#
include
"
AudioChannelService
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
DocumentInlines
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
CSSEnabledState
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
IdentifierMapEntry
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
plstr
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsNumberControlFrame
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsScreen
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
FullscreenChange
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
CSPDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicy
.
h
"
#
include
"
mozilla
/
dom
/
FramingChecker
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSharedElement
.
h
"
#
include
"
mozilla
/
dom
/
Navigator
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
TreeOrderedArrayInlines
.
h
"
#
include
"
mozilla
/
dom
/
ResizeObserver
.
h
"
#
include
"
mozilla
/
dom
/
ResizeObserverController
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerContainer
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
ShadowIncludingTreeIterator
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetList
.
h
"
#
include
"
mozilla
/
dom
/
SVGUseElement
.
h
"
#
include
"
mozilla
/
net
/
CookieSettings
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
mozilla
/
dom
/
CDATASection
.
h
"
#
include
"
mozilla
/
dom
/
ProcessingInstruction
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIBrowserChild
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
TreeWalker
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsIRefreshURI
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIRequestContext
.
h
"
#
include
"
nsStyleSheetService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIInputStreamChannel
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIPrivateBrowsingChannel
.
h
"
#
include
"
ExpandedPrincipal
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsICookiePermission
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIContentSink
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIDocumentLoaderFactory
.
h
"
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
mozilla
/
dom
/
PageTransitionEvent
.
h
"
#
include
"
mozilla
/
dom
/
StyleRuleChangeEvent
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetChangeEvent
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetApplicableStateChangeEvent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLinkElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPService
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsHTMLCSSStyleSheet
.
h
"
#
include
"
mozilla
/
dom
/
DOMImplementation
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Comment
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCollectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLElementBinding
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
imgILoader
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
mozilla
/
dom
/
AnimatableBinding
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ClientState
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentL10n
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
dom
/
MediaQueryList
.
h
"
#
include
"
mozilla
/
dom
/
NodeFilterBinding
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
WebComponentsBinding
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistryBinding
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
nsFrame
.
h
"
#
include
"
nsDOMCaretPosition
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsITextControlElement
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsISecurityConsoleMessage
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
mozilla
/
dom
/
XPathEvaluator
.
h
"
#
include
"
mozilla
/
dom
/
XPathNSResolverBinding
.
h
"
#
include
"
mozilla
/
dom
/
XPathResult
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIDocumentActivity
.
h
"
#
include
"
nsIStructuredCloneContainer
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
mozilla
/
dom
/
Location
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
dom
/
SVGDocument
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
ifdef
MOZ_XUL
#
include
"
mozilla
/
dom
/
XULBroadcastManager
.
h
"
#
include
"
mozilla
/
dom
/
XULPersist
.
h
"
#
include
"
nsIXULWindow
.
h
"
#
include
"
nsIChromeRegistry
.
h
"
#
include
"
nsXULPrototypeDocument
.
h
"
#
include
"
nsXULCommandDispatcher
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
BoxObject
.
h
"
#
include
"
mozilla
/
DocLoadingTimelineMarker
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
nsISpeculativeConnect
.
h
"
#
include
"
mozilla
/
MediaManager
.
h
"
#
include
"
AutoplayPolicy
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
PendingFullscreenEvent
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
MobileViewportManager
.
h
"
#
include
"
NodeUbiReporting
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
mozilla
/
net
/
ChannelEventQueue
.
h
"
#
include
"
mozilla
/
net
/
RequestContextService
.
h
"
#
include
"
StorageAccessPermissionRequest
.
h
"
#
include
"
mozilla
/
dom
/
WindowProxyHolder
.
h
"
#
include
"
ThirdPartyUtil
.
h
"
#
define
XML_DECLARATION_BITS_DECLARATION_EXISTS
(
1
<
<
0
)
#
define
XML_DECLARATION_BITS_ENCODING_EXISTS
(
1
<
<
1
)
#
define
XML_DECLARATION_BITS_STANDALONE_EXISTS
(
1
<
<
2
)
#
define
XML_DECLARATION_BITS_STANDALONE_YES
(
1
<
<
3
)
extern
bool
sDisablePrefetchHTTPSPref
;
mozilla
:
:
LazyLogModule
gPageCacheLog
(
"
PageCache
"
)
;
namespace
mozilla
{
namespace
dom
{
typedef
nsTArray
<
Link
*
>
LinkArray
;
static
LazyLogModule
gDocumentLeakPRLog
(
"
DocumentLeak
"
)
;
static
LazyLogModule
gCspPRLog
(
"
CSP
"
)
;
LazyLogModule
gUserInteractionPRLog
(
"
UserInteraction
"
)
;
static
nsresult
GetHttpChannelHelper
(
nsIChannel
*
aChannel
nsIHttpChannel
*
*
aHttpChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multipart
=
do_QueryInterface
(
aChannel
)
;
if
(
!
multipart
)
{
*
aHttpChannel
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsresult
rv
=
multipart
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
httpChannel
=
do_QueryInterface
(
baseChannel
)
;
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
}
#
define
NAME_NOT_VALID
(
(
nsSimpleContentList
*
)
1
)
IdentifierMapEntry
:
:
IdentifierMapEntry
(
const
IdentifierMapEntry
:
:
AtomOrString
&
aKey
)
:
mKey
(
aKey
)
{
}
IdentifierMapEntry
:
:
IdentifierMapEntry
(
const
IdentifierMapEntry
:
:
AtomOrString
*
aKey
)
:
mKey
(
aKey
?
*
aKey
:
nullptr
)
{
}
IdentifierMapEntry
:
:
~
IdentifierMapEntry
(
)
{
}
IdentifierMapEntry
:
:
IdentifierMapEntry
(
IdentifierMapEntry
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
mIdContentList
(
std
:
:
move
(
aOther
.
mIdContentList
)
)
mNameContentList
(
std
:
:
move
(
aOther
.
mNameContentList
)
)
mChangeCallbacks
(
std
:
:
move
(
aOther
.
mChangeCallbacks
)
)
mImageElement
(
std
:
:
move
(
aOther
.
mImageElement
)
)
{
}
void
IdentifierMapEntry
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mIdentifierMap
mNameContentList
"
)
;
aCallback
-
>
NoteXPCOMChild
(
static_cast
<
nsINodeList
*
>
(
mNameContentList
)
)
;
if
(
mImageElement
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mIdentifierMap
mImageElement
element
"
)
;
nsIContent
*
imageElement
=
mImageElement
;
aCallback
-
>
NoteXPCOMChild
(
imageElement
)
;
}
}
bool
IdentifierMapEntry
:
:
IsEmpty
(
)
{
return
mIdContentList
-
>
IsEmpty
(
)
&
&
!
mNameContentList
&
&
!
mChangeCallbacks
&
&
!
mImageElement
;
}
bool
IdentifierMapEntry
:
:
HasNameElement
(
)
const
{
return
mNameContentList
&
&
mNameContentList
-
>
Length
(
)
!
=
0
;
}
void
IdentifierMapEntry
:
:
AddContentChangeCallback
(
Document
:
:
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
{
if
(
!
mChangeCallbacks
)
{
mChangeCallbacks
=
new
nsTHashtable
<
ChangeCallbackEntry
>
;
}
ChangeCallback
cc
=
{
aCallback
aData
aForImage
}
;
mChangeCallbacks
-
>
PutEntry
(
cc
)
;
}
void
IdentifierMapEntry
:
:
RemoveContentChangeCallback
(
Document
:
:
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
{
if
(
!
mChangeCallbacks
)
return
;
ChangeCallback
cc
=
{
aCallback
aData
aForImage
}
;
mChangeCallbacks
-
>
RemoveEntry
(
cc
)
;
if
(
mChangeCallbacks
-
>
Count
(
)
=
=
0
)
{
mChangeCallbacks
=
nullptr
;
}
}
void
IdentifierMapEntry
:
:
FireChangeCallbacks
(
Element
*
aOldElement
Element
*
aNewElement
bool
aImageOnly
)
{
if
(
!
mChangeCallbacks
)
return
;
for
(
auto
iter
=
mChangeCallbacks
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
IdentifierMapEntry
:
:
ChangeCallbackEntry
*
entry
=
iter
.
Get
(
)
;
if
(
entry
-
>
mKey
.
mForImage
?
(
mImageElement
&
&
!
aImageOnly
)
:
aImageOnly
)
{
continue
;
}
if
(
!
entry
-
>
mKey
.
mCallback
(
aOldElement
aNewElement
entry
-
>
mKey
.
mData
)
)
{
iter
.
Remove
(
)
;
}
}
}
void
IdentifierMapEntry
:
:
AddIdElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
"
Must
have
element
"
)
;
MOZ_ASSERT
(
!
mIdContentList
-
>
Contains
(
nullptr
)
"
Why
is
null
in
our
list
?
"
)
;
size_t
index
=
mIdContentList
.
Insert
(
*
aElement
)
;
if
(
index
=
=
0
)
{
Element
*
oldElement
=
mIdContentList
-
>
SafeElementAt
(
1
)
;
FireChangeCallbacks
(
oldElement
aElement
)
;
}
}
void
IdentifierMapEntry
:
:
RemoveIdElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
"
Missing
element
"
)
;
NS_ASSERTION
(
!
aElement
-
>
OwnerDoc
(
)
-
>
IsHTMLDocument
(
)
|
|
mIdContentList
-
>
Contains
(
aElement
)
"
Removing
id
entry
that
doesn
'
t
exist
"
)
;
Element
*
currentElement
=
mIdContentList
-
>
SafeElementAt
(
0
)
;
mIdContentList
.
RemoveElement
(
*
aElement
)
;
if
(
currentElement
=
=
aElement
)
{
FireChangeCallbacks
(
currentElement
mIdContentList
-
>
SafeElementAt
(
0
)
)
;
}
}
void
IdentifierMapEntry
:
:
SetImageElement
(
Element
*
aElement
)
{
Element
*
oldElement
=
GetImageIdElement
(
)
;
mImageElement
=
aElement
;
Element
*
newElement
=
GetImageIdElement
(
)
;
if
(
oldElement
!
=
newElement
)
{
FireChangeCallbacks
(
oldElement
newElement
true
)
;
}
}
namespace
dom
{
class
SimpleHTMLCollection
final
:
public
nsSimpleContentList
public
nsIHTMLCollection
{
public
:
explicit
SimpleHTMLCollection
(
nsINode
*
aRoot
)
:
nsSimpleContentList
(
aRoot
)
{
}
NS_DECL_ISUPPORTS_INHERITED
virtual
nsINode
*
GetParentObject
(
)
override
{
return
nsSimpleContentList
:
:
GetParentObject
(
)
;
}
virtual
uint32_t
Length
(
)
override
{
return
nsSimpleContentList
:
:
Length
(
)
;
}
virtual
Element
*
GetElementAt
(
uint32_t
aIndex
)
override
{
return
mElements
.
SafeElementAt
(
aIndex
)
-
>
AsElement
(
)
;
}
virtual
Element
*
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
override
{
aFound
=
false
;
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
aName
)
;
for
(
uint32_t
i
=
0
;
i
<
mElements
.
Length
(
)
;
i
+
+
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mElements
[
i
]
)
;
Element
*
element
=
mElements
[
i
]
-
>
AsElement
(
)
;
if
(
element
-
>
GetID
(
)
=
=
name
|
|
(
element
-
>
HasName
(
)
&
&
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
=
=
name
)
)
{
aFound
=
true
;
return
element
;
}
}
return
nullptr
;
}
virtual
void
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
override
{
AutoTArray
<
nsAtom
*
8
>
atoms
;
for
(
uint32_t
i
=
0
;
i
<
mElements
.
Length
(
)
;
i
+
+
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mElements
[
i
]
)
;
Element
*
element
=
mElements
[
i
]
-
>
AsElement
(
)
;
nsAtom
*
id
=
element
-
>
GetID
(
)
;
MOZ_ASSERT
(
id
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
id
&
&
!
atoms
.
Contains
(
id
)
)
{
atoms
.
AppendElement
(
id
)
;
}
if
(
element
-
>
HasName
(
)
)
{
nsAtom
*
name
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
;
MOZ_ASSERT
(
name
&
&
name
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
name
&
&
!
atoms
.
Contains
(
name
)
)
{
atoms
.
AppendElement
(
name
)
;
}
}
}
nsString
*
names
=
aNames
.
AppendElements
(
atoms
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
atoms
.
Length
(
)
;
i
+
+
)
{
atoms
[
i
]
-
>
ToString
(
names
[
i
]
)
;
}
}
virtual
JSObject
*
GetWrapperPreserveColorInternal
(
)
override
{
return
nsWrapperCache
:
:
GetWrapperPreserveColor
(
)
;
}
virtual
void
PreserveWrapperInternal
(
nsISupports
*
aScriptObjectHolder
)
override
{
nsWrapperCache
:
:
PreserveWrapper
(
aScriptObjectHolder
)
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
HTMLCollection_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
using
nsBaseContentList
:
:
Item
;
private
:
virtual
~
SimpleHTMLCollection
(
)
{
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
SimpleHTMLCollection
nsSimpleContentList
nsIHTMLCollection
)
}
void
IdentifierMapEntry
:
:
AddNameElement
(
nsINode
*
aNode
Element
*
aElement
)
{
if
(
!
mNameContentList
)
{
mNameContentList
=
new
dom
:
:
SimpleHTMLCollection
(
aNode
)
;
}
mNameContentList
-
>
AppendElement
(
aElement
)
;
}
void
IdentifierMapEntry
:
:
RemoveNameElement
(
Element
*
aElement
)
{
if
(
mNameContentList
)
{
mNameContentList
-
>
RemoveElement
(
aElement
)
;
}
}
bool
IdentifierMapEntry
:
:
HasIdElementExposedAsHTMLDocumentProperty
(
)
{
Element
*
idElement
=
GetIdElement
(
)
;
return
idElement
&
&
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
idElement
)
;
}
size_t
IdentifierMapEntry
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mKey
.
mString
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
class
SubDocMapEntry
:
public
PLDHashEntryHdr
{
public
:
Element
*
mKey
;
dom
:
:
Document
*
mSubDocument
;
}
;
class
OnloadBlocker
final
:
public
nsIRequest
{
public
:
OnloadBlocker
(
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUEST
private
:
~
OnloadBlocker
(
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
OnloadBlocker
nsIRequest
)
NS_IMETHODIMP
OnloadBlocker
:
:
GetName
(
nsACString
&
aResult
)
{
aResult
.
AssignLiteral
(
"
about
:
document
-
onload
-
blocker
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
IsPending
(
bool
*
_retval
)
{
*
_retval
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetStatus
(
nsresult
*
status
)
{
*
status
=
NS_OK
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
Cancel
(
nsresult
status
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
Suspend
(
void
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
Resume
(
void
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
{
*
aLoadGroup
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
{
*
aLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
SetLoadFlags
(
nsLoadFlags
aLoadFlags
)
{
return
NS_OK
;
}
namespace
dom
{
ExternalResourceMap
:
:
ExternalResourceMap
(
)
:
mHaveShutDown
(
false
)
{
}
Document
*
ExternalResourceMap
:
:
RequestResource
(
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
nsINode
*
aRequestingNode
Document
*
aDisplayDocument
ExternalResourceLoad
*
*
aPendingLoad
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aRequestingNode
"
Must
have
a
node
"
)
;
*
aPendingLoad
=
nullptr
;
if
(
mHaveShutDown
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
clone
;
nsresult
rv
=
NS_GetURIWithoutRef
(
aURI
getter_AddRefs
(
clone
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
clone
)
{
return
nullptr
;
}
ExternalResource
*
resource
;
mMap
.
Get
(
clone
&
resource
)
;
if
(
resource
)
{
return
resource
-
>
mDocument
;
}
RefPtr
<
PendingLoad
>
&
loadEntry
=
mPendingLoads
.
GetOrInsert
(
clone
)
;
if
(
loadEntry
)
{
RefPtr
<
PendingLoad
>
load
(
loadEntry
)
;
load
.
forget
(
aPendingLoad
)
;
return
nullptr
;
}
RefPtr
<
PendingLoad
>
load
(
new
PendingLoad
(
aDisplayDocument
)
)
;
loadEntry
=
load
;
if
(
NS_FAILED
(
load
-
>
StartLoad
(
clone
aReferrer
aReferrerPolicy
aRequestingNode
)
)
)
{
AddExternalResource
(
clone
nullptr
nullptr
aDisplayDocument
)
;
}
else
{
load
.
forget
(
aPendingLoad
)
;
}
return
nullptr
;
}
void
ExternalResourceMap
:
:
EnumerateResources
(
Document
:
:
SubDocEnumFunc
aCallback
void
*
aData
)
{
for
(
auto
iter
=
mMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ExternalResourceMap
:
:
ExternalResource
*
resource
=
iter
.
UserData
(
)
;
if
(
resource
-
>
mDocument
&
&
!
aCallback
(
resource
-
>
mDocument
aData
)
)
{
break
;
}
}
}
void
ExternalResourceMap
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
const
{
for
(
auto
iter
=
mMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ExternalResourceMap
:
:
ExternalResource
*
resource
=
iter
.
UserData
(
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mExternalResourceMap
.
mMap
entry
"
"
-
>
mDocument
"
)
;
aCallback
-
>
NoteXPCOMChild
(
ToSupports
(
resource
-
>
mDocument
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mExternalResourceMap
.
mMap
entry
"
"
-
>
mViewer
"
)
;
aCallback
-
>
NoteXPCOMChild
(
resource
-
>
mViewer
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mExternalResourceMap
.
mMap
entry
"
"
-
>
mLoadGroup
"
)
;
aCallback
-
>
NoteXPCOMChild
(
resource
-
>
mLoadGroup
)
;
}
}
void
ExternalResourceMap
:
:
HideViewers
(
)
{
for
(
auto
iter
=
mMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
iter
.
UserData
(
)
-
>
mViewer
;
if
(
viewer
)
{
viewer
-
>
Hide
(
)
;
}
}
}
void
ExternalResourceMap
:
:
ShowViewers
(
)
{
for
(
auto
iter
=
mMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
=
iter
.
UserData
(
)
-
>
mViewer
;
if
(
viewer
)
{
viewer
-
>
Show
(
)
;
}
}
}
void
TransferZoomLevels
(
Document
*
aFromDoc
Document
*
aToDoc
)
{
MOZ_ASSERT
(
aFromDoc
&
&
aToDoc
"
transferring
zoom
levels
from
/
to
null
doc
"
)
;
nsPresContext
*
fromCtxt
=
aFromDoc
-
>
GetPresContext
(
)
;
if
(
!
fromCtxt
)
return
;
nsPresContext
*
toCtxt
=
aToDoc
-
>
GetPresContext
(
)
;
if
(
!
toCtxt
)
return
;
toCtxt
-
>
SetFullZoom
(
fromCtxt
-
>
GetFullZoom
(
)
)
;
toCtxt
-
>
SetTextZoom
(
fromCtxt
-
>
TextZoom
(
)
)
;
toCtxt
-
>
SetOverrideDPPX
(
fromCtxt
-
>
GetOverrideDPPX
(
)
)
;
}
void
TransferShowingState
(
Document
*
aFromDoc
Document
*
aToDoc
)
{
MOZ_ASSERT
(
aFromDoc
&
&
aToDoc
"
transferring
showing
state
from
/
to
null
doc
"
)
;
if
(
aFromDoc
-
>
IsShowing
(
)
)
{
aToDoc
-
>
OnPageShow
(
true
nullptr
)
;
}
}
nsresult
ExternalResourceMap
:
:
AddExternalResource
(
nsIURI
*
aURI
nsIContentViewer
*
aViewer
nsILoadGroup
*
aLoadGroup
Document
*
aDisplayDocument
)
{
MOZ_ASSERT
(
aURI
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
(
aViewer
&
&
aLoadGroup
)
|
|
(
!
aViewer
&
&
!
aLoadGroup
)
"
Must
have
both
or
neither
"
)
;
RefPtr
<
PendingLoad
>
load
;
mPendingLoads
.
Remove
(
aURI
getter_AddRefs
(
load
)
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
Document
>
doc
;
if
(
aViewer
)
{
doc
=
aViewer
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
Must
have
a
document
"
)
;
if
(
doc
-
>
IsXULDocument
(
)
)
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
else
{
doc
-
>
SetDisplayDocument
(
aDisplayDocument
)
;
aViewer
-
>
SetSticky
(
false
)
;
rv
=
aViewer
-
>
Init
(
nullptr
nsIntRect
(
0
0
0
0
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
aViewer
-
>
Open
(
nullptr
nullptr
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
doc
=
nullptr
;
aViewer
=
nullptr
;
aLoadGroup
=
nullptr
;
}
}
ExternalResource
*
newResource
=
new
ExternalResource
(
)
;
mMap
.
Put
(
aURI
newResource
)
;
newResource
-
>
mDocument
=
doc
;
newResource
-
>
mViewer
=
aViewer
;
newResource
-
>
mLoadGroup
=
aLoadGroup
;
if
(
doc
)
{
TransferZoomLevels
(
aDisplayDocument
doc
)
;
TransferShowingState
(
aDisplayDocument
doc
)
;
}
const
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
&
obs
=
load
-
>
Observers
(
)
;
for
(
uint32_t
i
=
0
;
i
<
obs
.
Length
(
)
;
+
+
i
)
{
obs
[
i
]
-
>
Observe
(
ToSupports
(
doc
)
"
external
-
resource
-
document
-
created
"
nullptr
)
;
}
return
rv
;
}
NS_IMPL_ISUPPORTS
(
ExternalResourceMap
:
:
PendingLoad
nsIStreamListener
nsIRequestObserver
)
NS_IMETHODIMP
ExternalResourceMap
:
:
PendingLoad
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
ExternalResourceMap
&
map
=
mDisplayDocument
-
>
ExternalResourceMap
(
)
;
if
(
map
.
HaveShutDown
(
)
)
{
return
NS_BINDING_ABORTED
;
}
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
SetupViewer
(
aRequest
getter_AddRefs
(
viewer
)
getter_AddRefs
(
loadGroup
)
)
;
nsresult
rv2
=
map
.
AddExternalResource
(
mURI
viewer
loadGroup
mDisplayDocument
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_FAILED
(
rv2
)
)
{
mTargetListener
=
nullptr
;
return
rv2
;
}
return
mTargetListener
-
>
OnStartRequest
(
aRequest
)
;
}
nsresult
ExternalResourceMap
:
:
PendingLoad
:
:
SetupViewer
(
nsIRequest
*
aRequest
nsIContentViewer
*
*
aViewer
nsILoadGroup
*
*
aLoadGroup
)
{
MOZ_ASSERT
(
!
mTargetListener
"
Unexpected
call
to
OnStartRequest
"
)
;
*
aViewer
=
nullptr
;
*
aLoadGroup
=
nullptr
;
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
aRequest
)
)
;
NS_ENSURE_TRUE
(
chan
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
if
(
NS_FAILED
(
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
)
|
|
!
requestSucceeded
)
{
return
NS_BINDING_ABORTED
;
}
}
nsAutoCString
type
;
chan
-
>
GetContentType
(
type
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
chan
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
nsCOMPtr
<
nsILoadGroup
>
newLoadGroup
=
do_CreateInstance
(
NS_LOADGROUP_CONTRACTID
)
;
NS_ENSURE_TRUE
(
newLoadGroup
NS_ERROR_OUT_OF_MEMORY
)
;
newLoadGroup
-
>
SetLoadGroup
(
loadGroup
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
loadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
newCallbacks
=
new
LoadgroupCallbacks
(
callbacks
)
;
newLoadGroup
-
>
SetNotificationCallbacks
(
newCallbacks
)
;
nsCOMPtr
<
nsICategoryManager
>
catMan
=
do_GetService
(
NS_CATEGORYMANAGER_CONTRACTID
)
;
NS_ENSURE_TRUE
(
catMan
NS_ERROR_NOT_AVAILABLE
)
;
nsCString
contractId
;
nsresult
rv
=
catMan
-
>
GetCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
type
contractId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docLoaderFactory
=
do_GetService
(
contractId
.
get
(
)
)
;
NS_ENSURE_TRUE
(
docLoaderFactory
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
docLoaderFactory
-
>
CreateInstance
(
"
external
-
resource
"
chan
newLoadGroup
type
nullptr
nullptr
getter_AddRefs
(
listener
)
getter_AddRefs
(
viewer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
viewer
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryInterface
(
listener
)
;
if
(
!
parser
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIContentSink
*
sink
=
parser
-
>
GetContentSink
(
)
;
nsCOMPtr
<
nsIXMLContentSink
>
xmlSink
=
do_QueryInterface
(
sink
)
;
if
(
!
xmlSink
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
listener
.
swap
(
mTargetListener
)
;
viewer
.
forget
(
aViewer
)
;
newLoadGroup
.
forget
(
aLoadGroup
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ExternalResourceMap
:
:
PendingLoad
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aCount
)
{
NS_ENSURE_TRUE
(
mTargetListener
NS_ERROR_FAILURE
)
;
if
(
mDisplayDocument
-
>
ExternalResourceMap
(
)
.
HaveShutDown
(
)
)
{
return
NS_BINDING_ABORTED
;
}
return
mTargetListener
-
>
OnDataAvailable
(
aRequest
aStream
aOffset
aCount
)
;
}
NS_IMETHODIMP
ExternalResourceMap
:
:
PendingLoad
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatus
)
{
if
(
mTargetListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
;
mTargetListener
.
swap
(
listener
)
;
return
listener
-
>
OnStopRequest
(
aRequest
aStatus
)
;
}
return
NS_OK
;
}
nsresult
ExternalResourceMap
:
:
PendingLoad
:
:
StartLoad
(
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
nsINode
*
aRequestingNode
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aRequestingNode
"
Must
have
a
node
"
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aRequestingNode
-
>
OwnerDoc
(
)
-
>
GetDocumentLoadGroup
(
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aURI
aRequestingNode
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
loadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
aReferrer
aReferrerPolicy
)
;
rv
=
httpChannel
-
>
SetReferrerInfoWithoutClone
(
referrerInfo
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
mURI
=
aURI
;
return
channel
-
>
AsyncOpen
(
this
)
;
}
NS_IMPL_ISUPPORTS
(
ExternalResourceMap
:
:
LoadgroupCallbacks
nsIInterfaceRequestor
)
#
define
IMPL_SHIM
(
_i
)
\
NS_IMPL_ISUPPORTS
(
ExternalResourceMap
:
:
LoadgroupCallbacks
:
:
_i
#
#
Shim
_i
)
IMPL_SHIM
(
nsILoadContext
)
IMPL_SHIM
(
nsIProgressEventSink
)
IMPL_SHIM
(
nsIChannelEventSink
)
IMPL_SHIM
(
nsIApplicationCacheContainer
)
#
undef
IMPL_SHIM
#
define
IID_IS
(
_i
)
aIID
.
Equals
(
NS_GET_IID
(
_i
)
)
#
define
TRY_SHIM
(
_i
)
\
PR_BEGIN_MACRO
\
if
(
IID_IS
(
_i
)
)
{
\
nsCOMPtr
<
_i
>
real
=
do_GetInterface
(
mCallbacks
)
;
\
if
(
!
real
)
{
\
return
NS_NOINTERFACE
;
\
}
\
nsCOMPtr
<
_i
>
shim
=
new
_i
#
#
Shim
(
this
real
)
;
\
shim
.
forget
(
aSink
)
;
\
return
NS_OK
;
\
}
\
PR_END_MACRO
NS_IMETHODIMP
ExternalResourceMap
:
:
LoadgroupCallbacks
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
if
(
mCallbacks
&
&
(
IID_IS
(
nsIPrompt
)
|
|
IID_IS
(
nsIAuthPrompt
)
|
|
IID_IS
(
nsIAuthPrompt2
)
|
|
IID_IS
(
nsIBrowserChild
)
)
)
{
return
mCallbacks
-
>
GetInterface
(
aIID
aSink
)
;
}
*
aSink
=
nullptr
;
TRY_SHIM
(
nsILoadContext
)
;
TRY_SHIM
(
nsIProgressEventSink
)
;
TRY_SHIM
(
nsIChannelEventSink
)
;
TRY_SHIM
(
nsIApplicationCacheContainer
)
;
return
NS_NOINTERFACE
;
}
#
undef
TRY_SHIM
#
undef
IID_IS
ExternalResourceMap
:
:
ExternalResource
:
:
~
ExternalResource
(
)
{
if
(
mViewer
)
{
mViewer
-
>
Close
(
nullptr
)
;
mViewer
-
>
Destroy
(
)
;
}
}
class
DOMStyleSheetSetList
final
:
public
DOMStringList
{
public
:
explicit
DOMStyleSheetSetList
(
Document
*
aDocument
)
;
void
Disconnect
(
)
{
mDocument
=
nullptr
;
}
virtual
void
EnsureFresh
(
)
override
;
protected
:
Document
*
mDocument
;
}
;
DOMStyleSheetSetList
:
:
DOMStyleSheetSetList
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
NS_ASSERTION
(
mDocument
"
Must
have
document
!
"
)
;
}
void
DOMStyleSheetSetList
:
:
EnsureFresh
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mNames
.
Clear
(
)
;
if
(
!
mDocument
)
{
return
;
}
size_t
count
=
mDocument
-
>
SheetCount
(
)
;
nsAutoString
title
;
for
(
size_t
index
=
0
;
index
<
count
;
index
+
+
)
{
StyleSheet
*
sheet
=
mDocument
-
>
SheetAt
(
index
)
;
NS_ASSERTION
(
sheet
"
Null
sheet
in
sheet
list
!
"
)
;
sheet
-
>
GetTitle
(
title
)
;
if
(
!
title
.
IsEmpty
(
)
&
&
!
mNames
.
Contains
(
title
)
&
&
!
Add
(
title
)
)
{
return
;
}
}
}
Document
:
:
SelectorCache
:
:
SelectorCache
(
nsIEventTarget
*
aEventTarget
)
:
nsExpirationTracker
<
SelectorCacheKey
4
>
(
1000
"
Document
:
:
SelectorCache
"
aEventTarget
)
{
}
Document
:
:
SelectorCache
:
:
~
SelectorCache
(
)
{
AgeAllGenerations
(
)
;
}
void
Document
:
:
SelectorCache
:
:
NotifyExpired
(
SelectorCacheKey
*
aSelector
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aSelector
)
;
RemoveObject
(
aSelector
)
;
mTable
.
Remove
(
aSelector
-
>
mKey
)
;
delete
aSelector
;
}
Document
:
:
FrameRequest
:
:
FrameRequest
(
FrameRequestCallback
&
aCallback
int32_t
aHandle
)
:
mCallback
(
&
aCallback
)
mHandle
(
aHandle
)
{
}
Document
:
:
Document
(
const
char
*
aContentType
)
:
nsINode
(
nullptr
)
DocumentOrShadowRoot
(
*
this
)
mReferrerPolicySet
(
false
)
mReferrerPolicy
(
mozilla
:
:
net
:
:
RP_Unset
)
mBlockAllMixedContent
(
false
)
mBlockAllMixedContentPreloads
(
false
)
mUpgradeInsecureRequests
(
false
)
mUpgradeInsecurePreloads
(
false
)
mCharacterSet
(
WINDOWS_1252_ENCODING
)
mCharacterSetSource
(
0
)
mParentDocument
(
nullptr
)
mCachedRootElement
(
nullptr
)
mNodeInfoManager
(
nullptr
)
#
ifdef
DEBUG
mStyledLinksCleared
(
false
)
#
endif
mBidiEnabled
(
false
)
mMayNeedFontPrefsUpdate
(
true
)
mMathMLEnabled
(
false
)
mIsInitialDocumentInWindow
(
false
)
mIgnoreDocGroupMismatches
(
false
)
mLoadedAsData
(
false
)
mLoadedAsInteractiveData
(
false
)
mMayStartLayout
(
true
)
mHaveFiredTitleChange
(
false
)
mIsShowing
(
false
)
mVisible
(
true
)
mRemovedFromDocShell
(
false
)
mAllowDNSPrefetch
(
true
)
mIsStaticDocument
(
false
)
mCreatingStaticClone
(
false
)
mInUnlinkOrDeletion
(
false
)
mHasHadScriptHandlingObject
(
false
)
mIsBeingUsedAsImage
(
false
)
mDocURISchemeIsChrome
(
false
)
mInChromeDocShell
(
false
)
mIsSyntheticDocument
(
false
)
mHasLinksToUpdateRunnable
(
false
)
mFlushingPendingLinkUpdates
(
false
)
mMayHaveDOMMutationObservers
(
false
)
mMayHaveAnimationObservers
(
false
)
mHasMixedActiveContentLoaded
(
false
)
mHasMixedActiveContentBlocked
(
false
)
mHasMixedDisplayContentLoaded
(
false
)
mHasMixedDisplayContentBlocked
(
false
)
mHasMixedContentObjectSubrequest
(
false
)
mHasCSP
(
false
)
mHasUnsafeEvalCSP
(
false
)
mHasUnsafeInlineCSP
(
false
)
mBFCacheDisallowed
(
false
)
mHasHadDefaultView
(
false
)
mStyleSheetChangeEventsEnabled
(
false
)
mIsSrcdocDocument
(
false
)
mHasDisplayDocument
(
false
)
mFontFaceSetDirty
(
true
)
mDidFireDOMContentLoaded
(
true
)
mHasScrollLinkedEffect
(
false
)
mFrameRequestCallbacksScheduled
(
false
)
mIsTopLevelContentDocument
(
false
)
mIsContentDocument
(
false
)
mDidCallBeginLoad
(
false
)
mAllowPaymentRequest
(
false
)
mEncodingMenuDisabled
(
false
)
mIsSVGGlyphsDocument
(
false
)
mInDestructor
(
false
)
mIsGoingAway
(
false
)
mInXBLUpdate
(
false
)
mNeedsReleaseAfterStackRefCntRelease
(
false
)
mStyleSetFilled
(
false
)
mQuirkSheetAdded
(
false
)
mContentEditableSheetAdded
(
false
)
mDesignModeSheetAdded
(
false
)
mSSApplicableStateNotificationPending
(
false
)
mMayHaveTitleElement
(
false
)
mDOMLoadingSet
(
false
)
mDOMInteractiveSet
(
false
)
mDOMCompleteSet
(
false
)
mAutoFocusFired
(
false
)
mScrolledToRefAlready
(
false
)
mChangeScrollPosWhenScrollingToRef
(
false
)
mHasWarnedAboutBoxObjects
(
false
)
mDelayFrameLoaderInitialization
(
false
)
mSynchronousDOMContentLoaded
(
false
)
mMaybeServiceWorkerControlled
(
false
)
mAllowZoom
(
false
)
mValidScaleFloat
(
false
)
mValidMaxScale
(
false
)
mScaleStrEmpty
(
false
)
mWidthStrEmpty
(
false
)
mParserAborted
(
false
)
mReportedUseCounters
(
false
)
mHasReportedShadowDOMUsage
(
false
)
mDocTreeHadAudibleMedia
(
false
)
mDocTreeHadPlayRevoked
(
false
)
mHasDelayedRefreshEvent
(
false
)
mLoadEventFiring
(
false
)
mSkipLoadEventAfterClose
(
false
)
mDisableCookieAccess
(
false
)
mPendingFullscreenRequests
(
0
)
mXMLDeclarationBits
(
0
)
mOnloadBlockCount
(
0
)
mAsyncOnloadBlockCount
(
0
)
mCompatMode
(
eCompatibility_FullStandards
)
mReadyState
(
ReadyState
:
:
READYSTATE_UNINITIALIZED
)
mAncestorIsLoading
(
false
)
#
ifdef
MOZILLA_INTERNAL_API
mVisibilityState
(
dom
:
:
VisibilityState
:
:
Hidden
)
#
else
mDummy
(
0
)
#
endif
mType
(
eUnknown
)
mDefaultElementType
(
0
)
mAllowXULXBL
(
eTriUnset
)
mBidiOptions
(
IBMBIDI_DEFAULT_BIDI_OPTIONS
)
mSandboxFlags
(
0
)
mPartID
(
0
)
mMarkedCCGeneration
(
0
)
mPresShell
(
nullptr
)
mSubtreeModifiedDepth
(
0
)
mPreloadPictureDepth
(
0
)
mEventsSuppressed
(
0
)
mIgnoreDestructiveWritesCounter
(
0
)
mFrameRequestCallbackCounter
(
0
)
mStaticCloneCount
(
0
)
mWindow
(
nullptr
)
mBFCacheEntry
(
nullptr
)
mInSyncOperationCount
(
0
)
mBlockDOMContentLoaded
(
0
)
mUseCounters
(
0
)
mChildDocumentUseCounters
(
0
)
mNotifiedPageForUseCounter
(
0
)
mUserHasInteracted
(
false
)
mHasUserInteractionTimerScheduled
(
false
)
mStackRefCnt
(
0
)
mUpdateNestLevel
(
0
)
mViewportType
(
Unknown
)
mSubDocuments
(
nullptr
)
mHeaderData
(
nullptr
)
mFlashClassification
(
FlashClassification
:
:
Unknown
)
mScrollAnchorAdjustmentLength
(
0
)
mScrollAnchorAdjustmentCount
(
0
)
mBoxObjectTable
(
nullptr
)
mCurrentOrientationAngle
(
0
)
mCurrentOrientationType
(
OrientationType
:
:
Portrait_primary
)
mServoRestyleRootDirtyBits
(
0
)
mThrowOnDynamicMarkupInsertionCounter
(
0
)
mIgnoreOpensDuringUnloadCounter
(
0
)
mDocLWTheme
(
Doc_Theme_Uninitialized
)
mSavedResolution
(
1
.
0f
)
mPendingInitialTranslation
(
false
)
mGeneration
(
0
)
mCachedTabSizeGeneration
(
0
)
mInRDMPane
(
false
)
{
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
created
"
this
)
)
;
SetIsInDocument
(
)
;
SetIsConnected
(
true
)
;
if
(
StaticPrefs
:
:
layout_css_use_counters_enabled
(
)
)
{
mStyleUseCounters
=
Servo_UseCounters_Create
(
)
.
Consume
(
)
;
}
SetContentTypeInternal
(
nsDependentCString
(
aContentType
)
)
;
SetDOMStringToNull
(
mLastStyleSheetSet
)
;
mPreloadPictureFoundSource
.
SetIsVoid
(
true
)
;
RecomputeLanguageFromCharset
(
)
;
}
void
Document
:
:
ClearAllBoxObjects
(
)
{
if
(
mBoxObjectTable
)
{
for
(
auto
iter
=
mBoxObjectTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsPIBoxObject
*
boxObject
=
iter
.
UserData
(
)
;
if
(
boxObject
)
{
boxObject
-
>
Clear
(
)
;
}
}
delete
mBoxObjectTable
;
mBoxObjectTable
=
nullptr
;
}
}
bool
Document
:
:
IsAboutPage
(
)
const
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
NodePrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
principal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
bool
isAboutScheme
=
true
;
if
(
uri
)
{
uri
-
>
SchemeIs
(
"
about
"
&
isAboutScheme
)
;
}
return
isAboutScheme
;
}
void
Document
:
:
ConstructUbiNode
(
void
*
storage
)
{
JS
:
:
ubi
:
:
Concrete
<
Document
>
:
:
construct
(
storage
this
)
;
}
Document
:
:
~
Document
(
)
{
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
destroyed
"
this
)
)
;
MOZ_ASSERT
(
!
IsTopLevelContentDocument
(
)
|
|
!
IsResourceDoc
(
)
"
Can
'
t
be
top
-
level
and
a
resource
doc
at
the
same
time
"
)
;
NS_ASSERTION
(
!
mIsShowing
"
Destroying
a
currently
-
showing
document
"
)
;
if
(
IsTopLevelContentDocument
(
)
)
{
if
(
!
IsAboutPage
(
)
)
{
uint32_t
pageLoaded
=
1
;
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_UNBLOCK_COUNTER
pageLoaded
)
;
enum
{
NO_MIXED_CONTENT
=
0
MIXED_DISPLAY_CONTENT
=
1
MIXED_ACTIVE_CONTENT
=
2
MIXED_DISPLAY_AND_ACTIVE_CONTENT
=
3
}
;
bool
mixedActiveLoaded
=
GetHasMixedActiveContentLoaded
(
)
;
bool
mixedActiveBlocked
=
GetHasMixedActiveContentBlocked
(
)
;
bool
mixedDisplayLoaded
=
GetHasMixedDisplayContentLoaded
(
)
;
bool
mixedDisplayBlocked
=
GetHasMixedDisplayContentBlocked
(
)
;
bool
hasMixedDisplay
=
(
mixedDisplayBlocked
|
|
mixedDisplayLoaded
)
;
bool
hasMixedActive
=
(
mixedActiveBlocked
|
|
mixedActiveLoaded
)
;
uint32_t
mixedContentLevel
=
NO_MIXED_CONTENT
;
if
(
hasMixedDisplay
&
&
hasMixedActive
)
{
mixedContentLevel
=
MIXED_DISPLAY_AND_ACTIVE_CONTENT
;
}
else
if
(
hasMixedActive
)
{
mixedContentLevel
=
MIXED_ACTIVE_CONTENT
;
}
else
if
(
hasMixedDisplay
)
{
mixedContentLevel
=
MIXED_DISPLAY_CONTENT
;
}
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_PAGE_LOAD
mixedContentLevel
)
;
if
(
mHasMixedContentObjectSubrequest
)
{
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_OBJECT_SUBREQUEST
1
)
;
}
else
{
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_OBJECT_SUBREQUEST
0
)
;
}
if
(
mHasCSP
)
{
Accumulate
(
Telemetry
:
:
CSP_DOCUMENTS_COUNT
1
)
;
}
if
(
mHasUnsafeInlineCSP
)
{
Accumulate
(
Telemetry
:
:
CSP_UNSAFE_INLINE_DOCUMENTS_COUNT
1
)
;
}
if
(
mHasUnsafeEvalCSP
)
{
Accumulate
(
Telemetry
:
:
CSP_UNSAFE_EVAL_DOCUMENTS_COUNT
1
)
;
}
if
(
MOZ_UNLIKELY
(
mMathMLEnabled
)
)
{
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MATHML_DOC_COUNT
1
)
;
}
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIA_PAGE_COUNT
1
)
;
if
(
mDocTreeHadAudibleMedia
)
{
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIA_PAGE_HAD_MEDIA_COUNT
1
)
;
}
if
(
mDocTreeHadPlayRevoked
)
{
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIA_PAGE_HAD_PLAY_REVOKED_COUNT
1
)
;
}
if
(
IsHTMLDocument
(
)
)
{
switch
(
GetCompatibilityMode
(
)
)
{
case
eCompatibility_FullStandards
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUIRKS_MODE
:
:
FullStandards
)
;
break
;
case
eCompatibility_AlmostStandards
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUIRKS_MODE
:
:
AlmostStandards
)
;
break
;
case
eCompatibility_NavQuirks
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUIRKS_MODE
:
:
NavQuirks
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
quirks
mode
"
)
;
break
;
}
}
}
}
ReportUseCounters
(
)
;
mInDestructor
=
true
;
mInUnlinkOrDeletion
=
true
;
mozilla
:
:
DropJSObjects
(
this
)
;
mObservers
.
Clear
(
)
;
mIntersectionObservers
.
Clear
(
)
;
if
(
mStyleSheetSetList
)
{
mStyleSheetSetList
-
>
Disconnect
(
)
;
}
if
(
mAnimationController
)
{
mAnimationController
-
>
Disconnect
(
)
;
}
MOZ_ASSERT
(
mTimelines
.
isEmpty
(
)
)
;
mParentDocument
=
nullptr
;
delete
mSubDocuments
;
mSubDocuments
=
nullptr
;
DestroyElementMaps
(
)
;
nsAutoScriptBlocker
scriptBlocker
;
InvalidateChildNodes
(
)
;
MOZ_ASSERT
(
!
HasChildren
(
)
)
;
mCachedRootElement
=
nullptr
;
for
(
auto
&
sheets
:
mAdditionalSheets
)
{
for
(
StyleSheet
*
sheet
:
sheets
)
{
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
}
}
if
(
mAttrStyleSheet
)
{
mAttrStyleSheet
-
>
SetOwningDocument
(
nullptr
)
;
}
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
UnsetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
}
if
(
mScriptLoader
)
{
mScriptLoader
-
>
DropDocumentReference
(
)
;
}
if
(
mCSSLoader
)
{
mCSSLoader
-
>
DropDocumentReference
(
)
;
}
if
(
mStyleImageLoader
)
{
mStyleImageLoader
-
>
DropDocumentReference
(
)
;
}
if
(
mXULBroadcastManager
)
{
mXULBroadcastManager
-
>
DropDocumentReference
(
)
;
}
if
(
mXULPersist
)
{
mXULPersist
-
>
DropDocumentReference
(
)
;
}
delete
mHeaderData
;
ClearAllBoxObjects
(
)
;
mPendingTitleChangeEvent
.
Revoke
(
)
;
mPlugins
.
Clear
(
)
;
MOZ_ASSERT
(
mDOMMediaQueryLists
.
isEmpty
(
)
"
must
not
have
media
query
lists
left
"
)
;
if
(
mNodeInfoManager
)
{
mNodeInfoManager
-
>
DropDocumentReference
(
)
;
}
if
(
mDocGroup
)
{
mDocGroup
-
>
RemoveDocument
(
this
)
;
}
UnlinkOriginalDocumentIfStatic
(
)
;
}
NS_INTERFACE_TABLE_HEAD
(
Document
)
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_TABLE_BEGIN
NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS
(
Document
nsISupports
nsINode
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsINode
)
NS_INTERFACE_TABLE_ENTRY
(
Document
Document
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsIScriptObjectPrincipal
)
NS_INTERFACE_TABLE_ENTRY
(
Document
mozilla
:
:
dom
:
:
EventTarget
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsISupportsWeakReference
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsIRadioGroupContainer
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsIMutationObserver
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsIApplicationCacheContainer
)
NS_INTERFACE_TABLE_END
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
Document
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Document
)
NS_IMETHODIMP_
(
MozExternalRefCountType
)
Document
:
:
Release
(
)
{
MOZ_ASSERT
(
0
!
=
mRefCnt
"
dup
release
"
)
;
NS_ASSERT_OWNINGTHREAD
(
Document
)
;
nsISupports
*
base
=
NS_CYCLE_COLLECTION_CLASSNAME
(
Document
)
:
:
Upcast
(
this
)
;
bool
shouldDelete
=
false
;
nsrefcnt
count
=
mRefCnt
.
decr
(
base
&
shouldDelete
)
;
NS_LOG_RELEASE
(
this
count
"
Document
"
)
;
if
(
count
=
=
0
)
{
if
(
mStackRefCnt
&
&
!
mNeedsReleaseAfterStackRefCntRelease
)
{
mNeedsReleaseAfterStackRefCntRelease
=
true
;
NS_ADDREF_THIS
(
)
;
return
mRefCnt
.
get
(
)
;
}
mRefCnt
.
incr
(
base
)
;
nsNodeUtils
:
:
LastRelease
(
this
)
;
mRefCnt
.
decr
(
base
)
;
if
(
shouldDelete
)
{
mRefCnt
.
stabilizeForDeletion
(
)
;
DeleteCycleCollectable
(
)
;
}
}
return
count
;
}
NS_IMETHODIMP_
(
void
)
Document
:
:
DeleteCycleCollectable
(
)
{
delete
this
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
Document
)
if
(
Element
:
:
CanSkip
(
tmp
aRemovingAllowed
)
)
{
EventListenerManager
*
elm
=
tmp
-
>
GetExistingListenerManager
(
)
;
if
(
elm
)
{
elm
-
>
MarkForCC
(
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
Document
)
return
Element
:
:
CanSkipInCC
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
Document
)
return
Element
:
:
CanSkipThis
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
Document
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
nsAutoCString
loadedAsData
;
if
(
tmp
-
>
IsLoadedAsData
(
)
)
{
loadedAsData
.
AssignLiteral
(
"
data
"
)
;
}
else
{
loadedAsData
.
AssignLiteral
(
"
normal
"
)
;
}
uint32_t
nsid
=
tmp
-
>
GetDefaultNamespaceID
(
)
;
nsAutoCString
uri
;
if
(
tmp
-
>
mDocumentURI
)
uri
=
tmp
-
>
mDocumentURI
-
>
GetSpecOrDefault
(
)
;
static
const
char
*
kNSURIs
[
]
=
{
"
(
[
none
]
)
"
"
(
xmlns
)
"
"
(
xml
)
"
"
(
xhtml
)
"
"
(
XLink
)
"
"
(
XSLT
)
"
"
(
XBL
)
"
"
(
MathML
)
"
"
(
RDF
)
"
"
(
XUL
)
"
}
;
if
(
nsid
<
ArrayLength
(
kNSURIs
)
)
{
SprintfLiteral
(
name
"
Document
%
s
%
s
%
s
"
loadedAsData
.
get
(
)
kNSURIs
[
nsid
]
uri
.
get
(
)
)
;
}
else
{
SprintfLiteral
(
name
"
Document
%
s
%
s
"
loadedAsData
.
get
(
)
uri
.
get
(
)
)
;
}
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
Document
tmp
-
>
mRefCnt
.
get
(
)
)
}
if
(
!
nsINode
:
:
Traverse
(
tmp
cb
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
if
(
tmp
-
>
mMaybeEndOutermostXBLUpdateRunner
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mMaybeEndOutermostXBLUpdateRunner
.
mObj
"
)
;
cb
.
NoteXPCOMChild
(
ToSupports
(
tmp
)
)
;
}
tmp
-
>
mExternalResourceMap
.
Traverse
(
&
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSecurityInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDisplayDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFontFaceSet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReadyForIdle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentL10n
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParser
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScriptGlobalObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListenerManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheetSetList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScriptLoader
)
DocumentOrShadowRoot
:
:
Traverse
(
tmp
cb
)
;
if
(
tmp
-
>
mBoxObjectTable
)
{
for
(
auto
iter
=
tmp
-
>
mBoxObjectTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mBoxObjectTable
entry
"
)
;
cb
.
NoteXPCOMChild
(
iter
.
UserData
(
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChannel
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLayoutHistoryState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOnloadBlocker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDOMImplementation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mImageMaps
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOrientationPendingPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOriginalDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCachedEncoder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStateObjectCached
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentTimeline
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPendingAnimationTracker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTemplateContentsOwner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChildrenCollection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mImages
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEmbeds
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLinks
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mForms
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScripts
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mApplets
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchors
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnonymousContents
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCommandDispatcher
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSuppressedEventListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPrototypeDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPreloadingImages
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mFrameRequestCallbacks
.
Length
(
)
;
+
+
i
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mFrameRequestCallbacks
[
i
]
"
)
;
cb
.
NoteXPCOMChild
(
tmp
-
>
mFrameRequestCallbacks
[
i
]
.
mCallback
)
;
}
if
(
tmp
-
>
mAnimationController
)
{
tmp
-
>
mAnimationController
-
>
Traverse
(
&
cb
)
;
}
if
(
tmp
-
>
mSubDocuments
)
{
for
(
auto
iter
=
tmp
-
>
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mSubDocuments
entry
-
>
mKey
"
)
;
cb
.
NoteXPCOMChild
(
entry
-
>
mKey
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mSubDocuments
entry
-
>
mSubDocument
"
)
;
cb
.
NoteXPCOMChild
(
ToSupports
(
entry
-
>
mSubDocument
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCSSLoader
)
for
(
MediaQueryList
*
mql
=
tmp
-
>
mDOMMediaQueryLists
.
getFirst
(
)
;
mql
;
mql
=
static_cast
<
LinkedListElement
<
MediaQueryList
>
*
>
(
mql
)
-
>
getNext
(
)
)
{
if
(
mql
-
>
HasListeners
(
)
&
&
NS_SUCCEEDED
(
mql
-
>
CheckCurrentGlobalCorrectness
(
)
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mDOMMediaQueryLists
item
"
)
;
cb
.
NoteXPCOMChild
(
mql
)
;
}
}
if
(
tmp
-
>
mResizeObserverController
)
{
tmp
-
>
mResizeObserverController
-
>
Traverse
(
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Document
)
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
Document
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Document
)
tmp
-
>
mInUnlinkOrDeletion
=
true
;
tmp
-
>
mExternalResourceMap
.
Shutdown
(
)
;
nsAutoScriptBlocker
scriptBlocker
;
nsINode
:
:
Unlink
(
tmp
)
;
while
(
tmp
-
>
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
tmp
-
>
GetLastChild
(
)
;
tmp
-
>
DisconnectChild
(
child
)
;
child
-
>
UnbindFromTree
(
)
;
}
tmp
-
>
UnlinkOriginalDocumentIfStatic
(
)
;
tmp
-
>
mCachedRootElement
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDisplayDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMaybeEndOutermostXBLUpdateRunner
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDOMImplementation
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mImageMaps
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCachedEncoder
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentTimeline
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPendingAnimationTracker
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTemplateContentsOwner
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChildrenCollection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mImages
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEmbeds
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLinks
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mForms
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScripts
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mApplets
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnchors
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOrientationPendingPromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFontFaceSet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReadyForIdle
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCommandDispatcher
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentL10n
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSuppressedEventListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPrototypeDocument
)
tmp
-
>
mParentDocument
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPreloadingImages
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIntersectionObservers
)
tmp
-
>
ClearAllBoxObjects
(
)
;
if
(
tmp
-
>
mListenerManager
)
{
tmp
-
>
mListenerManager
-
>
Disconnect
(
)
;
tmp
-
>
UnsetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
tmp
-
>
mListenerManager
=
nullptr
;
}
if
(
tmp
-
>
mStyleSheetSetList
)
{
tmp
-
>
mStyleSheetSetList
-
>
Disconnect
(
)
;
tmp
-
>
mStyleSheetSetList
=
nullptr
;
}
delete
tmp
-
>
mSubDocuments
;
tmp
-
>
mSubDocuments
=
nullptr
;
tmp
-
>
mFrameRequestCallbacks
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
!
tmp
-
>
mFrameRequestCallbacksScheduled
"
How
did
we
get
here
without
our
presshell
going
away
"
"
first
?
"
)
;
DocumentOrShadowRoot
:
:
Unlink
(
tmp
)
;
tmp
-
>
mExpandoAndGeneration
.
OwnerUnlinked
(
)
;
if
(
tmp
-
>
mAnimationController
)
{
tmp
-
>
mAnimationController
-
>
Unlink
(
)
;
}
tmp
-
>
mPendingTitleChangeEvent
.
Revoke
(
)
;
if
(
tmp
-
>
mCSSLoader
)
{
tmp
-
>
mCSSLoader
-
>
DropDocumentReference
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCSSLoader
)
}
for
(
MediaQueryList
*
mql
=
tmp
-
>
mDOMMediaQueryLists
.
getFirst
(
)
;
mql
;
)
{
MediaQueryList
*
next
=
static_cast
<
LinkedListElement
<
MediaQueryList
>
*
>
(
mql
)
-
>
getNext
(
)
;
mql
-
>
Disconnect
(
)
;
mql
=
next
;
}
tmp
-
>
mInUnlinkOrDeletion
=
false
;
if
(
tmp
-
>
mResizeObserverController
)
{
tmp
-
>
mResizeObserverController
-
>
Unlink
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
nsresult
Document
:
:
Init
(
)
{
if
(
mCSSLoader
|
|
mStyleImageLoader
|
|
mNodeInfoManager
|
|
mScriptLoader
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
nsINode
:
:
nsSlots
*
slots
=
Slots
(
)
;
slots
-
>
mMutationObservers
.
PrependElementUnlessExists
(
static_cast
<
nsIMutationObserver
*
>
(
this
)
)
;
mOnloadBlocker
=
new
OnloadBlocker
(
)
;
mCSSLoader
=
new
mozilla
:
:
css
:
:
Loader
(
this
)
;
mCSSLoader
-
>
SetCompatibilityMode
(
eCompatibility_FullStandards
)
;
mStyleImageLoader
=
new
mozilla
:
:
css
:
:
ImageLoader
(
this
)
;
mNodeInfoManager
=
new
nsNodeInfoManager
(
)
;
nsresult
rv
=
mNodeInfoManager
-
>
Init
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mNodeInfo
=
mNodeInfoManager
-
>
GetDocumentNodeInfo
(
)
;
NS_ENSURE_TRUE
(
mNodeInfo
NS_ERROR_OUT_OF_MEMORY
)
;
MOZ_ASSERT
(
mNodeInfo
-
>
NodeType
(
)
=
=
DOCUMENT_NODE
"
Bad
NodeType
in
aNodeInfo
"
)
;
NS_ASSERTION
(
OwnerDoc
(
)
=
=
this
"
Our
nodeinfo
is
busted
!
"
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
xpc
:
:
PrivilegedJunkScope
(
)
)
;
NS_ENSURE_TRUE
(
global
NS_ERROR_FAILURE
)
;
mScopeObject
=
do_GetWeakReference
(
global
)
;
MOZ_ASSERT
(
mScopeObject
)
;
mScriptLoader
=
new
dom
:
:
ScriptLoader
(
this
)
;
mFeaturePolicy
=
new
FeaturePolicy
(
this
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
NodePrincipal
(
)
)
;
mStyleSet
=
MakeUnique
<
ServoStyleSet
>
(
*
this
)
;
mozilla
:
:
HoldJSObjects
(
this
)
;
return
NS_OK
;
}
void
Document
:
:
DeleteAllProperties
(
)
{
PropertyTable
(
)
.
DeleteAllProperties
(
)
;
}
void
Document
:
:
DeleteAllPropertiesFor
(
nsINode
*
aNode
)
{
PropertyTable
(
)
.
DeleteAllPropertiesFor
(
aNode
)
;
}
bool
Document
:
:
IsVisibleConsideringAncestors
(
)
const
{
const
Document
*
parent
=
this
;
do
{
if
(
!
parent
-
>
IsVisible
(
)
)
{
return
false
;
}
}
while
(
(
parent
=
parent
-
>
GetParentDocument
(
)
)
)
;
return
true
;
}
void
Document
:
:
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsIPrincipal
>
storagePrincipal
;
if
(
aChannel
)
{
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
nsIScriptSecurityManager
*
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
securityManager
)
{
securityManager
-
>
GetChannelResultPrincipals
(
aChannel
getter_AddRefs
(
principal
)
getter_AddRefs
(
storagePrincipal
)
)
;
}
}
bool
equal
=
principal
-
>
Equals
(
storagePrincipal
)
;
principal
=
MaybeDowngradePrincipal
(
principal
)
;
if
(
equal
)
{
storagePrincipal
=
principal
;
}
else
{
storagePrincipal
=
MaybeDowngradePrincipal
(
storagePrincipal
)
;
}
ResetToURI
(
uri
aLoadGroup
principal
storagePrincipal
)
;
mDocumentTimeline
=
nullptr
;
nsCOMPtr
<
nsIPropertyBag2
>
bag
=
do_QueryInterface
(
aChannel
)
;
if
(
bag
)
{
nsCOMPtr
<
nsIURI
>
baseURI
;
bag
-
>
GetPropertyAsInterface
(
NS_LITERAL_STRING
(
"
baseURI
"
)
NS_GET_IID
(
nsIURI
)
getter_AddRefs
(
baseURI
)
)
;
if
(
baseURI
)
{
mDocumentBaseURI
=
baseURI
;
mChromeXHRDocBaseURI
=
nullptr
;
}
}
mChannel
=
aChannel
;
}
bool
PrincipalAllowsL10n
(
nsIPrincipal
*
principal
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
principal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
hasFlags
;
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_DANGEROUS_TO_LOAD
&
hasFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
hasFlags
)
{
return
true
;
}
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
hasFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
hasFlags
;
}
void
Document
:
:
DisconnectNodeTree
(
)
{
delete
mSubDocuments
;
mSubDocuments
=
nullptr
;
DestroyElementMaps
(
)
;
bool
oldVal
=
mInUnlinkOrDeletion
;
mInUnlinkOrDeletion
=
true
;
{
MOZ_AUTO_DOC_UPDATE
(
this
true
)
;
InvalidateChildNodes
(
)
;
while
(
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetLastChild
(
)
;
nsIContent
*
previousSibling
=
content
-
>
GetPreviousSibling
(
)
;
DisconnectChild
(
content
)
;
if
(
content
=
=
mCachedRootElement
)
{
mCachedRootElement
=
nullptr
;
}
nsNodeUtils
:
:
ContentRemoved
(
this
content
previousSibling
)
;
content
-
>
UnbindFromTree
(
)
;
}
MOZ_ASSERT
(
!
mCachedRootElement
"
After
removing
all
children
there
should
be
no
root
elem
"
)
;
}
mInUnlinkOrDeletion
=
oldVal
;
}
void
Document
:
:
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
)
{
MOZ_ASSERT
(
aURI
"
Null
URI
passed
to
ResetToURI
"
)
;
MOZ_ASSERT
(
!
!
aPrincipal
=
=
!
!
aStoragePrincipal
)
;
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
ResetToURI
%
s
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
mSecurityInfo
=
nullptr
;
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
if
(
!
aLoadGroup
|
|
group
!
=
aLoadGroup
)
{
mDocumentLoadGroup
=
nullptr
;
}
DisconnectNodeTree
(
)
;
ResetStylesheetsToURI
(
aURI
)
;
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
mListenerManager
=
nullptr
;
}
mDOMStyleSheets
=
nullptr
;
SetPrincipals
(
nullptr
nullptr
)
;
mOriginalURI
=
nullptr
;
SetDocumentURI
(
aURI
)
;
mChromeXHRDocURI
=
nullptr
;
mDocumentBaseURI
=
nullptr
;
mChromeXHRDocBaseURI
=
nullptr
;
if
(
aLoadGroup
)
{
mDocumentLoadGroup
=
do_GetWeakReference
(
aLoadGroup
)
;
if
(
IsContentDocument
(
)
)
{
nsCOMPtr
<
nsIRequestContextService
>
rcsvc
=
mozilla
:
:
net
:
:
RequestContextService
:
:
GetOrCreate
(
)
;
if
(
rcsvc
)
{
nsCOMPtr
<
nsIRequestContext
>
rc
;
rcsvc
-
>
GetRequestContextFromLoadGroup
(
aLoadGroup
getter_AddRefs
(
rc
)
)
;
if
(
rc
)
{
rc
-
>
BeginLoad
(
)
;
}
}
}
}
mLastModified
.
Truncate
(
)
;
SetContentTypeInternal
(
EmptyCString
(
)
)
;
mContentLanguage
.
Truncate
(
)
;
mBaseTarget
.
Truncate
(
)
;
mReferrer
.
Truncate
(
)
;
mXMLDeclarationBits
=
0
;
if
(
aPrincipal
)
{
SetPrincipals
(
aPrincipal
aStoragePrincipal
)
;
}
else
{
nsIScriptSecurityManager
*
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
securityManager
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
(
mDocumentContainer
)
;
if
(
!
loadContext
&
&
aLoadGroup
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
cbs
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
cbs
)
)
;
loadContext
=
do_GetInterface
(
cbs
)
;
}
MOZ_ASSERT
(
loadContext
"
must
have
a
load
context
or
pass
in
an
explicit
principal
"
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
securityManager
-
>
GetLoadContextCodebasePrincipal
(
mDocumentURI
loadContext
getter_AddRefs
(
principal
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetPrincipals
(
principal
principal
)
;
}
}
}
if
(
mFontFaceSet
)
{
mFontFaceSet
-
>
RefreshStandardFontLoadPrincipal
(
)
;
}
if
(
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
)
{
nsGlobalWindowInner
:
:
Cast
(
win
)
-
>
RefreshRealmPrincipal
(
)
;
}
}
already_AddRefed
<
nsIPrincipal
>
Document
:
:
MaybeDowngradePrincipal
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
aPrincipal
)
{
return
nullptr
;
}
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
basePrin
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Should
never
try
to
create
a
document
with
"
"
an
expanded
principal
"
)
;
auto
*
expanded
=
basePrin
-
>
As
<
ExpandedPrincipal
>
(
)
;
return
do_AddRef
(
expanded
-
>
AllowList
(
)
.
LastElement
(
)
)
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
if
(
mDocumentContainer
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDocShellItem
;
mDocumentContainer
-
>
GetParent
(
getter_AddRefs
(
parentDocShellItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
parentDocShell
=
do_QueryInterface
(
parentDocShellItem
)
;
if
(
parentDocShell
)
{
nsCOMPtr
<
Document
>
parentDoc
;
parentDoc
=
parentDocShell
-
>
GetDocument
(
)
;
if
(
!
parentDoc
|
|
!
nsContentUtils
:
:
IsSystemPrincipal
(
parentDoc
-
>
NodePrincipal
(
)
)
)
{
nsCOMPtr
<
nsIPrincipal
>
nullPrincipal
=
do_CreateInstance
(
"
mozilla
.
org
/
nullprincipal
;
1
"
)
;
return
nullPrincipal
.
forget
(
)
;
}
}
}
}
nsCOMPtr
<
nsIPrincipal
>
principal
(
aPrincipal
)
;
return
principal
.
forget
(
)
;
}
size_t
Document
:
:
FindDocStyleSheetInsertionPoint
(
const
StyleSheet
&
aSheet
)
{
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
int32_t
newDocIndex
=
IndexOfSheet
(
aSheet
)
;
size_t
count
=
mStyleSet
-
>
SheetCount
(
StyleOrigin
:
:
Author
)
;
size_t
index
=
0
;
for
(
;
index
<
count
;
index
+
+
)
{
auto
*
sheet
=
mStyleSet
-
>
SheetAt
(
StyleOrigin
:
:
Author
index
)
;
MOZ_ASSERT
(
sheet
)
;
int32_t
sheetDocIndex
=
IndexOfSheet
(
*
sheet
)
;
if
(
sheetDocIndex
>
newDocIndex
)
break
;
if
(
sheetDocIndex
<
0
)
{
if
(
sheetService
)
{
auto
&
authorSheets
=
*
sheetService
-
>
AuthorStyleSheets
(
)
;
if
(
authorSheets
.
IndexOf
(
sheet
)
!
=
authorSheets
.
NoIndex
)
{
break
;
}
}
if
(
sheet
=
=
GetFirstAdditionalAuthorSheet
(
)
)
{
break
;
}
}
}
return
index
;
}
void
Document
:
:
RemoveDocStyleSheetsFromStyleSets
(
)
{
MOZ_ASSERT
(
mStyleSetFilled
)
;
for
(
StyleSheet
*
sheet
:
Reversed
(
mStyleSheets
)
)
{
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
if
(
sheet
-
>
IsApplicable
(
)
)
{
mStyleSet
-
>
RemoveDocStyleSheet
(
sheet
)
;
}
}
}
void
Document
:
:
RemoveStyleSheetsFromStyleSets
(
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
StyleOrigin
aType
)
{
for
(
StyleSheet
*
sheet
:
Reversed
(
aSheets
)
)
{
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
if
(
mStyleSetFilled
&
&
sheet
-
>
IsApplicable
(
)
)
{
mStyleSet
-
>
RemoveStyleSheet
(
aType
sheet
)
;
}
}
}
void
Document
:
:
ResetStylesheetsToURI
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
if
(
mStyleSetFilled
)
{
RemoveDocStyleSheetsFromStyleSets
(
)
;
RemoveStyleSheetsFromStyleSets
(
mAdditionalSheets
[
eAgentSheet
]
StyleOrigin
:
:
UserAgent
)
;
RemoveStyleSheetsFromStyleSets
(
mAdditionalSheets
[
eUserSheet
]
StyleOrigin
:
:
User
)
;
RemoveStyleSheetsFromStyleSets
(
mAdditionalSheets
[
eAuthorSheet
]
StyleOrigin
:
:
Author
)
;
if
(
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
)
{
RemoveStyleSheetsFromStyleSets
(
*
sheetService
-
>
AuthorStyleSheets
(
)
StyleOrigin
:
:
Author
)
;
}
}
mStyleSheets
.
Clear
(
)
;
for
(
auto
&
sheets
:
mAdditionalSheets
)
{
sheets
.
Clear
(
)
;
}
if
(
mAttrStyleSheet
)
{
mAttrStyleSheet
-
>
Reset
(
)
;
mAttrStyleSheet
-
>
SetOwningDocument
(
this
)
;
}
else
{
mAttrStyleSheet
=
new
nsHTMLStyleSheet
(
this
)
;
}
if
(
!
mStyleAttrStyleSheet
)
{
mStyleAttrStyleSheet
=
new
nsHTMLCSSStyleSheet
(
)
;
}
if
(
mStyleSetFilled
)
{
FillStyleSetDocumentSheets
(
)
;
if
(
mStyleSet
-
>
StyleSheetsHaveChanged
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
}
static
void
AppendSheetsToStyleSet
(
ServoStyleSet
*
aStyleSet
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
StyleOrigin
aOrigin
)
{
for
(
StyleSheet
*
sheet
:
Reversed
(
aSheets
)
)
{
aStyleSet
-
>
AppendStyleSheet
(
aOrigin
sheet
)
;
}
}
void
Document
:
:
FillStyleSetUserAndUASheets
(
)
{
auto
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
MOZ_ASSERT
(
sheetService
"
should
never
be
creating
a
StyleSet
after
the
style
sheet
"
"
service
has
gone
"
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
UserStyleSheets
(
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
User
sheet
)
;
}
StyleSheet
*
sheet
=
IsInChromeDocShell
(
)
?
cache
-
>
GetUserChromeSheet
(
)
:
cache
-
>
GetUserContentSheet
(
)
;
if
(
sheet
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
User
sheet
)
;
}
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
UASheet
(
)
)
;
if
(
MOZ_LIKELY
(
NodeInfoManager
(
)
-
>
MathMLEnabled
(
)
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
MathMLSheet
(
)
)
;
}
if
(
MOZ_LIKELY
(
NodeInfoManager
(
)
-
>
SVGEnabled
(
)
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
SVGSheet
(
)
)
;
}
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
HTMLSheet
(
)
)
;
if
(
nsLayoutUtils
:
:
ShouldUseNoFramesSheet
(
this
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
NoFramesSheet
(
)
)
;
}
if
(
nsLayoutUtils
:
:
ShouldUseNoScriptSheet
(
this
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
NoScriptSheet
(
)
)
;
}
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
CounterStylesSheet
(
)
)
;
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
MinimalXULSheet
(
)
)
;
if
(
LoadsFullXULStyleSheetUpFront
(
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
XULSheet
(
)
)
;
}
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
FormsSheet
(
)
)
;
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
ScrollbarsSheet
(
)
)
;
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
PluginProblemSheet
(
)
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
AgentStyleSheets
(
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
sheet
)
;
}
MOZ_ASSERT
(
!
mQuirkSheetAdded
)
;
if
(
NeedsQuirksSheet
(
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
QuirkSheet
(
)
)
;
mQuirkSheetAdded
=
true
;
}
}
void
Document
:
:
FillStyleSet
(
)
{
MOZ_ASSERT
(
!
mStyleSetFilled
)
;
FillStyleSetUserAndUASheets
(
)
;
FillStyleSetDocumentSheets
(
)
;
mStyleSetFilled
=
true
;
}
void
Document
:
:
RemoveContentEditableStyleSheets
(
)
{
MOZ_ASSERT
(
IsHTMLOrXHTML
(
)
)
;
auto
*
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
bool
changed
=
false
;
if
(
mDesignModeSheetAdded
)
{
mStyleSet
-
>
RemoveStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
DesignModeSheet
(
)
)
;
mDesignModeSheetAdded
=
false
;
changed
=
true
;
}
if
(
mContentEditableSheetAdded
)
{
mStyleSet
-
>
RemoveStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
ContentEditableSheet
(
)
)
;
mContentEditableSheetAdded
=
false
;
changed
=
true
;
}
if
(
changed
)
{
MOZ_ASSERT
(
mStyleSetFilled
)
;
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
AddContentEditableStyleSheetsToStyleSet
(
bool
aDesignMode
)
{
MOZ_ASSERT
(
IsHTMLOrXHTML
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mStyleSetFilled
"
Caller
should
ensure
we
'
re
being
rendered
"
)
;
auto
*
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
bool
changed
=
false
;
if
(
!
mContentEditableSheetAdded
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
ContentEditableSheet
(
)
)
;
mContentEditableSheetAdded
=
true
;
changed
=
true
;
}
if
(
mDesignModeSheetAdded
!
=
aDesignMode
)
{
if
(
mDesignModeSheetAdded
)
{
mStyleSet
-
>
RemoveStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
DesignModeSheet
(
)
)
;
}
else
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
cache
-
>
DesignModeSheet
(
)
)
;
}
mDesignModeSheetAdded
=
!
mDesignModeSheetAdded
;
changed
=
true
;
}
if
(
changed
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
FillStyleSetDocumentSheets
(
)
{
MOZ_ASSERT
(
mStyleSet
-
>
SheetCount
(
StyleOrigin
:
:
Author
)
=
=
0
"
Style
set
already
has
document
sheets
?
"
)
;
for
(
StyleSheet
*
sheet
:
Reversed
(
mStyleSheets
)
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
mStyleSet
-
>
AddDocStyleSheet
(
sheet
)
;
}
}
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
AuthorStyleSheets
(
)
)
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
Author
sheet
)
;
}
AppendSheetsToStyleSet
(
mStyleSet
.
get
(
)
mAdditionalSheets
[
eAgentSheet
]
StyleOrigin
:
:
UserAgent
)
;
AppendSheetsToStyleSet
(
mStyleSet
.
get
(
)
mAdditionalSheets
[
eUserSheet
]
StyleOrigin
:
:
User
)
;
AppendSheetsToStyleSet
(
mStyleSet
.
get
(
)
mAdditionalSheets
[
eAuthorSheet
]
StyleOrigin
:
:
Author
)
;
}
void
Document
:
:
CompatibilityModeChanged
(
)
{
MOZ_ASSERT
(
IsHTMLOrXHTML
(
)
)
;
CSSLoader
(
)
-
>
SetCompatibilityMode
(
mCompatMode
)
;
mStyleSet
-
>
CompatibilityModeChanged
(
)
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
if
(
!
mStyleSetFilled
)
{
MOZ_ASSERT
(
!
mQuirkSheetAdded
)
;
return
;
}
if
(
mQuirkSheetAdded
=
=
NeedsQuirksSheet
(
)
)
{
return
;
}
auto
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
StyleSheet
*
sheet
=
cache
-
>
QuirkSheet
(
)
;
if
(
mQuirkSheetAdded
)
{
mStyleSet
-
>
RemoveStyleSheet
(
StyleOrigin
:
:
UserAgent
sheet
)
;
}
else
{
mStyleSet
-
>
AppendStyleSheet
(
StyleOrigin
:
:
UserAgent
sheet
)
;
}
mQuirkSheetAdded
=
!
mQuirkSheetAdded
;
ApplicableStylesChanged
(
)
;
}
static
void
WarnIfSandboxIneffective
(
nsIDocShell
*
aDocShell
uint32_t
aSandboxFlags
nsIChannel
*
aChannel
)
{
if
(
aSandboxFlags
&
SANDBOXED_NAVIGATION
&
&
!
(
aSandboxFlags
&
SANDBOXED_SCRIPTS
)
&
&
!
(
aSandboxFlags
&
SANDBOXED_ORIGIN
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
aDocShell
-
>
GetSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
parentDocShell
=
do_QueryInterface
(
parentAsItem
)
;
if
(
!
parentDocShell
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
grandParentAsItem
;
parentDocShell
-
>
GetSameTypeParent
(
getter_AddRefs
(
grandParentAsItem
)
)
;
if
(
grandParentAsItem
)
{
return
;
}
nsCOMPtr
<
nsIChannel
>
parentChannel
;
parentDocShell
-
>
GetCurrentDocumentChannel
(
getter_AddRefs
(
parentChannel
)
)
;
if
(
!
parentChannel
)
{
return
;
}
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
aChannel
parentChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
Document
>
parentDocument
=
parentDocShell
-
>
GetDocument
(
)
;
nsCOMPtr
<
nsIURI
>
iframeUri
;
parentChannel
-
>
GetURI
(
getter_AddRefs
(
iframeUri
)
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Iframe
Sandbox
"
)
parentDocument
nsContentUtils
:
:
eSECURITY_PROPERTIES
"
BothAllowScriptsAndSameOriginPresent
"
nullptr
0
iframeUri
)
;
}
}
bool
Document
:
:
IsSynthesized
(
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
?
mChannel
-
>
LoadInfo
(
)
:
nullptr
;
return
loadInfo
&
&
loadInfo
-
>
GetServiceWorkerTaintingSynthesized
(
)
;
}
bool
Document
:
:
IsCallerChromeOrAddon
(
JSContext
*
aCx
JSObject
*
aObject
)
{
nsIPrincipal
*
principal
=
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
;
return
principal
&
&
(
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
|
|
principal
-
>
GetIsAddonOrExpandedAddonPrincipal
(
)
)
;
}
nsresult
Document
:
:
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
)
{
if
(
MOZ_LOG_TEST
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
StartDocumentLoad
%
s
"
this
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
}
MOZ_ASSERT
(
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_UNINITIALIZED
"
Bad
readyState
"
)
;
SetReadyStateInternal
(
READYSTATE_LOADING
)
;
if
(
nsCRT
:
:
strcmp
(
kLoadAsData
aCommand
)
=
=
0
)
{
mLoadedAsData
=
true
;
ScriptLoader
(
)
-
>
SetEnabled
(
false
)
;
CSSLoader
(
)
-
>
SetEnabled
(
false
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
"
external
-
resource
"
aCommand
)
=
=
0
)
{
ScriptLoader
(
)
-
>
SetEnabled
(
false
)
;
}
mMayStartLayout
=
false
;
MOZ_ASSERT
(
!
mReadyForIdle
"
We
should
never
hit
DOMContentLoaded
before
this
point
"
)
;
if
(
aReset
)
{
Reset
(
aChannel
aLoadGroup
)
;
}
nsAutoCString
contentType
;
nsCOMPtr
<
nsIPropertyBag2
>
bag
=
do_QueryInterface
(
aChannel
)
;
if
(
(
bag
&
&
NS_SUCCEEDED
(
bag
-
>
GetPropertyAsACString
(
NS_LITERAL_STRING
(
"
contentType
"
)
contentType
)
)
)
|
|
NS_SUCCEEDED
(
aChannel
-
>
GetContentType
(
contentType
)
)
)
{
nsACString
:
:
const_iterator
start
end
semicolon
;
contentType
.
BeginReading
(
start
)
;
contentType
.
EndReading
(
end
)
;
semicolon
=
start
;
FindCharInReadable
(
'
;
'
semicolon
end
)
;
SetContentTypeInternal
(
Substring
(
start
semicolon
)
)
;
}
RetrieveRelevantHeaders
(
aChannel
)
;
mChannel
=
aChannel
;
nsCOMPtr
<
nsIInputStreamChannel
>
inStrmChan
=
do_QueryInterface
(
mChannel
)
;
if
(
inStrmChan
)
{
bool
isSrcdocChannel
;
inStrmChan
-
>
GetIsSrcdocChannel
(
&
isSrcdocChannel
)
;
if
(
isSrcdocChannel
)
{
mIsSrcdocDocument
=
true
;
}
}
if
(
mChannel
)
{
nsLoadFlags
loadFlags
;
mChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
bool
isDocument
=
false
;
mChannel
-
>
GetIsDocument
(
&
isDocument
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_DOCUMENT_NEEDS_COOKIE
&
&
isDocument
&
&
IsSynthesized
(
)
&
&
XRE_IsContentProcess
(
)
)
{
ContentChild
:
:
UpdateCookieStatus
(
mChannel
)
;
}
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
aContainer
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
docShell
&
&
!
loadInfo
-
>
GetLoadErrorPage
(
)
)
{
nsresult
rv
=
docShell
-
>
GetSandboxFlags
(
&
mSandboxFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
WarnIfSandboxIneffective
(
docShell
mSandboxFlags
GetChannel
(
)
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
=
this
-
>
GetDocShell
(
)
;
if
(
treeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeParent
;
treeItem
-
>
GetSameTypeParent
(
getter_AddRefs
(
sameTypeParent
)
)
;
if
(
sameTypeParent
)
{
Document
*
doc
=
sameTypeParent
-
>
GetDocument
(
)
;
mBlockAllMixedContent
=
doc
-
>
GetBlockAllMixedContent
(
false
)
;
mBlockAllMixedContentPreloads
=
mBlockAllMixedContent
|
|
doc
-
>
GetBlockAllMixedContent
(
true
)
;
mUpgradeInsecureRequests
=
doc
-
>
GetUpgradeInsecureRequests
(
false
)
;
mUpgradeInsecurePreloads
=
mUpgradeInsecureRequests
|
|
doc
-
>
GetUpgradeInsecureRequests
(
true
)
;
}
}
nsresult
rv
=
InitCSP
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InitFeaturePolicy
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspForFA
=
mCSP
;
if
(
!
FramingChecker
:
:
CheckFrameOptions
(
aChannel
docShell
cspForFA
)
)
{
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
XFO
doesn
'
t
like
frame
'
s
ancestry
not
loading
.
"
)
)
;
aChannel
-
>
Cancel
(
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
)
;
}
if
(
loadInfo
)
{
rv
=
loadInfo
-
>
GetCookieSettings
(
getter_AddRefs
(
mCookieSettings
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
Document
>
parentDocument
=
GetParentDocument
(
)
;
if
(
parentDocument
)
{
mCookieSettings
=
parentDocument
-
>
CookieSettings
(
)
;
}
}
return
NS_OK
;
}
nsIContentSecurityPolicy
*
Document
:
:
GetCsp
(
)
const
{
return
mCSP
;
}
void
Document
:
:
SetCsp
(
nsIContentSecurityPolicy
*
aCSP
)
{
mCSP
=
aCSP
;
}
nsIContentSecurityPolicy
*
Document
:
:
GetPreloadCsp
(
)
const
{
return
mPreloadCSP
;
}
void
Document
:
:
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCSP
)
{
mPreloadCSP
=
aPreloadCSP
;
}
void
Document
:
:
GetCspJSON
(
nsString
&
aJSON
)
{
aJSON
.
Truncate
(
)
;
if
(
!
mCSP
)
{
dom
:
:
CSPPolicies
jsonPolicies
;
jsonPolicies
.
ToJSON
(
aJSON
)
;
return
;
}
mCSP
-
>
ToJSON
(
aJSON
)
;
}
void
Document
:
:
SendToConsole
(
nsCOMArray
<
nsISecurityConsoleMessage
>
&
aMessages
)
{
for
(
uint32_t
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
nsAutoString
messageTag
;
aMessages
[
i
]
-
>
GetTag
(
messageTag
)
;
nsAutoString
category
;
aMessages
[
i
]
-
>
GetCategory
(
category
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_ConvertUTF16toUTF8
(
category
)
this
nsContentUtils
:
:
eSECURITY_PROPERTIES
NS_ConvertUTF16toUTF8
(
messageTag
)
.
get
(
)
)
;
}
}
void
Document
:
:
ApplySettingsFromCSP
(
bool
aSpeculative
)
{
nsresult
rv
=
NS_OK
;
if
(
!
aSpeculative
)
{
if
(
mCSP
)
{
if
(
!
mBlockAllMixedContent
)
{
rv
=
mCSP
-
>
GetBlockAllMixedContent
(
&
mBlockAllMixedContent
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
if
(
!
mBlockAllMixedContentPreloads
)
{
mBlockAllMixedContentPreloads
=
mBlockAllMixedContent
;
}
if
(
!
mUpgradeInsecureRequests
)
{
rv
=
mCSP
-
>
GetUpgradeInsecureRequests
(
&
mUpgradeInsecureRequests
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
if
(
!
mUpgradeInsecurePreloads
)
{
mUpgradeInsecurePreloads
=
mUpgradeInsecureRequests
;
}
}
return
;
}
if
(
mPreloadCSP
)
{
if
(
!
mBlockAllMixedContentPreloads
)
{
rv
=
mPreloadCSP
-
>
GetBlockAllMixedContent
(
&
mBlockAllMixedContentPreloads
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
if
(
!
mUpgradeInsecurePreloads
)
{
rv
=
mPreloadCSP
-
>
GetUpgradeInsecureRequests
(
&
mUpgradeInsecurePreloads
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
}
nsresult
Document
:
:
InitCSP
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
!
mScriptGlobalObject
"
CSP
must
be
initialized
before
mScriptGlobalObject
is
set
!
"
)
;
if
(
!
StaticPrefs
:
:
security_csp_enable
(
)
)
{
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
CSP
is
disabled
skipping
CSP
init
for
document
%
p
"
this
)
)
;
return
NS_OK
;
}
if
(
mLoadedAsData
)
{
return
NS_OK
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
NodePrincipal
(
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
mCSP
"
where
did
mCSP
get
set
if
not
here
?
"
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
mCSP
=
static_cast
<
net
:
:
LoadInfo
*
>
(
loadInfo
.
get
(
)
)
-
>
GetCSPToInherit
(
)
;
if
(
!
mCSP
)
{
mCSP
=
new
nsCSPContext
(
)
;
}
nsresult
rv
=
mCSP
-
>
SetRequestContextWithDocument
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
tCspHeaderValue
tCspROHeaderValue
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
content
-
security
-
policy
"
)
tCspHeaderValue
)
;
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
content
-
security
-
policy
-
report
-
only
"
)
tCspROHeaderValue
)
;
}
NS_ConvertASCIItoUTF16
cspHeaderValue
(
tCspHeaderValue
)
;
NS_ConvertASCIItoUTF16
cspROHeaderValue
(
tCspROHeaderValue
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
NodePrincipal
(
)
;
auto
addonPolicy
=
BasePrincipal
:
:
Cast
(
principal
)
-
>
AddonPolicy
(
)
;
if
(
!
addonPolicy
&
&
cspHeaderValue
.
IsEmpty
(
)
&
&
cspROHeaderValue
.
IsEmpty
(
)
)
{
if
(
MOZ_LOG_TEST
(
gCspPRLog
LogLevel
:
:
Debug
)
)
{
nsCOMPtr
<
nsIURI
>
chanURI
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
chanURI
)
)
;
nsAutoCString
aspec
;
chanURI
-
>
GetAsciiSpec
(
aspec
)
;
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
no
CSP
for
document
%
s
"
aspec
.
get
(
)
)
)
;
}
return
NS_OK
;
}
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
Document
is
an
add
-
on
or
CSP
header
specified
%
p
"
this
)
)
;
if
(
addonPolicy
)
{
nsAutoString
addonCSP
;
Unused
<
<
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetBaseCSP
(
addonCSP
)
;
mCSP
-
>
AppendPolicy
(
addonCSP
false
false
)
;
mCSP
-
>
AppendPolicy
(
addonPolicy
-
>
ContentSecurityPolicy
(
)
false
false
)
;
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
principal
)
;
if
(
basePrin
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
basePrin
-
>
As
<
ExpandedPrincipal
>
(
)
-
>
SetCsp
(
mCSP
)
;
}
}
if
(
!
cspHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
mCSP
cspHeaderValue
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
cspROHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
mCSP
cspROHeaderValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
uint32_t
cspSandboxFlags
=
SANDBOXED_NONE
;
rv
=
mCSP
-
>
GetCSPSandboxFlags
(
&
cspSandboxFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
needNewNullPrincipal
=
(
cspSandboxFlags
&
SANDBOXED_ORIGIN
)
&
&
!
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
;
mSandboxFlags
|
=
cspSandboxFlags
;
if
(
needNewNullPrincipal
)
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
principal
)
;
SetPrincipals
(
principal
principal
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
bool
safeAncestry
=
false
;
rv
=
mCSP
-
>
PermitsAncestry
(
docShell
&
safeAncestry
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
safeAncestry
)
{
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
CSP
doesn
'
t
like
frame
'
s
ancestry
not
loading
.
"
)
)
;
aChannel
-
>
Cancel
(
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
)
;
}
}
ApplySettingsFromCSP
(
false
)
;
return
NS_OK
;
}
nsresult
Document
:
:
InitFeaturePolicy
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
mFeaturePolicy
"
we
should
only
call
init
once
"
)
;
mFeaturePolicy
-
>
ResetDeclaredPolicy
(
)
;
if
(
!
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
{
return
NS_OK
;
}
mFeaturePolicy
-
>
SetDefaultOrigin
(
NodePrincipal
(
)
)
;
RefPtr
<
FeaturePolicy
>
parentPolicy
=
nullptr
;
if
(
mDocumentContainer
)
{
nsPIDOMWindowOuter
*
containerWindow
=
mDocumentContainer
-
>
GetWindow
(
)
;
if
(
containerWindow
)
{
nsCOMPtr
<
nsINode
>
node
=
containerWindow
-
>
GetFrameElementInternal
(
)
;
HTMLIFrameElement
*
iframe
=
HTMLIFrameElement
:
:
FromNodeOrNull
(
node
)
;
if
(
iframe
)
{
parentPolicy
=
iframe
-
>
Policy
(
)
;
}
}
}
if
(
parentPolicy
)
{
mFeaturePolicy
-
>
InheritPolicy
(
parentPolicy
)
;
}
if
(
!
StaticPrefs
:
:
dom_security_featurePolicy_header_enabled
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
nsresult
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
httpChannel
)
{
return
NS_OK
;
}
nsAutoCString
value
;
rv
=
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
Feature
-
Policy
"
)
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mFeaturePolicy
-
>
SetDeclaredPolicy
(
this
NS_ConvertUTF8toUTF16
(
value
)
NodePrincipal
(
)
nullptr
)
;
}
return
NS_OK
;
}
void
Document
:
:
StopDocumentLoad
(
)
{
if
(
mParser
)
{
mParserAborted
=
true
;
mParser
-
>
Terminate
(
)
;
}
}
void
Document
:
:
SetDocumentURI
(
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIURI
>
oldBase
=
GetDocBaseURI
(
)
;
mDocumentURI
=
aURI
;
nsIURI
*
newBase
=
GetDocBaseURI
(
)
;
mDocURISchemeIsChrome
=
aURI
&
&
IsChromeURI
(
aURI
)
;
bool
equalBases
=
false
;
if
(
oldBase
&
&
newBase
)
{
oldBase
-
>
EqualsExceptRef
(
newBase
&
equalBases
)
;
}
else
{
equalBases
=
!
oldBase
&
&
!
newBase
;
}
if
(
!
mOriginalURI
)
mOriginalURI
=
mDocumentURI
;
if
(
!
equalBases
)
{
RefreshLinkHrefs
(
)
;
}
mBaseDomain
.
Truncate
(
)
;
ThirdPartyUtil
*
thirdPartyUtil
=
ThirdPartyUtil
:
:
GetInstance
(
)
;
if
(
thirdPartyUtil
)
{
Unused
<
<
thirdPartyUtil
-
>
GetBaseDomain
(
mDocumentURI
mBaseDomain
)
;
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
WindowGlobalChild
*
wgc
=
inner
?
inner
-
>
GetWindowGlobalChild
(
)
:
nullptr
;
if
(
wgc
)
{
Unused
<
<
wgc
-
>
SendUpdateDocumentURI
(
mDocumentURI
)
;
}
}
static
void
GetFormattedTimeString
(
PRTime
aTime
nsAString
&
aFormattedTimeString
)
{
PRExplodedTime
prtime
;
PR_ExplodeTime
(
aTime
PR_LocalTimeParameters
&
prtime
)
;
char
formatedTime
[
24
]
;
if
(
SprintfLiteral
(
formatedTime
"
%
02d
/
%
02d
/
%
04d
%
02d
:
%
02d
:
%
02d
"
prtime
.
tm_month
+
1
prtime
.
tm_mday
int
(
prtime
.
tm_year
)
prtime
.
tm_hour
prtime
.
tm_min
prtime
.
tm_sec
)
)
{
CopyASCIItoUTF16
(
nsDependentCString
(
formatedTime
)
aFormattedTimeString
)
;
}
else
{
aFormattedTimeString
.
AssignLiteral
(
u
"
01
/
01
/
1970
00
:
00
:
00
"
)
;
}
}
void
Document
:
:
GetLastModified
(
nsAString
&
aLastModified
)
const
{
if
(
!
mLastModified
.
IsEmpty
(
)
)
{
aLastModified
.
Assign
(
mLastModified
)
;
}
else
{
GetFormattedTimeString
(
PR_Now
(
)
aLastModified
)
;
}
}
static
void
IncrementExpandoGeneration
(
Document
&
aDoc
)
{
+
+
aDoc
.
mExpandoAndGeneration
.
generation
;
}
void
Document
:
:
AddToNameTable
(
Element
*
aElement
nsAtom
*
aName
)
{
MOZ_ASSERT
(
nsGenericHTMLElement
:
:
ShouldExposeNameAsHTMLDocumentProperty
(
aElement
)
"
Only
put
elements
that
need
to
be
exposed
as
document
[
'
name
'
]
in
"
"
the
named
table
.
"
)
;
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aName
)
;
if
(
entry
)
{
if
(
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
entry
-
>
AddNameElement
(
this
aElement
)
;
}
}
void
Document
:
:
RemoveFromNameTable
(
Element
*
aElement
nsAtom
*
aName
)
{
if
(
mIdentifierMap
.
Count
(
)
=
=
0
)
return
;
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aName
)
;
if
(
!
entry
)
return
;
entry
-
>
RemoveNameElement
(
aElement
)
;
if
(
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
}
void
Document
:
:
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aId
)
;
if
(
entry
)
{
if
(
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
aElement
)
&
&
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
entry
-
>
AddIdElement
(
aElement
)
;
}
}
void
Document
:
:
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
NS_ASSERTION
(
aId
"
huhwhatnow
?
"
)
;
if
(
mIdentifierMap
.
Count
(
)
=
=
0
)
{
return
;
}
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aId
)
;
if
(
!
entry
)
return
;
entry
-
>
RemoveIdElement
(
aElement
)
;
if
(
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
aElement
)
&
&
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
if
(
entry
-
>
IsEmpty
(
)
)
{
mIdentifierMap
.
RemoveEntry
(
entry
)
;
}
}
void
Document
:
:
SetPrincipals
(
nsIPrincipal
*
aNewPrincipal
nsIPrincipal
*
aNewStoragePrincipal
)
{
MOZ_ASSERT
(
!
!
aNewPrincipal
=
=
!
!
aNewStoragePrincipal
)
;
if
(
aNewPrincipal
&
&
mAllowDNSPrefetch
&
&
sDisablePrefetchHTTPSPref
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aNewPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
bool
isHTTPS
;
if
(
!
uri
|
|
NS_FAILED
(
uri
-
>
SchemeIs
(
"
https
"
&
isHTTPS
)
)
|
|
isHTTPS
)
{
mAllowDNSPrefetch
=
false
;
}
}
mNodeInfoManager
-
>
SetDocumentPrincipal
(
aNewPrincipal
)
;
mIntrinsicStoragePrincipal
=
aNewStoragePrincipal
;
#
ifdef
DEBUG
if
(
aNewPrincipal
)
{
GetDocGroup
(
)
;
}
#
endif
}
#
ifdef
DEBUG
void
Document
:
:
AssertDocGroupMatchesKey
(
)
const
{
if
(
mDocGroup
)
{
nsAutoCString
docGroupKey
;
nsresult
rv
=
mozilla
:
:
dom
:
:
DocGroup
:
:
GetKey
(
NodePrincipal
(
)
docGroupKey
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
mDocGroup
-
>
MatchesKey
(
docGroupKey
)
)
;
}
}
}
#
endif
nsresult
Document
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
mDocGroup
)
{
return
mDocGroup
-
>
Dispatch
(
aCategory
std
:
:
move
(
aRunnable
)
)
;
}
return
DispatcherTrait
:
:
Dispatch
(
aCategory
std
:
:
move
(
aRunnable
)
)
;
}
nsISerialEventTarget
*
Document
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
if
(
mDocGroup
)
{
return
mDocGroup
-
>
EventTargetFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
EventTargetFor
(
aCategory
)
;
}
AbstractThread
*
Document
:
:
AbstractMainThreadFor
(
mozilla
:
:
TaskCategory
aCategory
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mDocGroup
)
{
return
mDocGroup
-
>
AbstractMainThreadFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
AbstractMainThreadFor
(
aCategory
)
;
}
void
Document
:
:
NoteScriptTrackingStatus
(
const
nsACString
&
aURL
bool
aIsTracking
)
{
if
(
aIsTracking
)
{
mTrackingScripts
.
PutEntry
(
aURL
)
;
}
else
{
MOZ_ASSERT
(
!
mTrackingScripts
.
Contains
(
aURL
)
)
;
}
}
bool
Document
:
:
IsScriptTracking
(
const
nsACString
&
aURL
)
const
{
return
mTrackingScripts
.
Contains
(
aURL
)
;
}
NS_IMETHODIMP
Document
:
:
GetApplicationCache
(
nsIApplicationCache
*
*
aApplicationCache
)
{
NS_IF_ADDREF
(
*
aApplicationCache
=
mApplicationCache
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Document
:
:
SetApplicationCache
(
nsIApplicationCache
*
aApplicationCache
)
{
mApplicationCache
=
aApplicationCache
;
return
NS_OK
;
}
void
Document
:
:
GetContentType
(
nsAString
&
aContentType
)
{
CopyUTF8toUTF16
(
GetContentTypeInternal
(
)
aContentType
)
;
}
void
Document
:
:
SetContentType
(
const
nsAString
&
aContentType
)
{
SetContentTypeInternal
(
NS_ConvertUTF16toUTF8
(
aContentType
)
)
;
}
bool
Document
:
:
GetAllowPlugins
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
bool
allowPlugins
=
false
;
docShell
-
>
GetAllowPlugins
(
&
allowPlugins
)
;
if
(
!
allowPlugins
)
{
return
false
;
}
if
(
mSandboxFlags
&
SANDBOXED_PLUGINS
)
{
return
false
;
}
}
FlashClassification
classification
=
DocumentFlashClassification
(
)
;
if
(
classification
=
=
FlashClassification
:
:
Denied
)
{
return
false
;
}
return
true
;
}
void
Document
:
:
InitializeLocalization
(
nsTArray
<
nsString
>
&
aResourceIds
)
{
MOZ_ASSERT
(
!
mDocumentL10n
"
mDocumentL10n
should
not
be
initialized
yet
"
)
;
DocumentL10n
*
l10n
=
new
DocumentL10n
(
this
)
;
MOZ_ALWAYS_TRUE
(
l10n
-
>
Init
(
aResourceIds
)
)
;
mDocumentL10n
=
l10n
;
}
DocumentL10n
*
Document
:
:
GetL10n
(
)
{
return
mDocumentL10n
;
}
bool
Document
:
:
DocumentSupportsL10n
(
JSContext
*
aCx
JSObject
*
aObject
)
{
nsCOMPtr
<
nsIPrincipal
>
callerPrincipal
=
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
;
return
PrincipalAllowsL10n
(
callerPrincipal
)
;
}
void
Document
:
:
LocalizationLinkAdded
(
Element
*
aLinkElement
)
{
if
(
!
PrincipalAllowsL10n
(
NodePrincipal
(
)
)
)
{
return
;
}
nsAutoString
href
;
aLinkElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
href
)
;
if
(
mDocumentL10n
)
{
AutoTArray
<
nsString
1
>
resourceIds
;
resourceIds
.
AppendElement
(
href
)
;
mDocumentL10n
-
>
AddResourceIds
(
resourceIds
)
;
}
else
if
(
mReadyState
>
=
READYSTATE_INTERACTIVE
)
{
AutoTArray
<
nsString
1
>
resourceIds
;
resourceIds
.
AppendElement
(
href
)
;
InitializeLocalization
(
resourceIds
)
;
mDocumentL10n
-
>
TriggerInitialDocumentTranslation
(
)
;
}
else
{
mL10nResources
.
AppendElement
(
href
)
;
mPendingInitialTranslation
=
true
;
}
}
void
Document
:
:
LocalizationLinkRemoved
(
Element
*
aLinkElement
)
{
if
(
!
PrincipalAllowsL10n
(
NodePrincipal
(
)
)
)
{
return
;
}
nsAutoString
href
;
aLinkElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
href
)
;
if
(
mDocumentL10n
)
{
AutoTArray
<
nsString
1
>
resourceIds
;
resourceIds
.
AppendElement
(
href
)
;
uint32_t
remaining
=
mDocumentL10n
-
>
RemoveResourceIds
(
resourceIds
)
;
if
(
remaining
=
=
0
)
{
mDocumentL10n
=
nullptr
;
}
}
else
{
mL10nResources
.
RemoveElement
(
href
)
;
}
}
void
Document
:
:
OnL10nResourceContainerParsed
(
)
{
if
(
!
mL10nResources
.
IsEmpty
(
)
)
{
InitializeLocalization
(
mL10nResources
)
;
mL10nResources
.
Clear
(
)
;
}
}
void
Document
:
:
TriggerInitialDocumentTranslation
(
)
{
OnL10nResourceContainerParsed
(
)
;
if
(
mDocumentL10n
)
{
mDocumentL10n
-
>
TriggerInitialDocumentTranslation
(
)
;
}
}
void
Document
:
:
InitialDocumentTranslationCompleted
(
)
{
mPendingInitialTranslation
=
false
;
}
bool
Document
:
:
IsWebAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
dom_animations_api_core_enabled
(
)
;
}
bool
Document
:
:
IsWebAnimationsEnabled
(
CallerType
aCallerType
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
aCallerType
=
=
dom
:
:
CallerType
:
:
System
|
|
StaticPrefs
:
:
dom_animations_api_core_enabled
(
)
;
}
bool
Document
:
:
IsWebAnimationsGetAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
dom_animations_api_getAnimations_enabled
(
)
;
}
bool
Document
:
:
AreWebAnimationsImplicitKeyframesEnabled
(
JSContext
*
aCx
JSObject
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
dom_animations_api_implicit_keyframes_enabled
(
)
;
}
bool
Document
:
:
AreWebAnimationsTimelinesEnabled
(
JSContext
*
aCx
JSObject
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
dom_animations_api_timelines_enabled
(
)
;
}
DocumentTimeline
*
Document
:
:
Timeline
(
)
{
if
(
!
mDocumentTimeline
)
{
mDocumentTimeline
=
new
DocumentTimeline
(
this
TimeDuration
(
0
)
)
;
}
return
mDocumentTimeline
;
}
void
Document
:
:
GetAnimations
(
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
{
RefPtr
<
Element
>
root
=
GetRootElement
(
)
;
if
(
!
root
)
{
return
;
}
AnimationFilter
filter
;
filter
.
mSubtree
=
true
;
root
-
>
GetAnimations
(
filter
aAnimations
)
;
}
SVGSVGElement
*
Document
:
:
GetSVGRootElement
(
)
const
{
Element
*
root
=
GetRootElement
(
)
;
if
(
!
root
|
|
!
root
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
nullptr
;
}
return
static_cast
<
SVGSVGElement
*
>
(
root
)
;
}
bool
Document
:
:
HasFocus
(
ErrorResult
&
rv
)
const
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
rv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
false
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
nsPIDOMWindowOuter
*
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
focusedWindow
)
;
for
(
Document
*
currentDoc
=
piWindow
-
>
GetDoc
(
)
;
currentDoc
;
currentDoc
=
currentDoc
-
>
GetParentDocument
(
)
)
{
if
(
currentDoc
=
=
this
)
{
return
true
;
}
}
return
false
;
}
TimeStamp
Document
:
:
LastFocusTime
(
)
const
{
return
mLastFocusTime
;
}
void
Document
:
:
SetLastFocusTime
(
const
TimeStamp
&
aFocusTime
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aFocusTime
.
IsNull
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mLastFocusTime
.
IsNull
(
)
|
|
aFocusTime
>
=
mLastFocusTime
)
;
mLastFocusTime
=
aFocusTime
;
}
void
Document
:
:
GetReferrer
(
nsAString
&
aReferrer
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
mParentDocument
-
>
GetReferrer
(
aReferrer
)
;
else
CopyUTF8toUTF16
(
mReferrer
aReferrer
)
;
}
void
Document
:
:
GetCookie
(
nsAString
&
aCookie
ErrorResult
&
rv
)
{
aCookie
.
Truncate
(
)
;
if
(
mDisableCookieAccess
)
{
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsContentUtils
:
:
StorageAccess
storageAccess
=
nsContentUtils
:
:
StorageAllowedForDocument
(
this
)
;
if
(
storageAccess
=
=
nsContentUtils
:
:
StorageAccess
:
:
eDeny
)
{
return
;
}
if
(
storageAccess
=
=
nsContentUtils
:
:
StorageAccess
:
:
ePartitionedOrDeny
&
&
!
StaticPrefs
:
:
privacy_storagePrincipal_enabledForTrackers
(
)
)
{
return
;
}
if
(
IsCookieAverse
(
)
)
{
return
;
}
nsCOMPtr
<
nsICookieService
>
service
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
if
(
service
)
{
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
mChannel
)
;
if
(
!
channel
)
{
channel
=
CreateDummyChannelForCookies
(
codebaseURI
)
;
if
(
!
channel
)
{
return
;
}
}
nsCString
cookie
;
service
-
>
GetCookieString
(
codebaseURI
channel
getter_Copies
(
cookie
)
)
;
UTF_8_ENCODING
-
>
DecodeWithoutBOMHandling
(
cookie
aCookie
)
;
}
}
void
Document
:
:
SetCookie
(
const
nsAString
&
aCookie
ErrorResult
&
rv
)
{
if
(
mDisableCookieAccess
)
{
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsContentUtils
:
:
StorageAccess
storageAccess
=
nsContentUtils
:
:
StorageAllowedForDocument
(
this
)
;
if
(
storageAccess
=
=
nsContentUtils
:
:
StorageAccess
:
:
eDeny
)
{
return
;
}
if
(
storageAccess
=
=
nsContentUtils
:
:
StorageAccess
:
:
ePartitionedOrDeny
&
&
!
StaticPrefs
:
:
privacy_storagePrincipal_enabledForTrackers
(
)
)
{
return
;
}
if
(
IsCookieAverse
(
)
)
{
return
;
}
nsCOMPtr
<
nsICookieService
>
service
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
if
(
service
&
&
mDocumentURI
)
{
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
mChannel
)
;
if
(
!
channel
)
{
channel
=
CreateDummyChannelForCookies
(
codebaseURI
)
;
if
(
!
channel
)
{
return
;
}
}
NS_ConvertUTF16toUTF8
cookie
(
aCookie
)
;
service
-
>
SetCookieString
(
codebaseURI
nullptr
cookie
.
get
(
)
channel
)
;
}
}
already_AddRefed
<
nsIChannel
>
Document
:
:
CreateDummyChannelForCookies
(
nsIURI
*
aCodebaseURI
)
{
MOZ_ASSERT
(
!
mChannel
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
NS_NewChannel
(
getter_AddRefs
(
channel
)
aCodebaseURI
this
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
nsIContentPolicy
:
:
TYPE_INVALID
)
;
nsCOMPtr
<
nsIPrivateBrowsingChannel
>
pbChannel
=
do_QueryInterface
(
channel
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_QueryInterface
(
docShell
)
;
if
(
!
pbChannel
|
|
!
loadContext
)
{
return
nullptr
;
}
pbChannel
-
>
SetPrivate
(
loadContext
-
>
UsePrivateBrowsing
(
)
)
;
return
channel
.
forget
(
)
;
}
mozilla
:
:
net
:
:
ReferrerPolicy
Document
:
:
GetReferrerPolicy
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
&
&
mReferrerPolicy
=
=
mozilla
:
:
net
:
:
RP_Unset
)
{
return
mParentDocument
-
>
GetReferrerPolicy
(
)
;
}
return
mReferrerPolicy
;
}
nsresult
Document
:
:
GetSrcdocData
(
nsAString
&
aSrcdocData
)
{
if
(
mIsSrcdocDocument
)
{
nsCOMPtr
<
nsIInputStreamChannel
>
inStrmChan
=
do_QueryInterface
(
mChannel
)
;
if
(
inStrmChan
)
{
return
inStrmChan
-
>
GetSrcdocData
(
aSrcdocData
)
;
}
}
aSrcdocData
=
VoidString
(
)
;
return
NS_OK
;
}
Nullable
<
WindowProxyHolder
>
Document
:
:
GetDefaultView
(
)
const
{
nsPIDOMWindowOuter
*
win
=
GetWindow
(
)
;
if
(
!
win
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
win
-
>
GetBrowsingContext
(
)
)
;
}
Element
*
Document
:
:
GetActiveElement
(
)
{
Element
*
focusedElement
=
GetRetargetedFocusedElement
(
)
;
if
(
focusedElement
)
{
return
focusedElement
;
}
if
(
IsHTMLOrXHTML
(
)
)
{
Element
*
bodyElement
=
AsHTMLDocument
(
)
-
>
GetBody
(
)
;
if
(
bodyElement
)
{
return
bodyElement
;
}
if
(
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
Element
*
docElement
=
GetDocumentElement
(
)
;
if
(
docElement
&
&
docElement
-
>
IsXULElement
(
)
)
{
return
docElement
;
}
}
return
nullptr
;
}
return
GetDocumentElement
(
)
;
}
Element
*
Document
:
:
GetCurrentScript
(
)
{
nsCOMPtr
<
Element
>
el
(
do_QueryInterface
(
ScriptLoader
(
)
-
>
GetCurrentScript
(
)
)
)
;
return
el
;
}
void
Document
:
:
ReleaseCapture
(
)
const
{
nsCOMPtr
<
nsINode
>
node
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
node
&
&
nsContentUtils
:
:
CanCallerAccess
(
node
)
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
already_AddRefed
<
nsIURI
>
Document
:
:
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
)
const
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
aTryUseXHRDocBaseURI
&
&
mChromeXHRDocBaseURI
)
{
uri
=
mChromeXHRDocBaseURI
;
}
else
{
uri
=
GetDocBaseURI
(
)
;
}
return
uri
.
forget
(
)
;
}
void
Document
:
:
SetBaseURI
(
nsIURI
*
aURI
)
{
if
(
!
aURI
&
&
!
mDocumentBaseURI
)
{
return
;
}
if
(
aURI
&
&
mDocumentBaseURI
)
{
bool
equalBases
=
false
;
mDocumentBaseURI
-
>
Equals
(
aURI
&
equalBases
)
;
if
(
equalBases
)
{
return
;
}
}
mDocumentBaseURI
=
aURI
;
RefreshLinkHrefs
(
)
;
}
URLExtraData
*
Document
:
:
DefaultStyleAttrURLData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsIURI
*
baseURI
=
GetDocBaseURI
(
)
;
nsIURI
*
docURI
=
GetDocumentURI
(
)
;
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
mozilla
:
:
net
:
:
ReferrerPolicy
policy
=
GetReferrerPolicy
(
)
;
if
(
!
mCachedURLData
|
|
mCachedURLData
-
>
BaseURI
(
)
!
=
baseURI
|
|
mCachedURLData
-
>
GetReferrer
(
)
!
=
docURI
|
|
mCachedURLData
-
>
GetReferrerPolicy
(
)
!
=
policy
|
|
mCachedURLData
-
>
Principal
(
)
!
=
principal
)
{
mCachedURLData
=
new
URLExtraData
(
baseURI
docURI
principal
policy
)
;
}
return
mCachedURLData
;
}
void
Document
:
:
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
if
(
mCharacterSet
!
=
aEncoding
)
{
mCharacterSet
=
aEncoding
;
mEncodingMenuDisabled
=
aEncoding
=
=
UTF_8_ENCODING
;
RecomputeLanguageFromCharset
(
)
;
if
(
nsPresContext
*
context
=
GetPresContext
(
)
)
{
context
-
>
DispatchCharSetChange
(
aEncoding
)
;
}
}
}
void
Document
:
:
GetSandboxFlagsAsString
(
nsAString
&
aFlags
)
{
nsContentUtils
:
:
SandboxFlagsToString
(
mSandboxFlags
aFlags
)
;
}
void
Document
:
:
GetHeaderData
(
nsAtom
*
aHeaderField
nsAString
&
aData
)
const
{
aData
.
Truncate
(
)
;
const
DocHeaderData
*
data
=
mHeaderData
;
while
(
data
)
{
if
(
data
-
>
mField
=
=
aHeaderField
)
{
aData
=
data
-
>
mData
;
break
;
}
data
=
data
-
>
mNext
;
}
}
void
Document
:
:
SetHeaderData
(
nsAtom
*
aHeaderField
const
nsAString
&
aData
)
{
if
(
!
aHeaderField
)
{
NS_ERROR
(
"
null
headerField
"
)
;
return
;
}
if
(
!
mHeaderData
)
{
if
(
!
aData
.
IsEmpty
(
)
)
{
mHeaderData
=
new
DocHeaderData
(
aHeaderField
aData
)
;
}
}
else
{
DocHeaderData
*
data
=
mHeaderData
;
DocHeaderData
*
*
lastPtr
=
&
mHeaderData
;
bool
found
=
false
;
do
{
if
(
data
-
>
mField
=
=
aHeaderField
)
{
if
(
!
aData
.
IsEmpty
(
)
)
{
data
-
>
mData
.
Assign
(
aData
)
;
}
else
{
*
lastPtr
=
data
-
>
mNext
;
data
-
>
mNext
=
nullptr
;
delete
data
;
}
found
=
true
;
break
;
}
lastPtr
=
&
(
data
-
>
mNext
)
;
data
=
*
lastPtr
;
}
while
(
data
)
;
if
(
!
aData
.
IsEmpty
(
)
&
&
!
found
)
{
*
lastPtr
=
new
DocHeaderData
(
aHeaderField
aData
)
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerContentLanguage
)
{
CopyUTF16toUTF8
(
aData
mContentLanguage
)
;
mMayNeedFontPrefsUpdate
=
true
;
if
(
auto
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
ContentLanguageChanged
(
)
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerDefaultStyle
)
{
SetPreferredStyleSheetSet
(
aData
)
;
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
refresh
)
{
nsCOMPtr
<
nsIRefreshURI
>
refresher
(
mDocumentContainer
)
;
if
(
refresher
)
{
refresher
-
>
SetupRefreshURIFromHeader
(
mDocumentURI
NodePrincipal
(
)
NS_ConvertUTF16toUTF8
(
aData
)
)
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerDNSPrefetchControl
&
&
mAllowDNSPrefetch
)
{
mAllowDNSPrefetch
=
aData
.
IsEmpty
(
)
|
|
aData
.
LowerCaseEqualsLiteral
(
"
on
"
)
;
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
viewport
|
|
aHeaderField
=
=
nsGkAtoms
:
:
handheldFriendly
|
|
aHeaderField
=
=
nsGkAtoms
:
:
viewport_minimum_scale
|
|
aHeaderField
=
=
nsGkAtoms
:
:
viewport_maximum_scale
|
|
aHeaderField
=
=
nsGkAtoms
:
:
viewport_initial_scale
|
|
aHeaderField
=
=
nsGkAtoms
:
:
viewport_height
|
|
aHeaderField
=
=
nsGkAtoms
:
:
viewport_width
|
|
aHeaderField
=
=
nsGkAtoms
:
:
viewport_user_scalable
)
{
mViewportType
=
Unknown
;
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
referrer
&
&
!
aData
.
IsEmpty
(
)
)
{
enum
mozilla
:
:
net
:
:
ReferrerPolicy
policy
=
mozilla
:
:
net
:
:
ReferrerPolicyFromString
(
aData
)
;
if
(
policy
!
=
mozilla
:
:
net
:
:
RP_Unset
)
{
mReferrerPolicy
=
policy
;
mReferrerPolicySet
=
true
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerReferrerPolicy
&
&
!
aData
.
IsEmpty
(
)
)
{
enum
mozilla
:
:
net
:
:
ReferrerPolicy
policy
=
nsContentUtils
:
:
GetReferrerPolicyFromHeader
(
aData
)
;
if
(
policy
!
=
mozilla
:
:
net
:
:
RP_Unset
)
{
mReferrerPolicy
=
policy
;
mReferrerPolicySet
=
true
;
}
}
}
void
Document
:
:
TryChannelCharset
(
nsIChannel
*
aChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
nsHtml5TreeOpExecutor
*
aExecutor
)
{
if
(
aChannel
)
{
nsAutoCString
charsetVal
;
nsresult
rv
=
aChannel
-
>
GetContentCharset
(
charsetVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
const
Encoding
*
preferred
=
Encoding
:
:
ForLabel
(
charsetVal
)
;
if
(
preferred
)
{
aEncoding
=
WrapNotNull
(
preferred
)
;
aCharsetSource
=
kCharsetFromChannel
;
return
;
}
else
if
(
aExecutor
&
&
!
charsetVal
.
IsEmpty
(
)
)
{
aExecutor
-
>
ComplainAboutBogusProtocolCharset
(
this
)
;
}
}
}
}
static
inline
void
AssertNoStaleServoDataIn
(
nsINode
&
aSubtreeRoot
)
{
#
ifdef
DEBUG
for
(
nsINode
*
node
:
ShadowIncludingTreeIterator
(
aSubtreeRoot
)
)
{
const
Element
*
element
=
Element
:
:
FromNode
(
node
)
;
if
(
!
element
)
{
continue
;
}
MOZ_ASSERT
(
!
element
-
>
HasServoData
(
)
)
;
if
(
nsXBLBinding
*
binding
=
element
-
>
GetXBLBinding
(
)
)
{
if
(
nsXBLBinding
*
bindingWithContent
=
binding
-
>
GetBindingWithContent
(
)
)
{
nsIContent
*
content
=
bindingWithContent
-
>
GetAnonymousContent
(
)
;
MOZ_ASSERT
(
!
content
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
;
for
(
nsINode
*
child
=
content
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AssertNoStaleServoDataIn
(
*
child
)
;
}
}
}
}
#
endif
}
already_AddRefed
<
PresShell
>
Document
:
:
CreatePresShell
(
nsPresContext
*
aContext
nsViewManager
*
aViewManager
)
{
MOZ_ASSERT
(
!
mPresShell
"
We
have
a
presshell
already
!
"
)
;
NS_ENSURE_FALSE
(
GetBFCacheEntry
(
)
nullptr
)
;
AssertNoStaleServoDataIn
(
*
this
)
;
RefPtr
<
PresShell
>
presShell
=
new
PresShell
;
mPresShell
=
presShell
;
bool
hadStyleSheets
=
mStyleSetFilled
;
if
(
!
hadStyleSheets
)
{
FillStyleSet
(
)
;
}
presShell
-
>
Init
(
this
aContext
aViewManager
)
;
if
(
hadStyleSheets
)
{
aContext
-
>
MediaFeatureValuesChanged
(
{
MediaFeatureChange
:
:
kAllChanges
}
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
&
&
docShell
-
>
IsInvisible
(
)
)
{
presShell
-
>
SetNeverPainting
(
true
)
;
}
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
with
PressShell
%
p
and
DocShell
%
p
"
this
presShell
.
get
(
)
docShell
.
get
(
)
)
)
;
mExternalResourceMap
.
ShowViewers
(
)
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
MarkUserFontSetDirty
(
)
;
return
presShell
.
forget
(
)
;
}
void
Document
:
:
UpdateFrameRequestCallbackSchedulingState
(
PresShell
*
aOldPresShell
)
{
bool
shouldBeScheduled
=
mPresShell
&
&
IsEventHandlingEnabled
(
)
&
&
!
mFrameRequestCallbacks
.
IsEmpty
(
)
;
if
(
shouldBeScheduled
=
=
mFrameRequestCallbacksScheduled
)
{
return
;
}
PresShell
*
presShell
=
aOldPresShell
?
aOldPresShell
:
mPresShell
;
MOZ_RELEASE_ASSERT
(
presShell
)
;
nsRefreshDriver
*
rd
=
presShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
if
(
shouldBeScheduled
)
{
rd
-
>
ScheduleFrameRequestCallbacks
(
this
)
;
}
else
{
rd
-
>
RevokeFrameRequestCallbacks
(
this
)
;
}
mFrameRequestCallbacksScheduled
=
shouldBeScheduled
;
}
void
Document
:
:
TakeFrameRequestCallbacks
(
nsTArray
<
FrameRequest
>
&
aCallbacks
)
{
MOZ_ASSERT
(
aCallbacks
.
IsEmpty
(
)
)
;
aCallbacks
.
SwapElements
(
mFrameRequestCallbacks
)
;
mCanceledFrameRequestCallbacks
.
clear
(
)
;
mFrameRequestCallbacksScheduled
=
false
;
}
bool
Document
:
:
ShouldThrottleFrameRequests
(
)
{
if
(
mStaticCloneCount
>
0
)
{
return
false
;
}
if
(
Hidden
(
)
)
{
return
true
;
}
if
(
!
mPresShell
)
{
return
false
;
}
nsIFrame
*
frame
=
mPresShell
-
>
GetRootFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
nsIFrame
*
displayRootFrame
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
frame
)
;
if
(
!
displayRootFrame
)
{
return
false
;
}
if
(
!
displayRootFrame
-
>
DidPaintPresShell
(
mPresShell
)
)
{
return
true
;
}
return
false
;
}
void
Document
:
:
DeletePresShell
(
)
{
mExternalResourceMap
.
HideViewers
(
)
;
if
(
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
RefreshDriver
(
)
-
>
CancelPendingFullscreenEvents
(
this
)
;
}
ImageTracker
(
)
-
>
RequestDiscardAll
(
)
;
MarkUserFontSetDirty
(
)
;
if
(
mResizeObserverController
)
{
mResizeObserverController
-
>
ShellDetachedFromDocument
(
)
;
}
PresShell
*
oldPresShell
=
mPresShell
;
mPresShell
=
nullptr
;
UpdateFrameRequestCallbackSchedulingState
(
oldPresShell
)
;
ClearStaleServoData
(
)
;
AssertNoStaleServoDataIn
(
*
this
)
;
mStyleSet
-
>
ShellDetachedFromDocument
(
)
;
mStyleSetFilled
=
false
;
mQuirkSheetAdded
=
false
;
mContentEditableSheetAdded
=
false
;
mDesignModeSheetAdded
=
false
;
}
void
Document
:
:
SetBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
{
MOZ_ASSERT
(
IsBFCachingAllowed
(
)
|
|
!
aEntry
"
You
should
have
checked
!
"
)
;
if
(
mPresShell
)
{
if
(
aEntry
)
{
mPresShell
-
>
StopObservingRefreshDriver
(
)
;
}
else
if
(
mBFCacheEntry
)
{
mPresShell
-
>
StartObservingRefreshDriver
(
)
;
}
}
mBFCacheEntry
=
aEntry
;
}
static
void
SubDocClearEntry
(
PLDHashTable
*
table
PLDHashEntryHdr
*
entry
)
{
SubDocMapEntry
*
e
=
static_cast
<
SubDocMapEntry
*
>
(
entry
)
;
NS_RELEASE
(
e
-
>
mKey
)
;
if
(
e
-
>
mSubDocument
)
{
e
-
>
mSubDocument
-
>
SetParentDocument
(
nullptr
)
;
NS_RELEASE
(
e
-
>
mSubDocument
)
;
}
}
static
void
SubDocInitEntry
(
PLDHashEntryHdr
*
entry
const
void
*
key
)
{
SubDocMapEntry
*
e
=
const_cast
<
SubDocMapEntry
*
>
(
static_cast
<
const
SubDocMapEntry
*
>
(
entry
)
)
;
e
-
>
mKey
=
const_cast
<
Element
*
>
(
static_cast
<
const
Element
*
>
(
key
)
)
;
NS_ADDREF
(
e
-
>
mKey
)
;
e
-
>
mSubDocument
=
nullptr
;
}
nsresult
Document
:
:
SetSubDocumentFor
(
Element
*
aElement
Document
*
aSubDoc
)
{
NS_ENSURE_TRUE
(
aElement
NS_ERROR_UNEXPECTED
)
;
if
(
!
aSubDoc
)
{
if
(
mSubDocuments
)
{
Document
*
subDoc
=
GetSubDocumentFor
(
aElement
)
;
if
(
subDoc
)
{
subDoc
-
>
SetAllowPaymentRequest
(
false
)
;
}
mSubDocuments
-
>
Remove
(
aElement
)
;
}
}
else
{
if
(
!
mSubDocuments
)
{
static
const
PLDHashTableOps
hash_table_ops
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
PLDHashTable
:
:
MatchEntryStub
PLDHashTable
:
:
MoveEntryStub
SubDocClearEntry
SubDocInitEntry
}
;
mSubDocuments
=
new
PLDHashTable
(
&
hash_table_ops
sizeof
(
SubDocMapEntry
)
)
;
}
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
mSubDocuments
-
>
Add
(
aElement
fallible
)
)
;
if
(
!
entry
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
entry
-
>
mSubDocument
)
{
entry
-
>
mSubDocument
-
>
SetAllowPaymentRequest
(
false
)
;
entry
-
>
mSubDocument
-
>
SetParentDocument
(
nullptr
)
;
NS_RELEASE
(
entry
-
>
mSubDocument
)
;
}
entry
-
>
mSubDocument
=
aSubDoc
;
NS_ADDREF
(
entry
-
>
mSubDocument
)
;
if
(
!
mAllowPaymentRequest
)
{
aSubDoc
-
>
SetAllowPaymentRequest
(
false
)
;
}
else
{
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
aElement
aSubDoc
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aSubDoc
-
>
SetAllowPaymentRequest
(
true
)
;
}
else
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
aElement
-
>
GetBoolAttr
(
nsGkAtoms
:
:
allowpaymentrequest
)
)
{
aSubDoc
-
>
SetAllowPaymentRequest
(
true
)
;
}
else
{
aSubDoc
-
>
SetAllowPaymentRequest
(
false
)
;
}
}
}
aSubDoc
-
>
SetParentDocument
(
this
)
;
}
return
NS_OK
;
}
Document
*
Document
:
:
GetSubDocumentFor
(
nsIContent
*
aContent
)
const
{
if
(
mSubDocuments
&
&
aContent
-
>
IsElement
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
mSubDocuments
-
>
Search
(
aContent
-
>
AsElement
(
)
)
)
;
if
(
entry
)
{
return
entry
-
>
mSubDocument
;
}
}
return
nullptr
;
}
Element
*
Document
:
:
FindContentForSubDocument
(
Document
*
aDocument
)
const
{
NS_ENSURE_TRUE
(
aDocument
nullptr
)
;
if
(
!
mSubDocuments
)
{
return
nullptr
;
}
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
if
(
entry
-
>
mSubDocument
=
=
aDocument
)
{
return
entry
-
>
mKey
;
}
}
return
nullptr
;
}
bool
Document
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
false
;
}
Element
*
Document
:
:
GetRootElement
(
)
const
{
return
(
mCachedRootElement
&
&
mCachedRootElement
-
>
GetParentNode
(
)
=
=
this
)
?
mCachedRootElement
:
GetRootElementInternal
(
)
;
}
Element
*
Document
:
:
GetUnfocusedKeyEventTarget
(
)
{
return
GetRootElement
(
)
;
}
Element
*
Document
:
:
GetRootElementInternal
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
nsIContent
*
child
=
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
Element
*
element
=
Element
:
:
FromNode
(
child
)
)
{
const_cast
<
Document
*
>
(
this
)
-
>
mCachedRootElement
=
element
;
return
element
;
}
}
const_cast
<
Document
*
>
(
this
)
-
>
mCachedRootElement
=
nullptr
;
return
nullptr
;
}
nsresult
Document
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
{
if
(
aKid
-
>
IsElement
(
)
&
&
GetRootElement
(
)
)
{
NS_WARNING
(
"
Inserting
root
element
when
we
already
have
one
"
)
;
return
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
;
}
return
nsINode
:
:
InsertChildBefore
(
aKid
aBeforeThis
aNotify
)
;
}
void
Document
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
{
if
(
aKid
-
>
IsElement
(
)
)
{
DestroyElementMaps
(
)
;
}
mCachedRootElement
=
nullptr
;
nsINode
:
:
RemoveChildNode
(
aKid
aNotify
)
;
MOZ_ASSERT
(
mCachedRootElement
!
=
aKid
"
Stale
pointer
in
mCachedRootElement
after
we
tried
to
clear
it
"
"
(
maybe
somebody
called
GetRootElement
(
)
too
early
?
)
"
)
;
}
void
Document
:
:
AddStyleSheetToStyleSets
(
StyleSheet
*
aSheet
)
{
if
(
mStyleSetFilled
)
{
mStyleSet
-
>
AddDocStyleSheet
(
aSheet
)
;
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
RecordShadowStyleChange
(
ShadowRoot
&
aShadowRoot
)
{
mStyleSet
-
>
RecordShadowStyleChange
(
aShadowRoot
)
;
ApplicableStylesChanged
(
)
;
}
void
Document
:
:
ApplicableStylesChanged
(
)
{
if
(
!
mStyleSetFilled
)
{
return
;
}
MarkUserFontSetDirty
(
)
;
PresShell
*
ps
=
GetPresShell
(
)
;
if
(
!
ps
)
{
return
;
}
ps
-
>
EnsureStyleFlush
(
)
;
nsPresContext
*
pc
=
ps
-
>
GetPresContext
(
)
;
if
(
!
pc
)
{
return
;
}
pc
-
>
MarkCounterStylesDirty
(
)
;
pc
-
>
MarkFontFeatureValuesDirty
(
)
;
pc
-
>
RestyleManager
(
)
-
>
NextRestyleIsForCSSRuleChanges
(
)
;
}
#
define
DO_STYLESHEET_NOTIFICATION
(
className
type
memberName
argName
)
\
do
{
\
className
#
#
Init
init
;
\
init
.
mBubbles
=
true
;
\
init
.
mCancelable
=
true
;
\
init
.
mStylesheet
=
aSheet
;
\
init
.
memberName
=
argName
;
\
\
RefPtr
<
className
>
event
=
\
className
:
:
Constructor
(
this
NS_LITERAL_STRING
(
type
)
init
)
;
\
event
-
>
SetTrusted
(
true
)
;
\
event
-
>
SetTarget
(
this
)
;
\
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
\
new
AsyncEventDispatcher
(
this
event
)
;
\
asyncDispatcher
-
>
mOnlyChromeDispatch
=
ChromeOnlyDispatch
:
:
eYes
;
\
asyncDispatcher
-
>
PostDOMEvent
(
)
;
\
}
while
(
0
)
;
void
Document
:
:
NotifyStyleSheetAdded
(
StyleSheet
*
aSheet
bool
aDocumentSheet
)
{
if
(
StyleSheetChangeEventsEnabled
(
)
)
{
DO_STYLESHEET_NOTIFICATION
(
StyleSheetChangeEvent
"
StyleSheetAdded
"
mDocumentSheet
aDocumentSheet
)
;
}
}
void
Document
:
:
NotifyStyleSheetRemoved
(
StyleSheet
*
aSheet
bool
aDocumentSheet
)
{
if
(
StyleSheetChangeEventsEnabled
(
)
)
{
DO_STYLESHEET_NOTIFICATION
(
StyleSheetChangeEvent
"
StyleSheetRemoved
"
mDocumentSheet
aDocumentSheet
)
;
}
}
void
Document
:
:
RemoveStyleSheetFromStyleSets
(
StyleSheet
*
aSheet
)
{
if
(
mStyleSetFilled
)
{
mStyleSet
-
>
RemoveDocStyleSheet
(
aSheet
)
;
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
RemoveStyleSheet
(
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
RefPtr
<
StyleSheet
>
sheet
=
DocumentOrShadowRoot
:
:
RemoveSheet
(
*
aSheet
)
;
if
(
!
sheet
)
{
NS_ASSERTION
(
mInUnlinkOrDeletion
"
stylesheet
not
found
"
)
;
return
;
}
if
(
!
mIsGoingAway
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
RemoveStyleSheetFromStyleSets
(
sheet
)
;
}
NotifyStyleSheetRemoved
(
sheet
true
)
;
}
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
}
void
Document
:
:
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
aSheet
)
{
DocumentOrShadowRoot
:
:
InsertSheetAt
(
aIndex
aSheet
)
;
if
(
aSheet
.
IsApplicable
(
)
)
{
AddStyleSheetToStyleSets
(
&
aSheet
)
;
}
NotifyStyleSheetAdded
(
&
aSheet
true
)
;
}
void
Document
:
:
SetStyleSheetApplicableState
(
StyleSheet
*
aSheet
bool
aApplicable
)
{
MOZ_ASSERT
(
aSheet
"
null
arg
"
)
;
if
(
mStyleSheets
.
IndexOf
(
aSheet
)
!
=
mStyleSheets
.
NoIndex
)
{
if
(
aApplicable
)
{
AddStyleSheetToStyleSets
(
aSheet
)
;
}
else
{
RemoveStyleSheetFromStyleSets
(
aSheet
)
;
}
}
if
(
StyleSheetChangeEventsEnabled
(
)
)
{
DO_STYLESHEET_NOTIFICATION
(
StyleSheetApplicableStateChangeEvent
"
StyleSheetApplicableStateChanged
"
mApplicable
aApplicable
)
;
}
if
(
!
mSSApplicableStateNotificationPending
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
notification
=
NewRunnableMethod
(
"
Document
:
:
NotifyStyleSheetApplicableStateChanged
"
this
&
Document
:
:
NotifyStyleSheetApplicableStateChanged
)
;
mSSApplicableStateNotificationPending
=
NS_SUCCEEDED
(
Dispatch
(
TaskCategory
:
:
Other
notification
.
forget
(
)
)
)
;
}
}
void
Document
:
:
NotifyStyleSheetApplicableStateChanged
(
)
{
mSSApplicableStateNotificationPending
=
false
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
this
)
"
style
-
sheet
-
applicable
-
state
-
changed
"
nullptr
)
;
}
}
static
StyleOrigin
ConvertAdditionalSheetType
(
Document
:
:
additionalSheetType
aType
)
{
switch
(
aType
)
{
case
Document
:
:
eAgentSheet
:
return
StyleOrigin
:
:
UserAgent
;
case
Document
:
:
eUserSheet
:
return
StyleOrigin
:
:
User
;
case
Document
:
:
eAuthorSheet
:
return
StyleOrigin
:
:
Author
;
default
:
MOZ_CRASH
(
"
Wrong
sheet
type
"
)
;
}
}
static
int32_t
FindSheet
(
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
nsIURI
*
aSheetURI
)
{
for
(
int32_t
i
=
aSheets
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
bool
bEqual
;
nsIURI
*
uri
=
aSheets
[
i
]
-
>
GetSheetURI
(
)
;
if
(
uri
&
&
NS_SUCCEEDED
(
uri
-
>
Equals
(
aSheetURI
&
bEqual
)
)
&
&
bEqual
)
return
i
;
}
return
-
1
;
}
nsresult
Document
:
:
LoadAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
{
MOZ_ASSERT
(
aSheetURI
"
null
arg
"
)
;
if
(
FindSheet
(
mAdditionalSheets
[
aType
]
aSheetURI
)
>
=
0
)
return
NS_ERROR_INVALID_ARG
;
RefPtr
<
css
:
:
Loader
>
loader
=
new
css
:
:
Loader
(
GetDocGroup
(
)
)
;
css
:
:
SheetParsingMode
parsingMode
;
switch
(
aType
)
{
case
Document
:
:
eAgentSheet
:
parsingMode
=
css
:
:
eAgentSheetFeatures
;
break
;
case
Document
:
:
eUserSheet
:
parsingMode
=
css
:
:
eUserSheetFeatures
;
break
;
case
Document
:
:
eAuthorSheet
:
parsingMode
=
css
:
:
eAuthorSheetFeatures
;
break
;
default
:
MOZ_CRASH
(
"
impossible
value
for
aType
"
)
;
}
RefPtr
<
StyleSheet
>
sheet
;
nsresult
rv
=
loader
-
>
LoadSheetSync
(
aSheetURI
parsingMode
true
&
sheet
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
sheet
-
>
SetAssociatedDocumentOrShadowRoot
(
this
StyleSheet
:
:
OwnedByDocumentOrShadowRoot
)
;
MOZ_ASSERT
(
sheet
-
>
IsApplicable
(
)
)
;
return
AddAdditionalStyleSheet
(
aType
sheet
)
;
}
nsresult
Document
:
:
AddAdditionalStyleSheet
(
additionalSheetType
aType
StyleSheet
*
aSheet
)
{
if
(
mAdditionalSheets
[
aType
]
.
Contains
(
aSheet
)
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
aSheet
-
>
IsApplicable
(
)
)
return
NS_ERROR_INVALID_ARG
;
mAdditionalSheets
[
aType
]
.
AppendElement
(
aSheet
)
;
if
(
mStyleSetFilled
)
{
mStyleSet
-
>
AppendStyleSheet
(
ConvertAdditionalSheetType
(
aType
)
aSheet
)
;
ApplicableStylesChanged
(
)
;
}
NotifyStyleSheetAdded
(
aSheet
false
)
;
return
NS_OK
;
}
void
Document
:
:
RemoveAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
{
MOZ_ASSERT
(
aSheetURI
)
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
sheets
=
mAdditionalSheets
[
aType
]
;
int32_t
i
=
FindSheet
(
mAdditionalSheets
[
aType
]
aSheetURI
)
;
if
(
i
>
=
0
)
{
RefPtr
<
StyleSheet
>
sheetRef
=
sheets
[
i
]
;
sheets
.
RemoveElementAt
(
i
)
;
if
(
!
mIsGoingAway
)
{
MOZ_ASSERT
(
sheetRef
-
>
IsApplicable
(
)
)
;
if
(
mStyleSetFilled
)
{
mStyleSet
-
>
RemoveStyleSheet
(
ConvertAdditionalSheetType
(
aType
)
sheetRef
)
;
ApplicableStylesChanged
(
)
;
}
}
NotifyStyleSheetRemoved
(
sheetRef
false
)
;
sheetRef
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
}
}
nsIGlobalObject
*
Document
:
:
GetScopeObject
(
)
const
{
nsCOMPtr
<
nsIGlobalObject
>
scope
(
do_QueryReferent
(
mScopeObject
)
)
;
return
scope
;
}
void
Document
:
:
SetScopeObject
(
nsIGlobalObject
*
aGlobal
)
{
mScopeObject
=
do_GetWeakReference
(
aGlobal
)
;
if
(
aGlobal
)
{
mHasHadScriptHandlingObject
=
true
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
)
;
if
(
window
)
{
mozilla
:
:
dom
:
:
TabGroup
*
tabgroup
=
window
-
>
TabGroup
(
)
;
nsAutoCString
docGroupKey
;
nsresult
rv
=
mozilla
:
:
dom
:
:
DocGroup
:
:
GetKey
(
NodePrincipal
(
)
docGroupKey
)
;
if
(
mDocGroup
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_RELEASE_ASSERT
(
mDocGroup
-
>
MatchesKey
(
docGroupKey
)
)
;
}
MOZ_RELEASE_ASSERT
(
mDocGroup
-
>
GetTabGroup
(
)
=
=
tabgroup
)
;
}
else
{
mDocGroup
=
tabgroup
-
>
AddDocument
(
docGroupKey
this
)
;
MOZ_ASSERT
(
mDocGroup
)
;
}
}
}
}
static
void
CheckIfContainsEMEContent
(
nsISupports
*
aSupports
void
*
aContainsEME
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
auto
mediaElem
=
HTMLMediaElement
:
:
FromNodeOrNull
(
content
)
)
{
bool
*
contains
=
static_cast
<
bool
*
>
(
aContainsEME
)
;
if
(
mediaElem
-
>
GetMediaKeys
(
)
)
{
*
contains
=
true
;
}
}
}
bool
Document
:
:
ContainsEMEContent
(
)
{
bool
containsEME
=
false
;
EnumerateActivityObservers
(
CheckIfContainsEMEContent
static_cast
<
void
*
>
(
&
containsEME
)
)
;
return
containsEME
;
}
static
void
CheckIfContainsMSEContent
(
nsISupports
*
aSupports
void
*
aContainsMSE
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
auto
mediaElem
=
HTMLMediaElement
:
:
FromNodeOrNull
(
content
)
)
{
bool
*
contains
=
static_cast
<
bool
*
>
(
aContainsMSE
)
;
RefPtr
<
MediaSource
>
ms
=
mediaElem
-
>
GetMozMediaSourceObject
(
)
;
if
(
ms
)
{
*
contains
=
true
;
}
}
}
bool
Document
:
:
ContainsMSEContent
(
)
{
bool
containsMSE
=
false
;
EnumerateActivityObservers
(
CheckIfContainsMSEContent
static_cast
<
void
*
>
(
&
containsMSE
)
)
;
return
containsMSE
;
}
static
void
NotifyActivityChanged
(
nsISupports
*
aSupports
void
*
aUnused
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
auto
mediaElem
=
HTMLMediaElement
:
:
FromNodeOrNull
(
content
)
)
{
mediaElem
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
nsCOMPtr
<
nsIObjectLoadingContent
>
objectLoadingContent
(
do_QueryInterface
(
aSupports
)
)
;
if
(
objectLoadingContent
)
{
nsObjectLoadingContent
*
olc
=
static_cast
<
nsObjectLoadingContent
*
>
(
objectLoadingContent
.
get
(
)
)
;
olc
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
nsCOMPtr
<
nsIDocumentActivity
>
objectDocumentActivity
(
do_QueryInterface
(
aSupports
)
)
;
if
(
objectDocumentActivity
)
{
objectDocumentActivity
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
else
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoadingContent
(
do_QueryInterface
(
aSupports
)
)
;
if
(
imageLoadingContent
)
{
auto
ilc
=
static_cast
<
nsImageLoadingContent
*
>
(
imageLoadingContent
.
get
(
)
)
;
ilc
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
}
}
bool
Document
:
:
IsTopLevelWindowInactive
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
=
GetDocShell
(
)
;
if
(
!
treeItem
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
treeItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
!
rootItem
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
rootItem
-
>
GetWindow
(
)
;
return
domWindow
&
&
!
domWindow
-
>
IsActive
(
)
;
}
void
Document
:
:
SetContainer
(
nsDocShell
*
aContainer
)
{
if
(
aContainer
)
{
mDocumentContainer
=
aContainer
;
}
else
{
mDocumentContainer
=
WeakPtr
<
nsDocShell
>
(
)
;
}
mInChromeDocShell
=
aContainer
&
&
aContainer
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
;
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
UpdateDocumentStates
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
false
)
;
if
(
!
aContainer
)
{
return
;
}
BrowsingContext
*
context
=
aContainer
-
>
GetBrowsingContext
(
)
;
if
(
context
&
&
context
-
>
IsContent
(
)
)
{
if
(
!
context
-
>
GetParent
(
)
)
{
SetIsTopLevelContentDocument
(
true
)
;
}
SetIsContentDocument
(
true
)
;
}
mAncestorPrincipals
=
aContainer
-
>
AncestorPrincipals
(
)
;
mAncestorOuterWindowIDs
=
aContainer
-
>
AncestorOuterWindowIDs
(
)
;
}
nsISupports
*
Document
:
:
GetContainer
(
)
const
{
return
static_cast
<
nsIDocShell
*
>
(
mDocumentContainer
)
;
}
void
Document
:
:
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aScriptGlobalObject
)
{
MOZ_ASSERT
(
aScriptGlobalObject
|
|
!
mAnimationController
|
|
mAnimationController
-
>
IsPausedByType
(
SMILTimeContainer
:
:
PAUSE_PAGEHIDE
|
SMILTimeContainer
:
:
PAUSE_BEGIN
)
"
Clearing
window
pointer
while
animations
are
unpaused
"
)
;
if
(
mScriptGlobalObject
&
&
!
aScriptGlobalObject
)
{
mLayoutHistoryState
=
GetLayoutHistoryState
(
)
;
if
(
mOnloadBlockCount
!
=
0
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
loadGroup
-
>
RemoveRequest
(
mOnloadBlocker
nullptr
NS_OK
)
;
}
}
ErrorResult
error
;
if
(
GetController
(
)
.
isSome
(
)
)
{
imgLoader
*
loader
=
nsContentUtils
:
:
GetImgLoaderForDocument
(
this
)
;
if
(
loader
)
{
loader
-
>
ClearCacheForControlledDocument
(
this
)
;
}
mMaybeServiceWorkerControlled
=
false
;
}
}
bool
needOnloadBlocker
=
!
mScriptGlobalObject
&
&
aScriptGlobalObject
;
mScriptGlobalObject
=
aScriptGlobalObject
;
if
(
needOnloadBlocker
)
{
EnsureOnloadBlocker
(
)
;
}
UpdateFrameRequestCallbackSchedulingState
(
)
;
if
(
aScriptGlobalObject
)
{
mLayoutHistoryState
=
nullptr
;
SetScopeObject
(
aScriptGlobalObject
)
;
mHasHadDefaultView
=
true
;
if
(
mAllowDNSPrefetch
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_GetInterface
(
aScriptGlobalObject
)
;
NS_ASSERTION
(
SameCOMIdentity
(
webNav
docShell
)
"
Unexpected
container
or
script
global
?
"
)
;
#
endif
bool
allowDNSPrefetch
;
docShell
-
>
GetAllowDNSPrefetch
(
&
allowDNSPrefetch
)
;
mAllowDNSPrefetch
=
allowDNSPrefetch
;
}
}
IgnoredErrorResult
ignored
;
bool
focused
=
HasFocus
(
ignored
)
;
if
(
focused
)
{
SetLastFocusTime
(
TimeStamp
:
:
Now
(
)
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mScriptGlobalObject
)
;
mWindow
=
window
;
if
(
mCSP
)
{
static_cast
<
nsCSPContext
*
>
(
mCSP
.
get
(
)
)
-
>
flushConsoleMessages
(
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
GetChannel
(
)
)
;
if
(
internalChannel
)
{
nsCOMArray
<
nsISecurityConsoleMessage
>
messages
;
DebugOnly
<
nsresult
>
rv
=
internalChannel
-
>
TakeAllSecurityMessages
(
messages
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
SendToConsole
(
messages
)
;
}
dom
:
:
VisibilityState
oldState
=
mVisibilityState
;
mVisibilityState
=
ComputeVisibilityState
(
)
;
if
(
oldState
!
=
mVisibilityState
)
{
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
}
if
(
mTemplateContentsOwner
&
&
mTemplateContentsOwner
!
=
this
)
{
mTemplateContentsOwner
-
>
SetScriptGlobalObject
(
aScriptGlobalObject
)
;
}
if
(
!
mMaybeServiceWorkerControlled
&
&
mDocumentContainer
&
&
mScriptGlobalObject
&
&
GetChannel
(
)
)
{
if
(
mDocumentContainer
-
>
IsForceReloading
(
)
)
{
NS_WARNING
(
"
Page
was
shift
reloaded
skipping
ServiceWorker
control
"
)
;
return
;
}
mMaybeServiceWorkerControlled
=
true
;
}
}
nsIScriptGlobalObject
*
Document
:
:
GetScriptHandlingObjectInternal
(
)
const
{
MOZ_ASSERT
(
!
mScriptGlobalObject
"
Do
not
call
this
when
mScriptGlobalObject
is
set
!
"
)
;
if
(
mHasHadDefaultView
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptHandlingObject
=
do_QueryReferent
(
mScopeObject
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
scriptHandlingObject
)
;
if
(
win
)
{
nsPIDOMWindowOuter
*
outer
=
win
-
>
GetOuterWindow
(
)
;
if
(
!
outer
|
|
outer
-
>
GetCurrentInnerWindow
(
)
!
=
win
)
{
NS_WARNING
(
"
Wrong
inner
/
outer
window
combination
!
"
)
;
return
nullptr
;
}
}
return
scriptHandlingObject
;
}
void
Document
:
:
SetScriptHandlingObject
(
nsIScriptGlobalObject
*
aScriptObject
)
{
NS_ASSERTION
(
!
mScriptGlobalObject
|
|
mScriptGlobalObject
=
=
aScriptObject
"
Wrong
script
object
!
"
)
;
if
(
aScriptObject
)
{
SetScopeObject
(
aScriptObject
)
;
mHasHadDefaultView
=
false
;
}
}
nsPIDOMWindowOuter
*
Document
:
:
GetWindowInternal
(
)
const
{
MOZ_ASSERT
(
!
mWindow
"
This
should
not
be
called
when
mWindow
is
not
null
!
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
if
(
mRemovedFromDocShell
)
{
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
mDocumentContainer
)
;
if
(
kungFuDeathGrip
)
{
win
=
kungFuDeathGrip
-
>
GetWindow
(
)
;
}
}
else
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
mScriptGlobalObject
)
)
{
win
=
inner
-
>
GetOuterWindow
(
)
;
}
}
return
win
;
}
bool
Document
:
:
InternalAllowXULXBL
(
)
{
if
(
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
NodePrincipal
(
)
)
)
{
mAllowXULXBL
=
eTriTrue
;
return
true
;
}
mAllowXULXBL
=
eTriFalse
;
return
false
;
}
void
Document
:
:
AddObserver
(
nsIDocumentObserver
*
aObserver
)
{
NS_ASSERTION
(
mObservers
.
IndexOf
(
aObserver
)
=
=
nsTArray
<
int
>
:
:
NoIndex
"
Observer
already
in
the
list
"
)
;
mObservers
.
AppendElement
(
aObserver
)
;
AddMutationObserver
(
aObserver
)
;
}
bool
Document
:
:
RemoveObserver
(
nsIDocumentObserver
*
aObserver
)
{
if
(
!
mInDestructor
)
{
RemoveMutationObserver
(
aObserver
)
;
return
mObservers
.
RemoveElement
(
aObserver
)
;
}
return
mObservers
.
Contains
(
aObserver
)
;
}
void
Document
:
:
MaybeEndOutermostXBLUpdate
(
)
{
if
(
mUpdateNestLevel
=
=
0
&
&
mInXBLUpdate
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
mInXBLUpdate
=
false
;
BindingManager
(
)
-
>
EndOutermostUpdate
(
)
;
}
else
if
(
!
mInDestructor
)
{
if
(
!
mMaybeEndOutermostXBLUpdateRunner
)
{
mMaybeEndOutermostXBLUpdateRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeEndOutermostXBLUpdate
"
this
&
Document
:
:
MaybeEndOutermostXBLUpdate
)
;
}
nsContentUtils
:
:
AddScriptRunner
(
mMaybeEndOutermostXBLUpdateRunner
)
;
}
}
}
void
Document
:
:
BeginUpdate
(
)
{
if
(
mDocGroup
&
&
!
mIsGoingAway
&
&
!
mInUnlinkOrDeletion
&
&
!
mIgnoreDocGroupMismatches
)
{
mDocGroup
-
>
ValidateAccess
(
)
;
}
if
(
mUpdateNestLevel
=
=
0
&
&
!
mInXBLUpdate
)
{
mInXBLUpdate
=
true
;
BindingManager
(
)
-
>
BeginOutermostUpdate
(
)
;
}
+
+
mUpdateNestLevel
;
nsContentUtils
:
:
AddScriptBlocker
(
)
;
NS_DOCUMENT_NOTIFY_OBSERVERS
(
BeginUpdate
(
this
)
)
;
}
void
Document
:
:
EndUpdate
(
)
{
NS_DOCUMENT_NOTIFY_OBSERVERS
(
EndUpdate
(
this
)
)
;
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
-
-
mUpdateNestLevel
;
MaybeEndOutermostXBLUpdate
(
)
;
MaybeInitializeFinalizeFrameLoaders
(
)
;
if
(
mXULBroadcastManager
)
{
mXULBroadcastManager
-
>
MaybeBroadcast
(
)
;
}
}
void
Document
:
:
BeginLoad
(
)
{
MOZ_ASSERT
(
!
mDidCallBeginLoad
)
;
mDidCallBeginLoad
=
true
;
BlockOnload
(
)
;
mDidFireDOMContentLoaded
=
false
;
BlockDOMContentLoaded
(
)
;
if
(
mScriptLoader
)
{
mScriptLoader
-
>
BeginDeferringScripts
(
)
;
}
NS_DOCUMENT_NOTIFY_OBSERVERS
(
BeginLoad
(
this
)
)
;
}
void
Document
:
:
MozSetImageElement
(
const
nsAString
&
aImageElementId
Element
*
aElement
)
{
if
(
aImageElementId
.
IsEmpty
(
)
)
return
;
nsAutoScriptBlocker
scriptBlocker
;
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aImageElementId
)
;
if
(
entry
)
{
entry
-
>
SetImageElement
(
aElement
)
;
if
(
entry
-
>
IsEmpty
(
)
)
{
mIdentifierMap
.
RemoveEntry
(
entry
)
;
}
}
}
void
Document
:
:
DispatchContentLoadedEvents
(
)
{
mPreloadingImages
.
Clear
(
)
;
mPreloadedPreconnects
.
Clear
(
)
;
if
(
mTiming
)
{
mTiming
-
>
NotifyDOMContentLoadedStart
(
Document
:
:
GetDocumentURI
(
)
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
?
"
chrome
-
document
-
interactive
"
:
"
content
-
document
-
interactive
"
nullptr
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
this
ToSupports
(
this
)
NS_LITERAL_STRING
(
"
DOMContentLoaded
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
if
(
auto
*
const
window
=
GetInnerWindow
(
)
)
{
const
RefPtr
<
ServiceWorkerContainer
>
serviceWorker
=
window
-
>
Navigator
(
)
-
>
ServiceWorker
(
)
;
serviceWorker
-
>
StartMessages
(
)
;
}
if
(
MayStartLayout
(
)
)
{
MaybeResolveReadyForIdle
(
)
;
}
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
nsIDocShell
*
docShell
=
this
-
>
GetDocShell
(
)
;
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
MakeUnique
<
DocLoadingTimelineMarker
>
(
"
document
:
:
DOMContentLoaded
"
)
)
;
}
if
(
mTiming
)
{
mTiming
-
>
NotifyDOMContentLoadedEnd
(
Document
:
:
GetDocumentURI
(
)
)
;
}
nsCOMPtr
<
EventTarget
>
target_frame
;
if
(
mParentDocument
)
{
target_frame
=
mParentDocument
-
>
FindContentForSubDocument
(
this
)
;
}
if
(
target_frame
)
{
nsCOMPtr
<
Document
>
parent
=
mParentDocument
;
do
{
RefPtr
<
Event
>
event
;
if
(
parent
)
{
IgnoredErrorResult
ignored
;
event
=
parent
-
>
CreateEvent
(
NS_LITERAL_STRING
(
"
Events
"
)
CallerType
:
:
System
ignored
)
;
}
if
(
event
)
{
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
DOMFrameContentLoaded
"
)
true
true
)
;
event
-
>
SetTarget
(
target_frame
)
;
event
-
>
SetTrusted
(
true
)
;
WidgetEvent
*
innerEvent
=
event
-
>
WidgetEventPtr
(
)
;
if
(
innerEvent
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
RefPtr
<
nsPresContext
>
context
=
parent
-
>
GetPresContext
(
)
)
{
EventDispatcher
:
:
Dispatch
(
ToSupports
(
parent
)
context
innerEvent
event
&
status
)
;
}
}
}
parent
=
parent
-
>
GetParentDocument
(
)
;
}
while
(
parent
)
;
}
Element
*
root
=
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
manifest
)
)
{
nsContentUtils
:
:
DispatchChromeEvent
(
this
ToSupports
(
this
)
NS_LITERAL_STRING
(
"
MozApplicationManifest
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
inner
-
>
NoteDOMContentLoaded
(
)
;
}
if
(
mMaybeServiceWorkerControlled
)
{
using
mozilla
:
:
dom
:
:
ServiceWorkerManager
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
swm
)
{
Maybe
<
ClientInfo
>
clientInfo
=
GetClientInfo
(
)
;
if
(
clientInfo
.
isSome
(
)
)
{
swm
-
>
MaybeCheckNavigationUpdate
(
clientInfo
.
ref
(
)
)
;
}
}
}
UnblockOnload
(
true
)
;
}
#
if
defined
(
DEBUG
)
&
&
!
defined
(
ANDROID
)
static
void
AssertAboutPageHasCSP
(
Document
*
aDocument
)
{
nsCOMPtr
<
nsIURI
>
documentURI
=
aDocument
-
>
GetDocumentURI
(
)
;
bool
isAboutURI
=
(
NS_SUCCEEDED
(
documentURI
-
>
SchemeIs
(
"
about
"
&
isAboutURI
)
)
&
&
isAboutURI
)
;
if
(
!
isAboutURI
|
|
Preferences
:
:
GetBool
(
"
csp
.
skip_about_page_has_csp_assert
"
)
)
{
return
;
}
static
StaticAutoPtr
<
nsTArray
<
nsCString
>
>
sLegacyAboutPagesWithNoCSP
;
if
(
!
sLegacyAboutPagesWithNoCSP
|
|
Preferences
:
:
GetBool
(
"
csp
.
overrule_about_uris_without_csp_whitelist
"
)
)
{
sLegacyAboutPagesWithNoCSP
=
new
nsTArray
<
nsCString
>
(
)
;
nsAutoCString
legacyAboutPages
;
Preferences
:
:
GetCString
(
"
csp
.
about_uris_without_csp
"
legacyAboutPages
)
;
for
(
const
nsACString
&
hostString
:
legacyAboutPages
.
Split
(
'
'
)
)
{
nsCString
aboutURI
;
aboutURI
.
AppendLiteral
(
"
about
:
"
)
;
aboutURI
.
Append
(
hostString
)
;
sLegacyAboutPagesWithNoCSP
-
>
AppendElement
(
aboutURI
)
;
}
ClearOnShutdown
(
&
sLegacyAboutPagesWithNoCSP
)
;
}
nsAutoCString
aboutSpec
;
documentURI
-
>
GetSpec
(
aboutSpec
)
;
ToLowerCase
(
aboutSpec
)
;
for
(
auto
&
legacyPageEntry
:
*
sLegacyAboutPagesWithNoCSP
)
{
if
(
aboutSpec
.
Find
(
legacyPageEntry
)
=
=
0
)
{
return
;
}
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
bool
foundDefaultSrc
=
false
;
if
(
csp
)
{
uint32_t
policyCount
=
0
;
csp
-
>
GetPolicyCount
(
&
policyCount
)
;
nsAutoString
parsedPolicyStr
;
for
(
uint32_t
i
=
0
;
i
<
policyCount
;
+
+
i
)
{
csp
-
>
GetPolicyString
(
i
parsedPolicyStr
)
;
if
(
parsedPolicyStr
.
Find
(
"
default
-
src
"
)
>
=
0
)
{
foundDefaultSrc
=
true
;
break
;
}
}
}
if
(
Preferences
:
:
GetBool
(
"
csp
.
overrule_about_uris_without_csp_whitelist
"
)
)
{
NS_ASSERTION
(
foundDefaultSrc
"
about
:
page
must
have
a
CSP
"
)
;
return
;
}
MOZ_ASSERT
(
foundDefaultSrc
"
about
:
page
must
contain
a
CSP
including
default
-
src
"
)
;
}
#
endif
void
Document
:
:
EndLoad
(
)
{
#
if
defined
(
DEBUG
)
&
&
!
defined
(
ANDROID
)
if
(
!
mParserAborted
&
&
!
IsXULDocument
(
)
)
{
AssertAboutPageHasCSP
(
this
)
;
}
#
endif
if
(
mParser
)
{
mWeakSink
=
do_GetWeakReference
(
mParser
-
>
GetContentSink
(
)
)
;
mParser
=
nullptr
;
}
NS_DOCUMENT_NOTIFY_OBSERVERS
(
EndLoad
(
this
)
)
;
if
(
!
mDidCallBeginLoad
)
{
return
;
}
mDidCallBeginLoad
=
false
;
UnblockDOMContentLoaded
(
)
;
}
void
Document
:
:
UnblockDOMContentLoaded
(
)
{
MOZ_ASSERT
(
mBlockDOMContentLoaded
)
;
if
(
-
-
mBlockDOMContentLoaded
!
=
0
|
|
mDidFireDOMContentLoaded
)
{
return
;
}
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
UnblockDOMContentLoaded
"
this
)
)
;
mDidFireDOMContentLoaded
=
true
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
GetRefreshDriver
(
)
-
>
NotifyDOMContentLoaded
(
)
;
}
MOZ_ASSERT
(
mReadyState
=
=
READYSTATE_INTERACTIVE
)
;
if
(
!
mSynchronousDOMContentLoaded
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
Document
:
:
DispatchContentLoadedEvents
"
this
&
Document
:
:
DispatchContentLoadedEvents
)
;
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
}
else
{
DispatchContentLoadedEvents
(
)
;
}
}
void
Document
:
:
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aStateMask
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
scriptblocker
"
)
;
NS_DOCUMENT_NOTIFY_OBSERVERS
(
ContentStateChanged
(
this
aContent
aStateMask
)
)
;
}
void
Document
:
:
StyleRuleChanged
(
StyleSheet
*
aSheet
css
:
:
Rule
*
aStyleRule
)
{
ApplicableStylesChanged
(
)
;
if
(
!
StyleSheetChangeEventsEnabled
(
)
)
{
return
;
}
DO_STYLESHEET_NOTIFICATION
(
StyleRuleChangeEvent
"
StyleRuleChanged
"
mRule
aStyleRule
)
;
}
void
Document
:
:
StyleRuleAdded
(
StyleSheet
*
aSheet
css
:
:
Rule
*
aStyleRule
)
{
ApplicableStylesChanged
(
)
;
if
(
!
StyleSheetChangeEventsEnabled
(
)
)
{
return
;
}
DO_STYLESHEET_NOTIFICATION
(
StyleRuleChangeEvent
"
StyleRuleAdded
"
mRule
aStyleRule
)
;
}
void
Document
:
:
StyleRuleRemoved
(
StyleSheet
*
aSheet
css
:
:
Rule
*
aStyleRule
)
{
ApplicableStylesChanged
(
)
;
if
(
!
StyleSheetChangeEventsEnabled
(
)
)
{
return
;
}
DO_STYLESHEET_NOTIFICATION
(
StyleRuleChangeEvent
"
StyleRuleRemoved
"
mRule
aStyleRule
)
;
}
#
undef
DO_STYLESHEET_NOTIFICATION
static
Element
*
GetCustomContentContainer
(
PresShell
*
aPresShell
)
{
if
(
!
aPresShell
|
|
!
aPresShell
-
>
GetCanvasFrame
(
)
)
{
return
nullptr
;
}
return
aPresShell
-
>
GetCanvasFrame
(
)
-
>
GetCustomContentContainer
(
)
;
}
static
void
InsertAnonContentIntoCanvas
(
AnonymousContent
&
aAnonContent
PresShell
*
aPresShell
)
{
Element
*
container
=
GetCustomContentContainer
(
aPresShell
)
;
if
(
!
container
)
{
return
;
}
nsresult
rv
=
container
-
>
AppendChildTo
(
&
aAnonContent
.
ContentNode
(
)
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
aPresShell
-
>
GetCanvasFrame
(
)
-
>
ShowCustomContentContainer
(
)
;
}
already_AddRefed
<
AnonymousContent
>
Document
:
:
InsertAnonymousContent
(
Element
&
aElement
ErrorResult
&
aRv
)
{
nsAutoScriptBlocker
scriptBlocker
;
nsCOMPtr
<
nsINode
>
clone
=
aElement
.
CloneNode
(
true
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
auto
anonContent
=
MakeRefPtr
<
AnonymousContent
>
(
clone
.
forget
(
)
.
downcast
<
Element
>
(
)
)
;
mAnonymousContents
.
AppendElement
(
anonContent
)
;
InsertAnonContentIntoCanvas
(
*
anonContent
GetPresShell
(
)
)
;
return
anonContent
.
forget
(
)
;
}
static
void
RemoveAnonContentFromCanvas
(
AnonymousContent
&
aAnonContent
PresShell
*
aPresShell
)
{
RefPtr
<
Element
>
container
=
GetCustomContentContainer
(
aPresShell
)
;
if
(
!
container
)
{
return
;
}
container
-
>
RemoveChild
(
aAnonContent
.
ContentNode
(
)
IgnoreErrors
(
)
)
;
}
void
Document
:
:
RemoveAnonymousContent
(
AnonymousContent
&
aContent
ErrorResult
&
aRv
)
{
nsAutoScriptBlocker
scriptBlocker
;
auto
index
=
mAnonymousContents
.
IndexOf
(
&
aContent
)
;
if
(
index
=
=
mAnonymousContents
.
NoIndex
)
{
return
;
}
mAnonymousContents
.
RemoveElementAt
(
index
)
;
RemoveAnonContentFromCanvas
(
aContent
GetPresShell
(
)
)
;
if
(
mAnonymousContents
.
IsEmpty
(
)
&
&
GetCustomContentContainer
(
GetPresShell
(
)
)
)
{
GetPresShell
(
)
-
>
GetCanvasFrame
(
)
-
>
HideCustomContentContainer
(
)
;
}
}
Element
*
Document
:
:
GetAnonRootIfInAnonymousContentContainer
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
presShell
-
>
GetCanvasFrame
(
)
)
{
return
nullptr
;
}
nsAutoScriptBlocker
scriptBlocker
;
nsCOMPtr
<
Element
>
customContainer
=
presShell
-
>
GetCanvasFrame
(
)
-
>
GetCustomContentContainer
(
)
;
if
(
!
customContainer
)
{
return
nullptr
;
}
nsINode
*
child
=
aNode
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
while
(
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
if
(
parent
=
=
customContainer
)
{
return
Element
:
:
FromNode
(
child
)
;
}
child
=
parent
;
parent
=
child
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
Maybe
<
ClientInfo
>
Document
:
:
GetClientInfo
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
return
inner
-
>
GetClientInfo
(
)
;
}
return
Maybe
<
ClientInfo
>
(
)
;
}
Maybe
<
ClientState
>
Document
:
:
GetClientState
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
return
inner
-
>
GetClientState
(
)
;
}
return
Maybe
<
ClientState
>
(
)
;
}
Maybe
<
ServiceWorkerDescriptor
>
Document
:
:
GetController
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
return
inner
-
>
GetController
(
)
;
}
return
Maybe
<
ServiceWorkerDescriptor
>
(
)
;
}
DocumentType
*
Document
:
:
GetDoctype
(
)
const
{
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
NodeType
(
)
=
=
DOCUMENT_TYPE_NODE
)
{
return
static_cast
<
DocumentType
*
>
(
child
)
;
}
}
return
nullptr
;
}
DOMImplementation
*
Document
:
:
GetImplementation
(
ErrorResult
&
rv
)
{
if
(
!
mDOMImplementation
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
)
;
if
(
!
uri
)
{
rv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
GetScriptHandlingObject
(
hasHadScriptObject
)
;
if
(
!
scriptObject
&
&
hasHadScriptObject
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
mDOMImplementation
=
new
DOMImplementation
(
this
scriptObject
?
scriptObject
:
GetScopeObject
(
)
uri
uri
)
;
}
return
mDOMImplementation
;
}
bool
IsLowercaseASCII
(
const
nsAString
&
aValue
)
{
int32_t
len
=
aValue
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
char16_t
c
=
aValue
[
i
]
;
if
(
!
(
0x0061
<
=
(
c
)
&
&
(
(
c
)
<
=
0x007a
)
)
)
{
return
false
;
}
}
return
true
;
}
static
PseudoStyleType
GetPseudoElementType
(
const
nsString
&
aString
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aString
.
IsEmpty
(
)
"
GetPseudoElementType
aString
should
be
non
-
null
"
)
;
if
(
aString
.
Length
(
)
<
=
2
|
|
aString
[
0
]
!
=
'
:
'
|
|
aString
[
1
]
!
=
'
:
'
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
PseudoStyleType
:
:
NotPseudo
;
}
RefPtr
<
nsAtom
>
pseudo
=
NS_Atomize
(
Substring
(
aString
1
)
)
;
return
nsCSSPseudoElements
:
:
GetPseudoType
(
pseudo
CSSEnabledState
:
:
InUASheets
)
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
{
rv
=
nsContentUtils
:
:
CheckQName
(
aTagName
false
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
IsXULDocument
(
)
)
{
#
if
DEBUG
xpc_DumpJSStack
(
true
true
false
)
;
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
false
"
CreateElement
(
)
not
allowed
in
XUL
document
.
"
)
;
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
bool
needsLowercase
=
IsHTMLDocument
(
)
&
&
!
IsLowercaseASCII
(
aTagName
)
;
nsAutoString
lcTagName
;
if
(
needsLowercase
)
{
nsContentUtils
:
:
ASCIIToLower
(
aTagName
lcTagName
)
;
}
const
nsString
*
is
=
nullptr
;
PseudoStyleType
pseudoType
=
PseudoStyleType
:
:
NotPseudo
;
if
(
aOptions
.
IsElementCreationOptions
(
)
)
{
const
ElementCreationOptions
&
options
=
aOptions
.
GetAsElementCreationOptions
(
)
;
if
(
options
.
mIs
.
WasPassed
(
)
)
{
is
=
&
options
.
mIs
.
Value
(
)
;
}
if
(
options
.
mPseudo
.
WasPassed
(
)
)
{
pseudoType
=
GetPseudoElementType
(
options
.
mPseudo
.
Value
(
)
rv
)
;
if
(
rv
.
Failed
(
)
|
|
pseudoType
=
=
PseudoStyleType
:
:
NotPseudo
|
|
!
nsCSSPseudoElements
:
:
PseudoElementIsJSCreatedNAC
(
pseudoType
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
}
RefPtr
<
Element
>
elem
=
CreateElem
(
needsLowercase
?
lcTagName
:
aTagName
nullptr
mDefaultElementType
is
)
;
if
(
pseudoType
!
=
PseudoStyleType
:
:
NotPseudo
)
{
elem
-
>
SetPseudoElementType
(
pseudoType
)
;
}
return
elem
.
forget
(
)
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateElementNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
rv
=
nsContentUtils
:
:
GetNodeInfoFromQName
(
aNamespaceURI
aQualifiedName
mNodeInfoManager
ELEMENT_NODE
getter_AddRefs
(
nodeInfo
)
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
const
nsString
*
is
=
nullptr
;
if
(
aOptions
.
IsElementCreationOptions
(
)
)
{
const
ElementCreationOptions
&
options
=
aOptions
.
GetAsElementCreationOptions
(
)
;
if
(
options
.
mIs
.
WasPassed
(
)
)
{
is
=
&
options
.
mIs
.
Value
(
)
;
}
}
nsCOMPtr
<
Element
>
element
;
rv
=
NS_NewElement
(
getter_AddRefs
(
element
)
nodeInfo
.
forget
(
)
NOT_FROM_PARSER
is
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
element
.
forget
(
)
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateXULElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
aRv
)
{
aRv
=
nsContentUtils
:
:
CheckQName
(
aTagName
false
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
const
nsString
*
is
=
nullptr
;
if
(
aOptions
.
IsElementCreationOptions
(
)
)
{
const
ElementCreationOptions
&
options
=
aOptions
.
GetAsElementCreationOptions
(
)
;
if
(
options
.
mIs
.
WasPassed
(
)
)
{
is
=
&
options
.
mIs
.
Value
(
)
;
}
}
RefPtr
<
Element
>
elem
=
CreateElem
(
aTagName
nullptr
kNameSpaceID_XUL
is
)
;
if
(
!
elem
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
return
elem
.
forget
(
)
;
}
already_AddRefed
<
nsTextNode
>
Document
:
:
CreateEmptyTextNode
(
)
const
{
RefPtr
<
nsTextNode
>
text
=
new
nsTextNode
(
mNodeInfoManager
)
;
return
text
.
forget
(
)
;
}
already_AddRefed
<
nsTextNode
>
Document
:
:
CreateTextNode
(
const
nsAString
&
aData
)
const
{
RefPtr
<
nsTextNode
>
text
=
new
nsTextNode
(
mNodeInfoManager
)
;
text
-
>
SetText
(
aData
false
)
;
return
text
.
forget
(
)
;
}
already_AddRefed
<
DocumentFragment
>
Document
:
:
CreateDocumentFragment
(
)
const
{
RefPtr
<
DocumentFragment
>
frag
=
new
DocumentFragment
(
mNodeInfoManager
)
;
return
frag
.
forget
(
)
;
}
already_AddRefed
<
dom
:
:
Comment
>
Document
:
:
CreateComment
(
const
nsAString
&
aData
)
const
{
RefPtr
<
dom
:
:
Comment
>
comment
=
new
dom
:
:
Comment
(
mNodeInfoManager
)
;
comment
-
>
SetText
(
aData
false
)
;
return
comment
.
forget
(
)
;
}
already_AddRefed
<
CDATASection
>
Document
:
:
CreateCDATASection
(
const
nsAString
&
aData
ErrorResult
&
rv
)
{
if
(
IsHTMLDocument
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
]
]
>
"
)
aData
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_CHARACTER_ERR
)
;
return
nullptr
;
}
RefPtr
<
CDATASection
>
cdata
=
new
CDATASection
(
mNodeInfoManager
)
;
cdata
-
>
SetText
(
aData
false
)
;
return
cdata
.
forget
(
)
;
}
already_AddRefed
<
ProcessingInstruction
>
Document
:
:
CreateProcessingInstruction
(
const
nsAString
&
aTarget
const
nsAString
&
aData
ErrorResult
&
rv
)
const
{
nsresult
res
=
nsContentUtils
:
:
CheckQName
(
aTarget
false
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
if
(
FindInReadable
(
NS_LITERAL_STRING
(
"
?
>
"
)
aData
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_CHARACTER_ERR
)
;
return
nullptr
;
}
RefPtr
<
ProcessingInstruction
>
pi
=
NS_NewXMLProcessingInstruction
(
mNodeInfoManager
aTarget
aData
)
;
return
pi
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
Document
:
:
CreateAttribute
(
const
nsAString
&
aName
ErrorResult
&
rv
)
{
if
(
!
mNodeInfoManager
)
{
rv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
nsresult
res
=
nsContentUtils
:
:
CheckQName
(
aName
false
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
nsAutoString
name
;
if
(
IsHTMLDocument
(
)
)
{
nsContentUtils
:
:
ASCIIToLower
(
aName
name
)
;
}
else
{
name
=
aName
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
res
=
mNodeInfoManager
-
>
GetNodeInfo
(
name
nullptr
kNameSpaceID_None
ATTRIBUTE_NODE
getter_AddRefs
(
nodeInfo
)
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
RefPtr
<
Attr
>
attribute
=
new
Attr
(
nullptr
nodeInfo
.
forget
(
)
EmptyString
(
)
)
;
return
attribute
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
Document
:
:
CreateAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
ErrorResult
&
rv
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
rv
=
nsContentUtils
:
:
GetNodeInfoFromQName
(
aNamespaceURI
aQualifiedName
mNodeInfoManager
ATTRIBUTE_NODE
getter_AddRefs
(
nodeInfo
)
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
Attr
>
attribute
=
new
Attr
(
nullptr
nodeInfo
.
forget
(
)
EmptyString
(
)
)
;
return
attribute
.
forget
(
)
;
}
void
Document
:
:
ResolveScheduledSVGPresAttrs
(
)
{
for
(
auto
iter
=
mLazySVGPresElements
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
SVGElement
*
svg
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
svg
-
>
UpdateContentDeclarationBlock
(
)
;
}
mLazySVGPresElements
.
Clear
(
)
;
}
already_AddRefed
<
nsSimpleContentList
>
Document
:
:
BlockedNodesByClassifier
(
)
const
{
RefPtr
<
nsSimpleContentList
>
list
=
new
nsSimpleContentList
(
nullptr
)
;
nsTArray
<
nsWeakPtr
>
blockedNodes
;
blockedNodes
=
mBlockedNodesByClassifier
;
for
(
unsigned
long
i
=
0
;
i
<
blockedNodes
.
Length
(
)
;
i
+
+
)
{
nsWeakPtr
weakNode
=
blockedNodes
[
i
]
;
nsCOMPtr
<
nsIContent
>
node
=
do_QueryReferent
(
weakNode
)
;
if
(
node
)
{
list
-
>
AppendElement
(
node
)
;
}
}
return
list
.
forget
(
)
;
}
void
Document
:
:
GetSelectedStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
.
Truncate
(
)
;
size_t
count
=
SheetCount
(
)
;
nsAutoString
title
;
for
(
size_t
index
=
0
;
index
<
count
;
index
+
+
)
{
StyleSheet
*
sheet
=
SheetAt
(
index
)
;
NS_ASSERTION
(
sheet
"
Null
sheet
in
sheet
list
!
"
)
;
if
(
sheet
-
>
Disabled
(
)
)
{
continue
;
}
sheet
-
>
GetTitle
(
title
)
;
if
(
aSheetSet
.
IsEmpty
(
)
)
{
aSheetSet
=
title
;
}
else
if
(
!
title
.
IsEmpty
(
)
&
&
!
aSheetSet
.
Equals
(
title
)
)
{
SetDOMStringToNull
(
aSheetSet
)
;
return
;
}
}
}
void
Document
:
:
SetSelectedStyleSheetSet
(
const
nsAString
&
aSheetSet
)
{
if
(
DOMStringIsNull
(
aSheetSet
)
)
{
return
;
}
mLastStyleSheetSet
=
aSheetSet
;
EnableStyleSheetsForSetInternal
(
aSheetSet
true
)
;
}
void
Document
:
:
SetPreferredStyleSheetSet
(
const
nsAString
&
aSheetSet
)
{
mPreferredStyleSheetSet
=
aSheetSet
;
if
(
DOMStringIsNull
(
mLastStyleSheetSet
)
)
{
EnableStyleSheetsForSetInternal
(
aSheetSet
true
)
;
}
}
DOMStringList
*
Document
:
:
StyleSheetSets
(
)
{
if
(
!
mStyleSheetSetList
)
{
mStyleSheetSetList
=
new
DOMStyleSheetSetList
(
this
)
;
}
return
mStyleSheetSetList
;
}
void
Document
:
:
EnableStyleSheetsForSet
(
const
nsAString
&
aSheetSet
)
{
if
(
!
DOMStringIsNull
(
aSheetSet
)
)
{
EnableStyleSheetsForSetInternal
(
aSheetSet
false
)
;
}
}
void
Document
:
:
EnableStyleSheetsForSetInternal
(
const
nsAString
&
aSheetSet
bool
aUpdateCSSLoader
)
{
size_t
count
=
SheetCount
(
)
;
nsAutoString
title
;
for
(
size_t
index
=
0
;
index
<
count
;
index
+
+
)
{
StyleSheet
*
sheet
=
SheetAt
(
index
)
;
NS_ASSERTION
(
sheet
"
Null
sheet
in
sheet
list
!
"
)
;
sheet
-
>
GetTitle
(
title
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
sheet
-
>
SetEnabled
(
title
.
Equals
(
aSheetSet
)
)
;
}
}
if
(
aUpdateCSSLoader
)
{
CSSLoader
(
)
-
>
DocumentStyleSheetSetChanged
(
)
;
}
if
(
mStyleSet
-
>
StyleSheetsHaveChanged
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
GetCharacterSet
(
nsAString
&
aCharacterSet
)
const
{
nsAutoCString
charset
;
GetDocumentCharacterSet
(
)
-
>
Name
(
charset
)
;
CopyASCIItoUTF16
(
charset
aCharacterSet
)
;
}
already_AddRefed
<
nsINode
>
Document
:
:
ImportNode
(
nsINode
&
aNode
bool
aDeep
ErrorResult
&
rv
)
const
{
nsINode
*
imported
=
&
aNode
;
switch
(
imported
-
>
NodeType
(
)
)
{
case
DOCUMENT_NODE
:
{
break
;
}
case
DOCUMENT_FRAGMENT_NODE
:
case
ATTRIBUTE_NODE
:
case
ELEMENT_NODE
:
case
PROCESSING_INSTRUCTION_NODE
:
case
TEXT_NODE
:
case
CDATA_SECTION_NODE
:
case
COMMENT_NODE
:
case
DOCUMENT_TYPE_NODE
:
{
return
nsNodeUtils
:
:
Clone
(
imported
aDeep
mNodeInfoManager
nullptr
rv
)
;
}
default
:
{
NS_WARNING
(
"
Don
'
t
know
how
to
clone
this
nodetype
for
importNode
.
"
)
;
}
}
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
void
Document
:
:
LoadBindingDocument
(
const
nsAString
&
aURI
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aURI
mCharacterSet
GetDocBaseURI
(
)
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
BindingManager
(
)
-
>
LoadBindingDocument
(
this
uri
&
aSubjectPrincipal
)
;
}
Element
*
Document
:
:
GetBindingParent
(
nsINode
&
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
&
aNode
)
)
;
if
(
!
content
)
return
nullptr
;
nsIContent
*
bindingParent
=
content
-
>
GetBindingParent
(
)
;
return
bindingParent
?
bindingParent
-
>
AsElement
(
)
:
nullptr
;
}
static
Element
*
GetElementByAttribute
(
Element
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aAttrValue
bool
aUniversalMatch
)
{
if
(
aUniversalMatch
?
aElement
-
>
HasAttr
(
kNameSpaceID_None
aAttrName
)
:
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
aAttrName
aAttrValue
eCaseMatters
)
)
{
return
aElement
;
}
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
matchedElement
=
GetElementByAttribute
(
child
-
>
AsElement
(
)
aAttrName
aAttrValue
aUniversalMatch
)
;
if
(
matchedElement
)
return
matchedElement
;
}
return
nullptr
;
}
Element
*
Document
:
:
GetAnonymousElementByAttribute
(
nsIContent
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aAttrValue
)
const
{
nsINodeList
*
nodeList
=
BindingManager
(
)
-
>
GetAnonymousNodesFor
(
aElement
)
;
if
(
!
nodeList
)
return
nullptr
;
uint32_t
length
=
nodeList
-
>
Length
(
)
;
bool
universalMatch
=
aAttrValue
.
EqualsLiteral
(
"
*
"
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
Element
*
current
=
Element
:
:
FromNode
(
nodeList
-
>
Item
(
i
)
)
;
if
(
!
current
)
{
continue
;
}
Element
*
matchedElm
=
GetElementByAttribute
(
current
aAttrName
aAttrValue
universalMatch
)
;
if
(
matchedElm
)
return
matchedElm
;
}
return
nullptr
;
}
Element
*
Document
:
:
GetAnonymousElementByAttribute
(
Element
&
aElement
const
nsAString
&
aAttrName
const
nsAString
&
aAttrValue
)
{
RefPtr
<
nsAtom
>
attribute
=
NS_Atomize
(
aAttrName
)
;
return
GetAnonymousElementByAttribute
(
&
aElement
attribute
aAttrValue
)
;
}
nsINodeList
*
Document
:
:
GetAnonymousNodes
(
Element
&
aElement
)
{
return
BindingManager
(
)
-
>
GetAnonymousNodesFor
(
&
aElement
)
;
}
already_AddRefed
<
nsRange
>
Document
:
:
CreateRange
(
ErrorResult
&
rv
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
this
)
;
nsresult
res
=
range
-
>
CollapseTo
(
this
0
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
return
range
.
forget
(
)
;
}
already_AddRefed
<
NodeIterator
>
Document
:
:
CreateNodeIterator
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
{
RefPtr
<
NodeIterator
>
iterator
=
new
NodeIterator
(
&
aRoot
aWhatToShow
aFilter
)
;
return
iterator
.
forget
(
)
;
}
already_AddRefed
<
TreeWalker
>
Document
:
:
CreateTreeWalker
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
{
RefPtr
<
TreeWalker
>
walker
=
new
TreeWalker
(
&
aRoot
aWhatToShow
aFilter
)
;
return
walker
.
forget
(
)
;
}
already_AddRefed
<
Location
>
Document
:
:
GetLocation
(
)
const
{
nsCOMPtr
<
nsPIDOMWindowInner
>
w
=
do_QueryInterface
(
mScriptGlobalObject
)
;
if
(
!
w
)
{
return
nullptr
;
}
return
do_AddRef
(
w
-
>
Location
(
)
)
;
}
Element
*
Document
:
:
GetHtmlElement
(
)
const
{
Element
*
rootElement
=
GetRootElement
(
)
;
if
(
rootElement
&
&
rootElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
return
rootElement
;
return
nullptr
;
}
Element
*
Document
:
:
GetHtmlChildElement
(
nsAtom
*
aTag
)
{
Element
*
html
=
GetHtmlElement
(
)
;
if
(
!
html
)
return
nullptr
;
for
(
nsIContent
*
child
=
html
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
aTag
)
)
return
child
-
>
AsElement
(
)
;
}
return
nullptr
;
}
nsGenericHTMLElement
*
Document
:
:
GetBody
(
)
{
Element
*
html
=
GetHtmlElement
(
)
;
if
(
!
html
)
{
return
nullptr
;
}
for
(
nsIContent
*
child
=
html
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frameset
)
)
{
return
static_cast
<
nsGenericHTMLElement
*
>
(
child
)
;
}
}
return
nullptr
;
}
void
Document
:
:
SetBody
(
nsGenericHTMLElement
*
newBody
ErrorResult
&
rv
)
{
nsCOMPtr
<
Element
>
root
=
GetRootElement
(
)
;
if
(
!
newBody
|
|
!
newBody
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
frameset
)
|
|
!
root
)
{
rv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
nsCOMPtr
<
Element
>
currentBody
=
GetBody
(
)
;
if
(
currentBody
)
{
root
-
>
ReplaceChild
(
*
newBody
*
currentBody
rv
)
;
}
else
{
root
-
>
AppendChild
(
*
newBody
rv
)
;
}
}
HTMLSharedElement
*
Document
:
:
GetHead
(
)
{
return
static_cast
<
HTMLSharedElement
*
>
(
GetHeadElement
(
)
)
;
}
Element
*
Document
:
:
GetTitleElement
(
)
{
if
(
!
mMayHaveTitleElement
)
return
nullptr
;
Element
*
root
=
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
for
(
nsIContent
*
child
=
root
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsSVGElement
(
nsGkAtoms
:
:
title
)
)
{
return
child
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
RefPtr
<
nsContentList
>
list
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
title
nsGkAtoms
:
:
title
true
false
)
;
nsIContent
*
first
=
list
-
>
Item
(
0
false
)
;
return
first
?
first
-
>
AsElement
(
)
:
nullptr
;
}
void
Document
:
:
GetTitle
(
nsAString
&
aTitle
)
{
aTitle
.
Truncate
(
)
;
Element
*
rootElement
=
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
nsAutoString
tmp
;
#
ifdef
MOZ_XUL
if
(
rootElement
-
>
IsXULElement
(
)
)
{
rootElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
title
tmp
)
;
}
else
#
endif
{
Element
*
title
=
GetTitleElement
(
)
;
if
(
!
title
)
{
return
;
}
nsContentUtils
:
:
GetNodeTextContent
(
title
false
tmp
)
;
}
tmp
.
CompressWhitespace
(
)
;
aTitle
=
tmp
;
}
void
Document
:
:
SetTitle
(
const
nsAString
&
aTitle
ErrorResult
&
aRv
)
{
Element
*
rootElement
=
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
#
ifdef
MOZ_XUL
if
(
rootElement
-
>
IsXULElement
(
)
)
{
aRv
=
rootElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
title
aTitle
true
)
;
return
;
}
#
endif
Maybe
<
mozAutoDocUpdate
>
updateBatch
;
nsCOMPtr
<
Element
>
title
=
GetTitleElement
(
)
;
if
(
rootElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
if
(
!
title
)
{
updateBatch
.
emplace
(
this
true
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
titleInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
title
nullptr
kNameSpaceID_SVG
ELEMENT_NODE
)
;
NS_NewSVGElement
(
getter_AddRefs
(
title
)
titleInfo
.
forget
(
)
NOT_FROM_PARSER
)
;
if
(
!
title
)
{
return
;
}
rootElement
-
>
InsertChildBefore
(
title
rootElement
-
>
GetFirstChild
(
)
true
)
;
}
}
else
if
(
rootElement
-
>
IsHTMLElement
(
)
)
{
if
(
!
title
)
{
updateBatch
.
emplace
(
this
true
)
;
Element
*
head
=
GetHeadElement
(
)
;
if
(
!
head
)
{
return
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
titleInfo
;
titleInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
title
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
title
=
NS_NewHTMLTitleElement
(
titleInfo
.
forget
(
)
)
;
if
(
!
title
)
{
return
;
}
head
-
>
AppendChildTo
(
title
true
)
;
}
}
else
{
return
;
}
aRv
=
nsContentUtils
:
:
SetNodeTextContent
(
title
aTitle
false
)
;
}
void
Document
:
:
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
{
NS_ASSERTION
(
!
mInUnlinkOrDeletion
|
|
!
aBoundTitleElement
"
Setting
a
title
while
unlinking
or
destroying
the
element
?
"
)
;
if
(
mInUnlinkOrDeletion
)
{
return
;
}
if
(
aBoundTitleElement
)
{
mMayHaveTitleElement
=
true
;
}
if
(
mPendingTitleChangeEvent
.
IsPending
(
)
)
return
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsRunnableMethod
<
Document
void
false
>
>
event
=
NewNonOwningRunnableMethod
(
"
Document
:
:
DoNotifyPossibleTitleChange
"
this
&
Document
:
:
DoNotifyPossibleTitleChange
)
;
nsresult
rv
=
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
event
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingTitleChangeEvent
=
std
:
:
move
(
event
)
;
}
}
void
Document
:
:
DoNotifyPossibleTitleChange
(
)
{
mPendingTitleChangeEvent
.
Forget
(
)
;
mHaveFiredTitleChange
=
true
;
nsAutoString
title
;
GetTitle
(
title
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
nsCOMPtr
<
nsISupports
>
container
=
presShell
-
>
GetPresContext
(
)
-
>
GetContainerWeak
(
)
;
if
(
container
)
{
nsCOMPtr
<
nsIBaseWindow
>
docShellWin
=
do_QueryInterface
(
container
)
;
if
(
docShellWin
)
{
docShellWin
-
>
SetTitle
(
title
)
;
}
}
}
nsContentUtils
:
:
DispatchChromeEvent
(
this
ToSupports
(
this
)
NS_LITERAL_STRING
(
"
DOMTitleChanged
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
already_AddRefed
<
BoxObject
>
Document
:
:
GetBoxObjectFor
(
Element
*
aElement
ErrorResult
&
aRv
)
{
if
(
!
aElement
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
if
(
doc
!
=
this
)
{
aRv
.
Throw
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
nullptr
;
}
if
(
!
mHasWarnedAboutBoxObjects
&
&
!
aElement
-
>
IsXULElement
(
)
)
{
mHasWarnedAboutBoxObjects
=
true
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
BoxObjects
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
UseOfGetBoxObjectForWarning
"
)
;
}
if
(
!
mBoxObjectTable
)
{
mBoxObjectTable
=
new
nsRefPtrHashtable
<
nsPtrHashKey
<
nsIContent
>
BoxObject
>
(
6
)
;
}
RefPtr
<
BoxObject
>
boxObject
;
auto
entry
=
mBoxObjectTable
-
>
LookupForAdd
(
aElement
)
;
if
(
entry
)
{
boxObject
=
entry
.
Data
(
)
;
return
boxObject
.
forget
(
)
;
}
boxObject
=
new
BoxObject
(
)
;
boxObject
-
>
Init
(
aElement
)
;
entry
.
OrInsert
(
[
&
boxObject
]
(
)
{
return
boxObject
;
}
)
;
return
boxObject
.
forget
(
)
;
}
void
Document
:
:
ClearBoxObjectFor
(
nsIContent
*
aContent
)
{
if
(
mBoxObjectTable
)
{
if
(
auto
entry
=
mBoxObjectTable
-
>
Lookup
(
aContent
)
)
{
nsPIBoxObject
*
boxObject
=
entry
.
Data
(
)
;
boxObject
-
>
Clear
(
)
;
entry
.
Remove
(
)
;
}
}
}
already_AddRefed
<
MediaQueryList
>
Document
:
:
MatchMedia
(
const
nsAString
&
aMediaQueryList
CallerType
aCallerType
)
{
RefPtr
<
MediaQueryList
>
result
=
new
MediaQueryList
(
this
aMediaQueryList
aCallerType
)
;
mDOMMediaQueryLists
.
insertBack
(
result
)
;
return
result
.
forget
(
)
;
}
void
Document
:
:
SetMayStartLayout
(
bool
aMayStartLayout
)
{
mMayStartLayout
=
aMayStartLayout
;
if
(
MayStartLayout
(
)
)
{
if
(
nsCOMPtr
<
nsIXULWindow
>
win
=
GetXULWindowIfToplevelChrome
(
)
)
{
win
-
>
BeforeStartLayout
(
)
;
}
ReadyState
state
=
GetReadyStateEnum
(
)
;
if
(
state
>
=
READYSTATE_INTERACTIVE
)
{
MaybeResolveReadyForIdle
(
)
;
}
}
}
nsresult
Document
:
:
InitializeFrameLoader
(
nsFrameLoader
*
aLoader
)
{
mInitializableFrameLoaders
.
RemoveElement
(
aLoader
)
;
if
(
mInDestructor
)
{
NS_WARNING
(
"
Trying
to
initialize
a
frame
loader
while
"
"
document
is
being
deleted
"
)
;
return
NS_ERROR_FAILURE
;
}
mInitializableFrameLoaders
.
AppendElement
(
aLoader
)
;
if
(
!
mFrameLoaderRunner
)
{
mFrameLoaderRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeInitializeFinalizeFrameLoaders
"
this
&
Document
:
:
MaybeInitializeFinalizeFrameLoaders
)
;
NS_ENSURE_TRUE
(
mFrameLoaderRunner
NS_ERROR_OUT_OF_MEMORY
)
;
nsContentUtils
:
:
AddScriptRunner
(
mFrameLoaderRunner
)
;
}
return
NS_OK
;
}
nsresult
Document
:
:
FinalizeFrameLoader
(
nsFrameLoader
*
aLoader
nsIRunnable
*
aFinalizer
)
{
mInitializableFrameLoaders
.
RemoveElement
(
aLoader
)
;
if
(
mInDestructor
)
{
return
NS_ERROR_FAILURE
;
}
mFrameLoaderFinalizers
.
AppendElement
(
aFinalizer
)
;
if
(
!
mFrameLoaderRunner
)
{
mFrameLoaderRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeInitializeFinalizeFrameLoaders
"
this
&
Document
:
:
MaybeInitializeFinalizeFrameLoaders
)
;
NS_ENSURE_TRUE
(
mFrameLoaderRunner
NS_ERROR_OUT_OF_MEMORY
)
;
nsContentUtils
:
:
AddScriptRunner
(
mFrameLoaderRunner
)
;
}
return
NS_OK
;
}
void
Document
:
:
MaybeInitializeFinalizeFrameLoaders
(
)
{
if
(
mDelayFrameLoaderInitialization
|
|
mUpdateNestLevel
!
=
0
)
{
mFrameLoaderRunner
=
nullptr
;
return
;
}
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
if
(
!
mInDestructor
&
&
!
mFrameLoaderRunner
&
&
(
mInitializableFrameLoaders
.
Length
(
)
|
|
mFrameLoaderFinalizers
.
Length
(
)
)
)
{
mFrameLoaderRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeInitializeFinalizeFrameLoaders
"
this
&
Document
:
:
MaybeInitializeFinalizeFrameLoaders
)
;
nsContentUtils
:
:
AddScriptRunner
(
mFrameLoaderRunner
)
;
}
return
;
}
mFrameLoaderRunner
=
nullptr
;
while
(
mInitializableFrameLoaders
.
Length
(
)
)
{
RefPtr
<
nsFrameLoader
>
loader
=
mInitializableFrameLoaders
[
0
]
;
mInitializableFrameLoaders
.
RemoveElementAt
(
0
)
;
NS_ASSERTION
(
loader
"
null
frameloader
in
the
array
?
"
)
;
loader
-
>
ReallyStartLoading
(
)
;
}
uint32_t
length
=
mFrameLoaderFinalizers
.
Length
(
)
;
if
(
length
>
0
)
{
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
finalizers
;
mFrameLoaderFinalizers
.
SwapElements
(
finalizers
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
finalizers
[
i
]
-
>
Run
(
)
;
}
}
}
void
Document
:
:
TryCancelFrameLoaderInitialization
(
nsIDocShell
*
aShell
)
{
uint32_t
length
=
mInitializableFrameLoaders
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mInitializableFrameLoaders
[
i
]
-
>
GetExistingDocShell
(
)
=
=
aShell
)
{
mInitializableFrameLoaders
.
RemoveElementAt
(
i
)
;
return
;
}
}
}
void
Document
:
:
SetPrototypeDocument
(
nsXULPrototypeDocument
*
aPrototype
)
{
mPrototypeDocument
=
aPrototype
;
}
Document
*
Document
:
:
RequestExternalResource
(
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
nsINode
*
aRequestingNode
ExternalResourceLoad
*
*
aPendingLoad
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aRequestingNode
"
Must
have
a
node
"
)
;
if
(
mDisplayDocument
)
{
return
mDisplayDocument
-
>
RequestExternalResource
(
aURI
aReferrer
aReferrerPolicy
aRequestingNode
aPendingLoad
)
;
}
return
mExternalResourceMap
.
RequestResource
(
aURI
aReferrer
aReferrerPolicy
aRequestingNode
this
aPendingLoad
)
;
}
void
Document
:
:
EnumerateExternalResources
(
SubDocEnumFunc
aCallback
void
*
aData
)
{
mExternalResourceMap
.
EnumerateResources
(
aCallback
aData
)
;
}
SMILAnimationController
*
Document
:
:
GetAnimationController
(
)
{
if
(
mAnimationController
)
return
mAnimationController
;
if
(
mLoadedAsData
|
|
mLoadedAsInteractiveData
)
return
nullptr
;
mAnimationController
=
new
SMILAnimationController
(
this
)
;
nsPresContext
*
context
=
GetPresContext
(
)
;
if
(
mAnimationController
&
&
context
&
&
context
-
>
ImageAnimationMode
(
)
=
=
imgIContainer
:
:
kDontAnimMode
)
{
mAnimationController
-
>
Pause
(
SMILTimeContainer
:
:
PAUSE_USERPREF
)
;
}
if
(
!
mIsShowing
&
&
!
mIsBeingUsedAsImage
)
{
mAnimationController
-
>
OnPageHide
(
)
;
}
return
mAnimationController
;
}
PendingAnimationTracker
*
Document
:
:
GetOrCreatePendingAnimationTracker
(
)
{
if
(
!
mPendingAnimationTracker
)
{
mPendingAnimationTracker
=
new
PendingAnimationTracker
(
this
)
;
}
return
mPendingAnimationTracker
;
}
void
Document
:
:
GetDir
(
nsAString
&
aDirection
)
const
{
aDirection
.
Truncate
(
)
;
Element
*
rootElement
=
GetHtmlElement
(
)
;
if
(
rootElement
)
{
static_cast
<
nsGenericHTMLElement
*
>
(
rootElement
)
-
>
GetDir
(
aDirection
)
;
}
}
void
Document
:
:
SetDir
(
const
nsAString
&
aDirection
)
{
Element
*
rootElement
=
GetHtmlElement
(
)
;
if
(
rootElement
)
{
rootElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
aDirection
true
)
;
}
}
nsIHTMLCollection
*
Document
:
:
Images
(
)
{
if
(
!
mImages
)
{
mImages
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
img
nsGkAtoms
:
:
img
)
;
}
return
mImages
;
}
nsIHTMLCollection
*
Document
:
:
Embeds
(
)
{
if
(
!
mEmbeds
)
{
mEmbeds
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
embed
)
;
}
return
mEmbeds
;
}
static
bool
MatchLinks
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
return
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
area
)
&
&
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
)
;
}
nsIHTMLCollection
*
Document
:
:
Links
(
)
{
if
(
!
mLinks
)
{
mLinks
=
new
nsContentList
(
this
MatchLinks
nullptr
nullptr
)
;
}
return
mLinks
;
}
nsIHTMLCollection
*
Document
:
:
Forms
(
)
{
if
(
!
mForms
)
{
mForms
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
form
nsGkAtoms
:
:
form
)
;
}
return
mForms
;
}
nsIHTMLCollection
*
Document
:
:
Scripts
(
)
{
if
(
!
mScripts
)
{
mScripts
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
script
nsGkAtoms
:
:
script
)
;
}
return
mScripts
;
}
nsIHTMLCollection
*
Document
:
:
Applets
(
)
{
if
(
!
mApplets
)
{
mApplets
=
new
nsEmptyContentList
(
this
)
;
}
return
mApplets
;
}
static
bool
MatchAnchors
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
return
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
&
&
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
)
;
}
nsIHTMLCollection
*
Document
:
:
Anchors
(
)
{
if
(
!
mAnchors
)
{
mAnchors
=
new
nsContentList
(
this
MatchAnchors
nullptr
nullptr
)
;
}
return
mAnchors
;
}
bool
Document
:
:
MatchNameAttribute
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
MOZ_ASSERT
(
aElement
"
Must
have
element
to
work
with
!
"
)
;
if
(
!
aElement
-
>
HasName
(
)
)
{
return
false
;
}
nsString
*
elementName
=
static_cast
<
nsString
*
>
(
aData
)
;
return
aElement
-
>
GetNameSpaceID
(
)
=
=
kNameSpaceID_XHTML
&
&
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
*
elementName
eCaseMatters
)
;
}
void
*
Document
:
:
UseExistingNameString
(
nsINode
*
aRootNode
const
nsString
*
aName
)
{
return
const_cast
<
nsString
*
>
(
aName
)
;
}
nsresult
Document
:
:
GetDocumentURI
(
nsString
&
aDocumentURI
)
const
{
if
(
mDocumentURI
)
{
nsAutoCString
uri
;
nsresult
rv
=
mDocumentURI
-
>
GetSpec
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
uri
aDocumentURI
)
;
}
else
{
aDocumentURI
.
Truncate
(
)
;
}
return
NS_OK
;
}
nsresult
Document
:
:
GetURL
(
nsString
&
aURL
)
const
{
return
GetDocumentURI
(
aURL
)
;
}
void
Document
:
:
GetDocumentURIFromJS
(
nsString
&
aDocumentURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
{
if
(
!
mChromeXHRDocURI
|
|
aCallerType
!
=
CallerType
:
:
System
)
{
aRv
=
GetDocumentURI
(
aDocumentURI
)
;
return
;
}
nsAutoCString
uri
;
nsresult
res
=
mChromeXHRDocURI
-
>
GetSpec
(
uri
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
CopyUTF8toUTF16
(
uri
aDocumentURI
)
;
}
nsIURI
*
Document
:
:
GetDocumentURIObject
(
)
const
{
if
(
!
mChromeXHRDocURI
)
{
return
GetDocumentURI
(
)
;
}
return
mChromeXHRDocURI
;
}
void
Document
:
:
GetCompatMode
(
nsString
&
aCompatMode
)
const
{
NS_ASSERTION
(
mCompatMode
=
=
eCompatibility_NavQuirks
|
|
mCompatMode
=
=
eCompatibility_AlmostStandards
|
|
mCompatMode
=
=
eCompatibility_FullStandards
"
mCompatMode
is
neither
quirks
nor
strict
for
this
document
"
)
;
if
(
mCompatMode
=
=
eCompatibility_NavQuirks
)
{
aCompatMode
.
AssignLiteral
(
"
BackCompat
"
)
;
}
else
{
aCompatMode
.
AssignLiteral
(
"
CSS1Compat
"
)
;
}
}
}
}
void
nsDOMAttributeMap
:
:
BlastSubtreeToPieces
(
nsINode
*
aNode
)
{
if
(
Element
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
const
nsDOMAttributeMap
*
map
=
element
-
>
GetAttributeMap
(
)
)
{
while
(
true
)
{
RefPtr
<
Attr
>
attr
;
{
auto
iter
=
map
-
>
mAttributeCache
.
ConstIter
(
)
;
if
(
iter
.
Done
(
)
)
{
break
;
}
attr
=
iter
.
UserData
(
)
;
}
BlastSubtreeToPieces
(
attr
)
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
element
-
>
UnsetAttr
(
attr
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
attr
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Uh
-
oh
UnsetAttr
shouldn
'
t
fail
!
"
)
;
}
}
if
(
mozilla
:
:
dom
:
:
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
BlastSubtreeToPieces
(
shadow
)
;
element
-
>
UnattachShadow
(
)
;
}
}
while
(
aNode
-
>
HasChildren
(
)
)
{
nsIContent
*
node
=
aNode
-
>
GetFirstChild
(
)
;
BlastSubtreeToPieces
(
node
)
;
aNode
-
>
RemoveChildNode
(
node
false
)
;
}
}
namespace
mozilla
{
namespace
dom
{
nsINode
*
Document
:
:
AdoptNode
(
nsINode
&
aAdoptedNode
ErrorResult
&
rv
)
{
nsINode
*
adoptedNode
=
&
aAdoptedNode
;
{
nsINode
*
parent
=
adoptedNode
-
>
GetParentNode
(
)
;
if
(
parent
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
adoptedNode
parent
)
;
}
}
nsAutoScriptBlocker
scriptBlocker
;
switch
(
adoptedNode
-
>
NodeType
(
)
)
{
case
ATTRIBUTE_NODE
:
{
RefPtr
<
Attr
>
adoptedAttr
=
static_cast
<
Attr
*
>
(
adoptedNode
)
;
nsCOMPtr
<
Element
>
ownerElement
=
adoptedAttr
-
>
GetOwnerElement
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
ownerElement
)
{
RefPtr
<
Attr
>
newAttr
=
ownerElement
-
>
RemoveAttributeNode
(
*
adoptedAttr
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
newAttr
.
swap
(
adoptedAttr
)
;
}
break
;
}
case
DOCUMENT_FRAGMENT_NODE
:
{
if
(
adoptedNode
-
>
IsShadowRoot
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
MOZ_FALLTHROUGH
;
}
case
ELEMENT_NODE
:
case
PROCESSING_INSTRUCTION_NODE
:
case
TEXT_NODE
:
case
CDATA_SECTION_NODE
:
case
COMMENT_NODE
:
case
DOCUMENT_TYPE_NODE
:
{
if
(
adoptedNode
-
>
AsContent
(
)
-
>
IsRootOfAnonymousSubtree
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
Document
*
doc
=
this
;
do
{
if
(
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
win
-
>
GetFrameElementInternal
(
)
;
if
(
node
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
node
adoptedNode
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
}
}
while
(
(
doc
=
doc
-
>
GetParentDocument
(
)
)
)
;
nsCOMPtr
<
nsINode
>
parent
=
adoptedNode
-
>
GetParentNode
(
)
;
if
(
parent
)
{
parent
-
>
RemoveChildNode
(
adoptedNode
-
>
AsContent
(
)
true
)
;
}
else
{
MOZ_ASSERT
(
!
adoptedNode
-
>
IsInUncomposedDoc
(
)
)
;
if
(
Element
*
element
=
Element
:
:
FromNode
(
adoptedNode
)
)
{
element
-
>
SetXBLBinding
(
nullptr
)
;
}
}
break
;
}
case
DOCUMENT_NODE
:
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
default
:
{
NS_WARNING
(
"
Don
'
t
know
how
to
adopt
this
nodetype
for
adoptNode
.
"
)
;
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
nsCOMPtr
<
Document
>
oldDocument
=
adoptedNode
-
>
OwnerDoc
(
)
;
bool
sameDocument
=
oldDocument
=
=
this
;
AutoJSContext
cx
;
JS
:
:
Rooted
<
JSObject
*
>
newScope
(
cx
nullptr
)
;
if
(
!
sameDocument
)
{
newScope
=
GetWrapper
(
)
;
if
(
!
newScope
&
&
GetScopeObject
(
)
&
&
GetScopeObject
(
)
-
>
HasJSGlobal
(
)
)
{
JSObject
*
globalObject
=
GetScopeObject
(
)
-
>
GetGlobalJSObject
(
)
;
JSAutoRealm
ar
(
cx
globalObject
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
)
;
rv
=
nsContentUtils
:
:
WrapNative
(
cx
ToSupports
(
this
)
this
&
v
false
)
;
if
(
rv
.
Failed
(
)
)
return
nullptr
;
newScope
=
&
v
.
toObject
(
)
;
}
}
nsCOMArray
<
nsINode
>
nodesWithProperties
;
nsNodeUtils
:
:
Adopt
(
adoptedNode
sameDocument
?
nullptr
:
mNodeInfoManager
newScope
nodesWithProperties
rv
)
;
if
(
rv
.
Failed
(
)
)
{
nsDOMAttributeMap
:
:
BlastSubtreeToPieces
(
adoptedNode
)
;
if
(
!
sameDocument
&
&
oldDocument
)
{
for
(
nsINode
*
node
:
nodesWithProperties
)
{
oldDocument
-
>
PropertyTable
(
)
.
DeleteAllPropertiesFor
(
node
)
;
}
}
return
nullptr
;
}
if
(
!
sameDocument
&
&
oldDocument
)
{
nsPropertyTable
&
oldTable
=
oldDocument
-
>
PropertyTable
(
)
;
nsPropertyTable
&
newTable
=
PropertyTable
(
)
;
for
(
nsINode
*
node
:
nodesWithProperties
)
{
rv
=
oldTable
.
TransferOrDeleteAllPropertiesFor
(
node
newTable
)
;
}
if
(
rv
.
Failed
(
)
)
{
nsDOMAttributeMap
:
:
BlastSubtreeToPieces
(
adoptedNode
)
;
return
nullptr
;
}
}
NS_ASSERTION
(
adoptedNode
-
>
OwnerDoc
(
)
=
=
this
"
Should
still
be
in
the
document
we
just
got
adopted
into
"
)
;
return
adoptedNode
;
}
bool
Document
:
:
UseWidthDeviceWidthFallbackViewport
(
)
const
{
return
false
;
}
void
Document
:
:
ParseWidthAndHeightInMetaViewport
(
const
nsAString
&
aWidthString
const
nsAString
&
aHeightString
const
nsAString
&
aScaleString
)
{
mMinWidth
=
nsViewportInfo
:
:
Auto
;
mMaxWidth
=
nsViewportInfo
:
:
Auto
;
if
(
!
aWidthString
.
IsEmpty
(
)
)
{
mMinWidth
=
nsViewportInfo
:
:
ExtendToZoom
;
if
(
aWidthString
.
EqualsLiteral
(
"
device
-
width
"
)
)
{
mMaxWidth
=
nsViewportInfo
:
:
DeviceSize
;
}
else
{
nsresult
widthErrorCode
;
mMaxWidth
=
aWidthString
.
ToInteger
(
&
widthErrorCode
)
;
if
(
NS_FAILED
(
widthErrorCode
)
)
{
mMaxWidth
=
1
.
0f
;
}
else
if
(
mMaxWidth
>
=
0
.
0f
)
{
mMaxWidth
=
clamped
(
mMaxWidth
CSSCoord
(
1
.
0f
)
CSSCoord
(
10000
.
0f
)
)
;
}
else
{
mMaxWidth
=
nsViewportInfo
:
:
Auto
;
}
}
}
else
if
(
!
aScaleString
.
IsEmpty
(
)
)
{
if
(
aHeightString
.
IsEmpty
(
)
)
{
mMinWidth
=
nsViewportInfo
:
:
ExtendToZoom
;
mMaxWidth
=
nsViewportInfo
:
:
ExtendToZoom
;
}
}
else
if
(
aHeightString
.
IsEmpty
(
)
&
&
UseWidthDeviceWidthFallbackViewport
(
)
)
{
mMinWidth
=
nsViewportInfo
:
:
ExtendToZoom
;
mMaxWidth
=
nsViewportInfo
:
:
DeviceSize
;
}
mMinHeight
=
nsViewportInfo
:
:
Auto
;
mMaxHeight
=
nsViewportInfo
:
:
Auto
;
if
(
!
aHeightString
.
IsEmpty
(
)
)
{
mMinHeight
=
nsViewportInfo
:
:
ExtendToZoom
;
if
(
aHeightString
.
EqualsLiteral
(
"
device
-
height
"
)
)
{
mMaxHeight
=
nsViewportInfo
:
:
DeviceSize
;
}
else
{
nsresult
heightErrorCode
;
mMaxHeight
=
aHeightString
.
ToInteger
(
&
heightErrorCode
)
;
if
(
NS_FAILED
(
heightErrorCode
)
)
{
mMaxHeight
=
1
.
0f
;
}
else
if
(
mMaxHeight
>
=
0
.
0f
)
{
mMaxHeight
=
clamped
(
mMaxHeight
CSSCoord
(
1
.
0f
)
CSSCoord
(
10000
.
0f
)
)
;
}
else
{
mMaxHeight
=
nsViewportInfo
:
:
Auto
;
}
}
}
}
nsViewportInfo
Document
:
:
GetViewportInfo
(
const
ScreenIntSize
&
aDisplaySize
)
{
MOZ_ASSERT
(
mPresShell
)
;
nsPresContext
*
context
=
mPresShell
-
>
GetPresContext
(
)
;
float
fullZoom
=
context
?
context
-
>
DeviceContext
(
)
-
>
GetFullZoom
(
)
:
1
.
0
;
fullZoom
=
(
fullZoom
=
=
0
.
0
)
?
1
.
0
:
fullZoom
;
CSSToLayoutDeviceScale
layoutDeviceScale
=
context
?
context
-
>
CSSToDevPixelScale
(
)
:
CSSToLayoutDeviceScale
(
1
)
;
CSSToScreenScale
defaultScale
=
layoutDeviceScale
*
LayoutDeviceToScreenScale
(
1
.
0
)
;
nsPIDOMWindowOuter
*
win
=
GetWindow
(
)
;
if
(
win
&
&
win
-
>
IsDesktopModeViewport
(
)
&
&
!
IsAboutPage
(
)
)
{
CSSCoord
viewportWidth
=
gfxPrefs
:
:
DesktopViewportWidth
(
)
/
fullZoom
;
CSSToScreenScale
scaleToFit
(
aDisplaySize
.
width
/
viewportWidth
)
;
float
aspectRatio
=
(
float
)
aDisplaySize
.
height
/
aDisplaySize
.
width
;
CSSSize
viewportSize
(
viewportWidth
viewportWidth
*
aspectRatio
)
;
ScreenIntSize
fakeDesktopSize
=
RoundedToInt
(
viewportSize
*
scaleToFit
)
;
return
nsViewportInfo
(
fakeDesktopSize
scaleToFit
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
)
;
}
if
(
!
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
this
)
)
{
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsLayoutUtils
:
:
AllowZoomingForDocument
(
this
)
?
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
:
nsViewportInfo
:
:
ZoomFlag
:
:
DisallowZoom
)
;
}
switch
(
mViewportType
)
{
case
DisplayWidthHeight
:
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
)
;
case
Unknown
:
{
nsAutoString
viewport
;
GetHeaderData
(
nsGkAtoms
:
:
viewport
viewport
)
;
bool
viewportIsEmpty
=
viewport
.
IsEmpty
(
)
;
if
(
viewportIsEmpty
)
{
RefPtr
<
DocumentType
>
docType
=
GetDoctype
(
)
;
if
(
docType
)
{
nsAutoString
docId
;
docType
-
>
GetPublicId
(
docId
)
;
if
(
(
docId
.
Find
(
"
WAP
"
)
!
=
-
1
)
|
|
(
docId
.
Find
(
"
Mobile
"
)
!
=
-
1
)
|
|
(
docId
.
Find
(
"
WML
"
)
!
=
-
1
)
)
{
mViewportType
=
DisplayWidthHeight
;
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
)
;
}
}
nsAutoString
handheldFriendly
;
GetHeaderData
(
nsGkAtoms
:
:
handheldFriendly
handheldFriendly
)
;
if
(
handheldFriendly
.
EqualsLiteral
(
"
true
"
)
)
{
mViewportType
=
DisplayWidthHeight
;
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
)
;
}
}
nsAutoString
minScaleStr
;
GetHeaderData
(
nsGkAtoms
:
:
viewport_minimum_scale
minScaleStr
)
;
nsresult
scaleMinErrorCode
;
mScaleMinFloat
=
LayoutDeviceToScreenScale
(
minScaleStr
.
ToFloat
(
&
scaleMinErrorCode
)
)
;
if
(
NS_FAILED
(
scaleMinErrorCode
)
)
{
mScaleMinFloat
=
kViewportMinScale
;
}
mScaleMinFloat
=
mozilla
:
:
clamped
(
mScaleMinFloat
kViewportMinScale
kViewportMaxScale
)
;
nsAutoString
maxScaleStr
;
GetHeaderData
(
nsGkAtoms
:
:
viewport_maximum_scale
maxScaleStr
)
;
nsresult
scaleMaxErrorCode
;
mScaleMaxFloat
=
LayoutDeviceToScreenScale
(
maxScaleStr
.
ToFloat
(
&
scaleMaxErrorCode
)
)
;
if
(
NS_FAILED
(
scaleMaxErrorCode
)
)
{
mScaleMaxFloat
=
kViewportMaxScale
;
}
if
(
NS_SUCCEEDED
(
scaleMaxErrorCode
)
&
&
NS_SUCCEEDED
(
scaleMinErrorCode
)
)
{
mScaleMaxFloat
=
std
:
:
max
(
mScaleMinFloat
mScaleMaxFloat
)
;
}
mScaleMaxFloat
=
mozilla
:
:
clamped
(
mScaleMaxFloat
kViewportMinScale
kViewportMaxScale
)
;
nsAutoString
scaleStr
;
GetHeaderData
(
nsGkAtoms
:
:
viewport_initial_scale
scaleStr
)
;
nsresult
scaleErrorCode
;
mScaleFloat
=
LayoutDeviceToScreenScale
(
scaleStr
.
ToFloat
(
&
scaleErrorCode
)
)
;
nsAutoString
widthStr
heightStr
;
GetHeaderData
(
nsGkAtoms
:
:
viewport_height
heightStr
)
;
GetHeaderData
(
nsGkAtoms
:
:
viewport_width
widthStr
)
;
ParseWidthAndHeightInMetaViewport
(
widthStr
heightStr
scaleStr
)
;
mAllowZoom
=
true
;
nsAutoString
userScalable
;
GetHeaderData
(
nsGkAtoms
:
:
viewport_user_scalable
userScalable
)
;
if
(
(
userScalable
.
EqualsLiteral
(
"
0
"
)
)
|
|
(
userScalable
.
EqualsLiteral
(
"
no
"
)
)
|
|
(
userScalable
.
EqualsLiteral
(
"
false
"
)
)
)
{
mAllowZoom
=
false
;
}
mScaleStrEmpty
=
scaleStr
.
IsEmpty
(
)
;
mWidthStrEmpty
=
widthStr
.
IsEmpty
(
)
;
mValidScaleFloat
=
!
scaleStr
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
scaleErrorCode
)
;
mValidMaxScale
=
!
maxScaleStr
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
scaleMaxErrorCode
)
;
mViewportType
=
viewportIsEmpty
?
Empty
:
Specified
;
MOZ_FALLTHROUGH
;
}
case
Specified
:
case
Empty
:
default
:
LayoutDeviceToScreenScale
effectiveMinScale
=
mScaleMinFloat
;
LayoutDeviceToScreenScale
effectiveMaxScale
=
mScaleMaxFloat
;
bool
effectiveValidMaxScale
=
mValidMaxScale
;
nsViewportInfo
:
:
ZoomFlag
effectiveZoomFlag
=
mAllowZoom
?
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
:
nsViewportInfo
:
:
ZoomFlag
:
:
DisallowZoom
;
if
(
gfxPrefs
:
:
ForceUserScalable
(
)
)
{
effectiveMinScale
=
kViewportMinScale
;
effectiveMaxScale
=
kViewportMaxScale
;
effectiveValidMaxScale
=
true
;
effectiveZoomFlag
=
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
;
}
auto
ComputeExtendZoom
=
[
&
]
(
)
-
>
float
{
if
(
mValidScaleFloat
&
&
effectiveValidMaxScale
)
{
return
std
:
:
min
(
mScaleFloat
.
scale
effectiveMaxScale
.
scale
)
;
}
if
(
mValidScaleFloat
)
{
return
mScaleFloat
.
scale
;
}
if
(
effectiveValidMaxScale
)
{
return
effectiveMaxScale
.
scale
;
}
return
nsViewportInfo
:
:
Auto
;
}
;
float
extendZoom
=
ComputeExtendZoom
(
)
;
CSSCoord
minWidth
=
mMinWidth
;
CSSCoord
maxWidth
=
mMaxWidth
;
CSSCoord
minHeight
=
mMinHeight
;
CSSCoord
maxHeight
=
mMaxHeight
;
CSSSize
displaySize
=
ScreenSize
(
aDisplaySize
)
/
defaultScale
;
if
(
maxWidth
=
=
nsViewportInfo
:
:
DeviceSize
)
{
maxWidth
=
displaySize
.
width
;
}
if
(
maxHeight
=
=
nsViewportInfo
:
:
DeviceSize
)
{
maxHeight
=
displaySize
.
height
;
}
if
(
extendZoom
=
=
nsViewportInfo
:
:
Auto
)
{
if
(
maxWidth
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
maxWidth
=
nsViewportInfo
:
:
Auto
;
}
if
(
maxHeight
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
maxHeight
=
nsViewportInfo
:
:
Auto
;
}
if
(
minWidth
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
minWidth
=
maxWidth
;
}
if
(
minHeight
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
minHeight
=
maxHeight
;
}
}
else
{
CSSSize
extendSize
=
displaySize
/
extendZoom
;
if
(
maxWidth
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
maxWidth
=
extendSize
.
width
;
}
if
(
maxHeight
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
maxHeight
=
extendSize
.
height
;
}
if
(
minWidth
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
minWidth
=
nsViewportInfo
:
:
Max
(
extendSize
.
width
maxWidth
)
;
}
if
(
minHeight
=
=
nsViewportInfo
:
:
ExtendToZoom
)
{
minHeight
=
nsViewportInfo
:
:
Max
(
extendSize
.
height
maxHeight
)
;
}
}
CSSCoord
width
=
nsViewportInfo
:
:
Auto
;
if
(
minWidth
!
=
nsViewportInfo
:
:
Auto
|
|
maxWidth
!
=
nsViewportInfo
:
:
Auto
)
{
width
=
nsViewportInfo
:
:
Max
(
minWidth
nsViewportInfo
:
:
Min
(
maxWidth
displaySize
.
width
)
)
;
}
CSSCoord
height
=
nsViewportInfo
:
:
Auto
;
if
(
minHeight
!
=
nsViewportInfo
:
:
Auto
|
|
maxHeight
!
=
nsViewportInfo
:
:
Auto
)
{
height
=
nsViewportInfo
:
:
Max
(
minHeight
nsViewportInfo
:
:
Min
(
maxHeight
displaySize
.
height
)
)
;
}
if
(
width
=
=
nsViewportInfo
:
:
Auto
)
{
if
(
height
=
=
nsViewportInfo
:
:
Auto
|
|
aDisplaySize
.
height
=
=
0
)
{
if
(
mViewportType
=
=
Empty
)
{
width
=
gfxPrefs
:
:
DesktopViewportWidth
(
)
/
fullZoom
;
}
else
{
width
=
displaySize
.
width
;
}
}
else
{
width
=
height
*
aDisplaySize
.
width
/
aDisplaySize
.
height
;
}
}
if
(
height
=
=
nsViewportInfo
:
:
Auto
)
{
if
(
aDisplaySize
.
width
=
=
0
)
{
height
=
displaySize
.
height
;
}
else
{
height
=
width
*
aDisplaySize
.
height
/
aDisplaySize
.
width
;
}
}
MOZ_ASSERT
(
width
!
=
nsViewportInfo
:
:
Auto
&
&
height
!
=
nsViewportInfo
:
:
Auto
)
;
CSSSize
size
(
width
height
)
;
CSSToScreenScale
scaleFloat
=
mScaleFloat
*
layoutDeviceScale
;
CSSToScreenScale
scaleMinFloat
=
effectiveMinScale
*
layoutDeviceScale
;
CSSToScreenScale
scaleMaxFloat
=
effectiveMaxScale
*
layoutDeviceScale
;
nsViewportInfo
:
:
AutoSizeFlag
sizeFlag
=
nsViewportInfo
:
:
AutoSizeFlag
:
:
FixedSize
;
if
(
mMaxWidth
=
=
nsViewportInfo
:
:
DeviceSize
|
|
(
mWidthStrEmpty
&
&
(
mMaxHeight
=
=
nsViewportInfo
:
:
DeviceSize
|
|
mScaleFloat
.
scale
=
=
1
.
0f
)
)
|
|
(
!
mWidthStrEmpty
&
&
mMaxWidth
=
=
nsViewportInfo
:
:
Auto
&
&
mMaxHeight
<
0
)
)
{
sizeFlag
=
nsViewportInfo
:
:
AutoSizeFlag
:
:
AutoSize
;
}
if
(
sizeFlag
=
=
nsViewportInfo
:
:
AutoSizeFlag
:
:
AutoSize
)
{
size
=
displaySize
;
}
CSSSize
effectiveMinSize
=
Min
(
CSSSize
(
kViewportMinSize
)
displaySize
)
;
size
.
width
=
clamped
(
size
.
width
effectiveMinSize
.
width
float
(
kViewportMaxSize
.
width
)
)
;
if
(
mScaleStrEmpty
&
&
!
mWidthStrEmpty
)
{
CSSToScreenScale
bestFitScale
(
float
(
aDisplaySize
.
width
)
/
size
.
width
)
;
scaleFloat
=
(
scaleFloat
>
bestFitScale
)
?
scaleFloat
:
bestFitScale
;
}
size
.
height
=
clamped
(
size
.
height
effectiveMinSize
.
height
float
(
kViewportMaxSize
.
height
)
)
;
if
(
mValidScaleFloat
&
&
scaleFloat
>
=
scaleMinFloat
&
&
scaleFloat
<
=
scaleMaxFloat
)
{
CSSSize
displaySize
=
ScreenSize
(
aDisplaySize
)
/
scaleFloat
;
size
.
width
=
std
:
:
max
(
size
.
width
displaySize
.
width
)
;
size
.
height
=
std
:
:
max
(
size
.
height
displaySize
.
height
)
;
}
else
if
(
effectiveValidMaxScale
)
{
CSSSize
displaySize
=
ScreenSize
(
aDisplaySize
)
/
scaleMaxFloat
;
size
.
width
=
std
:
:
max
(
size
.
width
displaySize
.
width
)
;
size
.
height
=
std
:
:
max
(
size
.
height
displaySize
.
height
)
;
}
return
nsViewportInfo
(
scaleFloat
scaleMinFloat
scaleMaxFloat
size
sizeFlag
mValidScaleFloat
?
nsViewportInfo
:
:
AutoScaleFlag
:
:
FixedScale
:
nsViewportInfo
:
:
AutoScaleFlag
:
:
AutoScale
effectiveZoomFlag
)
;
}
}
void
Document
:
:
UpdateForScrollAnchorAdjustment
(
nscoord
aLength
)
{
mScrollAnchorAdjustmentLength
+
=
abs
(
aLength
)
;
mScrollAnchorAdjustmentCount
+
=
1
;
}
EventListenerManager
*
Document
:
:
GetOrCreateListenerManager
(
)
{
if
(
!
mListenerManager
)
{
mListenerManager
=
new
EventListenerManager
(
static_cast
<
EventTarget
*
>
(
this
)
)
;
SetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
}
return
mListenerManager
;
}
EventListenerManager
*
Document
:
:
GetExistingListenerManager
(
)
const
{
return
mListenerManager
;
}
void
Document
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
if
(
mDocGroup
&
&
aVisitor
.
mEvent
-
>
mMessage
!
=
eVoidEvent
&
&
!
mIgnoreDocGroupMismatches
)
{
mDocGroup
-
>
ValidateAccess
(
)
;
}
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mForceContentDispatch
=
true
;
if
(
aVisitor
.
mEvent
-
>
mMessage
!
=
eLoad
)
{
nsGlobalWindowOuter
*
window
=
nsGlobalWindowOuter
:
:
Cast
(
GetWindow
(
)
)
;
aVisitor
.
SetParentTarget
(
window
?
window
-
>
GetTargetForEventTargetChain
(
)
:
nullptr
false
)
;
}
}
already_AddRefed
<
Event
>
Document
:
:
CreateEvent
(
const
nsAString
&
aEventType
CallerType
aCallerType
ErrorResult
&
rv
)
const
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
RefPtr
<
Event
>
ev
=
EventDispatcher
:
:
CreateEvent
(
const_cast
<
Document
*
>
(
this
)
presContext
nullptr
aEventType
aCallerType
)
;
if
(
!
ev
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
WidgetEvent
*
e
=
ev
-
>
WidgetEventPtr
(
)
;
e
-
>
mFlags
.
mBubbles
=
false
;
e
-
>
mFlags
.
mCancelable
=
false
;
return
ev
.
forget
(
)
;
}
void
Document
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
mozilla
:
:
ChangesToFlush
flush
(
aType
aType
>
=
FlushType
:
:
Style
)
;
FlushPendingNotifications
(
flush
)
;
}
class
nsDocumentOnStack
{
public
:
explicit
nsDocumentOnStack
(
Document
*
aDoc
)
:
mDoc
(
aDoc
)
{
mDoc
-
>
IncreaseStackRefCnt
(
)
;
}
~
nsDocumentOnStack
(
)
{
mDoc
-
>
DecreaseStackRefCnt
(
)
;
}
private
:
Document
*
mDoc
;
}
;
void
Document
:
:
FlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aFlush
)
{
FlushType
flushType
=
aFlush
.
mFlushType
;
nsDocumentOnStack
dos
(
this
)
;
if
(
(
!
IsHTMLDocument
(
)
|
|
(
flushType
>
FlushType
:
:
ContentAndNotify
&
&
mPresShell
&
&
!
mPresShell
-
>
DidInitialize
(
)
)
)
&
&
(
mParser
|
|
mWeakSink
)
)
{
nsCOMPtr
<
nsIContentSink
>
sink
;
if
(
mParser
)
{
sink
=
mParser
-
>
GetContentSink
(
)
;
}
else
{
sink
=
do_QueryReferent
(
mWeakSink
)
;
if
(
!
sink
)
{
mWeakSink
=
nullptr
;
}
}
if
(
sink
&
&
(
flushType
=
=
FlushType
:
:
Content
|
|
IsSafeToFlush
(
)
)
)
{
sink
-
>
FlushPendingNotifications
(
flushType
)
;
}
}
if
(
flushType
<
=
FlushType
:
:
ContentAndNotify
)
{
return
;
}
if
(
StyleOrLayoutObservablyDependsOnParentDocumentLayout
(
)
&
&
IsSafeToFlush
(
)
)
{
mozilla
:
:
ChangesToFlush
parentFlush
=
aFlush
;
if
(
flushType
>
=
FlushType
:
:
Style
)
{
parentFlush
.
mFlushType
=
std
:
:
max
(
FlushType
:
:
Layout
flushType
)
;
}
mParentDocument
-
>
FlushPendingNotifications
(
parentFlush
)
;
}
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
aFlush
)
;
}
}
static
bool
Copy
(
Document
*
aDocument
void
*
aData
)
{
auto
*
resources
=
static_cast
<
nsTArray
<
nsCOMPtr
<
Document
>
>
*
>
(
aData
)
;
resources
-
>
AppendElement
(
aDocument
)
;
return
true
;
}
void
Document
:
:
FlushExternalResources
(
FlushType
aType
)
{
NS_ASSERTION
(
aType
>
=
FlushType
:
:
Style
"
should
only
need
to
flush
for
style
or
higher
in
external
resources
"
)
;
if
(
GetDisplayDocument
(
)
)
{
return
;
}
nsTArray
<
nsCOMPtr
<
Document
>
>
resources
;
EnumerateExternalResources
(
Copy
&
resources
)
;
for
(
uint32_t
i
=
0
;
i
<
resources
.
Length
(
)
;
i
+
+
)
{
resources
[
i
]
-
>
FlushPendingNotifications
(
aType
)
;
}
}
void
Document
:
:
SetXMLDeclaration
(
const
char16_t
*
aVersion
const
char16_t
*
aEncoding
const
int32_t
aStandalone
)
{
if
(
!
aVersion
|
|
*
aVersion
=
=
'
\
0
'
)
{
mXMLDeclarationBits
=
0
;
return
;
}
mXMLDeclarationBits
=
XML_DECLARATION_BITS_DECLARATION_EXISTS
;
if
(
aEncoding
&
&
*
aEncoding
!
=
'
\
0
'
)
{
mXMLDeclarationBits
|
=
XML_DECLARATION_BITS_ENCODING_EXISTS
;
}
if
(
aStandalone
=
=
1
)
{
mXMLDeclarationBits
|
=
XML_DECLARATION_BITS_STANDALONE_EXISTS
|
XML_DECLARATION_BITS_STANDALONE_YES
;
}
else
if
(
aStandalone
=
=
0
)
{
mXMLDeclarationBits
|
=
XML_DECLARATION_BITS_STANDALONE_EXISTS
;
}
}
void
Document
:
:
GetXMLDeclaration
(
nsAString
&
aVersion
nsAString
&
aEncoding
nsAString
&
aStandalone
)
{
aVersion
.
Truncate
(
)
;
aEncoding
.
Truncate
(
)
;
aStandalone
.
Truncate
(
)
;
if
(
!
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_DECLARATION_EXISTS
)
)
{
return
;
}
aVersion
.
AssignLiteral
(
"
1
.
0
"
)
;
if
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_ENCODING_EXISTS
)
{
GetCharacterSet
(
aEncoding
)
;
}
if
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_STANDALONE_EXISTS
)
{
if
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_STANDALONE_YES
)
{
aStandalone
.
AssignLiteral
(
"
yes
"
)
;
}
else
{
aStandalone
.
AssignLiteral
(
"
no
"
)
;
}
}
}
bool
Document
:
:
IsScriptEnabled
(
)
{
if
(
HasScriptsBlockedBySandbox
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
GetInnerWindow
(
)
)
;
if
(
!
globalObject
|
|
!
globalObject
-
>
HasJSGlobal
(
)
)
{
return
false
;
}
return
xpc
:
:
Scriptability
:
:
Get
(
globalObject
-
>
GetGlobalJSObjectPreserveColor
(
)
)
.
Allowed
(
)
;
}
void
Document
:
:
RetrieveRelevantHeaders
(
nsIChannel
*
aChannel
)
{
PRTime
modDate
=
0
;
nsresult
rv
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
httpChannel
)
{
nsAutoCString
tmp
;
rv
=
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
last
-
modified
"
)
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
PRTime
time
;
PRStatus
st
=
PR_ParseTimeString
(
tmp
.
get
(
)
true
&
time
)
;
if
(
st
=
=
PR_SUCCESS
)
{
modDate
=
time
;
}
}
rv
=
httpChannel
-
>
GetRequestHeader
(
NS_LITERAL_CSTRING
(
"
referer
"
)
mReferrer
)
;
static
const
char
*
const
headers
[
]
=
{
"
default
-
style
"
"
content
-
style
-
type
"
"
content
-
language
"
"
content
-
disposition
"
"
refresh
"
"
x
-
dns
-
prefetch
-
control
"
"
x
-
frame
-
options
"
"
referrer
-
policy
"
0
}
;
nsAutoCString
headerVal
;
const
char
*
const
*
name
=
headers
;
while
(
*
name
)
{
rv
=
httpChannel
-
>
GetResponseHeader
(
nsDependentCString
(
*
name
)
headerVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
headerVal
.
IsEmpty
(
)
)
{
RefPtr
<
nsAtom
>
key
=
NS_Atomize
(
*
name
)
;
SetHeaderData
(
key
NS_ConvertASCIItoUTF16
(
headerVal
)
)
;
}
+
+
name
;
}
}
else
{
nsCOMPtr
<
nsIFileChannel
>
fileChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
fileChannel
)
{
nsCOMPtr
<
nsIFile
>
file
;
fileChannel
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
file
)
{
PRTime
msecs
;
rv
=
file
-
>
GetLastModifiedTime
(
&
msecs
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
modDate
=
msecs
*
int64_t
(
PR_USEC_PER_MSEC
)
;
}
}
}
else
{
nsAutoCString
contentDisp
;
rv
=
aChannel
-
>
GetContentDispositionHeader
(
contentDisp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetHeaderData
(
nsGkAtoms
:
:
headerContentDisposition
NS_ConvertASCIItoUTF16
(
contentDisp
)
)
;
}
}
}
mLastModified
.
Truncate
(
)
;
if
(
modDate
!
=
0
)
{
GetFormattedTimeString
(
modDate
mLastModified
)
;
}
}
already_AddRefed
<
Element
>
Document
:
:
CreateElem
(
const
nsAString
&
aName
nsAtom
*
aPrefix
int32_t
aNamespaceID
const
nsAString
*
aIs
)
{
#
ifdef
DEBUG
nsAutoString
qName
;
if
(
aPrefix
)
{
aPrefix
-
>
ToString
(
qName
)
;
qName
.
Append
(
'
:
'
)
;
}
qName
.
Append
(
aName
)
;
bool
nsAware
=
aPrefix
!
=
nullptr
|
|
aNamespaceID
!
=
GetDefaultNamespaceID
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
nsContentUtils
:
:
CheckQName
(
qName
nsAware
)
)
"
Don
'
t
pass
invalid
prefixes
to
Document
:
:
CreateElem
"
"
check
caller
.
"
)
;
#
endif
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
mNodeInfoManager
-
>
GetNodeInfo
(
aName
aPrefix
aNamespaceID
ELEMENT_NODE
getter_AddRefs
(
nodeInfo
)
)
;
NS_ENSURE_TRUE
(
nodeInfo
nullptr
)
;
nsCOMPtr
<
Element
>
element
;
nsresult
rv
=
NS_NewElement
(
getter_AddRefs
(
element
)
nodeInfo
.
forget
(
)
NOT_FROM_PARSER
aIs
)
;
return
NS_SUCCEEDED
(
rv
)
?
element
.
forget
(
)
:
nullptr
;
}
bool
Document
:
:
IsSafeToFlush
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
true
;
}
return
presShell
-
>
IsSafeToFlush
(
)
;
}
void
Document
:
:
Sanitize
(
)
{
RefPtr
<
nsContentList
>
nodes
=
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
input
"
)
)
;
nsAutoString
value
;
uint32_t
length
=
nodes
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
NS_ASSERTION
(
nodes
-
>
Item
(
i
)
"
null
item
in
node
list
!
"
)
;
RefPtr
<
HTMLInputElement
>
input
=
HTMLInputElement
:
:
FromNodeOrNull
(
nodes
-
>
Item
(
i
)
)
;
if
(
!
input
)
continue
;
input
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
autocomplete
"
)
value
)
;
if
(
value
.
LowerCaseEqualsLiteral
(
"
off
"
)
|
|
input
-
>
HasBeenTypePassword
(
)
)
{
input
-
>
Reset
(
)
;
}
}
nodes
=
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
form
"
)
)
;
length
=
nodes
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
NS_ASSERTION
(
nodes
-
>
Item
(
i
)
"
null
item
in
nodelist
"
)
;
HTMLFormElement
*
form
=
HTMLFormElement
:
:
FromNode
(
nodes
-
>
Item
(
i
)
)
;
if
(
!
form
)
continue
;
form
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
value
)
;
if
(
value
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
form
-
>
Reset
(
)
;
}
}
void
Document
:
:
EnumerateSubDocuments
(
SubDocEnumFunc
aCallback
void
*
aData
)
{
if
(
!
mSubDocuments
)
{
return
;
}
AutoTArray
<
nsCOMPtr
<
Document
>
8
>
subdocs
;
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
Document
*
subdoc
=
entry
-
>
mSubDocument
;
if
(
subdoc
)
{
subdocs
.
AppendElement
(
subdoc
)
;
}
}
for
(
auto
subdoc
:
subdocs
)
{
if
(
!
aCallback
(
subdoc
aData
)
)
{
break
;
}
}
}
void
Document
:
:
CollectDescendantDocuments
(
nsTArray
<
RefPtr
<
Document
>
>
&
aDescendants
nsDocTestFunc
aCallback
)
const
{
if
(
!
mSubDocuments
)
{
return
;
}
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
const
Document
*
subdoc
=
entry
-
>
mSubDocument
;
if
(
subdoc
)
{
if
(
aCallback
(
subdoc
)
)
{
aDescendants
.
AppendElement
(
entry
-
>
mSubDocument
)
;
}
subdoc
-
>
CollectDescendantDocuments
(
aDescendants
aCallback
)
;
}
}
}
bool
Document
:
:
CanSavePresentation
(
nsIRequest
*
aNewRequest
uint16_t
&
aBFCacheCombo
)
{
bool
ret
=
true
;
if
(
!
IsBFCachingAllowed
(
)
)
{
aBFCacheCombo
|
=
BFCacheStatus
:
:
NOT_ALLOWED
;
ret
=
false
;
}
nsAutoCString
uri
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Verbose
)
)
)
{
if
(
mDocumentURI
)
{
mDocumentURI
-
>
GetSpec
(
uri
)
;
}
}
if
(
EventHandlingSuppressed
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
on
event
handling
suppression
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
EVENT_HANDLING_SUPPRESSED
;
ret
=
false
;
}
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
;
if
(
win
&
&
win
-
>
IsSuspended
(
)
&
&
!
win
-
>
IsFrozen
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
on
suspended
Window
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
SUSPENDED
;
ret
=
false
;
}
nsCOMPtr
<
EventTarget
>
piTarget
=
do_QueryInterface
(
mScriptGlobalObject
)
;
if
(
piTarget
)
{
EventListenerManager
*
manager
=
piTarget
-
>
GetExistingListenerManager
(
)
;
if
(
manager
&
&
manager
-
>
HasUnloadListeners
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
unload
handlers
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
UNLOAD_LISTENER
;
ret
=
false
;
}
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
loadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
bool
hasMore
=
false
;
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsCOMPtr
<
nsIMultiPartChannel
>
part
(
do_QueryInterface
(
aNewRequest
)
)
;
if
(
part
)
{
part
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
}
while
(
NS_SUCCEEDED
(
requests
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
requests
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
nsCOMPtr
<
nsIRequest
>
request
=
do_QueryInterface
(
elem
)
;
if
(
request
&
&
request
!
=
aNewRequest
&
&
request
!
=
baseChannel
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
request
)
;
if
(
channel
)
{
nsCOMPtr
<
nsILoadInfo
>
li
=
channel
-
>
LoadInfo
(
)
;
if
(
li
-
>
InternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
{
continue
;
}
}
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Verbose
)
)
)
{
nsAutoCString
requestName
;
request
-
>
GetName
(
requestName
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
because
document
has
request
%
s
"
uri
.
get
(
)
requestName
.
get
(
)
)
)
;
}
aBFCacheCombo
|
=
BFCacheStatus
:
:
REQUEST
;
ret
=
false
;
}
}
}
if
(
MediaManager
:
:
Exists
(
)
&
&
win
&
&
MediaManager
:
:
Get
(
)
-
>
IsWindowStillActive
(
win
-
>
WindowID
(
)
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
GetUserMedia
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
ACTIVE_GET_USER_MEDIA
;
ret
=
false
;
}
#
ifdef
MOZ_WEBRTC
if
(
win
&
&
win
-
>
HasActivePeerConnections
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
PeerConnection
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
ACTIVE_PEER_CONNECTION
;
ret
=
false
;
}
#
endif
if
(
ContainsEMEContent
(
)
)
{
aBFCacheCombo
|
=
BFCacheStatus
:
:
CONTAINS_EME_CONTENT
;
ret
=
false
;
}
if
(
ContainsMSEContent
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
MSE
use
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
CONTAINS_MSE_CONTENT
;
ret
=
false
;
}
if
(
mSubDocuments
)
{
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
Document
*
subdoc
=
entry
-
>
mSubDocument
;
uint16_t
subDocBFCacheCombo
=
0
;
bool
canCache
=
subdoc
?
subdoc
-
>
CanSavePresentation
(
nullptr
subDocBFCacheCombo
)
:
false
;
if
(
!
canCache
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
subdocument
blocked
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
subDocBFCacheCombo
;
ret
=
false
;
}
}
}
if
(
win
)
{
auto
*
globalWindow
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
#
ifdef
MOZ_WEBSPEECH
if
(
globalWindow
-
>
HasActiveSpeechSynthesis
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
Speech
use
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
HAS_ACTIVE_SPEECH_SYNTHESIS
;
ret
=
false
;
}
#
endif
if
(
globalWindow
-
>
HasUsedVR
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
having
used
VR
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
HAS_USED_VR
;
ret
=
false
;
}
}
return
ret
;
}
void
Document
:
:
Destroy
(
)
{
if
(
mIsGoingAway
)
return
;
if
(
!
nsContentUtils
:
:
IsInPrivateBrowsing
(
this
)
)
{
mContentBlockingLog
.
ReportLog
(
)
;
}
mIsGoingAway
=
true
;
if
(
mDocumentL10n
)
{
mDocumentL10n
-
>
Destroy
(
)
;
}
ScriptLoader
(
)
-
>
Destroy
(
)
;
SetScriptGlobalObject
(
nullptr
)
;
RemovedFromDocShell
(
)
;
bool
oldVal
=
mInUnlinkOrDeletion
;
mInUnlinkOrDeletion
=
true
;
#
ifdef
DEBUG
uint32_t
oldChildCount
=
GetChildCount
(
)
;
#
endif
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
DestroyContent
(
)
;
MOZ_ASSERT
(
child
-
>
GetParentNode
(
)
=
=
this
)
;
}
MOZ_ASSERT
(
oldChildCount
=
=
GetChildCount
(
)
)
;
mInUnlinkOrDeletion
=
oldVal
;
mLayoutHistoryState
=
nullptr
;
if
(
mOriginalDocument
)
{
mOriginalDocument
-
>
mLatestStaticClone
=
nullptr
;
}
mExternalResourceMap
.
Shutdown
(
)
;
}
void
Document
:
:
RemovedFromDocShell
(
)
{
if
(
mRemovedFromDocShell
)
return
;
mRemovedFromDocShell
=
true
;
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
SaveSubtreeState
(
)
;
}
}
already_AddRefed
<
nsILayoutHistoryState
>
Document
:
:
GetLayoutHistoryState
(
)
const
{
nsCOMPtr
<
nsILayoutHistoryState
>
state
;
if
(
!
mScriptGlobalObject
)
{
state
=
mLayoutHistoryState
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
docShell
-
>
GetLayoutHistoryState
(
getter_AddRefs
(
state
)
)
;
}
}
return
state
.
forget
(
)
;
}
void
Document
:
:
EnsureOnloadBlocker
(
)
{
if
(
mOnloadBlockCount
!
=
0
&
&
mScriptGlobalObject
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
loadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
bool
hasMore
=
false
;
while
(
NS_SUCCEEDED
(
requests
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
requests
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
nsCOMPtr
<
nsIRequest
>
request
=
do_QueryInterface
(
elem
)
;
if
(
request
&
&
request
=
=
mOnloadBlocker
)
{
return
;
}
}
loadGroup
-
>
AddRequest
(
mOnloadBlocker
nullptr
)
;
}
}
}
void
Document
:
:
AsyncBlockOnload
(
)
{
while
(
mAsyncOnloadBlockCount
)
{
-
-
mAsyncOnloadBlockCount
;
BlockOnload
(
)
;
}
}
void
Document
:
:
BlockOnload
(
)
{
if
(
mDisplayDocument
)
{
mDisplayDocument
-
>
BlockOnload
(
)
;
return
;
}
if
(
mOnloadBlockCount
=
=
0
&
&
mScriptGlobalObject
)
{
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
+
+
mAsyncOnloadBlockCount
;
if
(
mAsyncOnloadBlockCount
=
=
1
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
Document
:
:
AsyncBlockOnload
"
this
&
Document
:
:
AsyncBlockOnload
)
)
;
}
return
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
loadGroup
-
>
AddRequest
(
mOnloadBlocker
nullptr
)
;
}
}
+
+
mOnloadBlockCount
;
}
void
Document
:
:
UnblockOnload
(
bool
aFireSync
)
{
if
(
mDisplayDocument
)
{
mDisplayDocument
-
>
UnblockOnload
(
aFireSync
)
;
return
;
}
if
(
mOnloadBlockCount
=
=
0
&
&
mAsyncOnloadBlockCount
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
More
UnblockOnload
(
)
calls
than
BlockOnload
(
)
"
"
calls
;
dropping
call
"
)
;
return
;
}
-
-
mOnloadBlockCount
;
if
(
mOnloadBlockCount
=
=
0
)
{
if
(
mScriptGlobalObject
)
{
if
(
aFireSync
&
&
mAsyncOnloadBlockCount
=
=
0
)
{
+
+
mOnloadBlockCount
;
DoUnblockOnload
(
)
;
}
else
{
PostUnblockOnloadEvent
(
)
;
}
}
else
if
(
mIsBeingUsedAsImage
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
MozSVGAsImageDocumentLoad
"
)
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
}
class
nsUnblockOnloadEvent
:
public
Runnable
{
public
:
explicit
nsUnblockOnloadEvent
(
Document
*
aDoc
)
:
mozilla
:
:
Runnable
(
"
nsUnblockOnloadEvent
"
)
mDoc
(
aDoc
)
{
}
NS_IMETHOD
Run
(
)
override
{
mDoc
-
>
DoUnblockOnload
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Document
>
mDoc
;
}
;
void
Document
:
:
PostUnblockOnloadEvent
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
evt
=
new
nsUnblockOnloadEvent
(
this
)
;
nsresult
rv
=
Dispatch
(
TaskCategory
:
:
Other
evt
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
+
+
mOnloadBlockCount
;
}
else
{
NS_WARNING
(
"
failed
to
dispatch
nsUnblockOnloadEvent
"
)
;
}
}
void
Document
:
:
DoUnblockOnload
(
)
{
MOZ_ASSERT
(
!
mDisplayDocument
"
Shouldn
'
t
get
here
for
resource
document
"
)
;
MOZ_ASSERT
(
mOnloadBlockCount
!
=
0
"
Shouldn
'
t
have
a
count
of
zero
here
since
we
stabilized
in
"
"
PostUnblockOnloadEvent
"
)
;
-
-
mOnloadBlockCount
;
if
(
mOnloadBlockCount
!
=
0
)
{
return
;
}
if
(
mAsyncOnloadBlockCount
!
=
0
)
{
PostUnblockOnloadEvent
(
)
;
}
if
(
mScriptGlobalObject
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
loadGroup
-
>
RemoveRequest
(
mOnloadBlocker
nullptr
NS_OK
)
;
}
}
}
nsIContent
*
Document
:
:
GetContentInThisDocument
(
nsIFrame
*
aFrame
)
const
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
if
(
!
content
|
|
content
-
>
IsInAnonymousSubtree
(
)
)
continue
;
if
(
content
-
>
OwnerDoc
(
)
=
=
this
)
{
return
content
;
}
f
=
f
-
>
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootFrame
(
)
;
}
return
nullptr
;
}
void
Document
:
:
DispatchPageTransition
(
EventTarget
*
aDispatchTarget
const
nsAString
&
aType
bool
aPersisted
bool
aOnlySystemGroup
)
{
if
(
!
aDispatchTarget
)
{
return
;
}
PageTransitionEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
init
.
mPersisted
=
aPersisted
;
nsDocShell
*
docShell
=
mDocumentContainer
.
get
(
)
;
init
.
mInFrameSwap
=
docShell
&
&
docShell
-
>
InFrameSwap
(
)
;
RefPtr
<
PageTransitionEvent
>
event
=
PageTransitionEvent
:
:
Constructor
(
this
aType
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
SetTarget
(
this
)
;
if
(
aOnlySystemGroup
)
{
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
true
;
}
EventDispatcher
:
:
DispatchDOMEvent
(
aDispatchTarget
nullptr
event
nullptr
nullptr
)
;
}
static
bool
NotifyPageShow
(
Document
*
aDocument
void
*
aData
)
{
const
bool
*
aPersistedPtr
=
static_cast
<
const
bool
*
>
(
aData
)
;
aDocument
-
>
OnPageShow
(
*
aPersistedPtr
nullptr
)
;
return
true
;
}
void
Document
:
:
OnPageShow
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
)
{
mVisible
=
true
;
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
EnumerateExternalResources
(
NotifyPageShow
&
aPersisted
)
;
Element
*
root
=
GetRootElement
(
)
;
if
(
aPersisted
&
&
root
)
{
RefPtr
<
nsContentList
>
links
=
NS_GetContentList
(
root
kNameSpaceID_XHTML
NS_LITERAL_STRING
(
"
link
"
)
)
;
uint32_t
linkCount
=
links
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
linkCount
;
+
+
i
)
{
static_cast
<
HTMLLinkElement
*
>
(
links
-
>
Item
(
i
false
)
)
-
>
LinkAdded
(
)
;
}
}
if
(
!
aDispatchStartTarget
)
{
mIsShowing
=
true
;
}
if
(
mAnimationController
)
{
mAnimationController
-
>
OnPageShow
(
)
;
}
if
(
aPersisted
)
{
ImageTracker
(
)
-
>
SetAnimatingState
(
true
)
;
}
UpdateVisibilityState
(
)
;
if
(
!
mIsBeingUsedAsImage
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
?
"
chrome
-
page
-
shown
"
:
"
content
-
page
-
shown
"
nullptr
)
;
}
nsCOMPtr
<
EventTarget
>
target
=
aDispatchStartTarget
;
if
(
!
target
)
{
target
=
do_QueryInterface
(
GetWindow
(
)
)
;
}
DispatchPageTransition
(
target
NS_LITERAL_STRING
(
"
pageshow
"
)
aPersisted
aOnlySystemGroup
)
;
}
}
static
bool
NotifyPageHide
(
Document
*
aDocument
void
*
aData
)
{
const
bool
*
aPersistedPtr
=
static_cast
<
const
bool
*
>
(
aData
)
;
aDocument
-
>
OnPageHide
(
*
aPersistedPtr
nullptr
)
;
return
true
;
}
static
void
DispatchFullscreenChange
(
Document
*
aDocument
nsINode
*
aTarget
)
{
if
(
nsPresContext
*
presContext
=
aDocument
-
>
GetPresContext
(
)
)
{
auto
pendingEvent
=
MakeUnique
<
PendingFullscreenEvent
>
(
FullscreenEventType
:
:
Change
aDocument
aTarget
)
;
presContext
-
>
RefreshDriver
(
)
-
>
ScheduleFullscreenEvent
(
std
:
:
move
(
pendingEvent
)
)
;
}
}
static
void
ClearPendingFullscreenRequests
(
Document
*
aDoc
)
;
static
bool
HasHttpScheme
(
nsIURI
*
aURI
)
{
bool
isHttpish
=
false
;
return
aURI
&
&
(
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
http
"
&
isHttpish
)
)
&
&
isHttpish
)
|
|
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
https
"
&
isHttpish
)
)
&
&
isHttpish
)
)
;
}
void
Document
:
:
OnPageHide
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
)
{
if
(
IsTopLevelContentDocument
(
)
&
&
GetDocGroup
(
)
&
&
Telemetry
:
:
CanRecordExtended
(
)
)
{
TabGroup
*
tabGroup
=
mDocGroup
-
>
GetTabGroup
(
)
;
if
(
tabGroup
)
{
uint32_t
active
=
tabGroup
-
>
Count
(
true
)
;
uint32_t
total
=
tabGroup
-
>
Count
(
)
;
if
(
HasHttpScheme
(
GetDocumentURI
(
)
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
ACTIVE_HTTP_DOCGROUPS_PER_TABGROUP
active
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TOTAL_HTTP_DOCGROUPS_PER_TABGROUP
total
)
;
}
}
}
Element
*
root
=
GetRootElement
(
)
;
if
(
aPersisted
&
&
root
)
{
RefPtr
<
nsContentList
>
links
=
NS_GetContentList
(
root
kNameSpaceID_XHTML
NS_LITERAL_STRING
(
"
link
"
)
)
;
uint32_t
linkCount
=
links
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
linkCount
;
+
+
i
)
{
static_cast
<
HTMLLinkElement
*
>
(
links
-
>
Item
(
i
false
)
)
-
>
LinkRemoved
(
)
;
}
}
if
(
!
aDispatchStartTarget
)
{
mIsShowing
=
false
;
}
if
(
mAnimationController
)
{
mAnimationController
-
>
OnPageHide
(
)
;
}
nsDocShell
*
docShell
=
mDocumentContainer
.
get
(
)
;
if
(
aPersisted
&
&
!
(
docShell
&
&
docShell
-
>
InFrameSwap
(
)
)
)
{
ImageTracker
(
)
-
>
SetAnimatingState
(
false
)
;
}
ExitPointerLock
(
)
;
if
(
!
mIsBeingUsedAsImage
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
?
"
chrome
-
page
-
hidden
"
:
"
content
-
page
-
hidden
"
nullptr
)
;
}
nsCOMPtr
<
EventTarget
>
target
=
aDispatchStartTarget
;
if
(
!
target
)
{
target
=
do_QueryInterface
(
GetWindow
(
)
)
;
}
{
PageUnloadingEventTimeStamp
timeStamp
(
this
)
;
DispatchPageTransition
(
target
NS_LITERAL_STRING
(
"
pagehide
"
)
aPersisted
aOnlySystemGroup
)
;
}
}
mVisible
=
false
;
UpdateVisibilityState
(
)
;
EnumerateExternalResources
(
NotifyPageHide
&
aPersisted
)
;
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
ClearPendingFullscreenRequests
(
this
)
;
if
(
FullscreenStackTop
(
)
)
{
Document
:
:
ExitFullscreenInDocTree
(
this
)
;
CleanupFullscreenState
(
)
;
}
}
void
Document
:
:
WillDispatchMutationEvent
(
nsINode
*
aTarget
)
{
NS_ASSERTION
(
mSubtreeModifiedDepth
!
=
0
|
|
mSubtreeModifiedTargets
.
Count
(
)
=
=
0
"
mSubtreeModifiedTargets
not
cleared
after
dispatching
?
"
)
;
+
+
mSubtreeModifiedDepth
;
if
(
aTarget
)
{
int32_t
count
=
mSubtreeModifiedTargets
.
Count
(
)
;
if
(
!
count
|
|
mSubtreeModifiedTargets
[
count
-
1
]
!
=
aTarget
)
{
mSubtreeModifiedTargets
.
AppendObject
(
aTarget
)
;
}
}
}
void
Document
:
:
MutationEventDispatched
(
nsINode
*
aTarget
)
{
-
-
mSubtreeModifiedDepth
;
if
(
mSubtreeModifiedDepth
=
=
0
)
{
int32_t
count
=
mSubtreeModifiedTargets
.
Count
(
)
;
if
(
!
count
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
if
(
window
&
&
!
window
-
>
HasMutationListeners
(
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
)
{
mSubtreeModifiedTargets
.
Clear
(
)
;
return
;
}
nsCOMArray
<
nsINode
>
realTargets
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsINode
*
possibleTarget
=
mSubtreeModifiedTargets
[
i
]
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
possibleTarget
)
;
if
(
content
&
&
content
-
>
ChromeOnlyAccess
(
)
)
{
continue
;
}
nsINode
*
commonAncestor
=
nullptr
;
int32_t
realTargetCount
=
realTargets
.
Count
(
)
;
for
(
int32_t
j
=
0
;
j
<
realTargetCount
;
+
+
j
)
{
commonAncestor
=
nsContentUtils
:
:
GetCommonAncestor
(
possibleTarget
realTargets
[
j
]
)
;
if
(
commonAncestor
)
{
realTargets
.
ReplaceObjectAt
(
commonAncestor
j
)
;
break
;
}
}
if
(
!
commonAncestor
)
{
realTargets
.
AppendObject
(
possibleTarget
)
;
}
}
mSubtreeModifiedTargets
.
Clear
(
)
;
int32_t
realTargetCount
=
realTargets
.
Count
(
)
;
for
(
int32_t
k
=
0
;
k
<
realTargetCount
;
+
+
k
)
{
InternalMutationEvent
mutation
(
true
eLegacySubtreeModified
)
;
(
new
AsyncEventDispatcher
(
realTargets
[
k
]
mutation
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
}
}
void
Document
:
:
DestroyElementMaps
(
)
{
#
ifdef
DEBUG
mStyledLinksCleared
=
true
;
#
endif
mStyledLinks
.
Clear
(
)
;
mIdentifierMap
.
Clear
(
)
;
mComposedShadowRoots
.
Clear
(
)
;
mResponsiveContent
.
Clear
(
)
;
IncrementExpandoGeneration
(
*
this
)
;
}
void
Document
:
:
RefreshLinkHrefs
(
)
{
LinkArray
linksToNotify
(
mStyledLinks
.
Count
(
)
)
;
for
(
auto
iter
=
mStyledLinks
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
linksToNotify
.
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
nsAutoScriptBlocker
scriptBlocker
;
for
(
LinkArray
:
:
size_type
i
=
0
;
i
<
linksToNotify
.
Length
(
)
;
i
+
+
)
{
linksToNotify
[
i
]
-
>
ResetLinkState
(
true
linksToNotify
[
i
]
-
>
ElementHasHref
(
)
)
;
}
}
nsresult
Document
:
:
CloneDocHelper
(
Document
*
clone
)
const
{
clone
-
>
mIsStaticDocument
=
mCreatingStaticClone
;
nsresult
rv
=
clone
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mCreatingStaticClone
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsCOMPtr
<
nsIDocumentLoader
>
docLoader
(
mDocumentContainer
)
;
if
(
docLoader
)
{
docLoader
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
GetChannel
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
channel
)
{
NS_GetFinalChannelURI
(
channel
getter_AddRefs
(
uri
)
)
;
}
else
{
uri
=
Document
:
:
GetDocumentURI
(
)
;
}
clone
-
>
mChannel
=
channel
;
if
(
uri
)
{
clone
-
>
ResetToURI
(
uri
loadGroup
NodePrincipal
(
)
EffectiveStoragePrincipal
(
)
)
;
}
clone
-
>
SetContainer
(
mDocumentContainer
)
;
}
clone
-
>
SetDocumentURI
(
Document
:
:
GetDocumentURI
(
)
)
;
clone
-
>
SetChromeXHRDocURI
(
mChromeXHRDocURI
)
;
clone
-
>
SetPrincipals
(
NodePrincipal
(
)
EffectiveStoragePrincipal
(
)
)
;
clone
-
>
mDocumentBaseURI
=
mDocumentBaseURI
;
clone
-
>
SetChromeXHRDocBaseURI
(
mChromeXHRDocBaseURI
)
;
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
GetScriptHandlingObject
(
hasHadScriptObject
)
;
NS_ENSURE_STATE
(
scriptObject
|
|
!
hasHadScriptObject
)
;
if
(
mCreatingStaticClone
)
{
clone
-
>
mHasHadScriptHandlingObject
=
true
;
}
else
if
(
scriptObject
)
{
clone
-
>
SetScriptHandlingObject
(
scriptObject
)
;
}
else
{
clone
-
>
SetScopeObject
(
GetScopeObject
(
)
)
;
}
clone
-
>
SetLoadedAsData
(
true
)
;
clone
-
>
mCharacterSet
=
mCharacterSet
;
clone
-
>
mCharacterSetSource
=
mCharacterSetSource
;
clone
-
>
mCompatMode
=
mCompatMode
;
clone
-
>
mBidiOptions
=
mBidiOptions
;
clone
-
>
mContentLanguage
=
mContentLanguage
;
clone
-
>
SetContentTypeInternal
(
GetContentTypeInternal
(
)
)
;
clone
-
>
mSecurityInfo
=
mSecurityInfo
;
clone
-
>
mType
=
mType
;
clone
-
>
mXMLDeclarationBits
=
mXMLDeclarationBits
;
clone
-
>
mBaseTarget
=
mBaseTarget
;
return
NS_OK
;
}
static
bool
SetLoadingInSubDocument
(
Document
*
aDocument
void
*
aData
)
{
aDocument
-
>
SetAncestorLoading
(
*
(
static_cast
<
bool
*
>
(
aData
)
)
)
;
return
true
;
}
void
Document
:
:
SetAncestorLoading
(
bool
aAncestorIsLoading
)
{
NotifyLoading
(
mAncestorIsLoading
aAncestorIsLoading
mReadyState
mReadyState
)
;
mAncestorIsLoading
=
aAncestorIsLoading
;
}
void
Document
:
:
NotifyLoading
(
const
bool
&
aCurrentParentIsLoading
bool
aNewParentIsLoading
const
ReadyState
&
aCurrentState
ReadyState
aNewState
)
{
bool
was_loading
=
aCurrentParentIsLoading
|
|
aCurrentState
=
=
READYSTATE_LOADING
|
|
aCurrentState
=
=
READYSTATE_INTERACTIVE
;
bool
is_loading
=
aNewParentIsLoading
|
|
aNewState
=
=
READYSTATE_LOADING
|
|
aNewState
=
=
READYSTATE_INTERACTIVE
;
bool
set_load_state
=
was_loading
!
=
is_loading
;
if
(
set_load_state
&
&
StaticPrefs
:
:
dom_timeout_defer_during_load
(
)
)
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
inner
-
>
SetActiveLoadingState
(
is_loading
)
;
}
EnumerateSubDocuments
(
SetLoadingInSubDocument
&
is_loading
)
;
}
}
void
Document
:
:
SetReadyStateInternal
(
ReadyState
rs
bool
updateTimingInformation
)
{
if
(
rs
=
=
READYSTATE_UNINITIALIZED
)
{
mReadyState
=
rs
;
return
;
}
if
(
updateTimingInformation
&
&
READYSTATE_LOADING
=
=
rs
)
{
mLoadingTimeStamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
}
NotifyLoading
(
mAncestorIsLoading
mAncestorIsLoading
mReadyState
rs
)
;
mReadyState
=
rs
;
if
(
updateTimingInformation
&
&
mTiming
)
{
switch
(
rs
)
{
case
READYSTATE_LOADING
:
mTiming
-
>
NotifyDOMLoading
(
Document
:
:
GetDocumentURI
(
)
)
;
break
;
case
READYSTATE_INTERACTIVE
:
mTiming
-
>
NotifyDOMInteractive
(
Document
:
:
GetDocumentURI
(
)
)
;
break
;
case
READYSTATE_COMPLETE
:
mTiming
-
>
NotifyDOMComplete
(
Document
:
:
GetDocumentURI
(
)
)
;
break
;
default
:
NS_WARNING
(
"
Unexpected
ReadyState
value
"
)
;
break
;
}
}
if
(
READYSTATE_INTERACTIVE
=
=
rs
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
NodePrincipal
(
)
)
)
{
Element
*
root
=
GetRootElement
(
)
;
if
(
(
root
&
&
root
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozpersist
)
)
|
|
IsXULDocument
(
)
)
{
mXULPersist
=
new
XULPersist
(
this
)
;
mXULPersist
-
>
Init
(
)
;
}
}
}
if
(
updateTimingInformation
)
{
RecordNavigationTiming
(
rs
)
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
readystatechange
"
)
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
asyncDispatcher
-
>
RunDOMEventWhenSafe
(
)
;
}
void
Document
:
:
GetReadyState
(
nsAString
&
aReadyState
)
const
{
switch
(
mReadyState
)
{
case
READYSTATE_LOADING
:
aReadyState
.
AssignLiteral
(
u
"
loading
"
)
;
break
;
case
READYSTATE_INTERACTIVE
:
aReadyState
.
AssignLiteral
(
u
"
interactive
"
)
;
break
;
case
READYSTATE_COMPLETE
:
aReadyState
.
AssignLiteral
(
u
"
complete
"
)
;
break
;
default
:
aReadyState
.
AssignLiteral
(
u
"
uninitialized
"
)
;
}
}
static
bool
SuppressEventHandlingInDocument
(
Document
*
aDocument
void
*
aData
)
{
aDocument
-
>
SuppressEventHandling
(
*
static_cast
<
uint32_t
*
>
(
aData
)
)
;
return
true
;
}
void
Document
:
:
SuppressEventHandling
(
uint32_t
aIncrease
)
{
mEventsSuppressed
+
=
aIncrease
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aIncrease
;
+
+
i
)
{
ScriptLoader
(
)
-
>
AddExecuteBlocker
(
)
;
}
EnumerateSubDocuments
(
SuppressEventHandlingInDocument
&
aIncrease
)
;
}
static
void
FireOrClearDelayedEvents
(
nsTArray
<
nsCOMPtr
<
Document
>
>
&
aDocuments
bool
aFireEvents
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
return
;
for
(
uint32_t
i
=
0
;
i
<
aDocuments
.
Length
(
)
;
+
+
i
)
{
if
(
!
aDocuments
[
i
]
-
>
EventHandlingSuppressed
(
)
)
{
fm
-
>
FireDelayedEvents
(
aDocuments
[
i
]
)
;
RefPtr
<
PresShell
>
presShell
=
aDocuments
[
i
]
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
bool
fire
=
aFireEvents
&
&
aDocuments
[
i
]
-
>
GetInnerWindow
(
)
&
&
aDocuments
[
i
]
-
>
GetInnerWindow
(
)
-
>
IsCurrentInnerWindow
(
)
;
presShell
-
>
FireOrClearDelayedEvents
(
fire
)
;
}
}
}
}
void
Document
:
:
PreloadPictureClosed
(
)
{
MOZ_ASSERT
(
mPreloadPictureDepth
>
0
)
;
mPreloadPictureDepth
-
-
;
if
(
mPreloadPictureDepth
=
=
0
)
{
mPreloadPictureFoundSource
.
SetIsVoid
(
true
)
;
}
}
void
Document
:
:
PreloadPictureImageSource
(
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
)
{
if
(
mPreloadPictureDepth
=
=
1
&
&
mPreloadPictureFoundSource
.
IsVoid
(
)
)
{
bool
found
=
HTMLImageElement
:
:
SelectSourceForTagWithAttrs
(
this
true
VoidString
(
)
aSrcsetAttr
aSizesAttr
aTypeAttr
aMediaAttr
mPreloadPictureFoundSource
)
;
if
(
found
&
&
mPreloadPictureFoundSource
.
IsVoid
(
)
)
{
mPreloadPictureFoundSource
.
SetIsVoid
(
false
)
;
}
}
}
already_AddRefed
<
nsIURI
>
Document
:
:
ResolvePreloadImage
(
nsIURI
*
aBaseURI
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
bool
*
aIsImgSet
)
{
nsString
sourceURL
;
bool
isImgSet
;
if
(
mPreloadPictureDepth
=
=
1
&
&
!
mPreloadPictureFoundSource
.
IsVoid
(
)
)
{
sourceURL
=
mPreloadPictureFoundSource
;
isImgSet
=
true
;
}
else
{
HTMLImageElement
:
:
SelectSourceForTagWithAttrs
(
this
false
aSrcAttr
aSrcsetAttr
aSizesAttr
VoidString
(
)
VoidString
(
)
sourceURL
)
;
isImgSet
=
!
aSrcsetAttr
.
IsEmpty
(
)
;
}
if
(
sourceURL
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
uri
)
sourceURL
this
aBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
*
aIsImgSet
=
isImgSet
;
return
uri
.
forget
(
)
;
}
void
Document
:
:
MaybePreLoadImage
(
nsIURI
*
uri
const
nsAString
&
aCrossOriginAttr
enum
mozilla
:
:
net
:
:
ReferrerPolicy
aReferrerPolicy
bool
aIsImgSet
)
{
if
(
nsContentUtils
:
:
IsImageInCache
(
uri
this
)
)
{
return
;
}
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
|
nsContentUtils
:
:
CORSModeToLoadImageFlags
(
Element
:
:
StringToCORSMode
(
aCrossOriginAttr
)
)
;
nsContentPolicyType
policyType
=
aIsImgSet
?
nsIContentPolicy
:
:
TYPE_IMAGESET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
;
RefPtr
<
imgRequestProxy
>
request
;
nsresult
rv
=
nsContentUtils
:
:
LoadImage
(
uri
static_cast
<
nsINode
*
>
(
this
)
this
NodePrincipal
(
)
0
GetDocumentURIAsReferrer
(
)
aReferrerPolicy
nullptr
loadFlags
NS_LITERAL_STRING
(
"
img
"
)
getter_AddRefs
(
request
)
policyType
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPreloadingImages
.
Put
(
uri
request
.
forget
(
)
)
;
}
}
void
Document
:
:
MaybePreconnect
(
nsIURI
*
aOrigURI
mozilla
:
:
CORSMode
aCORSMode
)
{
NS_MutateURI
mutator
(
aOrigURI
)
;
if
(
NS_FAILED
(
mutator
.
GetStatus
(
)
)
)
{
return
;
}
if
(
aCORSMode
=
=
CORS_ANONYMOUS
)
{
mutator
.
SetPathQueryRef
(
NS_LITERAL_CSTRING
(
"
/
anonymous
"
)
)
;
}
else
{
mutator
.
SetPathQueryRef
(
NS_LITERAL_CSTRING
(
"
/
"
)
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
mutator
.
Finalize
(
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
auto
entry
=
mPreloadedPreconnects
.
LookupForAdd
(
uri
)
;
if
(
entry
)
{
return
;
}
entry
.
OrInsert
(
[
]
(
)
{
return
true
;
}
)
;
nsCOMPtr
<
nsISpeculativeConnect
>
speculator
(
do_QueryInterface
(
nsContentUtils
:
:
GetIOService
(
)
)
)
;
if
(
!
speculator
)
{
return
;
}
if
(
aCORSMode
=
=
CORS_ANONYMOUS
)
{
speculator
-
>
SpeculativeAnonymousConnect
(
uri
NodePrincipal
(
)
nullptr
)
;
}
else
{
speculator
-
>
SpeculativeConnect
(
uri
NodePrincipal
(
)
nullptr
)
;
}
}
void
Document
:
:
ForgetImagePreload
(
nsIURI
*
aURI
)
{
if
(
mPreloadingImages
.
Count
(
)
!
=
0
)
{
nsCOMPtr
<
imgIRequest
>
req
;
mPreloadingImages
.
Remove
(
aURI
getter_AddRefs
(
req
)
)
;
if
(
req
)
{
req
-
>
CancelAndForgetObserver
(
NS_BINDING_ABORTED
)
;
}
}
}
void
Document
:
:
UpdateDocumentStates
(
EventStates
aMaybeChangedStates
bool
aNotify
)
{
EventStates
oldStates
=
mDocumentState
;
if
(
aMaybeChangedStates
.
HasState
(
NS_DOCUMENT_STATE_RTL_LOCALE
)
)
{
if
(
IsDocumentRightToLeft
(
)
)
{
mDocumentState
|
=
NS_DOCUMENT_STATE_RTL_LOCALE
;
}
else
{
mDocumentState
&
=
~
NS_DOCUMENT_STATE_RTL_LOCALE
;
}
}
if
(
aMaybeChangedStates
.
HasState
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
)
{
if
(
IsTopLevelWindowInactive
(
)
)
{
mDocumentState
|
=
NS_DOCUMENT_STATE_WINDOW_INACTIVE
;
}
else
{
mDocumentState
&
=
~
NS_DOCUMENT_STATE_WINDOW_INACTIVE
;
}
}
EventStates
changedStates
=
oldStates
^
mDocumentState
;
if
(
aNotify
&
&
!
changedStates
.
IsEmpty
(
)
)
{
if
(
PresShell
*
ps
=
GetObservingPresShell
(
)
)
{
ps
-
>
DocumentStatesChanged
(
changedStates
)
;
}
}
}
namespace
{
class
StubCSSLoaderObserver
final
:
public
nsICSSLoaderObserver
{
~
StubCSSLoaderObserver
(
)
{
}
public
:
NS_IMETHOD
StyleSheetLoaded
(
StyleSheet
*
bool
nsresult
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
StubCSSLoaderObserver
nsICSSLoaderObserver
)
}
void
Document
:
:
PreloadStyle
(
nsIURI
*
uri
const
Encoding
*
aEncoding
const
nsAString
&
aCrossOriginAttr
const
enum
mozilla
:
:
net
:
:
ReferrerPolicy
aReferrerPolicy
const
nsAString
&
aIntegrity
)
{
nsCOMPtr
<
nsICSSLoaderObserver
>
obs
=
new
StubCSSLoaderObserver
(
)
;
CSSLoader
(
)
-
>
LoadSheet
(
uri
true
NodePrincipal
(
)
aEncoding
obs
Element
:
:
StringToCORSMode
(
aCrossOriginAttr
)
aReferrerPolicy
aIntegrity
)
;
}
RefPtr
<
StyleSheet
>
Document
:
:
LoadChromeSheetSync
(
nsIURI
*
uri
)
{
RefPtr
<
StyleSheet
>
sheet
;
CSSLoader
(
)
-
>
LoadSheetSync
(
uri
css
:
:
eAuthorSheetFeatures
false
&
sheet
)
;
return
sheet
;
}
void
Document
:
:
ResetDocumentDirection
(
)
{
if
(
!
(
nsContentUtils
:
:
IsChromeDoc
(
this
)
|
|
IsXULDocument
(
)
)
)
{
return
;
}
UpdateDocumentStates
(
NS_DOCUMENT_STATE_RTL_LOCALE
true
)
;
}
bool
Document
:
:
IsDocumentRightToLeft
(
)
{
if
(
!
(
nsContentUtils
:
:
IsChromeDoc
(
this
)
|
|
IsXULDocument
(
)
)
)
{
return
false
;
}
Element
*
element
=
GetRootElement
(
)
;
if
(
element
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
ltr
nsGkAtoms
:
:
rtl
nullptr
}
;
switch
(
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
localedir
strings
eCaseMatters
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
break
;
}
}
nsCOMPtr
<
nsIXULChromeRegistry
>
reg
=
mozilla
:
:
services
:
:
GetXULChromeRegistryService
(
)
;
if
(
!
reg
)
return
false
;
nsAutoCString
package
;
bool
isChrome
;
if
(
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
)
&
&
isChrome
)
{
mDocumentURI
-
>
GetHostPort
(
package
)
;
}
else
{
bool
isAbout
isResource
;
if
(
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
about
"
&
isAbout
)
)
&
&
isAbout
)
{
package
.
AssignLiteral
(
"
global
"
)
;
}
else
if
(
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
resource
"
&
isResource
)
)
&
&
isResource
)
{
package
.
AssignLiteral
(
"
global
"
)
;
}
else
{
return
false
;
}
}
bool
isRTL
=
false
;
reg
-
>
IsLocaleRTL
(
package
&
isRTL
)
;
return
isRTL
;
}
class
nsDelayedEventDispatcher
:
public
Runnable
{
public
:
explicit
nsDelayedEventDispatcher
(
nsTArray
<
nsCOMPtr
<
Document
>
>
&
aDocuments
)
:
mozilla
:
:
Runnable
(
"
nsDelayedEventDispatcher
"
)
{
mDocuments
.
SwapElements
(
aDocuments
)
;
}
virtual
~
nsDelayedEventDispatcher
(
)
{
}
NS_IMETHOD
Run
(
)
override
{
FireOrClearDelayedEvents
(
mDocuments
true
)
;
return
NS_OK
;
}
private
:
nsTArray
<
nsCOMPtr
<
Document
>
>
mDocuments
;
}
;
static
bool
GetAndUnsuppressSubDocuments
(
Document
*
aDocument
void
*
aData
)
{
if
(
aDocument
-
>
EventHandlingSuppressed
(
)
>
0
)
{
aDocument
-
>
DecreaseEventSuppression
(
)
;
aDocument
-
>
ScriptLoader
(
)
-
>
RemoveExecuteBlocker
(
)
;
}
auto
*
docs
=
static_cast
<
nsTArray
<
nsCOMPtr
<
Document
>
>
*
>
(
aData
)
;
docs
-
>
AppendElement
(
aDocument
)
;
aDocument
-
>
EnumerateSubDocuments
(
GetAndUnsuppressSubDocuments
aData
)
;
return
true
;
}
void
Document
:
:
UnsuppressEventHandlingAndFireEvents
(
bool
aFireEvents
)
{
nsTArray
<
nsCOMPtr
<
Document
>
>
documents
;
GetAndUnsuppressSubDocuments
(
this
&
documents
)
;
if
(
aFireEvents
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
ded
=
new
nsDelayedEventDispatcher
(
documents
)
;
Dispatch
(
TaskCategory
:
:
Other
ded
.
forget
(
)
)
;
}
else
{
FireOrClearDelayedEvents
(
documents
false
)
;
}
if
(
!
EventHandlingSuppressed
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
RefPtr
<
net
:
:
ChannelEventQueue
>
>
queues
;
mSuspendedQueues
.
SwapElements
(
queues
)
;
for
(
net
:
:
ChannelEventQueue
*
queue
:
queues
)
{
queue
-
>
Resume
(
)
;
}
if
(
mHasDelayedRefreshEvent
)
{
mHasDelayedRefreshEvent
=
false
;
if
(
mPresShell
)
{
nsRefreshDriver
*
rd
=
mPresShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
rd
-
>
RunDelayedEventsSoon
(
)
;
}
}
}
}
void
Document
:
:
AddSuspendedChannelEventQueue
(
net
:
:
ChannelEventQueue
*
aQueue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
EventHandlingSuppressed
(
)
)
;
mSuspendedQueues
.
AppendElement
(
aQueue
)
;
}
static
bool
SetSuppressedEventListenerInSubDocument
(
Document
*
aDocument
void
*
aData
)
{
aDocument
-
>
SetSuppressedEventListener
(
static_cast
<
EventListener
*
>
(
aData
)
)
;
return
true
;
}
void
Document
:
:
SetSuppressedEventListener
(
EventListener
*
aListener
)
{
mSuppressedEventListener
=
aListener
;
EnumerateSubDocuments
(
SetSuppressedEventListenerInSubDocument
aListener
)
;
}
nsISupports
*
Document
:
:
GetCurrentContentSink
(
)
{
return
mParser
?
mParser
-
>
GetContentSink
(
)
:
nullptr
;
}
Document
*
Document
:
:
GetTemplateContentsOwner
(
)
{
if
(
!
mTemplateContentsOwner
)
{
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
GetScriptHandlingObject
(
hasHadScriptObject
)
;
nsCOMPtr
<
Document
>
document
;
nsresult
rv
=
NS_NewDOMDocument
(
getter_AddRefs
(
document
)
EmptyString
(
)
EmptyString
(
)
nullptr
Document
:
:
GetDocumentURI
(
)
Document
:
:
GetDocBaseURI
(
)
NodePrincipal
(
)
true
scriptObject
DocumentFlavorHTML
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
mTemplateContentsOwner
=
document
;
NS_ENSURE_TRUE
(
mTemplateContentsOwner
nullptr
)
;
if
(
!
scriptObject
)
{
mTemplateContentsOwner
-
>
SetScopeObject
(
GetScopeObject
(
)
)
;
}
mTemplateContentsOwner
-
>
mHasHadScriptHandlingObject
=
hasHadScriptObject
;
mTemplateContentsOwner
-
>
mTemplateContentsOwner
=
mTemplateContentsOwner
;
}
return
mTemplateContentsOwner
;
}
static
already_AddRefed
<
nsPIDOMWindowOuter
>
FindTopWindowForElement
(
Element
*
element
)
{
Document
*
document
=
element
-
>
OwnerDoc
(
)
;
if
(
!
document
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
document
-
>
GetWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
window
-
>
GetTop
(
)
)
{
window
=
top
.
forget
(
)
;
}
return
window
.
forget
(
)
;
}
class
nsAutoFocusEvent
:
public
Runnable
{
public
:
explicit
nsAutoFocusEvent
(
already_AddRefed
<
Element
>
&
&
aElement
already_AddRefed
<
nsPIDOMWindowOuter
>
&
&
aTopWindow
)
:
mozilla
:
:
Runnable
(
"
nsAutoFocusEvent
"
)
mElement
(
aElement
)
mTopWindow
(
aTopWindow
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
currentTopWindow
=
FindTopWindowForElement
(
mElement
)
;
if
(
currentTopWindow
!
=
mTopWindow
)
{
return
NS_OK
;
}
if
(
mTopWindow
-
>
GetFocusedElement
(
)
)
{
return
NS_OK
;
}
FocusOptions
options
;
ErrorResult
rv
;
mElement
-
>
Focus
(
options
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
private
:
nsCOMPtr
<
Element
>
mElement
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mTopWindow
;
}
;
void
Document
:
:
SetAutoFocusElement
(
Element
*
aAutoFocusElement
)
{
if
(
mAutoFocusFired
)
{
return
;
}
if
(
mAutoFocusElement
)
{
return
;
}
mAutoFocusElement
=
do_GetWeakReference
(
aAutoFocusElement
)
;
TriggerAutoFocus
(
)
;
}
void
Document
:
:
TriggerAutoFocus
(
)
{
if
(
mAutoFocusFired
)
{
return
;
}
if
(
!
mPresShell
|
|
!
mPresShell
-
>
DidInitialize
(
)
)
{
return
;
}
nsCOMPtr
<
Element
>
autoFocusElement
=
do_QueryReferent
(
mAutoFocusElement
)
;
if
(
autoFocusElement
&
&
autoFocusElement
-
>
OwnerDoc
(
)
=
=
this
)
{
mAutoFocusFired
=
true
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
FindTopWindowForElement
(
autoFocusElement
)
;
if
(
!
topWindow
)
{
return
;
}
nsCOMPtr
<
Document
>
topDoc
=
topWindow
-
>
GetExtantDoc
(
)
;
if
(
topDoc
&
&
topDoc
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_COMPLETE
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsAutoFocusEvent
(
autoFocusElement
.
forget
(
)
topWindow
.
forget
(
)
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
event
.
forget
(
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
void
Document
:
:
SetScrollToRef
(
nsIURI
*
aDocumentURI
)
{
if
(
!
aDocumentURI
)
{
return
;
}
nsAutoCString
ref
;
nsresult
rv
=
aDocumentURI
-
>
GetSpec
(
ref
)
;
if
(
NS_FAILED
(
rv
)
)
{
Unused
<
<
aDocumentURI
-
>
GetRef
(
mScrollToRef
)
;
return
;
}
nsReadingIterator
<
char
>
start
end
;
ref
.
BeginReading
(
start
)
;
ref
.
EndReading
(
end
)
;
if
(
FindCharInReadable
(
'
#
'
start
end
)
)
{
+
+
start
;
mScrollToRef
=
Substring
(
start
end
)
;
}
}
void
Document
:
:
ScrollToRef
(
)
{
if
(
mScrolledToRefAlready
)
{
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
ScrollToAnchor
(
)
;
}
return
;
}
if
(
mScrollToRef
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
NS_ConvertUTF8toUTF16
ref
(
mScrollToRef
)
;
if
(
!
ref
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
ref
mChangeScrollPosWhenScrollingToRef
)
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
if
(
NS_FAILED
(
rv
)
)
{
nsAutoCString
buff
;
const
bool
unescaped
=
NS_UnescapeURL
(
mScrollToRef
.
BeginReading
(
)
mScrollToRef
.
Length
(
)
0
buff
)
;
if
(
unescaped
)
{
NS_ConvertUTF8toUTF16
utf16Str
(
buff
)
;
if
(
!
utf16Str
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
utf16Str
mChangeScrollPosWhenScrollingToRef
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
const
Encoding
*
encoding
=
GetDocumentCharacterSet
(
)
;
rv
=
encoding
-
>
DecodeWithoutBOMHandling
(
unescaped
?
buff
:
mScrollToRef
ref
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
ref
.
IsEmpty
(
)
)
{
rv
=
presShell
-
>
GoToAnchor
(
ref
mChangeScrollPosWhenScrollingToRef
)
;
}
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
mScrolledToRefAlready
=
true
;
}
}
}
void
Document
:
:
RegisterActivityObserver
(
nsISupports
*
aSupports
)
{
if
(
!
mActivityObservers
)
{
mActivityObservers
=
new
nsTHashtable
<
nsPtrHashKey
<
nsISupports
>
>
(
)
;
}
mActivityObservers
-
>
PutEntry
(
aSupports
)
;
}
bool
Document
:
:
UnregisterActivityObserver
(
nsISupports
*
aSupports
)
{
if
(
!
mActivityObservers
)
{
return
false
;
}
nsPtrHashKey
<
nsISupports
>
*
entry
=
mActivityObservers
-
>
GetEntry
(
aSupports
)
;
if
(
!
entry
)
{
return
false
;
}
mActivityObservers
-
>
RemoveEntry
(
entry
)
;
return
true
;
}
void
Document
:
:
EnumerateActivityObservers
(
ActivityObserverEnumerator
aEnumerator
void
*
aData
)
{
if
(
!
mActivityObservers
)
return
;
for
(
auto
iter
=
mActivityObservers
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aEnumerator
(
iter
.
Get
(
)
-
>
GetKey
(
)
aData
)
;
}
}
void
Document
:
:
RegisterPendingLinkUpdate
(
Link
*
aLink
)
{
if
(
aLink
-
>
HasPendingLinkUpdate
(
)
)
{
return
;
}
aLink
-
>
SetHasPendingLinkUpdate
(
)
;
if
(
!
mHasLinksToUpdateRunnable
&
&
!
mFlushingPendingLinkUpdates
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
Document
:
:
FlushPendingLinkUpdatesFromRunnable
"
this
&
Document
:
:
FlushPendingLinkUpdatesFromRunnable
)
;
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
event
.
forget
(
)
1000
EventQueuePriority
:
:
Idle
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
mHasLinksToUpdateRunnable
=
true
;
}
mLinksToUpdate
.
InfallibleAppend
(
aLink
)
;
}
void
Document
:
:
FlushPendingLinkUpdatesFromRunnable
(
)
{
MOZ_ASSERT
(
mHasLinksToUpdateRunnable
)
;
mHasLinksToUpdateRunnable
=
false
;
FlushPendingLinkUpdates
(
)
;
}
void
Document
:
:
FlushPendingLinkUpdates
(
)
{
if
(
mFlushingPendingLinkUpdates
)
{
return
;
}
auto
restore
=
MakeScopeExit
(
[
&
]
{
mFlushingPendingLinkUpdates
=
false
;
}
)
;
mFlushingPendingLinkUpdates
=
true
;
while
(
!
mLinksToUpdate
.
IsEmpty
(
)
)
{
LinksToUpdateList
links
(
std
:
:
move
(
mLinksToUpdate
)
)
;
for
(
auto
iter
=
links
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Link
*
link
=
iter
.
Get
(
)
;
Element
*
element
=
link
-
>
GetElement
(
)
;
if
(
element
-
>
OwnerDoc
(
)
=
=
this
)
{
link
-
>
ClearHasPendingLinkUpdate
(
)
;
if
(
element
-
>
IsInComposedDoc
(
)
)
{
element
-
>
UpdateLinkState
(
link
-
>
LinkState
(
)
)
;
}
}
}
}
}
already_AddRefed
<
Document
>
Document
:
:
CreateStaticClone
(
nsIDocShell
*
aCloneContainer
)
{
mCreatingStaticClone
=
true
;
RefPtr
<
nsDocShell
>
originalShell
=
mDocumentContainer
.
get
(
)
;
SetContainer
(
static_cast
<
nsDocShell
*
>
(
aCloneContainer
)
)
;
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
clonedNode
=
this
-
>
CloneNode
(
true
rv
)
;
SetContainer
(
originalShell
)
;
nsCOMPtr
<
Document
>
clonedDoc
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
}
else
{
clonedDoc
=
do_QueryInterface
(
clonedNode
)
;
if
(
clonedDoc
)
{
if
(
IsStaticDocument
(
)
)
{
clonedDoc
-
>
mOriginalDocument
=
mOriginalDocument
;
mOriginalDocument
-
>
mLatestStaticClone
=
clonedDoc
;
}
else
{
clonedDoc
-
>
mOriginalDocument
=
this
;
mLatestStaticClone
=
clonedDoc
;
}
clonedDoc
-
>
mOriginalDocument
-
>
mStaticCloneCount
+
+
;
size_t
sheetsCount
=
SheetCount
(
)
;
for
(
size_t
i
=
0
;
i
<
sheetsCount
;
+
+
i
)
{
RefPtr
<
StyleSheet
>
sheet
=
SheetAt
(
i
)
;
if
(
sheet
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
RefPtr
<
StyleSheet
>
clonedSheet
=
sheet
-
>
Clone
(
nullptr
nullptr
clonedDoc
nullptr
)
;
NS_WARNING_ASSERTION
(
clonedSheet
"
Cloning
a
stylesheet
didn
'
t
work
!
"
)
;
if
(
clonedSheet
)
{
clonedDoc
-
>
AddStyleSheet
(
clonedSheet
)
;
}
}
}
}
for
(
int
t
=
0
;
t
<
AdditionalSheetTypeCount
;
+
+
t
)
{
auto
&
sheets
=
mAdditionalSheets
[
additionalSheetType
(
t
)
]
;
for
(
StyleSheet
*
sheet
:
sheets
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
RefPtr
<
StyleSheet
>
clonedSheet
=
sheet
-
>
Clone
(
nullptr
nullptr
clonedDoc
nullptr
)
;
NS_WARNING_ASSERTION
(
clonedSheet
"
Cloning
a
stylesheet
didn
'
t
work
!
"
)
;
if
(
clonedSheet
)
{
clonedDoc
-
>
AddAdditionalStyleSheet
(
additionalSheetType
(
t
)
clonedSheet
)
;
}
}
}
}
if
(
const
FontFaceSet
*
set
=
GetFonts
(
)
)
{
set
-
>
CopyNonRuleFacesTo
(
clonedDoc
-
>
Fonts
(
)
)
;
}
}
}
mCreatingStaticClone
=
false
;
return
clonedDoc
.
forget
(
)
;
}
void
Document
:
:
UnlinkOriginalDocumentIfStatic
(
)
{
if
(
IsStaticDocument
(
)
&
&
mOriginalDocument
)
{
MOZ_ASSERT
(
mOriginalDocument
-
>
mStaticCloneCount
>
0
)
;
mOriginalDocument
-
>
mStaticCloneCount
-
-
;
mOriginalDocument
=
nullptr
;
}
MOZ_ASSERT
(
!
mOriginalDocument
)
;
}
nsresult
Document
:
:
ScheduleFrameRequestCallback
(
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
{
if
(
mFrameRequestCallbackCounter
=
=
INT32_MAX
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
int32_t
newHandle
=
+
+
mFrameRequestCallbackCounter
;
DebugOnly
<
FrameRequest
*
>
request
=
mFrameRequestCallbacks
.
AppendElement
(
FrameRequest
(
aCallback
newHandle
)
)
;
NS_ASSERTION
(
request
"
This
is
supposed
to
be
infallible
!
"
)
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
*
aHandle
=
newHandle
;
return
NS_OK
;
}
void
Document
:
:
CancelFrameRequestCallback
(
int32_t
aHandle
)
{
if
(
mFrameRequestCallbacks
.
RemoveElementSorted
(
aHandle
)
)
{
UpdateFrameRequestCallbackSchedulingState
(
)
;
}
else
{
Unused
<
<
mCanceledFrameRequestCallbacks
.
put
(
aHandle
)
;
}
}
bool
Document
:
:
IsCanceledFrameRequestCallback
(
int32_t
aHandle
)
const
{
return
!
mCanceledFrameRequestCallbacks
.
empty
(
)
&
&
mCanceledFrameRequestCallbacks
.
has
(
aHandle
)
;
}
nsresult
Document
:
:
GetStateObject
(
nsIVariant
*
*
aState
)
{
if
(
!
mStateObjectCached
&
&
mStateObjectContainer
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
GetScopeObject
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mStateObjectContainer
-
>
DeserializeToVariant
(
jsapi
.
cx
(
)
getter_AddRefs
(
mStateObjectCached
)
)
;
}
NS_IF_ADDREF
(
*
aState
=
mStateObjectCached
)
;
return
NS_OK
;
}
void
Document
:
:
SetNavigationTiming
(
nsDOMNavigationTiming
*
aTiming
)
{
mTiming
=
aTiming
;
if
(
!
mLoadingTimeStamp
.
IsNull
(
)
&
&
mTiming
)
{
mTiming
-
>
SetDOMLoadingTimeStamp
(
GetDocumentURI
(
)
mLoadingTimeStamp
)
;
}
}
nsContentList
*
Document
:
:
ImageMapList
(
)
{
if
(
!
mImageMaps
)
{
mImageMaps
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
map
nsGkAtoms
:
:
map
)
;
}
return
mImageMaps
;
}
#
define
DEPRECATED_OPERATION
(
_op
)
#
_op
"
Warning
"
static
const
char
*
kDeprecationWarnings
[
]
=
{
#
include
"
nsDeprecatedOperationList
.
h
"
nullptr
}
;
#
undef
DEPRECATED_OPERATION
#
define
DOCUMENT_WARNING
(
_op
)
#
_op
"
Warning
"
static
const
char
*
kDocumentWarnings
[
]
=
{
#
include
"
nsDocumentWarningList
.
h
"
nullptr
}
;
#
undef
DOCUMENT_WARNING
static
UseCounter
OperationToUseCounter
(
Document
:
:
DeprecatedOperations
aOperation
)
{
switch
(
aOperation
)
{
#
define
DEPRECATED_OPERATION
(
_op
)
\
case
Document
:
:
e
#
#
_op
:
\
return
eUseCounter_
#
#
_op
;
#
include
"
nsDeprecatedOperationList
.
h
"
#
undef
DEPRECATED_OPERATION
default
:
MOZ_CRASH
(
)
;
}
}
bool
Document
:
:
HasWarnedAbout
(
DeprecatedOperations
aOperation
)
const
{
return
mDeprecationWarnedAbout
[
aOperation
]
;
}
void
Document
:
:
WarnOnceAbout
(
DeprecatedOperations
aOperation
bool
asError
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasWarnedAbout
(
aOperation
)
)
{
return
;
}
mDeprecationWarnedAbout
[
aOperation
]
=
true
;
if
(
!
IsAboutPage
(
)
)
{
const_cast
<
Document
*
>
(
this
)
-
>
SetDocumentAndPageUseCounter
(
OperationToUseCounter
(
aOperation
)
)
;
}
uint32_t
flags
=
asError
?
nsIScriptError
:
:
errorFlag
:
nsIScriptError
:
:
warningFlag
;
nsContentUtils
:
:
ReportToConsole
(
flags
NS_LITERAL_CSTRING
(
"
DOM
Core
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
kDeprecationWarnings
[
aOperation
]
)
;
}
bool
Document
:
:
HasWarnedAbout
(
DocumentWarnings
aWarning
)
const
{
return
mDocWarningWarnedAbout
[
aWarning
]
;
}
void
Document
:
:
WarnOnceAbout
(
DocumentWarnings
aWarning
bool
asError
const
char16_t
*
*
aParams
uint32_t
aParamsLength
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasWarnedAbout
(
aWarning
)
)
{
return
;
}
mDocWarningWarnedAbout
[
aWarning
]
=
true
;
uint32_t
flags
=
asError
?
nsIScriptError
:
:
errorFlag
:
nsIScriptError
:
:
warningFlag
;
nsContentUtils
:
:
ReportToConsole
(
flags
NS_LITERAL_CSTRING
(
"
DOM
Core
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
kDocumentWarnings
[
aWarning
]
aParams
aParamsLength
)
;
}
mozilla
:
:
dom
:
:
ImageTracker
*
Document
:
:
ImageTracker
(
)
{
if
(
!
mImageTracker
)
{
mImageTracker
=
new
mozilla
:
:
dom
:
:
ImageTracker
;
}
return
mImageTracker
;
}
static
bool
AllSubDocumentPluginEnum
(
Document
*
aDocument
void
*
userArg
)
{
nsTArray
<
nsIObjectLoadingContent
*
>
*
plugins
=
reinterpret_cast
<
nsTArray
<
nsIObjectLoadingContent
*
>
*
>
(
userArg
)
;
MOZ_ASSERT
(
plugins
)
;
aDocument
-
>
GetPlugins
(
*
plugins
)
;
return
true
;
}
void
Document
:
:
GetPlugins
(
nsTArray
<
nsIObjectLoadingContent
*
>
&
aPlugins
)
{
aPlugins
.
SetCapacity
(
aPlugins
.
Length
(
)
+
mPlugins
.
Count
(
)
)
;
for
(
auto
iter
=
mPlugins
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aPlugins
.
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
EnumerateSubDocuments
(
AllSubDocumentPluginEnum
&
aPlugins
)
;
}
void
Document
:
:
ScheduleSVGUseElementShadowTreeUpdate
(
SVGUseElement
&
aUseElement
)
{
MOZ_ASSERT
(
aUseElement
.
IsInComposedDoc
(
)
)
;
mSVGUseElementsNeedingShadowTreeUpdate
.
PutEntry
(
&
aUseElement
)
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
}
void
Document
:
:
DoUpdateSVGUseElementShadowTrees
(
)
{
MOZ_ASSERT
(
!
mSVGUseElementsNeedingShadowTreeUpdate
.
IsEmpty
(
)
)
;
nsTArray
<
RefPtr
<
SVGUseElement
>
>
useElementsToUpdate
;
do
{
useElementsToUpdate
.
Clear
(
)
;
useElementsToUpdate
.
SetCapacity
(
mSVGUseElementsNeedingShadowTreeUpdate
.
Count
(
)
)
;
{
for
(
auto
iter
=
mSVGUseElementsNeedingShadowTreeUpdate
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
useElementsToUpdate
.
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mSVGUseElementsNeedingShadowTreeUpdate
.
Clear
(
)
;
}
for
(
auto
&
useElement
:
useElementsToUpdate
)
{
if
(
MOZ_UNLIKELY
(
!
useElement
-
>
IsInComposedDoc
(
)
)
)
{
MOZ_ASSERT
(
useElementsToUpdate
.
Length
(
)
>
1
)
;
continue
;
}
useElement
-
>
UpdateShadowTree
(
)
;
}
}
while
(
!
mSVGUseElementsNeedingShadowTreeUpdate
.
IsEmpty
(
)
)
;
}
void
Document
:
:
NotifyMediaFeatureValuesChanged
(
)
{
for
(
auto
iter
=
mResponsiveContent
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
HTMLImageElement
>
imageElement
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
imageElement
-
>
MediaFeatureValuesChanged
(
)
;
}
}
already_AddRefed
<
Touch
>
Document
:
:
CreateTouch
(
nsGlobalWindowInner
*
aView
EventTarget
*
aTarget
int32_t
aIdentifier
int32_t
aPageX
int32_t
aPageY
int32_t
aScreenX
int32_t
aScreenY
int32_t
aClientX
int32_t
aClientY
int32_t
aRadiusX
int32_t
aRadiusY
float
aRotationAngle
float
aForce
)
{
RefPtr
<
Touch
>
touch
=
new
Touch
(
aTarget
aIdentifier
aPageX
aPageY
aScreenX
aScreenY
aClientX
aClientY
aRadiusX
aRadiusY
aRotationAngle
aForce
)
;
return
touch
.
forget
(
)
;
}
already_AddRefed
<
TouchList
>
Document
:
:
CreateTouchList
(
)
{
RefPtr
<
TouchList
>
retval
=
new
TouchList
(
ToSupports
(
this
)
)
;
return
retval
.
forget
(
)
;
}
already_AddRefed
<
TouchList
>
Document
:
:
CreateTouchList
(
Touch
&
aTouch
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
{
RefPtr
<
TouchList
>
retval
=
new
TouchList
(
ToSupports
(
this
)
)
;
retval
-
>
Append
(
&
aTouch
)
;
for
(
uint32_t
i
=
0
;
i
<
aTouches
.
Length
(
)
;
+
+
i
)
{
retval
-
>
Append
(
aTouches
[
i
]
.
get
(
)
)
;
}
return
retval
.
forget
(
)
;
}
already_AddRefed
<
TouchList
>
Document
:
:
CreateTouchList
(
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
{
RefPtr
<
TouchList
>
retval
=
new
TouchList
(
ToSupports
(
this
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aTouches
.
Length
(
)
;
+
+
i
)
{
retval
-
>
Append
(
aTouches
[
i
]
.
get
(
)
)
;
}
return
retval
.
forget
(
)
;
}
already_AddRefed
<
nsDOMCaretPosition
>
Document
:
:
CaretPositionFromPoint
(
float
aX
float
aY
)
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
nscoord
x
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aX
)
;
nscoord
y
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aY
)
;
nsPoint
pt
(
x
y
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nullptr
;
}
nsIFrame
*
ptFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
pt
{
FrameForPointOption
:
:
IgnorePaintSuppression
FrameForPointOption
:
:
IgnoreCrossDoc
}
)
;
if
(
!
ptFrame
)
{
return
nullptr
;
}
nsPoint
aOffset
;
nsCOMPtr
<
nsIWidget
>
widget
=
nsContentUtils
:
:
GetWidget
(
presShell
&
aOffset
)
;
LayoutDeviceIntPoint
refPoint
=
nsContentUtils
:
:
ToWidgetPoint
(
CSSPoint
(
aX
aY
)
aOffset
GetPresContext
(
)
)
;
nsPoint
adjustedPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
widget
refPoint
ptFrame
)
;
nsFrame
:
:
ContentOffsets
offsets
=
ptFrame
-
>
GetContentOffsetsFromPoint
(
adjustedPoint
)
;
nsCOMPtr
<
nsIContent
>
node
=
offsets
.
content
;
uint32_t
offset
=
offsets
.
offset
;
nsCOMPtr
<
nsIContent
>
anonNode
=
node
;
bool
nodeIsAnonymous
=
node
&
&
node
-
>
IsInNativeAnonymousSubtree
(
)
;
if
(
nodeIsAnonymous
)
{
node
=
ptFrame
-
>
GetContent
(
)
;
nsIContent
*
nonanon
=
node
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
nonanon
)
;
nsITextControlFrame
*
textFrame
=
do_QueryFrame
(
nonanon
-
>
GetPrimaryFrame
(
)
)
;
nsNumberControlFrame
*
numberFrame
=
do_QueryFrame
(
nonanon
-
>
GetPrimaryFrame
(
)
)
;
if
(
textFrame
|
|
numberFrame
)
{
nsCOMPtr
<
nsIContent
>
firstChild
=
anonNode
-
>
GetFirstChild
(
)
;
if
(
firstChild
)
{
anonNode
=
firstChild
;
}
if
(
textArea
)
{
offset
=
nsContentUtils
:
:
GetAdjustedOffsetInTextControl
(
ptFrame
offset
)
;
}
node
=
nonanon
;
}
else
{
node
=
nullptr
;
offset
=
0
;
}
}
RefPtr
<
nsDOMCaretPosition
>
aCaretPos
=
new
nsDOMCaretPosition
(
node
offset
)
;
if
(
nodeIsAnonymous
)
{
aCaretPos
-
>
SetAnonymousContentNode
(
anonNode
)
;
}
return
aCaretPos
.
forget
(
)
;
}
bool
Document
:
:
IsPotentiallyScrollable
(
HTMLBodyElement
*
aBody
)
{
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
nsIFrame
*
bodyFrame
=
aBody
-
>
GetPrimaryFrame
(
)
;
if
(
!
bodyFrame
)
{
return
false
;
}
MOZ_ASSERT
(
aBody
-
>
GetParent
(
)
=
=
aBody
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
)
;
nsIFrame
*
parentFrame
=
aBody
-
>
GetParent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
parentFrame
&
&
parentFrame
-
>
StyleDisplay
(
)
-
>
mOverflowX
=
=
StyleOverflow
:
:
Visible
&
&
parentFrame
-
>
StyleDisplay
(
)
-
>
mOverflowY
=
=
StyleOverflow
:
:
Visible
)
{
return
false
;
}
if
(
bodyFrame
-
>
StyleDisplay
(
)
-
>
mOverflowX
=
=
StyleOverflow
:
:
Visible
&
&
bodyFrame
-
>
StyleDisplay
(
)
-
>
mOverflowY
=
=
StyleOverflow
:
:
Visible
)
{
return
false
;
}
return
true
;
}
Element
*
Document
:
:
GetScrollingElement
(
)
{
if
(
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
{
RefPtr
<
HTMLBodyElement
>
body
=
GetBodyElement
(
)
;
if
(
body
&
&
!
IsPotentiallyScrollable
(
body
)
)
{
return
body
;
}
return
nullptr
;
}
return
GetRootElement
(
)
;
}
bool
Document
:
:
IsScrollingElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
if
(
GetCompatibilityMode
(
)
!
=
eCompatibility_NavQuirks
)
{
return
aElement
=
=
GetRootElement
(
)
;
}
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
aElement
!
=
body
)
{
return
false
;
}
RefPtr
<
HTMLBodyElement
>
strongBody
(
body
)
;
return
!
IsPotentiallyScrollable
(
strongBody
)
;
}
class
UnblockParsingPromiseHandler
final
:
public
PromiseNativeHandler
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
UnblockParsingPromiseHandler
)
explicit
UnblockParsingPromiseHandler
(
Document
*
aDocument
Promise
*
aPromise
const
BlockParsingOptions
&
aOptions
)
:
mPromise
(
aPromise
)
{
nsCOMPtr
<
nsIParser
>
parser
=
aDocument
-
>
CreatorParserOrNull
(
)
;
if
(
parser
&
&
(
aOptions
.
mBlockScriptCreated
|
|
!
parser
-
>
IsScriptCreated
(
)
)
)
{
parser
-
>
BlockParser
(
)
;
mParser
=
do_GetWeakReference
(
parser
)
;
mDocument
=
aDocument
;
mDocument
-
>
BlockOnload
(
)
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MaybeUnblockParser
(
)
;
mPromise
-
>
MaybeResolve
(
aCx
aValue
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MaybeUnblockParser
(
)
;
mPromise
-
>
MaybeReject
(
aCx
aValue
)
;
}
protected
:
virtual
~
UnblockParsingPromiseHandler
(
)
{
if
(
mDocument
)
{
MaybeUnblockParser
(
)
;
}
}
private
:
void
MaybeUnblockParser
(
)
{
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryReferent
(
mParser
)
;
if
(
parser
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mDocument
)
;
nsCOMPtr
<
nsIParser
>
docParser
=
mDocument
-
>
CreatorParserOrNull
(
)
;
if
(
parser
=
=
docParser
)
{
parser
-
>
UnblockParser
(
)
;
parser
-
>
ContinueInterruptedParsingAsync
(
)
;
}
}
if
(
mDocument
)
{
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
}
mParser
=
nullptr
;
mDocument
=
nullptr
;
}
nsWeakPtr
mParser
;
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
Document
>
mDocument
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
UnblockParsingPromiseHandler
mDocument
mPromise
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
UnblockParsingPromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
UnblockParsingPromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
UnblockParsingPromiseHandler
)
already_AddRefed
<
Promise
>
Document
:
:
BlockParsing
(
Promise
&
aPromise
const
BlockParsingOptions
&
aOptions
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
resultPromise
=
Promise
:
:
Create
(
aPromise
.
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
PromiseNativeHandler
>
promiseHandler
=
new
UnblockParsingPromiseHandler
(
this
resultPromise
aOptions
)
;
aPromise
.
AppendNativeHandler
(
promiseHandler
)
;
return
resultPromise
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
Document
:
:
GetMozDocumentURIIfNotForErrorPages
(
)
{
if
(
mFailedChannel
)
{
nsCOMPtr
<
nsIURI
>
failedURI
;
if
(
NS_SUCCEEDED
(
mFailedChannel
-
>
GetURI
(
getter_AddRefs
(
failedURI
)
)
)
)
{
return
failedURI
.
forget
(
)
;
}
}
nsCOMPtr
<
nsIURI
>
uri
=
GetDocumentURIObject
(
)
;
if
(
!
uri
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
Promise
*
Document
:
:
GetDocumentReadyForIdle
(
ErrorResult
&
aRv
)
{
if
(
!
mReadyForIdle
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
mReadyForIdle
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
return
mReadyForIdle
;
}
void
Document
:
:
MaybeResolveReadyForIdle
(
)
{
IgnoredErrorResult
rv
;
Promise
*
readyPromise
=
GetDocumentReadyForIdle
(
rv
)
;
if
(
readyPromise
)
{
readyPromise
-
>
MaybeResolve
(
this
)
;
}
}
FeaturePolicy
*
Document
:
:
Policy
(
)
const
{
MOZ_ASSERT
(
mFeaturePolicy
)
;
return
mFeaturePolicy
;
}
nsIDOMXULCommandDispatcher
*
Document
:
:
GetCommandDispatcher
(
)
{
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
return
nullptr
;
}
if
(
!
mCommandDispatcher
)
{
mCommandDispatcher
=
new
nsXULCommandDispatcher
(
this
)
;
}
return
mCommandDispatcher
;
}
void
Document
:
:
InitializeXULBroadcastManager
(
)
{
if
(
mXULBroadcastManager
)
{
return
;
}
mXULBroadcastManager
=
new
XULBroadcastManager
(
this
)
;
}
static
bool
NodeHasScopeObject
(
nsINode
*
node
)
{
MOZ_ASSERT
(
node
"
Must
not
be
called
with
null
.
"
)
;
Document
*
doc
=
node
-
>
OwnerDoc
(
)
;
MOZ_ASSERT
(
doc
"
This
should
never
happen
.
"
)
;
nsIGlobalObject
*
global
=
doc
-
>
GetScopeObject
(
)
;
return
global
?
global
-
>
HasJSGlobal
(
)
:
false
;
}
already_AddRefed
<
nsPIWindowRoot
>
Document
:
:
GetWindowRoot
(
)
{
if
(
!
mDocumentContainer
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
piWin
=
mDocumentContainer
-
>
GetWindow
(
)
;
return
piWin
?
piWin
-
>
GetTopWindowRoot
(
)
:
nullptr
;
}
already_AddRefed
<
nsINode
>
Document
:
:
GetPopupNode
(
)
{
nsCOMPtr
<
nsINode
>
node
;
nsCOMPtr
<
nsPIWindowRoot
>
rootWin
=
GetWindowRoot
(
)
;
if
(
rootWin
)
{
node
=
rootWin
-
>
GetPopupNode
(
)
;
}
if
(
!
node
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
node
=
pm
-
>
GetLastTriggerPopupNode
(
this
)
;
}
}
if
(
node
&
&
NodeHasScopeObject
(
node
)
)
{
return
node
.
forget
(
)
;
}
return
nullptr
;
}
void
Document
:
:
SetPopupNode
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsPIWindowRoot
>
rootWin
=
GetWindowRoot
(
)
;
if
(
rootWin
)
{
rootWin
-
>
SetPopupNode
(
aNode
)
;
}
}
nsINode
*
Document
:
:
GetPopupRangeParent
(
ErrorResult
&
aRv
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
pm
-
>
GetMouseLocationParent
(
)
;
}
int32_t
Document
:
:
GetPopupRangeOffset
(
ErrorResult
&
aRv
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
0
;
}
return
pm
-
>
MouseLocationOffset
(
)
;
}
already_AddRefed
<
nsINode
>
Document
:
:
GetTooltipNode
(
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
nsCOMPtr
<
nsINode
>
node
=
pm
-
>
GetLastTriggerTooltipNode
(
this
)
;
if
(
node
)
{
return
node
.
forget
(
)
;
}
}
return
nullptr
;
}
nsIHTMLCollection
*
Document
:
:
Children
(
)
{
if
(
!
mChildrenCollection
)
{
mChildrenCollection
=
new
nsContentList
(
this
kNameSpaceID_Wildcard
nsGkAtoms
:
:
_asterisk
nsGkAtoms
:
:
_asterisk
false
)
;
}
return
mChildrenCollection
;
}
uint32_t
Document
:
:
ChildElementCount
(
)
{
return
Children
(
)
-
>
Length
(
)
;
}
class
FullscreenRoots
{
public
:
static
void
Add
(
Document
*
aDoc
)
;
static
void
ForEach
(
void
(
*
aFunction
)
(
Document
*
aDoc
)
)
;
static
void
Remove
(
Document
*
aDoc
)
;
static
bool
IsEmpty
(
)
;
private
:
FullscreenRoots
(
)
{
MOZ_COUNT_CTOR
(
FullscreenRoots
)
;
}
~
FullscreenRoots
(
)
{
MOZ_COUNT_DTOR
(
FullscreenRoots
)
;
}
enum
{
NotFound
=
uint32_t
(
-
1
)
}
;
static
uint32_t
Find
(
Document
*
aRoot
)
;
static
bool
Contains
(
Document
*
aRoot
)
;
static
FullscreenRoots
*
sInstance
;
nsTArray
<
nsWeakPtr
>
mRoots
;
}
;
FullscreenRoots
*
FullscreenRoots
:
:
sInstance
=
nullptr
;
void
FullscreenRoots
:
:
ForEach
(
void
(
*
aFunction
)
(
Document
*
aDoc
)
)
{
if
(
!
sInstance
)
{
return
;
}
nsTArray
<
nsWeakPtr
>
roots
(
sInstance
-
>
mRoots
)
;
for
(
uint32_t
i
=
0
;
i
<
roots
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
Document
>
root
=
do_QueryReferent
(
roots
[
i
]
)
;
if
(
root
&
&
FullscreenRoots
:
:
Contains
(
root
)
)
{
aFunction
(
root
)
;
}
}
}
bool
FullscreenRoots
:
:
Contains
(
Document
*
aRoot
)
{
return
FullscreenRoots
:
:
Find
(
aRoot
)
!
=
NotFound
;
}
void
FullscreenRoots
:
:
Add
(
Document
*
aDoc
)
{
nsCOMPtr
<
Document
>
root
=
nsContentUtils
:
:
GetRootDocument
(
aDoc
)
;
if
(
!
FullscreenRoots
:
:
Contains
(
root
)
)
{
if
(
!
sInstance
)
{
sInstance
=
new
FullscreenRoots
(
)
;
}
sInstance
-
>
mRoots
.
AppendElement
(
do_GetWeakReference
(
root
)
)
;
}
}
uint32_t
FullscreenRoots
:
:
Find
(
Document
*
aRoot
)
{
if
(
!
sInstance
)
{
return
NotFound
;
}
nsTArray
<
nsWeakPtr
>
&
roots
=
sInstance
-
>
mRoots
;
for
(
uint32_t
i
=
0
;
i
<
roots
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
Document
>
otherRoot
(
do_QueryReferent
(
roots
[
i
]
)
)
;
if
(
otherRoot
=
=
aRoot
)
{
return
i
;
}
}
return
NotFound
;
}
void
FullscreenRoots
:
:
Remove
(
Document
*
aDoc
)
{
nsCOMPtr
<
Document
>
root
=
nsContentUtils
:
:
GetRootDocument
(
aDoc
)
;
uint32_t
index
=
Find
(
root
)
;
NS_ASSERTION
(
index
!
=
NotFound
"
Should
only
try
to
remove
roots
which
are
still
added
!
"
)
;
if
(
index
=
=
NotFound
|
|
!
sInstance
)
{
return
;
}
sInstance
-
>
mRoots
.
RemoveElementAt
(
index
)
;
if
(
sInstance
-
>
mRoots
.
IsEmpty
(
)
)
{
delete
sInstance
;
sInstance
=
nullptr
;
}
}
bool
FullscreenRoots
:
:
IsEmpty
(
)
{
return
!
sInstance
;
}
class
PendingFullscreenChangeList
{
public
:
PendingFullscreenChangeList
(
)
=
delete
;
template
<
typename
T
>
static
void
Add
(
UniquePtr
<
T
>
aChange
)
{
sList
.
insertBack
(
aChange
.
release
(
)
)
;
}
static
const
FullscreenChange
*
GetLast
(
)
{
return
sList
.
getLast
(
)
;
}
enum
IteratorOption
{
eDocumentsWithSameRoot
eInclusiveDescendants
}
;
template
<
typename
T
>
class
Iterator
{
public
:
explicit
Iterator
(
Document
*
aDoc
IteratorOption
aOption
)
:
mCurrent
(
PendingFullscreenChangeList
:
:
sList
.
getFirst
(
)
)
mRootShellForIteration
(
aDoc
-
>
GetDocShell
(
)
)
{
if
(
mCurrent
)
{
if
(
mRootShellForIteration
&
&
aOption
=
=
eDocumentsWithSameRoot
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
mRootShellForIteration
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
mRootShellForIteration
=
root
.
forget
(
)
;
}
SkipToNextMatch
(
)
;
}
}
UniquePtr
<
T
>
TakeAndNext
(
)
{
auto
thisChange
=
TakeAndNextInternal
(
)
;
SkipToNextMatch
(
)
;
return
thisChange
;
}
bool
AtEnd
(
)
const
{
return
mCurrent
=
=
nullptr
;
}
private
:
UniquePtr
<
T
>
TakeAndNextInternal
(
)
{
FullscreenChange
*
thisChange
=
mCurrent
;
MOZ_ASSERT
(
thisChange
-
>
Type
(
)
=
=
T
:
:
kType
)
;
mCurrent
=
mCurrent
-
>
removeAndGetNext
(
)
;
return
WrapUnique
(
static_cast
<
T
*
>
(
thisChange
)
)
;
}
void
SkipToNextMatch
(
)
{
while
(
mCurrent
)
{
if
(
mCurrent
-
>
Type
(
)
=
=
T
:
:
kType
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShell
=
mCurrent
-
>
Document
(
)
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
UniquePtr
<
T
>
change
=
TakeAndNextInternal
(
)
;
change
-
>
MayRejectPromise
(
)
;
continue
;
}
while
(
docShell
&
&
docShell
!
=
mRootShellForIteration
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
docShell
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
;
docShell
=
parent
.
forget
(
)
;
}
if
(
docShell
)
{
break
;
}
}
mCurrent
=
mCurrent
-
>
getNext
(
)
;
}
}
FullscreenChange
*
mCurrent
;
nsCOMPtr
<
nsIDocShellTreeItem
>
mRootShellForIteration
;
}
;
private
:
static
LinkedList
<
FullscreenChange
>
sList
;
}
;
LinkedList
<
FullscreenChange
>
PendingFullscreenChangeList
:
:
sList
;
Document
*
Document
:
:
GetFullscreenRoot
(
)
{
nsCOMPtr
<
Document
>
root
=
do_QueryReferent
(
mFullscreenRoot
)
;
return
root
;
}
void
Document
:
:
SetFullscreenRoot
(
Document
*
aRoot
)
{
mFullscreenRoot
=
do_GetWeakReference
(
aRoot
)
;
}
already_AddRefed
<
Promise
>
Document
:
:
ExitFullscreen
(
ErrorResult
&
aRv
)
{
UniquePtr
<
FullscreenExit
>
exit
=
FullscreenExit
:
:
Create
(
this
aRv
)
;
RefPtr
<
Promise
>
promise
=
exit
-
>
GetPromise
(
)
;
RestorePreviousFullscreenState
(
std
:
:
move
(
exit
)
)
;
return
promise
.
forget
(
)
;
}
static
void
AskWindowToExitFullscreen
(
Document
*
aDoc
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
aDoc
ToSupports
(
aDoc
)
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
Exit
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
}
else
{
if
(
nsPIDOMWindowOuter
*
win
=
aDoc
-
>
GetWindow
(
)
)
{
win
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenAPI
false
)
;
}
}
}
class
nsCallExitFullscreen
:
public
Runnable
{
public
:
explicit
nsCallExitFullscreen
(
Document
*
aDoc
)
:
mozilla
:
:
Runnable
(
"
nsCallExitFullscreen
"
)
mDoc
(
aDoc
)
{
}
NS_IMETHOD
Run
(
)
final
{
if
(
!
mDoc
)
{
FullscreenRoots
:
:
ForEach
(
&
AskWindowToExitFullscreen
)
;
}
else
{
AskWindowToExitFullscreen
(
mDoc
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
Document
>
mDoc
;
}
;
void
Document
:
:
AsyncExitFullscreen
(
Document
*
aDoc
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
exit
=
new
nsCallExitFullscreen
(
aDoc
)
;
if
(
aDoc
)
{
aDoc
-
>
Dispatch
(
TaskCategory
:
:
Other
exit
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
exit
.
forget
(
)
)
;
}
}
static
bool
CountFullscreenSubDocuments
(
Document
*
aDoc
void
*
aData
)
{
if
(
aDoc
-
>
FullscreenStackTop
(
)
)
{
uint32_t
*
count
=
static_cast
<
uint32_t
*
>
(
aData
)
;
(
*
count
)
+
+
;
}
return
true
;
}
static
uint32_t
CountFullscreenSubDocuments
(
Document
*
aDoc
)
{
uint32_t
count
=
0
;
aDoc
-
>
EnumerateSubDocuments
(
CountFullscreenSubDocuments
&
count
)
;
return
count
;
}
bool
Document
:
:
IsFullscreenLeaf
(
)
{
if
(
!
FullscreenStackTop
(
)
)
{
return
false
;
}
return
CountFullscreenSubDocuments
(
this
)
=
=
0
;
}
bool
GetFullscreenLeaf
(
Document
*
aDoc
void
*
aData
)
{
if
(
aDoc
-
>
IsFullscreenLeaf
(
)
)
{
Document
*
*
result
=
static_cast
<
Document
*
*
>
(
aData
)
;
*
result
=
aDoc
;
return
false
;
}
if
(
aDoc
-
>
FullscreenStackTop
(
)
)
{
aDoc
-
>
EnumerateSubDocuments
(
GetFullscreenLeaf
aData
)
;
}
return
true
;
}
static
Document
*
GetFullscreenLeaf
(
Document
*
aDoc
)
{
Document
*
leaf
=
nullptr
;
GetFullscreenLeaf
(
aDoc
&
leaf
)
;
if
(
leaf
)
{
return
leaf
;
}
Document
*
root
=
nsContentUtils
:
:
GetRootDocument
(
aDoc
)
;
if
(
!
root
-
>
FullscreenStackTop
(
)
)
{
return
nullptr
;
}
GetFullscreenLeaf
(
root
&
leaf
)
;
return
leaf
;
}
static
bool
ResetFullscreen
(
Document
*
aDocument
void
*
aData
)
{
if
(
Element
*
fsElement
=
aDocument
-
>
FullscreenStackTop
(
)
)
{
NS_ASSERTION
(
CountFullscreenSubDocuments
(
aDocument
)
<
=
1
"
Should
have
at
most
1
fullscreen
subdocument
.
"
)
;
aDocument
-
>
CleanupFullscreenState
(
)
;
NS_ASSERTION
(
!
aDocument
-
>
FullscreenStackTop
(
)
"
Should
reset
fullscreen
"
)
;
DispatchFullscreenChange
(
aDocument
fsElement
)
;
aDocument
-
>
EnumerateSubDocuments
(
ResetFullscreen
nullptr
)
;
}
return
true
;
}
class
ExitFullscreenScriptRunnable
:
public
Runnable
{
public
:
explicit
ExitFullscreenScriptRunnable
(
Document
*
aRoot
Document
*
aLeaf
)
:
mozilla
:
:
Runnable
(
"
ExitFullscreenScriptRunnable
"
)
mRoot
(
aRoot
)
mLeaf
(
aLeaf
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
mLeaf
ToSupports
(
mLeaf
)
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
Exited
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
if
(
nsPIDOMWindowOuter
*
win
=
mRoot
-
>
GetWindow
(
)
)
{
win
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForForceExitFullscreen
false
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
Document
>
mRoot
;
nsCOMPtr
<
Document
>
mLeaf
;
}
;
void
Document
:
:
ExitFullscreenInDocTree
(
Document
*
aMaybeNotARootDoc
)
{
MOZ_ASSERT
(
aMaybeNotARootDoc
)
;
UnlockPointer
(
)
;
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenExit
>
iter
(
aMaybeNotARootDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
UniquePtr
<
FullscreenExit
>
exit
=
iter
.
TakeAndNext
(
)
;
exit
-
>
MayResolvePromise
(
)
;
}
nsCOMPtr
<
Document
>
root
=
aMaybeNotARootDoc
-
>
GetFullscreenRoot
(
)
;
if
(
!
root
|
|
!
root
-
>
FullscreenStackTop
(
)
)
{
return
;
}
Document
*
fullscreenLeaf
=
GetFullscreenLeaf
(
root
)
;
ResetFullscreen
(
root
nullptr
)
;
NS_ASSERTION
(
!
root
-
>
FullscreenStackTop
(
)
"
Fullscreen
root
should
no
longer
be
a
fullscreen
doc
.
.
.
"
)
;
FullscreenRoots
:
:
Remove
(
root
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
ExitFullscreenScriptRunnable
(
root
fullscreenLeaf
)
)
;
}
static
void
DispatchFullscreenNewOriginEvent
(
Document
*
aDoc
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
aDoc
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
NewOrigin
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
void
Document
:
:
RestorePreviousFullscreenState
(
UniquePtr
<
FullscreenExit
>
aExit
)
{
NS_ASSERTION
(
!
FullscreenStackTop
(
)
|
|
!
FullscreenRoots
:
:
IsEmpty
(
)
"
Should
have
at
least
1
fullscreen
root
when
fullscreen
!
"
)
;
if
(
!
FullscreenStackTop
(
)
|
|
!
GetWindow
(
)
|
|
FullscreenRoots
:
:
IsEmpty
(
)
)
{
aExit
-
>
MayRejectPromise
(
)
;
return
;
}
nsCOMPtr
<
Document
>
fullScreenDoc
=
GetFullscreenLeaf
(
this
)
;
AutoTArray
<
Element
*
8
>
exitElements
;
Document
*
doc
=
fullScreenDoc
;
for
(
;
doc
!
=
this
;
doc
=
doc
-
>
GetParentDocument
(
)
)
{
Element
*
fsElement
=
doc
-
>
FullscreenStackTop
(
)
;
MOZ_ASSERT
(
fsElement
"
Parent
document
of
"
"
a
fullscreen
document
without
fullscreen
element
?
"
)
;
exitElements
.
AppendElement
(
fsElement
)
;
}
MOZ_ASSERT
(
doc
=
=
this
"
Must
have
reached
this
doc
"
)
;
for
(
;
doc
;
doc
=
doc
-
>
GetParentDocument
(
)
)
{
MOZ_ASSERT
(
!
doc
-
>
mFullscreenStack
.
IsEmpty
(
)
"
Ancestor
of
fullscreen
document
must
also
be
in
fullscreen
"
)
;
Element
*
fsElement
=
doc
-
>
FullscreenStackTop
(
)
;
if
(
doc
!
=
this
)
{
if
(
auto
*
iframe
=
HTMLIFrameElement
:
:
FromNode
(
fsElement
)
)
{
if
(
iframe
-
>
FullscreenFlag
(
)
)
{
break
;
}
}
}
exitElements
.
AppendElement
(
fsElement
)
;
if
(
doc
-
>
mFullscreenStack
.
Length
(
)
>
1
)
{
break
;
}
}
Document
*
lastDoc
=
exitElements
.
LastElement
(
)
-
>
OwnerDoc
(
)
;
if
(
!
lastDoc
-
>
GetParentDocument
(
)
&
&
lastDoc
-
>
mFullscreenStack
.
Length
(
)
=
=
1
)
{
PendingFullscreenChangeList
:
:
Add
(
std
:
:
move
(
aExit
)
)
;
AskWindowToExitFullscreen
(
this
)
;
return
;
}
UnlockPointer
(
)
;
for
(
auto
i
:
IntegerRange
(
exitElements
.
Length
(
)
-
1
)
)
{
exitElements
[
i
]
-
>
OwnerDoc
(
)
-
>
CleanupFullscreenState
(
)
;
}
Document
*
newFullscreenDoc
;
if
(
lastDoc
-
>
mFullscreenStack
.
Length
(
)
>
1
)
{
lastDoc
-
>
FullscreenStackPop
(
)
;
newFullscreenDoc
=
lastDoc
;
}
else
{
lastDoc
-
>
CleanupFullscreenState
(
)
;
newFullscreenDoc
=
lastDoc
-
>
GetParentDocument
(
)
;
}
for
(
Element
*
e
:
Reversed
(
exitElements
)
)
{
DispatchFullscreenChange
(
e
-
>
OwnerDoc
(
)
e
)
;
}
aExit
-
>
MayResolvePromise
(
)
;
MOZ_ASSERT
(
newFullscreenDoc
"
If
we
were
going
to
exit
from
fullscreen
on
"
"
all
documents
in
this
doctree
we
should
'
ve
asked
the
window
to
"
"
exit
first
instead
of
reaching
here
.
"
)
;
if
(
fullScreenDoc
!
=
newFullscreenDoc
&
&
!
nsContentUtils
:
:
HaveEqualPrincipals
(
fullScreenDoc
newFullscreenDoc
)
)
{
DispatchFullscreenNewOriginEvent
(
newFullscreenDoc
)
;
}
}
class
nsCallRequestFullscreen
:
public
Runnable
{
public
:
explicit
nsCallRequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
)
:
mozilla
:
:
Runnable
(
"
nsCallRequestFullscreen
"
)
mRequest
(
std
:
:
move
(
aRequest
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
Document
*
doc
=
mRequest
-
>
Document
(
)
;
doc
-
>
RequestFullscreen
(
std
:
:
move
(
mRequest
)
)
;
return
NS_OK
;
}
UniquePtr
<
FullscreenRequest
>
mRequest
;
}
;
void
Document
:
:
AsyncRequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsCallRequestFullscreen
(
std
:
:
move
(
aRequest
)
)
;
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
static
void
UpdateViewportScrollbarOverrideForFullscreen
(
Document
*
aDoc
)
{
if
(
nsPresContext
*
presContext
=
aDoc
-
>
GetPresContext
(
)
)
{
presContext
-
>
UpdateViewportScrollStylesOverride
(
)
;
}
}
static
void
ClearFullscreenStateOnElement
(
Element
*
aElement
)
{
EventStateManager
:
:
SetFullscreenState
(
aElement
false
)
;
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
)
{
static_cast
<
HTMLIFrameElement
*
>
(
aElement
)
-
>
SetFullscreenFlag
(
false
)
;
}
}
void
Document
:
:
CleanupFullscreenState
(
)
{
for
(
nsWeakPtr
&
weakPtr
:
Reversed
(
mFullscreenStack
)
)
{
if
(
nsCOMPtr
<
Element
>
element
=
do_QueryReferent
(
weakPtr
)
)
{
ClearFullscreenStateOnElement
(
element
)
;
}
}
mFullscreenStack
.
Clear
(
)
;
mFullscreenRoot
=
nullptr
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
if
(
presShell
-
>
GetMobileViewportManager
(
)
)
{
presShell
-
>
SetResolutionAndScaleTo
(
mSavedResolution
ResolutionChangeOrigin
:
:
MainThread
)
;
}
}
UpdateViewportScrollbarOverrideForFullscreen
(
this
)
;
}
bool
Document
:
:
FullscreenStackPush
(
Element
*
aElement
)
{
NS_ASSERTION
(
aElement
"
Must
pass
non
-
null
to
FullscreenStackPush
(
)
"
)
;
Element
*
top
=
FullscreenStackTop
(
)
;
if
(
top
=
=
aElement
|
|
!
aElement
)
{
return
false
;
}
EventStateManager
:
:
SetFullscreenState
(
aElement
true
)
;
mFullscreenStack
.
AppendElement
(
do_GetWeakReference
(
aElement
)
)
;
NS_ASSERTION
(
FullscreenStackTop
(
)
=
=
aElement
"
Should
match
"
)
;
UpdateViewportScrollbarOverrideForFullscreen
(
this
)
;
return
true
;
}
void
Document
:
:
FullscreenStackPop
(
)
{
if
(
mFullscreenStack
.
IsEmpty
(
)
)
{
return
;
}
ClearFullscreenStateOnElement
(
FullscreenStackTop
(
)
)
;
uint32_t
last
=
mFullscreenStack
.
Length
(
)
-
1
;
mFullscreenStack
.
RemoveElementAt
(
last
)
;
while
(
!
mFullscreenStack
.
IsEmpty
(
)
)
{
Element
*
element
=
FullscreenStackTop
(
)
;
if
(
!
element
|
|
!
element
-
>
IsInUncomposedDoc
(
)
|
|
element
-
>
OwnerDoc
(
)
!
=
this
)
{
NS_ASSERTION
(
!
element
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FULLSCREEN
)
"
Should
have
already
removed
fullscreen
styles
"
)
;
uint32_t
last
=
mFullscreenStack
.
Length
(
)
-
1
;
mFullscreenStack
.
RemoveElementAt
(
last
)
;
}
else
{
break
;
}
}
UpdateViewportScrollbarOverrideForFullscreen
(
this
)
;
}
Element
*
Document
:
:
FullscreenStackTop
(
)
{
if
(
mFullscreenStack
.
IsEmpty
(
)
)
{
return
nullptr
;
}
uint32_t
last
=
mFullscreenStack
.
Length
(
)
-
1
;
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
mFullscreenStack
[
last
]
)
)
;
NS_ASSERTION
(
element
"
Should
have
fullscreen
element
!
"
)
;
NS_ASSERTION
(
element
-
>
IsInComposedDoc
(
)
"
Fullscreen
element
should
be
in
doc
"
)
;
NS_ASSERTION
(
element
-
>
OwnerDoc
(
)
=
=
this
"
Fullscreen
element
should
be
in
this
doc
"
)
;
return
element
;
}
nsTArray
<
Element
*
>
Document
:
:
GetFullscreenStack
(
)
const
{
nsTArray
<
Element
*
>
elements
;
for
(
const
nsWeakPtr
&
ptr
:
mFullscreenStack
)
{
if
(
nsCOMPtr
<
Element
>
elem
=
do_QueryReferent
(
ptr
)
)
{
MOZ_ASSERT
(
elem
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FULLSCREEN
)
)
;
elements
.
AppendElement
(
elem
)
;
}
}
return
elements
;
}
static
bool
IsInActiveTab
(
Document
*
aDoc
)
{
nsCOMPtr
<
nsIDocShell
>
docshell
=
aDoc
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
false
;
}
bool
isActive
=
false
;
docshell
-
>
GetIsActive
(
&
isActive
)
;
if
(
!
isActive
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
docshell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
!
rootItem
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
-
>
GetWindow
(
)
;
if
(
!
rootWin
)
{
return
false
;
}
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
return
false
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
activeWindow
;
fm
-
>
GetActiveWindow
(
getter_AddRefs
(
activeWindow
)
)
;
if
(
!
activeWindow
)
{
return
false
;
}
return
activeWindow
=
=
rootWin
;
}
nsresult
Document
:
:
RemoteFrameFullscreenChanged
(
Element
*
aFrameElement
)
{
auto
request
=
FullscreenRequest
:
:
CreateForRemote
(
aFrameElement
)
;
RequestFullscreen
(
std
:
:
move
(
request
)
)
;
return
NS_OK
;
}
nsresult
Document
:
:
RemoteFrameFullscreenReverted
(
)
{
UniquePtr
<
FullscreenExit
>
exit
=
FullscreenExit
:
:
CreateForRemote
(
this
)
;
RestorePreviousFullscreenState
(
std
:
:
move
(
exit
)
)
;
return
NS_OK
;
}
bool
Document
:
:
IsUnprefixedFullscreenEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
full_screen_api_unprefix_enabled
(
)
;
}
static
bool
HasFullscreenSubDocument
(
Document
*
aDoc
)
{
uint32_t
count
=
CountFullscreenSubDocuments
(
aDoc
)
;
NS_ASSERTION
(
count
<
=
1
"
Fullscreen
docs
should
have
at
most
1
fullscreen
child
!
"
)
;
return
count
>
=
1
;
}
static
const
char
*
GetFullscreenError
(
Document
*
aDoc
CallerType
aCallerType
)
{
bool
apiEnabled
=
StaticPrefs
:
:
full_screen_api_enabled
(
)
;
if
(
apiEnabled
&
&
aCallerType
=
=
CallerType
:
:
System
)
{
return
nullptr
;
}
if
(
!
apiEnabled
)
{
return
"
FullscreenDeniedDisabled
"
;
}
if
(
!
aDoc
-
>
IsVisible
(
)
)
{
return
"
FullscreenDeniedHidden
"
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
aDoc
-
>
GetDocShell
(
)
)
;
if
(
!
docShell
|
|
!
docShell
-
>
GetFullscreenAllowed
(
)
)
{
return
"
FullscreenDeniedContainerNotAllowed
"
;
}
return
nullptr
;
}
bool
Document
:
:
FullscreenElementReadyCheck
(
const
FullscreenRequest
&
aRequest
)
{
Element
*
elem
=
aRequest
.
Element
(
)
;
if
(
elem
=
=
FullscreenStackTop
(
)
)
{
aRequest
.
MayResolvePromise
(
)
;
return
false
;
}
if
(
!
elem
-
>
IsInComposedDoc
(
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedNotInDocument
"
)
;
return
false
;
}
if
(
elem
-
>
OwnerDoc
(
)
!
=
this
)
{
aRequest
.
Reject
(
"
FullscreenDeniedMovedDocument
"
)
;
return
false
;
}
if
(
!
GetWindow
(
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedLostWindow
"
)
;
return
false
;
}
if
(
const
char
*
msg
=
GetFullscreenError
(
this
aRequest
.
mCallerType
)
)
{
aRequest
.
Reject
(
msg
)
;
return
false
;
}
if
(
HasFullscreenSubDocument
(
this
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedSubDocFullScreen
"
)
;
return
false
;
}
if
(
FullscreenStackTop
(
)
&
&
!
nsContentUtils
:
:
ContentIsHostIncludingDescendantOf
(
elem
FullscreenStackTop
(
)
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedNotDescendant
"
)
;
return
false
;
}
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
&
&
!
IsInActiveTab
(
this
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedNotFocusedTab
"
)
;
return
false
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
NS_WARNING
(
"
Failed
to
retrieve
focus
manager
in
fullscreen
request
.
"
)
;
aRequest
.
MayRejectPromise
(
)
;
return
false
;
}
if
(
nsContentUtils
:
:
HasPluginWithUncontrolledEventDispatch
(
fm
-
>
GetFocusedElement
(
)
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedFocusedPlugin
"
)
;
return
false
;
}
return
true
;
}
static
nsCOMPtr
<
nsPIDOMWindowOuter
>
GetRootWindow
(
Document
*
aDoc
)
{
nsIDocShell
*
docShell
=
aDoc
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
docShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
return
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
}
static
bool
ShouldApplyFullscreenDirectly
(
Document
*
aDoc
nsPIDOMWindowOuter
*
aRootWin
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
return
!
!
nsContentUtils
:
:
GetRootDocument
(
aDoc
)
-
>
GetFullscreenElement
(
)
;
}
else
{
if
(
!
aRootWin
-
>
GetFullScreen
(
)
)
{
return
false
;
}
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
aDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
if
(
!
iter
.
AtEnd
(
)
)
{
return
false
;
}
return
true
;
}
}
void
Document
:
:
RequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
GetRootWindow
(
this
)
;
if
(
!
rootWin
)
{
aRequest
-
>
MayRejectPromise
(
)
;
return
;
}
if
(
ShouldApplyFullscreenDirectly
(
this
rootWin
)
)
{
ApplyFullscreen
(
std
:
:
move
(
aRequest
)
)
;
return
;
}
Element
*
elem
=
aRequest
-
>
Element
(
)
;
if
(
!
elem
-
>
IsHTMLElement
(
)
&
&
!
elem
-
>
IsXULElement
(
)
&
&
!
elem
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
&
&
!
elem
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
)
{
aRequest
-
>
Reject
(
"
FullscreenDeniedNotHTMLSVGOrMathML
"
)
;
return
;
}
if
(
!
FullscreenElementReadyCheck
(
*
aRequest
)
)
{
return
;
}
PendingFullscreenChangeList
:
:
Add
(
std
:
:
move
(
aRequest
)
)
;
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
this
ToSupports
(
this
)
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
Request
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
}
else
{
rootWin
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenAPI
true
)
;
}
}
bool
Document
:
:
HandlePendingFullscreenRequests
(
Document
*
aDoc
)
{
bool
handled
=
false
;
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
aDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
UniquePtr
<
FullscreenRequest
>
request
=
iter
.
TakeAndNext
(
)
;
Document
*
doc
=
request
-
>
Document
(
)
;
if
(
doc
-
>
ApplyFullscreen
(
std
:
:
move
(
request
)
)
)
{
handled
=
true
;
}
}
return
handled
;
}
static
void
ClearPendingFullscreenRequests
(
Document
*
aDoc
)
{
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
aDoc
PendingFullscreenChangeList
:
:
eInclusiveDescendants
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
UniquePtr
<
FullscreenRequest
>
request
=
iter
.
TakeAndNext
(
)
;
request
-
>
MayRejectPromise
(
)
;
}
}
bool
Document
:
:
ApplyFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
)
{
if
(
!
FullscreenElementReadyCheck
(
*
aRequest
)
)
{
return
false
;
}
nsCOMPtr
<
Document
>
previousFullscreenDoc
=
GetFullscreenLeaf
(
this
)
;
AutoTArray
<
Document
*
8
>
changed
;
Document
*
fullScreenRootDoc
=
nsContentUtils
:
:
GetRootDocument
(
this
)
;
UnlockPointer
(
)
;
Element
*
elem
=
aRequest
-
>
Element
(
)
;
DebugOnly
<
bool
>
x
=
FullscreenStackPush
(
elem
)
;
NS_ASSERTION
(
x
"
Fullscreen
state
of
requesting
doc
should
always
change
!
"
)
;
if
(
auto
*
iframe
=
HTMLIFrameElement
:
:
FromNode
(
elem
)
)
{
iframe
-
>
SetFullscreenFlag
(
true
)
;
}
changed
.
AppendElement
(
this
)
;
Document
*
child
=
this
;
while
(
true
)
{
child
-
>
SetFullscreenRoot
(
fullScreenRootDoc
)
;
if
(
PresShell
*
presShell
=
child
-
>
GetPresShell
(
)
)
{
if
(
RefPtr
<
MobileViewportManager
>
manager
=
presShell
-
>
GetMobileViewportManager
(
)
)
{
child
-
>
mSavedResolution
=
presShell
-
>
GetResolution
(
)
;
presShell
-
>
SetResolutionAndScaleTo
(
manager
-
>
ComputeIntrinsicResolution
(
)
ResolutionChangeOrigin
:
:
MainThread
)
;
}
}
NS_ASSERTION
(
child
-
>
GetFullscreenRoot
(
)
=
=
fullScreenRootDoc
"
Fullscreen
root
should
be
set
!
"
)
;
if
(
child
=
=
fullScreenRootDoc
)
{
break
;
}
Document
*
parent
=
child
-
>
GetParentDocument
(
)
;
Element
*
element
=
parent
-
>
FindContentForSubDocument
(
child
)
;
if
(
parent
-
>
FullscreenStackPush
(
element
)
)
{
changed
.
AppendElement
(
parent
)
;
child
=
parent
;
}
else
{
break
;
}
}
FullscreenRoots
:
:
Add
(
this
)
;
if
(
!
previousFullscreenDoc
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
this
ToSupports
(
elem
)
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
Entered
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
}
if
(
aRequest
-
>
mShouldNotifyNewOrigin
&
&
!
nsContentUtils
:
:
HaveEqualPrincipals
(
previousFullscreenDoc
this
)
)
{
DispatchFullscreenNewOriginEvent
(
this
)
;
}
for
(
Document
*
d
:
Reversed
(
changed
)
)
{
DispatchFullscreenChange
(
d
d
-
>
FullscreenStackTop
(
)
)
;
}
aRequest
-
>
MayResolvePromise
(
)
;
return
true
;
}
bool
Document
:
:
FullscreenEnabled
(
CallerType
aCallerType
)
{
return
!
GetFullscreenError
(
this
aCallerType
)
;
}
void
Document
:
:
SetOrientationPendingPromise
(
Promise
*
aPromise
)
{
mOrientationPendingPromise
=
aPromise
;
}
static
void
DispatchPointerLockChange
(
Document
*
aTarget
)
{
if
(
!
aTarget
)
{
return
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
aTarget
NS_LITERAL_STRING
(
"
pointerlockchange
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
static
void
DispatchPointerLockError
(
Document
*
aTarget
const
char
*
aMessage
)
{
if
(
!
aTarget
)
{
return
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
aTarget
NS_LITERAL_STRING
(
"
pointerlockerror
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
aTarget
nsContentUtils
:
:
eDOM_PROPERTIES
aMessage
)
;
}
class
PointerLockRequest
final
:
public
Runnable
{
public
:
PointerLockRequest
(
Element
*
aElement
bool
aUserInputOrChromeCaller
)
:
mozilla
:
:
Runnable
(
"
PointerLockRequest
"
)
mElement
(
do_GetWeakReference
(
aElement
)
)
mDocument
(
do_GetWeakReference
(
aElement
-
>
OwnerDoc
(
)
)
)
mUserInputOrChromeCaller
(
aUserInputOrChromeCaller
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
final
;
private
:
nsWeakPtr
mElement
;
nsWeakPtr
mDocument
;
bool
mUserInputOrChromeCaller
;
}
;
static
const
char
*
GetPointerLockError
(
Element
*
aElement
Element
*
aCurrentLock
bool
aNoFocusCheck
=
false
)
{
if
(
!
Preferences
:
:
GetBool
(
"
full
-
screen
-
api
.
pointer
-
lock
.
enabled
"
)
)
{
return
"
PointerLockDeniedDisabled
"
;
}
nsCOMPtr
<
Document
>
ownerDoc
=
aElement
-
>
OwnerDoc
(
)
;
if
(
aCurrentLock
&
&
aCurrentLock
-
>
OwnerDoc
(
)
!
=
ownerDoc
)
{
return
"
PointerLockDeniedInUse
"
;
}
if
(
!
aElement
-
>
IsInComposedDoc
(
)
)
{
return
"
PointerLockDeniedNotInDocument
"
;
}
if
(
ownerDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_POINTER_LOCK
)
{
return
"
PointerLockDeniedSandboxed
"
;
}
if
(
!
ownerDoc
-
>
GetContainer
(
)
)
{
return
"
PointerLockDeniedHidden
"
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
ownerWindow
=
ownerDoc
-
>
GetWindow
(
)
;
if
(
!
ownerWindow
)
{
return
"
PointerLockDeniedHidden
"
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
ownerInnerWindow
=
ownerDoc
-
>
GetInnerWindow
(
)
;
if
(
!
ownerInnerWindow
)
{
return
"
PointerLockDeniedHidden
"
;
}
if
(
ownerWindow
-
>
GetCurrentInnerWindow
(
)
!
=
ownerInnerWindow
)
{
return
"
PointerLockDeniedHidden
"
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
ownerWindow
-
>
GetScriptableTop
(
)
;
if
(
!
top
|
|
!
top
-
>
GetExtantDoc
(
)
|
|
top
-
>
GetExtantDoc
(
)
-
>
Hidden
(
)
)
{
return
"
PointerLockDeniedHidden
"
;
}
if
(
!
aNoFocusCheck
)
{
mozilla
:
:
ErrorResult
rv
;
if
(
!
top
-
>
GetExtantDoc
(
)
-
>
HasFocus
(
rv
)
)
{
return
"
PointerLockDeniedNotFocused
"
;
}
}
return
nullptr
;
}
static
void
ChangePointerLockedElement
(
Element
*
aElement
Document
*
aDocument
Element
*
aPointerLockedElement
)
{
MOZ_ASSERT
(
aDocument
)
;
MOZ_ASSERT
(
aElement
!
=
aPointerLockedElement
)
;
if
(
aPointerLockedElement
)
{
MOZ_ASSERT
(
aPointerLockedElement
-
>
GetComposedDoc
(
)
=
=
aDocument
)
;
aPointerLockedElement
-
>
ClearPointerLock
(
)
;
}
if
(
aElement
)
{
MOZ_ASSERT
(
aElement
-
>
GetComposedDoc
(
)
=
=
aDocument
)
;
aElement
-
>
SetPointerLock
(
)
;
EventStateManager
:
:
sPointerLockedElement
=
do_GetWeakReference
(
aElement
)
;
EventStateManager
:
:
sPointerLockedDoc
=
do_GetWeakReference
(
aDocument
)
;
NS_ASSERTION
(
EventStateManager
:
:
sPointerLockedElement
&
&
EventStateManager
:
:
sPointerLockedDoc
"
aElement
and
this
should
support
weak
references
!
"
)
;
}
else
{
EventStateManager
:
:
sPointerLockedElement
=
nullptr
;
EventStateManager
:
:
sPointerLockedDoc
=
nullptr
;
}
PresShell
:
:
SetCapturingContent
(
aElement
CaptureFlags
:
:
PointerLock
)
;
DispatchPointerLockChange
(
aDocument
)
;
}
NS_IMETHODIMP
PointerLockRequest
:
:
Run
(
)
{
nsCOMPtr
<
Element
>
e
=
do_QueryReferent
(
mElement
)
;
nsCOMPtr
<
Document
>
doc
=
do_QueryReferent
(
mDocument
)
;
const
char
*
error
=
nullptr
;
if
(
!
e
|
|
!
doc
|
|
!
e
-
>
GetComposedDoc
(
)
)
{
error
=
"
PointerLockDeniedNotInDocument
"
;
}
else
if
(
e
-
>
GetComposedDoc
(
)
!
=
doc
)
{
error
=
"
PointerLockDeniedMovedDocument
"
;
}
if
(
!
error
)
{
nsCOMPtr
<
Element
>
pointerLockedElement
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedElement
)
;
if
(
e
=
=
pointerLockedElement
)
{
DispatchPointerLockChange
(
doc
)
;
return
NS_OK
;
}
error
=
GetPointerLockError
(
e
pointerLockedElement
true
)
;
if
(
!
error
&
&
pointerLockedElement
)
{
ChangePointerLockedElement
(
e
doc
pointerLockedElement
)
;
return
NS_OK
;
}
}
if
(
!
error
&
&
!
mUserInputOrChromeCaller
&
&
!
doc
-
>
GetFullscreenElement
(
)
)
{
error
=
"
PointerLockDeniedNotInputDriven
"
;
}
if
(
!
error
&
&
!
doc
-
>
SetPointerLock
(
e
StyleCursorKind
:
:
None
)
)
{
error
=
"
PointerLockDeniedFailedToLock
"
;
}
if
(
error
)
{
DispatchPointerLockError
(
doc
error
)
;
return
NS_OK
;
}
ChangePointerLockedElement
(
e
doc
nullptr
)
;
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
doc
ToSupports
(
e
)
NS_LITERAL_STRING
(
"
MozDOMPointerLock
:
Entered
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
return
NS_OK
;
}
void
Document
:
:
RequestPointerLock
(
Element
*
aElement
CallerType
aCallerType
)
{
NS_ASSERTION
(
aElement
"
Must
pass
non
-
null
element
to
Document
:
:
RequestPointerLock
"
)
;
nsCOMPtr
<
Element
>
pointerLockedElement
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedElement
)
;
if
(
aElement
=
=
pointerLockedElement
)
{
DispatchPointerLockChange
(
this
)
;
return
;
}
if
(
const
char
*
msg
=
GetPointerLockError
(
aElement
pointerLockedElement
)
)
{
DispatchPointerLockError
(
this
msg
)
;
return
;
}
bool
userInputOrSystemCaller
=
EventStateManager
:
:
IsHandlingUserInput
(
)
|
|
aCallerType
=
=
CallerType
:
:
System
;
nsCOMPtr
<
nsIRunnable
>
request
=
new
PointerLockRequest
(
aElement
userInputOrSystemCaller
)
;
Dispatch
(
TaskCategory
:
:
Other
request
.
forget
(
)
)
;
}
bool
Document
:
:
SetPointerLock
(
Element
*
aElement
StyleCursorKind
aCursorStyle
)
{
MOZ_ASSERT
(
!
aElement
|
|
aElement
-
>
OwnerDoc
(
)
=
=
this
"
We
should
be
either
unlocking
pointer
(
aElement
is
nullptr
)
"
"
or
locking
pointer
to
an
element
in
this
document
"
)
;
#
ifdef
DEBUG
if
(
!
aElement
)
{
nsCOMPtr
<
Document
>
pointerLockedDoc
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedDoc
)
;
MOZ_ASSERT
(
pointerLockedDoc
=
=
this
)
;
}
#
endif
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
NS_WARNING
(
"
SetPointerLock
(
)
:
No
PresShell
"
)
;
if
(
!
aElement
)
{
EventStateManager
:
:
SetPointerLock
(
nullptr
nullptr
)
;
return
true
;
}
return
false
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
NS_WARNING
(
"
SetPointerLock
(
)
:
Unable
to
get
PresContext
"
)
;
return
false
;
}
nsCOMPtr
<
nsIWidget
>
widget
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
NS_WARN_IF
(
!
rootFrame
)
)
{
widget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_WARNING_ASSERTION
(
widget
"
SetPointerLock
(
)
:
Unable
to
find
widget
in
"
"
presShell
-
>
GetRootFrame
(
)
-
>
GetNearestWidget
(
)
;
"
)
;
if
(
aElement
&
&
!
widget
)
{
return
false
;
}
}
RefPtr
<
EventStateManager
>
esm
=
presContext
-
>
EventStateManager
(
)
;
esm
-
>
SetCursor
(
aCursorStyle
nullptr
Nothing
(
)
widget
true
)
;
EventStateManager
:
:
SetPointerLock
(
widget
aElement
)
;
return
true
;
}
void
Document
:
:
UnlockPointer
(
Document
*
aDoc
)
{
if
(
!
EventStateManager
:
:
sIsPointerLocked
)
{
return
;
}
nsCOMPtr
<
Document
>
pointerLockedDoc
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedDoc
)
;
if
(
!
pointerLockedDoc
|
|
(
aDoc
&
&
aDoc
!
=
pointerLockedDoc
)
)
{
return
;
}
if
(
!
pointerLockedDoc
-
>
SetPointerLock
(
nullptr
StyleCursorKind
:
:
Auto
)
)
{
return
;
}
nsCOMPtr
<
Element
>
pointerLockedElement
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedElement
)
;
ChangePointerLockedElement
(
nullptr
pointerLockedDoc
pointerLockedElement
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
pointerLockedElement
NS_LITERAL_STRING
(
"
MozDOMPointerLock
:
Exited
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
asyncDispatcher
-
>
RunDOMEventWhenSafe
(
)
;
}
void
Document
:
:
UpdateVisibilityState
(
)
{
dom
:
:
VisibilityState
oldState
=
mVisibilityState
;
mVisibilityState
=
ComputeVisibilityState
(
)
;
if
(
oldState
!
=
mVisibilityState
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
this
ToSupports
(
this
)
NS_LITERAL_STRING
(
"
visibilitychange
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
}
if
(
mVisibilityState
=
=
dom
:
:
VisibilityState
:
:
Visible
)
{
MaybeActiveMediaComponents
(
)
;
}
}
VisibilityState
Document
:
:
ComputeVisibilityState
(
)
const
{
if
(
!
IsVisible
(
)
|
|
!
mWindow
|
|
!
mWindow
-
>
GetOuterWindow
(
)
|
|
mWindow
-
>
GetOuterWindow
(
)
-
>
IsBackground
(
)
)
{
return
dom
:
:
VisibilityState
:
:
Hidden
;
}
return
dom
:
:
VisibilityState
:
:
Visible
;
}
void
Document
:
:
PostVisibilityUpdateEvent
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
Document
:
:
UpdateVisibilityState
"
this
&
Document
:
:
UpdateVisibilityState
)
;
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
void
Document
:
:
MaybeActiveMediaComponents
(
)
{
if
(
!
mWindow
)
{
return
;
}
GetWindow
(
)
-
>
MaybeActiveMediaComponents
(
)
;
}
void
Document
:
:
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
nsINode
:
:
AddSizeOfExcludingThis
(
aWindowSizes
&
aWindowSizes
.
mDOMOtherSize
)
;
for
(
nsIContent
*
kid
=
GetFirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
AddSizeOfNodeTree
(
*
kid
aWindowSizes
)
;
}
if
(
mPresShell
)
{
mPresShell
-
>
AddSizeOfIncludingThis
(
aWindowSizes
)
;
}
mStyleSet
-
>
AddSizeOfIncludingThis
(
aWindowSizes
)
;
aWindowSizes
.
mDOMOtherSize
+
=
mLangGroupFontPrefs
.
SizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
aWindowSizes
.
mPropertyTablesSize
+
=
mPropertyTable
.
SizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
if
(
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
)
{
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
if
(
mNodeInfoManager
)
{
mNodeInfoManager
-
>
AddSizeOfIncludingThis
(
aWindowSizes
)
;
}
aWindowSizes
.
mDOMMediaQueryLists
+
=
mDOMMediaQueryLists
.
sizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
for
(
const
MediaQueryList
*
mql
:
mDOMMediaQueryLists
)
{
aWindowSizes
.
mDOMMediaQueryLists
+
=
mql
-
>
SizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
mContentBlockingLog
.
AddSizeOfExcludingThis
(
aWindowSizes
)
;
DocumentOrShadowRoot
:
:
AddSizeOfExcludingThis
(
aWindowSizes
)
;
for
(
auto
&
sheetArray
:
mAdditionalSheets
)
{
AddSizeOfOwnedSheetArrayExcludingThis
(
aWindowSizes
sheetArray
)
;
}
aWindowSizes
.
mLayoutStyleSheetsSize
+
=
CSSLoader
(
)
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
aWindowSizes
.
mDOMOtherSize
+
=
mAttrStyleSheet
?
mAttrStyleSheet
-
>
DOMSizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
:
0
;
aWindowSizes
.
mDOMOtherSize
+
=
mStyledLinks
.
ShallowSizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
void
Document
:
:
DocAddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
aWindowSizes
.
mDOMOtherSize
+
=
aWindowSizes
.
mState
.
mMallocSizeOf
(
this
)
;
DocAddSizeOfExcludingThis
(
aWindowSizes
)
;
}
void
Document
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
MOZ_CRASH
(
)
;
}
void
Document
:
:
AddSizeOfNodeTree
(
nsINode
&
aNode
nsWindowSizes
&
aWindowSizes
)
{
size_t
nodeSize
=
0
;
aNode
.
AddSizeOfIncludingThis
(
aWindowSizes
&
nodeSize
)
;
switch
(
aNode
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
aWindowSizes
.
mDOMElementNodesSize
+
=
nodeSize
;
break
;
case
nsINode
:
:
TEXT_NODE
:
aWindowSizes
.
mDOMTextNodesSize
+
=
nodeSize
;
break
;
case
nsINode
:
:
CDATA_SECTION_NODE
:
aWindowSizes
.
mDOMCDATANodesSize
+
=
nodeSize
;
break
;
case
nsINode
:
:
COMMENT_NODE
:
aWindowSizes
.
mDOMCommentNodesSize
+
=
nodeSize
;
break
;
default
:
aWindowSizes
.
mDOMOtherSize
+
=
nodeSize
;
break
;
}
if
(
EventListenerManager
*
elm
=
aNode
.
GetExistingListenerManager
(
)
)
{
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
if
(
aNode
.
IsContent
(
)
)
{
nsTArray
<
nsIContent
*
>
anonKids
;
nsContentUtils
:
:
AppendNativeAnonymousChildren
(
aNode
.
AsContent
(
)
anonKids
nsIContent
:
:
eAllChildren
)
;
for
(
nsIContent
*
anonKid
:
anonKids
)
{
AddSizeOfNodeTree
(
*
anonKid
aWindowSizes
)
;
}
if
(
auto
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
AddSizeOfNodeTree
(
*
shadow
aWindowSizes
)
;
}
for
(
nsXBLBinding
*
binding
=
element
-
>
GetXBLBinding
(
)
;
binding
;
binding
=
binding
-
>
GetBaseBinding
(
)
)
{
if
(
nsIContent
*
anonContent
=
binding
-
>
GetAnonymousContent
(
)
)
{
AddSizeOfNodeTree
(
*
anonContent
aWindowSizes
)
;
}
}
}
}
for
(
nsIContent
*
kid
=
aNode
.
GetFirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
AddSizeOfNodeTree
(
*
kid
aWindowSizes
)
;
}
}
already_AddRefed
<
Document
>
Document
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
prin
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
prin
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
)
;
if
(
!
uri
)
{
rv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
nsCOMPtr
<
Document
>
doc
;
nsresult
res
=
NS_NewDOMDocument
(
getter_AddRefs
(
doc
)
VoidString
(
)
EmptyString
(
)
nullptr
uri
uri
prin
-
>
GetPrincipal
(
)
true
global
DocumentFlavorPlain
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
doc
-
>
SetReadyStateInternal
(
Document
:
:
READYSTATE_COMPLETE
)
;
return
doc
.
forget
(
)
;
}
XPathExpression
*
Document
:
:
CreateExpression
(
const
nsAString
&
aExpression
XPathNSResolver
*
aResolver
ErrorResult
&
rv
)
{
return
XPathEvaluator
(
)
-
>
CreateExpression
(
aExpression
aResolver
rv
)
;
}
nsINode
*
Document
:
:
CreateNSResolver
(
nsINode
&
aNodeResolver
)
{
return
XPathEvaluator
(
)
-
>
CreateNSResolver
(
aNodeResolver
)
;
}
already_AddRefed
<
XPathResult
>
Document
:
:
Evaluate
(
JSContext
*
aCx
const
nsAString
&
aExpression
nsINode
&
aContextNode
XPathNSResolver
*
aResolver
uint16_t
aType
JS
:
:
Handle
<
JSObject
*
>
aResult
ErrorResult
&
rv
)
{
return
XPathEvaluator
(
)
-
>
Evaluate
(
aCx
aExpression
aContextNode
aResolver
aType
aResult
rv
)
;
}
already_AddRefed
<
nsIXULWindow
>
Document
:
:
GetXULWindowIfToplevelChrome
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
=
GetDocShell
(
)
;
if
(
!
item
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
item
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
nsCOMPtr
<
nsIXULWindow
>
xulWin
=
do_GetInterface
(
owner
)
;
if
(
!
xulWin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
xulWinShell
;
xulWin
-
>
GetDocShell
(
getter_AddRefs
(
xulWinShell
)
)
;
if
(
!
SameCOMIdentity
(
xulWinShell
item
)
)
{
return
nullptr
;
}
return
xulWin
.
forget
(
)
;
}
Document
*
Document
:
:
GetTopLevelContentDocument
(
)
{
Document
*
parent
;
if
(
!
mLoadedAsData
)
{
parent
=
this
;
}
else
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
GetScopeObject
(
)
)
;
if
(
!
window
)
{
return
nullptr
;
}
parent
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
}
do
{
if
(
parent
-
>
IsTopLevelContentDocument
(
)
)
{
break
;
}
if
(
!
parent
-
>
IsContentDocument
(
)
)
{
return
nullptr
;
}
parent
=
parent
-
>
GetParentDocument
(
)
;
}
while
(
parent
)
;
return
parent
;
}
static
bool
MightBeChromeScheme
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
bool
isChrome
=
true
;
aURI
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
;
return
isChrome
;
}
static
bool
MightBeAboutOrChromeScheme
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
bool
isAbout
=
true
;
aURI
-
>
SchemeIs
(
"
about
"
&
isAbout
)
;
return
isAbout
|
|
MightBeChromeScheme
(
aURI
)
;
}
void
Document
:
:
PropagateUseCounters
(
Document
*
aParentDocument
)
{
MOZ_ASSERT
(
this
!
=
aParentDocument
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
!
uri
|
|
MightBeChromeScheme
(
uri
)
)
{
return
;
}
Document
*
contentParent
=
aParentDocument
-
>
GetTopLevelContentDocument
(
)
;
if
(
!
contentParent
)
{
return
;
}
contentParent
-
>
mChildDocumentUseCounters
|
=
mUseCounters
;
contentParent
-
>
mChildDocumentUseCounters
|
=
mChildDocumentUseCounters
;
}
void
Document
:
:
SetPageUseCounter
(
UseCounter
aUseCounter
)
{
if
(
mNotifiedPageForUseCounter
[
aUseCounter
]
)
{
return
;
}
mNotifiedPageForUseCounter
[
aUseCounter
]
=
true
;
if
(
mDisplayDocument
)
{
MOZ_ASSERT
(
!
mDocumentContainer
)
;
mDisplayDocument
-
>
SetChildDocumentUseCounter
(
aUseCounter
)
;
return
;
}
if
(
IsBeingUsedAsImage
(
)
)
{
MOZ_ASSERT
(
!
mDocumentContainer
)
;
return
;
}
Document
*
contentParent
=
GetTopLevelContentDocument
(
)
;
if
(
!
contentParent
)
{
return
;
}
if
(
this
=
=
contentParent
)
{
MOZ_ASSERT
(
GetUseCounter
(
aUseCounter
)
)
;
return
;
}
contentParent
-
>
SetChildDocumentUseCounter
(
aUseCounter
)
;
}
bool
Document
:
:
HasScriptsBlockedBySandbox
(
)
{
return
mSandboxFlags
&
SANDBOXED_SCRIPTS
;
}
bool
Document
:
:
InlineScriptAllowedByCSP
(
)
{
bool
allowsInlineScript
=
true
;
if
(
mCSP
)
{
nsresult
rv
=
mCSP
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_SCRIPT
EmptyString
(
)
true
nullptr
nullptr
EmptyString
(
)
0
0
&
allowsInlineScript
)
;
NS_ENSURE_SUCCESS
(
rv
true
)
;
}
return
allowsInlineScript
;
}
static
bool
ReportExternalResourceUseCounters
(
Document
*
aDocument
void
*
aData
)
{
const
auto
reportKind
=
Document
:
:
UseCounterReportKind
:
:
eIncludeExternalResources
;
aDocument
-
>
ReportUseCounters
(
reportKind
)
;
return
true
;
}
void
Document
:
:
ReportUseCounters
(
UseCounterReportKind
aKind
)
{
static
const
bool
sDebugUseCounters
=
false
;
if
(
mReportedUseCounters
)
{
return
;
}
mReportedUseCounters
=
true
;
if
(
aKind
=
=
UseCounterReportKind
:
:
eIncludeExternalResources
)
{
EnumerateExternalResources
(
ReportExternalResourceUseCounters
nullptr
)
;
}
if
(
Telemetry
:
:
HistogramUseCounterCount
>
0
&
&
(
IsContentDocument
(
)
|
|
IsResourceDoc
(
)
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
!
uri
|
|
MightBeAboutOrChromeScheme
(
uri
)
)
{
return
;
}
if
(
sDebugUseCounters
)
{
nsCString
spec
=
uri
-
>
GetSpecOrDefault
(
)
;
spec
.
Truncate
(
std
:
:
min
(
128U
spec
.
Length
(
)
)
)
;
printf
(
"
-
-
Use
counters
for
%
s
-
-
\
n
"
spec
.
get
(
)
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_DOCUMENTS_DESTROYED
1
)
;
if
(
IsTopLevelContentDocument
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
1
)
;
}
for
(
int32_t
c
=
0
;
c
<
eUseCounter_Count
;
+
+
c
)
{
UseCounter
uc
=
static_cast
<
UseCounter
>
(
c
)
;
Telemetry
:
:
HistogramID
id
=
static_cast
<
Telemetry
:
:
HistogramID
>
(
Telemetry
:
:
HistogramFirstUseCounter
+
uc
*
2
)
;
bool
value
=
GetUseCounter
(
uc
)
;
if
(
value
)
{
if
(
sDebugUseCounters
)
{
const
char
*
name
=
Telemetry
:
:
GetHistogramName
(
id
)
;
if
(
name
)
{
printf
(
"
%
s
"
name
)
;
}
else
{
printf
(
"
#
%
d
"
id
)
;
}
printf
(
"
:
%
d
\
n
"
value
)
;
}
Telemetry
:
:
Accumulate
(
id
1
)
;
}
if
(
IsTopLevelContentDocument
(
)
)
{
id
=
static_cast
<
Telemetry
:
:
HistogramID
>
(
Telemetry
:
:
HistogramFirstUseCounter
+
uc
*
2
+
1
)
;
value
=
GetUseCounter
(
uc
)
|
|
GetChildDocumentUseCounter
(
uc
)
;
if
(
value
)
{
if
(
sDebugUseCounters
)
{
const
char
*
name
=
Telemetry
:
:
GetHistogramName
(
id
)
;
if
(
name
)
{
printf
(
"
%
s
"
name
)
;
}
else
{
printf
(
"
#
%
d
"
id
)
;
}
printf
(
"
:
%
d
\
n
"
value
)
;
}
Telemetry
:
:
Accumulate
(
id
1
)
;
}
}
}
}
if
(
IsTopLevelContentDocument
(
)
)
{
CSSIntCoord
adjustmentLength
=
CSSPixel
:
:
FromAppUnits
(
mScrollAnchorAdjustmentLength
)
.
Rounded
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SCROLL_ANCHOR_ADJUSTMENT_LENGTH
adjustmentLength
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SCROLL_ANCHOR_ADJUSTMENT_COUNT
mScrollAnchorAdjustmentCount
)
;
}
}
void
Document
:
:
UpdateIntersectionObservations
(
)
{
if
(
mIntersectionObservers
.
IsEmpty
(
)
)
{
return
;
}
DOMHighResTimeStamp
time
=
0
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
)
{
Performance
*
perf
=
window
-
>
GetPerformance
(
)
;
if
(
perf
)
{
time
=
perf
-
>
Now
(
)
;
}
}
nsTArray
<
RefPtr
<
DOMIntersectionObserver
>
>
observers
(
mIntersectionObservers
.
Count
(
)
)
;
for
(
auto
iter
=
mIntersectionObservers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DOMIntersectionObserver
*
observer
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
observers
.
AppendElement
(
observer
)
;
}
for
(
const
auto
&
observer
:
observers
)
{
if
(
observer
)
{
observer
-
>
Update
(
this
time
)
;
}
}
}
void
Document
:
:
ScheduleIntersectionObserverNotification
(
)
{
if
(
mIntersectionObservers
.
IsEmpty
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
notification
=
NewRunnableMethod
(
"
Document
:
:
NotifyIntersectionObservers
"
this
&
Document
:
:
NotifyIntersectionObservers
)
;
Dispatch
(
TaskCategory
:
:
Other
notification
.
forget
(
)
)
;
}
void
Document
:
:
NotifyIntersectionObservers
(
)
{
nsTArray
<
RefPtr
<
DOMIntersectionObserver
>
>
observers
(
mIntersectionObservers
.
Count
(
)
)
;
for
(
auto
iter
=
mIntersectionObservers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DOMIntersectionObserver
*
observer
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
observers
.
AppendElement
(
observer
)
;
}
for
(
const
auto
&
observer
:
observers
)
{
if
(
observer
)
{
observer
-
>
Notify
(
)
;
}
}
}
static
bool
NotifyLayerManagerRecreatedCallback
(
Document
*
aDocument
void
*
aData
)
{
aDocument
-
>
NotifyLayerManagerRecreated
(
)
;
return
true
;
}
void
Document
:
:
NotifyLayerManagerRecreated
(
)
{
EnumerateActivityObservers
(
NotifyActivityChanged
nullptr
)
;
EnumerateSubDocuments
(
NotifyLayerManagerRecreatedCallback
nullptr
)
;
}
XPathEvaluator
*
Document
:
:
XPathEvaluator
(
)
{
if
(
!
mXPathEvaluator
)
{
mXPathEvaluator
.
reset
(
new
dom
:
:
XPathEvaluator
(
this
)
)
;
}
return
mXPathEvaluator
.
get
(
)
;
}
already_AddRefed
<
nsIDocumentEncoder
>
Document
:
:
GetCachedEncoder
(
)
{
return
mCachedEncoder
.
forget
(
)
;
}
void
Document
:
:
SetCachedEncoder
(
already_AddRefed
<
nsIDocumentEncoder
>
aEncoder
)
{
mCachedEncoder
=
aEncoder
;
}
void
Document
:
:
SetContentTypeInternal
(
const
nsACString
&
aType
)
{
if
(
!
IsHTMLOrXHTML
(
)
&
&
mDefaultElementType
=
=
kNameSpaceID_None
&
&
aType
.
EqualsLiteral
(
"
application
/
xhtml
+
xml
"
)
)
{
mDefaultElementType
=
kNameSpaceID_XHTML
;
}
mCachedEncoder
=
nullptr
;
mContentType
=
aType
;
}
nsILoadContext
*
Document
:
:
GetLoadContext
(
)
const
{
return
mDocumentContainer
;
}
nsIDocShell
*
Document
:
:
GetDocShell
(
)
const
{
return
mDocumentContainer
;
}
void
Document
:
:
SetStateObject
(
nsIStructuredCloneContainer
*
scContainer
)
{
mStateObjectContainer
=
scContainer
;
mStateObjectCached
=
nullptr
;
}
Document
:
:
DocumentTheme
Document
:
:
GetDocumentLWTheme
(
)
{
if
(
mDocLWTheme
=
=
Doc_Theme_Uninitialized
)
{
mDocLWTheme
=
ThreadSafeGetDocumentLWTheme
(
)
;
}
return
mDocLWTheme
;
}
Document
:
:
DocumentTheme
Document
:
:
ThreadSafeGetDocumentLWTheme
(
)
const
{
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
NodePrincipal
(
)
)
)
{
return
Doc_Theme_None
;
}
if
(
mDocLWTheme
!
=
Doc_Theme_Uninitialized
)
{
return
mDocLWTheme
;
}
DocumentTheme
theme
=
Doc_Theme_None
;
Element
*
element
=
GetRootElement
(
)
;
if
(
element
&
&
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
lwtheme
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
theme
=
Doc_Theme_Neutral
;
nsAutoString
lwTheme
;
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
lwthemetextcolor
lwTheme
)
;
if
(
lwTheme
.
EqualsLiteral
(
"
dark
"
)
)
{
theme
=
Doc_Theme_Dark
;
}
else
if
(
lwTheme
.
EqualsLiteral
(
"
bright
"
)
)
{
theme
=
Doc_Theme_Bright
;
}
}
return
theme
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateHTMLElement
(
nsAtom
*
aTag
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nodeInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
aTag
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
MOZ_ASSERT
(
nodeInfo
"
GetNodeInfo
should
never
fail
"
)
;
nsCOMPtr
<
Element
>
element
;
DebugOnly
<
nsresult
>
rv
=
NS_NewHTMLElement
(
getter_AddRefs
(
element
)
nodeInfo
.
forget
(
)
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
NS_NewHTMLElement
should
never
fail
"
)
;
return
element
.
forget
(
)
;
}
bool
MarkDocumentTreeToBeInSyncOperation
(
Document
*
aDoc
void
*
aData
)
{
auto
*
documents
=
static_cast
<
nsTArray
<
nsCOMPtr
<
Document
>
>
*
>
(
aData
)
;
if
(
aDoc
)
{
aDoc
-
>
SetIsInSyncOperation
(
true
)
;
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
aDoc
-
>
GetInnerWindow
(
)
)
{
window
-
>
TimeoutManager
(
)
.
BeginSyncOperation
(
)
;
}
documents
-
>
AppendElement
(
aDoc
)
;
aDoc
-
>
EnumerateSubDocuments
(
MarkDocumentTreeToBeInSyncOperation
aData
)
;
}
return
true
;
}
nsAutoSyncOperation
:
:
nsAutoSyncOperation
(
Document
*
aDoc
)
{
mMicroTaskLevel
=
0
;
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
;
if
(
ccjs
)
{
mMicroTaskLevel
=
ccjs
-
>
MicroTaskLevel
(
)
;
ccjs
-
>
SetMicroTaskLevel
(
0
)
;
}
if
(
aDoc
)
{
if
(
nsPIDOMWindowOuter
*
win
=
aDoc
-
>
GetWindow
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
win
-
>
GetTop
(
)
)
{
nsCOMPtr
<
Document
>
doc
=
top
-
>
GetExtantDoc
(
)
;
MarkDocumentTreeToBeInSyncOperation
(
doc
&
mDocuments
)
;
}
}
}
}
nsAutoSyncOperation
:
:
~
nsAutoSyncOperation
(
)
{
for
(
RefPtr
<
Document
>
&
doc
:
mDocuments
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
doc
-
>
GetInnerWindow
(
)
)
{
window
-
>
TimeoutManager
(
)
.
EndSyncOperation
(
)
;
}
doc
-
>
SetIsInSyncOperation
(
false
)
;
}
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
;
if
(
ccjs
)
{
ccjs
-
>
SetMicroTaskLevel
(
mMicroTaskLevel
)
;
}
}
gfxUserFontSet
*
Document
:
:
GetUserFontSet
(
)
{
if
(
!
mFontFaceSet
)
{
return
nullptr
;
}
return
mFontFaceSet
-
>
GetUserFontSet
(
)
;
}
void
Document
:
:
FlushUserFontSet
(
)
{
if
(
!
mFontFaceSetDirty
)
{
return
;
}
mFontFaceSetDirty
=
false
;
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
DownloadableFontsEnabled
(
)
)
{
nsTArray
<
nsFontFaceRuleContainer
>
rules
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
MOZ_ASSERT
(
mStyleSetFilled
)
;
mStyleSet
-
>
AppendFontFaceRules
(
rules
)
;
}
if
(
!
mFontFaceSet
&
&
!
rules
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
GetScopeObject
(
)
)
;
mFontFaceSet
=
new
FontFaceSet
(
window
this
)
;
}
bool
changed
=
false
;
if
(
mFontFaceSet
)
{
changed
=
mFontFaceSet
-
>
UpdateRules
(
rules
)
;
}
if
(
changed
&
&
presShell
)
{
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
UserFontSetUpdated
(
)
;
}
}
}
}
void
Document
:
:
MarkUserFontSetDirty
(
)
{
if
(
mFontFaceSetDirty
)
{
return
;
}
mFontFaceSetDirty
=
true
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
}
FontFaceSet
*
Document
:
:
Fonts
(
)
{
if
(
!
mFontFaceSet
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
GetScopeObject
(
)
)
;
mFontFaceSet
=
new
FontFaceSet
(
window
this
)
;
FlushUserFontSet
(
)
;
}
return
mFontFaceSet
;
}
void
Document
:
:
ReportHasScrollLinkedEffect
(
)
{
if
(
mHasScrollLinkedEffect
)
{
return
;
}
mHasScrollLinkedEffect
=
true
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Async
Pan
/
Zoom
"
)
this
nsContentUtils
:
:
eLAYOUT_PROPERTIES
"
ScrollLinkedEffectFound2
"
)
;
}
void
Document
:
:
SetUserHasInteracted
(
)
{
MOZ_LOG
(
gUserInteractionPRLog
LogLevel
:
:
Debug
(
"
Document
%
p
has
been
interacted
by
user
.
"
this
)
)
;
MaybeStoreUserInteractionAsPermission
(
)
;
if
(
mUserHasInteracted
)
{
return
;
}
mUserHasInteracted
=
true
;
if
(
mChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetDocumentHasUserInteracted
(
true
)
;
}
MaybeAllowStorageForOpenerAfterUserInteraction
(
)
;
}
BrowsingContext
*
Document
:
:
GetBrowsingContext
(
)
const
{
nsPIDOMWindowOuter
*
outer
=
GetWindow
(
)
;
return
outer
?
outer
-
>
GetBrowsingContext
(
)
:
nullptr
;
}
void
Document
:
:
NotifyUserGestureActivation
(
)
{
if
(
HasBeenUserGestureActivated
(
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
;
}
bc
-
>
NotifyUserGestureActivation
(
)
;
}
bool
Document
:
:
HasBeenUserGestureActivated
(
)
{
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
false
;
}
return
bc
-
>
GetUserGestureActivation
(
)
;
}
void
Document
:
:
MaybeNotifyAutoplayBlocked
(
)
{
Document
*
topLevelDoc
=
GetTopLevelContentDocument
(
)
;
if
(
!
topLevelDoc
)
{
return
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
topLevelDoc
NS_LITERAL_STRING
(
"
GloballyAutoplayBlocked
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
void
Document
:
:
ClearUserGestureActivation
(
)
{
if
(
!
HasBeenUserGestureActivated
(
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
;
}
bc
-
>
NotifyResetUserGestureActivation
(
)
;
}
void
Document
:
:
SetDocTreeHadAudibleMedia
(
)
{
Document
*
topLevelDoc
=
GetTopLevelContentDocument
(
)
;
if
(
!
topLevelDoc
)
{
return
;
}
topLevelDoc
-
>
mDocTreeHadAudibleMedia
=
true
;
}
void
Document
:
:
SetDocTreeHadPlayRevoked
(
)
{
Document
*
topLevelDoc
=
GetTopLevelContentDocument
(
)
;
if
(
topLevelDoc
)
{
topLevelDoc
-
>
mDocTreeHadPlayRevoked
=
true
;
}
}
DocumentAutoplayPolicy
Document
:
:
AutoplayPolicy
(
)
const
{
return
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
;
}
void
Document
:
:
MaybeAllowStorageForOpenerAfterUserInteraction
(
)
{
if
(
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
!
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
return
;
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
inner
-
>
GetOuterWindow
(
)
;
if
(
NS_WARN_IF
(
!
outer
)
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerOpener
=
outer
-
>
GetOpener
(
)
;
if
(
!
outerOpener
)
{
return
;
}
nsPIDOMWindowInner
*
openerInner
=
outerOpener
-
>
GetCurrentInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
openerInner
)
)
{
return
;
}
Document
*
openerDocument
=
openerInner
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
openerDocument
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
openerURI
=
openerDocument
-
>
GetDocumentURI
(
)
;
if
(
NS_WARN_IF
(
!
openerURI
)
)
{
return
;
}
if
(
!
nsContentUtils
:
:
IsTrackingResourceWindow
(
inner
)
)
{
return
;
}
if
(
!
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
inner
nullptr
openerURI
)
&
&
!
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
openerInner
nullptr
nullptr
)
)
{
return
;
}
Unused
<
<
AntiTrackingCommon
:
:
AddFirstPartyStorageAccessGrantedFor
(
NodePrincipal
(
)
openerInner
AntiTrackingCommon
:
:
eOpenerAfterUserInteraction
)
;
}
namespace
{
class
UserIntractionTimer
final
:
public
Runnable
public
nsITimerCallback
public
nsIAsyncShutdownBlocker
{
public
:
NS_DECL_ISUPPORTS_INHERITED
explicit
UserIntractionTimer
(
Document
*
aDocument
)
:
Runnable
(
"
UserIntractionTimer
"
)
mPrincipal
(
aDocument
-
>
NodePrincipal
(
)
)
mDocument
(
do_GetWeakReference
(
aDocument
)
)
{
static
int32_t
userInteractionTimerId
=
0
;
mBlockerName
.
AppendPrintf
(
"
UserInteractionTimer
%
d
for
document
%
p
"
+
+
userInteractionTimerId
aDocument
)
;
}
NS_IMETHOD
Run
(
)
override
{
uint32_t
interval
=
StaticPrefs
:
:
privacy_userInteraction_document_interval
(
)
;
if
(
!
interval
)
{
return
NS_OK
;
}
RefPtr
<
UserIntractionTimer
>
self
=
this
;
auto
raii
=
MakeScopeExit
(
[
self
]
{
self
-
>
CancelTimerAndStoreUserInteraction
(
)
;
}
)
;
nsresult
rv
=
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimer
)
this
interval
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
=
GetShutdownPhase
(
)
;
NS_ENSURE_TRUE
(
!
!
phase
NS_OK
)
;
rv
=
phase
-
>
AddBlocker
(
this
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
UserIntractionTimer
shutdown
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
raii
.
release
(
)
;
return
NS_OK
;
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
StoreUserInteraction
(
)
;
return
NS_OK
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
using
nsINamed
:
:
GetName
;
#
endif
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
{
aName
=
mBlockerName
;
return
NS_OK
;
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aClient
)
override
{
CancelTimerAndStoreUserInteraction
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
private
:
~
UserIntractionTimer
(
)
=
default
;
void
StoreUserInteraction
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
=
GetShutdownPhase
(
)
;
if
(
phase
)
{
phase
-
>
RemoveBlocker
(
this
)
;
}
nsCOMPtr
<
Document
>
document
=
do_QueryReferent
(
mDocument
)
;
if
(
document
)
{
AntiTrackingCommon
:
:
StoreUserInteractionFor
(
mPrincipal
)
;
document
-
>
ResetUserInteractionTimer
(
)
;
}
}
void
CancelTimerAndStoreUserInteraction
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
StoreUserInteraction
(
)
;
}
static
already_AddRefed
<
nsIAsyncShutdownClient
>
GetShutdownPhase
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdown
(
)
;
NS_ENSURE_TRUE
(
!
!
svc
nullptr
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
;
nsresult
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
phase
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
phase
.
forget
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsWeakPtr
mDocument
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsString
mBlockerName
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
UserIntractionTimer
Runnable
nsITimerCallback
nsIAsyncShutdownBlocker
)
}
void
Document
:
:
MaybeStoreUserInteractionAsPermission
(
)
{
if
(
GetSameTypeParentDocument
(
)
)
{
return
;
}
if
(
!
mUserHasInteracted
)
{
AntiTrackingCommon
:
:
StoreUserInteractionFor
(
NodePrincipal
(
)
)
;
return
;
}
if
(
mHasUserInteractionTimerScheduled
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
task
=
new
UserIntractionTimer
(
this
)
;
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
task
.
forget
(
)
2500
EventQueuePriority
:
:
Idle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
mHasUserInteractionTimerScheduled
=
true
;
}
void
Document
:
:
ResetUserInteractionTimer
(
)
{
mHasUserInteractionTimerScheduled
=
false
;
}
bool
Document
:
:
IsExtensionPage
(
)
const
{
return
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
allow
-
extension
-
background
-
pages
"
true
)
&
&
BasePrincipal
:
:
Cast
(
NodePrincipal
(
)
)
-
>
AddonPolicy
(
)
;
}
Document
*
Document
:
:
GetSameTypeParentDocument
(
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
current
=
GetDocShell
(
)
;
if
(
!
current
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
current
-
>
GetSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
)
{
return
nullptr
;
}
return
parent
-
>
GetDocument
(
)
;
}
void
Document
:
:
TraceProtos
(
JSTracer
*
aTrc
)
{
if
(
mPrototypeDocument
)
{
mPrototypeDocument
-
>
TraceProtos
(
aTrc
)
;
}
}
FlashClassification
Document
:
:
DocumentFlashClassification
(
)
{
if
(
!
StaticPrefs
:
:
plugins_http_https_only
(
)
&
&
!
StaticPrefs
:
:
plugins_flashBlock_enabled
(
)
)
{
return
FlashClassification
:
:
Unknown
;
}
if
(
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
)
{
return
FlashClassification
:
:
Denied
;
}
nsCOMPtr
<
nsIURI
>
classificationURI
;
nsresult
rv
=
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
classificationURI
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
classificationURI
)
{
return
FlashClassification
:
:
Denied
;
}
if
(
StaticPrefs
:
:
plugins_http_https_only
(
)
)
{
nsAutoCString
scheme
;
rv
=
classificationURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
!
(
scheme
.
EqualsLiteral
(
"
http
"
)
|
|
scheme
.
EqualsLiteral
(
"
https
"
)
)
)
{
return
FlashClassification
:
:
Denied
;
}
}
if
(
!
StaticPrefs
:
:
plugins_flashBlock_enabled
(
)
)
{
return
FlashClassification
:
:
Unknown
;
}
if
(
mFlashClassification
=
=
FlashClassification
:
:
Unknown
)
{
mFlashClassification
=
DocumentFlashClassificationInternal
(
)
;
}
return
mFlashClassification
;
}
void
Document
:
:
AddResizeObserver
(
ResizeObserver
*
aResizeObserver
)
{
if
(
!
mResizeObserverController
)
{
mResizeObserverController
=
MakeUnique
<
ResizeObserverController
>
(
this
)
;
}
mResizeObserverController
-
>
AddResizeObserver
(
aResizeObserver
)
;
}
void
Document
:
:
ScheduleResizeObserversNotification
(
)
const
{
if
(
!
mResizeObserverController
)
{
return
;
}
mResizeObserverController
-
>
ScheduleNotification
(
)
;
}
bool
Document
:
:
IsThirdPartyForFlashClassifier
(
)
{
if
(
mIsThirdPartyForFlashClassifier
.
isSome
(
)
)
{
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
docshell
=
this
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
mIsThirdPartyForFlashClassifier
.
emplace
(
true
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
nsresult
rv
=
docshell
-
>
GetSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
nsIDocShellTreeItem
:
:
GetSameTypeParent
should
never
fail
"
)
;
bool
isTopLevel
=
!
parent
;
if
(
isTopLevel
)
{
mIsThirdPartyForFlashClassifier
.
emplace
(
false
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
nsCOMPtr
<
Document
>
parentDocument
=
GetParentDocument
(
)
;
if
(
!
parentDocument
)
{
mIsThirdPartyForFlashClassifier
.
emplace
(
true
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
if
(
parentDocument
-
>
IsThirdPartyForFlashClassifier
(
)
)
{
mIsThirdPartyForFlashClassifier
.
emplace
(
true
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
NodePrincipal
(
)
;
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
=
parentDocument
-
>
GetPrincipal
(
)
;
bool
principalsMatch
=
false
;
rv
=
principal
-
>
Equals
(
parentPrincipal
&
principalsMatch
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mIsThirdPartyForFlashClassifier
.
emplace
(
true
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
if
(
!
principalsMatch
)
{
mIsThirdPartyForFlashClassifier
.
emplace
(
true
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
mIsThirdPartyForFlashClassifier
.
emplace
(
false
)
;
return
mIsThirdPartyForFlashClassifier
.
value
(
)
;
}
FlashClassification
Document
:
:
DocumentFlashClassificationInternal
(
)
{
FlashClassification
classification
=
FlashClassification
:
:
Unknown
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
GetChannel
(
)
)
;
if
(
httpChannel
)
{
nsIHttpChannel
:
:
FlashPluginState
state
=
nsIHttpChannel
:
:
FlashPluginUnknown
;
httpChannel
-
>
GetFlashPluginState
(
&
state
)
;
if
(
state
=
=
nsIHttpChannel
:
:
FlashPluginDeniedInSubdocuments
&
&
IsThirdPartyForFlashClassifier
(
)
)
{
return
FlashClassification
:
:
Denied
;
}
if
(
state
=
=
nsIHttpChannel
:
:
FlashPluginDenied
)
{
return
FlashClassification
:
:
Denied
;
}
if
(
state
=
=
nsIHttpChannel
:
:
FlashPluginAllowed
)
{
classification
=
FlashClassification
:
:
Allowed
;
}
}
if
(
IsTopLevelContentDocument
(
)
)
{
return
classification
;
}
Document
*
parentDocument
=
GetParentDocument
(
)
;
if
(
!
parentDocument
)
{
return
FlashClassification
:
:
Denied
;
}
FlashClassification
parentClassification
=
parentDocument
-
>
DocumentFlashClassification
(
)
;
if
(
parentClassification
=
=
FlashClassification
:
:
Denied
)
{
return
FlashClassification
:
:
Denied
;
}
if
(
classification
=
=
FlashClassification
:
:
Unknown
&
&
parentClassification
=
=
FlashClassification
:
:
Allowed
)
{
return
FlashClassification
:
:
Allowed
;
}
return
classification
;
}
void
Document
:
:
ClearStaleServoData
(
)
{
DocumentStyleRootIterator
iter
(
this
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
RestyleManager
:
:
ClearServoDataFromSubtree
(
root
)
;
}
}
Selection
*
Document
:
:
GetSelection
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
if
(
!
window
-
>
IsCurrentInnerWindow
(
)
)
{
return
nullptr
;
}
return
nsGlobalWindowInner
:
:
Cast
(
window
)
-
>
GetSelection
(
aRv
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Document
:
:
HasStorageAccess
(
mozilla
:
:
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
Promise
:
:
ePropagateUserInteraction
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
)
{
promise
-
>
MaybeResolve
(
false
)
;
return
promise
.
forget
(
)
;
}
if
(
IsTopLevelContentDocument
(
)
)
{
promise
-
>
MaybeResolve
(
true
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
Document
>
topLevelDoc
=
GetTopLevelContentDocument
(
)
;
if
(
!
topLevelDoc
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
if
(
topLevelDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
NodePrincipal
(
)
)
)
{
promise
-
>
MaybeResolve
(
true
)
;
return
promise
.
forget
(
)
;
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
nsGlobalWindowOuter
*
outer
=
nullptr
;
if
(
inner
)
{
outer
=
nsGlobalWindowOuter
:
:
Cast
(
inner
-
>
GetOuterWindow
(
)
)
;
promise
-
>
MaybeResolve
(
outer
-
>
HasStorageAccess
(
)
)
;
}
else
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
return
promise
.
forget
(
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Document
:
:
RequestStorageAccess
(
mozilla
:
:
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
Promise
:
:
ePropagateUserInteraction
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
GetInnerWindow
(
)
;
RefPtr
<
nsGlobalWindowOuter
>
outer
;
if
(
inner
)
{
outer
=
nsGlobalWindowOuter
:
:
Cast
(
inner
-
>
GetOuterWindow
(
)
)
;
if
(
outer
-
>
HasStorageAccess
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
}
if
(
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
!
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
)
{
if
(
IsTopLevelContentDocument
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
Document
>
topLevelDoc
=
GetTopLevelContentDocument
(
)
;
if
(
!
topLevelDoc
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
if
(
topLevelDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
NodePrincipal
(
)
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
}
if
(
StorageAccessSandboxed
(
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
Document
*
parent
=
GetParentDocument
(
)
;
if
(
parent
&
&
!
parent
-
>
IsTopLevelContentDocument
(
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
!
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
nsContentUtils
:
:
IsInPrivateBrowsing
(
this
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
&
&
inner
)
{
if
(
nsContentUtils
:
:
StorageDisabledByAntiTracking
(
this
nullptr
)
)
{
DebugOnly
<
bool
>
isOnAllowList
=
false
;
MOZ_ASSERT_IF
(
parent
!
nsContentUtils
:
:
IsInPrivateBrowsing
(
parent
)
)
;
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
AntiTrackingCommon
:
:
IsOnContentBlockingAllowList
(
parent
-
>
GetDocumentURI
(
)
false
AntiTrackingCommon
:
:
eStorageChecks
isOnAllowList
)
)
!
isOnAllowList
)
;
auto
performFinalChecks
=
[
inner
]
(
)
-
>
RefPtr
<
AntiTrackingCommon
:
:
StorageAccessFinalCheckPromise
>
{
RefPtr
<
AntiTrackingCommon
:
:
StorageAccessFinalCheckPromise
:
:
Private
>
p
=
new
AntiTrackingCommon
:
:
StorageAccessFinalCheckPromise
:
:
Private
(
__func__
)
;
RefPtr
<
StorageAccessPermissionRequest
>
sapr
=
StorageAccessPermissionRequest
:
:
Create
(
inner
[
p
]
{
p
-
>
Resolve
(
AntiTrackingCommon
:
:
eAllow
__func__
)
;
}
[
p
]
{
p
-
>
Resolve
(
AntiTrackingCommon
:
:
eAllowAutoGrant
__func__
)
;
}
[
p
]
{
p
-
>
Resolve
(
AntiTrackingCommon
:
:
eAllowOnAnySite
__func__
)
;
}
[
p
]
{
p
-
>
Reject
(
false
__func__
)
;
}
)
;
typedef
ContentPermissionRequestBase
:
:
PromptResult
PromptResult
;
PromptResult
pr
=
sapr
-
>
CheckPromptPrefs
(
)
;
bool
onAnySite
=
false
;
if
(
pr
=
=
PromptResult
:
:
Pending
)
{
if
(
Preferences
:
:
GetBool
(
"
dom
.
storage_access
.
prompt
.
testing
"
false
)
&
&
Preferences
:
:
GetBool
(
"
dom
.
storage_access
.
prompt
.
testing
.
allowonanysite
"
false
)
)
{
pr
=
PromptResult
:
:
Granted
;
onAnySite
=
true
;
}
}
if
(
pr
!
=
PromptResult
:
:
Pending
)
{
MOZ_ASSERT_IF
(
pr
!
=
PromptResult
:
:
Granted
pr
=
=
PromptResult
:
:
Denied
)
;
if
(
pr
=
=
PromptResult
:
:
Granted
)
{
return
AntiTrackingCommon
:
:
StorageAccessFinalCheckPromise
:
:
CreateAndResolve
(
onAnySite
?
AntiTrackingCommon
:
:
eAllowOnAnySite
:
AntiTrackingCommon
:
:
eAllow
__func__
)
;
}
return
AntiTrackingCommon
:
:
StorageAccessFinalCheckPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
sapr
-
>
RequestDelayedTask
(
inner
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
ContentPermissionRequestBase
:
:
DelayedTaskType
:
:
Request
)
;
return
p
.
forget
(
)
;
}
;
AntiTrackingCommon
:
:
AddFirstPartyStorageAccessGrantedFor
(
NodePrincipal
(
)
inner
AntiTrackingCommon
:
:
eStorageAccessAPI
performFinalChecks
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
outer
promise
]
{
outer
-
>
SetHasStorageAccess
(
true
)
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
outer
promise
]
{
outer
-
>
SetHasStorageAccess
(
false
)
;
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
return
promise
.
forget
(
)
;
}
}
outer
-
>
SetHasStorageAccess
(
true
)
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
void
Document
:
:
RecordNavigationTiming
(
ReadyState
aReadyState
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
return
;
}
if
(
!
IsTopLevelContentDocument
(
)
)
{
return
;
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mTiming
;
if
(
!
timing
)
{
if
(
!
mDocumentContainer
)
{
return
;
}
timing
=
mDocumentContainer
-
>
GetNavigationTiming
(
)
;
if
(
!
timing
)
{
return
;
}
}
TimeStamp
startTime
=
timing
-
>
GetNavigationStartTimeStamp
(
)
;
switch
(
aReadyState
)
{
case
READYSTATE_LOADING
:
if
(
!
mDOMLoadingSet
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TIME_TO_DOM_LOADING_MS
startTime
)
;
mDOMLoadingSet
=
true
;
}
break
;
case
READYSTATE_INTERACTIVE
:
if
(
!
mDOMInteractiveSet
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TIME_TO_DOM_INTERACTIVE_MS
startTime
)
;
mDOMInteractiveSet
=
true
;
}
break
;
case
READYSTATE_COMPLETE
:
if
(
!
mDOMCompleteSet
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TIME_TO_DOM_COMPLETE_MS
startTime
)
;
mDOMCompleteSet
=
true
;
}
break
;
default
:
NS_WARNING
(
"
Unexpected
ReadyState
value
"
)
;
break
;
}
}
bool
Document
:
:
ModuleScriptsEnabled
(
)
{
static
bool
sEnabledForContent
=
false
;
static
bool
sCachedPref
=
false
;
if
(
!
sCachedPref
)
{
sCachedPref
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sEnabledForContent
"
dom
.
moduleScripts
.
enabled
"
false
)
;
}
return
nsContentUtils
:
:
IsChromeDoc
(
this
)
|
|
sEnabledForContent
;
}
void
Document
:
:
ReportShadowDOMUsage
(
)
{
if
(
mHasReportedShadowDOMUsage
)
{
return
;
}
Document
*
topLevel
=
GetTopLevelContentDocument
(
)
;
if
(
topLevel
&
&
!
topLevel
-
>
mHasReportedShadowDOMUsage
)
{
topLevel
-
>
mHasReportedShadowDOMUsage
=
true
;
nsString
uri
;
Unused
<
<
topLevel
-
>
GetDocumentURI
(
uri
)
;
if
(
!
uri
.
IsEmpty
(
)
)
{
nsAutoString
msg
=
NS_LITERAL_STRING
(
"
Shadow
DOM
used
in
[
"
)
+
uri
+
NS_LITERAL_STRING
(
"
]
or
in
some
of
its
subdocuments
.
"
)
;
nsContentUtils
:
:
ReportToConsoleNonLocalized
(
msg
nsIScriptError
:
:
infoFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
topLevel
)
;
}
}
mHasReportedShadowDOMUsage
=
true
;
}
bool
Document
:
:
StorageAccessSandboxed
(
)
const
{
return
StaticPrefs
:
:
dom_storage_access_enabled
(
)
&
&
(
GetSandboxFlags
(
)
&
SANDBOXED_STORAGE_ACCESS
)
!
=
0
;
}
bool
Document
:
:
GetCachedSizes
(
nsTabSizes
*
aSizes
)
{
if
(
mCachedTabSizeGeneration
=
=
0
|
|
GetGeneration
(
)
!
=
mCachedTabSizeGeneration
)
{
return
false
;
}
aSizes
-
>
mDom
+
=
mCachedTabSizes
.
mDom
;
aSizes
-
>
mStyle
+
=
mCachedTabSizes
.
mStyle
;
aSizes
-
>
mOther
+
=
mCachedTabSizes
.
mOther
;
return
true
;
}
void
Document
:
:
SetCachedSizes
(
nsTabSizes
*
aSizes
)
{
mCachedTabSizes
.
mDom
=
aSizes
-
>
mDom
;
mCachedTabSizes
.
mStyle
=
aSizes
-
>
mStyle
;
mCachedTabSizes
.
mOther
=
aSizes
-
>
mOther
;
mCachedTabSizeGeneration
=
GetGeneration
(
)
;
}
already_AddRefed
<
nsAtom
>
Document
:
:
GetContentLanguageAsAtomForStyle
(
)
const
{
nsAutoString
contentLang
;
GetContentLanguage
(
contentLang
)
;
contentLang
.
StripWhitespace
(
)
;
if
(
!
contentLang
.
IsEmpty
(
)
&
&
!
contentLang
.
Contains
(
char16_t
(
'
'
)
)
)
{
return
NS_Atomize
(
contentLang
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsAtom
>
Document
:
:
GetLanguageForStyle
(
)
const
{
RefPtr
<
nsAtom
>
lang
=
GetContentLanguageAsAtomForStyle
(
)
;
if
(
!
lang
)
{
lang
=
mLanguageFromCharset
;
}
return
lang
.
forget
(
)
;
}
const
LangGroupFontPrefs
*
Document
:
:
GetFontPrefsForLang
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
)
const
{
nsAtom
*
lang
=
aLanguage
?
aLanguage
:
mLanguageFromCharset
.
get
(
)
;
return
StaticPresData
:
:
Get
(
)
-
>
GetFontPrefsForLang
(
lang
aNeedsToCache
)
;
}
void
Document
:
:
DoCacheAllKnownLangPrefs
(
)
{
MOZ_ASSERT
(
mMayNeedFontPrefsUpdate
)
;
RefPtr
<
nsAtom
>
lang
=
GetLanguageForStyle
(
)
;
StaticPresData
*
data
=
StaticPresData
:
:
Get
(
)
;
data
-
>
GetFontPrefsForLang
(
lang
?
lang
.
get
(
)
:
mLanguageFromCharset
.
get
(
)
)
;
data
-
>
GetFontPrefsForLang
(
nsGkAtoms
:
:
x_math
)
;
data
-
>
GetFontPrefsForLang
(
nsGkAtoms
:
:
Unicode
)
;
for
(
auto
iter
=
mLanguagesUsed
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
data
-
>
GetFontPrefsForLang
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mMayNeedFontPrefsUpdate
=
false
;
}
void
Document
:
:
RecomputeLanguageFromCharset
(
)
{
nsLanguageAtomService
*
service
=
nsLanguageAtomService
:
:
GetService
(
)
;
RefPtr
<
nsAtom
>
language
=
service
-
>
LookupCharSet
(
mCharacterSet
)
;
if
(
language
=
=
nsGkAtoms
:
:
Unicode
)
{
language
=
service
-
>
GetLocaleLanguage
(
)
;
}
if
(
language
=
=
mLanguageFromCharset
)
{
return
;
}
mMayNeedFontPrefsUpdate
=
true
;
mLanguageFromCharset
=
language
.
forget
(
)
;
}
nsICookieSettings
*
Document
:
:
CookieSettings
(
)
{
if
(
!
mCookieSettings
)
{
mCookieSettings
=
net
:
:
CookieSettings
:
:
Create
(
)
;
}
return
mCookieSettings
;
}
nsIPrincipal
*
Document
:
:
EffectiveStoragePrincipal
(
)
const
{
if
(
!
StaticPrefs
:
:
privacy_storagePrincipal_enabledForTrackers
(
)
)
{
return
NodePrincipal
(
)
;
}
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForDocument
(
this
)
;
if
(
access
!
=
nsContentUtils
:
:
StorageAccess
:
:
ePartitionedOrDeny
)
{
return
NodePrincipal
(
)
;
}
return
mIntrinsicStoragePrincipal
;
}
}
}
