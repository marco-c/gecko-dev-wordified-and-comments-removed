#
include
"
Crypto
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIRandomGenerator
.
h
"
#
include
"
mozilla
/
dom
/
CryptoBinding
.
h
"
#
include
"
mozilla
/
dom
/
SubtleCrypto
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
namespace
mozilla
:
:
dom
{
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Crypto
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Crypto
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Crypto
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
Crypto
mParent
mSubtle
)
Crypto
:
:
Crypto
(
nsIGlobalObject
*
aParent
)
:
mParent
(
aParent
)
{
}
Crypto
:
:
~
Crypto
(
)
=
default
;
JSObject
*
Crypto
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Crypto_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
Crypto
:
:
GetRandomValues
(
JSContext
*
aCx
const
ArrayBufferView
&
aArray
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
view
(
aCx
aArray
.
Obj
(
)
)
;
switch
(
JS_GetArrayBufferViewType
(
view
)
)
{
case
js
:
:
Scalar
:
:
Int8
:
case
js
:
:
Scalar
:
:
Uint8
:
case
js
:
:
Scalar
:
:
Uint8Clamped
:
case
js
:
:
Scalar
:
:
Int16
:
case
js
:
:
Scalar
:
:
Uint16
:
case
js
:
:
Scalar
:
:
Int32
:
case
js
:
:
Scalar
:
:
Uint32
:
break
;
default
:
aRv
.
Throw
(
NS_ERROR_DOM_TYPE_MISMATCH_ERR
)
;
return
;
}
aArray
.
ComputeState
(
)
;
uint32_t
dataLen
=
aArray
.
Length
(
)
;
if
(
dataLen
=
=
0
)
{
NS_WARNING
(
"
ArrayBufferView
length
is
0
cannot
continue
"
)
;
aRetval
.
set
(
view
)
;
return
;
}
else
if
(
dataLen
>
65536
)
{
aRv
.
Throw
(
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
)
;
return
;
}
nsCOMPtr
<
nsIRandomGenerator
>
randomGenerator
=
do_GetService
(
"
mozilla
.
org
/
security
/
random
-
generator
;
1
"
)
;
if
(
!
randomGenerator
)
{
aRv
.
Throw
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
uint8_t
*
buf
;
nsresult
rv
=
randomGenerator
-
>
GenerateRandomBytes
(
dataLen
&
buf
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
buf
)
{
aRv
.
Throw
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
;
}
memcpy
(
aArray
.
Data
(
)
buf
dataLen
)
;
free
(
buf
)
;
aRetval
.
set
(
view
)
;
}
SubtleCrypto
*
Crypto
:
:
Subtle
(
)
{
if
(
!
mSubtle
)
{
mSubtle
=
new
SubtleCrypto
(
GetParentObject
(
)
)
;
}
return
mSubtle
;
}
}
