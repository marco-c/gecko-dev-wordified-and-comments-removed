#
ifndef
nsNodeUtils_h___
#
define
nsNodeUtils_h___
#
include
"
nsIContent
.
h
"
#
include
"
nsIMutationObserver
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsContentUtils
.
h
"
struct
CharacterDataChangeInfo
;
template
<
class
E
>
class
nsCOMArray
;
class
nsCycleCollectionTraversalCallback
;
namespace
mozilla
{
struct
NonOwningAnimationTarget
;
class
ErrorResult
;
namespace
dom
{
class
Animation
;
}
}
class
nsNodeUtils
{
public
:
static
void
CharacterDataWillChange
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
;
static
void
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
;
static
void
AttributeWillChange
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
;
static
void
AttributeChanged
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
;
static
void
AttributeSetToCurrentValue
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
;
static
void
ContentAppended
(
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
)
;
static
void
NativeAnonymousChildListChange
(
nsIContent
*
aContent
bool
aIsRemove
)
;
static
void
ContentInserted
(
nsINode
*
aContainer
nsIContent
*
aChild
)
;
static
void
ContentRemoved
(
nsINode
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
;
static
inline
void
ParentChainChanged
(
nsIContent
*
aContent
)
{
nsINode
:
:
nsSlots
*
slots
=
aContent
-
>
GetExistingSlots
(
)
;
if
(
slots
&
&
!
slots
-
>
mMutationObservers
.
IsEmpty
(
)
)
{
NS_OBSERVER_AUTO_ARRAY_NOTIFY_OBSERVERS
(
slots
-
>
mMutationObservers
nsIMutationObserver
1
ParentChainChanged
(
aContent
)
)
;
}
}
static
void
AnimationAdded
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
AnimationChanged
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
AnimationRemoved
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
LastRelease
(
nsINode
*
aNode
)
;
static
already_AddRefed
<
nsINode
>
Clone
(
nsINode
*
aNode
bool
aDeep
nsNodeInfoManager
*
aNewNodeInfoManager
nsCOMArray
<
nsINode
>
*
aNodesWithProperties
mozilla
:
:
ErrorResult
&
aError
)
{
return
CloneAndAdopt
(
aNode
true
aDeep
aNewNodeInfoManager
nullptr
aNodesWithProperties
nullptr
aError
)
;
}
static
void
Adopt
(
nsINode
*
aNode
nsNodeInfoManager
*
aNewNodeInfoManager
JS
:
:
Handle
<
JSObject
*
>
aReparentScope
nsCOMArray
<
nsINode
>
&
aNodesWithProperties
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
aNode
&
&
aNewNodeInfoManager
)
{
mozilla
:
:
dom
:
:
Document
*
afterAdoptDoc
=
aNewNodeInfoManager
-
>
GetDocument
(
)
;
mozilla
:
:
dom
:
:
Document
*
beforeAdoptDoc
=
aNode
-
>
OwnerDoc
(
)
;
if
(
afterAdoptDoc
&
&
beforeAdoptDoc
&
&
(
afterAdoptDoc
-
>
GetDocGroup
(
)
!
=
beforeAdoptDoc
-
>
GetDocGroup
(
)
)
)
{
if
(
nsContentUtils
:
:
IsChromeDoc
(
afterAdoptDoc
)
|
|
nsContentUtils
:
:
IsChromeDoc
(
beforeAdoptDoc
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
}
}
nsCOMPtr
<
nsINode
>
node
=
CloneAndAdopt
(
aNode
false
true
aNewNodeInfoManager
aReparentScope
&
aNodesWithProperties
nullptr
aError
)
;
nsMutationGuard
:
:
DidMutate
(
)
;
}
static
already_AddRefed
<
nsINode
>
CloneNodeImpl
(
nsINode
*
aNode
bool
aDeep
mozilla
:
:
ErrorResult
&
aError
)
;
private
:
static
already_AddRefed
<
nsINode
>
CloneAndAdopt
(
nsINode
*
aNode
bool
aClone
bool
aDeep
nsNodeInfoManager
*
aNewNodeInfoManager
JS
:
:
Handle
<
JSObject
*
>
aReparentScope
nsCOMArray
<
nsINode
>
*
aNodesWithProperties
nsINode
*
aParent
mozilla
:
:
ErrorResult
&
aError
)
;
enum
class
AnimationMutationType
{
Added
Changed
Removed
}
;
static
void
AnimationMutated
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
AnimationMutationType
aMutatedType
)
;
}
;
#
endif
