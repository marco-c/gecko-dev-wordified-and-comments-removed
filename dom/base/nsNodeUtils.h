#
ifndef
nsNodeUtils_h___
#
define
nsNodeUtils_h___
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIMutationObserver
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsCOMArray
.
h
"
struct
CharacterDataChangeInfo
;
template
<
class
E
>
class
nsCOMArray
;
class
nsCycleCollectionTraversalCallback
;
namespace
mozilla
{
struct
NonOwningAnimationTarget
;
class
ErrorResult
;
namespace
dom
{
class
Animation
;
}
}
class
nsNodeUtils
{
public
:
static
void
CharacterDataWillChange
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
;
static
void
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
;
static
void
AttributeWillChange
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
;
static
void
AttributeChanged
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
;
static
void
AttributeSetToCurrentValue
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
;
static
void
ContentAppended
(
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
)
;
static
void
NativeAnonymousChildListChange
(
nsIContent
*
aContent
bool
aIsRemove
)
;
static
void
ContentInserted
(
nsINode
*
aContainer
nsIContent
*
aChild
)
;
static
void
ContentRemoved
(
nsINode
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
;
static
inline
void
ParentChainChanged
(
nsIContent
*
aContent
)
{
nsINode
:
:
nsSlots
*
slots
=
aContent
-
>
GetExistingSlots
(
)
;
if
(
slots
&
&
!
slots
-
>
mMutationObservers
.
IsEmpty
(
)
)
{
NS_OBSERVER_AUTO_ARRAY_NOTIFY_OBSERVERS
(
slots
-
>
mMutationObservers
nsIMutationObserver
1
ParentChainChanged
(
aContent
)
)
;
}
}
static
mozilla
:
:
Maybe
<
mozilla
:
:
NonOwningAnimationTarget
>
GetTargetForAnimation
(
const
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
AnimationAdded
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
AnimationChanged
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
AnimationRemoved
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
)
;
static
void
LastRelease
(
nsINode
*
aNode
)
;
static
already_AddRefed
<
nsINode
>
Clone
(
nsINode
*
aNode
bool
aDeep
nsNodeInfoManager
*
aNewNodeInfoManager
nsCOMArray
<
nsINode
>
*
aNodesWithProperties
mozilla
:
:
ErrorResult
&
aError
)
{
return
CloneAndAdopt
(
aNode
true
aDeep
aNewNodeInfoManager
nullptr
aNodesWithProperties
nullptr
aError
)
;
}
static
void
Adopt
(
nsINode
*
aNode
nsNodeInfoManager
*
aNewNodeInfoManager
JS
:
:
Handle
<
JSObject
*
>
aReparentScope
nsCOMArray
<
nsINode
>
&
aNodesWithProperties
mozilla
:
:
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsINode
>
node
=
CloneAndAdopt
(
aNode
false
true
aNewNodeInfoManager
aReparentScope
&
aNodesWithProperties
nullptr
aError
)
;
nsMutationGuard
:
:
DidMutate
(
)
;
}
static
already_AddRefed
<
nsINode
>
CloneNodeImpl
(
nsINode
*
aNode
bool
aDeep
mozilla
:
:
ErrorResult
&
aError
)
;
static
bool
IsTemplateElement
(
const
nsINode
*
aNode
)
;
static
nsIContent
*
GetFirstChildOfTemplateOrNode
(
nsINode
*
aNode
)
;
private
:
static
already_AddRefed
<
nsINode
>
CloneAndAdopt
(
nsINode
*
aNode
bool
aClone
bool
aDeep
nsNodeInfoManager
*
aNewNodeInfoManager
JS
:
:
Handle
<
JSObject
*
>
aReparentScope
nsCOMArray
<
nsINode
>
*
aNodesWithProperties
nsINode
*
aParent
mozilla
:
:
ErrorResult
&
aError
)
;
enum
class
AnimationMutationType
{
Added
Changed
Removed
}
;
static
void
AnimationMutated
(
mozilla
:
:
dom
:
:
Animation
*
aAnimation
AnimationMutationType
aMutatedType
)
;
}
;
#
endif
