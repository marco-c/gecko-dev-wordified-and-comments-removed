#
include
"
SelectionChangeListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
Selection
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
SelectionChangeListener
:
:
RawRangeData
:
:
RawRangeData
(
const
nsRange
*
aRange
)
{
mozilla
:
:
ErrorResult
rv
;
mStartContainer
=
aRange
-
>
GetStartContainer
(
rv
)
;
rv
.
SuppressException
(
)
;
mEndParent
=
aRange
-
>
GetEndContainer
(
rv
)
;
rv
.
SuppressException
(
)
;
mStartOffset
=
aRange
-
>
GetStartOffset
(
rv
)
;
rv
.
SuppressException
(
)
;
mEndOffset
=
aRange
-
>
GetEndOffset
(
rv
)
;
rv
.
SuppressException
(
)
;
}
bool
SelectionChangeListener
:
:
RawRangeData
:
:
Equals
(
const
nsRange
*
aRange
)
{
mozilla
:
:
ErrorResult
rv
;
bool
eq
=
mStartContainer
=
=
aRange
-
>
GetStartContainer
(
rv
)
;
rv
.
SuppressException
(
)
;
eq
=
eq
&
&
mEndParent
=
=
aRange
-
>
GetEndContainer
(
rv
)
;
rv
.
SuppressException
(
)
;
eq
=
eq
&
&
mStartOffset
=
=
aRange
-
>
GetStartOffset
(
rv
)
;
rv
.
SuppressException
(
)
;
eq
=
eq
&
&
mEndOffset
=
=
aRange
-
>
GetEndOffset
(
rv
)
;
rv
.
SuppressException
(
)
;
return
eq
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
SelectionChangeListener
:
:
RawRangeData
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mStartContainer
"
mStartContainer
"
aFlags
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mEndParent
"
mEndParent
"
aFlags
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SelectionChangeListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SelectionChangeListener
)
tmp
-
>
mOldRanges
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
SelectionChangeListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOldRanges
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SelectionChangeListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
nsISelectionListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SelectionChangeListener
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SelectionChangeListener
)
NS_IMETHODIMP
SelectionChangeListener
:
:
NotifySelectionChanged
(
nsIDOMDocument
*
aDoc
nsISelection
*
aSel
int16_t
aReason
)
{
RefPtr
<
Selection
>
sel
=
aSel
-
>
AsSelection
(
)
;
nsIDocument
*
doc
=
sel
-
>
GetParentObject
(
)
;
if
(
!
(
doc
&
&
nsContentUtils
:
:
IsSystemPrincipal
(
doc
-
>
NodePrincipal
(
)
)
)
&
&
!
nsFrameSelection
:
:
sSelectionEventsEnabled
)
{
return
NS_OK
;
}
if
(
mOldRanges
.
Length
(
)
=
=
sel
-
>
RangeCount
(
)
&
&
!
sel
-
>
IsBlockingSelectionChangeEvents
(
)
)
{
bool
changed
=
false
;
for
(
size_t
i
=
0
;
i
<
mOldRanges
.
Length
(
)
;
i
+
+
)
{
if
(
!
mOldRanges
[
i
]
.
Equals
(
sel
-
>
GetRangeAt
(
i
)
)
)
{
changed
=
true
;
break
;
}
}
if
(
!
changed
)
{
return
NS_OK
;
}
}
mOldRanges
.
ClearAndRetainStorage
(
)
;
for
(
size_t
i
=
0
;
i
<
sel
-
>
RangeCount
(
)
;
i
+
+
)
{
mOldRanges
.
AppendElement
(
RawRangeData
(
sel
-
>
GetRangeAt
(
i
)
)
)
;
}
if
(
doc
)
{
nsPIDOMWindowInner
*
inner
=
doc
-
>
GetInnerWindow
(
)
;
if
(
inner
&
&
!
inner
-
>
HasSelectionChangeEventListeners
(
)
)
{
return
NS_OK
;
}
}
if
(
sel
-
>
IsBlockingSelectionChangeEvents
(
)
)
{
return
NS_OK
;
}
if
(
nsFrameSelection
:
:
sSelectionEventsOnTextControlsEnabled
)
{
nsCOMPtr
<
nsINode
>
target
;
if
(
const
nsFrameSelection
*
fs
=
sel
-
>
GetFrameSelection
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
root
=
fs
-
>
GetLimiter
(
)
)
{
while
(
root
&
&
root
-
>
IsInNativeAnonymousSubtree
(
)
)
{
root
=
root
-
>
GetParent
(
)
;
}
target
=
root
.
forget
(
)
;
}
}
if
(
!
target
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
aDoc
)
;
target
=
doc
.
forget
(
)
;
}
if
(
target
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
target
eSelectionChange
false
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
else
{
if
(
const
nsFrameSelection
*
fs
=
sel
-
>
GetFrameSelection
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
root
=
fs
-
>
GetLimiter
(
)
)
{
if
(
root
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
aDoc
)
;
if
(
doc
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
doc
eSelectionChange
false
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
return
NS_OK
;
}
