#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
<
algorithm
>
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsAutoCopyListener
.
h
"
#
include
"
SelectionChangeListener
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
SelectionBinding
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
bool
IsValidSelectionPoint
(
nsFrameSelection
*
aFrameSel
nsINode
*
aNode
)
;
#
ifdef
PRINT_RANGE
static
void
printRange
(
nsRange
*
aDomRange
)
;
#
define
DEBUG_OUT_RANGE
(
x
)
printRange
(
x
)
#
else
#
define
DEBUG_OUT_RANGE
(
x
)
#
endif
namespace
mozilla
{
const
char
*
ToChar
(
SelectionType
aSelectionType
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eInvalid
:
return
"
SelectionType
:
:
eInvalid
"
;
case
SelectionType
:
:
eNone
:
return
"
SelectionType
:
:
eNone
"
;
case
SelectionType
:
:
eNormal
:
return
"
SelectionType
:
:
eNormal
"
;
case
SelectionType
:
:
eSpellCheck
:
return
"
SelectionType
:
:
eSpellCheck
"
;
case
SelectionType
:
:
eIMERawClause
:
return
"
SelectionType
:
:
eIMERawClause
"
;
case
SelectionType
:
:
eIMESelectedRawClause
:
return
"
SelectionType
:
:
eIMESelectedRawClause
"
;
case
SelectionType
:
:
eIMEConvertedClause
:
return
"
SelectionType
:
:
eIMEConvertedClause
"
;
case
SelectionType
:
:
eIMESelectedClause
:
return
"
SelectionType
:
:
eIMESelectedClause
"
;
case
SelectionType
:
:
eAccessibility
:
return
"
SelectionType
:
:
eAccessibility
"
;
case
SelectionType
:
:
eFind
:
return
"
SelectionType
:
:
eFind
"
;
case
SelectionType
:
:
eURLSecondary
:
return
"
SelectionType
:
:
eURLSecondary
"
;
case
SelectionType
:
:
eURLStrikeout
:
return
"
SelectionType
:
:
eURLStrikeout
"
;
default
:
return
"
Invalid
SelectionType
"
;
}
}
}
struct
CachedOffsetForFrame
{
CachedOffsetForFrame
(
)
:
mCachedFrameOffset
(
0
0
)
mLastCaretFrame
(
nullptr
)
mLastContentOffset
(
0
)
mCanCacheFrameOffset
(
false
)
{
}
nsPoint
mCachedFrameOffset
;
nsIFrame
*
mLastCaretFrame
;
int32_t
mLastContentOffset
;
bool
mCanCacheFrameOffset
;
}
;
class
nsAutoScrollTimer
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
nsAutoScrollTimer
(
)
:
mFrameSelection
(
0
)
mSelection
(
0
)
mPresContext
(
0
)
mPoint
(
0
0
)
mDelay
(
30
)
{
}
nsresult
Start
(
nsPresContext
*
aPresContext
nsPoint
&
aPoint
)
{
mPoint
=
aPoint
;
mPresContext
=
aPresContext
;
mContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
if
(
!
mTimer
)
{
mTimer
=
NS_NewTimer
(
mPresContext
-
>
Document
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
if
(
!
mTimer
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
mTimer
-
>
InitWithCallback
(
this
mDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
nsresult
Stop
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
mContent
=
nullptr
;
return
NS_OK
;
}
nsresult
Init
(
nsFrameSelection
*
aFrameSelection
Selection
*
aSelection
)
{
mFrameSelection
=
aFrameSelection
;
mSelection
=
aSelection
;
return
NS_OK
;
}
nsresult
SetDelay
(
uint32_t
aDelay
)
{
mDelay
=
aDelay
;
return
NS_OK
;
}
NS_IMETHOD
Notify
(
nsITimer
*
timer
)
override
{
if
(
mSelection
&
&
mPresContext
)
{
AutoWeakFrame
frame
=
mContent
?
mPresContext
-
>
GetPrimaryFrameFor
(
mContent
)
:
nullptr
;
if
(
!
frame
)
{
return
NS_OK
;
}
mContent
=
nullptr
;
nsPoint
pt
=
mPoint
-
frame
-
>
GetOffsetTo
(
mPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
HandleDrag
(
frame
pt
)
;
if
(
!
frame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
frame
-
>
PresContext
(
)
=
=
mPresContext
"
document
mismatch
?
"
)
;
mSelection
-
>
DoAutoScroll
(
frame
pt
)
;
}
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
nsAutoScrollTimer
"
)
;
return
NS_OK
;
}
protected
:
virtual
~
nsAutoScrollTimer
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
private
:
nsFrameSelection
*
mFrameSelection
;
Selection
*
mSelection
;
nsPresContext
*
mPresContext
;
nsPoint
mPoint
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsCOMPtr
<
nsIContent
>
mContent
;
uint32_t
mDelay
;
}
;
NS_IMPL_ISUPPORTS
(
nsAutoScrollTimer
nsITimerCallback
nsINamed
)
bool
IsValidSelectionPoint
(
nsFrameSelection
*
aFrameSel
nsINode
*
aNode
)
{
if
(
!
aFrameSel
|
|
!
aNode
)
return
false
;
nsIContent
*
limiter
=
aFrameSel
-
>
GetLimiter
(
)
;
if
(
limiter
&
&
limiter
!
=
aNode
&
&
limiter
!
=
aNode
-
>
GetParent
(
)
)
{
return
false
;
}
limiter
=
aFrameSel
-
>
GetAncestorLimiter
(
)
;
return
!
limiter
|
|
nsContentUtils
:
:
ContentIsDescendantOf
(
aNode
limiter
)
;
}
namespace
mozilla
{
struct
MOZ_RAII
AutoPrepareFocusRange
{
AutoPrepareFocusRange
(
Selection
*
aSelection
bool
aContinueSelection
bool
aMultipleSelection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
aSelection
-
>
mRanges
.
Length
(
)
<
=
1
)
{
return
;
}
if
(
aSelection
-
>
mFrameSelection
-
>
IsUserSelectionReason
(
)
)
{
mUserSelect
.
emplace
(
aSelection
)
;
}
bool
userSelection
=
aSelection
-
>
mUserInitiated
;
nsTArray
<
RangeData
>
&
ranges
=
aSelection
-
>
mRanges
;
if
(
!
userSelection
|
|
(
!
aContinueSelection
&
&
aMultipleSelection
)
)
{
for
(
RangeData
&
entry
:
ranges
)
{
entry
.
mRange
-
>
SetIsGenerated
(
false
)
;
}
return
;
}
int16_t
reason
=
aSelection
-
>
mFrameSelection
-
>
mSelectionChangeReason
;
bool
isAnchorRelativeOp
=
(
reason
&
(
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
)
)
;
if
(
!
isAnchorRelativeOp
)
{
return
;
}
const
size_t
len
=
ranges
.
Length
(
)
;
size_t
newAnchorFocusIndex
=
size_t
(
-
1
)
;
if
(
aSelection
-
>
GetDirection
(
)
=
=
eDirNext
)
{
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
ranges
[
i
]
.
mRange
-
>
IsGenerated
(
)
)
{
newAnchorFocusIndex
=
i
;
break
;
}
}
}
else
{
size_t
i
=
len
;
while
(
i
-
-
)
{
if
(
ranges
[
i
]
.
mRange
-
>
IsGenerated
(
)
)
{
newAnchorFocusIndex
=
i
;
break
;
}
}
}
if
(
newAnchorFocusIndex
=
=
size_t
(
-
1
)
)
{
return
;
}
if
(
aSelection
-
>
mAnchorFocusRange
)
{
aSelection
-
>
mAnchorFocusRange
-
>
SetIsGenerated
(
true
)
;
}
nsRange
*
range
=
ranges
[
newAnchorFocusIndex
]
.
mRange
;
range
-
>
SetIsGenerated
(
false
)
;
aSelection
-
>
mAnchorFocusRange
=
range
;
RefPtr
<
nsPresContext
>
presContext
=
aSelection
-
>
GetPresContext
(
)
;
size_t
i
=
len
;
while
(
i
-
-
)
{
range
=
aSelection
-
>
mRanges
[
i
]
.
mRange
;
if
(
range
-
>
IsGenerated
(
)
)
{
range
-
>
SetSelection
(
nullptr
)
;
aSelection
-
>
SelectFrames
(
presContext
range
false
)
;
aSelection
-
>
mRanges
.
RemoveElementAt
(
i
)
;
}
}
if
(
aSelection
-
>
mFrameSelection
)
{
aSelection
-
>
mFrameSelection
-
>
InvalidateDesiredPos
(
)
;
}
}
Maybe
<
Selection
:
:
AutoUserInitiated
>
mUserSelect
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
#
ifdef
PRINT_RANGE
void
printRange
(
nsRange
*
aDomRange
)
{
if
(
!
aDomRange
)
{
printf
(
"
NULL
Range
\
n
"
)
;
}
nsINode
*
startNode
=
aDomRange
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
aDomRange
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
aDomRange
-
>
StartOffset
(
)
;
int32_t
endOffset
=
aDomRange
-
>
EndOffset
(
)
;
printf
(
"
range
:
0x
%
lx
\
t
start
:
0x
%
lx
%
ld
\
t
end
:
0x
%
lx
%
ld
\
n
"
(
unsigned
long
)
aDomRange
(
unsigned
long
)
startNode
(
long
)
startOffset
(
unsigned
long
)
endNode
(
long
)
endOffset
)
;
}
#
endif
void
Selection
:
:
Stringify
(
nsAString
&
aResult
)
{
nsCOMPtr
<
nsIPresShell
>
shell
=
mFrameSelection
?
mFrameSelection
-
>
GetShell
(
)
:
nullptr
;
if
(
!
shell
)
{
aResult
.
Truncate
(
)
;
return
;
}
shell
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
IgnoredErrorResult
rv
;
ToStringWithFormat
(
NS_LITERAL_STRING
(
"
text
/
plain
"
)
nsIDocumentEncoder
:
:
SkipInvisibleContent
0
aResult
rv
)
;
if
(
rv
.
Failed
(
)
)
{
aResult
.
Truncate
(
)
;
}
}
void
Selection
:
:
ToStringWithFormat
(
const
nsAString
&
aFormatType
uint32_t
aFlags
int32_t
aWrapCol
nsAString
&
aReturn
ErrorResult
&
aRv
)
{
nsresult
rv
=
NS_OK
;
NS_ConvertUTF8toUTF16
formatType
(
NS_DOC_ENCODER_CONTRACTID_BASE
)
;
formatType
.
Append
(
aFormatType
)
;
nsCOMPtr
<
nsIDocumentEncoder
>
encoder
=
do_CreateInstance
(
NS_ConvertUTF16toUTF8
(
formatType
)
.
get
(
)
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
nsIPresShell
*
shell
=
GetPresShell
(
)
;
if
(
!
shell
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIDocument
*
doc
=
shell
-
>
GetDocument
(
)
;
aFlags
|
=
nsIDocumentEncoder
:
:
OutputSelectionOnly
;
nsAutoString
readstring
;
readstring
.
Assign
(
aFormatType
)
;
rv
=
encoder
-
>
Init
(
doc
readstring
aFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
encoder
-
>
SetSelection
(
this
)
;
if
(
aWrapCol
!
=
0
)
encoder
-
>
SetWrapColumn
(
aWrapCol
)
;
rv
=
encoder
-
>
EncodeToString
(
aReturn
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
void
Selection
:
:
SetInterlinePosition
(
bool
aHintRight
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
mFrameSelection
-
>
SetHint
(
aHintRight
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
)
;
}
bool
Selection
:
:
GetInterlinePosition
(
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
false
;
}
return
mFrameSelection
-
>
GetHint
(
)
=
=
CARET_ASSOCIATE_AFTER
;
}
Nullable
<
int16_t
>
Selection
:
:
GetCaretBidiLevel
(
mozilla
:
:
ErrorResult
&
aRv
)
const
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
Nullable
<
int16_t
>
(
)
;
}
nsBidiLevel
caretBidiLevel
=
mFrameSelection
-
>
GetCaretBidiLevel
(
)
;
return
(
caretBidiLevel
&
BIDI_LEVEL_UNDEFINED
)
?
Nullable
<
int16_t
>
(
)
:
Nullable
<
int16_t
>
(
caretBidiLevel
)
;
}
void
Selection
:
:
SetCaretBidiLevel
(
const
Nullable
<
int16_t
>
&
aCaretBidiLevel
mozilla
:
:
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
aCaretBidiLevel
.
IsNull
(
)
)
{
mFrameSelection
-
>
UndefineCaretBidiLevel
(
)
;
}
else
{
mFrameSelection
-
>
SetCaretBidiLevel
(
aCaretBidiLevel
.
Value
(
)
)
;
}
}
nsresult
Selection
:
:
GetTableCellLocationFromRange
(
nsRange
*
aRange
TableSelection
*
aSelectionType
int32_t
*
aRow
int32_t
*
aCol
)
{
if
(
!
aRange
|
|
!
aSelectionType
|
|
!
aRow
|
|
!
aCol
)
return
NS_ERROR_NULL_POINTER
;
*
aSelectionType
=
TableSelection
:
:
None
;
*
aRow
=
0
;
*
aCol
=
0
;
if
(
!
mFrameSelection
)
return
NS_OK
;
nsresult
result
=
GetTableSelectionType
(
aRange
aSelectionType
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
*
aSelectionType
!
=
TableSelection
:
:
Cell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
child
=
aRange
-
>
GetChildAtStartOffset
(
)
;
if
(
!
child
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mFrameSelection
-
>
GetShell
(
)
;
if
(
presShell
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
if
(
!
mFrameSelection
|
|
!
mFrameSelection
-
>
GetShell
(
)
)
{
return
NS_ERROR_FAILURE
;
}
}
nsITableCellLayout
*
cellLayout
=
mFrameSelection
-
>
GetCellLayout
(
child
)
;
if
(
!
cellLayout
)
return
NS_ERROR_FAILURE
;
return
cellLayout
-
>
GetCellIndexes
(
*
aRow
*
aCol
)
;
}
nsresult
Selection
:
:
AddTableCellRange
(
nsRange
*
aRange
bool
*
aDidAddRange
int32_t
*
aOutIndex
)
{
if
(
!
aDidAddRange
|
|
!
aOutIndex
)
return
NS_ERROR_NULL_POINTER
;
*
aDidAddRange
=
false
;
*
aOutIndex
=
-
1
;
if
(
!
mFrameSelection
)
return
NS_OK
;
if
(
!
aRange
)
return
NS_ERROR_NULL_POINTER
;
nsresult
result
;
int32_t
newRow
newCol
;
TableSelection
tableMode
;
result
=
GetTableCellLocationFromRange
(
aRange
&
tableMode
&
newRow
&
newCol
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
tableMode
!
=
TableSelection
:
:
Cell
)
{
mFrameSelection
-
>
mSelectingTableCellMode
=
tableMode
;
return
NS_OK
;
}
if
(
mFrameSelection
-
>
mSelectingTableCellMode
=
=
TableSelection
:
:
None
)
mFrameSelection
-
>
mSelectingTableCellMode
=
tableMode
;
*
aDidAddRange
=
true
;
return
AddItem
(
aRange
aOutIndex
)
;
}
nsresult
Selection
:
:
GetTableSelectionType
(
nsRange
*
aRange
TableSelection
*
aTableSelectionType
)
{
if
(
!
aRange
|
|
!
aTableSelectionType
)
return
NS_ERROR_NULL_POINTER
;
*
aTableSelectionType
=
TableSelection
:
:
None
;
if
(
!
mFrameSelection
)
return
NS_OK
;
nsINode
*
startNode
=
aRange
-
>
GetStartContainer
(
)
;
if
(
!
startNode
)
return
NS_ERROR_FAILURE
;
nsINode
*
endNode
=
aRange
-
>
GetEndContainer
(
)
;
if
(
!
endNode
)
return
NS_ERROR_FAILURE
;
if
(
startNode
!
=
endNode
)
return
NS_OK
;
nsIContent
*
child
=
aRange
-
>
GetChildAtStartOffset
(
)
;
if
(
!
child
|
|
child
-
>
GetNextSibling
(
)
!
=
aRange
-
>
GetChildAtEndOffset
(
)
)
{
return
NS_OK
;
}
nsIContent
*
startContent
=
static_cast
<
nsIContent
*
>
(
startNode
)
;
if
(
!
(
startNode
-
>
IsElement
(
)
&
&
startContent
-
>
IsHTMLElement
(
)
)
)
{
return
NS_OK
;
}
if
(
startContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
*
aTableSelectionType
=
TableSelection
:
:
Cell
;
}
else
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
*
aTableSelectionType
=
TableSelection
:
:
Table
;
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
*
aTableSelectionType
=
TableSelection
:
:
Row
;
}
return
NS_OK
;
}
Selection
:
:
Selection
(
)
:
mCachedOffsetForFrame
(
nullptr
)
mDirection
(
eDirNext
)
mSelectionType
(
SelectionType
:
:
eNormal
)
mCustomColors
(
nullptr
)
mUserInitiated
(
false
)
mCalledByJS
(
false
)
mSelectionChangeBlockerCount
(
0
)
{
}
Selection
:
:
Selection
(
nsFrameSelection
*
aList
)
:
mFrameSelection
(
aList
)
mCachedOffsetForFrame
(
nullptr
)
mDirection
(
eDirNext
)
mSelectionType
(
SelectionType
:
:
eNormal
)
mCustomColors
(
nullptr
)
mUserInitiated
(
false
)
mCalledByJS
(
false
)
mSelectionChangeBlockerCount
(
0
)
{
}
Selection
:
:
~
Selection
(
)
{
SetAnchorFocusRange
(
-
1
)
;
uint32_t
count
=
mRanges
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
mRanges
[
i
]
.
mRange
-
>
SetSelection
(
nullptr
)
;
}
if
(
mAutoScrollTimer
)
{
mAutoScrollTimer
-
>
Stop
(
)
;
mAutoScrollTimer
=
nullptr
;
}
mScrollEvent
.
Revoke
(
)
;
if
(
mCachedOffsetForFrame
)
{
delete
mCachedOffsetForFrame
;
mCachedOffsetForFrame
=
nullptr
;
}
}
nsIDocument
*
Selection
:
:
GetParentObject
(
)
const
{
nsIPresShell
*
shell
=
GetPresShell
(
)
;
if
(
shell
)
{
return
shell
-
>
GetDocument
(
)
;
}
return
nullptr
;
}
DocGroup
*
Selection
:
:
GetDocGroup
(
)
const
{
nsIPresShell
*
shell
=
GetPresShell
(
)
;
if
(
!
shell
)
{
return
nullptr
;
}
nsIDocument
*
doc
=
shell
-
>
GetDocument
(
)
;
return
doc
?
doc
-
>
GetDocGroup
(
)
:
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Selection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Selection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectionListeners
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCachedRange
)
tmp
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFrameSelection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Selection
)
{
uint32_t
i
count
=
tmp
-
>
mRanges
.
Length
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRanges
[
i
]
.
mRange
)
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchorFocusRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCachedRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameSelection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectionListeners
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
Selection
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Selection
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_ADDREF
(
Selection
)
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_RELEASE
(
Selection
)
const
RangeBoundary
&
Selection
:
:
AnchorRef
(
)
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmpty
;
return
sEmpty
;
}
if
(
GetDirection
(
)
=
=
eDirNext
)
{
return
mAnchorFocusRange
-
>
StartRef
(
)
;
}
return
mAnchorFocusRange
-
>
EndRef
(
)
;
}
const
RangeBoundary
&
Selection
:
:
FocusRef
(
)
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmpty
;
return
sEmpty
;
}
if
(
GetDirection
(
)
=
=
eDirNext
)
{
return
mAnchorFocusRange
-
>
EndRef
(
)
;
}
return
mAnchorFocusRange
-
>
StartRef
(
)
;
}
void
Selection
:
:
SetAnchorFocusRange
(
int32_t
indx
)
{
if
(
indx
>
=
(
int32_t
)
mRanges
.
Length
(
)
)
return
;
if
(
indx
<
0
)
{
mAnchorFocusRange
=
nullptr
;
}
else
{
mAnchorFocusRange
=
mRanges
[
indx
]
.
mRange
;
}
}
static
nsresult
CompareToRangeStart
(
nsINode
*
aCompareNode
int32_t
aCompareOffset
nsRange
*
aRange
int32_t
*
aCmp
)
{
nsINode
*
start
=
aRange
-
>
GetStartContainer
(
)
;
NS_ENSURE_STATE
(
aCompareNode
&
&
start
)
;
if
(
aCompareNode
-
>
GetComposedDoc
(
)
!
=
start
-
>
GetComposedDoc
(
)
|
|
!
start
-
>
GetComposedDoc
(
)
|
|
aCompareNode
-
>
SubtreeRoot
(
)
!
=
start
-
>
SubtreeRoot
(
)
)
{
*
aCmp
=
1
;
}
else
{
*
aCmp
=
nsContentUtils
:
:
ComparePoints
(
aCompareNode
aCompareOffset
start
aRange
-
>
StartOffset
(
)
)
;
}
return
NS_OK
;
}
static
nsresult
CompareToRangeEnd
(
nsINode
*
aCompareNode
int32_t
aCompareOffset
nsRange
*
aRange
int32_t
*
aCmp
)
{
nsINode
*
end
=
aRange
-
>
GetEndContainer
(
)
;
NS_ENSURE_STATE
(
aCompareNode
&
&
end
)
;
if
(
aCompareNode
-
>
GetComposedDoc
(
)
!
=
end
-
>
GetComposedDoc
(
)
|
|
!
end
-
>
GetComposedDoc
(
)
|
|
aCompareNode
-
>
SubtreeRoot
(
)
!
=
end
-
>
SubtreeRoot
(
)
)
{
*
aCmp
=
1
;
}
else
{
*
aCmp
=
nsContentUtils
:
:
ComparePoints
(
aCompareNode
aCompareOffset
end
aRange
-
>
EndOffset
(
)
)
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
FindInsertionPoint
(
nsTArray
<
RangeData
>
*
aElementArray
nsINode
*
aPointNode
int32_t
aPointOffset
nsresult
(
*
aComparator
)
(
nsINode
*
int32_t
nsRange
*
int32_t
*
)
int32_t
*
aPoint
)
{
*
aPoint
=
0
;
int32_t
beginSearch
=
0
;
int32_t
endSearch
=
aElementArray
-
>
Length
(
)
;
if
(
endSearch
)
{
int32_t
center
=
endSearch
-
1
;
do
{
nsRange
*
range
=
(
*
aElementArray
)
[
center
]
.
mRange
;
int32_t
cmp
;
nsresult
rv
=
aComparator
(
aPointNode
aPointOffset
range
&
cmp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cmp
<
0
)
{
endSearch
=
center
;
}
else
if
(
cmp
>
0
)
{
beginSearch
=
center
+
1
;
}
else
{
beginSearch
=
center
;
break
;
}
center
=
(
endSearch
-
beginSearch
)
/
2
+
beginSearch
;
}
while
(
endSearch
-
beginSearch
>
0
)
;
}
*
aPoint
=
beginSearch
;
return
NS_OK
;
}
nsresult
Selection
:
:
SubtractRange
(
RangeData
*
aRange
nsRange
*
aSubtract
nsTArray
<
RangeData
>
*
aOutput
)
{
nsRange
*
range
=
aRange
-
>
mRange
;
int32_t
cmp
;
nsresult
rv
=
CompareToRangeStart
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
aSubtract
&
cmp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
cmp2
;
rv
=
CompareToRangeEnd
(
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
aSubtract
&
cmp2
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
cmp2
>
0
)
{
RefPtr
<
nsRange
>
postOverlap
=
new
nsRange
(
aSubtract
-
>
GetEndContainer
(
)
)
;
rv
=
postOverlap
-
>
SetStartAndEnd
(
aSubtract
-
>
GetEndContainer
(
)
aSubtract
-
>
EndOffset
(
)
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
postOverlap
-
>
Collapsed
(
)
)
{
if
(
!
aOutput
-
>
InsertElementAt
(
0
RangeData
(
postOverlap
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
(
*
aOutput
)
[
0
]
.
mTextRangeStyle
=
aRange
-
>
mTextRangeStyle
;
}
}
if
(
cmp
<
0
)
{
RefPtr
<
nsRange
>
preOverlap
=
new
nsRange
(
range
-
>
GetStartContainer
(
)
)
;
rv
=
preOverlap
-
>
SetStartAndEnd
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
aSubtract
-
>
GetStartContainer
(
)
aSubtract
-
>
StartOffset
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
preOverlap
-
>
Collapsed
(
)
)
{
if
(
!
aOutput
-
>
InsertElementAt
(
0
RangeData
(
preOverlap
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
(
*
aOutput
)
[
0
]
.
mTextRangeStyle
=
aRange
-
>
mTextRangeStyle
;
}
}
return
NS_OK
;
}
void
Selection
:
:
UserSelectRangesToAdd
(
nsRange
*
aItem
nsTArray
<
RefPtr
<
nsRange
>
>
&
aRangesToAdd
)
{
aItem
-
>
ExcludeNonSelectableNodes
(
&
aRangesToAdd
)
;
if
(
aRangesToAdd
.
IsEmpty
(
)
)
{
ErrorResult
err
;
nsINode
*
node
=
aItem
-
>
GetStartContainer
(
err
)
;
if
(
node
&
&
node
-
>
IsContent
(
)
&
&
node
-
>
AsContent
(
)
-
>
GetEditingHost
(
)
)
{
aItem
-
>
Collapse
(
GetDirection
(
)
=
=
eDirPrevious
)
;
aRangesToAdd
.
AppendElement
(
aItem
)
;
}
}
}
nsresult
Selection
:
:
AddItem
(
nsRange
*
aItem
int32_t
*
aOutIndex
bool
aNoStartSelect
)
{
if
(
!
aItem
)
return
NS_ERROR_NULL_POINTER
;
if
(
!
aItem
-
>
IsPositioned
(
)
)
return
NS_ERROR_UNEXPECTED
;
NS_ASSERTION
(
aOutIndex
"
aOutIndex
can
'
t
be
null
"
)
;
if
(
mUserInitiated
)
{
AutoTArray
<
RefPtr
<
nsRange
>
4
>
rangesToAdd
;
*
aOutIndex
=
int32_t
(
mRanges
.
Length
(
)
)
-
1
;
nsIDocument
*
doc
=
GetParentObject
(
)
;
bool
selectEventsEnabled
=
nsFrameSelection
:
:
sSelectionEventsEnabled
|
|
(
doc
&
&
nsContentUtils
:
:
IsSystemPrincipal
(
doc
-
>
NodePrincipal
(
)
)
)
;
if
(
!
aNoStartSelect
&
&
mSelectionType
=
=
SelectionType
:
:
eNormal
&
&
selectEventsEnabled
&
&
IsCollapsed
(
)
&
&
!
IsBlockingSelectionChangeEvents
(
)
)
{
RefPtr
<
nsRange
>
scratchRange
=
aItem
-
>
CloneRange
(
)
;
UserSelectRangesToAdd
(
scratchRange
rangesToAdd
)
;
bool
newRangesNonEmpty
=
rangesToAdd
.
Length
(
)
>
1
|
|
(
rangesToAdd
.
Length
(
)
=
=
1
&
&
!
rangesToAdd
[
0
]
-
>
Collapsed
(
)
)
;
MOZ_ASSERT
(
!
newRangesNonEmpty
|
|
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
if
(
newRangesNonEmpty
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
bool
defaultAction
=
true
;
bool
dispatchEvent
=
true
;
nsCOMPtr
<
nsINode
>
target
=
aItem
-
>
GetStartContainer
(
)
;
if
(
nsFrameSelection
:
:
sSelectionEventsOnTextControlsEnabled
)
{
while
(
target
&
&
target
-
>
IsInNativeAnonymousSubtree
(
)
)
{
target
=
target
-
>
GetParent
(
)
;
}
}
else
{
if
(
target
-
>
IsInNativeAnonymousSubtree
(
)
)
{
dispatchEvent
=
false
;
}
}
if
(
dispatchEvent
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
GetParentObject
(
)
target
NS_LITERAL_STRING
(
"
selectstart
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
&
defaultAction
)
;
if
(
!
defaultAction
)
{
return
NS_OK
;
}
if
(
!
aItem
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
}
rangesToAdd
.
ClearAndRetainStorage
(
)
;
}
UserSelectRangesToAdd
(
aItem
rangesToAdd
)
;
size_t
newAnchorFocusIndex
=
GetDirection
(
)
=
=
eDirPrevious
?
0
:
rangesToAdd
.
Length
(
)
-
1
;
for
(
size_t
i
=
0
;
i
<
rangesToAdd
.
Length
(
)
;
+
+
i
)
{
int32_t
index
;
nsresult
rv
=
AddItemInternal
(
rangesToAdd
[
i
]
&
index
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
i
=
=
newAnchorFocusIndex
)
{
*
aOutIndex
=
index
;
rangesToAdd
[
i
]
-
>
SetIsGenerated
(
false
)
;
}
else
{
rangesToAdd
[
i
]
-
>
SetIsGenerated
(
true
)
;
}
}
return
NS_OK
;
}
return
AddItemInternal
(
aItem
aOutIndex
)
;
}
nsresult
Selection
:
:
AddItemInternal
(
nsRange
*
aItem
int32_t
*
aOutIndex
)
{
MOZ_ASSERT
(
aItem
)
;
MOZ_ASSERT
(
aItem
-
>
IsPositioned
(
)
)
;
MOZ_ASSERT
(
aOutIndex
)
;
*
aOutIndex
=
-
1
;
if
(
mRanges
.
Length
(
)
=
=
0
)
{
if
(
!
mRanges
.
AppendElement
(
RangeData
(
aItem
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
aItem
-
>
SetSelection
(
this
)
;
*
aOutIndex
=
0
;
return
NS_OK
;
}
int32_t
startIndex
endIndex
;
nsresult
rv
=
GetIndicesForInterval
(
aItem
-
>
GetStartContainer
(
)
aItem
-
>
StartOffset
(
)
aItem
-
>
GetEndContainer
(
)
aItem
-
>
EndOffset
(
)
false
&
startIndex
&
endIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
endIndex
=
=
-
1
)
{
startIndex
=
0
;
endIndex
=
0
;
}
else
if
(
startIndex
=
=
-
1
)
{
startIndex
=
mRanges
.
Length
(
)
;
endIndex
=
startIndex
;
}
bool
sameRange
=
EqualsRangeAtPoint
(
aItem
-
>
GetStartContainer
(
)
aItem
-
>
StartOffset
(
)
aItem
-
>
GetEndContainer
(
)
aItem
-
>
EndOffset
(
)
startIndex
)
;
if
(
sameRange
)
{
*
aOutIndex
=
startIndex
;
return
NS_OK
;
}
if
(
startIndex
=
=
endIndex
)
{
if
(
!
mRanges
.
InsertElementAt
(
startIndex
RangeData
(
aItem
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
aItem
-
>
SetSelection
(
this
)
;
*
aOutIndex
=
startIndex
;
return
NS_OK
;
}
nsTArray
<
RangeData
>
overlaps
;
if
(
!
overlaps
.
InsertElementAt
(
0
mRanges
[
startIndex
]
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
endIndex
-
1
!
=
startIndex
)
{
if
(
!
overlaps
.
InsertElementAt
(
1
mRanges
[
endIndex
-
1
]
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
int32_t
i
=
startIndex
;
i
<
endIndex
;
+
+
i
)
{
mRanges
[
i
]
.
mRange
-
>
SetSelection
(
nullptr
)
;
}
mRanges
.
RemoveElementsAt
(
startIndex
endIndex
-
startIndex
)
;
nsTArray
<
RangeData
>
temp
;
for
(
int32_t
i
=
overlaps
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
nsresult
rv
=
SubtractRange
(
&
overlaps
[
i
]
aItem
&
temp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
insertionPoint
;
rv
=
FindInsertionPoint
(
&
temp
aItem
-
>
GetStartContainer
(
)
aItem
-
>
StartOffset
(
)
CompareToRangeStart
&
insertionPoint
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
temp
.
InsertElementAt
(
insertionPoint
RangeData
(
aItem
)
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
!
mRanges
.
InsertElementsAt
(
startIndex
temp
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
for
(
uint32_t
i
=
0
;
i
<
temp
.
Length
(
)
;
+
+
i
)
{
temp
[
i
]
.
mRange
-
>
SetSelection
(
this
)
;
}
*
aOutIndex
=
startIndex
+
insertionPoint
;
return
NS_OK
;
}
nsresult
Selection
:
:
RemoveItem
(
nsRange
*
aItem
)
{
if
(
!
aItem
)
return
NS_ERROR_NULL_POINTER
;
int32_t
idx
=
-
1
;
uint32_t
i
;
for
(
i
=
0
;
i
<
mRanges
.
Length
(
)
;
i
+
+
)
{
if
(
mRanges
[
i
]
.
mRange
=
=
aItem
)
{
idx
=
(
int32_t
)
i
;
break
;
}
}
if
(
idx
<
0
)
return
NS_ERROR_DOM_NOT_FOUND_ERR
;
mRanges
.
RemoveElementAt
(
idx
)
;
aItem
-
>
SetSelection
(
nullptr
)
;
return
NS_OK
;
}
nsresult
Selection
:
:
RemoveCollapsedRanges
(
)
{
uint32_t
i
=
0
;
while
(
i
<
mRanges
.
Length
(
)
)
{
if
(
mRanges
[
i
]
.
mRange
-
>
Collapsed
(
)
)
{
nsresult
rv
=
RemoveItem
(
mRanges
[
i
]
.
mRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
+
+
i
;
}
}
return
NS_OK
;
}
nsresult
Selection
:
:
Clear
(
nsPresContext
*
aPresContext
)
{
SetAnchorFocusRange
(
-
1
)
;
for
(
uint32_t
i
=
0
;
i
<
mRanges
.
Length
(
)
;
+
+
i
)
{
mRanges
[
i
]
.
mRange
-
>
SetSelection
(
nullptr
)
;
SelectFrames
(
aPresContext
mRanges
[
i
]
.
mRange
false
)
;
}
mRanges
.
Clear
(
)
;
SetDirection
(
eDirNext
)
;
if
(
mFrameSelection
&
&
mFrameSelection
-
>
GetDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
mFrameSelection
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
}
return
NS_OK
;
}
static
inline
bool
RangeMatchesBeginPoint
(
nsRange
*
aRange
nsINode
*
aNode
int32_t
aOffset
)
{
return
aRange
-
>
GetStartContainer
(
)
=
=
aNode
&
&
static_cast
<
int32_t
>
(
aRange
-
>
StartOffset
(
)
)
=
=
aOffset
;
}
static
inline
bool
RangeMatchesEndPoint
(
nsRange
*
aRange
nsINode
*
aNode
int32_t
aOffset
)
{
return
aRange
-
>
GetEndContainer
(
)
=
=
aNode
&
&
static_cast
<
int32_t
>
(
aRange
-
>
EndOffset
(
)
)
=
=
aOffset
;
}
bool
Selection
:
:
EqualsRangeAtPoint
(
nsINode
*
aBeginNode
int32_t
aBeginOffset
nsINode
*
aEndNode
int32_t
aEndOffset
int32_t
aRangeIndex
)
{
if
(
aRangeIndex
>
=
0
&
&
aRangeIndex
<
(
int32_t
)
mRanges
.
Length
(
)
)
{
nsRange
*
range
=
mRanges
[
aRangeIndex
]
.
mRange
;
if
(
RangeMatchesBeginPoint
(
range
aBeginNode
aBeginOffset
)
&
&
RangeMatchesEndPoint
(
range
aEndNode
aEndOffset
)
)
return
true
;
}
return
false
;
}
void
Selection
:
:
GetRangesForInterval
(
nsINode
&
aBeginNode
int32_t
aBeginOffset
nsINode
&
aEndNode
int32_t
aEndOffset
bool
aAllowAdjacent
nsTArray
<
RefPtr
<
nsRange
>
>
&
aReturn
mozilla
:
:
ErrorResult
&
aRv
)
{
nsTArray
<
nsRange
*
>
results
;
nsresult
rv
=
GetRangesForIntervalArray
(
&
aBeginNode
aBeginOffset
&
aEndNode
aEndOffset
aAllowAdjacent
&
results
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aReturn
.
SetLength
(
results
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
results
.
Length
(
)
;
+
+
i
)
{
aReturn
[
i
]
=
results
[
i
]
;
}
}
nsresult
Selection
:
:
GetRangesForIntervalArray
(
nsINode
*
aBeginNode
int32_t
aBeginOffset
nsINode
*
aEndNode
int32_t
aEndOffset
bool
aAllowAdjacent
nsTArray
<
nsRange
*
>
*
aRanges
)
{
aRanges
-
>
Clear
(
)
;
int32_t
startIndex
endIndex
;
nsresult
res
=
GetIndicesForInterval
(
aBeginNode
aBeginOffset
aEndNode
aEndOffset
aAllowAdjacent
&
startIndex
&
endIndex
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
startIndex
=
=
-
1
|
|
endIndex
=
=
-
1
)
return
NS_OK
;
for
(
int32_t
i
=
startIndex
;
i
<
endIndex
;
i
+
+
)
{
if
(
!
aRanges
-
>
AppendElement
(
mRanges
[
i
]
.
mRange
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
GetIndicesForInterval
(
nsINode
*
aBeginNode
int32_t
aBeginOffset
nsINode
*
aEndNode
int32_t
aEndOffset
bool
aAllowAdjacent
int32_t
*
aStartIndex
int32_t
*
aEndIndex
)
{
int32_t
startIndex
;
int32_t
endIndex
;
if
(
!
aStartIndex
)
aStartIndex
=
&
startIndex
;
if
(
!
aEndIndex
)
aEndIndex
=
&
endIndex
;
*
aStartIndex
=
-
1
;
*
aEndIndex
=
-
1
;
if
(
mRanges
.
Length
(
)
=
=
0
)
return
NS_OK
;
bool
intervalIsCollapsed
=
aBeginNode
=
=
aEndNode
&
&
aBeginOffset
=
=
aEndOffset
;
int32_t
endsBeforeIndex
;
if
(
NS_FAILED
(
FindInsertionPoint
(
&
mRanges
aEndNode
aEndOffset
&
CompareToRangeStart
&
endsBeforeIndex
)
)
)
{
return
NS_OK
;
}
if
(
endsBeforeIndex
=
=
0
)
{
nsRange
*
endRange
=
mRanges
[
endsBeforeIndex
]
.
mRange
;
if
(
!
RangeMatchesBeginPoint
(
endRange
aEndNode
aEndOffset
)
)
return
NS_OK
;
if
(
!
aAllowAdjacent
&
&
!
(
endRange
-
>
Collapsed
(
)
&
&
intervalIsCollapsed
)
)
return
NS_OK
;
}
*
aEndIndex
=
endsBeforeIndex
;
int32_t
beginsAfterIndex
;
if
(
NS_FAILED
(
FindInsertionPoint
(
&
mRanges
aBeginNode
aBeginOffset
&
CompareToRangeEnd
&
beginsAfterIndex
)
)
)
{
return
NS_OK
;
}
if
(
beginsAfterIndex
=
=
(
int32_t
)
mRanges
.
Length
(
)
)
return
NS_OK
;
if
(
aAllowAdjacent
)
{
while
(
endsBeforeIndex
<
(
int32_t
)
mRanges
.
Length
(
)
)
{
nsRange
*
endRange
=
mRanges
[
endsBeforeIndex
]
.
mRange
;
if
(
!
RangeMatchesBeginPoint
(
endRange
aEndNode
aEndOffset
)
)
break
;
endsBeforeIndex
+
+
;
}
nsRange
*
beginRange
=
mRanges
[
beginsAfterIndex
]
.
mRange
;
if
(
beginsAfterIndex
>
0
&
&
beginRange
-
>
Collapsed
(
)
&
&
RangeMatchesEndPoint
(
beginRange
aBeginNode
aBeginOffset
)
)
{
beginRange
=
mRanges
[
beginsAfterIndex
-
1
]
.
mRange
;
if
(
RangeMatchesEndPoint
(
beginRange
aBeginNode
aBeginOffset
)
)
beginsAfterIndex
-
-
;
}
}
else
{
nsRange
*
beginRange
=
mRanges
[
beginsAfterIndex
]
.
mRange
;
if
(
RangeMatchesEndPoint
(
beginRange
aBeginNode
aBeginOffset
)
&
&
!
beginRange
-
>
Collapsed
(
)
)
beginsAfterIndex
+
+
;
if
(
endsBeforeIndex
<
(
int32_t
)
mRanges
.
Length
(
)
)
{
nsRange
*
endRange
=
mRanges
[
endsBeforeIndex
]
.
mRange
;
if
(
RangeMatchesBeginPoint
(
endRange
aEndNode
aEndOffset
)
&
&
endRange
-
>
Collapsed
(
)
)
endsBeforeIndex
+
+
;
}
}
NS_ASSERTION
(
beginsAfterIndex
<
=
endsBeforeIndex
"
Is
mRanges
not
ordered
?
"
)
;
NS_ENSURE_STATE
(
beginsAfterIndex
<
=
endsBeforeIndex
)
;
*
aStartIndex
=
beginsAfterIndex
;
*
aEndIndex
=
endsBeforeIndex
;
return
NS_OK
;
}
nsresult
Selection
:
:
GetPrimaryFrameForAnchorNode
(
nsIFrame
*
*
aReturnFrame
)
{
if
(
!
aReturnFrame
)
return
NS_ERROR_NULL_POINTER
;
int32_t
frameOffset
=
0
;
*
aReturnFrame
=
0
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
GetAnchorNode
(
)
)
;
if
(
content
&
&
mFrameSelection
)
{
*
aReturnFrame
=
mFrameSelection
-
>
GetFrameForNodeOffset
(
content
AnchorOffset
(
)
mFrameSelection
-
>
GetHint
(
)
&
frameOffset
)
;
if
(
*
aReturnFrame
)
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
Selection
:
:
GetPrimaryFrameForFocusNode
(
nsIFrame
*
*
aReturnFrame
int32_t
*
aOffsetUsed
bool
aVisual
)
{
if
(
!
aReturnFrame
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aReturnFrame
=
nullptr
;
nsINode
*
focusNode
=
GetFocusNode
(
)
;
if
(
!
focusNode
|
|
!
focusNode
-
>
IsContent
(
)
|
|
!
mFrameSelection
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
content
=
focusNode
-
>
AsContent
(
)
;
int32_t
frameOffset
=
0
;
if
(
!
aOffsetUsed
)
{
aOffsetUsed
=
&
frameOffset
;
}
nsresult
rv
=
GetPrimaryOrCaretFrameForNodeOffset
(
content
FocusOffset
(
)
aReturnFrame
aOffsetUsed
aVisual
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
if
(
!
content
-
>
TextIsOnlyWhitespace
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
parent
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
offset
=
parent
-
>
ComputeIndexOf
(
content
)
;
return
GetPrimaryOrCaretFrameForNodeOffset
(
parent
offset
aReturnFrame
aOffsetUsed
aVisual
)
;
}
nsresult
Selection
:
:
GetPrimaryOrCaretFrameForNodeOffset
(
nsIContent
*
aContent
uint32_t
aOffset
nsIFrame
*
*
aReturnFrame
int32_t
*
aOffsetUsed
bool
aVisual
)
const
{
MOZ_ASSERT
(
aReturnFrame
)
;
MOZ_ASSERT
(
aOffsetUsed
)
;
*
aReturnFrame
=
nullptr
;
if
(
!
mFrameSelection
)
{
return
NS_ERROR_FAILURE
;
}
CaretAssociationHint
hint
=
mFrameSelection
-
>
GetHint
(
)
;
if
(
aVisual
)
{
nsBidiLevel
caretBidiLevel
=
mFrameSelection
-
>
GetCaretBidiLevel
(
)
;
return
nsCaret
:
:
GetCaretFrameForNodeOffset
(
mFrameSelection
aContent
aOffset
hint
caretBidiLevel
aReturnFrame
aOffsetUsed
)
;
}
*
aReturnFrame
=
mFrameSelection
-
>
GetFrameForNodeOffset
(
aContent
aOffset
hint
aOffsetUsed
)
;
if
(
!
*
aReturnFrame
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
Selection
:
:
SelectFramesForContent
(
nsIContent
*
aContent
bool
aSelected
)
{
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
textFrame
-
>
SetSelectedRange
(
0
aContent
-
>
GetText
(
)
-
>
GetLength
(
)
aSelected
mSelectionType
)
;
}
else
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
}
nsresult
Selection
:
:
SelectAllFramesForContent
(
nsIContentIterator
*
aInnerIter
nsIContent
*
aContent
bool
aSelected
)
{
if
(
!
aContent
-
>
HasChildren
(
)
)
{
SelectFramesForContent
(
aContent
aSelected
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
aInnerIter
-
>
Init
(
aContent
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
;
!
aInnerIter
-
>
IsDone
(
)
;
aInnerIter
-
>
Next
(
)
)
{
nsINode
*
node
=
aInnerIter
-
>
GetCurrentNode
(
)
;
MOZ_ASSERT
(
node
)
;
nsIContent
*
innercontent
=
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
SelectFramesForContent
(
innercontent
aSelected
)
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
SelectFrames
(
nsPresContext
*
aPresContext
nsRange
*
aRange
bool
aSelect
)
{
if
(
!
mFrameSelection
|
|
!
aPresContext
|
|
!
aPresContext
-
>
GetPresShell
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
aRange
&
&
aRange
-
>
IsPositioned
(
)
)
;
if
(
mFrameSelection
-
>
GetTableCellSelection
(
)
)
{
nsINode
*
node
=
aRange
-
>
GetCommonAncestor
(
)
;
nsIFrame
*
frame
=
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
:
aPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
frame
)
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
return
NS_OK
;
}
nsINode
*
startNode
=
aRange
-
>
GetStartContainer
(
)
;
nsIContent
*
startContent
=
startNode
-
>
IsContent
(
)
?
startNode
-
>
AsContent
(
)
:
nullptr
;
if
(
!
startContent
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
isFirstContentTextNode
=
startContent
-
>
IsText
(
)
;
nsINode
*
endNode
=
aRange
-
>
GetEndContainer
(
)
;
if
(
isFirstContentTextNode
)
{
nsIFrame
*
frame
=
startContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
uint32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
uint32_t
endOffset
;
if
(
endNode
=
=
startContent
)
{
endOffset
=
aRange
-
>
EndOffset
(
)
;
}
else
{
endOffset
=
startContent
-
>
Length
(
)
;
}
textFrame
-
>
SetSelectedRange
(
startOffset
endOffset
aSelect
mSelectionType
)
;
}
else
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
}
}
if
(
aRange
-
>
Collapsed
(
)
|
|
(
startNode
=
=
endNode
&
&
!
startNode
-
>
HasChildren
(
)
)
)
{
if
(
!
isFirstContentTextNode
)
{
SelectFramesForContent
(
startContent
aSelect
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentSubtreeIterator
(
)
;
iter
-
>
Init
(
aRange
)
;
if
(
isFirstContentTextNode
&
&
!
iter
-
>
IsDone
(
)
&
&
iter
-
>
GetCurrentNode
(
)
=
=
startNode
)
{
iter
-
>
Next
(
)
;
}
nsCOMPtr
<
nsIContentIterator
>
inneriter
=
NS_NewContentIterator
(
)
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
MOZ_ASSERT
(
node
)
;
nsIContent
*
content
=
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
SelectAllFramesForContent
(
inneriter
content
aSelect
)
;
}
if
(
endNode
!
=
startNode
)
{
nsIContent
*
endContent
=
endNode
-
>
IsContent
(
)
?
endNode
-
>
AsContent
(
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
endContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
endContent
-
>
IsText
(
)
)
{
nsIFrame
*
frame
=
endContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
textFrame
-
>
SetSelectedRange
(
0
aRange
-
>
EndOffset
(
)
aSelect
mSelectionType
)
;
}
}
}
return
NS_OK
;
}
UniquePtr
<
SelectionDetails
>
Selection
:
:
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
UniquePtr
<
SelectionDetails
>
aDetailsHead
SelectionType
aSelectionType
bool
aSlowCheck
)
{
if
(
!
aContent
)
{
return
aDetailsHead
;
}
if
(
mRanges
.
Length
(
)
=
=
0
)
{
return
aDetailsHead
;
}
nsTArray
<
nsRange
*
>
overlappingRanges
;
nsresult
rv
=
GetRangesForIntervalArray
(
aContent
aContentOffset
aContent
aContentOffset
+
aContentLength
false
&
overlappingRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
aDetailsHead
;
}
if
(
overlappingRanges
.
Length
(
)
=
=
0
)
{
return
aDetailsHead
;
}
UniquePtr
<
SelectionDetails
>
detailsHead
=
std
:
:
move
(
aDetailsHead
)
;
for
(
uint32_t
i
=
0
;
i
<
overlappingRanges
.
Length
(
)
;
i
+
+
)
{
nsRange
*
range
=
overlappingRanges
[
i
]
;
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
range
-
>
StartOffset
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
int32_t
start
=
-
1
end
=
-
1
;
if
(
startNode
=
=
aContent
&
&
endNode
=
=
aContent
)
{
if
(
startOffset
<
(
aContentOffset
+
aContentLength
)
&
&
endOffset
>
aContentOffset
)
{
start
=
std
:
:
max
(
0
startOffset
-
aContentOffset
)
;
end
=
std
:
:
min
(
aContentLength
endOffset
-
aContentOffset
)
;
}
}
else
if
(
startNode
=
=
aContent
)
{
if
(
startOffset
<
(
aContentOffset
+
aContentLength
)
)
{
start
=
std
:
:
max
(
0
startOffset
-
aContentOffset
)
;
end
=
aContentLength
;
}
}
else
if
(
endNode
=
=
aContent
)
{
if
(
endOffset
>
aContentOffset
)
{
start
=
0
;
end
=
std
:
:
min
(
aContentLength
endOffset
-
aContentOffset
)
;
}
}
else
{
start
=
0
;
end
=
aContentLength
;
}
if
(
start
<
0
)
continue
;
auto
newHead
=
MakeUnique
<
SelectionDetails
>
(
)
;
newHead
-
>
mNext
=
std
:
:
move
(
detailsHead
)
;
newHead
-
>
mStart
=
start
;
newHead
-
>
mEnd
=
end
;
newHead
-
>
mSelectionType
=
aSelectionType
;
RangeData
*
rd
=
FindRangeData
(
range
)
;
if
(
rd
)
{
newHead
-
>
mTextRangeStyle
=
rd
-
>
mTextRangeStyle
;
}
detailsHead
=
std
:
:
move
(
newHead
)
;
}
return
detailsHead
;
}
NS_IMETHODIMP
Selection
:
:
Repaint
(
nsPresContext
*
aPresContext
)
{
int32_t
arrCount
=
(
int32_t
)
mRanges
.
Length
(
)
;
if
(
arrCount
<
1
)
return
NS_OK
;
int32_t
i
;
for
(
i
=
0
;
i
<
arrCount
;
i
+
+
)
{
nsresult
rv
=
SelectFrames
(
aPresContext
mRanges
[
i
]
.
mRange
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
void
Selection
:
:
SetCanCacheFrameOffset
(
bool
aCanCacheFrameOffset
)
{
if
(
!
mCachedOffsetForFrame
)
{
mCachedOffsetForFrame
=
new
CachedOffsetForFrame
;
}
mCachedOffsetForFrame
-
>
mCanCacheFrameOffset
=
aCanCacheFrameOffset
;
if
(
!
aCanCacheFrameOffset
)
{
mCachedOffsetForFrame
-
>
mLastCaretFrame
=
nullptr
;
}
}
nsresult
Selection
:
:
GetCachedFrameOffset
(
nsIFrame
*
aFrame
int32_t
inOffset
nsPoint
&
aPoint
)
{
if
(
!
mCachedOffsetForFrame
)
{
mCachedOffsetForFrame
=
new
CachedOffsetForFrame
;
}
nsresult
rv
=
NS_OK
;
if
(
mCachedOffsetForFrame
-
>
mCanCacheFrameOffset
&
&
mCachedOffsetForFrame
-
>
mLastCaretFrame
&
&
(
aFrame
=
=
mCachedOffsetForFrame
-
>
mLastCaretFrame
)
&
&
(
inOffset
=
=
mCachedOffsetForFrame
-
>
mLastContentOffset
)
)
{
aPoint
=
mCachedOffsetForFrame
-
>
mCachedFrameOffset
;
}
else
{
rv
=
aFrame
-
>
GetPointFromOffset
(
inOffset
&
aPoint
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mCachedOffsetForFrame
-
>
mCanCacheFrameOffset
)
{
mCachedOffsetForFrame
-
>
mCachedFrameOffset
=
aPoint
;
mCachedOffsetForFrame
-
>
mLastCaretFrame
=
aFrame
;
mCachedOffsetForFrame
-
>
mLastContentOffset
=
inOffset
;
}
}
return
rv
;
}
nsIContent
*
Selection
:
:
GetAncestorLimiter
(
)
const
{
if
(
mFrameSelection
)
{
return
mFrameSelection
-
>
GetAncestorLimiter
(
)
;
}
return
nullptr
;
}
void
Selection
:
:
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
SetAncestorLimiter
(
aLimiter
)
;
}
}
RangeData
*
Selection
:
:
FindRangeData
(
nsRange
*
aRange
)
{
NS_ENSURE_TRUE
(
aRange
nullptr
)
;
for
(
uint32_t
i
=
0
;
i
<
mRanges
.
Length
(
)
;
i
+
+
)
{
if
(
mRanges
[
i
]
.
mRange
=
=
aRange
)
return
&
mRanges
[
i
]
;
}
return
nullptr
;
}
nsresult
Selection
:
:
SetTextRangeStyle
(
nsRange
*
aRange
const
TextRangeStyle
&
aTextRangeStyle
)
{
NS_ENSURE_ARG_POINTER
(
aRange
)
;
RangeData
*
rd
=
FindRangeData
(
aRange
)
;
if
(
rd
)
{
rd
-
>
mTextRangeStyle
=
aTextRangeStyle
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
StartAutoScrollTimer
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aDelay
)
{
MOZ_ASSERT
(
aFrame
"
Need
a
frame
"
)
;
nsresult
result
;
if
(
!
mFrameSelection
)
{
return
NS_OK
;
}
if
(
!
mAutoScrollTimer
)
{
mAutoScrollTimer
=
new
nsAutoScrollTimer
(
)
;
result
=
mAutoScrollTimer
-
>
Init
(
mFrameSelection
this
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
}
result
=
mAutoScrollTimer
-
>
SetDelay
(
aDelay
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
return
DoAutoScroll
(
aFrame
aPoint
)
;
}
nsresult
Selection
:
:
StopAutoScrollTimer
(
)
{
if
(
mAutoScrollTimer
)
{
return
mAutoScrollTimer
-
>
Stop
(
)
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
DoAutoScroll
(
nsIFrame
*
aFrame
nsPoint
aPoint
)
{
MOZ_ASSERT
(
aFrame
"
Need
a
frame
"
)
;
if
(
mAutoScrollTimer
)
{
(
void
)
mAutoScrollTimer
-
>
Stop
(
)
;
}
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
nsCOMPtr
<
nsIPresShell
>
shell
=
presContext
-
>
PresShell
(
)
;
nsRootPresContext
*
rootPC
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPC
)
return
NS_OK
;
nsIFrame
*
rootmostFrame
=
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
AutoWeakFrame
weakRootFrame
(
rootmostFrame
)
;
AutoWeakFrame
weakFrame
(
aFrame
)
;
nsPoint
globalPoint
=
aPoint
+
aFrame
-
>
GetOffsetToCrossDoc
(
rootmostFrame
)
;
bool
done
=
false
;
bool
didScroll
;
while
(
true
)
{
didScroll
=
shell
-
>
ScrollFrameRectIntoView
(
aFrame
nsRect
(
aPoint
nsSize
(
0
0
)
)
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
0
)
;
if
(
!
weakFrame
|
|
!
weakRootFrame
)
{
return
NS_OK
;
}
if
(
!
didScroll
&
&
!
done
)
{
RefPtr
<
nsDeviceContext
>
dx
=
shell
-
>
GetViewManager
(
)
-
>
GetDeviceContext
(
)
;
nsRect
screen
;
dx
-
>
GetRect
(
screen
)
;
nsPoint
screenPoint
=
globalPoint
+
rootmostFrame
-
>
GetScreenRectInAppUnits
(
)
.
TopLeft
(
)
;
nscoord
onePx
=
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
;
nscoord
scrollAmount
=
10
*
onePx
;
if
(
std
:
:
abs
(
screen
.
x
-
screenPoint
.
x
)
<
=
onePx
)
{
aPoint
.
x
-
=
scrollAmount
;
}
else
if
(
std
:
:
abs
(
screen
.
XMost
(
)
-
screenPoint
.
x
)
<
=
onePx
)
{
aPoint
.
x
+
=
scrollAmount
;
}
else
if
(
std
:
:
abs
(
screen
.
y
-
screenPoint
.
y
)
<
=
onePx
)
{
aPoint
.
y
-
=
scrollAmount
;
}
else
if
(
std
:
:
abs
(
screen
.
YMost
(
)
-
screenPoint
.
y
)
<
=
onePx
)
{
aPoint
.
y
+
=
scrollAmount
;
}
else
{
break
;
}
done
=
true
;
continue
;
}
break
;
}
if
(
didScroll
&
&
mAutoScrollTimer
)
{
nsPoint
presContextPoint
=
globalPoint
-
shell
-
>
GetRootFrame
(
)
-
>
GetOffsetToCrossDoc
(
rootmostFrame
)
;
mAutoScrollTimer
-
>
Start
(
presContext
presContextPoint
)
;
}
return
NS_OK
;
}
void
Selection
:
:
RemoveAllRanges
(
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
return
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
nsresult
result
=
Clear
(
presContext
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
ClearTableCellSelection
(
)
;
result
=
frameSelection
-
>
NotifySelectionListeners
(
GetType
(
)
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
}
}
nsresult
Selection
:
:
RemoveAllRangesTemporarily
(
)
{
if
(
!
mCachedRange
)
{
for
(
auto
&
rangeData
:
mRanges
)
{
auto
&
range
=
rangeData
.
mRange
;
if
(
range
-
>
GetRefCount
(
)
=
=
1
|
|
(
range
-
>
GetRefCount
(
)
=
=
2
&
&
range
=
=
mAnchorFocusRange
)
)
{
mCachedRange
=
range
;
break
;
}
}
}
ErrorResult
result
;
RemoveAllRanges
(
result
)
;
if
(
result
.
Failed
(
)
)
{
mCachedRange
=
nullptr
;
}
else
if
(
mCachedRange
)
{
mCachedRange
-
>
ResetTemporarily
(
)
;
}
return
result
.
StealNSResult
(
)
;
}
void
Selection
:
:
AddRangeJS
(
nsRange
&
aRange
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
AddRange
(
aRange
aRv
)
;
}
void
Selection
:
:
AddRange
(
nsRange
&
aRange
ErrorResult
&
aRv
)
{
return
AddRangeInternal
(
aRange
GetParentObject
(
)
aRv
)
;
}
void
Selection
:
:
AddRangeInternal
(
nsRange
&
aRange
nsIDocument
*
aDocument
ErrorResult
&
aRv
)
{
nsINode
*
rangeRoot
=
aRange
.
GetRoot
(
)
;
if
(
aDocument
!
=
rangeRoot
&
&
(
!
rangeRoot
|
|
aDocument
!
=
rangeRoot
-
>
GetComposedDoc
(
)
)
)
{
return
;
}
mCachedRange
=
nullptr
;
RefPtr
<
Selection
>
kungFuDeathGrip
(
this
)
;
bool
didAddRange
;
int32_t
rangeIndex
;
nsresult
result
=
AddTableCellRange
(
&
aRange
&
didAddRange
&
rangeIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
if
(
!
didAddRange
)
{
result
=
AddItem
(
&
aRange
&
rangeIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
}
if
(
rangeIndex
<
0
)
{
return
;
}
SetAnchorFocusRange
(
rangeIndex
)
;
if
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
{
SetInterlinePosition
(
true
IgnoreErrors
(
)
)
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
SelectFrames
(
presContext
&
aRange
true
)
;
if
(
!
mFrameSelection
)
return
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
result
=
frameSelection
-
>
NotifySelectionListeners
(
GetType
(
)
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
}
}
void
Selection
:
:
RemoveRange
(
nsRange
&
aRange
ErrorResult
&
aRv
)
{
nsresult
rv
=
RemoveItem
(
&
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
nsINode
*
beginNode
=
aRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRange
.
GetEndContainer
(
)
;
if
(
!
beginNode
|
|
!
endNode
)
{
return
;
}
int32_t
beginOffset
endOffset
;
if
(
endNode
-
>
IsText
(
)
)
{
beginOffset
=
0
;
endOffset
=
endNode
-
>
AsText
(
)
-
>
TextLength
(
)
;
}
else
{
beginOffset
=
aRange
.
StartOffset
(
)
;
endOffset
=
aRange
.
EndOffset
(
)
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
SelectFrames
(
presContext
&
aRange
false
)
;
nsTArray
<
nsRange
*
>
affectedRanges
;
rv
=
GetRangesForIntervalArray
(
beginNode
beginOffset
endNode
endOffset
true
&
affectedRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
for
(
uint32_t
i
=
0
;
i
<
affectedRanges
.
Length
(
)
;
i
+
+
)
{
SelectFrames
(
presContext
affectedRanges
[
i
]
true
)
;
}
int32_t
cnt
=
mRanges
.
Length
(
)
;
if
(
&
aRange
=
=
mAnchorFocusRange
)
{
SetAnchorFocusRange
(
cnt
-
1
)
;
if
(
mSelectionType
!
=
SelectionType
:
:
eSpellCheck
&
&
cnt
>
0
)
{
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
)
;
}
}
if
(
!
mFrameSelection
)
return
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
rv
=
frameSelection
-
>
NotifySelectionListeners
(
GetType
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
void
Selection
:
:
CollapseJS
(
nsINode
*
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
if
(
!
aContainer
)
{
RemoveAllRanges
(
aRv
)
;
return
;
}
Collapse
(
RawRangeBoundary
(
aContainer
aOffset
)
aRv
)
;
}
void
Selection
:
:
Collapse
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
!
aPoint
.
IsSet
(
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
if
(
aPoint
.
Container
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
if
(
!
HasSameRoot
(
*
aPoint
.
Container
(
)
)
)
{
return
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
InvalidateDesiredPos
(
)
;
if
(
!
IsValidSelectionPoint
(
frameSelection
aPoint
.
Container
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsresult
result
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
|
|
presContext
-
>
Document
(
)
!
=
aPoint
.
Container
(
)
-
>
OwnerDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
nsRange
>
oldRange
=
!
mRanges
.
IsEmpty
(
)
?
mRanges
[
0
]
.
mRange
:
nullptr
;
Clear
(
presContext
)
;
frameSelection
-
>
ClearTableCellSelection
(
)
;
if
(
frameSelection
-
>
GetHint
(
)
!
=
CARET_ASSOCIATE_AFTER
&
&
aPoint
.
Container
(
)
-
>
IsContent
(
)
)
{
int32_t
frameOffset
;
nsTextFrame
*
f
=
do_QueryFrame
(
nsCaret
:
:
GetFrameAndOffset
(
this
aPoint
.
Container
(
)
aPoint
.
Offset
(
)
&
frameOffset
)
)
;
if
(
f
&
&
f
-
>
IsAtEndOfLine
(
)
&
&
f
-
>
HasSignificantTerminalNewline
(
)
)
{
if
(
(
aPoint
.
Container
(
)
-
>
AsContent
(
)
=
=
f
-
>
GetContent
(
)
&
&
f
-
>
GetContentEnd
(
)
=
=
static_cast
<
int32_t
>
(
aPoint
.
Offset
(
)
)
)
|
|
(
aPoint
.
Container
(
)
=
=
f
-
>
GetContent
(
)
-
>
GetParentNode
(
)
&
&
f
-
>
GetContent
(
)
=
=
aPoint
.
GetPreviousSiblingOfChildAtOffset
(
)
)
)
{
frameSelection
-
>
SetHint
(
CARET_ASSOCIATE_AFTER
)
;
}
}
}
RefPtr
<
nsRange
>
range
;
if
(
oldRange
&
&
oldRange
-
>
GetRefCount
(
)
=
=
1
)
{
range
=
std
:
:
move
(
oldRange
)
;
}
else
if
(
mCachedRange
)
{
range
=
std
:
:
move
(
mCachedRange
)
;
}
else
{
range
=
new
nsRange
(
aPoint
.
Container
(
)
)
;
}
result
=
range
-
>
CollapseTo
(
aPoint
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
#
ifdef
DEBUG_SELECTION
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aPoint
.
Container
(
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
aPoint
.
Container
(
)
)
;
printf
(
"
Sel
.
Collapse
to
%
p
%
s
%
d
\
n
"
container
.
get
(
)
content
?
nsAtomCString
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
:
(
doc
?
"
DOCUMENT
"
:
"
?
?
?
"
)
aPoint
.
Offset
(
)
)
;
#
endif
int32_t
rangeIndex
=
-
1
;
result
=
AddItem
(
range
&
rangeIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
SetAnchorFocusRange
(
0
)
;
SelectFrames
(
presContext
range
true
)
;
result
=
frameSelection
-
>
NotifySelectionListeners
(
GetType
(
)
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
}
}
void
Selection
:
:
CollapseToStartJS
(
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
CollapseToStart
(
aRv
)
;
}
void
Selection
:
:
CollapseToStart
(
ErrorResult
&
aRv
)
{
if
(
RangeCount
(
)
=
=
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsRange
*
firstRange
=
mRanges
[
0
]
.
mRange
;
if
(
!
firstRange
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mFrameSelection
)
{
int16_t
reason
=
mFrameSelection
-
>
PopReason
(
)
|
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
;
mFrameSelection
-
>
PostReason
(
reason
)
;
}
nsINode
*
container
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
!
container
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Collapse
(
*
container
firstRange
-
>
StartOffset
(
)
aRv
)
;
}
void
Selection
:
:
CollapseToEndJS
(
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
CollapseToEnd
(
aRv
)
;
}
void
Selection
:
:
CollapseToEnd
(
ErrorResult
&
aRv
)
{
uint32_t
cnt
=
RangeCount
(
)
;
if
(
cnt
=
=
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsRange
*
lastRange
=
mRanges
[
cnt
-
1
]
.
mRange
;
if
(
!
lastRange
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mFrameSelection
)
{
int16_t
reason
=
mFrameSelection
-
>
PopReason
(
)
|
nsISelectionListener
:
:
COLLAPSETOEND_REASON
;
mFrameSelection
-
>
PostReason
(
reason
)
;
}
nsINode
*
container
=
lastRange
-
>
GetEndContainer
(
)
;
if
(
!
container
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Collapse
(
*
container
lastRange
-
>
EndOffset
(
)
aRv
)
;
}
void
Selection
:
:
GetType
(
nsAString
&
aOutType
)
const
{
if
(
!
RangeCount
(
)
)
{
aOutType
.
AssignLiteral
(
"
None
"
)
;
}
else
if
(
IsCollapsed
(
)
)
{
aOutType
.
AssignLiteral
(
"
Caret
"
)
;
}
else
{
aOutType
.
AssignLiteral
(
"
Range
"
)
;
}
}
nsRange
*
Selection
:
:
GetRangeAt
(
uint32_t
aIndex
ErrorResult
&
aRv
)
{
nsRange
*
range
=
GetRangeAt
(
aIndex
)
;
if
(
!
range
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
return
range
;
}
nsRange
*
Selection
:
:
GetRangeAt
(
int32_t
aIndex
)
const
{
RangeData
empty
(
nullptr
)
;
return
mRanges
.
SafeElementAt
(
aIndex
empty
)
.
mRange
;
}
nsresult
Selection
:
:
SetAnchorFocusToRange
(
nsRange
*
aRange
)
{
NS_ENSURE_STATE
(
mAnchorFocusRange
)
;
bool
collapsed
=
IsCollapsed
(
)
;
nsresult
res
=
RemoveItem
(
mAnchorFocusRange
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
int32_t
aOutIndex
=
-
1
;
res
=
AddItem
(
aRange
&
aOutIndex
!
collapsed
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
SetAnchorFocusRange
(
aOutIndex
)
;
return
NS_OK
;
}
void
Selection
:
:
ReplaceAnchorFocusRange
(
nsRange
*
aRange
)
{
NS_ENSURE_TRUE_VOID
(
mAnchorFocusRange
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
SelectFrames
(
presContext
mAnchorFocusRange
false
)
;
SetAnchorFocusToRange
(
aRange
)
;
SelectFrames
(
presContext
mAnchorFocusRange
true
)
;
}
}
void
Selection
:
:
AdjustAnchorFocusForMultiRange
(
nsDirection
aDirection
)
{
if
(
aDirection
=
=
mDirection
)
{
return
;
}
SetDirection
(
aDirection
)
;
if
(
RangeCount
(
)
<
=
1
)
{
return
;
}
nsRange
*
firstRange
=
GetRangeAt
(
0
)
;
nsRange
*
lastRange
=
GetRangeAt
(
RangeCount
(
)
-
1
)
;
if
(
mDirection
=
=
eDirPrevious
)
{
firstRange
-
>
SetIsGenerated
(
false
)
;
lastRange
-
>
SetIsGenerated
(
true
)
;
SetAnchorFocusRange
(
0
)
;
}
else
{
firstRange
-
>
SetIsGenerated
(
true
)
;
lastRange
-
>
SetIsGenerated
(
false
)
;
SetAnchorFocusRange
(
RangeCount
(
)
-
1
)
;
}
}
void
Selection
:
:
ExtendJS
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
Extend
(
aContainer
aOffset
aRv
)
;
}
nsresult
Selection
:
:
Extend
(
nsINode
*
aContainer
int32_t
aOffset
)
{
if
(
!
aContainer
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
result
;
Extend
(
*
aContainer
static_cast
<
uint32_t
>
(
aOffset
)
result
)
;
return
result
.
StealNSResult
(
)
;
}
void
Selection
:
:
Extend
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
mAnchorFocusRange
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
!
HasSameRoot
(
aContainer
)
)
{
return
;
}
nsresult
res
;
if
(
!
IsValidSelectionPoint
(
mFrameSelection
&
aContainer
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
|
|
presContext
-
>
Document
(
)
!
=
aContainer
.
OwnerDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
#
ifdef
DEBUG_SELECTION
nsDirection
oldDirection
=
GetDirection
(
)
;
#
endif
nsINode
*
anchorNode
=
GetAnchorNode
(
)
;
nsINode
*
focusNode
=
GetFocusNode
(
)
;
uint32_t
anchorOffset
=
AnchorOffset
(
)
;
uint32_t
focusOffset
=
FocusOffset
(
)
;
RefPtr
<
nsRange
>
range
=
mAnchorFocusRange
-
>
CloneRange
(
)
;
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
range
-
>
StartOffset
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
bool
disconnected
=
false
;
bool
shouldClearRange
=
false
;
int32_t
result1
=
nsContentUtils
:
:
ComparePoints
(
anchorNode
anchorOffset
focusNode
focusOffset
&
disconnected
)
;
shouldClearRange
|
=
disconnected
;
int32_t
result2
=
nsContentUtils
:
:
ComparePoints
(
focusNode
focusOffset
&
aContainer
aOffset
&
disconnected
)
;
shouldClearRange
|
=
disconnected
;
int32_t
result3
=
nsContentUtils
:
:
ComparePoints
(
anchorNode
anchorOffset
&
aContainer
aOffset
&
disconnected
)
;
if
(
shouldClearRange
)
{
SelectFrames
(
presContext
range
false
)
;
}
RefPtr
<
nsRange
>
difRange
=
new
nsRange
(
&
aContainer
)
;
if
(
(
result1
=
=
0
&
&
result3
<
0
)
|
|
(
result1
<
=
0
&
&
result2
<
0
)
)
{
range
-
>
SetEnd
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetDirection
(
eDirNext
)
;
res
=
difRange
-
>
SetStartAndEnd
(
focusNode
focusOffset
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
true
)
;
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
else
if
(
result1
=
=
0
&
&
result3
>
0
)
{
SetDirection
(
eDirPrevious
)
;
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SelectFrames
(
presContext
range
true
)
;
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
else
if
(
result3
<
=
0
&
&
result2
>
=
0
)
{
res
=
difRange
-
>
SetStartAndEnd
(
&
aContainer
aOffset
focusNode
focusOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
range
-
>
SetEnd
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
difRange
-
>
SetEnd
(
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
;
SelectFrames
(
presContext
difRange
true
)
;
}
else
if
(
result1
>
=
0
&
&
result3
<
=
0
)
{
if
(
GetDirection
(
)
=
=
eDirPrevious
)
{
res
=
range
-
>
SetStart
(
endNode
endOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
SetDirection
(
eDirNext
)
;
range
-
>
SetEnd
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
focusNode
!
=
anchorNode
|
|
focusOffset
!
=
anchorOffset
)
{
res
=
difRange
-
>
SetStart
(
focusNode
focusOffset
)
;
nsresult
tmp
=
difRange
-
>
SetEnd
(
anchorNode
anchorOffset
)
;
if
(
NS_FAILED
(
tmp
)
)
{
res
=
tmp
;
}
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
}
else
{
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
SelectFrames
(
presContext
range
true
)
;
}
else
if
(
result2
<
=
0
&
&
result3
>
=
0
)
{
res
=
difRange
-
>
SetStartAndEnd
(
focusNode
focusOffset
&
aContainer
aOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SetDirection
(
eDirPrevious
)
;
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
difRange
-
>
SetStart
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
)
;
SelectFrames
(
presContext
difRange
true
)
;
}
else
if
(
result3
>
=
0
&
&
result1
<
=
0
)
{
if
(
GetDirection
(
)
=
=
eDirNext
)
{
range
-
>
SetEnd
(
startNode
startOffset
)
;
}
SetDirection
(
eDirPrevious
)
;
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
focusNode
!
=
anchorNode
|
|
focusOffset
!
=
anchorOffset
)
{
res
=
difRange
-
>
SetStartAndEnd
(
anchorNode
anchorOffset
focusNode
focusOffset
)
;
nsresult
tmp
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
tmp
)
)
{
res
=
tmp
;
}
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
}
else
{
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
SelectFrames
(
presContext
range
true
)
;
}
else
if
(
result2
>
=
0
&
&
result1
>
=
0
)
{
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetDirection
(
eDirPrevious
)
;
res
=
difRange
-
>
SetStartAndEnd
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
focusNode
focusOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
true
)
;
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
if
(
mRanges
.
Length
(
)
>
1
)
{
for
(
size_t
i
=
0
;
i
<
mRanges
.
Length
(
)
;
+
+
i
)
{
nsRange
*
range
=
mRanges
[
i
]
.
mRange
;
MOZ_ASSERT
(
range
-
>
IsInSelection
(
)
)
;
SelectFrames
(
presContext
range
range
-
>
IsInSelection
(
)
)
;
}
}
DEBUG_OUT_RANGE
(
range
)
;
#
ifdef
DEBUG_SELECTION
if
(
GetDirection
(
)
!
=
oldDirection
)
{
printf
(
"
direction
changed
to
%
s
\
n
"
GetDirection
(
)
=
=
eDirNext
?
"
eDirNext
"
:
"
eDirPrevious
"
)
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
&
aContainer
)
;
printf
(
"
Sel
.
Extend
to
%
p
%
s
%
d
\
n
"
content
.
get
(
)
nsAtomCString
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
aOffset
)
;
#
endif
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
res
=
frameSelection
-
>
NotifySelectionListeners
(
GetType
(
)
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
}
}
void
Selection
:
:
SelectAllChildrenJS
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
SelectAllChildren
(
aNode
aRv
)
;
}
void
Selection
:
:
SelectAllChildren
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
aNode
.
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
if
(
!
HasSameRoot
(
aNode
)
)
{
return
;
}
if
(
mFrameSelection
)
{
mFrameSelection
-
>
PostReason
(
nsISelectionListener
:
:
SELECTALL_REASON
)
;
}
SelectionBatcher
batch
(
this
)
;
Collapse
(
aNode
0
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
Extend
(
aNode
aNode
.
GetChildCount
(
)
aRv
)
;
}
bool
Selection
:
:
ContainsNode
(
nsINode
&
aNode
bool
aAllowPartial
ErrorResult
&
aRv
)
{
nsresult
rv
;
if
(
mRanges
.
Length
(
)
=
=
0
)
{
return
false
;
}
uint32_t
nodeLength
;
auto
*
nodeAsCharData
=
CharacterData
:
:
FromNode
(
aNode
)
;
if
(
nodeAsCharData
)
{
nodeLength
=
nodeAsCharData
-
>
TextLength
(
)
;
}
else
{
nodeLength
=
aNode
.
GetChildCount
(
)
;
}
nsTArray
<
nsRange
*
>
overlappingRanges
;
rv
=
GetRangesForIntervalArray
(
&
aNode
0
&
aNode
nodeLength
false
&
overlappingRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
false
;
}
if
(
overlappingRanges
.
Length
(
)
=
=
0
)
return
false
;
if
(
aAllowPartial
)
{
return
true
;
}
if
(
nodeAsCharData
)
{
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
overlappingRanges
.
Length
(
)
;
i
+
+
)
{
bool
nodeStartsBeforeRange
nodeEndsAfterRange
;
if
(
NS_SUCCEEDED
(
nsRange
:
:
CompareNodeToRange
(
&
aNode
overlappingRanges
[
i
]
&
nodeStartsBeforeRange
&
nodeEndsAfterRange
)
)
)
{
if
(
!
nodeStartsBeforeRange
&
&
!
nodeEndsAfterRange
)
{
return
true
;
}
}
}
return
false
;
}
class
PointInRectChecker
:
public
nsLayoutUtils
:
:
RectCallback
{
public
:
explicit
PointInRectChecker
(
const
nsPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mMatchFound
(
false
)
{
}
void
AddRect
(
const
nsRect
&
aRect
)
override
{
mMatchFound
=
mMatchFound
|
|
aRect
.
Contains
(
mPoint
)
;
}
bool
MatchFound
(
)
{
return
mMatchFound
;
}
private
:
nsPoint
mPoint
;
bool
mMatchFound
;
}
;
bool
Selection
:
:
ContainsPoint
(
const
nsPoint
&
aPoint
)
{
if
(
IsCollapsed
(
)
)
{
return
false
;
}
PointInRectChecker
checker
(
aPoint
)
;
for
(
uint32_t
i
=
0
;
i
<
RangeCount
(
)
;
i
+
+
)
{
nsRange
*
range
=
GetRangeAt
(
i
)
;
nsRange
:
:
CollectClientRectsAndText
(
&
checker
nullptr
range
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
true
false
)
;
if
(
checker
.
MatchFound
(
)
)
{
return
true
;
}
}
return
false
;
}
nsPresContext
*
Selection
:
:
GetPresContext
(
)
const
{
nsIPresShell
*
shell
=
GetPresShell
(
)
;
if
(
!
shell
)
{
return
nullptr
;
}
return
shell
-
>
GetPresContext
(
)
;
}
nsIPresShell
*
Selection
:
:
GetPresShell
(
)
const
{
if
(
!
mFrameSelection
)
return
nullptr
;
return
mFrameSelection
-
>
GetShell
(
)
;
}
nsIDocument
*
Selection
:
:
GetDocument
(
)
const
{
nsIPresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetDocument
(
)
:
nullptr
;
}
nsPIDOMWindowOuter
*
Selection
:
:
GetWindow
(
)
const
{
nsIDocument
*
document
=
GetDocument
(
)
;
return
document
?
document
-
>
GetWindow
(
)
:
nullptr
;
}
HTMLEditor
*
Selection
:
:
GetHTMLEditor
(
)
const
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
nullptr
;
}
return
nsContentUtils
:
:
GetHTMLEditor
(
presContext
)
;
}
nsIFrame
*
Selection
:
:
GetSelectionAnchorGeometry
(
SelectionRegion
aRegion
nsRect
*
aRect
)
{
if
(
!
mFrameSelection
)
return
nullptr
;
NS_ENSURE_TRUE
(
aRect
nullptr
)
;
aRect
-
>
SetRect
(
0
0
0
0
)
;
switch
(
aRegion
)
{
case
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
:
case
nsISelectionController
:
:
SELECTION_FOCUS_REGION
:
return
GetSelectionEndPointGeometry
(
aRegion
aRect
)
;
case
nsISelectionController
:
:
SELECTION_WHOLE_SELECTION
:
break
;
default
:
return
nullptr
;
}
NS_ASSERTION
(
aRegion
=
=
nsISelectionController
:
:
SELECTION_WHOLE_SELECTION
"
should
only
be
SELECTION_WHOLE_SELECTION
here
"
)
;
nsRect
anchorRect
;
nsIFrame
*
anchorFrame
=
GetSelectionEndPointGeometry
(
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
&
anchorRect
)
;
if
(
!
anchorFrame
)
return
nullptr
;
nsRect
focusRect
;
nsIFrame
*
focusFrame
=
GetSelectionEndPointGeometry
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
&
focusRect
)
;
if
(
!
focusFrame
)
return
nullptr
;
NS_ASSERTION
(
anchorFrame
-
>
PresContext
(
)
=
=
focusFrame
-
>
PresContext
(
)
"
points
of
selection
in
different
documents
?
"
)
;
focusRect
+
=
focusFrame
-
>
GetOffsetTo
(
anchorFrame
)
;
aRect
-
>
UnionRectEdges
(
anchorRect
focusRect
)
;
return
anchorFrame
;
}
nsIFrame
*
Selection
:
:
GetSelectionEndPointGeometry
(
SelectionRegion
aRegion
nsRect
*
aRect
)
{
if
(
!
mFrameSelection
)
return
nullptr
;
NS_ENSURE_TRUE
(
aRect
nullptr
)
;
aRect
-
>
SetRect
(
0
0
0
0
)
;
nsINode
*
node
=
nullptr
;
uint32_t
nodeOffset
=
0
;
nsIFrame
*
frame
=
nullptr
;
switch
(
aRegion
)
{
case
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
:
node
=
GetAnchorNode
(
)
;
nodeOffset
=
AnchorOffset
(
)
;
break
;
case
nsISelectionController
:
:
SELECTION_FOCUS_REGION
:
node
=
GetFocusNode
(
)
;
nodeOffset
=
FocusOffset
(
)
;
break
;
default
:
return
nullptr
;
}
if
(
!
node
)
return
nullptr
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
NS_ENSURE_TRUE
(
content
.
get
(
)
nullptr
)
;
int32_t
frameOffset
=
0
;
frame
=
mFrameSelection
-
>
GetFrameForNodeOffset
(
content
nodeOffset
mFrameSelection
-
>
GetHint
(
)
&
frameOffset
)
;
if
(
!
frame
)
return
nullptr
;
bool
isText
=
node
-
>
IsText
(
)
;
nsPoint
pt
(
0
0
)
;
if
(
isText
)
{
nsIFrame
*
childFrame
=
nullptr
;
frameOffset
=
0
;
nsresult
rv
=
frame
-
>
GetChildFrameContainingOffset
(
nodeOffset
mFrameSelection
-
>
GetHint
(
)
&
frameOffset
&
childFrame
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
if
(
!
childFrame
)
return
nullptr
;
frame
=
childFrame
;
rv
=
GetCachedFrameOffset
(
frame
nodeOffset
pt
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
}
if
(
isText
)
{
aRect
-
>
x
=
pt
.
x
;
}
else
if
(
mFrameSelection
-
>
GetHint
(
)
=
=
CARET_ASSOCIATE_BEFORE
)
{
aRect
-
>
x
=
frame
-
>
GetRect
(
)
.
Width
(
)
;
}
aRect
-
>
SetHeight
(
frame
-
>
GetRect
(
)
.
Height
(
)
)
;
return
frame
;
}
NS_IMETHODIMP
Selection
:
:
ScrollSelectionIntoViewEvent
:
:
Run
(
)
{
if
(
!
mSelection
)
return
NS_OK
;
int32_t
flags
=
Selection
:
:
SCROLL_DO_FLUSH
|
Selection
:
:
SCROLL_SYNCHRONOUS
;
Selection
*
sel
=
mSelection
;
RefPtr
<
Selection
>
kungFuDeathGrip
(
sel
)
;
mSelection
-
>
mScrollEvent
.
Forget
(
)
;
mSelection
-
>
ScrollIntoView
(
mRegion
mVerticalScroll
mHorizontalScroll
mFlags
|
flags
)
;
return
NS_OK
;
}
nsresult
Selection
:
:
PostScrollSelectionIntoViewEvent
(
SelectionRegion
aRegion
int32_t
aFlags
nsIPresShell
:
:
ScrollAxis
aVertical
nsIPresShell
:
:
ScrollAxis
aHorizontal
)
{
mScrollEvent
.
Revoke
(
)
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
NS_ENSURE_STATE
(
presContext
)
;
nsRefreshDriver
*
refreshDriver
=
presContext
-
>
RefreshDriver
(
)
;
NS_ENSURE_STATE
(
refreshDriver
)
;
mScrollEvent
=
new
ScrollSelectionIntoViewEvent
(
this
aRegion
aVertical
aHorizontal
aFlags
)
;
refreshDriver
-
>
AddEarlyRunner
(
mScrollEvent
.
get
(
)
)
;
return
NS_OK
;
}
void
Selection
:
:
ScrollIntoView
(
int16_t
aRegion
bool
aIsSynchronous
int16_t
aVPercent
int16_t
aHPercent
ErrorResult
&
aRv
)
{
int32_t
flags
=
aIsSynchronous
?
Selection
:
:
SCROLL_SYNCHRONOUS
:
0
;
nsresult
rv
=
ScrollIntoView
(
aRegion
nsIPresShell
:
:
ScrollAxis
(
aVPercent
)
nsIPresShell
:
:
ScrollAxis
(
aHPercent
)
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
nsresult
Selection
:
:
ScrollIntoView
(
SelectionRegion
aRegion
nsIPresShell
:
:
ScrollAxis
aVertical
nsIPresShell
:
:
ScrollAxis
aHorizontal
int32_t
aFlags
)
{
if
(
!
mFrameSelection
)
return
NS_OK
;
nsIPresShell
*
presShell
=
mFrameSelection
-
>
GetShell
(
)
;
if
(
!
presShell
)
return
NS_OK
;
if
(
mFrameSelection
-
>
GetBatching
(
)
)
return
NS_OK
;
if
(
!
(
aFlags
&
Selection
:
:
SCROLL_SYNCHRONOUS
)
)
return
PostScrollSelectionIntoViewEvent
(
aRegion
aFlags
aVertical
aHorizontal
)
;
nsCOMPtr
<
nsIPresShell
>
kungFuDeathGrip
(
presShell
)
;
if
(
aFlags
&
Selection
:
:
SCROLL_DO_FLUSH
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
presShell
=
mFrameSelection
?
mFrameSelection
-
>
GetShell
(
)
:
nullptr
;
if
(
!
presShell
)
return
NS_OK
;
}
nsRect
rect
;
nsIFrame
*
frame
=
GetSelectionAnchorGeometry
(
aRegion
&
rect
)
;
if
(
!
frame
)
return
NS_ERROR_FAILURE
;
aVertical
.
mOnlyIfPerceivedScrollableDirection
=
true
;
uint32_t
flags
=
0
;
if
(
aFlags
&
Selection
:
:
SCROLL_FIRST_ANCESTOR_ONLY
)
{
flags
|
=
nsIPresShell
:
:
SCROLL_FIRST_ANCESTOR_ONLY
;
}
if
(
aFlags
&
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
)
{
flags
|
=
nsIPresShell
:
:
SCROLL_OVERFLOW_HIDDEN
;
}
presShell
-
>
ScrollFrameRectIntoView
(
frame
rect
aVertical
aHorizontal
flags
)
;
return
NS_OK
;
}
void
Selection
:
:
AddSelectionListener
(
nsISelectionListener
*
aNewListener
)
{
MOZ_ASSERT
(
aNewListener
)
;
mSelectionListeners
.
AppendElement
(
aNewListener
)
;
}
void
Selection
:
:
RemoveSelectionListener
(
nsISelectionListener
*
aListenerToRemove
)
{
mSelectionListeners
.
RemoveElement
(
aListenerToRemove
)
;
}
Element
*
Selection
:
:
GetCommonEditingHostForAllRanges
(
)
{
Element
*
editingHost
=
nullptr
;
for
(
RangeData
&
rangeData
:
mRanges
)
{
nsRange
*
range
=
rangeData
.
mRange
;
MOZ_ASSERT
(
range
)
;
nsINode
*
commonAncestorNode
=
range
-
>
GetCommonAncestor
(
)
;
if
(
!
commonAncestorNode
|
|
!
commonAncestorNode
-
>
IsContent
(
)
)
{
return
nullptr
;
}
nsIContent
*
commonAncestor
=
commonAncestorNode
-
>
AsContent
(
)
;
Element
*
foundEditingHost
=
commonAncestor
-
>
GetEditingHost
(
)
;
if
(
!
foundEditingHost
)
{
return
nullptr
;
}
if
(
!
editingHost
)
{
editingHost
=
foundEditingHost
;
continue
;
}
if
(
editingHost
=
=
foundEditingHost
)
{
continue
;
}
if
(
nsContentUtils
:
:
ContentIsDescendantOf
(
foundEditingHost
editingHost
)
)
{
continue
;
}
if
(
nsContentUtils
:
:
ContentIsDescendantOf
(
editingHost
foundEditingHost
)
)
{
editingHost
=
foundEditingHost
;
continue
;
}
return
nullptr
;
}
return
editingHost
;
}
nsresult
Selection
:
:
NotifySelectionListeners
(
bool
aCalledByJS
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
aCalledByJS
;
return
NotifySelectionListeners
(
)
;
}
nsresult
Selection
:
:
NotifySelectionListeners
(
)
{
if
(
!
mFrameSelection
)
return
NS_OK
;
AutoRestore
<
bool
>
calledByJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
false
;
if
(
mSelectionType
=
=
SelectionType
:
:
eNormal
&
&
calledByJSRestorer
.
SavedValue
(
)
)
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
nsIDocument
*
document
=
GetDocument
(
)
;
if
(
window
&
&
document
&
&
!
document
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
GetHTMLEditor
(
)
)
{
RefPtr
<
Element
>
newEditingHost
=
GetCommonEditingHostForAllRanges
(
)
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsIContent
*
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
nsCOMPtr
<
Element
>
focusedElement
=
do_QueryInterface
(
focusedContent
)
;
if
(
newEditingHost
&
&
newEditingHost
!
=
focusedElement
)
{
MOZ_ASSERT
(
!
newEditingHost
-
>
IsInNativeAnonymousSubtree
(
)
)
;
uint32_t
flags
=
nsIFocusManager
:
:
FLAG_NOSWITCHFRAME
;
if
(
focusedWindow
!
=
fm
-
>
GetFocusedWindow
(
)
)
{
flags
|
=
nsIFocusManager
:
:
FLAG_NOSCROLL
;
}
fm
-
>
SetFocus
(
newEditingHost
flags
)
;
}
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
if
(
frameSelection
-
>
GetBatching
(
)
)
{
frameSelection
-
>
SetDirty
(
)
;
return
NS_OK
;
}
if
(
mSelectionListeners
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
AutoTArray
<
nsCOMPtr
<
nsISelectionListener
>
8
>
selectionListeners
(
mSelectionListeners
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsIPresShell
*
ps
=
GetPresShell
(
)
;
if
(
ps
)
{
doc
=
ps
-
>
GetDocument
(
)
;
}
short
reason
=
frameSelection
-
>
PopReason
(
)
;
for
(
auto
&
listener
:
selectionListeners
)
{
listener
-
>
NotifySelectionChanged
(
doc
this
reason
)
;
}
return
NS_OK
;
}
void
Selection
:
:
StartBatchChanges
(
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
StartBatchChanges
(
)
;
}
}
void
Selection
:
:
EndBatchChanges
(
int16_t
aReason
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
EndBatchChanges
(
aReason
)
;
}
}
void
Selection
:
:
AddSelectionChangeBlocker
(
)
{
mSelectionChangeBlockerCount
+
+
;
}
void
Selection
:
:
RemoveSelectionChangeBlocker
(
)
{
MOZ_ASSERT
(
mSelectionChangeBlockerCount
>
0
"
mSelectionChangeBlockerCount
has
an
invalid
value
-
"
"
maybe
you
have
a
mismatched
RemoveSelectionChangeBlocker
?
"
)
;
mSelectionChangeBlockerCount
-
-
;
}
bool
Selection
:
:
IsBlockingSelectionChangeEvents
(
)
const
{
return
mSelectionChangeBlockerCount
>
0
;
}
void
Selection
:
:
DeleteFromDocument
(
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
return
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsresult
rv
=
frameSelection
-
>
DeleteFromDocument
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
void
Selection
:
:
Modify
(
const
nsAString
&
aAlter
const
nsAString
&
aDirection
const
nsAString
&
aGranularity
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
|
|
!
GetAnchorFocusRange
(
)
|
|
!
GetFocusNode
(
)
)
{
return
;
}
if
(
!
aAlter
.
LowerCaseEqualsLiteral
(
"
move
"
)
&
&
!
aAlter
.
LowerCaseEqualsLiteral
(
"
extend
"
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
if
(
!
aDirection
.
LowerCaseEqualsLiteral
(
"
forward
"
)
&
&
!
aDirection
.
LowerCaseEqualsLiteral
(
"
backward
"
)
&
&
!
aDirection
.
LowerCaseEqualsLiteral
(
"
left
"
)
&
&
!
aDirection
.
LowerCaseEqualsLiteral
(
"
right
"
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
bool
visual
=
aDirection
.
LowerCaseEqualsLiteral
(
"
left
"
)
|
|
aDirection
.
LowerCaseEqualsLiteral
(
"
right
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
line
"
)
;
bool
forward
=
aDirection
.
LowerCaseEqualsLiteral
(
"
forward
"
)
|
|
aDirection
.
LowerCaseEqualsLiteral
(
"
right
"
)
;
bool
extend
=
aAlter
.
LowerCaseEqualsLiteral
(
"
extend
"
)
;
nsSelectionAmount
amount
;
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
character
"
)
)
{
amount
=
eSelectCluster
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
word
"
)
)
{
amount
=
eSelectWordNoSpace
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
line
"
)
)
{
amount
=
eSelectLine
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
lineboundary
"
)
)
{
amount
=
forward
?
eSelectEndLine
:
eSelectBeginLine
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
sentence
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
sentenceboundary
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
paragraph
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
paragraphboundary
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
documentboundary
"
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
;
}
else
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
nsresult
rv
=
NS_OK
;
if
(
!
extend
)
{
nsINode
*
focusNode
=
GetFocusNode
(
)
;
if
(
!
focusNode
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
uint32_t
focusOffset
=
FocusOffset
(
)
;
Collapse
(
focusNode
focusOffset
)
;
}
nsIFrame
*
frame
;
int32_t
offset
;
rv
=
GetPrimaryFrameForFocusNode
(
&
frame
&
offset
visual
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
frame
)
{
nsBidiDirection
paraDir
=
nsBidiPresUtils
:
:
ParagraphDirection
(
frame
)
;
if
(
paraDir
=
=
NSBIDI_RTL
&
&
visual
)
{
if
(
amount
=
=
eSelectBeginLine
)
{
amount
=
eSelectEndLine
;
forward
=
!
forward
;
}
else
if
(
amount
=
=
eSelectEndLine
)
{
amount
=
eSelectBeginLine
;
forward
=
!
forward
;
}
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
rv
=
frameSelection
-
>
MoveCaret
(
forward
?
eDirNext
:
eDirPrevious
extend
amount
visual
?
nsFrameSelection
:
:
eVisual
:
nsFrameSelection
:
:
eLogical
)
;
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
line
"
)
&
&
NS_FAILED
(
rv
)
)
{
nsCOMPtr
<
nsISelectionController
>
shell
=
do_QueryInterface
(
frameSelection
-
>
GetShell
(
)
)
;
if
(
!
shell
)
return
;
shell
-
>
CompleteMove
(
forward
extend
)
;
}
}
void
Selection
:
:
SetBaseAndExtentJS
(
nsINode
&
aAnchorNode
uint32_t
aAnchorOffset
nsINode
&
aFocusNode
uint32_t
aFocusOffset
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
SetBaseAndExtent
(
aAnchorNode
aAnchorOffset
aFocusNode
aFocusOffset
aRv
)
;
}
void
Selection
:
:
SetBaseAndExtent
(
nsINode
&
aAnchorNode
uint32_t
aAnchorOffset
nsINode
&
aFocusNode
uint32_t
aFocusOffset
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
return
;
}
if
(
!
HasSameRoot
(
aAnchorNode
)
|
|
!
HasSameRoot
(
aFocusNode
)
)
{
return
;
}
SelectionBatcher
batch
(
this
)
;
int32_t
relativePosition
=
nsContentUtils
:
:
ComparePoints
(
&
aAnchorNode
aAnchorOffset
&
aFocusNode
aFocusOffset
)
;
nsINode
*
start
=
&
aAnchorNode
;
nsINode
*
end
=
&
aFocusNode
;
uint32_t
startOffset
=
aAnchorOffset
;
uint32_t
endOffset
=
aFocusOffset
;
if
(
relativePosition
>
0
)
{
start
=
&
aFocusNode
;
end
=
&
aAnchorNode
;
startOffset
=
aFocusOffset
;
endOffset
=
aAnchorOffset
;
}
RefPtr
<
nsRange
>
newRange
=
std
:
:
move
(
mCachedRange
)
;
nsresult
rv
=
NS_OK
;
if
(
newRange
)
{
rv
=
newRange
-
>
SetStartAndEnd
(
start
startOffset
end
endOffset
)
;
}
else
{
rv
=
nsRange
:
:
CreateRange
(
start
startOffset
end
endOffset
getter_AddRefs
(
newRange
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
RemoveAllRanges
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
AddRange
(
*
newRange
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetDirection
(
relativePosition
>
0
?
eDirPrevious
:
eDirNext
)
;
}
nsresult
Selection
:
:
SelectionLanguageChange
(
bool
aLangRTL
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_NOT_INITIALIZED
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsBidiLevel
kbdBidiLevel
=
aLangRTL
?
NSBIDI_RTL
:
NSBIDI_LTR
;
if
(
kbdBidiLevel
=
=
frameSelection
-
>
mKbdBidiLevel
)
{
return
NS_OK
;
}
frameSelection
-
>
mKbdBidiLevel
=
kbdBidiLevel
;
nsresult
result
;
nsIFrame
*
focusFrame
=
0
;
result
=
GetPrimaryFrameForFocusNode
(
&
focusFrame
nullptr
false
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
if
(
!
focusFrame
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
frameStart
frameEnd
;
focusFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
RefPtr
<
nsPresContext
>
context
=
GetPresContext
(
)
;
nsBidiLevel
levelBefore
levelAfter
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
nsBidiLevel
level
=
focusFrame
-
>
GetEmbeddingLevel
(
)
;
int32_t
focusOffset
=
static_cast
<
int32_t
>
(
FocusOffset
(
)
)
;
if
(
(
focusOffset
!
=
frameStart
)
&
&
(
focusOffset
!
=
frameEnd
)
)
levelBefore
=
levelAfter
=
level
;
else
{
nsCOMPtr
<
nsIContent
>
focusContent
=
do_QueryInterface
(
GetFocusNode
(
)
)
;
nsPrevNextBidiLevels
levels
=
frameSelection
-
>
GetPrevNextBidiLevels
(
focusContent
focusOffset
false
)
;
levelBefore
=
levels
.
mLevelBefore
;
levelAfter
=
levels
.
mLevelAfter
;
}
if
(
IS_SAME_DIRECTION
(
levelBefore
levelAfter
)
)
{
if
(
(
level
!
=
levelBefore
)
&
&
(
level
!
=
levelAfter
)
)
level
=
std
:
:
min
(
levelBefore
levelAfter
)
;
if
(
IS_SAME_DIRECTION
(
level
kbdBidiLevel
)
)
frameSelection
-
>
SetCaretBidiLevel
(
level
)
;
else
frameSelection
-
>
SetCaretBidiLevel
(
level
+
1
)
;
}
else
{
if
(
IS_SAME_DIRECTION
(
levelBefore
kbdBidiLevel
)
)
frameSelection
-
>
SetCaretBidiLevel
(
levelBefore
)
;
else
frameSelection
-
>
SetCaretBidiLevel
(
levelAfter
)
;
}
frameSelection
-
>
InvalidateDesiredPos
(
)
;
return
NS_OK
;
}
void
Selection
:
:
SetColors
(
const
nsAString
&
aForegroundColor
const
nsAString
&
aBackgroundColor
const
nsAString
&
aAltForegroundColor
const
nsAString
&
aAltBackgroundColor
ErrorResult
&
aRv
)
{
if
(
mSelectionType
!
=
SelectionType
:
:
eFind
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
mCustomColors
.
reset
(
new
SelectionCustomColors
)
;
NS_NAMED_LITERAL_STRING
(
currentColorStr
"
currentColor
"
)
;
NS_NAMED_LITERAL_STRING
(
transparentStr
"
transparent
"
)
;
if
(
!
aForegroundColor
.
Equals
(
currentColorStr
)
)
{
nscolor
foregroundColor
;
nsAttrValue
aForegroundColorValue
;
aForegroundColorValue
.
ParseColor
(
aForegroundColor
)
;
if
(
!
aForegroundColorValue
.
GetColorValue
(
foregroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mForegroundColor
=
Some
(
foregroundColor
)
;
}
else
{
mCustomColors
-
>
mForegroundColor
=
Nothing
(
)
;
}
if
(
!
aBackgroundColor
.
Equals
(
transparentStr
)
)
{
nscolor
backgroundColor
;
nsAttrValue
aBackgroundColorValue
;
aBackgroundColorValue
.
ParseColor
(
aBackgroundColor
)
;
if
(
!
aBackgroundColorValue
.
GetColorValue
(
backgroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mBackgroundColor
=
Some
(
backgroundColor
)
;
}
else
{
mCustomColors
-
>
mBackgroundColor
=
Nothing
(
)
;
}
if
(
!
aAltForegroundColor
.
Equals
(
currentColorStr
)
)
{
nscolor
altForegroundColor
;
nsAttrValue
aAltForegroundColorValue
;
aAltForegroundColorValue
.
ParseColor
(
aAltForegroundColor
)
;
if
(
!
aAltForegroundColorValue
.
GetColorValue
(
altForegroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mAltForegroundColor
=
Some
(
altForegroundColor
)
;
}
else
{
mCustomColors
-
>
mAltForegroundColor
=
Nothing
(
)
;
}
if
(
!
aAltBackgroundColor
.
Equals
(
transparentStr
)
)
{
nscolor
altBackgroundColor
;
nsAttrValue
aAltBackgroundColorValue
;
aAltBackgroundColorValue
.
ParseColor
(
aAltBackgroundColor
)
;
if
(
!
aAltBackgroundColorValue
.
GetColorValue
(
altBackgroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mAltBackgroundColor
=
Some
(
altBackgroundColor
)
;
}
else
{
mCustomColors
-
>
mAltBackgroundColor
=
Nothing
(
)
;
}
}
void
Selection
:
:
ResetColors
(
ErrorResult
&
aRv
)
{
mCustomColors
=
nullptr
;
}
JSObject
*
Selection
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
mozilla
:
:
dom
:
:
Selection_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
AutoHideSelectionChanges
:
:
AutoHideSelectionChanges
(
const
nsFrameSelection
*
aFrame
)
:
AutoHideSelectionChanges
(
aFrame
?
aFrame
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
:
nullptr
)
{
}
bool
Selection
:
:
HasSameRoot
(
nsINode
&
aNode
)
{
nsINode
*
root
=
aNode
.
SubtreeRoot
(
)
;
nsIDocument
*
doc
=
GetParentObject
(
)
;
return
doc
=
=
root
|
|
(
root
&
&
doc
=
=
root
-
>
GetComposedDoc
(
)
)
;
}
