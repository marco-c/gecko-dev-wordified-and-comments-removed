#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
intl
/
BidiEmbeddingLevel
.
h
"
#
include
"
mozilla
/
AccessibleCaretEventHub
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoCopyListener
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SelectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
<
algorithm
>
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
LazyLogModule
sSelectionLog
(
"
Selection
"
)
;
#
ifdef
PRINT_RANGE
static
void
printRange
(
nsRange
*
aDomRange
)
;
#
define
DEBUG_OUT_RANGE
(
x
)
printRange
(
x
)
#
else
#
define
DEBUG_OUT_RANGE
(
x
)
#
endif
static
constexpr
nsLiteralCString
kNoDocumentTypeNodeError
=
"
DocumentType
nodes
are
not
supported
"
_ns
;
static
constexpr
nsLiteralCString
kNoRangeExistsError
=
"
No
selection
range
exists
"
_ns
;
namespace
mozilla
{
const
char
*
ToChar
(
SelectionType
aSelectionType
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eInvalid
:
return
"
SelectionType
:
:
eInvalid
"
;
case
SelectionType
:
:
eNone
:
return
"
SelectionType
:
:
eNone
"
;
case
SelectionType
:
:
eNormal
:
return
"
SelectionType
:
:
eNormal
"
;
case
SelectionType
:
:
eSpellCheck
:
return
"
SelectionType
:
:
eSpellCheck
"
;
case
SelectionType
:
:
eIMERawClause
:
return
"
SelectionType
:
:
eIMERawClause
"
;
case
SelectionType
:
:
eIMESelectedRawClause
:
return
"
SelectionType
:
:
eIMESelectedRawClause
"
;
case
SelectionType
:
:
eIMEConvertedClause
:
return
"
SelectionType
:
:
eIMEConvertedClause
"
;
case
SelectionType
:
:
eIMESelectedClause
:
return
"
SelectionType
:
:
eIMESelectedClause
"
;
case
SelectionType
:
:
eAccessibility
:
return
"
SelectionType
:
:
eAccessibility
"
;
case
SelectionType
:
:
eFind
:
return
"
SelectionType
:
:
eFind
"
;
case
SelectionType
:
:
eURLSecondary
:
return
"
SelectionType
:
:
eURLSecondary
"
;
case
SelectionType
:
:
eURLStrikeout
:
return
"
SelectionType
:
:
eURLStrikeout
"
;
default
:
return
"
Invalid
SelectionType
"
;
}
}
}
struct
CachedOffsetForFrame
{
CachedOffsetForFrame
(
)
:
mCachedFrameOffset
(
0
0
)
mLastCaretFrame
(
nullptr
)
mLastContentOffset
(
0
)
mCanCacheFrameOffset
(
false
)
{
}
nsPoint
mCachedFrameOffset
;
nsIFrame
*
mLastCaretFrame
;
int32_t
mLastContentOffset
;
bool
mCanCacheFrameOffset
;
}
;
class
AutoScroller
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
explicit
AutoScroller
(
nsFrameSelection
*
aFrameSelection
)
:
mFrameSelection
(
aFrameSelection
)
mPresContext
(
0
)
mPoint
(
0
0
)
mDelayInMs
(
30
)
mFurtherScrollingAllowed
(
FurtherScrollingAllowed
:
:
kYes
)
{
MOZ_ASSERT
(
mFrameSelection
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
DoAutoScroll
(
nsIFrame
*
aFrame
nsPoint
aPoint
)
;
private
:
nsresult
ScheduleNextDoAutoScroll
(
nsPresContext
*
aPresContext
nsPoint
&
aPoint
)
{
if
(
NS_WARN_IF
(
mFurtherScrollingAllowed
=
=
FurtherScrollingAllowed
:
:
kNo
)
)
{
return
NS_ERROR_FAILURE
;
}
mPoint
=
aPoint
;
mPresContext
=
aPresContext
;
mContent
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
!
mTimer
)
{
mTimer
=
NS_NewTimer
(
mPresContext
-
>
Document
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
if
(
!
mTimer
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
mTimer
-
>
InitWithCallback
(
this
mDelayInMs
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
public
:
enum
class
FurtherScrollingAllowed
{
kYes
kNo
}
;
void
Stop
(
const
FurtherScrollingAllowed
aFurtherScrollingAllowed
)
{
MOZ_ASSERT
(
(
aFurtherScrollingAllowed
=
=
FurtherScrollingAllowed
:
:
kNo
)
|
|
(
mFurtherScrollingAllowed
=
=
FurtherScrollingAllowed
:
:
kYes
)
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
mContent
=
nullptr
;
mFurtherScrollingAllowed
=
aFurtherScrollingAllowed
;
}
void
SetDelay
(
uint32_t
aDelayInMs
)
{
mDelayInMs
=
aDelayInMs
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Notify
(
nsITimer
*
timer
)
override
{
if
(
mPresContext
)
{
AutoWeakFrame
frame
=
mContent
?
mPresContext
-
>
GetPrimaryFrameFor
(
mContent
)
:
nullptr
;
if
(
!
frame
)
{
return
NS_OK
;
}
mContent
=
nullptr
;
nsPoint
pt
=
mPoint
-
frame
-
>
GetOffsetTo
(
mPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
HandleDrag
(
frame
pt
)
;
if
(
!
frame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
frame
-
>
PresContext
(
)
=
=
mPresContext
"
document
mismatch
?
"
)
;
DoAutoScroll
(
frame
pt
)
;
}
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
AutoScroller
"
)
;
return
NS_OK
;
}
protected
:
virtual
~
AutoScroller
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
private
:
nsFrameSelection
*
const
mFrameSelection
;
nsPresContext
*
mPresContext
;
nsPoint
mPoint
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsCOMPtr
<
nsIContent
>
mContent
;
uint32_t
mDelayInMs
;
FurtherScrollingAllowed
mFurtherScrollingAllowed
;
}
;
NS_IMPL_ISUPPORTS
(
AutoScroller
nsITimerCallback
nsINamed
)
#
ifdef
PRINT_RANGE
void
printRange
(
nsRange
*
aDomRange
)
{
if
(
!
aDomRange
)
{
printf
(
"
NULL
Range
\
n
"
)
;
}
nsINode
*
startNode
=
aDomRange
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
aDomRange
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
aDomRange
-
>
StartOffset
(
)
;
int32_t
endOffset
=
aDomRange
-
>
EndOffset
(
)
;
printf
(
"
range
:
0x
%
lx
\
t
start
:
0x
%
lx
%
ld
\
t
end
:
0x
%
lx
%
ld
\
n
"
(
unsigned
long
)
aDomRange
(
unsigned
long
)
startNode
(
long
)
startOffset
(
unsigned
long
)
endNode
(
long
)
endOffset
)
;
}
#
endif
void
Selection
:
:
Stringify
(
nsAString
&
aResult
FlushFrames
aFlushFrames
)
{
if
(
aFlushFrames
=
=
FlushFrames
:
:
Yes
)
{
RefPtr
<
PresShell
>
presShell
=
mFrameSelection
?
mFrameSelection
-
>
GetPresShell
(
)
:
nullptr
;
if
(
!
presShell
)
{
aResult
.
Truncate
(
)
;
return
;
}
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
IgnoredErrorResult
rv
;
ToStringWithFormat
(
u
"
text
/
plain
"
_ns
nsIDocumentEncoder
:
:
SkipInvisibleContent
0
aResult
rv
)
;
if
(
rv
.
Failed
(
)
)
{
aResult
.
Truncate
(
)
;
}
}
void
Selection
:
:
ToStringWithFormat
(
const
nsAString
&
aFormatType
uint32_t
aFlags
int32_t
aWrapCol
nsAString
&
aReturn
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIDocumentEncoder
>
encoder
=
do_createDocumentEncoder
(
NS_ConvertUTF16toUTF8
(
aFormatType
)
.
get
(
)
)
;
if
(
!
encoder
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
aFlags
|
=
nsIDocumentEncoder
:
:
OutputSelectionOnly
;
nsAutoString
readstring
;
readstring
.
Assign
(
aFormatType
)
;
nsresult
rv
=
encoder
-
>
Init
(
doc
readstring
aFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
encoder
-
>
SetSelection
(
this
)
;
if
(
aWrapCol
!
=
0
)
encoder
-
>
SetWrapColumn
(
aWrapCol
)
;
rv
=
encoder
-
>
EncodeToString
(
aReturn
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
void
Selection
:
:
SetInterlinePosition
(
bool
aHintRight
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
mFrameSelection
-
>
SetHint
(
aHintRight
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
)
;
}
bool
Selection
:
:
GetInterlinePosition
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
false
;
}
return
mFrameSelection
-
>
GetHint
(
)
=
=
CARET_ASSOCIATE_AFTER
;
}
static
bool
IsEditorNode
(
const
nsINode
*
aNode
)
{
if
(
!
aNode
)
{
return
false
;
}
if
(
aNode
-
>
IsEditable
(
)
)
{
return
true
;
}
auto
*
element
=
Element
:
:
FromNode
(
aNode
)
;
return
element
&
&
element
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_READWRITE
)
;
}
bool
Selection
:
:
IsEditorSelection
(
)
const
{
return
IsEditorNode
(
GetFocusNode
(
)
)
;
}
Nullable
<
int16_t
>
Selection
:
:
GetCaretBidiLevel
(
mozilla
:
:
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
Nullable
<
int16_t
>
(
)
;
}
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
caretBidiLevel
=
static_cast
<
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
>
(
mFrameSelection
-
>
GetCaretBidiLevel
(
)
)
;
return
(
caretBidiLevel
&
BIDI_LEVEL_UNDEFINED
)
?
Nullable
<
int16_t
>
(
)
:
Nullable
<
int16_t
>
(
caretBidiLevel
)
;
}
void
Selection
:
:
SetCaretBidiLevel
(
const
Nullable
<
int16_t
>
&
aCaretBidiLevel
mozilla
:
:
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
aCaretBidiLevel
.
IsNull
(
)
)
{
mFrameSelection
-
>
UndefineCaretBidiLevel
(
)
;
}
else
{
mFrameSelection
-
>
SetCaretBidiLevelAndMaybeSchedulePaint
(
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
(
aCaretBidiLevel
.
Value
(
)
)
)
;
}
}
static
nsresult
GetTableSelectionMode
(
const
nsRange
&
aRange
TableSelectionMode
*
aTableSelectionType
)
{
if
(
!
aTableSelectionType
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aTableSelectionType
=
TableSelectionMode
:
:
None
;
nsINode
*
startNode
=
aRange
.
GetStartContainer
(
)
;
if
(
!
startNode
)
{
return
NS_ERROR_FAILURE
;
}
nsINode
*
endNode
=
aRange
.
GetEndContainer
(
)
;
if
(
!
endNode
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startNode
!
=
endNode
)
{
return
NS_OK
;
}
nsIContent
*
child
=
aRange
.
GetChildAtStartOffset
(
)
;
if
(
!
child
|
|
child
-
>
GetNextSibling
(
)
!
=
aRange
.
GetChildAtEndOffset
(
)
)
{
return
NS_OK
;
}
nsIContent
*
startContent
=
static_cast
<
nsIContent
*
>
(
startNode
)
;
if
(
!
(
startNode
-
>
IsElement
(
)
&
&
startContent
-
>
IsHTMLElement
(
)
)
)
{
return
NS_OK
;
}
if
(
startContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
*
aTableSelectionType
=
TableSelectionMode
:
:
Cell
;
}
else
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
*
aTableSelectionType
=
TableSelectionMode
:
:
Table
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
*
aTableSelectionType
=
TableSelectionMode
:
:
Row
;
}
}
return
NS_OK
;
}
nsresult
Selection
:
:
MaybeAddTableCellRange
(
nsRange
&
aRange
Maybe
<
size_t
>
*
aOutIndex
)
{
if
(
!
aOutIndex
)
{
return
NS_ERROR_NULL_POINTER
;
}
MOZ_ASSERT
(
aOutIndex
-
>
isNothing
(
)
)
;
if
(
!
mFrameSelection
)
{
return
NS_OK
;
}
TableSelectionMode
tableMode
;
nsresult
result
=
GetTableSelectionMode
(
aRange
&
tableMode
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
tableMode
!
=
TableSelectionMode
:
:
Cell
)
{
mFrameSelection
-
>
mTableSelection
.
mMode
=
tableMode
;
return
NS_OK
;
}
if
(
mFrameSelection
-
>
mTableSelection
.
mMode
=
=
TableSelectionMode
:
:
None
)
{
mFrameSelection
-
>
mTableSelection
.
mMode
=
tableMode
;
}
return
AddRangesForSelectableNodes
(
&
aRange
aOutIndex
DispatchSelectstartEvent
:
:
Maybe
)
;
}
Selection
:
:
Selection
(
SelectionType
aSelectionType
nsFrameSelection
*
aFrameSelection
)
:
mFrameSelection
(
aFrameSelection
)
mCachedOffsetForFrame
(
nullptr
)
mDirection
(
eDirNext
)
mSelectionType
(
aSelectionType
)
mCustomColors
(
nullptr
)
mSelectionChangeBlockerCount
(
0
)
mUserInitiated
(
false
)
mCalledByJS
(
false
)
mNotifyAutoCopy
(
false
)
{
}
Selection
:
:
~
Selection
(
)
{
Disconnect
(
)
;
}
void
Selection
:
:
Disconnect
(
)
{
RemoveAnchorFocusRange
(
)
;
mStyledRanges
.
UnregisterSelection
(
)
;
if
(
mAutoScroller
)
{
mAutoScroller
-
>
Stop
(
AutoScroller
:
:
FurtherScrollingAllowed
:
:
kNo
)
;
mAutoScroller
=
nullptr
;
}
mScrollEvent
.
Revoke
(
)
;
if
(
mCachedOffsetForFrame
)
{
delete
mCachedOffsetForFrame
;
mCachedOffsetForFrame
=
nullptr
;
}
}
Document
*
Selection
:
:
GetParentObject
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetDocument
(
)
:
nullptr
;
}
DocGroup
*
Selection
:
:
GetDocGroup
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
return
doc
?
doc
-
>
GetDocGroup
(
)
:
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Selection
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Selection
)
tmp
-
>
mNotifyAutoCopy
=
false
;
if
(
tmp
-
>
mAccessibleCaretEventHub
)
{
tmp
-
>
StopNotifyingAccessibleCaretEventHub
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectionChangeEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectionListeners
)
MOZ_KnownLive
(
tmp
)
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFrameSelection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_PTR
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Selection
)
{
uint32_t
i
count
=
tmp
-
>
mStyledRanges
.
Length
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyledRanges
.
mRanges
[
i
]
.
mRange
)
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchorFocusRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameSelection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectionChangeEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectionListeners
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
Selection
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Selection
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_ADDREF
(
Selection
)
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
Selection
Disconnect
(
)
)
const
RangeBoundary
&
Selection
:
:
AnchorRef
(
)
const
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmpty
;
return
sEmpty
;
}
if
(
GetDirection
(
)
=
=
eDirNext
)
{
return
mAnchorFocusRange
-
>
StartRef
(
)
;
}
return
mAnchorFocusRange
-
>
EndRef
(
)
;
}
const
RangeBoundary
&
Selection
:
:
FocusRef
(
)
const
{
if
(
!
mAnchorFocusRange
)
{
static
RangeBoundary
sEmpty
;
return
sEmpty
;
}
if
(
GetDirection
(
)
=
=
eDirNext
)
{
return
mAnchorFocusRange
-
>
EndRef
(
)
;
}
return
mAnchorFocusRange
-
>
StartRef
(
)
;
}
void
Selection
:
:
SetAnchorFocusRange
(
size_t
aIndex
)
{
if
(
aIndex
>
=
mStyledRanges
.
Length
(
)
)
{
return
;
}
mAnchorFocusRange
=
mStyledRanges
.
mRanges
[
aIndex
]
.
mRange
;
}
static
int32_t
CompareToRangeStart
(
const
nsINode
&
aCompareNode
uint32_t
aCompareOffset
const
nsRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
.
GetStartContainer
(
)
)
;
nsINode
*
start
=
aRange
.
GetStartContainer
(
)
;
if
(
aCompareNode
.
GetComposedDoc
(
)
!
=
start
-
>
GetComposedDoc
(
)
|
|
!
start
-
>
GetComposedDoc
(
)
|
|
aCompareNode
.
SubtreeRoot
(
)
!
=
start
-
>
SubtreeRoot
(
)
)
{
NS_WARNING
(
"
CompareToRangeStart
couldn
'
t
compare
nodes
pretending
some
order
.
"
)
;
return
1
;
}
return
*
nsContentUtils
:
:
ComparePoints
(
&
aCompareNode
AssertedCast
<
int32_t
>
(
aCompareOffset
)
start
AssertedCast
<
int32_t
>
(
aRange
.
StartOffset
(
)
)
)
;
}
static
int32_t
CompareToRangeEnd
(
const
nsINode
&
aCompareNode
uint32_t
aCompareOffset
const
nsRange
&
aRange
)
{
MOZ_ASSERT
(
aRange
.
IsPositioned
(
)
)
;
nsINode
*
end
=
aRange
.
GetEndContainer
(
)
;
if
(
aCompareNode
.
GetComposedDoc
(
)
!
=
end
-
>
GetComposedDoc
(
)
|
|
!
end
-
>
GetComposedDoc
(
)
|
|
aCompareNode
.
SubtreeRoot
(
)
!
=
end
-
>
SubtreeRoot
(
)
)
{
NS_WARNING
(
"
CompareToRangeEnd
couldn
'
t
compare
nodes
pretending
some
order
.
"
)
;
return
1
;
}
return
*
nsContentUtils
:
:
ComparePoints
(
&
aCompareNode
AssertedCast
<
int32_t
>
(
aCompareOffset
)
end
AssertedCast
<
int32_t
>
(
aRange
.
EndOffset
(
)
)
)
;
}
size_t
Selection
:
:
StyledRanges
:
:
FindInsertionPoint
(
const
nsTArray
<
StyledRange
>
*
aElementArray
const
nsINode
&
aPointNode
uint32_t
aPointOffset
int32_t
(
*
aComparator
)
(
const
nsINode
&
uint32_t
const
nsRange
&
)
)
{
int32_t
beginSearch
=
0
;
int32_t
endSearch
=
aElementArray
-
>
Length
(
)
;
if
(
endSearch
)
{
int32_t
center
=
endSearch
-
1
;
do
{
const
nsRange
*
range
=
(
*
aElementArray
)
[
center
]
.
mRange
;
int32_t
cmp
{
aComparator
(
aPointNode
aPointOffset
*
range
)
}
;
if
(
cmp
<
0
)
{
endSearch
=
center
;
}
else
if
(
cmp
>
0
)
{
beginSearch
=
center
+
1
;
}
else
{
beginSearch
=
center
;
break
;
}
center
=
(
endSearch
-
beginSearch
)
/
2
+
beginSearch
;
}
while
(
endSearch
-
beginSearch
>
0
)
;
}
return
AssertedCast
<
size_t
>
(
beginSearch
)
;
}
nsresult
Selection
:
:
StyledRanges
:
:
SubtractRange
(
StyledRange
&
aRange
nsRange
&
aSubtract
nsTArray
<
StyledRange
>
*
aOutput
)
{
nsRange
*
range
=
aRange
.
mRange
;
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
int32_t
cmp
{
CompareToRangeStart
(
*
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
aSubtract
)
}
;
int32_t
cmp2
{
CompareToRangeEnd
(
*
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
aSubtract
)
}
;
if
(
cmp2
>
0
)
{
ErrorResult
error
;
RefPtr
<
nsRange
>
postOverlap
=
nsRange
:
:
Create
(
aSubtract
.
EndRef
(
)
range
-
>
EndRef
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
MOZ_ASSERT
(
postOverlap
)
;
if
(
!
postOverlap
-
>
Collapsed
(
)
)
{
aOutput
-
>
InsertElementAt
(
0
StyledRange
(
postOverlap
)
)
;
(
*
aOutput
)
[
0
]
.
mTextRangeStyle
=
aRange
.
mTextRangeStyle
;
}
}
if
(
cmp
<
0
)
{
ErrorResult
error
;
RefPtr
<
nsRange
>
preOverlap
=
nsRange
:
:
Create
(
range
-
>
StartRef
(
)
aSubtract
.
StartRef
(
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
MOZ_ASSERT
(
preOverlap
)
;
if
(
!
preOverlap
-
>
Collapsed
(
)
)
{
aOutput
-
>
InsertElementAt
(
0
StyledRange
(
preOverlap
)
)
;
(
*
aOutput
)
[
0
]
.
mTextRangeStyle
=
aRange
.
mTextRangeStyle
;
}
}
return
NS_OK
;
}
static
void
UserSelectRangesToAdd
(
nsRange
*
aItem
nsTArray
<
RefPtr
<
nsRange
>
>
&
aRangesToAdd
)
{
if
(
IsEditorNode
(
aItem
-
>
GetStartContainer
(
)
)
&
&
IsEditorNode
(
aItem
-
>
GetEndContainer
(
)
)
)
{
aRangesToAdd
.
AppendElement
(
aItem
)
;
}
else
{
aItem
-
>
ExcludeNonSelectableNodes
(
&
aRangesToAdd
)
;
}
}
static
nsINode
*
DetermineSelectstartEventTarget
(
const
bool
aSelectionEventsOnTextControlsEnabled
const
nsRange
&
aRange
)
{
nsINode
*
target
=
aRange
.
GetStartContainer
(
)
;
if
(
aSelectionEventsOnTextControlsEnabled
)
{
while
(
target
&
&
target
-
>
IsInNativeAnonymousSubtree
(
)
)
{
target
=
target
-
>
GetParent
(
)
;
}
}
else
{
if
(
target
-
>
IsInNativeAnonymousSubtree
(
)
)
{
target
=
nullptr
;
}
}
return
target
;
}
static
bool
MaybeDispatchSelectstartEvent
(
const
nsRange
&
aRange
const
bool
aSelectionEventsOnTextControlsEnabled
Document
*
aDocument
)
{
nsCOMPtr
<
nsINode
>
selectstartEventTarget
=
DetermineSelectstartEventTarget
(
aSelectionEventsOnTextControlsEnabled
aRange
)
;
bool
executeDefaultAction
=
true
;
if
(
selectstartEventTarget
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
aDocument
selectstartEventTarget
u
"
selectstart
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eYes
&
executeDefaultAction
)
;
}
return
executeDefaultAction
;
}
bool
Selection
:
:
IsUserSelectionCollapsed
(
const
nsRange
&
aRange
nsTArray
<
RefPtr
<
nsRange
>
>
&
aTempRangesToAdd
)
{
MOZ_ASSERT
(
aTempRangesToAdd
.
IsEmpty
(
)
)
;
RefPtr
<
nsRange
>
scratchRange
=
aRange
.
CloneRange
(
)
;
UserSelectRangesToAdd
(
scratchRange
aTempRangesToAdd
)
;
const
bool
userSelectionCollapsed
=
(
aTempRangesToAdd
.
Length
(
)
=
=
0
)
|
|
(
(
aTempRangesToAdd
.
Length
(
)
=
=
1
)
&
&
aTempRangesToAdd
[
0
]
-
>
Collapsed
(
)
)
;
aTempRangesToAdd
.
ClearAndRetainStorage
(
)
;
return
userSelectionCollapsed
;
}
nsresult
Selection
:
:
AddRangesForUserSelectableNodes
(
nsRange
*
aRange
Maybe
<
size_t
>
*
aOutIndex
const
DispatchSelectstartEvent
aDispatchSelectstartEvent
)
{
MOZ_ASSERT
(
mUserInitiated
)
;
MOZ_ASSERT
(
aOutIndex
)
;
MOZ_ASSERT
(
aOutIndex
-
>
isNothing
(
)
)
;
if
(
!
aRange
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
!
aRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
AutoTArray
<
RefPtr
<
nsRange
>
4
>
rangesToAdd
;
if
(
mStyledRanges
.
Length
(
)
)
{
aOutIndex
-
>
emplace
(
mStyledRanges
.
Length
(
)
-
1
)
;
}
Document
*
doc
=
GetDocument
(
)
;
if
(
aDispatchSelectstartEvent
=
=
DispatchSelectstartEvent
:
:
Maybe
&
&
mSelectionType
=
=
SelectionType
:
:
eNormal
&
&
IsCollapsed
(
)
&
&
!
IsBlockingSelectionChangeEvents
(
)
)
{
const
bool
userSelectionCollapsed
=
IsUserSelectionCollapsed
(
*
aRange
rangesToAdd
)
;
MOZ_ASSERT
(
userSelectionCollapsed
|
|
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
if
(
!
userSelectionCollapsed
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
const
bool
executeDefaultAction
=
MaybeDispatchSelectstartEvent
(
*
aRange
StaticPrefs
:
:
dom_select_events_textcontrols_selectstart_enabled
(
)
doc
)
;
if
(
!
executeDefaultAction
)
{
return
NS_OK
;
}
if
(
!
aRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
}
UserSelectRangesToAdd
(
aRange
rangesToAdd
)
;
size_t
newAnchorFocusIndex
=
GetDirection
(
)
=
=
eDirPrevious
?
0
:
rangesToAdd
.
Length
(
)
-
1
;
for
(
size_t
i
=
0
;
i
<
rangesToAdd
.
Length
(
)
;
+
+
i
)
{
Maybe
<
size_t
>
index
;
const
RefPtr
<
Selection
>
selection
{
this
}
;
nsresult
rv
=
mStyledRanges
.
MaybeAddRangeAndTruncateOverlaps
(
MOZ_KnownLive
(
rangesToAdd
[
i
]
)
&
index
*
selection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
i
=
=
newAnchorFocusIndex
)
{
*
aOutIndex
=
index
;
rangesToAdd
[
i
]
-
>
SetIsGenerated
(
false
)
;
}
else
{
rangesToAdd
[
i
]
-
>
SetIsGenerated
(
true
)
;
}
}
return
NS_OK
;
}
nsresult
Selection
:
:
AddRangesForSelectableNodes
(
nsRange
*
aRange
Maybe
<
size_t
>
*
aOutIndex
const
DispatchSelectstartEvent
aDispatchSelectstartEvent
)
{
MOZ_ASSERT
(
aOutIndex
)
;
MOZ_ASSERT
(
aOutIndex
-
>
isNothing
(
)
)
;
if
(
!
aRange
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
!
aRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_LOG
(
sSelectionLog
LogLevel
:
:
Debug
(
"
%
s
:
selection
=
%
p
type
=
%
i
range
=
(
%
p
StartOffset
=
%
u
EndOffset
=
%
u
)
"
__FUNCTION__
this
static_cast
<
int
>
(
GetType
(
)
)
aRange
aRange
-
>
StartOffset
(
)
aRange
-
>
EndOffset
(
)
)
)
;
if
(
mUserInitiated
)
{
return
AddRangesForUserSelectableNodes
(
aRange
aOutIndex
aDispatchSelectstartEvent
)
;
}
const
RefPtr
<
Selection
>
selection
{
this
}
;
return
mStyledRanges
.
MaybeAddRangeAndTruncateOverlaps
(
aRange
aOutIndex
*
selection
)
;
}
nsresult
Selection
:
:
StyledRanges
:
:
MaybeAddRangeAndTruncateOverlaps
(
nsRange
*
aRange
Maybe
<
size_t
>
*
aOutIndex
Selection
&
aSelection
)
{
MOZ_ASSERT
(
aRange
)
;
MOZ_ASSERT
(
aRange
-
>
IsPositioned
(
)
)
;
MOZ_ASSERT
(
aOutIndex
)
;
MOZ_ASSERT
(
aOutIndex
-
>
isNothing
(
)
)
;
if
(
mRanges
.
Length
(
)
=
=
0
)
{
mRanges
.
AppendElement
(
StyledRange
(
aRange
)
)
;
aRange
-
>
RegisterSelection
(
aSelection
)
;
aOutIndex
-
>
emplace
(
0u
)
;
return
NS_OK
;
}
Maybe
<
size_t
>
maybeStartIndex
maybeEndIndex
;
nsresult
rv
=
GetIndicesForInterval
(
aRange
-
>
GetStartContainer
(
)
aRange
-
>
StartOffset
(
)
aRange
-
>
GetEndContainer
(
)
aRange
-
>
EndOffset
(
)
false
maybeStartIndex
maybeEndIndex
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
size_t
startIndex
endIndex
;
if
(
maybeEndIndex
.
isNothing
(
)
)
{
startIndex
=
0
;
endIndex
=
0
;
}
else
if
(
maybeStartIndex
.
isNothing
(
)
)
{
startIndex
=
mRanges
.
Length
(
)
;
endIndex
=
startIndex
;
}
else
{
startIndex
=
*
maybeStartIndex
;
endIndex
=
*
maybeEndIndex
;
}
const
bool
sameRange
=
HasEqualRangeBoundariesAt
(
*
aRange
startIndex
)
;
if
(
sameRange
)
{
aOutIndex
-
>
emplace
(
startIndex
)
;
return
NS_OK
;
}
if
(
startIndex
=
=
endIndex
)
{
mRanges
.
InsertElementAt
(
startIndex
StyledRange
(
aRange
)
)
;
aRange
-
>
RegisterSelection
(
aSelection
)
;
aOutIndex
-
>
emplace
(
startIndex
)
;
return
NS_OK
;
}
nsTArray
<
StyledRange
>
overlaps
;
overlaps
.
InsertElementAt
(
0
mRanges
[
startIndex
]
)
;
if
(
endIndex
-
1
!
=
startIndex
)
{
overlaps
.
InsertElementAt
(
1
mRanges
[
endIndex
-
1
]
)
;
}
for
(
size_t
i
=
startIndex
;
i
<
endIndex
;
+
+
i
)
{
mRanges
[
i
]
.
mRange
-
>
UnregisterSelection
(
)
;
}
mRanges
.
RemoveElementsAt
(
startIndex
endIndex
-
startIndex
)
;
nsTArray
<
StyledRange
>
temp
;
for
(
const
size_t
i
:
Reversed
(
IntegerRange
(
overlaps
.
Length
(
)
)
)
)
{
nsresult
rv
=
SubtractRange
(
overlaps
[
i
]
*
aRange
&
temp
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
size_t
insertionPoint
{
FindInsertionPoint
(
&
temp
*
aRange
-
>
GetStartContainer
(
)
aRange
-
>
StartOffset
(
)
CompareToRangeStart
)
}
;
temp
.
InsertElementAt
(
insertionPoint
StyledRange
(
aRange
)
)
;
mRanges
.
InsertElementsAt
(
startIndex
temp
)
;
for
(
uint32_t
i
=
0
;
i
<
temp
.
Length
(
)
;
+
+
i
)
{
MOZ_KnownLive
(
temp
[
i
]
.
mRange
)
-
>
RegisterSelection
(
aSelection
)
;
}
aOutIndex
-
>
emplace
(
startIndex
+
insertionPoint
)
;
return
NS_OK
;
}
nsresult
Selection
:
:
StyledRanges
:
:
RemoveRangeAndUnregisterSelection
(
nsRange
&
aRange
)
{
int32_t
idx
=
-
1
;
uint32_t
i
;
for
(
i
=
0
;
i
<
mRanges
.
Length
(
)
;
i
+
+
)
{
if
(
mRanges
[
i
]
.
mRange
=
=
&
aRange
)
{
idx
=
(
int32_t
)
i
;
break
;
}
}
if
(
idx
<
0
)
return
NS_ERROR_DOM_NOT_FOUND_ERR
;
mRanges
.
RemoveElementAt
(
idx
)
;
aRange
.
UnregisterSelection
(
)
;
return
NS_OK
;
}
nsresult
Selection
:
:
RemoveCollapsedRanges
(
)
{
return
mStyledRanges
.
RemoveCollapsedRanges
(
)
;
}
nsresult
Selection
:
:
StyledRanges
:
:
RemoveCollapsedRanges
(
)
{
uint32_t
i
=
0
;
while
(
i
<
mRanges
.
Length
(
)
)
{
if
(
mRanges
[
i
]
.
mRange
-
>
Collapsed
(
)
)
{
nsresult
rv
=
RemoveRangeAndUnregisterSelection
(
*
mRanges
[
i
]
.
mRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
+
+
i
;
}
}
return
NS_OK
;
}
void
Selection
:
:
Clear
(
nsPresContext
*
aPresContext
)
{
RemoveAnchorFocusRange
(
)
;
mStyledRanges
.
UnregisterSelection
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mStyledRanges
.
Length
(
)
;
+
+
i
)
{
SelectFrames
(
aPresContext
mStyledRanges
.
mRanges
[
i
]
.
mRange
false
)
;
}
mStyledRanges
.
Clear
(
)
;
SetDirection
(
eDirNext
)
;
if
(
mFrameSelection
&
&
mFrameSelection
-
>
GetDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
mFrameSelection
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
}
}
bool
Selection
:
:
StyledRanges
:
:
HasEqualRangeBoundariesAt
(
const
nsRange
&
aRange
size_t
aRangeIndex
)
const
{
if
(
aRangeIndex
<
mRanges
.
Length
(
)
)
{
const
nsRange
*
range
=
mRanges
[
aRangeIndex
]
.
mRange
;
return
range
-
>
HasEqualBoundaries
(
aRange
)
;
}
return
false
;
}
void
Selection
:
:
GetRangesForInterval
(
nsINode
&
aBeginNode
uint32_t
aBeginOffset
nsINode
&
aEndNode
uint32_t
aEndOffset
bool
aAllowAdjacent
nsTArray
<
RefPtr
<
nsRange
>
>
&
aReturn
mozilla
:
:
ErrorResult
&
aRv
)
{
nsTArray
<
nsRange
*
>
results
;
nsresult
rv
=
GetRangesForIntervalArray
(
&
aBeginNode
aBeginOffset
&
aEndNode
aEndOffset
aAllowAdjacent
&
results
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aReturn
.
SetLength
(
results
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
results
.
Length
(
)
;
+
+
i
)
{
aReturn
[
i
]
=
results
[
i
]
;
}
}
nsresult
Selection
:
:
GetRangesForIntervalArray
(
nsINode
*
aBeginNode
uint32_t
aBeginOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
bool
aAllowAdjacent
nsTArray
<
nsRange
*
>
*
aRanges
)
{
if
(
NS_WARN_IF
(
!
aBeginNode
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
!
aEndNode
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
aRanges
-
>
Clear
(
)
;
Maybe
<
size_t
>
maybeStartIndex
maybeEndIndex
;
nsresult
res
=
mStyledRanges
.
GetIndicesForInterval
(
aBeginNode
aBeginOffset
aEndNode
aEndOffset
aAllowAdjacent
maybeStartIndex
maybeEndIndex
)
;
NS_ENSURE_SUCCESS
(
res
res
)
;
if
(
maybeStartIndex
.
isNothing
(
)
|
|
maybeEndIndex
.
isNothing
(
)
)
{
return
NS_OK
;
}
for
(
const
size_t
i
:
IntegerRange
(
*
maybeStartIndex
*
maybeEndIndex
)
)
{
aRanges
-
>
AppendElement
(
mStyledRanges
.
mRanges
[
i
]
.
mRange
)
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
StyledRanges
:
:
GetIndicesForInterval
(
const
nsINode
*
aBeginNode
uint32_t
aBeginOffset
const
nsINode
*
aEndNode
uint32_t
aEndOffset
bool
aAllowAdjacent
Maybe
<
size_t
>
&
aStartIndex
Maybe
<
size_t
>
&
aEndIndex
)
const
{
MOZ_ASSERT
(
aStartIndex
.
isNothing
(
)
)
;
MOZ_ASSERT
(
aEndIndex
.
isNothing
(
)
)
;
if
(
NS_WARN_IF
(
!
aBeginNode
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
if
(
NS_WARN_IF
(
!
aEndNode
)
)
{
return
NS_ERROR_INVALID_POINTER
;
}
if
(
mRanges
.
Length
(
)
=
=
0
)
{
return
NS_OK
;
}
const
bool
intervalIsCollapsed
=
aBeginNode
=
=
aEndNode
&
&
aBeginOffset
=
=
aEndOffset
;
size_t
endsBeforeIndex
{
FindInsertionPoint
(
&
mRanges
*
aEndNode
aEndOffset
&
CompareToRangeStart
)
}
;
if
(
endsBeforeIndex
=
=
0
)
{
const
nsRange
*
endRange
=
mRanges
[
endsBeforeIndex
]
.
mRange
;
if
(
!
endRange
-
>
StartRef
(
)
.
Equals
(
aEndNode
aEndOffset
)
)
{
return
NS_OK
;
}
if
(
!
aAllowAdjacent
&
&
!
(
endRange
-
>
Collapsed
(
)
&
&
intervalIsCollapsed
)
)
return
NS_OK
;
}
aEndIndex
.
emplace
(
endsBeforeIndex
)
;
size_t
beginsAfterIndex
{
FindInsertionPoint
(
&
mRanges
*
aBeginNode
aBeginOffset
&
CompareToRangeEnd
)
}
;
if
(
beginsAfterIndex
=
=
mRanges
.
Length
(
)
)
{
return
NS_OK
;
}
if
(
aAllowAdjacent
)
{
while
(
endsBeforeIndex
<
mRanges
.
Length
(
)
)
{
const
nsRange
*
endRange
=
mRanges
[
endsBeforeIndex
]
.
mRange
;
if
(
!
endRange
-
>
StartRef
(
)
.
Equals
(
aEndNode
aEndOffset
)
)
{
break
;
}
endsBeforeIndex
+
+
;
}
const
nsRange
*
beginRange
=
mRanges
[
beginsAfterIndex
]
.
mRange
;
if
(
beginsAfterIndex
>
0
&
&
beginRange
-
>
Collapsed
(
)
&
&
beginRange
-
>
EndRef
(
)
.
Equals
(
aBeginNode
aBeginOffset
)
)
{
beginRange
=
mRanges
[
beginsAfterIndex
-
1
]
.
mRange
;
if
(
beginRange
-
>
EndRef
(
)
.
Equals
(
aBeginNode
aBeginOffset
)
)
{
beginsAfterIndex
-
-
;
}
}
}
else
{
const
nsRange
*
beginRange
=
mRanges
[
beginsAfterIndex
]
.
mRange
;
if
(
beginRange
-
>
EndRef
(
)
.
Equals
(
aBeginNode
aBeginOffset
)
&
&
!
beginRange
-
>
Collapsed
(
)
)
{
beginsAfterIndex
+
+
;
}
if
(
endsBeforeIndex
<
mRanges
.
Length
(
)
)
{
const
nsRange
*
endRange
=
mRanges
[
endsBeforeIndex
]
.
mRange
;
if
(
endRange
-
>
StartRef
(
)
.
Equals
(
aEndNode
aEndOffset
)
&
&
endRange
-
>
Collapsed
(
)
)
{
endsBeforeIndex
+
+
;
}
}
}
NS_ASSERTION
(
beginsAfterIndex
<
=
endsBeforeIndex
"
Is
mRanges
not
ordered
?
"
)
;
NS_ENSURE_STATE
(
beginsAfterIndex
<
=
endsBeforeIndex
)
;
aStartIndex
.
emplace
(
beginsAfterIndex
)
;
aEndIndex
=
Some
(
endsBeforeIndex
)
;
return
NS_OK
;
}
nsIFrame
*
Selection
:
:
GetPrimaryFrameForAnchorNode
(
)
const
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
int32_t
frameOffset
=
0
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
GetAnchorNode
(
)
)
;
if
(
content
&
&
mFrameSelection
)
{
return
nsFrameSelection
:
:
GetFrameForNodeOffset
(
content
AnchorOffset
(
)
mFrameSelection
-
>
GetHint
(
)
&
frameOffset
)
;
}
return
nullptr
;
}
nsIFrame
*
Selection
:
:
GetPrimaryFrameForFocusNode
(
bool
aVisual
int32_t
*
aOffsetUsed
)
const
{
nsINode
*
focusNode
=
GetFocusNode
(
)
;
if
(
!
focusNode
|
|
!
focusNode
-
>
IsContent
(
)
|
|
!
mFrameSelection
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
content
=
focusNode
-
>
AsContent
(
)
;
int32_t
frameOffset
=
0
;
if
(
!
aOffsetUsed
)
{
aOffsetUsed
=
&
frameOffset
;
}
nsIFrame
*
frame
=
GetPrimaryOrCaretFrameForNodeOffset
(
content
FocusOffset
(
)
aOffsetUsed
aVisual
)
;
if
(
frame
)
{
return
frame
;
}
if
(
!
content
-
>
TextIsOnlyWhitespace
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
parent
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
int32_t
offset
=
parent
-
>
ComputeIndexOf
(
content
)
;
return
GetPrimaryOrCaretFrameForNodeOffset
(
parent
offset
aOffsetUsed
aVisual
)
;
}
nsIFrame
*
Selection
:
:
GetPrimaryOrCaretFrameForNodeOffset
(
nsIContent
*
aContent
uint32_t
aOffset
int32_t
*
aOffsetUsed
bool
aVisual
)
const
{
MOZ_ASSERT
(
aOffsetUsed
)
;
if
(
!
mFrameSelection
)
{
return
nullptr
;
}
CaretAssociationHint
hint
=
mFrameSelection
-
>
GetHint
(
)
;
if
(
aVisual
)
{
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
caretBidiLevel
=
mFrameSelection
-
>
GetCaretBidiLevel
(
)
;
return
nsCaret
:
:
GetCaretFrameForNodeOffset
(
mFrameSelection
aContent
aOffset
hint
caretBidiLevel
nullptr
aOffsetUsed
)
;
}
return
nsFrameSelection
:
:
GetFrameForNodeOffset
(
aContent
aOffset
hint
aOffsetUsed
)
;
}
void
Selection
:
:
SelectFramesOf
(
nsIContent
*
aContent
bool
aSelected
)
const
{
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
textFrame
-
>
SelectionStateChanged
(
0
textFrame
-
>
TextFragment
(
)
-
>
GetLength
(
)
aSelected
mSelectionType
)
;
}
else
{
frame
-
>
SelectionStateChanged
(
)
;
}
}
nsresult
Selection
:
:
SelectFramesOfInclusiveDescendantsOfContent
(
PostContentIterator
&
aPostOrderIter
nsIContent
*
aContent
bool
aSelected
)
const
{
if
(
!
aContent
-
>
HasChildren
(
)
)
{
SelectFramesOf
(
aContent
aSelected
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
aPostOrderIter
.
Init
(
aContent
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
;
!
aPostOrderIter
.
IsDone
(
)
;
aPostOrderIter
.
Next
(
)
)
{
nsINode
*
node
=
aPostOrderIter
.
GetCurrentNode
(
)
;
MOZ_ASSERT
(
node
)
;
nsIContent
*
innercontent
=
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
SelectFramesOf
(
innercontent
aSelected
)
;
}
return
NS_OK
;
}
void
Selection
:
:
SelectFramesInAllRanges
(
nsPresContext
*
aPresContext
)
{
for
(
size_t
i
=
0
;
i
<
mStyledRanges
.
Length
(
)
;
+
+
i
)
{
nsRange
*
range
=
mStyledRanges
.
mRanges
[
i
]
.
mRange
;
MOZ_ASSERT
(
range
-
>
IsInSelection
(
)
)
;
SelectFrames
(
aPresContext
range
range
-
>
IsInSelection
(
)
)
;
}
}
nsresult
Selection
:
:
SelectFrames
(
nsPresContext
*
aPresContext
nsRange
*
aRange
bool
aSelect
)
const
{
if
(
!
mFrameSelection
|
|
!
aPresContext
|
|
!
aPresContext
-
>
GetPresShell
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
aRange
&
&
aRange
-
>
IsPositioned
(
)
)
;
if
(
mFrameSelection
-
>
IsInTableSelectionMode
(
)
)
{
nsINode
*
node
=
aRange
-
>
GetClosestCommonInclusiveAncestor
(
)
;
nsIFrame
*
frame
=
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
:
aPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
frame
)
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
MOZ_ASSERT
(
node
=
=
aRange
-
>
GetStartContainer
(
)
)
;
MOZ_ASSERT
(
node
=
=
aRange
-
>
GetEndContainer
(
)
)
;
textFrame
-
>
SelectionStateChanged
(
aRange
-
>
StartOffset
(
)
aRange
-
>
EndOffset
(
)
aSelect
mSelectionType
)
;
}
else
{
frame
-
>
SelectionStateChanged
(
)
;
}
}
return
NS_OK
;
}
nsINode
*
startNode
=
aRange
-
>
GetStartContainer
(
)
;
nsIContent
*
startContent
=
startNode
-
>
IsContent
(
)
?
startNode
-
>
AsContent
(
)
:
nullptr
;
if
(
!
startContent
)
{
return
NS_ERROR_UNEXPECTED
;
}
bool
isFirstContentTextNode
=
startContent
-
>
IsText
(
)
;
nsINode
*
endNode
=
aRange
-
>
GetEndContainer
(
)
;
if
(
isFirstContentTextNode
)
{
nsIFrame
*
frame
=
startContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
uint32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
uint32_t
endOffset
;
if
(
endNode
=
=
startContent
)
{
endOffset
=
aRange
-
>
EndOffset
(
)
;
}
else
{
endOffset
=
startContent
-
>
Length
(
)
;
}
textFrame
-
>
SelectionStateChanged
(
startOffset
endOffset
aSelect
mSelectionType
)
;
}
else
{
frame
-
>
SelectionStateChanged
(
)
;
}
}
}
if
(
aRange
-
>
Collapsed
(
)
|
|
(
startNode
=
=
endNode
&
&
!
startNode
-
>
HasChildren
(
)
)
)
{
if
(
!
isFirstContentTextNode
)
{
SelectFramesOf
(
startContent
aSelect
)
;
}
return
NS_OK
;
}
ContentSubtreeIterator
subtreeIter
;
subtreeIter
.
Init
(
aRange
)
;
if
(
isFirstContentTextNode
&
&
!
subtreeIter
.
IsDone
(
)
&
&
subtreeIter
.
GetCurrentNode
(
)
=
=
startNode
)
{
subtreeIter
.
Next
(
)
;
}
PostContentIterator
postOrderIter
;
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsINode
*
node
=
subtreeIter
.
GetCurrentNode
(
)
;
MOZ_ASSERT
(
node
)
;
nsIContent
*
content
=
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
SelectFramesOfInclusiveDescendantsOfContent
(
postOrderIter
content
aSelect
)
;
}
if
(
endNode
!
=
startNode
)
{
nsIContent
*
endContent
=
endNode
-
>
IsContent
(
)
?
endNode
-
>
AsContent
(
)
:
nullptr
;
if
(
NS_WARN_IF
(
!
endContent
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
endContent
-
>
IsText
(
)
)
{
nsIFrame
*
frame
=
endContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
textFrame
-
>
SelectionStateChanged
(
0
aRange
-
>
EndOffset
(
)
aSelect
mSelectionType
)
;
}
}
}
return
NS_OK
;
}
UniquePtr
<
SelectionDetails
>
Selection
:
:
LookUpSelection
(
nsIContent
*
aContent
uint32_t
aContentOffset
uint32_t
aContentLength
UniquePtr
<
SelectionDetails
>
aDetailsHead
SelectionType
aSelectionType
bool
aSlowCheck
)
{
if
(
!
aContent
)
{
return
aDetailsHead
;
}
if
(
mStyledRanges
.
Length
(
)
=
=
0
)
{
return
aDetailsHead
;
}
nsTArray
<
nsRange
*
>
overlappingRanges
;
nsresult
rv
=
GetRangesForIntervalArray
(
aContent
aContentOffset
aContent
aContentOffset
+
aContentLength
false
&
overlappingRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
aDetailsHead
;
}
if
(
overlappingRanges
.
Length
(
)
=
=
0
)
{
return
aDetailsHead
;
}
UniquePtr
<
SelectionDetails
>
detailsHead
=
std
:
:
move
(
aDetailsHead
)
;
for
(
size_t
i
=
0
;
i
<
overlappingRanges
.
Length
(
)
;
i
+
+
)
{
nsRange
*
range
=
overlappingRanges
[
i
]
;
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
uint32_t
startOffset
=
range
-
>
StartOffset
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
Maybe
<
uint32_t
>
start
end
;
if
(
startNode
=
=
aContent
&
&
endNode
=
=
aContent
)
{
if
(
startOffset
<
(
aContentOffset
+
aContentLength
)
&
&
endOffset
>
aContentOffset
)
{
start
.
emplace
(
startOffset
>
=
aContentOffset
?
startOffset
-
aContentOffset
:
0u
)
;
end
.
emplace
(
std
:
:
min
(
aContentLength
endOffset
-
aContentOffset
)
)
;
}
}
else
if
(
startNode
=
=
aContent
)
{
if
(
startOffset
<
(
aContentOffset
+
aContentLength
)
)
{
start
.
emplace
(
startOffset
>
=
aContentOffset
?
startOffset
-
aContentOffset
:
0u
)
;
end
.
emplace
(
aContentLength
)
;
}
}
else
if
(
endNode
=
=
aContent
)
{
if
(
endOffset
>
aContentOffset
)
{
start
.
emplace
(
0u
)
;
end
.
emplace
(
std
:
:
min
(
aContentLength
endOffset
-
aContentOffset
)
)
;
}
}
else
{
start
.
emplace
(
0u
)
;
end
.
emplace
(
aContentLength
)
;
}
if
(
start
.
isNothing
(
)
)
{
continue
;
}
auto
newHead
=
MakeUnique
<
SelectionDetails
>
(
)
;
newHead
-
>
mNext
=
std
:
:
move
(
detailsHead
)
;
newHead
-
>
mStart
=
AssertedCast
<
int32_t
>
(
*
start
)
;
newHead
-
>
mEnd
=
AssertedCast
<
int32_t
>
(
*
end
)
;
newHead
-
>
mSelectionType
=
aSelectionType
;
StyledRange
*
rd
=
mStyledRanges
.
FindRangeData
(
range
)
;
if
(
rd
)
{
newHead
-
>
mTextRangeStyle
=
rd
-
>
mTextRangeStyle
;
}
detailsHead
=
std
:
:
move
(
newHead
)
;
}
return
detailsHead
;
}
NS_IMETHODIMP
Selection
:
:
Repaint
(
nsPresContext
*
aPresContext
)
{
int32_t
arrCount
=
(
int32_t
)
mStyledRanges
.
Length
(
)
;
if
(
arrCount
<
1
)
return
NS_OK
;
int32_t
i
;
for
(
i
=
0
;
i
<
arrCount
;
i
+
+
)
{
nsresult
rv
=
SelectFrames
(
aPresContext
mStyledRanges
.
mRanges
[
i
]
.
mRange
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
void
Selection
:
:
SetCanCacheFrameOffset
(
bool
aCanCacheFrameOffset
)
{
if
(
!
mCachedOffsetForFrame
)
{
mCachedOffsetForFrame
=
new
CachedOffsetForFrame
;
}
mCachedOffsetForFrame
-
>
mCanCacheFrameOffset
=
aCanCacheFrameOffset
;
if
(
!
aCanCacheFrameOffset
)
{
mCachedOffsetForFrame
-
>
mLastCaretFrame
=
nullptr
;
}
}
nsresult
Selection
:
:
GetCachedFrameOffset
(
nsIFrame
*
aFrame
int32_t
inOffset
nsPoint
&
aPoint
)
{
if
(
!
mCachedOffsetForFrame
)
{
mCachedOffsetForFrame
=
new
CachedOffsetForFrame
;
}
nsresult
rv
=
NS_OK
;
if
(
mCachedOffsetForFrame
-
>
mCanCacheFrameOffset
&
&
mCachedOffsetForFrame
-
>
mLastCaretFrame
&
&
(
aFrame
=
=
mCachedOffsetForFrame
-
>
mLastCaretFrame
)
&
&
(
inOffset
=
=
mCachedOffsetForFrame
-
>
mLastContentOffset
)
)
{
aPoint
=
mCachedOffsetForFrame
-
>
mCachedFrameOffset
;
}
else
{
rv
=
aFrame
-
>
GetPointFromOffset
(
inOffset
&
aPoint
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mCachedOffsetForFrame
-
>
mCanCacheFrameOffset
)
{
mCachedOffsetForFrame
-
>
mCachedFrameOffset
=
aPoint
;
mCachedOffsetForFrame
-
>
mLastCaretFrame
=
aFrame
;
mCachedOffsetForFrame
-
>
mLastContentOffset
=
inOffset
;
}
}
return
rv
;
}
nsIContent
*
Selection
:
:
GetAncestorLimiter
(
)
const
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
mFrameSelection
)
{
return
mFrameSelection
-
>
GetAncestorLimiter
(
)
;
}
return
nullptr
;
}
void
Selection
:
:
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
SetAncestorLimiter
(
aLimiter
)
;
}
}
void
Selection
:
:
StyledRanges
:
:
UnregisterSelection
(
)
{
uint32_t
count
=
mRanges
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
mRanges
[
i
]
.
mRange
-
>
UnregisterSelection
(
)
;
}
}
void
Selection
:
:
StyledRanges
:
:
Clear
(
)
{
mRanges
.
Clear
(
)
;
}
StyledRange
*
Selection
:
:
StyledRanges
:
:
FindRangeData
(
nsRange
*
aRange
)
{
NS_ENSURE_TRUE
(
aRange
nullptr
)
;
for
(
uint32_t
i
=
0
;
i
<
mRanges
.
Length
(
)
;
i
+
+
)
{
if
(
mRanges
[
i
]
.
mRange
=
=
aRange
)
{
return
&
mRanges
[
i
]
;
}
}
return
nullptr
;
}
Selection
:
:
StyledRanges
:
:
Elements
:
:
size_type
Selection
:
:
StyledRanges
:
:
Length
(
)
const
{
return
mRanges
.
Length
(
)
;
}
nsresult
Selection
:
:
SetTextRangeStyle
(
nsRange
*
aRange
const
TextRangeStyle
&
aTextRangeStyle
)
{
NS_ENSURE_ARG_POINTER
(
aRange
)
;
StyledRange
*
rd
=
mStyledRanges
.
FindRangeData
(
aRange
)
;
if
(
rd
)
{
rd
-
>
mTextRangeStyle
=
aTextRangeStyle
;
}
return
NS_OK
;
}
nsresult
Selection
:
:
StartAutoScrollTimer
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aDelayInMs
)
{
MOZ_ASSERT
(
aFrame
"
Need
a
frame
"
)
;
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mFrameSelection
)
{
return
NS_OK
;
}
if
(
!
mAutoScroller
)
{
mAutoScroller
=
new
AutoScroller
(
mFrameSelection
)
;
}
mAutoScroller
-
>
SetDelay
(
aDelayInMs
)
;
RefPtr
<
AutoScroller
>
autoScroller
{
mAutoScroller
}
;
return
autoScroller
-
>
DoAutoScroll
(
aFrame
aPoint
)
;
}
nsresult
Selection
:
:
StopAutoScrollTimer
(
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
mAutoScroller
)
{
mAutoScroller
-
>
Stop
(
AutoScroller
:
:
FurtherScrollingAllowed
:
:
kYes
)
;
}
return
NS_OK
;
}
nsresult
AutoScroller
:
:
DoAutoScroll
(
nsIFrame
*
aFrame
nsPoint
aPoint
)
{
MOZ_ASSERT
(
aFrame
"
Need
a
frame
"
)
;
Stop
(
FurtherScrollingAllowed
:
:
kYes
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
RefPtr
<
PresShell
>
presShell
=
presContext
-
>
PresShell
(
)
;
nsRootPresContext
*
rootPC
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPC
)
return
NS_OK
;
nsIFrame
*
rootmostFrame
=
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
AutoWeakFrame
weakRootFrame
(
rootmostFrame
)
;
AutoWeakFrame
weakFrame
(
aFrame
)
;
nsPoint
globalPoint
=
aPoint
+
aFrame
-
>
GetOffsetToCrossDoc
(
rootmostFrame
)
;
bool
done
=
false
;
bool
didScroll
;
while
(
true
)
{
didScroll
=
presShell
-
>
ScrollFrameRectIntoView
(
aFrame
nsRect
(
aPoint
nsSize
(
0
0
)
)
nsMargin
(
)
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
None
)
;
if
(
!
weakFrame
|
|
!
weakRootFrame
)
{
return
NS_OK
;
}
if
(
!
didScroll
&
&
!
done
)
{
RefPtr
<
nsDeviceContext
>
dx
=
presShell
-
>
GetViewManager
(
)
-
>
GetDeviceContext
(
)
;
nsRect
screen
;
dx
-
>
GetRect
(
screen
)
;
nsPoint
screenPoint
=
globalPoint
+
rootmostFrame
-
>
GetScreenRectInAppUnits
(
)
.
TopLeft
(
)
;
nscoord
onePx
=
AppUnitsPerCSSPixel
(
)
;
nscoord
scrollAmount
=
10
*
onePx
;
if
(
std
:
:
abs
(
screen
.
x
-
screenPoint
.
x
)
<
=
onePx
)
{
aPoint
.
x
-
=
scrollAmount
;
}
else
if
(
std
:
:
abs
(
screen
.
XMost
(
)
-
screenPoint
.
x
)
<
=
onePx
)
{
aPoint
.
x
+
=
scrollAmount
;
}
else
if
(
std
:
:
abs
(
screen
.
y
-
screenPoint
.
y
)
<
=
onePx
)
{
aPoint
.
y
-
=
scrollAmount
;
}
else
if
(
std
:
:
abs
(
screen
.
YMost
(
)
-
screenPoint
.
y
)
<
=
onePx
)
{
aPoint
.
y
+
=
scrollAmount
;
}
else
{
break
;
}
done
=
true
;
continue
;
}
break
;
}
if
(
didScroll
&
&
(
mFurtherScrollingAllowed
=
=
FurtherScrollingAllowed
:
:
kYes
)
)
{
nsPoint
presContextPoint
=
globalPoint
-
presShell
-
>
GetRootFrame
(
)
-
>
GetOffsetToCrossDoc
(
rootmostFrame
)
;
ScheduleNextDoAutoScroll
(
presContext
presContextPoint
)
;
}
return
NS_OK
;
}
void
Selection
:
:
RemoveAllRanges
(
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
Clear
(
presContext
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
ClearTableCellSelection
(
)
;
RefPtr
<
Selection
>
kungFuDeathGrip
{
this
}
;
NotifySelectionListeners
(
)
;
}
void
Selection
:
:
AddRangeJS
(
nsRange
&
aRange
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
AddRangeAndSelectFramesAndNotifyListeners
(
aRange
aRv
)
;
}
void
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
nsRange
&
aRange
ErrorResult
&
aRv
)
{
RefPtr
<
Document
>
document
(
GetDocument
(
)
)
;
return
AddRangeAndSelectFramesAndNotifyListeners
(
aRange
document
aRv
)
;
}
void
Selection
:
:
AddRangeAndSelectFramesAndNotifyListeners
(
nsRange
&
aRange
Document
*
aDocument
ErrorResult
&
aRv
)
{
RefPtr
<
nsRange
>
range
;
if
(
aRange
.
IsInSelection
(
)
&
&
aRange
.
GetSelection
(
)
!
=
this
)
{
range
=
aRange
.
CloneRange
(
)
;
}
else
{
range
=
&
aRange
;
}
nsINode
*
rangeRoot
=
range
-
>
GetRoot
(
)
;
if
(
aDocument
!
=
rangeRoot
&
&
(
!
rangeRoot
|
|
aDocument
!
=
rangeRoot
-
>
GetComposedDoc
(
)
)
)
{
return
;
}
RefPtr
<
Selection
>
kungFuDeathGrip
(
this
)
;
Maybe
<
size_t
>
maybeRangeIndex
;
nsresult
result
=
MaybeAddTableCellRange
(
*
range
&
maybeRangeIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
if
(
maybeRangeIndex
.
isNothing
(
)
)
{
result
=
AddRangesForSelectableNodes
(
range
&
maybeRangeIndex
DispatchSelectstartEvent
:
:
Maybe
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
if
(
maybeRangeIndex
.
isNothing
(
)
)
{
return
;
}
}
MOZ_ASSERT
(
*
maybeRangeIndex
<
mStyledRanges
.
Length
(
)
)
;
SetAnchorFocusRange
(
*
maybeRangeIndex
)
;
if
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
{
SetInterlinePosition
(
true
IgnoreErrors
(
)
)
;
}
if
(
!
mFrameSelection
)
{
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
SelectFrames
(
presContext
range
true
)
;
NotifySelectionListeners
(
)
;
}
void
Selection
:
:
RemoveRangeAndUnselectFramesAndNotifyListeners
(
nsRange
&
aRange
ErrorResult
&
aRv
)
{
nsresult
rv
=
mStyledRanges
.
RemoveRangeAndUnregisterSelection
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
nsINode
*
beginNode
=
aRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRange
.
GetEndContainer
(
)
;
if
(
!
beginNode
|
|
!
endNode
)
{
return
;
}
uint32_t
beginOffset
endOffset
;
if
(
endNode
-
>
IsText
(
)
)
{
beginOffset
=
0
;
endOffset
=
endNode
-
>
AsText
(
)
-
>
TextLength
(
)
;
}
else
{
beginOffset
=
aRange
.
StartOffset
(
)
;
endOffset
=
aRange
.
EndOffset
(
)
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
SelectFrames
(
presContext
&
aRange
false
)
;
nsTArray
<
nsRange
*
>
affectedRanges
;
rv
=
GetRangesForIntervalArray
(
beginNode
beginOffset
endNode
endOffset
true
&
affectedRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
for
(
uint32_t
i
=
0
;
i
<
affectedRanges
.
Length
(
)
;
i
+
+
)
{
SelectFrames
(
presContext
affectedRanges
[
i
]
true
)
;
}
if
(
&
aRange
=
=
mAnchorFocusRange
)
{
const
size_t
rangeCount
=
mStyledRanges
.
Length
(
)
;
if
(
rangeCount
)
{
SetAnchorFocusRange
(
rangeCount
-
1
)
;
}
else
{
RemoveAnchorFocusRange
(
)
;
}
if
(
mSelectionType
!
=
SelectionType
:
:
eSpellCheck
&
&
rangeCount
)
{
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
)
;
}
}
if
(
!
mFrameSelection
)
return
;
RefPtr
<
Selection
>
kungFuDeathGrip
{
this
}
;
NotifySelectionListeners
(
)
;
}
void
Selection
:
:
CollapseJS
(
nsINode
*
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
if
(
!
aContainer
)
{
RemoveAllRanges
(
aRv
)
;
return
;
}
CollapseInternal
(
InLimiter
:
:
eNo
RawRangeBoundary
(
aContainer
aOffset
)
aRv
)
;
}
void
Selection
:
:
CollapseInternal
(
InLimiter
aInLimiter
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
!
aPoint
.
IsSet
(
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
if
(
aPoint
.
Container
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
{
aRv
.
ThrowInvalidNodeTypeError
(
kNoDocumentTypeNodeError
)
;
return
;
}
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
aRv
.
ThrowIndexSizeError
(
"
The
offset
is
out
of
range
.
"
)
;
return
;
}
if
(
!
HasSameRootOrSameComposedDoc
(
*
aPoint
.
Container
(
)
)
)
{
return
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
InvalidateDesiredCaretPos
(
)
;
if
(
aInLimiter
=
=
InLimiter
:
:
eYes
&
&
!
frameSelection
-
>
IsValidSelectionPoint
(
aPoint
.
Container
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsresult
result
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
|
|
presContext
-
>
Document
(
)
!
=
aPoint
.
Container
(
)
-
>
OwnerDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Clear
(
presContext
)
;
frameSelection
-
>
ClearTableCellSelection
(
)
;
if
(
frameSelection
-
>
GetHint
(
)
!
=
CARET_ASSOCIATE_AFTER
&
&
aPoint
.
Container
(
)
-
>
IsContent
(
)
)
{
int32_t
frameOffset
;
nsTextFrame
*
f
=
do_QueryFrame
(
nsCaret
:
:
GetFrameAndOffset
(
this
aPoint
.
Container
(
)
*
aPoint
.
Offset
(
RawRangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
&
frameOffset
)
)
;
if
(
f
&
&
f
-
>
IsAtEndOfLine
(
)
&
&
f
-
>
HasSignificantTerminalNewline
(
)
)
{
if
(
(
aPoint
.
Container
(
)
-
>
AsContent
(
)
=
=
f
-
>
GetContent
(
)
&
&
f
-
>
GetContentEnd
(
)
=
=
static_cast
<
int32_t
>
(
*
aPoint
.
Offset
(
RawRangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
)
)
|
|
(
aPoint
.
Container
(
)
=
=
f
-
>
GetContent
(
)
-
>
GetParentNode
(
)
&
&
f
-
>
GetContent
(
)
=
=
aPoint
.
GetPreviousSiblingOfChildAtOffset
(
)
)
)
{
frameSelection
-
>
SetHint
(
CARET_ASSOCIATE_AFTER
)
;
}
}
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aPoint
.
Container
(
)
)
;
result
=
range
-
>
CollapseTo
(
aPoint
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
#
ifdef
DEBUG_SELECTION
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aPoint
.
Container
(
)
)
;
nsCOMPtr
<
Document
>
doc
=
do_QueryInterface
(
aPoint
.
Container
(
)
)
;
printf
(
"
Sel
.
Collapse
to
%
p
%
s
%
d
\
n
"
container
.
get
(
)
content
?
nsAtomCString
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
:
(
doc
?
"
DOCUMENT
"
:
"
?
?
?
"
)
aPoint
.
Offset
(
)
)
;
#
endif
Maybe
<
size_t
>
maybeRangeIndex
;
result
=
AddRangesForSelectableNodes
(
range
&
maybeRangeIndex
DispatchSelectstartEvent
:
:
Maybe
)
;
if
(
NS_FAILED
(
result
)
)
{
aRv
.
Throw
(
result
)
;
return
;
}
SetAnchorFocusRange
(
0
)
;
SelectFrames
(
presContext
range
true
)
;
RefPtr
<
Selection
>
kungFuDeathGrip
{
this
}
;
NotifySelectionListeners
(
)
;
}
void
Selection
:
:
CollapseToStartJS
(
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
CollapseToStart
(
aRv
)
;
}
void
Selection
:
:
CollapseToStart
(
ErrorResult
&
aRv
)
{
if
(
RangeCount
(
)
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
kNoRangeExistsError
)
;
return
;
}
const
nsRange
*
firstRange
=
mStyledRanges
.
mRanges
[
0
]
.
mRange
;
if
(
!
firstRange
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mFrameSelection
)
{
mFrameSelection
-
>
AddChangeReasons
(
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
)
;
}
nsINode
*
container
=
firstRange
-
>
GetStartContainer
(
)
;
if
(
!
container
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
CollapseInternal
(
InLimiter
:
:
eNo
RawRangeBoundary
(
container
firstRange
-
>
StartOffset
(
)
)
aRv
)
;
}
void
Selection
:
:
CollapseToEndJS
(
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
CollapseToEnd
(
aRv
)
;
}
void
Selection
:
:
CollapseToEnd
(
ErrorResult
&
aRv
)
{
uint32_t
cnt
=
RangeCount
(
)
;
if
(
cnt
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
kNoRangeExistsError
)
;
return
;
}
const
nsRange
*
lastRange
=
mStyledRanges
.
mRanges
[
cnt
-
1
]
.
mRange
;
if
(
!
lastRange
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mFrameSelection
)
{
mFrameSelection
-
>
AddChangeReasons
(
nsISelectionListener
:
:
COLLAPSETOEND_REASON
)
;
}
nsINode
*
container
=
lastRange
-
>
GetEndContainer
(
)
;
if
(
!
container
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
CollapseInternal
(
InLimiter
:
:
eNo
RawRangeBoundary
(
container
lastRange
-
>
EndOffset
(
)
)
aRv
)
;
}
void
Selection
:
:
GetType
(
nsAString
&
aOutType
)
const
{
if
(
!
RangeCount
(
)
)
{
aOutType
.
AssignLiteral
(
"
None
"
)
;
}
else
if
(
IsCollapsed
(
)
)
{
aOutType
.
AssignLiteral
(
"
Caret
"
)
;
}
else
{
aOutType
.
AssignLiteral
(
"
Range
"
)
;
}
}
nsRange
*
Selection
:
:
GetRangeAt
(
uint32_t
aIndex
ErrorResult
&
aRv
)
{
nsRange
*
range
=
GetRangeAt
(
aIndex
)
;
if
(
!
range
)
{
aRv
.
ThrowIndexSizeError
(
nsPrintfCString
(
"
%
u
is
out
of
range
"
aIndex
)
)
;
return
nullptr
;
}
return
range
;
}
nsRange
*
Selection
:
:
GetRangeAt
(
int32_t
aIndex
)
const
{
StyledRange
empty
(
nullptr
)
;
return
mStyledRanges
.
mRanges
.
SafeElementAt
(
aIndex
empty
)
.
mRange
;
}
nsresult
Selection
:
:
SetAnchorFocusToRange
(
nsRange
*
aRange
)
{
NS_ENSURE_STATE
(
mAnchorFocusRange
)
;
const
DispatchSelectstartEvent
dispatchSelectstartEvent
=
IsCollapsed
(
)
?
DispatchSelectstartEvent
:
:
Maybe
:
DispatchSelectstartEvent
:
:
No
;
nsresult
rv
=
mStyledRanges
.
RemoveRangeAndUnregisterSelection
(
*
mAnchorFocusRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Maybe
<
size_t
>
maybeOutIndex
;
rv
=
AddRangesForSelectableNodes
(
aRange
&
maybeOutIndex
dispatchSelectstartEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
maybeOutIndex
.
isSome
(
)
)
{
SetAnchorFocusRange
(
*
maybeOutIndex
)
;
}
else
{
RemoveAnchorFocusRange
(
)
;
}
return
NS_OK
;
}
void
Selection
:
:
ReplaceAnchorFocusRange
(
nsRange
*
aRange
)
{
NS_ENSURE_TRUE_VOID
(
mAnchorFocusRange
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
SelectFrames
(
presContext
mAnchorFocusRange
false
)
;
SetAnchorFocusToRange
(
aRange
)
;
SelectFrames
(
presContext
mAnchorFocusRange
true
)
;
}
}
void
Selection
:
:
AdjustAnchorFocusForMultiRange
(
nsDirection
aDirection
)
{
if
(
aDirection
=
=
mDirection
)
{
return
;
}
SetDirection
(
aDirection
)
;
if
(
RangeCount
(
)
<
=
1
)
{
return
;
}
nsRange
*
firstRange
=
GetRangeAt
(
0
)
;
nsRange
*
lastRange
=
GetRangeAt
(
RangeCount
(
)
-
1
)
;
if
(
mDirection
=
=
eDirPrevious
)
{
firstRange
-
>
SetIsGenerated
(
false
)
;
lastRange
-
>
SetIsGenerated
(
true
)
;
SetAnchorFocusRange
(
0
)
;
}
else
{
firstRange
-
>
SetIsGenerated
(
true
)
;
lastRange
-
>
SetIsGenerated
(
false
)
;
SetAnchorFocusRange
(
RangeCount
(
)
-
1
)
;
}
}
void
Selection
:
:
ExtendJS
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
Extend
(
aContainer
aOffset
aRv
)
;
}
nsresult
Selection
:
:
Extend
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
if
(
!
aContainer
)
{
return
NS_ERROR_INVALID_ARG
;
}
ErrorResult
result
;
Extend
(
*
aContainer
aOffset
result
)
;
return
result
.
StealNSResult
(
)
;
}
void
Selection
:
:
Extend
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
mAnchorFocusRange
)
{
aRv
.
ThrowInvalidStateError
(
kNoRangeExistsError
)
;
return
;
}
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
!
HasSameRootOrSameComposedDoc
(
aContainer
)
)
{
return
;
}
nsresult
res
;
if
(
!
mFrameSelection
-
>
IsValidSelectionPoint
(
&
aContainer
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
|
|
presContext
-
>
Document
(
)
!
=
aContainer
.
OwnerDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
#
ifdef
DEBUG_SELECTION
nsDirection
oldDirection
=
GetDirection
(
)
;
#
endif
nsINode
*
anchorNode
=
GetAnchorNode
(
)
;
nsINode
*
focusNode
=
GetFocusNode
(
)
;
uint32_t
anchorOffset
=
AnchorOffset
(
)
;
uint32_t
focusOffset
=
FocusOffset
(
)
;
RefPtr
<
nsRange
>
range
=
mAnchorFocusRange
-
>
CloneRange
(
)
;
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
range
-
>
StartOffset
(
)
;
int32_t
endOffset
=
range
-
>
EndOffset
(
)
;
bool
shouldClearRange
=
false
;
const
Maybe
<
int32_t
>
anchorOldFocusOrder
=
nsContentUtils
:
:
ComparePoints
(
anchorNode
anchorOffset
focusNode
focusOffset
)
;
shouldClearRange
|
=
!
anchorOldFocusOrder
;
const
Maybe
<
int32_t
>
oldFocusNewFocusOrder
=
nsContentUtils
:
:
ComparePoints
(
focusNode
focusOffset
&
aContainer
aOffset
)
;
shouldClearRange
|
=
!
oldFocusNewFocusOrder
;
const
Maybe
<
int32_t
>
anchorNewFocusOrder
=
nsContentUtils
:
:
ComparePoints
(
anchorNode
anchorOffset
&
aContainer
aOffset
)
;
shouldClearRange
|
=
!
anchorNewFocusOrder
;
if
(
shouldClearRange
)
{
SelectFrames
(
presContext
range
false
)
;
res
=
range
-
>
CollapseTo
(
&
aContainer
aOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
else
{
RefPtr
<
nsRange
>
difRange
=
nsRange
:
:
Create
(
&
aContainer
)
;
if
(
(
*
anchorOldFocusOrder
=
=
0
&
&
*
anchorNewFocusOrder
<
0
)
|
|
(
*
anchorOldFocusOrder
<
=
0
&
&
*
oldFocusNewFocusOrder
<
0
)
)
{
range
-
>
SetEnd
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetDirection
(
eDirNext
)
;
res
=
difRange
-
>
SetStartAndEnd
(
focusNode
focusOffset
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
true
)
;
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
else
if
(
*
anchorOldFocusOrder
=
=
0
&
&
*
anchorNewFocusOrder
>
0
)
{
SetDirection
(
eDirPrevious
)
;
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SelectFrames
(
presContext
range
true
)
;
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
else
if
(
*
anchorNewFocusOrder
<
=
0
&
&
*
oldFocusNewFocusOrder
>
=
0
)
{
res
=
difRange
-
>
SetStartAndEnd
(
&
aContainer
aOffset
focusNode
focusOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
range
-
>
SetEnd
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
difRange
-
>
SetEnd
(
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
;
SelectFrames
(
presContext
difRange
true
)
;
}
else
if
(
*
anchorOldFocusOrder
>
=
0
&
&
*
anchorNewFocusOrder
<
=
0
)
{
if
(
GetDirection
(
)
=
=
eDirPrevious
)
{
res
=
range
-
>
SetStart
(
endNode
endOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
SetDirection
(
eDirNext
)
;
range
-
>
SetEnd
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
focusNode
!
=
anchorNode
|
|
focusOffset
!
=
anchorOffset
)
{
res
=
difRange
-
>
SetStart
(
focusNode
focusOffset
)
;
nsresult
tmp
=
difRange
-
>
SetEnd
(
anchorNode
anchorOffset
)
;
if
(
NS_FAILED
(
tmp
)
)
{
res
=
tmp
;
}
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
}
else
{
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
SelectFrames
(
presContext
range
true
)
;
}
else
if
(
*
oldFocusNewFocusOrder
<
=
0
&
&
*
anchorNewFocusOrder
>
=
0
)
{
res
=
difRange
-
>
SetStartAndEnd
(
focusNode
focusOffset
&
aContainer
aOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SetDirection
(
eDirPrevious
)
;
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
difRange
-
>
SetStart
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
)
;
SelectFrames
(
presContext
difRange
true
)
;
}
else
if
(
*
anchorNewFocusOrder
>
=
0
&
&
*
anchorOldFocusOrder
<
=
0
)
{
if
(
GetDirection
(
)
=
=
eDirNext
)
{
range
-
>
SetEnd
(
startNode
startOffset
)
;
}
SetDirection
(
eDirPrevious
)
;
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
focusNode
!
=
anchorNode
|
|
focusOffset
!
=
anchorOffset
)
{
res
=
difRange
-
>
SetStartAndEnd
(
anchorNode
anchorOffset
focusNode
focusOffset
)
;
nsresult
tmp
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
tmp
)
)
{
res
=
tmp
;
}
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
false
)
;
}
else
{
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
SelectFrames
(
presContext
range
true
)
;
}
else
if
(
*
oldFocusNewFocusOrder
>
=
0
&
&
*
anchorOldFocusOrder
>
=
0
)
{
range
-
>
SetStart
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetDirection
(
eDirPrevious
)
;
res
=
difRange
-
>
SetStartAndEnd
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
focusNode
focusOffset
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
SelectFrames
(
presContext
difRange
true
)
;
res
=
SetAnchorFocusToRange
(
range
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
}
if
(
mStyledRanges
.
Length
(
)
>
1
)
{
SelectFramesInAllRanges
(
presContext
)
;
}
DEBUG_OUT_RANGE
(
range
)
;
#
ifdef
DEBUG_SELECTION
if
(
GetDirection
(
)
!
=
oldDirection
)
{
printf
(
"
direction
changed
to
%
s
\
n
"
GetDirection
(
)
=
=
eDirNext
?
"
eDirNext
"
:
"
eDirPrevious
"
)
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
&
aContainer
)
;
printf
(
"
Sel
.
Extend
to
%
p
%
s
%
d
\
n
"
content
.
get
(
)
nsAtomCString
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
aOffset
)
;
#
endif
RefPtr
<
Selection
>
kungFuDeathGrip
{
this
}
;
NotifySelectionListeners
(
)
;
}
void
Selection
:
:
SelectAllChildrenJS
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
SelectAllChildren
(
aNode
aRv
)
;
}
void
Selection
:
:
SelectAllChildren
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
aNode
.
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
{
aRv
.
ThrowInvalidNodeTypeError
(
kNoDocumentTypeNodeError
)
;
return
;
}
if
(
!
HasSameRootOrSameComposedDoc
(
aNode
)
)
{
return
;
}
if
(
mFrameSelection
)
{
mFrameSelection
-
>
AddChangeReasons
(
nsISelectionListener
:
:
SELECTALL_REASON
)
;
}
SetStartAndEndInternal
(
InLimiter
:
:
eNo
RawRangeBoundary
(
&
aNode
0u
)
RawRangeBoundary
(
&
aNode
aNode
.
GetChildCount
(
)
)
eDirNext
aRv
)
;
}
bool
Selection
:
:
ContainsNode
(
nsINode
&
aNode
bool
aAllowPartial
ErrorResult
&
aRv
)
{
nsresult
rv
;
if
(
mStyledRanges
.
Length
(
)
=
=
0
)
{
return
false
;
}
uint32_t
nodeLength
;
auto
*
nodeAsCharData
=
CharacterData
:
:
FromNode
(
aNode
)
;
if
(
nodeAsCharData
)
{
nodeLength
=
nodeAsCharData
-
>
TextLength
(
)
;
}
else
{
nodeLength
=
aNode
.
GetChildCount
(
)
;
}
nsTArray
<
nsRange
*
>
overlappingRanges
;
rv
=
GetRangesForIntervalArray
(
&
aNode
0
&
aNode
nodeLength
false
&
overlappingRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
false
;
}
if
(
overlappingRanges
.
Length
(
)
=
=
0
)
return
false
;
if
(
aAllowPartial
)
{
return
true
;
}
if
(
nodeAsCharData
)
{
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
overlappingRanges
.
Length
(
)
;
i
+
+
)
{
bool
nodeStartsBeforeRange
nodeEndsAfterRange
;
if
(
NS_SUCCEEDED
(
RangeUtils
:
:
CompareNodeToRange
(
&
aNode
overlappingRanges
[
i
]
&
nodeStartsBeforeRange
&
nodeEndsAfterRange
)
)
)
{
if
(
!
nodeStartsBeforeRange
&
&
!
nodeEndsAfterRange
)
{
return
true
;
}
}
}
return
false
;
}
class
PointInRectChecker
:
public
mozilla
:
:
RectCallback
{
public
:
explicit
PointInRectChecker
(
const
nsPoint
&
aPoint
)
:
mPoint
(
aPoint
)
mMatchFound
(
false
)
{
}
void
AddRect
(
const
nsRect
&
aRect
)
override
{
mMatchFound
=
mMatchFound
|
|
aRect
.
Contains
(
mPoint
)
;
}
bool
MatchFound
(
)
{
return
mMatchFound
;
}
private
:
nsPoint
mPoint
;
bool
mMatchFound
;
}
;
bool
Selection
:
:
ContainsPoint
(
const
nsPoint
&
aPoint
)
{
if
(
IsCollapsed
(
)
)
{
return
false
;
}
PointInRectChecker
checker
(
aPoint
)
;
for
(
uint32_t
i
=
0
;
i
<
RangeCount
(
)
;
i
+
+
)
{
nsRange
*
range
=
GetRangeAt
(
i
)
;
nsRange
:
:
CollectClientRectsAndText
(
&
checker
nullptr
range
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
true
false
)
;
if
(
checker
.
MatchFound
(
)
)
{
return
true
;
}
}
return
false
;
}
void
Selection
:
:
MaybeNotifyAccessibleCaretEventHub
(
PresShell
*
aPresShell
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mAccessibleCaretEventHub
&
&
aPresShell
)
{
mAccessibleCaretEventHub
=
aPresShell
-
>
GetAccessibleCaretEventHub
(
)
;
}
}
void
Selection
:
:
StopNotifyingAccessibleCaretEventHub
(
)
{
MOZ_ASSERT
(
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
mAccessibleCaretEventHub
=
nullptr
;
}
nsPresContext
*
Selection
:
:
GetPresContext
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
}
PresShell
*
Selection
:
:
GetPresShell
(
)
const
{
if
(
!
mFrameSelection
)
{
return
nullptr
;
}
return
mFrameSelection
-
>
GetPresShell
(
)
;
}
Document
*
Selection
:
:
GetDocument
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetDocument
(
)
:
nullptr
;
}
nsIFrame
*
Selection
:
:
GetSelectionAnchorGeometry
(
SelectionRegion
aRegion
nsRect
*
aRect
)
{
if
(
!
mFrameSelection
)
return
nullptr
;
NS_ENSURE_TRUE
(
aRect
nullptr
)
;
aRect
-
>
SetRect
(
0
0
0
0
)
;
switch
(
aRegion
)
{
case
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
:
case
nsISelectionController
:
:
SELECTION_FOCUS_REGION
:
return
GetSelectionEndPointGeometry
(
aRegion
aRect
)
;
case
nsISelectionController
:
:
SELECTION_WHOLE_SELECTION
:
break
;
default
:
return
nullptr
;
}
NS_ASSERTION
(
aRegion
=
=
nsISelectionController
:
:
SELECTION_WHOLE_SELECTION
"
should
only
be
SELECTION_WHOLE_SELECTION
here
"
)
;
nsRect
anchorRect
;
nsIFrame
*
anchorFrame
=
GetSelectionEndPointGeometry
(
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
&
anchorRect
)
;
if
(
!
anchorFrame
)
return
nullptr
;
nsRect
focusRect
;
nsIFrame
*
focusFrame
=
GetSelectionEndPointGeometry
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
&
focusRect
)
;
if
(
!
focusFrame
)
return
nullptr
;
NS_ASSERTION
(
anchorFrame
-
>
PresContext
(
)
=
=
focusFrame
-
>
PresContext
(
)
"
points
of
selection
in
different
documents
?
"
)
;
focusRect
+
=
focusFrame
-
>
GetOffsetTo
(
anchorFrame
)
;
*
aRect
=
anchorRect
.
UnionEdges
(
focusRect
)
;
return
anchorFrame
;
}
nsIFrame
*
Selection
:
:
GetSelectionEndPointGeometry
(
SelectionRegion
aRegion
nsRect
*
aRect
)
{
if
(
!
mFrameSelection
)
return
nullptr
;
NS_ENSURE_TRUE
(
aRect
nullptr
)
;
aRect
-
>
SetRect
(
0
0
0
0
)
;
nsINode
*
node
=
nullptr
;
uint32_t
nodeOffset
=
0
;
nsIFrame
*
frame
=
nullptr
;
switch
(
aRegion
)
{
case
nsISelectionController
:
:
SELECTION_ANCHOR_REGION
:
node
=
GetAnchorNode
(
)
;
nodeOffset
=
AnchorOffset
(
)
;
break
;
case
nsISelectionController
:
:
SELECTION_FOCUS_REGION
:
node
=
GetFocusNode
(
)
;
nodeOffset
=
FocusOffset
(
)
;
break
;
default
:
return
nullptr
;
}
if
(
!
node
)
return
nullptr
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
NS_ENSURE_TRUE
(
content
.
get
(
)
nullptr
)
;
int32_t
frameOffset
=
0
;
frame
=
nsFrameSelection
:
:
GetFrameForNodeOffset
(
content
nodeOffset
mFrameSelection
-
>
GetHint
(
)
&
frameOffset
)
;
if
(
!
frame
)
return
nullptr
;
nsFrameSelection
:
:
AdjustFrameForLineStart
(
frame
frameOffset
)
;
bool
isText
=
node
-
>
IsText
(
)
;
nsPoint
pt
(
0
0
)
;
if
(
isText
)
{
nsIFrame
*
childFrame
=
nullptr
;
frameOffset
=
0
;
nsresult
rv
=
frame
-
>
GetChildFrameContainingOffset
(
nodeOffset
mFrameSelection
-
>
GetHint
(
)
&
frameOffset
&
childFrame
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
if
(
!
childFrame
)
return
nullptr
;
frame
=
childFrame
;
rv
=
GetCachedFrameOffset
(
frame
nodeOffset
pt
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
}
if
(
isText
)
{
aRect
-
>
x
=
pt
.
x
;
}
else
if
(
mFrameSelection
-
>
GetHint
(
)
=
=
CARET_ASSOCIATE_BEFORE
)
{
aRect
-
>
x
=
frame
-
>
GetRect
(
)
.
Width
(
)
;
}
aRect
-
>
SetHeight
(
frame
-
>
GetRect
(
)
.
Height
(
)
)
;
return
frame
;
}
NS_IMETHODIMP
Selection
:
:
ScrollSelectionIntoViewEvent
:
:
Run
(
)
{
if
(
!
mSelection
)
return
NS_OK
;
int32_t
flags
=
Selection
:
:
SCROLL_DO_FLUSH
|
Selection
:
:
SCROLL_SYNCHRONOUS
;
const
RefPtr
<
Selection
>
selection
{
mSelection
}
;
selection
-
>
mScrollEvent
.
Forget
(
)
;
selection
-
>
ScrollIntoView
(
mRegion
mVerticalScroll
mHorizontalScroll
mFlags
|
flags
)
;
return
NS_OK
;
}
nsresult
Selection
:
:
PostScrollSelectionIntoViewEvent
(
SelectionRegion
aRegion
int32_t
aFlags
ScrollAxis
aVertical
ScrollAxis
aHorizontal
)
{
mScrollEvent
.
Revoke
(
)
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
NS_ENSURE_STATE
(
presContext
)
;
nsRefreshDriver
*
refreshDriver
=
presContext
-
>
RefreshDriver
(
)
;
NS_ENSURE_STATE
(
refreshDriver
)
;
mScrollEvent
=
new
ScrollSelectionIntoViewEvent
(
this
aRegion
aVertical
aHorizontal
aFlags
)
;
refreshDriver
-
>
AddEarlyRunner
(
mScrollEvent
.
get
(
)
)
;
return
NS_OK
;
}
void
Selection
:
:
ScrollIntoView
(
int16_t
aRegion
bool
aIsSynchronous
WhereToScroll
aVPercent
WhereToScroll
aHPercent
ErrorResult
&
aRv
)
{
int32_t
flags
=
aIsSynchronous
?
Selection
:
:
SCROLL_SYNCHRONOUS
:
0
;
nsresult
rv
=
ScrollIntoView
(
aRegion
ScrollAxis
(
aVPercent
)
ScrollAxis
(
aHPercent
)
flags
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
nsresult
Selection
:
:
ScrollIntoView
(
SelectionRegion
aRegion
ScrollAxis
aVertical
ScrollAxis
aHorizontal
int32_t
aFlags
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
PresShell
>
presShell
=
mFrameSelection
-
>
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
presShell
-
>
GetDocument
(
)
)
{
return
NS_OK
;
}
if
(
mFrameSelection
-
>
IsBatching
(
)
)
{
return
NS_OK
;
}
if
(
!
(
aFlags
&
Selection
:
:
SCROLL_SYNCHRONOUS
)
)
return
PostScrollSelectionIntoViewEvent
(
aRegion
aFlags
aVertical
aHorizontal
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
presShell
)
;
if
(
aFlags
&
Selection
:
:
SCROLL_DO_FLUSH
)
{
presShell
-
>
GetDocument
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
presShell
=
mFrameSelection
?
mFrameSelection
-
>
GetPresShell
(
)
:
nullptr
;
if
(
!
presShell
)
{
return
NS_OK
;
}
}
nsRect
rect
;
nsIFrame
*
frame
=
GetSelectionAnchorGeometry
(
aRegion
&
rect
)
;
if
(
!
frame
)
return
NS_ERROR_FAILURE
;
aVertical
.
mOnlyIfPerceivedScrollableDirection
=
true
;
auto
scrollFlags
=
ScrollFlags
:
:
None
;
if
(
aFlags
&
Selection
:
:
SCROLL_FIRST_ANCESTOR_ONLY
)
{
scrollFlags
|
=
ScrollFlags
:
:
ScrollFirstAncestorOnly
;
}
if
(
aFlags
&
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
)
{
scrollFlags
|
=
ScrollFlags
:
:
ScrollOverflowHidden
;
}
presShell
-
>
ScrollFrameRectIntoView
(
frame
rect
nsMargin
(
)
aVertical
aHorizontal
scrollFlags
)
;
return
NS_OK
;
}
void
Selection
:
:
AddSelectionListener
(
nsISelectionListener
*
aNewListener
)
{
MOZ_ASSERT
(
aNewListener
)
;
mSelectionListeners
.
AppendElement
(
aNewListener
)
;
}
void
Selection
:
:
RemoveSelectionListener
(
nsISelectionListener
*
aListenerToRemove
)
{
mSelectionListeners
.
RemoveElement
(
aListenerToRemove
)
;
}
Element
*
Selection
:
:
StyledRanges
:
:
GetCommonEditingHost
(
)
const
{
Element
*
editingHost
=
nullptr
;
for
(
const
StyledRange
&
rangeData
:
mRanges
)
{
const
nsRange
*
range
=
rangeData
.
mRange
;
MOZ_ASSERT
(
range
)
;
nsINode
*
commonAncestorNode
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
commonAncestorNode
|
|
!
commonAncestorNode
-
>
IsContent
(
)
)
{
return
nullptr
;
}
nsIContent
*
commonAncestor
=
commonAncestorNode
-
>
AsContent
(
)
;
Element
*
foundEditingHost
=
commonAncestor
-
>
GetEditingHost
(
)
;
if
(
!
foundEditingHost
)
{
return
nullptr
;
}
if
(
!
editingHost
)
{
editingHost
=
foundEditingHost
;
continue
;
}
if
(
editingHost
=
=
foundEditingHost
)
{
continue
;
}
if
(
foundEditingHost
-
>
IsInclusiveDescendantOf
(
editingHost
)
)
{
continue
;
}
if
(
editingHost
-
>
IsInclusiveDescendantOf
(
foundEditingHost
)
)
{
editingHost
=
foundEditingHost
;
continue
;
}
return
nullptr
;
}
return
editingHost
;
}
void
Selection
:
:
StyledRanges
:
:
MaybeFocusCommonEditingHost
(
PresShell
*
aPresShell
)
const
{
if
(
!
aPresShell
)
{
return
;
}
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
Document
*
document
=
aPresShell
-
>
GetDocument
(
)
;
if
(
!
document
)
{
return
;
}
nsPIDOMWindowOuter
*
window
=
document
-
>
GetWindow
(
)
;
if
(
window
&
&
!
document
-
>
IsInDesignMode
(
)
&
&
nsContentUtils
:
:
GetHTMLEditor
(
presContext
)
)
{
RefPtr
<
Element
>
newEditingHost
=
GetCommonEditingHost
(
)
;
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsIContent
*
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
nsCOMPtr
<
Element
>
focusedElement
=
do_QueryInterface
(
focusedContent
)
;
if
(
newEditingHost
&
&
newEditingHost
!
=
focusedElement
)
{
MOZ_ASSERT
(
!
newEditingHost
-
>
IsInNativeAnonymousSubtree
(
)
)
;
fm
-
>
SetFocus
(
newEditingHost
nsIFocusManager
:
:
FLAG_NOSWITCHFRAME
|
nsIFocusManager
:
:
FLAG_NOSCROLL
)
;
}
}
}
void
Selection
:
:
NotifySelectionListeners
(
bool
aCalledByJS
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
aCalledByJS
;
NotifySelectionListeners
(
)
;
}
void
Selection
:
:
NotifySelectionListeners
(
)
{
if
(
!
mFrameSelection
)
{
return
;
}
MOZ_LOG
(
sSelectionLog
LogLevel
:
:
Debug
(
"
%
s
:
selection
=
%
p
"
__FUNCTION__
this
)
)
;
AutoRestore
<
bool
>
calledByJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
false
;
if
(
mSelectionType
=
=
SelectionType
:
:
eNormal
&
&
calledByJSRestorer
.
SavedValue
(
)
)
{
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
mStyledRanges
.
MaybeFocusCommonEditingHost
(
presShell
)
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
if
(
frameSelection
-
>
IsBatching
(
)
)
{
frameSelection
-
>
SetChangesDuringBatchingFlag
(
)
;
return
;
}
if
(
mSelectionListeners
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
Document
>
doc
;
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
doc
=
presShell
-
>
GetDocument
(
)
;
}
const
CopyableAutoTArray
<
nsCOMPtr
<
nsISelectionListener
>
5
>
selectionListeners
=
mSelectionListeners
;
int16_t
reason
=
frameSelection
-
>
PopChangeReasons
(
)
;
if
(
calledByJSRestorer
.
SavedValue
(
)
)
{
reason
|
=
nsISelectionListener
:
:
JS_REASON
;
}
if
(
mNotifyAutoCopy
)
{
AutoCopyListener
:
:
OnSelectionChange
(
doc
*
this
reason
)
;
}
if
(
mAccessibleCaretEventHub
)
{
RefPtr
<
AccessibleCaretEventHub
>
hub
(
mAccessibleCaretEventHub
)
;
hub
-
>
OnSelectionChange
(
doc
this
reason
)
;
}
if
(
mSelectionChangeEventDispatcher
)
{
RefPtr
<
SelectionChangeEventDispatcher
>
dispatcher
(
mSelectionChangeEventDispatcher
)
;
dispatcher
-
>
OnSelectionChange
(
doc
this
reason
)
;
}
for
(
const
auto
&
listener
:
selectionListeners
)
{
MOZ_KnownLive
(
listener
)
-
>
NotifySelectionChanged
(
doc
this
reason
)
;
}
}
void
Selection
:
:
StartBatchChanges
(
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
StartBatchChanges
(
)
;
}
}
void
Selection
:
:
EndBatchChanges
(
int16_t
aReason
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
frameSelection
-
>
EndBatchChanges
(
aReason
)
;
}
}
void
Selection
:
:
AddSelectionChangeBlocker
(
)
{
mSelectionChangeBlockerCount
+
+
;
}
void
Selection
:
:
RemoveSelectionChangeBlocker
(
)
{
MOZ_ASSERT
(
mSelectionChangeBlockerCount
>
0
"
mSelectionChangeBlockerCount
has
an
invalid
value
-
"
"
maybe
you
have
a
mismatched
RemoveSelectionChangeBlocker
?
"
)
;
mSelectionChangeBlockerCount
-
-
;
}
bool
Selection
:
:
IsBlockingSelectionChangeEvents
(
)
const
{
return
mSelectionChangeBlockerCount
>
0
;
}
void
Selection
:
:
DeleteFromDocument
(
ErrorResult
&
aRv
)
{
if
(
mSelectionType
!
=
SelectionType
:
:
eNormal
)
{
return
;
}
if
(
IsCollapsed
(
)
)
{
return
;
}
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
RangeCount
(
)
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
GetRangeAt
(
rangeIdx
)
;
range
-
>
DeleteContents
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
AnchorOffset
(
)
>
0
)
{
RefPtr
<
nsINode
>
anchor
=
GetAnchorNode
(
)
;
CollapseInLimiter
(
anchor
AnchorOffset
(
)
)
;
}
#
ifdef
DEBUG
else
{
printf
(
"
Don
'
t
know
how
to
set
selection
back
past
frame
boundary
\
n
"
)
;
}
#
endif
}
void
Selection
:
:
Modify
(
const
nsAString
&
aAlter
const
nsAString
&
aDirection
const
nsAString
&
aGranularity
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
!
GetAnchorFocusRange
(
)
|
|
!
GetFocusNode
(
)
)
{
return
;
}
if
(
!
aAlter
.
LowerCaseEqualsLiteral
(
"
move
"
)
&
&
!
aAlter
.
LowerCaseEqualsLiteral
(
"
extend
"
)
)
{
aRv
.
ThrowSyntaxError
(
R
"
(
The
first
argument
must
be
one
of
:
"
move
"
or
"
extend
"
)
"
)
;
return
;
}
if
(
!
aDirection
.
LowerCaseEqualsLiteral
(
"
forward
"
)
&
&
!
aDirection
.
LowerCaseEqualsLiteral
(
"
backward
"
)
&
&
!
aDirection
.
LowerCaseEqualsLiteral
(
"
left
"
)
&
&
!
aDirection
.
LowerCaseEqualsLiteral
(
"
right
"
)
)
{
aRv
.
ThrowSyntaxError
(
R
"
(
The
direction
argument
must
be
one
of
:
"
forward
"
"
backward
"
"
left
"
or
"
right
"
)
"
)
;
return
;
}
if
(
RefPtr
<
Document
>
doc
=
GetDocument
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
bool
visual
=
aDirection
.
LowerCaseEqualsLiteral
(
"
left
"
)
|
|
aDirection
.
LowerCaseEqualsLiteral
(
"
right
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
line
"
)
;
bool
forward
=
aDirection
.
LowerCaseEqualsLiteral
(
"
forward
"
)
|
|
aDirection
.
LowerCaseEqualsLiteral
(
"
right
"
)
;
bool
extend
=
aAlter
.
LowerCaseEqualsLiteral
(
"
extend
"
)
;
nsSelectionAmount
amount
;
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
character
"
)
)
{
amount
=
eSelectCluster
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
word
"
)
)
{
amount
=
eSelectWordNoSpace
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
line
"
)
)
{
amount
=
eSelectLine
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
lineboundary
"
)
)
{
amount
=
forward
?
eSelectEndLine
:
eSelectBeginLine
;
}
else
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
sentence
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
sentenceboundary
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
paragraph
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
paragraphboundary
"
)
|
|
aGranularity
.
LowerCaseEqualsLiteral
(
"
documentboundary
"
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
;
}
else
{
aRv
.
ThrowSyntaxError
(
R
"
(
The
granularity
argument
must
be
one
of
:
"
character
"
"
word
"
"
line
"
or
"
lineboundary
"
)
"
)
;
return
;
}
nsresult
rv
=
NS_OK
;
if
(
!
extend
)
{
RefPtr
<
nsINode
>
focusNode
=
GetFocusNode
(
)
;
if
(
!
focusNode
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
uint32_t
focusOffset
=
FocusOffset
(
)
;
CollapseInLimiter
(
focusNode
focusOffset
)
;
}
if
(
nsIFrame
*
frame
=
GetPrimaryFrameForFocusNode
(
visual
)
)
{
mozilla
:
:
intl
:
:
BidiDirection
paraDir
=
nsBidiPresUtils
:
:
ParagraphDirection
(
frame
)
;
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
RTL
&
&
visual
)
{
if
(
amount
=
=
eSelectBeginLine
)
{
amount
=
eSelectEndLine
;
forward
=
!
forward
;
}
else
if
(
amount
=
=
eSelectEndLine
)
{
amount
=
eSelectBeginLine
;
forward
=
!
forward
;
}
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
rv
=
frameSelection
-
>
MoveCaret
(
forward
?
eDirNext
:
eDirPrevious
extend
amount
visual
?
nsFrameSelection
:
:
eVisual
:
nsFrameSelection
:
:
eLogical
)
;
if
(
aGranularity
.
LowerCaseEqualsLiteral
(
"
line
"
)
&
&
NS_FAILED
(
rv
)
)
{
RefPtr
<
PresShell
>
presShell
=
frameSelection
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
presShell
-
>
CompleteMove
(
forward
extend
)
;
}
}
void
Selection
:
:
SetBaseAndExtentJS
(
nsINode
&
aAnchorNode
uint32_t
aAnchorOffset
nsINode
&
aFocusNode
uint32_t
aFocusOffset
ErrorResult
&
aRv
)
{
AutoRestore
<
bool
>
calledFromJSRestorer
(
mCalledByJS
)
;
mCalledByJS
=
true
;
SetBaseAndExtent
(
aAnchorNode
aAnchorOffset
aFocusNode
aFocusOffset
aRv
)
;
}
void
Selection
:
:
SetBaseAndExtent
(
nsINode
&
aAnchorNode
uint32_t
aAnchorOffset
nsINode
&
aFocusNode
uint32_t
aFocusOffset
ErrorResult
&
aRv
)
{
if
(
aAnchorOffset
>
aAnchorNode
.
Length
(
)
)
{
aRv
.
ThrowIndexSizeError
(
nsPrintfCString
(
"
The
anchor
offset
value
%
u
is
out
of
range
"
aAnchorOffset
)
)
;
return
;
}
if
(
aFocusOffset
>
aFocusNode
.
Length
(
)
)
{
aRv
.
ThrowIndexSizeError
(
nsPrintfCString
(
"
The
focus
offset
value
%
u
is
out
of
range
"
aFocusOffset
)
)
;
return
;
}
SetBaseAndExtent
(
RawRangeBoundary
{
&
aAnchorNode
aAnchorOffset
}
RawRangeBoundary
{
&
aFocusNode
aFocusOffset
}
aRv
)
;
}
void
Selection
:
:
SetBaseAndExtentInternal
(
InLimiter
aInLimiter
const
RawRangeBoundary
&
aAnchorRef
const
RawRangeBoundary
&
aFocusRef
ErrorResult
&
aRv
)
{
if
(
!
mFrameSelection
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
if
(
NS_WARN_IF
(
!
aAnchorRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aFocusRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
if
(
!
HasSameRootOrSameComposedDoc
(
*
aAnchorRef
.
Container
(
)
)
|
|
!
HasSameRootOrSameComposedDoc
(
*
aFocusRef
.
Container
(
)
)
)
{
return
;
}
SelectionBatcher
batch
(
this
)
;
const
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints
(
aAnchorRef
aFocusRef
)
;
if
(
order
&
&
(
*
order
<
=
0
)
)
{
SetStartAndEndInternal
(
aInLimiter
aAnchorRef
aFocusRef
eDirNext
aRv
)
;
return
;
}
SetStartAndEndInternal
(
aInLimiter
aFocusRef
aAnchorRef
eDirPrevious
aRv
)
;
}
Result
<
Ok
nsresult
>
Selection
:
:
SetStartAndEndInLimiter
(
nsINode
&
aStartContainer
uint32_t
aStartOffset
nsINode
&
aEndContainer
uint32_t
aEndOffset
nsDirection
aDirection
int16_t
aReason
)
{
if
(
mFrameSelection
)
{
mFrameSelection
-
>
AddChangeReasons
(
aReason
)
;
}
ErrorResult
error
;
SetStartAndEndInternal
(
InLimiter
:
:
eYes
RawRangeBoundary
(
&
aStartContainer
aStartOffset
)
RawRangeBoundary
(
&
aEndContainer
aEndOffset
)
aDirection
error
)
;
MOZ_TRY
(
error
.
StealNSResult
(
)
)
;
return
Ok
(
)
;
}
void
Selection
:
:
SetStartAndEndInternal
(
InLimiter
aInLimiter
const
RawRangeBoundary
&
aStartRef
const
RawRangeBoundary
&
aEndRef
nsDirection
aDirection
ErrorResult
&
aRv
)
{
if
(
NS_WARN_IF
(
!
aStartRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndRef
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
SelectionBatcher
batch
(
this
)
;
if
(
aInLimiter
=
=
InLimiter
:
:
eYes
)
{
if
(
!
mFrameSelection
|
|
!
mFrameSelection
-
>
IsValidSelectionPoint
(
aStartRef
.
Container
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
aStartRef
.
Container
(
)
!
=
aEndRef
.
Container
(
)
&
&
!
mFrameSelection
-
>
IsValidSelectionPoint
(
aEndRef
.
Container
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
RefPtr
<
nsRange
>
newRange
=
nsRange
:
:
Create
(
aStartRef
aEndRef
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RemoveAllRanges
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
AddRangeAndSelectFramesAndNotifyListeners
(
*
newRange
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
mUserInitiated
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
if
(
mStyledRanges
.
Length
(
)
>
1
&
&
presContext
)
{
SelectFramesInAllRanges
(
presContext
)
;
}
}
SetDirection
(
aDirection
)
;
}
nsresult
Selection
:
:
SelectionLanguageChange
(
bool
aLangRTL
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
kbdBidiLevel
=
aLangRTL
?
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
RTL
(
)
:
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
LTR
(
)
;
if
(
kbdBidiLevel
=
=
frameSelection
-
>
mKbdBidiLevel
)
{
return
NS_OK
;
}
frameSelection
-
>
mKbdBidiLevel
=
kbdBidiLevel
;
nsIFrame
*
focusFrame
=
GetPrimaryFrameForFocusNode
(
false
)
;
if
(
!
focusFrame
)
{
return
NS_ERROR_FAILURE
;
}
auto
[
frameStart
frameEnd
]
=
focusFrame
-
>
GetOffsets
(
)
;
RefPtr
<
nsPresContext
>
context
=
GetPresContext
(
)
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
levelBefore
levelAfter
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
level
=
focusFrame
-
>
GetEmbeddingLevel
(
)
;
int32_t
focusOffset
=
static_cast
<
int32_t
>
(
FocusOffset
(
)
)
;
if
(
(
focusOffset
!
=
frameStart
)
&
&
(
focusOffset
!
=
frameEnd
)
)
levelBefore
=
levelAfter
=
level
;
else
{
nsCOMPtr
<
nsIContent
>
focusContent
=
do_QueryInterface
(
GetFocusNode
(
)
)
;
nsPrevNextBidiLevels
levels
=
frameSelection
-
>
GetPrevNextBidiLevels
(
focusContent
focusOffset
false
)
;
levelBefore
=
levels
.
mLevelBefore
;
levelAfter
=
levels
.
mLevelAfter
;
}
if
(
levelBefore
.
IsSameDirection
(
levelAfter
)
)
{
if
(
(
level
!
=
levelBefore
)
&
&
(
level
!
=
levelAfter
)
)
{
level
=
std
:
:
min
(
levelBefore
levelAfter
)
;
}
if
(
level
.
IsSameDirection
(
kbdBidiLevel
)
)
{
frameSelection
-
>
SetCaretBidiLevelAndMaybeSchedulePaint
(
level
)
;
}
else
{
frameSelection
-
>
SetCaretBidiLevelAndMaybeSchedulePaint
(
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
(
level
+
1
)
)
;
}
}
else
{
if
(
levelBefore
.
IsSameDirection
(
kbdBidiLevel
)
)
{
frameSelection
-
>
SetCaretBidiLevelAndMaybeSchedulePaint
(
levelBefore
)
;
}
else
{
frameSelection
-
>
SetCaretBidiLevelAndMaybeSchedulePaint
(
levelAfter
)
;
}
}
frameSelection
-
>
InvalidateDesiredCaretPos
(
)
;
return
NS_OK
;
}
void
Selection
:
:
SetColors
(
const
nsAString
&
aForegroundColor
const
nsAString
&
aBackgroundColor
const
nsAString
&
aAltForegroundColor
const
nsAString
&
aAltBackgroundColor
ErrorResult
&
aRv
)
{
if
(
mSelectionType
!
=
SelectionType
:
:
eFind
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
mCustomColors
.
reset
(
new
SelectionCustomColors
)
;
constexpr
auto
currentColorStr
=
u
"
currentColor
"
_ns
;
constexpr
auto
transparentStr
=
u
"
transparent
"
_ns
;
if
(
!
aForegroundColor
.
Equals
(
currentColorStr
)
)
{
nscolor
foregroundColor
;
nsAttrValue
aForegroundColorValue
;
aForegroundColorValue
.
ParseColor
(
aForegroundColor
)
;
if
(
!
aForegroundColorValue
.
GetColorValue
(
foregroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mForegroundColor
=
Some
(
foregroundColor
)
;
}
else
{
mCustomColors
-
>
mForegroundColor
=
Nothing
(
)
;
}
if
(
!
aBackgroundColor
.
Equals
(
transparentStr
)
)
{
nscolor
backgroundColor
;
nsAttrValue
aBackgroundColorValue
;
aBackgroundColorValue
.
ParseColor
(
aBackgroundColor
)
;
if
(
!
aBackgroundColorValue
.
GetColorValue
(
backgroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mBackgroundColor
=
Some
(
backgroundColor
)
;
}
else
{
mCustomColors
-
>
mBackgroundColor
=
Nothing
(
)
;
}
if
(
!
aAltForegroundColor
.
Equals
(
currentColorStr
)
)
{
nscolor
altForegroundColor
;
nsAttrValue
aAltForegroundColorValue
;
aAltForegroundColorValue
.
ParseColor
(
aAltForegroundColor
)
;
if
(
!
aAltForegroundColorValue
.
GetColorValue
(
altForegroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mAltForegroundColor
=
Some
(
altForegroundColor
)
;
}
else
{
mCustomColors
-
>
mAltForegroundColor
=
Nothing
(
)
;
}
if
(
!
aAltBackgroundColor
.
Equals
(
transparentStr
)
)
{
nscolor
altBackgroundColor
;
nsAttrValue
aAltBackgroundColorValue
;
aAltBackgroundColorValue
.
ParseColor
(
aAltBackgroundColor
)
;
if
(
!
aAltBackgroundColorValue
.
GetColorValue
(
altBackgroundColor
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
mCustomColors
-
>
mAltBackgroundColor
=
Some
(
altBackgroundColor
)
;
}
else
{
mCustomColors
-
>
mAltBackgroundColor
=
Nothing
(
)
;
}
}
void
Selection
:
:
ResetColors
(
ErrorResult
&
aRv
)
{
mCustomColors
=
nullptr
;
}
JSObject
*
Selection
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
mozilla
:
:
dom
:
:
Selection_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
AutoHideSelectionChanges
:
:
AutoHideSelectionChanges
(
const
nsFrameSelection
*
aFrame
)
:
AutoHideSelectionChanges
(
aFrame
?
aFrame
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
:
nullptr
)
{
}
bool
Selection
:
:
HasSameRootOrSameComposedDoc
(
const
nsINode
&
aNode
)
{
nsINode
*
root
=
aNode
.
SubtreeRoot
(
)
;
Document
*
doc
=
GetDocument
(
)
;
return
doc
=
=
root
|
|
(
root
&
&
doc
=
=
root
-
>
GetComposedDoc
(
)
)
;
}
