#
ifndef
nsIContentInlines_h
#
define
nsIContentInlines_h
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
inline
bool
nsINode
:
:
IsUAWidget
(
)
const
{
auto
*
shadow
=
mozilla
:
:
dom
:
:
ShadowRoot
:
:
FromNode
(
this
)
;
return
shadow
&
&
shadow
-
>
IsUAWidget
(
)
;
}
inline
bool
nsINode
:
:
IsInUAWidget
(
)
const
{
if
(
!
IsInShadowTree
(
)
)
{
return
false
;
}
mozilla
:
:
dom
:
:
ShadowRoot
*
shadow
=
AsContent
(
)
-
>
GetContainingShadow
(
)
;
return
shadow
&
&
shadow
-
>
IsUAWidget
(
)
;
}
inline
bool
nsINode
:
:
IsRootOfChromeAccessOnlySubtree
(
)
const
{
return
IsRootOfNativeAnonymousSubtree
(
)
|
|
IsUAWidget
(
)
;
}
inline
bool
nsIContent
:
:
IsInHTMLDocument
(
)
const
{
return
OwnerDoc
(
)
-
>
IsHTMLDocument
(
)
;
}
inline
bool
nsIContent
:
:
IsInChromeDocument
(
)
const
{
return
nsContentUtils
:
:
IsChromeDoc
(
OwnerDoc
(
)
)
;
}
inline
void
nsIContent
:
:
SetPrimaryFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsInUncomposedDoc
(
)
|
|
IsInShadowTree
(
)
"
This
will
end
badly
!
"
)
;
NS_ASSERTION
(
!
aFrame
|
|
!
mPrimaryFrame
|
|
aFrame
=
=
mPrimaryFrame
"
Losing
track
of
existing
primary
frame
"
)
;
if
(
aFrame
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsPlaceholderFrame
(
)
)
;
if
(
MOZ_LIKELY
(
!
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
|
|
aFrame
-
>
GetContent
(
)
=
=
this
)
{
aFrame
-
>
SetIsPrimaryFrame
(
true
)
;
}
}
else
if
(
nsIFrame
*
currentPrimaryFrame
=
GetPrimaryFrame
(
)
)
{
if
(
MOZ_LIKELY
(
!
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
|
|
currentPrimaryFrame
-
>
GetContent
(
)
=
=
this
)
{
currentPrimaryFrame
-
>
SetIsPrimaryFrame
(
false
)
;
}
}
mPrimaryFrame
=
aFrame
;
}
inline
mozilla
:
:
dom
:
:
ShadowRoot
*
nsIContent
:
:
GetShadowRoot
(
)
const
{
if
(
!
IsElement
(
)
)
{
return
nullptr
;
}
return
AsElement
(
)
-
>
GetShadowRoot
(
)
;
}
template
<
nsINode
:
:
FlattenedParentType
aType
>
static
inline
nsINode
*
GetFlattenedTreeParentNode
(
const
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsContent
(
)
)
{
return
nullptr
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsContent
(
)
)
{
return
parent
;
}
const
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
nsIContent
*
parentAsContent
=
parent
-
>
AsContent
(
)
;
if
(
aType
=
=
nsINode
:
:
eForStyle
&
&
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
&
&
parentAsContent
=
=
content
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
)
{
const
bool
docLevel
=
content
-
>
GetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
)
;
return
docLevel
?
content
-
>
OwnerDocAsNode
(
)
:
parent
;
}
if
(
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
parent
;
}
if
(
parentAsContent
-
>
GetShadowRoot
(
)
)
{
return
content
-
>
GetAssignedSlot
(
)
;
}
if
(
parentAsContent
-
>
IsInShadowTree
(
)
)
{
if
(
auto
*
slot
=
mozilla
:
:
dom
:
:
HTMLSlotElement
:
:
FromNode
(
parentAsContent
)
)
{
return
slot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
?
parent
:
nullptr
;
}
if
(
auto
*
shadowRoot
=
mozilla
:
:
dom
:
:
ShadowRoot
:
:
FromNode
(
parentAsContent
)
)
{
return
shadowRoot
-
>
GetHost
(
)
;
}
}
return
parent
;
}
inline
nsINode
*
nsINode
:
:
GetFlattenedTreeParentNode
(
)
const
{
return
:
:
GetFlattenedTreeParentNode
<
nsINode
:
:
eNotForStyle
>
(
this
)
;
}
inline
nsIContent
*
nsIContent
:
:
GetFlattenedTreeParent
(
)
const
{
nsINode
*
parent
=
GetFlattenedTreeParentNode
(
)
;
return
(
parent
&
&
parent
-
>
IsContent
(
)
)
?
parent
-
>
AsContent
(
)
:
nullptr
;
}
inline
bool
nsIContent
:
:
IsEventAttributeName
(
nsAtom
*
aName
)
{
const
char16_t
*
name
=
aName
-
>
GetUTF16String
(
)
;
if
(
name
[
0
]
!
=
'
o
'
|
|
name
[
1
]
!
=
'
n
'
)
{
return
false
;
}
return
IsEventAttributeNameInternal
(
aName
)
;
}
inline
nsINode
*
nsINode
:
:
GetFlattenedTreeParentNodeForStyle
(
)
const
{
return
:
:
GetFlattenedTreeParentNode
<
nsINode
:
:
eForStyle
>
(
this
)
;
}
inline
bool
nsINode
:
:
NodeOrAncestorHasDirAuto
(
)
const
{
return
AncestorHasDirAuto
(
)
|
|
(
IsElement
(
)
&
&
AsElement
(
)
-
>
HasDirAuto
(
)
)
;
}
inline
bool
nsINode
:
:
IsEditable
(
)
const
{
if
(
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
if
(
IsInNativeAnonymousSubtree
(
)
)
{
return
false
;
}
return
IsInDesignMode
(
)
;
}
inline
bool
nsINode
:
:
IsInDesignMode
(
)
const
{
if
(
!
OwnerDoc
(
)
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
false
;
}
if
(
IsDocument
(
)
)
{
return
HasFlag
(
NODE_IS_EDITABLE
)
;
}
if
(
IsInUncomposedDoc
(
)
&
&
GetUncomposedDoc
(
)
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
if
(
IsInUAWidget
(
)
)
{
nsIContent
*
host
=
GetContainingShadowHost
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
host
!
=
this
)
;
return
host
&
&
host
-
>
IsInDesignMode
(
)
;
}
MOZ_ASSERT
(
!
IsUAWidget
(
)
)
;
if
(
IsInNativeAnonymousSubtree
(
)
)
{
nsIContent
*
host
=
GetClosestNativeAnonymousSubtreeRootParent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
host
!
=
this
)
;
return
host
&
&
host
-
>
IsInDesignMode
(
)
;
}
return
false
;
}
inline
void
nsIContent
:
:
HandleInsertionToOrRemovalFromSlot
(
)
{
using
mozilla
:
:
dom
:
:
HTMLSlotElement
;
MOZ_ASSERT
(
GetParentElement
(
)
)
;
if
(
!
IsInShadowTree
(
)
|
|
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
;
}
HTMLSlotElement
*
slot
=
HTMLSlotElement
:
:
FromNode
(
mParent
)
;
if
(
!
slot
)
{
return
;
}
if
(
slot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
slot
-
>
EnqueueSlotChangeEvent
(
)
;
}
}
inline
void
nsIContent
:
:
HandleShadowDOMRelatedInsertionSteps
(
bool
aHadParent
)
{
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
ShadowRoot
;
if
(
!
aHadParent
)
{
if
(
Element
*
parentElement
=
Element
:
:
FromNode
(
mParent
)
)
{
if
(
ShadowRoot
*
shadow
=
parentElement
-
>
GetShadowRoot
(
)
)
{
shadow
-
>
MaybeSlotHostChild
(
*
this
)
;
}
HandleInsertionToOrRemovalFromSlot
(
)
;
}
}
}
inline
void
nsIContent
:
:
HandleShadowDOMRelatedRemovalSteps
(
bool
aNullParent
)
{
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
ShadowRoot
;
if
(
aNullParent
)
{
if
(
Element
*
parentElement
=
Element
:
:
FromNodeOrNull
(
mParent
)
)
{
if
(
ShadowRoot
*
shadow
=
parentElement
-
>
GetShadowRoot
(
)
)
{
shadow
-
>
MaybeUnslotHostChild
(
*
this
)
;
}
HandleInsertionToOrRemovalFromSlot
(
)
;
}
}
}
#
endif
