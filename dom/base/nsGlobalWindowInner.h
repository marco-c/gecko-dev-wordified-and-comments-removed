#
ifndef
nsGlobalWindowInner_h___
#
define
nsGlobalWindowInner_h___
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
prclist
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ChromeMessageBroadcaster
.
h
"
#
include
"
mozilla
/
dom
/
DebuggerNotificationManager
.
h
"
#
include
"
mozilla
/
dom
/
GamepadHandle
.
h
"
#
include
"
mozilla
/
dom
/
Location
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
CallState
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowProxyHolder
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsCheapSets
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapSource
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsIArray
;
class
nsIBaseWindow
;
class
nsIContent
;
class
nsICSSDeclaration
;
class
nsIDocShellTreeOwner
;
class
nsIDOMWindowUtils
;
class
nsIScrollableFrame
;
class
nsIControllers
;
class
nsIScriptContext
;
class
nsIScriptTimeoutHandler
;
class
nsIBrowserChild
;
class
nsIPrintSettings
;
class
nsITimeoutHandler
;
class
nsIWebBrowserChrome
;
class
nsIWebProgressListener
;
class
mozIDOMWindowProxy
;
class
nsScreen
;
class
nsHistory
;
class
nsGlobalWindowObserver
;
class
nsGlobalWindowOuter
;
class
nsDOMWindowUtils
;
class
nsIUserIdleService
;
struct
nsRect
;
class
nsWindowSizes
;
class
IdleRequestExecutor
;
class
DialogValueHolder
;
class
PromiseDocumentFlushedResolver
;
namespace
mozilla
{
class
AbstractThread
;
class
ErrorResult
;
namespace
glean
{
class
Glean
;
class
GleanPings
;
}
namespace
hal
{
enum
class
ScreenOrientation
:
uint32_t
;
}
namespace
dom
{
class
BarProp
;
class
BrowsingContext
;
struct
ChannelPixelLayout
;
class
ClientSource
;
class
Console
;
class
Crypto
;
class
CustomElementRegistry
;
class
DocGroup
;
class
External
;
class
Function
;
class
Gamepad
;
class
ContentMediaController
;
enum
class
ImageBitmapFormat
:
uint8_t
;
class
IdleRequest
;
class
IdleRequestCallback
;
class
IncrementalRunnable
;
class
InstallTriggerImpl
;
class
IntlUtils
;
class
MediaQueryList
;
class
OwningExternalOrWindowProxy
;
class
Promise
;
class
PostMessageEvent
;
struct
RequestInit
;
class
RequestOrUSVString
;
class
SharedWorker
;
class
Selection
;
struct
SizeToContentConstraints
;
class
WebTaskScheduler
;
class
WebTaskSchedulerMainThread
;
class
SpeechSynthesis
;
class
Timeout
;
class
VisualViewport
;
class
VRDisplay
;
enum
class
VRDisplayEventReason
:
uint8_t
;
class
VREventObserver
;
struct
WindowPostMessageOptions
;
class
Worklet
;
namespace
cache
{
class
CacheStorage
;
}
class
IDBFactory
;
}
}
extern
already_AddRefed
<
nsIScriptTimeoutHandler
>
NS_CreateJSTimeoutHandler
(
JSContext
*
aCx
nsGlobalWindowInner
*
aWindow
mozilla
:
:
dom
:
:
Function
&
aFunction
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
extern
already_AddRefed
<
nsIScriptTimeoutHandler
>
NS_CreateJSTimeoutHandler
(
JSContext
*
aCx
nsGlobalWindowInner
*
aWindow
const
nsAString
&
aExpression
mozilla
:
:
ErrorResult
&
aError
)
;
extern
const
JSClass
OuterWindowProxyClass
;
class
nsGlobalWindowInner
final
:
public
mozilla
:
:
dom
:
:
EventTarget
public
nsPIDOMWindowInner
private
nsIDOMWindow
public
nsIScriptGlobalObject
public
nsIScriptObjectPrincipal
public
nsSupportsWeakReference
public
nsIInterfaceRequestor
public
PRCListStr
{
public
:
using
RemoteProxy
=
mozilla
:
:
dom
:
:
BrowsingContext
;
using
TimeStamp
=
mozilla
:
:
TimeStamp
;
using
TimeDuration
=
mozilla
:
:
TimeDuration
;
using
InnerWindowByIdTable
=
nsTHashMap
<
nsUint64HashKey
nsGlobalWindowInner
*
>
;
static
void
AssertIsOnMainThread
(
)
#
ifdef
DEBUG
;
#
else
{
}
#
endif
bool
IsInnerWindow
(
)
const
final
{
return
true
;
}
static
nsGlobalWindowInner
*
Cast
(
nsPIDOMWindowInner
*
aPIWin
)
{
return
static_cast
<
nsGlobalWindowInner
*
>
(
aPIWin
)
;
}
static
const
nsGlobalWindowInner
*
Cast
(
const
nsPIDOMWindowInner
*
aPIWin
)
{
return
static_cast
<
const
nsGlobalWindowInner
*
>
(
aPIWin
)
;
}
static
nsGlobalWindowInner
*
Cast
(
mozIDOMWindow
*
aWin
)
{
return
Cast
(
nsPIDOMWindowInner
:
:
From
(
aWin
)
)
;
}
static
nsGlobalWindowInner
*
GetInnerWindowWithId
(
uint64_t
aInnerWindowID
)
{
AssertIsOnMainThread
(
)
;
if
(
!
sInnerWindowsById
)
{
return
nullptr
;
}
nsGlobalWindowInner
*
innerWindow
=
sInnerWindowsById
-
>
Get
(
aInnerWindowID
)
;
return
innerWindow
;
}
static
InnerWindowByIdTable
*
GetWindowsTable
(
)
{
AssertIsOnMainThread
(
)
;
return
sInnerWindowsById
;
}
static
nsGlobalWindowInner
*
FromSupports
(
nsISupports
*
supports
)
{
return
(
nsGlobalWindowInner
*
)
(
mozilla
:
:
dom
:
:
EventTarget
*
)
supports
;
}
static
already_AddRefed
<
nsGlobalWindowInner
>
Create
(
nsGlobalWindowOuter
*
aOuter
bool
aIsChrome
mozilla
:
:
dom
:
:
WindowGlobalChild
*
aActor
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
GetWrapper
(
)
;
}
bool
ShouldResistFingerprinting
(
RFPTarget
aTarget
)
const
final
;
mozilla
:
:
OriginTrials
Trials
(
)
const
final
;
mozilla
:
:
dom
:
:
FontFaceSet
*
GetFonts
(
)
final
;
JSObject
*
GetGlobalJSObject
(
)
final
{
return
GetWrapper
(
)
;
}
JSObject
*
GetGlobalJSObjectPreserveColor
(
)
const
final
{
return
GetWrapperPreserveColor
(
)
;
}
bool
HasJSGlobal
(
)
const
{
return
GetGlobalJSObjectPreserveColor
(
)
;
}
mozilla
:
:
Result
<
mozilla
:
:
ipc
:
:
PrincipalInfo
nsresult
>
GetStorageKey
(
)
override
;
mozilla
:
:
dom
:
:
StorageManager
*
GetStorageManager
(
)
override
;
bool
IsEligibleForMessaging
(
)
override
;
void
TraceGlobalJSObject
(
JSTracer
*
aTrc
)
;
virtual
nsresult
EnsureScriptEnvironment
(
)
override
;
virtual
nsIScriptContext
*
GetScriptContext
(
)
override
;
virtual
bool
IsBlackForCC
(
bool
aTracingNeeded
=
true
)
override
;
virtual
nsIPrincipal
*
GetPrincipal
(
)
override
;
virtual
nsIPrincipal
*
GetEffectiveCookiePrincipal
(
)
override
;
virtual
nsIPrincipal
*
GetEffectiveStoragePrincipal
(
)
override
;
virtual
nsIPrincipal
*
PartitionedPrincipal
(
)
override
;
NS_DECL_NSIDOMWINDOW
void
CaptureEvents
(
)
;
void
ReleaseEvents
(
)
;
void
Dump
(
const
nsAString
&
aStr
)
;
void
SetResizable
(
bool
aResizable
)
const
;
virtual
mozilla
:
:
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
EventCallbackDebuggerNotificationType
>
GetDebuggerNotificationType
(
)
const
override
;
bool
ComputeDefaultWantsUntrusted
(
mozilla
:
:
ErrorResult
&
aRv
)
final
;
virtual
nsPIDOMWindowOuter
*
GetOwnerGlobalForBindingsInternal
(
)
override
;
virtual
nsIGlobalObject
*
GetOwnerGlobal
(
)
const
override
;
EventTarget
*
GetTargetForDOMEvent
(
)
override
;
using
mozilla
:
:
dom
:
:
EventTarget
:
:
DispatchEvent
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
DispatchEvent
(
mozilla
:
:
dom
:
:
Event
&
aEvent
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
override
;
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PostHandleEvent
(
mozilla
:
:
EventChainPostVisitor
&
aVisitor
)
override
;
void
Suspend
(
bool
aIncludeSubWindows
=
true
)
;
void
Resume
(
bool
aIncludeSubWindows
=
true
)
;
virtual
bool
IsSuspended
(
)
const
override
;
void
Freeze
(
bool
aIncludeSubWindows
=
true
)
;
void
Thaw
(
bool
aIncludeSubWindows
=
true
)
;
virtual
bool
IsFrozen
(
)
const
override
;
void
SyncStateFromParentWindow
(
)
;
void
UpdateBackgroundState
(
)
;
mozilla
:
:
dom
:
:
DebuggerNotificationManager
*
GetOrCreateDebuggerNotificationManager
(
)
override
;
mozilla
:
:
dom
:
:
DebuggerNotificationManager
*
GetExistingDebuggerNotificationManager
(
)
override
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
GetClientInfo
(
)
const
override
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientState
>
GetClientState
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
GetController
(
)
const
override
;
void
SetCsp
(
nsIContentSecurityPolicy
*
aCsp
)
;
void
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCsp
)
;
nsIContentSecurityPolicy
*
GetCsp
(
)
;
virtual
RefPtr
<
mozilla
:
:
dom
:
:
ServiceWorker
>
GetOrCreateServiceWorker
(
const
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
&
aDescriptor
)
override
;
RefPtr
<
mozilla
:
:
dom
:
:
ServiceWorkerRegistration
>
GetServiceWorkerRegistration
(
const
mozilla
:
:
dom
:
:
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
const
override
;
RefPtr
<
mozilla
:
:
dom
:
:
ServiceWorkerRegistration
>
GetOrCreateServiceWorkerRegistration
(
const
mozilla
:
:
dom
:
:
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
override
;
mozilla
:
:
StorageAccess
GetStorageAccess
(
)
final
;
void
NoteCalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
;
void
NoteDOMContentLoaded
(
)
;
virtual
nsresult
FireDelayedDOMEvents
(
bool
aIncludeSubWindows
)
override
;
virtual
void
MaybeUpdateTouchState
(
)
override
;
void
RefreshRealmPrincipal
(
)
;
friend
class
FullscreenTransitionTask
;
virtual
void
SetHasGamepadEventListener
(
bool
aHasGamepad
=
true
)
override
;
void
NotifyHasXRSession
(
)
;
bool
HasUsedVR
(
)
const
;
bool
IsVRContentDetected
(
)
const
;
bool
IsVRContentPresenting
(
)
const
;
void
RequestXRPermission
(
)
;
void
OnXRPermissionRequestAllow
(
)
;
void
OnXRPermissionRequestCancel
(
)
;
using
EventTarget
:
:
EventListenerAdded
;
virtual
void
EventListenerAdded
(
nsAtom
*
aType
)
override
;
using
EventTarget
:
:
EventListenerRemoved
;
virtual
void
EventListenerRemoved
(
nsAtom
*
aType
)
override
;
NS_DECL_NSIINTERFACEREQUESTOR
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
IndexedGetter
(
uint32_t
aIndex
)
;
static
bool
IsPrivilegedChromeWindow
(
JSContext
*
JSObject
*
aObj
)
;
static
bool
IsRequestIdleCallbackEnabled
(
JSContext
*
aCx
JSObject
*
)
;
static
bool
DeviceSensorsEnabled
(
JSContext
*
JSObject
*
)
;
static
bool
CachesEnabled
(
JSContext
*
aCx
JSObject
*
)
;
static
bool
IsSizeToContentEnabled
(
JSContext
*
JSObject
*
)
;
bool
DoResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
mozilla
:
:
Maybe
<
JS
:
:
PropertyDescriptor
>
>
aDesc
)
;
static
bool
MayResolve
(
jsid
aId
)
;
void
GetOwnPropertyNames
(
JSContext
*
aCx
JS
:
:
MutableHandleVector
<
jsid
>
aNames
bool
aEnumerableOnly
mozilla
:
:
ErrorResult
&
aRv
)
;
nsPIDOMWindowOuter
*
GetInProcessScriptableTop
(
)
override
;
inline
nsGlobalWindowOuter
*
GetInProcessTopInternal
(
)
;
inline
nsGlobalWindowOuter
*
GetInProcessScriptableTopInternal
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
BrowsingContext
>
GetChildWindow
(
const
nsAString
&
aName
)
;
inline
nsIBrowserChild
*
GetBrowserChild
(
)
{
return
mBrowserChild
.
get
(
)
;
}
nsIScriptContext
*
GetContextInternal
(
)
;
nsGlobalWindowOuter
*
GetOuterWindowInternal
(
)
const
;
bool
IsChromeWindow
(
)
const
{
return
mIsChrome
;
}
nsIScrollableFrame
*
GetScrollFrame
(
)
;
nsresult
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
;
void
ObserveStorageNotification
(
mozilla
:
:
dom
:
:
StorageEvent
*
aEvent
const
char16_t
*
aStorageType
bool
aPrivateBrowsing
)
;
static
void
Init
(
)
;
static
void
ShutDown
(
)
;
static
bool
IsCallerChrome
(
)
;
friend
class
WindowStateHolder
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsGlobalWindowInner
mozilla
:
:
dom
:
:
EventTarget
)
#
ifdef
DEBUG
void
RiskyUnlink
(
)
;
#
endif
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
SetReadyForFocus
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
PageHidden
(
)
override
;
virtual
nsresult
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
override
;
virtual
nsresult
DispatchSyncPopState
(
)
override
;
virtual
void
EnableDeviceSensor
(
uint32_t
aType
)
override
;
virtual
void
DisableDeviceSensor
(
uint32_t
aType
)
override
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
virtual
void
EnableOrientationChangeListener
(
)
override
;
virtual
void
DisableOrientationChangeListener
(
)
override
;
#
endif
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
void
CollectDOMSizesForDataDocuments
(
nsWindowSizes
&
)
const
;
void
RegisterDataDocumentForMemoryReporting
(
Document
*
)
;
void
UnregisterDataDocumentForMemoryReporting
(
Document
*
)
;
enum
SlowScriptResponse
{
ContinueSlowScript
=
0
ContinueSlowScriptAndKeepNotifying
AlwaysContinueSlowScript
KillSlowScript
KillScriptGlobal
}
;
SlowScriptResponse
ShowSlowScriptDialog
(
JSContext
*
aCx
const
nsString
&
aAddonId
const
double
aDuration
)
;
void
AddGamepad
(
mozilla
:
:
dom
:
:
GamepadHandle
aHandle
mozilla
:
:
dom
:
:
Gamepad
*
aGamepad
)
;
void
RemoveGamepad
(
mozilla
:
:
dom
:
:
GamepadHandle
aHandle
)
;
void
GetGamepads
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Gamepad
>
>
&
aGamepads
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Gamepad
>
GetGamepad
(
mozilla
:
:
dom
:
:
GamepadHandle
aHandle
)
;
void
SetHasSeenGamepadInput
(
bool
aHasSeen
)
;
bool
HasSeenGamepadInput
(
)
;
void
SyncGamepadState
(
)
;
void
StopGamepadHaptics
(
)
;
void
EnableGamepadUpdates
(
)
;
void
DisableGamepadUpdates
(
)
;
void
EnableVRUpdates
(
)
;
void
DisableVRUpdates
(
)
;
void
ResetVRTelemetry
(
bool
aUpdate
)
;
void
StartVRActivity
(
)
;
void
StopVRActivity
(
)
;
bool
UpdateVRDisplays
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VRDisplay
>
>
&
aDisplays
)
;
void
NotifyActiveVRDisplaysChanged
(
)
;
void
NotifyDetectXRRuntimesCompleted
(
)
;
void
NotifyPresentationGenerationChanged
(
uint32_t
aDisplayID
)
;
void
DispatchVRDisplayActivate
(
uint32_t
aDisplayID
mozilla
:
:
dom
:
:
VRDisplayEventReason
aReason
)
;
void
DispatchVRDisplayDeactivate
(
uint32_t
aDisplayID
mozilla
:
:
dom
:
:
VRDisplayEventReason
aReason
)
;
void
DispatchVRDisplayConnect
(
uint32_t
aDisplayID
)
;
void
DispatchVRDisplayDisconnect
(
uint32_t
aDisplayID
)
;
void
DispatchVRDisplayPresentChange
(
uint32_t
aDisplayID
)
;
#
define
EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
handler
)
;
\
}
\
}
#
define
ERROR_EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
OnErrorEventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetOnErrorEventHandler
(
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
OnErrorEventHandlerNonNull
*
handler
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
handler
)
;
\
}
\
}
#
define
BEFOREUNLOAD_EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetOnBeforeUnloadEventHandler
(
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
\
mozilla
:
:
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
handler
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
handler
)
;
\
}
\
}
#
define
WINDOW_ONLY_EVENT
EVENT
#
define
TOUCH_EVENT
EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
TOUCH_EVENT
#
undef
WINDOW_ONLY_EVENT
#
undef
BEFOREUNLOAD_EVENT
#
undef
ERROR_EVENT
#
undef
EVENT
nsISupports
*
GetParentObject
(
)
{
return
nullptr
;
}
static
JSObject
*
CreateNamedPropertiesObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aProto
)
;
mozilla
:
:
dom
:
:
WindowProxyHolder
Window
(
)
;
mozilla
:
:
dom
:
:
WindowProxyHolder
Self
(
)
{
return
Window
(
)
;
}
Document
*
GetDocument
(
)
{
return
GetDoc
(
)
;
}
void
GetName
(
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetName
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Location
*
Location
(
)
override
;
nsHistory
*
GetHistory
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
CustomElementRegistry
*
CustomElements
(
)
override
;
mozilla
:
:
dom
:
:
CustomElementRegistry
*
GetExistingCustomElements
(
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetLocationbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetMenubar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetPersonalbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetScrollbars
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetStatusbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetToolbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetStatus
(
nsAString
&
aStatus
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetStatus
(
const
nsAString
&
aStatus
mozilla
:
:
ErrorResult
&
aError
)
;
void
Close
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
Close
(
)
override
;
bool
GetClosed
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Stop
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Focus
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
Focus
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
override
;
void
Blur
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
WindowProxyHolder
GetFrames
(
mozilla
:
:
ErrorResult
&
aError
)
;
uint32_t
Length
(
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetTop
(
mozilla
:
:
ErrorResult
&
aError
)
;
protected
:
explicit
nsGlobalWindowInner
(
nsGlobalWindowOuter
*
aOuterWindow
mozilla
:
:
dom
:
:
WindowGlobalChild
*
aActor
)
;
void
InitWasOffline
(
)
;
public
:
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetOpenerWindow
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOpener
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOpener
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetEvent
(
mozilla
:
:
dom
:
:
OwningEventOrUndefined
&
aRetval
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetParent
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsPIDOMWindowOuter
*
GetInProcessScriptableParent
(
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
int16_t
Orientation
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Console
>
GetConsole
(
JSContext
*
aCx
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
IsSecureContext
(
)
const
;
void
GetSidebar
(
mozilla
:
:
dom
:
:
OwningExternalOrWindowProxy
&
aResult
)
;
mozilla
:
:
dom
:
:
External
*
External
(
)
;
mozilla
:
:
dom
:
:
Worklet
*
GetPaintWorklet
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
GetRegionalPrefsLocales
(
nsTArray
<
nsString
>
&
aLocales
)
;
void
GetWebExposedLocales
(
nsTArray
<
nsString
>
&
aLocales
)
;
mozilla
:
:
dom
:
:
IntlUtils
*
GetIntlUtils
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
StoreSharedWorker
(
mozilla
:
:
dom
:
:
SharedWorker
*
aSharedWorker
)
;
void
ForgetSharedWorker
(
mozilla
:
:
dom
:
:
SharedWorker
*
aSharedWorker
)
;
public
:
void
Alert
(
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
Alert
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
bool
Confirm
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
Prompt
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
cache
:
:
CacheStorage
>
GetCaches
(
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Fetch
(
const
mozilla
:
:
dom
:
:
RequestOrUSVString
&
aInput
const
mozilla
:
:
dom
:
:
RequestInit
&
aInit
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
Print
(
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
PrintPreview
(
nsIPrintSettings
*
nsIWebProgressListener
*
nsIDocShell
*
mozilla
:
:
ErrorResult
&
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
mozilla
:
:
dom
:
:
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
mozilla
:
:
dom
:
:
WindowPostMessageOptions
&
aOptions
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
SetTimeout
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Function
&
aFunction
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
SetTimeout
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
ClearTimeout
(
int32_t
aHandle
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
SetInterval
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Function
&
aFunction
const
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
SetInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
const
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
ClearInterval
(
int32_t
aHandle
)
;
void
GetOrigin
(
nsAString
&
aOrigin
)
;
MOZ_CAN_RUN_SCRIPT
void
ReportError
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
;
void
Atob
(
const
nsAString
&
aAsciiBase64String
nsAString
&
aBinaryData
mozilla
:
:
ErrorResult
&
aError
)
;
void
Btoa
(
const
nsAString
&
aBinaryData
nsAString
&
aAsciiBase64String
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Storage
*
GetSessionStorage
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Storage
*
GetLocalStorage
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
IDBFactory
*
GetIndexedDB
(
JSContext
*
aCx
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
override
;
mozilla
:
:
dom
:
:
VisualViewport
*
VisualViewport
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
MediaQueryList
>
MatchMedia
(
const
nsACString
&
aQuery
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
nsScreen
*
GetScreen
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
MoveTo
(
int32_t
aXPos
int32_t
aYPos
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
MoveBy
(
int32_t
aXDif
int32_t
aYDif
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
ResizeTo
(
int32_t
aWidth
int32_t
aHeight
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
ResizeBy
(
int32_t
aWidthDif
int32_t
aHeightDif
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
Scroll
(
double
aXScroll
double
aYScroll
)
;
void
Scroll
(
const
mozilla
:
:
dom
:
:
ScrollToOptions
&
aOptions
)
;
void
ScrollTo
(
double
aXScroll
double
aYScroll
)
;
void
ScrollTo
(
const
mozilla
:
:
dom
:
:
ScrollToOptions
&
aOptions
)
;
void
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
;
void
ScrollBy
(
const
mozilla
:
:
dom
:
:
ScrollToOptions
&
aOptions
)
;
void
ScrollByLines
(
int32_t
numLines
const
mozilla
:
:
dom
:
:
ScrollOptions
&
aOptions
)
;
void
ScrollByPages
(
int32_t
numPages
const
mozilla
:
:
dom
:
:
ScrollOptions
&
aOptions
)
;
void
MozScrollSnap
(
)
;
double
GetScrollX
(
mozilla
:
:
ErrorResult
&
aError
)
;
double
GetPageXOffset
(
mozilla
:
:
ErrorResult
&
aError
)
{
return
GetScrollX
(
aError
)
;
}
double
GetScrollY
(
mozilla
:
:
ErrorResult
&
aError
)
;
double
GetPageYOffset
(
mozilla
:
:
ErrorResult
&
aError
)
{
return
GetScrollY
(
aError
)
;
}
int32_t
GetScreenLeft
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
{
return
GetScreenX
(
aCallerType
aError
)
;
}
double
ScreenEdgeSlopX
(
)
const
;
double
ScreenEdgeSlopY
(
)
const
;
int32_t
GetScreenTop
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
{
return
GetScreenY
(
aCallerType
aError
)
;
}
void
GetScreenX
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetScreenY
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetOuterWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetOuterHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
RequestAnimationFrame
(
mozilla
:
:
dom
:
:
FrameRequestCallback
&
aCallback
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
CancelAnimationFrame
(
int32_t
aHandle
mozilla
:
:
ErrorResult
&
aError
)
;
uint32_t
RequestIdleCallback
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
IdleRequestCallback
&
aCallback
const
mozilla
:
:
dom
:
:
IdleRequestOptions
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
void
CancelIdleCallback
(
uint32_t
aHandle
)
;
#
ifdef
MOZ_WEBSPEECH
mozilla
:
:
dom
:
:
SpeechSynthesis
*
GetSpeechSynthesis
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
HasActiveSpeechSynthesis
(
)
;
#
endif
mozilla
:
:
glean
:
:
Glean
*
Glean
(
)
;
mozilla
:
:
glean
:
:
GleanPings
*
GleanPings
(
)
;
already_AddRefed
<
nsICSSDeclaration
>
GetDefaultComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
;
void
SizeToContent
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
SizeToContentConstrained
(
const
mozilla
:
:
dom
:
:
SizeToContentConstraints
&
mozilla
:
:
ErrorResult
&
)
;
mozilla
:
:
dom
:
:
Crypto
*
GetCrypto
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIControllers
*
GetControllers
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetRealFrameElement
(
mozilla
:
:
ErrorResult
&
aError
)
;
float
GetMozInnerScreenX
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
float
GetMozInnerScreenY
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
double
GetDevicePixelRatio
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
double
GetDesktopToDeviceScale
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMinX
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMinY
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMaxX
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMaxY
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
GetFullScreen
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
GetFullScreen
(
)
override
;
void
SetFullScreen
(
bool
aFullscreen
mozilla
:
:
ErrorResult
&
aError
)
;
bool
Find
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
mozilla
:
:
ErrorResult
&
aError
)
;
bool
DidFireDocElemInserted
(
)
const
{
return
mDidFireDocElemInserted
;
}
void
SetDidFireDocElemInserted
(
)
{
mDidFireDocElemInserted
=
true
;
}
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
OpenDialog
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
mozilla
:
:
ErrorResult
&
aError
)
;
void
UpdateCommands
(
const
nsAString
&
anAction
mozilla
:
:
dom
:
:
Selection
*
aSel
int16_t
aReason
)
;
void
GetContent
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
CreateImageBitmap
(
const
mozilla
:
:
dom
:
:
ImageBitmapSource
&
aImage
const
mozilla
:
:
dom
:
:
ImageBitmapOptions
&
aOptions
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
CreateImageBitmap
(
const
mozilla
:
:
dom
:
:
ImageBitmapSource
&
aImage
int32_t
aSx
int32_t
aSy
int32_t
aSw
int32_t
aSh
const
mozilla
:
:
dom
:
:
ImageBitmapOptions
&
aOptions
mozilla
:
:
ErrorResult
&
aRv
)
;
void
StructuredClone
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
const
mozilla
:
:
dom
:
:
StructuredSerializeOptions
&
aOptions
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
uint16_t
WindowState
(
)
;
bool
IsFullyOccluded
(
)
;
nsIBrowserDOMWindow
*
GetBrowserDOMWindow
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
aBrowserWindow
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetAttention
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetAttentionWithCycleCount
(
int32_t
aCycleCount
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetCursor
(
const
nsACString
&
aCursor
mozilla
:
:
ErrorResult
&
aError
)
;
void
Maximize
(
)
;
void
Minimize
(
)
;
void
Restore
(
)
;
void
GetWorkspaceID
(
nsAString
&
workspaceID
)
;
void
MoveToWorkspace
(
const
nsAString
&
workspaceID
)
;
void
NotifyDefaultButtonLoaded
(
mozilla
:
:
dom
:
:
Element
&
aDefaultButton
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
*
MessageManager
(
)
;
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
*
GetGroupMessageManager
(
const
nsAString
&
aGroup
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
PromiseDocumentFlushed
(
mozilla
:
:
dom
:
:
PromiseDocumentFlushedCallback
&
aCallback
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetReturnValueOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetReturnValue
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReturnValueOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReturnValue
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetInterface
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsWindowRoot
>
GetWindowRoot
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
ShouldReportForServiceWorkerScope
(
const
nsAString
&
aScope
)
;
mozilla
:
:
dom
:
:
InstallTriggerImpl
*
GetInstallTrigger
(
)
;
nsIDOMWindowUtils
*
GetWindowUtils
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
UpdateTopInnerWindow
(
)
;
virtual
bool
IsInSyncOperation
(
)
override
;
bool
IsSharedMemoryAllowed
(
)
const
override
{
return
IsSharedMemoryAllowedInternal
(
const_cast
<
nsGlobalWindowInner
*
>
(
this
)
-
>
GetPrincipal
(
)
)
;
}
bool
IsSharedMemoryAllowedInternal
(
nsIPrincipal
*
aPrincipal
=
nullptr
)
const
;
bool
CrossOriginIsolated
(
)
const
override
;
mozilla
:
:
dom
:
:
WebTaskScheduler
*
Scheduler
(
)
;
protected
:
void
RedefineProperty
(
JSContext
*
aCx
const
char
*
aPropName
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetInnerWidth
(
double
*
aWidth
)
override
;
nsresult
GetInnerHeight
(
double
*
aHeight
)
override
;
public
:
double
GetInnerWidth
(
mozilla
:
:
ErrorResult
&
aError
)
;
double
GetInnerHeight
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenX
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenY
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterWidth
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterHeight
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
protected
:
friend
class
HashchangeCallback
;
friend
class
mozilla
:
:
dom
:
:
BarProp
;
virtual
~
nsGlobalWindowInner
(
)
;
void
FreeInnerObjects
(
)
;
void
InitDocumentDependentState
(
JSContext
*
aCx
)
;
nsresult
EnsureClientSource
(
)
;
nsresult
ExecutionReady
(
)
;
nsresult
DefineArgumentsProperty
(
nsIArray
*
aArguments
)
;
nsPIDOMWindowOuter
*
GetInProcessParentInternal
(
)
;
private
:
template
<
typename
Method
typename
.
.
.
Args
>
mozilla
:
:
CallState
CallOnInProcessDescendantsInternal
(
mozilla
:
:
dom
:
:
BrowsingContext
*
aBrowsingContext
bool
aChildOnly
Method
aMethod
Args
&
&
.
.
.
aArgs
)
;
template
<
typename
Method
typename
.
.
.
Args
>
mozilla
:
:
CallState
CallOnInProcessChildren
(
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
IsCurrentInnerWindow
(
)
)
;
return
CallOnInProcessDescendantsInternal
(
GetBrowsingContext
(
)
true
aMethod
aArgs
.
.
.
)
;
}
template
<
typename
Method
typename
.
.
.
Args
>
mozilla
:
:
CallState
CallOnInProcessDescendants
(
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
IsCurrentInnerWindow
(
)
)
;
return
CallOnInProcessDescendantsInternal
(
GetBrowsingContext
(
)
false
aMethod
aArgs
.
.
.
)
;
}
template
<
typename
Return
typename
Method
typename
.
.
.
Args
>
typename
std
:
:
enable_if
<
std
:
:
is_void
<
Return
>
:
:
value
mozilla
:
:
CallState
>
:
:
type
CallDescendant
(
nsGlobalWindowInner
*
aWindow
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
(
aWindow
-
>
*
aMethod
)
(
aArgs
.
.
.
)
;
return
mozilla
:
:
CallState
:
:
Continue
;
}
template
<
typename
Return
typename
Method
typename
.
.
.
Args
>
typename
std
:
:
enable_if
<
std
:
:
is_same
<
Return
mozilla
:
:
CallState
>
:
:
value
mozilla
:
:
CallState
>
:
:
type
CallDescendant
(
nsGlobalWindowInner
*
aWindow
Method
aMethod
Args
&
&
.
.
.
aArgs
)
{
return
(
aWindow
-
>
*
aMethod
)
(
aArgs
.
.
.
)
;
}
void
FreezeInternal
(
bool
aIncludeSubWindows
)
;
void
ThawInternal
(
bool
aIncludeSubWindows
)
;
mozilla
:
:
CallState
ShouldReportForServiceWorkerScopeInternal
(
const
nsACString
&
aScope
bool
*
aResultOut
)
;
public
:
MOZ_CAN_RUN_SCRIPT
int32_t
SetTimeoutOrInterval
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Function
&
aFunction
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
bool
aIsInterval
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
SetTimeoutOrInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
bool
aIsInterval
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
bool
RunTimeoutHandler
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
nsIScriptContext
*
aScx
)
;
already_AddRefed
<
nsIDocShellTreeOwner
>
GetTreeOwner
(
)
;
already_AddRefed
<
nsIWebBrowserChrome
>
GetWebBrowserChrome
(
)
;
bool
IsPrivateBrowsing
(
)
;
void
FireOfflineStatusEventIfChanged
(
)
;
public
:
nsresult
FireHashchange
(
const
nsAString
&
aOldURL
const
nsAString
&
aNewURL
)
;
void
FlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
;
void
ScrollTo
(
const
mozilla
:
:
CSSIntPoint
&
aScroll
const
mozilla
:
:
dom
:
:
ScrollOptions
&
aOptions
)
;
already_AddRefed
<
nsIWidget
>
GetMainWidget
(
)
;
nsIWidget
*
GetNearestWidget
(
)
const
;
bool
IsInModalState
(
)
;
void
SetFocusedElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
override
;
uint32_t
GetFocusMethod
(
)
override
;
bool
ShouldShowFocusRing
(
)
override
;
void
UpdateCanvasFocus
(
bool
aFocusChanged
nsIContent
*
aNewContent
)
;
public
:
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
override
;
nsIPrincipal
*
GetTopLevelAntiTrackingPrincipal
(
)
;
nsIPrincipal
*
GetClientPrincipal
(
)
;
void
StorageAccessPermissionGranted
(
)
;
protected
:
static
void
NotifyDOMWindowDestroyed
(
nsGlobalWindowInner
*
aWindow
)
;
void
NotifyWindowIDDestroyed
(
const
char
*
aTopic
)
;
static
void
NotifyDOMWindowFrozen
(
nsGlobalWindowInner
*
aWindow
)
;
static
void
NotifyDOMWindowThawed
(
nsGlobalWindowInner
*
aWindow
)
;
virtual
void
UpdateParentTarget
(
)
override
;
void
ClearDocumentDependentSlots
(
JSContext
*
aCx
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
StorageEvent
>
CloneStorageEvent
(
const
nsAString
&
aType
const
RefPtr
<
mozilla
:
:
dom
:
:
StorageEvent
>
&
aEvent
mozilla
:
:
ErrorResult
&
aRv
)
;
protected
:
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyleHelper
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
mozilla
:
:
ErrorResult
&
aError
)
;
nsGlobalWindowInner
*
InnerForSetTimeoutOrInterval
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
private
:
void
FireOnNewGlobalObject
(
)
;
bool
ResolveComponentsShim
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
MutableHandle
<
mozilla
:
:
Maybe
<
JS
:
:
PropertyDescriptor
>
>
aDesc
)
;
friend
class
nsPIDOMWindowInner
;
friend
class
nsPIDOMWindowOuter
;
bool
IsBackgroundInternal
(
)
const
;
void
DisconnectAndClearGroupMessageManagers
(
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
for
(
const
auto
&
entry
:
mChromeFields
.
mGroupMessageManagers
)
{
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
*
mm
=
entry
.
GetWeak
(
)
;
if
(
mm
)
{
mm
-
>
Disconnect
(
)
;
}
}
mChromeFields
.
mGroupMessageManagers
.
Clear
(
)
;
}
void
CallDocumentFlushedResolvers
(
bool
aUntilExhaustion
)
;
bool
MaybeCallDocumentFlushedResolvers
(
bool
aUntilExhaustion
)
;
MOZ_CAN_RUN_SCRIPT
void
FireFrameLoadEvent
(
)
;
void
UpdateAutoplayPermission
(
)
;
void
UpdateShortcutsPermission
(
)
;
void
UpdatePopupPermission
(
)
;
void
UpdatePermissions
(
)
;
public
:
static
uint32_t
GetShortcutsPermission
(
nsIPrincipal
*
aPrincipal
)
;
virtual
nsresult
Dispatch
(
mozilla
:
:
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
override
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
override
;
virtual
mozilla
:
:
AbstractThread
*
AbstractMainThreadFor
(
mozilla
:
:
TaskCategory
aCategory
)
override
;
void
DisableIdleCallbackRequests
(
)
;
uint32_t
LastIdleRequestHandle
(
)
const
{
return
mIdleRequestCallbackCounter
-
1
;
}
MOZ_CAN_RUN_SCRIPT
void
RunIdleRequest
(
mozilla
:
:
dom
:
:
IdleRequest
*
aRequest
DOMHighResTimeStamp
aDeadline
bool
aDidTimeout
)
;
MOZ_CAN_RUN_SCRIPT
void
ExecuteIdleRequest
(
TimeStamp
aDeadline
)
;
void
ScheduleIdleRequestDispatch
(
)
;
void
SuspendIdleRequests
(
)
;
void
ResumeIdleRequests
(
)
;
using
IdleRequests
=
mozilla
:
:
LinkedList
<
RefPtr
<
mozilla
:
:
dom
:
:
IdleRequest
>
>
;
void
RemoveIdleCallback
(
mozilla
:
:
dom
:
:
IdleRequest
*
aRequest
)
;
void
SetActiveLoadingState
(
bool
aIsLoading
)
override
;
void
HintIsLoading
(
bool
aIsLoading
)
;
mozilla
:
:
dom
:
:
ContentMediaController
*
GetContentMediaController
(
)
;
bool
TryOpenExternalProtocolIframe
(
)
{
if
(
mHasOpenedExternalProtocolFrame
)
{
return
false
;
}
mHasOpenedExternalProtocolFrame
=
true
;
return
true
;
}
nsTArray
<
uint32_t
>
&
GetScrollMarks
(
)
{
return
mScrollMarks
;
}
bool
GetScrollMarksOnHScrollbar
(
)
const
{
return
mScrollMarksOnHScrollbar
;
}
void
SetScrollMarks
(
const
nsTArray
<
uint32_t
>
&
aScrollMarks
bool
aOnHScrollbar
)
;
mozilla
:
:
Maybe
<
mozilla
:
:
StorageAccess
>
GetStorageAllowedCache
(
uint32_t
&
aRejectedReason
)
{
if
(
mStorageAllowedCache
.
isSome
(
)
)
{
aRejectedReason
=
mStorageAllowedReasonCache
;
}
return
mStorageAllowedCache
;
}
void
SetStorageAllowedCache
(
const
mozilla
:
:
StorageAccess
&
storageAllowed
uint32_t
aRejectedReason
)
{
mStorageAllowedCache
=
Some
(
storageAllowed
)
;
mStorageAllowedReasonCache
=
aRejectedReason
;
}
void
ClearStorageAllowedCache
(
)
{
mStorageAllowedCache
=
mozilla
:
:
Nothing
(
)
;
mStorageAllowedReasonCache
=
0
;
}
virtual
JS
:
:
loader
:
:
ModuleLoaderBase
*
GetModuleLoader
(
JSContext
*
aCx
)
override
;
private
:
RefPtr
<
mozilla
:
:
dom
:
:
ContentMediaController
>
mContentMediaController
;
RefPtr
<
mozilla
:
:
dom
:
:
WebTaskSchedulerMainThread
>
mWebTaskScheduler
;
protected
:
bool
mHasOrientationChangeListeners
:
1
;
bool
mWasOffline
:
1
;
bool
mHasHadSlowScript
:
1
;
bool
mIsChrome
:
1
;
bool
mCleanMessageManager
:
1
;
bool
mNeedsFocus
:
1
;
bool
mHasFocus
:
1
;
bool
mFocusByKeyOccurred
:
1
;
bool
mDidFireDocElemInserted
:
1
;
bool
mHasGamepad
:
1
;
bool
mHasXRSession
:
1
;
bool
mHasVRDisplayActivateEvents
:
1
;
bool
mXRRuntimeDetectionInFlight
:
1
;
bool
mXRPermissionRequestInFlight
:
1
;
bool
mXRPermissionGranted
:
1
;
bool
mWasCurrentInnerWindow
:
1
;
void
SetWasCurrentInnerWindow
(
)
{
mWasCurrentInnerWindow
=
true
;
}
bool
WasCurrentInnerWindow
(
)
const
override
{
return
mWasCurrentInnerWindow
;
}
bool
mHasSeenGamepadInput
:
1
;
bool
mHintedWasLoading
:
1
;
bool
mHasOpenedExternalProtocolFrame
:
1
;
bool
mScrollMarksOnHScrollbar
:
1
;
nsCheapSet
<
nsUint32HashKey
>
mGamepadIndexSet
;
nsRefPtrHashtable
<
nsGenericHashKey
<
mozilla
:
:
dom
:
:
GamepadHandle
>
mozilla
:
:
dom
:
:
Gamepad
>
mGamepads
;
RefPtr
<
nsScreen
>
mScreen
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mMenubar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mToolbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mLocationbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mPersonalbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mStatusbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mScrollbars
;
RefPtr
<
nsGlobalWindowObserver
>
mObserver
;
RefPtr
<
mozilla
:
:
dom
:
:
Crypto
>
mCrypto
;
RefPtr
<
mozilla
:
:
dom
:
:
cache
:
:
CacheStorage
>
mCacheStorage
;
RefPtr
<
mozilla
:
:
dom
:
:
Console
>
mConsole
;
RefPtr
<
mozilla
:
:
dom
:
:
Worklet
>
mPaintWorklet
;
RefPtr
<
mozilla
:
:
dom
:
:
External
>
mExternal
;
RefPtr
<
mozilla
:
:
dom
:
:
InstallTriggerImpl
>
mInstallTrigger
;
RefPtr
<
mozilla
:
:
dom
:
:
Storage
>
mLocalStorage
;
RefPtr
<
mozilla
:
:
dom
:
:
Storage
>
mSessionStorage
;
RefPtr
<
mozilla
:
:
EventListenerManager
>
mListenerManager
;
RefPtr
<
mozilla
:
:
dom
:
:
Location
>
mLocation
;
RefPtr
<
nsHistory
>
mHistory
;
RefPtr
<
mozilla
:
:
dom
:
:
CustomElementRegistry
>
mCustomElements
;
nsTObserverArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SharedWorker
>
>
mSharedWorkers
;
RefPtr
<
mozilla
:
:
dom
:
:
VisualViewport
>
mVisualViewport
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentCookiePrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentStoragePrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentPartitionedPrincipal
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
mDocumentCsp
;
mozilla
:
:
Maybe
<
mozilla
:
:
StorageAccess
>
mStorageAllowedCache
;
uint32_t
mStorageAllowedReasonCache
;
RefPtr
<
mozilla
:
:
dom
:
:
DebuggerNotificationManager
>
mDebuggerNotificationManager
;
nsCOMPtr
<
nsIBrowserChild
>
mBrowserChild
;
uint32_t
mSuspendDepth
;
uint32_t
mFreezeDepth
;
#
ifdef
DEBUG
uint32_t
mSerial
;
#
endif
uint32_t
mFocusMethod
;
int16_t
mOrientationAngle
=
0
;
uint32_t
mIdleRequestCallbackCounter
;
IdleRequests
mIdleRequestCallbacks
;
RefPtr
<
IdleRequestExecutor
>
mIdleRequestExecutor
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIURI
>
mLastOpenedURI
;
#
endif
RefPtr
<
mozilla
:
:
dom
:
:
IDBFactory
>
mIndexedDB
;
bool
mObservingRefresh
;
bool
mIteratingDocumentFlushedResolvers
;
bool
TryToObserveRefresh
(
)
;
nsTArray
<
uint32_t
>
mEnabledSensors
;
#
ifdef
MOZ_WEBSPEECH
RefPtr
<
mozilla
:
:
dom
:
:
SpeechSynthesis
>
mSpeechSynthesis
;
#
endif
RefPtr
<
mozilla
:
:
glean
:
:
Glean
>
mGlean
;
RefPtr
<
mozilla
:
:
glean
:
:
GleanPings
>
mGleanPings
;
uint32_t
mCanSkipCCGeneration
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VRDisplay
>
>
mVRDisplays
;
RefPtr
<
mozilla
:
:
dom
:
:
VREventObserver
>
mVREventObserver
;
uint64_t
mUnloadOrBeforeUnloadListenerCount
=
0
;
RefPtr
<
mozilla
:
:
dom
:
:
IntlUtils
>
mIntlUtils
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
ClientSource
>
mClientSource
;
nsTArray
<
mozilla
:
:
UniquePtr
<
PromiseDocumentFlushedResolver
>
>
mDocumentFlushedResolvers
;
nsTArray
<
uint32_t
>
mScrollMarks
;
nsTArray
<
nsWeakPtr
>
mDataDocumentsForMemoryReporting
;
static
InnerWindowByIdTable
*
sInnerWindowsById
;
struct
ChromeFields
{
RefPtr
<
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
>
mMessageManager
;
nsRefPtrHashtable
<
nsStringHashKey
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
>
mGroupMessageManagers
{
1
}
;
}
mChromeFields
;
static
bool
sMouseDown
;
static
bool
sDragServiceDisabled
;
friend
class
nsDOMScriptableHelper
;
friend
class
nsDOMWindowUtils
;
friend
class
mozilla
:
:
dom
:
:
PostMessageEvent
;
friend
class
DesktopNotification
;
friend
class
mozilla
:
:
dom
:
:
TimeoutManager
;
friend
class
IdleRequestExecutor
;
friend
class
nsGlobalWindowOuter
;
}
;
inline
nsISupports
*
ToSupports
(
nsGlobalWindowInner
*
p
)
{
return
static_cast
<
mozilla
:
:
dom
:
:
EventTarget
*
>
(
p
)
;
}
inline
nsISupports
*
ToCanonicalSupports
(
nsGlobalWindowInner
*
p
)
{
return
static_cast
<
mozilla
:
:
dom
:
:
EventTarget
*
>
(
p
)
;
}
#
include
"
nsGlobalWindowOuter
.
h
"
inline
nsIGlobalObject
*
nsGlobalWindowInner
:
:
GetOwnerGlobal
(
)
const
{
return
const_cast
<
nsGlobalWindowInner
*
>
(
this
)
;
}
inline
nsGlobalWindowOuter
*
nsGlobalWindowInner
:
:
GetInProcessTopInternal
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
outer
?
outer
-
>
GetInProcessTop
(
)
:
nullptr
;
if
(
top
)
{
return
nsGlobalWindowOuter
:
:
Cast
(
top
)
;
}
return
nullptr
;
}
inline
nsGlobalWindowOuter
*
nsGlobalWindowInner
:
:
GetInProcessScriptableTopInternal
(
)
{
nsPIDOMWindowOuter
*
top
=
GetInProcessScriptableTop
(
)
;
return
nsGlobalWindowOuter
:
:
Cast
(
top
)
;
}
inline
nsIScriptContext
*
nsGlobalWindowInner
:
:
GetContextInternal
(
)
{
if
(
mOuterWindow
)
{
return
GetOuterWindowInternal
(
)
-
>
mContext
;
}
return
nullptr
;
}
inline
nsGlobalWindowOuter
*
nsGlobalWindowInner
:
:
GetOuterWindowInternal
(
)
const
{
return
nsGlobalWindowOuter
:
:
Cast
(
GetOuterWindow
(
)
)
;
}
#
endif
