#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
ContentParent
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsFrameTraversal
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIXULWindow
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIObjectFrame
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
BrowserChild
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsNumberControlFrame
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozilla
/
AccessibleCaretEventHub
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
algorithm
>
#
ifdef
MOZ_XUL
#
include
"
nsIDOMXULMenuListElement
.
h
"
#
endif
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
ifndef
XP_MACOSX
#
include
"
nsIScriptError
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
widget
;
LazyLogModule
gFocusLog
(
"
Focus
"
)
;
LazyLogModule
gFocusNavigationLog
(
"
FocusNavigation
"
)
;
#
define
LOGFOCUS
(
args
)
MOZ_LOG
(
gFocusLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOGFOCUSNAVIGATION
(
args
)
\
MOZ_LOG
(
gFocusNavigationLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOGTAG
(
log
format
content
)
\
if
(
MOZ_LOG_TEST
(
log
LogLevel
:
:
Debug
)
)
{
\
nsAutoCString
tag
(
NS_LITERAL_CSTRING
(
"
(
none
)
"
)
)
;
\
if
(
content
)
{
\
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToUTF8String
(
tag
)
;
\
}
\
MOZ_LOG
(
log
LogLevel
:
:
Debug
(
format
tag
.
get
(
)
)
)
;
\
}
#
define
LOGCONTENT
(
format
content
)
LOGTAG
(
gFocusLog
format
content
)
#
define
LOGCONTENTNAVIGATION
(
format
content
)
\
LOGTAG
(
gFocusNavigationLog
format
content
)
struct
nsDelayedBlurOrFocusEvent
{
nsDelayedBlurOrFocusEvent
(
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
Document
*
aDocument
EventTarget
*
aTarget
EventTarget
*
aRelatedTarget
)
:
mPresShell
(
aPresShell
)
mDocument
(
aDocument
)
mTarget
(
aTarget
)
mEventMessage
(
aEventMessage
)
mRelatedTarget
(
aRelatedTarget
)
{
}
nsDelayedBlurOrFocusEvent
(
const
nsDelayedBlurOrFocusEvent
&
aOther
)
:
mPresShell
(
aOther
.
mPresShell
)
mDocument
(
aOther
.
mDocument
)
mTarget
(
aOther
.
mTarget
)
mEventMessage
(
aOther
.
mEventMessage
)
{
}
nsCOMPtr
<
nsIPresShell
>
mPresShell
;
nsCOMPtr
<
Document
>
mDocument
;
nsCOMPtr
<
EventTarget
>
mTarget
;
EventMessage
mEventMessage
;
nsCOMPtr
<
EventTarget
>
mRelatedTarget
;
}
;
inline
void
ImplCycleCollectionUnlink
(
nsDelayedBlurOrFocusEvent
&
aField
)
{
aField
.
mPresShell
=
nullptr
;
aField
.
mDocument
=
nullptr
;
aField
.
mTarget
=
nullptr
;
aField
.
mRelatedTarget
=
nullptr
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsDelayedBlurOrFocusEvent
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
CycleCollectionNoteChild
(
aCallback
aField
.
mPresShell
.
get
(
)
aName
aFlags
)
;
CycleCollectionNoteChild
(
aCallback
aField
.
mDocument
.
get
(
)
aName
aFlags
)
;
CycleCollectionNoteChild
(
aCallback
aField
.
mTarget
.
get
(
)
aName
aFlags
)
;
CycleCollectionNoteChild
(
aCallback
aField
.
mRelatedTarget
.
get
(
)
aName
aFlags
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsFocusManager
)
NS_INTERFACE_MAP_ENTRY
(
nsIFocusManager
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIFocusManager
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsFocusManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsFocusManager
)
NS_IMPL_CYCLE_COLLECTION
(
nsFocusManager
mActiveWindow
mFocusedWindow
mFocusedElement
mFirstBlurEvent
mFirstFocusEvent
mWindowBeingLowered
mDelayedBlurFocusEvents
mMouseButtonEventHandlingDocument
)
nsFocusManager
*
nsFocusManager
:
:
sInstance
=
nullptr
;
bool
nsFocusManager
:
:
sMouseFocusesFormControl
=
false
;
bool
nsFocusManager
:
:
sTestMode
=
false
;
static
const
char
*
kObservedPrefs
[
]
=
{
"
accessibility
.
browsewithcaret
"
"
accessibility
.
tabfocus_applies_to_xul
"
"
accessibility
.
mouse_focuses_formcontrol
"
"
focusmanager
.
testmode
"
nullptr
}
;
nsFocusManager
:
:
nsFocusManager
(
)
:
mEventHandlingNeedsFlush
(
false
)
{
}
nsFocusManager
:
:
~
nsFocusManager
(
)
{
Preferences
:
:
UnregisterCallbacks
(
PREF_CHANGE_METHOD
(
nsFocusManager
:
:
PrefChanged
)
kObservedPrefs
this
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
xpcom
-
shutdown
"
)
;
}
}
nsresult
nsFocusManager
:
:
Init
(
)
{
nsFocusManager
*
fm
=
new
nsFocusManager
(
)
;
NS_ADDREF
(
fm
)
;
sInstance
=
fm
;
nsIContent
:
:
sTabFocusModelAppliesToXUL
=
Preferences
:
:
GetBool
(
"
accessibility
.
tabfocus_applies_to_xul
"
nsIContent
:
:
sTabFocusModelAppliesToXUL
)
;
sMouseFocusesFormControl
=
Preferences
:
:
GetBool
(
"
accessibility
.
mouse_focuses_formcontrol
"
false
)
;
sTestMode
=
Preferences
:
:
GetBool
(
"
focusmanager
.
testmode
"
false
)
;
Preferences
:
:
RegisterCallbacks
(
PREF_CHANGE_METHOD
(
nsFocusManager
:
:
PrefChanged
)
kObservedPrefs
fm
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
fm
"
xpcom
-
shutdown
"
true
)
;
}
return
NS_OK
;
}
void
nsFocusManager
:
:
Shutdown
(
)
{
NS_IF_RELEASE
(
sInstance
)
;
}
void
nsFocusManager
:
:
PrefChanged
(
const
char
*
aPref
)
{
nsDependentCString
pref
(
aPref
)
;
if
(
pref
.
EqualsLiteral
(
"
accessibility
.
browsewithcaret
"
)
)
{
UpdateCaretForCaretBrowsingMode
(
)
;
}
else
if
(
pref
.
EqualsLiteral
(
"
accessibility
.
tabfocus_applies_to_xul
"
)
)
{
nsIContent
:
:
sTabFocusModelAppliesToXUL
=
Preferences
:
:
GetBool
(
"
accessibility
.
tabfocus_applies_to_xul
"
nsIContent
:
:
sTabFocusModelAppliesToXUL
)
;
}
else
if
(
pref
.
EqualsLiteral
(
"
accessibility
.
mouse_focuses_formcontrol
"
)
)
{
sMouseFocusesFormControl
=
Preferences
:
:
GetBool
(
"
accessibility
.
mouse_focuses_formcontrol
"
false
)
;
}
else
if
(
pref
.
EqualsLiteral
(
"
focusmanager
.
testmode
"
)
)
{
sTestMode
=
Preferences
:
:
GetBool
(
"
focusmanager
.
testmode
"
false
)
;
}
}
NS_IMETHODIMP
nsFocusManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
)
{
mActiveWindow
=
nullptr
;
mFocusedWindow
=
nullptr
;
mFocusedElement
=
nullptr
;
mFirstBlurEvent
=
nullptr
;
mFirstFocusEvent
=
nullptr
;
mWindowBeingLowered
=
nullptr
;
mDelayedBlurFocusEvents
.
Clear
(
)
;
mMouseButtonEventHandlingDocument
=
nullptr
;
}
return
NS_OK
;
}
static
nsPIDOMWindowOuter
*
GetContentWindow
(
nsIContent
*
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
Document
*
subdoc
=
doc
-
>
GetSubDocumentFor
(
aContent
)
;
if
(
subdoc
)
return
subdoc
-
>
GetWindow
(
)
;
}
return
nullptr
;
}
bool
nsFocusManager
:
:
IsFocused
(
nsIContent
*
aContent
)
{
if
(
!
aContent
|
|
!
mFocusedElement
)
{
return
false
;
}
return
aContent
=
=
mFocusedElement
;
}
bool
nsFocusManager
:
:
IsTestMode
(
)
{
return
sTestMode
;
}
static
nsPIDOMWindowOuter
*
GetCurrentWindow
(
nsIContent
*
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
return
doc
?
doc
-
>
GetWindow
(
)
:
nullptr
;
}
Element
*
nsFocusManager
:
:
GetFocusedDescendant
(
nsPIDOMWindowOuter
*
aWindow
SearchRange
aSearchRange
nsPIDOMWindowOuter
*
*
aFocusedWindow
)
{
NS_ENSURE_TRUE
(
aWindow
nullptr
)
;
*
aFocusedWindow
=
nullptr
;
Element
*
currentElement
=
nullptr
;
nsPIDOMWindowOuter
*
window
=
aWindow
;
for
(
;
;
)
{
*
aFocusedWindow
=
window
;
currentElement
=
window
-
>
GetFocusedElement
(
)
;
if
(
!
currentElement
|
|
aSearchRange
=
=
eOnlyCurrentWindow
)
{
break
;
}
window
=
GetContentWindow
(
currentElement
)
;
if
(
!
window
)
{
break
;
}
if
(
aSearchRange
=
=
eIncludeAllDescendants
)
{
continue
;
}
MOZ_ASSERT
(
aSearchRange
=
=
eIncludeVisibleDescendants
)
;
nsIDocShell
*
docShell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
break
;
}
if
(
!
docShell
-
>
GetPresShell
(
)
)
{
break
;
}
}
NS_IF_ADDREF
(
*
aFocusedWindow
)
;
return
currentElement
;
}
Element
*
nsFocusManager
:
:
GetRedirectedFocus
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
bool
typeIsNumber
=
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
aContent
)
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_NUMBER
;
if
(
typeIsNumber
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
aContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
HTMLInputElement
*
textControl
=
numberControlFrame
-
>
GetAnonTextControl
(
)
;
return
textControl
;
}
}
}
#
ifdef
MOZ_XUL
if
(
aContent
-
>
IsXULElement
(
)
)
{
if
(
aContent
-
>
IsXULElement
(
nsGkAtoms
:
:
textbox
)
)
{
return
aContent
-
>
OwnerDoc
(
)
-
>
GetAnonymousElementByAttribute
(
aContent
nsGkAtoms
:
:
anonid
NS_LITERAL_STRING
(
"
input
"
)
)
;
}
else
{
nsCOMPtr
<
nsIDOMXULMenuListElement
>
menulist
=
aContent
-
>
AsElement
(
)
-
>
AsXULMenuList
(
)
;
if
(
menulist
)
{
RefPtr
<
Element
>
inputField
;
menulist
-
>
GetInputField
(
getter_AddRefs
(
inputField
)
)
;
return
inputField
;
}
}
}
#
endif
return
nullptr
;
}
InputContextAction
:
:
Cause
nsFocusManager
:
:
GetFocusMoveActionCause
(
uint32_t
aFlags
)
{
if
(
aFlags
&
nsIFocusManager
:
:
FLAG_BYTOUCH
)
{
return
InputContextAction
:
:
CAUSE_TOUCH
;
}
else
if
(
aFlags
&
nsIFocusManager
:
:
FLAG_BYMOUSE
)
{
return
InputContextAction
:
:
CAUSE_MOUSE
;
}
else
if
(
aFlags
&
nsIFocusManager
:
:
FLAG_BYKEY
)
{
return
InputContextAction
:
:
CAUSE_KEY
;
}
return
InputContextAction
:
:
CAUSE_UNKNOWN
;
}
NS_IMETHODIMP
nsFocusManager
:
:
GetActiveWindow
(
mozIDOMWindowProxy
*
*
aWindow
)
{
NS_IF_ADDREF
(
*
aWindow
=
mActiveWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
SetActiveWindow
(
mozIDOMWindowProxy
*
aWindow
)
{
NS_ENSURE_STATE
(
aWindow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
NS_ENSURE_TRUE
(
piWindow
=
=
piWindow
-
>
GetPrivateRoot
(
)
NS_ERROR_INVALID_ARG
)
;
RaiseWindow
(
piWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
GetFocusedWindow
(
mozIDOMWindowProxy
*
*
aFocusedWindow
)
{
NS_IF_ADDREF
(
*
aFocusedWindow
=
mFocusedWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
SetFocusedWindow
(
mozIDOMWindowProxy
*
aWindowToFocus
)
{
LOGFOCUS
(
(
"
<
<
SetFocusedWindow
begin
>
>
"
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
windowToFocus
=
nsPIDOMWindowOuter
:
:
From
(
aWindowToFocus
)
;
NS_ENSURE_TRUE
(
windowToFocus
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
Element
>
frameElement
=
windowToFocus
-
>
GetFrameElementInternal
(
)
;
if
(
frameElement
)
{
SetFocusInner
(
frameElement
0
false
true
)
;
}
else
{
nsIContent
*
content
=
windowToFocus
-
>
GetFocusedElement
(
)
;
if
(
content
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
childWindow
=
GetContentWindow
(
content
)
)
ClearFocus
(
windowToFocus
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
windowToFocus
-
>
GetPrivateRoot
(
)
;
if
(
rootWindow
)
RaiseWindow
(
rootWindow
)
;
LOGFOCUS
(
(
"
<
<
SetFocusedWindow
end
>
>
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
GetFocusedElement
(
Element
*
*
aFocusedElement
)
{
RefPtr
<
Element
>
focusedElement
=
mFocusedElement
;
focusedElement
.
forget
(
aFocusedElement
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
GetLastFocusMethod
(
mozIDOMWindowProxy
*
aWindow
uint32_t
*
aLastFocusMethod
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
if
(
aWindow
)
{
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
}
if
(
!
window
)
window
=
mFocusedWindow
;
*
aLastFocusMethod
=
window
?
window
-
>
GetFocusMethod
(
)
:
0
;
NS_ASSERTION
(
(
*
aLastFocusMethod
&
FOCUSMETHOD_MASK
)
=
=
*
aLastFocusMethod
"
invalid
focus
method
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
SetFocus
(
Element
*
aElement
uint32_t
aFlags
)
{
LOGFOCUS
(
(
"
<
<
SetFocus
begin
>
>
"
)
)
;
NS_ENSURE_ARG
(
aElement
)
;
SetFocusInner
(
aElement
aFlags
true
true
)
;
LOGFOCUS
(
(
"
<
<
SetFocus
end
>
>
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
ElementIsFocusable
(
Element
*
aElement
uint32_t
aFlags
bool
*
aIsFocusable
)
{
NS_ENSURE_TRUE
(
aElement
NS_ERROR_INVALID_ARG
)
;
*
aIsFocusable
=
FlushAndCheckIfFocusable
(
aElement
aFlags
)
!
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
MoveFocus
(
mozIDOMWindowProxy
*
aWindow
Element
*
aStartElement
uint32_t
aType
uint32_t
aFlags
Element
*
*
aElement
)
{
*
aElement
=
nullptr
;
LOGFOCUS
(
(
"
<
<
MoveFocus
begin
Type
:
%
d
Flags
:
%
x
>
>
"
aType
aFlags
)
)
;
if
(
MOZ_LOG_TEST
(
gFocusLog
LogLevel
:
:
Debug
)
&
&
mFocusedWindow
)
{
Document
*
doc
=
mFocusedWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Focused
Window
:
%
p
%
s
"
mFocusedWindow
.
get
(
)
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
}
LOGCONTENT
(
"
Current
Focus
:
%
s
"
mFocusedElement
.
get
(
)
)
;
if
(
aType
!
=
MOVEFOCUS_ROOT
&
&
aType
!
=
MOVEFOCUS_CARET
&
&
(
aFlags
&
FOCUSMETHOD_MASK
)
=
=
0
)
{
aFlags
|
=
FLAG_BYMOVEFOCUS
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
if
(
aStartElement
)
{
window
=
GetCurrentWindow
(
aStartElement
)
;
}
else
{
window
=
aWindow
?
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
:
mFocusedWindow
.
get
(
)
;
}
NS_ENSURE_TRUE
(
window
NS_ERROR_FAILURE
)
;
bool
noParentTraversal
=
aFlags
&
FLAG_NOPARENTFRAME
;
nsCOMPtr
<
nsIContent
>
newFocus
;
nsresult
rv
=
DetermineElementToMoveFocus
(
window
aStartElement
aType
noParentTraversal
getter_AddRefs
(
newFocus
)
)
;
if
(
rv
=
=
NS_SUCCESS_DOM_NO_OPERATION
)
{
return
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOGCONTENTNAVIGATION
(
"
Element
to
be
focused
:
%
s
"
newFocus
.
get
(
)
)
;
if
(
newFocus
&
&
newFocus
-
>
IsElement
(
)
)
{
SetFocusInner
(
MOZ_KnownLive
(
newFocus
-
>
AsElement
(
)
)
aFlags
aType
!
=
MOVEFOCUS_CARET
true
)
;
*
aElement
=
do_AddRef
(
newFocus
-
>
AsElement
(
)
)
.
take
(
)
;
}
else
if
(
aType
=
=
MOVEFOCUS_ROOT
|
|
aType
=
=
MOVEFOCUS_CARET
)
{
ClearFocus
(
window
)
;
}
LOGFOCUS
(
(
"
<
<
MoveFocus
end
>
>
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
ClearFocus
(
mozIDOMWindowProxy
*
aWindow
)
{
LOGFOCUS
(
(
"
<
<
ClearFocus
begin
>
>
"
)
)
;
NS_ENSURE_TRUE
(
aWindow
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
if
(
IsSameOrAncestor
(
window
mFocusedWindow
)
)
{
bool
isAncestor
=
(
window
!
=
mFocusedWindow
)
;
if
(
Blur
(
window
nullptr
isAncestor
true
)
)
{
if
(
isAncestor
)
Focus
(
window
nullptr
0
true
false
false
true
)
;
}
}
else
{
window
-
>
SetFocusedElement
(
nullptr
)
;
}
LOGFOCUS
(
(
"
<
<
ClearFocus
end
>
>
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
GetFocusedElementForWindow
(
mozIDOMWindowProxy
*
aWindow
bool
aDeep
mozIDOMWindowProxy
*
*
aFocusedWindow
Element
*
*
aElement
)
{
*
aElement
=
nullptr
;
if
(
aFocusedWindow
)
*
aFocusedWindow
=
nullptr
;
NS_ENSURE_TRUE
(
aWindow
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
RefPtr
<
Element
>
focusedElement
=
GetFocusedDescendant
(
window
aDeep
?
nsFocusManager
:
:
eIncludeAllDescendants
:
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
focusedElement
.
forget
(
aElement
)
;
if
(
aFocusedWindow
)
NS_IF_ADDREF
(
*
aFocusedWindow
=
focusedWindow
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
MoveCaretToFocus
(
mozIDOMWindowProxy
*
aWindow
)
{
nsCOMPtr
<
nsIWebNavigation
>
webnav
=
do_GetInterface
(
aWindow
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
do_QueryInterface
(
webnav
)
;
if
(
dsti
)
{
if
(
dsti
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
dsti
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_FAILURE
)
;
bool
isEditable
;
docShell
-
>
GetEditable
(
&
isEditable
)
;
if
(
isEditable
)
return
NS_OK
;
RefPtr
<
PresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
nsCOMPtr
<
nsIContent
>
content
=
window
-
>
GetFocusedElement
(
)
;
if
(
content
)
{
MoveCaretToFocus
(
presShell
content
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
WindowRaised
(
mozIDOMWindowProxy
*
aWindow
)
{
NS_ENSURE_TRUE
(
aWindow
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
if
(
MOZ_LOG_TEST
(
gFocusLog
LogLevel
:
:
Debug
)
)
{
LOGFOCUS
(
(
"
Window
%
p
Raised
[
Currently
:
%
p
%
p
]
"
aWindow
mActiveWindow
.
get
(
)
mFocusedWindow
.
get
(
)
)
)
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Raised
Window
:
%
p
%
s
"
aWindow
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mActiveWindow
)
{
doc
=
mActiveWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Active
Window
:
%
p
%
s
"
mActiveWindow
.
get
(
)
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
}
}
if
(
mActiveWindow
=
=
window
)
{
EnsureCurrentWidgetFocused
(
)
;
return
NS_OK
;
}
if
(
mActiveWindow
)
WindowLowered
(
mActiveWindow
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellAsItem
=
window
-
>
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
docShellAsItem
NS_OK
)
;
mActiveWindow
=
window
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
docShellAsItem
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
treeOwner
)
;
if
(
baseWindow
)
{
bool
isEnabled
=
true
;
if
(
NS_SUCCEEDED
(
baseWindow
-
>
GetEnabled
(
&
isEnabled
)
)
&
&
!
isEnabled
)
{
return
NS_ERROR_FAILURE
;
}
baseWindow
-
>
SetVisibility
(
true
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
ActivateOrDeactivate
(
window
true
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
currentWindow
;
RefPtr
<
Element
>
currentFocus
=
GetFocusedDescendant
(
window
eIncludeAllDescendants
getter_AddRefs
(
currentWindow
)
)
;
NS_ASSERTION
(
currentWindow
"
window
raised
with
no
window
current
"
)
;
if
(
!
currentWindow
)
return
NS_OK
;
nsCOMPtr
<
nsIXULWindow
>
xulWin
(
do_GetInterface
(
baseWindow
)
)
;
Focus
(
currentWindow
currentFocus
0
true
false
xulWin
!
=
nullptr
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
WindowLowered
(
mozIDOMWindowProxy
*
aWindow
)
{
NS_ENSURE_TRUE
(
aWindow
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
if
(
MOZ_LOG_TEST
(
gFocusLog
LogLevel
:
:
Debug
)
)
{
LOGFOCUS
(
(
"
Window
%
p
Lowered
[
Currently
:
%
p
%
p
]
"
aWindow
mActiveWindow
.
get
(
)
mFocusedWindow
.
get
(
)
)
)
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Lowered
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mActiveWindow
)
{
doc
=
mActiveWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Active
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
}
}
if
(
mActiveWindow
!
=
window
)
return
NS_OK
;
PresShell
:
:
ReleaseCapturingContent
(
)
;
if
(
mFocusedWindow
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
mFocusedWindow
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
if
(
PresShell
*
presShell
=
docShell
-
>
GetPresShell
(
)
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
presShell
-
>
FrameSelection
(
)
;
frameSelection
-
>
SetDragState
(
false
)
;
}
}
}
if
(
XRE_IsParentProcess
(
)
)
{
ActivateOrDeactivate
(
window
false
)
;
}
mWindowBeingLowered
=
mActiveWindow
;
mActiveWindow
=
nullptr
;
if
(
mFocusedWindow
)
Blur
(
nullptr
nullptr
true
true
)
;
mWindowBeingLowered
=
nullptr
;
return
NS_OK
;
}
nsresult
nsFocusManager
:
:
ContentRemoved
(
Document
*
aDocument
nsIContent
*
aContent
)
{
NS_ENSURE_ARG
(
aDocument
)
;
NS_ENSURE_ARG
(
aContent
)
;
nsPIDOMWindowOuter
*
window
=
aDocument
-
>
GetWindow
(
)
;
if
(
!
window
)
return
NS_OK
;
nsIContent
*
content
=
window
-
>
GetFocusedElement
(
)
;
if
(
content
&
&
nsContentUtils
:
:
ContentIsHostIncludingDescendantOf
(
content
aContent
)
)
{
bool
shouldShowFocusRing
=
window
-
>
ShouldShowFocusRing
(
)
;
window
-
>
SetFocusedElement
(
nullptr
)
;
if
(
window
=
=
mFocusedWindow
)
{
mFocusedElement
=
nullptr
;
}
else
{
Document
*
subdoc
=
aDocument
-
>
GetSubDocumentFor
(
content
)
;
if
(
subdoc
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
subdoc
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
childWindow
=
docShell
-
>
GetWindow
(
)
;
if
(
childWindow
&
&
IsSameOrAncestor
(
childWindow
mFocusedWindow
)
)
{
ClearFocus
(
mActiveWindow
)
;
}
}
}
}
if
(
content
-
>
IsEditable
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
aDocument
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
docShell
-
>
GetHTMLEditor
(
)
;
if
(
htmlEditor
)
{
RefPtr
<
Selection
>
selection
=
htmlEditor
-
>
GetSelection
(
)
;
if
(
selection
&
&
selection
-
>
GetFrameSelection
(
)
&
&
content
=
=
selection
-
>
GetFrameSelection
(
)
-
>
GetAncestorLimiter
(
)
)
{
htmlEditor
-
>
FinalizeSelection
(
)
;
}
}
}
}
NotifyFocusStateChange
(
content
nullptr
shouldShowFocusRing
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
WindowShown
(
mozIDOMWindowProxy
*
aWindow
bool
aNeedsFocus
)
{
NS_ENSURE_TRUE
(
aWindow
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
if
(
MOZ_LOG_TEST
(
gFocusLog
LogLevel
:
:
Debug
)
)
{
LOGFOCUS
(
(
"
Window
%
p
Shown
[
Currently
:
%
p
%
p
]
"
window
.
get
(
)
mActiveWindow
.
get
(
)
mFocusedWindow
.
get
(
)
)
)
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Shown
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mFocusedWindow
)
{
doc
=
mFocusedWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Focused
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
}
}
if
(
nsIDocShell
*
docShell
=
window
-
>
GetDocShell
(
)
)
{
if
(
nsCOMPtr
<
nsIBrowserChild
>
child
=
docShell
-
>
GetBrowserChild
(
)
)
{
bool
active
=
static_cast
<
BrowserChild
*
>
(
child
.
get
(
)
)
-
>
ParentIsActive
(
)
;
ActivateOrDeactivate
(
window
active
)
;
}
}
if
(
mFocusedWindow
!
=
window
)
return
NS_OK
;
if
(
aNeedsFocus
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
currentWindow
;
RefPtr
<
Element
>
currentFocus
=
GetFocusedDescendant
(
window
eIncludeAllDescendants
getter_AddRefs
(
currentWindow
)
)
;
if
(
currentWindow
)
Focus
(
currentWindow
currentFocus
0
true
false
false
true
)
;
}
else
{
EnsureCurrentWidgetFocused
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
WindowHidden
(
mozIDOMWindowProxy
*
aWindow
)
{
NS_ENSURE_TRUE
(
aWindow
NS_ERROR_INVALID_ARG
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
if
(
MOZ_LOG_TEST
(
gFocusLog
LogLevel
:
:
Debug
)
)
{
LOGFOCUS
(
(
"
Window
%
p
Hidden
[
Currently
:
%
p
%
p
]
"
window
.
get
(
)
mActiveWindow
.
get
(
)
mFocusedWindow
.
get
(
)
)
)
;
nsAutoCString
spec
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Hide
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mFocusedWindow
)
{
doc
=
mFocusedWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Focused
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
}
if
(
mActiveWindow
)
{
doc
=
mActiveWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
GetDocumentURI
(
)
)
{
LOGFOCUS
(
(
"
Active
Window
:
%
s
"
doc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
}
}
if
(
!
IsSameOrAncestor
(
window
mFocusedWindow
)
)
return
NS_OK
;
RefPtr
<
Element
>
oldFocusedElement
=
mFocusedElement
.
forget
(
)
;
nsCOMPtr
<
nsIDocShell
>
focusedDocShell
=
mFocusedWindow
-
>
GetDocShell
(
)
;
RefPtr
<
PresShell
>
presShell
=
focusedDocShell
-
>
GetPresShell
(
)
;
if
(
oldFocusedElement
&
&
oldFocusedElement
-
>
IsInComposedDoc
(
)
)
{
NotifyFocusStateChange
(
oldFocusedElement
nullptr
mFocusedWindow
-
>
ShouldShowFocusRing
(
)
false
)
;
window
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
focus
"
)
nullptr
0
)
;
if
(
presShell
)
{
SendFocusOrBlurEvent
(
eBlur
presShell
oldFocusedElement
-
>
GetComposedDoc
(
)
oldFocusedElement
1
false
)
;
}
}
nsPresContext
*
focusedPresContext
=
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
IMEStateManager
:
:
OnChangeFocus
(
focusedPresContext
nullptr
GetFocusMoveActionCause
(
0
)
)
;
if
(
presShell
)
{
SetCaretVisible
(
presShell
false
nullptr
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShellBeingHidden
=
window
-
>
GetDocShell
(
)
;
bool
beingDestroyed
=
!
docShellBeingHidden
;
if
(
docShellBeingHidden
)
{
docShellBeingHidden
-
>
IsBeingDestroyed
(
&
beingDestroyed
)
;
}
if
(
beingDestroyed
)
{
if
(
mActiveWindow
=
=
mFocusedWindow
|
|
mActiveWindow
=
=
window
)
WindowLowered
(
mActiveWindow
)
;
else
ClearFocus
(
mActiveWindow
)
;
return
NS_OK
;
}
if
(
window
!
=
mFocusedWindow
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
mFocusedWindow
?
mFocusedWindow
-
>
GetDocShell
(
)
:
nullptr
;
if
(
dsti
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti
;
dsti
-
>
GetParent
(
getter_AddRefs
(
parentDsti
)
)
;
if
(
parentDsti
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindow
=
parentDsti
-
>
GetWindow
(
)
)
parentWindow
-
>
SetFocusedElement
(
nullptr
)
;
}
}
SetFocusedWindowInternal
(
window
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
FireDelayedEvents
(
Document
*
aDocument
)
{
NS_ENSURE_ARG
(
aDocument
)
;
for
(
uint32_t
i
=
0
;
i
<
mDelayedBlurFocusEvents
.
Length
(
)
;
i
+
+
)
{
if
(
mDelayedBlurFocusEvents
[
i
]
.
mDocument
=
=
aDocument
)
{
if
(
!
aDocument
-
>
GetInnerWindow
(
)
|
|
!
aDocument
-
>
GetInnerWindow
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
mDelayedBlurFocusEvents
.
RemoveElementAt
(
i
)
;
-
-
i
;
}
else
if
(
!
aDocument
-
>
EventHandlingSuppressed
(
)
)
{
EventMessage
message
=
mDelayedBlurFocusEvents
[
i
]
.
mEventMessage
;
nsCOMPtr
<
EventTarget
>
target
=
mDelayedBlurFocusEvents
[
i
]
.
mTarget
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDelayedBlurFocusEvents
[
i
]
.
mPresShell
;
nsCOMPtr
<
EventTarget
>
relatedTarget
=
mDelayedBlurFocusEvents
[
i
]
.
mRelatedTarget
;
mDelayedBlurFocusEvents
.
RemoveElementAt
(
i
)
;
FireFocusOrBlurEvent
(
message
presShell
target
false
false
relatedTarget
)
;
-
-
i
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
FocusPlugin
(
Element
*
aPlugin
)
{
NS_ENSURE_ARG
(
aPlugin
)
;
SetFocusInner
(
aPlugin
0
true
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFocusManager
:
:
ParentActivated
(
mozIDOMWindowProxy
*
aWindow
bool
aActive
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_INVALID_ARG
)
;
ActivateOrDeactivate
(
window
aActive
)
;
return
NS_OK
;
}
void
nsFocusManager
:
:
NotifyFocusStateChange
(
nsIContent
*
aContent
nsIContent
*
aContentToFocus
bool
aWindowShouldShowFocusRing
bool
aGettingFocus
)
{
MOZ_ASSERT_IF
(
aContentToFocus
!
aGettingFocus
)
;
if
(
!
aContent
-
>
IsElement
(
)
)
{
return
;
}
nsIContent
*
commonAncestor
=
nullptr
;
if
(
aContentToFocus
&
&
aContentToFocus
-
>
IsElement
(
)
)
{
commonAncestor
=
nsContentUtils
:
:
GetCommonFlattenedTreeAncestor
(
aContent
aContentToFocus
)
;
}
EventStates
eventState
=
NS_EVENT_STATE_FOCUS
;
if
(
aWindowShouldShowFocusRing
)
{
eventState
|
=
NS_EVENT_STATE_FOCUSRING
;
}
if
(
aGettingFocus
)
{
aContent
-
>
AsElement
(
)
-
>
AddStates
(
eventState
)
;
}
else
{
aContent
-
>
AsElement
(
)
-
>
RemoveStates
(
eventState
)
;
}
for
(
nsIContent
*
content
=
aContent
;
content
&
&
content
!
=
commonAncestor
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
element
=
content
-
>
AsElement
(
)
;
if
(
aGettingFocus
)
{
if
(
element
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FOCUS_WITHIN
)
)
{
break
;
}
element
-
>
AddStates
(
NS_EVENT_STATE_FOCUS_WITHIN
)
;
}
else
{
element
-
>
RemoveStates
(
NS_EVENT_STATE_FOCUS_WITHIN
)
;
}
}
}
void
nsFocusManager
:
:
EnsureCurrentWidgetFocused
(
)
{
if
(
!
mFocusedWindow
|
|
sTestMode
)
return
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
mFocusedWindow
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
widget
-
>
SetFocus
(
false
)
;
}
}
}
}
bool
ActivateOrDeactivateChild
(
BrowserParent
*
aParent
void
*
aArg
)
{
bool
active
=
static_cast
<
bool
>
(
aArg
)
;
Unused
<
<
aParent
-
>
SendParentActivated
(
active
)
;
return
false
;
}
void
nsFocusManager
:
:
ActivateOrDeactivate
(
nsPIDOMWindowOuter
*
aWindow
bool
aActive
)
{
if
(
!
aWindow
)
{
return
;
}
aWindow
-
>
ActivateOrDeactivate
(
aActive
)
;
if
(
aWindow
-
>
GetExtantDoc
(
)
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
aWindow
-
>
GetExtantDoc
(
)
aWindow
-
>
GetCurrentInnerWindow
(
)
aActive
?
NS_LITERAL_STRING
(
"
activate
"
)
:
NS_LITERAL_STRING
(
"
deactivate
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
nullptr
)
;
}
nsContentUtils
:
:
CallOnAllRemoteChildren
(
aWindow
ActivateOrDeactivateChild
(
void
*
)
aActive
)
;
}
void
nsFocusManager
:
:
SetFocusInner
(
Element
*
aNewContent
int32_t
aFlags
bool
aFocusChanged
bool
aAdjustWidget
)
{
RefPtr
<
Element
>
elementToFocus
=
FlushAndCheckIfFocusable
(
aNewContent
aFlags
)
;
if
(
!
elementToFocus
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
subWindow
=
GetContentWindow
(
elementToFocus
)
;
if
(
subWindow
)
{
elementToFocus
=
GetFocusedDescendant
(
subWindow
eIncludeAllDescendants
getter_AddRefs
(
newWindow
)
)
;
aFocusChanged
=
false
;
}
if
(
!
newWindow
)
{
newWindow
=
GetCurrentWindow
(
elementToFocus
)
;
}
if
(
!
newWindow
|
|
(
newWindow
=
=
mFocusedWindow
&
&
elementToFocus
=
=
mFocusedElement
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
newDocShell
=
newWindow
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
newDocShell
;
while
(
docShell
)
{
bool
inUnload
;
docShell
-
>
GetIsInUnload
(
&
inUnload
)
;
if
(
inUnload
)
return
;
bool
beingDestroyed
;
docShell
-
>
IsBeingDestroyed
(
&
beingDestroyed
)
;
if
(
beingDestroyed
)
return
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti
;
docShell
-
>
GetParent
(
getter_AddRefs
(
parentDsti
)
)
;
docShell
=
do_QueryInterface
(
parentDsti
)
;
}
bool
isElementInFocusedWindow
=
(
mFocusedWindow
=
=
newWindow
)
;
if
(
!
isElementInFocusedWindow
&
&
mFocusedWindow
&
&
newWindow
&
&
nsContentUtils
:
:
IsHandlingKeyBoardEvent
(
)
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
focused
=
do_QueryInterface
(
mFocusedWindow
)
;
nsCOMPtr
<
nsIScriptObjectPrincipal
>
newFocus
=
do_QueryInterface
(
newWindow
)
;
nsIPrincipal
*
focusedPrincipal
=
focused
-
>
GetPrincipal
(
)
;
nsIPrincipal
*
newPrincipal
=
newFocus
-
>
GetPrincipal
(
)
;
if
(
!
focusedPrincipal
|
|
!
newPrincipal
)
{
return
;
}
bool
subsumes
=
false
;
focusedPrincipal
-
>
Subsumes
(
newPrincipal
&
subsumes
)
;
if
(
!
subsumes
&
&
!
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
NS_WARNING
(
"
Not
allowed
to
focus
the
new
window
!
"
)
;
return
;
}
}
bool
isElementInActiveWindow
=
false
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
newWindow
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
newRootWindow
;
if
(
dsti
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
dsti
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
newRootWindow
=
root
?
root
-
>
GetWindow
(
)
:
nullptr
;
isElementInActiveWindow
=
(
mActiveWindow
&
&
newRootWindow
=
=
mActiveWindow
)
;
}
#
ifndef
XP_MACOSX
if
(
elementToFocus
&
&
nsContentUtils
:
:
GetRootDocument
(
elementToFocus
-
>
OwnerDoc
(
)
)
-
>
GetFullscreenElement
(
)
&
&
nsContentUtils
:
:
HasPluginWithUncontrolledEventDispatch
(
elementToFocus
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
elementToFocus
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
FocusedWindowedPluginWhileFullscreen
"
)
;
Document
:
:
AsyncExitFullscreen
(
elementToFocus
-
>
OwnerDoc
(
)
)
;
}
#
endif
bool
allowFrameSwitch
=
!
(
aFlags
&
FLAG_NOSWITCHFRAME
)
|
|
IsSameOrAncestor
(
newWindow
mFocusedWindow
)
;
bool
sendFocusEvent
=
isElementInActiveWindow
&
&
allowFrameSwitch
&
&
IsWindowVisible
(
newWindow
)
;
if
(
sendFocusEvent
&
&
mFocusedElement
&
&
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
mFocusedElement
-
>
OwnerDoc
(
)
!
=
aNewContent
-
>
OwnerDoc
(
)
)
{
sendFocusEvent
=
nsContentUtils
:
:
CanCallerAccess
(
mFocusedElement
)
;
if
(
!
sendFocusEvent
&
&
mMouseButtonEventHandlingDocument
)
{
sendFocusEvent
=
nsContentUtils
:
:
CanCallerAccess
(
mMouseButtonEventHandlingDocument
)
;
}
}
LOGCONTENT
(
"
Shift
Focus
:
%
s
"
elementToFocus
.
get
(
)
)
;
LOGFOCUS
(
(
"
Flags
:
%
x
Current
Window
:
%
p
New
Window
:
%
p
Current
Element
:
%
p
"
aFlags
mFocusedWindow
.
get
(
)
newWindow
.
get
(
)
mFocusedElement
.
get
(
)
)
)
;
LOGFOCUS
(
(
"
In
Active
Window
:
%
d
In
Focused
Window
:
%
d
SendFocus
:
%
d
"
isElementInActiveWindow
isElementInFocusedWindow
sendFocusEvent
)
)
;
if
(
sendFocusEvent
)
{
RefPtr
<
Element
>
oldFocusedElement
=
mFocusedElement
;
if
(
mFocusedWindow
)
{
bool
currentIsSameOrAncestor
=
IsSameOrAncestor
(
mFocusedWindow
newWindow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
commonAncestor
;
if
(
!
isElementInFocusedWindow
)
commonAncestor
=
GetCommonAncestor
(
newWindow
mFocusedWindow
)
;
if
(
!
Blur
(
currentIsSameOrAncestor
?
mFocusedWindow
.
get
(
)
:
nullptr
commonAncestor
!
isElementInFocusedWindow
aAdjustWidget
elementToFocus
)
)
{
return
;
}
}
Focus
(
newWindow
elementToFocus
aFlags
!
isElementInFocusedWindow
aFocusChanged
false
aAdjustWidget
oldFocusedElement
)
;
}
else
{
if
(
allowFrameSwitch
)
AdjustWindowFocus
(
newWindow
true
)
;
uint32_t
focusMethod
=
aFocusChanged
?
aFlags
&
FOCUSMETHODANDRING_MASK
:
newWindow
-
>
GetFocusMethod
(
)
|
(
aFlags
&
FLAG_SHOWRING
)
;
newWindow
-
>
SetFocusedElement
(
elementToFocus
focusMethod
)
;
if
(
aFocusChanged
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
newWindow
-
>
GetDocShell
(
)
;
RefPtr
<
PresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
DidInitialize
(
)
)
{
ScrollIntoView
(
presShell
elementToFocus
aFlags
)
;
}
}
if
(
allowFrameSwitch
)
newWindow
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
focus
"
)
nullptr
0
)
;
if
(
aFlags
&
FLAG_RAISE
)
RaiseWindow
(
newRootWindow
)
;
}
}
bool
nsFocusManager
:
:
IsSameOrAncestor
(
nsPIDOMWindowOuter
*
aPossibleAncestor
nsPIDOMWindowOuter
*
aWindow
)
{
if
(
!
aWindow
|
|
!
aPossibleAncestor
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
ancestordsti
=
aPossibleAncestor
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
aWindow
-
>
GetDocShell
(
)
;
while
(
dsti
)
{
if
(
dsti
=
=
ancestordsti
)
return
true
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti
;
dsti
-
>
GetParent
(
getter_AddRefs
(
parentDsti
)
)
;
dsti
.
swap
(
parentDsti
)
;
}
return
false
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsFocusManager
:
:
GetCommonAncestor
(
nsPIDOMWindowOuter
*
aWindow1
nsPIDOMWindowOuter
*
aWindow2
)
{
NS_ENSURE_TRUE
(
aWindow1
&
&
aWindow2
nullptr
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti1
=
aWindow1
-
>
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
dsti1
nullptr
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti2
=
aWindow2
-
>
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
dsti2
nullptr
)
;
AutoTArray
<
nsIDocShellTreeItem
*
30
>
parents1
parents2
;
do
{
parents1
.
AppendElement
(
dsti1
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti1
;
dsti1
-
>
GetParent
(
getter_AddRefs
(
parentDsti1
)
)
;
dsti1
.
swap
(
parentDsti1
)
;
}
while
(
dsti1
)
;
do
{
parents2
.
AppendElement
(
dsti2
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti2
;
dsti2
-
>
GetParent
(
getter_AddRefs
(
parentDsti2
)
)
;
dsti2
.
swap
(
parentDsti2
)
;
}
while
(
dsti2
)
;
uint32_t
pos1
=
parents1
.
Length
(
)
;
uint32_t
pos2
=
parents2
.
Length
(
)
;
nsIDocShellTreeItem
*
parent
=
nullptr
;
uint32_t
len
;
for
(
len
=
std
:
:
min
(
pos1
pos2
)
;
len
>
0
;
-
-
len
)
{
nsIDocShellTreeItem
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
nsIDocShellTreeItem
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
child1
!
=
child2
)
{
break
;
}
parent
=
child1
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
return
window
.
forget
(
)
;
}
void
nsFocusManager
:
:
AdjustWindowFocus
(
nsPIDOMWindowOuter
*
aWindow
bool
aCheckPermission
)
{
bool
isVisible
=
IsWindowVisible
(
aWindow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
aWindow
)
;
while
(
window
)
{
nsCOMPtr
<
Element
>
frameElement
=
window
-
>
GetFrameElementInternal
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
window
-
>
GetDocShell
(
)
;
if
(
!
dsti
)
return
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti
;
dsti
-
>
GetParent
(
getter_AddRefs
(
parentDsti
)
)
;
if
(
!
parentDsti
)
{
return
;
}
window
=
parentDsti
-
>
GetWindow
(
)
;
if
(
window
)
{
if
(
IsWindowVisible
(
window
)
!
=
isVisible
)
break
;
if
(
aCheckPermission
&
&
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
window
-
>
GetCurrentInnerWindow
(
)
)
)
{
break
;
}
window
-
>
SetFocusedElement
(
frameElement
)
;
}
}
}
bool
nsFocusManager
:
:
IsWindowVisible
(
nsPIDOMWindowOuter
*
aWindow
)
{
if
(
!
aWindow
|
|
aWindow
-
>
IsFrozen
(
)
)
return
false
;
nsPIDOMWindowInner
*
innerWindow
=
aWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
!
innerWindow
|
|
innerWindow
-
>
IsFrozen
(
)
)
return
false
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWin
(
do_QueryInterface
(
docShell
)
)
;
if
(
!
baseWin
)
return
false
;
bool
visible
=
false
;
baseWin
-
>
GetVisibility
(
&
visible
)
;
return
visible
;
}
bool
nsFocusManager
:
:
IsNonFocusableRoot
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
"
aContent
must
not
be
NULL
"
)
;
MOZ_ASSERT
(
aContent
-
>
IsInComposedDoc
(
)
"
aContent
must
be
in
a
document
"
)
;
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
NS_ASSERTION
(
doc
"
aContent
must
have
current
document
"
)
;
return
aContent
=
=
doc
-
>
GetRootElement
(
)
&
&
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
!
aContent
-
>
IsEditable
(
)
|
|
nsContentUtils
:
:
IsUserFocusIgnored
(
aContent
)
)
;
}
Element
*
nsFocusManager
:
:
FlushAndCheckIfFocusable
(
Element
*
aElement
uint32_t
aFlags
)
{
if
(
!
aElement
)
return
nullptr
;
nsCOMPtr
<
Document
>
doc
=
aElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
LOGCONTENT
(
"
Cannot
focus
%
s
because
content
not
in
document
"
aElement
)
return
nullptr
;
}
mEventHandlingNeedsFlush
=
false
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
EnsurePresShellInitAndFrames
)
;
RefPtr
<
Element
>
redirectedFocus
=
GetRedirectedFocus
(
aElement
)
;
if
(
redirectedFocus
)
{
return
FlushAndCheckIfFocusable
(
redirectedFocus
aFlags
)
;
}
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
if
(
aElement
=
=
doc
-
>
GetRootElement
(
)
)
{
return
nsContentUtils
:
:
IsUserFocusIgnored
(
aElement
)
?
nullptr
:
aElement
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PrintPreview
)
{
LOGCONTENT
(
"
Cannot
focus
%
s
while
in
print
preview
"
aElement
)
return
nullptr
;
}
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
LOGCONTENT
(
"
Cannot
focus
%
s
as
it
has
no
frame
"
aElement
)
return
nullptr
;
}
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
{
return
frame
-
>
IsVisibleConsideringAncestors
(
)
&
&
aElement
-
>
IsFocusable
(
)
?
aElement
:
nullptr
;
}
Document
*
subdoc
=
doc
-
>
GetSubDocumentFor
(
aElement
)
;
if
(
subdoc
&
&
IsWindowVisible
(
subdoc
-
>
GetWindow
(
)
)
)
{
const
nsStyleUI
*
ui
=
frame
-
>
StyleUI
(
)
;
int32_t
tabIndex
=
(
ui
-
>
mUserFocus
=
=
StyleUserFocus
:
:
Ignore
|
|
ui
-
>
mUserFocus
=
=
StyleUserFocus
:
:
None
)
?
-
1
:
0
;
return
aElement
-
>
IsFocusable
(
&
tabIndex
aFlags
&
FLAG_BYMOUSE
)
?
aElement
:
nullptr
;
}
return
frame
-
>
IsFocusable
(
nullptr
aFlags
&
FLAG_BYMOUSE
)
?
aElement
:
nullptr
;
}
bool
nsFocusManager
:
:
Blur
(
nsPIDOMWindowOuter
*
aWindowToClear
nsPIDOMWindowOuter
*
aAncestorWindowToFocus
bool
aIsLeavingDocument
bool
aAdjustWidgets
nsIContent
*
aContentToFocus
)
{
LOGFOCUS
(
(
"
<
<
Blur
begin
>
>
"
)
)
;
RefPtr
<
Element
>
element
=
mFocusedElement
;
if
(
element
)
{
if
(
!
element
-
>
IsInComposedDoc
(
)
)
{
mFocusedElement
=
nullptr
;
return
true
;
}
if
(
element
=
=
mFirstBlurEvent
)
return
true
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mFocusedWindow
;
if
(
!
window
)
{
mFocusedElement
=
nullptr
;
return
true
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
mFocusedWindow
=
nullptr
;
mFocusedElement
=
nullptr
;
return
true
;
}
RefPtr
<
PresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
mFocusedElement
=
nullptr
;
mFocusedWindow
=
nullptr
;
return
true
;
}
bool
clearFirstBlurEvent
=
false
;
if
(
!
mFirstBlurEvent
)
{
mFirstBlurEvent
=
element
;
clearFirstBlurEvent
=
true
;
}
nsPresContext
*
focusedPresContext
=
mActiveWindow
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
IMEStateManager
:
:
OnChangeFocus
(
focusedPresContext
nullptr
GetFocusMoveActionCause
(
0
)
)
;
mFocusedElement
=
nullptr
;
bool
shouldShowFocusRing
=
window
-
>
ShouldShowFocusRing
(
)
;
if
(
aWindowToClear
)
aWindowToClear
-
>
SetFocusedElement
(
nullptr
)
;
LOGCONTENT
(
"
Element
%
s
has
been
blurred
"
element
.
get
(
)
)
;
bool
sendBlurEvent
=
element
&
&
element
-
>
IsInComposedDoc
(
)
&
&
!
IsNonFocusableRoot
(
element
)
;
if
(
element
)
{
if
(
sendBlurEvent
)
{
NotifyFocusStateChange
(
element
aContentToFocus
shouldShowFocusRing
false
)
;
}
if
(
mActiveWindow
)
{
nsIFrame
*
contentFrame
=
element
-
>
GetPrimaryFrame
(
)
;
nsIObjectFrame
*
objectFrame
=
do_QueryFrame
(
contentFrame
)
;
if
(
aAdjustWidgets
&
&
objectFrame
&
&
!
sTestMode
)
{
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIBrowserChild
>
browserChild
=
docShell
-
>
GetBrowserChild
(
)
;
if
(
browserChild
)
{
static_cast
<
BrowserChild
*
>
(
browserChild
.
get
(
)
)
-
>
SendDispatchFocusToTopLevelWindow
(
)
;
}
}
else
{
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
{
widget
-
>
SetFocus
(
false
)
;
}
}
}
}
}
if
(
BrowserParent
*
remote
=
BrowserParent
:
:
GetFrom
(
element
)
)
{
remote
-
>
Deactivate
(
)
;
LOGFOCUS
(
(
"
Remote
browser
deactivated
%
p
"
remote
)
)
;
}
if
(
BrowserBridgeChild
*
bbc
=
BrowserBridgeChild
:
:
GetFrom
(
element
)
)
{
bbc
-
>
Deactivate
(
)
;
LOGFOCUS
(
(
"
Out
-
of
-
process
iframe
deactivated
%
p
"
bbc
)
)
;
}
}
bool
result
=
true
;
if
(
sendBlurEvent
)
{
if
(
mActiveWindow
)
window
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
focus
"
)
nullptr
0
)
;
SendFocusOrBlurEvent
(
eBlur
presShell
element
-
>
GetComposedDoc
(
)
element
1
false
false
aContentToFocus
)
;
}
if
(
aIsLeavingDocument
|
|
!
mActiveWindow
)
{
SetCaretVisible
(
presShell
false
nullptr
)
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
presShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
eventHub
)
{
eventHub
-
>
NotifyBlur
(
aIsLeavingDocument
|
|
!
mActiveWindow
)
;
}
if
(
mFocusedWindow
!
=
window
|
|
(
mFocusedElement
!
=
nullptr
&
&
!
aIsLeavingDocument
)
)
{
result
=
false
;
}
else
if
(
aIsLeavingDocument
)
{
window
-
>
TakeFocus
(
false
0
)
;
if
(
aAncestorWindowToFocus
)
aAncestorWindowToFocus
-
>
SetFocusedElement
(
nullptr
0
true
)
;
SetFocusedWindowInternal
(
nullptr
)
;
mFocusedElement
=
nullptr
;
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
SendFocusOrBlurEvent
(
eBlur
presShell
doc
ToSupports
(
doc
)
1
false
)
;
if
(
mFocusedWindow
=
=
nullptr
)
SendFocusOrBlurEvent
(
eBlur
presShell
doc
window
-
>
GetCurrentInnerWindow
(
)
1
false
)
;
result
=
(
mFocusedWindow
=
=
nullptr
&
&
mActiveWindow
)
;
}
else
if
(
mActiveWindow
)
{
UpdateCaret
(
false
true
nullptr
)
;
}
if
(
clearFirstBlurEvent
)
mFirstBlurEvent
=
nullptr
;
return
result
;
}
void
nsFocusManager
:
:
Focus
(
nsPIDOMWindowOuter
*
aWindow
Element
*
aElement
uint32_t
aFlags
bool
aIsNewDocument
bool
aFocusChanged
bool
aWindowRaised
bool
aAdjustWidgets
nsIContent
*
aContentLostFocus
)
{
LOGFOCUS
(
(
"
<
<
Focus
begin
>
>
"
)
)
;
if
(
!
aWindow
)
return
;
if
(
aElement
&
&
(
aElement
=
=
mFirstFocusEvent
|
|
aElement
=
=
mFirstBlurEvent
)
)
return
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
return
;
RefPtr
<
PresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
uint32_t
focusMethod
=
aFocusChanged
?
aFlags
&
FOCUSMETHODANDRING_MASK
:
aWindow
-
>
GetFocusMethod
(
)
|
(
aFlags
&
FLAG_SHOWRING
)
;
if
(
!
IsWindowVisible
(
aWindow
)
)
{
if
(
FlushAndCheckIfFocusable
(
aElement
aFlags
)
)
{
aWindow
-
>
SetFocusedElement
(
aElement
focusMethod
)
;
if
(
aFocusChanged
)
{
ScrollIntoView
(
presShell
aElement
aFlags
)
;
}
}
return
;
}
bool
clearFirstFocusEvent
=
false
;
if
(
!
mFirstFocusEvent
)
{
mFirstFocusEvent
=
aElement
;
clearFirstFocusEvent
=
true
;
}
LOGCONTENT
(
"
Element
%
s
has
been
focused
"
aElement
)
;
if
(
MOZ_LOG_TEST
(
gFocusLog
LogLevel
:
:
Debug
)
)
{
Document
*
docm
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
docm
)
{
LOGCONTENT
(
"
from
%
s
"
docm
-
>
GetRootElement
(
)
)
;
}
LOGFOCUS
(
(
"
[
Newdoc
:
%
d
FocusChanged
:
%
d
Raised
:
%
d
Flags
:
%
x
]
"
aIsNewDocument
aFocusChanged
aWindowRaised
aFlags
)
)
;
}
if
(
aIsNewDocument
)
{
AdjustWindowFocus
(
aWindow
false
)
;
}
if
(
aWindow
-
>
TakeFocus
(
true
focusMethod
)
)
aIsNewDocument
=
true
;
SetFocusedWindowInternal
(
aWindow
)
;
nsCOMPtr
<
nsIWidget
>
objectFrameWidget
;
if
(
aElement
)
{
nsIFrame
*
contentFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
nsIObjectFrame
*
objectFrame
=
do_QueryFrame
(
contentFrame
)
;
if
(
objectFrame
)
objectFrameWidget
=
objectFrame
-
>
GetWidget
(
)
;
}
if
(
aAdjustWidgets
&
&
!
objectFrameWidget
&
&
!
sTestMode
)
{
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
widget
-
>
SetFocus
(
false
)
;
}
}
if
(
aIsNewDocument
)
{
Document
*
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
IMEStateManager
:
:
OnChangeFocus
(
presShell
-
>
GetPresContext
(
)
nullptr
GetFocusMoveActionCause
(
aFlags
)
)
;
}
if
(
doc
)
{
SendFocusOrBlurEvent
(
eFocus
presShell
doc
ToSupports
(
doc
)
aFlags
&
FOCUSMETHOD_MASK
aWindowRaised
)
;
}
if
(
mFocusedWindow
=
=
aWindow
&
&
mFocusedElement
=
=
nullptr
)
{
SendFocusOrBlurEvent
(
eFocus
presShell
doc
aWindow
-
>
GetCurrentInnerWindow
(
)
aFlags
&
FOCUSMETHOD_MASK
aWindowRaised
)
;
}
}
if
(
FlushAndCheckIfFocusable
(
aElement
aFlags
)
&
&
mFocusedWindow
=
=
aWindow
&
&
mFocusedElement
=
=
nullptr
)
{
mFocusedElement
=
aElement
;
nsIContent
*
focusedNode
=
aWindow
-
>
GetFocusedElement
(
)
;
bool
isRefocus
=
focusedNode
&
&
focusedNode
-
>
IsEqualNode
(
aElement
)
;
aWindow
-
>
SetFocusedElement
(
aElement
focusMethod
)
;
if
(
aElement
&
&
aFocusChanged
)
{
ScrollIntoView
(
presShell
aElement
aFlags
)
;
}
bool
sendFocusEvent
=
aElement
&
&
aElement
-
>
IsInComposedDoc
(
)
&
&
!
IsNonFocusableRoot
(
aElement
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
sendFocusEvent
)
{
NotifyFocusStateChange
(
aElement
nullptr
aWindow
-
>
ShouldShowFocusRing
(
)
true
)
;
if
(
presShell
-
>
GetDocument
(
)
=
=
aElement
-
>
GetComposedDoc
(
)
)
{
if
(
aAdjustWidgets
&
&
objectFrameWidget
&
&
!
sTestMode
)
objectFrameWidget
-
>
SetFocus
(
false
)
;
if
(
BrowserParent
*
remote
=
BrowserParent
:
:
GetFrom
(
aElement
)
)
{
remote
-
>
Activate
(
)
;
LOGFOCUS
(
(
"
Remote
browser
activated
%
p
"
remote
)
)
;
}
if
(
BrowserBridgeChild
*
bbc
=
BrowserBridgeChild
:
:
GetFrom
(
aElement
)
)
{
bbc
-
>
Activate
(
)
;
LOGFOCUS
(
(
"
Out
-
of
-
process
iframe
activated
%
p
"
bbc
)
)
;
}
}
IMEStateManager
:
:
OnChangeFocus
(
presContext
aElement
GetFocusMoveActionCause
(
aFlags
)
)
;
if
(
!
aWindowRaised
)
aWindow
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
focus
"
)
nullptr
0
)
;
SendFocusOrBlurEvent
(
eFocus
presShell
aElement
-
>
GetComposedDoc
(
)
aElement
aFlags
&
FOCUSMETHOD_MASK
aWindowRaised
isRefocus
aContentLostFocus
)
;
}
else
{
IMEStateManager
:
:
OnChangeFocus
(
presContext
nullptr
GetFocusMoveActionCause
(
aFlags
)
)
;
if
(
!
aWindowRaised
)
{
aWindow
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
focus
"
)
nullptr
0
)
;
}
}
}
else
{
if
(
aAdjustWidgets
&
&
objectFrameWidget
&
&
mFocusedWindow
=
=
aWindow
&
&
mFocusedElement
=
=
nullptr
&
&
!
sTestMode
)
{
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
widget
-
>
SetFocus
(
false
)
;
}
}
if
(
!
mFocusedElement
)
{
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
IMEStateManager
:
:
OnChangeFocus
(
presContext
nullptr
GetFocusMoveActionCause
(
aFlags
)
)
;
}
if
(
!
aWindowRaised
)
aWindow
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
focus
"
)
nullptr
0
)
;
}
if
(
mFocusedElement
=
=
aElement
)
UpdateCaret
(
aFocusChanged
&
&
!
(
aFlags
&
FLAG_BYMOUSE
)
aIsNewDocument
mFocusedElement
)
;
if
(
clearFirstFocusEvent
)
mFirstFocusEvent
=
nullptr
;
}
class
FocusBlurEvent
:
public
Runnable
{
public
:
FocusBlurEvent
(
nsISupports
*
aTarget
EventMessage
aEventMessage
nsPresContext
*
aContext
bool
aWindowRaised
bool
aIsRefocus
EventTarget
*
aRelatedTarget
)
:
mozilla
:
:
Runnable
(
"
FocusBlurEvent
"
)
mTarget
(
aTarget
)
mContext
(
aContext
)
mEventMessage
(
aEventMessage
)
mWindowRaised
(
aWindowRaised
)
mIsRefocus
(
aIsRefocus
)
mRelatedTarget
(
aRelatedTarget
)
{
}
NS_IMETHOD
Run
(
)
override
{
InternalFocusEvent
event
(
true
mEventMessage
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mFlags
.
mCancelable
=
false
;
event
.
mFromRaise
=
mWindowRaised
;
event
.
mIsRefocus
=
mIsRefocus
;
event
.
mRelatedTarget
=
mRelatedTarget
;
return
EventDispatcher
:
:
Dispatch
(
mTarget
mContext
&
event
)
;
}
nsCOMPtr
<
nsISupports
>
mTarget
;
RefPtr
<
nsPresContext
>
mContext
;
EventMessage
mEventMessage
;
bool
mWindowRaised
;
bool
mIsRefocus
;
nsCOMPtr
<
EventTarget
>
mRelatedTarget
;
}
;
class
FocusInOutEvent
:
public
Runnable
{
public
:
FocusInOutEvent
(
nsISupports
*
aTarget
EventMessage
aEventMessage
nsPresContext
*
aContext
nsPIDOMWindowOuter
*
aOriginalFocusedWindow
nsIContent
*
aOriginalFocusedContent
EventTarget
*
aRelatedTarget
)
:
mozilla
:
:
Runnable
(
"
FocusInOutEvent
"
)
mTarget
(
aTarget
)
mContext
(
aContext
)
mEventMessage
(
aEventMessage
)
mOriginalFocusedWindow
(
aOriginalFocusedWindow
)
mOriginalFocusedContent
(
aOriginalFocusedContent
)
mRelatedTarget
(
aRelatedTarget
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsCOMPtr
<
nsIContent
>
originalWindowFocus
=
mOriginalFocusedWindow
?
mOriginalFocusedWindow
-
>
GetFocusedElement
(
)
:
nullptr
;
if
(
mEventMessage
=
=
eFocusOut
|
|
originalWindowFocus
=
=
mOriginalFocusedContent
)
{
InternalFocusEvent
event
(
true
mEventMessage
)
;
event
.
mFlags
.
mBubbles
=
true
;
event
.
mFlags
.
mCancelable
=
false
;
event
.
mRelatedTarget
=
mRelatedTarget
;
return
EventDispatcher
:
:
Dispatch
(
mTarget
mContext
&
event
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsISupports
>
mTarget
;
RefPtr
<
nsPresContext
>
mContext
;
EventMessage
mEventMessage
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mOriginalFocusedWindow
;
nsCOMPtr
<
nsIContent
>
mOriginalFocusedContent
;
nsCOMPtr
<
EventTarget
>
mRelatedTarget
;
}
;
static
Document
*
GetDocumentHelper
(
EventTarget
*
aTarget
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aTarget
)
;
if
(
!
node
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aTarget
)
;
return
win
?
win
-
>
GetExtantDoc
(
)
:
nullptr
;
}
return
node
-
>
OwnerDoc
(
)
;
}
void
nsFocusManager
:
:
FireFocusInOrOutEvent
(
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
nsISupports
*
aTarget
nsPIDOMWindowOuter
*
aCurrentFocusedWindow
nsIContent
*
aCurrentFocusedContent
EventTarget
*
aRelatedTarget
)
{
NS_ASSERTION
(
aEventMessage
=
=
eFocusIn
|
|
aEventMessage
=
=
eFocusOut
"
Wrong
event
type
for
FireFocusInOrOutEvent
"
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
FocusInOutEvent
(
aTarget
aEventMessage
aPresShell
-
>
GetPresContext
(
)
aCurrentFocusedWindow
aCurrentFocusedContent
aRelatedTarget
)
)
;
}
void
nsFocusManager
:
:
SendFocusOrBlurEvent
(
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
Document
*
aDocument
nsISupports
*
aTarget
uint32_t
aFocusMethod
bool
aWindowRaised
bool
aIsRefocus
EventTarget
*
aRelatedTarget
)
{
NS_ASSERTION
(
aEventMessage
=
=
eFocus
|
|
aEventMessage
=
=
eBlur
"
Wrong
event
type
for
SendFocusOrBlurEvent
"
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
do_QueryInterface
(
aTarget
)
;
nsCOMPtr
<
Document
>
eventTargetDoc
=
GetDocumentHelper
(
eventTarget
)
;
nsCOMPtr
<
Document
>
relatedTargetDoc
=
GetDocumentHelper
(
aRelatedTarget
)
;
if
(
eventTargetDoc
!
=
relatedTargetDoc
)
{
aRelatedTarget
=
nullptr
;
}
bool
dontDispatchEvent
=
eventTargetDoc
&
&
nsContentUtils
:
:
IsUserFocusIgnored
(
eventTargetDoc
)
;
if
(
!
dontDispatchEvent
&
&
aDocument
&
&
aDocument
-
>
EventHandlingSuppressed
(
)
)
{
for
(
uint32_t
i
=
mDelayedBlurFocusEvents
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
if
(
mDelayedBlurFocusEvents
[
i
-
1
]
.
mEventMessage
=
=
aEventMessage
&
&
mDelayedBlurFocusEvents
[
i
-
1
]
.
mPresShell
=
=
aPresShell
&
&
mDelayedBlurFocusEvents
[
i
-
1
]
.
mDocument
=
=
aDocument
&
&
mDelayedBlurFocusEvents
[
i
-
1
]
.
mTarget
=
=
eventTarget
&
&
mDelayedBlurFocusEvents
[
i
-
1
]
.
mRelatedTarget
=
=
aRelatedTarget
)
{
mDelayedBlurFocusEvents
.
RemoveElementAt
(
i
-
1
)
;
}
}
mDelayedBlurFocusEvents
.
AppendElement
(
nsDelayedBlurOrFocusEvent
(
aEventMessage
aPresShell
aDocument
eventTarget
aRelatedTarget
)
)
;
return
;
}
if
(
aDocument
&
&
!
aDocument
-
>
EventHandlingSuppressed
(
)
&
&
mDelayedBlurFocusEvents
.
Length
(
)
)
{
FireDelayedEvents
(
aDocument
)
;
}
FireFocusOrBlurEvent
(
aEventMessage
aPresShell
aTarget
aWindowRaised
aIsRefocus
aRelatedTarget
)
;
}
void
nsFocusManager
:
:
FireFocusOrBlurEvent
(
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
nsISupports
*
aTarget
bool
aWindowRaised
bool
aIsRefocus
EventTarget
*
aRelatedTarget
)
{
nsCOMPtr
<
EventTarget
>
eventTarget
=
do_QueryInterface
(
aTarget
)
;
nsCOMPtr
<
Document
>
eventTargetDoc
=
GetDocumentHelper
(
eventTarget
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
currentWindow
=
mFocusedWindow
;
nsCOMPtr
<
nsPIDOMWindowInner
>
targetWindow
=
do_QueryInterface
(
aTarget
)
;
nsCOMPtr
<
Document
>
targetDocument
=
do_QueryInterface
(
aTarget
)
;
nsCOMPtr
<
nsIContent
>
currentFocusedContent
=
currentWindow
?
currentWindow
-
>
GetFocusedElement
(
)
:
nullptr
;
bool
dontDispatchEvent
=
eventTargetDoc
&
&
nsContentUtils
:
:
IsUserFocusIgnored
(
eventTargetDoc
)
;
#
ifdef
ACCESSIBILITY
nsAccessibilityService
*
accService
=
GetAccService
(
)
;
if
(
accService
)
{
if
(
aEventMessage
=
=
eFocus
)
{
accService
-
>
NotifyOfDOMFocus
(
aTarget
)
;
}
else
{
accService
-
>
NotifyOfDOMBlur
(
aTarget
)
;
}
}
#
endif
if
(
!
dontDispatchEvent
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
FocusBlurEvent
(
aTarget
aEventMessage
aPresShell
-
>
GetPresContext
(
)
aWindowRaised
aIsRefocus
aRelatedTarget
)
)
;
if
(
!
targetWindow
&
&
!
targetDocument
)
{
EventMessage
focusInOrOutMessage
=
aEventMessage
=
=
eFocus
?
eFocusIn
:
eFocusOut
;
FireFocusInOrOutEvent
(
focusInOrOutMessage
aPresShell
aTarget
currentWindow
currentFocusedContent
aRelatedTarget
)
;
}
}
}
void
nsFocusManager
:
:
ScrollIntoView
(
PresShell
*
aPresShell
nsIContent
*
aContent
uint32_t
aFlags
)
{
if
(
!
(
aFlags
&
FLAG_NOSCROLL
)
)
{
uint32_t
scrollFlags
=
nsIPresShell
:
:
SCROLL_OVERFLOW_HIDDEN
;
if
(
!
(
aFlags
&
FLAG_BYELEMENTFOCUS
)
)
{
scrollFlags
|
=
nsIPresShell
:
:
SCROLL_IGNORE_SCROLL_MARGIN_AND_PADDING
;
}
aPresShell
-
>
ScrollContentIntoView
(
aContent
nsIPresShell
:
:
ScrollAxis
(
nsIPresShell
:
:
SCROLL_MINIMUM
nsIPresShell
:
:
SCROLL_IF_NOT_VISIBLE
)
nsIPresShell
:
:
ScrollAxis
(
nsIPresShell
:
:
SCROLL_MINIMUM
nsIPresShell
:
:
SCROLL_IF_NOT_VISIBLE
)
scrollFlags
)
;
}
}
void
nsFocusManager
:
:
RaiseWindow
(
nsPIDOMWindowOuter
*
aWindow
)
{
if
(
!
aWindow
|
|
aWindow
=
=
mActiveWindow
|
|
aWindow
=
=
mWindowBeingLowered
)
return
;
if
(
sTestMode
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
active
(
mActiveWindow
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
aWindow
)
;
RefPtr
<
nsFocusManager
>
self
(
this
)
;
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
nsFocusManager
:
:
RaiseWindow
"
[
self
active
window
]
(
)
-
>
void
{
if
(
active
)
{
self
-
>
WindowLowered
(
active
)
;
}
self
-
>
WindowRaised
(
window
)
;
}
)
)
;
return
;
}
#
if
defined
(
XP_WIN
)
nsCOMPtr
<
nsPIDOMWindowOuter
>
childWindow
;
GetFocusedDescendant
(
aWindow
eIncludeAllDescendants
getter_AddRefs
(
childWindow
)
)
;
if
(
!
childWindow
)
childWindow
=
aWindow
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
return
;
PresShell
*
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
widget
-
>
SetFocus
(
true
)
;
}
#
else
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
do_QueryInterface
(
aWindow
-
>
GetDocShell
(
)
)
;
if
(
treeOwnerAsWin
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
treeOwnerAsWin
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
)
widget
-
>
SetFocus
(
true
)
;
}
#
endif
}
void
nsFocusManager
:
:
UpdateCaretForCaretBrowsingMode
(
)
{
UpdateCaret
(
false
true
mFocusedElement
)
;
}
void
nsFocusManager
:
:
UpdateCaret
(
bool
aMoveCaretToFocus
bool
aUpdateVisibility
nsIContent
*
aContent
)
{
LOGFOCUS
(
(
"
Update
Caret
:
%
d
%
d
"
aMoveCaretToFocus
aUpdateVisibility
)
)
;
if
(
!
mFocusedWindow
)
return
;
nsCOMPtr
<
nsIDocShell
>
focusedDocShell
=
mFocusedWindow
-
>
GetDocShell
(
)
;
if
(
!
focusedDocShell
)
{
return
;
}
if
(
focusedDocShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
;
}
bool
browseWithCaret
=
Preferences
:
:
GetBool
(
"
accessibility
.
browsewithcaret
"
)
;
RefPtr
<
PresShell
>
presShell
=
focusedDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
bool
isEditable
=
false
;
focusedDocShell
-
>
GetEditable
(
&
isEditable
)
;
if
(
isEditable
)
{
nsCOMPtr
<
nsIHTMLDocument
>
doc
=
do_QueryInterface
(
presShell
-
>
GetDocument
(
)
)
;
bool
isContentEditableDoc
=
doc
&
&
doc
-
>
GetEditingState
(
)
=
=
nsIHTMLDocument
:
:
eContentEditable
;
bool
isFocusEditable
=
aContent
&
&
aContent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
!
isContentEditableDoc
|
|
isFocusEditable
)
return
;
}
if
(
!
isEditable
&
&
aMoveCaretToFocus
)
{
MoveCaretToFocus
(
presShell
aContent
)
;
}
if
(
!
aUpdateVisibility
)
return
;
if
(
!
browseWithCaret
)
{
nsCOMPtr
<
Element
>
docElement
=
mFocusedWindow
-
>
GetFrameElementInternal
(
)
;
if
(
docElement
)
browseWithCaret
=
docElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
showcaret
NS_LITERAL_STRING
(
"
true
"
)
eCaseMatters
)
;
}
SetCaretVisible
(
presShell
browseWithCaret
aContent
)
;
}
void
nsFocusManager
:
:
MoveCaretToFocus
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
)
{
nsCOMPtr
<
Document
>
doc
=
aPresShell
-
>
GetDocument
(
)
;
if
(
doc
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
aPresShell
-
>
FrameSelection
(
)
;
RefPtr
<
Selection
>
domSelection
=
frameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
domSelection
)
{
domSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
if
(
aContent
)
{
ErrorResult
rv
;
RefPtr
<
nsRange
>
newRange
=
doc
-
>
CreateRange
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
;
}
newRange
-
>
SelectNodeContents
(
*
aContent
IgnoreErrors
(
)
)
;
if
(
!
aContent
-
>
GetFirstChild
(
)
|
|
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
)
{
newRange
-
>
SetStartBefore
(
*
aContent
IgnoreErrors
(
)
)
;
newRange
-
>
SetEndBefore
(
*
aContent
IgnoreErrors
(
)
)
;
}
domSelection
-
>
AddRange
(
*
newRange
IgnoreErrors
(
)
)
;
domSelection
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
}
}
}
nsresult
nsFocusManager
:
:
SetCaretVisible
(
nsIPresShell
*
aPresShell
bool
aVisible
nsIContent
*
aContent
)
{
RefPtr
<
nsCaret
>
caret
=
aPresShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
return
NS_OK
;
bool
caretVisible
=
caret
-
>
IsVisible
(
)
;
if
(
!
aVisible
&
&
!
caretVisible
)
return
NS_OK
;
RefPtr
<
nsFrameSelection
>
frameSelection
;
if
(
aContent
)
{
NS_ASSERTION
(
aContent
-
>
GetComposedDoc
(
)
=
=
aPresShell
-
>
GetDocument
(
)
"
Wrong
document
?
"
)
;
nsIFrame
*
focusFrame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
focusFrame
)
frameSelection
=
focusFrame
-
>
GetFrameSelection
(
)
;
}
RefPtr
<
nsFrameSelection
>
docFrameSelection
=
aPresShell
-
>
FrameSelection
(
)
;
if
(
docFrameSelection
&
&
caret
&
&
(
frameSelection
=
=
docFrameSelection
|
|
!
aContent
)
)
{
Selection
*
domSelection
=
docFrameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
domSelection
)
{
nsCOMPtr
<
nsISelectionController
>
selCon
(
do_QueryInterface
(
aPresShell
)
)
;
if
(
!
selCon
)
{
return
NS_ERROR_FAILURE
;
}
selCon
-
>
SetCaretEnabled
(
false
)
;
caret
-
>
SetIgnoreUserModify
(
true
)
;
caret
-
>
SetSelection
(
domSelection
)
;
selCon
-
>
SetCaretReadOnly
(
false
)
;
selCon
-
>
SetCaretEnabled
(
aVisible
)
;
}
}
return
NS_OK
;
}
nsresult
nsFocusManager
:
:
GetSelectionLocation
(
Document
*
aDocument
nsIPresShell
*
aPresShell
nsIContent
*
*
aStartContent
nsIContent
*
*
aEndContent
)
{
*
aStartContent
=
*
aEndContent
=
nullptr
;
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
NS_ASSERTION
(
presContext
"
mPresContent
is
null
!
!
"
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
aPresShell
-
>
FrameSelection
(
)
;
RefPtr
<
Selection
>
domSelection
;
if
(
frameSelection
)
{
domSelection
=
frameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
}
bool
isCollapsed
=
false
;
nsCOMPtr
<
nsIContent
>
startContent
endContent
;
uint32_t
startOffset
=
0
;
if
(
domSelection
)
{
isCollapsed
=
domSelection
-
>
IsCollapsed
(
)
;
RefPtr
<
nsRange
>
domRange
=
domSelection
-
>
GetRangeAt
(
0
)
;
if
(
domRange
)
{
nsCOMPtr
<
nsINode
>
startNode
=
domRange
-
>
GetStartContainer
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
domRange
-
>
GetEndContainer
(
)
;
startOffset
=
domRange
-
>
StartOffset
(
)
;
nsIContent
*
childContent
=
nullptr
;
startContent
=
do_QueryInterface
(
startNode
)
;
if
(
startContent
&
&
startContent
-
>
IsElement
(
)
)
{
childContent
=
startContent
-
>
GetChildAt_Deprecated
(
startOffset
)
;
if
(
childContent
)
{
startContent
=
childContent
;
}
}
endContent
=
do_QueryInterface
(
endNode
)
;
if
(
endContent
&
&
endContent
-
>
IsElement
(
)
)
{
uint32_t
endOffset
=
domRange
-
>
EndOffset
(
)
;
childContent
=
endContent
-
>
GetChildAt_Deprecated
(
endOffset
)
;
if
(
childContent
)
{
endContent
=
childContent
;
}
}
}
}
else
{
return
NS_ERROR_INVALID_ARG
;
}
nsIFrame
*
startFrame
=
nullptr
;
if
(
startContent
)
{
startFrame
=
startContent
-
>
GetPrimaryFrame
(
)
;
if
(
isCollapsed
)
{
if
(
startContent
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
nsAutoString
nodeValue
;
startContent
-
>
GetAsText
(
)
-
>
AppendTextTo
(
nodeValue
)
;
bool
isFormControl
=
startContent
-
>
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
;
if
(
nodeValue
.
Length
(
)
=
=
startOffset
&
&
!
isFormControl
&
&
startContent
!
=
aDocument
-
>
GetRootElement
(
)
)
{
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
nsresult
rv
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
presContext
startFrame
eLeaf
false
false
true
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIFrame
*
newCaretFrame
=
nullptr
;
nsCOMPtr
<
nsIContent
>
newCaretContent
=
startContent
;
bool
endOfSelectionInStartNode
(
startContent
=
=
endContent
)
;
do
{
frameTraversal
-
>
Next
(
)
;
newCaretFrame
=
static_cast
<
nsIFrame
*
>
(
frameTraversal
-
>
CurrentItem
(
)
)
;
if
(
nullptr
=
=
newCaretFrame
)
break
;
newCaretContent
=
newCaretFrame
-
>
GetContent
(
)
;
}
while
(
!
newCaretContent
|
|
newCaretContent
=
=
startContent
)
;
if
(
newCaretFrame
&
&
newCaretContent
)
{
nsRect
caretRect
;
nsIFrame
*
frame
=
nsCaret
:
:
GetGeometry
(
domSelection
&
caretRect
)
;
if
(
frame
)
{
nsPoint
caretWidgetOffset
;
nsIWidget
*
widget
=
frame
-
>
GetNearestWidget
(
caretWidgetOffset
)
;
caretRect
.
MoveBy
(
caretWidgetOffset
)
;
nsPoint
newCaretOffset
;
nsIWidget
*
newCaretWidget
=
newCaretFrame
-
>
GetNearestWidget
(
newCaretOffset
)
;
if
(
widget
=
=
newCaretWidget
&
&
caretRect
.
y
=
=
newCaretOffset
.
y
&
&
caretRect
.
x
=
=
newCaretOffset
.
x
)
{
startFrame
=
newCaretFrame
;
startContent
=
newCaretContent
;
if
(
endOfSelectionInStartNode
)
{
endContent
=
newCaretContent
;
}
}
}
}
}
}
}
}
*
aStartContent
=
startContent
;
*
aEndContent
=
endContent
;
NS_IF_ADDREF
(
*
aStartContent
)
;
NS_IF_ADDREF
(
*
aEndContent
)
;
return
NS_OK
;
}
nsresult
nsFocusManager
:
:
DetermineElementToMoveFocus
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aStartContent
int32_t
aType
bool
aNoParentTraversal
nsIContent
*
*
aNextContent
)
{
*
aNextContent
=
nullptr
;
bool
forDocumentNavigation
=
false
;
bool
mayFocusRoot
=
(
aStartContent
!
=
nullptr
)
;
nsCOMPtr
<
nsIContent
>
startContent
=
aStartContent
;
if
(
!
startContent
&
&
aType
!
=
MOVEFOCUS_CARET
)
{
if
(
aType
=
=
MOVEFOCUS_FORWARDDOC
|
|
aType
=
=
MOVEFOCUS_BACKWARDDOC
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
startContent
=
GetFocusedDescendant
(
aWindow
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
}
else
if
(
aType
!
=
MOVEFOCUS_LASTDOC
)
{
startContent
=
aWindow
-
>
GetFocusedElement
(
)
;
}
}
nsCOMPtr
<
Document
>
doc
;
if
(
startContent
)
doc
=
startContent
-
>
GetComposedDoc
(
)
;
else
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
return
NS_OK
;
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_TabFocusModel
&
nsIContent
:
:
sTabFocusModel
)
;
if
(
aType
=
=
MOVEFOCUS_FORWARDDOC
|
|
aType
=
=
MOVEFOCUS_BACKWARDDOC
|
|
aType
=
=
MOVEFOCUS_FIRSTDOC
|
|
aType
=
=
MOVEFOCUS_LASTDOC
)
{
forDocumentNavigation
=
true
;
}
if
(
aType
=
=
MOVEFOCUS_ROOT
|
|
aType
=
=
MOVEFOCUS_FIRSTDOC
)
{
NS_IF_ADDREF
(
*
aNextContent
=
GetRootForFocus
(
aWindow
doc
false
false
)
)
;
if
(
!
*
aNextContent
&
&
aType
=
=
MOVEFOCUS_FIRSTDOC
)
{
aType
=
MOVEFOCUS_FORWARDDOC
;
}
else
{
return
NS_OK
;
}
}
Element
*
rootContent
=
doc
-
>
GetRootElement
(
)
;
NS_ENSURE_TRUE
(
rootContent
NS_OK
)
;
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_OK
)
;
if
(
aType
=
=
MOVEFOCUS_FIRST
)
{
if
(
!
aStartContent
)
startContent
=
rootContent
;
return
GetNextTabbableContent
(
presShell
startContent
nullptr
startContent
true
1
false
false
aNextContent
)
;
}
if
(
aType
=
=
MOVEFOCUS_LAST
)
{
if
(
!
aStartContent
)
startContent
=
rootContent
;
return
GetNextTabbableContent
(
presShell
startContent
nullptr
startContent
false
0
false
false
aNextContent
)
;
}
bool
forward
=
(
aType
=
=
MOVEFOCUS_FORWARD
|
|
aType
=
=
MOVEFOCUS_FORWARDDOC
|
|
aType
=
=
MOVEFOCUS_CARET
)
;
bool
doNavigation
=
true
;
bool
ignoreTabIndex
=
false
;
nsIFrame
*
popupFrame
=
nullptr
;
int32_t
tabIndex
=
forward
?
1
:
0
;
if
(
startContent
)
{
nsIFrame
*
frame
=
startContent
-
>
GetPrimaryFrame
(
)
;
if
(
startContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
startContent
-
>
IsFocusable
(
&
tabIndex
)
;
else
if
(
frame
)
frame
-
>
IsFocusable
(
&
tabIndex
0
)
;
else
startContent
-
>
IsFocusable
(
&
tabIndex
)
;
if
(
tabIndex
<
0
)
{
tabIndex
=
1
;
if
(
startContent
!
=
rootContent
)
ignoreTabIndex
=
true
;
}
if
(
frame
)
{
popupFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
frame
LayoutFrameType
:
:
MenuPopup
)
;
}
if
(
popupFrame
&
&
!
forDocumentNavigation
)
{
rootContent
=
popupFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
NS_ASSERTION
(
rootContent
"
Popup
frame
doesn
'
t
have
a
content
node
"
)
;
}
else
if
(
!
forward
)
{
if
(
startContent
=
=
rootContent
)
{
doNavigation
=
false
;
}
else
{
Document
*
doc
=
startContent
-
>
GetComposedDoc
(
)
;
if
(
startContent
=
=
nsLayoutUtils
:
:
GetEditableRootContentByContentEditable
(
doc
)
)
{
doNavigation
=
false
;
}
}
}
}
else
{
#
ifdef
MOZ_XUL
if
(
aType
!
=
MOVEFOCUS_CARET
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
popupFrame
=
pm
-
>
GetTopPopup
(
ePopupTypePanel
)
;
}
#
endif
if
(
popupFrame
)
{
startContent
=
popupFrame
-
>
GetContent
(
)
;
NS_ASSERTION
(
startContent
"
Popup
frame
doesn
'
t
have
a
content
node
"
)
;
if
(
!
forDocumentNavigation
)
{
rootContent
=
startContent
-
>
AsElement
(
)
;
}
doc
=
startContent
?
startContent
-
>
GetComposedDoc
(
)
:
nullptr
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
docShell
&
&
docShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
nsCOMPtr
<
nsIContent
>
endSelectionContent
;
GetSelectionLocation
(
doc
presShell
getter_AddRefs
(
startContent
)
getter_AddRefs
(
endSelectionContent
)
)
;
if
(
startContent
=
=
rootContent
)
{
startContent
=
nullptr
;
}
if
(
aType
=
=
MOVEFOCUS_CARET
)
{
if
(
startContent
)
{
GetFocusInSelection
(
aWindow
startContent
endSelectionContent
aNextContent
)
;
}
return
NS_OK
;
}
if
(
startContent
)
{
ignoreTabIndex
=
true
;
}
}
if
(
!
startContent
)
{
startContent
=
rootContent
;
NS_ENSURE_TRUE
(
startContent
NS_OK
)
;
}
}
}
if
(
forDocumentNavigation
&
&
nsContentUtils
:
:
IsChromeDoc
(
doc
)
)
{
nsAutoString
retarget
;
if
(
rootContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
retargetdocumentfocus
retarget
)
)
{
nsIContent
*
retargetElement
=
doc
-
>
GetElementById
(
retarget
)
;
if
(
retargetElement
&
&
(
retargetElement
=
=
startContent
|
|
(
!
retargetElement
-
>
Contains
(
startContent
)
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
startContent
retargetElement
)
)
)
)
{
startContent
=
rootContent
;
}
}
}
NS_ASSERTION
(
startContent
"
starting
content
not
set
"
)
;
bool
skipOriginalContentCheck
=
true
;
nsIContent
*
originalStartContent
=
startContent
;
LOGCONTENTNAVIGATION
(
"
Focus
Navigation
Start
Content
%
s
"
startContent
.
get
(
)
)
;
LOGFOCUSNAVIGATION
(
(
"
Forward
:
%
d
Tabindex
:
%
d
Ignore
:
%
d
DocNav
:
%
d
"
forward
tabIndex
ignoreTabIndex
forDocumentNavigation
)
)
;
while
(
doc
)
{
if
(
doNavigation
)
{
nsCOMPtr
<
nsIContent
>
nextFocus
;
nsresult
rv
=
GetNextTabbableContent
(
presShell
rootContent
skipOriginalContentCheck
?
nullptr
:
originalStartContent
startContent
forward
tabIndex
ignoreTabIndex
forDocumentNavigation
getter_AddRefs
(
nextFocus
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
rv
=
=
NS_SUCCESS_DOM_NO_OPERATION
)
{
return
NS_OK
;
}
if
(
nextFocus
)
{
LOGCONTENTNAVIGATION
(
"
Next
Content
:
%
s
"
nextFocus
.
get
(
)
)
;
if
(
nextFocus
!
=
originalStartContent
|
|
forDocumentNavigation
)
{
nextFocus
.
forget
(
aNextContent
)
;
}
return
NS_OK
;
}
if
(
popupFrame
&
&
!
forDocumentNavigation
)
{
if
(
startContent
!
=
rootContent
)
{
startContent
=
rootContent
;
tabIndex
=
forward
?
1
:
0
;
continue
;
}
return
NS_OK
;
}
}
doNavigation
=
true
;
skipOriginalContentCheck
=
forDocumentNavigation
;
ignoreTabIndex
=
false
;
if
(
aNoParentTraversal
)
{
if
(
startContent
=
=
rootContent
)
return
NS_OK
;
startContent
=
rootContent
;
tabIndex
=
forward
?
1
:
0
;
continue
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
piWindow
=
doc
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
piWindow
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
piWindow
-
>
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_FAILURE
)
;
startContent
=
piWindow
-
>
GetFrameElementInternal
(
)
;
if
(
startContent
)
{
doc
=
startContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
rootContent
=
doc
-
>
GetRootElement
(
)
;
presShell
=
doc
-
>
GetPresShell
(
)
;
mayFocusRoot
=
true
;
nsIFrame
*
frame
=
startContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
NS_OK
;
}
frame
-
>
IsFocusable
(
&
tabIndex
0
)
;
if
(
tabIndex
<
0
)
{
tabIndex
=
1
;
ignoreTabIndex
=
true
;
}
if
(
!
forDocumentNavigation
)
{
popupFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
frame
LayoutFrameType
:
:
MenuPopup
)
;
if
(
popupFrame
)
{
rootContent
=
popupFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
NS_ASSERTION
(
rootContent
"
Popup
frame
doesn
'
t
have
a
content
node
"
)
;
}
}
}
else
{
bool
tookFocus
;
docShell
-
>
TabToTreeOwner
(
forward
forDocumentNavigation
&
tookFocus
)
;
if
(
tookFocus
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docShell
-
>
GetWindow
(
)
;
if
(
window
-
>
GetFocusedElement
(
)
=
=
mFocusedElement
)
Blur
(
mFocusedWindow
nullptr
true
true
)
;
else
window
-
>
SetFocusedElement
(
nullptr
)
;
return
NS_OK
;
}
if
(
forDocumentNavigation
&
&
(
forward
|
|
mayFocusRoot
|
|
popupFrame
)
)
{
Element
*
root
=
GetRootForFocus
(
piWindow
doc
true
true
)
;
return
FocusFirst
(
root
aNextContent
)
;
}
mayFocusRoot
=
true
;
startContent
=
rootContent
;
tabIndex
=
forward
?
1
:
0
;
}
if
(
startContent
=
=
originalStartContent
)
break
;
}
return
NS_OK
;
}
uint32_t
nsFocusManager
:
:
FocusOptionsToFocusManagerFlags
(
const
mozilla
:
:
dom
:
:
FocusOptions
&
aOptions
)
{
return
aOptions
.
mPreventScroll
?
nsIFocusManager
:
:
FLAG_NOSCROLL
:
0
;
}
static
bool
IsHostOrSlot
(
const
nsIContent
*
aContent
)
{
return
aContent
&
&
(
aContent
-
>
GetShadowRoot
(
)
|
|
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
slot
)
)
;
}
class
MOZ_STACK_CLASS
ScopedContentTraversal
{
public
:
ScopedContentTraversal
(
nsIContent
*
aStartContent
nsIContent
*
aOwner
)
:
mCurrent
(
aStartContent
)
mOwner
(
aOwner
)
{
MOZ_ASSERT
(
aStartContent
)
;
}
void
Next
(
)
;
void
Prev
(
)
;
void
Reset
(
)
{
SetCurrent
(
mOwner
)
;
}
nsIContent
*
GetCurrent
(
)
const
{
return
mCurrent
;
}
private
:
void
SetCurrent
(
nsIContent
*
aContent
)
{
mCurrent
=
aContent
;
}
nsIContent
*
mCurrent
;
nsIContent
*
mOwner
;
}
;
void
ScopedContentTraversal
:
:
Next
(
)
{
MOZ_ASSERT
(
mCurrent
)
;
if
(
!
IsHostOrSlot
(
mCurrent
)
|
|
mCurrent
=
=
mOwner
)
{
StyleChildrenIterator
iter
(
mCurrent
)
;
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
if
(
child
)
{
SetCurrent
(
child
)
;
return
;
}
}
if
(
mCurrent
=
=
mOwner
)
{
SetCurrent
(
nullptr
)
;
return
;
}
nsIContent
*
current
=
mCurrent
;
while
(
1
)
{
nsIContent
*
parent
=
current
-
>
GetFlattenedTreeParent
(
)
;
StyleChildrenIterator
parentIter
(
parent
)
;
parentIter
.
Seek
(
current
)
;
if
(
nsIContent
*
next
=
parentIter
.
GetNextChild
(
)
)
{
SetCurrent
(
next
)
;
return
;
}
if
(
parent
=
=
mOwner
)
{
SetCurrent
(
nullptr
)
;
return
;
}
current
=
parent
;
}
}
void
ScopedContentTraversal
:
:
Prev
(
)
{
MOZ_ASSERT
(
mCurrent
)
;
nsIContent
*
parent
;
nsIContent
*
last
;
if
(
mCurrent
=
=
mOwner
)
{
StyleChildrenIterator
ownerIter
(
mOwner
false
)
;
last
=
ownerIter
.
GetPreviousChild
(
)
;
parent
=
last
;
}
else
{
parent
=
mCurrent
-
>
GetFlattenedTreeParent
(
)
;
StyleChildrenIterator
parentIter
(
parent
)
;
parentIter
.
Seek
(
mCurrent
)
;
last
=
parentIter
.
GetPreviousChild
(
)
;
}
while
(
last
)
{
parent
=
last
;
if
(
IsHostOrSlot
(
parent
)
)
{
break
;
}
StyleChildrenIterator
iter
(
parent
false
)
;
last
=
iter
.
GetPreviousChild
(
)
;
}
SetCurrent
(
parent
=
=
mOwner
?
nullptr
:
parent
)
;
}
static
nsIContent
*
FindOwner
(
nsIContent
*
aContent
)
{
nsIContent
*
currentContent
=
aContent
;
while
(
currentContent
)
{
nsIContent
*
parent
=
currentContent
-
>
GetFlattenedTreeParent
(
)
;
if
(
IsHostOrSlot
(
parent
)
)
{
return
parent
;
}
currentContent
=
parent
;
}
return
nullptr
;
}
static
int32_t
HostOrSlotTabIndexValue
(
const
nsIContent
*
aContent
bool
*
aIsFocusable
=
nullptr
)
{
MOZ_ASSERT
(
IsHostOrSlot
(
aContent
)
)
;
if
(
aIsFocusable
)
{
*
aIsFocusable
=
false
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
int32_t
tabIndex
;
frame
-
>
IsFocusable
(
&
tabIndex
0
)
;
*
aIsFocusable
=
tabIndex
>
=
0
;
}
}
const
nsAttrValue
*
attrVal
=
aContent
-
>
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
tabindex
)
;
if
(
!
attrVal
)
{
return
0
;
}
if
(
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
return
attrVal
-
>
GetIntegerValue
(
)
;
}
return
-
1
;
}
nsIContent
*
nsFocusManager
:
:
GetNextTabbableContentInScope
(
nsIContent
*
aOwner
nsIContent
*
aStartContent
nsIContent
*
aOriginalStartContent
bool
aForward
int32_t
aCurrentTabIndex
bool
aIgnoreTabIndex
bool
aForDocumentNavigation
bool
aSkipOwner
)
{
MOZ_ASSERT
(
IsHostOrSlot
(
aOwner
)
"
Scope
owner
should
be
host
or
slot
"
)
;
if
(
!
aSkipOwner
&
&
(
aForward
&
&
aOwner
=
=
aStartContent
)
)
{
int32_t
tabIndex
=
-
1
;
nsIFrame
*
frame
=
aOwner
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsFocusable
(
&
tabIndex
false
)
&
&
tabIndex
>
=
0
)
{
return
aOwner
;
}
}
ScopedContentTraversal
contentTraversal
(
aStartContent
aOwner
)
;
nsCOMPtr
<
nsIContent
>
iterContent
;
nsIContent
*
firstNonChromeOnly
=
aStartContent
-
>
IsInNativeAnonymousSubtree
(
)
?
aStartContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
:
nullptr
;
while
(
1
)
{
while
(
1
)
{
aForward
?
contentTraversal
.
Next
(
)
:
contentTraversal
.
Prev
(
)
;
iterContent
=
contentTraversal
.
GetCurrent
(
)
;
if
(
firstNonChromeOnly
&
&
firstNonChromeOnly
=
=
iterContent
)
{
if
(
aForward
)
{
contentTraversal
.
Next
(
)
;
}
else
{
contentTraversal
.
Prev
(
)
;
}
iterContent
=
contentTraversal
.
GetCurrent
(
)
;
}
if
(
!
iterContent
)
{
break
;
}
int32_t
tabIndex
=
0
;
if
(
iterContent
-
>
IsInNativeAnonymousSubtree
(
)
&
&
iterContent
-
>
GetPrimaryFrame
(
)
)
{
iterContent
-
>
GetPrimaryFrame
(
)
-
>
IsFocusable
(
&
tabIndex
)
;
}
else
if
(
IsHostOrSlot
(
iterContent
)
)
{
tabIndex
=
HostOrSlotTabIndexValue
(
iterContent
)
;
}
else
{
nsIFrame
*
frame
=
iterContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
continue
;
}
frame
-
>
IsFocusable
(
&
tabIndex
0
)
;
}
if
(
tabIndex
<
0
|
|
!
(
aIgnoreTabIndex
|
|
tabIndex
=
=
aCurrentTabIndex
)
)
{
continue
;
}
if
(
!
IsHostOrSlot
(
iterContent
)
)
{
nsCOMPtr
<
nsIContent
>
elementInFrame
;
bool
checkSubDocument
=
true
;
if
(
aForDocumentNavigation
&
&
TryDocumentNavigation
(
iterContent
&
checkSubDocument
getter_AddRefs
(
elementInFrame
)
)
)
{
return
elementInFrame
;
}
if
(
!
checkSubDocument
)
{
continue
;
}
if
(
TryToMoveFocusToSubDocument
(
iterContent
aOriginalStartContent
aForward
aForDocumentNavigation
getter_AddRefs
(
elementInFrame
)
)
)
{
return
elementInFrame
;
}
return
iterContent
;
}
nsIContent
*
contentToFocus
=
GetNextTabbableContentInScope
(
iterContent
iterContent
aOriginalStartContent
aForward
aForward
?
1
:
0
aIgnoreTabIndex
aForDocumentNavigation
false
)
;
if
(
contentToFocus
)
{
return
contentToFocus
;
}
}
;
if
(
aCurrentTabIndex
=
=
(
aForward
?
0
:
1
)
)
{
break
;
}
if
(
aIgnoreTabIndex
)
{
break
;
}
aCurrentTabIndex
=
GetNextTabIndex
(
aOwner
aCurrentTabIndex
aForward
)
;
contentTraversal
.
Reset
(
)
;
}
if
(
!
aSkipOwner
&
&
!
aForward
)
{
int32_t
tabIndex
=
-
1
;
nsIFrame
*
frame
=
aOwner
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsFocusable
(
&
tabIndex
false
)
&
&
tabIndex
>
=
0
)
{
return
aOwner
;
}
}
return
nullptr
;
}
nsIContent
*
nsFocusManager
:
:
GetNextTabbableContentInAncestorScopes
(
nsIContent
*
aStartOwner
nsIContent
*
*
aStartContent
nsIContent
*
aOriginalStartContent
bool
aForward
int32_t
*
aCurrentTabIndex
bool
aIgnoreTabIndex
bool
aForDocumentNavigation
)
{
MOZ_ASSERT
(
aStartOwner
=
=
FindOwner
(
*
aStartContent
)
"
aStartOWner
should
be
the
scope
owner
of
aStartContent
"
)
;
MOZ_ASSERT
(
IsHostOrSlot
(
aStartOwner
)
"
scope
owner
should
be
host
or
slot
"
)
;
nsIContent
*
owner
=
aStartOwner
;
nsIContent
*
startContent
=
*
aStartContent
;
while
(
IsHostOrSlot
(
owner
)
)
{
int32_t
tabIndex
=
0
;
if
(
IsHostOrSlot
(
startContent
)
)
{
tabIndex
=
HostOrSlotTabIndexValue
(
startContent
)
;
}
else
if
(
nsIFrame
*
frame
=
startContent
-
>
GetPrimaryFrame
(
)
)
{
frame
-
>
IsFocusable
(
&
tabIndex
)
;
}
else
{
startContent
-
>
IsFocusable
(
&
tabIndex
)
;
}
nsIContent
*
contentToFocus
=
GetNextTabbableContentInScope
(
owner
startContent
aOriginalStartContent
aForward
tabIndex
aIgnoreTabIndex
aForDocumentNavigation
false
)
;
if
(
contentToFocus
)
{
return
contentToFocus
;
}
startContent
=
owner
;
owner
=
FindOwner
(
startContent
)
;
}
*
aStartContent
=
startContent
;
*
aCurrentTabIndex
=
HostOrSlotTabIndexValue
(
startContent
)
;
return
nullptr
;
}
static
nsIContent
*
GetTopLevelScopeOwner
(
nsIContent
*
aContent
)
{
nsIContent
*
topLevelScopeOwner
=
nullptr
;
while
(
aContent
)
{
if
(
HTMLSlotElement
*
slot
=
aContent
-
>
GetAssignedSlot
(
)
)
{
aContent
=
slot
;
}
else
if
(
ShadowRoot
*
shadowRoot
=
aContent
-
>
GetContainingShadow
(
)
)
{
aContent
=
shadowRoot
-
>
Host
(
)
;
topLevelScopeOwner
=
aContent
;
}
else
{
if
(
HTMLSlotElement
:
:
FromNode
(
aContent
)
)
{
topLevelScopeOwner
=
aContent
;
}
aContent
=
aContent
-
>
GetParent
(
)
;
}
}
return
topLevelScopeOwner
;
}
nsresult
nsFocusManager
:
:
GetNextTabbableContent
(
nsIPresShell
*
aPresShell
nsIContent
*
aRootContent
nsIContent
*
aOriginalStartContent
nsIContent
*
aStartContent
bool
aForward
int32_t
aCurrentTabIndex
bool
aIgnoreTabIndex
bool
aForDocumentNavigation
nsIContent
*
*
aResultContent
)
{
*
aResultContent
=
nullptr
;
nsCOMPtr
<
nsIContent
>
startContent
=
aStartContent
;
if
(
!
startContent
)
return
NS_OK
;
nsIContent
*
currentTopLevelScopeOwner
=
GetTopLevelScopeOwner
(
aStartContent
)
;
LOGCONTENTNAVIGATION
(
"
GetNextTabbable
:
%
s
"
aStartContent
)
;
LOGFOCUSNAVIGATION
(
(
"
tabindex
:
%
d
"
aCurrentTabIndex
)
)
;
if
(
aForward
&
&
IsHostOrSlot
(
aStartContent
)
)
{
nsIContent
*
contentToFocus
=
GetNextTabbableContentInScope
(
aStartContent
aStartContent
aOriginalStartContent
aForward
aForward
?
1
:
0
aIgnoreTabIndex
aForDocumentNavigation
true
)
;
if
(
contentToFocus
)
{
NS_ADDREF
(
*
aResultContent
=
contentToFocus
)
;
return
NS_OK
;
}
}
if
(
nsIContent
*
owner
=
FindOwner
(
aStartContent
)
)
{
nsIContent
*
contentToFocus
=
GetNextTabbableContentInAncestorScopes
(
owner
&
aStartContent
aOriginalStartContent
aForward
&
aCurrentTabIndex
aIgnoreTabIndex
aForDocumentNavigation
)
;
if
(
contentToFocus
)
{
NS_ADDREF
(
*
aResultContent
=
contentToFocus
)
;
return
NS_OK
;
}
}
MOZ_ASSERT
(
!
FindOwner
(
aStartContent
)
"
aStartContent
should
not
be
owned
by
Shadow
DOM
at
this
point
"
)
;
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
bool
getNextFrame
=
true
;
nsCOMPtr
<
nsIContent
>
iterStartContent
=
aStartContent
;
while
(
1
)
{
nsIFrame
*
frame
=
iterStartContent
-
>
GetPrimaryFrame
(
)
;
while
(
!
frame
)
{
if
(
iterStartContent
=
=
aRootContent
)
{
return
NS_OK
;
}
iterStartContent
=
aForward
?
iterStartContent
-
>
GetNextNode
(
)
:
iterStartContent
-
>
GetPreviousContent
(
)
;
if
(
!
iterStartContent
)
{
break
;
}
frame
=
iterStartContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
&
&
iterStartContent
-
>
GetShadowRoot
(
)
)
{
int32_t
tabIndex
=
HostOrSlotTabIndexValue
(
iterStartContent
)
;
if
(
tabIndex
>
=
0
&
&
(
aIgnoreTabIndex
|
|
aCurrentTabIndex
=
=
tabIndex
)
)
{
nsIContent
*
contentToFocus
=
GetNextTabbableContentInScope
(
iterStartContent
iterStartContent
aOriginalStartContent
aForward
aForward
?
1
:
0
aIgnoreTabIndex
aForDocumentNavigation
true
)
;
if
(
contentToFocus
)
{
NS_ADDREF
(
*
aResultContent
=
contentToFocus
)
;
return
NS_OK
;
}
}
}
getNextFrame
=
false
;
}
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
if
(
frame
)
{
nsresult
rv
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
presContext
frame
ePreOrder
false
false
true
aForDocumentNavigation
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
iterStartContent
=
=
aRootContent
)
{
if
(
!
aForward
)
{
frameTraversal
-
>
Last
(
)
;
}
else
if
(
aRootContent
-
>
IsFocusable
(
)
)
{
frameTraversal
-
>
Next
(
)
;
}
frame
=
static_cast
<
nsIFrame
*
>
(
frameTraversal
-
>
CurrentItem
(
)
)
;
}
else
if
(
getNextFrame
&
&
(
!
iterStartContent
|
|
!
iterStartContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
)
{
if
(
aForward
)
{
frameTraversal
-
>
Next
(
)
;
}
else
{
frameTraversal
-
>
Prev
(
)
;
}
frame
=
static_cast
<
nsIFrame
*
>
(
frameTraversal
-
>
CurrentItem
(
)
)
;
}
}
while
(
frame
)
{
nsIContent
*
currentContent
=
frame
-
>
GetContent
(
)
;
nsIContent
*
oldTopLevelScopeOwner
=
currentTopLevelScopeOwner
;
if
(
oldTopLevelScopeOwner
!
=
currentContent
)
{
currentTopLevelScopeOwner
=
GetTopLevelScopeOwner
(
currentContent
)
;
}
else
{
currentTopLevelScopeOwner
=
currentContent
;
}
if
(
currentTopLevelScopeOwner
)
{
if
(
currentTopLevelScopeOwner
=
=
oldTopLevelScopeOwner
)
{
do
{
if
(
aForward
)
{
frameTraversal
-
>
Next
(
)
;
}
else
{
frameTraversal
-
>
Prev
(
)
;
}
frame
=
static_cast
<
nsIFrame
*
>
(
frameTraversal
-
>
CurrentItem
(
)
)
;
}
while
(
frame
&
&
frame
-
>
GetPrevContinuation
(
)
)
;
continue
;
}
currentContent
=
currentTopLevelScopeOwner
;
}
if
(
aForDocumentNavigation
&
&
currentContent
&
&
(
aCurrentTabIndex
=
=
0
)
&
&
currentContent
-
>
IsXULElement
(
nsGkAtoms
:
:
panel
)
)
{
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
frame
)
;
if
(
popupFrame
&
&
popupFrame
-
>
IsOpen
(
)
)
{
bool
validPopup
=
true
;
if
(
!
aForward
)
{
nsIContent
*
content
=
aStartContent
;
while
(
content
)
{
if
(
content
=
=
currentContent
)
{
validPopup
=
false
;
break
;
}
content
=
content
-
>
GetParent
(
)
;
}
}
if
(
validPopup
)
{
nsresult
rv
=
GetNextTabbableContent
(
aPresShell
currentContent
nullptr
currentContent
true
1
false
false
aResultContent
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
*
aResultContent
)
{
return
rv
;
}
}
}
}
if
(
IsHostOrSlot
(
currentContent
)
)
{
bool
focusableHostSlot
;
int32_t
tabIndex
=
HostOrSlotTabIndexValue
(
currentContent
&
focusableHostSlot
)
;
if
(
(
!
aForward
|
|
!
focusableHostSlot
)
&
&
tabIndex
>
=
0
&
&
(
aIgnoreTabIndex
|
|
aCurrentTabIndex
=
=
tabIndex
)
)
{
nsIContent
*
contentToFocus
=
GetNextTabbableContentInScope
(
currentContent
currentContent
aOriginalStartContent
aForward
aForward
?
1
:
0
aIgnoreTabIndex
aForDocumentNavigation
true
)
;
if
(
contentToFocus
)
{
NS_ADDREF
(
*
aResultContent
=
contentToFocus
)
;
return
NS_OK
;
}
}
}
int32_t
tabIndex
;
frame
-
>
IsFocusable
(
&
tabIndex
0
)
;
LOGCONTENTNAVIGATION
(
"
Next
Tabbable
%
s
:
"
frame
-
>
GetContent
(
)
)
;
LOGFOCUSNAVIGATION
(
(
"
with
tabindex
:
%
d
expected
:
%
d
"
tabIndex
aCurrentTabIndex
)
)
;
if
(
tabIndex
>
=
0
)
{
NS_ASSERTION
(
currentContent
"
IsFocusable
set
a
tabindex
for
a
frame
with
no
content
"
)
;
if
(
!
aForDocumentNavigation
&
&
currentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
&
&
currentContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
usemap
)
)
{
nsIContent
*
areaContent
=
GetNextTabbableMapArea
(
aForward
aCurrentTabIndex
currentContent
-
>
AsElement
(
)
iterStartContent
)
;
if
(
areaContent
)
{
NS_ADDREF
(
*
aResultContent
=
areaContent
)
;
return
NS_OK
;
}
}
else
if
(
aIgnoreTabIndex
|
|
aCurrentTabIndex
=
=
tabIndex
)
{
if
(
aOriginalStartContent
&
&
currentContent
=
=
aOriginalStartContent
)
{
NS_ADDREF
(
*
aResultContent
=
currentContent
)
;
return
NS_OK
;
}
BrowserParent
*
remote
=
BrowserParent
:
:
GetFrom
(
currentContent
)
;
if
(
remote
)
{
remote
-
>
NavigateByKey
(
aForward
aForDocumentNavigation
)
;
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
BrowserBridgeChild
*
bbc
=
BrowserBridgeChild
:
:
GetFrom
(
currentContent
)
;
if
(
bbc
)
{
bbc
-
>
NavigateByKey
(
aForward
aForDocumentNavigation
)
;
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
bool
checkSubDocument
=
true
;
if
(
aForDocumentNavigation
&
&
TryDocumentNavigation
(
currentContent
&
checkSubDocument
aResultContent
)
)
{
return
NS_OK
;
}
if
(
checkSubDocument
)
{
if
(
TryToMoveFocusToSubDocument
(
currentContent
aOriginalStartContent
aForward
aForDocumentNavigation
aResultContent
)
)
{
MOZ_ASSERT
(
*
aResultContent
)
;
return
NS_OK
;
}
else
if
(
currentContent
=
=
aRootContent
|
|
(
currentContent
!
=
startContent
&
&
(
aForward
|
|
!
GetRedirectedFocus
(
currentContent
)
)
)
)
{
NS_ADDREF
(
*
aResultContent
=
currentContent
)
;
return
NS_OK
;
}
}
}
}
else
if
(
aOriginalStartContent
&
&
currentContent
=
=
aOriginalStartContent
)
{
NS_ADDREF
(
*
aResultContent
=
currentContent
)
;
return
NS_OK
;
}
do
{
if
(
aForward
)
frameTraversal
-
>
Next
(
)
;
else
frameTraversal
-
>
Prev
(
)
;
frame
=
static_cast
<
nsIFrame
*
>
(
frameTraversal
-
>
CurrentItem
(
)
)
;
}
while
(
frame
&
&
frame
-
>
GetPrevContinuation
(
)
)
;
}
if
(
aCurrentTabIndex
=
=
(
aForward
?
0
:
1
)
)
{
if
(
!
aForward
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetCurrentWindow
(
aRootContent
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_FAILURE
)
;
RefPtr
<
Element
>
docRoot
=
GetRootForFocus
(
window
aRootContent
-
>
GetComposedDoc
(
)
false
true
)
;
FocusFirst
(
docRoot
aResultContent
)
;
}
break
;
}
aCurrentTabIndex
=
GetNextTabIndex
(
aRootContent
aCurrentTabIndex
aForward
)
;
startContent
=
iterStartContent
=
aRootContent
;
}
return
NS_OK
;
}
bool
nsFocusManager
:
:
TryDocumentNavigation
(
nsIContent
*
aCurrentContent
bool
*
aCheckSubDocument
nsIContent
*
*
aResultContent
)
{
*
aCheckSubDocument
=
true
;
Element
*
docRoot
=
GetRootForChildDocument
(
aCurrentContent
)
;
if
(
docRoot
)
{
if
(
!
docRoot
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frameset
)
)
{
*
aCheckSubDocument
=
false
;
Unused
<
<
FocusFirst
(
docRoot
aResultContent
)
;
return
*
aResultContent
!
=
nullptr
;
}
}
else
{
*
aCheckSubDocument
=
false
;
}
return
false
;
}
bool
nsFocusManager
:
:
TryToMoveFocusToSubDocument
(
nsIContent
*
aCurrentContent
nsIContent
*
aOriginalStartContent
bool
aForward
bool
aForDocumentNavigation
nsIContent
*
*
aResultContent
)
{
Document
*
doc
=
aCurrentContent
-
>
GetComposedDoc
(
)
;
NS_ASSERTION
(
doc
"
content
not
in
document
"
)
;
Document
*
subdoc
=
doc
-
>
GetSubDocumentFor
(
aCurrentContent
)
;
if
(
subdoc
&
&
!
subdoc
-
>
EventHandlingSuppressed
(
)
)
{
if
(
aForward
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
subframe
=
subdoc
-
>
GetWindow
(
)
;
if
(
subframe
)
{
*
aResultContent
=
GetRootForFocus
(
subframe
subdoc
false
true
)
;
if
(
*
aResultContent
)
{
NS_ADDREF
(
*
aResultContent
)
;
return
true
;
}
}
}
Element
*
rootElement
=
subdoc
-
>
GetRootElement
(
)
;
PresShell
*
subPresShell
=
subdoc
-
>
GetPresShell
(
)
;
if
(
rootElement
&
&
subPresShell
)
{
nsresult
rv
=
GetNextTabbableContent
(
subPresShell
rootElement
aOriginalStartContent
rootElement
aForward
(
aForward
?
1
:
0
)
false
aForDocumentNavigation
aResultContent
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
*
aResultContent
)
{
return
true
;
}
}
}
return
false
;
}
nsIContent
*
nsFocusManager
:
:
GetNextTabbableMapArea
(
bool
aForward
int32_t
aCurrentTabIndex
Element
*
aImageContent
nsIContent
*
aStartContent
)
{
if
(
aImageContent
-
>
IsInComposedDoc
(
)
)
{
HTMLImageElement
*
imgElement
=
HTMLImageElement
:
:
FromNode
(
aImageContent
)
;
MOZ_ASSERT
(
imgElement
)
;
nsCOMPtr
<
nsIContent
>
mapContent
=
imgElement
-
>
FindImageMap
(
)
;
if
(
!
mapContent
)
return
nullptr
;
uint32_t
count
=
mapContent
-
>
GetChildCount
(
)
;
int32_t
index
=
mapContent
-
>
ComputeIndexOf
(
aStartContent
)
;
int32_t
tabIndex
;
if
(
index
<
0
|
|
(
aStartContent
-
>
IsFocusable
(
&
tabIndex
)
&
&
tabIndex
!
=
aCurrentTabIndex
)
)
{
index
=
aForward
?
-
1
:
(
int32_t
)
count
;
}
nsCOMPtr
<
nsIContent
>
areaContent
;
while
(
(
areaContent
=
mapContent
-
>
GetChildAt_Deprecated
(
aForward
?
+
+
index
:
-
-
index
)
)
!
=
nullptr
)
{
if
(
areaContent
-
>
IsFocusable
(
&
tabIndex
)
&
&
tabIndex
=
=
aCurrentTabIndex
)
{
return
areaContent
;
}
}
}
return
nullptr
;
}
int32_t
nsFocusManager
:
:
GetNextTabIndex
(
nsIContent
*
aParent
int32_t
aCurrentTabIndex
bool
aForward
)
{
int32_t
tabIndex
childTabIndex
;
StyleChildrenIterator
iter
(
aParent
)
;
if
(
aForward
)
{
tabIndex
=
0
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
if
(
!
IsHostOrSlot
(
child
)
)
{
childTabIndex
=
GetNextTabIndex
(
child
aCurrentTabIndex
aForward
)
;
if
(
childTabIndex
>
aCurrentTabIndex
&
&
childTabIndex
!
=
tabIndex
)
{
tabIndex
=
(
tabIndex
=
=
0
|
|
childTabIndex
<
tabIndex
)
?
childTabIndex
:
tabIndex
;
}
}
nsAutoString
tabIndexStr
;
if
(
child
-
>
IsElement
(
)
)
{
child
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
tabIndexStr
)
;
}
nsresult
ec
;
int32_t
val
=
tabIndexStr
.
ToInteger
(
&
ec
)
;
if
(
NS_SUCCEEDED
(
ec
)
&
&
val
>
aCurrentTabIndex
&
&
val
!
=
tabIndex
)
{
tabIndex
=
(
tabIndex
=
=
0
|
|
val
<
tabIndex
)
?
val
:
tabIndex
;
}
}
}
else
{
tabIndex
=
1
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
if
(
!
IsHostOrSlot
(
child
)
)
{
childTabIndex
=
GetNextTabIndex
(
child
aCurrentTabIndex
aForward
)
;
if
(
(
aCurrentTabIndex
=
=
0
&
&
childTabIndex
>
tabIndex
)
|
|
(
childTabIndex
<
aCurrentTabIndex
&
&
childTabIndex
>
tabIndex
)
)
{
tabIndex
=
childTabIndex
;
}
}
nsAutoString
tabIndexStr
;
if
(
child
-
>
IsElement
(
)
)
{
child
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
tabIndexStr
)
;
}
nsresult
ec
;
int32_t
val
=
tabIndexStr
.
ToInteger
(
&
ec
)
;
if
(
NS_SUCCEEDED
(
ec
)
)
{
if
(
(
aCurrentTabIndex
=
=
0
&
&
val
>
tabIndex
)
|
|
(
val
<
aCurrentTabIndex
&
&
val
>
tabIndex
)
)
{
tabIndex
=
val
;
}
}
}
}
return
tabIndex
;
}
nsresult
nsFocusManager
:
:
FocusFirst
(
Element
*
aRootElement
nsIContent
*
*
aNextContent
)
{
if
(
!
aRootElement
)
{
return
NS_OK
;
}
Document
*
doc
=
aRootElement
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
if
(
nsContentUtils
:
:
IsChromeDoc
(
doc
)
)
{
nsAutoString
retarget
;
if
(
aRootElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
retargetdocumentfocus
retarget
)
)
{
nsCOMPtr
<
Element
>
element
=
doc
-
>
GetElementById
(
retarget
)
;
nsCOMPtr
<
nsIContent
>
retargetElement
=
FlushAndCheckIfFocusable
(
element
0
)
;
if
(
retargetElement
)
{
retargetElement
.
forget
(
aNextContent
)
;
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
doc
-
>
GetDocShell
(
)
;
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
return
GetNextTabbableContent
(
presShell
aRootElement
nullptr
aRootElement
true
1
false
false
aNextContent
)
;
}
}
}
NS_ADDREF
(
*
aNextContent
=
aRootElement
)
;
return
NS_OK
;
}
Element
*
nsFocusManager
:
:
GetRootForFocus
(
nsPIDOMWindowOuter
*
aWindow
Document
*
aDocument
bool
aForDocumentNavigation
bool
aCheckVisibility
)
{
if
(
!
aForDocumentNavigation
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
nullptr
;
}
}
if
(
aCheckVisibility
&
&
!
IsWindowVisible
(
aWindow
)
)
return
nullptr
;
RefPtr
<
Element
>
rootElement
=
nsLayoutUtils
:
:
GetEditableRootContentByContentEditable
(
aDocument
)
;
if
(
!
rootElement
|
|
!
rootElement
-
>
GetPrimaryFrame
(
)
)
{
rootElement
=
aDocument
-
>
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
nullptr
;
}
}
if
(
aCheckVisibility
&
&
!
rootElement
-
>
GetPrimaryFrame
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
aDocument
)
;
if
(
htmlDoc
)
{
Element
*
htmlChild
=
aDocument
-
>
GetHtmlChildElement
(
nsGkAtoms
:
:
frameset
)
;
if
(
htmlChild
)
{
return
aForDocumentNavigation
?
htmlChild
:
nullptr
;
}
}
return
rootElement
;
}
Element
*
nsFocusManager
:
:
GetRootForChildDocument
(
nsIContent
*
aContent
)
{
if
(
!
aContent
|
|
!
(
aContent
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
|
|
aContent
-
>
IsXULElement
(
nsGkAtoms
:
:
editor
)
|
|
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frame
)
)
)
{
return
nullptr
;
}
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
Document
*
subdoc
=
doc
-
>
GetSubDocumentFor
(
aContent
)
;
if
(
!
subdoc
|
|
subdoc
-
>
EventHandlingSuppressed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
subdoc
-
>
GetWindow
(
)
;
return
GetRootForFocus
(
window
subdoc
true
true
)
;
}
void
nsFocusManager
:
:
GetFocusInSelection
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aStartSelection
nsIContent
*
aEndSelection
nsIContent
*
*
aFocusedContent
)
{
*
aFocusedContent
=
nullptr
;
nsCOMPtr
<
nsIContent
>
testContent
=
aStartSelection
;
nsCOMPtr
<
nsIContent
>
nextTestContent
=
aEndSelection
;
nsCOMPtr
<
nsIContent
>
currentFocus
=
aWindow
-
>
GetFocusedElement
(
)
;
while
(
testContent
)
{
nsCOMPtr
<
nsIURI
>
uri
;
if
(
testContent
=
=
currentFocus
|
|
testContent
-
>
IsLink
(
getter_AddRefs
(
uri
)
)
)
{
testContent
.
forget
(
aFocusedContent
)
;
return
;
}
testContent
=
testContent
-
>
GetParent
(
)
;
if
(
!
testContent
)
{
testContent
=
nextTestContent
;
nextTestContent
=
nullptr
;
}
}
nsCOMPtr
<
nsIContent
>
selectionNode
=
aStartSelection
;
nsCOMPtr
<
nsIContent
>
endSelectionNode
=
aEndSelection
;
nsCOMPtr
<
nsIContent
>
testNode
;
do
{
testContent
=
selectionNode
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
testContent
=
=
currentFocus
|
|
testContent
-
>
IsLink
(
getter_AddRefs
(
uri
)
)
)
{
testContent
.
forget
(
aFocusedContent
)
;
return
;
}
nsIContent
*
testNode
=
selectionNode
-
>
GetFirstChild
(
)
;
if
(
testNode
)
{
selectionNode
=
testNode
;
continue
;
}
if
(
selectionNode
=
=
endSelectionNode
)
break
;
testNode
=
selectionNode
-
>
GetNextSibling
(
)
;
if
(
testNode
)
{
selectionNode
=
testNode
;
continue
;
}
do
{
testNode
=
selectionNode
-
>
GetParent
(
)
;
if
(
!
testNode
|
|
testNode
=
=
endSelectionNode
)
{
selectionNode
=
nullptr
;
break
;
}
selectionNode
=
testNode
-
>
GetNextSibling
(
)
;
if
(
selectionNode
)
break
;
selectionNode
=
testNode
;
}
while
(
true
)
;
}
while
(
selectionNode
&
&
selectionNode
!
=
endSelectionNode
)
;
}
class
PointerUnlocker
:
public
Runnable
{
public
:
PointerUnlocker
(
)
:
mozilla
:
:
Runnable
(
"
PointerUnlocker
"
)
{
MOZ_ASSERT
(
!
PointerUnlocker
:
:
sActiveUnlocker
)
;
PointerUnlocker
:
:
sActiveUnlocker
=
this
;
}
~
PointerUnlocker
(
)
{
if
(
PointerUnlocker
:
:
sActiveUnlocker
=
=
this
)
{
PointerUnlocker
:
:
sActiveUnlocker
=
nullptr
;
}
}
NS_IMETHOD
Run
(
)
override
{
if
(
PointerUnlocker
:
:
sActiveUnlocker
=
=
this
)
{
PointerUnlocker
:
:
sActiveUnlocker
=
nullptr
;
}
NS_ENSURE_STATE
(
nsFocusManager
:
:
GetFocusManager
(
)
)
;
nsPIDOMWindowOuter
*
focused
=
nsFocusManager
:
:
GetFocusManager
(
)
-
>
GetFocusedWindow
(
)
;
nsCOMPtr
<
Document
>
pointerLockedDoc
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedDoc
)
;
if
(
pointerLockedDoc
&
&
!
nsContentUtils
:
:
IsInPointerLockContext
(
focused
)
)
{
Document
:
:
UnlockPointer
(
)
;
}
return
NS_OK
;
}
static
PointerUnlocker
*
sActiveUnlocker
;
}
;
PointerUnlocker
*
PointerUnlocker
:
:
sActiveUnlocker
=
nullptr
;
void
nsFocusManager
:
:
SetFocusedWindowInternal
(
nsPIDOMWindowOuter
*
aWindow
)
{
if
(
!
PointerUnlocker
:
:
sActiveUnlocker
&
&
nsContentUtils
:
:
IsInPointerLockContext
(
mFocusedWindow
)
&
&
!
nsContentUtils
:
:
IsInPointerLockContext
(
aWindow
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
PointerUnlocker
(
)
;
NS_DispatchToCurrentThread
(
runnable
)
;
}
if
(
aWindow
&
&
aWindow
!
=
mFocusedWindow
)
{
const
TimeStamp
now
(
TimeStamp
:
:
Now
(
)
)
;
for
(
Document
*
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
doc
;
doc
=
doc
-
>
GetParentDocument
(
)
)
{
doc
-
>
SetLastFocusTime
(
now
)
;
}
}
mFocusedWindow
=
aWindow
;
}
void
nsFocusManager
:
:
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
if
(
!
sInstance
)
{
return
;
}
if
(
sInstance
-
>
mActiveWindow
)
{
sInstance
-
>
mActiveWindow
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
if
(
sInstance
-
>
mFocusedWindow
)
{
sInstance
-
>
mFocusedWindow
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
if
(
sInstance
-
>
mWindowBeingLowered
)
{
sInstance
-
>
mWindowBeingLowered
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
if
(
sInstance
-
>
mFocusedElement
)
{
sInstance
-
>
mFocusedElement
-
>
OwnerDoc
(
)
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
if
(
sInstance
-
>
mFirstBlurEvent
)
{
sInstance
-
>
mFirstBlurEvent
-
>
OwnerDoc
(
)
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
if
(
sInstance
-
>
mFirstFocusEvent
)
{
sInstance
-
>
mFirstFocusEvent
-
>
OwnerDoc
(
)
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
if
(
sInstance
-
>
mMouseButtonEventHandlingDocument
)
{
sInstance
-
>
mMouseButtonEventHandlingDocument
-
>
MarkUncollectableForCCGeneration
(
aGeneration
)
;
}
}
bool
nsFocusManager
:
:
CanSkipFocus
(
nsIContent
*
aContent
)
{
if
(
!
aContent
|
|
nsContentUtils
:
:
IsChromeDoc
(
aContent
-
>
OwnerDoc
(
)
)
)
{
return
false
;
}
if
(
mFocusedElement
=
=
aContent
)
{
return
true
;
}
nsIDocShell
*
ds
=
aContent
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
!
ds
)
{
return
true
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
ds
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
newRootWindow
=
root
?
root
-
>
GetWindow
(
)
:
nullptr
;
if
(
mActiveWindow
!
=
newRootWindow
)
{
nsPIDOMWindowOuter
*
outerWindow
=
aContent
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
;
if
(
outerWindow
&
&
outerWindow
-
>
GetFocusedElement
(
)
=
=
aContent
)
{
return
true
;
}
}
return
false
;
}
nsresult
NS_NewFocusManager
(
nsIFocusManager
*
*
aResult
)
{
NS_IF_ADDREF
(
*
aResult
=
nsFocusManager
:
:
GetFocusManager
(
)
)
;
return
NS_OK
;
}
