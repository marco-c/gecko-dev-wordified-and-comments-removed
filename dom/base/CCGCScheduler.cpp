#
include
"
CCGCScheduler
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsRefreshDriver
.
h
"
namespace
mozilla
{
void
CCGCScheduler
:
:
NoteGCBegin
(
)
{
mInIncrementalGC
=
true
;
mReadyForMajorGC
=
false
;
using
mozilla
:
:
ipc
:
:
IdleSchedulerChild
;
IdleSchedulerChild
*
child
=
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
child
)
{
child
-
>
StartedGC
(
)
;
}
}
void
CCGCScheduler
:
:
NoteGCEnd
(
)
{
mMajorGCReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
mInIncrementalGC
=
false
;
mCCBlockStart
=
TimeStamp
(
)
;
mReadyForMajorGC
=
false
;
mWantAtLeastRegularGC
=
false
;
mNeedsFullCC
=
CCReason
:
:
GC_FINISHED
;
mHasRunGC
=
true
;
mIsCompactingOnUserInactive
=
false
;
mCleanupsSinceLastGC
=
0
;
mCCollectedWaitingForGC
=
0
;
mCCollectedZonesWaitingForGC
=
0
;
mLikelyShortLivingObjectsNeedingGC
=
0
;
using
mozilla
:
:
ipc
:
:
IdleSchedulerChild
;
IdleSchedulerChild
*
child
=
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
child
)
{
child
-
>
DoneGC
(
)
;
}
}
#
ifdef
MOZ_GECKO_PROFILER
struct
CCIntervalMarker
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
CC
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
const
mozilla
:
:
ProfilerString8View
&
aReason
)
{
if
(
aReason
.
Length
(
)
)
{
aWriter
.
StringProperty
(
"
reason
"
aReason
)
;
}
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
mozilla
:
:
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
MS
:
:
Location
:
:
TimelineMemory
}
;
schema
.
AddStaticLabelValue
(
"
Description
"
"
Summary
data
for
the
core
part
of
a
cycle
collection
possibly
"
"
encompassing
a
set
of
incremental
slices
.
The
main
thread
is
not
"
"
blocked
for
the
entire
major
CC
interval
only
for
the
individual
"
"
slices
.
"
)
;
schema
.
AddKeyLabelFormatSearchable
(
"
reason
"
"
Reason
"
MS
:
:
Format
:
:
String
MS
:
:
Searchable
:
:
Searchable
)
;
return
schema
;
}
}
;
#
endif
void
CCGCScheduler
:
:
NoteCCBegin
(
CCReason
aReason
TimeStamp
aWhen
)
{
#
ifdef
MOZ_GECKO_PROFILER
profiler_add_marker
(
"
CC
"
baseprofiler
:
:
category
:
:
GCCC
MarkerOptions
(
MarkerTiming
:
:
IntervalStart
(
aWhen
)
)
CCIntervalMarker
{
}
ProfilerString8View
:
:
WrapNullTerminatedString
(
CCReasonToString
(
aReason
)
)
)
;
#
endif
mIsCollectingCycles
=
true
;
}
void
CCGCScheduler
:
:
NoteCCEnd
(
TimeStamp
aWhen
)
{
#
ifdef
MOZ_GECKO_PROFILER
profiler_add_marker
(
"
CC
"
baseprofiler
:
:
category
:
:
GCCC
MarkerOptions
(
MarkerTiming
:
:
IntervalEnd
(
aWhen
)
)
CCIntervalMarker
{
}
nullptr
)
;
#
endif
mIsCollectingCycles
=
false
;
mLastCCEndTime
=
aWhen
;
mNeedsFullCC
=
CCReason
:
:
NO_REASON
;
mNeedsGCAfterCC
=
false
;
}
void
CCGCScheduler
:
:
NoteWontGC
(
)
{
mReadyForMajorGC
=
false
;
mMajorGCReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
mWantAtLeastRegularGC
=
false
;
}
bool
CCGCScheduler
:
:
GCRunnerFired
(
TimeStamp
aDeadline
)
{
MOZ_ASSERT
(
!
mDidShutdown
"
GCRunner
still
alive
during
shutdown
"
)
;
GCRunnerStep
step
=
GetNextGCRunnerAction
(
)
;
switch
(
step
.
mAction
)
{
case
GCRunnerAction
:
:
None
:
MOZ_CRASH
(
"
Unexpected
GCRunnerAction
"
)
;
case
GCRunnerAction
:
:
WaitToMajorGC
:
{
MOZ_ASSERT
(
!
mHaveAskedParent
"
GCRunner
alive
after
asking
the
parent
"
)
;
RefPtr
<
CCGCScheduler
:
:
MayGCPromise
>
mbPromise
=
CCGCScheduler
:
:
MayGCNow
(
step
.
mReason
)
;
if
(
!
mbPromise
)
{
break
;
}
mHaveAskedParent
=
true
;
KillGCRunner
(
)
;
mbPromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
this
]
(
bool
aMayGC
)
{
mHaveAskedParent
=
false
;
if
(
aMayGC
)
{
if
(
!
NoteReadyForMajorGC
(
)
)
{
return
;
}
KillGCRunner
(
)
;
EnsureGCRunner
(
0
)
;
}
else
if
(
!
InIncrementalGC
(
)
)
{
KillGCRunner
(
)
;
NoteWontGC
(
)
;
}
}
[
this
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
r
)
{
mHaveAskedParent
=
false
;
if
(
!
InIncrementalGC
(
)
)
{
KillGCRunner
(
)
;
NoteWontGC
(
)
;
}
}
)
;
return
true
;
}
case
GCRunnerAction
:
:
StartMajorGC
:
case
GCRunnerAction
:
:
GCSlice
:
break
;
}
return
GCRunnerFiredDoGC
(
aDeadline
step
)
;
}
bool
CCGCScheduler
:
:
GCRunnerFiredDoGC
(
TimeStamp
aDeadline
const
GCRunnerStep
&
aStep
)
{
nsJSContext
:
:
IsShrinking
is_shrinking
=
nsJSContext
:
:
NonShrinkingGC
;
if
(
!
InIncrementalGC
(
)
&
&
aStep
.
mReason
=
=
JS
:
:
GCReason
:
:
USER_INACTIVE
)
{
bool
do_gc
=
mWantAtLeastRegularGC
;
if
(
!
mUserIsActive
)
{
if
(
!
nsRefreshDriver
:
:
IsRegularRateTimerTicking
(
)
)
{
mIsCompactingOnUserInactive
=
true
;
is_shrinking
=
nsJSContext
:
:
ShrinkingGC
;
do_gc
=
true
;
}
else
{
PokeShrinkingGC
(
)
;
}
}
if
(
!
do_gc
)
{
using
mozilla
:
:
ipc
:
:
IdleSchedulerChild
;
IdleSchedulerChild
*
child
=
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
child
)
{
child
-
>
DoneGC
(
)
;
}
NoteWontGC
(
)
;
KillGCRunner
(
)
;
return
true
;
}
}
MOZ_ASSERT
(
mActiveIntersliceGCBudget
)
;
TimeStamp
startTimeStamp
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
budget
=
ComputeInterSliceGCBudget
(
aDeadline
startTimeStamp
)
;
TimeDuration
duration
=
mGCUnnotifiedTotalTime
;
nsJSContext
:
:
GarbageCollectNow
(
aStep
.
mReason
nsJSContext
:
:
IncrementalGC
is_shrinking
budget
.
ToMilliseconds
(
)
)
;
mGCUnnotifiedTotalTime
=
TimeDuration
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
sliceDuration
=
now
-
startTimeStamp
;
duration
+
=
sliceDuration
;
if
(
duration
.
ToSeconds
(
)
)
{
TimeDuration
idleDuration
;
if
(
!
aDeadline
.
IsNull
(
)
)
{
if
(
aDeadline
<
now
)
{
idleDuration
=
aDeadline
-
startTimeStamp
;
}
else
{
idleDuration
=
sliceDuration
;
}
}
uint32_t
percent
=
uint32_t
(
idleDuration
.
ToSeconds
(
)
/
duration
.
ToSeconds
(
)
*
100
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SLICE_DURING_IDLE
percent
)
;
}
JSContext
*
cx
=
dom
:
:
danger
:
:
GetJSContext
(
)
;
return
JS
:
:
IncrementalGCHasForegroundWork
(
cx
)
;
}
RefPtr
<
CCGCScheduler
:
:
MayGCPromise
>
CCGCScheduler
:
:
MayGCNow
(
JS
:
:
GCReason
reason
)
{
using
namespace
mozilla
:
:
ipc
;
switch
(
reason
)
{
case
JS
:
:
GCReason
:
:
PAGE_HIDE
:
case
JS
:
:
GCReason
:
:
MEM_PRESSURE
:
case
JS
:
:
GCReason
:
:
USER_INACTIVE
:
case
JS
:
:
GCReason
:
:
FULL_GC_TIMER
:
case
JS
:
:
GCReason
:
:
CC_FINISHED
:
{
if
(
XRE_IsContentProcess
(
)
)
{
IdleSchedulerChild
*
child
=
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
child
)
{
return
child
-
>
MayGCNow
(
)
;
}
}
break
;
}
default
:
break
;
}
return
MayGCPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
void
CCGCScheduler
:
:
RunNextCollectorTimer
(
JS
:
:
GCReason
aReason
mozilla
:
:
TimeStamp
aDeadline
)
{
if
(
mDidShutdown
)
{
return
;
}
MOZ_ASSERT_IF
(
InIncrementalGC
(
)
mGCRunner
)
;
RefPtr
<
IdleTaskRunner
>
runner
;
if
(
mGCRunner
)
{
SetWantMajorGC
(
aReason
)
;
runner
=
mGCRunner
;
}
else
if
(
mCCRunner
)
{
runner
=
mCCRunner
;
}
if
(
runner
)
{
runner
-
>
SetIdleDeadline
(
aDeadline
)
;
runner
-
>
Run
(
)
;
}
}
void
CCGCScheduler
:
:
PokeShrinkingGC
(
)
{
if
(
mShrinkingGCTimer
|
|
mDidShutdown
)
{
return
;
}
NS_NewTimerWithFuncCallback
(
&
mShrinkingGCTimer
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
CCGCScheduler
*
s
=
static_cast
<
CCGCScheduler
*
>
(
aClosure
)
;
s
-
>
KillShrinkingGCTimer
(
)
;
if
(
!
s
-
>
mUserIsActive
)
{
if
(
!
nsRefreshDriver
:
:
IsRegularRateTimerTicking
(
)
)
{
s
-
>
SetWantMajorGC
(
JS
:
:
GCReason
:
:
USER_INACTIVE
)
;
if
(
!
s
-
>
mHaveAskedParent
)
{
s
-
>
EnsureGCRunner
(
0
)
;
}
}
else
{
s
-
>
PokeShrinkingGC
(
)
;
}
}
}
this
StaticPrefs
:
:
javascript_options_compact_on_user_inactive_delay
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
ShrinkingGCTimerFired
"
)
;
}
void
CCGCScheduler
:
:
PokeFullGC
(
)
{
if
(
!
mFullGCTimer
&
&
!
mDidShutdown
)
{
NS_NewTimerWithFuncCallback
(
&
mFullGCTimer
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
CCGCScheduler
*
s
=
static_cast
<
CCGCScheduler
*
>
(
aClosure
)
;
s
-
>
KillFullGCTimer
(
)
;
s
-
>
SetNeedsFullGC
(
)
;
s
-
>
SetWantMajorGC
(
JS
:
:
GCReason
:
:
FULL_GC_TIMER
)
;
if
(
!
s
-
>
mHaveAskedParent
)
{
s
-
>
EnsureGCRunner
(
0
)
;
}
}
this
StaticPrefs
:
:
javascript_options_gc_delay_full
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
FullGCTimerFired
"
)
;
}
}
void
CCGCScheduler
:
:
PokeGC
(
JS
:
:
GCReason
aReason
JSObject
*
aObj
TimeDuration
aDelay
)
{
if
(
mDidShutdown
)
{
return
;
}
if
(
aObj
)
{
JS
:
:
Zone
*
zone
=
JS
:
:
GetObjectZone
(
aObj
)
;
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
AddZoneWaitingForGC
(
zone
)
;
}
else
if
(
aReason
!
=
JS
:
:
GCReason
:
:
CC_FINISHED
)
{
SetNeedsFullGC
(
)
;
}
if
(
mGCRunner
|
|
mHaveAskedParent
)
{
return
;
}
SetWantMajorGC
(
aReason
)
;
if
(
mCCRunner
)
{
EnsureCCThenGC
(
CCReason
:
:
GC_WAITING
)
;
return
;
}
static
bool
first
=
true
;
TimeDuration
delay
=
aDelay
?
aDelay
:
TimeDuration
:
:
FromMilliseconds
(
first
?
StaticPrefs
:
:
javascript_options_gc_delay_first
(
)
:
StaticPrefs
:
:
javascript_options_gc_delay
(
)
)
;
first
=
false
;
EnsureGCRunner
(
delay
)
;
}
void
CCGCScheduler
:
:
EnsureGCRunner
(
TimeDuration
aDelay
)
{
if
(
mGCRunner
)
{
return
;
}
mGCRunner
=
IdleTaskRunner
:
:
Create
(
[
this
]
(
TimeStamp
aDeadline
)
{
return
GCRunnerFired
(
aDeadline
)
;
}
"
CCGCScheduler
:
:
EnsureGCRunner
"
aDelay
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
javascript_options_gc_delay_interslice
(
)
)
mActiveIntersliceGCBudget
true
[
this
]
{
return
mDidShutdown
;
}
)
;
}
void
CCGCScheduler
:
:
UserIsInactive
(
)
{
mUserIsActive
=
false
;
if
(
StaticPrefs
:
:
javascript_options_compact_on_user_inactive
(
)
)
{
PokeShrinkingGC
(
)
;
}
}
void
CCGCScheduler
:
:
UserIsActive
(
)
{
mUserIsActive
=
true
;
KillShrinkingGCTimer
(
)
;
if
(
mIsCompactingOnUserInactive
)
{
mozilla
:
:
dom
:
:
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS
:
:
AbortIncrementalGC
(
jsapi
.
cx
(
)
)
;
}
MOZ_ASSERT
(
!
mIsCompactingOnUserInactive
)
;
}
void
CCGCScheduler
:
:
KillShrinkingGCTimer
(
)
{
if
(
mShrinkingGCTimer
)
{
mShrinkingGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
mShrinkingGCTimer
)
;
}
}
void
CCGCScheduler
:
:
KillFullGCTimer
(
)
{
if
(
mFullGCTimer
)
{
mFullGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
mFullGCTimer
)
;
}
}
void
CCGCScheduler
:
:
KillGCRunner
(
)
{
MOZ_ASSERT
(
!
(
InIncrementalGC
(
)
&
&
!
mDidShutdown
)
)
;
if
(
mGCRunner
)
{
mGCRunner
-
>
Cancel
(
)
;
mGCRunner
=
nullptr
;
}
}
void
CCGCScheduler
:
:
EnsureCCRunner
(
TimeDuration
aDelay
TimeDuration
aBudget
)
{
MOZ_ASSERT
(
!
mDidShutdown
)
;
if
(
!
mCCRunner
)
{
mCCRunner
=
IdleTaskRunner
:
:
Create
(
CCRunnerFired
"
EnsureCCRunner
:
:
CCRunnerFired
"
0
aDelay
aBudget
true
[
this
]
{
return
mDidShutdown
;
}
)
;
}
else
{
mCCRunner
-
>
SetMinimumUsefulBudget
(
aBudget
.
ToMilliseconds
(
)
)
;
nsIEventTarget
*
target
=
mozilla
:
:
GetCurrentEventTarget
(
)
;
if
(
target
)
{
mCCRunner
-
>
SetTimer
(
aDelay
target
)
;
}
}
}
void
CCGCScheduler
:
:
MaybePokeCC
(
TimeStamp
aNow
uint32_t
aSuspectedCCObjects
)
{
if
(
mCCRunner
|
|
mDidShutdown
)
{
return
;
}
CCReason
reason
=
ShouldScheduleCC
(
aNow
aSuspectedCCObjects
)
;
if
(
reason
!
=
CCReason
:
:
NO_REASON
)
{
nsCycleCollector_dispatchDeferredDeletion
(
)
;
if
(
!
mCCRunner
)
{
InitCCRunnerStateMachine
(
CCRunnerState
:
:
ReducePurple
reason
)
;
}
EnsureCCRunner
(
kCCSkippableDelay
kForgetSkippableSliceDuration
)
;
}
}
void
CCGCScheduler
:
:
KillCCRunner
(
)
{
UnblockCC
(
)
;
DeactivateCCRunner
(
)
;
if
(
mCCRunner
)
{
mCCRunner
-
>
Cancel
(
)
;
mCCRunner
=
nullptr
;
}
}
void
CCGCScheduler
:
:
KillAllTimersAndRunners
(
)
{
KillShrinkingGCTimer
(
)
;
KillCCRunner
(
)
;
KillFullGCTimer
(
)
;
KillGCRunner
(
)
;
}
js
:
:
SliceBudget
CCGCScheduler
:
:
ComputeCCSliceBudget
(
TimeStamp
aDeadline
TimeStamp
aCCBeginTime
TimeStamp
aPrevSliceEndTime
TimeStamp
aNow
bool
*
aPreferShorterSlices
)
const
{
*
aPreferShorterSlices
=
aDeadline
.
IsNull
(
)
|
|
(
aDeadline
-
aNow
)
<
kICCSliceBudget
;
TimeDuration
baseBudget
=
aDeadline
.
IsNull
(
)
?
kICCSliceBudget
:
aDeadline
-
aNow
;
if
(
aCCBeginTime
.
IsNull
(
)
)
{
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
baseBudget
)
kNumCCNodesBetweenTimeChecks
)
;
}
MOZ_ASSERT
(
aNow
>
=
aCCBeginTime
)
;
TimeDuration
runningTime
=
aNow
-
aCCBeginTime
;
if
(
runningTime
>
=
kMaxICCDuration
)
{
return
js
:
:
SliceBudget
:
:
unlimited
(
)
;
}
const
TimeDuration
maxSlice
=
TimeDuration
:
:
FromMilliseconds
(
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
)
;
MOZ_ASSERT
(
aNow
>
=
aPrevSliceEndTime
)
;
double
sliceDelayMultiplier
=
(
aNow
-
aPrevSliceEndTime
)
/
kICCIntersliceDelay
;
TimeDuration
delaySliceBudget
=
std
:
:
min
(
baseBudget
.
MultDouble
(
sliceDelayMultiplier
)
maxSlice
)
;
double
percentToHalfDone
=
std
:
:
min
(
2
.
0
*
(
runningTime
/
kMaxICCDuration
)
1
.
0
)
;
TimeDuration
laterSliceBudget
=
maxSlice
.
MultDouble
(
percentToHalfDone
)
;
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
std
:
:
max
(
{
delaySliceBudget
laterSliceBudget
baseBudget
}
)
)
kNumCCNodesBetweenTimeChecks
)
;
}
TimeDuration
CCGCScheduler
:
:
ComputeInterSliceGCBudget
(
TimeStamp
aDeadline
TimeStamp
aNow
)
const
{
TimeDuration
budget
=
aDeadline
.
IsNull
(
)
?
mActiveIntersliceGCBudget
*
2
:
aDeadline
-
aNow
;
if
(
!
mCCBlockStart
)
{
return
budget
;
}
TimeDuration
blockedTime
=
aNow
-
mCCBlockStart
;
TimeDuration
maxSliceGCBudget
=
mActiveIntersliceGCBudget
*
10
;
double
percentOfBlockedTime
=
std
:
:
min
(
blockedTime
/
kMaxCCLockedoutTime
1
.
0
)
;
return
std
:
:
max
(
budget
maxSliceGCBudget
.
MultDouble
(
percentOfBlockedTime
)
)
;
}
CCReason
CCGCScheduler
:
:
ShouldScheduleCC
(
TimeStamp
aNow
uint32_t
aSuspectedCCObjects
)
const
{
if
(
!
mHasRunGC
)
{
return
CCReason
:
:
NO_REASON
;
}
if
(
mCleanupsSinceLastGC
&
&
!
mLastCCEndTime
.
IsNull
(
)
)
{
if
(
aNow
-
mLastCCEndTime
<
kCCDelay
)
{
return
CCReason
:
:
NO_REASON
;
}
}
if
(
(
mCleanupsSinceLastGC
>
kMajorForgetSkippableCalls
)
&
&
!
mLastForgetSkippableCycleEndTime
.
IsNull
(
)
)
{
if
(
aNow
-
mLastForgetSkippableCycleEndTime
<
kTimeBetweenForgetSkippableCycles
)
{
return
CCReason
:
:
NO_REASON
;
}
}
return
IsCCNeeded
(
aNow
aSuspectedCCObjects
)
;
}
CCRunnerStep
CCGCScheduler
:
:
AdvanceCCRunner
(
TimeStamp
aDeadline
TimeStamp
aNow
uint32_t
aSuspectedCCObjects
)
{
struct
StateDescriptor
{
bool
mCanAbortCC
;
bool
mTryFinalForgetSkippable
;
}
;
constexpr
StateDescriptor
stateDescriptors
[
]
=
{
{
false
false
}
{
false
false
}
{
true
true
}
{
true
false
}
{
false
false
}
{
false
false
}
{
false
false
}
{
false
false
}
}
;
static_assert
(
ArrayLength
(
stateDescriptors
)
=
=
size_t
(
CCRunnerState
:
:
NumStates
)
"
need
one
state
descriptor
per
state
"
)
;
const
StateDescriptor
&
desc
=
stateDescriptors
[
int
(
mCCRunnerState
)
]
;
MOZ_ASSERT
(
mCCRunnerState
!
=
CCRunnerState
:
:
Inactive
)
;
if
(
mDidShutdown
)
{
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
if
(
mCCRunnerState
=
=
CCRunnerState
:
:
Canceled
)
{
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
if
(
InIncrementalGC
(
)
)
{
if
(
mCCBlockStart
.
IsNull
(
)
)
{
BlockCC
(
aNow
)
;
if
(
mCCRunnerState
!
=
CCRunnerState
:
:
CycleCollecting
)
{
mCCRunnerState
=
CCRunnerState
:
:
ReducePurple
;
mCCRunnerEarlyFireCount
=
0
;
mCCDelay
=
kCCDelay
/
int64_t
(
3
)
;
}
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
if
(
GetCCBlockedTime
(
aNow
)
<
kMaxCCLockedoutTime
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
}
if
(
desc
.
mCanAbortCC
&
&
IsCCNeeded
(
aNow
aSuspectedCCObjects
)
=
=
CCReason
:
:
NO_REASON
)
{
mCCRunnerState
=
CCRunnerState
:
:
Canceled
;
NoteForgetSkippableOnlyCycle
(
aNow
)
;
if
(
desc
.
mTryFinalForgetSkippable
&
&
ShouldForgetSkippable
(
aSuspectedCCObjects
)
)
{
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
KeepChildless
}
;
}
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
switch
(
mCCRunnerState
)
{
case
CCRunnerState
:
:
ReducePurple
:
+
+
mCCRunnerEarlyFireCount
;
if
(
IsLastEarlyCCTimer
(
mCCRunnerEarlyFireCount
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
CleanupChildless
;
}
if
(
ShouldForgetSkippable
(
aSuspectedCCObjects
)
)
{
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
KeepChildless
}
;
}
if
(
aDeadline
.
IsNull
(
)
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
mCCRunnerState
=
CCRunnerState
:
:
CleanupChildless
;
return
{
CCRunnerAction
:
:
None
Continue
}
;
case
CCRunnerState
:
:
CleanupChildless
:
mCCRunnerState
=
CCRunnerState
:
:
CleanupContentUnbinder
;
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
RemoveChildless
}
;
case
CCRunnerState
:
:
CleanupContentUnbinder
:
if
(
aDeadline
.
IsNull
(
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
if
(
aNow
>
=
aDeadline
)
{
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
mCCRunnerState
=
CCRunnerState
:
:
CleanupDeferred
;
return
{
CCRunnerAction
:
:
CleanupContentUnbinder
Continue
}
;
case
CCRunnerState
:
:
CleanupDeferred
:
MOZ_ASSERT
(
!
aDeadline
.
IsNull
(
)
"
Should
only
be
in
CleanupDeferred
state
when
idle
"
)
;
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
if
(
aNow
>
=
aDeadline
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
return
{
CCRunnerAction
:
:
CleanupDeferred
Yield
}
;
case
CCRunnerState
:
:
StartCycleCollection
:
mCCRunnerState
=
CCRunnerState
:
:
CycleCollecting
;
[
[
fallthrough
]
]
;
case
CCRunnerState
:
:
CycleCollecting
:
{
CCRunnerStep
step
{
CCRunnerAction
:
:
CycleCollect
Yield
}
;
step
.
mCCReason
=
mCCReason
;
mCCReason
=
CCReason
:
:
SLICE
;
return
step
;
}
default
:
MOZ_CRASH
(
"
Unexpected
CCRunner
state
"
)
;
}
;
}
GCRunnerStep
CCGCScheduler
:
:
GetNextGCRunnerAction
(
)
const
{
MOZ_ASSERT
(
mMajorGCReason
!
=
JS
:
:
GCReason
:
:
NO_REASON
)
;
if
(
InIncrementalGC
(
)
)
{
return
{
GCRunnerAction
:
:
GCSlice
mMajorGCReason
}
;
}
if
(
mReadyForMajorGC
)
{
return
{
GCRunnerAction
:
:
StartMajorGC
mMajorGCReason
}
;
}
return
{
GCRunnerAction
:
:
WaitToMajorGC
mMajorGCReason
}
;
}
js
:
:
SliceBudget
CCGCScheduler
:
:
ComputeForgetSkippableBudget
(
TimeStamp
aStartTimeStamp
TimeStamp
aDeadline
)
{
if
(
mForgetSkippableFrequencyStartTime
.
IsNull
(
)
)
{
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
else
if
(
aStartTimeStamp
-
mForgetSkippableFrequencyStartTime
>
kOneMinute
)
{
TimeStamp
startPlusMinute
=
mForgetSkippableFrequencyStartTime
+
kOneMinute
;
TimeStamp
endPoint
=
std
:
:
max
(
startPlusMinute
mLastForgetSkippableEndTime
)
;
double
duration
=
(
endPoint
-
mForgetSkippableFrequencyStartTime
)
.
ToSeconds
(
)
/
60
;
uint32_t
frequencyPerMinute
=
uint32_t
(
mForgetSkippableCounter
/
duration
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FORGET_SKIPPABLE_FREQUENCY
frequencyPerMinute
)
;
mForgetSkippableCounter
=
0
;
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
+
+
mForgetSkippableCounter
;
TimeDuration
budgetTime
=
aDeadline
?
(
aDeadline
-
aStartTimeStamp
)
:
kForgetSkippableSliceDuration
;
return
js
:
:
SliceBudget
(
budgetTime
)
;
}
}
