#
include
"
CCGCScheduler
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
namespace
mozilla
{
TimeStamp
CCGCScheduler
:
:
Now
(
)
{
return
TimeStamp
:
:
Now
(
)
;
}
uint32_t
CCGCScheduler
:
:
SuspectedCCObjects
(
)
{
return
nsCycleCollector_suspectedCount
(
)
;
}
void
CCGCScheduler
:
:
FullGCTimerFired
(
nsITimer
*
aTimer
)
{
KillFullGCTimer
(
)
;
RefPtr
<
CCGCScheduler
:
:
MayGCPromise
>
mbPromise
=
CCGCScheduler
:
:
MayGCNow
(
JS
:
:
GCReason
:
:
FULL_GC_TIMER
)
;
if
(
mbPromise
)
{
mbPromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
]
(
bool
aIgnored
)
{
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
FULL_GC_TIMER
nsJSContext
:
:
IncrementalGC
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
r
)
{
}
)
;
}
}
void
CCGCScheduler
:
:
ShrinkingGCTimerFired
(
nsITimer
*
aTimer
)
{
KillShrinkingGCTimer
(
)
;
RefPtr
<
MayGCPromise
>
mbPromise
=
MayGCNow
(
JS
:
:
GCReason
:
:
USER_INACTIVE
)
;
if
(
mbPromise
)
{
mbPromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
]
(
bool
aIgnored
)
{
if
(
!
sUserIsActive
)
{
sIsCompactingOnUserInactive
=
true
;
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
USER_INACTIVE
nsJSContext
:
:
IncrementalGC
nsJSContext
:
:
ShrinkingGC
)
;
}
else
{
using
mozilla
:
:
ipc
:
:
IdleSchedulerChild
;
IdleSchedulerChild
*
child
=
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
child
)
{
child
-
>
DoneGC
(
)
;
}
}
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
r
)
{
}
)
;
}
}
bool
CCGCScheduler
:
:
GCRunnerFired
(
TimeStamp
aDeadline
)
{
MOZ_ASSERT
(
!
mDidShutdown
"
GCRunner
still
alive
during
shutdown
"
)
;
GCRunnerStep
step
=
GetNextGCRunnerAction
(
aDeadline
)
;
switch
(
step
.
mAction
)
{
case
GCRunnerAction
:
:
None
:
MOZ_CRASH
(
"
Unexpected
GCRunnerAction
"
)
;
case
GCRunnerAction
:
:
WaitToMajorGC
:
{
RefPtr
<
CCGCScheduler
:
:
MayGCPromise
>
mbPromise
=
CCGCScheduler
:
:
MayGCNow
(
step
.
mReason
)
;
if
(
!
mbPromise
|
|
mbPromise
-
>
IsResolved
(
)
)
{
break
;
}
KillGCRunner
(
)
;
mbPromise
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
this
]
(
bool
aIgnored
)
{
if
(
!
NoteReadyForMajorGC
(
)
)
{
return
;
}
KillGCRunner
(
)
;
mGCRunner
=
IdleTaskRunner
:
:
Create
(
[
this
]
(
TimeStamp
aDeadline
)
{
return
GCRunnerFired
(
aDeadline
)
;
}
"
GCRunnerFired
"
0
StaticPrefs
:
:
javascript_options_gc_delay_interslice
(
)
int64_t
(
mActiveIntersliceGCBudget
.
ToMilliseconds
(
)
)
true
[
this
]
{
return
mDidShutdown
;
}
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
r
)
{
}
)
;
return
true
;
}
case
GCRunnerAction
:
:
StartMajorGC
:
case
GCRunnerAction
:
:
GCSlice
:
break
;
}
MOZ_ASSERT
(
mActiveIntersliceGCBudget
)
;
TimeStamp
startTimeStamp
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
budget
=
ComputeInterSliceGCBudget
(
aDeadline
startTimeStamp
)
;
TimeDuration
duration
=
mGCUnnotifiedTotalTime
;
nsJSContext
:
:
GarbageCollectNow
(
step
.
mReason
nsJSContext
:
:
IncrementalGC
nsJSContext
:
:
NonShrinkingGC
budget
.
ToMilliseconds
(
)
)
;
mGCUnnotifiedTotalTime
=
TimeDuration
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
sliceDuration
=
now
-
startTimeStamp
;
duration
+
=
sliceDuration
;
if
(
duration
.
ToSeconds
(
)
)
{
TimeDuration
idleDuration
;
if
(
!
aDeadline
.
IsNull
(
)
)
{
if
(
aDeadline
<
now
)
{
idleDuration
=
aDeadline
-
startTimeStamp
;
}
else
{
idleDuration
=
sliceDuration
;
}
}
uint32_t
percent
=
uint32_t
(
idleDuration
.
ToSeconds
(
)
/
duration
.
ToSeconds
(
)
*
100
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SLICE_DURING_IDLE
percent
)
;
}
JSContext
*
cx
=
dom
:
:
danger
:
:
GetJSContext
(
)
;
return
JS
:
:
IncrementalGCHasForegroundWork
(
cx
)
;
}
RefPtr
<
CCGCScheduler
:
:
MayGCPromise
>
CCGCScheduler
:
:
MayGCNow
(
JS
:
:
GCReason
reason
)
{
using
namespace
mozilla
:
:
ipc
;
switch
(
reason
)
{
case
JS
:
:
GCReason
:
:
PAGE_HIDE
:
case
JS
:
:
GCReason
:
:
MEM_PRESSURE
:
case
JS
:
:
GCReason
:
:
USER_INACTIVE
:
case
JS
:
:
GCReason
:
:
FULL_GC_TIMER
:
case
JS
:
:
GCReason
:
:
CC_FINISHED
:
{
if
(
XRE_IsContentProcess
(
)
)
{
IdleSchedulerChild
*
child
=
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
child
)
{
return
child
-
>
MayGCNow
(
)
;
}
}
break
;
}
default
:
break
;
}
return
MayGCPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
void
CCGCScheduler
:
:
RunNextCollectorTimer
(
JS
:
:
GCReason
aReason
mozilla
:
:
TimeStamp
aDeadline
)
{
if
(
mDidShutdown
)
{
return
;
}
MOZ_ASSERT_IF
(
InIncrementalGC
(
)
mGCRunner
)
;
RefPtr
<
IdleTaskRunner
>
runner
;
if
(
mGCRunner
)
{
SetWantMajorGC
(
aReason
)
;
runner
=
mGCRunner
;
}
else
if
(
mCCRunner
)
{
runner
=
mCCRunner
;
}
if
(
runner
)
{
runner
-
>
SetIdleDeadline
(
aDeadline
)
;
runner
-
>
Run
(
)
;
}
}
void
CCGCScheduler
:
:
PokeShrinkingGC
(
)
{
if
(
mShrinkingGCTimer
|
|
mDidShutdown
)
{
return
;
}
NS_NewTimerWithFuncCallback
(
&
mShrinkingGCTimer
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
static_cast
<
CCGCScheduler
*
>
(
aClosure
)
-
>
ShrinkingGCTimerFired
(
aTimer
)
;
}
this
StaticPrefs
:
:
javascript_options_compact_on_user_inactive_delay
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
ShrinkingGCTimerFired
"
)
;
}
void
CCGCScheduler
:
:
PokeFullGC
(
)
{
if
(
!
mFullGCTimer
&
&
!
mDidShutdown
)
{
NS_NewTimerWithFuncCallback
(
&
mFullGCTimer
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
static_cast
<
CCGCScheduler
*
>
(
aClosure
)
-
>
FullGCTimerFired
(
aTimer
)
;
}
this
StaticPrefs
:
:
javascript_options_gc_delay_full
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
FullGCTimerFired
"
)
;
}
}
void
CCGCScheduler
:
:
PokeGC
(
JS
:
:
GCReason
aReason
JSObject
*
aObj
uint32_t
aDelay
)
{
if
(
mDidShutdown
)
{
return
;
}
if
(
aObj
)
{
JS
:
:
Zone
*
zone
=
JS
:
:
GetObjectZone
(
aObj
)
;
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
AddZoneWaitingForGC
(
zone
)
;
}
else
if
(
aReason
!
=
JS
:
:
GCReason
:
:
CC_FINISHED
)
{
SetNeedsFullGC
(
)
;
}
if
(
mGCRunner
)
{
return
;
}
SetWantMajorGC
(
aReason
)
;
if
(
mCCRunner
)
{
EnsureCCThenGC
(
)
;
return
;
}
static
bool
first
=
true
;
uint32_t
delay
=
aDelay
?
aDelay
:
(
first
?
StaticPrefs
:
:
javascript_options_gc_delay_first
(
)
:
StaticPrefs
:
:
javascript_options_gc_delay
(
)
)
;
first
=
false
;
mGCRunner
=
IdleTaskRunner
:
:
Create
(
[
this
]
(
TimeStamp
aDeadline
)
{
return
GCRunnerFired
(
aDeadline
)
;
}
"
GCRunnerFired
"
delay
StaticPrefs
:
:
javascript_options_gc_delay_interslice
(
)
mActiveIntersliceGCBudget
.
ToMilliseconds
(
)
true
[
this
]
{
return
mDidShutdown
;
}
)
;
}
void
CCGCScheduler
:
:
EnsureGCRunner
(
)
{
if
(
mGCRunner
)
{
return
;
}
mGCRunner
=
IdleTaskRunner
:
:
Create
(
[
this
]
(
TimeStamp
aDeadline
)
{
return
GCRunnerFired
(
aDeadline
)
;
}
"
CCGCScheduler
:
:
EnsureGCRunner
"
0
StaticPrefs
:
:
javascript_options_gc_delay_interslice
(
)
mActiveIntersliceGCBudget
.
ToMilliseconds
(
)
true
[
this
]
{
return
mDidShutdown
;
}
)
;
}
void
CCGCScheduler
:
:
KillShrinkingGCTimer
(
)
{
if
(
mShrinkingGCTimer
)
{
mShrinkingGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
mShrinkingGCTimer
)
;
}
}
void
CCGCScheduler
:
:
KillFullGCTimer
(
)
{
if
(
mFullGCTimer
)
{
mFullGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
mFullGCTimer
)
;
}
}
void
CCGCScheduler
:
:
KillGCRunner
(
)
{
if
(
mGCRunner
)
{
mGCRunner
-
>
Cancel
(
)
;
mGCRunner
=
nullptr
;
}
}
void
CCGCScheduler
:
:
EnsureCCRunner
(
TimeDuration
aDelay
TimeDuration
aBudget
)
{
MOZ_ASSERT
(
!
mDidShutdown
)
;
if
(
!
mCCRunner
)
{
mCCRunner
=
IdleTaskRunner
:
:
Create
(
CCRunnerFired
"
EnsureCCRunner
:
:
CCRunnerFired
"
0
aDelay
.
ToMilliseconds
(
)
aBudget
.
ToMilliseconds
(
)
true
[
this
]
{
return
mDidShutdown
;
}
)
;
}
else
{
mCCRunner
-
>
SetMinimumUsefulBudget
(
aBudget
.
ToMilliseconds
(
)
)
;
nsIEventTarget
*
target
=
mozilla
:
:
GetCurrentEventTarget
(
)
;
if
(
target
)
{
mCCRunner
-
>
SetTimer
(
aDelay
.
ToMilliseconds
(
)
target
)
;
}
}
}
void
CCGCScheduler
:
:
MaybePokeCC
(
)
{
if
(
mCCRunner
|
|
mDidShutdown
)
{
return
;
}
if
(
ShouldScheduleCC
(
)
)
{
nsCycleCollector_dispatchDeferredDeletion
(
)
;
if
(
!
mCCRunner
)
{
InitCCRunnerStateMachine
(
CCRunnerState
:
:
ReducePurple
)
;
}
EnsureCCRunner
(
kCCSkippableDelay
kForgetSkippableSliceDuration
)
;
}
}
void
CCGCScheduler
:
:
KillCCRunner
(
)
{
UnblockCC
(
)
;
DeactivateCCRunner
(
)
;
if
(
mCCRunner
)
{
mCCRunner
-
>
Cancel
(
)
;
mCCRunner
=
nullptr
;
}
}
void
CCGCScheduler
:
:
KillAllTimersAndRunners
(
)
{
KillShrinkingGCTimer
(
)
;
KillCCRunner
(
)
;
KillFullGCTimer
(
)
;
KillGCRunner
(
)
;
}
}
