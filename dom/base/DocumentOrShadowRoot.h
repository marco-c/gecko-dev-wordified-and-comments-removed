#
ifndef
mozilla_dom_DocumentOrShadowRoot_h__
#
define
mozilla_dom_DocumentOrShadowRoot_h__
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIdentifierMapEntry
.
h
"
class
nsContentList
;
class
nsIDocument
;
class
nsINode
;
namespace
mozilla
{
class
StyleSheet
;
namespace
dom
{
class
Element
;
class
StyleSheetList
;
class
ShadowRoot
;
class
DocumentOrShadowRoot
{
enum
class
Kind
{
Document
ShadowRoot
}
;
public
:
explicit
DocumentOrShadowRoot
(
nsIDocument
&
)
;
explicit
DocumentOrShadowRoot
(
mozilla
:
:
dom
:
:
ShadowRoot
&
)
;
nsINode
&
AsNode
(
)
{
return
mAsNode
;
}
const
nsINode
&
AsNode
(
)
const
{
return
mAsNode
;
}
StyleSheet
*
SheetAt
(
size_t
aIndex
)
const
{
return
mStyleSheets
.
SafeElementAt
(
aIndex
)
;
}
size_t
SheetCount
(
)
const
{
return
mStyleSheets
.
Length
(
)
;
}
int32_t
IndexOfSheet
(
const
StyleSheet
&
aSheet
)
const
{
return
mStyleSheets
.
IndexOf
(
&
aSheet
)
;
}
StyleSheetList
&
EnsureDOMStyleSheets
(
)
;
Element
*
GetElementById
(
const
nsAString
&
aElementId
)
;
inline
const
nsTArray
<
Element
*
>
*
GetAllElementsForId
(
const
nsAString
&
aElementId
)
const
;
already_AddRefed
<
nsContentList
>
GetElementsByTagName
(
const
nsAString
&
aTagName
)
{
return
NS_GetContentList
(
&
AsNode
(
)
kNameSpaceID_Unknown
aTagName
)
;
}
already_AddRefed
<
nsContentList
>
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
already_AddRefed
<
nsContentList
>
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
mozilla
:
:
ErrorResult
&
)
;
already_AddRefed
<
nsContentList
>
GetElementsByClassName
(
const
nsAString
&
aClasses
)
;
~
DocumentOrShadowRoot
(
)
=
default
;
Element
*
GetPointerLockElement
(
)
;
Element
*
GetFullscreenElement
(
)
;
Element
*
ElementFromPoint
(
float
aX
float
aY
)
;
void
ElementsFromPoint
(
float
aX
float
aY
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
>
&
aElements
)
;
Element
*
ElementFromPointHelper
(
float
aX
float
aY
bool
aIgnoreRootScrollFrame
bool
aFlushLayout
)
;
enum
ElementsFromPointFlags
{
IGNORE_ROOT_SCROLL_FRAME
=
1
FLUSH_LAYOUT
=
2
IS_ELEMENT_FROM_POINT
=
4
}
;
void
ElementsFromPointHelper
(
float
aX
float
aY
uint32_t
aFlags
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
>
&
aElements
)
;
typedef
bool
(
*
IDTargetObserver
)
(
Element
*
aOldElement
Element
*
aNewelement
void
*
aData
)
;
Element
*
AddIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
;
void
RemoveIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
;
inline
bool
CheckGetElementByIdArg
(
const
nsAString
&
aId
)
{
if
(
aId
.
IsEmpty
(
)
)
{
ReportEmptyGetElementByIdArg
(
)
;
return
false
;
}
return
true
;
}
void
ReportEmptyGetElementByIdArg
(
)
;
protected
:
already_AddRefed
<
StyleSheet
>
RemoveSheet
(
StyleSheet
&
aSheet
)
;
void
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
aSheet
)
;
nsIContent
*
Retarget
(
nsIContent
*
aContent
)
const
;
Element
*
GetRetargetedFocusedElement
(
)
;
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
mStyleSheets
;
RefPtr
<
mozilla
:
:
dom
:
:
StyleSheetList
>
mDOMStyleSheets
;
nsTHashtable
<
nsIdentifierMapEntry
>
mIdentifierMap
;
nsINode
&
mAsNode
;
const
Kind
mKind
;
}
;
inline
const
nsTArray
<
Element
*
>
*
DocumentOrShadowRoot
:
:
GetAllElementsForId
(
const
nsAString
&
aElementId
)
const
{
if
(
aElementId
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aElementId
)
;
return
entry
?
&
entry
-
>
GetIdElements
(
)
:
nullptr
;
}
}
}
#
endif
