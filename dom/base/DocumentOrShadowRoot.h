#
ifndef
mozilla_dom_DocumentOrShadowRoot_h__
#
define
mozilla_dom_DocumentOrShadowRoot_h__
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIdentifierMapEntry
.
h
"
class
nsContentList
;
class
nsCycleCollectionTraversalCallback
;
class
nsIDocument
;
class
nsINode
;
class
nsINodeList
;
class
nsIRadioVisitor
;
class
nsWindowSizes
;
namespace
mozilla
{
class
StyleSheet
;
namespace
dom
{
class
Element
;
class
DocumentOrShadowRoot
;
class
HTMLInputElement
;
struct
nsRadioGroupStruct
;
class
StyleSheetList
;
class
ShadowRoot
;
class
DocumentOrShadowRoot
{
enum
class
Kind
{
Document
ShadowRoot
}
;
public
:
explicit
DocumentOrShadowRoot
(
nsIDocument
&
)
;
explicit
DocumentOrShadowRoot
(
ShadowRoot
&
)
;
static
void
Traverse
(
DocumentOrShadowRoot
*
tmp
nsCycleCollectionTraversalCallback
&
cb
)
;
static
void
Unlink
(
DocumentOrShadowRoot
*
tmp
)
;
nsINode
&
AsNode
(
)
{
return
mAsNode
;
}
const
nsINode
&
AsNode
(
)
const
{
return
mAsNode
;
}
StyleSheet
*
SheetAt
(
size_t
aIndex
)
const
{
return
mStyleSheets
.
SafeElementAt
(
aIndex
)
;
}
size_t
SheetCount
(
)
const
{
return
mStyleSheets
.
Length
(
)
;
}
int32_t
IndexOfSheet
(
const
StyleSheet
&
aSheet
)
const
{
return
mStyleSheets
.
IndexOf
(
&
aSheet
)
;
}
StyleSheetList
&
EnsureDOMStyleSheets
(
)
;
Element
*
GetElementById
(
const
nsAString
&
aElementId
)
;
inline
const
nsTArray
<
Element
*
>
*
GetAllElementsForId
(
const
nsAString
&
aElementId
)
const
;
already_AddRefed
<
nsContentList
>
GetElementsByTagName
(
const
nsAString
&
aTagName
)
{
return
NS_GetContentList
(
&
AsNode
(
)
kNameSpaceID_Unknown
aTagName
)
;
}
already_AddRefed
<
nsContentList
>
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
already_AddRefed
<
nsContentList
>
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
mozilla
:
:
ErrorResult
&
)
;
already_AddRefed
<
nsContentList
>
GetElementsByClassName
(
const
nsAString
&
aClasses
)
;
~
DocumentOrShadowRoot
(
)
;
Element
*
GetPointerLockElement
(
)
;
Element
*
GetFullscreenElement
(
)
;
Element
*
ElementFromPoint
(
float
aX
float
aY
)
;
nsINode
*
NodeFromPoint
(
float
aX
float
aY
)
;
void
ElementsFromPoint
(
float
aX
float
aY
nsTArray
<
RefPtr
<
Element
>
>
&
)
;
void
NodesFromPoint
(
float
aX
float
aY
nsTArray
<
RefPtr
<
nsINode
>
>
&
)
;
Element
*
ElementFromPointHelper
(
float
aX
float
aY
bool
aIgnoreRootScrollFrame
bool
aFlushLayout
)
;
void
NodesFromRect
(
float
aX
float
aY
float
aTopSize
float
aRightSize
float
aBottomSize
float
aLeftSize
bool
aIgnoreRootScrollFrame
bool
aFlushLayout
nsTArray
<
RefPtr
<
nsINode
>
>
&
)
;
typedef
bool
(
*
IDTargetObserver
)
(
Element
*
aOldElement
Element
*
aNewelement
void
*
aData
)
;
Element
*
AddIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
;
void
RemoveIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
;
Element
*
LookupImageElement
(
const
nsAString
&
aElementId
)
;
inline
bool
CheckGetElementByIdArg
(
const
nsAString
&
aId
)
{
if
(
aId
.
IsEmpty
(
)
)
{
ReportEmptyGetElementByIdArg
(
)
;
return
false
;
}
return
true
;
}
void
ReportEmptyGetElementByIdArg
(
)
;
NS_IMETHOD
WalkRadioGroup
(
const
nsAString
&
aName
nsIRadioVisitor
*
aVisitor
bool
aFlushContent
)
;
void
SetCurrentRadioButton
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
;
HTMLInputElement
*
GetCurrentRadioButton
(
const
nsAString
&
aName
)
;
nsresult
GetNextRadioButton
(
const
nsAString
&
aName
const
bool
aPrevious
HTMLInputElement
*
aFocusedRadio
HTMLInputElement
*
*
aRadioOut
)
;
void
AddToRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
;
void
RemoveFromRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
;
uint32_t
GetRequiredRadioCount
(
const
nsAString
&
aName
)
const
;
void
RadioRequiredWillChange
(
const
nsAString
&
aName
bool
aRequiredAdded
)
;
bool
GetValueMissingState
(
const
nsAString
&
aName
)
const
;
void
SetValueMissingState
(
const
nsAString
&
aName
bool
aValue
)
;
nsRadioGroupStruct
*
GetRadioGroup
(
const
nsAString
&
aName
)
const
;
nsRadioGroupStruct
*
GetOrCreateRadioGroup
(
const
nsAString
&
aName
)
;
nsIContent
*
Retarget
(
nsIContent
*
aContent
)
const
;
protected
:
already_AddRefed
<
StyleSheet
>
RemoveSheet
(
StyleSheet
&
aSheet
)
;
void
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
aSheet
)
;
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
)
const
;
void
AddSizeOfOwnedSheetArrayExcludingThis
(
nsWindowSizes
&
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
)
const
;
Element
*
GetRetargetedFocusedElement
(
)
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mStyleSheets
;
RefPtr
<
StyleSheetList
>
mDOMStyleSheets
;
nsTHashtable
<
nsIdentifierMapEntry
>
mIdentifierMap
;
nsClassHashtable
<
nsStringHashKey
nsRadioGroupStruct
>
mRadioGroups
;
nsINode
&
mAsNode
;
const
Kind
mKind
;
}
;
inline
const
nsTArray
<
Element
*
>
*
DocumentOrShadowRoot
:
:
GetAllElementsForId
(
const
nsAString
&
aElementId
)
const
{
if
(
aElementId
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aElementId
)
;
return
entry
?
&
entry
-
>
GetIdElements
(
)
:
nullptr
;
}
}
}
#
endif
