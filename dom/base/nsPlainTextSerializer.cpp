#
include
"
nsPlainTextSerializer
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
EditorUtils
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
namespace
mozilla
{
class
Encoding
;
}
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
PREF_STRUCTS
"
converter
.
html2txt
.
structs
"
#
define
PREF_HEADER_STRATEGY
"
converter
.
html2txt
.
header_strategy
"
#
define
PREF_ALWAYS_INCLUDE_RUBY
"
converter
.
html2txt
.
always_include_ruby
"
static
const
int32_t
kTabSize
=
4
;
static
const
int32_t
kIndentSizeHeaders
=
2
;
static
const
int32_t
kIndentIncrementHeaders
=
2
;
static
const
int32_t
kIndentSizeList
=
kTabSize
;
static
const
int32_t
kIndentSizeDD
=
kTabSize
;
static
const
char16_t
kNBSP
=
160
;
static
const
char16_t
kSPACE
=
'
'
;
constexpr
int32_t
kNoFlags
=
0
;
static
int32_t
HeaderLevel
(
nsAtom
*
aTag
)
;
static
int32_t
GetUnicharWidth
(
char16_t
ucs
)
;
static
int32_t
GetUnicharStringWidth
(
const
nsString
&
aString
)
;
static
const
uint32_t
TagStackSize
=
500
;
static
const
uint32_t
OLStackSize
=
100
;
static
bool
gPreferenceInitialized
=
false
;
static
bool
gAlwaysIncludeRuby
=
false
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsPlainTextSerializer
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsPlainTextSerializer
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsPlainTextSerializer
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentSerializer
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsPlainTextSerializer
mElement
)
nsresult
NS_NewPlainTextSerializer
(
nsIContentSerializer
*
*
aSerializer
)
{
RefPtr
<
nsPlainTextSerializer
>
it
=
new
nsPlainTextSerializer
(
)
;
it
.
forget
(
aSerializer
)
;
return
NS_OK
;
}
static
void
DetermineLineBreak
(
const
int32_t
aFlags
nsAString
&
aLineBreak
)
{
if
(
(
aFlags
&
nsIDocumentEncoder
:
:
OutputCRLineBreak
)
&
&
(
aFlags
&
nsIDocumentEncoder
:
:
OutputLFLineBreak
)
)
{
aLineBreak
.
AssignLiteral
(
u
"
\
r
\
n
"
)
;
}
else
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputCRLineBreak
)
{
aLineBreak
.
AssignLiteral
(
u
"
\
r
"
)
;
}
else
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputLFLineBreak
)
{
aLineBreak
.
AssignLiteral
(
u
"
\
n
"
)
;
}
else
{
aLineBreak
.
AssignLiteral
(
NS_ULINEBREAK
)
;
}
}
void
nsPlainTextSerializer
:
:
CurrentLine
:
:
MaybeReplaceNbspsInContent
(
const
int32_t
aFlags
)
{
if
(
!
(
aFlags
&
nsIDocumentEncoder
:
:
OutputPersistNBSP
)
)
{
mContent
.
ReplaceChar
(
kNBSP
kSPACE
)
;
}
}
void
nsPlainTextSerializer
:
:
CurrentLine
:
:
ResetContentAndIndentationHeader
(
)
{
mContent
.
Truncate
(
)
;
mIndentation
.
mHeader
.
Truncate
(
)
;
}
nsPlainTextSerializer
:
:
OutputManager
:
:
OutputManager
(
const
int32_t
aFlags
nsAString
&
aOutput
)
:
mFlags
{
aFlags
}
mOutput
{
aOutput
}
mAtFirstColumn
{
true
}
{
MOZ_ASSERT
(
aOutput
.
IsEmpty
(
)
)
;
DetermineLineBreak
(
mFlags
mLineBreak
)
;
}
void
nsPlainTextSerializer
:
:
OutputManager
:
:
Append
(
const
CurrentLine
&
aCurrentLine
const
StripTrailingWhitespaces
aStripTrailingWhitespaces
)
{
if
(
IsAtFirstColumn
(
)
)
{
nsAutoString
quotesAndIndent
;
aCurrentLine
.
CreateQuotesAndIndent
(
quotesAndIndent
)
;
if
(
(
aStripTrailingWhitespaces
=
=
StripTrailingWhitespaces
:
:
kMaybe
)
)
{
const
bool
stripTrailingSpaces
=
aCurrentLine
.
mContent
.
IsEmpty
(
)
;
if
(
stripTrailingSpaces
)
{
quotesAndIndent
.
Trim
(
"
"
false
true
false
)
;
}
}
Append
(
quotesAndIndent
)
;
}
Append
(
aCurrentLine
.
mContent
)
;
}
void
nsPlainTextSerializer
:
:
OutputManager
:
:
Append
(
const
nsAString
&
aString
)
{
if
(
!
aString
.
IsEmpty
(
)
)
{
mOutput
.
Append
(
aString
)
;
mAtFirstColumn
=
false
;
}
}
void
nsPlainTextSerializer
:
:
OutputManager
:
:
AppendLineBreak
(
)
{
mOutput
.
Append
(
mLineBreak
)
;
mAtFirstColumn
=
true
;
}
uint32_t
nsPlainTextSerializer
:
:
OutputManager
:
:
GetOutputLength
(
)
const
{
return
mOutput
.
Length
(
)
;
}
nsPlainTextSerializer
:
:
nsPlainTextSerializer
(
)
:
mFloatingLines
(
-
1
)
mLineBreakDue
(
false
)
kSpace
(
NS_LITERAL_STRING
(
"
"
)
)
{
mHeadLevel
=
0
;
mHasWrittenCiteBlockquote
=
false
;
mSpanLevel
=
0
;
for
(
int32_t
i
=
0
;
i
<
=
6
;
i
+
+
)
{
mHeaderCounter
[
i
]
=
0
;
}
mWrapColumn
=
72
;
mEmptyLines
=
1
;
mInWhitespace
=
false
;
mPreFormattedMail
=
false
;
mPreformattedBlockBoundary
=
false
;
mTagStack
=
new
nsAtom
*
[
TagStackSize
]
;
mTagStackIndex
=
0
;
mIgnoreAboveIndex
=
(
uint32_t
)
kNotFound
;
mOLStack
=
new
int32_t
[
OLStackSize
]
;
mOLStackIndex
=
0
;
mULCount
=
0
;
mIgnoredChildNodeLevel
=
0
;
if
(
!
gPreferenceInitialized
)
{
Preferences
:
:
AddBoolVarCache
(
&
gAlwaysIncludeRuby
PREF_ALWAYS_INCLUDE_RUBY
true
)
;
gPreferenceInitialized
=
true
;
}
}
nsPlainTextSerializer
:
:
~
nsPlainTextSerializer
(
)
{
delete
[
]
mTagStack
;
delete
[
]
mOLStack
;
NS_WARNING_ASSERTION
(
mHeadLevel
=
=
0
"
Wrong
head
level
!
"
)
;
}
nsPlainTextSerializer
:
:
Settings
:
:
HeaderStrategy
nsPlainTextSerializer
:
:
Settings
:
:
Convert
(
const
int32_t
aPrefHeaderStrategy
)
{
HeaderStrategy
result
{
HeaderStrategy
:
:
kIndentIncreasedWithHeaderLevel
}
;
switch
(
aPrefHeaderStrategy
)
{
case
0
:
{
result
=
HeaderStrategy
:
:
kNoIndentation
;
break
;
}
case
1
:
{
result
=
HeaderStrategy
:
:
kIndentIncreasedWithHeaderLevel
;
break
;
}
case
2
:
{
result
=
HeaderStrategy
:
:
kNumberHeadingsAndIndentSlightly
;
break
;
}
default
:
{
NS_WARNING
(
nsPrintfCString
(
"
Header
strategy
pref
contains
undefined
value
:
%
i
"
aPrefHeaderStrategy
)
.
get
(
)
)
;
}
}
return
result
;
}
const
int32_t
kDefaultHeaderStrategy
=
1
;
void
nsPlainTextSerializer
:
:
Settings
:
:
Init
(
const
int32_t
aFlags
)
{
mFlags
=
aFlags
;
if
(
mFlags
&
nsIDocumentEncoder
:
:
OutputFormatted
)
{
mStructs
=
Preferences
:
:
GetBool
(
PREF_STRUCTS
mStructs
)
;
int32_t
headerStrategy
=
Preferences
:
:
GetInt
(
PREF_HEADER_STRATEGY
kDefaultHeaderStrategy
)
;
mHeaderStrategy
=
Convert
(
headerStrategy
)
;
}
mWithRubyAnnotation
=
gAlwaysIncludeRuby
|
|
(
mFlags
&
nsIDocumentEncoder
:
:
OutputRubyAnnotation
)
;
mFlags
&
=
~
nsIDocumentEncoder
:
:
OutputNoFramesContent
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
Init
(
const
uint32_t
aFlags
uint32_t
aWrapColumn
const
Encoding
*
aEncoding
bool
aIsCopying
bool
aIsWholeDocument
bool
*
aNeedsPreformatScanning
nsAString
&
aOutput
)
{
#
ifdef
DEBUG
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
{
NS_ASSERTION
(
aFlags
&
nsIDocumentEncoder
:
:
OutputFormatted
"
If
you
want
format
=
flowed
you
must
combine
it
with
"
"
nsIDocumentEncoder
:
:
OutputFormatted
"
)
;
}
if
(
aFlags
&
nsIDocumentEncoder
:
:
OutputFormatted
)
{
NS_ASSERTION
(
!
(
aFlags
&
nsIDocumentEncoder
:
:
OutputPreformatted
)
"
Can
'
t
do
formatted
and
preformatted
output
at
the
same
time
!
"
)
;
}
#
endif
MOZ_ASSERT
(
!
(
aFlags
&
nsIDocumentEncoder
:
:
OutputFormatDelSp
)
|
|
(
aFlags
&
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
)
;
*
aNeedsPreformatScanning
=
true
;
mSettings
.
Init
(
aFlags
)
;
mOutputManager
.
emplace
(
mSettings
.
GetFlags
(
)
aOutput
)
;
mWrapColumn
=
aWrapColumn
;
if
(
MayWrap
(
)
&
&
MayBreakLines
(
)
)
{
mLineBreaker
=
nsContentUtils
:
:
LineBreaker
(
)
;
}
mLineBreakDue
=
false
;
mFloatingLines
=
-
1
;
mPreformattedBlockBoundary
=
false
;
return
NS_OK
;
}
bool
nsPlainTextSerializer
:
:
GetLastBool
(
const
nsTArray
<
bool
>
&
aStack
)
{
uint32_t
size
=
aStack
.
Length
(
)
;
if
(
size
=
=
0
)
{
return
false
;
}
return
aStack
.
ElementAt
(
size
-
1
)
;
}
void
nsPlainTextSerializer
:
:
SetLastBool
(
nsTArray
<
bool
>
&
aStack
bool
aValue
)
{
uint32_t
size
=
aStack
.
Length
(
)
;
if
(
size
>
0
)
{
aStack
.
ElementAt
(
size
-
1
)
=
aValue
;
}
else
{
NS_ERROR
(
"
There
is
no
\
"
Last
\
"
value
"
)
;
}
}
void
nsPlainTextSerializer
:
:
PushBool
(
nsTArray
<
bool
>
&
aStack
bool
aValue
)
{
aStack
.
AppendElement
(
bool
(
aValue
)
)
;
}
bool
nsPlainTextSerializer
:
:
PopBool
(
nsTArray
<
bool
>
&
aStack
)
{
bool
returnValue
=
false
;
uint32_t
size
=
aStack
.
Length
(
)
;
if
(
size
>
0
)
{
returnValue
=
aStack
.
ElementAt
(
size
-
1
)
;
aStack
.
RemoveElementAt
(
size
-
1
)
;
}
return
returnValue
;
}
bool
nsPlainTextSerializer
:
:
IsIgnorableRubyAnnotation
(
nsAtom
*
aTag
)
const
{
if
(
mSettings
.
GetWithRubyAnnotation
(
)
)
{
return
false
;
}
return
aTag
=
=
nsGkAtoms
:
:
rp
|
|
aTag
=
=
nsGkAtoms
:
:
rt
|
|
aTag
=
=
nsGkAtoms
:
:
rtc
;
}
static
bool
IsDisplayNone
(
Element
*
aElement
)
{
RefPtr
<
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aElement
nullptr
)
;
return
!
computedStyle
|
|
computedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
;
}
static
bool
IsIgnorableScriptOrStyle
(
Element
*
aElement
)
{
return
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
style
)
&
&
IsDisplayNone
(
aElement
)
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
AppendText
(
nsIContent
*
aText
int32_t
aStartOffset
int32_t
aEndOffset
)
{
if
(
mIgnoreAboveIndex
!
=
(
uint32_t
)
kNotFound
)
{
return
NS_OK
;
}
NS_ASSERTION
(
aStartOffset
>
=
0
"
Negative
start
offset
for
text
fragment
!
"
)
;
if
(
aStartOffset
<
0
)
return
NS_ERROR_INVALID_ARG
;
NS_ENSURE_ARG
(
aText
)
;
nsresult
rv
=
NS_OK
;
nsIContent
*
content
=
aText
;
const
nsTextFragment
*
frag
;
if
(
!
content
|
|
!
(
frag
=
content
-
>
GetText
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
fragLength
=
frag
-
>
GetLength
(
)
;
int32_t
endoffset
=
(
aEndOffset
=
=
-
1
)
?
fragLength
:
std
:
:
min
(
aEndOffset
fragLength
)
;
NS_ASSERTION
(
aStartOffset
<
=
endoffset
"
A
start
offset
is
beyond
the
end
of
the
text
fragment
!
"
)
;
int32_t
length
=
endoffset
-
aStartOffset
;
if
(
length
<
=
0
)
{
return
NS_OK
;
}
nsAutoString
textstr
;
if
(
frag
-
>
Is2b
(
)
)
{
textstr
.
Assign
(
frag
-
>
Get2b
(
)
+
aStartOffset
length
)
;
}
else
{
const
char
*
data
=
frag
-
>
Get1b
(
)
;
CopyASCIItoUTF16
(
Substring
(
data
+
aStartOffset
data
+
endoffset
)
textstr
)
;
}
if
(
content
-
>
HasFlag
(
NS_MAYBE_MASKED
)
)
{
EditorUtils
:
:
MaskString
(
textstr
content
-
>
AsText
(
)
0
aStartOffset
)
;
}
int32_t
start
=
0
;
int32_t
offset
=
textstr
.
FindCharInSet
(
"
\
n
\
r
"
)
;
while
(
offset
!
=
kNotFound
)
{
if
(
offset
>
start
)
{
DoAddText
(
false
Substring
(
textstr
start
offset
-
start
)
)
;
}
DoAddText
(
)
;
start
=
offset
+
1
;
offset
=
textstr
.
FindCharInSet
(
"
\
n
\
r
"
start
)
;
}
if
(
start
<
length
)
{
if
(
start
)
{
DoAddText
(
false
Substring
(
textstr
start
length
-
start
)
)
;
}
else
{
DoAddText
(
false
textstr
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
AppendCDATASection
(
nsIContent
*
aCDATASection
int32_t
aStartOffset
int32_t
aEndOffset
)
{
return
AppendText
(
aCDATASection
aStartOffset
aEndOffset
)
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
ScanElementForPreformat
(
Element
*
aElement
)
{
mPreformatStack
.
push
(
IsElementPreformatted
(
aElement
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
ForgetElementForPreformat
(
Element
*
aElement
)
{
MOZ_RELEASE_ASSERT
(
!
mPreformatStack
.
empty
(
)
"
Tried
to
pop
without
previous
push
.
"
)
;
mPreformatStack
.
pop
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
AppendElementStart
(
Element
*
aElement
Element
*
aOriginalElement
)
{
NS_ENSURE_ARG
(
aElement
)
;
mElement
=
aElement
;
nsresult
rv
;
nsAtom
*
id
=
GetIdForContent
(
mElement
)
;
bool
isContainer
=
!
FragmentOrElement
:
:
IsHTMLVoid
(
id
)
;
if
(
isContainer
)
{
rv
=
DoOpenContainer
(
id
)
;
}
else
{
rv
=
DoAddLeaf
(
id
)
;
}
mElement
=
nullptr
;
if
(
id
=
=
nsGkAtoms
:
:
head
)
{
+
+
mHeadLevel
;
}
return
rv
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
AppendElementEnd
(
Element
*
aElement
Element
*
aOriginalElement
)
{
NS_ENSURE_ARG
(
aElement
)
;
mElement
=
aElement
;
nsresult
rv
;
nsAtom
*
id
=
GetIdForContent
(
mElement
)
;
bool
isContainer
=
!
FragmentOrElement
:
:
IsHTMLVoid
(
id
)
;
rv
=
NS_OK
;
if
(
isContainer
)
{
rv
=
DoCloseContainer
(
id
)
;
}
mElement
=
nullptr
;
if
(
id
=
=
nsGkAtoms
:
:
head
)
{
NS_ASSERTION
(
mHeadLevel
!
=
0
"
mHeadLevel
being
decremented
below
0
"
)
;
-
-
mHeadLevel
;
}
return
rv
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
FlushAndFinish
(
)
{
MOZ_ASSERT
(
mOutputManager
)
;
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
return
Finish
(
)
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
Finish
(
)
{
mOutputManager
.
reset
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
GetOutputLength
(
uint32_t
&
aLength
)
const
{
MOZ_ASSERT
(
mOutputManager
)
;
aLength
=
mOutputManager
-
>
GetOutputLength
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPlainTextSerializer
:
:
AppendDocumentStart
(
Document
*
aDocument
)
{
return
NS_OK
;
}
nsresult
nsPlainTextSerializer
:
:
DoOpenContainer
(
nsAtom
*
aTag
)
{
if
(
IsIgnorableRubyAnnotation
(
aTag
)
)
{
mIgnoredChildNodeLevel
+
+
;
return
NS_OK
;
}
if
(
IsIgnorableScriptOrStyle
(
mElement
)
)
{
mIgnoredChildNodeLevel
+
+
;
return
NS_OK
;
}
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputForPlainTextClipboardCopy
)
)
{
if
(
mPreformattedBlockBoundary
&
&
DoOutput
(
)
)
{
if
(
mFloatingLines
<
0
)
mFloatingLines
=
0
;
mLineBreakDue
=
true
;
}
mPreformattedBlockBoundary
=
false
;
}
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputRaw
)
)
{
return
NS_OK
;
}
if
(
mTagStackIndex
<
TagStackSize
)
{
mTagStack
[
mTagStackIndex
+
+
]
=
aTag
;
}
if
(
mIgnoreAboveIndex
!
=
(
uint32_t
)
kNotFound
)
{
return
NS_OK
;
}
mHasWrittenCiteBlockquote
=
mHasWrittenCiteBlockquote
&
&
aTag
=
=
nsGkAtoms
:
:
pre
;
bool
isInCiteBlockquote
=
false
;
if
(
aTag
=
=
nsGkAtoms
:
:
blockquote
)
{
nsAutoString
value
;
nsresult
rv
=
GetAttributeValue
(
nsGkAtoms
:
:
type
value
)
;
isInCiteBlockquote
=
NS_SUCCEEDED
(
rv
)
&
&
value
.
EqualsIgnoreCase
(
"
cite
"
)
;
}
if
(
mLineBreakDue
&
&
!
isInCiteBlockquote
)
EnsureVerticalSpace
(
mFloatingLines
)
;
if
(
(
aTag
=
=
nsGkAtoms
:
:
noscript
&
&
!
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputNoScriptContent
)
)
|
|
(
(
aTag
=
=
nsGkAtoms
:
:
iframe
|
|
aTag
=
=
nsGkAtoms
:
:
noframes
)
&
&
!
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputNoFramesContent
)
)
)
{
mIgnoreAboveIndex
=
mTagStackIndex
-
1
;
return
NS_OK
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
body
)
{
nsAutoString
style
;
int32_t
whitespace
;
if
(
NS_SUCCEEDED
(
GetAttributeValue
(
nsGkAtoms
:
:
style
style
)
)
&
&
(
kNotFound
!
=
(
whitespace
=
style
.
Find
(
"
white
-
space
:
"
)
)
)
)
{
if
(
kNotFound
!
=
style
.
Find
(
"
pre
-
wrap
"
true
whitespace
)
)
{
#
ifdef
DEBUG_preformatted
printf
(
"
Set
mPreFormattedMail
based
on
style
pre
-
wrap
\
n
"
)
;
#
endif
mPreFormattedMail
=
true
;
int32_t
widthOffset
=
style
.
Find
(
"
width
:
"
)
;
if
(
widthOffset
>
=
0
)
{
int32_t
semiOffset
=
style
.
Find
(
"
ch
"
false
widthOffset
+
6
)
;
int32_t
length
=
(
semiOffset
>
0
?
semiOffset
-
widthOffset
-
6
:
style
.
Length
(
)
-
widthOffset
)
;
nsAutoString
widthstr
;
style
.
Mid
(
widthstr
widthOffset
+
6
length
)
;
nsresult
err
;
int32_t
col
=
widthstr
.
ToInteger
(
&
err
)
;
if
(
NS_SUCCEEDED
(
err
)
)
{
mWrapColumn
=
(
uint32_t
)
col
;
#
ifdef
DEBUG_preformatted
printf
(
"
Set
wrap
column
to
%
d
based
on
style
\
n
"
mWrapColumn
)
;
#
endif
}
}
}
else
if
(
kNotFound
!
=
style
.
Find
(
"
pre
"
true
whitespace
)
)
{
#
ifdef
DEBUG_preformatted
printf
(
"
Set
mPreFormattedMail
based
on
style
pre
\
n
"
)
;
#
endif
mPreFormattedMail
=
true
;
mWrapColumn
=
0
;
}
}
else
{
mInWhitespace
=
true
;
mPreFormattedMail
=
false
;
}
return
NS_OK
;
}
if
(
!
DoOutput
(
)
)
{
return
NS_OK
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
p
)
EnsureVerticalSpace
(
1
)
;
else
if
(
aTag
=
=
nsGkAtoms
:
:
pre
)
{
if
(
GetLastBool
(
mIsInCiteBlockquote
)
)
EnsureVerticalSpace
(
0
)
;
else
if
(
mHasWrittenCiteBlockquote
)
{
EnsureVerticalSpace
(
0
)
;
mHasWrittenCiteBlockquote
=
false
;
}
else
EnsureVerticalSpace
(
1
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
tr
)
{
PushBool
(
mHasWrittenCellsForRow
false
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
td
|
|
aTag
=
=
nsGkAtoms
:
:
th
)
{
if
(
mHasWrittenCellsForRow
.
IsEmpty
(
)
)
{
PushBool
(
mHasWrittenCellsForRow
true
)
;
}
else
if
(
GetLastBool
(
mHasWrittenCellsForRow
)
)
{
AddToLine
(
u
"
\
t
"
1
)
;
mInWhitespace
=
true
;
}
else
{
SetLastBool
(
mHasWrittenCellsForRow
true
)
;
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
ul
)
{
EnsureVerticalSpace
(
mULCount
+
mOLStackIndex
=
=
0
?
1
:
0
)
;
mCurrentLine
.
mIndentation
.
mLength
+
=
kIndentSizeList
;
mULCount
+
+
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
ol
)
{
EnsureVerticalSpace
(
mULCount
+
mOLStackIndex
=
=
0
?
1
:
0
)
;
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
if
(
mOLStackIndex
<
OLStackSize
)
{
nsAutoString
startAttr
;
int32_t
startVal
=
1
;
if
(
NS_SUCCEEDED
(
GetAttributeValue
(
nsGkAtoms
:
:
start
startAttr
)
)
)
{
nsresult
rv
=
NS_OK
;
startVal
=
startAttr
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
startVal
=
1
;
}
mOLStack
[
mOLStackIndex
+
+
]
=
startVal
;
}
}
else
{
mOLStackIndex
+
+
;
}
mCurrentLine
.
mIndentation
.
mLength
+
=
kIndentSizeList
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
li
&
&
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
if
(
mTagStackIndex
>
1
&
&
IsInOL
(
)
)
{
if
(
mOLStackIndex
>
0
)
{
nsAutoString
valueAttr
;
if
(
NS_SUCCEEDED
(
GetAttributeValue
(
nsGkAtoms
:
:
value
valueAttr
)
)
)
{
nsresult
rv
=
NS_OK
;
int32_t
valueAttrVal
=
valueAttr
.
ToInteger
(
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
mOLStack
[
mOLStackIndex
-
1
]
=
valueAttrVal
;
}
mCurrentLine
.
mIndentation
.
mHeader
.
AppendInt
(
mOLStack
[
mOLStackIndex
-
1
]
+
+
10
)
;
}
else
{
mCurrentLine
.
mIndentation
.
mHeader
.
Append
(
char16_t
(
'
#
'
)
)
;
}
mCurrentLine
.
mIndentation
.
mHeader
.
Append
(
char16_t
(
'
.
'
)
)
;
}
else
{
static
const
char
bulletCharArray
[
]
=
"
*
o
+
#
"
;
uint32_t
index
=
mULCount
>
0
?
(
mULCount
-
1
)
:
3
;
char
bulletChar
=
bulletCharArray
[
index
%
4
]
;
mCurrentLine
.
mIndentation
.
mHeader
.
Append
(
char16_t
(
bulletChar
)
)
;
}
mCurrentLine
.
mIndentation
.
mHeader
.
Append
(
char16_t
(
'
'
)
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
dl
)
{
EnsureVerticalSpace
(
1
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
dt
)
{
EnsureVerticalSpace
(
0
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
dd
)
{
EnsureVerticalSpace
(
0
)
;
mCurrentLine
.
mIndentation
.
mLength
+
=
kIndentSizeDD
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
span
)
{
+
+
mSpanLevel
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
blockquote
)
{
PushBool
(
mIsInCiteBlockquote
isInCiteBlockquote
)
;
if
(
isInCiteBlockquote
)
{
EnsureVerticalSpace
(
0
)
;
mCurrentLine
.
mCiteQuoteLevel
+
+
;
}
else
{
EnsureVerticalSpace
(
1
)
;
mCurrentLine
.
mIndentation
.
mLength
+
=
kTabSize
;
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
q
)
{
Write
(
NS_LITERAL_STRING
(
"
\
"
"
)
)
;
}
else
if
(
IsCssBlockLevelElement
(
mElement
)
)
{
EnsureVerticalSpace
(
0
)
;
}
if
(
!
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
return
NS_OK
;
}
const
bool
currentNodeIsConverted
=
IsCurrentNodeConverted
(
)
;
if
(
aTag
=
=
nsGkAtoms
:
:
h1
|
|
aTag
=
=
nsGkAtoms
:
:
h2
|
|
aTag
=
=
nsGkAtoms
:
:
h3
|
|
aTag
=
=
nsGkAtoms
:
:
h4
|
|
aTag
=
=
nsGkAtoms
:
:
h5
|
|
aTag
=
=
nsGkAtoms
:
:
h6
)
{
EnsureVerticalSpace
(
2
)
;
if
(
mSettings
.
GetHeaderStrategy
(
)
=
=
Settings
:
:
HeaderStrategy
:
:
kNumberHeadingsAndIndentSlightly
)
{
mCurrentLine
.
mIndentation
.
mLength
+
=
kIndentSizeHeaders
;
int32_t
level
=
HeaderLevel
(
aTag
)
;
mHeaderCounter
[
level
]
+
+
;
int32_t
i
;
for
(
i
=
level
+
1
;
i
<
=
6
;
i
+
+
)
{
mHeaderCounter
[
i
]
=
0
;
}
nsAutoString
leadup
;
for
(
i
=
1
;
i
<
=
level
;
i
+
+
)
{
leadup
.
AppendInt
(
mHeaderCounter
[
i
]
)
;
leadup
.
Append
(
char16_t
(
'
.
'
)
)
;
}
leadup
.
Append
(
char16_t
(
'
'
)
)
;
Write
(
leadup
)
;
}
else
if
(
mSettings
.
GetHeaderStrategy
(
)
=
=
Settings
:
:
HeaderStrategy
:
:
kIndentIncreasedWithHeaderLevel
)
{
mCurrentLine
.
mIndentation
.
mLength
+
=
kIndentSizeHeaders
;
for
(
int32_t
i
=
HeaderLevel
(
aTag
)
;
i
>
1
;
i
-
-
)
{
mCurrentLine
.
mIndentation
.
mLength
+
=
kIndentIncrementHeaders
;
}
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
sup
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
^
"
)
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
sub
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
_
"
)
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
code
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
|
"
)
)
;
}
else
if
(
(
aTag
=
=
nsGkAtoms
:
:
strong
|
|
aTag
=
=
nsGkAtoms
:
:
b
)
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
*
"
)
)
;
}
else
if
(
(
aTag
=
=
nsGkAtoms
:
:
em
|
|
aTag
=
=
nsGkAtoms
:
:
i
)
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
/
"
)
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
u
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
_
"
)
)
;
}
mInWhitespace
=
true
;
return
NS_OK
;
}
nsresult
nsPlainTextSerializer
:
:
DoCloseContainer
(
nsAtom
*
aTag
)
{
if
(
IsIgnorableRubyAnnotation
(
aTag
)
)
{
mIgnoredChildNodeLevel
-
-
;
return
NS_OK
;
}
if
(
IsIgnorableScriptOrStyle
(
mElement
)
)
{
mIgnoredChildNodeLevel
-
-
;
return
NS_OK
;
}
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputForPlainTextClipboardCopy
)
)
{
if
(
DoOutput
(
)
&
&
IsElementPreformatted
(
)
&
&
IsCssBlockLevelElement
(
mElement
)
)
{
mPreformattedBlockBoundary
=
true
;
}
}
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputRaw
)
)
{
return
NS_OK
;
}
if
(
mTagStackIndex
>
0
)
{
-
-
mTagStackIndex
;
}
if
(
mTagStackIndex
>
=
mIgnoreAboveIndex
)
{
if
(
mTagStackIndex
=
=
mIgnoreAboveIndex
)
{
mIgnoreAboveIndex
=
(
uint32_t
)
kNotFound
;
}
return
NS_OK
;
}
MOZ_ASSERT
(
mOutputManager
)
;
if
(
(
aTag
=
=
nsGkAtoms
:
:
body
)
|
|
(
aTag
=
=
nsGkAtoms
:
:
html
)
)
{
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
EnsureVerticalSpace
(
0
)
;
}
else
{
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
}
return
NS_OK
;
}
if
(
!
DoOutput
(
)
)
{
return
NS_OK
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
tr
)
{
PopBool
(
mHasWrittenCellsForRow
)
;
if
(
mFloatingLines
<
0
)
mFloatingLines
=
0
;
mLineBreakDue
=
true
;
}
else
if
(
(
(
aTag
=
=
nsGkAtoms
:
:
li
)
|
|
(
aTag
=
=
nsGkAtoms
:
:
dt
)
)
&
&
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
if
(
mFloatingLines
<
0
)
mFloatingLines
=
0
;
mLineBreakDue
=
true
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
pre
)
{
mFloatingLines
=
GetLastBool
(
mIsInCiteBlockquote
)
?
0
:
1
;
mLineBreakDue
=
true
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
ul
)
{
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
mCurrentLine
.
mIndentation
.
mLength
-
=
kIndentSizeList
;
if
(
-
-
mULCount
+
mOLStackIndex
=
=
0
)
{
mFloatingLines
=
1
;
mLineBreakDue
=
true
;
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
ol
)
{
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
mCurrentLine
.
mIndentation
.
mLength
-
=
kIndentSizeList
;
NS_ASSERTION
(
mOLStackIndex
"
Wrong
OLStack
level
!
"
)
;
mOLStackIndex
-
-
;
if
(
mULCount
+
mOLStackIndex
=
=
0
)
{
mFloatingLines
=
1
;
mLineBreakDue
=
true
;
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
dl
)
{
mFloatingLines
=
1
;
mLineBreakDue
=
true
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
dd
)
{
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
mCurrentLine
.
mIndentation
.
mLength
-
=
kIndentSizeDD
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
span
)
{
NS_ASSERTION
(
mSpanLevel
"
Span
level
will
be
negative
!
"
)
;
-
-
mSpanLevel
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
div
)
{
if
(
mFloatingLines
<
0
)
mFloatingLines
=
0
;
mLineBreakDue
=
true
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
blockquote
)
{
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
bool
isInCiteBlockquote
=
PopBool
(
mIsInCiteBlockquote
)
;
if
(
isInCiteBlockquote
)
{
NS_ASSERTION
(
mCurrentLine
.
mCiteQuoteLevel
"
CiteQuote
level
will
be
negative
!
"
)
;
mCurrentLine
.
mCiteQuoteLevel
-
-
;
mFloatingLines
=
0
;
mHasWrittenCiteBlockquote
=
true
;
}
else
{
mCurrentLine
.
mIndentation
.
mLength
-
=
kTabSize
;
mFloatingLines
=
1
;
}
mLineBreakDue
=
true
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
q
)
{
Write
(
NS_LITERAL_STRING
(
"
\
"
"
)
)
;
}
else
if
(
IsCssBlockLevelElement
(
mElement
)
)
{
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
EnsureVerticalSpace
(
1
)
;
}
else
{
if
(
mFloatingLines
<
0
)
mFloatingLines
=
0
;
mLineBreakDue
=
true
;
}
}
if
(
!
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
return
NS_OK
;
}
const
bool
currentNodeIsConverted
=
IsCurrentNodeConverted
(
)
;
if
(
aTag
=
=
nsGkAtoms
:
:
h1
|
|
aTag
=
=
nsGkAtoms
:
:
h2
|
|
aTag
=
=
nsGkAtoms
:
:
h3
|
|
aTag
=
=
nsGkAtoms
:
:
h4
|
|
aTag
=
=
nsGkAtoms
:
:
h5
|
|
aTag
=
=
nsGkAtoms
:
:
h6
)
{
using
HeaderStrategy
=
Settings
:
:
HeaderStrategy
;
if
(
(
mSettings
.
GetHeaderStrategy
(
)
=
=
HeaderStrategy
:
:
kIndentIncreasedWithHeaderLevel
)
|
|
(
mSettings
.
GetHeaderStrategy
(
)
=
=
HeaderStrategy
:
:
kNumberHeadingsAndIndentSlightly
)
)
{
mCurrentLine
.
mIndentation
.
mLength
-
=
kIndentSizeHeaders
;
}
if
(
mSettings
.
GetHeaderStrategy
(
)
=
=
HeaderStrategy
:
:
kIndentIncreasedWithHeaderLevel
)
{
for
(
int32_t
i
=
HeaderLevel
(
aTag
)
;
i
>
1
;
i
-
-
)
{
mCurrentLine
.
mIndentation
.
mLength
-
=
kIndentIncrementHeaders
;
}
}
EnsureVerticalSpace
(
1
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
a
&
&
!
currentNodeIsConverted
)
{
nsAutoString
url
;
if
(
NS_SUCCEEDED
(
GetAttributeValue
(
nsGkAtoms
:
:
href
url
)
)
&
&
!
url
.
IsEmpty
(
)
)
{
nsAutoString
temp
;
temp
.
AssignLiteral
(
"
<
"
)
;
temp
+
=
url
;
temp
.
Append
(
char16_t
(
'
>
'
)
)
;
Write
(
temp
)
;
}
}
else
if
(
(
aTag
=
=
nsGkAtoms
:
:
sup
|
|
aTag
=
=
nsGkAtoms
:
:
sub
)
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
kSpace
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
code
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
|
"
)
)
;
}
else
if
(
(
aTag
=
=
nsGkAtoms
:
:
strong
|
|
aTag
=
=
nsGkAtoms
:
:
b
)
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
*
"
)
)
;
}
else
if
(
(
aTag
=
=
nsGkAtoms
:
:
em
|
|
aTag
=
=
nsGkAtoms
:
:
i
)
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
/
"
)
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
u
&
&
mSettings
.
GetStructs
(
)
&
&
!
currentNodeIsConverted
)
{
Write
(
NS_LITERAL_STRING
(
"
_
"
)
)
;
}
return
NS_OK
;
}
bool
nsPlainTextSerializer
:
:
MustSuppressLeaf
(
)
const
{
if
(
mIgnoredChildNodeLevel
>
0
)
{
return
true
;
}
if
(
(
mTagStackIndex
>
1
&
&
mTagStack
[
mTagStackIndex
-
2
]
=
=
nsGkAtoms
:
:
select
)
|
|
(
mTagStackIndex
>
0
&
&
mTagStack
[
mTagStackIndex
-
1
]
=
=
nsGkAtoms
:
:
select
)
)
{
return
true
;
}
return
false
;
}
void
nsPlainTextSerializer
:
:
DoAddText
(
)
{
DoAddText
(
true
EmptyString
(
)
)
;
}
void
nsPlainTextSerializer
:
:
DoAddText
(
bool
aIsLineBreak
const
nsAString
&
aText
)
{
if
(
!
DoOutput
(
)
)
{
return
;
}
if
(
!
aIsLineBreak
)
{
mHasWrittenCiteBlockquote
=
false
;
}
if
(
mLineBreakDue
)
EnsureVerticalSpace
(
mFloatingLines
)
;
if
(
MustSuppressLeaf
(
)
)
{
return
;
}
if
(
aIsLineBreak
)
{
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputPreformatted
)
|
|
(
mPreFormattedMail
&
&
!
mWrapColumn
)
|
|
IsElementPreformatted
(
)
)
{
EnsureVerticalSpace
(
mEmptyLines
+
1
)
;
}
else
if
(
!
mInWhitespace
)
{
Write
(
kSpace
)
;
mInWhitespace
=
true
;
}
return
;
}
Write
(
aText
)
;
}
void
CreateLineOfDashes
(
nsAString
&
aResult
const
uint32_t
aWrapColumn
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
const
uint32_t
width
=
(
aWrapColumn
>
0
?
aWrapColumn
:
25
)
;
while
(
aResult
.
Length
(
)
<
width
)
{
aResult
.
Append
(
char16_t
(
'
-
'
)
)
;
}
}
nsresult
nsPlainTextSerializer
:
:
DoAddLeaf
(
nsAtom
*
aTag
)
{
mPreformattedBlockBoundary
=
false
;
if
(
!
DoOutput
(
)
)
{
return
NS_OK
;
}
if
(
mLineBreakDue
)
EnsureVerticalSpace
(
mFloatingLines
)
;
if
(
MustSuppressLeaf
(
)
)
{
return
NS_OK
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
br
)
{
HTMLBRElement
*
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
mElement
)
;
if
(
!
brElement
|
|
!
brElement
-
>
IsPaddingForEmptyLastLine
(
)
)
{
EnsureVerticalSpace
(
mEmptyLines
+
1
)
;
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
hr
&
&
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatted
)
)
{
EnsureVerticalSpace
(
0
)
;
nsAutoString
line
;
CreateLineOfDashes
(
line
mWrapColumn
)
;
Write
(
line
)
;
EnsureVerticalSpace
(
0
)
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
img
)
{
nsAutoString
imageDescription
;
if
(
NS_SUCCEEDED
(
GetAttributeValue
(
nsGkAtoms
:
:
alt
imageDescription
)
)
)
{
}
else
if
(
NS_SUCCEEDED
(
GetAttributeValue
(
nsGkAtoms
:
:
title
imageDescription
)
)
&
&
!
imageDescription
.
IsEmpty
(
)
)
{
imageDescription
=
NS_LITERAL_STRING
(
"
[
"
)
+
imageDescription
+
NS_LITERAL_STRING
(
"
]
"
)
;
}
Write
(
imageDescription
)
;
}
return
NS_OK
;
}
void
nsPlainTextSerializer
:
:
EnsureVerticalSpace
(
int32_t
noOfRows
)
{
if
(
noOfRows
>
=
0
&
&
!
mCurrentLine
.
mIndentation
.
mHeader
.
IsEmpty
(
)
)
{
EndLine
(
false
)
;
mInWhitespace
=
true
;
}
while
(
mEmptyLines
<
noOfRows
)
{
EndLine
(
false
)
;
mInWhitespace
=
true
;
}
mLineBreakDue
=
false
;
mFloatingLines
=
-
1
;
}
void
nsPlainTextSerializer
:
:
OutputManager
:
:
Flush
(
CurrentLine
&
aCurrentLine
)
{
if
(
!
aCurrentLine
.
mContent
.
IsEmpty
(
)
)
{
aCurrentLine
.
MaybeReplaceNbspsInContent
(
mFlags
)
;
Append
(
aCurrentLine
StripTrailingWhitespaces
:
:
kNo
)
;
aCurrentLine
.
ResetContentAndIndentationHeader
(
)
;
}
}
static
bool
IsSpaceStuffable
(
const
char16_t
*
s
)
{
return
(
s
[
0
]
=
=
'
>
'
|
|
s
[
0
]
=
=
'
'
|
|
s
[
0
]
=
=
kNBSP
|
|
NS_strncmp
(
s
u
"
From
"
5
)
=
=
0
)
;
}
void
nsPlainTextSerializer
:
:
MaybeWrapAndOutputCompleteLines
(
)
{
if
(
!
MayWrap
(
)
)
{
return
;
}
const
uint32_t
prefixwidth
=
mCurrentLine
.
DeterminePrefixWidth
(
)
;
int32_t
linelength
=
mCurrentLine
.
mContent
.
Length
(
)
;
uint32_t
currentLineContentWidth
=
GetUnicharStringWidth
(
mCurrentLine
.
mContent
)
;
uint32_t
bonuswidth
=
(
mWrapColumn
>
20
)
?
4
:
0
;
while
(
currentLineContentWidth
+
prefixwidth
>
mWrapColumn
+
bonuswidth
)
{
int32_t
goodSpace
=
mCurrentLine
.
mContent
.
Length
(
)
;
if
(
mLineBreaker
)
{
uint32_t
width
=
currentLineContentWidth
;
while
(
goodSpace
>
0
&
&
(
width
+
prefixwidth
>
mWrapColumn
)
)
{
goodSpace
-
-
;
width
-
=
GetUnicharWidth
(
mCurrentLine
.
mContent
[
goodSpace
]
)
;
}
goodSpace
+
+
;
goodSpace
=
mLineBreaker
-
>
Prev
(
mCurrentLine
.
mContent
.
get
(
)
mCurrentLine
.
mContent
.
Length
(
)
goodSpace
)
;
if
(
goodSpace
!
=
NS_LINEBREAKER_NEED_MORE_TEXT
&
&
nsCRT
:
:
IsAsciiSpace
(
mCurrentLine
.
mContent
.
CharAt
(
goodSpace
-
1
)
)
)
{
-
-
goodSpace
;
}
}
else
{
if
(
mCurrentLine
.
mContent
.
IsEmpty
(
)
|
|
mWrapColumn
<
prefixwidth
)
{
goodSpace
=
NS_LINEBREAKER_NEED_MORE_TEXT
;
}
else
{
goodSpace
=
std
:
:
min
(
mWrapColumn
-
prefixwidth
mCurrentLine
.
mContent
.
Length
(
)
-
1
)
;
while
(
goodSpace
>
=
0
&
&
!
nsCRT
:
:
IsAsciiSpace
(
mCurrentLine
.
mContent
.
CharAt
(
goodSpace
)
)
)
{
goodSpace
-
-
;
}
}
}
nsAutoString
restOfLine
;
if
(
goodSpace
=
=
NS_LINEBREAKER_NEED_MORE_TEXT
)
{
goodSpace
=
(
prefixwidth
>
mWrapColumn
+
1
)
?
1
:
mWrapColumn
-
prefixwidth
+
1
;
if
(
mLineBreaker
)
{
if
(
(
uint32_t
)
goodSpace
<
mCurrentLine
.
mContent
.
Length
(
)
)
goodSpace
=
mLineBreaker
-
>
Next
(
mCurrentLine
.
mContent
.
get
(
)
mCurrentLine
.
mContent
.
Length
(
)
goodSpace
)
;
if
(
goodSpace
=
=
NS_LINEBREAKER_NEED_MORE_TEXT
)
goodSpace
=
mCurrentLine
.
mContent
.
Length
(
)
;
}
else
{
goodSpace
=
(
prefixwidth
>
mWrapColumn
)
?
1
:
mWrapColumn
-
prefixwidth
;
while
(
goodSpace
<
linelength
&
&
!
nsCRT
:
:
IsAsciiSpace
(
mCurrentLine
.
mContent
.
CharAt
(
goodSpace
)
)
)
{
goodSpace
+
+
;
}
}
}
if
(
(
goodSpace
<
linelength
)
&
&
(
goodSpace
>
0
)
)
{
if
(
nsCRT
:
:
IsAsciiSpace
(
mCurrentLine
.
mContent
.
CharAt
(
goodSpace
)
)
)
{
mCurrentLine
.
mContent
.
Right
(
restOfLine
linelength
-
goodSpace
-
1
)
;
}
else
{
mCurrentLine
.
mContent
.
Right
(
restOfLine
linelength
-
goodSpace
)
;
}
const
bool
breakBySpace
=
mCurrentLine
.
mContent
.
CharAt
(
goodSpace
)
=
=
'
'
;
mCurrentLine
.
mContent
.
Truncate
(
goodSpace
)
;
EndLine
(
true
breakBySpace
)
;
mCurrentLine
.
mContent
.
Truncate
(
)
;
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
)
{
if
(
!
restOfLine
.
IsEmpty
(
)
&
&
IsSpaceStuffable
(
restOfLine
.
get
(
)
)
&
&
mCurrentLine
.
mCiteQuoteLevel
=
=
0
)
{
mCurrentLine
.
mContent
.
Append
(
char16_t
(
'
'
)
)
;
}
}
mCurrentLine
.
mContent
.
Append
(
restOfLine
)
;
currentLineContentWidth
=
GetUnicharStringWidth
(
mCurrentLine
.
mContent
)
;
linelength
=
mCurrentLine
.
mContent
.
Length
(
)
;
mEmptyLines
=
-
1
;
}
else
{
break
;
}
}
}
void
nsPlainTextSerializer
:
:
AddToLine
(
const
char16_t
*
aLineFragment
int32_t
aLineFragmentLength
)
{
if
(
mLineBreakDue
)
EnsureVerticalSpace
(
mFloatingLines
)
;
if
(
mCurrentLine
.
mContent
.
IsEmpty
(
)
)
{
if
(
0
=
=
aLineFragmentLength
)
{
return
;
}
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
)
{
if
(
IsSpaceStuffable
(
aLineFragment
)
&
&
mCurrentLine
.
mCiteQuoteLevel
=
=
0
)
{
mCurrentLine
.
mContent
.
Append
(
char16_t
(
'
'
)
)
;
}
}
mEmptyLines
=
-
1
;
}
mCurrentLine
.
mContent
.
Append
(
aLineFragment
aLineFragmentLength
)
;
MaybeWrapAndOutputCompleteLines
(
)
;
}
const
char
kSignatureSeparator
[
]
=
"
-
-
"
;
const
char
kDashEscapedSignatureSeparator
[
]
=
"
-
-
-
"
;
static
bool
IsSignatureSeparator
(
const
nsAString
&
aString
)
{
return
aString
.
EqualsLiteral
(
kSignatureSeparator
)
|
|
aString
.
EqualsLiteral
(
kDashEscapedSignatureSeparator
)
;
}
void
nsPlainTextSerializer
:
:
EndLine
(
bool
aSoftLineBreak
bool
aBreakBySpace
)
{
if
(
aSoftLineBreak
&
&
mCurrentLine
.
mContent
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputPreformatted
)
&
&
(
aSoftLineBreak
|
|
!
IsSignatureSeparator
(
mCurrentLine
.
mContent
)
)
)
{
mCurrentLine
.
mContent
.
Trim
(
"
"
false
true
false
)
;
}
if
(
aSoftLineBreak
&
&
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
&
&
(
mCurrentLine
.
mIndentation
.
mLength
=
=
0
)
)
{
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatDelSp
)
&
&
aBreakBySpace
)
{
mCurrentLine
.
mContent
.
AppendLiteral
(
"
"
)
;
}
else
{
mCurrentLine
.
mContent
.
Append
(
char16_t
(
'
'
)
)
;
}
}
if
(
aSoftLineBreak
)
{
mEmptyLines
=
0
;
}
else
{
if
(
mCurrentLine
.
HasContentOrIndentationHeader
(
)
)
{
mEmptyLines
=
0
;
}
else
{
mEmptyLines
+
+
;
}
}
MOZ_ASSERT
(
mOutputManager
)
;
mCurrentLine
.
MaybeReplaceNbspsInContent
(
mSettings
.
GetFlags
(
)
)
;
mOutputManager
-
>
Append
(
mCurrentLine
OutputManager
:
:
StripTrailingWhitespaces
:
:
kMaybe
)
;
mOutputManager
-
>
AppendLineBreak
(
)
;
mCurrentLine
.
ResetContentAndIndentationHeader
(
)
;
mInWhitespace
=
true
;
mLineBreakDue
=
false
;
mFloatingLines
=
-
1
;
}
void
nsPlainTextSerializer
:
:
CurrentLine
:
:
CreateQuotesAndIndent
(
nsAString
&
aResult
)
const
{
if
(
mCiteQuoteLevel
>
0
)
{
nsAutoString
quotes
;
for
(
int
i
=
0
;
i
<
mCiteQuoteLevel
;
i
+
+
)
{
quotes
.
Append
(
char16_t
(
'
>
'
)
)
;
}
if
(
!
mContent
.
IsEmpty
(
)
)
{
quotes
.
Append
(
char16_t
(
'
'
)
)
;
}
aResult
=
quotes
;
}
int32_t
indentwidth
=
mIndentation
.
mLength
-
mIndentation
.
mHeader
.
Length
(
)
;
if
(
indentwidth
>
0
&
&
HasContentOrIndentationHeader
(
)
)
{
nsAutoString
spaces
;
for
(
int
i
=
0
;
i
<
indentwidth
;
+
+
i
)
spaces
.
Append
(
char16_t
(
'
'
)
)
;
aResult
+
=
spaces
;
}
if
(
!
mIndentation
.
mHeader
.
IsEmpty
(
)
)
{
aResult
+
=
mIndentation
.
mHeader
;
}
}
static
bool
IsLineFeedCarriageReturnBlankOrTab
(
char16_t
c
)
{
return
(
'
\
n
'
=
=
c
|
|
'
\
r
'
=
=
c
|
|
'
'
=
=
c
|
|
'
\
t
'
=
=
c
)
;
}
static
void
ReplaceVisiblyTrailingNbsps
(
nsAString
&
aString
)
{
const
int32_t
totLen
=
aString
.
Length
(
)
;
for
(
int32_t
i
=
totLen
-
1
;
i
>
=
0
;
i
-
-
)
{
char16_t
c
=
aString
[
i
]
;
if
(
IsLineFeedCarriageReturnBlankOrTab
(
c
)
)
{
continue
;
}
if
(
kNBSP
=
=
c
)
{
aString
.
Replace
(
i
1
'
'
)
;
}
else
{
break
;
}
}
}
void
nsPlainTextSerializer
:
:
ConvertToLinesAndOutput
(
const
nsAString
&
aString
)
{
const
int32_t
totLen
=
aString
.
Length
(
)
;
int32_t
newline
{
0
}
;
int32_t
bol
=
0
;
while
(
bol
<
totLen
)
{
bool
outputLineBreak
=
false
;
bool
spacesOnly
=
true
;
nsAString
:
:
const_iterator
iter
;
aString
.
BeginReading
(
iter
)
;
nsAString
:
:
const_iterator
done_searching
;
aString
.
EndReading
(
done_searching
)
;
iter
.
advance
(
bol
)
;
int32_t
new_newline
=
bol
;
newline
=
kNotFound
;
while
(
iter
!
=
done_searching
)
{
if
(
'
\
n
'
=
=
*
iter
|
|
'
\
r
'
=
=
*
iter
)
{
newline
=
new_newline
;
break
;
}
if
(
'
'
!
=
*
iter
)
{
spacesOnly
=
false
;
}
+
+
new_newline
;
+
+
iter
;
}
nsAutoString
stringpart
;
if
(
newline
=
=
kNotFound
)
{
stringpart
.
Assign
(
Substring
(
aString
bol
totLen
-
bol
)
)
;
if
(
!
stringpart
.
IsEmpty
(
)
)
{
char16_t
lastchar
=
stringpart
.
Last
(
)
;
mInWhitespace
=
IsLineFeedCarriageReturnBlankOrTab
(
lastchar
)
;
}
mEmptyLines
=
-
1
;
bol
=
totLen
;
}
else
{
stringpart
.
Assign
(
Substring
(
aString
bol
newline
-
bol
)
)
;
mInWhitespace
=
true
;
outputLineBreak
=
true
;
mEmptyLines
=
0
;
bol
=
newline
+
1
;
if
(
'
\
r
'
=
=
*
iter
&
&
bol
<
totLen
&
&
'
\
n
'
=
=
*
+
+
iter
)
{
bol
+
+
;
}
}
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
)
{
if
(
(
outputLineBreak
|
|
!
spacesOnly
)
&
&
!
IsQuotedLine
(
stringpart
)
&
&
!
IsSignatureSeparator
(
stringpart
)
)
{
stringpart
.
Trim
(
"
"
false
true
true
)
;
}
if
(
IsSpaceStuffable
(
stringpart
.
get
(
)
)
&
&
!
IsQuotedLine
(
stringpart
)
)
{
mCurrentLine
.
mContent
.
Append
(
char16_t
(
'
'
)
)
;
}
}
mCurrentLine
.
mContent
.
Append
(
stringpart
)
;
mCurrentLine
.
MaybeReplaceNbspsInContent
(
mSettings
.
GetFlags
(
)
)
;
mOutputManager
-
>
Append
(
mCurrentLine
OutputManager
:
:
StripTrailingWhitespaces
:
:
kNo
)
;
if
(
outputLineBreak
)
{
mOutputManager
-
>
AppendLineBreak
(
)
;
}
mCurrentLine
.
ResetContentAndIndentationHeader
(
)
;
}
#
ifdef
DEBUG_wrapping
printf
(
"
No
wrapping
:
newline
is
%
d
totLen
is
%
d
\
n
"
newline
totLen
)
;
#
endif
}
void
nsPlainTextSerializer
:
:
Write
(
const
nsAString
&
aStr
)
{
nsAutoString
str
(
aStr
)
;
#
ifdef
DEBUG_wrapping
printf
(
"
Write
(
%
s
)
:
wrap
col
=
%
d
\
n
"
NS_ConvertUTF16toUTF8
(
str
)
.
get
(
)
mWrapColumn
)
;
#
endif
const
int32_t
totLen
=
str
.
Length
(
)
;
if
(
totLen
<
=
0
)
return
;
if
(
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputFormatFlowed
)
)
{
ReplaceVisiblyTrailingNbsps
(
str
)
;
}
if
(
(
mPreFormattedMail
&
&
!
mWrapColumn
)
|
|
(
IsElementPreformatted
(
)
&
&
!
mPreFormattedMail
)
|
|
(
mSpanLevel
>
0
&
&
mEmptyLines
>
=
0
&
&
IsQuotedLine
(
str
)
)
)
{
NS_ASSERTION
(
mCurrentLine
.
mContent
.
IsEmpty
(
)
|
|
(
IsElementPreformatted
(
)
&
&
!
mPreFormattedMail
)
"
Mixed
wrapping
data
and
nonwrapping
data
on
the
same
line
"
)
;
MOZ_ASSERT
(
mOutputManager
)
;
if
(
!
mCurrentLine
.
mContent
.
IsEmpty
(
)
)
{
mOutputManager
-
>
Flush
(
mCurrentLine
)
;
}
ConvertToLinesAndOutput
(
str
)
;
return
;
}
int32_t
nextpos
;
const
char16_t
*
offsetIntoBuffer
=
nullptr
;
int32_t
bol
=
0
;
while
(
bol
<
totLen
)
{
nextpos
=
str
.
FindCharInSet
(
"
\
t
\
n
\
r
"
bol
)
;
#
ifdef
DEBUG_wrapping
nsAutoString
remaining
;
str
.
Right
(
remaining
totLen
-
bol
)
;
foo
=
ToNewCString
(
remaining
)
;
free
(
foo
)
;
#
endif
if
(
nextpos
=
=
kNotFound
)
{
offsetIntoBuffer
=
str
.
get
(
)
+
bol
;
AddToLine
(
offsetIntoBuffer
totLen
-
bol
)
;
bol
=
totLen
;
mInWhitespace
=
false
;
}
else
{
if
(
nextpos
!
=
0
&
&
(
nextpos
+
1
)
<
totLen
)
{
offsetIntoBuffer
=
str
.
get
(
)
+
nextpos
;
if
(
offsetIntoBuffer
[
0
]
=
=
'
\
n
'
&
&
IS_CJ_CHAR
(
offsetIntoBuffer
[
-
1
]
)
&
&
IS_CJ_CHAR
(
offsetIntoBuffer
[
1
]
)
)
{
offsetIntoBuffer
=
str
.
get
(
)
+
bol
;
AddToLine
(
offsetIntoBuffer
nextpos
-
bol
)
;
bol
=
nextpos
+
1
;
continue
;
}
}
if
(
mInWhitespace
&
&
(
nextpos
=
=
bol
)
&
&
!
mPreFormattedMail
&
&
!
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputPreformatted
)
)
{
bol
+
+
;
continue
;
}
if
(
nextpos
=
=
bol
)
{
mInWhitespace
=
true
;
offsetIntoBuffer
=
str
.
get
(
)
+
nextpos
;
AddToLine
(
offsetIntoBuffer
1
)
;
bol
+
+
;
continue
;
}
mInWhitespace
=
true
;
offsetIntoBuffer
=
str
.
get
(
)
+
bol
;
if
(
mPreFormattedMail
|
|
mSettings
.
HasFlag
(
nsIDocumentEncoder
:
:
OutputPreformatted
)
)
{
nextpos
+
+
;
AddToLine
(
offsetIntoBuffer
nextpos
-
bol
)
;
bol
=
nextpos
;
}
else
{
AddToLine
(
offsetIntoBuffer
nextpos
-
bol
)
;
AddToLine
(
kSpace
.
get
(
)
1
)
;
bol
=
nextpos
+
1
;
}
}
}
}
nsresult
nsPlainTextSerializer
:
:
GetAttributeValue
(
nsAtom
*
aName
nsString
&
aValueRet
)
const
{
if
(
mElement
)
{
if
(
mElement
-
>
GetAttr
(
kNameSpaceID_None
aName
aValueRet
)
)
{
return
NS_OK
;
}
}
return
NS_ERROR_NOT_AVAILABLE
;
}
bool
nsPlainTextSerializer
:
:
IsCurrentNodeConverted
(
)
const
{
nsAutoString
value
;
nsresult
rv
=
GetAttributeValue
(
nsGkAtoms
:
:
_class
value
)
;
return
(
NS_SUCCEEDED
(
rv
)
&
&
(
value
.
EqualsIgnoreCase
(
"
moz
-
txt
"
7
)
|
|
value
.
EqualsIgnoreCase
(
"
\
"
moz
-
txt
"
8
)
)
)
;
}
nsAtom
*
nsPlainTextSerializer
:
:
GetIdForContent
(
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsHTMLElement
(
)
)
{
return
nullptr
;
}
nsAtom
*
localName
=
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
return
localName
-
>
IsStatic
(
)
?
localName
:
nullptr
;
}
bool
nsPlainTextSerializer
:
:
IsElementPreformatted
(
)
const
{
return
!
mPreformatStack
.
empty
(
)
&
&
mPreformatStack
.
top
(
)
;
}
bool
nsPlainTextSerializer
:
:
IsElementPreformatted
(
Element
*
aElement
)
{
RefPtr
<
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aElement
nullptr
)
;
if
(
computedStyle
)
{
const
nsStyleText
*
textStyle
=
computedStyle
-
>
StyleText
(
)
;
return
textStyle
-
>
WhiteSpaceOrNewlineIsSignificant
(
)
;
}
return
GetIdForContent
(
aElement
)
=
=
nsGkAtoms
:
:
pre
;
}
bool
nsPlainTextSerializer
:
:
IsCssBlockLevelElement
(
Element
*
aElement
)
{
RefPtr
<
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aElement
nullptr
)
;
if
(
computedStyle
)
{
const
nsStyleDisplay
*
displayStyle
=
computedStyle
-
>
StyleDisplay
(
)
;
return
displayStyle
-
>
IsBlockOutsideStyle
(
)
;
}
return
nsContentUtils
:
:
IsHTMLBlockLevelElement
(
aElement
)
;
}
bool
nsPlainTextSerializer
:
:
IsInOL
(
)
const
{
int32_t
i
=
mTagStackIndex
;
while
(
-
-
i
>
=
0
)
{
if
(
mTagStack
[
i
]
=
=
nsGkAtoms
:
:
ol
)
return
true
;
if
(
mTagStack
[
i
]
=
=
nsGkAtoms
:
:
ul
)
{
return
false
;
}
}
return
false
;
}
int32_t
HeaderLevel
(
nsAtom
*
aTag
)
{
if
(
aTag
=
=
nsGkAtoms
:
:
h1
)
{
return
1
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
h2
)
{
return
2
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
h3
)
{
return
3
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
h4
)
{
return
4
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
h5
)
{
return
5
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
h6
)
{
return
6
;
}
return
0
;
}
namespace
{
struct
interval
{
uint16_t
first
;
uint16_t
last
;
}
;
struct
CombiningComparator
{
const
char16_t
mUcs
;
explicit
CombiningComparator
(
char16_t
aUcs
)
:
mUcs
(
aUcs
)
{
}
int
operator
(
)
(
const
interval
&
combining
)
const
{
if
(
mUcs
>
combining
.
last
)
return
1
;
if
(
mUcs
<
combining
.
first
)
return
-
1
;
MOZ_ASSERT
(
combining
.
first
<
=
mUcs
)
;
MOZ_ASSERT
(
mUcs
<
=
combining
.
last
)
;
return
0
;
}
}
;
}
int32_t
GetUnicharWidth
(
char16_t
ucs
)
{
static
const
interval
combining
[
]
=
{
{
0x0300
0x034E
}
{
0x0360
0x0362
}
{
0x0483
0x0486
}
{
0x0488
0x0489
}
{
0x0591
0x05A1
}
{
0x05A3
0x05B9
}
{
0x05BB
0x05BD
}
{
0x05BF
0x05BF
}
{
0x05C1
0x05C2
}
{
0x05C4
0x05C4
}
{
0x064B
0x0655
}
{
0x0670
0x0670
}
{
0x06D6
0x06E4
}
{
0x06E7
0x06E8
}
{
0x06EA
0x06ED
}
{
0x0711
0x0711
}
{
0x0730
0x074A
}
{
0x07A6
0x07B0
}
{
0x0901
0x0902
}
{
0x093C
0x093C
}
{
0x0941
0x0948
}
{
0x094D
0x094D
}
{
0x0951
0x0954
}
{
0x0962
0x0963
}
{
0x0981
0x0981
}
{
0x09BC
0x09BC
}
{
0x09C1
0x09C4
}
{
0x09CD
0x09CD
}
{
0x09E2
0x09E3
}
{
0x0A02
0x0A02
}
{
0x0A3C
0x0A3C
}
{
0x0A41
0x0A42
}
{
0x0A47
0x0A48
}
{
0x0A4B
0x0A4D
}
{
0x0A70
0x0A71
}
{
0x0A81
0x0A82
}
{
0x0ABC
0x0ABC
}
{
0x0AC1
0x0AC5
}
{
0x0AC7
0x0AC8
}
{
0x0ACD
0x0ACD
}
{
0x0B01
0x0B01
}
{
0x0B3C
0x0B3C
}
{
0x0B3F
0x0B3F
}
{
0x0B41
0x0B43
}
{
0x0B4D
0x0B4D
}
{
0x0B56
0x0B56
}
{
0x0B82
0x0B82
}
{
0x0BC0
0x0BC0
}
{
0x0BCD
0x0BCD
}
{
0x0C3E
0x0C40
}
{
0x0C46
0x0C48
}
{
0x0C4A
0x0C4D
}
{
0x0C55
0x0C56
}
{
0x0CBF
0x0CBF
}
{
0x0CC6
0x0CC6
}
{
0x0CCC
0x0CCD
}
{
0x0D41
0x0D43
}
{
0x0D4D
0x0D4D
}
{
0x0DCA
0x0DCA
}
{
0x0DD2
0x0DD4
}
{
0x0DD6
0x0DD6
}
{
0x0E31
0x0E31
}
{
0x0E34
0x0E3A
}
{
0x0E47
0x0E4E
}
{
0x0EB1
0x0EB1
}
{
0x0EB4
0x0EB9
}
{
0x0EBB
0x0EBC
}
{
0x0EC8
0x0ECD
}
{
0x0F18
0x0F19
}
{
0x0F35
0x0F35
}
{
0x0F37
0x0F37
}
{
0x0F39
0x0F39
}
{
0x0F71
0x0F7E
}
{
0x0F80
0x0F84
}
{
0x0F86
0x0F87
}
{
0x0F90
0x0F97
}
{
0x0F99
0x0FBC
}
{
0x0FC6
0x0FC6
}
{
0x102D
0x1030
}
{
0x1032
0x1032
}
{
0x1036
0x1037
}
{
0x1039
0x1039
}
{
0x1058
0x1059
}
{
0x17B7
0x17BD
}
{
0x17C6
0x17C6
}
{
0x17C9
0x17D3
}
{
0x18A9
0x18A9
}
{
0x20D0
0x20E3
}
{
0x302A
0x302F
}
{
0x3099
0x309A
}
{
0xFB1E
0xFB1E
}
{
0xFE20
0xFE23
}
}
;
if
(
ucs
=
=
0
)
return
0
;
if
(
ucs
<
32
|
|
(
ucs
>
=
0x7f
&
&
ucs
<
0xa0
)
)
return
-
1
;
if
(
ucs
<
combining
[
0
]
.
first
)
return
1
;
size_t
idx
;
if
(
BinarySearchIf
(
combining
0
ArrayLength
(
combining
)
CombiningComparator
(
ucs
)
&
idx
)
)
{
return
0
;
}
if
(
ucs
<
0x1100
)
return
1
;
return
1
+
(
(
ucs
>
=
0x1100
&
&
ucs
<
=
0x115f
)
|
|
(
ucs
>
=
0x2e80
&
&
ucs
<
=
0xa4cf
&
&
(
ucs
&
~
0x0011
)
!
=
0x300a
&
&
ucs
!
=
0x303f
)
|
|
(
ucs
>
=
0xac00
&
&
ucs
<
=
0xd7a3
)
|
|
(
ucs
>
=
0xf900
&
&
ucs
<
=
0xfaff
)
|
|
(
ucs
>
=
0xfe30
&
&
ucs
<
=
0xfe6f
)
|
|
(
ucs
>
=
0xff00
&
&
ucs
<
=
0xff5f
)
|
|
(
ucs
>
=
0xffe0
&
&
ucs
<
=
0xffe6
)
)
;
}
int32_t
GetUnicharStringWidth
(
const
nsString
&
aString
)
{
const
char16_t
*
pwcs
=
aString
.
get
(
)
;
int32_t
n
=
aString
.
Length
(
)
;
int32_t
w
width
=
0
;
for
(
;
*
pwcs
&
&
n
-
-
>
0
;
pwcs
+
+
)
if
(
(
w
=
GetUnicharWidth
(
*
pwcs
)
)
<
0
)
+
+
width
;
else
width
+
=
w
;
return
width
;
}
