#
include
"
nsError
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsTextFormatter
.
h
"
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
include
"
xpcpublic
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
SliceBudget
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
nsIArray
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
MainThreadIdlePeriod
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
DOMExceptionBinding
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ErrorEvent
.
h
"
#
include
"
mozilla
/
dom
/
FetchUtil
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
SerializedStackHolder
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
ifdef
XP_MACOSX
#
undef
check
#
endif
#
include
"
AccessCheck
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prthread
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2DBinding
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
nsCycleCollectionNoteRootCallback
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
IdleTaskRunner
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
ifdef
CompareString
#
undef
CompareString
#
endif
static
const
TimeDuration
kCCDelay
=
TimeDuration
:
:
FromSeconds
(
6
)
;
static
const
TimeDuration
kCCSkippableDelay
=
TimeDuration
:
:
FromMilliseconds
(
250
)
;
static
const
TimeDuration
kTimeBetweenForgetSkippableCycles
=
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
TimeDuration
kForgetSkippableSliceDuration
=
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
TimeDuration
kICCIntersliceDelay
=
TimeDuration
:
:
FromMilliseconds
(
64
)
;
static
const
TimeDuration
kICCSliceBudget
=
TimeDuration
:
:
FromMilliseconds
(
3
)
;
static
const
TimeDuration
kIdleICCSliceBudget
=
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
TimeDuration
kMaxICCDuration
=
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
TimeDuration
kCCForced
=
TimeDuration
:
:
FromSeconds
(
2
*
60
)
;
static
const
uint32_t
kCCForcedPurpleLimit
=
10
;
static
const
TimeDuration
kMaxCCLockedoutTime
=
TimeDuration
:
:
FromSeconds
(
30
)
;
static
const
uint32_t
kCCPurpleLimit
=
200
;
enum
class
CCRunnerState
{
Inactive
EarlyTimer
LateTimer
FinalTimer
}
;
static
nsITimer
*
sGCTimer
;
static
nsITimer
*
sShrinkingGCTimer
;
static
StaticRefPtr
<
IdleTaskRunner
>
sCCRunner
;
static
StaticRefPtr
<
IdleTaskRunner
>
sICCRunner
;
static
nsITimer
*
sFullGCTimer
;
static
StaticRefPtr
<
IdleTaskRunner
>
sInterSliceGCRunner
;
static
TimeStamp
sLastCCEndTime
;
static
TimeStamp
sLastForgetSkippableCycleEndTime
;
static
TimeStamp
sCurrentGCStartTime
;
static
CCRunnerState
sCCRunnerState
=
CCRunnerState
:
:
Inactive
;
static
TimeDuration
sCCDelay
=
kCCDelay
;
static
bool
sCCLockedOut
;
static
TimeStamp
sCCLockedOutTime
;
static
JS
:
:
GCSliceCallback
sPrevGCSliceCallback
;
static
bool
sHasRunGC
;
static
uint32_t
sCCollectedWaitingForGC
;
static
uint32_t
sCCollectedZonesWaitingForGC
;
static
uint32_t
sLikelyShortLivingObjectsNeedingGC
;
static
int32_t
sCCRunnerEarlyFireCount
=
0
;
static
uint32_t
sPreviousSuspectedCount
=
0
;
static
uint32_t
sCleanupsSinceLastGC
=
UINT32_MAX
;
static
bool
sNeedsFullCC
=
false
;
static
bool
sNeedsFullGC
=
false
;
static
bool
sNeedsGCAfterCC
=
false
;
static
bool
sIncrementalCC
=
false
;
static
TimeDuration
sActiveIntersliceGCBudget
=
TimeDuration
:
:
FromMilliseconds
(
5
)
;
static
TimeStamp
sFirstCollectionTime
;
static
bool
sIsInitialized
;
static
bool
sDidShutdown
;
static
bool
sShuttingDown
;
static
bool
sIsCompactingOnUserInactive
=
false
;
static
TimeDuration
sGCUnnotifiedTotalTime
;
struct
CycleCollectorStats
{
constexpr
CycleCollectorStats
(
)
=
default
;
void
Init
(
)
;
void
Clear
(
)
;
void
PrepareForCycleCollectionSlice
(
TimeStamp
aDeadline
=
TimeStamp
(
)
)
;
void
FinishCycleCollectionSlice
(
)
;
void
RunForgetSkippable
(
)
;
void
UpdateAfterForgetSkippable
(
TimeDuration
duration
uint32_t
aRemovedPurples
)
;
void
UpdateAfterCycleCollection
(
)
;
void
SendTelemetry
(
TimeDuration
aCCNowDuration
)
const
;
void
MaybeLogStats
(
const
CycleCollectorResults
&
aResults
uint32_t
aCleanups
)
const
;
void
MaybeNotifyStats
(
const
CycleCollectorResults
&
aResults
TimeDuration
aCCNowDuration
uint32_t
aCleanups
)
const
;
TimeStamp
mBeginSliceTime
;
TimeStamp
mEndSliceTime
;
TimeStamp
mBeginTime
;
TimeDuration
mMaxGCDuration
;
bool
mRanSyncForgetSkippable
=
false
;
uint32_t
mSuspected
=
0
;
TimeDuration
mMaxSkippableDuration
;
TimeDuration
mMaxSliceTime
;
TimeDuration
mMaxSliceTimeSinceClear
;
TimeDuration
mTotalSliceTime
;
bool
mAnyLockedOut
=
false
;
FILE
*
mFile
=
nullptr
;
TimeStamp
mIdleDeadline
;
TimeDuration
mMinForgetSkippableTime
;
TimeDuration
mMaxForgetSkippableTime
;
TimeDuration
mTotalForgetSkippableTime
;
uint32_t
mForgetSkippableBeforeCC
=
0
;
uint32_t
mRemovedPurples
=
0
;
}
;
static
CycleCollectorStats
sCCStats
;
static
const
char
*
ProcessNameForCollectorLog
(
)
{
return
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
?
"
default
"
:
"
content
"
;
}
namespace
xpc
{
void
FindExceptionStackForConsoleReport
(
nsPIDOMWindowInner
*
win
JS
:
:
HandleValue
exceptionValue
JS
:
:
HandleObject
exceptionStack
JS
:
:
MutableHandleObject
stackObj
JS
:
:
MutableHandleObject
stackGlobal
)
{
stackObj
.
set
(
nullptr
)
;
stackGlobal
.
set
(
nullptr
)
;
if
(
!
exceptionValue
.
isObject
(
)
)
{
if
(
exceptionStack
)
{
stackObj
.
set
(
exceptionStack
)
;
stackGlobal
.
set
(
JS
:
:
GetNonCCWObjectGlobal
(
exceptionStack
)
)
;
}
return
;
}
if
(
win
&
&
win
-
>
AsGlobal
(
)
-
>
IsDying
(
)
)
{
return
;
}
JS
:
:
RootingContext
*
rcx
=
RootingCx
(
)
;
JS
:
:
RootedObject
exceptionObject
(
rcx
&
exceptionValue
.
toObject
(
)
)
;
if
(
JSObject
*
excStack
=
JS
:
:
ExceptionStackOrNull
(
exceptionObject
)
)
{
JSObject
*
unwrappedException
=
js
:
:
UncheckedUnwrap
(
exceptionObject
)
;
stackObj
.
set
(
excStack
)
;
stackGlobal
.
set
(
JS
:
:
GetNonCCWObjectGlobal
(
unwrappedException
)
)
;
return
;
}
RefPtr
<
Exception
>
exception
;
UNWRAP_OBJECT
(
DOMException
exceptionObject
exception
)
;
if
(
!
exception
)
{
UNWRAP_OBJECT
(
Exception
exceptionObject
exception
)
;
if
(
!
exception
)
{
if
(
exceptionStack
)
{
stackObj
.
set
(
exceptionStack
)
;
stackGlobal
.
set
(
JS
:
:
GetNonCCWObjectGlobal
(
exceptionStack
)
)
;
}
return
;
}
}
nsCOMPtr
<
nsIStackFrame
>
stack
=
exception
-
>
GetLocation
(
)
;
if
(
!
stack
)
{
return
;
}
JS
:
:
RootedValue
value
(
rcx
)
;
stack
-
>
GetNativeSavedFrame
(
&
value
)
;
if
(
value
.
isObject
(
)
)
{
stackObj
.
set
(
&
value
.
toObject
(
)
)
;
MOZ_ASSERT
(
JS
:
:
IsUnwrappedSavedFrame
(
stackObj
)
)
;
stackGlobal
.
set
(
JS
:
:
GetNonCCWObjectGlobal
(
stackObj
)
)
;
return
;
}
}
}
static
TimeDuration
GetCollectionTimeDelta
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
sFirstCollectionTime
)
{
return
now
-
sFirstCollectionTime
;
}
sFirstCollectionTime
=
now
;
return
TimeDuration
(
)
;
}
static
void
KillTimers
(
)
{
nsJSContext
:
:
KillGCTimer
(
)
;
nsJSContext
:
:
KillShrinkingGCTimer
(
)
;
nsJSContext
:
:
KillCCRunner
(
)
;
nsJSContext
:
:
KillICCRunner
(
)
;
nsJSContext
:
:
KillFullGCTimer
(
)
;
nsJSContext
:
:
KillInterSliceGCRunner
(
)
;
}
static
bool
NeedsGCAfterCC
(
)
{
return
sCCollectedWaitingForGC
>
250
|
|
sCCollectedZonesWaitingForGC
>
0
|
|
sLikelyShortLivingObjectsNeedingGC
>
2500
|
|
sNeedsGCAfterCC
;
}
class
nsJSEnvironmentObserver
final
:
public
nsIObserver
{
~
nsJSEnvironmentObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
nsJSEnvironmentObserver
nsIObserver
)
NS_IMETHODIMP
nsJSEnvironmentObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
if
(
StaticPrefs
:
:
javascript_options_gc_on_memory_pressure
(
)
)
{
nsDependentString
data
(
aData
)
;
if
(
data
.
EqualsLiteral
(
"
low
-
memory
-
ongoing
"
)
)
{
return
NS_OK
;
}
if
(
data
.
EqualsLiteral
(
"
low
-
memory
"
)
)
{
nsJSContext
:
:
SetLowMemoryState
(
true
)
;
}
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
MEM_PRESSURE
nsJSContext
:
:
NonIncrementalGC
nsJSContext
:
:
ShrinkingGC
)
;
nsJSContext
:
:
CycleCollectNow
(
)
;
if
(
NeedsGCAfterCC
(
)
)
{
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
MEM_PRESSURE
nsJSContext
:
:
NonIncrementalGC
nsJSContext
:
:
ShrinkingGC
)
;
}
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
memory
-
pressure
-
stop
"
)
)
{
nsJSContext
:
:
SetLowMemoryState
(
false
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
user
-
interaction
-
inactive
"
)
)
{
if
(
StaticPrefs
:
:
javascript_options_compact_on_user_inactive
(
)
)
{
nsJSContext
:
:
PokeShrinkingGC
(
)
;
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
user
-
interaction
-
active
"
)
)
{
nsJSContext
:
:
KillShrinkingGCTimer
(
)
;
if
(
sIsCompactingOnUserInactive
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS
:
:
AbortIncrementalGC
(
jsapi
.
cx
(
)
)
;
}
MOZ_ASSERT
(
!
sIsCompactingOnUserInactive
)
;
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
quit
-
application
"
)
|
|
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
sShuttingDown
=
true
;
KillTimers
(
)
;
}
return
NS_OK
;
}
class
AutoFree
{
public
:
explicit
AutoFree
(
void
*
aPtr
)
:
mPtr
(
aPtr
)
{
}
~
AutoFree
(
)
{
if
(
mPtr
)
free
(
mPtr
)
;
}
void
Invalidate
(
)
{
mPtr
=
0
;
}
private
:
void
*
mPtr
;
}
;
bool
NS_HandleScriptError
(
nsIScriptGlobalObject
*
aScriptGlobal
const
ErrorEventInit
&
aErrorEventInit
nsEventStatus
*
aStatus
)
{
bool
called
=
false
;
nsCOMPtr
<
nsPIDOMWindowInner
>
win
(
do_QueryInterface
(
aScriptGlobal
)
)
;
nsIDocShell
*
docShell
=
win
?
win
-
>
GetDocShell
(
)
:
nullptr
;
if
(
docShell
)
{
RefPtr
<
nsPresContext
>
presContext
=
docShell
-
>
GetPresContext
(
)
;
static
int32_t
errorDepth
;
+
+
errorDepth
;
if
(
errorDepth
<
2
)
{
RefPtr
<
ErrorEvent
>
event
=
ErrorEvent
:
:
Constructor
(
nsGlobalWindowInner
:
:
Cast
(
win
)
NS_LITERAL_STRING
(
"
error
"
)
aErrorEventInit
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
win
nullptr
event
presContext
aStatus
)
;
called
=
true
;
}
-
-
errorDepth
;
}
return
called
;
}
class
ScriptErrorEvent
:
public
Runnable
{
public
:
ScriptErrorEvent
(
nsPIDOMWindowInner
*
aWindow
JS
:
:
RootingContext
*
aRootingCx
xpc
:
:
ErrorReport
*
aReport
JS
:
:
Handle
<
JS
:
:
Value
>
aError
JS
:
:
Handle
<
JSObject
*
>
aErrorStack
)
:
mozilla
:
:
Runnable
(
"
ScriptErrorEvent
"
)
mWindow
(
aWindow
)
mReport
(
aReport
)
mError
(
aRootingCx
aError
)
mErrorStack
(
aRootingCx
aErrorStack
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsPIDOMWindowInner
*
win
=
mWindow
;
MOZ_ASSERT
(
win
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
JS
:
:
RootingContext
*
rootingCx
=
RootingCx
(
)
;
if
(
win
-
>
IsCurrentInnerWindow
(
)
&
&
win
-
>
GetDocShell
(
)
&
&
!
sHandlingScriptError
)
{
AutoRestore
<
bool
>
recursionGuard
(
sHandlingScriptError
)
;
sHandlingScriptError
=
true
;
RefPtr
<
nsPresContext
>
presContext
=
win
-
>
GetDocShell
(
)
-
>
GetPresContext
(
)
;
RootedDictionary
<
ErrorEventInit
>
init
(
rootingCx
)
;
init
.
mCancelable
=
true
;
init
.
mFilename
=
mReport
-
>
mFileName
;
init
.
mBubbles
=
true
;
NS_NAMED_LITERAL_STRING
(
xoriginMsg
"
Script
error
.
"
)
;
if
(
!
mReport
-
>
mIsMuted
)
{
init
.
mMessage
=
mReport
-
>
mErrorMsg
;
init
.
mLineno
=
mReport
-
>
mLineNumber
;
init
.
mColno
=
mReport
-
>
mColumn
;
init
.
mError
=
mError
;
}
else
{
NS_WARNING
(
"
Not
same
origin
error
!
"
)
;
init
.
mMessage
=
xoriginMsg
;
init
.
mLineno
=
0
;
}
RefPtr
<
ErrorEvent
>
event
=
ErrorEvent
:
:
Constructor
(
nsGlobalWindowInner
:
:
Cast
(
win
)
NS_LITERAL_STRING
(
"
error
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
win
nullptr
event
presContext
&
status
)
;
}
if
(
status
!
=
nsEventStatus_eConsumeNoDefault
)
{
JS
:
:
Rooted
<
JSObject
*
>
stack
(
rootingCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
stackGlobal
(
rootingCx
)
;
xpc
:
:
FindExceptionStackForConsoleReport
(
win
mError
mErrorStack
&
stack
&
stackGlobal
)
;
mReport
-
>
LogToConsoleWithStack
(
stack
stackGlobal
JS
:
:
ExceptionTimeWarpTarget
(
mError
)
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
RefPtr
<
xpc
:
:
ErrorReport
>
mReport
;
JS
:
:
PersistentRootedValue
mError
;
JS
:
:
PersistentRootedObject
mErrorStack
;
static
bool
sHandlingScriptError
;
}
;
bool
ScriptErrorEvent
:
:
sHandlingScriptError
=
false
;
namespace
xpc
{
void
DispatchScriptErrorEvent
(
nsPIDOMWindowInner
*
win
JS
:
:
RootingContext
*
rootingCx
xpc
:
:
ErrorReport
*
xpcReport
JS
:
:
Handle
<
JS
:
:
Value
>
exception
JS
:
:
Handle
<
JSObject
*
>
exceptionStack
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
ScriptErrorEvent
(
win
rootingCx
xpcReport
exception
exceptionStack
)
)
;
}
}
#
ifdef
DEBUG
nsGlobalWindowInner
*
JSObject2Win
(
JSObject
*
obj
)
{
return
xpc
:
:
WindowOrNull
(
obj
)
;
}
template
<
typename
T
>
void
PrintWinURI
(
T
*
win
)
{
if
(
!
win
)
{
printf
(
"
No
window
passed
in
.
\
n
"
)
;
return
;
}
nsCOMPtr
<
Document
>
doc
=
win
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
printf
(
"
No
document
in
the
window
.
\
n
"
)
;
return
;
}
nsIURI
*
uri
=
doc
-
>
GetDocumentURI
(
)
;
if
(
!
uri
)
{
printf
(
"
Document
doesn
'
t
have
a
URI
.
\
n
"
)
;
return
;
}
printf
(
"
%
s
\
n
"
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
}
void
PrintWinURIInner
(
nsGlobalWindowInner
*
aWin
)
{
return
PrintWinURI
(
aWin
)
;
}
void
PrintWinURIOuter
(
nsGlobalWindowOuter
*
aWin
)
{
return
PrintWinURI
(
aWin
)
;
}
template
<
typename
T
>
void
PrintWinCodebase
(
T
*
win
)
{
if
(
!
win
)
{
printf
(
"
No
window
passed
in
.
\
n
"
)
;
return
;
}
nsIPrincipal
*
prin
=
win
-
>
GetPrincipal
(
)
;
if
(
!
prin
)
{
printf
(
"
Window
doesn
'
t
have
principals
.
\
n
"
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
prin
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
!
uri
)
{
printf
(
"
No
URI
maybe
the
system
principal
.
\
n
"
)
;
return
;
}
printf
(
"
%
s
\
n
"
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
}
void
PrintWinCodebaseInner
(
nsGlobalWindowInner
*
aWin
)
{
return
PrintWinCodebase
(
aWin
)
;
}
void
PrintWinCodebaseOuter
(
nsGlobalWindowOuter
*
aWin
)
{
return
PrintWinCodebase
(
aWin
)
;
}
void
DumpString
(
const
nsAString
&
str
)
{
printf
(
"
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
str
)
.
get
(
)
)
;
}
#
endif
nsJSContext
:
:
nsJSContext
(
bool
aGCOnDestruction
nsIScriptGlobalObject
*
aGlobalObject
)
:
mWindowProxy
(
nullptr
)
mGCOnDestruction
(
aGCOnDestruction
)
mGlobalObjectRef
(
aGlobalObject
)
{
EnsureStatics
(
)
;
mProcessingScriptTag
=
false
;
HoldJSObjects
(
this
)
;
}
nsJSContext
:
:
~
nsJSContext
(
)
{
mGlobalObjectRef
=
nullptr
;
Destroy
(
)
;
}
void
nsJSContext
:
:
Destroy
(
)
{
if
(
mGCOnDestruction
)
{
PokeGC
(
JS
:
:
GCReason
:
:
NSJSCONTEXT_DESTROY
mWindowProxy
)
;
}
DropJSObjects
(
this
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsJSContext
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsJSContext
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mWindowProxy
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsJSContext
)
tmp
-
>
mGCOnDestruction
=
false
;
tmp
-
>
mWindowProxy
=
nullptr
;
tmp
-
>
Destroy
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGlobalObjectRef
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsJSContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobalObjectRef
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsJSContext
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptContext
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsJSContext
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsJSContext
)
#
ifdef
DEBUG
bool
AtomIsEventHandlerName
(
nsAtom
*
aName
)
{
const
char16_t
*
name
=
aName
-
>
GetUTF16String
(
)
;
const
char16_t
*
cp
;
char16_t
c
;
for
(
cp
=
name
;
*
cp
!
=
'
\
0
'
;
+
+
cp
)
{
c
=
*
cp
;
if
(
(
c
<
'
A
'
|
|
c
>
'
Z
'
)
&
&
(
c
<
'
a
'
|
|
c
>
'
z
'
)
)
return
false
;
}
return
true
;
}
#
endif
nsIScriptGlobalObject
*
nsJSContext
:
:
GetGlobalObject
(
)
{
if
(
!
mWindowProxy
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mGlobalObjectRef
)
;
return
mGlobalObjectRef
;
}
nsresult
nsJSContext
:
:
SetProperty
(
JS
:
:
Handle
<
JSObject
*
>
aTarget
const
char
*
aPropName
nsISupports
*
aArgs
)
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
GetGlobalObject
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
RootedVector
<
JS
:
:
Value
>
args
(
cx
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
GetWindowProxy
(
)
)
;
nsresult
rv
=
ConvertSupportsTojsvals
(
cx
aArgs
global
&
args
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
args
.
length
(
)
;
+
+
i
)
{
if
(
!
JS_WrapValue
(
cx
args
[
i
]
)
)
{
return
NS_ERROR_FAILURE
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
array
(
cx
:
:
JS_NewArrayObject
(
cx
args
)
)
;
if
(
!
array
)
{
return
NS_ERROR_FAILURE
;
}
return
JS_DefineProperty
(
cx
aTarget
aPropName
array
0
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
nsJSContext
:
:
ConvertSupportsTojsvals
(
JSContext
*
aCx
nsISupports
*
aArgs
JS
:
:
Handle
<
JSObject
*
>
aScope
JS
:
:
MutableHandleVector
<
JS
:
:
Value
>
aArgsOut
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIJSArgArray
>
fastArray
=
do_QueryInterface
(
aArgs
)
;
if
(
fastArray
)
{
uint32_t
argc
;
JS
:
:
Value
*
argv
;
rv
=
fastArray
-
>
GetArgs
(
&
argc
reinterpret_cast
<
void
*
*
>
(
&
argv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
aArgsOut
.
append
(
argv
argc
)
)
{
rv
=
NS_ERROR_OUT_OF_MEMORY
;
}
return
rv
;
}
nsIXPConnect
*
xpc
=
nsContentUtils
:
:
XPConnect
(
)
;
NS_ENSURE_TRUE
(
xpc
NS_ERROR_UNEXPECTED
)
;
if
(
!
aArgs
)
return
NS_OK
;
uint32_t
argCount
;
nsCOMPtr
<
nsIArray
>
argsArray
(
do_QueryInterface
(
aArgs
)
)
;
if
(
argsArray
)
{
rv
=
argsArray
-
>
GetLength
(
&
argCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
argCount
=
=
0
)
return
NS_OK
;
}
else
{
argCount
=
1
;
}
if
(
!
aArgsOut
.
resize
(
argCount
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
argsArray
)
{
for
(
uint32_t
argCtr
=
0
;
argCtr
<
argCount
&
&
NS_SUCCEEDED
(
rv
)
;
argCtr
+
+
)
{
nsCOMPtr
<
nsISupports
>
arg
;
JS
:
:
MutableHandle
<
JS
:
:
Value
>
thisVal
=
aArgsOut
[
argCtr
]
;
argsArray
-
>
QueryElementAt
(
argCtr
NS_GET_IID
(
nsISupports
)
getter_AddRefs
(
arg
)
)
;
if
(
!
arg
)
{
thisVal
.
setNull
(
)
;
continue
;
}
nsCOMPtr
<
nsIVariant
>
variant
(
do_QueryInterface
(
arg
)
)
;
if
(
variant
!
=
nullptr
)
{
rv
=
xpc
-
>
VariantToJS
(
aCx
aScope
variant
thisVal
)
;
}
else
{
rv
=
AddSupportsPrimitiveTojsvals
(
aCx
arg
thisVal
.
address
(
)
)
;
if
(
rv
=
=
NS_ERROR_NO_INTERFACE
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsISupportsPrimitive
>
prim
(
do_QueryInterface
(
arg
)
)
;
NS_ASSERTION
(
prim
=
=
nullptr
"
Don
'
t
pass
nsISupportsPrimitives
-
use
nsIVariant
!
"
)
;
#
endif
JSAutoRealm
ar
(
aCx
aScope
)
;
rv
=
nsContentUtils
:
:
WrapNative
(
aCx
arg
thisVal
)
;
}
}
}
}
else
{
nsCOMPtr
<
nsIVariant
>
variant
=
do_QueryInterface
(
aArgs
)
;
if
(
variant
)
{
rv
=
xpc
-
>
VariantToJS
(
aCx
aScope
variant
aArgsOut
[
0
]
)
;
}
else
{
NS_ERROR
(
"
Not
an
array
not
an
interface
?
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
}
}
return
rv
;
}
nsresult
nsJSContext
:
:
AddSupportsPrimitiveTojsvals
(
JSContext
*
aCx
nsISupports
*
aArg
JS
:
:
Value
*
aArgv
)
{
MOZ_ASSERT
(
aArg
"
Empty
arg
"
)
;
nsCOMPtr
<
nsISupportsPrimitive
>
argPrimitive
(
do_QueryInterface
(
aArg
)
)
;
if
(
!
argPrimitive
)
return
NS_ERROR_NO_INTERFACE
;
uint16_t
type
;
argPrimitive
-
>
GetType
(
&
type
)
;
switch
(
type
)
{
case
nsISupportsPrimitive
:
:
TYPE_CSTRING
:
{
nsCOMPtr
<
nsISupportsCString
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
nsAutoCString
data
;
p
-
>
GetData
(
data
)
;
JSString
*
str
=
:
:
JS_NewStringCopyN
(
aCx
data
.
get
(
)
data
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
str
NS_ERROR_OUT_OF_MEMORY
)
;
aArgv
-
>
setString
(
str
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_STRING
:
{
nsCOMPtr
<
nsISupportsString
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
nsAutoString
data
;
p
-
>
GetData
(
data
)
;
JSString
*
str
=
:
:
JS_NewUCStringCopyN
(
aCx
data
.
get
(
)
data
.
Length
(
)
)
;
NS_ENSURE_TRUE
(
str
NS_ERROR_OUT_OF_MEMORY
)
;
aArgv
-
>
setString
(
str
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_PRBOOL
:
{
nsCOMPtr
<
nsISupportsPRBool
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
bool
data
;
p
-
>
GetData
(
&
data
)
;
aArgv
-
>
setBoolean
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_PRUINT8
:
{
nsCOMPtr
<
nsISupportsPRUint8
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
uint8_t
data
;
p
-
>
GetData
(
&
data
)
;
aArgv
-
>
setInt32
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_PRUINT16
:
{
nsCOMPtr
<
nsISupportsPRUint16
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
uint16_t
data
;
p
-
>
GetData
(
&
data
)
;
aArgv
-
>
setInt32
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_PRUINT32
:
{
nsCOMPtr
<
nsISupportsPRUint32
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
uint32_t
data
;
p
-
>
GetData
(
&
data
)
;
aArgv
-
>
setInt32
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_CHAR
:
{
nsCOMPtr
<
nsISupportsChar
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
char
data
;
p
-
>
GetData
(
&
data
)
;
JSString
*
str
=
:
:
JS_NewStringCopyN
(
aCx
&
data
1
)
;
NS_ENSURE_TRUE
(
str
NS_ERROR_OUT_OF_MEMORY
)
;
aArgv
-
>
setString
(
str
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_PRINT16
:
{
nsCOMPtr
<
nsISupportsPRInt16
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
int16_t
data
;
p
-
>
GetData
(
&
data
)
;
aArgv
-
>
setInt32
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_PRINT32
:
{
nsCOMPtr
<
nsISupportsPRInt32
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
int32_t
data
;
p
-
>
GetData
(
&
data
)
;
aArgv
-
>
setInt32
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_FLOAT
:
{
nsCOMPtr
<
nsISupportsFloat
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
float
data
;
p
-
>
GetData
(
&
data
)
;
*
aArgv
=
:
:
JS_NumberValue
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_DOUBLE
:
{
nsCOMPtr
<
nsISupportsDouble
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
double
data
;
p
-
>
GetData
(
&
data
)
;
*
aArgv
=
:
:
JS_NumberValue
(
data
)
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_INTERFACE_POINTER
:
{
nsCOMPtr
<
nsISupportsInterfacePointer
>
p
(
do_QueryInterface
(
argPrimitive
)
)
;
NS_ENSURE_TRUE
(
p
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsISupports
>
data
;
nsIID
*
iid
=
nullptr
;
p
-
>
GetData
(
getter_AddRefs
(
data
)
)
;
p
-
>
GetDataIID
(
&
iid
)
;
NS_ENSURE_TRUE
(
iid
NS_ERROR_UNEXPECTED
)
;
AutoFree
iidGuard
(
iid
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
aCx
GetWindowProxy
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
)
;
JSAutoRealm
ar
(
aCx
scope
)
;
nsresult
rv
=
nsContentUtils
:
:
WrapNative
(
aCx
data
iid
&
v
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aArgv
=
v
;
break
;
}
case
nsISupportsPrimitive
:
:
TYPE_ID
:
case
nsISupportsPrimitive
:
:
TYPE_PRUINT64
:
case
nsISupportsPrimitive
:
:
TYPE_PRINT64
:
case
nsISupportsPrimitive
:
:
TYPE_PRTIME
:
{
NS_WARNING
(
"
Unsupported
primitive
type
used
"
)
;
aArgv
-
>
setNull
(
)
;
break
;
}
default
:
{
NS_WARNING
(
"
Unknown
primitive
type
used
"
)
;
aArgv
-
>
setNull
(
)
;
break
;
}
}
return
NS_OK
;
}
#
ifdef
MOZ_JPROF
#
include
<
signal
.
h
>
inline
bool
IsJProfAction
(
struct
sigaction
*
action
)
{
return
(
action
-
>
sa_sigaction
&
&
(
action
-
>
sa_flags
&
(
SA_RESTART
|
SA_SIGINFO
)
)
=
=
(
SA_RESTART
|
SA_SIGINFO
)
)
;
}
void
NS_JProfStartProfiling
(
)
;
void
NS_JProfStopProfiling
(
)
;
void
NS_JProfClearCircular
(
)
;
static
bool
JProfStartProfilingJS
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
NS_JProfStartProfiling
(
)
;
return
true
;
}
void
NS_JProfStartProfiling
(
)
{
struct
sigaction
action
;
sigaction
(
SIGALRM
nullptr
&
action
)
;
if
(
IsJProfAction
(
&
action
)
)
{
raise
(
SIGALRM
)
;
return
;
}
sigaction
(
SIGPROF
nullptr
&
action
)
;
if
(
IsJProfAction
(
&
action
)
)
{
raise
(
SIGPROF
)
;
return
;
}
sigaction
(
SIGPOLL
nullptr
&
action
)
;
if
(
IsJProfAction
(
&
action
)
)
{
raise
(
SIGPOLL
)
;
return
;
}
printf
(
"
Could
not
start
jprof
-
profiling
since
JPROF_FLAGS
was
not
set
.
\
n
"
)
;
}
static
bool
JProfStopProfilingJS
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
NS_JProfStopProfiling
(
)
;
return
true
;
}
void
NS_JProfStopProfiling
(
)
{
raise
(
SIGUSR1
)
;
}
static
bool
JProfClearCircularJS
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
NS_JProfClearCircular
(
)
;
return
true
;
}
void
NS_JProfClearCircular
(
)
{
raise
(
SIGUSR2
)
;
}
static
bool
JProfSaveCircularJS
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
NS_JProfStopProfiling
(
)
;
NS_JProfStartProfiling
(
)
;
return
true
;
}
static
const
JSFunctionSpec
JProfFunctions
[
]
=
{
JS_FN
(
"
JProfStartProfiling
"
JProfStartProfilingJS
0
0
)
JS_FN
(
"
JProfStopProfiling
"
JProfStopProfilingJS
0
0
)
JS_FN
(
"
JProfClearCircular
"
JProfClearCircularJS
0
0
)
JS_FN
(
"
JProfSaveCircular
"
JProfSaveCircularJS
0
0
)
JS_FS_END
}
;
#
endif
nsresult
nsJSContext
:
:
InitClasses
(
JS
:
:
Handle
<
JSObject
*
>
aGlobalObj
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSAutoRealm
ar
(
cx
aGlobalObj
)
;
#
ifdef
MOZ_JPROF
:
:
JS_DefineFunctions
(
cx
aGlobalObj
JProfFunctions
)
;
#
endif
return
NS_OK
;
}
bool
nsJSContext
:
:
GetProcessingScriptTag
(
)
{
return
mProcessingScriptTag
;
}
void
nsJSContext
:
:
SetProcessingScriptTag
(
bool
aFlag
)
{
mProcessingScriptTag
=
aFlag
;
}
void
FullGCTimerFired
(
nsITimer
*
aTimer
void
*
aClosure
)
{
nsJSContext
:
:
KillFullGCTimer
(
)
;
MOZ_ASSERT
(
!
aClosure
"
Don
'
t
pass
a
closure
to
FullGCTimerFired
"
)
;
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
FULL_GC_TIMER
nsJSContext
:
:
IncrementalGC
)
;
}
void
nsJSContext
:
:
SetLowMemoryState
(
bool
aState
)
{
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
JS
:
:
SetLowMemoryState
(
cx
aState
)
;
}
void
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
aReason
IsIncremental
aIncremental
IsShrinking
aShrinking
int64_t
aSliceMillis
)
{
AUTO_PROFILER_LABEL_DYNAMIC_CSTR_NONSENSITIVE
(
"
nsJSContext
:
:
GarbageCollectNow
"
GCCC
JS
:
:
ExplainGCReason
(
aReason
)
)
;
MOZ_ASSERT_IF
(
aSliceMillis
aIncremental
=
=
IncrementalGC
)
;
KillGCTimer
(
)
;
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
if
(
!
nsContentUtils
:
:
XPConnect
(
)
|
|
!
cx
)
{
return
;
}
if
(
sCCLockedOut
&
&
aIncremental
=
=
IncrementalGC
)
{
JS
:
:
PrepareForIncrementalGC
(
cx
)
;
JS
:
:
IncrementalGCSlice
(
cx
aReason
aSliceMillis
)
;
return
;
}
JSGCInvocationKind
gckind
=
aShrinking
=
=
ShrinkingGC
?
GC_SHRINK
:
GC_NORMAL
;
if
(
aIncremental
=
=
NonIncrementalGC
|
|
aReason
=
=
JS
:
:
GCReason
:
:
FULL_GC_TIMER
)
{
sNeedsFullGC
=
true
;
}
if
(
sNeedsFullGC
)
{
JS
:
:
PrepareForFullGC
(
cx
)
;
}
if
(
aIncremental
=
=
IncrementalGC
)
{
JS
:
:
StartIncrementalGC
(
cx
gckind
aReason
aSliceMillis
)
;
}
else
{
JS
:
:
NonIncrementalGC
(
cx
gckind
aReason
)
;
}
}
static
void
FinishAnyIncrementalGC
(
)
{
AUTO_PROFILER_LABEL
(
"
FinishAnyIncrementalGC
"
GCCC
)
;
if
(
sCCLockedOut
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS
:
:
PrepareForIncrementalGC
(
jsapi
.
cx
(
)
)
;
JS
:
:
FinishIncrementalGC
(
jsapi
.
cx
(
)
JS
:
:
GCReason
:
:
CC_FORCED
)
;
}
}
static
inline
js
:
:
SliceBudget
BudgetFromDuration
(
TimeDuration
duration
)
{
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
duration
.
ToMilliseconds
(
)
)
)
;
}
static
void
FireForgetSkippable
(
uint32_t
aSuspected
bool
aRemoveChildless
TimeStamp
aDeadline
)
{
AUTO_PROFILER_TRACING
(
"
CC
"
aDeadline
.
IsNull
(
)
?
"
ForgetSkippable
"
:
"
IdleForgetSkippable
"
GCCC
)
;
TimeStamp
startTimeStamp
=
TimeStamp
:
:
Now
(
)
;
static
uint32_t
sForgetSkippableCounter
=
0
;
static
TimeStamp
sForgetSkippableFrequencyStartTime
;
static
TimeStamp
sLastForgetSkippableEndTime
;
static
const
TimeDuration
minute
=
TimeDuration
:
:
FromSeconds
(
60
.
0f
)
;
if
(
sForgetSkippableFrequencyStartTime
.
IsNull
(
)
)
{
sForgetSkippableFrequencyStartTime
=
startTimeStamp
;
}
else
if
(
startTimeStamp
-
sForgetSkippableFrequencyStartTime
>
minute
)
{
TimeStamp
startPlusMinute
=
sForgetSkippableFrequencyStartTime
+
minute
;
TimeStamp
endPoint
=
startPlusMinute
>
sLastForgetSkippableEndTime
?
startPlusMinute
:
sLastForgetSkippableEndTime
;
double
duration
=
(
endPoint
-
sForgetSkippableFrequencyStartTime
)
.
ToSeconds
(
)
/
60
;
uint32_t
frequencyPerMinute
=
uint32_t
(
sForgetSkippableCounter
/
duration
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FORGET_SKIPPABLE_FREQUENCY
frequencyPerMinute
)
;
sForgetSkippableCounter
=
0
;
sForgetSkippableFrequencyStartTime
=
startTimeStamp
;
}
+
+
sForgetSkippableCounter
;
FinishAnyIncrementalGC
(
)
;
bool
earlyForgetSkippable
=
sCleanupsSinceLastGC
<
kMajorForgetSkippableCalls
;
TimeDuration
budgetTime
=
aDeadline
?
(
aDeadline
-
TimeStamp
:
:
Now
(
)
)
:
kForgetSkippableSliceDuration
;
js
:
:
SliceBudget
budget
=
BudgetFromDuration
(
budgetTime
)
;
nsCycleCollector_forgetSkippable
(
budget
aRemoveChildless
earlyForgetSkippable
)
;
sPreviousSuspectedCount
=
nsCycleCollector_suspectedCount
(
)
;
+
+
sCleanupsSinceLastGC
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
sLastForgetSkippableEndTime
=
now
;
TimeDuration
duration
=
now
-
startTimeStamp
;
uint32_t
removedPurples
=
aSuspected
-
sPreviousSuspectedCount
;
sCCStats
.
UpdateAfterForgetSkippable
(
duration
removedPurples
)
;
if
(
duration
.
ToSeconds
(
)
)
{
TimeDuration
idleDuration
;
if
(
!
aDeadline
.
IsNull
(
)
)
{
if
(
aDeadline
<
now
)
{
if
(
aDeadline
>
startTimeStamp
)
{
idleDuration
=
aDeadline
-
startTimeStamp
;
}
}
else
{
idleDuration
=
duration
;
}
}
uint32_t
percent
=
uint32_t
(
idleDuration
.
ToSeconds
(
)
/
duration
.
ToSeconds
(
)
*
100
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FORGET_SKIPPABLE_DURING_IDLE
percent
)
;
}
}
MOZ_ALWAYS_INLINE
static
TimeDuration
TimeBetween
(
TimeStamp
start
TimeStamp
end
)
{
MOZ_ASSERT
(
end
>
=
start
)
;
return
end
-
start
;
}
static
TimeDuration
TimeUntilNow
(
TimeStamp
start
)
{
if
(
start
.
IsNull
(
)
)
{
return
TimeDuration
(
)
;
}
return
TimeBetween
(
start
TimeStamp
:
:
Now
(
)
)
;
}
void
CycleCollectorStats
:
:
Init
(
)
{
Clear
(
)
;
char
*
env
=
getenv
(
"
MOZ_CCTIMER
"
)
;
if
(
!
env
)
{
return
;
}
if
(
strcmp
(
env
"
none
"
)
=
=
0
)
{
mFile
=
nullptr
;
}
else
if
(
strcmp
(
env
"
stdout
"
)
=
=
0
)
{
mFile
=
stdout
;
}
else
if
(
strcmp
(
env
"
stderr
"
)
=
=
0
)
{
mFile
=
stderr
;
}
else
{
mFile
=
fopen
(
env
"
a
"
)
;
if
(
!
mFile
)
{
MOZ_CRASH
(
"
Failed
to
open
MOZ_CCTIMER
log
file
.
"
)
;
}
}
}
void
CycleCollectorStats
:
:
Clear
(
)
{
if
(
mFile
&
&
mFile
!
=
stdout
&
&
mFile
!
=
stderr
)
{
fclose
(
mFile
)
;
}
*
this
=
CycleCollectorStats
(
)
;
}
void
CycleCollectorStats
:
:
FinishCycleCollectionSlice
(
)
{
if
(
mBeginSliceTime
.
IsNull
(
)
)
{
return
;
}
mEndSliceTime
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
duration
=
mEndSliceTime
-
mBeginSliceTime
;
if
(
duration
.
ToSeconds
(
)
)
{
TimeDuration
idleDuration
;
if
(
!
mIdleDeadline
.
IsNull
(
)
)
{
if
(
mIdleDeadline
<
mEndSliceTime
)
{
idleDuration
=
mIdleDeadline
-
mBeginSliceTime
;
}
else
{
idleDuration
=
duration
;
}
}
uint32_t
percent
=
uint32_t
(
idleDuration
.
ToSeconds
(
)
/
duration
.
ToSeconds
(
)
*
100
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_SLICE_DURING_IDLE
percent
)
;
}
TimeDuration
sliceTime
=
TimeBetween
(
mBeginSliceTime
mEndSliceTime
)
;
mMaxSliceTime
=
std
:
:
max
(
mMaxSliceTime
sliceTime
)
;
mMaxSliceTimeSinceClear
=
std
:
:
max
(
mMaxSliceTimeSinceClear
sliceTime
)
;
mTotalSliceTime
+
=
sliceTime
;
mBeginSliceTime
=
TimeStamp
(
)
;
}
void
CycleCollectorStats
:
:
PrepareForCycleCollectionSlice
(
TimeStamp
aDeadline
)
{
mBeginSliceTime
=
TimeStamp
:
:
Now
(
)
;
mIdleDeadline
=
aDeadline
;
if
(
sCCLockedOut
)
{
mAnyLockedOut
=
true
;
FinishAnyIncrementalGC
(
)
;
TimeDuration
gcTime
=
TimeUntilNow
(
mBeginSliceTime
)
;
mMaxGCDuration
=
std
:
:
max
(
mMaxGCDuration
gcTime
)
;
}
}
void
CycleCollectorStats
:
:
RunForgetSkippable
(
)
{
TimeStamp
beginForgetSkippable
=
TimeStamp
:
:
Now
(
)
;
bool
ranSyncForgetSkippable
=
false
;
while
(
sCleanupsSinceLastGC
<
kMajorForgetSkippableCalls
)
{
FireForgetSkippable
(
nsCycleCollector_suspectedCount
(
)
false
TimeStamp
(
)
)
;
ranSyncForgetSkippable
=
true
;
}
if
(
ranSyncForgetSkippable
)
{
mMaxSkippableDuration
=
std
:
:
max
(
mMaxSkippableDuration
TimeUntilNow
(
beginForgetSkippable
)
)
;
mRanSyncForgetSkippable
=
true
;
}
}
void
CycleCollectorStats
:
:
UpdateAfterForgetSkippable
(
TimeDuration
duration
uint32_t
aRemovedPurples
)
{
if
(
!
mMinForgetSkippableTime
|
|
mMinForgetSkippableTime
>
duration
)
{
mMinForgetSkippableTime
=
duration
;
}
if
(
!
mMaxForgetSkippableTime
|
|
mMaxForgetSkippableTime
<
duration
)
{
mMaxForgetSkippableTime
=
duration
;
}
mTotalForgetSkippableTime
+
=
duration
;
+
+
mForgetSkippableBeforeCC
;
mRemovedPurples
+
=
aRemovedPurples
;
}
void
CycleCollectorStats
:
:
SendTelemetry
(
TimeDuration
aCCNowDuration
)
const
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_FINISH_IGC
mAnyLockedOut
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_SYNC_SKIPPABLE
mRanSyncForgetSkippable
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_FULL
aCCNowDuration
.
ToMilliseconds
(
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_MAX_PAUSE
mMaxSliceTime
.
ToMilliseconds
(
)
)
;
if
(
!
sLastCCEndTime
.
IsNull
(
)
)
{
TimeDuration
timeBetween
=
TimeBetween
(
sLastCCEndTime
mBeginTime
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CYCLE_COLLECTOR_TIME_BETWEEN
timeBetween
.
ToSeconds
(
)
)
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FORGET_SKIPPABLE_MAX
mMaxForgetSkippableTime
.
ToMilliseconds
(
)
)
;
}
void
CycleCollectorStats
:
:
MaybeLogStats
(
const
CycleCollectorResults
&
aResults
uint32_t
aCleanups
)
const
{
if
(
!
StaticPrefs
:
:
javascript_options_mem_log
(
)
&
&
!
sCCStats
.
mFile
)
{
return
;
}
TimeDuration
delta
=
GetCollectionTimeDelta
(
)
;
nsCString
mergeMsg
;
if
(
aResults
.
mMergedZones
)
{
mergeMsg
.
AssignLiteral
(
"
merged
"
)
;
}
nsCString
gcMsg
;
if
(
aResults
.
mForcedGC
)
{
gcMsg
.
AssignLiteral
(
"
forced
a
GC
"
)
;
}
const
char16_t
*
kFmt
=
u
"
CC
(
T
+
%
.
1f
)
[
%
s
-
%
i
]
max
pause
:
%
.
fms
total
time
:
%
.
fms
slices
:
%
lu
"
u
"
suspected
:
%
lu
visited
:
%
lu
RCed
and
%
lu
%
s
GCed
collected
:
%
lu
"
u
"
RCed
and
%
lu
GCed
(
%
lu
|
%
lu
|
%
lu
waiting
for
GC
)
%
s
\
n
"
u
"
ForgetSkippable
%
lu
times
before
CC
min
:
%
.
f
ms
max
:
%
.
f
ms
avg
:
"
u
"
%
.
f
ms
total
:
%
.
f
ms
max
sync
:
%
.
f
ms
removed
:
%
lu
"
;
nsString
msg
;
nsTextFormatter
:
:
ssprintf
(
msg
kFmt
delta
.
ToMicroseconds
(
)
/
PR_USEC_PER_SEC
ProcessNameForCollectorLog
(
)
getpid
(
)
mMaxSliceTime
.
ToMilliseconds
(
)
mTotalSliceTime
.
ToMilliseconds
(
)
aResults
.
mNumSlices
mSuspected
aResults
.
mVisitedRefCounted
aResults
.
mVisitedGCed
mergeMsg
.
get
(
)
aResults
.
mFreedRefCounted
aResults
.
mFreedGCed
sCCollectedWaitingForGC
sCCollectedZonesWaitingForGC
sLikelyShortLivingObjectsNeedingGC
gcMsg
.
get
(
)
mForgetSkippableBeforeCC
mMinForgetSkippableTime
.
ToMilliseconds
(
)
mMaxForgetSkippableTime
.
ToMilliseconds
(
)
mTotalForgetSkippableTime
.
ToMilliseconds
(
)
/
aCleanups
mTotalForgetSkippableTime
.
ToMilliseconds
(
)
mMaxSkippableDuration
.
ToMilliseconds
(
)
mRemovedPurples
)
;
if
(
StaticPrefs
:
:
javascript_options_mem_log
(
)
)
{
nsCOMPtr
<
nsIConsoleService
>
cs
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
cs
)
{
cs
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
}
if
(
mFile
)
{
fprintf
(
mFile
"
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
msg
)
.
get
(
)
)
;
}
}
void
CycleCollectorStats
:
:
MaybeNotifyStats
(
const
CycleCollectorResults
&
aResults
TimeDuration
aCCNowDuration
uint32_t
aCleanups
)
const
{
if
(
!
StaticPrefs
:
:
javascript_options_mem_notify
(
)
)
{
return
;
}
const
char16_t
*
kJSONFmt
=
u
"
{
\
"
timestamp
\
"
:
%
llu
"
u
"
\
"
duration
\
"
:
%
.
f
"
u
"
\
"
max_slice_pause
\
"
:
%
.
f
"
u
"
\
"
total_slice_pause
\
"
:
%
.
f
"
u
"
\
"
max_finish_gc_duration
\
"
:
%
.
f
"
u
"
\
"
max_sync_skippable_duration
\
"
:
%
.
f
"
u
"
\
"
suspected
\
"
:
%
lu
"
u
"
\
"
visited
\
"
:
{
"
u
"
\
"
RCed
\
"
:
%
lu
"
u
"
\
"
GCed
\
"
:
%
lu
}
"
u
"
\
"
collected
\
"
:
{
"
u
"
\
"
RCed
\
"
:
%
lu
"
u
"
\
"
GCed
\
"
:
%
lu
}
"
u
"
\
"
waiting_for_gc
\
"
:
%
lu
"
u
"
\
"
zones_waiting_for_gc
\
"
:
%
lu
"
u
"
\
"
short_living_objects_waiting_for_gc
\
"
:
%
lu
"
u
"
\
"
forced_gc
\
"
:
%
d
"
u
"
\
"
forget_skippable
\
"
:
{
"
u
"
\
"
times_before_cc
\
"
:
%
lu
"
u
"
\
"
min
\
"
:
%
.
f
"
u
"
\
"
max
\
"
:
%
.
f
"
u
"
\
"
avg
\
"
:
%
.
f
"
u
"
\
"
total
\
"
:
%
.
f
"
u
"
\
"
removed
\
"
:
%
lu
}
"
u
"
}
"
;
nsString
json
;
nsTextFormatter
:
:
ssprintf
(
json
kJSONFmt
PR_Now
(
)
aCCNowDuration
.
ToMilliseconds
(
)
mMaxSliceTime
.
ToMilliseconds
(
)
mTotalSliceTime
.
ToMilliseconds
(
)
mMaxGCDuration
.
ToMilliseconds
(
)
mMaxSkippableDuration
.
ToMilliseconds
(
)
mSuspected
aResults
.
mVisitedRefCounted
aResults
.
mVisitedGCed
aResults
.
mFreedRefCounted
aResults
.
mFreedGCed
sCCollectedWaitingForGC
sCCollectedZonesWaitingForGC
sLikelyShortLivingObjectsNeedingGC
aResults
.
mForcedGC
mForgetSkippableBeforeCC
mMinForgetSkippableTime
.
ToMilliseconds
(
)
mMaxForgetSkippableTime
.
ToMilliseconds
(
)
mTotalForgetSkippableTime
.
ToMilliseconds
(
)
/
aCleanups
mTotalForgetSkippableTime
.
ToMilliseconds
(
)
mRemovedPurples
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nullptr
"
cycle
-
collection
-
statistics
"
json
.
get
(
)
)
;
}
}
void
nsJSContext
:
:
CycleCollectNow
(
nsICycleCollectorListener
*
aListener
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
AUTO_PROFILER_LABEL
(
"
nsJSContext
:
:
CycleCollectNow
"
GCCC
)
;
sCCStats
.
PrepareForCycleCollectionSlice
(
TimeStamp
(
)
)
;
nsCycleCollector_collect
(
aListener
)
;
sCCStats
.
FinishCycleCollectionSlice
(
)
;
}
void
nsJSContext
:
:
RunCycleCollectorSlice
(
TimeStamp
aDeadline
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
AUTO_PROFILER_TRACING
(
"
CC
"
aDeadline
.
IsNull
(
)
?
"
CCSlice
"
:
"
IdleCCSlice
"
GCCC
)
;
AUTO_PROFILER_LABEL
(
"
nsJSContext
:
:
RunCycleCollectorSlice
"
GCCC
)
;
sCCStats
.
PrepareForCycleCollectionSlice
(
aDeadline
)
;
js
:
:
SliceBudget
budget
=
js
:
:
SliceBudget
:
:
unlimited
(
)
;
if
(
sIncrementalCC
)
{
TimeDuration
baseBudget
=
kICCSliceBudget
;
if
(
!
aDeadline
.
IsNull
(
)
)
{
baseBudget
=
aDeadline
-
TimeStamp
:
:
Now
(
)
;
}
if
(
sCCStats
.
mBeginTime
.
IsNull
(
)
)
{
budget
=
BudgetFromDuration
(
baseBudget
)
;
}
else
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
runningTime
=
TimeBetween
(
sCCStats
.
mBeginTime
now
)
;
if
(
runningTime
<
kMaxICCDuration
)
{
const
TimeDuration
maxSlice
=
TimeDuration
:
:
FromMilliseconds
(
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
)
;
double
sliceDelayMultiplier
=
TimeBetween
(
sCCStats
.
mEndSliceTime
now
)
/
kICCIntersliceDelay
;
TimeDuration
delaySliceBudget
=
std
:
:
min
(
baseBudget
.
MultDouble
(
sliceDelayMultiplier
)
maxSlice
)
;
double
percentToHalfDone
=
std
:
:
min
(
2
.
0
*
(
runningTime
/
kMaxICCDuration
)
1
.
0
)
;
TimeDuration
laterSliceBudget
=
maxSlice
.
MultDouble
(
percentToHalfDone
)
;
budget
=
BudgetFromDuration
(
std
:
:
max
(
{
delaySliceBudget
laterSliceBudget
baseBudget
}
)
)
;
}
}
}
nsCycleCollector_collectSlice
(
budget
aDeadline
.
IsNull
(
)
|
|
(
aDeadline
-
TimeStamp
:
:
Now
(
)
)
<
kICCSliceBudget
)
;
sCCStats
.
FinishCycleCollectionSlice
(
)
;
}
void
nsJSContext
:
:
RunCycleCollectorWorkSlice
(
int64_t
aWorkBudget
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
AUTO_PROFILER_LABEL
(
"
nsJSContext
:
:
RunCycleCollectorWorkSlice
"
GCCC
)
;
sCCStats
.
PrepareForCycleCollectionSlice
(
)
;
js
:
:
SliceBudget
budget
=
js
:
:
SliceBudget
(
js
:
:
WorkBudget
(
aWorkBudget
)
)
;
nsCycleCollector_collectSlice
(
budget
)
;
sCCStats
.
FinishCycleCollectionSlice
(
)
;
}
void
nsJSContext
:
:
ClearMaxCCSliceTime
(
)
{
sCCStats
.
mMaxSliceTimeSinceClear
=
TimeDuration
(
)
;
}
uint32_t
nsJSContext
:
:
GetMaxCCSliceTimeSinceClear
(
)
{
return
sCCStats
.
mMaxSliceTimeSinceClear
.
ToMilliseconds
(
)
;
}
static
bool
ICCRunnerFired
(
TimeStamp
aDeadline
)
{
if
(
sDidShutdown
)
{
return
false
;
}
if
(
sCCLockedOut
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
sCCLockedOutTime
)
{
sCCLockedOutTime
=
now
;
return
false
;
}
if
(
now
-
sCCLockedOutTime
<
kMaxCCLockedoutTime
)
{
return
false
;
}
}
nsJSContext
:
:
RunCycleCollectorSlice
(
aDeadline
)
;
return
true
;
}
void
nsJSContext
:
:
BeginCycleCollectionCallback
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sCCStats
.
mBeginTime
=
sCCStats
.
mBeginSliceTime
.
IsNull
(
)
?
TimeStamp
:
:
Now
(
)
:
sCCStats
.
mBeginSliceTime
;
sCCStats
.
mSuspected
=
nsCycleCollector_suspectedCount
(
)
;
KillCCRunner
(
)
;
sCCStats
.
RunForgetSkippable
(
)
;
MOZ_ASSERT
(
!
sICCRunner
"
Tried
to
create
a
new
ICC
timer
when
one
already
existed
.
"
)
;
if
(
sShuttingDown
)
{
return
;
}
sICCRunner
=
IdleTaskRunner
:
:
Create
(
ICCRunnerFired
"
BeginCycleCollectionCallback
:
:
ICCRunnerFired
"
kICCIntersliceDelay
.
ToMilliseconds
(
)
kIdleICCSliceBudget
.
ToMilliseconds
(
)
true
[
]
{
return
sShuttingDown
;
}
TaskCategory
:
:
GarbageCollection
)
;
}
void
nsJSContext
:
:
EndCycleCollectionCallback
(
CycleCollectorResults
&
aResults
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsJSContext
:
:
KillICCRunner
(
)
;
sCCStats
.
FinishCycleCollectionSlice
(
)
;
sCCollectedWaitingForGC
+
=
aResults
.
mFreedGCed
;
sCCollectedZonesWaitingForGC
+
=
aResults
.
mFreedJSZones
;
TimeStamp
endCCTimeStamp
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
ccNowDuration
=
TimeBetween
(
sCCStats
.
mBeginTime
endCCTimeStamp
)
;
if
(
NeedsGCAfterCC
(
)
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
javascript_options_gc_delay
(
)
>
kMaxICCDuration
.
ToMilliseconds
(
)
"
A
max
duration
ICC
shouldn
'
t
reduce
GC
delay
to
0
"
)
;
PokeGC
(
JS
:
:
GCReason
:
:
CC_WAITING
nullptr
StaticPrefs
:
:
javascript_options_gc_delay
(
)
-
std
:
:
min
(
ccNowDuration
kMaxICCDuration
)
.
ToMilliseconds
(
)
)
;
}
sCCStats
.
SendTelemetry
(
ccNowDuration
)
;
uint32_t
cleanups
=
std
:
:
max
(
sCCStats
.
mForgetSkippableBeforeCC
1u
)
;
sCCStats
.
MaybeLogStats
(
aResults
cleanups
)
;
sCCStats
.
MaybeNotifyStats
(
aResults
ccNowDuration
cleanups
)
;
sLastCCEndTime
=
endCCTimeStamp
;
sNeedsFullCC
=
false
;
sNeedsGCAfterCC
=
false
;
sCCStats
.
Clear
(
)
;
}
bool
InterSliceGCRunnerFired
(
TimeStamp
aDeadline
void
*
aData
)
{
MOZ_ASSERT
(
sActiveIntersliceGCBudget
)
;
TimeDuration
budget
=
aDeadline
.
IsNull
(
)
?
sActiveIntersliceGCBudget
*
2
:
aDeadline
-
TimeStamp
:
:
Now
(
)
;
if
(
sCCLockedOut
&
&
sCCLockedOutTime
)
{
TimeDuration
lockedTime
=
TimeStamp
:
:
Now
(
)
-
sCCLockedOutTime
;
TimeDuration
maxSliceGCBudget
=
sActiveIntersliceGCBudget
*
10
;
double
percentOfLockedTime
=
std
:
:
min
(
lockedTime
/
kMaxCCLockedoutTime
1
.
0
)
;
budget
=
std
:
:
max
(
budget
maxSliceGCBudget
.
MultDouble
(
percentOfLockedTime
)
)
;
}
TimeStamp
startTimeStamp
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
duration
=
sGCUnnotifiedTotalTime
;
uintptr_t
reason
=
reinterpret_cast
<
uintptr_t
>
(
aData
)
;
nsJSContext
:
:
GarbageCollectNow
(
aData
?
static_cast
<
JS
:
:
GCReason
>
(
reason
)
:
JS
:
:
GCReason
:
:
INTER_SLICE_GC
nsJSContext
:
:
IncrementalGC
nsJSContext
:
:
NonShrinkingGC
budget
.
ToMilliseconds
(
)
)
;
sGCUnnotifiedTotalTime
=
TimeDuration
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
sliceDuration
=
now
-
startTimeStamp
;
duration
+
=
sliceDuration
;
if
(
duration
.
ToSeconds
(
)
)
{
TimeDuration
idleDuration
;
if
(
!
aDeadline
.
IsNull
(
)
)
{
if
(
aDeadline
<
now
)
{
idleDuration
=
aDeadline
-
startTimeStamp
;
}
else
{
idleDuration
=
sliceDuration
;
}
}
uint32_t
percent
=
uint32_t
(
idleDuration
.
ToSeconds
(
)
/
duration
.
ToSeconds
(
)
*
100
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_SLICE_DURING_IDLE
percent
)
;
}
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
return
JS
:
:
IncrementalGCHasForegroundWork
(
cx
)
;
}
void
GCTimerFired
(
nsITimer
*
aTimer
void
*
aClosure
)
{
nsJSContext
:
:
KillGCTimer
(
)
;
if
(
sShuttingDown
)
{
nsJSContext
:
:
KillInterSliceGCRunner
(
)
;
return
;
}
if
(
sInterSliceGCRunner
)
{
return
;
}
sInterSliceGCRunner
=
IdleTaskRunner
:
:
Create
(
[
aClosure
]
(
TimeStamp
aDeadline
)
{
return
InterSliceGCRunnerFired
(
aDeadline
aClosure
)
;
}
"
GCTimerFired
:
:
InterSliceGCRunnerFired
"
StaticPrefs
:
:
javascript_options_gc_delay_interslice
(
)
sActiveIntersliceGCBudget
.
ToMilliseconds
(
)
true
[
]
{
return
sShuttingDown
;
}
TaskCategory
:
:
GarbageCollection
)
;
}
void
ShrinkingGCTimerFired
(
nsITimer
*
aTimer
void
*
aClosure
)
{
nsJSContext
:
:
KillShrinkingGCTimer
(
)
;
sIsCompactingOnUserInactive
=
true
;
nsJSContext
:
:
GarbageCollectNow
(
JS
:
:
GCReason
:
:
USER_INACTIVE
nsJSContext
:
:
IncrementalGC
nsJSContext
:
:
ShrinkingGC
)
;
}
static
bool
ShouldTriggerCC
(
uint32_t
aSuspected
)
{
return
sNeedsFullCC
|
|
aSuspected
>
kCCPurpleLimit
|
|
(
aSuspected
>
kCCForcedPurpleLimit
&
&
TimeUntilNow
(
sLastCCEndTime
)
>
kCCForced
)
;
}
static
inline
bool
ShouldFireForgetSkippable
(
uint32_t
aSuspected
)
{
return
(
(
sPreviousSuspectedCount
+
100
)
<
=
aSuspected
)
|
|
sCleanupsSinceLastGC
<
kMajorForgetSkippableCalls
;
}
static
inline
bool
IsLastEarlyCCTimer
(
int32_t
aCurrentFireCount
)
{
int32_t
numEarlyTimerFires
=
std
:
:
max
(
int32_t
(
sCCDelay
/
kCCSkippableDelay
)
-
2
1
)
;
return
aCurrentFireCount
>
=
numEarlyTimerFires
;
}
static
void
ActivateCCRunner
(
)
{
MOZ_ASSERT
(
sCCRunnerState
=
=
CCRunnerState
:
:
Inactive
)
;
sCCRunnerState
=
CCRunnerState
:
:
EarlyTimer
;
sCCDelay
=
kCCDelay
;
sCCRunnerEarlyFireCount
=
0
;
}
static
bool
CCRunnerFired
(
TimeStamp
aDeadline
)
{
if
(
sDidShutdown
)
{
return
false
;
}
if
(
sCCLockedOut
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
sCCLockedOutTime
)
{
sCCRunnerState
=
CCRunnerState
:
:
EarlyTimer
;
sCCRunnerEarlyFireCount
=
0
;
sCCDelay
=
kCCDelay
/
int64_t
(
3
)
;
sCCLockedOutTime
=
now
;
return
false
;
}
if
(
now
-
sCCLockedOutTime
<
kMaxCCLockedoutTime
)
{
return
false
;
}
}
bool
didDoWork
=
false
;
bool
finished
=
false
;
uint32_t
suspected
=
nsCycleCollector_suspectedCount
(
)
;
switch
(
sCCRunnerState
)
{
case
CCRunnerState
:
:
EarlyTimer
:
+
+
sCCRunnerEarlyFireCount
;
if
(
IsLastEarlyCCTimer
(
sCCRunnerEarlyFireCount
)
)
{
sCCRunnerState
=
CCRunnerState
:
:
LateTimer
;
}
if
(
ShouldFireForgetSkippable
(
suspected
)
)
{
FireForgetSkippable
(
suspected
false
aDeadline
)
;
didDoWork
=
true
;
break
;
}
if
(
aDeadline
.
IsNull
(
)
)
{
break
;
}
MOZ_ASSERT
(
!
didDoWork
)
;
sCCRunnerState
=
CCRunnerState
:
:
LateTimer
;
MOZ_FALLTHROUGH
;
case
CCRunnerState
:
:
LateTimer
:
if
(
!
ShouldTriggerCC
(
suspected
)
&
&
ShouldFireForgetSkippable
(
suspected
)
)
{
FireForgetSkippable
(
suspected
false
aDeadline
)
;
didDoWork
=
true
;
finished
=
true
;
break
;
}
FireForgetSkippable
(
suspected
true
aDeadline
)
;
didDoWork
=
true
;
if
(
!
ShouldTriggerCC
(
nsCycleCollector_suspectedCount
(
)
)
)
{
finished
=
true
;
break
;
}
sCCRunnerState
=
CCRunnerState
:
:
FinalTimer
;
if
(
!
aDeadline
.
IsNull
(
)
&
&
TimeStamp
:
:
Now
(
)
<
aDeadline
)
{
Element
:
:
ClearContentUnbinder
(
)
;
if
(
TimeStamp
:
:
Now
(
)
<
aDeadline
)
{
nsCycleCollector_doDeferredDeletion
(
)
;
}
}
break
;
case
CCRunnerState
:
:
FinalTimer
:
if
(
!
ShouldTriggerCC
(
suspected
)
&
&
ShouldFireForgetSkippable
(
suspected
)
)
{
FireForgetSkippable
(
suspected
false
aDeadline
)
;
didDoWork
=
true
;
finished
=
true
;
break
;
}
nsJSContext
:
:
RunCycleCollectorSlice
(
aDeadline
)
;
didDoWork
=
true
;
finished
=
true
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
CCRunner
state
"
)
;
}
if
(
finished
)
{
sPreviousSuspectedCount
=
0
;
nsJSContext
:
:
KillCCRunner
(
)
;
if
(
!
didDoWork
)
{
sLastForgetSkippableCycleEndTime
=
TimeStamp
:
:
Now
(
)
;
}
}
return
didDoWork
;
}
uint32_t
nsJSContext
:
:
CleanupsSinceLastGC
(
)
{
return
sCleanupsSinceLastGC
;
}
void
nsJSContext
:
:
RunNextCollectorTimer
(
JS
:
:
GCReason
aReason
mozilla
:
:
TimeStamp
aDeadline
)
{
if
(
sShuttingDown
)
{
return
;
}
if
(
sGCTimer
)
{
if
(
aReason
=
=
JS
:
:
GCReason
:
:
DOM_WINDOW_UTILS
)
{
sNeedsFullGC
=
true
;
}
GCTimerFired
(
nullptr
reinterpret_cast
<
void
*
>
(
aReason
)
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
;
if
(
sInterSliceGCRunner
)
{
sInterSliceGCRunner
-
>
SetDeadline
(
aDeadline
)
;
runnable
=
sInterSliceGCRunner
;
}
else
{
MOZ_ASSERT
(
!
sCCLockedOut
"
Don
'
t
check
the
CC
timers
if
the
CC
is
locked
out
.
"
)
;
if
(
sCCRunner
)
{
MOZ_ASSERT
(
!
sICCRunner
"
Shouldn
'
t
have
both
sCCRunner
and
sICCRunner
active
at
the
"
"
same
time
"
)
;
sCCRunner
-
>
SetDeadline
(
aDeadline
)
;
runnable
=
sCCRunner
;
}
else
if
(
sICCRunner
)
{
sICCRunner
-
>
SetDeadline
(
aDeadline
)
;
runnable
=
sICCRunner
;
}
}
if
(
runnable
)
{
runnable
-
>
Run
(
)
;
}
}
void
nsJSContext
:
:
MaybeRunNextCollectorSlice
(
nsIDocShell
*
aDocShell
JS
:
:
GCReason
aReason
)
{
if
(
!
aDocShell
|
|
!
XRE_IsContentProcess
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
aDocShell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
root
=
=
aDocShell
)
{
return
;
}
Document
*
rootDocument
=
root
-
>
GetDocument
(
)
;
if
(
!
rootDocument
|
|
rootDocument
-
>
GetReadyStateEnum
(
)
!
=
Document
:
:
READYSTATE_COMPLETE
|
|
rootDocument
-
>
IsInBackgroundWindow
(
)
)
{
return
;
}
PresShell
*
presShell
=
rootDocument
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
return
;
}
uint32_t
lastEventTime
=
0
;
vm
-
>
GetLastUserEventTime
(
lastEventTime
)
;
uint32_t
currentTime
=
PR_IntervalToMicroseconds
(
PR_IntervalNow
(
)
)
;
if
(
(
currentTime
-
lastEventTime
)
>
(
StaticPrefs
:
:
dom_events_user_interaction_interval
(
)
*
PR_USEC_PER_MSEC
)
)
{
Maybe
<
TimeStamp
>
next
=
nsRefreshDriver
:
:
GetNextTickHint
(
)
;
if
(
next
.
isSome
(
)
)
{
nsJSContext
:
:
RunNextCollectorTimer
(
aReason
next
.
value
(
)
)
;
}
}
}
void
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
aReason
JSObject
*
aObj
uint32_t
aDelay
)
{
if
(
sShuttingDown
)
{
return
;
}
if
(
aObj
)
{
JS
:
:
Zone
*
zone
=
JS
:
:
GetObjectZone
(
aObj
)
;
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
AddZoneWaitingForGC
(
zone
)
;
}
else
if
(
aReason
!
=
JS
:
:
GCReason
:
:
CC_WAITING
)
{
sNeedsFullGC
=
true
;
}
if
(
sGCTimer
|
|
sInterSliceGCRunner
)
{
return
;
}
if
(
sCCRunner
)
{
sNeedsFullCC
=
true
;
sNeedsGCAfterCC
=
true
;
return
;
}
if
(
sICCRunner
)
{
sNeedsGCAfterCC
=
true
;
return
;
}
static
bool
first
=
true
;
NS_NewTimerWithFuncCallback
(
&
sGCTimer
GCTimerFired
reinterpret_cast
<
void
*
>
(
aReason
)
aDelay
?
aDelay
:
(
first
?
StaticPrefs
:
:
javascript_options_gc_delay_first
(
)
:
StaticPrefs
:
:
javascript_options_gc_delay
(
)
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
GCTimerFired
"
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
GarbageCollection
)
)
;
first
=
false
;
}
void
nsJSContext
:
:
PokeShrinkingGC
(
)
{
if
(
sShrinkingGCTimer
|
|
sShuttingDown
)
{
return
;
}
NS_NewTimerWithFuncCallback
(
&
sShrinkingGCTimer
ShrinkingGCTimerFired
nullptr
StaticPrefs
:
:
javascript_options_compact_on_user_inactive_delay
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
ShrinkingGCTimerFired
"
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
GarbageCollection
)
)
;
}
void
nsJSContext
:
:
MaybePokeCC
(
)
{
if
(
sCCRunner
|
|
sICCRunner
|
|
!
sHasRunGC
|
|
sShuttingDown
)
{
return
;
}
if
(
sCleanupsSinceLastGC
&
&
!
sLastCCEndTime
.
IsNull
(
)
)
{
TimeDuration
sinceLastCCEnd
=
TimeUntilNow
(
sLastCCEndTime
)
;
if
(
sinceLastCCEnd
<
kCCDelay
)
{
return
;
}
}
if
(
(
sCleanupsSinceLastGC
>
kMajorForgetSkippableCalls
)
&
&
!
sLastForgetSkippableCycleEndTime
.
IsNull
(
)
)
{
TimeDuration
sinceLastForgetSkippableCycle
=
TimeUntilNow
(
sLastForgetSkippableCycleEndTime
)
;
if
(
sinceLastForgetSkippableCycle
<
kTimeBetweenForgetSkippableCycles
)
{
return
;
}
}
if
(
ShouldTriggerCC
(
nsCycleCollector_suspectedCount
(
)
)
)
{
nsCycleCollector_dispatchDeferredDeletion
(
)
;
ActivateCCRunner
(
)
;
sCCRunner
=
IdleTaskRunner
:
:
Create
(
CCRunnerFired
"
MaybePokeCC
:
:
CCRunnerFired
"
kCCSkippableDelay
.
ToMilliseconds
(
)
kForgetSkippableSliceDuration
.
ToMilliseconds
(
)
true
[
]
{
return
sShuttingDown
;
}
TaskCategory
:
:
GarbageCollection
)
;
}
}
void
nsJSContext
:
:
KillGCTimer
(
)
{
if
(
sGCTimer
)
{
sGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
sGCTimer
)
;
}
}
void
nsJSContext
:
:
KillFullGCTimer
(
)
{
if
(
sFullGCTimer
)
{
sFullGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
sFullGCTimer
)
;
}
}
void
nsJSContext
:
:
KillInterSliceGCRunner
(
)
{
if
(
sInterSliceGCRunner
)
{
sInterSliceGCRunner
-
>
Cancel
(
)
;
sInterSliceGCRunner
=
nullptr
;
}
}
void
nsJSContext
:
:
KillShrinkingGCTimer
(
)
{
if
(
sShrinkingGCTimer
)
{
sShrinkingGCTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
sShrinkingGCTimer
)
;
}
}
void
nsJSContext
:
:
KillCCRunner
(
)
{
sCCLockedOutTime
=
TimeStamp
(
)
;
sCCRunnerState
=
CCRunnerState
:
:
Inactive
;
if
(
sCCRunner
)
{
sCCRunner
-
>
Cancel
(
)
;
sCCRunner
=
nullptr
;
}
}
void
nsJSContext
:
:
KillICCRunner
(
)
{
sCCLockedOutTime
=
TimeStamp
(
)
;
if
(
sICCRunner
)
{
sICCRunner
-
>
Cancel
(
)
;
sICCRunner
=
nullptr
;
}
}
class
NotifyGCEndRunnable
:
public
Runnable
{
nsString
mMessage
;
public
:
explicit
NotifyGCEndRunnable
(
nsString
&
&
aMessage
)
:
mozilla
:
:
Runnable
(
"
NotifyGCEndRunnable
"
)
mMessage
(
std
:
:
move
(
aMessage
)
)
{
}
NS_DECL_NSIRUNNABLE
}
;
NS_IMETHODIMP
NotifyGCEndRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_OK
;
}
const
char16_t
oomMsg
[
3
]
=
{
'
{
'
'
}
'
0
}
;
const
char16_t
*
toSend
=
mMessage
.
get
(
)
?
mMessage
.
get
(
)
:
oomMsg
;
observerService
-
>
NotifyObservers
(
nullptr
"
garbage
-
collection
-
statistics
"
toSend
)
;
return
NS_OK
;
}
static
void
DOMGCSliceCallback
(
JSContext
*
aCx
JS
:
:
GCProgress
aProgress
const
JS
:
:
GCDescription
&
aDesc
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
GCs
must
run
on
the
main
thread
"
)
;
switch
(
aProgress
)
{
case
JS
:
:
GC_CYCLE_BEGIN
:
{
sCCLockedOut
=
true
;
sCurrentGCStartTime
=
TimeStamp
:
:
Now
(
)
;
break
;
}
case
JS
:
:
GC_CYCLE_END
:
{
TimeDuration
delta
=
GetCollectionTimeDelta
(
)
;
if
(
StaticPrefs
:
:
javascript_options_mem_log
(
)
)
{
nsString
gcstats
;
gcstats
.
Adopt
(
aDesc
.
formatSummaryMessage
(
aCx
)
)
;
nsAutoString
prefix
;
nsTextFormatter
:
:
ssprintf
(
prefix
u
"
GC
(
T
+
%
.
1f
)
[
%
s
-
%
i
]
"
delta
.
ToSeconds
(
)
ProcessNameForCollectorLog
(
)
getpid
(
)
)
;
nsString
msg
=
prefix
+
gcstats
;
nsCOMPtr
<
nsIConsoleService
>
cs
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
cs
)
{
cs
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
}
if
(
!
sShuttingDown
)
{
if
(
StaticPrefs
:
:
javascript_options_mem_notify
(
)
|
|
Telemetry
:
:
CanRecordExtended
(
)
)
{
nsString
json
;
json
.
Adopt
(
aDesc
.
formatJSONTelemetry
(
aCx
PR_Now
(
)
)
)
;
RefPtr
<
NotifyGCEndRunnable
>
notify
=
new
NotifyGCEndRunnable
(
std
:
:
move
(
json
)
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
GarbageCollection
notify
.
forget
(
)
)
;
}
}
sCCLockedOut
=
false
;
sIsCompactingOnUserInactive
=
false
;
nsJSContext
:
:
KillInterSliceGCRunner
(
)
;
sCCollectedWaitingForGC
=
0
;
sCCollectedZonesWaitingForGC
=
0
;
sLikelyShortLivingObjectsNeedingGC
=
0
;
sCleanupsSinceLastGC
=
0
;
sNeedsFullCC
=
true
;
sHasRunGC
=
true
;
nsJSContext
:
:
MaybePokeCC
(
)
;
if
(
aDesc
.
isZone_
)
{
if
(
!
sFullGCTimer
&
&
!
sShuttingDown
)
{
NS_NewTimerWithFuncCallback
(
&
sFullGCTimer
FullGCTimerFired
nullptr
StaticPrefs
:
:
javascript_options_gc_delay_full
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
FullGCTimerFired
"
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
GarbageCollection
)
)
;
}
}
else
{
nsJSContext
:
:
KillFullGCTimer
(
)
;
}
if
(
ShouldTriggerCC
(
nsCycleCollector_suspectedCount
(
)
)
)
{
nsCycleCollector_dispatchDeferredDeletion
(
)
;
}
if
(
!
aDesc
.
isZone_
)
{
sNeedsFullGC
=
false
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_IN_PROGRESS_MS
TimeUntilNow
(
sCurrentGCStartTime
)
.
ToMilliseconds
(
)
)
;
break
;
}
case
JS
:
:
GC_SLICE_BEGIN
:
break
;
case
JS
:
:
GC_SLICE_END
:
sGCUnnotifiedTotalTime
+
=
aDesc
.
lastSliceEnd
(
aCx
)
-
aDesc
.
lastSliceStart
(
aCx
)
;
if
(
sShuttingDown
|
|
aDesc
.
isComplete_
)
{
nsJSContext
:
:
KillInterSliceGCRunner
(
)
;
}
else
if
(
!
sInterSliceGCRunner
)
{
sInterSliceGCRunner
=
IdleTaskRunner
:
:
Create
(
[
]
(
TimeStamp
aDeadline
)
{
return
InterSliceGCRunnerFired
(
aDeadline
nullptr
)
;
}
"
DOMGCSliceCallback
:
:
InterSliceGCRunnerFired
"
StaticPrefs
:
:
javascript_options_gc_delay_interslice
(
)
sActiveIntersliceGCBudget
.
ToMilliseconds
(
)
true
[
]
{
return
sShuttingDown
;
}
TaskCategory
:
:
GarbageCollection
)
;
}
if
(
ShouldTriggerCC
(
nsCycleCollector_suspectedCount
(
)
)
)
{
nsCycleCollector_dispatchDeferredDeletion
(
)
;
}
if
(
StaticPrefs
:
:
javascript_options_mem_log
(
)
)
{
nsString
gcstats
;
gcstats
.
Adopt
(
aDesc
.
formatSliceMessage
(
aCx
)
)
;
nsAutoString
prefix
;
nsTextFormatter
:
:
ssprintf
(
prefix
u
"
[
%
s
-
%
i
]
"
ProcessNameForCollectorLog
(
)
getpid
(
)
)
;
nsString
msg
=
prefix
+
gcstats
;
nsCOMPtr
<
nsIConsoleService
>
cs
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
cs
)
{
cs
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
}
break
;
default
:
MOZ_CRASH
(
"
Unexpected
GCProgress
value
"
)
;
}
if
(
sPrevGCSliceCallback
)
{
(
*
sPrevGCSliceCallback
)
(
aCx
aProgress
aDesc
)
;
}
}
void
nsJSContext
:
:
SetWindowProxy
(
JS
:
:
Handle
<
JSObject
*
>
aWindowProxy
)
{
mWindowProxy
=
aWindowProxy
;
}
JSObject
*
nsJSContext
:
:
GetWindowProxy
(
)
{
return
mWindowProxy
;
}
void
nsJSContext
:
:
LikelyShortLivingObjectCreated
(
)
{
+
+
sLikelyShortLivingObjectsNeedingGC
;
}
void
mozilla
:
:
dom
:
:
StartupJSEnvironment
(
)
{
sGCTimer
=
sShrinkingGCTimer
=
sFullGCTimer
=
nullptr
;
sCCLockedOut
=
false
;
sCCLockedOutTime
=
TimeStamp
(
)
;
sLastCCEndTime
=
TimeStamp
(
)
;
sLastForgetSkippableCycleEndTime
=
TimeStamp
(
)
;
sHasRunGC
=
false
;
sCCollectedWaitingForGC
=
0
;
sCCollectedZonesWaitingForGC
=
0
;
sLikelyShortLivingObjectsNeedingGC
=
0
;
sNeedsFullCC
=
false
;
sNeedsFullGC
=
true
;
sNeedsGCAfterCC
=
false
;
sIsInitialized
=
false
;
sDidShutdown
=
false
;
sShuttingDown
=
false
;
sCCStats
.
Init
(
)
;
}
static
void
SetGCParameter
(
JSGCParamKey
aParam
uint32_t
aValue
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS_SetGCParameter
(
jsapi
.
cx
(
)
aParam
aValue
)
;
}
static
void
ResetGCParameter
(
JSGCParamKey
aParam
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS_ResetGCParameter
(
jsapi
.
cx
(
)
aParam
)
;
}
static
void
SetMemoryPrefChangedCallbackMB
(
const
char
*
aPrefName
void
*
aClosure
)
{
int32_t
prefMB
=
Preferences
:
:
GetInt
(
aPrefName
-
1
)
;
CheckedInt
<
int32_t
>
prefB
=
CheckedInt
<
int32_t
>
(
prefMB
)
*
1024
*
1024
;
if
(
prefB
.
isValid
(
)
&
&
prefB
.
value
(
)
>
=
0
)
{
SetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
prefB
.
value
(
)
)
;
}
else
{
ResetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
)
;
}
}
static
void
SetMemoryNurseryPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
int32_t
prefKB
=
Preferences
:
:
GetInt
(
aPrefName
-
1
)
;
CheckedInt
<
int32_t
>
prefB
=
CheckedInt
<
int32_t
>
(
prefKB
)
*
1024
;
if
(
prefB
.
isValid
(
)
&
&
prefB
.
value
(
)
>
=
0
)
{
SetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
prefB
.
value
(
)
)
;
}
else
{
ResetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
)
;
}
}
static
void
SetMemoryPrefChangedCallbackInt
(
const
char
*
aPrefName
void
*
aClosure
)
{
int32_t
pref
=
Preferences
:
:
GetInt
(
aPrefName
-
1
)
;
if
(
pref
>
=
0
&
&
pref
<
10000
)
{
SetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
pref
)
;
}
else
{
ResetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
)
;
}
}
static
void
SetMemoryPrefChangedCallbackBool
(
const
char
*
aPrefName
void
*
aClosure
)
{
bool
pref
=
Preferences
:
:
GetBool
(
aPrefName
)
;
SetGCParameter
(
(
JSGCParamKey
)
(
uintptr_t
)
aClosure
pref
)
;
}
static
void
SetMemoryGCModePrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
bool
enableZoneGC
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
mem
.
gc_per_zone
"
)
;
bool
enableIncrementalGC
=
Preferences
:
:
GetBool
(
"
javascript
.
options
.
mem
.
gc_incremental
"
)
;
JSGCMode
mode
;
if
(
enableIncrementalGC
)
{
if
(
enableZoneGC
)
{
mode
=
JSGC_MODE_ZONE_INCREMENTAL
;
}
else
{
mode
=
JSGC_MODE_INCREMENTAL
;
}
}
else
{
if
(
enableZoneGC
)
{
mode
=
JSGC_MODE_ZONE
;
}
else
{
mode
=
JSGC_MODE_GLOBAL
;
}
}
SetGCParameter
(
JSGC_MODE
mode
)
;
}
static
void
SetMemoryGCSliceTimePrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
int32_t
pref
=
Preferences
:
:
GetInt
(
aPrefName
-
1
)
;
if
(
pref
>
0
&
&
pref
<
100000
)
{
sActiveIntersliceGCBudget
=
TimeDuration
:
:
FromMilliseconds
(
pref
)
;
SetGCParameter
(
JSGC_SLICE_TIME_BUDGET_MS
pref
)
;
}
else
{
ResetGCParameter
(
JSGC_SLICE_TIME_BUDGET_MS
)
;
}
}
static
void
SetIncrementalCCPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
bool
pref
=
Preferences
:
:
GetBool
(
aPrefName
)
;
sIncrementalCC
=
pref
;
}
class
JSDispatchableRunnable
final
:
public
Runnable
{
~
JSDispatchableRunnable
(
)
{
MOZ_ASSERT
(
!
mDispatchable
)
;
}
public
:
explicit
JSDispatchableRunnable
(
JS
:
:
Dispatchable
*
aDispatchable
)
:
mozilla
:
:
Runnable
(
"
JSDispatchableRunnable
"
)
mDispatchable
(
aDispatchable
)
{
MOZ_ASSERT
(
mDispatchable
)
;
}
protected
:
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS
:
:
Dispatchable
:
:
MaybeShuttingDown
maybeShuttingDown
=
sShuttingDown
?
JS
:
:
Dispatchable
:
:
ShuttingDown
:
JS
:
:
Dispatchable
:
:
NotShuttingDown
;
mDispatchable
-
>
run
(
jsapi
.
cx
(
)
maybeShuttingDown
)
;
mDispatchable
=
nullptr
;
return
NS_OK
;
}
private
:
JS
:
:
Dispatchable
*
mDispatchable
;
}
;
static
bool
DispatchToEventLoop
(
void
*
closure
JS
:
:
Dispatchable
*
aDispatchable
)
{
MOZ_ASSERT
(
!
closure
)
;
nsCOMPtr
<
nsIEventTarget
>
mainTarget
=
GetMainThreadEventTarget
(
)
;
if
(
!
mainTarget
)
{
return
false
;
}
RefPtr
<
JSDispatchableRunnable
>
r
=
new
JSDispatchableRunnable
(
aDispatchable
)
;
MOZ_ALWAYS_SUCCEEDS
(
mainTarget
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
return
true
;
}
static
bool
ConsumeStream
(
JSContext
*
aCx
JS
:
:
HandleObject
aObj
JS
:
:
MimeType
aMimeType
JS
:
:
StreamConsumer
*
aConsumer
)
{
return
FetchUtil
:
:
StreamResponseToJS
(
aCx
aObj
aMimeType
aConsumer
nullptr
)
;
}
void
nsJSContext
:
:
EnsureStatics
(
)
{
if
(
sIsInitialized
)
{
if
(
!
nsContentUtils
:
:
XPConnect
(
)
)
{
MOZ_CRASH
(
)
;
}
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
sPrevGCSliceCallback
=
JS
:
:
SetGCSliceCallback
(
jsapi
.
cx
(
)
DOMGCSliceCallback
)
;
JS
:
:
InitDispatchToEventLoop
(
jsapi
.
cx
(
)
DispatchToEventLoop
nullptr
)
;
JS
:
:
InitConsumeStreamCallback
(
jsapi
.
cx
(
)
ConsumeStream
FetchUtil
:
:
ReportJSStreamError
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackMB
"
javascript
.
options
.
mem
.
max
"
(
void
*
)
JSGC_MAX_BYTES
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryNurseryPrefChangedCallback
"
javascript
.
options
.
mem
.
nursery
.
min_kb
"
(
void
*
)
JSGC_MIN_NURSERY_BYTES
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryNurseryPrefChangedCallback
"
javascript
.
options
.
mem
.
nursery
.
max_kb
"
(
void
*
)
JSGC_MAX_NURSERY_BYTES
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryGCModePrefChangedCallback
"
javascript
.
options
.
mem
.
gc_per_zone
"
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryGCModePrefChangedCallback
"
javascript
.
options
.
mem
.
gc_incremental
"
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryGCSliceTimePrefChangedCallback
"
javascript
.
options
.
mem
.
gc_incremental_slice_ms
"
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackBool
"
javascript
.
options
.
mem
.
gc_compacting
"
(
void
*
)
JSGC_COMPACTING_ENABLED
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_high_frequency_time_limit_ms
"
(
void
*
)
JSGC_HIGH_FREQUENCY_TIME_LIMIT
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackBool
"
javascript
.
options
.
mem
.
gc_dynamic_mark_slice
"
(
void
*
)
JSGC_DYNAMIC_MARK_SLICE
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackBool
"
javascript
.
options
.
mem
.
gc_dynamic_heap_growth
"
(
void
*
)
JSGC_DYNAMIC_HEAP_GROWTH
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_low_frequency_heap_growth
"
(
void
*
)
JSGC_LOW_FREQUENCY_HEAP_GROWTH
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_high_frequency_heap_growth_min
"
(
void
*
)
JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_high_frequency_heap_growth_max
"
(
void
*
)
JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_high_frequency_low_limit_mb
"
(
void
*
)
JSGC_HIGH_FREQUENCY_LOW_LIMIT
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_high_frequency_high_limit_mb
"
(
void
*
)
JSGC_HIGH_FREQUENCY_HIGH_LIMIT
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_allocation_threshold_mb
"
(
void
*
)
JSGC_ALLOCATION_THRESHOLD
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_non_incremental_factor
"
(
void
*
)
JSGC_NON_INCREMENTAL_FACTOR
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_avoid_interrupt_factor
"
(
void
*
)
JSGC_AVOID_INTERRUPT_FACTOR
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetIncrementalCCPrefChangedCallback
"
dom
.
cycle_collector
.
incremental
"
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_min_empty_chunk_count
"
(
void
*
)
JSGC_MIN_EMPTY_CHUNK_COUNT
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SetMemoryPrefChangedCallbackInt
"
javascript
.
options
.
mem
.
gc_max_empty_chunk_count
"
(
void
*
)
JSGC_MAX_EMPTY_CHUNK_COUNT
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
{
MOZ_CRASH
(
)
;
}
nsIObserver
*
observer
=
new
nsJSEnvironmentObserver
(
)
;
obs
-
>
AddObserver
(
observer
"
memory
-
pressure
"
false
)
;
obs
-
>
AddObserver
(
observer
"
user
-
interaction
-
inactive
"
false
)
;
obs
-
>
AddObserver
(
observer
"
user
-
interaction
-
active
"
false
)
;
obs
-
>
AddObserver
(
observer
"
quit
-
application
"
false
)
;
obs
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
sIsInitialized
=
true
;
}
void
mozilla
:
:
dom
:
:
ShutdownJSEnvironment
(
)
{
KillTimers
(
)
;
sShuttingDown
=
true
;
sDidShutdown
=
true
;
}
AsyncErrorReporter
:
:
AsyncErrorReporter
(
xpc
:
:
ErrorReport
*
aReport
)
:
Runnable
(
"
dom
:
:
AsyncErrorReporter
"
)
mReport
(
aReport
)
{
}
void
AsyncErrorReporter
:
:
SerializeStack
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aStack
)
{
mStackHolder
=
MakeUnique
<
SerializedStackHolder
>
(
)
;
mStackHolder
-
>
SerializeMainThreadOrWorkletStack
(
aCx
aStack
)
;
}
NS_IMETHODIMP
AsyncErrorReporter
:
:
Run
(
)
{
AutoJSAPI
jsapi
;
DebugOnly
<
bool
>
ok
=
jsapi
.
Init
(
xpc
:
:
UnprivilegedJunkScope
(
)
)
;
MOZ_ASSERT
(
ok
"
Problem
with
junk
scope
?
"
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
stack
(
cx
)
;
JS
:
:
Rooted
<
JSObject
*
>
stackGlobal
(
cx
)
;
if
(
mStackHolder
)
{
stack
=
mStackHolder
-
>
ReadStack
(
cx
)
;
if
(
stack
)
{
stackGlobal
=
JS
:
:
CurrentGlobalOrNull
(
cx
)
;
}
}
mReport
-
>
LogToConsoleWithStack
(
stack
stackGlobal
)
;
return
NS_OK
;
}
class
nsJSArgArray
final
:
public
nsIJSArgArray
{
public
:
nsJSArgArray
(
JSContext
*
aContext
uint32_t
argc
const
JS
:
:
Value
*
argv
nsresult
*
prv
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsJSArgArray
nsIJSArgArray
)
NS_DECL_NSIARRAY
nsresult
GetArgs
(
uint32_t
*
argc
void
*
*
argv
)
override
;
void
ReleaseJSObjects
(
)
;
protected
:
~
nsJSArgArray
(
)
;
JSContext
*
mContext
;
JS
:
:
Heap
<
JS
:
:
Value
>
*
mArgv
;
uint32_t
mArgc
;
}
;
nsJSArgArray
:
:
nsJSArgArray
(
JSContext
*
aContext
uint32_t
argc
const
JS
:
:
Value
*
argv
nsresult
*
prv
)
:
mContext
(
aContext
)
mArgv
(
nullptr
)
mArgc
(
argc
)
{
if
(
argc
)
{
mArgv
=
new
(
fallible
)
JS
:
:
Heap
<
JS
:
:
Value
>
[
argc
]
;
if
(
!
mArgv
)
{
*
prv
=
NS_ERROR_OUT_OF_MEMORY
;
return
;
}
}
if
(
argv
)
{
for
(
uint32_t
i
=
0
;
i
<
argc
;
+
+
i
)
mArgv
[
i
]
=
argv
[
i
]
;
}
if
(
argc
>
0
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
*
prv
=
NS_OK
;
}
nsJSArgArray
:
:
~
nsJSArgArray
(
)
{
ReleaseJSObjects
(
)
;
}
void
nsJSArgArray
:
:
ReleaseJSObjects
(
)
{
if
(
mArgv
)
{
delete
[
]
mArgv
;
}
if
(
mArgc
>
0
)
{
mArgc
=
0
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsJSArgArray
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsJSArgArray
)
tmp
-
>
ReleaseJSObjects
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsJSArgArray
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsJSArgArray
)
if
(
tmp
-
>
mArgv
)
{
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mArgc
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mArgv
[
i
]
)
}
}
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsJSArgArray
)
NS_INTERFACE_MAP_ENTRY
(
nsIArray
)
NS_INTERFACE_MAP_ENTRY
(
nsIJSArgArray
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIJSArgArray
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsJSArgArray
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsJSArgArray
)
nsresult
nsJSArgArray
:
:
GetArgs
(
uint32_t
*
argc
void
*
*
argv
)
{
*
argv
=
(
void
*
)
mArgv
;
*
argc
=
mArgc
;
return
NS_OK
;
}
NS_IMETHODIMP
nsJSArgArray
:
:
GetLength
(
uint32_t
*
aLength
)
{
*
aLength
=
mArgc
;
return
NS_OK
;
}
NS_IMETHODIMP
nsJSArgArray
:
:
QueryElementAt
(
uint32_t
index
const
nsIID
&
uuid
void
*
*
result
)
{
*
result
=
nullptr
;
if
(
index
>
=
mArgc
)
return
NS_ERROR_INVALID_ARG
;
if
(
uuid
.
Equals
(
NS_GET_IID
(
nsIVariant
)
)
|
|
uuid
.
Equals
(
NS_GET_IID
(
nsISupports
)
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
mContext
mArgv
[
index
]
)
;
return
nsContentUtils
:
:
XPConnect
(
)
-
>
JSToVariant
(
mContext
val
(
nsIVariant
*
*
)
result
)
;
}
NS_WARNING
(
"
nsJSArgArray
only
handles
nsIVariant
"
)
;
return
NS_ERROR_NO_INTERFACE
;
}
NS_IMETHODIMP
nsJSArgArray
:
:
IndexOf
(
uint32_t
startIndex
nsISupports
*
element
uint32_t
*
_retval
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsJSArgArray
:
:
ScriptedEnumerate
(
const
nsIID
&
aElemIID
uint8_t
aArgc
nsISimpleEnumerator
*
*
aResult
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsJSArgArray
:
:
EnumerateImpl
(
const
nsID
&
aEntryIID
nsISimpleEnumerator
*
*
_retval
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
NS_CreateJSArgv
(
JSContext
*
aContext
uint32_t
argc
const
JS
:
:
Value
*
argv
nsIJSArgArray
*
*
aArray
)
{
nsresult
rv
;
nsCOMPtr
<
nsIJSArgArray
>
ret
=
new
nsJSArgArray
(
aContext
argc
argv
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
ret
.
forget
(
aArray
)
;
return
NS_OK
;
}
