#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRootBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMClassInfoID
.
h
"
#
include
"
nsIDOMHTMLElement
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLContentElement
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ShadowRoot
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ShadowRoot
DocumentFragment
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheetList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAssociatedBinding
)
for
(
auto
iter
=
tmp
-
>
mIdentifierMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
Traverse
(
&
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ShadowRoot
)
if
(
tmp
-
>
GetHost
(
)
)
{
tmp
-
>
GetHost
(
)
-
>
RemoveMutationObserver
(
tmp
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStyleSheetList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAssociatedBinding
)
tmp
-
>
mIdentifierMap
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END_INHERITED
(
DocumentFragment
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ShadowRoot
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContent
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
DocumentFragment
)
NS_IMPL_ADDREF_INHERITED
(
ShadowRoot
DocumentFragment
)
NS_IMPL_RELEASE_INHERITED
(
ShadowRoot
DocumentFragment
)
ShadowRoot
:
:
ShadowRoot
(
Element
*
aElement
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
nsXBLPrototypeBinding
*
aProtoBinding
)
:
DocumentFragment
(
aNodeInfo
)
mProtoBinding
(
aProtoBinding
)
mInsertionPointChanged
(
false
)
mIsComposedDocParticipant
(
false
)
{
SetHost
(
aElement
)
;
ClearSubtreeRootPointer
(
)
;
SetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
ExtendedDOMSlots
(
)
-
>
mBindingParent
=
aElement
;
ExtendedDOMSlots
(
)
-
>
mContainingShadow
=
this
;
GetHost
(
)
-
>
AddMutationObserver
(
this
)
;
}
ShadowRoot
:
:
~
ShadowRoot
(
)
{
if
(
auto
*
host
=
GetHost
(
)
)
{
host
-
>
RemoveMutationObserver
(
this
)
;
}
UnsetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
SetSubtreeRootPointer
(
this
)
;
}
JSObject
*
ShadowRoot
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
mozilla
:
:
dom
:
:
ShadowRootBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
ShadowRoot
*
ShadowRoot
:
:
FromNode
(
nsINode
*
aNode
)
{
if
(
aNode
-
>
IsInShadowTree
(
)
&
&
!
aNode
-
>
GetParentNode
(
)
)
{
MOZ_ASSERT
(
aNode
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_FRAGMENT_NODE
"
ShadowRoot
is
a
document
fragment
.
"
)
;
return
static_cast
<
ShadowRoot
*
>
(
aNode
)
;
}
return
nullptr
;
}
void
ShadowRoot
:
:
StyleSheetChanged
(
)
{
mProtoBinding
-
>
FlushSkinSheets
(
)
;
if
(
nsIPresShell
*
shell
=
OwnerDoc
(
)
-
>
GetShell
(
)
)
{
OwnerDoc
(
)
-
>
BeginUpdate
(
UPDATE_STYLE
)
;
shell
-
>
RecordShadowStyleChange
(
this
)
;
OwnerDoc
(
)
-
>
EndUpdate
(
UPDATE_STYLE
)
;
}
}
void
ShadowRoot
:
:
InsertSheet
(
StyleSheet
*
aSheet
nsIContent
*
aLinkingContent
)
{
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
linkingElement
=
do_QueryInterface
(
aLinkingContent
)
;
MOZ_ASSERT
(
linkingElement
"
The
only
styles
in
a
ShadowRoot
should
come
"
"
from
<
style
>
.
"
)
;
linkingElement
-
>
SetStyleSheet
(
aSheet
)
;
for
(
size_t
i
=
0
;
i
<
=
mProtoBinding
-
>
SheetCount
(
)
;
i
+
+
)
{
if
(
i
=
=
mProtoBinding
-
>
SheetCount
(
)
)
{
mProtoBinding
-
>
AppendStyleSheet
(
aSheet
)
;
break
;
}
nsINode
*
sheetOwningNode
=
mProtoBinding
-
>
StyleSheetAt
(
i
)
-
>
GetOwnerNode
(
)
;
if
(
nsContentUtils
:
:
PositionIsBefore
(
aLinkingContent
sheetOwningNode
)
)
{
mProtoBinding
-
>
InsertStyleSheetAt
(
i
aSheet
)
;
break
;
}
}
if
(
aSheet
-
>
IsApplicable
(
)
)
{
StyleSheetChanged
(
)
;
}
}
void
ShadowRoot
:
:
RemoveSheet
(
StyleSheet
*
aSheet
)
{
mProtoBinding
-
>
RemoveStyleSheet
(
aSheet
)
;
if
(
aSheet
-
>
IsApplicable
(
)
)
{
StyleSheetChanged
(
)
;
}
}
Element
*
ShadowRoot
:
:
GetElementById
(
const
nsAString
&
aElementId
)
{
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aElementId
)
;
return
entry
?
entry
-
>
GetIdElement
(
)
:
nullptr
;
}
already_AddRefed
<
nsContentList
>
ShadowRoot
:
:
GetElementsByTagName
(
const
nsAString
&
aTagName
)
{
return
NS_GetContentList
(
this
kNameSpaceID_Unknown
aTagName
)
;
}
already_AddRefed
<
nsContentList
>
ShadowRoot
:
:
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
int32_t
nameSpaceId
=
kNameSpaceID_Wildcard
;
if
(
!
aNamespaceURI
.
EqualsLiteral
(
"
*
"
)
)
{
nsresult
rv
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
RegisterNameSpace
(
aNamespaceURI
nameSpaceId
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
NS_ASSERTION
(
nameSpaceId
!
=
kNameSpaceID_Unknown
"
Unexpected
namespace
ID
!
"
)
;
return
NS_GetContentList
(
this
nameSpaceId
aLocalName
)
;
}
void
ShadowRoot
:
:
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aId
)
;
if
(
entry
)
{
entry
-
>
AddIdElement
(
aElement
)
;
}
}
void
ShadowRoot
:
:
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aId
)
;
if
(
entry
)
{
entry
-
>
RemoveIdElement
(
aElement
)
;
if
(
entry
-
>
IsEmpty
(
)
)
{
mIdentifierMap
.
RemoveEntry
(
entry
)
;
}
}
}
already_AddRefed
<
nsContentList
>
ShadowRoot
:
:
GetElementsByClassName
(
const
nsAString
&
aClasses
)
{
return
nsContentUtils
:
:
GetElementsByClassName
(
this
aClasses
)
;
}
void
ShadowRoot
:
:
AddInsertionPoint
(
HTMLContentElement
*
aInsertionPoint
)
{
TreeOrderComparator
comparator
;
mInsertionPoints
.
InsertElementSorted
(
aInsertionPoint
comparator
)
;
}
void
ShadowRoot
:
:
RemoveInsertionPoint
(
HTMLContentElement
*
aInsertionPoint
)
{
mInsertionPoints
.
RemoveElement
(
aInsertionPoint
)
;
}
void
ShadowRoot
:
:
RemoveDestInsertionPoint
(
nsIContent
*
aInsertionPoint
nsTArray
<
nsIContent
*
>
&
aDestInsertionPoints
)
{
int32_t
index
=
aDestInsertionPoints
.
IndexOf
(
aInsertionPoint
)
;
if
(
index
>
=
0
)
{
aDestInsertionPoints
.
RemoveElementAt
(
index
)
;
}
}
void
ShadowRoot
:
:
DistributionChanged
(
)
{
auto
*
host
=
GetHost
(
)
;
if
(
!
host
)
{
return
;
}
auto
*
shell
=
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
;
}
shell
-
>
DestroyFramesFor
(
host
)
;
}
void
ShadowRoot
:
:
DistributeSingleNode
(
nsIContent
*
aContent
)
{
HTMLContentElement
*
foundInsertionPoint
=
nullptr
;
for
(
HTMLContentElement
*
insertionPoint
:
mInsertionPoints
)
{
if
(
insertionPoint
-
>
Match
(
aContent
)
)
{
if
(
insertionPoint
-
>
MatchedNodes
(
)
.
Contains
(
aContent
)
)
{
return
;
}
if
(
insertionPoint
-
>
MatchedNodes
(
)
.
IsEmpty
(
)
&
&
insertionPoint
-
>
HasChildren
(
)
)
{
DistributeAllNodes
(
)
;
return
;
}
foundInsertionPoint
=
insertionPoint
;
break
;
}
}
if
(
!
foundInsertionPoint
)
{
return
;
}
nsCOMArray
<
nsIContent
>
&
matchedNodes
=
foundInsertionPoint
-
>
MatchedNodes
(
)
;
bool
isIndexFound
=
false
;
ExplicitChildIterator
childIterator
(
GetHost
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
matchedNodes
.
Length
(
)
;
i
+
+
)
{
if
(
childIterator
.
Seek
(
aContent
matchedNodes
[
i
]
)
)
{
foundInsertionPoint
-
>
InsertMatchedNode
(
i
aContent
)
;
isIndexFound
=
true
;
break
;
}
}
if
(
!
isIndexFound
)
{
MOZ_ASSERT
(
childIterator
.
Seek
(
aContent
nullptr
)
"
Trying
to
match
a
node
that
is
not
a
candidate
to
be
matched
"
)
;
foundInsertionPoint
-
>
AppendMatchedNode
(
aContent
)
;
}
if
(
auto
*
parentShadow
=
foundInsertionPoint
-
>
GetParent
(
)
-
>
GetShadowRoot
(
)
)
{
parentShadow
-
>
DistributeSingleNode
(
aContent
)
;
}
DistributionChanged
(
)
;
}
void
ShadowRoot
:
:
RemoveDistributedNode
(
nsIContent
*
aContent
)
{
for
(
HTMLContentElement
*
insertionPoint
:
mInsertionPoints
)
{
if
(
!
insertionPoint
-
>
MatchedNodes
(
)
.
Contains
(
aContent
)
)
{
continue
;
}
if
(
insertionPoint
-
>
MatchedNodes
(
)
.
Length
(
)
=
=
1
&
&
insertionPoint
-
>
HasChildren
(
)
)
{
DistributeAllNodes
(
)
;
return
;
}
insertionPoint
-
>
RemoveMatchedNode
(
aContent
)
;
if
(
auto
*
parentShadow
=
insertionPoint
-
>
GetParent
(
)
-
>
GetShadowRoot
(
)
)
{
parentShadow
-
>
RemoveDistributedNode
(
aContent
)
;
}
DistributionChanged
(
)
;
return
;
}
}
void
ShadowRoot
:
:
DistributeAllNodes
(
)
{
nsTArray
<
nsIContent
*
>
nodePool
;
ExplicitChildIterator
childIterator
(
GetHost
(
)
)
;
for
(
nsIContent
*
content
=
childIterator
.
GetNextChild
(
)
;
content
;
content
=
childIterator
.
GetNextChild
(
)
)
{
nodePool
.
AppendElement
(
content
)
;
}
nsTArray
<
ShadowRoot
*
>
shadowsToUpdate
;
for
(
HTMLContentElement
*
insertionPoint
:
mInsertionPoints
)
{
insertionPoint
-
>
ClearMatchedNodes
(
)
;
for
(
uint32_t
j
=
0
;
j
<
nodePool
.
Length
(
)
;
j
+
+
)
{
if
(
insertionPoint
-
>
Match
(
nodePool
[
j
]
)
)
{
insertionPoint
-
>
AppendMatchedNode
(
nodePool
[
j
]
)
;
nodePool
.
RemoveElementAt
(
j
-
-
)
;
}
}
nsIContent
*
insertionParent
=
insertionPoint
-
>
GetParent
(
)
;
MOZ_ASSERT
(
insertionParent
"
The
only
way
for
an
insertion
point
to
be
in
the
"
"
mInsertionPoints
array
is
to
be
a
descendant
of
a
"
"
ShadowRoot
in
which
case
it
should
have
a
parent
"
)
;
ShadowRoot
*
parentShadow
=
insertionParent
-
>
GetShadowRoot
(
)
;
if
(
parentShadow
&
&
!
shadowsToUpdate
.
Contains
(
parentShadow
)
)
{
shadowsToUpdate
.
AppendElement
(
parentShadow
)
;
}
}
for
(
ShadowRoot
*
shadow
:
shadowsToUpdate
)
{
shadow
-
>
DistributeAllNodes
(
)
;
}
DistributionChanged
(
)
;
}
void
ShadowRoot
:
:
GetInnerHTML
(
nsAString
&
aInnerHTML
)
{
GetMarkup
(
false
aInnerHTML
)
;
}
void
ShadowRoot
:
:
SetInnerHTML
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
{
SetInnerHTMLInternal
(
aInnerHTML
aError
)
;
}
Element
*
ShadowRoot
:
:
Host
(
)
{
nsIContent
*
host
=
GetHost
(
)
;
MOZ_ASSERT
(
host
&
&
host
-
>
IsElement
(
)
"
ShadowRoot
host
should
always
be
an
element
"
"
how
else
did
we
create
this
ShadowRoot
?
"
)
;
return
host
-
>
AsElement
(
)
;
}
bool
ShadowRoot
:
:
ApplyAuthorStyles
(
)
{
return
mProtoBinding
-
>
InheritsStyle
(
)
;
}
void
ShadowRoot
:
:
SetApplyAuthorStyles
(
bool
aApplyAuthorStyles
)
{
mProtoBinding
-
>
SetInheritsStyle
(
aApplyAuthorStyles
)
;
nsIPresShell
*
shell
=
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
shell
)
{
OwnerDoc
(
)
-
>
BeginUpdate
(
UPDATE_STYLE
)
;
shell
-
>
RecordShadowStyleChange
(
this
)
;
OwnerDoc
(
)
-
>
EndUpdate
(
UPDATE_STYLE
)
;
}
}
StyleSheetList
*
ShadowRoot
:
:
StyleSheets
(
)
{
if
(
!
mStyleSheetList
)
{
mStyleSheetList
=
new
ShadowRootStyleSheetList
(
this
)
;
}
return
mStyleSheetList
;
}
bool
ShadowRoot
:
:
IsPooledNode
(
nsIContent
*
aContent
nsIContent
*
aContainer
nsIContent
*
aHost
)
{
if
(
nsContentUtils
:
:
IsContentInsertionPoint
(
aContent
)
)
{
return
false
;
}
if
(
aContainer
=
=
aHost
&
&
nsContentUtils
:
:
IsInSameAnonymousTree
(
aContainer
aContent
)
)
{
return
true
;
}
if
(
aContainer
)
{
HTMLContentElement
*
content
=
HTMLContentElement
:
:
FromContent
(
aContainer
)
;
return
content
&
&
content
-
>
IsInsertionPoint
(
)
&
&
content
-
>
MatchedNodes
(
)
.
IsEmpty
(
)
&
&
aContainer
-
>
GetParentNode
(
)
=
=
aHost
;
}
return
false
;
}
void
ShadowRoot
:
:
AttributeChanged
(
nsIDocument
*
aDocument
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
!
IsPooledNode
(
aElement
aElement
-
>
GetParent
(
)
GetHost
(
)
)
)
{
return
;
}
RemoveDistributedNode
(
aElement
)
;
DistributeSingleNode
(
aElement
)
;
}
void
ShadowRoot
:
:
ContentAppended
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
)
{
if
(
mInsertionPointChanged
)
{
DistributeAllNodes
(
)
;
mInsertionPointChanged
=
false
;
return
;
}
nsIContent
*
currentChild
=
aFirstNewContent
;
while
(
currentChild
)
{
if
(
nsContentUtils
:
:
IsContentInsertionPoint
(
aContainer
)
)
{
HTMLContentElement
*
content
=
HTMLContentElement
:
:
FromContent
(
aContainer
)
;
if
(
content
&
&
content
-
>
MatchedNodes
(
)
.
IsEmpty
(
)
)
{
currentChild
-
>
DestInsertionPoints
(
)
.
AppendElement
(
aContainer
)
;
}
}
if
(
IsPooledNode
(
currentChild
aContainer
GetHost
(
)
)
)
{
DistributeSingleNode
(
currentChild
)
;
}
currentChild
=
currentChild
-
>
GetNextSibling
(
)
;
}
}
void
ShadowRoot
:
:
ContentInserted
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
if
(
mInsertionPointChanged
)
{
DistributeAllNodes
(
)
;
mInsertionPointChanged
=
false
;
return
;
}
if
(
IsPooledNode
(
aChild
aContainer
GetHost
(
)
)
)
{
if
(
nsContentUtils
:
:
IsContentInsertionPoint
(
aContainer
)
)
{
HTMLContentElement
*
content
=
HTMLContentElement
:
:
FromContent
(
aContainer
)
;
if
(
content
&
&
content
-
>
MatchedNodes
(
)
.
IsEmpty
(
)
)
{
aChild
-
>
DestInsertionPoints
(
)
.
AppendElement
(
aContainer
)
;
}
}
DistributeSingleNode
(
aChild
)
;
}
}
void
ShadowRoot
:
:
ContentRemoved
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
mInsertionPointChanged
)
{
DistributeAllNodes
(
)
;
mInsertionPointChanged
=
false
;
return
;
}
if
(
nsContentUtils
:
:
IsContentInsertionPoint
(
aContainer
)
)
{
HTMLContentElement
*
content
=
HTMLContentElement
:
:
FromContent
(
aContainer
)
;
if
(
content
&
&
content
-
>
MatchedNodes
(
)
.
IsEmpty
(
)
)
{
aChild
-
>
DestInsertionPoints
(
)
.
Clear
(
)
;
}
}
if
(
IsPooledNode
(
aChild
aContainer
GetHost
(
)
)
)
{
RemoveDistributedNode
(
aChild
)
;
}
}
nsresult
ShadowRoot
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
{
*
aResult
=
nullptr
;
return
NS_ERROR_DOM_DATA_CLONE_ERR
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
ShadowRootStyleSheetList
StyleSheetList
mShadowRoot
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ShadowRootStyleSheetList
)
NS_INTERFACE_MAP_END_INHERITING
(
StyleSheetList
)
NS_IMPL_ADDREF_INHERITED
(
ShadowRootStyleSheetList
StyleSheetList
)
NS_IMPL_RELEASE_INHERITED
(
ShadowRootStyleSheetList
StyleSheetList
)
ShadowRootStyleSheetList
:
:
ShadowRootStyleSheetList
(
ShadowRoot
*
aShadowRoot
)
:
mShadowRoot
(
aShadowRoot
)
{
}
ShadowRootStyleSheetList
:
:
~
ShadowRootStyleSheetList
(
)
{
}
StyleSheet
*
ShadowRootStyleSheetList
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
{
aFound
=
aIndex
<
mShadowRoot
-
>
mProtoBinding
-
>
SheetCount
(
)
;
if
(
!
aFound
)
{
return
nullptr
;
}
return
mShadowRoot
-
>
mProtoBinding
-
>
StyleSheetAt
(
aIndex
)
;
}
uint32_t
ShadowRootStyleSheetList
:
:
Length
(
)
{
return
mShadowRoot
-
>
mProtoBinding
-
>
SheetCount
(
)
;
}
