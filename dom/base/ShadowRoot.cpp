#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
ServoStyleRuleMap
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetList
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ShadowRoot
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ShadowRoot
DocumentFragment
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheets
)
for
(
StyleSheet
*
sheet
:
tmp
-
>
mStyleSheets
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mServoStyles
-
>
sheets
[
i
]
"
)
;
cb
.
NoteXPCOMChild
(
sheet
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDOMStyleSheets
)
for
(
auto
iter
=
tmp
-
>
mIdentifierMap
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
Traverse
(
&
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ShadowRoot
)
if
(
tmp
-
>
GetHost
(
)
)
{
tmp
-
>
GetHost
(
)
-
>
RemoveMutationObserver
(
tmp
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDOMStyleSheets
)
tmp
-
>
mIdentifierMap
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END_INHERITED
(
DocumentFragment
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ShadowRoot
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContent
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
DocumentFragment
)
NS_IMPL_ADDREF_INHERITED
(
ShadowRoot
DocumentFragment
)
NS_IMPL_RELEASE_INHERITED
(
ShadowRoot
DocumentFragment
)
ShadowRoot
:
:
ShadowRoot
(
Element
*
aElement
ShadowRootMode
aMode
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
DocumentFragment
(
aNodeInfo
)
DocumentOrShadowRoot
(
*
this
)
mMode
(
aMode
)
mServoStyles
(
Servo_AuthorStyles_Create
(
)
)
mIsUAWidget
(
false
)
{
SetHost
(
aElement
)
;
ClearSubtreeRootPointer
(
)
;
SetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
Bind
(
)
;
ExtendedDOMSlots
(
)
-
>
mBindingParent
=
aElement
;
ExtendedDOMSlots
(
)
-
>
mContainingShadow
=
this
;
GetHost
(
)
-
>
AddMutationObserver
(
this
)
;
}
ShadowRoot
:
:
~
ShadowRoot
(
)
{
if
(
auto
*
host
=
GetHost
(
)
)
{
host
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
IsInComposedDoc
(
)
)
{
OwnerDoc
(
)
-
>
RemoveComposedDocShadowRoot
(
*
this
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
OwnerDoc
(
)
-
>
IsComposedDocShadowRoot
(
*
this
)
)
;
UnsetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
SetSubtreeRootPointer
(
this
)
;
}
void
ShadowRoot
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
DocumentFragment
:
:
AddSizeOfExcludingThis
(
aSizes
aNodeSize
)
;
DocumentOrShadowRoot
:
:
AddSizeOfExcludingThis
(
aSizes
)
;
}
JSObject
*
ShadowRoot
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
mozilla
:
:
dom
:
:
ShadowRoot_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
ShadowRoot
:
:
CloneInternalDataFrom
(
ShadowRoot
*
aOther
)
{
size_t
sheetCount
=
aOther
-
>
SheetCount
(
)
;
for
(
size_t
i
=
0
;
i
<
sheetCount
;
+
+
i
)
{
StyleSheet
*
sheet
=
aOther
-
>
SheetAt
(
i
)
;
if
(
sheet
-
>
IsApplicable
(
)
)
{
RefPtr
<
StyleSheet
>
clonedSheet
=
sheet
-
>
Clone
(
nullptr
nullptr
this
nullptr
)
;
if
(
clonedSheet
)
{
AppendStyleSheet
(
*
clonedSheet
.
get
(
)
)
;
}
}
}
}
nsresult
ShadowRoot
:
:
Bind
(
)
{
MOZ_ASSERT
(
!
IsInComposedDoc
(
)
"
Forgot
to
unbind
?
"
)
;
if
(
Host
(
)
-
>
IsInComposedDoc
(
)
)
{
SetIsConnected
(
true
)
;
OwnerDoc
(
)
-
>
AddComposedDocShadowRoot
(
*
this
)
;
}
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
nsresult
rv
=
child
-
>
BindToTree
(
nullptr
this
Host
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
void
ShadowRoot
:
:
Unbind
(
)
{
if
(
IsInComposedDoc
(
)
)
{
SetIsConnected
(
false
)
;
OwnerDoc
(
)
-
>
RemoveComposedDocShadowRoot
(
*
this
)
;
}
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
UnbindFromTree
(
true
false
)
;
}
}
void
ShadowRoot
:
:
InvalidateStyleAndLayoutOnSubtree
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
nsIDocument
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
;
}
shell
-
>
DestroyFramesForAndRestyle
(
aElement
)
;
}
void
ShadowRoot
:
:
AddSlot
(
HTMLSlotElement
*
aSlot
)
{
MOZ_ASSERT
(
aSlot
)
;
nsAutoString
name
;
aSlot
-
>
GetName
(
name
)
;
nsTArray
<
HTMLSlotElement
*
>
*
currentSlots
=
mSlotMap
.
LookupOrAdd
(
name
)
;
MOZ_ASSERT
(
currentSlots
)
;
HTMLSlotElement
*
oldSlot
=
currentSlots
-
>
SafeElementAt
(
0
)
;
TreeOrderComparator
comparator
;
currentSlots
-
>
InsertElementSorted
(
aSlot
comparator
)
;
HTMLSlotElement
*
currentSlot
=
currentSlots
-
>
ElementAt
(
0
)
;
if
(
currentSlot
!
=
aSlot
)
{
return
;
}
if
(
oldSlot
&
&
oldSlot
!
=
currentSlot
)
{
InvalidateStyleAndLayoutOnSubtree
(
oldSlot
)
;
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
oldSlot
-
>
AssignedNodes
(
)
;
bool
doEnqueueSlotChange
=
false
;
while
(
assignedNodes
.
Length
(
)
>
0
)
{
nsINode
*
assignedNode
=
assignedNodes
[
0
]
;
oldSlot
-
>
RemoveAssignedNode
(
assignedNode
)
;
currentSlot
-
>
AppendAssignedNode
(
assignedNode
)
;
doEnqueueSlotChange
=
true
;
}
if
(
doEnqueueSlotChange
)
{
oldSlot
-
>
EnqueueSlotChangeEvent
(
)
;
currentSlot
-
>
EnqueueSlotChangeEvent
(
)
;
SlotStateChanged
(
oldSlot
)
;
SlotStateChanged
(
currentSlot
)
;
}
}
else
{
bool
doEnqueueSlotChange
=
false
;
for
(
nsIContent
*
child
=
GetHost
(
)
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
nsAutoString
slotName
;
if
(
child
-
>
IsElement
(
)
)
{
child
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
slot
slotName
)
;
}
if
(
!
child
-
>
IsSlotable
(
)
|
|
!
slotName
.
Equals
(
name
)
)
{
continue
;
}
doEnqueueSlotChange
=
true
;
currentSlot
-
>
AppendAssignedNode
(
child
)
;
}
if
(
doEnqueueSlotChange
)
{
currentSlot
-
>
EnqueueSlotChangeEvent
(
)
;
SlotStateChanged
(
currentSlot
)
;
}
}
}
void
ShadowRoot
:
:
RemoveSlot
(
HTMLSlotElement
*
aSlot
)
{
MOZ_ASSERT
(
aSlot
)
;
nsAutoString
name
;
aSlot
-
>
GetName
(
name
)
;
SlotArray
*
currentSlots
=
mSlotMap
.
Get
(
name
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentSlots
&
&
currentSlots
-
>
Contains
(
aSlot
)
"
Slot
to
deregister
wasn
'
t
found
?
"
)
;
if
(
currentSlots
-
>
Length
(
)
=
=
1
)
{
MOZ_ASSERT
(
currentSlots
-
>
ElementAt
(
0
)
=
=
aSlot
)
;
InvalidateStyleAndLayoutOnSubtree
(
aSlot
)
;
mSlotMap
.
Remove
(
name
)
;
if
(
!
aSlot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
aSlot
-
>
ClearAssignedNodes
(
)
;
aSlot
-
>
EnqueueSlotChangeEvent
(
)
;
}
return
;
}
const
bool
wasFirstSlot
=
currentSlots
-
>
ElementAt
(
0
)
=
=
aSlot
;
currentSlots
-
>
RemoveElement
(
aSlot
)
;
if
(
!
wasFirstSlot
)
{
return
;
}
InvalidateStyleAndLayoutOnSubtree
(
aSlot
)
;
HTMLSlotElement
*
replacementSlot
=
currentSlots
-
>
ElementAt
(
0
)
;
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
aSlot
-
>
AssignedNodes
(
)
;
bool
slottedNodesChanged
=
!
assignedNodes
.
IsEmpty
(
)
;
while
(
!
assignedNodes
.
IsEmpty
(
)
)
{
nsINode
*
assignedNode
=
assignedNodes
[
0
]
;
aSlot
-
>
RemoveAssignedNode
(
assignedNode
)
;
replacementSlot
-
>
AppendAssignedNode
(
assignedNode
)
;
}
if
(
slottedNodesChanged
)
{
aSlot
-
>
EnqueueSlotChangeEvent
(
)
;
replacementSlot
-
>
EnqueueSlotChangeEvent
(
)
;
}
}
void
ShadowRoot
:
:
RuleAdded
(
StyleSheet
&
aSheet
css
:
:
Rule
&
aRule
)
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
RuleAdded
(
aSheet
aRule
)
;
}
Servo_AuthorStyles_ForceDirty
(
mServoStyles
.
get
(
)
)
;
ApplicableRulesChanged
(
)
;
}
void
ShadowRoot
:
:
RuleRemoved
(
StyleSheet
&
aSheet
css
:
:
Rule
&
aRule
)
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
RuleRemoved
(
aSheet
aRule
)
;
}
Servo_AuthorStyles_ForceDirty
(
mServoStyles
.
get
(
)
)
;
ApplicableRulesChanged
(
)
;
}
void
ShadowRoot
:
:
RuleChanged
(
StyleSheet
&
css
:
:
Rule
*
)
{
Servo_AuthorStyles_ForceDirty
(
mServoStyles
.
get
(
)
)
;
ApplicableRulesChanged
(
)
;
}
void
ShadowRoot
:
:
ApplicableRulesChanged
(
)
{
nsIDocument
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
if
(
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
)
{
shell
-
>
RecordShadowStyleChange
(
*
this
)
;
}
}
void
ShadowRoot
:
:
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
aSheet
)
{
DocumentOrShadowRoot
:
:
InsertSheetAt
(
aIndex
aSheet
)
;
if
(
aSheet
.
IsApplicable
(
)
)
{
InsertSheetIntoAuthorData
(
aIndex
aSheet
)
;
}
}
void
ShadowRoot
:
:
InsertSheetIntoAuthorData
(
size_t
aIndex
StyleSheet
&
aSheet
)
{
MOZ_ASSERT
(
SheetAt
(
aIndex
)
=
=
&
aSheet
)
;
MOZ_ASSERT
(
aSheet
.
IsApplicable
(
)
)
;
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetAdded
(
aSheet
)
;
}
for
(
size_t
i
=
aIndex
+
1
;
i
<
SheetCount
(
)
;
+
+
i
)
{
StyleSheet
*
beforeSheet
=
SheetAt
(
i
)
;
if
(
!
beforeSheet
-
>
IsApplicable
(
)
)
{
continue
;
}
Servo_AuthorStyles_InsertStyleSheetBefore
(
mServoStyles
.
get
(
)
&
aSheet
beforeSheet
)
;
ApplicableRulesChanged
(
)
;
return
;
}
Servo_AuthorStyles_AppendStyleSheet
(
mServoStyles
.
get
(
)
&
aSheet
)
;
ApplicableRulesChanged
(
)
;
}
void
ShadowRoot
:
:
StyleSheetApplicableStateChanged
(
StyleSheet
&
aSheet
bool
aApplicable
)
{
int32_t
index
=
IndexOfSheet
(
aSheet
)
;
if
(
index
<
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aSheet
.
GetParentSheet
(
)
"
It
'
d
better
be
an
import
sheet
"
)
;
return
;
}
if
(
aApplicable
)
{
InsertSheetIntoAuthorData
(
size_t
(
index
)
aSheet
)
;
}
else
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetRemoved
(
aSheet
)
;
}
Servo_AuthorStyles_RemoveStyleSheet
(
mServoStyles
.
get
(
)
&
aSheet
)
;
ApplicableRulesChanged
(
)
;
}
}
void
ShadowRoot
:
:
RemoveSheet
(
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
RefPtr
<
StyleSheet
>
sheet
=
DocumentOrShadowRoot
:
:
RemoveSheet
(
*
aSheet
)
;
MOZ_ASSERT
(
sheet
)
;
if
(
sheet
-
>
IsApplicable
(
)
)
{
if
(
mStyleRuleMap
)
{
mStyleRuleMap
-
>
SheetRemoved
(
*
sheet
)
;
}
Servo_AuthorStyles_RemoveStyleSheet
(
mServoStyles
.
get
(
)
sheet
)
;
ApplicableRulesChanged
(
)
;
}
}
void
ShadowRoot
:
:
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aId
)
;
if
(
entry
)
{
entry
-
>
AddIdElement
(
aElement
)
;
}
}
void
ShadowRoot
:
:
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aId
)
;
if
(
entry
)
{
entry
-
>
RemoveIdElement
(
aElement
)
;
if
(
entry
-
>
IsEmpty
(
)
)
{
mIdentifierMap
.
RemoveEntry
(
entry
)
;
}
}
}
void
ShadowRoot
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mRootOfClosedTree
=
IsClosed
(
)
;
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
=
false
;
if
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mComposed
)
{
nsCOMPtr
<
nsIContent
>
originalTarget
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
if
(
originalTarget
-
>
GetContainingShadow
(
)
=
=
this
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
EventTarget
*
parentTarget
=
win
&
&
aVisitor
.
mEvent
-
>
mMessage
!
=
eLoad
?
win
-
>
GetParentTarget
(
)
:
nullptr
;
aVisitor
.
SetParentTarget
(
parentTarget
true
)
;
return
;
}
}
nsIContent
*
shadowHost
=
GetHost
(
)
;
aVisitor
.
SetParentTarget
(
shadowHost
false
)
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mTarget
)
)
;
if
(
content
&
&
content
-
>
GetBindingParent
(
)
=
=
shadowHost
)
{
aVisitor
.
mEventTargetAtParent
=
shadowHost
;
}
}
ShadowRoot
:
:
SlotAssignment
ShadowRoot
:
:
SlotAssignmentFor
(
nsIContent
*
aContent
)
{
nsAutoString
slotName
;
if
(
aContent
-
>
IsElement
(
)
)
{
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
slot
slotName
)
;
}
nsTArray
<
HTMLSlotElement
*
>
*
slots
=
mSlotMap
.
Get
(
slotName
)
;
if
(
!
slots
)
{
return
{
}
;
}
HTMLSlotElement
*
slot
=
slots
-
>
ElementAt
(
0
)
;
MOZ_ASSERT
(
slot
)
;
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
nsIContent
*
currentContent
=
GetHost
(
)
-
>
GetFirstChild
(
)
;
Maybe
<
uint32_t
>
insertionIndex
;
for
(
uint32_t
i
=
0
;
i
<
assignedNodes
.
Length
(
)
;
i
+
+
)
{
while
(
currentContent
&
&
currentContent
!
=
assignedNodes
[
i
]
)
{
if
(
currentContent
=
=
aContent
)
{
insertionIndex
.
emplace
(
i
)
;
break
;
}
currentContent
=
currentContent
-
>
GetNextSibling
(
)
;
}
if
(
insertionIndex
)
{
break
;
}
}
return
{
slot
insertionIndex
}
;
}
void
ShadowRoot
:
:
MaybeReassignElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
-
>
GetParent
(
)
=
=
GetHost
(
)
)
;
HTMLSlotElement
*
oldSlot
=
aElement
-
>
GetAssignedSlot
(
)
;
SlotAssignment
assignment
=
SlotAssignmentFor
(
aElement
)
;
if
(
assignment
.
mSlot
=
=
oldSlot
)
{
return
;
}
if
(
nsIDocument
*
doc
=
GetComposedDoc
(
)
)
{
if
(
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
)
{
shell
-
>
SlotAssignmentWillChange
(
*
aElement
oldSlot
assignment
.
mSlot
)
;
}
}
if
(
oldSlot
)
{
oldSlot
-
>
RemoveAssignedNode
(
aElement
)
;
oldSlot
-
>
EnqueueSlotChangeEvent
(
)
;
}
if
(
assignment
.
mSlot
)
{
if
(
assignment
.
mIndex
)
{
assignment
.
mSlot
-
>
InsertAssignedNode
(
*
assignment
.
mIndex
aElement
)
;
}
else
{
assignment
.
mSlot
-
>
AppendAssignedNode
(
aElement
)
;
}
assignment
.
mSlot
-
>
EnqueueSlotChangeEvent
(
)
;
}
SlotStateChanged
(
oldSlot
)
;
SlotStateChanged
(
assignment
.
mSlot
)
;
}
Element
*
ShadowRoot
:
:
GetActiveElement
(
)
{
return
GetRetargetedFocusedElement
(
)
;
}
void
ShadowRoot
:
:
GetInnerHTML
(
nsAString
&
aInnerHTML
)
{
GetMarkup
(
false
aInnerHTML
)
;
}
void
ShadowRoot
:
:
SetInnerHTML
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
{
SetInnerHTMLInternal
(
aInnerHTML
aError
)
;
}
nsINode
*
ShadowRoot
:
:
ImportNodeAndAppendChildAt
(
nsINode
&
aParentNode
nsINode
&
aNode
bool
aDeep
mozilla
:
:
ErrorResult
&
rv
)
{
MOZ_ASSERT
(
mIsUAWidget
)
;
if
(
!
aParentNode
.
IsInUAWidget
(
)
)
{
rv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
nullptr
;
}
RefPtr
<
nsINode
>
node
=
OwnerDoc
(
)
-
>
ImportNode
(
aNode
aDeep
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
aParentNode
.
AppendChild
(
*
node
rv
)
;
}
nsINode
*
ShadowRoot
:
:
CreateElementAndAppendChildAt
(
nsINode
&
aParentNode
const
nsAString
&
aTagName
mozilla
:
:
ErrorResult
&
rv
)
{
MOZ_ASSERT
(
mIsUAWidget
)
;
MOZ_ASSERT
(
OwnerDoc
(
)
)
;
if
(
!
aParentNode
.
IsInUAWidget
(
)
)
{
rv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
nullptr
;
}
ElementCreationOptionsOrString
options
;
RefPtr
<
nsINode
>
node
=
OwnerDoc
(
)
-
>
CreateElement
(
aTagName
options
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
aParentNode
.
AppendChild
(
*
node
rv
)
;
}
void
ShadowRoot
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_None
|
|
aAttribute
!
=
nsGkAtoms
:
:
slot
)
{
return
;
}
if
(
aElement
-
>
GetParent
(
)
!
=
GetHost
(
)
)
{
return
;
}
MaybeReassignElement
(
aElement
)
;
}
void
ShadowRoot
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
for
(
nsIContent
*
content
=
aFirstNewContent
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
ContentInserted
(
content
)
;
}
}
void
ShadowRoot
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
if
(
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
{
return
;
}
if
(
!
aChild
-
>
IsSlotable
(
)
)
{
return
;
}
if
(
aChild
-
>
GetParent
(
)
=
=
GetHost
(
)
)
{
SlotAssignment
assignment
=
SlotAssignmentFor
(
aChild
)
;
if
(
!
assignment
.
mSlot
)
{
return
;
}
if
(
assignment
.
mSlot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
InvalidateStyleAndLayoutOnSubtree
(
assignment
.
mSlot
)
;
}
if
(
assignment
.
mIndex
)
{
assignment
.
mSlot
-
>
InsertAssignedNode
(
*
assignment
.
mIndex
aChild
)
;
}
else
{
assignment
.
mSlot
-
>
AppendAssignedNode
(
aChild
)
;
}
assignment
.
mSlot
-
>
EnqueueSlotChangeEvent
(
)
;
SlotStateChanged
(
assignment
.
mSlot
)
;
return
;
}
HTMLSlotElement
*
slot
=
HTMLSlotElement
:
:
FromNodeOrNull
(
aChild
-
>
GetParent
(
)
)
;
if
(
slot
&
&
slot
-
>
GetContainingShadow
(
)
=
=
this
&
&
slot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
slot
-
>
EnqueueSlotChangeEvent
(
)
;
}
}
void
ShadowRoot
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
{
return
;
}
if
(
!
aChild
-
>
IsSlotable
(
)
)
{
return
;
}
if
(
aChild
-
>
GetParent
(
)
=
=
GetHost
(
)
)
{
if
(
HTMLSlotElement
*
slot
=
aChild
-
>
GetAssignedSlot
(
)
)
{
if
(
slot
-
>
AssignedNodes
(
)
.
Length
(
)
=
=
1
)
{
InvalidateStyleAndLayoutOnSubtree
(
slot
)
;
}
slot
-
>
RemoveAssignedNode
(
aChild
)
;
slot
-
>
EnqueueSlotChangeEvent
(
)
;
}
return
;
}
HTMLSlotElement
*
slot
=
HTMLSlotElement
:
:
FromNodeOrNull
(
aChild
-
>
GetParent
(
)
)
;
if
(
slot
&
&
slot
-
>
GetContainingShadow
(
)
=
=
this
&
&
slot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
slot
-
>
EnqueueSlotChangeEvent
(
)
;
}
}
ServoStyleRuleMap
&
ShadowRoot
:
:
ServoStyleRuleMap
(
)
{
if
(
!
mStyleRuleMap
)
{
mStyleRuleMap
=
MakeUnique
<
mozilla
:
:
ServoStyleRuleMap
>
(
)
;
}
mStyleRuleMap
-
>
EnsureTable
(
*
this
)
;
return
*
mStyleRuleMap
;
}
nsresult
ShadowRoot
:
:
Clone
(
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
{
*
aResult
=
nullptr
;
return
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
}
