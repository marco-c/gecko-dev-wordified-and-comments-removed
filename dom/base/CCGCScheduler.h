#
include
"
js
/
SliceBudget
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
MainThreadIdlePeriod
.
h
"
#
include
"
nsCycleCollector
.
h
"
static
const
TimeDuration
kOneMinute
=
TimeDuration
:
:
FromSeconds
(
60
.
0f
)
;
static
const
TimeDuration
kCCDelay
=
TimeDuration
:
:
FromSeconds
(
6
)
;
static
const
TimeDuration
kCCSkippableDelay
=
TimeDuration
:
:
FromMilliseconds
(
250
)
;
static
const
TimeDuration
kTimeBetweenForgetSkippableCycles
=
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
TimeDuration
kForgetSkippableSliceDuration
=
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
TimeDuration
kICCIntersliceDelay
=
TimeDuration
:
:
FromMilliseconds
(
64
)
;
static
const
TimeDuration
kICCSliceBudget
=
TimeDuration
:
:
FromMilliseconds
(
3
)
;
static
const
TimeDuration
kIdleICCSliceBudget
=
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
TimeDuration
kMaxICCDuration
=
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
TimeDuration
kCCForced
=
kOneMinute
*
2
;
static
const
uint32_t
kCCForcedPurpleLimit
=
10
;
static
const
TimeDuration
kMaxCCLockedoutTime
=
TimeDuration
:
:
FromSeconds
(
30
)
;
static
const
uint32_t
kCCPurpleLimit
=
200
;
namespace
mozilla
{
MOZ_ALWAYS_INLINE
static
TimeDuration
TimeBetween
(
TimeStamp
aStart
TimeStamp
aEnd
)
{
MOZ_ASSERT
(
aEnd
>
=
aStart
)
;
return
aEnd
-
aStart
;
}
static
inline
js
:
:
SliceBudget
BudgetFromDuration
(
TimeDuration
aDuration
)
{
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
aDuration
.
ToMilliseconds
(
)
)
)
;
}
class
CCGCScheduler
{
public
:
void
SetActiveIntersliceGCBudget
(
TimeDuration
aDuration
)
{
mActiveIntersliceGCBudget
=
aDuration
;
}
Maybe
<
TimeDuration
>
GetCCBlockedTime
(
TimeStamp
now
)
const
{
MOZ_ASSERT_IF
(
mCCBlockStart
.
IsNull
(
)
!
mInIncrementalGC
)
;
if
(
mCCBlockStart
.
IsNull
(
)
)
{
return
{
}
;
}
return
Some
(
now
-
mCCBlockStart
)
;
}
bool
InIncrementalGC
(
)
const
{
return
mInIncrementalGC
;
}
void
NoteGCBegin
(
)
{
mInIncrementalGC
=
true
;
}
void
NoteGCEnd
(
)
{
mCCBlockStart
=
TimeStamp
(
)
;
mInIncrementalGC
=
false
;
}
enum
IsStartingCCLockout
{
StartingLockout
=
true
AlreadyLockedOut
=
false
}
;
IsStartingCCLockout
EnsureCCIsBlocked
(
TimeStamp
aNow
)
{
MOZ_ASSERT
(
mInIncrementalGC
)
;
if
(
mCCBlockStart
)
{
return
AlreadyLockedOut
;
}
mCCBlockStart
=
aNow
;
return
StartingLockout
;
}
void
UnblockCC
(
)
{
mCCBlockStart
=
TimeStamp
(
)
;
}
void
NoteForgetSkippableComplete
(
TimeStamp
now
)
{
mLastForgetSkippableEndTime
=
aNow
;
}
TimeDuration
ComputeInterSliceGCBudget
(
TimeStamp
aDeadline
)
const
{
TimeDuration
budget
=
aDeadline
.
IsNull
(
)
?
mActiveIntersliceGCBudget
*
2
:
aDeadline
-
TimeStamp
:
:
Now
(
)
;
if
(
!
mCCBlockStart
)
{
return
budget
;
}
TimeDuration
blockedTime
=
TimeStamp
:
:
Now
(
)
-
mCCBlockStart
;
TimeDuration
maxSliceGCBudget
=
mActiveIntersliceGCBudget
*
10
;
double
percentOfBlockedTime
=
std
:
:
min
(
blockedTime
/
kMaxCCLockedoutTime
1
.
0
)
;
return
std
:
:
max
(
budget
maxSliceGCBudget
.
MultDouble
(
percentOfBlockedTime
)
)
;
}
js
:
:
SliceBudget
ComputeCCSliceBudget
(
TimeStamp
aDeadline
TimeStamp
aCCBeginTime
TimeStamp
aPrevSliceEndTime
bool
*
aPreferShorterSlices
)
const
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
*
aPreferShorterSlices
=
aDeadline
.
IsNull
(
)
|
|
(
aDeadline
-
now
)
<
kICCSliceBudget
;
TimeDuration
baseBudget
=
aDeadline
.
IsNull
(
)
?
kICCSliceBudget
:
aDeadline
-
now
;
if
(
aCCBeginTime
.
IsNull
(
)
)
{
return
BudgetFromDuration
(
baseBudget
)
;
}
TimeDuration
runningTime
=
TimeBetween
(
aCCBeginTime
now
)
;
if
(
runningTime
>
=
kMaxICCDuration
)
{
return
js
:
:
SliceBudget
:
:
unlimited
(
)
;
}
const
TimeDuration
maxSlice
=
TimeDuration
:
:
FromMilliseconds
(
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
)
;
double
sliceDelayMultiplier
=
TimeBetween
(
aPrevSliceEndTime
now
)
/
kICCIntersliceDelay
;
TimeDuration
delaySliceBudget
=
std
:
:
min
(
baseBudget
.
MultDouble
(
sliceDelayMultiplier
)
maxSlice
)
;
double
percentToHalfDone
=
std
:
:
min
(
2
.
0
*
(
runningTime
/
kMaxICCDuration
)
1
.
0
)
;
TimeDuration
laterSliceBudget
=
maxSlice
.
MultDouble
(
percentToHalfDone
)
;
return
BudgetFromDuration
(
std
:
:
max
(
{
delaySliceBudget
laterSliceBudget
baseBudget
}
)
)
;
}
js
:
:
SliceBudget
ComputeForgetSkippableBudget
(
TimeStamp
aStartTimeStamp
TimeStamp
aDeadline
)
{
if
(
mForgetSkippableFrequencyStartTime
.
IsNull
(
)
)
{
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
else
if
(
aStartTimeStamp
-
mForgetSkippableFrequencyStartTime
>
kOneMinute
)
{
TimeStamp
startPlusMinute
=
mForgetSkippableFrequencyStartTime
+
kOneMinute
;
TimeStamp
endPoint
=
std
:
:
max
(
startPlusMinute
mLastForgetSkippableEndTime
)
;
double
duration
=
(
endPoint
-
mForgetSkippableFrequencyStartTime
)
.
ToSeconds
(
)
/
60
;
uint32_t
frequencyPerMinute
=
uint32_t
(
mForgetSkippableCounter
/
duration
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FORGET_SKIPPABLE_FREQUENCY
frequencyPerMinute
)
;
mForgetSkippableCounter
=
0
;
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
+
+
mForgetSkippableCounter
;
TimeDuration
budgetTime
=
aDeadline
?
(
aDeadline
-
aStartTimeStamp
)
:
kForgetSkippableSliceDuration
;
return
BudgetFromDuration
(
budgetTime
)
;
}
bool
mInIncrementalGC
=
false
;
TimeStamp
mCCBlockStart
;
TimeStamp
mLastForgetSkippableEndTime
;
uint32_t
mForgetSkippableCounter
=
0
;
TimeStamp
mForgetSkippableFrequencyStartTime
;
TimeDuration
mActiveIntersliceGCBudget
=
TimeDuration
:
:
FromMilliseconds
(
5
)
;
}
;
}
