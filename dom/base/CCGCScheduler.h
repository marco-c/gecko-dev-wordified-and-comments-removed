#
include
"
js
/
SliceBudget
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
IdleTaskRunner
.
h
"
#
include
"
mozilla
/
MainThreadIdlePeriod
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerChild
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsJSEnvironment
.
h
"
namespace
mozilla
{
static
const
TimeDuration
kOneMinute
=
TimeDuration
:
:
FromSeconds
(
60
.
0f
)
;
static
const
TimeDuration
kCCDelay
=
TimeDuration
:
:
FromSeconds
(
6
)
;
static
const
TimeDuration
kCCSkippableDelay
=
TimeDuration
:
:
FromMilliseconds
(
250
)
;
static
const
TimeDuration
kTimeBetweenForgetSkippableCycles
=
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
TimeDuration
kForgetSkippableSliceDuration
=
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
TimeDuration
kICCIntersliceDelay
=
TimeDuration
:
:
FromMilliseconds
(
64
)
;
static
const
TimeDuration
kICCSliceBudget
=
TimeDuration
:
:
FromMilliseconds
(
3
)
;
static
const
TimeDuration
kIdleICCSliceBudget
=
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
TimeDuration
kMaxICCDuration
=
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
TimeDuration
kCCForced
=
kOneMinute
*
2
;
static
const
uint32_t
kCCForcedPurpleLimit
=
10
;
static
const
TimeDuration
kMaxCCLockedoutTime
=
TimeDuration
:
:
FromSeconds
(
30
)
;
static
const
uint32_t
kCCPurpleLimit
=
200
;
static
const
int64_t
kNumCCNodesBetweenTimeChecks
=
1000
;
enum
class
GCRunnerAction
{
WaitToMajorGC
StartMajorGC
GCSlice
None
}
;
struct
GCRunnerStep
{
GCRunnerAction
mAction
;
JS
:
:
GCReason
mReason
;
}
;
enum
class
CCRunnerAction
{
None
ForgetSkippable
CleanupContentUnbinder
CleanupDeferred
CycleCollect
StopRunning
}
;
enum
CCRunnerYield
{
Continue
Yield
}
;
enum
CCRunnerForgetSkippableRemoveChildless
{
KeepChildless
=
false
RemoveChildless
=
true
}
;
struct
CCRunnerStep
{
CCRunnerAction
mAction
;
CCRunnerYield
mYield
;
CCRunnerForgetSkippableRemoveChildless
mRemoveChildless
;
}
;
class
CCGCScheduler
{
public
:
static
TimeStamp
Now
(
)
;
static
uint32_t
SuspectedCCObjects
(
)
;
static
bool
CCRunnerFired
(
TimeStamp
aDeadline
)
;
void
SetActiveIntersliceGCBudget
(
TimeDuration
aDuration
)
{
mActiveIntersliceGCBudget
=
aDuration
;
}
TimeDuration
GetCCBlockedTime
(
TimeStamp
aNow
)
const
{
MOZ_ASSERT
(
mInIncrementalGC
)
;
MOZ_ASSERT
(
!
mCCBlockStart
.
IsNull
(
)
)
;
return
aNow
-
mCCBlockStart
;
}
bool
InIncrementalGC
(
)
const
{
return
mInIncrementalGC
;
}
TimeStamp
GetLastCCEndTime
(
)
const
{
return
mLastCCEndTime
;
}
bool
IsEarlyForgetSkippable
(
uint32_t
aN
=
kMajorForgetSkippableCalls
)
const
{
return
mCleanupsSinceLastGC
<
aN
;
}
bool
NeedsFullGC
(
)
const
{
return
mNeedsFullGC
;
}
void
PokeShrinkingGC
(
)
;
void
PokeFullGC
(
)
;
void
KillShrinkingGCTimer
(
)
;
void
KillFullGCTimer
(
)
;
void
KillGCRunner
(
)
;
void
KillCCRunner
(
)
;
void
KillAllTimersAndRunners
(
)
;
void
EnsureCCRunner
(
TimeDuration
aDelay
TimeDuration
aBudget
)
;
void
SetNeedsFullGC
(
bool
aNeedGC
=
true
)
{
mNeedsFullGC
=
aNeedGC
;
}
void
SetWantMajorGC
(
JS
:
:
GCReason
aReason
)
{
mMajorGCReason
=
aReason
;
if
(
aReason
=
=
JS
:
:
GCReason
:
:
DOM_WINDOW_UTILS
)
{
SetNeedsFullGC
(
)
;
}
}
void
EnsureCCThenGC
(
)
{
MOZ_ASSERT
(
mCCRunnerState
!
=
CCRunnerState
:
:
Inactive
)
;
mNeedsFullCC
=
true
;
mNeedsGCAfterCC
=
true
;
}
[
[
nodiscard
]
]
bool
NoteReadyForMajorGC
(
)
{
if
(
mMajorGCReason
=
=
JS
:
:
GCReason
:
:
NO_REASON
)
{
return
false
;
}
mReadyForMajorGC
=
true
;
return
true
;
}
void
NoteGCBegin
(
)
{
mInIncrementalGC
=
true
;
mReadyForMajorGC
=
false
;
}
void
NoteGCEnd
(
)
{
mMajorGCReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
mInIncrementalGC
=
false
;
mCCBlockStart
=
TimeStamp
(
)
;
mInIncrementalGC
=
false
;
mReadyForMajorGC
=
false
;
mNeedsFullCC
=
true
;
mHasRunGC
=
true
;
mCleanupsSinceLastGC
=
0
;
mCCollectedWaitingForGC
=
0
;
mCCollectedZonesWaitingForGC
=
0
;
mLikelyShortLivingObjectsNeedingGC
=
0
;
}
void
NoteGCSliceEnd
(
TimeDuration
aSliceDuration
)
{
if
(
mMajorGCReason
=
=
JS
:
:
GCReason
:
:
NO_REASON
)
{
mReadyForMajorGC
=
true
;
}
mMajorGCReason
=
JS
:
:
GCReason
:
:
INTER_SLICE_GC
;
mGCUnnotifiedTotalTime
+
=
aSliceDuration
;
}
void
FullGCTimerFired
(
nsITimer
*
aTimer
)
;
void
ShrinkingGCTimerFired
(
nsITimer
*
aTimer
)
;
bool
GCRunnerFired
(
TimeStamp
aDeadline
)
;
using
MayGCPromise
=
MozPromise
<
bool
mozilla
:
:
ipc
:
:
ResponseRejectReason
true
>
;
static
RefPtr
<
MayGCPromise
>
MayGCNow
(
JS
:
:
GCReason
reason
)
;
void
BlockCC
(
TimeStamp
aNow
)
{
MOZ_ASSERT
(
mInIncrementalGC
)
;
MOZ_ASSERT
(
mCCBlockStart
.
IsNull
(
)
)
;
mCCBlockStart
=
aNow
;
}
void
UnblockCC
(
)
{
mCCBlockStart
=
TimeStamp
(
)
;
}
uint32_t
NoteForgetSkippableComplete
(
TimeStamp
aNow
uint32_t
aSuspectedBeforeForgetSkippable
)
{
mLastForgetSkippableEndTime
=
aNow
;
uint32_t
suspected
=
SuspectedCCObjects
(
)
;
mPreviousSuspectedCount
=
suspected
;
mCleanupsSinceLastGC
+
+
;
return
aSuspectedBeforeForgetSkippable
-
suspected
;
}
void
NoteCycleCollected
(
const
CycleCollectorResults
&
aResults
)
{
mCCollectedWaitingForGC
+
=
aResults
.
mFreedGCed
;
mCCollectedZonesWaitingForGC
+
=
aResults
.
mFreedJSZones
;
}
void
NoteCCEnd
(
TimeStamp
aWhen
)
{
mLastCCEndTime
=
aWhen
;
mNeedsFullCC
=
false
;
mNeedsGCAfterCC
=
false
;
}
void
NoteForgetSkippableOnlyCycle
(
)
{
mLastForgetSkippableCycleEndTime
=
Now
(
)
;
}
void
Shutdown
(
)
{
mDidShutdown
=
true
;
}
inline
js
:
:
SliceBudget
ComputeCCSliceBudget
(
TimeStamp
aDeadline
TimeStamp
aCCBeginTime
TimeStamp
aPrevSliceEndTime
bool
*
aPreferShorterSlices
)
const
;
inline
TimeDuration
ComputeInterSliceGCBudget
(
TimeStamp
aDeadline
TimeStamp
aNow
)
const
;
bool
ShouldForgetSkippable
(
)
const
{
return
(
(
mPreviousSuspectedCount
+
100
)
<
=
SuspectedCCObjects
(
)
)
|
|
mCleanupsSinceLastGC
<
kMajorForgetSkippableCalls
;
}
bool
IsCCNeeded
(
TimeStamp
aNow
=
Now
(
)
)
const
{
if
(
mNeedsFullCC
)
{
return
true
;
}
uint32_t
suspected
=
SuspectedCCObjects
(
)
;
return
suspected
>
kCCPurpleLimit
|
|
(
suspected
>
kCCForcedPurpleLimit
&
&
mLastCCEndTime
&
&
aNow
-
mLastCCEndTime
>
kCCForced
)
;
}
inline
bool
ShouldScheduleCC
(
)
const
;
bool
NeedsGCAfterCC
(
)
const
{
return
mCCollectedWaitingForGC
>
250
|
|
mCCollectedZonesWaitingForGC
>
0
|
|
mLikelyShortLivingObjectsNeedingGC
>
2500
|
|
mNeedsGCAfterCC
;
}
bool
IsLastEarlyCCTimer
(
int32_t
aCurrentFireCount
)
const
{
int32_t
numEarlyTimerFires
=
std
:
:
max
(
int32_t
(
mCCDelay
/
kCCSkippableDelay
)
-
2
1
)
;
return
aCurrentFireCount
>
=
numEarlyTimerFires
;
}
enum
class
CCRunnerState
{
Inactive
ReducePurple
CleanupChildless
CleanupContentUnbinder
CleanupDeferred
StartCycleCollection
CycleCollecting
Canceled
NumStates
}
;
void
InitCCRunnerStateMachine
(
CCRunnerState
initialState
)
{
if
(
mCCRunner
)
{
return
;
}
MOZ_ASSERT
(
mCCRunnerState
=
=
CCRunnerState
:
:
Inactive
"
DeactivateCCRunner
should
have
been
called
"
)
;
mCCRunnerState
=
initialState
;
if
(
initialState
=
=
CCRunnerState
:
:
ReducePurple
)
{
mCCDelay
=
kCCDelay
;
mCCRunnerEarlyFireCount
=
0
;
}
else
if
(
initialState
=
=
CCRunnerState
:
:
CycleCollecting
)
{
}
else
{
MOZ_CRASH
(
"
Invalid
initial
state
"
)
;
}
}
void
DeactivateCCRunner
(
)
{
mCCRunnerState
=
CCRunnerState
:
:
Inactive
;
}
inline
GCRunnerStep
GetNextGCRunnerAction
(
TimeStamp
aDeadline
)
;
inline
CCRunnerStep
AdvanceCCRunner
(
TimeStamp
aDeadline
)
;
js
:
:
SliceBudget
ComputeForgetSkippableBudget
(
TimeStamp
aStartTimeStamp
TimeStamp
aDeadline
)
;
private
:
bool
mInIncrementalGC
=
false
;
bool
mReadyForMajorGC
=
false
;
TimeStamp
mCCBlockStart
;
bool
mDidShutdown
=
false
;
TimeStamp
mLastForgetSkippableEndTime
;
uint32_t
mForgetSkippableCounter
=
0
;
TimeStamp
mForgetSkippableFrequencyStartTime
;
TimeStamp
mLastCCEndTime
;
TimeStamp
mLastForgetSkippableCycleEndTime
;
CCRunnerState
mCCRunnerState
=
CCRunnerState
:
:
Inactive
;
int32_t
mCCRunnerEarlyFireCount
=
0
;
TimeDuration
mCCDelay
=
kCCDelay
;
bool
mHasRunGC
=
false
;
bool
mNeedsFullCC
=
false
;
bool
mNeedsFullGC
=
true
;
bool
mNeedsGCAfterCC
=
false
;
uint32_t
mPreviousSuspectedCount
=
0
;
uint32_t
mCleanupsSinceLastGC
=
UINT32_MAX
;
TimeDuration
mGCUnnotifiedTotalTime
;
public
:
RefPtr
<
IdleTaskRunner
>
mGCRunner
;
RefPtr
<
IdleTaskRunner
>
mCCRunner
;
private
:
nsITimer
*
mShrinkingGCTimer
=
nullptr
;
nsITimer
*
mFullGCTimer
=
nullptr
;
public
:
JS
:
:
GCReason
mMajorGCReason
=
JS
:
:
GCReason
:
:
NO_REASON
;
public
:
uint32_t
mCCollectedWaitingForGC
=
0
;
uint32_t
mCCollectedZonesWaitingForGC
=
0
;
uint32_t
mLikelyShortLivingObjectsNeedingGC
=
0
;
TimeDuration
mActiveIntersliceGCBudget
=
TimeDuration
:
:
FromMilliseconds
(
5
)
;
}
;
static
bool
sIsCompactingOnUserInactive
=
false
;
static
bool
sUserIsActive
=
true
;
js
:
:
SliceBudget
CCGCScheduler
:
:
ComputeCCSliceBudget
(
TimeStamp
aDeadline
TimeStamp
aCCBeginTime
TimeStamp
aPrevSliceEndTime
bool
*
aPreferShorterSlices
)
const
{
TimeStamp
now
=
Now
(
)
;
*
aPreferShorterSlices
=
aDeadline
.
IsNull
(
)
|
|
(
aDeadline
-
now
)
<
kICCSliceBudget
;
TimeDuration
baseBudget
=
aDeadline
.
IsNull
(
)
?
kICCSliceBudget
:
aDeadline
-
now
;
if
(
aCCBeginTime
.
IsNull
(
)
)
{
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
baseBudget
)
kNumCCNodesBetweenTimeChecks
)
;
}
MOZ_ASSERT
(
now
>
=
aCCBeginTime
)
;
TimeDuration
runningTime
=
now
-
aCCBeginTime
;
if
(
runningTime
>
=
kMaxICCDuration
)
{
return
js
:
:
SliceBudget
:
:
unlimited
(
)
;
}
const
TimeDuration
maxSlice
=
TimeDuration
:
:
FromMilliseconds
(
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
)
;
MOZ_ASSERT
(
now
>
=
aPrevSliceEndTime
)
;
double
sliceDelayMultiplier
=
(
now
-
aPrevSliceEndTime
)
/
kICCIntersliceDelay
;
TimeDuration
delaySliceBudget
=
std
:
:
min
(
baseBudget
.
MultDouble
(
sliceDelayMultiplier
)
maxSlice
)
;
double
percentToHalfDone
=
std
:
:
min
(
2
.
0
*
(
runningTime
/
kMaxICCDuration
)
1
.
0
)
;
TimeDuration
laterSliceBudget
=
maxSlice
.
MultDouble
(
percentToHalfDone
)
;
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
std
:
:
max
(
{
delaySliceBudget
laterSliceBudget
baseBudget
}
)
)
kNumCCNodesBetweenTimeChecks
)
;
}
inline
TimeDuration
CCGCScheduler
:
:
ComputeInterSliceGCBudget
(
TimeStamp
aDeadline
TimeStamp
aNow
)
const
{
TimeDuration
budget
=
aDeadline
.
IsNull
(
)
?
mActiveIntersliceGCBudget
*
2
:
aDeadline
-
aNow
;
if
(
!
mCCBlockStart
)
{
return
budget
;
}
TimeDuration
blockedTime
=
aNow
-
mCCBlockStart
;
TimeDuration
maxSliceGCBudget
=
mActiveIntersliceGCBudget
*
10
;
double
percentOfBlockedTime
=
std
:
:
min
(
blockedTime
/
kMaxCCLockedoutTime
1
.
0
)
;
return
std
:
:
max
(
budget
maxSliceGCBudget
.
MultDouble
(
percentOfBlockedTime
)
)
;
}
bool
CCGCScheduler
:
:
ShouldScheduleCC
(
)
const
{
if
(
!
mHasRunGC
)
{
return
false
;
}
TimeStamp
now
=
Now
(
)
;
if
(
mCleanupsSinceLastGC
&
&
!
mLastCCEndTime
.
IsNull
(
)
)
{
if
(
now
-
mLastCCEndTime
<
kCCDelay
)
{
return
false
;
}
}
if
(
(
mCleanupsSinceLastGC
>
kMajorForgetSkippableCalls
)
&
&
!
mLastForgetSkippableCycleEndTime
.
IsNull
(
)
)
{
if
(
now
-
mLastForgetSkippableCycleEndTime
<
kTimeBetweenForgetSkippableCycles
)
{
return
false
;
}
}
return
IsCCNeeded
(
now
)
;
}
CCRunnerStep
CCGCScheduler
:
:
AdvanceCCRunner
(
TimeStamp
aDeadline
)
{
struct
StateDescriptor
{
bool
mCanAbortCC
;
bool
mTryFinalForgetSkippable
;
}
;
constexpr
StateDescriptor
stateDescriptors
[
]
=
{
{
false
false
}
{
false
false
}
{
true
true
}
{
true
false
}
{
false
false
}
{
false
false
}
{
false
false
}
{
false
false
}
}
;
static_assert
(
ArrayLength
(
stateDescriptors
)
=
=
size_t
(
CCRunnerState
:
:
NumStates
)
"
need
one
state
descriptor
per
state
"
)
;
const
StateDescriptor
&
desc
=
stateDescriptors
[
int
(
mCCRunnerState
)
]
;
MOZ_ASSERT
(
mCCRunnerState
!
=
CCRunnerState
:
:
Inactive
)
;
if
(
mDidShutdown
)
{
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
if
(
mCCRunnerState
=
=
CCRunnerState
:
:
Canceled
)
{
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
TimeStamp
now
=
Now
(
)
;
if
(
InIncrementalGC
(
)
)
{
if
(
mCCBlockStart
.
IsNull
(
)
)
{
BlockCC
(
now
)
;
if
(
mCCRunnerState
!
=
CCRunnerState
:
:
CycleCollecting
)
{
mCCRunnerState
=
CCRunnerState
:
:
ReducePurple
;
mCCRunnerEarlyFireCount
=
0
;
mCCDelay
=
kCCDelay
/
int64_t
(
3
)
;
}
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
if
(
GetCCBlockedTime
(
now
)
<
kMaxCCLockedoutTime
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
}
if
(
desc
.
mCanAbortCC
&
&
!
IsCCNeeded
(
now
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
Canceled
;
NoteForgetSkippableOnlyCycle
(
)
;
if
(
desc
.
mTryFinalForgetSkippable
&
&
ShouldForgetSkippable
(
)
)
{
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
KeepChildless
}
;
}
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
switch
(
mCCRunnerState
)
{
case
CCRunnerState
:
:
ReducePurple
:
+
+
mCCRunnerEarlyFireCount
;
if
(
IsLastEarlyCCTimer
(
mCCRunnerEarlyFireCount
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
CleanupChildless
;
}
if
(
ShouldForgetSkippable
(
)
)
{
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
KeepChildless
}
;
}
if
(
aDeadline
.
IsNull
(
)
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
mCCRunnerState
=
CCRunnerState
:
:
CleanupChildless
;
return
{
CCRunnerAction
:
:
None
Continue
}
;
case
CCRunnerState
:
:
CleanupChildless
:
mCCRunnerState
=
CCRunnerState
:
:
CleanupContentUnbinder
;
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
RemoveChildless
}
;
case
CCRunnerState
:
:
CleanupContentUnbinder
:
if
(
aDeadline
.
IsNull
(
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
if
(
now
>
=
aDeadline
)
{
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
mCCRunnerState
=
CCRunnerState
:
:
CleanupDeferred
;
return
{
CCRunnerAction
:
:
CleanupContentUnbinder
Continue
}
;
case
CCRunnerState
:
:
CleanupDeferred
:
MOZ_ASSERT
(
!
aDeadline
.
IsNull
(
)
"
Should
only
be
in
CleanupDeferred
state
when
idle
"
)
;
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
if
(
now
>
=
aDeadline
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
return
{
CCRunnerAction
:
:
CleanupDeferred
Yield
}
;
case
CCRunnerState
:
:
StartCycleCollection
:
mCCRunnerState
=
CCRunnerState
:
:
CycleCollecting
;
[
[
fallthrough
]
]
;
case
CCRunnerState
:
:
CycleCollecting
:
return
{
CCRunnerAction
:
:
CycleCollect
Yield
}
;
default
:
MOZ_CRASH
(
"
Unexpected
CCRunner
state
"
)
;
}
;
}
GCRunnerStep
CCGCScheduler
:
:
GetNextGCRunnerAction
(
TimeStamp
aDeadline
)
{
MOZ_ASSERT
(
mMajorGCReason
!
=
JS
:
:
GCReason
:
:
NO_REASON
)
;
if
(
InIncrementalGC
(
)
)
{
return
{
GCRunnerAction
:
:
GCSlice
mMajorGCReason
}
;
}
if
(
mReadyForMajorGC
)
{
return
{
GCRunnerAction
:
:
StartMajorGC
mMajorGCReason
}
;
}
return
{
GCRunnerAction
:
:
WaitToMajorGC
mMajorGCReason
}
;
}
inline
js
:
:
SliceBudget
CCGCScheduler
:
:
ComputeForgetSkippableBudget
(
TimeStamp
aStartTimeStamp
TimeStamp
aDeadline
)
{
if
(
mForgetSkippableFrequencyStartTime
.
IsNull
(
)
)
{
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
else
if
(
aStartTimeStamp
-
mForgetSkippableFrequencyStartTime
>
kOneMinute
)
{
TimeStamp
startPlusMinute
=
mForgetSkippableFrequencyStartTime
+
kOneMinute
;
TimeStamp
endPoint
=
std
:
:
max
(
startPlusMinute
mLastForgetSkippableEndTime
)
;
double
duration
=
(
endPoint
-
mForgetSkippableFrequencyStartTime
)
.
ToSeconds
(
)
/
60
;
uint32_t
frequencyPerMinute
=
uint32_t
(
mForgetSkippableCounter
/
duration
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FORGET_SKIPPABLE_FREQUENCY
frequencyPerMinute
)
;
mForgetSkippableCounter
=
0
;
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
+
+
mForgetSkippableCounter
;
TimeDuration
budgetTime
=
aDeadline
?
(
aDeadline
-
aStartTimeStamp
)
:
kForgetSkippableSliceDuration
;
return
js
:
:
SliceBudget
(
budgetTime
)
;
}
}
