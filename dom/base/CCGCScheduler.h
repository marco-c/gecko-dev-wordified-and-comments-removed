#
include
"
js
/
SliceBudget
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
MainThreadIdlePeriod
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsJSEnvironment
.
h
"
using
mozilla
:
:
TimeDuration
;
static
const
mozilla
:
:
TimeDuration
kOneMinute
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
60
.
0f
)
;
static
const
mozilla
:
:
TimeDuration
kCCDelay
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
6
)
;
static
const
mozilla
:
:
TimeDuration
kCCSkippableDelay
=
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
250
)
;
static
const
mozilla
:
:
TimeDuration
kTimeBetweenForgetSkippableCycles
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
mozilla
:
:
TimeDuration
kForgetSkippableSliceDuration
=
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
mozilla
:
:
TimeDuration
kICCIntersliceDelay
=
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
64
)
;
static
const
mozilla
:
:
TimeDuration
kICCSliceBudget
=
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
3
)
;
static
const
mozilla
:
:
TimeDuration
kIdleICCSliceBudget
=
mozilla
:
:
TimeDuration
:
:
FromMilliseconds
(
2
)
;
static
const
mozilla
:
:
TimeDuration
kMaxICCDuration
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
2
)
;
static
const
mozilla
:
:
TimeDuration
kCCForced
=
kOneMinute
*
2
;
static
const
uint32_t
kCCForcedPurpleLimit
=
10
;
static
const
mozilla
:
:
TimeDuration
kMaxCCLockedoutTime
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
30
)
;
static
const
uint32_t
kCCPurpleLimit
=
200
;
namespace
mozilla
{
MOZ_ALWAYS_INLINE
static
TimeDuration
TimeBetween
(
TimeStamp
aStart
TimeStamp
aEnd
)
{
MOZ_ASSERT
(
aEnd
>
=
aStart
)
;
return
aEnd
-
aStart
;
}
static
inline
js
:
:
SliceBudget
BudgetFromDuration
(
TimeDuration
aDuration
)
{
return
js
:
:
SliceBudget
(
js
:
:
TimeBudget
(
aDuration
.
ToMilliseconds
(
)
)
)
;
}
class
CCGCScheduler
{
public
:
void
SetActiveIntersliceGCBudget
(
TimeDuration
aDuration
)
{
mActiveIntersliceGCBudget
=
aDuration
;
}
TimeDuration
GetCCBlockedTime
(
TimeStamp
aNow
)
const
{
MOZ_ASSERT
(
mInIncrementalGC
)
;
MOZ_ASSERT
(
!
mCCBlockStart
.
IsNull
(
)
)
;
return
aNow
-
mCCBlockStart
;
}
bool
InIncrementalGC
(
)
const
{
return
mInIncrementalGC
;
}
TimeStamp
GetLastCCEndTime
(
)
const
{
return
mLastCCEndTime
;
}
bool
IsEarlyForgetSkippable
(
uint32_t
aN
=
kMajorForgetSkippableCalls
)
const
{
return
mCleanupsSinceLastGC
<
aN
;
}
bool
NeedsFullGC
(
)
const
{
return
mNeedsFullGC
;
}
void
SetNeedsFullGC
(
bool
aNeedGC
=
true
)
{
mNeedsFullGC
=
aNeedGC
;
}
void
EnsureCCThenGC
(
)
{
MOZ_ASSERT
(
mCCRunnerState
!
=
CCRunnerState
:
:
Inactive
)
;
mNeedsFullCC
=
true
;
mNeedsGCAfterCC
=
true
;
}
void
NoteGCBegin
(
)
{
mInIncrementalGC
=
true
;
}
void
NoteGCEnd
(
)
{
mInIncrementalGC
=
false
;
mCCBlockStart
=
TimeStamp
(
)
;
mInIncrementalGC
=
false
;
mNeedsFullCC
=
true
;
mHasRunGC
=
true
;
mCleanupsSinceLastGC
=
0
;
mCCollectedWaitingForGC
=
0
;
mCCollectedZonesWaitingForGC
=
0
;
mLikelyShortLivingObjectsNeedingGC
=
0
;
}
void
BlockCC
(
TimeStamp
aNow
)
{
MOZ_ASSERT
(
mInIncrementalGC
)
;
MOZ_ASSERT
(
mCCBlockStart
.
IsNull
(
)
)
;
mCCBlockStart
=
aNow
;
}
void
UnblockCC
(
)
{
mCCBlockStart
=
TimeStamp
(
)
;
}
uint32_t
NoteForgetSkippableComplete
(
TimeStamp
aNow
uint32_t
aSuspectedBeforeForgetSkippable
)
{
mLastForgetSkippableEndTime
=
aNow
;
uint32_t
suspected
=
nsCycleCollector_suspectedCount
(
)
;
mPreviousSuspectedCount
=
suspected
;
mCleanupsSinceLastGC
+
+
;
return
aSuspectedBeforeForgetSkippable
-
suspected
;
}
void
NoteCycleCollected
(
const
CycleCollectorResults
&
aResults
)
{
mCCollectedWaitingForGC
+
=
aResults
.
mFreedGCed
;
mCCollectedZonesWaitingForGC
+
=
aResults
.
mFreedJSZones
;
}
void
NoteCCEnd
(
TimeStamp
aWhen
)
{
mLastCCEndTime
=
aWhen
;
mNeedsFullCC
=
false
;
mNeedsGCAfterCC
=
false
;
}
void
NoteForgetSkippableOnlyCycle
(
)
{
mLastForgetSkippableCycleEndTime
=
TimeStamp
:
:
Now
(
)
;
}
void
Shutdown
(
)
{
mDidShutdown
=
true
;
}
TimeDuration
ComputeInterSliceGCBudget
(
TimeStamp
aDeadline
TimeStamp
aNow
)
const
{
TimeDuration
budget
=
aDeadline
.
IsNull
(
)
?
mActiveIntersliceGCBudget
*
2
:
aDeadline
-
aNow
;
if
(
!
mCCBlockStart
)
{
return
budget
;
}
TimeDuration
blockedTime
=
aNow
-
mCCBlockStart
;
TimeDuration
maxSliceGCBudget
=
mActiveIntersliceGCBudget
*
10
;
double
percentOfBlockedTime
=
std
:
:
min
(
blockedTime
/
kMaxCCLockedoutTime
1
.
0
)
;
return
std
:
:
max
(
budget
maxSliceGCBudget
.
MultDouble
(
percentOfBlockedTime
)
)
;
}
js
:
:
SliceBudget
ComputeCCSliceBudget
(
TimeStamp
aDeadline
TimeStamp
aCCBeginTime
TimeStamp
aPrevSliceEndTime
bool
*
aPreferShorterSlices
)
const
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
*
aPreferShorterSlices
=
aDeadline
.
IsNull
(
)
|
|
(
aDeadline
-
now
)
<
kICCSliceBudget
;
TimeDuration
baseBudget
=
aDeadline
.
IsNull
(
)
?
kICCSliceBudget
:
aDeadline
-
now
;
if
(
aCCBeginTime
.
IsNull
(
)
)
{
return
BudgetFromDuration
(
baseBudget
)
;
}
TimeDuration
runningTime
=
TimeBetween
(
aCCBeginTime
now
)
;
if
(
runningTime
>
=
kMaxICCDuration
)
{
return
js
:
:
SliceBudget
:
:
unlimited
(
)
;
}
const
TimeDuration
maxSlice
=
TimeDuration
:
:
FromMilliseconds
(
mozilla
:
:
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
)
;
double
sliceDelayMultiplier
=
TimeBetween
(
aPrevSliceEndTime
now
)
/
kICCIntersliceDelay
;
TimeDuration
delaySliceBudget
=
std
:
:
min
(
baseBudget
.
MultDouble
(
sliceDelayMultiplier
)
maxSlice
)
;
double
percentToHalfDone
=
std
:
:
min
(
2
.
0
*
(
runningTime
/
kMaxICCDuration
)
1
.
0
)
;
TimeDuration
laterSliceBudget
=
maxSlice
.
MultDouble
(
percentToHalfDone
)
;
return
BudgetFromDuration
(
std
:
:
max
(
{
delaySliceBudget
laterSliceBudget
baseBudget
}
)
)
;
}
bool
ShouldForgetSkippable
(
uint32_t
aSuspected
)
const
{
return
(
(
mPreviousSuspectedCount
+
100
)
<
=
aSuspected
)
|
|
mCleanupsSinceLastGC
<
kMajorForgetSkippableCalls
;
}
bool
IsCCNeeded
(
uint32_t
aSuspected
TimeStamp
aNow
=
TimeStamp
:
:
Now
(
)
)
const
{
return
mNeedsFullCC
|
|
aSuspected
>
kCCPurpleLimit
|
|
(
aSuspected
>
kCCForcedPurpleLimit
&
&
mLastCCEndTime
&
&
aNow
-
mLastCCEndTime
>
kCCForced
)
;
}
bool
ShouldScheduleCC
(
)
const
{
if
(
!
mHasRunGC
)
{
return
false
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
mCleanupsSinceLastGC
&
&
!
mLastCCEndTime
.
IsNull
(
)
)
{
if
(
now
-
mLastCCEndTime
<
kCCDelay
)
{
return
false
;
}
}
if
(
(
mCleanupsSinceLastGC
>
kMajorForgetSkippableCalls
)
&
&
!
mLastForgetSkippableCycleEndTime
.
IsNull
(
)
)
{
if
(
now
-
mLastForgetSkippableCycleEndTime
<
kTimeBetweenForgetSkippableCycles
)
{
return
false
;
}
}
return
IsCCNeeded
(
nsCycleCollector_suspectedCount
(
)
now
)
;
}
bool
NeedsGCAfterCC
(
)
const
{
return
mCCollectedWaitingForGC
>
250
|
|
mCCollectedZonesWaitingForGC
>
0
|
|
mLikelyShortLivingObjectsNeedingGC
>
2500
|
|
mNeedsGCAfterCC
;
}
bool
IsLastEarlyCCTimer
(
int32_t
aCurrentFireCount
)
const
{
int32_t
numEarlyTimerFires
=
std
:
:
max
(
int32_t
(
mCCDelay
/
kCCSkippableDelay
)
-
2
1
)
;
return
aCurrentFireCount
>
=
numEarlyTimerFires
;
}
enum
class
CCRunnerAction
{
None
ForgetSkippable
CleanupContentUnbinder
CleanupDeferred
CycleCollect
StopRunning
}
;
enum
class
CCRunnerState
{
Inactive
ReducePurple
CleanupChildless
CleanupContentUnbinder
CleanupDeferred
StartCycleCollection
CycleCollecting
}
;
enum
CCRunnerYield
{
Continue
Yield
}
;
enum
CCRunnerForgetSkippableRemoveChildless
{
KeepChildless
=
false
RemoveChildless
=
true
}
;
struct
CCRunnerStep
{
CCRunnerAction
mAction
;
CCRunnerYield
mYield
;
CCRunnerForgetSkippableRemoveChildless
mRemoveChildless
;
}
;
void
InitCCRunnerStateMachine
(
CCRunnerState
initialState
)
{
MOZ_ASSERT
(
mCCRunnerState
=
=
CCRunnerState
:
:
Inactive
)
;
mCCRunnerState
=
initialState
;
if
(
initialState
=
=
CCRunnerState
:
:
ReducePurple
)
{
mCCDelay
=
kCCDelay
;
mCCRunnerEarlyFireCount
=
0
;
}
else
if
(
initialState
=
=
CCRunnerState
:
:
CycleCollecting
)
{
}
else
{
MOZ_CRASH
(
"
Invalid
initial
state
"
)
;
}
}
void
DeactivateCCRunner
(
)
{
mCCRunnerState
=
CCRunnerState
:
:
Inactive
;
}
CCRunnerStep
GetNextCCRunnerAction
(
TimeStamp
aDeadline
uint32_t
aSuspected
)
{
struct
StateDescriptor
{
bool
mCanAbortCC
;
bool
mTryFinalForgetSkippable
;
}
;
constexpr
StateDescriptor
stateDescriptors
[
]
=
{
[
int
(
CCRunnerState
:
:
Inactive
)
]
=
{
false
false
}
[
int
(
CCRunnerState
:
:
ReducePurple
)
]
=
{
false
false
}
[
int
(
CCRunnerState
:
:
CleanupChildless
)
]
=
{
true
true
}
[
int
(
CCRunnerState
:
:
CleanupContentUnbinder
)
]
=
{
true
false
}
[
int
(
CCRunnerState
:
:
CleanupDeferred
)
]
=
{
false
false
}
[
int
(
CCRunnerState
:
:
StartCycleCollection
)
]
=
{
false
false
}
[
int
(
CCRunnerState
:
:
CycleCollecting
)
]
=
{
false
false
}
}
;
const
StateDescriptor
&
desc
=
stateDescriptors
[
int
(
mCCRunnerState
)
]
;
if
(
mDidShutdown
)
{
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
if
(
mCCRunnerState
=
=
CCRunnerState
:
:
Inactive
)
{
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
InIncrementalGC
(
)
)
{
if
(
mCCBlockStart
.
IsNull
(
)
)
{
BlockCC
(
now
)
;
if
(
mCCRunnerState
!
=
CCRunnerState
:
:
CycleCollecting
)
{
mCCRunnerState
=
CCRunnerState
:
:
ReducePurple
;
mCCRunnerEarlyFireCount
=
0
;
mCCDelay
=
kCCDelay
/
int64_t
(
3
)
;
}
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
if
(
GetCCBlockedTime
(
now
)
<
kMaxCCLockedoutTime
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
}
if
(
desc
.
mCanAbortCC
&
&
!
IsCCNeeded
(
aSuspected
now
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
Inactive
;
NoteForgetSkippableOnlyCycle
(
)
;
if
(
desc
.
mTryFinalForgetSkippable
&
&
ShouldForgetSkippable
(
aSuspected
)
)
{
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
KeepChildless
}
;
}
return
{
CCRunnerAction
:
:
StopRunning
Yield
}
;
}
switch
(
mCCRunnerState
)
{
case
CCRunnerState
:
:
ReducePurple
:
+
+
mCCRunnerEarlyFireCount
;
if
(
IsLastEarlyCCTimer
(
mCCRunnerEarlyFireCount
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
CleanupChildless
;
}
if
(
ShouldForgetSkippable
(
aSuspected
)
)
{
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
KeepChildless
}
;
}
if
(
aDeadline
.
IsNull
(
)
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
mCCRunnerState
=
CCRunnerState
:
:
CleanupChildless
;
return
{
CCRunnerAction
:
:
None
Continue
}
;
case
CCRunnerState
:
:
CleanupChildless
:
mCCRunnerState
=
CCRunnerState
:
:
CleanupContentUnbinder
;
return
{
CCRunnerAction
:
:
ForgetSkippable
Yield
RemoveChildless
}
;
case
CCRunnerState
:
:
CleanupContentUnbinder
:
if
(
aDeadline
.
IsNull
(
)
)
{
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
if
(
now
>
=
aDeadline
)
{
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
mCCRunnerState
=
CCRunnerState
:
:
CleanupDeferred
;
return
{
CCRunnerAction
:
:
CleanupContentUnbinder
Continue
}
;
case
CCRunnerState
:
:
CleanupDeferred
:
MOZ_ASSERT
(
!
aDeadline
.
IsNull
(
)
"
Should
only
be
in
CleanupDeferred
state
when
idle
"
)
;
mCCRunnerState
=
CCRunnerState
:
:
StartCycleCollection
;
if
(
now
>
=
aDeadline
)
{
return
{
CCRunnerAction
:
:
None
Yield
}
;
}
return
{
CCRunnerAction
:
:
CleanupDeferred
Yield
}
;
case
CCRunnerState
:
:
StartCycleCollection
:
mCCRunnerState
=
CCRunnerState
:
:
CycleCollecting
;
[
[
fallthrough
]
]
;
case
CCRunnerState
:
:
CycleCollecting
:
return
{
CCRunnerAction
:
:
CycleCollect
Yield
}
;
default
:
MOZ_CRASH
(
"
Unexpected
CCRunner
state
"
)
;
}
;
}
js
:
:
SliceBudget
ComputeForgetSkippableBudget
(
TimeStamp
aStartTimeStamp
TimeStamp
aDeadline
)
{
if
(
mForgetSkippableFrequencyStartTime
.
IsNull
(
)
)
{
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
else
if
(
aStartTimeStamp
-
mForgetSkippableFrequencyStartTime
>
kOneMinute
)
{
TimeStamp
startPlusMinute
=
mForgetSkippableFrequencyStartTime
+
kOneMinute
;
TimeStamp
endPoint
=
std
:
:
max
(
startPlusMinute
mLastForgetSkippableEndTime
)
;
double
duration
=
(
endPoint
-
mForgetSkippableFrequencyStartTime
)
.
ToSeconds
(
)
/
60
;
uint32_t
frequencyPerMinute
=
uint32_t
(
mForgetSkippableCounter
/
duration
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
FORGET_SKIPPABLE_FREQUENCY
frequencyPerMinute
)
;
mForgetSkippableCounter
=
0
;
mForgetSkippableFrequencyStartTime
=
aStartTimeStamp
;
}
+
+
mForgetSkippableCounter
;
TimeDuration
budgetTime
=
aDeadline
?
(
aDeadline
-
aStartTimeStamp
)
:
kForgetSkippableSliceDuration
;
return
BudgetFromDuration
(
budgetTime
)
;
}
private
:
bool
mInIncrementalGC
=
false
;
TimeStamp
mCCBlockStart
;
bool
mDidShutdown
=
false
;
TimeStamp
mLastForgetSkippableEndTime
;
uint32_t
mForgetSkippableCounter
=
0
;
TimeStamp
mForgetSkippableFrequencyStartTime
;
TimeStamp
mLastCCEndTime
;
TimeStamp
mLastForgetSkippableCycleEndTime
;
CCRunnerState
mCCRunnerState
=
CCRunnerState
:
:
Inactive
;
int32_t
mCCRunnerEarlyFireCount
=
0
;
TimeDuration
mCCDelay
=
kCCDelay
;
bool
mHasRunGC
=
false
;
bool
mNeedsFullCC
=
false
;
bool
mNeedsFullGC
=
true
;
bool
mNeedsGCAfterCC
=
false
;
uint32_t
mPreviousSuspectedCount
=
0
;
uint32_t
mCleanupsSinceLastGC
=
UINT32_MAX
;
public
:
uint32_t
mCCollectedWaitingForGC
=
0
;
uint32_t
mCCollectedZonesWaitingForGC
=
0
;
uint32_t
mLikelyShortLivingObjectsNeedingGC
=
0
;
TimeDuration
mActiveIntersliceGCBudget
=
TimeDuration
:
:
FromMilliseconds
(
5
)
;
}
;
}
