#
include
"
ContentIterator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
define
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
aResultType
aMethodName
.
.
.
)
\
template
aResultType
ContentIteratorBase
<
RefPtr
<
nsINode
>
>
:
:
aMethodName
(
\
__VA_ARGS__
)
;
\
template
aResultType
ContentIteratorBase
<
nsINode
*
>
:
:
aMethodName
(
__VA_ARGS__
)
static
bool
ComparePostMode
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
nsINode
&
aNode
)
{
nsINode
*
parent
=
aNode
.
GetParentNode
(
)
;
if
(
!
parent
)
{
return
false
;
}
nsIContent
*
content
=
NS_WARN_IF
(
!
aNode
.
IsContent
(
)
)
?
nullptr
:
aNode
.
AsContent
(
)
;
RawRangeBoundary
afterNode
(
parent
content
)
;
const
auto
isStartLessThanAfterNode
=
[
&
]
(
)
{
const
Maybe
<
int32_t
>
startComparedToAfterNode
=
nsContentUtils
:
:
ComparePoints
(
aStart
afterNode
)
;
return
!
NS_WARN_IF
(
!
startComparedToAfterNode
)
&
&
(
*
startComparedToAfterNode
<
0
)
;
}
;
const
auto
isAfterNodeLessOrEqualToEnd
=
[
&
]
(
)
{
const
Maybe
<
int32_t
>
afterNodeComparedToEnd
=
nsContentUtils
:
:
ComparePoints
(
afterNode
aEnd
)
;
return
!
NS_WARN_IF
(
!
afterNodeComparedToEnd
)
&
&
(
*
afterNodeComparedToEnd
<
=
0
)
;
}
;
return
isStartLessThanAfterNode
(
)
&
&
isAfterNodeLessOrEqualToEnd
(
)
;
}
static
bool
ComparePreMode
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
nsINode
&
aNode
)
{
nsINode
*
parent
=
aNode
.
GetParentNode
(
)
;
if
(
!
parent
)
{
return
false
;
}
RawRangeBoundary
beforeNode
(
parent
aNode
.
GetPreviousSibling
(
)
)
;
const
auto
isStartLessOrEqualToBeforeNode
=
[
&
]
(
)
{
const
Maybe
<
int32_t
>
startComparedToBeforeNode
=
nsContentUtils
:
:
ComparePoints
(
aStart
beforeNode
)
;
return
!
NS_WARN_IF
(
!
startComparedToBeforeNode
)
&
&
(
*
startComparedToBeforeNode
<
=
0
)
;
}
;
const
auto
isBeforeNodeLessThanEndNode
=
[
&
]
(
)
{
const
Maybe
<
int32_t
>
beforeNodeComparedToEnd
=
nsContentUtils
:
:
ComparePoints
(
beforeNode
aEnd
)
;
return
!
NS_WARN_IF
(
!
beforeNodeComparedToEnd
)
&
&
(
*
beforeNodeComparedToEnd
<
0
)
;
}
;
return
isStartLessOrEqualToBeforeNode
(
)
&
&
isBeforeNodeLessThanEndNode
(
)
;
}
static
bool
NodeIsInTraversalRange
(
nsINode
*
aNode
bool
aIsPreMode
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
if
(
NS_WARN_IF
(
!
aStart
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEnd
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
if
(
aNode
=
=
aStart
.
GetContainer
(
)
|
|
aNode
=
=
aEnd
.
GetContainer
(
)
)
{
if
(
aNode
-
>
IsCharacterData
(
)
)
{
return
true
;
}
if
(
!
aNode
-
>
HasChildren
(
)
)
{
MOZ_ASSERT
(
aNode
!
=
aStart
.
GetContainer
(
)
|
|
aStart
.
IsStartOfContainer
(
)
"
aStart
.
GetContainer
(
)
doesn
'
t
have
children
and
not
a
data
node
"
"
aStart
should
be
at
the
beginning
of
its
container
"
)
;
MOZ_ASSERT
(
aNode
!
=
aEnd
.
GetContainer
(
)
|
|
aEnd
.
IsStartOfContainer
(
)
"
aEnd
.
GetContainer
(
)
doesn
'
t
have
children
and
not
a
data
node
"
"
aEnd
should
be
at
the
beginning
of
its
container
"
)
;
return
true
;
}
}
if
(
aIsPreMode
)
{
return
ComparePreMode
(
aStart
aEnd
*
aNode
)
;
}
return
ComparePostMode
(
aStart
aEnd
*
aNode
)
;
}
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
PostContentIterator
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
static_cast
<
SafeContentIteratorBase
&
>
(
aField
)
aName
aFlags
)
;
}
void
ImplCycleCollectionUnlink
(
PostContentIterator
&
aField
)
{
ImplCycleCollectionUnlink
(
static_cast
<
SafeContentIteratorBase
&
>
(
aField
)
)
;
}
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
PreContentIterator
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
static_cast
<
SafeContentIteratorBase
&
>
(
aField
)
aName
aFlags
)
;
}
void
ImplCycleCollectionUnlink
(
PreContentIterator
&
aField
)
{
ImplCycleCollectionUnlink
(
static_cast
<
SafeContentIteratorBase
&
>
(
aField
)
)
;
}
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ContentSubtreeIterator
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mRange
aName
aFlags
)
;
ImplCycleCollectionTraverse
(
aCallback
static_cast
<
SafeContentIteratorBase
&
>
(
aField
)
aName
aFlags
)
;
}
void
ImplCycleCollectionUnlink
(
ContentSubtreeIterator
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mRange
)
;
ImplCycleCollectionUnlink
(
static_cast
<
SafeContentIteratorBase
&
>
(
aField
)
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
ContentIteratorBase
Order
)
;
template
<
typename
NodeType
>
ContentIteratorBase
<
NodeType
>
:
:
ContentIteratorBase
(
Order
aOrder
)
:
mOrder
(
aOrder
)
{
}
template
ContentIteratorBase
<
RefPtr
<
nsINode
>
>
:
:
~
ContentIteratorBase
(
)
;
template
ContentIteratorBase
<
nsINode
*
>
:
:
~
ContentIteratorBase
(
)
;
template
<
typename
NodeType
>
ContentIteratorBase
<
NodeType
>
:
:
~
ContentIteratorBase
(
)
{
MOZ_DIAGNOSTIC_ASSERT_IF
(
mMutationGuard
.
isSome
(
)
!
mMutationGuard
-
>
Mutated
(
0
)
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
nsresult
Init
nsINode
*
)
;
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
Init
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
mOrder
=
=
Order
:
:
Pre
)
{
mFirst
=
aRoot
;
mLast
=
ContentIteratorBase
:
:
GetDeepLastChild
(
aRoot
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetDeepLastChild
returned
null
"
)
;
}
else
{
mFirst
=
ContentIteratorBase
:
:
GetDeepFirstChild
(
aRoot
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetDeepFirstChild
returned
null
"
)
;
mLast
=
aRoot
;
}
mClosestCommonInclusiveAncestor
=
aRoot
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
nsresult
Init
AbstractRange
*
)
;
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
Init
(
AbstractRange
*
aRange
)
{
if
(
NS_WARN_IF
(
!
aRange
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
aRange
-
>
StartRef
(
)
.
AsRaw
(
)
aRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
nsresult
Init
nsINode
*
uint32_t
nsINode
*
uint32_t
)
;
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
RangeUtils
:
:
IsValidPoints
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
nsresult
Init
const
RawRangeBoundary
&
const
RawRangeBoundary
&
)
;
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
if
(
NS_WARN_IF
(
!
RangeUtils
:
:
IsValidPoints
(
aStart
aEnd
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
aStart
aEnd
)
;
}
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
InitWithoutValidatingPoints
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
MOZ_DIAGNOSTIC_ASSERT
(
RangeUtils
:
:
IsValidPoints
(
aStart
aEnd
)
)
;
return
InitInternal
(
aStart
aEnd
)
;
}
template
<
typename
NodeType
>
class
MOZ_STACK_CLASS
ContentIteratorBase
<
NodeType
>
:
:
Initializer
final
{
public
:
Initializer
(
ContentIteratorBase
<
NodeType
>
&
aIterator
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
:
mIterator
{
aIterator
}
mStart
{
aStart
}
mEnd
{
aEnd
}
mStartIsCharacterData
{
mStart
.
GetContainer
(
)
-
>
IsCharacterData
(
)
}
{
MOZ_ASSERT
(
mStart
.
IsSetAndValid
(
)
)
;
MOZ_ASSERT
(
mEnd
.
IsSetAndValid
(
)
)
;
}
nsresult
Run
(
)
;
private
:
nsINode
*
DetermineFirstNode
(
)
const
;
[
[
nodiscard
]
]
Result
<
nsINode
*
nsresult
>
DetermineLastNode
(
)
const
;
bool
IsCollapsedNonCharacterRange
(
)
const
;
bool
IsSingleNodeCharacterRange
(
)
const
;
ContentIteratorBase
&
mIterator
;
const
RawRangeBoundary
&
mStart
;
const
RawRangeBoundary
&
mEnd
;
const
bool
mStartIsCharacterData
;
}
;
template
<
>
nsresult
ContentIteratorBase
<
RefPtr
<
nsINode
>
>
:
:
InitInternal
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
Initializer
initializer
{
*
this
aStart
aEnd
}
;
return
initializer
.
Run
(
)
;
}
template
<
>
nsresult
ContentIteratorBase
<
nsINode
*
>
:
:
InitInternal
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
Initializer
initializer
{
*
this
aStart
aEnd
}
;
nsresult
rv
=
initializer
.
Run
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mMutationGuard
.
emplace
(
)
;
mAssertNoGC
.
emplace
(
)
;
return
NS_OK
;
}
template
<
typename
NodeType
>
bool
ContentIteratorBase
<
NodeType
>
:
:
Initializer
:
:
IsCollapsedNonCharacterRange
(
)
const
{
return
!
mStartIsCharacterData
&
&
mStart
=
=
mEnd
;
}
template
<
typename
NodeType
>
bool
ContentIteratorBase
<
NodeType
>
:
:
Initializer
:
:
IsSingleNodeCharacterRange
(
)
const
{
return
mStartIsCharacterData
&
&
mStart
.
GetContainer
(
)
=
=
mEnd
.
GetContainer
(
)
;
}
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
Initializer
:
:
Run
(
)
{
mIterator
.
mClosestCommonInclusiveAncestor
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
mStart
.
GetContainer
(
)
mEnd
.
GetContainer
(
)
)
;
if
(
NS_WARN_IF
(
!
mIterator
.
mClosestCommonInclusiveAncestor
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
IsCollapsedNonCharacterRange
(
)
)
{
mIterator
.
SetEmpty
(
)
;
return
NS_OK
;
}
if
(
IsSingleNodeCharacterRange
(
)
)
{
mIterator
.
mFirst
=
mStart
.
GetContainer
(
)
-
>
AsContent
(
)
;
mIterator
.
mLast
=
mIterator
.
mFirst
;
mIterator
.
mCurNode
=
mIterator
.
mFirst
;
return
NS_OK
;
}
mIterator
.
mFirst
=
DetermineFirstNode
(
)
;
if
(
Result
<
nsINode
*
nsresult
>
lastNode
=
DetermineLastNode
(
)
;
NS_WARN_IF
(
lastNode
.
isErr
(
)
)
)
{
return
lastNode
.
unwrapErr
(
)
;
}
else
{
mIterator
.
mLast
=
lastNode
.
unwrap
(
)
;
}
if
(
!
mIterator
.
mFirst
|
|
!
mIterator
.
mLast
)
{
mIterator
.
SetEmpty
(
)
;
}
mIterator
.
mCurNode
=
mIterator
.
mFirst
;
return
NS_OK
;
}
template
<
typename
NodeType
>
nsINode
*
ContentIteratorBase
<
NodeType
>
:
:
Initializer
:
:
DetermineFirstNode
(
)
const
{
nsIContent
*
cChild
=
nullptr
;
if
(
!
mStartIsCharacterData
)
{
cChild
=
mStart
.
GetChildAtOffset
(
)
;
}
if
(
!
cChild
)
{
if
(
mIterator
.
mOrder
=
=
Order
:
:
Pre
)
{
bool
startIsContainer
=
true
;
if
(
mStart
.
GetContainer
(
)
-
>
IsHTMLElement
(
)
)
{
nsAtom
*
name
=
mStart
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
startIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
if
(
!
mStartIsCharacterData
&
&
(
startIsContainer
|
|
!
mStart
.
IsStartOfContainer
(
)
)
)
{
nsINode
*
const
result
=
ContentIteratorBase
:
:
GetNextSibling
(
mStart
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
result
"
GetNextSibling
returned
null
"
)
;
if
(
result
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
result
mIterator
.
mOrder
=
=
Order
:
:
Pre
mStart
mEnd
)
)
)
{
return
nullptr
;
}
return
result
;
}
return
mStart
.
GetContainer
(
)
-
>
AsContent
(
)
;
}
if
(
NS_WARN_IF
(
!
mStart
.
GetContainer
(
)
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
return
mStart
.
GetContainer
(
)
-
>
AsContent
(
)
;
}
if
(
mIterator
.
mOrder
=
=
Order
:
:
Pre
)
{
return
cChild
;
}
nsINode
*
const
result
=
ContentIteratorBase
:
:
GetDeepFirstChild
(
cChild
)
;
NS_WARNING_ASSERTION
(
result
"
GetDeepFirstChild
returned
null
"
)
;
if
(
result
&
&
!
NodeIsInTraversalRange
(
result
mIterator
.
mOrder
=
=
Order
:
:
Pre
mStart
mEnd
)
)
{
return
nullptr
;
}
return
result
;
}
template
<
typename
NodeType
>
Result
<
nsINode
*
nsresult
>
ContentIteratorBase
<
NodeType
>
:
:
Initializer
:
:
DetermineLastNode
(
)
const
{
const
bool
endIsCharacterData
=
mEnd
.
GetContainer
(
)
-
>
IsCharacterData
(
)
;
if
(
endIsCharacterData
|
|
!
mEnd
.
GetContainer
(
)
-
>
HasChildren
(
)
|
|
mEnd
.
IsStartOfContainer
(
)
)
{
if
(
mIterator
.
mOrder
=
=
Order
:
:
Pre
)
{
if
(
NS_WARN_IF
(
!
mEnd
.
GetContainer
(
)
-
>
IsContent
(
)
)
)
{
return
nullptr
;
}
bool
endIsContainer
=
true
;
if
(
mEnd
.
GetContainer
(
)
-
>
IsHTMLElement
(
)
)
{
nsAtom
*
name
=
mEnd
.
GetContainer
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
endIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
if
(
!
endIsCharacterData
&
&
!
endIsContainer
&
&
mEnd
.
IsStartOfContainer
(
)
)
{
nsINode
*
const
result
=
mIterator
.
PrevNode
(
mEnd
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
result
"
PrevNode
returned
null
"
)
;
if
(
result
&
&
result
!
=
mIterator
.
mFirst
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
result
mIterator
.
mOrder
=
=
Order
:
:
Pre
RawRangeBoundary
(
mIterator
.
mFirst
0u
)
mEnd
)
)
)
{
return
nullptr
;
}
return
result
;
}
return
mEnd
.
GetContainer
(
)
-
>
AsContent
(
)
;
}
if
(
!
endIsCharacterData
)
{
nsINode
*
const
result
=
ContentIteratorBase
:
:
GetPrevSibling
(
mEnd
.
GetContainer
(
)
)
;
NS_WARNING_ASSERTION
(
result
"
GetPrevSibling
returned
null
"
)
;
if
(
!
NodeIsInTraversalRange
(
result
mIterator
.
mOrder
=
=
Order
:
:
Pre
mStart
mEnd
)
)
{
return
nullptr
;
}
return
result
;
}
return
mEnd
.
GetContainer
(
)
-
>
AsContent
(
)
;
}
nsIContent
*
cChild
=
mEnd
.
Ref
(
)
;
if
(
NS_WARN_IF
(
!
cChild
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
ContentIterator
:
:
ContentIterator
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
mIterator
.
mOrder
=
=
Order
:
:
Pre
)
{
nsINode
*
const
result
=
ContentIteratorBase
:
:
GetDeepLastChild
(
cChild
)
;
NS_WARNING_ASSERTION
(
result
"
GetDeepLastChild
returned
null
"
)
;
if
(
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
result
mIterator
.
mOrder
=
=
Order
:
:
Pre
mStart
mEnd
)
)
)
{
return
nullptr
;
}
return
result
;
}
return
cChild
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
void
SetEmpty
)
;
template
<
typename
NodeType
>
void
ContentIteratorBase
<
NodeType
>
:
:
SetEmpty
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mClosestCommonInclusiveAncestor
=
nullptr
;
}
template
<
typename
NodeType
>
nsINode
*
ContentIteratorBase
<
NodeType
>
:
:
GetDeepFirstChild
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
return
ContentIteratorBase
:
:
GetDeepFirstChild
(
aRoot
-
>
GetFirstChild
(
)
)
;
}
template
<
typename
NodeType
>
nsIContent
*
ContentIteratorBase
<
NodeType
>
:
:
GetDeepFirstChild
(
nsIContent
*
aRoot
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
nsIContent
*
child
=
nullptr
;
if
(
ShadowRoot
*
shadowRoot
=
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
node
aAllowCrossShadowBoundary
)
)
{
MOZ_ASSERT
(
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
;
child
=
shadowRoot
-
>
GetFirstChild
(
)
;
}
else
{
child
=
node
-
>
GetFirstChild
(
)
;
}
while
(
child
)
{
node
=
child
;
if
(
ShadowRoot
*
shadowRoot
=
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
node
aAllowCrossShadowBoundary
)
)
{
child
=
shadowRoot
-
>
GetFirstChild
(
)
;
}
else
{
child
=
node
-
>
GetFirstChild
(
)
;
}
}
return
node
;
}
template
<
typename
NodeType
>
nsINode
*
ContentIteratorBase
<
NodeType
>
:
:
GetDeepLastChild
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
return
ContentIteratorBase
:
:
GetDeepLastChild
(
aRoot
-
>
GetLastChild
(
)
)
;
}
template
<
typename
NodeType
>
nsIContent
*
ContentIteratorBase
<
NodeType
>
:
:
GetDeepLastChild
(
nsIContent
*
aRoot
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
while
(
HTMLSlotElement
*
slot
=
HTMLSlotElement
:
:
FromNode
(
node
)
)
{
if
(
!
slot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
if
(
nsIContent
*
content
=
nsIContent
:
:
FromNode
(
slot
-
>
AssignedNodes
(
)
.
LastElement
(
)
)
)
{
node
=
content
;
continue
;
}
}
break
;
}
ShadowRoot
*
shadowRoot
=
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
node
aAllowCrossShadowBoundary
)
;
while
(
node
-
>
HasChildren
(
)
|
|
(
shadowRoot
&
&
shadowRoot
-
>
HasChildren
(
)
)
)
{
if
(
node
-
>
HasChildren
(
)
)
{
node
=
node
-
>
GetLastChild
(
)
;
}
else
{
MOZ_ASSERT
(
shadowRoot
)
;
node
=
shadowRoot
-
>
GetLastChild
(
)
;
}
shadowRoot
=
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
node
aAllowCrossShadowBoundary
)
;
}
return
node
;
}
template
<
typename
NodeType
>
nsIContent
*
ContentIteratorBase
<
NodeType
>
:
:
GetNextSibling
(
nsINode
*
aNode
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
nsTArray
<
AncestorInfo
>
*
aInclusiveAncestorsOfEndContainer
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsContent
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
{
while
(
HTMLSlotElement
*
slot
=
aNode
-
>
AsContent
(
)
-
>
GetAssignedSlot
(
)
)
{
if
(
!
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
slot
-
>
GetContainingShadowHost
(
)
aAllowCrossShadowBoundary
)
)
{
break
;
}
auto
currentIndex
=
slot
-
>
AssignedNodes
(
)
.
IndexOf
(
aNode
)
;
if
(
currentIndex
<
slot
-
>
AssignedNodes
(
)
.
Length
(
)
-
1
)
{
nsINode
*
nextSlottedNode
=
slot
-
>
AssignedNodes
(
)
.
ElementAt
(
currentIndex
+
1
)
;
if
(
nextSlottedNode
-
>
IsContent
(
)
)
{
return
nextSlottedNode
-
>
AsContent
(
)
;
}
}
aNode
=
slot
;
}
}
if
(
nsIContent
*
next
=
aNode
-
>
GetNextSibling
(
)
)
{
return
next
;
}
nsINode
*
parent
=
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
aNode
aAllowCrossShadowBoundary
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
if
(
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
&
&
aInclusiveAncestorsOfEndContainer
&
&
parent
-
>
GetShadowRoot
(
)
=
=
aNode
)
{
const
int32_t
i
=
aInclusiveAncestorsOfEndContainer
-
>
IndexOf
(
parent
0
InclusiveAncestorComparator
(
)
)
;
if
(
i
!
=
-
1
)
{
MOZ_ASSERT
(
!
aInclusiveAncestorsOfEndContainer
-
>
ElementAt
(
i
)
.
mIsDescendantInShadowTree
)
;
return
parent
-
>
AsContent
(
)
;
}
}
return
ContentIteratorBase
:
:
GetNextSibling
(
parent
aAllowCrossShadowBoundary
aInclusiveAncestorsOfEndContainer
)
;
}
template
<
typename
NodeType
>
nsIContent
*
ContentIteratorBase
<
NodeType
>
:
:
GetPrevSibling
(
nsINode
*
aNode
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsContent
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
{
while
(
HTMLSlotElement
*
slot
=
aNode
-
>
AsContent
(
)
-
>
GetAssignedSlot
(
)
)
{
if
(
!
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
slot
-
>
GetContainingShadowHost
(
)
aAllowCrossShadowBoundary
)
)
{
break
;
}
auto
currentIndex
=
slot
-
>
AssignedNodes
(
)
.
IndexOf
(
aNode
)
;
if
(
currentIndex
>
0
)
{
nsINode
*
prevSlottedNode
=
slot
-
>
AssignedNodes
(
)
.
ElementAt
(
currentIndex
-
1
)
;
if
(
prevSlottedNode
-
>
IsContent
(
)
)
{
return
prevSlottedNode
-
>
AsContent
(
)
;
}
}
aNode
=
slot
;
}
}
if
(
nsIContent
*
prev
=
aNode
-
>
GetPreviousSibling
(
)
)
{
return
prev
;
}
nsINode
*
parent
=
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
aNode
aAllowCrossShadowBoundary
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
return
ContentIteratorBase
:
:
GetPrevSibling
(
parent
aAllowCrossShadowBoundary
)
;
}
template
<
typename
NodeType
>
nsINode
*
ContentIteratorBase
<
NodeType
>
:
:
NextNode
(
nsINode
*
aNode
)
{
nsINode
*
node
=
aNode
;
if
(
mOrder
=
=
Order
:
:
Pre
)
{
if
(
node
-
>
HasChildren
(
)
)
{
nsIContent
*
firstChild
=
node
-
>
GetFirstChild
(
)
;
MOZ_ASSERT
(
firstChild
)
;
return
firstChild
;
}
return
ContentIteratorBase
:
:
GetNextSibling
(
node
)
;
}
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
MOZ_ASSERT
(
parent
"
The
node
is
the
root
node
but
not
the
last
node
"
)
;
mCurNode
=
nullptr
;
return
node
;
}
if
(
nsIContent
*
sibling
=
node
-
>
GetNextSibling
(
)
)
{
return
ContentIteratorBase
:
:
GetDeepFirstChild
(
sibling
)
;
}
return
parent
;
}
template
<
typename
NodeType
>
nsINode
*
ContentIteratorBase
<
NodeType
>
:
:
PrevNode
(
nsINode
*
aNode
)
{
nsINode
*
node
=
aNode
;
if
(
mOrder
=
=
Order
:
:
Pre
)
{
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
MOZ_ASSERT
(
parent
"
The
node
is
the
root
node
but
not
the
first
node
"
)
;
mCurNode
=
nullptr
;
return
aNode
;
}
nsIContent
*
sibling
=
node
-
>
GetPreviousSibling
(
)
;
if
(
sibling
)
{
return
ContentIteratorBase
:
:
GetDeepLastChild
(
sibling
)
;
}
return
parent
;
}
if
(
node
-
>
HasChildren
(
)
)
{
return
node
-
>
GetLastChild
(
)
;
}
return
ContentIteratorBase
:
:
GetPrevSibling
(
node
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
void
First
)
;
template
<
typename
NodeType
>
void
ContentIteratorBase
<
NodeType
>
:
:
First
(
)
{
if
(
!
mFirst
)
{
MOZ_ASSERT
(
IsDone
(
)
)
;
mCurNode
=
nullptr
;
return
;
}
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mFirst
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
void
Last
)
;
template
<
typename
NodeType
>
void
ContentIteratorBase
<
NodeType
>
:
:
Last
(
)
{
if
(
!
mLast
)
{
MOZ_ASSERT
(
IsDone
(
)
)
;
mCurNode
=
nullptr
;
return
;
}
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mLast
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
void
Next
)
;
template
<
typename
NodeType
>
void
ContentIteratorBase
<
NodeType
>
:
:
Next
(
)
{
if
(
IsDone
(
)
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mCurNode
=
nullptr
;
return
;
}
mCurNode
=
NextNode
(
mCurNode
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
void
Prev
)
;
template
<
typename
NodeType
>
void
ContentIteratorBase
<
NodeType
>
:
:
Prev
(
)
{
if
(
IsDone
(
)
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mCurNode
=
nullptr
;
return
;
}
mCurNode
=
PrevNode
(
mCurNode
)
;
}
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
(
nsresult
PositionAt
nsINode
*
)
;
template
<
typename
NodeType
>
nsresult
ContentIteratorBase
<
NodeType
>
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
if
(
NS_WARN_IF
(
!
aCurNode
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
mCurNode
=
=
aCurNode
)
{
return
NS_OK
;
}
mCurNode
=
aCurNode
;
RawRangeBoundary
first
(
mFirst
0u
)
;
RawRangeBoundary
last
(
mLast
0u
)
;
if
(
mFirst
&
&
mLast
)
{
if
(
mOrder
=
=
Order
:
:
Pre
)
{
first
=
{
mFirst
-
>
GetParentNode
(
)
mFirst
-
>
GetPreviousSibling
(
)
}
;
if
(
!
mLast
-
>
HasChildren
(
)
)
{
last
=
{
mLast
-
>
GetParentNode
(
)
mLast
-
>
AsContent
(
)
}
;
}
}
else
{
if
(
mFirst
-
>
HasChildren
(
)
)
{
first
=
{
mFirst
mFirst
-
>
GetLastChild
(
)
}
;
}
else
{
first
=
{
mFirst
-
>
GetParentNode
(
)
mFirst
-
>
GetPreviousSibling
(
)
}
;
}
last
=
{
mLast
-
>
GetParentNode
(
)
mLast
-
>
AsContent
(
)
}
;
}
}
NS_WARNING_ASSERTION
(
first
.
IsSetAndValid
(
)
"
first
is
not
valid
"
)
;
NS_WARNING_ASSERTION
(
last
.
IsSetAndValid
(
)
"
last
is
not
valid
"
)
;
if
(
mFirst
!
=
mCurNode
&
&
mLast
!
=
mCurNode
&
&
(
NS_WARN_IF
(
!
first
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
last
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mCurNode
mOrder
=
=
Order
:
:
Pre
first
last
)
)
)
)
{
mCurNode
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ContentSubtreeIterator
:
:
Init
(
nsINode
*
aRoot
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
ContentSubtreeIterator
:
:
Init
(
AbstractRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
if
(
NS_WARN_IF
(
!
aRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mRange
=
aRange
;
return
InitWithRange
(
)
;
}
nsresult
ContentSubtreeIterator
:
:
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
return
Init
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
nsresult
ContentSubtreeIterator
:
:
Init
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aStartBoundary
aEndBoundary
IgnoreErrors
(
)
)
;
if
(
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
range
-
>
MayCrossShadowBoundaryStartRef
(
)
!
=
aStartBoundary
)
|
|
NS_WARN_IF
(
range
-
>
MayCrossShadowBoundaryEndRef
(
)
!
=
aEndBoundary
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRange
=
std
:
:
move
(
range
)
;
return
InitWithRange
(
)
;
}
nsresult
ContentSubtreeIterator
:
:
InitWithAllowCrossShadowBoundary
(
AbstractRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
if
(
NS_WARN_IF
(
!
aRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mRange
=
aRange
;
if
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
)
{
mAllowCrossShadowBoundary
=
AllowRangeCrossShadowBoundary
:
:
Yes
;
}
return
InitWithRange
(
)
;
}
void
ContentSubtreeIterator
:
:
CacheInclusiveAncestorsOfEndContainer
(
)
{
mInclusiveAncestorsOfEndContainer
.
Clear
(
)
;
nsINode
*
const
endContainer
=
ShadowDOMSelectionHelpers
:
:
GetEndContainer
(
mRange
mAllowCrossShadowBoundary
)
;
nsIContent
*
endNode
=
endContainer
-
>
IsContent
(
)
?
endContainer
-
>
AsContent
(
)
:
nullptr
;
AncestorInfo
info
{
endNode
false
}
;
while
(
info
.
mAncestor
)
{
const
nsINode
*
child
=
info
.
mAncestor
;
mInclusiveAncestorsOfEndContainer
.
AppendElement
(
info
)
;
nsINode
*
parent
=
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
child
mAllowCrossShadowBoundary
)
;
if
(
!
parent
|
|
!
parent
-
>
IsContent
(
)
)
{
break
;
}
const
bool
isChildAShadowRootForSelection
=
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
parent
mAllowCrossShadowBoundary
)
=
=
child
;
info
.
mAncestor
=
parent
-
>
AsContent
(
)
;
info
.
mIsDescendantInShadowTree
=
IterAllowCrossShadowBoundary
(
)
&
&
isChildAShadowRootForSelection
;
}
}
nsIContent
*
ContentSubtreeIterator
:
:
DetermineCandidateForFirstContent
(
)
const
{
nsINode
*
startContainer
=
ShadowDOMSelectionHelpers
:
:
GetStartContainer
(
mRange
mAllowCrossShadowBoundary
)
;
nsIContent
*
firstCandidate
=
nullptr
;
nsINode
*
node
=
nullptr
;
if
(
!
startContainer
-
>
GetChildCount
(
)
)
{
node
=
startContainer
;
}
else
{
nsIContent
*
child
=
IterAllowCrossShadowBoundary
(
)
?
mRange
-
>
GetMayCrossShadowBoundaryChildAtStartOffset
(
)
:
mRange
-
>
GetChildAtStartOffset
(
)
;
#
ifdef
DEBUG
const
auto
&
startRef
=
IterAllowCrossShadowBoundary
(
)
?
mRange
-
>
MayCrossShadowBoundaryStartRef
(
)
:
mRange
-
>
StartRef
(
)
;
const
uint32_t
startOffset
=
ShadowDOMSelectionHelpers
:
:
StartOffset
(
mRange
mAllowCrossShadowBoundary
)
;
MOZ_ASSERT
(
child
=
=
(
startRef
.
GetTreeKind
(
)
=
=
TreeKind
:
:
Flat
?
startContainer
-
>
GetChildAtInFlatTree
(
startOffset
)
:
startContainer
-
>
GetChildAt_Deprecated
(
startOffset
)
)
)
;
#
endif
if
(
!
child
)
{
node
=
startContainer
;
}
else
{
firstCandidate
=
child
;
}
}
if
(
!
firstCandidate
)
{
firstCandidate
=
ContentIteratorBase
:
:
GetNextSibling
(
node
mAllowCrossShadowBoundary
)
;
}
if
(
firstCandidate
)
{
firstCandidate
=
ContentIteratorBase
:
:
GetDeepFirstChild
(
firstCandidate
mAllowCrossShadowBoundary
)
;
}
return
firstCandidate
;
}
nsIContent
*
ContentSubtreeIterator
:
:
DetermineFirstContent
(
)
const
{
nsIContent
*
firstCandidate
=
DetermineCandidateForFirstContent
(
)
;
if
(
!
firstCandidate
)
{
return
nullptr
;
}
const
Maybe
<
bool
>
isNodeContainedInRange
=
IterAllowCrossShadowBoundary
(
)
?
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
Flat
>
(
*
firstCandidate
mRange
)
:
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
ShadowIncludingDOM
>
(
*
firstCandidate
mRange
)
;
MOZ_ALWAYS_TRUE
(
isNodeContainedInRange
)
;
if
(
!
isNodeContainedInRange
.
value
(
)
)
{
return
nullptr
;
}
return
GetTopAncestorInRange
(
firstCandidate
)
;
}
nsIContent
*
ContentSubtreeIterator
:
:
DetermineCandidateForLastContent
(
)
const
{
nsIContent
*
lastCandidate
{
nullptr
}
;
nsINode
*
endContainer
=
ShadowDOMSelectionHelpers
:
:
GetEndContainer
(
mRange
mAllowCrossShadowBoundary
)
;
int32_t
offset
=
ShadowDOMSelectionHelpers
:
:
EndOffset
(
mRange
mAllowCrossShadowBoundary
)
;
int32_t
numChildren
=
endContainer
-
>
GetChildCount
(
)
;
nsINode
*
node
=
nullptr
;
if
(
offset
>
numChildren
)
{
offset
=
numChildren
;
}
if
(
!
offset
|
|
!
numChildren
)
{
node
=
endContainer
;
}
else
{
lastCandidate
=
IterAllowCrossShadowBoundary
(
)
?
mRange
-
>
MayCrossShadowBoundaryEndRef
(
)
.
Ref
(
)
:
mRange
-
>
EndRef
(
)
.
Ref
(
)
;
#
ifdef
DEBUG
const
auto
&
endRef
=
IterAllowCrossShadowBoundary
(
)
?
mRange
-
>
MayCrossShadowBoundaryEndRef
(
)
:
mRange
-
>
EndRef
(
)
;
MOZ_ASSERT
(
lastCandidate
=
=
(
endRef
.
GetTreeKind
(
)
=
=
TreeKind
:
:
Flat
?
endContainer
-
>
GetChildAtInFlatTree
(
offset
-
1
)
:
endContainer
-
>
GetChildAt_Deprecated
(
offset
-
1
)
)
)
;
#
endif
NS_ASSERTION
(
lastCandidate
"
tree
traversal
trouble
in
ContentSubtreeIterator
:
:
Init
"
)
;
}
if
(
!
lastCandidate
)
{
lastCandidate
=
ContentIteratorBase
:
:
GetPrevSibling
(
node
mAllowCrossShadowBoundary
)
;
}
if
(
lastCandidate
)
{
lastCandidate
=
ContentIteratorBase
:
:
GetDeepLastChild
(
lastCandidate
mAllowCrossShadowBoundary
)
;
}
return
lastCandidate
;
}
nsresult
ContentSubtreeIterator
:
:
InitWithRange
(
)
{
MOZ_ASSERT
(
mRange
)
;
MOZ_ASSERT
(
mRange
-
>
IsPositioned
(
)
)
;
mClosestCommonInclusiveAncestor
=
mRange
-
>
GetClosestCommonInclusiveAncestor
(
mAllowCrossShadowBoundary
)
;
nsINode
*
startContainer
=
ShadowDOMSelectionHelpers
:
:
GetStartContainer
(
mRange
mAllowCrossShadowBoundary
)
;
const
int32_t
startOffset
=
ShadowDOMSelectionHelpers
:
:
StartOffset
(
mRange
mAllowCrossShadowBoundary
)
;
nsINode
*
endContainer
=
ShadowDOMSelectionHelpers
:
:
GetEndContainer
(
mRange
mAllowCrossShadowBoundary
)
;
const
int32_t
endOffset
=
ShadowDOMSelectionHelpers
:
:
EndOffset
(
mRange
mAllowCrossShadowBoundary
)
;
MOZ_ASSERT
(
mClosestCommonInclusiveAncestor
&
&
startContainer
&
&
endContainer
)
;
MOZ_ASSERT
(
uint32_t
(
startOffset
)
<
=
startContainer
-
>
Length
(
)
&
&
uint32_t
(
endOffset
)
<
=
endContainer
-
>
Length
(
)
)
;
if
(
startContainer
=
=
endContainer
)
{
nsINode
*
child
=
startContainer
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
startOffset
=
=
endOffset
)
{
SetEmpty
(
)
;
return
NS_OK
;
}
}
CacheInclusiveAncestorsOfEndContainer
(
)
;
mFirst
=
DetermineFirstContent
(
)
;
if
(
!
mFirst
)
{
SetEmpty
(
)
;
return
NS_OK
;
}
mLast
=
DetermineLastContent
(
)
;
if
(
!
mLast
)
{
SetEmpty
(
)
;
return
NS_OK
;
}
mCurNode
=
mFirst
;
return
NS_OK
;
}
nsIContent
*
ContentSubtreeIterator
:
:
DetermineLastContent
(
)
const
{
nsIContent
*
lastCandidate
=
DetermineCandidateForLastContent
(
)
;
if
(
!
lastCandidate
)
{
return
nullptr
;
}
const
Maybe
<
bool
>
isNodeContainedInRange
=
IterAllowCrossShadowBoundary
(
)
?
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
Flat
>
(
*
lastCandidate
mRange
)
:
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
ShadowIncludingDOM
>
(
*
lastCandidate
mRange
)
;
MOZ_ALWAYS_TRUE
(
isNodeContainedInRange
)
;
if
(
!
isNodeContainedInRange
.
value
(
)
)
{
return
nullptr
;
}
return
GetTopAncestorInRange
(
lastCandidate
)
;
}
void
ContentSubtreeIterator
:
:
First
(
)
{
mCurNode
=
mFirst
;
}
void
ContentSubtreeIterator
:
:
Last
(
)
{
mCurNode
=
mLast
;
}
void
ContentSubtreeIterator
:
:
Next
(
)
{
if
(
IsDone
(
)
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mCurNode
=
nullptr
;
return
;
}
nsINode
*
nextNode
=
ContentIteratorBase
:
:
GetNextSibling
(
mCurNode
mAllowCrossShadowBoundary
&
mInclusiveAncestorsOfEndContainer
)
;
NS_ASSERTION
(
nextNode
"
No
next
sibling
!
?
!
This
could
mean
deadlock
!
"
)
;
int32_t
i
=
mInclusiveAncestorsOfEndContainer
.
IndexOf
(
nextNode
0
InclusiveAncestorComparator
(
)
)
;
while
(
i
!
=
-
1
)
{
ShadowRoot
*
root
=
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
nextNode
mAllowCrossShadowBoundary
)
;
if
(
mInclusiveAncestorsOfEndContainer
[
i
]
.
mIsDescendantInShadowTree
)
{
MOZ_ASSERT
(
root
)
;
nextNode
=
root
-
>
GetFirstChild
(
)
;
}
else
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
nextNode
)
;
slot
&
&
IterAllowCrossShadowBoundary
(
)
&
&
!
slot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
)
{
nextNode
=
slot
-
>
AssignedNodes
(
)
[
0
]
;
}
else
{
if
(
root
)
{
mCurNode
=
nullptr
;
return
;
}
nextNode
=
nextNode
-
>
GetFirstChild
(
)
;
}
NS_ASSERTION
(
nextNode
"
Iterator
error
expected
a
child
node
!
"
)
;
i
=
mInclusiveAncestorsOfEndContainer
.
IndexOf
(
nextNode
0
InclusiveAncestorComparator
(
)
)
;
}
mCurNode
=
nextNode
;
}
void
ContentSubtreeIterator
:
:
Prev
(
)
{
if
(
IsDone
(
)
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mCurNode
=
nullptr
;
return
;
}
nsINode
*
prevNode
=
ContentIteratorBase
:
:
GetDeepFirstChild
(
mCurNode
)
;
prevNode
=
PrevNode
(
prevNode
)
;
prevNode
=
ContentIteratorBase
:
:
GetDeepLastChild
(
prevNode
)
;
mCurNode
=
GetTopAncestorInRange
(
prevNode
)
;
}
nsresult
ContentSubtreeIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
NS_ERROR
(
"
Not
implemented
!
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIContent
*
ContentSubtreeIterator
:
:
GetTopAncestorInRange
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
|
|
!
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
aNode
mAllowCrossShadowBoundary
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
Maybe
<
bool
>
isNodeContainedInRange
=
IterAllowCrossShadowBoundary
(
)
?
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
Flat
>
(
*
aNode
mRange
)
:
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
ShadowIncludingDOM
>
(
*
aNode
mRange
)
;
NS_ASSERTION
(
isNodeContainedInRange
&
&
isNodeContainedInRange
.
value
(
)
"
aNode
isn
'
t
in
mRange
or
something
else
weird
happened
"
)
;
if
(
!
isNodeContainedInRange
|
|
!
isNodeContainedInRange
.
value
(
)
)
{
return
nullptr
;
}
nsIContent
*
lastContentInShadowTree
=
nullptr
;
while
(
content
)
{
nsINode
*
parent
=
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
content
mAllowCrossShadowBoundary
)
;
if
(
!
parent
|
|
!
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
parent
mAllowCrossShadowBoundary
)
)
{
return
content
;
}
isNodeContainedInRange
=
IterAllowCrossShadowBoundary
(
)
?
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
Flat
>
(
*
parent
mRange
)
:
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
ShadowIncludingDOM
>
(
*
parent
mRange
)
;
MOZ_ALWAYS_TRUE
(
isNodeContainedInRange
)
;
if
(
!
isNodeContainedInRange
.
value
(
)
)
{
if
(
IterAllowCrossShadowBoundary
(
)
&
&
content
-
>
IsShadowRoot
(
)
)
{
MOZ_ASSERT
(
parent
-
>
GetShadowRoot
(
)
=
=
content
)
;
MOZ_ASSERT
(
lastContentInShadowTree
)
;
return
lastContentInShadowTree
;
}
return
content
;
}
if
(
IterAllowCrossShadowBoundary
(
)
&
&
parent
-
>
IsShadowRoot
(
)
)
{
lastContentInShadowTree
=
content
;
}
content
=
parent
-
>
AsContent
(
)
;
}
MOZ_CRASH
(
"
This
should
only
be
possible
if
aNode
was
null
"
)
;
}
#
undef
NS_INSTANTIATE_CONTENT_ITER_BASE_METHOD
}
