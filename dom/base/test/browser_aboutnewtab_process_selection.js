const
TEST_URL
=
"
http
:
/
/
www
.
example
.
com
/
browser
/
dom
/
base
/
test
/
dummy
.
html
"
;
const
PRELOADED_STATE
=
"
preloaded
"
;
const
CONSUMED_STATE
=
"
consumed
"
;
var
ppmm
=
Services
.
ppmm
;
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
]
[
"
dom
.
ipc
.
processCount
"
10
]
[
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
10
]
]
}
)
;
}
)
;
async
function
ensurePreloaded
(
gBrowser
)
{
NewTabPagePreloading
.
maybeCreatePreloadedBrowser
(
gBrowser
.
ownerGlobal
)
;
await
ContentTask
.
spawn
(
gBrowser
.
preloadedBrowser
null
async
(
)
=
>
{
await
ContentTaskUtils
.
waitForCondition
(
(
)
=
>
{
return
content
.
document
&
&
content
.
document
.
readyState
=
=
"
complete
"
;
}
)
;
}
)
;
}
add_task
(
async
function
(
)
{
if
(
!
gMultiProcessBrowser
)
{
return
;
}
ppmm
.
releaseCachedProcesses
(
)
;
await
ensurePreloaded
(
gBrowser
)
;
const
{
childCount
:
originalChildCount
}
=
ppmm
;
BrowserOpenTab
(
)
;
let
tab1
=
gBrowser
.
selectedTab
;
await
ensurePreloaded
(
gBrowser
)
;
is
(
ppmm
.
childCount
originalChildCount
"
Preloaded
browser
should
not
create
a
new
content
process
.
"
)
;
BrowserOpenTab
(
)
;
let
tab2
=
gBrowser
.
selectedTab
;
await
ensurePreloaded
(
gBrowser
)
;
is
(
ppmm
.
childCount
originalChildCount
"
Preloaded
browser
should
(
still
)
not
create
a
new
content
process
.
"
)
;
BrowserTestUtils
.
loadURI
(
tab2
.
linkedBrowser
TEST_URL
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab2
.
linkedBrowser
false
TEST_URL
)
;
is
(
ppmm
.
childCount
originalChildCount
+
1
"
Navigating
away
from
the
preloaded
browser
(
parent
side
)
should
create
a
new
content
process
.
"
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tab1
)
;
await
ContentTask
.
spawn
(
tab1
.
linkedBrowser
null
async
function
(
)
{
const
TEST_URL
=
"
http
:
/
/
www
.
example
.
com
/
browser
/
dom
/
base
/
test
/
dummy
.
html
"
;
content
.
location
.
href
=
TEST_URL
;
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab1
.
linkedBrowser
false
TEST_URL
)
;
is
(
ppmm
.
childCount
originalChildCount
+
2
"
Navigating
away
from
the
preloaded
browser
(
child
side
)
should
create
a
new
content
process
.
"
)
;
BrowserTestUtils
.
removeTab
(
tab1
)
;
BrowserTestUtils
.
removeTab
(
tab2
)
;
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
ppmm
.
releaseCachedProcesses
(
)
;
}
)
;
add_task
(
async
function
preloaded_state_attribute
(
)
{
await
ensurePreloaded
(
gBrowser
)
;
let
preloadedTabState
=
gBrowser
.
preloadedBrowser
.
getAttribute
(
"
preloadedState
"
)
;
is
(
preloadedTabState
PRELOADED_STATE
"
Sanity
check
that
the
first
preloaded
browser
has
the
correct
attribute
"
)
;
BrowserOpenTab
(
)
;
await
ensurePreloaded
(
gBrowser
)
;
let
consumedTabState
=
gBrowser
.
selectedBrowser
.
getAttribute
(
"
preloadedState
"
)
;
is
(
consumedTabState
CONSUMED_STATE
"
The
opened
tab
consumed
the
preloaded
browser
and
updated
the
attribute
"
)
;
preloadedTabState
=
gBrowser
.
preloadedBrowser
.
getAttribute
(
"
preloadedState
"
)
;
is
(
preloadedTabState
PRELOADED_STATE
"
The
preloaded
browser
has
the
correct
attribute
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
TEST_URL
)
;
let
navigatedTabHasState
=
gBrowser
.
selectedBrowser
.
hasAttribute
(
"
preloadedState
"
)
;
ok
(
!
navigatedTabHasState
"
Correctly
removed
the
preloadState
attribute
when
navigating
away
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
}
)
;
