const
TEST_URL
=
"
http
:
/
/
www
.
example
.
com
/
browser
/
dom
/
base
/
test
/
dummy
.
html
"
;
const
TEST_URL_2
=
"
http
:
/
/
example
.
org
/
browser
/
dom
/
base
/
test
/
dummy
.
html
"
;
const
PRELOADED_STATE
=
"
preloaded
"
;
const
CONSUMED_STATE
=
"
consumed
"
;
var
ppmm
=
Services
.
ppmm
;
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
]
[
"
dom
.
ipc
.
processCount
"
10
]
[
"
dom
.
ipc
.
keepProcessesAlive
.
web
"
10
]
]
}
)
;
}
)
;
add_task
(
async
function
(
)
{
if
(
!
gMultiProcessBrowser
)
{
return
;
}
ppmm
.
releaseCachedProcesses
(
)
;
await
BrowserTestUtils
.
maybeCreatePreloadedBrowser
(
gBrowser
)
;
let
expectedChildCount
=
ppmm
.
childCount
;
let
tabs
=
[
]
;
for
(
let
i
=
0
;
i
<
3
;
i
+
+
)
{
BrowserOpenTab
(
)
;
tabs
.
unshift
(
gBrowser
.
selectedTab
)
;
await
BrowserTestUtils
.
maybeCreatePreloadedBrowser
(
gBrowser
)
;
is
(
ppmm
.
childCount
expectedChildCount
"
Preloaded
browser
should
not
create
a
new
content
process
.
"
)
;
}
expectedChildCount
+
=
1
;
BrowserTestUtils
.
loadURI
(
tabs
[
0
]
.
linkedBrowser
TEST_URL
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabs
[
0
]
.
linkedBrowser
false
TEST_URL
)
;
is
(
ppmm
.
childCount
expectedChildCount
"
Navigating
away
from
the
preloaded
browser
(
parent
side
)
should
create
a
new
content
process
.
"
)
;
expectedChildCount
+
=
gFissionBrowser
?
0
:
1
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabs
[
1
]
)
;
await
SpecialPowers
.
spawn
(
tabs
[
1
]
.
linkedBrowser
[
TEST_URL
]
url
=
>
{
content
.
location
.
href
=
url
;
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabs
[
1
]
.
linkedBrowser
false
TEST_URL
)
;
is
(
ppmm
.
childCount
expectedChildCount
Navigating
away
from
the
preloaded
browser
(
child
side
same
-
origin
)
should
{
gFissionBrowser
?
"
not
"
:
"
"
}
create
a
new
content
process
.
)
;
expectedChildCount
+
=
1
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
tabs
[
2
]
)
;
await
ContentTask
.
spawn
(
tabs
[
2
]
.
linkedBrowser
TEST_URL_2
url
=
>
{
content
.
location
.
href
=
url
;
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
tabs
[
2
]
.
linkedBrowser
false
TEST_URL_2
)
;
is
(
ppmm
.
childCount
expectedChildCount
"
Navigating
away
from
the
preloaded
browser
(
child
side
cross
-
origin
)
should
create
a
new
content
process
.
"
)
;
for
(
let
tab
of
tabs
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
}
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
ppmm
.
releaseCachedProcesses
(
)
;
}
)
;
add_task
(
async
function
preloaded_state_attribute
(
)
{
await
BrowserTestUtils
.
maybeCreatePreloadedBrowser
(
gBrowser
)
;
let
preloadedTabState
=
gBrowser
.
preloadedBrowser
.
getAttribute
(
"
preloadedState
"
)
;
is
(
preloadedTabState
PRELOADED_STATE
"
Sanity
check
that
the
first
preloaded
browser
has
the
correct
attribute
"
)
;
BrowserOpenTab
(
)
;
await
BrowserTestUtils
.
maybeCreatePreloadedBrowser
(
gBrowser
)
;
let
consumedTabState
=
gBrowser
.
selectedBrowser
.
getAttribute
(
"
preloadedState
"
)
;
is
(
consumedTabState
CONSUMED_STATE
"
The
opened
tab
consumed
the
preloaded
browser
and
updated
the
attribute
"
)
;
preloadedTabState
=
gBrowser
.
preloadedBrowser
.
getAttribute
(
"
preloadedState
"
)
;
is
(
preloadedTabState
PRELOADED_STATE
"
The
preloaded
browser
has
the
correct
attribute
"
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
TEST_URL
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
false
TEST_URL
)
;
let
navigatedTabHasState
=
gBrowser
.
selectedBrowser
.
hasAttribute
(
"
preloadedState
"
)
;
ok
(
!
navigatedTabHasState
"
Correctly
removed
the
preloadState
attribute
when
navigating
away
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
NewTabPagePreloading
.
removePreloadedBrowser
(
window
)
;
}
)
;
