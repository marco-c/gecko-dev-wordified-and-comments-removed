const
UNORDERED_TYPE
=
8
;
function
isWhitespace
(
aNode
)
{
return
/
\
S
/
.
test
(
aNode
.
nodeValue
)
?
NodeFilter
.
FILTER_SKIP
:
NodeFilter
.
FILTER_ACCEPT
;
}
function
getFragment
(
aNode
)
{
var
frag
=
aNode
.
ownerDocument
.
createDocumentFragment
(
)
;
for
(
var
i
=
0
;
i
<
aNode
.
childNodes
.
length
;
i
+
+
)
{
frag
.
appendChild
(
aNode
.
childNodes
.
item
(
i
)
.
cloneNode
(
true
)
)
;
}
return
frag
;
}
const
parser
=
getParser
(
)
;
function
evalXPathInDocumentFragment
(
aContextNode
aPath
)
{
Assert
.
equal
(
ChromeUtils
.
getClassName
(
aContextNode
)
"
DocumentFragment
"
)
;
Assert
.
ok
(
aContextNode
.
childNodes
.
length
>
0
)
;
if
(
aPath
=
=
"
.
"
)
{
return
aContextNode
;
}
var
firstSlash
=
aPath
.
indexOf
(
"
/
"
)
;
if
(
firstSlash
=
=
-
1
)
{
firstSlash
=
aPath
.
length
;
}
var
prefix
=
aPath
.
substr
(
0
firstSlash
)
;
var
realPath
=
aPath
.
substr
(
firstSlash
+
1
)
;
if
(
!
realPath
)
{
realPath
=
"
.
"
;
}
var
childIndex
=
1
;
var
bracketIndex
=
prefix
.
indexOf
(
"
[
"
)
;
if
(
bracketIndex
!
=
-
1
)
{
childIndex
=
Number
(
prefix
.
substring
(
bracketIndex
+
1
prefix
.
indexOf
(
"
]
"
)
)
)
;
Assert
.
ok
(
childIndex
>
0
)
;
prefix
=
prefix
.
substr
(
0
bracketIndex
)
;
}
var
targetType
=
NodeFilter
.
SHOW_ELEMENT
;
var
targetNodeName
=
prefix
;
if
(
prefix
.
indexOf
(
"
processing
-
instruction
(
"
)
=
=
0
)
{
targetType
=
NodeFilter
.
SHOW_PROCESSING_INSTRUCTION
;
targetNodeName
=
prefix
.
substring
(
prefix
.
indexOf
(
"
(
"
)
+
2
prefix
.
indexOf
(
"
)
"
)
-
1
)
;
}
switch
(
prefix
)
{
case
"
text
(
)
"
:
targetType
=
NodeFilter
.
SHOW_TEXT
|
NodeFilter
.
SHOW_CDATA_SECTION
;
targetNodeName
=
null
;
break
;
case
"
comment
(
)
"
:
targetType
=
NodeFilter
.
SHOW_COMMENT
;
targetNodeName
=
null
;
break
;
case
"
node
(
)
"
:
targetType
=
NodeFilter
.
SHOW_ALL
;
targetNodeName
=
null
;
}
var
filter
=
{
count
:
0
acceptNode
:
function
acceptNode
(
aNode
)
{
if
(
aNode
.
parentNode
!
=
aContextNode
)
{
return
NodeFilter
.
FILTER_REJECT
;
}
if
(
targetNodeName
&
&
targetNodeName
!
=
aNode
.
nodeName
)
{
return
NodeFilter
.
FILTER_SKIP
;
}
this
.
count
+
+
;
if
(
this
.
count
!
=
childIndex
)
{
return
NodeFilter
.
FILTER_SKIP
;
}
return
NodeFilter
.
FILTER_ACCEPT
;
}
}
;
var
walker
=
aContextNode
.
ownerDocument
.
createTreeWalker
(
aContextNode
targetType
filter
)
;
var
targetNode
=
walker
.
nextNode
(
)
;
Assert
.
notEqual
(
targetNode
null
)
;
var
expr
=
aContextNode
.
ownerDocument
.
createExpression
(
realPath
null
)
;
var
result
=
expr
.
evaluate
(
targetNode
UNORDERED_TYPE
null
)
;
return
result
.
singleNodeValue
;
}
function
getRange
(
aSourceNode
aFragment
)
{
Assert
.
ok
(
Element
.
isInstance
(
aSourceNode
)
)
;
Assert
.
equal
(
ChromeUtils
.
getClassName
(
aFragment
)
"
DocumentFragment
"
)
;
var
doc
=
aSourceNode
.
ownerDocument
;
var
containerPath
=
aSourceNode
.
getAttribute
(
"
startContainer
"
)
;
var
startContainer
=
evalXPathInDocumentFragment
(
aFragment
containerPath
)
;
var
startOffset
=
Number
(
aSourceNode
.
getAttribute
(
"
startOffset
"
)
)
;
containerPath
=
aSourceNode
.
getAttribute
(
"
endContainer
"
)
;
var
endContainer
=
evalXPathInDocumentFragment
(
aFragment
containerPath
)
;
var
endOffset
=
Number
(
aSourceNode
.
getAttribute
(
"
endOffset
"
)
)
;
var
range
=
doc
.
createRange
(
)
;
range
.
setStart
(
startContainer
startOffset
)
;
range
.
setEnd
(
endContainer
endOffset
)
;
return
range
;
}
function
getParsedDocument
(
aPath
)
{
return
do_parse_document
(
aPath
"
application
/
xml
"
)
.
then
(
processParsedDocument
)
;
}
function
processParsedDocument
(
doc
)
{
Assert
.
ok
(
doc
.
documentElement
.
localName
!
=
"
parsererror
"
)
;
Assert
.
equal
(
ChromeUtils
.
getClassName
(
doc
)
"
XMLDocument
"
)
;
var
walker
=
doc
.
createTreeWalker
(
doc
NodeFilter
.
SHOW_TEXT
|
NodeFilter
.
SHOW_CDATA_SECTION
isWhitespace
)
;
while
(
walker
.
nextNode
(
)
)
{
var
parent
=
walker
.
currentNode
.
parentNode
;
parent
.
removeChild
(
walker
.
currentNode
)
;
walker
.
currentNode
=
parent
;
}
var
splits
=
doc
.
getElementsByTagName
(
"
split
"
)
;
var
i
;
for
(
i
=
splits
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
node
=
splits
.
item
(
i
)
;
node
.
remove
(
)
;
}
splits
=
null
;
var
emptyData
=
doc
.
getElementsByTagName
(
"
empty
-
cdata
"
)
;
for
(
i
=
emptyData
.
length
-
1
;
i
>
=
0
;
i
-
-
)
{
let
node
=
emptyData
.
item
(
i
)
;
var
cdata
=
doc
.
createCDATASection
(
"
"
)
;
node
.
parentNode
.
replaceChild
(
cdata
node
)
;
}
return
doc
;
}
function
run_extract_test
(
)
{
var
filePath
=
"
test_delete_range
.
xml
"
;
getParsedDocument
(
filePath
)
.
then
(
do_extract_test
)
;
}
function
do_extract_test
(
doc
)
{
var
tests
=
doc
.
getElementsByTagName
(
"
test
"
)
;
for
(
var
i
=
0
;
i
<
tests
.
length
;
i
+
+
)
{
dump
(
"
Configuring
for
test
"
+
i
+
"
\
n
"
)
;
var
currentTest
=
tests
.
item
(
i
)
;
var
baseSource
=
currentTest
.
firstChild
;
Assert
.
equal
(
baseSource
.
nodeName
"
source
"
)
;
var
baseResult
=
baseSource
.
nextSibling
;
Assert
.
equal
(
baseResult
.
nodeName
"
result
"
)
;
var
baseExtract
=
baseResult
.
nextSibling
;
Assert
.
equal
(
baseExtract
.
nodeName
"
extract
"
)
;
Assert
.
equal
(
baseExtract
.
nextSibling
null
)
;
var
resultFrag
=
getFragment
(
baseResult
)
;
var
extractFrag
=
getFragment
(
baseExtract
)
;
dump
(
"
Extract
contents
test
"
+
i
+
"
\
n
\
n
"
)
;
var
baseFrag
=
getFragment
(
baseSource
)
;
var
baseRange
=
getRange
(
baseSource
baseFrag
)
;
var
startContainer
=
baseRange
.
startContainer
;
var
endContainer
=
baseRange
.
endContainer
;
var
cutFragment
=
baseRange
.
extractContents
(
)
;
dump
(
"
cutFragment
:
"
+
cutFragment
+
"
\
n
"
)
;
if
(
cutFragment
)
{
Assert
.
ok
(
extractFrag
.
isEqualNode
(
cutFragment
)
)
;
}
else
{
Assert
.
equal
(
extractFrag
.
firstChild
null
)
;
}
Assert
.
ok
(
baseFrag
.
isEqualNode
(
resultFrag
)
)
;
dump
(
"
Ensure
the
original
nodes
weren
'
t
extracted
-
test
"
+
i
+
"
\
n
\
n
"
)
;
var
walker
=
doc
.
createTreeWalker
(
baseFrag
NodeFilter
.
SHOW_ALL
null
)
;
var
foundStart
=
false
;
var
foundEnd
=
false
;
do
{
if
(
walker
.
currentNode
=
=
startContainer
)
{
foundStart
=
true
;
}
if
(
walker
.
currentNode
=
=
endContainer
)
{
Assert
.
ok
(
foundStart
)
;
foundEnd
=
true
;
break
;
}
}
while
(
walker
.
nextNode
(
)
)
;
Assert
.
ok
(
foundEnd
)
;
dump
(
"
Delete
contents
test
"
+
i
+
"
\
n
\
n
"
)
;
baseFrag
=
getFragment
(
baseSource
)
;
baseRange
=
getRange
(
baseSource
baseFrag
)
;
startContainer
=
baseRange
.
startContainer
;
endContainer
=
baseRange
.
endContainer
;
baseRange
.
deleteContents
(
)
;
Assert
.
ok
(
baseFrag
.
isEqualNode
(
resultFrag
)
)
;
dump
(
"
Ensure
the
original
nodes
weren
'
t
deleted
-
test
"
+
i
+
"
\
n
\
n
"
)
;
walker
=
doc
.
createTreeWalker
(
baseFrag
NodeFilter
.
SHOW_ALL
null
)
;
foundStart
=
false
;
foundEnd
=
false
;
do
{
if
(
walker
.
currentNode
=
=
startContainer
)
{
foundStart
=
true
;
}
if
(
walker
.
currentNode
=
=
endContainer
)
{
Assert
.
ok
(
foundStart
)
;
foundEnd
=
true
;
break
;
}
}
while
(
walker
.
nextNode
(
)
)
;
Assert
.
ok
(
foundEnd
)
;
walker
=
null
;
}
}
function
run_miscellaneous_tests
(
)
{
var
filePath
=
"
test_delete_range
.
xml
"
;
getParsedDocument
(
filePath
)
.
then
(
do_miscellaneous_tests
)
;
}
function
isText
(
node
)
{
return
(
node
.
nodeType
=
=
node
.
TEXT_NODE
|
|
node
.
nodeType
=
=
node
.
CDATA_SECTION_NODE
)
;
}
function
do_miscellaneous_tests
(
doc
)
{
var
tests
=
doc
.
getElementsByTagName
(
"
test
"
)
;
var
currentTest
=
tests
.
item
(
0
)
;
var
baseSource
=
currentTest
.
firstChild
;
var
baseFrag
=
getFragment
(
baseSource
)
;
var
baseRange
=
getRange
(
baseSource
baseFrag
)
;
var
startContainer
=
baseRange
.
startContainer
;
var
endContainer
=
baseRange
.
endContainer
;
var
startOffset
=
baseRange
.
startOffset
;
var
endOffset
=
baseRange
.
endOffset
;
if
(
endOffset
>
startOffset
&
&
startContainer
=
=
endContainer
&
&
isText
(
startContainer
)
)
{
try
{
baseRange
.
setStart
(
null
0
)
;
do_throw
(
"
Should
have
thrown
NOT_OBJECT_ERR
!
"
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
constructor
.
name
"
TypeError
"
)
;
}
try
{
baseRange
.
setStart
(
{
}
0
)
;
do_throw
(
"
Should
have
thrown
SecurityError
!
"
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
constructor
.
name
"
TypeError
"
)
;
}
try
{
baseRange
.
setStart
(
startContainer
-
1
)
;
do_throw
(
"
Should
have
thrown
IndexSizeError
!
"
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
name
"
IndexSizeError
"
)
;
}
var
newOffset
=
isText
(
startContainer
)
?
startContainer
.
nodeValue
.
length
+
1
:
startContainer
.
childNodes
.
length
+
1
;
try
{
baseRange
.
setStart
(
startContainer
newOffset
)
;
do_throw
(
"
Should
have
thrown
IndexSizeError
!
"
)
;
}
catch
(
e
)
{
Assert
.
equal
(
e
.
name
"
IndexSizeError
"
)
;
}
newOffset
-
-
;
baseRange
.
setStart
(
startContainer
newOffset
)
;
Assert
.
equal
(
baseRange
.
startContainer
baseRange
.
endContainer
)
;
Assert
.
equal
(
baseRange
.
startOffset
newOffset
)
;
Assert
.
ok
(
baseRange
.
collapsed
)
;
baseRange
.
setEnd
(
startContainer
0
)
;
Assert
.
equal
(
baseRange
.
startContainer
baseRange
.
endContainer
)
;
Assert
.
equal
(
baseRange
.
startOffset
0
)
;
Assert
.
ok
(
baseRange
.
collapsed
)
;
}
else
{
do_throw
(
"
The
first
test
should
be
a
text
-
only
range
test
.
Test
is
invalid
.
"
)
;
}
baseRange
=
getRange
(
baseSource
baseFrag
)
;
startContainer
=
baseRange
.
startContainer
;
startOffset
=
baseRange
.
startOffset
;
endContainer
=
baseRange
.
endContainer
;
endOffset
=
baseRange
.
endOffset
;
dump
(
"
External
fragment
test
\
n
\
n
"
)
;
var
externalTest
=
tests
.
item
(
1
)
;
var
externalSource
=
externalTest
.
firstChild
;
var
externalFrag
=
getFragment
(
externalSource
)
;
var
externalRange
=
getRange
(
externalSource
externalFrag
)
;
baseRange
.
setEnd
(
externalRange
.
endContainer
0
)
;
Assert
.
equal
(
baseRange
.
startContainer
externalRange
.
endContainer
)
;
Assert
.
equal
(
baseRange
.
startOffset
0
)
;
Assert
.
ok
(
baseRange
.
collapsed
)
;
doc
=
parser
.
parseFromString
(
"
<
!
-
-
foo
-
-
>
<
foo
/
>
"
"
application
/
xml
"
)
;
Assert
.
equal
(
ChromeUtils
.
getClassName
(
doc
)
"
XMLDocument
"
)
;
Assert
.
equal
(
doc
.
childNodes
.
length
2
)
;
baseRange
=
doc
.
createRange
(
)
;
baseRange
.
setStart
(
doc
.
firstChild
1
)
;
baseRange
.
setEnd
(
doc
.
firstChild
2
)
;
var
frag
=
baseRange
.
extractContents
(
)
;
Assert
.
equal
(
frag
.
childNodes
.
length
1
)
;
Assert
.
ok
(
ChromeUtils
.
getClassName
(
frag
.
firstChild
)
=
=
"
Comment
"
)
;
Assert
.
equal
(
frag
.
firstChild
.
nodeType
frag
.
COMMENT_NODE
)
;
Assert
.
equal
(
frag
.
firstChild
.
nodeValue
"
f
"
)
;
}
function
run_test
(
)
{
run_extract_test
(
)
;
run_miscellaneous_tests
(
)
;
}
