const
TEST_URI
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
+
"
file_blocking_image
.
html
"
;
add_task
(
async
function
load_image_from_https_test
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
gBrowser
.
selectedTab
=
tab
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
function
imgListener
(
img
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
img
.
addEventListener
(
"
load
"
(
)
=
>
resolve
(
)
)
;
img
.
addEventListener
(
"
error
"
(
)
=
>
reject
(
)
)
;
}
)
;
}
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
"
https
:
/
/
example
.
com
/
tests
/
image
/
test
/
mochitest
/
shaver
.
png
"
;
content
.
document
.
body
.
appendChild
(
img
)
;
try
{
await
imgListener
(
img
)
;
Assert
.
ok
(
true
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
)
;
}
Assert
.
equal
(
img
.
imageBlockingStatus
Ci
.
nsIContentPolicy
.
ACCEPT
)
;
}
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
load_image_from_http_test
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
gBrowser
.
selectedTab
=
tab
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
function
imgListener
(
img
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
img
.
addEventListener
(
"
load
"
(
)
=
>
reject
(
)
)
;
img
.
addEventListener
(
"
error
"
(
)
=
>
resolve
(
)
)
;
}
)
;
}
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
"
http
:
/
/
example
.
com
/
tests
/
image
/
test
/
mochitest
/
shaver
.
png
"
;
content
.
document
.
body
.
appendChild
(
img
)
;
try
{
await
imgListener
(
img
)
;
Assert
.
ok
(
true
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
)
;
}
Assert
.
equal
(
img
.
imageBlockingStatus
Ci
.
nsIContentPolicy
.
REJECT_SERVER
"
images
from
http
should
be
blocked
"
)
;
}
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
load_https_and_http_test
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
let
imgTools
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
;
let
imageCache
=
imgTools
.
getImgCacheForDocument
(
window
.
document
)
;
imageCache
.
clearCache
(
false
)
;
gBrowser
.
selectedTab
=
tab
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
function
imgListener
(
img
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
img
.
addEventListener
(
"
load
"
(
)
=
>
reject
(
)
)
;
img
.
addEventListener
(
"
error
"
(
)
=
>
resolve
(
)
)
;
}
)
;
}
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
"
https
:
/
/
example
.
com
/
tests
/
image
/
test
/
mochitest
/
shaver
.
png
"
;
img
.
src
=
"
http
:
/
/
example
.
com
/
tests
/
image
/
test
/
mochitest
/
shaver
.
png
"
;
content
.
document
.
body
.
appendChild
(
img
)
;
try
{
await
imgListener
(
img
)
;
Assert
.
ok
(
true
)
;
}
catch
(
e
)
{
Assert
.
ok
(
false
)
;
}
Assert
.
equal
(
img
.
imageBlockingStatus
Ci
.
nsIContentPolicy
.
REJECT_SERVER
"
image
.
src
changed
to
http
should
be
blocked
"
)
;
}
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
function
block_pending_request_test
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
TEST_URI
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
gBrowser
.
selectedTab
=
tab
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
let
wrapper
=
{
_resolve
:
null
_sizeAvail
:
false
sizeAvailable
(
request
)
{
if
(
this
.
_resolve
)
{
this
.
_resolve
(
)
;
}
else
{
this
.
_sizeAvail
=
true
;
}
}
waitUntilSizeAvailable
(
)
{
return
new
Promise
(
resolve
=
>
{
this
.
_resolve
=
resolve
;
if
(
this
.
_sizeAvail
)
{
resolve
(
)
;
}
}
)
;
}
QueryInterface
(
aIID
)
{
if
(
aIID
.
equals
(
Ci
.
imgIScriptedNotificationObserver
)
)
{
return
this
;
}
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
}
;
let
observer
=
Cc
[
"
mozilla
.
org
/
image
/
tools
;
1
"
]
.
getService
(
Ci
.
imgITools
)
.
createScriptedObserver
(
wrapper
)
;
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
"
https
:
/
/
example
.
com
/
tests
/
image
/
test
/
mochitest
/
shaver
.
png
"
;
let
req
=
img
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
;
img
.
addObserver
(
observer
)
;
content
.
document
.
body
.
appendChild
(
img
)
;
info
(
"
Wait
until
Size
Available
"
)
;
await
wrapper
.
waitUntilSizeAvailable
(
)
;
info
(
"
Size
Available
now
!
"
)
;
img
.
removeObserver
(
observer
)
;
img
.
src
=
"
http
:
/
/
example
.
com
/
tests
/
image
/
test
/
mochitest
/
shaver
.
png
"
;
Assert
.
equal
(
img
.
getRequest
(
Ci
.
nsIImageLoadingContent
.
CURRENT_REQUEST
)
req
"
CURRENT_REQUEST
shouldn
'
t
be
replaced
.
"
)
;
Assert
.
equal
(
img
.
imageBlockingStatus
Ci
.
nsIContentPolicy
.
ACCEPT
)
;
}
)
;
gBrowser
.
removeTab
(
tab
)
;
}
)
;
