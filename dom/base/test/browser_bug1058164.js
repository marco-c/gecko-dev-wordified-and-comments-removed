"
use
strict
"
;
const
PAGE
=
"
data
:
text
/
html
<
html
>
<
body
>
A
%
20regular
%
20everyday
%
20normal
%
20page
.
"
;
function
prepareForVisibilityEvents
(
browser
expectedOrder
)
{
return
new
Promise
(
(
resolve
)
=
>
{
let
order
=
[
]
;
let
checkSatisfied
=
(
)
=
>
{
if
(
order
.
length
<
expectedOrder
.
length
)
{
return
;
}
else
{
browser
.
removeEventListener
(
"
pagehide
"
eventListener
)
;
browser
.
removeEventListener
(
"
pageshow
"
eventListener
)
;
for
(
let
i
=
0
;
i
<
expectedOrder
.
length
;
+
+
i
)
{
is
(
order
[
i
]
expectedOrder
[
i
]
"
Got
expected
event
"
)
;
}
resolve
(
)
;
}
}
;
let
eventListener
=
(
e
)
=
>
{
if
(
e
.
persisted
)
{
order
.
push
(
e
.
type
)
;
checkSatisfied
(
)
;
}
}
;
browser
.
addEventListener
(
"
pagehide
"
eventListener
)
;
browser
.
addEventListener
(
"
pageshow
"
eventListener
)
;
}
)
;
}
add_task
(
async
function
test_swap_frameloader_pagevisibility_events
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
PAGE
)
;
gBrowser
.
selectedTab
=
tab
;
let
firstBrowser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
firstBrowser
)
;
let
newWindow
=
gBrowser
.
replaceTabWithWindow
(
tab
)
;
await
BrowserTestUtils
.
waitForEvent
(
newWindow
"
load
"
)
;
let
newWindowBrowser
=
newWindow
.
gBrowser
.
selectedBrowser
;
await
prepareForVisibilityEvents
(
newWindowBrowser
[
"
pagehide
"
"
pageshow
"
]
)
;
let
newTab
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
gBrowser
.
selectedTab
=
newTab
;
let
emptyBrowser
=
newTab
.
linkedBrowser
;
await
ContentTask
.
spawn
(
emptyBrowser
{
}
async
(
)
=
>
{
if
(
content
.
document
.
visibilityState
=
=
=
"
hidden
"
)
{
info
(
"
waiting
for
hidden
emptyBrowser
to
pageshow
"
)
;
await
ContentTaskUtils
.
waitForEvent
(
content
"
pageshow
"
)
;
}
}
)
;
let
emptyBrowserPromise
=
prepareForVisibilityEvents
(
emptyBrowser
[
"
pagehide
"
"
pageshow
"
]
)
;
gBrowser
.
swapBrowsersAndCloseOther
(
newTab
newWindow
.
gBrowser
.
selectedTab
)
;
await
emptyBrowserPromise
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
