"
use
strict
"
;
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
security
.
allow_eval_with_system_principal
"
true
]
]
}
)
;
const
PAGE
=
"
data
:
text
/
html
<
html
>
<
body
>
A
%
20regular
%
20everyday
%
20normal
%
20page
.
"
;
let
gListenerId
=
0
;
function
addContentEventListenerWithMessageManager
(
browser
eventName
listener
listenerOptions
=
{
}
checkFn
autoremove
=
true
)
{
let
id
=
gListenerId
+
+
;
let
checkFnSource
=
checkFn
?
encodeURIComponent
(
escape
(
checkFn
.
toSource
(
)
)
)
:
"
"
;
function
frameScript
(
id
eventName
listenerOptions
checkFnSource
)
{
let
checkFn
;
if
(
checkFnSource
)
{
checkFn
=
eval
(
(
(
)
=
>
(
{
unescape
(
checkFnSource
)
}
)
)
(
)
)
;
}
function
listener
(
event
)
{
if
(
checkFn
&
&
!
checkFn
(
event
)
)
{
return
;
}
sendAsyncMessage
(
"
ContentEventListener
:
Run
"
id
)
;
}
function
removeListener
(
msg
)
{
if
(
msg
.
data
=
=
id
)
{
removeMessageListener
(
"
ContentEventListener
:
Remove
"
removeListener
)
;
removeEventListener
(
eventName
listener
listenerOptions
)
;
}
}
addMessageListener
(
"
ContentEventListener
:
Remove
"
removeListener
)
;
addEventListener
(
eventName
listener
listenerOptions
)
;
}
let
frameScriptSource
=
data
:
(
{
frameScript
.
toString
(
)
}
)
(
{
id
}
"
{
eventName
}
"
{
uneval
(
listenerOptions
)
}
"
{
checkFnSource
}
"
)
;
let
mm
=
Services
.
mm
;
function
runListener
(
msg
)
{
if
(
msg
.
data
=
=
id
&
&
msg
.
target
=
=
browser
)
{
listener
(
)
;
}
}
mm
.
addMessageListener
(
"
ContentEventListener
:
Run
"
runListener
)
;
let
needCleanup
=
true
;
let
unregisterFunction
=
function
(
)
{
if
(
!
needCleanup
)
{
return
;
}
needCleanup
=
false
;
mm
.
removeMessageListener
(
"
ContentEventListener
:
Run
"
runListener
)
;
mm
.
broadcastAsyncMessage
(
"
ContentEventListener
:
Remove
"
id
)
;
mm
.
removeDelayedFrameScript
(
frameScriptSource
)
;
if
(
autoremove
)
{
Services
.
obs
.
removeObserver
(
cleanupObserver
"
message
-
manager
-
close
"
)
;
}
}
;
function
cleanupObserver
(
subject
topic
data
)
{
if
(
subject
=
=
browser
.
messageManager
)
{
unregisterFunction
(
)
;
}
}
if
(
autoremove
)
{
Services
.
obs
.
addObserver
(
cleanupObserver
"
message
-
manager
-
close
"
)
;
}
mm
.
loadFrameScript
(
frameScriptSource
true
)
;
return
unregisterFunction
;
}
function
prepareForVisibilityEvents
(
browser
expectedOrder
)
{
return
new
Promise
(
resolve
=
>
{
let
order
=
[
]
;
let
rmvHide
rmvShow
;
let
checkSatisfied
=
(
)
=
>
{
if
(
order
.
length
<
expectedOrder
.
length
)
{
return
;
}
else
{
rmvHide
(
)
;
rmvShow
(
)
;
for
(
let
i
=
0
;
i
<
expectedOrder
.
length
;
+
+
i
)
{
is
(
order
[
i
]
expectedOrder
[
i
]
"
Got
expected
event
"
)
;
}
resolve
(
)
;
}
}
;
let
eventListener
=
type
=
>
{
order
.
push
(
type
)
;
checkSatisfied
(
)
;
}
;
let
checkFn
=
e
=
>
e
.
persisted
;
rmvHide
=
addContentEventListenerWithMessageManager
(
browser
"
pagehide
"
(
)
=
>
eventListener
(
"
pagehide
"
)
{
}
checkFn
false
)
;
rmvShow
=
addContentEventListenerWithMessageManager
(
browser
"
pageshow
"
(
)
=
>
eventListener
(
"
pageshow
"
)
{
}
checkFn
false
)
;
}
)
;
}
add_task
(
async
function
test_swap_frameloader_pagevisibility_events
(
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
PAGE
)
;
gBrowser
.
selectedTab
=
tab
;
let
firstBrowser
=
tab
.
linkedBrowser
;
await
BrowserTestUtils
.
browserLoaded
(
firstBrowser
)
;
let
newWindow
=
gBrowser
.
replaceTabWithWindow
(
tab
)
;
await
BrowserTestUtils
.
waitForEvent
(
newWindow
"
DOMContentLoaded
"
)
;
let
newWindowBrowser
=
newWindow
.
gBrowser
.
selectedBrowser
;
await
prepareForVisibilityEvents
(
newWindowBrowser
[
"
pagehide
"
"
pageshow
"
]
)
;
let
newTab
=
BrowserTestUtils
.
addTab
(
gBrowser
)
;
gBrowser
.
selectedTab
=
newTab
;
let
emptyBrowser
=
newTab
.
linkedBrowser
;
await
ContentTask
.
spawn
(
emptyBrowser
{
}
async
(
)
=
>
{
if
(
content
.
document
.
visibilityState
=
=
=
"
hidden
"
)
{
info
(
"
waiting
for
hidden
emptyBrowser
to
pageshow
"
)
;
await
ContentTaskUtils
.
waitForEvent
(
content
"
pageshow
"
{
}
)
;
}
}
)
;
let
emptyBrowserPromise
=
prepareForVisibilityEvents
(
emptyBrowser
[
"
pagehide
"
"
pageshow
"
]
)
;
gBrowser
.
swapBrowsersAndCloseOther
(
newTab
newWindow
.
gBrowser
.
selectedTab
)
;
await
emptyBrowserPromise
;
gBrowser
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
)
;
