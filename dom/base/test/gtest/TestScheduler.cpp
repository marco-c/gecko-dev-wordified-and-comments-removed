#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
CCGCScheduler
.
h
"
using
namespace
mozilla
;
MOZ_RUNINIT
static
TimeDuration
kOneSecond
=
TimeDuration
:
:
FromSeconds
(
1
)
;
MOZ_RUNINIT
static
TimeDuration
kTenthSecond
=
TimeDuration
:
:
FromSeconds
(
0
.
1
)
;
MOZ_RUNINIT
static
TimeDuration
kFrameDuration
=
TimeDuration
:
:
FromSeconds
(
1
.
0
/
60
.
0
)
;
MOZ_RUNINIT
static
mozilla
:
:
TimeStamp
sNow
=
TimeStamp
:
:
Now
(
)
;
static
mozilla
:
:
TimeStamp
AdvanceTime
(
TimeDuration
aDuration
)
{
sNow
+
=
aDuration
;
return
sNow
;
}
static
TimeStamp
Now
(
)
{
return
sNow
;
}
static
uint32_t
sSuspected
=
0
;
static
uint32_t
SuspectedCCObjects
(
)
{
return
sSuspected
;
}
static
void
SetNumSuspected
(
uint32_t
n
)
{
sSuspected
=
n
;
}
static
void
SuspectMore
(
uint32_t
n
)
{
sSuspected
+
=
n
;
}
using
CCRunnerState
=
mozilla
:
:
CCGCScheduler
:
:
CCRunnerState
;
class
TestGC
{
protected
:
CCGCScheduler
&
mScheduler
;
public
:
explicit
TestGC
(
CCGCScheduler
&
aScheduler
)
:
mScheduler
(
aScheduler
)
{
}
void
Run
(
int
aNumSlices
)
;
}
;
void
TestGC
:
:
Run
(
int
aNumSlices
)
{
static_assert
(
3
<
mozilla
:
:
kCCPurpleLimit
)
;
SetNumSuspected
(
3
)
;
CCReason
neededCCAtStartOfGC
=
mScheduler
.
IsCCNeeded
(
Now
(
)
SuspectedCCObjects
(
)
)
;
mScheduler
.
NoteGCBegin
(
JS
:
:
GCReason
:
:
API
)
;
for
(
int
slice
=
0
;
slice
<
aNumSlices
;
slice
+
+
)
{
EXPECT_TRUE
(
mScheduler
.
InIncrementalGC
(
)
)
;
TimeStamp
idleDeadline
=
Now
(
)
+
kTenthSecond
;
JS
:
:
SliceBudget
budget
=
mScheduler
.
ComputeInterSliceGCBudget
(
idleDeadline
Now
(
)
)
;
TimeDuration
budgetDuration
=
TimeDuration
:
:
FromMilliseconds
(
budget
.
timeBudget
(
)
)
;
EXPECT_NEAR
(
budgetDuration
.
ToSeconds
(
)
0
.
1
1
.
e
-
6
)
;
AdvanceTime
(
budgetDuration
)
;
EXPECT_EQ
(
mScheduler
.
IsCCNeeded
(
Now
(
)
SuspectedCCObjects
(
)
)
neededCCAtStartOfGC
)
;
AdvanceTime
(
kOneSecond
)
;
}
mScheduler
.
NoteGCEnd
(
)
;
mScheduler
.
SetNeedsFullGC
(
false
)
;
}
class
TestCC
{
protected
:
CCGCScheduler
&
mScheduler
;
public
:
explicit
TestCC
(
CCGCScheduler
&
aScheduler
)
:
mScheduler
(
aScheduler
)
{
}
void
Run
(
int
aNumSlices
)
{
Prepare
(
)
;
MaybePokeCC
(
)
;
TimerFires
(
aNumSlices
)
;
EndCycleCollectionCallback
(
)
;
KillCCRunner
(
)
;
}
virtual
void
Prepare
(
)
=
0
;
virtual
void
MaybePokeCC
(
)
;
virtual
void
TimerFires
(
int
aNumSlices
)
;
virtual
void
RunSlices
(
int
aNumSlices
)
;
virtual
void
RunSlice
(
TimeStamp
aCCStartTime
TimeStamp
aPrevSliceEnd
int
aSliceNum
int
aNumSlices
)
=
0
;
virtual
void
ForgetSkippable
(
)
;
virtual
void
EndCycleCollectionCallback
(
)
;
virtual
void
KillCCRunner
(
)
;
}
;
void
TestCC
:
:
MaybePokeCC
(
)
{
CCReason
reason
=
mScheduler
.
ShouldScheduleCC
(
Now
(
)
SuspectedCCObjects
(
)
)
;
EXPECT_EQ
(
reason
CCReason
:
:
GC_FINISHED
)
;
mScheduler
.
InitCCRunnerStateMachine
(
CCRunnerState
:
:
ReducePurple
reason
)
;
EXPECT_TRUE
(
mScheduler
.
IsEarlyForgetSkippable
(
)
)
;
}
void
TestCC
:
:
TimerFires
(
int
aNumSlices
)
{
CCRunnerStep
step
;
while
(
true
)
{
SuspectMore
(
1000
)
;
TimeStamp
idleDeadline
=
Now
(
)
+
kOneSecond
;
step
=
mScheduler
.
AdvanceCCRunner
(
idleDeadline
Now
(
)
SuspectedCCObjects
(
)
)
;
if
(
step
.
mAction
!
=
CCRunnerAction
:
:
ForgetSkippable
|
|
step
.
mParam
.
mRemoveChildless
!
=
KeepChildless
)
{
break
;
}
EXPECT_EQ
(
step
.
mYield
Yield
)
;
ForgetSkippable
(
)
;
}
while
(
step
.
mYield
=
=
Continue
)
{
TimeStamp
idleDeadline
=
Now
(
)
+
kOneSecond
;
step
=
mScheduler
.
AdvanceCCRunner
(
idleDeadline
Now
(
)
SuspectedCCObjects
(
)
)
;
}
EXPECT_EQ
(
step
.
mAction
CCRunnerAction
:
:
ForgetSkippable
)
;
EXPECT_EQ
(
step
.
mParam
.
mRemoveChildless
RemoveChildless
)
;
ForgetSkippable
(
)
;
TimeStamp
idleDeadline
=
Now
(
)
+
kOneSecond
;
step
=
mScheduler
.
AdvanceCCRunner
(
idleDeadline
Now
(
)
SuspectedCCObjects
(
)
)
;
EXPECT_EQ
(
step
.
mAction
CCRunnerAction
:
:
CleanupContentUnbinder
)
;
step
=
mScheduler
.
AdvanceCCRunner
(
idleDeadline
Now
(
)
SuspectedCCObjects
(
)
)
;
EXPECT_EQ
(
step
.
mAction
CCRunnerAction
:
:
CleanupDeferred
)
;
mScheduler
.
NoteCCBegin
(
)
;
RunSlices
(
aNumSlices
)
;
}
void
TestCC
:
:
ForgetSkippable
(
)
{
JS
:
:
SliceBudget
budget
=
mScheduler
.
ComputeForgetSkippableBudget
(
Now
(
)
Now
(
)
+
kTenthSecond
)
;
EXPECT_NEAR
(
budget
.
timeBudget
(
)
kTenthSecond
.
ToMilliseconds
(
)
1
)
;
AdvanceTime
(
kTenthSecond
)
;
mScheduler
.
NoteForgetSkippableComplete
(
Now
(
)
SuspectedCCObjects
(
)
)
;
}
void
TestCC
:
:
RunSlices
(
int
aNumSlices
)
{
TimeStamp
ccStartTime
=
Now
(
)
;
TimeStamp
prevSliceEnd
=
ccStartTime
;
for
(
int
ccslice
=
0
;
ccslice
<
aNumSlices
;
ccslice
+
+
)
{
RunSlice
(
ccStartTime
prevSliceEnd
ccslice
aNumSlices
)
;
prevSliceEnd
=
Now
(
)
;
}
SetNumSuspected
(
0
)
;
}
void
TestCC
:
:
EndCycleCollectionCallback
(
)
{
CycleCollectorResults
results
;
results
.
mFreedGCed
=
10
;
results
.
mFreedJSZones
=
2
;
mScheduler
.
NoteCCEnd
(
results
Now
(
)
)
;
EXPECT_TRUE
(
mScheduler
.
NeedsGCAfterCC
(
)
)
;
}
void
TestCC
:
:
KillCCRunner
(
)
{
mScheduler
.
KillCCRunner
(
)
;
}
class
TestIdleCC
:
public
TestCC
{
public
:
explicit
TestIdleCC
(
CCGCScheduler
&
aScheduler
)
:
TestCC
(
aScheduler
)
{
}
void
Prepare
(
)
override
;
void
RunSlice
(
TimeStamp
aCCStartTime
TimeStamp
aPrevSliceEnd
int
aSliceNum
int
aNumSlices
)
override
;
}
;
void
TestIdleCC
:
:
Prepare
(
)
{
EXPECT_TRUE
(
!
mScheduler
.
InIncrementalGC
(
)
)
;
}
void
TestIdleCC
:
:
RunSlice
(
TimeStamp
aCCStartTime
TimeStamp
aPrevSliceEnd
int
aSliceNum
int
aNumSlices
)
{
CCRunnerStep
step
;
TimeStamp
idleDeadline
=
Now
(
)
+
kTenthSecond
;
step
=
mScheduler
.
AdvanceCCRunner
(
idleDeadline
Now
(
)
SuspectedCCObjects
(
)
)
;
EXPECT_EQ
(
step
.
mAction
CCRunnerAction
:
:
CycleCollect
)
;
EXPECT_FALSE
(
mScheduler
.
InIncrementalGC
(
)
)
;
bool
preferShorter
;
JS
:
:
SliceBudget
budget
=
mScheduler
.
ComputeCCSliceBudget
(
idleDeadline
aCCStartTime
aPrevSliceEnd
Now
(
)
&
preferShorter
)
;
EXPECT_NEAR
(
budget
.
timeBudget
(
)
kTenthSecond
.
ToMilliseconds
(
)
1
)
;
EXPECT_FALSE
(
preferShorter
)
;
AdvanceTime
(
kTenthSecond
)
;
}
class
TestNonIdleCC
:
public
TestCC
{
public
:
explicit
TestNonIdleCC
(
CCGCScheduler
&
aScheduler
)
:
TestCC
(
aScheduler
)
{
}
void
Prepare
(
)
override
;
void
RunSlice
(
TimeStamp
aCCStartTime
TimeStamp
aPrevSliceEnd
int
aSliceNum
int
aNumSlices
)
override
;
}
;
void
TestNonIdleCC
:
:
Prepare
(
)
{
EXPECT_TRUE
(
!
mScheduler
.
InIncrementalGC
(
)
)
;
AdvanceTime
(
TimeDuration
:
:
FromSeconds
(
3600
)
)
;
}
void
TestNonIdleCC
:
:
RunSlice
(
TimeStamp
aCCStartTime
TimeStamp
aPrevSliceEnd
int
aSliceNum
int
aNumSlices
)
{
CCRunnerStep
step
;
TimeStamp
nullDeadline
;
step
=
mScheduler
.
AdvanceCCRunner
(
nullDeadline
Now
(
)
SuspectedCCObjects
(
)
)
;
EXPECT_EQ
(
step
.
mAction
CCRunnerAction
:
:
CycleCollect
)
;
EXPECT_FALSE
(
mScheduler
.
InIncrementalGC
(
)
)
;
bool
preferShorter
;
JS
:
:
SliceBudget
budget
=
mScheduler
.
ComputeCCSliceBudget
(
nullDeadline
aCCStartTime
aPrevSliceEnd
Now
(
)
&
preferShorter
)
;
if
(
aSliceNum
=
=
0
)
{
EXPECT_NEAR
(
budget
.
timeBudget
(
)
kICCSliceBudget
.
ToMilliseconds
(
)
0
.
1
)
;
}
else
if
(
aSliceNum
=
=
1
)
{
EXPECT_NEAR
(
budget
.
timeBudget
(
)
kICCSliceBudget
.
ToMilliseconds
(
)
0
.
1
)
;
}
else
if
(
aSliceNum
=
=
2
)
{
EXPECT_FALSE
(
budget
.
isUnlimited
(
)
)
;
EXPECT_NEAR
(
budget
.
timeBudget
(
)
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
/
2
0
.
1
)
;
}
else
{
EXPECT_FALSE
(
budget
.
isUnlimited
(
)
)
;
EXPECT_TRUE
(
budget
.
timeBudget
(
)
>
kICCSliceBudget
.
ToMilliseconds
(
)
)
;
EXPECT_TRUE
(
budget
.
timeBudget
(
)
<
=
MainThreadIdlePeriod
:
:
GetLongIdlePeriod
(
)
)
;
}
EXPECT_TRUE
(
preferShorter
)
;
AdvanceTime
(
TimeDuration
:
:
FromMilliseconds
(
budget
.
timeBudget
(
)
)
)
;
if
(
aSliceNum
=
=
1
)
{
AdvanceTime
(
kICCIntersliceDelay
*
2
)
;
}
}
static
bool
BasicScenario
(
CCGCScheduler
&
aScheduler
TestGC
*
aTestGC
TestCC
*
aTestCC
)
{
aTestGC
-
>
Run
(
10
)
;
SetNumSuspected
(
3
)
;
EXPECT_EQ
(
aScheduler
.
IsCCNeeded
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
GC_FINISHED
)
;
EXPECT_EQ
(
aScheduler
.
ShouldScheduleCC
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
GC_FINISHED
)
;
aTestCC
-
>
Run
(
5
)
;
EXPECT_EQ
(
aScheduler
.
IsCCNeeded
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
NO_REASON
)
;
EXPECT_EQ
(
aScheduler
.
ShouldScheduleCC
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
NO_REASON
)
;
SetNumSuspected
(
10000
)
;
EXPECT_EQ
(
aScheduler
.
ShouldScheduleCC
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
NO_REASON
)
;
AdvanceTime
(
mozilla
:
:
kCCDelay
)
;
EXPECT_EQ
(
aScheduler
.
ShouldScheduleCC
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
MANY_SUSPECTED
)
;
EXPECT_TRUE
(
!
aScheduler
.
InIncrementalGC
(
)
)
;
aTestGC
-
>
Run
(
3
)
;
return
true
;
}
MOZ_RUNINIT
static
CCGCScheduler
scheduler
;
MOZ_RUNINIT
static
TestGC
gc
(
scheduler
)
;
MOZ_RUNINIT
static
TestIdleCC
ccIdle
(
scheduler
)
;
MOZ_RUNINIT
static
TestNonIdleCC
ccNonIdle
(
scheduler
)
;
TEST
(
TestScheduler
Idle
)
{
EXPECT_EQ
(
scheduler
.
ShouldScheduleCC
(
Now
(
)
SuspectedCCObjects
(
)
)
CCReason
:
:
NO_REASON
)
;
EXPECT_TRUE
(
BasicScenario
(
scheduler
&
gc
&
ccIdle
)
)
;
}
TEST
(
TestScheduler
NonIdle
)
{
EXPECT_TRUE
(
BasicScenario
(
scheduler
&
gc
&
ccNonIdle
)
)
;
}
