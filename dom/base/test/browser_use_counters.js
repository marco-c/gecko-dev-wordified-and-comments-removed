requestLongerTimeout
(
2
)
;
const
gHttpTestRoot
=
"
http
:
/
/
example
.
com
/
browser
/
dom
/
base
/
test
/
"
;
var
gOldContentCanRecord
=
false
;
var
gOldParentCanRecord
=
false
;
add_task
(
async
function
test_initialize
(
)
{
let
Telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
gOldParentCanRecord
=
Telemetry
.
canRecordExtended
;
Telemetry
.
canRecordExtended
=
true
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
layout
.
css
.
use
-
counters
.
enabled
"
true
]
[
"
layout
.
css
.
use
-
counters
-
unimplemented
.
enabled
"
true
]
]
}
)
;
gOldContentCanRecord
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
old
=
telemetry
.
canRecordExtended
;
telemetry
.
canRecordExtended
=
true
;
return
old
;
}
)
;
info
(
"
canRecord
for
content
:
"
+
gOldContentCanRecord
)
;
}
)
;
add_task
(
async
function
(
)
{
await
check_use_counter_iframe
(
"
file_use_counter_svg_getElementById
.
svg
"
"
SVGSVGELEMENT_GETELEMENTBYID
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_svg_currentScale
.
svg
"
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_svg_currentScale
.
svg
"
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_style
.
html
"
"
CSS_PROPERTY_BackgroundImage
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_style
.
html
"
"
CSS_PROPERTY_Padding
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_style
.
html
"
"
CSS_PROPERTY_MozTransform
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_style
.
html
"
"
CSS_PROPERTY_WebkitPaddingStart
"
)
;
await
check_use_counter_iframe
(
"
file_use_counter_svg_getElementById
.
svg
"
"
SVGSVGELEMENT_GETELEMENTBYID
"
false
)
;
await
check_use_counter_iframe
(
"
file_use_counter_svg_currentScale
.
svg
"
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
false
)
;
await
check_use_counter_iframe
(
"
file_use_counter_svg_currentScale
.
svg
"
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
false
)
;
await
check_use_counter_img
(
"
file_use_counter_svg_getElementById
.
svg
"
"
CSS_PROPERTY_Fill
"
)
;
await
check_use_counter_img
(
"
file_use_counter_svg_currentScale
.
svg
"
"
CSS_PROPERTY_Fill
"
)
;
await
check_use_counter_direct
(
"
file_use_counter_svg_fill_pattern
.
svg
"
"
CSS_PROPERTY_FillOpacity
"
true
)
;
await
check_use_counter_direct
(
"
file_use_counter_svg_fill_pattern_internal
.
svg
"
"
CSS_PROPERTY_FillOpacity
"
)
;
}
)
;
add_task
(
async
function
(
)
{
let
Telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
Telemetry
.
canRecordExtended
=
gOldParentCanRecord
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
oldCanRecord
:
gOldContentCanRecord
}
]
async
function
(
arg
)
{
await
new
Promise
(
resolve
=
>
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
telemetry
.
canRecordExtended
=
arg
.
oldCanRecord
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
function
grabHistogramsFromContent
(
use_counter_middlefix
page_before
=
null
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
gather
=
(
)
=
>
{
let
snapshots
;
if
(
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
snapshots
=
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
content
;
}
else
{
snapshots
=
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
parent
;
}
let
checkGet
=
probe
=
>
{
return
snapshots
[
probe
]
?
snapshots
[
probe
]
.
sum
:
0
;
}
;
return
[
checkGet
(
"
USE_COUNTER2_
"
+
use_counter_middlefix
+
"
_PAGE
"
)
checkGet
(
"
USE_COUNTER2_
"
+
use_counter_middlefix
+
"
_DOCUMENT
"
)
checkGet
(
"
CONTENT_DOCUMENTS_DESTROYED
"
)
checkGet
(
"
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
"
)
]
;
}
;
return
BrowserTestUtils
.
waitForCondition
(
(
)
=
>
{
return
page_before
!
=
gather
(
)
[
0
]
;
}
)
.
finally
(
gather
)
;
}
var
check_use_counter_iframe
=
async
function
(
file
use_counter_middlefix
check_documents
=
true
)
{
info
(
"
checking
"
+
file
+
"
with
histogram
"
+
use_counter_middlefix
)
;
let
newTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
gBrowser
.
selectedTab
=
newTab
;
newTab
.
linkedBrowser
.
stop
(
)
;
let
[
histogram_page_before
histogram_document_before
histogram_docs_before
histogram_toplevel_docs_before
]
=
await
grabHistogramsFromContent
(
use_counter_middlefix
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
file
}
]
function
(
opts
)
{
let
iframe
=
content
.
document
.
getElementById
(
"
content
"
)
;
iframe
.
src
=
opts
.
file
;
return
new
Promise
(
resolve
=
>
{
let
listener
=
event
=
>
{
event
.
target
.
removeEventListener
(
"
load
"
listener
true
)
;
resolve
(
)
;
}
;
iframe
.
addEventListener
(
"
load
"
listener
true
)
;
}
)
;
}
)
;
let
tabClosed
=
BrowserTestUtils
.
waitForTabClosing
(
newTab
)
;
gBrowser
.
removeTab
(
newTab
)
;
await
tabClosed
;
let
[
histogram_page_after
histogram_document_after
histogram_docs_after
histogram_toplevel_docs_after
]
=
await
grabHistogramsFromContent
(
use_counter_middlefix
histogram_page_before
)
;
is
(
histogram_page_after
histogram_page_before
+
1
"
page
counts
for
"
+
use_counter_middlefix
+
"
after
are
correct
"
)
;
ok
(
histogram_toplevel_docs_after
>
=
histogram_toplevel_docs_before
+
1
"
top
level
document
counts
are
correct
"
)
;
if
(
check_documents
)
{
is
(
histogram_document_after
histogram_document_before
+
1
"
document
counts
for
"
+
use_counter_middlefix
+
"
after
are
correct
"
)
;
}
}
;
var
check_use_counter_img
=
async
function
(
file
use_counter_middlefix
)
{
info
(
"
checking
"
+
file
+
"
as
image
with
histogram
"
+
use_counter_middlefix
)
;
let
newTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
gBrowser
.
selectedTab
=
newTab
;
newTab
.
linkedBrowser
.
stop
(
)
;
let
[
histogram_page_before
histogram_document_before
histogram_docs_before
histogram_toplevel_docs_before
]
=
await
grabHistogramsFromContent
(
use_counter_middlefix
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
file
}
]
async
function
(
opts
)
{
let
img
=
content
.
document
.
getElementById
(
"
display
"
)
;
img
.
src
=
opts
.
file
;
return
new
Promise
(
resolve
=
>
{
let
listener
=
event
=
>
{
img
.
removeEventListener
(
"
load
"
listener
true
)
;
resolve
(
)
;
}
;
img
.
addEventListener
(
"
load
"
listener
true
)
;
}
)
;
}
)
;
let
tabClosed
=
BrowserTestUtils
.
waitForTabClosing
(
newTab
)
;
gBrowser
.
removeTab
(
newTab
)
;
await
tabClosed
;
let
[
histogram_page_after
histogram_document_after
histogram_docs_after
histogram_toplevel_docs_after
]
=
await
grabHistogramsFromContent
(
use_counter_middlefix
histogram_page_before
)
;
is
(
histogram_page_after
histogram_page_before
+
1
"
page
counts
for
"
+
use_counter_middlefix
+
"
after
are
correct
"
)
;
is
(
histogram_document_after
histogram_document_before
+
1
"
document
counts
for
"
+
use_counter_middlefix
+
"
after
are
correct
"
)
;
ok
(
histogram_toplevel_docs_after
>
=
histogram_toplevel_docs_before
+
1
"
top
level
document
counts
are
correct
"
)
;
ok
(
histogram_docs_after
>
=
histogram_docs_before
+
2
"
document
counts
are
correct
"
)
;
}
;
var
check_use_counter_direct
=
async
function
(
file
use_counter_middlefix
xfail
=
false
)
{
info
(
"
checking
"
+
file
+
"
with
histogram
"
+
use_counter_middlefix
)
;
let
newTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
gBrowser
.
selectedTab
=
newTab
;
newTab
.
linkedBrowser
.
stop
(
)
;
let
[
histogram_page_before
histogram_document_before
histogram_docs_before
histogram_toplevel_docs_before
]
=
await
grabHistogramsFromContent
(
use_counter_middlefix
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
gHttpTestRoot
+
file
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
let
tabClosed
=
BrowserTestUtils
.
waitForTabClosing
(
newTab
)
;
gBrowser
.
removeTab
(
newTab
)
;
await
tabClosed
;
let
[
histogram_page_after
histogram_document_after
histogram_docs_after
histogram_toplevel_docs_after
]
=
await
grabHistogramsFromContent
(
use_counter_middlefix
histogram_page_before
)
;
if
(
!
xfail
)
{
is
(
histogram_page_after
histogram_page_before
+
1
"
page
counts
for
"
+
use_counter_middlefix
+
"
after
are
correct
"
)
;
is
(
histogram_document_after
histogram_document_before
+
1
"
document
counts
for
"
+
use_counter_middlefix
+
"
after
are
correct
"
)
;
}
ok
(
histogram_toplevel_docs_after
>
=
histogram_toplevel_docs_before
+
1
"
top
level
document
counts
are
correct
"
)
;
ok
(
histogram_docs_after
>
=
histogram_docs_before
+
1
"
document
counts
are
correct
"
)
;
}
;
