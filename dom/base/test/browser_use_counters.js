requestLongerTimeout
(
2
)
;
const
gHttpTestRoot
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
base
/
test
/
"
;
add_task
(
async
function
test_initialize
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
layout
.
css
.
use
-
counters
.
enabled
"
true
]
[
"
layout
.
css
.
use
-
counters
-
unimplemented
.
enabled
"
true
]
]
}
)
;
}
)
;
add_task
(
async
function
(
)
{
const
TESTS
=
[
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
glean
:
[
"
"
"
svgsvgelementGetelementbyid
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleGetter
"
]
}
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleSetter
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_style
.
html
"
counters
:
[
{
name
:
"
CSS_PROPERTY_BackgroundImage
"
glean
:
[
"
Css
"
"
cssBackgroundImage
"
]
}
{
name
:
"
CSS_PROPERTY_Padding
"
glean
:
[
"
Css
"
"
cssPadding
"
]
}
{
name
:
"
CSS_PROPERTY_MozAppearance
"
glean
:
[
"
Css
"
"
cssMozAppearance
"
]
}
{
name
:
"
CSS_PROPERTY_WebkitPaddingStart
"
glean
:
[
"
Css
"
"
webkitPaddingStart
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
glean
:
[
"
"
"
svgsvgelementGetelementbyid
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleGetter
"
]
}
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleSetter
"
]
}
]
}
{
type
:
"
img
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_Fill
"
glean
:
[
"
Css
"
"
cssFill
"
]
}
]
}
{
type
:
"
img
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_Fill
"
glean
:
[
"
Css
"
"
cssFill
"
]
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_svg_fill_pattern
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_FillOpacity
"
glean
:
[
"
Css
"
"
cssFillOpacity
"
]
xfail
:
true
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_svg_fill_pattern_internal
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_FillOpacity
"
glean
:
[
"
Css
"
"
cssFillOpacity
"
]
}
]
}
{
type
:
"
undisplayed
-
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleGetter
"
]
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_bfcache
.
html
"
waitForExplicitFinish
:
true
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
glean
:
[
"
"
"
svgsvgelementGetelementbyid
"
]
}
]
}
]
;
for
(
let
test
of
TESTS
)
{
let
file
=
test
.
filename
;
info
(
checking
{
file
}
(
{
test
.
type
}
)
)
;
let
before
=
await
grabHistogramsFromContent
(
test
.
counters
.
map
(
c
=
>
c
.
name
)
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
before
.
gleanPage
=
Object
.
fromEntries
(
test
.
counters
.
map
(
c
=
>
[
c
.
name
Glean
[
useCounter
{
c
.
glean
[
0
]
}
Page
]
[
c
.
glean
[
1
]
]
.
testGetValue
(
)
?
?
0
]
)
)
;
before
.
gleanDoc
=
Object
.
fromEntries
(
test
.
counters
.
map
(
c
=
>
[
c
.
name
Glean
[
useCounter
{
c
.
glean
[
0
]
}
Doc
]
[
c
.
glean
[
1
]
]
.
testGetValue
(
)
?
?
0
]
)
)
;
before
.
glean_docs_destroyed
=
Glean
.
useCounter
.
contentDocumentsDestroyed
.
testGetValue
(
)
;
before
.
glean_toplevel_destroyed
=
Glean
.
useCounter
.
topLevelContentDocumentsDestroyed
.
testGetValue
(
)
;
let
url
targetElement
;
switch
(
test
.
type
)
{
case
"
iframe
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
;
targetElement
=
"
content
"
;
break
;
case
"
undisplayed
-
iframe
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer_display_none
.
html
"
;
targetElement
=
"
content
"
;
break
;
case
"
img
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
;
targetElement
=
"
display
"
;
break
;
case
"
direct
"
:
url
=
gHttpTestRoot
+
file
;
targetElement
=
null
;
break
;
default
:
throw
unexpected
type
{
test
.
type
}
;
}
let
waitForFinish
=
null
;
if
(
test
.
waitForExplicitFinish
)
{
is
(
test
.
type
"
direct
"
cannot
use
waitForExplicitFinish
with
test
type
{
test
.
type
}
)
;
waitForFinish
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
url
+
"
#
finished
"
)
;
}
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
if
(
waitForFinish
)
{
await
waitForFinish
;
}
if
(
targetElement
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
file
targetElement
}
]
function
(
opts
)
{
let
target
=
content
.
document
.
getElementById
(
opts
.
targetElement
)
;
target
.
src
=
opts
.
file
;
return
new
Promise
(
resolve
=
>
{
let
listener
=
event
=
>
{
event
.
target
.
removeEventListener
(
"
load
"
listener
true
)
;
resolve
(
)
;
}
;
target
.
addEventListener
(
"
load
"
listener
true
)
;
}
)
;
}
)
;
}
await
BrowserTestUtils
.
removeTab
(
newTab
)
;
let
after
=
await
grabHistogramsFromContent
(
test
.
counters
.
map
(
c
=
>
c
.
name
)
before
.
sentinel
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
after
.
gleanPage
=
Object
.
fromEntries
(
test
.
counters
.
map
(
c
=
>
[
c
.
name
Glean
[
useCounter
{
c
.
glean
[
0
]
}
Page
]
[
c
.
glean
[
1
]
]
.
testGetValue
(
)
?
?
0
]
)
)
;
after
.
gleanDoc
=
Object
.
fromEntries
(
test
.
counters
.
map
(
c
=
>
[
c
.
name
Glean
[
useCounter
{
c
.
glean
[
0
]
}
Doc
]
[
c
.
glean
[
1
]
]
.
testGetValue
(
)
?
?
0
]
)
)
;
after
.
glean_docs_destroyed
=
Glean
.
useCounter
.
contentDocumentsDestroyed
.
testGetValue
(
)
;
after
.
glean_toplevel_destroyed
=
Glean
.
useCounter
.
topLevelContentDocumentsDestroyed
.
testGetValue
(
)
;
for
(
let
counter
of
test
.
counters
)
{
let
name
=
counter
.
name
;
let
value
=
counter
.
value
?
?
1
;
if
(
!
counter
.
xfail
)
{
is
(
after
.
page
[
name
]
before
.
page
[
name
]
+
value
page
counts
for
{
name
}
after
are
correct
)
;
is
(
after
.
document
[
name
]
before
.
document
[
name
]
+
value
document
counts
for
{
name
}
after
are
correct
)
;
is
(
after
.
gleanPage
[
name
]
before
.
gleanPage
[
name
]
+
value
Glean
page
counts
for
{
name
}
are
correct
)
;
is
(
after
.
gleanDoc
[
name
]
before
.
gleanDoc
[
name
]
+
value
Glean
document
counts
for
{
name
}
are
correct
)
;
}
}
if
(
test
.
filename
=
=
"
file_use_counter_bfcache
.
html
"
)
{
ok
(
after
.
toplevel_docs
=
=
before
.
toplevel_docs
+
5
|
|
after
.
toplevel_docs
=
=
before
.
toplevel_docs
+
6
top
level
destroyed
document
counts
are
correct
:
{
before
.
toplevel_docs
}
vs
{
after
.
toplevel_docs
}
)
;
ok
(
after
.
glean_toplevel_destroyed
=
=
before
.
glean_toplevel_destroyed
+
5
|
|
after
.
glean_toplevel_destroyed
=
=
before
.
glean_toplevel_destroyed
+
6
Glean
top
level
destroyed
docs
counts
are
correct
:
{
before
.
glean_toplevel_destroyed
}
vs
{
after
.
glean_toplevel_destroyed
}
)
;
}
else
{
is
(
after
.
toplevel_docs
before
.
toplevel_docs
+
1
"
top
level
destroyed
document
counts
are
correct
"
)
;
is
(
after
.
glean_toplevel_destroyed
before
.
glean_toplevel_destroyed
+
1
"
Glean
top
level
destroyed
document
counts
are
correct
"
)
;
}
ok
(
after
.
docs
>
=
before
.
docs
+
(
test
.
type
=
=
"
img
"
?
2
:
1
)
"
destroyed
document
counts
are
correct
"
)
;
Assert
.
greaterOrEqual
(
after
.
glean_docs_destroyed
before
.
glean_docs_destroyed
+
(
test
.
type
=
=
"
img
"
?
2
:
1
)
"
Glean
destroyed
doc
counts
are
correct
"
)
;
}
}
)
;
async
function
grabHistogramsFromContent
(
names
prev_sentinel
=
null
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
gatheredHistograms
;
return
BrowserTestUtils
.
waitForCondition
(
function
(
)
{
let
snapshots
=
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
;
let
checkGet
=
probe
=
>
{
let
process
=
!
Services
.
appinfo
.
browserTabsRemoteAutostart
|
|
probe
.
endsWith
(
"
_PAGE
"
)
|
|
probe
=
=
"
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
"
?
"
parent
"
:
"
content
"
;
return
snapshots
[
process
]
[
probe
]
?
snapshots
[
process
]
[
probe
]
.
sum
:
0
;
}
;
let
page
=
Object
.
fromEntries
(
names
.
map
(
name
=
>
[
name
checkGet
(
USE_COUNTER2_
{
name
}
_PAGE
)
]
)
)
;
let
document
=
Object
.
fromEntries
(
names
.
map
(
name
=
>
[
name
checkGet
(
USE_COUNTER2_
{
name
}
_DOCUMENT
)
]
)
)
;
gatheredHistograms
=
{
page
document
docs
:
checkGet
(
"
CONTENT_DOCUMENTS_DESTROYED
"
)
toplevel_docs
:
checkGet
(
"
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
"
)
sentinel
:
{
doc
:
checkGet
(
"
USE_COUNTER2_CSS_PROPERTY_MarkerMid_DOCUMENT
"
)
page
:
checkGet
(
"
USE_COUNTER2_CSS_PROPERTY_MarkerMid_PAGE
"
)
}
}
;
let
sentinelChanged
=
!
prev_sentinel
|
|
(
prev_sentinel
.
doc
!
=
gatheredHistograms
.
sentinel
.
doc
&
&
prev_sentinel
.
page
!
=
gatheredHistograms
.
sentinel
.
page
)
;
return
sentinelChanged
;
}
"
grabHistogramsFromContent
"
100
Infinity
)
.
then
(
(
)
=
>
gatheredHistograms
function
(
msg
)
{
throw
msg
;
}
)
;
}
