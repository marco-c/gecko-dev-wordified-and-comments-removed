requestLongerTimeout
(
2
)
;
const
gHttpTestRoot
=
"
http
:
/
/
example
.
com
/
browser
/
dom
/
base
/
test
/
"
;
var
gOldContentCanRecord
=
false
;
var
gOldParentCanRecord
=
false
;
add_task
(
async
function
test_initialize
(
)
{
let
Telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
gOldParentCanRecord
=
Telemetry
.
canRecordExtended
;
Telemetry
.
canRecordExtended
=
true
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
layout
.
css
.
use
-
counters
.
enabled
"
true
]
[
"
layout
.
css
.
use
-
counters
-
unimplemented
.
enabled
"
true
]
]
}
)
;
gOldContentCanRecord
=
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
]
function
(
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
old
=
telemetry
.
canRecordExtended
;
telemetry
.
canRecordExtended
=
true
;
return
old
;
}
)
;
info
(
"
canRecord
for
content
:
"
+
gOldContentCanRecord
)
;
}
)
;
add_task
(
async
function
(
)
{
const
TESTS
=
[
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
}
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_style
.
html
"
counters
:
[
{
name
:
"
CSS_PROPERTY_BackgroundImage
"
}
{
name
:
"
CSS_PROPERTY_Padding
"
}
{
name
:
"
CSS_PROPERTY_MozTransform
"
}
{
name
:
"
CSS_PROPERTY_WebkitPaddingStart
"
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_appearance
.
html
"
counters
:
[
{
name
:
"
APPEARANCE_WIDGET_BUTTON
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_BUTTON
"
value
:
0
}
{
name
:
"
APPEARANCE_WIDGET_TEXTFIELD
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_TEXTFIELD
"
value
:
0
}
{
name
:
"
APPEARANCE_WIDGET_RADIO
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_RADIO
"
value
:
0
}
{
name
:
"
APPEARANCE_WIDGET_CHECKBOX
"
}
{
name
:
"
APPEARANCE_NONWIDGET_CHECKBOX
"
value
:
0
}
{
name
:
"
APPEARANCE_WIDGET_MENULISTBUTTON
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_MENULISTBUTTON
"
}
{
name
:
"
APPEARANCE_WIDGET_METER
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_METER
"
value
:
0
}
{
name
:
"
APPEARANCE_WIDGET_TEXTAREA
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_TEXTAREA
"
value
:
0
}
{
name
:
"
APPEARANCE_WIDGET_RANGE
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_RANGE
"
value
:
0
}
{
name
:
"
APPEARANCE_OVERRIDDEN_RANGE
"
}
{
name
:
"
APPEARANCE_WIDGET_NUMBERINPUT
"
value
:
0
}
{
name
:
"
APPEARANCE_NONWIDGET_NUMBERINPUT
"
value
:
0
}
{
name
:
"
APPEARANCE_OVERRIDDEN_NUMBERINPUT
"
value
:
0
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
}
]
check_documents
:
false
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
}
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
}
]
check_documents
:
false
}
{
type
:
"
img
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_Fill
"
}
]
}
{
type
:
"
img
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_Fill
"
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_svg_fill_pattern
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_FillOpacity
"
xfail
:
true
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_svg_fill_pattern_internal
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_FillOpacity
"
}
]
}
]
;
for
(
let
test
of
TESTS
)
{
let
file
=
test
.
filename
;
info
(
checking
{
file
}
)
;
let
newTab
=
BrowserTestUtils
.
addTab
(
gBrowser
"
about
:
blank
"
)
;
gBrowser
.
selectedTab
=
newTab
;
newTab
.
linkedBrowser
.
stop
(
)
;
let
before
=
await
grabHistogramsFromContent
(
test
.
counters
.
map
(
c
=
>
c
.
name
)
)
;
let
url
targetElement
;
switch
(
test
.
type
)
{
case
"
iframe
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
;
targetElement
=
"
content
"
;
break
;
case
"
img
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
;
targetElement
=
"
display
"
;
break
;
case
"
direct
"
:
url
=
gHttpTestRoot
+
file
;
targetElement
=
null
;
break
;
default
:
throw
unexpected
type
{
test
.
type
}
;
}
BrowserTestUtils
.
loadURI
(
gBrowser
.
selectedBrowser
url
)
;
await
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
;
if
(
targetElement
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
file
targetElement
}
]
function
(
opts
)
{
let
target
=
content
.
document
.
getElementById
(
opts
.
targetElement
)
;
target
.
src
=
opts
.
file
;
return
new
Promise
(
resolve
=
>
{
let
listener
=
event
=
>
{
event
.
target
.
removeEventListener
(
"
load
"
listener
true
)
;
resolve
(
)
;
}
;
target
.
addEventListener
(
"
load
"
listener
true
)
;
}
)
;
}
)
;
}
let
tabClosed
=
BrowserTestUtils
.
waitForTabClosing
(
newTab
)
;
gBrowser
.
removeTab
(
newTab
)
;
await
tabClosed
;
let
after
=
await
grabHistogramsFromContent
(
test
.
counters
.
map
(
c
=
>
c
.
name
)
before
.
sentinel
)
;
for
(
let
counter
of
test
.
counters
)
{
let
name
=
counter
.
name
;
let
value
=
counter
.
value
?
?
1
;
if
(
!
counter
.
xfail
)
{
is
(
after
.
page
[
name
]
before
.
page
[
name
]
+
value
page
counts
for
{
name
}
after
are
correct
)
;
is
(
after
.
document
[
name
]
before
.
document
[
name
]
+
value
document
counts
for
{
name
}
after
are
correct
)
;
}
}
if
(
test
.
check_documents
?
?
true
)
{
ok
(
after
.
toplevel_docs
>
=
before
.
toplevel_docs
+
1
"
top
level
destroyed
document
counts
are
correct
"
)
;
ok
(
after
.
docs
>
=
before
.
docs
+
(
test
.
type
=
=
"
img
"
?
2
:
1
)
"
destroyed
document
counts
are
correct
"
)
;
}
}
}
)
;
add_task
(
async
function
(
)
{
let
Telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
Telemetry
.
canRecordExtended
=
gOldParentCanRecord
;
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
oldCanRecord
:
gOldContentCanRecord
}
]
async
function
(
arg
)
{
await
new
Promise
(
resolve
=
>
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
telemetry
.
canRecordExtended
=
arg
.
oldCanRecord
;
resolve
(
)
;
}
)
;
}
)
;
}
)
;
async
function
grabHistogramsFromContent
(
names
prev_sentinel
=
null
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
gatheredHistograms
;
return
BrowserTestUtils
.
waitForCondition
(
function
(
)
{
let
snapshots
;
if
(
Services
.
appinfo
.
browserTabsRemoteAutostart
)
{
snapshots
=
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
content
;
}
else
{
snapshots
=
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
.
parent
;
}
let
checkGet
=
probe
=
>
{
return
snapshots
[
probe
]
?
snapshots
[
probe
]
.
sum
:
0
;
}
;
let
page
=
Object
.
fromEntries
(
names
.
map
(
name
=
>
[
name
checkGet
(
USE_COUNTER2_
{
name
}
_PAGE
)
]
)
)
;
let
document
=
Object
.
fromEntries
(
names
.
map
(
name
=
>
[
name
checkGet
(
USE_COUNTER2_
{
name
}
_DOCUMENT
)
]
)
)
;
gatheredHistograms
=
{
page
document
docs
:
checkGet
(
"
CONTENT_DOCUMENTS_DESTROYED
"
)
toplevel_docs
:
checkGet
(
"
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
"
)
sentinel
:
checkGet
(
"
USE_COUNTER2_CSS_PROPERTY_MarkerMid_DOCUMENT
"
)
}
;
return
prev_sentinel
!
=
=
gatheredHistograms
.
sentinel
;
}
"
grabHistogramsFromContent
"
100
Infinity
)
.
then
(
(
)
=
>
gatheredHistograms
function
(
msg
)
{
throw
msg
;
}
)
;
}
