requestLongerTimeout
(
2
)
;
const
gHttpTestRoot
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
base
/
test
/
"
;
add_setup
(
async
function
test_initialize
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
layout
.
css
.
use
-
counters
.
enabled
"
true
]
[
"
layout
.
css
.
use
-
counters
-
unimplemented
.
enabled
"
true
]
]
}
)
;
}
)
;
async
function
grabCounters
(
counters
before
)
{
let
result
=
await
grabHistogramsFromContent
(
counters
.
map
(
c
=
>
c
.
name
)
before
?
.
sentinel
)
;
await
Services
.
fog
.
testFlushAllChildren
(
)
;
result
.
gleanPage
=
Object
.
fromEntries
(
counters
.
map
(
c
=
>
[
c
.
name
Glean
[
useCounter
{
c
.
glean
[
0
]
}
Page
]
[
c
.
glean
[
1
]
]
.
testGetValue
(
)
?
?
0
]
)
)
;
result
.
gleanDoc
=
Object
.
fromEntries
(
counters
.
map
(
c
=
>
[
c
.
name
Glean
[
useCounter
{
c
.
glean
[
0
]
}
Doc
]
[
c
.
glean
[
1
]
]
.
testGetValue
(
)
?
?
0
]
)
)
;
result
.
glean_docs_destroyed
=
Glean
.
useCounter
.
contentDocumentsDestroyed
.
testGetValue
(
)
;
result
.
glean_toplevel_destroyed
=
Glean
.
useCounter
.
topLevelContentDocumentsDestroyed
.
testGetValue
(
)
;
return
result
;
}
function
assertRange
(
before
after
key
range
)
{
before
=
before
[
key
]
;
after
=
after
[
key
]
;
let
desc
=
key
+
"
are
correct
"
;
if
(
Array
.
isArray
(
range
)
)
{
let
[
min
max
]
=
range
;
Assert
.
greaterOrEqual
(
after
before
+
min
desc
)
;
Assert
.
lessOrEqual
(
after
before
+
max
desc
)
;
}
else
{
Assert
.
equal
(
after
before
+
range
desc
)
;
}
}
async
function
test_once
(
{
counters
toplevel_docs
docs
ignore_sentinel
}
callback
)
{
let
before
=
await
grabCounters
(
counters
)
;
await
callback
(
)
;
let
after
=
await
grabCounters
(
counters
ignore_sentinel
?
null
:
before
)
;
for
(
let
counter
of
counters
)
{
let
name
=
counter
.
name
;
let
value
=
counter
.
value
?
?
1
;
if
(
!
counter
.
xfail
)
{
is
(
after
.
page
[
name
]
before
.
page
[
name
]
+
value
page
counts
for
{
name
}
after
are
correct
)
;
is
(
after
.
document
[
name
]
before
.
document
[
name
]
+
value
document
counts
for
{
name
}
after
are
correct
)
;
is
(
after
.
gleanPage
[
name
]
before
.
gleanPage
[
name
]
+
value
Glean
page
counts
for
{
name
}
are
correct
)
;
is
(
after
.
gleanDoc
[
name
]
before
.
gleanDoc
[
name
]
+
value
Glean
document
counts
for
{
name
}
are
correct
)
;
}
}
assertRange
(
before
after
"
toplevel_docs
"
toplevel_docs
)
;
assertRange
(
before
after
"
glean_toplevel_destroyed
"
toplevel_docs
)
;
assertRange
(
before
after
"
docs
"
docs
)
;
assertRange
(
before
after
"
glean_docs_destroyed
"
docs
)
;
}
add_task
(
async
function
test_page_counters
(
)
{
const
TESTS
=
[
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
glean
:
[
"
"
"
svgsvgelementGetelementbyid
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleGetter
"
]
}
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleSetter
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_style
.
html
"
counters
:
[
{
name
:
"
CSS_PROPERTY_BackgroundImage
"
glean
:
[
"
Css
"
"
cssBackgroundImage
"
]
}
{
name
:
"
CSS_PROPERTY_Padding
"
glean
:
[
"
Css
"
"
cssPadding
"
]
}
{
name
:
"
CSS_PROPERTY_MozAppearance
"
glean
:
[
"
Css
"
"
cssMozAppearance
"
]
}
{
name
:
"
CSS_PROPERTY_WebkitPaddingStart
"
glean
:
[
"
Css
"
"
webkitPaddingStart
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
glean
:
[
"
"
"
svgsvgelementGetelementbyid
"
]
}
]
}
{
type
:
"
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleGetter
"
]
}
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_setter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleSetter
"
]
}
]
}
{
type
:
"
img
"
filename
:
"
file_use_counter_svg_getElementById
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_Fill
"
glean
:
[
"
Css
"
"
cssFill
"
]
}
]
}
{
type
:
"
img
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_Fill
"
glean
:
[
"
Css
"
"
cssFill
"
]
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_svg_fill_pattern
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_FillOpacity
"
glean
:
[
"
Css
"
"
cssFillOpacity
"
]
xfail
:
true
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_svg_fill_pattern_internal
.
svg
"
counters
:
[
{
name
:
"
CSS_PROPERTY_FillOpacity
"
glean
:
[
"
Css
"
"
cssFillOpacity
"
]
}
]
}
{
type
:
"
undisplayed
-
iframe
"
filename
:
"
file_use_counter_svg_currentScale
.
svg
"
counters
:
[
{
name
:
"
SVGSVGELEMENT_CURRENTSCALE_getter
"
glean
:
[
"
"
"
svgsvgelementCurrentscaleGetter
"
]
}
]
}
{
type
:
"
direct
"
filename
:
"
file_use_counter_bfcache
.
html
"
waitForExplicitFinish
:
true
counters
:
[
{
name
:
"
SVGSVGELEMENT_GETELEMENTBYID
"
glean
:
[
"
"
"
svgsvgelementGetelementbyid
"
]
}
]
}
]
;
for
(
let
test
of
TESTS
)
{
let
file
=
test
.
filename
;
info
(
checking
{
file
}
(
{
test
.
type
}
)
)
;
let
options
=
{
counters
:
test
.
counters
toplevel_docs
:
file
=
=
"
file_use_counter_bfcache
.
html
"
?
[
5
6
]
:
1
docs
:
[
test
.
type
=
=
"
img
"
?
2
:
1
Infinity
]
}
;
await
test_once
(
options
async
function
(
)
{
let
url
targetElement
;
switch
(
test
.
type
)
{
case
"
iframe
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
;
targetElement
=
"
content
"
;
break
;
case
"
undisplayed
-
iframe
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer_display_none
.
html
"
;
targetElement
=
"
content
"
;
break
;
case
"
img
"
:
url
=
gHttpTestRoot
+
"
file_use_counter_outer
.
html
"
;
targetElement
=
"
display
"
;
break
;
case
"
direct
"
:
url
=
gHttpTestRoot
+
file
;
targetElement
=
null
;
break
;
default
:
throw
unexpected
type
{
test
.
type
}
;
}
let
waitForFinish
=
null
;
if
(
test
.
waitForExplicitFinish
)
{
is
(
test
.
type
"
direct
"
cannot
use
waitForExplicitFinish
with
test
type
{
test
.
type
}
)
;
waitForFinish
=
BrowserTestUtils
.
waitForLocationChange
(
gBrowser
url
+
"
#
finished
"
)
;
}
let
newTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
url
)
;
if
(
waitForFinish
)
{
await
waitForFinish
;
}
if
(
targetElement
)
{
await
SpecialPowers
.
spawn
(
gBrowser
.
selectedBrowser
[
{
file
targetElement
}
]
function
(
opts
)
{
let
target
=
content
.
document
.
getElementById
(
opts
.
targetElement
)
;
target
.
src
=
opts
.
file
;
return
new
Promise
(
resolve
=
>
{
let
listener
=
event
=
>
{
event
.
target
.
removeEventListener
(
"
load
"
listener
true
)
;
resolve
(
)
;
}
;
target
.
addEventListener
(
"
load
"
listener
true
)
;
}
)
;
}
)
;
}
await
BrowserTestUtils
.
removeTab
(
newTab
)
;
}
)
;
}
}
)
;
add_task
(
async
function
test_extension_counters
(
)
{
let
options
=
{
counters
:
[
]
docs
:
0
toplevel_docs
:
0
ignore_sentinel
:
true
}
;
await
test_once
(
options
async
function
(
)
{
let
extension
=
ExtensionTestUtils
.
loadExtension
(
{
manifest
:
{
page_action
:
{
default_popup
:
"
page
.
html
"
browser_style
:
false
}
}
async
background
(
)
{
let
[
tab
]
=
await
browser
.
tabs
.
query
(
{
active
:
true
currentWindow
:
true
}
)
;
await
browser
.
pageAction
.
show
(
tab
.
id
)
;
browser
.
test
.
sendMessage
(
"
ready
"
)
;
}
files
:
{
"
page
.
html
"
:
<
!
DOCTYPE
html
>
<
meta
charset
=
"
utf
-
8
"
>
<
!
-
-
Enough
to
trigger
the
use
counter
-
-
>
<
style
>
:
root
{
opacity
:
.
5
}
<
/
style
>
}
}
)
;
await
extension
.
startup
(
)
;
info
(
"
Extension
started
up
"
)
;
await
extension
.
awaitMessage
(
"
ready
"
)
;
await
extension
.
unload
(
)
;
info
(
"
Extension
unloaded
"
)
;
}
)
;
}
)
;
async
function
grabHistogramsFromContent
(
names
prev_sentinel
=
null
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
gatheredHistograms
;
return
BrowserTestUtils
.
waitForCondition
(
function
(
)
{
let
snapshots
=
telemetry
.
getSnapshotForHistograms
(
"
main
"
false
)
;
let
checkGet
=
probe
=
>
{
let
process
=
!
Services
.
appinfo
.
browserTabsRemoteAutostart
|
|
probe
.
endsWith
(
"
_PAGE
"
)
|
|
probe
=
=
"
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
"
?
"
parent
"
:
"
content
"
;
return
snapshots
[
process
]
[
probe
]
?
snapshots
[
process
]
[
probe
]
.
sum
:
0
;
}
;
let
page
=
Object
.
fromEntries
(
names
.
map
(
name
=
>
[
name
checkGet
(
USE_COUNTER2_
{
name
}
_PAGE
)
]
)
)
;
let
document
=
Object
.
fromEntries
(
names
.
map
(
name
=
>
[
name
checkGet
(
USE_COUNTER2_
{
name
}
_DOCUMENT
)
]
)
)
;
gatheredHistograms
=
{
page
document
docs
:
checkGet
(
"
CONTENT_DOCUMENTS_DESTROYED
"
)
toplevel_docs
:
checkGet
(
"
TOP_LEVEL_CONTENT_DOCUMENTS_DESTROYED
"
)
sentinel
:
{
doc
:
checkGet
(
"
USE_COUNTER2_CSS_PROPERTY_MarkerMid_DOCUMENT
"
)
page
:
checkGet
(
"
USE_COUNTER2_CSS_PROPERTY_MarkerMid_PAGE
"
)
}
}
;
let
sentinelChanged
=
!
prev_sentinel
|
|
(
prev_sentinel
.
doc
!
=
gatheredHistograms
.
sentinel
.
doc
&
&
prev_sentinel
.
page
!
=
gatheredHistograms
.
sentinel
.
page
)
;
return
sentinelChanged
;
}
"
grabHistogramsFromContent
"
100
Infinity
)
.
then
(
(
)
=
>
gatheredHistograms
function
(
msg
)
{
throw
msg
;
}
)
;
}
