"
use
strict
"
;
function
dirtyStyleAndLayout
(
factor
=
1
)
{
gNavToolbox
.
style
.
padding
=
factor
+
"
px
"
;
}
function
dirtyStyle
(
)
{
gNavToolbox
.
style
.
color
=
"
red
"
;
}
const
gWindowUtils
=
window
.
windowUtils
;
function
assertNoFlushesRequired
(
)
{
Assert
.
ok
(
!
gWindowUtils
.
needsFlush
(
Ci
.
nsIDOMWindowUtils
.
FLUSH_STYLE
)
"
No
style
flushes
are
required
.
"
)
;
Assert
.
ok
(
!
gWindowUtils
.
needsFlush
(
Ci
.
nsIDOMWindowUtils
.
FLUSH_LAYOUT
)
"
No
layout
flushes
are
required
.
"
)
;
}
function
assertFlushesRequired
(
)
{
Assert
.
ok
(
gWindowUtils
.
needsFlush
(
Ci
.
nsIDOMWindowUtils
.
FLUSH_STYLE
)
"
Style
flush
required
.
"
)
;
Assert
.
ok
(
gWindowUtils
.
needsFlush
(
Ci
.
nsIDOMWindowUtils
.
FLUSH_LAYOUT
)
"
Layout
flush
required
.
"
)
;
}
async
function
cleanTheDOM
(
)
{
gNavToolbox
.
style
.
padding
=
"
"
;
gNavToolbox
.
style
.
color
=
"
"
;
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
}
add_task
(
async
function
setup
(
)
{
registerCleanupFunction
(
cleanTheDOM
)
;
}
)
;
add_task
(
async
function
test_basic
(
)
{
dirtyStyleAndLayout
(
)
;
assertFlushesRequired
(
)
;
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
assertNoFlushesRequired
(
)
;
dirtyStyle
(
)
;
assertFlushesRequired
(
)
;
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
assertNoFlushesRequired
(
)
;
await
cleanTheDOM
(
)
;
}
)
;
add_task
(
async
function
test_can_get_results_from_callback
(
)
{
const
NEW_PADDING
=
"
2px
"
;
gNavToolbox
.
style
.
padding
=
NEW_PADDING
;
assertFlushesRequired
(
)
;
let
paddings
=
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
style
=
window
.
getComputedStyle
(
gNavToolbox
)
;
return
{
left
:
style
.
paddingLeft
right
:
style
.
paddingRight
top
:
style
.
paddingTop
bottom
:
style
.
paddingBottom
}
;
}
)
;
for
(
let
prop
in
paddings
)
{
Assert
.
equal
(
paddings
[
prop
]
NEW_PADDING
"
Got
expected
padding
"
)
;
}
await
cleanTheDOM
(
)
;
gNavToolbox
.
style
.
padding
=
NEW_PADDING
;
assertFlushesRequired
(
)
;
let
rect
=
await
window
.
promiseDocumentFlushed
(
(
)
=
>
{
let
observer
=
{
reflow
(
)
{
Assert
.
ok
(
false
"
A
reflow
should
not
have
occurred
.
"
)
;
}
reflowInterruptible
(
)
{
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIReflowObserver
Ci
.
nsISupportsWeakReference
]
)
}
;
let
docShell
=
window
.
docShell
;
docShell
.
addWeakReflowObserver
(
observer
)
;
let
toolboxRect
=
gNavToolbox
.
getBoundingClientRect
(
)
;
docShell
.
removeWeakReflowObserver
(
observer
)
;
return
toolboxRect
;
}
)
;
for
(
let
property
of
[
"
width
"
"
height
"
]
)
{
Assert
.
ok
(
rect
[
property
]
>
0
Rect
property
{
property
}
>
0
(
{
rect
[
property
]
}
)
)
;
}
await
cleanTheDOM
(
)
;
}
)
;
add_task
(
async
function
test_resolved_in_window_close
(
)
{
let
win
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
await
win
.
promiseDocumentFlushed
(
(
)
=
>
{
}
)
;
let
docShell
=
win
.
docShell
;
docShell
.
contentViewer
.
pausePainting
(
)
;
win
.
gNavToolbox
.
style
.
padding
=
"
5px
"
;
const
EXPECTED
=
1234
;
let
promise
=
win
.
promiseDocumentFlushed
(
(
)
=
>
{
return
EXPECTED
;
}
)
;
await
BrowserTestUtils
.
closeWindow
(
win
)
;
Assert
.
equal
(
await
promise
EXPECTED
)
;
}
)
;
add_task
(
async
function
test_reentrancy
(
)
{
dirtyStyleAndLayout
(
)
;
assertFlushesRequired
(
)
;
let
promise
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
return
window
.
promiseDocumentFlushed
(
(
)
=
>
{
Assert
.
ok
(
false
"
Should
never
run
this
.
"
)
;
}
)
;
}
)
;
await
Assert
.
rejects
(
promise
ex
=
>
ex
.
result
=
=
Cr
.
NS_ERROR_FAILURE
)
;
}
)
;
add_task
(
async
function
test_execution_order
(
)
{
let
result
=
[
]
;
dirtyStyleAndLayout
(
1
)
;
let
promise1
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
result
.
push
(
0
)
;
}
)
.
then
(
(
)
=
>
{
result
.
push
(
2
)
;
}
)
;
let
promise2
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
result
.
push
(
1
)
;
}
)
.
then
(
(
)
=
>
{
result
.
push
(
3
)
;
}
)
;
await
Promise
.
all
(
[
promise1
promise2
]
)
;
Assert
.
equal
(
result
.
length
4
"
Should
have
run
all
callbacks
and
Promises
.
"
)
;
let
promise3
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
result
.
push
(
4
)
;
}
)
.
then
(
(
)
=
>
{
result
.
push
(
6
)
;
}
)
;
let
promise4
=
window
.
promiseDocumentFlushed
(
(
)
=
>
{
result
.
push
(
5
)
;
}
)
.
then
(
(
)
=
>
{
result
.
push
(
7
)
;
}
)
;
await
Promise
.
all
(
[
promise3
promise4
]
)
;
Assert
.
equal
(
result
.
length
8
"
Should
have
run
all
callbacks
and
Promises
.
"
)
;
for
(
let
i
=
0
;
i
<
result
.
length
;
+
+
i
)
{
Assert
.
equal
(
result
[
i
]
i
"
Callbacks
and
Promises
should
have
run
in
the
expected
order
.
"
)
;
}
}
)
;
