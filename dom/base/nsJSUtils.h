#
ifndef
nsJSUtils_h__
#
define
nsJSUtils_h__
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
nsString
.
h
"
#
include
"
xpcpublic
.
h
"
class
nsIScriptContext
;
class
nsIScriptElement
;
class
nsIScriptGlobalObject
;
class
nsXBLPrototypeBinding
;
namespace
mozilla
{
namespace
dom
{
class
AutoJSAPI
;
class
Element
;
}
}
class
nsJSUtils
{
public
:
static
bool
GetCallingLocation
(
JSContext
*
aContext
nsACString
&
aFilename
uint32_t
*
aLineno
=
nullptr
uint32_t
*
aColumn
=
nullptr
)
;
static
bool
GetCallingLocation
(
JSContext
*
aContext
nsAString
&
aFilename
uint32_t
*
aLineno
=
nullptr
uint32_t
*
aColumn
=
nullptr
)
;
static
uint64_t
GetCurrentlyRunningCodeInnerWindowID
(
JSContext
*
aContext
)
;
static
nsresult
CompileFunction
(
mozilla
:
:
dom
:
:
AutoJSAPI
&
jsapi
JS
:
:
HandleVector
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
&
aOptions
const
nsACString
&
aName
uint32_t
aArgCount
const
char
*
*
aArgArray
const
nsAString
&
aBody
JSObject
*
*
aFunctionObject
)
;
class
MOZ_STACK_CLASS
ExecutionContext
{
#
ifdef
MOZ_GECKO_PROFILER
mozilla
:
:
AutoProfilerLabel
mAutoProfilerLabel
;
#
endif
JSContext
*
mCx
;
JSAutoRealm
mRealm
;
JS
:
:
Rooted
<
JS
:
:
Value
>
mRetValue
;
JS
:
:
RootedVector
<
JSObject
*
>
mScopeChain
;
JS
:
:
Rooted
<
JSScript
*
>
mScript
;
nsresult
mRv
;
bool
mSkip
;
bool
mCoerceToString
;
bool
mEncodeBytecode
;
#
ifdef
DEBUG
bool
mWantsReturnValue
;
bool
mExpectScopeChain
;
bool
mScriptUsed
;
#
endif
private
:
template
<
typename
Unit
>
nsresult
InternalCompile
(
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
SourceText
<
Unit
>
&
aSrcBuf
)
;
public
:
ExecutionContext
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
;
ExecutionContext
(
const
ExecutionContext
&
)
=
delete
;
ExecutionContext
(
ExecutionContext
&
&
)
=
delete
;
~
ExecutionContext
(
)
{
MOZ_ASSERT_IF
(
!
mSkip
!
mWantsReturnValue
)
;
MOZ_ASSERT_IF
(
mEncodeBytecode
&
&
mScript
&
&
mRv
=
=
NS_OK
mScriptUsed
)
;
}
ExecutionContext
&
SetCoerceToString
(
bool
aCoerceToString
)
{
mCoerceToString
=
aCoerceToString
;
return
*
this
;
}
ExecutionContext
&
SetEncodeBytecode
(
bool
aEncodeBytecode
)
{
mEncodeBytecode
=
aEncodeBytecode
;
return
*
this
;
}
void
SetScopeChain
(
JS
:
:
HandleVector
<
JSObject
*
>
aScopeChain
)
;
MOZ_MUST_USE
nsresult
JoinCompile
(
JS
:
:
OffThreadToken
*
*
aOffThreadToken
)
;
nsresult
Compile
(
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
SourceText
<
char16_t
>
&
aSrcBuf
)
;
nsresult
Compile
(
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
aSrcBuf
)
;
nsresult
Compile
(
JS
:
:
CompileOptions
&
aCompileOptions
const
nsAString
&
aScript
)
;
nsresult
Decode
(
JS
:
:
CompileOptions
&
aCompileOptions
mozilla
:
:
Vector
<
uint8_t
>
&
aBytecodeBuf
size_t
aBytecodeIndex
)
;
nsresult
JoinDecode
(
JS
:
:
OffThreadToken
*
*
aOffThreadToken
)
;
nsresult
JoinDecodeBinAST
(
JS
:
:
OffThreadToken
*
*
aOffThreadToken
)
;
nsresult
DecodeBinAST
(
JS
:
:
CompileOptions
&
aCompileOptions
const
uint8_t
*
aBuf
size_t
aLength
)
;
JSScript
*
GetScript
(
)
;
JSScript
*
MaybeGetScript
(
)
;
MOZ_MUST_USE
nsresult
ExecScript
(
)
;
MOZ_MUST_USE
nsresult
ExecScript
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetValue
)
;
}
;
static
bool
BinASTEncodingEnabled
(
)
{
return
false
;
}
static
nsresult
CompileModule
(
JSContext
*
aCx
JS
:
:
SourceText
<
char16_t
>
&
aSrcBuf
JS
:
:
Handle
<
JSObject
*
>
aEvaluationGlobal
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
;
static
nsresult
CompileModule
(
JSContext
*
aCx
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
aSrcBuf
JS
:
:
Handle
<
JSObject
*
>
aEvaluationGlobal
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
;
static
nsresult
ModuleInstantiate
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
)
;
static
nsresult
ModuleEvaluate
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
)
;
static
bool
GetScopeChainForElement
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Element
*
aElement
JS
:
:
MutableHandleVector
<
JSObject
*
>
aScopeChain
)
;
static
void
ResetTimeZone
(
)
;
static
bool
DumpEnabled
(
)
;
}
;
inline
void
AssignFromStringBuffer
(
nsStringBuffer
*
buffer
size_t
len
nsAString
&
dest
)
{
buffer
-
>
ToString
(
len
dest
)
;
}
template
<
typename
T
typename
std
:
:
enable_if_t
<
std
:
:
is_same
<
typename
T
:
:
char_type
char16_t
>
:
:
value
>
*
=
nullptr
>
inline
bool
AssignJSString
(
JSContext
*
cx
T
&
dest
JSString
*
s
)
{
size_t
len
=
JS
:
:
GetStringLength
(
s
)
;
static_assert
(
js
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
const
char16_t
*
chars
;
if
(
XPCStringConvert
:
:
MaybeGetDOMStringChars
(
s
&
chars
)
)
{
if
(
chars
[
len
]
=
=
'
\
0
'
)
{
AssignFromStringBuffer
(
nsStringBuffer
:
:
FromData
(
const_cast
<
char16_t
*
>
(
chars
)
)
len
dest
)
;
return
true
;
}
}
else
if
(
XPCStringConvert
:
:
MaybeGetLiteralStringChars
(
s
&
chars
)
)
{
dest
.
AssignLiteral
(
chars
len
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
!
dest
.
SetLength
(
len
mozilla
:
:
fallible
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
js
:
:
CopyStringChars
(
cx
dest
.
BeginWriting
(
)
s
len
)
;
}
template
<
typename
T
typename
std
:
:
enable_if_t
<
std
:
:
is_same
<
typename
T
:
:
char_type
char
>
:
:
value
>
*
=
nullptr
>
inline
bool
AssignJSString
(
JSContext
*
cx
T
&
dest
JSString
*
s
)
{
using
namespace
mozilla
;
CheckedInt
<
size_t
>
bufLen
(
JS
:
:
GetStringLength
(
s
)
)
;
if
(
js
:
:
StringHasLatin1Chars
(
s
)
)
{
bufLen
*
=
2
;
}
else
{
bufLen
*
=
3
;
}
if
(
MOZ_UNLIKELY
(
!
bufLen
.
isValid
(
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
const
bool
kAllowShrinking
=
true
;
auto
handleOrErr
=
dest
.
BulkWrite
(
bufLen
.
value
(
)
0
kAllowShrinking
)
;
if
(
MOZ_UNLIKELY
(
handleOrErr
.
isErr
(
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
auto
handle
=
handleOrErr
.
unwrap
(
)
;
auto
maybe
=
JS_EncodeStringToUTF8BufferPartial
(
cx
s
handle
.
AsSpan
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
maybe
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
size_t
read
;
size_t
written
;
Tie
(
read
written
)
=
*
maybe
;
MOZ_ASSERT
(
read
=
=
JS
:
:
GetStringLength
(
s
)
)
;
handle
.
Finish
(
written
kAllowShrinking
)
;
return
true
;
}
inline
void
AssignJSLinearString
(
nsAString
&
dest
JSLinearString
*
s
)
{
size_t
len
=
js
:
:
GetLinearStringLength
(
s
)
;
static_assert
(
js
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
dest
.
SetLength
(
len
)
;
js
:
:
CopyLinearStringChars
(
dest
.
BeginWriting
(
)
s
len
)
;
}
inline
void
AssignJSLinearString
(
nsACString
&
dest
JSLinearString
*
s
)
{
size_t
len
=
js
:
:
GetLinearStringLength
(
s
)
;
static_assert
(
js
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
dest
.
SetLength
(
len
)
;
js
:
:
CopyLinearStringChars
(
dest
.
BeginWriting
(
)
s
len
)
;
}
template
<
typename
T
>
class
nsTAutoJSLinearString
:
public
nsTAutoString
<
T
>
{
public
:
explicit
nsTAutoJSLinearString
(
JSLinearString
*
str
)
{
AssignJSLinearString
(
*
this
str
)
;
}
}
;
using
nsAutoJSLinearString
=
nsTAutoJSLinearString
<
char16_t
>
;
using
nsAutoJSLinearCString
=
nsTAutoJSLinearString
<
char
>
;
template
<
typename
T
>
class
nsTAutoJSString
:
public
nsTAutoString
<
T
>
{
public
:
nsTAutoJSString
(
)
=
default
;
bool
init
(
JSContext
*
aContext
JSString
*
str
)
{
return
AssignJSString
(
aContext
*
this
str
)
;
}
bool
init
(
JSContext
*
aContext
const
JS
:
:
Value
&
v
)
{
if
(
v
.
isString
(
)
)
{
return
init
(
aContext
v
.
toString
(
)
)
;
}
JS
:
:
Rooted
<
JSString
*
>
str
(
aContext
)
;
if
(
v
.
isObject
(
)
)
{
str
=
JS_NewStringCopyZ
(
aContext
"
[
Object
]
"
)
;
}
else
{
JS
:
:
Rooted
<
JS
:
:
Value
>
rootedVal
(
aContext
v
)
;
str
=
JS
:
:
ToString
(
aContext
rootedVal
)
;
}
return
str
&
&
init
(
aContext
str
)
;
}
bool
init
(
JSContext
*
aContext
jsid
id
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aContext
)
;
return
JS_IdToValue
(
aContext
id
&
v
)
&
&
init
(
aContext
v
)
;
}
bool
init
(
const
JS
:
:
Value
&
v
)
;
~
nsTAutoJSString
(
)
=
default
;
}
;
using
nsAutoJSString
=
nsTAutoJSString
<
char16_t
>
;
using
nsAutoJSCString
=
nsTAutoJSString
<
char
>
;
#
endif
