#
ifndef
nsJSUtils_h__
#
define
nsJSUtils_h__
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
StableStringChars
.
h
"
#
include
"
nsString
.
h
"
#
include
"
xpcpublic
.
h
"
class
nsIScriptContext
;
class
nsIScriptElement
;
class
nsIScriptGlobalObject
;
class
nsXBLPrototypeBinding
;
namespace
mozilla
{
namespace
dom
{
class
AutoJSAPI
;
class
Element
;
}
}
class
nsJSUtils
{
public
:
static
bool
GetCallingLocation
(
JSContext
*
aContext
nsACString
&
aFilename
uint32_t
*
aLineno
=
nullptr
uint32_t
*
aColumn
=
nullptr
)
;
static
bool
GetCallingLocation
(
JSContext
*
aContext
nsAString
&
aFilename
uint32_t
*
aLineno
=
nullptr
uint32_t
*
aColumn
=
nullptr
)
;
static
uint64_t
GetCurrentlyRunningCodeInnerWindowID
(
JSContext
*
aContext
)
;
static
nsresult
CompileFunction
(
mozilla
:
:
dom
:
:
AutoJSAPI
&
jsapi
JS
:
:
HandleVector
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
&
aOptions
const
nsACString
&
aName
uint32_t
aArgCount
const
char
*
*
aArgArray
const
nsAString
&
aBody
JSObject
*
*
aFunctionObject
)
;
class
MOZ_STACK_CLASS
ExecutionContext
{
#
ifdef
MOZ_GECKO_PROFILER
mozilla
:
:
AutoProfilerLabel
mAutoProfilerLabel
;
#
endif
JSContext
*
mCx
;
JSAutoRealm
mRealm
;
JS
:
:
Rooted
<
JS
:
:
Value
>
mRetValue
;
JS
:
:
RootedVector
<
JSObject
*
>
mScopeChain
;
JS
:
:
Rooted
<
JSScript
*
>
mScript
;
nsresult
mRv
;
bool
mSkip
;
bool
mCoerceToString
;
bool
mEncodeBytecode
;
#
ifdef
DEBUG
bool
mWantsReturnValue
;
bool
mExpectScopeChain
;
bool
mScriptUsed
;
#
endif
private
:
template
<
typename
Unit
>
nsresult
InternalCompile
(
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
SourceText
<
Unit
>
&
aSrcBuf
)
;
public
:
ExecutionContext
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
;
ExecutionContext
(
const
ExecutionContext
&
)
=
delete
;
ExecutionContext
(
ExecutionContext
&
&
)
=
delete
;
~
ExecutionContext
(
)
{
MOZ_ASSERT_IF
(
!
mSkip
!
mWantsReturnValue
)
;
MOZ_ASSERT_IF
(
mEncodeBytecode
&
&
mScript
&
&
mRv
=
=
NS_OK
mScriptUsed
)
;
}
ExecutionContext
&
SetCoerceToString
(
bool
aCoerceToString
)
{
mCoerceToString
=
aCoerceToString
;
return
*
this
;
}
ExecutionContext
&
SetEncodeBytecode
(
bool
aEncodeBytecode
)
{
mEncodeBytecode
=
aEncodeBytecode
;
return
*
this
;
}
void
SetScopeChain
(
JS
:
:
HandleVector
<
JSObject
*
>
aScopeChain
)
;
MOZ_MUST_USE
nsresult
JoinCompile
(
JS
:
:
OffThreadToken
*
*
aOffThreadToken
)
;
nsresult
Compile
(
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
SourceText
<
char16_t
>
&
aSrcBuf
)
;
nsresult
Compile
(
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
aSrcBuf
)
;
nsresult
Compile
(
JS
:
:
CompileOptions
&
aCompileOptions
const
nsAString
&
aScript
)
;
nsresult
Decode
(
JS
:
:
CompileOptions
&
aCompileOptions
mozilla
:
:
Vector
<
uint8_t
>
&
aBytecodeBuf
size_t
aBytecodeIndex
)
;
nsresult
JoinDecode
(
JS
:
:
OffThreadToken
*
*
aOffThreadToken
)
;
nsresult
JoinDecodeBinAST
(
JS
:
:
OffThreadToken
*
*
aOffThreadToken
)
;
nsresult
DecodeBinAST
(
JS
:
:
CompileOptions
&
aCompileOptions
const
uint8_t
*
aBuf
size_t
aLength
)
;
JSScript
*
GetScript
(
)
;
JSScript
*
MaybeGetScript
(
)
;
MOZ_MUST_USE
nsresult
ExecScript
(
)
;
MOZ_MUST_USE
nsresult
ExecScript
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetValue
)
;
}
;
static
bool
BinASTEncodingEnabled
(
)
{
#
ifdef
JS_BUILD_BINAST
return
mozilla
:
:
StaticPrefs
:
:
dom_script_loader_binast_encoding_enabled
(
)
;
#
else
return
false
;
#
endif
}
static
nsresult
CompileModule
(
JSContext
*
aCx
JS
:
:
SourceText
<
char16_t
>
&
aSrcBuf
JS
:
:
Handle
<
JSObject
*
>
aEvaluationGlobal
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
;
static
nsresult
CompileModule
(
JSContext
*
aCx
JS
:
:
SourceText
<
mozilla
:
:
Utf8Unit
>
&
aSrcBuf
JS
:
:
Handle
<
JSObject
*
>
aEvaluationGlobal
JS
:
:
CompileOptions
&
aCompileOptions
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
;
static
nsresult
InitModuleSourceElement
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
nsIScriptElement
*
aElement
)
;
static
nsresult
ModuleInstantiate
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
)
;
static
nsresult
ModuleEvaluate
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
)
;
static
bool
GetScopeChainForElement
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Element
*
aElement
JS
:
:
MutableHandleVector
<
JSObject
*
>
aScopeChain
)
;
static
void
ResetTimeZone
(
)
;
static
bool
DumpEnabled
(
)
;
}
;
inline
void
AssignFromStringBuffer
(
nsStringBuffer
*
buffer
size_t
len
nsAString
&
dest
)
{
buffer
-
>
ToString
(
len
dest
)
;
}
template
<
typename
T
>
inline
bool
AssignJSString
(
JSContext
*
cx
T
&
dest
JSString
*
s
)
{
size_t
len
=
JS
:
:
GetStringLength
(
s
)
;
static_assert
(
js
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
const
char16_t
*
chars
;
if
(
XPCStringConvert
:
:
MaybeGetDOMStringChars
(
s
&
chars
)
)
{
if
(
chars
[
len
]
=
=
'
\
0
'
)
{
AssignFromStringBuffer
(
nsStringBuffer
:
:
FromData
(
const_cast
<
char16_t
*
>
(
chars
)
)
len
dest
)
;
return
true
;
}
}
else
if
(
XPCStringConvert
:
:
MaybeGetLiteralStringChars
(
s
&
chars
)
)
{
dest
.
AssignLiteral
(
chars
len
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
!
dest
.
SetLength
(
len
mozilla
:
:
fallible
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
js
:
:
CopyStringChars
(
cx
dest
.
BeginWriting
(
)
s
len
)
;
}
inline
void
AssignJSLinearString
(
nsAString
&
dest
JSLinearString
*
s
)
{
size_t
len
=
js
:
:
GetLinearStringLength
(
s
)
;
static_assert
(
js
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
dest
.
SetLength
(
len
)
;
js
:
:
CopyLinearStringChars
(
dest
.
BeginWriting
(
)
s
len
)
;
}
class
nsAutoJSString
:
public
nsAutoString
{
public
:
nsAutoJSString
(
)
{
}
bool
init
(
JSContext
*
aContext
JSString
*
str
)
{
return
AssignJSString
(
aContext
*
this
str
)
;
}
bool
init
(
JSContext
*
aContext
const
JS
:
:
Value
&
v
)
{
if
(
v
.
isString
(
)
)
{
return
init
(
aContext
v
.
toString
(
)
)
;
}
JS
:
:
Rooted
<
JSString
*
>
str
(
aContext
)
;
if
(
v
.
isObject
(
)
)
{
str
=
JS_NewStringCopyZ
(
aContext
"
[
Object
]
"
)
;
}
else
{
JS
:
:
Rooted
<
JS
:
:
Value
>
rootedVal
(
aContext
v
)
;
str
=
JS
:
:
ToString
(
aContext
rootedVal
)
;
}
return
str
&
&
init
(
aContext
str
)
;
}
bool
init
(
JSContext
*
aContext
jsid
id
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aContext
)
;
return
JS_IdToValue
(
aContext
id
&
v
)
&
&
init
(
aContext
v
)
;
}
bool
init
(
const
JS
:
:
Value
&
v
)
;
~
nsAutoJSString
(
)
{
}
}
;
#
endif
