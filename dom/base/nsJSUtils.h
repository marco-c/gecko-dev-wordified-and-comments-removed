#
ifndef
nsJSUtils_h__
#
define
nsJSUtils_h__
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
String
.
h
"
#
include
"
nsString
.
h
"
#
include
"
xpcpublic
.
h
"
class
nsIScriptContext
;
class
nsIScriptElement
;
class
nsIScriptGlobalObject
;
class
nsXBLPrototypeBinding
;
namespace
mozilla
{
union
Utf8Unit
;
namespace
dom
{
class
AutoJSAPI
;
class
Element
;
}
}
class
nsJSUtils
{
public
:
static
bool
GetCallingLocation
(
JSContext
*
aContext
nsACString
&
aFilename
uint32_t
*
aLineno
=
nullptr
uint32_t
*
aColumn
=
nullptr
)
;
static
bool
GetCallingLocation
(
JSContext
*
aContext
nsAString
&
aFilename
uint32_t
*
aLineno
=
nullptr
uint32_t
*
aColumn
=
nullptr
)
;
static
uint64_t
GetCurrentlyRunningCodeInnerWindowID
(
JSContext
*
aContext
)
;
static
nsresult
CompileFunction
(
mozilla
:
:
dom
:
:
AutoJSAPI
&
jsapi
JS
:
:
HandleVector
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
&
aOptions
const
nsACString
&
aName
uint32_t
aArgCount
const
char
*
*
aArgArray
const
nsAString
&
aBody
JSObject
*
*
aFunctionObject
)
;
static
nsresult
UpdateFunctionDebugMetadata
(
mozilla
:
:
dom
:
:
AutoJSAPI
&
jsapi
JS
:
:
Handle
<
JSObject
*
>
aFun
JS
:
:
CompileOptions
&
aOptions
JS
:
:
Handle
<
JSString
*
>
aElementAttributeName
JS
:
:
Handle
<
JS
:
:
Value
>
aPrivateValue
)
;
static
bool
IsScriptable
(
JS
:
:
Handle
<
JSObject
*
>
aEvaluationGlobal
)
;
static
nsresult
ModuleInstantiate
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
)
;
static
nsresult
ModuleEvaluate
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aModule
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
;
static
bool
GetScopeChainForElement
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Element
*
aElement
JS
:
:
MutableHandleVector
<
JSObject
*
>
aScopeChain
)
;
static
void
ResetTimeZone
(
)
;
static
bool
DumpEnabled
(
)
;
}
;
inline
void
AssignFromStringBuffer
(
nsStringBuffer
*
buffer
size_t
len
nsAString
&
dest
)
{
buffer
-
>
ToString
(
len
dest
)
;
}
template
<
typename
T
typename
std
:
:
enable_if_t
<
std
:
:
is_same
<
typename
T
:
:
char_type
char16_t
>
:
:
value
>
*
=
nullptr
>
inline
bool
AssignJSString
(
JSContext
*
cx
T
&
dest
JSString
*
s
)
{
size_t
len
=
JS
:
:
GetStringLength
(
s
)
;
static_assert
(
JS
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
const
char16_t
*
chars
;
if
(
XPCStringConvert
:
:
MaybeGetDOMStringChars
(
s
&
chars
)
)
{
if
(
chars
[
len
]
=
=
'
\
0
'
)
{
AssignFromStringBuffer
(
nsStringBuffer
:
:
FromData
(
const_cast
<
char16_t
*
>
(
chars
)
)
len
dest
)
;
return
true
;
}
}
else
if
(
XPCStringConvert
:
:
MaybeGetLiteralStringChars
(
s
&
chars
)
)
{
dest
.
AssignLiteral
(
chars
len
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
!
dest
.
SetLength
(
len
mozilla
:
:
fallible
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
return
JS
:
:
CopyStringChars
(
cx
dest
.
BeginWriting
(
)
s
len
)
;
}
template
<
typename
T
typename
std
:
:
enable_if_t
<
std
:
:
is_same
<
typename
T
:
:
char_type
char
>
:
:
value
>
*
=
nullptr
>
inline
bool
AssignJSString
(
JSContext
*
cx
T
&
dest
JSString
*
s
)
{
using
namespace
mozilla
;
CheckedInt
<
size_t
>
bufLen
(
JS
:
:
GetStringLength
(
s
)
)
;
if
(
JS
:
:
StringHasLatin1Chars
(
s
)
)
{
bufLen
*
=
2
;
}
else
{
bufLen
*
=
3
;
}
if
(
MOZ_UNLIKELY
(
!
bufLen
.
isValid
(
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
const
bool
kAllowShrinking
=
true
;
auto
handleOrErr
=
dest
.
BulkWrite
(
bufLen
.
value
(
)
0
kAllowShrinking
)
;
if
(
MOZ_UNLIKELY
(
handleOrErr
.
isErr
(
)
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
auto
handle
=
handleOrErr
.
unwrap
(
)
;
auto
maybe
=
JS_EncodeStringToUTF8BufferPartial
(
cx
s
handle
.
AsSpan
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
maybe
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
false
;
}
size_t
read
;
size_t
written
;
Tie
(
read
written
)
=
*
maybe
;
MOZ_ASSERT
(
read
=
=
JS
:
:
GetStringLength
(
s
)
)
;
handle
.
Finish
(
written
kAllowShrinking
)
;
return
true
;
}
inline
void
AssignJSLinearString
(
nsAString
&
dest
JSLinearString
*
s
)
{
size_t
len
=
JS
:
:
GetLinearStringLength
(
s
)
;
static_assert
(
JS
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
dest
.
SetLength
(
len
)
;
JS
:
:
CopyLinearStringChars
(
dest
.
BeginWriting
(
)
s
len
)
;
}
inline
void
AssignJSLinearString
(
nsACString
&
dest
JSLinearString
*
s
)
{
size_t
len
=
JS
:
:
GetLinearStringLength
(
s
)
;
static_assert
(
JS
:
:
MaxStringLength
<
(
1
<
<
30
)
"
Shouldn
'
t
overflow
here
or
in
SetCapacity
"
)
;
dest
.
SetLength
(
len
)
;
JS
:
:
LossyCopyLinearStringChars
(
dest
.
BeginWriting
(
)
s
len
)
;
}
template
<
typename
T
>
class
nsTAutoJSLinearString
:
public
nsTAutoString
<
T
>
{
public
:
explicit
nsTAutoJSLinearString
(
JSLinearString
*
str
)
{
AssignJSLinearString
(
*
this
str
)
;
}
}
;
using
nsAutoJSLinearString
=
nsTAutoJSLinearString
<
char16_t
>
;
using
nsAutoJSLinearCString
=
nsTAutoJSLinearString
<
char
>
;
template
<
typename
T
>
class
nsTAutoJSString
:
public
nsTAutoString
<
T
>
{
public
:
nsTAutoJSString
(
)
=
default
;
bool
init
(
JSContext
*
aContext
JSString
*
str
)
{
return
AssignJSString
(
aContext
*
this
str
)
;
}
bool
init
(
JSContext
*
aContext
const
JS
:
:
Value
&
v
)
{
if
(
v
.
isString
(
)
)
{
return
init
(
aContext
v
.
toString
(
)
)
;
}
JS
:
:
Rooted
<
JSString
*
>
str
(
aContext
)
;
if
(
v
.
isObject
(
)
)
{
str
=
JS_NewStringCopyZ
(
aContext
"
[
Object
]
"
)
;
}
else
{
JS
:
:
Rooted
<
JS
:
:
Value
>
rootedVal
(
aContext
v
)
;
str
=
JS
:
:
ToString
(
aContext
rootedVal
)
;
}
return
str
&
&
init
(
aContext
str
)
;
}
bool
init
(
JSContext
*
aContext
jsid
id
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aContext
)
;
return
JS_IdToValue
(
aContext
id
&
v
)
&
&
init
(
aContext
v
)
;
}
bool
init
(
const
JS
:
:
Value
&
v
)
;
~
nsTAutoJSString
(
)
=
default
;
}
;
using
nsAutoJSString
=
nsTAutoJSString
<
char16_t
>
;
using
nsAutoJSCString
=
nsTAutoJSString
<
char
>
;
#
endif
