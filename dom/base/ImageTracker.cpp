#
include
"
ImageTracker
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
dom
{
ImageTracker
:
:
ImageTracker
(
)
:
mLocking
(
false
)
mAnimating
(
true
)
{
}
ImageTracker
:
:
~
ImageTracker
(
)
{
SetLockingState
(
false
)
;
}
nsresult
ImageTracker
:
:
Add
(
imgIRequest
*
aImage
)
{
MOZ_ASSERT
(
aImage
)
;
nsresult
rv
=
NS_OK
;
auto
entry
=
mImages
.
LookupForAdd
(
aImage
)
;
if
(
entry
)
{
uint32_t
oldCount
=
entry
.
Data
(
)
;
MOZ_ASSERT
(
oldCount
>
0
"
Entry
in
the
image
tracker
with
count
0
!
"
)
;
entry
.
Data
(
)
=
oldCount
+
1
;
}
else
{
entry
.
OrInsert
(
[
]
(
)
{
return
1
;
}
)
;
if
(
mLocking
)
{
rv
=
aImage
-
>
LockImage
(
)
;
}
if
(
mAnimating
)
{
nsresult
rv2
=
aImage
-
>
IncrementAnimationConsumers
(
)
;
rv
=
NS_SUCCEEDED
(
rv
)
?
rv2
:
rv
;
}
}
return
rv
;
}
nsresult
ImageTracker
:
:
Remove
(
imgIRequest
*
aImage
uint32_t
aFlags
)
{
NS_ENSURE_ARG_POINTER
(
aImage
)
;
if
(
auto
entry
=
mImages
.
Lookup
(
aImage
)
)
{
MOZ_ASSERT
(
entry
.
Data
(
)
>
0
"
Entry
in
the
image
tracker
with
count
0
!
"
)
;
if
(
-
-
entry
.
Data
(
)
=
=
0
)
{
entry
.
Remove
(
)
;
}
else
{
return
NS_OK
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Removing
image
that
wasn
'
t
in
the
tracker
!
"
)
;
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
if
(
mLocking
)
{
rv
=
aImage
-
>
UnlockImage
(
)
;
}
if
(
mAnimating
)
{
nsresult
rv2
=
aImage
-
>
DecrementAnimationConsumers
(
)
;
rv
=
NS_SUCCEEDED
(
rv
)
?
rv2
:
rv
;
}
if
(
aFlags
&
REQUEST_DISCARD
)
{
aImage
-
>
RequestDiscard
(
)
;
}
return
rv
;
}
nsresult
ImageTracker
:
:
SetLockingState
(
bool
aLocked
)
{
if
(
XRE_IsContentProcess
(
)
&
&
!
Preferences
:
:
GetBool
(
"
image
.
mem
.
allow_locking_in_content_processes
"
true
)
)
{
return
NS_OK
;
}
if
(
mLocking
=
=
aLocked
)
return
NS_OK
;
for
(
auto
iter
=
mImages
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
imgIRequest
*
image
=
iter
.
Key
(
)
;
if
(
aLocked
)
{
image
-
>
LockImage
(
)
;
}
else
{
image
-
>
UnlockImage
(
)
;
}
}
mLocking
=
aLocked
;
return
NS_OK
;
}
void
ImageTracker
:
:
SetAnimatingState
(
bool
aAnimating
)
{
if
(
mAnimating
=
=
aAnimating
)
return
;
for
(
auto
iter
=
mImages
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
imgIRequest
*
image
=
iter
.
Key
(
)
;
if
(
aAnimating
)
{
image
-
>
IncrementAnimationConsumers
(
)
;
}
else
{
image
-
>
DecrementAnimationConsumers
(
)
;
}
}
mAnimating
=
aAnimating
;
}
void
ImageTracker
:
:
RequestDiscardAll
(
)
{
for
(
auto
iter
=
mImages
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Key
(
)
-
>
RequestDiscard
(
)
;
}
}
void
ImageTracker
:
:
MediaFeatureValuesChangedAllDocuments
(
const
MediaFeatureChange
&
aChange
)
{
nsTArray
<
nsCOMPtr
<
imgIContainer
>
>
images
;
for
(
auto
iter
=
mImages
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
imgIRequest
*
req
=
iter
.
Key
(
)
;
nsCOMPtr
<
imgIContainer
>
image
;
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
!
image
)
{
continue
;
}
images
.
AppendElement
(
image
-
>
Unwrap
(
)
)
;
}
for
(
imgIContainer
*
image
:
images
)
{
image
-
>
MediaFeatureValuesChangedAllDocuments
(
aChange
)
;
}
}
}
}
