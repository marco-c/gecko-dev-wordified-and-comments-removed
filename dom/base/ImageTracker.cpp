#
include
"
ImageTracker
.
h
"
namespace
mozilla
{
namespace
dom
{
ImageTracker
:
:
ImageTracker
(
)
:
mLockingImages
(
false
)
mAnimatingImages
(
true
)
{
}
ImageTracker
:
:
~
ImageTracker
(
)
{
SetImageLockingState
(
false
)
;
}
nsresult
ImageTracker
:
:
AddImage
(
imgIRequest
*
aImage
)
{
MOZ_ASSERT
(
aImage
)
;
uint32_t
oldCount
=
0
;
mImageTracker
.
Get
(
aImage
&
oldCount
)
;
mImageTracker
.
Put
(
aImage
oldCount
+
1
)
;
nsresult
rv
=
NS_OK
;
if
(
oldCount
=
=
0
&
&
mLockingImages
)
{
rv
=
aImage
-
>
LockImage
(
)
;
}
if
(
oldCount
=
=
0
&
&
mAnimatingImages
)
{
nsresult
rv2
=
aImage
-
>
IncrementAnimationConsumers
(
)
;
rv
=
NS_SUCCEEDED
(
rv
)
?
rv2
:
rv
;
}
return
rv
;
}
nsresult
ImageTracker
:
:
RemoveImage
(
imgIRequest
*
aImage
uint32_t
aFlags
)
{
NS_ENSURE_ARG_POINTER
(
aImage
)
;
uint32_t
count
=
0
;
DebugOnly
<
bool
>
found
=
mImageTracker
.
Get
(
aImage
&
count
)
;
MOZ_ASSERT
(
found
"
Removing
image
that
wasn
'
t
in
the
tracker
!
"
)
;
MOZ_ASSERT
(
count
>
0
"
Entry
in
the
cache
tracker
with
count
0
!
"
)
;
count
-
-
;
if
(
count
!
=
0
)
{
mImageTracker
.
Put
(
aImage
count
)
;
return
NS_OK
;
}
mImageTracker
.
Remove
(
aImage
)
;
nsresult
rv
=
NS_OK
;
if
(
mLockingImages
)
{
rv
=
aImage
-
>
UnlockImage
(
)
;
}
if
(
mAnimatingImages
)
{
nsresult
rv2
=
aImage
-
>
DecrementAnimationConsumers
(
)
;
rv
=
NS_SUCCEEDED
(
rv
)
?
rv2
:
rv
;
}
if
(
aFlags
&
REQUEST_DISCARD
)
{
aImage
-
>
RequestDiscard
(
)
;
}
return
rv
;
}
nsresult
ImageTracker
:
:
SetImageLockingState
(
bool
aLocked
)
{
if
(
XRE_IsContentProcess
(
)
&
&
!
Preferences
:
:
GetBool
(
"
image
.
mem
.
allow_locking_in_content_processes
"
true
)
)
{
return
NS_OK
;
}
if
(
mLockingImages
=
=
aLocked
)
return
NS_OK
;
for
(
auto
iter
=
mImageTracker
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
imgIRequest
*
image
=
iter
.
Key
(
)
;
if
(
aLocked
)
{
image
-
>
LockImage
(
)
;
}
else
{
image
-
>
UnlockImage
(
)
;
}
}
mLockingImages
=
aLocked
;
return
NS_OK
;
}
void
ImageTracker
:
:
SetImagesNeedAnimating
(
bool
aAnimating
)
{
if
(
mAnimatingImages
=
=
aAnimating
)
return
;
for
(
auto
iter
=
mImageTracker
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
imgIRequest
*
image
=
iter
.
Key
(
)
;
if
(
aAnimating
)
{
image
-
>
IncrementAnimationConsumers
(
)
;
}
else
{
image
-
>
DecrementAnimationConsumers
(
)
;
}
}
mAnimatingImages
=
aAnimating
;
}
void
ImageTracker
:
:
RequestDiscardAll
(
)
{
for
(
auto
iter
=
mImageTracker
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Key
(
)
-
>
RequestDiscard
(
)
;
}
}
}
}
