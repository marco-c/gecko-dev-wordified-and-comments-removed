#
ifndef
mozilla_dom_shadowroot_h__
#
define
mozilla_dom_shadowroot_h__
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIdentifierMapEntry
.
h
"
#
include
"
nsTHashtable
.
h
"
class
nsAtom
;
class
nsIContent
;
class
nsXBLPrototypeBinding
;
namespace
mozilla
{
class
EventChainPreVisitor
;
class
ServoStyleRuleMap
;
namespace
css
{
class
Rule
;
}
namespace
dom
{
class
Element
;
class
ShadowRoot
final
:
public
DocumentFragment
public
DocumentOrShadowRoot
public
nsStubMutationObserver
{
public
:
NS_IMPL_FROMNODE_HELPER
(
ShadowRoot
IsShadowRoot
(
)
)
;
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
ShadowRoot
DocumentFragment
)
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
ShadowRoot
(
Element
*
aElement
ShadowRootMode
aMode
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
Element
*
Host
(
)
const
{
MOZ_ASSERT
(
GetHost
(
)
"
ShadowRoot
always
has
a
host
how
did
we
create
"
"
this
ShadowRoot
?
"
)
;
return
GetHost
(
)
;
}
ShadowRootMode
Mode
(
)
const
{
return
mMode
;
}
bool
IsClosed
(
)
const
{
return
mMode
=
=
ShadowRootMode
:
:
Closed
;
}
void
RemoveSheet
(
StyleSheet
*
aSheet
)
;
void
RuleAdded
(
StyleSheet
&
css
:
:
Rule
&
)
;
void
RuleRemoved
(
StyleSheet
&
css
:
:
Rule
&
)
;
void
RuleChanged
(
StyleSheet
&
css
:
:
Rule
*
)
;
void
StyleSheetApplicableStateChanged
(
StyleSheet
&
bool
aApplicable
)
;
StyleSheetList
*
StyleSheets
(
)
{
return
&
DocumentOrShadowRoot
:
:
EnsureDOMStyleSheets
(
)
;
}
void
CloneInternalDataFrom
(
ShadowRoot
*
aOther
)
;
void
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
)
;
private
:
void
InsertSheetIntoAuthorData
(
size_t
aIndex
StyleSheet
&
)
;
void
AppendStyleSheet
(
StyleSheet
&
aSheet
)
{
InsertSheetAt
(
SheetCount
(
)
aSheet
)
;
}
void
MaybeReassignElement
(
Element
*
aElement
)
;
struct
SlotAssignment
{
HTMLSlotElement
*
mSlot
=
nullptr
;
Maybe
<
uint32_t
>
mIndex
;
SlotAssignment
(
)
=
default
;
SlotAssignment
(
HTMLSlotElement
*
aSlot
const
Maybe
<
uint32_t
>
&
aIndex
)
:
mSlot
(
aSlot
)
mIndex
(
aIndex
)
{
}
}
;
SlotAssignment
SlotAssignmentFor
(
nsIContent
*
aContent
)
;
void
InvalidateStyleAndLayoutOnSubtree
(
Element
*
)
;
public
:
void
AddSlot
(
HTMLSlotElement
*
aSlot
)
;
void
RemoveSlot
(
HTMLSlotElement
*
aSlot
)
;
bool
HasSlots
(
)
const
{
return
!
mSlotMap
.
IsEmpty
(
)
;
}
;
const
RawServoAuthorStyles
*
ServoStyles
(
)
const
{
return
mServoStyles
.
get
(
)
;
}
RawServoAuthorStyles
*
ServoStyles
(
)
{
return
mServoStyles
.
get
(
)
;
}
mozilla
:
:
ServoStyleRuleMap
&
ServoStyleRuleMap
(
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementById
;
Element
*
GetActiveElement
(
)
;
void
GetInnerHTML
(
nsAString
&
aInnerHTML
)
;
void
SetInnerHTML
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
;
bool
IsComposedDocParticipant
(
)
const
{
return
mIsComposedDocParticipant
;
}
void
SetIsComposedDocParticipant
(
bool
aIsComposedDocParticipant
)
;
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
protected
:
void
ApplicableRulesChanged
(
)
;
virtual
~
ShadowRoot
(
)
;
const
ShadowRootMode
mMode
;
UniquePtr
<
RawServoAuthorStyles
>
mServoStyles
;
UniquePtr
<
mozilla
:
:
ServoStyleRuleMap
>
mStyleRuleMap
;
using
SlotArray
=
AutoTArray
<
HTMLSlotElement
*
1
>
;
nsClassHashtable
<
nsStringHashKey
SlotArray
>
mSlotMap
;
bool
mIsComposedDocParticipant
;
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
override
;
}
;
}
}
#
endif
