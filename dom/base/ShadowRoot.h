#
ifndef
mozilla_dom_shadowroot_h__
#
define
mozilla_dom_shadowroot_h__
#
include
"
mozilla
/
BindgenUniquePtr
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRootBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsTHashtable
.
h
"
class
nsAtom
;
class
nsIContent
;
class
nsIPrincipal
;
namespace
mozilla
{
struct
StyleAuthorStyles
;
struct
StyleRuleChange
;
class
EventChainPreVisitor
;
class
ServoStyleRuleMap
;
enum
class
StyleRuleChangeKind
:
uint32_t
;
enum
class
BuiltInStyleSheet
:
uint8_t
;
namespace
css
{
class
Rule
;
}
namespace
dom
{
class
CSSImportRule
;
class
Element
;
class
HTMLInputElement
;
class
OwningTrustedHTMLOrNullIsEmptyString
;
class
TrustedHTMLOrString
;
class
TrustedHTMLOrNullIsEmptyString
;
class
ShadowRoot
final
:
public
DocumentFragment
public
DocumentOrShadowRoot
{
friend
class
DocumentOrShadowRoot
;
using
Declarative
=
Element
:
:
ShadowRootDeclarative
;
using
IsClonable
=
Element
:
:
ShadowRootClonable
;
using
IsSerializable
=
Element
:
:
ShadowRootSerializable
;
public
:
NS_IMPL_FROMNODE_HELPER
(
ShadowRoot
IsShadowRoot
(
)
)
;
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
ShadowRoot
DocumentFragment
)
NS_DECL_ISUPPORTS_INHERITED
ShadowRoot
(
Element
*
aElement
ShadowRootMode
aMode
Element
:
:
DelegatesFocus
aDelegatesFocus
SlotAssignmentMode
aSlotAssignment
IsClonable
aClonable
IsSerializable
aIsSerializable
Declarative
aDeclarative
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
size_t
*
aNodeSize
)
const
final
;
void
MaybeReassignContent
(
nsIContent
&
aElementOrText
)
;
void
MaybeSlotHostChild
(
nsIContent
&
)
;
void
MaybeUnslotHostChild
(
nsIContent
&
)
;
Element
*
Host
(
)
const
{
MOZ_ASSERT
(
GetHost
(
)
"
ShadowRoot
always
has
a
host
how
did
we
create
"
"
this
ShadowRoot
?
"
)
;
return
GetHost
(
)
;
}
ShadowRootMode
Mode
(
)
const
{
return
mMode
;
}
bool
DelegatesFocus
(
)
const
{
return
mDelegatesFocus
=
=
Element
:
:
DelegatesFocus
:
:
Yes
;
}
SlotAssignmentMode
SlotAssignment
(
)
const
{
return
mSlotAssignment
;
}
bool
Clonable
(
)
const
{
return
mIsClonable
=
=
IsClonable
:
:
Yes
;
}
bool
IsClosed
(
)
const
{
return
mMode
=
=
ShadowRootMode
:
:
Closed
;
}
bool
Serializable
(
)
const
{
return
mIsSerializable
=
=
IsSerializable
:
:
Yes
;
}
void
RemoveSheetFromStyles
(
StyleSheet
&
)
;
void
RuleAdded
(
StyleSheet
&
css
:
:
Rule
&
)
;
void
RuleRemoved
(
StyleSheet
&
css
:
:
Rule
&
)
;
void
RuleChanged
(
StyleSheet
&
css
:
:
Rule
*
const
StyleRuleChange
&
)
;
void
ImportRuleLoaded
(
StyleSheet
&
)
;
void
SheetCloned
(
StyleSheet
&
)
;
void
StyleSheetApplicableStateChanged
(
StyleSheet
&
)
;
void
AppendBuiltInStyleSheet
(
BuiltInStyleSheet
)
;
void
CloneInternalDataFrom
(
ShadowRoot
*
aOther
)
;
void
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
)
;
void
Unbind
(
)
;
void
Unattach
(
)
;
nsresult
Bind
(
)
;
void
InvalidateStyleAndLayoutOnSubtree
(
Element
*
)
;
private
:
void
InsertSheetIntoAuthorData
(
size_t
aIndex
StyleSheet
&
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
)
;
void
AppendStyleSheet
(
StyleSheet
&
aSheet
)
{
InsertSheetAt
(
SheetCount
(
)
aSheet
)
;
}
struct
SlotInsertionPoint
{
HTMLSlotElement
*
mSlot
=
nullptr
;
Maybe
<
uint32_t
>
mIndex
;
SlotInsertionPoint
(
)
=
default
;
SlotInsertionPoint
(
HTMLSlotElement
*
aSlot
const
Maybe
<
uint32_t
>
&
aIndex
)
:
mSlot
(
aSlot
)
mIndex
(
aIndex
)
{
}
}
;
SlotInsertionPoint
SlotInsertionPointFor
(
nsIContent
&
)
;
void
GetSlotNameFor
(
const
nsIContent
&
nsAString
&
)
const
;
enum
class
SummaryChangeReason
{
Deletion
Insertion
}
;
void
MaybeReassignMainSummary
(
SummaryChangeReason
)
;
public
:
void
AddSlot
(
HTMLSlotElement
*
aSlot
)
;
void
RemoveSlot
(
HTMLSlotElement
*
aSlot
)
;
bool
HasSlots
(
)
const
{
return
!
mSlotMap
.
IsEmpty
(
)
;
}
;
HTMLSlotElement
*
GetDefaultSlot
(
)
const
{
SlotArray
*
list
=
mSlotMap
.
Get
(
u
"
"
_ns
)
;
return
list
?
(
*
list
)
.
AsSpan
(
)
[
0
]
:
nullptr
;
}
void
PartAdded
(
const
Element
&
)
;
void
PartRemoved
(
const
Element
&
)
;
IMPL_EVENT_HANDLER
(
slotchange
)
;
const
nsTArray
<
const
Element
*
>
&
Parts
(
)
const
{
return
mParts
;
}
const
StyleAuthorStyles
*
GetServoStyles
(
)
const
{
return
mServoStyles
.
get
(
)
;
}
StyleAuthorStyles
*
GetServoStyles
(
)
{
return
mServoStyles
.
get
(
)
;
}
mozilla
:
:
ServoStyleRuleMap
&
ServoStyleRuleMap
(
)
;
JSObject
*
WrapNode
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
final
;
void
NodeInfoChanged
(
Document
*
aOldDoc
)
override
;
void
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementById
;
Element
*
GetActiveElement
(
)
;
nsINode
*
ImportNodeAndAppendChildAt
(
nsINode
&
aParentNode
nsINode
&
aNode
bool
aDeep
mozilla
:
:
ErrorResult
&
rv
)
;
nsINode
*
CreateElementAndAppendChildAt
(
nsINode
&
aParentNode
const
nsAString
&
aTagName
mozilla
:
:
ErrorResult
&
rv
)
;
bool
IsUAWidget
(
)
const
{
return
HasBeenInUAWidget
(
)
;
}
void
SetIsUAWidget
(
)
{
MOZ_ASSERT
(
!
HasChildren
(
)
)
;
SetIsNativeAnonymousRoot
(
)
;
SetFlags
(
NODE_HAS_BEEN_IN_UA_WIDGET
)
;
}
bool
IsAvailableToElementInternals
(
)
const
{
return
mIsAvailableToElementInternals
;
}
void
SetAvailableToElementInternals
(
)
{
mIsAvailableToElementInternals
=
true
;
}
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
bool
IsDeclarative
(
)
const
{
return
mIsDeclarative
=
=
Declarative
:
:
Yes
;
}
void
SetIsDeclarative
(
Declarative
aIsDeclarative
)
{
mIsDeclarative
=
aIsDeclarative
;
}
void
SetIsDeclarative
(
bool
aIsDeclarative
)
{
mIsDeclarative
=
aIsDeclarative
?
Declarative
:
:
Yes
:
Declarative
:
:
No
;
}
void
SetHTML
(
const
nsAString
&
aInnerHTML
const
SetHTMLOptions
&
aOptions
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
SetHTMLUnsafe
(
const
TrustedHTMLOrString
&
aHTML
const
SetHTMLUnsafeOptions
&
aOptions
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
GetInnerHTML
(
OwningTrustedHTMLOrNullIsEmptyString
&
aInnerHTML
)
;
MOZ_CAN_RUN_SCRIPT
void
SetInnerHTML
(
const
TrustedHTMLOrNullIsEmptyString
&
aInnerHTML
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
GetHTML
(
const
GetHTMLOptions
&
aOptions
nsAString
&
aResult
)
;
void
GetReferenceTarget
(
nsAString
&
aResult
)
const
{
if
(
!
mReferenceTarget
)
{
aResult
.
SetIsVoid
(
true
)
;
return
;
}
mReferenceTarget
-
>
ToString
(
aResult
)
;
}
nsAtom
*
ReferenceTarget
(
)
const
{
return
mReferenceTarget
;
}
void
SetReferenceTarget
(
const
nsAString
&
aValue
)
{
if
(
aValue
.
IsVoid
(
)
)
{
return
SetReferenceTarget
(
nullptr
)
;
}
SetReferenceTarget
(
NS_Atomize
(
aValue
)
)
;
}
void
SetReferenceTarget
(
RefPtr
<
nsAtom
>
aTarget
)
;
Element
*
GetReferenceTargetElement
(
)
const
{
return
mReferenceTarget
?
GetElementById
(
mReferenceTarget
)
:
nullptr
;
}
protected
:
void
ApplicableRulesChanged
(
)
;
virtual
~
ShadowRoot
(
)
;
BindgenUniquePtr
<
StyleAuthorStyles
>
mServoStyles
;
UniquePtr
<
mozilla
:
:
ServoStyleRuleMap
>
mStyleRuleMap
;
using
SlotArray
=
TreeOrderedArray
<
HTMLSlotElement
*
>
;
nsClassHashtable
<
nsStringHashKey
SlotArray
>
mSlotMap
;
nsTArray
<
const
Element
*
>
mParts
;
const
ShadowRootMode
mMode
;
Element
:
:
DelegatesFocus
mDelegatesFocus
;
const
SlotAssignmentMode
mSlotAssignment
;
bool
mIsDetailsShadowTree
:
1
;
bool
mIsAvailableToElementInternals
:
1
;
Declarative
mIsDeclarative
;
const
IsClonable
mIsClonable
;
const
IsSerializable
mIsSerializable
;
RefPtr
<
nsAtom
>
mReferenceTarget
;
nsresult
Clone
(
dom
:
:
NodeInfo
*
nsINode
*
*
aResult
)
const
override
;
}
;
}
}
#
endif
