#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
WorkerPrivate
.
h
"
namespace
mozilla
{
namespace
dom
{
static
MOZ_THREAD_LOCAL
(
ScriptSettingsStackEntry
*
)
sScriptSettingsTLS
;
static
bool
sScriptSettingsTLSInitialized
;
class
ScriptSettingsStack
{
public
:
static
ScriptSettingsStackEntry
*
Top
(
)
{
return
sScriptSettingsTLS
.
get
(
)
;
}
static
void
Push
(
ScriptSettingsStackEntry
*
aEntry
)
{
MOZ_ASSERT
(
!
aEntry
-
>
mOlder
)
;
MOZ_ASSERT_IF
(
!
Top
(
)
|
|
Top
(
)
-
>
NoJSAPI
(
)
aEntry
-
>
mIsCandidateEntryPoint
)
;
aEntry
-
>
mOlder
=
Top
(
)
;
sScriptSettingsTLS
.
set
(
aEntry
)
;
}
static
void
Pop
(
ScriptSettingsStackEntry
*
aEntry
)
{
MOZ_ASSERT
(
aEntry
=
=
Top
(
)
)
;
sScriptSettingsTLS
.
set
(
aEntry
-
>
mOlder
)
;
}
static
nsIGlobalObject
*
IncumbentGlobal
(
)
{
ScriptSettingsStackEntry
*
entry
=
Top
(
)
;
if
(
!
entry
)
{
return
nullptr
;
}
return
entry
-
>
mGlobalObject
;
}
static
ScriptSettingsStackEntry
*
EntryPoint
(
)
{
ScriptSettingsStackEntry
*
entry
=
Top
(
)
;
if
(
!
entry
)
{
return
nullptr
;
}
while
(
entry
)
{
if
(
entry
-
>
mIsCandidateEntryPoint
)
return
entry
;
entry
=
entry
-
>
mOlder
;
}
MOZ_CRASH
(
"
Non
-
empty
stack
should
always
have
an
entry
point
"
)
;
}
static
nsIGlobalObject
*
EntryGlobal
(
)
{
ScriptSettingsStackEntry
*
entry
=
EntryPoint
(
)
;
if
(
!
entry
)
{
return
nullptr
;
}
return
entry
-
>
mGlobalObject
;
}
}
;
static
unsigned
long
gRunToCompletionListeners
=
0
;
void
UseEntryScriptProfiling
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
+
+
gRunToCompletionListeners
;
}
void
UnuseEntryScriptProfiling
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
gRunToCompletionListeners
>
0
)
;
-
-
gRunToCompletionListeners
;
}
void
InitScriptSettings
(
)
{
bool
success
=
sScriptSettingsTLS
.
init
(
)
;
if
(
!
success
)
{
MOZ_CRASH
(
)
;
}
sScriptSettingsTLS
.
set
(
nullptr
)
;
sScriptSettingsTLSInitialized
=
true
;
}
void
DestroyScriptSettings
(
)
{
MOZ_ASSERT
(
sScriptSettingsTLS
.
get
(
)
=
=
nullptr
)
;
}
bool
ScriptSettingsInitialized
(
)
{
return
sScriptSettingsTLSInitialized
;
}
ScriptSettingsStackEntry
:
:
ScriptSettingsStackEntry
(
nsIGlobalObject
*
aGlobal
bool
aCandidate
)
:
mGlobalObject
(
aGlobal
)
mIsCandidateEntryPoint
(
aCandidate
)
mOlder
(
nullptr
)
{
MOZ_ASSERT
(
mGlobalObject
)
;
MOZ_ASSERT
(
mGlobalObject
-
>
GetGlobalJSObject
(
)
"
Must
have
an
actual
JS
global
for
the
duration
on
the
stack
"
)
;
MOZ_ASSERT
(
JS_IsGlobalObject
(
mGlobalObject
-
>
GetGlobalJSObject
(
)
)
"
No
outer
windows
allowed
"
)
;
ScriptSettingsStack
:
:
Push
(
this
)
;
}
ScriptSettingsStackEntry
:
:
ScriptSettingsStackEntry
(
)
:
mGlobalObject
(
nullptr
)
mIsCandidateEntryPoint
(
true
)
mOlder
(
nullptr
)
{
ScriptSettingsStack
:
:
Push
(
this
)
;
}
ScriptSettingsStackEntry
:
:
~
ScriptSettingsStackEntry
(
)
{
MOZ_ASSERT_IF
(
mGlobalObject
mGlobalObject
-
>
GetGlobalJSObject
(
)
)
;
ScriptSettingsStack
:
:
Pop
(
this
)
;
}
static
nsIGlobalObject
*
ClampToSubject
(
nsIGlobalObject
*
aGlobalOrNull
)
{
if
(
!
aGlobalOrNull
|
|
!
NS_IsMainThread
(
)
)
{
return
aGlobalOrNull
;
}
nsIPrincipal
*
globalPrin
=
aGlobalOrNull
-
>
PrincipalOrNull
(
)
;
NS_ENSURE_TRUE
(
globalPrin
GetCurrentGlobal
(
)
)
;
if
(
!
nsContentUtils
:
:
SubjectPrincipalOrSystemIfNativeCaller
(
)
-
>
SubsumesConsideringDomain
(
globalPrin
)
)
{
return
GetCurrentGlobal
(
)
;
}
return
aGlobalOrNull
;
}
nsIGlobalObject
*
GetEntryGlobal
(
)
{
return
ClampToSubject
(
ScriptSettingsStack
:
:
EntryGlobal
(
)
)
;
}
nsIDocument
*
GetEntryDocument
(
)
{
nsIGlobalObject
*
global
=
GetEntryGlobal
(
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
entryWin
=
do_QueryInterface
(
global
)
;
if
(
!
entryWin
&
&
global
)
{
if
(
auto
*
win
=
xpc
:
:
AddonWindowOrNull
(
global
-
>
GetGlobalJSObject
(
)
)
)
{
entryWin
=
win
-
>
AsInner
(
)
;
}
}
return
entryWin
?
entryWin
-
>
GetExtantDoc
(
)
:
nullptr
;
}
nsIGlobalObject
*
GetIncumbentGlobal
(
)
{
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContextForThread
(
)
;
if
(
!
cx
)
{
MOZ_ASSERT
(
ScriptSettingsStack
:
:
EntryGlobal
(
)
=
=
nullptr
)
;
return
nullptr
;
}
if
(
JSObject
*
global
=
JS
:
:
GetScriptedCallerGlobal
(
cx
)
)
{
return
ClampToSubject
(
xpc
:
:
NativeGlobal
(
global
)
)
;
}
return
ClampToSubject
(
ScriptSettingsStack
:
:
IncumbentGlobal
(
)
)
;
}
nsIGlobalObject
*
GetCurrentGlobal
(
)
{
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContextForThread
(
)
;
if
(
!
cx
)
{
return
nullptr
;
}
JSObject
*
global
=
JS
:
:
CurrentGlobalOrNull
(
cx
)
;
if
(
!
global
)
{
return
nullptr
;
}
return
xpc
:
:
NativeGlobal
(
global
)
;
}
nsIPrincipal
*
GetWebIDLCallerPrincipal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ScriptSettingsStackEntry
*
entry
=
ScriptSettingsStack
:
:
EntryPoint
(
)
;
if
(
!
entry
|
|
entry
-
>
NoJSAPI
(
)
)
{
return
nullptr
;
}
AutoEntryScript
*
aes
=
static_cast
<
AutoEntryScript
*
>
(
entry
)
;
if
(
!
aes
-
>
CxPusherIsStackTop
(
)
)
{
return
nullptr
;
}
return
aes
-
>
mWebIDLCallerPrincipal
;
}
static
JSContext
*
FindJSContext
(
nsIGlobalObject
*
aGlobalObject
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
JSContext
*
cx
=
nullptr
;
nsCOMPtr
<
nsIScriptGlobalObject
>
sgo
=
do_QueryInterface
(
aGlobalObject
)
;
if
(
sgo
&
&
sgo
-
>
GetScriptContext
(
)
)
{
cx
=
sgo
-
>
GetScriptContext
(
)
-
>
GetNativeContext
(
)
;
}
if
(
!
cx
)
{
cx
=
nsContentUtils
:
:
GetSafeJSContext
(
)
;
}
return
cx
;
}
AutoJSAPI
:
:
AutoJSAPI
(
)
:
mCx
(
nullptr
)
mOldAutoJSAPIOwnsErrorReporting
(
false
)
mIsMainThread
(
false
)
{
}
AutoJSAPI
:
:
~
AutoJSAPI
(
)
{
if
(
!
mCx
)
{
return
;
}
ReportException
(
)
;
JS
:
:
ContextOptionsRef
(
cx
(
)
)
.
setAutoJSAPIOwnsErrorReporting
(
mOldAutoJSAPIOwnsErrorReporting
)
;
if
(
mOldErrorReporter
.
isSome
(
)
)
{
JS_SetErrorReporter
(
JS_GetRuntime
(
cx
(
)
)
mOldErrorReporter
.
value
(
)
)
;
}
}
void
WarningOnlyErrorReporter
(
JSContext
*
aCx
const
char
*
aMessage
JSErrorReport
*
aRep
)
;
void
AutoJSAPI
:
:
InitInternal
(
JSObject
*
aGlobal
JSContext
*
aCx
bool
aIsMainThread
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aIsMainThread
=
=
NS_IsMainThread
(
)
)
;
#
ifdef
DEBUG
bool
haveException
=
JS_IsExceptionPending
(
aCx
)
;
#
endif
mCx
=
aCx
;
mIsMainThread
=
aIsMainThread
;
if
(
aIsMainThread
)
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
JS_GetRuntime
(
aCx
)
aGlobal
)
;
mCxPusher
.
emplace
(
mCx
)
;
mAutoNullableCompartment
.
emplace
(
mCx
global
)
;
}
else
{
mAutoNullableCompartment
.
emplace
(
mCx
aGlobal
)
;
}
JSRuntime
*
rt
=
JS_GetRuntime
(
aCx
)
;
mOldErrorReporter
.
emplace
(
JS_GetErrorReporter
(
rt
)
)
;
mOldAutoJSAPIOwnsErrorReporting
=
JS
:
:
ContextOptionsRef
(
aCx
)
.
autoJSAPIOwnsErrorReporting
(
)
;
JS
:
:
ContextOptionsRef
(
aCx
)
.
setAutoJSAPIOwnsErrorReporting
(
true
)
;
JS_SetErrorReporter
(
rt
WarningOnlyErrorReporter
)
;
#
ifdef
DEBUG
if
(
haveException
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
JS_GetPendingException
(
aCx
&
exn
)
;
JS_ClearPendingException
(
aCx
)
;
if
(
exn
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
exnObj
(
aCx
&
exn
.
toObject
(
)
)
;
nsAutoJSString
stack
filename
name
message
;
int32_t
line
;
JS
:
:
Rooted
<
JS
:
:
Value
>
tmp
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
exnObj
"
filename
"
&
tmp
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
if
(
tmp
.
isUndefined
(
)
)
{
if
(
!
JS_GetProperty
(
aCx
exnObj
"
fileName
"
&
tmp
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
}
if
(
!
filename
.
init
(
aCx
tmp
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
if
(
!
JS_GetProperty
(
aCx
exnObj
"
stack
"
&
tmp
)
|
|
!
stack
.
init
(
aCx
tmp
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
if
(
!
JS_GetProperty
(
aCx
exnObj
"
name
"
&
tmp
)
|
|
!
name
.
init
(
aCx
tmp
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
if
(
!
JS_GetProperty
(
aCx
exnObj
"
message
"
&
tmp
)
|
|
!
message
.
init
(
aCx
tmp
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
if
(
!
JS_GetProperty
(
aCx
exnObj
"
lineNumber
"
&
tmp
)
|
|
!
JS
:
:
ToInt32
(
aCx
tmp
&
line
)
)
{
JS_ClearPendingException
(
aCx
)
;
line
=
0
;
}
printf_stderr
(
"
PREEXISTING
EXCEPTION
OBJECT
:
'
%
s
:
%
s
'
\
n
%
s
:
%
d
\
n
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
message
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
filename
)
.
get
(
)
line
NS_ConvertUTF16toUTF8
(
stack
)
.
get
(
)
)
;
}
else
{
nsAutoJSString
exnStr
;
if
(
!
exnStr
.
init
(
aCx
exn
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
printf_stderr
(
"
PREEXISTING
EXCEPTION
PRIMITIVE
:
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
exnStr
)
.
get
(
)
)
;
}
MOZ_ASSERT
(
false
"
We
had
an
exception
;
we
should
not
have
"
)
;
}
#
endif
}
AutoJSAPI
:
:
AutoJSAPI
(
nsIGlobalObject
*
aGlobalObject
bool
aIsMainThread
JSContext
*
aCx
)
:
mOldAutoJSAPIOwnsErrorReporting
(
false
)
mIsMainThread
(
aIsMainThread
)
{
MOZ_ASSERT
(
aGlobalObject
)
;
MOZ_ASSERT
(
aGlobalObject
-
>
GetGlobalJSObject
(
)
"
Must
have
a
JS
global
"
)
;
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aIsMainThread
=
=
NS_IsMainThread
(
)
)
;
InitInternal
(
aGlobalObject
-
>
GetGlobalJSObject
(
)
aCx
aIsMainThread
)
;
}
void
AutoJSAPI
:
:
Init
(
)
{
MOZ_ASSERT
(
!
mCx
"
An
AutoJSAPI
should
only
be
initialised
once
"
)
;
InitInternal
(
nullptr
nsContentUtils
:
:
GetDefaultJSContextForThread
(
)
NS_IsMainThread
(
)
)
;
}
bool
AutoJSAPI
:
:
Init
(
nsIGlobalObject
*
aGlobalObject
JSContext
*
aCx
)
{
MOZ_ASSERT
(
!
mCx
"
An
AutoJSAPI
should
only
be
initialised
once
"
)
;
MOZ_ASSERT
(
aCx
)
;
if
(
NS_WARN_IF
(
!
aGlobalObject
)
)
{
return
false
;
}
JSObject
*
global
=
aGlobalObject
-
>
GetGlobalJSObject
(
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
false
;
}
InitInternal
(
global
aCx
NS_IsMainThread
(
)
)
;
return
true
;
}
bool
AutoJSAPI
:
:
Init
(
nsIGlobalObject
*
aGlobalObject
)
{
return
Init
(
aGlobalObject
nsContentUtils
:
:
GetDefaultJSContextForThread
(
)
)
;
}
bool
AutoJSAPI
:
:
Init
(
JSObject
*
aObject
)
{
return
Init
(
xpc
:
:
NativeGlobal
(
aObject
)
)
;
}
bool
AutoJSAPI
:
:
Init
(
nsPIDOMWindowInner
*
aWindow
JSContext
*
aCx
)
{
return
Init
(
nsGlobalWindow
:
:
Cast
(
aWindow
)
aCx
)
;
}
bool
AutoJSAPI
:
:
Init
(
nsPIDOMWindowInner
*
aWindow
)
{
return
Init
(
nsGlobalWindow
:
:
Cast
(
aWindow
)
)
;
}
bool
AutoJSAPI
:
:
Init
(
nsGlobalWindow
*
aWindow
JSContext
*
aCx
)
{
return
Init
(
static_cast
<
nsIGlobalObject
*
>
(
aWindow
)
aCx
)
;
}
bool
AutoJSAPI
:
:
Init
(
nsGlobalWindow
*
aWindow
)
{
return
Init
(
static_cast
<
nsIGlobalObject
*
>
(
aWindow
)
)
;
}
void
WarningOnlyErrorReporter
(
JSContext
*
aCx
const
char
*
aMessage
JSErrorReport
*
aRep
)
{
MOZ_ASSERT
(
JSREPORT_IS_WARNING
(
aRep
-
>
flags
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
workers
:
:
WorkerPrivate
*
worker
=
workers
:
:
GetWorkerPrivateFromContext
(
aCx
)
;
MOZ_ASSERT
(
worker
)
;
worker
-
>
ReportError
(
aCx
aMessage
aRep
)
;
return
;
}
RefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
nsGlobalWindow
*
win
=
xpc
:
:
CurrentWindowOrNull
(
aCx
)
;
if
(
!
win
)
{
win
=
xpc
:
:
AddonWindowOrNull
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
}
xpcReport
-
>
Init
(
aRep
aMessage
nsContentUtils
:
:
IsCallerChrome
(
)
win
?
win
-
>
AsInner
(
)
-
>
WindowID
(
)
:
0
)
;
xpcReport
-
>
LogToConsole
(
)
;
}
void
AutoJSAPI
:
:
ReportException
(
)
{
if
(
!
HasException
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
errorGlobal
(
cx
(
)
JS
:
:
CurrentGlobalOrNull
(
cx
(
)
)
)
;
if
(
!
errorGlobal
)
{
if
(
mIsMainThread
)
{
errorGlobal
=
xpc
:
:
PrivilegedJunkScope
(
)
;
}
else
{
errorGlobal
=
workers
:
:
GetCurrentThreadWorkerGlobal
(
)
;
}
}
JSAutoCompartment
ac
(
cx
(
)
errorGlobal
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
cx
(
)
)
;
js
:
:
ErrorReport
jsReport
(
cx
(
)
)
;
if
(
StealException
(
&
exn
)
&
&
jsReport
.
init
(
cx
(
)
exn
js
:
:
ErrorReport
:
:
WithSideEffects
)
)
{
if
(
mIsMainThread
)
{
RefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
RefPtr
<
nsGlobalWindow
>
win
=
xpc
:
:
WindowGlobalOrNull
(
errorGlobal
)
;
if
(
!
win
)
{
win
=
xpc
:
:
AddonWindowOrNull
(
errorGlobal
)
;
}
nsPIDOMWindowInner
*
inner
=
win
?
win
-
>
AsInner
(
)
:
nullptr
;
xpcReport
-
>
Init
(
jsReport
.
report
(
)
jsReport
.
message
(
)
nsContentUtils
:
:
IsCallerChrome
(
)
inner
?
inner
-
>
WindowID
(
)
:
0
)
;
if
(
inner
&
&
jsReport
.
report
(
)
-
>
errorNumber
!
=
JSMSG_OUT_OF_MEMORY
)
{
DispatchScriptErrorEvent
(
inner
JS_GetRuntime
(
cx
(
)
)
xpcReport
exn
)
;
}
else
{
JS
:
:
Rooted
<
JSObject
*
>
stack
(
cx
(
)
xpc
:
:
FindExceptionStackForConsoleReport
(
inner
exn
)
)
;
xpcReport
-
>
LogToConsoleWithStack
(
stack
)
;
}
}
else
{
workers
:
:
WorkerPrivate
*
worker
=
workers
:
:
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
worker
)
;
MOZ_ASSERT
(
worker
-
>
GetJSContext
(
)
=
=
cx
(
)
)
;
JS_SetPendingException
(
cx
(
)
exn
)
;
worker
-
>
ReportError
(
cx
(
)
jsReport
.
message
(
)
jsReport
.
report
(
)
)
;
ClearException
(
)
;
}
}
else
{
NS_WARNING
(
"
OOMed
while
acquiring
uncaught
exception
from
JSAPI
"
)
;
ClearException
(
)
;
}
}
bool
AutoJSAPI
:
:
PeekException
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
MOZ_ASSERT_IF
(
mIsMainThread
CxPusherIsStackTop
(
)
)
;
MOZ_ASSERT
(
HasException
(
)
)
;
MOZ_ASSERT
(
js
:
:
GetContextCompartment
(
cx
(
)
)
)
;
if
(
!
JS_GetPendingException
(
cx
(
)
aVal
)
)
{
return
false
;
}
return
true
;
}
bool
AutoJSAPI
:
:
StealException
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
if
(
!
PeekException
(
aVal
)
)
{
return
false
;
}
JS_ClearPendingException
(
cx
(
)
)
;
return
true
;
}
AutoEntryScript
:
:
AutoEntryScript
(
nsIGlobalObject
*
aGlobalObject
const
char
*
aReason
bool
aIsMainThread
JSContext
*
aCx
)
:
AutoJSAPI
(
aGlobalObject
aIsMainThread
aCx
?
aCx
:
FindJSContext
(
aGlobalObject
)
)
ScriptSettingsStackEntry
(
aGlobalObject
true
)
mWebIDLCallerPrincipal
(
nullptr
)
{
MOZ_ASSERT
(
aGlobalObject
)
;
MOZ_ASSERT_IF
(
!
aCx
aIsMainThread
)
;
MOZ_ASSERT_IF
(
aCx
&
&
aIsMainThread
aCx
=
=
FindJSContext
(
aGlobalObject
)
)
;
if
(
aIsMainThread
&
&
gRunToCompletionListeners
>
0
)
{
mDocShellEntryMonitor
.
emplace
(
cx
(
)
aReason
)
;
}
}
AutoEntryScript
:
:
AutoEntryScript
(
JSObject
*
aObject
const
char
*
aReason
bool
aIsMainThread
JSContext
*
aCx
)
:
AutoEntryScript
(
xpc
:
:
NativeGlobal
(
aObject
)
aReason
aIsMainThread
aCx
)
{
}
AutoEntryScript
:
:
~
AutoEntryScript
(
)
{
JS_MaybeGC
(
cx
(
)
)
;
}
AutoEntryScript
:
:
DocshellEntryMonitor
:
:
DocshellEntryMonitor
(
JSContext
*
aCx
const
char
*
aReason
)
:
JS
:
:
dbg
:
:
AutoEntryMonitor
(
aCx
)
mReason
(
aReason
)
{
}
void
AutoEntryScript
:
:
DocshellEntryMonitor
:
:
Entry
(
JSContext
*
aCx
JSFunction
*
aFunction
JSScript
*
aScript
JS
:
:
Handle
<
JS
:
:
Value
>
aAsyncStack
const
char
*
aAsyncCause
)
{
JS
:
:
Rooted
<
JSFunction
*
>
rootedFunction
(
aCx
)
;
if
(
aFunction
)
{
rootedFunction
=
aFunction
;
}
JS
:
:
Rooted
<
JSScript
*
>
rootedScript
(
aCx
)
;
if
(
aScript
)
{
rootedScript
=
aScript
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
xpc
:
:
NativeGlobal
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
)
;
if
(
!
window
|
|
!
window
-
>
GetDocShell
(
)
|
|
!
window
-
>
GetDocShell
(
)
-
>
GetRecordProfileTimelineMarkers
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
docShellForJSRunToCompletion
=
window
-
>
GetDocShell
(
)
;
nsString
filename
;
uint32_t
lineNumber
=
0
;
js
:
:
AutoStableStringChars
functionName
(
aCx
)
;
if
(
rootedFunction
)
{
JS
:
:
Rooted
<
JSString
*
>
displayId
(
aCx
JS_GetFunctionDisplayId
(
rootedFunction
)
)
;
if
(
displayId
)
{
if
(
!
functionName
.
initTwoByte
(
aCx
displayId
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
;
}
}
}
if
(
!
rootedScript
)
{
rootedScript
=
JS_GetFunctionScript
(
aCx
rootedFunction
)
;
}
if
(
rootedScript
)
{
filename
=
NS_ConvertUTF8toUTF16
(
JS_GetScriptFilename
(
rootedScript
)
)
;
lineNumber
=
JS_GetScriptBaseLineNumber
(
aCx
rootedScript
)
;
}
if
(
!
filename
.
IsEmpty
(
)
|
|
functionName
.
isTwoByte
(
)
)
{
const
char16_t
*
functionNameChars
=
functionName
.
isTwoByte
(
)
?
functionName
.
twoByteChars
(
)
:
nullptr
;
docShellForJSRunToCompletion
-
>
NotifyJSRunToCompletionStart
(
mReason
functionNameChars
filename
.
BeginReading
(
)
lineNumber
aAsyncStack
aAsyncCause
)
;
}
}
void
AutoEntryScript
:
:
DocshellEntryMonitor
:
:
Exit
(
JSContext
*
aCx
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
xpc
:
:
NativeGlobal
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
)
;
if
(
window
&
&
window
-
>
GetDocShell
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShellForJSRunToCompletion
=
window
-
>
GetDocShell
(
)
;
docShellForJSRunToCompletion
-
>
NotifyJSRunToCompletionStop
(
)
;
}
}
AutoIncumbentScript
:
:
AutoIncumbentScript
(
nsIGlobalObject
*
aGlobalObject
)
:
ScriptSettingsStackEntry
(
aGlobalObject
false
)
mCallerOverride
(
nsContentUtils
:
:
GetCurrentJSContextForThread
(
)
)
{
}
AutoNoJSAPI
:
:
AutoNoJSAPI
(
bool
aIsMainThread
)
:
ScriptSettingsStackEntry
(
)
{
if
(
aIsMainThread
)
{
mCxPusher
.
emplace
(
static_cast
<
JSContext
*
>
(
nullptr
)
true
)
;
}
}
danger
:
:
AutoCxPusher
:
:
AutoCxPusher
(
JSContext
*
cx
bool
allowNull
)
{
MOZ_ASSERT_IF
(
!
allowNull
cx
)
;
if
(
cx
)
mScx
=
GetScriptContextFromJSContext
(
cx
)
;
XPCJSContextStack
*
stack
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetJSContextStack
(
)
;
stack
-
>
Push
(
cx
)
;
mStackDepthAfterPush
=
stack
-
>
Count
(
)
;
#
ifdef
DEBUG
mPushedContext
=
cx
;
mCompartmentDepthOnEntry
=
cx
?
js
:
:
GetEnterCompartmentDepth
(
cx
)
:
0
;
#
endif
if
(
cx
)
{
mAutoRequest
.
emplace
(
cx
)
;
}
}
danger
:
:
AutoCxPusher
:
:
~
AutoCxPusher
(
)
{
mAutoRequest
.
reset
(
)
;
MOZ_ASSERT_IF
(
mPushedContext
mCompartmentDepthOnEntry
=
=
js
:
:
GetEnterCompartmentDepth
(
mPushedContext
)
)
;
DebugOnly
<
JSContext
*
>
stackTop
;
MOZ_ASSERT
(
mPushedContext
=
=
nsXPConnect
:
:
XPConnect
(
)
-
>
GetCurrentJSContext
(
)
)
;
XPCJSRuntime
:
:
Get
(
)
-
>
GetJSContextStack
(
)
-
>
Pop
(
)
;
mScx
=
nullptr
;
}
bool
danger
:
:
AutoCxPusher
:
:
IsStackTop
(
)
const
{
uint32_t
currentDepth
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetJSContextStack
(
)
-
>
Count
(
)
;
MOZ_ASSERT
(
currentDepth
>
=
mStackDepthAfterPush
)
;
return
currentDepth
=
=
mStackDepthAfterPush
;
}
}
AutoJSContext
:
:
AutoJSContext
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL
)
:
mCx
(
nullptr
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
MOZ_ASSERT
(
!
mCx
"
mCx
should
not
be
initialized
!
"
)
;
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
nsXPConnect
*
xpc
=
nsXPConnect
:
:
XPConnect
(
)
;
mCx
=
xpc
-
>
GetCurrentJSContext
(
)
;
if
(
!
mCx
)
{
mJSAPI
.
Init
(
)
;
mCx
=
mJSAPI
.
cx
(
)
;
}
}
AutoJSContext
:
:
operator
JSContext
*
(
)
const
{
return
mCx
;
}
AutoSafeJSContext
:
:
AutoSafeJSContext
(
MOZ_GUARD_OBJECT_NOTIFIER_ONLY_PARAM_IN_IMPL
)
:
AutoJSAPI
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
DebugOnly
<
bool
>
ok
=
Init
(
xpc
:
:
UnprivilegedJunkScope
(
)
)
;
MOZ_ASSERT
(
ok
"
This
is
quite
odd
.
We
should
have
crashed
in
the
"
"
xpc
:
:
NativeGlobal
(
)
call
if
xpc
:
:
UnprivilegedJunkScope
(
)
"
"
returned
null
and
inited
correctly
otherwise
!
"
)
;
}
}
