#
include
"
Nyx
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
namespace
mozilla
:
:
dom
{
void
Nyx
:
:
Log
(
const
GlobalObject
&
const
nsACString
&
aMsg
)
{
MOZ_FUZZING_NYX_PRINTF
(
"
%
s
\
n
"
PromiseFlatCString
(
aMsg
)
.
get
(
)
)
;
}
bool
Nyx
:
:
IsEnabled
(
const
GlobalObject
&
const
nsACString
&
aFuzzerName
)
{
return
fuzzing
:
:
Nyx
:
:
instance
(
)
.
is_enabled
(
PromiseFlatCString
(
aFuzzerName
)
.
get
(
)
)
;
}
bool
Nyx
:
:
IsReplay
(
const
GlobalObject
&
)
{
#
ifdef
FUZZING_SNAPSHOT
return
fuzzing
:
:
Nyx
:
:
instance
(
)
.
is_replay
(
)
;
#
endif
return
false
;
}
bool
Nyx
:
:
IsStarted
(
const
GlobalObject
&
)
{
return
fuzzing
:
:
Nyx
:
:
instance
(
)
.
started
(
)
;
}
void
Nyx
:
:
Start
(
const
GlobalObject
&
)
{
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Performing
snapshot
.
.
.
\
n
"
)
;
fuzzing
:
:
Nyx
:
:
instance
(
)
.
start
(
)
;
}
void
Nyx
:
:
Release
(
const
GlobalObject
&
uint32_t
aIterations
)
{
MOZ_FUZZING_NYX_PRINT
(
"
INFO
:
Performing
snapshot
.
.
.
\
n
"
)
;
fuzzing
:
:
Nyx
:
:
instance
(
)
.
release
(
aIterations
)
;
}
void
Nyx
:
:
GetRawData
(
const
GlobalObject
&
aGlobal
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
ErrorResult
&
aRv
)
{
const
size_t
maxMsgSize
=
4096
;
FallibleTArray
<
uint8_t
>
data
;
if
(
!
data
.
SetLength
(
maxMsgSize
fallible
)
)
{
MOZ_FUZZING_NYX_ABORT
(
"
ERROR
:
Failed
to
initialize
buffer
!
\
n
"
)
;
}
uint32_t
bufsize
=
fuzzing
:
:
Nyx
:
:
instance
(
)
.
get_raw_data
(
data
.
Elements
(
)
data
.
Length
(
)
)
;
if
(
!
data
.
SetLength
(
bufsize
fallible
)
)
{
MOZ_FUZZING_NYX_ABORT
(
"
ERROR
:
Failed
to
resize
buffer
!
\
n
"
)
;
}
if
(
bufsize
=
=
0xFFFFFFFF
)
{
MOZ_FUZZING_NYX_DEBUG
(
"
Nyx
:
Out
of
data
.
\
n
"
)
;
fuzzing
:
:
Nyx
:
:
instance
(
)
.
release
(
0
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
buffer
(
aGlobal
.
Context
(
)
ArrayBuffer
:
:
Create
(
aGlobal
.
Context
(
)
data
aRv
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aRetval
.
set
(
buffer
)
;
}
}
