#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
nsINode
*
RangeUtils
:
:
ComputeRootNode
(
nsINode
*
aNode
)
{
if
(
!
aNode
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
documentTypeNodeName
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
ShadowRoot
*
containingShadow
=
content
-
>
GetContainingShadow
(
)
)
{
return
containingShadow
;
}
if
(
nsINode
*
root
=
content
-
>
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
)
{
return
root
;
}
}
if
(
nsINode
*
root
=
aNode
-
>
GetUncomposedDoc
(
)
)
{
return
root
;
}
NS_ASSERTION
(
!
aNode
-
>
SubtreeRoot
(
)
-
>
IsDocument
(
)
"
GetUncomposedDoc
should
have
returned
a
doc
"
)
;
return
aNode
-
>
SubtreeRoot
(
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
)
{
if
(
NS_WARN_IF
(
!
aStartBoundary
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aEndBoundary
.
IsSetAndValid
(
)
)
)
{
return
false
;
}
if
(
ComputeRootNode
(
aStartBoundary
.
Container
(
)
)
!
=
ComputeRootNode
(
aEndBoundary
.
Container
(
)
)
)
{
return
false
;
}
const
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints
(
aStartBoundary
aEndBoundary
)
;
if
(
!
order
)
{
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
return
*
order
!
=
1
;
}
Maybe
<
bool
>
RangeUtils
:
:
IsNodeContainedInRange
(
nsINode
&
aNode
AbstractRange
*
aAbstractRange
)
{
bool
nodeIsBeforeRange
{
false
}
;
bool
nodeIsAfterRange
{
false
}
;
const
nsresult
rv
=
CompareNodeToRange
(
&
aNode
aAbstractRange
&
nodeIsBeforeRange
&
nodeIsAfterRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Nothing
(
)
;
}
return
Some
(
!
nodeIsBeforeRange
&
&
!
nodeIsAfterRange
)
;
}
nsresult
RangeUtils
:
:
CompareNodeToRange
(
nsINode
*
aNode
AbstractRange
*
aAbstractRange
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
{
if
(
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aAbstractRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
CompareNodeToRangeBoundaries
(
aNode
aAbstractRange
-
>
MayCrossShadowBoundaryStartRef
(
)
aAbstractRange
-
>
MayCrossShadowBoundaryEndRef
(
)
aNodeIsBeforeRange
aNodeIsAfterRange
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
{
MOZ_ASSERT
(
aNodeIsBeforeRange
)
;
MOZ_ASSERT
(
aNodeIsAfterRange
)
;
if
(
NS_WARN_IF
(
!
aNode
)
|
|
NS_WARN_IF
(
!
aStartBoundary
.
IsSet
(
)
|
|
!
aEndBoundary
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
int32_t
nodeStart
;
uint32_t
nodeEnd
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
parent
=
aNode
;
nodeStart
=
0
;
nodeEnd
=
aNode
-
>
GetChildCount
(
)
;
}
else
{
nodeStart
=
parent
-
>
ComputeIndexOf_Deprecated
(
aNode
)
;
NS_WARNING_ASSERTION
(
nodeStart
>
=
0
"
aNode
has
the
parent
node
but
it
does
not
have
aNode
!
"
)
;
nodeEnd
=
nodeStart
+
1u
;
MOZ_ASSERT
(
nodeStart
<
0
|
|
static_cast
<
uint32_t
>
(
nodeStart
)
<
nodeEnd
"
nodeStart
should
be
less
than
nodeEnd
"
)
;
}
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints_AllowNegativeOffsets
(
aStartBoundary
.
Container
(
)
*
aStartBoundary
.
Offset
(
RangeBoundaryBase
<
SPT
SRT
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
parent
nodeStart
)
;
if
(
NS_WARN_IF
(
!
order
)
)
{
return
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
;
}
*
aNodeIsBeforeRange
=
*
order
>
0
;
order
=
nsContentUtils
:
:
ComparePoints
(
aEndBoundary
.
Container
(
)
*
aEndBoundary
.
Offset
(
RangeBoundaryBase
<
EPT
ERT
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
parent
nodeEnd
)
;
if
(
NS_WARN_IF
(
!
order
)
)
{
return
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
;
}
*
aNodeIsAfterRange
=
*
order
<
0
;
return
NS_OK
;
}
nsINode
*
ShadowDOMSelectionHelpers
:
:
GetStartContainer
(
const
AbstractRange
*
aRange
bool
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
)
?
aRange
-
>
GetMayCrossShadowBoundaryStartContainer
(
)
:
aRange
-
>
GetStartContainer
(
)
;
}
uint32_t
ShadowDOMSelectionHelpers
:
:
StartOffset
(
const
AbstractRange
*
aRange
bool
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
)
?
aRange
-
>
MayCrossShadowBoundaryStartOffset
(
)
:
aRange
-
>
StartOffset
(
)
;
}
nsINode
*
ShadowDOMSelectionHelpers
:
:
GetEndContainer
(
const
AbstractRange
*
aRange
bool
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
)
?
aRange
-
>
GetMayCrossShadowBoundaryEndContainer
(
)
:
aRange
-
>
GetEndContainer
(
)
;
}
uint32_t
ShadowDOMSelectionHelpers
:
:
EndOffset
(
const
AbstractRange
*
aRange
bool
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
)
?
aRange
-
>
MayCrossShadowBoundaryEndOffset
(
)
:
aRange
-
>
EndOffset
(
)
;
}
nsINode
*
ShadowDOMSelectionHelpers
:
:
GetParentNode
(
nsINode
&
aNode
bool
aAllowCrossShadowBoundary
)
{
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
)
?
aNode
.
GetParentOrShadowHostNode
(
)
:
aNode
.
GetParentNode
(
)
;
}
ShadowRoot
*
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
const
nsINode
*
aNode
bool
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aNode
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
)
?
aNode
-
>
GetShadowRootForSelection
(
)
:
nullptr
;
}
}
