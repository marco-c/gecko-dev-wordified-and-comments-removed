#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
nsINode
*
RangeUtils
:
:
ComputeRootNode
(
nsINode
*
aNode
)
{
if
(
!
aNode
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
documentTypeNodeName
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
ShadowRoot
*
containingShadow
=
content
-
>
GetContainingShadow
(
)
)
{
return
containingShadow
;
}
if
(
nsINode
*
root
=
content
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
{
return
root
;
}
}
if
(
nsINode
*
root
=
aNode
-
>
GetUncomposedDoc
(
)
)
{
return
root
;
}
NS_ASSERTION
(
!
aNode
-
>
SubtreeRoot
(
)
-
>
IsDocument
(
)
"
GetUncomposedDoc
should
have
returned
a
doc
"
)
;
return
aNode
-
>
SubtreeRoot
(
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
)
{
if
(
NS_WARN_IF
(
!
aStartBoundary
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aEndBoundary
.
IsSetAndValid
(
)
)
)
{
return
false
;
}
if
(
ComputeRootNode
(
aStartBoundary
.
Container
(
)
)
!
=
ComputeRootNode
(
aEndBoundary
.
Container
(
)
)
)
{
return
false
;
}
bool
disconnected
=
false
;
int32_t
order
=
nsContentUtils
:
:
ComparePoints
(
aStartBoundary
aEndBoundary
&
disconnected
)
;
if
(
NS_WARN_IF
(
disconnected
)
)
{
return
false
;
}
return
order
!
=
1
;
}
nsresult
RangeUtils
:
:
CompareNodeToRange
(
nsINode
*
aNode
AbstractRange
*
aAbstractRange
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
{
MOZ_ASSERT
(
aNodeIsBeforeRange
)
;
MOZ_ASSERT
(
aNodeIsAfterRange
)
;
if
(
NS_WARN_IF
(
!
aNode
)
|
|
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aAbstractRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
int32_t
nodeStart
nodeEnd
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
parent
=
aNode
;
nodeStart
=
0
;
uint32_t
childCount
=
aNode
-
>
GetChildCount
(
)
;
MOZ_ASSERT
(
childCount
<
=
INT32_MAX
"
There
shouldn
'
t
be
over
INT32_MAX
children
"
)
;
nodeEnd
=
static_cast
<
int32_t
>
(
childCount
)
;
}
else
{
nodeStart
=
parent
-
>
ComputeIndexOf
(
aNode
)
;
nodeEnd
=
nodeStart
+
1
;
MOZ_ASSERT
(
nodeStart
<
nodeEnd
"
nodeStart
shouldn
'
t
be
INT32_MAX
"
)
;
}
bool
disconnected
=
false
;
*
aNodeIsBeforeRange
=
nsContentUtils
:
:
ComparePoints
(
aAbstractRange
-
>
StartRef
(
)
.
Container
(
)
*
aAbstractRange
-
>
StartRef
(
)
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
parent
nodeStart
&
disconnected
)
>
0
;
if
(
NS_WARN_IF
(
disconnected
)
)
{
return
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
;
}
*
aNodeIsAfterRange
=
nsContentUtils
:
:
ComparePoints
(
aAbstractRange
-
>
EndRef
(
)
.
Container
(
)
*
aAbstractRange
-
>
EndRef
(
)
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
parent
nodeEnd
&
disconnected
)
<
0
;
if
(
NS_WARN_IF
(
disconnected
)
)
{
return
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
;
}
return
NS_OK
;
}
}
