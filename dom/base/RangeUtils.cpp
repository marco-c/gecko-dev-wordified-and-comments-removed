#
include
"
RangeUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
AbstractRange
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFrameSelection
.
h
"
namespace
mozilla
{
using
namespace
dom
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
bool
RangeUtils
:
:
IsValidPoints
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
ShadowIncludingDOM
>
(
nsINode
*
aNode
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
Flat
>
(
nsINode
*
aNode
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
ShadowIncludingDOM
>
(
nsINode
*
aNode
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
Flat
>
(
nsINode
*
aNode
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
ShadowIncludingDOM
>
(
nsINode
*
aNode
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
Flat
>
(
nsINode
*
aNode
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
ShadowIncludingDOM
>
(
nsINode
*
aNode
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
<
TreeKind
:
:
Flat
>
(
nsINode
*
aNode
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRange
<
TreeKind
:
:
ShadowIncludingDOM
>
(
nsINode
*
aNode
AbstractRange
*
aAbstractRange
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
nsresult
RangeUtils
:
:
CompareNodeToRange
<
TreeKind
:
:
Flat
>
(
nsINode
*
aNode
AbstractRange
*
aAbstractRange
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
Maybe
<
bool
>
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
ShadowIncludingDOM
>
(
nsINode
&
aNode
AbstractRange
*
aAbstractRange
)
;
template
Maybe
<
bool
>
RangeUtils
:
:
IsNodeContainedInRange
<
TreeKind
:
:
Flat
>
(
nsINode
&
aNode
AbstractRange
*
aAbstractRange
)
;
[
[
nodiscard
]
]
static
inline
bool
ParentNodeIsInSameSelection
(
const
nsINode
&
aNode
)
{
if
(
!
aNode
.
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
true
;
}
const
nsFrameSelection
*
frameSelection
=
aNode
.
GetFrameSelection
(
)
;
if
(
!
frameSelection
|
|
frameSelection
-
>
IsIndependentSelection
(
)
)
{
MOZ_ASSERT_IF
(
aNode
.
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
aNode
.
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
-
>
IsTextControlElement
(
)
)
;
return
false
;
}
return
true
;
}
nsINode
*
RangeUtils
:
:
ComputeRootNode
(
nsINode
*
aNode
)
{
if
(
!
aNode
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
documentTypeNodeName
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
ShadowRoot
*
containingShadow
=
content
-
>
GetContainingShadow
(
)
)
{
return
containingShadow
;
}
if
(
nsINode
*
root
=
content
-
>
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
)
{
return
root
;
}
}
if
(
nsINode
*
root
=
aNode
-
>
GetUncomposedDoc
(
)
)
{
return
root
;
}
NS_ASSERTION
(
!
aNode
-
>
SubtreeRoot
(
)
-
>
IsDocument
(
)
"
GetUncomposedDoc
should
have
returned
a
doc
"
)
;
return
aNode
-
>
SubtreeRoot
(
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
bool
RangeUtils
:
:
IsValidPoints
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
)
{
if
(
NS_WARN_IF
(
!
aStartBoundary
.
IsSetAndValid
(
)
)
|
|
NS_WARN_IF
(
!
aEndBoundary
.
IsSetAndValid
(
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
aStartBoundary
.
GetTreeKind
(
)
=
=
aEndBoundary
.
GetTreeKind
(
)
)
;
if
(
ComputeRootNode
(
aStartBoundary
.
GetContainer
(
)
)
!
=
ComputeRootNode
(
aEndBoundary
.
GetContainer
(
)
)
)
{
return
false
;
}
const
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints
(
aStartBoundary
aEndBoundary
)
;
if
(
!
order
)
{
MOZ_ASSERT_UNREACHABLE
(
)
;
return
false
;
}
return
*
order
!
=
1
;
}
template
<
TreeKind
aKind
typename
Dummy
>
Maybe
<
bool
>
RangeUtils
:
:
IsNodeContainedInRange
(
nsINode
&
aNode
AbstractRange
*
aAbstractRange
)
{
bool
nodeIsBeforeRange
{
false
}
;
bool
nodeIsAfterRange
{
false
}
;
const
nsresult
rv
=
CompareNodeToRange
<
aKind
>
(
&
aNode
aAbstractRange
&
nodeIsBeforeRange
&
nodeIsAfterRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Nothing
(
)
;
}
return
Some
(
!
nodeIsBeforeRange
&
&
!
nodeIsAfterRange
)
;
}
template
<
TreeKind
aKind
typename
Dummy
>
nsresult
RangeUtils
:
:
CompareNodeToRange
(
nsINode
*
aNode
AbstractRange
*
aAbstractRange
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
{
if
(
NS_WARN_IF
(
!
aAbstractRange
)
|
|
NS_WARN_IF
(
!
aAbstractRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
CompareNodeToRangeBoundaries
<
aKind
>
(
aNode
aAbstractRange
-
>
MayCrossShadowBoundaryStartRef
(
)
aAbstractRange
-
>
MayCrossShadowBoundaryEndRef
(
)
aNodeIsBeforeRange
aNodeIsAfterRange
)
;
}
template
<
TreeKind
aKind
typename
SPT
typename
SRT
typename
EPT
typename
ERT
typename
Dummy
>
nsresult
RangeUtils
:
:
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
{
MOZ_ASSERT
(
aNodeIsBeforeRange
)
;
MOZ_ASSERT
(
aNodeIsAfterRange
)
;
MOZ_ASSERT
(
aStartBoundary
.
GetTreeKind
(
)
=
=
aEndBoundary
.
GetTreeKind
(
)
)
;
if
(
NS_WARN_IF
(
!
aNode
)
|
|
NS_WARN_IF
(
!
aStartBoundary
.
IsSet
(
)
|
|
!
aEndBoundary
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
int32_t
nodeStart
;
uint32_t
nodeEnd
;
const
nsINode
*
parent
=
nullptr
;
MOZ_ASSERT_IF
(
aKind
=
=
TreeKind
:
:
Flat
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
)
;
if
(
!
aNode
-
>
IsShadowRoot
(
)
)
{
parent
=
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
*
aNode
aKind
=
=
TreeKind
:
:
Flat
?
AllowRangeCrossShadowBoundary
:
:
Yes
:
AllowRangeCrossShadowBoundary
:
:
No
)
;
}
if
(
!
parent
)
{
parent
=
aNode
;
nodeStart
=
0
;
nodeEnd
=
aNode
-
>
GetChildCount
(
)
;
}
else
if
(
const
HTMLSlotElement
*
slotAsParent
=
HTMLSlotElement
:
:
FromNode
(
parent
)
;
slotAsParent
&
&
aKind
=
=
TreeKind
:
:
Flat
)
{
auto
index
=
slotAsParent
-
>
AssignedNodes
(
)
.
IndexOf
(
aNode
)
;
nodeStart
=
index
;
nodeEnd
=
nodeStart
+
1
;
}
else
{
nodeStart
=
parent
-
>
ComputeIndexOf_Deprecated
(
aNode
)
;
NS_WARNING_ASSERTION
(
nodeStart
>
=
0
"
aNode
has
the
parent
node
but
it
does
not
have
aNode
!
"
)
;
nodeEnd
=
nodeStart
+
1u
;
MOZ_ASSERT
(
nodeStart
<
0
|
|
static_cast
<
uint32_t
>
(
nodeStart
)
<
nodeEnd
"
nodeStart
should
be
less
than
nodeEnd
"
)
;
}
Maybe
<
int32_t
>
order
=
nsContentUtils
:
:
ComparePoints_AllowNegativeOffsets
<
aKind
>
(
aStartBoundary
.
GetContainer
(
)
*
aStartBoundary
.
Offset
(
RangeBoundaryBase
<
SPT
SRT
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
parent
nodeStart
)
;
if
(
NS_WARN_IF
(
!
order
)
)
{
return
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
;
}
*
aNodeIsBeforeRange
=
*
order
>
0
;
order
=
nsContentUtils
:
:
ComparePointsWithIndices
<
aKind
>
(
aEndBoundary
.
GetContainer
(
)
*
aEndBoundary
.
Offset
(
RangeBoundaryBase
<
EPT
ERT
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
parent
nodeEnd
)
;
if
(
NS_WARN_IF
(
!
order
)
)
{
return
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
;
}
*
aNodeIsAfterRange
=
*
order
<
0
;
return
NS_OK
;
}
nsINode
*
ShadowDOMSelectionHelpers
:
:
GetStartContainer
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
?
aRange
-
>
GetMayCrossShadowBoundaryStartContainer
(
)
:
aRange
-
>
GetStartContainer
(
)
;
}
uint32_t
ShadowDOMSelectionHelpers
:
:
StartOffset
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
?
aRange
-
>
MayCrossShadowBoundaryStartOffset
(
)
:
aRange
-
>
StartOffset
(
)
;
}
nsINode
*
ShadowDOMSelectionHelpers
:
:
GetEndContainer
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
?
aRange
-
>
GetMayCrossShadowBoundaryEndContainer
(
)
:
aRange
-
>
GetEndContainer
(
)
;
}
uint32_t
ShadowDOMSelectionHelpers
:
:
EndOffset
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aRange
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
?
aRange
-
>
MayCrossShadowBoundaryEndOffset
(
)
:
aRange
-
>
EndOffset
(
)
;
}
nsINode
*
ShadowDOMSelectionHelpers
:
:
GetParentNodeInSameSelection
(
const
nsINode
&
aNode
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
if
(
!
ParentNodeIsInSameSelection
(
aNode
)
)
{
return
nullptr
;
}
if
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
{
if
(
aNode
.
IsContent
(
)
)
{
if
(
HTMLSlotElement
*
slot
=
aNode
.
AsContent
(
)
-
>
GetAssignedSlot
(
)
;
slot
&
&
GetShadowRoot
(
slot
-
>
GetContainingShadowHost
(
)
aAllowCrossShadowBoundary
)
)
{
return
slot
;
}
}
return
aNode
.
GetParentOrShadowHostNode
(
)
;
}
return
aNode
.
GetParentNode
(
)
;
}
ShadowRoot
*
ShadowDOMSelectionHelpers
:
:
GetShadowRoot
(
const
nsINode
*
aNode
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
{
MOZ_ASSERT
(
aNode
)
;
return
(
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
&
&
aAllowCrossShadowBoundary
=
=
AllowRangeCrossShadowBoundary
:
:
Yes
)
?
aNode
-
>
GetShadowRootForSelection
(
)
:
nullptr
;
}
}
