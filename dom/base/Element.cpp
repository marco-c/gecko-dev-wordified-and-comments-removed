#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_full_screen_api
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
Flex
.
h
"
#
include
"
mozilla
/
dom
/
Grid
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsDOMCSSAttrDeclaration
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
mozilla
/
dom
/
AnimatableBinding
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDivElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLParagraphElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLPreElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSpanElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTableCellElement
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeAnimationOptionsBinding
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
AnimationComparator
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
FullscreenChange
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
SizeOfState
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULElement
.
h
"
#
endif
#
include
"
SVGElement
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
ifdef
DEBUG
#
include
"
nsRange
.
h
"
#
endif
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
NodeListBinding
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
dom
/
CSSPseudoElement
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplay
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDOMStringMap
.
h
"
#
include
"
DOMIntersectionObserver
.
h
"
#
include
"
nsIDOMXULButtonElement
.
h
"
#
include
"
nsIDOMXULContainerElement
.
h
"
#
include
"
nsIDOMXULControlElement
.
h
"
#
include
"
nsIDOMXULMenuListElement
.
h
"
#
include
"
nsIDOMXULMultSelectCntrlEl
.
h
"
#
include
"
nsIDOMXULRadioGroupElement
.
h
"
#
include
"
nsIDOMXULRelatedElement
.
h
"
#
include
"
nsIDOMXULMultSelectCntrlEl
.
h
"
#
include
"
nsIDOMXULSelectCntrlEl
.
h
"
#
include
"
nsIDOMXULSelectCntrlItemEl
.
h
"
#
include
"
nsIBrowser
.
h
"
#
include
"
nsIAutoCompletePopup
.
h
"
#
include
"
nsISpeculativeConnect
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
DOMMatrix
.
h
"
#
if
defined
(
ACCESSIBILITY
)
&
&
defined
(
DEBUG
)
#
include
"
nsAccessibilityService
.
h
"
#
endif
using
mozilla
:
:
gfx
:
:
Matrix4x4
;
namespace
mozilla
{
namespace
dom
{
#
ifdef
MOZ_THREAD_SAFETY_OWNERSHIP_CHECKS_SUPPORTED
#
define
EXTRA_DOM_NODE_BYTES
8
#
else
#
define
EXTRA_DOM_NODE_BYTES
0
#
endif
#
define
ASSERT_NODE_SIZE
(
type
opt_size_64
opt_size_32
)
\
template
<
int
a
int
sizeOn64
int
sizeOn32
>
\
struct
Check
#
#
type
#
#
Size
{
\
static_assert
(
(
sizeof
(
void
*
)
=
=
8
&
&
a
=
=
sizeOn64
)
|
|
\
(
sizeof
(
void
*
)
=
=
4
&
&
a
<
=
sizeOn32
)
\
"
DOM
size
changed
"
)
;
\
}
;
\
Check
#
#
type
#
#
Size
<
sizeof
(
type
)
opt_size_64
+
EXTRA_DOM_NODE_BYTES
\
opt_size_32
+
EXTRA_DOM_NODE_BYTES
>
\
g
#
#
type
#
#
CES
;
ASSERT_NODE_SIZE
(
Element
128
80
)
;
ASSERT_NODE_SIZE
(
HTMLDivElement
128
80
)
;
ASSERT_NODE_SIZE
(
HTMLParagraphElement
128
80
)
;
ASSERT_NODE_SIZE
(
HTMLPreElement
128
80
)
;
ASSERT_NODE_SIZE
(
HTMLSpanElement
128
80
)
;
ASSERT_NODE_SIZE
(
HTMLTableCellElement
128
80
)
;
ASSERT_NODE_SIZE
(
Text
120
64
)
;
#
undef
ASSERT_NODE_SIZE
#
undef
EXTRA_DOM_NODE_BYTES
}
}
nsAtom
*
nsIContent
:
:
DoGetID
(
)
const
{
MOZ_ASSERT
(
HasID
(
)
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
IsElement
(
)
"
Only
elements
can
have
IDs
"
)
;
return
AsElement
(
)
-
>
GetParsedAttr
(
nsGkAtoms
:
:
id
)
-
>
GetAtomValue
(
)
;
}
nsIFrame
*
nsIContent
:
:
GetPrimaryFrame
(
mozilla
:
:
FlushType
aType
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
if
(
aType
!
=
mozilla
:
:
FlushType
:
:
None
)
{
doc
-
>
FlushPendingNotifications
(
aType
)
;
}
return
GetPrimaryFrame
(
)
;
}
namespace
mozilla
{
namespace
dom
{
const
nsAttrValue
*
Element
:
:
GetSVGAnimatedClass
(
)
const
{
MOZ_ASSERT
(
MayHaveClass
(
)
&
&
IsSVGElement
(
)
"
Unexpected
call
"
)
;
return
static_cast
<
const
SVGElement
*
>
(
this
)
-
>
GetAnimatedClassName
(
)
;
}
NS_IMETHODIMP
Element
:
:
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
Element
)
)
)
{
NS_ADDREF_THIS
(
)
;
*
aInstancePtr
=
this
;
return
NS_OK
;
}
NS_ASSERTION
(
aInstancePtr
"
QueryInterface
requires
a
non
-
NULL
destination
!
"
)
;
nsresult
rv
=
FragmentOrElement
:
:
QueryInterface
(
aIID
aInstancePtr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
NS_OK
;
}
return
NS_NOINTERFACE
;
}
EventStates
Element
:
:
IntrinsicState
(
)
const
{
return
IsEditable
(
)
?
NS_EVENT_STATE_MOZ_READWRITE
:
NS_EVENT_STATE_MOZ_READONLY
;
}
void
Element
:
:
NotifyStateChange
(
EventStates
aStates
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
nsAutoScriptBlocker
scriptBlocker
;
doc
-
>
ContentStateChanged
(
this
aStates
)
;
}
}
void
Element
:
:
UpdateLinkState
(
EventStates
aState
)
{
MOZ_ASSERT
(
!
aState
.
HasAtLeastOneOfStates
(
~
(
NS_EVENT_STATE_VISITED
|
NS_EVENT_STATE_UNVISITED
)
)
"
Unexpected
link
state
bits
"
)
;
mState
=
(
mState
&
~
(
NS_EVENT_STATE_VISITED
|
NS_EVENT_STATE_UNVISITED
)
)
|
aState
;
}
void
Element
:
:
UpdateState
(
bool
aNotify
)
{
EventStates
oldState
=
mState
;
mState
=
IntrinsicState
(
)
|
(
oldState
&
EXTERNALLY_MANAGED_STATES
)
;
if
(
aNotify
)
{
EventStates
changedStates
=
oldState
^
mState
;
if
(
!
changedStates
.
IsEmpty
(
)
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
nsAutoScriptBlocker
scriptBlocker
;
doc
-
>
ContentStateChanged
(
this
changedStates
)
;
}
}
}
}
}
}
void
nsIContent
:
:
UpdateEditableState
(
bool
aNotify
)
{
nsIContent
*
parent
=
GetParent
(
)
;
SetEditableFlag
(
parent
&
&
parent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
!
IsRootOfNativeAnonymousSubtree
(
)
)
;
}
namespace
mozilla
{
namespace
dom
{
void
Element
:
:
UpdateEditableState
(
bool
aNotify
)
{
nsIContent
:
:
UpdateEditableState
(
aNotify
)
;
if
(
aNotify
)
{
UpdateState
(
aNotify
)
;
}
else
{
if
(
IsEditable
(
)
)
{
RemoveStatesSilently
(
NS_EVENT_STATE_MOZ_READONLY
)
;
AddStatesSilently
(
NS_EVENT_STATE_MOZ_READWRITE
)
;
}
else
{
RemoveStatesSilently
(
NS_EVENT_STATE_MOZ_READWRITE
)
;
AddStatesSilently
(
NS_EVENT_STATE_MOZ_READONLY
)
;
}
}
}
int32_t
Element
:
:
TabIndex
(
)
{
const
nsAttrValue
*
attrVal
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
tabindex
)
;
if
(
attrVal
&
&
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
return
attrVal
-
>
GetIntegerValue
(
)
;
}
return
TabIndexDefault
(
)
;
}
void
Element
:
:
Focus
(
const
FocusOptions
&
aOptions
ErrorResult
&
aError
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
if
(
fm
-
>
CanSkipFocus
(
this
)
)
{
fm
-
>
NeedsFlushBeforeEventHandling
(
this
)
;
}
else
{
aError
=
fm
-
>
SetFocus
(
this
nsIFocusManager
:
:
FLAG_BYELEMENTFOCUS
|
nsFocusManager
:
:
FocusOptionsToFocusManagerFlags
(
aOptions
)
)
;
}
}
}
void
Element
:
:
SetTabIndex
(
int32_t
aTabIndex
mozilla
:
:
ErrorResult
&
aError
)
{
nsAutoString
value
;
value
.
AppendInt
(
aTabIndex
)
;
SetAttr
(
nsGkAtoms
:
:
tabindex
value
aError
)
;
}
void
Element
:
:
SetShadowRoot
(
ShadowRoot
*
aShadowRoot
)
{
nsExtendedDOMSlots
*
slots
=
ExtendedDOMSlots
(
)
;
slots
-
>
mShadowRoot
=
aShadowRoot
;
}
void
Element
:
:
Blur
(
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
!
ShouldBlur
(
this
)
)
{
return
;
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
win
&
&
fm
)
{
aError
=
fm
-
>
ClearFocus
(
win
)
;
}
}
EventStates
Element
:
:
StyleStateFromLocks
(
)
const
{
StyleStateLocks
locksAndValues
=
LockedStyleStates
(
)
;
EventStates
locks
=
locksAndValues
.
mLocks
;
EventStates
values
=
locksAndValues
.
mValues
;
EventStates
state
=
(
mState
&
~
locks
)
|
(
locks
&
values
)
;
if
(
state
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
return
state
&
~
NS_EVENT_STATE_UNVISITED
;
}
if
(
state
.
HasState
(
NS_EVENT_STATE_UNVISITED
)
)
{
return
state
&
~
NS_EVENT_STATE_VISITED
;
}
return
state
;
}
Element
:
:
StyleStateLocks
Element
:
:
LockedStyleStates
(
)
const
{
StyleStateLocks
*
locks
=
static_cast
<
StyleStateLocks
*
>
(
GetProperty
(
nsGkAtoms
:
:
lockedStyleStates
)
)
;
if
(
locks
)
{
return
*
locks
;
}
return
StyleStateLocks
(
)
;
}
void
Element
:
:
NotifyStyleStateChange
(
EventStates
aStates
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
RefPtr
<
PresShell
>
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
nsAutoScriptBlocker
scriptBlocker
;
presShell
-
>
ContentStateChanged
(
doc
this
aStates
)
;
}
}
}
void
Element
:
:
LockStyleStates
(
EventStates
aStates
bool
aEnabled
)
{
StyleStateLocks
*
locks
=
new
StyleStateLocks
(
LockedStyleStates
(
)
)
;
locks
-
>
mLocks
|
=
aStates
;
if
(
aEnabled
)
{
locks
-
>
mValues
|
=
aStates
;
}
else
{
locks
-
>
mValues
&
=
~
aStates
;
}
if
(
aStates
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
locks
-
>
mLocks
&
=
~
NS_EVENT_STATE_UNVISITED
;
}
if
(
aStates
.
HasState
(
NS_EVENT_STATE_UNVISITED
)
)
{
locks
-
>
mLocks
&
=
~
NS_EVENT_STATE_VISITED
;
}
SetProperty
(
nsGkAtoms
:
:
lockedStyleStates
locks
nsINode
:
:
DeleteProperty
<
StyleStateLocks
>
)
;
SetHasLockedStyleStates
(
)
;
NotifyStyleStateChange
(
aStates
)
;
}
void
Element
:
:
UnlockStyleStates
(
EventStates
aStates
)
{
StyleStateLocks
*
locks
=
new
StyleStateLocks
(
LockedStyleStates
(
)
)
;
locks
-
>
mLocks
&
=
~
aStates
;
if
(
locks
-
>
mLocks
.
IsEmpty
(
)
)
{
DeleteProperty
(
nsGkAtoms
:
:
lockedStyleStates
)
;
ClearHasLockedStyleStates
(
)
;
delete
locks
;
}
else
{
SetProperty
(
nsGkAtoms
:
:
lockedStyleStates
locks
nsINode
:
:
DeleteProperty
<
StyleStateLocks
>
)
;
}
NotifyStyleStateChange
(
aStates
)
;
}
void
Element
:
:
ClearStyleStateLocks
(
)
{
StyleStateLocks
locks
=
LockedStyleStates
(
)
;
DeleteProperty
(
nsGkAtoms
:
:
lockedStyleStates
)
;
ClearHasLockedStyleStates
(
)
;
NotifyStyleStateChange
(
locks
.
mLocks
)
;
}
nsINode
*
Element
:
:
GetScopeChainParent
(
)
const
{
return
OwnerDoc
(
)
;
}
nsDOMTokenList
*
Element
:
:
ClassList
(
)
{
Element
:
:
nsDOMSlots
*
slots
=
DOMSlots
(
)
;
if
(
!
slots
-
>
mClassList
)
{
slots
-
>
mClassList
=
new
nsDOMTokenList
(
this
nsGkAtoms
:
:
_class
)
;
}
return
slots
-
>
mClassList
;
}
nsDOMTokenList
*
Element
:
:
Part
(
)
{
Element
:
:
nsDOMSlots
*
slots
=
DOMSlots
(
)
;
if
(
!
slots
-
>
mPart
)
{
slots
-
>
mPart
=
new
nsDOMTokenList
(
this
nsGkAtoms
:
:
part
)
;
}
return
slots
-
>
mPart
;
}
void
Element
:
:
GetAttributeNames
(
nsTArray
<
nsString
>
&
aResult
)
{
uint32_t
count
=
mAttrs
.
AttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mAttrs
.
AttrNameAt
(
i
)
;
name
-
>
GetQualifiedName
(
*
aResult
.
AppendElement
(
)
)
;
}
}
already_AddRefed
<
nsIHTMLCollection
>
Element
:
:
GetElementsByTagName
(
const
nsAString
&
aLocalName
)
{
return
NS_GetContentList
(
this
kNameSpaceID_Unknown
aLocalName
)
;
}
nsIScrollableFrame
*
Element
:
:
GetScrollFrame
(
nsIFrame
*
*
aFrame
FlushType
aFlushType
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
aFlushType
)
;
if
(
aFrame
)
{
*
aFrame
=
frame
;
}
if
(
frame
)
{
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
return
nullptr
;
}
LayoutFrameType
type
=
frame
-
>
Type
(
)
;
if
(
type
!
=
LayoutFrameType
:
:
Menu
&
&
type
!
=
LayoutFrameType
:
:
ComboboxControl
)
{
nsIScrollableFrame
*
scrollFrame
=
frame
-
>
GetScrollTargetFrame
(
)
;
if
(
scrollFrame
)
{
MOZ_ASSERT
(
!
OwnerDoc
(
)
-
>
IsScrollingElement
(
this
)
"
How
can
we
have
a
scrollframe
if
we
'
re
the
"
"
scrollingElement
for
our
document
?
"
)
;
return
scrollFrame
;
}
}
}
Document
*
doc
=
OwnerDoc
(
)
;
bool
isScrollingElement
=
OwnerDoc
(
)
-
>
IsScrollingElement
(
this
)
;
if
(
aFrame
)
{
*
aFrame
=
GetPrimaryFrame
(
FlushType
:
:
None
)
;
}
if
(
isScrollingElement
)
{
if
(
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
)
{
return
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
}
return
nullptr
;
}
void
Element
:
:
ScrollIntoView
(
const
BooleanOrScrollIntoViewOptions
&
aObject
)
{
if
(
aObject
.
IsScrollIntoViewOptions
(
)
)
{
return
ScrollIntoView
(
aObject
.
GetAsScrollIntoViewOptions
(
)
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aObject
.
IsBoolean
(
)
)
;
ScrollIntoViewOptions
options
;
if
(
aObject
.
GetAsBoolean
(
)
)
{
options
.
mBlock
=
ScrollLogicalPosition
:
:
Start
;
options
.
mInline
=
ScrollLogicalPosition
:
:
Nearest
;
}
else
{
options
.
mBlock
=
ScrollLogicalPosition
:
:
End
;
options
.
mInline
=
ScrollLogicalPosition
:
:
Nearest
;
}
return
ScrollIntoView
(
options
)
;
}
void
Element
:
:
ScrollIntoView
(
const
ScrollIntoViewOptions
&
aOptions
)
{
Document
*
document
=
GetComposedDoc
(
)
;
if
(
!
document
)
{
return
;
}
RefPtr
<
PresShell
>
presShell
=
document
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
WhereToScroll
whereToScrollVertically
=
kScrollToCenter
;
switch
(
aOptions
.
mBlock
)
{
case
ScrollLogicalPosition
:
:
Start
:
whereToScrollVertically
=
kScrollToTop
;
break
;
case
ScrollLogicalPosition
:
:
Center
:
whereToScrollVertically
=
kScrollToCenter
;
break
;
case
ScrollLogicalPosition
:
:
End
:
whereToScrollVertically
=
kScrollToBottom
;
break
;
case
ScrollLogicalPosition
:
:
Nearest
:
whereToScrollVertically
=
kScrollMinimum
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
ScrollLogicalPosition
value
"
)
;
}
WhereToScroll
whereToScrollHorizontally
=
kScrollToCenter
;
switch
(
aOptions
.
mInline
)
{
case
ScrollLogicalPosition
:
:
Start
:
whereToScrollHorizontally
=
kScrollToLeft
;
break
;
case
ScrollLogicalPosition
:
:
Center
:
whereToScrollHorizontally
=
kScrollToCenter
;
break
;
case
ScrollLogicalPosition
:
:
End
:
whereToScrollHorizontally
=
kScrollToRight
;
break
;
case
ScrollLogicalPosition
:
:
Nearest
:
whereToScrollHorizontally
=
kScrollMinimum
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
ScrollLogicalPosition
value
"
)
;
}
ScrollFlags
scrollFlags
=
ScrollFlags
:
:
ScrollOverflowHidden
|
ScrollFlags
:
:
ScrollSnap
;
if
(
aOptions
.
mBehavior
=
=
ScrollBehavior
:
:
Smooth
)
{
scrollFlags
|
=
ScrollFlags
:
:
ScrollSmooth
;
}
else
if
(
aOptions
.
mBehavior
=
=
ScrollBehavior
:
:
Auto
)
{
scrollFlags
|
=
ScrollFlags
:
:
ScrollSmoothAuto
;
}
presShell
-
>
ScrollContentIntoView
(
this
ScrollAxis
(
whereToScrollVertically
WhenToScroll
:
:
Always
)
ScrollAxis
(
whereToScrollHorizontally
WhenToScroll
:
:
Always
)
scrollFlags
)
;
}
void
Element
:
:
Scroll
(
const
CSSIntPoint
&
aScroll
const
ScrollOptions
&
aOptions
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
aOptions
.
mBehavior
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollToCSSPixels
(
aScroll
scrollMode
)
;
}
}
void
Element
:
:
Scroll
(
double
aXScroll
double
aYScroll
)
{
auto
scrollPos
=
CSSIntPoint
:
:
Truncate
(
mozilla
:
:
ToZeroIfNonfinite
(
aXScroll
)
mozilla
:
:
ToZeroIfNonfinite
(
aYScroll
)
)
;
Scroll
(
scrollPos
ScrollOptions
(
)
)
;
}
void
Element
:
:
Scroll
(
const
ScrollToOptions
&
aOptions
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
CSSIntPoint
scrollPos
=
sf
-
>
GetScrollPositionCSSPixels
(
)
;
if
(
aOptions
.
mLeft
.
WasPassed
(
)
)
{
scrollPos
.
x
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mLeft
.
Value
(
)
)
;
}
if
(
aOptions
.
mTop
.
WasPassed
(
)
)
{
scrollPos
.
y
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mTop
.
Value
(
)
)
;
}
Scroll
(
scrollPos
aOptions
)
;
}
}
void
Element
:
:
ScrollTo
(
double
aXScroll
double
aYScroll
)
{
Scroll
(
aXScroll
aYScroll
)
;
}
void
Element
:
:
ScrollTo
(
const
ScrollToOptions
&
aOptions
)
{
Scroll
(
aOptions
)
;
}
void
Element
:
:
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
ScrollToOptions
options
;
options
.
mLeft
.
Construct
(
aXScrollDif
)
;
options
.
mTop
.
Construct
(
aYScrollDif
)
;
ScrollBy
(
options
)
;
}
}
void
Element
:
:
ScrollBy
(
const
ScrollToOptions
&
aOptions
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
CSSIntPoint
scrollDelta
;
if
(
aOptions
.
mLeft
.
WasPassed
(
)
)
{
scrollDelta
.
x
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mLeft
.
Value
(
)
)
;
}
if
(
aOptions
.
mTop
.
WasPassed
(
)
)
{
scrollDelta
.
y
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mTop
.
Value
(
)
)
;
}
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
aOptions
.
mBehavior
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollByCSSPixels
(
scrollDelta
scrollMode
nsGkAtoms
:
:
relative
)
;
}
}
int32_t
Element
:
:
ScrollTop
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
return
sf
?
sf
-
>
GetScrollPositionCSSPixels
(
)
.
y
:
0
;
}
void
Element
:
:
SetScrollTop
(
int32_t
aScrollTop
)
{
FlushType
flushType
=
aScrollTop
=
=
0
?
FlushType
:
:
Frames
:
FlushType
:
:
Layout
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
nullptr
flushType
)
;
if
(
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollToCSSPixels
(
CSSIntPoint
(
sf
-
>
GetScrollPositionCSSPixels
(
)
.
x
aScrollTop
)
scrollMode
)
;
}
}
int32_t
Element
:
:
ScrollLeft
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
return
sf
?
sf
-
>
GetScrollPositionCSSPixels
(
)
.
x
:
0
;
}
void
Element
:
:
SetScrollLeft
(
int32_t
aScrollLeft
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollToCSSPixels
(
CSSIntPoint
(
aScrollLeft
sf
-
>
GetScrollPositionCSSPixels
(
)
.
y
)
scrollMode
)
;
}
}
void
Element
:
:
MozScrollSnap
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
nullptr
FlushType
:
:
None
)
;
if
(
sf
)
{
sf
-
>
ScrollSnap
(
)
;
}
}
static
nsSize
GetScrollRectSizeForOverflowVisibleFrame
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
|
|
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
return
nsSize
(
0
0
)
;
}
nsRect
paddingRect
=
aFrame
-
>
GetPaddingRectRelativeToSelf
(
)
;
nsOverflowAreas
overflowAreas
(
paddingRect
paddingRect
)
;
nsLayoutUtils
:
:
UnionChildOverflow
(
aFrame
overflowAreas
)
;
nsRect
overflowRect
=
overflowAreas
.
ScrollableOverflow
(
)
.
UnionEdges
(
paddingRect
)
;
return
nsLayoutUtils
:
:
GetScrolledRect
(
aFrame
overflowRect
paddingRect
.
Size
(
)
aFrame
-
>
StyleVisibility
(
)
-
>
mDirection
)
.
Size
(
)
;
}
int32_t
Element
:
:
ScrollHeight
(
)
{
nsIFrame
*
frame
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
&
frame
)
;
nscoord
height
;
if
(
sf
)
{
height
=
sf
-
>
GetScrollRange
(
)
.
Height
(
)
+
sf
-
>
GetScrollPortRect
(
)
.
Height
(
)
;
}
else
{
height
=
GetScrollRectSizeForOverflowVisibleFrame
(
frame
)
.
height
;
}
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
height
)
;
}
int32_t
Element
:
:
ScrollWidth
(
)
{
nsIFrame
*
frame
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
&
frame
)
;
nscoord
width
;
if
(
sf
)
{
width
=
sf
-
>
GetScrollRange
(
)
.
Width
(
)
+
sf
-
>
GetScrollPortRect
(
)
.
Width
(
)
;
}
else
{
width
=
GetScrollRectSizeForOverflowVisibleFrame
(
frame
)
.
width
;
}
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
width
)
;
}
nsRect
Element
:
:
GetClientAreaRect
(
)
{
Document
*
doc
=
OwnerDoc
(
)
;
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
;
bool
overlayScrollbars
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
;
bool
rootContentDocument
=
presContext
&
&
presContext
-
>
IsRootContentDocument
(
)
;
if
(
overlayScrollbars
&
&
rootContentDocument
&
&
doc
-
>
IsScrollingElement
(
this
)
)
{
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
RefPtr
<
nsViewManager
>
viewManager
=
presShell
-
>
GetViewManager
(
)
;
if
(
viewManager
)
{
viewManager
-
>
FlushDelayedResize
(
false
)
;
}
return
nsRect
(
nsPoint
(
)
presContext
-
>
GetVisibleArea
(
)
.
Size
(
)
)
;
}
nsIFrame
*
frame
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
&
frame
)
;
if
(
sf
)
{
nsRect
scrollPort
=
sf
-
>
GetScrollPortRect
(
)
;
scrollPort
.
SizeTo
(
sf
-
>
GetLayoutSize
(
)
)
;
return
scrollPort
;
}
if
(
frame
&
&
(
!
frame
-
>
StyleDisplay
(
)
-
>
IsInlineFlow
(
)
|
|
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
)
{
return
frame
-
>
GetPaddingRect
(
)
-
frame
-
>
GetPositionIgnoringScrolling
(
)
;
}
return
nsRect
(
0
0
0
0
)
;
}
already_AddRefed
<
DOMRect
>
Element
:
:
GetBoundingClientRect
(
)
{
RefPtr
<
DOMRect
>
rect
=
new
DOMRect
(
this
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
)
{
return
rect
.
forget
(
)
;
}
nsRect
r
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
;
rect
-
>
SetLayoutRect
(
r
)
;
return
rect
.
forget
(
)
;
}
already_AddRefed
<
DOMRectList
>
Element
:
:
GetClientRects
(
)
{
RefPtr
<
DOMRectList
>
rectList
=
new
DOMRectList
(
this
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
)
{
return
rectList
.
forget
(
)
;
}
nsLayoutUtils
:
:
RectListBuilder
builder
(
rectList
)
;
nsLayoutUtils
:
:
GetAllInFlowRects
(
frame
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
&
builder
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
;
return
rectList
.
forget
(
)
;
}
void
Element
:
:
AddToIdTable
(
nsAtom
*
aId
)
{
NS_ASSERTION
(
HasID
(
)
"
Node
doesn
'
t
have
an
ID
?
"
)
;
if
(
IsInShadowTree
(
)
)
{
ShadowRoot
*
containingShadow
=
GetContainingShadow
(
)
;
containingShadow
-
>
AddToIdTable
(
this
aId
)
;
}
else
{
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
doc
&
&
!
IsInAnonymousSubtree
(
)
)
{
doc
-
>
AddToIdTable
(
this
aId
)
;
}
}
}
void
Element
:
:
RemoveFromIdTable
(
)
{
if
(
!
HasID
(
)
)
{
return
;
}
nsAtom
*
id
=
DoGetID
(
)
;
if
(
IsInShadowTree
(
)
)
{
ShadowRoot
*
containingShadow
=
GetContainingShadow
(
)
;
if
(
containingShadow
)
{
containingShadow
-
>
RemoveFromIdTable
(
this
id
)
;
}
}
else
{
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
doc
&
&
!
IsInAnonymousSubtree
(
)
)
{
doc
-
>
RemoveFromIdTable
(
this
id
)
;
}
}
}
void
Element
:
:
SetSlot
(
const
nsAString
&
aName
ErrorResult
&
aError
)
{
aError
=
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
slot
aName
true
)
;
}
void
Element
:
:
GetSlot
(
nsAString
&
aName
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
slot
aName
)
;
}
ShadowRoot
*
Element
:
:
GetShadowRootByMode
(
)
const
{
ShadowRoot
*
shadowRoot
=
GetShadowRoot
(
)
;
if
(
!
shadowRoot
|
|
shadowRoot
-
>
IsClosed
(
)
)
{
return
nullptr
;
}
return
shadowRoot
;
}
bool
Element
:
:
CanAttachShadowDOM
(
)
const
{
if
(
!
IsHTMLElement
(
)
&
&
!
(
IsXULElement
(
)
&
&
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
NodePrincipal
(
)
)
)
)
{
return
false
;
}
nsAtom
*
nameAtom
=
NodeInfo
(
)
-
>
NameAtom
(
)
;
uint32_t
namespaceID
=
NodeInfo
(
)
-
>
NamespaceID
(
)
;
if
(
!
(
nsContentUtils
:
:
IsCustomElementName
(
nameAtom
namespaceID
)
|
|
nameAtom
=
=
nsGkAtoms
:
:
article
|
|
nameAtom
=
=
nsGkAtoms
:
:
aside
|
|
nameAtom
=
=
nsGkAtoms
:
:
blockquote
|
|
nameAtom
=
=
nsGkAtoms
:
:
body
|
|
nameAtom
=
=
nsGkAtoms
:
:
div
|
|
nameAtom
=
=
nsGkAtoms
:
:
footer
|
|
nameAtom
=
=
nsGkAtoms
:
:
h1
|
|
nameAtom
=
=
nsGkAtoms
:
:
h2
|
|
nameAtom
=
=
nsGkAtoms
:
:
h3
|
|
nameAtom
=
=
nsGkAtoms
:
:
h4
|
|
nameAtom
=
=
nsGkAtoms
:
:
h5
|
|
nameAtom
=
=
nsGkAtoms
:
:
h6
|
|
nameAtom
=
=
nsGkAtoms
:
:
header
|
|
nameAtom
=
=
nsGkAtoms
:
:
main
|
|
nameAtom
=
=
nsGkAtoms
:
:
nav
|
|
nameAtom
=
=
nsGkAtoms
:
:
p
|
|
nameAtom
=
=
nsGkAtoms
:
:
section
|
|
nameAtom
=
=
nsGkAtoms
:
:
span
)
)
{
return
false
;
}
CustomElementData
*
ceData
=
GetCustomElementData
(
)
;
if
(
StaticPrefs
:
:
dom_webcomponents_elementInternals_enabled
(
)
&
&
ceData
)
{
CustomElementDefinition
*
definition
=
ceData
-
>
GetCustomElementDefinition
(
)
;
if
(
!
definition
)
{
definition
=
nsContentUtils
:
:
LookupCustomElementDefinition
(
NodeInfo
(
)
-
>
GetDocument
(
)
nameAtom
namespaceID
ceData
-
>
GetCustomElementType
(
)
)
;
}
if
(
definition
&
&
definition
-
>
mDisableShadow
)
{
return
false
;
}
}
return
true
;
}
already_AddRefed
<
ShadowRoot
>
Element
:
:
AttachShadow
(
const
ShadowRootInit
&
aInit
ErrorResult
&
aError
)
{
if
(
!
CanAttachShadowDOM
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
GetShadowRoot
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
StaticPrefs
:
:
dom_webcomponents_shadowdom_report_usage
(
)
)
{
OwnerDoc
(
)
-
>
ReportShadowDOMUsage
(
)
;
}
return
AttachShadowWithoutNameChecks
(
aInit
.
mMode
)
;
}
already_AddRefed
<
ShadowRoot
>
Element
:
:
AttachShadowWithoutNameChecks
(
ShadowRootMode
aMode
)
{
nsAutoScriptBlocker
scriptBlocker
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
documentFragmentNodeName
nullptr
kNameSpaceID_None
DOCUMENT_FRAGMENT_NODE
)
;
if
(
HasChildren
(
)
)
{
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
if
(
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
)
{
presShell
-
>
DestroyFramesForAndRestyle
(
this
)
;
}
}
MOZ_ASSERT
(
!
GetPrimaryFrame
(
)
)
;
}
RefPtr
<
ShadowRoot
>
shadowRoot
=
new
ShadowRoot
(
this
aMode
nodeInfo
.
forget
(
)
)
;
if
(
NodeOrAncestorHasDirAuto
(
)
)
{
shadowRoot
-
>
SetAncestorHasDirAuto
(
)
;
}
SetShadowRoot
(
shadowRoot
)
;
{
AsyncEventDispatcher
*
dispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
shadowrootattached
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
Composed
:
:
eYes
)
;
dispatcher
-
>
PostDOMEvent
(
)
;
}
return
shadowRoot
.
forget
(
)
;
}
void
Element
:
:
AttachAndSetUAShadowRoot
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
CanAttachShadowDOM
(
)
"
Cannot
be
used
to
attach
UI
shadow
DOM
"
)
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
Element
:
:
AttachAndSetUAShadowRoot
:
:
Runnable
"
[
self
=
RefPtr
<
Element
>
(
this
)
]
(
)
{
if
(
self
-
>
GetShadowRoot
(
)
)
{
MOZ_ASSERT
(
self
-
>
GetShadowRoot
(
)
-
>
IsUAWidget
(
)
)
;
return
;
}
RefPtr
<
ShadowRoot
>
shadowRoot
=
self
-
>
AttachShadowWithoutNameChecks
(
ShadowRootMode
:
:
Closed
)
;
shadowRoot
-
>
SetIsUAWidget
(
)
;
}
)
)
;
}
void
Element
:
:
NotifyUAWidgetSetupOrChange
(
)
{
MOZ_ASSERT
(
IsInComposedDoc
(
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
Element
:
:
NotifyUAWidgetSetupOrChange
:
:
UAWidgetSetupOrChange
"
[
self
=
RefPtr
<
Element
>
(
this
)
ownerDoc
=
RefPtr
<
Document
>
(
OwnerDoc
(
)
)
]
(
)
{
MOZ_ASSERT
(
self
-
>
GetShadowRoot
(
)
&
&
self
-
>
GetShadowRoot
(
)
-
>
IsUAWidget
(
)
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
ownerDoc
self
NS_LITERAL_STRING
(
"
UAWidgetSetupOrChange
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
)
)
;
}
void
Element
:
:
NotifyUAWidgetTeardown
(
UnattachShadowRoot
aUnattachShadowRoot
)
{
MOZ_ASSERT
(
IsInComposedDoc
(
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
Element
:
:
NotifyUAWidgetTeardownAndUnattachShadow
:
:
UAWidgetTeardown
"
[
aUnattachShadowRoot
self
=
RefPtr
<
Element
>
(
this
)
ownerDoc
=
RefPtr
<
Document
>
(
OwnerDoc
(
)
)
]
(
)
{
if
(
!
self
-
>
GetShadowRoot
(
)
)
{
return
;
}
MOZ_ASSERT
(
self
-
>
GetShadowRoot
(
)
-
>
IsUAWidget
(
)
)
;
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
ownerDoc
-
>
GetScriptHandlingObject
(
hasHadScriptObject
)
;
if
(
!
scriptObject
&
&
hasHadScriptObject
)
{
return
;
}
nsresult
rv
=
nsContentUtils
:
:
DispatchChromeEvent
(
ownerDoc
self
NS_LITERAL_STRING
(
"
UAWidgetTeardown
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
aUnattachShadowRoot
=
=
UnattachShadowRoot
:
:
Yes
)
{
self
-
>
UnattachShadow
(
)
;
}
}
)
)
;
}
void
Element
:
:
UnattachShadow
(
)
{
ShadowRoot
*
shadowRoot
=
GetShadowRoot
(
)
;
if
(
!
shadowRoot
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
if
(
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
)
{
presShell
-
>
DestroyFramesForAndRestyle
(
this
)
;
}
}
MOZ_ASSERT
(
!
GetPrimaryFrame
(
)
)
;
shadowRoot
-
>
Unattach
(
)
;
SetShadowRoot
(
nullptr
)
;
}
void
Element
:
:
GetAttribute
(
const
nsAString
&
aName
DOMString
&
aReturn
)
{
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
IsHTMLElement
(
)
&
&
IsInHTMLDocument
(
)
?
eIgnoreCase
:
eCaseMatters
)
;
if
(
val
)
{
val
-
>
ToString
(
aReturn
)
;
}
else
{
if
(
IsXULElement
(
)
)
{
}
else
{
aReturn
.
SetNull
(
)
;
}
}
}
bool
Element
:
:
ToggleAttribute
(
const
nsAString
&
aName
const
Optional
<
bool
>
&
aForce
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
aError
=
nsContentUtils
:
:
CheckQName
(
aName
false
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
nsAutoString
nameToUse
;
const
nsAttrName
*
name
=
InternalGetAttrNameFromQName
(
aName
&
nameToUse
)
;
if
(
!
name
)
{
if
(
aForce
.
WasPassed
(
)
&
&
!
aForce
.
Value
(
)
)
{
return
false
;
}
RefPtr
<
nsAtom
>
nameAtom
=
NS_AtomizeMainThread
(
nameToUse
)
;
if
(
!
nameAtom
)
{
aError
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
false
;
}
aError
=
SetAttr
(
kNameSpaceID_None
nameAtom
EmptyString
(
)
aTriggeringPrincipal
true
)
;
return
true
;
}
if
(
aForce
.
WasPassed
(
)
&
&
aForce
.
Value
(
)
)
{
return
true
;
}
nsAttrName
tmp
(
*
name
)
;
aError
=
UnsetAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
true
)
;
return
false
;
}
void
Element
:
:
SetAttribute
(
const
nsAString
&
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
aError
=
nsContentUtils
:
:
CheckQName
(
aName
false
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsAutoString
nameToUse
;
const
nsAttrName
*
name
=
InternalGetAttrNameFromQName
(
aName
&
nameToUse
)
;
if
(
!
name
)
{
RefPtr
<
nsAtom
>
nameAtom
=
NS_AtomizeMainThread
(
nameToUse
)
;
if
(
!
nameAtom
)
{
aError
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
aError
=
SetAttr
(
kNameSpaceID_None
nameAtom
aValue
aTriggeringPrincipal
true
)
;
return
;
}
aError
=
SetAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
aValue
aTriggeringPrincipal
true
)
;
}
void
Element
:
:
RemoveAttribute
(
const
nsAString
&
aName
ErrorResult
&
aError
)
{
const
nsAttrName
*
name
=
InternalGetAttrNameFromQName
(
aName
)
;
if
(
!
name
)
{
return
;
}
nsAttrName
tmp
(
*
name
)
;
aError
=
UnsetAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
true
)
;
}
Attr
*
Element
:
:
GetAttributeNode
(
const
nsAString
&
aName
)
{
return
Attributes
(
)
-
>
GetNamedItem
(
aName
)
;
}
already_AddRefed
<
Attr
>
Element
:
:
SetAttributeNode
(
Attr
&
aNewAttr
ErrorResult
&
aError
)
{
return
Attributes
(
)
-
>
SetNamedItemNS
(
aNewAttr
aError
)
;
}
already_AddRefed
<
Attr
>
Element
:
:
RemoveAttributeNode
(
Attr
&
aAttribute
ErrorResult
&
aError
)
{
Element
*
elem
=
aAttribute
.
GetElement
(
)
;
if
(
elem
!
=
this
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
nsAutoString
nameSpaceURI
;
aAttribute
.
NodeInfo
(
)
-
>
GetNamespaceURI
(
nameSpaceURI
)
;
return
Attributes
(
)
-
>
RemoveNamedItemNS
(
nameSpaceURI
aAttribute
.
NodeInfo
(
)
-
>
LocalName
(
)
aError
)
;
}
void
Element
:
:
GetAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
nsAString
&
aReturn
)
{
int32_t
nsid
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceID
(
aNamespaceURI
nsContentUtils
:
:
IsChromeDoc
(
OwnerDoc
(
)
)
)
;
if
(
nsid
=
=
kNameSpaceID_Unknown
)
{
SetDOMStringToNull
(
aReturn
)
;
return
;
}
RefPtr
<
nsAtom
>
name
=
NS_AtomizeMainThread
(
aLocalName
)
;
bool
hasAttr
=
GetAttr
(
nsid
name
aReturn
)
;
if
(
!
hasAttr
)
{
SetDOMStringToNull
(
aReturn
)
;
}
}
void
Element
:
:
SetAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
;
aError
=
nsContentUtils
:
:
GetNodeInfoFromQName
(
aNamespaceURI
aQualifiedName
mNodeInfo
-
>
NodeInfoManager
(
)
ATTRIBUTE_NODE
getter_AddRefs
(
ni
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
aError
=
SetAttr
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
ni
-
>
GetPrefixAtom
(
)
aValue
aTriggeringPrincipal
true
)
;
}
static
already_AddRefed
<
BasePrincipal
>
CreateDevtoolsPrincipal
(
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
)
{
AutoTArray
<
nsCOMPtr
<
nsIPrincipal
>
1
>
allowList
=
{
aPrincipal
}
;
RefPtr
<
ExpandedPrincipal
>
dtPrincipal
=
ExpandedPrincipal
:
:
Create
(
allowList
aPrincipal
-
>
OriginAttributesRef
(
)
)
;
if
(
aCsp
)
{
RefPtr
<
nsCSPContext
>
dtCsp
=
new
nsCSPContext
(
)
;
dtCsp
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
aCsp
)
)
;
dtCsp
-
>
SetSkipAllowInlineStyleCheck
(
true
)
;
dtPrincipal
-
>
SetCsp
(
dtCsp
)
;
}
return
dtPrincipal
.
forget
(
)
;
}
void
Element
:
:
SetAttributeDevtools
(
const
nsAString
&
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
RefPtr
<
BasePrincipal
>
dtPrincipal
=
CreateDevtoolsPrincipal
(
NodePrincipal
(
)
GetCsp
(
)
)
;
SetAttribute
(
aName
aValue
dtPrincipal
aError
)
;
}
void
Element
:
:
SetAttributeDevtoolsNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
RefPtr
<
BasePrincipal
>
dtPrincipal
=
CreateDevtoolsPrincipal
(
NodePrincipal
(
)
GetCsp
(
)
)
;
SetAttributeNS
(
aNamespaceURI
aLocalName
aValue
dtPrincipal
aError
)
;
}
void
Element
:
:
RemoveAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
{
RefPtr
<
nsAtom
>
name
=
NS_AtomizeMainThread
(
aLocalName
)
;
int32_t
nsid
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceID
(
aNamespaceURI
nsContentUtils
:
:
IsChromeDoc
(
OwnerDoc
(
)
)
)
;
if
(
nsid
=
=
kNameSpaceID_Unknown
)
{
return
;
}
aError
=
UnsetAttr
(
nsid
name
true
)
;
}
Attr
*
Element
:
:
GetAttributeNodeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
return
GetAttributeNodeNSInternal
(
aNamespaceURI
aLocalName
)
;
}
Attr
*
Element
:
:
GetAttributeNodeNSInternal
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
return
Attributes
(
)
-
>
GetNamedItemNS
(
aNamespaceURI
aLocalName
)
;
}
already_AddRefed
<
Attr
>
Element
:
:
SetAttributeNodeNS
(
Attr
&
aNewAttr
ErrorResult
&
aError
)
{
return
Attributes
(
)
-
>
SetNamedItemNS
(
aNewAttr
aError
)
;
}
already_AddRefed
<
nsIHTMLCollection
>
Element
:
:
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
{
int32_t
nameSpaceId
=
kNameSpaceID_Wildcard
;
if
(
!
aNamespaceURI
.
EqualsLiteral
(
"
*
"
)
)
{
aError
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
RegisterNameSpace
(
aNamespaceURI
nameSpaceId
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
NS_ASSERTION
(
nameSpaceId
!
=
kNameSpaceID_Unknown
"
Unexpected
namespace
ID
!
"
)
;
return
NS_GetContentList
(
this
nameSpaceId
aLocalName
)
;
}
bool
Element
:
:
HasAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
const
{
int32_t
nsid
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceID
(
aNamespaceURI
nsContentUtils
:
:
IsChromeDoc
(
OwnerDoc
(
)
)
)
;
if
(
nsid
=
=
kNameSpaceID_Unknown
)
{
return
false
;
}
RefPtr
<
nsAtom
>
name
=
NS_AtomizeMainThread
(
aLocalName
)
;
return
HasAttr
(
nsid
name
)
;
}
already_AddRefed
<
nsIHTMLCollection
>
Element
:
:
GetElementsByClassName
(
const
nsAString
&
aClassNames
)
{
return
nsContentUtils
:
:
GetElementsByClassName
(
this
aClassNames
)
;
}
void
Element
:
:
GetElementsWithGrid
(
nsTArray
<
RefPtr
<
Element
>
>
&
aElements
)
{
nsINode
*
cur
=
this
;
while
(
cur
)
{
if
(
cur
-
>
IsElement
(
)
)
{
Element
*
elem
=
cur
-
>
AsElement
(
)
;
if
(
elem
-
>
GetPrimaryFrame
(
)
)
{
if
(
nsGridContainerFrame
:
:
GetGridContainerFrame
(
elem
-
>
GetPrimaryFrame
(
)
)
)
{
aElements
.
AppendElement
(
elem
)
;
}
cur
=
cur
-
>
GetNextNode
(
this
)
;
continue
;
}
}
cur
=
cur
-
>
GetNextNonChildNode
(
this
)
;
}
}
nsresult
Element
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
MOZ_ASSERT
(
aParent
.
IsContent
(
)
|
|
aParent
.
IsDocument
(
)
"
Must
have
content
or
document
parent
!
"
)
;
MOZ_ASSERT
(
aParent
.
OwnerDoc
(
)
=
=
OwnerDoc
(
)
"
Must
have
the
same
owner
document
"
)
;
MOZ_ASSERT
(
OwnerDoc
(
)
=
=
&
aContext
.
OwnerDoc
(
)
"
These
should
match
too
"
)
;
MOZ_ASSERT
(
!
IsInUncomposedDoc
(
)
"
Already
have
a
document
.
Unbind
first
!
"
)
;
MOZ_ASSERT
(
!
IsInComposedDoc
(
)
"
Already
have
a
document
.
Unbind
first
!
"
)
;
MOZ_ASSERT
(
!
GetParentNode
(
)
|
|
&
aParent
=
=
GetParentNode
(
)
"
Already
have
a
parent
.
Unbind
first
!
"
)
;
const
bool
hadParent
=
!
!
GetParentNode
(
)
;
if
(
aParent
.
IsInNativeAnonymousSubtree
(
)
)
{
SetFlags
(
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
)
;
}
if
(
aParent
.
HasFlag
(
NODE_HAS_BEEN_IN_UA_WIDGET
)
)
{
SetFlags
(
NODE_HAS_BEEN_IN_UA_WIDGET
)
;
}
if
(
IsRootOfNativeAnonymousSubtree
(
)
)
{
aParent
.
SetMayHaveAnonymousChildren
(
)
;
}
mParent
=
&
aParent
;
if
(
!
hadParent
&
&
aParent
.
IsContent
(
)
)
{
SetParentIsContent
(
true
)
;
NS_ADDREF
(
mParent
)
;
}
MOZ_ASSERT
(
!
!
GetParent
(
)
=
=
aParent
.
IsContent
(
)
)
;
MOZ_ASSERT
(
!
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
)
;
if
(
aParent
.
IsInUncomposedDoc
(
)
|
|
aParent
.
IsInShadowTree
(
)
)
{
ClearSubtreeRootPointer
(
)
;
SetIsConnected
(
aParent
.
IsInComposedDoc
(
)
)
;
if
(
aParent
.
IsInUncomposedDoc
(
)
)
{
SetIsInDocument
(
)
;
}
else
{
SetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
MOZ_ASSERT
(
aParent
.
IsContent
(
)
&
&
aParent
.
AsContent
(
)
-
>
GetContainingShadow
(
)
)
;
ExtendedDOMSlots
(
)
-
>
mContainingShadow
=
aParent
.
AsContent
(
)
-
>
GetContainingShadow
(
)
;
}
UnsetFlags
(
NODE_NEEDS_FRAME
|
NODE_DESCENDANTS_NEED_FRAMES
)
;
}
else
{
SetSubtreeRootPointer
(
aParent
.
SubtreeRoot
(
)
)
;
}
if
(
IsInComposedDoc
(
)
)
{
if
(
CustomElementData
*
data
=
GetCustomElementData
(
)
)
{
if
(
data
-
>
mState
=
=
CustomElementData
:
:
State
:
:
eCustom
)
{
nsContentUtils
:
:
EnqueueLifecycleCallback
(
Document
:
:
eConnected
this
)
;
}
else
{
nsContentUtils
:
:
TryToUpgradeElement
(
this
)
;
}
}
}
if
(
IsHTMLElement
(
)
)
{
SetDirOnBind
(
this
nsIContent
:
:
FromNode
(
aParent
)
)
;
}
UpdateEditableState
(
false
)
;
nsresult
rv
;
if
(
ShadowRoot
*
shadowRoot
=
GetShadowRoot
(
)
)
{
rv
=
shadowRoot
-
>
Bind
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
{
BindContext
:
:
NestingLevel
level
(
aContext
*
this
)
;
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
rv
=
child
-
>
BindToTree
(
aContext
*
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
MutationObservers
:
:
NotifyParentChainChanged
(
this
)
;
if
(
!
hadParent
&
&
IsRootOfNativeAnonymousSubtree
(
)
)
{
MutationObservers
:
:
NotifyNativeAnonymousChildListChange
(
this
false
)
;
}
if
(
aContext
.
SubtreeRootChanges
(
)
)
{
if
(
HasPartAttribute
(
)
)
{
if
(
ShadowRoot
*
shadow
=
GetContainingShadow
(
)
)
{
shadow
-
>
PartAdded
(
*
this
)
;
}
}
if
(
HasID
(
)
)
{
AddToIdTable
(
DoGetID
(
)
)
;
}
HandleShadowDOMRelatedInsertionSteps
(
hadParent
)
;
}
if
(
MayHaveStyle
(
)
&
&
!
IsXULElement
(
)
)
{
static_cast
<
nsStyledElement
*
>
(
this
)
-
>
ReparseStyleAttribute
(
false
)
;
}
if
(
aParent
.
IsInUncomposedDoc
(
)
&
&
MayHaveAnimations
(
)
)
{
PseudoStyleType
pseudoType
=
GetPseudoElementType
(
)
;
if
(
(
pseudoType
=
=
PseudoStyleType
:
:
NotPseudo
|
|
pseudoType
=
=
PseudoStyleType
:
:
before
|
|
pseudoType
=
=
PseudoStyleType
:
:
after
|
|
pseudoType
=
=
PseudoStyleType
:
:
marker
)
&
&
EffectSet
:
:
GetEffectSet
(
this
pseudoType
)
)
{
if
(
nsPresContext
*
presContext
=
aContext
.
OwnerDoc
(
)
.
GetPresContext
(
)
)
{
presContext
-
>
EffectCompositor
(
)
-
>
RequestRestyle
(
this
pseudoType
EffectCompositor
:
:
RestyleType
:
:
Standard
EffectCompositor
:
:
CascadeLevel
:
:
Animations
)
;
}
}
}
MOZ_ASSERT
(
OwnerDoc
(
)
=
=
aParent
.
OwnerDoc
(
)
"
Bound
to
wrong
document
"
)
;
MOZ_ASSERT
(
IsInComposedDoc
(
)
=
=
aContext
.
InComposedDoc
(
)
)
;
MOZ_ASSERT
(
IsInUncomposedDoc
(
)
=
=
aContext
.
InUncomposedDoc
(
)
)
;
MOZ_ASSERT
(
&
aParent
=
=
GetParentNode
(
)
"
Bound
to
wrong
parent
node
"
)
;
MOZ_ASSERT
(
aParent
.
IsInUncomposedDoc
(
)
=
=
IsInUncomposedDoc
(
)
)
;
MOZ_ASSERT
(
aParent
.
IsInComposedDoc
(
)
=
=
IsInComposedDoc
(
)
)
;
MOZ_ASSERT
(
aParent
.
IsInShadowTree
(
)
=
=
IsInShadowTree
(
)
)
;
MOZ_ASSERT
(
aParent
.
SubtreeRoot
(
)
=
=
SubtreeRoot
(
)
)
;
return
NS_OK
;
}
bool
WillDetachFromShadowOnUnbind
(
const
Element
&
aElement
bool
aNullParent
)
{
return
aElement
.
IsInShadowTree
(
)
&
&
(
aNullParent
|
|
!
aElement
.
GetParent
(
)
-
>
IsInShadowTree
(
)
)
;
}
void
Element
:
:
UnbindFromTree
(
bool
aNullParent
)
{
HandleShadowDOMRelatedRemovalSteps
(
aNullParent
)
;
const
bool
detachingFromShadow
=
WillDetachFromShadowOnUnbind
(
*
this
aNullParent
)
;
if
(
IsInUncomposedDoc
(
)
|
|
detachingFromShadow
)
{
RemoveFromIdTable
(
)
;
}
if
(
detachingFromShadow
&
&
HasPartAttribute
(
)
)
{
if
(
ShadowRoot
*
shadow
=
GetContainingShadow
(
)
)
{
shadow
-
>
PartRemoved
(
*
this
)
;
}
}
Document
*
document
=
GetComposedDoc
(
)
;
if
(
HasPointerLock
(
)
)
{
Document
:
:
UnlockPointer
(
)
;
}
if
(
mState
.
HasState
(
NS_EVENT_STATE_FULLSCREEN
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
RemovedFullscreenElement
"
)
;
Document
:
:
ExitFullscreenInDocTree
(
OwnerDoc
(
)
)
;
}
if
(
HasServoData
(
)
)
{
MOZ_ASSERT
(
document
)
;
MOZ_ASSERT
(
IsInAnonymousSubtree
(
)
)
;
}
if
(
document
)
{
ClearServoData
(
document
)
;
}
if
(
aNullParent
)
{
if
(
IsRootOfNativeAnonymousSubtree
(
)
)
{
MutationObservers
:
:
NotifyNativeAnonymousChildListChange
(
this
true
)
;
}
if
(
GetParent
(
)
)
{
RefPtr
<
nsINode
>
p
;
p
.
swap
(
mParent
)
;
}
else
{
mParent
=
nullptr
;
}
SetParentIsContent
(
false
)
;
}
#
ifdef
DEBUG
if
(
document
)
{
nsPresContext
*
presContext
=
document
-
>
GetPresContext
(
)
;
if
(
presContext
)
{
MOZ_ASSERT
(
this
!
=
presContext
-
>
GetViewportScrollStylesOverrideElement
(
)
"
Leaving
behind
a
raw
pointer
to
this
element
(
as
having
"
"
propagated
scrollbar
styles
)
-
that
'
s
dangerous
.
.
.
"
)
;
}
}
#
ifdef
ACCESSIBILITY
MOZ_ASSERT
(
!
GetAccService
(
)
|
|
!
GetAccService
(
)
-
>
HasAccessible
(
this
)
"
An
accessible
for
this
element
still
exists
!
"
)
;
#
endif
#
endif
if
(
MayHaveAnimations
(
)
)
{
DeleteProperty
(
nsGkAtoms
:
:
transitionsOfBeforeProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
transitionsOfAfterProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
transitionsOfMarkerProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
transitionsProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
animationsOfBeforeProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
animationsOfAfterProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
animationsOfMarkerProperty
)
;
DeleteProperty
(
nsGkAtoms
:
:
animationsProperty
)
;
if
(
document
)
{
if
(
nsPresContext
*
presContext
=
document
-
>
GetPresContext
(
)
)
{
presContext
-
>
EffectCompositor
(
)
-
>
ClearRestyleRequestsFor
(
this
)
;
}
}
}
ClearInDocument
(
)
;
SetIsConnected
(
false
)
;
if
(
HasElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
)
{
if
(
document
)
{
document
-
>
mL10nProtoElements
.
Remove
(
this
)
;
}
ClearElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
;
}
if
(
aNullParent
|
|
!
mParent
-
>
IsInShadowTree
(
)
)
{
UnsetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
SetSubtreeRootPointer
(
aNullParent
?
this
:
mParent
-
>
SubtreeRoot
(
)
)
;
}
if
(
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
)
{
if
(
aNullParent
|
|
!
mParent
-
>
IsInShadowTree
(
)
)
{
slots
-
>
mContainingShadow
=
nullptr
;
}
}
if
(
document
)
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
if
(
data
)
{
if
(
data
-
>
mState
=
=
CustomElementData
:
:
State
:
:
eCustom
)
{
nsContentUtils
:
:
EnqueueLifecycleCallback
(
Document
:
:
eDisconnected
this
)
;
}
else
{
nsContentUtils
:
:
UnregisterUnresolvedElement
(
this
)
;
}
}
}
if
(
IsHTMLElement
(
)
)
{
ResetDir
(
this
)
;
}
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
UnbindFromTree
(
false
)
;
}
MutationObservers
:
:
NotifyParentChainChanged
(
this
)
;
if
(
ShadowRoot
*
shadowRoot
=
GetShadowRoot
(
)
)
{
shadowRoot
-
>
Unbind
(
)
;
}
MOZ_ASSERT
(
!
HasAnyOfFlags
(
kAllServoDescendantBits
)
)
;
MOZ_ASSERT
(
!
document
|
|
document
-
>
GetServoRestyleRoot
(
)
!
=
this
)
;
}
nsDOMCSSAttributeDeclaration
*
Element
:
:
SMILOverrideStyle
(
)
{
Element
:
:
nsExtendedDOMSlots
*
slots
=
ExtendedDOMSlots
(
)
;
if
(
!
slots
-
>
mSMILOverrideStyle
)
{
slots
-
>
mSMILOverrideStyle
=
new
nsDOMCSSAttributeDeclaration
(
this
true
)
;
}
return
slots
-
>
mSMILOverrideStyle
;
}
DeclarationBlock
*
Element
:
:
GetSMILOverrideStyleDeclaration
(
)
{
Element
:
:
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mSMILOverrideStyleDeclaration
.
get
(
)
:
nullptr
;
}
void
Element
:
:
SetSMILOverrideStyleDeclaration
(
DeclarationBlock
&
aDeclaration
)
{
ExtendedDOMSlots
(
)
-
>
mSMILOverrideStyleDeclaration
=
&
aDeclaration
;
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
if
(
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
)
{
presShell
-
>
RestyleForAnimation
(
this
StyleRestyleHint_RESTYLE_SMIL
)
;
}
}
}
bool
Element
:
:
IsLabelable
(
)
const
{
return
false
;
}
bool
Element
:
:
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
{
return
false
;
}
DeclarationBlock
*
Element
:
:
GetInlineStyleDeclaration
(
)
const
{
if
(
!
MayHaveStyle
(
)
)
{
return
nullptr
;
}
const
nsAttrValue
*
attrVal
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
style
)
;
if
(
attrVal
&
&
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eCSSDeclaration
)
{
return
attrVal
-
>
GetCSSDeclarationValue
(
)
;
}
return
nullptr
;
}
const
nsMappedAttributes
*
Element
:
:
GetMappedAttributes
(
)
const
{
return
mAttrs
.
GetMapped
(
)
;
}
void
Element
:
:
InlineStyleDeclarationWillChange
(
MutationClosureData
&
aData
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Element
:
:
InlineStyleDeclarationWillChange
"
)
;
}
nsresult
Element
:
:
SetInlineStyleDeclaration
(
DeclarationBlock
&
aDeclaration
MutationClosureData
&
aData
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Element
:
:
SetInlineStyleDeclaration
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP_
(
bool
)
Element
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
return
false
;
}
nsChangeHint
Element
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
return
nsChangeHint
(
0
)
;
}
bool
Element
:
:
FindAttributeDependence
(
const
nsAtom
*
aAttribute
const
MappedAttributeEntry
*
const
aMaps
[
]
uint32_t
aMapCount
)
{
for
(
uint32_t
mapindex
=
0
;
mapindex
<
aMapCount
;
+
+
mapindex
)
{
for
(
const
MappedAttributeEntry
*
map
=
aMaps
[
mapindex
]
;
map
-
>
attribute
;
+
+
map
)
{
if
(
aAttribute
=
=
map
-
>
attribute
)
{
return
true
;
}
}
}
return
false
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
Element
:
:
GetExistingAttrNameFromQName
(
const
nsAString
&
aStr
)
const
{
const
nsAttrName
*
name
=
InternalGetAttrNameFromQName
(
aStr
)
;
if
(
!
name
)
{
return
nullptr
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
if
(
name
-
>
IsAtom
(
)
)
{
nodeInfo
=
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
name
-
>
Atom
(
)
nullptr
kNameSpaceID_None
ATTRIBUTE_NODE
)
;
}
else
{
nodeInfo
=
name
-
>
NodeInfo
(
)
;
}
return
nodeInfo
.
forget
(
)
;
}
bool
Element
:
:
ShouldBlur
(
nsIContent
*
aContent
)
{
Document
*
document
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
!
document
)
return
false
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
document
-
>
GetWindow
(
)
;
if
(
!
window
)
return
false
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedFrame
;
nsIContent
*
contentToBlur
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedFrame
)
)
;
if
(
contentToBlur
=
=
aContent
)
return
true
;
return
(
contentToBlur
&
&
nsFocusManager
:
:
GetRedirectedFocus
(
aContent
)
=
=
contentToBlur
)
;
}
bool
Element
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
false
;
}
nsresult
Element
:
:
DispatchEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIContent
*
aTarget
bool
aFullDispatch
nsEventStatus
*
aStatus
)
{
MOZ_ASSERT
(
aTarget
"
Must
have
target
"
)
;
MOZ_ASSERT
(
aEvent
"
Must
have
source
event
"
)
;
MOZ_ASSERT
(
aStatus
"
Null
out
param
?
"
)
;
if
(
!
aPresContext
)
{
return
NS_OK
;
}
RefPtr
<
PresShell
>
presShell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
if
(
aFullDispatch
)
{
return
presShell
-
>
HandleEventWithTarget
(
aEvent
nullptr
aTarget
aStatus
)
;
}
return
presShell
-
>
HandleDOMEventWithTarget
(
aTarget
aEvent
aStatus
)
;
}
nsresult
Element
:
:
DispatchClickEvent
(
nsPresContext
*
aPresContext
WidgetInputEvent
*
aSourceEvent
nsIContent
*
aTarget
bool
aFullDispatch
const
EventFlags
*
aExtraEventFlags
nsEventStatus
*
aStatus
)
{
MOZ_ASSERT
(
aTarget
"
Must
have
target
"
)
;
MOZ_ASSERT
(
aSourceEvent
"
Must
have
source
event
"
)
;
MOZ_ASSERT
(
aStatus
"
Null
out
param
?
"
)
;
WidgetMouseEvent
event
(
aSourceEvent
-
>
IsTrusted
(
)
eMouseClick
aSourceEvent
-
>
mWidget
WidgetMouseEvent
:
:
eReal
)
;
event
.
mRefPoint
=
aSourceEvent
-
>
mRefPoint
;
uint32_t
clickCount
=
1
;
float
pressure
=
0
;
uint32_t
pointerId
=
0
;
uint16_t
inputSource
=
0
;
WidgetMouseEvent
*
sourceMouseEvent
=
aSourceEvent
-
>
AsMouseEvent
(
)
;
if
(
sourceMouseEvent
)
{
clickCount
=
sourceMouseEvent
-
>
mClickCount
;
pressure
=
sourceMouseEvent
-
>
mPressure
;
pointerId
=
sourceMouseEvent
-
>
pointerId
;
inputSource
=
sourceMouseEvent
-
>
mInputSource
;
}
else
if
(
aSourceEvent
-
>
mClass
=
=
eKeyboardEventClass
)
{
event
.
mFlags
.
mIsPositionless
=
true
;
inputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
;
}
event
.
mPressure
=
pressure
;
event
.
mClickCount
=
clickCount
;
event
.
pointerId
=
pointerId
;
event
.
mInputSource
=
inputSource
;
event
.
mModifiers
=
aSourceEvent
-
>
mModifiers
;
if
(
aExtraEventFlags
)
{
event
.
mFlags
.
Union
(
*
aExtraEventFlags
)
;
}
return
DispatchEvent
(
aPresContext
&
event
aTarget
aFullDispatch
aStatus
)
;
}
nsresult
Element
:
:
LeaveLink
(
nsPresContext
*
aPresContext
)
{
if
(
!
aPresContext
|
|
!
aPresContext
-
>
Document
(
)
-
>
LinkHandlingEnabled
(
)
)
{
return
NS_OK
;
}
nsIDocShell
*
shell
=
aPresContext
-
>
Document
(
)
-
>
GetDocShell
(
)
;
if
(
!
shell
)
{
return
NS_OK
;
}
return
nsDocShell
:
:
Cast
(
shell
)
-
>
OnLeaveLink
(
)
;
}
nsresult
Element
:
:
SetEventHandler
(
nsAtom
*
aEventName
const
nsAString
&
aValue
bool
aDefer
)
{
Document
*
ownerDoc
=
OwnerDoc
(
)
;
if
(
ownerDoc
-
>
IsLoadedAsData
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
aEventName
"
Must
have
event
name
!
"
)
;
bool
defer
=
true
;
EventListenerManager
*
manager
=
GetEventListenerManagerForAttr
(
aEventName
&
defer
)
;
if
(
!
manager
)
{
return
NS_OK
;
}
defer
=
defer
&
&
aDefer
;
manager
-
>
SetEventHandler
(
aEventName
aValue
defer
!
nsContentUtils
:
:
IsChromeDoc
(
ownerDoc
)
this
)
;
return
NS_OK
;
}
const
nsAttrName
*
Element
:
:
InternalGetAttrNameFromQName
(
const
nsAString
&
aStr
nsAutoString
*
aNameToUse
)
const
{
MOZ_ASSERT
(
!
aNameToUse
|
|
aNameToUse
-
>
IsEmpty
(
)
)
;
const
nsAttrName
*
val
=
nullptr
;
if
(
IsHTMLElement
(
)
&
&
IsInHTMLDocument
(
)
)
{
nsAutoString
lower
;
nsAutoString
&
outStr
=
aNameToUse
?
*
aNameToUse
:
lower
;
nsContentUtils
:
:
ASCIIToLower
(
aStr
outStr
)
;
val
=
mAttrs
.
GetExistingAttrNameFromQName
(
outStr
)
;
if
(
val
)
{
outStr
.
Truncate
(
)
;
}
}
else
{
val
=
mAttrs
.
GetExistingAttrNameFromQName
(
aStr
)
;
if
(
!
val
&
&
aNameToUse
)
{
*
aNameToUse
=
aStr
;
}
}
return
val
;
}
bool
Element
:
:
MaybeCheckSameAttrVal
(
int32_t
aNamespaceID
const
nsAtom
*
aName
const
nsAtom
*
aPrefix
const
nsAttrValueOrString
&
aValue
bool
aNotify
nsAttrValue
&
aOldValue
uint8_t
*
aModType
bool
*
aHasListeners
bool
*
aOldValueSet
)
{
bool
modification
=
false
;
*
aHasListeners
=
aNotify
&
&
nsContentUtils
:
:
HasMutationListeners
(
this
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
this
)
;
*
aOldValueSet
=
false
;
if
(
*
aHasListeners
|
|
aNotify
)
{
BorrowedAttrInfo
info
(
GetAttrInfo
(
aNamespaceID
aName
)
)
;
if
(
info
.
mValue
)
{
if
(
*
aHasListeners
|
|
GetCustomElementData
(
)
)
{
aOldValue
.
SetToSerialized
(
*
info
.
mValue
)
;
*
aOldValueSet
=
true
;
}
bool
valueMatches
=
aValue
.
EqualsAsStrings
(
*
info
.
mValue
)
;
if
(
valueMatches
&
&
aPrefix
=
=
info
.
mName
-
>
GetPrefix
(
)
)
{
return
true
;
}
modification
=
true
;
}
}
*
aModType
=
modification
?
static_cast
<
uint8_t
>
(
MutationEvent_Binding
:
:
MODIFICATION
)
:
static_cast
<
uint8_t
>
(
MutationEvent_Binding
:
:
ADDITION
)
;
return
false
;
}
bool
Element
:
:
OnlyNotifySameValueSet
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAttrValueOrString
&
aValue
bool
aNotify
nsAttrValue
&
aOldValue
uint8_t
*
aModType
bool
*
aHasListeners
bool
*
aOldValueSet
)
{
if
(
!
MaybeCheckSameAttrVal
(
aNamespaceID
aName
aPrefix
aValue
aNotify
aOldValue
aModType
aHasListeners
aOldValueSet
)
)
{
return
false
;
}
nsAutoScriptBlocker
scriptBlocker
;
MutationObservers
:
:
NotifyAttributeSetToCurrentValue
(
this
aNamespaceID
aName
)
;
return
true
;
}
nsresult
Element
:
:
SetSingleClassFromParser
(
nsAtom
*
aSingleClassName
)
{
nsAttrValue
value
(
aSingleClassName
)
;
Document
*
document
=
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
false
)
;
SetMayHaveClass
(
)
;
return
SetAttrAndNotify
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
nullptr
nullptr
value
nullptr
static_cast
<
uint8_t
>
(
MutationEvent_Binding
:
:
ADDITION
)
false
false
kCallAfterSetAttr
document
updateBatch
)
;
}
nsresult
Element
:
:
SetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAString
&
aValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
NS_ENSURE_ARG_POINTER
(
aName
)
;
NS_ASSERTION
(
aNamespaceID
!
=
kNameSpaceID_Unknown
"
Don
'
t
call
SetAttr
with
unknown
namespace
"
)
;
uint8_t
modType
;
bool
hasListeners
;
nsAttrValueOrString
value
(
aValue
)
;
nsAttrValue
oldValue
;
bool
oldValueSet
;
if
(
OnlyNotifySameValueSet
(
aNamespaceID
aName
aPrefix
value
aNotify
oldValue
&
modType
&
hasListeners
&
oldValueSet
)
)
{
return
OnAttrSetButNotChanged
(
aNamespaceID
aName
value
aNotify
)
;
}
if
(
aNotify
)
{
MutationObservers
:
:
NotifyAttributeWillChange
(
this
aNamespaceID
aName
modType
)
;
}
Document
*
document
=
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
aNotify
)
;
nsresult
rv
=
BeforeSetAttr
(
aNamespaceID
aName
&
value
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAttrValue
attrValue
;
if
(
!
ParseAttribute
(
aNamespaceID
aName
aValue
aSubjectPrincipal
attrValue
)
)
{
attrValue
.
SetTo
(
aValue
)
;
}
PreIdMaybeChange
(
aNamespaceID
aName
&
value
)
;
return
SetAttrAndNotify
(
aNamespaceID
aName
aPrefix
oldValueSet
?
&
oldValue
:
nullptr
attrValue
aSubjectPrincipal
modType
hasListeners
aNotify
kCallAfterSetAttr
document
updateBatch
)
;
}
nsresult
Element
:
:
SetParsedAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
nsAttrValue
&
aParsedValue
bool
aNotify
)
{
NS_ENSURE_ARG_POINTER
(
aName
)
;
NS_ASSERTION
(
aNamespaceID
!
=
kNameSpaceID_Unknown
"
Don
'
t
call
SetAttr
with
unknown
namespace
"
)
;
uint8_t
modType
;
bool
hasListeners
;
nsAttrValueOrString
value
(
aParsedValue
)
;
nsAttrValue
oldValue
;
bool
oldValueSet
;
if
(
OnlyNotifySameValueSet
(
aNamespaceID
aName
aPrefix
value
aNotify
oldValue
&
modType
&
hasListeners
&
oldValueSet
)
)
{
return
OnAttrSetButNotChanged
(
aNamespaceID
aName
value
aNotify
)
;
}
if
(
aNotify
)
{
MutationObservers
:
:
NotifyAttributeWillChange
(
this
aNamespaceID
aName
modType
)
;
}
nsresult
rv
=
BeforeSetAttr
(
aNamespaceID
aName
&
value
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PreIdMaybeChange
(
aNamespaceID
aName
&
value
)
;
Document
*
document
=
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
aNotify
)
;
return
SetAttrAndNotify
(
aNamespaceID
aName
aPrefix
oldValueSet
?
&
oldValue
:
nullptr
aParsedValue
nullptr
modType
hasListeners
aNotify
kCallAfterSetAttr
document
updateBatch
)
;
}
nsresult
Element
:
:
SetAttrAndNotify
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAttrValue
*
aOldValue
nsAttrValue
&
aParsedValue
nsIPrincipal
*
aSubjectPrincipal
uint8_t
aModType
bool
aFireMutation
bool
aNotify
bool
aCallAfterSetAttr
Document
*
aComposedDocument
const
mozAutoDocUpdate
&
)
{
nsresult
rv
;
nsMutationGuard
:
:
DidMutate
(
)
;
nsAttrValue
valueForAfterSetAttr
;
if
(
aCallAfterSetAttr
|
|
GetCustomElementData
(
)
)
{
valueForAfterSetAttr
.
SetTo
(
aParsedValue
)
;
}
bool
hadValidDir
=
false
;
bool
hadDirAuto
=
false
;
bool
oldValueSet
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
dir
)
{
hadValidDir
=
HasValidDir
(
)
|
|
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
;
hadDirAuto
=
HasDirAuto
(
)
;
}
if
(
!
IsAttributeMapped
(
aName
)
|
|
!
SetAndSwapMappedAttribute
(
aName
aParsedValue
&
oldValueSet
&
rv
)
)
{
rv
=
mAttrs
.
SetAndSwapAttr
(
aName
aParsedValue
&
oldValueSet
)
;
}
}
else
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
;
ni
=
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
aName
aPrefix
aNamespaceID
ATTRIBUTE_NODE
)
;
rv
=
mAttrs
.
SetAndSwapAttr
(
ni
aParsedValue
&
oldValueSet
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PostIdMaybeChange
(
aNamespaceID
aName
&
valueForAfterSetAttr
)
;
const
nsAttrValue
*
oldValue
;
if
(
aParsedValue
.
StoresOwnData
(
)
)
{
if
(
oldValueSet
)
{
oldValue
=
&
aParsedValue
;
}
else
{
oldValue
=
nullptr
;
}
}
else
{
oldValue
=
aOldValue
;
}
if
(
HasElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
&
&
aNamespaceID
=
=
kNameSpaceID_None
&
&
(
aName
=
=
nsGkAtoms
:
:
datal10nid
|
|
aName
=
=
nsGkAtoms
:
:
datal10nargs
)
)
{
ClearElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
;
if
(
aComposedDocument
)
{
aComposedDocument
-
>
mL10nProtoElements
.
Remove
(
this
)
;
}
}
CustomElementDefinition
*
definition
=
GetCustomElementDefinition
(
)
;
if
(
definition
&
&
definition
-
>
IsInObservedAttributeList
(
aName
)
)
{
RefPtr
<
nsAtom
>
oldValueAtom
;
if
(
oldValue
)
{
oldValueAtom
=
oldValue
-
>
GetAsAtom
(
)
;
}
else
{
oldValueAtom
=
aParsedValue
.
GetAsAtom
(
)
;
}
RefPtr
<
nsAtom
>
newValueAtom
=
valueForAfterSetAttr
.
GetAsAtom
(
)
;
nsAutoString
ns
;
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceURI
(
aNamespaceID
ns
)
;
LifecycleCallbackArgs
args
=
{
nsDependentAtomString
(
aName
)
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
?
VoidString
(
)
:
nsDependentAtomString
(
oldValueAtom
)
nsDependentAtomString
(
newValueAtom
)
(
ns
.
IsEmpty
(
)
?
VoidString
(
)
:
ns
)
}
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
Document
:
:
eAttributeChanged
this
&
args
nullptr
definition
)
;
}
if
(
aCallAfterSetAttr
)
{
rv
=
AfterSetAttr
(
aNamespaceID
aName
&
valueForAfterSetAttr
oldValue
aSubjectPrincipal
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
dir
)
{
OnSetDirAttr
(
this
&
valueForAfterSetAttr
hadValidDir
hadDirAuto
aNotify
)
;
}
}
UpdateState
(
aNotify
)
;
if
(
aNotify
)
{
MutationObservers
:
:
NotifyAttributeChanged
(
this
aNamespaceID
aName
aModType
aParsedValue
.
StoresOwnData
(
)
?
&
aParsedValue
:
nullptr
)
;
}
if
(
aFireMutation
)
{
InternalMutationEvent
mutation
(
true
eLegacyAttrModified
)
;
nsAutoString
ns
;
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceURI
(
aNamespaceID
ns
)
;
Attr
*
attrNode
=
GetAttributeNodeNSInternal
(
ns
nsDependentAtomString
(
aName
)
)
;
mutation
.
mRelatedNode
=
attrNode
;
mutation
.
mAttrName
=
aName
;
nsAutoString
newValue
;
GetAttr
(
aNamespaceID
aName
newValue
)
;
if
(
!
newValue
.
IsEmpty
(
)
)
{
mutation
.
mNewAttrValue
=
NS_Atomize
(
newValue
)
;
}
if
(
oldValue
&
&
!
oldValue
-
>
IsEmptyString
(
)
)
{
mutation
.
mPrevAttrValue
=
oldValue
-
>
GetAsAtom
(
)
;
}
mutation
.
mAttrChange
=
aModType
;
mozAutoSubtreeModified
subtree
(
OwnerDoc
(
)
this
)
;
(
new
AsyncEventDispatcher
(
this
mutation
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
return
NS_OK
;
}
bool
Element
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
lang
)
{
aResult
.
ParseAtom
(
aValue
)
;
return
true
;
}
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
_class
|
|
aAttribute
=
=
nsGkAtoms
:
:
part
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
exportparts
&
&
StaticPrefs
:
:
layout_css_shadow_parts_enabled
(
)
)
{
aResult
.
ParsePartMapping
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
id
)
{
if
(
aValue
.
IsEmpty
(
)
)
{
return
false
;
}
aResult
.
ParseAtom
(
aValue
)
;
return
true
;
}
}
return
false
;
}
bool
Element
:
:
SetAndSwapMappedAttribute
(
nsAtom
*
aName
nsAttrValue
&
aValue
bool
*
aValueWasSet
nsresult
*
aRetval
)
{
*
aRetval
=
NS_OK
;
return
false
;
}
nsresult
Element
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
_class
&
&
aValue
)
{
SetMayHaveClass
(
)
;
}
}
return
NS_OK
;
}
nsresult
Element
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
part
)
{
bool
isPart
=
!
!
aValue
;
if
(
HasPartAttribute
(
)
!
=
isPart
)
{
SetHasPartAttribute
(
isPart
)
;
if
(
ShadowRoot
*
shadow
=
GetContainingShadow
(
)
)
{
if
(
isPart
)
{
shadow
-
>
PartAdded
(
*
this
)
;
}
else
{
shadow
-
>
PartRemoved
(
*
this
)
;
}
}
}
MOZ_ASSERT
(
HasPartAttribute
(
)
=
=
isPart
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
slot
&
&
GetParent
(
)
)
{
if
(
ShadowRoot
*
shadow
=
GetParent
(
)
-
>
GetShadowRoot
(
)
)
{
shadow
-
>
MaybeReassignElement
(
*
this
)
;
}
}
}
return
NS_OK
;
}
void
Element
:
:
PreIdMaybeChange
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
)
{
if
(
aNamespaceID
!
=
kNameSpaceID_None
|
|
aName
!
=
nsGkAtoms
:
:
id
)
{
return
;
}
RemoveFromIdTable
(
)
;
}
void
Element
:
:
PostIdMaybeChange
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
)
{
if
(
aNamespaceID
!
=
kNameSpaceID_None
|
|
aName
!
=
nsGkAtoms
:
:
id
)
{
return
;
}
if
(
aValue
&
&
!
aValue
-
>
IsEmptyString
(
)
)
{
SetHasID
(
)
;
AddToIdTable
(
aValue
-
>
GetAtomValue
(
)
)
;
}
else
{
ClearHasID
(
)
;
}
}
nsresult
Element
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
CustomElementDefinition
*
definition
=
GetCustomElementDefinition
(
)
;
if
(
definition
&
&
definition
-
>
IsInObservedAttributeList
(
aName
)
)
{
nsAutoString
ns
;
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceURI
(
aNamespaceID
ns
)
;
nsAutoString
value
(
aValue
.
String
(
)
)
;
LifecycleCallbackArgs
args
=
{
nsDependentAtomString
(
aName
)
value
value
(
ns
.
IsEmpty
(
)
?
VoidString
(
)
:
ns
)
}
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
Document
:
:
eAttributeChanged
this
&
args
nullptr
definition
)
;
}
return
NS_OK
;
}
EventListenerManager
*
Element
:
:
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
{
*
aDefer
=
true
;
return
GetOrCreateListenerManager
(
)
;
}
bool
Element
:
:
GetAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
nsAString
&
aResult
)
const
{
DOMString
str
;
bool
haveAttr
=
GetAttr
(
aNameSpaceID
aName
str
)
;
str
.
ToString
(
aResult
)
;
return
haveAttr
;
}
int32_t
Element
:
:
FindAttrValueIn
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
AttrValuesArray
*
aValues
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
NS_ASSERTION
(
aValues
"
Null
value
array
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
if
(
val
)
{
for
(
int32_t
i
=
0
;
aValues
[
i
]
;
+
+
i
)
{
if
(
val
-
>
Equals
(
aValues
[
i
]
aCaseSensitive
)
)
{
return
i
;
}
}
return
ATTR_VALUE_NO_MATCH
;
}
return
ATTR_MISSING
;
}
nsresult
Element
:
:
UnsetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
bool
aNotify
)
{
NS_ASSERTION
(
nullptr
!
=
aName
"
must
have
attribute
name
"
)
;
int32_t
index
=
mAttrs
.
IndexOfAttr
(
aName
aNameSpaceID
)
;
if
(
index
<
0
)
{
return
NS_OK
;
}
Document
*
document
=
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
aNotify
)
;
if
(
aNotify
)
{
MutationObservers
:
:
NotifyAttributeWillChange
(
this
aNameSpaceID
aName
MutationEvent_Binding
:
:
REMOVAL
)
;
}
nsresult
rv
=
BeforeSetAttr
(
aNameSpaceID
aName
nullptr
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasMutationListeners
=
aNotify
&
&
nsContentUtils
:
:
HasMutationListeners
(
this
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
this
)
;
PreIdMaybeChange
(
aNameSpaceID
aName
nullptr
)
;
RefPtr
<
Attr
>
attrNode
;
if
(
hasMutationListeners
)
{
nsAutoString
ns
;
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceURI
(
aNameSpaceID
ns
)
;
attrNode
=
GetAttributeNodeNSInternal
(
ns
nsDependentAtomString
(
aName
)
)
;
}
nsDOMSlots
*
slots
=
GetExistingDOMSlots
(
)
;
if
(
slots
&
&
slots
-
>
mAttributeMap
)
{
slots
-
>
mAttributeMap
-
>
DropAttribute
(
aNameSpaceID
aName
)
;
}
nsMutationGuard
:
:
DidMutate
(
)
;
bool
hadValidDir
=
false
;
bool
hadDirAuto
=
false
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
dir
)
{
hadValidDir
=
HasValidDir
(
)
|
|
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
;
hadDirAuto
=
HasDirAuto
(
)
;
}
nsAttrValue
oldValue
;
rv
=
mAttrs
.
RemoveAttrAt
(
index
oldValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
PostIdMaybeChange
(
aNameSpaceID
aName
nullptr
)
;
CustomElementDefinition
*
definition
=
GetCustomElementDefinition
(
)
;
if
(
definition
&
&
definition
-
>
IsInObservedAttributeList
(
aName
)
)
{
nsAutoString
ns
;
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceURI
(
aNameSpaceID
ns
)
;
RefPtr
<
nsAtom
>
oldValueAtom
=
oldValue
.
GetAsAtom
(
)
;
LifecycleCallbackArgs
args
=
{
nsDependentAtomString
(
aName
)
nsDependentAtomString
(
oldValueAtom
)
VoidString
(
)
(
ns
.
IsEmpty
(
)
?
VoidString
(
)
:
ns
)
}
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
Document
:
:
eAttributeChanged
this
&
args
nullptr
definition
)
;
}
rv
=
AfterSetAttr
(
aNameSpaceID
aName
nullptr
&
oldValue
nullptr
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateState
(
aNotify
)
;
if
(
aNotify
)
{
MutationObservers
:
:
NotifyAttributeChanged
(
this
aNameSpaceID
aName
MutationEvent_Binding
:
:
REMOVAL
&
oldValue
)
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
dir
)
{
OnSetDirAttr
(
this
nullptr
hadValidDir
hadDirAuto
aNotify
)
;
}
if
(
hasMutationListeners
)
{
InternalMutationEvent
mutation
(
true
eLegacyAttrModified
)
;
mutation
.
mRelatedNode
=
attrNode
;
mutation
.
mAttrName
=
aName
;
nsAutoString
value
;
oldValue
.
ToString
(
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
mutation
.
mPrevAttrValue
=
NS_Atomize
(
value
)
;
mutation
.
mAttrChange
=
MutationEvent_Binding
:
:
REMOVAL
;
mozAutoSubtreeModified
subtree
(
OwnerDoc
(
)
this
)
;
(
new
AsyncEventDispatcher
(
this
mutation
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
return
NS_OK
;
}
void
Element
:
:
DescribeAttribute
(
uint32_t
index
nsAString
&
aOutDescription
)
const
{
mAttrs
.
AttrNameAt
(
index
)
-
>
GetQualifiedName
(
aOutDescription
)
;
aOutDescription
.
AppendLiteral
(
"
=
\
"
"
)
;
nsAutoString
value
;
mAttrs
.
AttrAt
(
index
)
-
>
ToString
(
value
)
;
for
(
uint32_t
i
=
value
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
if
(
value
[
i
-
1
]
=
=
char16_t
(
'
"
'
)
)
value
.
Insert
(
char16_t
(
'
\
\
'
)
i
-
1
)
;
}
aOutDescription
.
Append
(
value
)
;
aOutDescription
.
Append
(
'
"
'
)
;
}
#
ifdef
DEBUG
void
Element
:
:
ListAttributes
(
FILE
*
out
)
const
{
uint32_t
index
count
=
mAttrs
.
AttrCount
(
)
;
for
(
index
=
0
;
index
<
count
;
index
+
+
)
{
nsAutoString
attributeDescription
;
DescribeAttribute
(
index
attributeDescription
)
;
fputs
(
"
"
out
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
attributeDescription
)
.
get
(
)
out
)
;
}
}
void
Element
:
:
List
(
FILE
*
out
int32_t
aIndent
const
nsCString
&
aPrefix
)
const
{
int32_t
indent
;
for
(
indent
=
aIndent
;
-
-
indent
>
=
0
;
)
fputs
(
"
"
out
)
;
fputs
(
aPrefix
.
get
(
)
out
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
mNodeInfo
-
>
QualifiedName
(
)
)
.
get
(
)
out
)
;
fprintf
(
out
"
%
p
"
(
void
*
)
this
)
;
ListAttributes
(
out
)
;
fprintf
(
out
"
state
=
[
%
llx
]
"
static_cast
<
unsigned
long
long
>
(
State
(
)
.
GetInternalValue
(
)
)
)
;
fprintf
(
out
"
flags
=
[
%
08x
]
"
static_cast
<
unsigned
int
>
(
GetFlags
(
)
)
)
;
if
(
IsCommonAncestorForRangeInSelection
(
)
)
{
const
LinkedList
<
nsRange
>
*
ranges
=
GetExistingCommonAncestorRanges
(
)
;
int32_t
count
=
0
;
if
(
ranges
)
{
for
(
const
nsRange
*
r
=
ranges
-
>
getFirst
(
)
;
r
;
r
=
r
-
>
getNext
(
)
)
{
+
+
count
;
}
}
fprintf
(
out
"
ranges
:
%
d
"
count
)
;
}
fprintf
(
out
"
primaryframe
=
%
p
"
static_cast
<
void
*
>
(
GetPrimaryFrame
(
)
)
)
;
fprintf
(
out
"
refcount
=
%
"
PRIuPTR
"
<
"
mRefCnt
.
get
(
)
)
;
nsIContent
*
child
=
GetFirstChild
(
)
;
if
(
child
)
{
fputs
(
"
\
n
"
out
)
;
for
(
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
List
(
out
aIndent
+
1
)
;
}
for
(
indent
=
aIndent
;
-
-
indent
>
=
0
;
)
fputs
(
"
"
out
)
;
}
fputs
(
"
>
\
n
"
out
)
;
}
void
Element
:
:
DumpContent
(
FILE
*
out
int32_t
aIndent
bool
aDumpAll
)
const
{
int32_t
indent
;
for
(
indent
=
aIndent
;
-
-
indent
>
=
0
;
)
fputs
(
"
"
out
)
;
const
nsString
&
buf
=
mNodeInfo
-
>
QualifiedName
(
)
;
fputs
(
"
<
"
out
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
buf
)
.
get
(
)
out
)
;
if
(
aDumpAll
)
ListAttributes
(
out
)
;
fputs
(
"
>
"
out
)
;
if
(
aIndent
)
fputs
(
"
\
n
"
out
)
;
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
int32_t
indent
=
aIndent
?
aIndent
+
1
:
0
;
child
-
>
DumpContent
(
out
indent
aDumpAll
)
;
}
for
(
indent
=
aIndent
;
-
-
indent
>
=
0
;
)
fputs
(
"
"
out
)
;
fputs
(
"
<
/
"
out
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
buf
)
.
get
(
)
out
)
;
fputs
(
"
>
"
out
)
;
if
(
aIndent
)
fputs
(
"
\
n
"
out
)
;
}
#
endif
void
Element
:
:
Describe
(
nsAString
&
aOutDescription
)
const
{
aOutDescription
.
Append
(
mNodeInfo
-
>
QualifiedName
(
)
)
;
aOutDescription
.
AppendPrintf
(
"
%
p
"
(
void
*
)
this
)
;
uint32_t
index
count
=
mAttrs
.
AttrCount
(
)
;
for
(
index
=
0
;
index
<
count
;
index
+
+
)
{
aOutDescription
.
Append
(
'
'
)
;
nsAutoString
attributeDescription
;
DescribeAttribute
(
index
attributeDescription
)
;
aOutDescription
.
Append
(
attributeDescription
)
;
}
}
bool
Element
:
:
CheckHandleEventForLinksPrecondition
(
EventChainVisitor
&
aVisitor
nsIURI
*
*
aURI
)
const
{
if
(
aVisitor
.
mEventStatus
=
=
nsEventStatus_eConsumeNoDefault
|
|
(
!
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
(
aVisitor
.
mEvent
-
>
mMessage
!
=
eMouseClick
)
&
&
(
aVisitor
.
mEvent
-
>
mMessage
!
=
eKeyPress
)
&
&
(
aVisitor
.
mEvent
-
>
mMessage
!
=
eLegacyDOMActivate
)
)
|
|
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
)
{
return
false
;
}
return
IsLink
(
aURI
)
;
}
void
Element
:
:
GetEventTargetParentForLinks
(
EventChainPreVisitor
&
aVisitor
)
{
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseOver
:
case
eFocus
:
case
eMouseOut
:
case
eBlur
:
break
;
default
:
return
;
}
nsCOMPtr
<
nsIURI
>
absURI
;
if
(
!
CheckHandleEventForLinksPrecondition
(
aVisitor
getter_AddRefs
(
absURI
)
)
)
{
return
;
}
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseOver
:
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
MOZ_FALLTHROUGH
;
case
eFocus
:
{
InternalFocusEvent
*
focusEvent
=
aVisitor
.
mEvent
-
>
AsFocusEvent
(
)
;
if
(
!
focusEvent
|
|
!
focusEvent
-
>
mIsRefocus
)
{
nsAutoString
target
;
GetLinkTarget
(
target
)
;
nsContentUtils
:
:
TriggerLink
(
this
absURI
target
false
true
)
;
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
break
;
}
case
eMouseOut
:
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
MOZ_FALLTHROUGH
;
case
eBlur
:
{
nsresult
rv
=
LeaveLink
(
aVisitor
.
mPresContext
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
switch
statements
not
in
sync
"
)
;
}
}
nsresult
Element
:
:
PostHandleEventForLinks
(
EventChainPostVisitor
&
aVisitor
)
{
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseDown
:
case
eMouseClick
:
case
eLegacyDOMActivate
:
case
eKeyPress
:
break
;
default
:
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
absURI
;
if
(
!
CheckHandleEventForLinksPrecondition
(
aVisitor
getter_AddRefs
(
absURI
)
)
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseDown
:
{
if
(
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
-
>
mButton
=
=
MouseButton
:
:
eLeft
&
&
OwnerDoc
(
)
-
>
LinkHandlingEnabled
(
)
)
{
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
if
(
IsInComposedDoc
(
)
)
{
if
(
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
RefPtr
<
Element
>
kungFuDeathGrip
(
this
)
;
fm
-
>
SetFocus
(
kungFuDeathGrip
nsIFocusManager
:
:
FLAG_BYMOUSE
|
nsIFocusManager
:
:
FLAG_NOSCROLL
)
;
}
}
if
(
aVisitor
.
mPresContext
)
{
EventStateManager
:
:
SetActiveManager
(
aVisitor
.
mPresContext
-
>
EventStateManager
(
)
this
)
;
}
if
(
nsIDocShell
*
shell
=
OwnerDoc
(
)
-
>
GetDocShell
(
)
)
{
nsCOMPtr
<
nsISpeculativeConnect
>
sc
=
do_QueryInterface
(
nsContentUtils
:
:
GetIOService
(
)
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
ir
=
do_QueryInterface
(
shell
)
;
sc
-
>
SpeculativeConnect
(
absURI
NodePrincipal
(
)
ir
)
;
}
}
}
break
;
case
eMouseClick
:
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
IsLeftClickEvent
(
)
)
{
if
(
mouseEvent
-
>
IsControl
(
)
|
|
mouseEvent
-
>
IsMeta
(
)
|
|
mouseEvent
-
>
IsAlt
(
)
|
|
mouseEvent
-
>
IsShift
(
)
)
{
break
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
InternalUIEvent
actEvent
(
true
eLegacyDOMActivate
mouseEvent
)
;
actEvent
.
mDetail
=
1
;
rv
=
EventDispatcher
:
:
Dispatch
(
this
aVisitor
.
mPresContext
&
actEvent
nullptr
&
status
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
if
(
!
actEvent
.
DefaultPreventedByContent
(
)
&
&
mouseEvent
-
>
IsTrusted
(
)
&
&
mouseEvent
-
>
mInputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
&
&
mouseEvent
-
>
mInputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_UNKNOWN
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_TYPES_OF_USER_CLICKS
:
:
Link
)
;
}
}
}
break
;
}
case
eLegacyDOMActivate
:
{
if
(
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
this
)
{
nsAutoString
target
;
GetLinkTarget
(
target
)
;
const
InternalUIEvent
*
activeEvent
=
aVisitor
.
mEvent
-
>
AsUIEvent
(
)
;
MOZ_ASSERT
(
activeEvent
)
;
nsContentUtils
:
:
TriggerLink
(
this
absURI
target
true
activeEvent
-
>
IsTrustable
(
)
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
break
;
case
eKeyPress
:
{
WidgetKeyboardEvent
*
keyEvent
=
aVisitor
.
mEvent
-
>
AsKeyboardEvent
(
)
;
if
(
keyEvent
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_RETURN
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
rv
=
DispatchClickEvent
(
MOZ_KnownLive
(
aVisitor
.
mPresContext
)
keyEvent
this
false
nullptr
&
status
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
switch
statements
not
in
sync
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
rv
;
}
void
Element
:
:
GetLinkTarget
(
nsAString
&
aTarget
)
{
aTarget
.
Truncate
(
)
;
}
static
nsStaticAtom
*
const
sPropertiesToTraverseAndUnlink
[
]
=
{
nsGkAtoms
:
:
dirAutoSetBy
nullptr
}
;
nsStaticAtom
*
const
*
Element
:
:
HTMLSVGPropertiesToTraverseAndUnlink
(
)
{
return
sPropertiesToTraverseAndUnlink
;
}
nsresult
Element
:
:
CopyInnerTo
(
Element
*
aDst
ReparseAttributes
aReparse
)
{
nsresult
rv
=
aDst
-
>
mAttrs
.
EnsureCapacityToClone
(
mAttrs
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
bool
reparse
=
aReparse
=
=
ReparseAttributes
:
:
Yes
;
uint32_t
count
=
mAttrs
.
AttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
BorrowedAttrInfo
info
=
mAttrs
.
AttrInfoAt
(
i
)
;
const
nsAttrName
*
name
=
info
.
mName
;
const
nsAttrValue
*
value
=
info
.
mValue
;
if
(
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eCSSDeclaration
)
{
MOZ_ASSERT
(
name
-
>
Equals
(
nsGkAtoms
:
:
style
kNameSpaceID_None
)
)
;
nsAttrValue
valueCopy
(
*
value
)
;
rv
=
aDst
-
>
SetParsedAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
valueCopy
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
value
-
>
GetCSSDeclarationValue
(
)
-
>
SetImmutable
(
)
;
}
else
if
(
reparse
)
{
nsAutoString
valStr
;
value
-
>
ToString
(
valStr
)
;
rv
=
aDst
-
>
SetAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
valStr
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsAttrValue
valueCopy
(
*
value
)
;
rv
=
aDst
-
>
SetParsedAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
valueCopy
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
Element
*
Element
:
:
Closest
(
const
nsAString
&
aSelector
ErrorResult
&
aResult
)
{
const
RawServoSelectorList
*
list
=
ParseSelectorList
(
aSelector
aResult
)
;
if
(
!
list
)
{
return
nullptr
;
}
return
const_cast
<
Element
*
>
(
Servo_SelectorList_Closest
(
this
list
)
)
;
}
bool
Element
:
:
Matches
(
const
nsAString
&
aSelector
ErrorResult
&
aResult
)
{
const
RawServoSelectorList
*
list
=
ParseSelectorList
(
aSelector
aResult
)
;
if
(
!
list
)
{
return
false
;
}
return
Servo_SelectorList_Matches
(
this
list
)
;
}
static
const
nsAttrValue
:
:
EnumTable
kCORSAttributeTable
[
]
=
{
{
"
anonymous
"
CORS_ANONYMOUS
}
{
"
use
-
credentials
"
CORS_USE_CREDENTIALS
}
{
nullptr
0
}
}
;
void
Element
:
:
ParseCORSValue
(
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
DebugOnly
<
bool
>
success
=
aResult
.
ParseEnumValue
(
aValue
kCORSAttributeTable
false
&
kCORSAttributeTable
[
0
]
)
;
MOZ_ASSERT
(
success
)
;
}
CORSMode
Element
:
:
StringToCORSMode
(
const
nsAString
&
aValue
)
{
if
(
aValue
.
IsVoid
(
)
)
{
return
CORS_NONE
;
}
nsAttrValue
val
;
Element
:
:
ParseCORSValue
(
aValue
val
)
;
return
CORSMode
(
val
.
GetEnumValue
(
)
)
;
}
CORSMode
Element
:
:
AttrValueToCORSMode
(
const
nsAttrValue
*
aValue
)
{
if
(
!
aValue
)
{
return
CORS_NONE
;
}
return
CORSMode
(
aValue
-
>
GetEnumValue
(
)
)
;
}
static
const
char
*
GetFullscreenError
(
CallerType
aCallerType
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
!
StaticPrefs
:
:
full_screen_api_allow_trusted_requests_only
(
)
|
|
aCallerType
=
=
CallerType
:
:
System
)
{
return
nullptr
;
}
if
(
!
aDocument
-
>
HasValidTransientUserGestureActivation
(
)
)
{
return
"
FullscreenDeniedNotInputDriven
"
;
}
if
(
StaticPrefs
:
:
full_screen_api_mouse_event_allow_left_button_only
(
)
&
&
(
EventStateManager
:
:
sCurrentMouseBtn
=
=
MouseButton
:
:
eMiddle
|
|
EventStateManager
:
:
sCurrentMouseBtn
=
=
MouseButton
:
:
eRight
)
)
{
return
"
FullscreenDeniedMouseEventOnlyLeftBtn
"
;
}
return
nullptr
;
}
already_AddRefed
<
Promise
>
Element
:
:
RequestFullscreen
(
CallerType
aCallerType
ErrorResult
&
aRv
)
{
auto
request
=
FullscreenRequest
:
:
Create
(
this
aCallerType
aRv
)
;
RefPtr
<
Promise
>
promise
=
request
-
>
GetPromise
(
)
;
if
(
!
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
OwnerDoc
(
)
NS_LITERAL_STRING
(
"
fullscreen
"
)
)
)
{
request
-
>
Reject
(
"
FullscreenDeniedFeaturePolicy
"
)
;
return
promise
.
forget
(
)
;
}
if
(
const
char
*
error
=
GetFullscreenError
(
aCallerType
OwnerDoc
(
)
)
)
{
request
-
>
Reject
(
error
)
;
}
else
{
OwnerDoc
(
)
-
>
AsyncRequestFullscreen
(
std
:
:
move
(
request
)
)
;
}
return
promise
.
forget
(
)
;
}
void
Element
:
:
RequestPointerLock
(
CallerType
aCallerType
)
{
OwnerDoc
(
)
-
>
RequestPointerLock
(
this
aCallerType
)
;
}
already_AddRefed
<
Flex
>
Element
:
:
GetAsFlexContainer
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
nsFlexContainerFrame
*
flexFrame
=
nsFlexContainerFrame
:
:
GetFlexFrameWithComputedInfo
(
frame
)
;
if
(
flexFrame
)
{
RefPtr
<
Flex
>
flex
=
new
Flex
(
this
flexFrame
)
;
return
flex
.
forget
(
)
;
}
return
nullptr
;
}
void
Element
:
:
GetGridFragments
(
nsTArray
<
RefPtr
<
Grid
>
>
&
aResult
)
{
nsGridContainerFrame
*
frame
=
nsGridContainerFrame
:
:
GetGridFrameWithComputedInfo
(
GetPrimaryFrame
(
)
)
;
while
(
frame
)
{
aResult
.
AppendElement
(
new
Grid
(
this
frame
)
)
;
frame
=
static_cast
<
nsGridContainerFrame
*
>
(
frame
-
>
GetNextInFlow
(
)
)
;
}
}
already_AddRefed
<
DOMMatrixReadOnly
>
Element
:
:
GetTransformToAncestor
(
Element
&
aAncestor
)
{
nsIFrame
*
primaryFrame
=
GetPrimaryFrame
(
)
;
nsIFrame
*
ancestorFrame
=
aAncestor
.
GetPrimaryFrame
(
)
;
Matrix4x4
transform
;
if
(
primaryFrame
)
{
transform
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
primaryFrame
ancestorFrame
nsIFrame
:
:
IN_CSS_UNITS
)
.
GetMatrix
(
)
;
}
DOMMatrixReadOnly
*
matrix
=
new
DOMMatrix
(
this
transform
)
;
RefPtr
<
DOMMatrixReadOnly
>
result
(
matrix
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
DOMMatrixReadOnly
>
Element
:
:
GetTransformToParent
(
)
{
nsIFrame
*
primaryFrame
=
GetPrimaryFrame
(
)
;
Matrix4x4
transform
;
if
(
primaryFrame
)
{
nsIFrame
*
parentFrame
=
primaryFrame
-
>
GetParent
(
)
;
transform
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
primaryFrame
parentFrame
nsIFrame
:
:
IN_CSS_UNITS
)
.
GetMatrix
(
)
;
}
DOMMatrixReadOnly
*
matrix
=
new
DOMMatrix
(
this
transform
)
;
RefPtr
<
DOMMatrixReadOnly
>
result
(
matrix
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
DOMMatrixReadOnly
>
Element
:
:
GetTransformToViewport
(
)
{
nsIFrame
*
primaryFrame
=
GetPrimaryFrame
(
)
;
Matrix4x4
transform
;
if
(
primaryFrame
)
{
transform
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
primaryFrame
nsLayoutUtils
:
:
GetDisplayRootFrame
(
primaryFrame
)
nsIFrame
:
:
IN_CSS_UNITS
)
.
GetMatrix
(
)
;
}
DOMMatrixReadOnly
*
matrix
=
new
DOMMatrix
(
this
transform
)
;
RefPtr
<
DOMMatrixReadOnly
>
result
(
matrix
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
Animation
>
Element
:
:
Animate
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aError
)
{
Nullable
<
ElementOrCSSPseudoElement
>
target
;
target
.
SetValue
(
)
.
SetAsElement
(
)
=
this
;
return
Animate
(
target
aContext
aKeyframes
aOptions
aError
)
;
}
already_AddRefed
<
Animation
>
Element
:
:
Animate
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
!
aTarget
.
IsNull
(
)
&
&
(
aTarget
.
Value
(
)
.
IsElement
(
)
|
|
aTarget
.
Value
(
)
.
IsCSSPseudoElement
(
)
)
"
aTarget
should
be
initialized
"
)
;
RefPtr
<
Element
>
referenceElement
;
if
(
aTarget
.
Value
(
)
.
IsElement
(
)
)
{
referenceElement
=
&
aTarget
.
Value
(
)
.
GetAsElement
(
)
;
}
else
{
referenceElement
=
aTarget
.
Value
(
)
.
GetAsCSSPseudoElement
(
)
.
Element
(
)
;
}
nsCOMPtr
<
nsIGlobalObject
>
ownerGlobal
=
referenceElement
-
>
GetOwnerGlobal
(
)
;
if
(
!
ownerGlobal
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
GlobalObject
global
(
aContext
ownerGlobal
-
>
GetGlobalJSObject
(
)
)
;
MOZ_ASSERT
(
!
global
.
Failed
(
)
)
;
RefPtr
<
KeyframeEffect
>
effect
=
KeyframeEffect
:
:
Constructor
(
global
aTarget
aKeyframes
aOptions
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
JSAutoRealm
ar
(
aContext
global
.
Get
(
)
)
;
AnimationTimeline
*
timeline
=
referenceElement
-
>
OwnerDoc
(
)
-
>
Timeline
(
)
;
RefPtr
<
Animation
>
animation
=
Animation
:
:
Constructor
(
global
effect
Optional
<
AnimationTimeline
*
>
(
timeline
)
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
aOptions
.
IsKeyframeAnimationOptions
(
)
)
{
animation
-
>
SetId
(
aOptions
.
GetAsKeyframeAnimationOptions
(
)
.
mId
)
;
}
animation
-
>
Play
(
aError
Animation
:
:
LimitBehavior
:
:
AutoRewind
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
return
animation
.
forget
(
)
;
}
void
Element
:
:
GetAnimations
(
const
GetAnimationsOptions
&
aOptions
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
Flush
aFlush
)
{
if
(
aFlush
=
=
Flush
:
:
Yes
)
{
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
Style
false
)
)
;
}
}
Element
*
elem
=
this
;
PseudoStyleType
pseudoType
=
PseudoStyleType
:
:
NotPseudo
;
if
(
IsGeneratedContentContainerForBefore
(
)
)
{
elem
=
GetParentElement
(
)
;
pseudoType
=
PseudoStyleType
:
:
before
;
}
else
if
(
IsGeneratedContentContainerForAfter
(
)
)
{
elem
=
GetParentElement
(
)
;
pseudoType
=
PseudoStyleType
:
:
after
;
}
else
if
(
IsGeneratedContentContainerForMarker
(
)
)
{
elem
=
GetParentElement
(
)
;
pseudoType
=
PseudoStyleType
:
:
marker
;
}
if
(
!
elem
)
{
return
;
}
if
(
!
aOptions
.
mSubtree
|
|
pseudoType
=
=
PseudoStyleType
:
:
before
|
|
pseudoType
=
=
PseudoStyleType
:
:
after
|
|
pseudoType
=
=
PseudoStyleType
:
:
marker
)
{
GetAnimationsUnsorted
(
elem
pseudoType
aAnimations
)
;
}
else
{
for
(
nsIContent
*
node
=
this
;
node
;
node
=
node
-
>
GetNextNode
(
this
)
)
{
if
(
!
node
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
element
=
node
-
>
AsElement
(
)
;
Element
:
:
GetAnimationsUnsorted
(
element
PseudoStyleType
:
:
NotPseudo
aAnimations
)
;
Element
:
:
GetAnimationsUnsorted
(
element
PseudoStyleType
:
:
before
aAnimations
)
;
Element
:
:
GetAnimationsUnsorted
(
element
PseudoStyleType
:
:
after
aAnimations
)
;
Element
:
:
GetAnimationsUnsorted
(
element
PseudoStyleType
:
:
marker
aAnimations
)
;
}
}
aAnimations
.
Sort
(
AnimationPtrComparator
<
RefPtr
<
Animation
>
>
(
)
)
;
}
void
Element
:
:
GetAnimationsUnsorted
(
Element
*
aElement
PseudoStyleType
aPseudoType
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
{
MOZ_ASSERT
(
aPseudoType
=
=
PseudoStyleType
:
:
NotPseudo
|
|
aPseudoType
=
=
PseudoStyleType
:
:
after
|
|
aPseudoType
=
=
PseudoStyleType
:
:
before
|
|
aPseudoType
=
=
PseudoStyleType
:
:
marker
"
Unsupported
pseudo
type
"
)
;
MOZ_ASSERT
(
aElement
"
Null
element
"
)
;
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSet
(
aElement
aPseudoType
)
;
if
(
!
effects
)
{
return
;
}
for
(
KeyframeEffect
*
effect
:
*
effects
)
{
MOZ_ASSERT
(
effect
&
&
effect
-
>
GetAnimation
(
)
"
Only
effects
associated
with
an
animation
should
be
"
"
added
to
an
element
'
s
effect
set
"
)
;
Animation
*
animation
=
effect
-
>
GetAnimation
(
)
;
MOZ_ASSERT
(
animation
-
>
IsRelevant
(
)
"
Only
relevant
animations
should
be
added
to
an
element
'
s
"
"
effect
set
"
)
;
aAnimations
.
AppendElement
(
animation
)
;
}
}
void
Element
:
:
GetInnerHTML
(
nsAString
&
aInnerHTML
OOMReporter
&
aError
)
{
GetMarkup
(
false
aInnerHTML
)
;
}
void
Element
:
:
SetInnerHTML
(
const
nsAString
&
aInnerHTML
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
{
SetInnerHTMLInternal
(
aInnerHTML
aError
)
;
}
void
Element
:
:
GetOuterHTML
(
nsAString
&
aOuterHTML
)
{
GetMarkup
(
true
aOuterHTML
)
;
}
void
Element
:
:
SetOuterHTML
(
const
nsAString
&
aOuterHTML
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
if
(
parent
-
>
NodeType
(
)
=
=
DOCUMENT_NODE
)
{
aError
.
Throw
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
return
;
}
if
(
OwnerDoc
(
)
-
>
IsHTMLDocument
(
)
)
{
nsAtom
*
localName
;
int32_t
namespaceID
;
if
(
parent
-
>
IsElement
(
)
)
{
localName
=
parent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
namespaceID
=
parent
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
;
}
else
{
NS_ASSERTION
(
parent
-
>
NodeType
(
)
=
=
DOCUMENT_FRAGMENT_NODE
"
How
come
the
parent
isn
'
t
a
document
a
fragment
or
an
element
?
"
)
;
localName
=
nsGkAtoms
:
:
body
;
namespaceID
=
kNameSpaceID_XHTML
;
}
RefPtr
<
DocumentFragment
>
fragment
=
new
DocumentFragment
(
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
)
;
nsContentUtils
:
:
ParseFragmentHTML
(
aOuterHTML
fragment
localName
namespaceID
OwnerDoc
(
)
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
true
)
;
parent
-
>
ReplaceChild
(
*
fragment
*
this
aError
)
;
return
;
}
nsCOMPtr
<
nsINode
>
context
;
if
(
parent
-
>
IsElement
(
)
)
{
context
=
parent
;
}
else
{
NS_ASSERTION
(
parent
-
>
NodeType
(
)
=
=
DOCUMENT_FRAGMENT_NODE
"
How
come
the
parent
isn
'
t
a
document
a
fragment
or
an
element
?
"
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
info
=
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
body
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
context
=
NS_NewHTMLBodyElement
(
info
.
forget
(
)
FROM_PARSER_FRAGMENT
)
;
}
RefPtr
<
DocumentFragment
>
fragment
=
nsContentUtils
:
:
CreateContextualFragment
(
context
aOuterHTML
true
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
parent
-
>
ReplaceChild
(
*
fragment
*
this
aError
)
;
}
enum
nsAdjacentPosition
{
eBeforeBegin
eAfterBegin
eBeforeEnd
eAfterEnd
}
;
void
Element
:
:
InsertAdjacentHTML
(
const
nsAString
&
aPosition
const
nsAString
&
aText
ErrorResult
&
aError
)
{
nsAdjacentPosition
position
;
if
(
aPosition
.
LowerCaseEqualsLiteral
(
"
beforebegin
"
)
)
{
position
=
eBeforeBegin
;
}
else
if
(
aPosition
.
LowerCaseEqualsLiteral
(
"
afterbegin
"
)
)
{
position
=
eAfterBegin
;
}
else
if
(
aPosition
.
LowerCaseEqualsLiteral
(
"
beforeend
"
)
)
{
position
=
eBeforeEnd
;
}
else
if
(
aPosition
.
LowerCaseEqualsLiteral
(
"
afterend
"
)
)
{
position
=
eAfterEnd
;
}
else
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
nsCOMPtr
<
nsIContent
>
destination
;
if
(
position
=
=
eBeforeBegin
|
|
position
=
=
eAfterEnd
)
{
destination
=
GetParent
(
)
;
if
(
!
destination
)
{
aError
.
Throw
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
return
;
}
}
else
{
destination
=
this
;
}
Document
*
doc
=
OwnerDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
doc
true
)
;
nsAutoScriptLoaderDisabler
sld
(
doc
)
;
mozAutoSubtreeModified
subtree
(
doc
nullptr
)
;
if
(
doc
-
>
IsHTMLDocument
(
)
&
&
!
OwnerDoc
(
)
-
>
MayHaveDOMMutationObservers
(
)
&
&
(
position
=
=
eBeforeEnd
|
|
(
position
=
=
eAfterEnd
&
&
!
GetNextSibling
(
)
)
|
|
(
position
=
=
eAfterBegin
&
&
!
GetFirstChild
(
)
)
)
)
{
int32_t
oldChildCount
=
destination
-
>
GetChildCount
(
)
;
int32_t
contextNs
=
destination
-
>
GetNameSpaceID
(
)
;
nsAtom
*
contextLocal
=
destination
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
contextLocal
=
=
nsGkAtoms
:
:
html
&
&
contextNs
=
=
kNameSpaceID_XHTML
)
{
contextLocal
=
nsGkAtoms
:
:
body
;
}
aError
=
nsContentUtils
:
:
ParseFragmentHTML
(
aText
destination
contextLocal
contextNs
doc
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
true
)
;
nsContentUtils
:
:
FireMutationEventsForDirectParsing
(
doc
destination
oldChildCount
)
;
return
;
}
RefPtr
<
DocumentFragment
>
fragment
=
nsContentUtils
:
:
CreateContextualFragment
(
destination
aText
true
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsAutoMutationBatch
mb
(
destination
true
false
)
;
switch
(
position
)
{
case
eBeforeBegin
:
destination
-
>
InsertBefore
(
*
fragment
this
aError
)
;
break
;
case
eAfterBegin
:
static_cast
<
nsINode
*
>
(
this
)
-
>
InsertBefore
(
*
fragment
GetFirstChild
(
)
aError
)
;
break
;
case
eBeforeEnd
:
static_cast
<
nsINode
*
>
(
this
)
-
>
AppendChild
(
*
fragment
aError
)
;
break
;
case
eAfterEnd
:
destination
-
>
InsertBefore
(
*
fragment
GetNextSibling
(
)
aError
)
;
break
;
}
}
nsINode
*
Element
:
:
InsertAdjacent
(
const
nsAString
&
aWhere
nsINode
*
aNode
ErrorResult
&
aError
)
{
if
(
aWhere
.
LowerCaseEqualsLiteral
(
"
beforebegin
"
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
parent
-
>
InsertBefore
(
*
aNode
this
aError
)
;
}
else
if
(
aWhere
.
LowerCaseEqualsLiteral
(
"
afterbegin
"
)
)
{
nsCOMPtr
<
nsINode
>
refNode
=
GetFirstChild
(
)
;
static_cast
<
nsINode
*
>
(
this
)
-
>
InsertBefore
(
*
aNode
refNode
aError
)
;
}
else
if
(
aWhere
.
LowerCaseEqualsLiteral
(
"
beforeend
"
)
)
{
static_cast
<
nsINode
*
>
(
this
)
-
>
AppendChild
(
*
aNode
aError
)
;
}
else
if
(
aWhere
.
LowerCaseEqualsLiteral
(
"
afterend
"
)
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
refNode
=
GetNextSibling
(
)
;
parent
-
>
InsertBefore
(
*
aNode
refNode
aError
)
;
}
else
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
nullptr
;
}
return
aError
.
Failed
(
)
?
nullptr
:
aNode
;
}
Element
*
Element
:
:
InsertAdjacentElement
(
const
nsAString
&
aWhere
Element
&
aElement
ErrorResult
&
aError
)
{
nsINode
*
newNode
=
InsertAdjacent
(
aWhere
&
aElement
aError
)
;
MOZ_ASSERT
(
!
newNode
|
|
newNode
-
>
IsElement
(
)
)
;
return
newNode
?
newNode
-
>
AsElement
(
)
:
nullptr
;
}
void
Element
:
:
InsertAdjacentText
(
const
nsAString
&
aWhere
const
nsAString
&
aData
ErrorResult
&
aError
)
{
RefPtr
<
nsTextNode
>
textNode
=
OwnerDoc
(
)
-
>
CreateTextNode
(
aData
)
;
InsertAdjacent
(
aWhere
textNode
aError
)
;
}
TextEditor
*
Element
:
:
GetTextEditorInternal
(
)
{
TextControlElement
*
textControlElement
=
TextControlElement
:
:
FromNode
(
this
)
;
return
textControlElement
?
MOZ_KnownLive
(
textControlElement
)
-
>
GetTextEditor
(
)
:
nullptr
;
}
nsresult
Element
:
:
SetBoolAttr
(
nsAtom
*
aAttr
bool
aValue
)
{
if
(
aValue
)
{
return
SetAttr
(
kNameSpaceID_None
aAttr
EmptyString
(
)
true
)
;
}
return
UnsetAttr
(
kNameSpaceID_None
aAttr
true
)
;
}
void
Element
:
:
GetEnumAttr
(
nsAtom
*
aAttr
const
char
*
aDefault
nsAString
&
aResult
)
const
{
GetEnumAttr
(
aAttr
aDefault
aDefault
aResult
)
;
}
void
Element
:
:
GetEnumAttr
(
nsAtom
*
aAttr
const
char
*
aDefaultMissing
const
char
*
aDefaultInvalid
nsAString
&
aResult
)
const
{
const
nsAttrValue
*
attrVal
=
mAttrs
.
GetAttr
(
aAttr
)
;
aResult
.
Truncate
(
)
;
if
(
!
attrVal
)
{
if
(
aDefaultMissing
)
{
AppendASCIItoUTF16
(
nsDependentCString
(
aDefaultMissing
)
aResult
)
;
}
else
{
SetDOMStringToNull
(
aResult
)
;
}
}
else
{
if
(
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
attrVal
-
>
GetEnumString
(
aResult
true
)
;
}
else
if
(
aDefaultInvalid
)
{
AppendASCIItoUTF16
(
nsDependentCString
(
aDefaultInvalid
)
aResult
)
;
}
}
}
void
Element
:
:
SetOrRemoveNullableStringAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
if
(
DOMStringIsNull
(
aValue
)
)
{
UnsetAttr
(
aName
aError
)
;
}
else
{
SetAttr
(
aName
aValue
aError
)
;
}
}
Directionality
Element
:
:
GetComputedDirectionality
(
)
const
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
return
frame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_LTR
?
eDir_LTR
:
eDir_RTL
;
}
return
GetDirectionality
(
)
;
}
float
Element
:
:
FontSizeInflation
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
-
1
.
0
;
}
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
frame
-
>
PresContext
(
)
)
)
{
return
nsLayoutUtils
:
:
FontSizeInflationFor
(
frame
)
;
}
return
1
.
0
;
}
ReferrerPolicy
Element
:
:
GetReferrerPolicyAsEnum
(
)
{
if
(
IsHTMLElement
(
)
)
{
const
nsAttrValue
*
referrerValue
=
GetParsedAttr
(
nsGkAtoms
:
:
referrerpolicy
)
;
return
ReferrerPolicyFromAttr
(
referrerValue
)
;
}
return
ReferrerPolicy
:
:
_empty
;
}
ReferrerPolicy
Element
:
:
ReferrerPolicyFromAttr
(
const
nsAttrValue
*
aValue
)
{
if
(
aValue
&
&
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
return
ReferrerPolicy
(
aValue
-
>
GetEnumValue
(
)
)
;
}
return
ReferrerPolicy
:
:
_empty
;
}
already_AddRefed
<
nsDOMStringMap
>
Element
:
:
Dataset
(
)
{
nsDOMSlots
*
slots
=
DOMSlots
(
)
;
if
(
!
slots
-
>
mDataset
)
{
slots
-
>
mDataset
=
new
nsDOMStringMap
(
this
)
;
}
RefPtr
<
nsDOMStringMap
>
ret
=
slots
-
>
mDataset
;
return
ret
.
forget
(
)
;
}
void
Element
:
:
ClearDataset
(
)
{
nsDOMSlots
*
slots
=
GetExistingDOMSlots
(
)
;
MOZ_ASSERT
(
slots
&
&
slots
-
>
mDataset
"
Slots
should
exist
and
dataset
should
not
be
null
.
"
)
;
slots
-
>
mDataset
=
nullptr
;
}
enum
nsPreviousIntersectionThreshold
{
eUninitialized
=
-
2
eNonIntersecting
=
-
1
}
;
static
void
IntersectionObserverPropertyDtor
(
void
*
aObject
nsAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
{
Element
*
element
=
static_cast
<
Element
*
>
(
aObject
)
;
IntersectionObserverList
*
observers
=
static_cast
<
IntersectionObserverList
*
>
(
aPropertyValue
)
;
for
(
auto
iter
=
observers
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DOMIntersectionObserver
*
observer
=
iter
.
Key
(
)
;
observer
-
>
UnlinkTarget
(
*
element
)
;
}
delete
observers
;
}
void
Element
:
:
RegisterIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
{
IntersectionObserverList
*
observers
=
static_cast
<
IntersectionObserverList
*
>
(
GetProperty
(
nsGkAtoms
:
:
intersectionobserverlist
)
)
;
if
(
!
observers
)
{
observers
=
new
IntersectionObserverList
(
)
;
observers
-
>
Put
(
aObserver
eUninitialized
)
;
SetProperty
(
nsGkAtoms
:
:
intersectionobserverlist
observers
IntersectionObserverPropertyDtor
true
)
;
return
;
}
observers
-
>
LookupForAdd
(
aObserver
)
.
OrInsert
(
[
]
(
)
{
return
eUninitialized
;
}
)
;
}
void
Element
:
:
UnregisterIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
{
IntersectionObserverList
*
observers
=
static_cast
<
IntersectionObserverList
*
>
(
GetProperty
(
nsGkAtoms
:
:
intersectionobserverlist
)
)
;
if
(
observers
)
{
observers
-
>
Remove
(
aObserver
)
;
}
}
void
Element
:
:
UnlinkIntersectionObservers
(
)
{
IntersectionObserverList
*
observers
=
static_cast
<
IntersectionObserverList
*
>
(
GetProperty
(
nsGkAtoms
:
:
intersectionobserverlist
)
)
;
if
(
!
observers
)
{
return
;
}
for
(
auto
iter
=
observers
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DOMIntersectionObserver
*
observer
=
iter
.
Key
(
)
;
observer
-
>
UnlinkTarget
(
*
this
)
;
}
observers
-
>
Clear
(
)
;
}
bool
Element
:
:
UpdateIntersectionObservation
(
DOMIntersectionObserver
*
aObserver
int32_t
aThreshold
)
{
auto
*
observers
=
static_cast
<
IntersectionObserverList
*
>
(
GetProperty
(
nsGkAtoms
:
:
intersectionobserverlist
)
)
;
if
(
!
observers
)
{
return
false
;
}
bool
updated
=
false
;
if
(
auto
entry
=
observers
-
>
Lookup
(
aObserver
)
)
{
updated
=
entry
.
Data
(
)
!
=
aThreshold
;
entry
.
Data
(
)
=
aThreshold
;
}
return
updated
;
}
template
<
class
T
>
void
Element
:
:
GetCustomInterface
(
nsGetterAddRefs
<
T
>
aResult
)
{
nsCOMPtr
<
nsISupports
>
iface
=
CustomElementRegistry
:
:
CallGetCustomInterface
(
this
NS_GET_TEMPLATE_IID
(
T
)
)
;
if
(
iface
)
{
if
(
NS_SUCCEEDED
(
CallQueryInterface
(
iface
static_cast
<
T
*
*
>
(
aResult
)
)
)
)
{
return
;
}
}
}
void
Element
:
:
ClearServoData
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
aDoc
)
;
if
(
HasServoData
(
)
)
{
Servo_Element_ClearData
(
this
)
;
}
else
{
UnsetFlags
(
kAllServoDescendantBits
|
NODE_NEEDS_FRAME
)
;
}
if
(
aDoc
-
>
GetServoRestyleRoot
(
)
=
=
this
)
{
aDoc
-
>
ClearServoRestyleRoot
(
)
;
}
}
void
Element
:
:
SetCustomElementData
(
CustomElementData
*
aData
)
{
SetHasCustomElementData
(
)
;
if
(
aData
-
>
mState
!
=
CustomElementData
:
:
State
:
:
eCustom
)
{
SetDefined
(
false
)
;
}
nsExtendedDOMSlots
*
slots
=
ExtendedDOMSlots
(
)
;
MOZ_ASSERT
(
!
slots
-
>
mCustomElementData
"
Custom
element
data
may
not
be
changed
once
set
.
"
)
;
#
if
DEBUG
if
(
NodeInfo
(
)
-
>
NamespaceID
(
)
=
=
kNameSpaceID_XUL
)
{
nsAtom
*
name
=
NodeInfo
(
)
-
>
NameAtom
(
)
;
nsAtom
*
type
=
aData
-
>
GetCustomElementType
(
)
;
if
(
nsContentUtils
:
:
IsNameWithDash
(
name
)
)
{
MOZ_ASSERT
(
type
=
=
name
)
;
}
else
{
if
(
type
!
=
name
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsNameWithDash
(
type
)
)
;
}
}
}
#
endif
slots
-
>
mCustomElementData
=
aData
;
}
CustomElementDefinition
*
Element
:
:
GetCustomElementDefinition
(
)
const
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
if
(
!
data
)
{
return
nullptr
;
}
return
data
-
>
GetCustomElementDefinition
(
)
;
}
void
Element
:
:
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
MOZ_ASSERT
(
data
)
;
data
-
>
SetCustomElementDefinition
(
aDefinition
)
;
}
already_AddRefed
<
nsIDOMXULButtonElement
>
Element
:
:
AsXULButton
(
)
{
nsCOMPtr
<
nsIDOMXULButtonElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULContainerElement
>
Element
:
:
AsXULContainer
(
)
{
nsCOMPtr
<
nsIDOMXULContainerElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULContainerItemElement
>
Element
:
:
AsXULContainerItem
(
)
{
nsCOMPtr
<
nsIDOMXULContainerItemElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULControlElement
>
Element
:
:
AsXULControl
(
)
{
nsCOMPtr
<
nsIDOMXULControlElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULMenuListElement
>
Element
:
:
AsXULMenuList
(
)
{
nsCOMPtr
<
nsIDOMXULMenuListElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULMultiSelectControlElement
>
Element
:
:
AsXULMultiSelectControl
(
)
{
nsCOMPtr
<
nsIDOMXULMultiSelectControlElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULRadioGroupElement
>
Element
:
:
AsXULRadioGroup
(
)
{
nsCOMPtr
<
nsIDOMXULRadioGroupElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULRelatedElement
>
Element
:
:
AsXULRelated
(
)
{
nsCOMPtr
<
nsIDOMXULRelatedElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULSelectControlElement
>
Element
:
:
AsXULSelectControl
(
)
{
nsCOMPtr
<
nsIDOMXULSelectControlElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIDOMXULSelectControlItemElement
>
Element
:
:
AsXULSelectControlItem
(
)
{
nsCOMPtr
<
nsIDOMXULSelectControlItemElement
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIBrowser
>
Element
:
:
AsBrowser
(
)
{
nsCOMPtr
<
nsIBrowser
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
already_AddRefed
<
nsIAutoCompletePopup
>
Element
:
:
AsAutoCompletePopup
(
)
{
nsCOMPtr
<
nsIAutoCompletePopup
>
value
;
GetCustomInterface
(
getter_AddRefs
(
value
)
)
;
return
value
.
forget
(
)
;
}
MOZ_DEFINE_MALLOC_SIZE_OF
(
ServoElementMallocSizeOf
)
MOZ_DEFINE_MALLOC_ENCLOSING_SIZE_OF
(
ServoElementMallocEnclosingSizeOf
)
void
Element
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
FragmentOrElement
:
:
AddSizeOfExcludingThis
(
aSizes
aNodeSize
)
;
*
aNodeSize
+
=
mAttrs
.
SizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
if
(
HasServoData
(
)
)
{
aSizes
.
mLayoutElementDataObjects
+
=
aSizes
.
mState
.
mMallocSizeOf
(
mServoData
.
Get
(
)
)
;
*
aNodeSize
+
=
Servo_Element_SizeOfExcludingThisAndCVs
(
ServoElementMallocSizeOf
ServoElementMallocEnclosingSizeOf
&
aSizes
.
mState
.
mSeenPtrs
this
)
;
if
(
auto
*
style
=
Servo_Element_GetMaybeOutOfDateStyle
(
this
)
)
{
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
style
)
)
{
style
-
>
AddSizeOfIncludingThis
(
aSizes
&
aSizes
.
mLayoutComputedValuesDom
)
;
}
for
(
size_t
i
=
0
;
i
<
PseudoStyle
:
:
kEagerPseudoCount
;
i
+
+
)
{
if
(
auto
*
style
=
Servo_Element_GetMaybeOutOfDatePseudoStyle
(
this
i
)
)
{
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
style
)
)
{
style
-
>
AddSizeOfIncludingThis
(
aSizes
&
aSizes
.
mLayoutComputedValuesDom
)
;
}
}
}
}
}
}
#
ifdef
DEBUG
static
bool
BitsArePropagated
(
const
Element
*
aElement
uint32_t
aBits
nsINode
*
aRestyleRoot
)
{
const
Element
*
curr
=
aElement
;
while
(
curr
)
{
if
(
curr
=
=
aRestyleRoot
)
{
return
true
;
}
if
(
!
curr
-
>
HasAllFlags
(
aBits
)
)
{
return
false
;
}
nsINode
*
parentNode
=
curr
-
>
GetParentNode
(
)
;
curr
=
curr
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
MOZ_ASSERT_IF
(
!
curr
parentNode
=
=
aElement
-
>
OwnerDoc
(
)
|
|
parentNode
=
=
parentNode
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
)
;
}
return
true
;
}
#
endif
static
inline
void
AssertNoBitsPropagatedFrom
(
nsINode
*
aRoot
)
{
#
ifdef
DEBUG
if
(
!
aRoot
|
|
!
aRoot
-
>
IsElement
(
)
)
{
return
;
}
auto
*
element
=
aRoot
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
while
(
element
)
{
MOZ_ASSERT
(
!
element
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
)
;
element
=
element
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
}
#
endif
}
static
inline
Element
*
PropagateBits
(
Element
*
aElement
uint32_t
aBits
nsINode
*
aStopAt
uint32_t
aBitsToStopAt
)
{
Element
*
curr
=
aElement
;
while
(
curr
&
&
!
curr
-
>
HasAllFlags
(
aBitsToStopAt
)
)
{
curr
-
>
SetFlags
(
aBits
)
;
if
(
curr
=
=
aStopAt
)
{
break
;
}
curr
=
curr
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
}
if
(
aBitsToStopAt
!
=
aBits
&
&
curr
)
{
curr
-
>
SetFlags
(
aBits
)
;
}
return
curr
;
}
static
void
NoteDirtyElement
(
Element
*
aElement
uint32_t
aBits
)
{
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
)
;
Document
*
doc
=
aElement
-
>
GetComposedDoc
(
)
;
nsINode
*
existingRoot
=
doc
-
>
GetServoRestyleRoot
(
)
;
if
(
existingRoot
=
=
aElement
)
{
doc
-
>
SetServoRestyleRootDirtyBits
(
doc
-
>
GetServoRestyleRootDirtyBits
(
)
|
aBits
)
;
return
;
}
nsINode
*
parent
=
aElement
-
>
GetFlattenedTreeParentNodeForStyle
(
)
;
if
(
!
parent
)
{
return
;
}
if
(
MOZ_LIKELY
(
parent
-
>
IsElement
(
)
)
)
{
if
(
!
parent
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
{
return
;
}
if
(
parent
-
>
HasAllFlags
(
aBits
)
)
{
return
;
}
if
(
Servo_Element_IsDisplayNone
(
parent
-
>
AsElement
(
)
)
)
{
return
;
}
}
if
(
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
MOZ_ASSERT
(
parent
-
>
IsElement
(
)
|
|
parent
=
=
doc
)
;
AssertNoBitsPropagatedFrom
(
existingRoot
)
;
if
(
!
existingRoot
)
{
doc
-
>
SetServoRestyleRoot
(
aElement
aBits
)
;
return
;
}
const
bool
reachedDocRoot
=
!
parent
-
>
IsElement
(
)
|
|
!
PropagateBits
(
parent
-
>
AsElement
(
)
aBits
existingRoot
aBits
)
;
uint32_t
existingBits
=
doc
-
>
GetServoRestyleRootDirtyBits
(
)
;
if
(
!
reachedDocRoot
|
|
existingRoot
=
=
doc
)
{
doc
-
>
SetServoRestyleRoot
(
existingRoot
existingBits
|
aBits
)
;
}
else
{
Element
*
rootParent
=
existingRoot
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
if
(
Element
*
commonAncestor
=
PropagateBits
(
rootParent
existingBits
aElement
aBits
)
)
{
MOZ_ASSERT
(
commonAncestor
=
=
aElement
|
|
commonAncestor
=
=
nsContentUtils
:
:
GetCommonFlattenedTreeAncestorForStyle
(
aElement
rootParent
)
)
;
doc
-
>
SetServoRestyleRoot
(
commonAncestor
existingBits
|
aBits
)
;
Element
*
curr
=
commonAncestor
;
while
(
(
curr
=
curr
-
>
GetFlattenedTreeParentElementForStyle
(
)
)
)
{
MOZ_ASSERT
(
curr
-
>
HasAllFlags
(
aBits
)
)
;
curr
-
>
UnsetFlags
(
aBits
)
;
}
AssertNoBitsPropagatedFrom
(
commonAncestor
)
;
}
else
{
doc
-
>
SetServoRestyleRoot
(
doc
existingBits
|
aBits
)
;
}
}
MOZ_ASSERT
(
aElement
=
=
doc
-
>
GetServoRestyleRoot
(
)
|
|
!
doc
-
>
GetServoRestyleRoot
(
)
-
>
IsElement
(
)
|
|
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOfForStyle
(
aElement
doc
-
>
GetServoRestyleRoot
(
)
)
)
;
MOZ_ASSERT
(
aElement
=
=
doc
-
>
GetServoRestyleRoot
(
)
|
|
!
doc
-
>
GetServoRestyleRoot
(
)
-
>
IsElement
(
)
|
|
!
parent
-
>
IsElement
(
)
|
|
BitsArePropagated
(
parent
-
>
AsElement
(
)
aBits
doc
-
>
GetServoRestyleRoot
(
)
)
)
;
MOZ_ASSERT
(
doc
-
>
GetServoRestyleRootDirtyBits
(
)
&
aBits
)
;
}
void
Element
:
:
NoteDirtySubtreeForServo
(
)
{
MOZ_ASSERT
(
IsInComposedDoc
(
)
)
;
MOZ_ASSERT
(
HasServoData
(
)
)
;
Document
*
doc
=
GetComposedDoc
(
)
;
nsINode
*
existingRoot
=
doc
-
>
GetServoRestyleRoot
(
)
;
uint32_t
existingBits
=
existingRoot
?
doc
-
>
GetServoRestyleRootDirtyBits
(
)
:
0
;
if
(
existingRoot
&
&
existingRoot
-
>
IsElement
(
)
&
&
existingRoot
!
=
this
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOfForStyle
(
existingRoot
-
>
AsElement
(
)
this
)
)
{
PropagateBits
(
existingRoot
-
>
AsElement
(
)
-
>
GetFlattenedTreeParentElementForStyle
(
)
existingBits
this
existingBits
)
;
doc
-
>
ClearServoRestyleRoot
(
)
;
}
NoteDirtyElement
(
this
existingBits
|
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
Element
:
:
NoteDirtyForServo
(
)
{
NoteDirtyElement
(
this
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
Element
:
:
NoteAnimationOnlyDirtyForServo
(
)
{
NoteDirtyElement
(
this
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
Element
:
:
NoteDescendantsNeedFramesForServo
(
)
{
NoteDirtyElement
(
this
NODE_DESCENDANTS_NEED_FRAMES
)
;
SetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
}
double
Element
:
:
FirstLineBoxBSize
(
)
const
{
const
nsBlockFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
!
frame
)
{
return
0
.
0
;
}
nsBlockFrame
:
:
ConstLineIterator
line
=
frame
-
>
LinesBegin
(
)
;
nsBlockFrame
:
:
ConstLineIterator
lineEnd
=
frame
-
>
LinesEnd
(
)
;
return
line
!
=
lineEnd
?
nsPresContext
:
:
AppUnitsToDoubleCSSPixels
(
line
-
>
BSize
(
)
)
:
0
.
0
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
Element
:
:
AssertInvariantsOnNodeInfoChange
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsInComposedDoc
(
)
)
;
if
(
nsCOMPtr
<
Link
>
link
=
do_QueryInterface
(
this
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
link
-
>
HasPendingLinkUpdate
(
)
)
;
}
}
#
endif
}
}
