#
include
"
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetList
.
h
"
#
include
"
nsDocument
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsSVGUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
DocumentOrShadowRoot
:
:
DocumentOrShadowRoot
(
mozilla
:
:
dom
:
:
ShadowRoot
&
aShadowRoot
)
:
mAsNode
(
aShadowRoot
)
mKind
(
Kind
:
:
ShadowRoot
)
{
}
DocumentOrShadowRoot
:
:
DocumentOrShadowRoot
(
nsIDocument
&
aDoc
)
:
mAsNode
(
aDoc
)
mKind
(
Kind
:
:
Document
)
{
}
DocumentOrShadowRoot
:
:
~
DocumentOrShadowRoot
(
)
{
for
(
StyleSheet
*
sheet
:
mStyleSheets
)
{
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
}
}
StyleSheetList
&
DocumentOrShadowRoot
:
:
EnsureDOMStyleSheets
(
)
{
if
(
!
mDOMStyleSheets
)
{
mDOMStyleSheets
=
new
StyleSheetList
(
*
this
)
;
}
return
*
mDOMStyleSheets
;
}
void
DocumentOrShadowRoot
:
:
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
aSheet
)
{
aSheet
.
SetAssociatedDocumentOrShadowRoot
(
this
StyleSheet
:
:
OwnedByDocumentOrShadowRoot
)
;
mStyleSheets
.
InsertElementAt
(
aIndex
&
aSheet
)
;
}
already_AddRefed
<
StyleSheet
>
DocumentOrShadowRoot
:
:
RemoveSheet
(
StyleSheet
&
aSheet
)
{
auto
index
=
mStyleSheets
.
IndexOf
(
&
aSheet
)
;
if
(
index
=
=
mStyleSheets
.
NoIndex
)
{
return
nullptr
;
}
RefPtr
<
StyleSheet
>
sheet
=
std
:
:
move
(
mStyleSheets
[
index
]
)
;
mStyleSheets
.
RemoveElementAt
(
index
)
;
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
return
sheet
.
forget
(
)
;
}
Element
*
DocumentOrShadowRoot
:
:
GetElementById
(
const
nsAString
&
aElementId
)
{
if
(
MOZ_UNLIKELY
(
aElementId
.
IsEmpty
(
)
)
)
{
nsContentUtils
:
:
ReportEmptyGetElementByIdArg
(
AsNode
(
)
.
OwnerDoc
(
)
)
;
return
nullptr
;
}
if
(
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aElementId
)
)
{
if
(
Element
*
el
=
entry
-
>
GetIdElement
(
)
)
{
return
el
;
}
}
return
nullptr
;
}
already_AddRefed
<
nsContentList
>
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
ErrorResult
rv
;
RefPtr
<
nsContentList
>
list
=
GetElementsByTagNameNS
(
aNamespaceURI
aLocalName
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
list
.
forget
(
)
;
}
already_AddRefed
<
nsContentList
>
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
mozilla
:
:
ErrorResult
&
aResult
)
{
int32_t
nameSpaceId
=
kNameSpaceID_Wildcard
;
if
(
!
aNamespaceURI
.
EqualsLiteral
(
"
*
"
)
)
{
aResult
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
RegisterNameSpace
(
aNamespaceURI
nameSpaceId
)
;
if
(
aResult
.
Failed
(
)
)
{
return
nullptr
;
}
}
NS_ASSERTION
(
nameSpaceId
!
=
kNameSpaceID_Unknown
"
Unexpected
namespace
ID
!
"
)
;
return
NS_GetContentList
(
&
AsNode
(
)
nameSpaceId
aLocalName
)
;
}
already_AddRefed
<
nsContentList
>
DocumentOrShadowRoot
:
:
GetElementsByClassName
(
const
nsAString
&
aClasses
)
{
return
nsContentUtils
:
:
GetElementsByClassName
(
&
AsNode
(
)
aClasses
)
;
}
nsIContent
*
DocumentOrShadowRoot
:
:
Retarget
(
nsIContent
*
aContent
)
const
{
for
(
nsIContent
*
cur
=
aContent
;
cur
;
cur
=
cur
-
>
GetContainingShadowHost
(
)
)
{
if
(
cur
-
>
SubtreeRoot
(
)
=
=
&
AsNode
(
)
)
{
return
cur
;
}
}
return
nullptr
;
}
Element
*
DocumentOrShadowRoot
:
:
GetRetargetedFocusedElement
(
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
AsNode
(
)
.
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsIContent
*
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
if
(
focusedContent
&
&
focusedContent
-
>
OwnerDoc
(
)
=
=
AsNode
(
)
.
OwnerDoc
(
)
)
{
if
(
focusedContent
-
>
ChromeOnlyAccess
(
)
)
{
focusedContent
=
focusedContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
if
(
focusedContent
)
{
if
(
!
nsDocument
:
:
IsShadowDOMEnabled
(
focusedContent
)
)
{
return
focusedContent
-
>
AsElement
(
)
;
}
if
(
nsIContent
*
retarget
=
Retarget
(
focusedContent
)
)
{
return
retarget
-
>
AsElement
(
)
;
}
}
}
}
return
nullptr
;
}
Element
*
DocumentOrShadowRoot
:
:
GetPointerLockElement
(
)
{
nsCOMPtr
<
Element
>
pointerLockedElement
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedElement
)
;
if
(
!
pointerLockedElement
)
{
return
nullptr
;
}
nsIContent
*
retargetedPointerLockedElement
=
Retarget
(
pointerLockedElement
)
;
return
retargetedPointerLockedElement
&
&
retargetedPointerLockedElement
-
>
IsElement
(
)
?
retargetedPointerLockedElement
-
>
AsElement
(
)
:
nullptr
;
}
Element
*
DocumentOrShadowRoot
:
:
GetFullscreenElement
(
)
{
if
(
!
AsNode
(
)
.
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
Element
*
element
=
AsNode
(
)
.
OwnerDoc
(
)
-
>
FullScreenStackTop
(
)
;
NS_ASSERTION
(
!
element
|
|
element
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FULL_SCREEN
)
"
Fullscreen
element
should
have
fullscreen
styles
applied
"
)
;
nsIContent
*
retargeted
=
Retarget
(
element
)
;
if
(
retargeted
&
&
retargeted
-
>
IsElement
(
)
)
{
return
retargeted
-
>
AsElement
(
)
;
}
return
nullptr
;
}
Element
*
DocumentOrShadowRoot
:
:
ElementFromPoint
(
float
aX
float
aY
)
{
return
ElementFromPointHelper
(
aX
aY
false
true
)
;
}
void
DocumentOrShadowRoot
:
:
ElementsFromPoint
(
float
aX
float
aY
nsTArray
<
RefPtr
<
Element
>
>
&
aElements
)
{
ElementsFromPointHelper
(
aX
aY
nsIDocument
:
:
FLUSH_LAYOUT
aElements
)
;
}
Element
*
DocumentOrShadowRoot
:
:
ElementFromPointHelper
(
float
aX
float
aY
bool
aIgnoreRootScrollFrame
bool
aFlushLayout
)
{
AutoTArray
<
RefPtr
<
Element
>
1
>
elementArray
;
ElementsFromPointHelper
(
aX
aY
(
(
aIgnoreRootScrollFrame
?
nsIDocument
:
:
IGNORE_ROOT_SCROLL_FRAME
:
0
)
|
(
aFlushLayout
?
nsIDocument
:
:
FLUSH_LAYOUT
:
0
)
|
nsIDocument
:
:
IS_ELEMENT_FROM_POINT
)
elementArray
)
;
if
(
elementArray
.
IsEmpty
(
)
)
{
return
nullptr
;
}
return
elementArray
[
0
]
;
}
void
DocumentOrShadowRoot
:
:
ElementsFromPointHelper
(
float
aX
float
aY
uint32_t
aFlags
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
>
&
aElements
)
{
if
(
!
(
aFlags
&
nsIDocument
:
:
IGNORE_ROOT_SCROLL_FRAME
)
&
&
(
aX
<
0
|
|
aY
<
0
)
)
{
return
;
}
nscoord
x
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aX
)
;
nscoord
y
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aY
)
;
nsPoint
pt
(
x
y
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
AsNode
(
)
.
OwnerDoc
(
)
;
if
(
aFlags
&
nsIDocument
:
:
FLUSH_LAYOUT
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
nsIPresShell
*
ps
=
doc
-
>
GetShell
(
)
;
if
(
!
ps
)
{
return
;
}
nsIFrame
*
rootFrame
=
ps
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
nsTArray
<
nsIFrame
*
>
outFrames
;
nsLayoutUtils
:
:
GetFramesForArea
(
rootFrame
nsRect
(
pt
nsSize
(
1
1
)
)
outFrames
nsLayoutUtils
:
:
IGNORE_PAINT_SUPPRESSION
|
nsLayoutUtils
:
:
IGNORE_CROSS_DOC
|
(
(
aFlags
&
nsIDocument
:
:
IGNORE_ROOT_SCROLL_FRAME
)
?
nsLayoutUtils
:
:
IGNORE_ROOT_SCROLL_FRAME
:
0
)
)
;
if
(
outFrames
.
IsEmpty
(
)
)
{
return
;
}
nsIContent
*
lastAdded
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
outFrames
.
Length
(
)
;
i
+
+
)
{
nsIContent
*
node
=
doc
-
>
GetContentInThisDocument
(
outFrames
[
i
]
)
;
if
(
!
node
|
|
!
node
-
>
IsElement
(
)
)
{
if
(
!
(
aFlags
&
nsIDocument
:
:
IS_ELEMENT_FROM_POINT
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
outFrames
[
i
]
)
)
{
continue
;
}
node
=
node
-
>
GetParent
(
)
;
if
(
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNodeOrNull
(
node
)
)
{
node
=
shadow
-
>
Host
(
)
;
}
}
node
=
Retarget
(
node
)
;
if
(
node
&
&
node
!
=
lastAdded
)
{
aElements
.
AppendElement
(
node
-
>
AsElement
(
)
)
;
lastAdded
=
node
;
if
(
aFlags
&
nsIDocument
:
:
IS_ELEMENT_FROM_POINT
)
{
return
;
}
}
}
}
Element
*
DocumentOrShadowRoot
:
:
AddIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
{
nsDependentAtomString
id
(
aID
)
;
if
(
!
CheckGetElementByIdArg
(
id
)
)
{
return
nullptr
;
}
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aID
)
;
NS_ENSURE_TRUE
(
entry
nullptr
)
;
entry
-
>
AddContentChangeCallback
(
aObserver
aData
aForImage
)
;
return
aForImage
?
entry
-
>
GetImageIdElement
(
)
:
entry
-
>
GetIdElement
(
)
;
}
void
DocumentOrShadowRoot
:
:
RemoveIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
{
nsDependentAtomString
id
(
aID
)
;
if
(
!
CheckGetElementByIdArg
(
id
)
)
{
return
;
}
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aID
)
;
if
(
!
entry
)
{
return
;
}
entry
-
>
RemoveContentChangeCallback
(
aObserver
aData
aForImage
)
;
}
void
DocumentOrShadowRoot
:
:
ReportEmptyGetElementByIdArg
(
)
{
nsContentUtils
:
:
ReportEmptyGetElementByIdArg
(
AsNode
(
)
.
OwnerDoc
(
)
)
;
}
}
}
