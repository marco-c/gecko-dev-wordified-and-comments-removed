#
include
"
nsGlobalWindow
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
Navigator
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsScreen
.
h
"
#
include
"
nsHistory
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsIDOMStorageManager
.
h
"
#
include
"
nsIPermission
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
mozilla
/
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
dom
/
ContentFrameMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
LocalStorage
.
h
"
#
include
"
mozilla
/
dom
/
LSObject
.
h
"
#
include
"
mozilla
/
dom
/
Storage
.
h
"
#
include
"
mozilla
/
dom
/
IdleRequest
.
h
"
#
include
"
mozilla
/
dom
/
MaybeCrossOriginObject
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
dom
/
StorageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
StorageNotifierService
.
h
"
#
include
"
mozilla
/
dom
/
StorageUtils
.
h
"
#
include
"
mozilla
/
dom
/
Timeout
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutHandler
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
#
include
"
mozilla
/
dom
/
WindowProxyHolder
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
dom
/
WindowOrientationObserver
.
h
"
#
endif
#
include
"
nsError
.
h
"
#
include
"
nsIIdleService
.
h
"
#
include
"
nsISizeOfEventTarget
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsDOMWindowList
.
h
"
#
include
"
mozilla
/
dom
/
WakeLock
.
h
"
#
include
"
mozilla
/
dom
/
power
/
PowerManagerService
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptTimeoutHandler
.
h
"
#
include
"
nsITimeoutHandler
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsISlowScriptDebug
.
h
"
#
include
"
nsWindowMemoryReporter
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
WindowNamedPropertiesHandler
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
WindowDestroyedEvent
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
PropertySpec
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
BarProps
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsLayoutStatics
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Debug
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
ProcessHangMonitor
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
AudioChannelService
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
PostMessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIDeviceSensors
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
Crypto
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIEmbeddingSiteWindow
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIPromptService
.
h
"
#
include
"
nsIPromptFactory
.
h
"
#
include
"
nsIAddonPolicyService
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebBrowserFind
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsDOMWindowUtils
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsPIWindowWatcher
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsIControllerContext
.
h
"
#
include
"
nsGlobalWindowCommands
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
ifndef
DEBUG
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
#
endif
#
include
"
nsCDefaultURIFixup
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIXULWindow
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
nsIJARChannel
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
xpcprivate
.
h
"
#
ifdef
NS_PRINTING
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsIPrintSettingsService
.
h
"
#
include
"
nsIWebBrowserPrint
.
h
"
#
endif
#
include
"
nsWindowRoot
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsIArray
.
h
"
#
include
"
XULDocument
.
h
"
#
include
"
nsIDOMXULCommandDispatcher
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsXBLService
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
dom
/
IDBFactory
.
h
"
#
include
"
mozilla
/
dom
/
MessageChannel
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Gamepad
.
h
"
#
include
"
mozilla
/
dom
/
GamepadManager
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplay
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplayEvent
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplayEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
VREventObserver
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
Location
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
prrng
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsBaseCommandController
.
h
"
#
include
"
nsXULControllers
.
h
"
#
include
"
mozilla
/
dom
/
AudioContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowserElementDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheStorage
.
h
"
#
include
"
mozilla
/
dom
/
Console
.
h
"
#
include
"
mozilla
/
dom
/
Fetch
.
h
"
#
include
"
mozilla
/
dom
/
FunctionBinding
.
h
"
#
include
"
mozilla
/
dom
/
HashChangeEvent
.
h
"
#
include
"
mozilla
/
dom
/
IntlUtils
.
h
"
#
include
"
mozilla
/
dom
/
PopStateEvent
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlockedEvent
.
h
"
#
include
"
mozilla
/
dom
/
PrimitiveConversions
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
nsITabChild
.
h
"
#
include
"
mozilla
/
dom
/
MediaQueryList
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
NavigatorBinding
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmap
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistration
.
h
"
#
include
"
mozilla
/
dom
/
U2F
.
h
"
#
include
"
mozilla
/
dom
/
WebIDLGlobalNameHash
.
h
"
#
include
"
mozilla
/
dom
/
Worklet
.
h
"
#
ifdef
HAVE_SIDEBAR
#
include
"
mozilla
/
dom
/
ExternalBinding
.
h
"
#
endif
#
ifdef
MOZ_WEBSPEECH
#
include
"
mozilla
/
dom
/
SpeechSynthesis
.
h
"
#
endif
#
ifdef
check
class
nsIScriptTimeoutHandler
;
#
undef
check
#
endif
#
include
"
AccessCheck
.
h
"
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
ipc
;
using
mozilla
:
:
BasePrincipal
;
using
mozilla
:
:
OriginAttributes
;
using
mozilla
:
:
TimeStamp
;
#
define
FORWARD_TO_INNER
(
method
args
err_rval
)
\
PR_BEGIN_MACRO
\
if
(
!
mInnerWindow
)
{
\
NS_WARNING
(
"
No
inner
window
available
!
"
)
;
\
return
err_rval
;
\
}
\
return
GetCurrentInnerWindowInternal
(
)
-
>
method
args
;
\
PR_END_MACRO
#
define
FORWARD_TO_INNER_VOID
(
method
args
)
\
PR_BEGIN_MACRO
\
if
(
!
mInnerWindow
)
{
\
NS_WARNING
(
"
No
inner
window
available
!
"
)
;
\
return
;
\
}
\
GetCurrentInnerWindowInternal
(
)
-
>
method
args
;
\
return
;
\
PR_END_MACRO
#
define
FORWARD_TO_INNER_CREATE
(
method
args
err_rval
)
\
PR_BEGIN_MACRO
\
if
(
!
mInnerWindow
)
{
\
if
(
mIsClosed
)
{
\
return
err_rval
;
\
}
\
nsCOMPtr
<
Document
>
kungFuDeathGrip
=
GetDoc
(
)
;
\
:
:
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
\
if
(
!
mInnerWindow
)
{
\
return
err_rval
;
\
}
\
}
\
return
GetCurrentInnerWindowInternal
(
)
-
>
method
args
;
\
PR_END_MACRO
static
LazyLogModule
gDOMLeakPRLogOuter
(
"
DOMLeakOuter
"
)
;
static
int32_t
gOpenPopupSpamCount
=
0
;
static
bool
gSyncContentBlockingNotifications
=
false
;
nsGlobalWindowOuter
:
:
OuterWindowByIdTable
*
nsGlobalWindowOuter
:
:
sOuterWindowsById
=
nullptr
;
nsPIDOMWindowOuter
*
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
nsPIDOMWindowInner
*
aInner
)
{
if
(
!
aInner
)
{
return
nullptr
;
}
nsPIDOMWindowOuter
*
outer
=
aInner
-
>
GetOuterWindow
(
)
;
if
(
!
outer
|
|
outer
-
>
GetCurrentInnerWindow
(
)
!
=
aInner
)
{
return
nullptr
;
}
return
outer
;
}
const
js
:
:
Class
OuterWindowProxyClass
=
PROXY_CLASS_DEF
(
"
Proxy
"
JSCLASS_HAS_RESERVED_SLOTS
(
2
)
)
;
static
const
size_t
OUTER_WINDOW_SLOT
=
0
;
static
const
size_t
HOLDER_WEAKMAP_SLOT
=
1
;
class
nsOuterWindowProxy
:
public
MaybeCrossOriginObject
<
js
:
:
Wrapper
>
{
typedef
MaybeCrossOriginObject
<
js
:
:
Wrapper
>
Base
;
public
:
constexpr
nsOuterWindowProxy
(
)
:
Base
(
0
)
{
}
bool
finalizeInBackground
(
const
JS
:
:
Value
&
priv
)
const
override
{
return
false
;
}
bool
getOwnPropertyDescriptor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
const
override
;
bool
definePropertySameOrigin
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
Handle
<
JS
:
:
PropertyDescriptor
>
desc
JS
:
:
ObjectOpResult
&
result
)
const
override
;
bool
ownPropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
AutoIdVector
&
props
)
const
override
;
bool
delete_
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
ObjectOpResult
&
result
)
const
override
;
JSObject
*
getSameOriginPrototype
(
JSContext
*
cx
)
const
override
;
bool
has
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
bool
*
bp
)
const
override
;
bool
get
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
JS
:
:
Value
>
receiver
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
)
const
override
;
bool
set
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
Handle
<
JS
:
:
Value
>
v
JS
:
:
Handle
<
JS
:
:
Value
>
receiver
JS
:
:
ObjectOpResult
&
result
)
const
override
;
bool
hasOwn
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
bool
*
bp
)
const
override
;
bool
getOwnEnumerablePropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
AutoIdVector
&
props
)
const
override
;
const
char
*
className
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
)
const
override
;
void
finalize
(
JSFreeOp
*
fop
JSObject
*
proxy
)
const
override
;
size_t
objectMoved
(
JSObject
*
proxy
JSObject
*
old
)
const
override
;
bool
isCallable
(
JSObject
*
obj
)
const
override
{
return
false
;
}
bool
isConstructor
(
JSObject
*
obj
)
const
override
{
return
false
;
}
static
const
nsOuterWindowProxy
singleton
;
protected
:
static
nsGlobalWindowOuter
*
GetOuterWindow
(
JSObject
*
proxy
)
{
nsGlobalWindowOuter
*
outerWindow
=
nsGlobalWindowOuter
:
:
FromSupports
(
static_cast
<
nsISupports
*
>
(
js
:
:
GetProxyReservedSlot
(
proxy
OUTER_WINDOW_SLOT
)
.
toPrivate
(
)
)
)
;
return
outerWindow
;
}
bool
GetSubframeWindow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
bool
&
found
)
const
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetSubframeWindow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
)
const
;
bool
AppendIndexedPropertyNames
(
JSObject
*
proxy
JS
:
:
AutoIdVector
&
props
)
const
;
using
MaybeCrossOriginObjectMixins
:
:
EnsureHolder
;
bool
EnsureHolder
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
MutableHandle
<
JSObject
*
>
holder
)
const
override
;
}
;
const
char
*
nsOuterWindowProxy
:
:
className
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
)
const
{
MOZ_ASSERT
(
js
:
:
IsProxy
(
proxy
)
)
;
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
"
Object
"
;
}
return
"
Window
"
;
}
void
nsOuterWindowProxy
:
:
finalize
(
JSFreeOp
*
fop
JSObject
*
proxy
)
const
{
nsGlobalWindowOuter
*
outerWindow
=
GetOuterWindow
(
proxy
)
;
if
(
outerWindow
)
{
outerWindow
-
>
ClearWrapper
(
proxy
)
;
BrowsingContext
*
bc
=
outerWindow
-
>
GetBrowsingContext
(
)
;
if
(
bc
)
{
bc
-
>
ClearWindowProxy
(
)
;
}
outerWindow
-
>
PoisonOuterWindowProxy
(
proxy
)
;
}
}
#
ifndef
RELEASE_OR_BETA
static
bool
IsNonConfigurableReadonlyPrimitiveGlobalProp
(
JSContext
*
cx
JS
:
:
Handle
<
jsid
>
id
)
{
return
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_NAN
)
|
|
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_UNDEFINED
)
|
|
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_INFINITY
)
;
}
#
endif
bool
nsOuterWindowProxy
:
:
getOwnPropertyDescriptor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
const
{
bool
found
;
if
(
!
GetSubframeWindow
(
cx
proxy
id
desc
.
value
(
)
found
)
)
{
return
false
;
}
if
(
found
)
{
FillPropertyDescriptor
(
desc
proxy
true
)
;
return
true
;
}
bool
isSameOrigin
=
IsPlatformObjectSameOrigin
(
cx
proxy
)
;
if
(
!
isSameOrigin
&
&
IsArrayIndex
(
GetArrayIndexFromId
(
id
)
)
)
{
return
ReportCrossOriginDenial
(
cx
id
NS_LITERAL_CSTRING
(
"
access
"
)
)
;
}
if
(
isSameOrigin
)
{
{
JSAutoRealm
ar
(
cx
proxy
)
;
JS_MarkCrossZoneId
(
cx
id
)
;
bool
ok
=
js
:
:
Wrapper
:
:
getOwnPropertyDescriptor
(
cx
proxy
id
desc
)
;
if
(
!
ok
)
{
return
false
;
}
#
ifndef
RELEASE_OR_BETA
if
(
!
IsNonConfigurableReadonlyPrimitiveGlobalProp
(
cx
id
)
)
{
desc
.
setConfigurable
(
true
)
;
}
#
endif
}
return
JS_WrapPropertyDescriptor
(
cx
desc
)
;
}
if
(
!
CrossOriginGetOwnPropertyHelper
(
cx
proxy
id
desc
)
)
{
return
false
;
}
if
(
desc
.
object
(
)
)
{
return
true
;
}
if
(
JSID_IS_STRING
(
id
)
)
{
nsAutoJSString
name
;
if
(
!
name
.
init
(
cx
JSID_TO_STRING
(
id
)
)
)
{
return
false
;
}
nsGlobalWindowOuter
*
win
=
GetOuterWindow
(
proxy
)
;
if
(
RefPtr
<
BrowsingContext
>
childDOMWin
=
win
-
>
GetChildWindow
(
name
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
childValue
(
cx
)
;
if
(
!
ToJSValue
(
cx
WindowProxyHolder
(
childDOMWin
)
&
childValue
)
)
{
return
false
;
}
FillPropertyDescriptor
(
desc
proxy
childValue
true
false
)
;
return
true
;
}
}
return
CrossOriginPropertyFallback
(
cx
proxy
id
desc
)
;
}
bool
nsOuterWindowProxy
:
:
definePropertySameOrigin
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
Handle
<
JS
:
:
PropertyDescriptor
>
desc
JS
:
:
ObjectOpResult
&
result
)
const
{
if
(
IsArrayIndex
(
GetArrayIndexFromId
(
id
)
)
)
{
return
result
.
failCantDefineWindowElement
(
)
;
}
JS
:
:
ObjectOpResult
ourResult
;
bool
ok
=
js
:
:
Wrapper
:
:
defineProperty
(
cx
proxy
id
desc
ourResult
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
!
ourResult
.
ok
(
)
)
{
if
(
!
desc
.
hasConfigurable
(
)
|
|
!
desc
.
configurable
(
)
)
{
result
=
ourResult
;
return
true
;
}
JS
:
:
Rooted
<
JS
:
:
PropertyDescriptor
>
existingDesc
(
cx
)
;
ok
=
js
:
:
Wrapper
:
:
getOwnPropertyDescriptor
(
cx
proxy
id
&
existingDesc
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
!
existingDesc
.
object
(
)
|
|
existingDesc
.
configurable
(
)
)
{
result
=
ourResult
;
return
true
;
}
JS
:
:
Rooted
<
JS
:
:
PropertyDescriptor
>
updatedDesc
(
cx
desc
)
;
updatedDesc
.
setConfigurable
(
false
)
;
JS
:
:
ObjectOpResult
ourNewResult
;
ok
=
js
:
:
Wrapper
:
:
defineProperty
(
cx
proxy
id
updatedDesc
ourNewResult
)
;
if
(
!
ok
)
{
return
false
;
}
if
(
!
ourNewResult
.
ok
(
)
)
{
result
=
ourNewResult
;
return
true
;
}
}
#
ifndef
RELEASE_OR_BETA
if
(
desc
.
hasConfigurable
(
)
&
&
!
desc
.
configurable
(
)
&
&
!
IsNonConfigurableReadonlyPrimitiveGlobalProp
(
cx
id
)
)
{
result
.
failCantDefineWindowNonConfigurable
(
)
;
return
true
;
}
#
endif
result
.
succeed
(
)
;
return
true
;
}
bool
nsOuterWindowProxy
:
:
ownPropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
AutoIdVector
&
props
)
const
{
if
(
!
AppendIndexedPropertyNames
(
proxy
props
)
)
{
return
false
;
}
if
(
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
JS
:
:
AutoIdVector
innerProps
(
cx
)
;
{
JSAutoRealm
ar
(
cx
proxy
)
;
if
(
!
js
:
:
Wrapper
:
:
ownPropertyKeys
(
cx
proxy
innerProps
)
)
{
return
false
;
}
}
for
(
auto
&
id
:
innerProps
)
{
JS_MarkCrossZoneId
(
cx
id
)
;
}
return
js
:
:
AppendUnique
(
cx
props
innerProps
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
holder
(
cx
)
;
if
(
!
EnsureHolder
(
cx
proxy
&
holder
)
)
{
return
false
;
}
JS
:
:
AutoIdVector
crossOriginProps
(
cx
)
;
if
(
!
js
:
:
GetPropertyKeys
(
cx
holder
JSITER_OWNONLY
|
JSITER_HIDDEN
|
JSITER_SYMBOLS
&
crossOriginProps
)
|
|
!
js
:
:
AppendUnique
(
cx
props
crossOriginProps
)
)
{
return
false
;
}
return
xpc
:
:
AppendCrossOriginWhitelistedPropNames
(
cx
props
)
;
}
bool
nsOuterWindowProxy
:
:
delete_
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
ObjectOpResult
&
result
)
const
{
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
ReportCrossOriginDenial
(
cx
id
NS_LITERAL_CSTRING
(
"
delete
"
)
)
;
}
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
frame
=
GetSubframeWindow
(
cx
proxy
id
)
)
{
return
result
.
failCantDeleteWindowElement
(
)
;
}
if
(
IsArrayIndex
(
GetArrayIndexFromId
(
id
)
)
)
{
return
result
.
succeed
(
)
;
}
JSAutoRealm
ar
(
cx
proxy
)
;
JS_MarkCrossZoneId
(
cx
id
)
;
return
js
:
:
Wrapper
:
:
delete_
(
cx
proxy
id
result
)
;
}
JSObject
*
nsOuterWindowProxy
:
:
getSameOriginPrototype
(
JSContext
*
cx
)
const
{
return
Window_Binding
:
:
GetProtoObjectHandle
(
cx
)
;
}
bool
nsOuterWindowProxy
:
:
has
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
bool
*
bp
)
const
{
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
hasOwn
(
cx
proxy
id
bp
)
;
}
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
frame
=
GetSubframeWindow
(
cx
proxy
id
)
)
{
*
bp
=
true
;
return
true
;
}
JSAutoRealm
ar
(
cx
proxy
)
;
JS_MarkCrossZoneId
(
cx
id
)
;
return
js
:
:
Wrapper
:
:
has
(
cx
proxy
id
bp
)
;
}
bool
nsOuterWindowProxy
:
:
hasOwn
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
bool
*
bp
)
const
{
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
js
:
:
BaseProxyHandler
:
:
hasOwn
(
cx
proxy
id
bp
)
;
}
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
frame
=
GetSubframeWindow
(
cx
proxy
id
)
)
{
*
bp
=
true
;
return
true
;
}
JSAutoRealm
ar
(
cx
proxy
)
;
JS_MarkCrossZoneId
(
cx
id
)
;
return
js
:
:
Wrapper
:
:
hasOwn
(
cx
proxy
id
bp
)
;
}
bool
nsOuterWindowProxy
:
:
get
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
JS
:
:
Value
>
receiver
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
)
const
{
if
(
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_WRAPPED_JSOBJECT
)
&
&
xpc
:
:
AccessCheck
:
:
isChrome
(
js
:
:
GetContextCompartment
(
cx
)
)
)
{
vp
.
set
(
JS
:
:
ObjectValue
(
*
proxy
)
)
;
return
MaybeWrapValue
(
cx
vp
)
;
}
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
CrossOriginGet
(
cx
proxy
receiver
id
vp
)
;
}
bool
found
;
if
(
!
GetSubframeWindow
(
cx
proxy
id
vp
found
)
)
{
return
false
;
}
if
(
found
)
{
return
true
;
}
{
JSAutoRealm
ar
(
cx
proxy
)
;
JS_MarkCrossZoneId
(
cx
id
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
wrappedReceiver
(
cx
receiver
)
;
if
(
!
MaybeWrapValue
(
cx
&
wrappedReceiver
)
)
{
return
false
;
}
if
(
!
js
:
:
Wrapper
:
:
get
(
cx
proxy
wrappedReceiver
id
vp
)
)
{
return
false
;
}
}
return
MaybeWrapValue
(
cx
vp
)
;
}
bool
nsOuterWindowProxy
:
:
set
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
Handle
<
JS
:
:
Value
>
v
JS
:
:
Handle
<
JS
:
:
Value
>
receiver
JS
:
:
ObjectOpResult
&
result
)
const
{
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
CrossOriginSet
(
cx
proxy
id
v
receiver
result
)
;
}
if
(
IsArrayIndex
(
GetArrayIndexFromId
(
id
)
)
)
{
return
result
.
failReadOnly
(
)
;
}
JSAutoRealm
ar
(
cx
proxy
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
wrappedArg
(
cx
v
)
;
if
(
!
MaybeWrapValue
(
cx
&
wrappedArg
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
wrappedReceiver
(
cx
receiver
)
;
if
(
!
MaybeWrapValue
(
cx
&
wrappedReceiver
)
)
{
return
false
;
}
JS_MarkCrossZoneId
(
cx
id
)
;
return
js
:
:
Wrapper
:
:
set
(
cx
proxy
id
wrappedArg
wrappedReceiver
result
)
;
}
bool
nsOuterWindowProxy
:
:
getOwnEnumerablePropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
AutoIdVector
&
props
)
const
{
if
(
!
AppendIndexedPropertyNames
(
proxy
props
)
)
{
return
false
;
}
if
(
!
IsPlatformObjectSameOrigin
(
cx
proxy
)
)
{
return
true
;
}
JS
:
:
AutoIdVector
innerProps
(
cx
)
;
{
JSAutoRealm
ar
(
cx
proxy
)
;
if
(
!
js
:
:
Wrapper
:
:
getOwnEnumerablePropertyKeys
(
cx
proxy
innerProps
)
)
{
return
false
;
}
}
for
(
auto
&
id
:
innerProps
)
{
JS_MarkCrossZoneId
(
cx
id
)
;
}
return
js
:
:
AppendUnique
(
cx
props
innerProps
)
;
}
bool
nsOuterWindowProxy
:
:
GetSubframeWindow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
bool
&
found
)
const
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
frame
=
GetSubframeWindow
(
cx
proxy
id
)
;
if
(
!
frame
)
{
found
=
false
;
return
true
;
}
found
=
true
;
nsGlobalWindowOuter
*
global
=
nsGlobalWindowOuter
:
:
Cast
(
frame
)
;
frame
-
>
EnsureInnerWindow
(
)
;
JSObject
*
obj
=
global
-
>
FastGetGlobalJSObject
(
)
;
if
(
MOZ_UNLIKELY
(
!
obj
)
)
{
return
xpc
:
:
Throw
(
cx
NS_ERROR_FAILURE
)
;
}
JS
:
:
ExposeObjectToActiveJS
(
obj
)
;
vp
.
setObject
(
*
obj
)
;
return
JS_WrapValue
(
cx
vp
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsOuterWindowProxy
:
:
GetSubframeWindow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
)
const
{
uint32_t
index
=
GetArrayIndexFromId
(
id
)
;
if
(
!
IsArrayIndex
(
index
)
)
{
return
nullptr
;
}
nsGlobalWindowOuter
*
win
=
GetOuterWindow
(
proxy
)
;
return
win
-
>
IndexedGetterOuter
(
index
)
;
}
bool
nsOuterWindowProxy
:
:
AppendIndexedPropertyNames
(
JSObject
*
proxy
JS
:
:
AutoIdVector
&
props
)
const
{
uint32_t
length
=
GetOuterWindow
(
proxy
)
-
>
Length
(
)
;
MOZ_ASSERT
(
int32_t
(
length
)
>
=
0
)
;
if
(
!
props
.
reserve
(
props
.
length
(
)
+
length
)
)
{
return
false
;
}
for
(
int32_t
i
=
0
;
i
<
int32_t
(
length
)
;
+
+
i
)
{
if
(
!
props
.
append
(
INT_TO_JSID
(
i
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsOuterWindowProxy
:
:
EnsureHolder
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
MutableHandle
<
JSObject
*
>
holder
)
const
{
return
EnsureHolder
(
cx
proxy
HOLDER_WEAKMAP_SLOT
Window_Binding
:
:
sCrossOriginAttributes
Window_Binding
:
:
sCrossOriginMethods
holder
)
;
}
size_t
nsOuterWindowProxy
:
:
objectMoved
(
JSObject
*
obj
JSObject
*
old
)
const
{
nsGlobalWindowOuter
*
outerWindow
=
GetOuterWindow
(
obj
)
;
if
(
outerWindow
)
{
outerWindow
-
>
UpdateWrapper
(
obj
old
)
;
BrowsingContext
*
bc
=
outerWindow
-
>
GetBrowsingContext
(
)
;
if
(
bc
)
{
bc
-
>
UpdateWindowProxy
(
obj
old
)
;
}
}
return
0
;
}
const
nsOuterWindowProxy
nsOuterWindowProxy
:
:
singleton
;
class
nsChromeOuterWindowProxy
:
public
nsOuterWindowProxy
{
public
:
constexpr
nsChromeOuterWindowProxy
(
)
:
nsOuterWindowProxy
(
)
{
}
const
char
*
className
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
)
const
override
;
static
const
nsChromeOuterWindowProxy
singleton
;
}
;
const
char
*
nsChromeOuterWindowProxy
:
:
className
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
)
const
{
MOZ_ASSERT
(
js
:
:
IsProxy
(
proxy
)
)
;
return
"
ChromeWindow
"
;
}
const
nsChromeOuterWindowProxy
nsChromeOuterWindowProxy
:
:
singleton
;
static
JSObject
*
NewOuterWindowProxy
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
bool
isChrome
)
{
MOZ_ASSERT
(
JS_IsGlobalObject
(
global
)
)
;
JSAutoRealm
ar
(
cx
global
)
;
js
:
:
WrapperOptions
options
;
options
.
setClass
(
&
OuterWindowProxyClass
)
;
options
.
setSingleton
(
true
)
;
JSObject
*
obj
=
js
:
:
Wrapper
:
:
New
(
cx
global
isChrome
?
&
nsChromeOuterWindowProxy
:
:
singleton
:
&
nsOuterWindowProxy
:
:
singleton
options
)
;
MOZ_ASSERT_IF
(
obj
js
:
:
IsWindowProxy
(
obj
)
)
;
return
obj
;
}
nsGlobalWindowOuter
:
:
nsGlobalWindowOuter
(
uint64_t
aWindowID
)
:
nsPIDOMWindowOuter
(
aWindowID
)
mIdleFuzzFactor
(
0
)
mIdleCallbackIndex
(
-
1
)
mCurrentlyIdle
(
false
)
mAddActiveEventFuzzTime
(
true
)
mFullscreen
(
false
)
mFullscreenMode
(
false
)
mIsClosed
(
false
)
mInClose
(
false
)
mHavePendingClose
(
false
)
mHadOriginalOpener
(
false
)
mIsPopupSpam
(
false
)
mBlockScriptedClosingFlag
(
false
)
mWasOffline
(
false
)
mCreatingInnerWindow
(
false
)
mIsChrome
(
false
)
mAllowScriptsToClose
(
false
)
mTopLevelOuterContentWindow
(
false
)
mHasStorageAccess
(
false
)
#
ifdef
DEBUG
mSerial
(
0
)
mSetOpenerWindowCalled
(
false
)
#
endif
mCleanedUp
(
false
)
#
ifdef
DEBUG
mIsValidatingTabGroup
(
false
)
#
endif
mCanSkipCCGeneration
(
0
)
mAutoActivateVRDisplayID
(
0
)
{
AssertIsOnMainThread
(
)
;
nsLayoutStatics
:
:
AddRef
(
)
;
PR_INIT_CLIST
(
this
)
;
MOZ_ASSERT
(
IsFrozen
(
)
)
;
#
ifdef
DEBUG
mSerial
=
nsContentUtils
:
:
InnerOrOuterWindowCreated
(
)
;
if
(
!
PR_GetEnv
(
"
MOZ_QUIET
"
)
)
{
printf_stderr
(
"
+
+
DOMWINDOW
=
=
%
d
(
%
p
)
[
pid
=
%
d
]
[
serial
=
%
d
]
[
outer
=
%
p
]
\
n
"
nsContentUtils
:
:
GetCurrentInnerOrOuterWindowCount
(
)
static_cast
<
void
*
>
(
ToCanonicalSupports
(
this
)
)
getpid
(
)
mSerial
nullptr
)
;
}
#
endif
MOZ_LOG
(
gDOMLeakPRLogOuter
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
created
outer
=
nullptr
"
this
)
)
;
MOZ_ASSERT
(
sOuterWindowsById
"
Outer
Windows
hash
table
must
be
created
!
"
)
;
MOZ_ASSERT
(
!
sOuterWindowsById
-
>
Get
(
mWindowID
)
"
This
window
shouldn
'
t
be
in
the
hash
table
yet
!
"
)
;
if
(
sOuterWindowsById
)
{
sOuterWindowsById
-
>
Put
(
mWindowID
this
)
;
}
}
#
ifdef
DEBUG
void
nsGlobalWindowOuter
:
:
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
#
endif
void
nsGlobalWindowOuter
:
:
Init
(
)
{
AssertIsOnMainThread
(
)
;
NS_ASSERTION
(
gDOMLeakPRLogOuter
"
gDOMLeakPRLogOuter
should
have
been
initialized
!
"
)
;
sOuterWindowsById
=
new
OuterWindowByIdTable
(
)
;
}
nsGlobalWindowOuter
:
:
~
nsGlobalWindowOuter
(
)
{
AssertIsOnMainThread
(
)
;
if
(
sOuterWindowsById
)
{
MOZ_ASSERT
(
sOuterWindowsById
-
>
Get
(
mWindowID
)
"
This
window
should
be
in
the
hash
table
"
)
;
sOuterWindowsById
-
>
Remove
(
mWindowID
)
;
}
nsContentUtils
:
:
InnerOrOuterWindowDestroyed
(
)
;
#
ifdef
DEBUG
if
(
!
PR_GetEnv
(
"
MOZ_QUIET
"
)
)
{
nsAutoCString
url
;
if
(
mLastOpenedURI
)
{
url
=
mLastOpenedURI
-
>
GetSpecOrDefault
(
)
;
const
uint32_t
maxURLLength
=
1000
;
if
(
url
.
Length
(
)
>
maxURLLength
)
{
url
.
Truncate
(
maxURLLength
)
;
}
}
printf_stderr
(
"
-
-
DOMWINDOW
=
=
%
d
(
%
p
)
[
pid
=
%
d
]
[
serial
=
%
d
]
[
outer
=
%
p
]
[
url
=
"
"
%
s
]
\
n
"
nsContentUtils
:
:
GetCurrentInnerOrOuterWindowCount
(
)
static_cast
<
void
*
>
(
ToCanonicalSupports
(
this
)
)
getpid
(
)
mSerial
nullptr
url
.
get
(
)
)
;
}
#
endif
MOZ_LOG
(
gDOMLeakPRLogOuter
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
destroyed
"
this
)
)
;
JSObject
*
proxy
=
GetWrapperMaybeDead
(
)
;
if
(
proxy
)
{
if
(
mBrowsingContext
)
{
mBrowsingContext
-
>
ClearWindowProxy
(
)
;
}
js
:
:
SetProxyReservedSlot
(
proxy
OUTER_WINDOW_SLOT
js
:
:
PrivateValue
(
nullptr
)
)
;
}
PRCList
*
w
;
while
(
(
w
=
PR_LIST_HEAD
(
this
)
)
!
=
this
)
{
PR_REMOVE_AND_INIT_LINK
(
w
)
;
}
DropOuterWindowDocs
(
)
;
if
(
mTabGroup
)
{
mTabGroup
-
>
Leave
(
this
)
;
}
MOZ_ASSERT
(
mCleanedUp
)
;
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
ac
-
>
RemoveWindowAsListener
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
PERM_CHANGE_NOTIFICATION
)
;
}
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefBranch
)
{
prefBranch
-
>
RemoveObserver
(
"
network
.
cookie
.
cookieBehavior
"
this
)
;
}
nsLayoutStatics
:
:
Release
(
)
;
}
void
nsGlobalWindowOuter
:
:
ShutDown
(
)
{
AssertIsOnMainThread
(
)
;
delete
sOuterWindowsById
;
sOuterWindowsById
=
nullptr
;
}
void
nsGlobalWindowOuter
:
:
MaybeForgiveSpamCount
(
)
{
if
(
IsPopupSpamWindow
(
)
)
{
SetIsPopupSpamWindow
(
false
)
;
}
}
void
nsGlobalWindowOuter
:
:
SetIsPopupSpamWindow
(
bool
aIsPopupSpam
)
{
mIsPopupSpam
=
aIsPopupSpam
;
if
(
aIsPopupSpam
)
{
+
+
gOpenPopupSpamCount
;
}
else
{
-
-
gOpenPopupSpamCount
;
NS_ASSERTION
(
gOpenPopupSpamCount
>
=
0
"
Unbalanced
decrement
of
gOpenPopupSpamCount
"
)
;
}
}
void
nsGlobalWindowOuter
:
:
DropOuterWindowDocs
(
)
{
MOZ_ASSERT_IF
(
mDoc
!
mDoc
-
>
EventHandlingSuppressed
(
)
)
;
mDoc
=
nullptr
;
mSuspendedDoc
=
nullptr
;
}
void
nsGlobalWindowOuter
:
:
CleanUp
(
)
{
if
(
mCleanedUp
)
return
;
mCleanedUp
=
true
;
StartDying
(
)
;
mFrames
=
nullptr
;
mWindowUtils
=
nullptr
;
ClearControllers
(
)
;
mOpener
=
nullptr
;
if
(
mContext
)
{
mContext
=
nullptr
;
}
mChromeEventHandler
=
nullptr
;
mParentTarget
=
nullptr
;
mMessageManager
=
nullptr
;
mArguments
=
nullptr
;
if
(
mIdleTimer
)
{
mIdleTimer
-
>
Cancel
(
)
;
mIdleTimer
=
nullptr
;
}
}
void
nsGlobalWindowOuter
:
:
ClearControllers
(
)
{
if
(
mControllers
)
{
uint32_t
count
;
mControllers
-
>
GetControllerCount
(
&
count
)
;
while
(
count
-
-
)
{
nsCOMPtr
<
nsIController
>
controller
;
mControllers
-
>
GetControllerAt
(
count
getter_AddRefs
(
controller
)
)
;
nsCOMPtr
<
nsIControllerContext
>
context
=
do_QueryInterface
(
controller
)
;
if
(
context
)
context
-
>
SetCommandContext
(
nullptr
)
;
}
mControllers
=
nullptr
;
}
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsGlobalWindowOuter
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
EventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIGlobalObject
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptGlobalObject
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptObjectPrincipal
)
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
EventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsPIDOMWindowOuter
)
NS_INTERFACE_MAP_ENTRY
(
mozIDOMWindowProxy
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsIDOMChromeWindow
IsChromeWindow
(
)
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsGlobalWindowOuter
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsGlobalWindowOuter
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsGlobalWindowOuter
)
if
(
tmp
-
>
IsBlackForCC
(
false
)
)
{
if
(
nsCCUncollectableMarker
:
:
InGeneration
(
tmp
-
>
mCanSkipCCGeneration
)
)
{
return
true
;
}
tmp
-
>
mCanSkipCCGeneration
=
nsCCUncollectableMarker
:
:
sGeneration
;
if
(
EventListenerManager
*
elm
=
tmp
-
>
GetExistingListenerManager
(
)
)
{
elm
-
>
MarkForCC
(
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsGlobalWindowOuter
)
return
tmp
-
>
IsBlackForCC
(
true
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsGlobalWindowOuter
)
return
tmp
-
>
IsBlackForCC
(
false
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsGlobalWindowOuter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
nsGlobalWindowOuter
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
nsAutoCString
uri
;
if
(
tmp
-
>
mDoc
&
&
tmp
-
>
mDoc
-
>
GetDocumentURI
(
)
)
{
uri
=
tmp
-
>
mDoc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
SprintfLiteral
(
name
"
nsGlobalWindowOuter
#
%
"
PRIu64
"
outer
%
s
"
tmp
-
>
mWindowID
uri
.
get
(
)
)
;
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
nsGlobalWindowOuter
tmp
-
>
mRefCnt
.
get
(
)
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mControllers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mArguments
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocalStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSuspendedDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentPrincipal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIdleService
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIdleObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeEventHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParentTarget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMessageManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOpenerForInitialContentBrowser
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocShell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBrowsingContext
)
tmp
-
>
TraverseHostObjectURIs
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mBrowserDOMWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsGlobalWindowOuter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContext
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mControllers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mArguments
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocalStorage
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSuspendedDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentPrincipal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIdleService
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIdleObservers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeEventHandler
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParentTarget
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMessageManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFrameElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOpenerForInitialContentBrowser
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocShell
)
if
(
tmp
-
>
mBrowsingContext
)
{
tmp
-
>
mBrowsingContext
-
>
ClearWindowProxy
(
)
;
tmp
-
>
mBrowsingContext
=
nullptr
;
}
tmp
-
>
UnlinkHostObjectURIs
(
)
;
if
(
tmp
-
>
IsChromeWindow
(
)
)
{
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mBrowserDOMWindow
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsGlobalWindowOuter
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
bool
nsGlobalWindowOuter
:
:
IsBlackForCC
(
bool
aTracingNeeded
)
{
if
(
!
nsCCUncollectableMarker
:
:
sGeneration
)
{
return
false
;
}
return
(
nsCCUncollectableMarker
:
:
InGeneration
(
GetMarkedCCGeneration
(
)
)
|
|
HasKnownLiveWrapper
(
)
)
&
&
(
!
aTracingNeeded
|
|
HasNothingToTrace
(
ToSupports
(
this
)
)
)
;
}
nsresult
nsGlobalWindowOuter
:
:
EnsureScriptEnvironment
(
)
{
if
(
GetWrapperPreserveColor
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
!
GetCurrentInnerWindowInternal
(
)
"
No
cached
wrapper
but
we
have
an
inner
window
?
"
)
;
nsCOMPtr
<
nsIScriptContext
>
context
=
new
nsJSContext
(
!
IsFrame
(
)
this
)
;
NS_ASSERTION
(
!
mContext
"
Will
overwrite
mContext
!
"
)
;
context
-
>
WillInitializeContext
(
)
;
nsresult
rv
=
context
-
>
InitContext
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mContext
=
context
;
return
NS_OK
;
}
nsIScriptContext
*
nsGlobalWindowOuter
:
:
GetScriptContext
(
)
{
return
mContext
;
}
JSObject
*
nsGlobalWindowOuter
:
:
GetGlobalJSObject
(
)
{
return
FastGetGlobalJSObject
(
)
;
}
bool
nsGlobalWindowOuter
:
:
WouldReuseInnerWindow
(
Document
*
aNewDocument
)
{
if
(
!
mDoc
|
|
!
aNewDocument
)
{
return
false
;
}
if
(
!
mDoc
-
>
IsInitialDocument
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_GetURIWithoutRef
(
mDoc
-
>
GetDocumentURI
(
)
getter_AddRefs
(
uri
)
)
;
NS_ASSERTION
(
NS_IsAboutBlank
(
uri
)
"
How
'
d
this
happen
?
"
)
;
}
#
endif
if
(
mDoc
=
=
aNewDocument
)
{
return
true
;
}
bool
equal
;
if
(
NS_SUCCEEDED
(
mDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
aNewDocument
-
>
NodePrincipal
(
)
&
equal
)
)
&
&
equal
)
{
return
true
;
}
return
false
;
}
void
nsGlobalWindowOuter
:
:
SetInitialPrincipalToSubject
(
)
{
nsCOMPtr
<
nsIPrincipal
>
newWindowPrincipal
=
nsContentUtils
:
:
SubjectPrincipalOrSystemIfNativeCaller
(
)
;
if
(
nsContentUtils
:
:
IsExpandedPrincipal
(
newWindowPrincipal
)
|
|
(
nsContentUtils
:
:
IsSystemPrincipal
(
newWindowPrincipal
)
&
&
GetDocShell
(
)
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
)
{
newWindowPrincipal
=
nullptr
;
}
if
(
mDoc
)
{
if
(
!
mDoc
-
>
IsInitialDocument
(
)
)
return
;
if
(
mDoc
-
>
NodePrincipal
(
)
=
=
newWindowPrincipal
)
return
;
#
ifdef
DEBUG
bool
isNullPrincipal
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mDoc
-
>
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
&
isNullPrincipal
)
)
&
&
isNullPrincipal
)
;
#
endif
}
GetDocShell
(
)
-
>
CreateAboutBlankContentViewer
(
newWindowPrincipal
)
;
if
(
mDoc
)
{
mDoc
-
>
SetIsInitialDocument
(
true
)
;
}
nsCOMPtr
<
nsIPresShell
>
shell
=
GetDocShell
(
)
-
>
GetPresShell
(
)
;
if
(
shell
&
&
!
shell
-
>
DidInitialize
(
)
)
{
shell
-
>
Initialize
(
)
;
}
}
#
define
WINDOWSTATEHOLDER_IID
\
{
\
0x0b917c3e
0xbd50
0x4683
{
\
0xaf
0xc9
0xc7
0x81
0x07
0xae
0x33
0x26
\
}
\
}
class
WindowStateHolder
final
:
public
nsISupports
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
WINDOWSTATEHOLDER_IID
)
NS_DECL_ISUPPORTS
explicit
WindowStateHolder
(
nsGlobalWindowInner
*
aWindow
)
;
nsGlobalWindowInner
*
GetInnerWindow
(
)
{
return
mInnerWindow
;
}
void
DidRestoreWindow
(
)
{
mInnerWindow
=
nullptr
;
mInnerWindowReflector
=
nullptr
;
}
protected
:
~
WindowStateHolder
(
)
;
nsGlobalWindowInner
*
mInnerWindow
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mInnerWindowReflector
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
WindowStateHolder
WINDOWSTATEHOLDER_IID
)
WindowStateHolder
:
:
WindowStateHolder
(
nsGlobalWindowInner
*
aWindow
)
:
mInnerWindow
(
aWindow
)
mInnerWindowReflector
(
RootingCx
(
)
aWindow
-
>
GetWrapper
(
)
)
{
MOZ_ASSERT
(
aWindow
"
null
window
"
)
;
aWindow
-
>
Suspend
(
)
;
xpc
:
:
Scriptability
:
:
Get
(
mInnerWindowReflector
)
.
SetDocShellAllowsScript
(
false
)
;
}
WindowStateHolder
:
:
~
WindowStateHolder
(
)
{
if
(
mInnerWindow
)
{
mInnerWindow
-
>
FreeInnerObjects
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
WindowStateHolder
WindowStateHolder
)
bool
nsGlobalWindowOuter
:
:
ComputeIsSecureContext
(
Document
*
aDocument
SecureContextFlags
aFlags
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aDocument
-
>
NodePrincipal
(
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
)
{
return
true
;
}
bool
hadNonSecureContextCreator
=
false
;
nsPIDOMWindowOuter
*
parentOuterWin
=
GetScriptableParent
(
)
;
MOZ_ASSERT
(
parentOuterWin
"
How
can
we
get
here
?
No
docShell
somehow
?
"
)
;
if
(
nsGlobalWindowOuter
:
:
Cast
(
parentOuterWin
)
!
=
this
)
{
Document
*
creatorDoc
=
aDocument
-
>
GetParentDocument
(
)
;
if
(
!
creatorDoc
)
{
return
false
;
}
nsGlobalWindowInner
*
parentWin
=
nsGlobalWindowInner
:
:
Cast
(
creatorDoc
-
>
GetInnerWindow
(
)
)
;
if
(
!
parentWin
)
{
return
false
;
}
MOZ_ASSERT
(
parentWin
=
=
nsGlobalWindowInner
:
:
Cast
(
parentOuterWin
-
>
GetCurrentInnerWindow
(
)
)
"
Creator
window
mismatch
while
setting
Secure
Context
state
"
)
;
hadNonSecureContextCreator
=
!
parentWin
-
>
IsSecureContext
(
)
;
}
if
(
hadNonSecureContextCreator
)
{
return
false
;
}
if
(
nsContentUtils
:
:
HttpsStateIsModern
(
aDocument
)
)
{
return
true
;
}
if
(
principal
-
>
GetIsNullPrincipal
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aDocument
-
>
GetOriginalURI
(
)
;
const
OriginAttributes
&
attrs
=
principal
-
>
OriginAttributesRef
(
)
;
principal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
uri
attrs
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
return
false
;
}
}
nsCOMPtr
<
nsIContentSecurityManager
>
csm
=
do_GetService
(
NS_CONTENTSECURITYMANAGER_CONTRACTID
)
;
NS_WARNING_ASSERTION
(
csm
"
csm
is
null
"
)
;
if
(
csm
)
{
bool
isTrustworthyOrigin
=
false
;
csm
-
>
IsOriginPotentiallyTrustworthy
(
principal
&
isTrustworthyOrigin
)
;
if
(
isTrustworthyOrigin
)
{
return
true
;
}
}
return
false
;
}
static
bool
TreatAsRemoteXUL
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
;
return
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
aPrincipal
)
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
use_xbl_scopes_for_remote_xul
"
false
)
;
}
static
bool
EnablePrivilege
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
ENABLE_PRIVILEGE_EVER_CALLED
true
)
;
return
xpc
:
:
EnableUniversalXPConnect
(
cx
)
;
}
static
const
JSFunctionSpec
EnablePrivilegeSpec
[
]
=
{
JS_FN
(
"
enablePrivilege
"
EnablePrivilege
1
0
)
JS_FS_END
}
;
static
bool
InitializeLegacyNetscapeObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
JSAutoRealm
ar
(
aCx
aGlobal
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
)
;
obj
=
JS_DefineObject
(
aCx
aGlobal
"
netscape
"
nullptr
)
;
NS_ENSURE_TRUE
(
obj
false
)
;
obj
=
JS_DefineObject
(
aCx
obj
"
security
"
nullptr
)
;
NS_ENSURE_TRUE
(
obj
false
)
;
if
(
!
xpc
:
:
IsInAutomation
(
)
)
{
return
true
;
}
obj
=
JS_DefineObject
(
aCx
obj
"
PrivilegeManager
"
nullptr
)
;
NS_ENSURE_TRUE
(
obj
false
)
;
return
JS_DefineFunctions
(
aCx
obj
EnablePrivilegeSpec
)
;
}
static
JS
:
:
RealmCreationOptions
&
SelectZone
(
nsIPrincipal
*
aPrincipal
nsGlobalWindowInner
*
aNewInner
JS
:
:
RealmCreationOptions
&
aOptions
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
aOptions
.
setExistingCompartment
(
xpc
:
:
PrivilegedJunkScope
(
)
)
;
}
if
(
aNewInner
-
>
GetOuterWindow
(
)
)
{
nsGlobalWindowOuter
*
top
=
aNewInner
-
>
GetTopInternal
(
)
;
if
(
top
&
&
top
-
>
GetGlobalJSObject
(
)
)
{
return
aOptions
.
setNewCompartmentInExistingZone
(
top
-
>
GetGlobalJSObject
(
)
)
;
}
}
return
aOptions
.
setNewCompartmentAndZone
(
)
;
}
static
nsresult
CreateNativeGlobalForInner
(
JSContext
*
aCx
nsGlobalWindowInner
*
aNewInner
nsIURI
*
aURI
nsIPrincipal
*
aPrincipal
JS
:
:
MutableHandle
<
JSObject
*
>
aGlobal
bool
aIsSecureContext
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aNewInner
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsCOMPtr
<
nsIExpandedPrincipal
>
nsEP
=
do_QueryInterface
(
aPrincipal
)
;
MOZ_RELEASE_ASSERT
(
!
nsEP
"
DOMWindow
with
nsEP
is
not
supported
"
)
;
JS
:
:
RealmOptions
options
;
SelectZone
(
aPrincipal
aNewInner
options
.
creationOptions
(
)
)
;
options
.
creationOptions
(
)
.
setSecureContext
(
aIsSecureContext
)
;
xpc
:
:
InitGlobalObjectOptions
(
options
aPrincipal
)
;
bool
needComponents
=
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
|
|
TreatAsRemoteXUL
(
aPrincipal
)
;
uint32_t
flags
=
needComponents
?
0
:
xpc
:
:
OMIT_COMPONENTS_OBJECT
;
flags
|
=
xpc
:
:
DONT_FIRE_ONNEWGLOBALHOOK
;
if
(
!
Window_Binding
:
:
Wrap
(
aCx
aNewInner
aNewInner
options
nsJSPrincipals
:
:
get
(
aPrincipal
)
false
aGlobal
)
|
|
!
xpc
:
:
InitGlobalObject
(
aCx
aGlobal
flags
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
aNewInner
-
>
GetWrapperPreserveColor
(
)
=
=
aGlobal
)
;
xpc
:
:
SetLocationForGlobal
(
aGlobal
aURI
)
;
if
(
!
InitializeLegacyNetscapeObject
(
aCx
aGlobal
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
nsGlobalWindowOuter
:
:
SetNewDocument
(
Document
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
{
MOZ_ASSERT
(
mDocumentPrincipal
=
=
nullptr
"
mDocumentPrincipal
prematurely
set
!
"
)
;
MOZ_ASSERT
(
aDocument
)
;
NS_ENSURE_STATE
(
!
mCleanedUp
)
;
NS_ASSERTION
(
!
GetCurrentInnerWindow
(
)
|
|
GetCurrentInnerWindow
(
)
-
>
GetExtantDoc
(
)
=
=
mDoc
"
Uh
mDoc
doesn
'
t
match
the
current
inner
window
"
"
document
!
"
)
;
bool
wouldReuseInnerWindow
=
WouldReuseInnerWindow
(
aDocument
)
;
if
(
aForceReuseInnerWindow
&
&
!
wouldReuseInnerWindow
&
&
mDoc
&
&
mDoc
-
>
NodePrincipal
(
)
!
=
aDocument
-
>
NodePrincipal
(
)
)
{
NS_ERROR
(
"
Attempted
forced
inner
window
reuse
while
changing
principal
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
Document
>
oldDoc
=
mDoc
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
if
(
!
js
:
:
CheckRecursionLimitConservativeDontReport
(
cx
)
)
{
NS_WARNING
(
"
Overrecursion
in
SetNewDocument
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mDoc
)
{
nsPIDOMWindowOuter
*
privateRoot
=
GetPrivateRoot
(
)
;
if
(
privateRoot
=
=
this
)
{
nsXBLService
:
:
AttachGlobalKeyHandler
(
mChromeEventHandler
)
;
}
}
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
nsGlobalWindowOuter
:
:
ClearStatus
"
this
&
nsGlobalWindowOuter
:
:
ClearStatus
)
)
;
bool
reUseInnerWindow
=
(
aForceReuseInnerWindow
|
|
wouldReuseInnerWindow
)
&
&
GetCurrentInnerWindowInternal
(
)
;
nsresult
rv
;
mDoc
=
aDocument
;
mSuspendedDoc
=
nullptr
;
#
ifdef
DEBUG
mLastOpenedURI
=
aDocument
-
>
GetDocumentURI
(
)
;
#
endif
mContext
-
>
WillInitializeContext
(
)
;
RefPtr
<
nsGlobalWindowInner
>
currentInner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
currentInner
&
&
currentInner
-
>
mNavigator
)
{
currentInner
-
>
mNavigator
-
>
OnNavigation
(
)
;
}
RefPtr
<
nsGlobalWindowInner
>
newInnerWindow
;
bool
createdInnerWindow
=
false
;
bool
thisChrome
=
IsChromeWindow
(
)
;
nsCOMPtr
<
WindowStateHolder
>
wsh
=
do_QueryInterface
(
aState
)
;
NS_ASSERTION
(
!
aState
|
|
wsh
"
What
kind
of
weird
state
are
you
giving
me
here
?
"
)
;
bool
handleDocumentOpen
=
false
;
bool
doomCurrentInner
=
false
;
JS
:
:
Rooted
<
JSObject
*
>
newInnerGlobal
(
cx
)
;
if
(
reUseInnerWindow
)
{
NS_ASSERTION
(
!
currentInner
-
>
IsFrozen
(
)
"
We
should
never
be
reusing
a
shared
inner
window
"
)
;
newInnerWindow
=
currentInner
;
newInnerGlobal
=
currentInner
-
>
GetWrapperPreserveColor
(
)
;
if
(
aDocument
!
=
oldDoc
)
{
JS
:
:
ExposeObjectToActiveJS
(
newInnerGlobal
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
rootedObject
(
cx
GetWrapper
(
)
)
;
if
(
!
JS_RefreshCrossCompartmentWrappers
(
cx
rootedObject
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
Realm
*
realm
=
js
:
:
GetNonCCWObjectRealm
(
newInnerGlobal
)
;
#
ifdef
DEBUG
bool
sameOrigin
=
false
;
nsIPrincipal
*
existing
=
nsJSPrincipals
:
:
get
(
JS
:
:
GetRealmPrincipals
(
realm
)
)
;
aDocument
-
>
NodePrincipal
(
)
-
>
Equals
(
existing
&
sameOrigin
)
;
MOZ_ASSERT
(
sameOrigin
)
;
MOZ_ASSERT_IF
(
aDocument
=
=
oldDoc
xpc
:
:
GetRealmPrincipal
(
realm
)
=
=
aDocument
-
>
NodePrincipal
(
)
)
;
#
endif
if
(
aDocument
!
=
oldDoc
)
{
JS
:
:
SetRealmPrincipals
(
realm
nsJSPrincipals
:
:
get
(
aDocument
-
>
NodePrincipal
(
)
)
)
;
xpc
:
:
ClearContentXBLScope
(
newInnerGlobal
)
;
}
}
else
{
if
(
aState
)
{
newInnerWindow
=
wsh
-
>
GetInnerWindow
(
)
;
newInnerGlobal
=
newInnerWindow
-
>
GetWrapperPreserveColor
(
)
;
}
else
{
newInnerWindow
=
nsGlobalWindowInner
:
:
Create
(
this
thisChrome
)
;
if
(
StaticPrefs
:
:
dom_timeout_defer_during_load
(
)
)
{
newInnerWindow
-
>
SetActiveLoadingState
(
aDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
ReadyState
:
:
READYSTATE_LOADING
)
;
}
mInnerWindow
=
nullptr
;
mCreatingInnerWindow
=
true
;
rv
=
CreateNativeGlobalForInner
(
cx
newInnerWindow
aDocument
-
>
GetDocumentURI
(
)
aDocument
-
>
NodePrincipal
(
)
&
newInnerGlobal
ComputeIsSecureContext
(
aDocument
)
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
&
&
newInnerGlobal
&
&
newInnerWindow
-
>
GetWrapperPreserveColor
(
)
=
=
newInnerGlobal
"
Failed
to
get
script
global
"
)
;
mCreatingInnerWindow
=
false
;
createdInnerWindow
=
true
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
currentInner
&
&
currentInner
-
>
GetWrapperPreserveColor
(
)
)
{
if
(
oldDoc
=
=
aDocument
)
{
handleDocumentOpen
=
true
;
}
if
(
!
currentInner
-
>
IsFrozen
(
)
)
{
doomCurrentInner
=
true
;
}
}
mInnerWindow
=
newInnerWindow
-
>
AsInner
(
)
;
MOZ_ASSERT
(
mInnerWindow
)
;
mInnerWindow
-
>
TryToCacheTopInnerWindow
(
)
;
if
(
!
GetWrapperPreserveColor
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
outer
(
cx
NewOuterWindowProxy
(
cx
newInnerGlobal
thisChrome
)
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_FAILURE
)
;
js
:
:
SetProxyReservedSlot
(
outer
OUTER_WINDOW_SLOT
js
:
:
PrivateValue
(
ToSupports
(
this
)
)
)
;
mContext
-
>
SetWindowProxy
(
outer
)
;
mContext
-
>
DidInitializeContext
(
)
;
SetWrapper
(
mContext
-
>
GetWindowProxy
(
)
)
;
}
else
{
JS
:
:
ExposeObjectToActiveJS
(
newInnerGlobal
)
;
JS
:
:
Rooted
<
JSObject
*
>
outerObject
(
cx
NewOuterWindowProxy
(
cx
newInnerGlobal
thisChrome
)
)
;
if
(
!
outerObject
)
{
NS_ERROR
(
"
out
of
memory
"
)
;
return
NS_ERROR_FAILURE
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
GetWrapperPreserveColor
(
)
)
;
js
:
:
SetProxyReservedSlot
(
obj
OUTER_WINDOW_SLOT
js
:
:
PrivateValue
(
nullptr
)
)
;
js
:
:
SetProxyReservedSlot
(
outerObject
OUTER_WINDOW_SLOT
js
:
:
PrivateValue
(
nullptr
)
)
;
outerObject
=
xpc
:
:
TransplantObject
(
cx
obj
outerObject
)
;
if
(
!
outerObject
)
{
mBrowsingContext
-
>
ClearWindowProxy
(
)
;
NS_ERROR
(
"
unable
to
transplant
wrappers
probably
OOM
"
)
;
return
NS_ERROR_FAILURE
;
}
js
:
:
SetProxyReservedSlot
(
outerObject
OUTER_WINDOW_SLOT
js
:
:
PrivateValue
(
ToSupports
(
this
)
)
)
;
SetWrapper
(
outerObject
)
;
MOZ_ASSERT
(
JS
:
:
GetNonCCWObjectGlobal
(
outerObject
)
=
=
newInnerGlobal
)
;
mContext
-
>
SetWindowProxy
(
outerObject
)
;
}
JSAutoRealm
ar
(
cx
GetWrapperPreserveColor
(
)
)
;
{
JS
:
:
Rooted
<
JSObject
*
>
outer
(
cx
GetWrapperPreserveColor
(
)
)
;
js
:
:
SetWindowProxy
(
cx
newInnerGlobal
outer
)
;
mBrowsingContext
-
>
SetWindowProxy
(
outer
)
;
}
bool
allow
=
GetDocShell
(
)
-
>
GetCanExecuteScripts
(
)
;
xpc
:
:
Scriptability
:
:
Get
(
GetWrapperPreserveColor
(
)
)
.
SetDocShellAllowsScript
(
allow
)
;
if
(
!
aState
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
unused
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
newInnerGlobal
"
window
"
&
unused
)
)
{
NS_ERROR
(
"
can
'
t
create
the
'
window
'
property
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
JS_GetProperty
(
cx
newInnerGlobal
"
self
"
&
unused
)
)
{
NS_ERROR
(
"
can
'
t
create
the
'
self
'
property
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
JSAutoRealm
ar
(
cx
GetWrapperPreserveColor
(
)
)
;
if
(
!
aState
&
&
!
reUseInnerWindow
)
{
MOZ_ASSERT
(
mContext
-
>
GetWindowProxy
(
)
=
=
GetWrapperPreserveColor
(
)
)
;
#
ifdef
DEBUG
JS
:
:
Rooted
<
JSObject
*
>
rootedJSObject
(
cx
GetWrapperPreserveColor
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
proto1
(
cx
)
proto2
(
cx
)
;
JS_GetPrototype
(
cx
rootedJSObject
&
proto1
)
;
JS_GetPrototype
(
cx
newInnerGlobal
&
proto2
)
;
NS_ASSERTION
(
proto1
=
=
proto2
"
outer
and
inner
globals
should
have
the
same
prototype
"
)
;
#
endif
mInnerWindow
-
>
SyncStateFromParentWindow
(
)
;
}
nsCOMPtr
<
nsIScriptContext
>
kungFuDeathGrip
(
mContext
)
;
aDocument
-
>
SetScriptGlobalObject
(
newInnerWindow
)
;
MOZ_ASSERT
(
newInnerWindow
-
>
mTabGroup
"
We
must
have
a
TabGroup
cached
at
this
point
"
)
;
if
(
!
aState
)
{
if
(
reUseInnerWindow
)
{
if
(
newInnerWindow
-
>
mDoc
!
=
aDocument
)
{
newInnerWindow
-
>
mDoc
=
aDocument
;
newInnerWindow
-
>
mLocalStorage
=
nullptr
;
newInnerWindow
-
>
mSessionStorage
=
nullptr
;
newInnerWindow
-
>
mPerformance
=
nullptr
;
newInnerWindow
-
>
ClearDocumentDependentSlots
(
cx
)
;
rv
=
newInnerWindow
-
>
ExecutionReady
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
newInnerWindow
-
>
InnerSetNewDocument
(
cx
aDocument
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
newInnerGlobal
)
;
rv
=
kungFuDeathGrip
-
>
InitClasses
(
obj
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
newInnerWindow
-
>
ExecutionReady
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mArguments
)
{
newInnerWindow
-
>
DefineArgumentsProperty
(
mArguments
)
;
mArguments
=
nullptr
;
}
newInnerWindow
-
>
mChromeEventHandler
=
mChromeEventHandler
;
}
if
(
handleDocumentOpen
)
{
newInnerWindow
-
>
MigrateStateForDocumentOpen
(
currentInner
)
;
}
mInnerWindow
-
>
GetWindowGlobalChild
(
)
-
>
SendBecomeCurrentWindowGlobal
(
)
;
if
(
doomCurrentInner
)
{
currentInner
-
>
FreeInnerObjects
(
handleDocumentOpen
)
;
}
currentInner
=
nullptr
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
mDoc
-
>
NodePrincipal
(
)
;
if
(
GetDocGroup
(
)
&
&
!
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
&
&
!
BasePrincipal
:
:
Cast
(
principal
)
-
>
AddonPolicy
(
)
)
{
js
:
:
SetRealmValidAccessPtr
(
cx
newInnerGlobal
newInnerWindow
-
>
GetDocGroup
(
)
-
>
GetValidAccessPtr
(
)
)
;
}
kungFuDeathGrip
-
>
DidInitializeContext
(
)
;
if
(
createdInnerWindow
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
nsGlobalWindowInner
:
:
FireOnNewGlobalObject
"
newInnerWindow
&
nsGlobalWindowInner
:
:
FireOnNewGlobalObject
)
)
;
}
if
(
newInnerWindow
&
&
!
newInnerWindow
-
>
mHasNotifiedGlobalCreated
&
&
mDoc
)
{
if
(
!
mDocShell
|
|
mDocShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
|
|
nsContentUtils
:
:
IsSystemPrincipal
(
mDoc
-
>
NodePrincipal
(
)
)
)
{
newInnerWindow
-
>
mHasNotifiedGlobalCreated
=
true
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
nsGlobalWindowOuter
:
:
DispatchDOMWindowCreated
"
this
&
nsGlobalWindowOuter
:
:
DispatchDOMWindowCreated
)
)
;
}
}
PreloadLocalStorage
(
)
;
ReportLargeAllocStatus
(
)
;
mLargeAllocStatus
=
LargeAllocStatus
:
:
NONE
;
mHasStorageAccess
=
false
;
nsIURI
*
uri
=
aDocument
-
>
GetDocumentURI
(
)
;
if
(
newInnerWindow
)
{
if
(
StaticPrefs
:
:
network_cookie_cookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
&
&
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
newInnerWindow
nullptr
uri
)
&
&
nsContentUtils
:
:
IsTrackingResourceWindow
(
newInnerWindow
)
)
{
mHasStorageAccess
=
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
newInnerWindow
uri
nullptr
)
;
}
}
return
NS_OK
;
}
void
nsGlobalWindowOuter
:
:
PreloadLocalStorage
(
)
{
if
(
!
Storage
:
:
StoragePrefIsEnabled
(
)
)
{
return
;
}
if
(
IsChromeWindow
(
)
)
{
return
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
return
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_GetService
(
"
mozilla
.
org
/
dom
/
localStorage
-
manager
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
principal
-
>
GetPrivateBrowsingId
(
)
=
=
0
)
{
RefPtr
<
Storage
>
storage
;
rv
=
storageManager
-
>
PrecacheStorage
(
principal
getter_AddRefs
(
storage
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mLocalStorage
=
storage
;
}
}
}
void
nsGlobalWindowOuter
:
:
DispatchDOMWindowCreated
(
)
{
if
(
!
mDoc
)
{
return
;
}
nsContentUtils
:
:
DispatchChromeEvent
(
mDoc
ToSupports
(
mDoc
)
NS_LITERAL_STRING
(
"
DOMWindowCreated
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
&
&
mDoc
)
{
nsAutoString
origin
;
nsIPrincipal
*
principal
=
mDoc
-
>
NodePrincipal
(
)
;
nsContentUtils
:
:
GetUTFOrigin
(
principal
origin
)
;
observerService
-
>
NotifyObservers
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
?
"
chrome
-
document
-
global
-
created
"
:
"
content
-
document
-
global
-
created
"
origin
.
get
(
)
)
;
}
}
void
nsGlobalWindowOuter
:
:
ClearStatus
(
)
{
SetStatusOuter
(
EmptyString
(
)
)
;
}
void
nsGlobalWindowOuter
:
:
SetDocShell
(
nsDocShell
*
aDocShell
)
{
MOZ_ASSERT
(
aDocShell
)
;
if
(
aDocShell
=
=
mDocShell
)
{
return
;
}
mDocShell
=
aDocShell
;
mBrowsingContext
=
aDocShell
-
>
GetBrowsingContext
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindow
=
GetScriptableParentOrNull
(
)
;
MOZ_RELEASE_ASSERT
(
!
parentWindow
|
|
!
mTabGroup
|
|
mTabGroup
=
=
nsGlobalWindowOuter
:
:
Cast
(
parentWindow
)
-
>
mTabGroup
)
;
mTopLevelOuterContentWindow
=
!
mIsChrome
&
&
GetScriptableTopInternal
(
)
=
=
this
;
if
(
mFrames
)
{
mFrames
-
>
SetDocShell
(
aDocShell
)
;
}
RefPtr
<
EventTarget
>
chromeEventHandler
;
mDocShell
-
>
GetChromeEventHandler
(
getter_AddRefs
(
chromeEventHandler
)
)
;
mChromeEventHandler
=
chromeEventHandler
;
if
(
!
mChromeEventHandler
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWindow
=
GetParent
(
)
;
if
(
parentWindow
.
get
(
)
!
=
this
)
{
mChromeEventHandler
=
parentWindow
-
>
GetChromeEventHandler
(
)
;
}
else
{
mChromeEventHandler
=
NS_NewWindowRoot
(
this
)
;
mIsRootOuterWindow
=
true
;
}
}
bool
docShellActive
;
mDocShell
-
>
GetIsActive
(
&
docShellActive
)
;
SetIsBackgroundInternal
(
!
docShellActive
)
;
}
void
nsGlobalWindowOuter
:
:
DetachFromDocShell
(
)
{
RefPtr
<
nsGlobalWindowInner
>
inner
;
for
(
PRCList
*
node
=
PR_LIST_HEAD
(
this
)
;
node
!
=
this
;
node
=
PR_NEXT_LINK
(
inner
)
)
{
inner
=
static_cast
<
nsGlobalWindowInner
*
>
(
node
)
;
MOZ_ASSERT
(
!
inner
-
>
mOuterWindow
|
|
inner
-
>
mOuterWindow
=
=
this
)
;
inner
-
>
FreeInnerObjects
(
)
;
}
NotifyWindowIDDestroyed
(
"
outer
-
window
-
destroyed
"
)
;
nsGlobalWindowInner
*
currentInner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
currentInner
)
{
NS_ASSERTION
(
mDoc
"
Must
have
doc
!
"
)
;
mDocumentPrincipal
=
mDoc
-
>
NodePrincipal
(
)
;
mDocumentURI
=
mDoc
-
>
GetDocumentURI
(
)
;
DropOuterWindowDocs
(
)
;
}
ClearControllers
(
)
;
mChromeEventHandler
=
nullptr
;
if
(
mContext
)
{
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
SET_DOC_SHELL
(
mTopLevelOuterContentWindow
|
|
mIsChrome
)
?
nullptr
:
GetWrapperPreserveColor
(
)
)
;
mContext
=
nullptr
;
}
mDocShell
=
nullptr
;
if
(
mFrames
)
{
mFrames
-
>
SetDocShell
(
nullptr
)
;
}
MaybeForgiveSpamCount
(
)
;
CleanUp
(
)
;
}
void
nsGlobalWindowOuter
:
:
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
{
nsWeakPtr
opener
=
do_GetWeakReference
(
aOpener
)
;
if
(
opener
=
=
mOpener
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aOpener
|
|
!
aOpener
-
>
GetDocShell
(
)
|
|
(
GetBrowsingContext
(
)
&
&
GetBrowsingContext
(
)
-
>
GetOpener
(
)
=
=
aOpener
-
>
GetBrowsingContext
(
)
)
)
;
return
;
}
NS_ASSERTION
(
!
aOriginalOpener
|
|
!
mSetOpenerWindowCalled
"
aOriginalOpener
is
true
but
not
first
call
to
"
"
SetOpenerWindow
!
"
)
;
NS_ASSERTION
(
aOpener
|
|
!
aOriginalOpener
"
Shouldn
'
t
set
mHadOriginalOpener
if
aOpener
is
null
"
)
;
mOpener
=
opener
.
forget
(
)
;
NS_ASSERTION
(
mOpener
|
|
!
aOpener
"
Opener
must
support
weak
references
!
"
)
;
if
(
mDocShell
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aOriginalOpener
|
|
!
aOpener
|
|
nsGlobalWindowOuter
:
:
Cast
(
aOpener
)
-
>
IsClosedOrClosing
(
)
|
|
aOpener
-
>
GetBrowsingContext
(
)
=
=
GetBrowsingContext
(
)
-
>
GetOpener
(
)
)
;
GetBrowsingContext
(
)
-
>
SetOpener
(
aOpener
?
aOpener
-
>
GetBrowsingContext
(
)
:
nullptr
)
;
}
nsPIDOMWindowOuter
*
contentOpener
=
GetSanitizedOpener
(
aOpener
)
;
mozilla
:
:
Unused
<
<
contentOpener
;
MOZ_DIAGNOSTIC_ASSERT
(
!
contentOpener
|
|
!
mTabGroup
|
|
mTabGroup
=
=
nsGlobalWindowOuter
:
:
Cast
(
contentOpener
)
-
>
mTabGroup
)
;
if
(
aOriginalOpener
)
{
MOZ_ASSERT
(
!
mHadOriginalOpener
"
Probably
too
late
to
call
ComputeIsSecureContext
again
"
)
;
mHadOriginalOpener
=
true
;
}
#
ifdef
DEBUG
mSetOpenerWindowCalled
=
true
;
#
endif
}
void
nsGlobalWindowOuter
:
:
UpdateParentTarget
(
)
{
nsCOMPtr
<
Element
>
frameElement
=
GetOuterWindow
(
)
-
>
GetFrameElementInternal
(
)
;
mMessageManager
=
nsContentUtils
:
:
TryGetTabChildGlobal
(
frameElement
)
;
if
(
!
mMessageManager
)
{
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
topWin
)
{
frameElement
=
topWin
-
>
GetFrameElementInternal
(
)
;
mMessageManager
=
nsContentUtils
:
:
TryGetTabChildGlobal
(
frameElement
)
;
}
}
if
(
!
mMessageManager
)
{
mMessageManager
=
nsContentUtils
:
:
TryGetTabChildGlobal
(
mChromeEventHandler
)
;
}
if
(
mMessageManager
)
{
mParentTarget
=
mMessageManager
;
}
else
{
mParentTarget
=
mChromeEventHandler
;
}
}
EventTarget
*
nsGlobalWindowOuter
:
:
GetTargetForEventTargetChain
(
)
{
return
GetCurrentInnerWindowInternal
(
)
;
}
void
nsGlobalWindowOuter
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
MOZ_CRASH
(
"
The
outer
window
should
not
be
part
of
an
event
path
"
)
;
}
bool
nsGlobalWindowOuter
:
:
ShouldPromptToBlockDialogs
(
)
{
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ASSERTION
(
!
mDocShell
"
ShouldPromptToBlockDialogs
(
)
called
without
a
top
window
?
"
)
;
return
true
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
!
topWindow
)
{
return
true
;
}
return
topWindow
-
>
DialogsAreBeingAbused
(
)
;
}
bool
nsGlobalWindowOuter
:
:
AreDialogsEnabled
(
)
{
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
AreDialogsEnabled
(
)
called
without
a
top
window
?
"
)
;
return
false
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
!
topWindow
)
{
return
false
;
}
if
(
mDocShell
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
bool
isHidden
;
cv
-
>
GetIsHidden
(
&
isHidden
)
;
if
(
isHidden
)
{
return
false
;
}
}
if
(
!
mDoc
|
|
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
)
{
return
false
;
}
return
topWindow
-
>
mAreDialogsEnabled
;
}
bool
nsGlobalWindowOuter
:
:
ConfirmDialogIfNeeded
(
)
{
NS_ENSURE_TRUE
(
mDocShell
false
)
;
nsCOMPtr
<
nsIPromptService
>
promptSvc
=
do_GetService
(
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
)
;
if
(
!
promptSvc
)
{
return
true
;
}
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
bool
disableDialog
=
false
;
nsAutoString
label
title
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogLabel
"
label
)
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogPreventTitle
"
title
)
;
promptSvc
-
>
Confirm
(
this
title
.
get
(
)
label
.
get
(
)
&
disableDialog
)
;
if
(
disableDialog
)
{
DisableDialogs
(
)
;
return
false
;
}
return
true
;
}
void
nsGlobalWindowOuter
:
:
DisableDialogs
(
)
{
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
DisableDialogs
(
)
called
without
a
top
window
?
"
)
;
return
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWindow
)
{
topWindow
-
>
mAreDialogsEnabled
=
false
;
}
}
void
nsGlobalWindowOuter
:
:
EnableDialogs
(
)
{
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
EnableDialogs
(
)
called
without
a
top
window
?
"
)
;
return
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWindow
)
{
topWindow
-
>
mAreDialogsEnabled
=
true
;
}
}
nsresult
nsGlobalWindowOuter
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
MOZ_CRASH
(
"
The
outer
window
should
not
be
part
of
an
event
path
"
)
;
}
void
nsGlobalWindowOuter
:
:
PoisonOuterWindowProxy
(
JSObject
*
aObject
)
{
if
(
aObject
=
=
GetWrapperMaybeDead
(
)
)
{
PoisonWrapper
(
)
;
}
}
nsresult
nsGlobalWindowOuter
:
:
SetArguments
(
nsIArray
*
aArguments
)
{
nsresult
rv
;
nsGlobalWindowInner
*
currentInner
=
GetCurrentInnerWindowInternal
(
)
;
mArguments
=
aArguments
;
rv
=
currentInner
-
>
DefineArgumentsProperty
(
aArguments
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsIPrincipal
*
nsGlobalWindowOuter
:
:
GetPrincipal
(
)
{
if
(
mDoc
)
{
return
mDoc
-
>
NodePrincipal
(
)
;
}
if
(
mDocumentPrincipal
)
{
return
mDocumentPrincipal
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
objPrincipal
=
do_QueryInterface
(
GetParentInternal
(
)
)
;
if
(
objPrincipal
)
{
return
objPrincipal
-
>
GetPrincipal
(
)
;
}
return
nullptr
;
}
void
nsPIDOMWindowOuter
:
:
SetInitialKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
{
MOZ_ASSERT
(
!
GetCurrentInnerWindow
(
)
)
;
nsPIDOMWindowOuter
*
piWin
=
GetPrivateRoot
(
)
;
if
(
!
piWin
)
{
return
;
}
MOZ_ASSERT
(
piWin
=
=
this
)
;
nsCOMPtr
<
nsPIWindowRoot
>
windowRoot
=
do_QueryInterface
(
mChromeEventHandler
)
;
if
(
!
windowRoot
)
{
return
;
}
if
(
aShowAccelerators
!
=
UIStateChangeType_NoChange
)
{
windowRoot
-
>
SetShowAccelerators
(
aShowAccelerators
=
=
UIStateChangeType_Set
)
;
}
if
(
aShowFocusRings
!
=
UIStateChangeType_NoChange
)
{
windowRoot
-
>
SetShowFocusRings
(
aShowFocusRings
=
=
UIStateChangeType_Set
)
;
}
nsContentUtils
:
:
SetKeyboardIndicatorsOnRemoteChildren
(
GetOuterWindow
(
)
aShowAccelerators
aShowFocusRings
)
;
}
Element
*
nsPIDOMWindowOuter
:
:
GetFrameElementInternal
(
)
const
{
return
mFrameElement
;
}
void
nsPIDOMWindowOuter
:
:
SetFrameElementInternal
(
Element
*
aFrameElement
)
{
mFrameElement
=
aFrameElement
;
}
Navigator
*
nsGlobalWindowOuter
:
:
GetNavigator
(
)
{
FORWARD_TO_INNER
(
Navigator
(
)
nullptr
)
;
}
nsScreen
*
nsGlobalWindowOuter
:
:
GetScreen
(
)
{
FORWARD_TO_INNER
(
GetScreen
(
IgnoreErrors
(
)
)
nullptr
)
;
}
void
nsPIDOMWindowOuter
:
:
MaybeActiveMediaComponents
(
)
{
if
(
mMediaSuspend
!
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
{
return
;
}
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
nsPIDOMWindowOuter
MaybeActiveMediaComponents
"
"
resume
the
window
from
blocked
this
=
%
p
\
n
"
this
)
)
;
SetMediaSuspend
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
}
SuspendTypes
nsPIDOMWindowOuter
:
:
GetMediaSuspend
(
)
const
{
return
mMediaSuspend
;
}
void
nsPIDOMWindowOuter
:
:
SetMediaSuspend
(
SuspendTypes
aSuspend
)
{
if
(
!
IsDisposableSuspend
(
aSuspend
)
)
{
MaybeNotifyMediaResumedFromBlock
(
aSuspend
)
;
mMediaSuspend
=
aSuspend
;
}
RefreshMediaElementsSuspend
(
aSuspend
)
;
}
void
nsPIDOMWindowOuter
:
:
MaybeNotifyMediaResumedFromBlock
(
SuspendTypes
aSuspend
)
{
if
(
mMediaSuspend
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
&
&
aSuspend
=
=
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
{
RefPtr
<
AudioChannelService
>
service
=
AudioChannelService
:
:
GetOrCreate
(
)
;
if
(
service
)
{
service
-
>
NotifyMediaResumedFromBlock
(
GetOuterWindow
(
)
)
;
}
}
}
bool
nsPIDOMWindowOuter
:
:
GetAudioMuted
(
)
const
{
return
mAudioMuted
;
}
void
nsPIDOMWindowOuter
:
:
SetAudioMuted
(
bool
aMuted
)
{
if
(
mAudioMuted
=
=
aMuted
)
{
return
;
}
mAudioMuted
=
aMuted
;
RefreshMediaElementsVolume
(
)
;
}
float
nsPIDOMWindowOuter
:
:
GetAudioVolume
(
)
const
{
return
mAudioVolume
;
}
nsresult
nsPIDOMWindowOuter
:
:
SetAudioVolume
(
float
aVolume
)
{
if
(
aVolume
<
0
.
0
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
mAudioVolume
=
=
aVolume
)
{
return
NS_OK
;
}
mAudioVolume
=
aVolume
;
RefreshMediaElementsVolume
(
)
;
return
NS_OK
;
}
void
nsPIDOMWindowOuter
:
:
RefreshMediaElementsVolume
(
)
{
RefPtr
<
AudioChannelService
>
service
=
AudioChannelService
:
:
GetOrCreate
(
)
;
if
(
service
)
{
service
-
>
RefreshAgentsVolume
(
GetOuterWindow
(
)
)
;
}
}
void
nsPIDOMWindowOuter
:
:
RefreshMediaElementsSuspend
(
SuspendTypes
aSuspend
)
{
RefPtr
<
AudioChannelService
>
service
=
AudioChannelService
:
:
GetOrCreate
(
)
;
if
(
service
)
{
service
-
>
RefreshAgentsSuspend
(
GetOuterWindow
(
)
aSuspend
)
;
}
}
bool
nsPIDOMWindowOuter
:
:
IsDisposableSuspend
(
SuspendTypes
aSuspend
)
const
{
return
(
aSuspend
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
|
|
aSuspend
=
=
nsISuspendedTypes
:
:
SUSPENDED_STOP_DISPOSABLE
)
;
}
void
nsPIDOMWindowOuter
:
:
SetServiceWorkersTestingEnabled
(
bool
aEnabled
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
GetScriptableTop
(
)
;
MOZ_ASSERT_IF
(
aEnabled
this
=
=
topWindow
)
;
#
endif
mServiceWorkersTestingEnabled
=
aEnabled
;
}
bool
nsPIDOMWindowOuter
:
:
GetServiceWorkersTestingEnabled
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
GetScriptableTop
(
)
;
if
(
!
topWindow
)
{
return
false
;
}
return
topWindow
-
>
mServiceWorkersTestingEnabled
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowOuter
:
:
GetParentOuter
(
)
{
nsPIDOMWindowOuter
*
parent
=
GetScriptableParent
(
)
;
BrowsingContext
*
parentBC
;
if
(
!
parent
|
|
!
(
parentBC
=
parent
-
>
GetBrowsingContext
(
)
)
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
parentBC
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetScriptableParent
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
if
(
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
return
this
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParent
(
)
;
return
parent
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetScriptableParentOrNull
(
)
{
nsPIDOMWindowOuter
*
parent
=
GetScriptableParent
(
)
;
return
(
nsGlobalWindowOuter
:
:
Cast
(
parent
)
=
=
this
)
?
nullptr
:
parent
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowOuter
:
:
GetParent
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
parent
;
mDocShell
-
>
GetSameTypeParentIgnoreBrowserBoundaries
(
getter_AddRefs
(
parent
)
)
;
if
(
parent
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
parent
-
>
GetWindow
(
)
;
return
win
.
forget
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
(
this
)
;
return
win
.
forget
(
)
;
}
static
nsresult
GetTopImpl
(
nsGlobalWindowOuter
*
aWin
nsIURI
*
aURIBeingLoaded
nsPIDOMWindowOuter
*
*
aTop
bool
aScriptable
bool
aExcludingExtensionAccessibleContentFrames
)
{
*
aTop
=
nullptr
;
MOZ_ASSERT_IF
(
aExcludingExtensionAccessibleContentFrames
!
aScriptable
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
prevParent
=
aWin
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
aWin
;
do
{
if
(
!
parent
)
{
break
;
}
prevParent
=
parent
;
if
(
aScriptable
)
{
parent
=
parent
-
>
GetScriptableParent
(
)
;
}
else
{
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
aExcludingExtensionAccessibleContentFrames
)
{
if
(
auto
*
p
=
nsGlobalWindowOuter
:
:
Cast
(
parent
)
)
{
nsGlobalWindowInner
*
currentInner
=
p
-
>
GetCurrentInnerWindowInternal
(
)
;
nsIURI
*
uri
=
prevParent
-
>
GetDocumentURI
(
)
;
if
(
!
uri
)
{
uri
=
aURIBeingLoaded
;
}
if
(
currentInner
&
&
uri
)
{
MOZ_DIAGNOSTIC_ASSERT
(
uri
)
;
if
(
BasePrincipal
:
:
Cast
(
p
-
>
GetPrincipal
(
)
)
-
>
AddonAllowsLoad
(
uri
true
)
)
{
parent
=
prevParent
;
break
;
}
}
}
}
}
while
(
parent
!
=
prevParent
)
;
if
(
parent
)
{
parent
.
swap
(
*
aTop
)
;
}
return
NS_OK
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetScriptableTop
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
GetTopImpl
(
this
nullptr
getter_AddRefs
(
window
)
true
false
)
;
return
window
.
get
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowOuter
:
:
GetTop
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
GetTopImpl
(
this
nullptr
getter_AddRefs
(
window
)
false
false
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowOuter
:
:
GetTopExcludingExtensionAccessibleContentFrames
(
nsIURI
*
aURIBeingLoaded
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
GetTopImpl
(
this
aURIBeingLoaded
getter_AddRefs
(
window
)
false
true
)
;
return
window
.
forget
(
)
;
}
void
nsGlobalWindowOuter
:
:
GetContentOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
CallerType
aCallerType
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
content
=
GetContentInternal
(
aError
aCallerType
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
if
(
content
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCx
)
;
aError
=
nsContentUtils
:
:
WrapNative
(
aCx
content
&
val
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
aRetval
.
set
(
&
val
.
toObject
(
)
)
;
return
;
}
aRetval
.
set
(
nullptr
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowOuter
:
:
GetContentInternal
(
ErrorResult
&
aError
CallerType
aCallerType
)
{
RefPtr
<
BrowsingContext
>
bc
=
GetChildWindow
(
NS_LITERAL_STRING
(
"
content
"
)
)
;
if
(
bc
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
content
(
bc
-
>
GetDOMWindow
(
)
)
;
return
content
.
forget
(
)
;
}
if
(
mDocShell
&
&
mDocShell
-
>
GetIsInMozBrowser
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
(
GetScriptableTop
(
)
)
;
return
domWindow
.
forget
(
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
primaryContent
;
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
Document
:
:
eWindowContentUntrusted
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseWin
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
baseWin
)
{
bool
visible
=
false
;
baseWin
-
>
GetVisibility
(
&
visible
)
;
if
(
!
visible
)
{
mDocShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
primaryContent
)
)
;
}
}
}
if
(
!
primaryContent
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
if
(
!
treeOwner
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
treeOwner
-
>
GetPrimaryContentShell
(
getter_AddRefs
(
primaryContent
)
)
;
}
if
(
!
primaryContent
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
primaryContent
-
>
GetWindow
(
)
;
return
domWindow
.
forget
(
)
;
}
nsresult
nsGlobalWindowOuter
:
:
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
{
if
(
!
mDocShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIPrompt
>
prompter
(
do_GetInterface
(
mDocShell
)
)
;
NS_ENSURE_TRUE
(
prompter
NS_ERROR_NO_INTERFACE
)
;
prompter
.
forget
(
aPrompt
)
;
return
NS_OK
;
}
bool
nsGlobalWindowOuter
:
:
GetClosedOuter
(
)
{
return
mIsClosed
|
|
!
mDocShell
;
}
bool
nsGlobalWindowOuter
:
:
Closed
(
)
{
return
GetClosedOuter
(
)
;
}
nsDOMWindowList
*
nsGlobalWindowOuter
:
:
GetFrames
(
)
{
if
(
!
mFrames
&
&
mDocShell
)
{
mFrames
=
new
nsDOMWindowList
(
mDocShell
)
;
}
return
mFrames
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowOuter
:
:
IndexedGetterOuter
(
uint32_t
aIndex
)
{
nsDOMWindowList
*
windows
=
GetFrames
(
)
;
NS_ENSURE_TRUE
(
windows
nullptr
)
;
return
windows
-
>
IndexedGetter
(
aIndex
)
;
}
nsIControllers
*
nsGlobalWindowOuter
:
:
GetControllersOuter
(
ErrorResult
&
aError
)
{
if
(
!
mControllers
)
{
mControllers
=
new
nsXULControllers
(
)
;
if
(
!
mControllers
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIController
>
controller
=
nsBaseCommandController
:
:
CreateWindowController
(
)
;
if
(
!
controller
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mControllers
-
>
InsertControllerAt
(
0
controller
)
;
nsCOMPtr
<
nsIControllerContext
>
controllerContext
=
do_QueryInterface
(
controller
)
;
if
(
!
controllerContext
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
controllerContext
-
>
SetCommandContext
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
)
;
}
return
mControllers
;
}
nsresult
nsGlobalWindowOuter
:
:
GetControllers
(
nsIControllers
*
*
aResult
)
{
FORWARD_TO_INNER
(
GetControllers
(
aResult
)
NS_ERROR_UNEXPECTED
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetSanitizedOpener
(
nsPIDOMWindowOuter
*
aOpener
)
{
if
(
!
aOpener
)
{
return
nullptr
;
}
nsGlobalWindowOuter
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
aOpener
)
;
if
(
win
-
>
IsChromeWindow
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
openerDocShell
=
aOpener
-
>
GetDocShell
(
)
;
if
(
openerDocShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
openerRootItem
;
openerDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
openerRootItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
openerRootDocShell
(
do_QueryInterface
(
openerRootItem
)
)
;
if
(
openerRootDocShell
)
{
nsIDocShell
:
:
AppType
appType
=
openerRootDocShell
-
>
GetAppType
(
)
;
if
(
appType
!
=
nsIDocShell
:
:
APP_TYPE_MAIL
)
{
return
aOpener
;
}
}
}
return
nullptr
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetOpenerWindowOuter
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
do_QueryReferent
(
mOpener
)
;
if
(
!
opener
)
{
return
nullptr
;
}
if
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
if
(
GetPrincipal
(
)
=
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
&
&
nsGlobalWindowOuter
:
:
Cast
(
opener
)
-
>
GetPrincipal
(
)
!
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
{
return
nullptr
;
}
return
opener
;
}
return
GetSanitizedOpener
(
opener
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowOuter
:
:
GetOpener
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
GetOpenerWindowOuter
(
)
;
return
opener
.
forget
(
)
;
}
void
nsGlobalWindowOuter
:
:
GetStatusOuter
(
nsAString
&
aStatus
)
{
aStatus
=
mStatus
;
}
void
nsGlobalWindowOuter
:
:
SetStatusOuter
(
const
nsAString
&
aStatus
)
{
mStatus
=
aStatus
;
}
void
nsGlobalWindowOuter
:
:
GetNameOuter
(
nsAString
&
aName
)
{
if
(
mDocShell
)
{
mDocShell
-
>
GetName
(
aName
)
;
}
}
void
nsGlobalWindowOuter
:
:
SetNameOuter
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
mDocShell
)
{
aError
=
mDocShell
-
>
SetName
(
aName
)
;
}
}
int32_t
nsGlobalWindowOuter
:
:
DevToCSSIntPixels
(
int32_t
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
return
px
;
return
presContext
-
>
DevPixelsToIntCSSPixels
(
px
)
;
}
int32_t
nsGlobalWindowOuter
:
:
CSSToDevIntPixels
(
int32_t
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
return
px
;
return
presContext
-
>
CSSPixelsToDevPixels
(
px
)
;
}
nsIntSize
nsGlobalWindowOuter
:
:
DevToCSSIntPixels
(
nsIntSize
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
return
px
;
return
nsIntSize
(
presContext
-
>
DevPixelsToIntCSSPixels
(
px
.
width
)
presContext
-
>
DevPixelsToIntCSSPixels
(
px
.
height
)
)
;
}
nsIntSize
nsGlobalWindowOuter
:
:
CSSToDevIntPixels
(
nsIntSize
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
return
px
;
return
nsIntSize
(
presContext
-
>
CSSPixelsToDevPixels
(
px
.
width
)
presContext
-
>
CSSPixelsToDevPixels
(
px
.
height
)
)
;
}
nsresult
nsGlobalWindowOuter
:
:
GetInnerSize
(
CSSIntSize
&
aSize
)
{
EnsureSizeAndPositionUpToDate
(
)
;
NS_ENSURE_STATE
(
mDocShell
)
;
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
RefPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presContext
|
|
!
presShell
)
{
aSize
=
CSSIntSize
(
0
0
)
;
return
NS_OK
;
}
if
(
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
aSize
=
CSSIntRect
:
:
FromAppUnitsRounded
(
presShell
-
>
GetVisualViewportSize
(
)
)
;
return
NS_OK
;
}
RefPtr
<
nsViewManager
>
viewManager
=
presShell
-
>
GetViewManager
(
)
;
if
(
viewManager
)
{
viewManager
-
>
FlushDelayedResize
(
false
)
;
}
aSize
=
CSSIntRect
:
:
FromAppUnitsRounded
(
presContext
-
>
GetVisibleArea
(
)
.
Size
(
)
)
;
return
NS_OK
;
}
int32_t
nsGlobalWindowOuter
:
:
GetInnerWidthOuter
(
ErrorResult
&
aError
)
{
CSSIntSize
size
;
aError
=
GetInnerSize
(
size
)
;
return
size
.
width
;
}
nsresult
nsGlobalWindowOuter
:
:
GetInnerWidth
(
int32_t
*
aInnerWidth
)
{
FORWARD_TO_INNER
(
GetInnerWidth
(
aInnerWidth
)
NS_ERROR_UNEXPECTED
)
;
}
void
nsGlobalWindowOuter
:
:
SetInnerWidthOuter
(
int32_t
aInnerWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
!
mDocShell
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
CheckSecurityWidthAndHeight
(
&
aInnerWidth
nullptr
aCallerType
)
;
RefPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
CSSSize
viewportSize
=
CSSRect
:
:
FromAppUnits
(
presShell
-
>
GetVisualViewportSize
(
)
)
;
viewportSize
.
width
=
aInnerWidth
;
nsLayoutUtils
:
:
SetVisualViewportSize
(
presShell
viewportSize
)
;
return
;
}
if
(
presShell
&
&
presShell
-
>
GetIsViewportOverridden
(
)
)
{
nscoord
height
=
0
;
RefPtr
<
nsPresContext
>
presContext
;
presContext
=
presShell
-
>
GetPresContext
(
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
height
=
shellArea
.
Height
(
)
;
SetCSSViewportWidthAndHeight
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aInnerWidth
)
height
)
;
return
;
}
int32_t
height
=
0
;
int32_t
unused
=
0
;
nsCOMPtr
<
nsIBaseWindow
>
docShellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
docShellAsWin
-
>
GetSize
(
&
unused
&
height
)
;
aError
=
SetDocShellWidthAndHeight
(
CSSToDevIntPixels
(
aInnerWidth
)
height
)
;
}
int32_t
nsGlobalWindowOuter
:
:
GetInnerHeightOuter
(
ErrorResult
&
aError
)
{
CSSIntSize
size
;
aError
=
GetInnerSize
(
size
)
;
return
size
.
height
;
}
nsresult
nsGlobalWindowOuter
:
:
GetInnerHeight
(
int32_t
*
aInnerHeight
)
{
FORWARD_TO_INNER
(
GetInnerHeight
(
aInnerHeight
)
NS_ERROR_UNEXPECTED
)
;
}
void
nsGlobalWindowOuter
:
:
SetInnerHeightOuter
(
int32_t
aInnerHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
!
mDocShell
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
CheckSecurityWidthAndHeight
(
nullptr
&
aInnerHeight
aCallerType
)
;
RefPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
CSSSize
viewportSize
=
CSSRect
:
:
FromAppUnits
(
presShell
-
>
GetVisualViewportSize
(
)
)
;
viewportSize
.
height
=
aInnerHeight
;
nsLayoutUtils
:
:
SetVisualViewportSize
(
presShell
viewportSize
)
;
return
;
}
if
(
presShell
&
&
presShell
-
>
GetIsViewportOverridden
(
)
)
{
nscoord
width
=
0
;
RefPtr
<
nsPresContext
>
presContext
;
presContext
=
presShell
-
>
GetPresContext
(
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
width
=
shellArea
.
Width
(
)
;
SetCSSViewportWidthAndHeight
(
width
nsPresContext
:
:
CSSPixelsToAppUnits
(
aInnerHeight
)
)
;
return
;
}
int32_t
height
=
0
;
int32_t
width
=
0
;
nsCOMPtr
<
nsIBaseWindow
>
docShellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
docShellAsWin
-
>
GetSize
(
&
width
&
height
)
;
aError
=
SetDocShellWidthAndHeight
(
width
CSSToDevIntPixels
(
aInnerHeight
)
)
;
}
nsIntSize
nsGlobalWindowOuter
:
:
GetOuterSize
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
CSSIntSize
size
;
aError
=
GetInnerSize
(
size
)
;
return
nsIntSize
(
size
.
width
size
.
height
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nsIntSize
(
0
0
)
;
}
nsIntSize
sizeDevPixels
;
aError
=
treeOwnerAsWin
-
>
GetSize
(
&
sizeDevPixels
.
width
&
sizeDevPixels
.
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
nsIntSize
(
)
;
}
return
DevToCSSIntPixels
(
sizeDevPixels
)
;
}
int32_t
nsGlobalWindowOuter
:
:
GetOuterWidthOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
return
GetOuterSize
(
aCallerType
aError
)
.
width
;
}
int32_t
nsGlobalWindowOuter
:
:
GetOuterHeightOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
return
GetOuterSize
(
aCallerType
aError
)
.
height
;
}
void
nsGlobalWindowOuter
:
:
SetOuterSize
(
int32_t
aLengthCSSPixels
bool
aIsWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
CheckSecurityWidthAndHeight
(
aIsWidth
?
&
aLengthCSSPixels
:
nullptr
aIsWidth
?
nullptr
:
&
aLengthCSSPixels
aCallerType
)
;
int32_t
width
height
;
aError
=
treeOwnerAsWin
-
>
GetSize
(
&
width
&
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
int32_t
lengthDevPixels
=
CSSToDevIntPixels
(
aLengthCSSPixels
)
;
if
(
aIsWidth
)
{
width
=
lengthDevPixels
;
}
else
{
height
=
lengthDevPixels
;
}
aError
=
treeOwnerAsWin
-
>
SetSize
(
width
height
true
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowOuter
:
:
SetOuterWidthOuter
(
int32_t
aOuterWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetOuterSize
(
aOuterWidth
true
aCallerType
aError
)
;
}
void
nsGlobalWindowOuter
:
:
SetOuterHeightOuter
(
int32_t
aOuterHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetOuterSize
(
aOuterHeight
false
aCallerType
aError
)
;
}
CSSIntPoint
nsGlobalWindowOuter
:
:
GetScreenXY
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
CSSIntPoint
(
0
0
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
CSSIntPoint
(
0
0
)
;
}
int32_t
x
=
0
y
=
0
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
CSSIntPoint
(
x
y
)
;
}
nsDeviceContext
*
dc
=
presContext
-
>
DeviceContext
(
)
;
nsRect
screenRect
;
dc
-
>
GetRect
(
screenRect
)
;
LayoutDeviceRect
screenRectDev
=
LayoutDevicePixel
:
:
FromAppUnits
(
screenRect
dc
-
>
AppUnitsPerDevPixel
(
)
)
;
DesktopToLayoutDeviceScale
scale
=
dc
-
>
GetDesktopToDeviceScale
(
)
;
DesktopRect
screenRectDesk
=
screenRectDev
/
scale
;
CSSPoint
cssPt
=
LayoutDevicePoint
(
x
-
screenRectDev
.
x
y
-
screenRectDev
.
y
)
/
presContext
-
>
CSSToDevPixelScale
(
)
;
cssPt
.
x
+
=
screenRectDesk
.
x
;
cssPt
.
y
+
=
screenRectDesk
.
y
;
return
CSSIntPoint
(
NSToIntRound
(
cssPt
.
x
)
NSToIntRound
(
cssPt
.
y
)
)
;
}
int32_t
nsGlobalWindowOuter
:
:
GetScreenXOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
return
GetScreenXY
(
aCallerType
aError
)
.
x
;
}
nsRect
nsGlobalWindowOuter
:
:
GetInnerScreenRect
(
)
{
if
(
!
mDocShell
)
{
return
nsRect
(
)
;
}
EnsureSizeAndPositionUpToDate
(
)
;
if
(
!
mDocShell
)
{
return
nsRect
(
)
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nsRect
(
)
;
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nsRect
(
)
;
}
return
rootFrame
-
>
GetScreenRectInAppUnits
(
)
;
}
float
nsGlobalWindowOuter
:
:
GetMozInnerScreenXOuter
(
CallerType
aCallerType
)
{
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
0
.
0
;
}
nsRect
r
=
GetInnerScreenRect
(
)
;
return
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
r
.
x
)
;
}
float
nsGlobalWindowOuter
:
:
GetMozInnerScreenYOuter
(
CallerType
aCallerType
)
{
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
0
.
0
;
}
nsRect
r
=
GetInnerScreenRect
(
)
;
return
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
r
.
y
)
;
}
double
nsGlobalWindowOuter
:
:
GetDevicePixelRatioOuter
(
CallerType
aCallerType
)
{
if
(
!
mDocShell
)
{
return
1
.
0
;
}
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
1
.
0
;
}
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
1
.
0
;
}
float
overrideDPPX
=
presContext
-
>
GetOverrideDPPX
(
)
;
if
(
overrideDPPX
>
0
)
{
return
overrideDPPX
;
}
return
double
(
AppUnitsPerCSSPixel
(
)
)
/
double
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
float
nsPIDOMWindowOuter
:
:
GetDevicePixelRatio
(
CallerType
aCallerType
)
{
return
nsGlobalWindowOuter
:
:
Cast
(
this
)
-
>
GetDevicePixelRatioOuter
(
aCallerType
)
;
}
uint64_t
nsGlobalWindowOuter
:
:
GetMozPaintCountOuter
(
)
{
if
(
!
mDocShell
)
{
return
0
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPaintCount
(
)
:
0
;
}
already_AddRefed
<
MediaQueryList
>
nsGlobalWindowOuter
:
:
MatchMediaOuter
(
const
nsAString
&
aMediaQueryList
CallerType
aCallerType
)
{
if
(
!
mDoc
)
{
return
nullptr
;
}
return
mDoc
-
>
MatchMedia
(
aMediaQueryList
aCallerType
)
;
}
void
nsGlobalWindowOuter
:
:
SetScreenXOuter
(
int32_t
aScreenX
CallerType
aCallerType
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
x
y
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
CheckSecurityLeftAndTop
(
&
aScreenX
nullptr
aCallerType
)
;
x
=
CSSToDevIntPixels
(
aScreenX
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
x
y
)
;
CheckForDPIChange
(
)
;
}
int32_t
nsGlobalWindowOuter
:
:
GetScreenYOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
return
GetScreenXY
(
aCallerType
aError
)
.
y
;
}
void
nsGlobalWindowOuter
:
:
SetScreenYOuter
(
int32_t
aScreenY
CallerType
aCallerType
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
x
y
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
CheckSecurityLeftAndTop
(
nullptr
&
aScreenY
aCallerType
)
;
y
=
CSSToDevIntPixels
(
aScreenY
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
x
y
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowOuter
:
:
CheckSecurityWidthAndHeight
(
int32_t
*
aWidth
int32_t
*
aHeight
CallerType
aCallerType
)
{
#
ifdef
MOZ_XUL
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
nsContentUtils
:
:
HidePopupsInDocument
(
mDoc
)
;
}
#
endif
if
(
(
aWidth
&
&
*
aWidth
<
100
)
|
|
(
aHeight
&
&
*
aHeight
<
100
)
)
{
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
aWidth
&
&
*
aWidth
<
100
)
{
*
aWidth
=
100
;
}
if
(
aHeight
&
&
*
aHeight
<
100
)
{
*
aHeight
=
100
;
}
}
}
}
nsresult
nsGlobalWindowOuter
:
:
SetDocShellWidthAndHeight
(
int32_t
aInnerWidth
int32_t
aInnerHeight
)
{
NS_ENSURE_TRUE
(
mDocShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
mDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
NS_ENSURE_TRUE
(
treeOwner
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
treeOwner
-
>
SizeShellTo
(
mDocShell
aInnerWidth
aInnerHeight
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
void
nsGlobalWindowOuter
:
:
SetCSSViewportWidthAndHeight
(
nscoord
aInnerWidth
nscoord
aInnerHeight
)
{
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
shellArea
.
SetHeight
(
aInnerHeight
)
;
shellArea
.
SetWidth
(
aInnerWidth
)
;
presContext
-
>
SetVisibleArea
(
shellArea
)
;
}
void
nsGlobalWindowOuter
:
:
CheckSecurityLeftAndTop
(
int32_t
*
aLeft
int32_t
*
aTop
CallerType
aCallerType
)
{
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
#
ifdef
MOZ_XUL
nsContentUtils
:
:
HidePopupsInDocument
(
mDoc
)
;
#
endif
if
(
nsGlobalWindowOuter
*
rootWindow
=
nsGlobalWindowOuter
:
:
Cast
(
GetPrivateRoot
(
)
)
)
{
rootWindow
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwner
=
GetTreeOwnerWindow
(
)
;
RefPtr
<
nsScreen
>
screen
=
GetScreen
(
)
;
if
(
treeOwner
&
&
screen
)
{
int32_t
winLeft
winTop
winWidth
winHeight
;
treeOwner
-
>
GetPositionAndSize
(
&
winLeft
&
winTop
&
winWidth
&
winHeight
)
;
winLeft
=
DevToCSSIntPixels
(
winLeft
)
;
winTop
=
DevToCSSIntPixels
(
winTop
)
;
winWidth
=
DevToCSSIntPixels
(
winWidth
)
;
winHeight
=
DevToCSSIntPixels
(
winHeight
)
;
int32_t
screenLeft
=
screen
-
>
GetAvailLeft
(
IgnoreErrors
(
)
)
;
int32_t
screenWidth
=
screen
-
>
GetAvailWidth
(
IgnoreErrors
(
)
)
;
int32_t
screenHeight
=
screen
-
>
GetAvailHeight
(
IgnoreErrors
(
)
)
;
#
if
defined
(
XP_MACOSX
)
int32_t
screenTop
=
screen
-
>
GetTop
(
IgnoreErrors
(
)
)
;
#
else
int32_t
screenTop
=
screen
-
>
GetAvailTop
(
IgnoreErrors
(
)
)
;
#
endif
if
(
aLeft
)
{
if
(
screenLeft
+
screenWidth
<
*
aLeft
+
winWidth
)
*
aLeft
=
screenLeft
+
screenWidth
-
winWidth
;
if
(
screenLeft
>
*
aLeft
)
*
aLeft
=
screenLeft
;
}
if
(
aTop
)
{
if
(
screenTop
+
screenHeight
<
*
aTop
+
winHeight
)
*
aTop
=
screenTop
+
screenHeight
-
winHeight
;
if
(
screenTop
>
*
aTop
)
*
aTop
=
screenTop
;
}
}
else
{
if
(
aLeft
)
*
aLeft
=
0
;
if
(
aTop
)
*
aTop
=
0
;
}
}
}
int32_t
nsGlobalWindowOuter
:
:
GetScrollBoundaryOuter
(
Side
aSide
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
)
{
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
sf
-
>
GetScrollRange
(
)
.
Edge
(
aSide
)
)
;
}
return
0
;
}
CSSPoint
nsGlobalWindowOuter
:
:
GetScrollXY
(
bool
aDoFlush
)
{
if
(
aDoFlush
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
else
{
EnsureSizeAndPositionUpToDate
(
)
;
}
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
!
sf
)
{
return
CSSIntPoint
(
0
0
)
;
}
nsPoint
scrollPos
=
sf
-
>
GetScrollPosition
(
)
;
if
(
scrollPos
!
=
nsPoint
(
0
0
)
&
&
!
aDoFlush
)
{
return
GetScrollXY
(
true
)
;
}
return
CSSPoint
:
:
FromAppUnits
(
scrollPos
)
;
}
double
nsGlobalWindowOuter
:
:
GetScrollXOuter
(
)
{
return
GetScrollXY
(
false
)
.
x
;
}
double
nsGlobalWindowOuter
:
:
GetScrollYOuter
(
)
{
return
GetScrollXY
(
false
)
.
y
;
}
uint32_t
nsGlobalWindowOuter
:
:
Length
(
)
{
nsDOMWindowList
*
windows
=
GetFrames
(
)
;
return
windows
?
windows
-
>
GetLength
(
)
:
0
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowOuter
:
:
GetTopOuter
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
GetScriptableTop
(
)
;
BrowsingContext
*
topBC
;
if
(
!
top
|
|
!
(
topBC
=
top
-
>
GetBrowsingContext
(
)
)
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
topBC
)
;
}
already_AddRefed
<
BrowsingContext
>
nsGlobalWindowOuter
:
:
GetChildWindow
(
const
nsAString
&
aName
)
{
NS_ENSURE_TRUE
(
mBrowsingContext
nullptr
)
;
return
mBrowsingContext
-
>
FindChildWithName
(
aName
)
;
}
bool
nsGlobalWindowOuter
:
:
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
{
bool
defaultActionEnabled
=
true
;
nsContentUtils
:
:
DispatchTrustedEvent
(
mDoc
ToSupports
(
this
)
aEventName
CanBubble
:
:
eYes
Cancelable
:
:
eYes
&
defaultActionEnabled
)
;
return
defaultActionEnabled
;
}
bool
nsGlobalWindowOuter
:
:
DispatchResizeEvent
(
const
CSSIntSize
&
aSize
)
{
ErrorResult
res
;
RefPtr
<
Event
>
domEvent
=
mDoc
-
>
CreateEvent
(
NS_LITERAL_STRING
(
"
CustomEvent
"
)
CallerType
:
:
System
res
)
;
if
(
res
.
Failed
(
)
)
{
return
false
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSAutoRealm
ar
(
cx
GetWrapperPreserveColor
(
)
)
;
DOMWindowResizeEventDetail
detail
;
detail
.
mWidth
=
aSize
.
width
;
detail
.
mHeight
=
aSize
.
height
;
JS
:
:
Rooted
<
JS
:
:
Value
>
detailValue
(
cx
)
;
if
(
!
ToJSValue
(
cx
detail
&
detailValue
)
)
{
return
false
;
}
CustomEvent
*
customEvent
=
static_cast
<
CustomEvent
*
>
(
domEvent
.
get
(
)
)
;
customEvent
-
>
InitCustomEvent
(
cx
NS_LITERAL_STRING
(
"
DOMWindowResize
"
)
true
true
detailValue
)
;
domEvent
-
>
SetTrusted
(
true
)
;
domEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
GetOuterWindow
(
)
)
;
domEvent
-
>
SetTarget
(
target
)
;
return
target
-
>
DispatchEvent
(
*
domEvent
CallerType
:
:
System
IgnoreErrors
(
)
)
;
}
static
already_AddRefed
<
nsIDocShellTreeItem
>
GetCallerDocShellTreeItem
(
)
{
nsCOMPtr
<
nsIWebNavigation
>
callerWebNav
=
do_GetInterface
(
GetEntryGlobal
(
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
callerItem
=
do_QueryInterface
(
callerWebNav
)
;
return
callerItem
.
forget
(
)
;
}
bool
nsGlobalWindowOuter
:
:
WindowExists
(
const
nsAString
&
aName
bool
aForceNoOpener
bool
aLookForCallerOnJSStack
)
{
MOZ_ASSERT
(
mDocShell
"
Must
have
docshell
"
)
;
if
(
aForceNoOpener
)
{
return
aName
.
LowerCaseEqualsLiteral
(
"
_self
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
_top
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
caller
;
if
(
aLookForCallerOnJSStack
)
{
caller
=
GetCallerDocShellTreeItem
(
)
;
}
if
(
!
caller
)
{
caller
=
mDocShell
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
namedItem
;
mDocShell
-
>
FindItemWithName
(
aName
nullptr
caller
false
getter_AddRefs
(
namedItem
)
)
;
return
namedItem
!
=
nullptr
;
}
already_AddRefed
<
nsIWidget
>
nsGlobalWindowOuter
:
:
GetMainWidget
(
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
nsCOMPtr
<
nsIWidget
>
widget
;
if
(
treeOwnerAsWin
)
{
treeOwnerAsWin
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
}
return
widget
.
forget
(
)
;
}
nsIWidget
*
nsGlobalWindowOuter
:
:
GetNearestWidget
(
)
const
{
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
docShell
nullptr
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
nullptr
)
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
nullptr
)
;
return
rootFrame
-
>
GetView
(
)
-
>
GetNearestWidget
(
nullptr
)
;
}
void
nsGlobalWindowOuter
:
:
SetFullscreenOuter
(
bool
aFullscreen
mozilla
:
:
ErrorResult
&
aError
)
{
aError
=
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenMode
aFullscreen
)
;
}
nsresult
nsGlobalWindowOuter
:
:
SetFullScreen
(
bool
aFullscreen
)
{
return
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenMode
aFullscreen
)
;
}
static
void
FinishDOMFullscreenChange
(
Document
*
aDoc
bool
aInDOMFullscreen
)
{
if
(
aInDOMFullscreen
)
{
if
(
!
Document
:
:
HandlePendingFullscreenRequests
(
aDoc
)
)
{
Document
:
:
AsyncExitFullscreen
(
aDoc
)
;
}
}
else
{
Document
:
:
ExitFullscreenInDocTree
(
aDoc
)
;
}
}
struct
FullscreenTransitionDuration
{
uint16_t
mFadeIn
=
0
;
uint16_t
mFadeOut
=
0
;
bool
IsSuppressed
(
)
const
{
return
mFadeIn
=
=
0
&
&
mFadeOut
=
=
0
;
}
}
;
static
void
GetFullscreenTransitionDuration
(
bool
aEnterFullscreen
FullscreenTransitionDuration
*
aDuration
)
{
const
char
*
pref
=
aEnterFullscreen
?
"
full
-
screen
-
api
.
transition
-
duration
.
enter
"
:
"
full
-
screen
-
api
.
transition
-
duration
.
leave
"
;
nsAutoCString
prefValue
;
Preferences
:
:
GetCString
(
pref
prefValue
)
;
if
(
!
prefValue
.
IsEmpty
(
)
)
{
sscanf
(
prefValue
.
get
(
)
"
%
hu
%
hu
"
&
aDuration
-
>
mFadeIn
&
aDuration
-
>
mFadeOut
)
;
}
}
class
FullscreenTransitionTask
:
public
Runnable
{
public
:
FullscreenTransitionTask
(
const
FullscreenTransitionDuration
&
aDuration
nsGlobalWindowOuter
*
aWindow
bool
aFullscreen
nsIWidget
*
aWidget
nsIScreen
*
aScreen
nsISupports
*
aTransitionData
)
:
mozilla
:
:
Runnable
(
"
FullscreenTransitionTask
"
)
mWindow
(
aWindow
)
mWidget
(
aWidget
)
mScreen
(
aScreen
)
mTransitionData
(
aTransitionData
)
mDuration
(
aDuration
)
mStage
(
eBeforeToggle
)
mFullscreen
(
aFullscreen
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
~
FullscreenTransitionTask
(
)
override
{
}
enum
Stage
{
eBeforeToggle
eToggleFullscreen
eAfterToggle
eEnd
}
;
class
Observer
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
Observer
(
FullscreenTransitionTask
*
aTask
)
:
mTask
(
aTask
)
{
}
private
:
~
Observer
(
)
=
default
;
RefPtr
<
FullscreenTransitionTask
>
mTask
;
}
;
static
const
char
*
const
kPaintedTopic
;
RefPtr
<
nsGlobalWindowOuter
>
mWindow
;
nsCOMPtr
<
nsIWidget
>
mWidget
;
nsCOMPtr
<
nsIScreen
>
mScreen
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsCOMPtr
<
nsISupports
>
mTransitionData
;
TimeStamp
mFullscreenChangeStartTime
;
FullscreenTransitionDuration
mDuration
;
Stage
mStage
;
bool
mFullscreen
;
}
;
const
char
*
const
FullscreenTransitionTask
:
:
kPaintedTopic
=
"
fullscreen
-
painted
"
;
NS_IMETHODIMP
FullscreenTransitionTask
:
:
Run
(
)
{
Stage
stage
=
mStage
;
mStage
=
Stage
(
mStage
+
1
)
;
if
(
MOZ_UNLIKELY
(
mWidget
-
>
Destroyed
(
)
)
)
{
NS_WARNING
(
"
The
widget
to
fullscreen
has
been
destroyed
"
)
;
return
NS_OK
;
}
if
(
stage
=
=
eBeforeToggle
)
{
PROFILER_ADD_MARKER
(
"
Fullscreen
transition
start
"
DOM
)
;
mWidget
-
>
PerformFullscreenTransition
(
nsIWidget
:
:
eBeforeFullscreenToggle
mDuration
.
mFadeIn
mTransitionData
this
)
;
}
else
if
(
stage
=
=
eToggleFullscreen
)
{
PROFILER_ADD_MARKER
(
"
Fullscreen
toggle
start
"
DOM
)
;
mFullscreenChangeStartTime
=
TimeStamp
:
:
Now
(
)
;
if
(
MOZ_UNLIKELY
(
mWindow
-
>
mFullscreen
!
=
mFullscreen
)
)
{
NS_WARNING
(
"
The
fullscreen
state
of
the
window
does
not
match
"
)
;
mWindow
-
>
mFullscreen
=
mFullscreen
;
}
if
(
!
mWindow
-
>
SetWidgetFullscreen
(
FullscreenReason
:
:
ForFullscreenAPI
mFullscreen
mWidget
mScreen
)
)
{
mWindow
-
>
FinishFullscreenChange
(
mFullscreen
)
;
}
nsCOMPtr
<
nsIObserver
>
observer
=
new
Observer
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obs
-
>
AddObserver
(
observer
kPaintedTopic
false
)
;
uint32_t
timeout
=
Preferences
:
:
GetUint
(
"
full
-
screen
-
api
.
transition
.
timeout
"
1000
)
;
NS_NewTimerWithObserver
(
getter_AddRefs
(
mTimer
)
observer
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
else
if
(
stage
=
=
eAfterToggle
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
FULLSCREEN_TRANSITION_BLACK_MS
mFullscreenChangeStartTime
)
;
mWidget
-
>
PerformFullscreenTransition
(
nsIWidget
:
:
eAfterFullscreenToggle
mDuration
.
mFadeOut
mTransitionData
this
)
;
}
else
if
(
stage
=
=
eEnd
)
{
PROFILER_ADD_MARKER
(
"
Fullscreen
transition
end
"
DOM
)
;
mWidget
-
>
CleanupFullscreenTransition
(
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
FullscreenTransitionTask
:
:
Observer
nsIObserver
)
NS_IMETHODIMP
FullscreenTransitionTask
:
:
Observer
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
bool
shouldContinue
=
false
;
if
(
strcmp
(
aTopic
FullscreenTransitionTask
:
:
kPaintedTopic
)
=
=
0
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
(
do_QueryInterface
(
aSubject
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
win
?
nsGlobalWindowInner
:
:
Cast
(
win
)
-
>
GetMainWidget
(
)
:
nullptr
;
if
(
widget
=
=
mTask
-
>
mWidget
)
{
mTask
-
>
mTimer
-
>
Cancel
(
)
;
shouldContinue
=
true
;
PROFILER_ADD_MARKER
(
"
Fullscreen
toggle
end
"
DOM
)
;
}
}
else
{
#
ifdef
DEBUG
MOZ_ASSERT
(
strcmp
(
aTopic
NS_TIMER_CALLBACK_TOPIC
)
=
=
0
"
Should
only
get
fullscreen
-
painted
or
timer
-
callback
"
)
;
nsCOMPtr
<
nsITimer
>
timer
(
do_QueryInterface
(
aSubject
)
)
;
MOZ_ASSERT
(
timer
&
&
timer
=
=
mTask
-
>
mTimer
"
Should
only
trigger
this
with
the
timer
the
task
created
"
)
;
#
endif
shouldContinue
=
true
;
PROFILER_ADD_MARKER
(
"
Fullscreen
toggle
timeout
"
DOM
)
;
}
if
(
shouldContinue
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obs
-
>
RemoveObserver
(
this
kPaintedTopic
)
;
mTask
-
>
mTimer
=
nullptr
;
mTask
-
>
Run
(
)
;
}
return
NS_OK
;
}
static
bool
MakeWidgetFullscreen
(
nsGlobalWindowOuter
*
aWindow
FullscreenReason
aReason
bool
aFullscreen
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
aWindow
-
>
GetMainWidget
(
)
;
if
(
!
widget
)
{
return
false
;
}
FullscreenTransitionDuration
duration
;
bool
performTransition
=
false
;
nsCOMPtr
<
nsISupports
>
transitionData
;
if
(
aReason
=
=
FullscreenReason
:
:
ForFullscreenAPI
)
{
GetFullscreenTransitionDuration
(
aFullscreen
&
duration
)
;
if
(
!
duration
.
IsSuppressed
(
)
)
{
performTransition
=
widget
-
>
PrepareForFullscreenTransition
(
getter_AddRefs
(
transitionData
)
)
;
}
}
if
(
!
performTransition
)
{
return
aWindow
-
>
SetWidgetFullscreen
(
aReason
aFullscreen
widget
nullptr
)
;
}
nsCOMPtr
<
nsIRunnable
>
task
=
new
FullscreenTransitionTask
(
duration
aWindow
aFullscreen
widget
nullptr
transitionData
)
;
task
-
>
Run
(
)
;
return
true
;
}
nsresult
nsGlobalWindowOuter
:
:
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aFullscreen
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Requires
safe
to
run
script
as
it
"
"
may
call
FinishDOMFullscreenChange
"
)
;
NS_ENSURE_TRUE
(
mDocShell
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
aReason
!
=
FullscreenReason
:
:
ForForceExitFullscreen
|
|
!
aFullscreen
"
FullscreenReason
:
:
ForForceExitFullscreen
can
"
"
only
be
used
with
exiting
fullscreen
"
)
;
if
(
aReason
=
=
FullscreenReason
:
:
ForFullscreenMode
&
&
!
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
if
(
!
window
)
return
NS_ERROR_FAILURE
;
if
(
rootItem
!
=
mDocShell
)
return
window
-
>
SetFullscreenInternal
(
aReason
aFullscreen
)
;
if
(
mDocShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
return
NS_ERROR_FAILURE
;
if
(
mFullscreen
=
=
aFullscreen
)
{
return
NS_OK
;
}
if
(
aReason
=
=
FullscreenReason
:
:
ForFullscreenMode
)
{
if
(
!
aFullscreen
&
&
!
mFullscreenMode
)
{
aReason
=
FullscreenReason
:
:
ForFullscreenAPI
;
}
else
{
mFullscreenMode
=
aFullscreen
;
}
}
else
{
if
(
!
aFullscreen
&
&
mFullscreenMode
)
{
FinishDOMFullscreenChange
(
mDoc
false
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
nsCOMPtr
<
nsIXULWindow
>
xulWin
(
do_GetInterface
(
treeOwnerAsWin
)
)
;
if
(
aFullscreen
&
&
xulWin
)
{
xulWin
-
>
SetIntrinsicallySized
(
false
)
;
}
mFullscreen
=
aFullscreen
;
if
(
!
Preferences
:
:
GetBool
(
"
full
-
screen
-
api
.
ignore
-
widgets
"
false
)
)
{
if
(
MakeWidgetFullscreen
(
this
aReason
aFullscreen
)
)
{
return
NS_OK
;
}
}
FinishFullscreenChange
(
aFullscreen
)
;
return
NS_OK
;
}
bool
nsGlobalWindowOuter
:
:
SetWidgetFullscreen
(
FullscreenReason
aReason
bool
aIsFullscreen
nsIWidget
*
aWidget
nsIScreen
*
aScreen
)
{
MOZ_ASSERT
(
this
=
=
GetTopInternal
(
)
"
Only
topmost
window
should
call
this
"
)
;
MOZ_ASSERT
(
!
GetFrameElementInternal
(
)
"
Content
window
should
not
call
this
"
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
if
(
!
NS_WARN_IF
(
!
IsChromeWindow
(
)
)
)
{
if
(
!
NS_WARN_IF
(
mChromeFields
.
mFullscreenPresShell
)
)
{
if
(
nsIPresShell
*
shell
=
mDocShell
-
>
GetPresShell
(
)
)
{
if
(
nsRefreshDriver
*
rd
=
shell
-
>
GetRefreshDriver
(
)
)
{
mChromeFields
.
mFullscreenPresShell
=
do_GetWeakReference
(
shell
)
;
MOZ_ASSERT
(
mChromeFields
.
mFullscreenPresShell
)
;
rd
-
>
SetIsResizeSuppressed
(
)
;
rd
-
>
Freeze
(
)
;
}
}
}
}
nsresult
rv
=
aReason
=
=
FullscreenReason
:
:
ForFullscreenMode
?
aWidget
-
>
MakeFullScreenWithNativeTransition
(
aIsFullscreen
aScreen
)
:
aWidget
-
>
MakeFullScreen
(
aIsFullscreen
aScreen
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
void
nsGlobalWindowOuter
:
:
FullscreenWillChange
(
bool
aIsFullscreen
)
{
if
(
aIsFullscreen
)
{
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
willenterfullscreen
"
)
)
;
}
else
{
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
willexitfullscreen
"
)
)
;
}
}
void
nsGlobalWindowOuter
:
:
FinishFullscreenChange
(
bool
aIsFullscreen
)
{
if
(
aIsFullscreen
!
=
mFullscreen
)
{
NS_WARNING
(
"
Failed
to
toggle
fullscreen
state
of
the
widget
"
)
;
if
(
!
aIsFullscreen
)
{
mFullscreen
=
false
;
mFullscreenMode
=
false
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
to
exit
fullscreen
?
"
)
;
mFullscreen
=
true
;
mFullscreenMode
=
false
;
}
return
;
}
FinishDOMFullscreenChange
(
mDoc
mFullscreen
)
;
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
fullscreen
"
)
)
;
if
(
!
NS_WARN_IF
(
!
IsChromeWindow
(
)
)
)
{
if
(
nsCOMPtr
<
nsIPresShell
>
shell
=
do_QueryReferent
(
mChromeFields
.
mFullscreenPresShell
)
)
{
if
(
nsRefreshDriver
*
rd
=
shell
-
>
GetRefreshDriver
(
)
)
{
rd
-
>
Thaw
(
)
;
}
mChromeFields
.
mFullscreenPresShell
=
nullptr
;
}
}
if
(
!
mWakeLock
&
&
mFullscreen
)
{
RefPtr
<
power
:
:
PowerManagerService
>
pmService
=
power
:
:
PowerManagerService
:
:
GetInstance
(
)
;
if
(
!
pmService
)
{
return
;
}
ErrorResult
rv
;
mWakeLock
=
pmService
-
>
NewWakeLock
(
NS_LITERAL_STRING
(
"
DOM_Fullscreen
"
)
GetCurrentInnerWindow
(
)
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
lock
the
wakelock
"
)
;
rv
.
SuppressException
(
)
;
}
else
if
(
mWakeLock
&
&
!
mFullscreen
)
{
ErrorResult
rv
;
mWakeLock
-
>
Unlock
(
rv
)
;
mWakeLock
=
nullptr
;
rv
.
SuppressException
(
)
;
}
}
bool
nsGlobalWindowOuter
:
:
Fullscreen
(
)
const
{
NS_ENSURE_TRUE
(
mDocShell
mFullscreen
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
rootItem
=
=
mDocShell
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
return
mFullscreen
;
}
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
GetNearestWidget
(
)
)
{
return
widget
-
>
SizeMode
(
)
=
=
nsSizeMode_Fullscreen
;
}
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
rootItem
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
mFullscreen
)
;
return
nsGlobalWindowOuter
:
:
Cast
(
window
)
-
>
Fullscreen
(
)
;
}
bool
nsGlobalWindowOuter
:
:
GetFullscreenOuter
(
)
{
return
Fullscreen
(
)
;
}
bool
nsGlobalWindowOuter
:
:
GetFullScreen
(
)
{
FORWARD_TO_INNER
(
GetFullScreen
(
)
false
)
;
}
void
nsGlobalWindowOuter
:
:
EnsureReflowFlushAndPaint
(
)
{
NS_ASSERTION
(
mDocShell
"
EnsureReflowFlushAndPaint
(
)
called
with
no
"
"
docshell
!
"
)
;
if
(
!
mDocShell
)
return
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
return
;
if
(
mDoc
)
{
mDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
presShell
-
>
UnsuppressPainting
(
)
;
}
void
nsGlobalWindowOuter
:
:
MakeScriptDialogTitle
(
nsAString
&
aOutTitle
nsIPrincipal
*
aSubjectPrincipal
)
{
MOZ_ASSERT
(
aSubjectPrincipal
)
;
aOutTitle
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aSubjectPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
uri
)
{
nsCOMPtr
<
nsIURIFixup
>
fixup
(
do_GetService
(
NS_URIFIXUP_CONTRACTID
)
)
;
if
(
fixup
)
{
nsCOMPtr
<
nsIURI
>
fixedURI
;
rv
=
fixup
-
>
CreateExposableURI
(
uri
getter_AddRefs
(
fixedURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
fixedURI
)
{
nsAutoCString
host
;
fixedURI
-
>
GetHost
(
host
)
;
if
(
!
host
.
IsEmpty
(
)
)
{
nsAutoCString
prepath
;
fixedURI
-
>
GetDisplayPrePath
(
prepath
)
;
NS_ConvertUTF8toUTF16
ucsPrePath
(
prepath
)
;
const
char16_t
*
formatStrings
[
]
=
{
ucsPrePath
.
get
(
)
}
;
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDlgHeading
"
formatStrings
aOutTitle
)
;
}
}
}
}
if
(
aOutTitle
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDlgGenericHeading
"
aOutTitle
)
;
}
if
(
aOutTitle
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
could
not
get
ScriptDlgGenericHeading
string
from
string
bundle
"
)
;
aOutTitle
.
AssignLiteral
(
"
[
Script
]
"
)
;
}
}
bool
nsGlobalWindowOuter
:
:
CanMoveResizeWindows
(
CallerType
aCallerType
)
{
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
!
mHadOriginalOpener
)
{
return
false
;
}
if
(
!
CanSetProperty
(
"
dom
.
disable_window_move_resize
"
)
)
{
return
false
;
}
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsITabChild
>
child
=
docShell
-
>
GetTabChild
(
)
;
bool
hasSiblings
=
true
;
if
(
child
&
&
NS_SUCCEEDED
(
child
-
>
GetHasSiblings
(
&
hasSiblings
)
)
&
&
hasSiblings
)
{
return
false
;
}
}
}
else
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
uint32_t
itemCount
=
0
;
if
(
treeOwner
&
&
NS_SUCCEEDED
(
treeOwner
-
>
GetTabCount
(
&
itemCount
)
)
&
&
itemCount
>
1
)
{
return
false
;
}
}
}
if
(
mDocShell
)
{
bool
allow
;
nsresult
rv
=
mDocShell
-
>
GetAllowWindowControl
(
&
allow
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
allow
)
return
false
;
}
if
(
nsGlobalWindowInner
:
:
sMouseDown
&
&
!
nsGlobalWindowInner
:
:
sDragServiceDisabled
)
{
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
nsGlobalWindowInner
:
:
sDragServiceDisabled
=
true
;
ds
-
>
Suppress
(
)
;
}
}
return
true
;
}
bool
nsGlobalWindowOuter
:
:
AlertOrConfirm
(
bool
aAlert
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
if
(
!
AreDialogsEnabled
(
)
)
{
return
false
;
}
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
EnsureReflowFlushAndPaint
(
)
;
nsAutoString
title
;
MakeScriptDialogTitle
(
title
&
aSubjectPrincipal
)
;
nsAutoString
final
;
nsContentUtils
:
:
StripNullChars
(
aMessage
final
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
final
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
promptFac
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
false
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
;
aError
=
promptFac
-
>
GetPrompt
(
this
NS_GET_IID
(
nsIPrompt
)
getter_AddRefs
(
prompt
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
promptBag
=
do_QueryInterface
(
prompt
)
)
{
promptBag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
allowTabModal
"
)
true
)
;
}
bool
result
=
false
;
nsAutoSyncOperation
sync
(
mDoc
)
;
if
(
ShouldPromptToBlockDialogs
(
)
)
{
bool
disallowDialog
=
false
;
nsAutoString
label
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogLabel
"
label
)
;
aError
=
aAlert
?
prompt
-
>
AlertCheck
(
title
.
get
(
)
final
.
get
(
)
label
.
get
(
)
&
disallowDialog
)
:
prompt
-
>
ConfirmCheck
(
title
.
get
(
)
final
.
get
(
)
label
.
get
(
)
&
disallowDialog
&
result
)
;
if
(
disallowDialog
)
DisableDialogs
(
)
;
}
else
{
aError
=
aAlert
?
prompt
-
>
Alert
(
title
.
get
(
)
final
.
get
(
)
)
:
prompt
-
>
Confirm
(
title
.
get
(
)
final
.
get
(
)
&
result
)
;
}
return
result
;
}
void
nsGlobalWindowOuter
:
:
AlertOuter
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AlertOrConfirm
(
true
aMessage
aSubjectPrincipal
aError
)
;
}
bool
nsGlobalWindowOuter
:
:
ConfirmOuter
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
return
AlertOrConfirm
(
false
aMessage
aSubjectPrincipal
aError
)
;
}
void
nsGlobalWindowOuter
:
:
PromptOuter
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
SetDOMStringToNull
(
aReturn
)
;
if
(
!
AreDialogsEnabled
(
)
)
{
return
;
}
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
EnsureReflowFlushAndPaint
(
)
;
nsAutoString
title
;
MakeScriptDialogTitle
(
title
&
aSubjectPrincipal
)
;
nsAutoString
fixedMessage
fixedInitial
;
nsContentUtils
:
:
StripNullChars
(
aMessage
fixedMessage
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
fixedMessage
)
;
nsContentUtils
:
:
StripNullChars
(
aInitial
fixedInitial
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
promptFac
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
;
aError
=
promptFac
-
>
GetPrompt
(
this
NS_GET_IID
(
nsIPrompt
)
getter_AddRefs
(
prompt
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
promptBag
=
do_QueryInterface
(
prompt
)
)
{
promptBag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
allowTabModal
"
)
true
)
;
}
char16_t
*
inoutValue
=
ToNewUnicode
(
fixedInitial
)
;
bool
disallowDialog
=
false
;
nsAutoString
label
;
label
.
SetIsVoid
(
true
)
;
if
(
ShouldPromptToBlockDialogs
(
)
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogLabel
"
label
)
;
}
nsAutoSyncOperation
sync
(
mDoc
)
;
bool
ok
;
aError
=
prompt
-
>
Prompt
(
title
.
get
(
)
fixedMessage
.
get
(
)
&
inoutValue
label
.
IsVoid
(
)
?
nullptr
:
label
.
get
(
)
&
disallowDialog
&
ok
)
;
if
(
disallowDialog
)
{
DisableDialogs
(
)
;
}
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsString
outValue
;
outValue
.
Adopt
(
inoutValue
)
;
if
(
ok
&
&
inoutValue
)
{
aReturn
.
Assign
(
outValue
)
;
}
}
void
nsGlobalWindowOuter
:
:
FocusOuter
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseWin
=
do_QueryInterface
(
mDocShell
)
;
bool
isVisible
=
false
;
if
(
baseWin
)
{
baseWin
-
>
GetVisibility
(
&
isVisible
)
;
}
if
(
!
isVisible
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
caller
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
nsPIDOMWindowOuter
*
callerOuter
=
caller
?
caller
-
>
GetOuterWindow
(
)
:
nullptr
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
GetOpener
(
)
;
bool
canFocus
=
CanSetProperty
(
"
dom
.
disable_window_flip
"
)
|
|
(
opener
=
=
callerOuter
&
&
RevisePopupAbuseLevel
(
PopupBlocker
:
:
GetPopupControlState
(
)
)
<
PopupBlocker
:
:
openBlocked
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
activeDOMWindow
;
fm
-
>
GetActiveWindow
(
getter_AddRefs
(
activeDOMWindow
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
auto
*
activeWindow
=
nsPIDOMWindowOuter
:
:
From
(
activeDOMWindow
)
;
bool
isActive
=
(
rootWin
=
=
activeWindow
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
treeOwnerAsWin
&
&
(
canFocus
|
|
isActive
)
)
{
bool
isEnabled
=
true
;
if
(
NS_SUCCEEDED
(
treeOwnerAsWin
-
>
GetEnabled
(
&
isEnabled
)
)
&
&
!
isEnabled
)
{
NS_WARNING
(
"
Should
not
try
to
set
the
focus
on
a
disabled
window
"
)
;
return
;
}
nsCOMPtr
<
nsIEmbeddingSiteWindow
>
embeddingWin
(
do_GetInterface
(
treeOwnerAsWin
)
)
;
if
(
embeddingWin
)
embeddingWin
-
>
SetFocus
(
)
;
}
if
(
!
mDocShell
)
{
return
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
;
bool
lookForPresShell
=
true
;
if
(
mDocShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
&
&
GetPrivateRoot
(
)
=
=
this
&
&
mDoc
)
{
nsIURI
*
ourURI
=
mDoc
-
>
GetDocumentURI
(
)
;
if
(
ourURI
)
{
lookForPresShell
=
!
NS_IsAboutBlank
(
ourURI
)
;
}
}
if
(
lookForPresShell
)
{
presShell
=
mDocShell
-
>
GetEldestPresShell
(
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti
;
mDocShell
-
>
GetParent
(
getter_AddRefs
(
parentDsti
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
parentDsti
?
parentDsti
-
>
GetWindow
(
)
:
nullptr
;
if
(
parent
)
{
nsCOMPtr
<
Document
>
parentdoc
=
parent
-
>
GetDoc
(
)
;
if
(
!
parentdoc
)
{
return
;
}
RefPtr
<
Element
>
frame
=
parentdoc
-
>
FindContentForSubDocument
(
mDoc
)
;
if
(
frame
)
{
uint32_t
flags
=
nsIFocusManager
:
:
FLAG_NOSCROLL
;
if
(
canFocus
)
flags
|
=
nsIFocusManager
:
:
FLAG_RAISE
;
DebugOnly
<
nsresult
>
rv
=
fm
-
>
SetFocus
(
frame
flags
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
SetFocus
only
fails
if
the
first
argument
is
null
"
"
but
we
pass
an
element
"
)
;
}
return
;
}
if
(
canFocus
)
{
DebugOnly
<
nsresult
>
rv
=
fm
-
>
SetActiveWindow
(
this
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
SetActiveWindow
only
fails
if
passed
null
or
a
non
-
toplevel
"
"
window
which
is
not
the
case
here
.
"
)
;
}
}
nsresult
nsGlobalWindowOuter
:
:
Focus
(
)
{
FORWARD_TO_INNER
(
Focus
(
)
NS_ERROR_UNEXPECTED
)
;
}
void
nsGlobalWindowOuter
:
:
BlurOuter
(
)
{
if
(
!
CanSetProperty
(
"
dom
.
disable_window_flip
"
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
nsCOMPtr
<
nsIEmbeddingSiteWindow
>
siteWindow
(
do_GetInterface
(
treeOwner
)
)
;
if
(
siteWindow
)
{
siteWindow
-
>
Blur
(
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
mDoc
)
{
RefPtr
<
Element
>
element
;
fm
-
>
GetFocusedElementForWindow
(
this
false
nullptr
getter_AddRefs
(
element
)
)
;
if
(
element
=
=
mDoc
-
>
GetRootElement
(
)
)
{
fm
-
>
ClearFocus
(
this
)
;
}
}
}
}
void
nsGlobalWindowOuter
:
:
StopOuter
(
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
webNav
)
{
aError
=
webNav
-
>
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
}
}
void
nsGlobalWindowOuter
:
:
PrintOuter
(
ErrorResult
&
aError
)
{
#
ifdef
NS_PRINTING
if
(
!
AreDialogsEnabled
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
if
(
ShouldPromptToBlockDialogs
(
)
&
&
!
ConfirmDialogIfNeeded
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
nsCOMPtr
<
nsIWebBrowserPrint
>
webBrowserPrint
;
if
(
NS_SUCCEEDED
(
GetInterface
(
NS_GET_IID
(
nsIWebBrowserPrint
)
getter_AddRefs
(
webBrowserPrint
)
)
)
)
{
nsAutoSyncOperation
sync
(
GetCurrentInnerWindowInternal
(
)
?
GetCurrentInnerWindowInternal
(
)
-
>
mDoc
.
get
(
)
:
nullptr
)
;
nsCOMPtr
<
nsIPrintSettingsService
>
printSettingsService
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
)
;
nsCOMPtr
<
nsIPrintSettings
>
printSettings
;
if
(
printSettingsService
)
{
bool
printSettingsAreGlobal
=
Preferences
:
:
GetBool
(
"
print
.
use_global_printsettings
"
false
)
;
if
(
printSettingsAreGlobal
)
{
printSettingsService
-
>
GetGlobalPrintSettings
(
getter_AddRefs
(
printSettings
)
)
;
nsAutoString
printerName
;
printSettings
-
>
GetPrinterName
(
printerName
)
;
bool
shouldGetDefaultPrinterName
=
printerName
.
IsEmpty
(
)
;
#
ifdef
MOZ_X11
if
(
!
XRE_IsParentProcess
(
)
)
{
shouldGetDefaultPrinterName
=
false
;
}
#
endif
if
(
shouldGetDefaultPrinterName
)
{
printSettingsService
-
>
GetDefaultPrinterName
(
printerName
)
;
printSettings
-
>
SetPrinterName
(
printerName
)
;
}
printSettingsService
-
>
InitPrintSettingsFromPrinter
(
printerName
printSettings
)
;
printSettingsService
-
>
InitPrintSettingsFromPrefs
(
printSettings
true
nsIPrintSettings
:
:
kInitSaveAll
)
;
}
else
{
printSettingsService
-
>
GetNewPrintSettings
(
getter_AddRefs
(
printSettings
)
)
;
}
EnterModalState
(
)
;
webBrowserPrint
-
>
Print
(
printSettings
nullptr
)
;
LeaveModalState
(
)
;
bool
savePrintSettings
=
Preferences
:
:
GetBool
(
"
print
.
save_print_settings
"
false
)
;
if
(
printSettingsAreGlobal
&
&
savePrintSettings
)
{
printSettingsService
-
>
SavePrintSettingsToPrefs
(
printSettings
true
nsIPrintSettings
:
:
kInitSaveAll
)
;
printSettingsService
-
>
SavePrintSettingsToPrefs
(
printSettings
false
nsIPrintSettings
:
:
kInitSavePrinterName
)
;
}
}
else
{
webBrowserPrint
-
>
GetGlobalPrintSettings
(
getter_AddRefs
(
printSettings
)
)
;
webBrowserPrint
-
>
Print
(
printSettings
nullptr
)
;
}
}
#
endif
}
void
nsGlobalWindowOuter
:
:
MoveToOuter
(
int32_t
aXPos
int32_t
aYPos
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
if
(
screenMgr
)
{
CSSIntSize
size
;
GetInnerSize
(
size
)
;
screenMgr
-
>
ScreenForRect
(
aXPos
aYPos
size
.
width
size
.
height
getter_AddRefs
(
screen
)
)
;
}
if
(
screen
)
{
int32_t
screenLeftDeskPx
screenTopDeskPx
w
h
;
screen
-
>
GetRectDisplayPix
(
&
screenLeftDeskPx
&
screenTopDeskPx
&
w
&
h
)
;
CSSIntPoint
cssPos
(
aXPos
-
screenLeftDeskPx
aYPos
-
screenTopDeskPx
)
;
CheckSecurityLeftAndTop
(
&
cssPos
.
x
&
cssPos
.
y
aCallerType
)
;
double
scale
;
screen
-
>
GetDefaultCSSScaleFactor
(
&
scale
)
;
LayoutDevicePoint
devPos
=
cssPos
*
CSSToLayoutDeviceScale
(
scale
)
;
screen
-
>
GetContentsScaleFactor
(
&
scale
)
;
DesktopPoint
deskPos
=
devPos
/
DesktopToLayoutDeviceScale
(
scale
)
;
aError
=
treeOwnerAsWin
-
>
SetPositionDesktopPix
(
screenLeftDeskPx
+
deskPos
.
x
screenTopDeskPx
+
deskPos
.
y
)
;
}
else
{
CSSIntPoint
cssPos
(
aXPos
aXPos
)
;
CheckSecurityLeftAndTop
(
&
cssPos
.
x
&
cssPos
.
y
aCallerType
)
;
LayoutDevicePoint
devPos
=
cssPos
*
CSSToLayoutDeviceScale
(
1
.
0
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
devPos
.
x
devPos
.
y
)
;
}
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowOuter
:
:
MoveByOuter
(
int32_t
aXDif
int32_t
aYDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
x
y
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsIntSize
cssPos
(
DevToCSSIntPixels
(
nsIntSize
(
x
y
)
)
)
;
cssPos
.
width
+
=
aXDif
;
cssPos
.
height
+
=
aYDif
;
CheckSecurityLeftAndTop
(
&
cssPos
.
width
&
cssPos
.
height
aCallerType
)
;
nsIntSize
newDevPos
(
CSSToDevIntPixels
(
cssPos
)
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
newDevPos
.
width
newDevPos
.
height
)
;
CheckForDPIChange
(
)
;
}
nsresult
nsGlobalWindowOuter
:
:
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
{
ErrorResult
rv
;
MoveByOuter
(
aXDif
aYDif
CallerType
:
:
System
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowOuter
:
:
ResizeToOuter
(
int32_t
aWidth
int32_t
aHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
mDocShell
&
&
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
CSSIntSize
size
(
aWidth
aHeight
)
;
if
(
!
DispatchResizeEvent
(
size
)
)
{
return
;
}
}
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIntSize
cssSize
(
aWidth
aHeight
)
;
CheckSecurityWidthAndHeight
(
&
cssSize
.
width
&
cssSize
.
height
aCallerType
)
;
nsIntSize
devSz
(
CSSToDevIntPixels
(
cssSize
)
)
;
aError
=
treeOwnerAsWin
-
>
SetSize
(
devSz
.
width
devSz
.
height
true
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowOuter
:
:
ResizeByOuter
(
int32_t
aWidthDif
int32_t
aHeightDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
mDocShell
&
&
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
CSSIntSize
size
;
if
(
NS_FAILED
(
GetInnerSize
(
size
)
)
)
{
return
;
}
size
.
width
+
=
aWidthDif
;
size
.
height
+
=
aHeightDif
;
if
(
!
DispatchResizeEvent
(
size
)
)
{
return
;
}
}
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
width
height
;
aError
=
treeOwnerAsWin
-
>
GetSize
(
&
width
&
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsIntSize
cssSize
(
DevToCSSIntPixels
(
nsIntSize
(
width
height
)
)
)
;
cssSize
.
width
+
=
aWidthDif
;
cssSize
.
height
+
=
aHeightDif
;
CheckSecurityWidthAndHeight
(
&
cssSize
.
width
&
cssSize
.
height
aCallerType
)
;
nsIntSize
newDevSize
(
CSSToDevIntPixels
(
cssSize
)
)
;
aError
=
treeOwnerAsWin
-
>
SetSize
(
newDevSize
.
width
newDevSize
.
height
true
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowOuter
:
:
SizeToContentOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
if
(
!
mDocShell
)
{
return
;
}
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
!
cv
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
width
height
;
aError
=
cv
-
>
GetContentSize
(
&
width
&
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
if
(
!
treeOwner
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIntSize
cssSize
(
DevToCSSIntPixels
(
nsIntSize
(
width
height
)
)
)
;
CheckSecurityWidthAndHeight
(
&
cssSize
.
width
&
cssSize
.
height
aCallerType
)
;
nsIntSize
newDevSize
(
CSSToDevIntPixels
(
cssSize
)
)
;
aError
=
treeOwner
-
>
SizeShellTo
(
mDocShell
newDevSize
.
width
newDevSize
.
height
)
;
}
already_AddRefed
<
nsPIWindowRoot
>
nsGlobalWindowOuter
:
:
GetTopWindowRoot
(
)
{
nsPIDOMWindowOuter
*
piWin
=
GetPrivateRoot
(
)
;
if
(
!
piWin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIWindowRoot
>
window
=
do_QueryInterface
(
piWin
-
>
GetChromeEventHandler
(
)
)
;
return
window
.
forget
(
)
;
}
void
nsGlobalWindowOuter
:
:
FirePopupBlockedEvent
(
Document
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
{
MOZ_ASSERT
(
aDoc
)
;
PopupBlockedEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
init
.
mRequestingWindow
=
GetCurrentInnerWindowInternal
(
)
;
init
.
mPopupWindowURI
=
aPopupURI
;
init
.
mPopupWindowName
=
aPopupWindowName
;
init
.
mPopupWindowFeatures
=
aPopupWindowFeatures
;
RefPtr
<
PopupBlockedEvent
>
event
=
PopupBlockedEvent
:
:
Constructor
(
aDoc
NS_LITERAL_STRING
(
"
DOMPopupBlocked
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
aDoc
-
>
DispatchEvent
(
*
event
)
;
}
void
nsGlobalWindowOuter
:
:
NotifyContentBlockingEvent
(
unsigned
aEvent
nsIChannel
*
aChannel
bool
aBlocked
nsIURI
*
aURIHint
)
{
MOZ_ASSERT
(
aURIHint
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
nsCOMPtr
<
Document
>
doc
=
docShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE_VOID
(
doc
)
;
nsCOMPtr
<
nsIURI
>
uri
(
aURIHint
)
;
nsCOMPtr
<
nsIChannel
>
channel
(
aChannel
)
;
static
bool
prefInitialized
=
false
;
if
(
!
prefInitialized
)
{
Preferences
:
:
AddBoolVarCache
(
&
gSyncContentBlockingNotifications
"
dom
.
testing
.
sync
-
content
-
blocking
-
notifications
"
false
)
;
prefInitialized
=
true
;
}
nsCOMPtr
<
nsIRunnable
>
func
=
NS_NewRunnableFunction
(
"
NotifyContentBlockingEventDelayed
"
[
doc
docShell
uri
channel
aEvent
aBlocked
]
(
)
{
if
(
!
SameLoadingURI
(
doc
channel
)
&
&
aEvent
=
=
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
)
{
return
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsISecurityEventSink
>
eventSink
=
do_QueryInterface
(
docShell
&
rv
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
uint32_t
event
=
0
;
nsCOMPtr
<
nsISecureBrowserUI
>
securityUI
;
docShell
-
>
GetSecurityUI
(
getter_AddRefs
(
securityUI
)
)
;
if
(
!
securityUI
)
{
return
;
}
securityUI
-
>
GetContentBlockingEvent
(
&
event
)
;
nsAutoCString
origin
;
nsContentUtils
:
:
GetASCIIOrigin
(
uri
origin
)
;
bool
blockedValue
=
aBlocked
;
bool
unblocked
=
false
;
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
)
{
doc
-
>
SetHasTrackingContentBlocked
(
aBlocked
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasTrackingContentBlocked
(
)
;
}
}
else
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_LOADED_TRACKING_CONTENT
)
{
doc
-
>
SetHasTrackingContentLoaded
(
aBlocked
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasTrackingContentLoaded
(
)
;
}
}
else
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
)
{
doc
-
>
SetHasCookiesBlockedByPermission
(
aBlocked
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasCookiesBlockedByPermission
(
)
;
}
}
else
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
)
{
doc
-
>
SetHasTrackingCookiesBlocked
(
aBlocked
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasTrackingCookiesBlocked
(
)
;
}
}
else
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
)
{
doc
-
>
SetHasAllCookiesBlocked
(
aBlocked
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasAllCookiesBlocked
(
)
;
}
}
else
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
)
{
doc
-
>
SetHasForeignCookiesBlocked
(
aBlocked
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasForeignCookiesBlocked
(
)
;
}
}
else
if
(
aEvent
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_LOADED
)
{
MOZ_ASSERT
(
!
aBlocked
"
We
don
'
t
expected
to
see
blocked
STATE_COOKIES_LOADED
"
)
;
blockedValue
=
!
aBlocked
;
doc
-
>
SetHasCookiesLoaded
(
blockedValue
origin
)
;
if
(
!
aBlocked
)
{
unblocked
=
!
doc
-
>
GetHasCookiesLoaded
(
)
;
}
}
else
{
}
const
uint32_t
oldEvent
=
event
;
if
(
blockedValue
)
{
event
|
=
aEvent
;
}
else
if
(
unblocked
)
{
event
&
=
~
aEvent
;
}
if
(
event
=
=
oldEvent
#
ifdef
ANDROID
&
&
aEvent
!
=
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
#
endif
)
{
return
;
}
eventSink
-
>
OnContentBlockingEvent
(
channel
event
)
;
}
)
;
nsresult
rv
;
if
(
gSyncContentBlockingNotifications
)
{
rv
=
func
-
>
Run
(
)
;
}
else
{
rv
=
NS_DispatchToCurrentThreadQueue
(
func
.
forget
(
)
100
EventQueuePriority
:
:
Idle
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
bool
nsGlobalWindowOuter
:
:
SameLoadingURI
(
Document
*
aDoc
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIURI
>
docURI
=
aDoc
-
>
GetDocumentURI
(
)
;
nsCOMPtr
<
nsILoadInfo
>
channelLoadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
!
channelLoadInfo
|
|
!
docURI
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
channelLoadingPrincipal
=
channelLoadInfo
-
>
LoadingPrincipal
(
)
;
if
(
!
channelLoadingPrincipal
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
channelLoadingURI
;
channelLoadingPrincipal
-
>
GetURI
(
getter_AddRefs
(
channelLoadingURI
)
)
;
if
(
!
channelLoadingURI
)
{
return
false
;
}
bool
equals
=
false
;
nsresult
rv
=
docURI
-
>
EqualsExceptRef
(
channelLoadingURI
&
equals
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
equals
;
}
bool
nsGlobalWindowOuter
:
:
CanSetProperty
(
const
char
*
aPrefName
)
{
if
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
return
true
;
}
return
!
Preferences
:
:
GetBool
(
aPrefName
true
)
;
}
bool
nsGlobalWindowOuter
:
:
PopupWhitelisted
(
)
{
if
(
mDoc
&
&
PopupBlocker
:
:
CanShowPopupByPermission
(
mDoc
-
>
NodePrincipal
(
)
)
)
{
return
true
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParent
(
)
;
if
(
parent
=
=
this
)
{
return
false
;
}
return
nsGlobalWindowOuter
:
:
Cast
(
parent
)
-
>
PopupWhitelisted
(
)
;
}
PopupBlocker
:
:
PopupControlState
nsGlobalWindowOuter
:
:
RevisePopupAbuseLevel
(
PopupBlocker
:
:
PopupControlState
aControl
)
{
NS_ASSERTION
(
mDocShell
"
Must
have
docshell
"
)
;
if
(
mDocShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeContent
)
{
return
PopupBlocker
:
:
openAllowed
;
}
PopupBlocker
:
:
PopupControlState
abuse
=
aControl
;
switch
(
abuse
)
{
case
PopupBlocker
:
:
openControlled
:
case
PopupBlocker
:
:
openBlocked
:
case
PopupBlocker
:
:
openOverridden
:
if
(
PopupWhitelisted
(
)
)
abuse
=
PopupBlocker
:
:
PopupControlState
(
abuse
-
1
)
;
break
;
case
PopupBlocker
:
:
openAbused
:
if
(
PopupWhitelisted
(
)
)
abuse
=
PopupBlocker
:
:
openControlled
;
break
;
case
PopupBlocker
:
:
openAllowed
:
break
;
default
:
NS_WARNING
(
"
Strange
PopupControlState
!
"
)
;
}
if
(
abuse
=
=
PopupBlocker
:
:
openAbused
|
|
abuse
=
=
PopupBlocker
:
:
openBlocked
|
|
abuse
=
=
PopupBlocker
:
:
openControlled
)
{
int32_t
popupMax
=
Preferences
:
:
GetInt
(
"
dom
.
popup_maximum
"
-
1
)
;
if
(
popupMax
>
=
0
&
&
gOpenPopupSpamCount
>
=
popupMax
)
abuse
=
PopupBlocker
:
:
openOverridden
;
}
if
(
(
abuse
=
=
PopupBlocker
:
:
openAllowed
|
|
abuse
=
=
PopupBlocker
:
:
openControlled
)
&
&
StaticPrefs
:
:
dom_block_multiple_popups
(
)
&
&
!
PopupWhitelisted
(
)
&
&
!
PopupBlocker
:
:
TryUsePopupOpeningToken
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
}
return
abuse
;
}
void
nsGlobalWindowOuter
:
:
FireAbuseEvents
(
const
nsAString
&
aPopupURL
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetTop
(
)
;
if
(
!
window
)
{
return
;
}
nsCOMPtr
<
Document
>
topDoc
=
window
-
>
GetDoc
(
)
;
nsCOMPtr
<
nsIURI
>
popupURI
;
nsIURI
*
baseURL
=
nullptr
;
nsCOMPtr
<
Document
>
doc
=
GetEntryDocument
(
)
;
if
(
doc
)
baseURL
=
doc
-
>
GetDocBaseURI
(
)
;
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
)
;
if
(
ios
)
ios
-
>
NewURI
(
NS_ConvertUTF16toUTF8
(
aPopupURL
)
nullptr
baseURL
getter_AddRefs
(
popupURI
)
)
;
FirePopupBlockedEvent
(
topDoc
popupURI
aPopupWindowName
aPopupWindowFeatures
)
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowOuter
:
:
OpenOuter
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
aError
=
OpenJS
(
aUrl
aName
aOptions
getter_AddRefs
(
window
)
)
;
RefPtr
<
BrowsingContext
>
bc
;
if
(
!
window
|
|
!
(
bc
=
window
-
>
GetBrowsingContext
(
)
)
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
bc
.
forget
(
)
)
;
}
nsresult
nsGlobalWindowOuter
:
:
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsDocShellLoadState
*
aLoadState
bool
aForceNoOpener
nsPIDOMWindowOuter
*
*
_retval
)
{
return
OpenInternal
(
aUrl
aName
aOptions
false
false
true
false
true
nullptr
nullptr
aLoadState
aForceNoOpener
_retval
)
;
}
nsresult
nsGlobalWindowOuter
:
:
OpenJS
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
{
return
OpenInternal
(
aUrl
aName
aOptions
false
false
false
true
true
nullptr
nullptr
nullptr
false
_retval
)
;
}
nsresult
nsGlobalWindowOuter
:
:
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
nsPIDOMWindowOuter
*
*
_retval
)
{
return
OpenInternal
(
aUrl
aName
aOptions
true
false
true
false
true
nullptr
aExtraArgument
nullptr
false
_retval
)
;
}
nsresult
nsGlobalWindowOuter
:
:
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
{
return
OpenInternal
(
aUrl
aName
aOptions
false
false
true
false
false
nullptr
nullptr
nullptr
false
_retval
)
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowOuter
:
:
OpenDialogOuter
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIJSArgArray
>
argvArray
;
aError
=
NS_CreateJSArgv
(
aCx
aExtraArgument
.
Length
(
)
aExtraArgument
.
Elements
(
)
getter_AddRefs
(
argvArray
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
dialog
;
aError
=
OpenInternal
(
aUrl
aName
aOptions
true
false
false
false
true
argvArray
nullptr
nullptr
false
getter_AddRefs
(
dialog
)
)
;
RefPtr
<
BrowsingContext
>
bc
;
if
(
!
dialog
|
|
!
(
bc
=
dialog
-
>
GetBrowsingContext
(
)
)
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
bc
.
forget
(
)
)
;
}
BrowsingContext
*
nsGlobalWindowOuter
:
:
GetFramesOuter
(
)
{
RefPtr
<
nsPIDOMWindowOuter
>
frames
(
this
)
;
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
return
mBrowsingContext
;
}
nsGlobalWindowInner
*
nsGlobalWindowOuter
:
:
CallerInnerWindow
(
JSContext
*
aCx
)
{
nsIGlobalObject
*
global
=
GetIncumbentGlobal
(
)
;
NS_ENSURE_TRUE
(
global
nullptr
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
aCx
global
-
>
GetGlobalJSObject
(
)
)
;
NS_ENSURE_TRUE
(
scope
nullptr
)
;
if
(
xpc
:
:
IsSandbox
(
scope
)
)
{
JSAutoRealm
ar
(
aCx
scope
)
;
JS
:
:
Rooted
<
JSObject
*
>
scopeProto
(
aCx
)
;
bool
ok
=
JS_GetPrototype
(
aCx
scope
&
scopeProto
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
if
(
scopeProto
&
&
xpc
:
:
IsSandboxPrototypeProxy
(
scopeProto
)
&
&
(
scopeProto
=
js
:
:
CheckedUnwrap
(
scopeProto
false
)
)
)
{
global
=
xpc
:
:
NativeGlobal
(
scopeProto
)
;
NS_ENSURE_TRUE
(
global
nullptr
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
global
)
;
return
nsGlobalWindowInner
:
:
Cast
(
win
)
;
}
bool
nsGlobalWindowOuter
:
:
GatherPostMessageData
(
JSContext
*
aCx
const
nsAString
&
aTargetOrigin
BrowsingContext
*
*
aSource
nsAString
&
aOrigin
nsIURI
*
*
aTargetOriginURI
nsIPrincipal
*
*
aCallerPrincipal
nsGlobalWindowInner
*
*
aCallerInnerWindow
nsIURI
*
*
aCallerDocumentURI
ErrorResult
&
aError
)
{
RefPtr
<
nsGlobalWindowInner
>
callerInnerWin
=
CallerInnerWindow
(
aCx
)
;
nsIPrincipal
*
callerPrin
;
if
(
callerInnerWin
)
{
RefPtr
<
Document
>
doc
=
callerInnerWin
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
NS_IF_ADDREF
(
*
aCallerDocumentURI
=
doc
-
>
GetDocumentURI
(
)
)
;
callerPrin
=
callerInnerWin
-
>
GetPrincipal
(
)
;
}
else
{
nsIGlobalObject
*
global
=
GetIncumbentGlobal
(
)
;
NS_ASSERTION
(
global
"
Why
is
there
no
global
object
?
"
)
;
callerPrin
=
global
-
>
PrincipalOrNull
(
)
;
}
if
(
!
callerPrin
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
callerOuterURI
;
if
(
NS_FAILED
(
callerPrin
-
>
GetURI
(
getter_AddRefs
(
callerOuterURI
)
)
)
)
{
return
false
;
}
if
(
callerOuterURI
)
{
nsContentUtils
:
:
GetUTFOrigin
(
callerPrin
aOrigin
)
;
}
else
if
(
callerInnerWin
)
{
if
(
!
*
aCallerDocumentURI
)
{
return
false
;
}
nsContentUtils
:
:
GetUTFOrigin
(
*
aCallerDocumentURI
aOrigin
)
;
}
else
{
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
callerPrin
)
)
{
return
false
;
}
}
NS_IF_ADDREF
(
*
aCallerPrincipal
=
callerPrin
)
;
if
(
!
aTargetOrigin
.
EqualsASCII
(
"
/
"
)
&
&
!
aTargetOrigin
.
EqualsASCII
(
"
*
"
)
)
{
nsCOMPtr
<
nsIURI
>
targetOriginURI
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
targetOriginURI
)
aTargetOrigin
)
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
nsresult
rv
=
NS_MutateURI
(
targetOriginURI
)
.
SetUserPass
(
EmptyCString
(
)
)
.
SetPathQueryRef
(
EmptyCString
(
)
)
.
Finalize
(
aTargetOriginURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
}
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
&
&
callerInnerWin
&
&
callerInnerWin
-
>
GetOuterWindowInternal
(
)
)
{
NS_ADDREF
(
*
aSource
=
callerInnerWin
-
>
GetOuterWindowInternal
(
)
-
>
GetBrowsingContext
(
)
)
;
}
else
{
*
aSource
=
nullptr
;
}
callerInnerWin
.
forget
(
aCallerInnerWindow
)
;
return
true
;
}
bool
nsGlobalWindowOuter
:
:
GetPrincipalForPostMessage
(
const
nsAString
&
aTargetOrigin
nsIURI
*
aTargetOriginURI
nsIPrincipal
*
aCallerPrincipal
nsIPrincipal
&
aSubjectPrincipal
nsIPrincipal
*
*
aProvidedPrincipal
)
{
nsCOMPtr
<
nsIPrincipal
>
providedPrincipal
;
if
(
aTargetOrigin
.
EqualsASCII
(
"
/
"
)
)
{
providedPrincipal
=
aCallerPrincipal
;
}
else
if
(
!
aTargetOrigin
.
EqualsASCII
(
"
*
"
)
)
{
OriginAttributes
attrs
=
aSubjectPrincipal
.
OriginAttributesRef
(
)
;
if
(
aSubjectPrincipal
.
IsSystemPrincipal
(
)
)
{
auto
principal
=
BasePrincipal
:
:
Cast
(
GetPrincipal
(
)
)
;
if
(
attrs
!
=
principal
-
>
OriginAttributesRef
(
)
)
{
nsCOMPtr
<
nsIURI
>
targetURI
;
nsAutoCString
targetURL
;
nsAutoCString
sourceOrigin
;
nsAutoCString
targetOrigin
;
if
(
NS_FAILED
(
principal
-
>
GetURI
(
getter_AddRefs
(
targetURI
)
)
)
|
|
NS_FAILED
(
targetURI
-
>
GetAsciiSpec
(
targetURL
)
)
|
|
NS_FAILED
(
principal
-
>
GetOrigin
(
targetOrigin
)
)
|
|
NS_FAILED
(
aSubjectPrincipal
.
GetOrigin
(
sourceOrigin
)
)
)
{
NS_WARNING
(
"
Failed
to
get
source
and
target
origins
"
)
;
return
false
;
}
nsContentUtils
:
:
LogSimpleConsoleError
(
NS_ConvertUTF8toUTF16
(
nsPrintfCString
(
R
"
(
Attempting
to
post
a
message
to
window
with
url
"
%
s
"
and
)
"
R
"
(
origin
"
%
s
"
from
a
system
principal
scope
with
mismatched
)
"
R
"
(
origin
"
%
s
"
.
)
"
targetURL
.
get
(
)
targetOrigin
.
get
(
)
sourceOrigin
.
get
(
)
)
)
"
DOM
"
!
!
principal
-
>
PrivateBrowsingId
(
)
)
;
attrs
=
principal
-
>
OriginAttributesRef
(
)
;
}
}
providedPrincipal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
aTargetOriginURI
attrs
)
;
if
(
NS_WARN_IF
(
!
providedPrincipal
)
)
{
return
false
;
}
}
else
{
auto
principal
=
BasePrincipal
:
:
Cast
(
GetPrincipal
(
)
)
;
NS_ENSURE_TRUE
(
principal
false
)
;
OriginAttributes
targetAttrs
=
principal
-
>
OriginAttributesRef
(
)
;
OriginAttributes
sourceAttrs
=
aSubjectPrincipal
.
OriginAttributesRef
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aSubjectPrincipal
.
IsSystemPrincipal
(
)
|
|
sourceAttrs
.
EqualsIgnoringFPD
(
targetAttrs
)
)
;
if
(
OriginAttributes
:
:
IsBlockPostMessageForFPI
(
)
&
&
!
aSubjectPrincipal
.
IsSystemPrincipal
(
)
&
&
sourceAttrs
.
mFirstPartyDomain
!
=
targetAttrs
.
mFirstPartyDomain
)
{
return
false
;
}
}
providedPrincipal
.
forget
(
aProvidedPrincipal
)
;
return
true
;
}
void
nsGlobalWindowOuter
:
:
PostMessageMozOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
RefPtr
<
BrowsingContext
>
sourceBc
;
nsAutoString
origin
;
nsCOMPtr
<
nsIURI
>
targetOriginURI
;
nsCOMPtr
<
nsIPrincipal
>
callerPrincipal
;
RefPtr
<
nsGlobalWindowInner
>
callerInnerWindow
;
nsCOMPtr
<
nsIURI
>
callerDocumentURI
;
if
(
!
GatherPostMessageData
(
aCx
aTargetOrigin
getter_AddRefs
(
sourceBc
)
origin
getter_AddRefs
(
targetOriginURI
)
getter_AddRefs
(
callerPrincipal
)
getter_AddRefs
(
callerInnerWindow
)
getter_AddRefs
(
callerDocumentURI
)
aError
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
providedPrincipal
;
if
(
!
GetPrincipalForPostMessage
(
aTargetOrigin
targetOriginURI
callerPrincipal
aSubjectPrincipal
getter_AddRefs
(
providedPrincipal
)
)
)
{
return
;
}
RefPtr
<
PostMessageEvent
>
event
=
new
PostMessageEvent
(
sourceBc
origin
this
providedPrincipal
callerInnerWindow
?
callerInnerWindow
-
>
WindowID
(
)
:
0
callerDocumentURI
)
;
event
-
>
Write
(
aCx
aMessage
aTransfer
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
aError
=
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
class
nsCloseEvent
:
public
Runnable
{
RefPtr
<
nsGlobalWindowOuter
>
mWindow
;
bool
mIndirect
;
nsCloseEvent
(
nsGlobalWindowOuter
*
aWindow
bool
aIndirect
)
:
mozilla
:
:
Runnable
(
"
nsCloseEvent
"
)
mWindow
(
aWindow
)
mIndirect
(
aIndirect
)
{
}
public
:
static
nsresult
PostCloseEvent
(
nsGlobalWindowOuter
*
aWindow
bool
aIndirect
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsCloseEvent
(
aWindow
aIndirect
)
;
nsresult
rv
=
aWindow
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
aWindow
-
>
MaybeForgiveSpamCount
(
)
;
return
rv
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mWindow
)
{
if
(
mIndirect
)
{
return
PostCloseEvent
(
mWindow
false
)
;
}
mWindow
-
>
ReallyCloseWindow
(
)
;
}
return
NS_OK
;
}
}
;
bool
nsGlobalWindowOuter
:
:
CanClose
(
)
{
if
(
mIsChrome
)
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
bwin
;
GetBrowserDOMWindow
(
getter_AddRefs
(
bwin
)
)
;
bool
canClose
=
true
;
if
(
bwin
&
&
NS_SUCCEEDED
(
bwin
-
>
CanClose
(
&
canClose
)
)
)
{
return
canClose
;
}
}
if
(
!
mDocShell
)
{
return
true
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
bool
canClose
;
nsresult
rv
=
cv
-
>
PermitUnload
(
&
canClose
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
canClose
)
return
false
;
rv
=
cv
-
>
RequestWindowClose
(
&
canClose
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
canClose
)
return
false
;
}
return
true
;
}
void
nsGlobalWindowOuter
:
:
CloseOuter
(
bool
aTrustedCaller
)
{
if
(
!
mDocShell
|
|
IsInModalState
(
)
|
|
(
IsFrame
(
)
&
&
!
mDocShell
-
>
GetIsMozBrowser
(
)
)
)
{
return
;
}
if
(
mHavePendingClose
)
{
return
;
}
if
(
mBlockScriptedClosingFlag
)
{
return
;
}
if
(
mDoc
)
{
nsAutoString
url
;
nsresult
rv
=
mDoc
-
>
GetURL
(
url
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
!
StringBeginsWith
(
url
NS_LITERAL_STRING
(
"
about
:
neterror
"
)
)
&
&
!
mHadOriginalOpener
&
&
!
aTrustedCaller
)
{
bool
allowClose
=
mAllowScriptsToClose
|
|
Preferences
:
:
GetBool
(
"
dom
.
allow_scripts_to_close_windows
"
true
)
;
if
(
!
allowClose
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
Window
"
)
mDoc
nsContentUtils
:
:
eDOM_PROPERTIES
"
WindowCloseBlockedWarning
"
)
;
return
;
}
}
}
if
(
!
mInClose
&
&
!
mIsClosed
&
&
!
CanClose
(
)
)
{
return
;
}
bool
wasInClose
=
mInClose
;
mInClose
=
true
;
if
(
!
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
DOMWindowClose
"
)
)
)
{
mInClose
=
wasInClose
;
return
;
}
FinalClose
(
)
;
}
nsresult
nsGlobalWindowOuter
:
:
Close
(
)
{
CloseOuter
(
true
)
;
return
NS_OK
;
}
void
nsGlobalWindowOuter
:
:
ForceClose
(
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
if
(
IsFrame
(
)
|
|
!
mDocShell
)
{
return
;
}
if
(
mHavePendingClose
)
{
return
;
}
mInClose
=
true
;
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
DOMWindowClose
"
)
)
;
FinalClose
(
)
;
}
void
nsGlobalWindowOuter
:
:
FinalClose
(
)
{
mIsClosed
=
true
;
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
entryWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
bool
indirect
=
entryWindow
&
&
entryWindow
-
>
GetOuterWindow
(
)
=
=
this
;
if
(
NS_FAILED
(
nsCloseEvent
:
:
PostCloseEvent
(
this
indirect
)
)
)
{
ReallyCloseWindow
(
)
;
}
else
{
mHavePendingClose
=
true
;
}
}
void
nsGlobalWindowOuter
:
:
ReallyCloseWindow
(
)
{
mHavePendingClose
=
true
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
treeOwnerAsWin
)
{
if
(
mDocShell
)
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
bwin
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
(
do_QueryInterface
(
rootWin
)
)
;
if
(
chromeWin
)
chromeWin
-
>
GetBrowserDOMWindow
(
getter_AddRefs
(
bwin
)
)
;
if
(
rootWin
)
{
bool
isTab
;
if
(
rootWin
=
=
this
|
|
!
bwin
|
|
(
NS_SUCCEEDED
(
bwin
-
>
IsTabContentWindow
(
GetOuterWindowInternal
(
)
&
isTab
)
)
&
&
isTab
)
)
{
treeOwnerAsWin
-
>
Destroy
(
)
;
}
}
}
CleanUp
(
)
;
}
}
void
nsGlobalWindowOuter
:
:
EnterModalState
(
)
{
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
!
topWin
)
{
NS_ERROR
(
"
Uh
EnterModalState
(
)
called
w
/
o
a
reachable
top
window
?
"
)
;
return
;
}
EventStateManager
*
activeESM
=
static_cast
<
EventStateManager
*
>
(
EventStateManager
:
:
GetActiveEventStateManager
(
)
)
;
if
(
activeESM
&
&
activeESM
-
>
GetPresContext
(
)
)
{
nsIPresShell
*
activeShell
=
activeESM
-
>
GetPresContext
(
)
-
>
GetPresShell
(
)
;
if
(
activeShell
&
&
(
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
activeShell
-
>
GetDocument
(
)
mDoc
)
|
|
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
mDoc
activeShell
-
>
GetDocument
(
)
)
)
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
activeESM
)
;
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
if
(
activeShell
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
activeShell
-
>
FrameSelection
(
)
;
frameSelection
-
>
SetDragState
(
false
)
;
}
}
}
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
ds
-
>
EndDragSession
(
true
0
)
;
}
Document
*
topDoc
=
topWin
-
>
GetExtantDoc
(
)
;
nsIContent
*
capturingContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
&
&
topDoc
&
&
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
capturingContent
topDoc
)
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
if
(
topWin
-
>
mModalStateDepth
=
=
0
)
{
NS_ASSERTION
(
!
topWin
-
>
mSuspendedDoc
"
Shouldn
'
t
have
mSuspendedDoc
here
!
"
)
;
topWin
-
>
mSuspendedDoc
=
topDoc
;
if
(
topDoc
)
{
topDoc
-
>
SuppressEventHandling
(
)
;
}
nsGlobalWindowInner
*
inner
=
topWin
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
)
{
topWin
-
>
GetCurrentInnerWindowInternal
(
)
-
>
Suspend
(
)
;
}
}
topWin
-
>
mModalStateDepth
+
+
;
}
void
nsGlobalWindowOuter
:
:
LeaveModalState
(
)
{
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
!
topWin
)
{
NS_ERROR
(
"
Uh
LeaveModalState
(
)
called
w
/
o
a
reachable
top
window
?
"
)
;
return
;
}
MOZ_ASSERT
(
topWin
-
>
mModalStateDepth
!
=
0
)
;
MOZ_ASSERT
(
IsSuspended
(
)
)
;
MOZ_ASSERT
(
topWin
-
>
IsSuspended
(
)
)
;
topWin
-
>
mModalStateDepth
-
-
;
nsGlobalWindowInner
*
inner
=
topWin
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWin
-
>
mModalStateDepth
=
=
0
)
{
if
(
inner
)
{
inner
-
>
Resume
(
)
;
}
if
(
topWin
-
>
mSuspendedDoc
)
{
nsCOMPtr
<
Document
>
currentDoc
=
topWin
-
>
GetExtantDoc
(
)
;
topWin
-
>
mSuspendedDoc
-
>
UnsuppressEventHandlingAndFireEvents
(
currentDoc
=
=
topWin
-
>
mSuspendedDoc
)
;
topWin
-
>
mSuspendedDoc
=
nullptr
;
}
}
if
(
inner
)
{
inner
-
>
mLastDialogQuitTime
=
TimeStamp
:
:
Now
(
)
;
}
if
(
topWin
-
>
mModalStateDepth
=
=
0
)
{
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
inner
nullptr
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
endmodalstate
"
)
true
false
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
topWin
-
>
DispatchEvent
(
*
event
)
;
}
}
bool
nsGlobalWindowOuter
:
:
IsInModalState
(
)
{
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
!
topWin
)
{
return
false
;
}
return
topWin
-
>
mModalStateDepth
!
=
0
;
}
void
nsGlobalWindowOuter
:
:
NotifyWindowIDDestroyed
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
WindowDestroyedEvent
(
this
mWindowID
aTopic
)
;
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
Element
*
nsGlobalWindowOuter
:
:
GetFrameElementOuter
(
nsIPrincipal
&
aSubjectPrincipal
)
{
if
(
!
mDocShell
|
|
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
return
nullptr
;
}
Element
*
element
=
GetRealFrameElementOuter
(
)
;
if
(
!
element
)
{
return
nullptr
;
}
if
(
!
aSubjectPrincipal
.
SubsumesConsideringDomain
(
element
-
>
NodePrincipal
(
)
)
)
{
return
nullptr
;
}
return
element
;
}
Element
*
nsGlobalWindowOuter
:
:
GetRealFrameElementOuter
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
parent
;
mDocShell
-
>
GetSameTypeParentIgnoreBrowserBoundaries
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
|
|
parent
=
=
mDocShell
)
{
return
nullptr
;
}
return
mFrameElement
;
}
Element
*
nsGlobalWindowOuter
:
:
GetFrameElement
(
)
{
FORWARD_TO_INNER
(
GetFrameElement
(
)
nullptr
)
;
}
namespace
{
class
ChildCommandDispatcher
:
public
Runnable
{
public
:
ChildCommandDispatcher
(
nsPIWindowRoot
*
aRoot
nsITabChild
*
aTabChild
const
nsAString
&
aAction
)
:
mozilla
:
:
Runnable
(
"
ChildCommandDispatcher
"
)
mRoot
(
aRoot
)
mTabChild
(
aTabChild
)
mAction
(
aAction
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsTArray
<
nsCString
>
enabledCommands
disabledCommands
;
mRoot
-
>
GetEnabledDisabledCommands
(
enabledCommands
disabledCommands
)
;
if
(
enabledCommands
.
Length
(
)
|
|
disabledCommands
.
Length
(
)
)
{
mTabChild
-
>
EnableDisableCommands
(
mAction
enabledCommands
disabledCommands
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsPIWindowRoot
>
mRoot
;
nsCOMPtr
<
nsITabChild
>
mTabChild
;
nsString
mAction
;
}
;
class
CommandDispatcher
:
public
Runnable
{
public
:
CommandDispatcher
(
nsIDOMXULCommandDispatcher
*
aDispatcher
const
nsAString
&
aAction
)
:
mozilla
:
:
Runnable
(
"
CommandDispatcher
"
)
mDispatcher
(
aDispatcher
)
mAction
(
aAction
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mDispatcher
-
>
UpdateCommands
(
mAction
)
;
}
nsCOMPtr
<
nsIDOMXULCommandDispatcher
>
mDispatcher
;
nsString
mAction
;
}
;
}
void
nsGlobalWindowOuter
:
:
UpdateCommands
(
const
nsAString
&
anAction
Selection
*
aSel
int16_t
aReason
)
{
if
(
nsIDocShell
*
docShell
=
GetDocShell
(
)
)
{
if
(
nsCOMPtr
<
nsITabChild
>
child
=
docShell
-
>
GetTabChild
(
)
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
GetTopWindowRoot
(
)
;
if
(
root
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
ChildCommandDispatcher
(
root
child
anAction
)
)
;
}
return
;
}
}
nsPIDOMWindowOuter
*
rootWindow
=
GetPrivateRoot
(
)
;
if
(
!
rootWindow
)
{
return
;
}
Document
*
doc
=
rootWindow
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
;
}
if
(
!
anAction
.
EqualsLiteral
(
"
selectionchange
"
)
)
{
nsIDOMXULCommandDispatcher
*
xulCommandDispatcher
=
doc
-
>
GetCommandDispatcher
(
)
;
if
(
xulCommandDispatcher
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
CommandDispatcher
(
xulCommandDispatcher
anAction
)
)
;
}
}
}
Selection
*
nsGlobalWindowOuter
:
:
GetSelectionOuter
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
return
presShell
-
>
GetCurrentSelection
(
SelectionType
:
:
eNormal
)
;
}
already_AddRefed
<
Selection
>
nsGlobalWindowOuter
:
:
GetSelection
(
)
{
RefPtr
<
Selection
>
selection
=
GetSelectionOuter
(
)
;
return
selection
.
forget
(
)
;
}
bool
nsGlobalWindowOuter
:
:
FindOuter
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
ErrorResult
&
aError
)
{
Unused
<
<
aShowDialog
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
disable_window_find
"
false
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
false
;
}
nsCOMPtr
<
nsIWebBrowserFind
>
finder
(
do_GetInterface
(
mDocShell
)
)
;
if
(
!
finder
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
false
;
}
aError
=
finder
-
>
SetSearchString
(
aString
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
finder
-
>
SetMatchCase
(
aCaseSensitive
)
;
finder
-
>
SetFindBackwards
(
aBackwards
)
;
finder
-
>
SetWrapFind
(
aWrapAround
)
;
finder
-
>
SetEntireWord
(
aWholeWord
)
;
finder
-
>
SetSearchFrames
(
aSearchInFrames
)
;
nsCOMPtr
<
nsIWebBrowserFindInFrames
>
framesFinder
(
do_QueryInterface
(
finder
)
)
;
if
(
framesFinder
)
{
framesFinder
-
>
SetRootSearchFrame
(
this
)
;
framesFinder
-
>
SetCurrentSearchFrame
(
this
)
;
}
if
(
aString
.
IsEmpty
(
)
)
{
return
false
;
}
bool
didFind
=
false
;
aError
=
finder
-
>
FindNext
(
&
didFind
)
;
return
didFind
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetOwnerGlobalForBindingsInternal
(
)
{
return
this
;
}
bool
nsGlobalWindowOuter
:
:
DispatchEvent
(
Event
&
aEvent
CallerType
aCallerType
ErrorResult
&
aRv
)
{
FORWARD_TO_INNER
(
DispatchEvent
(
aEvent
aCallerType
aRv
)
false
)
;
}
bool
nsGlobalWindowOuter
:
:
ComputeDefaultWantsUntrusted
(
ErrorResult
&
aRv
)
{
FORWARD_TO_INNER_CREATE
(
ComputeDefaultWantsUntrusted
(
aRv
)
false
)
;
}
EventListenerManager
*
nsGlobalWindowOuter
:
:
GetOrCreateListenerManager
(
)
{
FORWARD_TO_INNER_CREATE
(
GetOrCreateListenerManager
(
)
nullptr
)
;
}
EventListenerManager
*
nsGlobalWindowOuter
:
:
GetExistingListenerManager
(
)
const
{
FORWARD_TO_INNER
(
GetExistingListenerManager
(
)
nullptr
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetPrivateParent
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParent
(
)
;
if
(
this
=
=
parent
)
{
nsCOMPtr
<
nsIContent
>
chromeElement
(
do_QueryInterface
(
mChromeEventHandler
)
)
;
if
(
!
chromeElement
)
return
nullptr
;
Document
*
doc
=
chromeElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
return
nullptr
;
return
doc
-
>
GetWindow
(
)
;
}
return
parent
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetPrivateRoot
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
GetTop
(
)
;
nsCOMPtr
<
nsIContent
>
chromeElement
(
do_QueryInterface
(
mChromeEventHandler
)
)
;
if
(
chromeElement
)
{
Document
*
doc
=
chromeElement
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
doc
-
>
GetWindow
(
)
;
if
(
parent
)
{
top
=
parent
-
>
GetTop
(
)
;
}
}
}
return
top
;
}
Location
*
nsGlobalWindowOuter
:
:
GetLocation
(
)
{
FORWARD_TO_INNER
(
Location
(
)
nullptr
)
;
}
void
nsGlobalWindowOuter
:
:
ActivateOrDeactivate
(
bool
aActivate
)
{
if
(
!
mDoc
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
mainWidget
=
GetMainWidget
(
)
;
nsCOMPtr
<
nsIWidget
>
topLevelWidget
;
if
(
mainWidget
)
{
topLevelWidget
=
mainWidget
-
>
GetSheetWindowParent
(
)
;
if
(
!
topLevelWidget
)
{
topLevelWidget
=
mainWidget
;
}
}
SetActive
(
aActivate
)
;
if
(
mainWidget
!
=
topLevelWidget
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
topLevelWindow
;
nsIWidgetListener
*
listener
=
topLevelWidget
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
nsCOMPtr
<
nsIXULWindow
>
window
=
listener
-
>
GetXULWindow
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
req
(
do_QueryInterface
(
window
)
)
;
topLevelWindow
=
do_GetInterface
(
req
)
;
}
if
(
topLevelWindow
)
{
topLevelWindow
-
>
SetActive
(
aActivate
)
;
}
}
}
static
bool
NotifyDocumentTree
(
Document
*
aDocument
void
*
aData
)
{
aDocument
-
>
EnumerateSubDocuments
(
NotifyDocumentTree
nullptr
)
;
aDocument
-
>
DocumentStatesChanged
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
;
return
true
;
}
void
nsGlobalWindowOuter
:
:
SetActive
(
bool
aActive
)
{
nsPIDOMWindowOuter
:
:
SetActive
(
aActive
)
;
if
(
mDoc
)
{
NotifyDocumentTree
(
mDoc
nullptr
)
;
}
}
bool
nsGlobalWindowOuter
:
:
IsTopLevelWindowActive
(
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
GetDocShell
(
)
)
;
if
(
!
treeItem
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
treeItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
!
rootItem
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
rootItem
-
>
GetWindow
(
)
;
return
domWindow
&
&
domWindow
-
>
IsActive
(
)
;
}
void
nsGlobalWindowOuter
:
:
SetIsBackground
(
bool
aIsBackground
)
{
bool
changed
=
aIsBackground
!
=
IsBackground
(
)
;
SetIsBackgroundInternal
(
aIsBackground
)
;
nsGlobalWindowInner
*
inner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
&
&
changed
)
{
inner
-
>
mTimeoutManager
-
>
UpdateBackgroundState
(
)
;
}
if
(
aIsBackground
)
{
if
(
inner
&
&
changed
)
{
inner
-
>
StopGamepadHaptics
(
)
;
inner
-
>
StopVRActivity
(
)
;
inner
-
>
ResetVRTelemetry
(
true
)
;
}
return
;
}
if
(
inner
)
{
inner
-
>
ResetVRTelemetry
(
false
)
;
inner
-
>
SyncGamepadState
(
)
;
inner
-
>
StartVRActivity
(
)
;
}
}
void
nsGlobalWindowOuter
:
:
SetIsBackgroundInternal
(
bool
aIsBackground
)
{
if
(
mIsBackground
!
=
aIsBackground
)
{
TabGroup
(
)
-
>
WindowChangedBackgroundStatus
(
aIsBackground
)
;
}
mIsBackground
=
aIsBackground
;
}
void
nsGlobalWindowOuter
:
:
SetChromeEventHandler
(
EventTarget
*
aChromeEventHandler
)
{
SetChromeEventHandlerInternal
(
aChromeEventHandler
)
;
RefPtr
<
nsGlobalWindowInner
>
inner
;
for
(
PRCList
*
node
=
PR_LIST_HEAD
(
this
)
;
node
!
=
this
;
node
=
PR_NEXT_LINK
(
inner
)
)
{
inner
=
static_cast
<
nsGlobalWindowInner
*
>
(
node
)
;
NS_ASSERTION
(
!
inner
-
>
mOuterWindow
|
|
inner
-
>
mOuterWindow
=
=
this
"
bad
outer
window
pointer
"
)
;
inner
-
>
SetChromeEventHandlerInternal
(
aChromeEventHandler
)
;
}
}
void
nsGlobalWindowOuter
:
:
SetFocusedElement
(
Element
*
aElement
uint32_t
aFocusMethod
bool
aNeedsFocus
)
{
FORWARD_TO_INNER_VOID
(
SetFocusedElement
(
aElement
aFocusMethod
aNeedsFocus
)
)
;
}
uint32_t
nsGlobalWindowOuter
:
:
GetFocusMethod
(
)
{
FORWARD_TO_INNER
(
GetFocusMethod
(
)
0
)
;
}
bool
nsGlobalWindowOuter
:
:
ShouldShowFocusRing
(
)
{
FORWARD_TO_INNER
(
ShouldShowFocusRing
(
)
false
)
;
}
void
nsGlobalWindowOuter
:
:
SetKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
{
nsPIDOMWindowOuter
*
piWin
=
GetPrivateRoot
(
)
;
if
(
!
piWin
)
{
return
;
}
MOZ_ASSERT
(
piWin
=
=
this
)
;
bool
oldShouldShowFocusRing
=
ShouldShowFocusRing
(
)
;
nsCOMPtr
<
nsPIWindowRoot
>
windowRoot
=
do_QueryInterface
(
mChromeEventHandler
)
;
if
(
!
windowRoot
)
{
return
;
}
if
(
aShowAccelerators
!
=
UIStateChangeType_NoChange
)
{
windowRoot
-
>
SetShowAccelerators
(
aShowAccelerators
=
=
UIStateChangeType_Set
)
;
}
if
(
aShowFocusRings
!
=
UIStateChangeType_NoChange
)
{
windowRoot
-
>
SetShowFocusRings
(
aShowFocusRings
=
=
UIStateChangeType_Set
)
;
}
nsContentUtils
:
:
SetKeyboardIndicatorsOnRemoteChildren
(
GetOuterWindow
(
)
aShowAccelerators
aShowFocusRings
)
;
bool
newShouldShowFocusRing
=
ShouldShowFocusRing
(
)
;
if
(
mInnerWindow
&
&
nsGlobalWindowInner
:
:
Cast
(
mInnerWindow
)
-
>
mHasFocus
&
&
mInnerWindow
-
>
mFocusedElement
&
&
oldShouldShowFocusRing
!
=
newShouldShowFocusRing
)
{
if
(
newShouldShowFocusRing
)
{
mInnerWindow
-
>
mFocusedElement
-
>
AddStates
(
NS_EVENT_STATE_FOCUSRING
)
;
}
else
{
mInnerWindow
-
>
mFocusedElement
-
>
RemoveStates
(
NS_EVENT_STATE_FOCUSRING
)
;
}
}
}
bool
nsGlobalWindowOuter
:
:
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
{
FORWARD_TO_INNER
(
TakeFocus
(
aFocus
aFocusMethod
)
false
)
;
}
void
nsGlobalWindowOuter
:
:
SetReadyForFocus
(
)
{
FORWARD_TO_INNER_VOID
(
SetReadyForFocus
(
)
)
;
}
void
nsGlobalWindowOuter
:
:
PageHidden
(
)
{
FORWARD_TO_INNER_VOID
(
PageHidden
(
)
)
;
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowOuter
:
:
GetComputedStyleHelperOuter
(
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
)
{
if
(
!
mDoc
)
{
return
nullptr
;
}
RefPtr
<
nsICSSDeclaration
>
compStyle
=
NS_NewComputedDOMStyle
(
&
aElt
aPseudoElt
mDoc
aDefaultStylesOnly
?
nsComputedDOMStyle
:
:
eDefaultOnly
:
nsComputedDOMStyle
:
:
eAll
)
;
return
compStyle
.
forget
(
)
;
}
nsresult
nsGlobalWindowOuter
:
:
GetInterfaceInternal
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
NS_ENSURE_ARG_POINTER
(
aSink
)
;
*
aSink
=
nullptr
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebNavigation
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
outer
-
>
mDocShell
)
)
;
webNav
.
forget
(
aSink
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDocShell
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
outer
-
>
mDocShell
;
docShell
.
forget
(
aSink
)
;
}
#
ifdef
NS_PRINTING
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebBrowserPrint
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
if
(
outer
-
>
mDocShell
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
;
outer
-
>
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
nsCOMPtr
<
nsIWebBrowserPrint
>
webBrowserPrint
(
do_QueryInterface
(
viewer
)
)
;
webBrowserPrint
.
forget
(
aSink
)
;
}
}
}
#
endif
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
(
do_QueryInterface
(
outer
-
>
mDocShell
)
)
;
loadContext
.
forget
(
aSink
)
;
}
return
*
aSink
?
NS_OK
:
NS_ERROR_NO_INTERFACE
;
}
NS_IMETHODIMP
nsGlobalWindowOuter
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
nsresult
rv
=
GetInterfaceInternal
(
aIID
aSink
)
;
if
(
rv
=
=
NS_ERROR_NO_INTERFACE
)
{
return
QueryInterface
(
aIID
aSink
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsGlobalWindowOuter
:
:
Observe
(
nsISupports
*
aSupports
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
PERM_CHANGE_NOTIFICATION
)
)
{
if
(
!
nsCRT
:
:
strcmp
(
aData
u
"
cleared
"
)
&
&
!
aSupports
)
{
mHasStorageAccess
=
false
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPermission
>
permission
=
do_QueryInterface
(
aSupports
)
;
if
(
!
permission
)
{
return
NS_OK
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
return
NS_OK
;
}
if
(
!
AntiTrackingCommon
:
:
IsStorageAccessPermission
(
permission
principal
)
)
{
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aData
u
"
deleted
"
)
)
{
mHasStorageAccess
=
false
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aData
u
"
added
"
)
|
|
!
nsCRT
:
:
strcmp
(
aData
u
"
changed
"
)
)
{
uint32_t
expireType
=
0
;
int64_t
expireTime
=
0
;
MOZ_ALWAYS_SUCCEEDS
(
permission
-
>
GetExpireType
(
&
expireType
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
permission
-
>
GetExpireTime
(
&
expireTime
)
)
;
if
(
(
expireType
=
=
nsIPermissionManager
:
:
EXPIRE_TIME
&
&
expireTime
>
=
PR_Now
(
)
/
1000
)
|
|
(
expireType
=
=
nsIPermissionManager
:
:
EXPIRE_SESSION
&
&
expireTime
!
=
0
)
)
{
mHasStorageAccess
=
true
;
return
NS_OK
;
}
}
}
else
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
mHasStorageAccess
=
false
;
return
NS_OK
;
}
return
NS_OK
;
}
bool
nsGlobalWindowOuter
:
:
IsSuspended
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mInnerWindow
)
{
return
true
;
}
return
mInnerWindow
-
>
IsSuspended
(
)
;
}
bool
nsGlobalWindowOuter
:
:
IsFrozen
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mInnerWindow
)
{
return
true
;
}
return
mInnerWindow
-
>
IsFrozen
(
)
;
}
nsresult
nsGlobalWindowOuter
:
:
FireDelayedDOMEvents
(
)
{
FORWARD_TO_INNER
(
FireDelayedDOMEvents
(
)
NS_ERROR_UNEXPECTED
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowOuter
:
:
GetParentInternal
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
!
=
this
)
{
return
parent
;
}
return
nullptr
;
}
void
nsGlobalWindowOuter
:
:
UnblockScriptedClosing
(
)
{
mBlockScriptedClosingFlag
=
false
;
}
class
AutoUnblockScriptClosing
{
private
:
RefPtr
<
nsGlobalWindowOuter
>
mWin
;
public
:
explicit
AutoUnblockScriptClosing
(
nsGlobalWindowOuter
*
aWin
)
:
mWin
(
aWin
)
{
MOZ_ASSERT
(
mWin
)
;
}
~
AutoUnblockScriptClosing
(
)
{
void
(
nsGlobalWindowOuter
:
:
*
run
)
(
)
=
&
nsGlobalWindowOuter
:
:
UnblockScriptedClosing
;
nsCOMPtr
<
nsIRunnable
>
caller
=
NewRunnableMethod
(
"
AutoUnblockScriptClosing
:
:
~
AutoUnblockScriptClosing
"
mWin
run
)
;
mWin
-
>
Dispatch
(
TaskCategory
:
:
Other
caller
.
forget
(
)
)
;
}
}
;
nsresult
nsGlobalWindowOuter
:
:
OpenInternal
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
bool
aDialog
bool
aContentModal
bool
aCalledNoScript
bool
aDoJSFixups
bool
aNavigate
nsIArray
*
argv
nsISupports
*
aExtraArgument
nsDocShellLoadState
*
aLoadState
bool
aForceNoOpener
nsPIDOMWindowOuter
*
*
aReturn
)
{
#
ifdef
DEBUG
uint32_t
argc
=
0
;
if
(
argv
)
argv
-
>
GetLength
(
&
argc
)
;
#
endif
MOZ_ASSERT
(
!
aExtraArgument
|
|
(
!
argv
&
&
argc
=
=
0
)
"
Can
'
t
pass
in
arguments
both
ways
"
)
;
MOZ_ASSERT
(
!
aCalledNoScript
|
|
(
!
argv
&
&
argc
=
=
0
)
"
Can
'
t
pass
JS
args
when
called
via
the
noscript
methods
"
)
;
mozilla
:
:
Maybe
<
AutoUnblockScriptClosing
>
closeUnblocker
;
MOZ_ASSERT
(
aCalledNoScript
|
|
aNavigate
)
;
*
aReturn
=
nullptr
;
nsCOMPtr
<
nsIWebBrowserChrome
>
chrome
=
GetWebBrowserChrome
(
)
;
if
(
!
chrome
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ASSERTION
(
mDocShell
"
Must
have
docshell
here
"
)
;
nsAutoCString
options
;
bool
forceNoOpener
=
aForceNoOpener
;
nsCharSeparatedTokenizerTemplate
<
nsContentUtils
:
:
IsHTMLWhitespace
>
tok
(
aOptions
'
'
)
;
while
(
tok
.
hasMoreTokens
(
)
)
{
auto
nextTok
=
tok
.
nextToken
(
)
;
if
(
nextTok
.
EqualsLiteral
(
"
noopener
"
)
)
{
forceNoOpener
=
true
;
continue
;
}
if
(
!
options
.
IsEmpty
(
)
)
{
options
.
Append
(
'
'
)
;
}
AppendUTF16toUTF8
(
nextTok
options
)
;
}
bool
windowExists
=
WindowExists
(
aName
forceNoOpener
!
aCalledNoScript
)
;
const
bool
checkForPopup
=
!
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
&
&
!
aDialog
&
&
!
windowExists
;
nsCString
url
;
url
.
SetIsVoid
(
true
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
!
aUrl
.
IsEmpty
(
)
)
{
AppendUTF16toUTF8
(
aUrl
url
)
;
if
(
!
url
.
IsVoid
(
)
&
&
!
aDialog
&
&
aNavigate
)
rv
=
SecurityCheckURL
(
url
.
get
(
)
getter_AddRefs
(
uri
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
PopupBlocker
:
:
PopupControlState
abuseLevel
=
PopupBlocker
:
:
GetPopupControlState
(
)
;
if
(
checkForPopup
)
{
abuseLevel
=
RevisePopupAbuseLevel
(
abuseLevel
)
;
if
(
abuseLevel
>
=
PopupBlocker
:
:
openBlocked
)
{
if
(
!
aCalledNoScript
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
entryWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
if
(
entryWindow
&
&
entryWindow
-
>
GetOuterWindow
(
)
=
=
this
)
{
mBlockScriptedClosingFlag
=
true
;
closeUnblocker
.
emplace
(
this
)
;
}
}
FireAbuseEvents
(
aUrl
aName
aOptions
)
;
return
aDoJSFixups
?
NS_OK
:
NS_ERROR_FAILURE
;
}
}
nsCOMPtr
<
mozIDOMWindowProxy
>
domReturn
;
nsCOMPtr
<
nsIWindowWatcher
>
wwatch
=
do_GetService
(
NS_WINDOWWATCHER_CONTRACTID
&
rv
)
;
NS_ENSURE_TRUE
(
wwatch
rv
)
;
NS_ConvertUTF16toUTF8
name
(
aName
)
;
const
char
*
options_ptr
=
options
.
IsEmpty
(
)
?
nullptr
:
options
.
get
(
)
;
const
char
*
name_ptr
=
aName
.
IsEmpty
(
)
?
nullptr
:
name
.
get
(
)
;
nsCOMPtr
<
nsPIWindowWatcher
>
pwwatch
(
do_QueryInterface
(
wwatch
)
)
;
NS_ENSURE_STATE
(
pwwatch
)
;
MOZ_ASSERT_IF
(
checkForPopup
abuseLevel
<
PopupBlocker
:
:
openBlocked
)
;
bool
isPopupSpamWindow
=
checkForPopup
&
&
(
abuseLevel
>
=
PopupBlocker
:
:
openControlled
)
;
{
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
if
(
!
aCalledNoScript
)
{
rv
=
pwwatch
-
>
OpenWindow2
(
this
url
.
IsVoid
(
)
?
nullptr
:
url
.
get
(
)
name_ptr
options_ptr
true
aDialog
aNavigate
argv
isPopupSpamWindow
forceNoOpener
aLoadState
getter_AddRefs
(
domReturn
)
)
;
}
else
{
Maybe
<
AutoNoJSAPI
>
nojsapi
;
if
(
!
aContentModal
)
{
nojsapi
.
emplace
(
)
;
}
rv
=
pwwatch
-
>
OpenWindow2
(
this
url
.
IsVoid
(
)
?
nullptr
:
url
.
get
(
)
name_ptr
options_ptr
false
aDialog
aNavigate
aExtraArgument
isPopupSpamWindow
forceNoOpener
aLoadState
getter_AddRefs
(
domReturn
)
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aCalledNoScript
&
&
!
windowExists
&
&
uri
&
&
!
forceNoOpener
)
{
MaybeAllowStorageForOpenedWindow
(
uri
)
;
}
NS_ENSURE_TRUE
(
domReturn
NS_OK
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerReturn
=
nsPIDOMWindowOuter
:
:
From
(
domReturn
)
;
outerReturn
.
swap
(
*
aReturn
)
;
if
(
aDoJSFixups
)
{
nsCOMPtr
<
nsIDOMChromeWindow
>
chrome_win
(
do_QueryInterface
(
*
aReturn
)
)
;
if
(
!
chrome_win
)
{
nsCOMPtr
<
Document
>
doc
=
(
*
aReturn
)
-
>
GetDoc
(
)
;
Unused
<
<
doc
;
}
}
return
rv
;
}
void
nsGlobalWindowOuter
:
:
MaybeAllowStorageForOpenedWindow
(
nsIURI
*
aURI
)
{
nsGlobalWindowInner
*
inner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
;
}
if
(
!
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
inner
nullptr
aURI
)
)
{
return
;
}
Document
*
doc
=
inner
-
>
GetDoc
(
)
;
if
(
!
doc
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
aURI
doc
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
Unused
<
<
AntiTrackingCommon
:
:
AddFirstPartyStorageAccessGrantedFor
(
principal
inner
AntiTrackingCommon
:
:
eOpener
)
;
}
already_AddRefed
<
nsIDocShellTreeOwner
>
nsGlobalWindowOuter
:
:
GetTreeOwner
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
mDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
return
treeOwner
.
forget
(
)
;
}
already_AddRefed
<
nsIBaseWindow
>
nsGlobalWindowOuter
:
:
GetTreeOwnerWindow
(
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
if
(
mDocShell
)
{
mDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
treeOwner
)
;
return
baseWindow
.
forget
(
)
;
}
already_AddRefed
<
nsIWebBrowserChrome
>
nsGlobalWindowOuter
:
:
GetWebBrowserChrome
(
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
=
do_GetInterface
(
treeOwner
)
;
return
browserChrome
.
forget
(
)
;
}
nsIScrollableFrame
*
nsGlobalWindowOuter
:
:
GetScrollFrame
(
)
{
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
return
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
return
nullptr
;
}
nsresult
nsGlobalWindowOuter
:
:
SecurityCheckURL
(
const
char
*
aURL
nsIURI
*
*
aURI
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
sourceWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
if
(
!
sourceWindow
)
{
sourceWindow
=
GetCurrentInnerWindow
(
)
;
}
AutoJSContext
cx
;
nsGlobalWindowInner
*
sourceWin
=
nsGlobalWindowInner
:
:
Cast
(
sourceWindow
)
;
JSAutoRealm
ar
(
cx
sourceWin
-
>
GetGlobalJSObject
(
)
)
;
nsCOMPtr
<
Document
>
doc
=
sourceWindow
-
>
GetDoc
(
)
;
nsIURI
*
baseURI
=
nullptr
;
auto
encoding
=
UTF_8_ENCODING
;
if
(
doc
)
{
baseURI
=
doc
-
>
GetDocBaseURI
(
)
;
encoding
=
doc
-
>
GetDocumentCharacterSet
(
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
nsDependentCString
(
aURL
)
encoding
baseURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
if
(
NS_FAILED
(
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIFromScript
(
cx
uri
)
)
)
{
return
NS_ERROR_FAILURE
;
}
uri
.
forget
(
aURI
)
;
return
NS_OK
;
}
void
nsGlobalWindowOuter
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
if
(
mDoc
)
{
mDoc
-
>
FlushPendingNotifications
(
aType
)
;
}
}
void
nsGlobalWindowOuter
:
:
EnsureSizeAndPositionUpToDate
(
)
{
nsGlobalWindowOuter
*
parent
=
nsGlobalWindowOuter
:
:
Cast
(
GetPrivateParent
(
)
)
;
if
(
parent
)
{
parent
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
already_AddRefed
<
nsISupports
>
nsGlobalWindowOuter
:
:
SaveWindowState
(
)
{
if
(
!
mContext
|
|
!
GetWrapperPreserveColor
(
)
)
{
return
nullptr
;
}
nsGlobalWindowInner
*
inner
=
GetCurrentInnerWindowInternal
(
)
;
NS_ASSERTION
(
inner
"
No
inner
window
to
save
"
)
;
inner
-
>
Freeze
(
)
;
nsCOMPtr
<
nsISupports
>
state
=
new
WindowStateHolder
(
inner
)
;
#
ifdef
DEBUG_PAGE_CACHE
printf
(
"
saving
window
state
state
=
%
p
\
n
"
(
void
*
)
state
)
;
#
endif
return
state
.
forget
(
)
;
}
nsresult
nsGlobalWindowOuter
:
:
RestoreWindowState
(
nsISupports
*
aState
)
{
if
(
!
mContext
|
|
!
GetWrapperPreserveColor
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
WindowStateHolder
>
holder
=
do_QueryInterface
(
aState
)
;
NS_ENSURE_TRUE
(
holder
NS_ERROR_FAILURE
)
;
#
ifdef
DEBUG_PAGE_CACHE
printf
(
"
restoring
window
state
state
=
%
p
\
n
"
(
void
*
)
holder
)
;
#
endif
nsGlobalWindowInner
*
inner
=
GetCurrentInnerWindowInternal
(
)
;
Element
*
focusedElement
=
inner
-
>
GetFocusedElement
(
)
;
if
(
nsContentUtils
:
:
ContentIsLink
(
focusedElement
)
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
RefPtr
<
Element
>
kungFuDeathGrip
(
focusedElement
)
;
fm
-
>
SetFocus
(
kungFuDeathGrip
nsIFocusManager
:
:
FLAG_NOSCROLL
|
nsIFocusManager
:
:
FLAG_SHOWRING
)
;
}
}
inner
-
>
Thaw
(
)
;
holder
-
>
DidRestoreWindow
(
)
;
return
NS_OK
;
}
void
nsGlobalWindowOuter
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
aWindowSizes
.
mDOMOtherSize
+
=
aWindowSizes
.
mState
.
mMallocSizeOf
(
this
)
;
}
uint32_t
nsGlobalWindowOuter
:
:
GetAutoActivateVRDisplayID
(
)
{
uint32_t
retVal
=
mAutoActivateVRDisplayID
;
mAutoActivateVRDisplayID
=
0
;
return
retVal
;
}
void
nsGlobalWindowOuter
:
:
SetAutoActivateVRDisplayID
(
uint32_t
aAutoActivateVRDisplayID
)
{
mAutoActivateVRDisplayID
=
aAutoActivateVRDisplayID
;
}
already_AddRefed
<
nsWindowRoot
>
nsGlobalWindowOuter
:
:
GetWindowRootOuter
(
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
GetTopWindowRoot
(
)
;
return
root
.
forget
(
)
.
downcast
<
nsWindowRoot
>
(
)
;
}
nsIDOMWindowUtils
*
nsGlobalWindowOuter
:
:
WindowUtils
(
)
{
if
(
!
mWindowUtils
)
{
mWindowUtils
=
new
nsDOMWindowUtils
(
this
)
;
}
return
mWindowUtils
;
}
void
nsGlobalWindowOuter
:
:
SetCursorOuter
(
const
nsAString
&
aCursor
ErrorResult
&
aError
)
{
StyleCursorKind
cursor
;
if
(
aCursor
.
EqualsLiteral
(
"
auto
"
)
)
{
cursor
=
StyleCursorKind
:
:
Auto
;
}
else
{
nsCSSKeyword
keyword
=
nsCSSKeywords
:
:
LookupKeyword
(
aCursor
)
;
int32_t
c
;
if
(
!
nsCSSProps
:
:
FindKeyword
(
keyword
nsCSSProps
:
:
kCursorKTable
c
)
)
{
return
;
}
cursor
=
static_cast
<
StyleCursorKind
>
(
c
)
;
}
RefPtr
<
nsPresContext
>
presContext
;
if
(
mDocShell
)
{
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
}
if
(
presContext
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
if
(
!
rootView
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIWidget
*
widget
=
rootView
-
>
GetNearestWidget
(
nullptr
)
;
if
(
!
widget
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aError
=
presContext
-
>
EventStateManager
(
)
-
>
SetCursor
(
cursor
nullptr
false
0
.
0f
0
.
0f
widget
true
)
;
}
}
NS_IMETHODIMP
nsGlobalWindowOuter
:
:
GetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
*
aBrowserWindow
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
FORWARD_TO_INNER
(
GetBrowserDOMWindow
(
aBrowserWindow
)
NS_ERROR_UNEXPECTED
)
;
}
nsIBrowserDOMWindow
*
nsGlobalWindowOuter
:
:
GetBrowserDOMWindowOuter
(
)
{
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
return
mChromeFields
.
mBrowserDOMWindow
;
}
void
nsGlobalWindowOuter
:
:
SetBrowserDOMWindowOuter
(
nsIBrowserDOMWindow
*
aBrowserWindow
)
{
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
mChromeFields
.
mBrowserDOMWindow
=
aBrowserWindow
;
}
ChromeMessageBroadcaster
*
nsGlobalWindowOuter
:
:
GetMessageManager
(
)
{
if
(
!
mInnerWindow
)
{
NS_WARNING
(
"
No
inner
window
available
!
"
)
;
return
nullptr
;
}
return
GetCurrentInnerWindowInternal
(
)
-
>
MessageManager
(
)
;
}
ChromeMessageBroadcaster
*
nsGlobalWindowOuter
:
:
GetGroupMessageManager
(
const
nsAString
&
aGroup
)
{
if
(
!
mInnerWindow
)
{
NS_WARNING
(
"
No
inner
window
available
!
"
)
;
return
nullptr
;
}
return
GetCurrentInnerWindowInternal
(
)
-
>
GetGroupMessageManager
(
aGroup
)
;
}
void
nsPIDOMWindowOuter
:
:
SetOpenerForInitialContentBrowser
(
BrowsingContext
*
aOpenerWindow
)
{
MOZ_ASSERT
(
!
mOpenerForInitialContentBrowser
"
Don
'
t
set
OpenerForInitialContentBrowser
twice
!
"
)
;
mOpenerForInitialContentBrowser
=
aOpenerWindow
;
}
already_AddRefed
<
BrowsingContext
>
nsPIDOMWindowOuter
:
:
TakeOpenerForInitialContentBrowser
(
)
{
return
mOpenerForInitialContentBrowser
.
forget
(
)
;
}
void
nsGlobalWindowOuter
:
:
InitWasOffline
(
)
{
mWasOffline
=
NS_IsOffline
(
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
int16_t
nsGlobalWindowOuter
:
:
Orientation
(
CallerType
aCallerType
)
const
{
return
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
?
0
:
WindowOrientationObserver
:
:
OrientationAngle
(
)
;
}
#
endif
void
nsPIDOMWindowOuter
:
:
SetLargeAllocStatus
(
LargeAllocStatus
aStatus
)
{
MOZ_ASSERT
(
mLargeAllocStatus
=
=
LargeAllocStatus
:
:
NONE
)
;
mLargeAllocStatus
=
aStatus
;
}
bool
nsPIDOMWindowOuter
:
:
IsTopLevelWindow
(
)
{
return
nsGlobalWindowOuter
:
:
Cast
(
this
)
-
>
IsTopLevelWindow
(
)
;
}
bool
nsPIDOMWindowOuter
:
:
HadOriginalOpener
(
)
const
{
return
nsGlobalWindowOuter
:
:
Cast
(
this
)
-
>
HadOriginalOpener
(
)
;
}
void
nsGlobalWindowOuter
:
:
ReportLargeAllocStatus
(
)
{
uint32_t
errorFlags
=
nsIScriptError
:
:
warningFlag
;
const
char
*
message
=
nullptr
;
switch
(
mLargeAllocStatus
)
{
case
LargeAllocStatus
:
:
SUCCESS
:
errorFlags
=
nsIScriptError
:
:
infoFlag
;
message
=
"
LargeAllocationSuccess
"
;
break
;
case
LargeAllocStatus
:
:
NON_WIN32
:
errorFlags
=
nsIScriptError
:
:
infoFlag
;
message
=
"
LargeAllocationNonWin32
"
;
break
;
case
LargeAllocStatus
:
:
NON_GET
:
message
=
"
LargeAllocationNonGetRequest
"
;
break
;
case
LargeAllocStatus
:
:
NON_E10S
:
message
=
"
LargeAllocationNonE10S
"
;
break
;
case
LargeAllocStatus
:
:
NOT_ONLY_TOPLEVEL_IN_TABGROUP
:
message
=
"
LargeAllocationNotOnlyToplevelInTabGroup
"
;
break
;
default
:
return
;
}
nsContentUtils
:
:
ReportToConsole
(
errorFlags
NS_LITERAL_CSTRING
(
"
DOM
"
)
mDoc
nsContentUtils
:
:
eDOM_PROPERTIES
message
)
;
}
#
if
defined
(
_WINDOWS_
)
&
&
!
defined
(
MOZ_WRAPPED_WINDOWS_H
)
#
pragma
message
(
\
"
wrapper
failure
reason
:
"
MOZ_WINDOWS_WRAPPER_DISABLED_REASON
)
#
error
"
Never
include
unwrapped
windows
.
h
in
this
file
!
"
#
endif
void
nsGlobalWindowOuter
:
:
CheckForDPIChange
(
)
{
if
(
mDocShell
)
{
RefPtr
<
nsPresContext
>
presContext
=
mDocShell
-
>
GetPresContext
(
)
;
if
(
presContext
)
{
if
(
presContext
-
>
DeviceContext
(
)
-
>
CheckDPIChange
(
)
)
{
presContext
-
>
UIResolutionChanged
(
)
;
}
}
}
}
mozilla
:
:
dom
:
:
TabGroup
*
nsGlobalWindowOuter
:
:
TabGroupOuter
(
)
{
if
(
!
mTabGroup
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
piOpener
=
do_QueryReferent
(
mOpener
)
;
nsPIDOMWindowOuter
*
opener
=
GetSanitizedOpener
(
piOpener
)
;
nsPIDOMWindowOuter
*
parent
=
GetScriptableParentOrNull
(
)
;
MOZ_ASSERT
(
!
parent
|
|
!
opener
"
Only
one
of
parent
and
opener
may
be
provided
"
)
;
mozilla
:
:
dom
:
:
TabGroup
*
toJoin
=
nullptr
;
if
(
GetDocShell
(
)
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
toJoin
=
TabGroup
:
:
GetChromeTabGroup
(
)
;
}
else
if
(
opener
)
{
toJoin
=
opener
-
>
TabGroup
(
)
;
}
else
if
(
parent
)
{
toJoin
=
parent
-
>
TabGroup
(
)
;
}
else
{
toJoin
=
TabGroup
:
:
GetFromWindow
(
this
)
;
}
#
ifdef
DEBUG
mozilla
:
:
dom
:
:
TabGroup
*
testGroup
=
TabGroup
:
:
GetFromWindow
(
this
)
;
MOZ_ASSERT_IF
(
testGroup
testGroup
=
=
toJoin
)
;
#
endif
mTabGroup
=
mozilla
:
:
dom
:
:
TabGroup
:
:
Join
(
this
toJoin
)
;
}
MOZ_ASSERT
(
mTabGroup
)
;
#
ifdef
DEBUG
if
(
!
mIsValidatingTabGroup
)
{
mIsValidatingTabGroup
=
true
;
if
(
mIsChrome
)
{
MOZ_ASSERT
(
mTabGroup
=
=
TabGroup
:
:
GetChromeTabGroup
(
)
)
;
}
else
{
RefPtr
<
nsPIDOMWindowOuter
>
parent
=
GetScriptableParentOrNull
(
)
;
MOZ_ASSERT_IF
(
parent
parent
-
>
TabGroup
(
)
=
=
mTabGroup
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
piOpener
=
do_QueryReferent
(
mOpener
)
;
nsPIDOMWindowOuter
*
opener
=
GetSanitizedOpener
(
piOpener
)
;
MOZ_ASSERT_IF
(
opener
&
&
nsGlobalWindowOuter
:
:
Cast
(
opener
)
!
=
this
opener
-
>
TabGroup
(
)
=
=
mTabGroup
)
;
}
mIsValidatingTabGroup
=
false
;
}
#
endif
return
mTabGroup
;
}
nsresult
nsGlobalWindowOuter
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
Dispatch
(
aCategory
std
:
:
move
(
aRunnable
)
)
;
}
return
DispatcherTrait
:
:
Dispatch
(
aCategory
std
:
:
move
(
aRunnable
)
)
;
}
nsISerialEventTarget
*
nsGlobalWindowOuter
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
EventTargetFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
EventTargetFor
(
aCategory
)
;
}
AbstractThread
*
nsGlobalWindowOuter
:
:
AbstractMainThreadFor
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
AbstractMainThreadFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
AbstractMainThreadFor
(
aCategory
)
;
}
nsGlobalWindowOuter
:
:
TemporarilyDisableDialogs
:
:
TemporarilyDisableDialogs
(
nsGlobalWindowOuter
*
aWindow
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
mSavedDialogsEnabled
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
aWindow
)
;
nsGlobalWindowOuter
*
topWindowOuter
=
aWindow
-
>
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
nsGlobalWindowOuter
:
:
TemporarilyDisableDialogs
used
without
a
top
"
"
window
?
"
)
;
return
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWindow
)
{
mTopWindow
=
topWindow
;
mSavedDialogsEnabled
=
mTopWindow
-
>
mAreDialogsEnabled
;
mTopWindow
-
>
mAreDialogsEnabled
=
false
;
}
}
nsGlobalWindowOuter
:
:
TemporarilyDisableDialogs
:
:
~
TemporarilyDisableDialogs
(
)
{
if
(
mTopWindow
)
{
mTopWindow
-
>
mAreDialogsEnabled
=
mSavedDialogsEnabled
;
}
}
mozilla
:
:
dom
:
:
TabGroup
*
nsPIDOMWindowOuter
:
:
TabGroup
(
)
{
return
nsGlobalWindowOuter
:
:
Cast
(
this
)
-
>
TabGroupOuter
(
)
;
}
already_AddRefed
<
nsGlobalWindowOuter
>
nsGlobalWindowOuter
:
:
Create
(
nsDocShell
*
aDocShell
bool
aIsChrome
)
{
uint64_t
outerWindowID
=
aDocShell
-
>
GetOuterWindowID
(
)
;
RefPtr
<
nsGlobalWindowOuter
>
window
=
new
nsGlobalWindowOuter
(
outerWindowID
)
;
if
(
aIsChrome
)
{
window
-
>
mIsChrome
=
true
;
}
window
-
>
SetDocShell
(
aDocShell
)
;
window
-
>
InitWasOffline
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
PermChangeDelayRunnable
"
[
obs
window
]
{
obs
-
>
AddObserver
(
window
PERM_CHANGE_NOTIFICATION
true
)
;
}
)
)
;
}
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefBranch
)
{
prefBranch
-
>
AddObserver
(
"
network
.
cookie
.
cookieBehavior
"
window
true
)
;
}
return
window
.
forget
(
)
;
}
nsIURI
*
nsPIDOMWindowOuter
:
:
GetDocumentURI
(
)
const
{
return
mDoc
?
mDoc
-
>
GetDocumentURI
(
)
:
mDocumentURI
.
get
(
)
;
}
void
nsPIDOMWindowOuter
:
:
MaybeCreateDoc
(
)
{
MOZ_ASSERT
(
!
mDoc
)
;
if
(
nsIDocShell
*
docShell
=
GetDocShell
(
)
)
{
nsCOMPtr
<
Document
>
document
=
docShell
-
>
GetDocument
(
)
;
Unused
<
<
document
;
}
}
void
nsPIDOMWindowOuter
:
:
SetChromeEventHandlerInternal
(
EventTarget
*
aChromeEventHandler
)
{
mChromeEventHandler
=
aChromeEventHandler
;
mParentTarget
=
nullptr
;
mMessageManager
=
nullptr
;
}
mozilla
:
:
dom
:
:
DocGroup
*
nsPIDOMWindowOuter
:
:
GetDocGroup
(
)
const
{
Document
*
doc
=
GetExtantDoc
(
)
;
if
(
doc
)
{
return
doc
-
>
GetDocGroup
(
)
;
}
return
nullptr
;
}
nsPIDOMWindowOuter
:
:
nsPIDOMWindowOuter
(
uint64_t
aWindowID
)
:
mFrameElement
(
nullptr
)
mDocShell
(
nullptr
)
mModalStateDepth
(
0
)
mIsActive
(
false
)
mIsBackground
(
false
)
mMediaSuspend
(
Preferences
:
:
GetBool
(
"
media
.
block
-
autoplay
-
until
-
in
-
foreground
"
true
)
?
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
:
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
mAudioMuted
(
false
)
mAudioVolume
(
1
.
0
)
mDesktopModeViewport
(
false
)
mIsRootOuterWindow
(
false
)
mInnerWindow
(
nullptr
)
mWindowID
(
aWindowID
)
mMarkedCCGeneration
(
0
)
mServiceWorkersTestingEnabled
(
false
)
mLargeAllocStatus
(
LargeAllocStatus
:
:
NONE
)
{
}
nsPIDOMWindowOuter
:
:
~
nsPIDOMWindowOuter
(
)
{
}
