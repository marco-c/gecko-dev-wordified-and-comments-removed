#
include
"
BodyStream
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
<
cstdint
>
#
include
<
utility
>
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReadableStreamBody
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
BodyStreamHolder
)
if
(
tmp
-
>
mBodyStream
)
{
tmp
-
>
mBodyStream
-
>
ReleaseObjects
(
)
;
MOZ_ASSERT
(
!
tmp
-
>
mBodyStream
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReadableStreamBody
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
BodyStreamHolder
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
BodyStreamHolder
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
BodyStreamHolder
:
:
BodyStreamHolder
(
)
:
mBodyStream
(
nullptr
)
{
}
void
BodyStreamHolder
:
:
StoreBodyStream
(
BodyStream
*
aBodyStream
)
{
MOZ_ASSERT
(
aBodyStream
)
;
MOZ_ASSERT
(
!
mBodyStream
)
;
mBodyStream
=
aBodyStream
;
}
NS_IMPL_ISUPPORTS
(
BodyStream
nsIInputStreamCallback
nsIObserver
nsISupportsWeakReference
)
class
BodyStreamUnderlyingSourceAlgorithms
final
:
public
UnderlyingSourceAlgorithmsWrapper
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
BodyStreamUnderlyingSourceAlgorithms
(
nsIGlobalObject
&
aGlobal
BodyStreamHolder
&
aUnderlyingSource
)
:
mGlobal
(
&
aGlobal
)
mUnderlyingSource
(
&
aUnderlyingSource
)
{
}
already_AddRefed
<
Promise
>
PullCallbackImpl
(
JSContext
*
aCx
ReadableStreamController
&
aController
ErrorResult
&
aRv
)
override
{
RefPtr
<
BodyStream
>
bodyStream
=
mUnderlyingSource
-
>
GetBodyStream
(
)
;
return
bodyStream
-
>
PullCallback
(
aCx
aController
aRv
)
;
}
void
ReleaseObjects
(
)
override
{
RefPtr
<
BodyStreamHolder
>
holder
=
mUnderlyingSource
.
forget
(
)
;
if
(
RefPtr
<
BodyStream
>
bodyStream
=
holder
-
>
GetBodyStream
(
)
)
{
bodyStream
-
>
CloseInputAndReleaseObjects
(
)
;
}
}
BodyStreamHolder
*
GetBodyStreamHolder
(
)
override
{
return
mUnderlyingSource
;
}
protected
:
~
BodyStreamUnderlyingSourceAlgorithms
(
)
override
=
default
;
private
:
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
RefPtr
<
BodyStreamHolder
>
mUnderlyingSource
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
mGlobal
mUnderlyingSource
)
NS_IMPL_ADDREF_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
NS_IMPL_RELEASE_INHERITED
(
BodyStreamUnderlyingSourceAlgorithms
UnderlyingSourceAlgorithmsBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
BodyStreamUnderlyingSourceAlgorithms
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourceAlgorithmsBase
)
void
BodyStream
:
:
Create
(
JSContext
*
aCx
BodyStreamHolder
*
aStreamHolder
nsIGlobalObject
*
aGlobal
nsIInputStream
*
aInputStream
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aCx
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStreamHolder
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
RefPtr
<
BodyStream
>
stream
=
new
BodyStream
(
aGlobal
aStreamHolder
aInputStream
)
;
auto
cleanup
=
MakeScopeExit
(
[
stream
]
{
stream
-
>
Close
(
)
;
}
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
os
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aRv
=
os
-
>
AddObserver
(
stream
DOM_WINDOW_DESTROYED_TOPIC
true
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
else
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
BodyStream
"
[
stream
]
(
)
{
stream
-
>
Close
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
stream
-
>
mWorkerRef
=
std
:
:
move
(
workerRef
)
;
}
auto
algorithms
=
MakeRefPtr
<
BodyStreamUnderlyingSourceAlgorithms
>
(
*
aGlobal
*
aStreamHolder
)
;
RefPtr
<
ReadableStream
>
body
=
ReadableStream
:
:
CreateByteNative
(
aCx
aGlobal
*
algorithms
Nothing
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
cleanup
.
release
(
)
;
aStreamHolder
-
>
StoreBodyStream
(
stream
)
;
aStreamHolder
-
>
SetReadableStreamBody
(
body
)
;
#
ifdef
DEBUG
aStreamHolder
-
>
mStreamCreated
=
true
;
#
endif
}
already_AddRefed
<
Promise
>
BodyStream
:
:
PullCallback
(
JSContext
*
aCx
ReadableStreamController
&
aController
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aController
.
IsByte
(
)
)
;
ReadableStream
*
stream
=
aController
.
Stream
(
)
;
MOZ_ASSERT
(
stream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
Disturbed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsClosed
(
)
)
;
MOZ_ASSERT
(
!
mPullPromise
)
;
mPullPromise
=
Promise
:
:
CreateInfallible
(
aController
.
GetParentObject
(
)
)
;
mStreamHolder
-
>
MarkAsRead
(
)
;
if
(
!
mInputStream
)
{
MOZ_ASSERT
(
mOriginalInputStream
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
;
nsresult
rv
=
NS_MakeAsyncNonBlockingInputStream
(
mOriginalInputStream
.
forget
(
)
getter_AddRefs
(
asyncStream
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
stream
rv
)
;
return
nullptr
;
}
mInputStream
=
asyncStream
;
mOriginalInputStream
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mOriginalInputStream
)
;
nsresult
rv
=
mInputStream
-
>
AsyncWait
(
this
0
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
stream
rv
)
;
return
nullptr
;
}
mAsyncWaitWorkerRef
=
mWorkerRef
;
return
do_AddRef
(
mPullPromise
)
;
}
void
BodyStream
:
:
WriteIntoReadRequestBuffer
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
Handle
<
JSObject
*
>
aBuffer
uint32_t
aLength
uint32_t
*
aByteWritten
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aBuffer
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aByteWritten
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsClosed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPullPromise
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Pending
)
;
uint32_t
written
;
nsresult
rv
;
void
*
buffer
;
{
JS
:
:
AutoSuppressGCAnalysis
suppress
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
isSharedMemory
;
buffer
=
JS_GetArrayBufferViewData
(
aBuffer
&
isSharedMemory
noGC
)
;
MOZ_ASSERT
(
!
isSharedMemory
)
;
rv
=
mInputStream
-
>
Read
(
static_cast
<
char
*
>
(
buffer
)
aLength
&
written
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
}
*
aByteWritten
=
written
;
if
(
written
=
=
0
)
{
CloseAndReleaseObjects
(
aCx
aStream
)
;
return
;
}
rv
=
mInputStream
-
>
AsyncWait
(
this
nsIAsyncInputStream
:
:
WAIT_CLOSURE_ONLY
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
mAsyncWaitWorkerRef
=
mWorkerRef
;
}
void
BodyStream
:
:
CloseInputAndReleaseObjects
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mStreamHolder
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
if
(
mInputStream
)
{
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
if
(
mOriginalInputStream
)
{
MOZ_ASSERT
(
!
mInputStream
)
;
mOriginalInputStream
-
>
Close
(
)
;
}
ReleaseObjects
(
)
;
}
BodyStream
:
:
BodyStream
(
nsIGlobalObject
*
aGlobal
BodyStreamHolder
*
aStreamHolder
nsIInputStream
*
aInputStream
)
:
mGlobal
(
aGlobal
)
mStreamHolder
(
aStreamHolder
)
mOwningEventTarget
(
aGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
mOriginalInputStream
(
aInputStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStreamHolder
)
;
}
BodyStream
:
:
~
BodyStream
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
}
void
BodyStream
:
:
ErrorPropagation
(
JSContext
*
aCx
ReadableStream
*
aStream
nsresult
aError
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
IsClosed
(
)
)
{
return
;
}
if
(
aError
=
=
NS_BASE_STREAM_CLOSED
)
{
CloseAndReleaseObjects
(
aCx
aStream
)
;
return
;
}
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Error
in
body
stream
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
errorValue
(
aCx
)
;
bool
ok
=
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
errorValue
)
;
MOZ_RELEASE_ASSERT
(
ok
"
ToJSValue
never
fails
for
ErrorResult
"
)
;
{
IgnoredErrorResult
rv
;
aStream
-
>
ErrorNative
(
aCx
errorValue
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
error
BodyStream
"
)
;
}
if
(
mStreamHolder
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
if
(
mInputStream
)
{
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
ReleaseObjects
(
)
;
}
void
BodyStream
:
:
EnqueueChunkWithSizeIntoStream
(
JSContext
*
aCx
ReadableStream
*
aStream
uint64_t
aAvailableData
ErrorResult
&
aRv
)
{
uint32_t
ableToRead
=
std
:
:
min
(
static_cast
<
uint64_t
>
(
256
*
1024
*
1024
)
aAvailableData
)
;
aRv
.
MightThrowJSException
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
chunk
(
aCx
JS_NewUint8Array
(
aCx
ableToRead
)
)
;
if
(
!
chunk
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
{
uint32_t
bytesWritten
=
0
;
WriteIntoReadRequestBuffer
(
aCx
aStream
chunk
ableToRead
&
bytesWritten
)
;
if
(
bytesWritten
=
=
0
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
(
ableToRead
-
bytesWritten
)
=
=
0
)
;
}
MOZ_ASSERT
(
aStream
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
chunkValue
(
aCx
)
;
chunkValue
.
setObject
(
*
chunk
)
;
aStream
-
>
EnqueueNative
(
aCx
chunkValue
aRv
)
;
}
NS_IMETHODIMP
BodyStream
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStream
)
;
mAsyncWaitWorkerRef
=
nullptr
;
if
(
IsClosed
(
)
)
{
return
NS_OK
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
mGlobal
"
fetch
body
data
available
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
ReadableStream
*
stream
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
!
stream
)
{
return
NS_ERROR_FAILURE
;
}
uint64_t
size
=
0
;
nsresult
rv
=
mInputStream
-
>
Available
(
&
size
)
;
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
rv
)
size
>
0
)
;
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
|
|
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
cx
stream
rv
)
;
return
NS_OK
;
}
if
(
!
mPullPromise
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mPullPromise
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Pending
)
;
ErrorResult
errorResult
;
EnqueueChunkWithSizeIntoStream
(
cx
stream
size
errorResult
)
;
errorResult
.
WouldReportJSException
(
)
;
if
(
errorResult
.
Failed
(
)
)
{
ErrorPropagation
(
cx
stream
errorResult
.
StealNSResult
(
)
)
;
return
NS_OK
;
}
MOZ_ASSERT_IF
(
!
mPullPromise
IsClosed
(
)
)
;
if
(
mPullPromise
)
{
mPullPromise
-
>
MaybeResolveWithUndefined
(
)
;
mPullPromise
=
nullptr
;
}
return
NS_OK
;
}
nsresult
BodyStream
:
:
RetrieveInputStream
(
BodyStreamHolder
*
aStream
nsIInputStream
*
*
aInputStream
)
{
MOZ_ASSERT
(
aStream
)
;
MOZ_ASSERT
(
aInputStream
)
;
BodyStream
*
stream
=
aStream
-
>
GetBodyStream
(
)
;
if
(
NS_WARN_IF
(
!
stream
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
NS_WARN_IF
(
!
stream
-
>
mOriginalInputStream
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
=
stream
-
>
mOriginalInputStream
;
inputStream
.
forget
(
aInputStream
)
;
return
NS_OK
;
}
void
BodyStream
:
:
Close
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
IsClosed
(
)
)
{
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
ReleaseObjects
(
)
;
return
;
}
ReadableStream
*
stream
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
stream
)
{
JSContext
*
cx
=
jsapi
.
cx
(
)
;
CloseAndReleaseObjects
(
cx
stream
)
;
}
else
{
ReleaseObjects
(
)
;
}
}
void
BodyStream
:
:
CloseAndReleaseObjects
(
JSContext
*
aCx
ReadableStream
*
aStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsClosed
(
)
)
;
ReleaseObjects
(
)
;
if
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
IgnoredErrorResult
rv
;
aStream
-
>
CloseNative
(
aCx
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
Close
Stream
"
)
;
}
}
void
BodyStream
:
:
ReleaseObjects
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
IsClosed
(
)
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
DOM_WINDOW_DESTROYED_TOPIC
)
;
}
}
mWorkerRef
=
nullptr
;
mGlobal
=
nullptr
;
mPullPromise
=
nullptr
;
RefPtr
<
BodyStream
>
self
=
mStreamHolder
-
>
TakeBodyStream
(
)
;
mStreamHolder
-
>
NullifyStream
(
)
;
mStreamHolder
=
nullptr
;
}
NS_IMETHODIMP
BodyStream
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
strcmp
(
aTopic
DOM_WINDOW_DESTROYED_TOPIC
)
=
=
0
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mGlobal
)
;
if
(
SameCOMIdentity
(
aSubject
window
)
)
{
Close
(
)
;
}
return
NS_OK
;
}
}
