#
include
"
BodyStream
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableByteStreamController
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
<
cstdint
>
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
BodyStreamHolder
)
if
(
tmp
-
>
mBodyStream
)
{
tmp
-
>
mBodyStream
-
>
ReleaseObjects
(
)
;
MOZ_ASSERT
(
!
tmp
-
>
mBodyStream
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
BodyStreamHolder
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
BodyStreamHolder
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
BodyStreamHolder
:
:
BodyStreamHolder
(
)
:
mBodyStream
(
nullptr
)
{
}
void
BodyStreamHolder
:
:
StoreBodyStream
(
BodyStream
*
aBodyStream
)
{
MOZ_ASSERT
(
aBodyStream
)
;
MOZ_ASSERT
(
!
mBodyStream
)
;
mBodyStream
=
aBodyStream
;
}
class
BodyStream
:
:
WorkerShutdown
final
:
public
WorkerControlRunnable
{
public
:
WorkerShutdown
(
WorkerPrivate
*
aWorkerPrivate
RefPtr
<
BodyStream
>
aStream
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mStream
(
aStream
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mStream
-
>
ReleaseObjects
(
)
;
return
true
;
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
private
:
RefPtr
<
BodyStream
>
mStream
;
}
;
NS_IMPL_ISUPPORTS
(
BodyStream
nsIInputStreamCallback
nsIObserver
nsISupportsWeakReference
)
void
BodyStream
:
:
Create
(
JSContext
*
aCx
BodyStreamHolder
*
aStreamHolder
nsIGlobalObject
*
aGlobal
nsIInputStream
*
aInputStream
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aCx
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStreamHolder
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
RefPtr
<
BodyStream
>
stream
=
new
BodyStream
(
aGlobal
aStreamHolder
aInputStream
)
;
auto
cleanup
=
MakeScopeExit
(
[
stream
]
{
stream
-
>
Close
(
)
;
}
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
os
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aRv
=
os
-
>
AddObserver
(
stream
DOM_WINDOW_DESTROYED_TOPIC
true
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
else
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
MOZ_ASSERT
(
workerPrivate
)
;
RefPtr
<
WeakWorkerRef
>
workerRef
=
WeakWorkerRef
:
:
Create
(
workerPrivate
[
stream
]
(
)
{
stream
-
>
Close
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
stream
-
>
mWorkerRef
=
std
:
:
move
(
workerRef
)
;
}
RefPtr
<
ReadableStream
>
body
=
ReadableStream
:
:
Create
(
aCx
aGlobal
aStreamHolder
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
cleanup
.
release
(
)
;
aStreamHolder
-
>
StoreBodyStream
(
stream
)
;
aStreamHolder
-
>
SetReadableStreamBody
(
body
)
;
#
ifdef
DEBUG
aStreamHolder
-
>
mStreamCreated
=
true
;
#
endif
}
already_AddRefed
<
Promise
>
BodyStream
:
:
PullCallback
(
JSContext
*
aCx
ReadableStreamController
&
aController
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aController
.
IsByte
(
)
)
;
ReadableStream
*
stream
=
aController
.
AsByte
(
)
-
>
Stream
(
)
;
MOZ_ASSERT
(
stream
)
;
#
if
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
Disturbed
(
)
)
;
#
endif
AssertIsOnOwningThread
(
)
;
MutexSingleWriterAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eInitializing
|
|
mState
=
=
eWaiting
|
|
mState
=
=
eChecking
|
|
mState
=
=
eReading
)
;
RefPtr
<
Promise
>
resolvedWithUndefinedPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
aController
.
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mState
=
=
eReading
)
{
return
resolvedWithUndefinedPromise
.
forget
(
)
;
}
if
(
mState
=
=
eChecking
)
{
MOZ_ASSERT
(
mInputStream
)
;
mState
=
eReading
;
return
resolvedWithUndefinedPromise
.
forget
(
)
;
}
if
(
mState
=
=
eInitializing
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
mState
=
eReading
;
if
(
!
mInputStream
)
{
MOZ_ASSERT
(
mOriginalInputStream
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
;
nsresult
rv
=
NS_MakeAsyncNonBlockingInputStream
(
mOriginalInputStream
.
forget
(
)
getter_AddRefs
(
asyncStream
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
stream
rv
)
;
return
nullptr
;
}
mInputStream
=
asyncStream
;
mOriginalInputStream
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mOriginalInputStream
)
;
nsresult
rv
=
mInputStream
-
>
AsyncWait
(
this
0
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
stream
rv
)
;
return
nullptr
;
}
return
resolvedWithUndefinedPromise
.
forget
(
)
;
}
void
BodyStream
:
:
WriteIntoReadRequestBuffer
(
JSContext
*
aCx
ReadableStream
*
aStream
JS
:
:
Handle
<
JSObject
*
>
aChunk
uint32_t
aLength
uint32_t
*
aByteWritten
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aChunk
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aByteWritten
)
;
AssertIsOnOwningThread
(
)
;
MutexSingleWriterAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eWriting
)
;
mState
=
eChecking
;
uint32_t
written
;
nsresult
rv
;
void
*
buffer
;
{
JS
:
:
AutoSuppressGCAnalysis
suppress
;
JS
:
:
AutoCheckCannotGC
noGC
;
bool
isSharedMemory
;
buffer
=
JS_GetArrayBufferViewData
(
aChunk
&
isSharedMemory
noGC
)
;
MOZ_ASSERT
(
!
isSharedMemory
)
;
rv
=
mInputStream
-
>
Read
(
static_cast
<
char
*
>
(
buffer
)
aLength
&
written
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
aStream
rv
)
;
return
;
}
}
*
aByteWritten
=
written
;
if
(
written
=
=
0
)
{
CloseAndReleaseObjects
(
aCx
lock
aStream
)
;
return
;
}
rv
=
mInputStream
-
>
AsyncWait
(
this
0
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
aStream
rv
)
;
return
;
}
}
already_AddRefed
<
Promise
>
BodyStream
:
:
CancelCallback
(
JSContext
*
aCx
const
Optional
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
&
aReason
ErrorResult
&
aRv
)
{
mMutex
.
AssertOnWritingThread
(
)
;
if
(
mState
=
=
eInitializing
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
if
(
mInputStream
)
{
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
if
(
mOriginalInputStream
)
{
MOZ_ASSERT
(
!
mInputStream
)
;
mOriginalInputStream
-
>
Close
(
)
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateResolvedWithUndefined
(
mGlobal
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
ReleaseObjects
(
)
;
return
promise
.
forget
(
)
;
}
void
BodyStream
:
:
ErrorCallback
(
)
{
mMutex
.
AssertOnWritingThread
(
)
;
if
(
mState
=
=
eInitializing
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
if
(
mInputStream
)
{
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
ReleaseObjects
(
)
;
}
BodyStream
:
:
BodyStream
(
nsIGlobalObject
*
aGlobal
BodyStreamHolder
*
aStreamHolder
nsIInputStream
*
aInputStream
)
:
mMutex
(
"
BodyStream
:
:
mMutex
"
this
)
mState
(
eInitializing
)
mGlobal
(
aGlobal
)
mStreamHolder
(
aStreamHolder
)
mOwningEventTarget
(
aGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
mOriginalInputStream
(
aInputStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStreamHolder
)
;
}
void
BodyStream
:
:
ErrorPropagation
(
JSContext
*
aCx
const
MutexSingleWriterAutoLock
&
aProofOfLock
ReadableStream
*
aStream
nsresult
aError
)
{
mMutex
.
AssertOnWritingThread
(
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mState
=
=
eClosed
)
{
return
;
}
if
(
aError
=
=
NS_BASE_STREAM_CLOSED
)
{
CloseAndReleaseObjects
(
aCx
aProofOfLock
aStream
)
;
return
;
}
ErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Error
in
body
stream
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
errorValue
(
aCx
)
;
bool
ok
=
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
errorValue
)
;
MOZ_RELEASE_ASSERT
(
ok
"
ToJSValue
never
fails
for
ErrorResult
"
)
;
{
MutexSingleWriterAutoUnlock
unlock
(
mMutex
)
;
if
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
IgnoredErrorResult
rv
;
ReadableStreamError
(
aCx
aStream
errorValue
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
error
BodyStream
"
)
;
}
}
ReleaseObjects
(
aProofOfLock
)
;
}
void
BodyStream
:
:
EnqueueChunkWithSizeIntoStream
(
JSContext
*
aCx
ReadableStream
*
aStream
uint64_t
aAvailableData
ErrorResult
&
aRv
)
{
uint32_t
ableToRead
=
std
:
:
min
(
static_cast
<
uint64_t
>
(
256
*
1024
*
1024
)
aAvailableData
)
;
aRv
.
MightThrowJSException
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
chunk
(
aCx
JS_NewUint8Array
(
aCx
ableToRead
)
)
;
if
(
!
chunk
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
{
uint32_t
bytesWritten
=
0
;
WriteIntoReadRequestBuffer
(
aCx
aStream
chunk
ableToRead
&
bytesWritten
)
;
if
(
bytesWritten
=
=
0
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
(
ableToRead
-
bytesWritten
)
=
=
0
)
;
}
MOZ_ASSERT
(
aStream
-
>
Controller
(
)
-
>
IsByte
(
)
)
;
RefPtr
<
ReadableByteStreamController
>
byteStreamController
=
aStream
-
>
Controller
(
)
-
>
AsByte
(
)
;
ReadableByteStreamControllerEnqueue
(
aCx
byteStreamController
chunk
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
NS_IMETHODIMP
BodyStream
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
NO_THREAD_SAFETY_ANALYSIS
{
AssertIsOnOwningThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStream
)
;
Maybe
<
MutexSingleWriterAutoLock
>
lock
;
lock
.
emplace
(
mMutex
)
;
if
(
mState
=
=
eClosed
)
{
return
NS_OK
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
mGlobal
"
fetch
body
data
available
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eReading
|
|
mState
=
=
eChecking
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
ReadableStream
*
stream
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
!
stream
)
{
return
NS_ERROR_FAILURE
;
}
uint64_t
size
=
0
;
nsresult
rv
=
mInputStream
-
>
Available
(
&
size
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
size
=
=
0
)
{
rv
=
NS_BASE_STREAM_CLOSED
;
}
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
|
|
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
cx
*
lock
stream
rv
)
;
return
NS_OK
;
}
if
(
mState
=
=
eChecking
)
{
mState
=
eWaiting
;
return
NS_OK
;
}
mState
=
eWriting
;
lock
.
reset
(
)
;
ErrorResult
errorResult
;
EnqueueChunkWithSizeIntoStream
(
cx
stream
size
errorResult
)
;
errorResult
.
WouldReportJSException
(
)
;
if
(
errorResult
.
Failed
(
)
)
{
lock
.
emplace
(
mMutex
)
;
ErrorPropagation
(
cx
*
lock
stream
errorResult
.
StealNSResult
(
)
)
;
return
NS_OK
;
}
return
NS_OK
;
}
nsresult
BodyStream
:
:
RetrieveInputStream
(
BodyStreamHolder
*
aStream
nsIInputStream
*
*
aInputStream
)
{
MOZ_ASSERT
(
aStream
)
;
MOZ_ASSERT
(
aInputStream
)
;
BodyStream
*
stream
=
aStream
-
>
GetBodyStream
(
)
;
if
(
NS_WARN_IF
(
!
stream
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
stream
-
>
AssertIsOnOwningThread
(
)
;
if
(
NS_WARN_IF
(
!
stream
-
>
mOriginalInputStream
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
=
stream
-
>
mOriginalInputStream
;
inputStream
.
forget
(
aInputStream
)
;
return
NS_OK
;
}
void
BodyStream
:
:
Close
(
)
{
AssertIsOnOwningThread
(
)
;
MutexSingleWriterAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eClosed
)
{
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
ReleaseObjects
(
lock
)
;
return
;
}
ReadableStream
*
stream
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
stream
)
{
JSContext
*
cx
=
jsapi
.
cx
(
)
;
CloseAndReleaseObjects
(
cx
lock
stream
)
;
}
else
{
ReleaseObjects
(
lock
)
;
}
}
void
BodyStream
:
:
CloseAndReleaseObjects
(
JSContext
*
aCx
const
MutexSingleWriterAutoLock
&
aProofOfLock
ReadableStream
*
aStream
)
{
AssertIsOnOwningThread
(
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
!
=
eClosed
)
;
ReleaseObjects
(
aProofOfLock
)
;
MutexSingleWriterAutoUnlock
unlock
(
mMutex
)
;
if
(
aStream
-
>
State
(
)
=
=
ReadableStream
:
:
ReaderState
:
:
Readable
)
{
IgnoredErrorResult
rv
;
ReadableStreamClose
(
aCx
aStream
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
Failed
to
Close
Stream
"
)
;
}
}
void
BodyStream
:
:
ReleaseObjects
(
)
{
MutexSingleWriterAutoLock
lock
(
mMutex
)
;
ReleaseObjects
(
lock
)
;
}
void
BodyStream
:
:
ReleaseObjects
(
const
MutexSingleWriterAutoLock
&
aProofOfLock
)
{
if
(
mState
=
=
eClosed
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
&
&
!
IsCurrentThreadRunningWorker
(
)
)
{
if
(
mWorkerRef
)
{
RefPtr
<
WorkerShutdown
>
r
=
new
WorkerShutdown
(
mWorkerRef
-
>
GetUnsafePrivate
(
)
this
)
;
Unused
<
<
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
;
return
;
}
RefPtr
<
BodyStream
>
self
=
this
;
RefPtr
<
Runnable
>
r
=
NS_NewRunnableFunction
(
"
BodyStream
:
:
ReleaseObjects
"
[
self
]
(
)
{
self
-
>
ReleaseObjects
(
)
;
}
)
;
mOwningEventTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
;
}
AssertIsOnOwningThread
(
)
;
mState
=
eClosed
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
DOM_WINDOW_DESTROYED_TOPIC
)
;
}
}
ReadableStream
*
stream
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
stream
)
{
stream
-
>
ReleaseObjects
(
)
;
}
mWorkerRef
=
nullptr
;
mGlobal
=
nullptr
;
GetCurrentSerialEventTarget
(
)
-
>
Dispatch
(
NS_NewCancelableRunnableFunction
(
"
BodyStream
:
:
ReleaseObjects
"
[
streamHolder
=
RefPtr
{
mStreamHolder
-
>
TakeBodyStream
(
)
}
]
{
}
)
)
;
mStreamHolder
-
>
NullifyStream
(
)
;
mStreamHolder
=
nullptr
;
}
#
ifdef
DEBUG
void
BodyStream
:
:
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
BodyStream
)
;
}
#
endif
NS_IMETHODIMP
BodyStream
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
strcmp
(
aTopic
DOM_WINDOW_DESTROYED_TOPIC
)
=
=
0
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mGlobal
)
;
if
(
SameCOMIdentity
(
aSubject
window
)
)
{
Close
(
)
;
}
return
NS_OK
;
}
}
