#
include
"
BodyStream
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsStreamUtils
.
h
"
static
NS_DEFINE_CID
(
kStreamTransportServiceCID
NS_STREAMTRANSPORTSERVICE_CID
)
;
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
BodyStreamHolder
)
if
(
tmp
-
>
mBodyStream
)
{
tmp
-
>
mBodyStream
-
>
ReleaseObjects
(
)
;
MOZ_ASSERT
(
!
tmp
-
>
mBodyStream
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
BodyStreamHolder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
BodyStreamHolder
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
BodyStreamHolder
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
BodyStreamHolder
:
:
BodyStreamHolder
(
)
:
mBodyStream
(
nullptr
)
{
}
void
BodyStreamHolder
:
:
StoreBodyStream
(
BodyStream
*
aBodyStream
)
{
MOZ_ASSERT
(
aBodyStream
)
;
MOZ_ASSERT
(
!
mBodyStream
)
;
mBodyStream
=
aBodyStream
;
}
void
BodyStreamHolder
:
:
ForgetBodyStream
(
)
{
MOZ_ASSERT_IF
(
mStreamCreated
mBodyStream
)
;
mBodyStream
=
nullptr
;
}
class
BodyStream
:
:
WorkerShutdown
final
:
public
WorkerControlRunnable
{
public
:
WorkerShutdown
(
WorkerPrivate
*
aWorkerPrivate
RefPtr
<
BodyStream
>
aStream
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mStream
(
aStream
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mStream
-
>
ReleaseObjects
(
)
;
return
true
;
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
private
:
RefPtr
<
BodyStream
>
mStream
;
}
;
NS_IMPL_ISUPPORTS
(
BodyStream
nsIInputStreamCallback
nsIObserver
nsISupportsWeakReference
)
void
BodyStream
:
:
Create
(
JSContext
*
aCx
BodyStreamHolder
*
aStreamHolder
nsIGlobalObject
*
aGlobal
nsIInputStream
*
aInputStream
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aCx
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStreamHolder
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
RefPtr
<
BodyStream
>
stream
=
new
BodyStream
(
aGlobal
aStreamHolder
aInputStream
)
;
auto
cleanup
=
MakeScopeExit
(
[
stream
]
{
stream
-
>
Close
(
)
;
}
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
os
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aRv
=
os
-
>
AddObserver
(
stream
DOM_WINDOW_DESTROYED_TOPIC
true
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
else
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
MOZ_ASSERT
(
workerPrivate
)
;
RefPtr
<
WeakWorkerRef
>
workerRef
=
WeakWorkerRef
:
:
Create
(
workerPrivate
[
stream
]
(
)
{
stream
-
>
Close
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
stream
-
>
mWorkerRef
=
std
:
:
move
(
workerRef
)
;
}
aRv
.
MightThrowJSException
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
body
(
aCx
JS
:
:
NewReadableExternalSourceStreamObject
(
aCx
stream
aStreamHolder
)
)
;
if
(
!
body
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
NS_ADDREF
(
stream
.
get
(
)
)
;
cleanup
.
release
(
)
;
aStreamHolder
-
>
StoreBodyStream
(
stream
)
;
aStreamHolder
-
>
SetReadableStreamBody
(
body
)
;
#
ifdef
DEBUG
aStreamHolder
-
>
mStreamCreated
=
true
;
#
endif
}
void
BodyStream
:
:
requestData
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
size_t
aDesiredSize
)
{
#
if
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
disturbed
;
if
(
!
JS
:
:
ReadableStreamIsDisturbed
(
aCx
aStream
&
disturbed
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
disturbed
)
;
}
#
endif
AssertIsOnOwningThread
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eInitializing
|
|
mState
=
=
eWaiting
|
|
mState
=
=
eChecking
|
|
mState
=
=
eReading
)
;
if
(
mState
=
=
eReading
)
{
return
;
}
if
(
mState
=
=
eChecking
)
{
MOZ_ASSERT
(
mInputStream
)
;
mState
=
eReading
;
return
;
}
if
(
mState
=
=
eInitializing
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
mState
=
eReading
;
if
(
!
mInputStream
)
{
MOZ_ASSERT
(
mOriginalInputStream
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
;
nsresult
rv
=
NS_MakeAsyncNonBlockingInputStream
(
mOriginalInputStream
.
forget
(
)
getter_AddRefs
(
asyncStream
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
aStream
rv
)
;
return
;
}
mInputStream
=
asyncStream
;
mOriginalInputStream
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mOriginalInputStream
)
;
nsresult
rv
=
mInputStream
-
>
AsyncWait
(
this
0
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
aStream
rv
)
;
return
;
}
}
void
BodyStream
:
:
writeIntoReadRequestBuffer
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
void
*
aBuffer
size_t
aLength
size_t
*
aByteWritten
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aBuffer
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aByteWritten
)
;
AssertIsOnOwningThread
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eWriting
)
;
mState
=
eChecking
;
uint32_t
written
;
nsresult
rv
=
mInputStream
-
>
Read
(
static_cast
<
char
*
>
(
aBuffer
)
aLength
&
written
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
aStream
rv
)
;
return
;
}
*
aByteWritten
=
written
;
if
(
written
=
=
0
)
{
CloseAndReleaseObjects
(
aCx
lock
aStream
)
;
return
;
}
rv
=
mInputStream
-
>
AsyncWait
(
this
0
0
mOwningEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
aCx
lock
aStream
rv
)
;
return
;
}
}
JS
:
:
Value
BodyStream
:
:
cancel
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
JS
:
:
HandleValue
aReason
)
{
AssertIsOnOwningThread
(
)
;
if
(
mState
=
=
eInitializing
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
if
(
mInputStream
)
{
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
if
(
mOriginalInputStream
)
{
MOZ_ASSERT
(
!
mInputStream
)
;
mOriginalInputStream
-
>
Close
(
)
;
}
ReleaseObjects
(
)
;
return
JS
:
:
UndefinedValue
(
)
;
}
void
BodyStream
:
:
onClosed
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
)
{
}
void
BodyStream
:
:
onErrored
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
JS
:
:
HandleValue
aReason
)
{
AssertIsOnOwningThread
(
)
;
if
(
mState
=
=
eInitializing
)
{
mStreamHolder
-
>
MarkAsRead
(
)
;
}
if
(
mInputStream
)
{
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
ReleaseObjects
(
)
;
}
void
BodyStream
:
:
finalize
(
)
{
RefPtr
<
BodyStream
>
stream
=
dont_AddRef
(
this
)
;
stream
-
>
ReleaseObjects
(
)
;
}
BodyStream
:
:
BodyStream
(
nsIGlobalObject
*
aGlobal
BodyStreamHolder
*
aStreamHolder
nsIInputStream
*
aInputStream
)
:
mMutex
(
"
BodyStream
:
:
mMutex
"
)
mState
(
eInitializing
)
mGlobal
(
aGlobal
)
mStreamHolder
(
aStreamHolder
)
mOwningEventTarget
(
aGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
mOriginalInputStream
(
aInputStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStreamHolder
)
;
}
BodyStream
:
:
~
BodyStream
(
)
=
default
;
void
BodyStream
:
:
ErrorPropagation
(
JSContext
*
aCx
const
MutexAutoLock
&
aProofOfLock
JS
:
:
HandleObject
aStream
nsresult
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
mState
=
=
eClosed
)
{
return
;
}
if
(
aError
=
=
NS_BASE_STREAM_CLOSED
)
{
CloseAndReleaseObjects
(
aCx
aProofOfLock
aStream
)
;
return
;
}
ErrorResult
rv
;
rv
.
ThrowTypeError
(
u
"
Error
in
body
stream
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
errorValue
(
aCx
)
;
bool
ok
=
ToJSValue
(
aCx
std
:
:
move
(
rv
)
&
errorValue
)
;
MOZ_RELEASE_ASSERT
(
ok
"
ToJSValue
never
fails
for
ErrorResult
"
)
;
{
MutexAutoUnlock
unlock
(
mMutex
)
;
JS
:
:
ReadableStreamError
(
aCx
aStream
errorValue
)
;
}
ReleaseObjects
(
aProofOfLock
)
;
}
NS_IMETHODIMP
BodyStream
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
AssertIsOnOwningThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aStream
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eClosed
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eReading
|
|
mState
=
=
eChecking
)
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSObject
*
streamObj
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
!
streamObj
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
stream
(
cx
streamObj
)
;
uint64_t
size
=
0
;
nsresult
rv
=
mInputStream
-
>
Available
(
&
size
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
size
=
=
0
)
{
rv
=
NS_BASE_STREAM_CLOSED
;
}
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
|
|
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
cx
lock
stream
rv
)
;
return
NS_OK
;
}
if
(
mState
=
=
eChecking
)
{
mState
=
eWaiting
;
return
NS_OK
;
}
mState
=
eWriting
;
{
MutexAutoUnlock
unlock
(
mMutex
)
;
DebugOnly
<
bool
>
ok
=
JS
:
:
ReadableStreamUpdateDataAvailableFromSource
(
cx
stream
size
)
;
MOZ_ASSERT_IF
(
ok
mState
=
=
eChecking
)
;
}
return
NS_OK
;
}
nsresult
BodyStream
:
:
RetrieveInputStream
(
JS
:
:
ReadableStreamUnderlyingSource
*
aUnderlyingReadableStreamSource
nsIInputStream
*
*
aInputStream
)
{
MOZ_ASSERT
(
aUnderlyingReadableStreamSource
)
;
MOZ_ASSERT
(
aInputStream
)
;
RefPtr
<
BodyStream
>
stream
=
static_cast
<
BodyStream
*
>
(
aUnderlyingReadableStreamSource
)
;
stream
-
>
AssertIsOnOwningThread
(
)
;
if
(
NS_WARN_IF
(
!
stream
-
>
mOriginalInputStream
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
=
stream
-
>
mOriginalInputStream
;
inputStream
.
forget
(
aInputStream
)
;
return
NS_OK
;
}
void
BodyStream
:
:
Close
(
)
{
AssertIsOnOwningThread
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
mState
=
=
eClosed
)
{
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
ReleaseObjects
(
lock
)
;
return
;
}
JSObject
*
streamObj
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
streamObj
)
{
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
stream
(
cx
streamObj
)
;
CloseAndReleaseObjects
(
cx
lock
stream
)
;
}
else
{
ReleaseObjects
(
lock
)
;
}
}
void
BodyStream
:
:
CloseAndReleaseObjects
(
JSContext
*
aCx
const
MutexAutoLock
&
aProofOfLock
JS
:
:
HandleObject
aStream
)
{
AssertIsOnOwningThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
!
=
eClosed
)
;
ReleaseObjects
(
aProofOfLock
)
;
MutexAutoUnlock
unlock
(
mMutex
)
;
bool
readable
;
if
(
!
JS
:
:
ReadableStreamIsReadable
(
aCx
aStream
&
readable
)
)
{
return
;
}
if
(
readable
)
{
JS
:
:
ReadableStreamClose
(
aCx
aStream
)
;
}
}
void
BodyStream
:
:
ReleaseObjects
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
ReleaseObjects
(
lock
)
;
}
void
BodyStream
:
:
ReleaseObjects
(
const
MutexAutoLock
&
aProofOfLock
)
{
if
(
mState
=
=
eClosed
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
&
&
!
IsCurrentThreadRunningWorker
(
)
)
{
if
(
mWorkerRef
)
{
RefPtr
<
WorkerShutdown
>
r
=
new
WorkerShutdown
(
mWorkerRef
-
>
GetUnsafePrivate
(
)
this
)
;
Unused
<
<
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
;
return
;
}
RefPtr
<
BodyStream
>
self
=
this
;
RefPtr
<
Runnable
>
r
=
NS_NewRunnableFunction
(
"
BodyStream
:
:
ReleaseObjects
"
[
self
]
(
)
{
self
-
>
ReleaseObjects
(
)
;
}
)
;
mOwningEventTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
return
;
}
AssertIsOnOwningThread
(
)
;
mState
=
eClosed
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
DOM_WINDOW_DESTROYED_TOPIC
)
;
}
}
JSObject
*
streamObj
=
mStreamHolder
-
>
GetReadableStreamBody
(
)
;
if
(
streamObj
)
{
JS
:
:
ReadableStreamReleaseCCObject
(
streamObj
)
;
}
mWorkerRef
=
nullptr
;
mGlobal
=
nullptr
;
mStreamHolder
-
>
ForgetBodyStream
(
)
;
mStreamHolder
-
>
NullifyStream
(
)
;
mStreamHolder
=
nullptr
;
}
#
ifdef
DEBUG
void
BodyStream
:
:
AssertIsOnOwningThread
(
)
{
NS_ASSERT_OWNINGTHREAD
(
BodyStream
)
;
}
#
endif
NS_IMETHODIMP
BodyStream
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
strcmp
(
aTopic
DOM_WINDOW_DESTROYED_TOPIC
)
=
=
0
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mGlobal
)
;
if
(
SameCOMIdentity
(
aSubject
window
)
)
{
Close
(
)
;
}
return
NS_OK
;
}
}
}
