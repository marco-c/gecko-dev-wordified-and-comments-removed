#
ifndef
mozilla_dom_Element_h__
#
define
mozilla_dom_Element_h__
#
include
<
cstdio
>
#
include
<
cstdint
>
#
include
<
cstdlib
>
#
include
<
utility
>
#
include
"
AttrArray
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
Units
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PseudoStyleType
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
RustCell
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
BorrowedAttrInfo
.
h
"
#
include
"
mozilla
/
dom
/
DOMString
.
h
"
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
mozilla
/
dom
/
FragmentOrElement
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
RustTypes
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRootBinding
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsTLiteralString
.
h
"
#
include
"
nscore
.
h
"
class
JSObject
;
class
mozAutoDocUpdate
;
class
nsAttrName
;
class
nsAttrValueOrString
;
class
nsContentList
;
class
nsDOMAttributeMap
;
class
nsDOMCSSAttributeDeclaration
;
class
nsDOMStringMap
;
class
nsDOMTokenList
;
class
nsFocusManager
;
class
nsGlobalWindowInner
;
class
nsGlobalWindowOuter
;
class
nsIAutoCompletePopup
;
class
nsIBrowser
;
class
nsIDOMXULButtonElement
;
class
nsIDOMXULContainerElement
;
class
nsIDOMXULContainerItemElement
;
class
nsIDOMXULControlElement
;
class
nsIDOMXULMenuListElement
;
class
nsIDOMXULMultiSelectControlElement
;
class
nsIDOMXULRadioGroupElement
;
class
nsIDOMXULRelatedElement
;
class
nsIDOMXULSelectControlElement
;
class
nsIDOMXULSelectControlItemElement
;
class
nsIFrame
;
class
nsIHTMLCollection
;
class
nsIMozBrowserFrame
;
class
nsIPrincipal
;
class
nsIScrollableFrame
;
class
nsIURI
;
class
nsMappedAttributes
;
class
nsPresContext
;
class
nsWindowSizes
;
struct
JSContext
;
struct
ServoNodeData
;
template
<
class
E
>
class
nsTArray
;
template
<
class
T
>
class
nsGetterAddRefs
;
namespace
mozilla
{
class
DeclarationBlock
;
class
ErrorResult
;
class
OOMReporter
;
class
SMILAttr
;
struct
MutationClosureData
;
class
TextEditor
;
namespace
css
{
struct
URLValue
;
}
namespace
dom
{
struct
CheckVisibilityOptions
;
struct
CustomElementData
;
struct
SetHTMLOptions
;
struct
GetAnimationsOptions
;
struct
ScrollIntoViewOptions
;
struct
ScrollToOptions
;
struct
FocusOptions
;
struct
ShadowRootInit
;
struct
ScrollOptions
;
class
Attr
;
class
BooleanOrScrollIntoViewOptions
;
class
Document
;
class
DOMIntersectionObserver
;
class
DOMMatrixReadOnly
;
class
Element
;
class
ElementOrCSSPseudoElement
;
class
Promise
;
class
Sanitizer
;
class
ShadowRoot
;
class
UnrestrictedDoubleOrKeyframeAnimationOptions
;
template
<
typename
T
>
class
Optional
;
enum
class
CallerType
:
uint32_t
;
enum
class
ReferrerPolicy
:
uint8_t
;
typedef
nsTHashMap
<
nsRefPtrHashKey
<
DOMIntersectionObserver
>
int32_t
>
IntersectionObserverList
;
}
}
extern
"
C
"
bool
Servo_Element_IsDisplayContents
(
const
mozilla
:
:
dom
:
:
Element
*
)
;
already_AddRefed
<
nsContentList
>
NS_GetContentList
(
nsINode
*
aRootNode
int32_t
aMatchNameSpaceId
const
nsAString
&
aTagname
)
;
#
define
ELEMENT_FLAG_BIT
(
n_
)
\
NODE_FLAG_BIT
(
NODE_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
=
ELEMENT_FLAG_BIT
(
0
)
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
=
ELEMENT_FLAG_BIT
(
1
)
ELEMENT_HAS_SNAPSHOT
=
ELEMENT_FLAG_BIT
(
2
)
ELEMENT_HANDLED_SNAPSHOT
=
ELEMENT_FLAG_BIT
(
3
)
ELEMENT_IS_DATALIST_OR_HAS_DATALIST_ANCESTOR
=
ELEMENT_FLAG_BIT
(
4
)
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
=
NODE_TYPE_SPECIFIC_BITS_OFFSET
+
5
}
;
#
undef
ELEMENT_FLAG_BIT
ASSERT_NODE_FLAGS_SPACE
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
)
;
namespace
mozilla
{
enum
class
PseudoStyleType
:
uint8_t
;
class
EventChainPostVisitor
;
class
EventChainPreVisitor
;
class
EventChainVisitor
;
class
EventListenerManager
;
class
EventStateManager
;
namespace
dom
{
struct
CustomElementDefinition
;
class
Animation
;
class
CustomElementRegistry
;
class
Link
;
class
DOMRect
;
class
DOMRectList
;
class
Flex
;
class
Grid
;
#
define
NS_ELEMENT_IID
\
{
\
0xc67ed254
0xfd3b
0x4b10
{
\
0x96
0xa2
0xc5
0x8b
0x7b
0x64
0x97
0xd1
\
}
\
}
#
define
REFLECT_DOMSTRING_ATTR
(
method
attr
)
\
void
Get
#
#
method
(
nsAString
&
aValue
)
const
{
\
GetAttr
(
nsGkAtoms
:
:
attr
aValue
)
;
\
}
\
void
Set
#
#
method
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
\
SetAttr
(
nsGkAtoms
:
:
attr
aValue
aRv
)
;
\
}
class
Element
:
public
FragmentOrElement
{
public
:
#
ifdef
MOZILLA_INTERNAL_API
explicit
Element
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
FragmentOrElement
(
std
:
:
move
(
aNodeInfo
)
)
mState
(
ElementState
:
:
READONLY
|
ElementState
:
:
DEFINED
)
{
MOZ_ASSERT
(
mNodeInfo
-
>
NodeType
(
)
=
=
ELEMENT_NODE
"
Bad
NodeType
in
aNodeInfo
"
)
;
SetIsElement
(
)
;
}
~
Element
(
)
{
NS_ASSERTION
(
!
HasServoData
(
)
"
expected
ServoData
to
be
cleared
earlier
"
)
;
}
#
endif
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_ELEMENT_IID
)
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
NS_IMPL_FROMNODE_HELPER
(
Element
IsElement
(
)
)
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
;
ElementState
State
(
)
const
{
return
mState
;
}
void
UpdateState
(
bool
aNotify
)
;
void
UpdateLinkState
(
ElementState
aState
)
;
bool
IsDisabled
(
)
const
{
return
State
(
)
.
HasState
(
ElementState
:
:
DISABLED
)
;
}
virtual
int32_t
TabIndexDefault
(
)
{
return
-
1
;
}
int32_t
TabIndex
(
)
;
Maybe
<
int32_t
>
GetTabIndexAttrValue
(
)
;
void
SetTabIndex
(
int32_t
aTabIndex
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetShadowRoot
(
ShadowRoot
*
aShadowRoot
)
;
void
SetLastRememberedBSize
(
float
aBSize
)
;
void
SetLastRememberedISize
(
float
aISize
)
;
void
RemoveLastRememberedBSize
(
)
;
void
RemoveLastRememberedISize
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
Focus
(
const
FocusOptions
&
aOptions
const
CallerType
aCallerType
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
Blur
(
mozilla
:
:
ErrorResult
&
aError
)
;
ElementState
StyleState
(
)
const
{
if
(
!
HasLockedStyleStates
(
)
)
{
return
mState
;
}
return
StyleStateFromLocks
(
)
;
}
struct
StyleStateLocks
{
ElementState
mLocks
;
ElementState
mValues
;
}
;
StyleStateLocks
LockedStyleStates
(
)
const
;
void
LockStyleStates
(
ElementState
aStates
bool
aEnabled
)
;
void
UnlockStyleStates
(
ElementState
aStates
)
;
void
ClearStyleStateLocks
(
)
;
bool
HasDirAuto
(
)
const
{
return
State
(
)
.
HasState
(
ElementState
:
:
HAS_DIR_ATTR_LIKE_AUTO
)
;
}
bool
HasFixedDir
(
)
const
{
return
State
(
)
.
HasAtLeastOneOfStates
(
ElementState
:
:
HAS_DIR_ATTR_LTR
|
ElementState
:
:
HAS_DIR_ATTR_RTL
)
;
}
DeclarationBlock
*
GetInlineStyleDeclaration
(
)
const
;
const
nsMappedAttributes
*
GetMappedAttributes
(
)
const
;
void
ClearMappedServoStyle
(
)
{
mAttrs
.
ClearMappedServoStyle
(
)
;
}
virtual
void
InlineStyleDeclarationWillChange
(
MutationClosureData
&
aData
)
;
virtual
nsresult
SetInlineStyleDeclaration
(
DeclarationBlock
&
aDeclaration
MutationClosureData
&
aData
)
;
DeclarationBlock
*
GetSMILOverrideStyleDeclaration
(
)
;
void
SetSMILOverrideStyleDeclaration
(
DeclarationBlock
&
)
;
virtual
UniquePtr
<
SMILAttr
>
GetAnimatedAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
)
;
nsDOMCSSAttributeDeclaration
*
SMILOverrideStyle
(
)
;
virtual
bool
IsLabelable
(
)
const
;
virtual
bool
IsInteractiveHTMLContent
(
)
const
;
virtual
nsIMozBrowserFrame
*
GetAsMozBrowserFrame
(
)
{
return
nullptr
;
}
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
;
virtual
nsChangeHint
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
;
inline
Directionality
GetDirectionality
(
)
const
{
if
(
HasFlag
(
NODE_HAS_DIRECTION_RTL
)
)
{
return
eDir_RTL
;
}
if
(
HasFlag
(
NODE_HAS_DIRECTION_LTR
)
)
{
return
eDir_LTR
;
}
return
eDir_NotSet
;
}
inline
void
SetDirectionality
(
Directionality
aDir
bool
aNotify
)
{
UnsetFlags
(
NODE_ALL_DIRECTION_FLAGS
)
;
if
(
!
aNotify
)
{
RemoveStatesSilently
(
ElementState
:
:
DIR_STATES
)
;
}
switch
(
aDir
)
{
case
(
eDir_RTL
)
:
SetFlags
(
NODE_HAS_DIRECTION_RTL
)
;
if
(
!
aNotify
)
{
AddStatesSilently
(
ElementState
:
:
RTL
)
;
}
break
;
case
(
eDir_LTR
)
:
SetFlags
(
NODE_HAS_DIRECTION_LTR
)
;
if
(
!
aNotify
)
{
AddStatesSilently
(
ElementState
:
:
LTR
)
;
}
break
;
default
:
break
;
}
if
(
aNotify
)
{
UpdateState
(
true
)
;
}
}
Directionality
GetComputedDirectionality
(
)
const
;
static
const
uint32_t
kAllServoDescendantBits
=
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
|
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
|
NODE_DESCENDANTS_NEED_FRAMES
;
void
NoteDirtySubtreeForServo
(
)
;
void
NoteDirtyForServo
(
)
;
void
NoteAnimationOnlyDirtyForServo
(
)
;
void
NoteDescendantsNeedFramesForServo
(
)
;
bool
HasDirtyDescendantsForServo
(
)
const
{
return
HasFlag
(
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
SetHasDirtyDescendantsForServo
(
)
{
SetFlags
(
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
UnsetHasDirtyDescendantsForServo
(
)
{
UnsetFlags
(
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
bool
HasAnimationOnlyDirtyDescendantsForServo
(
)
const
{
return
HasFlag
(
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
SetHasAnimationOnlyDirtyDescendantsForServo
(
)
{
SetFlags
(
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
UnsetHasAnimationOnlyDirtyDescendantsForServo
(
)
{
UnsetFlags
(
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
bool
HasServoData
(
)
const
{
return
!
!
mServoData
.
Get
(
)
;
}
void
ClearServoData
(
)
{
ClearServoData
(
GetComposedDoc
(
)
)
;
}
void
ClearServoData
(
Document
*
aDocument
)
;
inline
CustomElementData
*
GetCustomElementData
(
)
const
{
if
(
!
HasCustomElementData
(
)
)
{
return
nullptr
;
}
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mCustomElementData
.
get
(
)
:
nullptr
;
}
void
SetCustomElementData
(
UniquePtr
<
CustomElementData
>
aData
)
;
CustomElementDefinition
*
GetCustomElementDefinition
(
)
const
;
virtual
void
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
;
void
SetDefined
(
bool
aSet
)
{
if
(
aSet
)
{
AddStates
(
ElementState
:
:
DEFINED
)
;
}
else
{
RemoveStates
(
ElementState
:
:
DEFINED
)
;
}
}
REFLECT_DOMSTRING_ATTR
(
Role
role
)
REFLECT_DOMSTRING_ATTR
(
AriaAtomic
aria_atomic
)
REFLECT_DOMSTRING_ATTR
(
AriaAutoComplete
aria_autocomplete
)
REFLECT_DOMSTRING_ATTR
(
AriaBusy
aria_busy
)
REFLECT_DOMSTRING_ATTR
(
AriaChecked
aria_checked
)
REFLECT_DOMSTRING_ATTR
(
AriaColCount
aria_colcount
)
REFLECT_DOMSTRING_ATTR
(
AriaColIndex
aria_colindex
)
REFLECT_DOMSTRING_ATTR
(
AriaColIndexText
aria_colindextext
)
REFLECT_DOMSTRING_ATTR
(
AriaColSpan
aria_colspan
)
REFLECT_DOMSTRING_ATTR
(
AriaCurrent
aria_current
)
REFLECT_DOMSTRING_ATTR
(
AriaDescription
aria_description
)
REFLECT_DOMSTRING_ATTR
(
AriaDisabled
aria_disabled
)
REFLECT_DOMSTRING_ATTR
(
AriaExpanded
aria_expanded
)
REFLECT_DOMSTRING_ATTR
(
AriaHasPopup
aria_haspopup
)
REFLECT_DOMSTRING_ATTR
(
AriaHidden
aria_hidden
)
REFLECT_DOMSTRING_ATTR
(
AriaInvalid
aria_invalid
)
REFLECT_DOMSTRING_ATTR
(
AriaKeyShortcuts
aria_keyshortcuts
)
REFLECT_DOMSTRING_ATTR
(
AriaLabel
aria_label
)
REFLECT_DOMSTRING_ATTR
(
AriaLevel
aria_level
)
REFLECT_DOMSTRING_ATTR
(
AriaLive
aria_live
)
REFLECT_DOMSTRING_ATTR
(
AriaModal
aria_modal
)
REFLECT_DOMSTRING_ATTR
(
AriaMultiLine
aria_multiline
)
REFLECT_DOMSTRING_ATTR
(
AriaMultiSelectable
aria_multiselectable
)
REFLECT_DOMSTRING_ATTR
(
AriaOrientation
aria_orientation
)
REFLECT_DOMSTRING_ATTR
(
AriaPlaceholder
aria_placeholder
)
REFLECT_DOMSTRING_ATTR
(
AriaPosInSet
aria_posinset
)
REFLECT_DOMSTRING_ATTR
(
AriaPressed
aria_pressed
)
REFLECT_DOMSTRING_ATTR
(
AriaReadOnly
aria_readonly
)
REFLECT_DOMSTRING_ATTR
(
AriaRelevant
aria_relevant
)
REFLECT_DOMSTRING_ATTR
(
AriaRequired
aria_required
)
REFLECT_DOMSTRING_ATTR
(
AriaRoleDescription
aria_roledescription
)
REFLECT_DOMSTRING_ATTR
(
AriaRowCount
aria_rowcount
)
REFLECT_DOMSTRING_ATTR
(
AriaRowIndex
aria_rowindex
)
REFLECT_DOMSTRING_ATTR
(
AriaRowIndexText
aria_rowindextext
)
REFLECT_DOMSTRING_ATTR
(
AriaRowSpan
aria_rowspan
)
REFLECT_DOMSTRING_ATTR
(
AriaSelected
aria_selected
)
REFLECT_DOMSTRING_ATTR
(
AriaSetSize
aria_setsize
)
REFLECT_DOMSTRING_ATTR
(
AriaSort
aria_sort
)
REFLECT_DOMSTRING_ATTR
(
AriaValueMax
aria_valuemax
)
REFLECT_DOMSTRING_ATTR
(
AriaValueMin
aria_valuemin
)
REFLECT_DOMSTRING_ATTR
(
AriaValueNow
aria_valuenow
)
REFLECT_DOMSTRING_ATTR
(
AriaValueText
aria_valuetext
)
protected
:
virtual
ElementState
IntrinsicState
(
)
const
;
void
AddStatesSilently
(
ElementState
aStates
)
{
mState
|
=
aStates
;
}
void
RemoveStatesSilently
(
ElementState
aStates
)
{
mState
&
=
~
aStates
;
}
already_AddRefed
<
ShadowRoot
>
AttachShadowInternal
(
ShadowRootMode
ErrorResult
&
aError
)
;
public
:
MOZ_CAN_RUN_SCRIPT
nsIScrollableFrame
*
GetScrollFrame
(
nsIFrame
*
*
aStyledFrame
=
nullptr
FlushType
aFlushType
=
FlushType
:
:
Layout
)
;
private
:
friend
class
mozilla
:
:
EventStateManager
;
friend
class
mozilla
:
:
dom
:
:
Document
;
friend
class
:
:
nsGlobalWindowInner
;
friend
class
:
:
nsGlobalWindowOuter
;
friend
class
:
:
nsFocusManager
;
friend
class
CustomElementRegistry
;
friend
class
Link
;
void
NotifyStateChange
(
ElementState
aStates
)
;
void
NotifyStyleStateChange
(
ElementState
aStates
)
;
ElementState
StyleStateFromLocks
(
)
const
;
protected
:
void
AddStates
(
ElementState
aStates
)
{
MOZ_ASSERT
(
!
aStates
.
HasAtLeastOneOfStates
(
ElementState
:
:
INTRINSIC_STATES
)
"
Should
only
be
adding
externally
-
managed
states
here
"
)
;
ElementState
old
=
mState
;
AddStatesSilently
(
aStates
)
;
NotifyStateChange
(
old
^
mState
)
;
}
void
RemoveStates
(
ElementState
aStates
)
{
MOZ_ASSERT
(
!
aStates
.
HasAtLeastOneOfStates
(
ElementState
:
:
INTRINSIC_STATES
)
"
Should
only
be
removing
externally
-
managed
states
here
"
)
;
ElementState
old
=
mState
;
RemoveStatesSilently
(
aStates
)
;
NotifyStateChange
(
old
^
mState
)
;
}
void
ToggleStates
(
ElementState
aStates
bool
aNotify
)
{
MOZ_ASSERT
(
!
aStates
.
HasAtLeastOneOfStates
(
ElementState
:
:
INTRINSIC_STATES
)
"
Should
only
be
removing
externally
-
managed
states
here
"
)
;
mState
^
=
aStates
;
if
(
aNotify
)
{
NotifyStateChange
(
aStates
)
;
}
}
public
:
void
AddManuallyManagedStates
(
ElementState
aStates
)
{
MOZ_ASSERT
(
ElementState
:
:
MANUALLY_MANAGED_STATES
.
HasAllStates
(
aStates
)
"
Should
only
be
adding
manually
-
managed
states
here
"
)
;
AddStates
(
aStates
)
;
}
void
RemoveManuallyManagedStates
(
ElementState
aStates
)
{
MOZ_ASSERT
(
ElementState
:
:
MANUALLY_MANAGED_STATES
.
HasAllStates
(
aStates
)
"
Should
only
be
removing
manually
-
managed
states
here
"
)
;
RemoveStates
(
aStates
)
;
}
void
UpdateEditableState
(
bool
aNotify
)
override
;
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
void
UnbindFromTree
(
bool
aNullParent
=
true
)
override
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
GetExistingAttrNameFromQName
(
const
nsAString
&
aStr
)
const
;
bool
MaybeCheckSameAttrVal
(
int32_t
aNamespaceID
const
nsAtom
*
aName
const
nsAtom
*
aPrefix
const
nsAttrValueOrString
&
aValue
bool
aNotify
nsAttrValue
&
aOldValue
uint8_t
*
aModType
bool
*
aHasListeners
bool
*
aOldValueSet
)
;
bool
OnlyNotifySameValueSet
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAttrValueOrString
&
aValue
bool
aNotify
nsAttrValue
&
aOldValue
uint8_t
*
aModType
bool
*
aHasListeners
bool
*
aOldValueSet
)
;
nsresult
SetSingleClassFromParser
(
nsAtom
*
aSingleClassName
)
;
nsresult
SetParsedAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
nsAtom
*
aPrefix
nsAttrValue
&
aParsedValue
bool
aNotify
)
;
bool
GetAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
nsAString
&
aResult
)
const
;
bool
GetAttr
(
const
nsAtom
*
aName
nsAString
&
aResult
)
const
{
return
GetAttr
(
kNameSpaceID_None
aName
aResult
)
;
}
inline
bool
HasAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
;
bool
HasAttr
(
const
nsAtom
*
aAttr
)
const
{
return
HasAttr
(
kNameSpaceID_None
aAttr
)
;
}
inline
bool
HasNonEmptyAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
;
bool
HasNonEmptyAttr
(
const
nsAtom
*
aAttr
)
const
{
return
HasNonEmptyAttr
(
kNameSpaceID_None
aAttr
)
;
}
inline
bool
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAString
&
aValue
nsCaseTreatment
aCaseSensitive
)
const
;
bool
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAtom
*
aValue
nsCaseTreatment
aCaseSensitive
)
const
;
enum
{
ATTR_MISSING
=
-
1
ATTR_VALUE_NO_MATCH
=
-
2
}
;
typedef
nsStaticAtom
*
const
AttrValuesArray
;
int32_t
FindAttrValueIn
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
AttrValuesArray
*
aValues
nsCaseTreatment
aCaseSensitive
)
const
;
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAString
&
aValue
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
nullptr
aValue
aNotify
)
;
}
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAString
&
aValue
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
aPrefix
aValue
nullptr
aNotify
)
;
}
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
nullptr
aValue
aTriggeringPrincipal
aNotify
)
;
}
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
;
nsresult
UnsetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
bool
aNotify
)
;
const
nsAttrName
*
GetAttrNameAt
(
uint32_t
aIndex
)
const
{
return
mAttrs
.
GetSafeAttrNameAt
(
aIndex
)
;
}
const
nsAttrName
*
GetUnsafeAttrNameAt
(
uint32_t
aIndex
)
const
{
return
mAttrs
.
AttrNameAt
(
aIndex
)
;
}
BorrowedAttrInfo
GetAttrInfoAt
(
uint32_t
aIndex
)
const
{
if
(
aIndex
>
=
mAttrs
.
AttrCount
(
)
)
{
return
BorrowedAttrInfo
(
nullptr
nullptr
)
;
}
return
mAttrs
.
AttrInfoAt
(
aIndex
)
;
}
uint32_t
GetAttrCount
(
)
const
{
return
mAttrs
.
AttrCount
(
)
;
}
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
const
nsAttrValue
*
GetClasses
(
)
const
{
if
(
!
MayHaveClass
(
)
)
{
return
nullptr
;
}
if
(
IsSVGElement
(
)
)
{
if
(
const
nsAttrValue
*
value
=
GetSVGAnimatedClass
(
)
)
{
return
value
;
}
}
return
GetParsedAttr
(
nsGkAtoms
:
:
_class
)
;
}
#
ifdef
MOZ_DOM_LIST
virtual
void
List
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
)
const
override
{
List
(
out
aIndent
"
"
_ns
)
;
}
virtual
void
DumpContent
(
FILE
*
out
int32_t
aIndent
bool
aDumpAll
)
const
override
;
void
List
(
FILE
*
out
int32_t
aIndent
const
nsCString
&
aPrefix
)
const
;
void
ListAttributes
(
FILE
*
out
)
const
;
#
endif
void
Describe
(
nsAString
&
aOutDescription
bool
aShort
=
false
)
const
;
struct
MappedAttributeEntry
{
const
nsStaticAtom
*
const
attribute
;
}
;
template
<
size_t
N
>
static
bool
FindAttributeDependence
(
const
nsAtom
*
aAttribute
const
MappedAttributeEntry
*
const
(
&
aMaps
)
[
N
]
)
{
return
FindAttributeDependence
(
aAttribute
aMaps
N
)
;
}
static
nsStaticAtom
*
const
*
HTMLSVGPropertiesToTraverseAndUnlink
(
)
;
private
:
void
DescribeAttribute
(
uint32_t
index
nsAString
&
aOutDescription
)
const
;
static
bool
FindAttributeDependence
(
const
nsAtom
*
aAttribute
const
MappedAttributeEntry
*
const
aMaps
[
]
uint32_t
aMapCount
)
;
protected
:
inline
bool
GetAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
DOMString
&
aResult
)
const
{
NS_ASSERTION
(
nullptr
!
=
aName
"
must
have
attribute
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
must
have
a
real
namespace
ID
!
"
)
;
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
if
(
val
)
{
val
-
>
ToString
(
aResult
)
;
return
true
;
}
return
false
;
}
public
:
bool
HasAttrs
(
)
const
{
return
mAttrs
.
HasAttrs
(
)
;
}
inline
bool
GetAttr
(
const
nsAString
&
aName
DOMString
&
aResult
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
)
;
if
(
val
)
{
val
-
>
ToString
(
aResult
)
;
return
true
;
}
return
false
;
}
void
GetTagName
(
nsAString
&
aTagName
)
const
{
aTagName
=
NodeName
(
)
;
}
void
GetId
(
nsAString
&
aId
)
const
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aId
)
;
}
void
GetId
(
DOMString
&
aId
)
const
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aId
)
;
}
void
SetId
(
const
nsAString
&
aId
)
{
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aId
true
)
;
}
void
GetClassName
(
nsAString
&
aClassName
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
aClassName
)
;
}
void
GetClassName
(
DOMString
&
aClassName
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
aClassName
)
;
}
void
SetClassName
(
const
nsAString
&
aClassName
)
{
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
aClassName
true
)
;
}
nsDOMTokenList
*
ClassList
(
)
;
nsDOMTokenList
*
Part
(
)
;
nsDOMAttributeMap
*
Attributes
(
)
;
void
GetAttributeNames
(
nsTArray
<
nsString
>
&
aResult
)
;
void
GetAttribute
(
const
nsAString
&
aName
nsAString
&
aReturn
)
{
DOMString
str
;
GetAttribute
(
aName
str
)
;
str
.
ToString
(
aReturn
)
;
}
void
GetAttribute
(
const
nsAString
&
aName
DOMString
&
aReturn
)
;
void
GetAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
nsAString
&
aReturn
)
;
bool
ToggleAttribute
(
const
nsAString
&
aName
const
Optional
<
bool
>
&
aForce
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
;
void
SetAttribute
(
const
nsAString
&
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
;
void
SetAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
;
void
SetAttribute
(
const
nsAString
&
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
SetAttribute
(
aName
aValue
nullptr
aError
)
;
}
already_AddRefed
<
nsIPrincipal
>
CreateDevtoolsPrincipal
(
)
;
void
SetAttributeDevtools
(
const
nsAString
&
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
;
void
SetAttributeDevtoolsNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
const
nsAString
&
aValue
ErrorResult
&
aError
)
;
void
RemoveAttribute
(
const
nsAString
&
aName
ErrorResult
&
aError
)
;
void
RemoveAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
;
bool
HasAttribute
(
const
nsAString
&
aName
)
const
{
return
InternalGetAttrNameFromQName
(
aName
)
!
=
nullptr
;
}
bool
HasAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
const
;
bool
HasAttributes
(
)
const
{
return
HasAttrs
(
)
;
}
Element
*
Closest
(
const
nsACString
&
aSelector
ErrorResult
&
aResult
)
;
bool
Matches
(
const
nsACString
&
aSelector
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByTagName
(
const
nsAString
&
aQualifiedName
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByClassName
(
const
nsAString
&
aClassNames
)
;
PseudoStyleType
GetPseudoElementType
(
)
const
{
nsresult
rv
=
NS_OK
;
auto
raw
=
GetProperty
(
nsGkAtoms
:
:
pseudoProperty
&
rv
)
;
if
(
rv
=
=
NS_PROPTABLE_PROP_NOT_THERE
)
{
return
PseudoStyleType
:
:
NotPseudo
;
}
return
PseudoStyleType
(
reinterpret_cast
<
uintptr_t
>
(
raw
)
)
;
}
void
SetPseudoElementType
(
PseudoStyleType
aPseudo
)
{
static_assert
(
sizeof
(
PseudoStyleType
)
<
=
sizeof
(
uintptr_t
)
"
Need
to
be
able
to
store
this
in
a
void
*
"
)
;
MOZ_ASSERT
(
PseudoStyle
:
:
IsPseudoElement
(
aPseudo
)
)
;
SetProperty
(
nsGkAtoms
:
:
pseudoProperty
reinterpret_cast
<
void
*
>
(
aPseudo
)
)
;
}
void
GetElementsWithGrid
(
nsTArray
<
RefPtr
<
Element
>
>
&
aElements
)
;
MOZ_CAN_RUN_SCRIPT
bool
HasVisibleScrollbars
(
)
;
private
:
nsINode
*
InsertAdjacent
(
const
nsAString
&
aWhere
nsINode
*
aNode
ErrorResult
&
aError
)
;
public
:
Element
*
InsertAdjacentElement
(
const
nsAString
&
aWhere
Element
&
aElement
ErrorResult
&
aError
)
;
void
InsertAdjacentText
(
const
nsAString
&
aWhere
const
nsAString
&
aData
ErrorResult
&
aError
)
;
void
SetPointerCapture
(
int32_t
aPointerId
ErrorResult
&
aError
)
;
void
ReleasePointerCapture
(
int32_t
aPointerId
ErrorResult
&
aError
)
;
bool
HasPointerCapture
(
long
aPointerId
)
;
void
SetCapture
(
bool
aRetargetToElement
)
;
void
SetCaptureAlways
(
bool
aRetargetToElement
)
;
void
ReleaseCapture
(
)
;
already_AddRefed
<
Promise
>
RequestFullscreen
(
CallerType
ErrorResult
&
)
;
void
RequestPointerLock
(
CallerType
aCallerType
)
;
Attr
*
GetAttributeNode
(
const
nsAString
&
aName
)
;
already_AddRefed
<
Attr
>
SetAttributeNode
(
Attr
&
aNewAttr
ErrorResult
&
aError
)
;
already_AddRefed
<
Attr
>
RemoveAttributeNode
(
Attr
&
aOldAttr
ErrorResult
&
aError
)
;
Attr
*
GetAttributeNodeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
already_AddRefed
<
Attr
>
SetAttributeNodeNS
(
Attr
&
aNewAttr
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
DOMRectList
>
GetClientRects
(
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
DOMRect
>
GetBoundingClientRect
(
)
;
already_AddRefed
<
ShadowRoot
>
AttachShadow
(
const
ShadowRootInit
&
aInit
ErrorResult
&
aError
)
;
bool
CanAttachShadowDOM
(
)
const
;
enum
class
DelegatesFocus
:
bool
{
No
Yes
}
;
already_AddRefed
<
ShadowRoot
>
AttachShadowWithoutNameChecks
(
ShadowRootMode
aMode
DelegatesFocus
=
DelegatesFocus
:
:
No
SlotAssignmentMode
aSlotAssignmentMode
=
SlotAssignmentMode
:
:
Named
)
;
enum
class
NotifyUAWidgetSetup
:
bool
{
No
Yes
}
;
void
AttachAndSetUAShadowRoot
(
NotifyUAWidgetSetup
=
NotifyUAWidgetSetup
:
:
Yes
DelegatesFocus
=
DelegatesFocus
:
:
No
)
;
void
NotifyUAWidgetSetupOrChange
(
)
;
enum
class
UnattachShadowRoot
{
No
Yes
}
;
void
NotifyUAWidgetTeardown
(
UnattachShadowRoot
=
UnattachShadowRoot
:
:
Yes
)
;
void
UnattachShadow
(
)
;
ShadowRoot
*
GetShadowRootByMode
(
)
const
;
void
SetSlot
(
const
nsAString
&
aName
ErrorResult
&
aError
)
;
void
GetSlot
(
nsAString
&
aName
)
;
ShadowRoot
*
GetShadowRoot
(
)
const
{
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mShadowRoot
.
get
(
)
:
nullptr
;
}
const
Maybe
<
float
>
GetLastRememberedBSize
(
)
const
{
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mLastRememberedBSize
:
Nothing
(
)
;
}
const
Maybe
<
float
>
GetLastRememberedISize
(
)
const
{
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mLastRememberedISize
:
Nothing
(
)
;
}
bool
HasLastRememberedBSize
(
)
const
{
return
GetLastRememberedBSize
(
)
.
isSome
(
)
;
}
bool
HasLastRememberedISize
(
)
const
{
return
GetLastRememberedISize
(
)
.
isSome
(
)
;
}
MOZ_CAN_RUN_SCRIPT
bool
CheckVisibility
(
const
CheckVisibilityOptions
&
)
;
private
:
MOZ_CAN_RUN_SCRIPT
void
ScrollIntoView
(
const
ScrollIntoViewOptions
&
aOptions
)
;
public
:
MOZ_CAN_RUN_SCRIPT
void
ScrollIntoView
(
const
BooleanOrScrollIntoViewOptions
&
aObject
)
;
MOZ_CAN_RUN_SCRIPT
void
Scroll
(
double
aXScroll
double
aYScroll
)
;
MOZ_CAN_RUN_SCRIPT
void
Scroll
(
const
ScrollToOptions
&
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollTo
(
double
aXScroll
double
aYScroll
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollTo
(
const
ScrollToOptions
&
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollBy
(
const
ScrollToOptions
&
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollTop
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SetScrollTop
(
int32_t
aScrollTop
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollLeft
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SetScrollLeft
(
int32_t
aScrollLeft
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollWidth
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollHeight
(
)
;
MOZ_CAN_RUN_SCRIPT
void
MozScrollSnap
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ClientTop
(
)
{
return
CSSPixel
:
:
FromAppUnits
(
GetClientAreaRect
(
)
.
y
)
.
Rounded
(
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ClientLeft
(
)
{
return
CSSPixel
:
:
FromAppUnits
(
GetClientAreaRect
(
)
.
x
)
.
Rounded
(
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ClientWidth
(
)
{
return
CSSPixel
:
:
FromAppUnits
(
GetClientAreaRect
(
)
.
Width
(
)
)
.
Rounded
(
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ClientHeight
(
)
{
return
CSSPixel
:
:
FromAppUnits
(
GetClientAreaRect
(
)
.
Height
(
)
)
.
Rounded
(
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ScreenX
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScreenY
(
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
nsIScreen
>
GetScreen
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollTopMin
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollTopMax
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollLeftMin
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollLeftMax
(
)
;
MOZ_CAN_RUN_SCRIPT
double
ClientHeightDouble
(
)
{
return
CSSPixel
:
:
FromAppUnits
(
GetClientAreaRect
(
)
.
Height
(
)
)
;
}
MOZ_CAN_RUN_SCRIPT
double
ClientWidthDouble
(
)
{
return
CSSPixel
:
:
FromAppUnits
(
GetClientAreaRect
(
)
.
Width
(
)
)
;
}
double
FirstLineBoxBSize
(
)
const
;
already_AddRefed
<
Flex
>
GetAsFlexContainer
(
)
;
void
GetGridFragments
(
nsTArray
<
RefPtr
<
Grid
>
>
&
aResult
)
;
bool
HasGridFragments
(
)
;
already_AddRefed
<
DOMMatrixReadOnly
>
GetTransformToAncestor
(
Element
&
aAncestor
)
;
already_AddRefed
<
DOMMatrixReadOnly
>
GetTransformToParent
(
)
;
already_AddRefed
<
DOMMatrixReadOnly
>
GetTransformToViewport
(
)
;
already_AddRefed
<
Animation
>
Animate
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
GetAnimations
(
const
GetAnimationsOptions
&
aOptions
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
;
void
GetAnimationsWithoutFlush
(
const
GetAnimationsOptions
&
aOptions
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
;
static
void
GetAnimationsUnsorted
(
Element
*
aElement
PseudoStyleType
aPseudoType
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
;
void
CloneAnimationsFrom
(
const
Element
&
aOther
)
;
virtual
void
GetInnerHTML
(
nsAString
&
aInnerHTML
OOMReporter
&
aError
)
;
virtual
void
SetInnerHTML
(
const
nsAString
&
aInnerHTML
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
GetOuterHTML
(
nsAString
&
aOuterHTML
)
;
void
SetOuterHTML
(
const
nsAString
&
aOuterHTML
ErrorResult
&
aError
)
;
void
InsertAdjacentHTML
(
const
nsAString
&
aPosition
const
nsAString
&
aText
ErrorResult
&
aError
)
;
void
SetHTML
(
const
nsAString
&
aInnerHTML
const
SetHTMLOptions
&
aOptions
ErrorResult
&
aError
)
;
void
SetEventHandler
(
nsAtom
*
aEventName
const
nsAString
&
aValue
bool
aDefer
=
true
)
;
nsresult
LeaveLink
(
nsPresContext
*
aPresContext
)
;
static
bool
ShouldBlur
(
nsIContent
*
aContent
)
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
DispatchClickEvent
(
nsPresContext
*
aPresContext
WidgetInputEvent
*
aSourceEvent
nsIContent
*
aTarget
bool
aFullDispatch
const
EventFlags
*
aFlags
nsEventStatus
*
aStatus
)
;
using
nsIContent
:
:
DispatchEvent
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
DispatchEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIContent
*
aTarget
bool
aFullDispatch
nsEventStatus
*
aStatus
)
;
bool
IsDisplayContents
(
)
const
{
return
HasServoData
(
)
&
&
Servo_Element_IsDisplayContents
(
this
)
;
}
bool
IsRendered
(
)
const
{
return
GetPrimaryFrame
(
)
|
|
IsDisplayContents
(
)
;
}
const
nsAttrValue
*
GetParsedAttr
(
const
nsAtom
*
aAttr
)
const
{
return
mAttrs
.
GetAttr
(
aAttr
)
;
}
const
nsAttrValue
*
GetParsedAttr
(
const
nsAtom
*
aAttr
int32_t
aNameSpaceID
)
const
{
return
mAttrs
.
GetAttr
(
aAttr
aNameSpaceID
)
;
}
nsDOMAttributeMap
*
GetAttributeMap
(
)
{
nsDOMSlots
*
slots
=
GetExistingDOMSlots
(
)
;
return
slots
?
slots
-
>
mAttributeMap
.
get
(
)
:
nullptr
;
}
void
RecompileScriptEventListeners
(
)
;
BorrowedAttrInfo
GetAttrInfo
(
int32_t
aNamespaceID
const
nsAtom
*
aName
)
const
{
NS_ASSERTION
(
aName
"
must
have
attribute
name
"
)
;
NS_ASSERTION
(
aNamespaceID
!
=
kNameSpaceID_Unknown
"
must
have
a
real
namespace
ID
!
"
)
;
int32_t
index
=
mAttrs
.
IndexOfAttr
(
aName
aNamespaceID
)
;
if
(
index
<
0
)
{
return
BorrowedAttrInfo
(
nullptr
nullptr
)
;
}
return
mAttrs
.
AttrInfoAt
(
index
)
;
}
static
void
ParseCORSValue
(
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
;
static
CORSMode
StringToCORSMode
(
const
nsAString
&
aValue
)
;
static
CORSMode
AttrValueToCORSMode
(
const
nsAttrValue
*
aValue
)
;
nsINode
*
GetScopeChainParent
(
)
const
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
mozilla
:
:
TextEditor
*
GetTextEditorInternal
(
)
;
bool
GetBoolAttr
(
nsAtom
*
aAttr
)
const
{
return
HasAttr
(
kNameSpaceID_None
aAttr
)
;
}
nsresult
SetBoolAttr
(
nsAtom
*
aAttr
bool
aValue
)
;
void
GetEnumAttr
(
nsAtom
*
aAttr
const
char
*
aDefault
nsAString
&
aResult
)
const
;
void
GetEnumAttr
(
nsAtom
*
aAttr
const
char
*
aDefaultMissing
const
char
*
aDefaultInvalid
nsAString
&
aResult
)
const
;
void
UnsetAttr
(
nsAtom
*
aAttr
ErrorResult
&
aError
)
{
aError
=
UnsetAttr
(
kNameSpaceID_None
aAttr
true
)
;
}
void
SetAttr
(
nsAtom
*
aAttr
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
aError
=
SetAttr
(
kNameSpaceID_None
aAttr
aValue
true
)
;
}
void
SetAttr
(
nsAtom
*
aAttr
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
aError
=
SetAttr
(
kNameSpaceID_None
aAttr
aValue
aTriggeringPrincipal
true
)
;
}
void
SetOrRemoveNullableStringAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
;
float
FontSizeInflation
(
)
;
void
GetImplementedPseudoElement
(
nsAString
&
)
const
;
ReferrerPolicy
GetReferrerPolicyAsEnum
(
)
const
;
ReferrerPolicy
ReferrerPolicyFromAttr
(
const
nsAttrValue
*
aValue
)
const
;
already_AddRefed
<
nsDOMStringMap
>
Dataset
(
)
;
void
ClearDataset
(
)
;
void
RegisterIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
;
void
UnregisterIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
;
void
UnlinkIntersectionObservers
(
)
;
bool
UpdateIntersectionObservation
(
DOMIntersectionObserver
*
aObserver
int32_t
threshold
)
;
already_AddRefed
<
nsIDOMXULButtonElement
>
AsXULButton
(
)
;
already_AddRefed
<
nsIDOMXULContainerElement
>
AsXULContainer
(
)
;
already_AddRefed
<
nsIDOMXULContainerItemElement
>
AsXULContainerItem
(
)
;
already_AddRefed
<
nsIDOMXULControlElement
>
AsXULControl
(
)
;
already_AddRefed
<
nsIDOMXULMenuListElement
>
AsXULMenuList
(
)
;
already_AddRefed
<
nsIDOMXULMultiSelectControlElement
>
AsXULMultiSelectControl
(
)
;
already_AddRefed
<
nsIDOMXULRadioGroupElement
>
AsXULRadioGroup
(
)
;
already_AddRefed
<
nsIDOMXULRelatedElement
>
AsXULRelated
(
)
;
already_AddRefed
<
nsIDOMXULSelectControlElement
>
AsXULSelectControl
(
)
;
already_AddRefed
<
nsIDOMXULSelectControlItemElement
>
AsXULSelectControlItem
(
)
;
already_AddRefed
<
nsIBrowser
>
AsBrowser
(
)
;
already_AddRefed
<
nsIAutoCompletePopup
>
AsAutoCompletePopup
(
)
;
enum
PresContextFor
{
eForComposedDoc
eForUncomposedDoc
}
;
nsPresContext
*
GetPresContext
(
PresContextFor
aFor
)
;
MOZ_CAN_RUN_SCRIPT
virtual
Result
<
bool
nsresult
>
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
{
return
Err
(
NS_ERROR_NOT_IMPLEMENTED
)
;
}
protected
:
static
const
bool
kFireMutationEvent
=
true
;
static
const
bool
kDontFireMutationEvent
=
false
;
static
const
bool
kNotifyDocumentObservers
=
true
;
static
const
bool
kDontNotifyDocumentObservers
=
false
;
static
const
bool
kCallAfterSetAttr
=
true
;
static
const
bool
kDontCallAfterSetAttr
=
false
;
nsresult
SetAttrAndNotify
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAttrValue
*
aOldValue
nsAttrValue
&
aParsedValue
nsIPrincipal
*
aMaybeScriptedPrincipal
uint8_t
aModType
bool
aFireMutation
bool
aNotify
bool
aCallAfterSetAttr
Document
*
aComposedDocument
const
mozAutoDocUpdate
&
aGuard
)
;
MOZ_CAN_RUN_SCRIPT
void
Scroll
(
const
CSSIntPoint
&
aScroll
const
ScrollOptions
&
aOptions
)
;
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
;
virtual
bool
SetAndSwapMappedAttribute
(
nsAtom
*
aName
nsAttrValue
&
aValue
bool
*
aValueWasSet
nsresult
*
aRetval
)
;
virtual
nsresult
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
;
void
PreIdMaybeChange
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
)
;
void
PostIdMaybeChange
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
)
;
virtual
nsresult
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
;
virtual
EventListenerManager
*
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
;
const
nsAttrName
*
InternalGetAttrNameFromQName
(
const
nsAString
&
aStr
nsAutoString
*
aNameToUse
=
nullptr
)
const
;
virtual
Element
*
GetNameSpaceElement
(
)
override
{
return
this
;
}
Attr
*
GetAttributeNodeNSInternal
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
inline
void
RegisterActivityObserver
(
)
;
inline
void
UnregisterActivityObserver
(
)
;
void
AddToIdTable
(
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
)
;
bool
CheckHandleEventForLinksPrecondition
(
EventChainVisitor
&
aVisitor
)
const
;
void
GetEventTargetParentForLinks
(
EventChainPreVisitor
&
aVisitor
)
;
void
DispatchChromeOnlyLinkClickEvent
(
EventChainPostVisitor
&
aVisitor
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PostHandleEventForLinks
(
EventChainPostVisitor
&
aVisitor
)
;
public
:
bool
IsLink
(
)
const
{
return
mState
.
HasAtLeastOneOfStates
(
ElementState
:
:
VISITED
|
ElementState
:
:
UNVISITED
)
;
}
virtual
already_AddRefed
<
nsIURI
>
GetHrefURI
(
)
const
{
return
nullptr
;
}
virtual
void
GetLinkTarget
(
nsAString
&
aTarget
)
;
protected
:
enum
class
ReparseAttributes
{
No
Yes
}
;
nsresult
CopyInnerTo
(
Element
*
aDest
ReparseAttributes
=
ReparseAttributes
:
:
Yes
)
;
virtual
nsAtom
*
GetEventNameForAttr
(
nsAtom
*
aAttr
)
;
virtual
void
RegUnRegAccessKey
(
bool
aDoReg
)
;
private
:
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
AssertInvariantsOnNodeInfoChange
(
)
;
#
endif
const
nsAttrValue
*
GetSVGAnimatedClass
(
)
const
;
MOZ_CAN_RUN_SCRIPT
nsRect
GetClientAreaRect
(
)
;
template
<
class
T
>
void
GetCustomInterface
(
nsGetterAddRefs
<
T
>
aResult
)
;
void
IsElement
(
)
=
delete
;
void
AsElement
(
)
=
delete
;
ElementState
mState
;
mozilla
:
:
RustCell
<
ServoNodeData
*
>
mServoData
;
protected
:
AttrArray
mAttrs
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Element
NS_ELEMENT_IID
)
inline
bool
Element
:
:
HasAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
{
NS_ASSERTION
(
nullptr
!
=
aName
"
must
have
attribute
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
must
have
a
real
namespace
ID
!
"
)
;
return
mAttrs
.
IndexOfAttr
(
aName
aNameSpaceID
)
>
=
0
;
}
inline
bool
Element
:
:
HasNonEmptyAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
{
MOZ_ASSERT
(
aNameSpaceID
>
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
MOZ_ASSERT
(
aName
"
Must
have
attribute
name
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
!
val
-
>
IsEmptyString
(
)
;
}
inline
bool
Element
:
:
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAString
&
aValue
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
val
-
>
Equals
(
aValue
aCaseSensitive
)
;
}
inline
bool
Element
:
:
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAtom
*
aValue
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
NS_ASSERTION
(
aValue
"
Null
value
atom
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
val
-
>
Equals
(
aValue
aCaseSensitive
)
;
}
}
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
AsElement
(
)
{
MOZ_ASSERT
(
IsElement
(
)
)
;
return
static_cast
<
mozilla
:
:
dom
:
:
Element
*
>
(
this
)
;
}
inline
const
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
AsElement
(
)
const
{
MOZ_ASSERT
(
IsElement
(
)
)
;
return
static_cast
<
const
mozilla
:
:
dom
:
:
Element
*
>
(
this
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetParentElement
(
)
const
{
return
mozilla
:
:
dom
:
:
Element
:
:
FromNodeOrNull
(
mParent
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetPreviousElementSibling
(
)
const
{
nsIContent
*
previousSibling
=
GetPreviousSibling
(
)
;
while
(
previousSibling
)
{
if
(
previousSibling
-
>
IsElement
(
)
)
{
return
previousSibling
-
>
AsElement
(
)
;
}
previousSibling
=
previousSibling
-
>
GetPreviousSibling
(
)
;
}
return
nullptr
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetAsElementOrParentElement
(
)
const
{
return
IsElement
(
)
?
const_cast
<
mozilla
:
:
dom
:
:
Element
*
>
(
AsElement
(
)
)
:
GetParentElement
(
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetNextElementSibling
(
)
const
{
nsIContent
*
nextSibling
=
GetNextSibling
(
)
;
while
(
nextSibling
)
{
if
(
nextSibling
-
>
IsElement
(
)
)
{
return
nextSibling
-
>
AsElement
(
)
;
}
nextSibling
=
nextSibling
-
>
GetNextSibling
(
)
;
}
return
nullptr
;
}
#
define
NS_IMPL_ELEMENT_CLONE
(
_elementName
)
\
nsresult
_elementName
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
\
nsINode
*
*
aResult
)
const
{
\
*
aResult
=
nullptr
;
\
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
(
aNodeInfo
)
;
\
auto
*
nim
=
ni
-
>
NodeInfoManager
(
)
;
\
RefPtr
<
_elementName
>
it
=
new
(
nim
)
_elementName
(
ni
.
forget
(
)
)
;
\
nsresult
rv
=
const_cast
<
_elementName
*
>
(
this
)
-
>
CopyInnerTo
(
it
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
it
.
forget
(
aResult
)
;
\
}
\
\
return
rv
;
\
}
#
define
EXPAND
(
.
.
.
)
__VA_ARGS__
#
define
NS_IMPL_ELEMENT_CLONE_WITH_INIT_HELPER
(
_elementName
extra_args_
)
\
nsresult
_elementName
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
\
nsINode
*
*
aResult
)
const
{
\
*
aResult
=
nullptr
;
\
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
(
aNodeInfo
)
;
\
auto
*
nim
=
ni
-
>
NodeInfoManager
(
)
;
\
RefPtr
<
_elementName
>
it
=
\
new
(
nim
)
_elementName
(
ni
.
forget
(
)
EXPAND
extra_args_
)
;
\
nsresult
rv
=
it
-
>
Init
(
)
;
\
nsresult
rv2
=
const_cast
<
_elementName
*
>
(
this
)
-
>
CopyInnerTo
(
it
)
;
\
if
(
NS_FAILED
(
rv2
)
)
{
\
rv
=
rv2
;
\
}
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
it
.
forget
(
aResult
)
;
\
}
\
\
return
rv
;
\
}
#
define
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
_elementName
)
\
NS_IMPL_ELEMENT_CLONE_WITH_INIT_HELPER
(
_elementName
(
)
)
#
define
NS_IMPL_ELEMENT_CLONE_WITH_INIT_AND_PARSER
(
_elementName
)
\
NS_IMPL_ELEMENT_CLONE_WITH_INIT_HELPER
(
_elementName
(
NOT_FROM_PARSER
)
)
#
endif
