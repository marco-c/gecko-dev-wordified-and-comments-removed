#
ifndef
mozilla_dom_Element_h__
#
define
mozilla_dom_Element_h__
#
include
"
AttrArray
.
h
"
#
include
"
DOMIntersectionObserver
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsINodeList
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
RustCell
.
h
"
#
include
"
mozilla
/
SMILAttr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
mozilla
/
dom
/
FragmentOrElement
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
DOMTokenListSupportedTokens
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventHandler
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
class
mozAutoDocUpdate
;
class
nsIFrame
;
class
nsIMozBrowserFrame
;
class
nsIURI
;
class
nsIScrollableFrame
;
class
nsAttrValueOrString
;
class
nsContentList
;
class
nsDOMTokenList
;
struct
nsRect
;
class
nsFocusManager
;
class
nsGlobalWindowInner
;
class
nsGlobalWindowOuter
;
class
nsDOMCSSAttributeDeclaration
;
class
nsDOMStringMap
;
struct
ServoNodeData
;
class
nsIDOMXULButtonElement
;
class
nsIDOMXULContainerElement
;
class
nsIDOMXULContainerItemElement
;
class
nsIDOMXULControlElement
;
class
nsIDOMXULMenuListElement
;
class
nsIDOMXULMultiSelectControlElement
;
class
nsIDOMXULRadioGroupElement
;
class
nsIDOMXULRelatedElement
;
class
nsIDOMXULSelectControlElement
;
class
nsIDOMXULSelectControlItemElement
;
class
nsIBrowser
;
namespace
mozilla
{
class
DeclarationBlock
;
struct
MutationClosureData
;
class
TextEditor
;
namespace
css
{
struct
URLValue
;
}
namespace
dom
{
struct
AnimationFilter
;
struct
ScrollIntoViewOptions
;
struct
ScrollToOptions
;
class
DOMIntersectionObserver
;
class
DOMMatrixReadOnly
;
class
Element
;
class
ElementOrCSSPseudoElement
;
class
UnrestrictedDoubleOrKeyframeAnimationOptions
;
enum
class
CallerType
:
uint32_t
;
typedef
nsDataHashtable
<
nsRefPtrHashKey
<
DOMIntersectionObserver
>
int32_t
>
IntersectionObserverList
;
}
}
extern
"
C
"
bool
Servo_Element_IsDisplayContents
(
const
mozilla
:
:
dom
:
:
Element
*
)
;
already_AddRefed
<
nsContentList
>
NS_GetContentList
(
nsINode
*
aRootNode
int32_t
aMatchNameSpaceId
const
nsAString
&
aTagname
)
;
#
define
ELEMENT_FLAG_BIT
(
n_
)
\
NODE_FLAG_BIT
(
NODE_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
=
ELEMENT_FLAG_BIT
(
0
)
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
=
ELEMENT_FLAG_BIT
(
1
)
ELEMENT_HAS_SNAPSHOT
=
ELEMENT_FLAG_BIT
(
2
)
ELEMENT_HANDLED_SNAPSHOT
=
ELEMENT_FLAG_BIT
(
3
)
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
=
NODE_TYPE_SPECIFIC_BITS_OFFSET
+
4
}
;
#
undef
ELEMENT_FLAG_BIT
ASSERT_NODE_FLAGS_SPACE
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
)
;
namespace
mozilla
{
enum
class
PseudoStyleType
:
uint8_t
;
class
EventChainPostVisitor
;
class
EventChainPreVisitor
;
class
EventChainVisitor
;
class
EventListenerManager
;
class
EventStateManager
;
namespace
dom
{
struct
CustomElementDefinition
;
class
Animation
;
class
CustomElementRegistry
;
class
Link
;
class
DOMRect
;
class
DOMRectList
;
class
Flex
;
class
Grid
;
#
define
NS_ELEMENT_IID
\
{
\
0xc67ed254
0xfd3b
0x4b10
{
\
0x96
0xa2
0xc5
0x8b
0x7b
0x64
0x97
0xd1
\
}
\
}
class
Element
:
public
FragmentOrElement
{
public
:
#
ifdef
MOZILLA_INTERNAL_API
explicit
Element
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
FragmentOrElement
(
std
:
:
move
(
aNodeInfo
)
)
mState
(
NS_EVENT_STATE_MOZ_READONLY
|
NS_EVENT_STATE_DEFINED
)
{
MOZ_ASSERT
(
mNodeInfo
-
>
NodeType
(
)
=
=
ELEMENT_NODE
"
Bad
NodeType
in
aNodeInfo
"
)
;
SetIsElement
(
)
;
}
~
Element
(
)
{
NS_ASSERTION
(
!
HasServoData
(
)
"
expected
ServoData
to
be
cleared
earlier
"
)
;
}
#
endif
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_ELEMENT_IID
)
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
NS_IMPL_FROMNODE_HELPER
(
Element
IsElement
(
)
)
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
;
EventStates
State
(
)
const
{
return
mState
;
}
void
UpdateState
(
bool
aNotify
)
;
void
UpdateLinkState
(
EventStates
aState
)
;
virtual
int32_t
TabIndexDefault
(
)
{
return
-
1
;
}
int32_t
TabIndex
(
)
;
void
SetTabIndex
(
int32_t
aTabIndex
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetXBLBinding
(
nsXBLBinding
*
aBinding
nsBindingManager
*
aOldBindingManager
=
nullptr
)
;
void
SetShadowRoot
(
ShadowRoot
*
aShadowRoot
)
;
virtual
void
Focus
(
mozilla
:
:
ErrorResult
&
aError
)
;
virtual
void
Blur
(
mozilla
:
:
ErrorResult
&
aError
)
;
EventStates
StyleState
(
)
const
{
if
(
!
HasLockedStyleStates
(
)
)
{
return
mState
;
}
return
StyleStateFromLocks
(
)
;
}
struct
StyleStateLocks
{
EventStates
mLocks
;
EventStates
mValues
;
}
;
StyleStateLocks
LockedStyleStates
(
)
const
;
void
LockStyleStates
(
EventStates
aStates
bool
aEnabled
)
;
void
UnlockStyleStates
(
EventStates
aStates
)
;
void
ClearStyleStateLocks
(
)
;
bool
HasDirAuto
(
)
const
{
return
State
(
)
.
HasState
(
NS_EVENT_STATE_DIR_ATTR_LIKE_AUTO
)
;
}
bool
HasFixedDir
(
)
const
{
return
State
(
)
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_DIR_ATTR_LTR
|
NS_EVENT_STATE_DIR_ATTR_RTL
)
;
}
DeclarationBlock
*
GetInlineStyleDeclaration
(
)
const
;
const
nsMappedAttributes
*
GetMappedAttributes
(
)
const
;
void
ClearMappedServoStyle
(
)
{
mAttrs
.
ClearMappedServoStyle
(
)
;
}
virtual
void
InlineStyleDeclarationWillChange
(
MutationClosureData
&
aData
)
;
virtual
nsresult
SetInlineStyleDeclaration
(
DeclarationBlock
&
aDeclaration
MutationClosureData
&
aData
)
;
DeclarationBlock
*
GetSMILOverrideStyleDeclaration
(
)
;
nsresult
SetSMILOverrideStyleDeclaration
(
DeclarationBlock
*
aDeclaration
)
;
virtual
UniquePtr
<
SMILAttr
>
GetAnimatedAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
)
{
return
nullptr
;
}
nsDOMCSSAttributeDeclaration
*
SMILOverrideStyle
(
)
;
virtual
bool
IsLabelable
(
)
const
;
virtual
bool
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
;
virtual
nsIMozBrowserFrame
*
GetAsMozBrowserFrame
(
)
{
return
nullptr
;
}
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
;
virtual
nsChangeHint
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
;
inline
Directionality
GetDirectionality
(
)
const
{
if
(
HasFlag
(
NODE_HAS_DIRECTION_RTL
)
)
{
return
eDir_RTL
;
}
if
(
HasFlag
(
NODE_HAS_DIRECTION_LTR
)
)
{
return
eDir_LTR
;
}
return
eDir_NotSet
;
}
inline
void
SetDirectionality
(
Directionality
aDir
bool
aNotify
)
{
UnsetFlags
(
NODE_ALL_DIRECTION_FLAGS
)
;
if
(
!
aNotify
)
{
RemoveStatesSilently
(
DIRECTION_STATES
)
;
}
switch
(
aDir
)
{
case
(
eDir_RTL
)
:
SetFlags
(
NODE_HAS_DIRECTION_RTL
)
;
if
(
!
aNotify
)
{
AddStatesSilently
(
NS_EVENT_STATE_RTL
)
;
}
break
;
case
(
eDir_LTR
)
:
SetFlags
(
NODE_HAS_DIRECTION_LTR
)
;
if
(
!
aNotify
)
{
AddStatesSilently
(
NS_EVENT_STATE_LTR
)
;
}
break
;
default
:
break
;
}
if
(
aNotify
)
{
UpdateState
(
true
)
;
}
}
bool
GetBindingURL
(
Document
*
aDocument
css
:
:
URLValue
*
*
aResult
)
;
Directionality
GetComputedDirectionality
(
)
const
;
static
const
uint32_t
kAllServoDescendantBits
=
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
|
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
|
NODE_DESCENDANTS_NEED_FRAMES
;
void
NoteDirtySubtreeForServo
(
)
;
void
NoteDirtyForServo
(
)
;
void
NoteAnimationOnlyDirtyForServo
(
)
;
void
NoteDescendantsNeedFramesForServo
(
)
;
bool
HasDirtyDescendantsForServo
(
)
const
{
return
HasFlag
(
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
SetHasDirtyDescendantsForServo
(
)
{
SetFlags
(
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
UnsetHasDirtyDescendantsForServo
(
)
{
UnsetFlags
(
ELEMENT_HAS_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
bool
HasAnimationOnlyDirtyDescendantsForServo
(
)
const
{
return
HasFlag
(
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
SetHasAnimationOnlyDirtyDescendantsForServo
(
)
{
SetFlags
(
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
void
UnsetHasAnimationOnlyDirtyDescendantsForServo
(
)
{
UnsetFlags
(
ELEMENT_HAS_ANIMATION_ONLY_DIRTY_DESCENDANTS_FOR_SERVO
)
;
}
bool
HasServoData
(
)
const
{
return
!
!
mServoData
.
Get
(
)
;
}
void
ClearServoData
(
)
{
ClearServoData
(
GetComposedDoc
(
)
)
;
}
void
ClearServoData
(
Document
*
aDocument
)
;
inline
CustomElementData
*
GetCustomElementData
(
)
const
{
if
(
!
HasCustomElementData
(
)
)
{
return
nullptr
;
}
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mCustomElementData
.
get
(
)
:
nullptr
;
}
void
SetCustomElementData
(
CustomElementData
*
aData
)
;
CustomElementDefinition
*
GetCustomElementDefinition
(
)
const
;
void
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
;
void
SetDefined
(
bool
aSet
)
{
if
(
aSet
)
{
AddStates
(
NS_EVENT_STATE_DEFINED
)
;
}
else
{
RemoveStates
(
NS_EVENT_STATE_DEFINED
)
;
}
}
protected
:
virtual
EventStates
IntrinsicState
(
)
const
;
void
AddStatesSilently
(
EventStates
aStates
)
{
mState
|
=
aStates
;
}
void
RemoveStatesSilently
(
EventStates
aStates
)
{
mState
&
=
~
aStates
;
}
already_AddRefed
<
ShadowRoot
>
AttachShadowInternal
(
ShadowRootMode
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
nsIScrollableFrame
*
GetScrollFrame
(
nsIFrame
*
*
aStyledFrame
=
nullptr
FlushType
aFlushType
=
FlushType
:
:
Layout
)
;
private
:
friend
class
mozilla
:
:
EventStateManager
;
friend
class
:
:
nsGlobalWindowInner
;
friend
class
:
:
nsGlobalWindowOuter
;
friend
class
:
:
nsFocusManager
;
friend
class
CustomElementRegistry
;
friend
class
Link
;
void
NotifyStateChange
(
EventStates
aStates
)
;
void
NotifyStyleStateChange
(
EventStates
aStates
)
;
EventStates
StyleStateFromLocks
(
)
const
;
protected
:
virtual
void
AddStates
(
EventStates
aStates
)
{
MOZ_ASSERT
(
!
aStates
.
HasAtLeastOneOfStates
(
INTRINSIC_STATES
)
"
Should
only
be
adding
externally
-
managed
states
here
"
)
;
AddStatesSilently
(
aStates
)
;
NotifyStateChange
(
aStates
)
;
}
virtual
void
RemoveStates
(
EventStates
aStates
)
{
MOZ_ASSERT
(
!
aStates
.
HasAtLeastOneOfStates
(
INTRINSIC_STATES
)
"
Should
only
be
removing
externally
-
managed
states
here
"
)
;
RemoveStatesSilently
(
aStates
)
;
NotifyStateChange
(
aStates
)
;
}
virtual
void
ToggleStates
(
EventStates
aStates
bool
aNotify
)
{
MOZ_ASSERT
(
!
aStates
.
HasAtLeastOneOfStates
(
INTRINSIC_STATES
)
"
Should
only
be
removing
externally
-
managed
states
here
"
)
;
mState
^
=
aStates
;
if
(
aNotify
)
{
NotifyStateChange
(
aStates
)
;
}
}
public
:
void
AddManuallyManagedStates
(
EventStates
aStates
)
{
MOZ_ASSERT
(
MANUALLY_MANAGED_STATES
.
HasAllStates
(
aStates
)
"
Should
only
be
adding
manually
-
managed
states
here
"
)
;
AddStates
(
aStates
)
;
}
void
RemoveManuallyManagedStates
(
EventStates
aStates
)
{
MOZ_ASSERT
(
MANUALLY_MANAGED_STATES
.
HasAllStates
(
aStates
)
"
Should
only
be
removing
manually
-
managed
states
here
"
)
;
RemoveStates
(
aStates
)
;
}
void
UpdateEditableState
(
bool
aNotify
)
override
;
nsresult
BindToTree
(
Document
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
override
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
GetExistingAttrNameFromQName
(
const
nsAString
&
aStr
)
const
;
bool
MaybeCheckSameAttrVal
(
int32_t
aNamespaceID
const
nsAtom
*
aName
const
nsAtom
*
aPrefix
const
nsAttrValueOrString
&
aValue
bool
aNotify
nsAttrValue
&
aOldValue
uint8_t
*
aModType
bool
*
aHasListeners
bool
*
aOldValueSet
)
;
bool
OnlyNotifySameValueSet
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAttrValueOrString
&
aValue
bool
aNotify
nsAttrValue
&
aOldValue
uint8_t
*
aModType
bool
*
aHasListeners
bool
*
aOldValueSet
)
;
nsresult
SetSingleClassFromParser
(
nsAtom
*
aSingleClassName
)
;
nsresult
SetParsedAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
nsAtom
*
aPrefix
nsAttrValue
&
aParsedValue
bool
aNotify
)
;
bool
GetAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
nsAString
&
aResult
)
const
;
bool
GetAttr
(
const
nsAtom
*
aName
nsAString
&
aResult
)
const
{
return
GetAttr
(
kNameSpaceID_None
aName
aResult
)
;
}
inline
bool
HasAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
;
bool
HasAttr
(
const
nsAtom
*
aAttr
)
const
{
return
HasAttr
(
kNameSpaceID_None
aAttr
)
;
}
inline
bool
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAString
&
aValue
nsCaseTreatment
aCaseSensitive
)
const
;
bool
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAtom
*
aValue
nsCaseTreatment
aCaseSensitive
)
const
;
enum
{
ATTR_MISSING
=
-
1
ATTR_VALUE_NO_MATCH
=
-
2
}
;
typedef
nsStaticAtom
*
const
AttrValuesArray
;
int32_t
FindAttrValueIn
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
AttrValuesArray
*
aValues
nsCaseTreatment
aCaseSensitive
)
const
;
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAString
&
aValue
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
nullptr
aValue
aNotify
)
;
}
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAString
&
aValue
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
aPrefix
aValue
nullptr
aNotify
)
;
}
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
nullptr
aValue
aTriggeringPrincipal
aNotify
)
;
}
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
;
nsresult
UnsetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
bool
aNotify
)
;
const
nsAttrName
*
GetAttrNameAt
(
uint32_t
aIndex
)
const
{
return
mAttrs
.
GetSafeAttrNameAt
(
aIndex
)
;
}
const
nsAttrName
*
GetUnsafeAttrNameAt
(
uint32_t
aIndex
)
const
{
return
mAttrs
.
AttrNameAt
(
aIndex
)
;
}
BorrowedAttrInfo
GetAttrInfoAt
(
uint32_t
aIndex
)
const
{
if
(
aIndex
>
=
mAttrs
.
AttrCount
(
)
)
{
return
BorrowedAttrInfo
(
nullptr
nullptr
)
;
}
return
mAttrs
.
AttrInfoAt
(
aIndex
)
;
}
uint32_t
GetAttrCount
(
)
const
{
return
mAttrs
.
AttrCount
(
)
;
}
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
const
nsAttrValue
*
GetClasses
(
)
const
{
if
(
!
MayHaveClass
(
)
)
{
return
nullptr
;
}
if
(
IsSVGElement
(
)
)
{
if
(
const
nsAttrValue
*
value
=
GetSVGAnimatedClass
(
)
)
{
return
value
;
}
}
return
GetParsedAttr
(
nsGkAtoms
:
:
_class
)
;
}
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
)
const
override
{
List
(
out
aIndent
EmptyCString
(
)
)
;
}
virtual
void
DumpContent
(
FILE
*
out
int32_t
aIndent
bool
aDumpAll
)
const
override
;
void
List
(
FILE
*
out
int32_t
aIndent
const
nsCString
&
aPrefix
)
const
;
void
ListAttributes
(
FILE
*
out
)
const
;
#
endif
void
Describe
(
nsAString
&
aOutDescription
)
const
;
struct
MappedAttributeEntry
{
const
nsStaticAtom
*
const
attribute
;
}
;
template
<
size_t
N
>
static
bool
FindAttributeDependence
(
const
nsAtom
*
aAttribute
const
MappedAttributeEntry
*
const
(
&
aMaps
)
[
N
]
)
{
return
FindAttributeDependence
(
aAttribute
aMaps
N
)
;
}
static
nsStaticAtom
*
const
*
HTMLSVGPropertiesToTraverseAndUnlink
(
)
;
private
:
void
DescribeAttribute
(
uint32_t
index
nsAString
&
aOutDescription
)
const
;
static
bool
FindAttributeDependence
(
const
nsAtom
*
aAttribute
const
MappedAttributeEntry
*
const
aMaps
[
]
uint32_t
aMapCount
)
;
protected
:
inline
bool
GetAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
DOMString
&
aResult
)
const
{
NS_ASSERTION
(
nullptr
!
=
aName
"
must
have
attribute
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
must
have
a
real
namespace
ID
!
"
)
;
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
if
(
val
)
{
val
-
>
ToString
(
aResult
)
;
return
true
;
}
return
false
;
}
public
:
bool
HasAttrs
(
)
const
{
return
mAttrs
.
HasAttrs
(
)
;
}
inline
bool
GetAttr
(
const
nsAString
&
aName
DOMString
&
aResult
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
)
;
if
(
val
)
{
val
-
>
ToString
(
aResult
)
;
return
true
;
}
return
false
;
}
void
GetTagName
(
nsAString
&
aTagName
)
const
{
aTagName
=
NodeName
(
)
;
}
void
GetId
(
nsAString
&
aId
)
const
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aId
)
;
}
void
GetId
(
DOMString
&
aId
)
const
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aId
)
;
}
void
SetId
(
const
nsAString
&
aId
)
{
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aId
true
)
;
}
void
GetClassName
(
nsAString
&
aClassName
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
aClassName
)
;
}
void
GetClassName
(
DOMString
&
aClassName
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
aClassName
)
;
}
void
SetClassName
(
const
nsAString
&
aClassName
)
{
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
aClassName
true
)
;
}
nsDOMTokenList
*
ClassList
(
)
;
nsDOMAttributeMap
*
Attributes
(
)
{
nsDOMSlots
*
slots
=
DOMSlots
(
)
;
if
(
!
slots
-
>
mAttributeMap
)
{
slots
-
>
mAttributeMap
=
new
nsDOMAttributeMap
(
this
)
;
}
return
slots
-
>
mAttributeMap
;
}
void
GetAttributeNames
(
nsTArray
<
nsString
>
&
aResult
)
;
void
GetAttribute
(
const
nsAString
&
aName
nsAString
&
aReturn
)
{
DOMString
str
;
GetAttribute
(
aName
str
)
;
str
.
ToString
(
aReturn
)
;
}
void
GetAttribute
(
const
nsAString
&
aName
DOMString
&
aReturn
)
;
void
GetAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
nsAString
&
aReturn
)
;
bool
ToggleAttribute
(
const
nsAString
&
aName
const
Optional
<
bool
>
&
aForce
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
;
void
SetAttribute
(
const
nsAString
&
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
;
void
SetAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
;
void
SetAttribute
(
const
nsAString
&
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
SetAttribute
(
aName
aValue
nullptr
aError
)
;
}
void
RemoveAttribute
(
const
nsAString
&
aName
ErrorResult
&
aError
)
;
void
RemoveAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
;
bool
HasAttribute
(
const
nsAString
&
aName
)
const
{
return
InternalGetAttrNameFromQName
(
aName
)
!
=
nullptr
;
}
bool
HasAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
const
;
bool
HasAttributes
(
)
const
{
return
HasAttrs
(
)
;
}
Element
*
Closest
(
const
nsAString
&
aSelector
ErrorResult
&
aResult
)
;
bool
Matches
(
const
nsAString
&
aSelector
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByTagName
(
const
nsAString
&
aQualifiedName
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByTagNameNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByClassName
(
const
nsAString
&
aClassNames
)
;
PseudoStyleType
GetPseudoElementType
(
)
const
{
nsresult
rv
=
NS_OK
;
auto
raw
=
GetProperty
(
nsGkAtoms
:
:
pseudoProperty
&
rv
)
;
if
(
rv
=
=
NS_PROPTABLE_PROP_NOT_THERE
)
{
return
PseudoStyleType
:
:
NotPseudo
;
}
return
PseudoStyleType
(
reinterpret_cast
<
uintptr_t
>
(
raw
)
)
;
}
void
SetPseudoElementType
(
PseudoStyleType
aPseudo
)
{
static_assert
(
sizeof
(
PseudoStyleType
)
<
=
sizeof
(
uintptr_t
)
"
Need
to
be
able
to
store
this
in
a
void
*
"
)
;
MOZ_ASSERT
(
PseudoStyle
:
:
IsPseudoElement
(
aPseudo
)
)
;
SetProperty
(
nsGkAtoms
:
:
pseudoProperty
reinterpret_cast
<
void
*
>
(
aPseudo
)
)
;
}
void
GetElementsWithGrid
(
nsTArray
<
RefPtr
<
Element
>
>
&
aElements
)
;
private
:
nsINode
*
InsertAdjacent
(
const
nsAString
&
aWhere
nsINode
*
aNode
ErrorResult
&
aError
)
;
public
:
Element
*
InsertAdjacentElement
(
const
nsAString
&
aWhere
Element
&
aElement
ErrorResult
&
aError
)
;
void
InsertAdjacentText
(
const
nsAString
&
aWhere
const
nsAString
&
aData
ErrorResult
&
aError
)
;
void
SetPointerCapture
(
int32_t
aPointerId
ErrorResult
&
aError
)
{
bool
activeState
=
false
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
GetComposedDoc
(
)
)
&
&
aPointerId
!
=
PointerEventHandler
:
:
GetSpoofedPointerIdForRFP
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_POINTER_ERR
)
;
return
;
}
if
(
!
PointerEventHandler
:
:
GetPointerInfo
(
aPointerId
activeState
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_POINTER_ERR
)
;
return
;
}
if
(
!
IsInUncomposedDoc
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
OwnerDoc
(
)
-
>
GetPointerLockElement
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
!
activeState
)
{
return
;
}
PointerEventHandler
:
:
SetPointerCaptureById
(
aPointerId
this
)
;
}
void
ReleasePointerCapture
(
int32_t
aPointerId
ErrorResult
&
aError
)
{
bool
activeState
=
false
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
GetComposedDoc
(
)
)
&
&
aPointerId
!
=
PointerEventHandler
:
:
GetSpoofedPointerIdForRFP
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_POINTER_ERR
)
;
return
;
}
if
(
!
PointerEventHandler
:
:
GetPointerInfo
(
aPointerId
activeState
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_POINTER_ERR
)
;
return
;
}
if
(
HasPointerCapture
(
aPointerId
)
)
{
PointerEventHandler
:
:
ReleasePointerCaptureById
(
aPointerId
)
;
}
}
bool
HasPointerCapture
(
long
aPointerId
)
{
PointerCaptureInfo
*
pointerCaptureInfo
=
PointerEventHandler
:
:
GetPointerCaptureInfo
(
aPointerId
)
;
if
(
pointerCaptureInfo
&
&
pointerCaptureInfo
-
>
mPendingContent
=
=
this
)
{
return
true
;
}
return
false
;
}
void
SetCapture
(
bool
aRetargetToElement
)
{
if
(
!
nsIPresShell
:
:
GetCapturingContent
(
)
)
{
nsIPresShell
:
:
SetCapturingContent
(
this
CAPTURE_PREVENTDRAG
|
(
aRetargetToElement
?
CAPTURE_RETARGETTOELEMENT
:
0
)
)
;
}
}
void
SetCaptureAlways
(
bool
aRetargetToElement
)
{
nsIPresShell
:
:
SetCapturingContent
(
this
CAPTURE_PREVENTDRAG
|
CAPTURE_IGNOREALLOWED
|
(
aRetargetToElement
?
CAPTURE_RETARGETTOELEMENT
:
0
)
)
;
}
void
ReleaseCapture
(
)
{
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
=
=
this
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
}
already_AddRefed
<
Promise
>
RequestFullscreen
(
CallerType
ErrorResult
&
)
;
void
RequestPointerLock
(
CallerType
aCallerType
)
;
Attr
*
GetAttributeNode
(
const
nsAString
&
aName
)
;
already_AddRefed
<
Attr
>
SetAttributeNode
(
Attr
&
aNewAttr
ErrorResult
&
aError
)
;
already_AddRefed
<
Attr
>
RemoveAttributeNode
(
Attr
&
aOldAttr
ErrorResult
&
aError
)
;
Attr
*
GetAttributeNodeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
already_AddRefed
<
Attr
>
SetAttributeNodeNS
(
Attr
&
aNewAttr
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
DOMRectList
>
GetClientRects
(
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
DOMRect
>
GetBoundingClientRect
(
)
;
already_AddRefed
<
ShadowRoot
>
AttachShadow
(
const
ShadowRootInit
&
aInit
ErrorResult
&
aError
)
;
bool
CanAttachShadowDOM
(
)
const
;
already_AddRefed
<
ShadowRoot
>
AttachShadowWithoutNameChecks
(
ShadowRootMode
aMode
)
;
void
AttachAndSetUAShadowRoot
(
)
;
void
NotifyUAWidgetSetupOrChange
(
)
;
enum
class
UnattachShadowRoot
{
No
Yes
}
;
void
NotifyUAWidgetTeardown
(
UnattachShadowRoot
=
UnattachShadowRoot
:
:
Yes
)
;
void
UnattachShadow
(
)
;
ShadowRoot
*
GetShadowRootByMode
(
)
const
;
void
SetSlot
(
const
nsAString
&
aName
ErrorResult
&
aError
)
;
void
GetSlot
(
nsAString
&
aName
)
;
ShadowRoot
*
GetShadowRoot
(
)
const
{
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mShadowRoot
.
get
(
)
:
nullptr
;
}
private
:
void
ScrollIntoView
(
const
ScrollIntoViewOptions
&
aOptions
)
;
public
:
void
ScrollIntoView
(
const
BooleanOrScrollIntoViewOptions
&
aObject
)
;
MOZ_CAN_RUN_SCRIPT
void
Scroll
(
double
aXScroll
double
aYScroll
)
;
MOZ_CAN_RUN_SCRIPT
void
Scroll
(
const
ScrollToOptions
&
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollTo
(
double
aXScroll
double
aYScroll
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollTo
(
const
ScrollToOptions
&
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollBy
(
const
ScrollToOptions
&
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollTop
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SetScrollTop
(
int32_t
aScrollTop
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollLeft
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SetScrollLeft
(
int32_t
aScrollLeft
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollWidth
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollHeight
(
)
;
MOZ_CAN_RUN_SCRIPT
void
MozScrollSnap
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
ClientTop
(
)
{
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
GetClientAreaRect
(
)
.
y
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ClientLeft
(
)
{
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
GetClientAreaRect
(
)
.
x
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ClientWidth
(
)
{
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
GetClientAreaRect
(
)
.
Width
(
)
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ClientHeight
(
)
{
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
GetClientAreaRect
(
)
.
Height
(
)
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollTopMin
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
return
sf
?
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
sf
-
>
GetScrollRange
(
)
.
y
)
:
0
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollTopMax
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
return
sf
?
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
sf
-
>
GetScrollRange
(
)
.
YMost
(
)
)
:
0
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollLeftMin
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
return
sf
?
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
sf
-
>
GetScrollRange
(
)
.
x
)
:
0
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
ScrollLeftMax
(
)
{
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
return
sf
?
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
sf
-
>
GetScrollRange
(
)
.
XMost
(
)
)
:
0
;
}
already_AddRefed
<
Flex
>
GetAsFlexContainer
(
)
;
void
GetGridFragments
(
nsTArray
<
RefPtr
<
Grid
>
>
&
aResult
)
;
already_AddRefed
<
DOMMatrixReadOnly
>
GetTransformToAncestor
(
Element
&
aAncestor
)
;
already_AddRefed
<
DOMMatrixReadOnly
>
GetTransformToParent
(
)
;
already_AddRefed
<
DOMMatrixReadOnly
>
GetTransformToViewport
(
)
;
already_AddRefed
<
Animation
>
Animate
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Animation
>
Animate
(
const
Nullable
<
ElementOrCSSPseudoElement
>
&
aTarget
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aKeyframes
const
UnrestrictedDoubleOrKeyframeAnimationOptions
&
aOptions
ErrorResult
&
aError
)
;
void
GetAnimations
(
const
AnimationFilter
&
filter
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
;
static
void
GetAnimationsUnsorted
(
Element
*
aElement
PseudoStyleType
aPseudoType
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
;
virtual
void
GetInnerHTML
(
nsAString
&
aInnerHTML
OOMReporter
&
aError
)
;
virtual
void
SetInnerHTML
(
const
nsAString
&
aInnerHTML
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
;
void
GetOuterHTML
(
nsAString
&
aOuterHTML
)
;
void
SetOuterHTML
(
const
nsAString
&
aOuterHTML
ErrorResult
&
aError
)
;
void
InsertAdjacentHTML
(
const
nsAString
&
aPosition
const
nsAString
&
aText
ErrorResult
&
aError
)
;
nsresult
SetEventHandler
(
nsAtom
*
aEventName
const
nsAString
&
aValue
bool
aDefer
=
true
)
;
nsresult
LeaveLink
(
nsPresContext
*
aPresContext
)
;
static
bool
ShouldBlur
(
nsIContent
*
aContent
)
;
static
nsresult
DispatchClickEvent
(
nsPresContext
*
aPresContext
WidgetInputEvent
*
aSourceEvent
nsIContent
*
aTarget
bool
aFullDispatch
const
EventFlags
*
aFlags
nsEventStatus
*
aStatus
)
;
using
nsIContent
:
:
DispatchEvent
;
static
nsresult
DispatchEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIContent
*
aTarget
bool
aFullDispatch
nsEventStatus
*
aStatus
)
;
bool
IsDisplayContents
(
)
const
{
return
HasServoData
(
)
&
&
Servo_Element_IsDisplayContents
(
this
)
;
}
const
nsAttrValue
*
GetParsedAttr
(
const
nsAtom
*
aAttr
)
const
{
return
mAttrs
.
GetAttr
(
aAttr
)
;
}
const
nsAttrValue
*
GetParsedAttr
(
const
nsAtom
*
aAttr
int32_t
aNameSpaceID
)
const
{
return
mAttrs
.
GetAttr
(
aAttr
aNameSpaceID
)
;
}
nsDOMAttributeMap
*
GetAttributeMap
(
)
{
nsDOMSlots
*
slots
=
GetExistingDOMSlots
(
)
;
return
slots
?
slots
-
>
mAttributeMap
.
get
(
)
:
nullptr
;
}
virtual
void
RecompileScriptEventListeners
(
)
{
}
BorrowedAttrInfo
GetAttrInfo
(
int32_t
aNamespaceID
const
nsAtom
*
aName
)
const
{
NS_ASSERTION
(
aName
"
must
have
attribute
name
"
)
;
NS_ASSERTION
(
aNamespaceID
!
=
kNameSpaceID_Unknown
"
must
have
a
real
namespace
ID
!
"
)
;
int32_t
index
=
mAttrs
.
IndexOfAttr
(
aName
aNamespaceID
)
;
if
(
index
<
0
)
{
return
BorrowedAttrInfo
(
nullptr
nullptr
)
;
}
return
mAttrs
.
AttrInfoAt
(
index
)
;
}
virtual
void
NodeInfoChanged
(
Document
*
aOldDoc
)
{
}
static
void
ParseCORSValue
(
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
;
static
CORSMode
StringToCORSMode
(
const
nsAString
&
aValue
)
;
static
CORSMode
AttrValueToCORSMode
(
const
nsAttrValue
*
aValue
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
final
;
nsINode
*
GetScopeChainParent
(
)
const
override
;
mozilla
:
:
TextEditor
*
GetTextEditorInternal
(
)
;
bool
GetBoolAttr
(
nsAtom
*
aAttr
)
const
{
return
HasAttr
(
kNameSpaceID_None
aAttr
)
;
}
nsresult
SetBoolAttr
(
nsAtom
*
aAttr
bool
aValue
)
;
void
GetEnumAttr
(
nsAtom
*
aAttr
const
char
*
aDefault
nsAString
&
aResult
)
const
;
void
GetEnumAttr
(
nsAtom
*
aAttr
const
char
*
aDefaultMissing
const
char
*
aDefaultInvalid
nsAString
&
aResult
)
const
;
void
UnsetAttr
(
nsAtom
*
aAttr
ErrorResult
&
aError
)
{
aError
=
UnsetAttr
(
kNameSpaceID_None
aAttr
true
)
;
}
void
SetAttr
(
nsAtom
*
aAttr
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
aError
=
SetAttr
(
kNameSpaceID_None
aAttr
aValue
true
)
;
}
void
SetAttr
(
nsAtom
*
aAttr
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
aError
=
SetAttr
(
kNameSpaceID_None
aAttr
aValue
aTriggeringPrincipal
true
)
;
}
void
SetOrRemoveNullableStringAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
ErrorResult
&
aError
)
;
float
FontSizeInflation
(
)
;
net
:
:
ReferrerPolicy
GetReferrerPolicyAsEnum
(
)
;
net
:
:
ReferrerPolicy
ReferrerPolicyFromAttr
(
const
nsAttrValue
*
aValue
)
;
already_AddRefed
<
nsDOMStringMap
>
Dataset
(
)
;
void
ClearDataset
(
)
;
void
RegisterIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
;
void
UnregisterIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
;
void
UnlinkIntersectionObservers
(
)
;
bool
UpdateIntersectionObservation
(
DOMIntersectionObserver
*
aObserver
int32_t
threshold
)
;
already_AddRefed
<
nsIDOMXULButtonElement
>
AsXULButton
(
)
;
already_AddRefed
<
nsIDOMXULContainerElement
>
AsXULContainer
(
)
;
already_AddRefed
<
nsIDOMXULContainerItemElement
>
AsXULContainerItem
(
)
;
already_AddRefed
<
nsIDOMXULControlElement
>
AsXULControl
(
)
;
already_AddRefed
<
nsIDOMXULMenuListElement
>
AsXULMenuList
(
)
;
already_AddRefed
<
nsIDOMXULMultiSelectControlElement
>
AsXULMultiSelectControl
(
)
;
already_AddRefed
<
nsIDOMXULRadioGroupElement
>
AsXULRadioGroup
(
)
;
already_AddRefed
<
nsIDOMXULRelatedElement
>
AsXULRelated
(
)
;
already_AddRefed
<
nsIDOMXULSelectControlElement
>
AsXULSelectControl
(
)
;
already_AddRefed
<
nsIDOMXULSelectControlItemElement
>
AsXULSelectControlItem
(
)
;
already_AddRefed
<
nsIBrowser
>
AsBrowser
(
)
;
protected
:
static
const
bool
kFireMutationEvent
=
true
;
static
const
bool
kDontFireMutationEvent
=
false
;
static
const
bool
kNotifyDocumentObservers
=
true
;
static
const
bool
kDontNotifyDocumentObservers
=
false
;
static
const
bool
kCallAfterSetAttr
=
true
;
static
const
bool
kDontCallAfterSetAttr
=
false
;
nsresult
SetAttrAndNotify
(
int32_t
aNamespaceID
nsAtom
*
aName
nsAtom
*
aPrefix
const
nsAttrValue
*
aOldValue
nsAttrValue
&
aParsedValue
nsIPrincipal
*
aMaybeScriptedPrincipal
uint8_t
aModType
bool
aFireMutation
bool
aNotify
bool
aCallAfterSetAttr
Document
*
aComposedDocument
const
mozAutoDocUpdate
&
aGuard
)
;
MOZ_CAN_RUN_SCRIPT
void
Scroll
(
const
CSSIntPoint
&
aScroll
const
ScrollOptions
&
aOptions
)
;
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
;
virtual
bool
SetAndSwapMappedAttribute
(
nsAtom
*
aName
nsAttrValue
&
aValue
bool
*
aValueWasSet
nsresult
*
aRetval
)
;
virtual
nsresult
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
return
NS_OK
;
}
void
PreIdMaybeChange
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
)
;
void
PostIdMaybeChange
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
)
;
virtual
nsresult
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
;
virtual
EventListenerManager
*
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
;
const
nsAttrName
*
InternalGetAttrNameFromQName
(
const
nsAString
&
aStr
nsAutoString
*
aNameToUse
=
nullptr
)
const
;
virtual
Element
*
GetNameSpaceElement
(
)
override
{
return
this
;
}
Attr
*
GetAttributeNodeNSInternal
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
inline
void
RegisterActivityObserver
(
)
;
inline
void
UnregisterActivityObserver
(
)
;
void
AddToIdTable
(
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
)
;
bool
CheckHandleEventForLinksPrecondition
(
EventChainVisitor
&
aVisitor
nsIURI
*
*
aURI
)
const
;
void
GetEventTargetParentForLinks
(
EventChainPreVisitor
&
aVisitor
)
;
nsresult
PostHandleEventForLinks
(
EventChainPostVisitor
&
aVisitor
)
;
virtual
void
GetLinkTarget
(
nsAString
&
aTarget
)
;
nsDOMTokenList
*
GetTokenList
(
nsAtom
*
aAtom
const
DOMTokenListSupportedTokenArray
aSupportedTokens
=
nullptr
)
;
nsresult
CopyInnerTo
(
Element
*
aDest
)
;
private
:
const
nsAttrValue
*
GetSVGAnimatedClass
(
)
const
;
MOZ_CAN_RUN_SCRIPT
nsRect
GetClientAreaRect
(
)
;
template
<
class
T
>
void
GetCustomInterface
(
nsGetterAddRefs
<
T
>
aResult
)
;
void
IsElement
(
)
=
delete
;
void
AsElement
(
)
=
delete
;
EventStates
mState
;
mozilla
:
:
RustCell
<
ServoNodeData
*
>
mServoData
;
protected
:
AttrArray
mAttrs
;
}
;
class
RemoveFromBindingManagerRunnable
:
public
mozilla
:
:
Runnable
{
public
:
RemoveFromBindingManagerRunnable
(
nsBindingManager
*
aManager
nsIContent
*
aContent
Document
*
aDoc
)
;
NS_IMETHOD
Run
(
)
override
;
private
:
virtual
~
RemoveFromBindingManagerRunnable
(
)
;
RefPtr
<
nsBindingManager
>
mManager
;
RefPtr
<
nsIContent
>
mContent
;
RefPtr
<
Document
>
mDoc
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Element
NS_ELEMENT_IID
)
inline
bool
Element
:
:
HasAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
{
NS_ASSERTION
(
nullptr
!
=
aName
"
must
have
attribute
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
must
have
a
real
namespace
ID
!
"
)
;
return
mAttrs
.
IndexOfAttr
(
aName
aNameSpaceID
)
>
=
0
;
}
inline
bool
Element
:
:
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAString
&
aValue
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
val
-
>
Equals
(
aValue
aCaseSensitive
)
;
}
inline
bool
Element
:
:
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAtom
*
aValue
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
NS_ASSERTION
(
aValue
"
Null
value
atom
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
val
-
>
Equals
(
aValue
aCaseSensitive
)
;
}
}
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
AsElement
(
)
{
MOZ_ASSERT
(
IsElement
(
)
)
;
return
static_cast
<
mozilla
:
:
dom
:
:
Element
*
>
(
this
)
;
}
inline
const
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
AsElement
(
)
const
{
MOZ_ASSERT
(
IsElement
(
)
)
;
return
static_cast
<
const
mozilla
:
:
dom
:
:
Element
*
>
(
this
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetParentElement
(
)
const
{
return
mozilla
:
:
dom
:
:
Element
:
:
FromNodeOrNull
(
mParent
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetPreviousElementSibling
(
)
const
{
nsIContent
*
previousSibling
=
GetPreviousSibling
(
)
;
while
(
previousSibling
)
{
if
(
previousSibling
-
>
IsElement
(
)
)
{
return
previousSibling
-
>
AsElement
(
)
;
}
previousSibling
=
previousSibling
-
>
GetPreviousSibling
(
)
;
}
return
nullptr
;
}
inline
mozilla
:
:
dom
:
:
Element
*
nsINode
:
:
GetNextElementSibling
(
)
const
{
nsIContent
*
nextSibling
=
GetNextSibling
(
)
;
while
(
nextSibling
)
{
if
(
nextSibling
-
>
IsElement
(
)
)
{
return
nextSibling
-
>
AsElement
(
)
;
}
nextSibling
=
nextSibling
-
>
GetNextSibling
(
)
;
}
return
nullptr
;
}
#
define
NS_IMPL_ELEMENT_CLONE
(
_elementName
)
\
nsresult
_elementName
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
\
nsINode
*
*
aResult
)
const
{
\
*
aResult
=
nullptr
;
\
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
(
aNodeInfo
)
;
\
_elementName
*
it
=
new
_elementName
(
ni
.
forget
(
)
)
;
\
if
(
!
it
)
{
\
return
NS_ERROR_OUT_OF_MEMORY
;
\
}
\
\
nsCOMPtr
<
nsINode
>
kungFuDeathGrip
=
it
;
\
nsresult
rv
=
const_cast
<
_elementName
*
>
(
this
)
-
>
CopyInnerTo
(
it
)
;
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
kungFuDeathGrip
.
swap
(
*
aResult
)
;
\
}
\
\
return
rv
;
\
}
#
define
EXPAND
(
.
.
.
)
__VA_ARGS__
#
define
NS_IMPL_ELEMENT_CLONE_WITH_INIT_HELPER
(
_elementName
extra_args_
)
\
nsresult
_elementName
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
\
nsINode
*
*
aResult
)
const
{
\
*
aResult
=
nullptr
;
\
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
(
aNodeInfo
)
;
\
_elementName
*
it
=
new
_elementName
(
ni
.
forget
(
)
EXPAND
extra_args_
)
;
\
if
(
!
it
)
{
\
return
NS_ERROR_OUT_OF_MEMORY
;
\
}
\
\
nsCOMPtr
<
nsINode
>
kungFuDeathGrip
=
it
;
\
nsresult
rv
=
it
-
>
Init
(
)
;
\
nsresult
rv2
=
const_cast
<
_elementName
*
>
(
this
)
-
>
CopyInnerTo
(
it
)
;
\
if
(
NS_FAILED
(
rv2
)
)
{
\
rv
=
rv2
;
\
}
\
if
(
NS_SUCCEEDED
(
rv
)
)
{
\
kungFuDeathGrip
.
swap
(
*
aResult
)
;
\
}
\
\
return
rv
;
\
}
#
define
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
_elementName
)
\
NS_IMPL_ELEMENT_CLONE_WITH_INIT_HELPER
(
_elementName
(
)
)
#
define
NS_IMPL_ELEMENT_CLONE_WITH_INIT_AND_PARSER
(
_elementName
)
\
NS_IMPL_ELEMENT_CLONE_WITH_INIT_HELPER
(
_elementName
(
NOT_FROM_PARSER
)
)
#
endif
