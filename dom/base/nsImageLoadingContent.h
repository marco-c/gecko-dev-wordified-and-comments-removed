#
ifndef
nsImageLoadingContent_h__
#
define
nsImageLoadingContent_h__
#
include
"
imgINotificationObserver
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsAttrValue
.
h
"
class
nsIURI
;
class
nsPresContext
;
class
nsIContent
;
class
imgRequestProxy
;
namespace
mozilla
{
class
AsyncEventDispatcher
;
namespace
dom
{
struct
BindContext
;
class
Document
;
class
Element
;
}
}
#
ifdef
LoadImage
#
undef
LoadImage
#
endif
class
nsImageLoadingContent
:
public
nsIImageLoadingContent
{
protected
:
template
<
typename
T
>
using
Maybe
=
mozilla
:
:
Maybe
<
T
>
;
using
Nothing
=
mozilla
:
:
Nothing
;
using
OnNonvisible
=
mozilla
:
:
OnNonvisible
;
using
Visibility
=
mozilla
:
:
Visibility
;
public
:
nsImageLoadingContent
(
)
;
virtual
~
nsImageLoadingContent
(
)
;
NS_DECL_IMGINOTIFICATIONOBSERVER
NS_DECL_NSIIMAGELOADINGCONTENT
bool
LoadingEnabled
(
)
const
{
return
mLoadingEnabled
;
}
void
AddObserver
(
imgINotificationObserver
*
aObserver
)
;
void
RemoveObserver
(
imgINotificationObserver
*
aObserver
)
;
already_AddRefed
<
imgIRequest
>
GetRequest
(
int32_t
aRequestType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetRequestType
(
imgIRequest
*
aRequest
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIURI
>
GetCurrentURI
(
)
;
already_AddRefed
<
nsIURI
>
GetCurrentRequestFinalURI
(
)
;
void
ForceReload
(
bool
aNotify
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Element
*
FindImageMap
(
)
;
void
SetSyncDecodingHint
(
bool
aHint
)
;
void
NotifyOwnerDocumentActivityChanged
(
)
;
protected
:
enum
ImageLoadType
{
eImageLoadType_Normal
eImageLoadType_Imageset
}
;
nsresult
LoadImage
(
const
nsAString
&
aNewURI
bool
aForce
bool
aNotify
ImageLoadType
aImageLoadType
nsIPrincipal
*
aTriggeringPrincipal
=
nullptr
)
;
mozilla
:
:
EventStates
ImageState
(
)
const
;
nsresult
LoadImage
(
nsIURI
*
aNewURI
bool
aForce
bool
aNotify
ImageLoadType
aImageLoadType
nsLoadFlags
aLoadFlags
bool
aLoadStart
=
true
mozilla
:
:
dom
:
:
Document
*
aDocument
=
nullptr
nsIPrincipal
*
aTriggeringPrincipal
=
nullptr
)
;
nsresult
LoadImage
(
nsIURI
*
aNewURI
bool
aForce
bool
aNotify
ImageLoadType
aImageLoadType
nsIPrincipal
*
aTriggeringPrincipal
)
{
return
LoadImage
(
aNewURI
aForce
aNotify
aImageLoadType
LoadFlags
(
)
true
nullptr
aTriggeringPrincipal
)
;
}
mozilla
:
:
dom
:
:
Document
*
GetOurOwnerDoc
(
)
;
mozilla
:
:
dom
:
:
Document
*
GetOurCurrentDoc
(
)
;
nsIFrame
*
GetOurPrimaryFrame
(
)
;
nsPresContext
*
GetFramePresContext
(
)
;
void
CancelImageRequests
(
bool
aNotify
)
;
void
Destroy
(
)
;
virtual
mozilla
:
:
CORSMode
GetCORSMode
(
)
;
void
BindToTree
(
mozilla
:
:
dom
:
:
BindContext
&
nsINode
&
aParent
)
;
void
UnbindFromTree
(
bool
aNullParent
)
;
void
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
OnUnlockedDraw
(
)
;
void
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
;
static
nsContentPolicyType
PolicyTypeForLoad
(
ImageLoadType
aImageLoadType
)
;
void
AsyncEventRunning
(
mozilla
:
:
AsyncEventDispatcher
*
aEvent
)
;
virtual
nsIContent
*
AsContent
(
)
=
0
;
uint32_t
NaturalWidth
(
)
;
uint32_t
NaturalHeight
(
)
;
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
CSSIntSize
GetWidthHeightForImage
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
QueueDecodeAsync
(
mozilla
:
:
ErrorResult
&
aRv
)
;
enum
class
ImageDecodingType
:
uint8_t
{
Auto
Async
Sync
}
;
static
const
nsAttrValue
:
:
EnumTable
kDecodingTable
[
]
;
static
const
nsAttrValue
:
:
EnumTable
*
kDecodingTableDefault
;
private
:
void
DecodeAsync
(
RefPtr
<
mozilla
:
:
dom
:
:
Promise
>
&
&
aPromise
uint32_t
aRequestGeneration
)
;
void
MaybeResolveDecodePromises
(
)
;
void
RejectDecodePromises
(
nsresult
aStatus
)
;
void
MaybeAgeRequestGeneration
(
nsIURI
*
aNewURI
)
;
void
MaybeDeregisterActivityObserver
(
)
;
struct
ImageObserver
{
explicit
ImageObserver
(
imgINotificationObserver
*
aObserver
)
;
~
ImageObserver
(
)
;
nsCOMPtr
<
imgINotificationObserver
>
mObserver
;
ImageObserver
*
mNext
;
}
;
class
ScriptedImageObserver
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ScriptedImageObserver
)
ScriptedImageObserver
(
imgINotificationObserver
*
aObserver
RefPtr
<
imgRequestProxy
>
&
&
aCurrentRequest
RefPtr
<
imgRequestProxy
>
&
&
aPendingRequest
)
;
bool
CancelRequests
(
)
;
nsCOMPtr
<
imgINotificationObserver
>
mObserver
;
RefPtr
<
imgRequestProxy
>
mCurrentRequest
;
RefPtr
<
imgRequestProxy
>
mPendingRequest
;
private
:
~
ScriptedImageObserver
(
)
;
}
;
struct
AutoStateChanger
{
AutoStateChanger
(
nsImageLoadingContent
*
aImageContent
bool
aNotify
)
:
mImageContent
(
aImageContent
)
mNotify
(
aNotify
)
{
mImageContent
-
>
mStateChangerDepth
+
+
;
}
~
AutoStateChanger
(
)
{
mImageContent
-
>
mStateChangerDepth
-
-
;
mImageContent
-
>
UpdateImageState
(
mNotify
)
;
}
nsImageLoadingContent
*
mImageContent
;
bool
mNotify
;
}
;
friend
struct
AutoStateChanger
;
nsresult
FireEvent
(
const
nsAString
&
aEventType
bool
aIsCancelable
=
false
)
;
void
CancelPendingEvent
(
)
;
RefPtr
<
mozilla
:
:
AsyncEventDispatcher
>
mPendingEvent
;
protected
:
void
UpdateImageState
(
bool
aNotify
)
;
nsresult
StringToURI
(
const
nsAString
&
aSpec
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIURI
*
*
aURI
)
;
RefPtr
<
imgRequestProxy
>
&
PrepareNextRequest
(
ImageLoadType
aImageLoadType
)
;
RefPtr
<
imgRequestProxy
>
&
PrepareCurrentRequest
(
ImageLoadType
aImageLoadType
)
;
RefPtr
<
imgRequestProxy
>
&
PreparePendingRequest
(
ImageLoadType
aImageLoadType
)
;
void
MakePendingRequestCurrent
(
)
;
void
ClearCurrentRequest
(
nsresult
aReason
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
void
ClearPendingRequest
(
nsresult
aReason
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
bool
*
GetRegisteredFlagForRequest
(
imgIRequest
*
aRequest
)
;
void
ResetAnimationIfNeeded
(
)
;
static
bool
HaveSize
(
imgIRequest
*
aImage
)
;
void
TrackImage
(
imgIRequest
*
aImage
nsIFrame
*
aFrame
=
nullptr
)
;
void
UntrackImage
(
imgIRequest
*
aImage
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
nsLoadFlags
LoadFlags
(
)
;
RefPtr
<
imgRequestProxy
>
mCurrentRequest
;
RefPtr
<
imgRequestProxy
>
mPendingRequest
;
uint32_t
mCurrentRequestFlags
;
uint32_t
mPendingRequestFlags
;
enum
{
REQUEST_NEEDS_ANIMATION_RESET
=
0x00000001U
REQUEST_IS_TRACKED
=
0x00000004U
REQUEST_IS_IMAGESET
=
0x00000008U
}
;
nsCOMPtr
<
nsIURI
>
mCurrentURI
;
private
:
void
CloneScriptedRequests
(
imgRequestProxy
*
aRequest
)
;
void
ClearScriptedRequests
(
int32_t
aRequestType
nsresult
aReason
)
;
void
MakePendingScriptedRequestsCurrent
(
)
;
void
MaybeForceSyncDecoding
(
bool
aPrepareNextRequest
nsIFrame
*
aFrame
=
nullptr
)
;
ImageObserver
mObserverList
;
nsTArray
<
RefPtr
<
ScriptedImageObserver
>
>
mScriptedObservers
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Promise
>
>
mDecodePromises
;
mozilla
:
:
EventStates
mForcedImageState
;
mozilla
:
:
TimeStamp
mMostRecentRequestChange
;
size_t
mOutstandingDecodePromises
;
uint32_t
mRequestGeneration
;
bool
mLoadingEnabled
:
1
;
bool
mIsImageStateForced
:
1
;
bool
mLoading
:
1
;
bool
mBroken
:
1
;
protected
:
bool
mNewRequestsWillNeedAnimationReset
:
1
;
bool
mUseUrgentStartForChannel
:
1
;
bool
mLazyLoading
:
1
;
private
:
uint8_t
mStateChangerDepth
;
bool
mCurrentRequestRegistered
;
bool
mPendingRequestRegistered
;
bool
mIsStartingImageLoad
;
bool
mSyncDecodingHint
;
}
;
#
endif
