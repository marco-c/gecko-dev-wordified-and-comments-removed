#
ifndef
nsImageLoadingContent_h__
#
define
nsImageLoadingContent_h__
#
include
"
imgINotificationObserver
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
class
nsIURI
;
class
nsIDocument
;
class
nsPresContext
;
class
nsIContent
;
class
imgRequestProxy
;
namespace
mozilla
{
class
AsyncEventDispatcher
;
namespace
dom
{
class
Element
;
}
}
#
ifdef
LoadImage
#
undef
LoadImage
#
endif
class
nsImageLoadingContent
:
public
nsIImageLoadingContent
{
template
<
typename
T
>
using
Maybe
=
mozilla
:
:
Maybe
<
T
>
;
using
Nothing
=
mozilla
:
:
Nothing
;
using
OnNonvisible
=
mozilla
:
:
OnNonvisible
;
using
Visibility
=
mozilla
:
:
Visibility
;
public
:
nsImageLoadingContent
(
)
;
virtual
~
nsImageLoadingContent
(
)
;
NS_DECL_IMGINOTIFICATIONOBSERVER
NS_DECL_NSIIMAGELOADINGCONTENT
bool
LoadingEnabled
(
)
const
{
return
mLoadingEnabled
;
}
int16_t
ImageBlockingStatus
(
)
const
{
return
mImageBlockingStatus
;
}
void
AddObserver
(
imgINotificationObserver
*
aObserver
)
;
void
RemoveObserver
(
imgINotificationObserver
*
aObserver
)
;
already_AddRefed
<
imgIRequest
>
GetRequest
(
int32_t
aRequestType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetRequestType
(
imgIRequest
*
aRequest
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIURI
>
GetCurrentURI
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIURI
>
GetCurrentRequestFinalURI
(
)
;
void
ForceReload
(
bool
aNotify
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Element
*
FindImageMap
(
)
;
protected
:
enum
ImageLoadType
{
eImageLoadType_Normal
eImageLoadType_Imageset
}
;
nsresult
LoadImage
(
const
nsAString
&
aNewURI
bool
aForce
bool
aNotify
ImageLoadType
aImageLoadType
nsIPrincipal
*
aTriggeringPrincipal
=
nullptr
)
;
mozilla
:
:
EventStates
ImageState
(
)
const
;
nsresult
LoadImage
(
nsIURI
*
aNewURI
bool
aForce
bool
aNotify
ImageLoadType
aImageLoadType
bool
aLoadStart
=
true
nsIDocument
*
aDocument
=
nullptr
nsLoadFlags
aLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
nsIPrincipal
*
aTriggeringPrincipal
=
nullptr
)
;
nsresult
LoadImage
(
nsIURI
*
aNewURI
bool
aForce
bool
aNotify
ImageLoadType
aImageLoadType
nsIPrincipal
*
aTriggeringPrincipal
)
{
return
LoadImage
(
aNewURI
aForce
aNotify
aImageLoadType
true
nullptr
nsIRequest
:
:
LOAD_NORMAL
aTriggeringPrincipal
)
;
}
nsIDocument
*
GetOurOwnerDoc
(
)
;
nsIDocument
*
GetOurCurrentDoc
(
)
;
nsIFrame
*
GetOurPrimaryFrame
(
)
;
nsPresContext
*
GetFramePresContext
(
)
;
void
CancelImageRequests
(
bool
aNotify
)
;
void
DestroyImageLoadingContent
(
)
;
void
ClearBrokenState
(
)
{
mBroken
=
false
;
}
virtual
mozilla
:
:
CORSMode
GetCORSMode
(
)
;
virtual
mozilla
:
:
net
:
:
ReferrerPolicy
GetImageReferrerPolicy
(
)
;
void
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
;
void
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
;
nsresult
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
OnUnlockedDraw
(
)
;
nsresult
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
;
static
nsContentPolicyType
PolicyTypeForLoad
(
ImageLoadType
aImageLoadType
)
;
void
AsyncEventRunning
(
mozilla
:
:
AsyncEventDispatcher
*
aEvent
)
;
virtual
nsIContent
*
AsContent
(
)
=
0
;
private
:
struct
ImageObserver
{
explicit
ImageObserver
(
imgINotificationObserver
*
aObserver
)
;
~
ImageObserver
(
)
;
nsCOMPtr
<
imgINotificationObserver
>
mObserver
;
ImageObserver
*
mNext
;
}
;
class
ScriptedImageObserver
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ScriptedImageObserver
)
ScriptedImageObserver
(
imgINotificationObserver
*
aObserver
RefPtr
<
imgRequestProxy
>
&
&
aCurrentRequest
RefPtr
<
imgRequestProxy
>
&
&
aPendingRequest
)
;
bool
CancelRequests
(
)
;
nsCOMPtr
<
imgINotificationObserver
>
mObserver
;
RefPtr
<
imgRequestProxy
>
mCurrentRequest
;
RefPtr
<
imgRequestProxy
>
mPendingRequest
;
private
:
~
ScriptedImageObserver
(
)
;
}
;
struct
AutoStateChanger
{
AutoStateChanger
(
nsImageLoadingContent
*
aImageContent
bool
aNotify
)
:
mImageContent
(
aImageContent
)
mNotify
(
aNotify
)
{
mImageContent
-
>
mStateChangerDepth
+
+
;
}
~
AutoStateChanger
(
)
{
mImageContent
-
>
mStateChangerDepth
-
-
;
mImageContent
-
>
UpdateImageState
(
mNotify
)
;
}
nsImageLoadingContent
*
mImageContent
;
bool
mNotify
;
}
;
friend
struct
AutoStateChanger
;
void
UpdateImageState
(
bool
aNotify
)
;
nsresult
FireEvent
(
const
nsAString
&
aEventType
bool
aIsCancelable
=
false
)
;
void
CancelPendingEvent
(
)
;
RefPtr
<
mozilla
:
:
AsyncEventDispatcher
>
mPendingEvent
;
protected
:
nsresult
StringToURI
(
const
nsAString
&
aSpec
nsIDocument
*
aDocument
nsIURI
*
*
aURI
)
;
void
CreateStaticImageClone
(
nsImageLoadingContent
*
aDest
)
const
;
RefPtr
<
imgRequestProxy
>
&
PrepareNextRequest
(
ImageLoadType
aImageLoadType
)
;
RefPtr
<
imgRequestProxy
>
&
PrepareCurrentRequest
(
ImageLoadType
aImageLoadType
)
;
RefPtr
<
imgRequestProxy
>
&
PreparePendingRequest
(
ImageLoadType
aImageLoadType
)
;
void
MakePendingRequestCurrent
(
)
;
void
ClearCurrentRequest
(
nsresult
aReason
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
void
ClearPendingRequest
(
nsresult
aReason
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
bool
*
GetRegisteredFlagForRequest
(
imgIRequest
*
aRequest
)
;
void
ResetAnimationIfNeeded
(
)
;
static
bool
HaveSize
(
imgIRequest
*
aImage
)
;
void
TrackImage
(
imgIRequest
*
aImage
nsIFrame
*
aFrame
=
nullptr
)
;
void
UntrackImage
(
imgIRequest
*
aImage
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
RefPtr
<
imgRequestProxy
>
mCurrentRequest
;
RefPtr
<
imgRequestProxy
>
mPendingRequest
;
uint32_t
mCurrentRequestFlags
;
uint32_t
mPendingRequestFlags
;
enum
{
REQUEST_NEEDS_ANIMATION_RESET
=
0x00000001U
REQUEST_IS_TRACKED
=
0x00000004U
REQUEST_IS_IMAGESET
=
0x00000008U
}
;
nsCOMPtr
<
nsIURI
>
mCurrentURI
;
private
:
void
CloneScriptedRequests
(
imgRequestProxy
*
aRequest
)
;
void
ClearScriptedRequests
(
int32_t
aRequestType
nsresult
aReason
)
;
void
MakePendingScriptedRequestsCurrent
(
)
;
ImageObserver
mObserverList
;
nsTArray
<
RefPtr
<
ScriptedImageObserver
>
>
mScriptedObservers
;
mozilla
:
:
EventStates
mForcedImageState
;
mozilla
:
:
TimeStamp
mMostRecentRequestChange
;
int16_t
mImageBlockingStatus
;
bool
mLoadingEnabled
:
1
;
bool
mIsImageStateForced
:
1
;
bool
mLoading
:
1
;
bool
mBroken
:
1
;
bool
mUserDisabled
:
1
;
bool
mSuppressed
:
1
;
protected
:
bool
mNewRequestsWillNeedAnimationReset
:
1
;
bool
mUseUrgentStartForChannel
;
private
:
uint8_t
mStateChangerDepth
;
bool
mCurrentRequestRegistered
;
bool
mPendingRequestRegistered
;
bool
mIsStartingImageLoad
;
}
;
#
endif
