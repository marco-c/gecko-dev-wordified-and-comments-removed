#
ifndef
DocGroup_h
#
define
DocGroup_h
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
PerformanceCounter
.
h
"
#
include
"
mozilla
/
PerformanceTypes
.
h
"
namespace
mozilla
{
class
AbstractThread
;
namespace
dom
{
class
DocGroup
final
{
public
:
typedef
nsTArray
<
Document
*
>
:
:
iterator
Iterator
;
friend
class
TabGroup
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DocGroup
)
static
MOZ_MUST_USE
nsresult
GetKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aString
)
;
bool
MatchesKey
(
const
nsACString
&
aKey
)
{
return
aKey
=
=
mKey
;
}
PerformanceCounter
*
GetPerformanceCounter
(
)
{
return
mPerformanceCounter
;
}
RefPtr
<
PerformanceInfoPromise
>
ReportPerformanceInfo
(
)
;
TabGroup
*
GetTabGroup
(
)
{
return
mTabGroup
;
}
mozilla
:
:
dom
:
:
CustomElementReactionsStack
*
CustomElementReactionsStack
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mReactionsStack
)
{
mReactionsStack
=
new
mozilla
:
:
dom
:
:
CustomElementReactionsStack
(
)
;
}
return
mReactionsStack
;
}
void
RemoveDocument
(
Document
*
aWindow
)
;
Iterator
begin
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDocuments
.
begin
(
)
;
}
Iterator
end
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDocuments
.
end
(
)
;
}
nsresult
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
nsISerialEventTarget
*
EventTargetFor
(
TaskCategory
aCategory
)
const
;
AbstractThread
*
AbstractMainThreadFor
(
TaskCategory
aCategory
)
;
void
ValidateAccess
(
)
const
{
mTabGroup
-
>
ValidateAccess
(
)
;
}
bool
*
GetValidAccessPtr
(
)
;
void
SignalSlotChange
(
HTMLSlotElement
&
aSlot
)
;
void
MoveSignalSlotListTo
(
nsTArray
<
RefPtr
<
HTMLSlotElement
>
>
&
aDest
)
;
static
AutoTArray
<
RefPtr
<
DocGroup
>
2
>
*
sPendingDocGroups
;
bool
IsActive
(
)
const
;
nsresult
QueueIframePostMessages
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint64_t
aWindowId
)
;
void
TryFlushIframePostMessages
(
uint64_t
aWindowId
)
;
static
bool
TryToLoadIframesInBackground
(
)
;
private
:
DocGroup
(
TabGroup
*
aTabGroup
const
nsACString
&
aKey
)
;
~
DocGroup
(
)
;
void
FlushIframePostMessageQueue
(
)
;
nsCString
mKey
;
RefPtr
<
TabGroup
>
mTabGroup
;
nsTArray
<
Document
*
>
mDocuments
;
RefPtr
<
mozilla
:
:
dom
:
:
CustomElementReactionsStack
>
mReactionsStack
;
nsTArray
<
RefPtr
<
HTMLSlotElement
>
>
mSignalSlotList
;
RefPtr
<
mozilla
:
:
PerformanceCounter
>
mPerformanceCounter
;
RefPtr
<
mozilla
:
:
ThrottledEventQueue
>
mIframePostMessageQueue
;
nsTHashtable
<
nsUint64HashKey
>
mIframesUsedPostMessageQueue
;
}
;
}
}
#
endif
