#
ifndef
DocGroup_h
#
define
DocGroup_h
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
PerformanceCounter
.
h
"
#
include
"
mozilla
/
PerformanceTypes
.
h
"
namespace
mozilla
{
class
AbstractThread
;
namespace
dom
{
class
DocGroup
final
{
public
:
typedef
nsTArray
<
Document
*
>
:
:
iterator
Iterator
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DocGroup
)
static
already_AddRefed
<
DocGroup
>
Create
(
BrowsingContextGroup
*
aBrowsingContextGroup
const
nsACString
&
aKey
)
;
static
MOZ_MUST_USE
nsresult
GetKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aString
)
;
bool
MatchesKey
(
const
nsACString
&
aKey
)
{
return
aKey
=
=
mKey
;
}
const
nsACString
&
GetKey
(
)
const
{
return
mKey
;
}
PerformanceCounter
*
GetPerformanceCounter
(
)
{
return
mPerformanceCounter
;
}
JSExecutionManager
*
GetExecutionManager
(
)
const
{
return
mExecutionManager
;
}
void
SetExecutionManager
(
JSExecutionManager
*
)
;
RefPtr
<
PerformanceInfoPromise
>
ReportPerformanceInfo
(
)
;
BrowsingContextGroup
*
GetBrowsingContextGroup
(
)
const
{
return
mBrowsingContextGroup
;
}
mozilla
:
:
dom
:
:
DOMArena
*
ArenaAllocator
(
)
{
return
mArena
;
}
mozilla
:
:
dom
:
:
CustomElementReactionsStack
*
CustomElementReactionsStack
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mReactionsStack
)
{
mReactionsStack
=
new
mozilla
:
:
dom
:
:
CustomElementReactionsStack
(
)
;
}
return
mReactionsStack
;
}
void
AddDocument
(
Document
*
aDocument
)
;
void
RemoveDocument
(
Document
*
aDocument
)
;
Iterator
begin
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDocuments
.
begin
(
)
;
}
Iterator
end
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDocuments
.
end
(
)
;
}
nsresult
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
nsISerialEventTarget
*
EventTargetFor
(
TaskCategory
aCategory
)
const
;
AbstractThread
*
AbstractMainThreadFor
(
TaskCategory
aCategory
)
;
bool
*
GetValidAccessPtr
(
)
;
void
SignalSlotChange
(
HTMLSlotElement
&
aSlot
)
;
void
MoveSignalSlotListTo
(
nsTArray
<
RefPtr
<
HTMLSlotElement
>
>
&
aDest
)
;
static
AutoTArray
<
RefPtr
<
DocGroup
>
2
>
*
sPendingDocGroups
;
bool
IsActive
(
)
const
;
nsresult
QueueIframePostMessages
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint64_t
aWindowId
)
;
void
TryFlushIframePostMessages
(
uint64_t
aWindowId
)
;
static
bool
TryToLoadIframesInBackground
(
)
;
const
nsID
&
AgentClusterId
(
)
const
{
return
mAgentClusterId
;
}
bool
IsEmpty
(
)
const
{
return
mDocuments
.
IsEmpty
(
)
;
}
void
ClearEventTarget
(
)
;
private
:
DocGroup
(
BrowsingContextGroup
*
aBrowsingContextGroup
const
nsACString
&
aKey
)
;
~
DocGroup
(
)
;
void
FlushIframePostMessageQueue
(
)
;
nsCString
mKey
;
nsTArray
<
Document
*
>
mDocuments
;
RefPtr
<
mozilla
:
:
dom
:
:
CustomElementReactionsStack
>
mReactionsStack
;
nsTArray
<
RefPtr
<
HTMLSlotElement
>
>
mSignalSlotList
;
RefPtr
<
mozilla
:
:
PerformanceCounter
>
mPerformanceCounter
;
RefPtr
<
BrowsingContextGroup
>
mBrowsingContextGroup
;
RefPtr
<
mozilla
:
:
ThrottledEventQueue
>
mIframePostMessageQueue
;
nsTHashtable
<
nsUint64HashKey
>
mIframesUsedPostMessageQueue
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
RefPtr
<
AbstractThread
>
mAbstractThread
;
RefPtr
<
JSExecutionManager
>
mExecutionManager
;
const
nsID
mAgentClusterId
;
RefPtr
<
mozilla
:
:
dom
:
:
DOMArena
>
mArena
;
}
;
}
}
#
endif
