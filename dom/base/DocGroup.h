#
ifndef
DocGroup_h
#
define
DocGroup_h
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
Dispatcher
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
namespace
mozilla
{
class
AbstractThread
;
namespace
dom
{
class
DocGroup
final
:
public
Dispatcher
{
public
:
typedef
nsTArray
<
nsIDocument
*
>
:
:
iterator
Iterator
;
friend
class
TabGroup
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DocGroup
override
)
static
MOZ_MUST_USE
nsresult
GetKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aString
)
;
bool
MatchesKey
(
const
nsACString
&
aKey
)
{
return
aKey
=
=
mKey
;
}
TabGroup
*
GetTabGroup
(
)
{
return
mTabGroup
;
}
mozilla
:
:
dom
:
:
CustomElementReactionsStack
*
CustomElementReactionsStack
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mReactionsStack
)
{
mReactionsStack
=
new
mozilla
:
:
dom
:
:
CustomElementReactionsStack
(
)
;
}
return
mReactionsStack
;
}
void
RemoveDocument
(
nsIDocument
*
aWindow
)
;
Iterator
begin
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDocuments
.
begin
(
)
;
}
Iterator
end
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mDocuments
.
end
(
)
;
}
virtual
nsresult
Dispatch
(
const
char
*
aName
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
override
;
virtual
nsIEventTarget
*
EventTargetFor
(
TaskCategory
aCategory
)
const
override
;
void
ValidateAccess
(
)
const
{
mTabGroup
-
>
ValidateAccess
(
)
;
}
bool
AccessAllowed
(
)
const
{
return
mTabGroup
-
>
AccessAllowed
(
)
;
}
bool
*
GetValidAccessPtr
(
)
;
private
:
virtual
AbstractThread
*
AbstractMainThreadForImpl
(
TaskCategory
aCategory
)
override
;
DocGroup
(
TabGroup
*
aTabGroup
const
nsACString
&
aKey
)
;
~
DocGroup
(
)
;
nsCString
mKey
;
RefPtr
<
TabGroup
>
mTabGroup
;
nsTArray
<
nsIDocument
*
>
mDocuments
;
RefPtr
<
mozilla
:
:
dom
:
:
CustomElementReactionsStack
>
mReactionsStack
;
}
;
}
}
#
endif
