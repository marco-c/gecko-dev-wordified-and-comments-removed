#
ifndef
nsIContent_h___
#
define
nsIContent_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
dom
/
BorrowedAttrInfo
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsAtom
;
class
nsIURI
;
class
nsAttrValue
;
class
nsAttrName
;
class
nsTextFragment
;
class
nsIFrame
;
class
nsXBLBinding
;
class
nsITextControlElement
;
namespace
mozilla
{
class
EventChainPreVisitor
;
struct
URLExtraData
;
namespace
dom
{
class
ShadowRoot
;
class
HTMLSlotElement
;
}
namespace
widget
{
struct
IMEState
;
}
}
enum
nsLinkState
{
eLinkState_Unvisited
=
1
eLinkState_Visited
=
2
eLinkState_NotLink
=
3
}
;
#
define
NS_ICONTENT_IID
\
{
\
0x8e1bab9d
0x8815
0x4d2c
{
\
0xa2
0x4d
0x7a
0xba
0x52
0x39
0xdc
0x22
\
}
\
}
class
nsIContent
:
public
nsINode
{
public
:
typedef
mozilla
:
:
widget
:
:
IMEState
IMEState
;
void
ConstructUbiNode
(
void
*
storage
)
override
;
#
ifdef
MOZILLA_INTERNAL_API
explicit
nsIContent
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsINode
(
std
:
:
move
(
aNodeInfo
)
)
{
MOZ_ASSERT
(
mNodeInfo
)
;
SetNodeIsContent
(
)
;
}
#
endif
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_ICONTENT_IID
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsIContent
)
NS_IMPL_FROMNODE_HELPER
(
nsIContent
IsContent
(
)
)
virtual
nsresult
BindToTree
(
Document
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
=
0
;
virtual
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
=
0
;
enum
{
eAllChildren
=
0
eAllButXBL
=
1
eSkipPlaceholderContent
=
2
eSkipDocumentLevelNativeAnonymousContent
=
4
}
;
virtual
already_AddRefed
<
nsINodeList
>
GetChildren
(
uint32_t
aFilter
)
=
0
;
void
SetIsNativeAnonymousRoot
(
)
{
SetFlags
(
NODE_IS_ANONYMOUS_ROOT
|
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
|
NODE_IS_NATIVE_ANONYMOUS_ROOT
)
;
}
nsIContent
*
FindFirstNonChromeOnlyAccessContent
(
)
const
;
bool
IsRootOfAnonymousSubtree
(
)
const
{
NS_ASSERTION
(
!
IsRootOfNativeAnonymousSubtree
(
)
|
|
(
GetParent
(
)
&
&
GetBindingParent
(
)
=
=
GetParent
(
)
)
"
root
of
native
anonymous
subtree
must
have
parent
equal
"
"
to
binding
parent
"
)
;
NS_ASSERTION
(
!
GetParent
(
)
|
|
(
(
GetBindingParent
(
)
=
=
GetParent
(
)
)
=
=
HasFlag
(
NODE_IS_ANONYMOUS_ROOT
)
)
|
|
(
GetBindingParent
(
)
&
&
(
GetBindingParent
(
)
=
=
GetParent
(
)
-
>
GetBindingParent
(
)
)
=
=
HasFlag
(
NODE_IS_ANONYMOUS_ROOT
)
)
"
For
nodes
with
parent
flag
and
GetBindingParent
(
)
check
"
"
should
match
"
)
;
return
HasFlag
(
NODE_IS_ANONYMOUS_ROOT
)
;
}
inline
bool
IsInAnonymousSubtree
(
)
const
;
inline
bool
IsInHTMLDocument
(
)
const
;
inline
bool
IsInChromeDocument
(
)
const
;
inline
int32_t
GetNameSpaceID
(
)
const
{
return
mNodeInfo
-
>
NamespaceID
(
)
;
}
inline
bool
IsHTMLElement
(
)
const
{
return
IsInNamespace
(
kNameSpaceID_XHTML
)
;
}
inline
bool
IsHTMLElement
(
const
nsAtom
*
aTag
)
const
{
return
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_XHTML
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsHTMLElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsSVGElement
(
)
const
{
return
IsInNamespace
(
kNameSpaceID_SVG
)
;
}
inline
bool
IsSVGElement
(
const
nsAtom
*
aTag
)
const
{
return
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_SVG
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfSVGElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsSVGElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsXULElement
(
)
const
{
return
IsInNamespace
(
kNameSpaceID_XUL
)
;
}
inline
bool
IsXULElement
(
const
nsAtom
*
aTag
)
const
{
return
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_XUL
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfXULElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsXULElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsMathMLElement
(
)
const
{
return
IsInNamespace
(
kNameSpaceID_MathML
)
;
}
inline
bool
IsMathMLElement
(
const
nsAtom
*
aTag
)
const
{
return
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_MathML
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfMathMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsMathMLElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsActiveChildrenElement
(
)
const
;
bool
IsGeneratedContentContainerForBefore
(
)
const
{
return
IsRootOfNativeAnonymousSubtree
(
)
&
&
mNodeInfo
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentbefore
;
}
bool
IsGeneratedContentContainerForAfter
(
)
const
{
return
IsRootOfNativeAnonymousSubtree
(
)
&
&
mNodeInfo
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentafter
;
}
virtual
const
nsTextFragment
*
GetText
(
)
=
0
;
virtual
uint32_t
TextLength
(
)
const
=
0
;
bool
IsEventAttributeName
(
nsAtom
*
aName
)
;
virtual
bool
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
false
;
}
virtual
bool
TextIsOnlyWhitespace
(
)
=
0
;
virtual
bool
ThreadSafeTextIsOnlyWhitespace
(
)
const
=
0
;
bool
IsFocusable
(
int32_t
*
aTabIndex
=
nullptr
bool
aWithMouse
=
false
)
;
virtual
bool
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
;
virtual
bool
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
{
return
false
;
}
virtual
IMEState
GetDesiredIMEState
(
)
;
virtual
nsIContent
*
GetBindingParent
(
)
const
{
const
nsExtendedContentSlots
*
slots
=
GetExistingExtendedContentSlots
(
)
;
return
slots
?
slots
-
>
mBindingParent
.
get
(
)
:
nullptr
;
}
nsXBLBinding
*
GetXBLBinding
(
)
const
{
if
(
!
HasFlag
(
NODE_MAY_BE_IN_BINDING_MNGR
)
)
{
return
nullptr
;
}
return
DoGetXBLBinding
(
)
;
}
virtual
nsXBLBinding
*
DoGetXBLBinding
(
)
const
=
0
;
inline
mozilla
:
:
dom
:
:
ShadowRoot
*
GetShadowRoot
(
)
const
;
mozilla
:
:
dom
:
:
ShadowRoot
*
GetContainingShadow
(
)
const
{
const
nsExtendedContentSlots
*
slots
=
GetExistingExtendedContentSlots
(
)
;
return
slots
?
slots
-
>
mContainingShadow
.
get
(
)
:
nullptr
;
}
nsIContent
*
GetContainingShadowHost
(
)
const
;
mozilla
:
:
dom
:
:
HTMLSlotElement
*
GetAssignedSlot
(
)
const
{
const
nsExtendedContentSlots
*
slots
=
GetExistingExtendedContentSlots
(
)
;
return
slots
?
slots
-
>
mAssignedSlot
.
get
(
)
:
nullptr
;
}
void
SetAssignedSlot
(
mozilla
:
:
dom
:
:
HTMLSlotElement
*
aSlot
)
;
mozilla
:
:
dom
:
:
HTMLSlotElement
*
GetAssignedSlotByMode
(
)
const
;
nsIContent
*
GetXBLInsertionParent
(
)
const
{
nsIContent
*
ip
=
GetXBLInsertionPoint
(
)
;
return
ip
?
ip
-
>
GetParent
(
)
:
nullptr
;
}
nsIContent
*
GetXBLInsertionPoint
(
)
const
{
const
nsExtendedContentSlots
*
slots
=
GetExistingExtendedContentSlots
(
)
;
return
slots
?
slots
-
>
mXBLInsertionPoint
.
get
(
)
:
nullptr
;
}
void
SetXBLInsertionPoint
(
nsIContent
*
aContent
)
;
inline
nsIContent
*
GetFlattenedTreeParent
(
)
const
;
virtual
bool
IsLink
(
nsIURI
*
*
aURI
)
const
=
0
;
virtual
already_AddRefed
<
nsIURI
>
GetHrefURI
(
)
const
{
return
nullptr
;
}
virtual
void
DoneCreatingElement
(
)
{
}
virtual
void
DoneAddingChildren
(
bool
aHaveNotified
)
{
}
virtual
bool
IsDoneAddingChildren
(
)
{
return
true
;
}
nsAtom
*
GetID
(
)
const
{
if
(
HasID
(
)
)
{
return
DoGetID
(
)
;
}
return
nullptr
;
}
virtual
void
UpdateEditableState
(
bool
aNotify
)
;
virtual
void
DestroyContent
(
)
{
}
virtual
void
SaveSubtreeState
(
)
=
0
;
nsIFrame
*
GetPrimaryFrame
(
)
const
{
return
(
IsInUncomposedDoc
(
)
|
|
IsInShadowTree
(
)
)
?
mPrimaryFrame
:
nullptr
;
}
nsIFrame
*
GetPrimaryFrame
(
mozilla
:
:
FlushType
aType
)
;
inline
void
SetPrimaryFrame
(
nsIFrame
*
aFrame
)
;
nsresult
LookupNamespaceURIInternal
(
const
nsAString
&
aNamespacePrefix
nsAString
&
aNamespaceURI
)
const
;
bool
HasIndependentSelection
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetEditingHost
(
)
;
bool
SupportsLangAttr
(
)
const
{
return
IsHTMLElement
(
)
|
|
IsSVGElement
(
)
|
|
IsXULElement
(
)
;
}
nsAtom
*
GetLang
(
)
const
;
bool
GetLang
(
nsAString
&
aResult
)
const
{
if
(
auto
*
lang
=
GetLang
(
)
)
{
aResult
.
Assign
(
nsDependentAtomString
(
lang
)
)
;
return
true
;
}
return
false
;
}
virtual
already_AddRefed
<
nsIURI
>
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
override
;
nsIURI
*
GetBaseURIForStyleAttr
(
)
const
;
already_AddRefed
<
mozilla
:
:
URLExtraData
>
GetURLDataForStyleAttr
(
nsIPrincipal
*
aSubjectPrincipal
=
nullptr
)
const
;
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
bool
IsPurple
(
)
const
{
return
mRefCnt
.
IsPurple
(
)
;
}
void
RemovePurple
(
)
{
mRefCnt
.
RemovePurple
(
)
;
}
bool
OwnedOnlyByTheDOMTree
(
)
{
uint32_t
rc
=
mRefCnt
.
get
(
)
;
if
(
GetParent
(
)
)
{
-
-
rc
;
}
rc
-
=
GetChildCount
(
)
;
return
rc
=
=
0
;
}
protected
:
class
nsExtendedContentSlots
{
public
:
nsExtendedContentSlots
(
)
;
virtual
~
nsExtendedContentSlots
(
)
;
virtual
void
TraverseExtendedSlots
(
nsCycleCollectionTraversalCallback
&
)
;
virtual
void
UnlinkExtendedSlots
(
)
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCOMPtr
<
nsIContent
>
mBindingParent
;
nsCOMPtr
<
nsIContent
>
mXBLInsertionPoint
;
RefPtr
<
mozilla
:
:
dom
:
:
ShadowRoot
>
mContainingShadow
;
RefPtr
<
mozilla
:
:
dom
:
:
HTMLSlotElement
>
mAssignedSlot
;
}
;
class
nsContentSlots
:
public
nsINode
:
:
nsSlots
{
public
:
nsContentSlots
(
)
:
nsINode
:
:
nsSlots
(
)
mExtendedSlots
(
0
)
{
}
~
nsContentSlots
(
)
{
if
(
!
(
mExtendedSlots
&
sNonOwningExtendedSlotsFlag
)
)
{
delete
GetExtendedContentSlots
(
)
;
}
}
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
override
{
nsINode
:
:
nsSlots
:
:
Traverse
(
aCb
)
;
if
(
mExtendedSlots
)
{
GetExtendedContentSlots
(
)
-
>
TraverseExtendedSlots
(
aCb
)
;
}
}
void
Unlink
(
)
override
{
nsINode
:
:
nsSlots
:
:
Unlink
(
)
;
if
(
mExtendedSlots
)
{
GetExtendedContentSlots
(
)
-
>
UnlinkExtendedSlots
(
)
;
}
}
void
SetExtendedContentSlots
(
nsExtendedContentSlots
*
aSlots
bool
aOwning
)
{
mExtendedSlots
=
reinterpret_cast
<
uintptr_t
>
(
aSlots
)
;
if
(
!
aOwning
)
{
mExtendedSlots
|
=
sNonOwningExtendedSlotsFlag
;
}
}
bool
OwnsExtendedSlots
(
)
const
{
return
!
(
mExtendedSlots
&
sNonOwningExtendedSlotsFlag
)
;
}
nsExtendedContentSlots
*
GetExtendedContentSlots
(
)
const
{
return
reinterpret_cast
<
nsExtendedContentSlots
*
>
(
mExtendedSlots
&
~
sNonOwningExtendedSlotsFlag
)
;
}
private
:
static
const
uintptr_t
sNonOwningExtendedSlotsFlag
=
1u
;
uintptr_t
mExtendedSlots
;
}
;
nsContentSlots
*
CreateSlots
(
)
override
{
return
new
nsContentSlots
(
)
;
}
nsContentSlots
*
ContentSlots
(
)
{
return
static_cast
<
nsContentSlots
*
>
(
Slots
(
)
)
;
}
const
nsContentSlots
*
GetExistingContentSlots
(
)
const
{
return
static_cast
<
nsContentSlots
*
>
(
GetExistingSlots
(
)
)
;
}
nsContentSlots
*
GetExistingContentSlots
(
)
{
return
static_cast
<
nsContentSlots
*
>
(
GetExistingSlots
(
)
)
;
}
virtual
nsExtendedContentSlots
*
CreateExtendedSlots
(
)
{
return
new
nsExtendedContentSlots
(
)
;
}
const
nsExtendedContentSlots
*
GetExistingExtendedContentSlots
(
)
const
{
const
nsContentSlots
*
slots
=
GetExistingContentSlots
(
)
;
return
slots
?
slots
-
>
GetExtendedContentSlots
(
)
:
nullptr
;
}
nsExtendedContentSlots
*
GetExistingExtendedContentSlots
(
)
{
nsContentSlots
*
slots
=
GetExistingContentSlots
(
)
;
return
slots
?
slots
-
>
GetExtendedContentSlots
(
)
:
nullptr
;
}
nsExtendedContentSlots
*
ExtendedContentSlots
(
)
{
nsContentSlots
*
slots
=
ContentSlots
(
)
;
if
(
!
slots
-
>
GetExtendedContentSlots
(
)
)
{
slots
-
>
SetExtendedContentSlots
(
CreateExtendedSlots
(
)
true
)
;
}
return
slots
-
>
GetExtendedContentSlots
(
)
;
}
nsAtom
*
DoGetID
(
)
const
;
~
nsIContent
(
)
{
}
public
:
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
)
const
=
0
;
virtual
void
DumpContent
(
FILE
*
out
=
stdout
int32_t
aIndent
=
0
bool
aDumpAll
=
true
)
const
=
0
;
#
endif
enum
ETabFocusType
{
eTabFocus_textControlsMask
=
(
1
<
<
0
)
eTabFocus_formElementsMask
=
(
1
<
<
1
)
eTabFocus_linksMask
=
(
1
<
<
2
)
eTabFocus_any
=
1
+
(
1
<
<
1
)
+
(
1
<
<
2
)
}
;
static
int32_t
sTabFocusModel
;
static
bool
sTabFocusModelAppliesToXUL
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsIContent
NS_ICONTENT_IID
)
inline
nsIContent
*
nsINode
:
:
AsContent
(
)
{
MOZ_ASSERT
(
IsContent
(
)
)
;
return
static_cast
<
nsIContent
*
>
(
this
)
;
}
inline
const
nsIContent
*
nsINode
:
:
AsContent
(
)
const
{
return
const_cast
<
nsINode
*
>
(
this
)
-
>
AsContent
(
)
;
}
#
endif
