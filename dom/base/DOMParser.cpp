#
include
"
mozilla
/
dom
/
DOMParser
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
NullPrincipal
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
DOMParser
:
:
DOMParser
(
)
:
mAttemptedInit
(
false
)
mForceEnableXULXBL
(
false
)
{
}
DOMParser
:
:
~
DOMParser
(
)
{
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DOMParser
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMParser
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMParser
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
DOMParser
mOwner
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
DOMParser
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
DOMParser
)
static
const
char
*
StringFromSupportedType
(
SupportedType
aType
)
{
return
SupportedTypeValues
:
:
strings
[
static_cast
<
int
>
(
aType
)
]
.
value
;
}
already_AddRefed
<
nsIDocument
>
DOMParser
:
:
ParseFromString
(
const
nsAString
&
aStr
SupportedType
aType
ErrorResult
&
rv
)
{
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
rv
=
ParseFromString
(
aStr
StringFromSupportedType
(
aType
)
getter_AddRefs
(
domDocument
)
)
;
nsCOMPtr
<
nsIDocument
>
document
(
do_QueryInterface
(
domDocument
)
)
;
return
document
.
forget
(
)
;
}
NS_IMETHODIMP
DOMParser
:
:
ParseFromString
(
const
char16_t
*
str
const
char
*
contentType
nsIDOMDocument
*
*
aResult
)
{
NS_ENSURE_ARG
(
str
)
;
return
ParseFromString
(
nsDependentString
(
str
)
contentType
aResult
)
;
}
nsresult
DOMParser
:
:
ParseFromString
(
const
nsAString
&
str
const
char
*
contentType
nsIDOMDocument
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
nsresult
rv
;
if
(
!
nsCRT
:
:
strcmp
(
contentType
"
text
/
html
"
)
)
{
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
rv
=
SetUpDocument
(
DocumentFlavorHTML
getter_AddRefs
(
domDocument
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocument
>
document
=
do_QueryInterface
(
domDocument
)
;
if
(
mForceEnableXULXBL
)
{
document
-
>
ForceEnableXULXBL
(
)
;
}
rv
=
nsContentUtils
:
:
ParseDocumentHTML
(
str
document
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
domDocument
.
forget
(
aResult
)
;
return
rv
;
}
nsAutoCString
utf8str
;
if
(
!
AppendUTF16toUTF8
(
str
utf8str
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
utf8str
.
get
(
)
utf8str
.
Length
(
)
NS_ASSIGNMENT_DEPEND
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
ParseFromStream
(
stream
"
UTF
-
8
"
utf8str
.
Length
(
)
contentType
aResult
)
;
}
already_AddRefed
<
nsIDocument
>
DOMParser
:
:
ParseFromBuffer
(
const
Sequence
<
uint8_t
>
&
aBuf
uint32_t
aBufLen
SupportedType
aType
ErrorResult
&
rv
)
{
if
(
aBufLen
>
aBuf
.
Length
(
)
)
{
rv
.
Throw
(
NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
rv
=
DOMParser
:
:
ParseFromBuffer
(
aBuf
.
Elements
(
)
aBufLen
StringFromSupportedType
(
aType
)
getter_AddRefs
(
domDocument
)
)
;
nsCOMPtr
<
nsIDocument
>
document
(
do_QueryInterface
(
domDocument
)
)
;
return
document
.
forget
(
)
;
}
already_AddRefed
<
nsIDocument
>
DOMParser
:
:
ParseFromBuffer
(
const
Uint8Array
&
aBuf
uint32_t
aBufLen
SupportedType
aType
ErrorResult
&
rv
)
{
aBuf
.
ComputeLengthAndData
(
)
;
if
(
aBufLen
>
aBuf
.
Length
(
)
)
{
rv
.
Throw
(
NS_ERROR_XPC_NOT_ENOUGH_ELEMENTS_IN_ARRAY
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
rv
=
DOMParser
:
:
ParseFromBuffer
(
aBuf
.
Data
(
)
aBufLen
StringFromSupportedType
(
aType
)
getter_AddRefs
(
domDocument
)
)
;
nsCOMPtr
<
nsIDocument
>
document
(
do_QueryInterface
(
domDocument
)
)
;
return
document
.
forget
(
)
;
}
NS_IMETHODIMP
DOMParser
:
:
ParseFromBuffer
(
const
uint8_t
*
buf
uint32_t
bufLen
const
char
*
contentType
nsIDOMDocument
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
buf
)
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
reinterpret_cast
<
const
char
*
>
(
buf
)
bufLen
NS_ASSIGNMENT_DEPEND
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
ParseFromStream
(
stream
nullptr
bufLen
contentType
aResult
)
;
}
already_AddRefed
<
nsIDocument
>
DOMParser
:
:
ParseFromStream
(
nsIInputStream
*
aStream
const
nsAString
&
aCharset
int32_t
aContentLength
SupportedType
aType
ErrorResult
&
rv
)
{
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
rv
=
DOMParser
:
:
ParseFromStream
(
aStream
NS_ConvertUTF16toUTF8
(
aCharset
)
.
get
(
)
aContentLength
StringFromSupportedType
(
aType
)
getter_AddRefs
(
domDocument
)
)
;
nsCOMPtr
<
nsIDocument
>
document
(
do_QueryInterface
(
domDocument
)
)
;
return
document
.
forget
(
)
;
}
NS_IMETHODIMP
DOMParser
:
:
ParseFromStream
(
nsIInputStream
*
aStream
const
char
*
aCharset
int32_t
aContentLength
const
char
*
aContentType
nsIDOMDocument
*
*
aResult
)
{
NS_ENSURE_ARG
(
aStream
)
;
NS_ENSURE_ARG
(
aContentType
)
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
nullptr
;
bool
svg
=
nsCRT
:
:
strcmp
(
aContentType
"
image
/
svg
+
xml
"
)
=
=
0
;
if
(
(
nsCRT
:
:
strcmp
(
aContentType
"
text
/
xml
"
)
!
=
0
)
&
&
(
nsCRT
:
:
strcmp
(
aContentType
"
application
/
xml
"
)
!
=
0
)
&
&
(
nsCRT
:
:
strcmp
(
aContentType
"
application
/
xhtml
+
xml
"
)
!
=
0
)
&
&
!
svg
)
return
NS_ERROR_NOT_IMPLEMENTED
;
nsresult
rv
;
nsCOMPtr
<
nsIInputStream
>
stream
=
aStream
;
if
(
!
NS_InputStreamIsBuffered
(
stream
)
)
{
nsCOMPtr
<
nsIInputStream
>
bufferedStream
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufferedStream
)
stream
.
forget
(
)
4096
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
stream
=
bufferedStream
;
}
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
rv
=
SetUpDocument
(
svg
?
DocumentFlavorSVG
:
DocumentFlavorLegacyGuess
getter_AddRefs
(
domDocument
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
parserChannel
;
NS_NewInputStreamChannel
(
getter_AddRefs
(
parserChannel
)
mDocumentURI
nullptr
mPrincipal
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
nsIContentPolicy
:
:
TYPE_OTHER
nsDependentCString
(
aContentType
)
)
;
NS_ENSURE_STATE
(
parserChannel
)
;
if
(
aCharset
)
{
parserChannel
-
>
SetContentCharset
(
nsDependentCString
(
aCharset
)
)
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
;
nsCOMPtr
<
nsIDocument
>
document
(
do_QueryInterface
(
domDocument
)
)
;
if
(
!
document
)
return
NS_ERROR_FAILURE
;
if
(
mForceEnableXULXBL
)
{
document
-
>
ForceEnableXULXBL
(
)
;
}
rv
=
document
-
>
StartDocumentLoad
(
kLoadAsData
parserChannel
nullptr
nullptr
getter_AddRefs
(
listener
)
false
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
listener
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
status
;
rv
=
listener
-
>
OnStartRequest
(
parserChannel
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
parserChannel
-
>
Cancel
(
rv
)
;
parserChannel
-
>
GetStatus
(
&
status
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
status
)
)
{
rv
=
listener
-
>
OnDataAvailable
(
parserChannel
nullptr
stream
0
aContentLength
)
;
if
(
NS_FAILED
(
rv
)
)
parserChannel
-
>
Cancel
(
rv
)
;
parserChannel
-
>
GetStatus
(
&
status
)
;
}
rv
=
listener
-
>
OnStopRequest
(
parserChannel
nullptr
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
domDocument
.
swap
(
*
aResult
)
;
return
NS_OK
;
}
nsresult
DOMParser
:
:
Init
(
nsIPrincipal
*
principal
nsIURI
*
documentURI
nsIURI
*
baseURI
nsIGlobalObject
*
aScriptObject
)
{
NS_ENSURE_STATE
(
!
mAttemptedInit
)
;
mAttemptedInit
=
true
;
NS_ENSURE_ARG
(
principal
|
|
documentURI
)
;
mDocumentURI
=
documentURI
;
if
(
!
mDocumentURI
)
{
principal
-
>
GetURI
(
getter_AddRefs
(
mDocumentURI
)
)
;
if
(
!
mDocumentURI
&
&
!
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
mScriptHandlingObject
=
do_GetWeakReference
(
aScriptObject
)
;
mPrincipal
=
principal
;
nsresult
rv
;
if
(
!
mPrincipal
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
nullptr
nsContentUtils
:
:
eDOM_PROPERTIES
"
ChromeScriptedDOMParserWithoutPrincipal
"
nullptr
0
documentURI
)
;
OriginAttributes
attrs
;
mPrincipal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
mDocumentURI
attrs
)
;
NS_ENSURE_TRUE
(
mPrincipal
NS_ERROR_FAILURE
)
;
}
else
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
mPrincipal
)
)
{
mForceEnableXULXBL
=
true
;
mPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
if
(
!
mDocumentURI
)
{
rv
=
mPrincipal
-
>
GetURI
(
getter_AddRefs
(
mDocumentURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
mBaseURI
=
baseURI
;
MOZ_ASSERT
(
mPrincipal
"
Must
have
principal
"
)
;
MOZ_ASSERT
(
mDocumentURI
"
Must
have
document
URI
"
)
;
return
NS_OK
;
}
already_AddRefed
<
DOMParser
>
DOMParser
:
:
Constructor
(
const
GlobalObject
&
aOwner
ErrorResult
&
rv
)
{
RefPtr
<
DOMParser
>
domParser
=
new
DOMParser
(
aOwner
.
GetAsSupports
(
)
)
;
rv
=
domParser
-
>
InitInternal
(
aOwner
.
GetAsSupports
(
)
nsContentUtils
:
:
SubjectPrincipal
(
)
nullptr
nullptr
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
domParser
.
forget
(
)
;
}
nsresult
DOMParser
:
:
InitInternal
(
nsISupports
*
aOwner
nsIPrincipal
*
prin
nsIURI
*
documentURI
nsIURI
*
baseURI
)
{
AttemptedInitMarker
marker
(
&
mAttemptedInit
)
;
if
(
!
documentURI
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aOwner
)
;
if
(
!
window
)
{
return
NS_ERROR_UNEXPECTED
;
}
baseURI
=
window
-
>
GetDocBaseURI
(
)
;
documentURI
=
window
-
>
GetDocumentURI
(
)
;
if
(
!
documentURI
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
nsCOMPtr
<
nsIGlobalObject
>
scriptglobal
=
do_QueryInterface
(
aOwner
)
;
return
Init
(
prin
documentURI
baseURI
scriptglobal
)
;
}
nsresult
DOMParser
:
:
SetUpDocument
(
DocumentFlavor
aFlavor
nsIDOMDocument
*
*
aResult
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptHandlingObject
=
do_QueryReferent
(
mScriptHandlingObject
)
;
nsresult
rv
;
if
(
!
mPrincipal
)
{
NS_ENSURE_TRUE
(
!
mAttemptedInit
NS_ERROR_NOT_INITIALIZED
)
;
AttemptedInitMarker
marker
(
&
mAttemptedInit
)
;
nsCOMPtr
<
nsIPrincipal
>
prin
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
rv
=
Init
(
prin
nullptr
nullptr
scriptHandlingObject
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ASSERTION
(
mPrincipal
"
Must
have
principal
by
now
"
)
;
NS_ASSERTION
(
mDocumentURI
"
Must
have
document
URI
by
now
"
)
;
return
NS_NewDOMDocument
(
aResult
EmptyString
(
)
EmptyString
(
)
nullptr
mDocumentURI
mBaseURI
mPrincipal
true
scriptHandlingObject
aFlavor
)
;
}
