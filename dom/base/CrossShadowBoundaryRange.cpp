#
include
"
mozilla
/
dom
/
CrossShadowBoundaryRange
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
:
:
dom
{
template
already_AddRefed
<
CrossShadowBoundaryRange
>
CrossShadowBoundaryRange
:
:
Create
(
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
nsRange
*
aOwner
)
;
template
already_AddRefed
<
CrossShadowBoundaryRange
>
CrossShadowBoundaryRange
:
:
Create
(
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
nsRange
*
aOwner
)
;
template
already_AddRefed
<
CrossShadowBoundaryRange
>
CrossShadowBoundaryRange
:
:
Create
(
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
nsRange
*
aOwner
)
;
template
already_AddRefed
<
CrossShadowBoundaryRange
>
CrossShadowBoundaryRange
:
:
Create
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
nsRange
*
aOwner
)
;
template
void
CrossShadowBoundaryRange
:
:
DoSetRange
(
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
nsINode
*
aRootNode
nsRange
*
aOwner
)
;
template
void
CrossShadowBoundaryRange
:
:
DoSetRange
(
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
nsINode
*
aRootNode
nsRange
*
aOwner
)
;
template
void
CrossShadowBoundaryRange
:
:
DoSetRange
(
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
nsINode
*
aRootNode
nsRange
*
aOwner
)
;
template
void
CrossShadowBoundaryRange
:
:
DoSetRange
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
nsINode
*
aRootNode
nsRange
*
aOwner
)
;
template
nsresult
CrossShadowBoundaryRange
:
:
SetStartAndEnd
(
const
RangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
nsresult
CrossShadowBoundaryRange
:
:
SetStartAndEnd
(
const
RangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
template
nsresult
CrossShadowBoundaryRange
:
:
SetStartAndEnd
(
const
RawRangeBoundary
&
aStartBoundary
const
RangeBoundary
&
aEndBoundary
)
;
template
nsresult
CrossShadowBoundaryRange
:
:
SetStartAndEnd
(
const
RawRangeBoundary
&
aStartBoundary
const
RawRangeBoundary
&
aEndBoundary
)
;
nsTArray
<
RefPtr
<
CrossShadowBoundaryRange
>
>
*
CrossShadowBoundaryRange
:
:
sCachedRanges
=
nullptr
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
CrossShadowBoundaryRange
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_INTERRUPTABLE_LAST_RELEASE
(
CrossShadowBoundaryRange
DoSetRange
(
RawRangeBoundary
(
TreeKind
:
:
Flat
)
RawRangeBoundary
(
TreeKind
:
:
Flat
)
nullptr
nullptr
)
AbstractRange
:
:
MaybeCacheToReuse
(
*
this
)
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CrossShadowBoundaryRange
)
NS_INTERFACE_MAP_END_INHERITING
(
CrossShadowBoundaryRange
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
CrossShadowBoundaryRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
CrossShadowBoundaryRange
StaticRange
)
if
(
tmp
-
>
mCommonAncestor
)
{
tmp
-
>
mCommonAncestor
-
>
RemoveMutationObserver
(
tmp
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCommonAncestor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
CrossShadowBoundaryRange
StaticRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCommonAncestor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
CrossShadowBoundaryRange
StaticRange
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
already_AddRefed
<
CrossShadowBoundaryRange
>
CrossShadowBoundaryRange
:
:
Create
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
nsRange
*
aOwner
)
{
RefPtr
<
CrossShadowBoundaryRange
>
range
;
if
(
!
sCachedRanges
|
|
sCachedRanges
-
>
IsEmpty
(
)
)
{
range
=
new
CrossShadowBoundaryRange
(
aStartBoundary
.
GetContainer
(
)
aOwner
)
;
}
else
{
range
=
sCachedRanges
-
>
PopLastElement
(
)
.
forget
(
)
;
}
range
-
>
Init
(
aStartBoundary
.
GetContainer
(
)
)
;
range
-
>
DoSetRange
(
aStartBoundary
aEndBoundary
nullptr
aOwner
)
;
return
range
.
forget
(
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
void
CrossShadowBoundaryRange
:
:
DoSetRange
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
nsINode
*
aRootNode
nsRange
*
aOwner
)
{
StaticRange
:
:
DoSetRange
(
aStartBoundary
aEndBoundary
nullptr
)
;
nsINode
*
startRoot
=
RangeUtils
:
:
ComputeRootNode
(
mStart
.
GetContainer
(
)
)
;
nsINode
*
endRoot
=
RangeUtils
:
:
ComputeRootNode
(
mEnd
.
GetContainer
(
)
)
;
nsINode
*
previousCommonAncestor
=
mCommonAncestor
;
mCommonAncestor
=
startRoot
=
=
endRoot
?
startRoot
:
nsContentUtils
:
:
GetClosestCommonShadowIncludingInclusiveAncestor
(
mStart
.
GetContainer
(
)
mEnd
.
GetContainer
(
)
)
;
MOZ_ASSERT_IF
(
mOwner
mOwner
=
=
aOwner
|
|
!
aOwner
)
;
mOwner
=
aOwner
;
if
(
previousCommonAncestor
!
=
mCommonAncestor
)
{
if
(
previousCommonAncestor
)
{
previousCommonAncestor
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
mCommonAncestor
)
{
mCommonAncestor
-
>
AddMutationObserver
(
this
)
;
}
}
}
void
CrossShadowBoundaryRange
:
:
ContentWillBeRemoved
(
nsIContent
*
aChild
const
ContentRemoveInfo
&
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOwner
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOwner
-
>
GetCrossShadowBoundaryRange
(
)
=
=
this
)
;
RefPtr
<
CrossShadowBoundaryRange
>
kungFuDeathGrip
(
this
)
;
const
nsINode
*
startContainer
=
mStart
.
GetContainer
(
)
;
const
nsINode
*
endContainer
=
mEnd
.
GetContainer
(
)
;
MOZ_ASSERT
(
startContainer
&
&
endContainer
)
;
if
(
startContainer
=
=
aChild
|
|
endContainer
=
=
aChild
)
{
mOwner
-
>
ResetCrossShadowBoundaryRange
(
)
;
return
;
}
if
(
!
startContainer
-
>
IsInComposedDoc
(
)
|
|
!
endContainer
-
>
IsInComposedDoc
(
)
)
{
mOwner
-
>
ResetCrossShadowBoundaryRange
(
)
;
return
;
}
if
(
const
auto
*
shadowRoot
=
aChild
-
>
GetShadowRoot
(
)
)
{
if
(
startContainer
=
=
shadowRoot
|
|
endContainer
=
=
shadowRoot
)
{
mOwner
-
>
ResetCrossShadowBoundaryRange
(
)
;
return
;
}
}
if
(
startContainer
-
>
IsShadowIncludingInclusiveDescendantOf
(
aChild
)
|
|
endContainer
-
>
IsShadowIncludingInclusiveDescendantOf
(
aChild
)
)
{
mOwner
-
>
ResetCrossShadowBoundaryRange
(
)
;
return
;
}
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
auto
MaybeCreateNewBoundary
=
[
container
aChild
]
(
const
nsINode
*
aContainer
const
RangeBoundary
&
aBoundary
)
-
>
Maybe
<
RawRangeBoundary
>
{
if
(
container
=
=
aContainer
)
{
if
(
aChild
=
=
aBoundary
.
Ref
(
)
)
{
return
Some
<
RawRangeBoundary
>
(
{
container
aChild
-
>
GetPreviousSibling
(
)
TreeKind
:
:
Flat
}
)
;
}
RawRangeBoundary
newBoundary
(
TreeKind
:
:
Flat
)
;
newBoundary
.
CopyFrom
(
aBoundary
RangeBoundaryIsMutationObserved
:
:
Yes
)
;
newBoundary
.
InvalidateOffset
(
)
;
return
Some
(
newBoundary
)
;
}
return
Nothing
(
)
;
}
;
const
Maybe
<
RawRangeBoundary
>
newStartBoundary
=
MaybeCreateNewBoundary
(
startContainer
mStart
)
;
const
Maybe
<
RawRangeBoundary
>
newEndBoundary
=
MaybeCreateNewBoundary
(
endContainer
mEnd
)
;
if
(
newStartBoundary
|
|
newEndBoundary
)
{
DoSetRange
(
newStartBoundary
?
newStartBoundary
.
ref
(
)
:
mStart
.
AsRaw
(
)
newEndBoundary
?
newEndBoundary
.
ref
(
)
:
mEnd
.
AsRaw
(
)
nullptr
mOwner
)
;
}
}
void
CrossShadowBoundaryRange
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
if
(
aInfo
.
mDetails
)
{
return
;
}
MOZ_ASSERT
(
aContent
)
;
MOZ_ASSERT
(
mIsPositioned
)
;
auto
MaybeCreateNewBoundary
=
[
aContent
&
aInfo
]
(
const
RangeBoundary
&
aBoundary
)
-
>
Maybe
<
RawRangeBoundary
>
{
if
(
aContent
=
=
aBoundary
.
GetContainer
(
)
&
&
aInfo
.
mChangeStart
<
*
aBoundary
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
{
RawRangeBoundary
newStart
=
nsRange
:
:
ComputeNewBoundaryWhenBoundaryInsideChangedText
(
aInfo
aBoundary
.
AsRaw
(
)
)
;
return
Some
(
newStart
.
AsRangeBoundaryInFlatTree
(
)
)
;
}
return
Nothing
(
)
;
}
;
const
Maybe
<
RawRangeBoundary
>
newStartBoundary
=
MaybeCreateNewBoundary
(
mStart
)
;
const
Maybe
<
RawRangeBoundary
>
newEndBoundary
=
MaybeCreateNewBoundary
(
mEnd
)
;
if
(
newStartBoundary
|
|
newEndBoundary
)
{
DoSetRange
(
newStartBoundary
?
newStartBoundary
.
ref
(
)
:
mStart
.
AsRaw
(
)
newEndBoundary
?
newEndBoundary
.
ref
(
)
:
mEnd
.
AsRaw
(
)
nullptr
mOwner
)
;
}
}
void
CrossShadowBoundaryRange
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mCommonAncestor
=
=
aContent
"
Wrong
ParentChainChanged
notification
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOwner
)
;
mOwner
-
>
ResetCrossShadowBoundaryRange
(
)
;
}
}
