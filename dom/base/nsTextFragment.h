#
ifndef
nsTextFragment_h___
#
define
nsTextFragment_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsTextFragment
final
{
public
:
static
nsresult
Init
(
)
;
static
void
Shutdown
(
)
;
nsTextFragment
(
)
:
m1b
(
nullptr
)
mAllBits
(
0
)
{
MOZ_COUNT_CTOR
(
nsTextFragment
)
;
NS_ASSERTION
(
sizeof
(
FragmentBits
)
=
=
4
"
Bad
field
packing
!
"
)
;
}
~
nsTextFragment
(
)
;
nsTextFragment
&
operator
=
(
const
nsTextFragment
&
aOther
)
;
bool
Is2b
(
)
const
{
return
mState
.
mIs2b
;
}
bool
IsBidi
(
)
const
{
return
mState
.
mIsBidi
;
}
const
char16_t
*
Get2b
(
)
const
{
MOZ_ASSERT
(
Is2b
(
)
"
not
2b
text
"
)
;
return
static_cast
<
char16_t
*
>
(
m2b
-
>
Data
(
)
)
;
}
const
char
*
Get1b
(
)
const
{
NS_ASSERTION
(
!
Is2b
(
)
"
not
1b
text
"
)
;
return
(
const
char
*
)
m1b
;
}
uint32_t
GetLength
(
)
const
{
return
mState
.
mLength
;
}
bool
CanGrowBy
(
size_t
n
)
const
{
return
n
<
(
1
<
<
29
)
&
&
mState
.
mLength
+
n
<
(
1
<
<
29
)
;
}
bool
SetTo
(
const
char16_t
*
aBuffer
int32_t
aLength
bool
aUpdateBidi
bool
aForce2b
)
;
bool
SetTo
(
const
nsString
&
aString
bool
aUpdateBidi
bool
aForce2b
)
{
ReleaseText
(
)
;
if
(
aForce2b
&
&
!
aUpdateBidi
)
{
nsStringBuffer
*
buffer
=
nsStringBuffer
:
:
FromString
(
aString
)
;
if
(
buffer
)
{
NS_ADDREF
(
m2b
=
buffer
)
;
mState
.
mInHeap
=
true
;
mState
.
mIs2b
=
true
;
mState
.
mLength
=
aString
.
Length
(
)
;
return
true
;
}
}
return
SetTo
(
aString
.
get
(
)
aString
.
Length
(
)
aUpdateBidi
aForce2b
)
;
}
bool
Append
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aUpdateBidi
bool
aForce2b
)
;
void
AppendTo
(
nsAString
&
aString
)
const
{
if
(
!
AppendTo
(
aString
mozilla
:
:
fallible
)
)
{
aString
.
AllocFailed
(
aString
.
Length
(
)
+
GetLength
(
)
)
;
}
}
MOZ_MUST_USE
bool
AppendTo
(
nsAString
&
aString
const
mozilla
:
:
fallible_t
&
aFallible
)
const
{
if
(
mState
.
mIs2b
)
{
if
(
aString
.
IsEmpty
(
)
)
{
m2b
-
>
ToString
(
mState
.
mLength
aString
)
;
return
true
;
}
bool
ok
=
aString
.
Append
(
Get2b
(
)
mState
.
mLength
aFallible
)
;
if
(
!
ok
)
{
return
false
;
}
return
true
;
}
else
{
return
AppendASCIItoUTF16
(
Substring
(
m1b
mState
.
mLength
)
aString
aFallible
)
;
}
}
void
AppendTo
(
nsAString
&
aString
int32_t
aOffset
int32_t
aLength
)
const
{
if
(
!
AppendTo
(
aString
aOffset
aLength
mozilla
:
:
fallible
)
)
{
aString
.
AllocFailed
(
aString
.
Length
(
)
+
aLength
)
;
}
}
MOZ_MUST_USE
bool
AppendTo
(
nsAString
&
aString
int32_t
aOffset
int32_t
aLength
const
mozilla
:
:
fallible_t
&
aFallible
)
const
{
if
(
mState
.
mIs2b
)
{
bool
ok
=
aString
.
Append
(
Get2b
(
)
+
aOffset
aLength
aFallible
)
;
if
(
!
ok
)
{
return
false
;
}
return
true
;
}
else
{
return
AppendASCIItoUTF16
(
Substring
(
m1b
+
aOffset
aLength
)
aString
aFallible
)
;
}
}
void
CopyTo
(
char16_t
*
aDest
int32_t
aOffset
int32_t
aCount
)
;
char16_t
CharAt
(
int32_t
aIndex
)
const
{
MOZ_ASSERT
(
uint32_t
(
aIndex
)
<
mState
.
mLength
"
bad
index
"
)
;
return
mState
.
mIs2b
?
Get2b
(
)
[
aIndex
]
:
static_cast
<
unsigned
char
>
(
m1b
[
aIndex
]
)
;
}
void
SetBidi
(
bool
aBidi
)
{
mState
.
mIsBidi
=
aBidi
;
}
struct
FragmentBits
{
uint32_t
mInHeap
:
1
;
uint32_t
mIs2b
:
1
;
uint32_t
mIsBidi
:
1
;
uint32_t
mLength
:
29
;
}
;
#
define
NS_MAX_TEXT_FRAGMENT_LENGTH
(
static_cast
<
uint32_t
>
(
0x1FFFFFFF
)
)
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
void
ReleaseText
(
)
;
void
UpdateBidiFlag
(
const
char16_t
*
aBuffer
uint32_t
aLength
)
;
union
{
nsStringBuffer
*
m2b
;
const
char
*
m1b
;
}
;
union
{
uint32_t
mAllBits
;
FragmentBits
mState
;
}
;
}
;
#
endif
