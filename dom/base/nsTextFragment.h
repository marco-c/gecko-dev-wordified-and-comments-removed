#
ifndef
nsTextFragment_h___
#
define
nsTextFragment_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsTextFragment
final
{
public
:
static
nsresult
Init
(
)
;
static
void
Shutdown
(
)
;
nsTextFragment
(
)
:
m1b
(
nullptr
)
mAllBits
(
0
)
{
MOZ_COUNT_CTOR
(
nsTextFragment
)
;
NS_ASSERTION
(
sizeof
(
FragmentBits
)
=
=
4
"
Bad
field
packing
!
"
)
;
}
~
nsTextFragment
(
)
;
nsTextFragment
&
operator
=
(
const
nsTextFragment
&
aOther
)
;
bool
Is2b
(
)
const
{
return
mState
.
mIs2b
;
}
bool
IsBidi
(
)
const
{
return
mState
.
mIsBidi
;
}
const
char16_t
*
Get2b
(
)
const
{
MOZ_ASSERT
(
Is2b
(
)
"
not
2b
text
"
)
;
return
static_cast
<
char16_t
*
>
(
m2b
-
>
Data
(
)
)
;
}
const
char
*
Get1b
(
)
const
{
NS_ASSERTION
(
!
Is2b
(
)
"
not
1b
text
"
)
;
return
(
const
char
*
)
m1b
;
}
uint32_t
GetLength
(
)
const
{
return
mState
.
mLength
;
}
#
define
NS_MAX_TEXT_FRAGMENT_LENGTH
(
static_cast
<
uint32_t
>
(
0x1FFFFFFF
)
)
bool
CanGrowBy
(
size_t
n
)
const
{
return
n
<
(
1
<
<
29
)
&
&
mState
.
mLength
+
n
<
(
1
<
<
29
)
;
}
bool
SetTo
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aUpdateBidi
bool
aForce2b
)
;
bool
SetTo
(
const
nsString
&
aString
bool
aUpdateBidi
bool
aForce2b
)
{
if
(
MOZ_UNLIKELY
(
aString
.
Length
(
)
>
NS_MAX_TEXT_FRAGMENT_LENGTH
)
)
{
return
false
;
}
ReleaseText
(
)
;
if
(
aForce2b
&
&
!
aUpdateBidi
)
{
nsStringBuffer
*
buffer
=
nsStringBuffer
:
:
FromString
(
aString
)
;
if
(
buffer
)
{
NS_ADDREF
(
m2b
=
buffer
)
;
mState
.
mInHeap
=
true
;
mState
.
mIs2b
=
true
;
mState
.
mLength
=
aString
.
Length
(
)
;
return
true
;
}
}
return
SetTo
(
aString
.
get
(
)
aString
.
Length
(
)
aUpdateBidi
aForce2b
)
;
}
bool
Append
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aUpdateBidi
bool
aForce2b
)
;
void
AppendTo
(
nsAString
&
aString
)
const
{
if
(
!
AppendTo
(
aString
mozilla
:
:
fallible
)
)
{
aString
.
AllocFailed
(
aString
.
Length
(
)
+
GetLength
(
)
)
;
}
}
[
[
nodiscard
]
]
bool
AppendTo
(
nsAString
&
aString
const
mozilla
:
:
fallible_t
&
aFallible
)
const
{
if
(
mState
.
mIs2b
)
{
if
(
aString
.
IsEmpty
(
)
)
{
m2b
-
>
ToString
(
mState
.
mLength
aString
)
;
return
true
;
}
bool
ok
=
aString
.
Append
(
Get2b
(
)
mState
.
mLength
aFallible
)
;
if
(
!
ok
)
{
return
false
;
}
return
true
;
}
else
{
return
AppendASCIItoUTF16
(
Substring
(
m1b
mState
.
mLength
)
aString
aFallible
)
;
}
}
void
AppendTo
(
nsAString
&
aString
uint32_t
aOffset
uint32_t
aLength
)
const
{
if
(
!
AppendTo
(
aString
aOffset
aLength
mozilla
:
:
fallible
)
)
{
aString
.
AllocFailed
(
aString
.
Length
(
)
+
aLength
)
;
}
}
[
[
nodiscard
]
]
bool
AppendTo
(
nsAString
&
aString
uint32_t
aOffset
uint32_t
aLength
const
mozilla
:
:
fallible_t
&
aFallible
)
const
{
if
(
mState
.
mIs2b
)
{
bool
ok
=
aString
.
Append
(
Get2b
(
)
+
aOffset
aLength
aFallible
)
;
if
(
!
ok
)
{
return
false
;
}
return
true
;
}
else
{
return
AppendASCIItoUTF16
(
Substring
(
m1b
+
aOffset
aLength
)
aString
aFallible
)
;
}
}
void
CopyTo
(
char16_t
*
aDest
uint32_t
aOffset
uint32_t
aCount
)
;
char16_t
CharAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mState
.
mLength
"
bad
index
"
)
;
return
mState
.
mIs2b
?
Get2b
(
)
[
aIndex
]
:
static_cast
<
unsigned
char
>
(
m1b
[
aIndex
]
)
;
}
inline
bool
IsHighSurrogateFollowedByLowSurrogateAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mState
.
mLength
)
;
if
(
!
mState
.
mIs2b
|
|
aIndex
+
1
>
=
mState
.
mLength
)
{
return
false
;
}
return
NS_IS_SURROGATE_PAIR
(
Get2b
(
)
[
aIndex
]
Get2b
(
)
[
aIndex
+
1
]
)
;
}
inline
bool
IsLowSurrogateFollowingHighSurrogateAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mState
.
mLength
)
;
if
(
!
mState
.
mIs2b
|
|
!
aIndex
)
{
return
false
;
}
return
NS_IS_SURROGATE_PAIR
(
Get2b
(
)
[
aIndex
-
1
]
Get2b
(
)
[
aIndex
]
)
;
}
inline
char32_t
ScalarValueAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
mState
.
mLength
)
;
if
(
!
mState
.
mIs2b
)
{
return
static_cast
<
unsigned
char
>
(
m1b
[
aIndex
]
)
;
}
char16_t
ch
=
Get2b
(
)
[
aIndex
]
;
if
(
!
IS_SURROGATE
(
ch
)
)
{
return
ch
;
}
if
(
aIndex
+
1
<
mState
.
mLength
&
&
NS_IS_HIGH_SURROGATE
(
ch
)
)
{
char16_t
nextCh
=
Get2b
(
)
[
aIndex
+
1
]
;
if
(
NS_IS_LOW_SURROGATE
(
nextCh
)
)
{
return
SURROGATE_TO_UCS4
(
ch
nextCh
)
;
}
}
return
0
;
}
void
SetBidi
(
bool
aBidi
)
{
mState
.
mIsBidi
=
aBidi
;
}
struct
FragmentBits
{
uint32_t
mInHeap
:
1
;
uint32_t
mIs2b
:
1
;
uint32_t
mIsBidi
:
1
;
uint32_t
mLength
:
29
;
}
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
[
[
nodiscard
]
]
bool
TextEquals
(
const
nsTextFragment
&
aOther
)
const
;
private
:
void
ReleaseText
(
)
;
void
UpdateBidiFlag
(
const
char16_t
*
aBuffer
uint32_t
aLength
)
;
union
{
nsStringBuffer
*
m2b
;
const
char
*
m1b
;
}
;
union
{
uint32_t
mAllBits
;
FragmentBits
mState
;
}
;
}
;
#
endif
