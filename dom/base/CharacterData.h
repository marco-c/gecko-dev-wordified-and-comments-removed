#
ifndef
mozilla_dom_CharacterData_h
#
define
mozilla_dom_CharacterData_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
namespace
mozilla
{
namespace
dom
{
class
HTMLSlotElement
;
}
}
#
define
CHARACTER_DATA_FLAG_BIT
(
n_
)
\
NODE_FLAG_BIT
(
NODE_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
NS_CREATE_FRAME_IF_NON_WHITESPACE
=
CHARACTER_DATA_FLAG_BIT
(
0
)
NS_REFRAME_IF_WHITESPACE
=
CHARACTER_DATA_FLAG_BIT
(
1
)
NS_CACHED_TEXT_IS_ONLY_WHITESPACE
=
CHARACTER_DATA_FLAG_BIT
(
2
)
NS_TEXT_IS_ONLY_WHITESPACE
=
CHARACTER_DATA_FLAG_BIT
(
3
)
NS_HAS_NEWLINE_PROPERTY
=
CHARACTER_DATA_FLAG_BIT
(
4
)
NS_HAS_FLOWLENGTH_PROPERTY
=
CHARACTER_DATA_FLAG_BIT
(
5
)
NS_MAYBE_MODIFIED_FREQUENTLY
=
CHARACTER_DATA_FLAG_BIT
(
6
)
}
;
ASSERT_NODE_FLAGS_SPACE
(
NODE_TYPE_SPECIFIC_BITS_OFFSET
+
7
)
;
#
undef
CHARACTER_DATA_FLAG_BIT
namespace
mozilla
{
namespace
dom
{
class
CharacterData
:
public
nsIContent
{
public
:
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
;
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
CharacterData
nsIContent
)
;
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
explicit
CharacterData
(
already_AddRefed
<
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
void
MarkAsMaybeModifiedFrequently
(
)
{
SetFlags
(
NS_MAYBE_MODIFIED_FREQUENTLY
)
;
}
NS_IMPL_FROMNODE_HELPER
(
CharacterData
IsCharacterData
(
)
)
virtual
void
GetNodeValueInternal
(
nsAString
&
aNodeValue
)
override
;
virtual
void
SetNodeValueInternal
(
const
nsAString
&
aNodeValue
ErrorResult
&
aError
)
override
;
void
GetTextContentInternal
(
nsAString
&
aTextContent
OOMReporter
&
)
final
{
GetNodeValue
(
aTextContent
)
;
}
void
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
final
{
mozAutoSubtreeModified
subtree
(
OwnerDoc
(
)
nullptr
)
;
return
SetNodeValue
(
aTextContent
aError
)
;
}
nsresult
BindToTree
(
Document
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
override
;
already_AddRefed
<
nsINodeList
>
GetChildren
(
uint32_t
aFilter
)
final
{
return
nullptr
;
}
const
nsTextFragment
*
GetText
(
)
override
{
return
&
mText
;
}
const
nsTextFragment
&
TextFragment
(
)
const
{
return
mText
;
}
uint32_t
TextLength
(
)
const
final
{
return
TextDataLength
(
)
;
}
nsresult
SetText
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aNotify
)
;
nsresult
SetText
(
const
nsAString
&
aStr
bool
aNotify
)
{
return
SetText
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aNotify
)
;
}
nsresult
AppendText
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aNotify
)
;
bool
TextIsOnlyWhitespace
(
)
final
;
bool
ThreadSafeTextIsOnlyWhitespace
(
)
const
final
;
void
AppendTextTo
(
nsAString
&
aResult
)
const
{
mText
.
AppendTo
(
aResult
)
;
}
MOZ_MUST_USE
bool
AppendTextTo
(
nsAString
&
aResult
const
fallible_t
&
aFallible
)
const
{
return
mText
.
AppendTo
(
aResult
aFallible
)
;
}
void
SaveSubtreeState
(
)
final
{
}
#
ifdef
DEBUG
void
List
(
FILE
*
out
int32_t
aIndent
)
const
override
{
}
void
DumpContent
(
FILE
*
out
int32_t
aIndent
bool
aDumpAll
)
const
override
{
}
#
endif
nsXBLBinding
*
DoGetXBLBinding
(
)
const
final
{
return
nullptr
;
}
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
{
return
false
;
}
bool
IsLink
(
nsIURI
*
*
aURI
)
const
final
{
*
aURI
=
nullptr
;
return
false
;
}
nsresult
Clone
(
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
override
{
RefPtr
<
CharacterData
>
result
=
CloneDataNode
(
aNodeInfo
true
)
;
result
.
forget
(
aResult
)
;
if
(
!
*
aResult
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
GetData
(
nsAString
&
aData
)
const
;
virtual
void
SetData
(
const
nsAString
&
aData
ErrorResult
&
rv
)
;
void
SubstringData
(
uint32_t
aStart
uint32_t
aCount
nsAString
&
aReturn
ErrorResult
&
rv
)
;
void
AppendData
(
const
nsAString
&
aData
ErrorResult
&
rv
)
;
void
InsertData
(
uint32_t
aOffset
const
nsAString
&
aData
ErrorResult
&
rv
)
;
void
DeleteData
(
uint32_t
aOffset
uint32_t
aCount
ErrorResult
&
rv
)
;
void
ReplaceData
(
uint32_t
aOffset
uint32_t
aCount
const
nsAString
&
aData
ErrorResult
&
rv
)
;
uint32_t
TextDataLength
(
)
const
{
return
mText
.
GetLength
(
)
;
}
#
ifdef
DEBUG
void
ToCString
(
nsAString
&
aBuf
int32_t
aOffset
int32_t
aLen
)
const
;
#
endif
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_INHERITED
(
CharacterData
nsIContent
)
protected
:
virtual
~
CharacterData
(
)
;
Element
*
GetNameSpaceElement
(
)
final
{
return
Element
:
:
FromNodeOrNull
(
GetParentNode
(
)
)
;
}
nsresult
SetTextInternal
(
uint32_t
aOffset
uint32_t
aCount
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aNotify
CharacterDataChangeInfo
:
:
Details
*
aDetails
=
nullptr
)
;
virtual
already_AddRefed
<
CharacterData
>
CloneDataNode
(
dom
:
:
NodeInfo
*
aNodeInfo
bool
aCloneText
)
const
=
0
;
nsTextFragment
mText
;
private
:
already_AddRefed
<
nsAtom
>
GetCurrentValueAtom
(
)
;
}
;
}
}
#
endif
