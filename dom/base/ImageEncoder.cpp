#
include
"
ImageEncoder
.
h
"
#
include
"
YCbCrUtils
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SyncRunnable
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
dom
/
GeneratePlaceholderCanvasData
.
h
"
#
include
"
mozilla
/
dom
/
MemoryBlobImpl
.
h
"
#
include
"
mozilla
/
dom
/
OffscreenCanvasDisplayHelper
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
layers
/
CanvasRenderer
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOMCIDInternal
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
:
:
dom
{
class
SurfaceHelper
:
public
Runnable
{
public
:
explicit
SurfaceHelper
(
already_AddRefed
<
layers
:
:
Image
>
aImage
)
:
Runnable
(
"
SurfaceHelper
"
)
mImage
(
aImage
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
mImage
-
>
GetAsSourceSurface
(
)
;
if
(
surface
-
>
GetFormat
(
)
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
{
mDataSourceSurface
=
surface
-
>
GetDataSurface
(
)
;
}
else
{
mDataSourceSurface
=
gfxUtils
:
:
CopySurfaceToDataSourceSurfaceWithFormat
(
surface
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
;
}
NS_ReleaseOnMainThread
(
"
SurfaceHelper
:
:
surface
"
surface
.
forget
(
)
)
;
return
NS_OK
;
}
already_AddRefed
<
gfx
:
:
DataSourceSurface
>
GetDataSurfaceSafe
(
)
{
nsCOMPtr
<
nsIEventTarget
>
mainTarget
=
GetMainThreadSerialEventTarget
(
)
;
MOZ_ASSERT
(
mainTarget
)
;
SyncRunnable
:
:
DispatchToThread
(
mainTarget
this
false
)
;
return
mDataSourceSurface
.
forget
(
)
;
}
private
:
RefPtr
<
layers
:
:
Image
>
mImage
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
mDataSourceSurface
;
}
;
already_AddRefed
<
DataSourceSurface
>
GetBRGADataSourceSurfaceSync
(
already_AddRefed
<
layers
:
:
Image
>
aImage
)
{
RefPtr
<
SurfaceHelper
>
helper
=
new
SurfaceHelper
(
std
:
:
move
(
aImage
)
)
;
return
helper
-
>
GetDataSurfaceSafe
(
)
;
}
class
EncodingCompleteEvent
final
:
public
DiscardableRunnable
{
virtual
~
EncodingCompleteEvent
(
)
=
default
;
public
:
explicit
EncodingCompleteEvent
(
EncodeCompleteCallback
*
aEncodeCompleteCallback
)
:
DiscardableRunnable
(
"
EncodingCompleteEvent
"
)
mImgSize
(
0
)
mImgData
(
nullptr
)
mEncodeCompleteCallback
(
aEncodeCompleteCallback
)
mFailed
(
false
)
{
if
(
!
NS_IsMainThread
(
)
&
&
IsCurrentThreadRunningWorker
(
)
)
{
mCreationEventTarget
=
GetCurrentSerialEventTarget
(
)
;
}
else
{
mCreationEventTarget
=
GetMainThreadSerialEventTarget
(
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
nsresult
rv
=
NS_OK
;
RefPtr
<
EncodeCompleteCallback
>
callback
(
std
:
:
move
(
mEncodeCompleteCallback
)
)
;
if
(
!
mFailed
)
{
RefPtr
<
BlobImpl
>
blobImpl
=
new
MemoryBlobImpl
(
mImgData
mImgSize
mType
)
;
rv
=
callback
-
>
ReceiveBlobImpl
(
blobImpl
.
forget
(
)
)
;
}
else
{
rv
=
callback
-
>
ReceiveBlobImpl
(
nullptr
)
;
}
return
rv
;
}
void
SetMembers
(
void
*
aImgData
uint64_t
aImgSize
const
nsAutoString
&
aType
)
{
mImgData
=
aImgData
;
mImgSize
=
aImgSize
;
mType
=
aType
;
}
void
SetFailed
(
)
{
mFailed
=
true
;
}
nsIEventTarget
*
GetCreationThreadEventTarget
(
)
{
return
mCreationEventTarget
;
}
bool
CanBeDeletedOnAnyThread
(
)
{
return
!
mEncodeCompleteCallback
|
|
mEncodeCompleteCallback
-
>
CanBeDeletedOnAnyThread
(
)
;
}
private
:
uint64_t
mImgSize
;
nsAutoString
mType
;
void
*
mImgData
;
nsCOMPtr
<
nsIEventTarget
>
mCreationEventTarget
;
RefPtr
<
EncodeCompleteCallback
>
mEncodeCompleteCallback
;
bool
mFailed
;
}
;
class
EncodingRunnable
:
public
Runnable
{
virtual
~
EncodingRunnable
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
EncodingRunnable
Runnable
)
EncodingRunnable
(
const
nsAString
&
aType
const
nsAString
&
aOptions
UniquePtr
<
uint8_t
[
]
>
aImageBuffer
layers
:
:
Image
*
aImage
imgIEncoder
*
aEncoder
EncodingCompleteEvent
*
aEncodingCompleteEvent
int32_t
aFormat
const
CSSIntSize
aSize
CanvasUtils
:
:
ImageExtraction
aExtractionBehavior
bool
aUsingCustomOptions
)
:
Runnable
(
"
EncodingRunnable
"
)
mType
(
aType
)
mOptions
(
aOptions
)
mImageBuffer
(
std
:
:
move
(
aImageBuffer
)
)
mImage
(
aImage
)
mEncoder
(
aEncoder
)
mEncodingCompleteEvent
(
aEncodingCompleteEvent
)
mFormat
(
aFormat
)
mSize
(
aSize
)
mExtractionBehavior
(
aExtractionBehavior
)
mUsingCustomOptions
(
aUsingCustomOptions
)
{
}
nsresult
ProcessImageData
(
uint64_t
*
aImgSize
void
*
*
aImgData
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
ImageEncoder
:
:
ExtractDataInternal
(
mType
mOptions
mImageBuffer
.
get
(
)
mFormat
mSize
mExtractionBehavior
mImage
nullptr
nullptr
getter_AddRefs
(
stream
)
mEncoder
)
;
if
(
rv
=
=
NS_ERROR_INVALID_ARG
&
&
mUsingCustomOptions
)
{
rv
=
ImageEncoder
:
:
ExtractDataInternal
(
mType
u
"
"
_ns
mImageBuffer
.
get
(
)
mFormat
mSize
mExtractionBehavior
mImage
nullptr
nullptr
getter_AddRefs
(
stream
)
mEncoder
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_ReadInputStreamToBuffer
(
stream
aImgData
-
1
aImgSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
NS_IMETHOD
Run
(
)
override
{
uint64_t
imgSize
;
void
*
imgData
=
nullptr
;
nsresult
rv
=
ProcessImageData
(
&
imgSize
&
imgData
)
;
if
(
NS_FAILED
(
rv
)
)
{
mEncodingCompleteEvent
-
>
SetFailed
(
)
;
}
else
{
mEncodingCompleteEvent
-
>
SetMembers
(
imgData
imgSize
mType
)
;
}
rv
=
mEncodingCompleteEvent
-
>
GetCreationThreadEventTarget
(
)
-
>
Dispatch
(
mEncodingCompleteEvent
nsIThread
:
:
DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
mEncodingCompleteEvent
-
>
CanBeDeletedOnAnyThread
(
)
)
{
Unused
<
<
mEncodingCompleteEvent
.
forget
(
)
;
}
return
rv
;
}
return
rv
;
}
private
:
nsAutoString
mType
;
nsAutoString
mOptions
;
UniquePtr
<
uint8_t
[
]
>
mImageBuffer
;
RefPtr
<
layers
:
:
Image
>
mImage
;
nsCOMPtr
<
imgIEncoder
>
mEncoder
;
RefPtr
<
EncodingCompleteEvent
>
mEncodingCompleteEvent
;
int32_t
mFormat
;
const
CSSIntSize
mSize
;
CanvasUtils
:
:
ImageExtraction
mExtractionBehavior
;
bool
mUsingCustomOptions
;
}
;
nsresult
ImageEncoder
:
:
ExtractData
(
nsAString
&
aType
const
nsAString
&
aOptions
const
CSSIntSize
aSize
CanvasUtils
:
:
ImageExtraction
aExtractionBehavior
nsICanvasRenderingContextInternal
*
aContext
OffscreenCanvasDisplayHelper
*
aOffscreenDisplay
nsIInputStream
*
*
aStream
)
{
nsCOMPtr
<
imgIEncoder
>
encoder
=
ImageEncoder
:
:
GetImageEncoder
(
aType
)
;
if
(
!
encoder
)
{
return
NS_IMAGELIB_ERROR_NO_ENCODER
;
}
return
ExtractDataInternal
(
aType
aOptions
nullptr
0
aSize
aExtractionBehavior
nullptr
aContext
aOffscreenDisplay
aStream
encoder
)
;
}
nsresult
ImageEncoder
:
:
ExtractDataFromLayersImageAsync
(
nsAString
&
aType
const
nsAString
&
aOptions
bool
aUsingCustomOptions
layers
:
:
Image
*
aImage
CanvasUtils
:
:
ImageExtraction
aExtractionBehavior
EncodeCompleteCallback
*
aEncodeCallback
)
{
nsCOMPtr
<
imgIEncoder
>
encoder
=
ImageEncoder
:
:
GetImageEncoder
(
aType
)
;
if
(
!
encoder
)
{
return
NS_IMAGELIB_ERROR_NO_ENCODER
;
}
RefPtr
<
EncodingCompleteEvent
>
completeEvent
=
new
EncodingCompleteEvent
(
aEncodeCallback
)
;
CSSIntSize
size
=
CSSIntSize
:
:
FromUnknownSize
(
aImage
-
>
GetSize
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
EncodingRunnable
(
aType
aOptions
nullptr
aImage
encoder
completeEvent
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
size
aExtractionBehavior
aUsingCustomOptions
)
;
return
NS_DispatchBackgroundTask
(
event
.
forget
(
)
)
;
}
nsresult
ImageEncoder
:
:
ExtractDataAsync
(
nsAString
&
aType
const
nsAString
&
aOptions
bool
aUsingCustomOptions
UniquePtr
<
uint8_t
[
]
>
aImageBuffer
int32_t
aFormat
const
CSSIntSize
aSize
CanvasUtils
:
:
ImageExtraction
aExtractionBehavior
EncodeCompleteCallback
*
aEncodeCallback
)
{
nsCOMPtr
<
imgIEncoder
>
encoder
=
ImageEncoder
:
:
GetImageEncoder
(
aType
)
;
if
(
!
encoder
)
{
return
NS_IMAGELIB_ERROR_NO_ENCODER
;
}
RefPtr
<
EncodingCompleteEvent
>
completeEvent
=
new
EncodingCompleteEvent
(
aEncodeCallback
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
EncodingRunnable
(
aType
aOptions
std
:
:
move
(
aImageBuffer
)
nullptr
encoder
completeEvent
aFormat
aSize
aExtractionBehavior
aUsingCustomOptions
)
;
return
NS_DispatchBackgroundTask
(
event
.
forget
(
)
)
;
}
nsresult
ImageEncoder
:
:
GetInputStream
(
int32_t
aWidth
int32_t
aHeight
uint8_t
*
aImageBuffer
int32_t
aFormat
imgIEncoder
*
aEncoder
const
nsAString
&
aEncoderOptions
nsIInputStream
*
*
aStream
)
{
nsresult
rv
=
aEncoder
-
>
InitFromData
(
aImageBuffer
aWidth
*
aHeight
*
4
aWidth
aHeight
aWidth
*
4
aFormat
aEncoderOptions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
imgIEncoder
>
encoder
(
aEncoder
)
;
encoder
.
forget
(
aStream
)
;
return
NS_OK
;
}
nsresult
ImageEncoder
:
:
ExtractDataInternal
(
const
nsAString
&
aType
const
nsAString
&
aOptions
uint8_t
*
aImageBuffer
int32_t
aFormat
const
CSSIntSize
aSize
CanvasUtils
:
:
ImageExtraction
aExtractionBehavior
layers
:
:
Image
*
aImage
nsICanvasRenderingContextInternal
*
aContext
OffscreenCanvasDisplayHelper
*
aOffscreenDisplay
nsIInputStream
*
*
aStream
imgIEncoder
*
aEncoder
)
{
if
(
aSize
.
IsEmpty
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIInputStream
>
imgStream
;
nsresult
rv
=
NS_OK
;
bool
hasImageSource
=
aImageBuffer
|
|
aContext
|
|
aOffscreenDisplay
|
|
aImage
;
bool
usePlaceholder
=
aExtractionBehavior
=
=
CanvasUtils
:
:
ImageExtraction
:
:
Placeholder
;
if
(
!
hasImageSource
|
|
usePlaceholder
)
{
if
(
BufferSizeFromDimensions
(
aSize
.
width
aSize
.
height
4
)
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
DataSourceSurface
>
emptyCanvas
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
IntSize
(
aSize
.
width
aSize
.
height
)
SurfaceFormat
:
:
B8G8R8A8
4
*
aSize
.
width
true
)
;
if
(
NS_WARN_IF
(
!
emptyCanvas
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
emptyCanvas
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
WRITE
&
map
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
usePlaceholder
)
{
auto
size
=
4
*
aSize
.
width
*
aSize
.
height
;
auto
*
data
=
map
.
mData
;
GeneratePlaceholderCanvasData
(
size
data
)
;
}
rv
=
aEncoder
-
>
InitFromData
(
map
.
mData
aSize
.
width
*
aSize
.
height
*
4
aSize
.
width
aSize
.
height
aSize
.
width
*
4
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
aOptions
)
;
emptyCanvas
-
>
Unmap
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
imgStream
=
aEncoder
;
}
}
else
if
(
aImageBuffer
)
{
if
(
BufferSizeFromDimensions
(
aSize
.
width
aSize
.
height
4
)
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
rv
=
ImageEncoder
:
:
GetInputStream
(
aSize
.
width
aSize
.
height
aImageBuffer
aFormat
aEncoder
aOptions
getter_AddRefs
(
imgStream
)
)
;
}
else
if
(
aContext
)
{
NS_ConvertUTF16toUTF8
encoderType
(
aType
)
;
rv
=
aContext
-
>
GetInputStream
(
encoderType
.
get
(
)
aOptions
aExtractionBehavior
getter_AddRefs
(
imgStream
)
)
;
}
else
if
(
aOffscreenDisplay
)
{
const
NS_ConvertUTF16toUTF8
encoderType
(
aType
)
;
if
(
BufferSizeFromDimensions
(
aSize
.
width
aSize
.
height
4
)
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
RefPtr
<
SourceSurface
>
snapshot
=
aOffscreenDisplay
-
>
GetSurfaceSnapshot
(
)
;
if
(
!
snapshot
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
const
RefPtr
<
DataSourceSurface
>
data
=
snapshot
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
{
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
data
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
auto
size
=
data
-
>
GetSize
(
)
;
rv
=
aEncoder
-
>
InitFromData
(
map
.
mData
size
.
width
*
size
.
height
*
4
size
.
width
size
.
height
size
.
width
*
4
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
aOptions
)
;
data
-
>
Unmap
(
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
imgStream
=
aEncoder
;
}
}
else
if
(
aImage
)
{
if
(
aImage
-
>
GetFormat
(
)
=
=
ImageFormat
:
:
PLANAR_YCBCR
)
{
nsTArray
<
uint8_t
>
data
;
layers
:
:
PlanarYCbCrImage
*
ycbcrImage
=
static_cast
<
layers
:
:
PlanarYCbCrImage
*
>
(
aImage
)
;
gfxImageFormat
format
=
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
int32_t
stride
=
GetAlignedStride
<
16
>
(
aSize
.
width
4
)
;
size_t
length
=
BufferSizeFromStrideAndHeight
(
stride
aSize
.
height
)
;
if
(
length
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
data
.
SetCapacity
(
length
)
;
rv
=
ConvertYCbCrToRGB
(
*
ycbcrImage
-
>
GetData
(
)
format
aSize
.
ToUnknownSize
(
)
data
.
Elements
(
)
stride
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
to
convert
YUV
into
RGB
data
"
)
;
return
rv
;
}
rv
=
aEncoder
-
>
InitFromData
(
data
.
Elements
(
)
aSize
.
width
*
aSize
.
height
*
4
aSize
.
width
aSize
.
height
aSize
.
width
*
4
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
aOptions
)
;
}
else
{
if
(
BufferSizeFromDimensions
(
aSize
.
width
aSize
.
height
4
)
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
;
RefPtr
<
layers
:
:
Image
>
image
(
aImage
)
;
dataSurface
=
GetBRGADataSourceSurfaceSync
(
image
.
forget
(
)
)
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
auto
size
=
dataSurface
-
>
GetSize
(
)
;
rv
=
aEncoder
-
>
InitFromData
(
map
.
mData
size
.
width
*
size
.
height
*
4
size
.
width
size
.
height
size
.
width
*
4
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
aOptions
)
;
dataSurface
-
>
Unmap
(
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
imgStream
=
aEncoder
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
imgStream
.
forget
(
aStream
)
;
return
rv
;
}
already_AddRefed
<
imgIEncoder
>
ImageEncoder
:
:
GetImageEncoder
(
nsAString
&
aType
)
{
nsCString
encoderCID
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
"
)
;
NS_ConvertUTF16toUTF8
encoderType
(
aType
)
;
encoderCID
+
=
encoderType
;
nsCOMPtr
<
imgIEncoder
>
encoder
=
do_CreateInstance
(
encoderCID
.
get
(
)
)
;
if
(
!
encoder
&
&
aType
!
=
u
"
image
/
png
"
_ns
)
{
aType
.
AssignLiteral
(
"
image
/
png
"
)
;
nsCString
PNGEncoderCID
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
image
/
png
"
)
;
encoder
=
do_CreateInstance
(
PNGEncoderCID
.
get
(
)
)
;
}
return
encoder
.
forget
(
)
;
}
}
