#
ifndef
nsContentPermissionHelper_h
#
define
nsContentPermissionHelper_h
#
include
"
nsIContentPermissionPrompt
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
mozilla
/
dom
/
PContentPermissionRequestChild
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
undef
LoadImage
class
nsPIDOMWindowInner
;
class
nsContentPermissionRequestProxy
;
class
VisibilityChangeListener
;
namespace
IPC
{
class
Principal
;
}
namespace
mozilla
{
namespace
dom
{
class
Element
;
class
PermissionRequest
;
class
ContentPermissionRequestParent
;
class
PContentPermissionRequestParent
;
class
ContentPermissionType
:
public
nsIContentPermissionType
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTPERMISSIONTYPE
ContentPermissionType
(
const
nsACString
&
aType
const
nsACString
&
aAccess
const
nsTArray
<
nsString
>
&
aOptions
)
;
protected
:
virtual
~
ContentPermissionType
(
)
;
nsCString
mType
;
nsCString
mAccess
;
nsTArray
<
nsString
>
mOptions
;
}
;
class
nsContentPermissionUtils
{
public
:
static
uint32_t
ConvertPermissionRequestToArray
(
nsTArray
<
PermissionRequest
>
&
aSrcArray
nsIMutableArray
*
aDesArray
)
;
static
uint32_t
ConvertArrayToPermissionRequest
(
nsIArray
*
aSrcArray
nsTArray
<
PermissionRequest
>
&
aDesArray
)
;
static
nsresult
CreatePermissionArray
(
const
nsACString
&
aType
const
nsACString
&
aAccess
const
nsTArray
<
nsString
>
&
aOptions
nsIArray
*
*
aTypesArray
)
;
static
PContentPermissionRequestParent
*
CreateContentPermissionRequestParent
(
const
nsTArray
<
PermissionRequest
>
&
aRequests
Element
*
aElement
const
IPC
:
:
Principal
&
aPrincipal
const
bool
aIsHandlingUserInput
const
TabId
&
aTabId
)
;
static
nsresult
AskPermission
(
nsIContentPermissionRequest
*
aRequest
nsPIDOMWindowInner
*
aWindow
)
;
static
nsTArray
<
PContentPermissionRequestParent
*
>
GetContentPermissionRequestParentById
(
const
TabId
&
aTabId
)
;
static
void
NotifyRemoveContentPermissionRequestParent
(
PContentPermissionRequestParent
*
aParent
)
;
static
nsTArray
<
PContentPermissionRequestChild
*
>
GetContentPermissionRequestChildById
(
const
TabId
&
aTabId
)
;
static
void
NotifyRemoveContentPermissionRequestChild
(
PContentPermissionRequestChild
*
aChild
)
;
}
;
class
nsContentPermissionRequester
final
:
public
nsIContentPermissionRequester
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTPERMISSIONREQUESTER
explicit
nsContentPermissionRequester
(
nsPIDOMWindowInner
*
aWindow
)
;
private
:
virtual
~
nsContentPermissionRequester
(
)
;
nsWeakPtr
mWindow
;
RefPtr
<
VisibilityChangeListener
>
mListener
;
}
;
}
}
using
mozilla
:
:
dom
:
:
ContentPermissionRequestParent
;
class
nsContentPermissionRequestProxy
:
public
nsIContentPermissionRequest
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTPERMISSIONREQUEST
explicit
nsContentPermissionRequestProxy
(
ContentPermissionRequestParent
*
parent
)
;
nsresult
Init
(
const
nsTArray
<
mozilla
:
:
dom
:
:
PermissionRequest
>
&
requests
)
;
void
OnParentDestroyed
(
)
;
void
NotifyVisibility
(
const
bool
&
aIsVisible
)
;
private
:
class
nsContentPermissionRequesterProxy
final
:
public
nsIContentPermissionRequester
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTPERMISSIONREQUESTER
explicit
nsContentPermissionRequesterProxy
(
ContentPermissionRequestParent
*
aParent
)
:
mParent
(
aParent
)
mWaitGettingResult
(
false
)
{
}
void
NotifyVisibilityResult
(
const
bool
&
aIsVisible
)
;
private
:
virtual
~
nsContentPermissionRequesterProxy
(
)
{
}
ContentPermissionRequestParent
*
mParent
;
bool
mWaitGettingResult
;
nsCOMPtr
<
nsIContentPermissionRequestCallback
>
mGetCallback
;
nsCOMPtr
<
nsIContentPermissionRequestCallback
>
mOnChangeCallback
;
}
;
virtual
~
nsContentPermissionRequestProxy
(
)
;
ContentPermissionRequestParent
*
mParent
;
nsTArray
<
mozilla
:
:
dom
:
:
PermissionRequest
>
mPermissionRequests
;
RefPtr
<
nsContentPermissionRequesterProxy
>
mRequester
;
}
;
class
RemotePermissionRequest
final
:
public
nsIContentPermissionRequestCallback
public
mozilla
:
:
dom
:
:
PContentPermissionRequestChild
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTPERMISSIONREQUESTCALLBACK
RemotePermissionRequest
(
nsIContentPermissionRequest
*
aRequest
nsPIDOMWindowInner
*
aWindow
)
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvNotifyResult
(
const
bool
&
aAllow
InfallibleTArray
<
PermissionChoice
>
&
&
aChoices
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvGetVisibility
(
)
override
;
void
IPDLAddRef
(
)
{
mIPCOpen
=
true
;
AddRef
(
)
;
}
void
IPDLRelease
(
)
{
mIPCOpen
=
false
;
Release
(
)
;
}
void
Destroy
(
)
;
bool
IPCOpen
(
)
const
{
return
mIPCOpen
&
&
!
mDestroyed
;
}
private
:
virtual
~
RemotePermissionRequest
(
)
;
void
DoAllow
(
JS
:
:
HandleValue
aChoices
)
;
void
DoCancel
(
)
;
nsCOMPtr
<
nsIContentPermissionRequest
>
mRequest
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
bool
mIPCOpen
;
bool
mDestroyed
;
RefPtr
<
VisibilityChangeListener
>
mListener
;
}
;
#
endif
