#
include
"
IDTracker
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
namespace
mozilla
{
namespace
dom
{
static
DocumentOrShadowRoot
*
DocOrShadowFromContent
(
nsIContent
&
aContent
)
{
ShadowRoot
*
shadow
=
aContent
.
GetContainingShadow
(
)
;
while
(
shadow
&
&
shadow
-
>
Host
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
use
)
)
{
shadow
=
shadow
-
>
Host
(
)
-
>
GetContainingShadow
(
)
;
}
if
(
shadow
)
{
return
shadow
;
}
return
aContent
.
OwnerDoc
(
)
;
}
void
IDTracker
:
:
Reset
(
nsIContent
*
aFromContent
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
bool
aWatch
bool
aReferenceImage
)
{
MOZ_ASSERT
(
aFromContent
"
Reset
(
)
expects
non
-
null
content
pointer
"
)
;
Unlink
(
)
;
if
(
!
aURI
)
return
;
nsAutoCString
refPart
;
aURI
-
>
GetRef
(
refPart
)
;
NS_UnescapeURL
(
refPart
)
;
nsIDocument
*
doc
=
aFromContent
-
>
OwnerDoc
(
)
;
DocumentOrShadowRoot
*
docOrShadow
=
DocOrShadowFromContent
(
*
aFromContent
)
;
auto
encoding
=
doc
-
>
GetDocumentCharacterSet
(
)
;
nsAutoString
ref
;
nsresult
rv
=
encoding
-
>
DecodeWithoutBOMHandling
(
refPart
ref
)
;
if
(
NS_FAILED
(
rv
)
|
|
ref
.
IsEmpty
(
)
)
{
return
;
}
rv
=
NS_OK
;
nsIContent
*
bindingParent
=
aFromContent
-
>
GetBindingParent
(
)
;
if
(
bindingParent
&
&
!
aFromContent
-
>
IsInShadowTree
(
)
)
{
nsXBLBinding
*
binding
=
bindingParent
-
>
GetXBLBinding
(
)
;
if
(
!
binding
)
{
Element
*
anonRoot
=
doc
-
>
GetAnonRootIfInAnonymousContentContainer
(
aFromContent
)
;
if
(
anonRoot
)
{
mElement
=
nsContentUtils
:
:
MatchElementId
(
anonRoot
ref
)
;
return
;
}
}
else
{
bool
isEqualExceptRef
;
rv
=
aURI
-
>
EqualsExceptRef
(
binding
-
>
PrototypeBinding
(
)
-
>
DocURI
(
)
&
isEqualExceptRef
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isEqualExceptRef
)
{
nsINodeList
*
anonymousChildren
=
doc
-
>
BindingManager
(
)
-
>
GetAnonymousNodesFor
(
bindingParent
)
;
if
(
anonymousChildren
)
{
uint32_t
length
=
anonymousChildren
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
&
&
!
mElement
;
+
+
i
)
{
mElement
=
nsContentUtils
:
:
MatchElementId
(
anonymousChildren
-
>
Item
(
i
)
ref
)
;
}
}
return
;
}
}
}
bool
isEqualExceptRef
;
rv
=
aURI
-
>
EqualsExceptRef
(
doc
-
>
GetDocumentURI
(
)
&
isEqualExceptRef
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
isEqualExceptRef
)
{
RefPtr
<
nsIDocument
:
:
ExternalResourceLoad
>
load
;
doc
=
doc
-
>
RequestExternalResource
(
aURI
aReferrer
aReferrerPolicy
aFromContent
getter_AddRefs
(
load
)
)
;
docOrShadow
=
doc
;
if
(
!
doc
)
{
if
(
!
load
|
|
!
aWatch
)
{
return
;
}
DocumentLoadNotification
*
observer
=
new
DocumentLoadNotification
(
this
ref
)
;
mPendingNotification
=
observer
;
load
-
>
AddObserver
(
observer
)
;
}
}
if
(
aWatch
)
{
mWatchID
=
NS_Atomize
(
ref
)
;
}
mReferencingImage
=
aReferenceImage
;
HaveNewDocumentOrShadowRoot
(
docOrShadow
aWatch
ref
)
;
}
void
IDTracker
:
:
ResetWithID
(
Element
&
aFrom
nsAtom
*
aID
bool
aWatch
)
{
MOZ_ASSERT
(
aID
)
;
if
(
aWatch
)
{
mWatchID
=
aID
;
}
mReferencingImage
=
false
;
DocumentOrShadowRoot
*
docOrShadow
=
DocOrShadowFromContent
(
aFrom
)
;
HaveNewDocumentOrShadowRoot
(
docOrShadow
aWatch
nsDependentAtomString
(
aID
)
)
;
}
void
IDTracker
:
:
HaveNewDocumentOrShadowRoot
(
DocumentOrShadowRoot
*
aDocOrShadow
bool
aWatch
const
nsString
&
aRef
)
{
if
(
aWatch
)
{
mWatchDocumentOrShadowRoot
=
nullptr
;
if
(
aDocOrShadow
)
{
mWatchDocumentOrShadowRoot
=
&
aDocOrShadow
-
>
AsNode
(
)
;
mElement
=
aDocOrShadow
-
>
AddIDTargetObserver
(
mWatchID
Observe
this
mReferencingImage
)
;
}
return
;
}
if
(
!
aDocOrShadow
)
{
return
;
}
Element
*
e
=
mReferencingImage
?
aDocOrShadow
-
>
LookupImageElement
(
aRef
)
:
aDocOrShadow
-
>
GetElementById
(
aRef
)
;
if
(
e
)
{
mElement
=
e
;
}
}
void
IDTracker
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCB
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCB
"
mWatchDocumentOrShadowRoot
"
)
;
aCB
-
>
NoteXPCOMChild
(
mWatchDocumentOrShadowRoot
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCB
"
mElement
"
)
;
aCB
-
>
NoteXPCOMChild
(
mElement
)
;
}
void
IDTracker
:
:
Unlink
(
)
{
if
(
mWatchID
)
{
if
(
DocumentOrShadowRoot
*
docOrShadow
=
GetWatchDocOrShadowRoot
(
)
)
{
docOrShadow
-
>
RemoveIDTargetObserver
(
mWatchID
Observe
this
mReferencingImage
)
;
}
}
if
(
mPendingNotification
)
{
mPendingNotification
-
>
Clear
(
)
;
mPendingNotification
=
nullptr
;
}
mWatchDocumentOrShadowRoot
=
nullptr
;
mWatchID
=
nullptr
;
mElement
=
nullptr
;
mReferencingImage
=
false
;
}
bool
IDTracker
:
:
Observe
(
Element
*
aOldElement
Element
*
aNewElement
void
*
aData
)
{
IDTracker
*
p
=
static_cast
<
IDTracker
*
>
(
aData
)
;
if
(
p
-
>
mPendingNotification
)
{
p
-
>
mPendingNotification
-
>
SetTo
(
aNewElement
)
;
}
else
{
NS_ASSERTION
(
aOldElement
=
=
p
-
>
mElement
"
Failed
to
track
content
!
"
)
;
ChangeNotification
*
watcher
=
new
ChangeNotification
(
p
aOldElement
aNewElement
)
;
p
-
>
mPendingNotification
=
watcher
;
nsContentUtils
:
:
AddScriptRunner
(
watcher
)
;
}
bool
keepTracking
=
p
-
>
IsPersistent
(
)
;
if
(
!
keepTracking
)
{
p
-
>
mWatchDocumentOrShadowRoot
=
nullptr
;
p
-
>
mWatchID
=
nullptr
;
}
return
keepTracking
;
}
NS_IMPL_ISUPPORTS_INHERITED0
(
IDTracker
:
:
ChangeNotification
mozilla
:
:
Runnable
)
NS_IMPL_ISUPPORTS
(
IDTracker
:
:
DocumentLoadNotification
nsIObserver
)
NS_IMETHODIMP
IDTracker
:
:
DocumentLoadNotification
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
PL_strcmp
(
aTopic
"
external
-
resource
-
document
-
created
"
)
=
=
0
"
Unexpected
topic
"
)
;
if
(
mTarget
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
aSubject
)
;
mTarget
-
>
mPendingNotification
=
nullptr
;
NS_ASSERTION
(
!
mTarget
-
>
mElement
"
Why
do
we
have
content
here
?
"
)
;
mTarget
-
>
HaveNewDocumentOrShadowRoot
(
doc
mTarget
-
>
IsPersistent
(
)
mRef
)
;
mTarget
-
>
ElementChanged
(
nullptr
mTarget
-
>
mElement
)
;
}
return
NS_OK
;
}
}
}
