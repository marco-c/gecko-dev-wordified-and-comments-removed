#
ifndef
mozilla_dom_Document_h___
#
define
mozilla_dom_Document_h___
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsICookieSettings
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIApplicationCache
.
h
"
#
include
"
nsIApplicationCacheContainer
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDOMXULCommandDispatcher
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsIRadioGroupContainer
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPropertyTable
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
StaticPresData
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentBlockingLog
.
h
"
#
include
"
mozilla
/
dom
/
DispatcherTrait
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
FailedCertSecurityInfoBinding
.
h
"
#
include
<
bitset
>
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
else
namespace
mozilla
{
namespace
dom
{
class
ElementCreationOptionsOrString
;
}
}
#
endif
class
gfxUserFontSet
;
class
imgIRequest
;
class
nsBindingManager
;
class
nsCachableElementsByNameNodeList
;
class
nsContentList
;
class
nsIDocShell
;
class
nsDocShell
;
class
nsDOMNavigationTiming
;
class
nsFrameLoader
;
class
nsGlobalWindowInner
;
class
nsHtml5TreeOpExecutor
;
class
nsHTMLCSSStyleSheet
;
class
nsHTMLDocument
;
class
nsHTMLStyleSheet
;
class
nsGenericHTMLElement
;
class
nsAtom
;
class
nsIBFCacheEntry
;
class
nsIChannel
;
class
nsIContent
;
class
nsIContentSecurityPolicy
;
class
nsIContentSink
;
class
nsIDocShell
;
class
nsIDocShellTreeItem
;
class
nsIDocumentEncoder
;
class
nsIDocumentObserver
;
class
nsIHTMLCollection
;
class
nsILayoutHistoryState
;
class
nsILoadContext
;
class
nsIObjectLoadingContent
;
class
nsIObserver
;
class
nsIPrincipal
;
class
nsIRequest
;
class
nsIRunnable
;
class
nsISecurityConsoleMessage
;
class
nsIStreamListener
;
class
nsIStructuredCloneContainer
;
class
nsIURI
;
class
nsIVariant
;
class
nsViewManager
;
class
nsPresContext
;
class
nsRange
;
class
nsSimpleContentList
;
class
nsTextNode
;
class
nsWindowSizes
;
class
nsDOMCaretPosition
;
class
nsViewportInfo
;
class
nsIGlobalObject
;
class
nsIXULWindow
;
class
nsXULPrototypeDocument
;
struct
nsFont
;
namespace
mozilla
{
class
AbstractThread
;
class
CSSStyleSheet
;
class
Encoding
;
class
ErrorResult
;
class
EventStates
;
class
EventListenerManager
;
class
FullscreenExit
;
class
FullscreenRequest
;
class
PendingAnimationTracker
;
class
PresShell
;
class
ServoStyleSet
;
class
SMILAnimationController
;
enum
class
StyleCursorKind
:
uint8_t
;
template
<
typename
>
class
OwningNonNull
;
struct
URLExtraData
;
namespace
css
{
class
Loader
;
class
ImageLoader
;
class
Rule
;
}
namespace
dom
{
class
Animation
;
class
AnonymousContent
;
class
Attr
;
class
BoxObject
;
class
XULBroadcastManager
;
class
XULPersist
;
class
ClientInfo
;
class
ClientState
;
class
CDATASection
;
class
Comment
;
struct
CustomElementDefinition
;
class
DocGroup
;
class
DocumentL10n
;
class
DocumentFragment
;
class
DocumentTimeline
;
class
DocumentType
;
class
DOMImplementation
;
class
DOMIntersectionObserver
;
class
DOMStringList
;
class
Element
;
struct
ElementCreationOptions
;
class
Event
;
class
EventTarget
;
class
FeaturePolicy
;
class
FontFaceSet
;
class
FrameRequestCallback
;
class
ImageTracker
;
class
HTMLBodyElement
;
class
HTMLSharedElement
;
class
HTMLImageElement
;
struct
LifecycleCallbackArgs
;
class
Link
;
class
Location
;
class
MediaQueryList
;
class
GlobalObject
;
class
NodeFilter
;
class
NodeIterator
;
enum
class
OrientationType
:
uint8_t
;
class
ProcessingInstruction
;
class
Promise
;
class
ScriptLoader
;
class
Selection
;
class
ServiceWorkerDescriptor
;
class
StyleSheetList
;
class
SVGDocument
;
class
SVGElement
;
class
SVGSVGElement
;
class
SVGUseElement
;
class
Touch
;
class
TouchList
;
class
TreeWalker
;
class
XPathEvaluator
;
class
XPathExpression
;
class
XPathNSResolver
;
class
XPathResult
;
class
XULDocument
;
template
<
typename
>
class
Sequence
;
class
nsDocumentOnStack
;
class
nsUnblockOnloadEvent
;
template
<
typename
typename
>
class
CallbackObjectHolder
;
enum
class
CallerType
:
uint32_t
;
enum
BFCacheStatus
{
NOT_ALLOWED
=
1
<
<
0
EVENT_HANDLING_SUPPRESSED
=
1
<
<
1
SUSPENDED
=
1
<
<
2
UNLOAD_LISTENER
=
1
<
<
3
REQUEST
=
1
<
<
4
ACTIVE_GET_USER_MEDIA
=
1
<
<
5
ACTIVE_PEER_CONNECTION
=
1
<
<
6
CONTAINS_EME_CONTENT
=
1
<
<
7
CONTAINS_MSE_CONTENT
=
1
<
<
8
HAS_ACTIVE_SPEECH_SYNTHESIS
=
1
<
<
9
HAS_USED_VR
=
1
<
<
10
}
;
}
}
namespace
mozilla
{
namespace
net
{
class
ChannelEventQueue
;
}
}
#
define
NS_IDOCUMENT_IID
\
{
\
0xce1f7627
0x7109
0x4977
{
\
0xba
0x77
0x49
0x0f
0xfd
0xe0
0x7a
0xaa
\
}
\
}
namespace
mozilla
{
namespace
dom
{
class
Document
;
class
DOMStyleSheetSetList
;
class
ResizeObserver
;
class
ResizeObserverController
;
#
define
NS_DOCUMENT_STATE_RTL_LOCALE
NS_DEFINE_EVENT_STATE_MACRO
(
0
)
#
define
NS_DOCUMENT_STATE_WINDOW_INACTIVE
NS_DEFINE_EVENT_STATE_MACRO
(
1
)
class
DocHeaderData
{
public
:
DocHeaderData
(
nsAtom
*
aField
const
nsAString
&
aData
)
:
mField
(
aField
)
mData
(
aData
)
mNext
(
nullptr
)
{
}
~
DocHeaderData
(
void
)
{
delete
mNext
;
}
RefPtr
<
nsAtom
>
mField
;
nsString
mData
;
DocHeaderData
*
mNext
;
}
;
class
ExternalResourceMap
{
typedef
bool
(
*
SubDocEnumFunc
)
(
Document
*
aDocument
void
*
aData
)
;
public
:
class
ExternalResourceLoad
:
public
nsISupports
{
public
:
virtual
~
ExternalResourceLoad
(
)
=
default
;
void
AddObserver
(
nsIObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
"
Must
have
observer
"
)
;
mObservers
.
AppendElement
(
aObserver
)
;
}
const
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
&
Observers
(
)
{
return
mObservers
;
}
protected
:
AutoTArray
<
nsCOMPtr
<
nsIObserver
>
8
>
mObservers
;
}
;
ExternalResourceMap
(
)
;
Document
*
RequestResource
(
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
nsINode
*
aRequestingNode
Document
*
aDisplayDocument
ExternalResourceLoad
*
*
aPendingLoad
)
;
void
EnumerateResources
(
SubDocEnumFunc
aCallback
void
*
aData
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
const
;
void
Shutdown
(
)
{
mPendingLoads
.
Clear
(
)
;
mMap
.
Clear
(
)
;
mHaveShutDown
=
true
;
}
bool
HaveShutDown
(
)
const
{
return
mHaveShutDown
;
}
struct
ExternalResource
{
~
ExternalResource
(
)
;
RefPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsIContentViewer
>
mViewer
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
}
;
void
HideViewers
(
)
;
void
ShowViewers
(
)
;
protected
:
class
PendingLoad
:
public
ExternalResourceLoad
public
nsIStreamListener
{
~
PendingLoad
(
)
{
}
public
:
explicit
PendingLoad
(
Document
*
aDisplayDocument
)
:
mDisplayDocument
(
aDisplayDocument
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
nsresult
StartLoad
(
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
nsINode
*
aRequestingNode
)
;
nsresult
SetupViewer
(
nsIRequest
*
aRequest
nsIContentViewer
*
*
aViewer
nsILoadGroup
*
*
aLoadGroup
)
;
private
:
RefPtr
<
Document
>
mDisplayDocument
;
nsCOMPtr
<
nsIStreamListener
>
mTargetListener
;
nsCOMPtr
<
nsIURI
>
mURI
;
}
;
friend
class
PendingLoad
;
class
LoadgroupCallbacks
final
:
public
nsIInterfaceRequestor
{
~
LoadgroupCallbacks
(
)
{
}
public
:
explicit
LoadgroupCallbacks
(
nsIInterfaceRequestor
*
aOtherCallbacks
)
:
mCallbacks
(
aOtherCallbacks
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
private
:
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
#
define
DECL_SHIM
(
_i
_allcaps
)
\
class
_i
#
#
Shim
final
:
public
nsIInterfaceRequestor
public
_i
{
\
~
_i
#
#
Shim
(
)
{
}
\
\
public
:
\
_i
#
#
Shim
(
nsIInterfaceRequestor
*
aIfreq
_i
*
aRealPtr
)
\
:
mIfReq
(
aIfreq
)
mRealPtr
(
aRealPtr
)
{
\
NS_ASSERTION
(
mIfReq
"
Expected
non
-
null
here
"
)
;
\
NS_ASSERTION
(
mRealPtr
"
Expected
non
-
null
here
"
)
;
\
}
\
NS_DECL_ISUPPORTS
\
NS_FORWARD_NSIINTERFACEREQUESTOR
(
mIfReq
-
>
)
\
NS_FORWARD_
#
#
_allcaps
(
mRealPtr
-
>
)
private
\
:
nsCOMPtr
<
nsIInterfaceRequestor
>
mIfReq
;
\
nsCOMPtr
<
_i
>
mRealPtr
;
\
}
;
DECL_SHIM
(
nsILoadContext
NSILOADCONTEXT
)
DECL_SHIM
(
nsIProgressEventSink
NSIPROGRESSEVENTSINK
)
DECL_SHIM
(
nsIChannelEventSink
NSICHANNELEVENTSINK
)
DECL_SHIM
(
nsIApplicationCacheContainer
NSIAPPLICATIONCACHECONTAINER
)
#
undef
DECL_SHIM
}
;
nsresult
AddExternalResource
(
nsIURI
*
aURI
nsIContentViewer
*
aViewer
nsILoadGroup
*
aLoadGroup
Document
*
aDisplayDocument
)
;
nsClassHashtable
<
nsURIHashKey
ExternalResource
>
mMap
;
nsRefPtrHashtable
<
nsURIHashKey
PendingLoad
>
mPendingLoads
;
bool
mHaveShutDown
;
}
;
class
Document
:
public
nsINode
public
DocumentOrShadowRoot
public
nsSupportsWeakReference
public
nsIRadioGroupContainer
public
nsIScriptObjectPrincipal
public
nsIApplicationCacheContainer
public
nsStubMutationObserver
public
DispatcherTrait
public
SupportsWeakPtr
<
Document
>
{
protected
:
explicit
Document
(
const
char
*
aContentType
)
;
virtual
~
Document
(
)
;
Document
(
const
Document
&
)
=
delete
;
Document
&
operator
=
(
const
Document
&
)
=
delete
;
public
:
typedef
dom
:
:
ExternalResourceMap
:
:
ExternalResourceLoad
ExternalResourceLoad
;
typedef
net
:
:
ReferrerPolicy
ReferrerPolicyEnum
;
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
Document
)
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IDOCUMENT_IID
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
Document
nsINode
)
#
define
NS_DOCUMENT_NOTIFY_OBSERVERS
(
func_
params_
)
\
do
{
\
NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS
(
mObservers
nsIDocumentObserver
\
func_
params_
)
;
\
/
*
FIXME
(
emilio
)
:
Apparently
we
can
keep
observing
from
the
BFCache
?
That
\
looks
bogus
.
*
/
\
if
(
PresShell
*
presShell
=
GetObservingPresShell
(
)
)
{
\
presShell
-
>
func_
params_
;
\
}
\
}
while
(
0
)
NS_DECL_NSIAPPLICATIONCACHECONTAINER
NS_IMETHOD
WalkRadioGroup
(
const
nsAString
&
aName
nsIRadioVisitor
*
aVisitor
bool
aFlushContent
)
final
{
return
DocumentOrShadowRoot
:
:
WalkRadioGroup
(
aName
aVisitor
aFlushContent
)
;
}
void
SetCurrentRadioButton
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
final
{
DocumentOrShadowRoot
:
:
SetCurrentRadioButton
(
aName
aRadio
)
;
}
HTMLInputElement
*
GetCurrentRadioButton
(
const
nsAString
&
aName
)
final
{
return
DocumentOrShadowRoot
:
:
GetCurrentRadioButton
(
aName
)
;
}
NS_IMETHOD
GetNextRadioButton
(
const
nsAString
&
aName
const
bool
aPrevious
HTMLInputElement
*
aFocusedRadio
HTMLInputElement
*
*
aRadioOut
)
final
{
return
DocumentOrShadowRoot
:
:
GetNextRadioButton
(
aName
aPrevious
aFocusedRadio
aRadioOut
)
;
}
void
AddToRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
final
{
DocumentOrShadowRoot
:
:
AddToRadioGroup
(
aName
aRadio
)
;
}
void
RemoveFromRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
final
{
DocumentOrShadowRoot
:
:
RemoveFromRadioGroup
(
aName
aRadio
)
;
}
uint32_t
GetRequiredRadioCount
(
const
nsAString
&
aName
)
const
final
{
return
DocumentOrShadowRoot
:
:
GetRequiredRadioCount
(
aName
)
;
}
void
RadioRequiredWillChange
(
const
nsAString
&
aName
bool
aRequiredAdded
)
final
{
DocumentOrShadowRoot
:
:
RadioRequiredWillChange
(
aName
aRequiredAdded
)
;
}
bool
GetValueMissingState
(
const
nsAString
&
aName
)
const
final
{
return
DocumentOrShadowRoot
:
:
GetValueMissingState
(
aName
)
;
}
void
SetValueMissingState
(
const
nsAString
&
aName
bool
aValue
)
final
{
return
DocumentOrShadowRoot
:
:
SetValueMissingState
(
aName
aValue
)
;
}
nsIPrincipal
*
EffectiveStoragePrincipal
(
)
const
;
nsIPrincipal
*
GetPrincipal
(
)
final
{
return
NodePrincipal
(
)
;
}
nsIPrincipal
*
GetEffectiveStoragePrincipal
(
)
final
{
return
EffectiveStoragePrincipal
(
)
;
}
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
class
MOZ_RAII
PageUnloadingEventTimeStamp
{
RefPtr
<
Document
>
mDocument
;
bool
mSet
;
public
:
explicit
PageUnloadingEventTimeStamp
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mSet
(
false
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
mDocument
-
>
mPageUnloadingEventTimeStamp
.
IsNull
(
)
)
{
mDocument
-
>
SetPageUnloadingEventTimeStamp
(
)
;
mSet
=
true
;
}
}
~
PageUnloadingEventTimeStamp
(
)
{
if
(
mSet
)
{
mDocument
-
>
CleanUnloadEventsTimeStamp
(
)
;
}
}
}
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
=
nullptr
)
=
0
;
void
StopDocumentLoad
(
)
;
virtual
void
SetSuppressParserErrorElement
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorElement
(
)
{
return
false
;
}
virtual
void
SetSuppressParserErrorConsoleMessages
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorConsoleMessages
(
)
{
return
false
;
}
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
final
;
nsresult
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
override
;
void
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
final
;
nsresult
Clone
(
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
CloneDocHelper
(
Document
*
clone
)
const
;
Document
*
GetLatestStaticClone
(
)
const
{
return
mLatestStaticClone
;
}
virtual
void
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
;
nsIURI
*
GetDocumentURI
(
)
const
{
return
mDocumentURI
;
}
nsIURI
*
GetOriginalURI
(
)
const
{
return
mOriginalURI
;
}
nsCString
GetBaseDomain
(
)
const
{
return
mBaseDomain
;
}
void
SetDocumentURI
(
nsIURI
*
aURI
)
;
void
SetChromeXHRDocURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocURI
=
aURI
;
}
void
SetChromeXHRDocBaseURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocBaseURI
=
aURI
;
}
nsIContentSecurityPolicy
*
GetCsp
(
)
const
;
void
SetCsp
(
nsIContentSecurityPolicy
*
aCSP
)
;
nsIContentSecurityPolicy
*
GetPreloadCsp
(
)
const
;
void
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCSP
)
;
void
GetCspJSON
(
nsString
&
aJSON
)
;
void
ApplySettingsFromCSP
(
bool
aSpeculative
)
;
already_AddRefed
<
nsIParser
>
CreatorParserOrNull
(
)
{
nsCOMPtr
<
nsIParser
>
parser
=
mParser
;
return
parser
.
forget
(
)
;
}
ReferrerPolicyEnum
GetReferrerPolicy
(
)
const
;
uint32_t
ReferrerPolicy
(
)
const
{
return
GetReferrerPolicy
(
)
;
}
bool
GetBlockAllMixedContent
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mBlockAllMixedContentPreloads
;
}
return
mBlockAllMixedContent
;
}
bool
GetUpgradeInsecureRequests
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mUpgradeInsecurePreloads
;
}
return
mUpgradeInsecureRequests
;
}
void
SetReferrer
(
const
nsACString
&
aReferrer
)
{
mReferrer
=
aReferrer
;
}
void
SetPrincipals
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
)
;
const
nsTArray
<
nsCOMPtr
<
nsIPrincipal
>
>
&
AncestorPrincipals
(
)
const
{
return
mAncestorPrincipals
;
}
const
nsTArray
<
uint64_t
>
&
AncestorOuterWindowIDs
(
)
const
{
return
mAncestorOuterWindowIDs
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
const
{
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
return
group
.
forget
(
)
;
}
nsIURI
*
GetFallbackBaseURI
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
{
return
mParentDocument
-
>
GetDocBaseURI
(
)
;
}
return
mDocumentURI
;
}
nsIURI
*
GetDocumentURIAsReferrer
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
{
return
mParentDocument
-
>
GetDocumentURIAsReferrer
(
)
;
}
return
mDocumentURI
;
}
nsIURI
*
GetDocBaseURI
(
)
const
{
if
(
mDocumentBaseURI
)
{
return
mDocumentBaseURI
;
}
return
GetFallbackBaseURI
(
)
;
}
already_AddRefed
<
nsIURI
>
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
final
;
void
SetBaseURI
(
nsIURI
*
aURI
)
;
URLExtraData
*
DefaultStyleAttrURLData
(
)
;
void
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
{
aBaseTarget
=
mBaseTarget
;
}
void
SetBaseTarget
(
const
nsString
&
aBaseTarget
)
{
mBaseTarget
=
aBaseTarget
;
}
NotNull
<
const
Encoding
*
>
GetDocumentCharacterSet
(
)
const
{
return
mCharacterSet
;
}
void
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
;
int32_t
GetDocumentCharacterSetSource
(
)
const
{
return
mCharacterSetSource
;
}
void
SetDocumentCharacterSetSource
(
int32_t
aCharsetSource
)
{
mCharacterSetSource
=
aCharsetSource
;
}
void
GetContentType
(
nsAString
&
aContentType
)
;
virtual
void
SetContentType
(
const
nsAString
&
aContentType
)
;
void
GetContentLanguage
(
nsAString
&
aContentLanguage
)
const
{
CopyASCIItoUTF16
(
mContentLanguage
aContentLanguage
)
;
}
bool
GetBidiEnabled
(
)
const
{
return
mBidiEnabled
;
}
void
SetBidiEnabled
(
)
{
mBidiEnabled
=
true
;
}
void
SetMathMLEnabled
(
)
{
mMathMLEnabled
=
true
;
}
bool
IsInitialDocument
(
)
const
{
return
mIsInitialDocumentInWindow
;
}
void
SetIsInitialDocument
(
bool
aIsInitialDocument
)
{
mIsInitialDocumentInWindow
=
aIsInitialDocument
;
}
void
SetLoadedAsData
(
bool
aLoadedAsData
)
{
mLoadedAsData
=
aLoadedAsData
;
}
void
SetLoadedAsInteractiveData
(
bool
aLoadedAsInteractiveData
)
{
mLoadedAsInteractiveData
=
aLoadedAsInteractiveData
;
}
void
IgnoreDocGroupMismatches
(
)
{
mIgnoreDocGroupMismatches
=
true
;
}
uint32_t
GetBidiOptions
(
)
const
{
return
mBidiOptions
;
}
void
SetBidiOptions
(
uint32_t
aBidiOptions
)
{
mBidiOptions
=
aBidiOptions
;
}
bool
GetHasMixedActiveContentLoaded
(
)
{
return
mHasMixedActiveContentLoaded
;
}
void
SetHasMixedActiveContentLoaded
(
bool
aHasMixedActiveContentLoaded
)
{
mHasMixedActiveContentLoaded
=
aHasMixedActiveContentLoaded
;
}
bool
GetHasMixedActiveContentBlocked
(
)
{
return
mHasMixedActiveContentBlocked
;
}
void
SetHasMixedActiveContentBlocked
(
bool
aHasMixedActiveContentBlocked
)
{
mHasMixedActiveContentBlocked
=
aHasMixedActiveContentBlocked
;
}
bool
GetHasMixedDisplayContentLoaded
(
)
{
return
mHasMixedDisplayContentLoaded
;
}
void
SetHasMixedDisplayContentLoaded
(
bool
aHasMixedDisplayContentLoaded
)
{
mHasMixedDisplayContentLoaded
=
aHasMixedDisplayContentLoaded
;
}
bool
GetHasMixedDisplayContentBlocked
(
)
{
return
mHasMixedDisplayContentBlocked
;
}
void
SetHasMixedDisplayContentBlocked
(
bool
aHasMixedDisplayContentBlocked
)
{
mHasMixedDisplayContentBlocked
=
aHasMixedDisplayContentBlocked
;
}
void
SetHasMixedContentObjectSubrequest
(
bool
aHasMixedContentObjectSubrequest
)
{
mHasMixedContentObjectSubrequest
=
aHasMixedContentObjectSubrequest
;
}
void
SetHasCSP
(
bool
aHasCSP
)
{
mHasCSP
=
aHasCSP
;
}
void
SetHasUnsafeInlineCSP
(
bool
aHasUnsafeInlineCSP
)
{
mHasUnsafeInlineCSP
=
aHasUnsafeInlineCSP
;
}
void
SetHasUnsafeEvalCSP
(
bool
aHasUnsafeEvalCSP
)
{
mHasUnsafeEvalCSP
=
aHasUnsafeEvalCSP
;
}
ContentBlockingLog
*
GetContentBlockingLog
(
)
{
return
&
mContentBlockingLog
;
}
bool
GetHasTrackingContentBlocked
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
)
;
}
bool
GetHasFingerprintingContentBlocked
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_BLOCKED_FINGERPRINTING_CONTENT
)
;
}
bool
GetHasCryptominingContentBlocked
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_BLOCKED_CRYPTOMINING_CONTENT
)
;
}
bool
GetHasAllCookiesBlocked
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
)
;
}
bool
GetHasTrackingCookiesBlocked
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
)
;
}
bool
GetHasForeignCookiesBlocked
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
)
;
}
bool
GetHasCookiesBlockedByPermission
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
)
;
}
void
SetHasTrackingContentBlocked
(
bool
aHasTrackingContentBlocked
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_BLOCKED_TRACKING_CONTENT
aHasTrackingContentBlocked
)
;
}
void
SetHasFingerprintingContentBlocked
(
bool
aHasFingerprintingContentBlocked
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_BLOCKED_FINGERPRINTING_CONTENT
aHasFingerprintingContentBlocked
)
;
}
void
SetHasCryptominingContentBlocked
(
bool
aHasCryptominingContentBlocked
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_BLOCKED_CRYPTOMINING_CONTENT
aHasCryptominingContentBlocked
)
;
}
void
SetHasAllCookiesBlocked
(
bool
aHasAllCookiesBlocked
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_ALL
aHasAllCookiesBlocked
)
;
}
void
SetHasTrackingCookiesBlocked
(
bool
aHasTrackingCookiesBlocked
const
nsACString
&
aOriginBlocked
const
Maybe
<
AntiTrackingCommon
:
:
StorageAccessGrantedReason
>
&
aReason
const
nsTArray
<
nsCString
>
&
aTrackingFullHashes
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
aHasTrackingCookiesBlocked
aReason
aTrackingFullHashes
)
;
}
void
SetHasForeignCookiesBlocked
(
bool
aHasForeignCookiesBlocked
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
aHasForeignCookiesBlocked
)
;
}
void
SetHasCookiesBlockedByPermission
(
bool
aHasCookiesBlockedByPermission
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_BY_PERMISSION
aHasCookiesBlockedByPermission
)
;
}
void
SetHasCookiesLoaded
(
bool
aHasCookiesLoaded
const
nsACString
&
aOriginLoaded
)
{
RecordContentBlockingLog
(
aOriginLoaded
nsIWebProgressListener
:
:
STATE_COOKIES_LOADED
aHasCookiesLoaded
)
;
}
bool
GetHasCookiesLoaded
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_COOKIES_LOADED
)
;
}
bool
GetHasTrackingContentLoaded
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_LOADED_TRACKING_CONTENT
)
;
}
void
SetHasTrackingContentLoaded
(
bool
aHasTrackingContentLoaded
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_LOADED_TRACKING_CONTENT
aHasTrackingContentLoaded
)
;
}
bool
GetHasFingerprintingContentLoaded
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_LOADED_FINGERPRINTING_CONTENT
)
;
}
void
SetHasFingerprintingContentLoaded
(
bool
aHasFingerprintingContentLoaded
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_LOADED_FINGERPRINTING_CONTENT
aHasFingerprintingContentLoaded
)
;
}
bool
GetHasCryptominingContentLoaded
(
)
{
return
mContentBlockingLog
.
HasBlockedAnyOfType
(
nsIWebProgressListener
:
:
STATE_LOADED_CRYPTOMINING_CONTENT
)
;
}
void
SetHasCryptominingContentLoaded
(
bool
aHasCryptominingContentLoaded
const
nsACString
&
aOriginBlocked
)
{
RecordContentBlockingLog
(
aOriginBlocked
nsIWebProgressListener
:
:
STATE_LOADED_CRYPTOMINING_CONTENT
aHasCryptominingContentLoaded
)
;
}
uint32_t
GetSandboxFlags
(
)
const
{
return
mSandboxFlags
;
}
void
GetSandboxFlagsAsString
(
nsAString
&
aFlags
)
;
void
SetSandboxFlags
(
uint32_t
sandboxFlags
)
{
mSandboxFlags
=
sandboxFlags
;
}
void
EnableEncodingMenu
(
)
{
mEncodingMenuDisabled
=
false
;
}
void
DisableCookieAccess
(
)
{
mDisableCookieAccess
=
true
;
}
void
SetCompatibilityMode
(
nsCompatibility
aMode
)
;
void
SetDocWriteDisabled
(
bool
aDisabled
)
{
mDisableDocWrite
=
aDisabled
;
}
bool
IsWriting
(
)
const
{
return
mWriteLevel
!
=
uint32_t
(
0
)
;
}
void
GetHeaderData
(
nsAtom
*
aHeaderField
nsAString
&
aData
)
const
;
void
SetHeaderData
(
nsAtom
*
aheaderField
const
nsAString
&
aData
)
;
already_AddRefed
<
PresShell
>
CreatePresShell
(
nsPresContext
*
aContext
nsViewManager
*
aViewManager
)
;
void
DeletePresShell
(
)
;
PresShell
*
GetPresShell
(
)
const
{
return
GetBFCacheEntry
(
)
?
nullptr
:
mPresShell
;
}
inline
PresShell
*
GetObservingPresShell
(
)
const
;
bool
IsSafeToFlush
(
)
const
;
inline
nsPresContext
*
GetPresContext
(
)
const
;
bool
HasShellOrBFCacheEntry
(
)
const
{
return
mPresShell
|
|
mBFCacheEntry
;
}
void
DisallowBFCaching
(
)
{
NS_ASSERTION
(
!
mBFCacheEntry
"
We
'
re
already
in
the
bfcache
!
"
)
;
mBFCacheDisallowed
=
true
;
}
bool
IsBFCachingAllowed
(
)
const
{
return
!
mBFCacheDisallowed
;
}
void
SetBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
;
nsIBFCacheEntry
*
GetBFCacheEntry
(
)
const
{
return
mBFCacheEntry
;
}
Document
*
GetParentDocument
(
)
const
{
return
mParentDocument
;
}
void
SetParentDocument
(
Document
*
aParent
)
{
mParentDocument
=
aParent
;
if
(
aParent
)
{
mIgnoreDocGroupMismatches
=
aParent
-
>
mIgnoreDocGroupMismatches
;
}
}
bool
GetAllowPlugins
(
)
;
nsresult
SetSubDocumentFor
(
Element
*
aContent
Document
*
aSubDoc
)
;
Document
*
GetSubDocumentFor
(
nsIContent
*
aContent
)
const
;
Element
*
FindContentForSubDocument
(
Document
*
aDocument
)
const
;
DocumentType
*
GetDoctype
(
)
const
;
Element
*
GetRootElement
(
)
const
;
Selection
*
GetSelection
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
HasStorageAccess
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
RequestStorageAccess
(
ErrorResult
&
aRv
)
;
virtual
Element
*
GetUnfocusedKeyEventTarget
(
)
;
nsViewportInfo
GetViewportInfo
(
const
ScreenIntSize
&
aDisplaySize
)
;
void
UpdateForScrollAnchorAdjustment
(
nscoord
aLength
)
;
virtual
bool
WillIgnoreCharsetOverride
(
)
{
return
true
;
}
bool
IsSrcdocDocument
(
)
const
{
return
mIsSrcdocDocument
;
}
void
SetIsSrcdocDocument
(
bool
aIsSrcdocDocument
)
{
mIsSrcdocDocument
=
aIsSrcdocDocument
;
}
nsresult
GetSrcdocData
(
nsAString
&
aSrcdocData
)
;
already_AddRefed
<
AnonymousContent
>
InsertAnonymousContent
(
Element
&
aElement
ErrorResult
&
aError
)
;
void
RemoveAnonymousContent
(
AnonymousContent
&
aContent
ErrorResult
&
aError
)
;
Element
*
GetAnonRootIfInAnonymousContentContainer
(
nsINode
*
aNode
)
const
;
nsTArray
<
RefPtr
<
AnonymousContent
>
>
&
GetAnonymousContents
(
)
{
return
mAnonymousContents
;
}
TimeStamp
GetPageUnloadingEventTimeStamp
(
)
const
{
if
(
!
mParentDocument
)
{
return
mPageUnloadingEventTimeStamp
;
}
TimeStamp
parentTimeStamp
(
mParentDocument
-
>
GetPageUnloadingEventTimeStamp
(
)
)
;
if
(
parentTimeStamp
.
IsNull
(
)
)
{
return
mPageUnloadingEventTimeStamp
;
}
if
(
!
mPageUnloadingEventTimeStamp
|
|
parentTimeStamp
<
mPageUnloadingEventTimeStamp
)
{
return
parentTimeStamp
;
}
return
mPageUnloadingEventTimeStamp
;
}
void
NotifyLayerManagerRecreated
(
)
;
void
ScheduleSVGForPresAttrEvaluation
(
SVGElement
*
aSVG
)
{
mLazySVGPresElements
.
PutEntry
(
aSVG
)
;
}
void
UnscheduleSVGForPresAttrEvaluation
(
SVGElement
*
aSVG
)
{
mLazySVGPresElements
.
RemoveEntry
(
aSVG
)
;
}
void
ResolveScheduledSVGPresAttrs
(
)
;
Maybe
<
ClientInfo
>
GetClientInfo
(
)
const
;
Maybe
<
ClientState
>
GetClientState
(
)
const
;
Maybe
<
ServiceWorkerDescriptor
>
GetController
(
)
const
;
long
BlockedNodeByClassifierCount
(
)
const
{
return
mBlockedNodesByClassifier
.
Length
(
)
;
}
already_AddRefed
<
nsSimpleContentList
>
BlockedNodesByClassifier
(
)
const
;
bool
StorageAccessSandboxed
(
)
const
;
nsICookieSettings
*
CookieSettings
(
)
;
inline
void
Changed
(
)
{
+
+
mGeneration
;
}
inline
int32_t
GetGeneration
(
)
const
{
return
mGeneration
;
}
bool
GetCachedSizes
(
nsTabSizes
*
aSizes
)
;
void
SetCachedSizes
(
nsTabSizes
*
aSizes
)
;
protected
:
friend
class
nsUnblockOnloadEvent
;
nsresult
InitCSP
(
nsIChannel
*
aChannel
)
;
nsresult
InitFeaturePolicy
(
nsIChannel
*
aChannel
)
;
void
PostUnblockOnloadEvent
(
)
;
void
DoUnblockOnload
(
)
;
void
ClearAllBoxObjects
(
)
;
void
MaybeEndOutermostXBLUpdate
(
)
;
void
RetrieveRelevantHeaders
(
nsIChannel
*
aChannel
)
;
void
TryChannelCharset
(
nsIChannel
*
aChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
nsHtml5TreeOpExecutor
*
aExecutor
)
;
void
DispatchContentLoadedEvents
(
)
;
void
DispatchPageTransition
(
EventTarget
*
aDispatchTarget
const
nsAString
&
aType
bool
aPersisted
bool
aOnlySystemGroup
=
false
)
;
void
DestroyElementMaps
(
)
;
Element
*
GetRootElementInternal
(
)
const
;
void
DoNotifyPossibleTitleChange
(
)
;
void
SetPageUnloadingEventTimeStamp
(
)
{
MOZ_ASSERT
(
!
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
TimeStamp
:
:
NowLoRes
(
)
;
}
void
CleanUnloadEventsTimeStamp
(
)
{
MOZ_ASSERT
(
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
TimeStamp
(
)
;
}
void
ClearStaleServoData
(
)
;
already_AddRefed
<
nsPIWindowRoot
>
GetWindowRoot
(
)
;
void
DisconnectNodeTree
(
)
;
private
:
class
SelectorCacheKey
{
public
:
explicit
SelectorCacheKey
(
const
nsAString
&
aString
)
:
mKey
(
aString
)
{
MOZ_COUNT_CTOR
(
SelectorCacheKey
)
;
}
nsString
mKey
;
nsExpirationState
mState
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mState
;
}
~
SelectorCacheKey
(
)
{
MOZ_COUNT_DTOR
(
SelectorCacheKey
)
;
}
}
;
class
SelectorCacheKeyDeleter
;
public
:
class
SelectorCache
final
:
public
nsExpirationTracker
<
SelectorCacheKey
4
>
{
public
:
using
SelectorList
=
UniquePtr
<
RawServoSelectorList
>
;
explicit
SelectorCache
(
nsIEventTarget
*
aEventTarget
)
;
void
CacheList
(
const
nsAString
&
aSelector
SelectorList
aSelectorList
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SelectorCacheKey
*
key
=
new
SelectorCacheKey
(
aSelector
)
;
mTable
.
Put
(
key
-
>
mKey
std
:
:
move
(
aSelectorList
)
)
;
AddObject
(
key
)
;
}
void
NotifyExpired
(
SelectorCacheKey
*
aSelector
)
final
;
SelectorList
*
GetList
(
const
nsAString
&
aSelector
)
{
return
mTable
.
GetValue
(
aSelector
)
;
}
~
SelectorCache
(
)
;
private
:
nsDataHashtable
<
nsStringHashKey
SelectorList
>
mTable
;
}
;
SelectorCache
&
GetSelectorCache
(
)
{
if
(
!
mSelectorCache
)
{
mSelectorCache
=
MakeUnique
<
SelectorCache
>
(
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
return
*
mSelectorCache
;
}
Element
*
GetHtmlElement
(
)
const
;
Element
*
GetHtmlChildElement
(
nsAtom
*
aTag
)
;
HTMLBodyElement
*
GetBodyElement
(
)
;
Element
*
GetHeadElement
(
)
{
return
GetHtmlChildElement
(
nsGkAtoms
:
:
head
)
;
}
nsGenericHTMLElement
*
GetBody
(
)
;
void
SetBody
(
nsGenericHTMLElement
*
aBody
ErrorResult
&
rv
)
;
HTMLSharedElement
*
GetHead
(
)
;
ServoStyleSet
*
StyleSetForPresShellOrMediaQueryEvaluation
(
)
const
{
return
mStyleSet
.
get
(
)
;
}
void
RecordShadowStyleChange
(
ShadowRoot
&
)
;
void
ApplicableStylesChanged
(
)
;
bool
StyleSetFilled
(
)
const
{
return
mStyleSetFilled
;
}
StyleSheetList
*
StyleSheets
(
)
{
return
&
DocumentOrShadowRoot
:
:
EnsureDOMStyleSheets
(
)
;
}
void
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
)
;
void
AddStyleSheet
(
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
InsertSheetAt
(
SheetCount
(
)
*
aSheet
)
;
}
void
RemoveStyleSheet
(
StyleSheet
*
aSheet
)
;
void
SetStyleSheetApplicableState
(
StyleSheet
*
aSheet
bool
aApplicable
)
;
enum
additionalSheetType
{
eAgentSheet
eUserSheet
eAuthorSheet
AdditionalSheetTypeCount
}
;
nsresult
LoadAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
;
nsresult
AddAdditionalStyleSheet
(
additionalSheetType
aType
StyleSheet
*
aSheet
)
;
void
RemoveAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
sheetURI
)
;
StyleSheet
*
GetFirstAdditionalAuthorSheet
(
)
{
return
mAdditionalSheets
[
eAuthorSheet
]
.
SafeElementAt
(
0
)
;
}
size_t
FindDocStyleSheetInsertionPoint
(
const
StyleSheet
&
aSheet
)
;
css
:
:
Loader
*
CSSLoader
(
)
const
{
return
mCSSLoader
;
}
css
:
:
ImageLoader
*
StyleImageLoader
(
)
const
{
return
mStyleImageLoader
;
}
nsIChannel
*
GetChannel
(
)
const
{
return
mChannel
;
}
nsHTMLStyleSheet
*
GetAttributeStyleSheet
(
)
const
{
return
mAttrStyleSheet
;
}
nsHTMLCSSStyleSheet
*
GetInlineStyleSheet
(
)
const
{
return
mStyleAttrStyleSheet
;
}
virtual
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aGlobalObject
)
;
nsIScriptGlobalObject
*
GetScriptHandlingObject
(
bool
&
aHasHadScriptHandlingObject
)
const
{
aHasHadScriptHandlingObject
=
mHasHadScriptHandlingObject
;
return
mScriptGlobalObject
?
mScriptGlobalObject
.
get
(
)
:
GetScriptHandlingObjectInternal
(
)
;
}
void
SetScriptHandlingObject
(
nsIScriptGlobalObject
*
aScriptObject
)
;
nsIGlobalObject
*
GetScopeObject
(
)
const
;
void
SetScopeObject
(
nsIGlobalObject
*
aGlobal
)
;
nsPIDOMWindowOuter
*
GetWindow
(
)
const
{
return
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
GetWindowInternal
(
)
;
}
bool
IsInBackgroundWindow
(
)
const
{
auto
*
outer
=
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
nullptr
;
return
outer
&
&
outer
-
>
IsBackground
(
)
;
}
nsPIDOMWindowInner
*
GetInnerWindow
(
)
const
{
return
mRemovedFromDocShell
?
nullptr
:
mWindow
;
}
uint64_t
OuterWindowID
(
)
const
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
uint64_t
InnerWindowID
(
)
const
{
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
bool
IsTopLevelWindowInactive
(
)
const
;
dom
:
:
ScriptLoader
*
ScriptLoader
(
)
{
return
mScriptLoader
;
}
void
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
AddToNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
void
RemoveFromNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
nsTArray
<
Element
*
>
GetFullscreenStack
(
)
const
;
void
AsyncRequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
)
;
bool
FullscreenElementReadyCheck
(
const
FullscreenRequest
&
)
;
void
RequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
)
;
void
CleanupFullscreenState
(
)
;
bool
FullscreenStackPush
(
Element
*
aElement
)
;
void
FullscreenStackPop
(
)
;
nsresult
RemoteFrameFullscreenChanged
(
Element
*
aFrameElement
)
;
nsresult
RemoteFrameFullscreenReverted
(
)
;
void
RestorePreviousFullscreenState
(
UniquePtr
<
FullscreenExit
>
)
;
bool
IsFullscreenLeaf
(
)
;
Document
*
GetFullscreenRoot
(
)
;
void
SetFullscreenRoot
(
Document
*
aRoot
)
;
static
void
ExitFullscreenInDocTree
(
Document
*
aDocument
)
;
static
void
AsyncExitFullscreen
(
Document
*
aDocument
)
;
static
bool
HandlePendingFullscreenRequests
(
Document
*
aDocument
)
;
void
RequestPointerLock
(
Element
*
aElement
CallerType
)
;
MOZ_CAN_RUN_SCRIPT
bool
SetPointerLock
(
Element
*
aElement
StyleCursorKind
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
void
UnlockPointer
(
Document
*
aDoc
=
nullptr
)
;
void
SetCurrentOrientation
(
OrientationType
aType
uint16_t
aAngle
)
{
mCurrentOrientationType
=
aType
;
mCurrentOrientationAngle
=
aAngle
;
}
uint16_t
CurrentOrientationAngle
(
)
const
{
return
mCurrentOrientationAngle
;
}
OrientationType
CurrentOrientationType
(
)
const
{
return
mCurrentOrientationType
;
}
void
SetOrientationPendingPromise
(
Promise
*
aPromise
)
;
Promise
*
GetOrientationPendingPromise
(
)
const
{
return
mOrientationPendingPromise
;
}
void
SetRDMPaneOrientation
(
OrientationType
aType
uint16_t
aAngle
)
{
if
(
mInRDMPane
)
{
SetCurrentOrientation
(
aType
aAngle
)
;
}
}
void
AddObserver
(
nsIDocumentObserver
*
aObserver
)
;
bool
RemoveObserver
(
nsIDocumentObserver
*
aObserver
)
;
void
BeginUpdate
(
)
;
virtual
void
EndUpdate
(
)
;
uint32_t
UpdateNestingLevel
(
)
{
return
mUpdateNestLevel
;
}
virtual
void
BeginLoad
(
)
;
virtual
void
EndLoad
(
)
;
enum
ReadyState
{
READYSTATE_UNINITIALIZED
=
0
READYSTATE_LOADING
=
1
READYSTATE_INTERACTIVE
=
3
READYSTATE_COMPLETE
=
4
}
;
void
SetReadyStateInternal
(
ReadyState
rs
bool
updateTimingInformation
=
true
)
;
ReadyState
GetReadyStateEnum
(
)
{
return
mReadyState
;
}
void
SetAncestorLoading
(
bool
aAncestorIsLoading
)
;
void
NotifyLoading
(
const
bool
&
aCurrentParentIsLoading
bool
aNewParentIsLoading
const
ReadyState
&
aCurrentState
ReadyState
aNewState
)
;
void
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aStateMask
)
;
void
UpdateDocumentStates
(
EventStates
aStateMask
bool
aNotify
)
;
void
ResetDocumentDirection
(
)
;
void
StyleRuleChanged
(
StyleSheet
*
aStyleSheet
css
:
:
Rule
*
aStyleRule
)
;
void
StyleRuleAdded
(
StyleSheet
*
aStyleSheet
css
:
:
Rule
*
aStyleRule
)
;
void
StyleRuleRemoved
(
StyleSheet
*
aStyleSheet
css
:
:
Rule
*
aStyleRule
)
;
void
FlushPendingNotifications
(
FlushType
aType
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
FlushPendingNotifications
(
ChangesToFlush
aFlush
)
;
void
FlushExternalResources
(
FlushType
aType
)
;
void
UpdateSVGUseElementShadowTrees
(
)
{
if
(
mSVGUseElementsNeedingShadowTreeUpdate
.
IsEmpty
(
)
)
{
return
;
}
DoUpdateSVGUseElementShadowTrees
(
)
;
}
nsBindingManager
*
BindingManager
(
)
const
{
return
mNodeInfoManager
-
>
GetBindingManager
(
)
;
}
nsNodeInfoManager
*
NodeInfoManager
(
)
const
{
return
mNodeInfoManager
;
}
virtual
void
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
;
virtual
void
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
)
;
virtual
void
SetContainer
(
nsDocShell
*
aContainer
)
;
virtual
nsISupports
*
GetContainer
(
)
const
;
nsILoadContext
*
GetLoadContext
(
)
const
;
nsIDocShell
*
GetDocShell
(
)
const
;
void
SetXMLDeclaration
(
const
char16_t
*
aVersion
const
char16_t
*
aEncoding
const
int32_t
aStandalone
)
;
void
GetXMLDeclaration
(
nsAString
&
aVersion
nsAString
&
aEncoding
nsAString
&
Standalone
)
;
bool
IsHTMLDocument
(
)
const
{
return
mType
=
=
eHTML
;
}
bool
IsHTMLOrXHTML
(
)
const
{
return
mType
=
=
eHTML
|
|
mType
=
=
eXHTML
;
}
bool
IsXMLDocument
(
)
const
{
return
!
IsHTMLDocument
(
)
;
}
bool
IsSVGDocument
(
)
const
{
return
mType
=
=
eSVG
;
}
bool
IsXULDocument
(
)
const
{
return
mType
=
=
eXUL
;
}
bool
IsUnstyledDocument
(
)
{
return
IsLoadedAsData
(
)
|
|
IsLoadedAsInteractiveData
(
)
;
}
bool
LoadsFullXULStyleSheetUpFront
(
)
{
if
(
IsXULDocument
(
)
)
{
return
true
;
}
if
(
IsSVGDocument
(
)
)
{
return
false
;
}
return
AllowXULXBL
(
)
;
}
bool
IsScriptEnabled
(
)
;
bool
LoadedFromPrototype
(
)
const
{
return
mPrototypeDocument
;
}
bool
IsTopLevelContentDocument
(
)
const
{
return
mIsTopLevelContentDocument
;
}
void
SetIsTopLevelContentDocument
(
bool
aIsTopLevelContentDocument
)
{
mIsTopLevelContentDocument
=
aIsTopLevelContentDocument
;
if
(
aIsTopLevelContentDocument
)
{
SetAllowPaymentRequest
(
true
)
;
}
}
bool
IsContentDocument
(
)
const
{
return
mIsContentDocument
;
}
void
SetIsContentDocument
(
bool
aIsContentDocument
)
{
mIsContentDocument
=
aIsContentDocument
;
}
already_AddRefed
<
Element
>
CreateElem
(
const
nsAString
&
aName
nsAtom
*
aPrefix
int32_t
aNamespaceID
const
nsAString
*
aIs
=
nullptr
)
;
nsISupports
*
GetSecurityInfo
(
)
{
return
mSecurityInfo
;
}
nsIChannel
*
GetFailedChannel
(
)
const
{
return
mFailedChannel
;
}
static
bool
CallerIsTrustedAboutCertError
(
JSContext
*
aCx
JSObject
*
aObject
)
;
void
GetFailedCertSecurityInfo
(
mozilla
:
:
dom
:
:
FailedCertSecurityInfo
&
aInfo
ErrorResult
&
aRv
)
;
void
SetFailedChannel
(
nsIChannel
*
aChannel
)
{
mFailedChannel
=
aChannel
;
}
int32_t
GetDefaultNamespaceID
(
)
const
{
return
mDefaultElementType
;
}
void
DeleteAllProperties
(
)
;
void
DeleteAllPropertiesFor
(
nsINode
*
aNode
)
;
nsPropertyTable
&
PropertyTable
(
)
{
return
mPropertyTable
;
}
void
SetPartID
(
uint32_t
aID
)
{
mPartID
=
aID
;
}
uint32_t
GetPartID
(
)
const
{
return
mPartID
;
}
void
Sanitize
(
)
;
typedef
bool
(
*
SubDocEnumFunc
)
(
Document
*
aDocument
void
*
aData
)
;
void
EnumerateSubDocuments
(
SubDocEnumFunc
aCallback
void
*
aData
)
;
typedef
bool
(
*
nsDocTestFunc
)
(
const
Document
*
aDocument
)
;
void
CollectDescendantDocuments
(
nsTArray
<
RefPtr
<
Document
>
>
&
aDescendants
nsDocTestFunc
aCallback
)
const
;
virtual
bool
CanSavePresentation
(
nsIRequest
*
aNewRequest
uint16_t
&
aBFCacheCombo
)
;
virtual
nsresult
Init
(
)
;
virtual
void
Destroy
(
)
;
virtual
void
RemovedFromDocShell
(
)
;
already_AddRefed
<
nsILayoutHistoryState
>
GetLayoutHistoryState
(
)
const
;
void
BlockOnload
(
)
;
void
UnblockOnload
(
bool
aFireSync
)
;
void
AsyncBlockOnload
(
)
;
void
BlockDOMContentLoaded
(
)
{
+
+
mBlockDOMContentLoaded
;
}
void
UnblockDOMContentLoaded
(
)
;
virtual
void
OnPageShow
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
=
false
)
;
void
OnPageHide
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
=
false
)
;
void
AddStyleRelevantLink
(
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
!
entry
"
Document
already
knows
about
this
Link
!
"
)
;
mStyledLinksCleared
=
false
;
#
endif
mStyledLinks
.
PutEntry
(
aLink
)
;
}
void
ForgetLink
(
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
entry
|
|
mStyledLinksCleared
"
Document
knows
nothing
about
this
Link
!
"
)
;
#
endif
mStyledLinks
.
RemoveEntry
(
aLink
)
;
}
void
RefreshLinkHrefs
(
)
;
void
ClearBoxObjectFor
(
nsIContent
*
aContent
)
;
already_AddRefed
<
BoxObject
>
GetBoxObjectFor
(
Element
*
aElement
ErrorResult
&
aRv
)
;
already_AddRefed
<
MediaQueryList
>
MatchMedia
(
const
nsAString
&
aMediaQueryList
CallerType
aCallerType
)
;
LinkedList
<
MediaQueryList
>
&
MediaQueryLists
(
)
{
return
mDOMMediaQueryLists
;
}
nsCompatibility
GetCompatibilityMode
(
)
const
{
return
mCompatMode
;
}
bool
HaveFiredDOMTitleChange
(
)
const
{
return
mHaveFiredTitleChange
;
}
Element
*
GetAnonymousElementByAttribute
(
nsIContent
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aAttrValue
)
const
;
void
MayDispatchMutationEvent
(
nsINode
*
aTarget
)
{
if
(
mSubtreeModifiedDepth
>
0
)
{
mSubtreeModifiedTargets
.
AppendObject
(
aTarget
)
;
}
}
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
bool
IsCookieAverse
(
)
const
{
if
(
!
GetInnerWindow
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
true
;
}
nsAutoCString
scheme
;
codebaseURI
-
>
GetScheme
(
scheme
)
;
return
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
ftp
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
file
"
)
;
}
bool
IsLoadedAsData
(
)
{
return
mLoadedAsData
;
}
bool
IsLoadedAsInteractiveData
(
)
{
return
mLoadedAsInteractiveData
;
}
bool
MayStartLayout
(
)
{
return
mMayStartLayout
;
}
virtual
void
SetMayStartLayout
(
bool
aMayStartLayout
)
;
already_AddRefed
<
nsIDocumentEncoder
>
GetCachedEncoder
(
)
;
void
SetCachedEncoder
(
already_AddRefed
<
nsIDocumentEncoder
>
aEncoder
)
;
nsresult
InitializeFrameLoader
(
nsFrameLoader
*
aLoader
)
;
nsresult
FinalizeFrameLoader
(
nsFrameLoader
*
aLoader
nsIRunnable
*
aFinalizer
)
;
void
TryCancelFrameLoaderInitialization
(
nsIDocShell
*
aShell
)
;
bool
IsRootDisplayDocument
(
)
const
{
return
!
mParentDocument
&
&
!
mDisplayDocument
;
}
bool
IsDocumentURISchemeChrome
(
)
const
{
return
mDocURISchemeIsChrome
;
}
bool
IsInChromeDocShell
(
)
const
{
const
Document
*
root
=
this
;
while
(
const
Document
*
displayDoc
=
root
-
>
GetDisplayDocument
(
)
)
{
root
=
displayDoc
;
}
return
root
-
>
mInChromeDocShell
;
}
bool
IsBeingUsedAsImage
(
)
const
{
return
mIsBeingUsedAsImage
;
}
void
SetIsBeingUsedAsImage
(
)
{
mIsBeingUsedAsImage
=
true
;
}
bool
IsSVGGlyphsDocument
(
)
const
{
return
mIsSVGGlyphsDocument
;
}
void
SetIsSVGGlyphsDocument
(
)
{
mIsSVGGlyphsDocument
=
true
;
}
bool
IsResourceDoc
(
)
const
{
return
IsBeingUsedAsImage
(
)
|
|
mHasDisplayDocument
;
}
Document
*
GetDisplayDocument
(
)
const
{
return
mDisplayDocument
;
}
void
SetDisplayDocument
(
Document
*
aDisplayDocument
)
{
MOZ_ASSERT
(
!
GetPresShell
(
)
&
&
!
GetContainer
(
)
&
&
!
GetWindow
(
)
"
Shouldn
'
t
set
mDisplayDocument
on
documents
that
already
"
"
have
a
presentation
or
a
docshell
or
a
window
"
)
;
MOZ_ASSERT
(
aDisplayDocument
"
Must
not
be
null
"
)
;
MOZ_ASSERT
(
aDisplayDocument
!
=
this
"
Should
be
different
document
"
)
;
MOZ_ASSERT
(
!
aDisplayDocument
-
>
GetDisplayDocument
(
)
"
Display
documents
should
not
nest
"
)
;
mDisplayDocument
=
aDisplayDocument
;
mHasDisplayDocument
=
!
!
aDisplayDocument
;
}
Document
*
RequestExternalResource
(
nsIURI
*
aURI
nsIURI
*
aReferrer
uint32_t
aReferrerPolicy
nsINode
*
aRequestingNode
ExternalResourceLoad
*
*
aPendingLoad
)
;
void
EnumerateExternalResources
(
SubDocEnumFunc
aCallback
void
*
aData
)
;
dom
:
:
ExternalResourceMap
&
ExternalResourceMap
(
)
{
return
mExternalResourceMap
;
}
bool
IsShowing
(
)
const
{
return
mIsShowing
;
}
bool
IsVisible
(
)
const
{
return
mVisible
;
}
bool
IsVisibleConsideringAncestors
(
)
const
;
void
SetSuppressedEventListener
(
EventListener
*
aListener
)
;
EventListener
*
GetSuppressedEventListener
(
)
{
return
mSuppressedEventListener
;
}
bool
IsActive
(
)
const
{
return
mDocumentContainer
&
&
!
mRemovedFromDocShell
;
}
bool
IsCurrentActiveDocument
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
return
inner
&
&
inner
-
>
IsCurrentInnerWindow
(
)
&
&
inner
-
>
GetDoc
(
)
=
=
this
;
}
bool
ShouldLoadImages
(
)
const
{
return
IsCurrentActiveDocument
(
)
|
|
IsBeingUsedAsImage
(
)
;
}
void
RegisterActivityObserver
(
nsISupports
*
aSupports
)
;
bool
UnregisterActivityObserver
(
nsISupports
*
aSupports
)
;
typedef
void
(
*
ActivityObserverEnumerator
)
(
nsISupports
*
void
*
)
;
void
EnumerateActivityObservers
(
ActivityObserverEnumerator
aEnumerator
void
*
aData
)
;
bool
HasAnimationController
(
)
{
return
!
!
mAnimationController
;
}
SMILAnimationController
*
GetAnimationController
(
)
;
PendingAnimationTracker
*
GetPendingAnimationTracker
(
)
{
return
mPendingAnimationTracker
;
}
PendingAnimationTracker
*
GetOrCreatePendingAnimationTracker
(
)
;
void
SuppressEventHandling
(
uint32_t
aIncrease
=
1
)
;
void
UnsuppressEventHandlingAndFireEvents
(
bool
aFireEvents
)
;
uint32_t
EventHandlingSuppressed
(
)
const
{
return
mEventsSuppressed
;
}
bool
IsEventHandlingEnabled
(
)
{
return
!
EventHandlingSuppressed
(
)
&
&
mScriptGlobalObject
;
}
void
DecreaseEventSuppression
(
)
{
MOZ_ASSERT
(
mEventsSuppressed
)
;
-
-
mEventsSuppressed
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
}
void
AddSuspendedChannelEventQueue
(
net
:
:
ChannelEventQueue
*
aQueue
)
;
void
SetHasDelayedRefreshEvent
(
)
{
mHasDelayedRefreshEvent
=
true
;
}
void
SetLoadEventFiring
(
bool
aFiring
)
{
mLoadEventFiring
=
aFiring
;
}
bool
SkipLoadEventAfterClose
(
)
{
bool
skip
=
mSkipLoadEventAfterClose
;
mSkipLoadEventAfterClose
=
false
;
return
skip
;
}
void
IncrementIgnoreDestructiveWritesCounter
(
)
{
+
+
mIgnoreDestructiveWritesCounter
;
}
void
DecrementIgnoreDestructiveWritesCounter
(
)
{
-
-
mIgnoreDestructiveWritesCounter
;
}
bool
IsDNSPrefetchAllowed
(
)
const
{
return
mAllowDNSPrefetch
;
}
bool
AllowXULXBL
(
)
{
return
mAllowXULXBL
=
=
eTriTrue
?
true
:
mAllowXULXBL
=
=
eTriFalse
?
false
:
InternalAllowXULXBL
(
)
;
}
void
ForceEnableXULXBL
(
)
{
mAllowXULXBL
=
eTriTrue
;
}
Document
*
GetTemplateContentsOwner
(
)
;
bool
IsStaticDocument
(
)
{
return
mIsStaticDocument
;
}
virtual
already_AddRefed
<
Document
>
CreateStaticClone
(
nsIDocShell
*
aCloneContainer
)
;
Document
*
GetOriginalDocument
(
)
{
MOZ_ASSERT
(
!
mOriginalDocument
|
|
!
mOriginalDocument
-
>
GetOriginalDocument
(
)
)
;
return
mOriginalDocument
;
}
void
UnlinkOriginalDocumentIfStatic
(
)
;
void
PreloadPictureOpened
(
)
{
mPreloadPictureDepth
+
+
;
}
void
PreloadPictureClosed
(
)
;
void
PreloadPictureImageSource
(
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
)
;
already_AddRefed
<
nsIURI
>
ResolvePreloadImage
(
nsIURI
*
aBaseURI
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
bool
*
aIsImgSet
)
;
void
MaybePreLoadImage
(
nsIURI
*
uri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
)
;
void
ForgetImagePreload
(
nsIURI
*
aURI
)
;
void
PreloadStyle
(
nsIURI
*
aURI
const
Encoding
*
aEncoding
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
const
nsAString
&
aIntegrity
)
;
RefPtr
<
StyleSheet
>
LoadChromeSheetSync
(
nsIURI
*
aURI
)
;
bool
IsDocumentRightToLeft
(
)
;
void
MaybePreconnect
(
nsIURI
*
uri
CORSMode
aCORSMode
)
;
enum
DocumentTheme
{
Doc_Theme_Uninitialized
Doc_Theme_None
Doc_Theme_Neutral
Doc_Theme_Dark
Doc_Theme_Bright
}
;
void
SetStateObject
(
nsIStructuredCloneContainer
*
scContainer
)
;
void
SetStateObjectFrom
(
Document
*
aDocument
)
{
SetStateObject
(
aDocument
-
>
mStateObjectContainer
)
;
}
DocumentTheme
GetDocumentLWTheme
(
)
;
DocumentTheme
ThreadSafeGetDocumentLWTheme
(
)
const
;
void
ResetDocumentLWTheme
(
)
{
mDocLWTheme
=
Doc_Theme_Uninitialized
;
}
enum
class
MediaDocumentKind
{
NotMedia
Video
Image
Plugin
}
;
virtual
enum
MediaDocumentKind
MediaDocumentKind
(
)
const
{
return
MediaDocumentKind
:
:
NotMedia
;
}
EventStates
GetDocumentState
(
)
const
{
return
mDocumentState
;
}
nsISupports
*
GetCurrentContentSink
(
)
;
void
SetAutoFocusElement
(
Element
*
aAutoFocusElement
)
;
void
TriggerAutoFocus
(
)
;
void
SetScrollToRef
(
nsIURI
*
aDocumentURI
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollToRef
(
)
;
void
ResetScrolledToRefAlready
(
)
{
mScrolledToRefAlready
=
false
;
}
void
SetChangeScrollPosWhenScrollingToRef
(
bool
aValue
)
{
mChangeScrollPosWhenScrollingToRef
=
aValue
;
}
using
DocumentOrShadowRoot
:
:
GetElementById
;
using
DocumentOrShadowRoot
:
:
GetElementsByClassName
;
using
DocumentOrShadowRoot
:
:
GetElementsByTagName
;
using
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
;
DocumentTimeline
*
Timeline
(
)
;
LinkedList
<
DocumentTimeline
>
&
Timelines
(
)
{
return
mTimelines
;
}
void
GetAnimations
(
nsTArray
<
RefPtr
<
Animation
>
>
&
aAnimations
)
;
SVGSVGElement
*
GetSVGRootElement
(
)
const
;
struct
FrameRequest
{
FrameRequest
(
FrameRequestCallback
&
aCallback
int32_t
aHandle
)
;
bool
operator
=
=
(
int32_t
aHandle
)
const
{
return
mHandle
=
=
aHandle
;
}
bool
operator
<
(
int32_t
aHandle
)
const
{
return
mHandle
<
aHandle
;
}
RefPtr
<
FrameRequestCallback
>
mCallback
;
int32_t
mHandle
;
}
;
nsresult
ScheduleFrameRequestCallback
(
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
;
void
CancelFrameRequestCallback
(
int32_t
aHandle
)
;
bool
IsCanceledFrameRequestCallback
(
int32_t
aHandle
)
const
;
void
TakeFrameRequestCallbacks
(
nsTArray
<
FrameRequest
>
&
aCallbacks
)
;
bool
ShouldThrottleFrameRequests
(
)
;
bool
InUnlinkOrDeletion
(
)
{
return
mInUnlinkOrDeletion
;
}
dom
:
:
ImageTracker
*
ImageTracker
(
)
;
void
AddPlugin
(
nsIObjectLoadingContent
*
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
)
;
mPlugins
.
PutEntry
(
aPlugin
)
;
}
void
RemovePlugin
(
nsIObjectLoadingContent
*
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
)
;
mPlugins
.
RemoveEntry
(
aPlugin
)
;
}
void
GetPlugins
(
nsTArray
<
nsIObjectLoadingContent
*
>
&
aPlugins
)
;
void
AddResponsiveContent
(
HTMLImageElement
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mResponsiveContent
.
PutEntry
(
aContent
)
;
}
void
RemoveResponsiveContent
(
HTMLImageElement
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mResponsiveContent
.
RemoveEntry
(
aContent
)
;
}
void
ScheduleSVGUseElementShadowTreeUpdate
(
SVGUseElement
&
)
;
void
UnscheduleSVGUseElementShadowTreeUpdate
(
SVGUseElement
&
aElement
)
{
mSVGUseElementsNeedingShadowTreeUpdate
.
RemoveEntry
(
&
aElement
)
;
}
bool
SVGUseElementNeedsShadowTreeUpdate
(
SVGUseElement
&
aElement
)
const
{
return
mSVGUseElementsNeedingShadowTreeUpdate
.
GetEntry
(
&
aElement
)
;
}
using
ShadowRootSet
=
nsTHashtable
<
nsPtrHashKey
<
ShadowRoot
>
>
;
void
AddComposedDocShadowRoot
(
ShadowRoot
&
aShadowRoot
)
{
mComposedShadowRoots
.
PutEntry
(
&
aShadowRoot
)
;
}
void
RemoveComposedDocShadowRoot
(
ShadowRoot
&
aShadowRoot
)
{
mComposedShadowRoots
.
RemoveEntry
(
&
aShadowRoot
)
;
}
bool
IsComposedDocShadowRoot
(
ShadowRoot
&
aShadowRoot
)
{
return
mComposedShadowRoots
.
Contains
(
&
aShadowRoot
)
;
}
const
ShadowRootSet
&
ComposedShadowRoots
(
)
const
{
return
mComposedShadowRoots
;
}
void
NotifyMediaFeatureValuesChanged
(
)
;
nsresult
GetStateObject
(
nsIVariant
*
*
aResult
)
;
nsDOMNavigationTiming
*
GetNavigationTiming
(
)
const
{
return
mTiming
;
}
void
SetNavigationTiming
(
nsDOMNavigationTiming
*
aTiming
)
;
nsContentList
*
ImageMapList
(
)
;
void
RegisterPendingLinkUpdate
(
Link
*
aLink
)
;
void
FlushPendingLinkUpdates
(
)
;
void
FlushPendingLinkUpdatesFromRunnable
(
)
;
#
define
DEPRECATED_OPERATION
(
_op
)
e
#
#
_op
enum
DeprecatedOperations
{
#
include
"
nsDeprecatedOperationList
.
h
"
eDeprecatedOperationCount
}
;
#
undef
DEPRECATED_OPERATION
bool
HasWarnedAbout
(
DeprecatedOperations
aOperation
)
const
;
void
WarnOnceAbout
(
DeprecatedOperations
aOperation
bool
asError
=
false
)
const
;
#
define
DOCUMENT_WARNING
(
_op
)
e
#
#
_op
enum
DocumentWarnings
{
#
include
"
nsDocumentWarningList
.
h
"
eDocumentWarningCount
}
;
#
undef
DOCUMENT_WARNING
bool
HasWarnedAbout
(
DocumentWarnings
aWarning
)
const
;
void
WarnOnceAbout
(
DocumentWarnings
aWarning
bool
asError
=
false
const
char16_t
*
*
aParams
=
nullptr
uint32_t
aParamsLength
=
0
)
const
;
void
PostVisibilityUpdateEvent
(
)
;
bool
IsSyntheticDocument
(
)
const
{
return
mIsSyntheticDocument
;
}
static
void
AddSizeOfNodeTree
(
nsINode
&
nsWindowSizes
&
)
;
virtual
void
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
virtual
void
DocAddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
void
ConstructUbiNode
(
void
*
storage
)
override
;
bool
MayHaveDOMMutationObservers
(
)
{
return
mMayHaveDOMMutationObservers
;
}
void
SetMayHaveDOMMutationObservers
(
)
{
mMayHaveDOMMutationObservers
=
true
;
}
bool
MayHaveAnimationObservers
(
)
{
return
mMayHaveAnimationObservers
;
}
void
SetMayHaveAnimationObservers
(
)
{
mMayHaveAnimationObservers
=
true
;
}
bool
IsInSyncOperation
(
)
{
return
mInSyncOperationCount
!
=
0
;
}
void
SetIsInSyncOperation
(
bool
aSync
)
{
if
(
aSync
)
{
+
+
mInSyncOperationCount
;
}
else
{
-
-
mInSyncOperationCount
;
}
}
bool
CreatingStaticClone
(
)
const
{
return
mCreatingStaticClone
;
}
already_AddRefed
<
Element
>
CreateHTMLElement
(
nsAtom
*
aTag
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetScopeObject
(
)
;
}
static
already_AddRefed
<
Document
>
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
;
DOMImplementation
*
GetImplementation
(
ErrorResult
&
rv
)
;
MOZ_MUST_USE
nsresult
GetURL
(
nsString
&
retval
)
const
;
MOZ_MUST_USE
nsresult
GetDocumentURI
(
nsString
&
retval
)
const
;
void
GetDocumentURIFromJS
(
nsString
&
aDocumentURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
void
GetCompatMode
(
nsString
&
retval
)
const
;
void
GetCharacterSet
(
nsAString
&
retval
)
const
;
Element
*
GetDocumentElement
(
)
const
{
return
GetRootElement
(
)
;
}
enum
ElementCallbackType
{
eConnected
eDisconnected
eAdopted
eAttributeChanged
eGetCustomInterface
}
;
Document
*
GetTopLevelContentDocument
(
)
;
const
Document
*
GetTopLevelContentDocument
(
)
const
;
already_AddRefed
<
nsIXULWindow
>
GetXULWindowIfToplevelChrome
(
)
const
;
already_AddRefed
<
Element
>
CreateElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
;
already_AddRefed
<
Element
>
CreateElementNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
;
already_AddRefed
<
Element
>
CreateXULElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
DocumentFragment
>
CreateDocumentFragment
(
)
const
;
already_AddRefed
<
nsTextNode
>
CreateTextNode
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
nsTextNode
>
CreateEmptyTextNode
(
)
const
;
already_AddRefed
<
Comment
>
CreateComment
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
ProcessingInstruction
>
CreateProcessingInstruction
(
const
nsAString
&
target
const
nsAString
&
data
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsINode
>
ImportNode
(
nsINode
&
aNode
bool
aDeep
ErrorResult
&
rv
)
const
;
nsINode
*
AdoptNode
(
nsINode
&
aNode
ErrorResult
&
rv
)
;
already_AddRefed
<
Event
>
CreateEvent
(
const
nsAString
&
aEventType
CallerType
aCallerType
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsRange
>
CreateRange
(
ErrorResult
&
rv
)
;
already_AddRefed
<
NodeIterator
>
CreateNodeIterator
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
;
already_AddRefed
<
TreeWalker
>
CreateTreeWalker
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
;
already_AddRefed
<
CDATASection
>
CreateCDATASection
(
const
nsAString
&
aData
ErrorResult
&
rv
)
;
already_AddRefed
<
Attr
>
CreateAttribute
(
const
nsAString
&
aName
ErrorResult
&
rv
)
;
already_AddRefed
<
Attr
>
CreateAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
ErrorResult
&
rv
)
;
void
GetInputEncoding
(
nsAString
&
aInputEncoding
)
const
;
already_AddRefed
<
Location
>
GetLocation
(
)
const
;
void
GetDomain
(
nsAString
&
aDomain
)
;
void
SetDomain
(
const
nsAString
&
aDomain
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetCookie
(
nsAString
&
aCookie
mozilla
:
:
ErrorResult
&
rv
)
;
void
SetCookie
(
const
nsAString
&
aCookie
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetReferrer
(
nsAString
&
aReferrer
)
const
;
void
GetLastModified
(
nsAString
&
aLastModified
)
const
;
void
GetReadyState
(
nsAString
&
aReadyState
)
const
;
void
GetTitle
(
nsAString
&
aTitle
)
;
void
SetTitle
(
const
nsAString
&
aTitle
ErrorResult
&
rv
)
;
void
GetDir
(
nsAString
&
aDirection
)
const
;
void
SetDir
(
const
nsAString
&
aDirection
)
;
nsIHTMLCollection
*
Images
(
)
;
nsIHTMLCollection
*
Embeds
(
)
;
nsIHTMLCollection
*
Plugins
(
)
{
return
Embeds
(
)
;
}
nsIHTMLCollection
*
Links
(
)
;
nsIHTMLCollection
*
Forms
(
)
;
nsIHTMLCollection
*
Scripts
(
)
;
already_AddRefed
<
nsContentList
>
GetElementsByName
(
const
nsAString
&
aName
)
{
return
GetFuncStringContentList
<
nsCachableElementsByNameNodeList
>
(
this
MatchNameAttribute
nullptr
UseExistingNameString
aName
)
;
}
Document
*
Open
(
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
const
nsAString
&
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
Open
(
const
nsAString
&
aURL
const
nsAString
&
aName
const
nsAString
&
aFeatures
bool
aReplace
mozilla
:
:
ErrorResult
&
rv
)
;
void
Close
(
mozilla
:
:
ErrorResult
&
rv
)
;
void
Write
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aText
mozilla
:
:
ErrorResult
&
rv
)
;
void
Writeln
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aText
mozilla
:
:
ErrorResult
&
rv
)
;
Nullable
<
WindowProxyHolder
>
GetDefaultView
(
)
const
;
Element
*
GetActiveElement
(
)
;
bool
HasFocus
(
ErrorResult
&
rv
)
const
;
nsIHTMLCollection
*
Applets
(
)
;
nsIHTMLCollection
*
Anchors
(
)
;
TimeStamp
LastFocusTime
(
)
const
;
void
SetLastFocusTime
(
const
TimeStamp
&
aFocusTime
)
;
bool
MozSyntheticDocument
(
)
const
{
return
IsSyntheticDocument
(
)
;
}
Element
*
GetCurrentScript
(
)
;
void
ReleaseCapture
(
)
const
;
void
MozSetImageElement
(
const
nsAString
&
aImageElementId
Element
*
aElement
)
;
nsIURI
*
GetDocumentURIObject
(
)
const
;
bool
FullscreenEnabled
(
CallerType
aCallerType
)
;
Element
*
FullscreenStackTop
(
)
;
bool
Fullscreen
(
)
{
return
!
!
GetFullscreenElement
(
)
;
}
already_AddRefed
<
Promise
>
ExitFullscreen
(
ErrorResult
&
)
;
void
ExitPointerLock
(
)
{
UnlockPointer
(
this
)
;
}
static
bool
IsUnprefixedFullscreenEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
DocumentSupportsL10n
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsWebAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsWebAnimationsEnabled
(
CallerType
aCallerType
)
;
static
bool
IsWebAnimationsGetAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
AreWebAnimationsImplicitKeyframesEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
AreWebAnimationsTimelinesEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsCallerChromeOrAddon
(
JSContext
*
aCx
JSObject
*
aObject
)
;
#
ifdef
MOZILLA_INTERNAL_API
bool
Hidden
(
)
const
{
return
mVisibilityState
!
=
VisibilityState
:
:
Visible
;
}
dom
:
:
VisibilityState
VisibilityState
(
)
const
{
return
mVisibilityState
;
}
#
endif
void
GetSelectedStyleSheetSet
(
nsAString
&
aSheetSet
)
;
void
SetSelectedStyleSheetSet
(
const
nsAString
&
aSheetSet
)
;
void
GetLastStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
=
mLastStyleSheetSet
;
}
const
nsString
&
GetCurrentStyleSheetSet
(
)
const
{
return
mLastStyleSheetSet
.
IsEmpty
(
)
?
mPreferredStyleSheetSet
:
mLastStyleSheetSet
;
}
void
SetPreferredStyleSheetSet
(
const
nsAString
&
)
;
void
GetPreferredStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
=
mPreferredStyleSheetSet
;
}
DOMStringList
*
StyleSheetSets
(
)
;
void
EnableStyleSheetsForSet
(
const
nsAString
&
aSheetSet
)
;
already_AddRefed
<
nsDOMCaretPosition
>
CaretPositionFromPoint
(
float
aX
float
aY
)
;
Element
*
GetScrollingElement
(
)
;
bool
IsScrollingElement
(
Element
*
aElement
)
;
nsINodeList
*
GetAnonymousNodes
(
Element
&
aElement
)
;
Element
*
GetAnonymousElementByAttribute
(
Element
&
aElement
const
nsAString
&
aAttrName
const
nsAString
&
aAttrValue
)
;
Element
*
GetBindingParent
(
nsINode
&
aNode
)
;
void
LoadBindingDocument
(
const
nsAString
&
aURI
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
;
XPathExpression
*
CreateExpression
(
const
nsAString
&
aExpression
XPathNSResolver
*
aResolver
ErrorResult
&
rv
)
;
nsINode
*
CreateNSResolver
(
nsINode
&
aNodeResolver
)
;
already_AddRefed
<
XPathResult
>
Evaluate
(
JSContext
*
aCx
const
nsAString
&
aExpression
nsINode
&
aContextNode
XPathNSResolver
*
aResolver
uint16_t
aType
JS
:
:
Handle
<
JSObject
*
>
aResult
ErrorResult
&
rv
)
;
already_AddRefed
<
Touch
>
CreateTouch
(
nsGlobalWindowInner
*
aView
EventTarget
*
aTarget
int32_t
aIdentifier
int32_t
aPageX
int32_t
aPageY
int32_t
aScreenX
int32_t
aScreenY
int32_t
aClientX
int32_t
aClientY
int32_t
aRadiusX
int32_t
aRadiusY
float
aRotationAngle
float
aForce
)
;
already_AddRefed
<
TouchList
>
CreateTouchList
(
)
;
already_AddRefed
<
TouchList
>
CreateTouchList
(
Touch
&
aTouch
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
;
already_AddRefed
<
TouchList
>
CreateTouchList
(
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
;
void
SetStyleSheetChangeEventsEnabled
(
bool
aValue
)
{
mStyleSheetChangeEventsEnabled
=
aValue
;
}
bool
StyleSheetChangeEventsEnabled
(
)
const
{
return
mStyleSheetChangeEventsEnabled
;
}
already_AddRefed
<
Promise
>
BlockParsing
(
Promise
&
aPromise
const
BlockParsingOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsIURI
>
GetMozDocumentURIIfNotForErrorPages
(
)
;
Promise
*
GetDocumentReadyForIdle
(
ErrorResult
&
aRv
)
;
nsIDOMXULCommandDispatcher
*
GetCommandDispatcher
(
)
;
bool
HasXULBroadcastManager
(
)
const
{
return
mXULBroadcastManager
;
}
;
void
InitializeXULBroadcastManager
(
)
;
XULBroadcastManager
*
GetXULBroadcastManager
(
)
const
{
return
mXULBroadcastManager
;
}
already_AddRefed
<
nsINode
>
GetPopupNode
(
)
;
void
SetPopupNode
(
nsINode
*
aNode
)
;
nsINode
*
GetPopupRangeParent
(
ErrorResult
&
aRv
)
;
int32_t
GetPopupRangeOffset
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsINode
>
GetTooltipNode
(
)
;
void
SetTooltipNode
(
nsINode
*
aNode
)
{
}
nsIHTMLCollection
*
Children
(
)
;
uint32_t
ChildElementCount
(
)
;
inline
nsHTMLDocument
*
AsHTMLDocument
(
)
;
inline
SVGDocument
*
AsSVGDocument
(
)
;
inline
XULDocument
*
AsXULDocument
(
)
;
void
AddBlockedNodeByClassifier
(
nsINode
*
node
)
{
if
(
!
node
)
{
return
;
}
nsWeakPtr
weakNode
=
do_GetWeakReference
(
node
)
;
if
(
weakNode
)
{
mBlockedNodesByClassifier
.
AppendElement
(
weakNode
)
;
}
}
gfxUserFontSet
*
GetUserFontSet
(
)
;
void
FlushUserFontSet
(
)
;
void
MarkUserFontSetDirty
(
)
;
FontFaceSet
*
GetFonts
(
)
{
return
mFontFaceSet
;
}
FontFaceSet
*
Fonts
(
)
;
bool
DidFireDOMContentLoaded
(
)
const
{
return
mDidFireDOMContentLoaded
;
}
bool
IsSynthesized
(
)
;
enum
class
UseCounterReportKind
{
eDefault
eIncludeExternalResources
}
;
void
ReportUseCounters
(
UseCounterReportKind
aKind
=
UseCounterReportKind
:
:
eDefault
)
;
void
SetDocumentUseCounter
(
UseCounter
aUseCounter
)
{
if
(
!
mUseCounters
[
aUseCounter
]
)
{
mUseCounters
[
aUseCounter
]
=
true
;
}
}
const
StyleUseCounters
*
GetStyleUseCounters
(
)
{
return
mStyleUseCounters
.
get
(
)
;
}
void
SetPageUseCounter
(
UseCounter
aUseCounter
)
;
void
SetDocumentAndPageUseCounter
(
UseCounter
aUseCounter
)
{
SetDocumentUseCounter
(
aUseCounter
)
;
SetPageUseCounter
(
aUseCounter
)
;
}
void
PropagateUseCounters
(
Document
*
aParentDocument
)
;
void
SetUserHasInteracted
(
)
;
bool
UserHasInteracted
(
)
{
return
mUserHasInteracted
;
}
void
ResetUserInteractionTimer
(
)
;
DocumentAutoplayPolicy
AutoplayPolicy
(
)
const
;
void
NotifyUserGestureActivation
(
)
;
void
ClearUserGestureActivation
(
)
;
bool
HasBeenUserGestureActivated
(
)
;
BrowsingContext
*
GetBrowsingContext
(
)
const
;
bool
IsExtensionPage
(
)
const
;
bool
HasScriptsBlockedBySandbox
(
)
;
bool
InlineScriptAllowedByCSP
(
)
;
void
ReportHasScrollLinkedEffect
(
)
;
bool
HasScrollLinkedEffect
(
)
const
{
return
mHasScrollLinkedEffect
;
}
#
ifdef
DEBUG
void
AssertDocGroupMatchesKey
(
)
const
;
#
endif
DocGroup
*
GetDocGroup
(
)
const
{
#
ifdef
DEBUG
AssertDocGroupMatchesKey
(
)
;
#
endif
return
mDocGroup
;
}
bool
StyleOrLayoutObservablyDependsOnParentDocumentLayout
(
)
const
{
return
GetParentDocument
(
)
&
&
GetDocGroup
(
)
=
=
GetParentDocument
(
)
-
>
GetDocGroup
(
)
;
}
void
AddIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mIntersectionObservers
.
Contains
(
aObserver
)
"
Intersection
observer
already
in
the
list
"
)
;
mIntersectionObservers
.
PutEntry
(
aObserver
)
;
}
void
RemoveIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
{
mIntersectionObservers
.
RemoveEntry
(
aObserver
)
;
}
bool
HasIntersectionObservers
(
)
const
{
return
!
mIntersectionObservers
.
IsEmpty
(
)
;
}
void
UpdateIntersectionObservations
(
)
;
void
ScheduleIntersectionObserverNotification
(
)
;
MOZ_CAN_RUN_SCRIPT
void
NotifyIntersectionObservers
(
)
;
nsresult
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
final
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
TaskCategory
aCategory
)
const
override
;
virtual
AbstractThread
*
AbstractMainThreadFor
(
TaskCategory
aCategory
)
override
;
void
NoteScriptTrackingStatus
(
const
nsACString
&
aURL
bool
isTracking
)
;
bool
IsScriptTracking
(
const
nsACString
&
aURL
)
const
;
FlashClassification
DocumentFlashClassification
(
)
;
void
AddResizeObserver
(
ResizeObserver
*
aResizeObserver
)
;
void
ScheduleResizeObserversNotification
(
)
const
;
public
:
DocumentL10n
*
GetL10n
(
)
;
void
OnL10nResourceContainerParsed
(
)
;
void
LocalizationLinkAdded
(
Element
*
aLinkElement
)
;
void
LocalizationLinkRemoved
(
Element
*
aLinkElement
)
;
void
TriggerInitialDocumentTranslation
(
)
;
virtual
void
InitialDocumentTranslationCompleted
(
)
;
protected
:
RefPtr
<
DocumentL10n
>
mDocumentL10n
;
virtual
bool
UseWidthDeviceWidthFallbackViewport
(
)
const
;
private
:
void
InitializeLocalization
(
nsTArray
<
nsString
>
&
aResourceIds
)
;
void
ParseWidthAndHeightInMetaViewport
(
const
nsAString
&
aWidthString
const
nsAString
&
aHeightString
bool
aIsAutoScale
)
;
Maybe
<
LayoutDeviceToScreenScale
>
ParseScaleInHeader
(
nsAtom
*
aHeaderField
)
;
void
ParseScalesInMetaViewport
(
)
;
FlashClassification
DocumentFlashClassificationInternal
(
)
;
nsTArray
<
nsString
>
mL10nResources
;
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCache
;
public
:
bool
IsThirdPartyForFlashClassifier
(
)
;
private
:
void
DoCacheAllKnownLangPrefs
(
)
;
void
RecomputeLanguageFromCharset
(
)
;
public
:
void
SetMayNeedFontPrefsUpdate
(
)
{
mMayNeedFontPrefsUpdate
=
true
;
}
bool
MayNeedFontPrefsUpdate
(
)
{
return
mMayNeedFontPrefsUpdate
;
}
already_AddRefed
<
nsAtom
>
GetContentLanguageAsAtomForStyle
(
)
const
;
already_AddRefed
<
nsAtom
>
GetLanguageForStyle
(
)
const
;
const
LangGroupFontPrefs
*
GetFontPrefsForLang
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
=
nullptr
)
const
;
void
ForceCacheLang
(
nsAtom
*
aLanguage
)
{
if
(
!
mLanguagesUsed
.
EnsureInserted
(
aLanguage
)
)
{
return
;
}
GetFontPrefsForLang
(
aLanguage
)
;
}
void
CacheAllKnownLangPrefs
(
)
{
if
(
!
mMayNeedFontPrefsUpdate
)
{
return
;
}
DoCacheAllKnownLangPrefs
(
)
;
}
nsINode
*
GetServoRestyleRoot
(
)
const
{
return
mServoRestyleRoot
;
}
uint32_t
GetServoRestyleRootDirtyBits
(
)
const
{
MOZ_ASSERT
(
mServoRestyleRoot
)
;
MOZ_ASSERT
(
mServoRestyleRootDirtyBits
)
;
return
mServoRestyleRootDirtyBits
;
}
void
ClearServoRestyleRoot
(
)
{
mServoRestyleRoot
=
nullptr
;
mServoRestyleRootDirtyBits
=
0
;
}
inline
void
SetServoRestyleRoot
(
nsINode
*
aRoot
uint32_t
aDirtyBits
)
;
inline
void
SetServoRestyleRootDirtyBits
(
uint32_t
aDirtyBits
)
;
bool
ShouldThrowOnDynamicMarkupInsertion
(
)
{
return
mThrowOnDynamicMarkupInsertionCounter
;
}
void
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
{
+
+
mThrowOnDynamicMarkupInsertionCounter
;
}
void
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
{
MOZ_ASSERT
(
mThrowOnDynamicMarkupInsertionCounter
)
;
-
-
mThrowOnDynamicMarkupInsertionCounter
;
}
bool
ShouldIgnoreOpens
(
)
const
{
return
mIgnoreOpensDuringUnloadCounter
;
}
void
IncrementIgnoreOpensDuringUnloadCounter
(
)
{
+
+
mIgnoreOpensDuringUnloadCounter
;
}
void
DecrementIgnoreOpensDuringUnloadCounter
(
)
{
MOZ_ASSERT
(
mIgnoreOpensDuringUnloadCounter
)
;
-
-
mIgnoreOpensDuringUnloadCounter
;
}
bool
AllowPaymentRequest
(
)
const
{
return
mAllowPaymentRequest
;
}
void
SetAllowPaymentRequest
(
bool
aAllowPaymentRequest
)
{
mAllowPaymentRequest
=
aAllowPaymentRequest
;
}
FeaturePolicy
*
Policy
(
)
const
;
bool
ModuleScriptsEnabled
(
)
;
nsIContent
*
GetContentInThisDocument
(
nsIFrame
*
aFrame
)
const
;
void
ReportShadowDOMUsage
(
)
;
void
MaybeNotifyAutoplayBlocked
(
)
;
void
SetDocTreeHadAudibleMedia
(
)
;
void
SetDocTreeHadPlayRevoked
(
)
;
dom
:
:
XPathEvaluator
*
XPathEvaluator
(
)
;
void
MaybeInitializeFinalizeFrameLoaders
(
)
;
void
SetDelayFrameLoaderInitialization
(
bool
aDelayFrameLoaderInitialization
)
{
mDelayFrameLoaderInitialization
=
aDelayFrameLoaderInitialization
;
}
void
SetPrototypeDocument
(
nsXULPrototypeDocument
*
aPrototype
)
;
bool
InRDMPane
(
)
const
{
return
mInRDMPane
;
}
void
SetInRDMPane
(
bool
aInRDMPane
)
{
mInRDMPane
=
aInRDMPane
;
}
protected
:
void
DoUpdateSVGUseElementShadowTrees
(
)
;
already_AddRefed
<
nsIPrincipal
>
MaybeDowngradePrincipal
(
nsIPrincipal
*
aPrincipal
)
;
void
EnsureOnloadBlocker
(
)
;
void
SendToConsole
(
nsCOMArray
<
nsISecurityConsoleMessage
>
&
aMessages
)
;
bool
IsAboutPage
(
)
const
;
bool
ContainsEMEContent
(
)
;
bool
ContainsMSEContent
(
)
;
Element
*
GetTitleElement
(
)
;
void
RecordNavigationTiming
(
ReadyState
aReadyState
)
;
void
UpdateVisibilityState
(
)
;
dom
:
:
VisibilityState
ComputeVisibilityState
(
)
const
;
void
MaybeActiveMediaComponents
(
)
;
bool
ApplyFullscreen
(
UniquePtr
<
FullscreenRequest
>
)
;
bool
GetUseCounter
(
UseCounter
aUseCounter
)
{
return
mUseCounters
[
aUseCounter
]
;
}
void
SetChildDocumentUseCounter
(
UseCounter
aUseCounter
)
{
if
(
!
mChildDocumentUseCounters
[
aUseCounter
]
)
{
mChildDocumentUseCounters
[
aUseCounter
]
=
true
;
}
}
bool
GetChildDocumentUseCounter
(
UseCounter
aUseCounter
)
{
return
mChildDocumentUseCounters
[
aUseCounter
]
;
}
void
RemoveDocStyleSheetsFromStyleSets
(
)
;
void
RemoveStyleSheetsFromStyleSets
(
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
StyleOrigin
)
;
void
ResetStylesheetsToURI
(
nsIURI
*
aURI
)
;
void
FillStyleSet
(
)
;
void
FillStyleSetUserAndUASheets
(
)
;
void
FillStyleSetDocumentSheets
(
)
;
void
CompatibilityModeChanged
(
)
;
bool
NeedsQuirksSheet
(
)
const
{
return
mCompatMode
=
=
eCompatibility_NavQuirks
&
&
!
IsSVGDocument
(
)
;
}
void
AddContentEditableStyleSheetsToStyleSet
(
bool
aDesignMode
)
;
void
RemoveContentEditableStyleSheets
(
)
;
void
AddStyleSheetToStyleSets
(
StyleSheet
*
aSheet
)
;
void
RemoveStyleSheetFromStyleSets
(
StyleSheet
*
aSheet
)
;
void
NotifyStyleSheetAdded
(
StyleSheet
*
aSheet
bool
aDocumentSheet
)
;
void
NotifyStyleSheetRemoved
(
StyleSheet
*
aSheet
bool
aDocumentSheet
)
;
void
NotifyStyleSheetApplicableStateChanged
(
)
;
void
EnableStyleSheetsForSetInternal
(
const
nsAString
&
aSheetSet
bool
aUpdateCSSLoader
)
;
already_AddRefed
<
nsIURI
>
GetDomainURI
(
)
;
already_AddRefed
<
nsIURI
>
CreateInheritingURIForHost
(
const
nsACString
&
aHostString
)
;
already_AddRefed
<
nsIURI
>
RegistrableDomainSuffixOfInternal
(
const
nsAString
&
aHostSuffixString
nsIURI
*
aOrigHost
)
;
void
WriteCommon
(
const
nsAString
&
aText
bool
aNewlineTerminate
mozilla
:
:
ErrorResult
&
aRv
)
;
void
WriteCommon
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aText
bool
aNewlineTerminate
mozilla
:
:
ErrorResult
&
rv
)
;
void
*
GenerateParserKey
(
void
)
;
private
:
void
RecordContentBlockingLog
(
const
nsACString
&
aOrigin
uint32_t
aType
bool
aBlocked
const
Maybe
<
AntiTrackingCommon
:
:
StorageAccessGrantedReason
>
&
aReason
=
Nothing
(
)
const
nsTArray
<
nsCString
>
&
aTrackingFullHashes
=
nsTArray
<
nsCString
>
(
)
)
{
mContentBlockingLog
.
RecordLog
(
aOrigin
aType
aBlocked
aReason
aTrackingFullHashes
)
;
}
mutable
std
:
:
bitset
<
eDeprecatedOperationCount
>
mDeprecationWarnedAbout
;
mutable
std
:
:
bitset
<
eDocumentWarningCount
>
mDocWarningWarnedAbout
;
UniquePtr
<
SelectorCache
>
mSelectorCache
;
UniquePtr
<
ServoStyleSet
>
mStyleSet
;
protected
:
friend
class
nsDocumentOnStack
;
void
IncreaseStackRefCnt
(
)
{
+
+
mStackRefCnt
;
}
void
DecreaseStackRefCnt
(
)
{
if
(
-
-
mStackRefCnt
=
=
0
&
&
mNeedsReleaseAfterStackRefCntRelease
)
{
mNeedsReleaseAfterStackRefCntRelease
=
false
;
NS_RELEASE_THIS
(
)
;
}
}
nsPIDOMWindowOuter
*
GetWindowInternal
(
)
const
;
nsIScriptGlobalObject
*
GetScriptHandlingObjectInternal
(
)
const
;
bool
InternalAllowXULXBL
(
)
;
void
WillDispatchMutationEvent
(
nsINode
*
aTarget
)
;
void
MutationEventDispatched
(
nsINode
*
aTarget
)
;
friend
class
mozAutoSubtreeModified
;
virtual
Element
*
GetNameSpaceElement
(
)
override
{
return
GetRootElement
(
)
;
}
void
SetContentTypeInternal
(
const
nsACString
&
aType
)
;
nsCString
GetContentTypeInternal
(
)
const
{
return
mContentType
;
}
void
UpdateFrameRequestCallbackSchedulingState
(
PresShell
*
aOldPresShell
=
nullptr
)
;
bool
IsPotentiallyScrollable
(
HTMLBodyElement
*
aBody
)
;
Document
*
GetSameTypeParentDocument
(
)
;
void
MaybeAllowStorageForOpenerAfterUserInteraction
(
)
;
void
MaybeStoreUserInteractionAsPermission
(
)
;
static
bool
MatchNameAttribute
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
;
static
void
*
UseExistingNameString
(
nsINode
*
aRootNode
const
nsString
*
aName
)
;
void
MaybeResolveReadyForIdle
(
)
;
already_AddRefed
<
nsIChannel
>
CreateDummyChannelForCookies
(
nsIURI
*
aCodebaseURI
)
;
nsCString
mReferrer
;
nsString
mLastModified
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mOriginalURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocURI
;
nsCOMPtr
<
nsIURI
>
mDocumentBaseURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocBaseURI
;
nsCString
mBaseDomain
;
RefPtr
<
URLExtraData
>
mCachedURLData
;
nsWeakPtr
mDocumentLoadGroup
;
bool
mReferrerPolicySet
;
ReferrerPolicyEnum
mReferrerPolicy
;
bool
mBlockAllMixedContent
;
bool
mBlockAllMixedContentPreloads
;
bool
mUpgradeInsecureRequests
;
bool
mUpgradeInsecurePreloads
;
WeakPtr
<
nsDocShell
>
mDocumentContainer
;
NotNull
<
const
Encoding
*
>
mCharacterSet
;
int32_t
mCharacterSetSource
;
Document
*
mParentDocument
;
Element
*
mCachedRootElement
;
nsNodeInfoManager
*
mNodeInfoManager
;
RefPtr
<
css
:
:
Loader
>
mCSSLoader
;
RefPtr
<
css
:
:
ImageLoader
>
mStyleImageLoader
;
RefPtr
<
nsHTMLStyleSheet
>
mAttrStyleSheet
;
RefPtr
<
nsHTMLCSSStyleSheet
>
mStyleAttrStyleSheet
;
RefPtr
<
dom
:
:
ImageTracker
>
mImageTracker
;
ShadowRootSet
mComposedShadowRoots
;
using
SVGUseElementSet
=
nsTHashtable
<
nsPtrHashKey
<
SVGUseElement
>
>
;
SVGUseElementSet
mSVGUseElementsNeedingShadowTreeUpdate
;
nsAutoPtr
<
nsTHashtable
<
nsPtrHashKey
<
nsISupports
>
>
>
mActivityObservers
;
nsTHashtable
<
nsPtrHashKey
<
Link
>
>
mStyledLinks
;
#
ifdef
DEBUG
bool
mStyledLinksCleared
;
#
endif
static
const
size_t
kSegmentSize
=
128
;
typedef
SegmentedVector
<
nsCOMPtr
<
Link
>
kSegmentSize
InfallibleAllocPolicy
>
LinksToUpdateList
;
LinksToUpdateList
mLinksToUpdate
;
RefPtr
<
SMILAnimationController
>
mAnimationController
;
nsPropertyTable
mPropertyTable
;
nsCOMPtr
<
nsIHTMLCollection
>
mChildrenCollection
;
RefPtr
<
nsContentList
>
mImages
;
RefPtr
<
nsContentList
>
mEmbeds
;
RefPtr
<
nsContentList
>
mLinks
;
RefPtr
<
nsContentList
>
mForms
;
RefPtr
<
nsContentList
>
mScripts
;
nsCOMPtr
<
nsIHTMLCollection
>
mApplets
;
RefPtr
<
nsContentList
>
mAnchors
;
RefPtr
<
FontFaceSet
>
mFontFaceSet
;
TimeStamp
mLastFocusTime
;
EventStates
mDocumentState
;
RefPtr
<
Promise
>
mReadyForIdle
;
RefPtr
<
FeaturePolicy
>
mFeaturePolicy
;
UniquePtr
<
ResizeObserverController
>
mResizeObserverController
;
bool
mBidiEnabled
:
1
;
bool
mMayNeedFontPrefsUpdate
:
1
;
bool
mMathMLEnabled
:
1
;
bool
mIsInitialDocumentInWindow
:
1
;
bool
mIgnoreDocGroupMismatches
:
1
;
bool
mLoadedAsData
:
1
;
bool
mLoadedAsInteractiveData
:
1
;
bool
mMayStartLayout
:
1
;
bool
mHaveFiredTitleChange
:
1
;
bool
mIsShowing
:
1
;
bool
mVisible
:
1
;
bool
mRemovedFromDocShell
:
1
;
bool
mAllowDNSPrefetch
:
1
;
bool
mIsStaticDocument
:
1
;
bool
mCreatingStaticClone
:
1
;
bool
mInUnlinkOrDeletion
:
1
;
bool
mHasHadScriptHandlingObject
:
1
;
bool
mIsBeingUsedAsImage
:
1
;
bool
mDocURISchemeIsChrome
:
1
;
bool
mInChromeDocShell
:
1
;
bool
mIsSyntheticDocument
:
1
;
bool
mHasLinksToUpdateRunnable
:
1
;
bool
mFlushingPendingLinkUpdates
:
1
;
bool
mMayHaveDOMMutationObservers
:
1
;
bool
mMayHaveAnimationObservers
:
1
;
bool
mHasMixedActiveContentLoaded
:
1
;
bool
mHasMixedActiveContentBlocked
:
1
;
bool
mHasMixedDisplayContentLoaded
:
1
;
bool
mHasMixedDisplayContentBlocked
:
1
;
bool
mHasMixedContentObjectSubrequest
:
1
;
bool
mHasCSP
:
1
;
bool
mHasUnsafeEvalCSP
:
1
;
bool
mHasUnsafeInlineCSP
:
1
;
bool
mBFCacheDisallowed
:
1
;
bool
mHasHadDefaultView
:
1
;
bool
mStyleSheetChangeEventsEnabled
:
1
;
bool
mIsSrcdocDocument
:
1
;
bool
mHasDisplayDocument
:
1
;
bool
mFontFaceSetDirty
:
1
;
bool
mDidFireDOMContentLoaded
:
1
;
bool
mHasScrollLinkedEffect
:
1
;
bool
mFrameRequestCallbacksScheduled
:
1
;
bool
mIsTopLevelContentDocument
:
1
;
bool
mIsContentDocument
:
1
;
bool
mDidCallBeginLoad
:
1
;
bool
mAllowPaymentRequest
:
1
;
bool
mEncodingMenuDisabled
:
1
;
bool
mIsSVGGlyphsDocument
:
1
;
bool
mInDestructor
:
1
;
bool
mIsGoingAway
:
1
;
bool
mInXBLUpdate
:
1
;
bool
mNeedsReleaseAfterStackRefCntRelease
:
1
;
bool
mStyleSetFilled
:
1
;
bool
mQuirkSheetAdded
:
1
;
bool
mContentEditableSheetAdded
:
1
;
bool
mDesignModeSheetAdded
:
1
;
bool
mSSApplicableStateNotificationPending
:
1
;
bool
mMayHaveTitleElement
:
1
;
bool
mDOMLoadingSet
:
1
;
bool
mDOMInteractiveSet
:
1
;
bool
mDOMCompleteSet
:
1
;
bool
mAutoFocusFired
:
1
;
bool
mScrolledToRefAlready
:
1
;
bool
mChangeScrollPosWhenScrollingToRef
:
1
;
bool
mHasWarnedAboutBoxObjects
:
1
;
bool
mDelayFrameLoaderInitialization
:
1
;
bool
mSynchronousDOMContentLoaded
:
1
;
bool
mMaybeServiceWorkerControlled
:
1
;
bool
mAllowZoom
:
1
;
bool
mValidScaleFloat
:
1
;
bool
mValidMinScale
:
1
;
bool
mValidMaxScale
:
1
;
bool
mWidthStrEmpty
:
1
;
bool
mParserAborted
:
1
;
bool
mReportedUseCounters
:
1
;
bool
mHasReportedShadowDOMUsage
:
1
;
bool
mDocTreeHadAudibleMedia
:
1
;
bool
mDocTreeHadPlayRevoked
:
1
;
bool
mHasDelayedRefreshEvent
:
1
;
bool
mLoadEventFiring
:
1
;
bool
mSkipLoadEventAfterClose
:
1
;
bool
mDisableCookieAccess
:
1
;
bool
mDisableDocWrite
:
1
;
bool
mTooDeepWriteRecursion
:
1
;
uint8_t
mPendingFullscreenRequests
;
uint8_t
mXMLDeclarationBits
;
uint32_t
mOnloadBlockCount
;
uint32_t
mAsyncOnloadBlockCount
;
uint32_t
mWriteLevel
;
nsCompatibility
mCompatMode
;
ReadyState
mReadyState
;
bool
mAncestorIsLoading
;
dom
:
:
VisibilityState
mVisibilityState
;
enum
Type
{
eUnknown
eHTML
eXHTML
eGenericXML
eSVG
eXUL
}
;
Type
mType
;
uint8_t
mDefaultElementType
;
enum
Tri
{
eTriUnset
=
0
eTriFalse
eTriTrue
}
;
Tri
mAllowXULXBL
;
nsCOMPtr
<
nsIScriptGlobalObject
>
mScriptGlobalObject
;
RefPtr
<
Document
>
mOriginalDocument
;
uint32_t
mBidiOptions
;
uint32_t
mSandboxFlags
;
nsCString
mContentLanguage
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
mCSP
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
mPreloadCSP
;
private
:
nsCString
mContentType
;
protected
:
nsCOMPtr
<
nsISupports
>
mSecurityInfo
;
nsCOMPtr
<
nsIChannel
>
mFailedChannel
;
uint32_t
mPartID
;
uint32_t
mMarkedCCGeneration
;
PresShell
*
mPresShell
;
nsCOMArray
<
nsINode
>
mSubtreeModifiedTargets
;
uint32_t
mSubtreeModifiedDepth
;
nsRefPtrHashtable
<
nsURIHashKey
imgIRequest
>
mPreloadingImages
;
nsDataHashtable
<
nsURIHashKey
bool
>
mPreloadedPreconnects
;
uint32_t
mPreloadPictureDepth
;
nsString
mPreloadPictureFoundSource
;
RefPtr
<
Document
>
mDisplayDocument
;
uint32_t
mEventsSuppressed
;
nsTArray
<
RefPtr
<
net
:
:
ChannelEventQueue
>
>
mSuspendedQueues
;
RefPtr
<
EventListener
>
mSuppressedEventListener
;
uint32_t
mIgnoreDestructiveWritesCounter
;
int32_t
mFrameRequestCallbackCounter
;
uint32_t
mStaticCloneCount
;
WeakPtr
<
Document
>
mLatestStaticClone
;
nsTArray
<
nsWeakPtr
>
mBlockedNodesByClassifier
;
nsPIDOMWindowInner
*
mWindow
;
nsCOMPtr
<
nsIDocumentEncoder
>
mCachedEncoder
;
nsTArray
<
FrameRequest
>
mFrameRequestCallbacks
;
HashSet
<
int32_t
>
mCanceledFrameRequestCallbacks
;
nsIBFCacheEntry
*
mBFCacheEntry
;
nsString
mBaseTarget
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
mStateObjectContainer
;
nsCOMPtr
<
nsIVariant
>
mStateObjectCached
;
uint32_t
mInSyncOperationCount
;
UniquePtr
<
dom
:
:
XPathEvaluator
>
mXPathEvaluator
;
nsTArray
<
RefPtr
<
AnonymousContent
>
>
mAnonymousContents
;
uint32_t
mBlockDOMContentLoaded
;
LinkedList
<
MediaQueryList
>
mDOMMediaQueryLists
;
nsTObserverArray
<
nsIDocumentObserver
*
>
mObservers
;
std
:
:
bitset
<
eUseCounter_Count
>
mUseCounters
;
std
:
:
bitset
<
eUseCounter_Count
>
mChildDocumentUseCounters
;
std
:
:
bitset
<
eUseCounter_Count
>
mNotifiedPageForUseCounter
;
UniquePtr
<
StyleUseCounters
>
mStyleUseCounters
;
bool
mUserHasInteracted
;
bool
mHasUserInteractionTimerScheduled
;
TimeStamp
mPageUnloadingEventTimeStamp
;
RefPtr
<
DocGroup
>
mDocGroup
;
nsTHashtable
<
nsCStringHashKey
>
mTrackingScripts
;
ContentBlockingLog
mContentBlockingLog
;
nsTArray
<
nsCOMPtr
<
nsIPrincipal
>
>
mAncestorPrincipals
;
nsTArray
<
uint64_t
>
mAncestorOuterWindowIDs
;
nsCOMPtr
<
nsIParser
>
mParser
;
RefPtr
<
nsXULPrototypeDocument
>
mPrototypeDocument
;
nsrefcnt
mStackRefCnt
;
nsWeakPtr
mWeakSink
;
uint32_t
mUpdateNestLevel
;
enum
ViewportType
:
uint8_t
{
DisplayWidthHeight
Specified
Unknown
Empty
}
;
ViewportType
mViewportType
;
PLDHashTable
*
mSubDocuments
;
DocHeaderData
*
mHeaderData
;
FlashClassification
mFlashClassification
;
Maybe
<
bool
>
mIsThirdPartyForFlashClassifier
;
nsRevocableEventPtr
<
nsRunnableMethod
<
Document
void
false
>
>
mPendingTitleChangeEvent
;
RefPtr
<
nsDOMNavigationTiming
>
mTiming
;
TimeStamp
mLoadingTimeStamp
;
nsWeakPtr
mAutoFocusElement
;
nsCString
mScrollToRef
;
nscoord
mScrollAnchorAdjustmentLength
;
int32_t
mScrollAnchorAdjustmentCount
;
nsWeakPtr
mScopeObject
;
nsTHashtable
<
nsPtrHashKey
<
DOMIntersectionObserver
>
>
mIntersectionObservers
;
nsTArray
<
nsWeakPtr
>
mFullscreenStack
;
nsWeakPtr
mFullscreenRoot
;
RefPtr
<
DOMImplementation
>
mDOMImplementation
;
RefPtr
<
nsContentList
>
mImageMaps
;
nsTHashtable
<
nsPtrHashKey
<
HTMLImageElement
>
>
mResponsiveContent
;
nsTHashtable
<
nsPtrHashKey
<
nsIObjectLoadingContent
>
>
mPlugins
;
RefPtr
<
DocumentTimeline
>
mDocumentTimeline
;
LinkedList
<
DocumentTimeline
>
mTimelines
;
RefPtr
<
dom
:
:
ScriptLoader
>
mScriptLoader
;
nsRefPtrHashtable
<
nsPtrHashKey
<
nsIContent
>
BoxObject
>
*
mBoxObjectTable
;
RefPtr
<
PendingAnimationTracker
>
mPendingAnimationTracker
;
RefPtr
<
Document
>
mTemplateContentsOwner
;
dom
:
:
ExternalResourceMap
mExternalResourceMap
;
RefPtr
<
Promise
>
mOrientationPendingPromise
;
uint16_t
mCurrentOrientationAngle
;
OrientationType
mCurrentOrientationType
;
nsTArray
<
RefPtr
<
nsFrameLoader
>
>
mInitializableFrameLoaders
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mFrameLoaderFinalizers
;
RefPtr
<
nsRunnableMethod
<
Document
>
>
mFrameLoaderRunner
;
nsCOMPtr
<
nsILayoutHistoryState
>
mLayoutHistoryState
;
LayoutDeviceToScreenScale
mScaleMinFloat
;
LayoutDeviceToScreenScale
mScaleMaxFloat
;
LayoutDeviceToScreenScale
mScaleFloat
;
CSSToLayoutDeviceScale
mPixelRatio
;
CSSCoord
mMinWidth
;
CSSCoord
mMaxWidth
;
CSSCoord
mMinHeight
;
CSSCoord
mMaxHeight
;
RefPtr
<
EventListenerManager
>
mListenerManager
;
nsCOMPtr
<
nsIRunnable
>
mMaybeEndOutermostXBLUpdateRunner
;
nsCOMPtr
<
nsIRequest
>
mOnloadBlocker
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mAdditionalSheets
[
AdditionalSheetTypeCount
]
;
nsString
mLastStyleSheetSet
;
nsString
mPreferredStyleSheetSet
;
RefPtr
<
DOMStyleSheetSetList
>
mStyleSheetSetList
;
nsTHashtable
<
nsPtrHashKey
<
SVGElement
>
>
mLazySVGPresElements
;
LangGroupFontPrefs
mLangGroupFontPrefs
;
nsTHashtable
<
nsRefPtrHashKey
<
nsAtom
>
>
mLanguagesUsed
;
RefPtr
<
nsAtom
>
mLanguageFromCharset
;
nsCOMPtr
<
nsINode
>
mServoRestyleRoot
;
uint32_t
mServoRestyleRootDirtyBits
;
uint32_t
mThrowOnDynamicMarkupInsertionCounter
;
uint32_t
mIgnoreOpensDuringUnloadCounter
;
nsCOMPtr
<
nsIDOMXULCommandDispatcher
>
mCommandDispatcher
;
RefPtr
<
XULBroadcastManager
>
mXULBroadcastManager
;
RefPtr
<
XULPersist
>
mXULPersist
;
DocumentTheme
mDocLWTheme
;
float
mSavedResolution
;
bool
mPendingInitialTranslation
;
nsCOMPtr
<
nsICookieSettings
>
mCookieSettings
;
int32_t
mGeneration
;
int32_t
mCachedTabSizeGeneration
;
nsTabSizes
mCachedTabSizes
;
bool
mInRDMPane
;
nsCOMPtr
<
nsIPrincipal
>
mIntrinsicStoragePrincipal
;
public
:
js
:
:
ExpandoAndGeneration
mExpandoAndGeneration
;
bool
HasPendingInitialTranslation
(
)
{
return
mPendingInitialTranslation
;
}
void
TraceProtos
(
JSTracer
*
aTrc
)
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Document
NS_IDOCUMENT_IID
)
class
MOZ_STACK_CLASS
mozAutoSubtreeModified
{
public
:
mozAutoSubtreeModified
(
Document
*
aSubtreeOwner
nsINode
*
aTarget
)
{
UpdateTarget
(
aSubtreeOwner
aTarget
)
;
}
~
mozAutoSubtreeModified
(
)
{
UpdateTarget
(
nullptr
nullptr
)
;
}
void
UpdateTarget
(
Document
*
aSubtreeOwner
nsINode
*
aTarget
)
{
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
MutationEventDispatched
(
mTarget
)
;
}
mTarget
=
aTarget
;
mSubtreeOwner
=
aSubtreeOwner
;
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
WillDispatchMutationEvent
(
mTarget
)
;
}
}
private
:
nsCOMPtr
<
nsINode
>
mTarget
;
RefPtr
<
Document
>
mSubtreeOwner
;
}
;
class
MOZ_STACK_CLASS
nsAutoSyncOperation
{
public
:
explicit
nsAutoSyncOperation
(
Document
*
aDocument
)
;
~
nsAutoSyncOperation
(
)
;
private
:
nsTArray
<
RefPtr
<
Document
>
>
mDocuments
;
uint32_t
mMicroTaskLevel
;
}
;
class
MOZ_RAII
AutoSetThrowOnDynamicMarkupInsertionCounter
final
{
public
:
explicit
AutoSetThrowOnDynamicMarkupInsertionCounter
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
mDocument
-
>
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
~
AutoSetThrowOnDynamicMarkupInsertionCounter
(
)
{
mDocument
-
>
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
private
:
Document
*
mDocument
;
}
;
class
MOZ_RAII
IgnoreOpensDuringUnload
final
{
public
:
explicit
IgnoreOpensDuringUnload
(
Document
*
aDoc
)
:
mDoc
(
aDoc
)
{
mDoc
-
>
IncrementIgnoreOpensDuringUnloadCounter
(
)
;
}
~
IgnoreOpensDuringUnload
(
)
{
mDoc
-
>
DecrementIgnoreOpensDuringUnloadCounter
(
)
;
}
private
:
Document
*
mDoc
;
}
;
}
}
nsresult
NS_NewHTMLDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
)
;
nsresult
NS_NewXMLDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
bool
aIsPlainDocument
=
false
)
;
nsresult
NS_NewSVGDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
nsresult
NS_NewImageDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
nsresult
NS_NewVideoDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
enum
DocumentFlavor
{
DocumentFlavorLegacyGuess
DocumentFlavorHTML
DocumentFlavorSVG
DocumentFlavorPlain
}
;
nsresult
NS_NewDOMDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
mozilla
:
:
dom
:
:
DocumentType
*
aDoctype
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
bool
aLoadedAsData
nsIGlobalObject
*
aEventObject
DocumentFlavor
aFlavor
)
;
nsresult
NS_NewXBLDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
)
;
nsresult
NS_NewPluginDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
inline
mozilla
:
:
dom
:
:
Document
*
nsINode
:
:
GetOwnerDocument
(
)
const
{
mozilla
:
:
dom
:
:
Document
*
ownerDoc
=
OwnerDoc
(
)
;
return
ownerDoc
!
=
this
?
ownerDoc
:
nullptr
;
}
inline
nsINode
*
nsINode
:
:
OwnerDocAsNode
(
)
const
{
return
OwnerDoc
(
)
;
}
inline
bool
ShouldUseNACScope
(
const
nsINode
*
aNode
)
{
return
aNode
-
>
IsInNativeAnonymousSubtree
(
)
;
}
inline
bool
ShouldUseUAWidgetScope
(
const
nsINode
*
aNode
)
{
return
aNode
-
>
HasBeenInUAWidget
(
)
;
}
inline
mozilla
:
:
dom
:
:
ParentObject
nsINode
:
:
GetParentObject
(
)
const
{
mozilla
:
:
dom
:
:
ParentObject
p
(
OwnerDoc
(
)
)
;
if
(
ShouldUseNACScope
(
this
)
)
{
p
.
mReflectionScope
=
mozilla
:
:
dom
:
:
ReflectionScope
:
:
NAC
;
}
else
if
(
ShouldUseUAWidgetScope
(
this
)
)
{
p
.
mReflectionScope
=
mozilla
:
:
dom
:
:
ReflectionScope
:
:
UAWidget
;
}
return
p
;
}
inline
mozilla
:
:
dom
:
:
Document
*
nsINode
:
:
AsDocument
(
)
{
MOZ_ASSERT
(
IsDocument
(
)
)
;
return
static_cast
<
mozilla
:
:
dom
:
:
Document
*
>
(
this
)
;
}
inline
const
mozilla
:
:
dom
:
:
Document
*
nsINode
:
:
AsDocument
(
)
const
{
MOZ_ASSERT
(
IsDocument
(
)
)
;
return
static_cast
<
const
mozilla
:
:
dom
:
:
Document
*
>
(
this
)
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
dom
:
:
Document
*
aDoc
)
{
return
static_cast
<
nsINode
*
>
(
aDoc
)
;
}
#
endif
