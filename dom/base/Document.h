#
ifndef
mozilla_dom_Document_h___
#
define
mozilla_dom_Document_h___
#
include
<
bitset
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
new
>
#
include
<
utility
>
#
include
"
ErrorList
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
Units
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
friend
/
DOMProxy
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
BitSet
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
CallState
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
FunctionRef
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
PointerLockManager
.
h
"
#
include
"
mozilla
/
PreloadService
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
TaskCategory
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
css
/
StylePreloadKind
.
h
"
#
include
"
mozilla
/
dom
/
DispatcherTrait
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
ViewportMetaData
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIApplicationCacheContainer
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsIRadioGroupContainer
.
h
"
#
include
"
nsIReferrerInfo
.
h
"
#
include
"
nsIRequestObserver
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPropertyTable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsTLiteralString
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
nscore
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
else
namespace
mozilla
{
namespace
dom
{
class
ElementCreationOptionsOrString
;
}
}
#
endif
class
InfallibleAllocPolicy
;
class
JSObject
;
class
JSTracer
;
class
PLDHashTable
;
class
gfxUserFontSet
;
class
mozIDOMWindowProxy
;
class
nsCachableElementsByNameNodeList
;
class
nsCommandManager
;
class
nsContentList
;
class
nsCycleCollectionTraversalCallback
;
class
nsDOMCaretPosition
;
class
nsDOMNavigationTiming
;
class
nsDocShell
;
class
nsFrameLoader
;
class
nsFrameLoaderOwner
;
class
nsGenericHTMLElement
;
class
nsGlobalWindowInner
;
class
nsHTMLCSSStyleSheet
;
class
nsHTMLDocument
;
class
nsHTMLStyleSheet
;
class
nsHtml5TreeOpExecutor
;
class
nsIAppWindow
;
class
nsIApplicationCache
;
class
nsIAsyncVerifyRedirectCallback
;
class
nsIBFCacheEntry
;
class
nsIContent
;
class
nsIContentSecurityPolicy
;
class
nsIContentSink
;
class
nsICookieJarSettings
;
class
nsIDOMXULCommandDispatcher
;
class
nsIDocShell
;
class
nsIDocShellTreeItem
;
class
nsIDocumentEncoder
;
class
nsIDocumentObserver
;
class
nsIEventTarget
;
class
nsIFrame
;
class
nsIGlobalObject
;
class
nsIHTMLCollection
;
class
nsIInputStream
;
class
nsILayoutHistoryState
;
class
nsIObjectLoadingContent
;
class
nsIPermissionDelegateHandler
;
class
nsIRadioVisitor
;
class
nsIRequest
;
class
nsIRunnable
;
class
nsIScriptGlobalObject
;
class
nsISecurityConsoleMessage
;
class
nsISerialEventTarget
;
class
nsIStructuredCloneContainer
;
class
nsIVariant
;
class
nsNodeInfoManager
;
class
nsPIWindowRoot
;
class
nsPresContext
;
class
nsRange
;
class
nsSimpleContentList
;
class
nsTextNode
;
class
nsViewManager
;
class
nsXULPrototypeDocument
;
struct
JSContext
;
struct
RawServoSelectorList
;
struct
StyleUseCounters
;
struct
nsFont
;
namespace
mozilla
{
class
AbstractThread
;
class
StyleSheet
;
class
EditorCommand
;
class
Encoding
;
class
ErrorResult
;
class
EventListenerManager
;
class
FullscreenExit
;
class
FullscreenRequest
;
struct
LangGroupFontPrefs
;
class
PendingAnimationTracker
;
class
PermissionDelegateHandler
;
class
PresShell
;
class
ServoStyleSet
;
enum
class
StyleOrigin
:
uint8_t
;
class
SMILAnimationController
;
enum
class
StyleCursorKind
:
uint8_t
;
enum
class
StylePrefersColorScheme
:
uint8_t
;
enum
class
StyleRuleChangeKind
:
uint32_t
;
template
<
typename
>
class
OwningNonNull
;
struct
URLExtraData
;
namespace
css
{
class
Loader
;
class
ImageLoader
;
class
Rule
;
}
namespace
dom
{
class
AnonymousContent
;
class
Attr
;
class
XULBroadcastManager
;
class
XULPersist
;
class
ChromeObserver
;
class
ClientInfo
;
class
ClientState
;
class
CDATASection
;
class
Comment
;
class
CSSImportRule
;
class
DocumentL10n
;
class
DocumentFragment
;
class
DocumentTimeline
;
class
DocumentType
;
class
DOMImplementation
;
class
DOMIntersectionObserver
;
class
DOMStringList
;
class
Event
;
class
EventListener
;
struct
FailedCertSecurityInfo
;
class
FeaturePolicy
;
class
FontFaceSet
;
class
FrameRequestCallback
;
class
ImageTracker
;
class
HTMLAllCollection
;
class
HTMLBodyElement
;
class
HTMLInputElement
;
class
HTMLMetaElement
;
class
HTMLDialogElement
;
class
HTMLSharedElement
;
class
HTMLImageElement
;
struct
LifecycleCallbackArgs
;
class
Link
;
class
Location
;
class
MediaQueryList
;
struct
NetErrorInfo
;
class
NodeFilter
;
class
NodeInfo
;
class
NodeIterator
;
enum
class
OrientationType
:
uint8_t
;
class
ProcessingInstruction
;
class
Promise
;
class
ScriptLoader
;
class
Selection
;
class
ServiceWorkerDescriptor
;
class
ShadowRoot
;
class
SVGDocument
;
class
SVGElement
;
class
SVGSVGElement
;
class
SVGUseElement
;
class
Touch
;
class
TouchList
;
class
TreeWalker
;
enum
class
ViewportFitType
:
uint8_t
;
class
WindowContext
;
class
WindowGlobalChild
;
class
WindowProxyHolder
;
class
XPathEvaluator
;
class
XPathExpression
;
class
XPathNSResolver
;
class
XPathResult
;
class
BrowsingContext
;
class
nsDocumentOnStack
;
class
nsUnblockOnloadEvent
;
template
<
typename
typename
>
class
CallbackObjectHolder
;
enum
class
CallerType
:
uint32_t
;
enum
BFCacheStatus
{
NOT_ALLOWED
=
1
<
<
0
EVENT_HANDLING_SUPPRESSED
=
1
<
<
1
SUSPENDED
=
1
<
<
2
UNLOAD_LISTENER
=
1
<
<
3
REQUEST
=
1
<
<
4
ACTIVE_GET_USER_MEDIA
=
1
<
<
5
ACTIVE_PEER_CONNECTION
=
1
<
<
6
CONTAINS_EME_CONTENT
=
1
<
<
7
CONTAINS_MSE_CONTENT
=
1
<
<
8
HAS_ACTIVE_SPEECH_SYNTHESIS
=
1
<
<
9
HAS_USED_VR
=
1
<
<
10
CONTAINS_REMOTE_SUBFRAMES
=
1
<
<
11
NOT_ONLY_TOPLEVEL_IN_BCG
=
1
<
<
12
}
;
}
}
namespace
mozilla
{
namespace
net
{
class
ChannelEventQueue
;
}
}
#
define
NS_IDOCUMENT_IID
\
{
\
0xce1f7627
0x7109
0x4977
{
\
0xba
0x77
0x49
0x0f
0xfd
0xe0
0x7a
0xaa
\
}
\
}
namespace
mozilla
{
namespace
dom
{
class
Document
;
class
DOMStyleSheetSetList
;
class
ResizeObserver
;
class
ResizeObserverController
;
class
PostMessageEvent
;
#
define
DEPRECATED_OPERATION
(
_op
)
e
#
#
_op
enum
class
DeprecatedOperations
:
uint16_t
{
#
include
"
nsDeprecatedOperationList
.
h
"
eDeprecatedOperationCount
}
;
#
undef
DEPRECATED_OPERATION
#
define
NS_DOCUMENT_STATE_RTL_LOCALE
NS_DEFINE_EVENT_STATE_MACRO
(
0
)
#
define
NS_DOCUMENT_STATE_WINDOW_INACTIVE
NS_DEFINE_EVENT_STATE_MACRO
(
1
)
class
DocHeaderData
{
public
:
DocHeaderData
(
nsAtom
*
aField
const
nsAString
&
aData
)
:
mField
(
aField
)
mData
(
aData
)
mNext
(
nullptr
)
{
}
~
DocHeaderData
(
void
)
{
delete
mNext
;
}
RefPtr
<
nsAtom
>
mField
;
nsString
mData
;
DocHeaderData
*
mNext
;
}
;
class
ExternalResourceMap
{
using
SubDocEnumFunc
=
FunctionRef
<
CallState
(
Document
&
)
>
;
public
:
class
ExternalResourceLoad
:
public
nsISupports
{
public
:
virtual
~
ExternalResourceLoad
(
)
=
default
;
void
AddObserver
(
nsIObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
"
Must
have
observer
"
)
;
mObservers
.
AppendElement
(
aObserver
)
;
}
const
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
&
Observers
(
)
{
return
mObservers
;
}
protected
:
AutoTArray
<
nsCOMPtr
<
nsIObserver
>
8
>
mObservers
;
}
;
ExternalResourceMap
(
)
;
Document
*
RequestResource
(
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
Document
*
aDisplayDocument
ExternalResourceLoad
*
*
aPendingLoad
)
;
void
EnumerateResources
(
SubDocEnumFunc
aCallback
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
const
;
void
Shutdown
(
)
{
mPendingLoads
.
Clear
(
)
;
mMap
.
Clear
(
)
;
mHaveShutDown
=
true
;
}
bool
HaveShutDown
(
)
const
{
return
mHaveShutDown
;
}
struct
ExternalResource
{
~
ExternalResource
(
)
;
RefPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsIContentViewer
>
mViewer
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
}
;
void
HideViewers
(
)
;
void
ShowViewers
(
)
;
protected
:
class
PendingLoad
:
public
ExternalResourceLoad
public
nsIStreamListener
{
~
PendingLoad
(
)
=
default
;
public
:
explicit
PendingLoad
(
Document
*
aDisplayDocument
)
:
mDisplayDocument
(
aDisplayDocument
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
nsresult
StartLoad
(
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
)
;
nsresult
SetupViewer
(
nsIRequest
*
aRequest
nsIContentViewer
*
*
aViewer
nsILoadGroup
*
*
aLoadGroup
)
;
private
:
RefPtr
<
Document
>
mDisplayDocument
;
nsCOMPtr
<
nsIStreamListener
>
mTargetListener
;
nsCOMPtr
<
nsIURI
>
mURI
;
}
;
friend
class
PendingLoad
;
class
LoadgroupCallbacks
final
:
public
nsIInterfaceRequestor
{
~
LoadgroupCallbacks
(
)
=
default
;
public
:
explicit
LoadgroupCallbacks
(
nsIInterfaceRequestor
*
aOtherCallbacks
)
:
mCallbacks
(
aOtherCallbacks
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
private
:
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
#
define
DECL_SHIM
(
_i
_allcaps
)
\
class
_i
#
#
Shim
final
:
public
nsIInterfaceRequestor
public
_i
{
\
~
_i
#
#
Shim
(
)
{
}
\
\
public
:
\
_i
#
#
Shim
(
nsIInterfaceRequestor
*
aIfreq
_i
*
aRealPtr
)
\
:
mIfReq
(
aIfreq
)
mRealPtr
(
aRealPtr
)
{
\
NS_ASSERTION
(
mIfReq
"
Expected
non
-
null
here
"
)
;
\
NS_ASSERTION
(
mRealPtr
"
Expected
non
-
null
here
"
)
;
\
}
\
NS_DECL_ISUPPORTS
\
NS_FORWARD_NSIINTERFACEREQUESTOR
(
mIfReq
-
>
)
\
NS_FORWARD_
#
#
_allcaps
(
mRealPtr
-
>
)
private
\
:
nsCOMPtr
<
nsIInterfaceRequestor
>
mIfReq
;
\
nsCOMPtr
<
_i
>
mRealPtr
;
\
}
;
DECL_SHIM
(
nsILoadContext
NSILOADCONTEXT
)
DECL_SHIM
(
nsIProgressEventSink
NSIPROGRESSEVENTSINK
)
DECL_SHIM
(
nsIChannelEventSink
NSICHANNELEVENTSINK
)
DECL_SHIM
(
nsIApplicationCacheContainer
NSIAPPLICATIONCACHECONTAINER
)
#
undef
DECL_SHIM
}
;
nsresult
AddExternalResource
(
nsIURI
*
aURI
nsIContentViewer
*
aViewer
nsILoadGroup
*
aLoadGroup
Document
*
aDisplayDocument
)
;
nsClassHashtable
<
nsURIHashKey
ExternalResource
>
mMap
;
nsRefPtrHashtable
<
nsURIHashKey
PendingLoad
>
mPendingLoads
;
bool
mHaveShutDown
;
}
;
enum
class
SheetPreloadStatus
:
uint8_t
{
AlreadyComplete
InProgress
Errored
}
;
class
Document
:
public
nsINode
public
DocumentOrShadowRoot
public
nsSupportsWeakReference
public
nsIRadioGroupContainer
public
nsIScriptObjectPrincipal
public
nsIApplicationCacheContainer
public
nsStubMutationObserver
public
DispatcherTrait
public
SupportsWeakPtr
{
friend
class
DocumentOrShadowRoot
;
protected
:
explicit
Document
(
const
char
*
aContentType
)
;
virtual
~
Document
(
)
;
Document
(
const
Document
&
)
=
delete
;
Document
&
operator
=
(
const
Document
&
)
=
delete
;
public
:
typedef
dom
:
:
ExternalResourceMap
:
:
ExternalResourceLoad
ExternalResourceLoad
;
typedef
dom
:
:
ReferrerPolicy
ReferrerPolicyEnum
;
using
AdoptedStyleSheetCloneCache
=
nsRefPtrHashtable
<
nsPtrHashKey
<
const
StyleSheet
>
StyleSheet
>
;
void
*
operator
new
(
size_t
aSize
)
{
return
:
:
operator
new
(
aSize
)
;
}
static
void
Shutdown
(
)
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IDOCUMENT_IID
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
Document
nsINode
)
#
define
NS_DOCUMENT_NOTIFY_OBSERVERS
(
func_
params_
)
\
do
{
\
NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS
(
mObservers
func_
params_
)
;
\
/
*
FIXME
(
emilio
)
:
Apparently
we
can
keep
observing
from
the
BFCache
?
That
\
looks
bogus
.
*
/
\
if
(
PresShell
*
presShell
=
GetObservingPresShell
(
)
)
{
\
presShell
-
>
func_
params_
;
\
}
\
}
while
(
0
)
NS_DECL_NSIAPPLICATIONCACHECONTAINER
NS_IMETHOD
WalkRadioGroup
(
const
nsAString
&
aName
nsIRadioVisitor
*
aVisitor
bool
aFlushContent
)
final
{
return
DocumentOrShadowRoot
:
:
WalkRadioGroup
(
aName
aVisitor
aFlushContent
)
;
}
void
SetCurrentRadioButton
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
final
{
DocumentOrShadowRoot
:
:
SetCurrentRadioButton
(
aName
aRadio
)
;
}
HTMLInputElement
*
GetCurrentRadioButton
(
const
nsAString
&
aName
)
final
{
return
DocumentOrShadowRoot
:
:
GetCurrentRadioButton
(
aName
)
;
}
NS_IMETHOD
GetNextRadioButton
(
const
nsAString
&
aName
const
bool
aPrevious
HTMLInputElement
*
aFocusedRadio
HTMLInputElement
*
*
aRadioOut
)
final
{
return
DocumentOrShadowRoot
:
:
GetNextRadioButton
(
aName
aPrevious
aFocusedRadio
aRadioOut
)
;
}
void
AddToRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
final
{
DocumentOrShadowRoot
:
:
AddToRadioGroup
(
aName
aRadio
)
;
}
void
RemoveFromRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
final
{
DocumentOrShadowRoot
:
:
RemoveFromRadioGroup
(
aName
aRadio
)
;
}
uint32_t
GetRequiredRadioCount
(
const
nsAString
&
aName
)
const
final
{
return
DocumentOrShadowRoot
:
:
GetRequiredRadioCount
(
aName
)
;
}
void
RadioRequiredWillChange
(
const
nsAString
&
aName
bool
aRequiredAdded
)
final
{
DocumentOrShadowRoot
:
:
RadioRequiredWillChange
(
aName
aRequiredAdded
)
;
}
bool
GetValueMissingState
(
const
nsAString
&
aName
)
const
final
{
return
DocumentOrShadowRoot
:
:
GetValueMissingState
(
aName
)
;
}
void
SetValueMissingState
(
const
nsAString
&
aName
bool
aValue
)
final
{
return
DocumentOrShadowRoot
:
:
SetValueMissingState
(
aName
aValue
)
;
}
nsIPrincipal
*
EffectiveStoragePrincipal
(
)
const
;
nsIPrincipal
*
GetPrincipal
(
)
final
{
return
NodePrincipal
(
)
;
}
nsIPrincipal
*
GetEffectiveStoragePrincipal
(
)
final
{
return
EffectiveStoragePrincipal
(
)
;
}
nsIPrincipal
*
PartitionedPrincipal
(
)
final
{
return
mPartitionedPrincipal
;
}
void
ClearActiveStoragePrincipal
(
)
{
mActiveStoragePrincipal
=
nullptr
;
}
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
class
MOZ_RAII
PageUnloadingEventTimeStamp
{
RefPtr
<
Document
>
mDocument
;
bool
mSet
;
public
:
explicit
PageUnloadingEventTimeStamp
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mSet
(
false
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
mDocument
-
>
mPageUnloadingEventTimeStamp
.
IsNull
(
)
)
{
mDocument
-
>
SetPageUnloadingEventTimeStamp
(
)
;
mSet
=
true
;
}
}
~
PageUnloadingEventTimeStamp
(
)
{
if
(
mSet
)
{
mDocument
-
>
CleanUnloadEventsTimeStamp
(
)
;
}
}
}
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
=
nullptr
)
=
0
;
void
StopDocumentLoad
(
)
;
virtual
void
SetSuppressParserErrorElement
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorElement
(
)
{
return
false
;
}
virtual
void
SetSuppressParserErrorConsoleMessages
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorConsoleMessages
(
)
{
return
false
;
}
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
final
;
nsresult
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
override
;
void
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
final
;
nsresult
Clone
(
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
CloneDocHelper
(
Document
*
clone
)
const
;
Document
*
GetLatestStaticClone
(
)
const
{
return
mLatestStaticClone
;
}
virtual
void
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
;
nsIURI
*
GetDocumentURI
(
)
const
{
return
mDocumentURI
;
}
nsIURI
*
GetOriginalURI
(
)
const
{
return
mOriginalURI
;
}
nsCString
GetBaseDomain
(
)
const
{
return
mBaseDomain
;
}
void
SetDocumentURI
(
nsIURI
*
aURI
)
;
void
SetChromeXHRDocURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocURI
=
aURI
;
}
void
SetChromeXHRDocBaseURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocBaseURI
=
aURI
;
}
nsIContentSecurityPolicy
*
GetCsp
(
)
const
;
void
SetCsp
(
nsIContentSecurityPolicy
*
aCSP
)
;
nsIContentSecurityPolicy
*
GetPreloadCsp
(
)
const
;
void
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCSP
)
;
void
GetCspJSON
(
nsString
&
aJSON
)
;
void
ApplySettingsFromCSP
(
bool
aSpeculative
)
;
already_AddRefed
<
nsIParser
>
CreatorParserOrNull
(
)
{
nsCOMPtr
<
nsIParser
>
parser
=
mParser
;
return
parser
.
forget
(
)
;
}
nsIReferrerInfo
*
ReferrerInfo
(
)
const
{
return
GetReferrerInfo
(
)
;
}
nsIReferrerInfo
*
GetReferrerInfo
(
)
const
{
return
mReferrerInfo
;
}
nsIReferrerInfo
*
GetPreloadReferrerInfo
(
)
const
{
return
mPreloadReferrerInfo
;
}
ReferrerPolicyEnum
GetReferrerPolicy
(
)
const
;
ReferrerPolicyEnum
ReferrerPolicy
(
)
const
{
return
GetReferrerPolicy
(
)
;
}
bool
GetBlockAllMixedContent
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mBlockAllMixedContentPreloads
;
}
return
mBlockAllMixedContent
;
}
bool
GetUpgradeInsecureRequests
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mUpgradeInsecurePreloads
;
}
return
mUpgradeInsecureRequests
;
}
void
SetReferrerInfo
(
nsIReferrerInfo
*
aReferrerInfo
)
{
mReferrerInfo
=
aReferrerInfo
;
}
void
UpdateReferrerInfoFromMeta
(
const
nsAString
&
aMetaReferrer
bool
aPreload
)
;
void
SetPrincipals
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
)
;
uint32_t
HttpsOnlyStatus
(
)
const
{
return
mHttpsOnlyStatus
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
const
{
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
return
group
.
forget
(
)
;
}
nsIURI
*
GetFallbackBaseURI
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
{
return
mParentDocument
-
>
GetDocBaseURI
(
)
;
}
return
mDocumentURI
;
}
nsIURI
*
GetDocumentURIAsReferrer
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
{
return
mParentDocument
-
>
GetDocumentURIAsReferrer
(
)
;
}
return
mDocumentURI
;
}
nsIURI
*
GetDocBaseURI
(
)
const
{
if
(
mDocumentBaseURI
)
{
return
mDocumentBaseURI
;
}
return
GetFallbackBaseURI
(
)
;
}
nsIURI
*
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
final
;
void
SetBaseURI
(
nsIURI
*
aURI
)
;
Result
<
OwningNonNull
<
nsIURI
>
nsresult
>
ResolveWithBaseURI
(
const
nsAString
&
aURI
)
;
URLExtraData
*
DefaultStyleAttrURLData
(
)
;
void
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
{
aBaseTarget
=
mBaseTarget
;
}
void
SetBaseTarget
(
const
nsString
&
aBaseTarget
)
{
mBaseTarget
=
aBaseTarget
;
}
NotNull
<
const
Encoding
*
>
GetDocumentCharacterSet
(
)
const
{
return
mCharacterSet
;
}
void
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
;
int32_t
GetDocumentCharacterSetSource
(
)
const
{
return
mCharacterSetSource
;
}
void
SetDocumentCharacterSetSource
(
int32_t
aCharsetSource
)
{
mCharacterSetSource
=
aCharsetSource
;
}
void
GetContentType
(
nsAString
&
aContentType
)
;
virtual
void
SetContentType
(
const
nsAString
&
aContentType
)
;
void
GetContentLanguage
(
nsAString
&
aContentLanguage
)
const
{
CopyASCIItoUTF16
(
mContentLanguage
aContentLanguage
)
;
}
bool
GetBidiEnabled
(
)
const
{
return
mBidiEnabled
;
}
void
SetBidiEnabled
(
)
{
mBidiEnabled
=
true
;
}
void
SetMathMLEnabled
(
)
{
mMathMLEnabled
=
true
;
}
bool
IsInitialDocument
(
)
const
{
return
mIsInitialDocumentInWindow
;
}
void
SetIsInitialDocument
(
bool
aIsInitialDocument
)
;
void
SetLoadedAsData
(
bool
aLoadedAsData
)
{
mLoadedAsData
=
aLoadedAsData
;
}
void
IgnoreDocGroupMismatches
(
)
{
mIgnoreDocGroupMismatches
=
true
;
}
uint32_t
GetBidiOptions
(
)
const
{
return
mBidiOptions
;
}
void
SetBidiOptions
(
uint32_t
aBidiOptions
)
{
mBidiOptions
=
aBidiOptions
;
}
void
SetHasCSP
(
bool
aHasCSP
)
{
mHasCSP
=
aHasCSP
;
}
void
SetHasUnsafeInlineCSP
(
bool
aHasUnsafeInlineCSP
)
{
mHasUnsafeInlineCSP
=
aHasUnsafeInlineCSP
;
}
void
SetHasUnsafeEvalCSP
(
bool
aHasUnsafeEvalCSP
)
{
mHasUnsafeEvalCSP
=
aHasUnsafeEvalCSP
;
}
bool
GetHasCSPDeliveredThroughHeader
(
)
{
return
mHasCSPDeliveredThroughHeader
;
}
typedef
MozPromise
<
uint32_t
bool
true
>
GetContentBlockingEventsPromise
;
MOZ_MUST_USE
RefPtr
<
GetContentBlockingEventsPromise
>
GetContentBlockingEvents
(
)
;
uint32_t
GetSandboxFlags
(
)
const
{
return
mSandboxFlags
;
}
Maybe
<
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
>
GetEmbedderPolicy
(
)
const
{
return
mEmbedderPolicy
;
}
void
SetEmbedderPolicy
(
const
Maybe
<
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
>
&
aCOEP
)
{
mEmbedderPolicy
=
aCOEP
;
}
void
GetSandboxFlagsAsString
(
nsAString
&
aFlags
)
;
void
SetSandboxFlags
(
uint32_t
sandboxFlags
)
{
mSandboxFlags
=
sandboxFlags
;
}
void
EnableEncodingMenu
(
)
{
mEncodingMenuDisabled
=
false
;
}
void
DisableCookieAccess
(
)
{
mDisableCookieAccess
=
true
;
}
void
SetLinkHandlingEnabled
(
bool
aValue
)
{
mLinksEnabled
=
aValue
;
}
bool
LinkHandlingEnabled
(
)
{
return
mLinksEnabled
;
}
void
SetCompatibilityMode
(
nsCompatibility
aMode
)
;
void
SetDocWriteDisabled
(
bool
aDisabled
)
{
mDisableDocWrite
=
aDisabled
;
}
bool
IsWriting
(
)
const
{
return
mWriteLevel
!
=
uint32_t
(
0
)
;
}
void
GetHeaderData
(
nsAtom
*
aHeaderField
nsAString
&
aData
)
const
;
void
SetHeaderData
(
nsAtom
*
aheaderField
const
nsAString
&
aData
)
;
already_AddRefed
<
PresShell
>
CreatePresShell
(
nsPresContext
*
aContext
nsViewManager
*
aViewManager
)
;
void
DeletePresShell
(
)
;
PresShell
*
GetPresShell
(
)
const
{
return
GetBFCacheEntry
(
)
?
nullptr
:
mPresShell
;
}
inline
PresShell
*
GetObservingPresShell
(
)
const
;
bool
IsSafeToFlush
(
)
const
;
inline
nsPresContext
*
GetPresContext
(
)
const
;
bool
HasShellOrBFCacheEntry
(
)
const
{
return
mPresShell
|
|
mBFCacheEntry
;
}
void
DisallowBFCaching
(
)
{
NS_ASSERTION
(
!
mBFCacheEntry
"
We
'
re
already
in
the
bfcache
!
"
)
;
mBFCacheDisallowed
=
true
;
}
bool
IsBFCachingAllowed
(
)
const
{
return
!
mBFCacheDisallowed
;
}
void
SetBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
;
nsIBFCacheEntry
*
GetBFCacheEntry
(
)
const
{
return
mBFCacheEntry
;
}
bool
RemoveFromBFCacheSync
(
)
;
Document
*
GetInProcessParentDocument
(
)
const
{
return
mParentDocument
;
}
void
SetParentDocument
(
Document
*
aParent
)
{
mParentDocument
=
aParent
;
if
(
aParent
)
{
mIgnoreDocGroupMismatches
=
aParent
-
>
mIgnoreDocGroupMismatches
;
if
(
!
mIsDevToolsDocument
)
{
mIsDevToolsDocument
=
mParentDocument
-
>
IsDevToolsDocument
(
)
;
}
}
}
bool
GetAllowPlugins
(
)
;
nsresult
SetSubDocumentFor
(
Element
*
aContent
Document
*
aSubDoc
)
;
Document
*
GetSubDocumentFor
(
nsIContent
*
aContent
)
const
;
Element
*
GetEmbedderElement
(
)
const
;
DocumentType
*
GetDoctype
(
)
const
;
Element
*
GetRootElement
(
)
const
;
Selection
*
GetSelection
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
HasStorageAccess
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
RequestStorageAccess
(
ErrorResult
&
aRv
)
;
bool
UseRegularPrincipal
(
)
const
;
virtual
Element
*
GetUnfocusedKeyEventTarget
(
)
;
nsViewportInfo
GetViewportInfo
(
const
ScreenIntSize
&
aDisplaySize
)
;
void
AddMetaViewportElement
(
HTMLMetaElement
*
aElement
ViewportMetaData
&
&
aData
)
;
void
RemoveMetaViewportElement
(
HTMLMetaElement
*
aElement
)
;
ViewportMetaData
GetViewportMetaData
(
)
const
;
virtual
bool
WillIgnoreCharsetOverride
(
)
{
return
true
;
}
bool
IsSrcdocDocument
(
)
const
{
return
mIsSrcdocDocument
;
}
void
SetIsSrcdocDocument
(
bool
aIsSrcdocDocument
)
{
mIsSrcdocDocument
=
aIsSrcdocDocument
;
}
nsresult
GetSrcdocData
(
nsAString
&
aSrcdocData
)
;
already_AddRefed
<
AnonymousContent
>
InsertAnonymousContent
(
Element
&
aElement
ErrorResult
&
aError
)
;
void
RemoveAnonymousContent
(
AnonymousContent
&
aContent
ErrorResult
&
aError
)
;
Element
*
GetAnonRootIfInAnonymousContentContainer
(
nsINode
*
aNode
)
const
;
nsTArray
<
RefPtr
<
AnonymousContent
>
>
&
GetAnonymousContents
(
)
{
return
mAnonymousContents
;
}
TimeStamp
GetPageUnloadingEventTimeStamp
(
)
const
{
if
(
!
mParentDocument
)
{
return
mPageUnloadingEventTimeStamp
;
}
TimeStamp
parentTimeStamp
(
mParentDocument
-
>
GetPageUnloadingEventTimeStamp
(
)
)
;
if
(
parentTimeStamp
.
IsNull
(
)
)
{
return
mPageUnloadingEventTimeStamp
;
}
if
(
!
mPageUnloadingEventTimeStamp
|
|
parentTimeStamp
<
mPageUnloadingEventTimeStamp
)
{
return
parentTimeStamp
;
}
return
mPageUnloadingEventTimeStamp
;
}
void
NotifyLayerManagerRecreated
(
)
;
void
ScheduleSVGForPresAttrEvaluation
(
SVGElement
*
aSVG
)
{
mLazySVGPresElements
.
PutEntry
(
aSVG
)
;
}
void
UnscheduleSVGForPresAttrEvaluation
(
SVGElement
*
aSVG
)
{
mLazySVGPresElements
.
RemoveEntry
(
aSVG
)
;
}
void
ResolveScheduledSVGPresAttrs
(
)
;
Maybe
<
ClientInfo
>
GetClientInfo
(
)
const
;
Maybe
<
ClientState
>
GetClientState
(
)
const
;
Maybe
<
ServiceWorkerDescriptor
>
GetController
(
)
const
;
long
BlockedNodeByClassifierCount
(
)
const
{
return
mBlockedNodesByClassifier
.
Length
(
)
;
}
already_AddRefed
<
nsSimpleContentList
>
BlockedNodesByClassifier
(
)
const
;
bool
StorageAccessSandboxed
(
)
const
;
static
bool
StorageAccessSandboxed
(
uint32_t
aSandboxFlags
)
;
nsICookieJarSettings
*
CookieJarSettings
(
)
;
bool
HasStorageAccessPermissionGranted
(
)
;
inline
void
Changed
(
)
{
+
+
mGeneration
;
}
inline
int32_t
GetGeneration
(
)
const
{
return
mGeneration
;
}
bool
GetCachedSizes
(
nsTabSizes
*
aSizes
)
;
void
SetCachedSizes
(
nsTabSizes
*
aSizes
)
;
void
ChangeContentEditableCount
(
Element
*
int32_t
aChange
)
;
void
DeferredContentEditableCountChange
(
Element
*
)
;
enum
class
EditingState
:
int8_t
{
eTearingDown
=
-
2
eSettingUp
=
-
1
eOff
=
0
eDesignMode
eContentEditable
}
;
EditingState
GetEditingState
(
)
const
{
return
mEditingState
;
}
bool
IsEditingOn
(
)
const
{
return
GetEditingState
(
)
=
=
EditingState
:
:
eDesignMode
|
|
GetEditingState
(
)
=
=
EditingState
:
:
eContentEditable
;
}
class
MOZ_STACK_CLASS
nsAutoEditingState
{
public
:
nsAutoEditingState
(
Document
*
aDoc
EditingState
aState
)
:
mDoc
(
aDoc
)
mSavedState
(
aDoc
-
>
mEditingState
)
{
aDoc
-
>
mEditingState
=
aState
;
}
~
nsAutoEditingState
(
)
{
mDoc
-
>
mEditingState
=
mSavedState
;
}
private
:
RefPtr
<
Document
>
mDoc
;
EditingState
mSavedState
;
}
;
friend
class
nsAutoEditingState
;
void
SetEditingState
(
EditingState
aState
)
{
mEditingState
=
aState
;
}
void
TearingDownEditor
(
)
;
void
SetKeyPressEventModel
(
uint16_t
aKeyPressEventModel
)
;
int32_t
GetNextFormNumber
(
)
{
return
mNextFormNumber
+
+
;
}
int32_t
GetNextControlNumber
(
)
{
return
mNextControlNumber
+
+
;
}
PreloadService
&
Preloads
(
)
{
return
mPreloadService
;
}
bool
HasThirdPartyChannel
(
)
;
bool
ShouldIncludeInTelemetry
(
bool
aAllowExtensionURIs
)
;
protected
:
friend
class
nsUnblockOnloadEvent
;
nsresult
InitCSP
(
nsIChannel
*
aChannel
)
;
nsresult
InitCOEP
(
nsIChannel
*
aChannel
)
;
nsresult
InitFeaturePolicy
(
nsIChannel
*
aChannel
)
;
nsresult
InitReferrerInfo
(
nsIChannel
*
aChannel
)
;
void
PostUnblockOnloadEvent
(
)
;
void
DoUnblockOnload
(
)
;
void
RetrieveRelevantHeaders
(
nsIChannel
*
aChannel
)
;
void
TryChannelCharset
(
nsIChannel
*
aChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
nsHtml5TreeOpExecutor
*
aExecutor
)
;
void
DispatchContentLoadedEvents
(
)
;
void
DispatchPageTransition
(
EventTarget
*
aDispatchTarget
const
nsAString
&
aType
bool
aInFrameSwap
bool
aPersisted
bool
aOnlySystemGroup
)
;
void
DestroyElementMaps
(
)
;
Element
*
GetRootElementInternal
(
)
const
;
void
DoNotifyPossibleTitleChange
(
)
;
void
SetPageUnloadingEventTimeStamp
(
)
{
MOZ_ASSERT
(
!
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
TimeStamp
:
:
NowLoRes
(
)
;
}
void
CleanUnloadEventsTimeStamp
(
)
{
MOZ_ASSERT
(
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
TimeStamp
(
)
;
}
void
ClearStaleServoData
(
)
;
already_AddRefed
<
nsPIWindowRoot
>
GetWindowRoot
(
)
;
void
DisconnectNodeTree
(
)
;
bool
IsEditingOnAfterFlush
(
)
;
void
MaybeDispatchCheckKeyPressEventModelEvent
(
)
;
nsCommandManager
*
GetMidasCommandManager
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
TurnEditingOff
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
EditingStateChanged
(
)
;
void
MaybeEditingStateChanged
(
)
;
private
:
class
SelectorCacheKey
{
public
:
explicit
SelectorCacheKey
(
const
nsACString
&
aString
)
:
mKey
(
aString
)
{
MOZ_COUNT_CTOR
(
SelectorCacheKey
)
;
}
nsCString
mKey
;
nsExpirationState
mState
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mState
;
}
MOZ_COUNTED_DTOR
(
SelectorCacheKey
)
}
;
class
SelectorCacheKeyDeleter
;
public
:
class
SelectorCache
final
:
public
nsExpirationTracker
<
SelectorCacheKey
4
>
{
public
:
using
SelectorList
=
UniquePtr
<
RawServoSelectorList
>
;
using
Table
=
nsDataHashtable
<
nsCStringHashKey
SelectorList
>
;
explicit
SelectorCache
(
nsIEventTarget
*
aEventTarget
)
;
void
NotifyExpired
(
SelectorCacheKey
*
)
final
;
Table
:
:
EntryPtr
GetList
(
const
nsACString
&
aSelector
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mTable
.
LookupForAdd
(
aSelector
)
;
}
~
SelectorCache
(
)
;
private
:
Table
mTable
;
}
;
SelectorCache
&
GetSelectorCache
(
)
{
if
(
!
mSelectorCache
)
{
mSelectorCache
=
MakeUnique
<
SelectorCache
>
(
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
return
*
mSelectorCache
;
}
Element
*
GetHtmlElement
(
)
const
;
Element
*
GetHtmlChildElement
(
nsAtom
*
aTag
)
;
HTMLBodyElement
*
GetBodyElement
(
)
;
Element
*
GetHeadElement
(
)
{
return
GetHtmlChildElement
(
nsGkAtoms
:
:
head
)
;
}
nsGenericHTMLElement
*
GetBody
(
)
;
void
SetBody
(
nsGenericHTMLElement
*
aBody
ErrorResult
&
rv
)
;
HTMLSharedElement
*
GetHead
(
)
;
ServoStyleSet
*
StyleSetForPresShellOrMediaQueryEvaluation
(
)
const
{
return
mStyleSet
.
get
(
)
;
}
void
RecordShadowStyleChange
(
ShadowRoot
&
)
;
void
ApplicableStylesChanged
(
)
;
bool
StyleSetFilled
(
)
const
{
return
mStyleSetFilled
;
}
void
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
)
;
void
AddStyleSheet
(
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
InsertSheetAt
(
SheetCount
(
)
*
aSheet
)
;
}
void
StyleSheetApplicableStateChanged
(
StyleSheet
&
)
;
void
PostStyleSheetApplicableStateChangeEvent
(
StyleSheet
&
)
;
enum
additionalSheetType
{
eAgentSheet
eUserSheet
eAuthorSheet
AdditionalSheetTypeCount
}
;
nsresult
LoadAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
;
nsresult
AddAdditionalStyleSheet
(
additionalSheetType
aType
StyleSheet
*
aSheet
)
;
void
RemoveAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
sheetURI
)
;
StyleSheet
*
GetFirstAdditionalAuthorSheet
(
)
{
return
mAdditionalSheets
[
eAuthorSheet
]
.
SafeElementAt
(
0
)
;
}
size_t
FindDocStyleSheetInsertionPoint
(
const
StyleSheet
&
aSheet
)
;
css
:
:
Loader
*
CSSLoader
(
)
const
{
return
mCSSLoader
;
}
css
:
:
ImageLoader
*
StyleImageLoader
(
)
const
{
return
mStyleImageLoader
;
}
nsIChannel
*
GetChannel
(
)
const
{
return
mChannel
;
}
nsHTMLStyleSheet
*
GetAttributeStyleSheet
(
)
const
{
return
mAttrStyleSheet
;
}
nsHTMLCSSStyleSheet
*
GetInlineStyleSheet
(
)
const
{
return
mStyleAttrStyleSheet
;
}
virtual
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aGlobalObject
)
;
nsIScriptGlobalObject
*
GetScriptHandlingObject
(
bool
&
aHasHadScriptHandlingObject
)
const
{
aHasHadScriptHandlingObject
=
mHasHadScriptHandlingObject
;
return
mScriptGlobalObject
?
mScriptGlobalObject
.
get
(
)
:
GetScriptHandlingObjectInternal
(
)
;
}
void
SetScriptHandlingObject
(
nsIScriptGlobalObject
*
aScriptObject
)
;
nsIGlobalObject
*
GetScopeObject
(
)
const
;
void
SetScopeObject
(
nsIGlobalObject
*
aGlobal
)
;
bool
CrossOriginIsolated
(
)
const
;
nsPIDOMWindowOuter
*
GetWindow
(
)
const
{
return
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
GetWindowInternal
(
)
;
}
bool
IsInBackgroundWindow
(
)
const
{
auto
*
outer
=
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
nullptr
;
return
outer
&
&
outer
-
>
IsBackground
(
)
;
}
nsPIDOMWindowInner
*
GetInnerWindow
(
)
const
{
return
mRemovedFromDocShell
?
nullptr
:
mWindow
;
}
uint64_t
OuterWindowID
(
)
const
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
uint64_t
InnerWindowID
(
)
const
{
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
WindowGlobalChild
*
GetWindowGlobalChild
(
)
{
return
GetInnerWindow
(
)
?
GetInnerWindow
(
)
-
>
GetWindowGlobalChild
(
)
:
nullptr
;
}
WindowContext
*
GetWindowContext
(
)
const
{
return
GetInnerWindow
(
)
?
GetInnerWindow
(
)
-
>
GetWindowContext
(
)
:
nullptr
;
}
bool
IsTopLevelWindowInactive
(
)
const
;
dom
:
:
ScriptLoader
*
ScriptLoader
(
)
{
return
mScriptLoader
;
}
void
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
AddToNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
void
RemoveFromNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
nsTArray
<
Element
*
>
GetTopLayer
(
)
const
;
void
AsyncRequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
)
;
bool
FullscreenElementReadyCheck
(
FullscreenRequest
&
)
;
void
RequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
bool
applyFullScreenDirectly
=
false
)
;
private
:
void
RequestFullscreenInContentProcess
(
UniquePtr
<
FullscreenRequest
>
aRequest
bool
applyFullScreenDirectly
)
;
void
RequestFullscreenInParentProcess
(
UniquePtr
<
FullscreenRequest
>
aRequest
bool
applyFullScreenDirectly
)
;
public
:
void
CleanupFullscreenState
(
)
;
void
TopLayerPush
(
Element
*
aElement
)
;
Element
*
TopLayerPop
(
FunctionRef
<
bool
(
Element
*
)
>
aPredicateFunc
)
;
void
UnsetFullscreenElement
(
)
;
void
SetFullscreenElement
(
Element
*
aElement
)
;
void
TryCancelDialog
(
)
;
void
SetBlockedByModalDialog
(
HTMLDialogElement
&
)
;
void
UnsetBlockedByModalDialog
(
HTMLDialogElement
&
)
;
void
RemoteFrameFullscreenChanged
(
Element
*
aFrameElement
)
;
void
RemoteFrameFullscreenReverted
(
)
;
void
RestorePreviousFullscreenState
(
UniquePtr
<
FullscreenExit
>
)
;
bool
IsFullscreenLeaf
(
)
;
Document
*
GetFullscreenRoot
(
)
;
size_t
CountFullscreenElements
(
)
const
;
void
SetFullscreenRoot
(
Document
*
aRoot
)
;
static
void
ExitFullscreenInDocTree
(
Document
*
aDocument
)
;
static
void
AsyncExitFullscreen
(
Document
*
aDocument
)
;
static
bool
HandlePendingFullscreenRequests
(
Document
*
aDocument
)
;
void
ClearOrientationPendingPromise
(
)
;
bool
SetOrientationPendingPromise
(
Promise
*
aPromise
)
;
Promise
*
GetOrientationPendingPromise
(
)
const
{
return
mOrientationPendingPromise
;
}
void
AddObserver
(
nsIDocumentObserver
*
aObserver
)
;
bool
RemoveObserver
(
nsIDocumentObserver
*
aObserver
)
;
void
BeginUpdate
(
)
;
void
EndUpdate
(
)
;
uint32_t
UpdateNestingLevel
(
)
{
return
mUpdateNestLevel
;
}
void
BeginLoad
(
)
;
virtual
void
EndLoad
(
)
;
enum
ReadyState
{
READYSTATE_UNINITIALIZED
=
0
READYSTATE_LOADING
=
1
READYSTATE_INTERACTIVE
=
3
READYSTATE_COMPLETE
=
4
}
;
void
SetReadyStateInternal
(
ReadyState
bool
aUpdateTimingInformation
=
true
)
;
ReadyState
GetReadyStateEnum
(
)
{
return
mReadyState
;
}
void
NotifyLoading
(
bool
aNewParentIsLoading
const
ReadyState
&
aCurrentState
ReadyState
aNewState
)
;
void
NotifyAbortedLoad
(
)
;
void
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aStateMask
)
;
void
UpdateDocumentStates
(
EventStates
aStateMask
bool
aNotify
)
;
void
ResetDocumentDirection
(
)
;
void
RuleChanged
(
StyleSheet
&
css
:
:
Rule
*
StyleRuleChangeKind
)
;
void
RuleAdded
(
StyleSheet
&
css
:
:
Rule
&
)
;
void
RuleRemoved
(
StyleSheet
&
css
:
:
Rule
&
)
;
void
SheetCloned
(
StyleSheet
&
)
{
}
void
ImportRuleLoaded
(
CSSImportRule
&
StyleSheet
&
)
;
void
FlushPendingNotifications
(
FlushType
aType
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
FlushPendingNotifications
(
ChangesToFlush
aFlush
)
;
void
FlushExternalResources
(
FlushType
aType
)
;
void
UpdateSVGUseElementShadowTrees
(
)
{
if
(
mSVGUseElementsNeedingShadowTreeUpdate
.
IsEmpty
(
)
)
{
return
;
}
DoUpdateSVGUseElementShadowTrees
(
)
;
}
nsNodeInfoManager
*
NodeInfoManager
(
)
const
{
return
mNodeInfoManager
;
}
virtual
void
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
;
virtual
void
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
)
;
virtual
void
SetContainer
(
nsDocShell
*
aContainer
)
;
nsISupports
*
GetContainer
(
)
const
;
nsILoadContext
*
GetLoadContext
(
)
const
;
nsIDocShell
*
GetDocShell
(
)
const
;
void
SetXMLDeclaration
(
const
char16_t
*
aVersion
const
char16_t
*
aEncoding
const
int32_t
aStandalone
)
;
void
GetXMLDeclaration
(
nsAString
&
aVersion
nsAString
&
aEncoding
nsAString
&
Standalone
)
;
bool
IsHTMLDocument
(
)
const
{
return
mType
=
=
eHTML
;
}
bool
IsHTMLOrXHTML
(
)
const
{
return
mType
=
=
eHTML
|
|
mType
=
=
eXHTML
;
}
bool
IsXMLDocument
(
)
const
{
return
!
IsHTMLDocument
(
)
;
}
bool
IsSVGDocument
(
)
const
{
return
mType
=
=
eSVG
;
}
bool
IsUnstyledDocument
(
)
{
return
IsLoadedAsData
(
)
;
}
bool
LoadsFullXULStyleSheetUpFront
(
)
{
if
(
IsSVGDocument
(
)
)
{
return
false
;
}
return
AllowXULXBL
(
)
;
}
bool
IsScriptEnabled
(
)
;
bool
LoadedFromPrototype
(
)
const
{
return
mPrototypeDocument
;
}
nsXULPrototypeDocument
*
GetPrototype
(
)
const
{
return
mPrototypeDocument
;
}
bool
IsTopLevelContentDocument
(
)
const
{
return
mIsTopLevelContentDocument
;
}
void
SetIsTopLevelContentDocument
(
bool
aIsTopLevelContentDocument
)
{
mIsTopLevelContentDocument
=
aIsTopLevelContentDocument
;
}
bool
IsContentDocument
(
)
const
{
return
mIsContentDocument
;
}
void
SetIsContentDocument
(
bool
aIsContentDocument
)
{
mIsContentDocument
=
aIsContentDocument
;
}
void
ProcessMETATag
(
HTMLMetaElement
*
aMetaElement
)
;
already_AddRefed
<
Element
>
CreateElem
(
const
nsAString
&
aName
nsAtom
*
aPrefix
int32_t
aNamespaceID
const
nsAString
*
aIs
=
nullptr
)
;
nsISupports
*
GetSecurityInfo
(
)
{
return
mSecurityInfo
;
}
nsIChannel
*
GetFailedChannel
(
)
const
{
return
mFailedChannel
;
}
static
bool
CallerIsTrustedAboutNetError
(
JSContext
*
aCx
JSObject
*
aObject
)
;
void
GetNetErrorInfo
(
mozilla
:
:
dom
:
:
NetErrorInfo
&
aInfo
ErrorResult
&
aRv
)
;
static
bool
CallerIsTrustedAboutCertError
(
JSContext
*
aCx
JSObject
*
aObject
)
;
void
GetFailedCertSecurityInfo
(
mozilla
:
:
dom
:
:
FailedCertSecurityInfo
&
aInfo
ErrorResult
&
aRv
)
;
bool
AllowDeprecatedTls
(
)
;
void
SetAllowDeprecatedTls
(
bool
aResult
)
;
void
SetFailedChannel
(
nsIChannel
*
aChannel
)
{
mFailedChannel
=
aChannel
;
}
int32_t
GetDefaultNamespaceID
(
)
const
{
return
mDefaultElementType
;
}
void
RemoveAllProperties
(
)
;
void
RemoveAllPropertiesFor
(
nsINode
*
aNode
)
;
nsPropertyTable
&
PropertyTable
(
)
{
return
mPropertyTable
;
}
void
SetPartID
(
uint32_t
aID
)
{
mPartID
=
aID
;
}
uint32_t
GetPartID
(
)
const
{
return
mPartID
;
}
void
Sanitize
(
)
;
using
SubDocEnumFunc
=
FunctionRef
<
CallState
(
Document
&
)
>
;
void
EnumerateSubDocuments
(
SubDocEnumFunc
aCallback
)
;
typedef
bool
(
*
nsDocTestFunc
)
(
const
Document
*
aDocument
)
;
void
CollectDescendantDocuments
(
nsTArray
<
RefPtr
<
Document
>
>
&
aDescendants
nsDocTestFunc
aCallback
)
const
;
virtual
bool
CanSavePresentation
(
nsIRequest
*
aNewRequest
uint16_t
&
aBFCacheCombo
)
;
virtual
nsresult
Init
(
)
;
virtual
void
Destroy
(
)
;
void
RemovedFromDocShell
(
)
;
already_AddRefed
<
nsILayoutHistoryState
>
GetLayoutHistoryState
(
)
const
;
void
BlockOnload
(
)
;
void
UnblockOnload
(
bool
aFireSync
)
;
void
AsyncBlockOnload
(
)
;
void
BlockDOMContentLoaded
(
)
{
+
+
mBlockDOMContentLoaded
;
}
void
UnblockDOMContentLoaded
(
)
;
virtual
void
OnPageShow
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
=
false
)
;
void
OnPageHide
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
=
false
)
;
void
AddStyleRelevantLink
(
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
!
entry
"
Document
already
knows
about
this
Link
!
"
)
;
mStyledLinksCleared
=
false
;
#
endif
mStyledLinks
.
PutEntry
(
aLink
)
;
}
void
ForgetLink
(
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
entry
|
|
mStyledLinksCleared
"
Document
knows
nothing
about
this
Link
!
"
)
;
#
endif
mStyledLinks
.
RemoveEntry
(
aLink
)
;
}
void
RefreshLinkHrefs
(
)
;
already_AddRefed
<
MediaQueryList
>
MatchMedia
(
const
nsACString
&
aMediaQueryList
CallerType
aCallerType
)
;
LinkedList
<
MediaQueryList
>
&
MediaQueryLists
(
)
{
return
mDOMMediaQueryLists
;
}
nsCompatibility
GetCompatibilityMode
(
)
const
{
return
mCompatMode
;
}
bool
HaveFiredDOMTitleChange
(
)
const
{
return
mHaveFiredTitleChange
;
}
void
MayDispatchMutationEvent
(
nsINode
*
aTarget
)
{
if
(
mSubtreeModifiedDepth
>
0
)
{
mSubtreeModifiedTargets
.
AppendObject
(
aTarget
)
;
}
}
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
bool
IsCookieAverse
(
)
const
{
if
(
!
GetInnerWindow
(
)
)
{
return
true
;
}
return
!
NodePrincipal
(
)
-
>
SchemeIs
(
"
http
"
)
&
&
!
NodePrincipal
(
)
-
>
SchemeIs
(
"
https
"
)
&
&
!
NodePrincipal
(
)
-
>
SchemeIs
(
"
ftp
"
)
&
&
!
NodePrincipal
(
)
-
>
SchemeIs
(
"
file
"
)
;
}
bool
IsLoadedAsData
(
)
{
return
mLoadedAsData
;
}
bool
MayStartLayout
(
)
{
return
mMayStartLayout
;
}
void
SetMayStartLayout
(
bool
aMayStartLayout
)
;
already_AddRefed
<
nsIDocumentEncoder
>
GetCachedEncoder
(
)
;
void
SetCachedEncoder
(
already_AddRefed
<
nsIDocumentEncoder
>
aEncoder
)
;
nsresult
InitializeFrameLoader
(
nsFrameLoader
*
aLoader
)
;
nsresult
FinalizeFrameLoader
(
nsFrameLoader
*
aLoader
nsIRunnable
*
aFinalizer
)
;
void
TryCancelFrameLoaderInitialization
(
nsIDocShell
*
aShell
)
;
bool
IsRootDisplayDocument
(
)
const
{
return
!
mParentDocument
&
&
!
mDisplayDocument
;
}
bool
IsDocumentURISchemeChrome
(
)
const
{
return
mDocURISchemeIsChrome
;
}
bool
IsInChromeDocShell
(
)
const
{
const
Document
*
root
=
this
;
while
(
const
Document
*
displayDoc
=
root
-
>
GetDisplayDocument
(
)
)
{
root
=
displayDoc
;
}
return
root
-
>
mInChromeDocShell
;
}
bool
IsDevToolsDocument
(
)
const
{
return
mIsDevToolsDocument
;
}
bool
IsBeingUsedAsImage
(
)
const
{
return
mIsBeingUsedAsImage
;
}
void
SetIsBeingUsedAsImage
(
)
{
mIsBeingUsedAsImage
=
true
;
}
bool
IsSVGGlyphsDocument
(
)
const
{
return
mIsSVGGlyphsDocument
;
}
void
SetIsSVGGlyphsDocument
(
)
{
mIsSVGGlyphsDocument
=
true
;
}
bool
IsResourceDoc
(
)
const
{
return
IsBeingUsedAsImage
(
)
|
|
mHasDisplayDocument
;
}
Document
*
GetDisplayDocument
(
)
const
{
return
mDisplayDocument
;
}
void
SetDisplayDocument
(
Document
*
aDisplayDocument
)
{
MOZ_ASSERT
(
!
GetPresShell
(
)
&
&
!
GetContainer
(
)
&
&
!
GetWindow
(
)
"
Shouldn
'
t
set
mDisplayDocument
on
documents
that
already
"
"
have
a
presentation
or
a
docshell
or
a
window
"
)
;
MOZ_ASSERT
(
aDisplayDocument
"
Must
not
be
null
"
)
;
MOZ_ASSERT
(
aDisplayDocument
!
=
this
"
Should
be
different
document
"
)
;
MOZ_ASSERT
(
!
aDisplayDocument
-
>
GetDisplayDocument
(
)
"
Display
documents
should
not
nest
"
)
;
mDisplayDocument
=
aDisplayDocument
;
mHasDisplayDocument
=
!
!
aDisplayDocument
;
}
Document
*
RequestExternalResource
(
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
ExternalResourceLoad
*
*
aPendingLoad
)
;
void
EnumerateExternalResources
(
SubDocEnumFunc
aCallback
)
;
dom
:
:
ExternalResourceMap
&
ExternalResourceMap
(
)
{
return
mExternalResourceMap
;
}
bool
IsShowing
(
)
const
{
return
mIsShowing
;
}
bool
IsVisible
(
)
const
{
return
mVisible
;
}
bool
IsVisibleConsideringAncestors
(
)
const
;
void
SetSuppressedEventListener
(
EventListener
*
aListener
)
;
EventListener
*
GetSuppressedEventListener
(
)
{
return
mSuppressedEventListener
;
}
bool
IsActive
(
)
const
{
return
mDocumentContainer
&
&
!
mRemovedFromDocShell
;
}
bool
IsCurrentActiveDocument
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
return
inner
&
&
inner
-
>
IsCurrentInnerWindow
(
)
&
&
inner
-
>
GetDoc
(
)
=
=
this
;
}
bool
ShouldLoadImages
(
)
const
{
return
IsCurrentActiveDocument
(
)
|
|
IsBeingUsedAsImage
(
)
|
|
IsStaticDocument
(
)
;
}
void
SetHasPrintCallbacks
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsStaticDocument
(
)
)
;
mHasPrintCallbacks
=
true
;
}
bool
HasPrintCallbacks
(
)
const
{
return
mHasPrintCallbacks
;
}
void
RegisterActivityObserver
(
nsISupports
*
aSupports
)
;
bool
UnregisterActivityObserver
(
nsISupports
*
aSupports
)
;
using
ActivityObserverEnumerator
=
FunctionRef
<
void
(
nsISupports
*
)
>
;
void
EnumerateActivityObservers
(
ActivityObserverEnumerator
aEnumerator
)
;
bool
HasAnimationController
(
)
{
return
!
!
mAnimationController
;
}
SMILAnimationController
*
GetAnimationController
(
)
;
PendingAnimationTracker
*
GetPendingAnimationTracker
(
)
{
return
mPendingAnimationTracker
;
}
PendingAnimationTracker
*
GetOrCreatePendingAnimationTracker
(
)
;
void
SuppressEventHandling
(
uint32_t
aIncrease
=
1
)
;
void
UnsuppressEventHandlingAndFireEvents
(
bool
aFireEvents
)
;
uint32_t
EventHandlingSuppressed
(
)
const
{
return
mEventsSuppressed
;
}
bool
IsEventHandlingEnabled
(
)
const
{
return
!
EventHandlingSuppressed
(
)
&
&
mScriptGlobalObject
;
}
bool
WouldScheduleFrameRequestCallbacks
(
)
const
{
return
mPresShell
&
&
IsEventHandlingEnabled
(
)
;
}
void
DecreaseEventSuppression
(
)
{
MOZ_ASSERT
(
mEventsSuppressed
)
;
-
-
mEventsSuppressed
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
}
bool
AreClipboardCommandsUnconditionallyEnabled
(
)
const
;
void
AddSuspendedChannelEventQueue
(
net
:
:
ChannelEventQueue
*
aQueue
)
;
bool
SuspendPostMessageEvent
(
PostMessageEvent
*
aEvent
)
;
void
FireOrClearPostMessageEvents
(
bool
aFireEvents
)
;
void
SetHasDelayedRefreshEvent
(
)
{
mHasDelayedRefreshEvent
=
true
;
}
void
SetLoadEventFiring
(
bool
aFiring
)
{
mLoadEventFiring
=
aFiring
;
}
bool
SkipLoadEventAfterClose
(
)
{
bool
skip
=
mSkipLoadEventAfterClose
;
mSkipLoadEventAfterClose
=
false
;
return
skip
;
}
void
IncrementIgnoreDestructiveWritesCounter
(
)
{
+
+
mIgnoreDestructiveWritesCounter
;
}
void
DecrementIgnoreDestructiveWritesCounter
(
)
{
-
-
mIgnoreDestructiveWritesCounter
;
}
bool
IsDNSPrefetchAllowed
(
)
const
{
return
mAllowDNSPrefetch
;
}
bool
AllowXULXBL
(
)
{
return
mAllowXULXBL
=
=
eTriTrue
?
true
:
mAllowXULXBL
=
=
eTriFalse
?
false
:
InternalAllowXULXBL
(
)
;
}
bool
SkipDTDSecurityChecks
(
)
{
return
mSkipDTDSecurityChecks
;
}
void
ForceEnableXULXBL
(
)
{
mAllowXULXBL
=
eTriTrue
;
}
void
ForceSkipDTDSecurityChecks
(
)
{
mSkipDTDSecurityChecks
=
true
;
}
Document
*
GetTemplateContentsOwner
(
)
;
bool
IsStaticDocument
(
)
const
{
return
mIsStaticDocument
;
}
already_AddRefed
<
Document
>
CreateStaticClone
(
nsIDocShell
*
aCloneContainer
nsIContentViewer
*
aContentViewer
bool
*
aOutHasInProcessPrintCallbacks
)
;
Document
*
GetOriginalDocument
(
)
const
{
MOZ_ASSERT
(
!
mOriginalDocument
|
|
!
mOriginalDocument
-
>
GetOriginalDocument
(
)
)
;
return
mOriginalDocument
;
}
void
UnlinkOriginalDocumentIfStatic
(
)
;
void
PreloadPictureOpened
(
)
{
mPreloadPictureDepth
+
+
;
}
void
PreloadPictureClosed
(
)
;
void
PreloadPictureImageSource
(
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
)
;
already_AddRefed
<
nsIURI
>
ResolvePreloadImage
(
nsIURI
*
aBaseURI
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
bool
*
aIsImgSet
)
;
void
MaybePreLoadImage
(
nsIURI
*
uri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
bool
aLinkPreload
)
;
void
PreLoadImage
(
nsIURI
*
uri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
bool
aLinkPreload
)
;
void
ForgetImagePreload
(
nsIURI
*
aURI
)
;
SheetPreloadStatus
PreloadStyle
(
nsIURI
*
aURI
const
Encoding
*
aEncoding
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
const
nsAString
&
aIntegrity
css
:
:
StylePreloadKind
)
;
RefPtr
<
StyleSheet
>
LoadChromeSheetSync
(
nsIURI
*
aURI
)
;
bool
IsDocumentRightToLeft
(
)
;
void
MaybePreconnect
(
nsIURI
*
uri
CORSMode
aCORSMode
)
;
enum
DocumentTheme
{
Doc_Theme_Uninitialized
Doc_Theme_None
Doc_Theme_Neutral
Doc_Theme_Dark
Doc_Theme_Bright
}
;
void
SetStateObject
(
nsIStructuredCloneContainer
*
scContainer
)
;
void
SetStateObjectFrom
(
Document
*
aDocument
)
{
SetStateObject
(
aDocument
-
>
mStateObjectContainer
)
;
}
DocumentTheme
GetDocumentLWTheme
(
)
;
DocumentTheme
ThreadSafeGetDocumentLWTheme
(
)
const
;
void
ResetDocumentLWTheme
(
)
{
mDocLWTheme
=
Doc_Theme_Uninitialized
;
}
enum
class
MediaDocumentKind
{
NotMedia
Video
Image
Plugin
}
;
virtual
enum
MediaDocumentKind
MediaDocumentKind
(
)
const
{
return
MediaDocumentKind
:
:
NotMedia
;
}
EventStates
GetDocumentState
(
)
const
{
return
mDocumentState
;
}
nsISupports
*
GetCurrentContentSink
(
)
;
void
SetAutoFocusElement
(
Element
*
aAutoFocusElement
)
;
void
TriggerAutoFocus
(
)
;
void
SetAutoFocusFired
(
)
;
bool
IsAutoFocusFired
(
)
;
void
SetScrollToRef
(
nsIURI
*
aDocumentURI
)
;
MOZ_CAN_RUN_SCRIPT
void
ScrollToRef
(
)
;
void
ResetScrolledToRefAlready
(
)
{
mScrolledToRefAlready
=
false
;
}
void
SetChangeScrollPosWhenScrollingToRef
(
bool
aValue
)
{
mChangeScrollPosWhenScrollingToRef
=
aValue
;
}
using
DocumentOrShadowRoot
:
:
GetElementById
;
using
DocumentOrShadowRoot
:
:
GetElementsByClassName
;
using
DocumentOrShadowRoot
:
:
GetElementsByTagName
;
using
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
;
DocumentTimeline
*
Timeline
(
)
;
LinkedList
<
DocumentTimeline
>
&
Timelines
(
)
{
return
mTimelines
;
}
SVGSVGElement
*
GetSVGRootElement
(
)
const
;
struct
FrameRequest
{
FrameRequest
(
FrameRequestCallback
&
aCallback
int32_t
aHandle
)
;
~
FrameRequest
(
)
;
bool
operator
=
=
(
int32_t
aHandle
)
const
{
return
mHandle
=
=
aHandle
;
}
bool
operator
<
(
int32_t
aHandle
)
const
{
return
mHandle
<
aHandle
;
}
RefPtr
<
FrameRequestCallback
>
mCallback
;
int32_t
mHandle
;
}
;
nsresult
ScheduleFrameRequestCallback
(
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
;
void
CancelFrameRequestCallback
(
int32_t
aHandle
)
;
bool
IsCanceledFrameRequestCallback
(
int32_t
aHandle
)
const
;
void
TakeFrameRequestCallbacks
(
nsTArray
<
FrameRequest
>
&
aCallbacks
)
;
bool
ShouldThrottleFrameRequests
(
)
const
;
bool
InUnlinkOrDeletion
(
)
{
return
mInUnlinkOrDeletion
;
}
dom
:
:
ImageTracker
*
ImageTracker
(
)
;
void
AddPlugin
(
nsIObjectLoadingContent
*
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
)
;
mPlugins
.
PutEntry
(
aPlugin
)
;
}
void
RemovePlugin
(
nsIObjectLoadingContent
*
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
)
;
mPlugins
.
RemoveEntry
(
aPlugin
)
;
}
void
GetPlugins
(
nsTArray
<
nsIObjectLoadingContent
*
>
&
aPlugins
)
;
void
AddResponsiveContent
(
HTMLImageElement
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mResponsiveContent
.
PutEntry
(
aContent
)
;
}
void
RemoveResponsiveContent
(
HTMLImageElement
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mResponsiveContent
.
RemoveEntry
(
aContent
)
;
}
void
ScheduleSVGUseElementShadowTreeUpdate
(
SVGUseElement
&
)
;
void
UnscheduleSVGUseElementShadowTreeUpdate
(
SVGUseElement
&
aElement
)
{
mSVGUseElementsNeedingShadowTreeUpdate
.
RemoveEntry
(
&
aElement
)
;
}
bool
SVGUseElementNeedsShadowTreeUpdate
(
SVGUseElement
&
aElement
)
const
{
return
mSVGUseElementsNeedingShadowTreeUpdate
.
GetEntry
(
&
aElement
)
;
}
using
ShadowRootSet
=
nsTHashtable
<
nsPtrHashKey
<
ShadowRoot
>
>
;
void
AddComposedDocShadowRoot
(
ShadowRoot
&
aShadowRoot
)
{
mComposedShadowRoots
.
PutEntry
(
&
aShadowRoot
)
;
}
void
RemoveComposedDocShadowRoot
(
ShadowRoot
&
aShadowRoot
)
{
mComposedShadowRoots
.
RemoveEntry
(
&
aShadowRoot
)
;
}
bool
IsComposedDocShadowRoot
(
ShadowRoot
&
aShadowRoot
)
{
return
mComposedShadowRoots
.
Contains
(
&
aShadowRoot
)
;
}
const
ShadowRootSet
&
ComposedShadowRoots
(
)
const
{
return
mComposedShadowRoots
;
}
void
GetConnectedShadowRoots
(
nsTArray
<
RefPtr
<
ShadowRoot
>
>
&
)
const
;
void
NotifyMediaFeatureValuesChanged
(
)
;
nsresult
GetStateObject
(
nsIVariant
*
*
aResult
)
;
nsDOMNavigationTiming
*
GetNavigationTiming
(
)
const
{
return
mTiming
;
}
void
SetNavigationTiming
(
nsDOMNavigationTiming
*
aTiming
)
;
nsContentList
*
ImageMapList
(
)
;
void
RegisterPendingLinkUpdate
(
Link
*
aLink
)
;
void
FlushPendingLinkUpdates
(
)
;
bool
HasWarnedAbout
(
DeprecatedOperations
aOperation
)
const
;
void
WarnOnceAbout
(
DeprecatedOperations
aOperation
bool
asError
=
false
const
nsTArray
<
nsString
>
&
aParams
=
nsTArray
<
nsString
>
(
)
)
const
;
#
define
DOCUMENT_WARNING
(
_op
)
e
#
#
_op
enum
DocumentWarnings
{
#
include
"
nsDocumentWarningList
.
h
"
eDocumentWarningCount
}
;
#
undef
DOCUMENT_WARNING
bool
HasWarnedAbout
(
DocumentWarnings
aWarning
)
const
;
void
WarnOnceAbout
(
DocumentWarnings
aWarning
bool
asError
=
false
const
nsTArray
<
nsString
>
&
aParams
=
nsTArray
<
nsString
>
(
)
)
const
;
enum
class
DispatchVisibilityChange
{
No
Yes
}
;
void
UpdateVisibilityState
(
DispatchVisibilityChange
=
DispatchVisibilityChange
:
:
Yes
)
;
void
PostVisibilityUpdateEvent
(
)
;
bool
IsSyntheticDocument
(
)
const
{
return
mIsSyntheticDocument
;
}
static
void
AddSizeOfNodeTree
(
nsINode
&
nsWindowSizes
&
)
;
virtual
void
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
virtual
void
DocAddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
void
ConstructUbiNode
(
void
*
storage
)
override
;
bool
MayHaveDOMMutationObservers
(
)
{
return
mMayHaveDOMMutationObservers
;
}
void
SetMayHaveDOMMutationObservers
(
)
{
mMayHaveDOMMutationObservers
=
true
;
}
bool
MayHaveAnimationObservers
(
)
{
return
mMayHaveAnimationObservers
;
}
void
SetMayHaveAnimationObservers
(
)
{
mMayHaveAnimationObservers
=
true
;
}
bool
IsInSyncOperation
(
)
{
return
mInSyncOperationCount
!
=
0
;
}
void
SetIsInSyncOperation
(
bool
aSync
)
{
if
(
aSync
)
{
+
+
mInSyncOperationCount
;
}
else
{
-
-
mInSyncOperationCount
;
}
}
bool
CreatingStaticClone
(
)
const
{
return
mCreatingStaticClone
;
}
already_AddRefed
<
Element
>
CreateHTMLElement
(
nsAtom
*
aTag
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetScopeObject
(
)
;
}
static
already_AddRefed
<
Document
>
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
;
DOMImplementation
*
GetImplementation
(
ErrorResult
&
rv
)
;
MOZ_MUST_USE
nsresult
GetURL
(
nsString
&
retval
)
const
;
MOZ_MUST_USE
nsresult
GetDocumentURI
(
nsString
&
retval
)
const
;
void
GetDocumentURIFromJS
(
nsString
&
aDocumentURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
void
GetCompatMode
(
nsString
&
retval
)
const
;
void
GetCharacterSet
(
nsAString
&
retval
)
const
;
Element
*
GetDocumentElement
(
)
const
{
return
GetRootElement
(
)
;
}
WindowContext
*
GetTopLevelWindowContext
(
)
const
;
Document
*
GetTopLevelContentDocument
(
)
;
const
Document
*
GetTopLevelContentDocument
(
)
const
;
already_AddRefed
<
nsIAppWindow
>
GetAppWindowIfToplevelChrome
(
)
const
;
already_AddRefed
<
Element
>
CreateElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
;
already_AddRefed
<
Element
>
CreateElementNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
;
already_AddRefed
<
Element
>
CreateXULElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
DocumentFragment
>
CreateDocumentFragment
(
)
const
;
already_AddRefed
<
nsTextNode
>
CreateTextNode
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
nsTextNode
>
CreateEmptyTextNode
(
)
const
;
already_AddRefed
<
Comment
>
CreateComment
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
ProcessingInstruction
>
CreateProcessingInstruction
(
const
nsAString
&
target
const
nsAString
&
data
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsINode
>
ImportNode
(
nsINode
&
aNode
bool
aDeep
ErrorResult
&
rv
)
const
;
nsINode
*
AdoptNode
(
nsINode
&
aNode
ErrorResult
&
rv
)
;
already_AddRefed
<
Event
>
CreateEvent
(
const
nsAString
&
aEventType
CallerType
aCallerType
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsRange
>
CreateRange
(
ErrorResult
&
rv
)
;
already_AddRefed
<
NodeIterator
>
CreateNodeIterator
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
;
already_AddRefed
<
TreeWalker
>
CreateTreeWalker
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
;
already_AddRefed
<
CDATASection
>
CreateCDATASection
(
const
nsAString
&
aData
ErrorResult
&
rv
)
;
already_AddRefed
<
Attr
>
CreateAttribute
(
const
nsAString
&
aName
ErrorResult
&
rv
)
;
already_AddRefed
<
Attr
>
CreateAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
ErrorResult
&
rv
)
;
void
GetInputEncoding
(
nsAString
&
aInputEncoding
)
const
;
already_AddRefed
<
Location
>
GetLocation
(
)
const
;
void
GetDomain
(
nsAString
&
aDomain
)
;
void
SetDomain
(
const
nsAString
&
aDomain
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetCookie
(
nsAString
&
aCookie
mozilla
:
:
ErrorResult
&
rv
)
;
void
SetCookie
(
const
nsAString
&
aCookie
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetReferrer
(
nsAString
&
aReferrer
)
const
;
void
GetLastModified
(
nsAString
&
aLastModified
)
const
;
void
GetReadyState
(
nsAString
&
aReadyState
)
const
;
void
GetTitle
(
nsAString
&
aTitle
)
;
void
SetTitle
(
const
nsAString
&
aTitle
ErrorResult
&
rv
)
;
void
GetDir
(
nsAString
&
aDirection
)
const
;
void
SetDir
(
const
nsAString
&
aDirection
)
;
nsIHTMLCollection
*
Images
(
)
;
nsIHTMLCollection
*
Embeds
(
)
;
nsIHTMLCollection
*
Plugins
(
)
{
return
Embeds
(
)
;
}
nsIHTMLCollection
*
Links
(
)
;
nsIHTMLCollection
*
Forms
(
)
;
nsIHTMLCollection
*
Scripts
(
)
;
already_AddRefed
<
nsContentList
>
GetElementsByName
(
const
nsAString
&
aName
)
{
return
GetFuncStringContentList
<
nsCachableElementsByNameNodeList
>
(
this
MatchNameAttribute
nullptr
UseExistingNameString
aName
)
;
}
Document
*
Open
(
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
Open
(
const
nsAString
&
aURL
const
nsAString
&
aName
const
nsAString
&
aFeatures
mozilla
:
:
ErrorResult
&
rv
)
;
void
Close
(
mozilla
:
:
ErrorResult
&
rv
)
;
void
Write
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aText
mozilla
:
:
ErrorResult
&
rv
)
;
void
Writeln
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aText
mozilla
:
:
ErrorResult
&
rv
)
;
Nullable
<
WindowProxyHolder
>
GetDefaultView
(
)
const
;
Element
*
GetActiveElement
(
)
;
nsIContent
*
GetUnretargetedFocusedContent
(
)
const
;
bool
HasFocus
(
ErrorResult
&
rv
)
const
;
void
GetDesignMode
(
nsAString
&
aDesignMode
)
;
void
SetDesignMode
(
const
nsAString
&
aDesignMode
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
rv
)
;
void
SetDesignMode
(
const
nsAString
&
aDesignMode
const
mozilla
:
:
Maybe
<
nsIPrincipal
*
>
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
rv
)
;
MOZ_CAN_RUN_SCRIPT
bool
ExecCommand
(
const
nsAString
&
aHTMLCommandName
bool
aShowUI
const
nsAString
&
aValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
QueryCommandEnabled
(
const
nsAString
&
aHTMLCommandName
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
QueryCommandIndeterm
(
const
nsAString
&
aHTMLCommandName
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
QueryCommandState
(
const
nsAString
&
aHTMLCommandName
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
QueryCommandSupported
(
const
nsAString
&
aHTMLCommandName
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
QueryCommandValue
(
const
nsAString
&
aHTMLCommandName
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
aRv
)
;
nsIHTMLCollection
*
Applets
(
)
;
nsIHTMLCollection
*
Anchors
(
)
;
TimeStamp
LastFocusTime
(
)
const
;
void
SetLastFocusTime
(
const
TimeStamp
&
aFocusTime
)
;
bool
MozSyntheticDocument
(
)
const
{
return
IsSyntheticDocument
(
)
;
}
Element
*
GetCurrentScript
(
)
;
void
ReleaseCapture
(
)
const
;
void
MozSetImageElement
(
const
nsAString
&
aImageElementId
Element
*
aElement
)
;
nsIURI
*
GetDocumentURIObject
(
)
const
;
const
char
*
GetFullscreenError
(
CallerType
)
;
bool
FullscreenEnabled
(
CallerType
aCallerType
)
{
return
!
GetFullscreenError
(
aCallerType
)
;
}
Element
*
GetTopLayerTop
(
)
;
Element
*
GetUnretargetedFullScreenElement
(
)
;
bool
Fullscreen
(
)
{
return
!
!
GetFullscreenElement
(
)
;
}
already_AddRefed
<
Promise
>
ExitFullscreen
(
ErrorResult
&
)
;
void
ExitPointerLock
(
)
{
PointerLockManager
:
:
Unlock
(
this
)
;
}
void
GetFgColor
(
nsAString
&
aFgColor
)
;
void
SetFgColor
(
const
nsAString
&
aFgColor
)
;
void
GetLinkColor
(
nsAString
&
aLinkColor
)
;
void
SetLinkColor
(
const
nsAString
&
aLinkColor
)
;
void
GetVlinkColor
(
nsAString
&
aAvlinkColor
)
;
void
SetVlinkColor
(
const
nsAString
&
aVlinkColor
)
;
void
GetAlinkColor
(
nsAString
&
aAlinkColor
)
;
void
SetAlinkColor
(
const
nsAString
&
aAlinkColor
)
;
void
GetBgColor
(
nsAString
&
aBgColor
)
;
void
SetBgColor
(
const
nsAString
&
aBgColor
)
;
void
Clear
(
)
const
{
}
void
CaptureEvents
(
)
;
void
ReleaseEvents
(
)
;
mozilla
:
:
dom
:
:
HTMLAllCollection
*
All
(
)
;
static
bool
DocumentSupportsL10n
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsWebAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsWebAnimationsEnabled
(
CallerType
aCallerType
)
;
static
bool
IsWebAnimationsGetAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
AreWebAnimationsImplicitKeyframesEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
AreWebAnimationsTimelinesEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsCallerChromeOrAddon
(
JSContext
*
aCx
JSObject
*
aObject
)
;
bool
Hidden
(
)
const
{
return
mVisibilityState
!
=
VisibilityState
:
:
Visible
;
}
dom
:
:
VisibilityState
VisibilityState
(
)
const
{
return
mVisibilityState
;
}
private
:
int32_t
mPictureInPictureChildElementCount
=
0
;
public
:
void
EnableChildElementInPictureInPictureMode
(
)
;
void
DisableChildElementInPictureInPictureMode
(
)
;
bool
HasPictureInPictureChildElement
(
)
const
;
void
GetSelectedStyleSheetSet
(
nsAString
&
aSheetSet
)
;
void
SetSelectedStyleSheetSet
(
const
nsAString
&
aSheetSet
)
;
void
GetLastStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
=
mLastStyleSheetSet
;
}
const
nsString
&
GetCurrentStyleSheetSet
(
)
const
{
return
mLastStyleSheetSet
.
IsEmpty
(
)
?
mPreferredStyleSheetSet
:
mLastStyleSheetSet
;
}
void
SetPreferredStyleSheetSet
(
const
nsAString
&
)
;
void
GetPreferredStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
=
mPreferredStyleSheetSet
;
}
DOMStringList
*
StyleSheetSets
(
)
;
void
EnableStyleSheetsForSet
(
const
nsAString
&
aSheetSet
)
;
already_AddRefed
<
nsDOMCaretPosition
>
CaretPositionFromPoint
(
float
aX
float
aY
)
;
Element
*
GetScrollingElement
(
)
;
bool
IsScrollingElement
(
Element
*
aElement
)
;
XPathExpression
*
CreateExpression
(
const
nsAString
&
aExpression
XPathNSResolver
*
aResolver
ErrorResult
&
rv
)
;
nsINode
*
CreateNSResolver
(
nsINode
&
aNodeResolver
)
;
already_AddRefed
<
XPathResult
>
Evaluate
(
JSContext
*
aCx
const
nsAString
&
aExpression
nsINode
&
aContextNode
XPathNSResolver
*
aResolver
uint16_t
aType
JS
:
:
Handle
<
JSObject
*
>
aResult
ErrorResult
&
rv
)
;
already_AddRefed
<
Touch
>
CreateTouch
(
nsGlobalWindowInner
*
aView
EventTarget
*
aTarget
int32_t
aIdentifier
int32_t
aPageX
int32_t
aPageY
int32_t
aScreenX
int32_t
aScreenY
int32_t
aClientX
int32_t
aClientY
int32_t
aRadiusX
int32_t
aRadiusY
float
aRotationAngle
float
aForce
)
;
already_AddRefed
<
TouchList
>
CreateTouchList
(
)
;
already_AddRefed
<
TouchList
>
CreateTouchList
(
Touch
&
aTouch
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
;
already_AddRefed
<
TouchList
>
CreateTouchList
(
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
;
void
SetStyleSheetChangeEventsEnabled
(
bool
aValue
)
{
mStyleSheetChangeEventsEnabled
=
aValue
;
}
bool
StyleSheetChangeEventsEnabled
(
)
const
{
return
mStyleSheetChangeEventsEnabled
;
}
void
SetShadowRootAttachedEventEnabled
(
bool
aValue
)
{
mShadowRootAttachedEventEnabled
=
aValue
;
}
bool
ShadowRootAttachedEventEnabled
(
)
const
{
return
mShadowRootAttachedEventEnabled
;
}
already_AddRefed
<
Promise
>
BlockParsing
(
Promise
&
aPromise
const
BlockParsingOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsIURI
>
GetMozDocumentURIIfNotForErrorPages
(
)
;
Promise
*
GetDocumentReadyForIdle
(
ErrorResult
&
aRv
)
;
nsIDOMXULCommandDispatcher
*
GetCommandDispatcher
(
)
;
bool
HasXULBroadcastManager
(
)
const
{
return
mXULBroadcastManager
;
}
;
void
InitializeXULBroadcastManager
(
)
;
XULBroadcastManager
*
GetXULBroadcastManager
(
)
const
{
return
mXULBroadcastManager
;
}
already_AddRefed
<
nsINode
>
GetPopupNode
(
)
;
void
SetPopupNode
(
nsINode
*
aNode
)
;
nsINode
*
GetPopupRangeParent
(
ErrorResult
&
aRv
)
;
int32_t
GetPopupRangeOffset
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsINode
>
GetTooltipNode
(
)
;
void
SetTooltipNode
(
nsINode
*
aNode
)
{
}
bool
DontWarnAboutMutationEventsAndAllowSlowDOMMutations
(
)
{
return
mDontWarnAboutMutationEventsAndAllowSlowDOMMutations
;
}
void
SetDontWarnAboutMutationEventsAndAllowSlowDOMMutations
(
bool
aDontWarnAboutMutationEventsAndAllowSlowDOMMutations
)
{
mDontWarnAboutMutationEventsAndAllowSlowDOMMutations
=
aDontWarnAboutMutationEventsAndAllowSlowDOMMutations
;
}
void
MaybeWarnAboutZoom
(
)
;
nsIHTMLCollection
*
Children
(
)
;
uint32_t
ChildElementCount
(
)
;
inline
nsHTMLDocument
*
AsHTMLDocument
(
)
;
inline
const
nsHTMLDocument
*
AsHTMLDocument
(
)
const
;
inline
SVGDocument
*
AsSVGDocument
(
)
;
inline
const
SVGDocument
*
AsSVGDocument
(
)
const
;
void
AddBlockedNodeByClassifier
(
nsINode
*
node
)
{
if
(
!
node
)
{
return
;
}
nsWeakPtr
weakNode
=
do_GetWeakReference
(
node
)
;
if
(
weakNode
)
{
mBlockedNodesByClassifier
.
AppendElement
(
weakNode
)
;
}
}
gfxUserFontSet
*
GetUserFontSet
(
)
;
void
FlushUserFontSet
(
)
;
void
MarkUserFontSetDirty
(
)
;
FontFaceSet
*
GetFonts
(
)
{
return
mFontFaceSet
;
}
FontFaceSet
*
Fonts
(
)
;
bool
DidFireDOMContentLoaded
(
)
const
{
return
mDidFireDOMContentLoaded
;
}
bool
IsSynthesized
(
)
;
void
InitUseCounters
(
)
;
void
ReportDocumentUseCounters
(
)
;
void
ReportDocumentLazyLoadCounters
(
)
;
void
SendPageUseCounters
(
)
;
void
SetUseCounter
(
UseCounter
aUseCounter
)
{
mUseCounters
[
aUseCounter
]
=
true
;
}
const
StyleUseCounters
*
GetStyleUseCounters
(
)
{
return
mStyleUseCounters
.
get
(
)
;
}
void
PropagateImageUseCounters
(
Document
*
aReferencingDocument
)
;
void
SetUserHasInteracted
(
)
;
bool
UserHasInteracted
(
)
{
return
mUserHasInteracted
;
}
void
ResetUserInteractionTimer
(
)
;
DocumentAutoplayPolicy
AutoplayPolicy
(
)
const
;
void
NotifyUserGestureActivation
(
)
;
void
ClearUserGestureActivation
(
)
;
bool
HasBeenUserGestureActivated
(
)
;
bool
HasValidTransientUserGestureActivation
(
)
;
bool
ConsumeTransientUserGestureActivation
(
)
;
BrowsingContext
*
GetBrowsingContext
(
)
const
;
bool
IsExtensionPage
(
)
const
;
bool
HasScriptsBlockedBySandbox
(
)
;
void
ReportHasScrollLinkedEffect
(
)
;
bool
HasScrollLinkedEffect
(
)
const
{
return
mHasScrollLinkedEffect
;
}
#
ifdef
DEBUG
void
AssertDocGroupMatchesKey
(
)
const
;
#
endif
DocGroup
*
GetDocGroup
(
)
const
{
#
ifdef
DEBUG
AssertDocGroupMatchesKey
(
)
;
#
endif
return
mDocGroup
;
}
DocGroup
*
GetDocGroupOrCreate
(
)
;
bool
StyleOrLayoutObservablyDependsOnParentDocumentLayout
(
)
const
{
return
GetInProcessParentDocument
(
)
&
&
GetDocGroup
(
)
=
=
GetInProcessParentDocument
(
)
-
>
GetDocGroup
(
)
;
}
void
AddIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mIntersectionObservers
.
Contains
(
aObserver
)
"
Intersection
observer
already
in
the
list
"
)
;
mIntersectionObservers
.
PutEntry
(
aObserver
)
;
}
void
RemoveIntersectionObserver
(
DOMIntersectionObserver
*
aObserver
)
{
mIntersectionObservers
.
RemoveEntry
(
aObserver
)
;
}
bool
HasIntersectionObservers
(
)
const
{
return
!
mIntersectionObservers
.
IsEmpty
(
)
;
}
void
UpdateIntersectionObservations
(
TimeStamp
aNowTime
)
;
void
ScheduleIntersectionObserverNotification
(
)
;
MOZ_CAN_RUN_SCRIPT
void
NotifyIntersectionObservers
(
)
;
DOMIntersectionObserver
*
GetLazyLoadImageObserver
(
)
{
return
mLazyLoadImageObserver
;
}
DOMIntersectionObserver
*
GetLazyLoadImageObserverViewport
(
)
{
return
mLazyLoadImageObserverViewport
;
}
DOMIntersectionObserver
&
EnsureLazyLoadImageObserver
(
)
;
DOMIntersectionObserver
&
EnsureLazyLoadImageObserverViewport
(
)
;
void
IncLazyLoadImageCount
(
)
{
+
+
mLazyLoadImageCount
;
}
void
DecLazyLoadImageCount
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mLazyLoadImageCount
>
0
)
;
-
-
mLazyLoadImageCount
;
}
void
IncLazyLoadImageStarted
(
)
{
+
+
mLazyLoadImageStarted
;
}
void
IncLazyLoadImageReachViewport
(
bool
aLoading
)
;
nsresult
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
final
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
TaskCategory
aCategory
)
const
override
;
virtual
AbstractThread
*
AbstractMainThreadFor
(
TaskCategory
aCategory
)
override
;
void
NoteScriptTrackingStatus
(
const
nsACString
&
aURL
bool
isTracking
)
;
bool
IsScriptTracking
(
JSContext
*
aCx
)
const
;
FlashClassification
DocumentFlashClassification
(
)
;
void
AddResizeObserver
(
ResizeObserver
&
)
;
void
RemoveResizeObserver
(
ResizeObserver
&
)
;
void
ScheduleResizeObserversNotification
(
)
const
;
PermissionDelegateHandler
*
GetPermissionDelegateHandler
(
)
;
public
:
DocumentL10n
*
GetL10n
(
)
;
void
OnL10nResourceContainerParsed
(
)
;
void
LocalizationLinkAdded
(
Element
*
aLinkElement
)
;
void
LocalizationLinkRemoved
(
Element
*
aLinkElement
)
;
void
OnParsingCompleted
(
)
;
void
InitialTranslationCompleted
(
bool
aL10nCached
)
;
bool
AllowsL10n
(
)
const
;
protected
:
RefPtr
<
DocumentL10n
>
mDocumentL10n
;
virtual
bool
UseWidthDeviceWidthFallbackViewport
(
)
const
;
private
:
bool
IsErrorPage
(
)
const
;
void
EnsureL10n
(
)
;
void
SetCssUseCounterBits
(
)
;
void
ParseWidthAndHeightInMetaViewport
(
const
nsAString
&
aWidthString
const
nsAString
&
aHeightString
bool
aIsAutoScale
)
;
Maybe
<
LayoutDeviceToScreenScale
>
ParseScaleInHeader
(
nsAtom
*
aHeaderField
)
;
void
ParseScalesInViewportMetaData
(
const
ViewportMetaData
&
aViewportMetaData
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
FeaturePolicy
>
GetParentFeaturePolicy
(
)
;
FlashClassification
DocumentFlashClassificationInternal
(
)
;
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCache
;
public
:
bool
IsThirdPartyForFlashClassifier
(
)
;
private
:
void
DoCacheAllKnownLangPrefs
(
)
;
void
RecomputeLanguageFromCharset
(
)
;
bool
GetSHEntryHasUserInteraction
(
)
;
public
:
void
SetMayNeedFontPrefsUpdate
(
)
{
mMayNeedFontPrefsUpdate
=
true
;
}
bool
MayNeedFontPrefsUpdate
(
)
{
return
mMayNeedFontPrefsUpdate
;
}
void
SetSHEntryHasUserInteraction
(
bool
aHasInteraction
)
;
already_AddRefed
<
nsAtom
>
GetContentLanguageAsAtomForStyle
(
)
const
;
already_AddRefed
<
nsAtom
>
GetLanguageForStyle
(
)
const
;
const
LangGroupFontPrefs
*
GetFontPrefsForLang
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
=
nullptr
)
const
;
void
ForceCacheLang
(
nsAtom
*
aLanguage
)
{
if
(
!
mLanguagesUsed
.
EnsureInserted
(
aLanguage
)
)
{
return
;
}
GetFontPrefsForLang
(
aLanguage
)
;
}
void
CacheAllKnownLangPrefs
(
)
{
if
(
!
mMayNeedFontPrefsUpdate
)
{
return
;
}
DoCacheAllKnownLangPrefs
(
)
;
}
nsINode
*
GetServoRestyleRoot
(
)
const
{
return
mServoRestyleRoot
;
}
uint32_t
GetServoRestyleRootDirtyBits
(
)
const
{
MOZ_ASSERT
(
mServoRestyleRoot
)
;
MOZ_ASSERT
(
mServoRestyleRootDirtyBits
)
;
return
mServoRestyleRootDirtyBits
;
}
void
ClearServoRestyleRoot
(
)
{
mServoRestyleRoot
=
nullptr
;
mServoRestyleRootDirtyBits
=
0
;
}
inline
void
SetServoRestyleRoot
(
nsINode
*
aRoot
uint32_t
aDirtyBits
)
;
inline
void
SetServoRestyleRootDirtyBits
(
uint32_t
aDirtyBits
)
;
bool
ShouldThrowOnDynamicMarkupInsertion
(
)
{
return
mThrowOnDynamicMarkupInsertionCounter
;
}
void
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
{
+
+
mThrowOnDynamicMarkupInsertionCounter
;
}
void
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
{
MOZ_ASSERT
(
mThrowOnDynamicMarkupInsertionCounter
)
;
-
-
mThrowOnDynamicMarkupInsertionCounter
;
}
bool
ShouldIgnoreOpens
(
)
const
{
return
mIgnoreOpensDuringUnloadCounter
;
}
void
IncrementIgnoreOpensDuringUnloadCounter
(
)
{
+
+
mIgnoreOpensDuringUnloadCounter
;
}
void
DecrementIgnoreOpensDuringUnloadCounter
(
)
{
MOZ_ASSERT
(
mIgnoreOpensDuringUnloadCounter
)
;
-
-
mIgnoreOpensDuringUnloadCounter
;
}
mozilla
:
:
dom
:
:
FeaturePolicy
*
FeaturePolicy
(
)
const
;
bool
ModuleScriptsEnabled
(
)
;
nsIContent
*
GetContentInThisDocument
(
nsIFrame
*
aFrame
)
const
;
void
ReportShadowDOMUsage
(
)
;
void
SetDocTreeHadMedia
(
)
;
dom
:
:
XPathEvaluator
*
XPathEvaluator
(
)
;
void
MaybeInitializeFinalizeFrameLoaders
(
)
;
void
SetDelayFrameLoaderInitialization
(
bool
aDelayFrameLoaderInitialization
)
{
mDelayFrameLoaderInitialization
=
aDelayFrameLoaderInitialization
;
}
void
SetPrototypeDocument
(
nsXULPrototypeDocument
*
aPrototype
)
;
nsIPermissionDelegateHandler
*
PermDelegateHandler
(
)
;
enum
class
IgnoreRFP
{
No
Yes
}
;
StylePrefersColorScheme
PrefersColorScheme
(
IgnoreRFP
=
IgnoreRFP
:
:
No
)
const
;
static
bool
UseOverlayScrollbars
(
const
Document
*
aDocument
)
;
static
bool
HasRecentlyStartedForegroundLoads
(
)
;
static
bool
AutomaticStorageAccessPermissionCanBeGranted
(
nsIPrincipal
*
aPrincipal
)
;
already_AddRefed
<
Promise
>
AddCertException
(
bool
aIsTemporary
)
;
struct
PendingFrameStaticClone
{
PendingFrameStaticClone
(
)
=
default
;
PendingFrameStaticClone
(
PendingFrameStaticClone
&
&
)
=
default
;
PendingFrameStaticClone
&
operator
=
(
PendingFrameStaticClone
&
&
)
=
default
;
~
PendingFrameStaticClone
(
)
;
RefPtr
<
nsFrameLoaderOwner
>
mElement
;
RefPtr
<
nsFrameLoader
>
mStaticCloneOf
;
}
;
void
AddPendingFrameStaticClone
(
nsFrameLoaderOwner
*
aElement
nsFrameLoader
*
aStaticCloneOf
)
;
bool
ShouldAvoidNativeTheme
(
)
const
;
protected
:
WindowContext
*
GetWindowContextForPageUseCounters
(
)
const
;
void
DoUpdateSVGUseElementShadowTrees
(
)
;
already_AddRefed
<
nsIPrincipal
>
MaybeDowngradePrincipal
(
nsIPrincipal
*
aPrincipal
)
;
void
EnsureOnloadBlocker
(
)
;
void
SendToConsole
(
nsCOMArray
<
nsISecurityConsoleMessage
>
&
aMessages
)
;
bool
IsAboutPage
(
)
const
;
bool
ContainsEMEContent
(
)
;
bool
ContainsMSEContent
(
)
;
Element
*
GetTitleElement
(
)
;
void
RecordNavigationTiming
(
ReadyState
aReadyState
)
;
dom
:
:
VisibilityState
ComputeVisibilityState
(
)
const
;
void
MaybeActiveMediaComponents
(
)
;
bool
ApplyFullscreen
(
UniquePtr
<
FullscreenRequest
>
)
;
void
RemoveDocStyleSheetsFromStyleSets
(
)
;
void
ResetStylesheetsToURI
(
nsIURI
*
aURI
)
;
void
FillStyleSet
(
)
;
void
FillStyleSetUserAndUASheets
(
)
;
void
FillStyleSetDocumentSheets
(
)
;
void
CompatibilityModeChanged
(
)
;
bool
NeedsQuirksSheet
(
)
const
{
return
mCompatMode
=
=
eCompatibility_NavQuirks
&
&
!
IsSVGDocument
(
)
;
}
void
AddContentEditableStyleSheetsToStyleSet
(
bool
aDesignMode
)
;
void
RemoveContentEditableStyleSheets
(
)
;
void
AddStyleSheetToStyleSets
(
StyleSheet
&
)
;
void
RemoveStyleSheetFromStyleSets
(
StyleSheet
&
)
;
void
NotifyStyleSheetApplicableStateChanged
(
)
;
void
EnableStyleSheetsForSetInternal
(
const
nsAString
&
aSheetSet
bool
aUpdateCSSLoader
)
;
already_AddRefed
<
nsIURI
>
GetDomainURI
(
)
;
already_AddRefed
<
nsIURI
>
CreateInheritingURIForHost
(
const
nsACString
&
aHostString
)
;
already_AddRefed
<
nsIURI
>
RegistrableDomainSuffixOfInternal
(
const
nsAString
&
aHostSuffixString
nsIURI
*
aOrigHost
)
;
void
WriteCommon
(
const
nsAString
&
aText
bool
aNewlineTerminate
mozilla
:
:
ErrorResult
&
aRv
)
;
void
WriteCommon
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aText
bool
aNewlineTerminate
mozilla
:
:
ErrorResult
&
rv
)
;
void
*
GenerateParserKey
(
void
)
;
private
:
enum
class
ExecCommandParam
:
uint8_t
{
Ignore
String
Boolean
InvertedBoolean
}
;
typedef
mozilla
:
:
EditorCommand
*
(
GetEditorCommandFunc
)
(
)
;
struct
InternalCommandData
{
const
char
*
mXULCommandName
;
mozilla
:
:
Command
mCommand
;
ExecCommandParam
mExecCommandParam
;
GetEditorCommandFunc
*
mGetEditorCommandFunc
;
InternalCommandData
(
)
:
mXULCommandName
(
nullptr
)
mCommand
(
mozilla
:
:
Command
:
:
DoNothing
)
mExecCommandParam
(
ExecCommandParam
:
:
Ignore
)
mGetEditorCommandFunc
(
nullptr
)
{
}
InternalCommandData
(
const
char
*
aXULCommandName
mozilla
:
:
Command
aCommand
ExecCommandParam
aExecCommandParam
GetEditorCommandFunc
aGetEditorCommandFunc
)
:
mXULCommandName
(
aXULCommandName
)
mCommand
(
aCommand
)
mExecCommandParam
(
aExecCommandParam
)
mGetEditorCommandFunc
(
aGetEditorCommandFunc
)
{
}
bool
IsAvailableOnlyWhenEditable
(
)
const
{
return
mCommand
!
=
mozilla
:
:
Command
:
:
Cut
&
&
mCommand
!
=
mozilla
:
:
Command
:
:
Copy
&
&
mCommand
!
=
mozilla
:
:
Command
:
:
Paste
;
}
bool
IsCutOrCopyCommand
(
)
const
{
return
mCommand
=
=
mozilla
:
:
Command
:
:
Cut
|
|
mCommand
=
=
mozilla
:
:
Command
:
:
Copy
;
}
bool
IsPasteCommand
(
)
const
{
return
mCommand
=
=
mozilla
:
:
Command
:
:
Paste
;
}
}
;
static
void
EnsureInitializeInternalCommandDataHashtable
(
)
;
static
InternalCommandData
ConvertToInternalCommand
(
const
nsAString
&
aHTMLCommandName
const
nsAString
&
aValue
=
u
"
"
_ns
nsAString
*
aAdjustedValue
=
nullptr
)
;
class
MOZ_STACK_CLASS
AutoRunningExecCommandMarker
final
{
public
:
AutoRunningExecCommandMarker
(
)
=
delete
;
explicit
AutoRunningExecCommandMarker
(
const
AutoRunningExecCommandMarker
&
)
=
delete
;
MOZ_CAN_RUN_SCRIPT
explicit
AutoRunningExecCommandMarker
(
Document
&
aDocument
)
:
mDocument
(
aDocument
)
mHasBeenRunning
(
aDocument
.
mIsRunningExecCommand
)
{
aDocument
.
mIsRunningExecCommand
=
true
;
}
~
AutoRunningExecCommandMarker
(
)
{
if
(
!
mHasBeenRunning
)
{
mDocument
.
mIsRunningExecCommand
=
false
;
}
}
private
:
Document
&
mDocument
;
bool
mHasBeenRunning
;
}
;
typedef
nsDataHashtable
<
nsStringCaseInsensitiveHashKey
InternalCommandData
>
InternalCommandDataHashtable
;
static
InternalCommandDataHashtable
*
sInternalCommandDataHashtable
;
mutable
std
:
:
bitset
<
static_cast
<
size_t
>
(
DeprecatedOperations
:
:
eDeprecatedOperationCount
)
>
mDeprecationWarnedAbout
;
mutable
std
:
:
bitset
<
eDocumentWarningCount
>
mDocWarningWarnedAbout
;
UniquePtr
<
SelectorCache
>
mSelectorCache
;
UniquePtr
<
ServoStyleSet
>
mStyleSet
;
protected
:
friend
class
nsDocumentOnStack
;
void
IncreaseStackRefCnt
(
)
{
+
+
mStackRefCnt
;
}
void
DecreaseStackRefCnt
(
)
{
if
(
-
-
mStackRefCnt
=
=
0
&
&
mNeedsReleaseAfterStackRefCntRelease
)
{
mNeedsReleaseAfterStackRefCntRelease
=
false
;
NS_RELEASE_THIS
(
)
;
}
}
nsPIDOMWindowOuter
*
GetWindowInternal
(
)
const
;
nsIScriptGlobalObject
*
GetScriptHandlingObjectInternal
(
)
const
;
bool
InternalAllowXULXBL
(
)
;
void
WillDispatchMutationEvent
(
nsINode
*
aTarget
)
;
void
MutationEventDispatched
(
nsINode
*
aTarget
)
;
friend
class
mozAutoSubtreeModified
;
virtual
Element
*
GetNameSpaceElement
(
)
override
{
return
GetRootElement
(
)
;
}
void
SetContentTypeInternal
(
const
nsACString
&
aType
)
;
nsCString
GetContentTypeInternal
(
)
const
{
return
mContentType
;
}
void
UpdateFrameRequestCallbackSchedulingState
(
PresShell
*
aOldPresShell
=
nullptr
)
;
bool
IsPotentiallyScrollable
(
HTMLBodyElement
*
aBody
)
;
void
MaybeAllowStorageForOpenerAfterUserInteraction
(
)
;
void
MaybeStoreUserInteractionAsPermission
(
)
;
static
bool
MatchNameAttribute
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
;
static
void
*
UseExistingNameString
(
nsINode
*
aRootNode
const
nsString
*
aName
)
;
void
MaybeResolveReadyForIdle
(
)
;
typedef
MozPromise
<
bool
bool
true
>
AutomaticStorageAccessPermissionGrantPromise
;
MOZ_MUST_USE
RefPtr
<
AutomaticStorageAccessPermissionGrantPromise
>
AutomaticStorageAccessPermissionCanBeGranted
(
)
;
static
void
AddToplevelLoadingDocument
(
Document
*
aDoc
)
;
static
void
RemoveToplevelLoadingDocument
(
Document
*
aDoc
)
;
static
AutoTArray
<
Document
*
8
>
*
sLoadingForegroundTopLevelContentDocument
;
friend
class
cycleCollection
;
nsCOMPtr
<
nsIReferrerInfo
>
mPreloadReferrerInfo
;
nsCOMPtr
<
nsIReferrerInfo
>
mReferrerInfo
;
nsString
mLastModified
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mOriginalURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocURI
;
nsCOMPtr
<
nsIURI
>
mDocumentBaseURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocBaseURI
;
nsCString
mBaseDomain
;
RefPtr
<
URLExtraData
>
mCachedURLData
;
nsCOMPtr
<
nsIReferrerInfo
>
mCachedReferrerInfo
;
nsWeakPtr
mDocumentLoadGroup
;
bool
mBlockAllMixedContent
;
bool
mBlockAllMixedContentPreloads
;
bool
mUpgradeInsecureRequests
;
bool
mUpgradeInsecurePreloads
;
bool
mDontWarnAboutMutationEventsAndAllowSlowDOMMutations
;
WeakPtr
<
nsDocShell
>
mDocumentContainer
;
NotNull
<
const
Encoding
*
>
mCharacterSet
;
int32_t
mCharacterSetSource
;
Document
*
mParentDocument
;
Element
*
mCachedRootElement
;
nsNodeInfoManager
*
mNodeInfoManager
;
RefPtr
<
css
:
:
Loader
>
mCSSLoader
;
RefPtr
<
css
:
:
ImageLoader
>
mStyleImageLoader
;
RefPtr
<
nsHTMLStyleSheet
>
mAttrStyleSheet
;
RefPtr
<
nsHTMLCSSStyleSheet
>
mStyleAttrStyleSheet
;
RefPtr
<
dom
:
:
ImageTracker
>
mImageTracker
;
ShadowRootSet
mComposedShadowRoots
;
using
SVGUseElementSet
=
nsTHashtable
<
nsPtrHashKey
<
SVGUseElement
>
>
;
SVGUseElementSet
mSVGUseElementsNeedingShadowTreeUpdate
;
UniquePtr
<
nsTHashtable
<
nsPtrHashKey
<
nsISupports
>
>
>
mActivityObservers
;
nsTHashtable
<
nsPtrHashKey
<
Link
>
>
mStyledLinks
;
#
ifdef
DEBUG
bool
mStyledLinksCleared
;
#
endif
static
const
size_t
kSegmentSize
=
128
;
typedef
SegmentedVector
<
nsCOMPtr
<
Link
>
kSegmentSize
InfallibleAllocPolicy
>
LinksToUpdateList
;
LinksToUpdateList
mLinksToUpdate
;
RefPtr
<
SMILAnimationController
>
mAnimationController
;
nsPropertyTable
mPropertyTable
;
nsCOMPtr
<
nsIHTMLCollection
>
mChildrenCollection
;
RefPtr
<
nsContentList
>
mImages
;
RefPtr
<
nsContentList
>
mEmbeds
;
RefPtr
<
nsContentList
>
mLinks
;
RefPtr
<
nsContentList
>
mForms
;
RefPtr
<
nsContentList
>
mScripts
;
nsCOMPtr
<
nsIHTMLCollection
>
mApplets
;
RefPtr
<
nsContentList
>
mAnchors
;
RefPtr
<
FontFaceSet
>
mFontFaceSet
;
TimeStamp
mLastFocusTime
;
EventStates
mDocumentState
;
RefPtr
<
Promise
>
mReadyForIdle
;
RefPtr
<
mozilla
:
:
dom
:
:
FeaturePolicy
>
mFeaturePolicy
;
UniquePtr
<
ResizeObserverController
>
mResizeObserverController
;
RefPtr
<
PermissionDelegateHandler
>
mPermissionDelegateHandler
;
bool
mBidiEnabled
:
1
;
bool
mMayNeedFontPrefsUpdate
:
1
;
bool
mMathMLEnabled
:
1
;
bool
mIsInitialDocumentInWindow
:
1
;
bool
mIgnoreDocGroupMismatches
:
1
;
bool
mLoadedAsData
:
1
;
bool
mMayStartLayout
:
1
;
bool
mHaveFiredTitleChange
:
1
;
bool
mIsShowing
:
1
;
bool
mVisible
:
1
;
bool
mRemovedFromDocShell
:
1
;
bool
mAllowDNSPrefetch
:
1
;
bool
mIsStaticDocument
:
1
;
bool
mCreatingStaticClone
:
1
;
bool
mHasPrintCallbacks
:
1
;
bool
mInUnlinkOrDeletion
:
1
;
bool
mHasHadScriptHandlingObject
:
1
;
bool
mIsBeingUsedAsImage
:
1
;
bool
mDocURISchemeIsChrome
:
1
;
bool
mInChromeDocShell
:
1
;
bool
mIsDevToolsDocument
:
1
;
bool
mIsSyntheticDocument
:
1
;
bool
mHasLinksToUpdateRunnable
:
1
;
bool
mFlushingPendingLinkUpdates
:
1
;
bool
mMayHaveDOMMutationObservers
:
1
;
bool
mMayHaveAnimationObservers
:
1
;
bool
mHasCSP
:
1
;
bool
mHasUnsafeEvalCSP
:
1
;
bool
mHasUnsafeInlineCSP
:
1
;
bool
mHasCSPDeliveredThroughHeader
:
1
;
bool
mBFCacheDisallowed
:
1
;
bool
mHasHadDefaultView
:
1
;
bool
mStyleSheetChangeEventsEnabled
:
1
;
bool
mShadowRootAttachedEventEnabled
:
1
;
bool
mIsSrcdocDocument
:
1
;
bool
mHasDisplayDocument
:
1
;
bool
mFontFaceSetDirty
:
1
;
bool
mDidFireDOMContentLoaded
:
1
;
bool
mHasScrollLinkedEffect
:
1
;
bool
mFrameRequestCallbacksScheduled
:
1
;
bool
mIsTopLevelContentDocument
:
1
;
bool
mIsContentDocument
:
1
;
bool
mDidCallBeginLoad
:
1
;
bool
mEncodingMenuDisabled
:
1
;
bool
mLinksEnabled
:
1
;
bool
mIsSVGGlyphsDocument
:
1
;
bool
mInDestructor
:
1
;
bool
mIsGoingAway
:
1
;
bool
mInXBLUpdate
:
1
;
bool
mNeedsReleaseAfterStackRefCntRelease
:
1
;
bool
mStyleSetFilled
:
1
;
bool
mQuirkSheetAdded
:
1
;
bool
mContentEditableSheetAdded
:
1
;
bool
mDesignModeSheetAdded
:
1
;
bool
mSSApplicableStateNotificationPending
:
1
;
bool
mMayHaveTitleElement
:
1
;
bool
mDOMLoadingSet
:
1
;
bool
mDOMInteractiveSet
:
1
;
bool
mDOMCompleteSet
:
1
;
bool
mAutoFocusFired
:
1
;
bool
mScrolledToRefAlready
:
1
;
bool
mChangeScrollPosWhenScrollingToRef
:
1
;
bool
mDelayFrameLoaderInitialization
:
1
;
bool
mSynchronousDOMContentLoaded
:
1
;
bool
mMaybeServiceWorkerControlled
:
1
;
bool
mAllowZoom
:
1
;
bool
mValidScaleFloat
:
1
;
bool
mValidMinScale
:
1
;
bool
mValidMaxScale
:
1
;
bool
mWidthStrEmpty
:
1
;
bool
mParserAborted
:
1
;
bool
mReportedDocumentUseCounters
:
1
;
bool
mHasReportedShadowDOMUsage
:
1
;
bool
mHasDelayedRefreshEvent
:
1
;
bool
mLoadEventFiring
:
1
;
bool
mSkipLoadEventAfterClose
:
1
;
bool
mDisableCookieAccess
:
1
;
bool
mDisableDocWrite
:
1
;
bool
mTooDeepWriteRecursion
:
1
;
bool
mPendingMaybeEditingStateChanged
:
1
;
bool
mHasBeenEditable
:
1
;
bool
mHasWarnedAboutZoom
:
1
;
bool
mIsRunningExecCommand
:
1
;
bool
mSetCompleteAfterDOMContentLoaded
:
1
;
uint8_t
mPendingFullscreenRequests
;
uint8_t
mXMLDeclarationBits
;
uint32_t
mOnloadBlockCount
;
uint32_t
mAsyncOnloadBlockCount
;
uint32_t
mWriteLevel
;
uint32_t
mLazyLoadImageCount
;
uint32_t
mLazyLoadImageStarted
;
uint32_t
mLazyLoadImageReachViewportLoading
;
uint32_t
mLazyLoadImageReachViewportLoaded
;
uint32_t
mContentEditableCount
;
EditingState
mEditingState
;
nsCompatibility
mCompatMode
;
ReadyState
mReadyState
;
bool
mAncestorIsLoading
;
dom
:
:
VisibilityState
mVisibilityState
;
enum
Type
{
eUnknown
eHTML
eXHTML
eGenericXML
eSVG
}
;
Type
mType
;
uint8_t
mDefaultElementType
;
enum
Tri
{
eTriUnset
=
0
eTriFalse
eTriTrue
}
;
Tri
mAllowXULXBL
;
bool
mSkipDTDSecurityChecks
;
nsCOMPtr
<
nsIScriptGlobalObject
>
mScriptGlobalObject
;
RefPtr
<
Document
>
mOriginalDocument
;
uint32_t
mBidiOptions
;
uint32_t
mSandboxFlags
;
Maybe
<
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
>
mEmbedderPolicy
;
nsCString
mContentLanguage
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
mCSP
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
mPreloadCSP
;
private
:
nsCString
mContentType
;
protected
:
nsCOMPtr
<
nsISupports
>
mSecurityInfo
;
nsCOMPtr
<
nsIChannel
>
mFailedChannel
;
uint32_t
mPartID
;
uint32_t
mMarkedCCGeneration
;
PresShell
*
mPresShell
;
nsCOMArray
<
nsINode
>
mSubtreeModifiedTargets
;
uint32_t
mSubtreeModifiedDepth
;
nsRefPtrHashtable
<
nsURIHashKey
imgIRequest
>
mPreloadingImages
;
nsDataHashtable
<
nsURIHashKey
bool
>
mPreloadedPreconnects
;
uint32_t
mPreloadPictureDepth
;
nsString
mPreloadPictureFoundSource
;
RefPtr
<
Document
>
mDisplayDocument
;
uint32_t
mEventsSuppressed
;
nsTArray
<
RefPtr
<
net
:
:
ChannelEventQueue
>
>
mSuspendedQueues
;
nsTArray
<
RefPtr
<
PostMessageEvent
>
>
mSuspendedPostMessageEvents
;
RefPtr
<
EventListener
>
mSuppressedEventListener
;
uint32_t
mIgnoreDestructiveWritesCounter
;
int32_t
mFrameRequestCallbackCounter
;
uint32_t
mStaticCloneCount
;
WeakPtr
<
Document
>
mLatestStaticClone
;
nsTArray
<
nsWeakPtr
>
mBlockedNodesByClassifier
;
nsPIDOMWindowInner
*
mWindow
;
nsCOMPtr
<
nsIDocumentEncoder
>
mCachedEncoder
;
nsTArray
<
FrameRequest
>
mFrameRequestCallbacks
;
HashSet
<
int32_t
>
mCanceledFrameRequestCallbacks
;
nsIBFCacheEntry
*
mBFCacheEntry
;
nsString
mBaseTarget
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
mStateObjectContainer
;
nsCOMPtr
<
nsIVariant
>
mStateObjectCached
;
uint32_t
mInSyncOperationCount
;
UniquePtr
<
dom
:
:
XPathEvaluator
>
mXPathEvaluator
;
nsTArray
<
RefPtr
<
AnonymousContent
>
>
mAnonymousContents
;
uint32_t
mBlockDOMContentLoaded
;
LinkedList
<
MediaQueryList
>
mDOMMediaQueryLists
;
nsTObserverArray
<
nsIDocumentObserver
*
>
mObservers
;
UseCounters
mUseCounters
;
UseCounters
mChildDocumentUseCounters
;
UniquePtr
<
StyleUseCounters
>
mStyleUseCounters
;
bool
mUseCountersInitialized
:
1
;
bool
mShouldReportUseCounters
:
1
;
bool
mShouldSendPageUseCounters
:
1
;
bool
mUserHasInteracted
;
bool
mHasUserInteractionTimerScheduled
;
TimeStamp
mPageUnloadingEventTimeStamp
;
RefPtr
<
DocGroup
>
mDocGroup
;
RefPtr
<
nsCommandManager
>
mMidasCommandManager
;
nsTHashtable
<
nsCStringHashKey
>
mTrackingScripts
;
nsCOMPtr
<
nsIParser
>
mParser
;
RefPtr
<
nsXULPrototypeDocument
>
mPrototypeDocument
;
nsrefcnt
mStackRefCnt
;
nsWeakPtr
mWeakSink
;
uint32_t
mUpdateNestLevel
;
uint32_t
mHttpsOnlyStatus
;
enum
ViewportType
:
uint8_t
{
DisplayWidthHeight
Specified
Unknown
}
;
ViewportType
mViewportType
;
ViewportFitType
mViewportFit
;
PLDHashTable
*
mSubDocuments
;
DocHeaderData
*
mHeaderData
;
FlashClassification
mFlashClassification
;
Maybe
<
bool
>
mIsThirdPartyForFlashClassifier
;
nsRevocableEventPtr
<
nsRunnableMethod
<
Document
void
false
>
>
mPendingTitleChangeEvent
;
RefPtr
<
nsDOMNavigationTiming
>
mTiming
;
TimeStamp
mLoadingTimeStamp
;
nsWeakPtr
mAutoFocusElement
;
nsCString
mScrollToRef
;
nsWeakPtr
mScopeObject
;
nsTHashtable
<
nsPtrHashKey
<
DOMIntersectionObserver
>
>
mIntersectionObservers
;
RefPtr
<
DOMIntersectionObserver
>
mLazyLoadImageObserver
;
RefPtr
<
DOMIntersectionObserver
>
mLazyLoadImageObserverViewport
;
nsTArray
<
nsWeakPtr
>
mTopLayer
;
nsWeakPtr
mFullscreenRoot
;
RefPtr
<
DOMImplementation
>
mDOMImplementation
;
RefPtr
<
nsContentList
>
mImageMaps
;
nsTHashtable
<
nsPtrHashKey
<
HTMLImageElement
>
>
mResponsiveContent
;
nsTHashtable
<
nsPtrHashKey
<
nsIObjectLoadingContent
>
>
mPlugins
;
RefPtr
<
DocumentTimeline
>
mDocumentTimeline
;
LinkedList
<
DocumentTimeline
>
mTimelines
;
RefPtr
<
dom
:
:
ScriptLoader
>
mScriptLoader
;
RefPtr
<
PendingAnimationTracker
>
mPendingAnimationTracker
;
RefPtr
<
Document
>
mTemplateContentsOwner
;
dom
:
:
ExternalResourceMap
mExternalResourceMap
;
RefPtr
<
Promise
>
mOrientationPendingPromise
;
nsTArray
<
RefPtr
<
nsFrameLoader
>
>
mInitializableFrameLoaders
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mFrameLoaderFinalizers
;
RefPtr
<
nsRunnableMethod
<
Document
>
>
mFrameLoaderRunner
;
nsTArray
<
PendingFrameStaticClone
>
mPendingFrameStaticClones
;
nsCOMPtr
<
nsILayoutHistoryState
>
mLayoutHistoryState
;
struct
MetaViewportElementAndData
;
nsTArray
<
MetaViewportElementAndData
>
mMetaViewports
;
LayoutDeviceToScreenScale
mScaleMinFloat
;
LayoutDeviceToScreenScale
mScaleMaxFloat
;
LayoutDeviceToScreenScale
mScaleFloat
;
CSSToLayoutDeviceScale
mPixelRatio
;
CSSCoord
mMinWidth
;
CSSCoord
mMaxWidth
;
CSSCoord
mMinHeight
;
CSSCoord
mMaxHeight
;
RefPtr
<
EventListenerManager
>
mListenerManager
;
nsCOMPtr
<
nsIRequest
>
mOnloadBlocker
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
mAdditionalSheets
[
AdditionalSheetTypeCount
]
;
nsString
mLastStyleSheetSet
;
nsString
mPreferredStyleSheetSet
;
RefPtr
<
DOMStyleSheetSetList
>
mStyleSheetSetList
;
nsTHashtable
<
nsPtrHashKey
<
SVGElement
>
>
mLazySVGPresElements
;
nsTHashtable
<
nsRefPtrHashKey
<
nsAtom
>
>
mLanguagesUsed
;
RefPtr
<
nsAtom
>
mLanguageFromCharset
;
nsCOMPtr
<
nsINode
>
mServoRestyleRoot
;
uint32_t
mServoRestyleRootDirtyBits
;
uint32_t
mThrowOnDynamicMarkupInsertionCounter
;
uint32_t
mIgnoreOpensDuringUnloadCounter
;
nsCOMPtr
<
nsIDOMXULCommandDispatcher
>
mCommandDispatcher
;
RefPtr
<
XULBroadcastManager
>
mXULBroadcastManager
;
RefPtr
<
XULPersist
>
mXULPersist
;
RefPtr
<
ChromeObserver
>
mChromeObserver
;
RefPtr
<
HTMLAllCollection
>
mAll
;
DocumentTheme
mDocLWTheme
;
float
mSavedResolution
;
float
mSavedResolutionBeforeMVM
;
nsCOMPtr
<
nsICookieJarSettings
>
mCookieJarSettings
;
bool
mHasStoragePermission
;
int32_t
mGeneration
;
int32_t
mCachedTabSizeGeneration
;
nsTabSizes
mCachedTabSizes
;
nsCOMPtr
<
nsIPrincipal
>
mPartitionedPrincipal
;
mutable
nsCOMPtr
<
nsIPrincipal
>
mActiveStoragePrincipal
;
int32_t
mNextFormNumber
;
int32_t
mNextControlNumber
;
PreloadService
mPreloadService
;
void
AccumulateJSTelemetry
(
)
;
void
AccumulatePageLoadTelemetry
(
)
;
public
:
JS
:
:
ExpandoAndGeneration
mExpandoAndGeneration
;
bool
HasPendingInitialTranslation
(
)
;
nsRefPtrHashtable
<
nsRefPtrHashKey
<
Element
>
nsXULPrototypeElement
>
mL10nProtoElements
;
void
TraceProtos
(
JSTracer
*
aTrc
)
;
float
GetSavedResolutionBeforeMVM
(
)
{
return
mSavedResolutionBeforeMVM
;
}
void
SetSavedResolutionBeforeMVM
(
float
aResolution
)
{
mSavedResolutionBeforeMVM
=
aResolution
;
}
void
LoadEventFired
(
)
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Document
NS_IDOCUMENT_IID
)
class
MOZ_STACK_CLASS
mozAutoSubtreeModified
{
public
:
mozAutoSubtreeModified
(
Document
*
aSubtreeOwner
nsINode
*
aTarget
)
{
UpdateTarget
(
aSubtreeOwner
aTarget
)
;
}
~
mozAutoSubtreeModified
(
)
{
UpdateTarget
(
nullptr
nullptr
)
;
}
void
UpdateTarget
(
Document
*
aSubtreeOwner
nsINode
*
aTarget
)
{
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
MutationEventDispatched
(
mTarget
)
;
}
mTarget
=
aTarget
;
mSubtreeOwner
=
aSubtreeOwner
;
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
WillDispatchMutationEvent
(
mTarget
)
;
}
}
private
:
nsCOMPtr
<
nsINode
>
mTarget
;
RefPtr
<
Document
>
mSubtreeOwner
;
}
;
enum
class
SyncOperationBehavior
{
eSuspendInput
eAllowInput
}
;
class
MOZ_STACK_CLASS
nsAutoSyncOperation
{
public
:
explicit
nsAutoSyncOperation
(
Document
*
aDocument
SyncOperationBehavior
aSyncBehavior
)
;
~
nsAutoSyncOperation
(
)
;
private
:
nsTArray
<
RefPtr
<
Document
>
>
mDocuments
;
uint32_t
mMicroTaskLevel
;
const
SyncOperationBehavior
mSyncBehavior
;
RefPtr
<
BrowsingContext
>
mBrowsingContext
;
}
;
class
MOZ_RAII
AutoSetThrowOnDynamicMarkupInsertionCounter
final
{
public
:
explicit
AutoSetThrowOnDynamicMarkupInsertionCounter
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
mDocument
-
>
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
~
AutoSetThrowOnDynamicMarkupInsertionCounter
(
)
{
mDocument
-
>
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
private
:
Document
*
mDocument
;
}
;
class
MOZ_RAII
IgnoreOpensDuringUnload
final
{
public
:
explicit
IgnoreOpensDuringUnload
(
Document
*
aDoc
)
:
mDoc
(
aDoc
)
{
mDoc
-
>
IncrementIgnoreOpensDuringUnloadCounter
(
)
;
}
~
IgnoreOpensDuringUnload
(
)
{
mDoc
-
>
DecrementIgnoreOpensDuringUnloadCounter
(
)
;
}
private
:
Document
*
mDoc
;
}
;
bool
IsInActiveTab
(
Document
*
aDoc
)
;
}
}
nsresult
NS_NewHTMLDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
)
;
nsresult
NS_NewXMLDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
bool
aIsPlainDocument
=
false
)
;
nsresult
NS_NewSVGDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
nsresult
NS_NewImageDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
nsresult
NS_NewVideoDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
enum
DocumentFlavor
{
DocumentFlavorLegacyGuess
DocumentFlavorHTML
DocumentFlavorSVG
DocumentFlavorXML
DocumentFlavorPlain
}
;
nsresult
NS_NewDOMDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
mozilla
:
:
dom
:
:
DocumentType
*
aDoctype
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
bool
aLoadedAsData
nsIGlobalObject
*
aEventObject
DocumentFlavor
aFlavor
)
;
nsresult
NS_NewPluginDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aInstancePtrResult
)
;
inline
mozilla
:
:
dom
:
:
Document
*
nsINode
:
:
GetOwnerDocument
(
)
const
{
mozilla
:
:
dom
:
:
Document
*
ownerDoc
=
OwnerDoc
(
)
;
return
ownerDoc
!
=
this
?
ownerDoc
:
nullptr
;
}
inline
nsINode
*
nsINode
:
:
OwnerDocAsNode
(
)
const
{
return
OwnerDoc
(
)
;
}
inline
mozilla
:
:
dom
:
:
Document
*
nsINode
:
:
AsDocument
(
)
{
MOZ_ASSERT
(
IsDocument
(
)
)
;
return
static_cast
<
mozilla
:
:
dom
:
:
Document
*
>
(
this
)
;
}
inline
const
mozilla
:
:
dom
:
:
Document
*
nsINode
:
:
AsDocument
(
)
const
{
MOZ_ASSERT
(
IsDocument
(
)
)
;
return
static_cast
<
const
mozilla
:
:
dom
:
:
Document
*
>
(
this
)
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
dom
:
:
Document
*
aDoc
)
{
return
static_cast
<
nsINode
*
>
(
aDoc
)
;
}
#
endif
