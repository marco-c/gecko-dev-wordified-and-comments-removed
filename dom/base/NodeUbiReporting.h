#
ifndef
dom_NodeUbiReporting_h
#
define
dom_NodeUbiReporting_h
#
include
"
nsINode
.
h
"
#
include
"
js
/
UbiNode
.
h
"
using
mozilla
:
:
dom
:
:
Attr
;
namespace
JS
{
namespace
ubi
{
template
<
>
class
Concrete
<
nsINode
>
:
public
Base
{
protected
:
explicit
Concrete
(
nsINode
*
ptr
)
:
Base
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
nsINode
*
ptr
)
;
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
js
:
:
UniquePtr
<
EdgeRange
>
edges
(
JSContext
*
cx
bool
wantNames
)
const
override
;
nsINode
&
get
(
)
const
{
return
*
static_cast
<
nsINode
*
>
(
ptr
)
;
}
CoarseType
coarseType
(
)
const
final
{
return
CoarseType
:
:
Other
;
}
}
;
template
<
>
class
Concrete
<
nsIContent
>
:
public
Concrete
<
nsINode
>
{
protected
:
explicit
Concrete
(
nsIContent
*
ptr
)
:
Concrete
<
nsINode
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
nsIContent
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
;
static
const
char16_t
concreteTypeName
[
]
;
}
;
template
<
>
class
Concrete
<
nsIDocument
>
:
public
Concrete
<
nsINode
>
{
protected
:
explicit
Concrete
(
nsIDocument
*
ptr
)
:
Concrete
<
nsINode
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
nsIDocument
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
Size
size
(
mozilla
:
:
MallocSizeOf
mallocSizeOf
)
const
override
;
nsIDocument
&
getDoc
(
)
const
{
return
*
static_cast
<
nsIDocument
*
>
(
ptr
)
;
}
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
;
static
const
char16_t
concreteTypeName
[
]
;
}
;
template
<
>
class
Concrete
<
Attr
>
:
public
Concrete
<
nsINode
>
{
protected
:
explicit
Concrete
(
Attr
*
ptr
)
:
Concrete
<
nsINode
>
(
ptr
)
{
}
public
:
static
void
construct
(
void
*
storage
Attr
*
ptr
)
{
new
(
storage
)
Concrete
(
ptr
)
;
}
const
char16_t
*
typeName
(
)
const
override
{
return
concreteTypeName
;
}
;
static
const
char16_t
concreteTypeName
[
]
;
}
;
}
}
#
endif
