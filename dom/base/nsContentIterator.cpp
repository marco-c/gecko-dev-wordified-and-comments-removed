#
include
"
nsISupports
.
h
"
#
include
"
nsIDOMNodeList
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
static
nsINode
*
NodeToParentOffset
(
nsINode
*
aNode
int32_t
*
aOffset
)
{
*
aOffset
=
0
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
parent
)
{
*
aOffset
=
parent
-
>
IndexOf
(
aNode
)
;
NS_WARN_IF
(
*
aOffset
<
0
)
;
}
return
parent
;
}
static
bool
NodeIsInTraversalRange
(
nsINode
*
aNode
bool
aIsPreMode
nsINode
*
aStartNode
int32_t
aStartOffset
nsINode
*
aEndNode
int32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aStartNode
)
|
|
NS_WARN_IF
(
!
aEndNode
)
|
|
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
if
(
aNode
=
=
aStartNode
|
|
aNode
=
=
aEndNode
)
{
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
)
{
return
true
;
}
if
(
!
aNode
-
>
HasChildren
(
)
)
{
MOZ_ASSERT
(
aNode
!
=
aStartNode
|
|
!
aStartOffset
"
aStartNode
doesn
'
t
have
children
and
not
a
data
node
"
"
aStartOffset
should
be
0
"
)
;
MOZ_ASSERT
(
aNode
!
=
aEndNode
|
|
!
aEndOffset
"
aStartNode
doesn
'
t
have
children
and
not
a
data
node
"
"
aStartOffset
should
be
0
"
)
;
return
true
;
}
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
return
false
;
}
int32_t
indx
=
parent
-
>
IndexOf
(
aNode
)
;
NS_WARN_IF
(
indx
=
=
-
1
)
;
if
(
!
aIsPreMode
)
{
+
+
indx
;
}
return
nsContentUtils
:
:
ComparePoints
(
aStartNode
aStartOffset
parent
indx
)
<
=
0
&
&
nsContentUtils
:
:
ComparePoints
(
aEndNode
aEndOffset
parent
indx
)
>
=
0
;
}
class
nsContentIterator
:
public
nsIContentIterator
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsContentIterator
)
explicit
nsContentIterator
(
bool
aPre
)
;
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
;
virtual
nsresult
Init
(
nsIDOMRange
*
aRange
)
override
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsINode
*
GetCurrentNode
(
)
override
;
virtual
bool
IsDone
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
protected
:
virtual
~
nsContentIterator
(
)
;
nsINode
*
GetDeepFirstChild
(
nsINode
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsIContent
*
GetDeepFirstChild
(
nsIContent
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsINode
*
GetDeepLastChild
(
nsINode
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsIContent
*
GetDeepLastChild
(
nsIContent
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsIContent
*
GetNextSibling
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsIContent
*
GetPrevSibling
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsINode
*
NextNode
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsINode
*
PrevNode
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
=
nullptr
)
;
nsresult
RebuildIndexStack
(
)
;
void
MakeEmpty
(
)
;
virtual
void
LastRelease
(
)
;
nsCOMPtr
<
nsINode
>
mCurNode
;
nsCOMPtr
<
nsINode
>
mFirst
;
nsCOMPtr
<
nsINode
>
mLast
;
nsCOMPtr
<
nsINode
>
mCommonParent
;
nsAutoTArray
<
int32_t
8
>
mIndexes
;
int32_t
mCachedIndex
;
bool
mIsDone
;
bool
mPre
;
private
:
nsContentIterator
(
const
nsContentIterator
&
)
;
nsContentIterator
&
operator
=
(
const
nsContentIterator
&
)
;
}
;
already_AddRefed
<
nsIContentIterator
>
NS_NewContentIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentIterator
(
false
)
;
return
iter
.
forget
(
)
;
}
already_AddRefed
<
nsIContentIterator
>
NS_NewPreContentIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentIterator
(
true
)
;
return
iter
.
forget
(
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsContentIterator
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsContentIterator
LastRelease
(
)
)
NS_INTERFACE_MAP_BEGIN
(
nsContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsContentIterator
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsContentIterator
mCurNode
mFirst
mLast
mCommonParent
)
void
nsContentIterator
:
:
LastRelease
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mCommonParent
=
nullptr
;
}
nsContentIterator
:
:
nsContentIterator
(
bool
aPre
)
:
mCachedIndex
(
0
)
mIsDone
(
false
)
mPre
(
aPre
)
{
}
nsContentIterator
:
:
~
nsContentIterator
(
)
{
}
nsresult
nsContentIterator
:
:
Init
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
mIsDone
=
false
;
mIndexes
.
Clear
(
)
;
if
(
mPre
)
{
mFirst
=
aRoot
;
mLast
=
GetDeepLastChild
(
aRoot
)
;
NS_WARN_IF
(
!
mLast
)
;
}
else
{
mFirst
=
GetDeepFirstChild
(
aRoot
)
;
NS_WARN_IF
(
!
mFirst
)
;
mLast
=
aRoot
;
}
mCommonParent
=
aRoot
;
mCurNode
=
mFirst
;
RebuildIndexStack
(
)
;
return
NS_OK
;
}
nsresult
nsContentIterator
:
:
Init
(
nsIDOMRange
*
aDOMRange
)
{
if
(
NS_WARN_IF
(
!
aDOMRange
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsRange
*
range
=
static_cast
<
nsRange
*
>
(
aDOMRange
)
;
mIsDone
=
false
;
mCommonParent
=
range
-
>
GetCommonAncestor
(
)
;
if
(
NS_WARN_IF
(
!
mCommonParent
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
startIndx
=
range
-
>
StartOffset
(
)
;
NS_WARN_IF
(
startIndx
<
0
)
;
nsINode
*
startNode
=
range
-
>
GetStartParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
endIndx
=
range
-
>
EndOffset
(
)
;
NS_WARN_IF
(
endIndx
<
0
)
;
nsINode
*
endNode
=
range
-
>
GetEndParent
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
startIsData
=
startNode
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
;
if
(
startNode
=
=
endNode
)
{
if
(
!
startIsData
&
&
startIndx
=
=
endIndx
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
if
(
startIsData
)
{
mFirst
=
startNode
-
>
AsContent
(
)
;
mLast
=
mFirst
;
mCurNode
=
mFirst
;
nsresult
rv
=
RebuildIndexStack
(
)
;
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
NS_OK
;
}
}
nsIContent
*
cChild
=
nullptr
;
if
(
!
startIsData
&
&
startNode
-
>
HasChildren
(
)
)
{
cChild
=
startNode
-
>
GetChildAt
(
startIndx
)
;
NS_WARN_IF
(
!
cChild
)
;
}
if
(
!
cChild
)
{
if
(
mPre
)
{
if
(
!
startIsData
&
&
startIndx
)
{
mFirst
=
GetNextSibling
(
startNode
)
;
NS_WARN_IF
(
!
mFirst
)
;
if
(
mFirst
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mFirst
mPre
startNode
startIndx
endNode
endIndx
)
)
)
{
mFirst
=
nullptr
;
}
}
else
{
mFirst
=
startNode
-
>
AsContent
(
)
;
}
}
else
{
if
(
NS_WARN_IF
(
!
startNode
-
>
IsContent
(
)
)
)
{
mFirst
=
nullptr
;
}
else
{
mFirst
=
startNode
-
>
AsContent
(
)
;
}
}
}
else
{
if
(
mPre
)
{
mFirst
=
cChild
;
}
else
{
mFirst
=
GetDeepFirstChild
(
cChild
)
;
NS_WARN_IF
(
!
mFirst
)
;
if
(
mFirst
&
&
!
NodeIsInTraversalRange
(
mFirst
mPre
startNode
startIndx
endNode
endIndx
)
)
{
mFirst
=
nullptr
;
}
}
}
bool
endIsData
=
endNode
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
;
if
(
endIsData
|
|
!
endNode
-
>
HasChildren
(
)
|
|
endIndx
=
=
0
)
{
if
(
mPre
)
{
if
(
NS_WARN_IF
(
!
endNode
-
>
IsContent
(
)
)
)
{
mLast
=
nullptr
;
}
else
{
if
(
!
endIsData
&
&
!
endNode
-
>
HasChildren
(
)
&
&
!
endIndx
)
{
mLast
=
GetPrevSibling
(
endNode
)
;
NS_WARN_IF
(
!
mLast
)
;
if
(
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mLast
mPre
startNode
startIndx
endNode
endIndx
)
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
endNode
-
>
AsContent
(
)
;
}
}
}
else
{
if
(
!
endIsData
)
{
mLast
=
GetPrevSibling
(
endNode
)
;
NS_WARN_IF
(
!
mLast
)
;
if
(
!
NodeIsInTraversalRange
(
mLast
mPre
startNode
startIndx
endNode
endIndx
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
endNode
-
>
AsContent
(
)
;
}
}
}
else
{
int32_t
indx
=
endIndx
;
cChild
=
endNode
-
>
GetChildAt
(
-
-
indx
)
;
if
(
NS_WARN_IF
(
!
cChild
)
)
{
NS_NOTREACHED
(
"
nsContentIterator
:
:
nsContentIterator
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mPre
)
{
mLast
=
GetDeepLastChild
(
cChild
)
;
NS_WARN_IF
(
!
mLast
)
;
if
(
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mLast
mPre
startNode
startIndx
endNode
endIndx
)
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
cChild
;
}
}
if
(
!
mFirst
|
|
!
mLast
)
{
mFirst
=
nullptr
;
mLast
=
nullptr
;
}
mCurNode
=
mFirst
;
mIsDone
=
!
mCurNode
;
if
(
!
mCurNode
)
{
mIndexes
.
Clear
(
)
;
}
else
{
nsresult
rv
=
RebuildIndexStack
(
)
;
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
return
NS_OK
;
}
nsresult
nsContentIterator
:
:
RebuildIndexStack
(
)
{
nsINode
*
parent
;
nsINode
*
current
;
mIndexes
.
Clear
(
)
;
current
=
mCurNode
;
if
(
!
current
)
{
return
NS_OK
;
}
while
(
current
!
=
mCommonParent
)
{
parent
=
current
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
mIndexes
.
InsertElementAt
(
0
parent
-
>
IndexOf
(
current
)
)
;
current
=
parent
;
}
return
NS_OK
;
}
void
nsContentIterator
:
:
MakeEmpty
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mCommonParent
=
nullptr
;
mIsDone
=
true
;
mIndexes
.
Clear
(
)
;
}
nsINode
*
nsContentIterator
:
:
GetDeepFirstChild
(
nsINode
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
if
(
aIndexes
)
{
aIndexes
-
>
AppendElement
(
0
)
;
}
return
GetDeepFirstChild
(
aRoot
-
>
GetFirstChild
(
)
aIndexes
)
;
}
nsIContent
*
nsContentIterator
:
:
GetDeepFirstChild
(
nsIContent
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
nsIContent
*
child
=
node
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
aIndexes
)
{
aIndexes
-
>
AppendElement
(
0
)
;
}
node
=
child
;
child
=
node
-
>
GetFirstChild
(
)
;
}
return
node
;
}
nsINode
*
nsContentIterator
:
:
GetDeepLastChild
(
nsINode
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
if
(
aIndexes
)
{
aIndexes
-
>
AppendElement
(
aRoot
-
>
GetChildCount
(
)
-
1
)
;
}
return
GetDeepLastChild
(
aRoot
-
>
GetLastChild
(
)
aIndexes
)
;
}
nsIContent
*
nsContentIterator
:
:
GetDeepLastChild
(
nsIContent
*
aRoot
nsTArray
<
int32_t
>
*
aIndexes
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
int32_t
numChildren
=
node
-
>
GetChildCount
(
)
;
while
(
numChildren
)
{
nsIContent
*
child
=
node
-
>
GetChildAt
(
-
-
numChildren
)
;
if
(
aIndexes
)
{
aIndexes
-
>
AppendElement
(
numChildren
)
;
}
numChildren
=
child
-
>
GetChildCount
(
)
;
node
=
child
;
}
return
node
;
}
nsIContent
*
nsContentIterator
:
:
GetNextSibling
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
int32_t
indx
=
0
;
NS_ASSERTION
(
!
aIndexes
|
|
!
aIndexes
-
>
IsEmpty
(
)
"
ContentIterator
stack
underflow
"
)
;
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
indx
=
(
*
aIndexes
)
[
aIndexes
-
>
Length
(
)
-
1
]
;
}
else
{
indx
=
mCachedIndex
;
}
NS_WARN_IF
(
indx
<
0
)
;
nsIContent
*
sib
=
parent
-
>
GetChildAt
(
indx
)
;
if
(
sib
!
=
aNode
)
{
indx
=
parent
-
>
IndexOf
(
aNode
)
;
NS_WARN_IF
(
indx
<
0
)
;
}
if
(
(
sib
=
parent
-
>
GetChildAt
(
+
+
indx
)
)
)
{
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
aIndexes
-
>
ElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
=
indx
;
}
else
{
mCachedIndex
=
indx
;
}
}
else
{
if
(
parent
!
=
mCommonParent
)
{
if
(
aIndexes
)
{
if
(
aIndexes
-
>
Length
(
)
>
1
)
{
aIndexes
-
>
RemoveElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
;
}
}
}
sib
=
GetNextSibling
(
parent
aIndexes
)
;
}
return
sib
;
}
nsIContent
*
nsContentIterator
:
:
GetPrevSibling
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
int32_t
indx
=
0
;
NS_ASSERTION
(
!
aIndexes
|
|
!
aIndexes
-
>
IsEmpty
(
)
"
ContentIterator
stack
underflow
"
)
;
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
indx
=
(
*
aIndexes
)
[
aIndexes
-
>
Length
(
)
-
1
]
;
}
else
{
indx
=
mCachedIndex
;
}
nsIContent
*
sib
=
parent
-
>
GetChildAt
(
indx
)
;
if
(
sib
!
=
aNode
)
{
indx
=
parent
-
>
IndexOf
(
aNode
)
;
NS_WARN_IF
(
indx
<
0
)
;
}
if
(
indx
>
0
&
&
(
sib
=
parent
-
>
GetChildAt
(
-
-
indx
)
)
)
{
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
aIndexes
-
>
ElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
=
indx
;
}
else
{
mCachedIndex
=
indx
;
}
}
else
if
(
parent
!
=
mCommonParent
)
{
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
aIndexes
-
>
RemoveElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
;
}
return
GetPrevSibling
(
parent
aIndexes
)
;
}
return
sib
;
}
nsINode
*
nsContentIterator
:
:
NextNode
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
)
{
nsINode
*
node
=
aNode
;
if
(
mPre
)
{
if
(
node
-
>
HasChildren
(
)
)
{
nsIContent
*
firstChild
=
node
-
>
GetFirstChild
(
)
;
MOZ_ASSERT
(
firstChild
)
;
if
(
aIndexes
)
{
aIndexes
-
>
AppendElement
(
0
)
;
}
else
{
mCachedIndex
=
0
;
}
return
firstChild
;
}
return
GetNextSibling
(
node
aIndexes
)
;
}
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
NS_WARN_IF
(
!
parent
)
;
nsIContent
*
sibling
=
nullptr
;
int32_t
indx
=
0
;
NS_ASSERTION
(
!
aIndexes
|
|
!
aIndexes
-
>
IsEmpty
(
)
"
ContentIterator
stack
underflow
"
)
;
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
indx
=
(
*
aIndexes
)
[
aIndexes
-
>
Length
(
)
-
1
]
;
}
else
{
indx
=
mCachedIndex
;
}
if
(
indx
>
=
0
)
{
sibling
=
parent
-
>
GetChildAt
(
indx
)
;
}
if
(
sibling
!
=
node
)
{
indx
=
parent
-
>
IndexOf
(
node
)
;
NS_WARN_IF
(
indx
<
0
)
;
}
sibling
=
parent
-
>
GetChildAt
(
+
+
indx
)
;
if
(
sibling
)
{
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
aIndexes
-
>
ElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
=
indx
;
}
else
{
mCachedIndex
=
indx
;
}
return
GetDeepFirstChild
(
sibling
aIndexes
)
;
}
if
(
aIndexes
)
{
if
(
aIndexes
-
>
Length
(
)
>
1
)
{
aIndexes
-
>
RemoveElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
;
}
}
else
{
mCachedIndex
=
0
;
}
return
parent
;
}
nsINode
*
nsContentIterator
:
:
PrevNode
(
nsINode
*
aNode
nsTArray
<
int32_t
>
*
aIndexes
)
{
nsINode
*
node
=
aNode
;
if
(
mPre
)
{
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
NS_WARN_IF
(
!
parent
)
;
nsIContent
*
sibling
=
nullptr
;
int32_t
indx
=
0
;
NS_ASSERTION
(
!
aIndexes
|
|
!
aIndexes
-
>
IsEmpty
(
)
"
ContentIterator
stack
underflow
"
)
;
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
indx
=
(
*
aIndexes
)
[
aIndexes
-
>
Length
(
)
-
1
]
;
}
else
{
indx
=
mCachedIndex
;
}
if
(
indx
>
=
0
)
{
sibling
=
parent
-
>
GetChildAt
(
indx
)
;
NS_WARN_IF
(
!
sibling
)
;
}
if
(
sibling
!
=
node
)
{
indx
=
parent
-
>
IndexOf
(
node
)
;
NS_WARN_IF
(
indx
<
0
)
;
}
if
(
indx
&
&
(
sibling
=
parent
-
>
GetChildAt
(
-
-
indx
)
)
)
{
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
aIndexes
-
>
ElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
=
indx
;
}
else
{
mCachedIndex
=
indx
;
}
return
GetDeepLastChild
(
sibling
aIndexes
)
;
}
if
(
aIndexes
&
&
!
aIndexes
-
>
IsEmpty
(
)
)
{
aIndexes
-
>
RemoveElementAt
(
aIndexes
-
>
Length
(
)
-
1
)
;
}
else
{
mCachedIndex
=
0
;
}
return
parent
;
}
int32_t
numChildren
=
node
-
>
GetChildCount
(
)
;
NS_WARN_IF
(
numChildren
<
0
)
;
if
(
numChildren
)
{
nsIContent
*
lastChild
=
node
-
>
GetLastChild
(
)
;
NS_WARN_IF
(
!
lastChild
)
;
numChildren
-
-
;
if
(
aIndexes
)
{
aIndexes
-
>
AppendElement
(
numChildren
)
;
}
else
{
mCachedIndex
=
numChildren
;
}
return
lastChild
;
}
return
GetPrevSibling
(
node
aIndexes
)
;
}
void
nsContentIterator
:
:
First
(
)
{
if
(
mFirst
)
{
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mFirst
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
}
mIsDone
=
mFirst
=
=
nullptr
;
}
void
nsContentIterator
:
:
Last
(
)
{
NS_ASSERTION
(
mLast
"
No
last
node
!
"
)
;
if
(
mLast
)
{
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mLast
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
}
mIsDone
=
mLast
=
=
nullptr
;
}
void
nsContentIterator
:
:
Next
(
)
{
if
(
mIsDone
|
|
NS_WARN_IF
(
!
mCurNode
)
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mIsDone
=
true
;
return
;
}
mCurNode
=
NextNode
(
mCurNode
&
mIndexes
)
;
}
void
nsContentIterator
:
:
Prev
(
)
{
if
(
NS_WARN_IF
(
mIsDone
)
|
|
NS_WARN_IF
(
!
mCurNode
)
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mIsDone
=
true
;
return
;
}
mCurNode
=
PrevNode
(
mCurNode
&
mIndexes
)
;
}
bool
nsContentIterator
:
:
IsDone
(
)
{
return
mIsDone
;
}
nsresult
nsContentIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
if
(
NS_WARN_IF
(
!
aCurNode
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
newCurNode
=
aCurNode
;
nsINode
*
tempNode
=
mCurNode
;
mCurNode
=
aCurNode
;
if
(
mCurNode
=
=
tempNode
)
{
mIsDone
=
false
;
return
NS_OK
;
}
nsINode
*
firstNode
=
mFirst
;
nsINode
*
lastNode
=
mLast
;
int32_t
firstOffset
=
0
lastOffset
=
0
;
if
(
firstNode
&
&
lastNode
)
{
if
(
mPre
)
{
firstNode
=
NodeToParentOffset
(
mFirst
&
firstOffset
)
;
NS_WARN_IF
(
!
firstNode
)
;
NS_WARN_IF
(
firstOffset
<
0
)
;
if
(
lastNode
-
>
GetChildCount
(
)
)
{
lastOffset
=
0
;
}
else
{
lastNode
=
NodeToParentOffset
(
mLast
&
lastOffset
)
;
NS_WARN_IF
(
!
lastNode
)
;
NS_WARN_IF
(
lastOffset
<
0
)
;
+
+
lastOffset
;
}
}
else
{
uint32_t
numChildren
=
firstNode
-
>
GetChildCount
(
)
;
if
(
numChildren
)
{
firstOffset
=
numChildren
;
NS_WARN_IF
(
firstOffset
<
0
)
;
}
else
{
firstNode
=
NodeToParentOffset
(
mFirst
&
firstOffset
)
;
NS_WARN_IF
(
!
firstNode
)
;
NS_WARN_IF
(
firstOffset
<
0
)
;
}
lastNode
=
NodeToParentOffset
(
mLast
&
lastOffset
)
;
NS_WARN_IF
(
!
lastNode
)
;
NS_WARN_IF
(
lastOffset
<
0
)
;
+
+
lastOffset
;
}
}
if
(
mFirst
!
=
mCurNode
&
&
mLast
!
=
mCurNode
&
&
(
NS_WARN_IF
(
!
firstNode
)
|
|
NS_WARN_IF
(
!
lastNode
)
|
|
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mCurNode
mPre
firstNode
firstOffset
lastNode
lastOffset
)
)
)
)
{
mIsDone
=
true
;
return
NS_ERROR_FAILURE
;
}
nsAutoTArray
<
nsINode
*
8
>
oldParentStack
;
nsAutoTArray
<
int32_t
8
>
newIndexes
;
oldParentStack
.
SetCapacity
(
mIndexes
.
Length
(
)
+
1
)
;
for
(
int32_t
i
=
mIndexes
.
Length
(
)
+
1
;
i
>
0
&
&
tempNode
;
i
-
-
)
{
oldParentStack
.
InsertElementAt
(
0
tempNode
)
;
nsINode
*
parent
=
tempNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
break
;
}
if
(
parent
=
=
mCurNode
)
{
mIndexes
.
RemoveElementsAt
(
mIndexes
.
Length
(
)
-
oldParentStack
.
Length
(
)
oldParentStack
.
Length
(
)
)
;
mIsDone
=
false
;
return
NS_OK
;
}
tempNode
=
parent
;
}
while
(
newCurNode
)
{
nsINode
*
parent
=
newCurNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
break
;
}
int32_t
indx
=
parent
-
>
IndexOf
(
newCurNode
)
;
NS_WARN_IF
(
indx
<
0
)
;
newIndexes
.
InsertElementAt
(
0
indx
)
;
indx
=
oldParentStack
.
IndexOf
(
parent
)
;
if
(
indx
>
=
0
)
{
int32_t
numToDrop
=
oldParentStack
.
Length
(
)
-
(
1
+
indx
)
;
if
(
numToDrop
>
0
)
{
mIndexes
.
RemoveElementsAt
(
mIndexes
.
Length
(
)
-
numToDrop
numToDrop
)
;
}
mIndexes
.
AppendElements
(
newIndexes
)
;
break
;
}
newCurNode
=
parent
;
}
mIsDone
=
false
;
return
NS_OK
;
}
nsINode
*
nsContentIterator
:
:
GetCurrentNode
(
)
{
if
(
mIsDone
)
{
return
nullptr
;
}
NS_ASSERTION
(
mCurNode
"
Null
current
node
in
an
iterator
that
'
s
not
done
!
"
)
;
return
mCurNode
;
}
class
nsContentSubtreeIterator
:
public
nsContentIterator
{
public
:
nsContentSubtreeIterator
(
)
:
nsContentIterator
(
false
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
;
virtual
nsresult
Init
(
nsIDOMRange
*
aRange
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
protected
:
virtual
~
nsContentSubtreeIterator
(
)
{
}
nsIContent
*
GetTopAncestorInRange
(
nsINode
*
aNode
)
;
nsContentSubtreeIterator
(
const
nsContentSubtreeIterator
&
)
;
nsContentSubtreeIterator
&
operator
=
(
const
nsContentSubtreeIterator
&
)
;
virtual
void
LastRelease
(
)
override
;
RefPtr
<
nsRange
>
mRange
;
nsAutoTArray
<
nsIContent
*
8
>
mEndNodes
;
nsAutoTArray
<
int32_t
8
>
mEndOffsets
;
}
;
NS_IMPL_ADDREF_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
NS_IMPL_RELEASE_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
nsContentSubtreeIterator
)
NS_INTERFACE_MAP_END_INHERITING
(
nsContentIterator
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
mRange
)
void
nsContentSubtreeIterator
:
:
LastRelease
(
)
{
mRange
=
nullptr
;
nsContentIterator
:
:
LastRelease
(
)
;
}
already_AddRefed
<
nsIContentIterator
>
NS_NewContentSubtreeIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentSubtreeIterator
(
)
;
return
iter
.
forget
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsINode
*
aRoot
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsIDOMRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
mIsDone
=
false
;
mRange
=
static_cast
<
nsRange
*
>
(
aRange
)
;
mCommonParent
=
mRange
-
>
GetCommonAncestor
(
)
;
nsINode
*
startParent
=
mRange
-
>
GetStartParent
(
)
;
int32_t
startOffset
=
mRange
-
>
StartOffset
(
)
;
nsINode
*
endParent
=
mRange
-
>
GetEndParent
(
)
;
int32_t
endOffset
=
mRange
-
>
EndOffset
(
)
;
MOZ_ASSERT
(
mCommonParent
&
&
startParent
&
&
endParent
)
;
MOZ_ASSERT
(
uint32_t
(
startOffset
)
<
=
startParent
-
>
Length
(
)
&
&
uint32_t
(
endOffset
)
<
=
endParent
-
>
Length
(
)
)
;
if
(
startParent
=
=
endParent
)
{
nsINode
*
child
=
startParent
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
startOffset
=
=
endOffset
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
}
nsContentUtils
:
:
GetAncestorsAndOffsets
(
endParent
-
>
AsDOMNode
(
)
endOffset
&
mEndNodes
&
mEndOffsets
)
;
nsIContent
*
firstCandidate
=
nullptr
;
nsIContent
*
lastCandidate
=
nullptr
;
int32_t
offset
=
mRange
-
>
StartOffset
(
)
;
nsINode
*
node
;
if
(
!
startParent
-
>
GetChildCount
(
)
)
{
node
=
startParent
;
}
else
{
nsIContent
*
child
=
startParent
-
>
GetChildAt
(
offset
)
;
if
(
!
child
)
{
node
=
startParent
;
}
else
{
firstCandidate
=
child
;
}
}
if
(
!
firstCandidate
)
{
firstCandidate
=
GetNextSibling
(
node
)
;
if
(
!
firstCandidate
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
}
firstCandidate
=
GetDeepFirstChild
(
firstCandidate
)
;
bool
nodeBefore
nodeAfter
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
nsRange
:
:
CompareNodeToRange
(
firstCandidate
mRange
&
nodeBefore
&
nodeAfter
)
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
mFirst
=
GetTopAncestorInRange
(
firstCandidate
)
;
offset
=
mRange
-
>
EndOffset
(
)
;
int32_t
numChildren
=
endParent
-
>
GetChildCount
(
)
;
if
(
offset
>
numChildren
)
{
offset
=
numChildren
;
}
if
(
!
offset
|
|
!
numChildren
)
{
node
=
endParent
;
}
else
{
lastCandidate
=
endParent
-
>
GetChildAt
(
-
-
offset
)
;
NS_ASSERTION
(
lastCandidate
"
tree
traversal
trouble
in
nsContentSubtreeIterator
:
:
Init
"
)
;
}
if
(
!
lastCandidate
)
{
lastCandidate
=
GetPrevSibling
(
node
)
;
}
if
(
!
lastCandidate
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
lastCandidate
=
GetDeepLastChild
(
lastCandidate
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
nsRange
:
:
CompareNodeToRange
(
lastCandidate
mRange
&
nodeBefore
&
nodeAfter
)
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
mLast
=
GetTopAncestorInRange
(
lastCandidate
)
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
void
nsContentSubtreeIterator
:
:
First
(
)
{
mIsDone
=
mFirst
=
=
nullptr
;
mCurNode
=
mFirst
;
}
void
nsContentSubtreeIterator
:
:
Last
(
)
{
mIsDone
=
mLast
=
=
nullptr
;
mCurNode
=
mLast
;
}
void
nsContentSubtreeIterator
:
:
Next
(
)
{
if
(
mIsDone
|
|
!
mCurNode
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mIsDone
=
true
;
return
;
}
nsINode
*
nextNode
=
GetNextSibling
(
mCurNode
)
;
NS_ASSERTION
(
nextNode
"
No
next
sibling
!
?
!
This
could
mean
deadlock
!
"
)
;
int32_t
i
=
mEndNodes
.
IndexOf
(
nextNode
)
;
while
(
i
!
=
-
1
)
{
nextNode
=
nextNode
-
>
GetFirstChild
(
)
;
NS_ASSERTION
(
nextNode
"
Iterator
error
expected
a
child
node
!
"
)
;
i
=
mEndNodes
.
IndexOf
(
nextNode
)
;
}
mCurNode
=
nextNode
;
mIsDone
=
mCurNode
=
=
nullptr
;
}
void
nsContentSubtreeIterator
:
:
Prev
(
)
{
if
(
mIsDone
|
|
!
mCurNode
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mIsDone
=
true
;
return
;
}
nsINode
*
prevNode
=
GetDeepFirstChild
(
mCurNode
)
;
prevNode
=
PrevNode
(
prevNode
)
;
prevNode
=
GetDeepLastChild
(
prevNode
)
;
mCurNode
=
GetTopAncestorInRange
(
prevNode
)
;
mIsDone
=
mCurNode
=
=
nullptr
;
}
nsresult
nsContentSubtreeIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
NS_ERROR
(
"
Not
implemented
!
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIContent
*
nsContentSubtreeIterator
:
:
GetTopAncestorInRange
(
nsINode
*
aNode
)
{
if
(
!
aNode
|
|
!
aNode
-
>
GetParentNode
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
bool
nodeBefore
nodeAfter
;
nsresult
res
=
nsRange
:
:
CompareNodeToRange
(
aNode
mRange
&
nodeBefore
&
nodeAfter
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
&
&
!
nodeBefore
&
&
!
nodeAfter
"
aNode
isn
'
t
in
mRange
or
something
else
weird
happened
"
)
;
if
(
NS_FAILED
(
res
)
|
|
nodeBefore
|
|
nodeAfter
)
{
return
nullptr
;
}
while
(
content
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
GetParentNode
(
)
)
{
return
content
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
nsRange
:
:
CompareNodeToRange
(
parent
mRange
&
nodeBefore
&
nodeAfter
)
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
return
content
;
}
content
=
parent
;
}
MOZ_CRASH
(
"
This
should
only
be
possible
if
aNode
was
null
"
)
;
}
