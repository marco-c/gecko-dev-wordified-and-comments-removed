#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsElementTable
.
h
"
using
mozilla
:
:
DebugOnly
;
using
mozilla
:
:
RawRangeBoundary
;
static
bool
NodeIsInTraversalRange
(
nsINode
*
aNode
bool
aIsPreMode
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
if
(
NS_WARN_IF
(
!
aStart
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEnd
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
if
(
aNode
=
=
aStart
.
Container
(
)
|
|
aNode
=
=
aEnd
.
Container
(
)
)
{
if
(
aNode
-
>
IsCharacterData
(
)
)
{
return
true
;
}
if
(
!
aNode
-
>
HasChildren
(
)
)
{
MOZ_ASSERT
(
aNode
!
=
aStart
.
Container
(
)
|
|
aStart
.
IsStartOfContainer
(
)
"
aStart
.
Container
(
)
doesn
'
t
have
children
and
not
a
data
node
"
"
aStart
should
be
at
the
beginning
of
its
container
"
)
;
MOZ_ASSERT
(
aNode
!
=
aEnd
.
Container
(
)
|
|
aEnd
.
IsStartOfContainer
(
)
"
aEnd
.
Container
(
)
doesn
'
t
have
children
and
not
a
data
node
"
"
aEnd
should
be
at
the
beginning
of
its
container
"
)
;
return
true
;
}
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
return
false
;
}
if
(
!
aIsPreMode
)
{
nsIContent
*
content
=
NS_WARN_IF
(
!
aNode
-
>
IsContent
(
)
)
?
nullptr
:
aNode
-
>
AsContent
(
)
;
RawRangeBoundary
afterNode
(
parent
content
)
;
return
nsContentUtils
:
:
ComparePoints
(
aStart
afterNode
)
<
0
&
&
nsContentUtils
:
:
ComparePoints
(
aEnd
afterNode
)
>
=
0
;
}
RawRangeBoundary
beforeNode
(
parent
aNode
-
>
GetPreviousSibling
(
)
)
;
return
nsContentUtils
:
:
ComparePoints
(
aStart
beforeNode
)
<
=
0
&
&
nsContentUtils
:
:
ComparePoints
(
aEnd
beforeNode
)
>
0
;
}
class
nsContentIterator
:
public
nsIContentIterator
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsContentIterator
)
explicit
nsContentIterator
(
bool
aPre
)
;
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
;
virtual
nsresult
Init
(
nsRange
*
aRange
)
override
;
virtual
nsresult
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
override
;
virtual
nsresult
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
override
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsINode
*
GetCurrentNode
(
)
override
;
virtual
bool
IsDone
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
protected
:
virtual
~
nsContentIterator
(
)
;
nsresult
InitInternal
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
;
nsINode
*
GetDeepFirstChild
(
nsINode
*
aRoot
)
;
nsIContent
*
GetDeepFirstChild
(
nsIContent
*
aRoot
)
;
nsINode
*
GetDeepLastChild
(
nsINode
*
aRoot
)
;
nsIContent
*
GetDeepLastChild
(
nsIContent
*
aRoot
)
;
nsIContent
*
GetNextSibling
(
nsINode
*
aNode
)
;
nsIContent
*
GetPrevSibling
(
nsINode
*
aNode
)
;
nsINode
*
NextNode
(
nsINode
*
aNode
)
;
nsINode
*
PrevNode
(
nsINode
*
aNode
)
;
void
MakeEmpty
(
)
;
virtual
void
LastRelease
(
)
;
nsCOMPtr
<
nsINode
>
mCurNode
;
nsCOMPtr
<
nsINode
>
mFirst
;
nsCOMPtr
<
nsINode
>
mLast
;
nsCOMPtr
<
nsINode
>
mCommonParent
;
bool
mIsDone
;
bool
mPre
;
private
:
nsContentIterator
(
const
nsContentIterator
&
)
;
nsContentIterator
&
operator
=
(
const
nsContentIterator
&
)
;
}
;
already_AddRefed
<
nsIContentIterator
>
NS_NewContentIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentIterator
(
false
)
;
return
iter
.
forget
(
)
;
}
already_AddRefed
<
nsIContentIterator
>
NS_NewPreContentIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentIterator
(
true
)
;
return
iter
.
forget
(
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsContentIterator
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsContentIterator
LastRelease
(
)
)
NS_INTERFACE_MAP_BEGIN
(
nsContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsContentIterator
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsContentIterator
mCurNode
mFirst
mLast
mCommonParent
)
void
nsContentIterator
:
:
LastRelease
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mCommonParent
=
nullptr
;
}
nsContentIterator
:
:
nsContentIterator
(
bool
aPre
)
:
mIsDone
(
false
)
mPre
(
aPre
)
{
}
nsContentIterator
:
:
~
nsContentIterator
(
)
{
}
nsresult
nsContentIterator
:
:
Init
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
mIsDone
=
false
;
if
(
mPre
)
{
mFirst
=
aRoot
;
mLast
=
GetDeepLastChild
(
aRoot
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetDeepLastChild
returned
null
"
)
;
}
else
{
mFirst
=
GetDeepFirstChild
(
aRoot
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetDeepFirstChild
returned
null
"
)
;
mLast
=
aRoot
;
}
mCommonParent
=
aRoot
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
nsresult
nsContentIterator
:
:
Init
(
nsRange
*
aRange
)
{
mIsDone
=
false
;
if
(
NS_WARN_IF
(
!
aRange
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
!
aRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
aRange
-
>
StartRef
(
)
.
AsRaw
(
)
aRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
}
nsresult
nsContentIterator
:
:
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
mIsDone
=
false
;
if
(
NS_WARN_IF
(
!
nsRange
:
:
IsValidPoints
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
nsresult
nsContentIterator
:
:
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
mIsDone
=
false
;
if
(
NS_WARN_IF
(
!
nsRange
:
:
IsValidPoints
(
aStart
.
Container
(
)
aStart
.
Offset
(
)
aEnd
.
Container
(
)
aEnd
.
Offset
(
)
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
aStart
aEnd
)
;
}
nsresult
nsContentIterator
:
:
InitInternal
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
mCommonParent
=
nsContentUtils
:
:
GetCommonAncestor
(
aStart
.
Container
(
)
aEnd
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
!
mCommonParent
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
startIsData
=
aStart
.
Container
(
)
-
>
IsCharacterData
(
)
;
if
(
!
startIsData
&
&
aStart
=
=
aEnd
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
if
(
startIsData
&
&
aStart
.
Container
(
)
=
=
aEnd
.
Container
(
)
)
{
mFirst
=
aStart
.
Container
(
)
-
>
AsContent
(
)
;
mLast
=
mFirst
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
nsIContent
*
cChild
=
nullptr
;
if
(
!
startIsData
)
{
cChild
=
aStart
.
GetChildAtOffset
(
)
;
}
if
(
!
cChild
)
{
if
(
mPre
)
{
bool
startIsContainer
=
true
;
if
(
aStart
.
Container
(
)
-
>
IsHTMLElement
(
)
)
{
nsAtom
*
name
=
aStart
.
Container
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
startIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
if
(
!
startIsData
&
&
(
startIsContainer
|
|
!
aStart
.
IsStartOfContainer
(
)
)
)
{
mFirst
=
GetNextSibling
(
aStart
.
Container
(
)
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetNextSibling
returned
null
"
)
;
if
(
mFirst
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mFirst
mPre
aStart
aEnd
)
)
)
{
mFirst
=
nullptr
;
}
}
else
{
mFirst
=
aStart
.
Container
(
)
-
>
AsContent
(
)
;
}
}
else
{
if
(
NS_WARN_IF
(
!
aStart
.
Container
(
)
-
>
IsContent
(
)
)
)
{
mFirst
=
nullptr
;
}
else
{
mFirst
=
aStart
.
Container
(
)
-
>
AsContent
(
)
;
}
}
}
else
{
if
(
mPre
)
{
mFirst
=
cChild
;
}
else
{
mFirst
=
GetDeepFirstChild
(
cChild
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetDeepFirstChild
returned
null
"
)
;
if
(
mFirst
&
&
!
NodeIsInTraversalRange
(
mFirst
mPre
aStart
aEnd
)
)
{
mFirst
=
nullptr
;
}
}
}
bool
endIsData
=
aEnd
.
Container
(
)
-
>
IsCharacterData
(
)
;
if
(
endIsData
|
|
!
aEnd
.
Container
(
)
-
>
HasChildren
(
)
|
|
aEnd
.
IsStartOfContainer
(
)
)
{
if
(
mPre
)
{
if
(
NS_WARN_IF
(
!
aEnd
.
Container
(
)
-
>
IsContent
(
)
)
)
{
mLast
=
nullptr
;
}
else
{
bool
endIsContainer
=
true
;
if
(
aEnd
.
Container
(
)
-
>
IsHTMLElement
(
)
)
{
nsAtom
*
name
=
aEnd
.
Container
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
endIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
if
(
!
endIsData
&
&
!
endIsContainer
&
&
aEnd
.
IsStartOfContainer
(
)
)
{
mLast
=
PrevNode
(
aEnd
.
Container
(
)
)
;
NS_WARNING_ASSERTION
(
mLast
"
PrevNode
returned
null
"
)
;
if
(
mLast
&
&
mLast
!
=
mFirst
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mLast
mPre
RawRangeBoundary
(
mFirst
0
)
aEnd
)
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
aEnd
.
Container
(
)
-
>
AsContent
(
)
;
}
}
}
else
{
if
(
!
endIsData
)
{
mLast
=
GetPrevSibling
(
aEnd
.
Container
(
)
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetPrevSibling
returned
null
"
)
;
if
(
!
NodeIsInTraversalRange
(
mLast
mPre
aStart
aEnd
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
aEnd
.
Container
(
)
-
>
AsContent
(
)
;
}
}
}
else
{
cChild
=
aEnd
.
Ref
(
)
;
if
(
NS_WARN_IF
(
!
cChild
)
)
{
NS_NOTREACHED
(
"
nsContentIterator
:
:
nsContentIterator
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mPre
)
{
mLast
=
GetDeepLastChild
(
cChild
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetDeepLastChild
returned
null
"
)
;
if
(
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mLast
mPre
aStart
aEnd
)
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
cChild
;
}
}
if
(
!
mFirst
|
|
!
mLast
)
{
mFirst
=
nullptr
;
mLast
=
nullptr
;
}
mCurNode
=
mFirst
;
mIsDone
=
!
mCurNode
;
return
NS_OK
;
}
void
nsContentIterator
:
:
MakeEmpty
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mCommonParent
=
nullptr
;
mIsDone
=
true
;
}
nsINode
*
nsContentIterator
:
:
GetDeepFirstChild
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
return
GetDeepFirstChild
(
aRoot
-
>
GetFirstChild
(
)
)
;
}
nsIContent
*
nsContentIterator
:
:
GetDeepFirstChild
(
nsIContent
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
nsIContent
*
child
=
node
-
>
GetFirstChild
(
)
;
while
(
child
)
{
node
=
child
;
child
=
node
-
>
GetFirstChild
(
)
;
}
return
node
;
}
nsINode
*
nsContentIterator
:
:
GetDeepLastChild
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
return
GetDeepLastChild
(
aRoot
-
>
GetLastChild
(
)
)
;
}
nsIContent
*
nsContentIterator
:
:
GetDeepLastChild
(
nsIContent
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
while
(
node
-
>
HasChildren
(
)
)
{
nsIContent
*
child
=
node
-
>
GetLastChild
(
)
;
node
=
child
;
}
return
node
;
}
nsIContent
*
nsContentIterator
:
:
GetNextSibling
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
GetNextSibling
(
)
)
{
return
aNode
-
>
GetNextSibling
(
)
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
if
(
parent
-
>
GetLastChild
(
)
&
&
parent
-
>
GetLastChild
(
)
!
=
aNode
)
{
return
parent
-
>
GetFirstChild
(
)
;
}
return
GetNextSibling
(
parent
)
;
}
nsIContent
*
nsContentIterator
:
:
GetPrevSibling
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
GetPreviousSibling
(
)
)
{
return
aNode
-
>
GetPreviousSibling
(
)
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
if
(
parent
-
>
GetFirstChild
(
)
&
&
parent
-
>
GetFirstChild
(
)
!
=
aNode
)
{
return
parent
-
>
GetLastChild
(
)
;
}
return
GetPrevSibling
(
parent
)
;
}
nsINode
*
nsContentIterator
:
:
NextNode
(
nsINode
*
aNode
)
{
nsINode
*
node
=
aNode
;
if
(
mPre
)
{
if
(
node
-
>
HasChildren
(
)
)
{
nsIContent
*
firstChild
=
node
-
>
GetFirstChild
(
)
;
MOZ_ASSERT
(
firstChild
)
;
return
firstChild
;
}
return
GetNextSibling
(
node
)
;
}
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
MOZ_ASSERT
(
parent
"
The
node
is
the
root
node
but
not
the
last
node
"
)
;
mIsDone
=
true
;
return
node
;
}
nsIContent
*
sibling
=
node
-
>
GetNextSibling
(
)
;
if
(
sibling
)
{
return
GetDeepFirstChild
(
sibling
)
;
}
return
parent
;
}
nsINode
*
nsContentIterator
:
:
PrevNode
(
nsINode
*
aNode
)
{
nsINode
*
node
=
aNode
;
if
(
mPre
)
{
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
MOZ_ASSERT
(
parent
"
The
node
is
the
root
node
but
not
the
first
node
"
)
;
mIsDone
=
true
;
return
aNode
;
}
nsIContent
*
sibling
=
node
-
>
GetPreviousSibling
(
)
;
if
(
sibling
)
{
return
GetDeepLastChild
(
sibling
)
;
}
return
parent
;
}
if
(
node
-
>
HasChildren
(
)
)
{
return
node
-
>
GetLastChild
(
)
;
}
return
GetPrevSibling
(
node
)
;
}
void
nsContentIterator
:
:
First
(
)
{
if
(
mFirst
)
{
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mFirst
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
}
mIsDone
=
mFirst
=
=
nullptr
;
}
void
nsContentIterator
:
:
Last
(
)
{
if
(
!
mLast
)
{
MOZ_ASSERT
(
mIsDone
)
;
return
;
}
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mLast
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
mIsDone
=
mLast
=
=
nullptr
;
}
void
nsContentIterator
:
:
Next
(
)
{
if
(
mIsDone
|
|
NS_WARN_IF
(
!
mCurNode
)
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mIsDone
=
true
;
return
;
}
mCurNode
=
NextNode
(
mCurNode
)
;
}
void
nsContentIterator
:
:
Prev
(
)
{
if
(
NS_WARN_IF
(
mIsDone
)
|
|
NS_WARN_IF
(
!
mCurNode
)
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mIsDone
=
true
;
return
;
}
mCurNode
=
PrevNode
(
mCurNode
)
;
}
bool
nsContentIterator
:
:
IsDone
(
)
{
return
mIsDone
;
}
nsresult
nsContentIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
if
(
NS_WARN_IF
(
!
aCurNode
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
mCurNode
=
=
aCurNode
)
{
mIsDone
=
false
;
return
NS_OK
;
}
mCurNode
=
aCurNode
;
RawRangeBoundary
first
(
mFirst
0
)
;
RawRangeBoundary
last
(
mLast
0
)
;
if
(
mFirst
&
&
mLast
)
{
if
(
mPre
)
{
first
.
SetAfterRef
(
mFirst
-
>
GetParentNode
(
)
mFirst
-
>
GetPreviousSibling
(
)
)
;
if
(
!
mLast
-
>
HasChildren
(
)
)
{
last
.
SetAfterRef
(
mLast
-
>
GetParentNode
(
)
mLast
-
>
AsContent
(
)
)
;
}
}
else
{
if
(
mFirst
-
>
HasChildren
(
)
)
{
first
.
SetAfterRef
(
mFirst
mFirst
-
>
GetLastChild
(
)
)
;
}
else
{
first
.
SetAfterRef
(
mFirst
-
>
GetParentNode
(
)
mFirst
-
>
GetPreviousSibling
(
)
)
;
}
last
.
SetAfterRef
(
mLast
-
>
GetParentNode
(
)
mLast
-
>
AsContent
(
)
)
;
}
}
NS_WARNING_ASSERTION
(
first
.
IsSetAndValid
(
)
"
first
is
not
valid
"
)
;
NS_WARNING_ASSERTION
(
last
.
IsSetAndValid
(
)
"
last
is
not
valid
"
)
;
if
(
mFirst
!
=
mCurNode
&
&
mLast
!
=
mCurNode
&
&
(
NS_WARN_IF
(
!
first
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
last
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mCurNode
mPre
first
last
)
)
)
)
{
mIsDone
=
true
;
return
NS_ERROR_FAILURE
;
}
mIsDone
=
false
;
return
NS_OK
;
}
nsINode
*
nsContentIterator
:
:
GetCurrentNode
(
)
{
if
(
mIsDone
)
{
return
nullptr
;
}
NS_ASSERTION
(
mCurNode
"
Null
current
node
in
an
iterator
that
'
s
not
done
!
"
)
;
return
mCurNode
;
}
class
nsContentSubtreeIterator
:
public
nsContentIterator
{
public
:
nsContentSubtreeIterator
(
)
:
nsContentIterator
(
false
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
;
virtual
nsresult
Init
(
nsRange
*
aRange
)
override
;
virtual
nsresult
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
override
;
virtual
nsresult
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
protected
:
virtual
~
nsContentSubtreeIterator
(
)
{
}
nsresult
InitWithRange
(
)
;
nsIContent
*
GetTopAncestorInRange
(
nsINode
*
aNode
)
;
nsContentSubtreeIterator
(
const
nsContentSubtreeIterator
&
)
;
nsContentSubtreeIterator
&
operator
=
(
const
nsContentSubtreeIterator
&
)
;
virtual
void
LastRelease
(
)
override
;
RefPtr
<
nsRange
>
mRange
;
AutoTArray
<
nsIContent
*
8
>
mEndNodes
;
AutoTArray
<
int32_t
8
>
mEndOffsets
;
}
;
NS_IMPL_ADDREF_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
NS_IMPL_RELEASE_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsContentSubtreeIterator
)
NS_INTERFACE_MAP_END_INHERITING
(
nsContentIterator
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
mRange
)
void
nsContentSubtreeIterator
:
:
LastRelease
(
)
{
mRange
=
nullptr
;
nsContentIterator
:
:
LastRelease
(
)
;
}
already_AddRefed
<
nsIContentIterator
>
NS_NewContentSubtreeIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentSubtreeIterator
(
)
;
return
iter
.
forget
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsINode
*
aRoot
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
mIsDone
=
false
;
if
(
NS_WARN_IF
(
!
aRange
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mRange
=
aRange
;
return
InitWithRange
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
return
Init
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
mIsDone
=
false
;
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
aStart
aEnd
getter_AddRefs
(
range
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
range
-
>
StartRef
(
)
!
=
aStart
)
|
|
NS_WARN_IF
(
range
-
>
EndRef
(
)
!
=
aEnd
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRange
=
std
:
:
move
(
range
)
;
return
InitWithRange
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
InitWithRange
(
)
{
MOZ_ASSERT
(
mRange
)
;
MOZ_ASSERT
(
mRange
-
>
IsPositioned
(
)
)
;
mCommonParent
=
mRange
-
>
GetCommonAncestor
(
)
;
nsINode
*
startContainer
=
mRange
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
mRange
-
>
StartOffset
(
)
;
nsINode
*
endContainer
=
mRange
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
mRange
-
>
EndOffset
(
)
;
MOZ_ASSERT
(
mCommonParent
&
&
startContainer
&
&
endContainer
)
;
MOZ_ASSERT
(
uint32_t
(
startOffset
)
<
=
startContainer
-
>
Length
(
)
&
&
uint32_t
(
endOffset
)
<
=
endContainer
-
>
Length
(
)
)
;
if
(
startContainer
=
=
endContainer
)
{
nsINode
*
child
=
startContainer
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
startOffset
=
=
endOffset
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
}
nsContentUtils
:
:
GetAncestorsAndOffsets
(
endContainer
endOffset
&
mEndNodes
&
mEndOffsets
)
;
nsIContent
*
firstCandidate
=
nullptr
;
nsIContent
*
lastCandidate
=
nullptr
;
int32_t
offset
=
mRange
-
>
StartOffset
(
)
;
nsINode
*
node
=
nullptr
;
if
(
!
startContainer
-
>
GetChildCount
(
)
)
{
node
=
startContainer
;
}
else
{
nsIContent
*
child
=
startContainer
-
>
GetChildAt_Deprecated
(
offset
)
;
if
(
!
child
)
{
node
=
startContainer
;
}
else
{
firstCandidate
=
child
;
}
}
if
(
!
firstCandidate
)
{
firstCandidate
=
GetNextSibling
(
node
)
;
if
(
!
firstCandidate
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
}
firstCandidate
=
GetDeepFirstChild
(
firstCandidate
)
;
bool
nodeBefore
nodeAfter
;
MOZ_ALWAYS_SUCCEEDS
(
nsRange
:
:
CompareNodeToRange
(
firstCandidate
mRange
&
nodeBefore
&
nodeAfter
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
mFirst
=
GetTopAncestorInRange
(
firstCandidate
)
;
offset
=
mRange
-
>
EndOffset
(
)
;
int32_t
numChildren
=
endContainer
-
>
GetChildCount
(
)
;
if
(
offset
>
numChildren
)
{
offset
=
numChildren
;
}
if
(
!
offset
|
|
!
numChildren
)
{
node
=
endContainer
;
}
else
{
lastCandidate
=
endContainer
-
>
GetChildAt_Deprecated
(
-
-
offset
)
;
NS_ASSERTION
(
lastCandidate
"
tree
traversal
trouble
in
nsContentSubtreeIterator
:
:
Init
"
)
;
}
if
(
!
lastCandidate
)
{
lastCandidate
=
GetPrevSibling
(
node
)
;
}
if
(
!
lastCandidate
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
lastCandidate
=
GetDeepLastChild
(
lastCandidate
)
;
MOZ_ALWAYS_SUCCEEDS
(
nsRange
:
:
CompareNodeToRange
(
lastCandidate
mRange
&
nodeBefore
&
nodeAfter
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
mLast
=
GetTopAncestorInRange
(
lastCandidate
)
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
void
nsContentSubtreeIterator
:
:
First
(
)
{
mIsDone
=
mFirst
=
=
nullptr
;
mCurNode
=
mFirst
;
}
void
nsContentSubtreeIterator
:
:
Last
(
)
{
mIsDone
=
mLast
=
=
nullptr
;
mCurNode
=
mLast
;
}
void
nsContentSubtreeIterator
:
:
Next
(
)
{
if
(
mIsDone
|
|
!
mCurNode
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mIsDone
=
true
;
return
;
}
nsINode
*
nextNode
=
GetNextSibling
(
mCurNode
)
;
NS_ASSERTION
(
nextNode
"
No
next
sibling
!
?
!
This
could
mean
deadlock
!
"
)
;
int32_t
i
=
mEndNodes
.
IndexOf
(
nextNode
)
;
while
(
i
!
=
-
1
)
{
nextNode
=
nextNode
-
>
GetFirstChild
(
)
;
NS_ASSERTION
(
nextNode
"
Iterator
error
expected
a
child
node
!
"
)
;
i
=
mEndNodes
.
IndexOf
(
nextNode
)
;
}
mCurNode
=
nextNode
;
mIsDone
=
mCurNode
=
=
nullptr
;
}
void
nsContentSubtreeIterator
:
:
Prev
(
)
{
if
(
mIsDone
|
|
!
mCurNode
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mIsDone
=
true
;
return
;
}
nsINode
*
prevNode
=
GetDeepFirstChild
(
mCurNode
)
;
prevNode
=
PrevNode
(
prevNode
)
;
prevNode
=
GetDeepLastChild
(
prevNode
)
;
mCurNode
=
GetTopAncestorInRange
(
prevNode
)
;
mIsDone
=
mCurNode
=
=
nullptr
;
}
nsresult
nsContentSubtreeIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
NS_ERROR
(
"
Not
implemented
!
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIContent
*
nsContentSubtreeIterator
:
:
GetTopAncestorInRange
(
nsINode
*
aNode
)
{
if
(
!
aNode
|
|
!
aNode
-
>
GetParentNode
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
bool
nodeBefore
nodeAfter
;
nsresult
res
=
nsRange
:
:
CompareNodeToRange
(
aNode
mRange
&
nodeBefore
&
nodeAfter
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
&
&
!
nodeBefore
&
&
!
nodeAfter
"
aNode
isn
'
t
in
mRange
or
something
else
weird
happened
"
)
;
if
(
NS_FAILED
(
res
)
|
|
nodeBefore
|
|
nodeAfter
)
{
return
nullptr
;
}
while
(
content
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
GetParentNode
(
)
)
{
return
content
;
}
MOZ_ALWAYS_SUCCEEDS
(
nsRange
:
:
CompareNodeToRange
(
parent
mRange
&
nodeBefore
&
nodeAfter
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
return
content
;
}
content
=
parent
;
}
MOZ_CRASH
(
"
This
should
only
be
possible
if
aNode
was
null
"
)
;
}
