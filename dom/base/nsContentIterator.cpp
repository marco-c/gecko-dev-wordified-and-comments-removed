#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIDOMNodeList
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsElementTable
.
h
"
using
mozilla
:
:
DebugOnly
;
static
nsINode
*
NodeToParentOffset
(
nsINode
*
aNode
int32_t
*
aOffset
)
{
*
aOffset
=
0
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
parent
)
{
*
aOffset
=
parent
-
>
IndexOf
(
aNode
)
;
NS_WARNING_ASSERTION
(
*
aOffset
>
=
0
"
bad
offset
"
)
;
}
return
parent
;
}
static
bool
NodeIsInTraversalRange
(
nsINode
*
aNode
bool
aIsPreMode
nsINode
*
aStartContainer
int32_t
aStartOffset
nsINode
*
aEndContainer
int32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aStartContainer
)
|
|
NS_WARN_IF
(
!
aEndContainer
)
|
|
NS_WARN_IF
(
!
aNode
)
)
{
return
false
;
}
if
(
aNode
=
=
aStartContainer
|
|
aNode
=
=
aEndContainer
)
{
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
)
{
return
true
;
}
if
(
!
aNode
-
>
HasChildren
(
)
)
{
MOZ_ASSERT
(
aNode
!
=
aStartContainer
|
|
!
aStartOffset
"
aStartContainer
doesn
'
t
have
children
and
not
a
data
node
"
"
aStartOffset
should
be
0
"
)
;
MOZ_ASSERT
(
aNode
!
=
aEndContainer
|
|
!
aEndOffset
"
aEndContainer
doesn
'
t
have
children
and
not
a
data
node
"
"
aEndOffset
should
be
0
"
)
;
return
true
;
}
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
return
false
;
}
int32_t
indx
=
parent
-
>
IndexOf
(
aNode
)
;
NS_WARNING_ASSERTION
(
indx
!
=
-
1
"
bad
indx
"
)
;
if
(
!
aIsPreMode
)
{
return
nsContentUtils
:
:
ComparePoints
(
aStartContainer
aStartOffset
parent
indx
+
1
)
<
0
&
&
nsContentUtils
:
:
ComparePoints
(
aEndContainer
aEndOffset
parent
indx
+
1
)
>
=
0
;
}
return
nsContentUtils
:
:
ComparePoints
(
aStartContainer
aStartOffset
parent
indx
)
<
=
0
&
&
nsContentUtils
:
:
ComparePoints
(
aEndContainer
aEndOffset
parent
indx
)
>
0
;
}
class
nsContentIterator
:
public
nsIContentIterator
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsContentIterator
)
explicit
nsContentIterator
(
bool
aPre
)
;
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
;
virtual
nsresult
Init
(
nsIDOMRange
*
aRange
)
override
;
virtual
nsresult
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
override
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsINode
*
GetCurrentNode
(
)
override
;
virtual
bool
IsDone
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
protected
:
virtual
~
nsContentIterator
(
)
;
nsresult
InitInternal
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
nsINode
*
GetDeepFirstChild
(
nsINode
*
aRoot
)
;
nsIContent
*
GetDeepFirstChild
(
nsIContent
*
aRoot
)
;
nsINode
*
GetDeepLastChild
(
nsINode
*
aRoot
)
;
nsIContent
*
GetDeepLastChild
(
nsIContent
*
aRoot
)
;
nsIContent
*
GetNextSibling
(
nsINode
*
aNode
)
;
nsIContent
*
GetPrevSibling
(
nsINode
*
aNode
)
;
nsINode
*
NextNode
(
nsINode
*
aNode
)
;
nsINode
*
PrevNode
(
nsINode
*
aNode
)
;
void
MakeEmpty
(
)
;
virtual
void
LastRelease
(
)
;
nsCOMPtr
<
nsINode
>
mCurNode
;
nsCOMPtr
<
nsINode
>
mFirst
;
nsCOMPtr
<
nsINode
>
mLast
;
nsCOMPtr
<
nsINode
>
mCommonParent
;
bool
mIsDone
;
bool
mPre
;
private
:
nsContentIterator
(
const
nsContentIterator
&
)
;
nsContentIterator
&
operator
=
(
const
nsContentIterator
&
)
;
}
;
already_AddRefed
<
nsIContentIterator
>
NS_NewContentIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentIterator
(
false
)
;
return
iter
.
forget
(
)
;
}
already_AddRefed
<
nsIContentIterator
>
NS_NewPreContentIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentIterator
(
true
)
;
return
iter
.
forget
(
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsContentIterator
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsContentIterator
LastRelease
(
)
)
NS_INTERFACE_MAP_BEGIN
(
nsContentIterator
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContentIterator
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsContentIterator
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsContentIterator
mCurNode
mFirst
mLast
mCommonParent
)
void
nsContentIterator
:
:
LastRelease
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mCommonParent
=
nullptr
;
}
nsContentIterator
:
:
nsContentIterator
(
bool
aPre
)
:
mIsDone
(
false
)
mPre
(
aPre
)
{
}
nsContentIterator
:
:
~
nsContentIterator
(
)
{
}
nsresult
nsContentIterator
:
:
Init
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
mIsDone
=
false
;
if
(
mPre
)
{
mFirst
=
aRoot
;
mLast
=
GetDeepLastChild
(
aRoot
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetDeepLastChild
returned
null
"
)
;
}
else
{
mFirst
=
GetDeepFirstChild
(
aRoot
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetDeepFirstChild
returned
null
"
)
;
mLast
=
aRoot
;
}
mCommonParent
=
aRoot
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
nsresult
nsContentIterator
:
:
Init
(
nsIDOMRange
*
aDOMRange
)
{
mIsDone
=
false
;
if
(
NS_WARN_IF
(
!
aDOMRange
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsRange
*
range
=
static_cast
<
nsRange
*
>
(
aDOMRange
)
;
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
)
;
}
nsresult
nsContentIterator
:
:
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
mIsDone
=
false
;
if
(
NS_WARN_IF
(
!
nsRange
:
:
IsValidPoints
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
InitInternal
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
;
}
nsresult
nsContentIterator
:
:
InitInternal
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
mCommonParent
=
nsContentUtils
:
:
GetCommonAncestor
(
aStartContainer
aEndContainer
)
;
if
(
NS_WARN_IF
(
!
mCommonParent
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
startIsData
=
aStartContainer
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
;
if
(
aStartContainer
=
=
aEndContainer
)
{
if
(
!
startIsData
&
&
aStartOffset
=
=
aEndOffset
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
if
(
startIsData
)
{
mFirst
=
aStartContainer
-
>
AsContent
(
)
;
mLast
=
mFirst
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
}
nsIContent
*
cChild
=
nullptr
;
if
(
!
startIsData
&
&
aStartOffset
<
aStartContainer
-
>
GetChildCount
(
)
)
{
cChild
=
aStartContainer
-
>
GetChildAt
(
aStartOffset
)
;
NS_WARNING_ASSERTION
(
cChild
"
GetChildAt
returned
null
"
)
;
}
if
(
!
cChild
)
{
if
(
mPre
)
{
bool
startIsContainer
=
true
;
if
(
aStartContainer
-
>
IsHTMLElement
(
)
)
{
nsIAtom
*
name
=
aStartContainer
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
startIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
if
(
!
startIsData
&
&
(
startIsContainer
|
|
aStartOffset
)
)
{
mFirst
=
GetNextSibling
(
aStartContainer
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetNextSibling
returned
null
"
)
;
if
(
mFirst
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mFirst
mPre
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
)
{
mFirst
=
nullptr
;
}
}
else
{
mFirst
=
aStartContainer
-
>
AsContent
(
)
;
}
}
else
{
if
(
NS_WARN_IF
(
!
aStartContainer
-
>
IsContent
(
)
)
)
{
mFirst
=
nullptr
;
}
else
{
mFirst
=
aStartContainer
-
>
AsContent
(
)
;
}
}
}
else
{
if
(
mPre
)
{
mFirst
=
cChild
;
}
else
{
mFirst
=
GetDeepFirstChild
(
cChild
)
;
NS_WARNING_ASSERTION
(
mFirst
"
GetDeepFirstChild
returned
null
"
)
;
if
(
mFirst
&
&
!
NodeIsInTraversalRange
(
mFirst
mPre
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
{
mFirst
=
nullptr
;
}
}
}
bool
endIsData
=
aEndContainer
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
;
if
(
endIsData
|
|
!
aEndContainer
-
>
HasChildren
(
)
|
|
!
aEndOffset
)
{
if
(
mPre
)
{
if
(
NS_WARN_IF
(
!
aEndContainer
-
>
IsContent
(
)
)
)
{
mLast
=
nullptr
;
}
else
{
bool
endIsContainer
=
true
;
if
(
aEndContainer
-
>
IsHTMLElement
(
)
)
{
nsIAtom
*
name
=
aEndContainer
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
endIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
if
(
!
endIsData
&
&
!
endIsContainer
&
&
!
aEndOffset
)
{
mLast
=
PrevNode
(
aEndContainer
)
;
NS_WARNING_ASSERTION
(
mLast
"
PrevNode
returned
null
"
)
;
if
(
mLast
&
&
mLast
!
=
mFirst
&
&
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mLast
mPre
mFirst
0
aEndContainer
aEndOffset
)
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
aEndContainer
-
>
AsContent
(
)
;
}
}
}
else
{
if
(
!
endIsData
)
{
mLast
=
GetPrevSibling
(
aEndContainer
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetPrevSibling
returned
null
"
)
;
if
(
!
NodeIsInTraversalRange
(
mLast
mPre
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
aEndContainer
-
>
AsContent
(
)
;
}
}
}
else
{
int32_t
indx
=
aEndOffset
;
cChild
=
aEndContainer
-
>
GetChildAt
(
-
-
indx
)
;
if
(
NS_WARN_IF
(
!
cChild
)
)
{
NS_NOTREACHED
(
"
nsContentIterator
:
:
nsContentIterator
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mPre
)
{
mLast
=
GetDeepLastChild
(
cChild
)
;
NS_WARNING_ASSERTION
(
mLast
"
GetDeepLastChild
returned
null
"
)
;
if
(
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mLast
mPre
aStartContainer
aStartOffset
aEndContainer
aEndOffset
)
)
)
{
mLast
=
nullptr
;
}
}
else
{
mLast
=
cChild
;
}
}
if
(
!
mFirst
|
|
!
mLast
)
{
mFirst
=
nullptr
;
mLast
=
nullptr
;
}
mCurNode
=
mFirst
;
mIsDone
=
!
mCurNode
;
return
NS_OK
;
}
void
nsContentIterator
:
:
MakeEmpty
(
)
{
mCurNode
=
nullptr
;
mFirst
=
nullptr
;
mLast
=
nullptr
;
mCommonParent
=
nullptr
;
mIsDone
=
true
;
}
nsINode
*
nsContentIterator
:
:
GetDeepFirstChild
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
return
GetDeepFirstChild
(
aRoot
-
>
GetFirstChild
(
)
)
;
}
nsIContent
*
nsContentIterator
:
:
GetDeepFirstChild
(
nsIContent
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
nsIContent
*
child
=
node
-
>
GetFirstChild
(
)
;
while
(
child
)
{
node
=
child
;
child
=
node
-
>
GetFirstChild
(
)
;
}
return
node
;
}
nsINode
*
nsContentIterator
:
:
GetDeepLastChild
(
nsINode
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
|
|
!
aRoot
-
>
HasChildren
(
)
)
{
return
aRoot
;
}
return
GetDeepLastChild
(
aRoot
-
>
GetLastChild
(
)
)
;
}
nsIContent
*
nsContentIterator
:
:
GetDeepLastChild
(
nsIContent
*
aRoot
)
{
if
(
NS_WARN_IF
(
!
aRoot
)
)
{
return
nullptr
;
}
nsIContent
*
node
=
aRoot
;
while
(
node
-
>
HasChildren
(
)
)
{
nsIContent
*
child
=
node
-
>
GetLastChild
(
)
;
node
=
child
;
}
return
node
;
}
nsIContent
*
nsContentIterator
:
:
GetNextSibling
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
GetNextSibling
(
)
)
{
return
aNode
-
>
GetNextSibling
(
)
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
ChromeOnlyAccess
(
)
&
&
parent
-
>
HasChildren
(
)
)
{
return
parent
-
>
GetFirstChild
(
)
;
}
return
GetNextSibling
(
parent
)
;
}
nsIContent
*
nsContentIterator
:
:
GetPrevSibling
(
nsINode
*
aNode
)
{
if
(
NS_WARN_IF
(
!
aNode
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
GetPreviousSibling
(
)
)
{
return
aNode
-
>
GetPreviousSibling
(
)
;
}
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
nullptr
;
}
if
(
aNode
-
>
ChromeOnlyAccess
(
)
&
&
parent
-
>
HasChildren
(
)
)
{
return
parent
-
>
GetFirstChild
(
)
;
}
return
GetPrevSibling
(
parent
)
;
}
nsINode
*
nsContentIterator
:
:
NextNode
(
nsINode
*
aNode
)
{
nsINode
*
node
=
aNode
;
if
(
mPre
)
{
if
(
node
-
>
HasChildren
(
)
)
{
nsIContent
*
firstChild
=
node
-
>
GetFirstChild
(
)
;
MOZ_ASSERT
(
firstChild
)
;
return
firstChild
;
}
return
GetNextSibling
(
node
)
;
}
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
MOZ_ASSERT
(
parent
"
The
node
is
the
root
node
but
not
the
last
node
"
)
;
mIsDone
=
true
;
return
node
;
}
nsIContent
*
sibling
=
node
-
>
GetNextSibling
(
)
;
if
(
sibling
)
{
return
GetDeepFirstChild
(
sibling
)
;
}
return
parent
;
}
nsINode
*
nsContentIterator
:
:
PrevNode
(
nsINode
*
aNode
)
{
nsINode
*
node
=
aNode
;
if
(
mPre
)
{
nsINode
*
parent
=
node
-
>
GetParentNode
(
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
MOZ_ASSERT
(
parent
"
The
node
is
the
root
node
but
not
the
first
node
"
)
;
mIsDone
=
true
;
return
aNode
;
}
nsIContent
*
sibling
=
node
-
>
GetPreviousSibling
(
)
;
if
(
sibling
)
{
return
GetDeepLastChild
(
sibling
)
;
}
return
parent
;
}
if
(
node
-
>
HasChildren
(
)
)
{
return
node
-
>
GetLastChild
(
)
;
}
return
GetPrevSibling
(
node
)
;
}
void
nsContentIterator
:
:
First
(
)
{
if
(
mFirst
)
{
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mFirst
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
}
mIsDone
=
mFirst
=
=
nullptr
;
}
void
nsContentIterator
:
:
Last
(
)
{
if
(
!
mLast
)
{
MOZ_ASSERT
(
mIsDone
)
;
return
;
}
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
PositionAt
(
mLast
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
position
iterator
!
"
)
;
mIsDone
=
mLast
=
=
nullptr
;
}
void
nsContentIterator
:
:
Next
(
)
{
if
(
mIsDone
|
|
NS_WARN_IF
(
!
mCurNode
)
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mIsDone
=
true
;
return
;
}
mCurNode
=
NextNode
(
mCurNode
)
;
}
void
nsContentIterator
:
:
Prev
(
)
{
if
(
NS_WARN_IF
(
mIsDone
)
|
|
NS_WARN_IF
(
!
mCurNode
)
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mIsDone
=
true
;
return
;
}
mCurNode
=
PrevNode
(
mCurNode
)
;
}
bool
nsContentIterator
:
:
IsDone
(
)
{
return
mIsDone
;
}
nsresult
nsContentIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
if
(
NS_WARN_IF
(
!
aCurNode
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
mCurNode
=
=
aCurNode
)
{
mIsDone
=
false
;
return
NS_OK
;
}
mCurNode
=
aCurNode
;
nsINode
*
firstNode
=
mFirst
;
nsINode
*
lastNode
=
mLast
;
int32_t
firstOffset
=
0
lastOffset
=
0
;
if
(
firstNode
&
&
lastNode
)
{
if
(
mPre
)
{
firstNode
=
NodeToParentOffset
(
mFirst
&
firstOffset
)
;
NS_WARNING_ASSERTION
(
firstNode
"
NodeToParentOffset
returned
null
"
)
;
NS_WARNING_ASSERTION
(
firstOffset
>
=
0
"
bad
firstOffset
"
)
;
if
(
lastNode
-
>
GetChildCount
(
)
)
{
lastOffset
=
0
;
}
else
{
lastNode
=
NodeToParentOffset
(
mLast
&
lastOffset
)
;
NS_WARNING_ASSERTION
(
lastNode
"
NodeToParentOffset
returned
null
"
)
;
NS_WARNING_ASSERTION
(
lastOffset
>
=
0
"
bad
lastOffset
"
)
;
+
+
lastOffset
;
}
}
else
{
uint32_t
numChildren
=
firstNode
-
>
GetChildCount
(
)
;
if
(
numChildren
)
{
firstOffset
=
numChildren
;
NS_WARNING_ASSERTION
(
firstOffset
>
=
0
"
bad
firstOffset
"
)
;
}
else
{
firstNode
=
NodeToParentOffset
(
mFirst
&
firstOffset
)
;
NS_WARNING_ASSERTION
(
firstNode
"
NodeToParentOffset
returned
null
"
)
;
NS_WARNING_ASSERTION
(
firstOffset
>
=
0
"
bad
firstOffset
"
)
;
}
lastNode
=
NodeToParentOffset
(
mLast
&
lastOffset
)
;
NS_WARNING_ASSERTION
(
lastNode
"
NodeToParentOffset
returned
null
"
)
;
NS_WARNING_ASSERTION
(
lastOffset
>
=
0
"
bad
lastOffset
"
)
;
+
+
lastOffset
;
}
}
if
(
mFirst
!
=
mCurNode
&
&
mLast
!
=
mCurNode
&
&
(
NS_WARN_IF
(
!
firstNode
)
|
|
NS_WARN_IF
(
!
lastNode
)
|
|
NS_WARN_IF
(
!
NodeIsInTraversalRange
(
mCurNode
mPre
firstNode
firstOffset
lastNode
lastOffset
)
)
)
)
{
mIsDone
=
true
;
return
NS_ERROR_FAILURE
;
}
mIsDone
=
false
;
return
NS_OK
;
}
nsINode
*
nsContentIterator
:
:
GetCurrentNode
(
)
{
if
(
mIsDone
)
{
return
nullptr
;
}
NS_ASSERTION
(
mCurNode
"
Null
current
node
in
an
iterator
that
'
s
not
done
!
"
)
;
return
mCurNode
;
}
class
nsContentSubtreeIterator
:
public
nsContentIterator
{
public
:
nsContentSubtreeIterator
(
)
:
nsContentIterator
(
false
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
virtual
nsresult
Init
(
nsINode
*
aRoot
)
override
;
virtual
nsresult
Init
(
nsIDOMRange
*
aRange
)
override
;
virtual
nsresult
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
override
;
virtual
void
Next
(
)
override
;
virtual
void
Prev
(
)
override
;
virtual
nsresult
PositionAt
(
nsINode
*
aCurNode
)
override
;
virtual
void
First
(
)
override
;
virtual
void
Last
(
)
override
;
protected
:
virtual
~
nsContentSubtreeIterator
(
)
{
}
nsresult
InitWithRange
(
)
;
nsIContent
*
GetTopAncestorInRange
(
nsINode
*
aNode
)
;
nsContentSubtreeIterator
(
const
nsContentSubtreeIterator
&
)
;
nsContentSubtreeIterator
&
operator
=
(
const
nsContentSubtreeIterator
&
)
;
virtual
void
LastRelease
(
)
override
;
RefPtr
<
nsRange
>
mRange
;
AutoTArray
<
nsIContent
*
8
>
mEndNodes
;
AutoTArray
<
int32_t
8
>
mEndOffsets
;
}
;
NS_IMPL_ADDREF_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
NS_IMPL_RELEASE_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsContentSubtreeIterator
)
NS_INTERFACE_MAP_END_INHERITING
(
nsContentIterator
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsContentSubtreeIterator
nsContentIterator
mRange
)
void
nsContentSubtreeIterator
:
:
LastRelease
(
)
{
mRange
=
nullptr
;
nsContentIterator
:
:
LastRelease
(
)
;
}
already_AddRefed
<
nsIContentIterator
>
NS_NewContentSubtreeIterator
(
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
new
nsContentSubtreeIterator
(
)
;
return
iter
.
forget
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsINode
*
aRoot
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsIDOMRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
mIsDone
=
false
;
nsRange
*
range
=
static_cast
<
nsRange
*
>
(
aRange
)
;
if
(
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mRange
=
range
;
return
InitWithRange
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
Init
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
mIsDone
=
false
;
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
getter_AddRefs
(
range
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
!
range
)
|
|
NS_WARN_IF
(
!
range
-
>
IsPositioned
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
NS_WARN_IF
(
range
-
>
GetStartContainer
(
)
!
=
aStartContainer
)
|
|
NS_WARN_IF
(
range
-
>
GetEndContainer
(
)
!
=
aEndContainer
)
|
|
NS_WARN_IF
(
range
-
>
StartOffset
(
)
!
=
aStartOffset
)
|
|
NS_WARN_IF
(
range
-
>
EndOffset
(
)
!
=
aEndOffset
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mRange
=
Move
(
range
)
;
return
InitWithRange
(
)
;
}
nsresult
nsContentSubtreeIterator
:
:
InitWithRange
(
)
{
MOZ_ASSERT
(
mRange
)
;
MOZ_ASSERT
(
mRange
-
>
IsPositioned
(
)
)
;
mCommonParent
=
mRange
-
>
GetCommonAncestor
(
)
;
nsINode
*
startContainer
=
mRange
-
>
GetStartContainer
(
)
;
int32_t
startOffset
=
mRange
-
>
StartOffset
(
)
;
nsINode
*
endContainer
=
mRange
-
>
GetEndContainer
(
)
;
int32_t
endOffset
=
mRange
-
>
EndOffset
(
)
;
MOZ_ASSERT
(
mCommonParent
&
&
startContainer
&
&
endContainer
)
;
MOZ_ASSERT
(
uint32_t
(
startOffset
)
<
=
startContainer
-
>
Length
(
)
&
&
uint32_t
(
endOffset
)
<
=
endContainer
-
>
Length
(
)
)
;
if
(
startContainer
=
=
endContainer
)
{
nsINode
*
child
=
startContainer
-
>
GetFirstChild
(
)
;
if
(
!
child
|
|
startOffset
=
=
endOffset
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
}
nsContentUtils
:
:
GetAncestorsAndOffsets
(
endContainer
-
>
AsDOMNode
(
)
endOffset
&
mEndNodes
&
mEndOffsets
)
;
nsIContent
*
firstCandidate
=
nullptr
;
nsIContent
*
lastCandidate
=
nullptr
;
int32_t
offset
=
mRange
-
>
StartOffset
(
)
;
nsINode
*
node
=
nullptr
;
if
(
!
startContainer
-
>
GetChildCount
(
)
)
{
node
=
startContainer
;
}
else
{
nsIContent
*
child
=
startContainer
-
>
GetChildAt
(
offset
)
;
if
(
!
child
)
{
node
=
startContainer
;
}
else
{
firstCandidate
=
child
;
}
}
if
(
!
firstCandidate
)
{
firstCandidate
=
GetNextSibling
(
node
)
;
if
(
!
firstCandidate
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
}
firstCandidate
=
GetDeepFirstChild
(
firstCandidate
)
;
bool
nodeBefore
nodeAfter
;
MOZ_ALWAYS_SUCCEEDS
(
nsRange
:
:
CompareNodeToRange
(
firstCandidate
mRange
&
nodeBefore
&
nodeAfter
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
mFirst
=
GetTopAncestorInRange
(
firstCandidate
)
;
offset
=
mRange
-
>
EndOffset
(
)
;
int32_t
numChildren
=
endContainer
-
>
GetChildCount
(
)
;
if
(
offset
>
numChildren
)
{
offset
=
numChildren
;
}
if
(
!
offset
|
|
!
numChildren
)
{
node
=
endContainer
;
}
else
{
lastCandidate
=
endContainer
-
>
GetChildAt
(
-
-
offset
)
;
NS_ASSERTION
(
lastCandidate
"
tree
traversal
trouble
in
nsContentSubtreeIterator
:
:
Init
"
)
;
}
if
(
!
lastCandidate
)
{
lastCandidate
=
GetPrevSibling
(
node
)
;
}
if
(
!
lastCandidate
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
lastCandidate
=
GetDeepLastChild
(
lastCandidate
)
;
MOZ_ALWAYS_SUCCEEDS
(
nsRange
:
:
CompareNodeToRange
(
lastCandidate
mRange
&
nodeBefore
&
nodeAfter
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
MakeEmpty
(
)
;
return
NS_OK
;
}
mLast
=
GetTopAncestorInRange
(
lastCandidate
)
;
mCurNode
=
mFirst
;
return
NS_OK
;
}
void
nsContentSubtreeIterator
:
:
First
(
)
{
mIsDone
=
mFirst
=
=
nullptr
;
mCurNode
=
mFirst
;
}
void
nsContentSubtreeIterator
:
:
Last
(
)
{
mIsDone
=
mLast
=
=
nullptr
;
mCurNode
=
mLast
;
}
void
nsContentSubtreeIterator
:
:
Next
(
)
{
if
(
mIsDone
|
|
!
mCurNode
)
{
return
;
}
if
(
mCurNode
=
=
mLast
)
{
mIsDone
=
true
;
return
;
}
nsINode
*
nextNode
=
GetNextSibling
(
mCurNode
)
;
NS_ASSERTION
(
nextNode
"
No
next
sibling
!
?
!
This
could
mean
deadlock
!
"
)
;
int32_t
i
=
mEndNodes
.
IndexOf
(
nextNode
)
;
while
(
i
!
=
-
1
)
{
nextNode
=
nextNode
-
>
GetFirstChild
(
)
;
NS_ASSERTION
(
nextNode
"
Iterator
error
expected
a
child
node
!
"
)
;
i
=
mEndNodes
.
IndexOf
(
nextNode
)
;
}
mCurNode
=
nextNode
;
mIsDone
=
mCurNode
=
=
nullptr
;
}
void
nsContentSubtreeIterator
:
:
Prev
(
)
{
if
(
mIsDone
|
|
!
mCurNode
)
{
return
;
}
if
(
mCurNode
=
=
mFirst
)
{
mIsDone
=
true
;
return
;
}
nsINode
*
prevNode
=
GetDeepFirstChild
(
mCurNode
)
;
prevNode
=
PrevNode
(
prevNode
)
;
prevNode
=
GetDeepLastChild
(
prevNode
)
;
mCurNode
=
GetTopAncestorInRange
(
prevNode
)
;
mIsDone
=
mCurNode
=
=
nullptr
;
}
nsresult
nsContentSubtreeIterator
:
:
PositionAt
(
nsINode
*
aCurNode
)
{
NS_ERROR
(
"
Not
implemented
!
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIContent
*
nsContentSubtreeIterator
:
:
GetTopAncestorInRange
(
nsINode
*
aNode
)
{
if
(
!
aNode
|
|
!
aNode
-
>
GetParentNode
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
bool
nodeBefore
nodeAfter
;
nsresult
res
=
nsRange
:
:
CompareNodeToRange
(
aNode
mRange
&
nodeBefore
&
nodeAfter
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
&
&
!
nodeBefore
&
&
!
nodeAfter
"
aNode
isn
'
t
in
mRange
or
something
else
weird
happened
"
)
;
if
(
NS_FAILED
(
res
)
|
|
nodeBefore
|
|
nodeAfter
)
{
return
nullptr
;
}
while
(
content
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
GetParentNode
(
)
)
{
return
content
;
}
MOZ_ALWAYS_SUCCEEDS
(
nsRange
:
:
CompareNodeToRange
(
parent
mRange
&
nodeBefore
&
nodeAfter
)
)
;
if
(
nodeBefore
|
|
nodeAfter
)
{
return
content
;
}
content
=
parent
;
}
MOZ_CRASH
(
"
This
should
only
be
possible
if
aNode
was
null
"
)
;
}
