#
include
"
nsTextNode
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
TextBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
MOZ_DOM_LIST
#
include
"
nsRange
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsAttributeTextNode
final
:
public
nsTextNode
public
nsStubMutationObserver
{
public
:
NS_DECL_ISUPPORTS_INHERITED
nsAttributeTextNode
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
int32_t
aNameSpaceID
nsAtom
*
aAttrName
nsAtom
*
aFallback
)
:
nsTextNode
(
std
:
:
move
(
aNodeInfo
)
)
mGrandparent
(
nullptr
)
mNameSpaceID
(
aNameSpaceID
)
mAttrName
(
aAttrName
)
mFallback
(
aFallback
)
{
NS_ASSERTION
(
mNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
know
namespace
"
)
;
NS_ASSERTION
(
mAttrName
"
Must
have
attr
name
"
)
;
}
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
void
UnbindFromTree
(
UnbindContext
&
)
override
;
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
already_AddRefed
<
CharacterData
>
CloneDataNode
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
bool
aCloneText
)
const
override
{
RefPtr
<
nsAttributeTextNode
>
it
=
new
(
aNodeInfo
-
>
NodeInfoManager
(
)
)
nsAttributeTextNode
(
do_AddRef
(
aNodeInfo
)
mNameSpaceID
mAttrName
mFallback
)
;
if
(
aCloneText
)
{
it
-
>
mBuffer
=
mBuffer
;
}
return
it
.
forget
(
)
;
}
void
UpdateText
(
)
{
UpdateText
(
true
)
;
}
private
:
virtual
~
nsAttributeTextNode
(
)
{
NS_ASSERTION
(
!
mGrandparent
"
We
were
not
unbound
!
"
)
;
}
void
UpdateText
(
bool
aNotify
)
;
Element
*
mGrandparent
;
int32_t
mNameSpaceID
;
RefPtr
<
nsAtom
>
mAttrName
;
RefPtr
<
nsAtom
>
mFallback
;
}
;
nsTextNode
:
:
~
nsTextNode
(
)
=
default
;
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
nsTextNode
CharacterData
)
JSObject
*
nsTextNode
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Text_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
CharacterData
>
nsTextNode
:
:
CloneDataNode
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
bool
aCloneText
)
const
{
RefPtr
<
nsTextNode
>
it
=
new
(
aNodeInfo
-
>
NodeInfoManager
(
)
)
nsTextNode
(
do_AddRef
(
aNodeInfo
)
)
;
if
(
aCloneText
)
{
it
-
>
mBuffer
=
mBuffer
;
}
return
it
.
forget
(
)
;
}
nsresult
nsTextNode
:
:
AppendTextForNormalize
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aNotify
nsIContent
*
aNextSibling
)
{
CharacterDataChangeInfo
:
:
Details
details
=
{
CharacterDataChangeInfo
:
:
Details
:
:
eMerge
aNextSibling
}
;
return
SetTextInternal
(
mBuffer
.
GetLength
(
)
0
aBuffer
aLength
aNotify
&
details
)
;
}
#
ifdef
MOZ_DOM_LIST
void
nsTextNode
:
:
List
(
FILE
*
out
int32_t
aIndent
)
const
{
int32_t
index
;
for
(
index
=
aIndent
;
-
-
index
>
=
0
;
)
fputs
(
"
"
out
)
;
fprintf
(
out
"
Text
%
p
"
static_cast
<
const
void
*
>
(
this
)
)
;
fprintf
(
out
"
flags
=
[
%
08x
]
"
static_cast
<
unsigned
int
>
(
GetFlags
(
)
)
)
;
if
(
IsClosestCommonInclusiveAncestorForRangeInSelection
(
)
)
{
const
LinkedList
<
AbstractRange
>
*
ranges
=
GetExistingClosestCommonInclusiveAncestorRanges
(
)
;
uint32_t
count
=
ranges
?
ranges
-
>
length
(
)
:
0
;
fprintf
(
out
"
ranges
:
%
d
"
count
)
;
}
fprintf
(
out
"
primaryframe
=
%
p
"
static_cast
<
void
*
>
(
GetPrimaryFrame
(
)
)
)
;
fprintf
(
out
"
refcount
=
%
"
PRIuPTR
"
<
"
mRefCnt
.
get
(
)
)
;
nsAutoString
tmp
;
ToCString
(
tmp
0
mBuffer
.
GetLength
(
)
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
tmp
)
.
get
(
)
out
)
;
fputs
(
"
>
\
n
"
out
)
;
}
void
nsTextNode
:
:
DumpContent
(
FILE
*
out
int32_t
aIndent
bool
aDumpAll
)
const
{
if
(
aDumpAll
)
{
int32_t
index
;
for
(
index
=
aIndent
;
-
-
index
>
=
0
;
)
fputs
(
"
"
out
)
;
nsAutoString
tmp
;
ToCString
(
tmp
0
mBuffer
.
GetLength
(
)
)
;
if
(
!
tmp
.
EqualsLiteral
(
"
\
\
n
"
)
)
{
fputs
(
NS_LossyConvertUTF16toASCII
(
tmp
)
.
get
(
)
out
)
;
if
(
aIndent
)
fputs
(
"
\
n
"
out
)
;
}
}
}
#
endif
nsresult
NS_NewAttributeContent
(
nsNodeInfoManager
*
aNodeInfoManager
int32_t
aNameSpaceID
nsAtom
*
aAttrName
nsAtom
*
aFallback
nsIContent
*
*
aResult
)
{
MOZ_ASSERT
(
aNodeInfoManager
"
Missing
nodeInfoManager
"
)
;
MOZ_ASSERT
(
aAttrName
"
Must
have
an
attr
name
"
)
;
MOZ_ASSERT
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
know
namespace
"
)
;
*
aResult
=
nullptr
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
aNodeInfoManager
-
>
GetTextNodeInfo
(
)
;
RefPtr
<
nsAttributeTextNode
>
textNode
=
new
(
aNodeInfoManager
)
nsAttributeTextNode
(
ni
.
forget
(
)
aNameSpaceID
aAttrName
aFallback
)
;
textNode
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsAttributeTextNode
nsTextNode
nsIMutationObserver
)
nsresult
nsAttributeTextNode
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
MOZ_ASSERT
(
aParent
.
IsContent
(
)
&
&
aParent
.
GetParent
(
)
"
This
node
can
'
t
be
a
child
of
the
document
or
of
"
"
the
document
root
"
)
;
nsresult
rv
=
nsTextNode
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
!
mGrandparent
"
We
were
already
bound
!
"
)
;
mGrandparent
=
aParent
.
GetParent
(
)
-
>
AsElement
(
)
;
mGrandparent
-
>
AddMutationObserver
(
this
)
;
UpdateText
(
false
)
;
return
NS_OK
;
}
void
nsAttributeTextNode
:
:
UnbindFromTree
(
UnbindContext
&
aContext
)
{
if
(
mGrandparent
)
{
mGrandparent
-
>
RemoveMutationObserver
(
this
)
;
mGrandparent
=
nullptr
;
}
nsTextNode
:
:
UnbindFromTree
(
aContext
)
;
}
void
nsAttributeTextNode
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aNameSpaceID
=
=
mNameSpaceID
&
&
aAttribute
=
=
mAttrName
&
&
aElement
=
=
mGrandparent
)
{
void
(
nsAttributeTextNode
:
:
*
update
)
(
)
=
&
nsAttributeTextNode
:
:
UpdateText
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
nsAttributeTextNode
:
:
AttributeChanged
"
this
update
)
)
;
}
}
void
nsAttributeTextNode
:
:
NodeWillBeDestroyed
(
nsINode
*
aNode
)
{
NS_ASSERTION
(
aNode
=
=
static_cast
<
nsINode
*
>
(
mGrandparent
)
"
Wrong
node
!
"
)
;
mGrandparent
=
nullptr
;
}
void
nsAttributeTextNode
:
:
UpdateText
(
bool
aNotify
)
{
if
(
mGrandparent
)
{
nsAutoString
attrValue
;
if
(
!
mGrandparent
-
>
GetAttr
(
mNameSpaceID
mAttrName
attrValue
)
)
{
mFallback
-
>
ToString
(
attrValue
)
;
}
SetText
(
attrValue
aNotify
)
;
}
}
