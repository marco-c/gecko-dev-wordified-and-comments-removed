#
ifndef
mozilla_IdentifierMapEntry_h
#
define
mozilla_IdentifierMapEntry_h
#
include
<
utility
>
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
TreeOrderedArray
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
class
nsIContent
;
class
nsINode
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
class
Element
;
}
class
IdentifierMapEntry
:
public
PLDHashEntryHdr
{
typedef
dom
:
:
Document
Document
;
typedef
dom
:
:
Element
Element
;
typedef
bool
(
*
IDTargetObserver
)
(
Element
*
aOldElement
Element
*
aNewelement
void
*
aData
)
;
public
:
struct
DependentAtomOrString
final
{
MOZ_IMPLICIT
DependentAtomOrString
(
nsAtom
*
aAtom
)
:
mAtom
(
aAtom
)
mString
(
nullptr
)
{
}
MOZ_IMPLICIT
DependentAtomOrString
(
const
nsAString
&
aString
)
:
mAtom
(
nullptr
)
mString
(
&
aString
)
{
}
DependentAtomOrString
(
const
DependentAtomOrString
&
aOther
)
=
default
;
nsAtom
*
mAtom
;
const
nsAString
*
mString
;
}
;
typedef
const
DependentAtomOrString
&
KeyType
;
typedef
const
DependentAtomOrString
*
KeyTypePointer
;
explicit
IdentifierMapEntry
(
const
DependentAtomOrString
*
aKey
)
;
IdentifierMapEntry
(
IdentifierMapEntry
&
&
aOther
)
=
default
;
~
IdentifierMapEntry
(
)
=
default
;
nsString
GetKeyAsString
(
)
const
{
if
(
mKey
.
mAtom
)
{
return
nsAtomString
(
mKey
.
mAtom
)
;
}
return
mKey
.
mString
;
}
bool
KeyEquals
(
const
KeyTypePointer
aOtherKey
)
const
{
if
(
mKey
.
mAtom
)
{
if
(
aOtherKey
-
>
mAtom
)
{
return
mKey
.
mAtom
=
=
aOtherKey
-
>
mAtom
;
}
return
mKey
.
mAtom
-
>
Equals
(
*
aOtherKey
-
>
mString
)
;
}
if
(
aOtherKey
-
>
mAtom
)
{
return
aOtherKey
-
>
mAtom
-
>
Equals
(
mKey
.
mString
)
;
}
return
mKey
.
mString
.
Equals
(
*
aOtherKey
-
>
mString
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
const
KeyTypePointer
aKey
)
{
return
aKey
-
>
mAtom
?
aKey
-
>
mAtom
-
>
hash
(
)
:
HashString
(
*
aKey
-
>
mString
)
;
}
enum
{
ALLOW_MEMMOVE
=
false
}
;
void
AddNameElement
(
nsINode
*
aDocument
Element
*
aElement
)
;
void
RemoveNameElement
(
Element
*
aElement
)
;
bool
IsEmpty
(
)
;
nsBaseContentList
*
GetNameContentList
(
)
{
return
mNameContentList
;
}
bool
HasNameElement
(
)
const
;
Element
*
GetIdElement
(
)
{
return
mIdContentList
-
>
SafeElementAt
(
0
)
;
}
const
nsTArray
<
Element
*
>
&
GetIdElements
(
)
const
{
return
mIdContentList
;
}
Element
*
GetImageIdElement
(
)
{
return
mImageElement
?
mImageElement
.
get
(
)
:
GetIdElement
(
)
;
}
void
AddIdElement
(
Element
*
aElement
)
;
void
RemoveIdElement
(
Element
*
aElement
)
;
void
SetImageElement
(
Element
*
aElement
)
;
bool
HasIdElementExposedAsHTMLDocumentProperty
(
)
;
bool
HasContentChangeCallback
(
)
{
return
mChangeCallbacks
!
=
nullptr
;
}
void
AddContentChangeCallback
(
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
;
void
RemoveContentChangeCallback
(
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
;
void
ClearAndNotify
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
;
struct
ChangeCallback
{
IDTargetObserver
mCallback
;
void
*
mData
;
bool
mForImage
;
}
;
struct
ChangeCallbackEntry
:
public
PLDHashEntryHdr
{
typedef
const
ChangeCallback
KeyType
;
typedef
const
ChangeCallback
*
KeyTypePointer
;
explicit
ChangeCallbackEntry
(
const
ChangeCallback
*
aKey
)
:
mKey
(
*
aKey
)
{
}
ChangeCallbackEntry
(
ChangeCallbackEntry
&
&
aOther
)
:
PLDHashEntryHdr
(
std
:
:
move
(
aOther
)
)
mKey
(
std
:
:
move
(
aOther
.
mKey
)
)
{
}
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
-
>
mCallback
=
=
mKey
.
mCallback
&
&
aKey
-
>
mData
=
=
mKey
.
mData
&
&
aKey
-
>
mForImage
=
=
mKey
.
mForImage
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
HashGeneric
(
aKey
-
>
mCallback
aKey
-
>
mData
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
ChangeCallback
mKey
;
}
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
struct
OwningAtomOrString
final
{
OwningAtomOrString
(
const
OwningAtomOrString
&
aOther
)
=
delete
;
OwningAtomOrString
(
OwningAtomOrString
&
&
aOther
)
=
default
;
explicit
OwningAtomOrString
(
const
DependentAtomOrString
&
aOther
)
:
mAtom
(
aOther
.
mAtom
)
mString
(
aOther
.
mString
?
*
aOther
.
mString
:
u
"
"
_ns
)
{
}
RefPtr
<
nsAtom
>
mAtom
;
nsString
mString
;
}
;
IdentifierMapEntry
(
const
IdentifierMapEntry
&
aOther
)
=
delete
;
IdentifierMapEntry
&
operator
=
(
const
IdentifierMapEntry
&
aOther
)
=
delete
;
void
FireChangeCallbacks
(
Element
*
aOldElement
Element
*
aNewElement
bool
aImageOnly
=
false
)
;
OwningAtomOrString
mKey
;
dom
:
:
TreeOrderedArray
<
Element
>
mIdContentList
;
RefPtr
<
nsBaseContentList
>
mNameContentList
;
UniquePtr
<
nsTHashtable
<
ChangeCallbackEntry
>
>
mChangeCallbacks
;
RefPtr
<
Element
>
mImageElement
;
}
;
}
#
endif
