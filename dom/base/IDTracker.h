#
ifndef
mozilla_dom_IDTracker_h_
#
define
mozilla_dom_IDTracker_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsIURI
;
class
nsIReferrerInfo
;
namespace
mozilla
{
namespace
dom
{
class
IDTracker
{
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
IDTracker
(
)
=
default
;
~
IDTracker
(
)
{
Unlink
(
)
;
}
Element
*
get
(
)
{
return
mElement
;
}
void
ResetToURIFragmentID
(
nsIContent
*
aFrom
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
bool
aWatch
=
true
bool
aReferenceImage
=
false
)
;
void
ResetWithID
(
Element
&
aFrom
nsAtom
*
aID
bool
aWatch
=
true
)
;
void
Unlink
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCB
)
;
protected
:
virtual
void
ElementChanged
(
Element
*
aFrom
Element
*
aTo
)
{
mElement
=
aTo
;
}
virtual
bool
IsPersistent
(
)
{
return
false
;
}
void
HaveNewDocumentOrShadowRoot
(
DocumentOrShadowRoot
*
bool
aWatch
const
nsString
&
aRef
)
;
private
:
static
bool
Observe
(
Element
*
aOldElement
Element
*
aNewElement
void
*
aData
)
;
class
Notification
:
public
nsISupports
{
public
:
virtual
void
SetTo
(
Element
*
aTo
)
=
0
;
virtual
void
Clear
(
)
{
mTarget
=
nullptr
;
}
virtual
~
Notification
(
)
{
}
protected
:
explicit
Notification
(
IDTracker
*
aTarget
)
:
mTarget
(
aTarget
)
{
MOZ_ASSERT
(
aTarget
"
Must
have
a
target
"
)
;
}
IDTracker
*
mTarget
;
}
;
class
ChangeNotification
:
public
mozilla
:
:
Runnable
public
Notification
{
public
:
ChangeNotification
(
IDTracker
*
aTarget
Element
*
aFrom
Element
*
aTo
)
:
mozilla
:
:
Runnable
(
"
IDTracker
:
:
ChangeNotification
"
)
Notification
(
aTarget
)
mFrom
(
aFrom
)
mTo
(
aTo
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
Run
(
)
override
{
if
(
mTarget
)
{
mTarget
-
>
mPendingNotification
=
nullptr
;
mTarget
-
>
ElementChanged
(
mFrom
mTo
)
;
}
return
NS_OK
;
}
virtual
void
SetTo
(
Element
*
aTo
)
override
{
mTo
=
aTo
;
}
virtual
void
Clear
(
)
override
{
Notification
:
:
Clear
(
)
;
mFrom
=
nullptr
;
mTo
=
nullptr
;
}
protected
:
virtual
~
ChangeNotification
(
)
{
}
RefPtr
<
Element
>
mFrom
;
RefPtr
<
Element
>
mTo
;
}
;
friend
class
ChangeNotification
;
class
DocumentLoadNotification
:
public
Notification
public
nsIObserver
{
public
:
DocumentLoadNotification
(
IDTracker
*
aTarget
const
nsString
&
aRef
)
:
Notification
(
aTarget
)
{
if
(
!
mTarget
-
>
IsPersistent
(
)
)
{
mRef
=
aRef
;
}
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
virtual
~
DocumentLoadNotification
(
)
{
}
virtual
void
SetTo
(
Element
*
aTo
)
override
{
}
nsString
mRef
;
}
;
friend
class
DocumentLoadNotification
;
DocumentOrShadowRoot
*
GetWatchDocOrShadowRoot
(
)
const
{
if
(
!
mWatchDocumentOrShadowRoot
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mWatchDocumentOrShadowRoot
-
>
IsDocument
(
)
|
|
mWatchDocumentOrShadowRoot
-
>
IsShadowRoot
(
)
)
;
if
(
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNode
(
*
mWatchDocumentOrShadowRoot
)
)
{
return
shadow
;
}
return
mWatchDocumentOrShadowRoot
-
>
AsDocument
(
)
;
}
RefPtr
<
nsAtom
>
mWatchID
;
nsCOMPtr
<
nsINode
>
mWatchDocumentOrShadowRoot
;
RefPtr
<
Element
>
mElement
;
RefPtr
<
Notification
>
mPendingNotification
;
bool
mReferencingImage
=
false
;
}
;
inline
void
ImplCycleCollectionUnlink
(
IDTracker
&
aField
)
{
aField
.
Unlink
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
IDTracker
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
&
aCallback
)
;
}
}
}
#
endif
