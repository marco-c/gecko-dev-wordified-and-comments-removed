#
ifndef
DOMIntersectionObserver_h
#
define
DOMIntersectionObserver_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
IntersectionObserverBinding
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashSet
.
h
"
namespace
mozilla
:
:
dom
{
class
DOMIntersectionObserver
;
class
DOMIntersectionObserverEntry
final
:
public
nsISupports
public
nsWrapperCache
{
~
DOMIntersectionObserverEntry
(
)
=
default
;
public
:
DOMIntersectionObserverEntry
(
nsISupports
*
aOwner
DOMHighResTimeStamp
aTime
RefPtr
<
DOMRect
>
aRootBounds
RefPtr
<
DOMRect
>
aBoundingClientRect
RefPtr
<
DOMRect
>
aIntersectionRect
bool
aIsIntersecting
Element
*
aTarget
double
aIntersectionRatio
)
:
mOwner
(
aOwner
)
mTime
(
aTime
)
mRootBounds
(
std
:
:
move
(
aRootBounds
)
)
mBoundingClientRect
(
std
:
:
move
(
aBoundingClientRect
)
)
mIntersectionRect
(
std
:
:
move
(
aIntersectionRect
)
)
mIsIntersecting
(
aIsIntersecting
)
mTarget
(
aTarget
)
mIntersectionRatio
(
aIntersectionRatio
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
DOMIntersectionObserverEntry
)
nsISupports
*
GetParentObject
(
)
const
{
return
mOwner
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
IntersectionObserverEntry_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
DOMHighResTimeStamp
Time
(
)
const
{
return
mTime
;
}
DOMRect
*
GetRootBounds
(
)
{
return
mRootBounds
;
}
DOMRect
*
BoundingClientRect
(
)
{
return
mBoundingClientRect
;
}
DOMRect
*
IntersectionRect
(
)
{
return
mIntersectionRect
;
}
bool
IsIntersecting
(
)
const
{
return
mIsIntersecting
;
}
double
IntersectionRatio
(
)
const
{
return
mIntersectionRatio
;
}
Element
*
Target
(
)
{
return
mTarget
;
}
protected
:
nsCOMPtr
<
nsISupports
>
mOwner
;
DOMHighResTimeStamp
mTime
;
RefPtr
<
DOMRect
>
mRootBounds
;
RefPtr
<
DOMRect
>
mBoundingClientRect
;
RefPtr
<
DOMRect
>
mIntersectionRect
;
bool
mIsIntersecting
;
RefPtr
<
Element
>
mTarget
;
double
mIntersectionRatio
;
}
;
#
define
NS_DOM_INTERSECTION_OBSERVER_IID
\
{
0x8570a575
0xe303
0x4d18
{
0xb6
0xb1
0x4d
0x2b
0x49
0xd8
0xef
0x94
}
}
using
IntersectionObserverMargin
=
StyleRect
<
LengthPercentage
>
;
struct
IntersectionInput
{
const
bool
mIsImplicitRoot
=
false
;
const
nsINode
*
mRootNode
=
nullptr
;
nsIFrame
*
mRootFrame
=
nullptr
;
nsRect
mRootRect
;
nsMargin
mRootMargin
;
IntersectionObserverMargin
mScrollMargin
;
Maybe
<
nsRect
>
mRemoteDocumentVisibleRect
;
}
;
struct
IntersectionOutput
{
const
bool
mIsSimilarOrigin
;
const
nsRect
mRootBounds
;
const
nsRect
mTargetRect
;
const
Maybe
<
nsRect
>
mIntersectionRect
;
const
bool
mPreservesAxisAlignedRectangles
;
bool
Intersects
(
)
const
{
return
mIntersectionRect
.
isSome
(
)
;
}
}
;
class
DOMIntersectionObserver
final
:
public
nsISupports
public
nsWrapperCache
{
virtual
~
DOMIntersectionObserver
(
)
{
Disconnect
(
)
;
}
using
NativeCallback
=
void
(
*
)
(
const
Sequence
<
OwningNonNull
<
DOMIntersectionObserverEntry
>
>
&
aEntries
)
;
DOMIntersectionObserver
(
Document
&
NativeCallback
)
;
public
:
DOMIntersectionObserver
(
already_AddRefed
<
nsPIDOMWindowInner
>
&
&
aOwner
dom
:
:
IntersectionCallback
&
aCb
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
DOMIntersectionObserver
)
NS_INLINE_DECL_STATIC_IID
(
NS_DOM_INTERSECTION_OBSERVER_IID
)
static
already_AddRefed
<
DOMIntersectionObserver
>
Constructor
(
const
GlobalObject
&
dom
:
:
IntersectionCallback
&
ErrorResult
&
)
;
static
already_AddRefed
<
DOMIntersectionObserver
>
Constructor
(
const
GlobalObject
&
dom
:
:
IntersectionCallback
&
const
IntersectionObserverInit
&
ErrorResult
&
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
IntersectionObserver_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsISupports
*
GetParentObject
(
)
const
;
nsINode
*
GetRoot
(
)
const
{
return
mRoot
;
}
void
GetRootMargin
(
nsACString
&
)
;
bool
SetRootMargin
(
const
nsACString
&
)
;
void
GetScrollMargin
(
nsACString
&
)
;
bool
SetScrollMargin
(
const
nsACString
&
)
;
void
GetThresholds
(
nsTArray
<
double
>
&
aRetVal
)
;
void
Observe
(
Element
&
aTarget
)
;
void
Unobserve
(
Element
&
aTarget
)
;
void
UnlinkTarget
(
Element
&
aTarget
)
;
void
Disconnect
(
)
;
void
TakeRecords
(
nsTArray
<
RefPtr
<
DOMIntersectionObserverEntry
>
>
&
aRetVal
)
;
static
StyleRect
<
LengthPercentage
>
LazyLoadingRootMargin
(
)
;
static
IntersectionInput
ComputeInput
(
const
Document
&
aDocument
const
nsINode
*
aRoot
const
StyleRect
<
LengthPercentage
>
*
aRootMargin
const
StyleRect
<
LengthPercentage
>
*
aScrollMargin
)
;
enum
class
IsForProximityToViewport
:
bool
{
No
Yes
}
;
enum
class
BoxToUse
:
uint8_t
{
Content
Border
OverflowClip
}
;
static
IntersectionOutput
Intersect
(
const
IntersectionInput
&
const
Element
&
BoxToUse
=
BoxToUse
:
:
Border
IsForProximityToViewport
=
IsForProximityToViewport
:
:
No
)
;
static
IntersectionOutput
Intersect
(
const
IntersectionInput
&
nsIFrame
*
BoxToUse
=
BoxToUse
:
:
Border
IsForProximityToViewport
=
IsForProximityToViewport
:
:
No
)
;
static
IntersectionOutput
Intersect
(
const
IntersectionInput
&
const
nsRect
&
)
;
void
Update
(
Document
&
aDocument
DOMHighResTimeStamp
time
)
;
MOZ_CAN_RUN_SCRIPT
void
Notify
(
)
;
static
already_AddRefed
<
DOMIntersectionObserver
>
CreateLazyLoadObserver
(
Document
&
)
;
static
Maybe
<
nsRect
>
EdgeInclusiveIntersection
(
const
nsRect
&
aRect
const
nsRect
&
aOtherRect
)
;
protected
:
void
Connect
(
)
;
void
QueueIntersectionObserverEntry
(
Element
*
aTarget
DOMHighResTimeStamp
time
const
Maybe
<
nsRect
>
&
aRootRect
const
nsRect
&
aTargetRect
const
Maybe
<
nsRect
>
&
aIntersectionRect
bool
aIsIntersecting
double
aIntersectionRatio
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mOwner
;
RefPtr
<
Document
>
mDocument
;
Variant
<
RefPtr
<
dom
:
:
IntersectionCallback
>
NativeCallback
>
mCallback
;
RefPtr
<
nsINode
>
mRoot
;
StyleRect
<
LengthPercentage
>
mRootMargin
;
StyleRect
<
LengthPercentage
>
mScrollMargin
;
AutoTArray
<
double
1
>
mThresholds
;
nsTArray
<
Element
*
>
mObservationTargets
;
enum
ObservationState
:
int32_t
{
Uninitialized
=
-
2
NotIntersecting
=
-
1
}
;
nsTHashMap
<
Element
*
int32_t
>
mObservationTargetMap
;
nsTArray
<
RefPtr
<
DOMIntersectionObserverEntry
>
>
mQueuedEntries
;
bool
mConnected
=
false
;
}
;
}
#
endif
