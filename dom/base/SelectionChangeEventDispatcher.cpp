#
include
"
SelectionChangeEventDispatcher
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
namespace
mozilla
{
using
namespace
dom
;
SelectionChangeEventDispatcher
:
:
RawRangeData
:
:
RawRangeData
(
const
nsRange
*
aRange
)
{
if
(
aRange
-
>
IsPositioned
(
)
)
{
mStartContainer
=
aRange
-
>
GetStartContainer
(
)
;
mEndContainer
=
aRange
-
>
GetEndContainer
(
)
;
mStartOffset
=
aRange
-
>
StartOffset
(
)
;
mEndOffset
=
aRange
-
>
EndOffset
(
)
;
}
else
{
mStartContainer
=
nullptr
;
mEndContainer
=
nullptr
;
mStartOffset
=
0
;
mEndOffset
=
0
;
}
}
bool
SelectionChangeEventDispatcher
:
:
RawRangeData
:
:
Equals
(
const
nsRange
*
aRange
)
{
if
(
!
aRange
-
>
IsPositioned
(
)
)
{
return
!
mStartContainer
;
}
return
mStartContainer
=
=
aRange
-
>
GetStartContainer
(
)
&
&
mEndContainer
=
=
aRange
-
>
GetEndContainer
(
)
&
&
mStartOffset
=
=
aRange
-
>
StartOffset
(
)
&
&
mEndOffset
=
=
aRange
-
>
EndOffset
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
SelectionChangeEventDispatcher
:
:
RawRangeData
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mStartContainer
"
mStartContainer
"
aFlags
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mEndContainer
"
mEndContainer
"
aFlags
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SelectionChangeEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SelectionChangeEventDispatcher
)
tmp
-
>
mOldRanges
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
SelectionChangeEventDispatcher
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOldRanges
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
SelectionChangeEventDispatcher
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
SelectionChangeEventDispatcher
Release
)
void
SelectionChangeEventDispatcher
:
:
OnSelectionChange
(
Document
*
aDoc
Selection
*
aSel
int16_t
aReason
)
{
Document
*
doc
=
aSel
-
>
GetParentObject
(
)
;
if
(
!
(
doc
&
&
nsContentUtils
:
:
IsSystemPrincipal
(
doc
-
>
NodePrincipal
(
)
)
)
&
&
!
StaticPrefs
:
:
dom_select_events_enabled
(
)
)
{
return
;
}
if
(
mOldRanges
.
Length
(
)
=
=
aSel
-
>
RangeCount
(
)
&
&
!
aSel
-
>
IsBlockingSelectionChangeEvents
(
)
)
{
bool
changed
=
false
;
for
(
size_t
i
=
0
;
i
<
mOldRanges
.
Length
(
)
;
i
+
+
)
{
if
(
!
mOldRanges
[
i
]
.
Equals
(
aSel
-
>
GetRangeAt
(
i
)
)
)
{
changed
=
true
;
break
;
}
}
if
(
!
changed
)
{
return
;
}
}
mOldRanges
.
ClearAndRetainStorage
(
)
;
for
(
size_t
i
=
0
;
i
<
aSel
-
>
RangeCount
(
)
;
i
+
+
)
{
mOldRanges
.
AppendElement
(
RawRangeData
(
aSel
-
>
GetRangeAt
(
i
)
)
)
;
}
if
(
doc
)
{
nsPIDOMWindowInner
*
inner
=
doc
-
>
GetInnerWindow
(
)
;
if
(
inner
&
&
!
inner
-
>
HasSelectionChangeEventListeners
(
)
)
{
return
;
}
}
if
(
aSel
-
>
IsBlockingSelectionChangeEvents
(
)
)
{
return
;
}
if
(
nsFrameSelection
:
:
sSelectionEventsOnTextControlsEnabled
)
{
nsCOMPtr
<
nsINode
>
target
;
if
(
const
nsFrameSelection
*
fs
=
aSel
-
>
GetFrameSelection
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
root
=
fs
-
>
GetLimiter
(
)
)
{
while
(
root
&
&
root
-
>
IsInNativeAnonymousSubtree
(
)
)
{
root
=
root
-
>
GetParent
(
)
;
}
target
=
root
.
forget
(
)
;
}
}
if
(
!
target
)
{
target
=
aDoc
;
}
if
(
target
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
target
eSelectionChange
CanBubble
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
else
{
if
(
const
nsFrameSelection
*
fs
=
aSel
-
>
GetFrameSelection
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
root
=
fs
-
>
GetLimiter
(
)
)
{
if
(
root
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
}
}
if
(
aDoc
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
aDoc
eSelectionChange
CanBubble
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
}
}
