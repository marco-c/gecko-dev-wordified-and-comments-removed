#
ifndef
nsDOMAttributeMap_h
#
define
nsDOMAttributeMap_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
nsAtom
;
class
nsINode
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
Attr
;
class
DocGroup
;
class
Document
;
class
Element
;
class
NodeInfo
;
}
}
class
nsAttrKey
{
public
:
int32_t
mNamespaceID
;
void
*
mLocalName
;
nsAttrKey
(
int32_t
aNs
nsAtom
*
aName
)
:
mNamespaceID
(
aNs
)
mLocalName
(
aName
)
{
}
nsAttrKey
(
const
nsAttrKey
&
aAttr
)
=
default
;
}
;
class
nsAttrHashKey
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
nsAttrKey
&
;
using
KeyTypePointer
=
const
nsAttrKey
*
;
explicit
nsAttrHashKey
(
KeyTypePointer
aKey
)
:
mKey
(
*
aKey
)
{
}
nsAttrHashKey
(
const
nsAttrHashKey
&
aCopy
)
:
PLDHashEntryHdr
{
}
mKey
(
aCopy
.
mKey
)
{
}
~
nsAttrHashKey
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
mKey
.
mLocalName
=
=
aKey
-
>
mLocalName
&
&
mKey
.
mNamespaceID
=
=
aKey
-
>
mNamespaceID
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
if
(
!
aKey
)
return
0
;
return
mozilla
:
:
HashGeneric
(
aKey
-
>
mNamespaceID
aKey
-
>
mLocalName
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
nsAttrKey
mKey
;
}
;
class
nsDOMAttributeMap
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
using
Attr
=
mozilla
:
:
dom
:
:
Attr
;
using
DocGroup
=
mozilla
:
:
dom
:
:
DocGroup
;
using
Document
=
mozilla
:
:
dom
:
:
Document
;
using
Element
=
mozilla
:
:
dom
:
:
Element
;
using
ErrorResult
=
mozilla
:
:
ErrorResult
;
explicit
nsDOMAttributeMap
(
Element
*
aContent
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_WRAPPERCACHE_CLASS
(
nsDOMAttributeMap
)
void
DropReference
(
)
;
Element
*
GetContent
(
)
{
return
mContent
;
}
nsresult
SetOwnerDocument
(
Document
*
aDocument
)
;
void
DropAttribute
(
int32_t
aNamespaceID
nsAtom
*
aLocalName
)
;
uint32_t
Count
(
)
const
;
using
AttrCache
=
nsRefPtrHashtable
<
nsAttrHashKey
Attr
>
;
static
void
BlastSubtreeToPieces
(
nsINode
*
aNode
)
;
Element
*
GetParentObject
(
)
const
{
return
mContent
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
DocGroup
*
GetDocGroup
(
)
const
;
Attr
*
GetNamedItem
(
const
nsAString
&
aAttrName
)
;
Attr
*
NamedGetter
(
const
nsAString
&
aAttrName
bool
&
aFound
)
;
already_AddRefed
<
Attr
>
RemoveNamedItem
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
ErrorResult
&
aError
)
;
already_AddRefed
<
Attr
>
RemoveNamedItem
(
const
nsAString
&
aName
ErrorResult
&
aError
)
;
Attr
*
Item
(
uint32_t
aIndex
)
;
Attr
*
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
;
uint32_t
Length
(
)
const
;
Attr
*
GetNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
already_AddRefed
<
Attr
>
SetNamedItemNS
(
Attr
&
aNode
ErrorResult
&
aError
)
;
already_AddRefed
<
Attr
>
RemoveNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
;
void
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
virtual
~
nsDOMAttributeMap
(
)
;
private
:
nsCOMPtr
<
Element
>
mContent
;
AttrCache
mAttributeCache
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
GetAttrNodeInfo
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
;
Attr
*
GetAttribute
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
)
;
}
;
#
endif
