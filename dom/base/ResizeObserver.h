#
ifndef
mozilla_dom_ResizeObserver_h
#
define
mozilla_dom_ResizeObserver_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ResizeObserverBinding
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
Element
;
class
ResizeObservation
final
:
public
LinkedListElement
<
ResizeObservation
>
{
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
ResizeObservation
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
ResizeObservation
)
ResizeObservation
(
Element
&
ResizeObserver
&
ResizeObserverBoxOptions
WritingMode
)
;
Element
*
Target
(
)
const
{
return
mTarget
;
}
ResizeObserverBoxOptions
BoxOptions
(
)
const
{
return
mObservedBox
;
}
bool
IsActive
(
)
const
;
void
UpdateLastReportedSize
(
const
nsSize
&
aSize
)
;
enum
class
RemoveFromObserver
:
bool
{
No
Yes
}
;
void
Unlink
(
RemoveFromObserver
)
;
protected
:
~
ResizeObservation
(
)
{
Unlink
(
RemoveFromObserver
:
:
No
)
;
}
;
nsCOMPtr
<
Element
>
mTarget
;
ResizeObserver
*
mObserver
;
const
ResizeObserverBoxOptions
mObservedBox
;
LogicalSize
mLastReportedSize
;
WritingMode
mLastReportedWM
;
}
;
class
ResizeObserver
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ResizeObserver
)
ResizeObserver
(
nsCOMPtr
<
nsPIDOMWindowInner
>
&
&
aOwner
Document
*
aDocument
ResizeObserverCallback
&
aCb
)
:
mOwner
(
std
:
:
move
(
aOwner
)
)
mDocument
(
aDocument
)
mCallback
(
&
aCb
)
{
MOZ_ASSERT
(
mOwner
"
Need
a
non
-
null
owner
window
"
)
;
MOZ_ASSERT
(
mDocument
"
Need
a
non
-
null
doc
"
)
;
MOZ_ASSERT
(
mDocument
=
=
mOwner
-
>
GetExtantDoc
(
)
)
;
}
nsISupports
*
GetParentObject
(
)
const
{
return
mOwner
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
ResizeObserver_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
static
already_AddRefed
<
ResizeObserver
>
Constructor
(
const
GlobalObject
&
aGlobal
ResizeObserverCallback
&
aCb
ErrorResult
&
aRv
)
;
void
Observe
(
Element
&
aTarget
const
ResizeObserverOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
Unobserve
(
Element
&
target
ErrorResult
&
aRv
)
;
void
Disconnect
(
)
;
void
GatherActiveObservations
(
uint32_t
aDepth
)
;
bool
HasActiveObservations
(
)
const
{
return
!
mActiveTargets
.
IsEmpty
(
)
;
}
bool
HasSkippedObservations
(
)
const
{
return
mHasSkippedTargets
;
}
MOZ_CAN_RUN_SCRIPT
uint32_t
BroadcastActiveObservations
(
)
;
protected
:
~
ResizeObserver
(
)
{
Disconnect
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
mOwner
;
RefPtr
<
Document
>
mDocument
;
RefPtr
<
ResizeObserverCallback
>
mCallback
;
nsTArray
<
RefPtr
<
ResizeObservation
>
>
mActiveTargets
;
bool
mHasSkippedTargets
;
nsRefPtrHashtable
<
nsPtrHashKey
<
Element
>
ResizeObservation
>
mObservationMap
;
LinkedList
<
ResizeObservation
>
mObservationList
;
}
;
class
ResizeObserverEntry
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ResizeObserverEntry
)
ResizeObserverEntry
(
nsISupports
*
aOwner
Element
&
aTarget
const
nsSize
&
aBorderBoxSize
const
nsSize
&
aContentBoxSize
)
:
mOwner
(
aOwner
)
mTarget
(
&
aTarget
)
{
MOZ_ASSERT
(
mOwner
"
Need
a
non
-
null
owner
"
)
;
MOZ_ASSERT
(
mTarget
"
Need
a
non
-
null
target
element
"
)
;
SetBorderBoxSize
(
aBorderBoxSize
)
;
SetContentRectAndSize
(
aContentBoxSize
)
;
}
nsISupports
*
GetParentObject
(
)
const
{
return
mOwner
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
ResizeObserverEntry_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
Element
*
Target
(
)
const
{
return
mTarget
;
}
DOMRectReadOnly
*
ContentRect
(
)
const
{
return
mContentRect
;
}
void
GetBorderBoxSize
(
nsTArray
<
RefPtr
<
ResizeObserverSize
>
>
&
aRetVal
)
const
;
void
GetContentBoxSize
(
nsTArray
<
RefPtr
<
ResizeObserverSize
>
>
&
aRetVal
)
const
;
private
:
~
ResizeObserverEntry
(
)
=
default
;
void
SetBorderBoxSize
(
const
nsSize
&
aSize
)
;
void
SetContentRectAndSize
(
const
nsSize
&
aSize
)
;
nsCOMPtr
<
nsISupports
>
mOwner
;
nsCOMPtr
<
Element
>
mTarget
;
RefPtr
<
DOMRectReadOnly
>
mContentRect
;
RefPtr
<
ResizeObserverSize
>
mBorderBoxSize
;
RefPtr
<
ResizeObserverSize
>
mContentBoxSize
;
}
;
class
ResizeObserverSize
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ResizeObserverSize
)
ResizeObserverSize
(
nsISupports
*
aOwner
const
nsSize
&
aSize
const
WritingMode
aWM
)
:
mOwner
(
aOwner
)
mSize
(
aWM
aSize
)
mWM
(
aWM
)
{
MOZ_ASSERT
(
mOwner
"
Need
a
non
-
null
owner
"
)
;
}
nsISupports
*
GetParentObject
(
)
const
{
return
mOwner
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
ResizeObserverSize_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
double
InlineSize
(
)
const
{
return
NSAppUnitsToDoublePixels
(
mSize
.
ISize
(
mWM
)
AppUnitsPerCSSPixel
(
)
)
;
}
double
BlockSize
(
)
const
{
return
NSAppUnitsToDoublePixels
(
mSize
.
BSize
(
mWM
)
AppUnitsPerCSSPixel
(
)
)
;
}
protected
:
~
ResizeObserverSize
(
)
=
default
;
nsCOMPtr
<
nsISupports
>
mOwner
;
const
LogicalSize
mSize
;
const
WritingMode
mWM
;
}
;
}
}
#
endif
