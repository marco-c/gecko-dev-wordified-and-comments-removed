#
include
"
nsNoDataProtocolContentPolicy
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIExternalProtocolHandler
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
NS_IMPL_ISUPPORTS
(
nsNoDataProtocolContentPolicy
nsIContentPolicy
)
NS_IMETHODIMP
nsNoDataProtocolContentPolicy
:
:
ShouldLoad
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
uint32_t
contentType
=
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
MOZ_ASSERT
(
contentType
=
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
contentType
)
"
We
should
only
see
external
content
policy
types
here
.
"
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
contentType
!
=
TYPE_DOCUMENT
&
&
contentType
!
=
TYPE_SUBDOCUMENT
&
&
contentType
!
=
TYPE_OBJECT
&
&
contentType
!
=
TYPE_WEBSOCKET
)
{
nsAutoCString
scheme
;
aContentLocation
-
>
GetScheme
(
scheme
)
;
if
(
scheme
.
EqualsLiteral
(
"
http
"
)
|
|
scheme
.
EqualsLiteral
(
"
https
"
)
|
|
scheme
.
EqualsLiteral
(
"
ftp
"
)
|
|
scheme
.
EqualsLiteral
(
"
file
"
)
|
|
scheme
.
EqualsLiteral
(
"
chrome
"
)
)
{
return
NS_OK
;
}
bool
shouldBlock
;
nsresult
rv
=
NS_URIChainHasFlags
(
aContentLocation
nsIProtocolHandler
:
:
URI_DOES_NOT_RETURN_DATA
&
shouldBlock
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
shouldBlock
)
{
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_CONTENT_POLICY_NO_DATA_PROTOCOL
)
;
*
aDecision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNoDataProtocolContentPolicy
:
:
ShouldProcess
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
return
ShouldLoad
(
aContentLocation
aLoadInfo
aMimeGuess
aDecision
)
;
}
