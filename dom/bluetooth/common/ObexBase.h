#
ifndef
mozilla_dom_bluetooth_ObexBase_h
#
define
mozilla_dom_bluetooth_ObexBase_h
#
include
"
BluetoothCommon
.
h
"
#
include
"
mozilla
/
Endian
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsTArray
.
h
"
BEGIN_BLUETOOTH_NAMESPACE
const
char
FINAL_BIT
=
0x80
;
static
const
uint32_t
kObexRespHeaderSize
=
3
;
static
const
uint32_t
kObexBodyHeaderSize
=
3
;
static
const
uint32_t
kObexLeastMaxSize
=
255
;
enum
ObexHeaderId
{
Count
=
0xC0
Name
=
0x01
Type
=
0x42
Length
=
0xC3
TimeISO8601
=
0x44
Time4Byte
=
0xC4
Description
=
0x05
Target
=
0x46
HTTP
=
0x47
Body
=
0x48
EndOfBody
=
0x49
Who
=
0x4A
ConnectionId
=
0xCB
AppParameters
=
0x4C
AuthChallenge
=
0x4D
AuthResponse
=
0x4E
ObjectClass
=
0x4F
}
;
enum
ObexRequestCode
{
Connect
=
0x80
Disconnect
=
0x81
Put
=
0x02
PutFinal
=
0x82
Get
=
0x03
GetFinal
=
0x83
SetPath
=
0x85
Abort
=
0xFF
}
;
enum
ObexResponseCode
{
Continue
=
0x90
Success
=
0xA0
Created
=
0xA1
Accepted
=
0xA2
NonAuthoritativeInfo
=
0xA3
NoContent
=
0xA4
ResetContent
=
0xA5
PartialContent
=
0xA6
MultipleChoices
=
0xB0
MovedPermanently
=
0xB1
MovedTemporarily
=
0xB2
SeeOther
=
0xB3
NotModified
=
0xB4
UseProxy
=
0xB5
BadRequest
=
0xC0
Unauthorized
=
0xC1
PaymentRequired
=
0xC2
Forbidden
=
0xC3
NotFound
=
0xC4
MethodNotAllowed
=
0xC5
NotAcceptable
=
0xC6
ProxyAuthenticationRequired
=
0xC7
RequestTimeOut
=
0xC8
Conflict
=
0xC9
Gone
=
0xCA
LengthRequired
=
0xCB
PreconditionFailed
=
0xCC
RequestedEntityTooLarge
=
0xCD
RequestUrlTooLarge
=
0xCE
UnsupprotedMediaType
=
0xCF
InternalServerError
=
0xD0
NotImplemented
=
0xD1
BadGateway
=
0xD2
ServiceUnavailable
=
0xD3
GatewayTimeout
=
0xD4
HttpVersionNotSupported
=
0xD5
DatabaseFull
=
0xE0
DatabaseLocked
=
0xE1
}
;
enum
ObexDigestChallenge
{
Nonce
=
0x00
Options
=
0x01
Realm
=
0x02
}
;
enum
ObexDigestResponse
{
ReqDigest
=
0x00
UserId
=
0x01
NonceChallenged
=
0x02
}
;
class
ObexHeader
{
public
:
ObexHeader
(
ObexHeaderId
aId
int
aDataLength
const
uint8_t
*
aData
)
:
mId
(
aId
)
mDataLength
(
aDataLength
)
mData
(
nullptr
)
{
mData
=
new
uint8_t
[
mDataLength
]
;
memcpy
(
mData
aData
aDataLength
)
;
}
~
ObexHeader
(
)
{
}
ObexHeaderId
mId
;
int
mDataLength
;
nsAutoArrayPtr
<
uint8_t
>
mData
;
}
;
class
ObexHeaderSet
{
public
:
ObexHeaderSet
(
)
{
}
~
ObexHeaderSet
(
)
{
}
void
AddHeader
(
ObexHeader
*
aHeader
)
{
mHeaders
.
AppendElement
(
aHeader
)
;
}
void
GetName
(
nsString
&
aRetName
)
const
{
aRetName
.
Truncate
(
)
;
int
length
=
mHeaders
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
Name
)
{
int
nameLength
=
mHeaders
[
i
]
-
>
mDataLength
/
2
-
1
;
uint8_t
*
ptr
=
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
for
(
int
j
=
0
;
j
<
nameLength
;
+
+
j
)
{
char16_t
c
=
BigEndian
:
:
readUint16
(
&
ptr
[
j
*
2
]
)
;
aRetName
+
=
c
;
}
break
;
}
}
}
void
GetContentType
(
nsString
&
aRetContentType
)
const
{
aRetContentType
.
Truncate
(
)
;
int
length
=
mHeaders
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
Type
)
{
uint8_t
*
ptr
=
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
aRetContentType
.
AssignASCII
(
(
const
char
*
)
ptr
)
;
break
;
}
}
}
void
GetLength
(
uint32_t
*
aRetLength
)
const
{
int
length
=
mHeaders
.
Length
(
)
;
*
aRetLength
=
0
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
Length
)
{
uint8_t
*
ptr
=
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
*
aRetLength
=
BigEndian
:
:
readUint32
(
&
ptr
[
0
]
)
;
return
;
}
}
}
void
GetBody
(
uint8_t
*
*
aRetBody
int
*
aRetBodyLength
)
const
{
int
length
=
mHeaders
.
Length
(
)
;
*
aRetBody
=
nullptr
;
*
aRetBodyLength
=
0
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
Body
|
|
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
EndOfBody
)
{
uint8_t
*
ptr
=
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
*
aRetBody
=
new
uint8_t
[
mHeaders
[
i
]
-
>
mDataLength
]
;
memcpy
(
*
aRetBody
ptr
mHeaders
[
i
]
-
>
mDataLength
)
;
*
aRetBodyLength
=
mHeaders
[
i
]
-
>
mDataLength
;
return
;
}
}
}
void
GetTarget
(
uint8_t
*
*
aRetTarget
int
*
aRetTargetLength
)
const
{
int
length
=
mHeaders
.
Length
(
)
;
*
aRetTarget
=
nullptr
;
*
aRetTargetLength
=
0
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
Target
)
{
uint8_t
*
ptr
=
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
*
aRetTarget
=
new
uint8_t
[
mHeaders
[
i
]
-
>
mDataLength
]
;
memcpy
(
*
aRetTarget
ptr
mHeaders
[
i
]
-
>
mDataLength
)
;
*
aRetTargetLength
=
mHeaders
[
i
]
-
>
mDataLength
;
return
;
}
}
}
void
GetAuthChallenge
(
nsAutoArrayPtr
<
uint8_t
>
&
aRetData
int
*
aRetDataLength
)
const
{
*
aRetDataLength
=
0
;
for
(
uint8_t
i
=
0
;
i
<
mHeaders
.
Length
(
)
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
AuthChallenge
)
{
aRetData
=
new
uint8_t
[
mHeaders
[
i
]
-
>
mDataLength
]
;
memcpy
(
aRetData
mHeaders
[
i
]
-
>
mData
mHeaders
[
i
]
-
>
mDataLength
)
;
*
aRetDataLength
=
mHeaders
[
i
]
-
>
mDataLength
;
return
;
}
}
}
uint32_t
GetConnectionId
(
)
const
{
int
length
=
mHeaders
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
ConnectionId
)
{
uint32_t
*
id
=
(
uint32_t
*
)
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
return
*
id
;
}
}
return
0xFFFFFFFF
;
}
bool
GetAppParameter
(
uint8_t
aTagId
uint8_t
*
aRetBuf
int
aBufferSize
)
const
{
int
length
=
mHeaders
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
ObexHeaderId
:
:
AppParameters
)
{
uint8_t
*
ptr
=
mHeaders
[
i
]
-
>
mData
.
get
(
)
;
int
dataLen
=
mHeaders
[
i
]
-
>
mDataLength
;
uint8_t
tagId
;
uint8_t
offset
=
0
;
do
{
tagId
=
*
(
ptr
+
offset
+
+
)
;
uint8_t
paramLen
=
*
(
ptr
+
offset
+
+
)
;
if
(
tagId
=
=
aTagId
)
{
memcpy
(
aRetBuf
ptr
+
offset
paramLen
<
aBufferSize
?
paramLen
:
aBufferSize
)
;
return
true
;
}
offset
+
=
paramLen
;
}
while
(
offset
<
dataLen
)
;
}
}
return
false
;
}
bool
Has
(
ObexHeaderId
aId
)
const
{
int
length
=
mHeaders
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mHeaders
[
i
]
-
>
mId
=
=
aId
)
{
return
true
;
}
}
return
false
;
}
void
ClearHeaders
(
)
{
mHeaders
.
Clear
(
)
;
}
private
:
nsTArray
<
nsAutoPtr
<
ObexHeader
>
>
mHeaders
;
}
;
int
AppendHeaderName
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
*
aName
int
aLength
)
;
int
AppendHeaderBody
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
*
aBody
int
aLength
)
;
int
AppendHeaderTarget
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
*
aTarget
int
aLength
)
;
int
AppendHeaderWho
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
*
aWho
int
aLength
)
;
int
AppendAuthResponse
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
*
aDigest
int
aLength
)
;
int
AppendHeaderAppParameters
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
*
aAppParameters
int
aLength
)
;
int
AppendAppParameter
(
uint8_t
*
aRetBuf
int
aBufferSize
const
uint8_t
aTagId
const
uint8_t
*
aValue
int
aLength
)
;
int
AppendHeaderLength
(
uint8_t
*
aRetBuf
int
aObjectLength
)
;
int
AppendHeaderConnectionId
(
uint8_t
*
aRetBuf
int
aConnectionId
)
;
int
AppendHeaderEndOfBody
(
uint8_t
*
aRetBuf
)
;
void
SetObexPacketInfo
(
uint8_t
*
aRetBuf
uint8_t
aOpcode
int
aPacketLength
)
;
bool
ParseHeaders
(
const
uint8_t
*
aHeaderStart
int
aTotalLength
ObexHeaderSet
*
aRetHanderSet
)
;
END_BLUETOOTH_NAMESPACE
#
endif
