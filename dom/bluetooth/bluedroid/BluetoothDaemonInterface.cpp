#
include
"
BluetoothDaemonInterface
.
h
"
#
include
<
cutils
/
properties
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
stdlib
.
h
>
#
include
"
BluetoothDaemonA2dpInterface
.
h
"
#
include
"
BluetoothDaemonAvrcpInterface
.
h
"
#
include
"
BluetoothDaemonCoreInterface
.
h
"
#
include
"
BluetoothDaemonGattInterface
.
h
"
#
include
"
BluetoothDaemonHandsfreeInterface
.
h
"
#
include
"
BluetoothDaemonHelpers
.
h
"
#
include
"
BluetoothDaemonSetupInterface
.
h
"
#
include
"
BluetoothDaemonSocketInterface
.
h
"
#
include
"
mozilla
/
ipc
/
DaemonRunnables
.
h
"
#
include
"
mozilla
/
ipc
/
DaemonSocket
.
h
"
#
include
"
mozilla
/
ipc
/
DaemonSocketConnector
.
h
"
#
include
"
mozilla
/
ipc
/
ListenSocket
.
h
"
#
include
"
mozilla
/
unused
.
h
"
BEGIN_BLUETOOTH_NAMESPACE
using
namespace
mozilla
:
:
ipc
;
static
const
int
sRetryInterval
=
100
;
class
BluetoothDaemonProtocol
final
:
public
DaemonSocketIOConsumer
public
BluetoothDaemonSetupModule
public
BluetoothDaemonCoreModule
public
BluetoothDaemonSocketModule
public
BluetoothDaemonHandsfreeModule
public
BluetoothDaemonA2dpModule
public
BluetoothDaemonAvrcpModule
public
BluetoothDaemonGattModule
{
public
:
BluetoothDaemonProtocol
(
)
;
void
SetConnection
(
DaemonSocket
*
aConnection
)
;
nsresult
Send
(
DaemonSocketPDU
*
aPDU
DaemonSocketResultHandler
*
aRes
)
override
;
void
StoreResultHandler
(
const
DaemonSocketPDU
&
aPDU
)
override
;
void
Handle
(
DaemonSocketPDU
&
aPDU
)
override
;
already_AddRefed
<
DaemonSocketResultHandler
>
FetchResultHandler
(
const
DaemonSocketPDUHeader
&
aHeader
)
;
private
:
void
HandleSetupSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
void
HandleCoreSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
void
HandleSocketSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
void
HandleHandsfreeSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
void
HandleA2dpSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aUserData
)
;
void
HandleAvrcpSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
void
HandleGattSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
DaemonSocket
*
mConnection
;
nsTArray
<
RefPtr
<
DaemonSocketResultHandler
>
>
mResQ
;
}
;
BluetoothDaemonProtocol
:
:
BluetoothDaemonProtocol
(
)
{
}
void
BluetoothDaemonProtocol
:
:
SetConnection
(
DaemonSocket
*
aConnection
)
{
mConnection
=
aConnection
;
}
nsresult
BluetoothDaemonProtocol
:
:
Send
(
DaemonSocketPDU
*
aPDU
DaemonSocketResultHandler
*
aRes
)
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
aPDU
)
;
aPDU
-
>
SetConsumer
(
this
)
;
aPDU
-
>
SetResultHandler
(
aRes
)
;
aPDU
-
>
UpdateHeader
(
)
;
if
(
mConnection
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
)
{
BT_LOGR
(
"
Connection
to
Bluetooth
daemon
is
closed
.
"
)
;
return
NS_ERROR_FAILURE
;
}
mConnection
-
>
SendSocketData
(
aPDU
)
;
return
NS_OK
;
}
void
BluetoothDaemonProtocol
:
:
HandleSetupSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonSetupModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
HandleCoreSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonCoreModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
HandleSocketSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonSocketModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
HandleHandsfreeSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonHandsfreeModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
HandleA2dpSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonA2dpModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
HandleAvrcpSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonAvrcpModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
HandleGattSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
BluetoothDaemonGattModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
BluetoothDaemonProtocol
:
:
Handle
(
DaemonSocketPDU
&
aPDU
)
{
static
void
(
BluetoothDaemonProtocol
:
:
*
const
HandleSvc
[
]
)
(
const
DaemonSocketPDUHeader
&
DaemonSocketPDU
&
DaemonSocketResultHandler
*
)
=
{
[
BluetoothDaemonSetupModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleSetupSvc
[
BluetoothDaemonCoreModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleCoreSvc
[
BluetoothDaemonSocketModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleSocketSvc
[
0x03
]
=
nullptr
[
0x04
]
=
nullptr
[
BluetoothDaemonHandsfreeModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleHandsfreeSvc
[
BluetoothDaemonA2dpModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleA2dpSvc
[
0x07
]
=
nullptr
[
BluetoothDaemonAvrcpModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleAvrcpSvc
[
BluetoothDaemonGattModule
:
:
SERVICE_ID
]
=
&
BluetoothDaemonProtocol
:
:
HandleGattSvc
}
;
DaemonSocketPDUHeader
header
;
if
(
NS_FAILED
(
UnpackPDU
(
aPDU
header
)
)
|
|
NS_WARN_IF
(
!
(
header
.
mService
<
MOZ_ARRAY_LENGTH
(
HandleSvc
)
)
)
|
|
NS_WARN_IF
(
!
(
HandleSvc
[
header
.
mService
]
)
)
)
{
return
;
}
RefPtr
<
DaemonSocketResultHandler
>
res
=
FetchResultHandler
(
header
)
;
(
this
-
>
*
(
HandleSvc
[
header
.
mService
]
)
)
(
header
aPDU
res
)
;
}
void
BluetoothDaemonProtocol
:
:
StoreResultHandler
(
const
DaemonSocketPDU
&
aPDU
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mResQ
.
AppendElement
(
aPDU
.
GetResultHandler
(
)
)
;
}
already_AddRefed
<
DaemonSocketResultHandler
>
BluetoothDaemonProtocol
:
:
FetchResultHandler
(
const
DaemonSocketPDUHeader
&
aHeader
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
aHeader
.
mOpcode
&
0x80
)
{
return
nullptr
;
}
RefPtr
<
DaemonSocketResultHandler
>
userData
=
mResQ
.
ElementAt
(
0
)
;
mResQ
.
RemoveElementAt
(
0
)
;
return
userData
.
forget
(
)
;
}
static
bool
IsDaemonRunning
(
)
{
char
value
[
PROPERTY_VALUE_MAX
]
;
NS_WARN_IF
(
property_get
(
"
init
.
svc
.
bluetoothd
"
value
"
"
)
<
0
)
;
if
(
strcmp
(
value
"
running
"
)
)
{
BT_LOGR
(
"
[
RESTART
]
Bluetooth
daemon
state
<
%
s
>
"
value
)
;
return
false
;
}
return
true
;
}
BluetoothDaemonInterface
*
BluetoothDaemonInterface
:
:
GetInstance
(
)
{
static
BluetoothDaemonInterface
*
sBluetoothInterface
;
if
(
sBluetoothInterface
)
{
return
sBluetoothInterface
;
}
sBluetoothInterface
=
new
BluetoothDaemonInterface
(
)
;
return
sBluetoothInterface
;
}
BluetoothDaemonInterface
:
:
BluetoothDaemonInterface
(
)
{
}
BluetoothDaemonInterface
:
:
~
BluetoothDaemonInterface
(
)
{
}
class
BluetoothDaemonInterface
:
:
StartDaemonTask
final
:
public
Task
{
public
:
StartDaemonTask
(
BluetoothDaemonInterface
*
aInterface
const
nsACString
&
aCommand
)
:
mInterface
(
aInterface
)
mCommand
(
aCommand
)
{
MOZ_ASSERT
(
mInterface
)
;
}
void
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
BT_LOGR
(
"
Start
Daemon
Task
"
)
;
if
(
NS_WARN_IF
(
property_set
(
"
ctl
.
start
"
mCommand
.
get
(
)
)
<
0
)
)
{
mInterface
-
>
OnConnectError
(
CMD_CHANNEL
)
;
}
if
(
IsDaemonRunning
(
)
)
{
return
;
}
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
FROM_HERE
new
StartDaemonTask
(
mInterface
mCommand
)
sRetryInterval
)
;
}
private
:
BluetoothDaemonInterface
*
mInterface
;
nsCString
mCommand
;
}
;
class
BluetoothDaemonInterface
:
:
InitResultHandler
final
:
public
BluetoothSetupResultHandler
{
public
:
InitResultHandler
(
BluetoothDaemonInterface
*
aInterface
BluetoothResultHandler
*
aRes
)
:
mInterface
(
aInterface
)
mRes
(
aRes
)
mRegisteredSocketModule
(
false
)
{
MOZ_ASSERT
(
mInterface
)
;
}
void
OnError
(
BluetoothStatus
aStatus
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mRes
)
{
mRes
-
>
OnError
(
aStatus
)
;
}
}
void
RegisterModule
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mInterface
-
>
mProtocol
)
;
if
(
!
mRegisteredSocketModule
)
{
mRegisteredSocketModule
=
true
;
mInterface
-
>
mProtocol
-
>
RegisterModuleCmd
(
SETUP_SERVICE_ID_SOCKET
0x00
BluetoothDaemonSocketModule
:
:
MAX_NUM_CLIENTS
this
)
;
}
else
if
(
mRes
)
{
mRes
-
>
Init
(
)
;
}
}
private
:
BluetoothDaemonInterface
*
mInterface
;
RefPtr
<
BluetoothResultHandler
>
mRes
;
bool
mRegisteredSocketModule
;
}
;
void
BluetoothDaemonInterface
:
:
Init
(
BluetoothNotificationHandler
*
aNotificationHandler
BluetoothResultHandler
*
aRes
)
{
#
define
BASE_SOCKET_NAME
"
bluetoothd
"
static
unsigned
long
POSTFIX_LENGTH
=
16
;
Unused
<
<
NS_WARN_IF
(
property_set
(
"
ctl
.
stop
"
"
bluetoothd
"
)
)
;
mResultHandlerQ
.
AppendElement
(
aRes
)
;
if
(
!
mProtocol
)
{
mProtocol
=
new
BluetoothDaemonProtocol
(
)
;
}
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
SetNotificationHandler
(
aNotificationHandler
)
;
if
(
!
mListenSocket
)
{
mListenSocket
=
new
ListenSocket
(
this
LISTEN_SOCKET
)
;
}
if
(
!
mCmdChannel
)
{
mCmdChannel
=
new
DaemonSocket
(
mProtocol
this
CMD_CHANNEL
)
;
}
else
if
(
NS_WARN_IF
(
mCmdChannel
-
>
GetConnectionStatus
(
)
=
=
SOCKET_CONNECTED
)
)
{
mCmdChannel
-
>
Close
(
)
;
}
nsresult
rv
=
DaemonSocketConnector
:
:
CreateRandomAddressString
(
NS_LITERAL_CSTRING
(
BASE_SOCKET_NAME
)
POSTFIX_LENGTH
mListenSocketName
)
;
if
(
NS_FAILED
(
rv
)
)
{
mListenSocketName
.
AssignLiteral
(
BASE_SOCKET_NAME
)
;
}
rv
=
mListenSocket
-
>
Listen
(
new
DaemonSocketConnector
(
mListenSocketName
)
mCmdChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnConnectError
(
CMD_CHANNEL
)
;
return
;
}
mProtocol
-
>
SetConnection
(
mCmdChannel
)
;
}
class
BluetoothDaemonInterface
:
:
CleanupResultHandler
final
:
public
BluetoothSetupResultHandler
{
public
:
CleanupResultHandler
(
BluetoothDaemonInterface
*
aInterface
)
:
mInterface
(
aInterface
)
mUnregisteredCoreModule
(
false
)
{
MOZ_ASSERT
(
mInterface
)
;
}
void
OnError
(
BluetoothStatus
aStatus
)
override
{
Proceed
(
)
;
}
void
UnregisterModule
(
)
override
{
Proceed
(
)
;
}
private
:
void
Proceed
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mInterface
-
>
mProtocol
)
;
if
(
!
mUnregisteredCoreModule
)
{
mUnregisteredCoreModule
=
true
;
mInterface
-
>
mProtocol
-
>
UnregisterModuleCmd
(
SETUP_SERVICE_ID_CORE
this
)
;
}
else
{
mInterface
-
>
mCmdChannel
-
>
Close
(
)
;
}
}
BluetoothDaemonInterface
*
mInterface
;
bool
mUnregisteredCoreModule
;
}
;
void
BluetoothDaemonInterface
:
:
Cleanup
(
BluetoothResultHandler
*
aRes
)
{
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
SetNotificationHandler
(
nullptr
)
;
nsresult
rv
=
mProtocol
-
>
UnregisterModuleCmd
(
SETUP_SERVICE_ID_SOCKET
new
CleanupResultHandler
(
this
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
return
;
}
mResultHandlerQ
.
AppendElement
(
aRes
)
;
}
void
BluetoothDaemonInterface
:
:
Enable
(
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
EnableCmd
(
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
Disable
(
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
DisableCmd
(
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetAdapterProperties
(
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetAdapterPropertiesCmd
(
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetAdapterProperty
(
BluetoothPropertyType
aType
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetAdapterPropertyCmd
(
aType
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
SetAdapterProperty
(
const
BluetoothProperty
&
aProperty
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
SetAdapterPropertyCmd
(
aProperty
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetRemoteDeviceProperties
(
const
BluetoothAddress
&
aRemoteAddr
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetRemoteDevicePropertiesCmd
(
aRemoteAddr
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetRemoteDeviceProperty
(
const
BluetoothAddress
&
aRemoteAddr
BluetoothPropertyType
aType
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetRemoteDevicePropertyCmd
(
aRemoteAddr
aType
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
SetRemoteDeviceProperty
(
const
BluetoothAddress
&
aRemoteAddr
const
BluetoothProperty
&
aProperty
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
SetRemoteDevicePropertyCmd
(
aRemoteAddr
aProperty
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetRemoteServiceRecord
(
const
BluetoothAddress
&
aRemoteAddr
const
BluetoothUuid
&
aUuid
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetRemoteServiceRecordCmd
(
aRemoteAddr
aUuid
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetRemoteServices
(
const
BluetoothAddress
&
aRemoteAddr
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetRemoteServicesCmd
(
aRemoteAddr
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
StartDiscovery
(
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
StartDiscoveryCmd
(
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
CancelDiscovery
(
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
CancelDiscoveryCmd
(
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
CreateBond
(
const
BluetoothAddress
&
aBdAddr
BluetoothTransport
aTransport
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
CreateBondCmd
(
aBdAddr
aTransport
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
RemoveBond
(
const
BluetoothAddress
&
aBdAddr
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
RemoveBondCmd
(
aBdAddr
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
CancelBond
(
const
BluetoothAddress
&
aBdAddr
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
CancelBondCmd
(
aBdAddr
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
GetConnectionState
(
const
BluetoothAddress
&
aBdAddr
BluetoothResultHandler
*
aRes
)
{
}
void
BluetoothDaemonInterface
:
:
PinReply
(
const
BluetoothAddress
&
aBdAddr
bool
aAccept
const
BluetoothPinCode
&
aPinCode
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
PinReplyCmd
(
aBdAddr
aAccept
aPinCode
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
SspReply
(
const
BluetoothAddress
&
aBdAddr
BluetoothSspVariant
aVariant
bool
aAccept
uint32_t
aPasskey
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
SspReplyCmd
(
aBdAddr
aVariant
aAccept
aPasskey
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
DutModeConfigure
(
bool
aEnable
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
DutModeConfigureCmd
(
aEnable
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
DutModeSend
(
uint16_t
aOpcode
uint8_t
*
aBuf
uint8_t
aLen
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
DutModeSendCmd
(
aOpcode
aBuf
aLen
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
LeTestMode
(
uint16_t
aOpcode
uint8_t
*
aBuf
uint8_t
aLen
BluetoothResultHandler
*
aRes
)
{
nsresult
rv
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
LeTestModeCmd
(
aOpcode
aBuf
aLen
aRes
)
;
if
(
NS_FAILED
(
rv
)
)
{
DispatchError
(
aRes
rv
)
;
}
}
void
BluetoothDaemonInterface
:
:
ReadEnergyInfo
(
BluetoothResultHandler
*
aRes
)
{
}
void
BluetoothDaemonInterface
:
:
DispatchError
(
BluetoothResultHandler
*
aRes
BluetoothStatus
aStatus
)
{
DaemonResultRunnable1
<
BluetoothResultHandler
void
BluetoothStatus
BluetoothStatus
>
:
:
Dispatch
(
aRes
&
BluetoothResultHandler
:
:
OnError
ConstantInitOp1
<
BluetoothStatus
>
(
aStatus
)
)
;
}
void
BluetoothDaemonInterface
:
:
DispatchError
(
BluetoothResultHandler
*
aRes
nsresult
aRv
)
{
BluetoothStatus
status
;
if
(
NS_WARN_IF
(
NS_FAILED
(
Convert
(
aRv
status
)
)
)
)
{
status
=
STATUS_FAIL
;
}
DispatchError
(
aRes
status
)
;
}
BluetoothSetupInterface
*
BluetoothDaemonInterface
:
:
GetBluetoothSetupInterface
(
)
{
if
(
mSetupInterface
)
{
return
mSetupInterface
;
}
mSetupInterface
=
new
BluetoothDaemonSetupInterface
(
mProtocol
)
;
return
mSetupInterface
;
}
BluetoothSocketInterface
*
BluetoothDaemonInterface
:
:
GetBluetoothSocketInterface
(
)
{
if
(
mSocketInterface
)
{
return
mSocketInterface
;
}
mSocketInterface
=
new
BluetoothDaemonSocketInterface
(
mProtocol
)
;
return
mSocketInterface
;
}
BluetoothHandsfreeInterface
*
BluetoothDaemonInterface
:
:
GetBluetoothHandsfreeInterface
(
)
{
if
(
mHandsfreeInterface
)
{
return
mHandsfreeInterface
;
}
mHandsfreeInterface
=
new
BluetoothDaemonHandsfreeInterface
(
mProtocol
)
;
return
mHandsfreeInterface
;
}
BluetoothA2dpInterface
*
BluetoothDaemonInterface
:
:
GetBluetoothA2dpInterface
(
)
{
if
(
mA2dpInterface
)
{
return
mA2dpInterface
;
}
mA2dpInterface
=
new
BluetoothDaemonA2dpInterface
(
mProtocol
)
;
return
mA2dpInterface
;
}
BluetoothAvrcpInterface
*
BluetoothDaemonInterface
:
:
GetBluetoothAvrcpInterface
(
)
{
if
(
mAvrcpInterface
)
{
return
mAvrcpInterface
;
}
mAvrcpInterface
=
new
BluetoothDaemonAvrcpInterface
(
mProtocol
)
;
return
mAvrcpInterface
;
}
BluetoothGattInterface
*
BluetoothDaemonInterface
:
:
GetBluetoothGattInterface
(
)
{
if
(
mGattInterface
)
{
return
mGattInterface
;
}
mGattInterface
=
new
BluetoothDaemonGattInterface
(
mProtocol
)
;
return
mGattInterface
;
}
void
BluetoothDaemonInterface
:
:
OnConnectSuccess
(
int
aIndex
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
;
switch
(
aIndex
)
{
case
LISTEN_SOCKET
:
{
nsCString
value
(
"
bluetoothd
:
-
a
"
)
;
value
.
Append
(
mListenSocketName
)
;
if
(
NS_WARN_IF
(
property_set
(
"
ctl
.
start
"
value
.
get
(
)
)
<
0
)
)
{
OnConnectError
(
CMD_CHANNEL
)
;
}
if
(
!
IsDaemonRunning
(
)
)
{
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
FROM_HERE
new
StartDaemonTask
(
this
value
)
sRetryInterval
)
;
}
}
break
;
case
CMD_CHANNEL
:
if
(
!
mNtfChannel
)
{
mNtfChannel
=
new
DaemonSocket
(
mProtocol
this
NTF_CHANNEL
)
;
}
else
if
(
NS_WARN_IF
(
mNtfChannel
-
>
GetConnectionStatus
(
)
=
=
SOCKET_CONNECTED
)
)
{
mNtfChannel
-
>
Close
(
)
;
}
if
(
NS_FAILED
(
mListenSocket
-
>
Listen
(
mNtfChannel
)
)
)
{
OnConnectError
(
NTF_CHANNEL
)
;
}
break
;
case
NTF_CHANNEL
:
{
RefPtr
<
BluetoothResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
nsresult
rv
=
mProtocol
-
>
RegisterModuleCmd
(
SETUP_SERVICE_ID_CORE
0x00
BluetoothDaemonCoreModule
:
:
MAX_NUM_CLIENTS
new
InitResultHandler
(
this
res
)
)
;
if
(
NS_FAILED
(
rv
)
&
&
res
)
{
DispatchError
(
res
STATUS_FAIL
)
;
}
}
break
;
}
}
void
BluetoothDaemonInterface
:
:
OnConnectError
(
int
aIndex
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
;
switch
(
aIndex
)
{
case
NTF_CHANNEL
:
mCmdChannel
-
>
Close
(
)
;
case
CMD_CHANNEL
:
Unused
<
<
NS_WARN_IF
(
property_set
(
"
ctl
.
stop
"
"
bluetoothd
"
)
)
;
mListenSocket
-
>
Close
(
)
;
case
LISTEN_SOCKET
:
if
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
{
RefPtr
<
BluetoothResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
if
(
res
)
{
DispatchError
(
res
STATUS_FAIL
)
;
}
}
break
;
}
}
void
BluetoothDaemonInterface
:
:
OnDisconnect
(
int
aIndex
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
aIndex
)
{
case
CMD_CHANNEL
:
break
;
case
NTF_CHANNEL
:
mListenSocket
-
>
Close
(
)
;
break
;
case
LISTEN_SOCKET
:
if
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
{
RefPtr
<
BluetoothResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
if
(
res
)
{
res
-
>
Cleanup
(
)
;
}
}
break
;
}
BluetoothNotificationHandler
*
notificationHandler
=
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
GetNotificationHandler
(
)
;
if
(
notificationHandler
&
&
mResultHandlerQ
.
IsEmpty
(
)
)
{
if
(
mListenSocket
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
&
&
mCmdChannel
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
&
&
mNtfChannel
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
)
{
notificationHandler
-
>
BackendErrorNotification
(
true
)
;
static_cast
<
BluetoothDaemonCoreModule
*
>
(
mProtocol
)
-
>
SetNotificationHandler
(
nullptr
)
;
}
}
}
END_BLUETOOTH_NAMESPACE
