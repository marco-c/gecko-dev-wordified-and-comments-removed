#
include
"
FileInfo
.
h
"
#
include
"
ActorsParent
.
h
"
#
include
"
FileManager
.
h
"
#
include
"
IndexedDatabaseManager
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
indexedDB
{
using
namespace
mozilla
:
:
dom
:
:
quota
;
using
namespace
mozilla
:
:
ipc
;
void
FileInfo
:
:
GetReferences
(
int32_t
*
aRefCnt
int32_t
*
aDBRefCnt
int32_t
*
aSliceRefCnt
)
{
MOZ_ASSERT
(
!
IndexedDatabaseManager
:
:
IsClosed
(
)
)
;
MutexAutoLock
lock
(
IndexedDatabaseManager
:
:
FileMutex
(
)
)
;
if
(
aRefCnt
)
{
*
aRefCnt
=
mRefCnt
;
}
if
(
aDBRefCnt
)
{
*
aDBRefCnt
=
mDBRefCnt
;
}
if
(
aSliceRefCnt
)
{
*
aSliceRefCnt
=
mSliceRefCnt
;
}
}
void
FileInfo
:
:
UpdateReferences
(
ThreadSafeAutoRefCnt
&
aRefCount
int32_t
aDelta
CustomCleanupCallback
*
aCustomCleanupCallback
)
{
if
(
IndexedDatabaseManager
:
:
IsClosed
(
)
)
{
MOZ_ASSERT
(
&
aRefCount
=
=
&
mRefCnt
)
;
MOZ_ASSERT
(
aDelta
=
=
1
|
|
aDelta
=
=
-
1
)
;
if
(
aDelta
>
0
)
{
+
+
aRefCount
;
}
else
{
nsrefcnt
count
=
-
-
aRefCount
;
if
(
!
count
)
{
mRefCnt
=
1
;
delete
this
;
}
}
return
;
}
MOZ_ASSERT
(
!
IndexedDatabaseManager
:
:
IsClosed
(
)
)
;
bool
needsCleanup
;
{
MutexAutoLock
lock
(
IndexedDatabaseManager
:
:
FileMutex
(
)
)
;
aRefCount
=
aRefCount
+
aDelta
;
if
(
mRefCnt
+
mDBRefCnt
+
mSliceRefCnt
>
0
)
{
return
;
}
mFileManager
-
>
mFileInfos
.
Remove
(
Id
(
)
)
;
needsCleanup
=
!
mFileManager
-
>
Invalidated
(
)
;
}
if
(
needsCleanup
)
{
if
(
aCustomCleanupCallback
)
{
nsresult
rv
=
aCustomCleanupCallback
-
>
Cleanup
(
mFileManager
Id
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Custom
cleanup
failed
!
"
)
;
}
}
else
{
Cleanup
(
)
;
}
}
delete
this
;
}
bool
FileInfo
:
:
LockedClearDBRefs
(
)
{
MOZ_ASSERT
(
!
IndexedDatabaseManager
:
:
IsClosed
(
)
)
;
IndexedDatabaseManager
:
:
FileMutex
(
)
.
AssertCurrentThreadOwns
(
)
;
mDBRefCnt
=
0
;
if
(
mRefCnt
|
|
mSliceRefCnt
)
{
return
true
;
}
MOZ_ASSERT
(
mFileManager
-
>
Invalidated
(
)
)
;
delete
this
;
return
false
;
}
void
FileInfo
:
:
Cleanup
(
)
{
AssertIsOnBackgroundThread
(
)
;
int64_t
id
=
Id
(
)
;
if
(
NS_FAILED
(
AsyncDeleteFile
(
mFileManager
id
)
)
)
{
NS_WARNING
(
"
Failed
to
delete
file
asynchronously
!
"
)
;
}
}
nsCOMPtr
<
nsIFile
>
FileInfo
:
:
GetFileForFileInfo
(
FileInfo
*
aFileInfo
)
{
FileManager
*
const
fileManager
=
aFileInfo
-
>
Manager
(
)
;
const
nsCOMPtr
<
nsIFile
>
directory
=
fileManager
-
>
GetDirectory
(
)
;
if
(
NS_WARN_IF
(
!
directory
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIFile
>
file
=
FileManager
:
:
GetFileForId
(
directory
aFileInfo
-
>
Id
(
)
)
;
if
(
NS_WARN_IF
(
!
file
)
)
{
return
nullptr
;
}
return
file
;
}
}
}
}
