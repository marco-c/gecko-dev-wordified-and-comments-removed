async
function
testSteps
(
)
{
const
cosmologicalConstant
=
35000
;
const
maxConnectionThreadCount
=
20
;
const
connectionIdleMaintenanceMS
=
2
*
1000
;
const
name
=
"
test_connection_idle_maintenance_stop
"
;
const
abc
=
"
abcdefghijklmnopqrstuvwxyz
"
;
if
(
mozinfo
.
os
=
=
"
android
"
)
{
info
(
"
Test
disabled
on
Android
for
now
"
)
;
return
;
}
info
(
"
Setting
pref
"
)
;
Services
.
prefs
.
setIntPref
(
"
dom
.
indexedDB
.
connectionIdleMaintenance
.
pauseOnConnectionThreadMs
"
2
*
connectionIdleMaintenanceMS
)
;
info
(
"
Forcing
only
one
connection
thread
to
be
available
"
)
;
let
done
=
false
;
const
completePromises
=
await
(
async
function
(
)
{
let
promises
=
[
]
;
for
(
let
index
=
0
;
index
<
maxConnectionThreadCount
-
1
;
index
+
+
)
{
const
request
=
indexedDB
.
open
(
name
+
"
-
"
+
index
1
)
;
{
const
event
=
await
expectingUpgrade
(
request
)
;
const
database
=
event
.
target
.
result
;
const
objectStore
=
database
.
createObjectStore
(
name
)
;
objectStore
.
add
(
"
foo
"
42
)
;
}
const
event
=
await
expectingSuccess
(
request
)
;
const
database
=
event
.
target
.
result
;
const
transaction
=
database
.
transaction
(
name
)
;
const
objectStore
=
transaction
.
objectStore
(
name
)
;
function
doWork
(
)
{
const
request
=
objectStore
.
get
(
42
)
;
request
.
onsuccess
=
function
(
)
{
if
(
!
done
)
{
doWork
(
)
;
}
}
;
}
doWork
(
)
;
const
promise
=
new
Promise
(
function
(
resolve
)
{
transaction
.
oncomplete
=
resolve
;
}
)
;
promises
.
push
(
promise
)
;
}
return
promises
;
}
)
(
)
;
info
(
"
Creating
database
A
"
)
;
const
databaseA
=
await
(
async
function
(
)
{
const
request
=
indexedDB
.
open
(
name
+
"
-
a
"
1
)
;
{
const
event
=
await
expectingUpgrade
(
request
)
;
const
database
=
event
.
target
.
result
;
database
.
createObjectStore
(
name
)
;
}
const
event
=
await
expectingSuccess
(
request
)
;
const
database
=
event
.
target
.
result
;
return
database
;
}
)
(
)
;
info
(
"
Creating
database
B
"
)
;
{
const
request
=
indexedDB
.
open
(
name
+
"
-
b
"
1
)
;
const
event
=
await
expectingUpgrade
(
request
)
;
const
database
=
event
.
target
.
result
;
const
objectStore
=
database
.
createObjectStore
(
name
)
;
for
(
let
index
=
0
;
index
<
10000
;
index
+
+
)
{
objectStore
.
add
(
abc
index
)
;
}
objectStore
.
clear
(
)
;
await
expectingSuccess
(
request
)
;
}
info
(
"
Getting
database
usage
before
maintenance
"
)
;
const
databaseUsageBeforeMaintenance
=
await
new
Promise
(
function
(
resolve
)
{
getCurrentUsage
(
function
(
request
)
{
resolve
(
request
.
result
.
databaseUsage
)
;
}
)
;
}
)
;
info
(
"
Waiting
for
maintenance
to
start
"
)
;
await
new
Promise
(
function
(
resolve
)
{
do_timeout
(
2
*
connectionIdleMaintenanceMS
resolve
)
;
}
)
;
info
(
"
Activating
database
A
"
)
;
{
const
transaction
=
databaseA
.
transaction
(
name
)
;
const
objectStore
=
transaction
.
objectStore
(
name
)
;
const
request
=
objectStore
.
get
(
42
)
;
await
requestSucceeded
(
request
)
;
}
info
(
"
Waiting
for
maintenance
to
finish
"
)
;
await
new
Promise
(
function
(
resolve
)
{
do_timeout
(
2
*
connectionIdleMaintenanceMS
resolve
)
;
}
)
;
info
(
"
Getting
database
usage
after
maintenance
"
)
;
const
databaseUsageAfterMaintenance
=
await
new
Promise
(
function
(
resolve
)
{
getCurrentUsage
(
function
(
request
)
{
resolve
(
request
.
result
.
databaseUsage
)
;
}
)
;
}
)
;
info
(
"
Database
usage
before
:
"
+
databaseUsageBeforeMaintenance
+
"
.
"
+
"
Database
usage
after
:
"
+
databaseUsageAfterMaintenance
)
;
ok
(
databaseUsageBeforeMaintenance
-
databaseUsageAfterMaintenance
<
cosmologicalConstant
"
Maintenance
did
not
significantly
decrease
database
usage
"
)
;
done
=
true
;
info
(
"
Waiting
for
transactions
to
complete
"
)
;
await
Promise
.
all
(
completePromises
)
;
}
