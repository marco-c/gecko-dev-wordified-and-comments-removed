async
function
testSteps
(
)
{
info
(
"
Creating
databases
"
)
;
for
(
let
originIndex
=
0
;
originIndex
<
3
;
originIndex
+
+
)
{
const
principal
=
getPrincipal
(
"
https
:
/
/
www
.
example
"
+
originIndex
+
"
.
com
"
)
;
for
(
let
databaseIndex
=
0
;
databaseIndex
<
5
;
databaseIndex
+
+
)
{
const
dbName
=
"
foo
-
"
+
databaseIndex
;
const
request
=
indexedDB
.
openForPrincipal
(
principal
dbName
1
)
;
{
const
event
=
await
expectingUpgrade
(
request
)
;
const
database
=
event
.
target
.
result
;
const
objectStore
=
database
.
createObjectStore
(
"
foo
"
)
;
for
(
let
i
=
0
;
i
<
100
;
i
+
+
)
{
objectStore
.
add
(
"
abcdefghijklmnopqrstuvwxyz0123456789
"
i
)
;
}
objectStore
.
clear
(
)
;
}
const
event
=
await
expectingSuccess
(
request
)
;
const
database
=
event
.
target
.
result
;
database
.
close
(
)
;
}
}
info
(
"
Sending
fake
'
idle
-
daily
'
notification
to
QuotaManager
"
)
;
let
observer
=
Services
.
qms
.
QueryInterface
(
Ci
.
nsIObserver
)
;
observer
.
observe
(
null
"
idle
-
daily
"
"
"
)
;
info
(
"
Getting
databases
"
)
;
const
completePromises
=
(
function
(
)
{
let
promises
=
[
]
;
for
(
let
index
=
0
;
index
<
10
;
index
+
+
)
{
async
function
sandboxScript
(
)
{
await
indexedDB
.
databases
(
)
;
}
const
sandbox
=
new
Cu
.
Sandbox
(
getPrincipal
(
"
https
:
/
/
www
.
example
"
+
index
+
"
.
org
"
)
{
wantGlobalProperties
:
[
"
indexedDB
"
]
}
)
;
const
promise
=
new
Promise
(
function
(
resolve
reject
)
{
sandbox
.
resolve
=
resolve
;
sandbox
.
reject
=
reject
;
}
)
;
Cu
.
evalInSandbox
(
sandboxScript
.
toSource
(
)
+
"
sandboxScript
(
)
.
then
(
resolve
reject
)
;
"
sandbox
)
;
promises
.
push
(
promise
)
;
}
return
promises
;
}
)
(
)
;
info
(
"
Waiting
for
maintenance
to
finish
"
)
;
await
new
Promise
(
function
(
resolve
)
{
do_timeout
(
10000
resolve
)
;
}
)
;
await
Promise
.
all
(
completePromises
)
;
}
