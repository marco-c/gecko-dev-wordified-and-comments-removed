#
include
"
Key
.
h
"
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
"
IndexedDBCommon
.
h
"
#
include
"
IndexedDatabase
.
h
"
#
include
"
IndexedDatabaseInlines
.
h
"
#
include
"
IndexedDatabaseManager
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
Date
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozIStorageValueArray
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
ReportInternalError
.
h
"
#
include
"
unicode
/
ucol
.
h
"
#
include
"
xpcpublic
.
h
"
namespace
mozilla
:
:
dom
:
:
indexedDB
{
namespace
{
template
<
typename
ArrayConversionPolicy
>
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
ConvertArrayValueToKey
(
JSContext
*
const
aCx
JS
:
:
HandleObject
aObject
ArrayConversionPolicy
&
&
aPolicy
)
{
uint32_t
len
;
if
(
!
JS
:
:
GetArrayLength
(
aCx
aObject
&
len
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
aPolicy
.
AddToSeenSet
(
aCx
aObject
)
;
aPolicy
.
BeginSubkeyList
(
)
;
uint32_t
index
=
0
;
while
(
index
<
len
)
{
JS
:
:
RootedId
indexId
(
aCx
)
;
if
(
!
JS_IndexToId
(
aCx
index
&
indexId
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
bool
hop
;
if
(
!
JS_HasOwnPropertyById
(
aCx
aObject
indexId
&
hop
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
if
(
!
hop
)
{
return
SpecialValues
:
:
Invalid
;
}
JS
:
:
RootedValue
entry
(
aCx
)
;
if
(
!
JS_GetPropertyById
(
aCx
aObject
indexId
&
entry
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
auto
result
=
aPolicy
.
ConvertSubkey
(
aCx
entry
index
)
;
if
(
!
result
.
Is
(
Ok
)
)
{
return
result
;
}
index
+
=
1
;
}
aPolicy
.
EndSubkeyList
(
)
;
return
Ok
(
)
;
}
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
SetFromString
(
const
nsAString
&
aString
)
{
mBuffer
.
Truncate
(
)
;
auto
result
=
EncodeString
(
aString
0
)
;
if
(
result
.
Is
(
Ok
)
)
{
TrimBuffer
(
)
;
}
return
result
;
}
uint32_t
Key
:
:
LengthOfEncodedBinary
(
const
EncodedDataType
*
aPos
const
EncodedDataType
*
aEnd
)
{
MOZ_ASSERT
(
*
aPos
%
Key
:
:
eMaxType
=
=
Key
:
:
eBinary
"
Don
'
t
call
me
!
"
)
;
const
auto
*
iter
=
aPos
+
1
;
for
(
;
iter
<
aEnd
&
&
*
iter
!
=
eTerminator
;
+
+
iter
)
{
if
(
*
iter
&
0x80
)
{
+
+
iter
;
MOZ_ASSERT
(
iter
<
aEnd
)
;
}
}
return
iter
-
aPos
-
1
;
}
IDBResult
<
Key
IDBSpecialValue
:
:
Invalid
>
Key
:
:
ToLocaleAwareKey
(
const
nsCString
&
aLocale
)
const
{
Key
res
;
if
(
IsUnset
(
)
)
{
return
Ok
(
res
)
;
}
if
(
IsFloat
(
)
|
|
IsDate
(
)
|
|
IsBinary
(
)
)
{
res
.
mBuffer
=
mBuffer
;
return
Ok
(
res
)
;
}
auto
*
it
=
BufferStart
(
)
;
auto
*
const
end
=
BufferEnd
(
)
;
bool
canShareBuffers
=
true
;
while
(
it
<
end
)
{
const
auto
type
=
*
it
%
eMaxType
;
if
(
type
=
=
eTerminator
)
{
it
+
+
;
}
else
if
(
type
=
=
eFloat
|
|
type
=
=
eDate
)
{
it
+
+
;
it
+
=
std
:
:
min
(
sizeof
(
uint64_t
)
size_t
(
end
-
it
)
)
;
}
else
if
(
type
=
=
eBinary
)
{
const
auto
binaryLength
=
LengthOfEncodedBinary
(
it
end
)
;
it
+
+
;
it
+
=
binaryLength
;
}
else
{
canShareBuffers
=
false
;
break
;
}
}
if
(
canShareBuffers
)
{
MOZ_ASSERT
(
it
=
=
end
)
;
res
.
mBuffer
=
mBuffer
;
return
Ok
(
res
)
;
}
if
(
!
res
.
mBuffer
.
SetCapacity
(
mBuffer
.
Length
(
)
fallible
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_OUT_OF_MEMORY
}
}
;
}
auto
*
const
start
=
BufferStart
(
)
;
if
(
it
>
start
)
{
char
*
buffer
;
MOZ_ALWAYS_TRUE
(
res
.
mBuffer
.
GetMutableData
(
&
buffer
it
-
start
)
)
;
std
:
:
copy
(
start
it
buffer
)
;
}
while
(
it
<
end
)
{
char
*
buffer
;
const
uint32_t
oldLen
=
res
.
mBuffer
.
Length
(
)
;
const
auto
type
=
*
it
%
eMaxType
;
const
auto
updateBufferAndIter
=
[
&
]
(
size_t
byteCount
)
-
>
bool
{
if
(
!
res
.
mBuffer
.
GetMutableData
(
&
buffer
oldLen
+
1
+
byteCount
)
)
{
return
false
;
}
buffer
+
=
oldLen
;
std
:
:
copy_n
(
it
byteCount
+
1
buffer
)
;
it
+
=
(
byteCount
+
1
)
;
return
true
;
}
;
if
(
type
=
=
eTerminator
)
{
if
(
!
updateBufferAndIter
(
0
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_OUT_OF_MEMORY
}
}
;
}
}
else
if
(
type
=
=
eFloat
|
|
type
=
=
eDate
)
{
const
size_t
byteCount
=
std
:
:
min
(
sizeof
(
uint64_t
)
size_t
(
end
-
it
-
1
)
)
;
if
(
!
updateBufferAndIter
(
byteCount
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_OUT_OF_MEMORY
}
}
;
}
}
else
if
(
type
=
=
eBinary
)
{
const
auto
binaryLength
=
LengthOfEncodedBinary
(
it
end
)
;
if
(
!
updateBufferAndIter
(
binaryLength
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_OUT_OF_MEMORY
}
}
;
}
}
else
{
const
uint8_t
typeOffset
=
*
it
-
eString
;
MOZ_ASSERT
(
(
typeOffset
%
eArray
=
=
0
)
&
&
(
typeOffset
/
eArray
<
=
2
)
)
;
auto
str
=
DecodeString
(
it
end
)
;
auto
result
=
res
.
EncodeLocaleString
(
str
typeOffset
aLocale
)
;
if
(
NS_WARN_IF
(
!
result
.
Is
(
Ok
)
)
)
{
return
result
.
PropagateNotOk
<
Key
>
(
)
;
}
}
}
res
.
TrimBuffer
(
)
;
return
Ok
(
res
)
;
}
class
MOZ_STACK_CLASS
Key
:
:
ArrayValueEncoder
final
{
public
:
ArrayValueEncoder
(
Key
&
aKey
const
uint8_t
aTypeOffset
const
uint16_t
aRecursionDepth
)
:
mKey
(
aKey
)
mTypeOffset
(
aTypeOffset
)
mRecursionDepth
(
aRecursionDepth
)
{
}
void
AddToSeenSet
(
JSContext
*
const
aCx
JS
:
:
HandleObject
)
{
+
+
mRecursionDepth
;
}
void
BeginSubkeyList
(
)
{
mTypeOffset
+
=
Key
:
:
eMaxType
;
if
(
mTypeOffset
=
=
eMaxType
*
kMaxArrayCollapse
)
{
mKey
.
mBuffer
.
Append
(
mTypeOffset
)
;
mTypeOffset
=
0
;
}
MOZ_ASSERT
(
mTypeOffset
%
eMaxType
=
=
0
"
Current
type
offset
must
indicate
beginning
of
array
"
)
;
MOZ_ASSERT
(
mTypeOffset
<
eMaxType
*
kMaxArrayCollapse
)
;
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
ConvertSubkey
(
JSContext
*
const
aCx
JS
:
:
HandleValue
aEntry
const
uint32_t
aIndex
)
{
auto
result
=
mKey
.
EncodeJSValInternal
(
aCx
aEntry
mTypeOffset
mRecursionDepth
)
;
mTypeOffset
=
0
;
return
result
;
}
void
EndSubkeyList
(
)
const
{
mKey
.
mBuffer
.
Append
(
eTerminator
+
mTypeOffset
)
;
}
private
:
Key
&
mKey
;
uint8_t
mTypeOffset
;
uint16_t
mRecursionDepth
;
}
;
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeJSValInternal
(
JSContext
*
const
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aVal
uint8_t
aTypeOffset
const
uint16_t
aRecursionDepth
)
{
static_assert
(
eMaxType
*
kMaxArrayCollapse
<
256
"
Unable
to
encode
jsvals
.
"
)
;
if
(
NS_WARN_IF
(
aRecursionDepth
=
=
kMaxRecursionDepth
)
)
{
return
SpecialValues
:
:
Invalid
;
}
if
(
aVal
.
isNumber
(
)
)
{
const
auto
number
=
aVal
.
toNumber
(
)
;
if
(
mozilla
:
:
IsNaN
(
number
)
)
{
return
SpecialValues
:
:
Invalid
;
}
EncodeNumber
(
number
eFloat
+
aTypeOffset
)
;
return
Ok
(
)
;
}
if
(
aVal
.
isString
(
)
)
{
nsAutoJSString
string
;
if
(
!
string
.
init
(
aCx
aVal
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
return
EncodeString
(
string
aTypeOffset
)
;
}
if
(
aVal
.
isObject
(
)
)
{
JS
:
:
RootedObject
object
(
aCx
&
aVal
.
toObject
(
)
)
;
js
:
:
ESClass
builtinClass
;
if
(
!
JS
:
:
GetBuiltinClass
(
aCx
object
&
builtinClass
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
if
(
builtinClass
=
=
js
:
:
ESClass
:
:
Date
)
{
double
ms
;
if
(
!
js
:
:
DateGetMsecSinceEpoch
(
aCx
object
&
ms
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
if
(
mozilla
:
:
IsNaN
(
ms
)
)
{
return
SpecialValues
:
:
Invalid
;
}
EncodeNumber
(
ms
eDate
+
aTypeOffset
)
;
return
Ok
(
)
;
}
if
(
JS
:
:
IsArrayBufferObject
(
object
)
|
|
JS_IsArrayBufferViewObject
(
object
)
)
{
const
bool
isViewObject
=
JS_IsArrayBufferViewObject
(
object
)
;
return
EncodeBinary
(
object
isViewObject
aTypeOffset
)
;
}
if
(
builtinClass
=
=
js
:
:
ESClass
:
:
Array
)
{
return
ConvertArrayValueToKey
(
aCx
object
ArrayValueEncoder
{
*
this
aTypeOffset
aRecursionDepth
}
)
;
}
}
return
SpecialValues
:
:
Invalid
;
}
nsresult
Key
:
:
DecodeJSValInternal
(
const
EncodedDataType
*
&
aPos
const
EncodedDataType
*
aEnd
JSContext
*
aCx
uint8_t
aTypeOffset
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
uint16_t
aRecursionDepth
)
{
if
(
NS_WARN_IF
(
aRecursionDepth
=
=
kMaxRecursionDepth
)
)
{
return
NS_ERROR_DOM_INDEXEDDB_DATA_ERR
;
}
if
(
*
aPos
-
aTypeOffset
>
=
eArray
)
{
JS
:
:
Rooted
<
JSObject
*
>
array
(
aCx
JS
:
:
NewArrayObject
(
aCx
0
)
)
;
if
(
!
array
)
{
NS_WARNING
(
"
Failed
to
make
array
!
"
)
;
IDB_REPORT_INTERNAL_ERR
(
)
;
return
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
aTypeOffset
+
=
eMaxType
;
if
(
aTypeOffset
=
=
eMaxType
*
kMaxArrayCollapse
)
{
+
+
aPos
;
aTypeOffset
=
0
;
}
uint32_t
index
=
0
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCx
)
;
while
(
aPos
<
aEnd
&
&
*
aPos
-
aTypeOffset
!
=
eTerminator
)
{
IDB_TRY
(
DecodeJSValInternal
(
aPos
aEnd
aCx
aTypeOffset
&
val
aRecursionDepth
+
1
)
)
;
aTypeOffset
=
0
;
if
(
!
JS_DefineElement
(
aCx
array
index
+
+
val
JSPROP_ENUMERATE
)
)
{
NS_WARNING
(
"
Failed
to
set
array
element
!
"
)
;
IDB_REPORT_INTERNAL_ERR
(
)
;
return
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
}
NS_ASSERTION
(
aPos
>
=
aEnd
|
|
(
*
aPos
%
eMaxType
)
=
=
eTerminator
"
Should
have
found
end
-
of
-
array
marker
"
)
;
+
+
aPos
;
aVal
.
setObject
(
*
array
)
;
}
else
if
(
*
aPos
-
aTypeOffset
=
=
eString
)
{
auto
key
=
DecodeString
(
aPos
aEnd
)
;
if
(
!
xpc
:
:
StringToJsval
(
aCx
key
aVal
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
}
else
if
(
*
aPos
-
aTypeOffset
=
=
eDate
)
{
double
msec
=
static_cast
<
double
>
(
DecodeNumber
(
aPos
aEnd
)
)
;
JS
:
:
ClippedTime
time
=
JS
:
:
TimeClip
(
msec
)
;
MOZ_ASSERT
(
msec
=
=
time
.
toDouble
(
)
"
encoding
from
a
Date
object
not
containing
an
invalid
date
"
"
means
we
should
always
have
clipped
values
"
)
;
JSObject
*
date
=
JS
:
:
NewDateObject
(
aCx
time
)
;
if
(
!
date
)
{
IDB_WARNING
(
"
Failed
to
make
date
!
"
)
;
return
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
aVal
.
setObject
(
*
date
)
;
}
else
if
(
*
aPos
-
aTypeOffset
=
=
eFloat
)
{
aVal
.
setDouble
(
DecodeNumber
(
aPos
aEnd
)
)
;
}
else
if
(
*
aPos
-
aTypeOffset
=
=
eBinary
)
{
JSObject
*
binary
=
DecodeBinary
(
aPos
aEnd
aCx
)
;
if
(
!
binary
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
aVal
.
setObject
(
*
binary
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
key
type
!
"
)
;
}
return
NS_OK
;
}
#
define
ONE_BYTE_LIMIT
0x7E
#
define
TWO_BYTE_LIMIT
(
0x3FFF
+
0x7F
)
#
define
ONE_BYTE_ADJUST
1
#
define
TWO_BYTE_ADJUST
(
-
0x7F
)
#
define
THREE_BYTE_SHIFT
6
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeJSVal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aVal
uint8_t
aTypeOffset
)
{
return
EncodeJSValInternal
(
aCx
aVal
aTypeOffset
0
)
;
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeString
(
const
nsAString
&
aString
uint8_t
aTypeOffset
)
{
return
EncodeString
(
Span
{
aString
}
aTypeOffset
)
;
}
template
<
typename
T
>
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeString
(
const
Span
<
const
T
>
aInput
uint8_t
aTypeOffset
)
{
return
EncodeAsString
(
aInput
eString
+
aTypeOffset
)
;
}
template
<
typename
T
>
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeAsString
(
const
Span
<
const
T
>
aInput
uint8_t
aType
)
{
if
(
NS_WARN_IF
(
UINT32_MAX
-
2
<
uintptr_t
(
aInput
.
Length
(
)
)
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
CheckedUint32
size
=
2
;
MOZ_ASSERT
(
size
.
isValid
(
)
)
;
const
auto
inputRange
=
mozilla
:
:
detail
:
:
IteratorRange
(
aInput
.
Elements
(
)
aInput
.
Elements
(
)
+
aInput
.
Length
(
)
)
;
CheckedUint32
payloadSize
=
aInput
.
Length
(
)
;
bool
anyMultibyte
=
false
;
for
(
const
auto
val
:
inputRange
)
{
if
(
val
>
ONE_BYTE_LIMIT
)
{
anyMultibyte
=
true
;
payloadSize
+
=
char16_t
(
val
)
>
TWO_BYTE_LIMIT
?
2
:
1
;
if
(
!
payloadSize
.
isValid
(
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
}
}
size
+
=
payloadSize
;
uint32_t
oldLen
=
mBuffer
.
Length
(
)
;
size
+
=
oldLen
;
if
(
!
size
.
isValid
(
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
char
*
buffer
;
if
(
!
mBuffer
.
GetMutableData
(
&
buffer
size
.
value
(
)
)
)
{
IDB_REPORT_INTERNAL_ERR
(
)
;
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
}
}
;
}
buffer
+
=
oldLen
;
*
(
buffer
+
+
)
=
aType
;
if
(
anyMultibyte
)
{
for
(
const
auto
val
:
inputRange
)
{
if
(
val
<
=
ONE_BYTE_LIMIT
)
{
*
(
buffer
+
+
)
=
val
+
ONE_BYTE_ADJUST
;
}
else
if
(
char16_t
(
val
)
<
=
TWO_BYTE_LIMIT
)
{
char16_t
c
=
char16_t
(
val
)
+
TWO_BYTE_ADJUST
+
0x8000
;
*
(
buffer
+
+
)
=
(
char
)
(
c
>
>
8
)
;
*
(
buffer
+
+
)
=
(
char
)
(
c
&
0xFF
)
;
}
else
{
uint32_t
c
=
(
uint32_t
(
val
)
<
<
THREE_BYTE_SHIFT
)
|
0x00C00000
;
*
(
buffer
+
+
)
=
(
char
)
(
c
>
>
16
)
;
*
(
buffer
+
+
)
=
(
char
)
(
c
>
>
8
)
;
*
(
buffer
+
+
)
=
(
char
)
c
;
}
}
}
else
{
const
auto
inputLen
=
std
:
:
distance
(
inputRange
.
cbegin
(
)
inputRange
.
cend
(
)
)
;
MOZ_ASSERT
(
inputLen
=
=
payloadSize
)
;
std
:
:
transform
(
inputRange
.
cbegin
(
)
inputRange
.
cend
(
)
buffer
[
]
(
auto
value
)
{
return
value
+
ONE_BYTE_ADJUST
;
}
)
;
buffer
+
=
inputLen
;
}
*
(
buffer
+
+
)
=
eTerminator
;
NS_ASSERTION
(
buffer
=
=
mBuffer
.
EndReading
(
)
"
Wrote
wrong
number
of
bytes
"
)
;
return
indexedDB
:
:
Ok
(
)
;
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeLocaleString
(
const
nsAString
&
aString
uint8_t
aTypeOffset
const
nsCString
&
aLocale
)
{
const
int
length
=
aString
.
Length
(
)
;
if
(
length
=
=
0
)
{
return
Ok
(
)
;
}
const
UChar
*
ustr
=
reinterpret_cast
<
const
UChar
*
>
(
aString
.
BeginReading
(
)
)
;
UErrorCode
uerror
=
U_ZERO_ERROR
;
UCollator
*
collator
=
ucol_open
(
aLocale
.
get
(
)
&
uerror
)
;
if
(
NS_WARN_IF
(
U_FAILURE
(
uerror
)
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_FAILURE
}
}
;
}
MOZ_ASSERT
(
collator
)
;
AutoTArray
<
uint8_t
128
>
keyBuffer
;
int32_t
sortKeyLength
=
ucol_getSortKey
(
collator
ustr
length
keyBuffer
.
Elements
(
)
keyBuffer
.
Length
(
)
)
;
if
(
sortKeyLength
>
(
int32_t
)
keyBuffer
.
Length
(
)
)
{
if
(
!
keyBuffer
.
SetLength
(
sortKeyLength
fallible
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_OUT_OF_MEMORY
}
}
;
}
sortKeyLength
=
ucol_getSortKey
(
collator
ustr
length
keyBuffer
.
Elements
(
)
sortKeyLength
)
;
}
ucol_close
(
collator
)
;
if
(
NS_WARN_IF
(
sortKeyLength
=
=
0
)
)
{
return
{
SpecialValues
:
:
Exception
ErrorResult
{
NS_ERROR_FAILURE
}
}
;
}
return
EncodeString
(
Span
{
keyBuffer
}
.
AsConst
(
)
.
First
(
sortKeyLength
)
aTypeOffset
)
;
}
nsresult
Key
:
:
DecodeJSVal
(
const
EncodedDataType
*
&
aPos
const
EncodedDataType
*
aEnd
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
return
DecodeJSValInternal
(
aPos
aEnd
aCx
0
aVal
0
)
;
}
template
<
typename
T
>
uint32_t
Key
:
:
CalcDecodedStringySize
(
const
EncodedDataType
*
const
aBegin
const
EncodedDataType
*
const
aEnd
const
EncodedDataType
*
*
aOutEncodedSectionEnd
)
{
static_assert
(
sizeof
(
T
)
<
=
2
"
Only
implemented
for
1
and
2
byte
decoded
types
"
)
;
uint32_t
decodedSize
=
0
;
auto
*
iter
=
aBegin
;
for
(
;
iter
<
aEnd
&
&
*
iter
!
=
eTerminator
;
+
+
iter
)
{
if
(
*
iter
&
0x80
)
{
iter
+
=
(
sizeof
(
T
)
>
1
&
&
(
*
iter
&
0x40
)
)
?
2
:
1
;
}
+
+
decodedSize
;
}
*
aOutEncodedSectionEnd
=
std
:
:
min
(
aEnd
iter
)
;
return
decodedSize
;
}
template
<
typename
T
>
void
Key
:
:
DecodeAsStringy
(
const
EncodedDataType
*
const
aEncodedSectionBegin
const
EncodedDataType
*
const
aEncodedSectionEnd
const
uint32_t
aDecodedLength
T
*
const
aOut
)
{
static_assert
(
sizeof
(
T
)
<
=
2
"
Only
implemented
for
1
and
2
byte
decoded
types
"
)
;
T
*
decodedPos
=
aOut
;
for
(
const
EncodedDataType
*
iter
=
aEncodedSectionBegin
;
iter
<
aEncodedSectionEnd
;
)
{
if
(
!
(
*
iter
&
0x80
)
)
{
*
decodedPos
=
*
(
iter
+
+
)
-
ONE_BYTE_ADJUST
;
}
else
if
(
sizeof
(
T
)
=
=
1
|
|
!
(
*
iter
&
0x40
)
)
{
auto
c
=
static_cast
<
uint16_t
>
(
*
(
iter
+
+
)
)
<
<
8
;
if
(
iter
<
aEncodedSectionEnd
)
{
c
|
=
*
(
iter
+
+
)
;
}
*
decodedPos
=
static_cast
<
T
>
(
c
-
TWO_BYTE_ADJUST
-
0x8000
)
;
}
else
if
(
sizeof
(
T
)
>
1
)
{
auto
c
=
static_cast
<
uint32_t
>
(
*
(
iter
+
+
)
)
<
<
(
16
-
THREE_BYTE_SHIFT
)
;
if
(
iter
<
aEncodedSectionEnd
)
{
c
|
=
static_cast
<
uint32_t
>
(
*
(
iter
+
+
)
)
<
<
(
8
-
THREE_BYTE_SHIFT
)
;
}
if
(
iter
<
aEncodedSectionEnd
)
{
c
|
=
*
(
iter
+
+
)
>
>
THREE_BYTE_SHIFT
;
}
*
decodedPos
=
static_cast
<
T
>
(
c
)
;
}
+
+
decodedPos
;
}
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
decodedPos
-
aOut
)
=
=
aDecodedLength
"
Should
have
written
the
whole
decoded
area
"
)
;
}
template
<
Key
:
:
EncodedDataType
TypeMask
typename
T
typename
AcquireBuffer
typename
AcquireEmpty
>
void
Key
:
:
DecodeStringy
(
const
EncodedDataType
*
&
aPos
const
EncodedDataType
*
aEnd
const
AcquireBuffer
&
acquireBuffer
const
AcquireEmpty
&
acquireEmpty
)
{
NS_ASSERTION
(
*
aPos
%
eMaxType
=
=
TypeMask
"
Don
'
t
call
me
!
"
)
;
const
EncodedDataType
*
const
encodedSectionBegin
=
aPos
+
1
;
const
EncodedDataType
*
encodedSectionEnd
;
const
uint32_t
decodedLength
=
CalcDecodedStringySize
<
T
>
(
encodedSectionBegin
aEnd
&
encodedSectionEnd
)
;
aPos
=
encodedSectionEnd
+
1
;
if
(
!
decodedLength
)
{
acquireEmpty
(
)
;
return
;
}
T
*
out
;
if
(
!
acquireBuffer
(
&
out
decodedLength
)
)
{
return
;
}
DecodeAsStringy
(
encodedSectionBegin
encodedSectionEnd
decodedLength
out
)
;
}
nsAutoString
Key
:
:
DecodeString
(
const
EncodedDataType
*
&
aPos
const
EncodedDataType
*
const
aEnd
)
{
nsAutoString
res
;
DecodeStringy
<
eString
char16_t
>
(
aPos
aEnd
[
&
res
]
(
char16_t
*
*
out
uint32_t
decodedLength
)
{
return
0
!
=
res
.
GetMutableData
(
out
decodedLength
)
;
}
[
]
{
}
)
;
return
res
;
}
void
Key
:
:
EncodeNumber
(
double
aFloat
uint8_t
aType
)
{
uint32_t
oldLen
=
mBuffer
.
Length
(
)
;
char
*
buffer
;
if
(
!
mBuffer
.
GetMutableData
(
&
buffer
oldLen
+
1
+
sizeof
(
double
)
)
)
{
return
;
}
buffer
+
=
oldLen
;
*
(
buffer
+
+
)
=
aType
;
uint64_t
bits
=
BitwiseCast
<
uint64_t
>
(
aFloat
)
;
const
uint64_t
signbit
=
FloatingPoint
<
double
>
:
:
kSignBit
;
uint64_t
number
=
bits
&
signbit
?
(
0
-
bits
)
:
(
bits
|
signbit
)
;
mozilla
:
:
BigEndian
:
:
writeUint64
(
buffer
number
)
;
}
double
Key
:
:
DecodeNumber
(
const
EncodedDataType
*
&
aPos
const
EncodedDataType
*
aEnd
)
{
NS_ASSERTION
(
*
aPos
%
eMaxType
=
=
eFloat
|
|
*
aPos
%
eMaxType
=
=
eDate
"
Don
'
t
call
me
!
"
)
;
+
+
aPos
;
uint64_t
number
=
0
;
memcpy
(
&
number
aPos
std
:
:
min
<
size_t
>
(
sizeof
(
number
)
aEnd
-
aPos
)
)
;
number
=
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
number
)
;
aPos
+
=
sizeof
(
number
)
;
const
uint64_t
signbit
=
FloatingPoint
<
double
>
:
:
kSignBit
;
uint64_t
bits
=
number
&
signbit
?
(
number
&
~
signbit
)
:
(
0
-
number
)
;
return
BitwiseCast
<
double
>
(
bits
)
;
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
EncodeBinary
(
JSObject
*
aObject
bool
aIsViewObject
uint8_t
aTypeOffset
)
{
uint8_t
*
bufferData
;
uint32_t
bufferLength
;
if
(
aIsViewObject
)
{
bool
unused
;
JS_GetObjectAsArrayBufferView
(
aObject
&
bufferLength
&
unused
&
bufferData
)
;
}
else
{
JS
:
:
GetObjectAsArrayBuffer
(
aObject
&
bufferLength
&
bufferData
)
;
}
return
EncodeAsString
(
Span
{
bufferData
bufferLength
}
.
AsConst
(
)
eBinary
+
aTypeOffset
)
;
}
JSObject
*
Key
:
:
DecodeBinary
(
const
EncodedDataType
*
&
aPos
const
EncodedDataType
*
aEnd
JSContext
*
aCx
)
{
JS
:
:
RootedObject
rv
(
aCx
)
;
DecodeStringy
<
eBinary
uint8_t
>
(
aPos
aEnd
[
&
rv
aCx
]
(
uint8_t
*
*
out
uint32_t
decodedSize
)
{
*
out
=
static_cast
<
uint8_t
*
>
(
JS_malloc
(
aCx
decodedSize
)
)
;
if
(
NS_WARN_IF
(
!
*
out
)
)
{
rv
=
nullptr
;
return
false
;
}
rv
=
JS
:
:
NewArrayBufferWithContents
(
aCx
decodedSize
*
out
)
;
return
true
;
}
[
&
rv
aCx
]
{
rv
=
JS
:
:
NewArrayBuffer
(
aCx
0
)
;
}
)
;
return
rv
;
}
nsresult
Key
:
:
BindToStatement
(
mozIStorageStatement
*
aStatement
const
nsACString
&
aParamName
)
const
{
nsresult
rv
;
if
(
IsUnset
(
)
)
{
rv
=
aStatement
-
>
BindNullByName
(
aParamName
)
;
}
else
{
rv
=
aStatement
-
>
BindBlobByName
(
aParamName
reinterpret_cast
<
const
uint8_t
*
>
(
mBuffer
.
get
(
)
)
mBuffer
.
Length
(
)
)
;
}
return
NS_SUCCEEDED
(
rv
)
?
NS_OK
:
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
nsresult
Key
:
:
SetFromStatement
(
mozIStorageStatement
*
aStatement
uint32_t
aIndex
)
{
return
SetFromSource
(
aStatement
aIndex
)
;
}
nsresult
Key
:
:
SetFromValueArray
(
mozIStorageValueArray
*
aValues
uint32_t
aIndex
)
{
return
SetFromSource
(
aValues
aIndex
)
;
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
SetFromJSVal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aVal
)
{
mBuffer
.
Truncate
(
)
;
if
(
aVal
.
isNull
(
)
|
|
aVal
.
isUndefined
(
)
)
{
Unset
(
)
;
return
Ok
(
)
;
}
auto
result
=
EncodeJSVal
(
aCx
aVal
0
)
;
if
(
!
result
.
Is
(
Ok
)
)
{
Unset
(
)
;
return
result
;
}
TrimBuffer
(
)
;
return
Ok
(
)
;
}
nsresult
Key
:
:
ToJSVal
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
const
{
if
(
IsUnset
(
)
)
{
aVal
.
setUndefined
(
)
;
return
NS_OK
;
}
const
EncodedDataType
*
pos
=
BufferStart
(
)
;
nsresult
rv
=
DecodeJSVal
(
pos
BufferEnd
(
)
aCx
aVal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
pos
>
=
BufferEnd
(
)
)
;
return
NS_OK
;
}
nsresult
Key
:
:
ToJSVal
(
JSContext
*
aCx
JS
:
:
Heap
<
JS
:
:
Value
>
&
aVal
)
const
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
nsresult
rv
=
ToJSVal
(
aCx
&
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aVal
=
value
;
}
return
rv
;
}
IDBResult
<
void
IDBSpecialValue
:
:
Invalid
>
Key
:
:
AppendItem
(
JSContext
*
aCx
bool
aFirstOfArray
JS
:
:
Handle
<
JS
:
:
Value
>
aVal
)
{
auto
result
=
EncodeJSVal
(
aCx
aVal
aFirstOfArray
?
eMaxType
:
0
)
;
if
(
!
result
.
Is
(
Ok
)
)
{
Unset
(
)
;
}
return
result
;
}
template
<
typename
T
>
nsresult
Key
:
:
SetFromSource
(
T
*
aSource
uint32_t
aIndex
)
{
const
uint8_t
*
data
;
uint32_t
dataLength
=
0
;
nsresult
rv
=
aSource
-
>
GetSharedBlob
(
aIndex
&
dataLength
&
data
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR
;
}
mBuffer
.
Assign
(
reinterpret_cast
<
const
char
*
>
(
data
)
dataLength
)
;
return
NS_OK
;
}
}
