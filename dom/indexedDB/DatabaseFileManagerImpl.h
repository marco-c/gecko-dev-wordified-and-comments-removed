#
ifndef
DOM_INDEXEDDB_DATABASEFILEMANAGERIMPL_H_
#
define
DOM_INDEXEDDB_DATABASEFILEMANAGERIMPL_H_
#
include
"
DatabaseFileManager
.
h
"
#
include
"
ActorsParentCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
:
:
dom
:
:
indexedDB
{
template
<
typename
KnownDirEntryOp
typename
UnknownDirEntryOp
>
Result
<
Ok
nsresult
>
DatabaseFileManager
:
:
TraverseFiles
(
nsIFile
&
aDirectory
KnownDirEntryOp
&
&
aKnownDirEntryOp
UnknownDirEntryOp
&
&
aUnknownDirEntryOp
)
{
quota
:
:
AssertIsOnIOThread
(
)
;
QM_TRY_INSPECT
(
const
bool
&
exists
MOZ_TO_RESULT_INVOKE
(
aDirectory
Exists
)
)
;
if
(
!
exists
)
{
return
Ok
{
}
;
}
QM_TRY
(
quota
:
:
CollectEachFile
(
aDirectory
[
&
aKnownDirEntryOp
&
aUnknownDirEntryOp
]
(
const
nsCOMPtr
<
nsIFile
>
&
file
)
-
>
Result
<
Ok
nsresult
>
{
QM_TRY_INSPECT
(
const
auto
&
dirEntryKind
quota
:
:
GetDirEntryKind
(
*
file
)
)
;
switch
(
dirEntryKind
)
{
case
quota
:
:
nsIFileKind
:
:
ExistsAsDirectory
:
{
QM_TRY_INSPECT
(
const
auto
&
leafName
MOZ_TO_RESULT_INVOKE_TYPED
(
nsString
file
GetLeafName
)
)
;
if
(
leafName
.
Equals
(
kJournalDirectoryName
)
)
{
QM_TRY
(
std
:
:
forward
<
KnownDirEntryOp
>
(
aKnownDirEntryOp
)
(
*
file
true
)
)
;
break
;
}
Unused
<
<
WARN_IF_FILE_IS_UNKNOWN
(
*
file
)
;
QM_TRY
(
std
:
:
forward
<
UnknownDirEntryOp
>
(
aUnknownDirEntryOp
)
(
*
file
true
)
)
;
break
;
}
case
quota
:
:
nsIFileKind
:
:
ExistsAsFile
:
{
QM_TRY_INSPECT
(
const
auto
&
leafName
MOZ_TO_RESULT_INVOKE_TYPED
(
nsString
file
GetLeafName
)
)
;
nsresult
rv
;
leafName
.
ToInteger64
(
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
QM_TRY
(
std
:
:
forward
<
KnownDirEntryOp
>
(
aKnownDirEntryOp
)
(
*
file
false
)
)
;
break
;
}
Unused
<
<
WARN_IF_FILE_IS_UNKNOWN
(
*
file
)
;
QM_TRY
(
std
:
:
forward
<
UnknownDirEntryOp
>
(
aUnknownDirEntryOp
)
(
*
file
false
)
)
;
break
;
}
case
quota
:
:
nsIFileKind
:
:
DoesNotExist
:
break
;
}
return
Ok
{
}
;
}
)
)
;
return
Ok
{
}
;
}
}
#
endif
