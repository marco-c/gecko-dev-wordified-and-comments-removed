#
ifndef
mozilla_dom_indexeddb_filemanagerbase_h__
#
define
mozilla_dom_indexeddb_filemanagerbase_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
FileInfo
.
h
"
#
include
"
FlippedOnce
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
indexedDB
{
template
<
typename
FileManager
>
class
FileManagerBase
{
public
:
using
FileInfo
=
FileInfo
<
FileManager
>
;
using
MutexType
=
StaticMutex
;
using
AutoLock
=
mozilla
:
:
detail
:
:
BaseAutoLock
<
MutexType
&
>
;
[
[
nodiscard
]
]
SafeRefPtr
<
FileInfo
>
GetFileInfo
(
int64_t
aId
)
const
{
return
AcquireFileInfo
(
[
this
aId
]
{
return
mFileInfos
.
MaybeGet
(
aId
)
;
}
)
;
}
[
[
nodiscard
]
]
SafeRefPtr
<
FileInfo
>
CreateFileInfo
(
)
{
return
AcquireFileInfo
(
[
this
]
{
const
int64_t
id
=
+
+
mLastFileId
;
auto
fileInfo
=
MakeNotNull
<
FileInfo
*
>
(
FileManagerGuard
{
}
SafeRefPtr
{
static_cast
<
FileManager
*
>
(
this
)
AcquireStrongRefFromRawPtr
{
}
}
id
)
;
mFileInfos
.
InsertOrUpdate
(
id
fileInfo
)
;
return
Some
(
fileInfo
)
;
}
)
;
}
void
RemoveFileInfo
(
const
int64_t
aId
const
AutoLock
&
aFileMutexLock
)
{
#
ifdef
DEBUG
aFileMutexLock
.
AssertOwns
(
FileManager
:
:
Mutex
(
)
)
;
#
endif
mFileInfos
.
Remove
(
aId
)
;
}
nsresult
Invalidate
(
)
{
AutoLock
lock
(
FileManager
:
:
Mutex
(
)
)
;
mInvalidated
.
Flip
(
)
;
mFileInfos
.
RemoveIf
(
[
]
(
const
auto
&
iter
)
{
FileInfo
*
info
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
info
)
;
return
!
info
-
>
LockedClearDBRefs
(
FileManagerGuard
{
}
)
;
}
)
;
return
NS_OK
;
}
bool
Invalidated
(
)
const
{
return
mInvalidated
;
}
class
FileManagerGuard
{
FileManagerGuard
(
)
=
default
;
}
;
private
:
template
<
typename
FileInfoTableOp
>
[
[
nodiscard
]
]
SafeRefPtr
<
FileInfo
>
AcquireFileInfo
(
const
FileInfoTableOp
&
aFileInfoTableOp
)
const
{
if
(
!
AssertValid
(
)
)
{
return
nullptr
;
}
auto
fileInfo
=
[
&
aFileInfoTableOp
]
(
)
-
>
RefPtr
<
FileInfo
>
{
AutoLock
lock
(
FileManager
:
:
Mutex
(
)
)
;
const
auto
maybeFileInfo
=
aFileInfoTableOp
(
)
;
if
(
maybeFileInfo
)
{
const
auto
&
fileInfo
=
maybeFileInfo
.
ref
(
)
;
fileInfo
-
>
LockedAddRef
(
)
;
return
dont_AddRef
(
fileInfo
.
get
(
)
)
;
}
return
{
}
;
}
(
)
;
return
SafeRefPtr
{
std
:
:
move
(
fileInfo
)
}
;
}
protected
:
bool
AssertValid
(
)
const
{
if
(
NS_WARN_IF
(
static_cast
<
const
FileManager
*
>
(
this
)
-
>
Invalidated
(
)
)
)
{
MOZ_ASSERT
(
false
)
;
return
false
;
}
return
true
;
}
#
ifdef
DEBUG
~
FileManagerBase
(
)
{
MOZ_ASSERT
(
mFileInfos
.
IsEmpty
(
)
)
;
}
#
else
~
FileManagerBase
(
)
=
default
;
#
endif
int64_t
mLastFileId
=
0
;
nsTHashMap
<
nsUint64HashKey
NotNull
<
FileInfo
*
>
>
mFileInfos
;
FlippedOnce
<
false
>
mInvalidated
;
}
;
}
}
}
#
endif
