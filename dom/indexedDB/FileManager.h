#
ifndef
mozilla_dom_indexeddb_filemanager_h__
#
define
mozilla_dom_indexeddb_filemanager_h__
#
include
"
mozilla
/
dom
/
quota
/
PersistenceType
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
FileManagerBase
.
h
"
class
nsIFile
;
class
mozIStorageConnection
;
namespace
mozilla
{
namespace
dom
{
namespace
indexedDB
{
class
FileManager
final
:
public
FileManagerBase
<
FileManager
>
{
using
PersistenceType
=
mozilla
:
:
dom
:
:
quota
:
:
PersistenceType
;
using
FileManagerBase
<
FileManager
>
:
:
MutexType
;
const
PersistenceType
mPersistenceType
;
const
nsCString
mGroup
;
const
nsCString
mOrigin
;
const
nsString
mDatabaseName
;
LazyInitializedOnce
<
const
nsString
>
mDirectoryPath
;
LazyInitializedOnce
<
const
nsString
>
mJournalDirectoryPath
;
const
bool
mEnforcingQuota
;
static
MutexType
sMutex
;
public
:
[
[
nodiscard
]
]
static
nsCOMPtr
<
nsIFile
>
GetFileForId
(
nsIFile
*
aDirectory
int64_t
aId
)
;
[
[
nodiscard
]
]
static
nsCOMPtr
<
nsIFile
>
GetCheckedFileForId
(
nsIFile
*
aDirectory
int64_t
aId
)
;
static
nsresult
InitDirectory
(
nsIFile
&
aDirectory
nsIFile
&
aDatabaseFile
const
nsACString
&
aOrigin
uint32_t
aTelemetryId
)
;
static
nsresult
GetUsage
(
nsIFile
*
aDirectory
Maybe
<
uint64_t
>
&
aUsage
)
;
static
nsresult
GetUsage
(
nsIFile
*
aDirectory
uint64_t
&
aUsage
)
;
FileManager
(
PersistenceType
aPersistenceType
const
nsACString
&
aGroup
const
nsACString
&
aOrigin
const
nsAString
&
aDatabaseName
bool
aEnforcingQuota
)
;
PersistenceType
Type
(
)
const
{
return
mPersistenceType
;
}
const
nsACString
&
Group
(
)
const
{
return
mGroup
;
}
const
nsACString
&
Origin
(
)
const
{
return
mOrigin
;
}
const
nsAString
&
DatabaseName
(
)
const
{
return
mDatabaseName
;
}
bool
EnforcingQuota
(
)
const
{
return
mEnforcingQuota
;
}
nsresult
Init
(
nsIFile
*
aDirectory
mozIStorageConnection
*
aConnection
)
;
[
[
nodiscard
]
]
nsCOMPtr
<
nsIFile
>
GetDirectory
(
)
;
[
[
nodiscard
]
]
nsCOMPtr
<
nsIFile
>
GetCheckedDirectory
(
)
;
[
[
nodiscard
]
]
nsCOMPtr
<
nsIFile
>
GetJournalDirectory
(
)
;
[
[
nodiscard
]
]
nsCOMPtr
<
nsIFile
>
EnsureJournalDirectory
(
)
;
[
[
nodiscard
]
]
nsresult
SyncDeleteFile
(
int64_t
aId
)
;
[
[
nodiscard
]
]
nsresult
SyncDeleteFile
(
nsIFile
&
aFile
nsIFile
&
aJournalFile
)
;
[
[
nodiscard
]
]
nsresult
AsyncDeleteFile
(
int64_t
aFileId
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FileManager
)
static
StaticMutex
&
Mutex
(
)
{
return
sMutex
;
}
private
:
~
FileManager
(
)
=
default
;
}
;
}
}
}
#
endif
