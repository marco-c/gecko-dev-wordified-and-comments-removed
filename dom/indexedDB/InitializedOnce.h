#
ifndef
mozilla_dom_indexeddb_initializedonce_h__
#
define
mozilla_dom_indexeddb_initializedonce_h__
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
<
type_traits
>
namespace
mozilla
{
enum
struct
LazyInit
{
Allow
AllowResettable
ForbidResettable
}
;
namespace
ValueCheckPolicies
{
template
<
typename
T
>
struct
AllowAnyValue
{
constexpr
static
bool
Check
(
const
T
&
)
{
return
true
;
}
}
;
template
<
typename
T
>
struct
ConvertsToTrue
{
constexpr
static
bool
Check
(
const
T
&
aValue
)
{
return
static_cast
<
bool
>
(
aValue
)
;
}
}
;
}
template
<
typename
T
LazyInit
LazyInitVal
=
LazyInit
:
:
ForbidResettable
template
<
typename
>
class
ValueCheckPolicy
=
ValueCheckPolicies
:
:
AllowAnyValue
>
class
InitializedOnce
final
{
static_assert
(
std
:
:
is_const_v
<
T
>
)
;
public
:
template
<
typename
Dummy
=
void
>
explicit
InitializedOnce
(
std
:
:
enable_if_t
<
LazyInitVal
=
=
LazyInit
:
:
Allow
|
|
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
Dummy
>
*
=
nullptr
)
{
}
template
<
typename
Arg0
typename
.
.
.
Args
>
explicit
InitializedOnce
(
Arg0
&
&
aArg0
Args
&
&
.
.
.
aArgs
)
:
mMaybe
{
Some
(
std
:
:
remove_const_t
<
T
>
{
std
:
:
forward
<
Arg0
>
(
aArg0
)
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
)
}
{
MOZ_ASSERT
(
ValueCheckPolicy
<
T
>
:
:
Check
(
*
mMaybe
)
)
;
}
InitializedOnce
(
const
InitializedOnce
&
)
=
delete
;
InitializedOnce
(
InitializedOnce
&
&
aOther
)
:
mMaybe
{
std
:
:
move
(
aOther
.
mMaybe
)
}
{
static_assert
(
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
|
|
LazyInitVal
=
=
LazyInit
:
:
ForbidResettable
)
;
#
ifdef
DEBUG
aOther
.
mWasReset
=
true
;
#
endif
}
InitializedOnce
&
operator
=
(
const
InitializedOnce
&
)
=
delete
;
InitializedOnce
&
operator
=
(
InitializedOnce
&
&
aOther
)
{
static_assert
(
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
)
;
MOZ_ASSERT
(
!
mWasReset
)
;
MOZ_ASSERT
(
!
mMaybe
)
;
mMaybe
.
~
Maybe
<
std
:
:
remove_const_t
<
T
>
>
(
)
;
new
(
&
mMaybe
)
Maybe
<
T
>
{
std
:
:
move
(
aOther
.
mMaybe
)
}
;
#
ifdef
DEBUG
aOther
.
mWasReset
=
true
;
#
endif
return
*
this
;
}
template
<
typename
.
.
.
Args
typename
Dummy
=
void
>
std
:
:
enable_if_t
<
LazyInitVal
=
=
LazyInit
:
:
Allow
|
|
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
Dummy
>
init
(
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
mMaybe
.
isNothing
(
)
)
;
MOZ_ASSERT
(
!
mWasReset
)
;
mMaybe
.
emplace
(
std
:
:
remove_const_t
<
T
>
{
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
}
)
;
MOZ_ASSERT
(
ValueCheckPolicy
<
T
>
:
:
Check
(
*
mMaybe
)
)
;
}
explicit
operator
bool
(
)
const
{
return
isSome
(
)
;
}
bool
isSome
(
)
const
{
return
mMaybe
.
isSome
(
)
;
}
bool
isNothing
(
)
const
{
return
mMaybe
.
isNothing
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
mMaybe
;
}
T
*
operator
-
>
(
)
const
{
return
mMaybe
.
operator
-
>
(
)
;
}
template
<
typename
Dummy
=
void
>
std
:
:
enable_if_t
<
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
|
|
LazyInitVal
=
=
LazyInit
:
:
ForbidResettable
Dummy
>
reset
(
)
{
MOZ_ASSERT
(
mMaybe
.
isSome
(
)
)
;
maybeReset
(
)
;
}
template
<
typename
Dummy
=
void
>
std
:
:
enable_if_t
<
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
|
|
LazyInitVal
=
=
LazyInit
:
:
ForbidResettable
Dummy
>
maybeReset
(
)
{
mMaybe
.
reset
(
)
;
#
ifdef
DEBUG
mWasReset
=
true
;
#
endif
}
template
<
typename
Dummy
=
T
>
std
:
:
enable_if_t
<
LazyInitVal
=
=
LazyInit
:
:
AllowResettable
|
|
LazyInitVal
=
=
LazyInit
:
:
ForbidResettable
Dummy
>
release
(
)
{
MOZ_ASSERT
(
mMaybe
.
isSome
(
)
)
;
auto
res
=
std
:
:
move
(
mMaybe
.
ref
(
)
)
;
maybeReset
(
)
;
return
res
;
}
private
:
Maybe
<
std
:
:
remove_const_t
<
T
>
>
mMaybe
;
#
ifdef
DEBUG
bool
mWasReset
=
false
;
#
endif
}
;
template
<
typename
T
LazyInit
LazyInitVal
=
LazyInit
:
:
ForbidResettable
>
using
InitializedOnceMustBeTrue
=
InitializedOnce
<
T
LazyInitVal
ValueCheckPolicies
:
:
ConvertsToTrue
>
;
}
#
endif
