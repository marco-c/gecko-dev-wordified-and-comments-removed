#
ifndef
mozilla_dom_indexeddatabase_h__
#
define
mozilla_dom_indexeddatabase_h__
#
include
"
DatabaseFileInfoFwd
.
h
"
#
include
"
SafeRefPtr
.
h
"
#
include
"
js
/
StructuredClone
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
{
class
Blob
;
class
IDBDatabase
;
namespace
indexedDB
{
struct
StructuredCloneFileBase
{
enum
FileType
{
eBlob
eMutableFile
eStructuredClone
eWasmBytecode
eWasmCompiled
eEndGuard
}
;
FileType
Type
(
)
const
{
return
mType
;
}
protected
:
explicit
StructuredCloneFileBase
(
FileType
aType
)
:
mType
{
aType
}
{
}
FileType
mType
;
}
;
struct
StructuredCloneFileChild
:
StructuredCloneFileBase
{
StructuredCloneFileChild
(
const
StructuredCloneFileChild
&
)
=
delete
;
StructuredCloneFileChild
&
operator
=
(
const
StructuredCloneFileChild
&
)
=
delete
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
StructuredCloneFileChild
(
StructuredCloneFileChild
&
&
)
;
#
else
StructuredCloneFileChild
(
StructuredCloneFileChild
&
&
)
=
default
;
#
endif
StructuredCloneFileChild
&
operator
=
(
StructuredCloneFileChild
&
&
)
=
delete
;
~
StructuredCloneFileChild
(
)
;
explicit
StructuredCloneFileChild
(
FileType
aType
)
;
StructuredCloneFileChild
(
FileType
aType
RefPtr
<
Blob
>
aBlob
)
;
const
dom
:
:
Blob
&
Blob
(
)
const
{
return
*
mContents
-
>
as
<
RefPtr
<
dom
:
:
Blob
>
>
(
)
;
}
dom
:
:
Blob
&
MutableBlob
(
)
const
{
return
*
mContents
-
>
as
<
RefPtr
<
dom
:
:
Blob
>
>
(
)
;
}
RefPtr
<
dom
:
:
Blob
>
BlobPtr
(
)
const
;
bool
HasBlob
(
)
const
{
return
mContents
-
>
is
<
RefPtr
<
dom
:
:
Blob
>
>
(
)
;
}
private
:
InitializedOnce
<
const
Variant
<
Nothing
RefPtr
<
dom
:
:
Blob
>
>
>
mContents
;
}
;
struct
StructuredCloneFileParent
:
StructuredCloneFileBase
{
StructuredCloneFileParent
(
const
StructuredCloneFileParent
&
)
=
delete
;
StructuredCloneFileParent
&
operator
=
(
const
StructuredCloneFileParent
&
)
=
delete
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
StructuredCloneFileParent
(
StructuredCloneFileParent
&
&
)
;
#
else
StructuredCloneFileParent
(
StructuredCloneFileParent
&
&
)
=
default
;
#
endif
StructuredCloneFileParent
&
operator
=
(
StructuredCloneFileParent
&
&
)
=
delete
;
StructuredCloneFileParent
(
FileType
aType
SafeRefPtr
<
DatabaseFileInfo
>
aFileInfo
)
;
~
StructuredCloneFileParent
(
)
;
void
MutateType
(
FileType
aNewType
)
{
mType
=
aNewType
;
}
const
DatabaseFileInfo
&
FileInfo
(
)
const
{
return
*
*
*
mContents
;
}
SafeRefPtr
<
DatabaseFileInfo
>
FileInfoPtr
(
)
const
;
private
:
InitializedOnce
<
const
Maybe
<
SafeRefPtr
<
DatabaseFileInfo
>
>
>
mContents
;
}
;
struct
StructuredCloneReadInfoBase
{
explicit
StructuredCloneReadInfoBase
(
JSStructuredCloneData
&
&
aData
)
:
mData
{
std
:
:
move
(
aData
)
}
{
}
const
JSStructuredCloneData
&
Data
(
)
const
{
return
mData
;
}
JSStructuredCloneData
ReleaseData
(
)
{
return
std
:
:
move
(
mData
)
;
}
private
:
JSStructuredCloneData
mData
;
}
;
template
<
typename
StructuredCloneFileT
>
struct
StructuredCloneReadInfo
:
StructuredCloneReadInfoBase
{
using
StructuredCloneFile
=
StructuredCloneFileT
;
explicit
StructuredCloneReadInfo
(
JS
:
:
StructuredCloneScope
aScope
)
;
StructuredCloneReadInfo
(
)
;
StructuredCloneReadInfo
(
JSStructuredCloneData
&
&
aData
nsTArray
<
StructuredCloneFile
>
aFiles
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
~
StructuredCloneReadInfo
(
)
;
StructuredCloneReadInfo
(
StructuredCloneReadInfo
&
&
aOther
)
noexcept
;
#
else
StructuredCloneReadInfo
(
StructuredCloneReadInfo
&
&
aOther
)
=
default
;
#
endif
StructuredCloneReadInfo
&
operator
=
(
StructuredCloneReadInfo
&
&
aOther
)
=
default
;
StructuredCloneReadInfo
(
const
StructuredCloneReadInfo
&
aOther
)
=
delete
;
StructuredCloneReadInfo
&
operator
=
(
const
StructuredCloneReadInfo
&
aOther
)
=
delete
;
size_t
Size
(
)
const
;
StructuredCloneFile
&
MutableFile
(
const
size_t
aIndex
)
{
return
mFiles
[
aIndex
]
;
}
const
nsTArray
<
StructuredCloneFile
>
&
Files
(
)
const
{
return
mFiles
;
}
nsTArray
<
StructuredCloneFile
>
ReleaseFiles
(
)
{
return
std
:
:
move
(
mFiles
)
;
}
bool
HasFiles
(
)
const
{
return
!
mFiles
.
IsEmpty
(
)
;
}
private
:
nsTArray
<
StructuredCloneFile
>
mFiles
;
}
;
struct
StructuredCloneReadInfoChild
:
StructuredCloneReadInfo
<
StructuredCloneFileChild
>
{
inline
StructuredCloneReadInfoChild
(
JSStructuredCloneData
&
&
aData
nsTArray
<
StructuredCloneFileChild
>
aFiles
IDBDatabase
*
aDatabase
)
;
IDBDatabase
*
Database
(
)
const
{
return
mDatabase
;
}
private
:
IDBDatabase
*
mDatabase
;
}
;
struct
StructuredCloneReadInfoParent
:
StructuredCloneReadInfo
<
StructuredCloneFileParent
>
{
StructuredCloneReadInfoParent
(
JSStructuredCloneData
&
&
aData
nsTArray
<
StructuredCloneFileParent
>
aFiles
bool
aHasPreprocessInfo
)
:
StructuredCloneReadInfo
{
std
:
:
move
(
aData
)
std
:
:
move
(
aFiles
)
}
mHasPreprocessInfo
{
aHasPreprocessInfo
}
{
}
bool
HasPreprocessInfo
(
)
const
{
return
mHasPreprocessInfo
;
}
private
:
bool
mHasPreprocessInfo
;
}
;
template
<
typename
StructuredCloneReadInfo
>
JSObject
*
CommonStructuredCloneReadCallback
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
const
JS
:
:
CloneDataPolicy
&
aCloneDataPolicy
uint32_t
aTag
uint32_t
aData
StructuredCloneReadInfo
*
aCloneReadInfo
IDBDatabase
*
aDatabase
)
;
template
<
typename
StructuredCloneReadInfoType
>
JSObject
*
StructuredCloneReadCallback
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
const
JS
:
:
CloneDataPolicy
&
aCloneDataPolicy
uint32_t
aTag
uint32_t
aData
void
*
aClosure
)
;
}
}
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
dom
:
:
indexedDB
:
:
StructuredCloneReadInfo
<
mozilla
:
:
dom
:
:
indexedDB
:
:
StructuredCloneFileChild
>
)
;
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
dom
:
:
indexedDB
:
:
StructuredCloneReadInfo
<
mozilla
:
:
dom
:
:
indexedDB
:
:
StructuredCloneFileParent
>
)
;
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
dom
:
:
indexedDB
:
:
StructuredCloneReadInfoChild
)
;
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
dom
:
:
indexedDB
:
:
StructuredCloneReadInfoParent
)
;
#
endif
