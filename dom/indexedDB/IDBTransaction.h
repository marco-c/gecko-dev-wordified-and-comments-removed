#
ifndef
mozilla_dom_idbtransaction_h__
#
define
mozilla_dom_idbtransaction_h__
#
include
"
FlippedOnce
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
IDBTransactionBinding
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
CheckedUnsafePtr
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
ErrorResult
;
class
EventChainPreVisitor
;
namespace
dom
{
class
DOMException
;
class
DOMStringList
;
class
IDBCursor
;
class
IDBDatabase
;
class
IDBObjectStore
;
class
IDBOpenDBRequest
;
class
IDBRequest
;
class
StrongWorkerRef
;
namespace
indexedDB
{
class
PBackgroundIDBCursorChild
;
class
BackgroundRequestChild
;
class
BackgroundTransactionChild
;
class
BackgroundVersionChangeTransactionChild
;
class
IndexMetadata
;
class
ObjectStoreSpec
;
class
OpenCursorParams
;
class
RequestParams
;
}
class
IDBTransaction
final
:
public
DOMEventTargetHelper
public
nsIRunnable
public
SupportsCheckedUnsafePtr
<
CheckIf
<
DiagnosticAssertEnabled
>
>
{
friend
class
indexedDB
:
:
BackgroundRequestChild
;
public
:
enum
struct
Mode
{
ReadOnly
=
0
ReadWrite
ReadWriteFlush
Cleanup
VersionChange
Invalid
}
;
enum
struct
ReadyState
{
Active
Inactive
Committing
Finished
}
;
private
:
RefPtr
<
IDBDatabase
>
mDatabase
;
RefPtr
<
DOMException
>
mError
;
const
nsTArray
<
nsString
>
mObjectStoreNames
;
nsTArray
<
RefPtr
<
IDBObjectStore
>
>
mObjectStores
;
nsTArray
<
RefPtr
<
IDBObjectStore
>
>
mDeletedObjectStores
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
nsTArray
<
IDBCursor
*
>
mCursors
;
union
{
indexedDB
:
:
BackgroundTransactionChild
*
mNormalBackgroundActor
;
indexedDB
:
:
BackgroundVersionChangeTransactionChild
*
mVersionChangeBackgroundActor
;
}
mBackgroundActor
;
const
int64_t
mLoggingSerialNumber
;
int64_t
mNextObjectStoreId
;
int64_t
mNextIndexId
;
nsresult
mAbortCode
;
uint32_t
mPendingRequestCount
;
const
nsString
mFilename
;
const
uint32_t
mLineNo
;
const
uint32_t
mColumn
;
ReadyState
mReadyState
=
ReadyState
:
:
Active
;
FlippedOnce
<
false
>
mStarted
;
const
Mode
mMode
;
bool
mRegistered
;
FlippedOnce
<
false
>
mAbortedByScript
;
bool
mNotedActiveTransaction
;
FlippedOnce
<
false
>
mSentCommitOrAbort
;
#
ifdef
DEBUG
FlippedOnce
<
false
>
mFiredCompleteOrAbort
;
FlippedOnce
<
false
>
mWasExplicitlyCommitted
;
#
endif
public
:
static
MOZ_MUST_USE
RefPtr
<
IDBTransaction
>
CreateVersionChange
(
IDBDatabase
*
aDatabase
indexedDB
:
:
BackgroundVersionChangeTransactionChild
*
aActor
IDBOpenDBRequest
*
aOpenRequest
int64_t
aNextObjectStoreId
int64_t
aNextIndexId
)
;
static
MOZ_MUST_USE
RefPtr
<
IDBTransaction
>
Create
(
JSContext
*
aCx
IDBDatabase
*
aDatabase
const
nsTArray
<
nsString
>
&
aObjectStoreNames
Mode
aMode
)
;
static
IDBTransaction
*
GetCurrent
(
)
;
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
void
SetBackgroundActor
(
indexedDB
:
:
BackgroundTransactionChild
*
aBackgroundActor
)
;
void
ClearBackgroundActor
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mMode
=
=
Mode
:
:
VersionChange
)
{
mBackgroundActor
.
mVersionChangeBackgroundActor
=
nullptr
;
}
else
{
mBackgroundActor
.
mNormalBackgroundActor
=
nullptr
;
}
MaybeNoteInactiveTransaction
(
)
;
}
indexedDB
:
:
BackgroundRequestChild
*
StartRequest
(
IDBRequest
*
aRequest
const
indexedDB
:
:
RequestParams
&
aParams
)
;
void
OpenCursor
(
indexedDB
:
:
PBackgroundIDBCursorChild
*
aBackgroundActor
const
indexedDB
:
:
OpenCursorParams
&
aParams
)
;
void
RefreshSpec
(
bool
aMayDelete
)
;
bool
IsCommittingOrFinished
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mReadyState
=
=
ReadyState
:
:
Committing
|
|
mReadyState
=
=
ReadyState
:
:
Finished
;
}
bool
IsActive
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mReadyState
=
=
ReadyState
:
:
Active
;
}
bool
IsInactive
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mReadyState
=
=
ReadyState
:
:
Inactive
;
}
bool
IsFinished
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mReadyState
=
=
ReadyState
:
:
Finished
;
}
bool
IsWriteAllowed
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mMode
=
=
Mode
:
:
ReadWrite
|
|
mMode
=
=
Mode
:
:
ReadWriteFlush
|
|
mMode
=
=
Mode
:
:
Cleanup
|
|
mMode
=
=
Mode
:
:
VersionChange
;
}
bool
IsAborted
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
NS_FAILED
(
mAbortCode
)
;
}
#
ifdef
DEBUG
bool
WasExplicitlyCommitted
(
)
const
{
return
mWasExplicitlyCommitted
;
}
#
endif
template
<
ReadyState
OriginalState
ReadyState
TemporaryState
>
class
AutoRestoreState
{
public
:
explicit
AutoRestoreState
(
IDBTransaction
&
aOwner
)
:
mOwner
{
aOwner
}
#
ifdef
DEBUG
mSavedPendingRequestCount
{
mOwner
.
mPendingRequestCount
}
#
endif
{
mOwner
.
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mOwner
.
mReadyState
=
=
OriginalState
)
;
mOwner
.
mReadyState
=
TemporaryState
;
}
~
AutoRestoreState
(
)
{
mOwner
.
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mOwner
.
mReadyState
=
=
TemporaryState
)
;
MOZ_ASSERT
(
mOwner
.
mPendingRequestCount
=
=
mSavedPendingRequestCount
)
;
mOwner
.
mReadyState
=
OriginalState
;
}
private
:
IDBTransaction
&
mOwner
;
#
ifdef
DEBUG
const
uint32_t
mSavedPendingRequestCount
;
#
endif
}
;
AutoRestoreState
<
ReadyState
:
:
Inactive
ReadyState
:
:
Active
>
TemporarilyTransitionToActive
(
)
;
AutoRestoreState
<
ReadyState
:
:
Active
ReadyState
:
:
Inactive
>
TemporarilyTransitionToInactive
(
)
;
void
TransitionToActive
(
)
{
MOZ_ASSERT
(
mReadyState
=
=
ReadyState
:
:
Inactive
)
;
mReadyState
=
ReadyState
:
:
Active
;
}
void
TransitionToInactive
(
)
{
MOZ_ASSERT
(
mReadyState
=
=
ReadyState
:
:
Active
)
;
mReadyState
=
ReadyState
:
:
Inactive
;
}
nsresult
AbortCode
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mAbortCode
;
}
void
GetCallerLocation
(
nsAString
&
aFilename
uint32_t
*
aLineNo
uint32_t
*
aColumn
)
const
;
Mode
GetMode
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mMode
;
}
IDBDatabase
*
Database
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mDatabase
;
}
const
nsTArray
<
nsString
>
&
ObjectStoreNamesInternal
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mObjectStoreNames
;
}
MOZ_MUST_USE
RefPtr
<
IDBObjectStore
>
CreateObjectStore
(
indexedDB
:
:
ObjectStoreSpec
&
aSpec
)
;
void
DeleteObjectStore
(
int64_t
aObjectStoreId
)
;
void
RenameObjectStore
(
int64_t
aObjectStoreId
const
nsAString
&
aName
)
;
void
CreateIndex
(
IDBObjectStore
*
aObjectStore
const
indexedDB
:
:
IndexMetadata
&
aMetadata
)
;
void
DeleteIndex
(
IDBObjectStore
*
aObjectStore
int64_t
aIndexId
)
;
void
RenameIndex
(
IDBObjectStore
*
aObjectStore
int64_t
aIndexId
const
nsAString
&
aName
)
;
void
Abort
(
IDBRequest
*
aRequest
)
;
void
Abort
(
nsresult
aErrorCode
)
;
int64_t
LoggingSerialNumber
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mLoggingSerialNumber
;
}
nsIGlobalObject
*
GetParentObject
(
)
const
;
void
FireCompleteOrAbortEvents
(
nsresult
aResult
)
;
int64_t
NextObjectStoreId
(
)
;
int64_t
NextIndexId
(
)
;
void
InvalidateCursorCaches
(
)
;
void
RegisterCursor
(
IDBCursor
*
aCursor
)
;
void
UnregisterCursor
(
IDBCursor
*
aCursor
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
IDBTransaction
DOMEventTargetHelper
)
void
CommitIfNotStarted
(
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
IDBDatabase
*
Db
(
)
const
{
return
Database
(
)
;
}
IDBTransactionMode
GetMode
(
ErrorResult
&
aRv
)
const
;
DOMException
*
GetError
(
)
const
;
MOZ_MUST_USE
RefPtr
<
IDBObjectStore
>
ObjectStore
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
;
void
Commit
(
ErrorResult
&
aRv
)
;
void
Abort
(
ErrorResult
&
aRv
)
;
IMPL_EVENT_HANDLER
(
abort
)
IMPL_EVENT_HANDLER
(
complete
)
IMPL_EVENT_HANDLER
(
error
)
MOZ_MUST_USE
RefPtr
<
DOMStringList
>
ObjectStoreNames
(
)
const
;
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
private
:
struct
CreatedFromFactoryFunction
{
}
;
public
:
IDBTransaction
(
IDBDatabase
*
aDatabase
const
nsTArray
<
nsString
>
&
aObjectStoreNames
Mode
aMode
nsString
aFilename
uint32_t
aLineNo
uint32_t
aColumn
CreatedFromFactoryFunction
aDummy
)
;
private
:
~
IDBTransaction
(
)
;
void
AbortInternal
(
nsresult
aAbortCode
RefPtr
<
DOMException
>
aError
)
;
void
SendCommit
(
bool
aAutoCommit
)
;
void
SendAbort
(
nsresult
aResultCode
)
;
void
NoteActiveTransaction
(
)
;
void
MaybeNoteInactiveTransaction
(
)
;
public
:
void
OnNewRequest
(
)
;
void
OnRequestFinished
(
bool
aRequestCompletedSuccessfully
)
;
private
:
template
<
typename
Func
>
auto
DoWithTransactionChild
(
const
Func
&
aFunc
)
const
;
bool
HasTransactionChild
(
)
const
;
}
;
}
}
#
endif
