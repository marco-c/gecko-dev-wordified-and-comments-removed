#
ifndef
mozilla_dom_indexeddb_actorschild_h__
#
define
mozilla_dom_indexeddb_actorschild_h__
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
IDBCursorType
.
h
"
#
include
"
mozilla
/
dom
/
IDBTransaction
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBCursorChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBDatabaseChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBDatabaseRequestChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBFactoryChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBFactoryRequestChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBRequestChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBSharedTypes
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBTransactionChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIDBVersionChangeTransactionChild
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
PBackgroundIndexedDBUtilsChild
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundFileHandleChild
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundFileRequestChild
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundMutableFileChild
.
h
"
#
include
"
mozilla
/
InitializedOnce
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIEventTarget
;
struct
nsID
;
namespace
mozilla
{
namespace
ipc
{
class
BackgroundChildImpl
;
}
namespace
dom
{
class
IDBCursor
;
class
IDBDatabase
;
class
IDBFactory
;
class
IDBFileHandle
;
class
IDBFileRequest
;
class
IDBMutableFile
;
class
IDBOpenDBRequest
;
class
IDBRequest
;
class
IndexedDatabaseManager
;
namespace
indexedDB
{
class
Key
;
class
PermissionRequestChild
;
class
PermissionRequestParent
;
class
SerializedStructuredCloneReadInfo
;
struct
CloneInfo
;
}
}
}
MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
(
mozilla
:
:
dom
:
:
indexedDB
:
:
CloneInfo
)
namespace
mozilla
:
:
dom
:
:
indexedDB
{
class
BackgroundFactoryChild
final
:
public
PBackgroundIDBFactoryChild
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
friend
IDBFactory
;
IDBFactory
*
mFactory
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
BackgroundFactoryChild
override
)
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
BackgroundFactoryChild
)
;
}
IDBFactory
&
GetDOMObject
(
)
const
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mFactory
)
;
return
*
mFactory
;
}
bool
SendDeleteMe
(
)
=
delete
;
private
:
explicit
BackgroundFactoryChild
(
IDBFactory
&
aFactory
)
;
~
BackgroundFactoryChild
(
)
;
void
SendDeleteMeInternal
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
PBackgroundIDBFactoryRequestChild
*
AllocPBackgroundIDBFactoryRequestChild
(
const
FactoryRequestParams
&
aParams
)
;
bool
DeallocPBackgroundIDBFactoryRequestChild
(
PBackgroundIDBFactoryRequestChild
*
aActor
)
;
PBackgroundIDBDatabaseChild
*
AllocPBackgroundIDBDatabaseChild
(
const
DatabaseSpec
&
aSpec
PBackgroundIDBFactoryRequestChild
*
aRequest
)
const
;
bool
DeallocPBackgroundIDBDatabaseChild
(
PBackgroundIDBDatabaseChild
*
aActor
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPBackgroundIDBDatabaseConstructor
(
PBackgroundIDBDatabaseChild
*
aActor
const
DatabaseSpec
&
aSpec
PBackgroundIDBFactoryRequestChild
*
aRequest
)
override
;
}
;
class
BackgroundDatabaseChild
;
class
BackgroundRequestChildBase
{
protected
:
const
NotNull
<
RefPtr
<
IDBRequest
>
>
mRequest
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
protected
:
explicit
BackgroundRequestChildBase
(
MovingNotNull
<
RefPtr
<
IDBRequest
>
>
aRequest
)
;
virtual
~
BackgroundRequestChildBase
(
)
;
}
;
class
BackgroundFactoryRequestChild
final
:
public
BackgroundRequestChildBase
public
PBackgroundIDBFactoryRequestChild
{
using
PersistenceType
=
mozilla
:
:
dom
:
:
quota
:
:
PersistenceType
;
friend
IDBFactory
;
friend
class
BackgroundFactoryChild
;
friend
class
BackgroundDatabaseChild
;
friend
class
PermissionRequestChild
;
friend
class
PermissionRequestParent
;
const
SafeRefPtr
<
IDBFactory
>
mFactory
;
BackgroundDatabaseChild
*
mDatabaseActor
;
const
uint64_t
mRequestedVersion
;
const
bool
mIsDeleteOp
;
public
:
NotNull
<
IDBOpenDBRequest
*
>
GetOpenDBRequest
(
)
const
;
private
:
BackgroundFactoryRequestChild
(
SafeRefPtr
<
IDBFactory
>
aFactory
MovingNotNull
<
RefPtr
<
IDBOpenDBRequest
>
>
aOpenRequest
bool
aIsDeleteOp
uint64_t
aRequestedVersion
)
;
~
BackgroundFactoryRequestChild
(
)
;
void
SetDatabaseActor
(
BackgroundDatabaseChild
*
aActor
)
;
void
HandleResponse
(
nsresult
aResponse
)
;
void
HandleResponse
(
const
OpenDatabaseRequestResponse
&
aResponse
)
;
void
HandleResponse
(
const
DeleteDatabaseRequestResponse
&
aResponse
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
Recv__delete__
(
const
FactoryRequestResponse
&
aResponse
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPermissionChallenge
(
PrincipalInfo
&
&
aPrincipalInfo
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvBlocked
(
uint64_t
aCurrentVersion
)
;
}
;
class
BackgroundDatabaseChild
final
:
public
PBackgroundIDBDatabaseChild
{
friend
class
BackgroundFactoryChild
;
friend
class
BackgroundFactoryRequestChild
;
friend
IDBDatabase
;
UniquePtr
<
DatabaseSpec
>
mSpec
;
RefPtr
<
IDBDatabase
>
mTemporaryStrongDatabase
;
BackgroundFactoryRequestChild
*
mOpenRequestActor
;
IDBDatabase
*
mDatabase
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
const
DatabaseSpec
*
Spec
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mSpec
.
get
(
)
;
}
IDBDatabase
*
GetDOMObject
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mDatabase
;
}
bool
SendDeleteMe
(
)
=
delete
;
private
:
BackgroundDatabaseChild
(
const
DatabaseSpec
&
aSpec
BackgroundFactoryRequestChild
*
aOpenRequest
)
;
~
BackgroundDatabaseChild
(
)
;
void
SendDeleteMeInternal
(
)
;
[
[
nodiscard
]
]
bool
EnsureDOMObject
(
)
;
void
ReleaseDOMObject
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
PBackgroundIDBDatabaseFileChild
*
AllocPBackgroundIDBDatabaseFileChild
(
const
IPCBlob
&
aIPCBlob
)
;
bool
DeallocPBackgroundIDBDatabaseFileChild
(
PBackgroundIDBDatabaseFileChild
*
aActor
)
const
;
PBackgroundIDBDatabaseRequestChild
*
AllocPBackgroundIDBDatabaseRequestChild
(
const
DatabaseRequestParams
&
aParams
)
;
bool
DeallocPBackgroundIDBDatabaseRequestChild
(
PBackgroundIDBDatabaseRequestChild
*
aActor
)
;
already_AddRefed
<
PBackgroundIDBVersionChangeTransactionChild
>
AllocPBackgroundIDBVersionChangeTransactionChild
(
uint64_t
aCurrentVersion
uint64_t
aRequestedVersion
int64_t
aNextObjectStoreId
int64_t
aNextIndexId
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPBackgroundIDBVersionChangeTransactionConstructor
(
PBackgroundIDBVersionChangeTransactionChild
*
aActor
const
uint64_t
&
aCurrentVersion
const
uint64_t
&
aRequestedVersion
const
int64_t
&
aNextObjectStoreId
const
int64_t
&
aNextIndexId
)
override
;
PBackgroundMutableFileChild
*
AllocPBackgroundMutableFileChild
(
const
nsString
&
aName
const
nsString
&
aType
)
const
;
bool
DeallocPBackgroundMutableFileChild
(
PBackgroundMutableFileChild
*
aActor
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvVersionChange
(
uint64_t
aOldVersion
Maybe
<
uint64_t
>
aNewVersion
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvInvalidate
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCloseAfterInvalidationComplete
(
)
;
}
;
class
BackgroundDatabaseRequestChild
final
:
public
BackgroundRequestChildBase
public
PBackgroundIDBDatabaseRequestChild
{
friend
class
BackgroundDatabaseChild
;
friend
IDBDatabase
;
RefPtr
<
IDBDatabase
>
mDatabase
;
private
:
BackgroundDatabaseRequestChild
(
IDBDatabase
*
aDatabase
MovingNotNull
<
RefPtr
<
IDBRequest
>
>
aRequest
)
;
~
BackgroundDatabaseRequestChild
(
)
;
void
HandleResponse
(
nsresult
aResponse
)
;
void
HandleResponse
(
const
CreateFileRequestResponse
&
aResponse
)
;
public
:
mozilla
:
:
ipc
:
:
IPCResult
Recv__delete__
(
const
DatabaseRequestResponse
&
aResponse
)
;
}
;
class
BackgroundVersionChangeTransactionChild
;
class
BackgroundTransactionBase
{
friend
class
BackgroundVersionChangeTransactionChild
;
SafeRefPtr
<
IDBTransaction
>
mTemporaryStrongTransaction
;
protected
:
IDBTransaction
*
mTransaction
=
nullptr
;
public
:
#
ifdef
DEBUG
virtual
void
AssertIsOnOwningThread
(
)
const
=
0
;
#
else
void
AssertIsOnOwningThread
(
)
const
{
}
#
endif
IDBTransaction
*
GetDOMObject
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mTransaction
;
}
protected
:
MOZ_COUNTED_DEFAULT_CTOR
(
BackgroundTransactionBase
)
;
explicit
BackgroundTransactionBase
(
SafeRefPtr
<
IDBTransaction
>
aTransaction
)
;
MOZ_COUNTED_DTOR_VIRTUAL
(
BackgroundTransactionBase
)
;
void
NoteActorDestroyed
(
)
;
void
NoteComplete
(
)
;
private
:
void
SetDOMTransaction
(
SafeRefPtr
<
IDBTransaction
>
aTransaction
)
;
}
;
class
BackgroundTransactionChild
final
:
public
BackgroundTransactionBase
public
PBackgroundIDBTransactionChild
{
friend
class
BackgroundDatabaseChild
;
friend
IDBDatabase
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
BackgroundTransactionChild
override
)
#
ifdef
DEBUG
void
AssertIsOnOwningThread
(
)
const
override
;
#
endif
void
SendDeleteMeInternal
(
)
;
bool
SendDeleteMe
(
)
=
delete
;
private
:
explicit
BackgroundTransactionChild
(
SafeRefPtr
<
IDBTransaction
>
aTransaction
)
;
~
BackgroundTransactionChild
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvComplete
(
nsresult
aResult
)
;
PBackgroundIDBRequestChild
*
AllocPBackgroundIDBRequestChild
(
const
RequestParams
&
aParams
)
;
bool
DeallocPBackgroundIDBRequestChild
(
PBackgroundIDBRequestChild
*
aActor
)
;
PBackgroundIDBCursorChild
*
AllocPBackgroundIDBCursorChild
(
const
OpenCursorParams
&
aParams
)
;
bool
DeallocPBackgroundIDBCursorChild
(
PBackgroundIDBCursorChild
*
aActor
)
;
}
;
class
BackgroundVersionChangeTransactionChild
final
:
public
BackgroundTransactionBase
public
PBackgroundIDBVersionChangeTransactionChild
{
friend
class
BackgroundDatabaseChild
;
IDBOpenDBRequest
*
mOpenDBRequest
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
BackgroundVersionChangeTransactionChild
override
)
#
ifdef
DEBUG
void
AssertIsOnOwningThread
(
)
const
override
;
#
endif
void
SendDeleteMeInternal
(
bool
aFailedConstructor
)
;
bool
SendDeleteMe
(
)
=
delete
;
private
:
explicit
BackgroundVersionChangeTransactionChild
(
IDBOpenDBRequest
*
aOpenDBRequest
)
;
~
BackgroundVersionChangeTransactionChild
(
)
;
using
BackgroundTransactionBase
:
:
SetDOMTransaction
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvComplete
(
nsresult
aResult
)
;
PBackgroundIDBRequestChild
*
AllocPBackgroundIDBRequestChild
(
const
RequestParams
&
aParams
)
;
bool
DeallocPBackgroundIDBRequestChild
(
PBackgroundIDBRequestChild
*
aActor
)
;
PBackgroundIDBCursorChild
*
AllocPBackgroundIDBCursorChild
(
const
OpenCursorParams
&
aParams
)
;
bool
DeallocPBackgroundIDBCursorChild
(
PBackgroundIDBCursorChild
*
aActor
)
;
}
;
class
BackgroundMutableFileChild
final
:
public
PBackgroundMutableFileChild
{
friend
class
BackgroundDatabaseChild
;
friend
IDBMutableFile
;
RefPtr
<
IDBMutableFile
>
mTemporaryStrongMutableFile
;
IDBMutableFile
*
mMutableFile
;
nsString
mName
;
nsString
mType
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
void
EnsureDOMObject
(
)
;
IDBMutableFile
*
GetDOMObject
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mMutableFile
;
}
void
ReleaseDOMObject
(
)
;
bool
SendDeleteMe
(
)
=
delete
;
private
:
BackgroundMutableFileChild
(
const
nsAString
&
aName
const
nsAString
&
aType
)
;
~
BackgroundMutableFileChild
(
)
;
void
SendDeleteMeInternal
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
PBackgroundFileHandleChild
*
AllocPBackgroundFileHandleChild
(
const
FileMode
&
aMode
)
;
bool
DeallocPBackgroundFileHandleChild
(
PBackgroundFileHandleChild
*
aActor
)
const
;
}
;
class
BackgroundRequestChild
final
:
public
BackgroundRequestChildBase
public
PBackgroundIDBRequestChild
{
friend
class
BackgroundTransactionChild
;
friend
class
BackgroundVersionChangeTransactionChild
;
friend
struct
CloneInfo
;
friend
IDBTransaction
;
class
PreprocessHelper
;
SafeRefPtr
<
IDBTransaction
>
mTransaction
;
nsTArray
<
CloneInfo
>
mCloneInfos
;
uint32_t
mRunningPreprocessHelpers
;
uint32_t
mCurrentCloneDataIndex
;
nsresult
mPreprocessResultCode
;
bool
mGetAll
;
private
:
explicit
BackgroundRequestChild
(
MovingNotNull
<
RefPtr
<
IDBRequest
>
>
aRequest
)
;
~
BackgroundRequestChild
(
)
;
void
MaybeSendContinue
(
)
;
void
OnPreprocessFinished
(
uint32_t
aCloneDataIndex
UniquePtr
<
JSStructuredCloneData
>
aCloneData
)
;
void
OnPreprocessFailed
(
uint32_t
aCloneDataIndex
nsresult
aErrorCode
)
;
UniquePtr
<
JSStructuredCloneData
>
GetNextCloneData
(
)
;
void
HandleResponse
(
nsresult
aResponse
)
;
void
HandleResponse
(
const
Key
&
aResponse
)
;
void
HandleResponse
(
const
nsTArray
<
Key
>
&
aResponse
)
;
void
HandleResponse
(
SerializedStructuredCloneReadInfo
&
&
aResponse
)
;
void
HandleResponse
(
nsTArray
<
SerializedStructuredCloneReadInfo
>
&
&
aResponse
)
;
void
HandleResponse
(
JS
:
:
Handle
<
JS
:
:
Value
>
aResponse
)
;
void
HandleResponse
(
uint64_t
aResponse
)
;
nsresult
HandlePreprocess
(
const
PreprocessInfo
&
aPreprocessInfo
)
;
nsresult
HandlePreprocess
(
const
nsTArray
<
PreprocessInfo
>
&
aPreprocessInfos
)
;
nsresult
HandlePreprocessInternal
(
const
nsTArray
<
PreprocessInfo
>
&
aPreprocessInfos
)
;
SafeRefPtr
<
IDBTransaction
>
AcquireTransaction
(
)
const
{
return
mTransaction
.
clonePtr
(
)
;
}
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
Recv__delete__
(
RequestResponse
&
&
aResponse
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPreprocess
(
const
PreprocessParams
&
aParams
)
;
}
;
struct
CloneInfo
{
RefPtr
<
BackgroundRequestChild
:
:
PreprocessHelper
>
mPreprocessHelper
;
UniquePtr
<
JSStructuredCloneData
>
mCloneData
;
}
;
class
BackgroundCursorChildBase
:
public
PBackgroundIDBCursorChild
public
SafeRefCounted
<
BackgroundCursorChildBase
>
{
private
:
NS_DECL_OWNINGTHREAD
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
mozilla
:
:
dom
:
:
indexedDB
:
:
BackgroundCursorChildBase
)
MOZ_INLINE_DECL_SAFEREFCOUNTING_INHERITED
(
BackgroundCursorChildBase
SafeRefCounted
)
protected
:
~
BackgroundCursorChildBase
(
)
;
InitializedOnce
<
const
NotNull
<
IDBRequest
*
>
>
mRequest
;
Maybe
<
IDBTransaction
&
>
mTransaction
;
RefPtr
<
IDBRequest
>
mStrongRequest
;
RefPtr
<
IDBCursor
>
mStrongCursor
;
const
Direction
mDirection
;
BackgroundCursorChildBase
(
NotNull
<
IDBRequest
*
>
aRequest
Direction
aDirection
)
;
void
HandleResponse
(
nsresult
aResponse
)
;
public
:
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
BackgroundCursorChildBase
)
;
}
MovingNotNull
<
RefPtr
<
IDBRequest
>
>
AcquireRequest
(
)
const
;
NotNull
<
IDBRequest
*
>
GetRequest
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
*
mRequest
;
}
Direction
GetDirection
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mDirection
;
}
virtual
void
SendDeleteMeInternal
(
)
=
0
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvResponse
(
CursorResponse
&
&
aResponse
)
=
0
;
}
;
template
<
IDBCursorType
CursorType
>
class
BackgroundCursorChild
final
:
public
BackgroundCursorChildBase
{
public
:
using
SourceType
=
CursorSourceType
<
CursorType
>
;
using
ResponseType
=
typename
CursorTypeTraits
<
CursorType
>
:
:
ResponseType
;
private
:
friend
class
BackgroundTransactionChild
;
friend
class
BackgroundVersionChangeTransactionChild
;
InitializedOnce
<
const
NotNull
<
SourceType
*
>
>
mSource
;
IDBCursorImpl
<
CursorType
>
*
mCursor
;
std
:
:
deque
<
CursorData
<
CursorType
>
>
mCachedResponses
mDelayedResponses
;
bool
mInFlightResponseInvalidationNeeded
;
public
:
BackgroundCursorChild
(
NotNull
<
IDBRequest
*
>
aRequest
SourceType
*
aSource
Direction
aDirection
)
;
void
SendContinueInternal
(
const
CursorRequestParams
&
aParams
const
CursorData
<
CursorType
>
&
aCurrentData
)
;
void
InvalidateCachedResponses
(
)
;
template
<
typename
Condition
>
void
DiscardCachedResponses
(
const
Condition
&
aConditionFunc
)
;
SourceType
*
GetSource
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
*
mSource
;
}
void
SendDeleteMeInternal
(
)
final
;
private
:
~
BackgroundCursorChild
(
)
;
void
CompleteContinueRequestFromCache
(
)
;
using
BackgroundCursorChildBase
:
:
HandleResponse
;
void
HandleResponse
(
const
void_t
&
aResponse
)
;
void
HandleResponse
(
nsTArray
<
ResponseType
>
&
&
aResponses
)
;
template
<
typename
Func
>
void
HandleMultipleCursorResponses
(
nsTArray
<
ResponseType
>
&
&
aResponses
const
Func
&
aHandleRecord
)
;
template
<
typename
.
.
.
Args
>
[
[
nodiscard
]
]
RefPtr
<
IDBCursor
>
HandleIndividualCursorResponse
(
bool
aUseAsCurrentResult
Args
&
&
.
.
.
aArgs
)
;
SafeRefPtr
<
BackgroundCursorChild
>
SafeRefPtrFromThis
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvResponse
(
CursorResponse
&
&
aResponse
)
override
;
bool
SendContinue
(
const
CursorRequestParams
&
aParams
const
Key
&
aCurrentKey
const
Key
&
aCurrentObjectStoreKey
)
=
delete
;
bool
SendDeleteMe
(
)
=
delete
;
}
;
class
BackgroundFileHandleChild
:
public
PBackgroundFileHandleChild
{
friend
class
BackgroundMutableFileChild
;
friend
IDBMutableFile
;
RefPtr
<
IDBFileHandle
>
mTemporaryStrongFileHandle
;
IDBFileHandle
*
mFileHandle
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
void
SendDeleteMeInternal
(
)
;
bool
SendDeleteMe
(
)
=
delete
;
private
:
explicit
BackgroundFileHandleChild
(
IDBFileHandle
*
aFileHandle
)
;
~
BackgroundFileHandleChild
(
)
;
void
NoteActorDestroyed
(
)
;
void
NoteComplete
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvComplete
(
bool
aAborted
)
;
PBackgroundFileRequestChild
*
AllocPBackgroundFileRequestChild
(
const
FileRequestParams
&
aParams
)
;
bool
DeallocPBackgroundFileRequestChild
(
PBackgroundFileRequestChild
*
aActor
)
;
}
;
class
BackgroundFileRequestChild
final
:
public
PBackgroundFileRequestChild
{
friend
class
BackgroundFileHandleChild
;
friend
IDBFileHandle
;
RefPtr
<
IDBFileRequest
>
mFileRequest
;
RefPtr
<
IDBFileHandle
>
mFileHandle
;
bool
mActorDestroyed
;
public
:
void
AssertIsOnOwningThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
private
:
explicit
BackgroundFileRequestChild
(
IDBFileRequest
*
aFileRequest
)
;
~
BackgroundFileRequestChild
(
)
;
void
HandleResponse
(
nsresult
aResponse
)
;
void
HandleResponse
(
const
nsCString
&
aResponse
)
;
void
HandleResponse
(
const
FileRequestMetadata
&
aResponse
)
;
void
HandleResponse
(
JS
:
:
Handle
<
JS
:
:
Value
>
aResponse
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
Recv__delete__
(
const
FileRequestResponse
&
aResponse
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvProgress
(
uint64_t
aProgress
uint64_t
aProgressMax
)
;
}
;
class
BackgroundUtilsChild
final
:
public
PBackgroundIndexedDBUtilsChild
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
friend
IndexedDatabaseManager
;
IndexedDatabaseManager
*
mManager
;
NS_DECL_OWNINGTHREAD
public
:
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
BackgroundUtilsChild
)
;
}
bool
SendDeleteMe
(
)
=
delete
;
private
:
explicit
BackgroundUtilsChild
(
IndexedDatabaseManager
*
aManager
)
;
~
BackgroundUtilsChild
(
)
;
void
SendDeleteMeInternal
(
)
;
public
:
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
}
#
endif
