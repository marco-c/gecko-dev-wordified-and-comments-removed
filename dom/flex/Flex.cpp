#
include
"
Flex
.
h
"
#
include
"
FlexLineValues
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FlexBinding
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
Flex
mParent
mLines
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Flex
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Flex
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Flex
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
Flex
:
:
Flex
(
Element
*
aParent
nsFlexContainerFrame
*
aFrame
)
:
mParent
(
aParent
)
{
MOZ_ASSERT
(
aFrame
"
Should
never
be
instantiated
with
a
null
nsFlexContainerFrame
"
)
;
const
ComputedFlexContainerInfo
*
containerInfo
=
aFrame
-
>
GetFlexContainerInfo
(
)
;
if
(
!
containerInfo
)
{
mMainAxisDirection
=
FlexPhysicalDirection
:
:
Horizontal_lr
;
mCrossAxisDirection
=
FlexPhysicalDirection
:
:
Vertical_tb
;
return
;
}
mLines
.
SetLength
(
containerInfo
-
>
mLines
.
Length
(
)
)
;
uint32_t
index
=
0
;
for
(
auto
&
&
l
:
containerInfo
-
>
mLines
)
{
FlexLineValues
*
line
=
new
FlexLineValues
(
this
&
l
)
;
mLines
.
ElementAt
(
index
)
=
line
;
index
+
+
;
}
mMainAxisDirection
=
containerInfo
-
>
mMainAxisDirection
;
mCrossAxisDirection
=
containerInfo
-
>
mCrossAxisDirection
;
}
JSObject
*
Flex
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Flex_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
Flex
:
:
GetLines
(
nsTArray
<
RefPtr
<
FlexLineValues
>
>
&
aResult
)
{
aResult
.
AppendElements
(
mLines
)
;
}
FlexPhysicalDirection
Flex
:
:
MainAxisDirection
(
)
const
{
return
mMainAxisDirection
;
}
FlexPhysicalDirection
Flex
:
:
CrossAxisDirection
(
)
const
{
return
mCrossAxisDirection
;
}
}
