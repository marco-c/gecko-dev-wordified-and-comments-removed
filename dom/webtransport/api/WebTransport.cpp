#
include
"
WebTransport
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIWebTransportStream
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
DOMExceptionBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PWebTransport
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStreamDefaultController
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportDatagramDuplexStream
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportError
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportLog
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
WebTransport
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
WebTransport
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIncomingUnidirectionalStreams
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIncomingBidirectionalStreams
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIncomingUnidirectionalAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIncomingBidirectionalAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSendStreams
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReceiveStreams
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDatagrams
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReady
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mClosed
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
WebTransport
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGlobal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIncomingUnidirectionalStreams
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIncomingBidirectionalStreams
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIncomingUnidirectionalAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIncomingBidirectionalAlgorithm
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSendStreams
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReceiveStreams
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDatagrams
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReady
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mClosed
)
if
(
tmp
-
>
mChild
)
{
tmp
-
>
mChild
-
>
Shutdown
(
false
)
;
tmp
-
>
mChild
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WebTransport
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WebTransport
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WebTransport
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
WebTransport
:
:
WebTransport
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
mState
(
WebTransportState
:
:
CONNECTING
)
mReliability
(
WebTransportReliabilityMode
:
:
Pending
)
{
LOG
(
(
"
Creating
WebTransport
%
p
"
this
)
)
;
}
WebTransport
:
:
~
WebTransport
(
)
{
LOG
(
(
"
~
WebTransport
(
)
for
%
p
"
this
)
)
;
MOZ_ASSERT
(
mSendStreams
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mReceiveStreams
.
IsEmpty
(
)
)
;
if
(
mChild
)
{
mChild
-
>
Shutdown
(
true
)
;
}
}
void
WebTransport
:
:
NewBidirectionalStream
(
const
RefPtr
<
mozilla
:
:
ipc
:
:
DataPipeReceiver
>
&
aIncoming
const
RefPtr
<
mozilla
:
:
ipc
:
:
DataPipeSender
>
&
aOutgoing
)
{
LOG_VERBOSE
(
(
"
NewUnidirectionalStream
(
)
"
)
)
;
}
void
WebTransport
:
:
NewUnidirectionalStream
(
const
RefPtr
<
mozilla
:
:
ipc
:
:
DataPipeReceiver
>
&
aStream
)
{
LOG_VERBOSE
(
(
"
NewUnidirectionalStream
(
)
"
)
)
;
mUnidirectionalStreams
.
Push
(
aStream
)
;
if
(
mIncomingUnidirectionalAlgorithm
)
{
RefPtr
<
WebTransportIncomingStreamsAlgorithms
>
callback
=
mIncomingUnidirectionalAlgorithm
;
LOG
(
(
"
NotifyIncomingStream
"
)
)
;
callback
-
>
NotifyIncomingStream
(
)
;
}
}
nsIGlobalObject
*
WebTransport
:
:
GetParentObject
(
)
const
{
return
mGlobal
;
}
JSObject
*
WebTransport
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WebTransport_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
WebTransport
>
WebTransport
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aURL
const
WebTransportOptions
&
aOptions
ErrorResult
&
aError
)
{
LOG
(
(
"
Creating
WebTransport
for
%
s
"
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
WebTransport
>
result
=
new
WebTransport
(
global
)
;
result
-
>
Init
(
aGlobal
aURL
aOptions
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
return
result
.
forget
(
)
;
}
void
WebTransport
:
:
Init
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aURL
const
WebTransportOptions
&
aOptions
ErrorResult
&
aError
)
{
using
mozilla
:
:
ipc
:
:
BackgroundChild
;
using
mozilla
:
:
ipc
:
:
Endpoint
;
using
mozilla
:
:
ipc
:
:
PBackgroundChild
;
if
(
!
ParseURL
(
aURL
)
)
{
aError
.
ThrowSyntaxError
(
"
Invalid
WebTransport
URL
"
)
;
return
;
}
bool
dedicated
=
!
aOptions
.
mAllowPooling
;
if
(
aOptions
.
mServerCertificateHashes
.
WasPassed
(
)
)
{
aError
.
ThrowNotSupportedError
(
"
No
support
for
serverCertificateHashes
yet
"
)
;
return
;
}
bool
requireUnreliable
=
aOptions
.
mRequireUnreliable
;
WebTransportCongestionControl
congestionControl
=
WebTransportCongestionControl
:
:
Default
;
mReady
=
Promise
:
:
Create
(
mGlobal
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
mClosed
=
Promise
:
:
Create
(
mGlobal
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
PBackgroundChild
*
backgroundChild
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundChild
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
Endpoint
<
PWebTransportParent
>
parentEndpoint
;
Endpoint
<
PWebTransportChild
>
childEndpoint
;
MOZ_ALWAYS_SUCCEEDS
(
PWebTransport
:
:
CreateEndpoints
(
&
parentEndpoint
&
childEndpoint
)
)
;
RefPtr
<
WebTransportChild
>
child
=
new
WebTransportChild
(
this
)
;
if
(
!
childEndpoint
.
Bind
(
child
)
)
{
return
;
}
mState
=
WebTransportState
:
:
CONNECTING
;
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
underlying
;
const
nsCOMPtr
<
nsIGlobalObject
>
global
(
mGlobal
)
;
mIncomingBidirectionalAlgorithm
=
new
WebTransportIncomingStreamsAlgorithms
(
WebTransportIncomingStreamsAlgorithms
:
:
StreamType
:
:
Bidirectional
this
)
;
RefPtr
<
WebTransportIncomingStreamsAlgorithms
>
algorithm
=
mIncomingBidirectionalAlgorithm
;
mIncomingBidirectionalStreams
=
ReadableStream
:
:
CreateNative
(
cx
global
*
algorithm
Some
(
0
.
0
)
nullptr
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
mIncomingUnidirectionalAlgorithm
=
new
WebTransportIncomingStreamsAlgorithms
(
WebTransportIncomingStreamsAlgorithms
:
:
StreamType
:
:
Unidirectional
this
)
;
algorithm
=
mIncomingUnidirectionalAlgorithm
;
mIncomingUnidirectionalStreams
=
ReadableStream
:
:
CreateNative
(
cx
global
*
algorithm
Some
(
0
.
0
)
nullptr
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
LOG
(
(
"
Connecting
WebTransport
to
parent
for
%
s
"
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
)
)
;
backgroundChild
-
>
SendCreateWebTransportParent
(
aURL
principal
dedicated
requireUnreliable
(
uint32_t
)
congestionControl
std
:
:
move
(
parentEndpoint
)
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
RefPtr
{
this
}
child
]
(
PBackgroundChild
:
:
CreateWebTransportParentPromise
:
:
ResolveOrRejectValue
&
&
aResult
)
{
nsresult
rv
=
aResult
.
IsReject
(
)
?
NS_ERROR_FAILURE
:
Get
<
0
>
(
aResult
.
ResolveValue
(
)
)
;
LOG
(
(
"
isreject
:
%
d
nsresult
0x
%
x
"
aResult
.
IsReject
(
)
(
uint32_t
)
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
RejectWaitingConnection
(
rv
child
)
;
}
else
{
self
-
>
ResolveWaitingConnection
(
static_cast
<
WebTransportReliabilityMode
>
(
Get
<
1
>
(
aResult
.
ResolveValue
(
)
)
)
child
)
;
}
}
)
;
}
void
WebTransport
:
:
ResolveWaitingConnection
(
WebTransportReliabilityMode
aReliability
WebTransportChild
*
aChild
)
{
LOG
(
(
"
Resolved
Connection
%
p
reliability
=
%
u
"
this
(
unsigned
)
aReliability
)
)
;
if
(
mState
!
=
WebTransportState
:
:
CONNECTING
)
{
return
;
}
mChild
=
aChild
;
mState
=
WebTransportState
:
:
CONNECTED
;
mReliability
=
aReliability
;
mReady
-
>
MaybeResolveWithUndefined
(
)
;
}
void
WebTransport
:
:
RejectWaitingConnection
(
nsresult
aRv
WebTransportChild
*
aChild
)
{
LOG
(
(
"
Rejected
connection
%
p
%
x
"
this
(
uint32_t
)
aRv
)
)
;
if
(
mState
=
=
WebTransportState
:
:
CLOSED
|
|
mState
=
=
WebTransportState
:
:
FAILED
)
{
return
;
}
RefPtr
<
WebTransportError
>
error
=
new
WebTransportError
(
"
WebTransport
session
rejected
"
_ns
WebTransportErrorSource
:
:
Session
)
;
ErrorResult
errorresult
;
Cleanup
(
error
nullptr
errorresult
)
;
aChild
-
>
Shutdown
(
true
)
;
}
bool
WebTransport
:
:
ParseURL
(
const
nsAString
&
aURL
)
const
{
NS_ENSURE_TRUE
(
!
aURL
.
IsEmpty
(
)
false
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aURL
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
uri
-
>
SchemeIs
(
"
https
"
)
)
{
return
false
;
}
bool
hasRef
;
rv
=
uri
-
>
GetHasRef
(
&
hasRef
)
;
NS_ENSURE_TRUE
(
NS_SUCCEEDED
(
rv
)
&
&
!
hasRef
false
)
;
return
true
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
GetStats
(
ErrorResult
&
aError
)
{
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
WebTransportReliabilityMode
WebTransport
:
:
Reliability
(
)
{
return
mReliability
;
}
WebTransportCongestionControl
WebTransport
:
:
CongestionControl
(
)
{
return
WebTransportCongestionControl
:
:
Default
;
}
void
WebTransport
:
:
RemoteClosed
(
bool
aCleanly
const
uint32_t
&
aCode
const
nsACString
&
aReason
)
{
LOG
(
(
"
Server
closed
:
cleanly
:
%
d
code
%
u
reason
%
s
"
aCleanly
aCode
PromiseFlatCString
(
aReason
)
.
get
(
)
)
)
;
if
(
mState
=
=
WebTransportState
:
:
CLOSED
|
|
mState
=
=
WebTransportState
:
:
FAILED
)
{
return
;
}
RefPtr
<
WebTransportError
>
error
=
new
WebTransportError
(
"
remote
WebTransport
close
"
_ns
WebTransportErrorSource
:
:
Session
)
;
ErrorResult
errorresult
;
if
(
!
aCleanly
)
{
Cleanup
(
error
nullptr
errorresult
)
;
return
;
}
WebTransportCloseInfo
closeinfo
;
closeinfo
.
mCloseCode
=
aCode
;
closeinfo
.
mReason
=
aReason
;
Cleanup
(
error
&
closeinfo
errorresult
)
;
}
void
WebTransport
:
:
Close
(
const
WebTransportCloseInfo
&
aOptions
ErrorResult
&
aRv
)
{
LOG
(
(
"
Close
(
)
called
"
)
)
;
if
(
mState
=
=
WebTransportState
:
:
CLOSED
|
|
mState
=
=
WebTransportState
:
:
FAILED
)
{
return
;
}
if
(
mState
=
=
WebTransportState
:
:
CONNECTING
)
{
RefPtr
<
WebTransportError
>
error
=
new
WebTransportError
(
"
close
(
)
called
on
WebTransport
while
connecting
"
_ns
WebTransportErrorSource
:
:
Session
)
;
Cleanup
(
error
nullptr
aRv
)
;
MOZ_ASSERT
(
!
mChild
)
;
return
;
}
LOG
(
(
"
Sending
Close
"
)
)
;
MOZ_ASSERT
(
mChild
)
;
if
(
aOptions
.
mReason
.
Length
(
)
>
1024u
)
{
mChild
-
>
SendClose
(
aOptions
.
mCloseCode
Substring
(
aOptions
.
mReason
0
RewindToPriorUTF8Codepoint
(
aOptions
.
mReason
.
get
(
)
1024u
)
)
)
;
}
else
{
mChild
-
>
SendClose
(
aOptions
.
mCloseCode
aOptions
.
mReason
)
;
LOG
(
(
"
Close
sent
"
)
)
;
}
RefPtr
<
WebTransportError
>
error
=
new
WebTransportError
(
"
close
(
)
"
_ns
WebTransportErrorSource
:
:
Session
DOMException_Binding
:
:
ABORT_ERR
)
;
Cleanup
(
error
&
aOptions
aRv
)
;
LOG
(
(
"
Cleanup
done
"
)
)
;
mChild
-
>
Shutdown
(
false
)
;
mChild
=
nullptr
;
LOG
(
(
"
Close
done
"
)
)
;
}
already_AddRefed
<
WebTransportDatagramDuplexStream
>
WebTransport
:
:
GetDatagrams
(
ErrorResult
&
aError
)
{
LOG
(
(
"
Datagrams
(
)
called
"
)
)
;
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
CreateBidirectionalStream
(
ErrorResult
&
aError
)
{
LOG
(
(
"
CreateBidirectionalStream
(
)
called
"
)
)
;
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
already_AddRefed
<
ReadableStream
>
WebTransport
:
:
IncomingBidirectionalStreams
(
)
{
return
do_AddRef
(
mIncomingBidirectionalStreams
)
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
CreateUnidirectionalStream
(
ErrorResult
&
aError
)
{
LOG
(
(
"
CreateUnidirectionalStream
(
)
called
"
)
)
;
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
already_AddRefed
<
ReadableStream
>
WebTransport
:
:
IncomingUnidirectionalStreams
(
)
{
return
do_AddRef
(
mIncomingUnidirectionalStreams
)
;
}
void
WebTransport
:
:
Cleanup
(
WebTransportError
*
aError
const
WebTransportCloseInfo
*
aCloseInfo
ErrorResult
&
aRv
)
{
LOG
(
(
"
Cleanup
started
"
)
)
;
nsTArray
<
RefPtr
<
WebTransportSendStream
>
>
sendStreams
;
sendStreams
.
SwapElements
(
mSendStreams
)
;
nsTArray
<
RefPtr
<
WebTransportReceiveStream
>
>
receiveStreams
;
receiveStreams
.
SwapElements
(
mReceiveStreams
)
;
mState
=
aCloseInfo
?
WebTransportState
:
:
CLOSED
:
WebTransportState
:
:
FAILED
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
errorValue
(
cx
)
;
bool
ok
=
ToJSValue
(
cx
aError
&
errorValue
)
;
if
(
!
ok
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
for
(
const
auto
&
stream
:
sendStreams
)
{
MOZ_KnownLive
(
stream
)
-
>
ErrorNative
(
cx
errorValue
IgnoreErrors
(
)
)
;
}
for
(
const
auto
&
stream
:
receiveStreams
)
{
stream
-
>
ErrorNative
(
cx
errorValue
IgnoreErrors
(
)
)
;
}
if
(
aCloseInfo
)
{
LOG
(
(
"
Resolving
mClosed
with
closeinfo
"
)
)
;
mClosed
-
>
MaybeResolve
(
aCloseInfo
)
;
MOZ_ASSERT
(
mReady
-
>
State
(
)
!
=
Promise
:
:
PromiseState
:
:
Pending
)
;
RefPtr
<
ReadableStream
>
stream
=
mIncomingBidirectionalStreams
;
stream
-
>
CloseNative
(
cx
IgnoreErrors
(
)
)
;
stream
=
mIncomingUnidirectionalStreams
;
stream
-
>
CloseNative
(
cx
IgnoreErrors
(
)
)
;
}
else
{
LOG
(
(
"
Rejecting
mClosed
"
)
)
;
mClosed
-
>
MaybeReject
(
errorValue
)
;
mReady
-
>
MaybeReject
(
errorValue
)
;
mIncomingBidirectionalStreams
-
>
ErrorNative
(
cx
errorValue
IgnoreErrors
(
)
)
;
mIncomingUnidirectionalStreams
-
>
ErrorNative
(
cx
errorValue
IgnoreErrors
(
)
)
;
}
mIncomingBidirectionalAlgorithm
=
nullptr
;
mIncomingUnidirectionalAlgorithm
=
nullptr
;
}
}
