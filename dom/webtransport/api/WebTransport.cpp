#
include
"
WebTransport
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PWebTransport
.
h
"
#
include
"
mozilla
/
dom
/
ReadableStream
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportLog
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
WebTransport
mGlobal
mIncomingUnidirectionalStreams
mIncomingBidirectionalStreams
mReady
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WebTransport
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WebTransport
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WebTransport
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
WebTransport
:
:
WebTransport
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
mState
(
WebTransportState
:
:
CONNECTING
)
{
LOG
(
(
"
Creating
WebTransport
%
p
"
this
)
)
;
}
nsIGlobalObject
*
WebTransport
:
:
GetParentObject
(
)
const
{
return
mGlobal
;
}
JSObject
*
WebTransport
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WebTransport_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
WebTransport
>
WebTransport
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aURL
const
WebTransportOptions
&
aOptions
ErrorResult
&
aError
)
{
LOG
(
(
"
Creating
WebTransport
for
%
s
"
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
WebTransport
>
result
=
new
WebTransport
(
global
)
;
if
(
!
result
-
>
Init
(
aGlobal
aURL
aOptions
aError
)
)
{
return
nullptr
;
}
return
result
.
forget
(
)
;
}
bool
WebTransport
:
:
Init
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aURL
const
WebTransportOptions
&
aOptions
ErrorResult
&
aError
)
{
using
mozilla
:
:
ipc
:
:
BackgroundChild
;
using
mozilla
:
:
ipc
:
:
Endpoint
;
using
mozilla
:
:
ipc
:
:
PBackgroundChild
;
mReady
=
Promise
:
:
Create
(
mGlobal
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
false
;
}
QueuingStrategy
strategy
;
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
underlying
;
mIncomingUnidirectionalStreams
=
ReadableStream
:
:
Constructor
(
aGlobal
underlying
strategy
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
mIncomingBidirectionalStreams
=
ReadableStream
:
:
Constructor
(
aGlobal
underlying
strategy
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
PBackgroundChild
*
backgroundChild
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundChild
)
)
{
return
false
;
}
Endpoint
<
PWebTransportParent
>
parentEndpoint
;
Endpoint
<
PWebTransportChild
>
childEndpoint
;
MOZ_ALWAYS_SUCCEEDS
(
PWebTransport
:
:
CreateEndpoints
(
&
parentEndpoint
&
childEndpoint
)
)
;
RefPtr
<
WebTransportChild
>
child
=
new
WebTransportChild
(
)
;
if
(
!
childEndpoint
.
Bind
(
child
)
)
{
return
false
;
}
mState
=
WebTransportState
:
:
CONNECTING
;
LOG
(
(
"
Connecting
WebTransport
to
parent
for
%
s
"
NS_ConvertUTF16toUTF8
(
aURL
)
.
get
(
)
)
)
;
backgroundChild
-
>
SendCreateWebTransportParent
(
aURL
std
:
:
move
(
parentEndpoint
)
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
RefPtr
{
this
}
child
]
(
nsresult
rv
)
{
if
(
NS_FAILED
(
rv
)
)
{
self
-
>
RejectWaitingConnection
(
rv
)
;
}
else
{
self
-
>
ResolveWaitingConnection
(
child
)
;
}
}
[
self
=
RefPtr
<
WebTransport
>
(
this
)
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
)
{
self
-
>
RejectWaitingConnection
(
NS_ERROR_FAILURE
)
;
}
)
;
return
true
;
}
void
WebTransport
:
:
ResolveWaitingConnection
(
WebTransportChild
*
aChild
)
{
LOG
(
(
"
Resolved
Connection
%
p
"
this
)
)
;
MOZ_ASSERT
(
mState
=
=
WebTransportState
:
:
CONNECTING
)
;
mChild
=
aChild
;
mState
=
WebTransportState
:
:
CONNECTED
;
mReady
-
>
MaybeResolve
(
true
)
;
}
void
WebTransport
:
:
RejectWaitingConnection
(
nsresult
aRv
)
{
LOG
(
(
"
Reject
Connection
%
p
"
this
)
)
;
MOZ_ASSERT
(
mState
=
=
WebTransportState
:
:
CONNECTING
)
;
mState
=
WebTransportState
:
:
FAILED
;
LOG
(
(
"
Rejected
connection
%
x
"
aRv
)
)
;
mReady
-
>
MaybeReject
(
aRv
)
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
GetStats
(
ErrorResult
&
aError
)
{
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
Ready
(
)
{
return
do_AddRef
(
mReady
)
;
}
WebTransportReliabilityMode
WebTransport
:
:
Reliability
(
)
{
return
WebTransportReliabilityMode
:
:
Pending
;
}
WebTransportCongestionControl
WebTransport
:
:
CongestionControl
(
)
{
return
WebTransportCongestionControl
:
:
Default
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
Closed
(
)
{
ErrorResult
error
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
error
)
;
if
(
error
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeResolve
(
mState
=
=
WebTransportState
:
:
CLOSED
)
;
return
promise
.
forget
(
)
;
}
void
WebTransport
:
:
Close
(
const
WebTransportCloseInfo
&
aOptions
)
{
LOG
(
(
"
Close
(
)
called
"
)
)
;
if
(
mState
=
=
WebTransportState
:
:
CONNECTED
|
|
mState
=
=
WebTransportState
:
:
CONNECTING
)
{
MOZ_ASSERT
(
mChild
)
;
LOG
(
(
"
Sending
Close
"
)
)
;
if
(
aOptions
.
mReason
.
Length
(
)
>
1024u
)
{
mChild
-
>
SendClose
(
aOptions
.
mCloseCode
Substring
(
aOptions
.
mReason
0
RewindToPriorUTF8Codepoint
(
aOptions
.
mReason
.
get
(
)
1024u
)
)
)
;
}
else
{
mChild
-
>
SendClose
(
aOptions
.
mCloseCode
aOptions
.
mReason
)
;
}
mState
=
WebTransportState
:
:
CLOSED
;
mChild
=
nullptr
;
}
}
already_AddRefed
<
WebTransportDatagramDuplexStream
>
WebTransport
:
:
Datagrams
(
)
{
LOG
(
(
"
Datagrams
(
)
called
"
)
)
;
return
nullptr
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
CreateBidirectionalStream
(
ErrorResult
&
aError
)
{
LOG
(
(
"
CreateBidirectionalStream
(
)
called
"
)
)
;
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
already_AddRefed
<
ReadableStream
>
WebTransport
:
:
IncomingBidirectionalStreams
(
)
{
return
do_AddRef
(
mIncomingBidirectionalStreams
)
;
}
already_AddRefed
<
Promise
>
WebTransport
:
:
CreateUnidirectionalStream
(
ErrorResult
&
aError
)
{
LOG
(
(
"
CreateUnidirectionalStream
(
)
called
"
)
)
;
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
already_AddRefed
<
ReadableStream
>
WebTransport
:
:
IncomingUnidirectionalStreams
(
)
{
return
do_AddRef
(
mIncomingUnidirectionalStreams
)
;
}
}
