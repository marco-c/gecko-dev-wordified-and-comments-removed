#
include
"
mozilla
/
dom
/
WebTransportStreams
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportLog
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
mozilla
/
dom
/
WebTransport
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportBidirectionalStream
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportReceiveStream
.
h
"
#
include
"
mozilla
/
dom
/
WebTransportSendStream
.
h
"
#
include
"
mozilla
/
Result
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
WebTransportIncomingStreamsAlgorithms
UnderlyingSourceAlgorithmsWrapper
mTransport
mCallback
)
NS_IMPL_ADDREF_INHERITED
(
WebTransportIncomingStreamsAlgorithms
UnderlyingSourceAlgorithmsWrapper
)
NS_IMPL_RELEASE_INHERITED
(
WebTransportIncomingStreamsAlgorithms
UnderlyingSourceAlgorithmsWrapper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WebTransportIncomingStreamsAlgorithms
)
NS_INTERFACE_MAP_END_INHERITING
(
UnderlyingSourceAlgorithmsWrapper
)
WebTransportIncomingStreamsAlgorithms
:
:
WebTransportIncomingStreamsAlgorithms
(
StreamType
aUnidirectional
WebTransport
*
aTransport
)
:
mUnidirectional
(
aUnidirectional
)
mTransport
(
aTransport
)
{
}
WebTransportIncomingStreamsAlgorithms
:
:
~
WebTransportIncomingStreamsAlgorithms
(
)
=
default
;
already_AddRefed
<
Promise
>
WebTransportIncomingStreamsAlgorithms
:
:
PullCallbackImpl
(
JSContext
*
aCx
ReadableStreamController
&
aController
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateInfallible
(
mTransport
-
>
GetParentObject
(
)
)
;
RefPtr
<
WebTransportIncomingStreamsAlgorithms
>
self
(
this
)
;
auto
length
=
(
mUnidirectional
=
=
StreamType
:
:
Unidirectional
)
?
mTransport
-
>
mUnidirectionalStreams
.
Length
(
)
:
mTransport
-
>
mBidirectionalStreams
.
Length
(
)
;
if
(
length
=
=
0
)
{
MOZ_ASSERT
(
!
mCallback
)
;
mCallback
=
promise
;
LOG
(
(
"
Incoming
%
sDirectionalStreams
Pull
waiting
for
a
stream
"
mUnidirectional
=
=
StreamType
:
:
Unidirectional
?
"
Uni
"
:
"
Bi
"
)
)
;
Result
<
RefPtr
<
Promise
>
nsresult
>
returnResult
=
promise
-
>
ThenWithCycleCollectedArgs
(
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
aRv
RefPtr
<
WebTransportIncomingStreamsAlgorithms
>
self
RefPtr
<
Promise
>
aPromise
)
-
>
already_AddRefed
<
Promise
>
{
self
-
>
BuildStream
(
aCx
aRv
)
;
return
nullptr
;
}
self
promise
)
;
if
(
returnResult
.
isErr
(
)
)
{
aRv
.
Throw
(
returnResult
.
unwrapErr
(
)
)
;
return
nullptr
;
}
return
returnResult
.
unwrap
(
)
.
forget
(
)
;
}
self
-
>
BuildStream
(
aCx
aRv
)
;
return
promise
.
forget
(
)
;
}
void
WebTransportIncomingStreamsAlgorithms
:
:
BuildStream
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
LOG
(
(
"
Incoming
%
sDirectionalStreams
Pull
building
a
stream
"
mUnidirectional
=
=
StreamType
:
:
Unidirectional
?
"
Uni
"
:
"
Bi
"
)
)
;
if
(
mUnidirectional
=
=
StreamType
:
:
Unidirectional
)
{
MOZ_ASSERT
(
mTransport
-
>
mUnidirectionalStreams
.
Length
(
)
>
0
)
;
std
:
:
tuple
<
uint64_t
RefPtr
<
mozilla
:
:
ipc
:
:
DataPipeReceiver
>
>
tuple
=
mTransport
-
>
mUnidirectionalStreams
[
0
]
;
mTransport
-
>
mUnidirectionalStreams
.
RemoveElementAt
(
0
)
;
RefPtr
<
WebTransportReceiveStream
>
readableStream
=
WebTransportReceiveStream
:
:
Create
(
mTransport
mTransport
-
>
mGlobal
std
:
:
get
<
0
>
(
tuple
)
std
:
:
get
<
1
>
(
tuple
)
aRv
)
;
if
(
MOZ_UNLIKELY
(
!
readableStream
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
jsStream
(
aCx
)
;
if
(
MOZ_UNLIKELY
(
!
ToJSValue
(
aCx
readableStream
&
jsStream
)
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
RefPtr
<
ReadableStream
>
incomingStream
=
mTransport
-
>
mIncomingUnidirectionalStreams
;
incomingStream
-
>
EnqueueNative
(
aCx
jsStream
aRv
)
;
if
(
MOZ_UNLIKELY
(
aRv
.
Failed
(
)
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
}
else
{
MOZ_ASSERT
(
mTransport
-
>
mBidirectionalStreams
.
Length
(
)
>
0
)
;
std
:
:
tuple
<
uint64_t
UniquePtr
<
BidirectionalPair
>
>
tuple
=
std
:
:
move
(
mTransport
-
>
mBidirectionalStreams
.
ElementAt
(
0
)
)
;
mTransport
-
>
mBidirectionalStreams
.
RemoveElementAt
(
0
)
;
RefPtr
<
DataPipeReceiver
>
input
=
std
:
:
get
<
1
>
(
tuple
)
-
>
first
.
forget
(
)
;
RefPtr
<
DataPipeSender
>
output
=
std
:
:
get
<
1
>
(
tuple
)
-
>
second
.
forget
(
)
;
RefPtr
<
WebTransportBidirectionalStream
>
stream
=
WebTransportBidirectionalStream
:
:
Create
(
mTransport
mTransport
-
>
mGlobal
std
:
:
get
<
0
>
(
tuple
)
input
output
aRv
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
jsStream
(
aCx
)
;
if
(
MOZ_UNLIKELY
(
!
ToJSValue
(
aCx
stream
&
jsStream
)
)
)
{
return
;
}
LOG
(
(
"
Enqueuing
bidirectional
stream
\
n
"
)
)
;
RefPtr
<
ReadableStream
>
incomingStream
=
mTransport
-
>
mIncomingBidirectionalStreams
;
incomingStream
-
>
EnqueueNative
(
aCx
jsStream
aRv
)
;
if
(
MOZ_UNLIKELY
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
}
void
WebTransportIncomingStreamsAlgorithms
:
:
NotifyIncomingStream
(
)
{
if
(
mUnidirectional
=
=
StreamType
:
:
Unidirectional
)
{
LOG
(
(
"
NotifyIncomingStream
:
%
zu
Unidirectional
"
mTransport
-
>
mUnidirectionalStreams
.
Length
(
)
)
)
;
#
ifdef
DEBUG
auto
number
=
mTransport
-
>
mUnidirectionalStreams
.
Length
(
)
;
MOZ_ASSERT
(
number
>
0
)
;
#
endif
RefPtr
<
Promise
>
promise
=
mCallback
.
forget
(
)
;
if
(
promise
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
}
else
{
LOG
(
(
"
NotifyIncomingStream
:
%
zu
Bidirectional
"
mTransport
-
>
mBidirectionalStreams
.
Length
(
)
)
)
;
#
ifdef
DEBUG
auto
number
=
mTransport
-
>
mBidirectionalStreams
.
Length
(
)
;
MOZ_ASSERT
(
number
>
0
)
;
#
endif
RefPtr
<
Promise
>
promise
=
mCallback
.
forget
(
)
;
if
(
promise
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
}
}
void
WebTransportIncomingStreamsAlgorithms
:
:
NotifyRejectAll
(
)
{
LOG
(
(
"
Cancel
all
WebTransport
Pulls
"
)
)
;
if
(
RefPtr
<
Promise
>
promise
=
mCallback
.
forget
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
}
}
