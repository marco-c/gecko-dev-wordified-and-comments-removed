#
ifndef
mozilla_dom_Lock_h
#
define
mozilla_dom_Lock_h
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
LockManagerBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
namespace
mozilla
:
:
dom
{
class
LockManager
;
class
Lock
final
:
public
PromiseNativeHandler
public
nsWrapperCache
{
friend
class
LockManager
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
Lock
)
Lock
(
nsIGlobalObject
*
aGlobal
const
RefPtr
<
LockManager
>
&
aLockManager
const
nsString
&
aName
LockMode
aMode
const
RefPtr
<
Promise
>
&
aReleasedPromise
ErrorResult
&
aRv
)
;
bool
operator
=
=
(
const
Lock
&
aOther
)
const
{
MOZ_ASSERT
(
mReleasedPromise
&
&
aOther
.
mReleasedPromise
"
Promises
are
null
when
locks
are
unreleased
?
?
"
)
;
return
mReleasedPromise
=
=
aOther
.
mReleasedPromise
;
}
protected
:
~
Lock
(
)
=
default
;
public
:
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mOwner
;
}
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
GetName
(
nsString
&
aRetVal
)
const
;
LockMode
Mode
(
)
const
;
Promise
&
GetWaitingPromise
(
)
;
virtual
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
;
virtual
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
;
private
:
nsCOMPtr
<
nsIGlobalObject
>
mOwner
;
RefPtr
<
LockManager
>
mLockManager
;
nsString
mName
;
LockMode
mMode
;
RefPtr
<
Promise
>
mWaitingPromise
;
RefPtr
<
Promise
>
mReleasedPromise
;
}
;
}
#
endif
