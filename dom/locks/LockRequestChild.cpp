#
include
"
LockManagerChild
.
h
"
#
include
"
LockRequestChild
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
namespace
mozilla
:
:
dom
:
:
locks
{
using
IPCResult
=
mozilla
:
:
ipc
:
:
IPCResult
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
void
RunCallbackAndSettlePromise
(
LockGrantedCallback
&
aCallback
mozilla
:
:
dom
:
:
Lock
*
lock
Promise
&
aPromise
)
{
ErrorResult
rv
;
if
(
RefPtr
<
Promise
>
result
=
aCallback
.
Call
(
lock
rv
nullptr
CallbackObject
:
:
eRethrowExceptions
)
)
{
aPromise
.
MaybeResolve
(
result
)
;
}
else
if
(
rv
.
Failed
(
)
&
&
!
rv
.
IsUncatchableException
(
)
)
{
aPromise
.
MaybeReject
(
std
:
:
move
(
rv
)
)
;
return
;
}
else
{
aPromise
.
MaybeResolveWithUndefined
(
)
;
}
rv
.
WouldReportJSException
(
)
;
if
(
NS_WARN_IF
(
rv
.
IsUncatchableException
(
)
)
)
{
rv
.
SuppressException
(
)
;
}
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
}
IPCResult
LockRequestChild
:
:
RecvResolve
(
const
LockMode
&
aLockMode
bool
aIsAvailable
)
{
RefPtr
<
Lock
>
lock
;
RefPtr
<
Promise
>
promise
;
if
(
aIsAvailable
)
{
IgnoredErrorResult
err
;
lock
=
new
Lock
(
static_cast
<
LockManagerChild
*
>
(
Manager
(
)
)
-
>
GetParentObject
(
)
this
mRequest
.
mName
aLockMode
mRequest
.
mPromise
err
)
;
if
(
MOZ_UNLIKELY
(
err
.
Failed
(
)
)
)
{
mRequest
.
mPromise
-
>
MaybeRejectWithUnknownError
(
"
Failed
to
allocate
a
lock
"
)
;
return
IPC_OK
(
)
;
}
lock
-
>
GetWaitingPromise
(
)
.
AppendNativeHandler
(
lock
)
;
promise
=
&
lock
-
>
GetWaitingPromise
(
)
;
}
else
{
promise
=
mRequest
.
mPromise
;
}
RunCallbackAndSettlePromise
(
*
mRequest
.
mCallback
lock
*
promise
)
;
return
IPC_OK
(
)
;
}
IPCResult
LockRequestChild
:
:
RecvAbort
(
)
{
mRequest
.
mPromise
-
>
MaybeRejectWithAbortError
(
"
The
lock
request
is
aborted
"
)
;
return
IPC_OK
(
)
;
}
}
