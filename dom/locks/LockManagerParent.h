#
ifndef
DOM_LOCKS_LOCKMANAGERPARENT_H_
#
define
DOM_LOCKS_LOCKMANAGERPARENT_H_
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
dom
/
locks
/
PLockManagerParent
.
h
"
#
include
"
mozilla
/
dom
/
locks
/
LockRequestParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
namespace
mozilla
:
:
dom
:
:
locks
{
class
ManagedLocks
:
public
SupportsWeakPtr
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ManagedLocks
)
nsTArray
<
RefPtr
<
LockRequestParent
>
>
mHeldLocks
;
nsTHashMap
<
nsStringHashKey
nsTArray
<
RefPtr
<
LockRequestParent
>
>
>
mQueueMap
;
private
:
~
ManagedLocks
(
)
=
default
;
}
;
class
LockManagerParent
final
:
public
PLockManagerParent
{
using
IPCResult
=
mozilla
:
:
ipc
:
:
IPCResult
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
LockManagerParent
)
LockManagerParent
(
const
mozilla
:
:
ipc
:
:
ContentPrincipalInfo
&
aPrincipalInfo
const
nsID
&
aClientId
)
;
void
ProcessRequestQueue
(
nsTArray
<
RefPtr
<
LockRequestParent
>
>
&
aQueue
)
;
bool
IsGrantableRequest
(
const
IPCLockRequest
&
aRequest
)
;
IPCResult
RecvQuery
(
QueryResolver
&
&
aResolver
)
;
already_AddRefed
<
PLockRequestParent
>
AllocPLockRequestParent
(
const
IPCLockRequest
&
aRequest
)
;
IPCResult
RecvPLockRequestConstructor
(
PLockRequestParent
*
aActor
const
IPCLockRequest
&
aRequest
)
final
;
ManagedLocks
&
Locks
(
)
{
return
*
mManagedLocks
;
}
private
:
~
LockManagerParent
(
)
=
default
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
final
;
RefPtr
<
ManagedLocks
>
mManagedLocks
;
nsString
mClientId
;
mozilla
:
:
ipc
:
:
ContentPrincipalInfo
mPrincipalInfo
;
}
;
}
#
endif
