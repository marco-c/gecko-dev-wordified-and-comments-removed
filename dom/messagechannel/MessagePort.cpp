#
include
"
MessagePort
.
h
"
#
include
"
MessageEvent
.
h
"
#
include
"
MessagePortChild
.
h
"
#
include
"
mozilla
/
dom
/
BlobBinding
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
MessageChannel
.
h
"
#
include
"
mozilla
/
dom
/
MessageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortChild
.
h
"
#
include
"
mozilla
/
dom
/
PMessagePort
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneTags
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerScope
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
MessagePortTimelineMarker
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
TimelineMarker
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
SharedMessagePortMessage
.
h
"
#
include
"
nsIBFCacheEntry
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMFileList
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
ifdef
XP_WIN
#
undef
PostMessage
#
endif
using
namespace
mozilla
:
:
dom
:
:
workers
;
namespace
mozilla
{
namespace
dom
{
class
PostMessageRunnable
final
:
public
CancelableRunnable
{
friend
class
MessagePort
;
public
:
PostMessageRunnable
(
MessagePort
*
aPort
SharedMessagePortMessage
*
aData
)
:
CancelableRunnable
(
"
dom
:
:
PostMessageRunnable
"
)
mPort
(
aPort
)
mData
(
aData
)
{
MOZ_ASSERT
(
aPort
)
;
MOZ_ASSERT
(
aData
)
;
}
NS_IMETHOD
Run
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
Runnable
)
;
if
(
!
mPort
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mPort
-
>
mPostMessageRunnable
=
=
this
)
;
nsresult
rv
=
DispatchMessage
(
)
;
mPort
-
>
UpdateMustKeepAlive
(
)
;
mPort
-
>
mPostMessageRunnable
=
nullptr
;
mPort
-
>
Dispatch
(
)
;
return
rv
;
}
nsresult
Cancel
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
Runnable
)
;
mPort
=
nullptr
;
mData
=
nullptr
;
return
NS_OK
;
}
private
:
nsresult
DispatchMessage
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
Runnable
)
;
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
mPort
-
>
GetParentObject
(
)
;
AutoJSAPI
jsapi
;
if
(
!
globalObject
|
|
!
jsapi
.
Init
(
globalObject
)
)
{
NS_WARNING
(
"
Failed
to
initialize
AutoJSAPI
object
.
"
)
;
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
rv
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
UniquePtr
<
AbstractTimelineMarker
>
start
;
UniquePtr
<
AbstractTimelineMarker
>
end
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
!
timelines
-
>
IsEmpty
(
)
;
if
(
isTimelineRecording
)
{
start
=
MakeUnique
<
MessagePortTimelineMarker
>
(
ProfileTimelineMessagePortOperationType
:
:
DeserializeData
MarkerTracingType
:
:
START
)
;
}
mData
-
>
Read
(
cx
&
value
rv
)
;
if
(
isTimelineRecording
)
{
end
=
MakeUnique
<
MessagePortTimelineMarker
>
(
ProfileTimelineMessagePortOperationType
:
:
DeserializeData
MarkerTracingType
:
:
END
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
start
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
end
)
;
}
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
mPort
-
>
DispatchError
(
)
;
return
rv
.
StealNSResult
(
)
;
}
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
eventTarget
=
do_QueryInterface
(
mPort
-
>
GetOwner
(
)
)
;
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
eventTarget
nullptr
nullptr
)
;
Sequence
<
OwningNonNull
<
MessagePort
>
>
ports
;
if
(
!
mData
-
>
TakeTransferredPortsAsSequence
(
ports
)
)
{
mPort
-
>
DispatchError
(
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
event
-
>
InitMessageEvent
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
false
false
value
EmptyString
(
)
EmptyString
(
)
nullptr
ports
)
;
event
-
>
SetTrusted
(
true
)
;
bool
dummy
;
mPort
-
>
DispatchEvent
(
static_cast
<
dom
:
:
Event
*
>
(
event
.
get
(
)
)
&
dummy
)
;
return
NS_OK
;
}
private
:
~
PostMessageRunnable
(
)
{
}
RefPtr
<
MessagePort
>
mPort
;
RefPtr
<
SharedMessagePortMessage
>
mData
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
MessagePort
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
MessagePort
DOMEventTargetHelper
)
if
(
tmp
-
>
mPostMessageRunnable
)
{
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPostMessageRunnable
-
>
mPort
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMessages
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMessagesForTheOtherPort
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mUnshippedEntangledPort
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
MessagePort
DOMEventTargetHelper
)
if
(
tmp
-
>
mPostMessageRunnable
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPostMessageRunnable
-
>
mPort
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mUnshippedEntangledPort
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MessagePort
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
MessagePort
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
MessagePort
DOMEventTargetHelper
)
namespace
{
class
MessagePortWorkerHolder
final
:
public
workers
:
:
WorkerHolder
{
MessagePort
*
mPort
;
public
:
explicit
MessagePortWorkerHolder
(
MessagePort
*
aPort
)
:
mPort
(
aPort
)
{
MOZ_ASSERT
(
aPort
)
;
MOZ_COUNT_CTOR
(
MessagePortWorkerHolder
)
;
}
virtual
bool
Notify
(
workers
:
:
Status
aStatus
)
override
{
if
(
aStatus
>
Running
)
{
mPort
-
>
CloseForced
(
)
;
}
return
true
;
}
private
:
~
MessagePortWorkerHolder
(
)
{
MOZ_COUNT_DTOR
(
MessagePortWorkerHolder
)
;
}
}
;
}
MessagePort
:
:
MessagePort
(
nsIGlobalObject
*
aGlobal
)
:
DOMEventTargetHelper
(
aGlobal
)
mInnerID
(
0
)
mMessageQueueEnabled
(
false
)
mIsKeptAlive
(
false
)
{
MOZ_ASSERT
(
aGlobal
)
;
mIdentifier
=
new
MessagePortIdentifier
(
)
;
mIdentifier
-
>
neutered
(
)
=
true
;
mIdentifier
-
>
sequenceId
(
)
=
0
;
}
MessagePort
:
:
~
MessagePort
(
)
{
CloseForced
(
)
;
MOZ_ASSERT
(
!
mWorkerHolder
)
;
}
already_AddRefed
<
MessagePort
>
MessagePort
:
:
Create
(
nsIGlobalObject
*
aGlobal
const
nsID
&
aUUID
const
nsID
&
aDestinationUUID
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aGlobal
)
;
RefPtr
<
MessagePort
>
mp
=
new
MessagePort
(
aGlobal
)
;
mp
-
>
Initialize
(
aUUID
aDestinationUUID
1
false
eStateUnshippedEntangled
aRv
)
;
return
mp
.
forget
(
)
;
}
already_AddRefed
<
MessagePort
>
MessagePort
:
:
Create
(
nsIGlobalObject
*
aGlobal
const
MessagePortIdentifier
&
aIdentifier
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aGlobal
)
;
RefPtr
<
MessagePort
>
mp
=
new
MessagePort
(
aGlobal
)
;
mp
-
>
Initialize
(
aIdentifier
.
uuid
(
)
aIdentifier
.
destinationUuid
(
)
aIdentifier
.
sequenceId
(
)
aIdentifier
.
neutered
(
)
eStateEntangling
aRv
)
;
return
mp
.
forget
(
)
;
}
void
MessagePort
:
:
UnshippedEntangle
(
MessagePort
*
aEntangledPort
)
{
MOZ_ASSERT
(
aEntangledPort
)
;
MOZ_ASSERT
(
!
mUnshippedEntangledPort
)
;
mUnshippedEntangledPort
=
aEntangledPort
;
}
void
MessagePort
:
:
Initialize
(
const
nsID
&
aUUID
const
nsID
&
aDestinationUUID
uint32_t
aSequenceID
bool
mNeutered
State
aState
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mIdentifier
)
;
mIdentifier
-
>
uuid
(
)
=
aUUID
;
mIdentifier
-
>
destinationUuid
(
)
=
aDestinationUUID
;
mIdentifier
-
>
sequenceId
(
)
=
aSequenceID
;
mState
=
aState
;
if
(
mNeutered
)
{
mState
=
eStateDisentangled
;
return
;
}
if
(
mState
=
=
eStateEntangling
)
{
ConnectToPBackground
(
)
;
}
else
{
MOZ_ASSERT
(
mState
=
=
eStateUnshippedEntangled
)
;
}
UpdateMustKeepAlive
(
)
;
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
MOZ_ASSERT
(
!
mWorkerHolder
)
;
nsAutoPtr
<
WorkerHolder
>
workerHolder
(
new
MessagePortWorkerHolder
(
this
)
)
;
if
(
NS_WARN_IF
(
!
workerHolder
-
>
HoldWorker
(
workerPrivate
Closing
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
mWorkerHolder
=
Move
(
workerHolder
)
;
}
else
if
(
GetOwner
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
GetOwner
(
)
-
>
IsInnerWindow
(
)
)
;
mInnerID
=
GetOwner
(
)
-
>
WindowID
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
}
}
}
JSObject
*
MessagePort
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MessagePortBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
MessagePort
:
:
PostMessage
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
{
for
(
uint32_t
i
=
0
;
i
<
aTransferable
.
Length
(
)
;
+
+
i
)
{
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
aTransferable
[
i
]
)
;
if
(
!
object
)
{
continue
;
}
MessagePort
*
port
=
nullptr
;
nsresult
rv
=
UNWRAP_OBJECT
(
MessagePort
&
object
port
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
port
=
=
this
)
{
aRv
.
Throw
(
NS_ERROR_DOM_DATA_CLONE_ERR
)
;
return
;
}
}
JS
:
:
Rooted
<
JS
:
:
Value
>
transferable
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
aRv
=
nsContentUtils
:
:
CreateJSValueFromSequenceOfObject
(
aCx
aTransferable
&
transferable
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
RefPtr
<
SharedMessagePortMessage
>
data
=
new
SharedMessagePortMessage
(
)
;
UniquePtr
<
AbstractTimelineMarker
>
start
;
UniquePtr
<
AbstractTimelineMarker
>
end
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
!
timelines
-
>
IsEmpty
(
)
;
if
(
isTimelineRecording
)
{
start
=
MakeUnique
<
MessagePortTimelineMarker
>
(
ProfileTimelineMessagePortOperationType
:
:
SerializeData
MarkerTracingType
:
:
START
)
;
}
data
-
>
Write
(
aCx
aMessage
transferable
aRv
)
;
if
(
isTimelineRecording
)
{
end
=
MakeUnique
<
MessagePortTimelineMarker
>
(
ProfileTimelineMessagePortOperationType
:
:
SerializeData
MarkerTracingType
:
:
END
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
start
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
end
)
;
}
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
mState
>
eStateEntangled
)
{
return
;
}
if
(
mState
=
=
eStateUnshippedEntangled
)
{
MOZ_ASSERT
(
mUnshippedEntangledPort
)
;
mUnshippedEntangledPort
-
>
mMessages
.
AppendElement
(
data
)
;
mUnshippedEntangledPort
-
>
Dispatch
(
)
;
return
;
}
if
(
mState
=
=
eStateEntanglingForDisentangle
|
|
mState
=
=
eStateEntanglingForClose
)
{
return
;
}
RemoveDocFromBFCache
(
)
;
if
(
mState
=
=
eStateEntangling
)
{
mMessagesForTheOtherPort
.
AppendElement
(
data
)
;
return
;
}
MOZ_ASSERT
(
mActor
)
;
MOZ_ASSERT
(
mMessagesForTheOtherPort
.
IsEmpty
(
)
)
;
AutoTArray
<
RefPtr
<
SharedMessagePortMessage
>
1
>
array
;
array
.
AppendElement
(
data
)
;
AutoTArray
<
ClonedMessageData
1
>
messages
;
SharedMessagePortMessage
:
:
FromSharedToMessagesChild
(
mActor
array
messages
)
;
mActor
-
>
SendPostMessages
(
messages
)
;
}
void
MessagePort
:
:
Start
(
)
{
if
(
mMessageQueueEnabled
)
{
return
;
}
mMessageQueueEnabled
=
true
;
Dispatch
(
)
;
}
void
MessagePort
:
:
Dispatch
(
)
{
if
(
!
mMessageQueueEnabled
|
|
mMessages
.
IsEmpty
(
)
|
|
mPostMessageRunnable
)
{
return
;
}
switch
(
mState
)
{
case
eStateUnshippedEntangled
:
break
;
case
eStateEntangling
:
break
;
case
eStateEntanglingForDisentangle
:
return
;
case
eStateEntanglingForClose
:
break
;
case
eStateEntangled
:
break
;
case
eStateDisentangling
:
return
;
case
eStateDisentangled
:
MOZ_CRASH
(
"
This
cannot
happen
.
"
)
;
break
;
case
eStateDisentangledForClose
:
break
;
}
RefPtr
<
SharedMessagePortMessage
>
data
=
mMessages
.
ElementAt
(
0
)
;
mMessages
.
RemoveElementAt
(
0
)
;
mPostMessageRunnable
=
new
PostMessageRunnable
(
this
data
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetOwnerGlobal
(
)
;
if
(
NS_IsMainThread
(
)
&
&
global
)
{
MOZ_ALWAYS_SUCCEEDS
(
global
-
>
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
mPostMessageRunnable
)
)
)
;
return
;
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
mPostMessageRunnable
)
)
;
}
void
MessagePort
:
:
Close
(
)
{
CloseInternal
(
true
)
;
}
void
MessagePort
:
:
CloseForced
(
)
{
CloseInternal
(
false
)
;
}
void
MessagePort
:
:
CloseInternal
(
bool
aSoftly
)
{
if
(
!
aSoftly
)
{
mMessages
.
Clear
(
)
;
}
if
(
mState
=
=
eStateUnshippedEntangled
)
{
MOZ_ASSERT
(
mUnshippedEntangledPort
)
;
RefPtr
<
MessagePort
>
port
=
Move
(
mUnshippedEntangledPort
)
;
MOZ_ASSERT
(
mUnshippedEntangledPort
=
=
nullptr
)
;
mState
=
eStateDisentangledForClose
;
port
-
>
CloseInternal
(
aSoftly
)
;
UpdateMustKeepAlive
(
)
;
return
;
}
if
(
mState
=
=
eStateEntangling
)
{
mState
=
eStateEntanglingForClose
;
return
;
}
if
(
mState
=
=
eStateEntanglingForDisentangle
|
|
mState
=
=
eStateEntanglingForClose
)
{
return
;
}
if
(
mState
=
=
eStateDisentangledForClose
&
&
!
aSoftly
)
{
UpdateMustKeepAlive
(
)
;
return
;
}
if
(
mState
>
eStateEntangled
)
{
return
;
}
mState
=
eStateDisentangledForClose
;
MOZ_ASSERT
(
mActor
)
;
mActor
-
>
SendClose
(
)
;
mActor
-
>
SetPort
(
nullptr
)
;
mActor
=
nullptr
;
UpdateMustKeepAlive
(
)
;
}
EventHandlerNonNull
*
MessagePort
:
:
GetOnmessage
(
)
{
if
(
NS_IsMainThread
(
)
)
{
return
GetEventHandler
(
nsGkAtoms
:
:
onmessage
EmptyString
(
)
)
;
}
return
GetEventHandler
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
)
;
}
void
MessagePort
:
:
SetOnmessage
(
EventHandlerNonNull
*
aCallback
)
{
if
(
NS_IsMainThread
(
)
)
{
SetEventHandler
(
nsGkAtoms
:
:
onmessage
EmptyString
(
)
aCallback
)
;
}
else
{
SetEventHandler
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
aCallback
)
;
}
Start
(
)
;
}
void
MessagePort
:
:
Entangled
(
nsTArray
<
ClonedMessageData
>
&
aMessages
)
{
MOZ_ASSERT
(
mState
=
=
eStateEntangling
|
|
mState
=
=
eStateEntanglingForDisentangle
|
|
mState
=
=
eStateEntanglingForClose
)
;
State
oldState
=
mState
;
mState
=
eStateEntangled
;
if
(
!
mMessagesForTheOtherPort
.
IsEmpty
(
)
)
{
{
nsTArray
<
ClonedMessageData
>
messages
;
SharedMessagePortMessage
:
:
FromSharedToMessagesChild
(
mActor
mMessagesForTheOtherPort
messages
)
;
mActor
-
>
SendPostMessages
(
messages
)
;
}
mMessagesForTheOtherPort
.
Clear
(
)
;
}
FallibleTArray
<
RefPtr
<
SharedMessagePortMessage
>
>
data
;
if
(
NS_WARN_IF
(
!
SharedMessagePortMessage
:
:
FromMessagesToSharedChild
(
aMessages
data
)
)
)
{
DispatchError
(
)
;
return
;
}
if
(
oldState
=
=
eStateEntanglingForClose
)
{
CloseForced
(
)
;
return
;
}
mMessages
.
AppendElements
(
data
)
;
if
(
oldState
=
=
eStateEntanglingForDisentangle
)
{
StartDisentangling
(
)
;
return
;
}
Dispatch
(
)
;
}
void
MessagePort
:
:
StartDisentangling
(
)
{
MOZ_ASSERT
(
mActor
)
;
MOZ_ASSERT
(
mState
=
=
eStateEntangled
)
;
mState
=
eStateDisentangling
;
mActor
-
>
SendStopSendingData
(
)
;
}
void
MessagePort
:
:
MessagesReceived
(
nsTArray
<
ClonedMessageData
>
&
aMessages
)
{
MOZ_ASSERT
(
mState
=
=
eStateEntangled
|
|
mState
=
=
eStateDisentangling
|
|
mState
=
=
eStateDisentangledForClose
)
;
MOZ_ASSERT
(
mMessagesForTheOtherPort
.
IsEmpty
(
)
)
;
RemoveDocFromBFCache
(
)
;
FallibleTArray
<
RefPtr
<
SharedMessagePortMessage
>
>
data
;
if
(
NS_WARN_IF
(
!
SharedMessagePortMessage
:
:
FromMessagesToSharedChild
(
aMessages
data
)
)
)
{
DispatchError
(
)
;
return
;
}
mMessages
.
AppendElements
(
data
)
;
if
(
mState
=
=
eStateEntangled
)
{
Dispatch
(
)
;
}
}
void
MessagePort
:
:
StopSendingDataConfirmed
(
)
{
MOZ_ASSERT
(
mState
=
=
eStateDisentangling
)
;
MOZ_ASSERT
(
mActor
)
;
Disentangle
(
)
;
}
void
MessagePort
:
:
Disentangle
(
)
{
MOZ_ASSERT
(
mState
=
=
eStateDisentangling
)
;
MOZ_ASSERT
(
mActor
)
;
mState
=
eStateDisentangled
;
{
nsTArray
<
ClonedMessageData
>
messages
;
SharedMessagePortMessage
:
:
FromSharedToMessagesChild
(
mActor
mMessages
messages
)
;
mActor
-
>
SendDisentangle
(
messages
)
;
}
mMessages
.
Clear
(
)
;
mActor
-
>
SetPort
(
nullptr
)
;
mActor
=
nullptr
;
UpdateMustKeepAlive
(
)
;
}
void
MessagePort
:
:
CloneAndDisentangle
(
MessagePortIdentifier
&
aIdentifier
)
{
MOZ_ASSERT
(
mIdentifier
)
;
aIdentifier
.
neutered
(
)
=
true
;
if
(
mState
>
eStateEntangled
)
{
return
;
}
if
(
mState
=
=
eStateEntanglingForDisentangle
|
|
mState
=
=
eStateEntanglingForClose
)
{
return
;
}
aIdentifier
.
uuid
(
)
=
mIdentifier
-
>
uuid
(
)
;
aIdentifier
.
destinationUuid
(
)
=
mIdentifier
-
>
destinationUuid
(
)
;
aIdentifier
.
sequenceId
(
)
=
mIdentifier
-
>
sequenceId
(
)
+
1
;
aIdentifier
.
neutered
(
)
=
false
;
if
(
mState
=
=
eStateUnshippedEntangled
)
{
MOZ_ASSERT
(
mUnshippedEntangledPort
)
;
MOZ_ASSERT
(
mMessagesForTheOtherPort
.
IsEmpty
(
)
)
;
mUnshippedEntangledPort
-
>
ConnectToPBackground
(
)
;
mUnshippedEntangledPort
=
nullptr
;
if
(
mMessages
.
IsEmpty
(
)
)
{
aIdentifier
.
sequenceId
(
)
=
mIdentifier
-
>
sequenceId
(
)
;
mState
=
eStateDisentangled
;
UpdateMustKeepAlive
(
)
;
return
;
}
ConnectToPBackground
(
)
;
mState
=
eStateEntanglingForDisentangle
;
return
;
}
if
(
mState
=
=
eStateEntangling
)
{
mState
=
eStateEntanglingForDisentangle
;
return
;
}
MOZ_ASSERT
(
mState
=
=
eStateEntangled
)
;
StartDisentangling
(
)
;
}
void
MessagePort
:
:
Closed
(
)
{
if
(
mState
>
=
eStateDisentangled
)
{
return
;
}
mState
=
eStateDisentangledForClose
;
if
(
mActor
)
{
mActor
-
>
SetPort
(
nullptr
)
;
mActor
=
nullptr
;
}
UpdateMustKeepAlive
(
)
;
}
void
MessagePort
:
:
ConnectToPBackground
(
)
{
mState
=
eStateEntangling
;
mozilla
:
:
ipc
:
:
PBackgroundChild
*
actorChild
=
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actorChild
)
)
{
MOZ_CRASH
(
"
Failed
to
create
a
PBackgroundChild
actor
!
"
)
;
}
PMessagePortChild
*
actor
=
actorChild
-
>
SendPMessagePortConstructor
(
mIdentifier
-
>
uuid
(
)
mIdentifier
-
>
destinationUuid
(
)
mIdentifier
-
>
sequenceId
(
)
)
;
mActor
=
static_cast
<
MessagePortChild
*
>
(
actor
)
;
MOZ_ASSERT
(
mActor
)
;
mActor
-
>
SetPort
(
this
)
;
}
void
MessagePort
:
:
UpdateMustKeepAlive
(
)
{
if
(
mState
>
=
eStateDisentangled
&
&
mMessages
.
IsEmpty
(
)
&
&
mIsKeptAlive
)
{
mIsKeptAlive
=
false
;
mWorkerHolder
=
nullptr
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
}
}
Release
(
)
;
return
;
}
if
(
mState
<
eStateDisentangled
&
&
!
mIsKeptAlive
)
{
mIsKeptAlive
=
true
;
AddRef
(
)
;
}
}
NS_IMETHODIMP
MessagePort
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
strcmp
(
aTopic
"
inner
-
window
-
destroyed
"
)
)
{
return
NS_OK
;
}
if
(
!
mIsKeptAlive
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISupportsPRUint64
>
wrapper
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE
(
wrapper
NS_ERROR_FAILURE
)
;
uint64_t
innerID
;
nsresult
rv
=
wrapper
-
>
GetData
(
&
innerID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
innerID
=
=
mInnerID
)
{
CloseForced
(
)
;
}
return
NS_OK
;
}
void
MessagePort
:
:
RemoveDocFromBFCache
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
if
(
!
window
)
{
return
;
}
nsIDocument
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
;
}
nsCOMPtr
<
nsIBFCacheEntry
>
bfCacheEntry
=
doc
-
>
GetBFCacheEntry
(
)
;
if
(
!
bfCacheEntry
)
{
return
;
}
bfCacheEntry
-
>
RemoveFromBFCacheSync
(
)
;
}
void
MessagePort
:
:
ForceClose
(
const
MessagePortIdentifier
&
aIdentifier
)
{
mozilla
:
:
ipc
:
:
PBackgroundChild
*
actorChild
=
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actorChild
)
)
{
MOZ_CRASH
(
"
Failed
to
create
a
PBackgroundChild
actor
!
"
)
;
}
Unused
<
<
actorChild
-
>
SendMessagePortForceClose
(
aIdentifier
.
uuid
(
)
aIdentifier
.
destinationUuid
(
)
aIdentifier
.
sequenceId
(
)
)
;
}
void
MessagePort
:
:
DispatchError
(
)
{
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
GetParentObject
(
)
;
AutoJSAPI
jsapi
;
if
(
!
globalObject
|
|
!
jsapi
.
Init
(
globalObject
)
)
{
NS_WARNING
(
"
Failed
to
initialize
AutoJSAPI
object
.
"
)
;
return
;
}
RootedDictionary
<
MessageEventInit
>
init
(
jsapi
.
cx
(
)
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
Event
>
event
=
MessageEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
messageerror
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
dummy
;
DispatchEvent
(
event
&
dummy
)
;
}
}
}
