#
include
"
NavigationPrecommitController
.
h
"
#
include
"
Navigation
.
h
"
#
include
"
NavigationUtils
.
h
"
#
include
"
mozilla
/
dom
/
NavigateEvent
.
h
"
#
include
"
mozilla
/
dom
/
NavigationPrecommitControllerBinding
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
NavigationPrecommitController
mGlobalObject
mEvent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
NavigationPrecommitController
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
NavigationPrecommitController
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
NavigationPrecommitController
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NavigationPrecommitController
:
:
NavigationPrecommitController
(
NavigateEvent
*
aEvent
nsIGlobalObject
*
aGlobalObject
)
:
mGlobalObject
(
aGlobalObject
)
mEvent
(
aEvent
)
{
}
NavigationPrecommitController
:
:
~
NavigationPrecommitController
(
)
{
}
JSObject
*
NavigationPrecommitController
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
NavigationPrecommitController_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsIGlobalObject
*
NavigationPrecommitController
:
:
GetParentObject
(
)
const
{
return
mGlobalObject
;
}
void
NavigationPrecommitController
:
:
Redirect
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
NavigationNavigateOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mEvent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mEvent
-
>
InterceptionState
(
)
!
=
NavigateEvent
:
:
InterceptionState
:
:
None
)
;
mEvent
-
>
PerformSharedChecks
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
mEvent
-
>
InterceptionState
(
)
!
=
NavigateEvent
:
:
InterceptionState
:
:
Intercepted
)
{
aRv
.
ThrowInvalidStateError
(
"
Expected
interception
state
to
be
'
intercepted
'
"
)
;
return
;
}
if
(
mEvent
-
>
NavigationType
(
)
!
=
NavigationType
:
:
Push
&
&
mEvent
-
>
NavigationType
(
)
!
=
NavigationType
:
:
Replace
)
{
aRv
.
ThrowInvalidStateError
(
"
Expected
navigation
type
to
be
'
push
'
or
'
replace
'
"
)
;
return
;
}
RefPtr
<
Document
>
document
=
mEvent
-
>
GetDocument
(
)
;
if
(
!
document
)
{
aRv
.
ThrowInvalidStateError
(
"
Document
is
not
available
"
)
;
return
;
}
RefPtr
<
nsIURI
>
destinationURL
;
nsresult
res
=
NS_NewURI
(
getter_AddRefs
(
destinationURL
)
aUrl
nullptr
document
-
>
GetDocBaseURI
(
)
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
ThrowSyntaxError
(
"
URL
given
to
navigate
(
)
is
invalid
"
)
;
return
;
}
if
(
!
document
-
>
CanRewriteURL
(
destinationURL
)
)
{
aRv
.
ThrowSecurityError
(
"
Cannot
rewrite
URL
to
the
given
destination
URL
"
)
;
return
;
}
if
(
aOptions
.
mHistory
=
=
NavigationHistoryBehavior
:
:
Push
|
|
aOptions
.
mHistory
=
=
NavigationHistoryBehavior
:
:
Replace
)
{
mEvent
-
>
SetNavigationType
(
*
NavigationUtils
:
:
NavigationTypeFromNavigationHistoryBehavior
(
aOptions
.
mHistory
)
)
;
}
RefPtr
destination
=
mEvent
-
>
Destination
(
)
;
if
(
!
aOptions
.
mState
.
isUndefined
(
)
)
{
RefPtr
<
nsIStructuredCloneContainer
>
serializedState
=
new
nsStructuredCloneContainer
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
state
(
aCx
aOptions
.
mState
)
;
const
nsresult
rv
=
serializedState
-
>
InitFromJSVal
(
state
aCx
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
aCx
)
;
if
(
JS_GetPendingException
(
aCx
&
exception
)
)
{
JS_ClearPendingException
(
aCx
)
;
aRv
.
ThrowJSException
(
aCx
exception
)
;
}
else
{
aRv
.
ThrowDataCloneError
(
"
Failed
to
serialize
value
for
redirect
(
)
.
"
)
;
}
return
;
}
destination
-
>
SetState
(
serializedState
)
;
if
(
Navigation
*
target
=
Navigation
:
:
FromEventTargetOrNull
(
mEvent
-
>
GetTarget
(
)
)
)
{
target
-
>
SetSerializedStateIntoOngoingAPIMethodTracker
(
serializedState
)
;
}
}
destination
-
>
SetURL
(
destinationURL
)
;
if
(
!
aOptions
.
mInfo
.
isUndefined
(
)
)
{
mEvent
-
>
SetInfo
(
aOptions
.
mInfo
)
;
}
}
}
