#
ifndef
mozilla_IMEContentObserver_h
#
define
mozilla_IMEContentObserver_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIReflowObserver
.
h
"
#
include
"
nsIScrollObserver
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIContent
;
class
nsINode
;
class
nsISelection
;
class
nsPresContext
;
namespace
mozilla
{
class
EventStateManager
;
class
TextComposition
;
namespace
dom
{
class
Selection
;
}
class
IMEContentObserver
final
:
public
nsStubMutationObserver
public
nsIReflowObserver
public
nsIScrollObserver
public
nsSupportsWeakReference
{
public
:
typedef
widget
:
:
IMENotification
:
:
SelectionChangeData
SelectionChangeData
;
typedef
widget
:
:
IMENotification
:
:
TextChangeData
TextChangeData
;
typedef
widget
:
:
IMENotification
:
:
TextChangeDataBase
TextChangeDataBase
;
typedef
widget
:
:
IMENotificationRequests
IMENotificationRequests
;
typedef
widget
:
:
IMEMessage
IMEMessage
;
IMEContentObserver
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
IMEContentObserver
nsIReflowObserver
)
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATAWILLCHANGE
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIREFLOWOBSERVER
virtual
void
ScrollPositionChanged
(
)
override
;
void
OnSelectionChange
(
dom
:
:
Selection
&
aSelection
)
;
bool
OnMouseButtonEvent
(
nsPresContext
*
aPresContext
WidgetMouseEvent
*
aMouseEvent
)
;
nsresult
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
;
void
Init
(
nsIWidget
*
aWidget
nsPresContext
*
aPresContext
nsIContent
*
aContent
EditorBase
*
aEditorBase
)
;
void
Destroy
(
)
;
bool
Destroyed
(
)
const
;
void
DisconnectFromEventStateManager
(
)
;
bool
MaybeReinitialize
(
nsIWidget
*
aWidget
nsPresContext
*
aPresContext
nsIContent
*
aContent
EditorBase
*
aEditorBase
)
;
bool
IsManaging
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
const
;
bool
IsManaging
(
const
TextComposition
*
aTextComposition
)
const
;
bool
WasInitializedWithPlugin
(
)
const
;
bool
WasInitializedWith
(
const
EditorBase
&
aEditorBase
)
const
{
return
mEditorBase
=
=
&
aEditorBase
;
}
bool
IsEditorHandlingEventForComposition
(
)
const
;
bool
KeepAliveDuringDeactive
(
)
const
{
return
mIMENotificationRequests
&
&
mIMENotificationRequests
-
>
WantDuringDeactive
(
)
;
}
nsIWidget
*
GetWidget
(
)
const
{
return
mWidget
;
}
void
SuppressNotifyingIME
(
)
;
void
UnsuppressNotifyingIME
(
)
;
nsPresContext
*
GetPresContext
(
)
const
;
nsresult
GetSelectionAndRoot
(
nsISelection
*
*
aSelection
nsIContent
*
*
aRoot
)
const
;
void
TryToFlushPendingNotifications
(
bool
aAllowAsync
)
;
void
MaybeNotifyCompositionEventHandled
(
)
;
void
OnEditActionHandled
(
)
;
void
BeforeEditAction
(
)
;
void
CancelEditAction
(
)
;
private
:
~
IMEContentObserver
(
)
{
}
enum
State
{
eState_NotObserving
eState_Initializing
eState_StoppedObserving
eState_Observing
}
;
State
GetState
(
)
const
;
bool
InitWithEditor
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
EditorBase
*
aEditorBase
)
;
bool
InitWithPlugin
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
;
bool
IsInitializedWithPlugin
(
)
const
{
return
!
mEditorBase
;
}
void
OnIMEReceivedFocus
(
)
;
void
Clear
(
)
;
bool
IsObservingContent
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
const
;
bool
IsReflowLocked
(
)
const
;
bool
IsSafeToNotifyIME
(
)
const
;
bool
IsEditorComposing
(
)
const
;
void
BeginDocumentUpdate
(
)
;
void
EndDocumentUpdate
(
)
;
void
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
bool
IsInDocumentChange
(
)
const
{
return
mDocumentObserver
&
&
mDocumentObserver
-
>
IsUpdating
(
)
;
}
void
ClearAddedNodesDuringDocumentChange
(
)
;
bool
HasAddedNodesDuringDocumentChange
(
)
const
{
return
mFirstAddedContainer
&
&
mLastAddedContainer
;
}
bool
IsNextNodeOfLastAddedNode
(
nsINode
*
aParent
nsIContent
*
aChild
)
const
;
void
PostFocusSetNotification
(
)
;
void
MaybeNotifyIMEOfFocusSet
(
)
;
void
PostTextChangeNotification
(
)
;
void
MaybeNotifyIMEOfTextChange
(
const
TextChangeDataBase
&
aTextChangeData
)
;
void
CancelNotifyingIMEOfTextChange
(
)
;
void
PostSelectionChangeNotification
(
)
;
void
MaybeNotifyIMEOfSelectionChange
(
bool
aCausedByComposition
bool
aCausedBySelectionEvent
bool
aOccurredDuringComposition
)
;
void
PostPositionChangeNotification
(
)
;
void
MaybeNotifyIMEOfPositionChange
(
)
;
void
CancelNotifyingIMEOfPositionChange
(
)
;
void
PostCompositionEventHandledNotification
(
)
;
void
NotifyContentAdded
(
nsINode
*
aContainer
nsIContent
*
aFirstContent
nsIContent
*
aLastContent
)
;
void
ObserveEditableNode
(
)
;
void
NotifyIMEOfBlur
(
)
;
void
UnregisterObservers
(
)
;
void
FlushMergeableNotifications
(
)
;
bool
NeedsTextChangeNotification
(
)
const
{
return
mIMENotificationRequests
&
&
mIMENotificationRequests
-
>
WantTextChange
(
)
;
}
bool
NeedsPositionChangeNotification
(
)
const
{
return
mIMENotificationRequests
&
&
mIMENotificationRequests
-
>
WantPositionChanged
(
)
;
}
void
ClearPendingNotifications
(
)
{
mNeedsToNotifyIMEOfFocusSet
=
false
;
mNeedsToNotifyIMEOfTextChange
=
false
;
mNeedsToNotifyIMEOfSelectionChange
=
false
;
mNeedsToNotifyIMEOfPositionChange
=
false
;
mNeedsToNotifyIMEOfCompositionEventHandled
=
false
;
mTextChangeData
.
Clear
(
)
;
}
bool
NeedsToNotifyIMEOfSomething
(
)
const
{
return
mNeedsToNotifyIMEOfFocusSet
|
|
mNeedsToNotifyIMEOfTextChange
|
|
mNeedsToNotifyIMEOfSelectionChange
|
|
mNeedsToNotifyIMEOfPositionChange
|
|
mNeedsToNotifyIMEOfCompositionEventHandled
;
}
bool
UpdateSelectionCache
(
)
;
nsCOMPtr
<
nsIWidget
>
mWidget
;
nsCOMPtr
<
nsIWidget
>
mFocusedWidget
;
RefPtr
<
dom
:
:
Selection
>
mSelection
;
nsCOMPtr
<
nsIContent
>
mRootContent
;
nsCOMPtr
<
nsINode
>
mEditableNode
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
EditorBase
>
mEditorBase
;
class
AChangeEvent
:
public
Runnable
{
protected
:
enum
ChangeEventType
{
eChangeEventType_Focus
eChangeEventType_Selection
eChangeEventType_Text
eChangeEventType_Position
eChangeEventType_CompositionEventHandled
}
;
explicit
AChangeEvent
(
const
char
*
aName
IMEContentObserver
*
aIMEContentObserver
)
:
Runnable
(
aName
)
mIMEContentObserver
(
do_GetWeakReference
(
static_cast
<
nsIReflowObserver
*
>
(
aIMEContentObserver
)
)
)
{
MOZ_ASSERT
(
aIMEContentObserver
)
;
}
already_AddRefed
<
IMEContentObserver
>
GetObserver
(
)
const
{
nsCOMPtr
<
nsIReflowObserver
>
observer
=
do_QueryReferent
(
mIMEContentObserver
)
;
return
observer
.
forget
(
)
.
downcast
<
IMEContentObserver
>
(
)
;
}
nsWeakPtr
mIMEContentObserver
;
bool
CanNotifyIME
(
ChangeEventType
aChangeEventType
)
const
;
bool
IsSafeToNotifyIME
(
ChangeEventType
aChangeEventType
)
const
;
}
;
class
IMENotificationSender
:
public
AChangeEvent
{
public
:
explicit
IMENotificationSender
(
IMEContentObserver
*
aIMEContentObserver
)
:
AChangeEvent
(
"
IMENotificationSender
"
aIMEContentObserver
)
mIsRunning
(
false
)
{
}
NS_IMETHOD
Run
(
)
override
;
void
Dispatch
(
nsIDocShell
*
aDocShell
)
;
private
:
void
SendFocusSet
(
)
;
void
SendSelectionChange
(
)
;
void
SendTextChange
(
)
;
void
SendPositionChange
(
)
;
void
SendCompositionEventHandled
(
)
;
bool
mIsRunning
;
}
;
RefPtr
<
IMENotificationSender
>
mQueuedSender
;
class
DocumentObserver
final
:
public
nsStubDocumentObserver
{
public
:
explicit
DocumentObserver
(
IMEContentObserver
&
aIMEContentObserver
)
:
mIMEContentObserver
(
&
aIMEContentObserver
)
mDocumentUpdating
(
0
)
{
}
NS_DECL_CYCLE_COLLECTION_CLASS
(
DocumentObserver
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIDOCUMENTOBSERVER_BEGINUPDATE
NS_DECL_NSIDOCUMENTOBSERVER_ENDUPDATE
void
Observe
(
nsIDocument
*
aDocument
)
;
void
StopObserving
(
)
;
void
Destroy
(
)
;
bool
Destroyed
(
)
const
{
return
!
mIMEContentObserver
;
}
bool
IsObserving
(
)
const
{
return
mDocument
!
=
nullptr
;
}
bool
IsUpdating
(
)
const
{
return
mDocumentUpdating
!
=
0
;
}
private
:
DocumentObserver
(
)
=
delete
;
virtual
~
DocumentObserver
(
)
{
Destroy
(
)
;
}
RefPtr
<
IMEContentObserver
>
mIMEContentObserver
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
uint32_t
mDocumentUpdating
;
}
;
RefPtr
<
DocumentObserver
>
mDocumentObserver
;
struct
FlatTextCache
{
nsCOMPtr
<
nsINode
>
mContainerNode
;
nsCOMPtr
<
nsINode
>
mNode
;
uint32_t
mFlatTextLength
;
FlatTextCache
(
)
:
mFlatTextLength
(
0
)
{
}
void
Clear
(
)
{
mContainerNode
=
nullptr
;
mNode
=
nullptr
;
mFlatTextLength
=
0
;
}
void
Cache
(
nsINode
*
aContainer
nsINode
*
aNode
uint32_t
aFlatTextLength
)
{
MOZ_ASSERT
(
aContainer
"
aContainer
must
not
be
null
"
)
;
MOZ_ASSERT
(
!
aNode
|
|
aNode
-
>
GetParentNode
(
)
=
=
aContainer
"
aNode
must
be
either
null
or
a
child
of
aContainer
"
)
;
mContainerNode
=
aContainer
;
mNode
=
aNode
;
mFlatTextLength
=
aFlatTextLength
;
}
bool
Match
(
nsINode
*
aContainer
nsINode
*
aNode
)
const
{
return
aContainer
=
=
mContainerNode
&
&
aNode
=
=
mNode
;
}
}
;
FlatTextCache
mEndOfAddedTextCache
;
FlatTextCache
mStartOfRemovingTextRangeCache
;
nsCOMPtr
<
nsINode
>
mFirstAddedContainer
;
nsCOMPtr
<
nsINode
>
mLastAddedContainer
;
nsCOMPtr
<
nsIContent
>
mFirstAddedContent
;
nsCOMPtr
<
nsIContent
>
mLastAddedContent
;
TextChangeData
mTextChangeData
;
SelectionChangeData
mSelectionData
;
EventStateManager
*
mESM
;
const
IMENotificationRequests
*
mIMENotificationRequests
;
uint32_t
mPreAttrChangeLength
;
uint32_t
mSuppressNotifications
;
int64_t
mPreCharacterDataChangeLength
;
IMEMessage
mSendingNotification
;
bool
mIsObserving
;
bool
mIMEHasFocus
;
bool
mNeedsToNotifyIMEOfFocusSet
;
bool
mNeedsToNotifyIMEOfTextChange
;
bool
mNeedsToNotifyIMEOfSelectionChange
;
bool
mNeedsToNotifyIMEOfPositionChange
;
bool
mNeedsToNotifyIMEOfCompositionEventHandled
;
bool
mIsHandlingQueryContentEvent
;
}
;
}
#
endif
