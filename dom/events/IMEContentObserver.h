#
ifndef
mozilla_IMEContentObserver_h
#
define
mozilla_IMEContentObserver_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIReflowObserver
.
h
"
#
include
"
nsIScrollObserver
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIContent
;
class
nsINode
;
class
nsPresContext
;
namespace
mozilla
{
class
EventStateManager
;
class
TextComposition
;
namespace
dom
{
class
Selection
;
}
class
IMEContentObserver
final
:
public
nsStubMutationObserver
public
nsIReflowObserver
public
nsIScrollObserver
public
nsSupportsWeakReference
{
public
:
using
SelectionChangeData
=
widget
:
:
IMENotification
:
:
SelectionChangeData
;
using
TextChangeData
=
widget
:
:
IMENotification
:
:
TextChangeData
;
using
TextChangeDataBase
=
widget
:
:
IMENotification
:
:
TextChangeDataBase
;
using
IMENotificationRequests
=
widget
:
:
IMENotificationRequests
;
using
IMEMessage
=
widget
:
:
IMEMessage
;
IMEContentObserver
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
IMEContentObserver
nsIReflowObserver
)
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATAWILLCHANGE
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIREFLOWOBSERVER
virtual
void
ScrollPositionChanged
(
)
override
;
void
OnSelectionChange
(
dom
:
:
Selection
&
aSelection
)
;
MOZ_CAN_RUN_SCRIPT
bool
OnMouseButtonEvent
(
nsPresContext
&
aPresContext
WidgetMouseEvent
&
aMouseEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
MaybeHandleSelectionEvent
(
nsPresContext
*
aPresContext
WidgetSelectionEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
void
Init
(
nsIWidget
&
aWidget
nsPresContext
&
aPresContext
dom
:
:
Element
*
aElement
EditorBase
&
aEditorBase
)
;
void
Destroy
(
)
;
bool
Destroyed
(
)
const
;
void
DisconnectFromEventStateManager
(
)
;
MOZ_CAN_RUN_SCRIPT
bool
MaybeReinitialize
(
nsIWidget
&
aWidget
nsPresContext
&
aPresContext
dom
:
:
Element
*
aElement
EditorBase
&
aEditorBase
)
;
[
[
nodiscard
]
]
bool
IsObserving
(
const
nsPresContext
&
aPresContext
const
dom
:
:
Element
*
aElement
)
const
;
[
[
nodiscard
]
]
bool
IsBeingInitializedFor
(
const
nsPresContext
&
aPresContext
const
dom
:
:
Element
*
aElement
const
EditorBase
&
aEditorBase
)
const
;
bool
IsObserving
(
const
TextComposition
&
aTextComposition
)
const
;
bool
WasInitializedWith
(
const
EditorBase
&
aEditorBase
)
const
{
return
mEditorBase
=
=
&
aEditorBase
;
}
bool
IsEditorHandlingEventForComposition
(
)
const
;
bool
KeepAliveDuringDeactive
(
)
const
{
return
mIMENotificationRequests
&
&
mIMENotificationRequests
-
>
WantDuringDeactive
(
)
;
}
[
[
nodiscard
]
]
bool
EditorIsTextEditor
(
)
const
{
return
mEditorBase
&
&
mEditorBase
-
>
IsTextEditor
(
)
;
}
nsIWidget
*
GetWidget
(
)
const
{
return
mWidget
;
}
void
SuppressNotifyingIME
(
)
;
void
UnsuppressNotifyingIME
(
)
;
nsPresContext
*
GetPresContext
(
)
const
;
nsresult
GetSelectionAndRoot
(
dom
:
:
Selection
*
*
aSelection
dom
:
:
Element
*
*
aRootElement
)
const
;
void
TryToFlushPendingNotifications
(
bool
aAllowAsync
)
;
void
MaybeNotifyCompositionEventHandled
(
)
;
void
OnEditActionHandled
(
)
;
void
BeforeEditAction
(
)
;
void
CancelEditAction
(
)
;
void
OnTextControlValueChangedWhileNotObservable
(
const
nsAString
&
aNewValue
)
;
dom
:
:
Element
*
GetObservingElement
(
)
const
{
return
mIsObserving
?
mRootElement
.
get
(
)
:
nullptr
;
}
private
:
~
IMEContentObserver
(
)
=
default
;
enum
State
{
eState_NotObserving
eState_Initializing
eState_StoppedObserving
eState_Observing
}
;
State
GetState
(
)
const
;
MOZ_CAN_RUN_SCRIPT
bool
InitWithEditor
(
nsPresContext
&
aPresContext
dom
:
:
Element
*
aElement
EditorBase
&
aEditorBase
)
;
void
OnIMEReceivedFocus
(
)
;
void
Clear
(
)
;
[
[
nodiscard
]
]
bool
IsObservingContent
(
const
nsPresContext
&
aPresContext
const
dom
:
:
Element
*
aElement
)
const
;
[
[
nodiscard
]
]
bool
IsReflowLocked
(
)
const
;
[
[
nodiscard
]
]
bool
IsSafeToNotifyIME
(
)
const
;
[
[
nodiscard
]
]
bool
IsEditorComposing
(
)
const
;
void
BeginDocumentUpdate
(
)
;
void
EndDocumentUpdate
(
)
;
void
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
bool
IsInDocumentChange
(
)
const
{
return
mDocumentObserver
&
&
mDocumentObserver
-
>
IsUpdating
(
)
;
}
void
ClearAddedNodesDuringDocumentChange
(
)
;
bool
HasAddedNodesDuringDocumentChange
(
)
const
{
return
mFirstAddedContainer
&
&
mLastAddedContainer
;
}
bool
IsNextNodeOfLastAddedNode
(
nsINode
*
aParent
nsIContent
*
aChild
)
const
;
void
PostFocusSetNotification
(
)
;
void
MaybeNotifyIMEOfFocusSet
(
)
;
void
PostTextChangeNotification
(
)
;
void
MaybeNotifyIMEOfTextChange
(
const
TextChangeDataBase
&
aTextChangeData
)
;
void
CancelNotifyingIMEOfTextChange
(
)
;
void
PostSelectionChangeNotification
(
)
;
void
MaybeNotifyIMEOfSelectionChange
(
bool
aCausedByComposition
bool
aCausedBySelectionEvent
bool
aOccurredDuringComposition
)
;
void
PostPositionChangeNotification
(
)
;
void
MaybeNotifyIMEOfPositionChange
(
)
;
void
CancelNotifyingIMEOfPositionChange
(
)
;
void
PostCompositionEventHandledNotification
(
)
;
void
NotifyContentAdded
(
nsINode
*
aContainer
nsIContent
*
aFirstContent
nsIContent
*
aLastContent
)
;
void
ObserveEditableNode
(
)
;
void
NotifyIMEOfBlur
(
)
;
void
UnregisterObservers
(
)
;
void
FlushMergeableNotifications
(
)
;
bool
NeedsTextChangeNotification
(
)
const
{
return
mIMENotificationRequests
&
&
mIMENotificationRequests
-
>
WantTextChange
(
)
;
}
bool
NeedsPositionChangeNotification
(
)
const
{
return
mIMENotificationRequests
&
&
mIMENotificationRequests
-
>
WantPositionChanged
(
)
;
}
void
ClearPendingNotifications
(
)
{
mNeedsToNotifyIMEOfFocusSet
=
false
;
mNeedsToNotifyIMEOfTextChange
=
false
;
mNeedsToNotifyIMEOfSelectionChange
=
false
;
mNeedsToNotifyIMEOfPositionChange
=
false
;
mNeedsToNotifyIMEOfCompositionEventHandled
=
false
;
mTextChangeData
.
Clear
(
)
;
}
bool
NeedsToNotifyIMEOfSomething
(
)
const
{
return
mNeedsToNotifyIMEOfFocusSet
|
|
mNeedsToNotifyIMEOfTextChange
|
|
mNeedsToNotifyIMEOfSelectionChange
|
|
mNeedsToNotifyIMEOfPositionChange
|
|
mNeedsToNotifyIMEOfCompositionEventHandled
;
}
MOZ_CAN_RUN_SCRIPT
bool
UpdateSelectionCache
(
bool
aRequireFlush
=
true
)
;
nsCOMPtr
<
nsIWidget
>
mWidget
;
nsCOMPtr
<
nsIWidget
>
mFocusedWidget
;
RefPtr
<
dom
:
:
Selection
>
mSelection
;
RefPtr
<
dom
:
:
Element
>
mRootElement
;
nsCOMPtr
<
nsINode
>
mEditableNode
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
EditorBase
>
mEditorBase
;
class
AChangeEvent
:
public
Runnable
{
protected
:
enum
ChangeEventType
{
eChangeEventType_Focus
eChangeEventType_Selection
eChangeEventType_Text
eChangeEventType_Position
eChangeEventType_CompositionEventHandled
}
;
explicit
AChangeEvent
(
const
char
*
aName
IMEContentObserver
*
aIMEContentObserver
)
:
Runnable
(
aName
)
mIMEContentObserver
(
do_GetWeakReference
(
static_cast
<
nsIReflowObserver
*
>
(
aIMEContentObserver
)
)
)
{
MOZ_ASSERT
(
aIMEContentObserver
)
;
}
already_AddRefed
<
IMEContentObserver
>
GetObserver
(
)
const
{
nsCOMPtr
<
nsIReflowObserver
>
observer
=
do_QueryReferent
(
mIMEContentObserver
)
;
return
observer
.
forget
(
)
.
downcast
<
IMEContentObserver
>
(
)
;
}
nsWeakPtr
mIMEContentObserver
;
bool
CanNotifyIME
(
ChangeEventType
aChangeEventType
)
const
;
bool
IsSafeToNotifyIME
(
ChangeEventType
aChangeEventType
)
const
;
}
;
class
IMENotificationSender
:
public
AChangeEvent
{
public
:
explicit
IMENotificationSender
(
IMEContentObserver
*
aIMEContentObserver
)
:
AChangeEvent
(
"
IMENotificationSender
"
aIMEContentObserver
)
mIsRunning
(
false
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
;
void
Dispatch
(
nsIDocShell
*
aDocShell
)
;
private
:
MOZ_CAN_RUN_SCRIPT
void
SendFocusSet
(
)
;
MOZ_CAN_RUN_SCRIPT
void
SendSelectionChange
(
)
;
void
SendTextChange
(
)
;
void
SendPositionChange
(
)
;
void
SendCompositionEventHandled
(
)
;
bool
mIsRunning
;
}
;
RefPtr
<
IMENotificationSender
>
mQueuedSender
;
class
DocumentObserver
final
:
public
nsStubDocumentObserver
{
public
:
DocumentObserver
(
)
=
delete
;
explicit
DocumentObserver
(
IMEContentObserver
&
aIMEContentObserver
)
:
mIMEContentObserver
(
&
aIMEContentObserver
)
mDocumentUpdating
(
0
)
{
SetEnabledCallbacks
(
nsIMutationObserver
:
:
kBeginUpdate
|
nsIMutationObserver
:
:
kEndUpdate
)
;
}
NS_DECL_CYCLE_COLLECTION_CLASS
(
DocumentObserver
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIDOCUMENTOBSERVER_BEGINUPDATE
NS_DECL_NSIDOCUMENTOBSERVER_ENDUPDATE
void
Observe
(
dom
:
:
Document
*
)
;
void
StopObserving
(
)
;
void
Destroy
(
)
;
bool
Destroyed
(
)
const
{
return
!
mIMEContentObserver
;
}
bool
IsObserving
(
)
const
{
return
mDocument
!
=
nullptr
;
}
bool
IsUpdating
(
)
const
{
return
mDocumentUpdating
!
=
0
;
}
private
:
virtual
~
DocumentObserver
(
)
{
Destroy
(
)
;
}
RefPtr
<
IMEContentObserver
>
mIMEContentObserver
;
RefPtr
<
dom
:
:
Document
>
mDocument
;
uint32_t
mDocumentUpdating
;
}
;
RefPtr
<
DocumentObserver
>
mDocumentObserver
;
struct
FlatTextCache
{
public
:
void
Clear
(
)
{
mContainerNode
=
nullptr
;
mContent
=
nullptr
;
mFlatTextLength
=
0
;
}
[
[
nodiscard
]
]
bool
IsCachingToEndOfContent
(
)
const
{
return
mContainerNode
&
&
mContent
;
}
[
[
nodiscard
]
]
bool
IsCachingToStartOfContainer
(
)
const
{
return
mContainerNode
&
&
!
mContent
;
}
[
[
nodiscard
]
]
nsresult
ComputeAndCacheFlatTextLengthBeforeEndOfContent
(
const
nsIContent
&
aContent
const
dom
:
:
Element
*
aRootElement
)
;
void
CacheFlatTextLengthBeforeEndOfContent
(
const
nsIContent
&
aContent
uint32_t
aFlatTextLength
)
{
mContainerNode
=
aContent
.
GetParentNode
(
)
;
mContent
=
const_cast
<
nsIContent
*
>
(
&
aContent
)
;
mFlatTextLength
=
aFlatTextLength
;
MOZ_ASSERT
(
IsCachingToEndOfContent
(
)
)
;
}
[
[
nodiscard
]
]
nsresult
ComputeAndCacheFlatTextLengthBeforeFirstContent
(
const
nsINode
&
aContainer
const
dom
:
:
Element
*
aRootElement
)
;
void
CacheFlatTextLengthBeforeFirstContent
(
const
nsINode
&
aContainer
uint32_t
aFlatTextLength
)
{
mContainerNode
=
const_cast
<
nsINode
*
>
(
&
aContainer
)
;
mContent
=
nullptr
;
mFlatTextLength
=
aFlatTextLength
;
MOZ_ASSERT
(
IsCachingToStartOfContainer
(
)
)
;
}
[
[
nodiscard
]
]
static
Result
<
uint32_t
nsresult
>
ComputeTextLengthOfRemovingContent
(
const
nsIContent
&
aRemovingContent
const
dom
:
:
Element
*
aRootElement
)
;
[
[
nodiscard
]
]
bool
CachesTextLengthBeforeContent
(
const
nsIContent
&
aContent
)
const
{
MOZ_ASSERT
(
!
aContent
.
IsBeingRemoved
(
)
)
;
return
CachesTextLengthBeforeContent
(
aContent
aContent
.
GetPreviousSibling
(
)
)
;
}
[
[
nodiscard
]
]
bool
CachesTextLengthBeforeContent
(
const
nsIContent
&
aContent
const
nsIContent
*
aPreviousSibling
)
const
{
MOZ_ASSERT_IF
(
!
aContent
.
IsBeingRemoved
(
)
aContent
.
GetPreviousSibling
(
)
=
=
aPreviousSibling
)
;
if
(
!
mContainerNode
|
|
mContainerNode
!
=
aContent
.
GetParentNode
(
)
)
{
return
false
;
}
if
(
IsCachingToStartOfContainer
(
)
)
{
MOZ_ASSERT
(
!
mContent
)
;
return
!
aPreviousSibling
;
}
MOZ_ASSERT
(
mContent
)
;
return
mContainerNode
=
=
aContent
.
GetParentNode
(
)
&
&
mContent
=
=
aPreviousSibling
;
}
nsCOMPtr
<
nsINode
>
mContainerNode
;
nsCOMPtr
<
nsIContent
>
mContent
;
uint32_t
mFlatTextLength
=
0
;
}
;
FlatTextCache
mEndOfAddedTextCache
;
FlatTextCache
mStartOfRemovingTextRangeCache
;
nsCOMPtr
<
nsINode
>
mFirstAddedContainer
;
nsCOMPtr
<
nsINode
>
mLastAddedContainer
;
nsCOMPtr
<
nsIContent
>
mFirstAddedContent
;
nsCOMPtr
<
nsIContent
>
mLastAddedContent
;
TextChangeData
mTextChangeData
;
SelectionChangeData
mSelectionData
;
EventStateManager
*
mESM
=
nullptr
;
const
IMENotificationRequests
*
mIMENotificationRequests
=
nullptr
;
int64_t
mPreCharacterDataChangeLength
=
-
1
;
uint32_t
mSuppressNotifications
=
0
;
uint32_t
mTextControlValueLength
=
0
;
IMEMessage
mSendingNotification
=
widget
:
:
NOTIFY_IME_OF_NOTHING
;
bool
mIsObserving
=
false
;
bool
mIsTextControl
=
false
;
bool
mIMEHasFocus
=
false
;
bool
mNeedsToNotifyIMEOfFocusSet
=
false
;
bool
mNeedsToNotifyIMEOfTextChange
=
false
;
bool
mNeedsToNotifyIMEOfSelectionChange
=
false
;
bool
mNeedsToNotifyIMEOfPositionChange
=
false
;
bool
mNeedsToNotifyIMEOfCompositionEventHandled
=
false
;
bool
mIsHandlingQueryContentEvent
=
false
;
}
;
}
#
endif
