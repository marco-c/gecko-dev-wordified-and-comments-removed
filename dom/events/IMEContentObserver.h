#
ifndef
mozilla_IMEContentObserver_h_
#
define
mozilla_IMEContentObserver_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEditorObserver
.
h
"
#
include
"
nsIReflowObserver
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsIScrollObserver
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIContent
;
class
nsINode
;
class
nsISelection
;
class
nsPresContext
;
namespace
mozilla
{
class
EventStateManager
;
class
IMEContentObserver
final
:
public
nsISelectionListener
public
nsStubMutationObserver
public
nsIReflowObserver
public
nsIScrollObserver
public
nsSupportsWeakReference
public
nsIEditorObserver
{
public
:
typedef
ContentEventHandler
:
:
NodePosition
NodePosition
;
typedef
ContentEventHandler
:
:
NodePositionBefore
NodePositionBefore
;
typedef
widget
:
:
IMENotification
:
:
SelectionChangeData
SelectionChangeData
;
typedef
widget
:
:
IMENotification
:
:
TextChangeData
TextChangeData
;
typedef
widget
:
:
IMENotification
:
:
TextChangeDataBase
TextChangeDataBase
;
typedef
widget
:
:
IMEMessage
IMEMessage
;
IMEContentObserver
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
IMEContentObserver
nsISelectionListener
)
NS_DECL_NSIEDITOROBSERVER
NS_DECL_NSISELECTIONLISTENER
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATAWILLCHANGE
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIREFLOWOBSERVER
virtual
void
ScrollPositionChanged
(
)
override
;
bool
OnMouseButtonEvent
(
nsPresContext
*
aPresContext
WidgetMouseEvent
*
aMouseEvent
)
;
nsresult
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
;
void
Init
(
nsIWidget
*
aWidget
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsIEditor
*
aEditor
)
;
void
Destroy
(
)
;
void
DisconnectFromEventStateManager
(
)
;
bool
MaybeReinitialize
(
nsIWidget
*
aWidget
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsIEditor
*
aEditor
)
;
bool
IsManaging
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
;
bool
IsEditorHandlingEventForComposition
(
)
const
;
bool
KeepAliveDuringDeactive
(
)
const
{
return
mUpdatePreference
.
WantDuringDeactive
(
)
;
}
nsIWidget
*
GetWidget
(
)
const
{
return
mWidget
;
}
nsIEditor
*
GetEditor
(
)
const
{
return
mEditor
;
}
void
SuppressNotifyingIME
(
)
;
void
UnsuppressNotifyingIME
(
)
;
nsPresContext
*
GetPresContext
(
)
const
;
nsresult
GetSelectionAndRoot
(
nsISelection
*
*
aSelection
nsIContent
*
*
aRoot
)
const
;
void
TryToFlushPendingNotifications
(
)
;
private
:
~
IMEContentObserver
(
)
{
}
enum
State
{
eState_NotObserving
eState_Initializing
eState_StoppedObserving
eState_Observing
}
;
State
GetState
(
)
const
;
bool
InitWithEditor
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsIEditor
*
aEditor
)
;
bool
InitWithPlugin
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
;
bool
IsInitializedWithPlugin
(
)
const
{
return
!
mEditor
;
}
void
OnIMEReceivedFocus
(
)
;
void
Clear
(
)
;
bool
IsObservingContent
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
const
;
bool
IsReflowLocked
(
)
const
;
bool
IsSafeToNotifyIME
(
)
const
;
bool
IsEditorComposing
(
)
const
;
void
PostFocusSetNotification
(
)
;
void
MaybeNotifyIMEOfFocusSet
(
)
;
void
PostTextChangeNotification
(
)
;
void
MaybeNotifyIMEOfTextChange
(
const
TextChangeDataBase
&
aTextChangeData
)
;
void
PostSelectionChangeNotification
(
)
;
void
MaybeNotifyIMEOfSelectionChange
(
bool
aCausedByComposition
bool
aCausedBySelectionEvent
bool
aOccurredDuringComposition
)
;
void
PostPositionChangeNotification
(
)
;
void
MaybeNotifyIMEOfPositionChange
(
)
;
void
NotifyContentAdded
(
nsINode
*
aContainer
int32_t
aStart
int32_t
aEnd
)
;
void
ObserveEditableNode
(
)
;
void
NotifyIMEOfBlur
(
)
;
void
UnregisterObservers
(
)
;
void
FlushMergeableNotifications
(
)
;
void
ClearPendingNotifications
(
)
{
mNeedsToNotifyIMEOfFocusSet
=
false
;
mNeedsToNotifyIMEOfTextChange
=
false
;
mNeedsToNotifyIMEOfSelectionChange
=
false
;
mNeedsToNotifyIMEOfPositionChange
=
false
;
mTextChangeData
.
Clear
(
)
;
}
bool
NeedsToNotifyIMEOfSomething
(
)
const
{
return
mNeedsToNotifyIMEOfFocusSet
|
|
mNeedsToNotifyIMEOfTextChange
|
|
mNeedsToNotifyIMEOfSelectionChange
|
|
mNeedsToNotifyIMEOfPositionChange
;
}
bool
UpdateSelectionCache
(
)
;
nsCOMPtr
<
nsIWidget
>
mWidget
;
nsCOMPtr
<
nsIWidget
>
mFocusedWidget
;
nsCOMPtr
<
nsISelection
>
mSelection
;
nsCOMPtr
<
nsIContent
>
mRootContent
;
nsCOMPtr
<
nsINode
>
mEditableNode
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
nsCOMPtr
<
nsIEditor
>
mEditor
;
class
AChangeEvent
:
public
Runnable
{
protected
:
enum
ChangeEventType
{
eChangeEventType_Focus
eChangeEventType_Selection
eChangeEventType_Text
eChangeEventType_Position
eChangeEventType_FlushPendingEvents
}
;
explicit
AChangeEvent
(
IMEContentObserver
*
aIMEContentObserver
)
:
mIMEContentObserver
(
aIMEContentObserver
)
{
MOZ_ASSERT
(
mIMEContentObserver
)
;
}
RefPtr
<
IMEContentObserver
>
mIMEContentObserver
;
bool
CanNotifyIME
(
ChangeEventType
aChangeEventType
)
const
;
bool
IsSafeToNotifyIME
(
ChangeEventType
aChangeEventType
)
const
;
}
;
class
IMENotificationSender
:
public
AChangeEvent
{
public
:
explicit
IMENotificationSender
(
IMEContentObserver
*
aIMEContentObserver
)
:
AChangeEvent
(
aIMEContentObserver
)
mIsRunning
(
false
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
void
SendFocusSet
(
)
;
void
SendSelectionChange
(
)
;
void
SendTextChange
(
)
;
void
SendPositionChange
(
)
;
bool
mIsRunning
;
}
;
RefPtr
<
IMENotificationSender
>
mQueuedSender
;
struct
FlatTextCache
{
nsCOMPtr
<
nsINode
>
mContainerNode
;
int32_t
mNodeOffset
;
uint32_t
mFlatTextLength
;
FlatTextCache
(
)
:
mNodeOffset
(
0
)
mFlatTextLength
(
0
)
{
}
void
Clear
(
)
{
mContainerNode
=
nullptr
;
mNodeOffset
=
0
;
mFlatTextLength
=
0
;
}
void
Cache
(
nsINode
*
aContainer
int32_t
aNodeOffset
uint32_t
aFlatTextLength
)
{
MOZ_ASSERT
(
aContainer
"
aContainer
must
not
be
null
"
)
;
MOZ_ASSERT
(
aNodeOffset
<
=
static_cast
<
int32_t
>
(
aContainer
-
>
GetChildCount
(
)
)
"
aNodeOffset
must
be
same
as
or
less
than
the
count
of
children
"
)
;
mContainerNode
=
aContainer
;
mNodeOffset
=
aNodeOffset
;
mFlatTextLength
=
aFlatTextLength
;
}
bool
Match
(
nsINode
*
aContainer
int32_t
aNodeOffset
)
const
{
return
aContainer
=
=
mContainerNode
&
&
aNodeOffset
=
=
mNodeOffset
;
}
}
;
FlatTextCache
mEndOfAddedTextCache
;
FlatTextCache
mStartOfRemovingTextRangeCache
;
TextChangeData
mTextChangeData
;
SelectionChangeData
mSelectionData
;
EventStateManager
*
mESM
;
nsIMEUpdatePreference
mUpdatePreference
;
uint32_t
mPreAttrChangeLength
;
uint32_t
mSuppressNotifications
;
int64_t
mPreCharacterDataChangeLength
;
IMEMessage
mSendingNotification
;
bool
mIsObserving
;
bool
mIMEHasFocus
;
bool
mNeedsToNotifyIMEOfFocusSet
;
bool
mNeedsToNotifyIMEOfTextChange
;
bool
mNeedsToNotifyIMEOfSelectionChange
;
bool
mNeedsToNotifyIMEOfPositionChange
;
bool
mIsHandlingQueryContentEvent
;
}
;
}
#
endif
