#
ifndef
mozilla_ContentEventHandler_h_
#
define
mozilla_ContentEventHandler_h_
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
class
nsPresContext
;
class
nsRange
;
struct
nsRect
;
namespace
mozilla
{
enum
LineBreakType
{
LINE_BREAK_TYPE_NATIVE
LINE_BREAK_TYPE_XP
}
;
class
MOZ_STACK_CLASS
ContentEventHandler
{
private
:
class
MOZ_STACK_CLASS
RawRange
final
{
public
:
RawRange
(
)
=
default
;
void
Clear
(
)
{
mRoot
=
nullptr
;
mStart
=
RangeBoundary
(
)
;
mEnd
=
RangeBoundary
(
)
;
}
bool
IsPositioned
(
)
const
{
return
mStart
.
IsSet
(
)
&
&
mEnd
.
IsSet
(
)
;
}
bool
Collapsed
(
)
const
{
return
mStart
=
=
mEnd
&
&
IsPositioned
(
)
;
}
nsINode
*
GetStartContainer
(
)
const
{
return
mStart
.
Container
(
)
;
}
nsINode
*
GetEndContainer
(
)
const
{
return
mEnd
.
Container
(
)
;
}
uint32_t
StartOffset
(
)
const
{
return
*
mStart
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
;
}
uint32_t
EndOffset
(
)
const
{
return
*
mEnd
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
;
}
nsIContent
*
StartRef
(
)
const
{
return
mStart
.
Ref
(
)
;
}
nsIContent
*
EndRef
(
)
const
{
return
mEnd
.
Ref
(
)
;
}
const
RangeBoundary
&
Start
(
)
const
{
return
mStart
;
}
const
RangeBoundary
&
End
(
)
const
{
return
mEnd
;
}
nsresult
CollapseTo
(
const
RawRangeBoundary
&
aBoundary
)
{
return
SetStartAndEnd
(
aBoundary
aBoundary
)
;
}
nsresult
SetStart
(
const
RawRangeBoundary
&
aStart
)
;
nsresult
SetEnd
(
const
RawRangeBoundary
&
aEnd
)
;
nsresult
SetStart
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
)
{
return
SetStart
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
)
;
}
nsresult
SetEnd
(
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
return
SetEnd
(
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
nsresult
SetEndAfter
(
nsINode
*
aEndContainer
)
;
void
SetStartAndEnd
(
const
nsRange
*
aRange
)
;
nsresult
SetStartAndEnd
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
;
nsresult
SelectNodeContents
(
nsINode
*
aNodeToSelectContents
)
;
private
:
inline
void
AssertStartIsBeforeOrEqualToEnd
(
)
;
nsCOMPtr
<
nsINode
>
mRoot
;
RangeBoundary
mStart
;
RangeBoundary
mEnd
;
}
;
public
:
using
Selection
=
dom
:
:
Selection
;
explicit
ContentEventHandler
(
nsPresContext
*
aPresContext
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQuerySelectedText
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryTextContent
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryCaretRect
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryTextRect
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryTextRectArray
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryEditorRect
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryContentState
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQuerySelectionAsTransferable
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryCharacterAtPoint
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnQueryDOMWidgetHittest
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
OnSelectionEvent
(
WidgetSelectionEvent
*
aEvent
)
;
protected
:
RefPtr
<
dom
:
:
Document
>
mDocument
;
RefPtr
<
Selection
>
mSelection
;
RawRange
mFirstSelectedRawRange
;
nsCOMPtr
<
nsIContent
>
mRootContent
;
MOZ_CAN_RUN_SCRIPT
nsresult
Init
(
WidgetQueryContentEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
Init
(
WidgetSelectionEvent
*
aEvent
)
;
nsresult
InitBasic
(
bool
aRequireFlush
=
true
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InitCommon
(
SelectionType
aSelectionType
=
SelectionType
:
:
eNormal
bool
aRequireFlush
=
true
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
InitRootContent
(
const
Selection
&
aNormalSelection
)
;
public
:
struct
MOZ_STACK_CLASS
NodePosition
:
public
RangeBoundary
{
bool
mAfterOpenTag
=
true
;
NodePosition
(
)
=
default
;
NodePosition
(
nsINode
*
aContainer
int32_t
aOffset
)
:
RangeBoundary
(
aContainer
aOffset
)
{
}
NodePosition
(
nsINode
*
aContainer
nsIContent
*
aRef
)
:
RangeBoundary
(
aContainer
aRef
)
{
}
explicit
NodePosition
(
const
nsIFrame
:
:
ContentOffsets
&
aContentOffsets
)
:
RangeBoundary
(
aContentOffsets
.
content
aContentOffsets
.
offset
)
{
}
public
:
bool
operator
=
=
(
const
NodePosition
&
aOther
)
const
{
return
RangeBoundary
:
:
operator
=
=
(
aOther
)
&
&
mAfterOpenTag
=
=
aOther
.
mAfterOpenTag
;
}
bool
IsBeforeOpenTag
(
)
const
{
return
IsSet
(
)
&
&
Container
(
)
-
>
IsElement
(
)
&
&
!
Ref
(
)
&
&
!
mAfterOpenTag
;
}
bool
IsImmediatelyAfterOpenTag
(
)
const
{
return
IsSet
(
)
&
&
Container
(
)
-
>
IsElement
(
)
&
&
!
Ref
(
)
&
&
mAfterOpenTag
;
}
}
;
struct
NodePositionBefore
final
:
public
NodePosition
{
NodePositionBefore
(
nsINode
*
aContainer
int32_t
aOffset
)
:
NodePosition
(
aContainer
aOffset
)
{
mAfterOpenTag
=
false
;
}
NodePositionBefore
(
nsINode
*
aContainer
nsIContent
*
aRef
)
:
NodePosition
(
aContainer
aRef
)
{
mAfterOpenTag
=
false
;
}
}
;
static
nsresult
GetFlatTextLengthInRange
(
const
NodePosition
&
aStartPosition
const
NodePosition
&
aEndPosition
nsIContent
*
aRootContent
uint32_t
*
aLength
LineBreakType
aLineBreakType
bool
aIsRemovingNode
=
false
)
;
static
uint32_t
GetNativeTextLength
(
nsIContent
*
aContent
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
static
uint32_t
GetNativeTextLength
(
nsIContent
*
aContent
uint32_t
aMaxLength
=
UINT32_MAX
)
;
static
uint32_t
GetNativeTextLengthBefore
(
nsIContent
*
aContent
nsINode
*
aRootNode
)
;
protected
:
static
uint32_t
GetTextLength
(
nsIContent
*
aContent
LineBreakType
aLineBreakType
uint32_t
aMaxLength
=
UINT32_MAX
)
;
static
uint32_t
GetTextLengthInRange
(
nsIContent
*
aContent
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
;
nsresult
GenerateFlatTextContent
(
nsIContent
*
aContent
nsString
&
aString
LineBreakType
aLineBreakType
)
;
nsresult
GenerateFlatTextContent
(
const
RawRange
&
aRawRange
nsString
&
aString
LineBreakType
aLineBreakType
)
;
nsresult
GetStartOffset
(
const
RawRange
&
aRawRange
uint32_t
*
aOffset
LineBreakType
aLineBreakType
)
;
static
bool
ShouldBreakLineBefore
(
nsIContent
*
aContent
nsINode
*
aRootNode
)
;
static
inline
uint32_t
GetBRLength
(
LineBreakType
aLineBreakType
)
;
static
LineBreakType
GetLineBreakType
(
WidgetQueryContentEvent
*
aEvent
)
;
static
LineBreakType
GetLineBreakType
(
WidgetSelectionEvent
*
aEvent
)
;
static
LineBreakType
GetLineBreakType
(
bool
aUseNativeLineBreak
)
;
nsIContent
*
GetFocusedContent
(
)
;
nsresult
QueryContentRect
(
nsIContent
*
aContent
WidgetQueryContentEvent
*
aEvent
)
;
nsresult
SetRawRangeFromFlatTextOffset
(
RawRange
*
aRawRange
uint32_t
aOffset
uint32_t
aLength
LineBreakType
aLineBreakType
bool
aExpandToClusterBoundaries
uint32_t
*
aNewOffset
=
nullptr
nsIContent
*
*
aLastTextNode
=
nullptr
)
;
nsresult
AdjustCollapsedRangeMaybeIntoTextNode
(
RawRange
&
aCollapsedRawRange
)
;
nsresult
ConvertToRootRelativeOffset
(
nsIFrame
*
aFrame
nsRect
&
aRect
)
;
nsresult
ExpandToClusterBoundary
(
nsIContent
*
aContent
bool
aForward
uint32_t
*
aXPOffset
)
;
using
FontRangeArray
=
nsTArray
<
mozilla
:
:
FontRange
>
;
static
void
AppendFontRanges
(
FontRangeArray
&
aFontRanges
nsIContent
*
aContent
uint32_t
aBaseOffset
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
;
nsresult
GenerateFlatFontRanges
(
const
RawRange
&
aRawRange
FontRangeArray
&
aFontRanges
uint32_t
&
aLength
LineBreakType
aLineBreakType
)
;
nsresult
QueryTextRectByRange
(
const
RawRange
&
aRawRange
LayoutDeviceIntRect
&
aRect
WritingMode
&
aWritingMode
)
;
struct
MOZ_STACK_CLASS
FrameAndNodeOffset
final
{
nsIFrame
*
mFrame
;
int32_t
mOffsetInNode
;
FrameAndNodeOffset
(
)
:
mFrame
(
nullptr
)
mOffsetInNode
(
-
1
)
{
}
FrameAndNodeOffset
(
nsIFrame
*
aFrame
int32_t
aStartOffsetInNode
)
:
mFrame
(
aFrame
)
mOffsetInNode
(
aStartOffsetInNode
)
{
}
nsIFrame
*
operator
-
>
(
)
{
return
mFrame
;
}
const
nsIFrame
*
operator
-
>
(
)
const
{
return
mFrame
;
}
operator
nsIFrame
*
(
)
{
return
mFrame
;
}
operator
const
nsIFrame
*
(
)
const
{
return
mFrame
;
}
bool
IsValid
(
)
const
{
return
mFrame
&
&
mOffsetInNode
>
=
0
;
}
}
;
FrameAndNodeOffset
GetFirstFrameInRangeForTextRect
(
const
RawRange
&
aRawRange
)
;
FrameAndNodeOffset
GetLastFrameInRangeForTextRect
(
const
RawRange
&
aRawRange
)
;
struct
MOZ_STACK_CLASS
FrameRelativeRect
final
{
nsRect
mRect
;
nsIFrame
*
mBaseFrame
;
FrameRelativeRect
(
)
:
mBaseFrame
(
nullptr
)
{
}
explicit
FrameRelativeRect
(
nsIFrame
*
aBaseFrame
)
:
mBaseFrame
(
aBaseFrame
)
{
}
FrameRelativeRect
(
const
nsRect
&
aRect
nsIFrame
*
aBaseFrame
)
:
mRect
(
aRect
)
mBaseFrame
(
aBaseFrame
)
{
}
bool
IsValid
(
)
const
{
return
mBaseFrame
!
=
nullptr
;
}
nsRect
RectRelativeTo
(
nsIFrame
*
aBaseFrame
)
const
;
}
;
FrameRelativeRect
GetLineBreakerRectBefore
(
nsIFrame
*
aFrame
)
;
FrameRelativeRect
GuessLineBreakerRectAfter
(
nsIContent
*
aTextContent
)
;
FrameRelativeRect
GuessFirstCaretRectIn
(
nsIFrame
*
aFrame
)
;
void
EnsureNonEmptyRect
(
nsRect
&
aRect
)
const
;
void
EnsureNonEmptyRect
(
LayoutDeviceIntRect
&
aRect
)
const
;
}
;
}
#
endif
