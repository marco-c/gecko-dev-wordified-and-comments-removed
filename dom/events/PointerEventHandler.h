#
ifndef
mozilla_PointerEventHandler_h
#
define
mozilla_PointerEventHandler_h
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
class
nsIFrame
;
class
nsIContent
;
namespace
mozilla
{
class
PresShell
;
class
PointerCaptureInfo
final
{
public
:
nsCOMPtr
<
nsIContent
>
mPendingContent
;
nsCOMPtr
<
nsIContent
>
mOverrideContent
;
explicit
PointerCaptureInfo
(
nsIContent
*
aPendingContent
)
:
mPendingContent
(
aPendingContent
)
{
MOZ_COUNT_CTOR
(
PointerCaptureInfo
)
;
}
~
PointerCaptureInfo
(
)
{
MOZ_COUNT_DTOR
(
PointerCaptureInfo
)
;
}
bool
Empty
(
)
{
return
!
(
mPendingContent
|
|
mOverrideContent
)
;
}
}
;
class
PointerEventHandler
final
{
public
:
static
void
Initialize
(
)
;
static
void
InitializeStatics
(
)
;
static
void
ReleaseStatics
(
)
;
static
bool
IsPointerEventImplicitCaptureForTouchEnabled
(
)
;
static
void
UpdateActivePointerState
(
WidgetMouseEvent
*
aEvent
)
;
static
void
SetPointerCaptureById
(
uint32_t
aPointerId
nsIContent
*
aContent
)
;
static
void
ReleasePointerCaptureById
(
uint32_t
aPointerId
)
;
static
void
ReleaseAllPointerCapture
(
)
;
static
PointerCaptureInfo
*
GetPointerCaptureInfo
(
uint32_t
aPointerId
)
;
static
bool
GetPointerInfo
(
uint32_t
aPointerId
bool
&
aActiveState
)
;
MOZ_CAN_RUN_SCRIPT
static
void
MaybeProcessPointerCapture
(
WidgetGUIEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
ProcessPointerCaptureForMouse
(
WidgetMouseEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
ProcessPointerCaptureForTouch
(
WidgetTouchEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
CheckPointerCaptureState
(
WidgetPointerEvent
*
aEvent
)
;
static
void
ImplicitlyCapturePointer
(
nsIFrame
*
aFrame
WidgetEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
ImplicitlyReleasePointerCapture
(
WidgetEvent
*
aEvent
)
;
static
nsIContent
*
GetPointerCapturingContent
(
WidgetGUIEvent
*
aEvent
)
;
static
nsIContent
*
GetPointerCapturingContent
(
uint32_t
aPointerId
)
;
static
void
ReleaseIfCaptureByDescendant
(
nsIContent
*
aContent
)
;
static
void
PreHandlePointerEventsPreventDefault
(
WidgetPointerEvent
*
aPointerEvent
WidgetGUIEvent
*
aMouseOrTouchEvent
)
;
static
void
PostHandlePointerEventsPreventDefault
(
WidgetPointerEvent
*
aPointerEvent
WidgetGUIEvent
*
aMouseOrTouchEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
DispatchPointerFromMouseOrTouch
(
PresShell
*
aShell
nsIFrame
*
aFrame
nsIContent
*
aContent
WidgetGUIEvent
*
aEvent
bool
aDontRetargetEvents
nsEventStatus
*
aStatus
nsIContent
*
*
aTargetContent
)
;
static
void
InitPointerEventFromMouse
(
WidgetPointerEvent
*
aPointerEvent
WidgetMouseEvent
*
aMouseEvent
EventMessage
aMessage
)
;
static
void
InitPointerEventFromTouch
(
WidgetPointerEvent
*
aPointerEvent
WidgetTouchEvent
*
aTouchEvent
mozilla
:
:
dom
:
:
Touch
*
aTouch
bool
aIsPrimary
)
;
static
bool
ShouldGeneratePointerEventFromMouse
(
WidgetGUIEvent
*
aEvent
)
{
return
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
eMouseUp
|
|
aEvent
-
>
mMessage
=
=
eMouseMove
;
}
static
bool
ShouldGeneratePointerEventFromTouch
(
WidgetGUIEvent
*
aEvent
)
{
return
aEvent
-
>
mMessage
=
=
eTouchStart
|
|
aEvent
-
>
mMessage
=
=
eTouchMove
|
|
aEvent
-
>
mMessage
=
=
eTouchEnd
|
|
aEvent
-
>
mMessage
=
=
eTouchCancel
|
|
aEvent
-
>
mMessage
=
=
eTouchPointerCancel
;
}
static
MOZ_ALWAYS_INLINE
int32_t
GetSpoofedPointerIdForRFP
(
)
{
return
sSpoofedPointerId
.
valueOr
(
0
)
;
}
private
:
static
uint16_t
GetPointerType
(
uint32_t
aPointerId
)
;
static
bool
GetPointerPrimaryState
(
uint32_t
aPointerId
)
;
MOZ_CAN_RUN_SCRIPT
static
void
DispatchGotOrLostPointerCaptureEvent
(
bool
aIsGotCapture
const
WidgetPointerEvent
*
aPointerEvent
nsIContent
*
aCaptureTarget
)
;
static
Maybe
<
int32_t
>
sSpoofedPointerId
;
static
void
MaybeCacheSpoofedPointerID
(
uint16_t
aInputSource
uint32_t
aPointerId
)
;
}
;
}
#
endif
