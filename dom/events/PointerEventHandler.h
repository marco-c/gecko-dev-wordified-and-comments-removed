#
ifndef
mozilla_PointerEventHandler_h
#
define
mozilla_PointerEventHandler_h
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
class
nsIFrame
;
class
nsIContent
;
class
nsPresContext
;
namespace
mozilla
{
class
PresShell
;
namespace
dom
{
class
BrowserParent
;
class
Document
;
class
Element
;
}
;
class
PointerCaptureInfo
final
{
public
:
RefPtr
<
dom
:
:
Element
>
mPendingElement
;
RefPtr
<
dom
:
:
Element
>
mOverrideElement
;
explicit
PointerCaptureInfo
(
dom
:
:
Element
*
aPendingElement
)
:
mPendingElement
(
aPendingElement
)
{
MOZ_COUNT_CTOR
(
PointerCaptureInfo
)
;
}
MOZ_COUNTED_DTOR
(
PointerCaptureInfo
)
bool
Empty
(
)
{
return
!
(
mPendingElement
|
|
mOverrideElement
)
;
}
}
;
class
PointerInfo
final
{
public
:
uint16_t
mPointerType
;
bool
mActiveState
;
bool
mPrimaryState
;
bool
mFromTouchEvent
;
bool
mPreventMouseEventByContent
;
bool
mIsSynthesizedForTests
;
WeakPtr
<
dom
:
:
Document
>
mActiveDocument
;
explicit
PointerInfo
(
bool
aActiveState
uint16_t
aPointerType
bool
aPrimaryState
bool
aFromTouchEvent
dom
:
:
Document
*
aActiveDocument
bool
aIsSynthesizedForTests
=
false
)
:
mPointerType
(
aPointerType
)
mActiveState
(
aActiveState
)
mPrimaryState
(
aPrimaryState
)
mFromTouchEvent
(
aFromTouchEvent
)
mPreventMouseEventByContent
(
false
)
mIsSynthesizedForTests
(
aIsSynthesizedForTests
)
mActiveDocument
(
aActiveDocument
)
{
}
}
;
class
PointerEventHandler
final
{
public
:
static
void
InitializeStatics
(
)
;
static
void
ReleaseStatics
(
)
;
static
bool
IsPointerEventImplicitCaptureForTouchEnabled
(
)
;
[
[
nodiscard
]
]
static
bool
ShouldDispatchClickEventOnCapturingElement
(
const
WidgetGUIEvent
*
aSourceEvent
=
nullptr
)
;
static
void
UpdateActivePointerState
(
WidgetMouseEvent
*
aEvent
nsIContent
*
aTargetContent
=
nullptr
)
;
static
void
RequestPointerCaptureById
(
uint32_t
aPointerId
dom
:
:
Element
*
aElement
)
;
static
void
ReleasePointerCaptureById
(
uint32_t
aPointerId
)
;
static
void
ReleaseAllPointerCapture
(
)
;
static
bool
SetPointerCaptureRemoteTarget
(
uint32_t
aPointerId
dom
:
:
BrowserParent
*
aBrowserParent
)
;
static
void
ReleasePointerCaptureRemoteTarget
(
dom
:
:
BrowserParent
*
aBrowserParent
)
;
static
void
ReleasePointerCaptureRemoteTarget
(
uint32_t
aPointerId
)
;
static
void
ReleaseAllPointerCaptureRemoteTarget
(
)
;
static
dom
:
:
BrowserParent
*
GetPointerCapturingRemoteTarget
(
uint32_t
aPointerId
)
;
static
PointerCaptureInfo
*
GetPointerCaptureInfo
(
uint32_t
aPointerId
)
;
static
const
PointerInfo
*
GetPointerInfo
(
uint32_t
aPointerId
)
;
MOZ_CAN_RUN_SCRIPT
static
void
MaybeProcessPointerCapture
(
WidgetGUIEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
ProcessPointerCaptureForMouse
(
WidgetMouseEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
ProcessPointerCaptureForTouch
(
WidgetTouchEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
CheckPointerCaptureState
(
WidgetPointerEvent
*
aEvent
)
;
static
void
ImplicitlyCapturePointer
(
nsIFrame
*
aFrame
WidgetEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
ImplicitlyReleasePointerCapture
(
WidgetEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
MaybeImplicitlyReleasePointerCapture
(
WidgetGUIEvent
*
aEvent
)
;
static
dom
:
:
Element
*
GetPointerCapturingElement
(
const
WidgetGUIEvent
*
aEvent
)
;
static
dom
:
:
Element
*
GetPointerCapturingElement
(
uint32_t
aPointerId
)
;
static
dom
:
:
Element
*
GetPendingPointerCapturingElement
(
const
WidgetGUIEvent
*
aEvent
)
;
static
dom
:
:
Element
*
GetPendingPointerCapturingElement
(
uint32_t
aPointerId
)
;
[
[
nodiscard
]
]
static
RefPtr
<
dom
:
:
Element
>
GetPointerCapturingElementAtLastPointerUp
(
)
;
static
void
ReleasePointerCapturingElementAtLastPointerUp
(
)
;
static
void
ReleaseIfCaptureByDescendant
(
nsIContent
*
aContent
)
;
static
void
PreHandlePointerEventsPreventDefault
(
WidgetPointerEvent
*
aPointerEvent
WidgetGUIEvent
*
aMouseOrTouchEvent
)
;
static
void
PostHandlePointerEventsPreventDefault
(
WidgetPointerEvent
*
aPointerEvent
WidgetGUIEvent
*
aMouseOrTouchEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
DispatchPointerFromMouseOrTouch
(
PresShell
*
aShell
nsIFrame
*
aEventTargetFrame
nsIContent
*
aEventTargetContent
dom
:
:
Element
*
aPointerCapturingElement
WidgetGUIEvent
*
aMouseOrTouchEvent
bool
aDontRetargetEvents
nsEventStatus
*
aStatus
nsIContent
*
*
aMouseOrTouchEventTarget
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
static
void
SynthesizeMoveToDispatchBoundaryEvents
(
const
WidgetMouseEvent
*
aEvent
)
;
static
void
InitPointerEventFromMouse
(
WidgetPointerEvent
*
aPointerEvent
WidgetMouseEvent
*
aMouseEvent
EventMessage
aMessage
)
;
static
void
InitPointerEventFromTouch
(
WidgetPointerEvent
&
aPointerEvent
const
WidgetTouchEvent
&
aTouchEvent
const
mozilla
:
:
dom
:
:
Touch
&
aTouch
)
;
static
void
InitCoalescedEventFromPointerEvent
(
WidgetPointerEvent
&
aCoalescedEvent
const
WidgetPointerEvent
&
aSourceEvent
)
;
static
bool
ShouldGeneratePointerEventFromMouse
(
WidgetGUIEvent
*
aEvent
)
{
return
aEvent
-
>
mMessage
=
=
eMouseRawUpdate
|
|
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
eMouseUp
|
|
(
aEvent
-
>
mMessage
=
=
eMouseMove
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
IsReal
(
)
)
|
|
aEvent
-
>
mMessage
=
=
eMouseExitFromWidget
;
}
static
bool
ShouldGeneratePointerEventFromTouch
(
WidgetGUIEvent
*
aEvent
)
{
return
aEvent
-
>
mMessage
=
=
eTouchRawUpdate
|
|
aEvent
-
>
mMessage
=
=
eTouchStart
|
|
aEvent
-
>
mMessage
=
=
eTouchMove
|
|
aEvent
-
>
mMessage
=
=
eTouchEnd
|
|
aEvent
-
>
mMessage
=
=
eTouchCancel
|
|
aEvent
-
>
mMessage
=
=
eTouchPointerCancel
;
}
static
MOZ_ALWAYS_INLINE
int32_t
GetSpoofedPointerIdForRFP
(
)
{
return
sSpoofedPointerId
.
valueOr
(
0
)
;
}
static
void
NotifyDestroyPresContext
(
nsPresContext
*
aPresContext
)
;
static
bool
IsDragAndDropEnabled
(
WidgetMouseEvent
&
aEvent
)
;
[
[
nodiscard
]
]
static
EventMessage
ToPointerEventMessage
(
const
WidgetGUIEvent
*
aMouseOrTouchEvent
)
;
[
[
nodiscard
]
]
static
bool
NeedToDispatchPointerRawUpdate
(
const
dom
:
:
Document
*
aDocument
)
;
private
:
static
void
SetPointerCaptureById
(
uint32_t
aPointerId
dom
:
:
Element
*
aElement
)
;
static
uint16_t
GetPointerType
(
uint32_t
aPointerId
)
;
static
bool
GetPointerPrimaryState
(
uint32_t
aPointerId
)
;
static
bool
HasActiveTouchPointer
(
)
;
MOZ_CAN_RUN_SCRIPT
static
void
DispatchGotOrLostPointerCaptureEvent
(
bool
aIsGotCapture
const
WidgetPointerEvent
*
aPointerEvent
dom
:
:
Element
*
aCaptureTarget
)
;
enum
class
CapturingState
{
Pending
Override
}
;
static
dom
:
:
Element
*
GetPointerCapturingElementInternal
(
CapturingState
aCapturingState
const
WidgetGUIEvent
*
aEvent
)
;
static
Maybe
<
int32_t
>
sSpoofedPointerId
;
static
void
MaybeCacheSpoofedPointerID
(
uint16_t
aInputSource
uint32_t
aPointerId
)
;
static
void
SetPointerCapturingElementAtLastPointerUp
(
nsWeakPtr
&
&
aPointerCapturingElement
)
;
}
;
}
#
endif
