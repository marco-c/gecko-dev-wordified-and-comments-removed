#
ifndef
mozilla_TextComposition_h
#
define
mozilla_TextComposition_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
namespace
mozilla
{
class
EditorBase
;
class
EventDispatchingCallback
;
class
IMEStateManager
;
class
TextComposition
final
{
friend
class
IMEStateManager
;
NS_INLINE_DECL_REFCOUNTING
(
TextComposition
)
public
:
typedef
dom
:
:
TabParent
TabParent
;
typedef
dom
:
:
Text
Text
;
static
bool
IsHandlingSelectionEvent
(
)
{
return
sHandlingSelectionEvent
;
}
TextComposition
(
nsPresContext
*
aPresContext
nsINode
*
aNode
TabParent
*
aTabParent
WidgetCompositionEvent
*
aCompositionEvent
)
;
bool
Destroyed
(
)
const
{
return
!
mPresContext
;
}
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresContext
;
}
nsINode
*
GetEventTargetNode
(
)
const
{
return
mNode
;
}
Text
*
GetContainerTextNode
(
)
const
{
return
mContainerTextNode
;
}
const
nsString
&
LastData
(
)
const
{
return
mLastData
;
}
const
nsString
&
String
(
)
const
{
return
mString
;
}
TextRangeArray
*
GetLastRanges
(
)
const
{
return
mLastRanges
;
}
TextRangeArray
*
GetRanges
(
)
const
{
return
mRanges
;
}
nsIWidget
*
GetWidget
(
)
const
{
return
mPresContext
?
mPresContext
-
>
GetRootWidget
(
)
:
nullptr
;
}
TabParent
*
GetTabParent
(
)
const
{
return
mTabParent
;
}
bool
IsSynthesizedForTests
(
)
const
{
return
mIsSynthesizedForTests
;
}
const
widget
:
:
NativeIMEContext
&
GetNativeIMEContext
(
)
const
{
return
mNativeContext
;
}
void
Destroy
(
)
;
nsresult
RequestToCommit
(
nsIWidget
*
aWidget
bool
aDiscard
)
;
bool
IsRequestingCommitOrCancelComposition
(
)
const
{
return
mIsRequestingCancel
|
|
mIsRequestingCommit
;
}
nsresult
NotifyIME
(
widget
:
:
IMEMessage
aMessage
)
;
uint32_t
NativeOffsetOfStartComposition
(
)
const
{
return
mCompositionStartOffset
;
}
uint32_t
NativeOffsetOfTargetClause
(
)
const
{
return
mCompositionStartOffset
+
mTargetClauseOffsetInComposition
;
}
uint32_t
XPOffsetInTextNode
(
)
const
{
return
mCompositionStartOffsetInTextNode
;
}
uint32_t
XPLengthInTextNode
(
)
const
{
return
mCompositionLengthInTextNode
;
}
uint32_t
XPEndOffsetInTextNode
(
)
const
{
if
(
mCompositionStartOffsetInTextNode
=
=
UINT32_MAX
|
|
mCompositionLengthInTextNode
=
=
UINT32_MAX
)
{
return
UINT32_MAX
;
}
return
mCompositionStartOffsetInTextNode
+
mCompositionLengthInTextNode
;
}
bool
IsComposing
(
)
const
{
return
mIsComposing
;
}
bool
IsEditorHandlingEvent
(
)
const
{
return
mIsEditorHandlingEvent
;
}
bool
IsMovingToNewTextNode
(
)
const
{
return
!
mContainerTextNode
&
&
mCompositionLengthInTextNode
&
&
mCompositionLengthInTextNode
!
=
UINT32_MAX
;
}
void
StartHandlingComposition
(
EditorBase
*
aEditorBase
)
;
void
EndHandlingComposition
(
EditorBase
*
aEditorBase
)
;
void
OnEditorDestroyed
(
)
;
class
MOZ_STACK_CLASS
CompositionChangeEventHandlingMarker
{
public
:
CompositionChangeEventHandlingMarker
(
TextComposition
*
aComposition
const
WidgetCompositionEvent
*
aCompositionChangeEvent
)
:
mComposition
(
aComposition
)
{
mComposition
-
>
EditorWillHandleCompositionChangeEvent
(
aCompositionChangeEvent
)
;
}
~
CompositionChangeEventHandlingMarker
(
)
{
mComposition
-
>
EditorDidHandleCompositionChangeEvent
(
)
;
}
private
:
RefPtr
<
TextComposition
>
mComposition
;
CompositionChangeEventHandlingMarker
(
)
;
CompositionChangeEventHandlingMarker
(
const
CompositionChangeEventHandlingMarker
&
aOther
)
;
}
;
void
WillCreateCompositionTransaction
(
Text
*
aTextNode
uint32_t
aOffset
)
{
if
(
!
mContainerTextNode
)
{
mContainerTextNode
=
aTextNode
;
mCompositionStartOffsetInTextNode
=
aOffset
;
NS_WARNING_ASSERTION
(
mCompositionStartOffsetInTextNode
!
=
UINT32_MAX
"
The
text
node
is
really
too
long
.
"
)
;
}
#
ifdef
DEBUG
else
{
NS_WARNING_ASSERTION
(
aTextNode
=
=
mContainerTextNode
"
The
editor
tries
to
insert
composition
string
into
different
node
"
)
;
NS_WARNING_ASSERTION
(
aOffset
=
=
mCompositionStartOffsetInTextNode
"
The
editor
tries
to
insert
composition
string
into
different
offset
"
)
;
}
#
endif
if
(
mCompositionLengthInTextNode
=
=
UINT32_MAX
)
{
mCompositionLengthInTextNode
=
0
;
}
}
void
DidCreateCompositionTransaction
(
const
nsAString
&
aStringToInsert
)
{
MOZ_ASSERT
(
mCompositionStartOffsetInTextNode
!
=
UINT32_MAX
)
;
mCompositionLengthInTextNode
=
aStringToInsert
.
Length
(
)
;
NS_WARNING_ASSERTION
(
mCompositionLengthInTextNode
!
=
UINT32_MAX
"
The
string
to
insert
is
really
too
long
.
"
)
;
}
void
OnTextNodeRemoved
(
)
{
mContainerTextNode
=
nullptr
;
}
private
:
~
TextComposition
(
)
{
}
static
bool
sHandlingSelectionEvent
;
nsPresContext
*
mPresContext
;
nsCOMPtr
<
nsINode
>
mNode
;
RefPtr
<
TabParent
>
mTabParent
;
RefPtr
<
Text
>
mContainerTextNode
;
RefPtr
<
TextRangeArray
>
mRanges
;
RefPtr
<
TextRangeArray
>
mLastRanges
;
widget
:
:
NativeIMEContext
mNativeContext
;
nsWeakPtr
mEditorBaseWeak
;
nsString
mLastData
;
nsString
mString
;
uint32_t
mCompositionStartOffset
;
uint32_t
mTargetClauseOffsetInComposition
;
uint32_t
mCompositionStartOffsetInTextNode
;
uint32_t
mCompositionLengthInTextNode
;
bool
mIsSynthesizedForTests
;
bool
mIsComposing
;
bool
mIsEditorHandlingEvent
;
bool
mIsRequestingCommit
;
bool
mIsRequestingCancel
;
bool
mRequestedToCommitOrCancel
;
bool
mHasReceivedCommitEvent
;
bool
mWasNativeCompositionEndEventDiscarded
;
bool
mAllowControlCharacters
;
bool
mWasCompositionStringEmpty
;
TextComposition
(
)
:
mPresContext
(
nullptr
)
mNativeContext
(
nullptr
)
mCompositionStartOffset
(
0
)
mTargetClauseOffsetInComposition
(
0
)
mCompositionStartOffsetInTextNode
(
UINT32_MAX
)
mCompositionLengthInTextNode
(
UINT32_MAX
)
mIsSynthesizedForTests
(
false
)
mIsComposing
(
false
)
mIsEditorHandlingEvent
(
false
)
mIsRequestingCommit
(
false
)
mIsRequestingCancel
(
false
)
mRequestedToCommitOrCancel
(
false
)
mHasReceivedCommitEvent
(
false
)
mWasNativeCompositionEndEventDiscarded
(
false
)
mAllowControlCharacters
(
false
)
mWasCompositionStringEmpty
(
true
)
{
}
TextComposition
(
const
TextComposition
&
aOther
)
;
bool
CanRequsetIMEToCommitOrCancelComposition
(
)
const
{
return
!
mIsRequestingCommit
&
&
!
mIsRequestingCancel
&
&
!
mRequestedToCommitOrCancel
&
&
!
mHasReceivedCommitEvent
;
}
already_AddRefed
<
EditorBase
>
GetEditorBase
(
)
const
;
bool
HasEditor
(
)
const
;
void
EditorWillHandleCompositionChangeEvent
(
const
WidgetCompositionEvent
*
aCompositionChangeEvent
)
;
void
EditorDidHandleCompositionChangeEvent
(
)
;
bool
IsValidStateForComposition
(
nsIWidget
*
aWidget
)
const
;
void
DispatchCompositionEvent
(
WidgetCompositionEvent
*
aCompositionEvent
nsEventStatus
*
aStatus
EventDispatchingCallback
*
aCallBack
bool
aIsSynthesized
)
;
void
DispatchEvent
(
WidgetCompositionEvent
*
aDispatchEvent
nsEventStatus
*
aStatus
EventDispatchingCallback
*
aCallback
const
WidgetCompositionEvent
*
aOriginalEvent
=
nullptr
)
;
void
HandleSelectionEvent
(
WidgetSelectionEvent
*
aSelectionEvent
)
{
HandleSelectionEvent
(
mPresContext
mTabParent
aSelectionEvent
)
;
}
static
void
HandleSelectionEvent
(
nsPresContext
*
aPresContext
TabParent
*
aTabParent
WidgetSelectionEvent
*
aSelectionEvent
)
;
bool
MaybeDispatchCompositionUpdate
(
const
WidgetCompositionEvent
*
aCompositionEvent
)
;
BaseEventFlags
CloneAndDispatchAs
(
const
WidgetCompositionEvent
*
aCompositionEvent
EventMessage
aMessage
nsEventStatus
*
aStatus
=
nullptr
EventDispatchingCallback
*
aCallBack
=
nullptr
)
;
bool
WasNativeCompositionEndEventDiscarded
(
)
const
{
return
mWasNativeCompositionEndEventDiscarded
;
}
void
OnCompositionEventDiscarded
(
WidgetCompositionEvent
*
aCompositionEvent
)
;
void
OnCompositionEventDispatched
(
const
WidgetCompositionEvent
*
aDispatchEvent
)
;
void
MaybeNotifyIMEOfCompositionEventHandled
(
const
WidgetCompositionEvent
*
aCompositionEvent
)
;
uint32_t
GetSelectionStartOffset
(
)
;
void
OnStartOffsetUpdatedInChild
(
uint32_t
aStartOffset
)
;
class
CompositionEventDispatcher
:
public
Runnable
{
public
:
CompositionEventDispatcher
(
TextComposition
*
aTextComposition
nsINode
*
aEventTarget
EventMessage
aEventMessage
const
nsAString
&
aData
bool
aIsSynthesizedEvent
=
false
)
;
NS_IMETHOD
Run
(
)
override
;
private
:
RefPtr
<
TextComposition
>
mTextComposition
;
nsCOMPtr
<
nsINode
>
mEventTarget
;
nsString
mData
;
EventMessage
mEventMessage
;
bool
mIsSynthesizedEvent
;
CompositionEventDispatcher
(
)
:
Runnable
(
"
TextComposition
:
:
CompositionEventDispatcher
"
)
mIsSynthesizedEvent
(
false
)
{
}
;
}
;
void
DispatchCompositionEventRunnable
(
EventMessage
aEventMessage
const
nsAString
&
aData
bool
aIsSynthesizingCommit
=
false
)
;
}
;
class
TextCompositionArray
final
:
public
AutoTArray
<
RefPtr
<
TextComposition
>
2
>
{
public
:
index_type
IndexOf
(
const
widget
:
:
NativeIMEContext
&
aNativeIMEContext
)
;
index_type
IndexOf
(
nsIWidget
*
aWidget
)
;
TextComposition
*
GetCompositionFor
(
nsIWidget
*
aWidget
)
;
TextComposition
*
GetCompositionFor
(
const
WidgetCompositionEvent
*
aCompositionEvent
)
;
index_type
IndexOf
(
nsPresContext
*
aPresContext
)
;
index_type
IndexOf
(
nsPresContext
*
aPresContext
nsINode
*
aNode
)
;
TextComposition
*
GetCompositionFor
(
nsPresContext
*
aPresContext
)
;
TextComposition
*
GetCompositionFor
(
nsPresContext
*
aPresContext
nsINode
*
aNode
)
;
TextComposition
*
GetCompositionInContent
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
;
}
;
}
#
endif
