#
include
"
DataTransferItem
.
h
"
#
include
"
DataTransferItemList
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferItemBinding
.
h
"
#
include
"
mozilla
/
dom
/
Directory
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
FileSystem
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemDirectoryEntry
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemFileEntry
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsVariant
.
h
"
namespace
{
struct
FileMimeNameData
{
const
char
*
mMimeName
;
const
char
*
mFileName
;
}
;
FileMimeNameData
kFileMimeNameMap
[
]
=
{
{
kFileMime
"
GenericFileName
"
}
{
kPNGImageMime
"
GenericImageNamePNG
"
}
}
;
}
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
DataTransferItem
mData
mPrincipal
mDataTransfer
mCachedFile
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
DataTransferItem
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
DataTransferItem
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DataTransferItem
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
JSObject
*
DataTransferItem
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
DataTransferItemBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
DataTransferItem
>
DataTransferItem
:
:
Clone
(
DataTransfer
*
aDataTransfer
)
const
{
MOZ_ASSERT
(
aDataTransfer
)
;
RefPtr
<
DataTransferItem
>
it
=
new
DataTransferItem
(
aDataTransfer
mType
)
;
it
-
>
mKind
=
mKind
;
it
-
>
mIndex
=
mIndex
;
it
-
>
mData
=
mData
;
it
-
>
mPrincipal
=
mPrincipal
;
it
-
>
mChromeOnly
=
mChromeOnly
;
return
it
.
forget
(
)
;
}
void
DataTransferItem
:
:
SetData
(
nsIVariant
*
aData
)
{
mCachedFile
=
nullptr
;
if
(
!
aData
)
{
MOZ_ASSERT
(
!
mType
.
IsEmpty
(
)
)
;
mKind
=
KIND_STRING
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kFileMimeNameMap
)
;
+
+
i
)
{
if
(
mType
.
EqualsASCII
(
kFileMimeNameMap
[
i
]
.
mMimeName
)
)
{
mKind
=
KIND_FILE
;
break
;
}
}
mData
=
nullptr
;
return
;
}
mData
=
aData
;
mKind
=
KindFromData
(
mData
)
;
}
DataTransferItem
:
:
eKind
DataTransferItem
:
:
KindFromData
(
nsIVariant
*
aData
)
{
nsCOMPtr
<
nsISupports
>
supports
;
nsresult
rv
=
aData
-
>
GetAsISupports
(
getter_AddRefs
(
supports
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
supports
)
{
if
(
nsCOMPtr
<
nsIDOMBlob
>
(
do_QueryInterface
(
supports
)
)
|
|
nsCOMPtr
<
BlobImpl
>
(
do_QueryInterface
(
supports
)
)
|
|
nsCOMPtr
<
nsIFile
>
(
do_QueryInterface
(
supports
)
)
)
{
return
KIND_FILE
;
}
}
nsAutoString
string
;
rv
=
aData
-
>
GetAsAString
(
string
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
KIND_STRING
;
}
return
KIND_OTHER
;
}
void
DataTransferItem
:
:
FillInExternalData
(
)
{
if
(
mData
)
{
return
;
}
NS_ConvertUTF16toUTF8
utf8format
(
mType
)
;
const
char
*
format
=
utf8format
.
get
(
)
;
if
(
strcmp
(
format
"
text
/
plain
"
)
=
=
0
)
{
format
=
kUnicodeMime
;
}
else
if
(
strcmp
(
format
"
text
/
uri
-
list
"
)
=
=
0
)
{
format
=
kURLDataMime
;
}
nsCOMPtr
<
nsITransferable
>
trans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
)
;
if
(
NS_WARN_IF
(
!
trans
)
)
{
return
;
}
trans
-
>
Init
(
nullptr
)
;
trans
-
>
AddDataFlavor
(
format
)
;
if
(
mDataTransfer
-
>
GetEventMessage
(
)
=
=
ePaste
)
{
MOZ_ASSERT
(
mIndex
=
=
0
"
index
in
clipboard
must
be
0
"
)
;
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
)
;
if
(
!
clipboard
|
|
mDataTransfer
-
>
ClipboardType
(
)
<
0
)
{
return
;
}
nsresult
rv
=
clipboard
-
>
GetData
(
trans
mDataTransfer
-
>
ClipboardType
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
else
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
!
dragSession
)
{
return
;
}
nsresult
rv
=
dragSession
-
>
GetData
(
trans
mIndex
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
uint32_t
length
=
0
;
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
trans
-
>
GetTransferData
(
format
getter_AddRefs
(
data
)
&
length
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
!
data
)
)
{
return
;
}
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
eKind
oldKind
=
Kind
(
)
;
if
(
oldKind
=
=
KIND_FILE
)
{
if
(
nsCOMPtr
<
nsIInputStream
>
istream
=
do_QueryInterface
(
data
)
)
{
RefPtr
<
File
>
file
=
CreateFileFromInputStream
(
istream
)
;
if
(
NS_WARN_IF
(
!
file
)
)
{
return
;
}
data
=
do_QueryObject
(
file
)
;
}
variant
-
>
SetAsISupports
(
data
)
;
}
else
{
MOZ_ASSERT
(
oldKind
=
=
KIND_STRING
)
;
nsCOMPtr
<
nsISupportsString
>
supportsstr
=
do_QueryInterface
(
data
)
;
if
(
supportsstr
)
{
nsAutoString
str
;
supportsstr
-
>
GetData
(
str
)
;
variant
-
>
SetAsAString
(
str
)
;
}
else
{
nsCOMPtr
<
nsISupportsCString
>
supportscstr
=
do_QueryInterface
(
data
)
;
if
(
supportscstr
)
{
nsAutoCString
str
;
supportscstr
-
>
GetData
(
str
)
;
variant
-
>
SetAsACString
(
str
)
;
}
}
}
SetData
(
variant
)
;
if
(
oldKind
!
=
Kind
(
)
)
{
NS_WARNING
(
"
Clipboard
data
provided
by
the
OS
does
not
match
predicted
kind
"
)
;
mDataTransfer
-
>
TypesListMayHaveChanged
(
)
;
}
}
void
DataTransferItem
:
:
GetType
(
nsAString
&
aType
)
{
if
(
Kind
(
)
!
=
KIND_FILE
)
{
aType
=
mType
;
return
;
}
ErrorResult
rv
;
RefPtr
<
File
>
file
=
GetAsFile
(
*
nsContentUtils
:
:
GetSystemPrincipal
(
)
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Failed
to
get
file
data
with
system
principal
"
)
;
if
(
NS_WARN_IF
(
!
file
)
)
{
aType
=
mType
;
return
;
}
file
-
>
GetType
(
aType
)
;
}
already_AddRefed
<
File
>
DataTransferItem
:
:
GetAsFile
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIVariant
>
data
=
Data
(
&
aSubjectPrincipal
aRv
)
;
if
(
NS_WARN_IF
(
!
data
|
|
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
mKind
!
=
KIND_FILE
)
)
{
return
nullptr
;
}
if
(
!
mCachedFile
)
{
nsCOMPtr
<
nsISupports
>
supports
;
aRv
=
data
-
>
GetAsISupports
(
getter_AddRefs
(
supports
)
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
&
&
supports
"
File
objects
should
be
stored
as
nsISupports
variants
"
)
;
if
(
aRv
.
Failed
(
)
|
|
!
supports
)
{
return
nullptr
;
}
if
(
nsCOMPtr
<
nsIDOMBlob
>
domBlob
=
do_QueryInterface
(
supports
)
)
{
Blob
*
blob
=
static_cast
<
Blob
*
>
(
domBlob
.
get
(
)
)
;
mCachedFile
=
blob
-
>
ToFile
(
)
;
}
else
if
(
nsCOMPtr
<
BlobImpl
>
blobImpl
=
do_QueryInterface
(
supports
)
)
{
MOZ_ASSERT
(
blobImpl
-
>
IsFile
(
)
)
;
mCachedFile
=
File
:
:
Create
(
mDataTransfer
blobImpl
)
;
}
else
if
(
nsCOMPtr
<
nsIFile
>
ifile
=
do_QueryInterface
(
supports
)
)
{
mCachedFile
=
File
:
:
CreateFromFile
(
mDataTransfer
ifile
)
;
}
else
{
MOZ_ASSERT
(
false
"
One
of
the
above
code
paths
should
be
taken
"
)
;
return
nullptr
;
}
}
RefPtr
<
File
>
file
=
mCachedFile
;
return
file
.
forget
(
)
;
}
already_AddRefed
<
FileSystemEntry
>
DataTransferItem
:
:
GetAsEntry
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
RefPtr
<
File
>
file
=
GetAsFile
(
aSubjectPrincipal
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
|
|
!
file
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
;
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
mDataTransfer
-
>
GetParentObject
(
)
)
;
if
(
target
)
{
global
=
target
-
>
GetOwnerGlobal
(
)
;
}
else
{
nsCOMPtr
<
nsIDOMEvent
>
event
=
do_QueryInterface
(
mDataTransfer
-
>
GetParentObject
(
)
)
;
if
(
event
)
{
global
=
event
-
>
InternalDOMEvent
(
)
-
>
GetParentObject
(
)
;
}
}
if
(
!
global
)
{
return
nullptr
;
}
RefPtr
<
FileSystem
>
fs
=
FileSystem
:
:
Create
(
global
)
;
RefPtr
<
FileSystemEntry
>
entry
;
BlobImpl
*
impl
=
file
-
>
Impl
(
)
;
MOZ_ASSERT
(
impl
)
;
if
(
impl
-
>
IsDirectory
(
)
)
{
nsAutoString
fullpath
;
impl
-
>
GetMozFullPathInternal
(
fullpath
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
aRv
.
SuppressException
(
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIFile
>
directoryFile
;
nsresult
rv
=
NS_NewLocalFile
(
fullpath
true
getter_AddRefs
(
directoryFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
RefPtr
<
Directory
>
directory
=
Directory
:
:
Create
(
global
directoryFile
)
;
entry
=
new
FileSystemDirectoryEntry
(
global
directory
nullptr
fs
)
;
}
else
{
entry
=
new
FileSystemFileEntry
(
global
file
nullptr
fs
)
;
}
Sequence
<
RefPtr
<
FileSystemEntry
>
>
entries
;
if
(
!
entries
.
AppendElement
(
entry
fallible
)
)
{
return
nullptr
;
}
fs
-
>
CreateRoot
(
entries
)
;
return
entry
.
forget
(
)
;
}
already_AddRefed
<
File
>
DataTransferItem
:
:
CreateFileFromInputStream
(
nsIInputStream
*
aStream
)
{
const
char
*
key
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kFileMimeNameMap
)
;
+
+
i
)
{
if
(
mType
.
EqualsASCII
(
kFileMimeNameMap
[
i
]
.
mMimeName
)
)
{
key
=
kFileMimeNameMap
[
i
]
.
mFileName
;
break
;
}
}
if
(
!
key
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
mime
type
"
)
;
key
=
"
GenericFileName
"
;
}
nsXPIDLString
fileName
;
nsresult
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
key
fileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
uint64_t
available
;
rv
=
aStream
-
>
Available
(
&
available
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
void
*
data
=
nullptr
;
rv
=
NS_ReadInputStreamToBuffer
(
aStream
&
data
available
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
File
:
:
CreateMemoryFile
(
mDataTransfer
data
available
fileName
mType
PR_Now
(
)
)
;
}
void
DataTransferItem
:
:
GetAsString
(
FunctionStringCallback
*
aCallback
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
aCallback
)
{
return
;
}
nsCOMPtr
<
nsIVariant
>
data
=
Data
(
&
aSubjectPrincipal
aRv
)
;
if
(
NS_WARN_IF
(
!
data
|
|
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
NS_WARN_IF
(
mKind
!
=
KIND_STRING
)
)
{
return
;
}
nsAutoString
stringData
;
nsresult
rv
=
data
-
>
GetAsAString
(
stringData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
class
GASRunnable
final
:
public
Runnable
{
public
:
GASRunnable
(
FunctionStringCallback
*
aCallback
const
nsAString
&
aStringData
)
:
mozilla
:
:
Runnable
(
"
GASRunnable
"
)
mCallback
(
aCallback
)
mStringData
(
aStringData
)
{
}
NS_IMETHOD
Run
(
)
override
{
ErrorResult
rv
;
mCallback
-
>
Call
(
mStringData
rv
)
;
NS_WARNING_ASSERTION
(
!
rv
.
Failed
(
)
"
callback
failed
"
)
;
return
rv
.
StealNSResult
(
)
;
}
private
:
RefPtr
<
FunctionStringCallback
>
mCallback
;
nsString
mStringData
;
}
;
RefPtr
<
GASRunnable
>
runnable
=
new
GASRunnable
(
aCallback
stringData
)
;
nsISupports
*
parent
=
mDataTransfer
-
>
GetParentObject
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
parent
)
;
if
(
parent
&
&
!
global
)
{
if
(
nsCOMPtr
<
dom
:
:
EventTarget
>
target
=
do_QueryInterface
(
parent
)
)
{
global
=
target
-
>
GetOwnerGlobal
(
)
;
}
else
if
(
nsCOMPtr
<
nsIDOMEvent
>
event
=
do_QueryInterface
(
parent
)
)
{
global
=
event
-
>
InternalDOMEvent
(
)
-
>
GetParentObject
(
)
;
}
}
if
(
global
)
{
rv
=
global
-
>
Dispatch
(
"
GASRunnable
"
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
{
rv
=
NS_DispatchToMainThread
(
runnable
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Dispatch
to
main
thread
Failed
in
"
"
DataTransferItem
:
:
GetAsString
!
"
)
;
}
}
already_AddRefed
<
nsIVariant
>
DataTransferItem
:
:
DataNoSecurityCheck
(
)
{
if
(
!
mData
)
{
FillInExternalData
(
)
;
}
nsCOMPtr
<
nsIVariant
>
data
=
mData
;
return
data
.
forget
(
)
;
}
already_AddRefed
<
nsIVariant
>
DataTransferItem
:
:
Data
(
nsIPrincipal
*
aPrincipal
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aPrincipal
)
;
nsCOMPtr
<
nsIVariant
>
variant
=
DataNoSecurityCheck
(
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
variant
.
forget
(
)
;
}
MOZ_ASSERT
(
!
ChromeOnly
(
)
"
Non
-
chrome
code
shouldn
'
t
see
a
ChromeOnly
DataTransferItem
"
)
;
if
(
ChromeOnly
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
bool
checkItemPrincipal
=
mDataTransfer
-
>
IsCrossDomainSubFrameDrop
(
)
|
|
(
mDataTransfer
-
>
GetEventMessage
(
)
!
=
eDrop
&
&
mDataTransfer
-
>
GetEventMessage
(
)
!
=
ePaste
)
;
if
(
Principal
(
)
&
&
checkItemPrincipal
&
&
!
aPrincipal
-
>
Subsumes
(
Principal
(
)
)
)
{
return
nullptr
;
}
if
(
!
variant
)
{
return
nullptr
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
variant
-
>
GetAsISupports
(
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
data
)
{
nsCOMPtr
<
EventTarget
>
pt
=
do_QueryInterface
(
data
)
;
if
(
pt
)
{
nsIScriptContext
*
c
=
pt
-
>
GetContextForEventHandlers
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
!
c
)
)
{
return
nullptr
;
}
nsIGlobalObject
*
go
=
c
-
>
GetGlobalObject
(
)
;
if
(
NS_WARN_IF
(
!
go
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sp
=
do_QueryInterface
(
go
)
;
MOZ_ASSERT
(
sp
"
This
cannot
fail
on
the
main
thread
.
"
)
;
nsIPrincipal
*
dataPrincipal
=
sp
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
dataPrincipal
|
|
!
aPrincipal
-
>
Equals
(
dataPrincipal
)
)
)
{
return
nullptr
;
}
}
}
return
variant
.
forget
(
)
;
}
}
}
