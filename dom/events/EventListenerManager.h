#
ifndef
mozilla_EventListenerManager_h_
#
define
mozilla_EventListenerManager_h_
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
EventListenerBinding
.
h
"
#
include
"
mozilla
/
JSEventHandler
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsTObserverArray
.
h
"
class
nsIDocShell
;
class
nsIEventListenerInfo
;
class
nsPIDOMWindowInner
;
class
JSTracer
;
struct
EventTypeData
;
template
<
class
T
>
class
nsCOMArray
;
namespace
mozilla
{
class
ELMCreationDetector
;
class
EventListenerManager
;
namespace
dom
{
class
Event
;
class
EventTarget
;
class
Element
;
}
typedef
dom
:
:
CallbackObjectHolder
<
dom
:
:
EventListener
nsIDOMEventListener
>
EventListenerHolder
;
struct
EventListenerFlags
{
friend
class
EventListenerManager
;
private
:
bool
mListenerIsJSListener
:
1
;
public
:
bool
mCapture
:
1
;
bool
mInSystemGroup
:
1
;
bool
mAllowUntrustedEvents
:
1
;
bool
mPassive
:
1
;
bool
mOnce
:
1
;
EventListenerFlags
(
)
:
mListenerIsJSListener
(
false
)
mCapture
(
false
)
mInSystemGroup
(
false
)
mAllowUntrustedEvents
(
false
)
mPassive
(
false
)
mOnce
(
false
)
{
}
bool
EqualsForAddition
(
const
EventListenerFlags
&
aOther
)
const
{
return
(
mCapture
=
=
aOther
.
mCapture
&
&
mInSystemGroup
=
=
aOther
.
mInSystemGroup
&
&
mListenerIsJSListener
=
=
aOther
.
mListenerIsJSListener
&
&
mAllowUntrustedEvents
=
=
aOther
.
mAllowUntrustedEvents
)
;
}
bool
EqualsForRemoval
(
const
EventListenerFlags
&
aOther
)
const
{
return
(
mCapture
=
=
aOther
.
mCapture
&
&
mInSystemGroup
=
=
aOther
.
mInSystemGroup
&
&
mListenerIsJSListener
=
=
aOther
.
mListenerIsJSListener
)
;
}
}
;
inline
EventListenerFlags
TrustedEventsAtBubble
(
)
{
EventListenerFlags
flags
;
return
flags
;
}
inline
EventListenerFlags
TrustedEventsAtCapture
(
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
true
;
return
flags
;
}
inline
EventListenerFlags
AllEventsAtBubble
(
)
{
EventListenerFlags
flags
;
flags
.
mAllowUntrustedEvents
=
true
;
return
flags
;
}
inline
EventListenerFlags
AllEventsAtCapture
(
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
true
;
flags
.
mAllowUntrustedEvents
=
true
;
return
flags
;
}
inline
EventListenerFlags
TrustedEventsAtSystemGroupBubble
(
)
{
EventListenerFlags
flags
;
flags
.
mInSystemGroup
=
true
;
return
flags
;
}
inline
EventListenerFlags
TrustedEventsAtSystemGroupCapture
(
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
true
;
flags
.
mInSystemGroup
=
true
;
return
flags
;
}
inline
EventListenerFlags
AllEventsAtSystemGroupBubble
(
)
{
EventListenerFlags
flags
;
flags
.
mInSystemGroup
=
true
;
flags
.
mAllowUntrustedEvents
=
true
;
return
flags
;
}
inline
EventListenerFlags
AllEventsAtSystemGroupCapture
(
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
true
;
flags
.
mInSystemGroup
=
true
;
flags
.
mAllowUntrustedEvents
=
true
;
return
flags
;
}
class
EventListenerManagerBase
{
protected
:
EventListenerManagerBase
(
)
;
EventMessage
mNoListenerForEvent
;
uint16_t
mMayHavePaintEventListener
:
1
;
uint16_t
mMayHaveMutationListeners
:
1
;
uint16_t
mMayHaveCapturingListeners
:
1
;
uint16_t
mMayHaveSystemGroupListeners
:
1
;
uint16_t
mMayHaveTouchEventListener
:
1
;
uint16_t
mMayHaveMouseEnterLeaveEventListener
:
1
;
uint16_t
mMayHavePointerEnterLeaveEventListener
:
1
;
uint16_t
mMayHaveKeyEventListener
:
1
;
uint16_t
mMayHaveInputOrCompositionEventListener
:
1
;
uint16_t
mMayHaveSelectionChangeEventListener
:
1
;
uint16_t
mClearingListeners
:
1
;
uint16_t
mIsMainThreadELM
:
1
;
}
;
class
EventListenerManager
final
:
public
EventListenerManagerBase
{
~
EventListenerManager
(
)
;
public
:
struct
Listener
{
EventListenerHolder
mListener
;
RefPtr
<
nsAtom
>
mTypeAtom
;
nsString
mTypeString
;
EventMessage
mEventMessage
;
enum
ListenerType
:
uint8_t
{
eNoListener
eNativeListener
eJSEventListener
eWebIDLListener
}
;
ListenerType
mListenerType
;
bool
mListenerIsHandler
:
1
;
bool
mHandlerIsString
:
1
;
bool
mAllEvents
:
1
;
bool
mIsChrome
:
1
;
EventListenerFlags
mFlags
;
JSEventHandler
*
GetJSEventHandler
(
)
const
{
return
(
mListenerType
=
=
eJSEventListener
)
?
static_cast
<
JSEventHandler
*
>
(
mListener
.
GetXPCOMCallback
(
)
)
:
nullptr
;
}
Listener
(
)
:
mEventMessage
(
eVoidEvent
)
mListenerType
(
eNoListener
)
mListenerIsHandler
(
false
)
mHandlerIsString
(
false
)
mAllEvents
(
false
)
mIsChrome
(
false
)
{
}
Listener
(
Listener
&
&
aOther
)
:
mListener
(
std
:
:
move
(
aOther
.
mListener
)
)
mTypeAtom
(
aOther
.
mTypeAtom
.
forget
(
)
)
mTypeString
(
aOther
.
mTypeString
)
mEventMessage
(
aOther
.
mEventMessage
)
mListenerType
(
aOther
.
mListenerType
)
mListenerIsHandler
(
aOther
.
mListenerIsHandler
)
mHandlerIsString
(
aOther
.
mHandlerIsString
)
mAllEvents
(
aOther
.
mAllEvents
)
mIsChrome
(
aOther
.
mIsChrome
)
{
aOther
.
mTypeString
.
Truncate
(
)
;
aOther
.
mEventMessage
=
eVoidEvent
;
aOther
.
mListenerType
=
eNoListener
;
aOther
.
mListenerIsHandler
=
false
;
aOther
.
mHandlerIsString
=
false
;
aOther
.
mAllEvents
=
false
;
aOther
.
mIsChrome
=
false
;
}
~
Listener
(
)
{
if
(
(
mListenerType
=
=
eJSEventListener
)
&
&
mListener
)
{
static_cast
<
JSEventHandler
*
>
(
mListener
.
GetXPCOMCallback
(
)
)
-
>
Disconnect
(
)
;
}
}
MOZ_ALWAYS_INLINE
bool
IsListening
(
const
WidgetEvent
*
aEvent
)
const
{
if
(
mFlags
.
mInSystemGroup
!
=
aEvent
-
>
mFlags
.
mInSystemGroup
)
{
return
false
;
}
return
(
(
mFlags
.
mCapture
&
&
aEvent
-
>
mFlags
.
mInCapturePhase
)
|
|
(
!
mFlags
.
mCapture
&
&
aEvent
-
>
mFlags
.
mInBubblingPhase
)
)
;
}
}
;
explicit
EventListenerManager
(
dom
:
:
EventTarget
*
aTarget
)
;
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
EventListenerManager
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
EventListenerManager
)
void
AddEventListener
(
const
nsAString
&
aType
nsIDOMEventListener
*
aListener
bool
aUseCapture
bool
aWantsUntrusted
)
{
AddEventListener
(
aType
EventListenerHolder
(
aListener
)
aUseCapture
aWantsUntrusted
)
;
}
void
AddEventListener
(
const
nsAString
&
aType
dom
:
:
EventListener
*
aListener
const
dom
:
:
AddEventListenerOptionsOrBoolean
&
aOptions
bool
aWantsUntrusted
)
{
AddEventListener
(
aType
EventListenerHolder
(
aListener
)
aOptions
aWantsUntrusted
)
;
}
void
RemoveEventListener
(
const
nsAString
&
aType
nsIDOMEventListener
*
aListener
bool
aUseCapture
)
{
RemoveEventListener
(
aType
EventListenerHolder
(
aListener
)
aUseCapture
)
;
}
void
RemoveEventListener
(
const
nsAString
&
aType
dom
:
:
EventListener
*
aListener
const
dom
:
:
EventListenerOptionsOrBoolean
&
aOptions
)
{
RemoveEventListener
(
aType
EventListenerHolder
(
aListener
)
aOptions
)
;
}
void
AddListenerForAllEvents
(
dom
:
:
EventListener
*
aListener
bool
aUseCapture
bool
aWantsUntrusted
bool
aSystemEventGroup
)
;
void
RemoveListenerForAllEvents
(
dom
:
:
EventListener
*
aListener
bool
aUseCapture
bool
aSystemEventGroup
)
;
void
AddEventListenerByType
(
nsIDOMEventListener
*
aListener
const
nsAString
&
type
const
EventListenerFlags
&
aFlags
)
{
AddEventListenerByType
(
EventListenerHolder
(
aListener
)
type
aFlags
)
;
}
void
AddEventListenerByType
(
dom
:
:
EventListener
*
aListener
const
nsAString
&
type
const
EventListenerFlags
&
aFlags
)
{
AddEventListenerByType
(
EventListenerHolder
(
aListener
)
type
aFlags
)
;
}
void
AddEventListenerByType
(
EventListenerHolder
aListener
const
nsAString
&
type
const
EventListenerFlags
&
aFlags
const
dom
:
:
Optional
<
bool
>
&
aPassive
=
dom
:
:
Optional
<
bool
>
(
)
)
;
void
RemoveEventListenerByType
(
nsIDOMEventListener
*
aListener
const
nsAString
&
type
const
EventListenerFlags
&
aFlags
)
{
RemoveEventListenerByType
(
EventListenerHolder
(
aListener
)
type
aFlags
)
;
}
void
RemoveEventListenerByType
(
dom
:
:
EventListener
*
aListener
const
nsAString
&
type
const
EventListenerFlags
&
aFlags
)
{
RemoveEventListenerByType
(
EventListenerHolder
(
aListener
)
type
aFlags
)
;
}
void
RemoveEventListenerByType
(
EventListenerHolder
aListener
const
nsAString
&
type
const
EventListenerFlags
&
aFlags
)
;
nsresult
SetEventHandler
(
nsAtom
*
aName
const
nsAString
&
aFunc
bool
aDeferCompilation
bool
aPermitUntrustedEvents
dom
:
:
Element
*
aElement
)
;
void
RemoveEventHandler
(
nsAtom
*
aName
const
nsAString
&
aTypeString
)
;
void
HandleEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
dom
:
:
Event
*
*
aDOMEvent
dom
:
:
EventTarget
*
aCurrentTarget
nsEventStatus
*
aEventStatus
bool
aItemInShadowTree
)
{
if
(
mListeners
.
IsEmpty
(
)
|
|
aEvent
-
>
PropagationStopped
(
)
)
{
return
;
}
if
(
!
mMayHaveCapturingListeners
&
&
!
aEvent
-
>
mFlags
.
mInBubblingPhase
)
{
return
;
}
if
(
!
mMayHaveSystemGroupListeners
&
&
aEvent
-
>
mFlags
.
mInSystemGroup
)
{
return
;
}
if
(
mNoListenerForEvent
=
=
aEvent
-
>
mMessage
&
&
(
mNoListenerForEvent
!
=
eUnidentifiedEvent
|
|
mNoListenerForEventAtom
=
=
aEvent
-
>
mSpecifiedEventType
)
)
{
return
;
}
HandleEventInternal
(
aPresContext
aEvent
aDOMEvent
aCurrentTarget
aEventStatus
aItemInShadowTree
)
;
}
void
Disconnect
(
)
;
bool
HasMutationListeners
(
)
;
bool
HasUnloadListeners
(
)
;
uint32_t
MutationListenerBits
(
)
;
bool
HasListenersFor
(
const
nsAString
&
aEventName
)
const
;
bool
HasListenersFor
(
nsAtom
*
aEventNameWithOn
)
const
;
bool
HasListeners
(
)
const
;
nsresult
GetListenerInfo
(
nsCOMArray
<
nsIEventListenerInfo
>
*
aList
)
;
uint32_t
GetIdentifierForEvent
(
nsAtom
*
aEvent
)
;
static
void
Shutdown
(
)
;
bool
MayHavePaintEventListener
(
)
{
return
mMayHavePaintEventListener
;
}
bool
MayHaveTouchEventListener
(
)
{
return
mMayHaveTouchEventListener
;
}
bool
MayHaveMouseEnterLeaveEventListener
(
)
{
return
mMayHaveMouseEnterLeaveEventListener
;
}
bool
MayHavePointerEnterLeaveEventListener
(
)
{
return
mMayHavePointerEnterLeaveEventListener
;
}
bool
MayHaveSelectionChangeEventListener
(
)
{
return
mMayHaveSelectionChangeEventListener
;
}
bool
MayHaveKeyEventListener
(
)
{
return
mMayHaveKeyEventListener
;
}
bool
MayHaveInputOrCompositionEventListener
(
)
{
return
mMayHaveInputOrCompositionEventListener
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
;
uint32_t
ListenerCount
(
)
const
{
return
mListeners
.
Length
(
)
;
}
void
MarkForCC
(
)
;
void
TraceListeners
(
JSTracer
*
aTrc
)
;
dom
:
:
EventTarget
*
GetTarget
(
)
{
return
mTarget
;
}
bool
HasNonSystemGroupListenersForUntrustedKeyEvents
(
)
;
bool
HasNonPassiveNonSystemGroupListenersForUntrustedKeyEvents
(
)
;
bool
HasApzAwareListeners
(
)
;
bool
IsApzAwareListener
(
Listener
*
aListener
)
;
bool
IsApzAwareEvent
(
nsAtom
*
aEvent
)
;
protected
:
void
HandleEventInternal
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
dom
:
:
Event
*
*
aDOMEvent
dom
:
:
EventTarget
*
aCurrentTarget
nsEventStatus
*
aEventStatus
bool
aItemInShadowTree
)
;
nsresult
HandleEventSubType
(
Listener
*
aListener
dom
:
:
Event
*
aDOMEvent
dom
:
:
EventTarget
*
aCurrentTarget
)
;
EventMessage
GetLegacyEventMessage
(
EventMessage
aEventMessage
)
const
;
void
ProcessApzAwareEventListenerAdd
(
)
;
nsresult
CompileEventHandlerInternal
(
Listener
*
aListener
const
nsAString
*
aBody
dom
:
:
Element
*
aElement
)
;
Listener
*
FindEventHandler
(
EventMessage
aEventMessage
nsAtom
*
aTypeAtom
const
nsAString
&
aTypeString
)
;
Listener
*
SetEventHandlerInternal
(
nsAtom
*
aName
const
nsAString
&
aTypeString
const
TypedEventHandler
&
aHandler
bool
aPermitUntrustedEvents
)
;
bool
IsDeviceType
(
EventMessage
aEventMessage
)
;
void
EnableDevice
(
EventMessage
aEventMessage
)
;
void
DisableDevice
(
EventMessage
aEventMessage
)
;
public
:
void
SetEventHandler
(
nsAtom
*
aEventName
const
nsAString
&
aTypeString
dom
:
:
EventHandlerNonNull
*
aHandler
)
;
void
SetEventHandler
(
dom
:
:
OnErrorEventHandlerNonNull
*
aHandler
)
;
void
SetEventHandler
(
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
aHandler
)
;
dom
:
:
EventHandlerNonNull
*
GetEventHandler
(
nsAtom
*
aEventName
const
nsAString
&
aTypeString
)
{
const
TypedEventHandler
*
typedHandler
=
GetTypedEventHandler
(
aEventName
aTypeString
)
;
return
typedHandler
?
typedHandler
-
>
NormalEventHandler
(
)
:
nullptr
;
}
dom
:
:
OnErrorEventHandlerNonNull
*
GetOnErrorEventHandler
(
)
{
const
TypedEventHandler
*
typedHandler
=
mIsMainThreadELM
?
GetTypedEventHandler
(
nsGkAtoms
:
:
onerror
EmptyString
(
)
)
:
GetTypedEventHandler
(
nullptr
NS_LITERAL_STRING
(
"
error
"
)
)
;
return
typedHandler
?
typedHandler
-
>
OnErrorEventHandler
(
)
:
nullptr
;
}
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
GetOnBeforeUnloadEventHandler
(
)
{
const
TypedEventHandler
*
typedHandler
=
GetTypedEventHandler
(
nsGkAtoms
:
:
onbeforeunload
EmptyString
(
)
)
;
return
typedHandler
?
typedHandler
-
>
OnBeforeUnloadEventHandler
(
)
:
nullptr
;
}
private
:
already_AddRefed
<
nsPIDOMWindowInner
>
WindowFromListener
(
Listener
*
aListener
bool
aItemInShadowTree
)
;
protected
:
const
TypedEventHandler
*
GetTypedEventHandler
(
nsAtom
*
aEventName
const
nsAString
&
aTypeString
)
;
void
AddEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListener
const
dom
:
:
AddEventListenerOptionsOrBoolean
&
aOptions
bool
aWantsUntrusted
)
;
void
AddEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListener
bool
aUseCapture
bool
aWantsUntrusted
)
;
void
RemoveEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListener
const
dom
:
:
EventListenerOptionsOrBoolean
&
aOptions
)
;
void
RemoveEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListener
bool
aUseCapture
)
;
void
AddEventListenerInternal
(
EventListenerHolder
aListener
EventMessage
aEventMessage
nsAtom
*
aTypeAtom
const
nsAString
&
aTypeString
const
EventListenerFlags
&
aFlags
bool
aHandler
=
false
bool
aAllEvents
=
false
)
;
void
RemoveEventListenerInternal
(
EventListenerHolder
aListener
EventMessage
aEventMessage
nsAtom
*
aUserType
const
nsAString
&
aTypeString
const
EventListenerFlags
&
aFlags
bool
aAllEvents
=
false
)
;
void
RemoveAllListeners
(
)
;
void
NotifyEventListenerRemoved
(
nsAtom
*
aUserType
const
nsAString
&
aTypeString
)
;
const
EventTypeData
*
GetTypeDataForIID
(
const
nsIID
&
aIID
)
;
const
EventTypeData
*
GetTypeDataForEventName
(
nsAtom
*
aName
)
;
nsPIDOMWindowInner
*
GetInnerWindowForTarget
(
)
;
already_AddRefed
<
nsPIDOMWindowInner
>
GetTargetAsInnerWindow
(
)
const
;
bool
ListenerCanHandle
(
const
Listener
*
aListener
const
WidgetEvent
*
aEvent
EventMessage
aEventMessage
)
const
;
already_AddRefed
<
nsIScriptGlobalObject
>
GetScriptGlobalAndDocument
(
nsIDocument
*
*
aDoc
)
;
nsAutoTObserverArray
<
Listener
2
>
mListeners
;
dom
:
:
EventTarget
*
MOZ_NON_OWNING_REF
mTarget
;
RefPtr
<
nsAtom
>
mNoListenerForEventAtom
;
friend
class
ELMCreationDetector
;
static
uint32_t
sMainThreadCreatedCount
;
}
;
}
#
endif
