#
include
"
EventStateManager
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PointerLockManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
FrameLoaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventHandler
.
h
"
#
include
"
mozilla
/
dom
/
UIEvent
.
h
"
#
include
"
mozilla
/
dom
/
UIEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
WheelEventBinding
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_mousewheel
.
h
"
#
include
"
mozilla
/
StaticPrefs_plugin
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
StaticPrefs_zoom
.
h
"
#
include
"
ContentEventHandler
.
h
"
#
include
"
IMEContentObserver
.
h
"
#
include
"
WheelHandlingHelper
.
h
"
#
include
"
RemoteDragStartData
.
h
"
#
include
"
nsCommandParams
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIDOMXULControlElement
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsIBrowserChild
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIDragSession
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
nsContentAreaDragDrop
.
h
"
#
include
"
nsTreeBodyFrame
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElement
.
h
"
#
include
"
mozilla
/
dom
/
Record
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
Units
.
h
"
#
ifdef
XP_MACOSX
#
import
<
ApplicationServices
/
ApplicationServices
.
h
>
#
endif
namespace
mozilla
{
using
namespace
dom
;
static
const
LayoutDeviceIntPoint
kInvalidRefPoint
=
LayoutDeviceIntPoint
(
-
1
-
1
)
;
static
uint32_t
gMouseOrKeyboardEventCounter
=
0
;
static
nsITimer
*
gUserInteractionTimer
=
nullptr
;
static
nsITimerCallback
*
gUserInteractionTimerCallback
=
nullptr
;
static
const
double
kCursorLoadingTimeout
=
1000
;
static
AutoWeakFrame
gLastCursorSourceFrame
;
static
TimeStamp
gLastCursorUpdateTime
;
static
TimeStamp
gTypingStartTime
;
static
TimeStamp
gTypingEndTime
;
static
int32_t
gTypingInteractionKeyPresses
=
0
;
static
dom
:
:
InteractionData
gTypingInteraction
=
{
}
;
static
inline
int32_t
RoundDown
(
double
aDouble
)
{
return
(
aDouble
>
0
)
?
static_cast
<
int32_t
>
(
floor
(
aDouble
)
)
:
static_cast
<
int32_t
>
(
ceil
(
aDouble
)
)
;
}
static
UniquePtr
<
WidgetMouseEvent
>
CreateMouseOrPointerWidgetEvent
(
WidgetMouseEvent
*
aMouseEvent
EventMessage
aMessage
EventTarget
*
aRelatedTarget
)
;
class
UITimerCallback
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
UITimerCallback
(
)
:
mPreviousCount
(
0
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
private
:
~
UITimerCallback
(
)
=
default
;
uint32_t
mPreviousCount
;
}
;
NS_IMPL_ISUPPORTS
(
UITimerCallback
nsITimerCallback
nsINamed
)
NS_IMETHODIMP
UITimerCallback
:
:
Notify
(
nsITimer
*
aTimer
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
obs
)
return
NS_ERROR_FAILURE
;
if
(
(
gMouseOrKeyboardEventCounter
=
=
mPreviousCount
)
|
|
!
aTimer
)
{
gMouseOrKeyboardEventCounter
=
0
;
obs
-
>
NotifyObservers
(
nullptr
"
user
-
interaction
-
inactive
"
nullptr
)
;
if
(
gUserInteractionTimer
)
{
gUserInteractionTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
gUserInteractionTimer
)
;
}
}
else
{
obs
-
>
NotifyObservers
(
nullptr
"
user
-
interaction
-
active
"
nullptr
)
;
EventStateManager
:
:
UpdateUserActivityTimer
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
hal
:
:
BatteryInformation
batteryInfo
;
hal
:
:
GetCurrentBatteryInformation
(
&
batteryInfo
)
;
glean
:
:
power_battery
:
:
percentage_when_user_active
.
AccumulateSamples
(
{
uint64_t
(
batteryInfo
.
level
(
)
*
100
)
}
)
;
}
}
mPreviousCount
=
gMouseOrKeyboardEventCounter
;
return
NS_OK
;
}
NS_IMETHODIMP
UITimerCallback
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
UITimerCallback_timer
"
)
;
return
NS_OK
;
}
OverOutElementsWrapper
:
:
OverOutElementsWrapper
(
)
:
mLastOverFrame
(
nullptr
)
{
}
OverOutElementsWrapper
:
:
~
OverOutElementsWrapper
(
)
=
default
;
NS_IMPL_CYCLE_COLLECTION
(
OverOutElementsWrapper
mLastOverElement
mFirstOverEventElement
mFirstOutEventElement
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
OverOutElementsWrapper
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
OverOutElementsWrapper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
OverOutElementsWrapper
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
static
uint32_t
sESMInstanceCount
=
0
;
bool
EventStateManager
:
:
sNormalLMouseEventInProcess
=
false
;
int16_t
EventStateManager
:
:
sCurrentMouseBtn
=
MouseButton
:
:
eNotPressed
;
EventStateManager
*
EventStateManager
:
:
sActiveESM
=
nullptr
;
Document
*
EventStateManager
:
:
sMouseOverDocument
=
nullptr
;
AutoWeakFrame
EventStateManager
:
:
sLastDragOverFrame
=
nullptr
;
LayoutDeviceIntPoint
EventStateManager
:
:
sPreLockPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
LayoutDeviceIntPoint
EventStateManager
:
:
sLastRefPoint
=
kInvalidRefPoint
;
CSSIntPoint
EventStateManager
:
:
sLastScreenPoint
=
CSSIntPoint
(
0
0
)
;
LayoutDeviceIntPoint
EventStateManager
:
:
sSynthCenteringPoint
=
kInvalidRefPoint
;
CSSIntPoint
EventStateManager
:
:
sLastClientPoint
=
CSSIntPoint
(
0
0
)
;
nsCOMPtr
<
nsIContent
>
EventStateManager
:
:
sDragOverContent
=
nullptr
;
EventStateManager
:
:
WheelPrefs
*
EventStateManager
:
:
WheelPrefs
:
:
sInstance
=
nullptr
;
EventStateManager
:
:
DeltaAccumulator
*
EventStateManager
:
:
DeltaAccumulator
:
:
sInstance
=
nullptr
;
constexpr
const
StyleCursorKind
kInvalidCursorKind
=
static_cast
<
StyleCursorKind
>
(
255
)
;
EventStateManager
:
:
EventStateManager
(
)
:
mLockCursor
(
kInvalidCursorKind
)
mLastFrameConsumedSetCursor
(
false
)
mCurrentTarget
(
nullptr
)
mGestureDownPoint
(
0
0
)
mGestureModifiers
(
0
)
mGestureDownButtons
(
0
)
mPresContext
(
nullptr
)
mLClickCount
(
0
)
mMClickCount
(
0
)
mRClickCount
(
0
)
mShouldAlwaysUseLineDeltas
(
false
)
mShouldAlwaysUseLineDeltasInitialized
(
false
)
mGestureDownInTextControl
(
false
)
mInTouchDrag
(
false
)
m_haveShutdown
(
false
)
{
if
(
sESMInstanceCount
=
=
0
)
{
gUserInteractionTimerCallback
=
new
UITimerCallback
(
)
;
if
(
gUserInteractionTimerCallback
)
NS_ADDREF
(
gUserInteractionTimerCallback
)
;
UpdateUserActivityTimer
(
)
;
}
+
+
sESMInstanceCount
;
}
nsresult
EventStateManager
:
:
UpdateUserActivityTimer
(
)
{
if
(
!
gUserInteractionTimerCallback
)
return
NS_OK
;
if
(
!
gUserInteractionTimer
)
{
gUserInteractionTimer
=
NS_NewTimer
(
)
.
take
(
)
;
}
if
(
gUserInteractionTimer
)
{
gUserInteractionTimer
-
>
InitWithCallback
(
gUserInteractionTimerCallback
StaticPrefs
:
:
dom_events_user_interaction_interval
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
return
NS_OK
;
}
nsresult
EventStateManager
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
return
NS_ERROR_FAILURE
;
observerService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
;
return
NS_OK
;
}
bool
EventStateManager
:
:
ShouldAlwaysUseLineDeltas
(
)
{
if
(
MOZ_UNLIKELY
(
!
mShouldAlwaysUseLineDeltasInitialized
)
)
{
mShouldAlwaysUseLineDeltasInitialized
=
true
;
mShouldAlwaysUseLineDeltas
=
!
StaticPrefs
:
:
dom_event_wheel_deltaMode_lines_disabled
(
)
;
if
(
!
mShouldAlwaysUseLineDeltas
&
&
mDocument
)
{
if
(
nsIPrincipal
*
principal
=
mDocument
-
>
GetPrincipalForPrefBasedHacks
(
)
)
{
mShouldAlwaysUseLineDeltas
=
principal
-
>
IsURIInPrefList
(
"
dom
.
event
.
wheel
-
deltaMode
-
lines
.
always
-
enabled
"
)
;
}
}
}
return
mShouldAlwaysUseLineDeltas
;
}
EventStateManager
:
:
~
EventStateManager
(
)
{
ReleaseCurrentIMEContentObserver
(
)
;
if
(
sActiveESM
=
=
this
)
{
sActiveESM
=
nullptr
;
}
if
(
StaticPrefs
:
:
ui_click_hold_context_menus
(
)
)
{
KillClickHoldTimer
(
)
;
}
if
(
mDocument
=
=
sMouseOverDocument
)
{
sMouseOverDocument
=
nullptr
;
}
-
-
sESMInstanceCount
;
if
(
sESMInstanceCount
=
=
0
)
{
WheelTransaction
:
:
Shutdown
(
)
;
if
(
gUserInteractionTimerCallback
)
{
gUserInteractionTimerCallback
-
>
Notify
(
nullptr
)
;
NS_RELEASE
(
gUserInteractionTimerCallback
)
;
}
if
(
gUserInteractionTimer
)
{
gUserInteractionTimer
-
>
Cancel
(
)
;
NS_RELEASE
(
gUserInteractionTimer
)
;
}
WheelPrefs
:
:
Shutdown
(
)
;
DeltaAccumulator
:
:
Shutdown
(
)
;
}
if
(
sDragOverContent
&
&
sDragOverContent
-
>
OwnerDoc
(
)
=
=
mDocument
)
{
sDragOverContent
=
nullptr
;
}
if
(
!
m_haveShutdown
)
{
Shutdown
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
}
}
nsresult
EventStateManager
:
:
Shutdown
(
)
{
m_haveShutdown
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
EventStateManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
Shutdown
(
)
;
}
return
NS_OK
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
EventStateManager
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
EventStateManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
EventStateManager
)
NS_IMPL_CYCLE_COLLECTION_WEAK
(
EventStateManager
mCurrentTargetContent
mGestureDownContent
mGestureDownFrameOwner
mLastLeftMouseDownContent
mLastMiddleMouseDownContent
mLastRightMouseDownContent
mActiveContent
mHoverContent
mURLTargetContent
mMouseEnterLeaveHelper
mPointersEnterLeaveHelper
mDocument
mIMEContentObserver
mAccessKeys
)
void
EventStateManager
:
:
ReleaseCurrentIMEContentObserver
(
)
{
if
(
mIMEContentObserver
)
{
mIMEContentObserver
-
>
DisconnectFromEventStateManager
(
)
;
}
mIMEContentObserver
=
nullptr
;
}
void
EventStateManager
:
:
OnStartToObserveContent
(
IMEContentObserver
*
aIMEContentObserver
)
{
if
(
mIMEContentObserver
=
=
aIMEContentObserver
)
{
return
;
}
ReleaseCurrentIMEContentObserver
(
)
;
mIMEContentObserver
=
aIMEContentObserver
;
}
void
EventStateManager
:
:
OnStopObservingContent
(
IMEContentObserver
*
aIMEContentObserver
)
{
aIMEContentObserver
-
>
DisconnectFromEventStateManager
(
)
;
NS_ENSURE_TRUE_VOID
(
mIMEContentObserver
=
=
aIMEContentObserver
)
;
mIMEContentObserver
=
nullptr
;
}
void
EventStateManager
:
:
TryToFlushPendingNotificationsToIME
(
)
{
if
(
mIMEContentObserver
)
{
mIMEContentObserver
-
>
TryToFlushPendingNotifications
(
true
)
;
}
}
static
bool
IsMessageMouseUserActivity
(
EventMessage
aMessage
)
{
return
aMessage
=
=
eMouseMove
|
|
aMessage
=
=
eMouseUp
|
|
aMessage
=
=
eMouseDown
|
|
aMessage
=
=
eMouseAuxClick
|
|
aMessage
=
=
eMouseDoubleClick
|
|
aMessage
=
=
eMouseClick
|
|
aMessage
=
=
eMouseActivate
|
|
aMessage
=
=
eMouseLongTap
;
}
static
bool
IsMessageGamepadUserActivity
(
EventMessage
aMessage
)
{
return
aMessage
=
=
eGamepadButtonDown
|
|
aMessage
=
=
eGamepadButtonUp
|
|
aMessage
=
=
eGamepadAxisMove
;
}
bool
EventStateManager
:
:
IsKeyboardEventUserActivity
(
WidgetEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
keyEvent
-
>
ModifiersMatchWithAccessKey
(
AccessKeyType
:
:
eContent
)
)
{
return
true
;
}
if
(
!
keyEvent
-
>
CanTreatAsUserInput
(
)
|
|
keyEvent
-
>
IsControl
(
)
|
|
keyEvent
-
>
IsMeta
(
)
|
|
keyEvent
-
>
IsOS
(
)
|
|
keyEvent
-
>
IsAlt
(
)
)
{
return
false
;
}
switch
(
keyEvent
-
>
mKeyNameIndex
)
{
case
KEY_NAME_INDEX_F1
:
case
KEY_NAME_INDEX_F2
:
case
KEY_NAME_INDEX_F3
:
case
KEY_NAME_INDEX_F4
:
case
KEY_NAME_INDEX_F5
:
case
KEY_NAME_INDEX_F6
:
case
KEY_NAME_INDEX_F7
:
case
KEY_NAME_INDEX_F8
:
case
KEY_NAME_INDEX_F9
:
case
KEY_NAME_INDEX_F10
:
case
KEY_NAME_INDEX_F11
:
case
KEY_NAME_INDEX_F12
:
case
KEY_NAME_INDEX_F13
:
case
KEY_NAME_INDEX_F14
:
case
KEY_NAME_INDEX_F15
:
case
KEY_NAME_INDEX_F16
:
case
KEY_NAME_INDEX_F17
:
case
KEY_NAME_INDEX_F18
:
case
KEY_NAME_INDEX_F19
:
case
KEY_NAME_INDEX_F20
:
case
KEY_NAME_INDEX_F21
:
case
KEY_NAME_INDEX_F22
:
case
KEY_NAME_INDEX_F23
:
case
KEY_NAME_INDEX_F24
:
return
false
;
default
:
return
true
;
}
}
static
void
OnTypingInteractionEnded
(
)
{
if
(
gTypingInteractionKeyPresses
>
1
)
{
gTypingInteraction
.
mInteractionCount
+
=
gTypingInteractionKeyPresses
;
gTypingInteraction
.
mInteractionTimeInMilliseconds
+
=
static_cast
<
uint32_t
>
(
std
:
:
ceil
(
(
gTypingEndTime
-
gTypingStartTime
)
.
ToMilliseconds
(
)
)
)
;
}
gTypingInteractionKeyPresses
=
0
;
gTypingStartTime
=
TimeStamp
(
)
;
gTypingEndTime
=
TimeStamp
(
)
;
}
static
void
HandleKeyUpInteraction
(
WidgetKeyboardEvent
*
aKeyEvent
)
{
if
(
EventStateManager
:
:
IsKeyboardEventUserActivity
(
aKeyEvent
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
gTypingEndTime
.
IsNull
(
)
)
{
gTypingEndTime
=
now
;
}
TimeDuration
delay
=
now
-
gTypingEndTime
;
if
(
gTypingInteractionKeyPresses
>
0
&
&
delay
>
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
browser_places_interactions_typing_timeout_ms
(
)
)
)
{
OnTypingInteractionEnded
(
)
;
}
gTypingInteractionKeyPresses
+
+
;
if
(
gTypingStartTime
.
IsNull
(
)
)
{
gTypingStartTime
=
now
;
}
gTypingEndTime
=
now
;
}
}
nsresult
EventStateManager
:
:
PreHandleEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIFrame
*
aTargetFrame
nsIContent
*
aTargetContent
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
{
NS_ENSURE_ARG_POINTER
(
aStatus
)
;
NS_ENSURE_ARG
(
aPresContext
)
;
if
(
!
aEvent
)
{
NS_ERROR
(
"
aEvent
is
null
.
This
should
never
happen
.
"
)
;
return
NS_ERROR_NULL_POINTER
;
}
NS_WARNING_ASSERTION
(
!
aTargetFrame
|
|
!
aTargetFrame
-
>
GetContent
(
)
|
|
aTargetFrame
-
>
GetContent
(
)
=
=
aTargetContent
|
|
aTargetFrame
-
>
GetContent
(
)
-
>
GetFlattenedTreeParent
(
)
=
=
aTargetContent
|
|
aTargetFrame
-
>
IsGeneratedContentFrame
(
)
"
aTargetFrame
should
be
related
with
aTargetContent
"
)
;
#
if
DEBUG
if
(
aTargetFrame
&
&
aTargetFrame
-
>
IsGeneratedContentFrame
(
)
)
{
nsCOMPtr
<
nsIContent
>
targetContent
;
aTargetFrame
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
targetContent
)
)
;
MOZ_ASSERT
(
aTargetContent
=
=
targetContent
"
Unexpected
target
for
generated
content
frame
!
"
)
;
}
#
endif
mCurrentTarget
=
aTargetFrame
;
mCurrentTargetContent
=
nullptr
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
aEvent
-
>
IsTrusted
(
)
&
&
(
(
mouseEvent
&
&
mouseEvent
-
>
IsReal
(
)
&
&
IsMessageMouseUserActivity
(
mouseEvent
-
>
mMessage
)
)
|
|
aEvent
-
>
mClass
=
=
eWheelEventClass
|
|
aEvent
-
>
mClass
=
=
ePointerEventClass
|
|
aEvent
-
>
mClass
=
=
eTouchEventClass
|
|
aEvent
-
>
mClass
=
=
eKeyboardEventClass
|
|
(
aEvent
-
>
mClass
=
=
eDragEventClass
&
&
aEvent
-
>
mMessage
=
=
eDrop
)
|
|
IsMessageGamepadUserActivity
(
aEvent
-
>
mMessage
)
)
)
{
if
(
gMouseOrKeyboardEventCounter
=
=
0
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
user
-
interaction
-
active
"
nullptr
)
;
UpdateUserActivityTimer
(
)
;
}
}
+
+
gMouseOrKeyboardEventCounter
;
nsCOMPtr
<
nsINode
>
node
=
aTargetContent
;
if
(
node
&
&
(
(
aEvent
-
>
mMessage
=
=
eKeyUp
&
&
IsKeyboardEventUserActivity
(
aEvent
)
)
|
|
aEvent
-
>
mMessage
=
=
eMouseUp
|
|
aEvent
-
>
mMessage
=
=
eWheel
|
|
aEvent
-
>
mMessage
=
=
eTouchEnd
|
|
aEvent
-
>
mMessage
=
=
ePointerUp
|
|
aEvent
-
>
mMessage
=
=
eDrop
)
)
{
Document
*
doc
=
node
-
>
OwnerDoc
(
)
;
while
(
doc
)
{
doc
-
>
SetUserHasInteracted
(
)
;
doc
=
nsContentUtils
:
:
IsChildOfSameType
(
doc
)
?
doc
-
>
GetInProcessParentDocument
(
)
:
nullptr
;
}
}
}
WheelTransaction
:
:
OnEvent
(
aEvent
)
;
if
(
!
mCurrentTarget
&
&
!
aTargetContent
)
{
NS_ERROR
(
"
mCurrentTarget
and
aTargetContent
are
null
"
)
;
return
NS_ERROR_NULL_POINTER
;
}
#
ifdef
DEBUG
if
(
aEvent
-
>
HasDragEventMessage
(
)
&
&
PointerLockManager
:
:
IsLocked
(
)
)
{
NS_ASSERTION
(
PointerLockManager
:
:
IsLocked
(
)
"
Pointer
is
locked
.
Drag
events
should
be
suppressed
when
"
"
the
pointer
is
locked
.
"
)
;
}
#
endif
if
(
aEvent
-
>
IsTrusted
(
)
&
&
(
(
mouseEvent
&
&
mouseEvent
-
>
IsReal
(
)
)
|
|
aEvent
-
>
mClass
=
=
eWheelEventClass
)
&
&
!
PointerLockManager
:
:
IsLocked
(
)
)
{
sLastScreenPoint
=
Event
:
:
GetScreenCoords
(
aPresContext
aEvent
aEvent
-
>
mRefPoint
)
.
extract
(
)
;
sLastClientPoint
=
Event
:
:
GetClientCoords
(
aPresContext
aEvent
aEvent
-
>
mRefPoint
CSSIntPoint
(
0
0
)
)
;
}
*
aStatus
=
nsEventStatus_eIgnore
;
if
(
aEvent
-
>
mClass
=
=
eQueryContentEventClass
)
{
HandleQueryContentEvent
(
aEvent
-
>
AsQueryContentEvent
(
)
)
;
return
NS_OK
;
}
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
if
(
touchEvent
&
&
mInTouchDrag
)
{
if
(
touchEvent
-
>
mMessage
=
=
eTouchMove
)
{
GenerateDragGesture
(
aPresContext
touchEvent
)
;
}
else
{
mInTouchDrag
=
false
;
StopTrackingDragGesture
(
true
)
;
}
}
switch
(
aEvent
-
>
mMessage
)
{
case
eContextMenu
:
if
(
PointerLockManager
:
:
IsLocked
(
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
break
;
case
eMouseTouchDrag
:
mInTouchDrag
=
true
;
BeginTrackingDragGesture
(
aPresContext
mouseEvent
aTargetFrame
)
;
break
;
case
eMouseDown
:
{
switch
(
mouseEvent
-
>
mButton
)
{
case
MouseButton
:
:
ePrimary
:
BeginTrackingDragGesture
(
aPresContext
mouseEvent
aTargetFrame
)
;
mLClickCount
=
mouseEvent
-
>
mClickCount
;
SetClickCount
(
mouseEvent
aStatus
)
;
sNormalLMouseEventInProcess
=
true
;
break
;
case
MouseButton
:
:
eMiddle
:
mMClickCount
=
mouseEvent
-
>
mClickCount
;
SetClickCount
(
mouseEvent
aStatus
)
;
break
;
case
MouseButton
:
:
eSecondary
:
mRClickCount
=
mouseEvent
-
>
mClickCount
;
SetClickCount
(
mouseEvent
aStatus
)
;
break
;
}
NotifyTargetUserActivation
(
aEvent
aTargetContent
)
;
break
;
}
case
eMouseUp
:
{
switch
(
mouseEvent
-
>
mButton
)
{
case
MouseButton
:
:
ePrimary
:
if
(
StaticPrefs
:
:
ui_click_hold_context_menus
(
)
)
{
KillClickHoldTimer
(
)
;
}
mInTouchDrag
=
false
;
StopTrackingDragGesture
(
true
)
;
sNormalLMouseEventInProcess
=
false
;
[
[
fallthrough
]
]
;
case
MouseButton
:
:
eSecondary
:
case
MouseButton
:
:
eMiddle
:
RefPtr
<
EventStateManager
>
esm
=
ESMFromContentOrThis
(
aOverrideClickTarget
)
;
esm
-
>
SetClickCount
(
mouseEvent
aStatus
aOverrideClickTarget
)
;
break
;
}
break
;
}
case
eMouseEnterIntoWidget
:
PointerEventHandler
:
:
UpdateActivePointerState
(
mouseEvent
aTargetContent
)
;
aEvent
-
>
StopCrossProcessForwarding
(
)
;
break
;
case
eMouseExitFromWidget
:
if
(
XRE_IsContentProcess
(
)
)
{
ClearCachedWidgetCursor
(
mCurrentTarget
)
;
}
aEvent
-
>
StopCrossProcessForwarding
(
)
;
if
(
mouseEvent
-
>
mExitFrom
.
value
(
)
!
=
WidgetMouseEvent
:
:
ePlatformTopLevel
&
&
mouseEvent
-
>
mExitFrom
.
value
(
)
!
=
WidgetMouseEvent
:
:
ePuppet
)
{
mouseEvent
-
>
mMessage
=
eMouseMove
;
mouseEvent
-
>
mReason
=
WidgetMouseEvent
:
:
eSynthesized
;
}
else
{
MOZ_ASSERT_IF
(
XRE_IsParentProcess
(
)
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePlatformTopLevel
)
;
MOZ_ASSERT_IF
(
XRE_IsContentProcess
(
)
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePuppet
)
;
GeneratePointerEnterExit
(
ePointerLeave
mouseEvent
)
;
GenerateMouseEnterExit
(
mouseEvent
)
;
aEvent
-
>
mMessage
=
eVoidEvent
;
break
;
}
[
[
fallthrough
]
]
;
case
eMouseMove
:
case
ePointerDown
:
if
(
aEvent
-
>
mMessage
=
=
ePointerDown
)
{
PointerEventHandler
:
:
UpdateActivePointerState
(
mouseEvent
aTargetContent
)
;
PointerEventHandler
:
:
ImplicitlyCapturePointer
(
aTargetFrame
aEvent
)
;
if
(
mouseEvent
-
>
mInputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
NotifyTargetUserActivation
(
aEvent
aTargetContent
)
;
}
}
[
[
fallthrough
]
]
;
case
ePointerMove
:
{
if
(
!
mInTouchDrag
&
&
PointerEventHandler
:
:
IsDragAndDropEnabled
(
*
mouseEvent
)
)
{
GenerateDragGesture
(
aPresContext
mouseEvent
)
;
}
UpdateCursor
(
aPresContext
aEvent
mCurrentTarget
aStatus
)
;
UpdateLastRefPointOfMouseEvent
(
mouseEvent
)
;
if
(
PointerLockManager
:
:
IsLocked
(
)
)
{
ResetPointerToWindowCenterWhilePointerLocked
(
mouseEvent
)
;
}
UpdateLastPointerPosition
(
mouseEvent
)
;
GenerateMouseEnterExit
(
mouseEvent
)
;
FlushLayout
(
aPresContext
)
;
break
;
}
case
ePointerGotCapture
:
GenerateMouseEnterExit
(
mouseEvent
)
;
break
;
case
eDragStart
:
if
(
StaticPrefs
:
:
ui_click_hold_context_menus
(
)
)
{
KillClickHoldTimer
(
)
;
}
break
;
case
eDragOver
:
{
WidgetDragEvent
*
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
MOZ_ASSERT
(
dragEvent
)
;
if
(
dragEvent
-
>
mFlags
.
mIsSynthesizedForTests
)
{
dragEvent
-
>
InitDropEffectForTests
(
)
;
}
GenerateDragDropEnterExit
(
aPresContext
dragEvent
)
;
break
;
}
case
eDrop
:
if
(
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
)
{
MOZ_ASSERT
(
aEvent
-
>
AsDragEvent
(
)
)
;
aEvent
-
>
AsDragEvent
(
)
-
>
InitDropEffectForTests
(
)
;
}
break
;
case
eKeyPress
:
{
WidgetKeyboardEvent
*
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
keyEvent
-
>
ModifiersMatchWithAccessKey
(
AccessKeyType
:
:
eChrome
)
|
|
keyEvent
-
>
ModifiersMatchWithAccessKey
(
AccessKeyType
:
:
eContent
)
)
{
if
(
IsTopLevelRemoteTarget
(
GetFocusedElement
(
)
)
)
{
if
(
CheckIfEventMatchesAccessKey
(
keyEvent
aPresContext
)
)
{
keyEvent
-
>
StopPropagation
(
)
;
keyEvent
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
}
}
else
{
AutoTArray
<
uint32_t
10
>
accessCharCodes
;
keyEvent
-
>
GetAccessKeyCandidates
(
accessCharCodes
)
;
if
(
HandleAccessKey
(
keyEvent
aPresContext
accessCharCodes
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
}
}
[
[
fallthrough
]
]
;
case
eKeyDown
:
if
(
aEvent
-
>
mMessage
=
=
eKeyDown
)
{
NotifyTargetUserActivation
(
aEvent
aTargetContent
)
;
}
[
[
fallthrough
]
]
;
case
eKeyUp
:
{
Element
*
element
=
GetFocusedElement
(
)
;
if
(
element
)
{
mCurrentTargetContent
=
element
;
}
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
aPresContext
)
;
aEvent
-
>
AsKeyboardEvent
(
)
-
>
mIsComposing
=
!
!
composition
;
if
(
aEvent
-
>
IsWaitingReplyFromRemoteProcess
(
)
&
&
!
aEvent
-
>
PropagationStopped
(
)
&
&
!
IsTopLevelRemoteTarget
(
element
)
)
{
aEvent
-
>
ResetWaitingReplyFromRemoteProcessState
(
)
;
}
}
break
;
case
eWheel
:
case
eWheelOperationStart
:
case
eWheelOperationEnd
:
{
NS_ASSERTION
(
aEvent
-
>
IsTrusted
(
)
"
Untrusted
wheel
event
shouldn
'
t
be
here
"
)
;
using
DeltaModeCheckingState
=
WidgetWheelEvent
:
:
DeltaModeCheckingState
;
if
(
Element
*
element
=
GetFocusedElement
(
)
)
{
mCurrentTargetContent
=
element
;
}
if
(
aEvent
-
>
mMessage
!
=
eWheel
)
{
break
;
}
WidgetWheelEvent
*
wheelEvent
=
aEvent
-
>
AsWheelEvent
(
)
;
WheelPrefs
:
:
GetInstance
(
)
-
>
ApplyUserPrefsToDelta
(
wheelEvent
)
;
if
(
!
wheelEvent
-
>
IsAllowedToDispatchDOMEvent
(
)
)
{
break
;
}
if
(
StaticPrefs
:
:
dom_event_wheel_deltaMode_lines_always_disabled
(
)
)
{
wheelEvent
-
>
mDeltaModeCheckingState
=
DeltaModeCheckingState
:
:
Unchecked
;
}
else
if
(
ShouldAlwaysUseLineDeltas
(
)
)
{
wheelEvent
-
>
mDeltaModeCheckingState
=
DeltaModeCheckingState
:
:
Checked
;
}
else
{
wheelEvent
-
>
mDeltaModeCheckingState
=
DeltaModeCheckingState
:
:
Unknown
;
}
DeltaAccumulator
:
:
GetInstance
(
)
-
>
InitLineOrPageDelta
(
aTargetFrame
this
wheelEvent
)
;
}
break
;
case
eSetSelection
:
{
RefPtr
<
Element
>
focuedElement
=
GetFocusedElement
(
)
;
IMEStateManager
:
:
HandleSelectionEvent
(
aPresContext
focuedElement
aEvent
-
>
AsSelectionEvent
(
)
)
;
break
;
}
case
eContentCommandCut
:
case
eContentCommandCopy
:
case
eContentCommandPaste
:
case
eContentCommandDelete
:
case
eContentCommandUndo
:
case
eContentCommandRedo
:
case
eContentCommandPasteTransferable
:
case
eContentCommandLookUpDictionary
:
DoContentCommandEvent
(
aEvent
-
>
AsContentCommandEvent
(
)
)
;
break
;
case
eContentCommandInsertText
:
DoContentCommandInsertTextEvent
(
aEvent
-
>
AsContentCommandEvent
(
)
)
;
break
;
case
eContentCommandScroll
:
DoContentCommandScrollEvent
(
aEvent
-
>
AsContentCommandEvent
(
)
)
;
break
;
case
eCompositionStart
:
if
(
aEvent
-
>
IsTrusted
(
)
)
{
WidgetCompositionEvent
*
compositionEvent
=
aEvent
-
>
AsCompositionEvent
(
)
;
WidgetQueryContentEvent
querySelectedTextEvent
(
true
eQuerySelectedText
compositionEvent
-
>
mWidget
)
;
HandleQueryContentEvent
(
&
querySelectedTextEvent
)
;
if
(
querySelectedTextEvent
.
FoundSelection
(
)
)
{
compositionEvent
-
>
mData
=
querySelectedTextEvent
.
mReply
-
>
DataRef
(
)
;
}
NS_ASSERTION
(
querySelectedTextEvent
.
Succeeded
(
)
"
Failed
to
get
selected
text
"
)
;
}
break
;
case
eTouchStart
:
SetGestureDownPoint
(
aEvent
-
>
AsTouchEvent
(
)
)
;
break
;
case
eTouchEnd
:
NotifyTargetUserActivation
(
aEvent
aTargetContent
)
;
break
;
default
:
break
;
}
return
NS_OK
;
}
void
EventStateManager
:
:
NotifyTargetUserActivation
(
WidgetEvent
*
aEvent
nsIContent
*
aTargetContent
)
{
if
(
!
aEvent
-
>
IsTrusted
(
)
)
{
return
;
}
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
!
mouseEvent
-
>
IsReal
(
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
node
=
aTargetContent
;
if
(
!
node
)
{
return
;
}
Document
*
doc
=
node
-
>
OwnerDoc
(
)
;
if
(
!
doc
)
{
return
;
}
WidgetKeyboardEvent
*
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
keyEvent
&
&
!
keyEvent
-
>
CanUserGestureActivateTarget
(
)
)
{
return
;
}
if
(
aEvent
-
>
mMessage
=
=
eTouchEnd
&
&
aEvent
-
>
AsTouchEvent
(
)
&
&
IsEventOutsideDragThreshold
(
aEvent
-
>
AsTouchEvent
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
aEvent
-
>
mMessage
=
=
eKeyDown
|
|
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
ePointerDown
|
|
aEvent
-
>
mMessage
=
=
eTouchEnd
)
;
doc
-
>
NotifyUserGestureActivation
(
)
;
}
already_AddRefed
<
EventStateManager
>
EventStateManager
:
:
ESMFromContentOrThis
(
nsIContent
*
aContent
)
{
if
(
aContent
)
{
PresShell
*
presShell
=
aContent
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
nsPresContext
*
prescontext
=
presShell
-
>
GetPresContext
(
)
;
if
(
prescontext
)
{
RefPtr
<
EventStateManager
>
esm
=
prescontext
-
>
EventStateManager
(
)
;
if
(
esm
)
{
return
esm
.
forget
(
)
;
}
}
}
}
RefPtr
<
EventStateManager
>
esm
=
this
;
return
esm
.
forget
(
)
;
}
void
EventStateManager
:
:
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eQuerySelectedText
:
case
eQueryTextContent
:
case
eQueryCaretRect
:
case
eQueryTextRect
:
case
eQueryEditorRect
:
if
(
!
IsTargetCrossProcess
(
aEvent
)
)
{
break
;
}
GetCrossProcessTarget
(
)
-
>
HandleQueryContentEvent
(
*
aEvent
)
;
return
;
case
eQueryContentState
:
case
eQuerySelectionAsTransferable
:
case
eQueryCharacterAtPoint
:
case
eQueryDOMWidgetHittest
:
case
eQueryTextRectArray
:
break
;
default
:
return
;
}
if
(
mIMEContentObserver
)
{
RefPtr
<
IMEContentObserver
>
contentObserver
=
mIMEContentObserver
;
contentObserver
-
>
HandleQueryContentEvent
(
aEvent
)
;
return
;
}
ContentEventHandler
handler
(
mPresContext
)
;
handler
.
HandleQueryContentEvent
(
aEvent
)
;
}
static
AccessKeyType
GetAccessKeyTypeFor
(
nsISupports
*
aDocShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
do_QueryInterface
(
aDocShell
)
)
;
if
(
!
treeItem
)
{
return
AccessKeyType
:
:
eNone
;
}
switch
(
treeItem
-
>
ItemType
(
)
)
{
case
nsIDocShellTreeItem
:
:
typeChrome
:
return
AccessKeyType
:
:
eChrome
;
case
nsIDocShellTreeItem
:
:
typeContent
:
return
AccessKeyType
:
:
eContent
;
default
:
return
AccessKeyType
:
:
eNone
;
}
}
static
bool
IsAccessKeyTarget
(
Element
*
aElement
nsAString
&
aKey
)
{
nsString
contentKey
;
if
(
!
aElement
|
|
!
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
contentKey
)
|
|
!
contentKey
.
Equals
(
aKey
nsCaseInsensitiveStringComparator
)
)
{
return
false
;
}
if
(
!
aElement
-
>
IsXULElement
(
)
)
{
return
true
;
}
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
false
;
}
if
(
frame
-
>
IsFocusable
(
)
)
{
return
true
;
}
if
(
!
frame
-
>
IsVisibleConsideringAncestors
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDOMXULControlElement
>
control
=
aElement
-
>
AsXULControl
(
)
;
if
(
control
)
{
return
true
;
}
if
(
aElement
-
>
IsXULElement
(
nsGkAtoms
:
:
label
)
)
{
return
true
;
}
return
false
;
}
bool
EventStateManager
:
:
CheckIfEventMatchesAccessKey
(
WidgetKeyboardEvent
*
aEvent
nsPresContext
*
aPresContext
)
{
AutoTArray
<
uint32_t
10
>
accessCharCodes
;
aEvent
-
>
GetAccessKeyCandidates
(
accessCharCodes
)
;
return
WalkESMTreeToHandleAccessKey
(
aEvent
aPresContext
accessCharCodes
nullptr
eAccessKeyProcessingNormal
false
)
;
}
bool
EventStateManager
:
:
LookForAccessKeyAndExecute
(
nsTArray
<
uint32_t
>
&
aAccessCharCodes
bool
aIsTrustedEvent
bool
aIsRepeat
bool
aExecute
)
{
int32_t
count
start
=
-
1
;
if
(
Element
*
focusedElement
=
GetFocusedElement
(
)
)
{
start
=
mAccessKeys
.
IndexOf
(
focusedElement
)
;
if
(
start
=
=
-
1
&
&
focusedElement
-
>
IsInNativeAnonymousSubtree
(
)
)
{
start
=
mAccessKeys
.
IndexOf
(
Element
:
:
FromNodeOrNull
(
focusedElement
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
)
;
}
}
RefPtr
<
Element
>
element
;
int32_t
length
=
mAccessKeys
.
Count
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aAccessCharCodes
.
Length
(
)
;
+
+
i
)
{
uint32_t
ch
=
aAccessCharCodes
[
i
]
;
nsAutoString
accessKey
;
AppendUCS4ToUTF16
(
ch
accessKey
)
;
for
(
count
=
1
;
count
<
=
length
;
+
+
count
)
{
MOZ_DIAGNOSTIC_ASSERT
(
length
=
=
mAccessKeys
.
Count
(
)
)
;
element
=
mAccessKeys
[
(
start
+
count
)
%
length
]
;
if
(
IsAccessKeyTarget
(
element
accessKey
)
)
{
if
(
!
aExecute
)
{
return
true
;
}
Document
*
doc
=
element
-
>
OwnerDoc
(
)
;
const
bool
shouldActivate
=
[
&
]
{
if
(
!
StaticPrefs
:
:
accessibility_accesskeycausesactivation
(
)
)
{
return
false
;
}
if
(
aIsRepeat
&
&
nsContentUtils
:
:
IsChromeDoc
(
doc
)
)
{
return
false
;
}
int32_t
j
=
0
;
while
(
+
+
j
<
length
)
{
Element
*
el
=
mAccessKeys
[
(
start
+
count
+
j
)
%
length
]
;
if
(
IsAccessKeyTarget
(
el
accessKey
)
)
{
return
false
;
}
}
return
true
;
}
(
)
;
if
(
aIsTrustedEvent
)
{
doc
-
>
NotifyUserGestureActivation
(
)
;
}
auto
result
=
element
-
>
PerformAccesskey
(
shouldActivate
aIsTrustedEvent
)
;
if
(
result
.
isOk
(
)
)
{
if
(
result
.
unwrap
(
)
&
&
aIsTrustedEvent
)
{
nsIDocShell
*
docShell
=
mPresContext
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIBrowserChild
>
child
=
docShell
?
docShell
-
>
GetBrowserChild
(
)
:
nullptr
;
if
(
child
)
{
child
-
>
SendRequestFocus
(
false
CallerType
:
:
System
)
;
}
}
return
true
;
}
}
}
}
return
false
;
}
void
EventStateManager
:
:
GetAccessKeyLabelPrefix
(
Element
*
aElement
nsAString
&
aPrefix
)
{
aPrefix
.
Truncate
(
)
;
nsAutoString
separator
modifierText
;
nsContentUtils
:
:
GetModifierSeparatorText
(
separator
)
;
AccessKeyType
accessKeyType
=
GetAccessKeyTypeFor
(
aElement
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
)
;
if
(
accessKeyType
=
=
AccessKeyType
:
:
eNone
)
{
return
;
}
Modifiers
modifiers
=
WidgetKeyboardEvent
:
:
AccessKeyModifiers
(
accessKeyType
)
;
if
(
modifiers
=
=
MODIFIER_NONE
)
{
return
;
}
if
(
modifiers
&
MODIFIER_CONTROL
)
{
nsContentUtils
:
:
GetControlText
(
modifierText
)
;
aPrefix
.
Append
(
modifierText
+
separator
)
;
}
if
(
modifiers
&
MODIFIER_META
)
{
nsContentUtils
:
:
GetMetaText
(
modifierText
)
;
aPrefix
.
Append
(
modifierText
+
separator
)
;
}
if
(
modifiers
&
MODIFIER_OS
)
{
nsContentUtils
:
:
GetOSText
(
modifierText
)
;
aPrefix
.
Append
(
modifierText
+
separator
)
;
}
if
(
modifiers
&
MODIFIER_ALT
)
{
nsContentUtils
:
:
GetAltText
(
modifierText
)
;
aPrefix
.
Append
(
modifierText
+
separator
)
;
}
if
(
modifiers
&
MODIFIER_SHIFT
)
{
nsContentUtils
:
:
GetShiftText
(
modifierText
)
;
aPrefix
.
Append
(
modifierText
+
separator
)
;
}
}
struct
MOZ_STACK_CLASS
AccessKeyInfo
{
WidgetKeyboardEvent
*
event
;
nsTArray
<
uint32_t
>
&
charCodes
;
AccessKeyInfo
(
WidgetKeyboardEvent
*
aEvent
nsTArray
<
uint32_t
>
&
aCharCodes
)
:
event
(
aEvent
)
charCodes
(
aCharCodes
)
{
}
}
;
bool
EventStateManager
:
:
WalkESMTreeToHandleAccessKey
(
WidgetKeyboardEvent
*
aEvent
nsPresContext
*
aPresContext
nsTArray
<
uint32_t
>
&
aAccessCharCodes
nsIDocShellTreeItem
*
aBubbledFrom
ProcessingAccessKeyState
aAccessKeyState
bool
aExecute
)
{
EnsureDocument
(
mPresContext
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
aPresContext
-
>
GetDocShell
(
)
;
if
(
NS_WARN_IF
(
!
docShell
)
|
|
NS_WARN_IF
(
!
mDocument
)
)
{
return
false
;
}
AccessKeyType
accessKeyType
=
GetAccessKeyTypeFor
(
docShell
)
;
if
(
accessKeyType
=
=
AccessKeyType
:
:
eNone
)
{
return
false
;
}
if
(
mAccessKeys
.
Count
(
)
>
0
&
&
aEvent
-
>
ModifiersMatchWithAccessKey
(
accessKeyType
)
)
{
if
(
LookForAccessKeyAndExecute
(
aAccessCharCodes
aEvent
-
>
IsTrusted
(
)
aEvent
-
>
mIsRepeat
aExecute
)
)
{
return
true
;
}
}
int32_t
childCount
;
docShell
-
>
GetInProcessChildCount
(
&
childCount
)
;
for
(
int32_t
counter
=
0
;
counter
<
childCount
;
counter
+
+
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
subShellItem
;
docShell
-
>
GetInProcessChildAt
(
counter
getter_AddRefs
(
subShellItem
)
)
;
if
(
aAccessKeyState
=
=
eAccessKeyProcessingUp
&
&
subShellItem
=
=
aBubbledFrom
)
{
continue
;
}
nsCOMPtr
<
nsIDocShell
>
subDS
=
do_QueryInterface
(
subShellItem
)
;
if
(
subDS
&
&
IsShellVisible
(
subDS
)
)
{
RefPtr
<
PresShell
>
subPresShell
=
subDS
-
>
GetPresShell
(
)
;
if
(
!
subPresShell
)
{
continue
;
}
RefPtr
<
nsPresContext
>
subPresContext
=
subPresShell
-
>
GetPresContext
(
)
;
RefPtr
<
EventStateManager
>
esm
=
static_cast
<
EventStateManager
*
>
(
subPresContext
-
>
EventStateManager
(
)
)
;
if
(
esm
&
&
esm
-
>
WalkESMTreeToHandleAccessKey
(
aEvent
subPresContext
aAccessCharCodes
nullptr
eAccessKeyProcessingDown
aExecute
)
)
{
return
true
;
}
}
}
if
(
eAccessKeyProcessingDown
!
=
aAccessKeyState
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentShellItem
;
docShell
-
>
GetInProcessParent
(
getter_AddRefs
(
parentShellItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
parentDS
=
do_QueryInterface
(
parentShellItem
)
;
if
(
parentDS
)
{
RefPtr
<
PresShell
>
parentPresShell
=
parentDS
-
>
GetPresShell
(
)
;
NS_ASSERTION
(
parentPresShell
"
Our
PresShell
exists
but
the
parent
'
s
does
not
?
"
)
;
RefPtr
<
nsPresContext
>
parentPresContext
=
parentPresShell
-
>
GetPresContext
(
)
;
NS_ASSERTION
(
parentPresContext
"
PresShell
without
PresContext
"
)
;
RefPtr
<
EventStateManager
>
esm
=
static_cast
<
EventStateManager
*
>
(
parentPresContext
-
>
EventStateManager
(
)
)
;
if
(
esm
&
&
esm
-
>
WalkESMTreeToHandleAccessKey
(
aEvent
parentPresContext
aAccessCharCodes
docShell
eAccessKeyProcessingDown
aExecute
)
)
{
return
true
;
}
}
}
if
(
aExecute
&
&
aEvent
-
>
ModifiersMatchWithAccessKey
(
AccessKeyType
:
:
eContent
)
&
&
mDocument
&
&
mDocument
-
>
GetWindow
(
)
)
{
if
(
BrowserParent
:
:
GetFrom
(
GetFocusedElement
(
)
)
)
{
MOZ_ASSERT
(
aEvent
-
>
IsHandledInRemoteProcess
(
)
|
|
!
aEvent
-
>
IsWaitingReplyFromRemoteProcess
(
)
)
;
}
else
if
(
!
aEvent
-
>
IsHandledInRemoteProcess
(
)
)
{
AccessKeyInfo
accessKeyInfo
(
aEvent
aAccessCharCodes
)
;
nsContentUtils
:
:
CallOnAllRemoteChildren
(
mDocument
-
>
GetWindow
(
)
[
&
accessKeyInfo
]
(
BrowserParent
*
aBrowserParent
)
-
>
CallState
{
if
(
aBrowserParent
-
>
GetDocShellIsActive
(
)
)
{
accessKeyInfo
.
event
-
>
StopPropagation
(
)
;
accessKeyInfo
.
event
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
aBrowserParent
-
>
HandleAccessKey
(
*
accessKeyInfo
.
event
accessKeyInfo
.
charCodes
)
;
return
CallState
:
:
Stop
;
}
return
CallState
:
:
Continue
;
}
)
;
}
}
return
false
;
}
static
BrowserParent
*
GetBrowserParentAncestor
(
BrowserParent
*
aBrowserParent
)
{
MOZ_ASSERT
(
aBrowserParent
)
;
BrowserBridgeParent
*
bbp
=
aBrowserParent
-
>
GetBrowserBridgeParent
(
)
;
if
(
!
bbp
)
{
return
nullptr
;
}
return
bbp
-
>
Manager
(
)
;
}
static
void
DispatchCrossProcessMouseExitEvents
(
WidgetMouseEvent
*
aMouseEvent
BrowserParent
*
aRemoteTarget
BrowserParent
*
aStopAncestor
bool
aIsReallyExit
)
{
MOZ_ASSERT
(
aMouseEvent
)
;
MOZ_ASSERT
(
aRemoteTarget
)
;
MOZ_ASSERT
(
aRemoteTarget
!
=
aStopAncestor
)
;
MOZ_ASSERT_IF
(
aStopAncestor
nsContentUtils
:
:
GetCommonBrowserParentAncestor
(
aRemoteTarget
aStopAncestor
)
)
;
while
(
aRemoteTarget
!
=
aStopAncestor
)
{
UniquePtr
<
WidgetMouseEvent
>
mouseExitEvent
=
CreateMouseOrPointerWidgetEvent
(
aMouseEvent
eMouseExitFromWidget
aMouseEvent
-
>
mRelatedTarget
)
;
mouseExitEvent
-
>
mExitFrom
=
Some
(
aIsReallyExit
?
WidgetMouseEvent
:
:
ePuppet
:
WidgetMouseEvent
:
:
ePuppetParentToPuppetChild
)
;
aRemoteTarget
-
>
SendRealMouseEvent
(
*
mouseExitEvent
)
;
aRemoteTarget
=
GetBrowserParentAncestor
(
aRemoteTarget
)
;
}
}
void
EventStateManager
:
:
DispatchCrossProcessEvent
(
WidgetEvent
*
aEvent
BrowserParent
*
aRemoteTarget
nsEventStatus
*
aStatus
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aRemoteTarget
)
;
MOZ_ASSERT
(
aStatus
)
;
BrowserParent
*
remote
=
aRemoteTarget
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
bool
isContextMenuKey
=
mouseEvent
&
&
mouseEvent
-
>
IsContextMenuKeyEvent
(
)
;
if
(
aEvent
-
>
mClass
=
=
eKeyboardEventClass
|
|
isContextMenuKey
)
{
BrowserParent
*
preciseRemote
=
BrowserParent
:
:
GetFocused
(
)
;
if
(
preciseRemote
)
{
remote
=
preciseRemote
;
}
}
else
if
(
aEvent
-
>
mLayersId
.
IsValid
(
)
)
{
BrowserParent
*
preciseRemote
=
BrowserParent
:
:
GetBrowserParentFromLayersId
(
aEvent
-
>
mLayersId
)
;
if
(
preciseRemote
)
{
remote
=
preciseRemote
;
}
}
switch
(
aEvent
-
>
mClass
)
{
case
eMouseEventClass
:
{
BrowserParent
*
oldRemote
=
BrowserParent
:
:
GetLastMouseRemoteTarget
(
)
;
if
(
mouseEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
{
MOZ_ASSERT
(
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePuppet
)
;
MOZ_ASSERT
(
mouseEvent
-
>
mReason
=
=
WidgetMouseEvent
:
:
eReal
)
;
MOZ_ASSERT
(
!
mouseEvent
-
>
mLayersId
.
IsValid
(
)
)
;
MOZ_ASSERT
(
remote
-
>
GetBrowserHost
(
)
)
;
if
(
oldRemote
&
&
oldRemote
!
=
remote
)
{
Unused
<
<
NS_WARN_IF
(
nsContentUtils
:
:
GetCommonBrowserParentAncestor
(
remote
oldRemote
)
!
=
remote
)
;
remote
=
oldRemote
;
}
DispatchCrossProcessMouseExitEvents
(
mouseEvent
remote
nullptr
true
)
;
return
;
}
if
(
BrowserParent
*
pointerLockedRemote
=
PointerLockManager
:
:
GetLockedRemoteTarget
(
)
)
{
remote
=
pointerLockedRemote
;
}
else
if
(
BrowserParent
*
pointerCapturedRemote
=
PointerEventHandler
:
:
GetPointerCapturingRemoteTarget
(
mouseEvent
-
>
pointerId
)
)
{
remote
=
pointerCapturedRemote
;
}
else
if
(
BrowserParent
*
capturingRemote
=
PresShell
:
:
GetCapturingRemoteTarget
(
)
)
{
remote
=
capturingRemote
;
}
if
(
mouseEvent
-
>
mReason
=
=
WidgetMouseEvent
:
:
eReal
&
&
remote
!
=
oldRemote
)
{
MOZ_ASSERT
(
mouseEvent
-
>
mMessage
!
=
eMouseExitFromWidget
)
;
if
(
oldRemote
)
{
BrowserParent
*
commonAncestor
=
nsContentUtils
:
:
GetCommonBrowserParentAncestor
(
remote
oldRemote
)
;
if
(
commonAncestor
=
=
oldRemote
)
{
DispatchCrossProcessMouseExitEvents
(
mouseEvent
GetBrowserParentAncestor
(
remote
)
GetBrowserParentAncestor
(
commonAncestor
)
false
)
;
}
else
if
(
commonAncestor
=
=
remote
)
{
DispatchCrossProcessMouseExitEvents
(
mouseEvent
oldRemote
commonAncestor
true
)
;
}
else
{
DispatchCrossProcessMouseExitEvents
(
mouseEvent
oldRemote
commonAncestor
true
)
;
if
(
commonAncestor
)
{
UniquePtr
<
WidgetMouseEvent
>
mouseExitEvent
=
CreateMouseOrPointerWidgetEvent
(
mouseEvent
eMouseExitFromWidget
mouseEvent
-
>
mRelatedTarget
)
;
mouseExitEvent
-
>
mExitFrom
=
Some
(
WidgetMouseEvent
:
:
ePuppetParentToPuppetChild
)
;
commonAncestor
-
>
SendRealMouseEvent
(
*
mouseExitEvent
)
;
}
}
}
if
(
mouseEvent
-
>
mMessage
!
=
eMouseExitFromWidget
&
&
mouseEvent
-
>
mMessage
!
=
eMouseEnterIntoWidget
)
{
remote
-
>
MouseEnterIntoWidget
(
)
;
}
}
remote
-
>
SendRealMouseEvent
(
*
mouseEvent
)
;
return
;
}
case
eKeyboardEventClass
:
{
auto
*
keyboardEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
aEvent
-
>
mMessage
=
=
eKeyUp
)
{
HandleKeyUpInteraction
(
keyboardEvent
)
;
}
remote
-
>
SendRealKeyEvent
(
*
keyboardEvent
)
;
return
;
}
case
eWheelEventClass
:
{
if
(
BrowserParent
*
pointerLockedRemote
=
PointerLockManager
:
:
GetLockedRemoteTarget
(
)
)
{
remote
=
pointerLockedRemote
;
}
remote
-
>
SendMouseWheelEvent
(
*
aEvent
-
>
AsWheelEvent
(
)
)
;
return
;
}
case
eTouchEventClass
:
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
remote
-
>
SendRealTouchEvent
(
*
aEvent
-
>
AsTouchEvent
(
)
)
;
return
;
}
case
eDragEventClass
:
{
RefPtr
<
BrowserParent
>
browserParent
=
remote
;
browserParent
-
>
Manager
(
)
-
>
MaybeInvokeDragSession
(
browserParent
)
;
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
uint32_t
dropEffect
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
uint32_t
action
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
if
(
dragSession
)
{
dragSession
-
>
DragEventDispatchedToChildProcess
(
)
;
dragSession
-
>
GetDragAction
(
&
action
)
;
dragSession
-
>
GetTriggeringPrincipal
(
getter_AddRefs
(
principal
)
)
;
dragSession
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
RefPtr
<
DataTransfer
>
initialDataTransfer
=
dragSession
-
>
GetDataTransfer
(
)
;
if
(
initialDataTransfer
)
{
dropEffect
=
initialDataTransfer
-
>
DropEffectInt
(
)
;
}
}
browserParent
-
>
SendRealDragEvent
(
*
aEvent
-
>
AsDragEvent
(
)
action
dropEffect
principal
csp
)
;
return
;
}
default
:
{
MOZ_CRASH
(
"
Attempt
to
send
non
-
whitelisted
event
?
"
)
;
}
}
}
bool
EventStateManager
:
:
IsRemoteTarget
(
nsIContent
*
target
)
{
return
BrowserParent
:
:
GetFrom
(
target
)
|
|
BrowserBridgeChild
:
:
GetFrom
(
target
)
;
}
bool
EventStateManager
:
:
IsTopLevelRemoteTarget
(
nsIContent
*
target
)
{
return
!
!
BrowserParent
:
:
GetFrom
(
target
)
;
}
bool
EventStateManager
:
:
HandleCrossProcessEvent
(
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
{
if
(
!
aEvent
-
>
CanBeSentToRemoteProcess
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
aEvent
-
>
HasBeenPostedToRemoteProcess
(
)
"
Why
do
we
need
to
post
same
event
to
remote
processes
again
?
"
)
;
AutoTArray
<
RefPtr
<
BrowserParent
>
1
>
remoteTargets
;
if
(
aEvent
-
>
mClass
!
=
eTouchEventClass
|
|
aEvent
-
>
mMessage
=
=
eTouchStart
)
{
nsIFrame
*
frame
=
aEvent
-
>
mMessage
=
=
eDragExit
?
sLastDragOverFrame
.
GetFrame
(
)
:
GetEventTarget
(
)
;
nsIContent
*
target
=
frame
?
frame
-
>
GetContent
(
)
:
nullptr
;
if
(
BrowserParent
*
remoteTarget
=
BrowserParent
:
:
GetFrom
(
target
)
)
{
remoteTargets
.
AppendElement
(
remoteTarget
)
;
}
}
else
{
const
WidgetTouchEvent
:
:
TouchArray
&
touches
=
aEvent
-
>
AsTouchEvent
(
)
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
Touch
*
touch
=
touches
[
i
]
;
if
(
!
touch
|
|
!
touch
-
>
mChanged
)
{
continue
;
}
nsCOMPtr
<
EventTarget
>
targetPtr
=
touch
-
>
mTarget
;
if
(
!
targetPtr
)
{
continue
;
}
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
targetPtr
)
;
BrowserParent
*
remoteTarget
=
BrowserParent
:
:
GetFrom
(
target
)
;
if
(
remoteTarget
&
&
!
remoteTargets
.
Contains
(
remoteTarget
)
)
{
remoteTargets
.
AppendElement
(
remoteTarget
)
;
}
}
}
if
(
remoteTargets
.
Length
(
)
=
=
0
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
remoteTargets
.
Length
(
)
;
+
+
i
)
{
DispatchCrossProcessEvent
(
aEvent
remoteTargets
[
i
]
aStatus
)
;
}
return
aEvent
-
>
HasBeenPostedToRemoteProcess
(
)
;
}
void
EventStateManager
:
:
CreateClickHoldTimer
(
nsPresContext
*
inPresContext
nsIFrame
*
inDownFrame
WidgetGUIEvent
*
inMouseDownEvent
)
{
if
(
!
inMouseDownEvent
-
>
IsTrusted
(
)
|
|
IsTopLevelRemoteTarget
(
mGestureDownContent
)
|
|
PointerLockManager
:
:
IsLocked
(
)
)
{
return
;
}
if
(
mClickHoldTimer
)
{
mClickHoldTimer
-
>
Cancel
(
)
;
mClickHoldTimer
=
nullptr
;
}
if
(
mGestureDownContent
&
&
nsContentUtils
:
:
HasNonEmptyAttr
(
mGestureDownContent
kNameSpaceID_None
nsGkAtoms
:
:
popup
)
)
{
return
;
}
int32_t
clickHoldDelay
=
StaticPrefs
:
:
ui_click_hold_context_menus_delay
(
)
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mClickHoldTimer
)
sClickHoldCallback
this
clickHoldDelay
nsITimer
:
:
TYPE_ONE_SHOT
"
EventStateManager
:
:
CreateClickHoldTimer
"
)
;
}
void
EventStateManager
:
:
KillClickHoldTimer
(
)
{
if
(
mClickHoldTimer
)
{
mClickHoldTimer
-
>
Cancel
(
)
;
mClickHoldTimer
=
nullptr
;
}
}
void
EventStateManager
:
:
sClickHoldCallback
(
nsITimer
*
aTimer
void
*
aESM
)
{
RefPtr
<
EventStateManager
>
self
=
static_cast
<
EventStateManager
*
>
(
aESM
)
;
if
(
self
)
{
self
-
>
FireContextClick
(
)
;
}
}
void
EventStateManager
:
:
FireContextClick
(
)
{
if
(
!
mGestureDownContent
|
|
!
mPresContext
|
|
PointerLockManager
:
:
IsLocked
(
)
)
{
return
;
}
#
ifdef
XP_MACOSX
if
(
!
CGEventSourceButtonState
(
kCGEventSourceStateCombinedSessionState
kCGMouseButtonLeft
)
)
return
;
#
endif
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mCurrentTarget
=
mPresContext
-
>
GetPrimaryFrameFor
(
mGestureDownContent
)
;
nsCOMPtr
<
nsIWidget
>
targetWidget
;
if
(
mCurrentTarget
&
&
(
targetWidget
=
mCurrentTarget
-
>
GetNearestWidget
(
)
)
)
{
NS_ASSERTION
(
mPresContext
=
=
mCurrentTarget
-
>
PresContext
(
)
"
a
prescontext
returned
a
primary
frame
that
didn
'
t
belong
to
it
?
"
)
;
bool
allowedToDispatch
=
true
;
if
(
mGestureDownContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
scrollbar
nsGkAtoms
:
:
scrollbarbutton
nsGkAtoms
:
:
button
)
)
{
allowedToDispatch
=
false
;
}
else
if
(
mGestureDownContent
-
>
IsXULElement
(
nsGkAtoms
:
:
toolbarbutton
)
)
{
if
(
nsContentUtils
:
:
HasNonEmptyAttr
(
mGestureDownContent
kNameSpaceID_None
nsGkAtoms
:
:
container
)
)
{
allowedToDispatch
=
false
;
}
else
{
if
(
mGestureDownContent
-
>
IsElement
(
)
&
&
mGestureDownContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
open
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
allowedToDispatch
=
false
;
}
}
}
else
if
(
mGestureDownContent
-
>
IsHTMLElement
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
formCtrl
(
do_QueryInterface
(
mGestureDownContent
)
)
;
if
(
formCtrl
)
{
allowedToDispatch
=
formCtrl
-
>
IsTextControl
(
false
)
|
|
formCtrl
-
>
ControlType
(
)
=
=
FormControlType
:
:
InputFile
;
}
else
if
(
mGestureDownContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
object
nsGkAtoms
:
:
label
)
)
{
allowedToDispatch
=
false
;
}
}
if
(
allowedToDispatch
)
{
WidgetMouseEvent
event
(
true
eContextMenu
targetWidget
WidgetMouseEvent
:
:
eReal
)
;
event
.
mClickCount
=
1
;
FillInEventFromGestureDown
(
&
event
)
;
if
(
mCurrentTarget
)
{
RefPtr
<
nsFrameSelection
>
frameSel
=
mCurrentTarget
-
>
GetFrameSelection
(
)
;
if
(
frameSel
&
&
frameSel
-
>
GetDragState
(
)
)
{
frameSel
-
>
SetDragState
(
false
)
;
}
}
AutoHandlingUserInputStatePusher
userInpStatePusher
(
true
&
event
)
;
RefPtr
<
nsIContent
>
gestureDownContent
=
mGestureDownContent
;
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
EventDispatcher
:
:
Dispatch
(
gestureDownContent
presContext
&
event
nullptr
&
status
)
;
}
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
StopTrackingDragGesture
(
true
)
;
}
KillClickHoldTimer
(
)
;
}
void
EventStateManager
:
:
BeginTrackingDragGesture
(
nsPresContext
*
aPresContext
WidgetMouseEvent
*
inDownEvent
nsIFrame
*
inDownFrame
)
{
if
(
!
inDownEvent
-
>
mWidget
)
{
return
;
}
SetGestureDownPoint
(
inDownEvent
)
;
if
(
inDownFrame
)
{
inDownFrame
-
>
GetContentForEvent
(
inDownEvent
getter_AddRefs
(
mGestureDownContent
)
)
;
mGestureDownFrameOwner
=
inDownFrame
-
>
GetContent
(
)
;
if
(
!
mGestureDownFrameOwner
)
{
mGestureDownFrameOwner
=
mGestureDownContent
;
}
}
mGestureModifiers
=
inDownEvent
-
>
mModifiers
;
mGestureDownButtons
=
inDownEvent
-
>
mButtons
;
if
(
inDownEvent
-
>
mMessage
!
=
eMouseTouchDrag
&
&
StaticPrefs
:
:
ui_click_hold_context_menus
(
)
)
{
CreateClickHoldTimer
(
aPresContext
inDownFrame
inDownEvent
)
;
}
}
void
EventStateManager
:
:
SetGestureDownPoint
(
WidgetGUIEvent
*
aEvent
)
{
mGestureDownPoint
=
GetEventRefPoint
(
aEvent
)
+
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
;
}
LayoutDeviceIntPoint
EventStateManager
:
:
GetEventRefPoint
(
WidgetEvent
*
aEvent
)
const
{
auto
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
return
(
touchEvent
&
&
!
touchEvent
-
>
mTouches
.
IsEmpty
(
)
)
?
aEvent
-
>
AsTouchEvent
(
)
-
>
mTouches
[
0
]
-
>
mRefPoint
:
aEvent
-
>
mRefPoint
;
}
void
EventStateManager
:
:
BeginTrackingRemoteDragGesture
(
nsIContent
*
aContent
RemoteDragStartData
*
aDragStartData
)
{
mGestureDownContent
=
aContent
;
mGestureDownFrameOwner
=
aContent
;
mGestureDownInTextControl
=
aContent
&
&
aContent
-
>
IsInNativeAnonymousSubtree
(
)
&
&
TextControlElement
:
:
FromNodeOrNull
(
aContent
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
;
mGestureDownDragStartData
=
aDragStartData
;
}
void
EventStateManager
:
:
StopTrackingDragGesture
(
bool
aClearInChildProcesses
)
{
mGestureDownContent
=
nullptr
;
mGestureDownFrameOwner
=
nullptr
;
mGestureDownInTextControl
=
false
;
mGestureDownDragStartData
=
nullptr
;
if
(
aClearInChildProcesses
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
dragService
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
;
dragService
-
>
GetCurrentSession
(
getter_AddRefs
(
dragSession
)
)
;
if
(
!
dragSession
)
{
dragService
-
>
RemoveAllChildProcesses
(
)
;
}
}
}
}
void
EventStateManager
:
:
FillInEventFromGestureDown
(
WidgetMouseEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
-
>
mWidget
=
=
mCurrentTarget
-
>
GetNearestWidget
(
)
"
Incorrect
widget
in
event
"
)
;
aEvent
-
>
mRefPoint
=
mGestureDownPoint
-
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
;
aEvent
-
>
mModifiers
=
mGestureModifiers
;
aEvent
-
>
mButtons
=
mGestureDownButtons
;
}
void
EventStateManager
:
:
MaybeFirePointerCancel
(
WidgetInputEvent
*
aEvent
)
{
RefPtr
<
PresShell
>
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
AutoWeakFrame
targetFrame
=
mCurrentTarget
;
if
(
!
presShell
|
|
!
targetFrame
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
content
;
targetFrame
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
content
)
)
;
if
(
!
content
)
{
return
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
WidgetMouseEvent
*
aMouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
)
{
WidgetPointerEvent
event
(
*
aMouseEvent
)
;
PointerEventHandler
:
:
InitPointerEventFromMouse
(
&
event
aMouseEvent
ePointerCancel
)
;
event
.
convertToPointer
=
false
;
presShell
-
>
HandleEventWithTarget
(
&
event
targetFrame
content
&
status
)
;
}
else
if
(
WidgetTouchEvent
*
aTouchEvent
=
aEvent
-
>
AsTouchEvent
(
)
)
{
WidgetPointerEvent
event
(
aTouchEvent
-
>
IsTrusted
(
)
ePointerCancel
aTouchEvent
-
>
mWidget
)
;
PointerEventHandler
:
:
InitPointerEventFromTouch
(
event
*
aTouchEvent
*
aTouchEvent
-
>
mTouches
[
0
]
true
)
;
event
.
convertToPointer
=
false
;
presShell
-
>
HandleEventWithTarget
(
&
event
targetFrame
content
&
status
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
mCurrentTarget
=
targetFrame
;
}
bool
EventStateManager
:
:
IsEventOutsideDragThreshold
(
WidgetInputEvent
*
aEvent
)
const
{
static
int32_t
sPixelThresholdX
=
0
;
static
int32_t
sPixelThresholdY
=
0
;
if
(
!
sPixelThresholdX
)
{
sPixelThresholdX
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
DragThresholdX
0
)
;
sPixelThresholdY
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
DragThresholdY
0
)
;
if
(
!
sPixelThresholdX
)
sPixelThresholdX
=
5
;
if
(
!
sPixelThresholdY
)
sPixelThresholdY
=
5
;
}
LayoutDeviceIntPoint
pt
=
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
+
GetEventRefPoint
(
aEvent
)
;
LayoutDeviceIntPoint
distance
=
pt
-
mGestureDownPoint
;
return
Abs
(
distance
.
x
)
>
AssertedCast
<
uint32_t
>
(
sPixelThresholdX
)
|
|
Abs
(
distance
.
y
)
>
AssertedCast
<
uint32_t
>
(
sPixelThresholdY
)
;
}
void
EventStateManager
:
:
GenerateDragGesture
(
nsPresContext
*
aPresContext
WidgetInputEvent
*
aEvent
)
{
NS_ASSERTION
(
aPresContext
"
This
shouldn
'
t
happen
.
"
)
;
if
(
!
IsTrackingDragGesture
(
)
)
{
return
;
}
AutoWeakFrame
targetFrameBefore
=
mCurrentTarget
;
auto
autoRestore
=
MakeScopeExit
(
[
&
]
{
mCurrentTarget
=
targetFrameBefore
;
}
)
;
mCurrentTarget
=
mGestureDownFrameOwner
-
>
GetPrimaryFrame
(
)
;
if
(
!
mCurrentTarget
|
|
!
mCurrentTarget
-
>
GetNearestWidget
(
)
)
{
StopTrackingDragGesture
(
true
)
;
return
;
}
if
(
mCurrentTarget
)
{
RefPtr
<
nsFrameSelection
>
frameSel
=
mCurrentTarget
-
>
GetFrameSelection
(
)
;
if
(
frameSel
&
&
frameSel
-
>
GetDragState
(
)
)
{
StopTrackingDragGesture
(
true
)
;
return
;
}
}
if
(
PresShell
:
:
IsMouseCapturePreventingDrag
(
)
)
{
StopTrackingDragGesture
(
true
)
;
return
;
}
if
(
!
IsEventOutsideDragThreshold
(
aEvent
)
)
{
FlushLayout
(
aPresContext
)
;
return
;
}
if
(
StaticPrefs
:
:
ui_click_hold_context_menus
(
)
)
{
KillClickHoldTimer
(
)
;
}
nsCOMPtr
<
nsIDocShell
>
docshell
=
aPresContext
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docshell
-
>
GetWindow
(
)
;
if
(
!
window
)
return
;
RefPtr
<
DataTransfer
>
dataTransfer
=
new
DataTransfer
(
window
eDragStart
false
-
1
)
;
auto
protectDataTransfer
=
MakeScopeExit
(
[
&
]
{
if
(
dataTransfer
)
{
dataTransfer
-
>
Disconnect
(
)
;
}
}
)
;
RefPtr
<
Selection
>
selection
;
RefPtr
<
RemoteDragStartData
>
remoteDragStartData
;
nsCOMPtr
<
nsIContent
>
eventContent
targetContent
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
;
bool
allowEmptyDataTransfer
=
false
;
mCurrentTarget
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
eventContent
)
)
;
if
(
eventContent
)
{
if
(
eventContent
-
>
IsText
(
)
&
&
eventContent
-
>
HasFlag
(
NS_MAYBE_MASKED
)
)
{
TextEditor
*
textEditor
=
nsContentUtils
:
:
GetTextEditorFromAnonymousNodeWithoutCreation
(
eventContent
)
;
if
(
!
textEditor
|
|
!
textEditor
-
>
IsCopyToClipboardAllowed
(
)
)
{
StopTrackingDragGesture
(
true
)
;
return
;
}
}
DetermineDragTargetAndDefaultData
(
window
eventContent
dataTransfer
&
allowEmptyDataTransfer
getter_AddRefs
(
selection
)
getter_AddRefs
(
remoteDragStartData
)
getter_AddRefs
(
targetContent
)
getter_AddRefs
(
principal
)
getter_AddRefs
(
csp
)
getter_AddRefs
(
cookieJarSettings
)
)
;
}
StopTrackingDragGesture
(
false
)
;
if
(
!
targetContent
)
return
;
nsCOMPtr
<
nsIContent
>
parentContent
=
targetContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
dataTransfer
-
>
SetParentObject
(
parentContent
)
;
sLastDragOverFrame
=
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
mCurrentTarget
-
>
GetNearestWidget
(
)
;
WidgetDragEvent
startEvent
(
aEvent
-
>
IsTrusted
(
)
eDragStart
widget
)
;
startEvent
.
mFlags
.
mIsSynthesizedForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
FillInEventFromGestureDown
(
&
startEvent
)
;
startEvent
.
mDataTransfer
=
dataTransfer
;
if
(
aEvent
-
>
AsMouseEvent
(
)
)
{
startEvent
.
mInputSource
=
aEvent
-
>
AsMouseEvent
(
)
-
>
mInputSource
;
}
else
if
(
aEvent
-
>
AsTouchEvent
(
)
)
{
startEvent
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
nsCOMPtr
<
nsIContent
>
targetBeforeEvent
=
mCurrentTargetContent
;
mCurrentTargetContent
=
targetContent
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
targetContent
aPresContext
&
startEvent
nullptr
&
status
)
;
WidgetDragEvent
*
event
=
&
startEvent
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
dataTransfer
"
on
-
datatransfer
-
available
"
nullptr
)
;
}
if
(
status
!
=
nsEventStatus_eConsumeNoDefault
)
{
bool
dragStarted
=
DoDefaultDragStart
(
aPresContext
event
dataTransfer
allowEmptyDataTransfer
targetContent
selection
remoteDragStartData
principal
csp
cookieJarSettings
)
;
if
(
dragStarted
)
{
sActiveESM
=
nullptr
;
MaybeFirePointerCancel
(
aEvent
)
;
aEvent
-
>
StopPropagation
(
)
;
}
}
mCurrentTargetContent
=
targetBeforeEvent
;
FlushLayout
(
aPresContext
)
;
}
void
EventStateManager
:
:
DetermineDragTargetAndDefaultData
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aSelectionTarget
DataTransfer
*
aDataTransfer
bool
*
aAllowEmptyDataTransfer
Selection
*
*
aSelection
RemoteDragStartData
*
*
aRemoteDragStartData
nsIContent
*
*
aTargetNode
nsIPrincipal
*
*
aPrincipal
nsIContentSecurityPolicy
*
*
aCsp
nsICookieJarSettings
*
*
aCookieJarSettings
)
{
*
aTargetNode
=
nullptr
;
*
aAllowEmptyDataTransfer
=
false
;
nsCOMPtr
<
nsIContent
>
dragDataNode
;
nsIContent
*
editingElement
=
aSelectionTarget
-
>
IsEditable
(
)
?
aSelectionTarget
-
>
GetEditingHost
(
)
:
nullptr
;
bool
isChromeContext
=
!
aWindow
-
>
GetBrowsingContext
(
)
-
>
IsContent
(
)
;
if
(
isChromeContext
&
&
!
editingElement
)
{
if
(
mGestureDownDragStartData
)
{
mGestureDownDragStartData
-
>
AddInitialDnDDataTo
(
aDataTransfer
aPrincipal
aCsp
aCookieJarSettings
)
;
mGestureDownDragStartData
.
forget
(
aRemoteDragStartData
)
;
*
aAllowEmptyDataTransfer
=
true
;
}
}
else
{
mGestureDownDragStartData
=
nullptr
;
bool
canDrag
;
bool
wasAlt
=
(
mGestureModifiers
&
MODIFIER_ALT
)
!
=
0
;
nsresult
rv
=
nsContentAreaDragDrop
:
:
GetDragData
(
aWindow
mGestureDownContent
aSelectionTarget
wasAlt
aDataTransfer
&
canDrag
aSelection
getter_AddRefs
(
dragDataNode
)
aPrincipal
aCsp
aCookieJarSettings
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
canDrag
)
{
return
;
}
}
nsIContent
*
dragContent
=
mGestureDownContent
;
if
(
dragDataNode
)
dragContent
=
dragDataNode
;
else
if
(
*
aSelection
)
dragContent
=
aSelectionTarget
;
nsIContent
*
originalDragContent
=
dragContent
;
if
(
!
*
aSelection
)
{
while
(
dragContent
)
{
if
(
auto
htmlElement
=
nsGenericHTMLElement
:
:
FromNode
(
dragContent
)
)
{
if
(
htmlElement
-
>
Draggable
(
)
)
{
*
aAllowEmptyDataTransfer
=
true
;
break
;
}
}
else
{
if
(
dragContent
-
>
IsXULElement
(
)
)
{
dragContent
=
mGestureDownContent
;
break
;
}
}
dragContent
=
dragContent
-
>
GetFlattenedTreeParent
(
)
;
}
}
if
(
!
dragContent
&
&
dragDataNode
)
dragContent
=
dragDataNode
;
if
(
dragContent
)
{
if
(
dragContent
!
=
originalDragContent
)
aDataTransfer
-
>
ClearAll
(
)
;
*
aTargetNode
=
dragContent
;
NS_ADDREF
(
*
aTargetNode
)
;
}
}
bool
EventStateManager
:
:
DoDefaultDragStart
(
nsPresContext
*
aPresContext
WidgetDragEvent
*
aDragEvent
DataTransfer
*
aDataTransfer
bool
aAllowEmptyDataTransfer
nsIContent
*
aDragTarget
Selection
*
aSelection
RemoteDragStartData
*
aDragStartData
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsICookieJarSettings
*
aCookieJarSettings
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
!
dragService
)
return
false
;
nsCOMPtr
<
nsIDragSession
>
dragSession
;
dragService
-
>
GetCurrentSession
(
getter_AddRefs
(
dragSession
)
)
;
if
(
dragSession
&
&
!
dragSession
-
>
IsSynthesizedForTests
(
)
)
{
return
true
;
}
uint32_t
count
=
0
;
if
(
aDataTransfer
)
{
count
=
aDataTransfer
-
>
MozItemCount
(
)
;
}
if
(
!
aAllowEmptyDataTransfer
&
&
!
count
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
dragTarget
=
aDataTransfer
-
>
GetDragTarget
(
)
;
if
(
!
dragTarget
)
{
dragTarget
=
aDragTarget
;
if
(
!
dragTarget
)
{
return
false
;
}
}
uint32_t
action
=
aDataTransfer
-
>
EffectAllowedInt
(
)
;
if
(
action
=
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
{
action
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
|
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
|
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
}
int32_t
imageX
imageY
;
RefPtr
<
Element
>
dragImage
=
aDataTransfer
-
>
GetDragImage
(
&
imageX
&
imageY
)
;
nsCOMPtr
<
nsIArray
>
transArray
=
aDataTransfer
-
>
GetTransferables
(
dragTarget
)
;
if
(
!
transArray
)
{
return
false
;
}
RefPtr
<
DataTransfer
>
dataTransfer
;
if
(
!
dragSession
)
{
aDataTransfer
-
>
Clone
(
aDragTarget
eDrop
aDataTransfer
-
>
MozUserCancelled
(
)
false
getter_AddRefs
(
dataTransfer
)
)
;
dataTransfer
-
>
SetDropEffectInt
(
aDataTransfer
-
>
DropEffectInt
(
)
)
;
}
else
{
MOZ_ASSERT
(
dragSession
-
>
IsSynthesizedForTests
(
)
)
;
MOZ_ASSERT
(
aDragEvent
-
>
mFlags
.
mIsSynthesizedForTests
)
;
dataTransfer
=
aDataTransfer
;
}
RefPtr
<
DragEvent
>
event
=
NS_NewDOMDragEvent
(
dragTarget
aPresContext
aDragEvent
)
;
if
(
!
dragImage
&
&
aSelection
)
{
dragService
-
>
InvokeDragSessionWithSelection
(
aSelection
aPrincipal
aCsp
aCookieJarSettings
transArray
action
event
dataTransfer
)
;
}
else
if
(
aDragStartData
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
dragService
-
>
InvokeDragSessionWithRemoteImage
(
dragTarget
aPrincipal
aCsp
aCookieJarSettings
transArray
action
aDragStartData
event
dataTransfer
)
;
}
else
{
dragService
-
>
InvokeDragSessionWithImage
(
dragTarget
aPrincipal
aCsp
aCookieJarSettings
transArray
action
dragImage
imageX
imageY
event
dataTransfer
)
;
}
return
true
;
}
void
EventStateManager
:
:
ChangeZoom
(
bool
aIncrease
)
{
nsIDocShell
*
docShell
=
mDocument
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
bc
-
>
Canonical
(
)
-
>
DispatchWheelZoomChange
(
aIncrease
)
;
}
else
if
(
BrowserChild
*
child
=
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
child
-
>
SendWheelZoomChange
(
aIncrease
)
;
}
}
void
EventStateManager
:
:
DoScrollHistory
(
int32_t
direction
)
{
nsCOMPtr
<
nsISupports
>
pcContainer
(
mPresContext
-
>
GetContainerWeak
(
)
)
;
if
(
pcContainer
)
{
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
pcContainer
)
)
;
if
(
webNav
)
{
if
(
direction
>
0
)
webNav
-
>
GoBack
(
StaticPrefs
:
:
browser_navigation_requireUserInteraction
(
)
true
)
;
else
webNav
-
>
GoForward
(
StaticPrefs
:
:
browser_navigation_requireUserInteraction
(
)
true
)
;
}
}
}
void
EventStateManager
:
:
DoScrollZoom
(
nsIFrame
*
aTargetFrame
int32_t
adjustment
)
{
nsIContent
*
content
=
aTargetFrame
-
>
GetContent
(
)
;
if
(
content
&
&
!
nsContentUtils
:
:
IsInChromeDocshell
(
content
-
>
OwnerDoc
(
)
)
)
{
const
bool
increase
=
adjustment
<
=
0
;
EnsureDocument
(
mPresContext
)
;
ChangeZoom
(
increase
)
;
}
}
static
nsIFrame
*
GetParentFrameToScroll
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
return
nullptr
;
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
aFrame
)
)
return
aFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootScrollFrame
(
)
;
return
aFrame
-
>
GetParent
(
)
;
}
void
EventStateManager
:
:
DispatchLegacyMouseScrollEvents
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
nsEventStatus
*
aStatus
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aStatus
)
;
if
(
!
aTargetFrame
|
|
*
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
auto
scrollAmountInCSSPixels
=
CSSIntSize
:
:
FromAppUnitsRounded
(
aEvent
-
>
mScrollAmount
)
;
int32_t
scrollDeltaX
scrollDeltaY
pixelDeltaX
pixelDeltaY
;
switch
(
aEvent
-
>
mDeltaMode
)
{
case
WheelEvent_Binding
:
:
DOM_DELTA_PAGE
:
scrollDeltaX
=
!
aEvent
-
>
mLineOrPageDeltaX
?
0
:
(
aEvent
-
>
mLineOrPageDeltaX
>
0
?
UIEvent_Binding
:
:
SCROLL_PAGE_DOWN
:
UIEvent_Binding
:
:
SCROLL_PAGE_UP
)
;
scrollDeltaY
=
!
aEvent
-
>
mLineOrPageDeltaY
?
0
:
(
aEvent
-
>
mLineOrPageDeltaY
>
0
?
UIEvent_Binding
:
:
SCROLL_PAGE_DOWN
:
UIEvent_Binding
:
:
SCROLL_PAGE_UP
)
;
pixelDeltaX
=
RoundDown
(
aEvent
-
>
mDeltaX
*
scrollAmountInCSSPixels
.
width
)
;
pixelDeltaY
=
RoundDown
(
aEvent
-
>
mDeltaY
*
scrollAmountInCSSPixels
.
height
)
;
break
;
case
WheelEvent_Binding
:
:
DOM_DELTA_LINE
:
scrollDeltaX
=
aEvent
-
>
mLineOrPageDeltaX
;
scrollDeltaY
=
aEvent
-
>
mLineOrPageDeltaY
;
pixelDeltaX
=
RoundDown
(
aEvent
-
>
mDeltaX
*
scrollAmountInCSSPixels
.
width
)
;
pixelDeltaY
=
RoundDown
(
aEvent
-
>
mDeltaY
*
scrollAmountInCSSPixels
.
height
)
;
break
;
case
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
:
scrollDeltaX
=
aEvent
-
>
mLineOrPageDeltaX
;
scrollDeltaY
=
aEvent
-
>
mLineOrPageDeltaY
;
pixelDeltaX
=
RoundDown
(
aEvent
-
>
mDeltaX
)
;
pixelDeltaY
=
RoundDown
(
aEvent
-
>
mDeltaY
)
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
deltaMode
value
comes
"
)
;
}
AutoWeakFrame
targetFrame
(
aTargetFrame
)
;
MOZ_ASSERT
(
*
aStatus
!
=
nsEventStatus_eConsumeNoDefault
&
&
!
aEvent
-
>
DefaultPrevented
(
)
"
If
you
make
legacy
events
dispatched
for
default
prevented
wheel
"
"
event
you
need
to
initialize
stateX
and
stateY
"
)
;
EventState
stateX
stateY
;
if
(
scrollDeltaY
)
{
SendLineScrollEvent
(
aTargetFrame
aEvent
stateY
scrollDeltaY
DELTA_DIRECTION_Y
)
;
if
(
!
targetFrame
.
IsAlive
(
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
;
}
}
if
(
pixelDeltaY
)
{
SendPixelScrollEvent
(
aTargetFrame
aEvent
stateY
pixelDeltaY
DELTA_DIRECTION_Y
)
;
if
(
!
targetFrame
.
IsAlive
(
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
;
}
}
if
(
scrollDeltaX
)
{
SendLineScrollEvent
(
aTargetFrame
aEvent
stateX
scrollDeltaX
DELTA_DIRECTION_X
)
;
if
(
!
targetFrame
.
IsAlive
(
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
;
}
}
if
(
pixelDeltaX
)
{
SendPixelScrollEvent
(
aTargetFrame
aEvent
stateX
pixelDeltaX
DELTA_DIRECTION_X
)
;
if
(
!
targetFrame
.
IsAlive
(
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
;
}
}
if
(
stateY
.
mDefaultPrevented
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
aEvent
-
>
PreventDefault
(
!
stateY
.
mDefaultPreventedByContent
)
;
}
if
(
stateX
.
mDefaultPrevented
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
aEvent
-
>
PreventDefault
(
!
stateX
.
mDefaultPreventedByContent
)
;
}
}
void
EventStateManager
:
:
SendLineScrollEvent
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
EventState
&
aState
int32_t
aDelta
DeltaDirection
aDeltaDirection
)
{
nsCOMPtr
<
nsIContent
>
targetContent
=
aTargetFrame
-
>
GetContent
(
)
;
if
(
!
targetContent
)
{
targetContent
=
GetFocusedElement
(
)
;
if
(
!
targetContent
)
{
return
;
}
}
while
(
targetContent
-
>
IsText
(
)
)
{
targetContent
=
targetContent
-
>
GetFlattenedTreeParent
(
)
;
}
WidgetMouseScrollEvent
event
(
aEvent
-
>
IsTrusted
(
)
eLegacyMouseLineOrPageScroll
aEvent
-
>
mWidget
)
;
event
.
mFlags
.
mDefaultPrevented
=
aState
.
mDefaultPrevented
;
event
.
mFlags
.
mDefaultPreventedByContent
=
aState
.
mDefaultPreventedByContent
;
event
.
mRefPoint
=
aEvent
-
>
mRefPoint
;
event
.
mTime
=
aEvent
-
>
mTime
;
event
.
mTimeStamp
=
aEvent
-
>
mTimeStamp
;
event
.
mModifiers
=
aEvent
-
>
mModifiers
;
event
.
mButtons
=
aEvent
-
>
mButtons
;
event
.
mIsHorizontal
=
(
aDeltaDirection
=
=
DELTA_DIRECTION_X
)
;
event
.
mDelta
=
aDelta
;
event
.
mInputSource
=
aEvent
-
>
mInputSource
;
RefPtr
<
nsPresContext
>
presContext
=
aTargetFrame
-
>
PresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
targetContent
presContext
&
event
nullptr
&
status
)
;
aState
.
mDefaultPrevented
=
event
.
DefaultPrevented
(
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
;
aState
.
mDefaultPreventedByContent
=
event
.
DefaultPreventedByContent
(
)
;
}
void
EventStateManager
:
:
SendPixelScrollEvent
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
EventState
&
aState
int32_t
aPixelDelta
DeltaDirection
aDeltaDirection
)
{
nsCOMPtr
<
nsIContent
>
targetContent
=
aTargetFrame
-
>
GetContent
(
)
;
if
(
!
targetContent
)
{
targetContent
=
GetFocusedElement
(
)
;
if
(
!
targetContent
)
{
return
;
}
}
while
(
targetContent
-
>
IsText
(
)
)
{
targetContent
=
targetContent
-
>
GetFlattenedTreeParent
(
)
;
}
WidgetMouseScrollEvent
event
(
aEvent
-
>
IsTrusted
(
)
eLegacyMousePixelScroll
aEvent
-
>
mWidget
)
;
event
.
mFlags
.
mDefaultPrevented
=
aState
.
mDefaultPrevented
;
event
.
mFlags
.
mDefaultPreventedByContent
=
aState
.
mDefaultPreventedByContent
;
event
.
mRefPoint
=
aEvent
-
>
mRefPoint
;
event
.
mTime
=
aEvent
-
>
mTime
;
event
.
mTimeStamp
=
aEvent
-
>
mTimeStamp
;
event
.
mModifiers
=
aEvent
-
>
mModifiers
;
event
.
mButtons
=
aEvent
-
>
mButtons
;
event
.
mIsHorizontal
=
(
aDeltaDirection
=
=
DELTA_DIRECTION_X
)
;
event
.
mDelta
=
aPixelDelta
;
event
.
mInputSource
=
aEvent
-
>
mInputSource
;
RefPtr
<
nsPresContext
>
presContext
=
aTargetFrame
-
>
PresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
targetContent
presContext
&
event
nullptr
&
status
)
;
aState
.
mDefaultPrevented
=
event
.
DefaultPrevented
(
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
;
aState
.
mDefaultPreventedByContent
=
event
.
DefaultPreventedByContent
(
)
;
}
nsIFrame
*
EventStateManager
:
:
ComputeScrollTargetAndMayAdjustWheelEvent
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
ComputeScrollTargetOptions
aOptions
)
{
return
ComputeScrollTargetAndMayAdjustWheelEvent
(
aTargetFrame
aEvent
-
>
mDeltaX
aEvent
-
>
mDeltaY
aEvent
aOptions
)
;
}
nsIFrame
*
EventStateManager
:
:
ComputeScrollTargetAndMayAdjustWheelEvent
(
nsIFrame
*
aTargetFrame
double
aDirectionX
double
aDirectionY
WidgetWheelEvent
*
aEvent
ComputeScrollTargetOptions
aOptions
)
{
bool
isAutoDir
=
false
;
bool
honoursRoot
=
false
;
if
(
MAY_BE_ADJUSTED_BY_AUTO_DIR
&
aOptions
)
{
MOZ_ASSERT
(
aDirectionX
=
=
aEvent
-
>
mDeltaX
&
&
aDirectionY
=
=
aEvent
-
>
mDeltaY
)
;
WheelDeltaAdjustmentStrategy
strategy
=
GetWheelDeltaAdjustmentStrategy
(
*
aEvent
)
;
switch
(
strategy
)
{
case
WheelDeltaAdjustmentStrategy
:
:
eAutoDir
:
isAutoDir
=
true
;
honoursRoot
=
false
;
break
;
case
WheelDeltaAdjustmentStrategy
:
:
eAutoDirWithRootHonour
:
isAutoDir
=
true
;
honoursRoot
=
true
;
break
;
default
:
break
;
}
}
if
(
aOptions
&
PREFER_MOUSE_WHEEL_TRANSACTION
)
{
nsIFrame
*
lastScrollFrame
=
WheelTransaction
:
:
GetTargetFrame
(
)
;
if
(
lastScrollFrame
)
{
nsIScrollableFrame
*
scrollableFrame
=
lastScrollFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
scrollableFrame
)
{
nsIFrame
*
frameToScroll
=
do_QueryFrame
(
scrollableFrame
)
;
MOZ_ASSERT
(
frameToScroll
)
;
if
(
isAutoDir
)
{
ESMAutoDirWheelDeltaAdjuster
adjuster
(
*
aEvent
*
lastScrollFrame
honoursRoot
)
;
adjuster
.
Adjust
(
)
;
}
return
frameToScroll
;
}
}
}
if
(
!
aDirectionX
&
&
!
aDirectionY
)
{
return
nullptr
;
}
bool
checkIfScrollableX
;
bool
checkIfScrollableY
;
if
(
isAutoDir
)
{
checkIfScrollableX
=
true
;
checkIfScrollableY
=
true
;
}
else
{
checkIfScrollableX
=
aDirectionX
&
&
(
aOptions
&
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_X_AXIS
)
;
checkIfScrollableY
=
aDirectionY
&
&
(
aOptions
&
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_Y_AXIS
)
;
}
nsIFrame
*
scrollFrame
=
!
(
aOptions
&
START_FROM_PARENT
)
?
aTargetFrame
:
GetParentFrameToScroll
(
aTargetFrame
)
;
for
(
;
scrollFrame
;
scrollFrame
=
GetParentFrameToScroll
(
scrollFrame
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
scrollFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
!
scrollableFrame
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
scrollFrame
)
;
if
(
menuPopupFrame
)
{
return
nullptr
;
}
continue
;
}
nsIFrame
*
frameToScroll
=
do_QueryFrame
(
scrollableFrame
)
;
MOZ_ASSERT
(
frameToScroll
)
;
if
(
!
checkIfScrollableX
&
&
!
checkIfScrollableY
)
{
return
frameToScroll
;
}
Maybe
<
layers
:
:
ScrollDirection
>
disregardedDirection
=
WheelHandlingUtils
:
:
GetDisregardedWheelScrollDirection
(
scrollFrame
)
;
if
(
disregardedDirection
)
{
switch
(
disregardedDirection
.
ref
(
)
)
{
case
layers
:
:
ScrollDirection
:
:
eHorizontal
:
if
(
checkIfScrollableX
)
{
continue
;
}
break
;
case
layers
:
:
ScrollDirection
:
:
eVertical
:
if
(
checkIfScrollableY
)
{
continue
;
}
break
;
}
}
layers
:
:
ScrollDirections
directions
=
scrollableFrame
-
>
GetAvailableScrollingDirectionsForUserInputEvents
(
)
;
if
(
(
!
(
directions
.
contains
(
layers
:
:
ScrollDirection
:
:
eVertical
)
)
&
&
!
(
directions
.
contains
(
layers
:
:
ScrollDirection
:
:
eHorizontal
)
)
)
|
|
(
checkIfScrollableY
&
&
!
checkIfScrollableX
&
&
!
(
directions
.
contains
(
layers
:
:
ScrollDirection
:
:
eVertical
)
)
)
|
|
(
checkIfScrollableX
&
&
!
checkIfScrollableY
&
&
!
(
directions
.
contains
(
layers
:
:
ScrollDirection
:
:
eHorizontal
)
)
)
)
{
continue
;
}
bool
canScroll
=
false
;
if
(
isAutoDir
)
{
ESMAutoDirWheelDeltaAdjuster
adjuster
(
*
aEvent
*
scrollFrame
honoursRoot
)
;
if
(
adjuster
.
ShouldBeAdjusted
(
)
)
{
adjuster
.
Adjust
(
)
;
canScroll
=
true
;
}
else
if
(
WheelHandlingUtils
:
:
CanScrollOn
(
scrollableFrame
aDirectionX
aDirectionY
)
)
{
canScroll
=
true
;
}
}
else
if
(
WheelHandlingUtils
:
:
CanScrollOn
(
scrollableFrame
aDirectionX
aDirectionY
)
)
{
canScroll
=
true
;
}
if
(
canScroll
)
{
return
frameToScroll
;
}
}
nsIFrame
*
newFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
aTargetFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
aOptions
=
static_cast
<
ComputeScrollTargetOptions
>
(
aOptions
&
~
START_FROM_PARENT
)
;
if
(
!
newFrame
)
{
return
nullptr
;
}
return
ComputeScrollTargetAndMayAdjustWheelEvent
(
newFrame
aEvent
aOptions
)
;
}
nsSize
EventStateManager
:
:
GetScrollAmount
(
nsPresContext
*
aPresContext
WidgetWheelEvent
*
aEvent
nsIScrollableFrame
*
aScrollableFrame
)
{
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aEvent
)
;
const
bool
isPage
=
aEvent
-
>
mDeltaMode
=
=
WheelEvent_Binding
:
:
DOM_DELTA_PAGE
;
if
(
!
aScrollableFrame
)
{
aScrollableFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
if
(
aScrollableFrame
)
{
return
isPage
?
aScrollableFrame
-
>
GetPageScrollAmount
(
)
:
aScrollableFrame
-
>
GetLineScrollAmount
(
)
;
}
if
(
isPage
)
{
return
aPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
;
}
nsIFrame
*
rootFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nsSize
(
0
0
)
;
}
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
rootFrame
)
;
NS_ENSURE_TRUE
(
fm
nsSize
(
0
0
)
)
;
return
nsSize
(
fm
-
>
AveCharWidth
(
)
fm
-
>
MaxHeight
(
)
)
;
}
void
EventStateManager
:
:
DoScrollText
(
nsIScrollableFrame
*
aScrollableFrame
WidgetWheelEvent
*
aEvent
)
{
MOZ_ASSERT
(
aScrollableFrame
)
;
MOZ_ASSERT
(
aEvent
)
;
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
aScrollableFrame
)
;
MOZ_ASSERT
(
scrollFrame
)
;
AutoWeakFrame
scrollFrameWeak
(
scrollFrame
)
;
if
(
!
WheelTransaction
:
:
WillHandleDefaultAction
(
aEvent
scrollFrameWeak
)
)
{
return
;
}
nsPresContext
*
pc
=
scrollFrame
-
>
PresContext
(
)
;
nsSize
scrollAmount
=
GetScrollAmount
(
pc
aEvent
aScrollableFrame
)
;
nsIntSize
scrollAmountInDevPixels
(
pc
-
>
AppUnitsToDevPixels
(
scrollAmount
.
width
)
pc
-
>
AppUnitsToDevPixels
(
scrollAmount
.
height
)
)
;
nsIntPoint
actualDevPixelScrollAmount
=
DeltaAccumulator
:
:
GetInstance
(
)
-
>
ComputeScrollAmountForDefaultAction
(
aEvent
scrollAmountInDevPixels
)
;
ScrollStyles
overflowStyle
=
aScrollableFrame
-
>
GetScrollStyles
(
)
;
if
(
overflowStyle
.
mHorizontal
=
=
StyleOverflow
:
:
Hidden
)
{
actualDevPixelScrollAmount
.
x
=
0
;
}
if
(
overflowStyle
.
mVertical
=
=
StyleOverflow
:
:
Hidden
)
{
actualDevPixelScrollAmount
.
y
=
0
;
}
ScrollSnapFlags
snapFlags
=
ScrollSnapFlags
:
:
Disabled
;
mozilla
:
:
ScrollOrigin
origin
=
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
;
switch
(
aEvent
-
>
mDeltaMode
)
{
case
WheelEvent_Binding
:
:
DOM_DELTA_LINE
:
origin
=
mozilla
:
:
ScrollOrigin
:
:
MouseWheel
;
snapFlags
=
ScrollSnapFlags
:
:
IntendedDirection
;
break
;
case
WheelEvent_Binding
:
:
DOM_DELTA_PAGE
:
origin
=
mozilla
:
:
ScrollOrigin
:
:
Pages
;
snapFlags
=
ScrollSnapFlags
:
:
IntendedDirection
|
ScrollSnapFlags
:
:
IntendedEndPosition
;
break
;
case
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
:
origin
=
mozilla
:
:
ScrollOrigin
:
:
Pixels
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
deltaMode
value
comes
"
)
;
}
nsSize
pageSize
=
aScrollableFrame
-
>
GetPageScrollAmount
(
)
;
nsIntSize
devPixelPageSize
(
pc
-
>
AppUnitsToDevPixels
(
pageSize
.
width
)
pc
-
>
AppUnitsToDevPixels
(
pageSize
.
height
)
)
;
if
(
!
WheelPrefs
:
:
GetInstance
(
)
-
>
IsOverOnePageScrollAllowedX
(
aEvent
)
&
&
DeprecatedAbs
(
actualDevPixelScrollAmount
.
x
)
>
devPixelPageSize
.
width
)
{
actualDevPixelScrollAmount
.
x
=
(
actualDevPixelScrollAmount
.
x
>
=
0
)
?
devPixelPageSize
.
width
:
-
devPixelPageSize
.
width
;
}
if
(
!
WheelPrefs
:
:
GetInstance
(
)
-
>
IsOverOnePageScrollAllowedY
(
aEvent
)
&
&
DeprecatedAbs
(
actualDevPixelScrollAmount
.
y
)
>
devPixelPageSize
.
height
)
{
actualDevPixelScrollAmount
.
y
=
(
actualDevPixelScrollAmount
.
y
>
=
0
)
?
devPixelPageSize
.
height
:
-
devPixelPageSize
.
height
;
}
bool
isDeltaModePixel
=
(
aEvent
-
>
mDeltaMode
=
=
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
)
;
ScrollMode
mode
;
switch
(
aEvent
-
>
mScrollType
)
{
case
WidgetWheelEvent
:
:
SCROLL_DEFAULT
:
if
(
isDeltaModePixel
)
{
mode
=
ScrollMode
:
:
Normal
;
}
else
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
mode
=
ScrollMode
:
:
SmoothMsd
;
}
else
{
mode
=
ScrollMode
:
:
Smooth
;
}
break
;
case
WidgetWheelEvent
:
:
SCROLL_SYNCHRONOUSLY
:
mode
=
ScrollMode
:
:
Instant
;
break
;
case
WidgetWheelEvent
:
:
SCROLL_ASYNCHRONOUSLY
:
mode
=
ScrollMode
:
:
Normal
;
break
;
case
WidgetWheelEvent
:
:
SCROLL_SMOOTHLY
:
mode
=
ScrollMode
:
:
Smooth
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
mScrollType
value
comes
"
)
;
}
nsIScrollableFrame
:
:
ScrollMomentum
momentum
=
aEvent
-
>
mIsMomentum
?
nsIScrollableFrame
:
:
SYNTHESIZED_MOMENTUM_EVENT
:
nsIScrollableFrame
:
:
NOT_MOMENTUM
;
nsIntPoint
overflow
;
aScrollableFrame
-
>
ScrollBy
(
actualDevPixelScrollAmount
ScrollUnit
:
:
DEVICE_PIXELS
mode
&
overflow
origin
momentum
snapFlags
)
;
if
(
!
scrollFrameWeak
.
IsAlive
(
)
)
{
aEvent
-
>
mOverflowDeltaX
=
aEvent
-
>
mOverflowDeltaY
=
0
;
}
else
if
(
isDeltaModePixel
)
{
aEvent
-
>
mOverflowDeltaX
=
overflow
.
x
;
aEvent
-
>
mOverflowDeltaY
=
overflow
.
y
;
}
else
{
aEvent
-
>
mOverflowDeltaX
=
static_cast
<
double
>
(
overflow
.
x
)
/
scrollAmountInDevPixels
.
width
;
aEvent
-
>
mOverflowDeltaY
=
static_cast
<
double
>
(
overflow
.
y
)
/
scrollAmountInDevPixels
.
height
;
}
if
(
scrollFrameWeak
.
IsAlive
(
)
)
{
if
(
aEvent
-
>
mDeltaX
&
&
overflowStyle
.
mHorizontal
=
=
StyleOverflow
:
:
Hidden
&
&
!
ComputeScrollTargetAndMayAdjustWheelEvent
(
scrollFrame
aEvent
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_X_AXIS_WITH_AUTO_DIR
)
)
{
aEvent
-
>
mOverflowDeltaX
=
aEvent
-
>
mDeltaX
;
}
if
(
aEvent
-
>
mDeltaY
&
&
overflowStyle
.
mVertical
=
=
StyleOverflow
:
:
Hidden
&
&
!
ComputeScrollTargetAndMayAdjustWheelEvent
(
scrollFrame
aEvent
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_Y_AXIS_WITH_AUTO_DIR
)
)
{
aEvent
-
>
mOverflowDeltaY
=
aEvent
-
>
mDeltaY
;
}
}
NS_ASSERTION
(
aEvent
-
>
mOverflowDeltaX
=
=
0
|
|
(
aEvent
-
>
mOverflowDeltaX
>
0
)
=
=
(
aEvent
-
>
mDeltaX
>
0
)
"
The
sign
of
mOverflowDeltaX
is
different
from
the
scroll
direction
"
)
;
NS_ASSERTION
(
aEvent
-
>
mOverflowDeltaY
=
=
0
|
|
(
aEvent
-
>
mOverflowDeltaY
>
0
)
=
=
(
aEvent
-
>
mDeltaY
>
0
)
"
The
sign
of
mOverflowDeltaY
is
different
from
the
scroll
direction
"
)
;
WheelPrefs
:
:
GetInstance
(
)
-
>
CancelApplyingUserPrefsFromOverflowDelta
(
aEvent
)
;
}
void
EventStateManager
:
:
DecideGestureEvent
(
WidgetGestureNotifyEvent
*
aEvent
nsIFrame
*
targetFrame
)
{
NS_ASSERTION
(
aEvent
-
>
mMessage
=
=
eGestureNotify
"
DecideGestureEvent
called
with
a
non
-
gesture
event
"
)
;
WidgetGestureNotifyEvent
:
:
PanDirection
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanNone
;
bool
displayPanFeedback
=
false
;
for
(
nsIFrame
*
current
=
targetFrame
;
current
;
current
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
current
)
)
{
if
(
current
&
&
IsTopLevelRemoteTarget
(
current
-
>
GetContent
(
)
)
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanBoth
;
displayPanFeedback
=
false
;
break
;
}
LayoutFrameType
currentFrameType
=
current
-
>
Type
(
)
;
if
(
currentFrameType
=
=
LayoutFrameType
:
:
Scrollbar
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanNone
;
break
;
}
nsTreeBodyFrame
*
treeFrame
=
do_QueryFrame
(
current
)
;
if
(
treeFrame
)
{
if
(
treeFrame
-
>
GetHorizontalOverflow
(
)
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanHorizontal
;
}
if
(
treeFrame
-
>
GetVerticalOverflow
(
)
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanVertical
;
}
break
;
}
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
current
)
;
if
(
scrollableFrame
)
{
if
(
current
-
>
IsFrameOfType
(
nsIFrame
:
:
eXULBox
)
)
{
displayPanFeedback
=
true
;
nsRect
scrollRange
=
scrollableFrame
-
>
GetScrollRange
(
)
;
bool
canScrollHorizontally
=
scrollRange
.
width
>
0
;
if
(
targetFrame
-
>
IsMenuFrame
(
)
)
{
canScrollHorizontally
=
false
;
displayPanFeedback
=
false
;
}
if
(
scrollRange
.
height
>
0
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanVertical
;
break
;
}
if
(
canScrollHorizontally
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanHorizontal
;
displayPanFeedback
=
false
;
}
}
else
{
layers
:
:
ScrollDirections
scrollbarVisibility
=
scrollableFrame
-
>
GetScrollbarVisibility
(
)
;
if
(
scrollbarVisibility
.
contains
(
layers
:
:
ScrollDirection
:
:
eVertical
)
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanVertical
;
displayPanFeedback
=
true
;
break
;
}
if
(
scrollbarVisibility
.
contains
(
layers
:
:
ScrollDirection
:
:
eHorizontal
)
)
{
panDirection
=
WidgetGestureNotifyEvent
:
:
ePanHorizontal
;
displayPanFeedback
=
true
;
}
}
}
}
aEvent
-
>
mDisplayPanFeedback
=
displayPanFeedback
;
aEvent
-
>
mPanDirection
=
panDirection
;
}
#
ifdef
XP_MACOSX
static
nsINode
*
GetCrossDocParentNode
(
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
"
The
child
is
null
!
"
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsINode
*
parent
=
aChild
-
>
GetParentNode
(
)
;
if
(
parent
&
&
parent
-
>
IsContent
(
)
&
&
aChild
-
>
IsContent
(
)
)
{
parent
=
aChild
-
>
AsContent
(
)
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
parent
|
|
!
aChild
-
>
IsDocument
(
)
)
{
return
parent
;
}
return
aChild
-
>
AsDocument
(
)
-
>
GetEmbedderElement
(
)
;
}
static
bool
NodeAllowsClickThrough
(
nsINode
*
aNode
)
{
while
(
aNode
)
{
if
(
aNode
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
)
{
return
false
;
}
if
(
aNode
-
>
IsXULElement
(
)
)
{
mozilla
:
:
dom
:
:
Element
*
element
=
aNode
-
>
AsElement
(
)
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
always
nsGkAtoms
:
:
never
nullptr
}
;
switch
(
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
clickthrough
strings
eCaseMatters
)
)
{
case
0
:
return
true
;
case
1
:
return
false
;
}
}
aNode
=
GetCrossDocParentNode
(
aNode
)
;
}
return
true
;
}
#
endif
void
EventStateManager
:
:
PostHandleKeyboardEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
nsIFrame
*
aTargetFrame
nsEventStatus
&
aStatus
)
{
if
(
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
if
(
!
aKeyboardEvent
-
>
HasBeenPostedToRemoteProcess
(
)
)
{
if
(
aKeyboardEvent
-
>
IsWaitingReplyFromRemoteProcess
(
)
)
{
RefPtr
<
BrowserParent
>
remote
=
aTargetFrame
?
BrowserParent
:
:
GetFrom
(
aTargetFrame
-
>
GetContent
(
)
)
:
nullptr
;
if
(
remote
)
{
BrowserParent
*
preciseRemote
=
BrowserParent
:
:
GetFocused
(
)
;
if
(
preciseRemote
)
{
remote
=
preciseRemote
;
}
}
if
(
remote
&
&
!
remote
-
>
IsReadyToHandleInputEvents
(
)
)
{
WidgetKeyboardEvent
keyEvent
(
*
aKeyboardEvent
)
;
aKeyboardEvent
-
>
MarkAsHandledInRemoteProcess
(
)
;
RefPtr
<
Element
>
ownerElement
=
remote
-
>
GetOwnerElement
(
)
;
EventDispatcher
:
:
Dispatch
(
ownerElement
presContext
&
keyEvent
)
;
if
(
keyEvent
.
DefaultPrevented
(
)
)
{
aKeyboardEvent
-
>
PreventDefault
(
!
keyEvent
.
DefaultPreventedByContent
(
)
)
;
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
;
}
}
}
if
(
aKeyboardEvent
-
>
mWidget
)
{
aKeyboardEvent
-
>
mWidget
-
>
PostHandleKeyEvent
(
aKeyboardEvent
)
;
}
if
(
aKeyboardEvent
-
>
DefaultPrevented
(
)
)
{
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
;
}
}
switch
(
aKeyboardEvent
-
>
mKeyCode
)
{
case
NS_VK_TAB
:
case
NS_VK_F6
:
if
(
!
aKeyboardEvent
-
>
IsAlt
(
)
)
{
aStatus
=
nsEventStatus_eConsumeNoDefault
;
if
(
aKeyboardEvent
-
>
HasBeenPostedToRemoteProcess
(
)
)
{
break
;
}
EnsureDocument
(
presContext
)
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
mDocument
)
{
bool
isDocMove
=
aKeyboardEvent
-
>
IsControl
(
)
|
|
aKeyboardEvent
-
>
mKeyCode
=
=
NS_VK_F6
;
uint32_t
dir
=
aKeyboardEvent
-
>
IsShift
(
)
?
(
isDocMove
?
static_cast
<
uint32_t
>
(
nsIFocusManager
:
:
MOVEFOCUS_BACKWARDDOC
)
:
static_cast
<
uint32_t
>
(
nsIFocusManager
:
:
MOVEFOCUS_BACKWARD
)
)
:
(
isDocMove
?
static_cast
<
uint32_t
>
(
nsIFocusManager
:
:
MOVEFOCUS_FORWARDDOC
)
:
static_cast
<
uint32_t
>
(
nsIFocusManager
:
:
MOVEFOCUS_FORWARD
)
)
;
RefPtr
<
Element
>
result
;
fm
-
>
MoveFocus
(
mDocument
-
>
GetWindow
(
)
nullptr
dir
nsIFocusManager
:
:
FLAG_BYKEY
getter_AddRefs
(
result
)
)
;
}
}
return
;
case
0
:
break
;
default
:
return
;
}
switch
(
aKeyboardEvent
-
>
mKeyNameIndex
)
{
case
KEY_NAME_INDEX_ZoomIn
:
case
KEY_NAME_INDEX_ZoomOut
:
ChangeZoom
(
aKeyboardEvent
-
>
mKeyNameIndex
=
=
KEY_NAME_INDEX_ZoomIn
)
;
aStatus
=
nsEventStatus_eConsumeNoDefault
;
break
;
default
:
break
;
}
}
nsresult
EventStateManager
:
:
PostHandleEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIFrame
*
aTargetFrame
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
{
NS_ENSURE_ARG
(
aPresContext
)
;
NS_ENSURE_ARG_POINTER
(
aStatus
)
;
mCurrentTarget
=
aTargetFrame
;
mCurrentTargetContent
=
nullptr
;
HandleCrossProcessEvent
(
aEvent
aStatus
)
;
aTargetFrame
=
nullptr
;
if
(
!
mCurrentTarget
&
&
aEvent
-
>
mMessage
!
=
eMouseUp
&
&
aEvent
-
>
mMessage
!
=
eMouseDown
&
&
aEvent
-
>
mMessage
!
=
eDragEnter
&
&
aEvent
-
>
mMessage
!
=
eDragOver
&
&
aEvent
-
>
mMessage
!
=
ePointerUp
&
&
aEvent
-
>
mMessage
!
=
ePointerCancel
)
{
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
presContext
=
aPresContext
;
nsresult
ret
=
NS_OK
;
switch
(
aEvent
-
>
mMessage
)
{
case
eMouseDown
:
{
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
mButton
=
=
MouseButton
:
:
ePrimary
&
&
!
sNormalLMouseEventInProcess
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
break
;
}
if
(
aEvent
-
>
HasBeenPostedToRemoteProcess
(
)
&
&
!
PresShell
:
:
GetCapturingContent
(
)
)
{
if
(
nsIContent
*
content
=
mCurrentTarget
?
mCurrentTarget
-
>
GetContent
(
)
:
nullptr
)
{
PresShell
:
:
SetCapturingContent
(
content
CaptureFlags
:
:
None
aEvent
)
;
}
else
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
if
(
mouseEvent
-
>
mClickEventPrevented
)
{
RefPtr
<
EventStateManager
>
esm
=
ESMFromContentOrThis
(
aOverrideClickTarget
)
;
switch
(
mouseEvent
-
>
mButton
)
{
case
MouseButton
:
:
ePrimary
:
esm
-
>
mLastLeftMouseDownContent
=
nullptr
;
esm
-
>
mLClickCount
=
0
;
break
;
case
MouseButton
:
:
eSecondary
:
esm
-
>
mLastMiddleMouseDownContent
=
nullptr
;
esm
-
>
mMClickCount
=
0
;
break
;
case
MouseButton
:
:
eMiddle
:
esm
-
>
mLastRightMouseDownContent
=
nullptr
;
esm
-
>
mRClickCount
=
0
;
break
;
default
:
break
;
}
}
nsCOMPtr
<
nsIContent
>
activeContent
;
if
(
nsEventStatus_eConsumeNoDefault
!
=
*
aStatus
&
&
!
aEvent
-
>
DefaultPrevented
(
)
)
{
nsCOMPtr
<
nsIContent
>
newFocus
;
bool
suppressBlur
=
false
;
if
(
mCurrentTarget
)
{
mCurrentTarget
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
newFocus
)
)
;
activeContent
=
mCurrentTarget
-
>
GetContent
(
)
;
suppressBlur
=
mCurrentTarget
-
>
StyleUI
(
)
-
>
UserFocus
(
)
=
=
StyleUserFocus
:
:
Ignore
;
if
(
!
suppressBlur
)
{
if
(
Element
*
element
=
Element
:
:
FromEventTargetOrNull
(
aEvent
-
>
mTarget
)
)
{
if
(
nsCOMPtr
<
nsIDOMXULControlElement
>
xulControl
=
element
-
>
AsXULControl
(
)
)
{
bool
disabled
=
false
;
xulControl
-
>
GetDisabled
(
&
disabled
)
;
suppressBlur
=
disabled
;
}
}
}
}
if
(
newFocus
&
&
!
newFocus
-
>
IsEditable
(
)
)
{
Document
*
doc
=
newFocus
-
>
GetComposedDoc
(
)
;
if
(
doc
&
&
newFocus
=
=
doc
-
>
GetRootElement
(
)
)
{
nsIContent
*
bodyContent
=
nsLayoutUtils
:
:
GetEditableRootContentByContentEditable
(
doc
)
;
if
(
bodyContent
&
&
bodyContent
-
>
GetPrimaryFrame
(
)
)
{
newFocus
=
bodyContent
;
}
}
}
for
(
;
newFocus
;
newFocus
=
newFocus
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
!
newFocus
-
>
IsElement
(
)
)
{
continue
;
}
nsIFrame
*
frame
=
newFocus
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
continue
;
}
if
(
frame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
MozPopup
)
{
newFocus
=
nullptr
;
break
;
}
if
(
frame
-
>
IsFocusable
(
true
)
)
{
break
;
}
if
(
ShadowRoot
*
root
=
newFocus
-
>
GetShadowRoot
(
)
)
{
if
(
root
-
>
DelegatesFocus
(
)
)
{
if
(
Element
*
firstFocusable
=
root
-
>
GetFirstFocusable
(
true
)
)
{
newFocus
=
firstFocusable
;
break
;
}
}
}
}
MOZ_ASSERT_IF
(
newFocus
newFocus
-
>
IsElement
(
)
)
;
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
if
(
newFocus
)
{
uint32_t
flags
=
nsIFocusManager
:
:
FLAG_BYMOUSE
|
nsIFocusManager
:
:
FLAG_NOSCROLL
;
if
(
mouseEvent
-
>
mInputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
flags
|
=
nsIFocusManager
:
:
FLAG_BYTOUCH
;
}
fm
-
>
SetFocus
(
MOZ_KnownLive
(
newFocus
-
>
AsElement
(
)
)
flags
)
;
}
else
if
(
!
suppressBlur
)
{
EnsureDocument
(
mPresContext
)
;
if
(
mDocument
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerWindow
=
mDocument
-
>
GetWindow
(
)
;
#
ifdef
XP_MACOSX
if
(
!
activeContent
|
|
!
activeContent
-
>
IsXULElement
(
)
)
#
endif
fm
-
>
ClearFocus
(
outerWindow
)
;
if
(
XRE_IsParentProcess
(
)
|
|
IsInActiveTab
(
mDocument
)
)
{
fm
-
>
SetFocusedWindow
(
outerWindow
)
;
}
}
}
}
if
(
mouseEvent
-
>
mButton
!
=
MouseButton
:
:
ePrimary
)
{
break
;
}
if
(
activeContent
&
&
!
activeContent
-
>
IsElement
(
)
)
{
if
(
nsIContent
*
par
=
activeContent
-
>
GetFlattenedTreeParent
(
)
)
{
activeContent
=
par
;
}
}
}
else
{
StopTrackingDragGesture
(
true
)
;
}
SetActiveManager
(
this
activeContent
)
;
}
break
;
case
ePointerCancel
:
case
ePointerUp
:
{
WidgetPointerEvent
*
pointerEvent
=
aEvent
-
>
AsPointerEvent
(
)
;
MOZ_ASSERT
(
pointerEvent
)
;
PointerEventHandler
:
:
ImplicitlyReleasePointerCapture
(
pointerEvent
)
;
PointerEventHandler
:
:
UpdateActivePointerState
(
pointerEvent
)
;
if
(
pointerEvent
-
>
mMessage
=
=
ePointerCancel
|
|
pointerEvent
-
>
mInputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
GenerateMouseEnterExit
(
pointerEvent
)
;
mPointersEnterLeaveHelper
.
Remove
(
pointerEvent
-
>
pointerId
)
;
}
break
;
}
case
eMouseUp
:
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
ClearGlobalActiveContent
(
this
)
;
WidgetMouseEvent
*
mouseUpEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseUpEvent
&
&
EventCausesClickEvents
(
*
mouseUpEvent
)
)
{
RefPtr
<
EventStateManager
>
esm
=
ESMFromContentOrThis
(
aOverrideClickTarget
)
;
ret
=
esm
-
>
PostHandleMouseUp
(
mouseUpEvent
aStatus
aOverrideClickTarget
)
;
}
if
(
PresShell
*
presShell
=
presContext
-
>
GetPresShell
(
)
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
presShell
-
>
FrameSelection
(
)
;
frameSelection
-
>
SetDragState
(
false
)
;
}
}
break
;
case
eWheelOperationEnd
:
{
MOZ_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
ScrollbarsForWheel
:
:
MayInactivate
(
)
;
WidgetWheelEvent
*
wheelEvent
=
aEvent
-
>
AsWheelEvent
(
)
;
nsIScrollableFrame
*
scrollTarget
=
do_QueryFrame
(
ComputeScrollTargetAndMayAdjustWheelEvent
(
mCurrentTarget
wheelEvent
COMPUTE_DEFAULT_ACTION_TARGET_WITH_AUTO_DIR
)
)
;
if
(
scrollTarget
)
{
scrollTarget
-
>
ScrollSnap
(
)
;
}
}
break
;
case
eWheel
:
case
eWheelOperationStart
:
{
MOZ_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
if
(
*
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
ScrollbarsForWheel
:
:
Inactivate
(
)
;
break
;
}
WidgetWheelEvent
*
wheelEvent
=
aEvent
-
>
AsWheelEvent
(
)
;
MOZ_ASSERT
(
wheelEvent
)
;
WheelPrefs
:
:
Action
action
=
wheelEvent
-
>
mFlags
.
mHandledByAPZ
?
WheelPrefs
:
:
ACTION_NONE
:
WheelPrefs
:
:
GetInstance
(
)
-
>
ComputeActionFor
(
wheelEvent
)
;
WheelDeltaAdjustmentStrategy
strategy
=
GetWheelDeltaAdjustmentStrategy
(
*
wheelEvent
)
;
WheelDeltaHorizontalizer
horizontalizer
(
*
wheelEvent
)
;
if
(
WheelDeltaAdjustmentStrategy
:
:
eHorizontalize
=
=
strategy
)
{
horizontalizer
.
Horizontalize
(
)
;
}
ESMAutoDirWheelDeltaRestorer
restorer
(
*
wheelEvent
)
;
nsIFrame
*
frameToScroll
=
ComputeScrollTargetAndMayAdjustWheelEvent
(
mCurrentTarget
wheelEvent
COMPUTE_DEFAULT_ACTION_TARGET_WITH_AUTO_DIR
)
;
switch
(
action
)
{
case
WheelPrefs
:
:
ACTION_SCROLL
:
case
WheelPrefs
:
:
ACTION_HORIZONTALIZED_SCROLL
:
{
ScrollbarsForWheel
:
:
PrepareToScrollText
(
this
mCurrentTarget
wheelEvent
)
;
if
(
aEvent
-
>
mMessage
!
=
eWheel
|
|
(
!
wheelEvent
-
>
mDeltaX
&
&
!
wheelEvent
-
>
mDeltaY
)
)
{
break
;
}
nsIScrollableFrame
*
scrollTarget
=
do_QueryFrame
(
frameToScroll
)
;
ScrollbarsForWheel
:
:
SetActiveScrollTarget
(
scrollTarget
)
;
nsIFrame
*
rootScrollFrame
=
!
mCurrentTarget
?
nullptr
:
mCurrentTarget
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
nsIScrollableFrame
*
rootScrollableFrame
=
nullptr
;
if
(
rootScrollFrame
)
{
rootScrollableFrame
=
do_QueryFrame
(
rootScrollFrame
)
;
}
if
(
!
scrollTarget
|
|
scrollTarget
=
=
rootScrollableFrame
)
{
wheelEvent
-
>
mViewPortIsOverscrolled
=
true
;
}
wheelEvent
-
>
mOverflowDeltaX
=
wheelEvent
-
>
mDeltaX
;
wheelEvent
-
>
mOverflowDeltaY
=
wheelEvent
-
>
mDeltaY
;
WheelPrefs
:
:
GetInstance
(
)
-
>
CancelApplyingUserPrefsFromOverflowDelta
(
wheelEvent
)
;
if
(
scrollTarget
)
{
DoScrollText
(
scrollTarget
wheelEvent
)
;
}
else
{
WheelTransaction
:
:
EndTransaction
(
)
;
ScrollbarsForWheel
:
:
Inactivate
(
)
;
}
break
;
}
case
WheelPrefs
:
:
ACTION_HISTORY
:
{
int32_t
intDelta
=
wheelEvent
-
>
GetPreferredIntDelta
(
)
;
if
(
!
intDelta
)
{
break
;
}
DoScrollHistory
(
intDelta
)
;
break
;
}
case
WheelPrefs
:
:
ACTION_ZOOM
:
{
int32_t
intDelta
=
wheelEvent
-
>
GetPreferredIntDelta
(
)
;
if
(
!
intDelta
)
{
break
;
}
DoScrollZoom
(
mCurrentTarget
intDelta
)
;
break
;
}
case
WheelPrefs
:
:
ACTION_NONE
:
default
:
bool
allDeltaOverflown
=
false
;
if
(
wheelEvent
-
>
mFlags
.
mHandledByAPZ
)
{
if
(
wheelEvent
-
>
mCanTriggerSwipe
)
{
allDeltaOverflown
=
!
ComputeScrollTarget
(
mCurrentTarget
wheelEvent
COMPUTE_DEFAULT_ACTION_TARGET
)
;
}
}
else
{
allDeltaOverflown
=
true
;
}
if
(
!
allDeltaOverflown
)
{
break
;
}
wheelEvent
-
>
mOverflowDeltaX
=
wheelEvent
-
>
mDeltaX
;
wheelEvent
-
>
mOverflowDeltaY
=
wheelEvent
-
>
mDeltaY
;
WheelPrefs
:
:
GetInstance
(
)
-
>
CancelApplyingUserPrefsFromOverflowDelta
(
wheelEvent
)
;
wheelEvent
-
>
mViewPortIsOverscrolled
=
true
;
break
;
}
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
}
break
;
case
eGestureNotify
:
{
if
(
nsEventStatus_eConsumeNoDefault
!
=
*
aStatus
)
{
DecideGestureEvent
(
aEvent
-
>
AsGestureNotifyEvent
(
)
mCurrentTarget
)
;
}
}
break
;
case
eDragEnter
:
case
eDragOver
:
{
NS_ASSERTION
(
aEvent
-
>
mClass
=
=
eDragEventClass
"
Expected
a
drag
event
"
)
;
if
(
mCurrentTarget
&
&
aEvent
-
>
mMessage
=
=
eDragOver
)
{
nsIFrame
*
checkFrame
=
mCurrentTarget
;
while
(
checkFrame
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
checkFrame
)
;
if
(
scrollFrame
&
&
scrollFrame
-
>
DragScroll
(
aEvent
)
)
{
break
;
}
checkFrame
=
checkFrame
-
>
GetParent
(
)
;
}
}
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
!
dragSession
)
break
;
dragSession
-
>
SetOnlyChromeDrop
(
false
)
;
if
(
mPresContext
)
{
EnsureDocument
(
mPresContext
)
;
}
bool
isChromeDoc
=
nsContentUtils
:
:
IsChromeDoc
(
mDocument
)
;
RefPtr
<
DataTransfer
>
dataTransfer
;
RefPtr
<
DataTransfer
>
initialDataTransfer
=
dragSession
-
>
GetDataTransfer
(
)
;
WidgetDragEvent
*
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
UpdateDragDataTransfer
(
dragEvent
)
;
uint32_t
dropEffect
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
uint32_t
action
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aStatus
)
{
if
(
dragEvent
-
>
mDataTransfer
)
{
dataTransfer
=
dragEvent
-
>
mDataTransfer
;
dropEffect
=
dataTransfer
-
>
DropEffectInt
(
)
;
}
else
{
dataTransfer
=
initialDataTransfer
;
dragSession
-
>
GetDragAction
(
&
action
)
;
dropEffect
=
nsContentUtils
:
:
FilterDropEffect
(
action
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
;
}
uint32_t
effectAllowed
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
;
if
(
dataTransfer
)
{
effectAllowed
=
dataTransfer
-
>
EffectAllowedInt
(
)
;
}
if
(
effectAllowed
=
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
|
|
dropEffect
&
effectAllowed
)
action
=
dropEffect
;
if
(
action
=
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
dropEffect
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
dragSession
-
>
SetDragAction
(
action
)
;
dragSession
-
>
SetCanDrop
(
action
!
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
;
if
(
aEvent
-
>
mMessage
=
=
eDragOver
&
&
!
isChromeDoc
)
{
dragSession
-
>
SetOnlyChromeDrop
(
!
dragEvent
-
>
mDefaultPreventedOnContent
)
;
}
}
else
if
(
aEvent
-
>
mMessage
=
=
eDragOver
&
&
!
isChromeDoc
)
{
dragSession
-
>
SetOnlyChromeDrop
(
true
)
;
}
if
(
ContentChild
*
child
=
ContentChild
:
:
GetSingleton
(
)
)
{
child
-
>
SendUpdateDropEffect
(
action
dropEffect
)
;
}
if
(
aEvent
-
>
HasBeenPostedToRemoteProcess
(
)
)
{
dragSession
-
>
SetCanDrop
(
true
)
;
}
else
if
(
initialDataTransfer
)
{
initialDataTransfer
-
>
SetDropEffectInt
(
dropEffect
)
;
}
}
break
;
case
eDrop
:
{
if
(
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
)
{
if
(
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
)
{
MOZ_ASSERT
(
dragSession
-
>
IsSynthesizedForTests
(
)
)
;
RefPtr
<
WindowContext
>
sourceWC
;
DebugOnly
<
nsresult
>
rvIgnored
=
dragSession
-
>
GetSourceWindowContext
(
getter_AddRefs
(
sourceWC
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
nsIDragSession
:
:
GetSourceDocument
(
)
failed
but
ignored
"
)
;
if
(
sourceWC
)
{
CSSIntPoint
dropPointInScreen
=
Event
:
:
GetScreenCoords
(
aPresContext
aEvent
aEvent
-
>
mRefPoint
)
.
extract
(
)
;
dragSession
-
>
SetDragEndPointForTests
(
dropPointInScreen
.
x
dropPointInScreen
.
y
)
;
}
}
}
sLastDragOverFrame
=
nullptr
;
ClearGlobalActiveContent
(
this
)
;
break
;
}
case
eDragExit
:
GenerateDragDropEnterExit
(
presContext
aEvent
-
>
AsDragEvent
(
)
)
;
if
(
ContentChild
*
child
=
ContentChild
:
:
GetSingleton
(
)
)
{
child
-
>
SendUpdateDropEffect
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
;
}
break
;
case
eKeyUp
:
break
;
case
eKeyPress
:
{
WidgetKeyboardEvent
*
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
PostHandleKeyboardEvent
(
keyEvent
mCurrentTarget
*
aStatus
)
;
}
break
;
case
eMouseEnterIntoWidget
:
if
(
mCurrentTarget
)
{
nsCOMPtr
<
nsIContent
>
targetContent
;
mCurrentTarget
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
targetContent
)
)
;
SetContentState
(
targetContent
ElementState
:
:
HOVER
)
;
}
break
;
case
eMouseExitFromWidget
:
PointerEventHandler
:
:
UpdateActivePointerState
(
aEvent
-
>
AsMouseEvent
(
)
)
;
break
;
#
ifdef
XP_MACOSX
case
eMouseActivate
:
if
(
mCurrentTarget
)
{
nsCOMPtr
<
nsIContent
>
targetContent
;
mCurrentTarget
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
targetContent
)
)
;
if
(
!
NodeAllowsClickThrough
(
targetContent
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
break
;
#
endif
default
:
break
;
}
mCurrentTarget
=
nullptr
;
mCurrentTargetContent
=
nullptr
;
return
ret
;
}
BrowserParent
*
EventStateManager
:
:
GetCrossProcessTarget
(
)
{
return
IMEStateManager
:
:
GetActiveBrowserParent
(
)
;
}
bool
EventStateManager
:
:
IsTargetCrossProcess
(
WidgetGUIEvent
*
aEvent
)
{
Element
*
focusedElement
=
GetFocusedElement
(
)
;
if
(
focusedElement
&
&
focusedElement
-
>
IsEditable
(
)
)
{
return
false
;
}
return
IMEStateManager
:
:
GetActiveBrowserParent
(
)
!
=
nullptr
;
}
void
EventStateManager
:
:
NotifyDestroyPresContext
(
nsPresContext
*
aPresContext
)
{
RefPtr
<
nsPresContext
>
presContext
=
aPresContext
;
if
(
presContext
)
{
IMEStateManager
:
:
OnDestroyPresContext
(
*
presContext
)
;
}
if
(
mHoverContent
)
{
SetContentState
(
nullptr
ElementState
:
:
HOVER
)
;
}
mPointersEnterLeaveHelper
.
Clear
(
)
;
PointerEventHandler
:
:
NotifyDestroyPresContext
(
presContext
)
;
}
void
EventStateManager
:
:
SetPresContext
(
nsPresContext
*
aPresContext
)
{
mPresContext
=
aPresContext
;
}
void
EventStateManager
:
:
ClearFrameRefs
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
&
&
aFrame
=
=
mCurrentTarget
)
{
mCurrentTargetContent
=
aFrame
-
>
GetContent
(
)
;
}
}
struct
CursorImage
{
gfx
:
:
IntPoint
mHotspot
;
nsCOMPtr
<
imgIContainer
>
mContainer
;
ImageResolution
mResolution
;
bool
mEarlierCursorLoading
=
false
;
}
;
static
bool
ShouldBlockCustomCursor
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
CursorImage
&
aCursor
)
{
if
(
!
StaticPrefs
:
:
layout_cursor_block_enabled
(
)
)
{
return
false
;
}
int32_t
width
=
0
;
int32_t
height
=
0
;
aCursor
.
mContainer
-
>
GetWidth
(
&
width
)
;
aCursor
.
mContainer
-
>
GetHeight
(
&
height
)
;
aCursor
.
mResolution
.
ApplyTo
(
width
height
)
;
int32_t
maxSize
=
StaticPrefs
:
:
layout_cursor_block_max_size
(
)
;
if
(
width
<
=
maxSize
&
&
height
<
=
maxSize
)
{
return
false
;
}
nsPresContext
*
topLevel
=
aPresContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
!
topLevel
)
{
return
false
;
}
nsPoint
point
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
topLevel
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
}
)
;
float
zoom
=
topLevel
-
>
GetFullZoom
(
)
;
zoom
/
=
LookAndFeel
:
:
GetFloat
(
LookAndFeel
:
:
FloatID
:
:
CursorScale
1
.
0f
)
;
nsSize
size
(
CSSPixel
:
:
ToAppUnits
(
width
/
zoom
)
CSSPixel
:
:
ToAppUnits
(
height
/
zoom
)
)
;
nsPoint
hotspot
(
CSSPixel
:
:
ToAppUnits
(
aCursor
.
mHotspot
.
x
/
zoom
)
CSSPixel
:
:
ToAppUnits
(
aCursor
.
mHotspot
.
y
/
zoom
)
)
;
nsRect
cursorRect
(
point
-
hotspot
size
)
;
return
!
topLevel
-
>
GetVisibleArea
(
)
.
Contains
(
cursorRect
)
;
}
static
gfx
:
:
IntPoint
ComputeHotspot
(
imgIContainer
*
aContainer
const
Maybe
<
gfx
:
:
Point
>
&
aHotspot
)
{
MOZ_ASSERT
(
aContainer
)
;
if
(
aHotspot
)
{
int32_t
imgWidth
imgHeight
;
aContainer
-
>
GetWidth
(
&
imgWidth
)
;
aContainer
-
>
GetHeight
(
&
imgHeight
)
;
auto
hotspot
=
gfx
:
:
IntPoint
:
:
Round
(
*
aHotspot
)
;
return
{
std
:
:
max
(
std
:
:
min
(
hotspot
.
x
imgWidth
-
1
)
0
)
std
:
:
max
(
std
:
:
min
(
hotspot
.
y
imgHeight
-
1
)
0
)
}
;
}
gfx
:
:
IntPoint
hotspot
;
aContainer
-
>
GetHotspotX
(
&
hotspot
.
x
)
;
aContainer
-
>
GetHotspotY
(
&
hotspot
.
y
)
;
return
hotspot
;
}
static
CursorImage
ComputeCustomCursor
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
nsIFrame
&
aFrame
const
nsIFrame
:
:
Cursor
&
aCursor
)
{
if
(
aCursor
.
mAllowCustomCursor
=
=
nsIFrame
:
:
AllowCustomCursorImage
:
:
No
)
{
return
{
}
;
}
const
ComputedStyle
&
style
=
aCursor
.
mStyle
?
*
aCursor
.
mStyle
:
*
aFrame
.
Style
(
)
;
bool
loading
=
false
;
for
(
const
auto
&
image
:
style
.
StyleUI
(
)
-
>
Cursor
(
)
.
images
.
AsSpan
(
)
)
{
MOZ_ASSERT
(
image
.
image
.
IsImageRequestType
(
)
"
Cursor
image
should
only
parse
url
(
)
types
"
)
;
uint32_t
status
;
imgRequestProxy
*
req
=
image
.
image
.
GetImageRequest
(
)
;
if
(
!
req
|
|
NS_FAILED
(
req
-
>
GetImageStatus
(
&
status
)
)
)
{
continue
;
}
if
(
!
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
)
{
loading
=
true
;
continue
;
}
if
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
{
continue
;
}
nsCOMPtr
<
imgIContainer
>
container
;
req
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
if
(
!
container
)
{
continue
;
}
container
=
nsLayoutUtils
:
:
OrientImage
(
container
aFrame
.
StyleVisibility
(
)
-
>
mImageOrientation
)
;
Maybe
<
gfx
:
:
Point
>
specifiedHotspot
=
image
.
has_hotspot
?
Some
(
gfx
:
:
Point
{
image
.
hotspot_x
image
.
hotspot_y
}
)
:
Nothing
(
)
;
gfx
:
:
IntPoint
hotspot
=
ComputeHotspot
(
container
specifiedHotspot
)
;
CursorImage
result
{
hotspot
std
:
:
move
(
container
)
image
.
image
.
GetResolution
(
)
loading
}
;
if
(
ShouldBlockCustomCursor
(
aPresContext
aEvent
result
)
)
{
continue
;
}
return
result
;
}
return
{
{
}
nullptr
{
}
loading
}
;
}
void
EventStateManager
:
:
UpdateCursor
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIFrame
*
aTargetFrame
nsEventStatus
*
aStatus
)
{
if
(
aTargetFrame
&
&
IsRemoteTarget
(
aTargetFrame
-
>
GetContent
(
)
)
)
{
return
;
}
auto
cursor
=
StyleCursorKind
:
:
Default
;
nsCOMPtr
<
imgIContainer
>
container
;
ImageResolution
resolution
;
Maybe
<
gfx
:
:
IntPoint
>
hotspot
;
if
(
mLockCursor
!
=
kInvalidCursorKind
)
{
cursor
=
mLockCursor
;
}
else
if
(
aTargetFrame
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
aTargetFrame
}
)
;
Maybe
<
nsIFrame
:
:
Cursor
>
framecursor
=
aTargetFrame
-
>
GetCursor
(
pt
)
;
if
(
!
framecursor
)
{
if
(
XRE_IsContentProcess
(
)
)
{
mLastFrameConsumedSetCursor
=
true
;
}
return
;
}
if
(
mLastFrameConsumedSetCursor
)
{
ClearCachedWidgetCursor
(
aTargetFrame
)
;
mLastFrameConsumedSetCursor
=
false
;
}
const
CursorImage
customCursor
=
ComputeCustomCursor
(
aPresContext
aEvent
*
aTargetFrame
*
framecursor
)
;
if
(
customCursor
.
mEarlierCursorLoading
&
&
gLastCursorSourceFrame
=
=
aTargetFrame
&
&
TimeStamp
:
:
NowLoRes
(
)
-
gLastCursorUpdateTime
<
TimeDuration
:
:
FromMilliseconds
(
kCursorLoadingTimeout
)
)
{
return
;
}
cursor
=
framecursor
-
>
mCursor
;
container
=
std
:
:
move
(
customCursor
.
mContainer
)
;
resolution
=
customCursor
.
mResolution
;
hotspot
=
Some
(
customCursor
.
mHotspot
)
;
}
if
(
StaticPrefs
:
:
ui_use_activity_cursor
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
aPresContext
-
>
GetDocShell
(
)
)
;
if
(
!
docShell
)
return
;
auto
busyFlags
=
docShell
-
>
GetBusyFlags
(
)
;
if
(
busyFlags
&
nsIDocShell
:
:
BUSY_FLAGS_BUSY
&
&
(
cursor
=
=
StyleCursorKind
:
:
Auto
|
|
cursor
=
=
StyleCursorKind
:
:
Default
)
)
{
cursor
=
StyleCursorKind
:
:
Progress
;
container
=
nullptr
;
}
}
if
(
aTargetFrame
)
{
SetCursor
(
cursor
container
resolution
hotspot
aTargetFrame
-
>
GetNearestWidget
(
)
false
)
;
gLastCursorSourceFrame
=
aTargetFrame
;
gLastCursorUpdateTime
=
TimeStamp
:
:
NowLoRes
(
)
;
}
if
(
mLockCursor
!
=
kInvalidCursorKind
|
|
StyleCursorKind
:
:
Auto
!
=
cursor
)
{
*
aStatus
=
nsEventStatus_eConsumeDoDefault
;
}
}
void
EventStateManager
:
:
ClearCachedWidgetCursor
(
nsIFrame
*
aTargetFrame
)
{
if
(
!
aTargetFrame
)
{
return
;
}
nsIWidget
*
aWidget
=
aTargetFrame
-
>
GetNearestWidget
(
)
;
if
(
!
aWidget
)
{
return
;
}
aWidget
-
>
ClearCachedCursor
(
)
;
}
nsresult
EventStateManager
:
:
SetCursor
(
StyleCursorKind
aCursor
imgIContainer
*
aContainer
const
ImageResolution
&
aResolution
const
Maybe
<
gfx
:
:
IntPoint
>
&
aHotspot
nsIWidget
*
aWidget
bool
aLockCursor
)
{
EnsureDocument
(
mPresContext
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_FAILURE
)
;
sMouseOverDocument
=
mDocument
.
get
(
)
;
NS_ENSURE_TRUE
(
aWidget
NS_ERROR_FAILURE
)
;
if
(
aLockCursor
)
{
if
(
StyleCursorKind
:
:
Auto
!
=
aCursor
)
{
mLockCursor
=
aCursor
;
}
else
{
mLockCursor
=
kInvalidCursorKind
;
}
}
nsCursor
c
;
switch
(
aCursor
)
{
case
StyleCursorKind
:
:
Auto
:
case
StyleCursorKind
:
:
Default
:
c
=
eCursor_standard
;
break
;
case
StyleCursorKind
:
:
Pointer
:
c
=
eCursor_hyperlink
;
break
;
case
StyleCursorKind
:
:
Crosshair
:
c
=
eCursor_crosshair
;
break
;
case
StyleCursorKind
:
:
Move
:
c
=
eCursor_move
;
break
;
case
StyleCursorKind
:
:
Text
:
c
=
eCursor_select
;
break
;
case
StyleCursorKind
:
:
Wait
:
c
=
eCursor_wait
;
break
;
case
StyleCursorKind
:
:
Help
:
c
=
eCursor_help
;
break
;
case
StyleCursorKind
:
:
NResize
:
c
=
eCursor_n_resize
;
break
;
case
StyleCursorKind
:
:
SResize
:
c
=
eCursor_s_resize
;
break
;
case
StyleCursorKind
:
:
WResize
:
c
=
eCursor_w_resize
;
break
;
case
StyleCursorKind
:
:
EResize
:
c
=
eCursor_e_resize
;
break
;
case
StyleCursorKind
:
:
NwResize
:
c
=
eCursor_nw_resize
;
break
;
case
StyleCursorKind
:
:
SeResize
:
c
=
eCursor_se_resize
;
break
;
case
StyleCursorKind
:
:
NeResize
:
c
=
eCursor_ne_resize
;
break
;
case
StyleCursorKind
:
:
SwResize
:
c
=
eCursor_sw_resize
;
break
;
case
StyleCursorKind
:
:
Copy
:
c
=
eCursor_copy
;
break
;
case
StyleCursorKind
:
:
Alias
:
c
=
eCursor_alias
;
break
;
case
StyleCursorKind
:
:
ContextMenu
:
c
=
eCursor_context_menu
;
break
;
case
StyleCursorKind
:
:
Cell
:
c
=
eCursor_cell
;
break
;
case
StyleCursorKind
:
:
Grab
:
c
=
eCursor_grab
;
break
;
case
StyleCursorKind
:
:
Grabbing
:
c
=
eCursor_grabbing
;
break
;
case
StyleCursorKind
:
:
Progress
:
c
=
eCursor_spinning
;
break
;
case
StyleCursorKind
:
:
ZoomIn
:
c
=
eCursor_zoom_in
;
break
;
case
StyleCursorKind
:
:
ZoomOut
:
c
=
eCursor_zoom_out
;
break
;
case
StyleCursorKind
:
:
NotAllowed
:
c
=
eCursor_not_allowed
;
break
;
case
StyleCursorKind
:
:
ColResize
:
c
=
eCursor_col_resize
;
break
;
case
StyleCursorKind
:
:
RowResize
:
c
=
eCursor_row_resize
;
break
;
case
StyleCursorKind
:
:
NoDrop
:
c
=
eCursor_no_drop
;
break
;
case
StyleCursorKind
:
:
VerticalText
:
c
=
eCursor_vertical_text
;
break
;
case
StyleCursorKind
:
:
AllScroll
:
c
=
eCursor_all_scroll
;
break
;
case
StyleCursorKind
:
:
NeswResize
:
c
=
eCursor_nesw_resize
;
break
;
case
StyleCursorKind
:
:
NwseResize
:
c
=
eCursor_nwse_resize
;
break
;
case
StyleCursorKind
:
:
NsResize
:
c
=
eCursor_ns_resize
;
break
;
case
StyleCursorKind
:
:
EwResize
:
c
=
eCursor_ew_resize
;
break
;
case
StyleCursorKind
:
:
None
:
c
=
eCursor_none
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
cursor
kind
"
)
;
c
=
eCursor_standard
;
break
;
}
uint32_t
x
=
aHotspot
?
aHotspot
-
>
x
:
0
;
uint32_t
y
=
aHotspot
?
aHotspot
-
>
y
:
0
;
aWidget
-
>
SetCursor
(
nsIWidget
:
:
Cursor
{
c
aContainer
x
y
aResolution
}
)
;
return
NS_OK
;
}
class
MOZ_STACK_CLASS
ESMEventCB
:
public
EventDispatchingCallback
{
public
:
explicit
ESMEventCB
(
nsIContent
*
aTarget
)
:
mTarget
(
aTarget
)
{
}
MOZ_CAN_RUN_SCRIPT
void
HandleEvent
(
EventChainPostVisitor
&
aVisitor
)
override
{
if
(
aVisitor
.
mPresContext
)
{
nsIFrame
*
frame
=
aVisitor
.
mPresContext
-
>
GetPrimaryFrameFor
(
mTarget
)
;
if
(
frame
)
{
frame
-
>
HandleEvent
(
aVisitor
.
mPresContext
aVisitor
.
mEvent
-
>
AsGUIEvent
(
)
&
aVisitor
.
mEventStatus
)
;
}
}
}
nsCOMPtr
<
nsIContent
>
mTarget
;
}
;
static
UniquePtr
<
WidgetMouseEvent
>
CreateMouseOrPointerWidgetEvent
(
WidgetMouseEvent
*
aMouseEvent
EventMessage
aMessage
EventTarget
*
aRelatedTarget
)
{
WidgetPointerEvent
*
sourcePointer
=
aMouseEvent
-
>
AsPointerEvent
(
)
;
UniquePtr
<
WidgetMouseEvent
>
newEvent
;
if
(
sourcePointer
)
{
AUTO_PROFILER_LABEL
(
"
CreateMouseOrPointerWidgetEvent
"
OTHER
)
;
WidgetPointerEvent
*
newPointerEvent
=
new
WidgetPointerEvent
(
aMouseEvent
-
>
IsTrusted
(
)
aMessage
aMouseEvent
-
>
mWidget
)
;
newPointerEvent
-
>
mIsPrimary
=
sourcePointer
-
>
mIsPrimary
;
newPointerEvent
-
>
mWidth
=
sourcePointer
-
>
mWidth
;
newPointerEvent
-
>
mHeight
=
sourcePointer
-
>
mHeight
;
newPointerEvent
-
>
mInputSource
=
sourcePointer
-
>
mInputSource
;
newEvent
=
WrapUnique
(
newPointerEvent
)
;
}
else
{
newEvent
=
MakeUnique
<
WidgetMouseEvent
>
(
aMouseEvent
-
>
IsTrusted
(
)
aMessage
aMouseEvent
-
>
mWidget
WidgetMouseEvent
:
:
eReal
)
;
}
newEvent
-
>
mRelatedTarget
=
aRelatedTarget
;
newEvent
-
>
mRefPoint
=
aMouseEvent
-
>
mRefPoint
;
newEvent
-
>
mModifiers
=
aMouseEvent
-
>
mModifiers
;
newEvent
-
>
mButton
=
aMouseEvent
-
>
mButton
;
newEvent
-
>
mButtons
=
aMouseEvent
-
>
mButtons
;
newEvent
-
>
mPressure
=
aMouseEvent
-
>
mPressure
;
newEvent
-
>
mInputSource
=
aMouseEvent
-
>
mInputSource
;
newEvent
-
>
pointerId
=
aMouseEvent
-
>
pointerId
;
return
newEvent
;
}
nsIFrame
*
EventStateManager
:
:
DispatchMouseOrPointerEvent
(
WidgetMouseEvent
*
aMouseEvent
EventMessage
aMessage
nsIContent
*
aTargetContent
nsIContent
*
aRelatedContent
)
{
if
(
PointerLockManager
:
:
IsLocked
(
)
&
&
(
aMessage
=
=
eMouseLeave
|
|
aMessage
=
=
eMouseEnter
|
|
aMessage
=
=
eMouseOver
|
|
aMessage
=
=
eMouseOut
)
)
{
mCurrentTargetContent
=
nullptr
;
nsCOMPtr
<
Element
>
pointerLockedElement
=
PointerLockManager
:
:
GetLockedElement
(
)
;
if
(
!
pointerLockedElement
)
{
NS_WARNING
(
"
Should
have
pointer
locked
element
but
didn
'
t
.
"
)
;
return
nullptr
;
}
return
mPresContext
-
>
GetPrimaryFrameFor
(
pointerLockedElement
)
;
}
mCurrentTargetContent
=
nullptr
;
if
(
!
aTargetContent
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
targetContent
=
aTargetContent
;
nsCOMPtr
<
nsIContent
>
relatedContent
=
aRelatedContent
;
UniquePtr
<
WidgetMouseEvent
>
dispatchEvent
=
CreateMouseOrPointerWidgetEvent
(
aMouseEvent
aMessage
relatedContent
)
;
AutoWeakFrame
previousTarget
=
mCurrentTarget
;
mCurrentTargetContent
=
targetContent
;
nsIFrame
*
targetFrame
=
nullptr
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
ESMEventCB
callback
(
targetContent
)
;
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
EventDispatcher
:
:
Dispatch
(
targetContent
presContext
dispatchEvent
.
get
(
)
nullptr
&
status
&
callback
)
;
if
(
mPresContext
)
{
targetFrame
=
mPresContext
-
>
GetPrimaryFrameFor
(
targetContent
)
;
if
(
IsTopLevelRemoteTarget
(
targetContent
)
)
{
if
(
aMessage
=
=
eMouseOut
)
{
UniquePtr
<
WidgetMouseEvent
>
remoteEvent
=
CreateMouseOrPointerWidgetEvent
(
aMouseEvent
eMouseExitFromWidget
relatedContent
)
;
remoteEvent
-
>
mExitFrom
=
Some
(
WidgetMouseEvent
:
:
ePuppet
)
;
mCurrentTarget
=
targetFrame
;
HandleCrossProcessEvent
(
remoteEvent
.
get
(
)
&
status
)
;
}
else
if
(
aMessage
=
=
eMouseOver
)
{
UniquePtr
<
WidgetMouseEvent
>
remoteEvent
=
CreateMouseOrPointerWidgetEvent
(
aMouseEvent
eMouseEnterIntoWidget
relatedContent
)
;
HandleCrossProcessEvent
(
remoteEvent
.
get
(
)
&
status
)
;
}
}
}
mCurrentTargetContent
=
nullptr
;
mCurrentTarget
=
previousTarget
;
return
targetFrame
;
}
static
nsIContent
*
FindCommonAncestor
(
nsIContent
*
aNode1
nsIContent
*
aNode2
)
{
if
(
!
aNode1
|
|
!
aNode2
)
{
return
nullptr
;
}
return
nsContentUtils
:
:
GetCommonFlattenedTreeAncestor
(
aNode1
aNode2
)
;
}
class
EnterLeaveDispatcher
{
public
:
EnterLeaveDispatcher
(
EventStateManager
*
aESM
nsIContent
*
aTarget
nsIContent
*
aRelatedTarget
WidgetMouseEvent
*
aMouseEvent
EventMessage
aEventMessage
)
:
mESM
(
aESM
)
mMouseEvent
(
aMouseEvent
)
mEventMessage
(
aEventMessage
)
{
nsPIDOMWindowInner
*
win
=
aTarget
?
aTarget
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
:
nullptr
;
if
(
aMouseEvent
-
>
AsPointerEvent
(
)
?
win
&
&
win
-
>
HasPointerEnterLeaveEventListeners
(
)
:
win
&
&
win
-
>
HasMouseEnterLeaveEventListeners
(
)
)
{
mRelatedTarget
=
aRelatedTarget
?
aRelatedTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
:
nullptr
;
nsINode
*
commonParent
=
FindCommonAncestor
(
aTarget
aRelatedTarget
)
;
nsIContent
*
current
=
aTarget
;
while
(
current
&
&
current
!
=
commonParent
)
{
if
(
!
current
-
>
ChromeOnlyAccess
(
)
)
{
mTargets
.
AppendObject
(
current
)
;
}
current
=
current
-
>
GetFlattenedTreeParent
(
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Dispatch
(
)
{
if
(
mEventMessage
=
=
eMouseEnter
|
|
mEventMessage
=
=
ePointerEnter
)
{
for
(
int32_t
i
=
mTargets
.
Count
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mESM
-
>
DispatchMouseOrPointerEvent
(
mMouseEvent
mEventMessage
MOZ_KnownLive
(
mTargets
[
i
]
)
mRelatedTarget
)
;
}
}
else
{
for
(
int32_t
i
=
0
;
i
<
mTargets
.
Count
(
)
;
+
+
i
)
{
mESM
-
>
DispatchMouseOrPointerEvent
(
mMouseEvent
mEventMessage
MOZ_KnownLive
(
mTargets
[
i
]
)
mRelatedTarget
)
;
}
}
}
const
RefPtr
<
EventStateManager
>
mESM
;
nsCOMArray
<
nsIContent
>
mTargets
;
MOZ_KNOWN_LIVE
nsCOMPtr
<
nsIContent
>
mRelatedTarget
;
WidgetMouseEvent
*
mMouseEvent
;
EventMessage
mEventMessage
;
}
;
void
EventStateManager
:
:
NotifyMouseOut
(
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
aMovingInto
)
{
RefPtr
<
OverOutElementsWrapper
>
wrapper
=
GetWrapperByEventID
(
aMouseEvent
)
;
if
(
!
wrapper
|
|
!
wrapper
-
>
mLastOverElement
)
{
return
;
}
if
(
wrapper
-
>
mLastOverElement
=
=
wrapper
-
>
mFirstOutEventElement
)
{
return
;
}
if
(
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
wrapper
-
>
mLastOverElement
)
)
{
if
(
BrowsingContext
*
bc
=
flo
-
>
GetExtantBrowsingContext
(
)
)
{
if
(
nsIDocShell
*
docshell
=
bc
-
>
GetDocShell
(
)
)
{
if
(
RefPtr
<
nsPresContext
>
presContext
=
docshell
-
>
GetPresContext
(
)
)
{
EventStateManager
*
kidESM
=
presContext
-
>
EventStateManager
(
)
;
kidESM
-
>
NotifyMouseOut
(
aMouseEvent
nullptr
)
;
}
}
}
}
if
(
!
wrapper
-
>
mLastOverElement
)
{
return
;
}
wrapper
-
>
mFirstOutEventElement
=
wrapper
-
>
mLastOverElement
;
bool
isPointer
=
aMouseEvent
-
>
mClass
=
=
ePointerEventClass
;
if
(
!
aMovingInto
&
&
!
isPointer
)
{
SetContentState
(
nullptr
ElementState
:
:
HOVER
)
;
}
EnterLeaveDispatcher
leaveDispatcher
(
this
wrapper
-
>
mLastOverElement
aMovingInto
aMouseEvent
isPointer
?
ePointerLeave
:
eMouseLeave
)
;
nsCOMPtr
<
nsIContent
>
lastOverElement
=
wrapper
-
>
mLastOverElement
;
DispatchMouseOrPointerEvent
(
aMouseEvent
isPointer
?
ePointerOut
:
eMouseOut
lastOverElement
aMovingInto
)
;
leaveDispatcher
.
Dispatch
(
)
;
wrapper
-
>
mLastOverFrame
=
nullptr
;
wrapper
-
>
mLastOverElement
=
nullptr
;
wrapper
-
>
mFirstOutEventElement
=
nullptr
;
}
void
EventStateManager
:
:
RecomputeMouseEnterStateForRemoteFrame
(
Element
&
aElement
)
{
if
(
!
mMouseEnterLeaveHelper
|
|
mMouseEnterLeaveHelper
-
>
mLastOverElement
!
=
&
aElement
)
{
return
;
}
if
(
BrowserParent
*
remote
=
BrowserParent
:
:
GetFrom
(
&
aElement
)
)
{
remote
-
>
MouseEnterIntoWidget
(
)
;
}
}
void
EventStateManager
:
:
NotifyMouseOver
(
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
aContent
)
{
NS_ASSERTION
(
aContent
"
Mouse
must
be
over
something
"
)
;
RefPtr
<
OverOutElementsWrapper
>
wrapper
=
GetWrapperByEventID
(
aMouseEvent
)
;
if
(
!
wrapper
|
|
wrapper
-
>
mLastOverElement
=
=
aContent
)
return
;
if
(
aContent
=
=
wrapper
-
>
mFirstOverEventElement
)
return
;
EnsureDocument
(
mPresContext
)
;
if
(
Document
*
parentDoc
=
mDocument
-
>
GetInProcessParentDocument
(
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
docContent
=
mDocument
-
>
GetEmbedderElement
(
)
)
{
if
(
PresShell
*
parentPresShell
=
parentDoc
-
>
GetPresShell
(
)
)
{
RefPtr
<
EventStateManager
>
parentESM
=
parentPresShell
-
>
GetPresContext
(
)
-
>
EventStateManager
(
)
;
parentESM
-
>
NotifyMouseOver
(
aMouseEvent
docContent
)
;
}
}
}
if
(
wrapper
-
>
mLastOverElement
=
=
aContent
)
return
;
nsCOMPtr
<
nsIContent
>
lastOverElement
=
wrapper
-
>
mLastOverElement
;
bool
isPointer
=
aMouseEvent
-
>
mClass
=
=
ePointerEventClass
;
EnterLeaveDispatcher
enterDispatcher
(
this
aContent
lastOverElement
aMouseEvent
isPointer
?
ePointerEnter
:
eMouseEnter
)
;
if
(
!
isPointer
)
{
SetContentState
(
aContent
ElementState
:
:
HOVER
)
;
}
NotifyMouseOut
(
aMouseEvent
aContent
)
;
wrapper
-
>
mFirstOverEventElement
=
aContent
;
wrapper
-
>
mLastOverFrame
=
DispatchMouseOrPointerEvent
(
aMouseEvent
isPointer
?
ePointerOver
:
eMouseOver
aContent
lastOverElement
)
;
enterDispatcher
.
Dispatch
(
)
;
wrapper
-
>
mLastOverElement
=
aContent
;
wrapper
-
>
mFirstOverEventElement
=
nullptr
;
}
static
LayoutDeviceIntPoint
GetWindowClientRectCenter
(
nsIWidget
*
aWidget
)
{
NS_ENSURE_TRUE
(
aWidget
LayoutDeviceIntPoint
(
0
0
)
)
;
LayoutDeviceIntRect
rect
=
aWidget
-
>
GetClientBounds
(
)
;
LayoutDeviceIntPoint
point
(
rect
.
x
+
rect
.
width
/
2
rect
.
y
+
rect
.
height
/
2
)
;
int32_t
round
=
aWidget
-
>
RoundsWidgetCoordinatesTo
(
)
;
point
.
x
=
point
.
x
/
round
*
round
;
point
.
y
=
point
.
y
/
round
*
round
;
return
point
-
aWidget
-
>
WidgetToScreenOffset
(
)
;
}
void
EventStateManager
:
:
GeneratePointerEnterExit
(
EventMessage
aMessage
WidgetMouseEvent
*
aEvent
)
{
WidgetPointerEvent
pointerEvent
(
*
aEvent
)
;
pointerEvent
.
mMessage
=
aMessage
;
GenerateMouseEnterExit
(
&
pointerEvent
)
;
}
void
EventStateManager
:
:
UpdateLastRefPointOfMouseEvent
(
WidgetMouseEvent
*
aMouseEvent
)
{
if
(
aMouseEvent
-
>
mMessage
!
=
eMouseMove
&
&
aMouseEvent
-
>
mMessage
!
=
ePointerMove
)
{
return
;
}
if
(
PointerLockManager
:
:
IsLocked
(
)
&
&
aMouseEvent
-
>
mWidget
)
{
aMouseEvent
-
>
mLastRefPoint
=
GetWindowClientRectCenter
(
aMouseEvent
-
>
mWidget
)
;
}
else
if
(
sLastRefPoint
=
=
kInvalidRefPoint
)
{
aMouseEvent
-
>
mLastRefPoint
=
aMouseEvent
-
>
mRefPoint
;
}
else
{
aMouseEvent
-
>
mLastRefPoint
=
sLastRefPoint
;
}
}
void
EventStateManager
:
:
ResetPointerToWindowCenterWhilePointerLocked
(
WidgetMouseEvent
*
aMouseEvent
)
{
MOZ_ASSERT
(
PointerLockManager
:
:
IsLocked
(
)
)
;
if
(
(
aMouseEvent
-
>
mMessage
!
=
eMouseMove
&
&
aMouseEvent
-
>
mMessage
!
=
ePointerMove
)
|
|
!
aMouseEvent
-
>
mWidget
)
{
return
;
}
bool
updateSynthCenteringPoint
=
aMouseEvent
-
>
mMessage
=
=
eMouseMove
;
LayoutDeviceIntPoint
center
=
GetWindowClientRectCenter
(
aMouseEvent
-
>
mWidget
)
;
if
(
aMouseEvent
-
>
mRefPoint
!
=
center
&
&
updateSynthCenteringPoint
)
{
sSynthCenteringPoint
=
center
;
aMouseEvent
-
>
mWidget
-
>
SynthesizeNativeMouseMove
(
center
+
aMouseEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
nullptr
)
;
}
else
if
(
aMouseEvent
-
>
mRefPoint
=
=
sSynthCenteringPoint
)
{
aMouseEvent
-
>
StopPropagation
(
)
;
if
(
updateSynthCenteringPoint
)
{
sSynthCenteringPoint
=
kInvalidRefPoint
;
}
}
}
void
EventStateManager
:
:
UpdateLastPointerPosition
(
WidgetMouseEvent
*
aMouseEvent
)
{
if
(
aMouseEvent
-
>
mMessage
!
=
eMouseMove
)
{
return
;
}
sLastRefPoint
=
aMouseEvent
-
>
mRefPoint
;
}
void
EventStateManager
:
:
GenerateMouseEnterExit
(
WidgetMouseEvent
*
aMouseEvent
)
{
EnsureDocument
(
mPresContext
)
;
if
(
!
mDocument
)
return
;
nsCOMPtr
<
nsIContent
>
targetBeforeEvent
=
mCurrentTargetContent
;
switch
(
aMouseEvent
-
>
mMessage
)
{
case
eMouseMove
:
case
ePointerMove
:
case
ePointerDown
:
case
ePointerGotCapture
:
{
nsCOMPtr
<
nsIContent
>
targetElement
=
GetEventTargetContent
(
aMouseEvent
)
;
if
(
!
targetElement
)
{
targetElement
=
mDocument
-
>
GetRootElement
(
)
;
}
if
(
targetElement
)
{
NotifyMouseOver
(
aMouseEvent
targetElement
)
;
}
}
break
;
case
ePointerUp
:
{
nsCOMPtr
<
nsIContent
>
targetElement
=
GetEventTargetContent
(
aMouseEvent
)
;
if
(
!
targetElement
)
{
targetElement
=
mDocument
-
>
GetRootElement
(
)
;
}
if
(
targetElement
)
{
RefPtr
<
OverOutElementsWrapper
>
helper
=
GetWrapperByEventID
(
aMouseEvent
)
;
if
(
helper
)
{
helper
-
>
mLastOverElement
=
targetElement
;
}
NotifyMouseOut
(
aMouseEvent
nullptr
)
;
}
}
break
;
case
ePointerLeave
:
case
ePointerCancel
:
case
eMouseExitFromWidget
:
{
RefPtr
<
OverOutElementsWrapper
>
helper
=
GetWrapperByEventID
(
aMouseEvent
)
;
if
(
helper
&
&
helper
-
>
mLastOverFrame
&
&
nsContentUtils
:
:
GetTopLevelWidget
(
aMouseEvent
-
>
mWidget
)
!
=
nsContentUtils
:
:
GetTopLevelWidget
(
helper
-
>
mLastOverFrame
-
>
GetNearestWidget
(
)
)
)
{
break
;
}
sLastRefPoint
=
kInvalidRefPoint
;
NotifyMouseOut
(
aMouseEvent
nullptr
)
;
}
break
;
default
:
break
;
}
mCurrentTargetContent
=
targetBeforeEvent
;
}
OverOutElementsWrapper
*
EventStateManager
:
:
GetWrapperByEventID
(
WidgetMouseEvent
*
aEvent
)
{
WidgetPointerEvent
*
pointer
=
aEvent
-
>
AsPointerEvent
(
)
;
if
(
!
pointer
)
{
MOZ_ASSERT
(
aEvent
-
>
AsMouseEvent
(
)
!
=
nullptr
)
;
if
(
!
mMouseEnterLeaveHelper
)
{
mMouseEnterLeaveHelper
=
new
OverOutElementsWrapper
(
)
;
}
return
mMouseEnterLeaveHelper
;
}
return
mPointersEnterLeaveHelper
.
GetOrInsertNew
(
pointer
-
>
pointerId
)
;
}
void
EventStateManager
:
:
SetPointerLock
(
nsIWidget
*
aWidget
nsIContent
*
aElement
)
{
WheelTransaction
:
:
EndTransaction
(
)
;
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
PointerLockManager
:
:
IsLocked
(
)
)
{
MOZ_ASSERT
(
aWidget
"
Locking
pointer
requires
a
widget
"
)
;
PointerEventHandler
:
:
ReleaseAllPointerCapture
(
)
;
sPreLockPoint
=
sLastRefPoint
;
sLastRefPoint
=
GetWindowClientRectCenter
(
aWidget
)
;
aWidget
-
>
SynthesizeNativeMouseMove
(
sLastRefPoint
+
aWidget
-
>
WidgetToScreenOffset
(
)
nullptr
)
;
if
(
dragService
)
{
dragService
-
>
Suppress
(
)
;
}
aWidget
-
>
LockNativePointer
(
)
;
}
else
{
if
(
aWidget
)
{
aWidget
-
>
UnlockNativePointer
(
)
;
}
sLastRefPoint
=
sPreLockPoint
;
sSynthCenteringPoint
=
kInvalidRefPoint
;
if
(
aWidget
)
{
aWidget
-
>
SynthesizeNativeMouseMove
(
sPreLockPoint
+
aWidget
-
>
WidgetToScreenOffset
(
)
nullptr
)
;
}
if
(
dragService
)
{
dragService
-
>
Unsuppress
(
)
;
}
}
}
void
EventStateManager
:
:
GenerateDragDropEnterExit
(
nsPresContext
*
aPresContext
WidgetDragEvent
*
aDragEvent
)
{
nsCOMPtr
<
nsIContent
>
targetBeforeEvent
=
mCurrentTargetContent
;
switch
(
aDragEvent
-
>
mMessage
)
{
case
eDragOver
:
{
if
(
sLastDragOverFrame
!
=
mCurrentTarget
)
{
nsCOMPtr
<
nsIContent
>
lastContent
;
nsCOMPtr
<
nsIContent
>
targetContent
;
mCurrentTarget
-
>
GetContentForEvent
(
aDragEvent
getter_AddRefs
(
targetContent
)
)
;
if
(
targetContent
&
&
targetContent
-
>
IsText
(
)
)
{
targetContent
=
targetContent
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
sLastDragOverFrame
)
{
sLastDragOverFrame
-
>
GetContentForEvent
(
aDragEvent
getter_AddRefs
(
lastContent
)
)
;
if
(
lastContent
&
&
lastContent
-
>
IsText
(
)
)
{
lastContent
=
lastContent
-
>
GetFlattenedTreeParent
(
)
;
}
RefPtr
<
nsPresContext
>
presContext
=
sLastDragOverFrame
-
>
PresContext
(
)
;
FireDragEnterOrExit
(
presContext
aDragEvent
eDragExit
targetContent
lastContent
sLastDragOverFrame
)
;
nsIContent
*
target
=
sLastDragOverFrame
?
sLastDragOverFrame
.
GetFrame
(
)
-
>
GetContent
(
)
:
nullptr
;
if
(
IsTopLevelRemoteTarget
(
target
)
)
{
WidgetDragEvent
remoteEvent
(
aDragEvent
-
>
IsTrusted
(
)
eDragExit
aDragEvent
-
>
mWidget
)
;
remoteEvent
.
AssignDragEventData
(
*
aDragEvent
true
)
;
remoteEvent
.
mFlags
.
mIsSynthesizedForTests
=
aDragEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
nsEventStatus
remoteStatus
=
nsEventStatus_eIgnore
;
HandleCrossProcessEvent
(
&
remoteEvent
&
remoteStatus
)
;
}
}
AutoWeakFrame
currentTraget
=
mCurrentTarget
;
FireDragEnterOrExit
(
aPresContext
aDragEvent
eDragEnter
lastContent
targetContent
currentTraget
)
;
if
(
sLastDragOverFrame
)
{
RefPtr
<
nsPresContext
>
presContext
=
sLastDragOverFrame
-
>
PresContext
(
)
;
FireDragEnterOrExit
(
presContext
aDragEvent
eDragLeave
targetContent
lastContent
sLastDragOverFrame
)
;
}
sLastDragOverFrame
=
mCurrentTarget
;
}
}
break
;
case
eDragExit
:
{
if
(
sLastDragOverFrame
)
{
nsCOMPtr
<
nsIContent
>
lastContent
;
sLastDragOverFrame
-
>
GetContentForEvent
(
aDragEvent
getter_AddRefs
(
lastContent
)
)
;
RefPtr
<
nsPresContext
>
lastDragOverFramePresContext
=
sLastDragOverFrame
-
>
PresContext
(
)
;
FireDragEnterOrExit
(
lastDragOverFramePresContext
aDragEvent
eDragExit
nullptr
lastContent
sLastDragOverFrame
)
;
FireDragEnterOrExit
(
lastDragOverFramePresContext
aDragEvent
eDragLeave
nullptr
lastContent
sLastDragOverFrame
)
;
sLastDragOverFrame
=
nullptr
;
}
}
break
;
default
:
break
;
}
mCurrentTargetContent
=
targetBeforeEvent
;
FlushLayout
(
aPresContext
)
;
}
void
EventStateManager
:
:
FireDragEnterOrExit
(
nsPresContext
*
aPresContext
WidgetDragEvent
*
aDragEvent
EventMessage
aMessage
nsIContent
*
aRelatedTarget
nsIContent
*
aTargetContent
AutoWeakFrame
&
aTargetFrame
)
{
MOZ_ASSERT
(
aMessage
=
=
eDragLeave
|
|
aMessage
=
=
eDragExit
|
|
aMessage
=
=
eDragEnter
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetDragEvent
event
(
aDragEvent
-
>
IsTrusted
(
)
aMessage
aDragEvent
-
>
mWidget
)
;
event
.
AssignDragEventData
(
*
aDragEvent
false
)
;
event
.
mFlags
.
mIsSynthesizedForTests
=
aDragEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
event
.
mRelatedTarget
=
aRelatedTarget
;
if
(
aMessage
=
=
eDragExit
&
&
!
StaticPrefs
:
:
dom_event_dragexit_enabled
(
)
)
{
event
.
mFlags
.
mOnlyChromeDispatch
=
true
;
}
mCurrentTargetContent
=
aTargetContent
;
if
(
aTargetContent
!
=
aRelatedTarget
)
{
if
(
aTargetContent
)
{
EventDispatcher
:
:
Dispatch
(
aTargetContent
aPresContext
&
event
nullptr
&
status
)
;
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
|
|
aMessage
=
=
eDragExit
)
{
SetContentState
(
(
aMessage
=
=
eDragEnter
)
?
aTargetContent
:
nullptr
ElementState
:
:
DRAGOVER
)
;
}
UpdateDragDataTransfer
(
&
event
)
;
}
if
(
aTargetFrame
)
{
aTargetFrame
-
>
HandleEvent
(
aPresContext
&
event
&
status
)
;
}
}
void
EventStateManager
:
:
UpdateDragDataTransfer
(
WidgetDragEvent
*
dragEvent
)
{
NS_ASSERTION
(
dragEvent
"
drag
event
is
null
in
UpdateDragDataTransfer
!
"
)
;
if
(
!
dragEvent
-
>
mDataTransfer
)
{
return
;
}
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
dragSession
)
{
RefPtr
<
DataTransfer
>
initialDataTransfer
=
dragSession
-
>
GetDataTransfer
(
)
;
if
(
initialDataTransfer
)
{
nsAutoString
mozCursor
;
dragEvent
-
>
mDataTransfer
-
>
GetMozCursor
(
mozCursor
)
;
initialDataTransfer
-
>
SetMozCursor
(
mozCursor
)
;
}
}
}
nsresult
EventStateManager
:
:
SetClickCount
(
WidgetMouseEvent
*
aEvent
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
{
nsCOMPtr
<
nsIContent
>
mouseContent
=
aOverrideClickTarget
;
if
(
!
mouseContent
&
&
mCurrentTarget
)
{
mCurrentTarget
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
mouseContent
)
)
;
}
if
(
mouseContent
&
&
mouseContent
-
>
IsText
(
)
)
{
nsINode
*
parent
=
mouseContent
-
>
GetFlattenedTreeParentNode
(
)
;
if
(
parent
&
&
parent
-
>
IsContent
(
)
)
{
mouseContent
=
parent
-
>
AsContent
(
)
;
}
}
switch
(
aEvent
-
>
mButton
)
{
case
MouseButton
:
:
ePrimary
:
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
mLastLeftMouseDownContent
=
!
aEvent
-
>
mClickEventPrevented
?
mouseContent
:
nullptr
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
aEvent
-
>
mClickTarget
=
!
aEvent
-
>
mClickEventPrevented
?
nsContentUtils
:
:
GetCommonAncestorUnderInteractiveContent
(
mouseContent
mLastLeftMouseDownContent
)
:
nullptr
;
if
(
aEvent
-
>
mClickTarget
)
{
aEvent
-
>
mClickCount
=
mLClickCount
;
mLClickCount
=
0
;
}
else
{
aEvent
-
>
mClickCount
=
0
;
}
mLastLeftMouseDownContent
=
nullptr
;
}
break
;
case
MouseButton
:
:
eMiddle
:
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
mLastMiddleMouseDownContent
=
!
aEvent
-
>
mClickEventPrevented
?
mouseContent
:
nullptr
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
aEvent
-
>
mClickTarget
=
!
aEvent
-
>
mClickEventPrevented
?
nsContentUtils
:
:
GetCommonAncestorUnderInteractiveContent
(
mouseContent
mLastMiddleMouseDownContent
)
:
nullptr
;
if
(
aEvent
-
>
mClickTarget
)
{
aEvent
-
>
mClickCount
=
mMClickCount
;
mMClickCount
=
0
;
}
else
{
aEvent
-
>
mClickCount
=
0
;
}
mLastMiddleMouseDownContent
=
nullptr
;
}
break
;
case
MouseButton
:
:
eSecondary
:
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
mLastRightMouseDownContent
=
!
aEvent
-
>
mClickEventPrevented
?
mouseContent
:
nullptr
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
aEvent
-
>
mClickTarget
=
!
aEvent
-
>
mClickEventPrevented
?
nsContentUtils
:
:
GetCommonAncestorUnderInteractiveContent
(
mouseContent
mLastRightMouseDownContent
)
:
nullptr
;
if
(
aEvent
-
>
mClickTarget
)
{
aEvent
-
>
mClickCount
=
mRClickCount
;
mRClickCount
=
0
;
}
else
{
aEvent
-
>
mClickCount
=
0
;
}
mLastRightMouseDownContent
=
nullptr
;
}
break
;
}
return
NS_OK
;
}
bool
EventStateManager
:
:
EventCausesClickEvents
(
const
WidgetMouseEvent
&
aMouseEvent
)
{
if
(
NS_WARN_IF
(
aMouseEvent
.
mMessage
!
=
eMouseUp
)
)
{
return
false
;
}
if
(
!
aMouseEvent
.
IsReal
(
)
)
{
return
false
;
}
if
(
!
aMouseEvent
.
mClickCount
|
|
!
aMouseEvent
.
mClickTarget
)
{
return
false
;
}
if
(
aMouseEvent
.
mClickEventPrevented
)
{
return
false
;
}
return
!
(
aMouseEvent
.
mWidget
&
&
!
aMouseEvent
.
mWidget
-
>
IsEnabled
(
)
)
;
}
nsresult
EventStateManager
:
:
InitAndDispatchClickEvent
(
WidgetMouseEvent
*
aMouseUpEvent
nsEventStatus
*
aStatus
EventMessage
aMessage
PresShell
*
aPresShell
nsIContent
*
aMouseUpContent
AutoWeakFrame
aCurrentTarget
bool
aNoContentDispatch
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aMouseUpEvent
)
;
MOZ_ASSERT
(
EventCausesClickEvents
(
*
aMouseUpEvent
)
)
;
MOZ_ASSERT
(
aMouseUpContent
|
|
aCurrentTarget
|
|
aOverrideClickTarget
)
;
WidgetMouseEvent
event
(
aMouseUpEvent
-
>
IsTrusted
(
)
aMessage
aMouseUpEvent
-
>
mWidget
WidgetMouseEvent
:
:
eReal
)
;
event
.
mRefPoint
=
aMouseUpEvent
-
>
mRefPoint
;
event
.
mClickCount
=
aMouseUpEvent
-
>
mClickCount
;
event
.
mModifiers
=
aMouseUpEvent
-
>
mModifiers
;
event
.
mButtons
=
aMouseUpEvent
-
>
mButtons
;
event
.
mTime
=
aMouseUpEvent
-
>
mTime
;
event
.
mTimeStamp
=
aMouseUpEvent
-
>
mTimeStamp
;
event
.
mFlags
.
mOnlyChromeDispatch
=
aNoContentDispatch
&
&
!
aMouseUpEvent
-
>
mUseLegacyNonPrimaryDispatch
;
event
.
mFlags
.
mNoContentDispatch
=
aNoContentDispatch
;
event
.
mButton
=
aMouseUpEvent
-
>
mButton
;
event
.
pointerId
=
aMouseUpEvent
-
>
pointerId
;
event
.
mInputSource
=
aMouseUpEvent
-
>
mInputSource
;
nsIContent
*
target
=
aMouseUpContent
;
nsIFrame
*
targetFrame
=
aCurrentTarget
;
if
(
aOverrideClickTarget
)
{
target
=
aOverrideClickTarget
;
targetFrame
=
aOverrideClickTarget
-
>
GetPrimaryFrame
(
)
;
}
if
(
!
target
-
>
IsInComposedDoc
(
)
)
{
return
NS_OK
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
aPresShell
-
>
HandleEventWithTarget
(
&
event
targetFrame
MOZ_KnownLive
(
target
)
&
status
)
;
aMouseUpEvent
-
>
mFlags
.
mMultipleActionsPrevented
|
=
event
.
mFlags
.
mMultipleActionsPrevented
;
if
(
*
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
rv
;
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
|
|
status
=
=
nsEventStatus_eConsumeDoDefault
)
{
*
aStatus
=
status
;
return
rv
;
}
return
rv
;
}
nsresult
EventStateManager
:
:
PostHandleMouseUp
(
WidgetMouseEvent
*
aMouseUpEvent
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aMouseUpEvent
)
;
MOZ_ASSERT
(
EventCausesClickEvents
(
*
aMouseUpEvent
)
)
;
MOZ_ASSERT
(
aStatus
)
;
RefPtr
<
PresShell
>
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
clickTarget
=
nsIContent
:
:
FromEventTargetOrNull
(
aMouseUpEvent
-
>
mClickTarget
)
;
NS_ENSURE_STATE
(
clickTarget
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
DispatchClickEvents
(
presShell
aMouseUpEvent
&
status
clickTarget
aOverrideClickTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
if
(
aMouseUpEvent
-
>
mButton
!
=
MouseButton
:
:
eMiddle
|
|
!
WidgetMouseEvent
:
:
IsMiddleClickPasteEnabled
(
)
)
{
return
NS_OK
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
HandleMiddleClickPaste
(
presShell
aMouseUpEvent
&
status
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
paste
for
a
middle
click
"
)
;
if
(
*
aStatus
!
=
nsEventStatus_eConsumeNoDefault
&
&
(
status
=
=
nsEventStatus_eConsumeNoDefault
|
|
status
=
=
nsEventStatus_eConsumeDoDefault
)
)
{
*
aStatus
=
status
;
}
return
NS_OK
;
}
nsresult
EventStateManager
:
:
DispatchClickEvents
(
PresShell
*
aPresShell
WidgetMouseEvent
*
aMouseUpEvent
nsEventStatus
*
aStatus
nsIContent
*
aClickTarget
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aPresShell
)
;
MOZ_ASSERT
(
aMouseUpEvent
)
;
MOZ_ASSERT
(
EventCausesClickEvents
(
*
aMouseUpEvent
)
)
;
MOZ_ASSERT
(
aStatus
)
;
MOZ_ASSERT
(
aClickTarget
|
|
aOverrideClickTarget
)
;
bool
notDispatchToContents
=
(
aMouseUpEvent
-
>
mButton
=
=
MouseButton
:
:
eMiddle
|
|
aMouseUpEvent
-
>
mButton
=
=
MouseButton
:
:
eSecondary
)
;
bool
fireAuxClick
=
notDispatchToContents
;
AutoWeakFrame
currentTarget
=
aClickTarget
-
>
GetPrimaryFrame
(
)
;
nsresult
rv
=
InitAndDispatchClickEvent
(
aMouseUpEvent
aStatus
eMouseClick
aPresShell
aClickTarget
currentTarget
notDispatchToContents
aOverrideClickTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
fireAuxClick
&
&
*
aStatus
!
=
nsEventStatus_eConsumeNoDefault
&
&
aClickTarget
&
&
aClickTarget
-
>
IsInComposedDoc
(
)
)
{
rv
=
InitAndDispatchClickEvent
(
aMouseUpEvent
aStatus
eMouseAuxClick
aPresShell
aClickTarget
currentTarget
false
aOverrideClickTarget
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
dispatch
eMouseAuxClick
"
)
;
}
if
(
aMouseUpEvent
-
>
mClickCount
=
=
2
&
&
!
fireAuxClick
&
&
aClickTarget
&
&
aClickTarget
-
>
IsInComposedDoc
(
)
)
{
rv
=
InitAndDispatchClickEvent
(
aMouseUpEvent
aStatus
eMouseDoubleClick
aPresShell
aClickTarget
currentTarget
notDispatchToContents
aOverrideClickTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
rv
;
}
nsresult
EventStateManager
:
:
HandleMiddleClickPaste
(
PresShell
*
aPresShell
WidgetMouseEvent
*
aMouseEvent
nsEventStatus
*
aStatus
EditorBase
*
aEditorBase
)
{
MOZ_ASSERT
(
aPresShell
)
;
MOZ_ASSERT
(
aMouseEvent
)
;
MOZ_ASSERT
(
(
aMouseEvent
-
>
mMessage
=
=
eMouseAuxClick
&
&
aMouseEvent
-
>
mButton
=
=
MouseButton
:
:
eMiddle
)
|
|
EventCausesClickEvents
(
*
aMouseEvent
)
)
;
MOZ_ASSERT
(
aStatus
)
;
MOZ_ASSERT
(
*
aStatus
!
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
aMouseEvent
-
>
mFlags
.
mMultipleActionsPrevented
)
{
return
NS_OK
;
}
aMouseEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
RefPtr
<
Selection
>
selection
;
if
(
aEditorBase
)
{
selection
=
aEditorBase
-
>
GetSelection
(
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
Document
*
document
=
aPresShell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
selection
=
nsCopySupport
:
:
GetSelectionForCopy
(
document
)
;
if
(
NS_WARN_IF
(
!
selection
)
)
{
return
NS_ERROR_FAILURE
;
}
}
int32_t
clipboardType
=
nsIClipboard
:
:
kGlobalClipboard
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIClipboard
>
clipboardService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
bool
selectionSupported
;
rv
=
clipboardService
-
>
SupportsSelectionClipboard
(
&
selectionSupported
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
selectionSupported
)
{
clipboardType
=
nsIClipboard
:
:
kSelectionClipboard
;
}
}
if
(
!
nsCopySupport
:
:
FireClipboardEvent
(
ePaste
clipboardType
aPresShell
selection
)
)
{
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
if
(
!
aEditorBase
)
{
return
NS_OK
;
}
if
(
aEditorBase
-
>
Destroyed
(
)
|
|
aEditorBase
-
>
IsReadonly
(
)
)
{
return
NS_OK
;
}
const
nsRange
*
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
!
range
)
{
return
NS_OK
;
}
WidgetMouseEvent
mouseEvent
(
*
aMouseEvent
)
;
mouseEvent
.
mOriginalTarget
=
range
-
>
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
mouseEvent
.
mOriginalTarget
)
|
|
!
aEditorBase
-
>
IsAcceptableInputEvent
(
&
mouseEvent
)
)
{
return
NS_OK
;
}
if
(
aMouseEvent
-
>
IsControl
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
aEditorBase
-
>
PasteAsQuotationAsAction
(
clipboardType
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
paste
as
quotation
"
)
;
}
else
{
DebugOnly
<
nsresult
>
rv
=
aEditorBase
-
>
PasteAsAction
(
clipboardType
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
paste
"
)
;
}
*
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
void
EventStateManager
:
:
ConsumeInteractionData
(
Record
<
nsString
dom
:
:
InteractionData
>
&
aInteractions
)
{
OnTypingInteractionEnded
(
)
;
aInteractions
.
Entries
(
)
.
Clear
(
)
;
auto
newEntry
=
aInteractions
.
Entries
(
)
.
AppendElement
(
)
;
newEntry
-
>
mKey
=
u
"
Typing
"
_ns
;
newEntry
-
>
mValue
=
gTypingInteraction
;
gTypingInteraction
=
{
}
;
}
nsIFrame
*
EventStateManager
:
:
GetEventTarget
(
)
{
PresShell
*
presShell
;
if
(
mCurrentTarget
|
|
!
mPresContext
|
|
!
(
presShell
=
mPresContext
-
>
GetPresShell
(
)
)
)
{
return
mCurrentTarget
;
}
if
(
mCurrentTargetContent
)
{
mCurrentTarget
=
mPresContext
-
>
GetPrimaryFrameFor
(
mCurrentTargetContent
)
;
if
(
mCurrentTarget
)
{
return
mCurrentTarget
;
}
}
nsIFrame
*
frame
=
presShell
-
>
GetCurrentEventFrame
(
)
;
return
(
mCurrentTarget
=
frame
)
;
}
already_AddRefed
<
nsIContent
>
EventStateManager
:
:
GetEventTargetContent
(
WidgetEvent
*
aEvent
)
{
if
(
aEvent
&
&
(
aEvent
-
>
mMessage
=
=
eFocus
|
|
aEvent
-
>
mMessage
=
=
eBlur
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetFocusedElement
(
)
;
return
content
.
forget
(
)
;
}
if
(
mCurrentTargetContent
)
{
nsCOMPtr
<
nsIContent
>
content
=
mCurrentTargetContent
;
return
content
.
forget
(
)
;
}
nsCOMPtr
<
nsIContent
>
content
;
if
(
PresShell
*
presShell
=
mPresContext
-
>
GetPresShell
(
)
)
{
content
=
presShell
-
>
GetEventTargetContent
(
aEvent
)
;
}
if
(
!
content
&
&
mCurrentTarget
)
{
mCurrentTarget
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
content
)
)
;
}
return
content
.
forget
(
)
;
}
static
Element
*
GetLabelTarget
(
nsIContent
*
aPossibleLabel
)
{
mozilla
:
:
dom
:
:
HTMLLabelElement
*
label
=
mozilla
:
:
dom
:
:
HTMLLabelElement
:
:
FromNode
(
aPossibleLabel
)
;
if
(
!
label
)
return
nullptr
;
return
label
-
>
GetLabeledElement
(
)
;
}
inline
void
EventStateManager
:
:
DoStateChange
(
Element
*
aElement
ElementState
aState
bool
aAddState
)
{
if
(
aAddState
)
{
aElement
-
>
AddStates
(
aState
)
;
}
else
{
aElement
-
>
RemoveStates
(
aState
)
;
}
}
inline
void
EventStateManager
:
:
DoStateChange
(
nsIContent
*
aContent
ElementState
aState
bool
aStateAdded
)
{
if
(
aContent
-
>
IsElement
(
)
)
{
DoStateChange
(
aContent
-
>
AsElement
(
)
aState
aStateAdded
)
;
}
}
void
EventStateManager
:
:
UpdateAncestorState
(
nsIContent
*
aStartNode
nsIContent
*
aStopBefore
ElementState
aState
bool
aAddState
)
{
for
(
;
aStartNode
&
&
aStartNode
!
=
aStopBefore
;
aStartNode
=
aStartNode
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
!
aStartNode
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
element
=
aStartNode
-
>
AsElement
(
)
;
DoStateChange
(
element
aState
aAddState
)
;
Element
*
labelTarget
=
GetLabelTarget
(
element
)
;
if
(
labelTarget
)
{
DoStateChange
(
labelTarget
aState
aAddState
)
;
}
}
if
(
aAddState
)
{
for
(
;
aStartNode
;
aStartNode
=
aStartNode
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
!
aStartNode
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
labelTarget
=
GetLabelTarget
(
aStartNode
-
>
AsElement
(
)
)
;
if
(
labelTarget
&
&
!
labelTarget
-
>
State
(
)
.
HasState
(
aState
)
)
{
DoStateChange
(
labelTarget
aState
true
)
;
}
}
}
}
bool
CanContentHaveActiveState
(
nsIContent
&
aContent
)
{
return
!
aContent
.
IsEditable
(
)
|
|
aContent
.
IsInNativeAnonymousSubtree
(
)
;
}
bool
EventStateManager
:
:
SetContentState
(
nsIContent
*
aContent
ElementState
aState
)
{
MOZ_ASSERT
(
ManagesState
(
aState
)
"
Unexpected
state
"
)
;
nsCOMPtr
<
nsIContent
>
notifyContent1
;
nsCOMPtr
<
nsIContent
>
notifyContent2
;
bool
updateAncestors
;
if
(
aState
=
=
ElementState
:
:
HOVER
|
|
aState
=
=
ElementState
:
:
ACTIVE
)
{
updateAncestors
=
true
;
if
(
mCurrentTarget
&
&
mCurrentTarget
-
>
StyleUI
(
)
-
>
UserInput
(
)
=
=
StyleUserInput
:
:
None
)
{
return
false
;
}
if
(
aState
=
=
ElementState
:
:
ACTIVE
)
{
if
(
aContent
&
&
!
CanContentHaveActiveState
(
*
aContent
)
)
{
aContent
=
nullptr
;
}
if
(
aContent
!
=
mActiveContent
)
{
notifyContent1
=
aContent
;
notifyContent2
=
mActiveContent
;
mActiveContent
=
aContent
;
}
}
else
{
NS_ASSERTION
(
aState
=
=
ElementState
:
:
HOVER
"
How
did
that
happen
?
"
)
;
nsIContent
*
newHover
;
if
(
mPresContext
-
>
IsDynamic
(
)
)
{
newHover
=
aContent
;
}
else
{
NS_ASSERTION
(
!
aContent
|
|
aContent
-
>
GetComposedDoc
(
)
=
=
mPresContext
-
>
PresShell
(
)
-
>
GetDocument
(
)
"
Unexpected
document
"
)
;
nsIFrame
*
frame
=
aContent
?
aContent
-
>
GetPrimaryFrame
(
)
:
nullptr
;
if
(
frame
&
&
nsLayoutUtils
:
:
IsViewportScrollbarFrame
(
frame
)
)
{
newHover
=
aContent
;
}
else
{
newHover
=
nullptr
;
}
}
if
(
newHover
!
=
mHoverContent
)
{
notifyContent1
=
newHover
;
notifyContent2
=
mHoverContent
;
mHoverContent
=
newHover
;
}
}
}
else
{
updateAncestors
=
false
;
if
(
aState
=
=
ElementState
:
:
DRAGOVER
)
{
if
(
aContent
!
=
sDragOverContent
)
{
notifyContent1
=
aContent
;
notifyContent2
=
sDragOverContent
;
sDragOverContent
=
aContent
;
}
}
else
if
(
aState
=
=
ElementState
:
:
URLTARGET
)
{
if
(
aContent
!
=
mURLTargetContent
)
{
notifyContent1
=
aContent
;
notifyContent2
=
mURLTargetContent
;
mURLTargetContent
=
aContent
;
}
}
}
bool
content1StateSet
=
true
;
if
(
!
notifyContent1
)
{
notifyContent1
=
notifyContent2
;
notifyContent2
=
nullptr
;
content1StateSet
=
false
;
}
if
(
notifyContent1
&
&
mPresContext
)
{
EnsureDocument
(
mPresContext
)
;
if
(
mDocument
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
updateAncestors
)
{
nsCOMPtr
<
nsIContent
>
commonAncestor
=
FindCommonAncestor
(
notifyContent1
notifyContent2
)
;
if
(
notifyContent2
)
{
UpdateAncestorState
(
notifyContent2
commonAncestor
aState
false
)
;
}
UpdateAncestorState
(
notifyContent1
commonAncestor
aState
content1StateSet
)
;
}
else
{
if
(
notifyContent2
)
{
DoStateChange
(
notifyContent2
aState
false
)
;
}
DoStateChange
(
notifyContent1
aState
content1StateSet
)
;
}
}
}
return
true
;
}
void
EventStateManager
:
:
ResetLastOverForContent
(
const
uint32_t
&
aIdx
const
RefPtr
<
OverOutElementsWrapper
>
&
aElemWrapper
nsIContent
*
aContent
)
{
if
(
aElemWrapper
&
&
aElemWrapper
-
>
mLastOverElement
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
aElemWrapper
-
>
mLastOverElement
aContent
)
)
{
aElemWrapper
-
>
mLastOverElement
=
nullptr
;
}
}
void
EventStateManager
:
:
RemoveNodeFromChainIfNeeded
(
ElementState
aState
nsIContent
*
aContentRemoved
bool
aNotify
)
{
MOZ_ASSERT
(
aState
=
=
ElementState
:
:
HOVER
|
|
aState
=
=
ElementState
:
:
ACTIVE
)
;
if
(
!
aContentRemoved
-
>
IsElement
(
)
|
|
!
aContentRemoved
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
aState
)
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
&
leaf
=
aState
=
=
ElementState
:
:
HOVER
?
mHoverContent
:
mActiveContent
;
MOZ_ASSERT
(
leaf
)
;
NS_ASSERTION
(
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
leaf
aContentRemoved
)
"
Flat
tree
and
active
/
hover
chain
got
out
of
sync
"
)
;
nsIContent
*
newLeaf
=
aContentRemoved
-
>
GetFlattenedTreeParent
(
)
;
MOZ_ASSERT
(
!
newLeaf
|
|
newLeaf
-
>
IsElement
(
)
)
;
NS_ASSERTION
(
!
newLeaf
|
|
newLeaf
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
aState
)
"
State
got
out
of
sync
because
of
shadow
DOM
"
)
;
if
(
aNotify
)
{
SetContentState
(
newLeaf
aState
)
;
}
else
{
leaf
=
newLeaf
;
}
MOZ_ASSERT
(
leaf
=
=
newLeaf
|
|
(
aState
=
=
ElementState
:
:
ACTIVE
&
&
!
leaf
&
&
!
CanContentHaveActiveState
(
*
newLeaf
)
)
)
;
}
void
EventStateManager
:
:
NativeAnonymousContentRemoved
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
;
RemoveNodeFromChainIfNeeded
(
ElementState
:
:
HOVER
aContent
false
)
;
RemoveNodeFromChainIfNeeded
(
ElementState
:
:
ACTIVE
aContent
false
)
;
if
(
mLastLeftMouseDownContent
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
mLastLeftMouseDownContent
aContent
)
)
{
mLastLeftMouseDownContent
=
aContent
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
mLastMiddleMouseDownContent
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
mLastMiddleMouseDownContent
aContent
)
)
{
mLastMiddleMouseDownContent
=
aContent
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
mLastRightMouseDownContent
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
mLastRightMouseDownContent
aContent
)
)
{
mLastRightMouseDownContent
=
aContent
-
>
GetFlattenedTreeParent
(
)
;
}
}
void
EventStateManager
:
:
ContentRemoved
(
Document
*
aDocument
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
area
)
&
&
(
aContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasAtLeastOneOfStates
(
ElementState
:
:
FOCUS
|
ElementState
:
:
HOVER
)
)
)
{
Element
*
element
=
aContent
-
>
AsElement
(
)
;
element
-
>
LeaveLink
(
element
-
>
GetPresContext
(
Element
:
:
eForComposedDoc
)
)
;
}
if
(
aContent
-
>
IsElement
(
)
)
{
if
(
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
)
{
IMEStateManager
:
:
OnRemoveContent
(
*
presContext
MOZ_KnownLive
(
*
aContent
-
>
AsElement
(
)
)
)
;
}
}
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
fm
-
>
ContentRemoved
(
aDocument
aContent
)
;
}
RemoveNodeFromChainIfNeeded
(
ElementState
:
:
HOVER
aContent
true
)
;
RemoveNodeFromChainIfNeeded
(
ElementState
:
:
ACTIVE
aContent
true
)
;
if
(
sDragOverContent
&
&
sDragOverContent
-
>
OwnerDoc
(
)
=
=
aContent
-
>
OwnerDoc
(
)
&
&
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
sDragOverContent
aContent
)
)
{
sDragOverContent
=
nullptr
;
}
PointerEventHandler
:
:
ReleaseIfCaptureByDescendant
(
aContent
)
;
ResetLastOverForContent
(
0
mMouseEnterLeaveHelper
aContent
)
;
for
(
const
auto
&
entry
:
mPointersEnterLeaveHelper
)
{
ResetLastOverForContent
(
entry
.
GetKey
(
)
entry
.
GetData
(
)
aContent
)
;
}
}
void
EventStateManager
:
:
TextControlRootWillBeRemoved
(
TextControlElement
&
aTextControlElement
)
{
if
(
!
mGestureDownInTextControl
|
|
!
mGestureDownFrameOwner
|
|
!
mGestureDownFrameOwner
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
if
(
&
aTextControlElement
=
=
mGestureDownFrameOwner
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
)
{
mGestureDownFrameOwner
=
&
aTextControlElement
;
}
}
void
EventStateManager
:
:
TextControlRootAdded
(
Element
&
aAnonymousDivElement
TextControlElement
&
aTextControlElement
)
{
if
(
!
mGestureDownInTextControl
|
|
mGestureDownFrameOwner
!
=
&
aTextControlElement
)
{
return
;
}
mGestureDownFrameOwner
=
aAnonymousDivElement
.
GetFirstChild
(
)
?
aAnonymousDivElement
.
GetFirstChild
(
)
:
static_cast
<
nsIContent
*
>
(
&
aAnonymousDivElement
)
;
}
bool
EventStateManager
:
:
EventStatusOK
(
WidgetGUIEvent
*
aEvent
)
{
return
!
(
aEvent
-
>
mMessage
=
=
eMouseDown
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
=
=
MouseButton
:
:
ePrimary
&
&
!
sNormalLMouseEventInProcess
)
;
}
void
EventStateManager
:
:
RegisterAccessKey
(
Element
*
aElement
uint32_t
aKey
)
{
if
(
aElement
&
&
!
mAccessKeys
.
Contains
(
aElement
)
)
{
mAccessKeys
.
AppendObject
(
aElement
)
;
}
}
void
EventStateManager
:
:
UnregisterAccessKey
(
Element
*
aElement
uint32_t
aKey
)
{
if
(
aElement
)
{
mAccessKeys
.
RemoveObject
(
aElement
)
;
}
}
uint32_t
EventStateManager
:
:
GetRegisteredAccessKey
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
if
(
!
mAccessKeys
.
Contains
(
aElement
)
)
{
return
0
;
}
nsAutoString
accessKey
;
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
accessKey
)
;
return
accessKey
.
First
(
)
;
}
void
EventStateManager
:
:
EnsureDocument
(
nsPresContext
*
aPresContext
)
{
if
(
!
mDocument
)
mDocument
=
aPresContext
-
>
Document
(
)
;
}
void
EventStateManager
:
:
FlushLayout
(
nsPresContext
*
aPresContext
)
{
MOZ_ASSERT
(
aPresContext
"
nullptr
ptr
"
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
aPresContext
-
>
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
InterruptibleLayout
)
;
}
}
Element
*
EventStateManager
:
:
GetFocusedElement
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
EnsureDocument
(
mPresContext
)
;
if
(
!
fm
|
|
!
mDocument
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
return
nsFocusManager
:
:
GetFocusedDescendant
(
mDocument
-
>
GetWindow
(
)
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
}
bool
EventStateManager
:
:
IsShellVisible
(
nsIDocShell
*
aShell
)
{
NS_ASSERTION
(
aShell
"
docshell
is
null
"
)
;
nsCOMPtr
<
nsIBaseWindow
>
basewin
=
do_QueryInterface
(
aShell
)
;
if
(
!
basewin
)
return
true
;
bool
isVisible
=
true
;
basewin
-
>
GetVisibility
(
&
isVisible
)
;
return
isVisible
;
}
nsresult
EventStateManager
:
:
DoContentCommandEvent
(
WidgetContentCommandEvent
*
aEvent
)
{
EnsureDocument
(
mPresContext
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
mDocument
-
>
GetWindow
(
)
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
window
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_FAILURE
)
;
const
char
*
cmd
;
switch
(
aEvent
-
>
mMessage
)
{
case
eContentCommandCut
:
cmd
=
"
cmd_cut
"
;
break
;
case
eContentCommandCopy
:
cmd
=
"
cmd_copy
"
;
break
;
case
eContentCommandPaste
:
cmd
=
"
cmd_paste
"
;
break
;
case
eContentCommandDelete
:
cmd
=
"
cmd_delete
"
;
break
;
case
eContentCommandUndo
:
cmd
=
"
cmd_undo
"
;
break
;
case
eContentCommandRedo
:
cmd
=
"
cmd_redo
"
;
break
;
case
eContentCommandPasteTransferable
:
cmd
=
"
cmd_pasteTransferable
"
;
break
;
case
eContentCommandLookUpDictionary
:
cmd
=
"
cmd_lookUpDictionary
"
;
break
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsCOMPtr
<
nsIController
>
controller
;
nsresult
rv
=
root
-
>
GetControllerForCommand
(
cmd
true
getter_AddRefs
(
controller
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
controller
)
{
aEvent
-
>
mIsEnabled
=
false
;
}
else
{
bool
canDoIt
;
rv
=
controller
-
>
IsCommandEnabled
(
cmd
&
canDoIt
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mIsEnabled
=
canDoIt
;
if
(
canDoIt
&
&
!
aEvent
-
>
mOnlyEnabledCheck
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eContentCommandPasteTransferable
:
{
BrowserParent
*
remote
=
BrowserParent
:
:
GetFocused
(
)
;
if
(
remote
)
{
nsCOMPtr
<
nsITransferable
>
transferable
=
aEvent
-
>
mTransferable
;
IPCDataTransfer
ipcDataTransfer
;
nsContentUtils
:
:
TransferableToIPCTransferable
(
transferable
&
ipcDataTransfer
false
nullptr
remote
-
>
Manager
(
)
)
;
bool
isPrivateData
=
transferable
-
>
GetIsPrivateData
(
)
;
nsCOMPtr
<
nsIPrincipal
>
requestingPrincipal
=
transferable
-
>
GetRequestingPrincipal
(
)
;
nsContentPolicyType
contentPolicyType
=
transferable
-
>
GetContentPolicyType
(
)
;
remote
-
>
SendPasteTransferable
(
ipcDataTransfer
isPrivateData
requestingPrincipal
contentPolicyType
)
;
rv
=
NS_OK
;
}
else
{
nsCOMPtr
<
nsICommandController
>
commandController
=
do_QueryInterface
(
controller
)
;
NS_ENSURE_STATE
(
commandController
)
;
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
rv
=
params
-
>
SetISupports
(
"
transferable
"
aEvent
-
>
mTransferable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
commandController
-
>
DoCommandWithParams
(
cmd
params
)
;
}
break
;
}
case
eContentCommandLookUpDictionary
:
{
nsCOMPtr
<
nsICommandController
>
commandController
=
do_QueryInterface
(
controller
)
;
if
(
NS_WARN_IF
(
!
commandController
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
rv
=
params
-
>
SetInt
(
"
x
"
aEvent
-
>
mRefPoint
.
x
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
params
-
>
SetInt
(
"
y
"
aEvent
-
>
mRefPoint
.
y
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
commandController
-
>
DoCommandWithParams
(
cmd
params
)
;
break
;
}
default
:
rv
=
controller
-
>
DoCommand
(
cmd
)
;
break
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
EventStateManager
:
:
DoContentCommandInsertTextEvent
(
WidgetContentCommandEvent
*
aEvent
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aEvent
-
>
mMessage
=
=
eContentCommandInsertText
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
mString
.
isSome
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aEvent
-
>
mString
.
ref
(
)
.
IsEmpty
(
)
)
;
aEvent
-
>
mIsEnabled
=
false
;
aEvent
-
>
mSucceeded
=
false
;
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_NOT_AVAILABLE
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
BrowserParent
*
remote
=
BrowserParent
:
:
GetFocused
(
)
)
{
remote
-
>
SendInsertText
(
aEvent
-
>
mString
.
ref
(
)
)
;
aEvent
-
>
mIsEnabled
=
true
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
}
RefPtr
<
EditorBase
>
activeEditor
=
nsContentUtils
:
:
GetActiveEditor
(
mPresContext
)
;
if
(
!
activeEditor
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
rv
=
activeEditor
-
>
InsertTextAsAction
(
aEvent
-
>
mString
.
ref
(
)
)
;
aEvent
-
>
mIsEnabled
=
rv
!
=
NS_SUCCESS_DOM_NO_OPERATION
;
aEvent
-
>
mSucceeded
=
NS_SUCCEEDED
(
rv
)
;
return
NS_OK
;
}
nsresult
EventStateManager
:
:
DoContentCommandScrollEvent
(
WidgetContentCommandEvent
*
aEvent
)
{
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_NOT_AVAILABLE
)
;
PresShell
*
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_NOT_AVAILABLE
)
;
NS_ENSURE_TRUE
(
aEvent
-
>
mScroll
.
mAmount
!
=
0
NS_ERROR_INVALID_ARG
)
;
ScrollUnit
scrollUnit
;
switch
(
aEvent
-
>
mScroll
.
mUnit
)
{
case
WidgetContentCommandEvent
:
:
eCmdScrollUnit_Line
:
scrollUnit
=
ScrollUnit
:
:
LINES
;
break
;
case
WidgetContentCommandEvent
:
:
eCmdScrollUnit_Page
:
scrollUnit
=
ScrollUnit
:
:
PAGES
;
break
;
case
WidgetContentCommandEvent
:
:
eCmdScrollUnit_Whole
:
scrollUnit
=
ScrollUnit
:
:
WHOLE
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
aEvent
-
>
mSucceeded
=
true
;
nsIScrollableFrame
*
sf
=
presShell
-
>
GetScrollableFrameToScroll
(
layers
:
:
EitherScrollDirection
)
;
aEvent
-
>
mIsEnabled
=
sf
?
(
aEvent
-
>
mScroll
.
mIsHorizontal
?
WheelHandlingUtils
:
:
CanScrollOn
(
sf
aEvent
-
>
mScroll
.
mAmount
0
)
:
WheelHandlingUtils
:
:
CanScrollOn
(
sf
0
aEvent
-
>
mScroll
.
mAmount
)
)
:
false
;
if
(
!
aEvent
-
>
mIsEnabled
|
|
aEvent
-
>
mOnlyEnabledCheck
)
{
return
NS_OK
;
}
nsIntPoint
pt
(
0
0
)
;
if
(
aEvent
-
>
mScroll
.
mIsHorizontal
)
{
pt
.
x
=
aEvent
-
>
mScroll
.
mAmount
;
}
else
{
pt
.
y
=
aEvent
-
>
mScroll
.
mAmount
;
}
sf
-
>
ScrollBy
(
pt
scrollUnit
ScrollMode
:
:
Instant
)
;
return
NS_OK
;
}
void
EventStateManager
:
:
SetActiveManager
(
EventStateManager
*
aNewESM
nsIContent
*
aContent
)
{
if
(
sActiveESM
&
&
aNewESM
!
=
sActiveESM
)
{
sActiveESM
-
>
SetContentState
(
nullptr
ElementState
:
:
ACTIVE
)
;
}
sActiveESM
=
aNewESM
;
if
(
sActiveESM
&
&
aContent
)
{
sActiveESM
-
>
SetContentState
(
aContent
ElementState
:
:
ACTIVE
)
;
}
}
void
EventStateManager
:
:
ClearGlobalActiveContent
(
EventStateManager
*
aClearer
)
{
if
(
aClearer
)
{
aClearer
-
>
SetContentState
(
nullptr
ElementState
:
:
ACTIVE
)
;
if
(
sDragOverContent
)
{
aClearer
-
>
SetContentState
(
nullptr
ElementState
:
:
DRAGOVER
)
;
}
}
if
(
sActiveESM
&
&
aClearer
!
=
sActiveESM
)
{
sActiveESM
-
>
SetContentState
(
nullptr
ElementState
:
:
ACTIVE
)
;
}
sActiveESM
=
nullptr
;
}
void
EventStateManager
:
:
DeltaAccumulator
:
:
InitLineOrPageDelta
(
nsIFrame
*
aTargetFrame
EventStateManager
*
aESM
WidgetWheelEvent
*
aEvent
)
{
MOZ_ASSERT
(
aESM
)
;
MOZ_ASSERT
(
aEvent
)
;
if
(
!
mLastTime
.
IsNull
(
)
)
{
TimeDuration
duration
=
TimeStamp
:
:
Now
(
)
-
mLastTime
;
if
(
duration
.
ToMilliseconds
(
)
>
StaticPrefs
:
:
mousewheel_transaction_timeout
(
)
)
{
Reset
(
)
;
}
}
if
(
IsInTransaction
(
)
)
{
if
(
mHandlingDeltaMode
!
=
aEvent
-
>
mDeltaMode
|
|
mIsNoLineOrPageDeltaDevice
!
=
aEvent
-
>
mIsNoLineOrPageDelta
)
{
Reset
(
)
;
}
else
{
if
(
mX
&
&
aEvent
-
>
mDeltaX
&
&
(
(
aEvent
-
>
mDeltaX
>
0
.
0
)
!
=
(
mX
>
0
.
0
)
)
)
{
mX
=
mPendingScrollAmountX
=
0
.
0
;
}
if
(
mY
&
&
aEvent
-
>
mDeltaY
&
&
(
(
aEvent
-
>
mDeltaY
>
0
.
0
)
!
=
(
mY
>
0
.
0
)
)
)
{
mY
=
mPendingScrollAmountY
=
0
.
0
;
}
}
}
mHandlingDeltaMode
=
aEvent
-
>
mDeltaMode
;
mIsNoLineOrPageDeltaDevice
=
aEvent
-
>
mIsNoLineOrPageDelta
;
{
nsIFrame
*
frame
=
aESM
-
>
ComputeScrollTarget
(
aTargetFrame
aEvent
COMPUTE_DEFAULT_ACTION_TARGET
)
;
nsPresContext
*
pc
=
frame
?
frame
-
>
PresContext
(
)
:
aTargetFrame
-
>
PresContext
(
)
;
nsIScrollableFrame
*
scrollTarget
=
do_QueryFrame
(
frame
)
;
aEvent
-
>
mScrollAmount
=
aESM
-
>
GetScrollAmount
(
pc
aEvent
scrollTarget
)
;
}
if
(
!
mIsNoLineOrPageDeltaDevice
&
&
!
EventStateManager
:
:
WheelPrefs
:
:
GetInstance
(
)
-
>
NeedToComputeLineOrPageDelta
(
aEvent
)
)
{
if
(
aEvent
-
>
mDeltaX
)
{
mX
=
aEvent
-
>
mDeltaX
;
}
if
(
aEvent
-
>
mDeltaY
)
{
mY
=
aEvent
-
>
mDeltaY
;
}
mLastTime
=
TimeStamp
:
:
Now
(
)
;
return
;
}
mX
+
=
aEvent
-
>
mDeltaX
;
mY
+
=
aEvent
-
>
mDeltaY
;
if
(
mHandlingDeltaMode
=
=
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
)
{
auto
scrollAmountInCSSPixels
=
CSSIntSize
:
:
FromAppUnitsRounded
(
aEvent
-
>
mScrollAmount
)
;
aEvent
-
>
mLineOrPageDeltaX
=
RoundDown
(
mX
)
/
scrollAmountInCSSPixels
.
width
;
aEvent
-
>
mLineOrPageDeltaY
=
RoundDown
(
mY
)
/
scrollAmountInCSSPixels
.
height
;
mX
-
=
aEvent
-
>
mLineOrPageDeltaX
*
scrollAmountInCSSPixels
.
width
;
mY
-
=
aEvent
-
>
mLineOrPageDeltaY
*
scrollAmountInCSSPixels
.
height
;
}
else
{
aEvent
-
>
mLineOrPageDeltaX
=
RoundDown
(
mX
)
;
aEvent
-
>
mLineOrPageDeltaY
=
RoundDown
(
mY
)
;
mX
-
=
aEvent
-
>
mLineOrPageDeltaX
;
mY
-
=
aEvent
-
>
mLineOrPageDeltaY
;
}
mLastTime
=
TimeStamp
:
:
Now
(
)
;
}
void
EventStateManager
:
:
DeltaAccumulator
:
:
Reset
(
)
{
mX
=
mY
=
0
.
0
;
mPendingScrollAmountX
=
mPendingScrollAmountY
=
0
.
0
;
mHandlingDeltaMode
=
UINT32_MAX
;
mIsNoLineOrPageDeltaDevice
=
false
;
}
nsIntPoint
EventStateManager
:
:
DeltaAccumulator
:
:
ComputeScrollAmountForDefaultAction
(
WidgetWheelEvent
*
aEvent
const
nsIntSize
&
aScrollAmountInDevPixels
)
{
MOZ_ASSERT
(
aEvent
)
;
DeltaValues
acceleratedDelta
=
WheelTransaction
:
:
AccelerateWheelDelta
(
aEvent
)
;
nsIntPoint
result
(
0
0
)
;
if
(
aEvent
-
>
mDeltaMode
=
=
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
)
{
mPendingScrollAmountX
+
=
acceleratedDelta
.
deltaX
;
mPendingScrollAmountY
+
=
acceleratedDelta
.
deltaY
;
}
else
{
mPendingScrollAmountX
+
=
aScrollAmountInDevPixels
.
width
*
acceleratedDelta
.
deltaX
;
mPendingScrollAmountY
+
=
aScrollAmountInDevPixels
.
height
*
acceleratedDelta
.
deltaY
;
}
result
.
x
=
RoundDown
(
mPendingScrollAmountX
)
;
result
.
y
=
RoundDown
(
mPendingScrollAmountY
)
;
mPendingScrollAmountX
-
=
result
.
x
;
mPendingScrollAmountY
-
=
result
.
y
;
return
result
;
}
EventStateManager
:
:
WheelPrefs
*
EventStateManager
:
:
WheelPrefs
:
:
GetInstance
(
)
{
if
(
!
sInstance
)
{
sInstance
=
new
WheelPrefs
(
)
;
}
return
sInstance
;
}
void
EventStateManager
:
:
WheelPrefs
:
:
Shutdown
(
)
{
delete
sInstance
;
sInstance
=
nullptr
;
}
void
EventStateManager
:
:
WheelPrefs
:
:
OnPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
{
sInstance
-
>
Reset
(
)
;
DeltaAccumulator
:
:
GetInstance
(
)
-
>
Reset
(
)
;
}
EventStateManager
:
:
WheelPrefs
:
:
WheelPrefs
(
)
{
Reset
(
)
;
Preferences
:
:
RegisterPrefixCallback
(
OnPrefChanged
"
mousewheel
.
"
)
;
}
EventStateManager
:
:
WheelPrefs
:
:
~
WheelPrefs
(
)
{
Preferences
:
:
UnregisterPrefixCallback
(
OnPrefChanged
"
mousewheel
.
"
)
;
}
void
EventStateManager
:
:
WheelPrefs
:
:
Reset
(
)
{
memset
(
mInit
0
sizeof
(
mInit
)
)
;
}
EventStateManager
:
:
WheelPrefs
:
:
Index
EventStateManager
:
:
WheelPrefs
:
:
GetIndexFor
(
const
WidgetWheelEvent
*
aEvent
)
{
if
(
!
aEvent
)
{
return
INDEX_DEFAULT
;
}
Modifiers
modifiers
=
(
aEvent
-
>
mModifiers
&
(
MODIFIER_ALT
|
MODIFIER_CONTROL
|
MODIFIER_META
|
MODIFIER_SHIFT
|
MODIFIER_OS
)
)
;
switch
(
modifiers
)
{
case
MODIFIER_ALT
:
return
INDEX_ALT
;
case
MODIFIER_CONTROL
:
return
INDEX_CONTROL
;
case
MODIFIER_META
:
return
INDEX_META
;
case
MODIFIER_SHIFT
:
return
INDEX_SHIFT
;
case
MODIFIER_OS
:
return
INDEX_OS
;
default
:
return
INDEX_DEFAULT
;
}
}
void
EventStateManager
:
:
WheelPrefs
:
:
GetBasePrefName
(
EventStateManager
:
:
WheelPrefs
:
:
Index
aIndex
nsACString
&
aBasePrefName
)
{
aBasePrefName
.
AssignLiteral
(
"
mousewheel
.
"
)
;
switch
(
aIndex
)
{
case
INDEX_ALT
:
aBasePrefName
.
AppendLiteral
(
"
with_alt
.
"
)
;
break
;
case
INDEX_CONTROL
:
aBasePrefName
.
AppendLiteral
(
"
with_control
.
"
)
;
break
;
case
INDEX_META
:
aBasePrefName
.
AppendLiteral
(
"
with_meta
.
"
)
;
break
;
case
INDEX_SHIFT
:
aBasePrefName
.
AppendLiteral
(
"
with_shift
.
"
)
;
break
;
case
INDEX_OS
:
aBasePrefName
.
AppendLiteral
(
"
with_win
.
"
)
;
break
;
case
INDEX_DEFAULT
:
default
:
aBasePrefName
.
AppendLiteral
(
"
default
.
"
)
;
break
;
}
}
void
EventStateManager
:
:
WheelPrefs
:
:
Init
(
EventStateManager
:
:
WheelPrefs
:
:
Index
aIndex
)
{
if
(
mInit
[
aIndex
]
)
{
return
;
}
mInit
[
aIndex
]
=
true
;
nsAutoCString
basePrefName
;
GetBasePrefName
(
aIndex
basePrefName
)
;
nsAutoCString
prefNameX
(
basePrefName
)
;
prefNameX
.
AppendLiteral
(
"
delta_multiplier_x
"
)
;
mMultiplierX
[
aIndex
]
=
static_cast
<
double
>
(
Preferences
:
:
GetInt
(
prefNameX
.
get
(
)
100
)
)
/
100
;
nsAutoCString
prefNameY
(
basePrefName
)
;
prefNameY
.
AppendLiteral
(
"
delta_multiplier_y
"
)
;
mMultiplierY
[
aIndex
]
=
static_cast
<
double
>
(
Preferences
:
:
GetInt
(
prefNameY
.
get
(
)
100
)
)
/
100
;
nsAutoCString
prefNameZ
(
basePrefName
)
;
prefNameZ
.
AppendLiteral
(
"
delta_multiplier_z
"
)
;
mMultiplierZ
[
aIndex
]
=
static_cast
<
double
>
(
Preferences
:
:
GetInt
(
prefNameZ
.
get
(
)
100
)
)
/
100
;
nsAutoCString
prefNameAction
(
basePrefName
)
;
prefNameAction
.
AppendLiteral
(
"
action
"
)
;
int32_t
action
=
Preferences
:
:
GetInt
(
prefNameAction
.
get
(
)
ACTION_SCROLL
)
;
if
(
action
<
int32_t
(
ACTION_NONE
)
|
|
action
>
int32_t
(
ACTION_LAST
)
)
{
NS_WARNING
(
"
Unsupported
action
pref
value
replaced
with
'
Scroll
'
.
"
)
;
action
=
ACTION_SCROLL
;
}
mActions
[
aIndex
]
=
static_cast
<
Action
>
(
action
)
;
prefNameAction
.
AppendLiteral
(
"
.
override_x
"
)
;
int32_t
actionOverrideX
=
Preferences
:
:
GetInt
(
prefNameAction
.
get
(
)
-
1
)
;
if
(
actionOverrideX
<
-
1
|
|
actionOverrideX
>
int32_t
(
ACTION_LAST
)
|
|
actionOverrideX
=
=
ACTION_HORIZONTALIZED_SCROLL
)
{
NS_WARNING
(
"
Unsupported
action
override
pref
value
didn
'
t
override
.
"
)
;
actionOverrideX
=
-
1
;
}
mOverriddenActionsX
[
aIndex
]
=
(
actionOverrideX
=
=
-
1
)
?
static_cast
<
Action
>
(
action
)
:
static_cast
<
Action
>
(
actionOverrideX
)
;
}
void
EventStateManager
:
:
WheelPrefs
:
:
GetMultiplierForDeltaXAndY
(
const
WidgetWheelEvent
*
aEvent
Index
aIndex
double
*
aMultiplierForDeltaX
double
*
aMultiplierForDeltaY
)
{
*
aMultiplierForDeltaX
=
mMultiplierX
[
aIndex
]
;
*
aMultiplierForDeltaY
=
mMultiplierY
[
aIndex
]
;
if
(
aEvent
-
>
mDeltaValuesHorizontalizedForDefaultHandler
&
&
ComputeActionFor
(
aEvent
)
=
=
ACTION_HORIZONTALIZED_SCROLL
)
{
std
:
:
swap
(
*
aMultiplierForDeltaX
*
aMultiplierForDeltaY
)
;
}
}
void
EventStateManager
:
:
WheelPrefs
:
:
ApplyUserPrefsToDelta
(
WidgetWheelEvent
*
aEvent
)
{
if
(
aEvent
-
>
mCustomizedByUserPrefs
)
{
return
;
}
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
double
multiplierForDeltaX
=
1
.
0
multiplierForDeltaY
=
1
.
0
;
GetMultiplierForDeltaXAndY
(
aEvent
index
&
multiplierForDeltaX
&
multiplierForDeltaY
)
;
aEvent
-
>
mDeltaX
*
=
multiplierForDeltaX
;
aEvent
-
>
mDeltaY
*
=
multiplierForDeltaY
;
aEvent
-
>
mDeltaZ
*
=
mMultiplierZ
[
index
]
;
if
(
!
NeedToComputeLineOrPageDelta
(
aEvent
)
)
{
aEvent
-
>
mLineOrPageDeltaX
*
=
static_cast
<
int32_t
>
(
multiplierForDeltaX
)
;
aEvent
-
>
mLineOrPageDeltaY
*
=
static_cast
<
int32_t
>
(
multiplierForDeltaY
)
;
}
else
{
aEvent
-
>
mLineOrPageDeltaX
=
0
;
aEvent
-
>
mLineOrPageDeltaY
=
0
;
}
aEvent
-
>
mCustomizedByUserPrefs
=
(
(
mMultiplierX
[
index
]
!
=
1
.
0
)
|
|
(
mMultiplierY
[
index
]
!
=
1
.
0
)
|
|
(
mMultiplierZ
[
index
]
!
=
1
.
0
)
)
;
}
void
EventStateManager
:
:
WheelPrefs
:
:
CancelApplyingUserPrefsFromOverflowDelta
(
WidgetWheelEvent
*
aEvent
)
{
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
double
multiplierForDeltaX
=
1
.
0
multiplierForDeltaY
=
1
.
0
;
GetMultiplierForDeltaXAndY
(
aEvent
index
&
multiplierForDeltaX
&
multiplierForDeltaY
)
;
if
(
multiplierForDeltaX
)
{
aEvent
-
>
mOverflowDeltaX
/
=
multiplierForDeltaX
;
}
if
(
multiplierForDeltaY
)
{
aEvent
-
>
mOverflowDeltaY
/
=
multiplierForDeltaY
;
}
}
EventStateManager
:
:
WheelPrefs
:
:
Action
EventStateManager
:
:
WheelPrefs
:
:
ComputeActionFor
(
const
WidgetWheelEvent
*
aEvent
)
{
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
bool
deltaXPreferred
=
(
Abs
(
aEvent
-
>
mDeltaX
)
>
Abs
(
aEvent
-
>
mDeltaY
)
&
&
Abs
(
aEvent
-
>
mDeltaX
)
>
Abs
(
aEvent
-
>
mDeltaZ
)
)
;
Action
*
actions
=
deltaXPreferred
?
mOverriddenActionsX
:
mActions
;
if
(
actions
[
index
]
=
=
ACTION_NONE
|
|
actions
[
index
]
=
=
ACTION_SCROLL
|
|
actions
[
index
]
=
=
ACTION_HORIZONTALIZED_SCROLL
)
{
return
actions
[
index
]
;
}
if
(
aEvent
-
>
mIsMomentum
)
{
Init
(
INDEX_DEFAULT
)
;
if
(
actions
[
INDEX_DEFAULT
]
=
=
ACTION_SCROLL
|
|
actions
[
INDEX_DEFAULT
]
=
=
ACTION_HORIZONTALIZED_SCROLL
)
{
return
actions
[
INDEX_DEFAULT
]
;
}
return
ACTION_NONE
;
}
return
actions
[
index
]
;
}
bool
EventStateManager
:
:
WheelPrefs
:
:
NeedToComputeLineOrPageDelta
(
const
WidgetWheelEvent
*
aEvent
)
{
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
return
(
mMultiplierX
[
index
]
!
=
1
.
0
&
&
mMultiplierX
[
index
]
!
=
-
1
.
0
)
|
|
(
mMultiplierY
[
index
]
!
=
1
.
0
&
&
mMultiplierY
[
index
]
!
=
-
1
.
0
)
;
}
void
EventStateManager
:
:
WheelPrefs
:
:
GetUserPrefsForEvent
(
const
WidgetWheelEvent
*
aEvent
double
*
aOutMultiplierX
double
*
aOutMultiplierY
)
{
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
double
multiplierForDeltaX
=
1
.
0
multiplierForDeltaY
=
1
.
0
;
GetMultiplierForDeltaXAndY
(
aEvent
index
&
multiplierForDeltaX
&
multiplierForDeltaY
)
;
*
aOutMultiplierX
=
multiplierForDeltaX
;
*
aOutMultiplierY
=
multiplierForDeltaY
;
}
Maybe
<
layers
:
:
APZWheelAction
>
EventStateManager
:
:
APZWheelActionFor
(
const
WidgetWheelEvent
*
aEvent
)
{
if
(
aEvent
-
>
mMessage
!
=
eWheel
)
{
return
Nothing
(
)
;
}
WheelPrefs
:
:
Action
action
=
WheelPrefs
:
:
GetInstance
(
)
-
>
ComputeActionFor
(
aEvent
)
;
switch
(
action
)
{
case
WheelPrefs
:
:
ACTION_SCROLL
:
case
WheelPrefs
:
:
ACTION_HORIZONTALIZED_SCROLL
:
return
Some
(
layers
:
:
APZWheelAction
:
:
Scroll
)
;
case
WheelPrefs
:
:
ACTION_PINCH_ZOOM
:
return
Some
(
layers
:
:
APZWheelAction
:
:
PinchZoom
)
;
default
:
return
Nothing
(
)
;
}
}
WheelDeltaAdjustmentStrategy
EventStateManager
:
:
GetWheelDeltaAdjustmentStrategy
(
const
WidgetWheelEvent
&
aEvent
)
{
if
(
aEvent
.
mMessage
!
=
eWheel
)
{
return
WheelDeltaAdjustmentStrategy
:
:
eNone
;
}
switch
(
WheelPrefs
:
:
GetInstance
(
)
-
>
ComputeActionFor
(
&
aEvent
)
)
{
case
WheelPrefs
:
:
ACTION_SCROLL
:
if
(
StaticPrefs
:
:
mousewheel_autodir_enabled
(
)
&
&
0
=
=
aEvent
.
mDeltaZ
)
{
if
(
StaticPrefs
:
:
mousewheel_autodir_honourroot
(
)
)
{
return
WheelDeltaAdjustmentStrategy
:
:
eAutoDirWithRootHonour
;
}
return
WheelDeltaAdjustmentStrategy
:
:
eAutoDir
;
}
return
WheelDeltaAdjustmentStrategy
:
:
eNone
;
case
WheelPrefs
:
:
ACTION_HORIZONTALIZED_SCROLL
:
return
WheelDeltaAdjustmentStrategy
:
:
eHorizontalize
;
default
:
break
;
}
return
WheelDeltaAdjustmentStrategy
:
:
eNone
;
}
void
EventStateManager
:
:
GetUserPrefsForWheelEvent
(
const
WidgetWheelEvent
*
aEvent
double
*
aOutMultiplierX
double
*
aOutMultiplierY
)
{
WheelPrefs
:
:
GetInstance
(
)
-
>
GetUserPrefsForEvent
(
aEvent
aOutMultiplierX
aOutMultiplierY
)
;
}
bool
EventStateManager
:
:
WheelPrefs
:
:
IsOverOnePageScrollAllowedX
(
const
WidgetWheelEvent
*
aEvent
)
{
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
return
Abs
(
mMultiplierX
[
index
]
)
>
=
MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL
;
}
bool
EventStateManager
:
:
WheelPrefs
:
:
IsOverOnePageScrollAllowedY
(
const
WidgetWheelEvent
*
aEvent
)
{
Index
index
=
GetIndexFor
(
aEvent
)
;
Init
(
index
)
;
return
Abs
(
mMultiplierY
[
index
]
)
>
=
MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL
;
}
}
