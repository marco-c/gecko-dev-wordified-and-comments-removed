#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
<
new
>
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
AnimationEvent
.
h
"
#
include
"
BeforeUnloadEvent
.
h
"
#
include
"
ClipboardEvent
.
h
"
#
include
"
CommandEvent
.
h
"
#
include
"
CompositionEvent
.
h
"
#
include
"
DeviceMotionEvent
.
h
"
#
include
"
DragEvent
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
KeyboardEvent
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
dom
/
CloseEvent
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
mozilla
/
dom
/
DeviceOrientationEvent
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
FocusEvent
.
h
"
#
include
"
mozilla
/
dom
/
HashChangeEvent
.
h
"
#
include
"
mozilla
/
dom
/
InputEvent
.
h
"
#
include
"
mozilla
/
dom
/
MessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
MouseScrollEvent
.
h
"
#
include
"
mozilla
/
dom
/
MutationEvent
.
h
"
#
include
"
mozilla
/
dom
/
NotifyPaintEvent
.
h
"
#
include
"
mozilla
/
dom
/
PageTransitionEvent
.
h
"
#
include
"
mozilla
/
dom
/
PointerEvent
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
ScrollAreaEvent
.
h
"
#
include
"
mozilla
/
dom
/
SimpleGestureEvent
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
dom
/
TimeEvent
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
dom
/
TransitionEvent
.
h
"
#
include
"
mozilla
/
dom
/
WheelEvent
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
XULCommandEvent
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
namespace
mozilla
{
using
namespace
dom
;
class
ELMCreationDetector
{
public
:
ELMCreationDetector
(
)
:
mNonMainThread
(
!
NS_IsMainThread
(
)
)
mInitialCount
(
mNonMainThread
?
0
:
EventListenerManager
:
:
sMainThreadCreatedCount
)
{
}
bool
MayHaveNewListenerManager
(
)
{
return
mNonMainThread
|
|
mInitialCount
!
=
EventListenerManager
:
:
sMainThreadCreatedCount
;
}
bool
IsMainThread
(
)
{
return
!
mNonMainThread
;
}
private
:
bool
mNonMainThread
;
uint32_t
mInitialCount
;
}
;
static
bool
IsEventTargetChrome
(
EventTarget
*
aEventTarget
nsIDocument
*
*
aDocument
=
nullptr
)
{
if
(
aDocument
)
{
*
aDocument
=
nullptr
;
}
nsIDocument
*
doc
=
nullptr
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aEventTarget
)
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
}
else
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aEventTarget
)
;
if
(
!
window
)
{
return
false
;
}
doc
=
window
-
>
GetExtantDoc
(
)
;
}
bool
isChrome
=
nsContentUtils
:
:
IsChromeDoc
(
doc
)
;
if
(
aDocument
&
&
doc
)
{
nsCOMPtr
<
nsIDocument
>
retVal
=
doc
;
retVal
.
swap
(
*
aDocument
)
;
}
return
isChrome
;
}
class
EventTargetChainItem
{
private
:
explicit
EventTargetChainItem
(
EventTarget
*
aTarget
)
;
public
:
EventTargetChainItem
(
)
:
mItemFlags
(
0
)
{
MOZ_COUNT_CTOR
(
EventTargetChainItem
)
;
}
~
EventTargetChainItem
(
)
{
MOZ_COUNT_DTOR
(
EventTargetChainItem
)
;
}
static
EventTargetChainItem
*
Create
(
nsTArray
<
EventTargetChainItem
>
&
aChain
EventTarget
*
aTarget
EventTargetChainItem
*
aChild
=
nullptr
)
{
MOZ_ASSERT
(
GetLastCanHandleEventTarget
(
aChain
)
=
=
aChild
)
;
MOZ_ASSERT
(
!
aTarget
|
|
aTarget
=
=
aTarget
-
>
GetTargetForEventTargetChain
(
)
)
;
EventTargetChainItem
*
etci
=
aChain
.
AppendElement
(
)
;
etci
-
>
mTarget
=
aTarget
;
return
etci
;
}
static
void
DestroyLast
(
nsTArray
<
EventTargetChainItem
>
&
aChain
EventTargetChainItem
*
aItem
)
{
uint32_t
lastIndex
=
aChain
.
Length
(
)
-
1
;
MOZ_ASSERT
(
&
aChain
[
lastIndex
]
=
=
aItem
)
;
aChain
.
RemoveElementAt
(
lastIndex
)
;
}
static
EventTargetChainItem
*
GetFirstCanHandleEventTarget
(
nsTArray
<
EventTargetChainItem
>
&
aChain
)
{
return
&
aChain
[
GetFirstCanHandleEventTargetIdx
(
aChain
)
]
;
}
static
uint32_t
GetFirstCanHandleEventTargetIdx
(
nsTArray
<
EventTargetChainItem
>
&
aChain
)
{
for
(
uint32_t
i
=
0
;
i
<
aChain
.
Length
(
)
;
+
+
i
)
{
if
(
!
aChain
[
i
]
.
PreHandleEventOnly
(
)
)
{
return
i
;
}
}
MOZ_ASSERT
(
false
)
;
return
0
;
}
static
EventTargetChainItem
*
GetLastCanHandleEventTarget
(
nsTArray
<
EventTargetChainItem
>
&
aChain
)
{
for
(
int32_t
i
=
aChain
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
!
aChain
[
i
]
.
PreHandleEventOnly
(
)
)
{
return
&
aChain
[
i
]
;
}
}
return
nullptr
;
}
bool
IsValid
(
)
{
NS_WARNING_ASSERTION
(
!
!
(
mTarget
)
"
Event
target
is
not
valid
!
"
)
;
return
!
!
(
mTarget
)
;
}
EventTarget
*
GetNewTarget
(
)
{
return
mNewTarget
;
}
void
SetNewTarget
(
EventTarget
*
aNewTarget
)
{
mNewTarget
=
aNewTarget
;
}
EventTarget
*
GetRetargetedRelatedTarget
(
)
{
return
mRetargetedRelatedTarget
;
}
void
SetRetargetedRelatedTarget
(
EventTarget
*
aTarget
)
{
mRetargetedRelatedTarget
=
aTarget
;
}
void
SetRetargetedTouchTarget
(
Maybe
<
nsTArray
<
RefPtr
<
EventTarget
>
>
>
&
&
aTargets
)
{
mRetargetedTouchTargets
=
std
:
:
move
(
aTargets
)
;
}
bool
HasRetargetTouchTargets
(
)
{
return
mRetargetedTouchTargets
.
isSome
(
)
|
|
mInitialTargetTouches
.
isSome
(
)
;
}
void
RetargetTouchTargets
(
WidgetTouchEvent
*
aTouchEvent
Event
*
aDOMEvent
)
{
MOZ_ASSERT
(
HasRetargetTouchTargets
(
)
)
;
MOZ_ASSERT
(
aTouchEvent
"
mRetargetedTouchTargets
should
be
empty
when
dispatching
non
-
touch
events
.
"
)
;
if
(
mRetargetedTouchTargets
.
isSome
(
)
)
{
WidgetTouchEvent
:
:
TouchArray
&
touches
=
aTouchEvent
-
>
mTouches
;
MOZ_ASSERT
(
!
touches
.
Length
(
)
|
|
touches
.
Length
(
)
=
=
mRetargetedTouchTargets
-
>
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
touches
[
i
]
-
>
mTarget
=
mRetargetedTouchTargets
-
>
ElementAt
(
i
)
;
}
}
if
(
aDOMEvent
)
{
TouchEvent
*
touchDOMEvent
=
static_cast
<
TouchEvent
*
>
(
aDOMEvent
)
;
TouchList
*
targetTouches
=
touchDOMEvent
-
>
GetExistingTargetTouches
(
)
;
if
(
targetTouches
)
{
targetTouches
-
>
Clear
(
)
;
if
(
mInitialTargetTouches
.
isSome
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
mInitialTargetTouches
-
>
Length
(
)
;
+
+
i
)
{
Touch
*
touch
=
mInitialTargetTouches
-
>
ElementAt
(
i
)
;
if
(
touch
)
{
touch
-
>
mTarget
=
touch
-
>
mOriginalTarget
;
}
targetTouches
-
>
Append
(
touch
)
;
}
}
}
}
}
void
SetInitialTargetTouches
(
Maybe
<
nsTArray
<
RefPtr
<
dom
:
:
Touch
>
>
>
&
&
aInitialTargetTouches
)
{
mInitialTargetTouches
=
std
:
:
move
(
aInitialTargetTouches
)
;
}
void
SetForceContentDispatch
(
bool
aForce
)
{
mFlags
.
mForceContentDispatch
=
aForce
;
}
bool
ForceContentDispatch
(
)
{
return
mFlags
.
mForceContentDispatch
;
}
void
SetWantsWillHandleEvent
(
bool
aWants
)
{
mFlags
.
mWantsWillHandleEvent
=
aWants
;
}
bool
WantsWillHandleEvent
(
)
{
return
mFlags
.
mWantsWillHandleEvent
;
}
void
SetWantsPreHandleEvent
(
bool
aWants
)
{
mFlags
.
mWantsPreHandleEvent
=
aWants
;
}
bool
WantsPreHandleEvent
(
)
{
return
mFlags
.
mWantsPreHandleEvent
;
}
void
SetPreHandleEventOnly
(
bool
aWants
)
{
mFlags
.
mPreHandleEventOnly
=
aWants
;
}
bool
PreHandleEventOnly
(
)
{
return
mFlags
.
mPreHandleEventOnly
;
}
void
SetRootOfClosedTree
(
bool
aSet
)
{
mFlags
.
mRootOfClosedTree
=
aSet
;
}
bool
IsRootOfClosedTree
(
)
{
return
mFlags
.
mRootOfClosedTree
;
}
void
SetItemInShadowTree
(
bool
aSet
)
{
mFlags
.
mItemInShadowTree
=
aSet
;
}
bool
IsItemInShadowTree
(
)
{
return
mFlags
.
mItemInShadowTree
;
}
void
SetIsSlotInClosedTree
(
bool
aSet
)
{
mFlags
.
mIsSlotInClosedTree
=
aSet
;
}
bool
IsSlotInClosedTree
(
)
{
return
mFlags
.
mIsSlotInClosedTree
;
}
void
SetIsChromeHandler
(
bool
aSet
)
{
mFlags
.
mIsChromeHandler
=
aSet
;
}
bool
IsChromeHandler
(
)
{
return
mFlags
.
mIsChromeHandler
;
}
void
SetMayHaveListenerManager
(
bool
aMayHave
)
{
mFlags
.
mMayHaveManager
=
aMayHave
;
}
bool
MayHaveListenerManager
(
)
{
return
mFlags
.
mMayHaveManager
;
}
EventTarget
*
CurrentTarget
(
)
{
return
mTarget
;
}
static
void
HandleEventTargetChain
(
nsTArray
<
EventTargetChainItem
>
&
aChain
EventChainPostVisitor
&
aVisitor
EventDispatchingCallback
*
aCallback
ELMCreationDetector
&
aCd
)
;
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
;
void
PreHandleEvent
(
EventChainVisitor
&
aVisitor
)
;
void
HandleEvent
(
EventChainPostVisitor
&
aVisitor
ELMCreationDetector
&
aCd
)
{
if
(
WantsWillHandleEvent
(
)
)
{
mTarget
-
>
WillHandleEvent
(
aVisitor
)
;
}
if
(
aVisitor
.
mEvent
-
>
PropagationStopped
(
)
)
{
return
;
}
if
(
aVisitor
.
mEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
&
&
!
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
&
&
!
IsCurrentTargetChrome
(
)
)
{
return
;
}
if
(
!
mManager
)
{
if
(
!
MayHaveListenerManager
(
)
&
&
!
aCd
.
MayHaveNewListenerManager
(
)
)
{
return
;
}
mManager
=
mTarget
-
>
GetExistingListenerManager
(
)
;
}
if
(
mManager
)
{
NS_ASSERTION
(
aVisitor
.
mEvent
-
>
mCurrentTarget
=
=
nullptr
"
CurrentTarget
should
be
null
!
"
)
;
mManager
-
>
HandleEvent
(
aVisitor
.
mPresContext
aVisitor
.
mEvent
&
aVisitor
.
mDOMEvent
CurrentTarget
(
)
&
aVisitor
.
mEventStatus
IsItemInShadowTree
(
)
)
;
NS_ASSERTION
(
aVisitor
.
mEvent
-
>
mCurrentTarget
=
=
nullptr
"
CurrentTarget
should
be
null
!
"
)
;
}
}
void
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
;
private
:
nsCOMPtr
<
EventTarget
>
mTarget
;
nsCOMPtr
<
EventTarget
>
mRetargetedRelatedTarget
;
Maybe
<
nsTArray
<
RefPtr
<
EventTarget
>
>
>
mRetargetedTouchTargets
;
Maybe
<
nsTArray
<
RefPtr
<
dom
:
:
Touch
>
>
>
mInitialTargetTouches
;
class
EventTargetChainFlags
{
public
:
explicit
EventTargetChainFlags
(
)
{
SetRawFlags
(
0
)
;
}
bool
mForceContentDispatch
:
1
;
bool
mWantsWillHandleEvent
:
1
;
bool
mMayHaveManager
:
1
;
bool
mChechedIfChrome
:
1
;
bool
mIsChromeContent
:
1
;
bool
mWantsPreHandleEvent
:
1
;
bool
mPreHandleEventOnly
:
1
;
bool
mRootOfClosedTree
:
1
;
bool
mItemInShadowTree
:
1
;
bool
mIsSlotInClosedTree
:
1
;
bool
mIsChromeHandler
:
1
;
private
:
typedef
uint32_t
RawFlags
;
void
SetRawFlags
(
RawFlags
aRawFlags
)
{
static_assert
(
sizeof
(
EventTargetChainFlags
)
<
=
sizeof
(
RawFlags
)
"
EventTargetChainFlags
must
not
be
bigger
than
the
RawFlags
"
)
;
memcpy
(
this
&
aRawFlags
sizeof
(
EventTargetChainFlags
)
)
;
}
}
mFlags
;
uint16_t
mItemFlags
;
nsCOMPtr
<
nsISupports
>
mItemData
;
nsCOMPtr
<
EventTarget
>
mNewTarget
;
RefPtr
<
EventListenerManager
>
mManager
;
bool
IsCurrentTargetChrome
(
)
{
if
(
!
mFlags
.
mChechedIfChrome
)
{
mFlags
.
mChechedIfChrome
=
true
;
if
(
IsEventTargetChrome
(
mTarget
)
)
{
mFlags
.
mIsChromeContent
=
true
;
}
}
return
mFlags
.
mIsChromeContent
;
}
}
;
void
EventTargetChainItem
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
Reset
(
)
;
mTarget
-
>
GetEventTargetParent
(
aVisitor
)
;
SetForceContentDispatch
(
aVisitor
.
mForceContentDispatch
)
;
SetWantsWillHandleEvent
(
aVisitor
.
mWantsWillHandleEvent
)
;
SetMayHaveListenerManager
(
aVisitor
.
mMayHaveListenerManager
)
;
SetWantsPreHandleEvent
(
aVisitor
.
mWantsPreHandleEvent
)
;
SetPreHandleEventOnly
(
aVisitor
.
mWantsPreHandleEvent
&
&
!
aVisitor
.
mCanHandle
)
;
SetRootOfClosedTree
(
aVisitor
.
mRootOfClosedTree
)
;
SetItemInShadowTree
(
aVisitor
.
mItemInShadowTree
)
;
SetRetargetedRelatedTarget
(
aVisitor
.
mRetargetedRelatedTarget
)
;
SetRetargetedTouchTarget
(
std
:
:
move
(
aVisitor
.
mRetargetedTouchTargets
)
)
;
mItemFlags
=
aVisitor
.
mItemFlags
;
mItemData
=
aVisitor
.
mItemData
;
}
void
EventTargetChainItem
:
:
PreHandleEvent
(
EventChainVisitor
&
aVisitor
)
{
if
(
!
WantsPreHandleEvent
(
)
)
{
return
;
}
aVisitor
.
mItemFlags
=
mItemFlags
;
aVisitor
.
mItemData
=
mItemData
;
Unused
<
<
mTarget
-
>
PreHandleEvent
(
aVisitor
)
;
}
void
EventTargetChainItem
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
aVisitor
.
mItemFlags
=
mItemFlags
;
aVisitor
.
mItemData
=
mItemData
;
mTarget
-
>
PostHandleEvent
(
aVisitor
)
;
}
void
EventTargetChainItem
:
:
HandleEventTargetChain
(
nsTArray
<
EventTargetChainItem
>
&
aChain
EventChainPostVisitor
&
aVisitor
EventDispatchingCallback
*
aCallback
ELMCreationDetector
&
aCd
)
{
nsCOMPtr
<
EventTarget
>
firstTarget
=
aVisitor
.
mEvent
-
>
mTarget
;
nsCOMPtr
<
EventTarget
>
firstRelatedTarget
=
aVisitor
.
mEvent
-
>
mRelatedTarget
;
Maybe
<
AutoTArray
<
nsCOMPtr
<
EventTarget
>
10
>
>
firstTouchTargets
;
WidgetTouchEvent
*
touchEvent
=
nullptr
;
if
(
aVisitor
.
mEvent
-
>
mClass
=
=
eTouchEventClass
)
{
touchEvent
=
aVisitor
.
mEvent
-
>
AsTouchEvent
(
)
;
if
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
)
{
firstTouchTargets
.
emplace
(
)
;
WidgetTouchEvent
*
touchEvent
=
aVisitor
.
mEvent
-
>
AsTouchEvent
(
)
;
WidgetTouchEvent
:
:
TouchArray
&
touches
=
touchEvent
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
firstTouchTargets
-
>
AppendElement
(
touches
[
i
]
-
>
mTarget
)
;
}
}
}
uint32_t
chainLength
=
aChain
.
Length
(
)
;
uint32_t
firstCanHandleEventTargetIdx
=
EventTargetChainItem
:
:
GetFirstCanHandleEventTargetIdx
(
aChain
)
;
aVisitor
.
mEvent
-
>
mFlags
.
mInCapturePhase
=
true
;
aVisitor
.
mEvent
-
>
mFlags
.
mInBubblingPhase
=
false
;
for
(
uint32_t
i
=
chainLength
-
1
;
i
>
firstCanHandleEventTargetIdx
;
-
-
i
)
{
EventTargetChainItem
&
item
=
aChain
[
i
]
;
if
(
item
.
PreHandleEventOnly
(
)
)
{
continue
;
}
if
(
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
|
|
item
.
ForceContentDispatch
(
)
)
&
&
!
aVisitor
.
mEvent
-
>
PropagationStopped
(
)
)
{
item
.
HandleEvent
(
aVisitor
aCd
)
;
}
if
(
item
.
GetNewTarget
(
)
)
{
for
(
uint32_t
j
=
i
;
j
>
0
;
-
-
j
)
{
uint32_t
childIndex
=
j
-
1
;
EventTarget
*
newTarget
=
aChain
[
childIndex
]
.
GetNewTarget
(
)
;
if
(
newTarget
)
{
aVisitor
.
mEvent
-
>
mTarget
=
newTarget
;
break
;
}
}
}
if
(
item
.
GetRetargetedRelatedTarget
(
)
)
{
bool
found
=
false
;
for
(
uint32_t
j
=
i
;
j
>
0
;
-
-
j
)
{
uint32_t
childIndex
=
j
-
1
;
EventTarget
*
relatedTarget
=
aChain
[
childIndex
]
.
GetRetargetedRelatedTarget
(
)
;
if
(
relatedTarget
)
{
found
=
true
;
aVisitor
.
mEvent
-
>
mRelatedTarget
=
relatedTarget
;
break
;
}
}
if
(
!
found
)
{
aVisitor
.
mEvent
-
>
mRelatedTarget
=
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
;
}
}
if
(
item
.
HasRetargetTouchTargets
(
)
)
{
bool
found
=
false
;
for
(
uint32_t
j
=
i
;
j
>
0
;
-
-
j
)
{
uint32_t
childIndex
=
j
-
1
;
if
(
aChain
[
childIndex
]
.
HasRetargetTouchTargets
(
)
)
{
found
=
true
;
aChain
[
childIndex
]
.
RetargetTouchTargets
(
touchEvent
aVisitor
.
mDOMEvent
)
;
break
;
}
}
if
(
!
found
)
{
WidgetTouchEvent
:
:
TouchArray
&
touches
=
touchEvent
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
touches
[
i
]
-
>
mTarget
=
touches
[
i
]
-
>
mOriginalTarget
;
}
}
}
}
aVisitor
.
mEvent
-
>
mFlags
.
mInBubblingPhase
=
true
;
EventTargetChainItem
&
targetItem
=
aChain
[
firstCanHandleEventTargetIdx
]
;
if
(
targetItem
.
HasRetargetTouchTargets
(
)
)
{
targetItem
.
RetargetTouchTargets
(
touchEvent
aVisitor
.
mDOMEvent
)
;
}
if
(
!
aVisitor
.
mEvent
-
>
PropagationStopped
(
)
&
&
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
|
|
targetItem
.
ForceContentDispatch
(
)
)
)
{
targetItem
.
HandleEvent
(
aVisitor
aCd
)
;
}
if
(
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
)
{
targetItem
.
PostHandleEvent
(
aVisitor
)
;
}
aVisitor
.
mEvent
-
>
mFlags
.
mInCapturePhase
=
false
;
for
(
uint32_t
i
=
firstCanHandleEventTargetIdx
+
1
;
i
<
chainLength
;
+
+
i
)
{
EventTargetChainItem
&
item
=
aChain
[
i
]
;
if
(
item
.
PreHandleEventOnly
(
)
)
{
continue
;
}
EventTarget
*
newTarget
=
item
.
GetNewTarget
(
)
;
if
(
newTarget
)
{
aVisitor
.
mEvent
-
>
mTarget
=
newTarget
;
}
EventTarget
*
relatedTarget
=
item
.
GetRetargetedRelatedTarget
(
)
;
if
(
relatedTarget
)
{
aVisitor
.
mEvent
-
>
mRelatedTarget
=
relatedTarget
;
}
if
(
item
.
HasRetargetTouchTargets
(
)
)
{
item
.
RetargetTouchTargets
(
touchEvent
aVisitor
.
mDOMEvent
)
;
}
if
(
aVisitor
.
mEvent
-
>
mFlags
.
mBubbles
|
|
newTarget
)
{
if
(
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
|
|
item
.
ForceContentDispatch
(
)
)
&
&
!
aVisitor
.
mEvent
-
>
PropagationStopped
(
)
)
{
item
.
HandleEvent
(
aVisitor
aCd
)
;
}
if
(
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
)
{
item
.
PostHandleEvent
(
aVisitor
)
;
}
}
}
aVisitor
.
mEvent
-
>
mFlags
.
mInBubblingPhase
=
false
;
if
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
&
&
aVisitor
.
mEvent
-
>
IsAllowedToDispatchInSystemGroup
(
)
)
{
aVisitor
.
mEvent
-
>
mFlags
.
mPropagationStopped
=
false
;
aVisitor
.
mEvent
-
>
mFlags
.
mImmediatePropagationStopped
=
false
;
aVisitor
.
mEvent
-
>
mTarget
=
aVisitor
.
mEvent
-
>
mOriginalTarget
;
aVisitor
.
mEvent
-
>
mRelatedTarget
=
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
;
if
(
firstTouchTargets
)
{
WidgetTouchEvent
:
:
TouchArray
&
touches
=
touchEvent
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
touches
[
i
]
-
>
mTarget
=
touches
[
i
]
-
>
mOriginalTarget
;
}
}
if
(
aCallback
)
{
aCallback
-
>
HandleEvent
(
aVisitor
)
;
}
aVisitor
.
mEvent
-
>
mTarget
=
firstTarget
;
aVisitor
.
mEvent
-
>
mRelatedTarget
=
firstRelatedTarget
;
if
(
firstTouchTargets
)
{
WidgetTouchEvent
:
:
TouchArray
&
touches
=
touchEvent
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
firstTouchTargets
-
>
Length
(
)
;
+
+
i
)
{
touches
[
i
]
-
>
mTarget
=
firstTouchTargets
-
>
ElementAt
(
i
)
;
}
}
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
=
true
;
HandleEventTargetChain
(
aChain
aVisitor
aCallback
aCd
)
;
aVisitor
.
mEvent
-
>
mFlags
.
mInSystemGroup
=
false
;
aVisitor
.
mEvent
-
>
mFlags
.
mPropagationStopped
=
false
;
aVisitor
.
mEvent
-
>
mFlags
.
mImmediatePropagationStopped
=
false
;
}
}
static
nsTArray
<
EventTargetChainItem
>
*
sCachedMainThreadChain
=
nullptr
;
void
EventDispatcher
:
:
Shutdown
(
)
{
delete
sCachedMainThreadChain
;
sCachedMainThreadChain
=
nullptr
;
}
EventTargetChainItem
*
EventTargetChainItemForChromeTarget
(
nsTArray
<
EventTargetChainItem
>
&
aChain
nsINode
*
aNode
EventTargetChainItem
*
aChild
=
nullptr
)
{
if
(
!
aNode
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
win
=
aNode
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
EventTarget
*
piTarget
=
win
?
win
-
>
GetParentTarget
(
)
:
nullptr
;
NS_ENSURE_TRUE
(
piTarget
nullptr
)
;
EventTargetChainItem
*
etci
=
EventTargetChainItem
:
:
Create
(
aChain
piTarget
-
>
GetTargetForEventTargetChain
(
)
aChild
)
;
if
(
!
etci
-
>
IsValid
(
)
)
{
EventTargetChainItem
:
:
DestroyLast
(
aChain
etci
)
;
return
nullptr
;
}
return
etci
;
}
EventTargetChainItem
*
MayRetargetToChromeIfCanNotHandleEvent
(
nsTArray
<
EventTargetChainItem
>
&
aChain
EventChainPreVisitor
&
aPreVisitor
EventTargetChainItem
*
aTargetEtci
EventTargetChainItem
*
aChildEtci
nsINode
*
aContent
)
{
if
(
!
aPreVisitor
.
mWantsPreHandleEvent
)
{
EventTargetChainItem
:
:
DestroyLast
(
aChain
aTargetEtci
)
;
}
if
(
aPreVisitor
.
mAutomaticChromeDispatch
&
&
aContent
)
{
aPreVisitor
.
mRelatedTargetRetargetedInCurrentScope
=
false
;
EventTargetChainItem
*
chromeTargetEtci
=
EventTargetChainItemForChromeTarget
(
aChain
aContent
aChildEtci
)
;
if
(
chromeTargetEtci
)
{
chromeTargetEtci
-
>
SetIsChromeHandler
(
true
)
;
chromeTargetEtci
-
>
GetEventTargetParent
(
aPreVisitor
)
;
return
chromeTargetEtci
;
}
}
return
nullptr
;
}
static
bool
ShouldClearTargets
(
WidgetEvent
*
aEvent
)
{
nsCOMPtr
<
nsIContent
>
finalTarget
;
nsCOMPtr
<
nsIContent
>
finalRelatedTarget
;
if
(
(
finalTarget
=
do_QueryInterface
(
aEvent
-
>
mTarget
)
)
&
&
finalTarget
-
>
SubtreeRoot
(
)
-
>
IsShadowRoot
(
)
)
{
return
true
;
}
if
(
(
finalRelatedTarget
=
do_QueryInterface
(
aEvent
-
>
mRelatedTarget
)
)
&
&
finalRelatedTarget
-
>
SubtreeRoot
(
)
-
>
IsShadowRoot
(
)
)
{
return
true
;
}
return
false
;
}
nsresult
EventDispatcher
:
:
Dispatch
(
nsISupports
*
aTarget
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
Event
*
aDOMEvent
nsEventStatus
*
aEventStatus
EventDispatchingCallback
*
aCallback
nsTArray
<
EventTarget
*
>
*
aTargets
)
{
AUTO_PROFILER_LABEL
(
"
EventDispatcher
:
:
Dispatch
"
OTHER
)
;
NS_ASSERTION
(
aEvent
"
Trying
to
dispatch
without
WidgetEvent
!
"
)
;
NS_ENSURE_TRUE
(
!
aEvent
-
>
mFlags
.
mIsBeingDispatched
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
NS_ASSERTION
(
!
aTargets
|
|
!
aEvent
-
>
mMessage
"
Wrong
parameters
!
"
)
;
NS_ENSURE_TRUE
(
aEvent
-
>
mMessage
|
|
!
aDOMEvent
|
|
aTargets
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsInStableOrMetaStableState
(
)
)
;
NS_ENSURE_TRUE
(
!
nsContentUtils
:
:
IsInStableOrMetaStableState
(
)
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
#
ifdef
MOZ_TASK_TRACER
if
(
MOZ_UNLIKELY
(
mozilla
:
:
tasktracer
:
:
IsStartLogging
(
)
)
)
{
nsAutoCString
eventType
;
nsAutoString
eventTypeU16
;
if
(
aDOMEvent
)
{
aDOMEvent
-
>
GetType
(
eventTypeU16
)
;
}
else
{
Event
:
:
GetWidgetEventType
(
aEvent
eventTypeU16
)
;
}
eventType
=
NS_ConvertUTF16toUTF8
(
eventTypeU16
)
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aTarget
)
;
nsAutoString
elementId
;
nsAutoString
elementTagName
;
if
(
element
)
{
element
-
>
GetId
(
elementId
)
;
element
-
>
GetTagName
(
elementTagName
)
;
}
AddLabel
(
"
Event
[
%
s
]
dispatched
at
target
[
id
:
%
s
tag
:
%
s
]
"
eventType
.
get
(
)
NS_ConvertUTF16toUTF8
(
elementId
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
elementTagName
)
.
get
(
)
)
;
}
#
endif
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
aTarget
)
;
bool
retargeted
=
false
;
if
(
aEvent
-
>
mFlags
.
mRetargetToNonNativeAnonymous
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
target
)
;
if
(
content
&
&
content
-
>
IsInNativeAnonymousSubtree
(
)
)
{
nsCOMPtr
<
EventTarget
>
newTarget
=
do_QueryInterface
(
content
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
;
NS_ENSURE_STATE
(
newTarget
)
;
aEvent
-
>
mOriginalTarget
=
target
;
target
=
newTarget
;
retargeted
=
true
;
}
}
if
(
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
)
{
nsCOMPtr
<
nsIDocument
>
doc
;
if
(
!
IsEventTargetChrome
(
target
getter_AddRefs
(
doc
)
)
&
&
doc
)
{
nsPIDOMWindowInner
*
win
=
doc
-
>
GetInnerWindow
(
)
;
EventTarget
*
piTarget
=
win
?
win
-
>
GetParentTarget
(
)
:
nullptr
;
if
(
!
piTarget
)
{
return
NS_OK
;
}
aEvent
-
>
mTarget
=
target
;
target
=
piTarget
;
}
else
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
#
ifdef
DEBUG
if
(
NS_IsMainThread
(
)
&
&
aEvent
-
>
mMessage
!
=
eVoidEvent
&
&
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
target
)
;
if
(
!
node
)
{
NS_ERROR
(
"
This
is
unsafe
!
Fix
the
caller
!
"
)
;
}
else
{
nsIDocument
*
doc
=
node
-
>
OwnerDoc
(
)
;
bool
hasHadScriptHandlingObject
;
nsIGlobalObject
*
global
=
doc
-
>
GetScriptHandlingObject
(
hasHadScriptHandlingObject
)
;
if
(
global
|
|
hasHadScriptHandlingObject
)
{
if
(
nsContentUtils
:
:
IsChromeDoc
(
doc
)
)
{
NS_WARNING
(
"
Fix
the
caller
!
"
)
;
}
else
{
NS_ERROR
(
"
This
is
unsafe
!
Fix
the
caller
!
"
)
;
}
}
}
}
if
(
aDOMEvent
)
{
WidgetEvent
*
innerEvent
=
aDOMEvent
-
>
WidgetEventPtr
(
)
;
NS_ASSERTION
(
innerEvent
=
=
aEvent
"
The
inner
event
of
aDOMEvent
is
not
the
same
as
aEvent
!
"
)
;
}
#
endif
nsresult
rv
=
NS_OK
;
bool
externalDOMEvent
=
!
!
(
aDOMEvent
)
;
RefPtr
<
nsPresContext
>
kungFuDeathGrip
(
aPresContext
)
;
ELMCreationDetector
cd
;
nsTArray
<
EventTargetChainItem
>
chain
;
if
(
cd
.
IsMainThread
(
)
)
{
if
(
!
sCachedMainThreadChain
)
{
sCachedMainThreadChain
=
new
nsTArray
<
EventTargetChainItem
>
(
)
;
}
chain
.
SwapElements
(
*
sCachedMainThreadChain
)
;
chain
.
SetCapacity
(
128
)
;
}
EventTargetChainItem
*
targetEtci
=
EventTargetChainItem
:
:
Create
(
chain
target
-
>
GetTargetForEventTargetChain
(
)
)
;
MOZ_ASSERT
(
&
chain
[
0
]
=
=
targetEtci
)
;
if
(
!
targetEtci
-
>
IsValid
(
)
)
{
EventTargetChainItem
:
:
DestroyLast
(
chain
targetEtci
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
aEvent
-
>
mTarget
)
{
aEvent
-
>
mTarget
=
targetEtci
-
>
CurrentTarget
(
)
;
}
else
{
aEvent
-
>
mTarget
=
aEvent
-
>
mTarget
-
>
GetTargetForEventTargetChain
(
)
;
NS_ENSURE_STATE
(
aEvent
-
>
mTarget
)
;
}
if
(
retargeted
)
{
aEvent
-
>
mOriginalTarget
=
aEvent
-
>
mOriginalTarget
-
>
GetTargetForEventTargetChain
(
)
;
NS_ENSURE_STATE
(
aEvent
-
>
mOriginalTarget
)
;
}
else
{
aEvent
-
>
mOriginalTarget
=
aEvent
-
>
mTarget
;
}
aEvent
-
>
mOriginalRelatedTarget
=
aEvent
-
>
mRelatedTarget
;
bool
clearTargets
=
false
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aEvent
-
>
mOriginalTarget
)
;
bool
isInAnon
=
content
&
&
content
-
>
IsInAnonymousSubtree
(
)
;
aEvent
-
>
mFlags
.
mIsBeingDispatched
=
true
;
nsEventStatus
status
=
aEventStatus
?
*
aEventStatus
:
nsEventStatus_eIgnore
;
EventChainPreVisitor
preVisitor
(
aPresContext
aEvent
aDOMEvent
status
isInAnon
aEvent
-
>
mTarget
)
;
targetEtci
-
>
GetEventTargetParent
(
preVisitor
)
;
if
(
!
preVisitor
.
mCanHandle
)
{
targetEtci
=
MayRetargetToChromeIfCanNotHandleEvent
(
chain
preVisitor
targetEtci
nullptr
content
)
;
}
if
(
!
preVisitor
.
mCanHandle
)
{
for
(
uint32_t
i
=
0
;
i
<
chain
.
Length
(
)
;
+
+
i
)
{
chain
[
i
]
.
PreHandleEvent
(
preVisitor
)
;
}
clearTargets
=
ShouldClearTargets
(
aEvent
)
;
}
else
{
nsCOMPtr
<
EventTarget
>
t
=
do_QueryInterface
(
aEvent
-
>
mTarget
)
;
targetEtci
-
>
SetNewTarget
(
t
)
;
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
&
&
aDOMEvent
)
{
TouchEvent
*
touchEvent
=
static_cast
<
TouchEvent
*
>
(
aDOMEvent
)
;
TouchList
*
targetTouches
=
touchEvent
-
>
GetExistingTargetTouches
(
)
;
if
(
targetTouches
)
{
Maybe
<
nsTArray
<
RefPtr
<
dom
:
:
Touch
>
>
>
initialTargetTouches
;
initialTargetTouches
.
emplace
(
)
;
for
(
uint32_t
i
=
0
;
i
<
targetTouches
-
>
Length
(
)
;
+
+
i
)
{
initialTargetTouches
-
>
AppendElement
(
targetTouches
-
>
Item
(
i
)
)
;
}
targetEtci
-
>
SetInitialTargetTouches
(
std
:
:
move
(
initialTargetTouches
)
)
;
targetTouches
-
>
Clear
(
)
;
}
}
EventTargetChainItem
*
topEtci
=
targetEtci
;
targetEtci
=
nullptr
;
while
(
preVisitor
.
GetParentTarget
(
)
)
{
EventTarget
*
parentTarget
=
preVisitor
.
GetParentTarget
(
)
;
EventTargetChainItem
*
parentEtci
=
EventTargetChainItem
:
:
Create
(
chain
parentTarget
topEtci
)
;
if
(
!
parentEtci
-
>
IsValid
(
)
)
{
EventTargetChainItem
:
:
DestroyLast
(
chain
parentEtci
)
;
rv
=
NS_ERROR_FAILURE
;
break
;
}
parentEtci
-
>
SetIsSlotInClosedTree
(
preVisitor
.
mParentIsSlotInClosedTree
)
;
parentEtci
-
>
SetIsChromeHandler
(
preVisitor
.
mParentIsChromeHandler
)
;
if
(
preVisitor
.
mEventTargetAtParent
)
{
preVisitor
.
mTargetInKnownToBeHandledScope
=
preVisitor
.
mEvent
-
>
mTarget
;
preVisitor
.
mEvent
-
>
mTarget
=
preVisitor
.
mEventTargetAtParent
;
parentEtci
-
>
SetNewTarget
(
preVisitor
.
mEventTargetAtParent
)
;
}
if
(
preVisitor
.
mRetargetedRelatedTarget
)
{
preVisitor
.
mEvent
-
>
mRelatedTarget
=
preVisitor
.
mRetargetedRelatedTarget
;
}
parentEtci
-
>
GetEventTargetParent
(
preVisitor
)
;
if
(
preVisitor
.
mCanHandle
)
{
preVisitor
.
mTargetInKnownToBeHandledScope
=
preVisitor
.
mEvent
-
>
mTarget
;
topEtci
=
parentEtci
;
}
else
{
bool
ignoreBecauseOfShadowDOM
=
preVisitor
.
mIgnoreBecauseOfShadowDOM
;
nsCOMPtr
<
nsINode
>
disabledTarget
=
do_QueryInterface
(
parentTarget
)
;
parentEtci
=
MayRetargetToChromeIfCanNotHandleEvent
(
chain
preVisitor
parentEtci
topEtci
disabledTarget
)
;
if
(
parentEtci
&
&
preVisitor
.
mCanHandle
)
{
preVisitor
.
mTargetInKnownToBeHandledScope
=
preVisitor
.
mEvent
-
>
mTarget
;
EventTargetChainItem
*
item
=
EventTargetChainItem
:
:
GetFirstCanHandleEventTarget
(
chain
)
;
if
(
!
ignoreBecauseOfShadowDOM
)
{
item
-
>
SetNewTarget
(
parentTarget
)
;
}
topEtci
=
parentEtci
;
continue
;
}
break
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aTargets
)
{
aTargets
-
>
Clear
(
)
;
uint32_t
numTargets
=
chain
.
Length
(
)
;
EventTarget
*
*
targets
=
aTargets
-
>
AppendElements
(
numTargets
)
;
for
(
uint32_t
i
=
0
;
i
<
numTargets
;
+
+
i
)
{
targets
[
i
]
=
chain
[
i
]
.
CurrentTarget
(
)
-
>
GetTargetForDOMEvent
(
)
;
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
chain
.
Length
(
)
;
+
+
i
)
{
chain
[
i
]
.
PreHandleEvent
(
preVisitor
)
;
}
clearTargets
=
ShouldClearTargets
(
aEvent
)
;
EventChainPostVisitor
postVisitor
(
preVisitor
)
;
MOZ_RELEASE_ASSERT
(
!
aEvent
-
>
mPath
)
;
aEvent
-
>
mPath
=
&
chain
;
EventTargetChainItem
:
:
HandleEventTargetChain
(
chain
postVisitor
aCallback
cd
)
;
aEvent
-
>
mPath
=
nullptr
;
preVisitor
.
mEventStatus
=
postVisitor
.
mEventStatus
;
if
(
!
preVisitor
.
mDOMEvent
&
&
postVisitor
.
mDOMEvent
)
{
preVisitor
.
mDOMEvent
=
postVisitor
.
mDOMEvent
;
}
}
}
}
aEvent
-
>
mFlags
.
mIsBeingDispatched
=
false
;
aEvent
-
>
mFlags
.
mDispatchedAtLeastOnce
=
true
;
if
(
clearTargets
)
{
aEvent
-
>
mTarget
=
nullptr
;
aEvent
-
>
mOriginalTarget
=
nullptr
;
aEvent
-
>
mRelatedTarget
=
nullptr
;
aEvent
-
>
mOriginalRelatedTarget
=
nullptr
;
}
if
(
!
externalDOMEvent
&
&
preVisitor
.
mDOMEvent
)
{
nsrefcnt
rc
=
0
;
NS_RELEASE2
(
preVisitor
.
mDOMEvent
rc
)
;
if
(
preVisitor
.
mDOMEvent
)
{
preVisitor
.
mDOMEvent
-
>
DuplicatePrivateData
(
)
;
}
}
if
(
aEventStatus
)
{
*
aEventStatus
=
preVisitor
.
mEventStatus
;
}
if
(
cd
.
IsMainThread
(
)
&
&
chain
.
Capacity
(
)
=
=
128
&
&
sCachedMainThreadChain
)
{
chain
.
ClearAndRetainStorage
(
)
;
chain
.
SwapElements
(
*
sCachedMainThreadChain
)
;
}
return
rv
;
}
nsresult
EventDispatcher
:
:
DispatchDOMEvent
(
nsISupports
*
aTarget
WidgetEvent
*
aEvent
Event
*
aDOMEvent
nsPresContext
*
aPresContext
nsEventStatus
*
aEventStatus
)
{
if
(
aDOMEvent
)
{
WidgetEvent
*
innerEvent
=
aDOMEvent
-
>
WidgetEventPtr
(
)
;
NS_ENSURE_TRUE
(
innerEvent
NS_ERROR_ILLEGAL_VALUE
)
;
bool
dontResetTrusted
=
false
;
if
(
innerEvent
-
>
mFlags
.
mDispatchedAtLeastOnce
)
{
innerEvent
-
>
mTarget
=
nullptr
;
innerEvent
-
>
mOriginalTarget
=
nullptr
;
}
else
{
dontResetTrusted
=
aDOMEvent
-
>
IsTrusted
(
)
;
}
if
(
!
dontResetTrusted
)
{
bool
trusted
=
NS_IsMainThread
(
)
?
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
:
IsCurrentThreadRunningChromeWorker
(
)
;
aDOMEvent
-
>
SetTrusted
(
trusted
)
;
}
return
EventDispatcher
:
:
Dispatch
(
aTarget
aPresContext
innerEvent
aDOMEvent
aEventStatus
)
;
}
else
if
(
aEvent
)
{
return
EventDispatcher
:
:
Dispatch
(
aTarget
aPresContext
aEvent
aDOMEvent
aEventStatus
)
;
}
return
NS_ERROR_ILLEGAL_VALUE
;
}
already_AddRefed
<
dom
:
:
Event
>
EventDispatcher
:
:
CreateEvent
(
EventTarget
*
aOwner
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
nsAString
&
aEventType
CallerType
aCallerType
)
{
if
(
aEvent
)
{
switch
(
aEvent
-
>
mClass
)
{
case
eMutationEventClass
:
return
NS_NewDOMMutationEvent
(
aOwner
aPresContext
aEvent
-
>
AsMutationEvent
(
)
)
;
case
eGUIEventClass
:
case
eScrollPortEventClass
:
case
eUIEventClass
:
return
NS_NewDOMUIEvent
(
aOwner
aPresContext
aEvent
-
>
AsGUIEvent
(
)
)
;
case
eScrollAreaEventClass
:
return
NS_NewDOMScrollAreaEvent
(
aOwner
aPresContext
aEvent
-
>
AsScrollAreaEvent
(
)
)
;
case
eKeyboardEventClass
:
return
NS_NewDOMKeyboardEvent
(
aOwner
aPresContext
aEvent
-
>
AsKeyboardEvent
(
)
)
;
case
eCompositionEventClass
:
return
NS_NewDOMCompositionEvent
(
aOwner
aPresContext
aEvent
-
>
AsCompositionEvent
(
)
)
;
case
eMouseEventClass
:
return
NS_NewDOMMouseEvent
(
aOwner
aPresContext
aEvent
-
>
AsMouseEvent
(
)
)
;
case
eFocusEventClass
:
return
NS_NewDOMFocusEvent
(
aOwner
aPresContext
aEvent
-
>
AsFocusEvent
(
)
)
;
case
eMouseScrollEventClass
:
return
NS_NewDOMMouseScrollEvent
(
aOwner
aPresContext
aEvent
-
>
AsMouseScrollEvent
(
)
)
;
case
eWheelEventClass
:
return
NS_NewDOMWheelEvent
(
aOwner
aPresContext
aEvent
-
>
AsWheelEvent
(
)
)
;
case
eEditorInputEventClass
:
return
NS_NewDOMInputEvent
(
aOwner
aPresContext
aEvent
-
>
AsEditorInputEvent
(
)
)
;
case
eDragEventClass
:
return
NS_NewDOMDragEvent
(
aOwner
aPresContext
aEvent
-
>
AsDragEvent
(
)
)
;
case
eClipboardEventClass
:
return
NS_NewDOMClipboardEvent
(
aOwner
aPresContext
aEvent
-
>
AsClipboardEvent
(
)
)
;
case
eSMILTimeEventClass
:
return
NS_NewDOMTimeEvent
(
aOwner
aPresContext
aEvent
-
>
AsSMILTimeEvent
(
)
)
;
case
eCommandEventClass
:
return
NS_NewDOMCommandEvent
(
aOwner
aPresContext
aEvent
-
>
AsCommandEvent
(
)
)
;
case
eSimpleGestureEventClass
:
return
NS_NewDOMSimpleGestureEvent
(
aOwner
aPresContext
aEvent
-
>
AsSimpleGestureEvent
(
)
)
;
case
ePointerEventClass
:
return
NS_NewDOMPointerEvent
(
aOwner
aPresContext
aEvent
-
>
AsPointerEvent
(
)
)
;
case
eTouchEventClass
:
return
NS_NewDOMTouchEvent
(
aOwner
aPresContext
aEvent
-
>
AsTouchEvent
(
)
)
;
case
eTransitionEventClass
:
return
NS_NewDOMTransitionEvent
(
aOwner
aPresContext
aEvent
-
>
AsTransitionEvent
(
)
)
;
case
eAnimationEventClass
:
return
NS_NewDOMAnimationEvent
(
aOwner
aPresContext
aEvent
-
>
AsAnimationEvent
(
)
)
;
default
:
return
NS_NewDOMEvent
(
aOwner
aPresContext
aEvent
)
;
}
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
mouseevent
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
mouseevents
"
)
)
{
return
NS_NewDOMMouseEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
mousescrollevents
"
)
)
{
return
NS_NewDOMMouseScrollEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
dragevent
"
)
)
{
return
NS_NewDOMDragEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
keyboardevent
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
keyevents
"
)
)
{
return
NS_NewDOMKeyboardEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
compositionevent
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
textevent
"
)
)
{
return
NS_NewDOMCompositionEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
mutationevent
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
mutationevents
"
)
)
{
return
NS_NewDOMMutationEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
deviceorientationevent
"
)
)
{
DeviceOrientationEventInit
init
;
RefPtr
<
Event
>
event
=
DeviceOrientationEvent
:
:
Constructor
(
aOwner
EmptyString
(
)
init
)
;
event
-
>
MarkUninitialized
(
)
;
return
event
.
forget
(
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
devicemotionevent
"
)
)
{
return
NS_NewDOMDeviceMotionEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
uievent
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
uievents
"
)
)
{
return
NS_NewDOMUIEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
event
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
events
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
htmlevents
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
svgevents
"
)
)
{
return
NS_NewDOMEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
timeevent
"
)
)
{
return
NS_NewDOMTimeEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
messageevent
"
)
)
{
RefPtr
<
Event
>
event
=
new
MessageEvent
(
aOwner
aPresContext
nullptr
)
;
return
event
.
forget
(
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
beforeunloadevent
"
)
)
{
return
NS_NewDOMBeforeUnloadEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
scrollareaevent
"
)
)
{
return
NS_NewDOMScrollAreaEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
touchevent
"
)
&
&
TouchEvent
:
:
PrefEnabled
(
nsContentUtils
:
:
GetDocShellForEventTarget
(
aOwner
)
)
)
{
return
NS_NewDOMTouchEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
hashchangeevent
"
)
)
{
HashChangeEventInit
init
;
RefPtr
<
Event
>
event
=
HashChangeEvent
:
:
Constructor
(
aOwner
EmptyString
(
)
init
)
;
event
-
>
MarkUninitialized
(
)
;
return
event
.
forget
(
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
customevent
"
)
)
{
return
NS_NewDOMCustomEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
storageevent
"
)
)
{
RefPtr
<
Event
>
event
=
StorageEvent
:
:
Constructor
(
aOwner
EmptyString
(
)
StorageEventInit
(
)
)
;
event
-
>
MarkUninitialized
(
)
;
return
event
.
forget
(
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
focusevent
"
)
)
{
RefPtr
<
Event
>
event
=
NS_NewDOMFocusEvent
(
aOwner
aPresContext
nullptr
)
;
event
-
>
MarkUninitialized
(
)
;
return
event
.
forget
(
)
;
}
if
(
aCallerType
=
=
CallerType
:
:
System
)
{
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
simplegestureevent
"
)
)
{
return
NS_NewDOMSimpleGestureEvent
(
aOwner
aPresContext
nullptr
)
;
}
if
(
aEventType
.
LowerCaseEqualsLiteral
(
"
xulcommandevent
"
)
|
|
aEventType
.
LowerCaseEqualsLiteral
(
"
xulcommandevents
"
)
)
{
return
NS_NewDOMXULCommandEvent
(
aOwner
aPresContext
nullptr
)
;
}
}
return
nullptr
;
}
void
EventDispatcher
:
:
GetComposedPathFor
(
WidgetEvent
*
aEvent
nsTArray
<
RefPtr
<
EventTarget
>
>
&
aPath
)
{
nsTArray
<
EventTargetChainItem
>
*
path
=
aEvent
-
>
mPath
;
if
(
!
path
|
|
path
-
>
IsEmpty
(
)
|
|
!
aEvent
-
>
mCurrentTarget
)
{
return
;
}
EventTarget
*
currentTarget
=
aEvent
-
>
mCurrentTarget
-
>
GetTargetForEventTargetChain
(
)
;
if
(
!
currentTarget
)
{
return
;
}
AutoTArray
<
EventTarget
*
128
>
reversedComposedPath
;
bool
hasSeenCurrentTarget
=
false
;
uint32_t
hiddenSubtreeLevel
=
0
;
for
(
uint32_t
i
=
path
-
>
Length
(
)
;
i
;
)
{
-
-
i
;
EventTargetChainItem
&
item
=
path
-
>
ElementAt
(
i
)
;
if
(
item
.
PreHandleEventOnly
(
)
)
{
continue
;
}
if
(
!
hasSeenCurrentTarget
&
&
currentTarget
=
=
item
.
CurrentTarget
(
)
)
{
hasSeenCurrentTarget
=
true
;
}
else
if
(
hasSeenCurrentTarget
&
&
item
.
IsRootOfClosedTree
(
)
)
{
+
+
hiddenSubtreeLevel
;
}
if
(
hiddenSubtreeLevel
=
=
0
)
{
reversedComposedPath
.
AppendElement
(
item
.
CurrentTarget
(
)
)
;
}
if
(
item
.
IsSlotInClosedTree
(
)
&
&
hiddenSubtreeLevel
>
0
)
{
-
-
hiddenSubtreeLevel
;
}
if
(
item
.
IsChromeHandler
(
)
)
{
if
(
hasSeenCurrentTarget
)
{
break
;
}
reversedComposedPath
.
Clear
(
)
;
}
}
aPath
.
SetCapacity
(
reversedComposedPath
.
Length
(
)
)
;
for
(
uint32_t
i
=
reversedComposedPath
.
Length
(
)
;
i
;
)
{
-
-
i
;
aPath
.
AppendElement
(
reversedComposedPath
[
i
]
-
>
GetTargetForDOMEvent
(
)
)
;
}
}
}
