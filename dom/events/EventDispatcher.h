#
ifdef
MOZILLA_INTERNAL_API
#
ifndef
mozilla_EventDispatcher_h_
#
define
mozilla_EventDispatcher_h_
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
undef
CreateEvent
class
nsIContent
;
class
nsPresContext
;
template
<
class
E
>
class
nsCOMArray
;
namespace
mozilla
{
namespace
dom
{
class
Event
;
class
EventTarget
;
}
class
EventChainVisitor
{
public
:
EventChainVisitor
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
dom
:
:
Event
*
aDOMEvent
nsEventStatus
aEventStatus
=
nsEventStatus_eIgnore
)
:
mPresContext
(
aPresContext
)
mEvent
(
aEvent
)
mDOMEvent
(
aDOMEvent
)
mEventStatus
(
aEventStatus
)
mItemFlags
(
0
)
{
}
nsPresContext
*
const
mPresContext
;
WidgetEvent
*
const
mEvent
;
dom
:
:
Event
*
mDOMEvent
;
nsEventStatus
mEventStatus
;
uint16_t
mItemFlags
;
nsCOMPtr
<
nsISupports
>
mItemData
;
}
;
class
EventChainPreVisitor
:
public
EventChainVisitor
{
public
:
EventChainPreVisitor
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
dom
:
:
Event
*
aDOMEvent
nsEventStatus
aEventStatus
bool
aIsInAnon
dom
:
:
EventTarget
*
aTargetInKnownToBeHandledScope
)
:
EventChainVisitor
(
aPresContext
aEvent
aDOMEvent
aEventStatus
)
mCanHandle
(
true
)
mAutomaticChromeDispatch
(
true
)
mForceContentDispatch
(
false
)
mRelatedTargetIsInAnon
(
false
)
mOriginalTargetIsInAnon
(
aIsInAnon
)
mWantsWillHandleEvent
(
false
)
mMayHaveListenerManager
(
true
)
mWantsPreHandleEvent
(
false
)
mRootOfClosedTree
(
false
)
mItemInShadowTree
(
false
)
mParentIsSlotInClosedTree
(
false
)
mParentIsChromeHandler
(
false
)
mRelatedTargetRetargetedInCurrentScope
(
false
)
mIgnoreBecauseOfShadowDOM
(
false
)
mParentTarget
(
nullptr
)
mEventTargetAtParent
(
nullptr
)
mRetargetedRelatedTarget
(
nullptr
)
mTargetInKnownToBeHandledScope
(
aTargetInKnownToBeHandledScope
)
{
}
void
Reset
(
)
{
mItemFlags
=
0
;
mItemData
=
nullptr
;
mCanHandle
=
true
;
mAutomaticChromeDispatch
=
true
;
mForceContentDispatch
=
false
;
mWantsWillHandleEvent
=
false
;
mMayHaveListenerManager
=
true
;
mWantsPreHandleEvent
=
false
;
mRootOfClosedTree
=
false
;
mItemInShadowTree
=
false
;
mParentIsSlotInClosedTree
=
false
;
mParentIsChromeHandler
=
false
;
mIgnoreBecauseOfShadowDOM
=
false
;
mParentTarget
=
nullptr
;
mEventTargetAtParent
=
nullptr
;
mRetargetedRelatedTarget
=
nullptr
;
mRetargetedTouchTargets
.
reset
(
)
;
}
dom
:
:
EventTarget
*
GetParentTarget
(
)
{
return
mParentTarget
;
}
void
SetParentTarget
(
dom
:
:
EventTarget
*
aParentTarget
bool
aIsChromeHandler
)
{
mParentTarget
=
aParentTarget
;
if
(
mParentTarget
)
{
mParentIsChromeHandler
=
aIsChromeHandler
;
}
}
void
IgnoreCurrentTargetBecauseOfShadowDOMRetargeting
(
)
{
mCanHandle
=
false
;
mIgnoreBecauseOfShadowDOM
=
true
;
SetParentTarget
(
nullptr
false
)
;
mEventTargetAtParent
=
nullptr
;
}
bool
mCanHandle
;
bool
mAutomaticChromeDispatch
;
bool
mForceContentDispatch
;
bool
mRelatedTargetIsInAnon
;
bool
mOriginalTargetIsInAnon
;
bool
mWantsWillHandleEvent
;
bool
mMayHaveListenerManager
;
bool
mWantsPreHandleEvent
;
bool
mRootOfClosedTree
;
bool
mItemInShadowTree
;
bool
mParentIsSlotInClosedTree
;
bool
mParentIsChromeHandler
;
bool
mRelatedTargetRetargetedInCurrentScope
;
bool
mIgnoreBecauseOfShadowDOM
;
private
:
dom
:
:
EventTarget
*
mParentTarget
;
public
:
dom
:
:
EventTarget
*
mEventTargetAtParent
;
dom
:
:
EventTarget
*
mRetargetedRelatedTarget
;
mozilla
:
:
Maybe
<
nsTArray
<
RefPtr
<
dom
:
:
EventTarget
>
>
>
mRetargetedTouchTargets
;
dom
:
:
EventTarget
*
mTargetInKnownToBeHandledScope
;
}
;
class
EventChainPostVisitor
:
public
mozilla
:
:
EventChainVisitor
{
public
:
explicit
EventChainPostVisitor
(
EventChainVisitor
&
aOther
)
:
EventChainVisitor
(
aOther
.
mPresContext
aOther
.
mEvent
aOther
.
mDOMEvent
aOther
.
mEventStatus
)
{
}
}
;
class
MOZ_STACK_CLASS
EventDispatchingCallback
{
public
:
virtual
void
HandleEvent
(
EventChainPostVisitor
&
aVisitor
)
=
0
;
}
;
class
EventDispatcher
{
public
:
static
nsresult
Dispatch
(
nsISupports
*
aTarget
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
dom
:
:
Event
*
aDOMEvent
=
nullptr
nsEventStatus
*
aEventStatus
=
nullptr
EventDispatchingCallback
*
aCallback
=
nullptr
nsTArray
<
dom
:
:
EventTarget
*
>
*
aTargets
=
nullptr
)
;
static
nsresult
DispatchDOMEvent
(
nsISupports
*
aTarget
WidgetEvent
*
aEvent
dom
:
:
Event
*
aDOMEvent
nsPresContext
*
aPresContext
nsEventStatus
*
aEventStatus
)
;
static
already_AddRefed
<
dom
:
:
Event
>
CreateEvent
(
dom
:
:
EventTarget
*
aOwner
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
nsAString
&
aEventType
dom
:
:
CallerType
aCallerType
=
dom
:
:
CallerType
:
:
System
)
;
static
void
GetComposedPathFor
(
WidgetEvent
*
aEvent
nsTArray
<
RefPtr
<
dom
:
:
EventTarget
>
>
&
aPath
)
;
static
void
Shutdown
(
)
;
}
;
}
#
endif
#
endif
