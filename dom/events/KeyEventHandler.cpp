#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
KeyEventHandler
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsGlobalWindowCommands
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
JSEventHandler
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventHandlerBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
layers
/
KeyboardMap
.
h
"
#
include
"
xpcpublic
.
h
"
namespace
mozilla
{
using
namespace
mozilla
:
:
layers
;
uint32_t
KeyEventHandler
:
:
gRefCnt
=
0
;
int32_t
KeyEventHandler
:
:
kMenuAccessKey
=
-
1
;
const
int32_t
KeyEventHandler
:
:
cShift
=
(
1
<
<
0
)
;
const
int32_t
KeyEventHandler
:
:
cAlt
=
(
1
<
<
1
)
;
const
int32_t
KeyEventHandler
:
:
cControl
=
(
1
<
<
2
)
;
const
int32_t
KeyEventHandler
:
:
cMeta
=
(
1
<
<
3
)
;
const
int32_t
KeyEventHandler
:
:
cOS
=
(
1
<
<
4
)
;
const
int32_t
KeyEventHandler
:
:
cShiftMask
=
(
1
<
<
5
)
;
const
int32_t
KeyEventHandler
:
:
cAltMask
=
(
1
<
<
6
)
;
const
int32_t
KeyEventHandler
:
:
cControlMask
=
(
1
<
<
7
)
;
const
int32_t
KeyEventHandler
:
:
cMetaMask
=
(
1
<
<
8
)
;
const
int32_t
KeyEventHandler
:
:
cOSMask
=
(
1
<
<
9
)
;
const
int32_t
KeyEventHandler
:
:
cAllModifiers
=
cShiftMask
|
cAltMask
|
cControlMask
|
cMetaMask
|
cOSMask
;
KeyEventHandler
:
:
KeyEventHandler
(
Element
*
aHandlerElement
ReservedKey
aReserved
)
:
mHandlerElement
(
nullptr
)
mIsXULKey
(
true
)
mReserved
(
aReserved
)
mNextHandler
(
nullptr
)
{
Init
(
)
;
ConstructPrototype
(
aHandlerElement
)
;
}
KeyEventHandler
:
:
KeyEventHandler
(
ShortcutKeyData
*
aKeyData
)
:
mCommand
(
nullptr
)
mIsXULKey
(
false
)
mReserved
(
ReservedKey_False
)
mNextHandler
(
nullptr
)
{
Init
(
)
;
ConstructPrototype
(
nullptr
aKeyData
-
>
event
aKeyData
-
>
command
aKeyData
-
>
keycode
aKeyData
-
>
key
aKeyData
-
>
modifiers
)
;
}
KeyEventHandler
:
:
~
KeyEventHandler
(
)
{
-
-
gRefCnt
;
if
(
mIsXULKey
)
{
NS_IF_RELEASE
(
mHandlerElement
)
;
}
else
if
(
mCommand
)
{
free
(
mCommand
)
;
}
NS_CONTENT_DELETE_LIST_MEMBER
(
KeyEventHandler
this
mNextHandler
)
;
}
bool
KeyEventHandler
:
:
TryConvertToKeyboardShortcut
(
KeyboardShortcut
*
aOut
)
const
{
KeyboardInput
:
:
KeyboardEventType
eventType
;
if
(
mEventName
=
=
nsGkAtoms
:
:
keydown
)
{
eventType
=
KeyboardInput
:
:
KEY_DOWN
;
}
else
if
(
mEventName
=
=
nsGkAtoms
:
:
keypress
)
{
eventType
=
KeyboardInput
:
:
KEY_PRESS
;
}
else
if
(
mEventName
=
=
nsGkAtoms
:
:
keyup
)
{
eventType
=
KeyboardInput
:
:
KEY_UP
;
}
else
{
return
false
;
}
Modifiers
modifiersMask
=
GetModifiersMask
(
)
;
Modifiers
modifiers
=
GetModifiers
(
)
;
modifiers
&
=
modifiersMask
;
uint32_t
keyCode
;
uint32_t
charCode
;
if
(
mMisc
)
{
keyCode
=
0
;
charCode
=
static_cast
<
uint32_t
>
(
mDetail
)
;
}
else
{
keyCode
=
static_cast
<
uint32_t
>
(
mDetail
)
;
charCode
=
0
;
}
NS_LossyConvertUTF16toASCII
commandText
(
mCommand
)
;
KeyboardScrollAction
action
;
if
(
!
nsGlobalWindowCommands
:
:
FindScrollCommand
(
commandText
.
get
(
)
&
action
)
)
{
*
aOut
=
KeyboardShortcut
(
eventType
keyCode
charCode
modifiers
modifiersMask
)
;
return
true
;
}
*
aOut
=
KeyboardShortcut
(
eventType
keyCode
charCode
modifiers
modifiersMask
action
)
;
return
true
;
}
already_AddRefed
<
Element
>
KeyEventHandler
:
:
GetHandlerElement
(
)
{
if
(
mIsXULKey
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryReferent
(
mHandlerElement
)
;
return
element
.
forget
(
)
;
}
return
nullptr
;
}
void
KeyEventHandler
:
:
InitAccessKeys
(
)
{
if
(
kMenuAccessKey
>
=
0
)
{
return
;
}
#
ifdef
XP_MACOSX
kMenuAccessKey
=
0
;
#
else
kMenuAccessKey
=
KeyboardEvent_Binding
:
:
DOM_VK_ALT
;
#
endif
kMenuAccessKey
=
Preferences
:
:
GetInt
(
"
ui
.
key
.
menuAccessKey
"
kMenuAccessKey
)
;
}
nsresult
KeyEventHandler
:
:
ExecuteHandler
(
EventTarget
*
aTarget
Event
*
aEvent
)
{
if
(
!
mHandlerElement
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
aEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
if
(
mIsXULKey
)
{
return
DispatchXULKeyCommand
(
aEvent
)
;
}
return
DispatchXBLCommand
(
aTarget
aEvent
)
;
}
nsresult
KeyEventHandler
:
:
DispatchXBLCommand
(
EventTarget
*
aTarget
Event
*
aEvent
)
{
if
(
aEvent
)
{
if
(
aEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
bool
dispatchStopped
=
aEvent
-
>
IsDispatchStopped
(
)
;
if
(
dispatchStopped
)
{
return
NS_OK
;
}
}
nsCOMPtr
<
nsIController
>
controller
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
privateWindow
;
nsCOMPtr
<
nsPIWindowRoot
>
windowRoot
=
do_QueryInterface
(
aTarget
)
;
if
(
windowRoot
)
{
privateWindow
=
windowRoot
-
>
GetWindow
(
)
;
}
else
{
privateWindow
=
do_QueryInterface
(
aTarget
)
;
if
(
!
privateWindow
)
{
nsCOMPtr
<
nsIContent
>
elt
(
do_QueryInterface
(
aTarget
)
)
;
nsCOMPtr
<
Document
>
doc
;
if
(
elt
)
{
doc
=
elt
-
>
OwnerDoc
(
)
;
}
if
(
!
doc
)
{
doc
=
do_QueryInterface
(
aTarget
)
;
}
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
privateWindow
=
doc
-
>
GetWindow
(
)
;
if
(
!
privateWindow
)
{
return
NS_ERROR_FAILURE
;
}
}
windowRoot
=
privateWindow
-
>
GetTopWindowRoot
(
)
;
}
NS_LossyConvertUTF16toASCII
command
(
mCommand
)
;
if
(
windowRoot
)
{
windowRoot
-
>
GetControllerForCommand
(
command
.
get
(
)
true
getter_AddRefs
(
controller
)
)
;
}
else
{
controller
=
GetController
(
aTarget
)
;
}
aEvent
-
>
PreventDefault
(
)
;
if
(
mEventName
=
=
nsGkAtoms
:
:
keypress
&
&
mDetail
=
=
KeyboardEvent_Binding
:
:
DOM_VK_SPACE
&
&
mMisc
=
=
1
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
windowToCheck
;
if
(
windowRoot
)
{
windowToCheck
=
windowRoot
-
>
GetWindow
(
)
;
}
else
{
windowToCheck
=
privateWindow
-
>
GetPrivateRoot
(
)
;
}
nsCOMPtr
<
nsIContent
>
focusedContent
;
if
(
windowToCheck
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
windowToCheck
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
}
if
(
focusedContent
&
&
focusedContent
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
for
(
nsIContent
*
c
=
focusedContent
;
c
;
c
=
c
-
>
GetParent
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
c
)
;
if
(
formControl
)
{
return
NS_OK
;
}
}
}
if
(
controller
)
{
controller
-
>
DoCommand
(
command
.
get
(
)
)
;
}
return
NS_OK
;
}
nsresult
KeyEventHandler
:
:
DispatchXULKeyCommand
(
Event
*
aEvent
)
{
nsCOMPtr
<
Element
>
handlerElement
=
GetHandlerElement
(
)
;
NS_ENSURE_STATE
(
handlerElement
)
;
if
(
handlerElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
NS_OK
;
}
aEvent
-
>
PreventDefault
(
)
;
RefPtr
<
KeyboardEvent
>
domKeyboardEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
!
domKeyboardEvent
)
{
NS_ERROR
(
"
Trying
to
execute
a
key
handler
for
a
non
-
key
event
!
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
isAlt
=
domKeyboardEvent
-
>
AltKey
(
)
;
bool
isControl
=
domKeyboardEvent
-
>
CtrlKey
(
)
;
bool
isShift
=
domKeyboardEvent
-
>
ShiftKey
(
)
;
bool
isMeta
=
domKeyboardEvent
-
>
MetaKey
(
)
;
nsContentUtils
:
:
DispatchXULCommand
(
handlerElement
true
nullptr
nullptr
isControl
isAlt
isShift
isMeta
)
;
return
NS_OK
;
}
Modifiers
KeyEventHandler
:
:
GetModifiers
(
)
const
{
Modifiers
modifiers
=
0
;
if
(
mKeyMask
&
cMeta
)
{
modifiers
|
=
MODIFIER_META
;
}
if
(
mKeyMask
&
cOS
)
{
modifiers
|
=
MODIFIER_OS
;
}
if
(
mKeyMask
&
cShift
)
{
modifiers
|
=
MODIFIER_SHIFT
;
}
if
(
mKeyMask
&
cAlt
)
{
modifiers
|
=
MODIFIER_ALT
;
}
if
(
mKeyMask
&
cControl
)
{
modifiers
|
=
MODIFIER_CONTROL
;
}
return
modifiers
;
}
Modifiers
KeyEventHandler
:
:
GetModifiersMask
(
)
const
{
Modifiers
modifiersMask
=
0
;
if
(
mKeyMask
&
cMetaMask
)
{
modifiersMask
|
=
MODIFIER_META
;
}
if
(
mKeyMask
&
cOSMask
)
{
modifiersMask
|
=
MODIFIER_OS
;
}
if
(
mKeyMask
&
cShiftMask
)
{
modifiersMask
|
=
MODIFIER_SHIFT
;
}
if
(
mKeyMask
&
cAltMask
)
{
modifiersMask
|
=
MODIFIER_ALT
;
}
if
(
mKeyMask
&
cControlMask
)
{
modifiersMask
|
=
MODIFIER_CONTROL
;
}
return
modifiersMask
;
}
already_AddRefed
<
nsIController
>
KeyEventHandler
:
:
GetController
(
EventTarget
*
aTarget
)
{
nsCOMPtr
<
nsIControllers
>
controllers
;
nsCOMPtr
<
nsIContent
>
targetContent
(
do_QueryInterface
(
aTarget
)
)
;
RefPtr
<
nsXULElement
>
xulElement
=
nsXULElement
:
:
FromNodeOrNull
(
targetContent
)
;
if
(
xulElement
)
{
controllers
=
xulElement
-
>
GetControllers
(
IgnoreErrors
(
)
)
;
}
if
(
!
controllers
)
{
HTMLTextAreaElement
*
htmlTextArea
=
HTMLTextAreaElement
:
:
FromNode
(
targetContent
)
;
if
(
htmlTextArea
)
{
htmlTextArea
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
if
(
!
controllers
)
{
HTMLInputElement
*
htmlInputElement
=
HTMLInputElement
:
:
FromNode
(
targetContent
)
;
if
(
htmlInputElement
)
{
htmlInputElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
if
(
!
controllers
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
(
do_QueryInterface
(
aTarget
)
)
;
if
(
domWindow
)
{
domWindow
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
nsCOMPtr
<
nsIController
>
controller
;
if
(
controllers
)
{
controllers
-
>
GetControllerAt
(
0
getter_AddRefs
(
controller
)
)
;
}
return
controller
.
forget
(
)
;
}
bool
KeyEventHandler
:
:
KeyEventMatched
(
KeyboardEvent
*
aDomKeyboardEvent
uint32_t
aCharCode
const
IgnoreModifierState
&
aIgnoreModifierState
)
{
if
(
mDetail
!
=
-
1
)
{
uint32_t
code
;
if
(
mMisc
)
{
if
(
aCharCode
)
{
code
=
aCharCode
;
}
else
{
code
=
aDomKeyboardEvent
-
>
CharCode
(
)
;
}
if
(
IS_IN_BMP
(
code
)
)
{
code
=
ToLowerCase
(
char16_t
(
code
)
)
;
}
}
else
{
code
=
aDomKeyboardEvent
-
>
KeyCode
(
)
;
}
if
(
code
!
=
static_cast
<
uint32_t
>
(
mDetail
)
)
{
return
false
;
}
}
return
ModifiersMatchMask
(
aDomKeyboardEvent
aIgnoreModifierState
)
;
}
struct
keyCodeData
{
const
char
*
str
;
uint16_t
strlength
;
uint16_t
keycode
;
}
;
static
const
keyCodeData
gKeyCodes
[
]
=
{
#
define
NS_DEFINE_VK
(
aDOMKeyName
aDOMKeyCode
)
\
{
#
aDOMKeyName
sizeof
(
#
aDOMKeyName
)
-
1
aDOMKeyCode
}
#
include
"
mozilla
/
VirtualKeyCodeList
.
h
"
#
undef
NS_DEFINE_VK
{
nullptr
0
0
}
}
;
int32_t
KeyEventHandler
:
:
GetMatchingKeyCode
(
const
nsAString
&
aKeyName
)
{
nsAutoCString
keyName
;
LossyCopyUTF16toASCII
(
aKeyName
keyName
)
;
ToUpperCase
(
keyName
)
;
uint32_t
keyNameLength
=
keyName
.
Length
(
)
;
const
char
*
keyNameStr
=
keyName
.
get
(
)
;
for
(
unsigned
long
i
=
0
;
i
<
ArrayLength
(
gKeyCodes
)
-
1
;
+
+
i
)
{
if
(
keyNameLength
=
=
gKeyCodes
[
i
]
.
strlength
&
&
!
nsCRT
:
:
strcmp
(
gKeyCodes
[
i
]
.
str
keyNameStr
)
)
{
return
gKeyCodes
[
i
]
.
keycode
;
}
}
return
0
;
}
int32_t
KeyEventHandler
:
:
KeyToMask
(
int32_t
key
)
{
switch
(
key
)
{
case
KeyboardEvent_Binding
:
:
DOM_VK_META
:
return
cMeta
|
cMetaMask
;
case
KeyboardEvent_Binding
:
:
DOM_VK_WIN
:
return
cOS
|
cOSMask
;
case
KeyboardEvent_Binding
:
:
DOM_VK_ALT
:
return
cAlt
|
cAltMask
;
case
KeyboardEvent_Binding
:
:
DOM_VK_CONTROL
:
default
:
return
cControl
|
cControlMask
;
}
return
cControl
|
cControlMask
;
}
int32_t
KeyEventHandler
:
:
AccelKeyMask
(
)
{
switch
(
WidgetInputEvent
:
:
AccelModifier
(
)
)
{
case
MODIFIER_ALT
:
return
KeyToMask
(
KeyboardEvent_Binding
:
:
DOM_VK_ALT
)
;
case
MODIFIER_CONTROL
:
return
KeyToMask
(
KeyboardEvent_Binding
:
:
DOM_VK_CONTROL
)
;
case
MODIFIER_META
:
return
KeyToMask
(
KeyboardEvent_Binding
:
:
DOM_VK_META
)
;
case
MODIFIER_OS
:
return
KeyToMask
(
KeyboardEvent_Binding
:
:
DOM_VK_WIN
)
;
default
:
MOZ_CRASH
(
"
Handle
the
new
result
of
WidgetInputEvent
:
:
AccelModifier
(
)
"
)
;
return
0
;
}
}
void
KeyEventHandler
:
:
GetEventType
(
nsAString
&
aEvent
)
{
nsCOMPtr
<
Element
>
handlerElement
=
GetHandlerElement
(
)
;
if
(
!
handlerElement
)
{
aEvent
.
Truncate
(
)
;
return
;
}
handlerElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
event
aEvent
)
;
if
(
aEvent
.
IsEmpty
(
)
&
&
mIsXULKey
)
{
aEvent
.
AssignLiteral
(
"
keypress
"
)
;
}
}
void
KeyEventHandler
:
:
ConstructPrototype
(
Element
*
aKeyElement
const
char16_t
*
aEvent
const
char16_t
*
aCommand
const
char16_t
*
aKeyCode
const
char16_t
*
aCharCode
const
char16_t
*
aModifiers
)
{
mDetail
=
-
1
;
mMisc
=
0
;
mKeyMask
=
0
;
nsAutoString
modifiers
;
if
(
mIsXULKey
)
{
nsWeakPtr
weak
=
do_GetWeakReference
(
aKeyElement
)
;
if
(
!
weak
)
{
return
;
}
weak
.
swap
(
mHandlerElement
)
;
nsAutoString
event
;
GetEventType
(
event
)
;
if
(
event
.
IsEmpty
(
)
)
{
return
;
}
mEventName
=
NS_Atomize
(
event
)
;
aKeyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
modifiers
modifiers
)
;
}
else
{
mCommand
=
ToNewUnicode
(
nsDependentString
(
aCommand
)
)
;
mEventName
=
NS_Atomize
(
aEvent
)
;
modifiers
=
aModifiers
;
}
BuildModifiers
(
modifiers
)
;
nsAutoString
key
(
aCharCode
)
;
if
(
key
.
IsEmpty
(
)
)
{
if
(
mIsXULKey
)
{
aKeyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
key
)
;
if
(
key
.
IsEmpty
(
)
)
{
aKeyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
charcode
key
)
;
}
}
}
if
(
!
key
.
IsEmpty
(
)
)
{
if
(
mKeyMask
=
=
0
)
{
mKeyMask
=
cAllModifiers
;
}
ToLowerCase
(
key
)
;
mMisc
=
1
;
mDetail
=
key
[
0
]
;
const
uint8_t
GTK2Modifiers
=
cShift
|
cControl
|
cShiftMask
|
cControlMask
;
if
(
mIsXULKey
&
&
(
mKeyMask
&
GTK2Modifiers
)
=
=
GTK2Modifiers
&
&
modifiers
.
First
(
)
!
=
char16_t
(
'
'
)
&
&
(
mDetail
=
=
'
u
'
|
|
mDetail
=
=
'
U
'
)
)
{
ReportKeyConflict
(
key
.
get
(
)
modifiers
.
get
(
)
aKeyElement
"
GTK2Conflict2
"
)
;
}
const
uint8_t
WinModifiers
=
cControl
|
cAlt
|
cControlMask
|
cAltMask
;
if
(
mIsXULKey
&
&
(
mKeyMask
&
WinModifiers
)
=
=
WinModifiers
&
&
modifiers
.
First
(
)
!
=
char16_t
(
'
'
)
&
&
(
(
'
A
'
<
=
mDetail
&
&
mDetail
<
=
'
Z
'
)
|
|
(
'
a
'
<
=
mDetail
&
&
mDetail
<
=
'
z
'
)
)
)
{
ReportKeyConflict
(
key
.
get
(
)
modifiers
.
get
(
)
aKeyElement
"
WinConflict2
"
)
;
}
}
else
{
key
.
Assign
(
aKeyCode
)
;
if
(
mIsXULKey
)
{
aKeyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
keycode
key
)
;
}
if
(
!
key
.
IsEmpty
(
)
)
{
if
(
mKeyMask
=
=
0
)
{
mKeyMask
=
cAllModifiers
;
}
mDetail
=
GetMatchingKeyCode
(
key
)
;
}
}
}
void
KeyEventHandler
:
:
BuildModifiers
(
nsAString
&
aModifiers
)
{
if
(
!
aModifiers
.
IsEmpty
(
)
)
{
mKeyMask
=
cAllModifiers
;
char
*
str
=
ToNewCString
(
aModifiers
)
;
char
*
newStr
;
char
*
token
=
nsCRT
:
:
strtok
(
str
"
\
t
"
&
newStr
)
;
while
(
token
!
=
nullptr
)
{
if
(
PL_strcmp
(
token
"
shift
"
)
=
=
0
)
{
mKeyMask
|
=
cShift
|
cShiftMask
;
}
else
if
(
PL_strcmp
(
token
"
alt
"
)
=
=
0
)
{
mKeyMask
|
=
cAlt
|
cAltMask
;
}
else
if
(
PL_strcmp
(
token
"
meta
"
)
=
=
0
)
{
mKeyMask
|
=
cMeta
|
cMetaMask
;
}
else
if
(
PL_strcmp
(
token
"
os
"
)
=
=
0
)
{
mKeyMask
|
=
cOS
|
cOSMask
;
}
else
if
(
PL_strcmp
(
token
"
control
"
)
=
=
0
)
{
mKeyMask
|
=
cControl
|
cControlMask
;
}
else
if
(
PL_strcmp
(
token
"
accel
"
)
=
=
0
)
{
mKeyMask
|
=
AccelKeyMask
(
)
;
}
else
if
(
PL_strcmp
(
token
"
access
"
)
=
=
0
)
{
mKeyMask
|
=
KeyToMask
(
kMenuAccessKey
)
;
}
else
if
(
PL_strcmp
(
token
"
any
"
)
=
=
0
)
{
mKeyMask
&
=
~
(
mKeyMask
<
<
5
)
;
}
token
=
nsCRT
:
:
strtok
(
newStr
"
\
t
"
&
newStr
)
;
}
free
(
str
)
;
}
}
void
KeyEventHandler
:
:
ReportKeyConflict
(
const
char16_t
*
aKey
const
char16_t
*
aModifiers
Element
*
aKeyElement
const
char
*
aMessageName
)
{
nsCOMPtr
<
Document
>
doc
=
aKeyElement
-
>
OwnerDoc
(
)
;
nsAutoString
id
;
aKeyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
AutoTArray
<
nsString
3
>
params
;
params
.
AppendElement
(
aKey
)
;
params
.
AppendElement
(
aModifiers
)
;
params
.
AppendElement
(
id
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Key
Event
Handler
"
)
doc
nsContentUtils
:
:
eDOM_PROPERTIES
aMessageName
params
nullptr
EmptyString
(
)
0
)
;
}
bool
KeyEventHandler
:
:
ModifiersMatchMask
(
UIEvent
*
aEvent
const
IgnoreModifierState
&
aIgnoreModifierState
)
{
WidgetInputEvent
*
inputEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsInputEvent
(
)
;
NS_ENSURE_TRUE
(
inputEvent
false
)
;
if
(
mKeyMask
&
cMetaMask
)
{
if
(
inputEvent
-
>
IsMeta
(
)
!
=
(
(
mKeyMask
&
cMeta
)
!
=
0
)
)
{
return
false
;
}
}
if
(
(
mKeyMask
&
cOSMask
)
&
&
!
aIgnoreModifierState
.
mOS
)
{
if
(
inputEvent
-
>
IsOS
(
)
!
=
(
(
mKeyMask
&
cOS
)
!
=
0
)
)
{
return
false
;
}
}
if
(
mKeyMask
&
cShiftMask
&
&
!
aIgnoreModifierState
.
mShift
)
{
if
(
inputEvent
-
>
IsShift
(
)
!
=
(
(
mKeyMask
&
cShift
)
!
=
0
)
)
{
return
false
;
}
}
if
(
mKeyMask
&
cAltMask
)
{
if
(
inputEvent
-
>
IsAlt
(
)
!
=
(
(
mKeyMask
&
cAlt
)
!
=
0
)
)
{
return
false
;
}
}
if
(
mKeyMask
&
cControlMask
)
{
if
(
inputEvent
-
>
IsControl
(
)
!
=
(
(
mKeyMask
&
cControl
)
!
=
0
)
)
{
return
false
;
}
}
return
true
;
}
size_t
KeyEventHandler
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
for
(
const
KeyEventHandler
*
handler
=
this
;
handler
;
handler
=
handler
-
>
mNextHandler
)
{
n
+
=
aMallocSizeOf
(
handler
)
;
if
(
!
mIsXULKey
)
{
n
+
=
aMallocSizeOf
(
handler
-
>
mCommand
)
;
}
}
return
n
;
}
}
