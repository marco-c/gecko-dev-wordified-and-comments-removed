#
undef
CreateEvent
#
include
"
mozilla
/
AddonPathService
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
ifdef
MOZ_B2G
#
include
"
mozilla
/
Hal
.
h
"
#
endif
#
include
"
mozilla
/
HalSensor
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
JSEventHandler
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
EventTimelineMarker
.
h
"
#
include
"
EventListenerService
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHtml5Atoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIFrame
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
hal
;
#
define
EVENT_TYPE_EQUALS
(
ls
message
userType
typeString
allEvents
)
\
(
(
ls
-
>
mEventMessage
=
=
message
&
&
\
(
ls
-
>
mEventMessage
!
=
eUnidentifiedEvent
|
|
\
(
mIsMainThreadELM
&
&
ls
-
>
mTypeAtom
=
=
userType
)
|
|
\
(
!
mIsMainThreadELM
&
&
ls
-
>
mTypeString
.
Equals
(
typeString
)
)
)
)
|
|
\
(
allEvents
&
&
ls
-
>
mAllEvents
)
)
static
const
uint32_t
kAllMutationBits
=
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEINSERTED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_NODEINSERTEDINTODOCUMENT
|
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
|
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
;
static
uint32_t
MutationBitForEventType
(
EventMessage
aEventType
)
{
switch
(
aEventType
)
{
case
eLegacySubtreeModified
:
return
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
;
case
eLegacyNodeInserted
:
return
NS_EVENT_BITS_MUTATION_NODEINSERTED
;
case
eLegacyNodeRemoved
:
return
NS_EVENT_BITS_MUTATION_NODEREMOVED
;
case
eLegacyNodeRemovedFromDocument
:
return
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
;
case
eLegacyNodeInsertedIntoDocument
:
return
NS_EVENT_BITS_MUTATION_NODEINSERTEDINTODOCUMENT
;
case
eLegacyAttrModified
:
return
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
;
case
eLegacyCharacterDataModified
:
return
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
;
default
:
break
;
}
return
0
;
}
uint32_t
EventListenerManager
:
:
sMainThreadCreatedCount
=
0
;
static
bool
IsWebkitPrefixSupportEnabled
(
)
{
static
bool
sIsWebkitPrefixSupportEnabled
;
static
bool
sIsPrefCached
=
false
;
if
(
!
sIsPrefCached
)
{
sIsPrefCached
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sIsWebkitPrefixSupportEnabled
"
layout
.
css
.
prefixes
.
webkit
"
)
;
}
return
sIsWebkitPrefixSupportEnabled
;
}
EventListenerManagerBase
:
:
EventListenerManagerBase
(
)
:
mNoListenerForEvent
(
eVoidEvent
)
mMayHavePaintEventListener
(
false
)
mMayHaveMutationListeners
(
false
)
mMayHaveCapturingListeners
(
false
)
mMayHaveSystemGroupListeners
(
false
)
mMayHaveTouchEventListener
(
false
)
mMayHaveMouseEnterLeaveEventListener
(
false
)
mMayHavePointerEnterLeaveEventListener
(
false
)
mMayHaveKeyEventListener
(
false
)
mMayHaveInputOrCompositionEventListener
(
false
)
mClearingListeners
(
false
)
mIsMainThreadELM
(
NS_IsMainThread
(
)
)
{
static_assert
(
sizeof
(
EventListenerManagerBase
)
=
=
sizeof
(
uint32_t
)
"
Keep
the
size
of
EventListenerManagerBase
size
compact
!
"
)
;
}
EventListenerManager
:
:
EventListenerManager
(
EventTarget
*
aTarget
)
:
EventListenerManagerBase
(
)
mTarget
(
aTarget
)
{
NS_ASSERTION
(
aTarget
"
unexpected
null
pointer
"
)
;
if
(
mIsMainThreadELM
)
{
+
+
sMainThreadCreatedCount
;
}
}
EventListenerManager
:
:
~
EventListenerManager
(
)
{
NS_ASSERTION
(
!
mTarget
"
didn
'
t
call
Disconnect
"
)
;
RemoveAllListeners
(
)
;
}
void
EventListenerManager
:
:
RemoveAllListeners
(
)
{
if
(
mClearingListeners
)
{
return
;
}
mClearingListeners
=
true
;
mListeners
.
Clear
(
)
;
mClearingListeners
=
false
;
}
void
EventListenerManager
:
:
Shutdown
(
)
{
Event
:
:
Shutdown
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
EventListenerManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
EventListenerManager
Release
)
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EventListenerManager
:
:
Listener
&
aField
const
char
*
aName
unsigned
aFlags
)
{
if
(
MOZ_UNLIKELY
(
aCallback
.
WantDebugInfo
(
)
)
)
{
nsAutoCString
name
;
name
.
AppendASCII
(
aName
)
;
if
(
aField
.
mTypeAtom
)
{
name
.
AppendASCII
(
"
event
=
"
)
;
name
.
Append
(
nsAtomCString
(
aField
.
mTypeAtom
)
)
;
name
.
AppendASCII
(
"
listenerType
=
"
)
;
name
.
AppendInt
(
aField
.
mListenerType
)
;
name
.
AppendASCII
(
"
"
)
;
}
CycleCollectionNoteChild
(
aCallback
aField
.
mListener
.
GetISupports
(
)
name
.
get
(
)
aFlags
)
;
}
else
{
CycleCollectionNoteChild
(
aCallback
aField
.
mListener
.
GetISupports
(
)
aName
aFlags
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
EventListenerManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
EventListenerManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListeners
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
EventListenerManager
)
tmp
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
nsPIDOMWindowInner
*
EventListenerManager
:
:
GetInnerWindowForTarget
(
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
mTarget
)
;
if
(
node
)
{
return
node
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
;
return
window
;
}
already_AddRefed
<
nsPIDOMWindowInner
>
EventListenerManager
:
:
GetTargetAsInnerWindow
(
)
const
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mTarget
)
;
return
window
.
forget
(
)
;
}
void
EventListenerManager
:
:
AddEventListenerInternal
(
const
EventListenerHolder
&
aListenerHolder
EventMessage
aEventMessage
nsIAtom
*
aTypeAtom
const
nsAString
&
aTypeString
const
EventListenerFlags
&
aFlags
bool
aHandler
bool
aAllEvents
)
{
MOZ_ASSERT
(
(
NS_IsMainThread
(
)
&
&
aEventMessage
&
&
aTypeAtom
)
|
|
(
!
NS_IsMainThread
(
)
&
&
aEventMessage
)
|
|
aAllEvents
"
Missing
type
"
)
;
if
(
!
aListenerHolder
|
|
mClearingListeners
)
{
return
;
}
Listener
*
listener
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mListenerIsHandler
=
=
aHandler
&
&
listener
-
>
mFlags
=
=
aFlags
&
&
EVENT_TYPE_EQUALS
(
listener
aEventMessage
aTypeAtom
aTypeString
aAllEvents
)
&
&
listener
-
>
mListener
=
=
aListenerHolder
)
{
return
;
}
}
mNoListenerForEvent
=
eVoidEvent
;
mNoListenerForEventAtom
=
nullptr
;
listener
=
aAllEvents
?
mListeners
.
InsertElementAt
(
0
)
:
mListeners
.
AppendElement
(
)
;
listener
-
>
mListener
=
aListenerHolder
;
listener
-
>
mEventMessage
=
aEventMessage
;
listener
-
>
mTypeString
=
aTypeString
;
listener
-
>
mTypeAtom
=
aTypeAtom
;
listener
-
>
mFlags
=
aFlags
;
listener
-
>
mListenerIsHandler
=
aHandler
;
listener
-
>
mHandlerIsString
=
false
;
listener
-
>
mAllEvents
=
aAllEvents
;
nsCOMPtr
<
nsIXPConnectWrappedJS
>
wjs
;
if
(
aFlags
.
mListenerIsJSListener
)
{
MOZ_ASSERT
(
!
aListenerHolder
.
HasWebIDLCallback
(
)
)
;
listener
-
>
mListenerType
=
Listener
:
:
eJSEventListener
;
}
else
if
(
aListenerHolder
.
HasWebIDLCallback
(
)
)
{
listener
-
>
mListenerType
=
Listener
:
:
eWebIDLListener
;
}
else
if
(
(
wjs
=
do_QueryInterface
(
aListenerHolder
.
GetXPCOMCallback
(
)
)
)
)
{
listener
-
>
mListenerType
=
Listener
:
:
eWrappedJSListener
;
}
else
{
listener
-
>
mListenerType
=
Listener
:
:
eNativeListener
;
}
if
(
aFlags
.
mInSystemGroup
)
{
mMayHaveSystemGroupListeners
=
true
;
}
if
(
aFlags
.
mCapture
)
{
mMayHaveCapturingListeners
=
true
;
}
if
(
aEventMessage
=
=
eAfterPaint
)
{
mMayHavePaintEventListener
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
window
-
>
SetHasPaintEventListeners
(
)
;
}
}
else
if
(
aEventMessage
>
=
eLegacyMutationEventFirst
&
&
aEventMessage
<
=
eLegacyMutationEventLast
)
{
mMayHaveMutationListeners
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eMutationEvent
)
;
}
window
-
>
SetMutationListeners
(
(
aEventMessage
=
=
eLegacySubtreeModified
)
?
kAllMutationBits
:
MutationBitForEventType
(
aEventMessage
)
)
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondeviceorientation
)
{
EnableDevice
(
eDeviceOrientation
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onabsolutedeviceorientation
)
{
EnableDevice
(
eAbsoluteDeviceOrientation
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondeviceproximity
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onuserproximity
)
{
EnableDevice
(
eDeviceProximity
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondevicelight
)
{
EnableDevice
(
eDeviceLight
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondevicemotion
)
{
EnableDevice
(
eDeviceMotion
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onorientationchange
)
{
EnableDevice
(
eOrientationChange
)
;
#
endif
#
ifdef
MOZ_B2G
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onmoztimechange
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
window
-
>
EnableTimeChangeNotifications
(
)
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onmoznetworkupload
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
window
-
>
EnableNetworkEvent
(
eNetworkUpload
)
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onmoznetworkdownload
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
window
-
>
EnableNetworkEvent
(
eNetworkDownload
)
;
}
#
endif
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchstart
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchend
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchmove
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchcancel
)
{
mMayHaveTouchEventListener
=
true
;
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
;
if
(
window
&
&
!
aFlags
.
mInSystemGroup
)
{
window
-
>
SetHasTouchEventListeners
(
)
;
}
}
else
if
(
aEventMessage
>
=
ePointerEventFirst
&
&
aEventMessage
<
=
ePointerEventLast
)
{
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
;
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onpointerenter
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onpointerleave
)
{
mMayHavePointerEnterLeaveEventListener
=
true
;
if
(
window
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocument
>
d
=
window
-
>
GetExtantDoc
(
)
;
NS_WARN_IF_FALSE
(
!
nsContentUtils
:
:
IsChromeDoc
(
d
)
"
Please
do
not
use
pointerenter
/
leave
events
in
chrome
.
"
"
They
are
slower
than
pointerover
/
out
!
"
)
;
#
endif
window
-
>
SetHasPointerEnterLeaveEventListeners
(
)
;
}
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onmouseenter
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onmouseleave
)
{
mMayHaveMouseEnterLeaveEventListener
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocument
>
d
=
window
-
>
GetExtantDoc
(
)
;
NS_WARN_IF_FALSE
(
!
nsContentUtils
:
:
IsChromeDoc
(
d
)
"
Please
do
not
use
mouseenter
/
leave
events
in
chrome
.
"
"
They
are
slower
than
mouseover
/
out
!
"
)
;
#
endif
window
-
>
SetHasMouseEnterLeaveEventListeners
(
)
;
}
#
ifdef
MOZ_GAMEPAD
}
else
if
(
aEventMessage
>
=
eGamepadEventFirst
&
&
aEventMessage
<
=
eGamepadEventLast
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
window
-
>
SetHasGamepadEventListener
(
)
;
}
#
endif
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onkeydown
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onkeypress
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onkeyup
)
{
if
(
!
aFlags
.
mInSystemGroup
)
{
mMayHaveKeyEventListener
=
true
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
oncompositionend
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
oncompositionstart
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
oncompositionupdate
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
oninput
)
{
if
(
!
aFlags
.
mInSystemGroup
)
{
mMayHaveInputOrCompositionEventListener
=
true
;
}
}
if
(
IsApzAwareEvent
(
aTypeAtom
)
)
{
ProcessApzAwareEventListenerAdd
(
)
;
}
if
(
aTypeAtom
&
&
mTarget
)
{
mTarget
-
>
EventListenerAdded
(
aTypeAtom
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aTypeAtom
)
;
}
}
void
EventListenerManager
:
:
ProcessApzAwareEventListenerAdd
(
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
mTarget
)
;
if
(
node
)
{
node
-
>
SetMayHaveApzAwareListeners
(
)
;
}
nsIDocument
*
doc
=
nullptr
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
}
if
(
!
doc
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
if
(
!
doc
)
{
if
(
nsCOMPtr
<
DOMEventTargetHelper
>
helper
=
do_QueryInterface
(
mTarget
)
)
{
if
(
nsPIDOMWindowInner
*
window
=
helper
-
>
GetOwner
(
)
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
}
if
(
doc
)
{
nsIPresShell
*
ps
=
doc
-
>
GetShell
(
)
;
if
(
ps
)
{
nsIFrame
*
f
=
ps
-
>
GetRootFrame
(
)
;
if
(
f
)
{
f
-
>
SchedulePaint
(
)
;
}
}
}
}
bool
EventListenerManager
:
:
IsDeviceType
(
EventMessage
aEventMessage
)
{
switch
(
aEventMessage
)
{
case
eDeviceOrientation
:
case
eAbsoluteDeviceOrientation
:
case
eDeviceMotion
:
case
eDeviceLight
:
case
eDeviceProximity
:
case
eUserProximity
:
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
case
eOrientationChange
:
#
endif
return
true
;
default
:
break
;
}
return
false
;
}
void
EventListenerManager
:
:
EnableDevice
(
EventMessage
aEventMessage
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
switch
(
aEventMessage
)
{
case
eDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
EnableDeviceSensor
(
SENSOR_GAME_ROTATION_VECTOR
)
;
#
else
window
-
>
EnableDeviceSensor
(
SENSOR_ORIENTATION
)
;
#
endif
break
;
case
eAbsoluteDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
EnableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
else
window
-
>
EnableDeviceSensor
(
SENSOR_ORIENTATION
)
;
#
endif
break
;
case
eDeviceProximity
:
case
eUserProximity
:
window
-
>
EnableDeviceSensor
(
SENSOR_PROXIMITY
)
;
break
;
case
eDeviceLight
:
window
-
>
EnableDeviceSensor
(
SENSOR_LIGHT
)
;
break
;
case
eDeviceMotion
:
window
-
>
EnableDeviceSensor
(
SENSOR_ACCELERATION
)
;
window
-
>
EnableDeviceSensor
(
SENSOR_LINEAR_ACCELERATION
)
;
window
-
>
EnableDeviceSensor
(
SENSOR_GYROSCOPE
)
;
break
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
case
eOrientationChange
:
window
-
>
EnableOrientationChangeListener
(
)
;
break
;
#
endif
default
:
NS_WARNING
(
"
Enabling
an
unknown
device
sensor
.
"
)
;
break
;
}
}
void
EventListenerManager
:
:
DisableDevice
(
EventMessage
aEventMessage
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
switch
(
aEventMessage
)
{
case
eDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
DisableDeviceSensor
(
SENSOR_GAME_ROTATION_VECTOR
)
;
window
-
>
DisableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
endif
window
-
>
DisableDeviceSensor
(
SENSOR_ORIENTATION
)
;
break
;
case
eAbsoluteDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
DisableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
endif
window
-
>
DisableDeviceSensor
(
SENSOR_ORIENTATION
)
;
break
;
case
eDeviceMotion
:
window
-
>
DisableDeviceSensor
(
SENSOR_ACCELERATION
)
;
window
-
>
DisableDeviceSensor
(
SENSOR_LINEAR_ACCELERATION
)
;
window
-
>
DisableDeviceSensor
(
SENSOR_GYROSCOPE
)
;
break
;
case
eDeviceProximity
:
case
eUserProximity
:
window
-
>
DisableDeviceSensor
(
SENSOR_PROXIMITY
)
;
break
;
case
eDeviceLight
:
window
-
>
DisableDeviceSensor
(
SENSOR_LIGHT
)
;
break
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
case
eOrientationChange
:
window
-
>
DisableOrientationChangeListener
(
)
;
break
;
#
endif
default
:
NS_WARNING
(
"
Disabling
an
unknown
device
sensor
.
"
)
;
break
;
}
}
void
EventListenerManager
:
:
RemoveEventListenerInternal
(
const
EventListenerHolder
&
aListenerHolder
EventMessage
aEventMessage
nsIAtom
*
aUserType
const
nsAString
&
aTypeString
const
EventListenerFlags
&
aFlags
bool
aAllEvents
)
{
if
(
!
aListenerHolder
|
|
!
aEventMessage
|
|
mClearingListeners
)
{
return
;
}
Listener
*
listener
;
uint32_t
count
=
mListeners
.
Length
(
)
;
uint32_t
typeCount
=
0
;
bool
deviceType
=
IsDeviceType
(
aEventMessage
)
;
#
ifdef
MOZ_B2G
bool
timeChangeEvent
=
(
aEventMessage
=
=
eTimeChange
)
;
bool
networkEvent
=
(
aEventMessage
=
=
eNetworkUpload
|
|
aEventMessage
=
=
eNetworkDownload
)
;
#
endif
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
EVENT_TYPE_EQUALS
(
listener
aEventMessage
aUserType
aTypeString
aAllEvents
)
)
{
+
+
typeCount
;
if
(
listener
-
>
mListener
=
=
aListenerHolder
&
&
listener
-
>
mFlags
.
EqualsIgnoringTrustness
(
aFlags
)
)
{
RefPtr
<
EventListenerManager
>
kungFuDeathGrip
(
this
)
;
mListeners
.
RemoveElementAt
(
i
)
;
-
-
count
;
mNoListenerForEvent
=
eVoidEvent
;
mNoListenerForEventAtom
=
nullptr
;
if
(
mTarget
&
&
aUserType
)
{
mTarget
-
>
EventListenerRemoved
(
aUserType
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aUserType
)
;
}
if
(
!
deviceType
#
ifdef
MOZ_B2G
&
&
!
timeChangeEvent
&
&
!
networkEvent
#
endif
)
{
return
;
}
-
-
typeCount
;
}
}
}
if
(
!
aAllEvents
&
&
deviceType
&
&
typeCount
=
=
0
)
{
DisableDevice
(
aEventMessage
)
;
#
ifdef
MOZ_B2G
}
else
if
(
timeChangeEvent
&
&
typeCount
=
=
0
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
window
-
>
DisableTimeChangeNotifications
(
)
;
}
}
else
if
(
!
aAllEvents
&
&
networkEvent
&
&
typeCount
=
=
0
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
window
-
>
DisableNetworkEvent
(
aEventMessage
)
;
}
#
endif
}
}
bool
EventListenerManager
:
:
ListenerCanHandle
(
const
Listener
*
aListener
const
WidgetEvent
*
aEvent
EventMessage
aEventMessage
)
const
{
MOZ_ASSERT
(
aEventMessage
=
=
aEvent
-
>
mMessage
|
|
aEventMessage
=
=
GetLegacyEventMessage
(
aEvent
-
>
mMessage
)
"
aEvent
and
aEventMessage
should
agree
modulo
legacyness
"
)
;
if
(
aListener
-
>
mAllEvents
)
{
return
true
;
}
if
(
aEvent
-
>
mMessage
=
=
eUnidentifiedEvent
)
{
if
(
mIsMainThreadELM
)
{
return
aListener
-
>
mTypeAtom
=
=
aEvent
-
>
userType
;
}
return
aListener
-
>
mTypeString
.
Equals
(
aEvent
-
>
typeString
)
;
}
MOZ_ASSERT
(
mIsMainThreadELM
)
;
return
aListener
-
>
mEventMessage
=
=
aEventMessage
;
}
void
EventListenerManager
:
:
AddEventListenerByType
(
const
EventListenerHolder
&
aListenerHolder
const
nsAString
&
aType
const
EventListenerFlags
&
aFlags
)
{
nsCOMPtr
<
nsIAtom
>
atom
=
mIsMainThreadELM
?
do_GetAtom
(
NS_LITERAL_STRING
(
"
on
"
)
+
aType
)
:
nullptr
;
EventMessage
message
=
nsContentUtils
:
:
GetEventMessage
(
atom
)
;
AddEventListenerInternal
(
aListenerHolder
message
atom
aType
aFlags
)
;
}
void
EventListenerManager
:
:
RemoveEventListenerByType
(
const
EventListenerHolder
&
aListenerHolder
const
nsAString
&
aType
const
EventListenerFlags
&
aFlags
)
{
nsCOMPtr
<
nsIAtom
>
atom
=
mIsMainThreadELM
?
do_GetAtom
(
NS_LITERAL_STRING
(
"
on
"
)
+
aType
)
:
nullptr
;
EventMessage
message
=
nsContentUtils
:
:
GetEventMessage
(
atom
)
;
RemoveEventListenerInternal
(
aListenerHolder
message
atom
aType
aFlags
)
;
}
EventListenerManager
:
:
Listener
*
EventListenerManager
:
:
FindEventHandler
(
EventMessage
aEventMessage
nsIAtom
*
aTypeAtom
const
nsAString
&
aTypeString
)
{
Listener
*
listener
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mListenerIsHandler
&
&
EVENT_TYPE_EQUALS
(
listener
aEventMessage
aTypeAtom
aTypeString
false
)
)
{
return
listener
;
}
}
return
nullptr
;
}
EventListenerManager
:
:
Listener
*
EventListenerManager
:
:
SetEventHandlerInternal
(
nsIAtom
*
aName
const
nsAString
&
aTypeString
const
TypedEventHandler
&
aTypedHandler
bool
aPermitUntrustedEvents
)
{
MOZ_ASSERT
(
aName
|
|
!
aTypeString
.
IsEmpty
(
)
)
;
EventMessage
eventMessage
=
nsContentUtils
:
:
GetEventMessage
(
aName
)
;
Listener
*
listener
=
FindEventHandler
(
eventMessage
aName
aTypeString
)
;
if
(
!
listener
)
{
EventListenerFlags
flags
;
flags
.
mListenerIsJSListener
=
true
;
nsCOMPtr
<
JSEventHandler
>
jsEventHandler
;
NS_NewJSEventHandler
(
mTarget
aName
aTypedHandler
getter_AddRefs
(
jsEventHandler
)
)
;
EventListenerHolder
listenerHolder
(
jsEventHandler
)
;
AddEventListenerInternal
(
listenerHolder
eventMessage
aName
aTypeString
flags
true
)
;
listener
=
FindEventHandler
(
eventMessage
aName
aTypeString
)
;
}
else
{
JSEventHandler
*
jsEventHandler
=
listener
-
>
GetJSEventHandler
(
)
;
MOZ_ASSERT
(
jsEventHandler
"
How
can
we
have
an
event
handler
with
no
JSEventHandler
?
"
)
;
bool
same
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
=
=
aTypedHandler
;
jsEventHandler
-
>
SetHandler
(
aTypedHandler
)
;
if
(
mTarget
&
&
!
same
&
&
aName
)
{
mTarget
-
>
EventListenerRemoved
(
aName
)
;
mTarget
-
>
EventListenerAdded
(
aName
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aName
)
;
}
}
listener
-
>
mHandlerIsString
=
!
aTypedHandler
.
HasEventHandler
(
)
;
if
(
aPermitUntrustedEvents
)
{
listener
-
>
mFlags
.
mAllowUntrustedEvents
=
true
;
}
return
listener
;
}
nsresult
EventListenerManager
:
:
SetEventHandler
(
nsIAtom
*
aName
const
nsAString
&
aBody
bool
aDeferCompilation
bool
aPermitUntrustedEvents
Element
*
aElement
)
{
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsIScriptGlobalObject
>
global
=
GetScriptGlobalAndDocument
(
getter_AddRefs
(
doc
)
)
;
if
(
!
global
)
{
return
NS_OK
;
}
#
ifdef
DEBUG
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
global
)
)
{
MOZ_ASSERT
(
win
-
>
IsInnerWindow
(
)
"
We
should
not
have
an
outer
window
here
!
"
)
;
}
#
endif
nsresult
rv
=
NS_OK
;
if
(
doc
)
{
if
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_SCRIPTS
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
rv
=
doc
-
>
NodePrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
csp
)
{
nsAutoString
scriptSample
attr
tagName
(
NS_LITERAL_STRING
(
"
UNKNOWN
"
)
)
;
aName
-
>
ToString
(
attr
)
;
nsCOMPtr
<
nsIDOMNode
>
domNode
(
do_QueryInterface
(
mTarget
)
)
;
if
(
domNode
)
{
domNode
-
>
GetNodeName
(
tagName
)
;
}
scriptSample
.
Assign
(
attr
)
;
scriptSample
.
AppendLiteral
(
"
attribute
on
"
)
;
scriptSample
.
Append
(
tagName
)
;
scriptSample
.
AppendLiteral
(
"
element
"
)
;
bool
allowsInlineScript
=
true
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_SCRIPT
EmptyString
(
)
scriptSample
0
&
allowsInlineScript
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
allowsInlineScript
)
{
return
NS_OK
;
}
}
}
if
(
NS_FAILED
(
global
-
>
EnsureScriptEnvironment
(
)
)
)
{
NS_WARNING
(
"
Failed
to
setup
script
environment
for
this
language
"
)
;
}
nsIScriptContext
*
context
=
global
-
>
GetScriptContext
(
)
;
NS_ENSURE_TRUE
(
context
NS_ERROR_FAILURE
)
;
NS_ENSURE_STATE
(
global
-
>
GetGlobalJSObject
(
)
)
;
Listener
*
listener
=
SetEventHandlerInternal
(
aName
EmptyString
(
)
TypedEventHandler
(
)
aPermitUntrustedEvents
)
;
if
(
!
aDeferCompilation
)
{
return
CompileEventHandlerInternal
(
listener
&
aBody
aElement
)
;
}
return
NS_OK
;
}
void
EventListenerManager
:
:
RemoveEventHandler
(
nsIAtom
*
aName
const
nsAString
&
aTypeString
)
{
if
(
mClearingListeners
)
{
return
;
}
EventMessage
eventMessage
=
nsContentUtils
:
:
GetEventMessage
(
aName
)
;
Listener
*
listener
=
FindEventHandler
(
eventMessage
aName
aTypeString
)
;
if
(
listener
)
{
mListeners
.
RemoveElementAt
(
uint32_t
(
listener
-
&
mListeners
.
ElementAt
(
0
)
)
)
;
mNoListenerForEvent
=
eVoidEvent
;
mNoListenerForEventAtom
=
nullptr
;
if
(
mTarget
&
&
aName
)
{
mTarget
-
>
EventListenerRemoved
(
aName
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aName
)
;
}
}
}
nsresult
EventListenerManager
:
:
CompileEventHandlerInternal
(
Listener
*
aListener
const
nsAString
*
aBody
Element
*
aElement
)
{
MOZ_ASSERT
(
aListener
-
>
GetJSEventHandler
(
)
)
;
MOZ_ASSERT
(
aListener
-
>
mHandlerIsString
"
Why
are
we
compiling
a
non
-
string
JS
listener
?
"
)
;
JSEventHandler
*
jsEventHandler
=
aListener
-
>
GetJSEventHandler
(
)
;
MOZ_ASSERT
(
!
jsEventHandler
-
>
GetTypedEventHandler
(
)
.
HasEventHandler
(
)
"
What
is
there
to
compile
?
"
)
;
nsresult
result
=
NS_OK
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsIScriptGlobalObject
>
global
=
GetScriptGlobalAndDocument
(
getter_AddRefs
(
doc
)
)
;
NS_ENSURE_STATE
(
global
)
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
global
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
jsapi
.
TakeOwnershipOfErrorReporting
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsCOMPtr
<
nsIAtom
>
typeAtom
=
aListener
-
>
mTypeAtom
;
nsIAtom
*
attrName
=
typeAtom
;
aListener
-
>
mHandlerIsString
=
false
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
mTarget
)
;
MOZ_ASSERT
(
element
|
|
aBody
"
Where
will
we
get
our
body
?
"
)
;
nsAutoString
handlerBody
;
const
nsAString
*
body
=
aBody
;
if
(
!
aBody
)
{
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGLoad
)
{
attrName
=
nsGkAtoms
:
:
onload
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGUnload
)
{
attrName
=
nsGkAtoms
:
:
onunload
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGResize
)
{
attrName
=
nsGkAtoms
:
:
onresize
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGScroll
)
{
attrName
=
nsGkAtoms
:
:
onscroll
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGZoom
)
{
attrName
=
nsGkAtoms
:
:
onzoom
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onbeginEvent
)
{
attrName
=
nsGkAtoms
:
:
onbegin
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onrepeatEvent
)
{
attrName
=
nsGkAtoms
:
:
onrepeat
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onendEvent
)
{
attrName
=
nsGkAtoms
:
:
onend
;
}
element
-
>
GetAttr
(
kNameSpaceID_None
attrName
handlerBody
)
;
body
=
&
handlerBody
;
aElement
=
element
;
}
aListener
=
nullptr
;
uint32_t
lineNo
=
0
;
nsAutoCString
url
(
NS_LITERAL_CSTRING
(
"
-
moz
-
evil
:
lying
-
event
-
listener
"
)
)
;
MOZ_ASSERT
(
body
)
;
MOZ_ASSERT
(
aElement
)
;
nsIURI
*
uri
=
aElement
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
url
)
;
lineNo
=
1
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
mTarget
)
;
uint32_t
argCount
;
const
char
*
*
argNames
;
nsContentUtils
:
:
GetEventArgNames
(
aElement
-
>
GetNameSpaceID
(
)
typeAtom
win
&
argCount
&
argNames
)
;
JSAddonId
*
addonId
=
MapURIToAddonID
(
uri
)
;
JS
:
:
Rooted
<
JSObject
*
>
wrapScope
(
cx
global
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
)
;
{
JSAutoCompartment
ac
(
cx
wrapScope
)
;
nsresult
rv
=
nsContentUtils
:
:
WrapNative
(
cx
mTarget
&
v
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
addonId
)
{
JS
:
:
Rooted
<
JSObject
*
>
vObj
(
cx
&
v
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
addonScope
(
cx
xpc
:
:
GetAddonScope
(
cx
vObj
addonId
)
)
;
if
(
!
addonScope
)
{
return
NS_ERROR_FAILURE
;
}
JSAutoCompartment
ac
(
cx
addonScope
)
;
if
(
!
JS_WrapValue
(
cx
&
v
)
)
{
return
NS_ERROR_FAILURE
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
target
(
cx
&
v
.
toObject
(
)
)
;
JSAutoCompartment
ac
(
cx
target
)
;
JS
:
:
AutoObjectVector
scopeChain
(
cx
)
;
if
(
!
nsJSUtils
:
:
GetScopeChainForElement
(
cx
element
scopeChain
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsDependentAtomString
str
(
attrName
)
;
JS
:
:
Rooted
<
JSString
*
>
jsStr
(
cx
JS_NewUCStringCopyN
(
cx
str
.
BeginReading
(
)
str
.
Length
(
)
)
)
;
NS_ENSURE_TRUE
(
jsStr
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
NS_WARN_IF
(
!
GetOrCreateDOMReflector
(
cx
aElement
&
v
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
CompileOptions
options
(
cx
)
;
options
.
setIntroductionType
(
"
eventHandler
"
)
.
setFileAndLine
(
url
.
get
(
)
lineNo
)
.
setVersion
(
JSVERSION_DEFAULT
)
.
setElement
(
&
v
.
toObject
(
)
)
.
setElementAttributeName
(
jsStr
)
;
JS
:
:
Rooted
<
JSObject
*
>
handler
(
cx
)
;
result
=
nsJSUtils
:
:
CompileFunction
(
jsapi
scopeChain
options
nsAtomCString
(
typeAtom
)
argCount
argNames
*
body
handler
.
address
(
)
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
NS_ENSURE_TRUE
(
handler
NS_ERROR_FAILURE
)
;
if
(
jsEventHandler
-
>
EventName
(
)
=
=
nsGkAtoms
:
:
onerror
&
&
win
)
{
RefPtr
<
OnErrorEventHandlerNonNull
>
handlerCallback
=
new
OnErrorEventHandlerNonNull
(
nullptr
handler
nullptr
)
;
jsEventHandler
-
>
SetHandler
(
handlerCallback
)
;
}
else
if
(
jsEventHandler
-
>
EventName
(
)
=
=
nsGkAtoms
:
:
onbeforeunload
&
&
win
)
{
RefPtr
<
OnBeforeUnloadEventHandlerNonNull
>
handlerCallback
=
new
OnBeforeUnloadEventHandlerNonNull
(
nullptr
handler
nullptr
)
;
jsEventHandler
-
>
SetHandler
(
handlerCallback
)
;
}
else
{
RefPtr
<
EventHandlerNonNull
>
handlerCallback
=
new
EventHandlerNonNull
(
nullptr
handler
nullptr
)
;
jsEventHandler
-
>
SetHandler
(
handlerCallback
)
;
}
return
result
;
}
nsresult
EventListenerManager
:
:
HandleEventSubType
(
Listener
*
aListener
nsIDOMEvent
*
aDOMEvent
EventTarget
*
aCurrentTarget
)
{
nsresult
result
=
NS_OK
;
EventListenerHolder
listenerHolder
(
aListener
-
>
mListener
)
;
if
(
(
aListener
-
>
mListenerType
=
=
Listener
:
:
eJSEventListener
)
&
&
aListener
-
>
mHandlerIsString
)
{
result
=
CompileEventHandlerInternal
(
aListener
nullptr
nullptr
)
;
aListener
=
nullptr
;
}
if
(
NS_SUCCEEDED
(
result
)
)
{
if
(
mIsMainThreadELM
)
{
nsContentUtils
:
:
EnterMicroTask
(
)
;
}
if
(
listenerHolder
.
HasWebIDLCallback
(
)
)
{
ErrorResult
rv
;
listenerHolder
.
GetWebIDLCallback
(
)
-
>
HandleEvent
(
aCurrentTarget
*
(
aDOMEvent
-
>
InternalDOMEvent
(
)
)
rv
)
;
result
=
rv
.
StealNSResult
(
)
;
}
else
{
result
=
listenerHolder
.
GetXPCOMCallback
(
)
-
>
HandleEvent
(
aDOMEvent
)
;
}
if
(
mIsMainThreadELM
)
{
nsContentUtils
:
:
LeaveMicroTask
(
)
;
}
}
return
result
;
}
EventMessage
EventListenerManager
:
:
GetLegacyEventMessage
(
EventMessage
aEventMessage
)
const
{
if
(
mIsMainThreadELM
&
&
IsWebkitPrefixSupportEnabled
(
)
)
{
if
(
aEventMessage
=
=
eTransitionEnd
)
{
return
eWebkitTransitionEnd
;
}
if
(
aEventMessage
=
=
eAnimationStart
)
{
return
eWebkitAnimationStart
;
}
if
(
aEventMessage
=
=
eAnimationEnd
)
{
return
eWebkitAnimationEnd
;
}
if
(
aEventMessage
=
=
eAnimationIteration
)
{
return
eWebkitAnimationIteration
;
}
}
return
aEventMessage
;
}
nsIDocShell
*
EventListenerManager
:
:
GetDocShellForTarget
(
)
{
nsCOMPtr
<
nsINode
>
node
(
do_QueryInterface
(
mTarget
)
)
;
nsIDocument
*
doc
=
nullptr
;
nsIDocShell
*
docShell
=
nullptr
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
if
(
!
doc
-
>
GetDocShell
(
)
)
{
bool
ignore
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
doc
-
>
GetScriptHandlingObject
(
ignore
)
)
;
if
(
window
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
}
else
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
if
(
!
doc
)
{
nsCOMPtr
<
DOMEventTargetHelper
>
helper
(
do_QueryInterface
(
mTarget
)
)
;
if
(
helper
)
{
if
(
nsPIDOMWindowInner
*
window
=
helper
-
>
GetOwner
(
)
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
}
if
(
doc
)
{
docShell
=
doc
-
>
GetDocShell
(
)
;
}
return
docShell
;
}
void
EventListenerManager
:
:
HandleEventInternal
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIDOMEvent
*
*
aDOMEvent
EventTarget
*
aCurrentTarget
nsEventStatus
*
aEventStatus
)
{
if
(
*
aEventStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
aEvent
-
>
mFlags
.
mDefaultPrevented
=
true
;
}
Maybe
<
nsAutoPopupStatePusher
>
popupStatePusher
;
if
(
mIsMainThreadELM
)
{
popupStatePusher
.
emplace
(
Event
:
:
GetEventPopupControlState
(
aEvent
*
aDOMEvent
)
)
;
}
bool
hasListener
=
false
;
bool
hasListenerForCurrentGroup
=
false
;
bool
usingLegacyMessage
=
false
;
EventMessage
eventMessage
=
aEvent
-
>
mMessage
;
while
(
true
)
{
nsAutoTObserverArray
<
Listener
2
>
:
:
EndLimitedIterator
iter
(
mListeners
)
;
Maybe
<
EventMessageAutoOverride
>
legacyAutoOverride
;
while
(
iter
.
HasMore
(
)
)
{
if
(
aEvent
-
>
mFlags
.
mImmediatePropagationStopped
)
{
break
;
}
Listener
*
listener
=
&
iter
.
GetNext
(
)
;
if
(
ListenerCanHandle
(
listener
aEvent
eventMessage
)
)
{
hasListener
=
true
;
hasListenerForCurrentGroup
=
hasListenerForCurrentGroup
|
|
listener
-
>
mFlags
.
mInSystemGroup
=
=
aEvent
-
>
mFlags
.
mInSystemGroup
;
if
(
listener
-
>
IsListening
(
aEvent
)
&
&
(
aEvent
-
>
mFlags
.
mIsTrusted
|
|
listener
-
>
mFlags
.
mAllowUntrustedEvents
)
)
{
if
(
!
*
aDOMEvent
)
{
nsCOMPtr
<
EventTarget
>
et
=
do_QueryInterface
(
aEvent
-
>
originalTarget
)
;
RefPtr
<
Event
>
event
=
EventDispatcher
:
:
CreateEvent
(
et
aPresContext
aEvent
EmptyString
(
)
)
;
event
.
forget
(
aDOMEvent
)
;
}
if
(
*
aDOMEvent
)
{
if
(
!
aEvent
-
>
currentTarget
)
{
aEvent
-
>
currentTarget
=
aCurrentTarget
-
>
GetTargetForDOMEvent
(
)
;
if
(
!
aEvent
-
>
currentTarget
)
{
break
;
}
}
if
(
usingLegacyMessage
&
&
!
legacyAutoOverride
)
{
legacyAutoOverride
.
emplace
(
*
aDOMEvent
eventMessage
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
needsEndEventMarker
=
false
;
if
(
mIsMainThreadELM
&
&
listener
-
>
mListenerType
!
=
Listener
:
:
eNativeListener
)
{
docShell
=
GetDocShellForTarget
(
)
;
if
(
docShell
)
{
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
)
{
needsEndEventMarker
=
true
;
nsAutoString
typeStr
;
(
*
aDOMEvent
)
-
>
GetType
(
typeStr
)
;
uint16_t
phase
;
(
*
aDOMEvent
)
-
>
GetEventPhase
(
&
phase
)
;
timelines
-
>
AddMarkerForDocShell
(
docShell
Move
(
MakeUnique
<
EventTimelineMarker
>
(
typeStr
phase
MarkerTracingType
:
:
START
)
)
)
;
}
}
}
if
(
NS_FAILED
(
HandleEventSubType
(
listener
*
aDOMEvent
aCurrentTarget
)
)
)
{
aEvent
-
>
mFlags
.
mExceptionHasBeenRisen
=
true
;
}
if
(
needsEndEventMarker
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
"
DOMEvent
"
MarkerTracingType
:
:
END
)
;
}
}
}
}
}
if
(
hasListenerForCurrentGroup
|
|
usingLegacyMessage
)
{
break
;
}
EventMessage
legacyEventMessage
=
GetLegacyEventMessage
(
eventMessage
)
;
if
(
legacyEventMessage
=
=
eventMessage
)
{
break
;
}
MOZ_ASSERT
(
GetLegacyEventMessage
(
legacyEventMessage
)
=
=
legacyEventMessage
"
Legacy
event
messages
should
not
themselves
have
legacy
versions
"
)
;
eventMessage
=
legacyEventMessage
;
usingLegacyMessage
=
true
;
}
aEvent
-
>
currentTarget
=
nullptr
;
if
(
mIsMainThreadELM
&
&
!
hasListener
)
{
mNoListenerForEvent
=
aEvent
-
>
mMessage
;
mNoListenerForEventAtom
=
aEvent
-
>
userType
;
}
if
(
aEvent
-
>
mFlags
.
mDefaultPrevented
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
void
EventListenerManager
:
:
Disconnect
(
)
{
mTarget
=
nullptr
;
RemoveAllListeners
(
)
;
}
void
EventListenerManager
:
:
AddEventListener
(
const
nsAString
&
aType
const
EventListenerHolder
&
aListenerHolder
bool
aUseCapture
bool
aWantsUntrusted
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
flags
.
mAllowUntrustedEvents
=
aWantsUntrusted
;
return
AddEventListenerByType
(
aListenerHolder
aType
flags
)
;
}
void
EventListenerManager
:
:
RemoveEventListener
(
const
nsAString
&
aType
const
EventListenerHolder
&
aListenerHolder
bool
aUseCapture
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
RemoveEventListenerByType
(
aListenerHolder
aType
flags
)
;
}
void
EventListenerManager
:
:
AddListenerForAllEvents
(
nsIDOMEventListener
*
aDOMListener
bool
aUseCapture
bool
aWantsUntrusted
bool
aSystemEventGroup
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
flags
.
mAllowUntrustedEvents
=
aWantsUntrusted
;
flags
.
mInSystemGroup
=
aSystemEventGroup
;
EventListenerHolder
listenerHolder
(
aDOMListener
)
;
AddEventListenerInternal
(
listenerHolder
eAllEvents
nullptr
EmptyString
(
)
flags
false
true
)
;
}
void
EventListenerManager
:
:
RemoveListenerForAllEvents
(
nsIDOMEventListener
*
aDOMListener
bool
aUseCapture
bool
aSystemEventGroup
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
flags
.
mInSystemGroup
=
aSystemEventGroup
;
EventListenerHolder
listenerHolder
(
aDOMListener
)
;
RemoveEventListenerInternal
(
listenerHolder
eAllEvents
nullptr
EmptyString
(
)
flags
true
)
;
}
bool
EventListenerManager
:
:
HasMutationListeners
(
)
{
if
(
mMayHaveMutationListeners
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mEventMessage
>
=
eLegacyMutationEventFirst
&
&
listener
-
>
mEventMessage
<
=
eLegacyMutationEventLast
)
{
return
true
;
}
}
}
return
false
;
}
uint32_t
EventListenerManager
:
:
MutationListenerBits
(
)
{
uint32_t
bits
=
0
;
if
(
mMayHaveMutationListeners
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mEventMessage
>
=
eLegacyMutationEventFirst
&
&
listener
-
>
mEventMessage
<
=
eLegacyMutationEventLast
)
{
if
(
listener
-
>
mEventMessage
=
=
eLegacySubtreeModified
)
{
return
kAllMutationBits
;
}
bits
|
=
MutationBitForEventType
(
listener
-
>
mEventMessage
)
;
}
}
}
return
bits
;
}
bool
EventListenerManager
:
:
HasListenersFor
(
const
nsAString
&
aEventName
)
{
if
(
mIsMainThreadELM
)
{
nsCOMPtr
<
nsIAtom
>
atom
=
do_GetAtom
(
NS_LITERAL_STRING
(
"
on
"
)
+
aEventName
)
;
return
HasListenersFor
(
atom
)
;
}
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mTypeString
=
=
aEventName
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
HasListenersFor
(
nsIAtom
*
aEventNameWithOn
)
{
#
ifdef
DEBUG
nsAutoString
name
;
aEventNameWithOn
-
>
ToString
(
name
)
;
#
endif
NS_ASSERTION
(
StringBeginsWith
(
name
NS_LITERAL_STRING
(
"
on
"
)
)
"
Event
name
does
not
start
with
'
on
'
"
)
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mTypeAtom
=
=
aEventNameWithOn
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
HasListeners
(
)
{
return
!
mListeners
.
IsEmpty
(
)
;
}
nsresult
EventListenerManager
:
:
GetListenerInfo
(
nsCOMArray
<
nsIEventListenerInfo
>
*
aList
)
{
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
mTarget
)
;
NS_ENSURE_STATE
(
target
)
;
aList
-
>
Clear
(
)
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
Listener
&
listener
=
mListeners
.
ElementAt
(
i
)
;
if
(
listener
.
mListenerType
=
=
Listener
:
:
eJSEventListener
&
&
listener
.
mHandlerIsString
)
{
CompileEventHandlerInternal
(
const_cast
<
Listener
*
>
(
&
listener
)
nullptr
nullptr
)
;
}
nsAutoString
eventType
;
if
(
listener
.
mAllEvents
)
{
eventType
.
SetIsVoid
(
true
)
;
}
else
{
eventType
.
Assign
(
Substring
(
nsDependentAtomString
(
listener
.
mTypeAtom
)
2
)
)
;
}
RefPtr
<
EventListenerInfo
>
info
=
new
EventListenerInfo
(
eventType
listener
.
mListener
.
ToXPCOMCallback
(
)
listener
.
mFlags
.
mCapture
listener
.
mFlags
.
mAllowUntrustedEvents
listener
.
mFlags
.
mInSystemGroup
)
;
aList
-
>
AppendObject
(
info
)
;
}
return
NS_OK
;
}
bool
EventListenerManager
:
:
HasUnloadListeners
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mEventMessage
=
=
eUnload
|
|
listener
-
>
mEventMessage
=
=
eBeforeUnload
)
{
return
true
;
}
}
return
false
;
}
void
EventListenerManager
:
:
SetEventHandler
(
nsIAtom
*
aEventName
const
nsAString
&
aTypeString
EventHandlerNonNull
*
aHandler
)
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
aEventName
aTypeString
)
;
return
;
}
SetEventHandlerInternal
(
aEventName
aTypeString
TypedEventHandler
(
aHandler
)
!
mIsMainThreadELM
|
|
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
}
void
EventListenerManager
:
:
SetEventHandler
(
OnErrorEventHandlerNonNull
*
aHandler
)
{
if
(
mIsMainThreadELM
)
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
nsGkAtoms
:
:
onerror
EmptyString
(
)
)
;
return
;
}
SetEventHandlerInternal
(
nsGkAtoms
:
:
onerror
EmptyString
(
)
TypedEventHandler
(
aHandler
)
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
}
else
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
nullptr
NS_LITERAL_STRING
(
"
error
"
)
)
;
return
;
}
SetEventHandlerInternal
(
nullptr
NS_LITERAL_STRING
(
"
error
"
)
TypedEventHandler
(
aHandler
)
true
)
;
}
}
void
EventListenerManager
:
:
SetEventHandler
(
OnBeforeUnloadEventHandlerNonNull
*
aHandler
)
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
nsGkAtoms
:
:
onbeforeunload
EmptyString
(
)
)
;
return
;
}
SetEventHandlerInternal
(
nsGkAtoms
:
:
onbeforeunload
EmptyString
(
)
TypedEventHandler
(
aHandler
)
!
mIsMainThreadELM
|
|
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
}
const
TypedEventHandler
*
EventListenerManager
:
:
GetTypedEventHandler
(
nsIAtom
*
aEventName
const
nsAString
&
aTypeString
)
{
EventMessage
eventMessage
=
nsContentUtils
:
:
GetEventMessage
(
aEventName
)
;
Listener
*
listener
=
FindEventHandler
(
eventMessage
aEventName
aTypeString
)
;
if
(
!
listener
)
{
return
nullptr
;
}
JSEventHandler
*
jsEventHandler
=
listener
-
>
GetJSEventHandler
(
)
;
if
(
listener
-
>
mHandlerIsString
)
{
CompileEventHandlerInternal
(
listener
nullptr
nullptr
)
;
}
const
TypedEventHandler
&
typedHandler
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
;
return
typedHandler
.
HasEventHandler
(
)
?
&
typedHandler
:
nullptr
;
}
size_t
EventListenerManager
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mListeners
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
JSEventHandler
*
jsEventHandler
=
mListeners
.
ElementAt
(
i
)
.
GetJSEventHandler
(
)
;
if
(
jsEventHandler
)
{
n
+
=
jsEventHandler
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
void
EventListenerManager
:
:
MarkForCC
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
Listener
&
listener
=
mListeners
.
ElementAt
(
i
)
;
JSEventHandler
*
jsEventHandler
=
listener
.
GetJSEventHandler
(
)
;
if
(
jsEventHandler
)
{
const
TypedEventHandler
&
typedHandler
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
;
if
(
typedHandler
.
HasEventHandler
(
)
)
{
typedHandler
.
Ptr
(
)
-
>
MarkForCC
(
)
;
}
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eWrappedJSListener
)
{
xpc_TryUnmarkWrappedGrayObject
(
listener
.
mListener
.
GetXPCOMCallback
(
)
)
;
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eWebIDLListener
)
{
listener
.
mListener
.
GetWebIDLCallback
(
)
-
>
MarkForCC
(
)
;
}
}
if
(
mRefCnt
.
IsPurple
(
)
)
{
mRefCnt
.
RemovePurple
(
)
;
}
}
void
EventListenerManager
:
:
TraceListeners
(
JSTracer
*
aTrc
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
Listener
&
listener
=
mListeners
.
ElementAt
(
i
)
;
JSEventHandler
*
jsEventHandler
=
listener
.
GetJSEventHandler
(
)
;
if
(
jsEventHandler
)
{
const
TypedEventHandler
&
typedHandler
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
;
if
(
typedHandler
.
HasEventHandler
(
)
)
{
mozilla
:
:
TraceScriptHolder
(
typedHandler
.
Ptr
(
)
aTrc
)
;
}
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eWebIDLListener
)
{
mozilla
:
:
TraceScriptHolder
(
listener
.
mListener
.
GetWebIDLCallback
(
)
aTrc
)
;
}
}
}
bool
EventListenerManager
:
:
HasApzAwareListeners
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
IsApzAwareEvent
(
listener
-
>
mTypeAtom
)
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
IsApzAwareEvent
(
nsIAtom
*
aEvent
)
{
return
aEvent
=
=
nsGkAtoms
:
:
ontouchstart
|
|
aEvent
=
=
nsGkAtoms
:
:
ontouchmove
|
|
aEvent
=
=
nsGkAtoms
:
:
onwheel
|
|
aEvent
=
=
nsGkAtoms
:
:
onDOMMouseScroll
|
|
aEvent
=
=
nsHtml5Atoms
:
:
onmousewheel
|
|
aEvent
=
=
nsGkAtoms
:
:
onMozMousePixelScroll
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
EventListenerManager
:
:
GetScriptGlobalAndDocument
(
nsIDocument
*
*
aDoc
)
{
nsCOMPtr
<
nsINode
>
node
(
do_QueryInterface
(
mTarget
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsIScriptGlobalObject
>
global
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsLoadedAsData
(
)
)
{
return
nullptr
;
}
global
=
do_QueryInterface
(
doc
-
>
GetScopeObject
(
)
)
;
}
else
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
GetTargetAsInnerWindow
(
)
)
{
doc
=
win
-
>
GetExtantDoc
(
)
;
global
=
do_QueryInterface
(
win
)
;
}
else
{
global
=
do_QueryInterface
(
mTarget
)
;
}
}
doc
.
forget
(
aDoc
)
;
return
global
.
forget
(
)
;
}
}
