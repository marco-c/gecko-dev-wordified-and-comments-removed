#
undef
CreateEvent
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
HalSensor
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
JSEventHandler
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTargetBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
EventTimelineMarker
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
EventListenerService
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
hal
;
#
define
EVENT_TYPE_EQUALS
(
ls
message
userType
allEvents
)
\
(
(
ls
-
>
mEventMessage
=
=
message
&
&
\
(
ls
-
>
mEventMessage
!
=
eUnidentifiedEvent
|
|
\
ls
-
>
mTypeAtom
=
=
userType
)
)
|
|
\
(
allEvents
&
&
ls
-
>
mAllEvents
)
)
static
const
uint32_t
kAllMutationBits
=
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
|
NS_EVENT_BITS_MUTATION_NODEINSERTED
|
NS_EVENT_BITS_MUTATION_NODEREMOVED
|
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
|
NS_EVENT_BITS_MUTATION_NODEINSERTEDINTODOCUMENT
|
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
|
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
;
static
uint32_t
MutationBitForEventType
(
EventMessage
aEventType
)
{
switch
(
aEventType
)
{
case
eLegacySubtreeModified
:
return
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
;
case
eLegacyNodeInserted
:
return
NS_EVENT_BITS_MUTATION_NODEINSERTED
;
case
eLegacyNodeRemoved
:
return
NS_EVENT_BITS_MUTATION_NODEREMOVED
;
case
eLegacyNodeRemovedFromDocument
:
return
NS_EVENT_BITS_MUTATION_NODEREMOVEDFROMDOCUMENT
;
case
eLegacyNodeInsertedIntoDocument
:
return
NS_EVENT_BITS_MUTATION_NODEINSERTEDINTODOCUMENT
;
case
eLegacyAttrModified
:
return
NS_EVENT_BITS_MUTATION_ATTRMODIFIED
;
case
eLegacyCharacterDataModified
:
return
NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED
;
default
:
break
;
}
return
0
;
}
uint32_t
EventListenerManager
:
:
sMainThreadCreatedCount
=
0
;
static
bool
IsWebkitPrefixSupportEnabled
(
)
{
static
bool
sIsWebkitPrefixSupportEnabled
;
static
bool
sIsPrefCached
=
false
;
if
(
!
sIsPrefCached
)
{
sIsPrefCached
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sIsWebkitPrefixSupportEnabled
"
layout
.
css
.
prefixes
.
webkit
"
)
;
}
return
sIsWebkitPrefixSupportEnabled
;
}
EventListenerManagerBase
:
:
EventListenerManagerBase
(
)
:
mNoListenerForEvent
(
eVoidEvent
)
mMayHavePaintEventListener
(
false
)
mMayHaveMutationListeners
(
false
)
mMayHaveCapturingListeners
(
false
)
mMayHaveSystemGroupListeners
(
false
)
mMayHaveTouchEventListener
(
false
)
mMayHaveMouseEnterLeaveEventListener
(
false
)
mMayHavePointerEnterLeaveEventListener
(
false
)
mMayHaveKeyEventListener
(
false
)
mMayHaveInputOrCompositionEventListener
(
false
)
mMayHaveSelectionChangeEventListener
(
false
)
mClearingListeners
(
false
)
mIsMainThreadELM
(
NS_IsMainThread
(
)
)
{
static_assert
(
sizeof
(
EventListenerManagerBase
)
=
=
sizeof
(
uint32_t
)
"
Keep
the
size
of
EventListenerManagerBase
size
compact
!
"
)
;
}
EventListenerManager
:
:
EventListenerManager
(
EventTarget
*
aTarget
)
:
EventListenerManagerBase
(
)
mTarget
(
aTarget
)
{
NS_ASSERTION
(
aTarget
"
unexpected
null
pointer
"
)
;
if
(
mIsMainThreadELM
)
{
+
+
sMainThreadCreatedCount
;
}
}
EventListenerManager
:
:
~
EventListenerManager
(
)
{
NS_ASSERTION
(
!
mTarget
"
didn
'
t
call
Disconnect
"
)
;
RemoveAllListeners
(
)
;
}
void
EventListenerManager
:
:
RemoveAllListeners
(
)
{
if
(
mClearingListeners
)
{
return
;
}
mClearingListeners
=
true
;
mListeners
.
Clear
(
)
;
mClearingListeners
=
false
;
}
void
EventListenerManager
:
:
Shutdown
(
)
{
Event
:
:
Shutdown
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
EventListenerManager
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
EventListenerManager
Release
)
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
EventListenerManager
:
:
Listener
&
aField
const
char
*
aName
unsigned
aFlags
)
{
if
(
MOZ_UNLIKELY
(
aCallback
.
WantDebugInfo
(
)
)
)
{
nsAutoCString
name
;
name
.
AppendASCII
(
aName
)
;
if
(
aField
.
mTypeAtom
)
{
name
.
AppendLiteral
(
"
event
=
"
)
;
name
.
Append
(
nsAtomCString
(
aField
.
mTypeAtom
)
)
;
name
.
AppendLiteral
(
"
listenerType
=
"
)
;
name
.
AppendInt
(
aField
.
mListenerType
)
;
name
.
AppendLiteral
(
"
"
)
;
}
CycleCollectionNoteChild
(
aCallback
aField
.
mListener
.
GetISupports
(
)
name
.
get
(
)
aFlags
)
;
}
else
{
CycleCollectionNoteChild
(
aCallback
aField
.
mListener
.
GetISupports
(
)
aName
aFlags
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
EventListenerManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
EventListenerManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListeners
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
EventListenerManager
)
tmp
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
nsPIDOMWindowInner
*
EventListenerManager
:
:
GetInnerWindowForTarget
(
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
mTarget
)
;
if
(
node
)
{
return
node
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
;
return
window
;
}
already_AddRefed
<
nsPIDOMWindowInner
>
EventListenerManager
:
:
GetTargetAsInnerWindow
(
)
const
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mTarget
)
;
return
window
.
forget
(
)
;
}
void
EventListenerManager
:
:
AddEventListenerInternal
(
EventListenerHolder
aListenerHolder
EventMessage
aEventMessage
nsAtom
*
aTypeAtom
const
EventListenerFlags
&
aFlags
bool
aHandler
bool
aAllEvents
)
{
MOZ_ASSERT
(
(
aEventMessage
&
&
aTypeAtom
)
|
|
aAllEvents
"
Missing
type
"
)
;
if
(
!
aListenerHolder
|
|
mClearingListeners
)
{
return
;
}
Listener
*
listener
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mListenerIsHandler
=
=
aHandler
&
&
listener
-
>
mFlags
.
EqualsForAddition
(
aFlags
)
&
&
EVENT_TYPE_EQUALS
(
listener
aEventMessage
aTypeAtom
aAllEvents
)
&
&
listener
-
>
mListener
=
=
aListenerHolder
)
{
return
;
}
}
mNoListenerForEvent
=
eVoidEvent
;
mNoListenerForEventAtom
=
nullptr
;
listener
=
aAllEvents
?
mListeners
.
InsertElementAt
(
0
)
:
mListeners
.
AppendElement
(
)
;
listener
-
>
mEventMessage
=
aEventMessage
;
listener
-
>
mTypeAtom
=
aTypeAtom
;
listener
-
>
mFlags
=
aFlags
;
listener
-
>
mListenerIsHandler
=
aHandler
;
listener
-
>
mHandlerIsString
=
false
;
listener
-
>
mAllEvents
=
aAllEvents
;
listener
-
>
mIsChrome
=
mIsMainThreadELM
&
&
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
;
if
(
aFlags
.
mListenerIsJSListener
)
{
MOZ_ASSERT
(
!
aListenerHolder
.
HasWebIDLCallback
(
)
)
;
listener
-
>
mListenerType
=
Listener
:
:
eJSEventListener
;
}
else
if
(
aListenerHolder
.
HasWebIDLCallback
(
)
)
{
listener
-
>
mListenerType
=
Listener
:
:
eWebIDLListener
;
}
else
{
listener
-
>
mListenerType
=
Listener
:
:
eNativeListener
;
}
listener
-
>
mListener
=
std
:
:
move
(
aListenerHolder
)
;
if
(
aFlags
.
mInSystemGroup
)
{
mMayHaveSystemGroupListeners
=
true
;
}
if
(
aFlags
.
mCapture
)
{
mMayHaveCapturingListeners
=
true
;
}
if
(
aEventMessage
=
=
eAfterPaint
)
{
mMayHavePaintEventListener
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
window
-
>
SetHasPaintEventListeners
(
)
;
}
}
else
if
(
aEventMessage
>
=
eLegacyMutationEventFirst
&
&
aEventMessage
<
=
eLegacyMutationEventLast
)
{
mMayHaveMutationListeners
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eMutationEvent
)
;
if
(
aEventMessage
=
=
eLegacyAttrModified
)
{
doc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eDOMAttrModifiedEvent
)
;
}
}
window
-
>
SetMutationListeners
(
(
aEventMessage
=
=
eLegacySubtreeModified
)
?
kAllMutationBits
:
MutationBitForEventType
(
aEventMessage
)
)
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondeviceorientation
)
{
EnableDevice
(
eDeviceOrientation
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onabsolutedeviceorientation
)
{
EnableDevice
(
eAbsoluteDeviceOrientation
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondeviceproximity
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onuserproximity
)
{
EnableDevice
(
eDeviceProximity
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondevicelight
)
{
EnableDevice
(
eDeviceLight
)
;
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ondevicemotion
)
{
EnableDevice
(
eDeviceMotion
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onorientationchange
)
{
EnableDevice
(
eOrientationChange
)
;
#
endif
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchstart
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchend
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchmove
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
ontouchcancel
)
{
mMayHaveTouchEventListener
=
true
;
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
;
if
(
window
&
&
!
aFlags
.
mInSystemGroup
)
{
window
-
>
SetHasTouchEventListeners
(
)
;
}
}
else
if
(
aEventMessage
>
=
ePointerEventFirst
&
&
aEventMessage
<
=
ePointerEventLast
)
{
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
;
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onpointerenter
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onpointerleave
)
{
mMayHavePointerEnterLeaveEventListener
=
true
;
if
(
window
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocument
>
d
=
window
-
>
GetExtantDoc
(
)
;
NS_WARNING_ASSERTION
(
!
nsContentUtils
:
:
IsChromeDoc
(
d
)
"
Please
do
not
use
pointerenter
/
leave
events
in
chrome
.
"
"
They
are
slower
than
pointerover
/
out
!
"
)
;
#
endif
window
-
>
SetHasPointerEnterLeaveEventListeners
(
)
;
}
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onmouseenter
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onmouseleave
)
{
mMayHaveMouseEnterLeaveEventListener
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocument
>
d
=
window
-
>
GetExtantDoc
(
)
;
NS_WARNING_ASSERTION
(
!
nsContentUtils
:
:
IsChromeDoc
(
d
)
"
Please
do
not
use
mouseenter
/
leave
events
in
chrome
.
"
"
They
are
slower
than
mouseover
/
out
!
"
)
;
#
endif
window
-
>
SetHasMouseEnterLeaveEventListeners
(
)
;
}
}
else
if
(
aEventMessage
>
=
eGamepadEventFirst
&
&
aEventMessage
<
=
eGamepadEventLast
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
window
-
>
SetHasGamepadEventListener
(
)
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onkeydown
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onkeypress
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
onkeyup
)
{
if
(
!
aFlags
.
mInSystemGroup
)
{
mMayHaveKeyEventListener
=
true
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
oncompositionend
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
oncompositionstart
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
oncompositionupdate
|
|
aTypeAtom
=
=
nsGkAtoms
:
:
oninput
)
{
if
(
!
aFlags
.
mInSystemGroup
)
{
mMayHaveInputOrCompositionEventListener
=
true
;
}
}
else
if
(
aEventMessage
=
=
eSelectionChange
)
{
mMayHaveSelectionChangeEventListener
=
true
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
window
-
>
SetHasSelectionChangeEventListeners
(
)
;
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onstart
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
SetDocumentAndPageUseCounter
(
eUseCounter_custom_onstart
)
;
}
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onbounce
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
SetDocumentAndPageUseCounter
(
eUseCounter_custom_onbounce
)
;
}
}
}
else
if
(
aTypeAtom
=
=
nsGkAtoms
:
:
onfinish
)
{
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindowForTarget
(
)
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
SetDocumentAndPageUseCounter
(
eUseCounter_custom_onfinish
)
;
}
}
}
if
(
IsApzAwareListener
(
listener
)
)
{
ProcessApzAwareEventListenerAdd
(
)
;
}
if
(
mTarget
)
{
mTarget
-
>
EventListenerAdded
(
aTypeAtom
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aTypeAtom
)
;
}
}
void
EventListenerManager
:
:
ProcessApzAwareEventListenerAdd
(
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
mTarget
)
;
if
(
node
)
{
node
-
>
SetMayBeApzAware
(
)
;
}
nsIDocument
*
doc
=
nullptr
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
}
if
(
!
doc
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
if
(
!
doc
)
{
if
(
nsCOMPtr
<
DOMEventTargetHelper
>
helper
=
do_QueryInterface
(
mTarget
)
)
{
if
(
nsPIDOMWindowInner
*
window
=
helper
-
>
GetOwner
(
)
)
{
doc
=
window
-
>
GetExtantDoc
(
)
;
}
}
}
if
(
doc
&
&
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
nsIPresShell
*
ps
=
doc
-
>
GetShell
(
)
;
if
(
ps
)
{
nsIFrame
*
f
=
ps
-
>
GetRootFrame
(
)
;
if
(
f
)
{
f
-
>
SchedulePaint
(
)
;
}
}
}
}
bool
EventListenerManager
:
:
IsDeviceType
(
EventMessage
aEventMessage
)
{
switch
(
aEventMessage
)
{
case
eDeviceOrientation
:
case
eAbsoluteDeviceOrientation
:
case
eDeviceMotion
:
case
eDeviceLight
:
case
eDeviceProximity
:
case
eUserProximity
:
#
if
defined
(
MOZ_WIDGET_ANDROID
)
case
eOrientationChange
:
#
endif
return
true
;
default
:
break
;
}
return
false
;
}
void
EventListenerManager
:
:
EnableDevice
(
EventMessage
aEventMessage
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
switch
(
aEventMessage
)
{
case
eDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
EnableDeviceSensor
(
SENSOR_GAME_ROTATION_VECTOR
)
;
window
-
>
EnableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
else
window
-
>
EnableDeviceSensor
(
SENSOR_ORIENTATION
)
;
#
endif
break
;
case
eAbsoluteDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
EnableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
else
window
-
>
EnableDeviceSensor
(
SENSOR_ORIENTATION
)
;
#
endif
break
;
case
eDeviceProximity
:
case
eUserProximity
:
window
-
>
EnableDeviceSensor
(
SENSOR_PROXIMITY
)
;
break
;
case
eDeviceLight
:
window
-
>
EnableDeviceSensor
(
SENSOR_LIGHT
)
;
break
;
case
eDeviceMotion
:
window
-
>
EnableDeviceSensor
(
SENSOR_ACCELERATION
)
;
window
-
>
EnableDeviceSensor
(
SENSOR_LINEAR_ACCELERATION
)
;
window
-
>
EnableDeviceSensor
(
SENSOR_GYROSCOPE
)
;
break
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
case
eOrientationChange
:
window
-
>
EnableOrientationChangeListener
(
)
;
break
;
#
endif
default
:
NS_WARNING
(
"
Enabling
an
unknown
device
sensor
.
"
)
;
break
;
}
}
void
EventListenerManager
:
:
DisableDevice
(
EventMessage
aEventMessage
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetTargetAsInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
switch
(
aEventMessage
)
{
case
eDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
DisableDeviceSensor
(
SENSOR_GAME_ROTATION_VECTOR
)
;
window
-
>
DisableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
endif
window
-
>
DisableDeviceSensor
(
SENSOR_ORIENTATION
)
;
break
;
case
eAbsoluteDeviceOrientation
:
#
ifdef
MOZ_WIDGET_ANDROID
window
-
>
DisableDeviceSensor
(
SENSOR_ROTATION_VECTOR
)
;
#
endif
window
-
>
DisableDeviceSensor
(
SENSOR_ORIENTATION
)
;
break
;
case
eDeviceMotion
:
window
-
>
DisableDeviceSensor
(
SENSOR_ACCELERATION
)
;
window
-
>
DisableDeviceSensor
(
SENSOR_LINEAR_ACCELERATION
)
;
window
-
>
DisableDeviceSensor
(
SENSOR_GYROSCOPE
)
;
break
;
case
eDeviceProximity
:
case
eUserProximity
:
window
-
>
DisableDeviceSensor
(
SENSOR_PROXIMITY
)
;
break
;
case
eDeviceLight
:
window
-
>
DisableDeviceSensor
(
SENSOR_LIGHT
)
;
break
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
case
eOrientationChange
:
window
-
>
DisableOrientationChangeListener
(
)
;
break
;
#
endif
default
:
NS_WARNING
(
"
Disabling
an
unknown
device
sensor
.
"
)
;
break
;
}
}
void
EventListenerManager
:
:
NotifyEventListenerRemoved
(
nsAtom
*
aUserType
)
{
mNoListenerForEvent
=
eVoidEvent
;
mNoListenerForEventAtom
=
nullptr
;
if
(
mTarget
)
{
mTarget
-
>
EventListenerRemoved
(
aUserType
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aUserType
)
;
}
}
void
EventListenerManager
:
:
RemoveEventListenerInternal
(
EventListenerHolder
aListenerHolder
EventMessage
aEventMessage
nsAtom
*
aUserType
const
EventListenerFlags
&
aFlags
bool
aAllEvents
)
{
if
(
!
aListenerHolder
|
|
!
aEventMessage
|
|
mClearingListeners
)
{
return
;
}
Listener
*
listener
;
uint32_t
count
=
mListeners
.
Length
(
)
;
bool
deviceType
=
IsDeviceType
(
aEventMessage
)
;
RefPtr
<
EventListenerManager
>
kungFuDeathGrip
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
EVENT_TYPE_EQUALS
(
listener
aEventMessage
aUserType
aAllEvents
)
)
{
if
(
listener
-
>
mListener
=
=
aListenerHolder
&
&
listener
-
>
mFlags
.
EqualsForRemoval
(
aFlags
)
)
{
mListeners
.
RemoveElementAt
(
i
)
;
NotifyEventListenerRemoved
(
aUserType
)
;
if
(
!
aAllEvents
&
&
deviceType
)
{
DisableDevice
(
aEventMessage
)
;
}
return
;
}
}
}
}
bool
EventListenerManager
:
:
ListenerCanHandle
(
const
Listener
*
aListener
const
WidgetEvent
*
aEvent
EventMessage
aEventMessage
)
const
{
MOZ_ASSERT
(
aEventMessage
=
=
aEvent
-
>
mMessage
|
|
aEventMessage
=
=
GetLegacyEventMessage
(
aEvent
-
>
mMessage
)
"
aEvent
and
aEventMessage
should
agree
modulo
legacyness
"
)
;
if
(
aListener
-
>
mListenerType
=
=
Listener
:
:
eNoListener
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
aListener
-
>
mAllEvents
)
)
{
return
true
;
}
if
(
aEvent
-
>
mMessage
=
=
eUnidentifiedEvent
)
{
return
aListener
-
>
mTypeAtom
=
=
aEvent
-
>
mSpecifiedEventType
;
}
if
(
MOZ_UNLIKELY
(
!
nsContentUtils
:
:
IsUnprefixedFullscreenApiEnabled
(
)
&
&
aEvent
-
>
IsTrusted
(
)
&
&
(
aEventMessage
=
=
eFullscreenChange
|
|
aEventMessage
=
=
eFullscreenError
)
)
)
{
if
(
!
aEvent
-
>
mFlags
.
mInSystemGroup
&
&
!
aListener
-
>
mIsChrome
)
{
return
false
;
}
}
MOZ_ASSERT
(
mIsMainThreadELM
)
;
return
aListener
-
>
mEventMessage
=
=
aEventMessage
;
}
static
bool
DefaultToPassiveTouchListeners
(
)
{
static
bool
sDefaultToPassiveTouchListeners
=
false
;
static
bool
sIsPrefCached
=
false
;
if
(
!
sIsPrefCached
)
{
sIsPrefCached
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sDefaultToPassiveTouchListeners
"
dom
.
event
.
default_to_passive_touch_listeners
"
)
;
}
return
sDefaultToPassiveTouchListeners
;
}
void
EventListenerManager
:
:
AddEventListenerByType
(
EventListenerHolder
aListenerHolder
const
nsAString
&
aType
const
EventListenerFlags
&
aFlags
const
Optional
<
bool
>
&
aPassive
)
{
RefPtr
<
nsAtom
>
atom
;
EventMessage
message
=
GetEventMessageAndAtomForListener
(
aType
getter_AddRefs
(
atom
)
)
;
EventListenerFlags
flags
=
aFlags
;
if
(
aPassive
.
WasPassed
(
)
)
{
flags
.
mPassive
=
aPassive
.
Value
(
)
;
}
else
if
(
(
message
=
=
eTouchStart
|
|
message
=
=
eTouchMove
)
&
&
mIsMainThreadELM
&
&
DefaultToPassiveTouchListeners
(
)
)
{
nsCOMPtr
<
nsINode
>
node
;
nsCOMPtr
<
nsPIDOMWindowInner
>
win
;
if
(
(
win
=
GetTargetAsInnerWindow
(
)
)
|
|
(
(
node
=
do_QueryInterface
(
mTarget
)
)
&
&
(
node
=
=
node
-
>
OwnerDoc
(
)
|
|
node
=
=
node
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
|
|
node
=
=
node
-
>
OwnerDoc
(
)
-
>
GetBody
(
)
)
)
)
{
flags
.
mPassive
=
true
;
}
}
AddEventListenerInternal
(
std
:
:
move
(
aListenerHolder
)
message
atom
flags
)
;
}
void
EventListenerManager
:
:
RemoveEventListenerByType
(
EventListenerHolder
aListenerHolder
const
nsAString
&
aType
const
EventListenerFlags
&
aFlags
)
{
RefPtr
<
nsAtom
>
atom
;
EventMessage
message
=
GetEventMessageAndAtomForListener
(
aType
getter_AddRefs
(
atom
)
)
;
RemoveEventListenerInternal
(
std
:
:
move
(
aListenerHolder
)
message
atom
aFlags
)
;
}
EventListenerManager
:
:
Listener
*
EventListenerManager
:
:
FindEventHandler
(
EventMessage
aEventMessage
nsAtom
*
aTypeAtom
)
{
Listener
*
listener
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mListenerIsHandler
&
&
EVENT_TYPE_EQUALS
(
listener
aEventMessage
aTypeAtom
false
)
)
{
return
listener
;
}
}
return
nullptr
;
}
EventListenerManager
:
:
Listener
*
EventListenerManager
:
:
SetEventHandlerInternal
(
nsAtom
*
aName
const
TypedEventHandler
&
aTypedHandler
bool
aPermitUntrustedEvents
)
{
MOZ_ASSERT
(
aName
)
;
EventMessage
eventMessage
=
GetEventMessage
(
aName
)
;
Listener
*
listener
=
FindEventHandler
(
eventMessage
aName
)
;
if
(
!
listener
)
{
EventListenerFlags
flags
;
flags
.
mListenerIsJSListener
=
true
;
nsCOMPtr
<
JSEventHandler
>
jsEventHandler
;
NS_NewJSEventHandler
(
mTarget
aName
aTypedHandler
getter_AddRefs
(
jsEventHandler
)
)
;
AddEventListenerInternal
(
EventListenerHolder
(
jsEventHandler
)
eventMessage
aName
flags
true
)
;
listener
=
FindEventHandler
(
eventMessage
aName
)
;
}
else
{
JSEventHandler
*
jsEventHandler
=
listener
-
>
GetJSEventHandler
(
)
;
MOZ_ASSERT
(
jsEventHandler
"
How
can
we
have
an
event
handler
with
no
JSEventHandler
?
"
)
;
bool
same
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
=
=
aTypedHandler
;
jsEventHandler
-
>
SetHandler
(
aTypedHandler
)
;
if
(
mTarget
&
&
!
same
)
{
mTarget
-
>
EventListenerRemoved
(
aName
)
;
mTarget
-
>
EventListenerAdded
(
aName
)
;
}
if
(
mIsMainThreadELM
&
&
mTarget
)
{
EventListenerService
:
:
NotifyAboutMainThreadListenerChange
(
mTarget
aName
)
;
}
}
listener
-
>
mHandlerIsString
=
!
aTypedHandler
.
HasEventHandler
(
)
;
if
(
aPermitUntrustedEvents
)
{
listener
-
>
mFlags
.
mAllowUntrustedEvents
=
true
;
}
return
listener
;
}
nsresult
EventListenerManager
:
:
SetEventHandler
(
nsAtom
*
aName
const
nsAString
&
aBody
bool
aDeferCompilation
bool
aPermitUntrustedEvents
Element
*
aElement
)
{
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsIScriptGlobalObject
>
global
=
GetScriptGlobalAndDocument
(
getter_AddRefs
(
doc
)
)
;
if
(
!
global
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
if
(
doc
)
{
if
(
doc
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
rv
=
doc
-
>
NodePrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
unsigned
lineNum
=
0
;
unsigned
columnNum
=
0
;
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
if
(
cx
&
&
!
JS
:
:
DescribeScriptedCaller
(
cx
nullptr
&
lineNum
&
columnNum
)
)
{
JS_ClearPendingException
(
cx
)
;
}
if
(
csp
)
{
bool
allowsInlineScript
=
true
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_SCRIPT
EmptyString
(
)
true
aElement
nullptr
aBody
lineNum
columnNum
&
allowsInlineScript
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
allowsInlineScript
)
{
return
NS_OK
;
}
}
}
if
(
NS_FAILED
(
global
-
>
EnsureScriptEnvironment
(
)
)
)
{
NS_WARNING
(
"
Failed
to
setup
script
environment
for
this
language
"
)
;
}
nsIScriptContext
*
context
=
global
-
>
GetScriptContext
(
)
;
NS_ENSURE_TRUE
(
context
NS_ERROR_FAILURE
)
;
NS_ENSURE_STATE
(
global
-
>
GetGlobalJSObject
(
)
)
;
Listener
*
listener
=
SetEventHandlerInternal
(
aName
TypedEventHandler
(
)
aPermitUntrustedEvents
)
;
if
(
!
aDeferCompilation
)
{
return
CompileEventHandlerInternal
(
listener
&
aBody
aElement
)
;
}
return
NS_OK
;
}
void
EventListenerManager
:
:
RemoveEventHandler
(
nsAtom
*
aName
)
{
if
(
mClearingListeners
)
{
return
;
}
EventMessage
eventMessage
=
GetEventMessage
(
aName
)
;
Listener
*
listener
=
FindEventHandler
(
eventMessage
aName
)
;
if
(
listener
)
{
mListeners
.
RemoveElementAt
(
uint32_t
(
listener
-
&
mListeners
.
ElementAt
(
0
)
)
)
;
NotifyEventListenerRemoved
(
aName
)
;
if
(
IsDeviceType
(
eventMessage
)
)
{
DisableDevice
(
eventMessage
)
;
}
}
}
nsresult
EventListenerManager
:
:
CompileEventHandlerInternal
(
Listener
*
aListener
const
nsAString
*
aBody
Element
*
aElement
)
{
MOZ_ASSERT
(
aListener
-
>
GetJSEventHandler
(
)
)
;
MOZ_ASSERT
(
aListener
-
>
mHandlerIsString
"
Why
are
we
compiling
a
non
-
string
JS
listener
?
"
)
;
JSEventHandler
*
jsEventHandler
=
aListener
-
>
GetJSEventHandler
(
)
;
MOZ_ASSERT
(
!
jsEventHandler
-
>
GetTypedEventHandler
(
)
.
HasEventHandler
(
)
"
What
is
there
to
compile
?
"
)
;
nsresult
result
=
NS_OK
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsIScriptGlobalObject
>
global
=
GetScriptGlobalAndDocument
(
getter_AddRefs
(
doc
)
)
;
NS_ENSURE_STATE
(
global
)
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
global
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
nsAtom
>
typeAtom
=
aListener
-
>
mTypeAtom
;
nsAtom
*
attrName
=
typeAtom
;
aListener
-
>
mHandlerIsString
=
false
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
mTarget
)
;
MOZ_ASSERT
(
element
|
|
aBody
"
Where
will
we
get
our
body
?
"
)
;
nsAutoString
handlerBody
;
const
nsAString
*
body
=
aBody
;
if
(
!
aBody
)
{
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGLoad
)
{
attrName
=
nsGkAtoms
:
:
onload
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGUnload
)
{
attrName
=
nsGkAtoms
:
:
onunload
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGResize
)
{
attrName
=
nsGkAtoms
:
:
onresize
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGScroll
)
{
attrName
=
nsGkAtoms
:
:
onscroll
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onSVGZoom
)
{
attrName
=
nsGkAtoms
:
:
onzoom
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onbeginEvent
)
{
attrName
=
nsGkAtoms
:
:
onbegin
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onrepeatEvent
)
{
attrName
=
nsGkAtoms
:
:
onrepeat
;
}
else
if
(
aListener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onendEvent
)
{
attrName
=
nsGkAtoms
:
:
onend
;
}
element
-
>
GetAttr
(
kNameSpaceID_None
attrName
handlerBody
)
;
body
=
&
handlerBody
;
aElement
=
element
;
}
aListener
=
nullptr
;
nsAutoCString
url
(
NS_LITERAL_CSTRING
(
"
-
moz
-
evil
:
lying
-
event
-
listener
"
)
)
;
MOZ_ASSERT
(
body
)
;
MOZ_ASSERT
(
aElement
)
;
nsIURI
*
uri
=
aElement
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
uri
-
>
GetSpec
(
url
)
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
mTarget
)
;
uint32_t
argCount
;
const
char
*
*
argNames
;
nsContentUtils
:
:
GetEventArgNames
(
aElement
-
>
GetNameSpaceID
(
)
typeAtom
win
&
argCount
&
argNames
)
;
JS
:
:
Rooted
<
JSObject
*
>
wrapScope
(
cx
global
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
)
;
{
JSAutoRealm
ar
(
cx
wrapScope
)
;
nsresult
rv
=
nsContentUtils
:
:
WrapNative
(
cx
mTarget
&
v
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
target
(
cx
&
v
.
toObject
(
)
)
;
JSAutoRealm
ar
(
cx
target
)
;
JS
:
:
AutoObjectVector
scopeChain
(
cx
)
;
if
(
!
nsJSUtils
:
:
GetScopeChainForElement
(
cx
element
scopeChain
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsDependentAtomString
str
(
attrName
)
;
JS
:
:
Rooted
<
JSString
*
>
jsStr
(
cx
JS_NewUCStringCopyN
(
cx
str
.
BeginReading
(
)
str
.
Length
(
)
)
)
;
NS_ENSURE_TRUE
(
jsStr
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
NS_WARN_IF
(
!
GetOrCreateDOMReflector
(
cx
aElement
&
v
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
CompileOptions
options
(
cx
)
;
options
.
setIntroductionType
(
"
eventHandler
"
)
.
setFileAndLine
(
url
.
get
(
)
0
)
.
setElement
(
&
v
.
toObject
(
)
)
.
setElementAttributeName
(
jsStr
)
;
JS
:
:
Rooted
<
JSObject
*
>
handler
(
cx
)
;
result
=
nsJSUtils
:
:
CompileFunction
(
jsapi
scopeChain
options
nsAtomCString
(
typeAtom
)
argCount
argNames
*
body
handler
.
address
(
)
)
;
NS_ENSURE_SUCCESS
(
result
result
)
;
NS_ENSURE_TRUE
(
handler
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
js
:
:
IsObjectInContextCompartment
(
handler
cx
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
handlerGlobal
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
if
(
jsEventHandler
-
>
EventName
(
)
=
=
nsGkAtoms
:
:
onerror
&
&
win
)
{
RefPtr
<
OnErrorEventHandlerNonNull
>
handlerCallback
=
new
OnErrorEventHandlerNonNull
(
static_cast
<
JSContext
*
>
(
nullptr
)
handler
handlerGlobal
nullptr
)
;
jsEventHandler
-
>
SetHandler
(
handlerCallback
)
;
}
else
if
(
jsEventHandler
-
>
EventName
(
)
=
=
nsGkAtoms
:
:
onbeforeunload
&
&
win
)
{
RefPtr
<
OnBeforeUnloadEventHandlerNonNull
>
handlerCallback
=
new
OnBeforeUnloadEventHandlerNonNull
(
static_cast
<
JSContext
*
>
(
nullptr
)
handler
handlerGlobal
nullptr
)
;
jsEventHandler
-
>
SetHandler
(
handlerCallback
)
;
}
else
{
RefPtr
<
EventHandlerNonNull
>
handlerCallback
=
new
EventHandlerNonNull
(
static_cast
<
JSContext
*
>
(
nullptr
)
handler
handlerGlobal
nullptr
)
;
jsEventHandler
-
>
SetHandler
(
handlerCallback
)
;
}
return
result
;
}
nsresult
EventListenerManager
:
:
HandleEventSubType
(
Listener
*
aListener
Event
*
aDOMEvent
EventTarget
*
aCurrentTarget
)
{
nsresult
result
=
NS_OK
;
EventListenerHolder
listenerHolder
(
aListener
-
>
mListener
.
Clone
(
)
)
;
if
(
(
aListener
-
>
mListenerType
=
=
Listener
:
:
eJSEventListener
)
&
&
aListener
-
>
mHandlerIsString
)
{
result
=
CompileEventHandlerInternal
(
aListener
nullptr
nullptr
)
;
aListener
=
nullptr
;
}
if
(
NS_SUCCEEDED
(
result
)
)
{
nsAutoMicroTask
mt
;
if
(
listenerHolder
.
HasWebIDLCallback
(
)
)
{
ErrorResult
rv
;
listenerHolder
.
GetWebIDLCallback
(
)
-
>
HandleEvent
(
aCurrentTarget
*
aDOMEvent
rv
)
;
result
=
rv
.
StealNSResult
(
)
;
}
else
{
result
=
listenerHolder
.
GetXPCOMCallback
(
)
-
>
HandleEvent
(
aDOMEvent
)
;
}
}
return
result
;
}
EventMessage
EventListenerManager
:
:
GetLegacyEventMessage
(
EventMessage
aEventMessage
)
const
{
if
(
mIsMainThreadELM
)
{
if
(
IsWebkitPrefixSupportEnabled
(
)
)
{
if
(
aEventMessage
=
=
eTransitionEnd
)
{
return
eWebkitTransitionEnd
;
}
if
(
aEventMessage
=
=
eAnimationStart
)
{
return
eWebkitAnimationStart
;
}
if
(
aEventMessage
=
=
eAnimationEnd
)
{
return
eWebkitAnimationEnd
;
}
if
(
aEventMessage
=
=
eAnimationIteration
)
{
return
eWebkitAnimationIteration
;
}
}
}
switch
(
aEventMessage
)
{
case
eFullscreenChange
:
return
eMozFullscreenChange
;
case
eFullscreenError
:
return
eMozFullscreenError
;
default
:
return
aEventMessage
;
}
}
EventMessage
EventListenerManager
:
:
GetEventMessage
(
nsAtom
*
aEventName
)
const
{
if
(
mIsMainThreadELM
)
{
return
nsContentUtils
:
:
GetEventMessage
(
aEventName
)
;
}
return
eUnidentifiedEvent
;
}
EventMessage
EventListenerManager
:
:
GetEventMessageAndAtomForListener
(
const
nsAString
&
aType
nsAtom
*
*
aAtom
)
{
if
(
mIsMainThreadELM
)
{
return
nsContentUtils
:
:
GetEventMessageAndAtomForListener
(
aType
aAtom
)
;
}
*
aAtom
=
NS_Atomize
(
NS_LITERAL_STRING
(
"
on
"
)
+
aType
)
.
take
(
)
;
return
eUnidentifiedEvent
;
}
already_AddRefed
<
nsPIDOMWindowInner
>
EventListenerManager
:
:
WindowFromListener
(
Listener
*
aListener
bool
aItemInShadowTree
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
innerWindow
;
if
(
!
aItemInShadowTree
)
{
if
(
aListener
-
>
mListener
.
HasWebIDLCallback
(
)
)
{
CallbackObject
*
callback
=
aListener
-
>
mListener
.
GetWebIDLCallback
(
)
;
nsIGlobalObject
*
global
=
nullptr
;
if
(
callback
)
{
global
=
callback
-
>
IncumbentGlobalOrNull
(
)
;
}
if
(
global
)
{
innerWindow
=
global
-
>
AsInnerWindow
(
)
;
}
}
else
{
innerWindow
=
GetInnerWindowForTarget
(
)
;
}
}
return
innerWindow
.
forget
(
)
;
}
void
EventListenerManager
:
:
HandleEventInternal
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
Event
*
*
aDOMEvent
EventTarget
*
aCurrentTarget
nsEventStatus
*
aEventStatus
bool
aItemInShadowTree
)
{
if
(
!
aEvent
-
>
DefaultPrevented
(
)
&
&
*
aEventStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
aEvent
-
>
PreventDefault
(
)
;
}
Maybe
<
nsAutoPopupStatePusher
>
popupStatePusher
;
if
(
mIsMainThreadELM
)
{
popupStatePusher
.
emplace
(
Event
:
:
GetEventPopupControlState
(
aEvent
*
aDOMEvent
)
)
;
}
bool
hasListener
=
false
;
bool
hasListenerForCurrentGroup
=
false
;
bool
usingLegacyMessage
=
false
;
bool
hasRemovedListener
=
false
;
EventMessage
eventMessage
=
aEvent
-
>
mMessage
;
while
(
true
)
{
nsAutoTObserverArray
<
Listener
2
>
:
:
EndLimitedIterator
iter
(
mListeners
)
;
Maybe
<
EventMessageAutoOverride
>
legacyAutoOverride
;
while
(
iter
.
HasMore
(
)
)
{
if
(
aEvent
-
>
mFlags
.
mImmediatePropagationStopped
)
{
break
;
}
Listener
*
listener
=
&
iter
.
GetNext
(
)
;
if
(
ListenerCanHandle
(
listener
aEvent
eventMessage
)
)
{
hasListener
=
true
;
hasListenerForCurrentGroup
=
hasListenerForCurrentGroup
|
|
listener
-
>
mFlags
.
mInSystemGroup
=
=
aEvent
-
>
mFlags
.
mInSystemGroup
;
if
(
listener
-
>
IsListening
(
aEvent
)
&
&
(
aEvent
-
>
IsTrusted
(
)
|
|
listener
-
>
mFlags
.
mAllowUntrustedEvents
)
)
{
if
(
!
*
aDOMEvent
)
{
nsCOMPtr
<
EventTarget
>
et
=
aEvent
-
>
mOriginalTarget
;
RefPtr
<
Event
>
event
=
EventDispatcher
:
:
CreateEvent
(
et
aPresContext
aEvent
EmptyString
(
)
)
;
event
.
forget
(
aDOMEvent
)
;
}
if
(
*
aDOMEvent
)
{
if
(
!
aEvent
-
>
mCurrentTarget
)
{
aEvent
-
>
mCurrentTarget
=
aCurrentTarget
-
>
GetTargetForDOMEvent
(
)
;
if
(
!
aEvent
-
>
mCurrentTarget
)
{
break
;
}
}
if
(
usingLegacyMessage
&
&
!
legacyAutoOverride
)
{
legacyAutoOverride
.
emplace
(
*
aDOMEvent
eventMessage
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
needsEndEventMarker
=
false
;
if
(
mIsMainThreadELM
&
&
listener
-
>
mListenerType
!
=
Listener
:
:
eNativeListener
)
{
docShell
=
nsContentUtils
:
:
GetDocShellForEventTarget
(
mTarget
)
;
if
(
docShell
)
{
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
)
{
needsEndEventMarker
=
true
;
nsAutoString
typeStr
;
(
*
aDOMEvent
)
-
>
GetType
(
typeStr
)
;
uint16_t
phase
=
(
*
aDOMEvent
)
-
>
EventPhase
(
)
;
timelines
-
>
AddMarkerForDocShell
(
docShell
MakeUnique
<
EventTimelineMarker
>
(
typeStr
phase
MarkerTracingType
:
:
START
)
)
;
}
}
}
aEvent
-
>
mFlags
.
mInPassiveListener
=
listener
-
>
mFlags
.
mPassive
;
Maybe
<
Listener
>
listenerHolder
;
if
(
listener
-
>
mFlags
.
mOnce
)
{
listenerHolder
.
emplace
(
std
:
:
move
(
*
listener
)
)
;
listener
=
listenerHolder
.
ptr
(
)
;
hasRemovedListener
=
true
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
innerWindow
=
WindowFromListener
(
listener
aItemInShadowTree
)
;
mozilla
:
:
dom
:
:
Event
*
oldWindowEvent
=
nullptr
;
if
(
innerWindow
)
{
oldWindowEvent
=
innerWindow
-
>
SetEvent
(
*
aDOMEvent
)
;
}
nsresult
rv
=
HandleEventSubType
(
listener
*
aDOMEvent
aCurrentTarget
)
;
if
(
innerWindow
)
{
Unused
<
<
innerWindow
-
>
SetEvent
(
oldWindowEvent
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aEvent
-
>
mFlags
.
mExceptionWasRaised
=
true
;
}
aEvent
-
>
mFlags
.
mInPassiveListener
=
false
;
if
(
needsEndEventMarker
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
"
DOMEvent
"
MarkerTracingType
:
:
END
)
;
}
}
}
}
}
if
(
hasListenerForCurrentGroup
|
|
usingLegacyMessage
|
|
!
aEvent
-
>
IsTrusted
(
)
)
{
break
;
}
EventMessage
legacyEventMessage
=
GetLegacyEventMessage
(
eventMessage
)
;
if
(
legacyEventMessage
=
=
eventMessage
)
{
break
;
}
MOZ_ASSERT
(
GetLegacyEventMessage
(
legacyEventMessage
)
=
=
legacyEventMessage
"
Legacy
event
messages
should
not
themselves
have
legacy
versions
"
)
;
eventMessage
=
legacyEventMessage
;
usingLegacyMessage
=
true
;
}
aEvent
-
>
mCurrentTarget
=
nullptr
;
if
(
hasRemovedListener
)
{
mListeners
.
RemoveElementsBy
(
[
]
(
const
Listener
&
aListener
)
{
return
aListener
.
mListenerType
=
=
Listener
:
:
eNoListener
;
}
)
;
NotifyEventListenerRemoved
(
aEvent
-
>
mSpecifiedEventType
)
;
if
(
IsDeviceType
(
aEvent
-
>
mMessage
)
)
{
bool
hasAnyListener
=
false
;
nsAutoTObserverArray
<
Listener
2
>
:
:
ForwardIterator
iter
(
mListeners
)
;
while
(
iter
.
HasMore
(
)
)
{
Listener
*
listener
=
&
iter
.
GetNext
(
)
;
if
(
EVENT_TYPE_EQUALS
(
listener
aEvent
-
>
mMessage
aEvent
-
>
mSpecifiedEventType
false
)
)
{
hasAnyListener
=
true
;
break
;
}
}
if
(
!
hasAnyListener
)
{
DisableDevice
(
aEvent
-
>
mMessage
)
;
}
}
}
if
(
mIsMainThreadELM
&
&
!
hasListener
)
{
mNoListenerForEvent
=
aEvent
-
>
mMessage
;
mNoListenerForEventAtom
=
aEvent
-
>
mSpecifiedEventType
;
}
if
(
aEvent
-
>
DefaultPrevented
(
)
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
void
EventListenerManager
:
:
Disconnect
(
)
{
mTarget
=
nullptr
;
RemoveAllListeners
(
)
;
}
void
EventListenerManager
:
:
AddEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListenerHolder
bool
aUseCapture
bool
aWantsUntrusted
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
flags
.
mAllowUntrustedEvents
=
aWantsUntrusted
;
return
AddEventListenerByType
(
std
:
:
move
(
aListenerHolder
)
aType
flags
)
;
}
void
EventListenerManager
:
:
AddEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListenerHolder
const
dom
:
:
AddEventListenerOptionsOrBoolean
&
aOptions
bool
aWantsUntrusted
)
{
EventListenerFlags
flags
;
Optional
<
bool
>
passive
;
if
(
aOptions
.
IsBoolean
(
)
)
{
flags
.
mCapture
=
aOptions
.
GetAsBoolean
(
)
;
}
else
{
const
auto
&
options
=
aOptions
.
GetAsAddEventListenerOptions
(
)
;
flags
.
mCapture
=
options
.
mCapture
;
flags
.
mInSystemGroup
=
options
.
mMozSystemGroup
;
flags
.
mOnce
=
options
.
mOnce
;
if
(
options
.
mPassive
.
WasPassed
(
)
)
{
passive
.
Construct
(
options
.
mPassive
.
Value
(
)
)
;
}
}
flags
.
mAllowUntrustedEvents
=
aWantsUntrusted
;
return
AddEventListenerByType
(
std
:
:
move
(
aListenerHolder
)
aType
flags
passive
)
;
}
void
EventListenerManager
:
:
RemoveEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListenerHolder
bool
aUseCapture
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
RemoveEventListenerByType
(
std
:
:
move
(
aListenerHolder
)
aType
flags
)
;
}
void
EventListenerManager
:
:
RemoveEventListener
(
const
nsAString
&
aType
EventListenerHolder
aListenerHolder
const
dom
:
:
EventListenerOptionsOrBoolean
&
aOptions
)
{
EventListenerFlags
flags
;
if
(
aOptions
.
IsBoolean
(
)
)
{
flags
.
mCapture
=
aOptions
.
GetAsBoolean
(
)
;
}
else
{
const
auto
&
options
=
aOptions
.
GetAsEventListenerOptions
(
)
;
flags
.
mCapture
=
options
.
mCapture
;
flags
.
mInSystemGroup
=
options
.
mMozSystemGroup
;
}
RemoveEventListenerByType
(
std
:
:
move
(
aListenerHolder
)
aType
flags
)
;
}
void
EventListenerManager
:
:
AddListenerForAllEvents
(
EventListener
*
aDOMListener
bool
aUseCapture
bool
aWantsUntrusted
bool
aSystemEventGroup
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
flags
.
mAllowUntrustedEvents
=
aWantsUntrusted
;
flags
.
mInSystemGroup
=
aSystemEventGroup
;
AddEventListenerInternal
(
EventListenerHolder
(
aDOMListener
)
eAllEvents
nullptr
flags
false
true
)
;
}
void
EventListenerManager
:
:
RemoveListenerForAllEvents
(
EventListener
*
aDOMListener
bool
aUseCapture
bool
aSystemEventGroup
)
{
EventListenerFlags
flags
;
flags
.
mCapture
=
aUseCapture
;
flags
.
mInSystemGroup
=
aSystemEventGroup
;
RemoveEventListenerInternal
(
EventListenerHolder
(
aDOMListener
)
eAllEvents
nullptr
flags
true
)
;
}
bool
EventListenerManager
:
:
HasMutationListeners
(
)
{
if
(
mMayHaveMutationListeners
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mEventMessage
>
=
eLegacyMutationEventFirst
&
&
listener
-
>
mEventMessage
<
=
eLegacyMutationEventLast
)
{
return
true
;
}
}
}
return
false
;
}
uint32_t
EventListenerManager
:
:
MutationListenerBits
(
)
{
uint32_t
bits
=
0
;
if
(
mMayHaveMutationListeners
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mEventMessage
>
=
eLegacyMutationEventFirst
&
&
listener
-
>
mEventMessage
<
=
eLegacyMutationEventLast
)
{
if
(
listener
-
>
mEventMessage
=
=
eLegacySubtreeModified
)
{
return
kAllMutationBits
;
}
bits
|
=
MutationBitForEventType
(
listener
-
>
mEventMessage
)
;
}
}
}
return
bits
;
}
bool
EventListenerManager
:
:
HasListenersFor
(
const
nsAString
&
aEventName
)
const
{
RefPtr
<
nsAtom
>
atom
=
NS_Atomize
(
NS_LITERAL_STRING
(
"
on
"
)
+
aEventName
)
;
return
HasListenersFor
(
atom
)
;
}
bool
EventListenerManager
:
:
HasListenersFor
(
nsAtom
*
aEventNameWithOn
)
const
{
#
ifdef
DEBUG
nsAutoString
name
;
aEventNameWithOn
-
>
ToString
(
name
)
;
#
endif
NS_ASSERTION
(
StringBeginsWith
(
name
NS_LITERAL_STRING
(
"
on
"
)
)
"
Event
name
does
not
start
with
'
on
'
"
)
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mTypeAtom
=
=
aEventNameWithOn
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
HasListeners
(
)
const
{
return
!
mListeners
.
IsEmpty
(
)
;
}
nsresult
EventListenerManager
:
:
GetListenerInfo
(
nsCOMArray
<
nsIEventListenerInfo
>
*
aList
)
{
nsCOMPtr
<
EventTarget
>
target
=
mTarget
;
NS_ENSURE_STATE
(
target
)
;
aList
-
>
Clear
(
)
;
nsAutoTObserverArray
<
Listener
2
>
:
:
ForwardIterator
iter
(
mListeners
)
;
while
(
iter
.
HasMore
(
)
)
{
const
Listener
&
listener
=
iter
.
GetNext
(
)
;
if
(
listener
.
mListenerType
=
=
Listener
:
:
eJSEventListener
&
&
listener
.
mHandlerIsString
)
{
CompileEventHandlerInternal
(
const_cast
<
Listener
*
>
(
&
listener
)
nullptr
nullptr
)
;
}
nsAutoString
eventType
;
if
(
listener
.
mAllEvents
)
{
eventType
.
SetIsVoid
(
true
)
;
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eNoListener
)
{
continue
;
}
else
{
eventType
.
Assign
(
Substring
(
nsDependentAtomString
(
listener
.
mTypeAtom
)
2
)
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
callback
(
RootingCx
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
callbackGlobal
(
RootingCx
(
)
)
;
if
(
JSEventHandler
*
handler
=
listener
.
GetJSEventHandler
(
)
)
{
if
(
handler
-
>
GetTypedEventHandler
(
)
.
HasEventHandler
(
)
)
{
CallbackFunction
*
callbackFun
=
handler
-
>
GetTypedEventHandler
(
)
.
Ptr
(
)
;
callback
=
callbackFun
-
>
CallableOrNull
(
)
;
callbackGlobal
=
callbackFun
-
>
CallbackGlobalOrNull
(
)
;
if
(
!
callback
)
{
continue
;
}
}
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eWebIDLListener
)
{
EventListener
*
listenerCallback
=
listener
.
mListener
.
GetWebIDLCallback
(
)
;
callback
=
listenerCallback
-
>
CallbackOrNull
(
)
;
callbackGlobal
=
listenerCallback
-
>
CallbackGlobalOrNull
(
)
;
if
(
!
callback
)
{
continue
;
}
}
RefPtr
<
EventListenerInfo
>
info
=
new
EventListenerInfo
(
eventType
callback
callbackGlobal
listener
.
mFlags
.
mCapture
listener
.
mFlags
.
mAllowUntrustedEvents
listener
.
mFlags
.
mInSystemGroup
)
;
aList
-
>
AppendElement
(
info
.
forget
(
)
)
;
}
return
NS_OK
;
}
bool
EventListenerManager
:
:
HasUnloadListeners
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
listener
-
>
mEventMessage
=
=
eUnload
|
|
listener
-
>
mEventMessage
=
=
eBeforeUnload
)
{
return
true
;
}
}
return
false
;
}
void
EventListenerManager
:
:
SetEventHandler
(
nsAtom
*
aEventName
EventHandlerNonNull
*
aHandler
)
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
aEventName
)
;
return
;
}
SetEventHandlerInternal
(
aEventName
TypedEventHandler
(
aHandler
)
!
mIsMainThreadELM
|
|
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
}
void
EventListenerManager
:
:
SetEventHandler
(
OnErrorEventHandlerNonNull
*
aHandler
)
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
nsGkAtoms
:
:
onerror
)
;
return
;
}
bool
allowUntrusted
=
!
mIsMainThreadELM
|
|
!
nsContentUtils
:
:
IsCallerChrome
(
)
;
SetEventHandlerInternal
(
nsGkAtoms
:
:
onerror
TypedEventHandler
(
aHandler
)
allowUntrusted
)
;
}
void
EventListenerManager
:
:
SetEventHandler
(
OnBeforeUnloadEventHandlerNonNull
*
aHandler
)
{
if
(
!
aHandler
)
{
RemoveEventHandler
(
nsGkAtoms
:
:
onbeforeunload
)
;
return
;
}
SetEventHandlerInternal
(
nsGkAtoms
:
:
onbeforeunload
TypedEventHandler
(
aHandler
)
!
mIsMainThreadELM
|
|
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
}
const
TypedEventHandler
*
EventListenerManager
:
:
GetTypedEventHandler
(
nsAtom
*
aEventName
)
{
EventMessage
eventMessage
=
GetEventMessage
(
aEventName
)
;
Listener
*
listener
=
FindEventHandler
(
eventMessage
aEventName
)
;
if
(
!
listener
)
{
return
nullptr
;
}
JSEventHandler
*
jsEventHandler
=
listener
-
>
GetJSEventHandler
(
)
;
if
(
listener
-
>
mHandlerIsString
)
{
CompileEventHandlerInternal
(
listener
nullptr
nullptr
)
;
}
const
TypedEventHandler
&
typedHandler
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
;
return
typedHandler
.
HasEventHandler
(
)
?
&
typedHandler
:
nullptr
;
}
size_t
EventListenerManager
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mListeners
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
JSEventHandler
*
jsEventHandler
=
mListeners
.
ElementAt
(
i
)
.
GetJSEventHandler
(
)
;
if
(
jsEventHandler
)
{
n
+
=
jsEventHandler
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
void
EventListenerManager
:
:
MarkForCC
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
Listener
&
listener
=
mListeners
.
ElementAt
(
i
)
;
JSEventHandler
*
jsEventHandler
=
listener
.
GetJSEventHandler
(
)
;
if
(
jsEventHandler
)
{
const
TypedEventHandler
&
typedHandler
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
;
if
(
typedHandler
.
HasEventHandler
(
)
)
{
typedHandler
.
Ptr
(
)
-
>
MarkForCC
(
)
;
}
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eWebIDLListener
)
{
listener
.
mListener
.
GetWebIDLCallback
(
)
-
>
MarkForCC
(
)
;
}
}
if
(
mRefCnt
.
IsPurple
(
)
)
{
mRefCnt
.
RemovePurple
(
)
;
}
}
void
EventListenerManager
:
:
TraceListeners
(
JSTracer
*
aTrc
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
Listener
&
listener
=
mListeners
.
ElementAt
(
i
)
;
JSEventHandler
*
jsEventHandler
=
listener
.
GetJSEventHandler
(
)
;
if
(
jsEventHandler
)
{
const
TypedEventHandler
&
typedHandler
=
jsEventHandler
-
>
GetTypedEventHandler
(
)
;
if
(
typedHandler
.
HasEventHandler
(
)
)
{
mozilla
:
:
TraceScriptHolder
(
typedHandler
.
Ptr
(
)
aTrc
)
;
}
}
else
if
(
listener
.
mListenerType
=
=
Listener
:
:
eWebIDLListener
)
{
mozilla
:
:
TraceScriptHolder
(
listener
.
mListener
.
GetWebIDLCallback
(
)
aTrc
)
;
}
}
}
bool
EventListenerManager
:
:
HasNonSystemGroupListenersForUntrustedKeyEvents
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
!
listener
-
>
mFlags
.
mInSystemGroup
&
&
listener
-
>
mFlags
.
mAllowUntrustedEvents
&
&
(
listener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onkeydown
|
|
listener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onkeypress
|
|
listener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onkeyup
)
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
HasNonPassiveNonSystemGroupListenersForUntrustedKeyEvents
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
!
listener
-
>
mFlags
.
mPassive
&
&
!
listener
-
>
mFlags
.
mInSystemGroup
&
&
listener
-
>
mFlags
.
mAllowUntrustedEvents
&
&
(
listener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onkeydown
|
|
listener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onkeypress
|
|
listener
-
>
mTypeAtom
=
=
nsGkAtoms
:
:
onkeyup
)
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
HasApzAwareListeners
(
)
{
uint32_t
count
=
mListeners
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
Listener
*
listener
=
&
mListeners
.
ElementAt
(
i
)
;
if
(
IsApzAwareListener
(
listener
)
)
{
return
true
;
}
}
return
false
;
}
bool
EventListenerManager
:
:
IsApzAwareListener
(
Listener
*
aListener
)
{
return
!
aListener
-
>
mFlags
.
mPassive
&
&
IsApzAwareEvent
(
aListener
-
>
mTypeAtom
)
;
}
bool
EventListenerManager
:
:
IsApzAwareEvent
(
nsAtom
*
aEvent
)
{
if
(
aEvent
=
=
nsGkAtoms
:
:
onwheel
|
|
aEvent
=
=
nsGkAtoms
:
:
onDOMMouseScroll
|
|
aEvent
=
=
nsGkAtoms
:
:
onmousewheel
|
|
aEvent
=
=
nsGkAtoms
:
:
onMozMousePixelScroll
)
{
return
true
;
}
if
(
aEvent
=
=
nsGkAtoms
:
:
ontouchstart
|
|
aEvent
=
=
nsGkAtoms
:
:
ontouchmove
)
{
return
TouchEvent
:
:
PrefEnabled
(
nsContentUtils
:
:
GetDocShellForEventTarget
(
mTarget
)
)
;
}
return
false
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
EventListenerManager
:
:
GetScriptGlobalAndDocument
(
nsIDocument
*
*
aDoc
)
{
nsCOMPtr
<
nsINode
>
node
(
do_QueryInterface
(
mTarget
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsIScriptGlobalObject
>
global
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsLoadedAsData
(
)
)
{
return
nullptr
;
}
global
=
do_QueryInterface
(
doc
-
>
GetScopeObject
(
)
)
;
}
else
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
GetTargetAsInnerWindow
(
)
)
{
doc
=
win
-
>
GetExtantDoc
(
)
;
global
=
do_QueryInterface
(
win
)
;
}
else
{
global
=
do_QueryInterface
(
mTarget
)
;
}
}
doc
.
forget
(
aDoc
)
;
return
global
.
forget
(
)
;
}
}
