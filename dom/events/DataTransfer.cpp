#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
DataTransfer
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
nsArray
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIStorageStream
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferBinding
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferItemList
.
h
"
#
include
"
mozilla
/
dom
/
Directory
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FileList
.
h
"
#
include
"
mozilla
/
dom
/
IPCBlobUtils
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
OSFileSystem
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
DataTransfer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
DataTransfer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mItems
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDragTarget
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDragImage
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
DataTransfer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mItems
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDragTarget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDragImage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
DataTransfer
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
DataTransfer
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
DataTransfer
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DataTransfer
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
DataTransfer
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
const
char
DataTransfer
:
:
sEffects
[
8
]
[
9
]
=
{
"
none
"
"
copy
"
"
move
"
"
copyMove
"
"
link
"
"
copyLink
"
"
linkMove
"
"
all
"
}
;
enum
CustomClipboardTypeId
{
eCustomClipboardTypeId_None
eCustomClipboardTypeId_String
}
;
static
DataTransfer
:
:
Mode
ModeForEvent
(
EventMessage
aEventMessage
)
{
switch
(
aEventMessage
)
{
case
eCut
:
case
eCopy
:
case
eDragStart
:
return
DataTransfer
:
:
Mode
:
:
ReadWrite
;
case
eDrop
:
case
ePaste
:
case
ePasteNoFormatting
:
case
eEditorInput
:
return
DataTransfer
:
:
Mode
:
:
ReadOnly
;
default
:
return
StaticPrefs
:
:
dom_events_dataTransfer_protected_enabled
(
)
?
DataTransfer
:
:
Mode
:
:
Protected
:
DataTransfer
:
:
Mode
:
:
ReadOnly
;
}
}
DataTransfer
:
:
DataTransfer
(
nsISupports
*
aParent
EventMessage
aEventMessage
bool
aIsExternal
int32_t
aClipboardType
)
:
mParent
(
aParent
)
mDropEffect
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
mEffectAllowed
(
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
mEventMessage
(
aEventMessage
)
mCursorState
(
false
)
mMode
(
ModeForEvent
(
aEventMessage
)
)
mIsExternal
(
aIsExternal
)
mUserCancelled
(
false
)
mIsCrossDomainSubFrameDrop
(
false
)
mClipboardType
(
aClipboardType
)
mDragImageX
(
0
)
mDragImageY
(
0
)
{
mItems
=
new
DataTransferItemList
(
this
)
;
if
(
mIsExternal
&
&
mMode
!
=
Mode
:
:
ReadWrite
)
{
if
(
aEventMessage
=
=
ePasteNoFormatting
)
{
mEventMessage
=
ePaste
;
CacheExternalClipboardFormats
(
true
)
;
}
else
if
(
aEventMessage
=
=
ePaste
)
{
CacheExternalClipboardFormats
(
false
)
;
}
else
if
(
aEventMessage
>
=
eDragDropEventFirst
&
&
aEventMessage
<
=
eDragDropEventLast
)
{
CacheExternalDragFormats
(
)
;
}
}
}
DataTransfer
:
:
DataTransfer
(
nsISupports
*
aParent
EventMessage
aEventMessage
nsITransferable
*
aTransferable
)
:
mParent
(
aParent
)
mTransferable
(
aTransferable
)
mDropEffect
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
mEffectAllowed
(
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
mEventMessage
(
aEventMessage
)
mCursorState
(
false
)
mMode
(
ModeForEvent
(
aEventMessage
)
)
mIsExternal
(
true
)
mUserCancelled
(
false
)
mIsCrossDomainSubFrameDrop
(
false
)
mClipboardType
(
-
1
)
mDragImageX
(
0
)
mDragImageY
(
0
)
{
mItems
=
new
DataTransferItemList
(
this
)
;
CacheTransferableFormats
(
)
;
FillAllExternalData
(
)
;
mIsExternal
=
false
;
mTransferable
=
nullptr
;
}
DataTransfer
:
:
DataTransfer
(
nsISupports
*
aParent
EventMessage
aEventMessage
const
nsAString
&
aString
)
:
mParent
(
aParent
)
mDropEffect
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
mEffectAllowed
(
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
mEventMessage
(
aEventMessage
)
mCursorState
(
false
)
mMode
(
ModeForEvent
(
aEventMessage
)
)
mIsExternal
(
false
)
mUserCancelled
(
false
)
mIsCrossDomainSubFrameDrop
(
false
)
mClipboardType
(
-
1
)
mDragImageX
(
0
)
mDragImageY
(
0
)
{
mItems
=
new
DataTransferItemList
(
this
)
;
nsCOMPtr
<
nsIPrincipal
>
sysPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsAString
(
aString
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
SetDataWithPrincipal
(
u
"
text
/
plain
"
_ns
variant
0
sysPrincipal
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
set
given
string
to
the
DataTransfer
object
"
)
;
}
DataTransfer
:
:
DataTransfer
(
nsISupports
*
aParent
EventMessage
aEventMessage
const
uint32_t
aEffectAllowed
bool
aCursorState
bool
aIsExternal
bool
aUserCancelled
bool
aIsCrossDomainSubFrameDrop
int32_t
aClipboardType
DataTransferItemList
*
aItems
Element
*
aDragImage
uint32_t
aDragImageX
uint32_t
aDragImageY
)
:
mParent
(
aParent
)
mDropEffect
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
mEffectAllowed
(
aEffectAllowed
)
mEventMessage
(
aEventMessage
)
mCursorState
(
aCursorState
)
mMode
(
ModeForEvent
(
aEventMessage
)
)
mIsExternal
(
aIsExternal
)
mUserCancelled
(
aUserCancelled
)
mIsCrossDomainSubFrameDrop
(
aIsCrossDomainSubFrameDrop
)
mClipboardType
(
aClipboardType
)
mDragImage
(
aDragImage
)
mDragImageX
(
aDragImageX
)
mDragImageY
(
aDragImageY
)
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
aItems
)
;
mItems
=
aItems
-
>
Clone
(
this
)
;
NS_ASSERTION
(
aEventMessage
!
=
eDragStart
"
invalid
event
type
for
DataTransfer
constructor
"
)
;
}
DataTransfer
:
:
~
DataTransfer
(
)
=
default
;
already_AddRefed
<
DataTransfer
>
DataTransfer
:
:
Constructor
(
const
GlobalObject
&
aGlobal
)
{
RefPtr
<
DataTransfer
>
transfer
=
new
DataTransfer
(
aGlobal
.
GetAsSupports
(
)
eCopy
false
-
1
)
;
transfer
-
>
mEffectAllowed
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
return
transfer
.
forget
(
)
;
}
JSObject
*
DataTransfer
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
DataTransfer_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
DataTransfer
:
:
SetDropEffect
(
const
nsAString
&
aDropEffect
)
{
for
(
uint32_t
e
=
0
;
e
<
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
e
+
+
)
{
if
(
aDropEffect
.
EqualsASCII
(
sEffects
[
e
]
)
)
{
if
(
e
!
=
(
nsIDragService
:
:
DRAGDROP_ACTION_COPY
|
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
)
)
{
mDropEffect
=
e
;
}
break
;
}
}
}
void
DataTransfer
:
:
SetEffectAllowed
(
const
nsAString
&
aEffectAllowed
)
{
if
(
aEffectAllowed
.
EqualsLiteral
(
"
uninitialized
"
)
)
{
mEffectAllowed
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
;
return
;
}
static_assert
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
=
=
0
"
DRAGDROP_ACTION_NONE
constant
is
wrong
"
)
;
static_assert
(
nsIDragService
:
:
DRAGDROP_ACTION_COPY
=
=
1
"
DRAGDROP_ACTION_COPY
constant
is
wrong
"
)
;
static_assert
(
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
=
=
2
"
DRAGDROP_ACTION_MOVE
constant
is
wrong
"
)
;
static_assert
(
nsIDragService
:
:
DRAGDROP_ACTION_LINK
=
=
4
"
DRAGDROP_ACTION_LINK
constant
is
wrong
"
)
;
for
(
uint32_t
e
=
0
;
e
<
ArrayLength
(
sEffects
)
;
e
+
+
)
{
if
(
aEffectAllowed
.
EqualsASCII
(
sEffects
[
e
]
)
)
{
mEffectAllowed
=
e
;
break
;
}
}
}
void
DataTransfer
:
:
GetMozTriggeringPrincipalURISpec
(
nsAString
&
aPrincipalURISpec
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
!
dragSession
)
{
aPrincipalURISpec
.
Truncate
(
0
)
;
return
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
dragSession
-
>
GetTriggeringPrincipal
(
getter_AddRefs
(
principal
)
)
;
if
(
!
principal
)
{
aPrincipalURISpec
.
Truncate
(
0
)
;
return
;
}
nsAutoCString
spec
;
principal
-
>
GetAsciiSpec
(
spec
)
;
CopyUTF8toUTF16
(
spec
aPrincipalURISpec
)
;
}
nsIContentSecurityPolicy
*
DataTransfer
:
:
GetMozCSP
(
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
!
dragSession
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
dragSession
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
return
csp
;
}
already_AddRefed
<
FileList
>
DataTransfer
:
:
GetFiles
(
nsIPrincipal
&
aSubjectPrincipal
)
{
return
mItems
-
>
Files
(
&
aSubjectPrincipal
)
;
}
void
DataTransfer
:
:
GetTypes
(
nsTArray
<
nsString
>
&
aTypes
CallerType
aCallerType
)
const
{
aTypes
.
Clear
(
)
;
return
mItems
-
>
GetTypes
(
aTypes
aCallerType
)
;
}
bool
DataTransfer
:
:
HasType
(
const
nsAString
&
aType
)
const
{
return
mItems
-
>
HasType
(
aType
)
;
}
bool
DataTransfer
:
:
HasFile
(
)
const
{
return
mItems
-
>
HasFile
(
)
;
}
void
DataTransfer
:
:
GetData
(
const
nsAString
&
aFormat
nsAString
&
aData
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
const
{
aData
.
Truncate
(
)
;
nsCOMPtr
<
nsIVariant
>
data
;
nsresult
rv
=
GetDataAtInternal
(
aFormat
0
&
aSubjectPrincipal
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
!
=
NS_ERROR_DOM_INDEX_SIZE_ERR
)
{
aRv
.
Throw
(
rv
)
;
}
return
;
}
if
(
data
)
{
nsAutoString
stringdata
;
data
-
>
GetAsAString
(
stringdata
)
;
nsAutoString
lowercaseFormat
;
nsContentUtils
:
:
ASCIIToLower
(
aFormat
lowercaseFormat
)
;
if
(
lowercaseFormat
.
EqualsLiteral
(
"
url
"
)
)
{
int32_t
lastidx
=
0
idx
;
int32_t
length
=
stringdata
.
Length
(
)
;
while
(
lastidx
<
length
)
{
idx
=
stringdata
.
FindChar
(
'
\
n
'
lastidx
)
;
if
(
stringdata
[
lastidx
]
=
=
'
#
'
)
{
if
(
idx
=
=
-
1
)
{
break
;
}
}
else
{
if
(
idx
=
=
-
1
)
{
aData
.
Assign
(
Substring
(
stringdata
lastidx
)
)
;
}
else
{
aData
.
Assign
(
Substring
(
stringdata
lastidx
idx
-
lastidx
)
)
;
}
aData
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
aData
true
)
;
return
;
}
lastidx
=
idx
+
1
;
}
}
else
{
aData
=
stringdata
;
}
}
}
void
DataTransfer
:
:
SetData
(
const
nsAString
&
aFormat
const
nsAString
&
aData
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsAString
(
aData
)
;
aRv
=
SetDataAtInternal
(
aFormat
variant
0
&
aSubjectPrincipal
)
;
}
void
DataTransfer
:
:
ClearData
(
const
Optional
<
nsAString
>
&
aFormat
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
IsReadOnly
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
return
;
}
if
(
MozItemCount
(
)
=
=
0
)
{
return
;
}
if
(
aFormat
.
WasPassed
(
)
)
{
MozClearDataAtHelper
(
aFormat
.
Value
(
)
0
aSubjectPrincipal
aRv
)
;
}
else
{
MozClearDataAtHelper
(
u
"
"
_ns
0
aSubjectPrincipal
aRv
)
;
}
}
void
DataTransfer
:
:
SetMozCursor
(
const
nsAString
&
aCursorState
)
{
mCursorState
=
aCursorState
.
EqualsLiteral
(
"
default
"
)
;
}
already_AddRefed
<
nsINode
>
DataTransfer
:
:
GetMozSourceNode
(
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
!
dragSession
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
sourceNode
;
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
sourceNode
&
&
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
sourceNode
)
)
{
return
nullptr
;
}
return
sourceNode
.
forget
(
)
;
}
already_AddRefed
<
DOMStringList
>
DataTransfer
:
:
MozTypesAt
(
uint32_t
aIndex
ErrorResult
&
aRv
)
const
{
if
(
aIndex
>
0
&
&
(
mEventMessage
=
=
eCut
|
|
mEventMessage
=
=
eCopy
|
|
mEventMessage
=
=
ePaste
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
RefPtr
<
DOMStringList
>
types
=
new
DOMStringList
(
)
;
if
(
aIndex
<
MozItemCount
(
)
)
{
const
nsTArray
<
RefPtr
<
DataTransferItem
>
>
&
items
=
*
mItems
-
>
MozItemsAt
(
aIndex
)
;
bool
addFile
=
false
;
for
(
uint32_t
i
=
0
;
i
<
items
.
Length
(
)
;
i
+
+
)
{
nsAutoString
type
;
items
[
i
]
-
>
GetInternalType
(
type
)
;
if
(
NS_WARN_IF
(
!
types
-
>
Add
(
type
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
items
[
i
]
-
>
Kind
(
)
=
=
DataTransferItem
:
:
KIND_FILE
)
{
addFile
=
true
;
}
}
if
(
addFile
)
{
types
-
>
Add
(
u
"
Files
"
_ns
)
;
}
}
return
types
.
forget
(
)
;
}
nsresult
DataTransfer
:
:
GetDataAtNoSecurityCheck
(
const
nsAString
&
aFormat
uint32_t
aIndex
nsIVariant
*
*
aData
)
const
{
return
GetDataAtInternal
(
aFormat
aIndex
nsContentUtils
:
:
GetSystemPrincipal
(
)
aData
)
;
}
nsresult
DataTransfer
:
:
GetDataAtInternal
(
const
nsAString
&
aFormat
uint32_t
aIndex
nsIPrincipal
*
aSubjectPrincipal
nsIVariant
*
*
aData
)
const
{
*
aData
=
nullptr
;
if
(
aFormat
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
aIndex
>
=
MozItemCount
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aIndex
>
0
&
&
(
mEventMessage
=
=
eCut
|
|
mEventMessage
=
=
eCopy
|
|
mEventMessage
=
=
ePaste
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
nsAutoString
format
;
GetRealFormat
(
aFormat
format
)
;
MOZ_ASSERT
(
aSubjectPrincipal
)
;
RefPtr
<
DataTransferItem
>
item
=
mItems
-
>
MozItemByTypeAt
(
format
aIndex
)
;
if
(
!
item
)
{
return
NS_OK
;
}
if
(
!
aSubjectPrincipal
-
>
IsSystemPrincipal
(
)
&
&
item
-
>
ChromeOnly
(
)
)
{
return
NS_OK
;
}
ErrorResult
result
;
nsCOMPtr
<
nsIVariant
>
data
=
item
-
>
Data
(
aSubjectPrincipal
result
)
;
if
(
NS_WARN_IF
(
!
data
|
|
result
.
Failed
(
)
)
)
{
return
result
.
StealNSResult
(
)
;
}
data
.
forget
(
aData
)
;
return
NS_OK
;
}
void
DataTransfer
:
:
MozGetDataAt
(
JSContext
*
aCx
const
nsAString
&
aFormat
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIVariant
>
data
;
aRv
=
GetDataAtInternal
(
aFormat
aIndex
nsContentUtils
:
:
GetSystemPrincipal
(
)
getter_AddRefs
(
data
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
data
)
{
aRetval
.
setNull
(
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
aCx
)
;
if
(
!
VariantToJsval
(
aCx
data
aRetval
)
)
{
aRv
=
NS_ERROR_FAILURE
;
return
;
}
}
bool
DataTransfer
:
:
PrincipalMaySetData
(
const
nsAString
&
aType
nsIVariant
*
aData
nsIPrincipal
*
aPrincipal
)
{
if
(
!
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
DataTransferItem
:
:
eKind
kind
=
DataTransferItem
:
:
KindFromData
(
aData
)
;
if
(
kind
=
=
DataTransferItem
:
:
KIND_OTHER
)
{
NS_WARNING
(
"
Disallowing
adding
non
string
/
file
types
to
DataTransfer
"
)
;
return
false
;
}
if
(
FindInReadable
(
kInternal_Mimetype_Prefix
aType
)
&
&
!
StringBeginsWith
(
aType
u
"
text
/
x
-
moz
-
url
"
_ns
)
)
{
auto
principal
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
!
principal
-
>
AddonPolicy
(
)
|
|
!
StringBeginsWith
(
aType
u
"
text
/
x
-
moz
-
place
"
_ns
)
)
{
NS_WARNING
(
"
Disallowing
adding
this
type
to
DataTransfer
"
)
;
return
false
;
}
}
}
return
true
;
}
void
DataTransfer
:
:
TypesListMayHaveChanged
(
)
{
DataTransfer_Binding
:
:
ClearCachedTypesValue
(
this
)
;
}
already_AddRefed
<
DataTransfer
>
DataTransfer
:
:
MozCloneForEvent
(
const
nsAString
&
aEvent
ErrorResult
&
aRv
)
{
RefPtr
<
nsAtom
>
atomEvt
=
NS_Atomize
(
aEvent
)
;
if
(
!
atomEvt
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
EventMessage
eventMessage
=
nsContentUtils
:
:
GetEventMessage
(
atomEvt
)
;
RefPtr
<
DataTransfer
>
dt
;
nsresult
rv
=
Clone
(
mParent
eventMessage
false
false
getter_AddRefs
(
dt
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
static
const
char
*
kNonPlainTextExternalFormats
[
]
=
{
kCustomTypesMime
kFileMime
kHTMLMime
kRTFMime
kURLMime
kURLDataMime
kUnicodeMime
kPNGImageMime
}
;
void
DataTransfer
:
:
GetExternalClipboardFormats
(
const
int32_t
&
aWhichClipboard
const
bool
&
aPlainTextOnly
nsTArray
<
nsCString
>
*
aResult
)
{
MOZ_ASSERT
(
aResult
)
;
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
)
;
if
(
!
clipboard
|
|
aWhichClipboard
<
0
)
{
return
;
}
if
(
aPlainTextOnly
)
{
bool
hasType
;
AutoTArray
<
nsCString
1
>
unicodeMime
=
{
nsDependentCString
(
kUnicodeMime
)
}
;
nsresult
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
unicodeMime
aWhichClipboard
&
hasType
)
;
NS_SUCCEEDED
(
rv
)
;
if
(
hasType
)
{
aResult
-
>
AppendElement
(
kUnicodeMime
)
;
}
return
;
}
for
(
uint32_t
f
=
0
;
f
<
mozilla
:
:
ArrayLength
(
kNonPlainTextExternalFormats
)
;
+
+
f
)
{
bool
hasType
;
AutoTArray
<
nsCString
1
>
format
=
{
nsDependentCString
(
kNonPlainTextExternalFormats
[
f
]
)
}
;
nsresult
rv
=
clipboard
-
>
HasDataMatchingFlavors
(
format
aWhichClipboard
&
hasType
)
;
NS_SUCCEEDED
(
rv
)
;
if
(
hasType
)
{
aResult
-
>
AppendElement
(
kNonPlainTextExternalFormats
[
f
]
)
;
}
}
}
void
DataTransfer
:
:
GetExternalTransferableFormats
(
nsITransferable
*
aTransferable
bool
aPlainTextOnly
nsTArray
<
nsCString
>
*
aResult
)
{
MOZ_ASSERT
(
aTransferable
)
;
MOZ_ASSERT
(
aResult
)
;
aResult
-
>
Clear
(
)
;
AutoTArray
<
nsCString
10
>
flavors
;
aTransferable
-
>
FlavorsTransferableCanExport
(
flavors
)
;
if
(
aPlainTextOnly
)
{
auto
index
=
flavors
.
IndexOf
(
nsLiteralCString
(
kUnicodeMime
)
)
;
if
(
index
!
=
flavors
.
NoIndex
)
{
aResult
-
>
AppendElement
(
nsLiteralCString
(
kUnicodeMime
)
)
;
}
return
;
}
for
(
const
char
*
format
:
kNonPlainTextExternalFormats
)
{
auto
index
=
flavors
.
IndexOf
(
nsCString
(
format
)
)
;
if
(
index
!
=
flavors
.
NoIndex
)
{
aResult
-
>
AppendElement
(
nsCString
(
format
)
)
;
}
}
}
nsresult
DataTransfer
:
:
SetDataAtInternal
(
const
nsAString
&
aFormat
nsIVariant
*
aData
uint32_t
aIndex
nsIPrincipal
*
aSubjectPrincipal
)
{
if
(
aFormat
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
IsReadOnly
(
)
)
{
return
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
;
}
if
(
aIndex
>
MozItemCount
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aIndex
>
0
&
&
(
mEventMessage
=
=
eCut
|
|
mEventMessage
=
=
eCopy
|
|
mEventMessage
=
=
ePaste
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aFormat
.
EqualsLiteral
(
kCustomTypesMime
)
)
{
return
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
}
if
(
!
PrincipalMaySetData
(
aFormat
aData
aSubjectPrincipal
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
return
SetDataWithPrincipal
(
aFormat
aData
aIndex
aSubjectPrincipal
)
;
}
void
DataTransfer
:
:
MozSetDataAt
(
JSContext
*
aCx
const
nsAString
&
aFormat
JS
:
:
Handle
<
JS
:
:
Value
>
aData
uint32_t
aIndex
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIVariant
>
data
;
aRv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
JSValToVariant
(
aCx
aData
getter_AddRefs
(
data
)
)
;
if
(
!
aRv
.
Failed
(
)
)
{
aRv
=
SetDataAtInternal
(
aFormat
data
aIndex
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
;
}
}
void
DataTransfer
:
:
MozClearDataAt
(
const
nsAString
&
aFormat
uint32_t
aIndex
ErrorResult
&
aRv
)
{
if
(
IsReadOnly
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
return
;
}
if
(
aIndex
>
=
MozItemCount
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
if
(
aIndex
>
0
&
&
(
mEventMessage
=
=
eCut
|
|
mEventMessage
=
=
eCopy
|
|
mEventMessage
=
=
ePaste
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
MozClearDataAtHelper
(
aFormat
aIndex
*
nsContentUtils
:
:
GetSystemPrincipal
(
)
aRv
)
;
if
(
aIndex
=
=
0
&
&
mItems
-
>
MozItemCount
(
)
>
1
&
&
mItems
-
>
MozItemsAt
(
0
)
-
>
Length
(
)
=
=
0
)
{
mItems
-
>
PopIndexZero
(
)
;
}
}
void
DataTransfer
:
:
MozClearDataAtHelper
(
const
nsAString
&
aFormat
uint32_t
aIndex
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
IsReadOnly
(
)
)
;
MOZ_ASSERT
(
aIndex
<
MozItemCount
(
)
)
;
MOZ_ASSERT
(
aIndex
=
=
0
|
|
(
mEventMessage
!
=
eCut
&
&
mEventMessage
!
=
eCopy
&
&
mEventMessage
!
=
ePaste
)
)
;
nsAutoString
format
;
GetRealFormat
(
aFormat
format
)
;
mItems
-
>
MozRemoveByTypeAt
(
format
aIndex
aSubjectPrincipal
aRv
)
;
}
void
DataTransfer
:
:
SetDragImage
(
Element
&
aImage
int32_t
aX
int32_t
aY
)
{
if
(
!
IsReadOnly
(
)
)
{
mDragImage
=
&
aImage
;
mDragImageX
=
aX
;
mDragImageY
=
aY
;
}
}
void
DataTransfer
:
:
UpdateDragImage
(
Element
&
aImage
int32_t
aX
int32_t
aY
)
{
if
(
mEventMessage
<
eDragDropEventFirst
|
|
mEventMessage
>
eDragDropEventLast
)
{
return
;
}
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
dragSession
)
{
dragSession
-
>
UpdateDragImage
(
&
aImage
aX
aY
)
;
}
}
void
DataTransfer
:
:
AddElement
(
Element
&
aElement
ErrorResult
&
aRv
)
{
if
(
IsReadOnly
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
return
;
}
mDragTarget
=
&
aElement
;
}
nsresult
DataTransfer
:
:
Clone
(
nsISupports
*
aParent
EventMessage
aEventMessage
bool
aUserCancelled
bool
aIsCrossDomainSubFrameDrop
DataTransfer
*
*
aNewDataTransfer
)
{
RefPtr
<
DataTransfer
>
newDataTransfer
=
new
DataTransfer
(
aParent
aEventMessage
mEffectAllowed
mCursorState
mIsExternal
aUserCancelled
aIsCrossDomainSubFrameDrop
mClipboardType
mItems
mDragImage
mDragImageX
mDragImageY
)
;
newDataTransfer
.
forget
(
aNewDataTransfer
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIArray
>
DataTransfer
:
:
GetTransferables
(
nsINode
*
aDragTarget
)
{
MOZ_ASSERT
(
aDragTarget
)
;
Document
*
doc
=
aDragTarget
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
return
GetTransferables
(
doc
-
>
GetLoadContext
(
)
)
;
}
already_AddRefed
<
nsIArray
>
DataTransfer
:
:
GetTransferables
(
nsILoadContext
*
aLoadContext
)
{
nsCOMPtr
<
nsIMutableArray
>
transArray
=
nsArray
:
:
Create
(
)
;
if
(
!
transArray
)
{
return
nullptr
;
}
uint32_t
count
=
MozItemCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
nsCOMPtr
<
nsITransferable
>
transferable
=
GetTransferable
(
i
aLoadContext
)
;
if
(
transferable
)
{
transArray
-
>
AppendElement
(
transferable
)
;
}
}
return
transArray
.
forget
(
)
;
}
already_AddRefed
<
nsITransferable
>
DataTransfer
:
:
GetTransferable
(
uint32_t
aIndex
nsILoadContext
*
aLoadContext
)
{
if
(
aIndex
>
=
MozItemCount
(
)
)
{
return
nullptr
;
}
const
nsTArray
<
RefPtr
<
DataTransferItem
>
>
&
item
=
*
mItems
-
>
MozItemsAt
(
aIndex
)
;
uint32_t
count
=
item
.
Length
(
)
;
if
(
!
count
)
{
return
nullptr
;
}
nsCOMPtr
<
nsITransferable
>
transferable
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
)
;
if
(
!
transferable
)
{
return
nullptr
;
}
transferable
-
>
Init
(
aLoadContext
)
;
nsCOMPtr
<
nsIStorageStream
>
storageStream
;
nsCOMPtr
<
nsIObjectOutputStream
>
stream
;
bool
added
=
false
;
bool
handlingCustomFormats
=
true
;
const
uint32_t
baseLength
=
sizeof
(
uint32_t
)
+
1
;
uint32_t
totalCustomLength
=
baseLength
;
const
char
*
knownFormats
[
]
=
{
kTextMime
kHTMLMime
kNativeHTMLMime
kRTFMime
kURLMime
kURLDataMime
kURLDescriptionMime
kURLPrivateMime
kPNGImageMime
kJPEGImageMime
kGIFImageMime
kNativeImageMime
kFileMime
kFilePromiseMime
kFilePromiseURLMime
kFilePromiseDestFilename
kFilePromiseDirectoryMime
kMozTextInternal
kHTMLContext
kHTMLInfo
kImageRequestMime
}
;
do
{
for
(
uint32_t
f
=
0
;
f
<
count
;
f
+
+
)
{
RefPtr
<
DataTransferItem
>
formatitem
=
item
[
f
]
;
nsCOMPtr
<
nsIVariant
>
variant
=
formatitem
-
>
DataNoSecurityCheck
(
)
;
if
(
!
variant
)
{
continue
;
}
nsAutoString
type
;
formatitem
-
>
GetInternalType
(
type
)
;
bool
isCustomFormat
=
true
;
for
(
uint32_t
f
=
0
;
f
<
ArrayLength
(
knownFormats
)
;
f
+
+
)
{
if
(
type
.
EqualsASCII
(
knownFormats
[
f
]
)
)
{
isCustomFormat
=
false
;
break
;
}
}
uint32_t
lengthInBytes
;
nsCOMPtr
<
nsISupports
>
convertedData
;
if
(
handlingCustomFormats
)
{
if
(
!
ConvertFromVariant
(
variant
getter_AddRefs
(
convertedData
)
&
lengthInBytes
)
)
{
continue
;
}
if
(
isCustomFormat
&
&
totalCustomLength
>
0
)
{
nsCOMPtr
<
nsISupportsString
>
str
(
do_QueryInterface
(
convertedData
)
)
;
if
(
str
)
{
nsAutoString
data
;
str
-
>
GetData
(
data
)
;
if
(
!
stream
)
{
NS_NewStorageStream
(
1024
UINT32_MAX
getter_AddRefs
(
storageStream
)
)
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
storageStream
-
>
GetOutputStream
(
0
getter_AddRefs
(
outputStream
)
)
;
stream
=
NS_NewObjectOutputStream
(
outputStream
)
;
}
CheckedInt
<
uint32_t
>
formatLength
=
CheckedInt
<
uint32_t
>
(
type
.
Length
(
)
)
*
sizeof
(
nsString
:
:
char_type
)
;
CheckedInt
<
uint32_t
>
newSize
=
formatLength
+
totalCustomLength
+
lengthInBytes
+
(
sizeof
(
uint32_t
)
*
3
)
;
if
(
newSize
.
isValid
(
)
)
{
nsresult
rv
=
stream
-
>
Write32
(
eCustomClipboardTypeId_String
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
totalCustomLength
=
0
;
continue
;
}
rv
=
stream
-
>
Write32
(
formatLength
.
value
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
totalCustomLength
=
0
;
continue
;
}
MOZ_ASSERT
(
formatLength
.
isValid
(
)
&
&
formatLength
.
value
(
)
=
=
type
.
Length
(
)
*
sizeof
(
nsString
:
:
char_type
)
"
Why
is
formatLength
off
?
"
)
;
rv
=
stream
-
>
WriteBytes
(
AsBytes
(
Span
(
type
.
BeginReading
(
)
type
.
Length
(
)
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
totalCustomLength
=
0
;
continue
;
}
rv
=
stream
-
>
Write32
(
lengthInBytes
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
totalCustomLength
=
0
;
continue
;
}
rv
=
stream
-
>
WriteBytes
(
Span
(
reinterpret_cast
<
const
uint8_t
*
>
(
data
.
BeginReading
(
)
)
lengthInBytes
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
totalCustomLength
=
0
;
continue
;
}
totalCustomLength
=
newSize
.
value
(
)
;
}
}
}
}
else
if
(
isCustomFormat
&
&
stream
)
{
if
(
totalCustomLength
>
baseLength
)
{
nsresult
rv
=
stream
-
>
Write32
(
eCustomClipboardTypeId_None
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
;
storageStream
-
>
NewInputStream
(
0
getter_AddRefs
(
inputStream
)
)
;
RefPtr
<
nsStringBuffer
>
stringBuffer
=
nsStringBuffer
:
:
Alloc
(
totalCustomLength
)
;
totalCustomLength
-
-
;
uint32_t
amountRead
;
rv
=
inputStream
-
>
Read
(
static_cast
<
char
*
>
(
stringBuffer
-
>
Data
(
)
)
totalCustomLength
&
amountRead
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
static_cast
<
char
*
>
(
stringBuffer
-
>
Data
(
)
)
[
amountRead
]
=
0
;
nsCString
str
;
stringBuffer
-
>
ToString
(
totalCustomLength
str
)
;
nsCOMPtr
<
nsISupportsCString
>
strSupports
(
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
)
;
strSupports
-
>
SetData
(
str
)
;
nsresult
rv
=
transferable
-
>
SetTransferData
(
kCustomTypesMime
strSupports
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
added
=
true
;
}
}
}
stream
=
nullptr
;
}
else
{
if
(
!
ConvertFromVariant
(
variant
getter_AddRefs
(
convertedData
)
&
lengthInBytes
)
)
{
continue
;
}
const
char
*
format
;
NS_ConvertUTF16toUTF8
utf8format
(
type
)
;
if
(
utf8format
.
EqualsLiteral
(
kTextMime
)
)
{
format
=
kUnicodeMime
;
}
else
{
format
=
utf8format
.
get
(
)
;
}
nsCOMPtr
<
nsIFormatConverter
>
converter
=
do_QueryInterface
(
convertedData
)
;
if
(
converter
)
{
transferable
-
>
AddDataFlavor
(
format
)
;
transferable
-
>
SetConverter
(
converter
)
;
continue
;
}
nsresult
rv
=
transferable
-
>
SetTransferData
(
format
convertedData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
added
=
true
;
}
}
handlingCustomFormats
=
!
handlingCustomFormats
;
}
while
(
!
handlingCustomFormats
)
;
if
(
added
)
{
return
transferable
.
forget
(
)
;
}
return
nullptr
;
}
bool
DataTransfer
:
:
ConvertFromVariant
(
nsIVariant
*
aVariant
nsISupports
*
*
aSupports
uint32_t
*
aLength
)
const
{
*
aSupports
=
nullptr
;
*
aLength
=
0
;
uint16_t
type
=
aVariant
-
>
GetDataType
(
)
;
if
(
type
=
=
nsIDataType
:
:
VTYPE_INTERFACE
|
|
type
=
=
nsIDataType
:
:
VTYPE_INTERFACE_IS
)
{
nsCOMPtr
<
nsISupports
>
data
;
if
(
NS_FAILED
(
aVariant
-
>
GetAsISupports
(
getter_AddRefs
(
data
)
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFlavorDataProvider
>
fdp
=
do_QueryInterface
(
data
)
;
if
(
fdp
)
{
fdp
.
forget
(
aSupports
)
;
*
aLength
=
0
;
}
else
{
data
.
forget
(
aSupports
)
;
*
aLength
=
sizeof
(
nsISupports
*
)
;
}
return
true
;
}
nsAutoString
str
;
nsresult
rv
=
aVariant
-
>
GetAsAString
(
str
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
nsCOMPtr
<
nsISupportsString
>
strSupports
(
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
)
)
;
if
(
!
strSupports
)
{
return
false
;
}
strSupports
-
>
SetData
(
str
)
;
strSupports
.
forget
(
aSupports
)
;
*
aLength
=
str
.
Length
(
)
*
2
;
return
true
;
}
void
DataTransfer
:
:
Disconnect
(
)
{
SetMode
(
Mode
:
:
Protected
)
;
if
(
StaticPrefs
:
:
dom_events_dataTransfer_protected_enabled
(
)
)
{
ClearAll
(
)
;
}
}
void
DataTransfer
:
:
ClearAll
(
)
{
mItems
-
>
ClearAllItems
(
)
;
}
uint32_t
DataTransfer
:
:
MozItemCount
(
)
const
{
return
mItems
-
>
MozItemCount
(
)
;
}
nsresult
DataTransfer
:
:
SetDataWithPrincipal
(
const
nsAString
&
aFormat
nsIVariant
*
aData
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
bool
aHidden
)
{
nsAutoString
format
;
GetRealFormat
(
aFormat
format
)
;
ErrorResult
rv
;
RefPtr
<
DataTransferItem
>
item
=
mItems
-
>
SetDataWithPrincipal
(
format
aData
aIndex
aPrincipal
false
aHidden
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
DataTransfer
:
:
SetDataWithPrincipalFromOtherProcess
(
const
nsAString
&
aFormat
nsIVariant
*
aData
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
bool
aHidden
)
{
if
(
aFormat
.
EqualsLiteral
(
kCustomTypesMime
)
)
{
FillInExternalCustomTypes
(
aData
aIndex
aPrincipal
)
;
}
else
{
nsAutoString
format
;
GetRealFormat
(
aFormat
format
)
;
ErrorResult
rv
;
RefPtr
<
DataTransferItem
>
item
=
mItems
-
>
SetDataWithPrincipal
(
format
aData
aIndex
aPrincipal
false
aHidden
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
}
}
}
void
DataTransfer
:
:
GetRealFormat
(
const
nsAString
&
aInFormat
nsAString
&
aOutFormat
)
const
{
nsAutoString
lowercaseFormat
;
nsContentUtils
:
:
ASCIIToLower
(
aInFormat
lowercaseFormat
)
;
if
(
lowercaseFormat
.
EqualsLiteral
(
"
text
"
)
|
|
lowercaseFormat
.
EqualsLiteral
(
"
text
/
unicode
"
)
)
{
aOutFormat
.
AssignLiteral
(
"
text
/
plain
"
)
;
return
;
}
if
(
lowercaseFormat
.
EqualsLiteral
(
"
url
"
)
)
{
aOutFormat
.
AssignLiteral
(
"
text
/
uri
-
list
"
)
;
return
;
}
aOutFormat
.
Assign
(
lowercaseFormat
)
;
}
nsresult
DataTransfer
:
:
CacheExternalData
(
const
char
*
aFormat
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
bool
aHidden
)
{
ErrorResult
rv
;
RefPtr
<
DataTransferItem
>
item
;
if
(
strcmp
(
aFormat
kUnicodeMime
)
=
=
0
)
{
item
=
mItems
-
>
SetDataWithPrincipal
(
u
"
text
/
plain
"
_ns
nullptr
aIndex
aPrincipal
false
aHidden
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
if
(
strcmp
(
aFormat
kURLDataMime
)
=
=
0
)
{
item
=
mItems
-
>
SetDataWithPrincipal
(
u
"
text
/
uri
-
list
"
_ns
nullptr
aIndex
aPrincipal
false
aHidden
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsAutoString
format
;
GetRealFormat
(
NS_ConvertUTF8toUTF16
(
aFormat
)
format
)
;
item
=
mItems
-
>
SetDataWithPrincipal
(
format
nullptr
aIndex
aPrincipal
false
aHidden
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
void
DataTransfer
:
:
CacheExternalDragFormats
(
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
!
dragSession
)
{
return
;
}
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsCOMPtr
<
nsIPrincipal
>
sysPrincipal
;
ssm
-
>
GetSystemPrincipal
(
getter_AddRefs
(
sysPrincipal
)
)
;
static
const
char
*
formats
[
]
=
{
kFileMime
kHTMLMime
kURLMime
kURLDataMime
kUnicodeMime
kPNGImageMime
}
;
uint32_t
count
;
dragSession
-
>
GetNumDropItems
(
&
count
)
;
for
(
uint32_t
c
=
0
;
c
<
count
;
c
+
+
)
{
bool
hasFileData
=
false
;
dragSession
-
>
IsDataFlavorSupported
(
kFileMime
&
hasFileData
)
;
bool
supported
;
dragSession
-
>
IsDataFlavorSupported
(
kCustomTypesMime
&
supported
)
;
if
(
supported
)
{
FillInExternalCustomTypes
(
c
sysPrincipal
)
;
}
for
(
uint32_t
f
=
0
;
f
<
ArrayLength
(
formats
)
;
f
+
+
)
{
bool
supported
;
dragSession
-
>
IsDataFlavorSupported
(
formats
[
f
]
&
supported
)
;
if
(
supported
)
{
CacheExternalData
(
formats
[
f
]
c
sysPrincipal
f
&
&
hasFileData
)
;
}
}
}
}
void
DataTransfer
:
:
CacheExternalClipboardFormats
(
bool
aPlainTextOnly
)
{
NS_ASSERTION
(
mEventMessage
=
=
ePaste
"
caching
clipboard
data
for
invalid
event
"
)
;
nsCOMPtr
<
nsIPrincipal
>
sysPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
nsTArray
<
nsCString
>
typesArray
;
if
(
XRE_IsContentProcess
(
)
)
{
ContentChild
:
:
GetSingleton
(
)
-
>
SendGetExternalClipboardFormats
(
mClipboardType
aPlainTextOnly
&
typesArray
)
;
}
else
{
GetExternalClipboardFormats
(
mClipboardType
aPlainTextOnly
&
typesArray
)
;
}
if
(
aPlainTextOnly
)
{
MOZ_ASSERT
(
typesArray
.
IsEmpty
(
)
|
|
typesArray
.
Length
(
)
=
=
1
)
;
if
(
typesArray
.
Length
(
)
=
=
1
)
{
CacheExternalData
(
kUnicodeMime
0
sysPrincipal
false
)
;
}
return
;
}
CacheExternalData
(
typesArray
sysPrincipal
)
;
}
void
DataTransfer
:
:
CacheTransferableFormats
(
)
{
nsCOMPtr
<
nsIPrincipal
>
sysPrincipal
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
AutoTArray
<
nsCString
10
>
typesArray
;
GetExternalTransferableFormats
(
mTransferable
false
&
typesArray
)
;
CacheExternalData
(
typesArray
sysPrincipal
)
;
}
void
DataTransfer
:
:
CacheExternalData
(
const
nsTArray
<
nsCString
>
&
aTypes
nsIPrincipal
*
aPrincipal
)
{
bool
hasFileData
=
false
;
for
(
const
nsCString
&
type
:
aTypes
)
{
if
(
type
.
EqualsLiteral
(
kCustomTypesMime
)
)
{
FillInExternalCustomTypes
(
0
aPrincipal
)
;
}
else
if
(
type
.
EqualsLiteral
(
kFileMime
)
&
&
XRE_IsContentProcess
(
)
)
{
hasFileData
=
false
;
continue
;
}
else
{
if
(
type
.
EqualsLiteral
(
kFileMime
)
&
&
!
XRE_IsContentProcess
(
)
)
{
hasFileData
=
true
;
}
CacheExternalData
(
type
.
get
(
)
0
aPrincipal
!
type
.
EqualsLiteral
(
kFileMime
)
&
&
hasFileData
)
;
}
}
}
void
DataTransfer
:
:
FillAllExternalData
(
)
{
if
(
mIsExternal
)
{
for
(
uint32_t
i
=
0
;
i
<
MozItemCount
(
)
;
+
+
i
)
{
const
nsTArray
<
RefPtr
<
DataTransferItem
>
>
&
items
=
*
mItems
-
>
MozItemsAt
(
i
)
;
for
(
uint32_t
j
=
0
;
j
<
items
.
Length
(
)
;
+
+
j
)
{
MOZ_ASSERT
(
items
[
j
]
-
>
Index
(
)
=
=
i
)
;
items
[
j
]
-
>
FillInExternalData
(
)
;
}
}
}
}
void
DataTransfer
:
:
FillInExternalCustomTypes
(
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
)
{
RefPtr
<
DataTransferItem
>
item
=
new
DataTransferItem
(
this
NS_LITERAL_STRING_FROM_CSTRING
(
kCustomTypesMime
)
DataTransferItem
:
:
KIND_STRING
)
;
item
-
>
SetIndex
(
aIndex
)
;
nsCOMPtr
<
nsIVariant
>
variant
=
item
-
>
DataNoSecurityCheck
(
)
;
if
(
!
variant
)
{
return
;
}
FillInExternalCustomTypes
(
variant
aIndex
aPrincipal
)
;
}
void
DataTransfer
:
:
FillInExternalCustomTypes
(
nsIVariant
*
aData
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
)
{
char
*
chrs
;
uint32_t
len
=
0
;
nsresult
rv
=
aData
-
>
GetAsStringWithSize
(
&
len
&
chrs
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CheckedInt
<
int32_t
>
checkedLen
(
len
)
;
if
(
!
checkedLen
.
isValid
(
)
)
{
return
;
}
nsCOMPtr
<
nsIInputStream
>
stringStream
;
NS_NewByteInputStream
(
getter_AddRefs
(
stringStream
)
Span
(
chrs
checkedLen
.
value
(
)
)
NS_ASSIGNMENT_ADOPT
)
;
nsCOMPtr
<
nsIObjectInputStream
>
stream
=
NS_NewObjectInputStream
(
stringStream
)
;
uint32_t
type
;
do
{
rv
=
stream
-
>
Read32
(
&
type
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
type
=
=
eCustomClipboardTypeId_String
)
{
uint32_t
formatLength
;
rv
=
stream
-
>
Read32
(
&
formatLength
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
char
*
formatBytes
;
rv
=
stream
-
>
ReadBytes
(
formatLength
&
formatBytes
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoString
format
;
format
.
Adopt
(
reinterpret_cast
<
char16_t
*
>
(
formatBytes
)
formatLength
/
sizeof
(
char16_t
)
)
;
uint32_t
dataLength
;
rv
=
stream
-
>
Read32
(
&
dataLength
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
char
*
dataBytes
;
rv
=
stream
-
>
ReadBytes
(
dataLength
&
dataBytes
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
nsAutoString
data
;
data
.
Adopt
(
reinterpret_cast
<
char16_t
*
>
(
dataBytes
)
dataLength
/
sizeof
(
char16_t
)
)
;
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
rv
=
variant
-
>
SetAsAString
(
data
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
SetDataWithPrincipal
(
format
variant
aIndex
aPrincipal
)
;
}
}
while
(
type
!
=
eCustomClipboardTypeId_None
)
;
}
void
DataTransfer
:
:
SetMode
(
DataTransfer
:
:
Mode
aMode
)
{
if
(
!
StaticPrefs
:
:
dom_events_dataTransfer_protected_enabled
(
)
&
&
aMode
=
=
Mode
:
:
Protected
)
{
mMode
=
Mode
:
:
ReadOnly
;
}
else
{
mMode
=
aMode
;
}
}
void
DataTransfer
:
:
IPCDataTransferTextItemsToDataTransfer
(
const
IPCDataTransfer
&
aIpcDataTransfer
const
bool
aHidden
DataTransfer
&
aDataTransfer
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_ASSERT
(
aDataTransfer
.
Items
(
)
-
>
Length
(
)
=
=
0
)
;
uint32_t
i
=
0
;
for
(
const
IPCDataTransferItem
&
item
:
aIpcDataTransfer
.
items
(
)
)
{
if
(
item
.
data
(
)
.
type
(
)
!
=
IPCDataTransferData
:
:
TIPCDataTransferString
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Expected
transferable
item
to
be
a
string
"
)
;
continue
;
}
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
nsresult
rv
=
nsContentUtils
:
:
IPCTransferableItemToVariant
(
item
variant
ContentChild
:
:
GetSingleton
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
aDataTransfer
.
SetDataWithPrincipalFromOtherProcess
(
NS_ConvertUTF8toUTF16
(
item
.
flavor
(
)
)
variant
i
nsContentUtils
:
:
GetSystemPrincipal
(
)
aHidden
)
;
}
}
}
