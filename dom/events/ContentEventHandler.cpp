#
include
"
ContentEventHandler
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLUnknownElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
<
algorithm
>
#
if
defined
(
small
)
#
undef
small
#
endif
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
void
ContentEventHandler
:
:
RawRange
:
:
AssertStartIsBeforeOrEqualToEnd
(
)
{
MOZ_ASSERT
(
*
nsContentUtils
:
:
ComparePoints
(
mStart
.
Container
(
)
*
mStart
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
mEnd
.
Container
(
)
*
mEnd
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
<
=
0
)
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetStart
(
const
RawRangeBoundary
&
aStart
)
{
nsINode
*
newRoot
=
RangeUtils
:
:
ComputeRootNode
(
aStart
.
Container
(
)
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aStart
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
!
IsPositioned
(
)
|
|
newRoot
!
=
mRoot
)
{
mRoot
=
newRoot
;
mStart
=
mEnd
=
aStart
;
return
NS_OK
;
}
mStart
=
aStart
;
AssertStartIsBeforeOrEqualToEnd
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetEnd
(
const
RawRangeBoundary
&
aEnd
)
{
nsINode
*
newRoot
=
RangeUtils
:
:
ComputeRootNode
(
aEnd
.
Container
(
)
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
!
IsPositioned
(
)
|
|
newRoot
!
=
mRoot
)
{
mRoot
=
newRoot
;
mStart
=
mEnd
=
aEnd
;
return
NS_OK
;
}
mEnd
=
aEnd
;
AssertStartIsBeforeOrEqualToEnd
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetEndAfter
(
nsINode
*
aEndContainer
)
{
return
SetEnd
(
RangeUtils
:
:
GetRawRangeBoundaryAfter
(
aEndContainer
)
)
;
}
void
ContentEventHandler
:
:
RawRange
:
:
SetStartAndEnd
(
const
nsRange
*
aRange
)
{
DebugOnly
<
nsresult
>
rv
=
SetStartAndEnd
(
aRange
-
>
StartRef
(
)
.
AsRaw
(
)
aRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
MOZ_ASSERT
(
!
aRange
-
>
IsPositioned
(
)
|
|
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetStartAndEnd
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
nsINode
*
newStartRoot
=
RangeUtils
:
:
ComputeRootNode
(
aStart
.
Container
(
)
)
;
if
(
!
newStartRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aStart
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aStart
.
Container
(
)
=
=
aEnd
.
Container
(
)
)
{
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
MOZ_ASSERT
(
*
aStart
.
Offset
(
RawRangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
<
=
*
aEnd
.
Offset
(
RawRangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
)
;
mRoot
=
newStartRoot
;
mStart
=
aStart
;
mEnd
=
aEnd
;
return
NS_OK
;
}
nsINode
*
newEndRoot
=
RangeUtils
:
:
ComputeRootNode
(
aEnd
.
Container
(
)
)
;
if
(
!
newEndRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
newStartRoot
!
=
newEndRoot
)
{
mRoot
=
newEndRoot
;
mStart
=
mEnd
=
aEnd
;
return
NS_OK
;
}
mRoot
=
newStartRoot
;
mStart
=
aStart
;
mEnd
=
aEnd
;
AssertStartIsBeforeOrEqualToEnd
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SelectNodeContents
(
const
nsINode
*
aNodeToSelectContents
)
{
nsINode
*
const
newRoot
=
RangeUtils
:
:
ComputeRootNode
(
const_cast
<
nsINode
*
>
(
aNodeToSelectContents
)
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
mRoot
=
newRoot
;
mStart
=
RawRangeBoundary
(
const_cast
<
nsINode
*
>
(
aNodeToSelectContents
)
nullptr
)
;
mEnd
=
RawRangeBoundary
(
const_cast
<
nsINode
*
>
(
aNodeToSelectContents
)
aNodeToSelectContents
-
>
GetLastChild
(
)
)
;
return
NS_OK
;
}
ContentEventHandler
:
:
ContentEventHandler
(
nsPresContext
*
aPresContext
)
:
mDocument
(
aPresContext
-
>
Document
(
)
)
{
}
nsresult
ContentEventHandler
:
:
InitBasic
(
bool
aRequireFlush
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
if
(
aRequireFlush
)
{
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
InitRootContent
(
const
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
aNormalSelection
.
RangeCount
(
)
)
{
mRootElement
=
Element
:
:
FromNodeOrNull
(
aNormalSelection
.
GetAncestorLimiter
(
)
)
;
if
(
!
mRootElement
)
{
mRootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
return
NS_OK
;
}
RefPtr
<
const
nsRange
>
range
(
aNormalSelection
.
GetRangeAt
(
0
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsINode
>
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
startNode
-
>
GetComposedDoc
(
)
!
=
mDocument
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
startNode
-
>
GetComposedDoc
(
)
=
=
endNode
-
>
GetComposedDoc
(
)
"
firstNormalSelectionRange
crosses
the
document
boundary
"
)
;
RefPtr
<
PresShell
>
presShell
=
mDocument
-
>
GetPresShell
(
)
;
mRootElement
=
Element
:
:
FromNodeOrNull
(
startNode
-
>
GetSelectionRootContent
(
presShell
)
)
;
if
(
NS_WARN_IF
(
!
mRootElement
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
InitCommon
(
EventMessage
aEventMessage
SelectionType
aSelectionType
bool
aRequireFlush
)
{
if
(
mSelection
&
&
mSelection
-
>
Type
(
)
=
=
aSelectionType
)
{
return
NS_OK
;
}
mSelection
=
nullptr
;
mRootElement
=
nullptr
;
mFirstSelectedRawRange
.
Clear
(
)
;
nsresult
rv
=
InitBasic
(
aRequireFlush
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsFrameSelection
>
frameSel
;
if
(
PresShell
*
presShell
=
mDocument
-
>
GetPresShell
(
)
)
{
frameSel
=
presShell
-
>
GetLastFocusedFrameSelection
(
)
;
}
if
(
NS_WARN_IF
(
!
frameSel
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mSelection
=
frameSel
-
>
GetSelection
(
aSelectionType
)
;
if
(
NS_WARN_IF
(
!
mSelection
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
Selection
>
normalSelection
;
if
(
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
normalSelection
=
mSelection
;
}
else
{
normalSelection
=
frameSel
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
normalSelection
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
rv
=
InitRootContent
(
*
normalSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mSelection
-
>
RangeCount
(
)
)
{
mFirstSelectedRawRange
.
SetStartAndEnd
(
mSelection
-
>
GetRangeAt
(
0
)
)
;
return
NS_OK
;
}
if
(
aSelectionType
!
=
SelectionType
:
:
eNormal
|
|
aEventMessage
=
=
eQuerySelectedText
)
{
MOZ_ASSERT
(
!
mFirstSelectedRawRange
.
IsPositioned
(
)
)
;
return
NS_OK
;
}
rv
=
mFirstSelectedRawRange
.
CollapseTo
(
RawRangeBoundary
(
mRootElement
0u
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
Init
(
WidgetQueryContentEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
MOZ_ASSERT
(
aEvent
-
>
mMessage
=
=
eQuerySelectedText
|
|
aEvent
-
>
mInput
.
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
IsValidOffset
(
)
)
|
|
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
IsValidEventMessage
(
aEvent
-
>
mMessage
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SelectionType
selectionType
=
aEvent
-
>
mMessage
=
=
eQuerySelectedText
?
aEvent
-
>
mInput
.
mSelectionType
:
SelectionType
:
:
eNormal
;
if
(
NS_WARN_IF
(
selectionType
=
=
SelectionType
:
:
eNone
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InitCommon
(
aEvent
-
>
mMessage
selectionType
aEvent
-
>
NeedsToFlushLayout
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEvent
-
>
mInput
.
mRelativeToInsertionPoint
)
{
MOZ_ASSERT
(
selectionType
=
=
SelectionType
:
:
eNormal
)
;
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
aEvent
-
>
mWidget
)
;
if
(
composition
)
{
uint32_t
compositionStart
=
composition
-
>
NativeOffsetOfStartComposition
(
)
;
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
MakeOffsetAbsolute
(
compositionStart
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
uint32_t
selectionStart
=
0
;
rv
=
GetStartOffset
(
mFirstSelectedRawRange
&
selectionStart
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
MakeOffsetAbsolute
(
selectionStart
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
aEvent
-
>
EmplaceReply
(
)
;
aEvent
-
>
mReply
-
>
mContentsRoot
=
mRootElement
.
get
(
)
;
aEvent
-
>
mReply
-
>
mIsEditableContent
=
mRootElement
&
&
mRootElement
-
>
IsEditable
(
)
;
nsRect
r
;
nsIFrame
*
frame
=
nsCaret
:
:
GetGeometry
(
mSelection
&
r
)
;
if
(
!
frame
)
{
frame
=
mRootElement
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aEvent
-
>
mReply
-
>
mFocusedWidget
=
frame
-
>
GetNearestWidget
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
Init
(
WidgetSelectionEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitCommon
(
aEvent
-
>
mMessage
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mSucceeded
=
false
;
return
NS_OK
;
}
nsIContent
*
ContentEventHandler
:
:
GetFocusedContent
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
return
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
}
nsresult
ContentEventHandler
:
:
QueryContentRect
(
nsIContent
*
aContent
WidgetQueryContentEvent
*
aEvent
)
{
MOZ_ASSERT
(
aContent
"
aContent
must
not
be
null
"
)
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
nsRect
resultRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
nsresult
rv
=
ConvertToRootRelativeOffset
(
frame
resultRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
while
(
(
frame
=
frame
-
>
GetNextContinuation
(
)
)
)
{
nsRect
frameRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
frame
frameRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
resultRect
.
UnionRect
(
resultRect
frameRect
)
;
}
aEvent
-
>
mReply
-
>
mRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
resultRect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
EnsureNonEmptyRect
(
aEvent
-
>
mReply
-
>
mRect
)
;
return
NS_OK
;
}
static
bool
IsContentBR
(
const
nsIContent
&
aContent
)
{
const
HTMLBRElement
*
brElement
=
HTMLBRElement
:
:
FromNode
(
aContent
)
;
return
brElement
&
&
!
brElement
-
>
IsPaddingForEmptyLastLine
(
)
&
&
!
brElement
-
>
IsPaddingForEmptyEditor
(
)
;
}
static
bool
IsPaddingBR
(
const
nsIContent
&
aContent
)
{
return
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsContentBR
(
aContent
)
;
}
static
void
ConvertToNativeNewlines
(
nsString
&
aString
)
{
#
if
defined
(
XP_WIN
)
aString
.
ReplaceSubstring
(
u
"
\
n
"
_ns
u
"
\
r
\
n
"
_ns
)
;
#
endif
}
static
void
AppendString
(
nsString
&
aString
const
Text
&
aTextNode
)
{
const
uint32_t
oldXPLength
=
aString
.
Length
(
)
;
aTextNode
.
TextFragment
(
)
.
AppendTo
(
aString
)
;
if
(
aTextNode
.
HasFlag
(
NS_MAYBE_MASKED
)
)
{
TextEditor
:
:
MaskString
(
aString
aTextNode
oldXPLength
0
)
;
}
}
static
void
AppendSubString
(
nsString
&
aString
const
Text
&
aTextNode
uint32_t
aXPOffset
uint32_t
aXPLength
)
{
const
uint32_t
oldXPLength
=
aString
.
Length
(
)
;
aTextNode
.
TextFragment
(
)
.
AppendTo
(
aString
aXPOffset
aXPLength
)
;
if
(
aTextNode
.
HasFlag
(
NS_MAYBE_MASKED
)
)
{
TextEditor
:
:
MaskString
(
aString
aTextNode
oldXPLength
aXPOffset
)
;
}
}
#
if
defined
(
XP_WIN
)
static
uint32_t
CountNewlinesInXPLength
(
const
Text
&
aTextNode
uint32_t
aXPLength
)
{
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
aXPLength
=
=
UINT32_MAX
|
|
aXPLength
<
=
textFragment
.
GetLength
(
)
"
aXPLength
is
out
-
of
-
bounds
"
)
;
const
uint32_t
length
=
std
:
:
min
(
aXPLength
textFragment
.
GetLength
(
)
)
;
uint32_t
newlines
=
0
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
textFragment
.
CharAt
(
i
)
=
=
'
\
n
'
)
{
+
+
newlines
;
}
}
return
newlines
;
}
static
uint32_t
CountNewlinesInNativeLength
(
const
Text
&
aTextNode
uint32_t
aNativeLength
)
{
const
nsTextFragment
&
textFragment
=
aTextNode
.
TextFragment
(
)
;
MOZ_ASSERT
(
(
aNativeLength
=
=
UINT32_MAX
|
|
aNativeLength
<
=
textFragment
.
GetLength
(
)
*
2
)
"
aNativeLength
is
unexpected
value
"
)
;
const
uint32_t
xpLength
=
textFragment
.
GetLength
(
)
;
uint32_t
newlines
=
0
;
for
(
uint32_t
i
=
0
nativeOffset
=
0
;
i
<
xpLength
&
&
nativeOffset
<
aNativeLength
;
+
+
i
+
+
nativeOffset
)
{
MOZ_ASSERT
(
i
<
xpLength
"
i
is
out
-
of
-
bounds
"
)
;
if
(
textFragment
.
CharAt
(
i
)
=
=
'
\
n
'
)
{
+
+
newlines
;
+
+
nativeOffset
;
}
}
return
newlines
;
}
#
endif
uint32_t
ContentEventHandler
:
:
GetNativeTextLength
(
const
Text
&
aTextNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
{
MOZ_ASSERT
(
aEndOffset
>
=
aStartOffset
"
aEndOffset
must
be
equals
or
larger
than
aStartOffset
"
)
;
if
(
aStartOffset
=
=
aEndOffset
)
{
return
0
;
}
return
GetTextLength
(
aTextNode
LINE_BREAK_TYPE_NATIVE
aEndOffset
)
-
GetTextLength
(
aTextNode
LINE_BREAK_TYPE_NATIVE
aStartOffset
)
;
}
uint32_t
ContentEventHandler
:
:
GetNativeTextLength
(
const
Text
&
aTextNode
uint32_t
aMaxLength
)
{
return
GetTextLength
(
aTextNode
LINE_BREAK_TYPE_NATIVE
aMaxLength
)
;
}
uint32_t
ContentEventHandler
:
:
GetBRLength
(
LineBreakType
aLineBreakType
)
{
#
if
defined
(
XP_WIN
)
return
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
?
2
:
1
;
#
else
return
1
;
#
endif
}
uint32_t
ContentEventHandler
:
:
GetTextLength
(
const
Text
&
aTextNode
LineBreakType
aLineBreakType
uint32_t
aMaxLength
)
{
const
uint32_t
textLengthDifference
=
#
if
defined
(
XP_WIN
)
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
?
CountNewlinesInXPLength
(
aTextNode
aMaxLength
)
:
0
;
#
else
0
;
#
endif
const
uint32_t
length
=
std
:
:
min
(
aTextNode
.
TextFragment
(
)
.
GetLength
(
)
aMaxLength
)
;
return
length
+
textLengthDifference
;
}
static
uint32_t
ConvertToXPOffset
(
const
Text
&
aTextNode
uint32_t
aNativeOffset
)
{
#
if
defined
(
XP_WIN
)
return
aNativeOffset
-
CountNewlinesInNativeLength
(
aTextNode
aNativeOffset
)
;
#
else
return
aNativeOffset
;
#
endif
}
bool
ContentEventHandler
:
:
ShouldBreakLineBefore
(
const
nsIContent
&
aContent
const
Element
*
aRootElement
)
{
if
(
&
aContent
=
=
aRootElement
)
{
return
false
;
}
if
(
!
aContent
.
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
aContent
.
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
IsContentBR
(
aContent
)
;
}
if
(
aContent
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
b
nsGkAtoms
:
:
bdi
nsGkAtoms
:
:
bdo
nsGkAtoms
:
:
big
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
code
nsGkAtoms
:
:
data
nsGkAtoms
:
:
del
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
em
nsGkAtoms
:
:
font
nsGkAtoms
:
:
i
nsGkAtoms
:
:
ins
nsGkAtoms
:
:
kbd
nsGkAtoms
:
:
mark
nsGkAtoms
:
:
s
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
small
nsGkAtoms
:
:
span
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
time
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
u
nsGkAtoms
:
:
var
)
)
{
return
false
;
}
RefPtr
<
HTMLUnknownElement
>
unknownHTMLElement
=
do_QueryObject
(
const_cast
<
nsIContent
*
>
(
&
aContent
)
)
;
return
!
unknownHTMLElement
;
}
nsresult
ContentEventHandler
:
:
GenerateFlatTextContent
(
const
Element
*
aElement
nsString
&
aString
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aString
.
IsEmpty
(
)
)
;
RawRange
rawRange
;
nsresult
rv
=
rawRange
.
SelectNodeContents
(
aElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
GenerateFlatTextContent
(
rawRange
aString
aLineBreakType
)
;
}
nsresult
ContentEventHandler
:
:
GenerateFlatTextContent
(
const
RawRange
&
aRawRange
nsString
&
aString
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aString
.
IsEmpty
(
)
)
;
if
(
aRawRange
.
Collapsed
(
)
)
{
return
NS_OK
;
}
nsINode
*
startNode
=
aRawRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRawRange
.
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startNode
=
=
endNode
&
&
startNode
-
>
IsText
(
)
)
{
AppendSubString
(
aString
*
startNode
-
>
AsText
(
)
aRawRange
.
StartOffset
(
)
aRawRange
.
EndOffset
(
)
-
aRawRange
.
StartOffset
(
)
)
;
ConvertToNativeNewlines
(
aString
)
;
return
NS_OK
;
}
PreContentIterator
preOrderIter
;
nsresult
rv
=
preOrderIter
.
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
!
preOrderIter
.
IsDone
(
)
;
preOrderIter
.
Next
(
)
)
{
nsINode
*
node
=
preOrderIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
if
(
const
Text
*
textNode
=
Text
:
:
FromNode
(
node
)
)
{
if
(
textNode
=
=
startNode
)
{
AppendSubString
(
aString
*
textNode
aRawRange
.
StartOffset
(
)
textNode
-
>
TextLength
(
)
-
aRawRange
.
StartOffset
(
)
)
;
}
else
if
(
textNode
=
=
endNode
)
{
AppendSubString
(
aString
*
textNode
0
aRawRange
.
EndOffset
(
)
)
;
}
else
{
AppendString
(
aString
*
textNode
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
*
node
-
>
AsContent
(
)
mRootElement
)
)
{
aString
.
Append
(
char16_t
(
'
\
n
'
)
)
;
}
}
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
ConvertToNativeNewlines
(
aString
)
;
}
return
NS_OK
;
}
static
FontRange
*
AppendFontRange
(
nsTArray
<
FontRange
>
&
aFontRanges
uint32_t
aBaseOffset
)
{
FontRange
*
fontRange
=
aFontRanges
.
AppendElement
(
)
;
fontRange
-
>
mStartOffset
=
aBaseOffset
;
return
fontRange
;
}
uint32_t
ContentEventHandler
:
:
GetTextLengthInRange
(
const
Text
&
aTextNode
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
{
return
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
?
GetNativeTextLength
(
aTextNode
aXPStartOffset
aXPEndOffset
)
:
aXPEndOffset
-
aXPStartOffset
;
}
void
ContentEventHandler
:
:
AppendFontRanges
(
FontRangeArray
&
aFontRanges
const
Text
&
aTextNode
uint32_t
aBaseOffset
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
{
nsIFrame
*
frame
=
aTextNode
.
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
AppendFontRange
(
aFontRanges
aBaseOffset
)
;
return
;
}
uint32_t
baseOffset
=
aBaseOffset
;
#
ifdef
DEBUG
{
nsTextFrame
*
text
=
do_QueryFrame
(
frame
)
;
MOZ_ASSERT
(
text
"
Not
a
text
frame
"
)
;
}
#
endif
auto
*
curr
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
while
(
curr
)
{
uint32_t
frameXPStart
=
std
:
:
max
(
static_cast
<
uint32_t
>
(
curr
-
>
GetContentOffset
(
)
)
aXPStartOffset
)
;
uint32_t
frameXPEnd
=
std
:
:
min
(
static_cast
<
uint32_t
>
(
curr
-
>
GetContentEnd
(
)
)
aXPEndOffset
)
;
if
(
frameXPStart
>
=
frameXPEnd
)
{
curr
=
curr
-
>
GetNextContinuation
(
)
;
continue
;
}
gfxSkipCharsIterator
iter
=
curr
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
curr
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
*
next
=
nullptr
;
if
(
frameXPEnd
<
aXPEndOffset
)
{
next
=
curr
-
>
GetNextContinuation
(
)
;
while
(
next
&
&
next
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
textRun
)
{
frameXPEnd
=
std
:
:
min
(
static_cast
<
uint32_t
>
(
next
-
>
GetContentEnd
(
)
)
aXPEndOffset
)
;
next
=
frameXPEnd
<
aXPEndOffset
?
next
-
>
GetNextContinuation
(
)
:
nullptr
;
}
}
gfxTextRun
:
:
Range
skipRange
(
iter
.
ConvertOriginalToSkipped
(
frameXPStart
)
iter
.
ConvertOriginalToSkipped
(
frameXPEnd
)
)
;
uint32_t
lastXPEndOffset
=
frameXPStart
;
for
(
gfxTextRun
:
:
GlyphRunIterator
runIter
(
textRun
skipRange
)
;
!
runIter
.
AtEnd
(
)
;
runIter
.
NextRun
(
)
)
{
gfxFont
*
font
=
runIter
.
GlyphRun
(
)
-
>
mFont
.
get
(
)
;
uint32_t
startXPOffset
=
iter
.
ConvertSkippedToOriginal
(
runIter
.
StringStart
(
)
)
;
if
(
startXPOffset
>
=
frameXPEnd
)
{
break
;
}
if
(
startXPOffset
>
lastXPEndOffset
)
{
AppendFontRange
(
aFontRanges
baseOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aTextNode
lastXPEndOffset
startXPOffset
aLineBreakType
)
;
}
FontRange
*
fontRange
=
AppendFontRange
(
aFontRanges
baseOffset
)
;
fontRange
-
>
mFontName
.
Append
(
NS_ConvertUTF8toUTF16
(
font
-
>
GetName
(
)
)
)
;
ParentLayerToScreenScale2D
cumulativeResolution
=
ParentLayerToParentLayerScale
(
frame
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleCrossProcessForFrameMetrics
(
frame
)
;
float
scale
=
std
:
:
max
(
cumulativeResolution
.
xScale
cumulativeResolution
.
yScale
)
;
fontRange
-
>
mFontSize
=
font
-
>
GetAdjustedSize
(
)
*
scale
;
uint32_t
endXPOffset
=
iter
.
ConvertSkippedToOriginal
(
runIter
.
StringEnd
(
)
)
;
endXPOffset
=
std
:
:
min
(
frameXPEnd
endXPOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aTextNode
startXPOffset
endXPOffset
aLineBreakType
)
;
lastXPEndOffset
=
endXPOffset
;
}
if
(
lastXPEndOffset
<
frameXPEnd
)
{
AppendFontRange
(
aFontRanges
baseOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aTextNode
lastXPEndOffset
frameXPEnd
aLineBreakType
)
;
}
curr
=
next
;
}
}
nsresult
ContentEventHandler
:
:
GenerateFlatFontRanges
(
const
RawRange
&
aRawRange
FontRangeArray
&
aFontRanges
uint32_t
&
aLength
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aFontRanges
.
IsEmpty
(
)
"
aRanges
must
be
empty
array
"
)
;
if
(
aRawRange
.
Collapsed
(
)
)
{
return
NS_OK
;
}
nsINode
*
startNode
=
aRawRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRawRange
.
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
baseOffset
=
0
;
PreContentIterator
preOrderIter
;
nsresult
rv
=
preOrderIter
.
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
!
preOrderIter
.
IsDone
(
)
;
preOrderIter
.
Next
(
)
)
{
nsINode
*
node
=
preOrderIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
const
Text
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
const
uint32_t
startOffset
=
textNode
!
=
startNode
?
0
:
aRawRange
.
StartOffset
(
)
;
const
uint32_t
endOffset
=
textNode
!
=
endNode
?
textNode
-
>
TextLength
(
)
:
aRawRange
.
EndOffset
(
)
;
AppendFontRanges
(
aFontRanges
*
textNode
baseOffset
startOffset
endOffset
aLineBreakType
)
;
baseOffset
+
=
GetTextLengthInRange
(
*
textNode
startOffset
endOffset
aLineBreakType
)
;
}
else
if
(
ShouldBreakLineBefore
(
*
content
mRootElement
)
)
{
if
(
aFontRanges
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
baseOffset
=
=
0
)
;
FontRange
*
fontRange
=
AppendFontRange
(
aFontRanges
baseOffset
)
;
if
(
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
)
{
const
nsFont
&
font
=
frame
-
>
GetParent
(
)
-
>
StyleFont
(
)
-
>
mFont
;
const
StyleFontFamilyList
&
fontList
=
font
.
family
.
families
;
MOZ_ASSERT
(
!
fontList
.
list
.
IsEmpty
(
)
"
Empty
font
family
?
"
)
;
const
StyleSingleFontFamily
*
fontName
=
fontList
.
list
.
IsEmpty
(
)
?
nullptr
:
&
fontList
.
list
.
AsSpan
(
)
[
0
]
;
nsAutoCString
name
;
if
(
fontName
)
{
fontName
-
>
AppendToString
(
name
false
)
;
}
AppendUTF8toUTF16
(
name
fontRange
-
>
mFontName
)
;
ParentLayerToScreenScale2D
cumulativeResolution
=
ParentLayerToParentLayerScale
(
frame
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleCrossProcessForFrameMetrics
(
frame
)
;
float
scale
=
std
:
:
max
(
cumulativeResolution
.
xScale
cumulativeResolution
.
yScale
)
;
fontRange
-
>
mFontSize
=
frame
-
>
PresContext
(
)
-
>
CSSPixelsToDevPixels
(
font
.
size
.
ToCSSPixels
(
)
*
scale
)
;
}
}
baseOffset
+
=
GetBRLength
(
aLineBreakType
)
;
}
}
aLength
=
baseOffset
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
ExpandToClusterBoundary
(
Text
&
aTextNode
bool
aForward
uint32_t
*
aXPOffset
)
const
{
if
(
*
aXPOffset
=
=
0
|
|
*
aXPOffset
=
=
aTextNode
.
TextLength
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
*
aXPOffset
<
=
aTextNode
.
TextLength
(
)
"
offset
is
out
of
range
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mDocument
-
>
GetPresShell
(
)
)
;
int32_t
offsetInFrame
;
CaretAssociationHint
hint
=
aForward
?
CARET_ASSOCIATE_BEFORE
:
CARET_ASSOCIATE_AFTER
;
nsIFrame
*
frame
=
nsFrameSelection
:
:
GetFrameForNodeOffset
(
&
aTextNode
int32_t
(
*
aXPOffset
)
hint
&
offsetInFrame
)
;
if
(
frame
)
{
auto
[
startOffset
endOffset
]
=
frame
-
>
GetOffsets
(
)
;
if
(
*
aXPOffset
=
=
static_cast
<
uint32_t
>
(
startOffset
)
|
|
*
aXPOffset
=
=
static_cast
<
uint32_t
>
(
endOffset
)
)
{
return
NS_OK
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
int32_t
newOffsetInFrame
=
*
aXPOffset
-
startOffset
;
newOffsetInFrame
+
=
aForward
?
-
1
:
1
;
nsTextFrame
:
:
PeekOffsetCharacterOptions
options
;
options
.
mRespectClusters
=
true
;
options
.
mIgnoreUserStyleAll
=
true
;
if
(
textFrame
-
>
PeekOffsetCharacter
(
aForward
&
newOffsetInFrame
options
)
=
=
nsIFrame
:
:
FOUND
)
{
*
aXPOffset
=
startOffset
+
newOffsetInFrame
;
return
NS_OK
;
}
}
if
(
aTextNode
.
TextFragment
(
)
.
IsLowSurrogateFollowingHighSurrogateAt
(
*
aXPOffset
)
)
{
*
aXPOffset
+
=
aForward
?
1
:
-
1
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
SetRawRangeFromFlatTextOffset
(
RawRange
*
aRawRange
uint32_t
aOffset
uint32_t
aLength
LineBreakType
aLineBreakType
bool
aExpandToClusterBoundaries
uint32_t
*
aNewOffset
Text
*
*
aLastTextNode
)
{
if
(
aNewOffset
)
{
*
aNewOffset
=
aOffset
;
}
if
(
aLastTextNode
)
{
*
aLastTextNode
=
nullptr
;
}
if
(
!
mRootElement
-
>
HasChildren
(
)
)
{
nsresult
rv
=
aRawRange
-
>
CollapseTo
(
RawRangeBoundary
(
mRootElement
0u
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
PreContentIterator
preOrderIter
;
nsresult
rv
=
preOrderIter
.
Init
(
mRootElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint32_t
offset
=
0
;
uint32_t
endOffset
=
aOffset
+
aLength
;
bool
startSet
=
false
;
for
(
;
!
preOrderIter
.
IsDone
(
)
;
preOrderIter
.
Next
(
)
)
{
nsINode
*
node
=
preOrderIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
node
=
=
mRootElement
|
|
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
const
content
=
node
-
>
AsContent
(
)
;
Text
*
const
contentAsText
=
Text
:
:
FromNode
(
content
)
;
if
(
aLastTextNode
&
&
contentAsText
)
{
NS_IF_RELEASE
(
*
aLastTextNode
)
;
NS_ADDREF
(
*
aLastTextNode
=
contentAsText
)
;
}
uint32_t
textLength
=
contentAsText
?
GetTextLength
(
*
contentAsText
aLineBreakType
)
:
(
ShouldBreakLineBefore
(
*
content
mRootElement
)
?
GetBRLength
(
aLineBreakType
)
:
0
)
;
if
(
!
textLength
)
{
continue
;
}
if
(
!
startSet
&
&
aOffset
<
=
offset
+
textLength
)
{
nsINode
*
startNode
=
nullptr
;
Maybe
<
uint32_t
>
startNodeOffset
;
if
(
contentAsText
)
{
uint32_t
xpOffset
=
aOffset
-
offset
;
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
xpOffset
=
ConvertToXPOffset
(
*
contentAsText
xpOffset
)
;
}
if
(
aExpandToClusterBoundaries
)
{
const
uint32_t
oldXPOffset
=
xpOffset
;
nsresult
rv
=
ExpandToClusterBoundary
(
*
contentAsText
false
&
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aNewOffset
)
{
*
aNewOffset
-
=
(
oldXPOffset
-
xpOffset
)
;
}
}
startNode
=
contentAsText
;
startNodeOffset
=
Some
(
xpOffset
)
;
}
else
if
(
aOffset
<
offset
+
textLength
)
{
startNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startNodeOffset
=
startNode
-
>
ComputeIndexOf
(
content
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
startNodeOffset
.
isNothing
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
content
-
>
HasChildren
(
)
)
{
startNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startNodeOffset
=
startNode
-
>
ComputeIndexOf
(
content
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
startNodeOffset
.
isNothing
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
*
startNodeOffset
!
=
UINT32_MAX
)
;
+
+
(
*
startNodeOffset
)
;
}
else
{
startNode
=
content
;
startNodeOffset
=
Some
(
0
)
;
}
NS_ASSERTION
(
startNode
"
startNode
must
not
be
nullptr
"
)
;
MOZ_ASSERT
(
startNodeOffset
.
isSome
(
)
"
startNodeOffset
must
not
be
Nothing
"
)
;
rv
=
aRawRange
-
>
SetStart
(
startNode
*
startNodeOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
startSet
=
true
;
if
(
!
aLength
)
{
rv
=
aRawRange
-
>
SetEnd
(
startNode
*
startNodeOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
if
(
endOffset
<
=
offset
+
textLength
)
{
MOZ_ASSERT
(
startSet
"
The
start
of
the
range
should
'
ve
been
set
already
"
)
;
if
(
contentAsText
)
{
uint32_t
xpOffset
=
endOffset
-
offset
;
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
const
uint32_t
xpOffsetCurrent
=
ConvertToXPOffset
(
*
contentAsText
xpOffset
)
;
if
(
xpOffset
&
&
GetBRLength
(
aLineBreakType
)
>
1
)
{
MOZ_ASSERT
(
GetBRLength
(
aLineBreakType
)
=
=
2
)
;
const
uint32_t
xpOffsetPre
=
ConvertToXPOffset
(
*
contentAsText
xpOffset
-
1
)
;
if
(
xpOffsetPre
=
=
xpOffsetCurrent
)
{
xpOffset
=
xpOffsetCurrent
+
1
;
}
else
{
xpOffset
=
xpOffsetCurrent
;
}
}
}
if
(
aExpandToClusterBoundaries
)
{
nsresult
rv
=
ExpandToClusterBoundary
(
*
contentAsText
true
&
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
NS_ASSERTION
(
xpOffset
<
=
INT32_MAX
"
The
end
node
offset
is
too
large
"
)
;
nsresult
rv
=
aRawRange
-
>
SetEnd
(
contentAsText
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
endOffset
=
=
offset
)
{
MOZ_ASSERT
(
false
"
This
case
should
'
ve
already
been
handled
at
"
"
the
last
node
which
caused
some
text
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
content
-
>
HasChildren
(
)
&
&
ShouldBreakLineBefore
(
*
content
mRootElement
)
)
{
rv
=
aRawRange
-
>
SetEnd
(
content
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsINode
*
endNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
const
Maybe
<
uint32_t
>
indexInParent
=
endNode
-
>
ComputeIndexOf
(
content
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
indexInParent
.
isNothing
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
*
indexInParent
!
=
UINT32_MAX
)
;
rv
=
aRawRange
-
>
SetEnd
(
endNode
*
indexInParent
+
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
offset
+
=
textLength
;
}
if
(
!
startSet
)
{
if
(
!
offset
)
{
rv
=
aRawRange
-
>
SetStart
(
mRootElement
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aLength
)
{
rv
=
aRawRange
-
>
SetEnd
(
mRootElement
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
else
{
rv
=
aRawRange
-
>
SetStart
(
mRootElement
mRootElement
-
>
GetChildCount
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aNewOffset
)
{
*
aNewOffset
=
offset
;
}
}
rv
=
aRawRange
-
>
SetEnd
(
mRootElement
mRootElement
-
>
GetChildCount
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
WidgetQueryContentEvent
*
aEvent
)
{
return
GetLineBreakType
(
aEvent
-
>
mUseNativeLineBreak
)
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
WidgetSelectionEvent
*
aEvent
)
{
return
GetLineBreakType
(
aEvent
-
>
mUseNativeLineBreak
)
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
bool
aUseNativeLineBreak
)
{
return
aUseNativeLineBreak
?
LINE_BREAK_TYPE_NATIVE
:
LINE_BREAK_TYPE_XP
;
}
nsresult
ContentEventHandler
:
:
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
NS_ERROR_NOT_IMPLEMENTED
;
switch
(
aEvent
-
>
mMessage
)
{
case
eQuerySelectedText
:
rv
=
OnQuerySelectedText
(
aEvent
)
;
break
;
case
eQueryTextContent
:
rv
=
OnQueryTextContent
(
aEvent
)
;
break
;
case
eQueryCaretRect
:
rv
=
OnQueryCaretRect
(
aEvent
)
;
break
;
case
eQueryTextRect
:
rv
=
OnQueryTextRect
(
aEvent
)
;
break
;
case
eQueryTextRectArray
:
rv
=
OnQueryTextRectArray
(
aEvent
)
;
break
;
case
eQueryEditorRect
:
rv
=
OnQueryEditorRect
(
aEvent
)
;
break
;
case
eQueryContentState
:
rv
=
OnQueryContentState
(
aEvent
)
;
break
;
case
eQuerySelectionAsTransferable
:
rv
=
OnQuerySelectionAsTransferable
(
aEvent
)
;
break
;
case
eQueryCharacterAtPoint
:
rv
=
OnQueryCharacterAtPoint
(
aEvent
)
;
break
;
case
eQueryDOMWidgetHittest
:
rv
=
OnQueryDOMWidgetHittest
(
aEvent
)
;
break
;
default
:
break
;
}
if
(
NS_FAILED
(
rv
)
)
{
aEvent
-
>
mReply
.
reset
(
)
;
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
static
Result
<
nsIFrame
*
nsresult
>
GetFrameForTextRect
(
const
nsINode
*
aNode
int32_t
aNodeOffset
bool
aHint
)
{
const
nsIContent
*
content
=
nsIContent
:
:
FromNodeOrNull
(
aNode
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
int32_t
childNodeOffset
=
0
;
nsIFrame
*
returnFrame
=
nullptr
;
nsresult
rv
=
frame
-
>
GetChildFrameContainingOffset
(
aNodeOffset
aHint
&
childNodeOffset
&
returnFrame
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
return
returnFrame
;
}
nsresult
ContentEventHandler
:
:
OnQuerySelectedText
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mOffsetAndData
.
isNothing
(
)
)
;
if
(
!
mFirstSelectedRawRange
.
IsPositioned
(
)
)
{
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mOffsetAndData
.
isNothing
(
)
)
;
MOZ_ASSERT_IF
(
mSelection
!
mSelection
-
>
RangeCount
(
)
)
;
return
NS_OK
;
}
nsINode
*
const
startNode
=
mFirstSelectedRawRange
.
GetStartContainer
(
)
;
nsINode
*
const
endNode
=
mFirstSelectedRawRange
.
GetEndContainer
(
)
;
if
(
!
startNode
-
>
IsInclusiveDescendantOf
(
mRootElement
)
|
|
!
endNode
-
>
IsInclusiveDescendantOf
(
mRootElement
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
uint32_t
startOffset
=
0
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GetStartOffset
(
mFirstSelectedRawRange
&
startOffset
lineBreakType
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
const
RangeBoundary
&
anchorRef
=
mSelection
-
>
RangeCount
(
)
>
0
?
mSelection
-
>
AnchorRef
(
)
:
mFirstSelectedRawRange
.
Start
(
)
;
const
RangeBoundary
&
focusRef
=
mSelection
-
>
RangeCount
(
)
>
0
?
mSelection
-
>
FocusRef
(
)
:
mFirstSelectedRawRange
.
End
(
)
;
if
(
NS_WARN_IF
(
!
anchorRef
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
focusRef
.
IsSet
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mSelection
-
>
RangeCount
(
)
)
{
if
(
mSelection
-
>
RangeCount
(
)
=
=
1
)
{
Maybe
<
int32_t
>
compare
=
nsContentUtils
:
:
ComparePoints
(
anchorRef
focusRef
)
;
if
(
compare
.
isNothing
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
-
>
mReversed
=
compare
.
value
(
)
>
0
;
}
else
{
aEvent
-
>
mReply
-
>
mReversed
=
false
;
}
nsString
selectedString
;
if
(
!
mFirstSelectedRawRange
.
Collapsed
(
)
&
&
NS_WARN_IF
(
NS_FAILED
(
GenerateFlatTextContent
(
mFirstSelectedRawRange
selectedString
lineBreakType
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
-
>
mOffsetAndData
.
emplace
(
startOffset
selectedString
OffsetAndDataFor
:
:
SelectedString
)
;
}
else
{
NS_ASSERTION
(
anchorRef
=
=
focusRef
"
When
mSelection
doesn
'
t
have
selection
"
"
mFirstSelectedRawRange
must
be
collapsed
"
)
;
aEvent
-
>
mReply
-
>
mReversed
=
false
;
aEvent
-
>
mReply
-
>
mOffsetAndData
.
emplace
(
startOffset
EmptyString
(
)
OffsetAndDataFor
:
:
SelectedString
)
;
}
Result
<
nsIFrame
*
nsresult
>
frameForTextRectOrError
=
GetFrameForTextRect
(
focusRef
.
Container
(
)
focusRef
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
.
valueOr
(
0
)
true
)
;
if
(
NS_WARN_IF
(
frameForTextRectOrError
.
isErr
(
)
)
|
|
!
frameForTextRectOrError
.
inspect
(
)
)
{
aEvent
-
>
mReply
-
>
mWritingMode
=
WritingMode
(
)
;
}
else
{
aEvent
-
>
mReply
-
>
mWritingMode
=
frameForTextRectOrError
.
inspect
(
)
-
>
GetWritingMode
(
)
;
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextContent
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mOffsetAndData
.
isNothing
(
)
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
RawRange
rawRange
;
uint32_t
startOffset
=
0
;
if
(
NS_WARN_IF
(
NS_FAILED
(
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mInput
.
mOffset
aEvent
-
>
mInput
.
mLength
lineBreakType
false
&
startOffset
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsString
textInRange
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GenerateFlatTextContent
(
rawRange
textInRange
lineBreakType
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
-
>
mOffsetAndData
.
emplace
(
startOffset
textInRange
OffsetAndDataFor
:
:
EditorString
)
;
if
(
aEvent
-
>
mWithFontRanges
)
{
uint32_t
fontRangeLength
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GenerateFlatFontRanges
(
rawRange
aEvent
-
>
mReply
-
>
mFontRanges
fontRangeLength
lineBreakType
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
fontRangeLength
=
=
aEvent
-
>
mReply
-
>
DataLength
(
)
"
Font
ranges
doesn
'
t
match
the
string
"
)
;
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
void
ContentEventHandler
:
:
EnsureNonEmptyRect
(
nsRect
&
aRect
)
const
{
aRect
.
height
=
std
:
:
max
(
1
aRect
.
height
)
;
aRect
.
width
=
std
:
:
max
(
1
aRect
.
width
)
;
}
void
ContentEventHandler
:
:
EnsureNonEmptyRect
(
LayoutDeviceIntRect
&
aRect
)
const
{
aRect
.
height
=
std
:
:
max
(
1
aRect
.
height
)
;
aRect
.
width
=
std
:
:
max
(
1
aRect
.
width
)
;
}
ContentEventHandler
:
:
FrameAndNodeOffset
ContentEventHandler
:
:
GetFirstFrameInRangeForTextRect
(
const
RawRange
&
aRawRange
)
{
NodePosition
nodePosition
;
PreContentIterator
preOrderIter
;
nsresult
rv
=
preOrderIter
.
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FrameAndNodeOffset
(
)
;
}
for
(
;
!
preOrderIter
.
IsDone
(
)
;
preOrderIter
.
Next
(
)
)
{
nsINode
*
node
=
preOrderIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
auto
*
content
=
nsIContent
:
:
FromNode
(
node
)
;
if
(
MOZ_UNLIKELY
(
!
content
)
)
{
continue
;
}
if
(
!
content
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
if
(
auto
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
const
uint32_t
offsetInNode
=
textNode
=
=
aRawRange
.
GetStartContainer
(
)
?
aRawRange
.
StartOffset
(
)
:
0u
;
if
(
offsetInNode
<
textNode
-
>
TextDataLength
(
)
)
{
nodePosition
=
{
textNode
offsetInNode
}
;
break
;
}
continue
;
}
if
(
ShouldBreakLineBefore
(
*
content
mRootElement
)
|
|
IsPaddingBR
(
*
content
)
)
{
nodePosition
=
{
content
0u
}
;
}
}
if
(
!
nodePosition
.
IsSetAndValid
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
Result
<
nsIFrame
*
nsresult
>
firstFrameOrError
=
GetFrameForTextRect
(
nodePosition
.
Container
(
)
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
true
)
;
if
(
NS_WARN_IF
(
firstFrameOrError
.
isErr
(
)
)
|
|
!
firstFrameOrError
.
inspect
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
return
FrameAndNodeOffset
(
firstFrameOrError
.
inspect
(
)
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
)
;
}
ContentEventHandler
:
:
FrameAndNodeOffset
ContentEventHandler
:
:
GetLastFrameInRangeForTextRect
(
const
RawRange
&
aRawRange
)
{
NodePosition
nodePosition
;
PreContentIterator
preOrderIter
;
nsresult
rv
=
preOrderIter
.
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FrameAndNodeOffset
(
)
;
}
const
RangeBoundary
&
endPoint
=
aRawRange
.
End
(
)
;
MOZ_ASSERT
(
endPoint
.
IsSetAndValid
(
)
)
;
nsINode
*
nextNodeOfRangeEnd
=
nullptr
;
if
(
endPoint
.
Container
(
)
-
>
IsText
(
)
)
{
if
(
endPoint
.
IsStartOfContainer
(
)
&
&
aRawRange
.
GetStartContainer
(
)
!
=
endPoint
.
Container
(
)
)
{
nextNodeOfRangeEnd
=
endPoint
.
Container
(
)
;
}
}
else
if
(
endPoint
.
IsSetAndValid
(
)
)
{
nextNodeOfRangeEnd
=
endPoint
.
GetChildAtOffset
(
)
;
}
for
(
preOrderIter
.
Last
(
)
;
!
preOrderIter
.
IsDone
(
)
;
preOrderIter
.
Prev
(
)
)
{
nsINode
*
node
=
preOrderIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
node
=
=
nextNodeOfRangeEnd
)
{
continue
;
}
auto
*
content
=
nsIContent
:
:
FromNode
(
node
)
;
if
(
MOZ_UNLIKELY
(
!
content
)
)
{
continue
;
}
if
(
!
content
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
if
(
auto
*
textNode
=
Text
:
:
FromNode
(
node
)
)
{
nodePosition
=
{
textNode
textNode
=
=
aRawRange
.
GetEndContainer
(
)
?
aRawRange
.
EndOffset
(
)
:
textNode
-
>
TextDataLength
(
)
}
;
if
(
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
=
=
0
)
{
continue
;
}
break
;
}
if
(
ShouldBreakLineBefore
(
*
content
mRootElement
)
|
|
IsPaddingBR
(
*
content
)
)
{
nodePosition
=
{
content
0u
}
;
break
;
}
}
if
(
!
nodePosition
.
IsSet
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
Result
<
nsIFrame
*
nsresult
>
lastFrameOrError
=
GetFrameForTextRect
(
nodePosition
.
Container
(
)
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
true
)
;
if
(
NS_WARN_IF
(
lastFrameOrError
.
isErr
(
)
)
|
|
!
lastFrameOrError
.
inspect
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
if
(
!
lastFrameOrError
.
inspect
(
)
-
>
IsTextFrame
(
)
)
{
return
FrameAndNodeOffset
(
lastFrameOrError
.
inspect
(
)
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
)
;
}
int32_t
start
=
lastFrameOrError
.
inspect
(
)
-
>
GetOffsets
(
)
.
first
;
if
(
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
&
&
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
=
=
static_cast
<
uint32_t
>
(
start
)
)
{
const
uint32_t
newNodePositionOffset
=
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
;
MOZ_ASSERT
(
newNodePositionOffset
!
=
0
)
;
nodePosition
=
{
nodePosition
.
Container
(
)
newNodePositionOffset
-
1u
}
;
lastFrameOrError
=
GetFrameForTextRect
(
nodePosition
.
Container
(
)
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
true
)
;
if
(
NS_WARN_IF
(
lastFrameOrError
.
isErr
(
)
)
|
|
!
lastFrameOrError
.
inspect
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
}
return
FrameAndNodeOffset
(
lastFrameOrError
.
inspect
(
)
*
nodePosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOffsets
)
)
;
}
ContentEventHandler
:
:
FrameRelativeRect
ContentEventHandler
:
:
GetLineBreakerRectBefore
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
ShouldBreakLineBefore
(
*
aFrame
-
>
GetContent
(
)
mRootElement
)
|
|
IsPaddingBR
(
*
aFrame
-
>
GetContent
(
)
)
)
;
nsIFrame
*
frameForFontMetrics
=
aFrame
;
if
(
!
aFrame
-
>
IsBrFrame
(
)
&
&
aFrame
-
>
GetParent
(
)
)
{
frameForFontMetrics
=
aFrame
-
>
GetParent
(
)
;
}
RefPtr
<
nsFontMetrics
>
fontMetrics
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
frameForFontMetrics
)
;
if
(
NS_WARN_IF
(
!
fontMetrics
)
)
{
return
FrameRelativeRect
(
)
;
}
const
WritingMode
kWritingMode
=
frameForFontMetrics
-
>
GetWritingMode
(
)
;
auto
caretBlockAxisMetrics
=
aFrame
-
>
GetCaretBlockAxisMetrics
(
kWritingMode
*
fontMetrics
)
;
nscoord
inlineOffset
=
0
;
if
(
!
aFrame
-
>
IsBrFrame
(
)
)
{
if
(
kWritingMode
.
IsVertical
(
)
&
&
!
kWritingMode
.
IsLineInverted
(
)
)
{
caretBlockAxisMetrics
.
mOffset
=
aFrame
-
>
GetRect
(
)
.
XMost
(
)
-
caretBlockAxisMetrics
.
mExtent
;
}
else
{
caretBlockAxisMetrics
.
mOffset
=
0
;
}
inlineOffset
=
-
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
}
FrameRelativeRect
result
(
aFrame
)
;
if
(
kWritingMode
.
IsVertical
(
)
)
{
result
.
mRect
.
x
=
caretBlockAxisMetrics
.
mOffset
;
result
.
mRect
.
y
=
inlineOffset
;
result
.
mRect
.
width
=
caretBlockAxisMetrics
.
mExtent
;
}
else
{
result
.
mRect
.
x
=
inlineOffset
;
result
.
mRect
.
y
=
caretBlockAxisMetrics
.
mOffset
;
result
.
mRect
.
height
=
caretBlockAxisMetrics
.
mExtent
;
}
return
result
;
}
ContentEventHandler
:
:
FrameRelativeRect
ContentEventHandler
:
:
GuessLineBreakerRectAfter
(
const
Text
&
aTextNode
)
{
FrameRelativeRect
result
;
const
int32_t
length
=
static_cast
<
int32_t
>
(
aTextNode
.
TextLength
(
)
)
;
if
(
NS_WARN_IF
(
length
<
0
)
)
{
return
result
;
}
Result
<
nsIFrame
*
nsresult
>
lastTextFrameOrError
=
GetFrameForTextRect
(
&
aTextNode
length
true
)
;
if
(
NS_WARN_IF
(
lastTextFrameOrError
.
isErr
(
)
)
|
|
!
lastTextFrameOrError
.
inspect
(
)
)
{
return
result
;
}
const
nsRect
kLastTextFrameRect
=
lastTextFrameOrError
.
inspect
(
)
-
>
GetRect
(
)
;
if
(
lastTextFrameOrError
.
inspect
(
)
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
result
.
mRect
.
SetRect
(
0
kLastTextFrameRect
.
height
kLastTextFrameRect
.
width
0
)
;
}
else
{
result
.
mRect
.
SetRect
(
kLastTextFrameRect
.
width
0
0
kLastTextFrameRect
.
height
)
;
}
result
.
mBaseFrame
=
lastTextFrameOrError
.
unwrap
(
)
;
return
result
;
}
ContentEventHandler
:
:
FrameRelativeRect
ContentEventHandler
:
:
GuessFirstCaretRectIn
(
nsIFrame
*
aFrame
)
{
const
WritingMode
kWritingMode
=
aFrame
-
>
GetWritingMode
(
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
RefPtr
<
nsFontMetrics
>
fontMetrics
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
const
nscoord
kMaxHeight
=
fontMetrics
?
fontMetrics
-
>
MaxHeight
(
)
:
16
*
presContext
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
caretRect
;
const
nsRect
kContentRect
=
aFrame
-
>
GetContentRect
(
)
-
aFrame
-
>
GetPosition
(
)
;
caretRect
.
y
=
kContentRect
.
y
;
if
(
!
kWritingMode
.
IsVertical
(
)
)
{
if
(
kWritingMode
.
IsBidiLTR
(
)
)
{
caretRect
.
x
=
kContentRect
.
x
;
}
else
{
const
nscoord
kOnePixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
caretRect
.
x
=
kContentRect
.
XMost
(
)
-
kOnePixel
;
}
caretRect
.
height
=
kMaxHeight
;
caretRect
.
width
=
1
;
}
else
{
if
(
kWritingMode
.
IsVerticalLR
(
)
)
{
caretRect
.
x
=
kContentRect
.
x
;
}
else
{
caretRect
.
x
=
kContentRect
.
XMost
(
)
-
kMaxHeight
;
}
caretRect
.
width
=
kMaxHeight
;
caretRect
.
height
=
1
;
}
return
FrameRelativeRect
(
caretRect
aFrame
)
;
}
LayoutDeviceIntRect
ContentEventHandler
:
:
GetCaretRectBefore
(
const
LayoutDeviceIntRect
&
aCharRect
const
WritingMode
&
aWritingMode
)
{
LayoutDeviceIntRect
caretRectBefore
(
aCharRect
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
caretRectBefore
.
height
=
1
;
}
else
{
caretRectBefore
.
width
=
1
;
}
return
caretRectBefore
;
}
nsRect
ContentEventHandler
:
:
GetCaretRectBefore
(
const
nsRect
&
aCharRect
const
WritingMode
&
aWritingMode
)
{
nsRect
caretRectBefore
(
aCharRect
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
caretRectBefore
.
height
=
1
;
}
else
{
caretRectBefore
.
width
=
1
;
}
return
caretRectBefore
;
}
LayoutDeviceIntRect
ContentEventHandler
:
:
GetCaretRectAfter
(
const
LayoutDeviceIntRect
&
aCharRect
const
WritingMode
&
aWritingMode
)
{
LayoutDeviceIntRect
caretRectAfter
(
aCharRect
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
caretRectAfter
.
y
=
aCharRect
.
YMost
(
)
+
1
;
caretRectAfter
.
height
=
1
;
}
else
{
caretRectAfter
.
x
=
aCharRect
.
XMost
(
)
+
1
;
caretRectAfter
.
width
=
1
;
}
return
caretRectAfter
;
}
nsRect
ContentEventHandler
:
:
GetCaretRectAfter
(
nsPresContext
&
aPresContext
const
nsRect
&
aCharRect
const
WritingMode
&
aWritingMode
)
{
nsRect
caretRectAfter
(
aCharRect
)
;
const
nscoord
onePixel
=
aPresContext
.
AppUnitsPerDevPixel
(
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
caretRectAfter
.
y
=
aCharRect
.
YMost
(
)
+
onePixel
;
caretRectAfter
.
height
=
1
;
}
else
{
caretRectAfter
.
x
=
aCharRect
.
XMost
(
)
+
onePixel
;
caretRectAfter
.
width
=
1
;
}
return
caretRectAfter
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextRectArray
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mOffsetAndData
.
isNothing
(
)
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
const
uint32_t
kBRLength
=
GetBRLength
(
lineBreakType
)
;
WritingMode
lastVisibleFrameWritingMode
;
LayoutDeviceIntRect
rect
;
uint32_t
offset
=
aEvent
-
>
mInput
.
mOffset
;
const
uint32_t
kEndOffset
=
aEvent
-
>
mInput
.
EndOffset
(
)
;
bool
wasLineBreaker
=
false
;
nsRect
lastCharRect
;
nsIFrame
*
lastFrame
=
nullptr
;
nsAutoString
flattenedAllText
;
flattenedAllText
.
SetIsVoid
(
true
)
;
while
(
offset
<
kEndOffset
)
{
RefPtr
<
Text
>
lastTextNode
;
RawRange
rawRange
;
nsresult
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
offset
1
lineBreakType
true
nullptr
getter_AddRefs
(
lastTextNode
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
rawRange
.
Collapsed
(
)
)
{
break
;
}
FrameAndNodeOffset
firstFrame
=
GetFirstFrameInRangeForTextRect
(
rawRange
)
;
if
(
!
firstFrame
.
IsValid
(
)
)
{
if
(
flattenedAllText
.
IsVoid
(
)
)
{
flattenedAllText
.
SetIsVoid
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GenerateFlatTextContent
(
mRootElement
flattenedAllText
lineBreakType
)
)
)
)
{
NS_WARNING
(
"
ContentEventHandler
:
:
GenerateFlatTextContent
(
)
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
}
if
(
offset
>
=
flattenedAllText
.
Length
(
)
)
{
break
;
}
const
uint32_t
remainingLengthInCurrentRange
=
[
&
]
(
)
{
if
(
lastTextNode
)
{
if
(
rawRange
.
GetStartContainer
(
)
=
=
lastTextNode
)
{
if
(
rawRange
.
StartOffset
(
)
<
lastTextNode
-
>
TextDataLength
(
)
)
{
return
lastTextNode
-
>
TextDataLength
(
)
-
rawRange
.
StartOffset
(
)
;
}
return
0u
;
}
return
lastTextNode
-
>
TextDataLength
(
)
;
}
if
(
rawRange
.
GetStartContainer
(
)
&
&
rawRange
.
GetStartContainer
(
)
-
>
IsContent
(
)
&
&
ShouldBreakLineBefore
(
*
rawRange
.
GetStartContainer
(
)
-
>
AsContent
(
)
mRootElement
)
)
{
if
(
kBRLength
!
=
1u
&
&
offset
-
aEvent
-
>
mInput
.
mOffset
<
kBRLength
)
{
return
1u
;
}
return
kBRLength
;
}
return
0u
;
}
(
)
;
offset
+
=
std
:
:
max
(
1u
remainingLengthInCurrentRange
)
;
continue
;
}
nsIContent
*
firstContent
=
firstFrame
.
mFrame
-
>
GetContent
(
)
;
if
(
NS_WARN_IF
(
!
firstContent
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
startsBetweenLineBreaker
=
false
;
nsAutoString
chars
;
lastVisibleFrameWritingMode
=
firstFrame
-
>
GetWritingMode
(
)
;
nsIFrame
*
baseFrame
=
firstFrame
;
AutoTArray
<
nsRect
16
>
charRects
;
if
(
firstFrame
-
>
IsTextFrame
(
)
)
{
rv
=
firstFrame
-
>
GetCharacterRectsInRange
(
firstFrame
.
mOffsetInNode
kEndOffset
-
offset
charRects
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
charRects
.
IsEmpty
(
)
)
)
{
return
rv
;
}
AppendSubString
(
chars
*
firstContent
-
>
AsText
(
)
firstFrame
.
mOffsetInNode
charRects
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
chars
.
Length
(
)
!
=
charRects
.
Length
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
kBRLength
>
1
&
&
chars
[
0
]
=
=
'
\
n
'
&
&
offset
=
=
aEvent
-
>
mInput
.
mOffset
&
&
offset
)
{
RawRange
rawRangeToPrevOffset
;
nsresult
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRangeToPrevOffset
aEvent
-
>
mInput
.
mOffset
-
1
1
lineBreakType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
startsBetweenLineBreaker
=
rawRange
.
GetStartContainer
(
)
=
=
rawRangeToPrevOffset
.
GetStartContainer
(
)
&
&
rawRange
.
StartOffset
(
)
=
=
rawRangeToPrevOffset
.
StartOffset
(
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
*
firstContent
mRootElement
)
|
|
IsPaddingBR
(
*
firstContent
)
)
{
nsRect
brRect
;
if
(
!
firstFrame
-
>
IsBrFrame
(
)
&
&
!
aEvent
-
>
mReply
-
>
mRectArray
.
IsEmpty
(
)
)
{
baseFrame
=
lastFrame
;
brRect
=
lastCharRect
;
if
(
!
wasLineBreaker
)
{
brRect
=
GetCaretRectAfter
(
*
baseFrame
-
>
PresContext
(
)
brRect
lastVisibleFrameWritingMode
)
;
}
}
else
if
(
!
firstFrame
-
>
IsBrFrame
(
)
&
&
lastTextNode
&
&
lastTextNode
-
>
GetPrimaryFrame
(
)
)
{
FrameRelativeRect
brRectRelativeToLastTextFrame
=
GuessLineBreakerRectAfter
(
*
lastTextNode
)
;
if
(
NS_WARN_IF
(
!
brRectRelativeToLastTextFrame
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
primaryFrame
=
lastTextNode
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
primaryFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
baseFrame
=
primaryFrame
-
>
LastContinuation
(
)
;
if
(
NS_WARN_IF
(
!
baseFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
brRect
=
brRectRelativeToLastTextFrame
.
RectRelativeTo
(
baseFrame
)
;
}
else
{
FrameRelativeRect
relativeBRRect
=
GetLineBreakerRectBefore
(
firstFrame
)
;
brRect
=
relativeBRRect
.
RectRelativeTo
(
firstFrame
)
;
}
charRects
.
AppendElement
(
brRect
)
;
chars
.
AssignLiteral
(
"
\
n
"
)
;
if
(
kBRLength
>
1
&
&
offset
=
=
aEvent
-
>
mInput
.
mOffset
&
&
offset
)
{
nsresult
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mInput
.
mOffset
-
1
1
lineBreakType
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
FrameAndNodeOffset
frameForPrevious
=
GetFirstFrameInRangeForTextRect
(
rawRange
)
;
startsBetweenLineBreaker
=
frameForPrevious
.
mFrame
=
=
firstFrame
.
mFrame
;
}
}
else
{
NS_WARNING
(
"
The
frame
is
neither
a
text
frame
nor
a
frame
whose
content
"
"
causes
a
line
break
"
)
;
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
charRects
.
Length
(
)
&
&
offset
<
kEndOffset
;
i
+
+
)
{
nsRect
charRect
=
charRects
[
i
]
;
lastCharRect
=
charRect
;
lastFrame
=
baseFrame
;
rv
=
ConvertToRootRelativeOffset
(
baseFrame
charRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsPresContext
*
presContext
=
baseFrame
-
>
PresContext
(
)
;
rect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
charRect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
nsPresContext
*
rootContext
=
presContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
)
{
rect
=
RoundedOut
(
ViewportUtils
:
:
DocumentRelativeLayoutToVisual
(
rect
rootContext
-
>
PresShell
(
)
)
)
;
}
EnsureNonEmptyRect
(
rect
)
;
if
(
i
=
=
0u
&
&
MOZ_LIKELY
(
offset
>
aEvent
-
>
mInput
.
mOffset
)
)
{
const
uint32_t
offsetInRange
=
offset
-
CheckedInt
<
uint32_t
>
(
aEvent
-
>
mInput
.
mOffset
)
.
value
(
)
;
if
(
offsetInRange
>
aEvent
-
>
mReply
-
>
mRectArray
.
Length
(
)
)
{
LayoutDeviceIntRect
caretRectBefore
=
GetCaretRectBefore
(
rect
lastVisibleFrameWritingMode
)
;
for
(
[
[
maybe_unused
]
]
uint32_t
index
:
IntegerRange
<
uint32_t
>
(
offsetInRange
-
aEvent
-
>
mReply
-
>
mRectArray
.
Length
(
)
)
)
{
aEvent
-
>
mReply
-
>
mRectArray
.
AppendElement
(
caretRectBefore
)
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mRectArray
.
Length
(
)
=
=
offsetInRange
)
;
}
}
aEvent
-
>
mReply
-
>
mRectArray
.
AppendElement
(
rect
)
;
offset
+
+
;
wasLineBreaker
=
chars
[
i
]
=
=
'
\
n
'
;
if
(
!
wasLineBreaker
|
|
kBRLength
=
=
1
)
{
continue
;
}
MOZ_ASSERT
(
kBRLength
=
=
2
)
;
if
(
offset
=
=
kEndOffset
)
{
break
;
}
if
(
startsBetweenLineBreaker
)
{
continue
;
}
aEvent
-
>
mReply
-
>
mRectArray
.
AppendElement
(
rect
)
;
offset
+
+
;
}
}
if
(
!
aEvent
-
>
mReply
-
>
mRectArray
.
IsEmpty
(
)
)
{
const
uint32_t
offsetInRange
=
offset
-
CheckedInt
<
uint32_t
>
(
aEvent
-
>
mInput
.
mOffset
)
.
value
(
)
;
if
(
offsetInRange
>
aEvent
-
>
mReply
-
>
mRectArray
.
Length
(
)
)
{
LayoutDeviceIntRect
caretRectAfter
=
GetCaretRectAfter
(
aEvent
-
>
mReply
-
>
mRectArray
.
LastElement
(
)
lastVisibleFrameWritingMode
)
;
for
(
[
[
maybe_unused
]
]
uint32_t
index
:
IntegerRange
<
uint32_t
>
(
offsetInRange
-
aEvent
-
>
mReply
-
>
mRectArray
.
Length
(
)
)
)
{
aEvent
-
>
mReply
-
>
mRectArray
.
AppendElement
(
caretRectAfter
)
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mRectArray
.
Length
(
)
=
=
offsetInRange
)
;
}
}
if
(
offset
<
kEndOffset
|
|
aEvent
-
>
mReply
-
>
mRectArray
.
IsEmpty
(
)
)
{
if
(
!
aEvent
-
>
mReply
-
>
mRectArray
.
IsEmpty
(
)
&
&
!
wasLineBreaker
)
{
rect
=
GetCaretRectAfter
(
aEvent
-
>
mReply
-
>
mRectArray
.
LastElement
(
)
lastVisibleFrameWritingMode
)
;
aEvent
-
>
mReply
-
>
mRectArray
.
AppendElement
(
rect
)
;
}
else
{
WidgetQueryContentEvent
queryTextRectEvent
(
eQueryTextRect
*
aEvent
)
;
WidgetQueryContentEvent
:
:
Options
options
(
*
aEvent
)
;
queryTextRectEvent
.
InitForQueryTextRect
(
offset
1
options
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
OnQueryTextRect
(
&
queryTextRectEvent
)
)
)
|
|
NS_WARN_IF
(
queryTextRectEvent
.
Failed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
queryTextRectEvent
.
mReply
-
>
mWritingMode
.
IsVertical
(
)
)
{
queryTextRectEvent
.
mReply
-
>
mRect
.
height
=
1
;
}
else
{
queryTextRectEvent
.
mReply
-
>
mRect
.
width
=
1
;
}
aEvent
-
>
mReply
-
>
mRectArray
.
AppendElement
(
queryTextRectEvent
.
mReply
-
>
mRect
)
;
}
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextRect
(
WidgetQueryContentEvent
*
aEvent
)
{
if
(
!
aEvent
-
>
mInput
.
mLength
)
{
return
OnQueryCaretRect
(
aEvent
)
;
}
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mOffsetAndData
.
isNothing
(
)
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
RawRange
rawRange
;
RefPtr
<
Text
>
lastTextNode
;
uint32_t
startOffset
=
0
;
if
(
NS_WARN_IF
(
NS_FAILED
(
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mInput
.
mOffset
aEvent
-
>
mInput
.
mLength
lineBreakType
true
&
startOffset
getter_AddRefs
(
lastTextNode
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsString
string
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GenerateFlatTextContent
(
rawRange
string
lineBreakType
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
-
>
mOffsetAndData
.
emplace
(
startOffset
string
OffsetAndDataFor
:
:
EditorString
)
;
PostContentIterator
postOrderIter
;
rv
=
postOrderIter
.
Init
(
rawRange
.
Start
(
)
.
AsRaw
(
)
rawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
FrameAndNodeOffset
firstFrame
=
GetFirstFrameInRangeForTextRect
(
rawRange
)
;
if
(
!
firstFrame
.
IsValid
(
)
)
{
nsAutoString
allText
;
rv
=
GenerateFlatTextContent
(
mRootElement
allText
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
static_cast
<
uint32_t
>
(
aEvent
-
>
mInput
.
mOffset
)
<
allText
.
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
rawRange
.
SelectNodeContents
(
mRootElement
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsRect
rect
;
FrameAndNodeOffset
lastFrame
=
GetLastFrameInRangeForTextRect
(
rawRange
)
;
nsPresContext
*
presContext
;
if
(
lastFrame
)
{
presContext
=
lastFrame
-
>
PresContext
(
)
;
if
(
NS_WARN_IF
(
!
lastFrame
-
>
GetContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
FrameRelativeRect
relativeRect
;
if
(
lastFrame
-
>
IsBrFrame
(
)
)
{
relativeRect
=
GetLineBreakerRectBefore
(
lastFrame
)
;
}
else
if
(
lastFrame
-
>
IsTextFrame
(
)
)
{
const
Text
*
textNode
=
Text
:
:
FromNode
(
lastFrame
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
textNode
)
;
if
(
textNode
)
{
relativeRect
=
GuessLineBreakerRectAfter
(
*
textNode
)
;
}
}
else
{
relativeRect
=
GuessFirstCaretRectIn
(
lastFrame
)
;
}
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
relativeRect
.
RectRelativeTo
(
lastFrame
)
;
rv
=
ConvertToRootRelativeOffset
(
lastFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aEvent
-
>
mReply
-
>
mWritingMode
=
lastFrame
-
>
GetWritingMode
(
)
;
}
else
{
nsIFrame
*
rootContentFrame
=
mRootElement
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootContentFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
presContext
=
rootContentFrame
-
>
PresContext
(
)
;
FrameRelativeRect
relativeRect
=
GuessFirstCaretRectIn
(
rootContentFrame
)
;
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
relativeRect
.
RectRelativeTo
(
rootContentFrame
)
;
rv
=
ConvertToRootRelativeOffset
(
rootContentFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aEvent
-
>
mReply
-
>
mWritingMode
=
rootContentFrame
-
>
GetWritingMode
(
)
;
}
aEvent
-
>
mReply
-
>
mRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
rect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
nsPresContext
*
rootContext
=
presContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
)
{
aEvent
-
>
mReply
-
>
mRect
=
RoundedOut
(
ViewportUtils
:
:
DocumentRelativeLayoutToVisual
(
aEvent
-
>
mReply
-
>
mRect
rootContext
-
>
PresShell
(
)
)
)
;
}
EnsureNonEmptyRect
(
aEvent
-
>
mReply
-
>
mRect
)
;
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsRect
rect
frameRect
;
nsPoint
ptOffset
;
if
(
firstFrame
-
>
IsTextFrame
(
)
)
{
rect
.
SetRect
(
nsPoint
(
0
0
)
firstFrame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
firstFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
frameRect
=
rect
;
firstFrame
-
>
GetPointFromOffset
(
firstFrame
.
mOffsetInNode
&
ptOffset
)
;
if
(
firstFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
rect
.
y
+
=
ptOffset
.
y
;
rect
.
height
-
=
ptOffset
.
y
;
}
else
{
rect
.
x
+
=
ptOffset
.
x
;
rect
.
width
-
=
ptOffset
.
x
;
}
}
else
if
(
!
firstFrame
-
>
IsBrFrame
(
)
&
&
lastTextNode
&
&
lastTextNode
-
>
GetPrimaryFrame
(
)
)
{
FrameRelativeRect
brRectAfterLastChar
=
GuessLineBreakerRectAfter
(
*
lastTextNode
)
;
if
(
NS_WARN_IF
(
!
brRectAfterLastChar
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
brRectAfterLastChar
.
mRect
;
rv
=
ConvertToRootRelativeOffset
(
brRectAfterLastChar
.
mBaseFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
frameRect
=
rect
;
}
else
{
FrameRelativeRect
relativeRect
=
GetLineBreakerRectBefore
(
firstFrame
)
;
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
relativeRect
.
RectRelativeTo
(
firstFrame
)
;
rv
=
ConvertToRootRelativeOffset
(
firstFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
frameRect
=
rect
;
}
EnsureNonEmptyRect
(
rect
)
;
FrameAndNodeOffset
lastFrame
=
GetLastFrameInRangeForTextRect
(
rawRange
)
;
if
(
NS_WARN_IF
(
!
lastFrame
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
nsIFrame
*
frame
=
firstFrame
;
frame
!
=
lastFrame
;
)
{
frame
=
frame
-
>
GetNextContinuation
(
)
;
if
(
!
frame
)
{
do
{
postOrderIter
.
Next
(
)
;
nsINode
*
node
=
postOrderIter
.
GetCurrentNode
(
)
;
if
(
!
node
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIFrame
*
primaryFrame
=
node
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
!
primaryFrame
)
{
continue
;
}
if
(
primaryFrame
-
>
IsTextFrame
(
)
|
|
primaryFrame
-
>
IsBrFrame
(
)
)
{
frame
=
primaryFrame
;
}
}
while
(
!
frame
&
&
!
postOrderIter
.
IsDone
(
)
)
;
if
(
!
frame
)
{
break
;
}
}
if
(
frame
-
>
IsTextFrame
(
)
)
{
frameRect
.
SetRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
}
else
{
MOZ_ASSERT
(
frame
-
>
IsBrFrame
(
)
)
;
FrameRelativeRect
relativeRect
=
GetLineBreakerRectBefore
(
frame
)
;
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
frameRect
=
relativeRect
.
RectRelativeTo
(
frame
)
;
}
rv
=
ConvertToRootRelativeOffset
(
frame
frameRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
EnsureNonEmptyRect
(
frameRect
)
;
if
(
frame
!
=
lastFrame
)
{
rect
.
UnionRect
(
rect
frameRect
)
;
}
}
if
(
firstFrame
.
mFrame
!
=
lastFrame
.
mFrame
)
{
frameRect
.
SetRect
(
nsPoint
(
0
0
)
lastFrame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
lastFrame
frameRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
lastFrame
-
>
IsTextFrame
(
)
)
{
lastFrame
-
>
GetPointFromOffset
(
lastFrame
.
mOffsetInNode
&
ptOffset
)
;
if
(
lastFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
frameRect
.
height
-
=
lastFrame
-
>
GetRect
(
)
.
height
-
ptOffset
.
y
;
}
else
{
frameRect
.
width
-
=
lastFrame
-
>
GetRect
(
)
.
width
-
ptOffset
.
x
;
}
EnsureNonEmptyRect
(
frameRect
)
;
if
(
firstFrame
.
mFrame
=
=
lastFrame
.
mFrame
)
{
rect
.
IntersectRect
(
rect
frameRect
)
;
}
else
{
rect
.
UnionRect
(
rect
frameRect
)
;
}
}
nsPresContext
*
presContext
=
lastFrame
-
>
PresContext
(
)
;
aEvent
-
>
mReply
-
>
mRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
rect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
nsPresContext
*
rootContext
=
presContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
)
{
aEvent
-
>
mReply
-
>
mRect
=
RoundedOut
(
ViewportUtils
:
:
DocumentRelativeLayoutToVisual
(
aEvent
-
>
mReply
-
>
mRect
rootContext
-
>
PresShell
(
)
)
)
;
}
EnsureNonEmptyRect
(
aEvent
-
>
mReply
-
>
mRect
)
;
aEvent
-
>
mReply
-
>
mWritingMode
=
lastFrame
-
>
GetWritingMode
(
)
;
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryEditorRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
QueryContentRect
(
mRootElement
aEvent
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryCaretRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mSelection
-
>
IsCollapsed
(
)
)
{
nsRect
caretRect
;
nsIFrame
*
caretFrame
=
nsCaret
:
:
GetGeometry
(
mSelection
&
caretRect
)
;
if
(
caretFrame
)
{
uint32_t
offset
;
rv
=
GetStartOffset
(
mFirstSelectedRawRange
&
offset
GetLineBreakType
(
aEvent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
aEvent
-
>
mInput
.
mOffset
)
{
rv
=
ConvertToRootRelativeOffset
(
caretFrame
caretRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsPresContext
*
presContext
=
caretFrame
-
>
PresContext
(
)
;
aEvent
-
>
mReply
-
>
mRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
caretRect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
nsPresContext
*
rootContext
=
presContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
)
{
aEvent
-
>
mReply
-
>
mRect
=
RoundedOut
(
ViewportUtils
:
:
DocumentRelativeLayoutToVisual
(
aEvent
-
>
mReply
-
>
mRect
rootContext
-
>
PresShell
(
)
)
)
;
}
EnsureNonEmptyRect
(
aEvent
-
>
mReply
-
>
mRect
)
;
aEvent
-
>
mReply
-
>
mWritingMode
=
caretFrame
-
>
GetWritingMode
(
)
;
aEvent
-
>
mReply
-
>
mOffsetAndData
.
emplace
(
aEvent
-
>
mInput
.
mOffset
EmptyString
(
)
OffsetAndDataFor
:
:
SelectedString
)
;
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
}
}
WidgetQueryContentEvent
queryTextRectEvent
(
eQueryTextRect
*
aEvent
)
;
WidgetQueryContentEvent
:
:
Options
options
(
*
aEvent
)
;
queryTextRectEvent
.
InitForQueryTextRect
(
aEvent
-
>
mInput
.
mOffset
1
options
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
OnQueryTextRect
(
&
queryTextRectEvent
)
)
)
|
|
NS_WARN_IF
(
queryTextRectEvent
.
Failed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
queryTextRectEvent
.
mReply
-
>
TruncateData
(
)
;
aEvent
-
>
mReply
-
>
mOffsetAndData
=
std
:
:
move
(
queryTextRectEvent
.
mReply
-
>
mOffsetAndData
)
;
aEvent
-
>
mReply
-
>
mWritingMode
=
std
:
:
move
(
queryTextRectEvent
.
mReply
-
>
mWritingMode
)
;
aEvent
-
>
mReply
-
>
mRect
=
GetCaretRectBefore
(
queryTextRectEvent
.
mReply
-
>
mRect
aEvent
-
>
mReply
-
>
mWritingMode
)
;
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryContentState
(
WidgetQueryContentEvent
*
aEvent
)
{
if
(
NS_FAILED
(
Init
(
aEvent
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
.
isSome
(
)
)
;
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQuerySelectionAsTransferable
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
.
isSome
(
)
)
;
if
(
mSelection
-
>
IsCollapsed
(
)
)
{
MOZ_ASSERT
(
!
aEvent
-
>
mReply
-
>
mTransferable
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
nsCopySupport
:
:
GetTransferableForSelection
(
mSelection
mDocument
getter_AddRefs
(
aEvent
-
>
mReply
-
>
mTransferable
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryCharacterAtPoint
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mOffsetAndData
.
isNothing
(
)
)
;
MOZ_ASSERT
(
aEvent
-
>
mReply
-
>
mTentativeCaretOffset
.
isNothing
(
)
)
;
PresShell
*
presShell
=
mDocument
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
NS_ERROR_FAILURE
)
;
nsIWidget
*
rootWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
rootWidget
NS_ERROR_FAILURE
)
;
if
(
rootWidget
!
=
aEvent
-
>
mWidget
)
{
MOZ_ASSERT
(
aEvent
-
>
mWidget
"
The
event
must
have
the
widget
"
)
;
nsView
*
view
=
nsView
:
:
GetViewFor
(
aEvent
-
>
mWidget
)
;
NS_ENSURE_TRUE
(
view
NS_ERROR_FAILURE
)
;
rootFrame
=
view
-
>
GetFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
NS_ERROR_FAILURE
)
;
rootWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
rootWidget
NS_ERROR_FAILURE
)
;
}
WidgetQueryContentEvent
queryCharAtPointOnRootWidgetEvent
(
true
eQueryCharacterAtPoint
rootWidget
)
;
queryCharAtPointOnRootWidgetEvent
.
mUseNativeLineBreak
=
aEvent
-
>
mUseNativeLineBreak
;
queryCharAtPointOnRootWidgetEvent
.
mRefPoint
=
aEvent
-
>
mRefPoint
;
if
(
rootWidget
!
=
aEvent
-
>
mWidget
)
{
queryCharAtPointOnRootWidgetEvent
.
mRefPoint
+
=
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
-
rootWidget
-
>
WidgetToScreenOffset
(
)
;
}
nsPoint
ptInRoot
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
&
queryCharAtPointOnRootWidgetEvent
RelativeTo
{
rootFrame
}
)
;
nsIFrame
*
targetFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
RelativeTo
{
rootFrame
}
ptInRoot
)
;
if
(
!
targetFrame
|
|
!
targetFrame
-
>
GetContent
(
)
|
|
!
targetFrame
-
>
GetContent
(
)
-
>
IsInclusiveDescendantOf
(
mRootElement
)
)
{
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsPoint
ptInTarget
=
ptInRoot
+
rootFrame
-
>
GetOffsetToCrossDoc
(
targetFrame
)
;
int32_t
rootAPD
=
rootFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
targetAPD
=
targetFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
ptInTarget
=
ptInTarget
.
ScaleToOtherAppUnits
(
rootAPD
targetAPD
)
;
nsIFrame
:
:
ContentOffsets
tentativeCaretOffsets
=
targetFrame
-
>
GetContentOffsetsFromPoint
(
ptInTarget
)
;
if
(
!
tentativeCaretOffsets
.
content
|
|
!
tentativeCaretOffsets
.
content
-
>
IsInclusiveDescendantOf
(
mRootElement
)
)
{
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
uint32_t
tentativeCaretOffset
=
0
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GetFlatTextLengthInRange
(
NodePosition
(
mRootElement
0u
)
NodePosition
(
tentativeCaretOffsets
)
mRootElement
&
tentativeCaretOffset
GetLineBreakType
(
aEvent
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
-
>
mTentativeCaretOffset
.
emplace
(
tentativeCaretOffset
)
;
if
(
!
targetFrame
-
>
IsTextFrame
(
)
)
{
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsTextFrame
*
textframe
=
static_cast
<
nsTextFrame
*
>
(
targetFrame
)
;
nsIFrame
:
:
ContentOffsets
contentOffsets
=
textframe
-
>
GetCharacterOffsetAtFramePoint
(
ptInTarget
)
;
NS_ENSURE_TRUE
(
contentOffsets
.
content
NS_ERROR_FAILURE
)
;
uint32_t
offset
=
0
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GetFlatTextLengthInRange
(
NodePosition
(
mRootElement
0u
)
NodePosition
(
contentOffsets
)
mRootElement
&
offset
GetLineBreakType
(
aEvent
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
WidgetQueryContentEvent
queryTextRectEvent
(
true
eQueryTextRect
aEvent
-
>
mWidget
)
;
WidgetQueryContentEvent
:
:
Options
options
(
*
aEvent
)
;
queryTextRectEvent
.
InitForQueryTextRect
(
offset
1
options
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
OnQueryTextRect
(
&
queryTextRectEvent
)
)
)
|
|
NS_WARN_IF
(
queryTextRectEvent
.
Failed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
-
>
mOffsetAndData
=
std
:
:
move
(
queryTextRectEvent
.
mReply
-
>
mOffsetAndData
)
;
aEvent
-
>
mReply
-
>
mRect
=
queryTextRectEvent
.
mReply
-
>
mRect
;
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryDOMWidgetHittest
(
WidgetQueryContentEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitBasic
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mReply
-
>
mWidgetIsHit
=
false
;
NS_ENSURE_TRUE
(
aEvent
-
>
mWidget
NS_ERROR_FAILURE
)
;
PresShell
*
presShell
=
mDocument
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsIFrame
*
docFrame
=
presShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
docFrame
NS_ERROR_FAILURE
)
;
LayoutDeviceIntPoint
eventLoc
=
aEvent
-
>
mRefPoint
+
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
;
CSSIntRect
docFrameRect
=
docFrame
-
>
GetScreenRect
(
)
;
CSSIntPoint
eventLocCSS
(
docFrame
-
>
PresContext
(
)
-
>
DevPixelsToIntCSSPixels
(
eventLoc
.
x
)
-
docFrameRect
.
x
docFrame
-
>
PresContext
(
)
-
>
DevPixelsToIntCSSPixels
(
eventLoc
.
y
)
-
docFrameRect
.
y
)
;
if
(
Element
*
contentUnderMouse
=
mDocument
-
>
ElementFromPointHelper
(
eventLocCSS
.
x
eventLocCSS
.
y
false
false
ViewportType
:
:
Visual
)
)
{
if
(
nsIFrame
*
targetFrame
=
contentUnderMouse
-
>
GetPrimaryFrame
(
)
)
{
if
(
aEvent
-
>
mWidget
=
=
targetFrame
-
>
GetNearestWidget
(
)
)
{
aEvent
-
>
mReply
-
>
mWidgetIsHit
=
true
;
}
}
}
MOZ_ASSERT
(
aEvent
-
>
Succeeded
(
)
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
const
NodePosition
&
aStartPosition
const
NodePosition
&
aEndPosition
const
Element
*
aRootElement
uint32_t
*
aLength
LineBreakType
aLineBreakType
bool
aIsRemovingNode
)
{
if
(
NS_WARN_IF
(
!
aRootElement
)
|
|
NS_WARN_IF
(
!
aStartPosition
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPosition
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aLength
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aStartPosition
=
=
aEndPosition
)
{
*
aLength
=
0
;
return
NS_OK
;
}
PreContentIterator
preOrderIter
;
NodePosition
endPosition
(
aEndPosition
)
;
if
(
aIsRemovingNode
)
{
DebugOnly
<
nsIContent
*
>
parent
=
aStartPosition
.
Container
(
)
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
&
&
parent
-
>
ComputeIndexOf
(
aStartPosition
.
Container
(
)
)
.
isNothing
(
)
"
At
removing
the
node
the
node
shouldn
'
t
be
in
the
array
of
children
"
"
of
its
parent
"
)
;
MOZ_ASSERT
(
aStartPosition
.
Container
(
)
=
=
endPosition
.
Container
(
)
"
At
removing
the
node
start
and
end
node
should
be
same
"
)
;
MOZ_ASSERT
(
*
aStartPosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
=
=
0
"
When
the
node
is
being
removed
the
start
offset
should
be
0
"
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
*
endPosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
=
=
endPosition
.
Container
(
)
-
>
GetChildCount
(
)
"
When
the
node
is
being
removed
the
end
offset
should
be
child
count
"
)
;
nsresult
rv
=
preOrderIter
.
Init
(
aStartPosition
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
RawRange
prevRawRange
;
nsresult
rv
=
prevRawRange
.
SetStart
(
aStartPosition
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
endPosition
.
Container
(
)
!
=
aRootElement
&
&
endPosition
.
IsImmediatelyAfterOpenTag
(
)
)
{
if
(
endPosition
.
Container
(
)
-
>
HasChildren
(
)
)
{
nsINode
*
firstChild
=
endPosition
.
Container
(
)
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
return
NS_ERROR_FAILURE
;
}
endPosition
=
NodePositionBefore
(
firstChild
0u
)
;
}
else
{
nsIContent
*
parentContent
=
endPosition
.
Container
(
)
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
Maybe
<
uint32_t
>
indexInParent
=
parentContent
-
>
ComputeIndexOf
(
endPosition
.
Container
(
)
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
indexInParent
.
isNothing
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
*
indexInParent
!
=
UINT32_MAX
)
;
endPosition
=
NodePositionBefore
(
parentContent
*
indexInParent
+
1u
)
;
}
}
if
(
endPosition
.
IsSetAndValid
(
)
)
{
rv
=
prevRawRange
.
SetEnd
(
endPosition
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
preOrderIter
.
Init
(
prevRawRange
.
Start
(
)
.
AsRaw
(
)
prevRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
endPosition
.
Container
(
)
!
=
aRootElement
)
{
rv
=
prevRawRange
.
SetEndAfter
(
endPosition
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
preOrderIter
.
Init
(
prevRawRange
.
Start
(
)
.
AsRaw
(
)
prevRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
preOrderIter
.
Init
(
const_cast
<
Element
*
>
(
aRootElement
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
*
aLength
=
0
;
for
(
;
!
preOrderIter
.
IsDone
(
)
;
preOrderIter
.
Next
(
)
)
{
nsINode
*
node
=
preOrderIter
.
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
const
Text
*
textNode
=
Text
:
:
FromNode
(
content
)
)
{
if
(
node
=
=
endPosition
.
Container
(
)
)
{
*
aLength
+
=
GetTextLength
(
*
textNode
aLineBreakType
*
endPosition
.
Offset
(
NodePosition
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
;
}
else
{
*
aLength
+
=
GetTextLength
(
*
textNode
aLineBreakType
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
*
content
aRootElement
)
)
{
if
(
node
=
=
aStartPosition
.
Container
(
)
&
&
!
aStartPosition
.
IsBeforeOpenTag
(
)
)
{
continue
;
}
if
(
node
=
=
endPosition
.
Container
(
)
&
&
endPosition
.
IsBeforeOpenTag
(
)
)
{
continue
;
}
*
aLength
+
=
GetBRLength
(
aLineBreakType
)
;
}
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetStartOffset
(
const
RawRange
&
aRawRange
uint32_t
*
aOffset
LineBreakType
aLineBreakType
)
{
nsINode
*
startNode
=
aRawRange
.
GetStartContainer
(
)
;
bool
startIsContainer
=
true
;
if
(
startNode
-
>
IsHTMLElement
(
)
)
{
nsAtom
*
name
=
startNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
startIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
const
NodePosition
&
startPos
=
startIsContainer
?
NodePosition
(
startNode
aRawRange
.
StartOffset
(
)
)
:
NodePositionBefore
(
startNode
aRawRange
.
StartOffset
(
)
)
;
return
GetFlatTextLengthInRange
(
NodePosition
(
mRootElement
0u
)
startPos
mRootElement
aOffset
aLineBreakType
)
;
}
nsresult
ContentEventHandler
:
:
AdjustCollapsedRangeMaybeIntoTextNode
(
RawRange
&
aRawRange
)
{
MOZ_ASSERT
(
aRawRange
.
Collapsed
(
)
)
;
if
(
!
aRawRange
.
Collapsed
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
RangeBoundary
&
startPoint
=
aRawRange
.
Start
(
)
;
if
(
NS_WARN_IF
(
!
startPoint
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
startPoint
.
Container
(
)
-
>
HasChildren
(
)
)
{
return
NS_OK
;
}
if
(
startPoint
.
IsStartOfContainer
(
)
)
{
if
(
!
startPoint
.
Container
(
)
-
>
GetFirstChild
(
)
-
>
IsText
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRawRange
.
CollapseTo
(
RawRangeBoundary
(
startPoint
.
Container
(
)
-
>
GetFirstChild
(
)
0u
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
!
startPoint
.
IsSetAndValid
(
)
)
{
return
NS_OK
;
}
if
(
!
startPoint
.
Ref
(
)
-
>
IsText
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRawRange
.
CollapseTo
(
RawRangeBoundary
(
startPoint
.
Ref
(
)
startPoint
.
Ref
(
)
-
>
Length
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
ConvertToRootRelativeOffset
(
nsIFrame
*
aFrame
nsRect
&
aRect
)
{
NS_ASSERTION
(
aFrame
"
aFrame
must
not
be
null
"
)
;
nsPresContext
*
thisPC
=
aFrame
-
>
PresContext
(
)
;
nsPresContext
*
rootPC
=
thisPC
-
>
GetRootPresContext
(
)
;
if
(
NS_WARN_IF
(
!
rootPC
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
rootFrame
=
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
aRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
aRect
rootFrame
)
;
aRect
=
aRect
.
ScaleToOtherAppUnitsRoundOut
(
rootPC
-
>
AppUnitsPerDevPixel
(
)
thisPC
-
>
AppUnitsPerDevPixel
(
)
)
;
return
NS_OK
;
}
static
void
AdjustRangeForSelection
(
const
Element
*
aRootElement
nsINode
*
*
aNode
Maybe
<
uint32_t
>
*
aNodeOffset
)
{
nsINode
*
node
=
*
aNode
;
Maybe
<
uint32_t
>
nodeOffset
=
*
aNodeOffset
;
if
(
aRootElement
=
=
node
|
|
NS_WARN_IF
(
!
node
-
>
GetParent
(
)
)
|
|
!
node
-
>
IsText
(
)
)
{
return
;
}
const
uint32_t
textLength
=
node
-
>
AsContent
(
)
-
>
TextLength
(
)
;
MOZ_ASSERT
(
nodeOffset
.
isNothing
(
)
|
|
*
nodeOffset
<
=
textLength
"
Offset
is
past
length
of
text
node
"
)
;
if
(
nodeOffset
.
isNothing
(
)
|
|
*
nodeOffset
!
=
textLength
)
{
return
;
}
Element
*
rootParentElement
=
aRootElement
-
>
GetParentElement
(
)
;
if
(
NS_WARN_IF
(
!
rootParentElement
)
)
{
return
;
}
if
(
!
rootParentElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
textarea
)
)
{
return
;
}
*
aNode
=
node
-
>
GetParent
(
)
;
Maybe
<
uint32_t
>
index
=
(
*
aNode
)
-
>
ComputeIndexOf
(
node
)
;
MOZ_ASSERT
(
index
.
isSome
(
)
)
;
if
(
index
.
isSome
(
)
)
{
MOZ_ASSERT
(
*
index
!
=
UINT32_MAX
)
;
*
aNodeOffset
=
Some
(
*
index
+
1u
)
;
}
else
{
*
aNodeOffset
=
Some
(
0u
)
;
}
}
nsresult
ContentEventHandler
:
:
OnSelectionEvent
(
WidgetSelectionEvent
*
aEvent
)
{
aEvent
-
>
mSucceeded
=
false
;
nsresult
rv
=
IMEStateManager
:
:
GetFocusSelectionAndRootElement
(
getter_AddRefs
(
mSelection
)
getter_AddRefs
(
mRootElement
)
)
;
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
Init
(
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
RawRange
rawRange
;
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mOffset
aEvent
-
>
mLength
GetLineBreakType
(
aEvent
)
aEvent
-
>
mExpandToClusterBoundary
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsINode
*
startNode
=
rawRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
rawRange
.
GetEndContainer
(
)
;
Maybe
<
uint32_t
>
startNodeOffset
=
Some
(
rawRange
.
StartOffset
(
)
)
;
Maybe
<
uint32_t
>
endNodeOffset
=
Some
(
rawRange
.
EndOffset
(
)
)
;
AdjustRangeForSelection
(
mRootElement
&
startNode
&
startNodeOffset
)
;
AdjustRangeForSelection
(
mRootElement
&
endNode
&
endNodeOffset
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
|
|
NS_WARN_IF
(
startNodeOffset
.
isNothing
(
)
)
|
|
NS_WARN_IF
(
endNodeOffset
.
isNothing
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aEvent
-
>
mReversed
)
{
nsCOMPtr
<
nsINode
>
startNodeStrong
(
startNode
)
;
nsCOMPtr
<
nsINode
>
endNodeStrong
(
endNode
)
;
ErrorResult
error
;
MOZ_KnownLive
(
mSelection
)
-
>
SetBaseAndExtentInLimiter
(
*
endNodeStrong
*
endNodeOffset
*
startNodeStrong
*
startNodeOffset
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
{
nsCOMPtr
<
nsINode
>
startNodeStrong
(
startNode
)
;
nsCOMPtr
<
nsINode
>
endNodeStrong
(
endNode
)
;
ErrorResult
error
;
MOZ_KnownLive
(
mSelection
)
-
>
SetBaseAndExtentInLimiter
(
*
startNodeStrong
*
startNodeOffset
*
endNodeStrong
*
endNodeOffset
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
MOZ_KnownLive
(
mSelection
)
-
>
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
ScrollAxis
(
)
ScrollAxis
(
)
0
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsRect
ContentEventHandler
:
:
FrameRelativeRect
:
:
RectRelativeTo
(
nsIFrame
*
aDestFrame
)
const
{
if
(
!
mBaseFrame
|
|
NS_WARN_IF
(
!
aDestFrame
)
)
{
return
nsRect
(
)
;
}
if
(
NS_WARN_IF
(
aDestFrame
-
>
PresContext
(
)
!
=
mBaseFrame
-
>
PresContext
(
)
)
)
{
return
nsRect
(
)
;
}
if
(
aDestFrame
=
=
mBaseFrame
)
{
return
mRect
;
}
nsIFrame
*
rootFrame
=
mBaseFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
baseFrameRectInRootFrame
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
mBaseFrame
nsRect
(
)
rootFrame
)
;
nsRect
destFrameRectInRootFrame
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aDestFrame
nsRect
(
)
rootFrame
)
;
nsPoint
difference
=
destFrameRectInRootFrame
.
TopLeft
(
)
-
baseFrameRectInRootFrame
.
TopLeft
(
)
;
return
mRect
-
difference
;
}
}
