#
include
"
ContentEventHandler
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLUnknownElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIObjectFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
void
ContentEventHandler
:
:
RawRange
:
:
AssertStartIsBeforeOrEqualToEnd
(
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
ComparePoints
(
mStart
.
Container
(
)
static_cast
<
int32_t
>
(
mStart
.
Offset
(
)
)
mEnd
.
Container
(
)
static_cast
<
int32_t
>
(
mEnd
.
Offset
(
)
)
)
<
=
0
)
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetStart
(
const
RawRangeBoundary
&
aStart
)
{
nsINode
*
newRoot
=
nsRange
:
:
ComputeRootNode
(
aStart
.
Container
(
)
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aStart
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
!
IsPositioned
(
)
|
|
newRoot
!
=
mRoot
)
{
mRoot
=
newRoot
;
mStart
=
mEnd
=
aStart
;
return
NS_OK
;
}
mStart
=
aStart
;
AssertStartIsBeforeOrEqualToEnd
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetEnd
(
const
RawRangeBoundary
&
aEnd
)
{
nsINode
*
newRoot
=
nsRange
:
:
ComputeRootNode
(
aEnd
.
Container
(
)
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
!
IsPositioned
(
)
|
|
newRoot
!
=
mRoot
)
{
mRoot
=
newRoot
;
mStart
=
mEnd
=
aEnd
;
return
NS_OK
;
}
mEnd
=
aEnd
;
AssertStartIsBeforeOrEqualToEnd
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetEndAfter
(
nsINode
*
aEndContainer
)
{
uint32_t
offset
=
0
;
nsINode
*
container
=
nsRange
:
:
GetContainerAndOffsetAfter
(
aEndContainer
&
offset
)
;
return
SetEnd
(
container
offset
)
;
}
void
ContentEventHandler
:
:
RawRange
:
:
SetStartAndEnd
(
const
nsRange
*
aRange
)
{
DebugOnly
<
nsresult
>
rv
=
SetStartAndEnd
(
aRange
-
>
StartRef
(
)
.
AsRaw
(
)
aRange
-
>
EndRef
(
)
.
AsRaw
(
)
)
;
MOZ_ASSERT
(
!
aRange
-
>
IsPositioned
(
)
|
|
NS_SUCCEEDED
(
rv
)
)
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SetStartAndEnd
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
nsINode
*
newStartRoot
=
nsRange
:
:
ComputeRootNode
(
aStart
.
Container
(
)
)
;
if
(
!
newStartRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aStart
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aStart
.
Container
(
)
=
=
aEnd
.
Container
(
)
)
{
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
MOZ_ASSERT
(
aStart
.
Offset
(
)
<
=
aEnd
.
Offset
(
)
)
;
mRoot
=
newStartRoot
;
mStart
=
aStart
;
mEnd
=
aEnd
;
return
NS_OK
;
}
nsINode
*
newEndRoot
=
nsRange
:
:
ComputeRootNode
(
aEnd
.
Container
(
)
)
;
if
(
!
newEndRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
newStartRoot
!
=
newEndRoot
)
{
mRoot
=
newEndRoot
;
mStart
=
mEnd
=
aEnd
;
return
NS_OK
;
}
mRoot
=
newStartRoot
;
mStart
=
aStart
;
mEnd
=
aEnd
;
AssertStartIsBeforeOrEqualToEnd
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
RawRange
:
:
SelectNodeContents
(
nsINode
*
aNodeToSelectContents
)
{
nsINode
*
newRoot
=
nsRange
:
:
ComputeRootNode
(
aNodeToSelectContents
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
mRoot
=
newRoot
;
mStart
=
RawRangeBoundary
(
aNodeToSelectContents
nullptr
)
;
mEnd
=
RawRangeBoundary
(
aNodeToSelectContents
aNodeToSelectContents
-
>
GetLastChild
(
)
)
;
return
NS_OK
;
}
ContentEventHandler
:
:
ContentEventHandler
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mPresShell
(
aPresContext
-
>
GetPresShell
(
)
)
{
}
nsresult
ContentEventHandler
:
:
InitBasic
(
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_AVAILABLE
)
;
mPresShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
NS_ENSURE_TRUE
(
!
mPresShell
-
>
IsDestroying
(
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
InitRootContent
(
Selection
*
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
)
;
MOZ_ASSERT
(
aNormalSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
aNormalSelection
-
>
RangeCount
(
)
)
{
nsresult
rv
=
aNormalSelection
-
>
GetAncestorLimiter
(
getter_AddRefs
(
mRootContent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mRootContent
)
{
mRootContent
=
mPresShell
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
mRootContent
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
return
NS_OK
;
}
RefPtr
<
nsRange
>
range
(
aNormalSelection
-
>
GetRangeAt
(
0
)
)
;
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsINode
*
startNode
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
startNode
-
>
GetUncomposedDoc
(
)
!
=
mPresShell
-
>
GetDocument
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
startNode
-
>
GetUncomposedDoc
(
)
=
=
endNode
-
>
GetUncomposedDoc
(
)
"
firstNormalSelectionRange
crosses
the
document
boundary
"
)
;
mRootContent
=
startNode
-
>
GetSelectionRootContent
(
mPresShell
)
;
if
(
NS_WARN_IF
(
!
mRootContent
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
InitCommon
(
SelectionType
aSelectionType
)
{
if
(
mSelection
&
&
mSelection
-
>
Type
(
)
=
=
aSelectionType
)
{
return
NS_OK
;
}
mSelection
=
nullptr
;
mRootContent
=
nullptr
;
mFirstSelectedRawRange
.
Clear
(
)
;
nsresult
rv
=
InitBasic
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISelectionController
>
selectionController
=
mPresShell
-
>
GetSelectionControllerForFocusedContent
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsISelection
>
selection
;
rv
=
selectionController
-
>
GetSelection
(
ToRawSelectionType
(
aSelectionType
)
getter_AddRefs
(
selection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mSelection
=
static_cast
<
Selection
*
>
(
selection
.
get
(
)
)
;
if
(
NS_WARN_IF
(
!
mSelection
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
Selection
>
normalSelection
;
if
(
mSelection
-
>
Type
(
)
=
=
SelectionType
:
:
eNormal
)
{
normalSelection
=
mSelection
;
}
else
{
nsCOMPtr
<
nsISelection
>
domSelection
;
nsresult
rv
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
getter_AddRefs
(
domSelection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
NS_WARN_IF
(
!
domSelection
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
normalSelection
=
domSelection
-
>
AsSelection
(
)
;
if
(
NS_WARN_IF
(
!
normalSelection
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
rv
=
InitRootContent
(
normalSelection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mSelection
-
>
RangeCount
(
)
)
{
mFirstSelectedRawRange
.
SetStartAndEnd
(
mSelection
-
>
GetRangeAt
(
0
)
)
;
return
NS_OK
;
}
if
(
aSelectionType
!
=
SelectionType
:
:
eNormal
)
{
MOZ_ASSERT
(
!
mFirstSelectedRawRange
.
IsPositioned
(
)
)
;
return
NS_OK
;
}
rv
=
mFirstSelectedRawRange
.
CollapseTo
(
RawRangeBoundary
(
mRootContent
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
Init
(
WidgetQueryContentEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
MOZ_ASSERT
(
aEvent
-
>
mMessage
=
=
eQuerySelectedText
|
|
aEvent
-
>
mInput
.
mSelectionType
=
=
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
IsValidOffset
(
)
)
|
|
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
IsValidEventMessage
(
aEvent
-
>
mMessage
)
)
)
{
return
NS_ERROR_FAILURE
;
}
SelectionType
selectionType
=
aEvent
-
>
mMessage
=
=
eQuerySelectedText
?
aEvent
-
>
mInput
.
mSelectionType
:
SelectionType
:
:
eNormal
;
if
(
NS_WARN_IF
(
selectionType
=
=
SelectionType
:
:
eNone
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
InitCommon
(
selectionType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEvent
-
>
mInput
.
mRelativeToInsertionPoint
)
{
MOZ_ASSERT
(
selectionType
=
=
SelectionType
:
:
eNormal
)
;
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
aEvent
-
>
mWidget
)
;
if
(
composition
)
{
uint32_t
compositionStart
=
composition
-
>
NativeOffsetOfStartComposition
(
)
;
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
MakeOffsetAbsolute
(
compositionStart
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
uint32_t
selectionStart
=
0
;
rv
=
GetStartOffset
(
mFirstSelectedRawRange
&
selectionStart
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
MakeOffsetAbsolute
(
selectionStart
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
aEvent
-
>
mSucceeded
=
false
;
aEvent
-
>
mReply
.
mContentsRoot
=
mRootContent
.
get
(
)
;
aEvent
-
>
mReply
.
mHasSelection
=
!
mSelection
-
>
IsCollapsed
(
)
;
nsRect
r
;
nsIFrame
*
frame
=
nsCaret
:
:
GetGeometry
(
mSelection
&
r
)
;
if
(
!
frame
)
{
frame
=
mRootContent
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aEvent
-
>
mReply
.
mFocusedWidget
=
frame
-
>
GetNearestWidget
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
Init
(
WidgetSelectionEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitCommon
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mSucceeded
=
false
;
return
NS_OK
;
}
nsIContent
*
ContentEventHandler
:
:
GetFocusedContent
(
)
{
nsIDocument
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
doc
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
return
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
}
bool
ContentEventHandler
:
:
IsPlugin
(
nsIContent
*
aContent
)
{
return
aContent
&
&
aContent
-
>
GetDesiredIMEState
(
)
.
mEnabled
=
=
IMEState
:
:
PLUGIN
;
}
nsresult
ContentEventHandler
:
:
QueryContentRect
(
nsIContent
*
aContent
WidgetQueryContentEvent
*
aEvent
)
{
NS_PRECONDITION
(
aContent
"
aContent
must
not
be
null
"
)
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
nsRect
resultRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
nsresult
rv
=
ConvertToRootRelativeOffset
(
frame
resultRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
(
frame
=
frame
-
>
GetNextContinuation
(
)
)
!
=
nullptr
)
{
nsRect
frameRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
frame
frameRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
resultRect
.
UnionRect
(
resultRect
frameRect
)
;
}
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
resultRect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
EnsureNonEmptyRect
(
aEvent
-
>
mReply
.
mRect
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
static
bool
IsContentBR
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
aContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
moz
eIgnoreCase
)
&
&
!
aContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
mozeditorbogusnode
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
}
static
bool
IsMozBR
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
IsContentBR
(
aContent
)
;
}
static
void
ConvertToNativeNewlines
(
nsString
&
aString
)
{
#
if
defined
(
XP_WIN
)
aString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
n
"
)
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
)
;
#
endif
}
static
void
AppendString
(
nsAString
&
aString
nsIContent
*
aContent
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
;
}
text
-
>
AppendTo
(
aString
)
;
}
static
void
AppendSubString
(
nsAString
&
aString
nsIContent
*
aContent
uint32_t
aXPOffset
uint32_t
aXPLength
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
;
}
text
-
>
AppendTo
(
aString
int32_t
(
aXPOffset
)
int32_t
(
aXPLength
)
)
;
}
#
if
defined
(
XP_WIN
)
static
uint32_t
CountNewlinesInXPLength
(
nsIContent
*
aContent
uint32_t
aXPLength
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
0
;
}
MOZ_ASSERT
(
aXPLength
=
=
UINT32_MAX
|
|
aXPLength
<
=
text
-
>
GetLength
(
)
"
aXPLength
is
out
-
of
-
bounds
"
)
;
const
uint32_t
length
=
std
:
:
min
(
aXPLength
text
-
>
GetLength
(
)
)
;
uint32_t
newlines
=
0
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
text
-
>
CharAt
(
i
)
=
=
'
\
n
'
)
{
+
+
newlines
;
}
}
return
newlines
;
}
static
uint32_t
CountNewlinesInNativeLength
(
nsIContent
*
aContent
uint32_t
aNativeLength
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
0
;
}
MOZ_ASSERT
(
(
aNativeLength
=
=
UINT32_MAX
|
|
aNativeLength
<
=
text
-
>
GetLength
(
)
*
2
)
"
aNativeLength
is
unexpected
value
"
)
;
const
uint32_t
xpLength
=
text
-
>
GetLength
(
)
;
uint32_t
newlines
=
0
;
for
(
uint32_t
i
=
0
nativeOffset
=
0
;
i
<
xpLength
&
&
nativeOffset
<
aNativeLength
;
+
+
i
+
+
nativeOffset
)
{
MOZ_ASSERT
(
i
<
text
-
>
GetLength
(
)
"
i
is
out
-
of
-
bounds
"
)
;
if
(
text
-
>
CharAt
(
i
)
=
=
'
\
n
'
)
{
+
+
newlines
;
+
+
nativeOffset
;
}
}
return
newlines
;
}
#
endif
uint32_t
ContentEventHandler
:
:
GetNativeTextLength
(
nsIContent
*
aContent
uint32_t
aStartOffset
uint32_t
aEndOffset
)
{
MOZ_ASSERT
(
aEndOffset
>
=
aStartOffset
"
aEndOffset
must
be
equals
or
larger
than
aStartOffset
"
)
;
if
(
NS_WARN_IF
(
!
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
)
{
return
0
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
0
;
}
return
GetTextLength
(
aContent
LINE_BREAK_TYPE_NATIVE
aEndOffset
)
-
GetTextLength
(
aContent
LINE_BREAK_TYPE_NATIVE
aStartOffset
)
;
}
uint32_t
ContentEventHandler
:
:
GetNativeTextLength
(
nsIContent
*
aContent
uint32_t
aMaxLength
)
{
if
(
NS_WARN_IF
(
!
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
)
{
return
0
;
}
return
GetTextLength
(
aContent
LINE_BREAK_TYPE_NATIVE
aMaxLength
)
;
}
uint32_t
ContentEventHandler
:
:
GetNativeTextLengthBefore
(
nsIContent
*
aContent
nsINode
*
aRootNode
)
{
if
(
NS_WARN_IF
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
)
{
return
0
;
}
return
ShouldBreakLineBefore
(
aContent
aRootNode
)
?
GetBRLength
(
LINE_BREAK_TYPE_NATIVE
)
:
0
;
}
uint32_t
ContentEventHandler
:
:
GetBRLength
(
LineBreakType
aLineBreakType
)
{
#
if
defined
(
XP_WIN
)
return
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
?
2
:
1
;
#
else
return
1
;
#
endif
}
uint32_t
ContentEventHandler
:
:
GetTextLength
(
nsIContent
*
aContent
LineBreakType
aLineBreakType
uint32_t
aMaxLength
)
{
MOZ_ASSERT
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
uint32_t
textLengthDifference
=
#
if
defined
(
XP_WIN
)
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
?
CountNewlinesInXPLength
(
aContent
aMaxLength
)
:
0
;
#
else
0
;
#
endif
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
0
;
}
uint32_t
length
=
std
:
:
min
(
text
-
>
GetLength
(
)
aMaxLength
)
;
return
length
+
textLengthDifference
;
}
static
uint32_t
ConvertToXPOffset
(
nsIContent
*
aContent
uint32_t
aNativeOffset
)
{
#
if
defined
(
XP_WIN
)
return
aNativeOffset
-
CountNewlinesInNativeLength
(
aContent
aNativeOffset
)
;
#
else
return
aNativeOffset
;
#
endif
}
bool
ContentEventHandler
:
:
ShouldBreakLineBefore
(
nsIContent
*
aContent
nsINode
*
aRootNode
)
{
if
(
aContent
=
=
aRootNode
)
{
return
false
;
}
if
(
!
aContent
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
IsContentBR
(
aContent
)
;
}
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
b
nsGkAtoms
:
:
bdi
nsGkAtoms
:
:
bdo
nsGkAtoms
:
:
big
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
code
nsGkAtoms
:
:
data
nsGkAtoms
:
:
del
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
em
nsGkAtoms
:
:
font
nsGkAtoms
:
:
i
nsGkAtoms
:
:
ins
nsGkAtoms
:
:
kbd
nsGkAtoms
:
:
mark
nsGkAtoms
:
:
s
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
small
nsGkAtoms
:
:
span
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
time
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
u
nsGkAtoms
:
:
var
)
)
{
return
false
;
}
RefPtr
<
HTMLUnknownElement
>
unknownHTMLElement
=
do_QueryObject
(
aContent
)
;
return
!
unknownHTMLElement
;
}
nsresult
ContentEventHandler
:
:
GenerateFlatTextContent
(
nsIContent
*
aContent
nsString
&
aString
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aString
.
IsEmpty
(
)
)
;
RawRange
rawRange
;
nsresult
rv
=
rawRange
.
SelectNodeContents
(
aContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
GenerateFlatTextContent
(
rawRange
aString
aLineBreakType
)
;
}
nsresult
ContentEventHandler
:
:
GenerateFlatTextContent
(
const
RawRange
&
aRawRange
nsString
&
aString
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aString
.
IsEmpty
(
)
)
;
if
(
aRawRange
.
Collapsed
(
)
)
{
return
NS_OK
;
}
nsINode
*
startNode
=
aRawRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRawRange
.
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startNode
=
=
endNode
&
&
startNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
nsIContent
*
content
=
startNode
-
>
AsContent
(
)
;
AppendSubString
(
aString
content
aRawRange
.
StartOffset
(
)
aRawRange
.
EndOffset
(
)
-
aRawRange
.
StartOffset
(
)
)
;
ConvertToNativeNewlines
(
aString
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
content
=
=
startNode
)
{
AppendSubString
(
aString
content
aRawRange
.
StartOffset
(
)
content
-
>
TextLength
(
)
-
aRawRange
.
StartOffset
(
)
)
;
}
else
if
(
content
=
=
endNode
)
{
AppendSubString
(
aString
content
0
aRawRange
.
EndOffset
(
)
)
;
}
else
{
AppendString
(
aString
content
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
content
mRootContent
)
)
{
aString
.
Append
(
char16_t
(
'
\
n
'
)
)
;
}
}
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
ConvertToNativeNewlines
(
aString
)
;
}
return
NS_OK
;
}
static
FontRange
*
AppendFontRange
(
nsTArray
<
FontRange
>
&
aFontRanges
uint32_t
aBaseOffset
)
{
FontRange
*
fontRange
=
aFontRanges
.
AppendElement
(
)
;
fontRange
-
>
mStartOffset
=
aBaseOffset
;
return
fontRange
;
}
uint32_t
ContentEventHandler
:
:
GetTextLengthInRange
(
nsIContent
*
aContent
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
return
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
?
GetNativeTextLength
(
aContent
aXPStartOffset
aXPEndOffset
)
:
aXPEndOffset
-
aXPStartOffset
;
}
void
ContentEventHandler
:
:
AppendFontRanges
(
FontRangeArray
&
aFontRanges
nsIContent
*
aContent
uint32_t
aBaseOffset
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
AppendFontRange
(
aFontRanges
aBaseOffset
)
;
return
;
}
uint32_t
baseOffset
=
aBaseOffset
;
#
ifdef
DEBUG
{
nsTextFrame
*
text
=
do_QueryFrame
(
frame
)
;
MOZ_ASSERT
(
text
"
Not
a
text
frame
"
)
;
}
#
endif
auto
*
curr
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
while
(
curr
)
{
uint32_t
frameXPStart
=
std
:
:
max
(
static_cast
<
uint32_t
>
(
curr
-
>
GetContentOffset
(
)
)
aXPStartOffset
)
;
uint32_t
frameXPEnd
=
std
:
:
min
(
static_cast
<
uint32_t
>
(
curr
-
>
GetContentEnd
(
)
)
aXPEndOffset
)
;
if
(
frameXPStart
>
=
frameXPEnd
)
{
curr
=
curr
-
>
GetNextContinuation
(
)
;
continue
;
}
gfxSkipCharsIterator
iter
=
curr
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
curr
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
*
next
=
nullptr
;
if
(
frameXPEnd
<
aXPEndOffset
)
{
next
=
curr
-
>
GetNextContinuation
(
)
;
while
(
next
&
&
next
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
textRun
)
{
frameXPEnd
=
std
:
:
min
(
static_cast
<
uint32_t
>
(
next
-
>
GetContentEnd
(
)
)
aXPEndOffset
)
;
next
=
frameXPEnd
<
aXPEndOffset
?
next
-
>
GetNextContinuation
(
)
:
nullptr
;
}
}
gfxTextRun
:
:
Range
skipRange
(
iter
.
ConvertOriginalToSkipped
(
frameXPStart
)
iter
.
ConvertOriginalToSkipped
(
frameXPEnd
)
)
;
gfxTextRun
:
:
GlyphRunIterator
runIter
(
textRun
skipRange
)
;
uint32_t
lastXPEndOffset
=
frameXPStart
;
while
(
runIter
.
NextRun
(
)
)
{
gfxFont
*
font
=
runIter
.
GetGlyphRun
(
)
-
>
mFont
.
get
(
)
;
uint32_t
startXPOffset
=
iter
.
ConvertSkippedToOriginal
(
runIter
.
GetStringStart
(
)
)
;
if
(
startXPOffset
>
=
frameXPEnd
)
{
break
;
}
if
(
startXPOffset
>
lastXPEndOffset
)
{
AppendFontRange
(
aFontRanges
baseOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aContent
lastXPEndOffset
startXPOffset
aLineBreakType
)
;
lastXPEndOffset
=
startXPOffset
;
}
FontRange
*
fontRange
=
AppendFontRange
(
aFontRanges
baseOffset
)
;
fontRange
-
>
mFontName
=
font
-
>
GetName
(
)
;
fontRange
-
>
mFontSize
=
font
-
>
GetAdjustedSize
(
)
;
uint32_t
endXPOffset
=
iter
.
ConvertSkippedToOriginal
(
runIter
.
GetStringEnd
(
)
)
;
endXPOffset
=
std
:
:
min
(
frameXPEnd
endXPOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aContent
startXPOffset
endXPOffset
aLineBreakType
)
;
lastXPEndOffset
=
endXPOffset
;
}
if
(
lastXPEndOffset
<
frameXPEnd
)
{
AppendFontRange
(
aFontRanges
baseOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aContent
lastXPEndOffset
frameXPEnd
aLineBreakType
)
;
}
curr
=
next
;
}
}
nsresult
ContentEventHandler
:
:
GenerateFlatFontRanges
(
const
RawRange
&
aRawRange
FontRangeArray
&
aFontRanges
uint32_t
&
aLength
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aFontRanges
.
IsEmpty
(
)
"
aRanges
must
be
empty
array
"
)
;
if
(
aRawRange
.
Collapsed
(
)
)
{
return
NS_OK
;
}
nsINode
*
startNode
=
aRawRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
aRawRange
.
GetEndContainer
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
baseOffset
=
0
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
uint32_t
startOffset
=
content
!
=
startNode
?
0
:
aRawRange
.
StartOffset
(
)
;
uint32_t
endOffset
=
content
!
=
endNode
?
content
-
>
TextLength
(
)
:
aRawRange
.
EndOffset
(
)
;
AppendFontRanges
(
aFontRanges
content
baseOffset
startOffset
endOffset
aLineBreakType
)
;
baseOffset
+
=
GetTextLengthInRange
(
content
startOffset
endOffset
aLineBreakType
)
;
}
else
if
(
ShouldBreakLineBefore
(
content
mRootContent
)
)
{
if
(
aFontRanges
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
baseOffset
=
=
0
)
;
FontRange
*
fontRange
=
AppendFontRange
(
aFontRanges
baseOffset
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
const
nsFont
&
font
=
frame
-
>
GetParent
(
)
-
>
StyleFont
(
)
-
>
mFont
;
const
FontFamilyList
&
fontList
=
font
.
fontlist
;
const
FontFamilyName
&
fontName
=
fontList
.
IsEmpty
(
)
?
FontFamilyName
(
fontList
.
GetDefaultFontType
(
)
)
:
fontList
.
GetFontlist
(
)
[
0
]
;
fontName
.
AppendToString
(
fontRange
-
>
mFontName
false
)
;
fontRange
-
>
mFontSize
=
frame
-
>
PresContext
(
)
-
>
AppUnitsToDevPixels
(
font
.
size
)
;
}
}
baseOffset
+
=
GetBRLength
(
aLineBreakType
)
;
}
}
aLength
=
baseOffset
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
ExpandToClusterBoundary
(
nsIContent
*
aContent
bool
aForward
uint32_t
*
aXPOffset
)
{
if
(
!
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
|
|
*
aXPOffset
=
=
0
|
|
*
aXPOffset
=
=
aContent
-
>
TextLength
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
*
aXPOffset
<
=
aContent
-
>
TextLength
(
)
"
offset
is
out
of
range
.
"
)
;
RefPtr
<
nsFrameSelection
>
fs
=
mPresShell
-
>
FrameSelection
(
)
;
int32_t
offsetInFrame
;
CaretAssociationHint
hint
=
aForward
?
CARET_ASSOCIATE_BEFORE
:
CARET_ASSOCIATE_AFTER
;
nsIFrame
*
frame
=
fs
-
>
GetFrameForNodeOffset
(
aContent
int32_t
(
*
aXPOffset
)
hint
&
offsetInFrame
)
;
if
(
frame
)
{
int32_t
startOffset
endOffset
;
nsresult
rv
=
frame
-
>
GetOffsets
(
startOffset
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
aXPOffset
=
=
static_cast
<
uint32_t
>
(
startOffset
)
|
|
*
aXPOffset
=
=
static_cast
<
uint32_t
>
(
endOffset
)
)
{
return
NS_OK
;
}
if
(
!
frame
-
>
IsTextFrame
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
int32_t
newOffsetInFrame
=
*
aXPOffset
-
startOffset
;
newOffsetInFrame
+
=
aForward
?
-
1
:
1
;
nsTextFrame
:
:
PeekOffsetCharacterOptions
options
;
options
.
mRespectClusters
=
true
;
options
.
mIgnoreUserStyleAll
=
true
;
if
(
textFrame
-
>
PeekOffsetCharacter
(
aForward
&
newOffsetInFrame
options
)
=
=
nsIFrame
:
:
FOUND
)
{
*
aXPOffset
=
startOffset
+
newOffsetInFrame
;
return
NS_OK
;
}
}
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
NS_ENSURE_TRUE
(
text
NS_ERROR_FAILURE
)
;
if
(
NS_IS_LOW_SURROGATE
(
text
-
>
CharAt
(
*
aXPOffset
)
)
&
&
NS_IS_HIGH_SURROGATE
(
text
-
>
CharAt
(
*
aXPOffset
-
1
)
)
)
{
*
aXPOffset
+
=
aForward
?
1
:
-
1
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
SetRawRangeFromFlatTextOffset
(
RawRange
*
aRawRange
uint32_t
aOffset
uint32_t
aLength
LineBreakType
aLineBreakType
bool
aExpandToClusterBoundaries
uint32_t
*
aNewOffset
nsIContent
*
*
aLastTextNode
)
{
if
(
aNewOffset
)
{
*
aNewOffset
=
aOffset
;
}
if
(
aLastTextNode
)
{
*
aLastTextNode
=
nullptr
;
}
if
(
!
mRootContent
-
>
HasChildren
(
)
)
{
nsresult
rv
=
aRawRange
-
>
CollapseTo
(
RawRangeBoundary
(
mRootContent
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
mRootContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint32_t
offset
=
0
;
uint32_t
endOffset
=
aOffset
+
aLength
;
bool
startSet
=
false
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
node
=
=
mRootContent
|
|
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
aLastTextNode
&
&
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
NS_IF_RELEASE
(
*
aLastTextNode
)
;
NS_ADDREF
(
*
aLastTextNode
=
content
)
;
}
uint32_t
textLength
=
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
?
GetTextLength
(
content
aLineBreakType
)
:
(
ShouldBreakLineBefore
(
content
mRootContent
)
?
GetBRLength
(
aLineBreakType
)
:
0
)
;
if
(
!
textLength
)
{
continue
;
}
if
(
!
startSet
&
&
aOffset
<
=
offset
+
textLength
)
{
nsINode
*
startNode
=
nullptr
;
int32_t
startNodeOffset
=
-
1
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
uint32_t
xpOffset
=
aOffset
-
offset
;
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
xpOffset
=
ConvertToXPOffset
(
content
xpOffset
)
;
}
if
(
aExpandToClusterBoundaries
)
{
uint32_t
oldXPOffset
=
xpOffset
;
rv
=
ExpandToClusterBoundary
(
content
false
&
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aNewOffset
)
{
*
aNewOffset
-
=
(
oldXPOffset
-
xpOffset
)
;
}
}
startNode
=
content
;
startNodeOffset
=
static_cast
<
int32_t
>
(
xpOffset
)
;
}
else
if
(
aOffset
<
offset
+
textLength
)
{
startNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startNodeOffset
=
startNode
-
>
IndexOf
(
content
)
;
if
(
NS_WARN_IF
(
startNodeOffset
=
=
-
1
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
content
-
>
HasChildren
(
)
)
{
startNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startNodeOffset
=
startNode
-
>
IndexOf
(
content
)
+
1
;
if
(
NS_WARN_IF
(
startNodeOffset
=
=
0
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
startNode
=
content
;
startNodeOffset
=
0
;
}
NS_ASSERTION
(
startNode
"
startNode
must
not
be
nullptr
"
)
;
NS_ASSERTION
(
startNodeOffset
>
=
0
"
startNodeOffset
must
not
be
negative
"
)
;
rv
=
aRawRange
-
>
SetStart
(
startNode
static_cast
<
uint32_t
>
(
startNodeOffset
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
startSet
=
true
;
if
(
!
aLength
)
{
rv
=
aRawRange
-
>
SetEnd
(
startNode
static_cast
<
uint32_t
>
(
startNodeOffset
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
if
(
endOffset
<
=
offset
+
textLength
)
{
MOZ_ASSERT
(
startSet
"
The
start
of
the
range
should
'
ve
been
set
already
"
)
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
uint32_t
xpOffset
=
endOffset
-
offset
;
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
uint32_t
xpOffsetCurrent
=
ConvertToXPOffset
(
content
xpOffset
)
;
if
(
xpOffset
&
&
GetBRLength
(
aLineBreakType
)
>
1
)
{
MOZ_ASSERT
(
GetBRLength
(
aLineBreakType
)
=
=
2
)
;
uint32_t
xpOffsetPre
=
ConvertToXPOffset
(
content
xpOffset
-
1
)
;
if
(
xpOffsetPre
=
=
xpOffsetCurrent
)
{
xpOffset
=
xpOffsetCurrent
+
1
;
}
else
{
xpOffset
=
xpOffsetCurrent
;
}
}
}
if
(
aExpandToClusterBoundaries
)
{
rv
=
ExpandToClusterBoundary
(
content
true
&
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
NS_ASSERTION
(
xpOffset
<
=
INT32_MAX
"
The
end
node
offset
is
too
large
"
)
;
rv
=
aRawRange
-
>
SetEnd
(
content
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
endOffset
=
=
offset
)
{
MOZ_ASSERT
(
false
"
This
case
should
'
ve
already
been
handled
at
"
"
the
last
node
which
caused
some
text
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
content
-
>
HasChildren
(
)
&
&
ShouldBreakLineBefore
(
content
mRootContent
)
)
{
rv
=
aRawRange
-
>
SetEnd
(
content
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsINode
*
endNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
indexInParent
=
endNode
-
>
IndexOf
(
content
)
;
if
(
NS_WARN_IF
(
indexInParent
=
=
-
1
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aRawRange
-
>
SetEnd
(
endNode
indexInParent
+
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
offset
+
=
textLength
;
}
if
(
!
startSet
)
{
MOZ_ASSERT
(
!
mRootContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
if
(
!
offset
)
{
rv
=
aRawRange
-
>
SetStart
(
mRootContent
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aLength
)
{
rv
=
aRawRange
-
>
SetEnd
(
mRootContent
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
else
{
rv
=
aRawRange
-
>
SetStart
(
mRootContent
mRootContent
-
>
GetChildCount
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aNewOffset
)
{
*
aNewOffset
=
offset
;
}
}
rv
=
aRawRange
-
>
SetEnd
(
mRootContent
mRootContent
-
>
GetChildCount
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
WidgetQueryContentEvent
*
aEvent
)
{
return
GetLineBreakType
(
aEvent
-
>
mUseNativeLineBreak
)
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
WidgetSelectionEvent
*
aEvent
)
{
return
GetLineBreakType
(
aEvent
-
>
mUseNativeLineBreak
)
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
bool
aUseNativeLineBreak
)
{
return
aUseNativeLineBreak
?
LINE_BREAK_TYPE_NATIVE
:
LINE_BREAK_TYPE_XP
;
}
nsresult
ContentEventHandler
:
:
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eQuerySelectedText
:
return
OnQuerySelectedText
(
aEvent
)
;
case
eQueryTextContent
:
return
OnQueryTextContent
(
aEvent
)
;
case
eQueryCaretRect
:
return
OnQueryCaretRect
(
aEvent
)
;
case
eQueryTextRect
:
return
OnQueryTextRect
(
aEvent
)
;
case
eQueryTextRectArray
:
return
OnQueryTextRectArray
(
aEvent
)
;
case
eQueryEditorRect
:
return
OnQueryEditorRect
(
aEvent
)
;
case
eQueryContentState
:
return
OnQueryContentState
(
aEvent
)
;
case
eQuerySelectionAsTransferable
:
return
OnQuerySelectionAsTransferable
(
aEvent
)
;
case
eQueryCharacterAtPoint
:
return
OnQueryCharacterAtPoint
(
aEvent
)
;
case
eQueryDOMWidgetHittest
:
return
OnQueryDOMWidgetHittest
(
aEvent
)
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
return
NS_OK
;
}
static
nsresult
GetFrameForTextRect
(
nsINode
*
aNode
int32_t
aNodeOffset
bool
aHint
nsIFrame
*
*
aReturnFrame
)
{
NS_ENSURE_TRUE
(
aNode
&
&
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
NS_ERROR_UNEXPECTED
)
;
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
aNode
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
int32_t
childNodeOffset
=
0
;
return
frame
-
>
GetChildFrameContainingOffset
(
aNodeOffset
aHint
&
childNodeOffset
aReturnFrame
)
;
}
nsresult
ContentEventHandler
:
:
OnQuerySelectedText
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
mFirstSelectedRawRange
.
IsPositioned
(
)
)
{
MOZ_ASSERT
(
aEvent
-
>
mInput
.
mSelectionType
!
=
SelectionType
:
:
eNormal
)
;
MOZ_ASSERT
(
aEvent
-
>
mReply
.
mOffset
=
=
WidgetQueryContentEvent
:
:
NOT_FOUND
)
;
MOZ_ASSERT
(
aEvent
-
>
mReply
.
mString
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aEvent
-
>
mReply
.
mHasSelection
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsINode
*
const
startNode
=
mFirstSelectedRawRange
.
GetStartContainer
(
)
;
nsINode
*
const
endNode
=
mFirstSelectedRawRange
.
GetEndContainer
(
)
;
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
startNode
mRootContent
)
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
endNode
mRootContent
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ASSERTION
(
aEvent
-
>
mReply
.
mString
.
IsEmpty
(
)
"
The
reply
string
must
be
empty
"
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
rv
=
GetStartOffset
(
mFirstSelectedRawRange
&
aEvent
-
>
mReply
.
mOffset
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
anchorNode
focusNode
;
int32_t
anchorOffset
=
0
focusOffset
=
0
;
if
(
mSelection
-
>
RangeCount
(
)
)
{
if
(
mSelection
-
>
RangeCount
(
)
=
=
1
)
{
anchorNode
=
mSelection
-
>
GetAnchorNode
(
)
;
focusNode
=
mSelection
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
focusNode
)
)
{
return
NS_ERROR_FAILURE
;
}
anchorOffset
=
static_cast
<
int32_t
>
(
mSelection
-
>
AnchorOffset
(
)
)
;
focusOffset
=
static_cast
<
int32_t
>
(
mSelection
-
>
FocusOffset
(
)
)
;
if
(
NS_WARN_IF
(
anchorOffset
<
0
)
|
|
NS_WARN_IF
(
focusOffset
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
int16_t
compare
=
nsContentUtils
:
:
ComparePoints
(
anchorNode
anchorOffset
focusNode
focusOffset
)
;
aEvent
-
>
mReply
.
mReversed
=
compare
>
0
;
}
else
{
aEvent
-
>
mReply
.
mReversed
=
false
;
}
if
(
!
mFirstSelectedRawRange
.
Collapsed
(
)
)
{
rv
=
GenerateFlatTextContent
(
mFirstSelectedRawRange
aEvent
-
>
mReply
.
mString
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
aEvent
-
>
mReply
.
mString
.
Truncate
(
)
;
}
}
else
{
NS_ASSERTION
(
mFirstSelectedRawRange
.
Collapsed
(
)
"
When
mSelection
doesn
'
t
have
selection
mFirstSelectedRawRange
must
be
"
"
collapsed
"
)
;
anchorNode
=
focusNode
=
mFirstSelectedRawRange
.
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
)
{
return
NS_ERROR_FAILURE
;
}
anchorOffset
=
focusOffset
=
static_cast
<
int32_t
>
(
mFirstSelectedRawRange
.
StartOffset
(
)
)
;
if
(
NS_WARN_IF
(
anchorOffset
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
.
mReversed
=
false
;
aEvent
-
>
mReply
.
mString
.
Truncate
(
)
;
}
nsIFrame
*
frame
=
nullptr
;
rv
=
GetFrameForTextRect
(
focusNode
focusOffset
true
&
frame
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
frame
)
{
aEvent
-
>
mReply
.
mWritingMode
=
frame
-
>
GetWritingMode
(
)
;
}
else
{
aEvent
-
>
mReply
.
mWritingMode
=
WritingMode
(
)
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextContent
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_ASSERTION
(
aEvent
-
>
mReply
.
mString
.
IsEmpty
(
)
"
The
reply
string
must
be
empty
"
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
RawRange
rawRange
;
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mInput
.
mOffset
aEvent
-
>
mInput
.
mLength
lineBreakType
false
&
aEvent
-
>
mReply
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GenerateFlatTextContent
(
rawRange
aEvent
-
>
mReply
.
mString
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEvent
-
>
mWithFontRanges
)
{
uint32_t
fontRangeLength
;
rv
=
GenerateFlatFontRanges
(
rawRange
aEvent
-
>
mReply
.
mFontRanges
fontRangeLength
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
fontRangeLength
=
=
aEvent
-
>
mReply
.
mString
.
Length
(
)
"
Font
ranges
doesn
'
t
match
the
string
"
)
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
void
ContentEventHandler
:
:
EnsureNonEmptyRect
(
nsRect
&
aRect
)
const
{
aRect
.
height
=
std
:
:
max
(
1
aRect
.
height
)
;
aRect
.
width
=
std
:
:
max
(
1
aRect
.
width
)
;
}
void
ContentEventHandler
:
:
EnsureNonEmptyRect
(
LayoutDeviceIntRect
&
aRect
)
const
{
aRect
.
height
=
std
:
:
max
(
1
aRect
.
height
)
;
aRect
.
width
=
std
:
:
max
(
1
aRect
.
width
)
;
}
ContentEventHandler
:
:
NodePosition
ContentEventHandler
:
:
GetNodePositionHavingFlatText
(
const
NodePosition
&
aNodePosition
)
{
return
GetNodePositionHavingFlatText
(
aNodePosition
.
Container
(
)
aNodePosition
.
Offset
(
)
)
;
}
ContentEventHandler
:
:
NodePosition
ContentEventHandler
:
:
GetNodePositionHavingFlatText
(
nsINode
*
aNode
int32_t
aNodeOffset
)
{
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
return
NodePosition
(
aNode
aNodeOffset
)
;
}
int32_t
childCount
=
static_cast
<
int32_t
>
(
aNode
-
>
GetChildCount
(
)
)
;
if
(
!
childCount
)
{
MOZ_ASSERT
(
!
aNodeOffset
|
|
aNodeOffset
=
=
1
)
;
return
NodePosition
(
aNode
aNodeOffset
)
;
}
if
(
aNodeOffset
<
childCount
)
{
return
NodePosition
(
aNode
-
>
GetChildAt
(
aNodeOffset
)
0
)
;
}
if
(
aNodeOffset
=
=
childCount
)
{
nsINode
*
node
=
aNode
-
>
GetChildAt
(
childCount
-
1
)
;
return
NodePosition
(
node
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
?
static_cast
<
int32_t
>
(
node
-
>
AsContent
(
)
-
>
TextLength
(
)
)
:
1
)
;
}
NS_WARNING
(
"
aNodeOffset
is
invalid
value
"
)
;
return
NodePosition
(
)
;
}
ContentEventHandler
:
:
FrameAndNodeOffset
ContentEventHandler
:
:
GetFirstFrameInRangeForTextRect
(
const
RawRange
&
aRawRange
)
{
NodePosition
nodePosition
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FrameAndNodeOffset
(
)
;
}
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
int32_t
offsetInNode
=
node
=
=
aRawRange
.
GetStartContainer
(
)
?
aRawRange
.
StartOffset
(
)
:
0
;
if
(
static_cast
<
uint32_t
>
(
offsetInNode
)
<
node
-
>
Length
(
)
)
{
nodePosition
.
Set
(
node
offsetInNode
)
;
break
;
}
continue
;
}
if
(
ShouldBreakLineBefore
(
node
-
>
AsContent
(
)
mRootContent
)
|
|
IsMozBR
(
node
-
>
AsContent
(
)
)
)
{
nodePosition
.
Set
(
node
0
)
;
}
}
if
(
!
nodePosition
.
IsSet
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
nsIFrame
*
firstFrame
=
nullptr
;
GetFrameForTextRect
(
nodePosition
.
Container
(
)
nodePosition
.
Offset
(
)
true
&
firstFrame
)
;
return
FrameAndNodeOffset
(
firstFrame
nodePosition
.
Offset
(
)
)
;
}
ContentEventHandler
:
:
FrameAndNodeOffset
ContentEventHandler
:
:
GetLastFrameInRangeForTextRect
(
const
RawRange
&
aRawRange
)
{
NodePosition
nodePosition
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRawRange
.
Start
(
)
.
AsRaw
(
)
aRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FrameAndNodeOffset
(
)
;
}
nsINode
*
endNode
=
aRawRange
.
GetEndContainer
(
)
;
uint32_t
endOffset
=
aRawRange
.
EndOffset
(
)
;
nsINode
*
nextNodeOfRangeEnd
=
nullptr
;
if
(
endNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
!
endOffset
&
&
aRawRange
.
GetStartContainer
(
)
!
=
endNode
)
{
nextNodeOfRangeEnd
=
endNode
;
}
}
else
if
(
endOffset
<
endNode
-
>
GetChildCount
(
)
)
{
nextNodeOfRangeEnd
=
endNode
-
>
GetChildAt
(
endOffset
)
;
}
for
(
iter
-
>
Last
(
)
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Prev
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
|
|
node
=
=
nextNodeOfRangeEnd
)
{
continue
;
}
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
uint32_t
offset
;
if
(
node
=
=
aRawRange
.
GetEndContainer
(
)
)
{
offset
=
aRawRange
.
EndOffset
(
)
;
}
else
{
offset
=
node
-
>
Length
(
)
;
}
nodePosition
.
Set
(
node
offset
)
;
if
(
!
nodePosition
.
Offset
(
)
)
{
continue
;
}
break
;
}
if
(
ShouldBreakLineBefore
(
node
-
>
AsContent
(
)
mRootContent
)
|
|
IsMozBR
(
node
-
>
AsContent
(
)
)
)
{
nodePosition
.
Set
(
node
0
)
;
break
;
}
}
if
(
!
nodePosition
.
IsSet
(
)
)
{
return
FrameAndNodeOffset
(
)
;
}
nsIFrame
*
lastFrame
=
nullptr
;
GetFrameForTextRect
(
nodePosition
.
Container
(
)
nodePosition
.
Offset
(
)
true
&
lastFrame
)
;
if
(
!
lastFrame
)
{
return
FrameAndNodeOffset
(
)
;
}
if
(
!
lastFrame
-
>
IsTextFrame
(
)
)
{
return
FrameAndNodeOffset
(
lastFrame
nodePosition
.
Offset
(
)
)
;
}
int32_t
start
end
;
if
(
NS_WARN_IF
(
NS_FAILED
(
lastFrame
-
>
GetOffsets
(
start
end
)
)
)
)
{
return
FrameAndNodeOffset
(
)
;
}
if
(
nodePosition
.
Offset
(
)
&
&
nodePosition
.
Offset
(
)
=
=
static_cast
<
uint32_t
>
(
start
)
)
{
nodePosition
.
Set
(
nodePosition
.
Container
(
)
nodePosition
.
Offset
(
)
-
1
)
;
GetFrameForTextRect
(
nodePosition
.
Container
(
)
nodePosition
.
Offset
(
)
true
&
lastFrame
)
;
if
(
NS_WARN_IF
(
!
lastFrame
)
)
{
return
FrameAndNodeOffset
(
)
;
}
}
return
FrameAndNodeOffset
(
lastFrame
nodePosition
.
Offset
(
)
)
;
}
ContentEventHandler
:
:
FrameRelativeRect
ContentEventHandler
:
:
GetLineBreakerRectBefore
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
ShouldBreakLineBefore
(
aFrame
-
>
GetContent
(
)
mRootContent
)
|
|
IsMozBR
(
aFrame
-
>
GetContent
(
)
)
)
;
nsIFrame
*
frameForFontMetrics
=
aFrame
;
if
(
!
aFrame
-
>
IsBrFrame
(
)
&
&
aFrame
-
>
GetParent
(
)
)
{
frameForFontMetrics
=
aFrame
-
>
GetParent
(
)
;
}
FrameRelativeRect
result
(
aFrame
)
;
RefPtr
<
nsFontMetrics
>
fontMetrics
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
frameForFontMetrics
)
;
if
(
NS_WARN_IF
(
!
fontMetrics
)
)
{
return
FrameRelativeRect
(
)
;
}
const
WritingMode
kWritingMode
=
frameForFontMetrics
-
>
GetWritingMode
(
)
;
nscoord
baseline
=
aFrame
-
>
GetCaretBaseline
(
)
;
if
(
kWritingMode
.
IsVertical
(
)
)
{
if
(
kWritingMode
.
IsLineInverted
(
)
)
{
result
.
mRect
.
x
=
baseline
-
fontMetrics
-
>
MaxDescent
(
)
;
}
else
{
result
.
mRect
.
x
=
baseline
-
fontMetrics
-
>
MaxAscent
(
)
;
}
result
.
mRect
.
width
=
fontMetrics
-
>
MaxHeight
(
)
;
}
else
{
result
.
mRect
.
y
=
baseline
-
fontMetrics
-
>
MaxAscent
(
)
;
result
.
mRect
.
height
=
fontMetrics
-
>
MaxHeight
(
)
;
}
if
(
!
aFrame
-
>
IsBrFrame
(
)
)
{
if
(
kWritingMode
.
IsVertical
(
)
)
{
if
(
kWritingMode
.
IsLineInverted
(
)
)
{
result
.
mRect
.
x
=
0
;
}
else
{
result
.
mRect
.
x
=
aFrame
-
>
GetRect
(
)
.
XMost
(
)
-
result
.
mRect
.
width
;
}
result
.
mRect
.
y
=
-
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
}
else
{
result
.
mRect
.
x
=
-
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
result
.
mRect
.
y
=
0
;
}
}
return
result
;
}
ContentEventHandler
:
:
FrameRelativeRect
ContentEventHandler
:
:
GuessLineBreakerRectAfter
(
nsIContent
*
aTextContent
)
{
MOZ_ASSERT
(
aTextContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
FrameRelativeRect
result
;
int32_t
length
=
static_cast
<
int32_t
>
(
aTextContent
-
>
Length
(
)
)
;
if
(
NS_WARN_IF
(
length
<
0
)
)
{
return
result
;
}
nsIFrame
*
lastTextFrame
=
nullptr
;
nsresult
rv
=
GetFrameForTextRect
(
aTextContent
length
true
&
lastTextFrame
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
!
lastTextFrame
)
)
{
return
result
;
}
const
nsRect
kLastTextFrameRect
=
lastTextFrame
-
>
GetRect
(
)
;
if
(
lastTextFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
result
.
mRect
.
SetRect
(
0
kLastTextFrameRect
.
height
kLastTextFrameRect
.
width
0
)
;
}
else
{
result
.
mRect
.
SetRect
(
kLastTextFrameRect
.
width
0
0
kLastTextFrameRect
.
height
)
;
}
result
.
mBaseFrame
=
lastTextFrame
;
return
result
;
}
ContentEventHandler
:
:
FrameRelativeRect
ContentEventHandler
:
:
GuessFirstCaretRectIn
(
nsIFrame
*
aFrame
)
{
const
WritingMode
kWritingMode
=
aFrame
-
>
GetWritingMode
(
)
;
RefPtr
<
nsFontMetrics
>
fontMetrics
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
const
nscoord
kMaxHeight
=
fontMetrics
?
fontMetrics
-
>
MaxHeight
(
)
:
16
*
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
caretRect
;
const
nsRect
kContentRect
=
aFrame
-
>
GetContentRect
(
)
-
aFrame
-
>
GetPosition
(
)
;
caretRect
.
y
=
kContentRect
.
y
;
if
(
!
kWritingMode
.
IsVertical
(
)
)
{
if
(
kWritingMode
.
IsBidiLTR
(
)
)
{
caretRect
.
x
=
kContentRect
.
x
;
}
else
{
const
nscoord
kOnePixel
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
caretRect
.
x
=
kContentRect
.
XMost
(
)
-
kOnePixel
;
}
caretRect
.
height
=
kMaxHeight
;
caretRect
.
width
=
1
;
}
else
{
if
(
kWritingMode
.
IsVerticalLR
(
)
)
{
caretRect
.
x
=
kContentRect
.
x
;
}
else
{
caretRect
.
x
=
kContentRect
.
XMost
(
)
-
kMaxHeight
;
}
caretRect
.
width
=
kMaxHeight
;
caretRect
.
height
=
1
;
}
return
FrameRelativeRect
(
caretRect
aFrame
)
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextRectArray
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
const
uint32_t
kBRLength
=
GetBRLength
(
lineBreakType
)
;
bool
isVertical
=
false
;
LayoutDeviceIntRect
rect
;
uint32_t
offset
=
aEvent
-
>
mInput
.
mOffset
;
const
uint32_t
kEndOffset
=
offset
+
aEvent
-
>
mInput
.
mLength
;
bool
wasLineBreaker
=
false
;
nsRect
lastCharRect
;
nsIFrame
*
lastFrame
=
nullptr
;
while
(
offset
<
kEndOffset
)
{
nsCOMPtr
<
nsIContent
>
lastTextContent
;
RawRange
rawRange
;
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
offset
1
lineBreakType
true
nullptr
getter_AddRefs
(
lastTextContent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
rawRange
.
Collapsed
(
)
)
{
break
;
}
FrameAndNodeOffset
firstFrame
=
GetFirstFrameInRangeForTextRect
(
rawRange
)
;
if
(
!
firstFrame
.
IsValid
(
)
)
{
nsAutoString
allText
;
rv
=
GenerateFlatTextContent
(
mRootContent
allText
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
offset
<
allText
.
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
break
;
}
nsIContent
*
firstContent
=
firstFrame
.
mFrame
-
>
GetContent
(
)
;
if
(
NS_WARN_IF
(
!
firstContent
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
startsBetweenLineBreaker
=
false
;
nsAutoString
chars
;
isVertical
=
firstFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
;
nsIFrame
*
baseFrame
=
firstFrame
;
AutoTArray
<
nsRect
16
>
charRects
;
if
(
firstFrame
-
>
IsTextFrame
(
)
)
{
rv
=
firstFrame
-
>
GetCharacterRectsInRange
(
firstFrame
.
mOffsetInNode
kEndOffset
-
offset
charRects
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
charRects
.
IsEmpty
(
)
)
)
{
return
rv
;
}
AppendSubString
(
chars
firstContent
firstFrame
.
mOffsetInNode
charRects
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
chars
.
Length
(
)
!
=
charRects
.
Length
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
kBRLength
>
1
&
&
chars
[
0
]
=
=
'
\
n
'
&
&
offset
=
=
aEvent
-
>
mInput
.
mOffset
&
&
offset
)
{
RawRange
rawRangeToPrevOffset
;
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRangeToPrevOffset
aEvent
-
>
mInput
.
mOffset
-
1
1
lineBreakType
true
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
startsBetweenLineBreaker
=
rawRange
.
GetStartContainer
(
)
=
=
rawRangeToPrevOffset
.
GetStartContainer
(
)
&
&
rawRange
.
StartOffset
(
)
=
=
rawRangeToPrevOffset
.
StartOffset
(
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
firstContent
mRootContent
)
|
|
IsMozBR
(
firstContent
)
)
{
nsRect
brRect
;
if
(
!
firstFrame
-
>
IsBrFrame
(
)
&
&
aEvent
-
>
mInput
.
mOffset
!
=
offset
)
{
baseFrame
=
lastFrame
;
brRect
=
lastCharRect
;
if
(
!
wasLineBreaker
)
{
if
(
isVertical
)
{
brRect
.
y
=
brRect
.
YMost
(
)
+
1
;
brRect
.
height
=
1
;
}
else
{
brRect
.
x
=
brRect
.
XMost
(
)
+
1
;
brRect
.
width
=
1
;
}
}
}
else
if
(
!
firstFrame
-
>
IsBrFrame
(
)
&
&
lastTextContent
)
{
FrameRelativeRect
brRectRelativeToLastTextFrame
=
GuessLineBreakerRectAfter
(
lastTextContent
)
;
if
(
NS_WARN_IF
(
!
brRectRelativeToLastTextFrame
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
primaryFrame
=
lastTextContent
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
primaryFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
baseFrame
=
primaryFrame
-
>
LastContinuation
(
)
;
if
(
NS_WARN_IF
(
!
baseFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
brRect
=
brRectRelativeToLastTextFrame
.
RectRelativeTo
(
baseFrame
)
;
}
else
{
FrameRelativeRect
relativeBRRect
=
GetLineBreakerRectBefore
(
firstFrame
)
;
brRect
=
relativeBRRect
.
RectRelativeTo
(
firstFrame
)
;
}
charRects
.
AppendElement
(
brRect
)
;
chars
.
AssignLiteral
(
"
\
n
"
)
;
if
(
kBRLength
>
1
&
&
offset
=
=
aEvent
-
>
mInput
.
mOffset
&
&
offset
)
{
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mInput
.
mOffset
-
1
1
lineBreakType
true
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
FrameAndNodeOffset
frameForPrevious
=
GetFirstFrameInRangeForTextRect
(
rawRange
)
;
startsBetweenLineBreaker
=
frameForPrevious
.
mFrame
=
=
firstFrame
.
mFrame
;
}
}
else
{
NS_WARNING
(
"
The
frame
is
neither
a
text
frame
nor
a
frame
whose
content
"
"
causes
a
line
break
"
)
;
return
NS_ERROR_FAILURE
;
}
for
(
size_t
i
=
0
;
i
<
charRects
.
Length
(
)
&
&
offset
<
kEndOffset
;
i
+
+
)
{
nsRect
charRect
=
charRects
[
i
]
;
lastCharRect
=
charRect
;
lastFrame
=
baseFrame
;
rv
=
ConvertToRootRelativeOffset
(
baseFrame
charRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
charRect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
EnsureNonEmptyRect
(
rect
)
;
aEvent
-
>
mReply
.
mRectArray
.
AppendElement
(
rect
)
;
offset
+
+
;
wasLineBreaker
=
chars
[
i
]
=
=
'
\
n
'
;
if
(
!
wasLineBreaker
|
|
kBRLength
=
=
1
)
{
continue
;
}
MOZ_ASSERT
(
kBRLength
=
=
2
)
;
if
(
offset
=
=
kEndOffset
)
{
break
;
}
if
(
startsBetweenLineBreaker
)
{
continue
;
}
aEvent
-
>
mReply
.
mRectArray
.
AppendElement
(
rect
)
;
offset
+
+
;
}
}
if
(
offset
<
kEndOffset
|
|
aEvent
-
>
mReply
.
mRectArray
.
IsEmpty
(
)
)
{
if
(
!
aEvent
-
>
mReply
.
mRectArray
.
IsEmpty
(
)
&
&
!
wasLineBreaker
)
{
rect
=
aEvent
-
>
mReply
.
mRectArray
.
LastElement
(
)
;
if
(
isVertical
)
{
rect
.
y
=
rect
.
YMost
(
)
+
1
;
rect
.
height
=
1
;
MOZ_ASSERT
(
rect
.
width
)
;
}
else
{
rect
.
x
=
rect
.
XMost
(
)
+
1
;
rect
.
width
=
1
;
MOZ_ASSERT
(
rect
.
height
)
;
}
aEvent
-
>
mReply
.
mRectArray
.
AppendElement
(
rect
)
;
}
else
{
WidgetQueryContentEvent
queryTextRect
(
eQueryTextRect
*
aEvent
)
;
WidgetQueryContentEvent
:
:
Options
options
(
*
aEvent
)
;
queryTextRect
.
InitForQueryTextRect
(
offset
1
options
)
;
rv
=
OnQueryTextRect
(
&
queryTextRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
queryTextRect
.
mSucceeded
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
queryTextRect
.
mReply
.
mRect
.
IsEmpty
(
)
)
;
if
(
queryTextRect
.
mReply
.
mWritingMode
.
IsVertical
(
)
)
{
queryTextRect
.
mReply
.
mRect
.
height
=
1
;
}
else
{
queryTextRect
.
mReply
.
mRect
.
width
=
1
;
}
aEvent
-
>
mReply
.
mRectArray
.
AppendElement
(
queryTextRect
.
mReply
.
mRect
)
;
}
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aEvent
-
>
mInput
.
mLength
)
{
return
OnQueryCaretRect
(
aEvent
)
;
}
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
RawRange
rawRange
;
nsCOMPtr
<
nsIContent
>
lastTextContent
;
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mInput
.
mOffset
aEvent
-
>
mInput
.
mLength
lineBreakType
true
&
aEvent
-
>
mReply
.
mOffset
getter_AddRefs
(
lastTextContent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GenerateFlatTextContent
(
rawRange
aEvent
-
>
mReply
.
mString
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
rv
=
iter
-
>
Init
(
rawRange
.
Start
(
)
.
AsRaw
(
)
rawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
FrameAndNodeOffset
firstFrame
=
GetFirstFrameInRangeForTextRect
(
rawRange
)
;
if
(
!
firstFrame
.
IsValid
(
)
)
{
nsAutoString
allText
;
rv
=
GenerateFlatTextContent
(
mRootContent
allText
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
static_cast
<
uint32_t
>
(
aEvent
-
>
mInput
.
mOffset
)
<
allText
.
Length
(
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
rawRange
.
SelectNodeContents
(
mRootContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsRect
rect
;
FrameAndNodeOffset
lastFrame
=
GetLastFrameInRangeForTextRect
(
rawRange
)
;
if
(
lastFrame
)
{
if
(
NS_WARN_IF
(
!
lastFrame
-
>
GetContent
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
FrameRelativeRect
relativeRect
;
if
(
lastFrame
-
>
IsBrFrame
(
)
)
{
relativeRect
=
GetLineBreakerRectBefore
(
lastFrame
)
;
}
else
if
(
lastFrame
-
>
IsTextFrame
(
)
)
{
relativeRect
=
GuessLineBreakerRectAfter
(
lastFrame
-
>
GetContent
(
)
)
;
}
else
{
relativeRect
=
GuessFirstCaretRectIn
(
lastFrame
)
;
}
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
relativeRect
.
RectRelativeTo
(
lastFrame
)
;
rv
=
ConvertToRootRelativeOffset
(
lastFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aEvent
-
>
mReply
.
mWritingMode
=
lastFrame
-
>
GetWritingMode
(
)
;
}
else
{
nsIFrame
*
rootContentFrame
=
mRootContent
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootContentFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
FrameRelativeRect
relativeRect
=
GuessFirstCaretRectIn
(
rootContentFrame
)
;
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
relativeRect
.
RectRelativeTo
(
rootContentFrame
)
;
rv
=
ConvertToRootRelativeOffset
(
rootContentFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aEvent
-
>
mReply
.
mWritingMode
=
rootContentFrame
-
>
GetWritingMode
(
)
;
}
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
EnsureNonEmptyRect
(
aEvent
-
>
mReply
.
mRect
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsRect
rect
frameRect
;
nsPoint
ptOffset
;
if
(
firstFrame
-
>
IsTextFrame
(
)
)
{
rect
.
SetRect
(
nsPoint
(
0
0
)
firstFrame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
firstFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
frameRect
=
rect
;
firstFrame
-
>
GetPointFromOffset
(
firstFrame
.
mOffsetInNode
&
ptOffset
)
;
if
(
firstFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
rect
.
y
+
=
ptOffset
.
y
;
rect
.
height
-
=
ptOffset
.
y
;
}
else
{
rect
.
x
+
=
ptOffset
.
x
;
rect
.
width
-
=
ptOffset
.
x
;
}
}
else
if
(
!
firstFrame
-
>
IsBrFrame
(
)
&
&
lastTextContent
)
{
FrameRelativeRect
brRectAfterLastChar
=
GuessLineBreakerRectAfter
(
lastTextContent
)
;
if
(
NS_WARN_IF
(
!
brRectAfterLastChar
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
brRectAfterLastChar
.
mRect
;
rv
=
ConvertToRootRelativeOffset
(
brRectAfterLastChar
.
mBaseFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
frameRect
=
rect
;
}
else
{
FrameRelativeRect
relativeRect
=
GetLineBreakerRectBefore
(
firstFrame
)
;
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rect
=
relativeRect
.
RectRelativeTo
(
firstFrame
)
;
rv
=
ConvertToRootRelativeOffset
(
firstFrame
rect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
frameRect
=
rect
;
}
EnsureNonEmptyRect
(
rect
)
;
FrameAndNodeOffset
lastFrame
=
GetLastFrameInRangeForTextRect
(
rawRange
)
;
if
(
NS_WARN_IF
(
!
lastFrame
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
nsIFrame
*
frame
=
firstFrame
;
frame
!
=
lastFrame
;
)
{
frame
=
frame
-
>
GetNextContinuation
(
)
;
if
(
!
frame
)
{
do
{
iter
-
>
Next
(
)
;
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
!
node
)
{
break
;
}
if
(
!
node
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
{
continue
;
}
nsIFrame
*
primaryFrame
=
node
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
!
primaryFrame
)
{
continue
;
}
if
(
primaryFrame
-
>
IsTextFrame
(
)
|
|
primaryFrame
-
>
IsBrFrame
(
)
)
{
frame
=
primaryFrame
;
}
}
while
(
!
frame
&
&
!
iter
-
>
IsDone
(
)
)
;
if
(
!
frame
)
{
break
;
}
}
if
(
frame
-
>
IsTextFrame
(
)
)
{
frameRect
.
SetRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
}
else
{
MOZ_ASSERT
(
frame
-
>
IsBrFrame
(
)
)
;
FrameRelativeRect
relativeRect
=
GetLineBreakerRectBefore
(
frame
)
;
if
(
NS_WARN_IF
(
!
relativeRect
.
IsValid
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
frameRect
=
relativeRect
.
RectRelativeTo
(
frame
)
;
}
rv
=
ConvertToRootRelativeOffset
(
frame
frameRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
EnsureNonEmptyRect
(
frameRect
)
;
if
(
frame
!
=
lastFrame
)
{
rect
.
UnionRect
(
rect
frameRect
)
;
}
}
if
(
firstFrame
.
mFrame
!
=
lastFrame
.
mFrame
)
{
frameRect
.
SetRect
(
nsPoint
(
0
0
)
lastFrame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
lastFrame
frameRect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
lastFrame
-
>
IsTextFrame
(
)
)
{
lastFrame
-
>
GetPointFromOffset
(
lastFrame
.
mOffsetInNode
&
ptOffset
)
;
if
(
lastFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
frameRect
.
height
-
=
lastFrame
-
>
GetRect
(
)
.
height
-
ptOffset
.
y
;
}
else
{
frameRect
.
width
-
=
lastFrame
-
>
GetRect
(
)
.
width
-
ptOffset
.
x
;
}
EnsureNonEmptyRect
(
frameRect
)
;
if
(
firstFrame
.
mFrame
=
=
lastFrame
.
mFrame
)
{
rect
.
IntersectRect
(
rect
frameRect
)
;
}
else
{
rect
.
UnionRect
(
rect
frameRect
)
;
}
}
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
EnsureNonEmptyRect
(
aEvent
-
>
mReply
.
mRect
)
;
aEvent
-
>
mReply
.
mWritingMode
=
lastFrame
-
>
GetWritingMode
(
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryEditorRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsIContent
*
focusedContent
=
GetFocusedContent
(
)
;
rv
=
QueryContentRect
(
IsPlugin
(
focusedContent
)
?
focusedContent
:
mRootContent
.
get
(
)
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryCaretRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mSelection
-
>
IsCollapsed
(
)
)
{
nsRect
caretRect
;
nsIFrame
*
caretFrame
=
nsCaret
:
:
GetGeometry
(
mSelection
&
caretRect
)
;
if
(
caretFrame
)
{
uint32_t
offset
;
rv
=
GetStartOffset
(
mFirstSelectedRawRange
&
offset
GetLineBreakType
(
aEvent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
aEvent
-
>
mInput
.
mOffset
)
{
rv
=
ConvertToRootRelativeOffset
(
caretFrame
caretRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nscoord
appUnitsPerDevPixel
=
caretFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
caretRect
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
)
;
EnsureNonEmptyRect
(
aEvent
-
>
mReply
.
mRect
)
;
aEvent
-
>
mReply
.
mWritingMode
=
caretFrame
-
>
GetWritingMode
(
)
;
aEvent
-
>
mReply
.
mOffset
=
aEvent
-
>
mInput
.
mOffset
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
}
}
WidgetQueryContentEvent
queryTextRectEvent
(
eQueryTextRect
*
aEvent
)
;
WidgetQueryContentEvent
:
:
Options
options
(
*
aEvent
)
;
queryTextRectEvent
.
InitForQueryTextRect
(
aEvent
-
>
mInput
.
mOffset
1
options
)
;
rv
=
OnQueryTextRect
(
&
queryTextRectEvent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
!
queryTextRectEvent
.
mSucceeded
)
)
{
return
NS_ERROR_FAILURE
;
}
queryTextRectEvent
.
mReply
.
mString
.
Truncate
(
)
;
aEvent
-
>
mReply
=
queryTextRectEvent
.
mReply
;
if
(
aEvent
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
aEvent
-
>
mReply
.
mRect
.
height
=
1
;
}
else
{
aEvent
-
>
mReply
.
mRect
.
width
=
1
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryContentState
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQuerySelectionAsTransferable
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aEvent
-
>
mReply
.
mHasSelection
)
{
aEvent
-
>
mSucceeded
=
true
;
aEvent
-
>
mReply
.
mTransferable
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mPresShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
rv
=
nsCopySupport
:
:
GetTransferableForSelection
(
mSelection
doc
getter_AddRefs
(
aEvent
-
>
mReply
.
mTransferable
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryCharacterAtPoint
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mReply
.
mOffset
=
aEvent
-
>
mReply
.
mTentativeCaretOffset
=
WidgetQueryContentEvent
:
:
NOT_FOUND
;
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
NS_ERROR_FAILURE
)
;
nsIWidget
*
rootWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
rootWidget
NS_ERROR_FAILURE
)
;
if
(
rootWidget
!
=
aEvent
-
>
mWidget
)
{
NS_PRECONDITION
(
aEvent
-
>
mWidget
"
The
event
must
have
the
widget
"
)
;
nsView
*
view
=
nsView
:
:
GetViewFor
(
aEvent
-
>
mWidget
)
;
NS_ENSURE_TRUE
(
view
NS_ERROR_FAILURE
)
;
rootFrame
=
view
-
>
GetFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
NS_ERROR_FAILURE
)
;
rootWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
rootWidget
NS_ERROR_FAILURE
)
;
}
WidgetQueryContentEvent
eventOnRoot
(
true
eQueryCharacterAtPoint
rootWidget
)
;
eventOnRoot
.
mUseNativeLineBreak
=
aEvent
-
>
mUseNativeLineBreak
;
eventOnRoot
.
mRefPoint
=
aEvent
-
>
mRefPoint
;
if
(
rootWidget
!
=
aEvent
-
>
mWidget
)
{
eventOnRoot
.
mRefPoint
+
=
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
-
rootWidget
-
>
WidgetToScreenOffset
(
)
;
}
nsPoint
ptInRoot
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
&
eventOnRoot
rootFrame
)
;
nsIFrame
*
targetFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
ptInRoot
)
;
if
(
!
targetFrame
|
|
!
targetFrame
-
>
GetContent
(
)
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
targetFrame
-
>
GetContent
(
)
mRootContent
)
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsPoint
ptInTarget
=
ptInRoot
+
rootFrame
-
>
GetOffsetToCrossDoc
(
targetFrame
)
;
int32_t
rootAPD
=
rootFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
targetAPD
=
targetFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
ptInTarget
=
ptInTarget
.
ScaleToOtherAppUnits
(
rootAPD
targetAPD
)
;
nsIFrame
:
:
ContentOffsets
tentativeCaretOffsets
=
targetFrame
-
>
GetContentOffsetsFromPoint
(
ptInTarget
)
;
if
(
!
tentativeCaretOffsets
.
content
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
tentativeCaretOffsets
.
content
mRootContent
)
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
rv
=
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
tentativeCaretOffsets
)
mRootContent
&
aEvent
-
>
mReply
.
mTentativeCaretOffset
GetLineBreakType
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
targetFrame
-
>
IsTextFrame
(
)
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
.
mTentativeCaretOffset
!
=
WidgetQueryContentEvent
:
:
NOT_FOUND
"
The
point
is
inside
a
character
bounding
box
.
Why
tentative
caret
point
"
"
hasn
'
t
been
found
?
"
)
;
nsTextFrame
*
textframe
=
static_cast
<
nsTextFrame
*
>
(
targetFrame
)
;
nsIFrame
:
:
ContentOffsets
contentOffsets
=
textframe
-
>
GetCharacterOffsetAtFramePoint
(
ptInTarget
)
;
NS_ENSURE_TRUE
(
contentOffsets
.
content
NS_ERROR_FAILURE
)
;
uint32_t
offset
;
rv
=
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
contentOffsets
)
mRootContent
&
offset
GetLineBreakType
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
WidgetQueryContentEvent
textRect
(
true
eQueryTextRect
aEvent
-
>
mWidget
)
;
WidgetQueryContentEvent
:
:
Options
options
(
*
aEvent
)
;
textRect
.
InitForQueryTextRect
(
offset
1
options
)
;
rv
=
OnQueryTextRect
(
&
textRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
textRect
.
mSucceeded
NS_ERROR_FAILURE
)
;
aEvent
-
>
mReply
.
mOffset
=
offset
;
aEvent
-
>
mReply
.
mRect
=
textRect
.
mReply
.
mRect
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryDOMWidgetHittest
(
WidgetQueryContentEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitBasic
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mSucceeded
=
false
;
aEvent
-
>
mReply
.
mWidgetIsHit
=
false
;
NS_ENSURE_TRUE
(
aEvent
-
>
mWidget
NS_ERROR_FAILURE
)
;
nsIDocument
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsIFrame
*
docFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
docFrame
NS_ERROR_FAILURE
)
;
LayoutDeviceIntPoint
eventLoc
=
aEvent
-
>
mRefPoint
+
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
;
CSSIntRect
docFrameRect
=
docFrame
-
>
GetScreenRect
(
)
;
CSSIntPoint
eventLocCSS
(
mPresContext
-
>
DevPixelsToIntCSSPixels
(
eventLoc
.
x
)
-
docFrameRect
.
x
mPresContext
-
>
DevPixelsToIntCSSPixels
(
eventLoc
.
y
)
-
docFrameRect
.
y
)
;
Element
*
contentUnderMouse
=
doc
-
>
ElementFromPointHelper
(
eventLocCSS
.
x
eventLocCSS
.
y
false
false
)
;
if
(
contentUnderMouse
)
{
nsIWidget
*
targetWidget
=
nullptr
;
nsIFrame
*
targetFrame
=
contentUnderMouse
-
>
GetPrimaryFrame
(
)
;
nsIObjectFrame
*
pluginFrame
=
do_QueryFrame
(
targetFrame
)
;
if
(
pluginFrame
)
{
targetWidget
=
pluginFrame
-
>
GetWidget
(
)
;
}
else
if
(
targetFrame
)
{
targetWidget
=
targetFrame
-
>
GetNearestWidget
(
)
;
}
if
(
aEvent
-
>
mWidget
=
=
targetWidget
)
{
aEvent
-
>
mReply
.
mWidgetIsHit
=
true
;
}
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
const
NodePosition
&
aStartPosition
const
NodePosition
&
aEndPosition
nsIContent
*
aRootContent
uint32_t
*
aLength
LineBreakType
aLineBreakType
bool
aIsRemovingNode
)
{
if
(
NS_WARN_IF
(
!
aRootContent
)
|
|
NS_WARN_IF
(
!
aStartPosition
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEndPosition
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aLength
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aStartPosition
=
=
aEndPosition
)
{
*
aLength
=
0
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
;
NodePosition
endPosition
(
aEndPosition
)
;
if
(
aIsRemovingNode
)
{
DebugOnly
<
nsIContent
*
>
parent
=
aStartPosition
.
Container
(
)
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
&
&
parent
-
>
IndexOf
(
aStartPosition
.
Container
(
)
)
=
=
-
1
"
At
removing
the
node
the
node
shouldn
'
t
be
in
the
array
of
children
"
"
of
its
parent
"
)
;
MOZ_ASSERT
(
aStartPosition
.
Container
(
)
=
=
endPosition
.
Container
(
)
"
At
removing
the
node
start
and
end
node
should
be
same
"
)
;
MOZ_ASSERT
(
aStartPosition
.
Offset
(
)
=
=
0
"
When
the
node
is
being
removed
the
start
offset
should
be
0
"
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
endPosition
.
Offset
(
)
)
=
=
endPosition
.
Container
(
)
-
>
GetChildCount
(
)
"
When
the
node
is
being
removed
the
end
offset
should
be
child
count
"
)
;
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aStartPosition
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
RawRange
prevRawRange
;
nsresult
rv
=
prevRawRange
.
SetStart
(
aStartPosition
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
endPosition
.
Container
(
)
!
=
aRootContent
&
&
endPosition
.
IsImmediatelyAfterOpenTag
(
)
)
{
if
(
endPosition
.
Container
(
)
-
>
HasChildren
(
)
)
{
nsINode
*
firstChild
=
endPosition
.
Container
(
)
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
return
NS_ERROR_FAILURE
;
}
endPosition
=
NodePositionBefore
(
firstChild
0
)
;
}
else
{
nsIContent
*
parentContent
=
endPosition
.
Container
(
)
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
indexInParent
=
parentContent
-
>
IndexOf
(
endPosition
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
endPosition
=
NodePositionBefore
(
parentContent
indexInParent
+
1
)
;
}
}
if
(
endPosition
.
IsSetAndValid
(
)
)
{
rv
=
prevRawRange
.
SetEnd
(
endPosition
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iter
=
NS_NewPreContentIterator
(
)
;
rv
=
iter
-
>
Init
(
prevRawRange
.
Start
(
)
.
AsRaw
(
)
prevRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
endPosition
.
Container
(
)
!
=
aRootContent
)
{
rv
=
prevRawRange
.
SetEndAfter
(
endPosition
.
Container
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iter
=
NS_NewPreContentIterator
(
)
;
rv
=
iter
-
>
Init
(
prevRawRange
.
Start
(
)
.
AsRaw
(
)
prevRawRange
.
End
(
)
.
AsRaw
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
iter
=
NS_NewPreContentIterator
(
)
;
rv
=
iter
-
>
Init
(
aRootContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
*
aLength
=
0
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
node
=
=
endPosition
.
Container
(
)
)
{
*
aLength
+
=
GetTextLength
(
content
aLineBreakType
endPosition
.
Offset
(
)
)
;
}
else
{
*
aLength
+
=
GetTextLength
(
content
aLineBreakType
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
content
aRootContent
)
)
{
if
(
node
=
=
aStartPosition
.
Container
(
)
&
&
!
aStartPosition
.
IsBeforeOpenTag
(
)
)
{
continue
;
}
if
(
node
=
=
endPosition
.
Container
(
)
&
&
endPosition
.
IsBeforeOpenTag
(
)
)
{
continue
;
}
*
aLength
+
=
GetBRLength
(
aLineBreakType
)
;
}
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetStartOffset
(
const
RawRange
&
aRawRange
uint32_t
*
aOffset
LineBreakType
aLineBreakType
)
{
nsINode
*
startNode
=
aRawRange
.
GetStartContainer
(
)
;
bool
startIsContainer
=
true
;
if
(
startNode
-
>
IsHTMLElement
(
)
)
{
nsIAtom
*
name
=
startNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
startIsContainer
=
nsHTMLElement
:
:
IsContainer
(
nsHTMLTags
:
:
AtomTagToId
(
name
)
)
;
}
const
NodePosition
&
startPos
=
startIsContainer
?
NodePosition
(
startNode
aRawRange
.
StartOffset
(
)
)
:
NodePositionBefore
(
startNode
aRawRange
.
StartOffset
(
)
)
;
return
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
startPos
mRootContent
aOffset
aLineBreakType
)
;
}
nsresult
ContentEventHandler
:
:
AdjustCollapsedRangeMaybeIntoTextNode
(
RawRange
&
aRawRange
)
{
MOZ_ASSERT
(
aRawRange
.
Collapsed
(
)
)
;
if
(
!
aRawRange
.
Collapsed
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsINode
>
container
=
aRawRange
.
GetStartContainer
(
)
;
int32_t
offsetInParentNode
=
aRawRange
.
StartOffset
(
)
;
if
(
NS_WARN_IF
(
!
container
)
|
|
NS_WARN_IF
(
offsetInParentNode
<
0
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
container
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
return
NS_OK
;
}
nsINode
*
childNode
=
nullptr
;
int32_t
offsetInChildNode
=
-
1
;
if
(
!
offsetInParentNode
&
&
container
-
>
HasChildren
(
)
)
{
childNode
=
container
-
>
GetFirstChild
(
)
;
offsetInChildNode
=
0
;
}
else
if
(
static_cast
<
uint32_t
>
(
offsetInParentNode
)
<
container
-
>
GetChildCount
(
)
)
{
childNode
=
container
-
>
GetChildAt
(
offsetInParentNode
-
1
)
;
offsetInChildNode
=
childNode
-
>
Length
(
)
;
}
if
(
!
childNode
|
|
!
childNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
|
|
NS_WARN_IF
(
offsetInChildNode
<
0
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRawRange
.
CollapseTo
(
RawRangeBoundary
(
childNode
offsetInChildNode
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetStartFrameAndOffset
(
const
RawRange
&
aRawRange
nsIFrame
*
&
aFrame
int32_t
&
aOffsetInFrame
)
{
aFrame
=
nullptr
;
aOffsetInFrame
=
-
1
;
nsINode
*
node
=
aRawRange
.
GetStartContainer
(
)
;
if
(
NS_WARN_IF
(
!
node
)
|
|
NS_WARN_IF
(
!
node
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
node
)
;
RefPtr
<
nsFrameSelection
>
fs
=
mPresShell
-
>
FrameSelection
(
)
;
aFrame
=
fs
-
>
GetFrameForNodeOffset
(
content
aRawRange
.
StartOffset
(
)
fs
-
>
GetHint
(
)
&
aOffsetInFrame
)
;
if
(
NS_WARN_IF
(
!
aFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
ConvertToRootRelativeOffset
(
nsIFrame
*
aFrame
nsRect
&
aRect
)
{
NS_ASSERTION
(
aFrame
"
aFrame
must
not
be
null
"
)
;
nsPresContext
*
thisPC
=
aFrame
-
>
PresContext
(
)
;
nsPresContext
*
rootPC
=
thisPC
-
>
GetRootPresContext
(
)
;
if
(
NS_WARN_IF
(
!
rootPC
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
rootFrame
=
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
aRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
aRect
rootFrame
)
;
aRect
=
aRect
.
ScaleToOtherAppUnitsRoundOut
(
rootPC
-
>
AppUnitsPerDevPixel
(
)
thisPC
-
>
AppUnitsPerDevPixel
(
)
)
;
return
NS_OK
;
}
static
void
AdjustRangeForSelection
(
nsIContent
*
aRoot
nsINode
*
*
aNode
int32_t
*
aNodeOffset
)
{
nsINode
*
node
=
*
aNode
;
int32_t
nodeOffset
=
*
aNodeOffset
;
if
(
aRoot
=
=
node
|
|
NS_WARN_IF
(
!
node
-
>
GetParent
(
)
)
|
|
!
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
return
;
}
int32_t
textLength
=
static_cast
<
int32_t
>
(
static_cast
<
nsIContent
*
>
(
node
)
-
>
TextLength
(
)
)
;
MOZ_ASSERT
(
nodeOffset
<
=
textLength
"
Offset
is
past
length
of
text
node
"
)
;
if
(
nodeOffset
!
=
textLength
)
{
return
;
}
nsIContent
*
aRootParent
=
aRoot
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
aRootParent
)
)
{
return
;
}
if
(
!
aRootParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
textarea
)
)
{
return
;
}
*
aNode
=
node
-
>
GetParent
(
)
;
MOZ_ASSERT
(
(
*
aNode
)
-
>
IndexOf
(
node
)
!
=
-
1
)
;
*
aNodeOffset
=
(
*
aNode
)
-
>
IndexOf
(
node
)
+
1
;
}
nsresult
ContentEventHandler
:
:
OnSelectionEvent
(
WidgetSelectionEvent
*
aEvent
)
{
aEvent
-
>
mSucceeded
=
false
;
nsCOMPtr
<
nsISelection
>
sel
;
nsresult
rv
=
IMEStateManager
:
:
GetFocusSelectionAndRoot
(
getter_AddRefs
(
sel
)
getter_AddRefs
(
mRootContent
)
)
;
mSelection
=
sel
?
sel
-
>
AsSelection
(
)
:
nullptr
;
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
Init
(
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
RawRange
rawRange
;
rv
=
SetRawRangeFromFlatTextOffset
(
&
rawRange
aEvent
-
>
mOffset
aEvent
-
>
mLength
GetLineBreakType
(
aEvent
)
aEvent
-
>
mExpandToClusterBoundary
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsINode
*
startNode
=
rawRange
.
GetStartContainer
(
)
;
nsINode
*
endNode
=
rawRange
.
GetEndContainer
(
)
;
int32_t
startNodeOffset
=
rawRange
.
StartOffset
(
)
;
int32_t
endNodeOffset
=
rawRange
.
EndOffset
(
)
;
AdjustRangeForSelection
(
mRootContent
&
startNode
&
startNodeOffset
)
;
AdjustRangeForSelection
(
mRootContent
&
endNode
&
endNodeOffset
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
|
|
NS_WARN_IF
(
startNodeOffset
<
0
)
|
|
NS_WARN_IF
(
endNodeOffset
<
0
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mSelection
-
>
StartBatchChanges
(
)
;
rv
=
mSelection
-
>
RemoveAllRangesTemporarily
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aEvent
-
>
mReversed
)
{
rv
=
mSelection
-
>
Collapse
(
endNode
endNodeOffset
)
;
}
else
{
rv
=
mSelection
-
>
Collapse
(
startNode
startNodeOffset
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
startNode
!
=
endNode
|
|
startNodeOffset
!
=
endNodeOffset
)
)
{
if
(
aEvent
-
>
mReversed
)
{
rv
=
mSelection
-
>
Extend
(
startNode
startNodeOffset
)
;
}
else
{
rv
=
mSelection
-
>
Extend
(
endNode
endNodeOffset
)
;
}
}
}
mSelection
-
>
EndBatchChanges
(
aEvent
-
>
mReason
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSelection
-
>
ScrollIntoViewInternal
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
false
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsRect
ContentEventHandler
:
:
FrameRelativeRect
:
:
RectRelativeTo
(
nsIFrame
*
aDestFrame
)
const
{
if
(
!
mBaseFrame
|
|
NS_WARN_IF
(
!
aDestFrame
)
)
{
return
nsRect
(
)
;
}
if
(
NS_WARN_IF
(
aDestFrame
-
>
PresContext
(
)
!
=
mBaseFrame
-
>
PresContext
(
)
)
)
{
return
nsRect
(
)
;
}
if
(
aDestFrame
=
=
mBaseFrame
)
{
return
mRect
;
}
nsIFrame
*
rootFrame
=
mBaseFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
baseFrameRectInRootFrame
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
mBaseFrame
nsRect
(
)
rootFrame
)
;
nsRect
destFrameRectInRootFrame
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aDestFrame
nsRect
(
)
rootFrame
)
;
nsPoint
difference
=
destFrameRectInRootFrame
.
TopLeft
(
)
-
baseFrameRectInRootFrame
.
TopLeft
(
)
;
return
mRect
-
difference
;
}
}
