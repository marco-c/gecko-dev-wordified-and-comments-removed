#
include
"
ContentEventHandler
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLUnknownElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIObjectFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
dom
;
using
namespace
widget
;
ContentEventHandler
:
:
ContentEventHandler
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mPresShell
(
aPresContext
-
>
GetPresShell
(
)
)
mSelection
(
nullptr
)
mFirstSelectedRange
(
nullptr
)
mRootContent
(
nullptr
)
{
}
nsresult
ContentEventHandler
:
:
InitBasic
(
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_AVAILABLE
)
;
mPresShell
-
>
FlushPendingNotifications
(
Flush_Layout
)
;
NS_ENSURE_TRUE
(
!
mPresShell
-
>
IsDestroying
(
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
InitCommon
(
)
{
if
(
mSelection
)
{
return
NS_OK
;
}
nsresult
rv
=
InitBasic
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISelection
>
sel
;
nsCopySupport
:
:
GetSelectionForCopy
(
mPresShell
-
>
GetDocument
(
)
getter_AddRefs
(
sel
)
)
;
mSelection
=
static_cast
<
Selection
*
>
(
sel
.
get
(
)
)
;
if
(
NS_WARN_IF
(
!
mSelection
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
mSelection
-
>
RangeCount
(
)
)
{
rv
=
mSelection
-
>
GetAncestorLimiter
(
getter_AddRefs
(
mRootContent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mRootContent
)
{
mRootContent
=
mPresShell
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
NS_WARN_IF
(
!
mRootContent
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
rv
=
nsRange
:
:
CreateRange
(
mRootContent
0
mRootContent
0
getter_AddRefs
(
mFirstSelectedRange
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
!
mFirstSelectedRange
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
mFirstSelectedRange
=
mSelection
-
>
GetRangeAt
(
0
)
;
if
(
NS_WARN_IF
(
!
mFirstSelectedRange
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsINode
*
startNode
=
mFirstSelectedRange
-
>
GetStartParent
(
)
;
NS_ENSURE_TRUE
(
startNode
NS_ERROR_FAILURE
)
;
nsINode
*
endNode
=
mFirstSelectedRange
-
>
GetEndParent
(
)
;
NS_ENSURE_TRUE
(
endNode
NS_ERROR_FAILURE
)
;
NS_ENSURE_TRUE
(
startNode
-
>
GetUncomposedDoc
(
)
=
=
mPresShell
-
>
GetDocument
(
)
NS_ERROR_NOT_AVAILABLE
)
;
NS_ASSERTION
(
startNode
-
>
GetUncomposedDoc
(
)
=
=
endNode
-
>
GetUncomposedDoc
(
)
"
mFirstSelectedRange
crosses
the
document
boundary
"
)
;
mRootContent
=
startNode
-
>
GetSelectionRootContent
(
mPresShell
)
;
NS_ENSURE_TRUE
(
mRootContent
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
Init
(
WidgetQueryContentEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitCommon
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mSucceeded
=
false
;
aEvent
-
>
mReply
.
mContentsRoot
=
mRootContent
.
get
(
)
;
aEvent
-
>
mReply
.
mHasSelection
=
!
mSelection
-
>
IsCollapsed
(
)
;
nsRect
r
;
nsIFrame
*
frame
=
nsCaret
:
:
GetGeometry
(
mSelection
&
r
)
;
if
(
!
frame
)
{
frame
=
mRootContent
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
NS_ERROR_FAILURE
;
}
}
aEvent
-
>
mReply
.
mFocusedWidget
=
frame
-
>
GetNearestWidget
(
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
Init
(
WidgetSelectionEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitCommon
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mSucceeded
=
false
;
return
NS_OK
;
}
nsIContent
*
ContentEventHandler
:
:
GetFocusedContent
(
)
{
nsIDocument
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
doc
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
return
nsFocusManager
:
:
GetFocusedDescendant
(
window
true
getter_AddRefs
(
focusedWindow
)
)
;
}
bool
ContentEventHandler
:
:
IsPlugin
(
nsIContent
*
aContent
)
{
return
aContent
&
&
aContent
-
>
GetDesiredIMEState
(
)
.
mEnabled
=
=
IMEState
:
:
PLUGIN
;
}
nsresult
ContentEventHandler
:
:
QueryContentRect
(
nsIContent
*
aContent
WidgetQueryContentEvent
*
aEvent
)
{
NS_PRECONDITION
(
aContent
"
aContent
must
not
be
null
"
)
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
nsRect
resultRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
nsresult
rv
=
ConvertToRootRelativeOffset
(
frame
resultRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
(
frame
=
frame
-
>
GetNextContinuation
(
)
)
!
=
nullptr
)
{
nsRect
frameRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
frame
frameRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
resultRect
.
UnionRect
(
resultRect
frameRect
)
;
}
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
resultRect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
static
bool
IsContentBR
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
!
aContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
moz
eIgnoreCase
)
&
&
!
aContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
mozeditorbogusnode
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
}
static
void
ConvertToNativeNewlines
(
nsAFlatString
&
aString
)
{
#
if
defined
(
XP_WIN
)
aString
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
n
"
)
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
)
;
#
endif
}
static
void
AppendString
(
nsAString
&
aString
nsIContent
*
aContent
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
;
}
text
-
>
AppendTo
(
aString
)
;
}
static
void
AppendSubString
(
nsAString
&
aString
nsIContent
*
aContent
uint32_t
aXPOffset
uint32_t
aXPLength
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
;
}
text
-
>
AppendTo
(
aString
int32_t
(
aXPOffset
)
int32_t
(
aXPLength
)
)
;
}
#
if
defined
(
XP_WIN
)
static
uint32_t
CountNewlinesInXPLength
(
nsIContent
*
aContent
uint32_t
aXPLength
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
0
;
}
MOZ_ASSERT
(
aXPLength
=
=
UINT32_MAX
|
|
aXPLength
<
=
text
-
>
GetLength
(
)
"
aXPLength
is
out
-
of
-
bounds
"
)
;
const
uint32_t
length
=
std
:
:
min
(
aXPLength
text
-
>
GetLength
(
)
)
;
uint32_t
newlines
=
0
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
text
-
>
CharAt
(
i
)
=
=
'
\
n
'
)
{
+
+
newlines
;
}
}
return
newlines
;
}
static
uint32_t
CountNewlinesInNativeLength
(
nsIContent
*
aContent
uint32_t
aNativeLength
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
aContent
is
not
a
text
node
!
"
)
;
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
0
;
}
MOZ_ASSERT
(
(
aNativeLength
=
=
UINT32_MAX
|
|
aNativeLength
<
=
text
-
>
GetLength
(
)
*
2
)
"
aNativeLength
is
unexpected
value
"
)
;
const
uint32_t
xpLength
=
text
-
>
GetLength
(
)
;
uint32_t
newlines
=
0
;
for
(
uint32_t
i
=
0
nativeOffset
=
0
;
i
<
xpLength
&
&
nativeOffset
<
aNativeLength
;
+
+
i
+
+
nativeOffset
)
{
MOZ_ASSERT
(
i
<
text
-
>
GetLength
(
)
"
i
is
out
-
of
-
bounds
"
)
;
if
(
text
-
>
CharAt
(
i
)
=
=
'
\
n
'
)
{
+
+
newlines
;
+
+
nativeOffset
;
}
}
return
newlines
;
}
#
endif
uint32_t
ContentEventHandler
:
:
GetNativeTextLength
(
nsIContent
*
aContent
uint32_t
aStartOffset
uint32_t
aEndOffset
)
{
MOZ_ASSERT
(
aEndOffset
>
=
aStartOffset
"
aEndOffset
must
be
equals
or
larger
than
aStartOffset
"
)
;
if
(
NS_WARN_IF
(
!
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
)
{
return
0
;
}
if
(
aStartOffset
=
=
aEndOffset
)
{
return
0
;
}
return
GetTextLength
(
aContent
LINE_BREAK_TYPE_NATIVE
aEndOffset
)
-
GetTextLength
(
aContent
LINE_BREAK_TYPE_NATIVE
aStartOffset
)
;
}
uint32_t
ContentEventHandler
:
:
GetNativeTextLength
(
nsIContent
*
aContent
uint32_t
aMaxLength
)
{
if
(
NS_WARN_IF
(
!
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
)
{
return
0
;
}
return
GetTextLength
(
aContent
LINE_BREAK_TYPE_NATIVE
aMaxLength
)
;
}
uint32_t
ContentEventHandler
:
:
GetNativeTextLengthBefore
(
nsIContent
*
aContent
nsINode
*
aRootNode
)
{
if
(
NS_WARN_IF
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
)
{
return
0
;
}
return
ShouldBreakLineBefore
(
aContent
aRootNode
)
?
GetBRLength
(
LINE_BREAK_TYPE_NATIVE
)
:
0
;
}
uint32_t
ContentEventHandler
:
:
GetBRLength
(
LineBreakType
aLineBreakType
)
{
#
if
defined
(
XP_WIN
)
return
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
?
2
:
1
;
#
else
return
1
;
#
endif
}
uint32_t
ContentEventHandler
:
:
GetTextLength
(
nsIContent
*
aContent
LineBreakType
aLineBreakType
uint32_t
aMaxLength
)
{
MOZ_ASSERT
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
uint32_t
textLengthDifference
=
#
if
defined
(
XP_WIN
)
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
?
CountNewlinesInXPLength
(
aContent
aMaxLength
)
:
0
;
#
else
0
;
#
endif
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
if
(
!
text
)
{
return
0
;
}
uint32_t
length
=
std
:
:
min
(
text
-
>
GetLength
(
)
aMaxLength
)
;
return
length
+
textLengthDifference
;
}
static
uint32_t
ConvertToXPOffset
(
nsIContent
*
aContent
uint32_t
aNativeOffset
)
{
#
if
defined
(
XP_WIN
)
return
aNativeOffset
-
CountNewlinesInNativeLength
(
aContent
aNativeOffset
)
;
#
else
return
aNativeOffset
;
#
endif
}
bool
ContentEventHandler
:
:
ShouldBreakLineBefore
(
nsIContent
*
aContent
nsINode
*
aRootNode
)
{
if
(
aContent
=
=
aRootNode
)
{
return
false
;
}
if
(
!
aContent
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
return
IsContentBR
(
aContent
)
;
}
if
(
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
acronym
nsGkAtoms
:
:
b
nsGkAtoms
:
:
bdi
nsGkAtoms
:
:
bdo
nsGkAtoms
:
:
big
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
code
nsGkAtoms
:
:
data
nsGkAtoms
:
:
del
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
em
nsGkAtoms
:
:
font
nsGkAtoms
:
:
i
nsGkAtoms
:
:
ins
nsGkAtoms
:
:
kbd
nsGkAtoms
:
:
mark
nsGkAtoms
:
:
s
nsGkAtoms
:
:
samp
nsGkAtoms
:
:
small
nsGkAtoms
:
:
span
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
sub
nsGkAtoms
:
:
sup
nsGkAtoms
:
:
time
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
u
nsGkAtoms
:
:
var
)
)
{
return
false
;
}
RefPtr
<
HTMLUnknownElement
>
unknownHTMLElement
=
do_QueryObject
(
aContent
)
;
return
!
unknownHTMLElement
;
}
nsresult
ContentEventHandler
:
:
GenerateFlatTextContent
(
nsRange
*
aRange
nsAFlatString
&
aString
LineBreakType
aLineBreakType
)
{
NS_ASSERTION
(
aString
.
IsEmpty
(
)
"
aString
must
be
empty
string
"
)
;
if
(
aRange
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
nsINode
*
startNode
=
aRange
-
>
GetStartParent
(
)
;
nsINode
*
endNode
=
aRange
-
>
GetEndParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
startNode
=
=
endNode
&
&
startNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
nsIContent
*
content
=
startNode
-
>
AsContent
(
)
;
AppendSubString
(
aString
content
aRange
-
>
StartOffset
(
)
aRange
-
>
EndOffset
(
)
-
aRange
-
>
StartOffset
(
)
)
;
ConvertToNativeNewlines
(
aString
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
content
=
=
startNode
)
{
AppendSubString
(
aString
content
aRange
-
>
StartOffset
(
)
content
-
>
TextLength
(
)
-
aRange
-
>
StartOffset
(
)
)
;
}
else
if
(
content
=
=
endNode
)
{
AppendSubString
(
aString
content
0
aRange
-
>
EndOffset
(
)
)
;
}
else
{
AppendString
(
aString
content
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
content
mRootContent
)
)
{
aString
.
Append
(
char16_t
(
'
\
n
'
)
)
;
}
}
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
ConvertToNativeNewlines
(
aString
)
;
}
return
NS_OK
;
}
static
FontRange
*
AppendFontRange
(
nsTArray
<
FontRange
>
&
aFontRanges
uint32_t
aBaseOffset
)
{
FontRange
*
fontRange
=
aFontRanges
.
AppendElement
(
)
;
fontRange
-
>
mStartOffset
=
aBaseOffset
;
return
fontRange
;
}
uint32_t
ContentEventHandler
:
:
GetTextLengthInRange
(
nsIContent
*
aContent
uint32_t
aXPStartOffset
uint32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
return
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
?
GetNativeTextLength
(
aContent
aXPStartOffset
aXPEndOffset
)
:
aXPEndOffset
-
aXPStartOffset
;
}
void
ContentEventHandler
:
:
AppendFontRanges
(
FontRangeArray
&
aFontRanges
nsIContent
*
aContent
int32_t
aBaseOffset
int32_t
aXPStartOffset
int32_t
aXPEndOffset
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
AppendFontRange
(
aFontRanges
aBaseOffset
)
;
return
;
}
int32_t
baseOffset
=
aBaseOffset
;
nsTextFrame
*
curr
=
do_QueryFrame
(
frame
)
;
MOZ_ASSERT
(
curr
"
Not
a
text
frame
"
)
;
while
(
curr
)
{
int32_t
frameXPStart
=
std
:
:
max
(
curr
-
>
GetContentOffset
(
)
aXPStartOffset
)
;
int32_t
frameXPEnd
=
std
:
:
min
(
curr
-
>
GetContentEnd
(
)
aXPEndOffset
)
;
if
(
frameXPStart
>
=
frameXPEnd
)
{
curr
=
static_cast
<
nsTextFrame
*
>
(
curr
-
>
GetNextContinuation
(
)
)
;
continue
;
}
gfxSkipCharsIterator
iter
=
curr
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
curr
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
*
next
=
nullptr
;
if
(
frameXPEnd
<
aXPEndOffset
)
{
next
=
static_cast
<
nsTextFrame
*
>
(
curr
-
>
GetNextContinuation
(
)
)
;
while
(
next
&
&
next
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
textRun
)
{
frameXPEnd
=
std
:
:
min
(
next
-
>
GetContentEnd
(
)
aXPEndOffset
)
;
next
=
frameXPEnd
<
aXPEndOffset
?
static_cast
<
nsTextFrame
*
>
(
next
-
>
GetNextContinuation
(
)
)
:
nullptr
;
}
}
gfxTextRun
:
:
Range
skipRange
(
iter
.
ConvertOriginalToSkipped
(
frameXPStart
)
iter
.
ConvertOriginalToSkipped
(
frameXPEnd
)
)
;
gfxTextRun
:
:
GlyphRunIterator
runIter
(
textRun
skipRange
)
;
int32_t
lastXPEndOffset
=
frameXPStart
;
while
(
runIter
.
NextRun
(
)
)
{
gfxFont
*
font
=
runIter
.
GetGlyphRun
(
)
-
>
mFont
.
get
(
)
;
int32_t
startXPOffset
=
iter
.
ConvertSkippedToOriginal
(
runIter
.
GetStringStart
(
)
)
;
if
(
startXPOffset
>
=
frameXPEnd
)
{
break
;
}
if
(
startXPOffset
>
lastXPEndOffset
)
{
AppendFontRange
(
aFontRanges
baseOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aContent
lastXPEndOffset
startXPOffset
aLineBreakType
)
;
lastXPEndOffset
=
startXPOffset
;
}
FontRange
*
fontRange
=
AppendFontRange
(
aFontRanges
baseOffset
)
;
fontRange
-
>
mFontName
=
font
-
>
GetName
(
)
;
fontRange
-
>
mFontSize
=
font
-
>
GetAdjustedSize
(
)
;
int32_t
endXPOffset
=
iter
.
ConvertSkippedToOriginal
(
runIter
.
GetStringEnd
(
)
)
;
endXPOffset
=
std
:
:
min
(
frameXPEnd
endXPOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aContent
startXPOffset
endXPOffset
aLineBreakType
)
;
lastXPEndOffset
=
endXPOffset
;
}
if
(
lastXPEndOffset
<
frameXPEnd
)
{
AppendFontRange
(
aFontRanges
baseOffset
)
;
baseOffset
+
=
GetTextLengthInRange
(
aContent
lastXPEndOffset
frameXPEnd
aLineBreakType
)
;
}
curr
=
next
;
}
}
nsresult
ContentEventHandler
:
:
GenerateFlatFontRanges
(
nsRange
*
aRange
FontRangeArray
&
aFontRanges
uint32_t
&
aLength
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aFontRanges
.
IsEmpty
(
)
"
aRanges
must
be
empty
array
"
)
;
if
(
aRange
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
nsINode
*
startNode
=
aRange
-
>
GetStartParent
(
)
;
nsINode
*
endNode
=
aRange
-
>
GetEndParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
baseOffset
=
0
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aRange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
int32_t
startOffset
=
content
!
=
startNode
?
0
:
aRange
-
>
StartOffset
(
)
;
int32_t
endOffset
=
content
!
=
endNode
?
content
-
>
TextLength
(
)
:
aRange
-
>
EndOffset
(
)
;
AppendFontRanges
(
aFontRanges
content
baseOffset
startOffset
endOffset
aLineBreakType
)
;
baseOffset
+
=
GetTextLengthInRange
(
content
startOffset
endOffset
aLineBreakType
)
;
}
else
if
(
ShouldBreakLineBefore
(
content
mRootContent
)
)
{
if
(
aFontRanges
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
baseOffset
=
=
0
)
;
FontRange
*
fontRange
=
AppendFontRange
(
aFontRanges
baseOffset
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
const
nsFont
&
font
=
frame
-
>
GetParent
(
)
-
>
StyleFont
(
)
-
>
mFont
;
const
FontFamilyList
&
fontList
=
font
.
fontlist
;
const
FontFamilyName
&
fontName
=
fontList
.
IsEmpty
(
)
?
FontFamilyName
(
fontList
.
GetDefaultFontType
(
)
)
:
fontList
.
GetFontlist
(
)
[
0
]
;
fontName
.
AppendToString
(
fontRange
-
>
mFontName
false
)
;
fontRange
-
>
mFontSize
=
frame
-
>
PresContext
(
)
-
>
AppUnitsToDevPixels
(
font
.
size
)
;
}
}
baseOffset
+
=
GetBRLength
(
aLineBreakType
)
;
}
}
aLength
=
baseOffset
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
ExpandToClusterBoundary
(
nsIContent
*
aContent
bool
aForward
uint32_t
*
aXPOffset
)
{
if
(
!
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
|
|
*
aXPOffset
=
=
0
|
|
*
aXPOffset
=
=
aContent
-
>
TextLength
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
*
aXPOffset
<
=
aContent
-
>
TextLength
(
)
"
offset
is
out
of
range
.
"
)
;
RefPtr
<
nsFrameSelection
>
fs
=
mPresShell
-
>
FrameSelection
(
)
;
int32_t
offsetInFrame
;
CaretAssociationHint
hint
=
aForward
?
CARET_ASSOCIATE_BEFORE
:
CARET_ASSOCIATE_AFTER
;
nsIFrame
*
frame
=
fs
-
>
GetFrameForNodeOffset
(
aContent
int32_t
(
*
aXPOffset
)
hint
&
offsetInFrame
)
;
if
(
!
frame
)
{
const
nsTextFragment
*
text
=
aContent
-
>
GetText
(
)
;
NS_ENSURE_TRUE
(
text
NS_ERROR_FAILURE
)
;
if
(
NS_IS_LOW_SURROGATE
(
text
-
>
CharAt
(
*
aXPOffset
)
)
&
&
NS_IS_HIGH_SURROGATE
(
text
-
>
CharAt
(
*
aXPOffset
-
1
)
)
)
{
*
aXPOffset
+
=
aForward
?
1
:
-
1
;
}
return
NS_OK
;
}
int32_t
startOffset
endOffset
;
nsresult
rv
=
frame
-
>
GetOffsets
(
startOffset
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
*
aXPOffset
=
=
static_cast
<
uint32_t
>
(
startOffset
)
|
|
*
aXPOffset
=
=
static_cast
<
uint32_t
>
(
endOffset
)
)
{
return
NS_OK
;
}
if
(
frame
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
textFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
int32_t
newOffsetInFrame
=
*
aXPOffset
-
startOffset
;
newOffsetInFrame
+
=
aForward
?
-
1
:
1
;
textFrame
-
>
PeekOffsetCharacter
(
aForward
&
newOffsetInFrame
)
;
*
aXPOffset
=
startOffset
+
newOffsetInFrame
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
SetRangeFromFlatTextOffset
(
nsRange
*
aRange
uint32_t
aOffset
uint32_t
aLength
LineBreakType
aLineBreakType
bool
aExpandToClusterBoundaries
uint32_t
*
aNewOffset
)
{
if
(
aNewOffset
)
{
*
aNewOffset
=
aOffset
;
}
if
(
!
mRootContent
-
>
HasChildren
(
)
)
{
nsresult
rv
=
aRange
-
>
SetStart
(
mRootContent
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aRange
-
>
SetEnd
(
mRootContent
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
mRootContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint32_t
offset
=
0
;
uint32_t
endOffset
=
aOffset
+
aLength
;
bool
startSet
=
false
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
node
=
=
mRootContent
|
|
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
uint32_t
textLength
=
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
?
GetTextLength
(
content
aLineBreakType
)
:
(
ShouldBreakLineBefore
(
content
mRootContent
)
?
GetBRLength
(
aLineBreakType
)
:
0
)
;
if
(
!
textLength
)
{
continue
;
}
if
(
!
startSet
&
&
aOffset
<
=
offset
+
textLength
)
{
nsINode
*
startNode
=
nullptr
;
int32_t
startNodeOffset
=
-
1
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
uint32_t
xpOffset
=
aOffset
-
offset
;
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
xpOffset
=
ConvertToXPOffset
(
content
xpOffset
)
;
}
if
(
aExpandToClusterBoundaries
)
{
uint32_t
oldXPOffset
=
xpOffset
;
rv
=
ExpandToClusterBoundary
(
content
false
&
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aNewOffset
)
{
*
aNewOffset
-
=
(
oldXPOffset
-
xpOffset
)
;
}
}
startNode
=
content
;
startNodeOffset
=
static_cast
<
int32_t
>
(
xpOffset
)
;
}
else
if
(
aOffset
<
offset
+
textLength
)
{
startNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startNodeOffset
=
startNode
-
>
IndexOf
(
content
)
;
if
(
NS_WARN_IF
(
startNodeOffset
=
=
-
1
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
!
content
-
>
HasChildren
(
)
)
{
startNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
startNode
)
)
{
return
NS_ERROR_FAILURE
;
}
startNodeOffset
=
startNode
-
>
IndexOf
(
content
)
+
1
;
if
(
NS_WARN_IF
(
startNodeOffset
=
=
0
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
startNode
=
content
;
startNodeOffset
=
0
;
}
NS_ASSERTION
(
startNode
"
startNode
must
not
be
nullptr
"
)
;
NS_ASSERTION
(
startNodeOffset
>
=
0
"
startNodeOffset
must
not
be
negative
"
)
;
rv
=
aRange
-
>
SetStart
(
startNode
startNodeOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
startSet
=
true
;
if
(
!
aLength
)
{
rv
=
aRange
-
>
SetEnd
(
startNode
startNodeOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
if
(
endOffset
<
=
offset
+
textLength
)
{
MOZ_ASSERT
(
startSet
"
The
start
of
the
range
should
'
ve
been
set
already
"
)
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
uint32_t
xpOffset
=
endOffset
-
offset
;
if
(
aLineBreakType
=
=
LINE_BREAK_TYPE_NATIVE
)
{
xpOffset
=
ConvertToXPOffset
(
content
xpOffset
)
;
}
if
(
aExpandToClusterBoundaries
)
{
rv
=
ExpandToClusterBoundary
(
content
true
&
xpOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
NS_ASSERTION
(
xpOffset
<
=
INT32_MAX
"
The
end
node
offset
is
too
large
"
)
;
rv
=
aRange
-
>
SetEnd
(
content
static_cast
<
int32_t
>
(
xpOffset
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
if
(
endOffset
=
=
offset
)
{
MOZ_ASSERT
(
false
"
This
case
should
'
ve
already
been
handled
at
"
"
the
last
node
which
caused
some
text
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
content
-
>
HasChildren
(
)
&
&
ShouldBreakLineBefore
(
content
mRootContent
)
)
{
rv
=
aRange
-
>
SetEnd
(
content
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsINode
*
endNode
=
content
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
endNode
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
indexInParent
=
endNode
-
>
IndexOf
(
content
)
;
if
(
NS_WARN_IF
(
indexInParent
=
=
-
1
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
aRange
-
>
SetEnd
(
endNode
indexInParent
+
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
offset
+
=
textLength
;
}
if
(
!
startSet
)
{
MOZ_ASSERT
(
!
mRootContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
;
if
(
!
offset
)
{
rv
=
aRange
-
>
SetStart
(
mRootContent
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aLength
)
{
rv
=
aRange
-
>
SetEnd
(
mRootContent
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
else
{
rv
=
aRange
-
>
SetStart
(
mRootContent
static_cast
<
int32_t
>
(
mRootContent
-
>
GetChildCount
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aNewOffset
)
{
*
aNewOffset
=
offset
;
}
}
rv
=
aRange
-
>
SetEnd
(
mRootContent
static_cast
<
int32_t
>
(
mRootContent
-
>
GetChildCount
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
WidgetQueryContentEvent
*
aEvent
)
{
return
GetLineBreakType
(
aEvent
-
>
mUseNativeLineBreak
)
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
WidgetSelectionEvent
*
aEvent
)
{
return
GetLineBreakType
(
aEvent
-
>
mUseNativeLineBreak
)
;
}
LineBreakType
ContentEventHandler
:
:
GetLineBreakType
(
bool
aUseNativeLineBreak
)
{
return
aUseNativeLineBreak
?
LINE_BREAK_TYPE_NATIVE
:
LINE_BREAK_TYPE_XP
;
}
nsresult
ContentEventHandler
:
:
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eQuerySelectedText
:
return
OnQuerySelectedText
(
aEvent
)
;
case
eQueryTextContent
:
return
OnQueryTextContent
(
aEvent
)
;
case
eQueryCaretRect
:
return
OnQueryCaretRect
(
aEvent
)
;
case
eQueryTextRect
:
return
OnQueryTextRect
(
aEvent
)
;
case
eQueryEditorRect
:
return
OnQueryEditorRect
(
aEvent
)
;
case
eQueryContentState
:
return
OnQueryContentState
(
aEvent
)
;
case
eQuerySelectionAsTransferable
:
return
OnQuerySelectionAsTransferable
(
aEvent
)
;
case
eQueryCharacterAtPoint
:
return
OnQueryCharacterAtPoint
(
aEvent
)
;
case
eQueryDOMWidgetHittest
:
return
OnQueryDOMWidgetHittest
(
aEvent
)
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
return
NS_OK
;
}
static
nsresult
GetFrameForTextRect
(
nsINode
*
aNode
int32_t
aNodeOffset
bool
aHint
nsIFrame
*
*
aReturnFrame
)
{
NS_ENSURE_TRUE
(
aNode
&
&
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
NS_ERROR_UNEXPECTED
)
;
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
aNode
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
int32_t
childNodeOffset
=
0
;
return
frame
-
>
GetChildFrameContainingOffset
(
aNodeOffset
aHint
&
childNodeOffset
aReturnFrame
)
;
}
nsresult
ContentEventHandler
:
:
OnQuerySelectedText
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsINode
*
const
startNode
=
mFirstSelectedRange
-
>
GetStartParent
(
)
;
nsINode
*
const
endNode
=
mFirstSelectedRange
-
>
GetEndParent
(
)
;
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
startNode
mRootContent
)
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
endNode
mRootContent
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ASSERTION
(
aEvent
-
>
mReply
.
mString
.
IsEmpty
(
)
"
The
reply
string
must
be
empty
"
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
rv
=
GetFlatTextLengthBefore
(
mFirstSelectedRange
&
aEvent
-
>
mReply
.
mOffset
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsINode
>
anchorNode
focusNode
;
int32_t
anchorOffset
focusOffset
;
if
(
mSelection
-
>
RangeCount
(
)
)
{
anchorNode
=
mSelection
-
>
GetAnchorNode
(
)
;
focusNode
=
mSelection
-
>
GetFocusNode
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
|
|
NS_WARN_IF
(
!
focusNode
)
)
{
return
NS_ERROR_FAILURE
;
}
anchorOffset
=
static_cast
<
int32_t
>
(
mSelection
-
>
AnchorOffset
(
)
)
;
focusOffset
=
static_cast
<
int32_t
>
(
mSelection
-
>
FocusOffset
(
)
)
;
if
(
NS_WARN_IF
(
anchorOffset
<
0
)
|
|
NS_WARN_IF
(
focusOffset
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
int16_t
compare
=
nsContentUtils
:
:
ComparePoints
(
anchorNode
anchorOffset
focusNode
focusOffset
)
;
aEvent
-
>
mReply
.
mReversed
=
compare
>
0
;
if
(
compare
)
{
RefPtr
<
nsRange
>
range
;
if
(
mSelection
-
>
RangeCount
(
)
=
=
1
)
{
range
=
mFirstSelectedRange
;
}
else
{
rv
=
nsRange
:
:
CreateRange
(
anchorNode
anchorOffset
focusNode
focusOffset
getter_AddRefs
(
range
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
range
)
)
{
return
NS_ERROR_FAILURE
;
}
}
rv
=
GenerateFlatTextContent
(
range
aEvent
-
>
mReply
.
mString
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
aEvent
-
>
mReply
.
mString
.
Truncate
(
)
;
}
}
else
{
NS_ASSERTION
(
mFirstSelectedRange
-
>
Collapsed
(
)
"
When
mSelection
doesn
'
t
have
selection
mFirstSelectedRange
must
be
"
"
collapsed
"
)
;
anchorNode
=
focusNode
=
mFirstSelectedRange
-
>
GetStartParent
(
)
;
if
(
NS_WARN_IF
(
!
anchorNode
)
)
{
return
NS_ERROR_FAILURE
;
}
anchorOffset
=
focusOffset
=
static_cast
<
int32_t
>
(
mFirstSelectedRange
-
>
StartOffset
(
)
)
;
if
(
NS_WARN_IF
(
anchorOffset
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
mReply
.
mReversed
=
false
;
aEvent
-
>
mReply
.
mString
.
Truncate
(
)
;
}
nsIFrame
*
frame
=
nullptr
;
rv
=
GetFrameForTextRect
(
focusNode
focusOffset
true
&
frame
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
frame
)
{
aEvent
-
>
mReply
.
mWritingMode
=
frame
-
>
GetWritingMode
(
)
;
}
else
{
aEvent
-
>
mReply
.
mWritingMode
=
WritingMode
(
)
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextContent
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_ASSERTION
(
aEvent
-
>
mReply
.
mString
.
IsEmpty
(
)
"
The
reply
string
must
be
empty
"
)
;
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mRootContent
)
;
rv
=
SetRangeFromFlatTextOffset
(
range
aEvent
-
>
mInput
.
mOffset
aEvent
-
>
mInput
.
mLength
lineBreakType
false
&
aEvent
-
>
mReply
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GenerateFlatTextContent
(
range
aEvent
-
>
mReply
.
mString
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aEvent
-
>
mWithFontRanges
)
{
uint32_t
fontRangeLength
;
rv
=
GenerateFlatFontRanges
(
range
aEvent
-
>
mReply
.
mFontRanges
fontRangeLength
lineBreakType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
fontRangeLength
=
=
aEvent
-
>
mReply
.
mString
.
Length
(
)
"
Font
ranges
doesn
'
t
match
the
string
"
)
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
static
nsINode
*
AdjustTextRectNode
(
nsINode
*
aNode
int32_t
&
aNodeOffset
)
{
int32_t
childCount
=
int32_t
(
aNode
-
>
GetChildCount
(
)
)
;
nsINode
*
node
=
aNode
;
if
(
childCount
)
{
if
(
aNodeOffset
<
childCount
)
{
node
=
aNode
-
>
GetChildAt
(
aNodeOffset
)
;
aNodeOffset
=
0
;
}
else
if
(
aNodeOffset
=
=
childCount
)
{
node
=
aNode
-
>
GetChildAt
(
childCount
-
1
)
;
aNodeOffset
=
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
?
static_cast
<
int32_t
>
(
static_cast
<
nsIContent
*
>
(
node
)
-
>
TextLength
(
)
)
:
1
;
}
}
return
node
;
}
nsresult
ContentEventHandler
:
:
OnQueryTextRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mRootContent
)
;
rv
=
SetRangeFromFlatTextOffset
(
range
aEvent
-
>
mInput
.
mOffset
aEvent
-
>
mInput
.
mLength
lineBreakType
true
&
aEvent
-
>
mReply
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GenerateFlatTextContent
(
range
aEvent
-
>
mReply
.
mString
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
iter
-
>
Init
(
range
)
;
int32_t
nodeOffset
=
range
-
>
StartOffset
(
)
;
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
!
node
)
{
node
=
AdjustTextRectNode
(
range
-
>
GetStartParent
(
)
nodeOffset
)
;
}
nsIFrame
*
firstFrame
=
nullptr
;
rv
=
GetFrameForTextRect
(
node
nodeOffset
true
&
firstFrame
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsRect
rect
(
nsPoint
(
0
0
)
firstFrame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
firstFrame
rect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsRect
frameRect
=
rect
;
nsPoint
ptOffset
;
firstFrame
-
>
GetPointFromOffset
(
nodeOffset
&
ptOffset
)
;
if
(
firstFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
rect
.
y
+
=
ptOffset
.
y
-
1
;
rect
.
height
-
=
ptOffset
.
y
-
1
;
}
else
{
rect
.
x
+
=
ptOffset
.
x
-
1
;
rect
.
width
-
=
ptOffset
.
x
-
1
;
}
nodeOffset
=
range
-
>
EndOffset
(
)
;
node
=
AdjustTextRectNode
(
range
-
>
GetEndParent
(
)
nodeOffset
)
;
nsIFrame
*
lastFrame
=
nullptr
;
rv
=
GetFrameForTextRect
(
node
nodeOffset
range
-
>
Collapsed
(
)
&
lastFrame
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
nsIFrame
*
frame
=
firstFrame
;
frame
!
=
lastFrame
;
)
{
frame
=
frame
-
>
GetNextContinuation
(
)
;
if
(
!
frame
)
{
do
{
iter
-
>
Next
(
)
;
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
!
node
)
{
break
;
}
if
(
!
node
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
{
continue
;
}
frame
=
static_cast
<
nsIContent
*
>
(
node
)
-
>
GetPrimaryFrame
(
)
;
}
while
(
!
frame
&
&
!
iter
-
>
IsDone
(
)
)
;
if
(
!
frame
)
{
frame
=
lastFrame
;
}
}
frameRect
.
SetRect
(
nsPoint
(
0
0
)
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
rv
=
ConvertToRootRelativeOffset
(
frame
frameRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
frame
!
=
lastFrame
)
{
rect
.
UnionRect
(
rect
frameRect
)
;
}
}
lastFrame
-
>
GetPointFromOffset
(
nodeOffset
&
ptOffset
)
;
if
(
lastFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
frameRect
.
height
-
=
lastFrame
-
>
GetRect
(
)
.
height
-
ptOffset
.
y
-
1
;
}
else
{
frameRect
.
width
-
=
lastFrame
-
>
GetRect
(
)
.
width
-
ptOffset
.
x
-
1
;
}
if
(
firstFrame
=
=
lastFrame
)
{
rect
.
IntersectRect
(
rect
frameRect
)
;
}
else
{
rect
.
UnionRect
(
rect
frameRect
)
;
}
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
aEvent
-
>
mReply
.
mWritingMode
=
lastFrame
-
>
GetWritingMode
(
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryEditorRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsIContent
*
focusedContent
=
GetFocusedContent
(
)
;
rv
=
QueryContentRect
(
IsPlugin
(
focusedContent
)
?
focusedContent
:
mRootContent
.
get
(
)
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryCaretRect
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
LineBreakType
lineBreakType
=
GetLineBreakType
(
aEvent
)
;
nsRect
caretRect
;
if
(
mSelection
-
>
IsCollapsed
(
)
)
{
nsIFrame
*
caretFrame
=
nsCaret
:
:
GetGeometry
(
mSelection
&
caretRect
)
;
if
(
caretFrame
)
{
uint32_t
offset
;
rv
=
GetFlatTextLengthBefore
(
mFirstSelectedRange
&
offset
lineBreakType
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
aEvent
-
>
mInput
.
mOffset
)
{
rv
=
ConvertToRootRelativeOffset
(
caretFrame
caretRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nscoord
appUnitsPerDevPixel
=
caretFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
caretRect
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
)
;
aEvent
-
>
mReply
.
mWritingMode
=
caretFrame
-
>
GetWritingMode
(
)
;
aEvent
-
>
mReply
.
mOffset
=
aEvent
-
>
mInput
.
mOffset
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
}
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mRootContent
)
;
rv
=
SetRangeFromFlatTextOffset
(
range
aEvent
-
>
mInput
.
mOffset
0
lineBreakType
true
&
aEvent
-
>
mReply
.
mOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
AdjustCollapsedRangeMaybeIntoTextNode
(
range
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int32_t
xpOffsetInFrame
;
nsIFrame
*
frame
;
rv
=
GetStartFrameAndOffset
(
range
frame
xpOffsetInFrame
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsPoint
posInFrame
;
rv
=
frame
-
>
GetPointFromOffset
(
range
-
>
StartOffset
(
)
&
posInFrame
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mReply
.
mWritingMode
=
frame
-
>
GetWritingMode
(
)
;
bool
isVertical
=
aEvent
-
>
mReply
.
mWritingMode
.
IsVertical
(
)
;
nsRect
rect
;
rect
.
x
=
posInFrame
.
x
;
rect
.
y
=
posInFrame
.
y
;
RefPtr
<
nsFontMetrics
>
fontMetrics
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
frame
)
;
if
(
isVertical
)
{
rect
.
width
=
fontMetrics
-
>
MaxHeight
(
)
;
rect
.
height
=
caretRect
.
height
;
}
else
{
rect
.
width
=
caretRect
.
width
;
rect
.
height
=
fontMetrics
-
>
MaxHeight
(
)
;
}
rv
=
ConvertToRootRelativeOffset
(
frame
rect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mReply
.
mRect
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rect
.
ToOutsidePixels
(
mPresContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
if
(
!
aEvent
-
>
mReply
.
mRect
.
width
)
{
aEvent
-
>
mReply
.
mRect
.
width
=
1
;
}
if
(
!
aEvent
-
>
mReply
.
mRect
.
height
)
{
aEvent
-
>
mReply
.
mRect
.
height
=
1
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryContentState
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQuerySelectionAsTransferable
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aEvent
-
>
mReply
.
mHasSelection
)
{
aEvent
-
>
mSucceeded
=
true
;
aEvent
-
>
mReply
.
mTransferable
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mPresShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
rv
=
nsCopySupport
:
:
GetTransferableForSelection
(
mSelection
doc
getter_AddRefs
(
aEvent
-
>
mReply
.
mTransferable
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryCharacterAtPoint
(
WidgetQueryContentEvent
*
aEvent
)
{
nsresult
rv
=
Init
(
aEvent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mReply
.
mOffset
=
aEvent
-
>
mReply
.
mTentativeCaretOffset
=
WidgetQueryContentEvent
:
:
NOT_FOUND
;
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
NS_ERROR_FAILURE
)
;
nsIWidget
*
rootWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
rootWidget
NS_ERROR_FAILURE
)
;
if
(
rootWidget
!
=
aEvent
-
>
mWidget
)
{
NS_PRECONDITION
(
aEvent
-
>
mWidget
"
The
event
must
have
the
widget
"
)
;
nsView
*
view
=
nsView
:
:
GetViewFor
(
aEvent
-
>
mWidget
)
;
NS_ENSURE_TRUE
(
view
NS_ERROR_FAILURE
)
;
rootFrame
=
view
-
>
GetFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
NS_ERROR_FAILURE
)
;
rootWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
rootWidget
NS_ERROR_FAILURE
)
;
}
WidgetQueryContentEvent
eventOnRoot
(
true
eQueryCharacterAtPoint
rootWidget
)
;
eventOnRoot
.
mUseNativeLineBreak
=
aEvent
-
>
mUseNativeLineBreak
;
eventOnRoot
.
mRefPoint
=
aEvent
-
>
mRefPoint
;
if
(
rootWidget
!
=
aEvent
-
>
mWidget
)
{
eventOnRoot
.
mRefPoint
+
=
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
-
rootWidget
-
>
WidgetToScreenOffset
(
)
;
}
nsPoint
ptInRoot
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
&
eventOnRoot
rootFrame
)
;
nsIFrame
*
targetFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
ptInRoot
)
;
if
(
!
targetFrame
|
|
!
targetFrame
-
>
GetContent
(
)
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
targetFrame
-
>
GetContent
(
)
mRootContent
)
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsPoint
ptInTarget
=
ptInRoot
+
rootFrame
-
>
GetOffsetToCrossDoc
(
targetFrame
)
;
int32_t
rootAPD
=
rootFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
targetAPD
=
targetFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
ptInTarget
=
ptInTarget
.
ScaleToOtherAppUnits
(
rootAPD
targetAPD
)
;
nsIFrame
:
:
ContentOffsets
tentativeCaretOffsets
=
targetFrame
-
>
GetContentOffsetsFromPoint
(
ptInTarget
)
;
if
(
!
tentativeCaretOffsets
.
content
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
tentativeCaretOffsets
.
content
mRootContent
)
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
rv
=
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
tentativeCaretOffsets
)
mRootContent
&
aEvent
-
>
mReply
.
mTentativeCaretOffset
GetLineBreakType
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
targetFrame
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
textFrame
)
{
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
MOZ_ASSERT
(
aEvent
-
>
mReply
.
mTentativeCaretOffset
!
=
WidgetQueryContentEvent
:
:
NOT_FOUND
"
The
point
is
inside
a
character
bounding
box
.
Why
tentative
caret
point
"
"
hasn
'
t
been
found
?
"
)
;
nsTextFrame
*
textframe
=
static_cast
<
nsTextFrame
*
>
(
targetFrame
)
;
nsIFrame
:
:
ContentOffsets
contentOffsets
=
textframe
-
>
GetCharacterOffsetAtFramePoint
(
ptInTarget
)
;
NS_ENSURE_TRUE
(
contentOffsets
.
content
NS_ERROR_FAILURE
)
;
uint32_t
offset
;
rv
=
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
contentOffsets
)
mRootContent
&
offset
GetLineBreakType
(
aEvent
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
WidgetQueryContentEvent
textRect
(
true
eQueryTextRect
aEvent
-
>
mWidget
)
;
textRect
.
InitForQueryTextRect
(
offset
1
aEvent
-
>
mUseNativeLineBreak
)
;
rv
=
OnQueryTextRect
(
&
textRect
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
textRect
.
mSucceeded
NS_ERROR_FAILURE
)
;
aEvent
-
>
mReply
.
mOffset
=
offset
;
aEvent
-
>
mReply
.
mRect
=
textRect
.
mReply
.
mRect
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
OnQueryDOMWidgetHittest
(
WidgetQueryContentEvent
*
aEvent
)
{
NS_ASSERTION
(
aEvent
"
aEvent
must
not
be
null
"
)
;
nsresult
rv
=
InitBasic
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aEvent
-
>
mSucceeded
=
false
;
aEvent
-
>
mReply
.
mWidgetIsHit
=
false
;
NS_ENSURE_TRUE
(
aEvent
-
>
mWidget
NS_ERROR_FAILURE
)
;
nsIDocument
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsIFrame
*
docFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
docFrame
NS_ERROR_FAILURE
)
;
LayoutDeviceIntPoint
eventLoc
=
aEvent
-
>
mRefPoint
+
aEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
;
nsIntRect
docFrameRect
=
docFrame
-
>
GetScreenRect
(
)
;
CSSIntPoint
eventLocCSS
(
mPresContext
-
>
DevPixelsToIntCSSPixels
(
eventLoc
.
x
)
-
docFrameRect
.
x
mPresContext
-
>
DevPixelsToIntCSSPixels
(
eventLoc
.
y
)
-
docFrameRect
.
y
)
;
Element
*
contentUnderMouse
=
doc
-
>
ElementFromPointHelper
(
eventLocCSS
.
x
eventLocCSS
.
y
false
false
)
;
if
(
contentUnderMouse
)
{
nsIWidget
*
targetWidget
=
nullptr
;
nsIFrame
*
targetFrame
=
contentUnderMouse
-
>
GetPrimaryFrame
(
)
;
nsIObjectFrame
*
pluginFrame
=
do_QueryFrame
(
targetFrame
)
;
if
(
pluginFrame
)
{
targetWidget
=
pluginFrame
-
>
GetWidget
(
)
;
}
else
if
(
targetFrame
)
{
targetWidget
=
targetFrame
-
>
GetNearestWidget
(
)
;
}
if
(
aEvent
-
>
mWidget
=
=
targetWidget
)
{
aEvent
-
>
mReply
.
mWidgetIsHit
=
true
;
}
}
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
const
NodePosition
&
aStartPosition
const
NodePosition
&
aEndPosition
nsIContent
*
aRootContent
uint32_t
*
aLength
LineBreakType
aLineBreakType
bool
aIsRemovingNode
)
{
if
(
NS_WARN_IF
(
!
aRootContent
)
|
|
NS_WARN_IF
(
!
aStartPosition
.
IsValid
(
)
)
|
|
NS_WARN_IF
(
!
aEndPosition
.
IsValid
(
)
)
|
|
NS_WARN_IF
(
!
aLength
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aStartPosition
=
=
aEndPosition
)
{
*
aLength
=
0
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContentIterator
>
iter
;
if
(
aIsRemovingNode
)
{
DebugOnly
<
nsIContent
*
>
parent
=
aStartPosition
.
mNode
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
&
&
parent
-
>
IndexOf
(
aStartPosition
.
mNode
)
=
=
-
1
"
At
removing
the
node
the
node
shouldn
'
t
be
in
the
array
of
children
"
"
of
its
parent
"
)
;
MOZ_ASSERT
(
aStartPosition
.
mNode
=
=
aEndPosition
.
mNode
"
At
removing
the
node
start
and
end
node
should
be
same
"
)
;
MOZ_ASSERT
(
aStartPosition
.
mOffset
=
=
0
"
When
the
node
is
being
removed
the
start
offset
should
be
0
"
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
aEndPosition
.
mOffset
)
=
=
aEndPosition
.
mNode
-
>
GetChildCount
(
)
"
When
the
node
is
being
removed
the
end
offset
should
be
child
count
"
)
;
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
aStartPosition
.
mNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
RefPtr
<
nsRange
>
prev
=
new
nsRange
(
aRootContent
)
;
nsresult
rv
=
aStartPosition
.
SetToRangeStart
(
prev
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NodePosition
endPosition
;
if
(
aEndPosition
.
mNode
!
=
aRootContent
&
&
aEndPosition
.
IsImmediatelyAfterOpenTag
(
)
)
{
if
(
aEndPosition
.
mNode
-
>
HasChildren
(
)
)
{
nsINode
*
firstChild
=
aEndPosition
.
mNode
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
return
NS_ERROR_FAILURE
;
}
endPosition
=
NodePosition
(
firstChild
0
)
;
}
else
{
nsIContent
*
parentContent
=
aEndPosition
.
mNode
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
parentContent
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
indexInParent
=
parentContent
-
>
IndexOf
(
aEndPosition
.
mNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
endPosition
=
NodePosition
(
parentContent
indexInParent
+
1
)
;
}
}
else
{
endPosition
=
aEndPosition
;
}
if
(
endPosition
.
OffsetIsValid
(
)
)
{
rv
=
endPosition
.
SetToRangeEnd
(
prev
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iter
=
NS_NewPreContentIterator
(
)
;
rv
=
iter
-
>
Init
(
prev
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
if
(
endPosition
.
mNode
!
=
aRootContent
)
{
rv
=
endPosition
.
SetToRangeEndAfter
(
prev
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
iter
=
NS_NewPreContentIterator
(
)
;
rv
=
iter
-
>
Init
(
prev
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
iter
=
NS_NewPreContentIterator
(
)
;
rv
=
iter
-
>
Init
(
aRootContent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
*
aLength
=
0
;
for
(
;
!
iter
-
>
IsDone
(
)
;
iter
-
>
Next
(
)
)
{
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
if
(
NS_WARN_IF
(
!
node
)
)
{
break
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
continue
;
}
nsIContent
*
content
=
node
-
>
AsContent
(
)
;
if
(
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
node
=
=
aEndPosition
.
mNode
)
{
*
aLength
+
=
GetTextLength
(
content
aLineBreakType
aEndPosition
.
mOffset
)
;
}
else
{
*
aLength
+
=
GetTextLength
(
content
aLineBreakType
)
;
}
}
else
if
(
ShouldBreakLineBefore
(
content
aRootContent
)
)
{
if
(
node
=
=
aStartPosition
.
mNode
&
&
!
aStartPosition
.
IsBeforeOpenTag
(
)
)
{
continue
;
}
*
aLength
+
=
GetBRLength
(
aLineBreakType
)
;
}
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetFlatTextLengthBefore
(
nsRange
*
aRange
uint32_t
*
aOffset
LineBreakType
aLineBreakType
)
{
MOZ_ASSERT
(
aRange
)
;
return
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePositionBefore
(
aRange
-
>
GetStartParent
(
)
aRange
-
>
StartOffset
(
)
)
mRootContent
aOffset
aLineBreakType
)
;
}
nsresult
ContentEventHandler
:
:
AdjustCollapsedRangeMaybeIntoTextNode
(
nsRange
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
MOZ_ASSERT
(
aRange
-
>
Collapsed
(
)
)
;
if
(
!
aRange
|
|
!
aRange
-
>
Collapsed
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsINode
>
parentNode
=
aRange
-
>
GetStartParent
(
)
;
int32_t
offsetInParentNode
=
aRange
-
>
StartOffset
(
)
;
if
(
NS_WARN_IF
(
!
parentNode
)
|
|
NS_WARN_IF
(
offsetInParentNode
<
0
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
parentNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
return
NS_OK
;
}
nsINode
*
childNode
=
nullptr
;
int32_t
offsetInChildNode
=
-
1
;
if
(
!
offsetInParentNode
&
&
parentNode
-
>
HasChildren
(
)
)
{
childNode
=
parentNode
-
>
GetFirstChild
(
)
;
offsetInChildNode
=
0
;
}
else
if
(
static_cast
<
uint32_t
>
(
offsetInParentNode
)
<
parentNode
-
>
GetChildCount
(
)
)
{
childNode
=
parentNode
-
>
GetChildAt
(
offsetInParentNode
-
1
)
;
offsetInChildNode
=
childNode
-
>
Length
(
)
;
}
if
(
!
childNode
|
|
!
childNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
|
|
NS_WARN_IF
(
offsetInChildNode
<
0
)
)
{
return
NS_OK
;
}
nsresult
rv
=
aRange
-
>
Set
(
childNode
offsetInChildNode
childNode
offsetInChildNode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
GetStartFrameAndOffset
(
const
nsRange
*
aRange
nsIFrame
*
&
aFrame
int32_t
&
aOffsetInFrame
)
{
MOZ_ASSERT
(
aRange
)
;
aFrame
=
nullptr
;
aOffsetInFrame
=
-
1
;
nsINode
*
node
=
aRange
-
>
GetStartParent
(
)
;
if
(
NS_WARN_IF
(
!
node
)
|
|
NS_WARN_IF
(
!
node
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
node
)
;
RefPtr
<
nsFrameSelection
>
fs
=
mPresShell
-
>
FrameSelection
(
)
;
aFrame
=
fs
-
>
GetFrameForNodeOffset
(
content
aRange
-
>
StartOffset
(
)
fs
-
>
GetHint
(
)
&
aOffsetInFrame
)
;
if
(
NS_WARN_IF
(
!
aFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ContentEventHandler
:
:
ConvertToRootRelativeOffset
(
nsIFrame
*
aFrame
nsRect
&
aRect
)
{
NS_ASSERTION
(
aFrame
"
aFrame
must
not
be
null
"
)
;
nsPresContext
*
thisPC
=
aFrame
-
>
PresContext
(
)
;
nsPresContext
*
rootPC
=
thisPC
-
>
GetRootPresContext
(
)
;
if
(
NS_WARN_IF
(
!
rootPC
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
rootFrame
=
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootFrame
)
)
{
return
NS_ERROR_FAILURE
;
}
aRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
aRect
rootFrame
)
;
aRect
=
aRect
.
ScaleToOtherAppUnitsRoundOut
(
rootPC
-
>
AppUnitsPerDevPixel
(
)
thisPC
-
>
AppUnitsPerDevPixel
(
)
)
;
return
NS_OK
;
}
static
void
AdjustRangeForSelection
(
nsIContent
*
aRoot
nsINode
*
*
aNode
int32_t
*
aNodeOffset
)
{
nsINode
*
node
=
*
aNode
;
int32_t
nodeOffset
=
*
aNodeOffset
;
if
(
aRoot
=
=
node
|
|
NS_WARN_IF
(
!
node
-
>
GetParent
(
)
)
|
|
!
node
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
return
;
}
int32_t
textLength
=
static_cast
<
int32_t
>
(
static_cast
<
nsIContent
*
>
(
node
)
-
>
TextLength
(
)
)
;
MOZ_ASSERT
(
nodeOffset
<
=
textLength
"
Offset
is
past
length
of
text
node
"
)
;
if
(
nodeOffset
!
=
textLength
)
{
return
;
}
nsIContent
*
aRootParent
=
aRoot
-
>
GetParent
(
)
;
if
(
NS_WARN_IF
(
!
aRootParent
)
)
{
return
;
}
if
(
!
aRootParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
textarea
)
)
{
return
;
}
*
aNode
=
node
-
>
GetParent
(
)
;
MOZ_ASSERT
(
(
*
aNode
)
-
>
IndexOf
(
node
)
!
=
-
1
)
;
*
aNodeOffset
=
(
*
aNode
)
-
>
IndexOf
(
node
)
+
1
;
}
nsresult
ContentEventHandler
:
:
OnSelectionEvent
(
WidgetSelectionEvent
*
aEvent
)
{
aEvent
-
>
mSucceeded
=
false
;
nsCOMPtr
<
nsISelection
>
sel
;
nsresult
rv
=
IMEStateManager
:
:
GetFocusSelectionAndRoot
(
getter_AddRefs
(
sel
)
getter_AddRefs
(
mRootContent
)
)
;
mSelection
=
static_cast
<
Selection
*
>
(
sel
.
get
(
)
)
;
if
(
rv
!
=
NS_ERROR_NOT_AVAILABLE
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
Init
(
aEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mRootContent
)
;
rv
=
SetRangeFromFlatTextOffset
(
range
aEvent
-
>
mOffset
aEvent
-
>
mLength
GetLineBreakType
(
aEvent
)
aEvent
-
>
mExpandToClusterBoundary
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsINode
*
startNode
=
range
-
>
GetStartParent
(
)
;
nsINode
*
endNode
=
range
-
>
GetEndParent
(
)
;
int32_t
startNodeOffset
=
range
-
>
StartOffset
(
)
;
int32_t
endNodeOffset
=
range
-
>
EndOffset
(
)
;
AdjustRangeForSelection
(
mRootContent
&
startNode
&
startNodeOffset
)
;
AdjustRangeForSelection
(
mRootContent
&
endNode
&
endNodeOffset
)
;
if
(
NS_WARN_IF
(
!
startNode
)
|
|
NS_WARN_IF
(
!
endNode
)
|
|
NS_WARN_IF
(
startNodeOffset
<
0
)
|
|
NS_WARN_IF
(
endNodeOffset
<
0
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
mSelection
-
>
StartBatchChanges
(
)
;
rv
=
mSelection
-
>
RemoveAllRanges
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aEvent
-
>
mReversed
)
{
rv
=
mSelection
-
>
Collapse
(
endNode
endNodeOffset
)
;
}
else
{
rv
=
mSelection
-
>
Collapse
(
startNode
startNodeOffset
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
startNode
!
=
endNode
|
|
startNodeOffset
!
=
endNodeOffset
)
)
{
if
(
aEvent
-
>
mReversed
)
{
rv
=
mSelection
-
>
Extend
(
startNode
startNodeOffset
)
;
}
else
{
rv
=
mSelection
-
>
Extend
(
endNode
endNodeOffset
)
;
}
}
}
mSelection
-
>
EndBatchChangesInternal
(
aEvent
-
>
mReason
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSelection
-
>
ScrollIntoViewInternal
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
false
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
)
;
aEvent
-
>
mSucceeded
=
true
;
return
NS_OK
;
}
}
