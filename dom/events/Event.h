#
ifndef
mozilla_dom_Event_h_
#
define
mozilla_dom_Event_h_
#
include
<
cstdint
>
#
include
"
Units
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
PickleIterator
;
class
nsCycleCollectionTraversalCallback
;
class
nsIContent
;
class
nsIGlobalObject
;
class
nsIPrincipal
;
class
nsPIDOMWindowInner
;
class
nsPresContext
;
namespace
IPC
{
class
Message
;
class
MessageReader
;
class
MessageWriter
;
}
namespace
mozilla
:
:
dom
{
class
BeforeUnloadEvent
;
class
CustomEvent
;
class
Document
;
class
DragEvent
;
class
EventTarget
;
class
EventMessageAutoOverride
;
class
ExtendableEvent
;
class
KeyboardEvent
;
class
MouseEvent
;
class
MessageEvent
;
class
PointerEvent
;
class
TimeEvent
;
class
ToggleEvent
;
class
UIEvent
;
class
WantsPopupControlCheck
;
class
XULCommandEvent
;
struct
EventInit
;
#
define
GENERATED_EVENT
(
EventClass_
)
class
EventClass_
;
#
include
"
mozilla
/
dom
/
GeneratedEventList
.
h
"
#
undef
GENERATED_EVENT
#
define
NS_EVENT_IID
\
{
0x71139716
0x4d91
0x4dee
{
0xba
0xf9
0xe3
0x3b
0x80
0xc1
0x61
0x61
}
}
class
Event
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_INLINE_DECL_STATIC_IID
(
NS_EVENT_IID
)
Event
(
EventTarget
*
aOwner
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
)
;
explicit
Event
(
nsPIDOMWindowInner
*
aWindow
)
;
protected
:
virtual
~
Event
(
)
;
void
LastRelease
(
)
;
private
:
void
ConstructorInit
(
EventTarget
*
aOwner
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
)
;
void
UpdateDefaultPreventedOnContentForDragEvent
(
)
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_WRAPPERCACHE_CLASS
(
Event
)
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mOwner
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
final
;
virtual
JSObject
*
WrapObjectInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
;
#
define
GENERATED_EVENT
(
EventClass_
)
\
virtual
EventClass_
*
As
#
#
EventClass_
(
)
{
return
nullptr
;
}
#
include
"
mozilla
/
dom
/
GeneratedEventList
.
h
"
#
undef
GENERATED_EVENT
virtual
ExtendableEvent
*
AsExtendableEvent
(
)
{
return
nullptr
;
}
virtual
TimeEvent
*
AsTimeEvent
(
)
{
return
nullptr
;
}
virtual
BeforeUnloadEvent
*
AsBeforeUnloadEvent
(
)
{
return
nullptr
;
}
virtual
KeyboardEvent
*
AsKeyboardEvent
(
)
{
return
nullptr
;
}
virtual
DragEvent
*
AsDragEvent
(
)
{
return
nullptr
;
}
virtual
XULCommandEvent
*
AsXULCommandEvent
(
)
{
return
nullptr
;
}
virtual
MouseEvent
*
AsMouseEvent
(
)
{
return
nullptr
;
}
virtual
PointerEvent
*
AsPointerEvent
(
)
{
return
nullptr
;
}
virtual
UIEvent
*
AsUIEvent
(
)
{
return
nullptr
;
}
virtual
CustomEvent
*
AsCustomEvent
(
)
{
return
nullptr
;
}
virtual
MessageEvent
*
AsMessageEvent
(
)
{
return
nullptr
;
}
virtual
ToggleEvent
*
AsToggleEvent
(
)
{
return
nullptr
;
}
void
InitEvent
(
const
nsAString
&
aEventTypeArg
bool
aCanBubble
bool
aCancelable
)
{
InitEvent
(
aEventTypeArg
aCanBubble
?
CanBubble
:
:
eYes
:
CanBubble
:
:
eNo
aCancelable
?
Cancelable
:
:
eYes
:
Cancelable
:
:
eNo
)
;
}
void
InitEvent
(
const
nsAString
&
aEventTypeArg
mozilla
:
:
CanBubble
mozilla
:
:
Cancelable
mozilla
:
:
Composed
=
mozilla
:
:
Composed
:
:
eDefault
)
;
void
SetTarget
(
EventTarget
*
aTarget
)
;
virtual
void
DuplicatePrivateData
(
)
;
bool
IsDispatchStopped
(
)
;
WidgetEvent
*
WidgetEventPtr
(
)
;
const
WidgetEvent
*
WidgetEventPtr
(
)
const
{
return
const_cast
<
Event
*
>
(
this
)
-
>
WidgetEventPtr
(
)
;
}
virtual
void
Serialize
(
IPC
:
:
MessageWriter
*
aWriter
bool
aSerializeInterfaceType
)
;
virtual
bool
Deserialize
(
IPC
:
:
MessageReader
*
aReader
)
;
void
SetOwner
(
EventTarget
*
aOwner
)
;
void
StopCrossProcessForwarding
(
)
;
void
SetTrusted
(
bool
aTrusted
)
;
bool
ShouldIgnoreChromeEventTargetListener
(
)
const
;
void
InitPresContextData
(
nsPresContext
*
aPresContext
)
;
bool
Init
(
EventTarget
*
aGlobal
)
;
static
const
char16_t
*
GetEventName
(
EventMessage
aEventType
)
;
static
CSSDoublePoint
GetClientCoords
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
LayoutDeviceDoublePoint
&
aWidgetOrScreenRelativePoint
const
CSSDoublePoint
&
aDefaultClientPoint
)
;
static
CSSDoublePoint
GetPageCoords
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
LayoutDeviceDoublePoint
&
aWidgetOrScreenRelativePoint
const
CSSDoublePoint
&
aDefaultClientPoint
)
;
static
Maybe
<
CSSDoublePoint
>
GetScreenCoords
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
LayoutDeviceDoublePoint
&
aWidgetOrScreenRelativePoint
)
;
MOZ_CAN_RUN_SCRIPT
static
CSSDoublePoint
GetOffsetCoords
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
const
LayoutDeviceDoublePoint
&
aWidgetOrScreenRelativePoint
const
CSSDoublePoint
&
aDefaultClientPoint
)
;
static
already_AddRefed
<
Event
>
Constructor
(
EventTarget
*
aEventTarget
const
nsAString
&
aType
const
EventInit
&
aParam
)
;
static
already_AddRefed
<
Event
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aType
const
EventInit
&
aParam
)
;
void
GetType
(
nsAString
&
aType
)
const
;
EventTarget
*
GetTarget
(
)
const
;
EventTarget
*
GetCurrentTarget
(
)
const
;
already_AddRefed
<
Document
>
GetDocument
(
)
const
;
void
ComposedPath
(
nsTArray
<
RefPtr
<
EventTarget
>
>
&
aPath
)
;
uint16_t
EventPhase
(
)
const
;
void
StopPropagation
(
)
;
void
StopImmediatePropagation
(
)
;
bool
Bubbles
(
)
const
{
return
mEvent
-
>
mFlags
.
mBubbles
;
}
bool
Cancelable
(
)
const
{
return
mEvent
-
>
mFlags
.
mCancelable
;
}
bool
Composed
(
)
const
{
return
mEvent
-
>
mFlags
.
mComposed
;
}
bool
CancelBubble
(
)
const
{
return
mEvent
-
>
PropagationStopped
(
)
;
}
void
SetCancelBubble
(
bool
aCancelBubble
)
{
if
(
aCancelBubble
)
{
mEvent
-
>
StopPropagation
(
)
;
}
}
void
PreventDefault
(
)
;
virtual
void
PreventDefault
(
JSContext
*
aCx
CallerType
aCallerType
)
;
bool
DefaultPrevented
(
CallerType
aCallerType
)
const
;
bool
DefaultPrevented
(
)
const
{
return
mEvent
-
>
DefaultPrevented
(
)
;
}
bool
DefaultPreventedByChrome
(
)
const
{
return
mEvent
-
>
mFlags
.
mDefaultPreventedByChrome
;
}
bool
DefaultPreventedByContent
(
)
const
{
return
mEvent
-
>
mFlags
.
mDefaultPreventedByContent
;
}
void
PreventMultipleActions
(
)
{
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
bool
MultipleActionsPrevented
(
)
const
{
return
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
;
}
bool
ReturnValue
(
CallerType
aCallerType
)
const
;
void
SetReturnValue
(
bool
aReturnValue
CallerType
aCallerType
)
;
bool
IsTrusted
(
)
const
{
return
mEvent
-
>
IsTrusted
(
)
;
}
bool
IsSynthesized
(
)
const
{
return
mEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
}
bool
IsSafeToBeDispatchedAsynchronously
(
)
const
{
return
mEventIsInternal
;
}
double
TimeStamp
(
)
;
EventTarget
*
GetOriginalTarget
(
)
const
;
EventTarget
*
GetExplicitOriginalTarget
(
)
const
;
EventTarget
*
GetComposedTarget
(
)
const
;
void
PreventDefaultInternal
(
bool
aCalledByDefaultHandler
nsIPrincipal
*
aPrincipal
=
nullptr
)
;
bool
IsMainThreadEvent
(
)
{
return
mIsMainThreadEvent
;
}
void
MarkUninitialized
(
)
{
mEvent
-
>
mMessage
=
eVoidEvent
;
mEvent
-
>
mSpecifiedEventTypeString
.
Truncate
(
)
;
mEvent
-
>
mSpecifiedEventType
=
nullptr
;
}
static
void
GetWidgetEventType
(
WidgetEvent
*
aEvent
nsAString
&
aType
)
;
void
RequestReplyFromRemoteContent
(
)
{
mEvent
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
}
bool
IsWaitingReplyFromRemoteContent
(
)
const
{
return
mEvent
-
>
IsWaitingReplyFromRemoteProcess
(
)
;
}
bool
IsReplyEventFromRemoteContent
(
)
const
{
return
mEvent
-
>
IsHandledInRemoteProcess
(
)
;
}
static
bool
IsDragExitEnabled
(
JSContext
*
aCx
JSObject
*
aGlobal
)
;
protected
:
void
SetEventType
(
const
nsAString
&
aEventTypeArg
)
;
nsIContent
*
GetTargetFromFrame
(
)
;
friend
class
EventMessageAutoOverride
;
friend
class
PopupBlocker
;
friend
class
WantsPopupControlCheck
;
void
SetWantsPopupControlCheck
(
bool
aCheck
)
{
mWantsPopupControlCheck
=
aCheck
;
}
bool
GetWantsPopupControlCheck
(
)
{
return
IsTrusted
(
)
&
&
mWantsPopupControlCheck
;
}
void
SetComposed
(
bool
aComposed
)
{
mEvent
-
>
SetComposed
(
aComposed
)
;
}
already_AddRefed
<
EventTarget
>
EnsureWebAccessibleRelatedTarget
(
EventTarget
*
aRelatedTarget
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
static
nsIFrame
*
GetPrimaryFrameOfEventTarget
(
const
nsPresContext
&
aPresContext
const
WidgetEvent
&
aEvent
)
;
mozilla
:
:
WidgetEvent
*
mEvent
;
WeakPtr
<
nsPresContext
>
mPresContext
;
nsCOMPtr
<
EventTarget
>
mExplicitOriginalTarget
;
nsCOMPtr
<
nsIGlobalObject
>
mOwner
;
bool
mEventIsInternal
;
bool
mPrivateDataDuplicated
;
bool
mIsMainThreadEvent
;
bool
mWantsPopupControlCheck
;
}
;
class
MOZ_RAII
EventMessageAutoOverride
{
public
:
explicit
EventMessageAutoOverride
(
Event
*
aEvent
EventMessage
aOverridingMessage
)
:
mEvent
(
aEvent
)
mOrigMessage
(
mEvent
-
>
mEvent
-
>
mMessage
)
{
MOZ_ASSERT
(
aOverridingMessage
!
=
mOrigMessage
"
Don
'
t
use
this
class
if
you
'
re
not
actually
overriding
"
)
;
MOZ_ASSERT
(
aOverridingMessage
!
=
eUnidentifiedEvent
"
Only
use
this
class
with
a
valid
overriding
EventMessage
"
)
;
MOZ_ASSERT
(
mOrigMessage
!
=
eUnidentifiedEvent
&
&
mEvent
-
>
mEvent
-
>
mSpecifiedEventTypeString
.
IsEmpty
(
)
"
Only
use
this
class
on
events
whose
overridden
type
is
"
"
known
(
so
we
can
restore
it
properly
)
"
)
;
mEvent
-
>
mEvent
-
>
mMessage
=
aOverridingMessage
;
}
~
EventMessageAutoOverride
(
)
{
mEvent
-
>
mEvent
-
>
mMessage
=
mOrigMessage
;
}
protected
:
Event
*
const
MOZ_NON_OWNING_REF
mEvent
;
const
EventMessage
mOrigMessage
;
}
;
class
MOZ_STACK_CLASS
WantsPopupControlCheck
{
public
:
explicit
WantsPopupControlCheck
(
Event
*
aEvent
)
:
mEvent
(
aEvent
)
{
mOriginalWantsPopupControlCheck
=
mEvent
-
>
GetWantsPopupControlCheck
(
)
;
mEvent
-
>
SetWantsPopupControlCheck
(
mEvent
-
>
IsTrusted
(
)
)
;
}
~
WantsPopupControlCheck
(
)
{
mEvent
-
>
SetWantsPopupControlCheck
(
mOriginalWantsPopupControlCheck
)
;
}
private
:
Event
*
mEvent
;
bool
mOriginalWantsPopupControlCheck
;
}
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Event
>
NS_NewDOMEvent
(
mozilla
:
:
dom
:
:
EventTarget
*
aOwner
nsPresContext
*
aPresContext
mozilla
:
:
WidgetEvent
*
aEvent
)
;
#
endif
