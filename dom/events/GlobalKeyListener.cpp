#
include
"
GlobalKeyListener
.
h
"
#
include
"
EventTarget
.
h
"
#
include
<
utility
>
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
KeyEventHandler
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ShortcutKeys
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
widget
/
IMEData
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
namespace
mozilla
{
using
namespace
mozilla
:
:
layers
;
GlobalKeyListener
:
:
GlobalKeyListener
(
dom
:
:
EventTarget
*
aTarget
)
:
mTarget
(
aTarget
)
mHandler
(
nullptr
)
{
}
NS_IMPL_ISUPPORTS
(
GlobalKeyListener
nsIDOMEventListener
)
static
void
BuildHandlerChain
(
nsIContent
*
aContent
KeyEventHandler
*
*
aResult
)
{
*
aResult
=
nullptr
;
for
(
nsIContent
*
key
=
aContent
-
>
GetLastChild
(
)
;
key
;
key
=
key
-
>
GetPreviousSibling
(
)
)
{
if
(
!
key
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
key
kNameSpaceID_XUL
)
)
{
continue
;
}
dom
:
:
Element
*
keyElement
=
key
-
>
AsElement
(
)
;
nsAutoString
valKey
valCharCode
valKeyCode
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
valKey
)
|
|
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
charcode
valCharCode
)
|
|
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
keycode
valKeyCode
)
;
if
(
valKey
.
IsEmpty
(
)
&
&
valCharCode
.
IsEmpty
(
)
&
&
valKeyCode
.
IsEmpty
(
)
)
{
continue
;
}
ReservedKey
reserved
=
ReservedKey_Unset
;
if
(
keyElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
reserved
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
reserved
=
ReservedKey_True
;
}
else
if
(
keyElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
reserved
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
reserved
=
ReservedKey_False
;
}
KeyEventHandler
*
handler
=
new
KeyEventHandler
(
keyElement
reserved
)
;
handler
-
>
SetNextHandler
(
*
aResult
)
;
*
aResult
=
handler
;
}
}
void
GlobalKeyListener
:
:
WalkHandlers
(
dom
:
:
KeyboardEvent
*
aKeyEvent
)
{
if
(
aKeyEvent
-
>
DefaultPrevented
(
)
)
{
return
;
}
if
(
!
aKeyEvent
-
>
IsTrusted
(
)
)
{
return
;
}
EnsureHandlers
(
)
;
if
(
IsDisabled
(
)
)
{
return
;
}
WalkHandlersInternal
(
aKeyEvent
true
)
;
}
void
GlobalKeyListener
:
:
InstallKeyboardEventListenersTo
(
EventListenerManager
*
aEventListenerManager
)
{
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
u
"
mozaccesskeynotfound
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
void
GlobalKeyListener
:
:
RemoveKeyboardEventListenersFrom
(
EventListenerManager
*
aEventListenerManager
)
{
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
u
"
mozaccesskeynotfound
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
NS_IMETHODIMP
GlobalKeyListener
:
:
HandleEvent
(
dom
:
:
Event
*
aEvent
)
{
RefPtr
<
dom
:
:
KeyboardEvent
>
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
NS_ENSURE_TRUE
(
keyEvent
NS_ERROR_INVALID_ARG
)
;
if
(
aEvent
-
>
EventPhase
(
)
=
=
dom
:
:
Event_Binding
:
:
CAPTURING_PHASE
)
{
if
(
aEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mInSystemGroup
)
{
HandleEventOnCaptureInSystemEventGroup
(
keyEvent
)
;
}
else
{
HandleEventOnCaptureInDefaultEventGroup
(
keyEvent
)
;
}
return
NS_OK
;
}
if
(
aEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mHandledByAPZ
)
{
aEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
WalkHandlers
(
keyEvent
)
;
return
NS_OK
;
}
void
GlobalKeyListener
:
:
HandleEventOnCaptureInDefaultEventGroup
(
dom
:
:
KeyboardEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
widgetKeyboardEvent
-
>
IsReservedByChrome
(
)
)
{
return
;
}
bool
isReserved
=
false
;
if
(
HasHandlerForEvent
(
aEvent
&
isReserved
)
&
&
isReserved
)
{
widgetKeyboardEvent
-
>
MarkAsReservedByChrome
(
)
;
}
}
void
GlobalKeyListener
:
:
HandleEventOnCaptureInSystemEventGroup
(
dom
:
:
KeyboardEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
widgetEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
widgetEvent
-
>
WillBeSentToRemoteProcess
(
)
)
{
return
;
}
if
(
!
HasHandlerForEvent
(
aEvent
)
)
{
return
;
}
widgetEvent
-
>
StopImmediatePropagation
(
)
;
widgetEvent
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
}
bool
GlobalKeyListener
:
:
WalkHandlersInternal
(
dom
:
:
KeyboardEvent
*
aKeyEvent
bool
aExecute
bool
*
aOutReservedForChrome
)
{
WidgetKeyboardEvent
*
nativeKeyboardEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
nativeKeyboardEvent
)
;
AutoShortcutKeyCandidateArray
shortcutKeys
;
nativeKeyboardEvent
-
>
GetShortcutKeyCandidates
(
shortcutKeys
)
;
if
(
shortcutKeys
.
IsEmpty
(
)
)
{
return
WalkHandlersAndExecute
(
aKeyEvent
0
IgnoreModifierState
(
)
aExecute
aOutReservedForChrome
)
;
}
for
(
unsigned
long
i
=
0
;
i
<
shortcutKeys
.
Length
(
)
;
+
+
i
)
{
ShortcutKeyCandidate
&
key
=
shortcutKeys
[
i
]
;
IgnoreModifierState
ignoreModifierState
;
ignoreModifierState
.
mShift
=
key
.
mIgnoreShift
;
if
(
WalkHandlersAndExecute
(
aKeyEvent
key
.
mCharCode
ignoreModifierState
aExecute
aOutReservedForChrome
)
)
{
return
true
;
}
}
return
false
;
}
bool
GlobalKeyListener
:
:
WalkHandlersAndExecute
(
dom
:
:
KeyboardEvent
*
aKeyEvent
uint32_t
aCharCode
const
IgnoreModifierState
&
aIgnoreModifierState
bool
aExecute
bool
*
aOutReservedForChrome
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
false
;
}
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetKeyboardEvent
)
)
{
return
false
;
}
nsAtom
*
eventType
=
ShortcutKeys
:
:
ConvertEventToDOMEventType
(
widgetKeyboardEvent
)
;
for
(
KeyEventHandler
*
handler
=
mHandler
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
bool
stopped
=
aKeyEvent
-
>
IsDispatchStopped
(
)
;
if
(
stopped
)
{
return
false
;
}
if
(
aExecute
)
{
if
(
!
handler
-
>
EventTypeEquals
(
eventType
)
)
{
continue
;
}
}
else
{
if
(
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
if
(
eventType
!
=
nsGkAtoms
:
:
keydown
&
&
eventType
!
=
nsGkAtoms
:
:
keypress
)
{
continue
;
}
}
else
if
(
!
handler
-
>
EventTypeEquals
(
eventType
)
)
{
continue
;
}
}
if
(
!
handler
-
>
KeyEventMatched
(
aKeyEvent
aCharCode
aIgnoreModifierState
)
)
{
continue
;
}
if
(
!
CanHandle
(
handler
aExecute
)
)
{
continue
;
}
if
(
!
aExecute
)
{
if
(
handler
-
>
EventTypeEquals
(
eventType
)
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
IsReservedKey
(
widgetKeyboardEvent
handler
)
;
}
return
true
;
}
if
(
eventType
=
=
nsGkAtoms
:
:
keydown
&
&
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
if
(
IsReservedKey
(
widgetKeyboardEvent
handler
)
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
true
;
}
return
true
;
}
}
continue
;
}
MOZ_ASSERT
(
!
aOutReservedForChrome
)
;
nsCOMPtr
<
dom
:
:
EventTarget
>
target
=
GetHandlerTarget
(
handler
)
;
nsresult
rv
=
handler
-
>
ExecuteHandler
(
target
aKeyEvent
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
true
;
}
}
#
ifdef
XP_WIN
if
(
!
aIgnoreModifierState
.
mOS
&
&
widgetKeyboardEvent
-
>
IsOS
(
)
)
{
IgnoreModifierState
ignoreModifierState
(
aIgnoreModifierState
)
;
ignoreModifierState
.
mOS
=
true
;
return
WalkHandlersAndExecute
(
aKeyEvent
aCharCode
ignoreModifierState
aExecute
)
;
}
#
endif
return
false
;
}
bool
GlobalKeyListener
:
:
IsReservedKey
(
WidgetKeyboardEvent
*
aKeyEvent
KeyEventHandler
*
aHandler
)
{
ReservedKey
reserved
=
aHandler
-
>
GetIsReserved
(
)
;
if
(
reserved
=
=
ReservedKey_False
)
{
return
false
;
}
if
(
reserved
!
=
ReservedKey_True
&
&
!
nsContentUtils
:
:
ShouldBlockReservedKeys
(
aKeyEvent
)
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
!
aKeyEvent
-
>
IsTrusted
(
)
|
|
!
aKeyEvent
-
>
mWidget
)
)
{
return
true
;
}
widget
:
:
InputContext
inputContext
=
aKeyEvent
-
>
mWidget
-
>
GetInputContext
(
)
;
if
(
!
inputContext
.
mIMEState
.
IsEditable
(
)
)
{
return
true
;
}
return
MOZ_UNLIKELY
(
!
aKeyEvent
-
>
IsEditCommandsInitialized
(
inputContext
.
GetNativeKeyBindingsType
(
)
)
)
|
|
aKeyEvent
-
>
EditCommandsConstRef
(
inputContext
.
GetNativeKeyBindingsType
(
)
)
.
IsEmpty
(
)
;
}
bool
GlobalKeyListener
:
:
HasHandlerForEvent
(
dom
:
:
KeyboardEvent
*
aEvent
bool
*
aOutReservedForChrome
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetKeyboardEvent
)
|
|
!
widgetKeyboardEvent
-
>
IsTrusted
(
)
)
{
return
false
;
}
EnsureHandlers
(
)
;
if
(
IsDisabled
(
)
)
{
return
false
;
}
return
WalkHandlersInternal
(
aEvent
false
aOutReservedForChrome
)
;
}
void
XULKeySetGlobalKeyListener
:
:
AttachKeyHandler
(
dom
:
:
Element
*
aElementTarget
)
{
nsCOMPtr
<
dom
:
:
Document
>
doc
=
aElementTarget
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
EventListenerManager
*
manager
=
doc
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
manager
)
{
return
;
}
if
(
aElementTarget
-
>
GetProperty
(
nsGkAtoms
:
:
listener
)
)
{
return
;
}
RefPtr
<
XULKeySetGlobalKeyListener
>
handler
=
new
XULKeySetGlobalKeyListener
(
aElementTarget
doc
)
;
handler
-
>
InstallKeyboardEventListenersTo
(
manager
)
;
aElementTarget
-
>
SetProperty
(
nsGkAtoms
:
:
listener
handler
.
forget
(
)
.
take
(
)
nsPropertyTable
:
:
SupportsDtorFunc
true
)
;
}
void
XULKeySetGlobalKeyListener
:
:
DetachKeyHandler
(
dom
:
:
Element
*
aElementTarget
)
{
nsCOMPtr
<
dom
:
:
Document
>
doc
=
aElementTarget
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
EventListenerManager
*
manager
=
doc
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
manager
)
{
return
;
}
nsIDOMEventListener
*
handler
=
static_cast
<
nsIDOMEventListener
*
>
(
aElementTarget
-
>
GetProperty
(
nsGkAtoms
:
:
listener
)
)
;
if
(
!
handler
)
{
return
;
}
static_cast
<
XULKeySetGlobalKeyListener
*
>
(
handler
)
-
>
RemoveKeyboardEventListenersFrom
(
manager
)
;
aElementTarget
-
>
RemoveProperty
(
nsGkAtoms
:
:
listener
)
;
}
XULKeySetGlobalKeyListener
:
:
XULKeySetGlobalKeyListener
(
dom
:
:
Element
*
aElement
dom
:
:
EventTarget
*
aTarget
)
:
GlobalKeyListener
(
aTarget
)
{
mWeakPtrForElement
=
do_GetWeakReference
(
aElement
)
;
}
dom
:
:
Element
*
XULKeySetGlobalKeyListener
:
:
GetElement
(
bool
*
aIsDisabled
)
const
{
RefPtr
<
dom
:
:
Element
>
element
=
do_QueryReferent
(
mWeakPtrForElement
)
;
if
(
element
&
&
aIsDisabled
)
{
*
aIsDisabled
=
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
return
element
.
get
(
)
;
}
XULKeySetGlobalKeyListener
:
:
~
XULKeySetGlobalKeyListener
(
)
{
if
(
mWeakPtrForElement
)
{
delete
mHandler
;
}
}
void
XULKeySetGlobalKeyListener
:
:
EnsureHandlers
(
)
{
if
(
mHandler
)
{
return
;
}
dom
:
:
Element
*
element
=
GetElement
(
)
;
if
(
!
element
)
{
return
;
}
BuildHandlerChain
(
element
&
mHandler
)
;
}
bool
XULKeySetGlobalKeyListener
:
:
IsDisabled
(
)
const
{
bool
isDisabled
;
dom
:
:
Element
*
element
=
GetElement
(
&
isDisabled
)
;
return
element
&
&
isDisabled
;
}
bool
XULKeySetGlobalKeyListener
:
:
GetElementForHandler
(
KeyEventHandler
*
aHandler
dom
:
:
Element
*
*
aElementForHandler
)
const
{
MOZ_ASSERT
(
aElementForHandler
)
;
*
aElementForHandler
=
nullptr
;
RefPtr
<
dom
:
:
Element
>
keyElement
=
aHandler
-
>
GetHandlerElement
(
)
;
if
(
!
keyElement
)
{
return
true
;
}
nsCOMPtr
<
dom
:
:
Element
>
chromeHandlerElement
=
GetElement
(
)
;
if
(
!
chromeHandlerElement
)
{
NS_WARNING_ASSERTION
(
keyElement
-
>
IsInUncomposedDoc
(
)
"
uncomposed
"
)
;
keyElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
nsAutoString
command
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
command
)
;
if
(
command
.
IsEmpty
(
)
)
{
NS_WARNING_ASSERTION
(
keyElement
-
>
IsInUncomposedDoc
(
)
"
uncomposed
"
)
;
keyElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
dom
:
:
Document
*
doc
=
keyElement
-
>
GetUncomposedDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
false
;
}
nsCOMPtr
<
dom
:
:
Element
>
commandElement
=
doc
-
>
GetElementById
(
command
)
;
if
(
!
commandElement
)
{
NS_ERROR
(
"
A
XUL
<
key
>
is
observing
a
command
that
doesn
'
t
exist
.
"
"
Unable
to
execute
key
binding
!
"
)
;
return
false
;
}
commandElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
bool
XULKeySetGlobalKeyListener
:
:
IsExecutableElement
(
dom
:
:
Element
*
aElement
)
const
{
if
(
!
aElement
)
{
return
false
;
}
nsAutoString
value
;
aElement
-
>
GetAttr
(
nsGkAtoms
:
:
disabled
value
)
;
if
(
value
.
EqualsLiteral
(
"
true
"
)
)
{
return
false
;
}
return
!
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
internal
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
already_AddRefed
<
dom
:
:
EventTarget
>
XULKeySetGlobalKeyListener
:
:
GetHandlerTarget
(
KeyEventHandler
*
aHandler
)
{
nsCOMPtr
<
dom
:
:
Element
>
commandElement
;
if
(
!
GetElementForHandler
(
aHandler
getter_AddRefs
(
commandElement
)
)
)
{
return
nullptr
;
}
return
commandElement
.
forget
(
)
;
}
bool
XULKeySetGlobalKeyListener
:
:
CanHandle
(
KeyEventHandler
*
aHandler
bool
aWillExecute
)
const
{
if
(
aHandler
-
>
KeyElementIsDisabled
(
)
)
{
return
false
;
}
nsCOMPtr
<
dom
:
:
Element
>
commandElement
;
if
(
!
GetElementForHandler
(
aHandler
getter_AddRefs
(
commandElement
)
)
)
{
return
false
;
}
if
(
!
commandElement
)
{
return
true
;
}
return
!
aWillExecute
|
|
IsExecutableElement
(
commandElement
)
;
}
layers
:
:
KeyboardMap
RootWindowGlobalKeyListener
:
:
CollectKeyboardShortcuts
(
)
{
KeyEventHandler
*
handlers
=
ShortcutKeys
:
:
GetHandlers
(
HandlerType
:
:
eBrowser
)
;
AutoTArray
<
KeyboardShortcut
48
>
shortcuts
;
KeyboardShortcut
:
:
AppendHardcodedShortcuts
(
shortcuts
)
;
for
(
KeyEventHandler
*
handler
=
handlers
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
KeyboardShortcut
shortcut
;
if
(
handler
-
>
TryConvertToKeyboardShortcut
(
&
shortcut
)
)
{
shortcuts
.
AppendElement
(
shortcut
)
;
}
}
return
layers
:
:
KeyboardMap
(
std
:
:
move
(
shortcuts
)
)
;
}
void
RootWindowGlobalKeyListener
:
:
AttachKeyHandler
(
dom
:
:
EventTarget
*
aTarget
)
{
EventListenerManager
*
manager
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
manager
)
{
return
;
}
RefPtr
<
RootWindowGlobalKeyListener
>
handler
=
new
RootWindowGlobalKeyListener
(
aTarget
)
;
handler
-
>
InstallKeyboardEventListenersTo
(
manager
)
;
}
RootWindowGlobalKeyListener
:
:
RootWindowGlobalKeyListener
(
dom
:
:
EventTarget
*
aTarget
)
:
GlobalKeyListener
(
aTarget
)
{
}
bool
RootWindowGlobalKeyListener
:
:
IsHTMLEditorFocused
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
return
false
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
auto
*
piwin
=
nsPIDOMWindowOuter
:
:
From
(
focusedWindow
)
;
nsIDocShell
*
docShell
=
piwin
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
HTMLEditor
*
htmlEditor
=
docShell
-
>
GetHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
if
(
htmlEditor
-
>
IsInDesignMode
(
)
)
{
return
true
;
}
nsINode
*
focusedNode
=
fm
-
>
GetFocusedElement
(
)
;
if
(
focusedNode
&
&
focusedNode
-
>
IsElement
(
)
)
{
dom
:
:
Element
*
editingHost
=
htmlEditor
-
>
ComputeEditingHost
(
)
;
if
(
!
editingHost
)
{
return
false
;
}
return
focusedNode
-
>
IsInclusiveDescendantOf
(
editingHost
)
;
}
return
false
;
}
void
RootWindowGlobalKeyListener
:
:
EnsureHandlers
(
)
{
if
(
IsHTMLEditorFocused
(
)
)
{
mHandler
=
ShortcutKeys
:
:
GetHandlers
(
HandlerType
:
:
eEditor
)
;
}
else
{
mHandler
=
ShortcutKeys
:
:
GetHandlers
(
HandlerType
:
:
eBrowser
)
;
}
}
}
