#
include
"
mozilla
/
Logging
.
h
"
#
include
"
ContentEventHandler
.
h
"
#
include
"
IMEContentObserver
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMRange
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionPrivate
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
WritingModes
.
h
"
namespace
mozilla
{
using
namespace
widget
;
LazyLogModule
sIMECOLog
(
"
IMEContentObserver
"
)
;
static
const
char
*
ToChar
(
bool
aBool
)
{
return
aBool
?
"
true
"
:
"
false
"
;
}
class
WritingModeToString
final
:
public
nsAutoCString
{
public
:
explicit
WritingModeToString
(
const
WritingMode
&
aWritingMode
)
{
if
(
!
aWritingMode
.
IsVertical
(
)
)
{
AssignLiteral
(
"
Horizontal
"
)
;
return
;
}
if
(
aWritingMode
.
IsVerticalLR
(
)
)
{
AssignLiteral
(
"
Vertical
(
LR
)
"
)
;
return
;
}
AssignLiteral
(
"
Vertical
(
RL
)
"
)
;
}
virtual
~
WritingModeToString
(
)
{
}
}
;
class
SelectionChangeDataToString
final
:
public
nsAutoCString
{
public
:
explicit
SelectionChangeDataToString
(
const
IMENotification
:
:
SelectionChangeDataBase
&
aData
)
{
if
(
!
aData
.
IsValid
(
)
)
{
AppendLiteral
(
"
{
IsValid
(
)
=
false
}
"
)
;
return
;
}
AppendPrintf
(
"
{
mOffset
=
%
u
"
aData
.
mOffset
)
;
if
(
aData
.
mString
-
>
Length
(
)
>
20
)
{
AppendPrintf
(
"
mString
.
Length
(
)
=
%
u
"
aData
.
mString
-
>
Length
(
)
)
;
}
else
{
AppendPrintf
(
"
mString
=
\
"
%
s
\
"
(
Length
(
)
=
%
u
)
"
NS_ConvertUTF16toUTF8
(
*
aData
.
mString
)
.
get
(
)
aData
.
mString
-
>
Length
(
)
)
;
}
AppendPrintf
(
"
GetWritingMode
(
)
=
%
s
mReversed
=
%
s
mCausedByComposition
=
%
s
"
"
mCausedBySelectionEvent
=
%
s
}
"
WritingModeToString
(
aData
.
GetWritingMode
(
)
)
.
get
(
)
ToChar
(
aData
.
mReversed
)
ToChar
(
aData
.
mCausedByComposition
)
ToChar
(
aData
.
mCausedBySelectionEvent
)
)
;
}
virtual
~
SelectionChangeDataToString
(
)
{
}
}
;
class
TextChangeDataToString
final
:
public
nsAutoCString
{
public
:
explicit
TextChangeDataToString
(
const
IMENotification
:
:
TextChangeDataBase
&
aData
)
{
if
(
!
aData
.
IsValid
(
)
)
{
AppendLiteral
(
"
{
IsValid
(
)
=
false
}
"
)
;
return
;
}
AppendPrintf
(
"
{
mStartOffset
=
%
u
mRemovedEndOffset
=
%
u
mAddedEndOffset
=
%
u
"
"
mCausedOnlyByComposition
=
%
s
"
"
mIncludingChangesDuringComposition
=
%
s
"
"
mIncludingChangesWithoutComposition
=
%
s
}
"
aData
.
mStartOffset
aData
.
mRemovedEndOffset
aData
.
mAddedEndOffset
ToChar
(
aData
.
mCausedOnlyByComposition
)
ToChar
(
aData
.
mIncludingChangesDuringComposition
)
ToChar
(
aData
.
mIncludingChangesWithoutComposition
)
)
;
}
virtual
~
TextChangeDataToString
(
)
{
}
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
IMEContentObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
IMEContentObserver
)
nsAutoScriptBlocker
scriptBlocker
;
tmp
-
>
NotifyIMEOfBlur
(
)
;
tmp
-
>
UnregisterObservers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRootContent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEditableNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocShell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEditorBase
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEndOfAddedTextCache
.
mContainerNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStartOfRemovingTextRangeCache
.
mContainerNode
)
tmp
-
>
mIMENotificationRequests
=
nullptr
;
tmp
-
>
mESM
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
IMEContentObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWidget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFocusedWidget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRootContent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEditableNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocShell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEditorBase
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEndOfAddedTextCache
.
mContainerNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStartOfRemovingTextRangeCache
.
mContainerNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IMEContentObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISelectionListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIReflowObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIScrollObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIEditorObserver
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsISelectionListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IMEContentObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IMEContentObserver
)
IMEContentObserver
:
:
IMEContentObserver
(
)
:
mFirstAddedNodeOffset
(
0
)
mLastAddedNodeOffset
(
0
)
mESM
(
nullptr
)
mIMENotificationRequests
(
nullptr
)
mSuppressNotifications
(
0
)
mPreCharacterDataChangeLength
(
-
1
)
mSendingNotification
(
NOTIFY_IME_OF_NOTHING
)
mIsObserving
(
false
)
mIMEHasFocus
(
false
)
mNeedsToNotifyIMEOfFocusSet
(
false
)
mNeedsToNotifyIMEOfTextChange
(
false
)
mNeedsToNotifyIMEOfSelectionChange
(
false
)
mNeedsToNotifyIMEOfPositionChange
(
false
)
mNeedsToNotifyIMEOfCompositionEventHandled
(
false
)
mIsHandlingQueryContentEvent
(
false
)
{
#
ifdef
DEBUG
mTextChangeData
.
Test
(
)
;
#
endif
}
void
IMEContentObserver
:
:
Init
(
nsIWidget
*
aWidget
nsPresContext
*
aPresContext
nsIContent
*
aContent
EditorBase
*
aEditorBase
)
{
State
state
=
GetState
(
)
;
if
(
NS_WARN_IF
(
state
=
=
eState_Observing
)
)
{
return
;
}
bool
firstInitialization
=
state
!
=
eState_StoppedObserving
;
if
(
!
firstInitialization
)
{
UnregisterObservers
(
)
;
Clear
(
)
;
}
mESM
=
aPresContext
-
>
EventStateManager
(
)
;
mESM
-
>
OnStartToObserveContent
(
this
)
;
mWidget
=
aWidget
;
mIMENotificationRequests
=
&
mWidget
-
>
IMENotificationRequestsRef
(
)
;
if
(
aWidget
-
>
GetInputContext
(
)
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
{
if
(
!
InitWithPlugin
(
aPresContext
aContent
)
)
{
Clear
(
)
;
return
;
}
}
else
{
if
(
!
InitWithEditor
(
aPresContext
aContent
aEditorBase
)
)
{
Clear
(
)
;
return
;
}
}
if
(
firstInitialization
)
{
MaybeNotifyIMEOfFocusSet
(
)
;
return
;
}
ObserveEditableNode
(
)
;
if
(
!
NeedsToNotifyIMEOfSomething
(
)
)
{
return
;
}
FlushMergeableNotifications
(
)
;
}
void
IMEContentObserver
:
:
OnIMEReceivedFocus
(
)
{
if
(
GetState
(
)
!
=
eState_Initializing
)
{
return
;
}
if
(
!
mRootContent
)
{
return
;
}
ObserveEditableNode
(
)
;
if
(
!
NeedsToNotifyIMEOfSomething
(
)
)
{
return
;
}
FlushMergeableNotifications
(
)
;
}
bool
IMEContentObserver
:
:
InitWithEditor
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
EditorBase
*
aEditorBase
)
{
MOZ_ASSERT
(
aEditorBase
)
;
mEditableNode
=
IMEStateManager
:
:
GetRootEditableNode
(
aPresContext
aContent
)
;
if
(
NS_WARN_IF
(
!
mEditableNode
)
)
{
return
false
;
}
mEditorBase
=
aEditorBase
;
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
false
;
}
nsIPresShell
*
presShell
=
aPresContext
-
>
PresShell
(
)
;
nsCOMPtr
<
nsISelectionController
>
selCon
;
if
(
mEditableNode
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
{
nsIFrame
*
frame
=
static_cast
<
nsIContent
*
>
(
mEditableNode
.
get
(
)
)
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
false
;
}
frame
-
>
GetSelectionController
(
aPresContext
getter_AddRefs
(
selCon
)
)
;
}
else
{
selCon
=
do_QueryInterface
(
presShell
)
;
}
if
(
NS_WARN_IF
(
!
selCon
)
)
{
return
false
;
}
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
getter_AddRefs
(
mSelection
)
)
;
if
(
NS_WARN_IF
(
!
mSelection
)
)
{
return
false
;
}
auto
selection
=
static_cast
<
mozilla
:
:
dom
:
:
Selection
*
>
(
mSelection
.
get
(
)
)
;
if
(
nsRange
*
selRange
=
selection
-
>
GetRangeAt
(
0
)
)
{
if
(
NS_WARN_IF
(
!
selRange
-
>
GetStartContainer
(
)
)
)
{
return
false
;
}
mRootContent
=
selRange
-
>
GetStartContainer
(
)
-
>
GetSelectionRootContent
(
presShell
)
;
}
else
{
mRootContent
=
mEditableNode
-
>
GetSelectionRootContent
(
presShell
)
;
}
if
(
!
mRootContent
&
&
mEditableNode
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
mRootContent
)
)
{
return
false
;
}
mDocShell
=
aPresContext
-
>
GetDocShell
(
)
;
if
(
NS_WARN_IF
(
!
mDocShell
)
)
{
return
false
;
}
mDocumentObserver
=
new
DocumentObserver
(
*
this
)
;
MOZ_ASSERT
(
!
WasInitializedWithPlugin
(
)
)
;
return
true
;
}
bool
IMEContentObserver
:
:
InitWithPlugin
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
{
if
(
NS_WARN_IF
(
!
aContent
)
|
|
NS_WARN_IF
(
aContent
-
>
GetDesiredIMEState
(
)
.
mEnabled
!
=
IMEState
:
:
PLUGIN
)
)
{
return
false
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
frame
)
)
{
return
false
;
}
nsCOMPtr
<
nsISelectionController
>
selCon
;
frame
-
>
GetSelectionController
(
aPresContext
getter_AddRefs
(
selCon
)
)
;
if
(
NS_WARN_IF
(
!
selCon
)
)
{
return
false
;
}
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
getter_AddRefs
(
mSelection
)
)
;
if
(
NS_WARN_IF
(
!
mSelection
)
)
{
return
false
;
}
mEditorBase
=
nullptr
;
mEditableNode
=
aContent
;
mRootContent
=
aContent
;
mDocumentObserver
=
nullptr
;
mDocShell
=
aPresContext
-
>
GetDocShell
(
)
;
if
(
NS_WARN_IF
(
!
mDocShell
)
)
{
return
false
;
}
MOZ_ASSERT
(
WasInitializedWithPlugin
(
)
)
;
return
true
;
}
bool
IMEContentObserver
:
:
WasInitializedWithPlugin
(
)
const
{
return
mDocShell
&
&
!
mEditorBase
;
}
void
IMEContentObserver
:
:
Clear
(
)
{
mEditorBase
=
nullptr
;
mSelection
=
nullptr
;
mEditableNode
=
nullptr
;
mRootContent
=
nullptr
;
mDocShell
=
nullptr
;
mDocumentObserver
=
nullptr
;
}
void
IMEContentObserver
:
:
ObserveEditableNode
(
)
{
MOZ_RELEASE_ASSERT
(
mSelection
)
;
MOZ_RELEASE_ASSERT
(
mRootContent
)
;
MOZ_RELEASE_ASSERT
(
GetState
(
)
!
=
eState_Observing
)
;
if
(
!
mIMEHasFocus
)
{
MOZ_ASSERT
(
!
mWidget
|
|
mNeedsToNotifyIMEOfFocusSet
|
|
mSendingNotification
=
=
NOTIFY_IME_OF_FOCUS
"
Wow
OnIMEReceivedFocus
(
)
won
'
t
be
called
?
"
)
;
return
;
}
mIsObserving
=
true
;
if
(
mEditorBase
)
{
mEditorBase
-
>
AddEditorObserver
(
this
)
;
}
if
(
!
WasInitializedWithPlugin
(
)
)
{
nsCOMPtr
<
nsISelectionPrivate
>
selPrivate
(
do_QueryInterface
(
mSelection
)
)
;
NS_ENSURE_TRUE_VOID
(
selPrivate
)
;
nsresult
rv
=
selPrivate
-
>
AddSelectionListener
(
this
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mRootContent
-
>
AddMutationObserver
(
this
)
;
nsIDocument
*
doc
=
mRootContent
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
RefPtr
<
DocumentObserver
>
documentObserver
=
mDocumentObserver
;
documentObserver
-
>
Observe
(
doc
)
;
}
}
if
(
mDocShell
)
{
mDocShell
-
>
AddWeakScrollObserver
(
this
)
;
mDocShell
-
>
AddWeakReflowObserver
(
this
)
;
}
}
void
IMEContentObserver
:
:
NotifyIMEOfBlur
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
mWidget
.
swap
(
widget
)
;
mIMENotificationRequests
=
nullptr
;
if
(
!
mIMEHasFocus
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
widget
)
;
RefPtr
<
IMEContentObserver
>
kungFuDeathGrip
(
this
)
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Info
(
"
0x
%
p
IMEContentObserver
:
:
NotifyIMEOfBlur
(
)
"
"
sending
NOTIFY_IME_OF_BLUR
"
this
)
)
;
mIMEHasFocus
=
false
;
IMEStateManager
:
:
NotifyIME
(
IMENotification
(
NOTIFY_IME_OF_BLUR
)
widget
)
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
NotifyIMEOfBlur
(
)
"
"
sent
NOTIFY_IME_OF_BLUR
"
this
)
)
;
}
void
IMEContentObserver
:
:
UnregisterObservers
(
)
{
if
(
!
mIsObserving
)
{
return
;
}
mIsObserving
=
false
;
if
(
mEditorBase
)
{
mEditorBase
-
>
RemoveEditorObserver
(
this
)
;
}
if
(
mSelection
)
{
nsCOMPtr
<
nsISelectionPrivate
>
selPrivate
(
do_QueryInterface
(
mSelection
)
)
;
if
(
selPrivate
)
{
selPrivate
-
>
RemoveSelectionListener
(
this
)
;
}
mSelectionData
.
Clear
(
)
;
mFocusedWidget
=
nullptr
;
}
if
(
mRootContent
)
{
mRootContent
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
mDocumentObserver
)
{
RefPtr
<
DocumentObserver
>
documentObserver
=
mDocumentObserver
;
documentObserver
-
>
StopObserving
(
)
;
}
if
(
mDocShell
)
{
mDocShell
-
>
RemoveWeakScrollObserver
(
this
)
;
mDocShell
-
>
RemoveWeakReflowObserver
(
this
)
;
}
}
nsPresContext
*
IMEContentObserver
:
:
GetPresContext
(
)
const
{
return
mESM
?
mESM
-
>
GetPresContext
(
)
:
nullptr
;
}
void
IMEContentObserver
:
:
Destroy
(
)
{
NotifyIMEOfBlur
(
)
;
UnregisterObservers
(
)
;
Clear
(
)
;
mWidget
=
nullptr
;
mIMENotificationRequests
=
nullptr
;
if
(
mESM
)
{
mESM
-
>
OnStopObservingContent
(
this
)
;
mESM
=
nullptr
;
}
}
bool
IMEContentObserver
:
:
Destroyed
(
)
const
{
return
!
mWidget
;
}
void
IMEContentObserver
:
:
DisconnectFromEventStateManager
(
)
{
mESM
=
nullptr
;
}
bool
IMEContentObserver
:
:
MaybeReinitialize
(
nsIWidget
*
aWidget
nsPresContext
*
aPresContext
nsIContent
*
aContent
EditorBase
*
aEditorBase
)
{
if
(
!
IsObservingContent
(
aPresContext
aContent
)
)
{
return
false
;
}
if
(
GetState
(
)
=
=
eState_StoppedObserving
)
{
Init
(
aWidget
aPresContext
aContent
aEditorBase
)
;
}
return
IsManaging
(
aPresContext
aContent
)
;
}
bool
IMEContentObserver
:
:
IsManaging
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
const
{
return
GetState
(
)
=
=
eState_Observing
&
&
IsObservingContent
(
aPresContext
aContent
)
;
}
bool
IMEContentObserver
:
:
IsManaging
(
const
TextComposition
*
aComposition
)
const
{
if
(
GetState
(
)
!
=
eState_Observing
)
{
return
false
;
}
nsPresContext
*
presContext
=
aComposition
-
>
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
false
;
}
if
(
presContext
!
=
GetPresContext
(
)
)
{
return
false
;
}
nsINode
*
targetNode
=
aComposition
-
>
GetEventTargetNode
(
)
;
nsIContent
*
targetContent
=
targetNode
&
&
targetNode
-
>
IsContent
(
)
?
targetNode
-
>
AsContent
(
)
:
nullptr
;
return
IsObservingContent
(
presContext
targetContent
)
;
}
IMEContentObserver
:
:
State
IMEContentObserver
:
:
GetState
(
)
const
{
if
(
!
mSelection
|
|
!
mRootContent
|
|
!
mEditableNode
)
{
return
eState_NotObserving
;
}
if
(
!
mRootContent
-
>
IsInComposedDoc
(
)
)
{
return
eState_StoppedObserving
;
}
return
mIsObserving
?
eState_Observing
:
eState_Initializing
;
}
bool
IMEContentObserver
:
:
IsObservingContent
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
const
{
return
IsInitializedWithPlugin
(
)
?
mRootContent
=
=
aContent
&
&
mRootContent
!
=
nullptr
:
mEditableNode
=
=
IMEStateManager
:
:
GetRootEditableNode
(
aPresContext
aContent
)
;
}
bool
IMEContentObserver
:
:
IsEditorHandlingEventForComposition
(
)
const
{
if
(
!
mWidget
)
{
return
false
;
}
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
mWidget
)
;
if
(
!
composition
)
{
return
false
;
}
return
composition
-
>
IsEditorHandlingEvent
(
)
;
}
bool
IMEContentObserver
:
:
IsEditorComposing
(
)
const
{
if
(
NS_WARN_IF
(
!
mEditorBase
)
)
{
return
false
;
}
return
mEditorBase
-
>
IsIMEComposing
(
)
;
}
nsresult
IMEContentObserver
:
:
GetSelectionAndRoot
(
nsISelection
*
*
aSelection
nsIContent
*
*
aRootContent
)
const
{
if
(
!
mEditableNode
|
|
!
mSelection
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_ASSERTION
(
mSelection
&
&
mRootContent
"
uninitialized
content
observer
"
)
;
NS_ADDREF
(
*
aSelection
=
mSelection
)
;
NS_ADDREF
(
*
aRootContent
=
mRootContent
)
;
return
NS_OK
;
}
nsresult
IMEContentObserver
:
:
NotifySelectionChanged
(
nsIDOMDocument
*
aDOMDocument
nsISelection
*
aSelection
int16_t
aReason
)
{
int32_t
count
=
0
;
nsresult
rv
=
aSelection
-
>
GetRangeCount
(
&
count
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
count
>
0
&
&
mWidget
)
{
bool
causedByComposition
=
IsEditorHandlingEventForComposition
(
)
;
bool
causedBySelectionEvent
=
TextComposition
:
:
IsHandlingSelectionEvent
(
)
;
bool
duringComposition
=
IsEditorComposing
(
)
;
MaybeNotifyIMEOfSelectionChange
(
causedByComposition
causedBySelectionEvent
duringComposition
)
;
}
return
NS_OK
;
}
void
IMEContentObserver
:
:
ScrollPositionChanged
(
)
{
if
(
!
NeedsPositionChangeNotification
(
)
)
{
return
;
}
MaybeNotifyIMEOfPositionChange
(
)
;
}
NS_IMETHODIMP
IMEContentObserver
:
:
Reflow
(
DOMHighResTimeStamp
aStart
DOMHighResTimeStamp
aEnd
)
{
if
(
!
NeedsPositionChangeNotification
(
)
)
{
return
NS_OK
;
}
MaybeNotifyIMEOfPositionChange
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
IMEContentObserver
:
:
ReflowInterruptible
(
DOMHighResTimeStamp
aStart
DOMHighResTimeStamp
aEnd
)
{
if
(
!
NeedsPositionChangeNotification
(
)
)
{
return
NS_OK
;
}
MaybeNotifyIMEOfPositionChange
(
)
;
return
NS_OK
;
}
nsresult
IMEContentObserver
:
:
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
{
bool
isSelectionCacheAvailable
=
aEvent
-
>
mUseNativeLineBreak
&
&
mSelectionData
.
IsValid
(
)
&
&
!
mNeedsToNotifyIMEOfSelectionChange
;
if
(
isSelectionCacheAvailable
&
&
aEvent
-
>
mMessage
=
=
eQuerySelectedText
&
&
aEvent
-
>
mInput
.
mSelectionType
=
=
SelectionType
:
:
eNormal
)
{
aEvent
-
>
mReply
.
mContentsRoot
=
mRootContent
;
aEvent
-
>
mReply
.
mHasSelection
=
!
mSelectionData
.
IsCollapsed
(
)
;
aEvent
-
>
mReply
.
mOffset
=
mSelectionData
.
mOffset
;
aEvent
-
>
mReply
.
mString
=
mSelectionData
.
String
(
)
;
aEvent
-
>
mReply
.
mWritingMode
=
mSelectionData
.
GetWritingMode
(
)
;
aEvent
-
>
mReply
.
mReversed
=
mSelectionData
.
mReversed
;
aEvent
-
>
mSucceeded
=
true
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
HandleQueryContentEvent
(
aEvent
=
{
"
"
mMessage
=
%
s
}
)
"
this
ToChar
(
aEvent
-
>
mMessage
)
)
)
;
return
NS_OK
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
HandleQueryContentEvent
(
aEvent
=
{
"
"
mMessage
=
%
s
}
)
"
this
ToChar
(
aEvent
-
>
mMessage
)
)
)
;
if
(
aEvent
-
>
mInput
.
mRelativeToInsertionPoint
&
&
aEvent
-
>
mInput
.
IsValidEventMessage
(
aEvent
-
>
mMessage
)
)
{
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
aEvent
-
>
mWidget
)
;
if
(
composition
)
{
uint32_t
compositionStart
=
composition
-
>
NativeOffsetOfStartComposition
(
)
;
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
MakeOffsetAbsolute
(
compositionStart
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
isSelectionCacheAvailable
)
{
uint32_t
selectionStart
=
mSelectionData
.
mOffset
;
if
(
NS_WARN_IF
(
!
aEvent
-
>
mInput
.
MakeOffsetAbsolute
(
selectionStart
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
AutoRestore
<
bool
>
handling
(
mIsHandlingQueryContentEvent
)
;
mIsHandlingQueryContentEvent
=
true
;
ContentEventHandler
handler
(
GetPresContext
(
)
)
;
nsresult
rv
=
handler
.
HandleQueryContentEvent
(
aEvent
)
;
if
(
NS_WARN_IF
(
Destroyed
(
)
)
)
{
aEvent
-
>
mSucceeded
=
false
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Warning
(
"
0x
%
p
IMEContentObserver
:
:
HandleQueryContentEvent
(
)
WARNING
"
"
IMEContentObserver
has
been
destroyed
during
the
query
"
"
making
the
query
fail
"
this
)
)
;
return
rv
;
}
if
(
!
IsInitializedWithPlugin
(
)
&
&
NS_WARN_IF
(
aEvent
-
>
mReply
.
mContentsRoot
!
=
mRootContent
)
)
{
aEvent
-
>
mSucceeded
=
false
;
}
return
rv
;
}
bool
IMEContentObserver
:
:
OnMouseButtonEvent
(
nsPresContext
*
aPresContext
WidgetMouseEvent
*
aMouseEvent
)
{
if
(
!
mIMENotificationRequests
|
|
!
mIMENotificationRequests
-
>
WantMouseButtonEventOnChar
(
)
)
{
return
false
;
}
if
(
!
aMouseEvent
-
>
IsTrusted
(
)
|
|
aMouseEvent
-
>
DefaultPrevented
(
)
|
|
!
aMouseEvent
-
>
mWidget
)
{
return
false
;
}
switch
(
aMouseEvent
-
>
mMessage
)
{
case
eMouseUp
:
case
eMouseDown
:
break
;
default
:
return
false
;
}
if
(
NS_WARN_IF
(
!
mWidget
)
|
|
NS_WARN_IF
(
mWidget
-
>
Destroyed
(
)
)
)
{
return
false
;
}
RefPtr
<
IMEContentObserver
>
kungFuDeathGrip
(
this
)
;
WidgetQueryContentEvent
charAtPt
(
true
eQueryCharacterAtPoint
aMouseEvent
-
>
mWidget
)
;
charAtPt
.
mRefPoint
=
aMouseEvent
-
>
mRefPoint
;
ContentEventHandler
handler
(
aPresContext
)
;
handler
.
OnQueryCharacterAtPoint
(
&
charAtPt
)
;
if
(
NS_WARN_IF
(
!
charAtPt
.
mSucceeded
)
|
|
charAtPt
.
mReply
.
mOffset
=
=
WidgetQueryContentEvent
:
:
NOT_FOUND
)
{
return
false
;
}
if
(
!
mWidget
|
|
NS_WARN_IF
(
mWidget
-
>
Destroyed
(
)
)
)
{
return
false
;
}
nsIWidget
*
topLevelWidget
=
mWidget
-
>
GetTopLevelWidget
(
)
;
if
(
topLevelWidget
&
&
topLevelWidget
!
=
mWidget
)
{
charAtPt
.
mReply
.
mRect
.
MoveBy
(
topLevelWidget
-
>
WidgetToScreenOffset
(
)
-
mWidget
-
>
WidgetToScreenOffset
(
)
)
;
}
if
(
aMouseEvent
-
>
mWidget
!
=
mWidget
)
{
charAtPt
.
mRefPoint
+
=
aMouseEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
-
mWidget
-
>
WidgetToScreenOffset
(
)
;
}
IMENotification
notification
(
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
)
;
notification
.
mMouseButtonEventData
.
mEventMessage
=
aMouseEvent
-
>
mMessage
;
notification
.
mMouseButtonEventData
.
mOffset
=
charAtPt
.
mReply
.
mOffset
;
notification
.
mMouseButtonEventData
.
mCursorPos
.
Set
(
charAtPt
.
mRefPoint
.
ToUnknownPoint
(
)
)
;
notification
.
mMouseButtonEventData
.
mCharRect
.
Set
(
charAtPt
.
mReply
.
mRect
.
ToUnknownRect
(
)
)
;
notification
.
mMouseButtonEventData
.
mButton
=
aMouseEvent
-
>
button
;
notification
.
mMouseButtonEventData
.
mButtons
=
aMouseEvent
-
>
buttons
;
notification
.
mMouseButtonEventData
.
mModifiers
=
aMouseEvent
-
>
mModifiers
;
nsresult
rv
=
IMEStateManager
:
:
NotifyIME
(
notification
mWidget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
bool
consumed
=
(
rv
=
=
NS_SUCCESS_EVENT_CONSUMED
)
;
if
(
consumed
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
}
return
consumed
;
}
void
IMEContentObserver
:
:
CharacterDataWillChange
(
nsIDocument
*
aDocument
nsIContent
*
aContent
CharacterDataChangeInfo
*
aInfo
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
character
data
changed
for
non
-
text
node
"
)
;
MOZ_ASSERT
(
mPreCharacterDataChangeLength
<
0
"
CharacterDataChanged
(
)
should
'
ve
reset
"
"
mPreCharacterDataChangeLength
"
)
;
if
(
!
NeedsTextChangeNotification
(
)
)
{
return
;
}
mEndOfAddedTextCache
.
Clear
(
)
;
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
mPreCharacterDataChangeLength
=
ContentEventHandler
:
:
GetNativeTextLength
(
aContent
aInfo
-
>
mChangeStart
aInfo
-
>
mChangeEnd
)
;
MOZ_ASSERT
(
mPreCharacterDataChangeLength
>
=
aInfo
-
>
mChangeEnd
-
aInfo
-
>
mChangeStart
"
The
computed
length
must
be
same
as
or
larger
than
XP
length
"
)
;
}
void
IMEContentObserver
:
:
CharacterDataChanged
(
nsIDocument
*
aDocument
nsIContent
*
aContent
CharacterDataChangeInfo
*
aInfo
)
{
NS_ASSERTION
(
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
"
character
data
changed
for
non
-
text
node
"
)
;
if
(
!
NeedsTextChangeNotification
(
)
)
{
return
;
}
mEndOfAddedTextCache
.
Clear
(
)
;
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
MOZ_ASSERT
(
!
HasAddedNodesDuringDocumentChange
(
)
"
The
stored
range
should
be
flushed
before
actually
the
data
is
changed
"
)
;
int64_t
removedLength
=
mPreCharacterDataChangeLength
;
mPreCharacterDataChangeLength
=
-
1
;
MOZ_ASSERT
(
removedLength
>
=
0
"
mPreCharacterDataChangeLength
should
'
ve
been
set
by
"
"
CharacterDataWillChange
(
)
"
)
;
uint32_t
offset
=
0
;
nsresult
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
aContent
aInfo
-
>
mChangeStart
)
mRootContent
&
offset
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
uint32_t
newLength
=
ContentEventHandler
:
:
GetNativeTextLength
(
aContent
aInfo
-
>
mChangeStart
aInfo
-
>
mChangeStart
+
aInfo
-
>
mReplaceLength
)
;
uint32_t
oldEnd
=
offset
+
static_cast
<
uint32_t
>
(
removedLength
)
;
uint32_t
newEnd
=
offset
+
newLength
;
TextChangeData
data
(
offset
oldEnd
newEnd
IsEditorHandlingEventForComposition
(
)
IsEditorComposing
(
)
)
;
MaybeNotifyIMEOfTextChange
(
data
)
;
}
void
IMEContentObserver
:
:
NotifyContentAdded
(
nsINode
*
aContainer
int32_t
aStartIndex
int32_t
aEndIndex
)
{
if
(
!
NeedsTextChangeNotification
(
)
)
{
return
;
}
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
if
(
IsInDocumentChange
(
)
)
{
mEndOfAddedTextCache
.
Clear
(
)
;
if
(
!
HasAddedNodesDuringDocumentChange
(
)
)
{
mFirstAddedNodeContainer
=
mLastAddedNodeContainer
=
aContainer
;
mFirstAddedNodeOffset
=
aStartIndex
;
mLastAddedNodeOffset
=
aEndIndex
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
NotifyContentAdded
(
)
starts
to
store
"
"
consecutive
added
nodes
"
this
)
)
;
return
;
}
if
(
NS_WARN_IF
(
!
IsNextNodeOfLastAddedNode
(
aContainer
aStartIndex
)
)
)
{
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
mFirstAddedNodeContainer
=
aContainer
;
mFirstAddedNodeOffset
=
aStartIndex
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
NotifyContentAdded
(
)
starts
to
store
"
"
consecutive
added
nodes
"
this
)
)
;
}
mLastAddedNodeContainer
=
aContainer
;
mLastAddedNodeOffset
=
aEndIndex
;
return
;
}
MOZ_ASSERT
(
!
HasAddedNodesDuringDocumentChange
(
)
"
The
cache
should
be
cleared
when
document
change
finished
"
)
;
uint32_t
offset
=
0
;
nsresult
rv
=
NS_OK
;
if
(
!
mEndOfAddedTextCache
.
Match
(
aContainer
aStartIndex
)
)
{
mEndOfAddedTextCache
.
Clear
(
)
;
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePositionBefore
(
aContainer
aStartIndex
)
mRootContent
&
offset
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
(
rv
)
)
)
)
{
return
;
}
}
else
{
offset
=
mEndOfAddedTextCache
.
mFlatTextLength
;
}
uint32_t
addingLength
=
0
;
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePositionBefore
(
aContainer
aStartIndex
)
NodePosition
(
aContainer
aEndIndex
)
mRootContent
&
addingLength
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
(
rv
)
)
)
)
{
mEndOfAddedTextCache
.
Clear
(
)
;
return
;
}
mEndOfAddedTextCache
.
Cache
(
aContainer
aEndIndex
offset
+
addingLength
)
;
if
(
!
addingLength
)
{
return
;
}
TextChangeData
data
(
offset
offset
offset
+
addingLength
IsEditorHandlingEventForComposition
(
)
IsEditorComposing
(
)
)
;
MaybeNotifyIMEOfTextChange
(
data
)
;
}
void
IMEContentObserver
:
:
ContentAppended
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
int32_t
aNewIndexInContainer
)
{
NotifyContentAdded
(
aContainer
aNewIndexInContainer
aContainer
-
>
GetChildCount
(
)
)
;
}
void
IMEContentObserver
:
:
ContentInserted
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexInContainer
)
{
NotifyContentAdded
(
NODE_FROM
(
aContainer
aDocument
)
aIndexInContainer
aIndexInContainer
+
1
)
;
}
void
IMEContentObserver
:
:
ContentRemoved
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexInContainer
nsIContent
*
aPreviousSibling
)
{
if
(
!
NeedsTextChangeNotification
(
)
)
{
return
;
}
mEndOfAddedTextCache
.
Clear
(
)
;
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
nsINode
*
containerNode
=
NODE_FROM
(
aContainer
aDocument
)
;
uint32_t
offset
=
0
;
nsresult
rv
=
NS_OK
;
if
(
!
mStartOfRemovingTextRangeCache
.
Match
(
containerNode
aIndexInContainer
)
)
{
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
containerNode
aIndexInContainer
)
mRootContent
&
offset
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
return
;
}
mStartOfRemovingTextRangeCache
.
Cache
(
containerNode
aIndexInContainer
offset
)
;
}
else
{
offset
=
mStartOfRemovingTextRangeCache
.
mFlatTextLength
;
}
uint32_t
textLength
=
0
;
if
(
aChild
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
textLength
=
ContentEventHandler
:
:
GetNativeTextLength
(
aChild
)
;
}
else
{
uint32_t
nodeLength
=
static_cast
<
int32_t
>
(
aChild
-
>
GetChildCount
(
)
)
;
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePositionBefore
(
aChild
0
)
NodePosition
(
aChild
nodeLength
)
mRootContent
&
textLength
LINE_BREAK_TYPE_NATIVE
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
return
;
}
}
if
(
!
textLength
)
{
return
;
}
TextChangeData
data
(
offset
offset
+
textLength
offset
IsEditorHandlingEventForComposition
(
)
IsEditorComposing
(
)
)
;
MaybeNotifyIMEOfTextChange
(
data
)
;
}
void
IMEContentObserver
:
:
AttributeWillChange
(
nsIDocument
*
aDocument
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
{
if
(
!
NeedsTextChangeNotification
(
)
)
{
return
;
}
mPreAttrChangeLength
=
ContentEventHandler
:
:
GetNativeTextLengthBefore
(
aElement
mRootContent
)
;
}
void
IMEContentObserver
:
:
AttributeChanged
(
nsIDocument
*
aDocument
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
!
NeedsTextChangeNotification
(
)
)
{
return
;
}
mEndOfAddedTextCache
.
Clear
(
)
;
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
uint32_t
postAttrChangeLength
=
ContentEventHandler
:
:
GetNativeTextLengthBefore
(
aElement
mRootContent
)
;
if
(
postAttrChangeLength
=
=
mPreAttrChangeLength
)
{
return
;
}
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
uint32_t
start
;
nsresult
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePositionBefore
(
aElement
0
)
mRootContent
&
start
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
TextChangeData
data
(
start
start
+
mPreAttrChangeLength
start
+
postAttrChangeLength
IsEditorHandlingEventForComposition
(
)
IsEditorComposing
(
)
)
;
MaybeNotifyIMEOfTextChange
(
data
)
;
}
void
IMEContentObserver
:
:
ClearAddedNodesDuringDocumentChange
(
)
{
mFirstAddedNodeContainer
=
mLastAddedNodeContainer
=
nullptr
;
mFirstAddedNodeOffset
=
mLastAddedNodeOffset
=
0
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
ClearAddedNodesDuringDocumentChange
(
)
"
"
finished
storing
consecutive
nodes
"
this
)
)
;
}
nsIContent
*
IMEContentObserver
:
:
GetChildNode
(
nsINode
*
aParent
int32_t
aOffset
)
{
if
(
!
aParent
-
>
HasChildren
(
)
|
|
aOffset
<
0
|
|
aOffset
>
=
static_cast
<
int32_t
>
(
aParent
-
>
Length
(
)
)
)
{
return
nullptr
;
}
if
(
!
aOffset
)
{
return
aParent
-
>
GetFirstChild
(
)
;
}
if
(
aOffset
=
=
static_cast
<
int32_t
>
(
aParent
-
>
Length
(
)
-
1
)
)
{
return
aParent
-
>
GetLastChild
(
)
;
}
return
aParent
-
>
GetChildAt
(
aOffset
)
;
}
bool
IMEContentObserver
:
:
IsNextNodeOfLastAddedNode
(
nsINode
*
aParent
int32_t
aOffset
)
const
{
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
aOffset
>
=
0
&
&
aOffset
<
=
static_cast
<
int32_t
>
(
aParent
-
>
Length
(
)
)
)
;
MOZ_ASSERT
(
mRootContent
)
;
MOZ_ASSERT
(
HasAddedNodesDuringDocumentChange
(
)
)
;
if
(
aParent
=
=
mLastAddedNodeContainer
)
{
if
(
NS_WARN_IF
(
mLastAddedNodeOffset
!
=
aOffset
)
)
{
return
false
;
}
return
true
;
}
if
(
NS_WARN_IF
(
mLastAddedNodeOffset
!
=
static_cast
<
int32_t
>
(
mLastAddedNodeContainer
-
>
Length
(
)
)
)
)
{
return
false
;
}
if
(
mLastAddedNodeContainer
=
=
aParent
-
>
GetParent
(
)
)
{
if
(
NS_WARN_IF
(
aOffset
)
)
{
return
false
;
}
return
true
;
}
nsIContent
*
lastAddedContent
=
GetChildNode
(
mLastAddedNodeContainer
mLastAddedNodeOffset
-
1
)
;
if
(
NS_WARN_IF
(
!
lastAddedContent
)
)
{
return
false
;
}
nsIContent
*
nextContentOfLastAddedContent
=
lastAddedContent
-
>
GetNextNode
(
mRootContent
-
>
GetParentNode
(
)
)
;
if
(
NS_WARN_IF
(
!
nextContentOfLastAddedContent
)
)
{
return
false
;
}
nsIContent
*
startContent
=
GetChildNode
(
aParent
aOffset
)
;
if
(
NS_WARN_IF
(
!
startContent
)
|
|
NS_WARN_IF
(
nextContentOfLastAddedContent
!
=
startContent
)
)
{
return
false
;
}
#
ifdef
DEBUG
NS_WARNING_ASSERTION
(
!
aOffset
|
|
aOffset
=
=
static_cast
<
int32_t
>
(
aParent
-
>
Length
(
)
-
1
)
"
Used
slow
path
for
aParent
"
)
;
NS_WARNING_ASSERTION
(
!
(
mLastAddedNodeOffset
-
1
)
|
|
mLastAddedNodeOffset
=
=
static_cast
<
int32_t
>
(
mLastAddedNodeContainer
-
>
Length
(
)
)
"
Used
slow
path
for
mLastAddedNodeContainer
"
)
;
#
endif
return
true
;
}
void
IMEContentObserver
:
:
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
{
if
(
!
HasAddedNodesDuringDocumentChange
(
)
)
{
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
"
"
flushing
stored
consecutive
nodes
"
this
)
)
;
uint32_t
offset
;
nsresult
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePosition
(
mRootContent
0
)
NodePosition
(
mFirstAddedNodeContainer
mFirstAddedNodeOffset
)
mRootContent
&
offset
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ClearAddedNodesDuringDocumentChange
(
)
;
return
;
}
uint32_t
length
;
rv
=
ContentEventHandler
:
:
GetFlatTextLengthInRange
(
NodePosition
(
mFirstAddedNodeContainer
mFirstAddedNodeOffset
)
NodePosition
(
mLastAddedNodeContainer
mLastAddedNodeOffset
)
mRootContent
&
length
LINE_BREAK_TYPE_NATIVE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ClearAddedNodesDuringDocumentChange
(
)
;
return
;
}
TextChangeData
data
(
offset
offset
offset
+
length
IsEditorHandlingEventForComposition
(
)
IsEditorComposing
(
)
)
;
MaybeNotifyIMEOfTextChange
(
data
)
;
ClearAddedNodesDuringDocumentChange
(
)
;
}
void
IMEContentObserver
:
:
BeginDocumentUpdate
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
BeginDocumentUpdate
(
)
"
"
HasAddedNodesDuringDocumentChange
(
)
=
%
s
"
this
ToChar
(
HasAddedNodesDuringDocumentChange
(
)
)
)
)
;
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
}
void
IMEContentObserver
:
:
EndDocumentUpdate
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
EndDocumentUpdate
(
)
"
"
HasAddedNodesDuringDocumentChange
(
)
=
%
s
"
this
ToChar
(
HasAddedNodesDuringDocumentChange
(
)
)
)
)
;
MaybeNotifyIMEOfAddedTextDuringDocumentChange
(
)
;
}
void
IMEContentObserver
:
:
SuppressNotifyingIME
(
)
{
mSuppressNotifications
+
+
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
SuppressNotifyingIME
(
)
"
"
mSuppressNotifications
=
%
u
"
this
mSuppressNotifications
)
)
;
}
void
IMEContentObserver
:
:
UnsuppressNotifyingIME
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
UnsuppressNotifyingIME
(
)
"
"
mSuppressNotifications
=
%
u
"
this
mSuppressNotifications
)
)
;
if
(
!
mSuppressNotifications
|
|
-
-
mSuppressNotifications
)
{
return
;
}
FlushMergeableNotifications
(
)
;
}
NS_IMETHODIMP
IMEContentObserver
:
:
EditAction
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
EditAction
(
)
"
this
)
)
;
mEndOfAddedTextCache
.
Clear
(
)
;
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
FlushMergeableNotifications
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
IMEContentObserver
:
:
BeforeEditAction
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
BeforeEditAction
(
)
"
this
)
)
;
mEndOfAddedTextCache
.
Clear
(
)
;
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
IMEContentObserver
:
:
CancelEditAction
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
CancelEditAction
(
)
"
this
)
)
;
mEndOfAddedTextCache
.
Clear
(
)
;
mStartOfRemovingTextRangeCache
.
Clear
(
)
;
FlushMergeableNotifications
(
)
;
return
NS_OK
;
}
void
IMEContentObserver
:
:
PostFocusSetNotification
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
PostFocusSetNotification
(
)
"
this
)
)
;
mNeedsToNotifyIMEOfFocusSet
=
true
;
}
void
IMEContentObserver
:
:
PostTextChangeNotification
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
PostTextChangeNotification
(
"
"
mTextChangeData
=
%
s
)
"
this
TextChangeDataToString
(
mTextChangeData
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
mTextChangeData
.
IsValid
(
)
"
mTextChangeData
must
have
text
change
data
"
)
;
mNeedsToNotifyIMEOfTextChange
=
true
;
}
void
IMEContentObserver
:
:
PostSelectionChangeNotification
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
PostSelectionChangeNotification
(
)
"
"
mSelectionData
=
{
mCausedByComposition
=
%
s
mCausedBySelectionEvent
=
%
s
}
"
this
ToChar
(
mSelectionData
.
mCausedByComposition
)
ToChar
(
mSelectionData
.
mCausedBySelectionEvent
)
)
)
;
mNeedsToNotifyIMEOfSelectionChange
=
true
;
}
void
IMEContentObserver
:
:
MaybeNotifyIMEOfFocusSet
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyIMEOfFocusSet
(
)
"
this
)
)
;
PostFocusSetNotification
(
)
;
FlushMergeableNotifications
(
)
;
}
void
IMEContentObserver
:
:
MaybeNotifyIMEOfTextChange
(
const
TextChangeDataBase
&
aTextChangeData
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyIMEOfTextChange
(
"
"
aTextChangeData
=
%
s
)
"
this
TextChangeDataToString
(
aTextChangeData
)
.
get
(
)
)
)
;
mTextChangeData
+
=
aTextChangeData
;
PostTextChangeNotification
(
)
;
FlushMergeableNotifications
(
)
;
}
void
IMEContentObserver
:
:
CancelNotifyingIMEOfTextChange
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
CancelNotifyingIMEOfTextChange
(
)
"
this
)
)
;
mTextChangeData
.
Clear
(
)
;
mNeedsToNotifyIMEOfTextChange
=
false
;
}
void
IMEContentObserver
:
:
MaybeNotifyIMEOfSelectionChange
(
bool
aCausedByComposition
bool
aCausedBySelectionEvent
bool
aOccurredDuringComposition
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyIMEOfSelectionChange
(
"
"
aCausedByComposition
=
%
s
aCausedBySelectionEvent
=
%
s
"
"
aOccurredDuringComposition
)
"
this
ToChar
(
aCausedByComposition
)
ToChar
(
aCausedBySelectionEvent
)
)
)
;
mSelectionData
.
AssignReason
(
aCausedByComposition
aCausedBySelectionEvent
aOccurredDuringComposition
)
;
PostSelectionChangeNotification
(
)
;
FlushMergeableNotifications
(
)
;
}
void
IMEContentObserver
:
:
MaybeNotifyIMEOfPositionChange
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyIMEOfPositionChange
(
)
"
this
)
)
;
if
(
mIsHandlingQueryContentEvent
&
&
mSendingNotification
=
=
NOTIFY_IME_OF_POSITION_CHANGE
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyIMEOfPositionChange
(
)
"
"
ignored
since
caused
by
ContentEventHandler
during
sending
"
"
NOTIY_IME_OF_POSITION_CHANGE
"
this
)
)
;
return
;
}
PostPositionChangeNotification
(
)
;
FlushMergeableNotifications
(
)
;
}
void
IMEContentObserver
:
:
CancelNotifyingIMEOfPositionChange
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
CancelNotifyIMEOfPositionChange
(
)
"
this
)
)
;
mNeedsToNotifyIMEOfPositionChange
=
false
;
}
void
IMEContentObserver
:
:
MaybeNotifyCompositionEventHandled
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
MaybeNotifyCompositionEventHandled
(
)
"
this
)
)
;
PostCompositionEventHandledNotification
(
)
;
FlushMergeableNotifications
(
)
;
}
bool
IMEContentObserver
:
:
UpdateSelectionCache
(
)
{
MOZ_ASSERT
(
IsSafeToNotifyIME
(
)
)
;
if
(
WasInitializedWithPlugin
(
)
)
{
return
false
;
}
mSelectionData
.
ClearSelectionData
(
)
;
WidgetQueryContentEvent
selection
(
true
eQuerySelectedText
mWidget
)
;
ContentEventHandler
handler
(
GetPresContext
(
)
)
;
handler
.
OnQuerySelectedText
(
&
selection
)
;
if
(
NS_WARN_IF
(
!
selection
.
mSucceeded
)
|
|
NS_WARN_IF
(
selection
.
mReply
.
mContentsRoot
!
=
mRootContent
)
)
{
return
false
;
}
mFocusedWidget
=
selection
.
mReply
.
mFocusedWidget
;
mSelectionData
.
mOffset
=
selection
.
mReply
.
mOffset
;
*
mSelectionData
.
mString
=
selection
.
mReply
.
mString
;
mSelectionData
.
SetWritingMode
(
selection
.
GetWritingMode
(
)
)
;
mSelectionData
.
mReversed
=
selection
.
mReply
.
mReversed
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
UpdateSelectionCache
(
)
"
"
mSelectionData
=
%
s
"
this
SelectionChangeDataToString
(
mSelectionData
)
.
get
(
)
)
)
;
return
mSelectionData
.
IsValid
(
)
;
}
void
IMEContentObserver
:
:
PostPositionChangeNotification
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
PostPositionChangeNotification
(
)
"
this
)
)
;
mNeedsToNotifyIMEOfPositionChange
=
true
;
}
void
IMEContentObserver
:
:
PostCompositionEventHandledNotification
(
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
"
"
PostCompositionEventHandledNotification
(
)
"
this
)
)
;
mNeedsToNotifyIMEOfCompositionEventHandled
=
true
;
}
bool
IMEContentObserver
:
:
IsReflowLocked
(
)
const
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
false
;
}
nsIPresShell
*
presShell
=
presContext
-
>
GetPresShell
(
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
false
;
}
return
presShell
-
>
IsReflowLocked
(
)
;
}
bool
IMEContentObserver
:
:
IsSafeToNotifyIME
(
)
const
{
if
(
!
mWidget
)
{
return
false
;
}
if
(
mSuppressNotifications
)
{
return
false
;
}
if
(
!
mESM
|
|
NS_WARN_IF
(
!
GetPresContext
(
)
)
)
{
return
false
;
}
if
(
IsReflowLocked
(
)
)
{
return
false
;
}
if
(
mEditorBase
&
&
mEditorBase
-
>
IsInEditAction
(
)
)
{
return
false
;
}
return
true
;
}
void
IMEContentObserver
:
:
FlushMergeableNotifications
(
)
{
if
(
!
IsSafeToNotifyIME
(
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
FlushMergeableNotifications
(
)
"
"
FAILED
due
to
unsafe
to
notify
IME
"
this
)
)
;
return
;
}
if
(
mQueuedSender
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
FlushMergeableNotifications
(
)
"
"
FAILED
due
to
already
flushing
pending
notifications
"
this
)
)
;
return
;
}
if
(
mNeedsToNotifyIMEOfTextChange
&
&
!
NeedsTextChangeNotification
(
)
)
{
CancelNotifyingIMEOfTextChange
(
)
;
}
if
(
mNeedsToNotifyIMEOfPositionChange
&
&
!
NeedsPositionChangeNotification
(
)
)
{
CancelNotifyingIMEOfPositionChange
(
)
;
}
if
(
!
NeedsToNotifyIMEOfSomething
(
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
FlushMergeableNotifications
(
)
"
"
FAILED
due
to
no
pending
notifications
"
this
)
)
;
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
FlushMergeableNotifications
(
)
"
"
creating
IMENotificationSender
.
.
.
"
this
)
)
;
mQueuedSender
=
new
IMENotificationSender
(
this
)
;
mQueuedSender
-
>
Dispatch
(
mDocShell
)
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
FlushMergeableNotifications
(
)
"
"
finished
"
this
)
)
;
}
void
IMEContentObserver
:
:
TryToFlushPendingNotifications
(
bool
aAllowAsync
)
{
if
(
!
mQueuedSender
|
|
mSendingNotification
!
=
NOTIFY_IME_OF_NOTHING
|
|
(
XRE_IsContentProcess
(
)
&
&
aAllowAsync
)
)
{
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
TryToFlushPendingNotifications
(
)
"
"
performing
queued
IMENotificationSender
forcibly
"
this
)
)
;
RefPtr
<
IMENotificationSender
>
queuedSender
=
mQueuedSender
;
queuedSender
-
>
Run
(
)
;
}
bool
IMEContentObserver
:
:
AChangeEvent
:
:
CanNotifyIME
(
ChangeEventType
aChangeEventType
)
const
{
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
NS_WARN_IF
(
!
observer
)
)
{
return
false
;
}
if
(
aChangeEventType
=
=
eChangeEventType_CompositionEventHandled
)
{
return
observer
-
>
mWidget
!
=
nullptr
;
}
State
state
=
observer
-
>
GetState
(
)
;
if
(
state
=
=
eState_NotObserving
)
{
return
false
;
}
if
(
aChangeEventType
=
=
eChangeEventType_Focus
)
{
return
!
NS_WARN_IF
(
observer
-
>
mIMEHasFocus
)
;
}
if
(
!
observer
-
>
mIMEHasFocus
)
{
return
false
;
}
MOZ_ASSERT
(
observer
-
>
mWidget
)
;
return
true
;
}
bool
IMEContentObserver
:
:
AChangeEvent
:
:
IsSafeToNotifyIME
(
ChangeEventType
aChangeEventType
)
const
{
if
(
NS_WARN_IF
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
)
{
return
false
;
}
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
false
;
}
if
(
observer
-
>
mSendingNotification
!
=
NOTIFY_IME_OF_NOTHING
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
AChangeEvent
:
:
IsSafeToNotifyIME
(
)
"
"
putting
off
sending
notification
due
to
detecting
recursive
call
"
"
mIMEContentObserver
=
{
mSendingNotification
=
%
s
}
"
this
ToChar
(
observer
-
>
mSendingNotification
)
)
)
;
return
false
;
}
State
state
=
observer
-
>
GetState
(
)
;
if
(
aChangeEventType
=
=
eChangeEventType_Focus
)
{
if
(
NS_WARN_IF
(
state
!
=
eState_Initializing
&
&
state
!
=
eState_Observing
)
)
{
return
false
;
}
}
else
if
(
aChangeEventType
=
=
eChangeEventType_CompositionEventHandled
)
{
}
else
if
(
state
!
=
eState_Observing
)
{
return
false
;
}
return
observer
-
>
IsSafeToNotifyIME
(
)
;
}
void
IMEContentObserver
:
:
IMENotificationSender
:
:
Dispatch
(
nsIDocShell
*
aDocShell
)
{
if
(
XRE_IsContentProcess
(
)
&
&
aDocShell
)
{
RefPtr
<
nsPresContext
>
presContext
;
aDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
presContext
)
{
nsRefreshDriver
*
refreshDriver
=
presContext
-
>
RefreshDriver
(
)
;
if
(
refreshDriver
)
{
refreshDriver
-
>
AddEarlyRunner
(
this
)
;
return
;
}
}
}
nsIScriptGlobalObject
*
globalObject
=
aDocShell
?
aDocShell
-
>
GetScriptGlobalObject
(
)
:
nullptr
;
if
(
globalObject
)
{
RefPtr
<
IMENotificationSender
>
queuedSender
=
this
;
globalObject
-
>
Dispatch
(
TaskCategory
:
:
Other
queuedSender
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
this
)
;
}
}
NS_IMETHODIMP
IMEContentObserver
:
:
IMENotificationSender
:
:
Run
(
)
{
if
(
NS_WARN_IF
(
mIsRunning
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Error
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
Run
(
)
FAILED
"
"
called
recursively
"
this
)
)
;
return
NS_OK
;
}
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
NS_OK
;
}
AutoRestore
<
bool
>
running
(
mIsRunning
)
;
mIsRunning
=
true
;
if
(
observer
-
>
mQueuedSender
!
=
this
)
{
return
NS_OK
;
}
if
(
observer
-
>
mNeedsToNotifyIMEOfFocusSet
)
{
observer
-
>
mNeedsToNotifyIMEOfFocusSet
=
false
;
SendFocusSet
(
)
;
observer
-
>
mQueuedSender
=
nullptr
;
if
(
observer
-
>
mNeedsToNotifyIMEOfFocusSet
)
{
MOZ_ASSERT
(
!
observer
-
>
mIMEHasFocus
)
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
Run
(
)
"
"
posting
IMENotificationSender
to
current
thread
"
this
)
)
;
observer
-
>
mQueuedSender
=
new
IMENotificationSender
(
observer
)
;
observer
-
>
mQueuedSender
-
>
Dispatch
(
observer
-
>
mDocShell
)
;
return
NS_OK
;
}
observer
-
>
ClearPendingNotifications
(
)
;
return
NS_OK
;
}
if
(
observer
-
>
mNeedsToNotifyIMEOfTextChange
)
{
observer
-
>
mNeedsToNotifyIMEOfTextChange
=
false
;
SendTextChange
(
)
;
}
if
(
!
observer
-
>
mNeedsToNotifyIMEOfTextChange
)
{
if
(
observer
-
>
mNeedsToNotifyIMEOfSelectionChange
)
{
observer
-
>
mNeedsToNotifyIMEOfSelectionChange
=
false
;
SendSelectionChange
(
)
;
}
}
if
(
!
observer
-
>
mNeedsToNotifyIMEOfTextChange
&
&
!
observer
-
>
mNeedsToNotifyIMEOfSelectionChange
)
{
if
(
observer
-
>
mNeedsToNotifyIMEOfPositionChange
)
{
observer
-
>
mNeedsToNotifyIMEOfPositionChange
=
false
;
SendPositionChange
(
)
;
}
}
if
(
!
observer
-
>
mNeedsToNotifyIMEOfTextChange
&
&
!
observer
-
>
mNeedsToNotifyIMEOfSelectionChange
&
&
!
observer
-
>
mNeedsToNotifyIMEOfPositionChange
)
{
if
(
observer
-
>
mNeedsToNotifyIMEOfCompositionEventHandled
)
{
observer
-
>
mNeedsToNotifyIMEOfCompositionEventHandled
=
false
;
SendCompositionEventHandled
(
)
;
}
}
observer
-
>
mQueuedSender
=
nullptr
;
if
(
observer
-
>
NeedsToNotifyIMEOfSomething
(
)
)
{
if
(
observer
-
>
GetState
(
)
=
=
eState_StoppedObserving
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
Run
(
)
"
"
waiting
IMENotificationSender
to
be
reinitialized
"
this
)
)
;
}
else
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
Run
(
)
"
"
posting
IMENotificationSender
to
current
thread
"
this
)
)
;
observer
-
>
mQueuedSender
=
new
IMENotificationSender
(
observer
)
;
observer
-
>
mQueuedSender
-
>
Dispatch
(
observer
-
>
mDocShell
)
;
}
}
return
NS_OK
;
}
void
IMEContentObserver
:
:
IMENotificationSender
:
:
SendFocusSet
(
)
{
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
;
}
if
(
!
CanNotifyIME
(
eChangeEventType_Focus
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendFocusSet
(
)
FAILED
due
to
impossible
to
notify
IME
of
focus
"
this
)
)
;
observer
-
>
ClearPendingNotifications
(
)
;
return
;
}
if
(
!
IsSafeToNotifyIME
(
eChangeEventType_Focus
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendFocusSet
(
)
retrying
to
send
NOTIFY_IME_OF_FOCUS
.
.
.
"
this
)
)
;
observer
-
>
PostFocusSetNotification
(
)
;
return
;
}
observer
-
>
mIMEHasFocus
=
true
;
observer
-
>
UpdateSelectionCache
(
)
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Info
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendFocusSet
(
)
sending
NOTIFY_IME_OF_FOCUS
.
.
.
"
this
)
)
;
MOZ_RELEASE_ASSERT
(
observer
-
>
mSendingNotification
=
=
NOTIFY_IME_OF_NOTHING
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_FOCUS
;
IMEStateManager
:
:
NotifyIME
(
IMENotification
(
NOTIFY_IME_OF_FOCUS
)
observer
-
>
mWidget
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_NOTHING
;
observer
-
>
OnIMEReceivedFocus
(
)
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendFocusSet
(
)
sent
NOTIFY_IME_OF_FOCUS
"
this
)
)
;
}
void
IMEContentObserver
:
:
IMENotificationSender
:
:
SendSelectionChange
(
)
{
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
;
}
if
(
!
CanNotifyIME
(
eChangeEventType_Selection
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
FAILED
due
to
impossible
to
notify
IME
of
"
"
selection
change
"
this
)
)
;
return
;
}
if
(
!
IsSafeToNotifyIME
(
eChangeEventType_Selection
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
retrying
to
send
"
"
NOTIFY_IME_OF_SELECTION_CHANGE
.
.
.
"
this
)
)
;
observer
-
>
PostSelectionChangeNotification
(
)
;
return
;
}
SelectionChangeData
lastSelChangeData
=
observer
-
>
mSelectionData
;
if
(
NS_WARN_IF
(
!
observer
-
>
UpdateSelectionCache
(
)
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Error
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
FAILED
due
to
UpdateSelectionCache
(
)
failure
"
this
)
)
;
return
;
}
if
(
!
CanNotifyIME
(
eChangeEventType_Selection
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
FAILED
due
to
flushing
layout
having
changed
"
"
something
"
this
)
)
;
return
;
}
SelectionChangeData
&
newSelChangeData
=
observer
-
>
mSelectionData
;
if
(
lastSelChangeData
.
IsValid
(
)
&
&
lastSelChangeData
.
mOffset
=
=
newSelChangeData
.
mOffset
&
&
lastSelChangeData
.
String
(
)
=
=
newSelChangeData
.
String
(
)
&
&
lastSelChangeData
.
GetWritingMode
(
)
=
=
newSelChangeData
.
GetWritingMode
(
)
&
&
lastSelChangeData
.
mReversed
=
=
newSelChangeData
.
mReversed
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
not
notifying
IME
of
"
"
NOTIFY_IME_OF_SELECTION_CHANGE
due
to
not
changed
actually
"
this
)
)
;
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Info
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
sending
NOTIFY_IME_OF_SELECTION_CHANGE
.
.
.
"
"
newSelChangeData
=
%
s
"
this
SelectionChangeDataToString
(
newSelChangeData
)
.
get
(
)
)
)
;
IMENotification
notification
(
NOTIFY_IME_OF_SELECTION_CHANGE
)
;
notification
.
SetData
(
observer
-
>
mSelectionData
)
;
MOZ_RELEASE_ASSERT
(
observer
-
>
mSendingNotification
=
=
NOTIFY_IME_OF_NOTHING
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_SELECTION_CHANGE
;
IMEStateManager
:
:
NotifyIME
(
notification
observer
-
>
mWidget
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_NOTHING
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendSelectionChange
(
)
sent
NOTIFY_IME_OF_SELECTION_CHANGE
"
this
)
)
;
}
void
IMEContentObserver
:
:
IMENotificationSender
:
:
SendTextChange
(
)
{
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
;
}
if
(
!
CanNotifyIME
(
eChangeEventType_Text
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendTextChange
(
)
FAILED
due
to
impossible
to
notify
IME
of
text
"
"
change
"
this
)
)
;
return
;
}
if
(
!
IsSafeToNotifyIME
(
eChangeEventType_Text
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendTextChange
(
)
retrying
to
send
NOTIFY_IME_OF_TEXT_CHANGE
.
.
.
"
this
)
)
;
observer
-
>
PostTextChangeNotification
(
)
;
return
;
}
if
(
!
observer
-
>
NeedsTextChangeNotification
(
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Warning
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendTextChange
(
)
canceling
sending
NOTIFY_IME_OF_TEXT_CHANGE
"
this
)
)
;
observer
-
>
CancelNotifyingIMEOfTextChange
(
)
;
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Info
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendTextChange
(
)
sending
NOTIFY_IME_OF_TEXT_CHANGE
.
.
.
"
"
mIMEContentObserver
=
{
mTextChangeData
=
%
s
}
"
this
TextChangeDataToString
(
observer
-
>
mTextChangeData
)
.
get
(
)
)
)
;
IMENotification
notification
(
NOTIFY_IME_OF_TEXT_CHANGE
)
;
notification
.
SetData
(
observer
-
>
mTextChangeData
)
;
observer
-
>
mTextChangeData
.
Clear
(
)
;
MOZ_RELEASE_ASSERT
(
observer
-
>
mSendingNotification
=
=
NOTIFY_IME_OF_NOTHING
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_TEXT_CHANGE
;
IMEStateManager
:
:
NotifyIME
(
notification
observer
-
>
mWidget
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_NOTHING
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendTextChange
(
)
sent
NOTIFY_IME_OF_TEXT_CHANGE
"
this
)
)
;
}
void
IMEContentObserver
:
:
IMENotificationSender
:
:
SendPositionChange
(
)
{
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
;
}
if
(
!
CanNotifyIME
(
eChangeEventType_Position
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendPositionChange
(
)
FAILED
due
to
impossible
to
notify
IME
of
"
"
position
change
"
this
)
)
;
return
;
}
if
(
!
IsSafeToNotifyIME
(
eChangeEventType_Position
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendPositionChange
(
)
retrying
to
send
"
"
NOTIFY_IME_OF_POSITION_CHANGE
.
.
.
"
this
)
)
;
observer
-
>
PostPositionChangeNotification
(
)
;
return
;
}
if
(
!
observer
-
>
NeedsPositionChangeNotification
(
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Warning
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendPositionChange
(
)
canceling
sending
NOTIFY_IME_OF_POSITION_CHANGE
"
this
)
)
;
observer
-
>
CancelNotifyingIMEOfPositionChange
(
)
;
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Info
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendPositionChange
(
)
sending
NOTIFY_IME_OF_POSITION_CHANGE
.
.
.
"
this
)
)
;
MOZ_RELEASE_ASSERT
(
observer
-
>
mSendingNotification
=
=
NOTIFY_IME_OF_NOTHING
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_POSITION_CHANGE
;
IMEStateManager
:
:
NotifyIME
(
IMENotification
(
NOTIFY_IME_OF_POSITION_CHANGE
)
observer
-
>
mWidget
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_NOTHING
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendPositionChange
(
)
sent
NOTIFY_IME_OF_POSITION_CHANGE
"
this
)
)
;
}
void
IMEContentObserver
:
:
IMENotificationSender
:
:
SendCompositionEventHandled
(
)
{
RefPtr
<
IMEContentObserver
>
observer
=
GetObserver
(
)
;
if
(
!
observer
)
{
return
;
}
if
(
!
CanNotifyIME
(
eChangeEventType_CompositionEventHandled
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendCompositionEventHandled
(
)
FAILED
due
to
impossible
to
notify
"
"
IME
of
composition
event
handled
"
this
)
)
;
return
;
}
if
(
!
IsSafeToNotifyIME
(
eChangeEventType_CompositionEventHandled
)
)
{
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendCompositionEventHandled
(
)
retrying
to
send
"
"
NOTIFY_IME_OF_POSITION_CHANGE
.
.
.
"
this
)
)
;
observer
-
>
PostCompositionEventHandledNotification
(
)
;
return
;
}
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Info
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendCompositionEventHandled
(
)
sending
"
"
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
.
.
.
"
this
)
)
;
MOZ_RELEASE_ASSERT
(
observer
-
>
mSendingNotification
=
=
NOTIFY_IME_OF_NOTHING
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
;
IMEStateManager
:
:
NotifyIME
(
IMENotification
(
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
)
observer
-
>
mWidget
)
;
observer
-
>
mSendingNotification
=
NOTIFY_IME_OF_NOTHING
;
MOZ_LOG
(
sIMECOLog
LogLevel
:
:
Debug
(
"
0x
%
p
IMEContentObserver
:
:
IMENotificationSender
:
:
"
"
SendCompositionEventHandled
(
)
sent
"
"
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
"
this
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
IMEContentObserver
:
:
DocumentObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
IMEContentObserver
:
:
DocumentObserver
)
tmp
-
>
StopObserving
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
IMEContentObserver
:
:
DocumentObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIMEContentObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IMEContentObserver
:
:
DocumentObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IMEContentObserver
:
:
DocumentObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IMEContentObserver
:
:
DocumentObserver
)
void
IMEContentObserver
:
:
DocumentObserver
:
:
Observe
(
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
RefPtr
<
nsIDocument
>
newDocument
=
aDocument
;
StopObserving
(
)
;
mDocument
=
newDocument
.
forget
(
)
;
mDocument
-
>
AddObserver
(
this
)
;
}
void
IMEContentObserver
:
:
DocumentObserver
:
:
StopObserving
(
)
{
if
(
!
IsObserving
(
)
)
{
return
;
}
RefPtr
<
IMEContentObserver
>
observer
=
mIMEContentObserver
.
forget
(
)
;
RefPtr
<
nsIDocument
>
document
=
mDocument
.
forget
(
)
;
document
-
>
RemoveObserver
(
this
)
;
for
(
;
IsUpdating
(
)
;
-
-
mDocumentUpdating
)
{
observer
-
>
EndDocumentUpdate
(
)
;
}
}
void
IMEContentObserver
:
:
DocumentObserver
:
:
Destroy
(
)
{
StopObserving
(
)
;
mIMEContentObserver
=
nullptr
;
}
void
IMEContentObserver
:
:
DocumentObserver
:
:
BeginUpdate
(
nsIDocument
*
aDocument
nsUpdateType
aUpdateType
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
|
|
NS_WARN_IF
(
!
IsObserving
(
)
)
)
{
return
;
}
if
(
!
(
aUpdateType
&
UPDATE_CONTENT_MODEL
)
)
{
return
;
}
mDocumentUpdating
+
+
;
mIMEContentObserver
-
>
BeginDocumentUpdate
(
)
;
}
void
IMEContentObserver
:
:
DocumentObserver
:
:
EndUpdate
(
nsIDocument
*
aDocument
nsUpdateType
aUpdateType
)
{
if
(
NS_WARN_IF
(
Destroyed
(
)
)
|
|
NS_WARN_IF
(
!
IsObserving
(
)
)
|
|
NS_WARN_IF
(
!
IsUpdating
(
)
)
)
{
return
;
}
if
(
!
(
aUpdateType
&
UPDATE_CONTENT_MODEL
)
)
{
return
;
}
mDocumentUpdating
-
-
;
mIMEContentObserver
-
>
EndDocumentUpdate
(
)
;
}
}
