#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
dom
/
AbortController
.
h
"
#
include
"
mozilla
/
dom
/
NavigateEvent
.
h
"
#
include
"
mozilla
/
dom
/
NavigateEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
Navigation
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED_WITH_JS_MEMBERS
(
NavigateEvent
Event
(
mDestination
mSignal
mFormData
mSourceElement
mNavigationHandlerList
mAbortController
)
(
mInfo
)
)
NS_IMPL_ADDREF_INHERITED
(
NavigateEvent
Event
)
NS_IMPL_RELEASE_INHERITED
(
NavigateEvent
Event
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
NavigateEvent
)
NS_INTERFACE_MAP_END_INHERITING
(
Event
)
JSObject
*
NavigateEvent
:
:
WrapObjectInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
NavigateEvent_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
NavigateEvent
>
NavigateEvent
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aType
const
NavigateEventInit
&
aEventInitDict
)
{
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
eventTarget
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
return
Constructor
(
eventTarget
aType
aEventInitDict
)
;
}
already_AddRefed
<
NavigateEvent
>
NavigateEvent
:
:
Constructor
(
EventTarget
*
aEventTarget
const
nsAString
&
aType
const
NavigateEventInit
&
aEventInitDict
)
{
RefPtr
<
NavigateEvent
>
event
=
new
NavigateEvent
(
aEventTarget
)
;
bool
trusted
=
event
-
>
Init
(
aEventTarget
)
;
event
-
>
InitEvent
(
aType
aEventInitDict
.
mBubbles
?
CanBubble
:
:
eYes
:
CanBubble
:
:
eNo
aEventInitDict
.
mCancelable
?
Cancelable
:
:
eYes
:
Cancelable
:
:
eNo
aEventInitDict
.
mComposed
?
Composed
:
:
eYes
:
Composed
:
:
eNo
)
;
event
-
>
InitNavigateEvent
(
aEventInitDict
)
;
event
-
>
SetTrusted
(
trusted
)
;
return
event
.
forget
(
)
;
}
already_AddRefed
<
NavigateEvent
>
NavigateEvent
:
:
Constructor
(
EventTarget
*
aEventTarget
const
nsAString
&
aType
const
NavigateEventInit
&
aEventInitDict
nsIStructuredCloneContainer
*
aClassicHistoryAPIState
AbortController
*
aAbortController
)
{
RefPtr
<
NavigateEvent
>
event
=
Constructor
(
aEventTarget
aType
aEventInitDict
)
;
event
-
>
mAbortController
=
aAbortController
;
MOZ_DIAGNOSTIC_ASSERT
(
event
-
>
mSignal
=
=
aAbortController
-
>
Signal
(
)
)
;
event
-
>
mClassicHistoryAPIState
=
aClassicHistoryAPIState
;
return
event
.
forget
(
)
;
}
NavigationType
NavigateEvent
:
:
NavigationType
(
)
const
{
return
mNavigationType
;
}
already_AddRefed
<
NavigationDestination
>
NavigateEvent
:
:
Destination
(
)
const
{
return
do_AddRef
(
mDestination
)
;
}
bool
NavigateEvent
:
:
CanIntercept
(
)
const
{
return
mCanIntercept
;
}
bool
NavigateEvent
:
:
UserInitiated
(
)
const
{
return
mUserInitiated
;
}
bool
NavigateEvent
:
:
HashChange
(
)
const
{
return
mHashChange
;
}
AbortSignal
*
NavigateEvent
:
:
Signal
(
)
const
{
return
mSignal
;
}
already_AddRefed
<
FormData
>
NavigateEvent
:
:
GetFormData
(
)
const
{
return
do_AddRef
(
mFormData
)
;
}
void
NavigateEvent
:
:
GetDownloadRequest
(
nsAString
&
aDownloadRequest
)
const
{
aDownloadRequest
=
mDownloadRequest
;
}
void
NavigateEvent
:
:
GetInfo
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aInfo
)
const
{
aInfo
.
set
(
mInfo
)
;
}
bool
NavigateEvent
:
:
HasUAVisualTransition
(
)
const
{
return
mHasUAVisualTransition
;
}
Element
*
NavigateEvent
:
:
GetSourceElement
(
)
const
{
return
mSourceElement
;
}
void
NavigateEvent
:
:
Intercept
(
const
NavigationInterceptOptions
&
aOptions
ErrorResult
&
aRv
)
{
}
void
NavigateEvent
:
:
Scroll
(
ErrorResult
&
aRv
)
{
}
NavigateEvent
:
:
NavigateEvent
(
EventTarget
*
aOwner
)
:
Event
(
aOwner
nullptr
nullptr
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
NavigateEvent
:
:
~
NavigateEvent
(
)
{
DropJSObjects
(
this
)
;
}
void
NavigateEvent
:
:
InitNavigateEvent
(
const
NavigateEventInit
&
aEventInitDict
)
{
mNavigationType
=
aEventInitDict
.
mNavigationType
;
mDestination
=
aEventInitDict
.
mDestination
;
mCanIntercept
=
aEventInitDict
.
mCanIntercept
;
mUserInitiated
=
aEventInitDict
.
mUserInitiated
;
mHashChange
=
aEventInitDict
.
mHashChange
;
mSignal
=
aEventInitDict
.
mSignal
;
mFormData
=
aEventInitDict
.
mFormData
;
mDownloadRequest
=
aEventInitDict
.
mDownloadRequest
;
mInfo
=
aEventInitDict
.
mInfo
;
mHasUAVisualTransition
=
aEventInitDict
.
mHasUAVisualTransition
;
mSourceElement
=
aEventInitDict
.
mSourceElement
;
}
void
NavigateEvent
:
:
SetCanIntercept
(
bool
aCanIntercept
)
{
mCanIntercept
=
aCanIntercept
;
}
enum
NavigateEvent
:
:
InterceptionState
NavigateEvent
:
:
InterceptionState
(
)
const
{
return
mInterceptionState
;
}
void
NavigateEvent
:
:
SetInterceptionState
(
enum
InterceptionState
aInterceptionState
)
{
mInterceptionState
=
aInterceptionState
;
}
nsIStructuredCloneContainer
*
NavigateEvent
:
:
ClassicHistoryAPIState
(
)
const
{
return
mClassicHistoryAPIState
;
}
nsTArray
<
RefPtr
<
NavigationInterceptHandler
>
>
&
NavigateEvent
:
:
NavigationHandlerList
(
)
{
return
mNavigationHandlerList
;
}
void
NavigateEvent
:
:
Finish
(
bool
aDidFulfill
)
{
switch
(
mInterceptionState
)
{
case
InterceptionState
:
:
Intercepted
:
case
InterceptionState
:
:
Finished
:
MOZ_DIAGNOSTIC_ASSERT
(
false
)
;
break
;
case
InterceptionState
:
:
None
:
return
;
default
:
break
;
}
PotentiallyResetFocus
(
)
;
if
(
aDidFulfill
)
{
PotentiallyProcessScrollBehavior
(
)
;
}
mInterceptionState
=
InterceptionState
:
:
Finished
;
}
void
NavigateEvent
:
:
PotentiallyResetFocus
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mInterceptionState
=
=
InterceptionState
:
:
Committed
|
|
mInterceptionState
=
=
InterceptionState
:
:
Scrolled
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
GetParentObject
(
)
)
;
if
(
NS_WARN_IF
(
!
window
)
)
{
return
;
}
Navigation
*
navigation
=
window
-
>
Navigation
(
)
;
bool
focusChanged
=
navigation
-
>
FocusedChangedDuringOngoingNavigation
(
)
;
navigation
-
>
SetFocusedChangedDuringOngoingNavigation
(
false
)
;
if
(
focusChanged
)
{
return
;
}
if
(
mFocusResetBehavior
&
&
*
mFocusResetBehavior
=
=
NavigationFocusReset
:
:
Manual
)
{
return
;
}
Document
*
document
=
window
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
;
}
Element
*
focusTarget
=
document
-
>
GetDocumentElement
(
)
;
if
(
focusTarget
)
{
focusTarget
=
focusTarget
-
>
GetAutofocusDelegate
(
mozilla
:
:
IsFocusableFlags
(
0
)
)
;
}
if
(
!
focusTarget
)
{
focusTarget
=
document
-
>
GetBody
(
)
;
}
if
(
!
focusTarget
)
{
focusTarget
=
document
-
>
GetDocumentElement
(
)
;
}
}
void
NavigateEvent
:
:
PotentiallyProcessScrollBehavior
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mInterceptionState
=
=
InterceptionState
:
:
Committed
|
|
mInterceptionState
=
=
InterceptionState
:
:
Scrolled
)
;
if
(
mInterceptionState
=
=
InterceptionState
:
:
Scrolled
)
{
return
;
}
if
(
mScrollBehavior
&
&
*
mScrollBehavior
=
=
NavigationScrollBehavior
:
:
Manual
)
{
return
;
}
ProcessScrollBehavior
(
)
;
}
void
NavigateEvent
:
:
ProcessScrollBehavior
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mInterceptionState
=
=
InterceptionState
:
:
Committed
)
;
mInterceptionState
=
InterceptionState
:
:
Scrolled
;
switch
(
mNavigationType
)
{
case
NavigationType
:
:
Traverse
:
case
NavigationType
:
:
Reload
:
return
;
default
:
break
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
GetParentObject
(
)
)
;
Unused
<
<
window
-
>
GetExtantDoc
(
)
;
}
}
