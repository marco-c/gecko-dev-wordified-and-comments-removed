#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
AsyncEventDispatcher
:
:
AsyncEventDispatcher
(
EventTarget
*
aTarget
WidgetEvent
&
aEvent
)
:
CancelableRunnable
(
"
AsyncEventDispatcher
"
)
mTarget
(
aTarget
)
mEventMessage
(
eUnidentifiedEvent
)
{
MOZ_ASSERT
(
mTarget
)
;
RefPtr
<
Event
>
event
=
EventDispatcher
:
:
CreateEvent
(
aTarget
nullptr
&
aEvent
u
"
"
_ns
)
;
mEvent
=
std
:
:
move
(
event
)
;
mEventType
.
SetIsVoid
(
true
)
;
NS_ASSERTION
(
mEvent
"
Should
never
fail
to
create
an
event
"
)
;
mEvent
-
>
DuplicatePrivateData
(
)
;
mEvent
-
>
SetTrusted
(
aEvent
.
IsTrusted
(
)
)
;
}
NS_IMETHODIMP
AsyncEventDispatcher
:
:
Run
(
)
{
if
(
mCanceled
)
{
return
NS_OK
;
}
nsINode
*
node
=
nsINode
:
:
FromEventTargetOrNull
(
mTarget
)
;
if
(
mCheckStillInDoc
)
{
MOZ_ASSERT
(
node
)
;
if
(
!
node
-
>
IsInComposedDoc
(
)
)
{
return
NS_OK
;
}
}
mTarget
-
>
AsyncEventRunning
(
this
)
;
if
(
mEventMessage
!
=
eUnidentifiedEvent
)
{
MOZ_ASSERT
(
mComposed
=
=
Composed
:
:
eDefault
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
<
WidgetEvent
>
(
node
-
>
OwnerDoc
(
)
mTarget
mEventMessage
mCanBubble
Cancelable
:
:
eNo
nullptr
mOnlyChromeDispatch
)
;
}
DispatchEventOnTarget
(
MOZ_KnownLive
(
mTarget
)
mEventType
mCanBubble
mOnlyChromeDispatch
mComposed
MOZ_KnownLive
(
mEvent
)
)
;
return
NS_OK
;
}
void
AsyncEventDispatcher
:
:
DispatchEventOnTarget
(
EventTarget
*
aTarget
const
nsAString
&
aEventType
CanBubble
aCanBubble
ChromeOnlyDispatch
aOnlyChromeDispatch
Composed
aComposed
Event
*
aEvent
)
{
RefPtr
<
Event
>
event
=
aEvent
;
if
(
!
event
)
{
event
=
NS_NewDOMEvent
(
aTarget
nullptr
nullptr
)
;
event
-
>
InitEvent
(
aEventType
aCanBubble
Cancelable
:
:
eNo
)
;
event
-
>
SetTrusted
(
true
)
;
}
if
(
aComposed
!
=
Composed
:
:
eDefault
)
{
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mComposed
=
aComposed
=
=
Composed
:
:
eYes
;
}
if
(
aOnlyChromeDispatch
=
=
ChromeOnlyDispatch
:
:
eYes
)
{
MOZ_ASSERT
(
event
-
>
IsTrusted
(
)
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
aTarget
-
>
DispatchEvent
(
*
event
)
;
}
nsresult
AsyncEventDispatcher
:
:
Cancel
(
)
{
mCanceled
=
true
;
return
NS_OK
;
}
nsresult
AsyncEventDispatcher
:
:
PostDOMEvent
(
)
{
RefPtr
<
AsyncEventDispatcher
>
ensureDeletionWhenFailing
=
this
;
if
(
NS_IsMainThread
(
)
)
{
if
(
nsCOMPtr
<
nsIGlobalObject
>
global
=
mTarget
-
>
GetOwnerGlobal
(
)
)
{
return
global
-
>
Dispatch
(
TaskCategory
:
:
Other
ensureDeletionWhenFailing
.
forget
(
)
)
;
}
if
(
nsINode
*
node
=
nsINode
:
:
FromEventTargetOrNull
(
mTarget
)
)
{
RefPtr
<
Document
>
doc
=
node
-
>
OwnerDoc
(
)
;
return
doc
-
>
Dispatch
(
TaskCategory
:
:
Other
ensureDeletionWhenFailing
.
forget
(
)
)
;
}
}
return
NS_DispatchToCurrentThread
(
this
)
;
}
void
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
)
{
RefPtr
<
AsyncEventDispatcher
>
ensureDeletionWhenFailing
=
this
;
nsContentUtils
:
:
AddScriptRunner
(
this
)
;
}
void
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
nsINode
&
aTarget
const
nsAString
&
aEventType
CanBubble
aCanBubble
ChromeOnlyDispatch
aOnlyChromeDispatch
Composed
aComposed
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
OwningNonNull
<
nsINode
>
target
=
aTarget
;
DispatchEventOnTarget
(
target
aEventType
aCanBubble
aOnlyChromeDispatch
aComposed
)
;
return
;
}
(
new
AsyncEventDispatcher
(
&
aTarget
aEventType
aCanBubble
aOnlyChromeDispatch
aComposed
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
nsresult
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
nsINode
&
aTarget
WidgetEvent
&
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsPresContext
*
presContext
=
aTarget
.
OwnerDoc
(
)
-
>
GetPresContext
(
)
;
return
EventDispatcher
:
:
Dispatch
(
MOZ_KnownLive
(
&
aTarget
)
MOZ_KnownLive
(
presContext
)
&
aEvent
nullptr
aEventStatus
)
;
}
(
new
AsyncEventDispatcher
(
&
aTarget
aEvent
)
)
-
>
RunDOMEventWhenSafe
(
)
;
return
NS_OK
;
}
void
AsyncEventDispatcher
:
:
RequireNodeInDocument
(
)
{
MOZ_ASSERT
(
mTarget
)
;
MOZ_ASSERT
(
mTarget
-
>
IsNode
(
)
)
;
mCheckStillInDoc
=
true
;
}
LoadBlockingAsyncEventDispatcher
:
:
~
LoadBlockingAsyncEventDispatcher
(
)
{
if
(
mBlockedDoc
)
{
mBlockedDoc
-
>
UnblockOnload
(
true
)
;
}
}
}
