#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
using
namespace
dom
;
AsyncEventDispatcher
:
:
AsyncEventDispatcher
(
EventTarget
*
aTarget
WidgetEvent
&
aEvent
)
:
CancelableRunnable
(
"
AsyncEventDispatcher
"
)
mTarget
(
aTarget
)
mEventMessage
(
eUnidentifiedEvent
)
{
MOZ_ASSERT
(
mTarget
)
;
RefPtr
<
Event
>
event
=
EventDispatcher
:
:
CreateEvent
(
aTarget
nullptr
&
aEvent
u
"
"
_ns
)
;
mEvent
=
std
:
:
move
(
event
)
;
mEventType
.
SetIsVoid
(
true
)
;
NS_ASSERTION
(
mEvent
"
Should
never
fail
to
create
an
event
"
)
;
mEvent
-
>
DuplicatePrivateData
(
)
;
mEvent
-
>
SetTrusted
(
aEvent
.
IsTrusted
(
)
)
;
}
NS_IMETHODIMP
AsyncEventDispatcher
:
:
Run
(
)
{
if
(
mCanceled
)
{
return
NS_OK
;
}
nsINode
*
node
=
nsINode
:
:
FromEventTargetOrNull
(
mTarget
)
;
if
(
mCheckStillInDoc
)
{
MOZ_ASSERT
(
node
)
;
if
(
!
node
-
>
IsInComposedDoc
(
)
)
{
return
NS_OK
;
}
}
mTarget
-
>
AsyncEventRunning
(
this
)
;
if
(
mEventMessage
!
=
eUnidentifiedEvent
)
{
MOZ_ASSERT
(
mComposed
=
=
Composed
:
:
eDefault
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
<
WidgetEvent
>
(
node
-
>
OwnerDoc
(
)
mTarget
mEventMessage
mCanBubble
Cancelable
:
:
eNo
nullptr
mOnlyChromeDispatch
)
;
}
RefPtr
<
Event
>
event
=
mEvent
;
if
(
!
event
)
{
event
=
NS_NewDOMEvent
(
mTarget
nullptr
nullptr
)
;
event
-
>
InitEvent
(
mEventType
mCanBubble
Cancelable
:
:
eNo
)
;
event
-
>
SetTrusted
(
true
)
;
}
if
(
mComposed
!
=
Composed
:
:
eDefault
)
{
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mComposed
=
mComposed
=
=
Composed
:
:
eYes
;
}
if
(
mOnlyChromeDispatch
=
=
ChromeOnlyDispatch
:
:
eYes
)
{
MOZ_ASSERT
(
event
-
>
IsTrusted
(
)
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
mTarget
-
>
DispatchEvent
(
*
event
)
;
return
NS_OK
;
}
nsresult
AsyncEventDispatcher
:
:
Cancel
(
)
{
mCanceled
=
true
;
return
NS_OK
;
}
nsresult
AsyncEventDispatcher
:
:
PostDOMEvent
(
)
{
RefPtr
<
AsyncEventDispatcher
>
ensureDeletionWhenFailing
=
this
;
if
(
NS_IsMainThread
(
)
)
{
if
(
nsCOMPtr
<
nsIGlobalObject
>
global
=
mTarget
-
>
GetOwnerGlobal
(
)
)
{
return
global
-
>
Dispatch
(
TaskCategory
:
:
Other
ensureDeletionWhenFailing
.
forget
(
)
)
;
}
if
(
nsINode
*
node
=
nsINode
:
:
FromEventTargetOrNull
(
mTarget
)
)
{
RefPtr
<
Document
>
doc
=
node
-
>
OwnerDoc
(
)
;
return
doc
-
>
Dispatch
(
TaskCategory
:
:
Other
ensureDeletionWhenFailing
.
forget
(
)
)
;
}
}
return
NS_DispatchToCurrentThread
(
this
)
;
}
void
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
)
{
RefPtr
<
AsyncEventDispatcher
>
ensureDeletionWhenFailing
=
this
;
nsContentUtils
:
:
AddScriptRunner
(
this
)
;
}
nsresult
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
nsINode
&
aTarget
WidgetEvent
&
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsPresContext
*
presContext
=
aTarget
.
OwnerDoc
(
)
-
>
GetPresContext
(
)
;
return
EventDispatcher
:
:
Dispatch
(
MOZ_KnownLive
(
&
aTarget
)
MOZ_KnownLive
(
presContext
)
&
aEvent
nullptr
aEventStatus
)
;
}
(
new
AsyncEventDispatcher
(
&
aTarget
aEvent
)
)
-
>
RunDOMEventWhenSafe
(
)
;
return
NS_OK
;
}
void
AsyncEventDispatcher
:
:
RequireNodeInDocument
(
)
{
MOZ_ASSERT
(
mTarget
)
;
MOZ_ASSERT
(
mTarget
-
>
IsNode
(
)
)
;
mCheckStillInDoc
=
true
;
}
LoadBlockingAsyncEventDispatcher
:
:
~
LoadBlockingAsyncEventDispatcher
(
)
{
if
(
mBlockedDoc
)
{
mBlockedDoc
-
>
UnblockOnload
(
true
)
;
}
}
}
