#
ifndef
mozilla_EventStateManager_h_
#
define
mozilla_EventStateManager_h_
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
layers
/
APZUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
Units
.
h
"
#
include
"
WheelHandlingHelper
.
h
"
#
define
NS_USER_INTERACTION_INTERVAL
5000
/
/
ms
class
nsFrameLoader
;
class
nsIContent
;
class
nsIDocShell
;
class
nsIDocShellTreeItem
;
class
imgIContainer
;
class
nsIContentViewer
;
class
nsIScrollableFrame
;
class
nsITimer
;
class
nsPresContext
;
namespace
mozilla
{
class
EnterLeaveDispatcher
;
class
EventStates
;
class
IMEContentObserver
;
class
ScrollbarsForWheel
;
class
WheelTransaction
;
namespace
dom
{
class
DataTransfer
;
class
Document
;
class
Element
;
class
Selection
;
class
TabParent
;
}
class
OverOutElementsWrapper
final
:
public
nsISupports
{
~
OverOutElementsWrapper
(
)
;
public
:
OverOutElementsWrapper
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
OverOutElementsWrapper
)
WeakFrame
mLastOverFrame
;
nsCOMPtr
<
nsIContent
>
mLastOverElement
;
nsCOMPtr
<
nsIContent
>
mFirstOverEventElement
;
nsCOMPtr
<
nsIContent
>
mFirstOutEventElement
;
}
;
class
EventStateManager
:
public
nsSupportsWeakReference
public
nsIObserver
{
friend
class
mozilla
:
:
EnterLeaveDispatcher
;
friend
class
mozilla
:
:
ScrollbarsForWheel
;
friend
class
mozilla
:
:
WheelTransaction
;
virtual
~
EventStateManager
(
)
;
public
:
EventStateManager
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIOBSERVER
nsresult
Init
(
)
;
nsresult
Shutdown
(
)
;
nsresult
PreHandleEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIFrame
*
aTargetFrame
nsIContent
*
aTargetContent
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PostHandleEvent
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIFrame
*
aTargetFrame
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
;
void
PostHandleKeyboardEvent
(
WidgetKeyboardEvent
*
aKeyboardEvent
nsIFrame
*
aTargetFrame
nsEventStatus
&
aStatus
)
;
void
DispatchLegacyMouseScrollEvents
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
nsEventStatus
*
aStatus
)
;
void
NotifyDestroyPresContext
(
nsPresContext
*
aPresContext
)
;
void
SetPresContext
(
nsPresContext
*
aPresContext
)
;
void
ClearFrameRefs
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
GetEventTarget
(
)
;
already_AddRefed
<
nsIContent
>
GetEventTargetContent
(
WidgetEvent
*
aEvent
)
;
bool
SetContentState
(
nsIContent
*
aContent
EventStates
aState
)
;
void
NativeAnonymousContentRemoved
(
nsIContent
*
aAnonContent
)
;
void
ContentRemoved
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
)
;
bool
EventStatusOK
(
WidgetGUIEvent
*
aEvent
)
;
void
OnStartToObserveContent
(
IMEContentObserver
*
aIMEContentObserver
)
;
void
OnStopObservingContent
(
IMEContentObserver
*
aIMEContentObserver
)
;
void
TryToFlushPendingNotificationsToIME
(
)
;
void
RegisterAccessKey
(
dom
:
:
Element
*
aElement
uint32_t
aKey
)
;
void
UnregisterAccessKey
(
dom
:
:
Element
*
aElement
uint32_t
aKey
)
;
uint32_t
GetRegisteredAccessKey
(
dom
:
:
Element
*
aContent
)
;
static
void
GetAccessKeyLabelPrefix
(
dom
:
:
Element
*
aElement
nsAString
&
aPrefix
)
;
bool
HandleAccessKey
(
WidgetKeyboardEvent
*
aEvent
nsPresContext
*
aPresContext
nsTArray
<
uint32_t
>
&
aAccessCharCodes
)
{
return
WalkESMTreeToHandleAccessKey
(
aEvent
aPresContext
aAccessCharCodes
nullptr
eAccessKeyProcessingNormal
true
)
;
}
bool
CheckIfEventMatchesAccessKey
(
WidgetKeyboardEvent
*
aEvent
nsPresContext
*
aPresContext
)
;
nsresult
SetCursor
(
StyleCursorKind
aCursor
imgIContainer
*
aContainer
const
Maybe
<
gfx
:
:
IntPoint
>
&
aHotspot
nsIWidget
*
aWidget
bool
aLockCursor
)
;
static
void
StartHandlingUserInput
(
EventMessage
aMessage
)
;
static
void
StopHandlingUserInput
(
EventMessage
aMessage
)
;
static
TimeStamp
GetHandlingInputStart
(
)
{
return
sHandlingInputStart
;
}
static
bool
IsHandlingUserInput
(
)
;
static
bool
IsHandlingKeyboardInput
(
)
;
static
uint64_t
UserInputCount
(
)
{
return
sUserInputCounter
;
}
static
TimeStamp
LatestUserInputStart
(
)
{
return
sLatestUserInputStart
;
}
nsPresContext
*
GetPresContext
(
)
{
return
mPresContext
;
}
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
EventStateManager
nsIObserver
)
static
dom
:
:
Document
*
sMouseOverDocument
;
static
EventStateManager
*
GetActiveEventStateManager
(
)
{
return
sActiveESM
;
}
static
void
SetActiveManager
(
EventStateManager
*
aNewESM
nsIContent
*
aContent
)
;
static
void
SetFullscreenState
(
dom
:
:
Element
*
aElement
bool
aIsFullscreen
)
;
static
bool
IsRemoteTarget
(
nsIContent
*
aTarget
)
;
static
Maybe
<
layers
:
:
APZWheelAction
>
APZWheelActionFor
(
const
WidgetWheelEvent
*
aEvent
)
;
static
WheelDeltaAdjustmentStrategy
GetWheelDeltaAdjustmentStrategy
(
const
WidgetWheelEvent
&
aEvent
)
;
static
void
GetUserPrefsForWheelEvent
(
const
WidgetWheelEvent
*
aEvent
double
*
aOutMultiplierX
double
*
aOutMultiplierY
)
;
static
CSSIntPoint
sLastScreenPoint
;
static
CSSIntPoint
sLastClientPoint
;
static
bool
sIsPointerLocked
;
static
nsWeakPtr
sPointerLockedElement
;
static
nsWeakPtr
sPointerLockedDoc
;
enum
{
MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL
=
1000
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleMiddleClickPaste
(
nsIPresShell
*
aPresShell
WidgetMouseEvent
*
aMouseEvent
nsEventStatus
*
aStatus
TextEditor
*
aTextEditor
)
;
protected
:
class
Prefs
{
public
:
static
bool
KeyCausesActivation
(
)
{
return
sKeyCausesActivation
;
}
static
bool
ClickHoldContextMenu
(
)
{
return
sClickHoldContextMenu
;
}
static
void
Init
(
)
;
private
:
static
bool
sKeyCausesActivation
;
static
bool
sClickHoldContextMenu
;
static
int32_t
GetAccessModifierMask
(
int32_t
aItemType
)
;
}
;
void
ClearCachedWidgetCursor
(
nsIFrame
*
aTargetFrame
)
;
void
UpdateCursor
(
nsPresContext
*
aPresContext
WidgetEvent
*
aEvent
nsIFrame
*
aTargetFrame
nsEventStatus
*
aStatus
)
;
nsIFrame
*
DispatchMouseOrPointerEvent
(
WidgetMouseEvent
*
aMouseEvent
EventMessage
aMessage
nsIContent
*
aTargetContent
nsIContent
*
aRelatedContent
)
;
void
GeneratePointerEnterExit
(
EventMessage
aMessage
WidgetMouseEvent
*
aEvent
)
;
void
GenerateMouseEnterExit
(
WidgetMouseEvent
*
aMouseEvent
)
;
void
NotifyMouseOver
(
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
aContent
)
;
void
NotifyMouseOut
(
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
aMovingInto
)
;
void
GenerateDragDropEnterExit
(
nsPresContext
*
aPresContext
WidgetDragEvent
*
aDragEvent
)
;
OverOutElementsWrapper
*
GetWrapperByEventID
(
WidgetMouseEvent
*
aMouseEvent
)
;
void
FireDragEnterOrExit
(
nsPresContext
*
aPresContext
WidgetDragEvent
*
aDragEvent
EventMessage
aMessage
nsIContent
*
aRelatedTarget
nsIContent
*
aTargetContent
AutoWeakFrame
&
aTargetFrame
)
;
void
UpdateDragDataTransfer
(
WidgetDragEvent
*
dragEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
InitAndDispatchClickEvent
(
WidgetMouseEvent
*
aMouseUpEvent
nsEventStatus
*
aStatus
EventMessage
aMessage
nsIPresShell
*
aPresShell
nsIContent
*
aMouseUpContent
AutoWeakFrame
aCurrentTarget
bool
aNoContentDispatch
nsIContent
*
aOverrideClickTarget
)
;
nsresult
SetClickCount
(
WidgetMouseEvent
*
aEvent
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
=
nullptr
)
;
static
bool
EventCausesClickEvents
(
const
WidgetMouseEvent
&
aMouseEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PostHandleMouseUp
(
WidgetMouseEvent
*
aMouseUpEvent
nsEventStatus
*
aStatus
nsIContent
*
aOverrideClickTarget
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DispatchClickEvents
(
nsIPresShell
*
aPresShell
WidgetMouseEvent
*
aMouseUpEvent
nsEventStatus
*
aStatus
nsIContent
*
aMouseUpContent
nsIContent
*
aOverrideClickTarget
)
;
void
EnsureDocument
(
nsPresContext
*
aPresContext
)
;
void
FlushPendingEvents
(
nsPresContext
*
aPresContext
)
;
typedef
enum
{
eAccessKeyProcessingNormal
=
0
eAccessKeyProcessingUp
eAccessKeyProcessingDown
}
ProcessingAccessKeyState
;
bool
WalkESMTreeToHandleAccessKey
(
WidgetKeyboardEvent
*
aEvent
nsPresContext
*
aPresContext
nsTArray
<
uint32_t
>
&
aAccessCharCodes
nsIDocShellTreeItem
*
aBubbledFrom
ProcessingAccessKeyState
aAccessKeyState
bool
aExecute
)
;
bool
LookForAccessKeyAndExecute
(
nsTArray
<
uint32_t
>
&
aAccessCharCodes
bool
aIsTrustedEvent
bool
aExecute
)
;
nsIContent
*
GetFocusedContent
(
)
;
bool
IsShellVisible
(
nsIDocShell
*
aShell
)
;
class
WheelPrefs
{
public
:
static
WheelPrefs
*
GetInstance
(
)
;
static
void
Shutdown
(
)
;
void
ApplyUserPrefsToDelta
(
WidgetWheelEvent
*
aEvent
)
;
void
GetUserPrefsForEvent
(
const
WidgetWheelEvent
*
aEvent
double
*
aOutMultiplierX
double
*
aOutMultiplierY
)
;
void
CancelApplyingUserPrefsFromOverflowDelta
(
WidgetWheelEvent
*
aEvent
)
;
enum
Action
:
uint8_t
{
ACTION_NONE
=
0
ACTION_SCROLL
ACTION_HISTORY
ACTION_ZOOM
ACTION_HORIZONTALIZED_SCROLL
ACTION_PINCH_ZOOM
ACTION_LAST
=
ACTION_PINCH_ZOOM
ACTION_SEND_TO_PLUGIN
}
;
Action
ComputeActionFor
(
const
WidgetWheelEvent
*
aEvent
)
;
bool
NeedToComputeLineOrPageDelta
(
const
WidgetWheelEvent
*
aEvent
)
;
bool
IsOverOnePageScrollAllowedX
(
const
WidgetWheelEvent
*
aEvent
)
;
bool
IsOverOnePageScrollAllowedY
(
const
WidgetWheelEvent
*
aEvent
)
;
static
bool
WheelEventsEnabledOnPlugins
(
)
;
static
bool
IsAutoDirEnabled
(
)
;
static
bool
HonoursRootForAutoDir
(
)
;
private
:
WheelPrefs
(
)
;
~
WheelPrefs
(
)
;
static
void
OnPrefChanged
(
const
char
*
aPrefName
void
*
aClosure
)
;
enum
Index
{
INDEX_DEFAULT
=
0
INDEX_ALT
INDEX_CONTROL
INDEX_META
INDEX_SHIFT
INDEX_OS
COUNT_OF_MULTIPLIERS
}
;
Index
GetIndexFor
(
const
WidgetWheelEvent
*
aEvent
)
;
void
GetBasePrefName
(
Index
aIndex
nsACString
&
aBasePrefName
)
;
void
Init
(
Index
aIndex
)
;
void
Reset
(
)
;
void
GetMultiplierForDeltaXAndY
(
const
WidgetWheelEvent
*
aEvent
Index
aIndex
double
*
aMultiplierForDeltaX
double
*
aMultiplierForDeltaY
)
;
bool
mInit
[
COUNT_OF_MULTIPLIERS
]
;
double
mMultiplierX
[
COUNT_OF_MULTIPLIERS
]
;
double
mMultiplierY
[
COUNT_OF_MULTIPLIERS
]
;
double
mMultiplierZ
[
COUNT_OF_MULTIPLIERS
]
;
Action
mActions
[
COUNT_OF_MULTIPLIERS
]
;
Action
mOverriddenActionsX
[
COUNT_OF_MULTIPLIERS
]
;
static
WheelPrefs
*
sInstance
;
static
bool
sWheelEventsEnabledOnPlugins
;
static
bool
sIsAutoDirEnabled
;
static
bool
sHonoursRootForAutoDir
;
}
;
enum
DeltaDirection
{
DELTA_DIRECTION_X
=
0
DELTA_DIRECTION_Y
}
;
struct
MOZ_STACK_CLASS
EventState
{
bool
mDefaultPrevented
;
bool
mDefaultPreventedByContent
;
EventState
(
)
:
mDefaultPrevented
(
false
)
mDefaultPreventedByContent
(
false
)
{
}
}
;
void
SendLineScrollEvent
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
EventState
&
aState
int32_t
aDelta
DeltaDirection
aDeltaDirection
)
;
void
SendPixelScrollEvent
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
EventState
&
aState
int32_t
aPixelDelta
DeltaDirection
aDeltaDirection
)
;
enum
{
PREFER_MOUSE_WHEEL_TRANSACTION
=
0x00000001
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_X_AXIS
=
0x00000002
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_Y_AXIS
=
0x00000004
START_FROM_PARENT
=
0x00000008
INCLUDE_PLUGIN_AS_TARGET
=
0x00000010
MAY_BE_ADJUSTED_BY_AUTO_DIR
=
0x00000020
}
;
enum
ComputeScrollTargetOptions
{
COMPUTE_LEGACY_MOUSE_SCROLL_EVENT_TARGET
=
0
COMPUTE_DEFAULT_ACTION_TARGET_EXCEPT_PLUGIN
=
(
PREFER_MOUSE_WHEEL_TRANSACTION
|
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_X_AXIS
|
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_Y_AXIS
)
COMPUTE_DEFAULT_ACTION_TARGET
=
(
COMPUTE_DEFAULT_ACTION_TARGET_EXCEPT_PLUGIN
|
INCLUDE_PLUGIN_AS_TARGET
)
COMPUTE_DEFAULT_ACTION_TARGET_WITH_AUTO_DIR_EXCEPT_PLUGIN
=
(
COMPUTE_DEFAULT_ACTION_TARGET_EXCEPT_PLUGIN
|
MAY_BE_ADJUSTED_BY_AUTO_DIR
)
COMPUTE_DEFAULT_ACTION_TARGET_WITH_AUTO_DIR
=
(
COMPUTE_DEFAULT_ACTION_TARGET
|
MAY_BE_ADJUSTED_BY_AUTO_DIR
)
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_X_AXIS
=
(
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_X_AXIS
|
START_FROM_PARENT
)
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_Y_AXIS
=
(
PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_Y_AXIS
|
START_FROM_PARENT
)
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_X_AXIS_WITH_AUTO_DIR
=
(
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_X_AXIS
|
MAY_BE_ADJUSTED_BY_AUTO_DIR
)
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_Y_AXIS_WITH_AUTO_DIR
=
(
COMPUTE_SCROLLABLE_ANCESTOR_ALONG_Y_AXIS
|
MAY_BE_ADJUSTED_BY_AUTO_DIR
)
}
;
static
ComputeScrollTargetOptions
RemovePluginFromTarget
(
ComputeScrollTargetOptions
aOptions
)
{
switch
(
aOptions
)
{
case
COMPUTE_DEFAULT_ACTION_TARGET
:
return
COMPUTE_DEFAULT_ACTION_TARGET_EXCEPT_PLUGIN
;
case
COMPUTE_DEFAULT_ACTION_TARGET_WITH_AUTO_DIR
:
return
COMPUTE_DEFAULT_ACTION_TARGET_WITH_AUTO_DIR_EXCEPT_PLUGIN
;
default
:
MOZ_ASSERT
(
!
(
aOptions
&
INCLUDE_PLUGIN_AS_TARGET
)
)
;
return
aOptions
;
}
}
nsIFrame
*
ComputeScrollTargetAndMayAdjustWheelEvent
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
ComputeScrollTargetOptions
aOptions
)
;
nsIFrame
*
ComputeScrollTargetAndMayAdjustWheelEvent
(
nsIFrame
*
aTargetFrame
double
aDirectionX
double
aDirectionY
WidgetWheelEvent
*
aEvent
ComputeScrollTargetOptions
aOptions
)
;
nsIFrame
*
ComputeScrollTarget
(
nsIFrame
*
aTargetFrame
WidgetWheelEvent
*
aEvent
ComputeScrollTargetOptions
aOptions
)
{
MOZ_ASSERT
(
!
(
aOptions
&
MAY_BE_ADJUSTED_BY_AUTO_DIR
)
"
aEvent
may
be
modified
by
auto
-
dir
"
)
;
return
ComputeScrollTargetAndMayAdjustWheelEvent
(
aTargetFrame
aEvent
aOptions
)
;
}
nsIFrame
*
ComputeScrollTarget
(
nsIFrame
*
aTargetFrame
double
aDirectionX
double
aDirectionY
WidgetWheelEvent
*
aEvent
ComputeScrollTargetOptions
aOptions
)
{
MOZ_ASSERT
(
!
(
aOptions
&
MAY_BE_ADJUSTED_BY_AUTO_DIR
)
"
aEvent
may
be
modified
by
auto
-
dir
"
)
;
return
ComputeScrollTargetAndMayAdjustWheelEvent
(
aTargetFrame
aDirectionX
aDirectionY
aEvent
aOptions
)
;
}
nsSize
GetScrollAmount
(
nsPresContext
*
aPresContext
WidgetWheelEvent
*
aEvent
nsIScrollableFrame
*
aScrollableFrame
)
;
void
DoScrollText
(
nsIScrollableFrame
*
aScrollableFrame
WidgetWheelEvent
*
aEvent
)
;
void
DoScrollHistory
(
int32_t
direction
)
;
void
DoScrollZoom
(
nsIFrame
*
aTargetFrame
int32_t
adjustment
)
;
nsresult
GetContentViewer
(
nsIContentViewer
*
*
aCv
)
;
nsresult
ChangeTextSize
(
int32_t
change
)
;
nsresult
ChangeFullZoom
(
int32_t
change
)
;
class
DeltaAccumulator
{
public
:
static
DeltaAccumulator
*
GetInstance
(
)
{
if
(
!
sInstance
)
{
sInstance
=
new
DeltaAccumulator
;
}
return
sInstance
;
}
static
void
Shutdown
(
)
{
delete
sInstance
;
sInstance
=
nullptr
;
}
bool
IsInTransaction
(
)
{
return
mHandlingDeltaMode
!
=
UINT32_MAX
;
}
void
InitLineOrPageDelta
(
nsIFrame
*
aTargetFrame
EventStateManager
*
aESM
WidgetWheelEvent
*
aEvent
)
;
void
Reset
(
)
;
nsIntPoint
ComputeScrollAmountForDefaultAction
(
WidgetWheelEvent
*
aEvent
const
nsIntSize
&
aScrollAmountInDevPixels
)
;
private
:
DeltaAccumulator
(
)
:
mX
(
0
.
0
)
mY
(
0
.
0
)
mPendingScrollAmountX
(
0
.
0
)
mPendingScrollAmountY
(
0
.
0
)
mHandlingDeltaMode
(
UINT32_MAX
)
mIsNoLineOrPageDeltaDevice
(
false
)
{
}
double
mX
;
double
mY
;
double
mPendingScrollAmountX
;
double
mPendingScrollAmountY
;
TimeStamp
mLastTime
;
uint32_t
mHandlingDeltaMode
;
bool
mIsNoLineOrPageDeltaDevice
;
static
DeltaAccumulator
*
sInstance
;
}
;
void
DecideGestureEvent
(
WidgetGestureNotifyEvent
*
aEvent
nsIFrame
*
targetFrame
)
;
void
BeginTrackingDragGesture
(
nsPresContext
*
aPresContext
WidgetMouseEvent
*
aDownEvent
nsIFrame
*
aDownFrame
)
;
void
SetGestureDownPoint
(
WidgetGUIEvent
*
aEvent
)
;
LayoutDeviceIntPoint
GetEventRefPoint
(
WidgetEvent
*
aEvent
)
const
;
friend
class
mozilla
:
:
dom
:
:
TabParent
;
void
BeginTrackingRemoteDragGesture
(
nsIContent
*
aContent
)
;
void
StopTrackingDragGesture
(
)
;
void
GenerateDragGesture
(
nsPresContext
*
aPresContext
WidgetInputEvent
*
aEvent
)
;
void
MaybeFirePointerCancel
(
WidgetInputEvent
*
aEvent
)
;
void
DetermineDragTargetAndDefaultData
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aSelectionTarget
dom
:
:
DataTransfer
*
aDataTransfer
dom
:
:
Selection
*
*
aSelection
nsIContent
*
*
aTargetNode
nsIPrincipal
*
*
aPrincipal
)
;
bool
DoDefaultDragStart
(
nsPresContext
*
aPresContext
WidgetDragEvent
*
aDragEvent
dom
:
:
DataTransfer
*
aDataTransfer
nsIContent
*
aDragTarget
dom
:
:
Selection
*
aSelection
nsIPrincipal
*
aPrincipal
)
;
bool
IsTrackingDragGesture
(
)
const
{
return
mGestureDownContent
!
=
nullptr
;
}
void
FillInEventFromGestureDown
(
WidgetMouseEvent
*
aEvent
)
;
nsresult
DoContentCommandEvent
(
WidgetContentCommandEvent
*
aEvent
)
;
nsresult
DoContentCommandScrollEvent
(
WidgetContentCommandEvent
*
aEvent
)
;
dom
:
:
TabParent
*
GetCrossProcessTarget
(
)
;
bool
IsTargetCrossProcess
(
WidgetGUIEvent
*
aEvent
)
;
void
DispatchCrossProcessEvent
(
WidgetEvent
*
aEvent
nsFrameLoader
*
aRemote
nsEventStatus
*
aStatus
)
;
bool
HandleCrossProcessEvent
(
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
;
void
ReleaseCurrentIMEContentObserver
(
)
;
void
HandleQueryContentEvent
(
WidgetQueryContentEvent
*
aEvent
)
;
private
:
void
RemoveNodeFromChainIfNeeded
(
EventStates
aState
nsIContent
*
aContentRemoved
bool
aNotify
)
;
bool
IsEventOutsideDragThreshold
(
WidgetInputEvent
*
aEvent
)
const
;
static
inline
void
DoStateChange
(
dom
:
:
Element
*
aElement
EventStates
aState
bool
aAddState
)
;
static
inline
void
DoStateChange
(
nsIContent
*
aContent
EventStates
aState
bool
aAddState
)
;
static
void
UpdateAncestorState
(
nsIContent
*
aStartNode
nsIContent
*
aStopBefore
EventStates
aState
bool
aAddState
)
;
static
void
ResetLastOverForContent
(
const
uint32_t
&
aIdx
RefPtr
<
OverOutElementsWrapper
>
&
aChunk
nsIContent
*
aClosure
)
;
static
void
UpdateLastRefPointOfMouseEvent
(
WidgetMouseEvent
*
aMouseEvent
)
;
static
void
ResetPointerToWindowCenterWhilePointerLocked
(
WidgetMouseEvent
*
aMouseEvent
)
;
static
void
UpdateLastPointerPosition
(
WidgetMouseEvent
*
aMouseEvent
)
;
void
NotifyTargetUserActivation
(
WidgetEvent
*
aEvent
nsIContent
*
aTargetContent
)
;
already_AddRefed
<
EventStateManager
>
ESMFromContentOrThis
(
nsIContent
*
aContent
)
;
StyleCursorKind
mLockCursor
;
bool
mLastFrameConsumedSetCursor
;
static
LayoutDeviceIntPoint
sPreLockPoint
;
static
LayoutDeviceIntPoint
sSynthCenteringPoint
;
WeakFrame
mCurrentTarget
;
nsCOMPtr
<
nsIContent
>
mCurrentTargetContent
;
static
AutoWeakFrame
sLastDragOverFrame
;
static
LayoutDeviceIntPoint
sLastRefPoint
;
LayoutDeviceIntPoint
mGestureDownPoint
;
nsCOMPtr
<
nsIContent
>
mGestureDownContent
;
nsCOMPtr
<
nsIContent
>
mGestureDownFrameOwner
;
Modifiers
mGestureModifiers
;
uint16_t
mGestureDownButtons
;
nsCOMPtr
<
nsIContent
>
mLastLeftMouseDownContent
;
nsCOMPtr
<
nsIContent
>
mLastMiddleMouseDownContent
;
nsCOMPtr
<
nsIContent
>
mLastRightMouseDownContent
;
nsCOMPtr
<
nsIContent
>
mActiveContent
;
nsCOMPtr
<
nsIContent
>
mHoverContent
;
static
nsCOMPtr
<
nsIContent
>
sDragOverContent
;
nsCOMPtr
<
nsIContent
>
mURLTargetContent
;
nsPresContext
*
mPresContext
;
RefPtr
<
dom
:
:
Document
>
mDocument
;
RefPtr
<
IMEContentObserver
>
mIMEContentObserver
;
uint32_t
mLClickCount
;
uint32_t
mMClickCount
;
uint32_t
mRClickCount
;
bool
mInTouchDrag
;
bool
m_haveShutdown
;
static
TimeStamp
sHandlingInputStart
;
static
TimeStamp
sLatestUserInputStart
;
RefPtr
<
OverOutElementsWrapper
>
mMouseEnterLeaveHelper
;
nsRefPtrHashtable
<
nsUint32HashKey
OverOutElementsWrapper
>
mPointersEnterLeaveHelper
;
public
:
static
nsresult
UpdateUserActivityTimer
(
void
)
;
nsCOMArray
<
nsIContent
>
mAccessKeys
;
static
uint64_t
sUserInputCounter
;
static
int32_t
sUserInputEventDepth
;
static
int32_t
sUserKeyboardEventDepth
;
static
bool
sNormalLMouseEventInProcess
;
static
EventStateManager
*
sActiveESM
;
static
void
ClearGlobalActiveContent
(
EventStateManager
*
aClearer
)
;
nsCOMPtr
<
nsITimer
>
mClickHoldTimer
;
void
CreateClickHoldTimer
(
nsPresContext
*
aPresContext
nsIFrame
*
aDownFrame
WidgetGUIEvent
*
aMouseDownEvent
)
;
void
KillClickHoldTimer
(
)
;
void
FireContextClick
(
)
;
static
void
SetPointerLock
(
nsIWidget
*
aWidget
nsIContent
*
aElement
)
;
static
void
sClickHoldCallback
(
nsITimer
*
aTimer
void
*
aESM
)
;
}
;
class
AutoHandlingUserInputStatePusher
{
public
:
AutoHandlingUserInputStatePusher
(
bool
aIsHandlingUserInput
WidgetEvent
*
aEvent
dom
:
:
Document
*
aDocument
)
;
~
AutoHandlingUserInputStatePusher
(
)
;
protected
:
RefPtr
<
dom
:
:
Document
>
mMouseButtonEventHandlingDocument
;
EventMessage
mMessage
;
bool
mIsHandlingUserInput
;
bool
NeedsToResetFocusManagerMouseButtonHandlingState
(
)
const
{
return
mMessage
=
=
eMouseDown
|
|
mMessage
=
=
eMouseUp
;
}
private
:
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
{
return
nullptr
;
}
static
void
operator
delete
(
void
*
)
{
}
}
;
}
#
define
NS_EVENT_NEEDS_FRAME
(
event
)
\
(
!
(
event
)
-
>
HasPluginActivationEventMessage
(
)
&
&
\
(
event
)
-
>
mMessage
!
=
eMouseClick
&
&
\
(
event
)
-
>
mMessage
!
=
eMouseDoubleClick
&
&
\
(
event
)
-
>
mMessage
!
=
eMouseAuxClick
)
#
endif
