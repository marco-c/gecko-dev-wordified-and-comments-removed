#
ifndef
mozilla_dom_DataTransferItemList_h
#
define
mozilla_dom_DataTransferItemList_h
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferItem
.
h
"
#
include
"
mozilla
/
dom
/
FileList
.
h
"
namespace
mozilla
{
namespace
dom
{
class
DataTransferItem
;
class
DataTransferItemList
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
DataTransferItemList
)
;
explicit
DataTransferItemList
(
DataTransfer
*
aDataTransfer
)
:
mDataTransfer
(
aDataTransfer
)
{
MOZ_ASSERT
(
aDataTransfer
)
;
mIndexedItems
.
SetLength
(
1
)
;
}
already_AddRefed
<
DataTransferItemList
>
Clone
(
DataTransfer
*
aDataTransfer
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
uint32_t
Length
(
)
const
{
return
mItems
.
Length
(
)
;
}
;
DataTransferItem
*
Add
(
const
nsAString
&
aData
const
nsAString
&
aType
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
;
DataTransferItem
*
Add
(
File
&
aData
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
void
Remove
(
uint32_t
aIndex
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
DataTransferItem
*
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
const
;
DataTransfer
*
GetParentObject
(
)
const
{
return
mDataTransfer
;
}
void
Clear
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
already_AddRefed
<
DataTransferItem
>
SetDataWithPrincipal
(
const
nsAString
&
aType
nsIVariant
*
aData
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
bool
aInsertOnly
bool
aHidden
ErrorResult
&
aRv
)
;
already_AddRefed
<
FileList
>
Files
(
nsIPrincipal
*
aPrincipal
)
;
void
MozRemoveByTypeAt
(
const
nsAString
&
aType
uint32_t
aIndex
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
DataTransferItem
*
MozItemByTypeAt
(
const
nsAString
&
aType
uint32_t
aIndex
)
;
const
nsTArray
<
RefPtr
<
DataTransferItem
>
>
*
MozItemsAt
(
uint32_t
aIndex
)
;
uint32_t
MozItemCount
(
)
const
;
void
PopIndexZero
(
)
;
void
ClearAllItems
(
)
;
void
GetTypes
(
nsTArray
<
nsString
>
&
aTypes
CallerType
aCallerType
)
const
;
bool
HasType
(
const
nsAString
&
aType
)
const
;
bool
HasFile
(
)
const
;
private
:
void
ClearDataHelper
(
DataTransferItem
*
aItem
uint32_t
aIndexHint
uint32_t
aMozOffsetHint
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
DataTransferItem
*
AppendNewItem
(
uint32_t
aIndex
const
nsAString
&
aType
nsIVariant
*
aData
nsIPrincipal
*
aPrincipal
bool
aHidden
)
;
void
RegenerateFiles
(
)
;
void
GenerateFiles
(
FileList
*
aFiles
nsIPrincipal
*
aFilesPrincipal
)
;
~
DataTransferItemList
(
)
{
}
RefPtr
<
DataTransfer
>
mDataTransfer
;
RefPtr
<
FileList
>
mFiles
;
nsCOMPtr
<
nsIPrincipal
>
mFilesPrincipal
;
nsTArray
<
RefPtr
<
DataTransferItem
>
>
mItems
;
nsTArray
<
nsTArray
<
RefPtr
<
DataTransferItem
>
>
>
mIndexedItems
;
}
;
}
}
#
endif
