#
ifndef
mozilla_dom_DataTransferItemList_h
#
define
mozilla_dom_DataTransferItemList_h
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferItem
.
h
"
#
include
"
mozilla
/
dom
/
FileList
.
h
"
namespace
mozilla
{
namespace
dom
{
class
DataTransferItem
;
class
DataTransferItemList
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
DataTransferItemList
)
;
DataTransferItemList
(
DataTransfer
*
aParent
bool
aIsExternal
bool
aIsCrossDomainSubFrameDrop
)
:
mParent
(
aParent
)
mIsCrossDomainSubFrameDrop
(
aIsCrossDomainSubFrameDrop
)
mIsExternal
(
aIsExternal
)
{
mIndexedItems
.
SetLength
(
1
)
;
}
already_AddRefed
<
DataTransferItemList
>
Clone
(
DataTransfer
*
aParent
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
uint32_t
Length
(
)
const
{
return
mItems
.
Length
(
)
;
}
;
DataTransferItem
*
Add
(
const
nsAString
&
aData
const
nsAString
&
aType
ErrorResult
&
rv
)
;
DataTransferItem
*
Add
(
File
&
aData
ErrorResult
&
aRv
)
;
void
Remove
(
uint32_t
aIndex
ErrorResult
&
aRv
)
;
DataTransferItem
*
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
ErrorResult
&
aRv
)
const
;
void
Clear
(
ErrorResult
&
aRv
)
;
DataTransfer
*
GetParentObject
(
)
const
{
return
mParent
;
}
bool
IsReadOnly
(
)
const
;
int32_t
ClipboardType
(
)
const
;
EventMessage
GetEventMessage
(
)
const
;
already_AddRefed
<
DataTransferItem
>
SetDataWithPrincipal
(
const
nsAString
&
aType
nsIVariant
*
aData
uint32_t
aIndex
nsIPrincipal
*
aPrincipal
bool
aInsertOnly
ErrorResult
&
aRv
)
;
FileList
*
Files
(
)
;
void
MozRemoveByTypeAt
(
const
nsAString
&
aType
uint32_t
aIndex
ErrorResult
&
aRv
)
;
DataTransferItem
*
MozItemByTypeAt
(
const
nsAString
&
aType
uint32_t
aIndex
)
;
const
nsTArray
<
RefPtr
<
DataTransferItem
>
>
*
MozItemsAt
(
uint32_t
aIndex
)
;
uint32_t
MozItemCount
(
)
const
;
void
PopIndexZero
(
)
;
void
ClearAllItems
(
)
;
private
:
void
ClearDataHelper
(
DataTransferItem
*
aItem
uint32_t
aIndexHint
uint32_t
aMozOffsetHint
ErrorResult
&
aRv
)
;
DataTransferItem
*
AppendNewItem
(
uint32_t
aIndex
const
nsAString
&
aType
nsIVariant
*
aData
nsIPrincipal
*
aPrincipal
)
;
void
RegenerateFiles
(
)
;
~
DataTransferItemList
(
)
{
}
RefPtr
<
DataTransfer
>
mParent
;
bool
mIsCrossDomainSubFrameDrop
;
bool
mIsExternal
;
RefPtr
<
FileList
>
mFiles
;
nsTArray
<
RefPtr
<
DataTransferItem
>
>
mItems
;
nsTArray
<
nsTArray
<
RefPtr
<
DataTransferItem
>
>
>
mIndexedItems
;
}
;
}
}
#
endif
