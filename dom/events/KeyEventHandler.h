#
ifndef
mozilla_KeyEventHandler_h_
#
define
mozilla_KeyEventHandler_h_
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
ShortcutKeys
.
h
"
namespace
mozilla
{
namespace
layers
{
class
KeyboardShortcut
;
}
struct
IgnoreModifierState
;
namespace
dom
{
class
Event
;
class
UIEvent
;
class
Element
;
class
EventTarget
;
class
KeyboardEvent
;
class
Element
;
}
using
namespace
dom
;
enum
ReservedKey
:
uint8_t
{
ReservedKey_False
=
0
ReservedKey_True
=
1
ReservedKey_Unset
=
2
}
;
class
KeyEventHandler
final
{
public
:
explicit
KeyEventHandler
(
Element
*
aHandlerElement
ReservedKey
aReserved
)
;
explicit
KeyEventHandler
(
ShortcutKeyData
*
aKeyData
)
;
~
KeyEventHandler
(
)
;
bool
TryConvertToKeyboardShortcut
(
layers
:
:
KeyboardShortcut
*
aOut
)
const
;
bool
EventTypeEquals
(
nsAtom
*
aEventType
)
const
{
return
mEventName
=
=
aEventType
;
}
bool
KeyEventMatched
(
KeyboardEvent
*
aDomKeyboardEvent
uint32_t
aCharCode
const
IgnoreModifierState
&
aIgnoreModifierState
)
;
already_AddRefed
<
Element
>
GetHandlerElement
(
)
;
ReservedKey
GetIsReserved
(
)
{
return
mReserved
;
}
KeyEventHandler
*
GetNextHandler
(
)
{
return
mNextHandler
;
}
void
SetNextHandler
(
KeyEventHandler
*
aHandler
)
{
mNextHandler
=
aHandler
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
ExecuteHandler
(
EventTarget
*
aTarget
Event
*
aEvent
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
public
:
static
uint32_t
gRefCnt
;
protected
:
void
Init
(
)
{
+
+
gRefCnt
;
if
(
gRefCnt
=
=
1
)
{
InitAccessKeys
(
)
;
}
}
already_AddRefed
<
nsIController
>
GetController
(
EventTarget
*
aTarget
)
;
inline
int32_t
GetMatchingKeyCode
(
const
nsAString
&
aKeyName
)
;
void
ConstructPrototype
(
Element
*
aKeyElement
const
char16_t
*
aEvent
=
nullptr
const
char16_t
*
aCommand
=
nullptr
const
char16_t
*
aKeyCode
=
nullptr
const
char16_t
*
aCharCode
=
nullptr
const
char16_t
*
aModifiers
=
nullptr
)
;
void
BuildModifiers
(
nsAString
&
aModifiers
)
;
void
ReportKeyConflict
(
const
char16_t
*
aKey
const
char16_t
*
aModifiers
Element
*
aKeyElement
const
char
*
aMessageName
)
;
void
GetEventType
(
nsAString
&
aEvent
)
;
bool
ModifiersMatchMask
(
UIEvent
*
aEvent
const
IgnoreModifierState
&
aIgnoreModifierState
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DispatchXBLCommand
(
EventTarget
*
aTarget
Event
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DispatchXULKeyCommand
(
Event
*
aEvent
)
;
Modifiers
GetModifiers
(
)
const
;
Modifiers
GetModifiersMask
(
)
const
;
static
int32_t
KeyToMask
(
int32_t
key
)
;
static
int32_t
AccelKeyMask
(
)
;
static
int32_t
kMenuAccessKey
;
static
void
InitAccessKeys
(
)
;
static
const
int32_t
cShift
;
static
const
int32_t
cAlt
;
static
const
int32_t
cControl
;
static
const
int32_t
cMeta
;
static
const
int32_t
cOS
;
static
const
int32_t
cShiftMask
;
static
const
int32_t
cAltMask
;
static
const
int32_t
cControlMask
;
static
const
int32_t
cMetaMask
;
static
const
int32_t
cOSMask
;
static
const
int32_t
cAllModifiers
;
protected
:
union
{
nsIWeakReference
*
mHandlerElement
;
char16_t
*
mCommand
;
}
;
bool
mIsXULKey
;
uint8_t
mMisc
;
ReservedKey
mReserved
;
int32_t
mKeyMask
;
int32_t
mDetail
;
KeyEventHandler
*
mNextHandler
;
RefPtr
<
nsAtom
>
mEventName
;
}
;
}
#
endif
