#
ifndef
mozilla_dom_StorageDBThread_h
#
define
mozilla_dom_StorageDBThread_h
#
include
"
prthread
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
storage
/
StatementCache
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIThreadInternal
.
h
"
class
mozIStorageConnection
;
namespace
mozilla
{
namespace
dom
{
class
LocalStorageCacheBridge
;
class
StorageUsageBridge
;
class
StorageUsage
;
typedef
mozilla
:
:
storage
:
:
StatementCache
<
mozIStorageStatement
>
StatementCache
;
#
if
0
class
StorageDBBridge
{
public
:
StorageDBBridge
(
)
;
virtual
~
StorageDBBridge
(
)
{
}
virtual
nsresult
Init
(
)
=
0
;
virtual
nsresult
Shutdown
(
)
=
0
;
virtual
void
AsyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aPriority
=
false
)
=
0
;
virtual
void
AsyncGetUsage
(
StorageUsageBridge
*
aUsage
)
=
0
;
virtual
void
SyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aForceSync
=
false
)
=
0
;
virtual
nsresult
AsyncAddItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
=
0
;
virtual
nsresult
AsyncUpdateItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
=
0
;
virtual
nsresult
AsyncRemoveItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
)
=
0
;
virtual
nsresult
AsyncClear
(
LocalStorageCacheBridge
*
aCache
)
=
0
;
virtual
void
AsyncClearAll
(
)
=
0
;
virtual
void
AsyncClearMatchingOrigin
(
const
nsACString
&
aOriginNoSuffix
)
=
0
;
virtual
void
AsyncClearMatchingOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
)
=
0
;
virtual
void
AsyncFlush
(
)
=
0
;
virtual
bool
ShouldPreloadOrigin
(
const
nsACString
&
aOriginNoSuffix
)
=
0
;
}
;
#
endif
class
StorageDBThread
final
{
public
:
class
PendingOperations
;
class
DBOperation
{
public
:
typedef
enum
{
opPreload
opPreloadUrgent
opGetUsage
opAddItem
opUpdateItem
opRemoveItem
opClear
opClearAll
opClearMatchingOrigin
opClearMatchingOriginAttributes
}
OperationType
;
explicit
DBOperation
(
const
OperationType
aType
LocalStorageCacheBridge
*
aCache
=
nullptr
const
nsAString
&
aKey
=
EmptyString
(
)
const
nsAString
&
aValue
=
EmptyString
(
)
)
;
DBOperation
(
const
OperationType
aType
StorageUsageBridge
*
aUsage
)
;
DBOperation
(
const
OperationType
aType
const
nsACString
&
aOriginNoSuffix
)
;
DBOperation
(
const
OperationType
aType
const
OriginAttributesPattern
&
aOriginNoSuffix
)
;
~
DBOperation
(
)
;
void
PerformAndFinalize
(
StorageDBThread
*
aThread
)
;
void
Finalize
(
nsresult
aRv
)
;
OperationType
Type
(
)
const
{
return
mType
;
}
const
nsCString
OriginNoSuffix
(
)
const
;
const
nsCString
OriginSuffix
(
)
const
;
const
nsCString
Origin
(
)
const
;
const
nsCString
Target
(
)
const
;
const
OriginAttributesPattern
&
OriginPattern
(
)
const
{
return
mOriginPattern
;
}
private
:
nsresult
Perform
(
StorageDBThread
*
aThread
)
;
friend
class
PendingOperations
;
OperationType
mType
;
RefPtr
<
LocalStorageCacheBridge
>
mCache
;
RefPtr
<
StorageUsageBridge
>
mUsage
;
nsString
const
mKey
;
nsString
const
mValue
;
nsCString
const
mOrigin
;
OriginAttributesPattern
const
mOriginPattern
;
}
;
class
PendingOperations
{
public
:
PendingOperations
(
)
;
void
Add
(
DBOperation
*
aOperation
)
;
bool
HasTasks
(
)
const
;
bool
Prepare
(
)
;
nsresult
Execute
(
StorageDBThread
*
aThread
)
;
bool
Finalize
(
nsresult
aRv
)
;
bool
IsOriginClearPending
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
const
;
bool
IsOriginUpdatePending
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
const
;
private
:
bool
CheckForCoalesceOpportunity
(
DBOperation
*
aNewOp
DBOperation
:
:
OperationType
aPendingType
DBOperation
:
:
OperationType
aNewType
)
;
nsClassHashtable
<
nsCStringHashKey
DBOperation
>
mClears
;
nsClassHashtable
<
nsCStringHashKey
DBOperation
>
mUpdates
;
nsTArray
<
nsAutoPtr
<
DBOperation
>
>
mExecList
;
uint32_t
mFlushFailureCount
;
}
;
class
ThreadObserver
final
:
public
nsIThreadObserver
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADOBSERVER
ThreadObserver
(
)
:
mHasPendingEvents
(
false
)
mMonitor
(
"
StorageThreadMonitor
"
)
{
}
bool
HasPendingEvents
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mHasPendingEvents
;
}
void
ClearPendingEvents
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mHasPendingEvents
=
false
;
}
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
private
:
virtual
~
ThreadObserver
(
)
{
}
bool
mHasPendingEvents
;
Monitor
mMonitor
;
}
;
class
InitHelper
;
class
NoteBackgroundThreadRunnable
;
class
ShutdownRunnable
:
public
Runnable
{
bool
&
mDone
;
public
:
explicit
ShutdownRunnable
(
bool
&
aDone
)
:
Runnable
(
"
dom
:
:
StorageDBThread
:
:
ShutdownRunnable
"
)
mDone
(
aDone
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
private
:
~
ShutdownRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
public
:
StorageDBThread
(
)
;
virtual
~
StorageDBThread
(
)
{
}
static
StorageDBThread
*
Get
(
)
;
static
StorageDBThread
*
GetOrCreate
(
const
nsString
&
aProfilePath
)
;
static
nsresult
GetProfilePath
(
nsString
&
aProfilePath
)
;
virtual
nsresult
Init
(
const
nsString
&
aProfilePath
)
;
virtual
nsresult
Shutdown
(
)
;
virtual
void
AsyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aPriority
=
false
)
{
InsertDBOp
(
new
DBOperation
(
aPriority
?
DBOperation
:
:
opPreloadUrgent
:
DBOperation
:
:
opPreload
aCache
)
)
;
}
virtual
void
SyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aForce
=
false
)
;
virtual
void
AsyncGetUsage
(
StorageUsageBridge
*
aUsage
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opGetUsage
aUsage
)
)
;
}
virtual
nsresult
AsyncAddItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opAddItem
aCache
aKey
aValue
)
)
;
}
virtual
nsresult
AsyncUpdateItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opUpdateItem
aCache
aKey
aValue
)
)
;
}
virtual
nsresult
AsyncRemoveItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opRemoveItem
aCache
aKey
)
)
;
}
virtual
nsresult
AsyncClear
(
LocalStorageCacheBridge
*
aCache
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClear
aCache
)
)
;
}
virtual
void
AsyncClearAll
(
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClearAll
)
)
;
}
virtual
void
AsyncClearMatchingOrigin
(
const
nsACString
&
aOriginNoSuffix
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClearMatchingOrigin
aOriginNoSuffix
)
)
;
}
virtual
void
AsyncClearMatchingOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClearMatchingOriginAttributes
aPattern
)
)
;
}
virtual
void
AsyncFlush
(
)
;
virtual
bool
ShouldPreloadOrigin
(
const
nsACString
&
aOrigin
)
;
void
GetOriginsHavingData
(
nsTArray
<
nsCString
>
*
aOrigins
)
;
private
:
nsCOMPtr
<
nsIFile
>
mDatabaseFile
;
PRThread
*
mThread
;
RefPtr
<
ThreadObserver
>
mThreadObserver
;
bool
mStopIOThread
;
bool
mWALModeEnabled
;
Atomic
<
bool
ReleaseAcquire
>
mDBReady
;
nsresult
mStatus
;
nsTHashtable
<
nsCStringHashKey
>
mOriginsHavingData
;
nsCOMPtr
<
mozIStorageConnection
>
mWorkerConnection
;
nsCOMPtr
<
mozIStorageConnection
>
mReaderConnection
;
StatementCache
mWorkerStatements
;
StatementCache
mReaderStatements
;
TimeStamp
mDirtyEpoch
;
bool
mFlushImmediately
;
nsTArray
<
DBOperation
*
>
mPreloads
;
PendingOperations
mPendingTasks
;
int32_t
mPriorityCounter
;
nsresult
InsertDBOp
(
DBOperation
*
aOperation
)
;
nsresult
OpenDatabaseConnection
(
)
;
nsresult
OpenAndUpdateDatabase
(
)
;
nsresult
InitDatabase
(
)
;
nsresult
ShutdownDatabase
(
)
;
nsresult
SetJournalMode
(
bool
aIsWal
)
;
nsresult
TryJournalMode
(
)
;
nsresult
ConfigureWALBehavior
(
)
;
void
SetHigherPriority
(
)
;
void
SetDefaultPriority
(
)
;
void
ScheduleFlush
(
)
;
void
UnscheduleFlush
(
)
;
TimeDuration
TimeUntilFlush
(
)
;
void
NotifyFlushCompletion
(
)
;
static
void
ThreadFunc
(
void
*
aArg
)
;
void
ThreadFunc
(
)
;
}
;
}
}
#
endif
