#
include
"
StorageManager
.
h
"
#
include
"
Storage
.
h
"
#
include
"
StorageDBThread
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
define
DEFAULT_QUOTA_LIMIT
(
5
*
1024
)
namespace
mozilla
{
namespace
dom
{
namespace
{
int32_t
gQuotaLimit
=
DEFAULT_QUOTA_LIMIT
;
}
DOMLocalStorageManager
*
DOMLocalStorageManager
:
:
sSelf
=
nullptr
;
uint32_t
StorageManagerBase
:
:
GetQuota
(
)
{
static
bool
preferencesInitialized
=
false
;
if
(
!
preferencesInitialized
)
{
mozilla
:
:
Preferences
:
:
AddIntVarCache
(
&
gQuotaLimit
"
dom
.
storage
.
default_quota
"
DEFAULT_QUOTA_LIMIT
)
;
preferencesInitialized
=
true
;
}
return
gQuotaLimit
*
1024
;
}
void
ReverseString
(
const
nsCSubstring
&
aSource
nsCSubstring
&
aResult
)
{
nsACString
:
:
const_iterator
sourceBegin
sourceEnd
;
aSource
.
BeginReading
(
sourceBegin
)
;
aSource
.
EndReading
(
sourceEnd
)
;
aResult
.
SetLength
(
aSource
.
Length
(
)
)
;
nsACString
:
:
iterator
destEnd
;
aResult
.
EndWriting
(
destEnd
)
;
while
(
sourceBegin
!
=
sourceEnd
)
{
*
(
-
-
destEnd
)
=
*
sourceBegin
;
+
+
sourceBegin
;
}
}
nsresult
CreateReversedDomain
(
const
nsACString
&
aAsciiDomain
nsACString
&
aKey
)
{
if
(
aAsciiDomain
.
IsEmpty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
ReverseString
(
aAsciiDomain
aKey
)
;
aKey
.
Append
(
'
.
'
)
;
return
NS_OK
;
}
bool
PrincipalsEqual
(
nsIPrincipal
*
aObjectPrincipal
nsIPrincipal
*
aSubjectPrincipal
)
{
if
(
!
aSubjectPrincipal
)
{
return
true
;
}
if
(
!
aObjectPrincipal
)
{
return
false
;
}
return
aSubjectPrincipal
-
>
Equals
(
aObjectPrincipal
)
;
}
NS_IMPL_ISUPPORTS
(
StorageManagerBase
nsIDOMStorageManager
)
StorageManagerBase
:
:
StorageManagerBase
(
LocalStorage
:
:
StorageType
aType
)
:
mCaches
(
8
)
mType
(
aType
)
mLowDiskSpace
(
false
)
{
StorageObserver
*
observer
=
StorageObserver
:
:
Self
(
)
;
NS_ASSERTION
(
observer
"
No
StorageObserver
cannot
observe
private
data
delete
notifications
!
"
)
;
if
(
observer
)
{
observer
-
>
AddSink
(
this
)
;
}
}
StorageManagerBase
:
:
~
StorageManagerBase
(
)
{
StorageObserver
*
observer
=
StorageObserver
:
:
Self
(
)
;
if
(
observer
)
{
observer
-
>
RemoveSink
(
this
)
;
}
}
namespace
{
nsresult
AppendOriginNoSuffix
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
uri
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsAutoCString
domainOrigin
;
rv
=
uri
-
>
GetAsciiHost
(
domainOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
domainOrigin
.
IsEmpty
(
)
)
{
bool
isScheme
=
false
;
if
(
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
file
"
&
isScheme
)
)
&
&
isScheme
)
{
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
uri
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
url
-
>
GetDirectory
(
domainOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
nsAutoCString
reverseDomain
;
rv
=
CreateReversedDomain
(
domainOrigin
reverseDomain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aKey
.
Append
(
reverseDomain
)
;
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aKey
.
Append
(
'
:
'
)
;
aKey
.
Append
(
scheme
)
;
int32_t
port
=
NS_GetRealPort
(
uri
)
;
if
(
port
!
=
-
1
)
{
aKey
.
Append
(
nsPrintfCString
(
"
:
%
d
"
port
)
)
;
}
return
NS_OK
;
}
nsresult
CreateQuotaDBKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
{
nsresult
rv
;
nsCOMPtr
<
nsIEffectiveTLDService
>
eTLDService
(
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
uri
NS_ERROR_UNEXPECTED
)
;
nsAutoCString
eTLDplusOne
;
rv
=
eTLDService
-
>
GetBaseDomain
(
uri
0
eTLDplusOne
)
;
if
(
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
=
=
rv
)
{
rv
=
uri
-
>
GetAsciiHost
(
eTLDplusOne
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aKey
.
Truncate
(
)
;
aPrincipal
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
aKey
)
;
nsAutoCString
subdomainsDBKey
;
CreateReversedDomain
(
eTLDplusOne
subdomainsDBKey
)
;
aKey
.
Append
(
'
:
'
)
;
aKey
.
Append
(
subdomainsDBKey
)
;
return
NS_OK
;
}
}
nsCString
StorageManagerBase
:
:
CreateOrigin
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
{
nsAutoCString
scope
;
scope
.
Append
(
aOriginSuffix
)
;
scope
.
Append
(
'
:
'
)
;
scope
.
Append
(
aOriginNoSuffix
)
;
return
scope
;
}
StorageCache
*
StorageManagerBase
:
:
GetCache
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
{
CacheOriginHashtable
*
table
=
mCaches
.
LookupOrAdd
(
aOriginSuffix
)
;
StorageCacheHashKey
*
entry
=
table
-
>
GetEntry
(
aOriginNoSuffix
)
;
if
(
!
entry
)
{
return
nullptr
;
}
return
entry
-
>
cache
(
)
;
}
already_AddRefed
<
StorageUsage
>
StorageManagerBase
:
:
GetOriginUsage
(
const
nsACString
&
aOriginNoSuffix
)
{
RefPtr
<
StorageUsage
>
usage
;
if
(
mUsages
.
Get
(
aOriginNoSuffix
&
usage
)
)
{
return
usage
.
forget
(
)
;
}
usage
=
new
StorageUsage
(
aOriginNoSuffix
)
;
if
(
mType
=
=
eLocalStorage
)
{
StorageDBBridge
*
db
=
StorageCache
:
:
StartDatabase
(
)
;
if
(
db
)
{
db
-
>
AsyncGetUsage
(
usage
)
;
}
}
mUsages
.
Put
(
aOriginNoSuffix
usage
)
;
return
usage
.
forget
(
)
;
}
already_AddRefed
<
StorageCache
>
StorageManagerBase
:
:
PutCache
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
nsIPrincipal
*
aPrincipal
)
{
CacheOriginHashtable
*
table
=
mCaches
.
LookupOrAdd
(
aOriginSuffix
)
;
StorageCacheHashKey
*
entry
=
table
-
>
PutEntry
(
aOriginNoSuffix
)
;
RefPtr
<
StorageCache
>
cache
=
entry
-
>
cache
(
)
;
nsAutoCString
quotaOrigin
;
CreateQuotaDBKey
(
aPrincipal
quotaOrigin
)
;
switch
(
mType
)
{
case
eSessionStorage
:
entry
-
>
HardRef
(
)
;
cache
-
>
Init
(
this
false
aPrincipal
quotaOrigin
)
;
break
;
case
eLocalStorage
:
cache
-
>
Init
(
this
true
aPrincipal
quotaOrigin
)
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
}
return
cache
.
forget
(
)
;
}
void
StorageManagerBase
:
:
DropCache
(
StorageCache
*
aCache
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
StorageManager
:
:
DropCache
called
on
a
non
-
main
thread
shutting
down
?
"
)
;
}
CacheOriginHashtable
*
table
=
mCaches
.
LookupOrAdd
(
aCache
-
>
OriginSuffix
(
)
)
;
table
-
>
RemoveEntry
(
aCache
-
>
OriginNoSuffix
(
)
)
;
}
nsresult
StorageManagerBase
:
:
GetStorageInternal
(
CreateMode
aCreateMode
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
nsresult
rv
;
nsAutoCString
originAttrSuffix
;
aPrincipal
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
originAttrSuffix
)
;
nsAutoCString
originKey
;
rv
=
AppendOriginNoSuffix
(
aPrincipal
originKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
StorageCache
>
cache
=
GetCache
(
originAttrSuffix
originKey
)
;
if
(
!
cache
)
{
if
(
aCreateMode
=
=
CreateMode
:
:
UseIfExistsNeverCreate
)
{
*
aRetval
=
nullptr
;
return
NS_OK
;
}
if
(
aCreateMode
=
=
CreateMode
:
:
CreateIfShouldPreload
)
{
StorageDBBridge
*
db
=
StorageCache
:
:
GetDatabase
(
)
;
if
(
db
)
{
if
(
!
db
-
>
ShouldPreloadOrigin
(
StorageManagerBase
:
:
CreateOrigin
(
originAttrSuffix
originKey
)
)
)
{
return
NS_OK
;
}
}
else
{
if
(
originKey
.
EqualsLiteral
(
"
knalb
.
:
about
"
)
)
{
return
NS_OK
;
}
}
}
cache
=
PutCache
(
originAttrSuffix
originKey
aPrincipal
)
;
}
else
if
(
mType
=
=
eSessionStorage
)
{
if
(
!
cache
-
>
CheckPrincipal
(
aPrincipal
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
}
if
(
aRetval
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
nsPIDOMWindowInner
:
:
From
(
aWindow
)
;
nsCOMPtr
<
nsIDOMStorage
>
storage
=
new
LocalStorage
(
inner
this
cache
aDocumentURI
aPrincipal
aPrivate
)
;
storage
.
forget
(
aRetval
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
StorageManagerBase
:
:
PrecacheStorage
(
nsIPrincipal
*
aPrincipal
nsIDOMStorage
*
*
aRetval
)
{
return
GetStorageInternal
(
CreateMode
:
:
CreateIfShouldPreload
nullptr
aPrincipal
EmptyString
(
)
false
aRetval
)
;
}
NS_IMETHODIMP
StorageManagerBase
:
:
CreateStorage
(
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
return
GetStorageInternal
(
CreateMode
:
:
CreateAlways
aWindow
aPrincipal
aDocumentURI
aPrivate
aRetval
)
;
}
NS_IMETHODIMP
StorageManagerBase
:
:
GetStorage
(
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
return
GetStorageInternal
(
CreateMode
:
:
UseIfExistsNeverCreate
aWindow
aPrincipal
EmptyString
(
)
aPrivate
aRetval
)
;
}
NS_IMETHODIMP
StorageManagerBase
:
:
CloneStorage
(
nsIDOMStorage
*
aStorage
)
{
if
(
mType
!
=
eSessionStorage
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
LocalStorage
>
storage
=
static_cast
<
LocalStorage
*
>
(
aStorage
)
;
if
(
!
storage
)
{
return
NS_ERROR_UNEXPECTED
;
}
const
StorageCache
*
origCache
=
storage
-
>
GetCache
(
)
;
StorageCache
*
existingCache
=
GetCache
(
origCache
-
>
OriginSuffix
(
)
origCache
-
>
OriginNoSuffix
(
)
)
;
if
(
existingCache
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
StorageCache
>
newCache
=
PutCache
(
origCache
-
>
OriginSuffix
(
)
origCache
-
>
OriginNoSuffix
(
)
origCache
-
>
Principal
(
)
)
;
newCache
-
>
CloneFrom
(
origCache
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageManagerBase
:
:
CheckStorage
(
nsIPrincipal
*
aPrincipal
nsIDOMStorage
*
aStorage
bool
*
aRetval
)
{
nsresult
rv
;
RefPtr
<
LocalStorage
>
storage
=
static_cast
<
LocalStorage
*
>
(
aStorage
)
;
if
(
!
storage
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aRetval
=
false
;
if
(
!
aPrincipal
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
suffix
;
aPrincipal
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
suffix
)
;
nsAutoCString
origin
;
rv
=
AppendOriginNoSuffix
(
aPrincipal
origin
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
StorageCache
*
cache
=
GetCache
(
suffix
origin
)
;
if
(
cache
!
=
storage
-
>
GetCache
(
)
)
{
return
NS_OK
;
}
if
(
!
storage
-
>
PrincipalEquals
(
aPrincipal
)
)
{
return
NS_OK
;
}
*
aRetval
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageManagerBase
:
:
GetLocalStorageForPrincipal
(
nsIPrincipal
*
aPrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
if
(
mType
!
=
eLocalStorage
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
CreateStorage
(
nullptr
aPrincipal
aDocumentURI
aPrivate
aRetval
)
;
}
void
StorageManagerBase
:
:
ClearCaches
(
uint32_t
aUnloadFlags
const
OriginAttributesPattern
&
aPattern
const
nsACString
&
aOriginScope
)
{
for
(
auto
iter1
=
mCaches
.
Iter
(
)
;
!
iter1
.
Done
(
)
;
iter1
.
Next
(
)
)
{
OriginAttributes
oa
;
DebugOnly
<
bool
>
rv
=
oa
.
PopulateFromSuffix
(
iter1
.
Key
(
)
)
;
MOZ_ASSERT
(
rv
)
;
if
(
!
aPattern
.
Matches
(
oa
)
)
{
continue
;
}
CacheOriginHashtable
*
table
=
iter1
.
Data
(
)
;
for
(
auto
iter2
=
table
-
>
Iter
(
)
;
!
iter2
.
Done
(
)
;
iter2
.
Next
(
)
)
{
StorageCache
*
cache
=
iter2
.
Get
(
)
-
>
cache
(
)
;
if
(
aOriginScope
.
IsEmpty
(
)
|
|
StringBeginsWith
(
cache
-
>
OriginNoSuffix
(
)
aOriginScope
)
)
{
cache
-
>
UnloadItems
(
aUnloadFlags
)
;
}
}
}
}
nsresult
StorageManagerBase
:
:
Observe
(
const
char
*
aTopic
const
nsAString
&
aOriginAttributesPattern
const
nsACString
&
aOriginScope
)
{
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aOriginAttributesPattern
)
)
{
NS_ERROR
(
"
Cannot
parse
origin
attributes
pattern
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
strcmp
(
aTopic
"
cookie
-
cleared
"
)
)
{
ClearCaches
(
StorageCache
:
:
kUnloadComplete
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
session
-
only
-
cleared
"
)
)
{
ClearCaches
(
StorageCache
:
:
kUnloadSession
pattern
aOriginScope
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
domain
-
data
-
cleared
"
)
)
{
ClearCaches
(
StorageCache
:
:
kUnloadComplete
pattern
aOriginScope
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
private
-
browsing
-
data
-
cleared
"
)
)
{
ClearCaches
(
StorageCache
:
:
kUnloadPrivate
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
origin
-
attr
-
pattern
-
cleared
"
)
)
{
if
(
mType
=
=
eSessionStorage
)
{
return
NS_OK
;
}
ClearCaches
(
StorageCache
:
:
kUnloadComplete
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
profile
-
change
"
)
)
{
ClearCaches
(
StorageCache
:
:
kUnloadComplete
pattern
EmptyCString
(
)
)
;
mCaches
.
Clear
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
low
-
disk
-
space
"
)
)
{
if
(
mType
=
=
eLocalStorage
)
{
mLowDiskSpace
=
true
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
no
-
low
-
disk
-
space
"
)
)
{
if
(
mType
=
=
eLocalStorage
)
{
mLowDiskSpace
=
false
;
}
return
NS_OK
;
}
#
ifdef
DOM_STORAGE_TESTS
if
(
!
strcmp
(
aTopic
"
test
-
reload
"
)
)
{
if
(
mType
!
=
eLocalStorage
)
{
return
NS_OK
;
}
ClearCaches
(
StorageCache
:
:
kTestReload
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
test
-
flushed
"
)
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
domstorage
-
test
-
flushed
"
nullptr
)
;
}
}
return
NS_OK
;
}
#
endif
NS_ERROR
(
"
Unexpected
topic
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
DOMLocalStorageManager
:
:
DOMLocalStorageManager
(
)
:
StorageManagerBase
(
eLocalStorage
)
{
NS_ASSERTION
(
!
sSelf
"
Somebody
is
trying
to
do_CreateInstance
(
\
"
mozilla
/
dom
/
localStorage
-
manager
;
1
\
"
"
)
;
sSelf
=
this
;
if
(
!
XRE_IsParentProcess
(
)
)
{
StorageCache
:
:
StartDatabase
(
)
;
}
}
DOMLocalStorageManager
:
:
~
DOMLocalStorageManager
(
)
{
sSelf
=
nullptr
;
}
DOMLocalStorageManager
*
DOMLocalStorageManager
:
:
Ensure
(
)
{
if
(
sSelf
)
{
return
sSelf
;
}
nsCOMPtr
<
nsIDOMStorageManager
>
initializer
=
do_GetService
(
"
mozilla
.
org
/
dom
/
localStorage
-
manager
;
1
"
)
;
MOZ_ASSERT
(
sSelf
"
Didn
'
t
initialize
?
"
)
;
return
sSelf
;
}
DOMSessionStorageManager
:
:
DOMSessionStorageManager
(
)
:
StorageManagerBase
(
eSessionStorage
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
StorageCache
:
:
StartDatabase
(
)
;
}
}
}
}
