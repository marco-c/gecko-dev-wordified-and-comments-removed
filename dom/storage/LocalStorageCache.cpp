#
include
"
LocalStorageCache
.
h
"
#
include
"
Storage
.
h
"
#
include
"
StorageDBThread
.
h
"
#
include
"
StorageIPC
.
h
"
#
include
"
StorageUtils
.
h
"
#
include
"
LocalStorageManager
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
#
define
DOM_STORAGE_CACHE_KEEP_ALIVE_TIME_MS
20000
StorageDBBridge
*
LocalStorageCache
:
:
sDatabase
=
nullptr
;
bool
LocalStorageCache
:
:
sDatabaseDown
=
false
;
namespace
{
const
uint32_t
kDefaultSet
=
0
;
const
uint32_t
kPrivateSet
=
1
;
const
uint32_t
kSessionSet
=
2
;
inline
uint32_t
GetDataSetIndex
(
bool
aPrivate
bool
aSessionOnly
)
{
if
(
aPrivate
)
{
return
kPrivateSet
;
}
if
(
aSessionOnly
)
{
return
kSessionSet
;
}
return
kDefaultSet
;
}
inline
uint32_t
GetDataSetIndex
(
const
LocalStorage
*
aStorage
)
{
return
GetDataSetIndex
(
aStorage
-
>
IsPrivate
(
)
aStorage
-
>
IsSessionOnly
(
)
)
;
}
}
NS_IMPL_ADDREF
(
LocalStorageCacheBridge
)
NS_IMETHODIMP_
(
void
)
LocalStorageCacheBridge
:
:
Release
(
void
)
{
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
"
dup
release
"
)
;
nsrefcnt
count
=
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
count
"
LocalStorageCacheBridge
"
)
;
if
(
0
=
=
count
)
{
mRefCnt
=
1
;
delete
(
this
)
;
}
}
LocalStorageCache
:
:
LocalStorageCache
(
const
nsACString
*
aOriginNoSuffix
)
:
mOriginNoSuffix
(
*
aOriginNoSuffix
)
mMonitor
(
"
LocalStorageCache
"
)
mLoaded
(
false
)
mLoadResult
(
NS_OK
)
mInitialized
(
false
)
mPersistent
(
false
)
mSessionOnlyDataSetActive
(
false
)
mPreloadTelemetryRecorded
(
false
)
{
MOZ_COUNT_CTOR
(
LocalStorageCache
)
;
}
LocalStorageCache
:
:
~
LocalStorageCache
(
)
{
if
(
mManager
)
{
mManager
-
>
DropCache
(
this
)
;
}
MOZ_COUNT_DTOR
(
LocalStorageCache
)
;
}
NS_IMETHODIMP_
(
void
)
LocalStorageCache
:
:
Release
(
void
)
{
if
(
NS_IsMainThread
(
)
)
{
LocalStorageCacheBridge
:
:
Release
(
)
;
return
;
}
RefPtr
<
nsRunnableMethod
<
LocalStorageCacheBridge
void
false
>
>
event
=
NewNonOwningRunnableMethod
(
"
dom
:
:
LocalStorageCacheBridge
:
:
Release
"
static_cast
<
LocalStorageCacheBridge
*
>
(
this
)
&
LocalStorageCacheBridge
:
:
Release
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
event
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
LocalStorageCache
:
:
Release
(
)
on
a
non
-
main
thread
"
)
;
LocalStorageCacheBridge
:
:
Release
(
)
;
}
}
void
LocalStorageCache
:
:
Init
(
LocalStorageManager
*
aManager
bool
aPersistent
nsIPrincipal
*
aPrincipal
const
nsACString
&
aQuotaOriginScope
)
{
if
(
mInitialized
)
{
return
;
}
mInitialized
=
true
;
aPrincipal
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
mOriginSuffix
)
;
mPersistent
=
aPersistent
;
if
(
aQuotaOriginScope
.
IsEmpty
(
)
)
{
mQuotaOriginScope
=
Origin
(
)
;
}
else
{
mQuotaOriginScope
=
aQuotaOriginScope
;
}
if
(
mPersistent
)
{
mManager
=
aManager
;
Preload
(
)
;
}
MOZ_ASSERT
(
StringBeginsWith
(
mQuotaOriginScope
mOriginSuffix
)
)
;
MOZ_ASSERT
(
mOriginSuffix
.
IsEmpty
(
)
!
=
StringBeginsWith
(
mQuotaOriginScope
NS_LITERAL_CSTRING
(
"
^
"
)
)
)
;
mUsage
=
aManager
-
>
GetOriginUsage
(
mQuotaOriginScope
)
;
}
inline
bool
LocalStorageCache
:
:
Persist
(
const
LocalStorage
*
aStorage
)
const
{
return
mPersistent
&
&
!
aStorage
-
>
IsSessionOnly
(
)
&
&
!
aStorage
-
>
IsPrivate
(
)
;
}
const
nsCString
LocalStorageCache
:
:
Origin
(
)
const
{
return
LocalStorageManager
:
:
CreateOrigin
(
mOriginSuffix
mOriginNoSuffix
)
;
}
LocalStorageCache
:
:
Data
&
LocalStorageCache
:
:
DataSet
(
const
LocalStorage
*
aStorage
)
{
uint32_t
index
=
GetDataSetIndex
(
aStorage
)
;
if
(
index
=
=
kSessionSet
&
&
!
mSessionOnlyDataSetActive
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_SESSIONONLY_PRELOAD_BLOCKING_MS
)
;
Data
&
defaultSet
=
mData
[
kDefaultSet
]
;
Data
&
sessionSet
=
mData
[
kSessionSet
]
;
for
(
auto
iter
=
defaultSet
.
mKeys
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
sessionSet
.
mKeys
.
Put
(
iter
.
Key
(
)
iter
.
UserData
(
)
)
;
}
mSessionOnlyDataSetActive
=
true
;
ProcessUsageDelta
(
kSessionSet
defaultSet
.
mOriginQuotaUsage
)
;
}
return
mData
[
index
]
;
}
bool
LocalStorageCache
:
:
ProcessUsageDelta
(
const
LocalStorage
*
aStorage
int64_t
aDelta
const
MutationSource
aSource
)
{
return
ProcessUsageDelta
(
GetDataSetIndex
(
aStorage
)
aDelta
aSource
)
;
}
bool
LocalStorageCache
:
:
ProcessUsageDelta
(
uint32_t
aGetDataSetIndex
const
int64_t
aDelta
const
MutationSource
aSource
)
{
if
(
aSource
=
=
ContentMutation
&
&
aDelta
>
0
&
&
mManager
&
&
mManager
-
>
IsLowDiskSpace
(
)
)
{
return
false
;
}
Data
&
data
=
mData
[
aGetDataSetIndex
]
;
uint64_t
newOriginUsage
=
data
.
mOriginQuotaUsage
+
aDelta
;
if
(
aSource
=
=
ContentMutation
&
&
aDelta
>
0
&
&
newOriginUsage
>
LocalStorageManager
:
:
GetQuota
(
)
)
{
return
false
;
}
if
(
mUsage
&
&
!
mUsage
-
>
CheckAndSetETLD1UsageDelta
(
aGetDataSetIndex
aDelta
aSource
)
)
{
return
false
;
}
data
.
mOriginQuotaUsage
=
newOriginUsage
;
return
true
;
}
void
LocalStorageCache
:
:
Preload
(
)
{
if
(
mLoaded
|
|
!
mPersistent
)
{
return
;
}
if
(
!
StartDatabase
(
)
)
{
mLoaded
=
true
;
mLoadResult
=
NS_ERROR_FAILURE
;
return
;
}
sDatabase
-
>
AsyncPreload
(
this
)
;
}
namespace
{
class
TelemetryAutoTimer
{
public
:
explicit
TelemetryAutoTimer
(
Telemetry
:
:
HistogramID
aId
)
:
id
(
aId
)
start
(
TimeStamp
:
:
Now
(
)
)
{
}
~
TelemetryAutoTimer
(
)
{
Telemetry
:
:
AccumulateDelta_impl
<
Telemetry
:
:
Millisecond
>
:
:
compute
(
id
start
)
;
}
private
:
Telemetry
:
:
HistogramID
id
;
const
TimeStamp
start
;
}
;
}
void
LocalStorageCache
:
:
WaitForPreload
(
Telemetry
:
:
HistogramID
aTelemetryID
)
{
if
(
!
mPersistent
)
{
return
;
}
bool
loaded
=
mLoaded
;
if
(
!
mPreloadTelemetryRecorded
)
{
mPreloadTelemetryRecorded
=
true
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
LOCALDOMSTORAGE_PRELOAD_PENDING_ON_FIRST_ACCESS
!
loaded
)
;
}
if
(
loaded
)
{
return
;
}
TelemetryAutoTimer
timer
(
aTelemetryID
)
;
sDatabase
-
>
SyncPreload
(
this
)
;
}
nsresult
LocalStorageCache
:
:
GetLength
(
const
LocalStorage
*
aStorage
uint32_t
*
aRetval
)
{
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_GETLENGTH_BLOCKING_MS
)
;
if
(
NS_FAILED
(
mLoadResult
)
)
{
return
mLoadResult
;
}
}
*
aRetval
=
DataSet
(
aStorage
)
.
mKeys
.
Count
(
)
;
return
NS_OK
;
}
nsresult
LocalStorageCache
:
:
GetKey
(
const
LocalStorage
*
aStorage
uint32_t
aIndex
nsAString
&
aRetval
)
{
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_GETKEY_BLOCKING_MS
)
;
if
(
NS_FAILED
(
mLoadResult
)
)
{
return
mLoadResult
;
}
}
aRetval
.
SetIsVoid
(
true
)
;
for
(
auto
iter
=
DataSet
(
aStorage
)
.
mKeys
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
aIndex
=
=
0
)
{
aRetval
=
iter
.
Key
(
)
;
break
;
}
aIndex
-
-
;
}
return
NS_OK
;
}
void
LocalStorageCache
:
:
GetKeys
(
const
LocalStorage
*
aStorage
nsTArray
<
nsString
>
&
aKeys
)
{
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_GETALLKEYS_BLOCKING_MS
)
;
}
if
(
NS_FAILED
(
mLoadResult
)
)
{
return
;
}
for
(
auto
iter
=
DataSet
(
aStorage
)
.
mKeys
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aKeys
.
AppendElement
(
iter
.
Key
(
)
)
;
}
}
nsresult
LocalStorageCache
:
:
GetItem
(
const
LocalStorage
*
aStorage
const
nsAString
&
aKey
nsAString
&
aRetval
)
{
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_GETVALUE_BLOCKING_MS
)
;
if
(
NS_FAILED
(
mLoadResult
)
)
{
return
mLoadResult
;
}
}
nsString
value
;
if
(
!
DataSet
(
aStorage
)
.
mKeys
.
Get
(
aKey
&
value
)
)
{
SetDOMStringToNull
(
value
)
;
}
aRetval
=
value
;
return
NS_OK
;
}
nsresult
LocalStorageCache
:
:
SetItem
(
const
LocalStorage
*
aStorage
const
nsAString
&
aKey
const
nsString
&
aValue
nsString
&
aOld
const
MutationSource
aSource
)
{
int64_t
delta
=
0
;
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_SETVALUE_BLOCKING_MS
)
;
if
(
NS_FAILED
(
mLoadResult
)
)
{
return
mLoadResult
;
}
}
Data
&
data
=
DataSet
(
aStorage
)
;
if
(
!
data
.
mKeys
.
Get
(
aKey
&
aOld
)
)
{
SetDOMStringToNull
(
aOld
)
;
delta
+
=
static_cast
<
int64_t
>
(
aKey
.
Length
(
)
)
;
}
delta
+
=
static_cast
<
int64_t
>
(
aValue
.
Length
(
)
)
-
static_cast
<
int64_t
>
(
aOld
.
Length
(
)
)
;
if
(
!
ProcessUsageDelta
(
aStorage
delta
aSource
)
)
{
return
NS_ERROR_DOM_QUOTA_REACHED
;
}
if
(
aValue
=
=
aOld
&
&
DOMStringIsNull
(
aValue
)
=
=
DOMStringIsNull
(
aOld
)
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
data
.
mKeys
.
Put
(
aKey
aValue
)
;
if
(
aSource
=
=
ContentMutation
&
&
Persist
(
aStorage
)
)
{
if
(
!
sDatabase
)
{
NS_ERROR
(
"
Writing
to
localStorage
after
the
database
has
been
shut
down
"
"
data
lose
!
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
DOMStringIsNull
(
aOld
)
)
{
return
sDatabase
-
>
AsyncAddItem
(
this
aKey
aValue
)
;
}
return
sDatabase
-
>
AsyncUpdateItem
(
this
aKey
aValue
)
;
}
return
NS_OK
;
}
nsresult
LocalStorageCache
:
:
RemoveItem
(
const
LocalStorage
*
aStorage
const
nsAString
&
aKey
nsString
&
aOld
const
MutationSource
aSource
)
{
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_REMOVEKEY_BLOCKING_MS
)
;
if
(
NS_FAILED
(
mLoadResult
)
)
{
return
mLoadResult
;
}
}
Data
&
data
=
DataSet
(
aStorage
)
;
if
(
!
data
.
mKeys
.
Get
(
aKey
&
aOld
)
)
{
SetDOMStringToNull
(
aOld
)
;
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
const
int64_t
delta
=
-
(
static_cast
<
int64_t
>
(
aOld
.
Length
(
)
)
+
static_cast
<
int64_t
>
(
aKey
.
Length
(
)
)
)
;
Unused
<
<
ProcessUsageDelta
(
aStorage
delta
aSource
)
;
data
.
mKeys
.
Remove
(
aKey
)
;
if
(
aSource
=
=
ContentMutation
&
&
Persist
(
aStorage
)
)
{
if
(
!
sDatabase
)
{
NS_ERROR
(
"
Writing
to
localStorage
after
the
database
has
been
shut
down
"
"
data
lose
!
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
sDatabase
-
>
AsyncRemoveItem
(
this
aKey
)
;
}
return
NS_OK
;
}
nsresult
LocalStorageCache
:
:
Clear
(
const
LocalStorage
*
aStorage
const
MutationSource
aSource
)
{
bool
refresh
=
false
;
if
(
Persist
(
aStorage
)
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_CLEAR_BLOCKING_MS
)
;
if
(
NS_FAILED
(
mLoadResult
)
)
{
refresh
=
true
;
mLoadResult
=
NS_OK
;
}
}
Data
&
data
=
DataSet
(
aStorage
)
;
bool
hadData
=
!
!
data
.
mKeys
.
Count
(
)
;
if
(
hadData
)
{
Unused
<
<
ProcessUsageDelta
(
aStorage
-
data
.
mOriginQuotaUsage
aSource
)
;
data
.
mKeys
.
Clear
(
)
;
}
if
(
aSource
=
=
ContentMutation
&
&
Persist
(
aStorage
)
&
&
(
refresh
|
|
hadData
)
)
{
if
(
!
sDatabase
)
{
NS_ERROR
(
"
Writing
to
localStorage
after
the
database
has
been
shut
down
"
"
data
lose
!
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
sDatabase
-
>
AsyncClear
(
this
)
;
}
return
hadData
?
NS_OK
:
NS_SUCCESS_DOM_NO_OPERATION
;
}
int64_t
LocalStorageCache
:
:
GetOriginQuotaUsage
(
const
LocalStorage
*
aStorage
)
const
{
return
mData
[
GetDataSetIndex
(
aStorage
)
]
.
mOriginQuotaUsage
;
}
void
LocalStorageCache
:
:
UnloadItems
(
uint32_t
aUnloadFlags
)
{
if
(
aUnloadFlags
&
kUnloadDefault
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_UNLOAD_BLOCKING_MS
)
;
mData
[
kDefaultSet
]
.
mKeys
.
Clear
(
)
;
ProcessUsageDelta
(
kDefaultSet
-
mData
[
kDefaultSet
]
.
mOriginQuotaUsage
)
;
}
if
(
aUnloadFlags
&
kUnloadPrivate
)
{
mData
[
kPrivateSet
]
.
mKeys
.
Clear
(
)
;
ProcessUsageDelta
(
kPrivateSet
-
mData
[
kPrivateSet
]
.
mOriginQuotaUsage
)
;
}
if
(
aUnloadFlags
&
kUnloadSession
)
{
mData
[
kSessionSet
]
.
mKeys
.
Clear
(
)
;
ProcessUsageDelta
(
kSessionSet
-
mData
[
kSessionSet
]
.
mOriginQuotaUsage
)
;
mSessionOnlyDataSetActive
=
false
;
}
#
ifdef
DOM_STORAGE_TESTS
if
(
aUnloadFlags
&
kTestReload
)
{
WaitForPreload
(
Telemetry
:
:
LOCALDOMSTORAGE_UNLOAD_BLOCKING_MS
)
;
mData
[
kDefaultSet
]
.
mKeys
.
Clear
(
)
;
mLoaded
=
false
;
Preload
(
)
;
}
#
endif
}
uint32_t
LocalStorageCache
:
:
LoadedCount
(
)
{
MonitorAutoLock
monitor
(
mMonitor
)
;
Data
&
data
=
mData
[
kDefaultSet
]
;
return
data
.
mKeys
.
Count
(
)
;
}
bool
LocalStorageCache
:
:
LoadItem
(
const
nsAString
&
aKey
const
nsString
&
aValue
)
{
MonitorAutoLock
monitor
(
mMonitor
)
;
if
(
mLoaded
)
{
return
false
;
}
Data
&
data
=
mData
[
kDefaultSet
]
;
if
(
data
.
mKeys
.
Get
(
aKey
nullptr
)
)
{
return
true
;
}
data
.
mKeys
.
Put
(
aKey
aValue
)
;
data
.
mOriginQuotaUsage
+
=
aKey
.
Length
(
)
+
aValue
.
Length
(
)
;
return
true
;
}
void
LocalStorageCache
:
:
LoadDone
(
nsresult
aRv
)
{
MonitorAutoLock
monitor
(
mMonitor
)
;
mLoadResult
=
aRv
;
mLoaded
=
true
;
monitor
.
Notify
(
)
;
}
void
LocalStorageCache
:
:
LoadWait
(
)
{
MonitorAutoLock
monitor
(
mMonitor
)
;
while
(
!
mLoaded
)
{
monitor
.
Wait
(
)
;
}
}
StorageUsage
:
:
StorageUsage
(
const
nsACString
&
aOriginScope
)
:
mOriginScope
(
aOriginScope
)
{
mUsage
[
kDefaultSet
]
=
mUsage
[
kPrivateSet
]
=
mUsage
[
kSessionSet
]
=
0LL
;
}
namespace
{
class
LoadUsageRunnable
:
public
Runnable
{
public
:
LoadUsageRunnable
(
int64_t
*
aUsage
const
int64_t
aDelta
)
:
Runnable
(
"
dom
:
:
LoadUsageRunnable
"
)
mTarget
(
aUsage
)
mDelta
(
aDelta
)
{
}
private
:
int64_t
*
mTarget
;
int64_t
mDelta
;
NS_IMETHOD
Run
(
)
override
{
*
mTarget
=
mDelta
;
return
NS_OK
;
}
}
;
}
void
StorageUsage
:
:
LoadUsage
(
const
int64_t
aUsage
)
{
if
(
!
NS_IsMainThread
(
)
)
{
RefPtr
<
LoadUsageRunnable
>
r
=
new
LoadUsageRunnable
(
mUsage
+
kDefaultSet
aUsage
)
;
NS_DispatchToMainThread
(
r
)
;
}
else
{
mUsage
[
kDefaultSet
]
+
=
aUsage
;
}
}
bool
StorageUsage
:
:
CheckAndSetETLD1UsageDelta
(
uint32_t
aDataSetIndex
const
int64_t
aDelta
const
LocalStorageCache
:
:
MutationSource
aSource
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
int64_t
newUsage
=
mUsage
[
aDataSetIndex
]
+
aDelta
;
if
(
aSource
=
=
LocalStorageCache
:
:
ContentMutation
&
&
aDelta
>
0
&
&
newUsage
>
LocalStorageManager
:
:
GetQuota
(
)
)
{
return
false
;
}
mUsage
[
aDataSetIndex
]
=
newUsage
;
return
true
;
}
StorageDBBridge
*
LocalStorageCache
:
:
StartDatabase
(
)
{
if
(
sDatabase
|
|
sDatabaseDown
)
{
return
sDatabase
;
}
if
(
XRE_IsParentProcess
(
)
)
{
return
nullptr
;
}
else
{
RefPtr
<
StorageDBChild
>
db
=
new
StorageDBChild
(
LocalStorageManager
:
:
Ensure
(
)
)
;
nsresult
rv
=
db
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
db
.
forget
(
&
sDatabase
)
;
}
return
sDatabase
;
}
StorageDBBridge
*
LocalStorageCache
:
:
GetDatabase
(
)
{
return
sDatabase
;
}
nsresult
LocalStorageCache
:
:
StopDatabase
(
)
{
if
(
!
sDatabase
)
{
return
NS_OK
;
}
sDatabaseDown
=
true
;
nsresult
rv
=
sDatabase
-
>
Shutdown
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
delete
sDatabase
;
}
else
{
StorageDBChild
*
child
=
static_cast
<
StorageDBChild
*
>
(
sDatabase
)
;
NS_RELEASE
(
child
)
;
}
sDatabase
=
nullptr
;
return
rv
;
}
}
}
