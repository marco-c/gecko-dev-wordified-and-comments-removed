#
include
"
LocalStorage
.
h
"
#
include
"
LocalStorageManager
.
h
"
#
include
"
StorageCache
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsICookiePermission
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
PermissionMessageUtils
.
h
"
#
include
"
mozilla
/
dom
/
StorageBinding
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
dom
/
StorageEventBinding
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
LocalStorage
Storage
mManager
)
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
LocalStorage
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END_INHERITING
(
Storage
)
NS_IMPL_ADDREF_INHERITED
(
LocalStorage
Storage
)
NS_IMPL_RELEASE_INHERITED
(
LocalStorage
Storage
)
LocalStorage
:
:
LocalStorage
(
nsPIDOMWindowInner
*
aWindow
LocalStorageManager
*
aManager
StorageCache
*
aCache
const
nsAString
&
aDocumentURI
nsIPrincipal
*
aPrincipal
bool
aIsPrivate
)
:
Storage
(
aWindow
aPrincipal
)
mManager
(
aManager
)
mCache
(
aCache
)
mDocumentURI
(
aDocumentURI
)
mIsPrivate
(
aIsPrivate
)
mIsSessionOnly
(
false
)
{
mCache
-
>
Preload
(
)
;
}
LocalStorage
:
:
~
LocalStorage
(
)
{
}
int64_t
LocalStorage
:
:
GetOriginQuotaUsage
(
)
const
{
return
mCache
-
>
GetOriginQuotaUsage
(
this
)
;
}
uint32_t
LocalStorage
:
:
GetLength
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
0
;
}
uint32_t
length
;
aRv
=
mCache
-
>
GetLength
(
this
&
length
)
;
return
length
;
}
void
LocalStorage
:
:
Key
(
uint32_t
aIndex
nsAString
&
aResult
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
aRv
=
mCache
-
>
GetKey
(
this
aIndex
aResult
)
;
}
void
LocalStorage
:
:
GetItem
(
const
nsAString
&
aKey
nsAString
&
aResult
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
aRv
=
mCache
-
>
GetItem
(
this
aKey
aResult
)
;
}
void
LocalStorage
:
:
SetItem
(
const
nsAString
&
aKey
const
nsAString
&
aData
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsString
data
;
bool
ok
=
data
.
Assign
(
aData
fallible
)
;
if
(
!
ok
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
nsString
old
;
aRv
=
mCache
-
>
SetItem
(
this
aKey
data
old
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
aRv
.
ErrorCodeIs
(
NS_SUCCESS_DOM_NO_OPERATION
)
)
{
BroadcastChangeNotification
(
aKey
old
aData
)
;
}
}
void
LocalStorage
:
:
RemoveItem
(
const
nsAString
&
aKey
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsAutoString
old
;
aRv
=
mCache
-
>
RemoveItem
(
this
aKey
old
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
aRv
.
ErrorCodeIs
(
NS_SUCCESS_DOM_NO_OPERATION
)
)
{
BroadcastChangeNotification
(
aKey
old
NullString
(
)
)
;
}
}
void
LocalStorage
:
:
Clear
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
aRv
=
mCache
-
>
Clear
(
this
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
!
aRv
.
ErrorCodeIs
(
NS_SUCCESS_DOM_NO_OPERATION
)
)
{
BroadcastChangeNotification
(
NullString
(
)
NullString
(
)
NullString
(
)
)
;
}
}
namespace
{
class
StorageNotifierRunnable
:
public
Runnable
{
public
:
StorageNotifierRunnable
(
nsISupports
*
aSubject
bool
aPrivateBrowsing
)
:
Runnable
(
"
StorageNotifierRunnable
"
)
mSubject
(
aSubject
)
mPrivateBrowsing
(
aPrivateBrowsing
)
{
}
NS_DECL_NSIRUNNABLE
private
:
nsCOMPtr
<
nsISupports
>
mSubject
;
const
bool
mPrivateBrowsing
;
}
;
NS_IMETHODIMP
StorageNotifierRunnable
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
mSubject
mPrivateBrowsing
?
"
dom
-
private
-
storage2
-
changed
"
:
"
dom
-
storage2
-
changed
"
u
"
localStorage
"
)
;
}
return
NS_OK
;
}
}
void
LocalStorage
:
:
BroadcastChangeNotification
(
const
nsSubstring
&
aKey
const
nsSubstring
&
aOldValue
const
nsSubstring
&
aNewValue
)
{
if
(
!
XRE_IsParentProcess
(
)
&
&
Principal
(
)
)
{
dom
:
:
ContentChild
*
cc
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
Unused
<
<
NS_WARN_IF
(
!
cc
-
>
SendBroadcastLocalStorageChange
(
mDocumentURI
nsString
(
aKey
)
nsString
(
aOldValue
)
nsString
(
aNewValue
)
IPC
:
:
Principal
(
Principal
(
)
)
mIsPrivate
)
)
;
}
DispatchStorageEvent
(
mDocumentURI
aKey
aOldValue
aNewValue
Principal
(
)
mIsPrivate
this
false
)
;
}
void
LocalStorage
:
:
DispatchStorageEvent
(
const
nsAString
&
aDocumentURI
const
nsAString
&
aKey
const
nsAString
&
aOldValue
const
nsAString
&
aNewValue
nsIPrincipal
*
aPrincipal
bool
aIsPrivate
Storage
*
aStorage
bool
aImmediateDispatch
)
{
StorageEventInit
dict
;
dict
.
mBubbles
=
false
;
dict
.
mCancelable
=
false
;
dict
.
mKey
=
aKey
;
dict
.
mNewValue
=
aNewValue
;
dict
.
mOldValue
=
aOldValue
;
dict
.
mStorageArea
=
aStorage
;
dict
.
mUrl
=
aDocumentURI
;
RefPtr
<
StorageEvent
>
event
=
StorageEvent
:
:
Constructor
(
nullptr
NS_LITERAL_STRING
(
"
storage
"
)
dict
)
;
event
-
>
SetPrincipal
(
aPrincipal
)
;
RefPtr
<
StorageNotifierRunnable
>
r
=
new
StorageNotifierRunnable
(
event
aIsPrivate
)
;
if
(
aImmediateDispatch
)
{
Unused
<
<
r
-
>
Run
(
)
;
}
else
{
NS_DispatchToMainThread
(
r
)
;
}
if
(
XRE_IsParentProcess
(
)
&
&
aPrincipal
)
{
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendDispatchLocalStorageChange
(
nsString
(
aDocumentURI
)
nsString
(
aKey
)
nsString
(
aOldValue
)
nsString
(
aNewValue
)
IPC
:
:
Principal
(
aPrincipal
)
aIsPrivate
)
;
}
}
}
void
LocalStorage
:
:
ApplyEvent
(
StorageEvent
*
aStorageEvent
)
{
MOZ_ASSERT
(
aStorageEvent
)
;
nsAutoString
key
;
nsAutoString
old
;
nsAutoString
value
;
aStorageEvent
-
>
GetKey
(
key
)
;
aStorageEvent
-
>
GetNewValue
(
value
)
;
if
(
key
.
IsVoid
(
)
)
{
MOZ_ASSERT
(
value
.
IsVoid
(
)
)
;
mCache
-
>
Clear
(
this
StorageCache
:
:
E10sPropagated
)
;
return
;
}
if
(
value
.
IsVoid
(
)
)
{
mCache
-
>
RemoveItem
(
this
key
old
StorageCache
:
:
E10sPropagated
)
;
return
;
}
mCache
-
>
SetItem
(
this
key
value
old
StorageCache
:
:
E10sPropagated
)
;
}
static
const
char
kPermissionType
[
]
=
"
cookie
"
;
static
const
char
kStorageEnabled
[
]
=
"
dom
.
storage
.
enabled
"
;
bool
LocalStorage
:
:
CanUseStorage
(
nsIPrincipal
&
aSubjectPrincipal
)
{
if
(
!
mozilla
:
:
Preferences
:
:
GetBool
(
kStorageEnabled
)
)
{
return
false
;
}
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForPrincipal
(
Principal
(
)
)
;
if
(
access
=
=
nsContentUtils
:
:
StorageAccess
:
:
eDeny
)
{
return
false
;
}
mIsSessionOnly
=
access
<
=
nsContentUtils
:
:
StorageAccess
:
:
eSessionScoped
;
return
CanAccess
(
&
aSubjectPrincipal
)
;
}
extern
bool
PrincipalsEqual
(
nsIPrincipal
*
aObjectPrincipal
nsIPrincipal
*
aSubjectPrincipal
)
;
bool
LocalStorage
:
:
PrincipalEquals
(
nsIPrincipal
*
aPrincipal
)
{
return
PrincipalsEqual
(
mPrincipal
aPrincipal
)
;
}
void
LocalStorage
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aKeys
)
{
if
(
!
CanUseStorage
(
*
nsContentUtils
:
:
SubjectPrincipal
(
)
)
)
{
aKeys
.
Clear
(
)
;
return
;
}
mCache
-
>
GetKeys
(
this
aKeys
)
;
}
}
}
