#
ifndef
mozilla_dom_StorageIPC_h
#
define
mozilla_dom_StorageIPC_h
#
include
"
mozilla
/
dom
/
PBackgroundStorageChild
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundStorageParent
.
h
"
#
include
"
StorageDBThread
.
h
"
#
include
"
LocalStorageCache
.
h
"
#
include
"
StorageObserver
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsAutoPtr
.
h
"
namespace
mozilla
{
class
OriginAttributesPattern
;
namespace
dom
{
class
LocalStorageManager
;
class
PBackgroundStorageParent
;
class
StorageDBChild
final
:
public
PBackgroundStorageChild
{
class
ShutdownObserver
;
virtual
~
StorageDBChild
(
)
;
public
:
explicit
StorageDBChild
(
LocalStorageManager
*
aManager
)
;
static
StorageDBChild
*
Get
(
)
;
static
StorageDBChild
*
GetOrCreate
(
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
;
void
AddIPDLReference
(
)
;
void
ReleaseIPDLReference
(
)
;
virtual
nsresult
Init
(
)
;
virtual
nsresult
Shutdown
(
)
;
virtual
void
AsyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aPriority
=
false
)
;
virtual
void
AsyncGetUsage
(
StorageUsageBridge
*
aUsage
)
;
virtual
void
SyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aForceSync
=
false
)
;
virtual
nsresult
AsyncAddItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
;
virtual
nsresult
AsyncUpdateItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
;
virtual
nsresult
AsyncRemoveItem
(
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
)
;
virtual
nsresult
AsyncClear
(
LocalStorageCacheBridge
*
aCache
)
;
virtual
void
AsyncClearAll
(
)
{
if
(
mOriginsHavingData
)
{
mOriginsHavingData
-
>
Clear
(
)
;
}
}
virtual
void
AsyncClearMatchingOrigin
(
const
nsACString
&
aOriginNoSuffix
)
{
MOZ_CRASH
(
"
Shouldn
'
t
be
called
!
"
)
;
}
virtual
void
AsyncClearMatchingOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
)
{
MOZ_CRASH
(
"
Shouldn
'
t
be
called
!
"
)
;
}
virtual
void
AsyncFlush
(
)
{
MOZ_CRASH
(
"
Shouldn
'
t
be
called
!
"
)
;
}
virtual
bool
ShouldPreloadOrigin
(
const
nsACString
&
aOriginNoSuffix
)
;
private
:
mozilla
:
:
ipc
:
:
IPCResult
RecvObserve
(
const
nsCString
&
aTopic
const
nsString
&
aOriginAttributesPattern
const
nsCString
&
aOriginScope
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLoadItem
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
nsString
&
aKey
const
nsString
&
aValue
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLoadDone
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
nsresult
&
aRv
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvOriginsHavingData
(
nsTArray
<
nsCString
>
&
&
aOrigins
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLoadUsage
(
const
nsCString
&
aOriginNoSuffix
const
int64_t
&
aUsage
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvError
(
const
nsresult
&
aRv
)
;
nsTHashtable
<
nsCStringHashKey
>
&
OriginsHavingData
(
)
;
ThreadSafeAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
RefPtr
<
LocalStorageManager
>
mManager
;
nsAutoPtr
<
nsTHashtable
<
nsCStringHashKey
>
>
mOriginsHavingData
;
nsTHashtable
<
nsRefPtrHashKey
<
LocalStorageCacheBridge
>
>
mLoadingCaches
;
nsresult
mStatus
;
bool
mIPCOpen
;
}
;
class
StorageDBParent
final
:
public
PBackgroundStorageParent
{
class
ObserverSink
;
virtual
~
StorageDBParent
(
)
;
public
:
explicit
StorageDBParent
(
const
nsString
&
aProfilePath
)
;
void
Init
(
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
;
void
AddIPDLReference
(
)
;
void
ReleaseIPDLReference
(
)
;
bool
IPCOpen
(
)
{
return
mIPCOpen
;
}
public
:
class
CacheParentBridge
:
public
LocalStorageCacheBridge
{
public
:
CacheParentBridge
(
StorageDBParent
*
aParentDB
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
:
mOwningEventTarget
(
GetCurrentThreadSerialEventTarget
(
)
)
mParent
(
aParentDB
)
mOriginSuffix
(
aOriginSuffix
)
mOriginNoSuffix
(
aOriginNoSuffix
)
mLoaded
(
false
)
mLoadedCount
(
0
)
{
}
virtual
~
CacheParentBridge
(
)
{
}
virtual
const
nsCString
Origin
(
)
const
;
virtual
const
nsCString
&
OriginNoSuffix
(
)
const
{
return
mOriginNoSuffix
;
}
virtual
const
nsCString
&
OriginSuffix
(
)
const
{
return
mOriginSuffix
;
}
virtual
bool
Loaded
(
)
{
return
mLoaded
;
}
virtual
uint32_t
LoadedCount
(
)
{
return
mLoadedCount
;
}
virtual
bool
LoadItem
(
const
nsAString
&
aKey
const
nsString
&
aValue
)
;
virtual
void
LoadDone
(
nsresult
aRv
)
;
virtual
void
LoadWait
(
)
;
NS_IMETHOD_
(
void
)
Release
(
void
)
;
private
:
void
Destroy
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
RefPtr
<
StorageDBParent
>
mParent
;
nsCString
mOriginSuffix
mOriginNoSuffix
;
bool
mLoaded
;
uint32_t
mLoadedCount
;
}
;
class
UsageParentBridge
:
public
StorageUsageBridge
{
public
:
UsageParentBridge
(
StorageDBParent
*
aParentDB
const
nsACString
&
aOriginScope
)
:
mOwningEventTarget
(
GetCurrentThreadSerialEventTarget
(
)
)
mParent
(
aParentDB
)
mOriginScope
(
aOriginScope
)
{
}
virtual
~
UsageParentBridge
(
)
{
}
virtual
const
nsCString
&
OriginScope
(
)
{
return
mOriginScope
;
}
virtual
void
LoadUsage
(
const
int64_t
usage
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
;
private
:
void
Destroy
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
RefPtr
<
StorageDBParent
>
mParent
;
nsCString
mOriginScope
;
}
;
private
:
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncPreload
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
bool
&
aPriority
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPreload
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
uint32_t
&
aAlreadyLoadedCount
InfallibleTArray
<
nsString
>
*
aKeys
InfallibleTArray
<
nsString
>
*
aValues
nsresult
*
aRv
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncGetUsage
(
const
nsCString
&
aOriginNoSuffix
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncAddItem
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
nsString
&
aKey
const
nsString
&
aValue
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncUpdateItem
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
nsString
&
aKey
const
nsString
&
aValue
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncRemoveItem
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
const
nsString
&
aKey
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncClear
(
const
nsCString
&
aOriginSuffix
const
nsCString
&
aOriginNoSuffix
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAsyncFlush
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvStartup
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvClearAll
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvClearMatchingOrigin
(
const
nsCString
&
aOriginNoSuffix
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvClearMatchingOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
)
override
;
void
Observe
(
const
nsCString
&
aTopic
const
nsString
&
aOriginAttrPattern
const
nsCString
&
aOriginScope
)
;
private
:
CacheParentBridge
*
NewCache
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
;
RefPtr
<
ObserverSink
>
mObserverSink
;
nsString
mProfilePath
;
ThreadSafeAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
bool
mIPCOpen
;
}
;
PBackgroundStorageParent
*
AllocPBackgroundStorageParent
(
const
nsString
&
aProfilePath
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPBackgroundStorageConstructor
(
PBackgroundStorageParent
*
aActor
const
nsString
&
aProfilePath
)
;
bool
DeallocPBackgroundStorageParent
(
PBackgroundStorageParent
*
aActor
)
;
}
}
#
endif
