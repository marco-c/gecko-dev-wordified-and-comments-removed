#
include
"
StorageDBThread
.
h
"
#
include
"
StorageDBUpdater
.
h
"
#
include
"
StorageUtils
.
h
"
#
include
"
LocalStorageCache
.
h
"
#
include
"
LocalStorageManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
mozStorageCID
.
h
"
#
include
"
mozStorageHelper
.
h
"
#
include
"
mozIStorageService
.
h
"
#
include
"
mozIStorageBindingParamsArray
.
h
"
#
include
"
mozIStorageBindingParams
.
h
"
#
include
"
mozIStorageValueArray
.
h
"
#
include
"
mozIStorageFunction
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
IOInterposer
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
define
FLUSHING_INTERVAL_MS
5000
#
define
MAX_WAL_SIZE_BYTES
512
*
1024
#
define
CURRENT_SCHEMA_VERSION
2
namespace
mozilla
{
namespace
dom
{
using
namespace
StorageUtils
;
namespace
{
StorageDBThread
*
sStorageThread
=
nullptr
;
bool
sStorageThreadDown
=
false
;
}
#
if
0
StorageDBBridge
:
:
StorageDBBridge
(
)
{
}
#
endif
class
StorageDBThread
:
:
InitHelper
final
:
public
Runnable
{
nsCOMPtr
<
nsIEventTarget
>
mOwningThread
;
mozilla
:
:
Mutex
mMutex
;
mozilla
:
:
CondVar
mCondVar
;
nsString
mProfilePath
;
nsresult
mMainThreadResultCode
;
bool
mWaiting
;
public
:
InitHelper
(
)
:
Runnable
(
"
dom
:
:
StorageDBThread
:
:
InitHelper
"
)
mOwningThread
(
GetCurrentThreadEventTarget
(
)
)
mMutex
(
"
InitHelper
:
:
mMutex
"
)
mCondVar
(
mMutex
"
InitHelper
:
:
mCondVar
"
)
mMainThreadResultCode
(
NS_OK
)
mWaiting
(
true
)
{
}
nsresult
SyncDispatchAndReturnProfilePath
(
nsAString
&
aProfilePath
)
;
private
:
~
InitHelper
(
)
override
=
default
;
nsresult
RunOnMainThread
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
StorageDBThread
:
:
NoteBackgroundThreadRunnable
final
:
public
Runnable
{
nsCOMPtr
<
nsIEventTarget
>
mOwningThread
;
public
:
NoteBackgroundThreadRunnable
(
)
:
Runnable
(
"
dom
:
:
StorageDBThread
:
:
NoteBackgroundThreadRunnable
"
)
mOwningThread
(
GetCurrentThreadEventTarget
(
)
)
{
}
private
:
~
NoteBackgroundThreadRunnable
(
)
override
=
default
;
NS_DECL_NSIRUNNABLE
}
;
StorageDBThread
:
:
StorageDBThread
(
)
:
mThread
(
nullptr
)
mThreadObserver
(
new
ThreadObserver
(
)
)
mStopIOThread
(
false
)
mWALModeEnabled
(
false
)
mDBReady
(
false
)
mStatus
(
NS_OK
)
mWorkerStatements
(
mWorkerConnection
)
mReaderStatements
(
mReaderConnection
)
mFlushImmediately
(
false
)
mPriorityCounter
(
0
)
{
}
StorageDBThread
*
StorageDBThread
:
:
Get
(
)
{
AssertIsOnBackgroundThread
(
)
;
return
sStorageThread
;
}
StorageDBThread
*
StorageDBThread
:
:
GetOrCreate
(
const
nsString
&
aProfilePath
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
sStorageThread
|
|
sStorageThreadDown
)
{
return
sStorageThread
;
}
nsAutoPtr
<
StorageDBThread
>
storageThread
(
new
StorageDBThread
(
)
)
;
nsresult
rv
=
storageThread
-
>
Init
(
aProfilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
sStorageThread
=
storageThread
.
forget
(
)
;
return
sStorageThread
;
}
nsresult
StorageDBThread
:
:
GetProfilePath
(
nsString
&
aProfilePath
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIFile
>
profileDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profileDir
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
profileDir
-
>
GetPath
(
aProfilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageService
>
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
Init
(
const
nsString
&
aProfilePath
)
{
AssertIsOnBackgroundThread
(
)
;
nsresult
rv
;
nsString
profilePath
;
if
(
aProfilePath
.
IsEmpty
(
)
)
{
RefPtr
<
InitHelper
>
helper
=
new
InitHelper
(
)
;
rv
=
helper
-
>
SyncDispatchAndReturnProfilePath
(
profilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
profilePath
=
aProfilePath
;
}
mDatabaseFile
=
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mDatabaseFile
-
>
InitWithPath
(
profilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mDatabaseFile
-
>
Append
(
NS_LITERAL_STRING
(
"
webappsstore
.
sqlite
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
mThread
=
PR_CreateThread
(
PR_USER_THREAD
&
StorageDBThread
:
:
ThreadFunc
this
PR_PRIORITY_LOW
PR_GLOBAL_THREAD
PR_JOINABLE_THREAD
262144
)
;
if
(
!
mThread
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
RefPtr
<
NoteBackgroundThreadRunnable
>
runnable
=
new
NoteBackgroundThreadRunnable
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
runnable
)
)
;
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
Shutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
sStorageThreadDown
=
true
;
if
(
!
mThread
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
LOCALDOMSTORAGE_SHUTDOWN_DATABASE_MS
>
timer
;
{
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
mFlushImmediately
=
true
;
mStopIOThread
=
true
;
monitor
.
Notify
(
)
;
}
PR_JoinThread
(
mThread
)
;
mThread
=
nullptr
;
return
mStatus
;
}
void
StorageDBThread
:
:
SyncPreload
(
LocalStorageCacheBridge
*
aCache
bool
aForceSync
)
{
AUTO_PROFILER_LABEL
(
"
StorageDBThread
:
:
SyncPreload
"
OTHER
)
;
if
(
!
aForceSync
&
&
aCache
-
>
LoadedCount
(
)
)
{
SetHigherPriority
(
)
;
aCache
-
>
LoadWait
(
)
;
SetDefaultPriority
(
)
;
return
;
}
if
(
mDBReady
&
&
mWALModeEnabled
)
{
bool
pendingTasks
;
{
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
pendingTasks
=
mPendingTasks
.
IsOriginUpdatePending
(
aCache
-
>
OriginSuffix
(
)
aCache
-
>
OriginNoSuffix
(
)
)
|
|
mPendingTasks
.
IsOriginClearPending
(
aCache
-
>
OriginSuffix
(
)
aCache
-
>
OriginNoSuffix
(
)
)
;
}
if
(
!
pendingTasks
)
{
DBOperation
preload
(
DBOperation
:
:
opPreload
aCache
)
;
preload
.
PerformAndFinalize
(
this
)
;
return
;
}
}
nsresult
rv
=
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opPreloadUrgent
aCache
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aCache
-
>
LoadWait
(
)
;
}
}
void
StorageDBThread
:
:
AsyncFlush
(
)
{
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
mFlushImmediately
=
true
;
monitor
.
Notify
(
)
;
}
bool
StorageDBThread
:
:
ShouldPreloadOrigin
(
const
nsACString
&
aOrigin
)
{
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
return
mOriginsHavingData
.
Contains
(
aOrigin
)
;
}
void
StorageDBThread
:
:
GetOriginsHavingData
(
nsTArray
<
nsCString
>
*
aOrigins
)
{
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
for
(
auto
iter
=
mOriginsHavingData
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aOrigins
-
>
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
}
nsresult
StorageDBThread
:
:
InsertDBOp
(
StorageDBThread
:
:
DBOperation
*
aOperation
)
{
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
nsAutoPtr
<
StorageDBThread
:
:
DBOperation
>
opScope
(
aOperation
)
;
if
(
NS_FAILED
(
mStatus
)
)
{
MonitorAutoUnlock
unlock
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
aOperation
-
>
Finalize
(
mStatus
)
;
return
mStatus
;
}
if
(
mStopIOThread
)
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
switch
(
aOperation
-
>
Type
(
)
)
{
case
DBOperation
:
:
opPreload
:
case
DBOperation
:
:
opPreloadUrgent
:
if
(
mPendingTasks
.
IsOriginUpdatePending
(
aOperation
-
>
OriginSuffix
(
)
aOperation
-
>
OriginNoSuffix
(
)
)
)
{
mFlushImmediately
=
true
;
}
else
if
(
mPendingTasks
.
IsOriginClearPending
(
aOperation
-
>
OriginSuffix
(
)
aOperation
-
>
OriginNoSuffix
(
)
)
)
{
MonitorAutoUnlock
unlock
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
aOperation
-
>
Finalize
(
NS_OK
)
;
return
NS_OK
;
}
MOZ_FALLTHROUGH
;
case
DBOperation
:
:
opGetUsage
:
if
(
aOperation
-
>
Type
(
)
=
=
DBOperation
:
:
opPreloadUrgent
)
{
SetHigherPriority
(
)
;
mPreloads
.
InsertElementAt
(
0
aOperation
)
;
}
else
{
mPreloads
.
AppendElement
(
aOperation
)
;
}
opScope
.
forget
(
)
;
monitor
.
Notify
(
)
;
break
;
default
:
mPendingTasks
.
Add
(
aOperation
)
;
opScope
.
forget
(
)
;
ScheduleFlush
(
)
;
break
;
}
return
NS_OK
;
}
void
StorageDBThread
:
:
SetHigherPriority
(
)
{
+
+
mPriorityCounter
;
PR_SetThreadPriority
(
mThread
PR_PRIORITY_URGENT
)
;
}
void
StorageDBThread
:
:
SetDefaultPriority
(
)
{
if
(
-
-
mPriorityCounter
<
=
0
)
{
PR_SetThreadPriority
(
mThread
PR_PRIORITY_LOW
)
;
}
}
void
StorageDBThread
:
:
ThreadFunc
(
void
*
aArg
)
{
{
auto
queue
=
MakeRefPtr
<
ThreadEventQueue
<
EventQueue
>
>
(
MakeUnique
<
EventQueue
>
(
)
)
;
Unused
<
<
nsThreadManager
:
:
get
(
)
.
CreateCurrentThread
(
queue
nsThread
:
:
NOT_MAIN_THREAD
)
;
}
AUTO_PROFILER_REGISTER_THREAD
(
"
localStorage
DB
"
)
;
NS_SetCurrentThreadName
(
"
localStorage
DB
"
)
;
mozilla
:
:
IOInterposer
:
:
RegisterCurrentThread
(
)
;
StorageDBThread
*
thread
=
static_cast
<
StorageDBThread
*
>
(
aArg
)
;
thread
-
>
ThreadFunc
(
)
;
mozilla
:
:
IOInterposer
:
:
UnregisterCurrentThread
(
)
;
}
void
StorageDBThread
:
:
ThreadFunc
(
)
{
nsresult
rv
=
InitDatabase
(
)
;
MonitorAutoLock
lockMonitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStatus
=
rv
;
mStopIOThread
=
true
;
return
;
}
nsCOMPtr
<
nsIThread
>
thread
=
NS_GetCurrentThread
(
)
;
nsCOMPtr
<
nsIThreadInternal
>
threadInternal
=
do_QueryInterface
(
thread
)
;
MOZ_ASSERT
(
threadInternal
)
;
threadInternal
-
>
SetObserver
(
mThreadObserver
)
;
while
(
MOZ_LIKELY
(
!
mStopIOThread
|
|
mPreloads
.
Length
(
)
|
|
mPendingTasks
.
HasTasks
(
)
|
|
mThreadObserver
-
>
HasPendingEvents
(
)
)
)
{
while
(
MOZ_UNLIKELY
(
mThreadObserver
-
>
HasPendingEvents
(
)
)
)
{
mThreadObserver
-
>
ClearPendingEvents
(
)
;
MonitorAutoUnlock
unlock
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
bool
processedEvent
;
do
{
rv
=
thread
-
>
ProcessNextEvent
(
false
&
processedEvent
)
;
}
while
(
NS_SUCCEEDED
(
rv
)
&
&
processedEvent
)
;
}
TimeDuration
timeUntilFlush
=
TimeUntilFlush
(
)
;
if
(
MOZ_UNLIKELY
(
timeUntilFlush
.
IsZero
(
)
)
)
{
UnscheduleFlush
(
)
;
if
(
mPendingTasks
.
Prepare
(
)
)
{
{
MonitorAutoUnlock
unlockMonitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
rv
=
mPendingTasks
.
Execute
(
this
)
;
}
if
(
!
mPendingTasks
.
Finalize
(
rv
)
)
{
mStatus
=
rv
;
NS_WARNING
(
"
localStorage
DB
access
broken
"
)
;
}
}
NotifyFlushCompletion
(
)
;
}
else
if
(
MOZ_LIKELY
(
mPreloads
.
Length
(
)
)
)
{
nsAutoPtr
<
DBOperation
>
op
(
mPreloads
[
0
]
)
;
mPreloads
.
RemoveElementAt
(
0
)
;
{
MonitorAutoUnlock
unlockMonitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
op
-
>
PerformAndFinalize
(
this
)
;
}
if
(
op
-
>
Type
(
)
=
=
DBOperation
:
:
opPreloadUrgent
)
{
SetDefaultPriority
(
)
;
}
}
else
if
(
MOZ_UNLIKELY
(
!
mStopIOThread
)
)
{
AUTO_PROFILER_LABEL
(
"
StorageDBThread
:
:
ThreadFunc
:
:
Wait
"
IDLE
)
;
AUTO_PROFILER_THREAD_SLEEP
;
lockMonitor
.
Wait
(
timeUntilFlush
)
;
}
}
mStatus
=
ShutdownDatabase
(
)
;
if
(
threadInternal
)
{
threadInternal
-
>
SetObserver
(
nullptr
)
;
}
}
NS_IMPL_ISUPPORTS
(
StorageDBThread
:
:
ThreadObserver
nsIThreadObserver
)
NS_IMETHODIMP
StorageDBThread
:
:
ThreadObserver
:
:
OnDispatchedEvent
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mHasPendingEvents
=
true
;
lock
.
Notify
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageDBThread
:
:
ThreadObserver
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
mayWait
)
{
return
NS_OK
;
}
NS_IMETHODIMP
StorageDBThread
:
:
ThreadObserver
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
eventWasProcessed
)
{
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
OpenDatabaseConnection
(
)
{
nsresult
rv
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageService
>
service
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
service
-
>
OpenUnsharedDatabase
(
mDatabaseFile
getter_AddRefs
(
mWorkerConnection
)
)
;
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
rv
=
mDatabaseFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
service
-
>
OpenUnsharedDatabase
(
mDatabaseFile
getter_AddRefs
(
mWorkerConnection
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
OpenAndUpdateDatabase
(
)
{
nsresult
rv
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
rv
=
OpenDatabaseConnection
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
TryJournalMode
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
InitDatabase
(
)
{
nsresult
rv
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
rv
=
OpenAndUpdateDatabase
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
StorageDBUpdater
:
:
Update
(
mWorkerConnection
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
mWorkerConnection
-
>
Close
(
)
;
mWorkerConnection
=
nullptr
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mDatabaseFile
-
>
Remove
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
OpenAndUpdateDatabase
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
(
void
)
mWorkerConnection
-
>
Clone
(
true
getter_AddRefs
(
mReaderConnection
)
)
;
NS_ENSURE_TRUE
(
mReaderConnection
NS_ERROR_FAILURE
)
;
mDBReady
=
true
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mWorkerConnection
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
"
SELECT
DISTINCT
originAttributes
|
|
'
:
'
|
|
originKey
"
"
FROM
webappsstore2
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
bool
exists
;
while
(
NS_SUCCEEDED
(
rv
=
stmt
-
>
ExecuteStep
(
&
exists
)
)
&
&
exists
)
{
nsAutoCString
foundOrigin
;
rv
=
stmt
-
>
GetUTF8String
(
0
foundOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MonitorAutoLock
monitor
(
mThreadObserver
-
>
GetMonitor
(
)
)
;
mOriginsHavingData
.
PutEntry
(
foundOrigin
)
;
}
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
SetJournalMode
(
bool
aIsWal
)
{
nsresult
rv
;
nsAutoCString
stmtString
(
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
PRAGMA
journal_mode
=
"
)
;
if
(
aIsWal
)
{
stmtString
.
AppendLiteral
(
"
wal
"
)
;
}
else
{
stmtString
.
AppendLiteral
(
"
truncate
"
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
mWorkerConnection
-
>
CreateStatement
(
stmtString
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
bool
hasResult
=
false
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
hasResult
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
journalMode
;
rv
=
stmt
-
>
GetUTF8String
(
0
journalMode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
(
aIsWal
&
&
!
journalMode
.
EqualsLiteral
(
"
wal
"
)
)
|
|
(
!
aIsWal
&
&
!
journalMode
.
EqualsLiteral
(
"
truncate
"
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
TryJournalMode
(
)
{
nsresult
rv
;
rv
=
SetJournalMode
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
mWALModeEnabled
=
false
;
rv
=
SetJournalMode
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
mWALModeEnabled
=
true
;
rv
=
ConfigureWALBehavior
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
ConfigureWALBehavior
(
)
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
mWorkerConnection
-
>
CreateStatement
(
NS_LITERAL_CSTRING
(
MOZ_STORAGE_UNIQUIFY_QUERY_STR
"
PRAGMA
page_size
"
)
getter_AddRefs
(
stmt
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
hasResult
=
false
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
NS_ENSURE_TRUE
(
NS_SUCCEEDED
(
rv
)
&
&
hasResult
NS_ERROR_FAILURE
)
;
int32_t
pageSize
=
0
;
rv
=
stmt
-
>
GetInt32
(
0
&
pageSize
)
;
NS_ENSURE_TRUE
(
NS_SUCCEEDED
(
rv
)
&
&
pageSize
>
0
NS_ERROR_UNEXPECTED
)
;
int32_t
thresholdInPages
=
static_cast
<
int32_t
>
(
MAX_WAL_SIZE_BYTES
/
pageSize
)
;
nsAutoCString
thresholdPragma
(
"
PRAGMA
wal_autocheckpoint
=
"
)
;
thresholdPragma
.
AppendInt
(
thresholdInPages
)
;
rv
=
mWorkerConnection
-
>
ExecuteSimpleSQL
(
thresholdPragma
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
journalSizePragma
(
"
PRAGMA
journal_size_limit
=
"
)
;
journalSizePragma
.
AppendInt
(
MAX_WAL_SIZE_BYTES
*
3
)
;
rv
=
mWorkerConnection
-
>
ExecuteSimpleSQL
(
journalSizePragma
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
StorageDBThread
:
:
ShutdownDatabase
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
mStatus
;
mDBReady
=
false
;
mReaderStatements
.
FinalizeStatements
(
)
;
mWorkerStatements
.
FinalizeStatements
(
)
;
if
(
mReaderConnection
)
{
mReaderConnection
-
>
Close
(
)
;
mReaderConnection
=
nullptr
;
}
if
(
mWorkerConnection
)
{
rv
=
mWorkerConnection
-
>
Close
(
)
;
mWorkerConnection
=
nullptr
;
}
return
rv
;
}
void
StorageDBThread
:
:
ScheduleFlush
(
)
{
if
(
mDirtyEpoch
)
{
return
;
}
mDirtyEpoch
=
TimeStamp
:
:
Now
(
)
;
(
mThreadObserver
-
>
GetMonitor
(
)
)
.
Notify
(
)
;
}
void
StorageDBThread
:
:
UnscheduleFlush
(
)
{
mFlushImmediately
=
false
;
mDirtyEpoch
=
TimeStamp
(
)
;
}
TimeDuration
StorageDBThread
:
:
TimeUntilFlush
(
)
{
if
(
mFlushImmediately
)
{
return
0
;
}
if
(
!
mDirtyEpoch
)
{
return
TimeDuration
:
:
Forever
(
)
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
age
=
now
-
mDirtyEpoch
;
static
const
TimeDuration
kMaxAge
=
TimeDuration
:
:
FromMilliseconds
(
FLUSHING_INTERVAL_MS
)
;
if
(
age
>
kMaxAge
)
{
return
0
;
}
return
kMaxAge
-
age
;
}
void
StorageDBThread
:
:
NotifyFlushCompletion
(
)
{
#
ifdef
DOM_STORAGE_TESTS
if
(
!
NS_IsMainThread
(
)
)
{
RefPtr
<
nsRunnableMethod
<
StorageDBThread
void
false
>
>
event
=
NewNonOwningRunnableMethod
(
"
dom
:
:
StorageDBThread
:
:
NotifyFlushCompletion
"
this
&
StorageDBThread
:
:
NotifyFlushCompletion
)
;
NS_DispatchToMainThread
(
event
)
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
domstorage
-
test
-
flushed
"
nullptr
)
;
}
#
endif
}
namespace
{
class
OriginAttrsPatternMatchSQLFunction
final
:
public
mozIStorageFunction
{
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
explicit
OriginAttrsPatternMatchSQLFunction
(
OriginAttributesPattern
const
&
aPattern
)
:
mPattern
(
aPattern
)
{
}
private
:
OriginAttrsPatternMatchSQLFunction
(
)
=
delete
;
~
OriginAttrsPatternMatchSQLFunction
(
)
{
}
OriginAttributesPattern
mPattern
;
}
;
NS_IMPL_ISUPPORTS
(
OriginAttrsPatternMatchSQLFunction
mozIStorageFunction
)
NS_IMETHODIMP
OriginAttrsPatternMatchSQLFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
nsresult
rv
;
nsAutoCString
suffix
;
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
suffix
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
oa
;
bool
success
=
oa
.
PopulateFromSuffix
(
suffix
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_FAILURE
)
;
bool
result
=
mPattern
.
Matches
(
oa
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsBool
(
result
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
}
StorageDBThread
:
:
DBOperation
:
:
DBOperation
(
const
OperationType
aType
LocalStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
:
mType
(
aType
)
mCache
(
aCache
)
mKey
(
aKey
)
mValue
(
aValue
)
{
MOZ_ASSERT
(
mType
=
=
opPreload
|
|
mType
=
=
opPreloadUrgent
|
|
mType
=
=
opAddItem
|
|
mType
=
=
opUpdateItem
|
|
mType
=
=
opRemoveItem
|
|
mType
=
=
opClear
|
|
mType
=
=
opClearAll
)
;
MOZ_COUNT_CTOR
(
StorageDBThread
:
:
DBOperation
)
;
}
StorageDBThread
:
:
DBOperation
:
:
DBOperation
(
const
OperationType
aType
StorageUsageBridge
*
aUsage
)
:
mType
(
aType
)
mUsage
(
aUsage
)
{
MOZ_ASSERT
(
mType
=
=
opGetUsage
)
;
MOZ_COUNT_CTOR
(
StorageDBThread
:
:
DBOperation
)
;
}
StorageDBThread
:
:
DBOperation
:
:
DBOperation
(
const
OperationType
aType
const
nsACString
&
aOriginNoSuffix
)
:
mType
(
aType
)
mCache
(
nullptr
)
mOrigin
(
aOriginNoSuffix
)
{
MOZ_ASSERT
(
mType
=
=
opClearMatchingOrigin
)
;
MOZ_COUNT_CTOR
(
StorageDBThread
:
:
DBOperation
)
;
}
StorageDBThread
:
:
DBOperation
:
:
DBOperation
(
const
OperationType
aType
const
OriginAttributesPattern
&
aOriginNoSuffix
)
:
mType
(
aType
)
mCache
(
nullptr
)
mOriginPattern
(
aOriginNoSuffix
)
{
MOZ_ASSERT
(
mType
=
=
opClearMatchingOriginAttributes
)
;
MOZ_COUNT_CTOR
(
StorageDBThread
:
:
DBOperation
)
;
}
StorageDBThread
:
:
DBOperation
:
:
~
DBOperation
(
)
{
MOZ_COUNT_DTOR
(
StorageDBThread
:
:
DBOperation
)
;
}
const
nsCString
StorageDBThread
:
:
DBOperation
:
:
OriginNoSuffix
(
)
const
{
if
(
mCache
)
{
return
mCache
-
>
OriginNoSuffix
(
)
;
}
return
EmptyCString
(
)
;
}
const
nsCString
StorageDBThread
:
:
DBOperation
:
:
OriginSuffix
(
)
const
{
if
(
mCache
)
{
return
mCache
-
>
OriginSuffix
(
)
;
}
return
EmptyCString
(
)
;
}
const
nsCString
StorageDBThread
:
:
DBOperation
:
:
Origin
(
)
const
{
if
(
mCache
)
{
return
mCache
-
>
Origin
(
)
;
}
return
mOrigin
;
}
const
nsCString
StorageDBThread
:
:
DBOperation
:
:
Target
(
)
const
{
switch
(
mType
)
{
case
opAddItem
:
case
opUpdateItem
:
case
opRemoveItem
:
return
Origin
(
)
+
NS_LITERAL_CSTRING
(
"
|
"
)
+
NS_ConvertUTF16toUTF8
(
mKey
)
;
default
:
return
Origin
(
)
;
}
}
void
StorageDBThread
:
:
DBOperation
:
:
PerformAndFinalize
(
StorageDBThread
*
aThread
)
{
Finalize
(
Perform
(
aThread
)
)
;
}
nsresult
StorageDBThread
:
:
DBOperation
:
:
Perform
(
StorageDBThread
*
aThread
)
{
nsresult
rv
;
switch
(
mType
)
{
case
opPreload
:
case
opPreloadUrgent
:
{
if
(
mCache
-
>
Loaded
(
)
)
{
break
;
}
StatementCache
*
statements
;
if
(
MOZ_UNLIKELY
(
IsOnBackgroundThread
(
)
)
)
{
statements
=
&
aThread
-
>
mReaderStatements
;
}
else
{
statements
=
&
aThread
-
>
mWorkerStatements
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
statements
-
>
GetCachedStatement
(
"
SELECT
key
value
FROM
webappsstore2
"
"
WHERE
originAttributes
=
:
originAttributes
AND
originKey
=
"
"
:
originKey
"
"
ORDER
BY
key
LIMIT
-
1
OFFSET
:
offset
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
mCache
-
>
OriginSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originKey
"
)
mCache
-
>
OriginNoSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindInt32ByName
(
NS_LITERAL_CSTRING
(
"
offset
"
)
static_cast
<
int32_t
>
(
mCache
-
>
LoadedCount
(
)
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
;
while
(
NS_SUCCEEDED
(
rv
=
stmt
-
>
ExecuteStep
(
&
exists
)
)
&
&
exists
)
{
nsAutoString
key
;
rv
=
stmt
-
>
GetString
(
0
key
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
value
;
rv
=
stmt
-
>
GetString
(
1
value
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mCache
-
>
LoadItem
(
key
value
)
)
{
break
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
break
;
}
case
opGetUsage
:
{
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
SELECT
SUM
(
LENGTH
(
key
)
+
LENGTH
(
value
)
)
FROM
webappsstore2
"
"
WHERE
(
originAttributes
|
|
'
:
'
|
|
originKey
)
LIKE
:
usageOrigin
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
usageOrigin
"
)
mUsage
-
>
OriginScope
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
;
rv
=
stmt
-
>
ExecuteStep
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int64_t
usage
=
0
;
if
(
exists
)
{
rv
=
stmt
-
>
GetInt64
(
0
&
usage
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mUsage
-
>
LoadUsage
(
usage
)
;
break
;
}
case
opAddItem
:
case
opUpdateItem
:
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
INSERT
OR
REPLACE
INTO
webappsstore2
(
originAttributes
"
"
originKey
scope
key
value
)
"
"
VALUES
(
:
originAttributes
:
originKey
:
scope
:
key
:
value
)
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
mCache
-
>
OriginSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originKey
"
)
mCache
-
>
OriginNoSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
scope
"
)
Scheme0Scope
(
mCache
-
>
OriginSuffix
(
)
mCache
-
>
OriginNoSuffix
(
)
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
key
"
)
mKey
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
value
"
)
mValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MonitorAutoLock
monitor
(
aThread
-
>
mThreadObserver
-
>
GetMonitor
(
)
)
;
aThread
-
>
mOriginsHavingData
.
PutEntry
(
Origin
(
)
)
;
break
;
}
case
opRemoveItem
:
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
DELETE
FROM
webappsstore2
"
"
WHERE
originAttributes
=
:
originAttributes
AND
originKey
=
"
"
:
originKey
"
"
AND
key
=
:
key
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
mCache
-
>
OriginSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originKey
"
)
mCache
-
>
OriginNoSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindStringByName
(
NS_LITERAL_CSTRING
(
"
key
"
)
mKey
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
break
;
}
case
opClear
:
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
DELETE
FROM
webappsstore2
"
"
WHERE
originAttributes
=
:
originAttributes
AND
originKey
=
"
"
:
originKey
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originAttributes
"
)
mCache
-
>
OriginSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
originKey
"
)
mCache
-
>
OriginNoSuffix
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MonitorAutoLock
monitor
(
aThread
-
>
mThreadObserver
-
>
GetMonitor
(
)
)
;
aThread
-
>
mOriginsHavingData
.
RemoveEntry
(
Origin
(
)
)
;
break
;
}
case
opClearAll
:
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
DELETE
FROM
webappsstore2
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MonitorAutoLock
monitor
(
aThread
-
>
mThreadObserver
-
>
GetMonitor
(
)
)
;
aThread
-
>
mOriginsHavingData
.
Clear
(
)
;
break
;
}
case
opClearMatchingOrigin
:
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
DELETE
FROM
webappsstore2
"
"
WHERE
originKey
GLOB
:
scope
"
)
;
NS_ENSURE_STATE
(
stmt
)
;
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
NS_LITERAL_CSTRING
(
"
scope
"
)
mOrigin
+
NS_LITERAL_CSTRING
(
"
*
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
stmt
-
>
Execute
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
break
;
}
case
opClearMatchingOriginAttributes
:
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageFunction
>
patternMatchFunction
(
new
OriginAttrsPatternMatchSQLFunction
(
mOriginPattern
)
)
;
rv
=
aThread
-
>
mWorkerConnection
-
>
CreateFunction
(
NS_LITERAL_CSTRING
(
"
ORIGIN_ATTRS_PATTERN_MATCH
"
)
1
patternMatchFunction
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
=
aThread
-
>
mWorkerStatements
.
GetCachedStatement
(
"
DELETE
FROM
webappsstore2
"
"
WHERE
ORIGIN_ATTRS_PATTERN_MATCH
(
originAttributes
)
"
)
;
if
(
stmt
)
{
mozStorageStatementScoper
scope
(
stmt
)
;
rv
=
stmt
-
>
Execute
(
)
;
}
else
{
rv
=
NS_ERROR_UNEXPECTED
;
}
aThread
-
>
mWorkerConnection
-
>
RemoveFunction
(
NS_LITERAL_CSTRING
(
"
ORIGIN_ATTRS_PATTERN_MATCH
"
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
break
;
}
default
:
NS_ERROR
(
"
Unknown
task
type
"
)
;
break
;
}
return
NS_OK
;
}
void
StorageDBThread
:
:
DBOperation
:
:
Finalize
(
nsresult
aRv
)
{
switch
(
mType
)
{
case
opPreloadUrgent
:
case
opPreload
:
if
(
NS_FAILED
(
aRv
)
)
{
NS_WARNING
(
"
Failed
to
preload
localStorage
"
)
;
}
mCache
-
>
LoadDone
(
aRv
)
;
break
;
case
opGetUsage
:
if
(
NS_FAILED
(
aRv
)
)
{
mUsage
-
>
LoadUsage
(
0
)
;
}
break
;
default
:
if
(
NS_FAILED
(
aRv
)
)
{
NS_WARNING
(
"
localStorage
update
/
clear
operation
failed
"
"
data
may
not
persist
or
clean
up
"
)
;
}
break
;
}
}
StorageDBThread
:
:
PendingOperations
:
:
PendingOperations
(
)
:
mFlushFailureCount
(
0
)
{
}
bool
StorageDBThread
:
:
PendingOperations
:
:
HasTasks
(
)
const
{
return
!
!
mUpdates
.
Count
(
)
|
|
!
!
mClears
.
Count
(
)
;
}
namespace
{
bool
OriginPatternMatches
(
const
nsACString
&
aOriginSuffix
const
OriginAttributesPattern
&
aPattern
)
{
OriginAttributes
oa
;
DebugOnly
<
bool
>
rv
=
oa
.
PopulateFromSuffix
(
aOriginSuffix
)
;
MOZ_ASSERT
(
rv
)
;
return
aPattern
.
Matches
(
oa
)
;
}
}
bool
StorageDBThread
:
:
PendingOperations
:
:
CheckForCoalesceOpportunity
(
DBOperation
*
aNewOp
DBOperation
:
:
OperationType
aPendingType
DBOperation
:
:
OperationType
aNewType
)
{
if
(
aNewOp
-
>
Type
(
)
!
=
aNewType
)
{
return
false
;
}
StorageDBThread
:
:
DBOperation
*
pendingTask
;
if
(
!
mUpdates
.
Get
(
aNewOp
-
>
Target
(
)
&
pendingTask
)
)
{
return
false
;
}
if
(
pendingTask
-
>
Type
(
)
!
=
aPendingType
)
{
return
false
;
}
return
true
;
}
void
StorageDBThread
:
:
PendingOperations
:
:
Add
(
StorageDBThread
:
:
DBOperation
*
aOperation
)
{
if
(
CheckForCoalesceOpportunity
(
aOperation
DBOperation
:
:
opAddItem
DBOperation
:
:
opRemoveItem
)
)
{
mUpdates
.
Remove
(
aOperation
-
>
Target
(
)
)
;
delete
aOperation
;
return
;
}
if
(
CheckForCoalesceOpportunity
(
aOperation
DBOperation
:
:
opAddItem
DBOperation
:
:
opUpdateItem
)
)
{
aOperation
-
>
mType
=
DBOperation
:
:
opAddItem
;
}
if
(
CheckForCoalesceOpportunity
(
aOperation
DBOperation
:
:
opRemoveItem
DBOperation
:
:
opAddItem
)
)
{
aOperation
-
>
mType
=
DBOperation
:
:
opUpdateItem
;
}
switch
(
aOperation
-
>
Type
(
)
)
{
case
DBOperation
:
:
opAddItem
:
case
DBOperation
:
:
opUpdateItem
:
case
DBOperation
:
:
opRemoveItem
:
mUpdates
.
Put
(
aOperation
-
>
Target
(
)
aOperation
)
;
break
;
case
DBOperation
:
:
opClear
:
case
DBOperation
:
:
opClearMatchingOrigin
:
case
DBOperation
:
:
opClearMatchingOriginAttributes
:
for
(
auto
iter
=
mUpdates
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsAutoPtr
<
DBOperation
>
&
pendingTask
=
iter
.
Data
(
)
;
if
(
aOperation
-
>
Type
(
)
=
=
DBOperation
:
:
opClear
&
&
(
pendingTask
-
>
OriginNoSuffix
(
)
!
=
aOperation
-
>
OriginNoSuffix
(
)
|
|
pendingTask
-
>
OriginSuffix
(
)
!
=
aOperation
-
>
OriginSuffix
(
)
)
)
{
continue
;
}
if
(
aOperation
-
>
Type
(
)
=
=
DBOperation
:
:
opClearMatchingOrigin
&
&
!
StringBeginsWith
(
pendingTask
-
>
OriginNoSuffix
(
)
aOperation
-
>
Origin
(
)
)
)
{
continue
;
}
if
(
aOperation
-
>
Type
(
)
=
=
DBOperation
:
:
opClearMatchingOriginAttributes
&
&
!
OriginPatternMatches
(
pendingTask
-
>
OriginSuffix
(
)
aOperation
-
>
OriginPattern
(
)
)
)
{
continue
;
}
iter
.
Remove
(
)
;
}
mClears
.
Put
(
aOperation
-
>
Target
(
)
aOperation
)
;
break
;
case
DBOperation
:
:
opClearAll
:
mUpdates
.
Clear
(
)
;
mClears
.
Clear
(
)
;
mClears
.
Put
(
aOperation
-
>
Target
(
)
aOperation
)
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
break
;
}
}
bool
StorageDBThread
:
:
PendingOperations
:
:
Prepare
(
)
{
for
(
auto
iter
=
mClears
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
mExecList
.
AppendElement
(
iter
.
Data
(
)
.
forget
(
)
)
;
}
mClears
.
Clear
(
)
;
for
(
auto
iter
=
mUpdates
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
mExecList
.
AppendElement
(
iter
.
Data
(
)
.
forget
(
)
)
;
}
mUpdates
.
Clear
(
)
;
return
!
!
mExecList
.
Length
(
)
;
}
nsresult
StorageDBThread
:
:
PendingOperations
:
:
Execute
(
StorageDBThread
*
aThread
)
{
mozStorageTransaction
transaction
(
aThread
-
>
mWorkerConnection
false
)
;
nsresult
rv
;
for
(
uint32_t
i
=
0
;
i
<
mExecList
.
Length
(
)
;
+
+
i
)
{
StorageDBThread
:
:
DBOperation
*
task
=
mExecList
[
i
]
;
rv
=
task
-
>
Perform
(
aThread
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
rv
=
transaction
.
Commit
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
StorageDBThread
:
:
PendingOperations
:
:
Finalize
(
nsresult
aRv
)
{
if
(
NS_FAILED
(
aRv
)
)
{
NS_WARNING
(
"
Flush
operation
on
localStorage
database
failed
"
)
;
+
+
mFlushFailureCount
;
return
mFlushFailureCount
>
=
5
;
}
mFlushFailureCount
=
0
;
mExecList
.
Clear
(
)
;
return
true
;
}
namespace
{
bool
FindPendingClearForOrigin
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
StorageDBThread
:
:
DBOperation
*
aPendingOperation
)
{
if
(
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opClearAll
)
{
return
true
;
}
if
(
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opClear
&
&
aOriginNoSuffix
=
=
aPendingOperation
-
>
OriginNoSuffix
(
)
&
&
aOriginSuffix
=
=
aPendingOperation
-
>
OriginSuffix
(
)
)
{
return
true
;
}
if
(
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opClearMatchingOrigin
&
&
StringBeginsWith
(
aOriginNoSuffix
aPendingOperation
-
>
Origin
(
)
)
)
{
return
true
;
}
if
(
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opClearMatchingOriginAttributes
&
&
OriginPatternMatches
(
aOriginSuffix
aPendingOperation
-
>
OriginPattern
(
)
)
)
{
return
true
;
}
return
false
;
}
}
bool
StorageDBThread
:
:
PendingOperations
:
:
IsOriginClearPending
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
const
{
for
(
auto
iter
=
mClears
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
FindPendingClearForOrigin
(
aOriginSuffix
aOriginNoSuffix
iter
.
UserData
(
)
)
)
{
return
true
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mExecList
.
Length
(
)
;
+
+
i
)
{
if
(
FindPendingClearForOrigin
(
aOriginSuffix
aOriginNoSuffix
mExecList
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
namespace
{
bool
FindPendingUpdateForOrigin
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
StorageDBThread
:
:
DBOperation
*
aPendingOperation
)
{
if
(
(
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opAddItem
|
|
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opUpdateItem
|
|
aPendingOperation
-
>
Type
(
)
=
=
StorageDBThread
:
:
DBOperation
:
:
opRemoveItem
)
&
&
aOriginNoSuffix
=
=
aPendingOperation
-
>
OriginNoSuffix
(
)
&
&
aOriginSuffix
=
=
aPendingOperation
-
>
OriginSuffix
(
)
)
{
return
true
;
}
return
false
;
}
}
bool
StorageDBThread
:
:
PendingOperations
:
:
IsOriginUpdatePending
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
const
{
for
(
auto
iter
=
mUpdates
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
FindPendingUpdateForOrigin
(
aOriginSuffix
aOriginNoSuffix
iter
.
UserData
(
)
)
)
{
return
true
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mExecList
.
Length
(
)
;
+
+
i
)
{
if
(
FindPendingUpdateForOrigin
(
aOriginSuffix
aOriginNoSuffix
mExecList
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
nsresult
StorageDBThread
:
:
InitHelper
:
:
SyncDispatchAndReturnProfilePath
(
nsAString
&
aProfilePath
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
this
)
)
;
mozilla
:
:
MutexAutoLock
autolock
(
mMutex
)
;
while
(
mWaiting
)
{
mCondVar
.
Wait
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
mMainThreadResultCode
)
)
)
{
return
mMainThreadResultCode
;
}
aProfilePath
=
mProfilePath
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageDBThread
:
:
InitHelper
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
GetProfilePath
(
mProfilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mMainThreadResultCode
=
rv
;
}
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mWaiting
)
;
mWaiting
=
false
;
mCondVar
.
Notify
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageDBThread
:
:
NoteBackgroundThreadRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StorageObserver
*
observer
=
StorageObserver
:
:
Self
(
)
;
MOZ_ASSERT
(
observer
)
;
observer
-
>
NoteBackgroundThread
(
mOwningThread
)
;
return
NS_OK
;
}
NS_IMETHODIMP
StorageDBThread
:
:
ShutdownRunnable
:
:
Run
(
)
{
if
(
NS_IsMainThread
(
)
)
{
mDone
=
true
;
return
NS_OK
;
}
AssertIsOnBackgroundThread
(
)
;
if
(
sStorageThread
)
{
sStorageThread
-
>
Shutdown
(
)
;
delete
sStorageThread
;
sStorageThread
=
nullptr
;
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
this
)
)
;
return
NS_OK
;
}
}
}
