#
ifndef
DOMStorageDBThread_h___
#
define
DOMStorageDBThread_h___
#
include
"
prthread
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
storage
/
StatementCache
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIThreadInternal
.
h
"
class
mozIStorageConnection
;
namespace
mozilla
{
namespace
dom
{
class
DOMStorageCacheBridge
;
class
DOMStorageUsageBridge
;
class
DOMStorageUsage
;
typedef
mozilla
:
:
storage
:
:
StatementCache
<
mozIStorageStatement
>
StatementCache
;
class
DOMStorageDBBridge
{
public
:
DOMStorageDBBridge
(
)
;
virtual
~
DOMStorageDBBridge
(
)
{
}
virtual
nsresult
Init
(
)
=
0
;
virtual
nsresult
Shutdown
(
)
=
0
;
virtual
void
AsyncPreload
(
DOMStorageCacheBridge
*
aCache
bool
aPriority
=
false
)
=
0
;
virtual
void
AsyncGetUsage
(
DOMStorageUsageBridge
*
aUsage
)
=
0
;
virtual
void
SyncPreload
(
DOMStorageCacheBridge
*
aCache
bool
aForceSync
=
false
)
=
0
;
virtual
nsresult
AsyncAddItem
(
DOMStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
=
0
;
virtual
nsresult
AsyncUpdateItem
(
DOMStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
=
0
;
virtual
nsresult
AsyncRemoveItem
(
DOMStorageCacheBridge
*
aCache
const
nsAString
&
aKey
)
=
0
;
virtual
nsresult
AsyncClear
(
DOMStorageCacheBridge
*
aCache
)
=
0
;
virtual
void
AsyncClearAll
(
)
=
0
;
virtual
void
AsyncClearMatchingOrigin
(
const
nsACString
&
aOriginNoSuffix
)
=
0
;
virtual
void
AsyncClearMatchingOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
)
=
0
;
virtual
void
AsyncFlush
(
)
=
0
;
virtual
bool
ShouldPreloadOrigin
(
const
nsACString
&
aOriginNoSuffix
)
=
0
;
virtual
void
GetOriginsHavingData
(
InfallibleTArray
<
nsCString
>
*
aOrigins
)
=
0
;
}
;
class
DOMStorageDBThread
final
:
public
DOMStorageDBBridge
{
public
:
class
PendingOperations
;
class
DBOperation
{
public
:
typedef
enum
{
opPreload
opPreloadUrgent
opGetUsage
opAddItem
opUpdateItem
opRemoveItem
opClear
opClearAll
opClearMatchingOrigin
opClearMatchingOriginAttributes
}
OperationType
;
explicit
DBOperation
(
const
OperationType
aType
DOMStorageCacheBridge
*
aCache
=
nullptr
const
nsAString
&
aKey
=
EmptyString
(
)
const
nsAString
&
aValue
=
EmptyString
(
)
)
;
DBOperation
(
const
OperationType
aType
DOMStorageUsageBridge
*
aUsage
)
;
DBOperation
(
const
OperationType
aType
const
nsACString
&
aOriginNoSuffix
)
;
DBOperation
(
const
OperationType
aType
const
OriginAttributesPattern
&
aOriginNoSuffix
)
;
~
DBOperation
(
)
;
void
PerformAndFinalize
(
DOMStorageDBThread
*
aThread
)
;
void
Finalize
(
nsresult
aRv
)
;
OperationType
Type
(
)
const
{
return
mType
;
}
const
nsCString
OriginNoSuffix
(
)
const
;
const
nsCString
OriginSuffix
(
)
const
;
const
nsCString
Origin
(
)
const
;
const
nsCString
Target
(
)
const
;
const
OriginAttributesPattern
&
OriginPattern
(
)
const
{
return
mOriginPattern
;
}
private
:
nsresult
Perform
(
DOMStorageDBThread
*
aThread
)
;
friend
class
PendingOperations
;
OperationType
mType
;
RefPtr
<
DOMStorageCacheBridge
>
mCache
;
RefPtr
<
DOMStorageUsageBridge
>
mUsage
;
nsString
const
mKey
;
nsString
const
mValue
;
nsCString
const
mOrigin
;
OriginAttributesPattern
const
mOriginPattern
;
}
;
class
PendingOperations
{
public
:
PendingOperations
(
)
;
void
Add
(
DBOperation
*
aOperation
)
;
bool
HasTasks
(
)
const
;
bool
Prepare
(
)
;
nsresult
Execute
(
DOMStorageDBThread
*
aThread
)
;
bool
Finalize
(
nsresult
aRv
)
;
bool
IsOriginClearPending
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
const
;
bool
IsOriginUpdatePending
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
const
;
private
:
bool
CheckForCoalesceOpportunity
(
DBOperation
*
aNewOp
DBOperation
:
:
OperationType
aPendingType
DBOperation
:
:
OperationType
aNewType
)
;
nsClassHashtable
<
nsCStringHashKey
DBOperation
>
mClears
;
nsClassHashtable
<
nsCStringHashKey
DBOperation
>
mUpdates
;
nsTArray
<
nsAutoPtr
<
DBOperation
>
>
mExecList
;
uint32_t
mFlushFailureCount
;
}
;
class
ThreadObserver
final
:
public
nsIThreadObserver
{
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADOBSERVER
ThreadObserver
(
)
:
mHasPendingEvents
(
false
)
mMonitor
(
"
DOMStorageThreadMonitor
"
)
{
}
bool
HasPendingEvents
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mHasPendingEvents
;
}
void
ClearPendingEvents
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mHasPendingEvents
=
false
;
}
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
private
:
virtual
~
ThreadObserver
(
)
{
}
bool
mHasPendingEvents
;
Monitor
mMonitor
;
}
;
public
:
DOMStorageDBThread
(
)
;
virtual
~
DOMStorageDBThread
(
)
{
}
virtual
nsresult
Init
(
)
;
virtual
nsresult
Shutdown
(
)
;
virtual
void
AsyncPreload
(
DOMStorageCacheBridge
*
aCache
bool
aPriority
=
false
)
{
InsertDBOp
(
new
DBOperation
(
aPriority
?
DBOperation
:
:
opPreloadUrgent
:
DBOperation
:
:
opPreload
aCache
)
)
;
}
virtual
void
SyncPreload
(
DOMStorageCacheBridge
*
aCache
bool
aForce
=
false
)
;
virtual
void
AsyncGetUsage
(
DOMStorageUsageBridge
*
aUsage
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opGetUsage
aUsage
)
)
;
}
virtual
nsresult
AsyncAddItem
(
DOMStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opAddItem
aCache
aKey
aValue
)
)
;
}
virtual
nsresult
AsyncUpdateItem
(
DOMStorageCacheBridge
*
aCache
const
nsAString
&
aKey
const
nsAString
&
aValue
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opUpdateItem
aCache
aKey
aValue
)
)
;
}
virtual
nsresult
AsyncRemoveItem
(
DOMStorageCacheBridge
*
aCache
const
nsAString
&
aKey
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opRemoveItem
aCache
aKey
)
)
;
}
virtual
nsresult
AsyncClear
(
DOMStorageCacheBridge
*
aCache
)
{
return
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClear
aCache
)
)
;
}
virtual
void
AsyncClearAll
(
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClearAll
)
)
;
}
virtual
void
AsyncClearMatchingOrigin
(
const
nsACString
&
aOriginNoSuffix
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClearMatchingOrigin
aOriginNoSuffix
)
)
;
}
virtual
void
AsyncClearMatchingOriginAttributes
(
const
OriginAttributesPattern
&
aPattern
)
{
InsertDBOp
(
new
DBOperation
(
DBOperation
:
:
opClearMatchingOriginAttributes
aPattern
)
)
;
}
virtual
void
AsyncFlush
(
)
;
virtual
bool
ShouldPreloadOrigin
(
const
nsACString
&
aOrigin
)
;
virtual
void
GetOriginsHavingData
(
InfallibleTArray
<
nsCString
>
*
aOrigins
)
;
private
:
nsCOMPtr
<
nsIFile
>
mDatabaseFile
;
PRThread
*
mThread
;
RefPtr
<
ThreadObserver
>
mThreadObserver
;
bool
mStopIOThread
;
bool
mWALModeEnabled
;
Atomic
<
bool
ReleaseAcquire
>
mDBReady
;
nsresult
mStatus
;
nsTHashtable
<
nsCStringHashKey
>
mOriginsHavingData
;
nsCOMPtr
<
mozIStorageConnection
>
mWorkerConnection
;
nsCOMPtr
<
mozIStorageConnection
>
mReaderConnection
;
StatementCache
mWorkerStatements
;
StatementCache
mReaderStatements
;
PRIntervalTime
mDirtyEpoch
;
bool
mFlushImmediately
;
nsTArray
<
DBOperation
*
>
mPreloads
;
PendingOperations
mPendingTasks
;
int32_t
mPriorityCounter
;
nsresult
InsertDBOp
(
DBOperation
*
aOperation
)
;
nsresult
OpenDatabaseConnection
(
)
;
nsresult
OpenAndUpdateDatabase
(
)
;
nsresult
InitDatabase
(
)
;
nsresult
ShutdownDatabase
(
)
;
nsresult
SetJournalMode
(
bool
aIsWal
)
;
nsresult
TryJournalMode
(
)
;
nsresult
ConfigureWALBehavior
(
)
;
void
SetHigherPriority
(
)
;
void
SetDefaultPriority
(
)
;
void
ScheduleFlush
(
)
;
void
UnscheduleFlush
(
)
;
PRIntervalTime
TimeUntilFlush
(
)
;
void
NotifyFlushCompletion
(
)
;
static
void
ThreadFunc
(
void
*
aArg
)
;
void
ThreadFunc
(
)
;
}
;
}
}
#
endif
