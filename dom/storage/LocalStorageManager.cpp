#
include
"
LocalStorageManager
.
h
"
#
include
"
LocalStorage
.
h
"
#
include
"
StorageDBThread
.
h
"
#
include
"
StorageUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
define
DEFAULT_QUOTA_LIMIT
(
5
*
1024
)
namespace
mozilla
{
namespace
dom
{
using
namespace
StorageUtils
;
namespace
{
int32_t
gQuotaLimit
=
DEFAULT_QUOTA_LIMIT
;
}
LocalStorageManager
*
LocalStorageManager
:
:
sSelf
=
nullptr
;
uint32_t
LocalStorageManager
:
:
GetQuota
(
)
{
static
bool
preferencesInitialized
=
false
;
if
(
!
preferencesInitialized
)
{
mozilla
:
:
Preferences
:
:
AddIntVarCache
(
&
gQuotaLimit
"
dom
.
storage
.
default_quota
"
DEFAULT_QUOTA_LIMIT
)
;
preferencesInitialized
=
true
;
}
return
gQuotaLimit
*
1024
;
}
NS_IMPL_ISUPPORTS
(
LocalStorageManager
nsIDOMStorageManager
)
LocalStorageManager
:
:
LocalStorageManager
(
)
:
mCaches
(
8
)
mLowDiskSpace
(
false
)
{
StorageObserver
*
observer
=
StorageObserver
:
:
Self
(
)
;
NS_ASSERTION
(
observer
"
No
StorageObserver
cannot
observe
private
data
delete
notifications
!
"
)
;
if
(
observer
)
{
observer
-
>
AddSink
(
this
)
;
}
NS_ASSERTION
(
!
sSelf
"
Somebody
is
trying
to
do_CreateInstance
(
\
"
mozilla
/
dom
/
localStorage
-
manager
;
1
\
"
"
)
;
sSelf
=
this
;
if
(
!
XRE_IsParentProcess
(
)
)
{
StorageDBChild
:
:
GetOrCreate
(
)
;
}
}
LocalStorageManager
:
:
~
LocalStorageManager
(
)
{
StorageObserver
*
observer
=
StorageObserver
:
:
Self
(
)
;
if
(
observer
)
{
observer
-
>
RemoveSink
(
this
)
;
}
sSelf
=
nullptr
;
}
namespace
{
nsresult
CreateQuotaDBKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
{
nsresult
rv
;
nsCOMPtr
<
nsIEffectiveTLDService
>
eTLDService
(
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
uri
NS_ERROR_UNEXPECTED
)
;
nsAutoCString
eTLDplusOne
;
rv
=
eTLDService
-
>
GetBaseDomain
(
uri
0
eTLDplusOne
)
;
if
(
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
=
=
rv
)
{
rv
=
uri
-
>
GetAsciiHost
(
eTLDplusOne
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aKey
.
Truncate
(
)
;
aPrincipal
-
>
OriginAttributesRef
(
)
.
CreateSuffix
(
aKey
)
;
nsAutoCString
subdomainsDBKey
;
CreateReversedDomain
(
eTLDplusOne
subdomainsDBKey
)
;
aKey
.
Append
(
'
:
'
)
;
aKey
.
Append
(
subdomainsDBKey
)
;
return
NS_OK
;
}
}
nsCString
LocalStorageManager
:
:
CreateOrigin
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
{
nsAutoCString
scope
;
scope
.
Append
(
aOriginSuffix
)
;
scope
.
Append
(
'
:
'
)
;
scope
.
Append
(
aOriginNoSuffix
)
;
return
scope
;
}
LocalStorageCache
*
LocalStorageManager
:
:
GetCache
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
{
CacheOriginHashtable
*
table
=
mCaches
.
LookupOrAdd
(
aOriginSuffix
)
;
LocalStorageCacheHashKey
*
entry
=
table
-
>
GetEntry
(
aOriginNoSuffix
)
;
if
(
!
entry
)
{
return
nullptr
;
}
return
entry
-
>
cache
(
)
;
}
already_AddRefed
<
StorageUsage
>
LocalStorageManager
:
:
GetOriginUsage
(
const
nsACString
&
aOriginNoSuffix
)
{
RefPtr
<
StorageUsage
>
usage
;
if
(
mUsages
.
Get
(
aOriginNoSuffix
&
usage
)
)
{
return
usage
.
forget
(
)
;
}
usage
=
new
StorageUsage
(
aOriginNoSuffix
)
;
StorageDBChild
*
storageChild
=
StorageDBChild
:
:
GetOrCreate
(
)
;
if
(
storageChild
)
{
storageChild
-
>
AsyncGetUsage
(
usage
)
;
}
mUsages
.
Put
(
aOriginNoSuffix
usage
)
;
return
usage
.
forget
(
)
;
}
already_AddRefed
<
LocalStorageCache
>
LocalStorageManager
:
:
PutCache
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
nsIPrincipal
*
aPrincipal
)
{
CacheOriginHashtable
*
table
=
mCaches
.
LookupOrAdd
(
aOriginSuffix
)
;
LocalStorageCacheHashKey
*
entry
=
table
-
>
PutEntry
(
aOriginNoSuffix
)
;
RefPtr
<
LocalStorageCache
>
cache
=
entry
-
>
cache
(
)
;
nsAutoCString
quotaOrigin
;
CreateQuotaDBKey
(
aPrincipal
quotaOrigin
)
;
cache
-
>
Init
(
this
true
aPrincipal
quotaOrigin
)
;
return
cache
.
forget
(
)
;
}
void
LocalStorageManager
:
:
DropCache
(
LocalStorageCache
*
aCache
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_WARNING
(
"
StorageManager
:
:
DropCache
called
on
a
non
-
main
thread
shutting
down
?
"
)
;
}
CacheOriginHashtable
*
table
=
mCaches
.
LookupOrAdd
(
aCache
-
>
OriginSuffix
(
)
)
;
table
-
>
RemoveEntry
(
aCache
-
>
OriginNoSuffix
(
)
)
;
}
nsresult
LocalStorageManager
:
:
GetStorageInternal
(
CreateMode
aCreateMode
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
nsAutoCString
originAttrSuffix
;
nsAutoCString
originKey
;
nsresult
rv
=
GenerateOriginKey
(
aPrincipal
originAttrSuffix
originKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
LocalStorageCache
>
cache
=
GetCache
(
originAttrSuffix
originKey
)
;
if
(
!
cache
)
{
if
(
aCreateMode
=
=
CreateMode
:
:
UseIfExistsNeverCreate
)
{
*
aRetval
=
nullptr
;
return
NS_OK
;
}
if
(
aCreateMode
=
=
CreateMode
:
:
CreateIfShouldPreload
)
{
StorageDBChild
*
db
=
StorageDBChild
:
:
Get
(
)
;
if
(
db
)
{
if
(
!
db
-
>
ShouldPreloadOrigin
(
LocalStorageManager
:
:
CreateOrigin
(
originAttrSuffix
originKey
)
)
)
{
return
NS_OK
;
}
}
else
{
if
(
originKey
.
EqualsLiteral
(
"
knalb
.
:
about
"
)
)
{
return
NS_OK
;
}
}
}
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
NS_ERROR_FAILURE
;
}
PrincipalInfo
principalInfo
;
rv
=
mozilla
:
:
ipc
:
:
PrincipalToPrincipalInfo
(
aPrincipal
&
principalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint32_t
privateBrowsingId
;
rv
=
aPrincipal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
cache
=
PutCache
(
originAttrSuffix
originKey
aPrincipal
)
;
LocalStorageCacheChild
*
actor
=
new
LocalStorageCacheChild
(
cache
)
;
MOZ_ALWAYS_TRUE
(
backgroundActor
-
>
SendPBackgroundLocalStorageCacheConstructor
(
actor
principalInfo
originKey
privateBrowsingId
)
)
;
cache
-
>
SetActor
(
actor
)
;
}
if
(
aRetval
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
nsPIDOMWindowInner
:
:
From
(
aWindow
)
;
nsCOMPtr
<
nsIDOMStorage
>
storage
=
new
LocalStorage
(
inner
this
cache
aDocumentURI
aPrincipal
aPrivate
)
;
storage
.
forget
(
aRetval
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
LocalStorageManager
:
:
PrecacheStorage
(
nsIPrincipal
*
aPrincipal
nsIDOMStorage
*
*
aRetval
)
{
return
GetStorageInternal
(
CreateMode
:
:
CreateIfShouldPreload
nullptr
aPrincipal
EmptyString
(
)
false
aRetval
)
;
}
NS_IMETHODIMP
LocalStorageManager
:
:
CreateStorage
(
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
return
GetStorageInternal
(
CreateMode
:
:
CreateAlways
aWindow
aPrincipal
aDocumentURI
aPrivate
aRetval
)
;
}
NS_IMETHODIMP
LocalStorageManager
:
:
GetStorage
(
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
bool
aPrivate
nsIDOMStorage
*
*
aRetval
)
{
return
GetStorageInternal
(
CreateMode
:
:
UseIfExistsNeverCreate
aWindow
aPrincipal
EmptyString
(
)
aPrivate
aRetval
)
;
}
NS_IMETHODIMP
LocalStorageManager
:
:
CloneStorage
(
nsIDOMStorage
*
aStorage
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
LocalStorageManager
:
:
CheckStorage
(
nsIPrincipal
*
aPrincipal
nsIDOMStorage
*
aStorage
bool
*
aRetval
)
{
nsresult
rv
;
RefPtr
<
LocalStorage
>
storage
=
static_cast
<
LocalStorage
*
>
(
aStorage
)
;
if
(
!
storage
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aRetval
=
false
;
if
(
!
aPrincipal
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
suffix
;
nsAutoCString
origin
;
rv
=
GenerateOriginKey
(
aPrincipal
suffix
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
LocalStorageCache
*
cache
=
GetCache
(
suffix
origin
)
;
if
(
cache
!
=
storage
-
>
GetCache
(
)
)
{
return
NS_OK
;
}
if
(
!
storage
-
>
PrincipalEquals
(
aPrincipal
)
)
{
return
NS_OK
;
}
*
aRetval
=
true
;
return
NS_OK
;
}
void
LocalStorageManager
:
:
ClearCaches
(
uint32_t
aUnloadFlags
const
OriginAttributesPattern
&
aPattern
const
nsACString
&
aOriginScope
)
{
for
(
auto
iter1
=
mCaches
.
Iter
(
)
;
!
iter1
.
Done
(
)
;
iter1
.
Next
(
)
)
{
OriginAttributes
oa
;
DebugOnly
<
bool
>
rv
=
oa
.
PopulateFromSuffix
(
iter1
.
Key
(
)
)
;
MOZ_ASSERT
(
rv
)
;
if
(
!
aPattern
.
Matches
(
oa
)
)
{
continue
;
}
CacheOriginHashtable
*
table
=
iter1
.
Data
(
)
;
for
(
auto
iter2
=
table
-
>
Iter
(
)
;
!
iter2
.
Done
(
)
;
iter2
.
Next
(
)
)
{
LocalStorageCache
*
cache
=
iter2
.
Get
(
)
-
>
cache
(
)
;
if
(
aOriginScope
.
IsEmpty
(
)
|
|
StringBeginsWith
(
cache
-
>
OriginNoSuffix
(
)
aOriginScope
)
)
{
cache
-
>
UnloadItems
(
aUnloadFlags
)
;
}
}
}
}
nsresult
LocalStorageManager
:
:
Observe
(
const
char
*
aTopic
const
nsAString
&
aOriginAttributesPattern
const
nsACString
&
aOriginScope
)
{
OriginAttributesPattern
pattern
;
if
(
!
pattern
.
Init
(
aOriginAttributesPattern
)
)
{
NS_ERROR
(
"
Cannot
parse
origin
attributes
pattern
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
strcmp
(
aTopic
"
cookie
-
cleared
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadComplete
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
extension
:
purge
-
localStorage
-
caches
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadComplete
pattern
aOriginScope
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
session
-
only
-
cleared
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadSession
pattern
aOriginScope
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
domain
-
data
-
cleared
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadComplete
pattern
aOriginScope
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
private
-
browsing
-
data
-
cleared
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadPrivate
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
origin
-
attr
-
pattern
-
cleared
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadComplete
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
profile
-
change
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kUnloadComplete
pattern
EmptyCString
(
)
)
;
mCaches
.
Clear
(
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
low
-
disk
-
space
"
)
)
{
mLowDiskSpace
=
true
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
no
-
low
-
disk
-
space
"
)
)
{
mLowDiskSpace
=
false
;
return
NS_OK
;
}
#
ifdef
DOM_STORAGE_TESTS
if
(
!
strcmp
(
aTopic
"
test
-
reload
"
)
)
{
ClearCaches
(
LocalStorageCache
:
:
kTestReload
pattern
EmptyCString
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
test
-
flushed
"
)
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
nullptr
"
domstorage
-
test
-
flushed
"
nullptr
)
;
}
}
return
NS_OK
;
}
#
endif
NS_ERROR
(
"
Unexpected
topic
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
LocalStorageManager
*
LocalStorageManager
:
:
Ensure
(
)
{
if
(
sSelf
)
{
return
sSelf
;
}
nsCOMPtr
<
nsIDOMStorageManager
>
initializer
=
do_GetService
(
"
mozilla
.
org
/
dom
/
localStorage
-
manager
;
1
"
)
;
MOZ_ASSERT
(
sSelf
"
Didn
'
t
initialize
?
"
)
;
return
sSelf
;
}
}
}
