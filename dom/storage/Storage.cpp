#
include
"
Storage
.
h
"
#
include
"
StorageNotifierService
.
h
"
#
include
"
mozilla
/
dom
/
StorageBinding
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
namespace
mozilla
{
namespace
dom
{
static
const
char
kStorageEnabled
[
]
=
"
dom
.
storage
.
enabled
"
;
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
Storage
mWindow
mPrincipal
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Storage
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
Storage
LastRelease
(
)
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Storage
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
Storage
:
:
Storage
(
nsPIDOMWindowInner
*
aWindow
nsIPrincipal
*
aPrincipal
)
:
mWindow
(
aWindow
)
mPrincipal
(
aPrincipal
)
mIsSessionOnly
(
false
)
{
MOZ_ASSERT
(
aPrincipal
)
;
}
Storage
:
:
~
Storage
(
)
{
}
bool
Storage
:
:
StoragePrefIsEnabled
(
)
{
return
mozilla
:
:
Preferences
:
:
GetBool
(
kStorageEnabled
)
;
}
bool
Storage
:
:
CanUseStorage
(
nsIPrincipal
&
aSubjectPrincipal
)
{
if
(
!
StoragePrefIsEnabled
(
)
)
{
return
false
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
mPrincipal
)
)
{
mIsSessionOnly
=
false
;
}
else
if
(
mWindow
)
{
uint32_t
rejectedReason
=
0
;
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForWindow
(
mWindow
&
rejectedReason
)
;
if
(
access
=
=
nsContentUtils
:
:
StorageAccess
:
:
eDeny
&
&
ShouldThrowWhenStorageAccessDenied
(
rejectedReason
)
)
{
return
false
;
}
mIsSessionOnly
=
access
<
=
nsContentUtils
:
:
StorageAccess
:
:
eSessionScoped
;
}
return
aSubjectPrincipal
.
Subsumes
(
mPrincipal
)
;
}
JSObject
*
Storage
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Storage_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
namespace
{
class
StorageNotifierRunnable
:
public
Runnable
{
public
:
StorageNotifierRunnable
(
nsISupports
*
aSubject
const
char16_t
*
aStorageType
bool
aPrivateBrowsing
)
:
Runnable
(
"
StorageNotifierRunnable
"
)
mSubject
(
aSubject
)
mStorageType
(
aStorageType
)
mPrivateBrowsing
(
aPrivateBrowsing
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
mSubject
mPrivateBrowsing
?
"
dom
-
private
-
storage2
-
changed
"
:
"
dom
-
storage2
-
changed
"
mStorageType
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsISupports
>
mSubject
;
const
char16_t
*
mStorageType
;
const
bool
mPrivateBrowsing
;
}
;
}
void
Storage
:
:
NotifyChange
(
Storage
*
aStorage
nsIPrincipal
*
aPrincipal
const
nsAString
&
aKey
const
nsAString
&
aOldValue
const
nsAString
&
aNewValue
const
char16_t
*
aStorageType
const
nsAString
&
aDocumentURI
bool
aIsPrivate
bool
aImmediateDispatch
)
{
StorageEventInit
dict
;
dict
.
mBubbles
=
false
;
dict
.
mCancelable
=
false
;
dict
.
mKey
=
aKey
;
dict
.
mNewValue
=
aNewValue
;
dict
.
mOldValue
=
aOldValue
;
dict
.
mStorageArea
=
aStorage
;
dict
.
mUrl
=
aDocumentURI
;
RefPtr
<
StorageEvent
>
event
=
StorageEvent
:
:
Constructor
(
nullptr
NS_LITERAL_STRING
(
"
storage
"
)
dict
)
;
event
-
>
SetPrincipal
(
aPrincipal
)
;
StorageNotifierService
:
:
Broadcast
(
event
aStorageType
aIsPrivate
aImmediateDispatch
)
;
RefPtr
<
StorageNotifierRunnable
>
r
=
new
StorageNotifierRunnable
(
event
aStorageType
aIsPrivate
)
;
if
(
aImmediateDispatch
)
{
Unused
<
<
r
-
>
Run
(
)
;
}
else
{
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
}
}
}
}
