#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
Navigator
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
WakeLockBinding
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsContentPermissionHelper
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
WakeLock
.
h
"
#
include
"
WakeLockJS
.
h
"
#
include
"
WakeLockSentinel
.
h
"
namespace
mozilla
:
:
dom
{
static
mozilla
:
:
LazyLogModule
sLogger
(
"
ScreenWakeLock
"
)
;
#
define
MIN_BATTERY_LEVEL
0
.
05
nsLiteralCString
WakeLockJS
:
:
GetRequestErrorMessage
(
RequestError
aRv
)
{
switch
(
aRv
)
{
case
RequestError
:
:
DocInactive
:
return
"
The
requesting
document
is
inactive
.
"
_ns
;
case
RequestError
:
:
DocHidden
:
return
"
The
requesting
document
is
hidden
.
"
_ns
;
case
RequestError
:
:
PolicyDisallowed
:
return
"
A
permissions
policy
does
not
allow
screen
-
wake
-
lock
for
the
requesting
document
.
"
_ns
;
case
RequestError
:
:
PrefDisabled
:
return
"
The
pref
dom
.
screenwakelock
.
enabled
is
disabled
.
"
_ns
;
case
RequestError
:
:
InternalFailure
:
return
"
A
browser
-
internal
error
occured
.
"
_ns
;
case
RequestError
:
:
PermissionDenied
:
return
"
Permission
to
request
screen
-
wake
-
lock
was
denied
.
"
_ns
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
error
reason
"
)
;
return
"
Unknown
error
"
_ns
;
}
}
WakeLockJS
:
:
RequestError
WakeLockJS
:
:
WakeLockAllowedForDocument
(
Document
*
aDoc
)
{
if
(
!
aDoc
)
{
return
RequestError
:
:
InternalFailure
;
}
if
(
!
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
aDoc
u
"
screen
-
wake
-
lock
"
_ns
)
)
{
return
RequestError
:
:
PolicyDisallowed
;
}
if
(
!
StaticPrefs
:
:
dom_screenwakelock_enabled
(
)
)
{
return
RequestError
:
:
PrefDisabled
;
}
if
(
!
aDoc
-
>
IsActive
(
)
)
{
return
RequestError
:
:
DocInactive
;
}
if
(
aDoc
-
>
Hidden
(
)
)
{
return
RequestError
:
:
DocHidden
;
}
return
RequestError
:
:
Success
;
}
static
bool
IsWakeLockApplicable
(
WakeLockType
aType
)
{
hal
:
:
BatteryInformation
batteryInfo
;
hal
:
:
GetCurrentBatteryInformation
(
&
batteryInfo
)
;
if
(
batteryInfo
.
level
(
)
<
=
MIN_BATTERY_LEVEL
&
&
!
batteryInfo
.
charging
(
)
)
{
return
false
;
}
return
aType
=
=
WakeLockType
:
:
Screen
;
}
void
ReleaseWakeLock
(
Document
*
aDoc
WakeLockSentinel
*
aLock
WakeLockType
aType
)
{
MOZ_ASSERT
(
aLock
)
;
MOZ_ASSERT
(
aDoc
)
;
RefPtr
<
WakeLockSentinel
>
kungFuDeathGrip
=
aLock
;
aDoc
-
>
ActiveWakeLocks
(
aType
)
.
Remove
(
aLock
)
;
aLock
-
>
NotifyLockReleased
(
)
;
MOZ_LOG
(
sLogger
LogLevel
:
:
Debug
(
"
Released
wake
lock
sentinel
"
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
WakeLockJS
mWindow
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WakeLockJS
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WakeLockJS
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WakeLockJS
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentActivity
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
WakeLockJS
:
:
WakeLockJS
(
nsPIDOMWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
{
AttachListeners
(
)
;
}
WakeLockJS
:
:
~
WakeLockJS
(
)
{
DetachListeners
(
)
;
}
nsISupports
*
WakeLockJS
:
:
GetParentObject
(
)
const
{
return
mWindow
;
}
JSObject
*
WakeLockJS
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WakeLock_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
Result
<
already_AddRefed
<
WakeLockSentinel
>
WakeLockJS
:
:
RequestError
>
WakeLockJS
:
:
Obtain
(
WakeLockType
aType
)
{
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
Err
(
RequestError
:
:
InternalFailure
)
;
}
if
(
doc
-
>
Hidden
(
)
)
{
return
Err
(
RequestError
:
:
DocHidden
)
;
}
RefPtr
<
WakeLockSentinel
>
lock
=
MakeRefPtr
<
WakeLockSentinel
>
(
mWindow
-
>
AsGlobal
(
)
aType
)
;
if
(
IsWakeLockApplicable
(
aType
)
)
{
lock
-
>
AcquireActualLock
(
)
;
}
doc
-
>
ActiveWakeLocks
(
aType
)
.
Insert
(
lock
)
;
return
lock
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WakeLockJS
:
:
Request
(
WakeLockType
aType
ErrorResult
&
aRv
)
{
MOZ_LOG
(
sLogger
LogLevel
:
:
Debug
(
"
Received
request
for
wake
lock
"
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
mWindow
-
>
AsGlobal
(
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
NS_ENSURE_FALSE
(
aRv
.
Failed
(
)
nullptr
)
;
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
RequestError
rv
=
WakeLockAllowedForDocument
(
doc
)
;
if
(
rv
!
=
RequestError
:
:
Success
)
{
promise
-
>
MaybeRejectWithNotAllowedError
(
GetRequestErrorMessage
(
rv
)
)
;
return
promise
.
forget
(
)
;
}
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ObtainWakeLock
"
[
aType
promise
self
=
RefPtr
<
WakeLockJS
>
(
this
)
]
(
)
{
auto
lockOrErr
=
self
-
>
Obtain
(
aType
)
;
if
(
lockOrErr
.
isOk
(
)
)
{
RefPtr
<
WakeLockSentinel
>
lock
=
lockOrErr
.
unwrap
(
)
;
promise
-
>
MaybeResolve
(
lock
)
;
MOZ_LOG
(
sLogger
LogLevel
:
:
Debug
(
"
Resolved
promise
with
wake
lock
sentinel
"
)
)
;
}
else
{
promise
-
>
MaybeRejectWithNotAllowedError
(
GetRequestErrorMessage
(
lockOrErr
.
unwrapErr
(
)
)
)
;
}
}
)
)
;
return
promise
.
forget
(
)
;
}
void
WakeLockJS
:
:
AttachListeners
(
)
{
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
DebugOnly
<
nsresult
>
rv
=
doc
-
>
AddSystemEventListener
(
u
"
visibilitychange
"
_ns
this
true
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
doc
-
>
RegisterActivityObserver
(
ToSupports
(
this
)
)
;
hal
:
:
RegisterBatteryObserver
(
this
)
;
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
MOZ_ASSERT
(
prefBranch
)
;
rv
=
prefBranch
-
>
AddObserver
(
"
dom
.
screenwakelock
.
enabled
"
this
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
WakeLockJS
:
:
DetachListeners
(
)
{
if
(
mWindow
)
{
if
(
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
)
{
doc
-
>
RemoveSystemEventListener
(
u
"
visibilitychange
"
_ns
this
true
)
;
doc
-
>
UnregisterActivityObserver
(
ToSupports
(
this
)
)
;
}
}
hal
:
:
UnregisterBatteryObserver
(
this
)
;
if
(
nsCOMPtr
<
nsIPrefBranch
>
prefBranch
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
)
{
prefBranch
-
>
RemoveObserver
(
"
dom
.
screenwakelock
.
enabled
"
this
)
;
}
}
NS_IMETHODIMP
WakeLockJS
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
=
=
0
)
{
if
(
!
StaticPrefs
:
:
dom_screenwakelock_enabled
(
)
)
{
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
doc
-
>
UnlockAllWakeLocks
(
WakeLockType
:
:
Screen
)
;
}
}
return
NS_OK
;
}
void
WakeLockJS
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
if
(
!
doc
-
>
IsActive
(
)
)
{
doc
-
>
UnlockAllWakeLocks
(
WakeLockType
:
:
Screen
)
;
}
}
NS_IMETHODIMP
WakeLockJS
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsAutoString
type
;
aEvent
-
>
GetType
(
type
)
;
if
(
type
.
EqualsLiteral
(
"
visibilitychange
"
)
)
{
nsCOMPtr
<
Document
>
doc
=
do_QueryInterface
(
aEvent
-
>
GetTarget
(
)
)
;
NS_ENSURE_STATE
(
doc
)
;
if
(
doc
-
>
Hidden
(
)
)
{
doc
-
>
UnlockAllWakeLocks
(
WakeLockType
:
:
Screen
)
;
}
}
return
NS_OK
;
}
void
WakeLockJS
:
:
Notify
(
const
hal
:
:
BatteryInformation
&
aBatteryInfo
)
{
if
(
aBatteryInfo
.
level
(
)
>
MIN_BATTERY_LEVEL
|
|
aBatteryInfo
.
charging
(
)
)
{
return
;
}
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetExtantDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
doc
-
>
UnlockAllWakeLocks
(
WakeLockType
:
:
Screen
)
;
}
}
