#
include
"
WorkerCSPContext
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPParser
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
:
:
dom
{
Result
<
UniquePtr
<
WorkerCSPContext
>
nsresult
>
WorkerCSPContext
:
:
CreateFromCSP
(
nsIContentSecurityPolicy
*
aCSP
)
{
AssertIsOnMainThread
(
)
;
mozilla
:
:
ipc
:
:
CSPInfo
cspInfo
;
nsresult
rv
=
CSPToCSPInfo
(
aCSP
&
cspInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
return
MakeUnique
<
WorkerCSPContext
>
(
std
:
:
move
(
cspInfo
)
)
;
}
const
nsTArray
<
UniquePtr
<
const
nsCSPPolicy
>
>
&
WorkerCSPContext
:
:
Policies
(
)
{
EnsureIPCPoliciesRead
(
)
;
return
mPolicies
;
}
bool
WorkerCSPContext
:
:
IsEvalAllowed
(
bool
&
aReportViolation
)
{
MOZ_ASSERT
(
!
aReportViolation
)
;
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
const
mozilla
:
:
ipc
:
:
CSPInfo
&
cspInfo
=
workerPrivate
-
>
GetCSPInfo
(
)
;
bool
trustedTypesRequired
=
(
cspInfo
.
requireTrustedTypesForDirectiveState
(
)
=
=
RequireTrustedTypesForDirectiveState
:
:
ENFORCE
)
;
for
(
const
UniquePtr
<
const
nsCSPPolicy
>
&
policy
:
Policies
(
)
)
{
if
(
!
(
trustedTypesRequired
&
&
policy
-
>
allows
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
CSP_TRUSTED_TYPES_EVAL
u
"
"
_ns
)
)
&
&
!
policy
-
>
allows
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
CSP_UNSAFE_EVAL
u
"
"
_ns
)
)
{
aReportViolation
=
true
;
if
(
!
policy
-
>
getReportOnlyFlag
(
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
WorkerCSPContext
:
:
IsWasmEvalAllowed
(
bool
&
aReportViolation
)
{
MOZ_ASSERT
(
!
aReportViolation
)
;
for
(
const
UniquePtr
<
const
nsCSPPolicy
>
&
policy
:
Policies
(
)
)
{
if
(
!
policy
-
>
allows
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
CSP_WASM_UNSAFE_EVAL
u
"
"
_ns
)
&
&
!
policy
-
>
allows
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
CSP_UNSAFE_EVAL
u
"
"
_ns
)
)
{
aReportViolation
=
true
;
if
(
!
policy
-
>
getReportOnlyFlag
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
WorkerCSPContext
:
:
EnsureIPCPoliciesRead
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
!
GetCurrentThreadWorkerPrivate
(
)
)
;
if
(
!
mPolicies
.
IsEmpty
(
)
|
|
mCSPInfo
.
policyInfos
(
)
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
selfURI
;
if
(
NS_WARN_IF
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
selfURI
)
mCSPInfo
.
selfURISpec
(
)
)
)
)
)
{
return
;
}
for
(
const
auto
&
policy
:
mCSPInfo
.
policyInfos
(
)
)
{
UniquePtr
<
const
nsCSPPolicy
>
cspPolicy
(
nsCSPParser
:
:
parseContentSecurityPolicy
(
policy
.
policy
(
)
selfURI
policy
.
reportOnlyFlag
(
)
nullptr
policy
.
deliveredViaMetaTagFlag
(
)
true
)
)
;
if
(
cspPolicy
)
{
mPolicies
.
AppendElement
(
std
:
:
move
(
cspPolicy
)
)
;
}
}
}
}
