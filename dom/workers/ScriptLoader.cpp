#
include
"
ScriptLoader
.
h
"
#
include
<
algorithm
>
#
include
<
type_traits
>
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIStreamListenerTee
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
Exception
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIPipe
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
mozilla
/
AntiTrackingUtils
.
h
"
#
include
"
mozilla
/
ArrayAlgorithm
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
LoadContext
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
dom
/
ClientChannelHelper
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
Exceptions
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPService
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceStorage
.
h
"
#
include
"
mozilla
/
dom
/
Response
.
h
"
#
include
"
mozilla
/
dom
/
ReferrerInfo
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
SerializedStackHolder
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
CacheLoadHandler
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
NetworkLoadHandler
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
ScriptResponseHeaderProcessor
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
WorkerScope
.
h
"
#
define
MAX_CONCURRENT_SCRIPTS
1000
using
JS
:
:
loader
:
:
ParserMetadata
;
using
JS
:
:
loader
:
:
ScriptKind
;
using
JS
:
:
loader
:
:
ScriptLoadRequest
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
namespace
mozilla
:
:
dom
:
:
workerinternals
{
namespace
{
nsresult
ConstructURI
(
const
nsAString
&
aScriptURL
nsIURI
*
baseURI
const
mozilla
:
:
Encoding
*
aDocumentEncoding
nsIURI
*
*
aResult
)
{
nsresult
rv
;
if
(
aDocumentEncoding
)
{
nsAutoCString
charset
;
aDocumentEncoding
-
>
Name
(
charset
)
;
rv
=
NS_NewURI
(
aResult
aScriptURL
charset
.
get
(
)
baseURI
)
;
}
else
{
rv
=
NS_NewURI
(
aResult
aScriptURL
nullptr
baseURI
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
return
NS_OK
;
}
nsresult
ChannelFromScriptURL
(
nsIPrincipal
*
principal
Document
*
parentDoc
WorkerPrivate
*
aWorkerPrivate
nsILoadGroup
*
loadGroup
nsIIOService
*
ios
nsIScriptSecurityManager
*
secMan
nsIURI
*
aScriptURL
const
Maybe
<
ClientInfo
>
&
aClientInfo
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
bool
aIsMainScript
WorkerScriptType
aWorkerScriptType
nsContentPolicyType
aContentPolicyType
nsLoadFlags
aLoadFlags
uint32_t
aSecFlags
nsICookieJarSettings
*
aCookieJarSettings
nsIReferrerInfo
*
aReferrerInfo
nsIChannel
*
*
aChannel
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
=
aScriptURL
;
if
(
parentDoc
&
&
parentDoc
-
>
NodePrincipal
(
)
!
=
principal
)
{
parentDoc
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aContentPolicyType
!
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
parentDoc
)
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
parentDoc
aSecFlags
aContentPolicyType
nullptr
loadGroup
nullptr
aLoadFlags
ios
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_DOM_SECURITY_ERR
)
;
}
else
{
MOZ_ASSERT
(
loadGroup
)
;
MOZ_ASSERT
(
NS_LoadGroupMatchesPrincipal
(
loadGroup
principal
)
)
;
RefPtr
<
PerformanceStorage
>
performanceStorage
;
nsCOMPtr
<
nsICSPEventListener
>
cspEventListener
;
if
(
aWorkerPrivate
&
&
!
aIsMainScript
)
{
performanceStorage
=
aWorkerPrivate
-
>
GetPerformanceStorage
(
)
;
cspEventListener
=
aWorkerPrivate
-
>
CSPEventListener
(
)
;
}
if
(
aClientInfo
.
isSome
(
)
)
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
principal
aClientInfo
.
ref
(
)
aController
aSecFlags
aContentPolicyType
aCookieJarSettings
performanceStorage
loadGroup
nullptr
aLoadFlags
ios
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
principal
aSecFlags
aContentPolicyType
aCookieJarSettings
performanceStorage
loadGroup
nullptr
aLoadFlags
ios
)
;
}
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_DOM_SECURITY_ERR
)
;
if
(
cspEventListener
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
rv
=
loadInfo
-
>
SetCspEventListener
(
cspEventListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
aReferrerInfo
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetReferrerInfo
(
aReferrerInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
channel
.
forget
(
aChannel
)
;
return
rv
;
}
void
LoadAllScripts
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
const
nsTArray
<
nsString
>
&
aScriptURLs
bool
aIsMainScript
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
const
mozilla
:
:
Encoding
*
aDocumentEncoding
=
nullptr
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
NS_ASSERTION
(
!
aScriptURLs
.
IsEmpty
(
)
"
Bad
arguments
!
"
)
;
AutoSyncLoopHolder
syncLoop
(
aWorkerPrivate
Canceling
)
;
nsCOMPtr
<
nsISerialEventTarget
>
syncLoopTarget
=
syncLoop
.
GetSerialEventTarget
(
)
;
if
(
!
syncLoopTarget
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
RefPtr
<
loader
:
:
WorkerScriptLoader
>
loader
=
loader
:
:
WorkerScriptLoader
:
:
Create
(
aWorkerPrivate
std
:
:
move
(
aOriginStack
)
syncLoopTarget
aWorkerScriptType
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
bool
ok
=
loader
-
>
CreateScriptRequests
(
aScriptURLs
aDocumentEncoding
aIsMainScript
)
;
if
(
!
ok
)
{
return
;
}
if
(
aWorkerPrivate
-
>
WorkerType
(
)
=
=
WorkerType
:
:
Module
&
&
aWorkerScriptType
!
=
DebuggerScript
)
{
MOZ_ASSERT
(
aIsMainScript
)
;
RefPtr
<
JS
:
:
loader
:
:
ScriptLoadRequest
>
mainScript
=
loader
-
>
GetMainScript
(
)
;
if
(
mainScript
&
&
mainScript
-
>
IsModuleRequest
(
)
)
{
if
(
NS_FAILED
(
mainScript
-
>
AsModuleRequest
(
)
-
>
StartModuleLoad
(
)
)
)
{
return
;
}
syncLoop
.
Run
(
)
;
return
;
}
}
if
(
loader
-
>
DispatchLoadScripts
(
)
)
{
syncLoop
.
Run
(
)
;
}
}
class
ChannelGetterRunnable
final
:
public
WorkerMainThreadRunnable
{
const
nsAString
&
mScriptURL
;
const
WorkerType
&
mWorkerType
;
const
RequestCredentials
&
mCredentials
;
const
ClientInfo
mClientInfo
;
WorkerLoadInfo
&
mLoadInfo
;
nsresult
mResult
;
public
:
ChannelGetterRunnable
(
WorkerPrivate
*
aParentWorker
const
nsAString
&
aScriptURL
const
WorkerType
&
aWorkerType
const
RequestCredentials
&
aCredentials
WorkerLoadInfo
&
aLoadInfo
)
:
WorkerMainThreadRunnable
(
aParentWorker
"
ScriptLoader
:
:
ChannelGetter
"
_ns
)
mScriptURL
(
aScriptURL
)
mWorkerType
(
aWorkerType
)
mCredentials
(
aCredentials
)
mClientInfo
(
aParentWorker
-
>
GlobalScope
(
)
-
>
GetClientInfo
(
)
.
ref
(
)
)
mLoadInfo
(
aLoadInfo
)
mResult
(
NS_ERROR_FAILURE
)
{
MOZ_ASSERT
(
aParentWorker
)
;
aParentWorker
-
>
AssertIsOnWorkerThread
(
)
;
}
virtual
bool
MainThreadRun
(
)
override
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mWorkerRef
)
;
WorkerPrivate
*
workerPrivate
=
mWorkerRef
-
>
Private
(
)
;
mLoadInfo
.
mLoadingPrincipal
=
workerPrivate
-
>
GetPrincipal
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mLoadInfo
.
mLoadingPrincipal
)
;
mLoadInfo
.
mPrincipal
=
mLoadInfo
.
mLoadingPrincipal
;
nsCOMPtr
<
nsIURI
>
baseURI
=
workerPrivate
-
>
GetBaseURI
(
)
;
MOZ_ASSERT
(
baseURI
)
;
nsCOMPtr
<
Document
>
parentDoc
=
workerPrivate
-
>
GetDocument
(
)
;
mLoadInfo
.
mLoadGroup
=
workerPrivate
-
>
GetLoadGroup
(
)
;
mLoadInfo
.
mCookieJarSettings
=
workerPrivate
-
>
CookieJarSettings
(
)
;
nsCOMPtr
<
nsIURI
>
url
;
mResult
=
ConstructURI
(
mScriptURL
baseURI
nullptr
getter_AddRefs
(
url
)
)
;
NS_ENSURE_SUCCESS
(
mResult
true
)
;
Maybe
<
ClientInfo
>
clientInfo
;
clientInfo
.
emplace
(
mClientInfo
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForFetch
(
mLoadInfo
.
mLoadingPrincipal
nullptr
)
;
mLoadInfo
.
mReferrerInfo
=
static_cast
<
ReferrerInfo
*
>
(
referrerInfo
.
get
(
)
)
-
>
CloneWithNewPolicy
(
workerPrivate
-
>
GetReferrerPolicy
(
)
)
;
mResult
=
workerinternals
:
:
ChannelFromScriptURLMainThread
(
mLoadInfo
.
mLoadingPrincipal
parentDoc
mLoadInfo
.
mLoadGroup
url
mWorkerType
mCredentials
clientInfo
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
mLoadInfo
.
mCookieJarSettings
mLoadInfo
.
mReferrerInfo
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
mResult
true
)
;
mResult
=
mLoadInfo
.
SetPrincipalsAndCSPFromChannel
(
channel
)
;
NS_ENSURE_SUCCESS
(
mResult
true
)
;
mLoadInfo
.
mChannel
=
std
:
:
move
(
channel
)
;
return
true
;
}
nsresult
GetResult
(
)
const
{
return
mResult
;
}
private
:
virtual
~
ChannelGetterRunnable
(
)
=
default
;
}
;
nsresult
GetCommonSecFlags
(
bool
aIsMainScript
nsIURI
*
uri
nsIPrincipal
*
principal
WorkerScriptType
aWorkerScriptType
uint32_t
&
secFlags
)
{
bool
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
principal
uri
true
false
)
;
bool
isData
=
uri
-
>
SchemeIs
(
"
data
"
)
;
if
(
inheritAttrs
&
&
!
isData
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
if
(
aWorkerScriptType
=
=
DebuggerScript
)
{
bool
isUIResource
=
false
;
nsresult
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
isUIResource
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isUIResource
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
secFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
}
if
(
aIsMainScript
&
&
isData
)
{
secFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
;
}
return
NS_OK
;
}
nsresult
GetModuleSecFlags
(
bool
aIsTopLevel
nsIPrincipal
*
principal
WorkerScriptType
aWorkerScriptType
nsIURI
*
aURI
RequestCredentials
aCredentials
uint32_t
&
secFlags
)
{
secFlags
=
aIsTopLevel
?
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_INHERITS_SEC_CONTEXT
;
if
(
aCredentials
=
=
RequestCredentials
:
:
Include
)
{
secFlags
|
=
nsILoadInfo
:
:
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
else
if
(
aCredentials
=
=
RequestCredentials
:
:
Same_origin
)
{
secFlags
|
=
nsILoadInfo
:
:
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
aCredentials
=
=
RequestCredentials
:
:
Omit
)
{
secFlags
|
=
nsILoadInfo
:
:
nsILoadInfo
:
:
SEC_COOKIES_OMIT
;
}
return
GetCommonSecFlags
(
aIsTopLevel
aURI
principal
aWorkerScriptType
secFlags
)
;
}
nsresult
GetClassicSecFlags
(
bool
aIsMainScript
nsIURI
*
uri
nsIPrincipal
*
principal
WorkerScriptType
aWorkerScriptType
uint32_t
&
secFlags
)
{
secFlags
=
aIsMainScript
?
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
:
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
;
return
GetCommonSecFlags
(
aIsMainScript
uri
principal
aWorkerScriptType
secFlags
)
;
}
}
namespace
loader
{
class
ScriptExecutorRunnable
final
:
public
MainThreadWorkerSyncRunnable
{
RefPtr
<
WorkerScriptLoader
>
mScriptLoader
;
const
Span
<
RefPtr
<
ThreadSafeRequestHandle
>
>
mLoadedRequests
;
public
:
ScriptExecutorRunnable
(
WorkerScriptLoader
*
aScriptLoader
WorkerPrivate
*
aWorkerPrivate
nsISerialEventTarget
*
aSyncLoopTarget
Span
<
RefPtr
<
ThreadSafeRequestHandle
>
>
aLoadedRequests
)
;
private
:
~
ScriptExecutorRunnable
(
)
=
default
;
virtual
bool
IsDebuggerRunnable
(
)
const
override
;
virtual
bool
PreRun
(
WorkerPrivate
*
aWorkerPrivate
)
override
;
bool
ProcessModuleScript
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
bool
ProcessClassicScripts
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
;
nsresult
Cancel
(
)
override
;
}
;
static
bool
EvaluateSourceBuffer
(
JSContext
*
aCx
JS
:
:
Handle
<
JSScript
*
>
aScript
JS
:
:
loader
:
:
ClassicScript
*
aClassicScript
)
{
if
(
aClassicScript
)
{
aClassicScript
-
>
AssociateWithScript
(
aScript
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
unused
(
aCx
)
;
return
JS_ExecuteScript
(
aCx
aScript
&
unused
)
;
}
WorkerScriptLoader
:
:
WorkerScriptLoader
(
UniquePtr
<
SerializedStackHolder
>
aOriginStack
nsISerialEventTarget
*
aSyncLoopTarget
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
)
:
mOriginStack
(
std
:
:
move
(
aOriginStack
)
)
mSyncLoopTarget
(
aSyncLoopTarget
)
mWorkerScriptType
(
aWorkerScriptType
)
mRv
(
aRv
)
mLoadingModuleRequestCount
(
0
)
mCleanedUp
(
false
)
mCleanUpLock
(
"
cleanUpLock
"
)
{
}
already_AddRefed
<
WorkerScriptLoader
>
WorkerScriptLoader
:
:
Create
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
nsISerialEventTarget
*
aSyncLoopTarget
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
WorkerScriptLoader
>
self
=
new
WorkerScriptLoader
(
std
:
:
move
(
aOriginStack
)
aSyncLoopTarget
aWorkerScriptType
aRv
)
;
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
aWorkerPrivate
"
WorkerScriptLoader
:
:
Create
"
[
self
]
(
)
{
self
-
>
TryShutdown
(
)
;
}
)
;
if
(
workerRef
)
{
self
-
>
mWorkerRef
=
new
ThreadSafeWorkerRef
(
workerRef
)
;
}
else
{
self
-
>
mRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsIGlobalObject
*
global
=
self
-
>
GetGlobal
(
)
;
self
-
>
mController
=
global
-
>
GetController
(
)
;
self
-
>
InitModuleLoader
(
)
;
return
self
.
forget
(
)
;
}
ScriptLoadRequest
*
WorkerScriptLoader
:
:
GetMainScript
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
ScriptLoadRequest
*
request
=
mLoadingRequests
.
getFirst
(
)
;
if
(
request
-
>
GetWorkerLoadContext
(
)
-
>
IsTopLevel
(
)
)
{
return
request
;
}
return
nullptr
;
}
void
WorkerScriptLoader
:
:
InitModuleLoader
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
GetGlobal
(
)
-
>
GetModuleLoader
(
nullptr
)
)
{
return
;
}
RefPtr
<
WorkerModuleLoader
>
moduleLoader
=
new
WorkerModuleLoader
(
this
GetGlobal
(
)
)
;
if
(
mWorkerScriptType
=
=
WorkerScript
)
{
mWorkerRef
-
>
Private
(
)
-
>
GlobalScope
(
)
-
>
InitModuleLoader
(
moduleLoader
)
;
return
;
}
mWorkerRef
-
>
Private
(
)
-
>
DebuggerGlobalScope
(
)
-
>
InitModuleLoader
(
moduleLoader
)
;
}
bool
WorkerScriptLoader
:
:
CreateScriptRequests
(
const
nsTArray
<
nsString
>
&
aScriptURLs
const
mozilla
:
:
Encoding
*
aDocumentEncoding
bool
aIsMainScript
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
mWorkerRef
-
>
Private
(
)
-
>
WorkerType
(
)
=
=
WorkerType
:
:
Module
&
&
!
aIsMainScript
&
&
!
IsDebuggerScript
(
)
)
{
mRv
.
ThrowTypeError
(
"
Using
ImportScripts
inside
a
Module
Worker
is
"
"
disallowed
.
"
)
;
return
false
;
}
for
(
const
nsString
&
scriptURL
:
aScriptURLs
)
{
RefPtr
<
ScriptLoadRequest
>
request
=
CreateScriptLoadRequest
(
scriptURL
aDocumentEncoding
aIsMainScript
)
;
if
(
!
request
)
{
return
false
;
}
mLoadingRequests
.
AppendElement
(
request
)
;
}
return
true
;
}
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
WorkerScriptLoader
:
:
GetLoadingList
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
list
;
for
(
ScriptLoadRequest
*
req
=
mLoadingRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
RefPtr
<
ThreadSafeRequestHandle
>
handle
=
new
ThreadSafeRequestHandle
(
req
mSyncLoopTarget
.
get
(
)
)
;
list
.
AppendElement
(
handle
.
forget
(
)
)
;
}
return
list
;
}
bool
WorkerScriptLoader
:
:
IsDynamicImport
(
ScriptLoadRequest
*
aRequest
)
{
return
aRequest
-
>
IsModuleRequest
(
)
&
&
aRequest
-
>
AsModuleRequest
(
)
-
>
IsDynamicImport
(
)
;
}
nsContentPolicyType
WorkerScriptLoader
:
:
GetContentPolicyType
(
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
GetWorkerLoadContext
(
)
-
>
IsTopLevel
(
)
)
{
return
mWorkerRef
-
>
Private
(
)
-
>
ContentPolicyType
(
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
if
(
aRequest
-
>
AsModuleRequest
(
)
-
>
IsDynamicImport
(
)
)
{
return
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
;
}
return
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_STATIC_MODULE
;
}
return
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
;
}
already_AddRefed
<
ScriptLoadRequest
>
WorkerScriptLoader
:
:
CreateScriptLoadRequest
(
const
nsString
&
aScriptURL
const
mozilla
:
:
Encoding
*
aDocumentEncoding
bool
aIsMainScript
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
WorkerLoadContext
:
:
Kind
kind
=
WorkerLoadContext
:
:
GetKind
(
aIsMainScript
IsDebuggerScript
(
)
)
;
Maybe
<
ClientInfo
>
clientInfo
=
GetGlobal
(
)
-
>
GetClientInfo
(
)
;
bool
onlyExistingCachedResourcesAllowed
=
false
;
if
(
mWorkerRef
-
>
Private
(
)
-
>
IsServiceWorker
(
)
)
{
onlyExistingCachedResourcesAllowed
=
mWorkerRef
-
>
Private
(
)
-
>
GetServiceWorkerDescriptor
(
)
.
State
(
)
>
ServiceWorkerState
:
:
Installing
;
}
RefPtr
<
WorkerLoadContext
>
loadContext
=
new
WorkerLoadContext
(
kind
clientInfo
this
onlyExistingCachedResourcesAllowed
)
;
ReferrerPolicy
referrerPolicy
=
mWorkerRef
-
>
Private
(
)
-
>
GetReferrerPolicy
(
)
;
MOZ_ASSERT_IF
(
bool
(
aDocumentEncoding
)
aIsMainScript
&
&
!
mWorkerRef
-
>
Private
(
)
-
>
GetParent
(
)
)
;
nsCOMPtr
<
nsIURI
>
baseURI
=
aIsMainScript
?
GetInitialBaseURI
(
)
:
GetBaseURI
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
bool
setErrorResult
=
false
;
nsresult
rv
=
ConstructURI
(
aScriptURL
baseURI
aDocumentEncoding
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
setErrorResult
=
true
;
loadContext
-
>
mLoadResult
=
rv
;
}
RefPtr
<
ScriptFetchOptions
>
fetchOptions
=
new
ScriptFetchOptions
(
CORSMode
:
:
CORS_NONE
u
"
"
_ns
RequestPriority
:
:
Auto
ParserMetadata
:
:
NotParserInserted
nullptr
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
nullptr
;
if
(
mWorkerRef
-
>
Private
(
)
-
>
WorkerType
(
)
=
=
WorkerType
:
:
Classic
|
|
IsDebuggerScript
(
)
)
{
request
=
new
ScriptLoadRequest
(
ScriptKind
:
:
eClassic
uri
referrerPolicy
fetchOptions
SRIMetadata
(
)
nullptr
loadContext
)
;
}
else
{
RefPtr
<
WorkerModuleLoader
:
:
ModuleLoaderBase
>
moduleLoader
=
GetGlobal
(
)
-
>
GetModuleLoader
(
nullptr
)
;
nsCOMPtr
<
nsIURI
>
referrer
=
mWorkerRef
-
>
Private
(
)
-
>
GetReferrerInfo
(
)
-
>
GetOriginalReferrer
(
)
;
RefPtr
<
JS
:
:
loader
:
:
VisitedURLSet
>
visitedSet
=
ModuleLoadRequest
:
:
NewVisitedSetForTopLevelImport
(
uri
JS
:
:
ModuleType
:
:
JavaScript
)
;
request
=
new
ModuleLoadRequest
(
uri
JS
:
:
ModuleType
:
:
JavaScript
referrerPolicy
fetchOptions
SRIMetadata
(
)
referrer
loadContext
ModuleLoadRequest
:
:
Kind
:
:
TopLevel
moduleLoader
visitedSet
nullptr
)
;
}
request
-
>
mURL
=
NS_ConvertUTF16toUTF8
(
aScriptURL
)
;
if
(
setErrorResult
)
{
request
-
>
SetPendingFetchingError
(
)
;
}
else
{
request
-
>
NoCacheEntryFound
(
)
;
}
return
request
.
forget
(
)
;
}
bool
WorkerScriptLoader
:
:
DispatchLoadScript
(
ScriptLoadRequest
*
aRequest
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
IncreaseLoadingModuleRequestCount
(
)
;
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
scriptLoadList
;
RefPtr
<
ThreadSafeRequestHandle
>
handle
=
new
ThreadSafeRequestHandle
(
aRequest
mSyncLoopTarget
.
get
(
)
)
;
scriptLoadList
.
AppendElement
(
handle
.
forget
(
)
)
;
RefPtr
<
ScriptLoaderRunnable
>
runnable
=
new
ScriptLoaderRunnable
(
this
std
:
:
move
(
scriptLoadList
)
)
;
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
mWorkerRef
-
>
Private
(
)
"
WorkerScriptLoader
:
:
DispatchLoadScript
"
[
runnable
]
(
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ScriptLoaderRunnable
:
:
CancelMainThreadWithBindingAborted
"
runnable
&
ScriptLoaderRunnable
:
:
CancelMainThreadWithBindingAborted
)
)
;
}
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
)
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
!
"
)
;
mRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
return
true
;
}
bool
WorkerScriptLoader
:
:
DispatchLoadScripts
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
scriptLoadList
=
GetLoadingList
(
)
;
RefPtr
<
ScriptLoaderRunnable
>
runnable
=
new
ScriptLoaderRunnable
(
this
std
:
:
move
(
scriptLoadList
)
)
;
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
mWorkerRef
-
>
Private
(
)
"
WorkerScriptLoader
:
:
DispatchLoadScripts
"
[
runnable
]
(
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ScriptLoaderRunnable
:
:
CancelMainThreadWithBindingAborted
"
runnable
&
ScriptLoaderRunnable
:
:
CancelMainThreadWithBindingAborted
)
)
;
}
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
)
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
!
"
)
;
mRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
return
true
;
}
nsIURI
*
WorkerScriptLoader
:
:
GetInitialBaseURI
(
)
{
MOZ_ASSERT
(
mWorkerRef
-
>
Private
(
)
)
;
nsIURI
*
baseURI
;
WorkerPrivate
*
parentWorker
=
mWorkerRef
-
>
Private
(
)
-
>
GetParent
(
)
;
if
(
parentWorker
)
{
baseURI
=
parentWorker
-
>
GetBaseURI
(
)
;
}
else
{
baseURI
=
mWorkerRef
-
>
Private
(
)
-
>
GetBaseURI
(
)
;
}
return
baseURI
;
}
nsIURI
*
WorkerScriptLoader
:
:
GetBaseURI
(
)
const
{
MOZ_ASSERT
(
mWorkerRef
)
;
nsIURI
*
baseURI
;
baseURI
=
mWorkerRef
-
>
Private
(
)
-
>
GetBaseURI
(
)
;
NS_ASSERTION
(
baseURI
"
Should
have
been
set
already
!
"
)
;
return
baseURI
;
}
nsIGlobalObject
*
WorkerScriptLoader
:
:
GetGlobal
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
return
mWorkerScriptType
=
=
WorkerScript
?
static_cast
<
nsIGlobalObject
*
>
(
mWorkerRef
-
>
Private
(
)
-
>
GlobalScope
(
)
)
:
mWorkerRef
-
>
Private
(
)
-
>
DebuggerGlobalScope
(
)
;
}
void
WorkerScriptLoader
:
:
MaybeMoveToLoadedList
(
ScriptLoadRequest
*
aRequest
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
!
aRequest
-
>
IsModuleRequest
(
)
)
{
aRequest
-
>
SetReady
(
)
;
}
MOZ_RELEASE_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
while
(
!
mLoadingRequests
.
isEmpty
(
)
)
{
ScriptLoadRequest
*
request
=
mLoadingRequests
.
getFirst
(
)
;
if
(
!
request
-
>
IsFinished
(
)
)
{
break
;
}
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingRequests
.
Steal
(
request
)
;
mLoadedRequests
.
AppendElement
(
req
)
;
}
}
bool
WorkerScriptLoader
:
:
StoreCSP
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
!
mWorkerRef
-
>
Private
(
)
-
>
GetJSContext
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
mRv
.
Failed
(
)
)
;
mWorkerRef
-
>
Private
(
)
-
>
StoreCSPOnClient
(
)
;
return
true
;
}
bool
WorkerScriptLoader
:
:
ProcessPendingRequests
(
JSContext
*
aCx
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
mExecutionAborted
)
{
mLoadedRequests
.
CancelRequestsAndClear
(
)
;
TryShutdown
(
)
;
return
true
;
}
MOZ_ASSERT
(
!
mRv
.
Failed
(
)
"
Who
failed
it
and
why
?
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
MOZ_ASSERT
(
global
)
;
while
(
!
mLoadedRequests
.
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadedRequests
.
StealFirst
(
)
;
if
(
!
EvaluateScript
(
aCx
req
)
)
{
req
-
>
Cancel
(
)
;
mExecutionAborted
=
true
;
WorkerLoadContext
*
loadContext
=
req
-
>
GetWorkerLoadContext
(
)
;
mMutedErrorFlag
=
loadContext
-
>
mMutedErrorFlag
.
valueOr
(
true
)
;
mLoadedRequests
.
CancelRequestsAndClear
(
)
;
break
;
}
}
TryShutdown
(
)
;
return
true
;
}
nsresult
WorkerScriptLoader
:
:
LoadScript
(
ThreadSafeRequestHandle
*
aRequestHandle
)
{
AssertIsOnMainThread
(
)
;
WorkerLoadContext
*
loadContext
=
aRequestHandle
-
>
GetContext
(
)
;
ScriptLoadRequest
*
request
=
aRequestHandle
-
>
GetRequest
(
)
;
MOZ_ASSERT_IF
(
loadContext
-
>
IsTopLevel
(
)
!
IsDebuggerScript
(
)
)
;
if
(
loadContext
-
>
mLoadResult
!
=
NS_ERROR_NOT_INITIALIZED
)
{
return
loadContext
-
>
mLoadResult
;
}
WorkerPrivate
*
parentWorker
=
mWorkerRef
-
>
Private
(
)
-
>
GetParent
(
)
;
nsIPrincipal
*
principal
=
(
IsDebuggerScript
(
)
)
?
nsContentUtils
:
:
GetSystemPrincipal
(
)
:
mWorkerRef
-
>
Private
(
)
-
>
GetPrincipal
(
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
mWorkerRef
-
>
Private
(
)
-
>
GetLoadGroup
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
principal
)
;
NS_ENSURE_TRUE
(
NS_LoadGroupMatchesPrincipal
(
loadGroup
principal
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
Document
>
parentDoc
=
mWorkerRef
-
>
Private
(
)
-
>
GetDocument
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
loadContext
-
>
IsTopLevel
(
)
)
{
channel
=
mWorkerRef
-
>
Private
(
)
-
>
ForgetWorkerChannel
(
)
;
}
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetIOService
(
)
)
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
NS_ASSERTION
(
secMan
"
This
should
never
be
null
!
"
)
;
nsresult
&
rv
=
loadContext
-
>
mLoadResult
;
nsLoadFlags
loadFlags
=
mWorkerRef
-
>
Private
(
)
-
>
GetLoadFlags
(
)
;
WorkerPrivate
*
topWorkerPrivate
=
mWorkerRef
-
>
Private
(
)
;
WorkerPrivate
*
parent
=
topWorkerPrivate
-
>
GetParent
(
)
;
while
(
parent
)
{
topWorkerPrivate
=
parent
;
parent
=
topWorkerPrivate
-
>
GetParent
(
)
;
}
if
(
topWorkerPrivate
-
>
IsDedicatedWorker
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
topWorkerPrivate
-
>
GetWindow
(
)
;
if
(
window
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
window
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
nsresult
rv
=
docShell
-
>
GetDefaultLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
if
(
!
channel
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
;
uint32_t
secFlags
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ReferrerPolicy
policy
=
request
-
>
ReferrerPolicy
(
)
=
=
ReferrerPolicy
:
:
_empty
?
mWorkerRef
-
>
Private
(
)
-
>
GetReferrerPolicy
(
)
:
request
-
>
ReferrerPolicy
(
)
;
referrerInfo
=
new
ReferrerInfo
(
request
-
>
mReferrer
policy
)
;
RequestCredentials
credentials
=
mWorkerRef
-
>
Private
(
)
-
>
WorkerType
(
)
=
=
WorkerType
:
:
Classic
?
RequestCredentials
:
:
Same_origin
:
mWorkerRef
-
>
Private
(
)
-
>
WorkerCredentials
(
)
;
rv
=
GetModuleSecFlags
(
loadContext
-
>
IsTopLevel
(
)
principal
mWorkerScriptType
request
-
>
mURI
credentials
secFlags
)
;
}
else
{
referrerInfo
=
ReferrerInfo
:
:
CreateForFetch
(
principal
nullptr
)
;
if
(
parentWorker
&
&
!
loadContext
-
>
IsTopLevel
(
)
)
{
referrerInfo
=
static_cast
<
ReferrerInfo
*
>
(
referrerInfo
.
get
(
)
)
-
>
CloneWithNewPolicy
(
parentWorker
-
>
GetReferrerPolicy
(
)
)
;
}
rv
=
GetClassicSecFlags
(
loadContext
-
>
IsTopLevel
(
)
request
-
>
mURI
principal
mWorkerScriptType
secFlags
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsContentPolicyType
contentPolicyType
=
GetContentPolicyType
(
request
)
;
rv
=
ChannelFromScriptURL
(
principal
parentDoc
mWorkerRef
-
>
Private
(
)
loadGroup
ios
secMan
request
-
>
mURI
loadContext
-
>
mClientInfo
mController
loadContext
-
>
IsTopLevel
(
)
mWorkerScriptType
contentPolicyType
loadFlags
secFlags
mWorkerRef
-
>
Private
(
)
-
>
CookieJarSettings
(
)
referrerInfo
getter_AddRefs
(
channel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
principal
-
>
OriginAttributesRef
(
)
.
mPartitionKey
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
rv
=
loadInfo
-
>
SetIsInThirdPartyContext
(
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
if
(
!
mOriginStackJSON
.
IsEmpty
(
)
)
{
NotifyNetworkMonitorAlternateStack
(
channel
mOriginStackJSON
)
;
}
RefPtr
<
NetworkLoadHandler
>
listener
=
new
NetworkLoadHandler
(
this
aRequestHandle
)
;
RefPtr
<
ScriptResponseHeaderProcessor
>
headerProcessor
=
nullptr
;
if
(
!
IsDebuggerScript
(
)
)
{
JS
:
:
ModuleType
moduleType
=
request
-
>
IsModuleRequest
(
)
?
request
-
>
AsModuleRequest
(
)
-
>
mModuleType
:
JS
:
:
ModuleType
:
:
JavaScript
;
bool
requiresStrictMimeCheck
=
GetContentPolicyType
(
request
)
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
|
|
request
-
>
IsModuleRequest
(
)
;
headerProcessor
=
MakeRefPtr
<
ScriptResponseHeaderProcessor
>
(
mWorkerRef
loadContext
-
>
IsTopLevel
(
)
&
&
!
IsDynamicImport
(
request
)
requiresStrictMimeCheck
moduleType
)
;
}
nsCOMPtr
<
nsIStreamLoader
>
loader
;
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
loader
)
listener
headerProcessor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
loadContext
-
>
IsTopLevel
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
loadContext
-
>
mClientInfo
.
isSome
(
)
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetIsInThirdPartyContext
(
mWorkerRef
-
>
Private
(
)
-
>
IsThirdPartyContext
(
)
)
;
Maybe
<
ClientInfo
>
clientInfo
;
clientInfo
.
emplace
(
loadContext
-
>
mClientInfo
.
ref
(
)
)
;
rv
=
AddClientChannelHelper
(
channel
std
:
:
move
(
clientInfo
)
Maybe
<
ClientInfo
>
(
)
mWorkerRef
-
>
Private
(
)
-
>
HybridEventTarget
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
StaticPrefs
:
:
browser_tabs_remote_useCrossOriginEmbedderPolicy
(
)
)
{
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
respectedCOEP
=
mWorkerRef
-
>
Private
(
)
-
>
GetEmbedderPolicy
(
)
;
if
(
mWorkerRef
-
>
Private
(
)
-
>
IsDedicatedWorker
(
)
&
&
respectedCOEP
=
=
nsILoadInfo
:
:
EMBEDDER_POLICY_NULL
)
{
respectedCOEP
=
mWorkerRef
-
>
Private
(
)
-
>
GetOwnerEmbedderPolicy
(
)
;
}
nsCOMPtr
<
nsILoadInfo
>
channelLoadInfo
=
channel
-
>
LoadInfo
(
)
;
channelLoadInfo
-
>
SetLoadingEmbedderPolicy
(
respectedCOEP
)
;
}
if
(
loadContext
-
>
mCacheStatus
!
=
WorkerLoadContext
:
:
ToBeCached
)
{
rv
=
channel
-
>
AsyncOpen
(
loader
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
nsCOMPtr
<
nsIOutputStream
>
writer
;
loadContext
-
>
mCacheStatus
=
WorkerLoadContext
:
:
Cancel
;
NS_NewPipe
(
getter_AddRefs
(
loadContext
-
>
mCacheReadStream
)
getter_AddRefs
(
writer
)
0
UINT32_MAX
true
false
)
;
nsCOMPtr
<
nsIStreamListenerTee
>
tee
=
do_CreateInstance
(
NS_STREAMLISTENERTEE_CONTRACTID
)
;
rv
=
tee
-
>
Init
(
loader
writer
listener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsresult
rv
=
channel
-
>
AsyncOpen
(
tee
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
loadContext
-
>
mChannel
.
swap
(
channel
)
;
return
NS_OK
;
}
nsresult
WorkerScriptLoader
:
:
FillCompileOptionsForRequest
(
JSContext
*
cx
ScriptLoadRequest
*
aRequest
JS
:
:
CompileOptions
*
aOptions
JS
:
:
MutableHandle
<
JSScript
*
>
aIntroductionScript
)
{
aOptions
-
>
setFileAndLine
(
aRequest
-
>
mURL
.
get
(
)
1
)
;
aOptions
-
>
setNoScriptRval
(
true
)
;
aOptions
-
>
setMutedErrors
(
aRequest
-
>
GetWorkerLoadContext
(
)
-
>
mMutedErrorFlag
.
value
(
)
)
;
if
(
aRequest
-
>
mSourceMapURL
)
{
aOptions
-
>
setSourceMapURL
(
aRequest
-
>
mSourceMapURL
-
>
get
(
)
)
;
}
return
NS_OK
;
}
bool
WorkerScriptLoader
:
:
EvaluateScript
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
IsDynamicImport
(
aRequest
)
)
;
WorkerLoadContext
*
loadContext
=
aRequest
-
>
GetWorkerLoadContext
(
)
;
NS_ASSERTION
(
!
loadContext
-
>
mChannel
"
Should
no
longer
have
a
channel
!
"
)
;
NS_ASSERTION
(
aRequest
-
>
IsFinished
(
)
"
Should
be
scheduled
!
"
)
;
MOZ_ASSERT
(
!
mRv
.
Failed
(
)
"
Who
failed
it
and
why
?
"
)
;
mRv
.
MightThrowJSException
(
)
;
if
(
NS_FAILED
(
loadContext
-
>
mLoadResult
)
)
{
ReportErrorToConsole
(
aRequest
loadContext
-
>
mLoadResult
)
;
return
false
;
}
if
(
loadContext
-
>
IsTopLevel
(
)
)
{
if
(
mController
.
isSome
(
)
)
{
MOZ_ASSERT
(
mWorkerScriptType
=
=
WorkerScript
"
Debugger
clients
can
'
t
be
controlled
.
"
)
;
mWorkerRef
-
>
Private
(
)
-
>
GlobalScope
(
)
-
>
Control
(
mController
.
ref
(
)
)
;
}
mWorkerRef
-
>
Private
(
)
-
>
ExecutionReady
(
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
IsTopLevel
(
)
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
!
request
-
>
mModuleScript
)
{
return
false
;
}
if
(
request
-
>
mModuleScript
-
>
HasParseError
(
)
)
{
mRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
if
(
!
request
-
>
InstantiateModuleGraph
(
)
)
{
return
false
;
}
if
(
request
-
>
mModuleScript
-
>
HasErrorToRethrow
(
)
)
{
mRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
false
;
}
nsresult
rv
=
request
-
>
EvaluateModule
(
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
JS
:
:
CompileOptions
options
(
aCx
)
;
JS
:
:
Rooted
<
JSScript
*
>
unusedIntroductionScript
(
aCx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
aCx
aRequest
&
options
&
unusedIntroductionScript
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Filling
compile
options
should
not
fail
"
)
;
MOZ_ASSERT
(
!
mRv
.
Failed
(
)
"
Who
failed
it
and
why
?
"
)
;
ScriptLoadRequest
:
:
MaybeSourceText
maybeSource
;
rv
=
aRequest
-
>
GetScriptSource
(
aCx
&
maybeSource
aRequest
-
>
mLoadContext
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
false
;
}
RefPtr
<
JS
:
:
loader
:
:
ClassicScript
>
classicScript
=
nullptr
;
if
(
!
mWorkerRef
-
>
Private
(
)
-
>
IsServiceWorker
(
)
)
{
nsCOMPtr
<
nsIURI
>
requestBaseURI
;
if
(
loadContext
-
>
mMutedErrorFlag
.
valueOr
(
false
)
)
{
NS_NewURI
(
getter_AddRefs
(
requestBaseURI
)
"
about
:
blank
"
_ns
)
;
}
else
{
requestBaseURI
=
aRequest
-
>
mBaseURL
;
}
MOZ_ASSERT
(
aRequest
-
>
mLoadedScript
-
>
IsClassicScript
(
)
)
;
MOZ_ASSERT
(
aRequest
-
>
mLoadedScript
-
>
GetFetchOptions
(
)
=
=
aRequest
-
>
mFetchOptions
)
;
aRequest
-
>
mLoadedScript
-
>
SetBaseURL
(
requestBaseURI
)
;
classicScript
=
aRequest
-
>
mLoadedScript
-
>
AsClassicScript
(
)
;
}
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
)
;
script
=
aRequest
-
>
IsUTF8Text
(
)
?
JS
:
:
Compile
(
aCx
options
maybeSource
.
ref
<
JS
:
:
SourceText
<
Utf8Unit
>
>
(
)
)
:
JS
:
:
Compile
(
aCx
options
maybeSource
.
ref
<
JS
:
:
SourceText
<
char16_t
>
>
(
)
)
;
if
(
!
script
)
{
if
(
loadContext
-
>
IsTopLevel
(
)
)
{
JS_ClearPendingException
(
aCx
)
;
mRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
}
else
{
mRv
.
StealExceptionFromJSContext
(
aCx
)
;
}
return
false
;
}
bool
successfullyEvaluated
=
EvaluateSourceBuffer
(
aCx
script
classicScript
)
;
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
false
;
}
if
(
!
successfullyEvaluated
)
{
mRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
false
;
}
return
true
;
}
void
WorkerScriptLoader
:
:
TryShutdown
(
)
{
{
MutexAutoLock
lock
(
CleanUpLock
(
)
)
;
if
(
CleanedUp
(
)
)
{
return
;
}
}
if
(
AllScriptsExecuted
(
)
&
&
AllModuleRequestsLoaded
(
)
)
{
ShutdownScriptLoader
(
!
mExecutionAborted
mMutedErrorFlag
)
;
}
}
void
WorkerScriptLoader
:
:
ShutdownScriptLoader
(
bool
aResult
bool
aMutedError
)
{
MOZ_ASSERT
(
AllScriptsExecuted
(
)
)
;
MOZ_ASSERT
(
AllModuleRequestsLoaded
(
)
)
;
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
!
aResult
)
{
if
(
mRv
.
Failed
(
)
)
{
if
(
aMutedError
&
&
mRv
.
IsJSException
(
)
)
{
LogExceptionToConsole
(
mWorkerRef
-
>
Private
(
)
-
>
GetJSContext
(
)
mWorkerRef
-
>
Private
(
)
)
;
mRv
.
Throw
(
NS_ERROR_DOM_NETWORK_ERR
)
;
}
}
else
{
mRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
}
}
{
MutexAutoLock
lock
(
CleanUpLock
(
)
)
;
if
(
CleanedUp
(
)
)
{
return
;
}
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
if
(
mSyncLoopTarget
)
{
mWorkerRef
-
>
Private
(
)
-
>
MaybeStopSyncLoop
(
mSyncLoopTarget
aResult
?
NS_OK
:
NS_ERROR_FAILURE
)
;
mSyncLoopTarget
=
nullptr
;
}
mCleanedUp
=
true
;
mWorkerRef
=
nullptr
;
}
}
void
WorkerScriptLoader
:
:
ReportErrorToConsole
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
const
{
nsAutoString
url
=
NS_ConvertUTF8toUTF16
(
aRequest
-
>
mURL
)
;
workerinternals
:
:
ReportLoadError
(
mRv
aResult
url
)
;
}
void
WorkerScriptLoader
:
:
LogExceptionToConsole
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mRv
.
IsJSException
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
std
:
:
move
(
mRv
)
&
exn
)
)
{
return
;
}
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
aCx
)
)
;
MOZ_ASSERT
(
!
mRv
.
Failed
(
)
)
;
JS
:
:
ExceptionStack
exnStack
(
aCx
exn
nullptr
)
;
JS
:
:
ErrorReportBuilder
report
(
aCx
)
;
if
(
!
report
.
init
(
aCx
exnStack
JS
:
:
ErrorReportBuilder
:
:
WithSideEffects
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
;
}
RefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
xpcReport
-
>
Init
(
report
.
report
(
)
report
.
toStringResult
(
)
.
c_str
(
)
aWorkerPrivate
-
>
IsChromeWorker
(
)
aWorkerPrivate
-
>
WindowID
(
)
)
;
RefPtr
<
AsyncErrorReporter
>
r
=
new
AsyncErrorReporter
(
xpcReport
)
;
NS_DispatchToMainThread
(
r
)
;
}
bool
WorkerScriptLoader
:
:
AllModuleRequestsLoaded
(
)
const
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
return
mLoadingModuleRequestCount
=
=
0
;
}
void
WorkerScriptLoader
:
:
IncreaseLoadingModuleRequestCount
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
+
+
mLoadingModuleRequestCount
;
}
void
WorkerScriptLoader
:
:
DecreaseLoadingModuleRequestCount
(
)
{
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
-
-
mLoadingModuleRequestCount
;
}
NS_IMPL_ISUPPORTS
(
ScriptLoaderRunnable
nsIRunnable
nsINamed
)
NS_IMPL_ISUPPORTS
(
WorkerScriptLoader
nsINamed
)
ScriptLoaderRunnable
:
:
ScriptLoaderRunnable
(
WorkerScriptLoader
*
aScriptLoader
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
aLoadingRequests
)
:
mScriptLoader
(
aScriptLoader
)
mWorkerRef
(
aScriptLoader
-
>
mWorkerRef
)
mLoadingRequests
(
std
:
:
move
(
aLoadingRequests
)
)
mCancelMainThread
(
Nothing
(
)
)
{
MOZ_ASSERT
(
aScriptLoader
)
;
}
nsresult
ScriptLoaderRunnable
:
:
Run
(
)
{
AssertIsOnMainThread
(
)
;
if
(
mScriptLoader
-
>
mOriginStack
&
&
mScriptLoader
-
>
mOriginStackJSON
.
IsEmpty
(
)
)
{
ConvertSerializedStackToJSON
(
std
:
:
move
(
mScriptLoader
-
>
mOriginStack
)
mScriptLoader
-
>
mOriginStackJSON
)
;
}
if
(
!
mWorkerRef
-
>
Private
(
)
-
>
IsServiceWorker
(
)
|
|
mScriptLoader
-
>
IsDebuggerScript
(
)
)
{
for
(
ThreadSafeRequestHandle
*
handle
:
mLoadingRequests
)
{
handle
-
>
mRunnable
=
this
;
}
for
(
ThreadSafeRequestHandle
*
handle
:
mLoadingRequests
)
{
nsresult
rv
=
mScriptLoader
-
>
LoadScript
(
handle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
LoadingFinished
(
handle
rv
)
;
CancelMainThread
(
rv
)
;
return
rv
;
}
}
return
NS_OK
;
}
MOZ_ASSERT
(
!
mCacheCreator
)
;
mCacheCreator
=
new
CacheCreator
(
mWorkerRef
-
>
Private
(
)
)
;
for
(
ThreadSafeRequestHandle
*
handle
:
mLoadingRequests
)
{
handle
-
>
mRunnable
=
this
;
WorkerLoadContext
*
loadContext
=
handle
-
>
GetContext
(
)
;
mCacheCreator
-
>
AddLoader
(
MakeNotNull
<
RefPtr
<
CacheLoadHandler
>
>
(
mWorkerRef
handle
loadContext
-
>
IsTopLevel
(
)
loadContext
-
>
mOnlyExistingCachedResourcesAllowed
mScriptLoader
)
)
;
}
nsIPrincipal
*
principal
=
mWorkerRef
-
>
Private
(
)
-
>
GetPrincipal
(
)
;
if
(
!
principal
)
{
WorkerPrivate
*
parentWorker
=
mWorkerRef
-
>
Private
(
)
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parentWorker
"
Must
have
a
parent
!
"
)
;
principal
=
parentWorker
-
>
GetPrincipal
(
)
;
}
nsresult
rv
=
mCacheCreator
-
>
Load
(
principal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
CancelMainThread
(
rv
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
ScriptLoaderRunnable
:
:
OnStreamComplete
(
ThreadSafeRequestHandle
*
aRequestHandle
nsresult
aStatus
)
{
AssertIsOnMainThread
(
)
;
LoadingFinished
(
aRequestHandle
aStatus
)
;
return
NS_OK
;
}
void
ScriptLoaderRunnable
:
:
LoadingFinished
(
ThreadSafeRequestHandle
*
aRequestHandle
nsresult
aRv
)
{
AssertIsOnMainThread
(
)
;
WorkerLoadContext
*
loadContext
=
aRequestHandle
-
>
GetContext
(
)
;
loadContext
-
>
mLoadResult
=
aRv
;
MOZ_ASSERT
(
!
loadContext
-
>
mLoadingFinished
)
;
loadContext
-
>
mLoadingFinished
=
true
;
if
(
loadContext
-
>
IsTopLevel
(
)
&
&
NS_SUCCEEDED
(
aRv
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWorkerRef
-
>
Private
(
)
-
>
PrincipalURIMatchesScriptURL
(
)
)
;
}
MaybeExecuteFinishedScripts
(
aRequestHandle
)
;
}
void
ScriptLoaderRunnable
:
:
MaybeExecuteFinishedScripts
(
ThreadSafeRequestHandle
*
aRequestHandle
)
{
AssertIsOnMainThread
(
)
;
WorkerLoadContext
*
loadContext
=
aRequestHandle
-
>
GetContext
(
)
;
if
(
!
loadContext
-
>
IsAwaitingPromise
(
)
)
{
if
(
aRequestHandle
-
>
GetContext
(
)
-
>
IsTopLevel
(
)
)
{
mWorkerRef
-
>
Private
(
)
-
>
WorkerScriptLoaded
(
)
;
}
DispatchProcessPendingRequests
(
)
;
}
}
void
ScriptLoaderRunnable
:
:
CancelMainThreadWithBindingAborted
(
)
{
AssertIsOnMainThread
(
)
;
CancelMainThread
(
NS_BINDING_ABORTED
)
;
}
void
ScriptLoaderRunnable
:
:
CancelMainThread
(
nsresult
aCancelResult
)
{
AssertIsOnMainThread
(
)
;
if
(
IsCancelled
(
)
)
{
return
;
}
{
MutexAutoLock
lock
(
mScriptLoader
-
>
CleanUpLock
(
)
)
;
if
(
mScriptLoader
-
>
CleanedUp
(
)
)
{
return
;
}
mCancelMainThread
=
Some
(
aCancelResult
)
;
for
(
ThreadSafeRequestHandle
*
handle
:
mLoadingRequests
)
{
if
(
handle
-
>
IsEmpty
(
)
)
{
continue
;
}
bool
callLoadingFinished
=
true
;
WorkerLoadContext
*
loadContext
=
handle
-
>
GetContext
(
)
;
if
(
!
loadContext
)
{
continue
;
}
if
(
loadContext
-
>
IsAwaitingPromise
(
)
)
{
MOZ_ASSERT
(
mWorkerRef
-
>
Private
(
)
-
>
IsServiceWorker
(
)
)
;
loadContext
-
>
mCachePromise
-
>
MaybeReject
(
NS_BINDING_ABORTED
)
;
loadContext
-
>
mCachePromise
=
nullptr
;
callLoadingFinished
=
false
;
}
if
(
loadContext
-
>
mChannel
)
{
if
(
NS_SUCCEEDED
(
loadContext
-
>
mChannel
-
>
Cancel
(
aCancelResult
)
)
)
{
callLoadingFinished
=
false
;
}
else
{
NS_WARNING
(
"
Failed
to
cancel
channel
!
"
)
;
}
}
if
(
callLoadingFinished
&
&
!
loadContext
-
>
mLoadingFinished
)
{
LoadingFinished
(
handle
aCancelResult
)
;
}
}
DispatchProcessPendingRequests
(
)
;
}
}
void
ScriptLoaderRunnable
:
:
DispatchProcessPendingRequests
(
)
{
AssertIsOnMainThread
(
)
;
const
auto
begin
=
mLoadingRequests
.
begin
(
)
;
const
auto
end
=
mLoadingRequests
.
end
(
)
;
using
Iterator
=
decltype
(
begin
)
;
const
auto
maybeRangeToExecute
=
[
begin
end
]
(
)
-
>
Maybe
<
std
:
:
pair
<
Iterator
Iterator
>
>
{
auto
firstItToExecute
=
std
:
:
find_if
(
begin
end
[
]
(
const
RefPtr
<
ThreadSafeRequestHandle
>
&
requestHandle
)
{
return
!
requestHandle
-
>
mExecutionScheduled
;
}
)
;
if
(
firstItToExecute
=
=
end
)
{
return
Nothing
(
)
;
}
const
auto
firstItUnexecutable
=
std
:
:
find_if
(
firstItToExecute
end
[
]
(
RefPtr
<
ThreadSafeRequestHandle
>
&
requestHandle
)
{
MOZ_ASSERT
(
!
requestHandle
-
>
IsEmpty
(
)
)
;
if
(
!
requestHandle
-
>
Finished
(
)
)
{
return
true
;
}
requestHandle
-
>
mExecutionScheduled
=
true
;
return
false
;
}
)
;
return
firstItUnexecutable
=
=
firstItToExecute
?
Nothing
(
)
:
Some
(
std
:
:
pair
(
firstItToExecute
firstItUnexecutable
)
)
;
}
(
)
;
if
(
maybeRangeToExecute
)
{
if
(
maybeRangeToExecute
-
>
second
=
=
end
)
{
mCacheCreator
=
nullptr
;
}
RefPtr
<
ScriptExecutorRunnable
>
runnable
=
new
ScriptExecutorRunnable
(
mScriptLoader
mWorkerRef
-
>
Private
(
)
mScriptLoader
-
>
mSyncLoopTarget
Span
<
RefPtr
<
ThreadSafeRequestHandle
>
>
{
maybeRangeToExecute
-
>
first
maybeRangeToExecute
-
>
second
}
)
;
if
(
!
runnable
-
>
Dispatch
(
mWorkerRef
-
>
Private
(
)
)
&
&
mScriptLoader
-
>
mSyncLoopTarget
)
{
MOZ_ASSERT
(
false
"
This
should
never
fail
!
"
)
;
}
}
}
ScriptExecutorRunnable
:
:
ScriptExecutorRunnable
(
WorkerScriptLoader
*
aScriptLoader
WorkerPrivate
*
aWorkerPrivate
nsISerialEventTarget
*
aSyncLoopTarget
Span
<
RefPtr
<
ThreadSafeRequestHandle
>
>
aLoadedRequests
)
:
MainThreadWorkerSyncRunnable
(
aSyncLoopTarget
"
ScriptExecutorRunnable
"
)
mScriptLoader
(
aScriptLoader
)
mLoadedRequests
(
aLoadedRequests
)
{
}
bool
ScriptExecutorRunnable
:
:
IsDebuggerRunnable
(
)
const
{
return
mScriptLoader
-
>
IsDebuggerScript
(
)
;
}
bool
ScriptExecutorRunnable
:
:
PreRun
(
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mScriptLoader
-
>
mSyncLoopTarget
=
=
mSyncLoopTarget
"
Unexpected
SyncLoopTarget
.
Check
if
the
sync
loop
was
closed
early
"
)
;
{
MutexAutoLock
lock
(
mScriptLoader
-
>
CleanUpLock
(
)
)
;
if
(
mScriptLoader
-
>
CleanedUp
(
)
)
{
return
true
;
}
const
auto
&
requestHandle
=
mLoadedRequests
[
0
]
;
if
(
requestHandle
-
>
IsEmpty
(
)
|
|
!
requestHandle
-
>
GetContext
(
)
-
>
IsTopLevel
(
)
)
{
return
true
;
}
}
return
mScriptLoader
-
>
StoreCSP
(
)
;
}
bool
ScriptExecutorRunnable
:
:
ProcessModuleScript
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
mLoadedRequests
.
Length
(
)
=
=
1
)
;
RefPtr
<
ScriptLoadRequest
>
request
;
{
MutexAutoLock
lock
(
mScriptLoader
-
>
CleanUpLock
(
)
)
;
if
(
mScriptLoader
-
>
CleanedUp
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
mLoadedRequests
.
Length
(
)
=
=
1
)
;
const
auto
&
requestHandle
=
mLoadedRequests
[
0
]
;
MOZ_ASSERT
(
!
requestHandle
-
>
IsEmpty
(
)
)
;
request
=
requestHandle
-
>
ReleaseRequest
(
)
;
}
MOZ_ASSERT
(
request
-
>
IsModuleRequest
(
)
)
;
WorkerLoadContext
*
loadContext
=
request
-
>
GetWorkerLoadContext
(
)
;
ModuleLoadRequest
*
moduleRequest
=
request
-
>
AsModuleRequest
(
)
;
mScriptLoader
-
>
DecreaseLoadingModuleRequestCount
(
)
;
moduleRequest
-
>
OnFetchComplete
(
loadContext
-
>
mLoadResult
)
;
if
(
NS_FAILED
(
loadContext
-
>
mLoadResult
)
)
{
if
(
moduleRequest
-
>
IsDynamicImport
(
)
)
{
if
(
request
-
>
isInList
(
)
)
{
moduleRequest
-
>
CancelDynamicImport
(
loadContext
-
>
mLoadResult
)
;
mScriptLoader
-
>
TryShutdown
(
)
;
}
}
else
if
(
!
moduleRequest
-
>
IsTopLevel
(
)
)
{
moduleRequest
-
>
Cancel
(
)
;
mScriptLoader
-
>
TryShutdown
(
)
;
}
else
{
moduleRequest
-
>
LoadFailed
(
)
;
}
}
return
true
;
}
bool
ScriptExecutorRunnable
:
:
ProcessClassicScripts
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
{
MutexAutoLock
lock
(
mScriptLoader
-
>
CleanUpLock
(
)
)
;
if
(
mScriptLoader
-
>
CleanedUp
(
)
)
{
return
true
;
}
for
(
const
auto
&
requestHandle
:
mLoadedRequests
)
{
MOZ_ASSERT
(
!
requestHandle
-
>
IsEmpty
(
)
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
requestHandle
-
>
ReleaseRequest
(
)
;
mScriptLoader
-
>
MaybeMoveToLoadedList
(
request
)
;
}
}
return
mScriptLoader
-
>
ProcessPendingRequests
(
aCx
)
;
}
bool
ScriptExecutorRunnable
:
:
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mScriptLoader
-
>
mSyncLoopTarget
=
=
mSyncLoopTarget
"
Unexpected
SyncLoopTarget
.
Check
if
the
sync
loop
was
closed
early
"
)
;
if
(
mLoadedRequests
.
begin
(
)
-
>
get
(
)
-
>
GetRequest
(
)
-
>
IsModuleRequest
(
)
)
{
return
ProcessModuleScript
(
aCx
aWorkerPrivate
)
;
}
return
ProcessClassicScripts
(
aCx
aWorkerPrivate
)
;
}
nsresult
ScriptExecutorRunnable
:
:
Cancel
(
)
{
if
(
mScriptLoader
-
>
AllScriptsExecuted
(
)
&
&
mScriptLoader
-
>
AllModuleRequestsLoaded
(
)
)
{
mScriptLoader
-
>
ShutdownScriptLoader
(
false
false
)
;
}
return
NS_OK
;
}
}
nsresult
ChannelFromScriptURLMainThread
(
nsIPrincipal
*
aPrincipal
Document
*
aParentDoc
nsILoadGroup
*
aLoadGroup
nsIURI
*
aScriptURL
const
WorkerType
&
aWorkerType
const
RequestCredentials
&
aCredentials
const
Maybe
<
ClientInfo
>
&
aClientInfo
nsContentPolicyType
aMainScriptContentPolicyType
nsICookieJarSettings
*
aCookieJarSettings
nsIReferrerInfo
*
aReferrerInfo
nsIChannel
*
*
aChannel
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetIOService
(
)
)
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
NS_ASSERTION
(
secMan
"
This
should
never
be
null
!
"
)
;
uint32_t
secFlags
;
nsresult
rv
;
if
(
aWorkerType
=
=
WorkerType
:
:
Module
)
{
rv
=
GetModuleSecFlags
(
true
aPrincipal
WorkerScript
aScriptURL
aCredentials
secFlags
)
;
}
else
{
rv
=
GetClassicSecFlags
(
true
aScriptURL
aPrincipal
WorkerScript
secFlags
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
ChannelFromScriptURL
(
aPrincipal
aParentDoc
nullptr
aLoadGroup
ios
secMan
aScriptURL
aClientInfo
Maybe
<
ServiceWorkerDescriptor
>
(
)
true
WorkerScript
aMainScriptContentPolicyType
nsIRequest
:
:
LOAD_NORMAL
secFlags
aCookieJarSettings
aReferrerInfo
aChannel
)
;
}
nsresult
ChannelFromScriptURLWorkerThread
(
JSContext
*
aCx
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
const
WorkerType
&
aWorkerType
const
RequestCredentials
&
aCredentials
WorkerLoadInfo
&
aLoadInfo
)
{
aParent
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
ChannelGetterRunnable
>
getter
=
new
ChannelGetterRunnable
(
aParent
aScriptURL
aWorkerType
aCredentials
aLoadInfo
)
;
ErrorResult
rv
;
getter
-
>
Dispatch
(
aParent
Canceling
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_ERROR
(
"
Failed
to
dispatch
!
"
)
;
return
rv
.
StealNSResult
(
)
;
}
return
getter
-
>
GetResult
(
)
;
}
void
ReportLoadError
(
ErrorResult
&
aRv
nsresult
aLoadResult
const
nsAString
&
aScriptURL
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
nsPrintfCString
err
(
"
Failed
to
load
worker
script
at
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
aScriptURL
)
.
get
(
)
)
;
switch
(
aLoadResult
)
{
case
NS_ERROR_MALFORMED_URI
:
case
NS_ERROR_DOM_SYNTAX_ERR
:
aRv
.
ThrowSyntaxError
(
err
)
;
break
;
case
NS_BINDING_ABORTED
:
aRv
.
Throw
(
aLoadResult
)
;
break
;
case
NS_ERROR_DOM_BAD_URI
:
case
NS_ERROR_DOM_SECURITY_ERR
:
aRv
.
ThrowSecurityError
(
err
)
;
break
;
case
NS_ERROR_FILE_NOT_FOUND
:
case
NS_ERROR_NOT_AVAILABLE
:
case
NS_ERROR_CORRUPTED_CONTENT
:
case
NS_ERROR_DOM_NETWORK_ERR
:
default
:
aRv
.
Throw
(
NS_ERROR_DOM_NETWORK_ERR
)
;
break
;
}
}
void
LoadMainScript
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
const
nsAString
&
aScriptURL
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
const
mozilla
:
:
Encoding
*
aDocumentEncoding
)
{
nsTArray
<
nsString
>
scriptURLs
;
scriptURLs
.
AppendElement
(
aScriptURL
)
;
LoadAllScripts
(
aWorkerPrivate
std
:
:
move
(
aOriginStack
)
scriptURLs
true
aWorkerScriptType
aRv
aDocumentEncoding
)
;
}
void
Load
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
const
nsTArray
<
nsString
>
&
aScriptURLs
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
)
{
const
uint32_t
urlCount
=
aScriptURLs
.
Length
(
)
;
if
(
!
urlCount
)
{
return
;
}
if
(
urlCount
>
MAX_CONCURRENT_SCRIPTS
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
LoadAllScripts
(
aWorkerPrivate
std
:
:
move
(
aOriginStack
)
aScriptURLs
false
aWorkerScriptType
aRv
)
;
}
}
