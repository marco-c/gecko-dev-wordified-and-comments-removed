#
include
"
MessageEventRunnable
.
h
"
#
include
"
mozilla
/
dom
/
MessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
MessageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
WorkerTimelineMarker
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
WorkerScope
.
h
"
namespace
mozilla
:
:
dom
{
MessageEventRunnable
:
:
MessageEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
)
:
WorkerDebuggeeRunnable
(
aWorkerPrivate
aBehavior
)
StructuredCloneHolder
(
CloningSupported
TransferringSupported
StructuredCloneScope
:
:
SameProcess
)
{
}
bool
MessageEventRunnable
:
:
DispatchDOMEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
DOMEventTargetHelper
*
aTarget
bool
aIsMainThread
)
{
nsCOMPtr
<
nsIGlobalObject
>
parent
=
aTarget
-
>
GetParentObject
(
)
;
if
(
!
parent
)
{
JS
:
:
Rooted
<
JSObject
*
>
globalObject
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
globalObject
)
)
{
return
false
;
}
parent
=
xpc
:
:
NativeGlobal
(
globalObject
)
;
if
(
NS_WARN_IF
(
!
parent
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
parent
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
messageData
(
aCx
)
;
IgnoredErrorResult
rv
;
UniquePtr
<
AbstractTimelineMarker
>
start
;
UniquePtr
<
AbstractTimelineMarker
>
end
;
bool
isTimelineRecording
=
!
TimelineConsumers
:
:
IsEmpty
(
)
;
if
(
isTimelineRecording
)
{
start
=
MakeUnique
<
WorkerTimelineMarker
>
(
aIsMainThread
?
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOffMainThread
MarkerTracingType
:
:
START
)
;
}
JS
:
:
CloneDataPolicy
cloneDataPolicy
;
if
(
parent
-
>
GetClientInfo
(
)
.
isSome
(
)
&
&
parent
-
>
GetClientInfo
(
)
-
>
AgentClusterId
(
)
.
isSome
(
)
&
&
parent
-
>
GetClientInfo
(
)
-
>
AgentClusterId
(
)
-
>
Equals
(
aWorkerPrivate
-
>
AgentClusterId
(
)
)
)
{
cloneDataPolicy
.
allowIntraClusterClonableSharedObjects
(
)
;
}
if
(
aWorkerPrivate
-
>
IsSharedMemoryAllowed
(
)
)
{
cloneDataPolicy
.
allowSharedMemoryObjects
(
)
;
}
Read
(
parent
aCx
&
messageData
cloneDataPolicy
rv
)
;
if
(
isTimelineRecording
)
{
end
=
MakeUnique
<
WorkerTimelineMarker
>
(
aIsMainThread
?
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOffMainThread
MarkerTracingType
:
:
END
)
;
TimelineConsumers
:
:
AddMarkerForAllObservedDocShells
(
start
)
;
TimelineConsumers
:
:
AddMarkerForAllObservedDocShells
(
end
)
;
}
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
DispatchError
(
aCx
aTarget
)
;
return
false
;
}
Sequence
<
OwningNonNull
<
MessagePort
>
>
ports
;
if
(
!
TakeTransferredPortsAsSequence
(
ports
)
)
{
DispatchError
(
aCx
aTarget
)
;
return
false
;
}
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
aTarget
nullptr
nullptr
)
;
event
-
>
InitMessageEvent
(
nullptr
u
"
message
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
messageData
u
"
"
_ns
u
"
"
_ns
nullptr
ports
)
;
event
-
>
SetTrusted
(
true
)
;
aTarget
-
>
DispatchEvent
(
*
event
)
;
return
true
;
}
bool
MessageEventRunnable
:
:
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
if
(
mBehavior
=
=
ParentThreadUnchangedBusyCount
)
{
if
(
!
aWorkerPrivate
-
>
IsAcceptingEvents
(
)
)
{
return
true
;
}
MOZ_ASSERT
(
!
aWorkerPrivate
-
>
IsFrozen
(
)
)
;
MOZ_ASSERT
(
!
aWorkerPrivate
-
>
IsParentWindowPaused
(
)
)
;
aWorkerPrivate
-
>
AssertInnerWindowIsCorrect
(
)
;
return
DispatchDOMEvent
(
aCx
aWorkerPrivate
aWorkerPrivate
-
>
ParentEventTargetRef
(
)
!
aWorkerPrivate
-
>
GetParent
(
)
)
;
}
MOZ_ASSERT
(
aWorkerPrivate
=
=
GetWorkerPrivateFromContext
(
aCx
)
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
GlobalScope
(
)
)
;
if
(
NS_FAILED
(
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
CheckCurrentGlobalCorrectness
(
)
)
)
{
return
true
;
}
return
DispatchDOMEvent
(
aCx
aWorkerPrivate
aWorkerPrivate
-
>
GlobalScope
(
)
false
)
;
}
void
MessageEventRunnable
:
:
DispatchError
(
JSContext
*
aCx
DOMEventTargetHelper
*
aTarget
)
{
RootedDictionary
<
MessageEventInit
>
init
(
aCx
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
Event
>
event
=
MessageEvent
:
:
Constructor
(
aTarget
u
"
messageerror
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
aTarget
-
>
DispatchEvent
(
*
event
)
;
}
}
