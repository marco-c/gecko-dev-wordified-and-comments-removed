#
include
"
WorkerLoadInfo
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
LoadContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsITabChild
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
{
class
MainThreadReleaseRunnable
final
:
public
Runnable
{
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
mDoomed
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroupToCancel
;
public
:
MainThreadReleaseRunnable
(
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
aDoomed
nsCOMPtr
<
nsILoadGroup
>
&
aLoadGroupToCancel
)
:
mozilla
:
:
Runnable
(
"
MainThreadReleaseRunnable
"
)
{
mDoomed
.
SwapElements
(
aDoomed
)
;
mLoadGroupToCancel
.
swap
(
aLoadGroupToCancel
)
;
}
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
MainThreadReleaseRunnable
Runnable
)
NS_IMETHOD
Run
(
)
override
{
if
(
mLoadGroupToCancel
)
{
mLoadGroupToCancel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mLoadGroupToCancel
=
nullptr
;
}
mDoomed
.
Clear
(
)
;
return
NS_OK
;
}
private
:
~
MainThreadReleaseRunnable
(
)
{
}
}
;
template
<
class
T
>
struct
ISupportsBaseInfo
{
typedef
T
ISupportsBase
;
}
;
template
<
template
<
class
>
class
SmartPtr
class
T
>
inline
void
SwapToISupportsArray
(
SmartPtr
<
T
>
&
aSrc
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
aDest
)
{
nsCOMPtr
<
nsISupports
>
*
dest
=
aDest
.
AppendElement
(
)
;
T
*
raw
=
nullptr
;
aSrc
.
swap
(
raw
)
;
nsISupports
*
rawSupports
=
static_cast
<
typename
ISupportsBaseInfo
<
T
>
:
:
ISupportsBase
*
>
(
raw
)
;
dest
-
>
swap
(
rawSupports
)
;
}
}
WorkerLoadInfo
:
:
WorkerLoadInfo
(
)
:
mLoadFlags
(
nsIRequest
:
:
LOAD_NORMAL
)
mWindowID
(
UINT64_MAX
)
mReferrerPolicy
(
net
:
:
RP_Unset
)
mFromWindow
(
false
)
mEvalAllowed
(
false
)
mReportCSPViolations
(
false
)
mXHRParamsAllowed
(
false
)
mPrincipalIsSystem
(
false
)
mStorageAllowed
(
false
)
mFirstPartyStorageAccessGranted
(
false
)
mServiceWorkersTestingInWindow
(
false
)
{
MOZ_COUNT_CTOR
(
WorkerLoadInfo
)
;
}
WorkerLoadInfo
:
:
~
WorkerLoadInfo
(
)
{
MOZ_COUNT_DTOR
(
WorkerLoadInfo
)
;
}
void
WorkerLoadInfo
:
:
StealFrom
(
WorkerLoadInfo
&
aOther
)
{
MOZ_ASSERT
(
!
mBaseURI
)
;
aOther
.
mBaseURI
.
swap
(
mBaseURI
)
;
MOZ_ASSERT
(
!
mResolvedScriptURI
)
;
aOther
.
mResolvedScriptURI
.
swap
(
mResolvedScriptURI
)
;
MOZ_ASSERT
(
!
mPrincipal
)
;
aOther
.
mPrincipal
.
swap
(
mPrincipal
)
;
aOther
.
mLoadingPrincipal
.
swap
(
mLoadingPrincipal
)
;
MOZ_ASSERT
(
!
mScriptContext
)
;
aOther
.
mScriptContext
.
swap
(
mScriptContext
)
;
MOZ_ASSERT
(
!
mWindow
)
;
aOther
.
mWindow
.
swap
(
mWindow
)
;
MOZ_ASSERT
(
!
mCSP
)
;
aOther
.
mCSP
.
swap
(
mCSP
)
;
MOZ_ASSERT
(
!
mChannel
)
;
aOther
.
mChannel
.
swap
(
mChannel
)
;
MOZ_ASSERT
(
!
mLoadGroup
)
;
aOther
.
mLoadGroup
.
swap
(
mLoadGroup
)
;
MOZ_ASSERT
(
!
mInterfaceRequestor
)
;
aOther
.
mInterfaceRequestor
.
swap
(
mInterfaceRequestor
)
;
MOZ_ASSERT
(
!
mPrincipalInfo
)
;
mPrincipalInfo
=
aOther
.
mPrincipalInfo
.
forget
(
)
;
mDomain
=
aOther
.
mDomain
;
mOrigin
=
aOther
.
mOrigin
;
mServiceWorkerCacheName
=
aOther
.
mServiceWorkerCacheName
;
mServiceWorkerDescriptor
=
aOther
.
mServiceWorkerDescriptor
;
mServiceWorkerRegistrationDescriptor
=
aOther
.
mServiceWorkerRegistrationDescriptor
;
mLoadFlags
=
aOther
.
mLoadFlags
;
mWindowID
=
aOther
.
mWindowID
;
mReferrerPolicy
=
aOther
.
mReferrerPolicy
;
mFromWindow
=
aOther
.
mFromWindow
;
mEvalAllowed
=
aOther
.
mEvalAllowed
;
mReportCSPViolations
=
aOther
.
mReportCSPViolations
;
mXHRParamsAllowed
=
aOther
.
mXHRParamsAllowed
;
mPrincipalIsSystem
=
aOther
.
mPrincipalIsSystem
;
mStorageAllowed
=
aOther
.
mStorageAllowed
;
mFirstPartyStorageAccessGranted
=
aOther
.
mFirstPartyStorageAccessGranted
;
mServiceWorkersTestingInWindow
=
aOther
.
mServiceWorkersTestingInWindow
;
mOriginAttributes
=
aOther
.
mOriginAttributes
;
mParentController
=
aOther
.
mParentController
;
}
nsresult
WorkerLoadInfo
:
:
SetPrincipalOnMainThread
(
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
NS_LoadGroupMatchesPrincipal
(
aLoadGroup
aPrincipal
)
)
;
mPrincipal
=
aPrincipal
;
mPrincipalIsSystem
=
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
;
nsresult
rv
=
aPrincipal
-
>
GetCsp
(
getter_AddRefs
(
mCSP
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mCSP
)
{
mCSP
-
>
GetAllowsEval
(
&
mReportCSPViolations
&
mEvalAllowed
)
;
}
else
{
mEvalAllowed
=
true
;
mReportCSPViolations
=
false
;
}
mLoadGroup
=
aLoadGroup
;
mPrincipalInfo
=
new
PrincipalInfo
(
)
;
mOriginAttributes
=
nsContentUtils
:
:
GetOriginAttributes
(
aLoadGroup
)
;
rv
=
PrincipalToPrincipalInfo
(
aPrincipal
mPrincipalInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
aPrincipal
mOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
WorkerLoadInfo
:
:
GetPrincipalAndLoadGroupFromChannel
(
nsIChannel
*
aChannel
nsIPrincipal
*
*
aPrincipalOut
nsILoadGroup
*
*
aLoadGroupOut
)
{
AssertIsOnMainThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChannel
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPrincipalOut
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aLoadGroupOut
)
;
NS_ENSURE_TRUE
(
mLoadingPrincipal
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ssm
)
;
nsCOMPtr
<
nsIPrincipal
>
channelPrincipal
;
nsresult
rv
=
ssm
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
channelPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mPrincipal
&
&
mPrincipal
-
>
GetIsNullPrincipal
(
)
&
&
channelPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
channelPrincipal
=
mPrincipal
;
}
nsCOMPtr
<
nsILoadGroup
>
channelLoadGroup
;
rv
=
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
channelLoadGroup
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
channelLoadGroup
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
mLoadingPrincipal
)
)
{
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
channelPrincipal
)
)
{
nsCOMPtr
<
nsIURI
>
finalURI
;
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
finalURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isResource
;
rv
=
NS_URIChainHasFlags
(
finalURI
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
isResource
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isResource
)
{
channelPrincipal
=
mLoadingPrincipal
;
}
else
{
return
NS_ERROR_DOM_BAD_URI
;
}
}
}
MOZ_ASSERT
(
NS_LoadGroupMatchesPrincipal
(
channelLoadGroup
channelPrincipal
)
)
;
channelPrincipal
.
forget
(
aPrincipalOut
)
;
channelLoadGroup
.
forget
(
aLoadGroupOut
)
;
return
NS_OK
;
}
nsresult
WorkerLoadInfo
:
:
SetPrincipalFromChannel
(
nsIChannel
*
aChannel
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
GetPrincipalAndLoadGroupFromChannel
(
aChannel
getter_AddRefs
(
principal
)
getter_AddRefs
(
loadGroup
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
SetPrincipalOnMainThread
(
principal
loadGroup
)
;
}
bool
WorkerLoadInfo
:
:
FinalChannelPrincipalIsValid
(
nsIChannel
*
aChannel
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
GetPrincipalAndLoadGroupFromChannel
(
aChannel
getter_AddRefs
(
principal
)
getter_AddRefs
(
loadGroup
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
principal
-
>
GetIsNullPrincipal
(
)
&
&
mPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
true
;
}
if
(
principal
-
>
Equals
(
mPrincipal
)
)
{
return
true
;
}
return
false
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
WorkerLoadInfo
:
:
PrincipalIsValid
(
)
const
{
return
mPrincipal
&
&
mPrincipalInfo
&
&
mPrincipalInfo
-
>
type
(
)
!
=
PrincipalInfo
:
:
T__None
&
&
mPrincipalInfo
-
>
type
(
)
<
=
PrincipalInfo
:
:
T__Last
;
}
bool
WorkerLoadInfo
:
:
PrincipalURIMatchesScriptURL
(
)
{
AssertIsOnMainThread
(
)
;
nsAutoCString
scheme
;
nsresult
rv
=
mBaseURI
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
mPrincipal
-
>
GetIsSystemPrincipal
(
)
)
{
if
(
scheme
=
=
NS_LITERAL_CSTRING
(
"
blob
"
)
)
{
return
true
;
}
bool
isResource
=
false
;
nsresult
rv
=
NS_URIChainHasFlags
(
mBaseURI
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
isResource
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
isResource
;
}
if
(
mPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
scheme
=
=
NS_LITERAL_CSTRING
(
"
data
"
)
|
|
scheme
=
=
NS_LITERAL_CSTRING
(
"
blob
"
)
;
}
if
(
scheme
=
=
NS_LITERAL_CSTRING
(
"
blob
"
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
principalURI
;
rv
=
mPrincipal
-
>
GetURI
(
getter_AddRefs
(
principalURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
NS_ENSURE_TRUE
(
principalURI
false
)
;
if
(
nsScriptSecurityManager
:
:
SecurityCompareURIs
(
mBaseURI
principalURI
)
)
{
return
true
;
}
if
(
nsScriptSecurityManager
:
:
GetStrictFileOriginPolicy
(
)
&
&
NS_URIIsLocalFile
(
mBaseURI
)
&
&
NS_RelaxStrictFileOriginPolicy
(
mBaseURI
principalURI
)
)
{
return
true
;
}
return
false
;
}
#
endif
bool
WorkerLoadInfo
:
:
ProxyReleaseMainThreadObjects
(
WorkerPrivate
*
aWorkerPrivate
)
{
nsCOMPtr
<
nsILoadGroup
>
nullLoadGroup
;
return
ProxyReleaseMainThreadObjects
(
aWorkerPrivate
nullLoadGroup
)
;
}
bool
WorkerLoadInfo
:
:
ProxyReleaseMainThreadObjects
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsILoadGroup
>
&
aLoadGroupToCancel
)
{
static
const
uint32_t
kDoomedCount
=
10
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
doomed
(
kDoomedCount
)
;
SwapToISupportsArray
(
mWindow
doomed
)
;
SwapToISupportsArray
(
mScriptContext
doomed
)
;
SwapToISupportsArray
(
mBaseURI
doomed
)
;
SwapToISupportsArray
(
mResolvedScriptURI
doomed
)
;
SwapToISupportsArray
(
mPrincipal
doomed
)
;
SwapToISupportsArray
(
mLoadingPrincipal
doomed
)
;
SwapToISupportsArray
(
mChannel
doomed
)
;
SwapToISupportsArray
(
mCSP
doomed
)
;
SwapToISupportsArray
(
mLoadGroup
doomed
)
;
SwapToISupportsArray
(
mInterfaceRequestor
doomed
)
;
MOZ_ASSERT
(
doomed
.
Length
(
)
=
=
kDoomedCount
)
;
RefPtr
<
MainThreadReleaseRunnable
>
runnable
=
new
MainThreadReleaseRunnable
(
doomed
aLoadGroupToCancel
)
;
return
NS_SUCCEEDED
(
aWorkerPrivate
-
>
DispatchToMainThread
(
runnable
.
forget
(
)
)
)
;
}
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
InterfaceRequestor
(
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsCOMPtr
<
nsILoadContext
>
baseContext
;
if
(
aLoadGroup
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
callbacks
-
>
GetInterface
(
NS_GET_IID
(
nsILoadContext
)
getter_AddRefs
(
baseContext
)
)
;
}
mOuterRequestor
=
callbacks
;
}
mLoadContext
=
new
LoadContext
(
aPrincipal
baseContext
)
;
}
void
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
MaybeAddTabChild
(
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aLoadGroup
)
{
return
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
!
callbacks
)
{
return
;
}
nsCOMPtr
<
nsITabChild
>
tabChild
;
callbacks
-
>
GetInterface
(
NS_GET_IID
(
nsITabChild
)
getter_AddRefs
(
tabChild
)
)
;
if
(
!
tabChild
)
{
return
;
}
mTabChildList
.
AppendElement
(
do_GetWeakReference
(
tabChild
)
)
;
}
NS_IMETHODIMP
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mLoadContext
)
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
)
{
nsCOMPtr
<
nsILoadContext
>
ref
=
mLoadContext
;
ref
.
forget
(
aSink
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsITabChild
)
)
)
{
nsCOMPtr
<
nsITabChild
>
tabChild
=
GetAnyLiveTabChild
(
)
;
if
(
!
tabChild
)
{
return
NS_NOINTERFACE
;
}
tabChild
.
forget
(
aSink
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsINetworkInterceptController
)
)
&
&
mOuterRequestor
)
{
return
mOuterRequestor
-
>
GetInterface
(
aIID
aSink
)
;
}
return
NS_NOINTERFACE
;
}
already_AddRefed
<
nsITabChild
>
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
GetAnyLiveTabChild
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
while
(
!
mTabChildList
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsITabChild
>
tabChild
=
do_QueryReferent
(
mTabChildList
.
LastElement
(
)
)
;
if
(
tabChild
&
&
!
static_cast
<
TabChild
*
>
(
tabChild
.
get
(
)
)
-
>
IsDestroyed
(
)
)
{
return
tabChild
.
forget
(
)
;
}
mTabChildList
.
RemoveLastElement
(
)
;
}
return
nullptr
;
}
NS_IMPL_ADDREF
(
WorkerLoadInfo
:
:
InterfaceRequestor
)
NS_IMPL_RELEASE
(
WorkerLoadInfo
:
:
InterfaceRequestor
)
NS_IMPL_QUERY_INTERFACE
(
WorkerLoadInfo
:
:
InterfaceRequestor
nsIInterfaceRequestor
)
}
}
