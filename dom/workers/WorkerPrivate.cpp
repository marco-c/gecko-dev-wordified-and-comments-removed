#
include
"
WorkerPrivate
.
h
"
#
include
"
amIAddonManager
.
h
"
#
include
"
nsIClassInfo
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIDOMDOMException
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsITabChild
.
h
"
#
include
"
nsITextToSubURI
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsIWorkerDebugger
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsPerformance
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
<
algorithm
>
#
include
"
ImageContainer
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
MemoryMetrics
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
LoadContext
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
ErrorEvent
.
h
"
#
include
"
mozilla
/
dom
/
ErrorEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
Exceptions
.
h
"
#
include
"
mozilla
/
dom
/
FunctionBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
MessageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePort
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortList
.
h
"
#
include
"
mozilla
/
dom
/
PMessagePort
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseDebugging
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneHolder
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
WorkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDebuggerGlobalScopeBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerGlobalScopeBinding
.
h
"
#
include
"
mozilla
/
dom
/
indexedDB
/
IDBFactory
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
mozilla
/
WorkerTimelineMarker
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
prthread
.
h
"
#
include
"
xpcpublic
.
h
"
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
#
ifdef
DEBUG
#
include
"
nsThreadManager
.
h
"
#
endif
#
include
"
Navigator
.
h
"
#
include
"
Principal
.
h
"
#
include
"
RuntimeService
.
h
"
#
include
"
ScriptLoader
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
ServiceWorkerWindowClient
.
h
"
#
include
"
SharedWorker
.
h
"
#
include
"
WorkerDebuggerManager
.
h
"
#
include
"
WorkerFeature
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
WorkerScope
.
h
"
#
include
"
WorkerThread
.
h
"
#
ifdef
XP_WIN
#
undef
PostMessage
#
endif
#
define
PERIODIC_GC_TIMER_DELAY_SEC
1
#
define
IDLE_GC_TIMER_DELAY_SEC
5
#
define
PREF_WORKERS_ENABLED
"
dom
.
workers
.
enabled
"
static
mozilla
:
:
LazyLogModule
sWorkerPrivateLog
(
"
WorkerPrivate
"
)
;
static
mozilla
:
:
LazyLogModule
sWorkerTimeoutsLog
(
"
WorkerTimeouts
"
)
;
mozilla
:
:
LogModule
*
WorkerLog
(
)
{
return
sWorkerPrivateLog
;
}
mozilla
:
:
LogModule
*
TimeoutsLog
(
)
{
return
sWorkerTimeoutsLog
;
}
#
define
LOG
(
log
_args
)
MOZ_LOG
(
log
LogLevel
:
:
Debug
_args
)
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
USING_WORKERS_NAMESPACE
MOZ_DEFINE_MALLOC_SIZE_OF
(
JsWorkerMallocSizeOf
)
#
ifdef
DEBUG
BEGIN_WORKERS_NAMESPACE
void
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
}
END_WORKERS_NAMESPACE
#
endif
namespace
{
#
ifdef
DEBUG
const
nsIID
kDEBUGWorkerEventTargetIID
=
{
0xccaba3fa
0x5be2
0x4de2
{
0xba
0x87
0x3b
0x3b
0x5b
0x1d
0x5
0xfb
}
}
;
#
endif
template
<
class
T
>
class
AutoPtrComparator
{
typedef
nsAutoPtr
<
T
>
A
;
typedef
T
*
B
;
public
:
bool
Equals
(
const
A
&
a
const
B
&
b
)
const
{
return
a
&
&
b
?
*
a
=
=
*
b
:
!
a
&
&
!
b
?
true
:
false
;
}
bool
LessThan
(
const
A
&
a
const
B
&
b
)
const
{
return
a
&
&
b
?
*
a
<
*
b
:
b
?
true
:
false
;
}
}
;
template
<
class
T
>
inline
AutoPtrComparator
<
T
>
GetAutoPtrComparator
(
const
nsTArray
<
nsAutoPtr
<
T
>
>
&
)
{
return
AutoPtrComparator
<
T
>
(
)
;
}
template
<
class
T
>
struct
ISupportsBaseInfo
{
typedef
T
ISupportsBase
;
}
;
template
<
template
<
class
>
class
SmartPtr
class
T
>
inline
void
SwapToISupportsArray
(
SmartPtr
<
T
>
&
aSrc
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
aDest
)
{
nsCOMPtr
<
nsISupports
>
*
dest
=
aDest
.
AppendElement
(
)
;
T
*
raw
=
nullptr
;
aSrc
.
swap
(
raw
)
;
nsISupports
*
rawSupports
=
static_cast
<
typename
ISupportsBaseInfo
<
T
>
:
:
ISupportsBase
*
>
(
raw
)
;
dest
-
>
swap
(
rawSupports
)
;
}
class
ExternalRunnableWrapper
final
:
public
WorkerRunnable
{
nsCOMPtr
<
nsICancelableRunnable
>
mWrappedRunnable
;
public
:
ExternalRunnableWrapper
(
WorkerPrivate
*
aWorkerPrivate
nsICancelableRunnable
*
aWrappedRunnable
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mWrappedRunnable
(
aWrappedRunnable
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWrappedRunnable
)
;
}
NS_DECL_ISUPPORTS_INHERITED
private
:
~
ExternalRunnableWrapper
(
)
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
nsresult
rv
=
mWrappedRunnable
-
>
Run
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
JS_IsExceptionPending
(
aCx
)
)
{
Throw
(
aCx
rv
)
;
}
return
false
;
}
return
true
;
}
NS_IMETHOD
Cancel
(
)
override
{
nsresult
rv
=
mWrappedRunnable
-
>
Cancel
(
)
;
nsresult
rv2
=
WorkerRunnable
:
:
Cancel
(
)
;
return
NS_FAILED
(
rv
)
?
rv
:
rv2
;
}
}
;
struct
WindowAction
{
nsPIDOMWindowInner
*
mWindow
;
bool
mDefaultAction
;
MOZ_IMPLICIT
WindowAction
(
nsPIDOMWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
mDefaultAction
(
true
)
{
}
bool
operator
=
=
(
const
WindowAction
&
aOther
)
const
{
return
mWindow
=
=
aOther
.
mWindow
;
}
}
;
void
LogErrorToConsole
(
const
nsAString
&
aMessage
const
nsAString
&
aFilename
const
nsAString
&
aLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
uint64_t
aInnerWindowId
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIScriptError
>
scriptError
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
;
NS_WARN_IF_FALSE
(
scriptError
"
Failed
to
create
script
error
!
"
)
;
if
(
scriptError
)
{
if
(
NS_FAILED
(
scriptError
-
>
InitWithWindowID
(
aMessage
aFilename
aLine
aLineNumber
aColumnNumber
aFlags
"
Web
Worker
"
aInnerWindowId
)
)
)
{
NS_WARNING
(
"
Failed
to
init
script
error
!
"
)
;
scriptError
=
nullptr
;
}
}
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
NS_WARN_IF_FALSE
(
consoleService
"
Failed
to
get
console
service
!
"
)
;
if
(
consoleService
)
{
if
(
scriptError
)
{
if
(
NS_SUCCEEDED
(
consoleService
-
>
LogMessage
(
scriptError
)
)
)
{
return
;
}
NS_WARNING
(
"
LogMessage
failed
!
"
)
;
}
else
if
(
NS_SUCCEEDED
(
consoleService
-
>
LogStringMessage
(
aMessage
.
BeginReading
(
)
)
)
)
{
return
;
}
NS_WARNING
(
"
LogStringMessage
failed
!
"
)
;
}
NS_ConvertUTF16toUTF8
msg
(
aMessage
)
;
NS_ConvertUTF16toUTF8
filename
(
aFilename
)
;
static
const
char
kErrorString
[
]
=
"
JS
error
in
Web
Worker
:
%
s
[
%
s
:
%
u
]
"
;
#
ifdef
ANDROID
__android_log_print
(
ANDROID_LOG_INFO
"
Gecko
"
kErrorString
msg
.
get
(
)
filename
.
get
(
)
aLineNumber
)
;
#
endif
fprintf
(
stderr
kErrorString
msg
.
get
(
)
filename
.
get
(
)
aLineNumber
)
;
fflush
(
stderr
)
;
}
class
MainThreadReleaseRunnable
final
:
public
nsRunnable
{
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
mDoomed
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroupToCancel
;
public
:
MainThreadReleaseRunnable
(
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
aDoomed
nsCOMPtr
<
nsILoadGroup
>
&
aLoadGroupToCancel
)
{
mDoomed
.
SwapElements
(
aDoomed
)
;
mLoadGroupToCancel
.
swap
(
aLoadGroupToCancel
)
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
Run
(
)
override
{
if
(
mLoadGroupToCancel
)
{
mLoadGroupToCancel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mLoadGroupToCancel
=
nullptr
;
}
mDoomed
.
Clear
(
)
;
return
NS_OK
;
}
private
:
~
MainThreadReleaseRunnable
(
)
{
}
}
;
class
WorkerFinishedRunnable
final
:
public
WorkerControlRunnable
{
WorkerPrivate
*
mFinishedWorker
;
public
:
WorkerFinishedRunnable
(
WorkerPrivate
*
aWorkerPrivate
WorkerPrivate
*
aFinishedWorker
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mFinishedWorker
(
aFinishedWorker
)
{
}
private
:
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
nsCOMPtr
<
nsILoadGroup
>
loadGroupToCancel
;
mFinishedWorker
-
>
ForgetOverridenLoadGroup
(
loadGroupToCancel
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
doomed
;
mFinishedWorker
-
>
ForgetMainThreadObjects
(
doomed
)
;
RefPtr
<
MainThreadReleaseRunnable
>
runnable
=
new
MainThreadReleaseRunnable
(
doomed
loadGroupToCancel
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
going
to
leak
!
"
)
;
}
RuntimeService
*
runtime
=
RuntimeService
:
:
GetService
(
)
;
NS_ASSERTION
(
runtime
"
This
should
never
be
null
!
"
)
;
mFinishedWorker
-
>
DisableDebugger
(
)
;
runtime
-
>
UnregisterWorker
(
aCx
mFinishedWorker
)
;
mFinishedWorker
-
>
ClearSelfRef
(
)
;
return
true
;
}
}
;
class
TopLevelWorkerFinishedRunnable
final
:
public
nsRunnable
{
WorkerPrivate
*
mFinishedWorker
;
public
:
explicit
TopLevelWorkerFinishedRunnable
(
WorkerPrivate
*
aFinishedWorker
)
:
mFinishedWorker
(
aFinishedWorker
)
{
aFinishedWorker
-
>
AssertIsOnWorkerThread
(
)
;
}
NS_DECL_ISUPPORTS_INHERITED
private
:
~
TopLevelWorkerFinishedRunnable
(
)
{
}
NS_IMETHOD
Run
(
)
override
{
AssertIsOnMainThread
(
)
;
RuntimeService
*
runtime
=
RuntimeService
:
:
GetService
(
)
;
MOZ_ASSERT
(
runtime
)
;
AutoSafeJSContext
cx
;
JSAutoRequest
ar
(
cx
)
;
mFinishedWorker
-
>
DisableDebugger
(
)
;
runtime
-
>
UnregisterWorker
(
cx
mFinishedWorker
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroupToCancel
;
mFinishedWorker
-
>
ForgetOverridenLoadGroup
(
loadGroupToCancel
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
doomed
;
mFinishedWorker
-
>
ForgetMainThreadObjects
(
doomed
)
;
RefPtr
<
MainThreadReleaseRunnable
>
runnable
=
new
MainThreadReleaseRunnable
(
doomed
loadGroupToCancel
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThread
(
runnable
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
going
to
leak
!
"
)
;
}
mFinishedWorker
-
>
ClearSelfRef
(
)
;
return
NS_OK
;
}
}
;
class
ModifyBusyCountRunnable
final
:
public
WorkerControlRunnable
{
bool
mIncrease
;
public
:
ModifyBusyCountRunnable
(
WorkerPrivate
*
aWorkerPrivate
bool
aIncrease
)
:
WorkerControlRunnable
(
aWorkerPrivate
ParentThreadUnchangedBusyCount
)
mIncrease
(
aIncrease
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
ModifyBusyCount
(
aCx
mIncrease
)
;
}
virtual
void
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
override
{
if
(
mIncrease
)
{
WorkerControlRunnable
:
:
PostRun
(
aCx
aWorkerPrivate
aRunResult
)
;
return
;
}
}
}
;
class
CompileScriptRunnable
final
:
public
WorkerRunnable
{
nsString
mScriptURL
;
public
:
explicit
CompileScriptRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsAString
&
aScriptURL
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
mScriptURL
(
aScriptURL
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
ErrorResult
rv
;
scriptloader
:
:
LoadMainScript
(
aCx
mScriptURL
WorkerScript
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
false
;
}
aWorkerPrivate
-
>
SetWorkerScriptExecutedSuccessfully
(
)
;
return
true
;
}
}
;
class
CompileDebuggerScriptRunnable
final
:
public
WorkerDebuggerRunnable
{
nsString
mScriptURL
;
public
:
CompileDebuggerScriptRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsAString
&
aScriptURL
)
:
WorkerDebuggerRunnable
(
aWorkerPrivate
)
mScriptURL
(
aScriptURL
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
WorkerDebuggerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
CreateDebuggerGlobalScope
(
aCx
)
;
if
(
!
globalScope
)
{
NS_WARNING
(
"
Failed
to
make
global
!
"
)
;
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
globalScope
-
>
GetWrapper
(
)
)
;
ErrorResult
rv
;
JSAutoCompartment
ac
(
aCx
global
)
;
scriptloader
:
:
LoadMainScript
(
aCx
mScriptURL
DebuggerScript
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
false
;
}
return
true
;
}
}
;
class
CloseEventRunnable
final
:
public
WorkerRunnable
{
public
:
explicit
CloseEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
private
:
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_CRASH
(
"
Don
'
t
call
Dispatch
(
)
on
CloseEventRunnable
!
"
)
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
MOZ_CRASH
(
"
Don
'
t
call
Dispatch
(
)
on
CloseEventRunnable
!
"
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
JS
:
:
Rooted
<
JSObject
*
>
target
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
NS_ASSERTION
(
target
"
This
must
never
be
null
!
"
)
;
aWorkerPrivate
-
>
CloseHandlerStarted
(
)
;
WorkerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
globalScope
nullptr
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
close
"
)
false
false
)
;
event
-
>
SetTrusted
(
true
)
;
globalScope
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
return
true
;
}
NS_IMETHOD
Cancel
(
)
override
{
Run
(
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
virtual
void
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
override
{
WorkerRunnable
:
:
PostRun
(
aCx
aWorkerPrivate
aRunResult
)
;
if
(
!
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
aCx
false
)
)
{
JS_ReportPendingException
(
aCx
)
;
}
aWorkerPrivate
-
>
CloseHandlerFinished
(
)
;
}
}
;
class
MessageEventRunnable
final
:
public
WorkerRunnable
public
StructuredCloneHolder
{
UniquePtr
<
ServiceWorkerClientInfo
>
mEventSource
;
public
:
MessageEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
)
:
WorkerRunnable
(
aWorkerPrivate
aBehavior
)
StructuredCloneHolder
(
CloningSupported
TransferringSupported
SameProcessDifferentThread
)
{
}
void
SetMessageSource
(
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aSource
)
{
mEventSource
=
Move
(
aSource
)
;
}
bool
DispatchDOMEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
DOMEventTargetHelper
*
aTarget
bool
aIsMainThread
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
parent
;
if
(
aIsMainThread
)
{
parent
=
do_QueryInterface
(
aTarget
-
>
GetParentObject
(
)
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
messageData
(
aCx
)
;
ErrorResult
rv
;
UniquePtr
<
AbstractTimelineMarker
>
start
;
UniquePtr
<
AbstractTimelineMarker
>
end
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
!
timelines
-
>
IsEmpty
(
)
;
if
(
isTimelineRecording
)
{
start
=
MakeUnique
<
WorkerTimelineMarker
>
(
aIsMainThread
?
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOffMainThread
MarkerTracingType
:
:
START
)
;
}
Read
(
parent
aCx
&
messageData
rv
)
;
if
(
isTimelineRecording
)
{
end
=
MakeUnique
<
WorkerTimelineMarker
>
(
aIsMainThread
?
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
DeserializeDataOffMainThread
MarkerTracingType
:
:
END
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
start
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
end
)
;
}
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
xpc
:
:
Throw
(
aCx
rv
.
StealNSResult
(
)
)
;
return
false
;
}
nsTArray
<
RefPtr
<
MessagePort
>
>
ports
=
TakeTransferredPorts
(
)
;
nsCOMPtr
<
nsIDOMEvent
>
domEvent
;
if
(
mEventSource
)
{
RefPtr
<
ServiceWorkerClient
>
client
=
new
ServiceWorkerWindowClient
(
aTarget
*
mEventSource
)
;
RootedDictionary
<
ExtendableMessageEventInit
>
init
(
aCx
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mData
=
messageData
;
init
.
mPorts
.
Construct
(
)
;
init
.
mPorts
.
Value
(
)
.
SetNull
(
)
;
ErrorResult
rv
;
RefPtr
<
ExtendableMessageEvent
>
event
=
ExtendableMessageEvent
:
:
Constructor
(
aTarget
NS_LITERAL_STRING
(
"
message
"
)
init
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
false
;
}
event
-
>
SetSource
(
client
)
;
event
-
>
SetPorts
(
new
MessagePortList
(
static_cast
<
dom
:
:
Event
*
>
(
event
.
get
(
)
)
ports
)
)
;
domEvent
=
do_QueryObject
(
event
)
;
}
else
{
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
aTarget
nullptr
nullptr
)
;
event
-
>
InitMessageEvent
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
false
false
messageData
EmptyString
(
)
EmptyString
(
)
nullptr
nullptr
)
;
event
-
>
SetPorts
(
new
MessagePortList
(
static_cast
<
dom
:
:
Event
*
>
(
event
.
get
(
)
)
ports
)
)
;
domEvent
=
do_QueryObject
(
event
)
;
}
domEvent
-
>
SetTrusted
(
true
)
;
nsEventStatus
dummy
=
nsEventStatus_eIgnore
;
aTarget
-
>
DispatchDOMEvent
(
nullptr
domEvent
nullptr
&
dummy
)
;
return
true
;
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
if
(
mBehavior
=
=
ParentThreadUnchangedBusyCount
)
{
if
(
!
aWorkerPrivate
-
>
IsAcceptingEvents
(
)
)
{
return
true
;
}
if
(
aWorkerPrivate
-
>
IsFrozen
(
)
|
|
aWorkerPrivate
-
>
IsSuspended
(
)
)
{
MOZ_ASSERT
(
!
IsDebuggerRunnable
(
)
)
;
aWorkerPrivate
-
>
QueueRunnable
(
this
)
;
return
true
;
}
aWorkerPrivate
-
>
AssertInnerWindowIsCorrect
(
)
;
return
DispatchDOMEvent
(
aCx
aWorkerPrivate
aWorkerPrivate
!
aWorkerPrivate
-
>
GetParent
(
)
)
;
}
MOZ_ASSERT
(
aWorkerPrivate
=
=
GetWorkerPrivateFromContext
(
aCx
)
)
;
return
DispatchDOMEvent
(
aCx
aWorkerPrivate
aWorkerPrivate
-
>
GlobalScope
(
)
false
)
;
}
}
;
class
DebuggerMessageEventRunnable
:
public
WorkerDebuggerRunnable
{
nsString
mMessage
;
public
:
DebuggerMessageEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsAString
&
aMessage
)
:
WorkerDebuggerRunnable
(
aWorkerPrivate
)
mMessage
(
aMessage
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
WorkerDebuggerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
DebuggerGlobalScope
(
)
;
MOZ_ASSERT
(
globalScope
)
;
JS
:
:
Rooted
<
JSString
*
>
message
(
aCx
JS_NewUCStringCopyN
(
aCx
mMessage
.
get
(
)
mMessage
.
Length
(
)
)
)
;
if
(
!
message
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
data
(
aCx
JS
:
:
StringValue
(
message
)
)
;
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
globalScope
nullptr
nullptr
)
;
event
-
>
InitMessageEvent
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
false
true
data
EmptyString
(
)
EmptyString
(
)
nullptr
nullptr
)
;
event
-
>
SetTrusted
(
true
)
;
nsCOMPtr
<
nsIDOMEvent
>
domEvent
=
do_QueryObject
(
event
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
globalScope
-
>
DispatchDOMEvent
(
nullptr
domEvent
nullptr
&
status
)
;
return
true
;
}
}
;
class
NotifyRunnable
final
:
public
WorkerControlRunnable
{
Status
mStatus
;
public
:
NotifyRunnable
(
WorkerPrivate
*
aWorkerPrivate
Status
aStatus
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mStatus
(
aStatus
)
{
MOZ_ASSERT
(
aStatus
=
=
Closing
|
|
aStatus
=
=
Terminating
|
|
aStatus
=
=
Canceling
|
|
aStatus
=
=
Killing
)
;
}
private
:
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
ModifyBusyCount
(
aCx
true
)
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
if
(
!
aDispatchResult
)
{
aWorkerPrivate
-
>
ModifyBusyCount
(
aCx
false
)
;
}
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
NotifyInternal
(
aCx
mStatus
)
;
}
}
;
class
CloseRunnable
final
:
public
WorkerControlRunnable
{
public
:
explicit
CloseRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerControlRunnable
(
aWorkerPrivate
ParentThreadUnchangedBusyCount
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
ModifyBusyCount
(
aCx
true
)
&
&
aWorkerPrivate
-
>
Close
(
)
;
}
}
;
class
FreezeRunnable
final
:
public
WorkerControlRunnable
{
public
:
explicit
FreezeRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
FreezeInternal
(
aCx
)
;
}
}
;
class
ThawRunnable
final
:
public
WorkerControlRunnable
{
public
:
explicit
ThawRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
ThawInternal
(
aCx
)
;
}
}
;
class
ReportErrorRunnable
final
:
public
WorkerRunnable
{
nsString
mMessage
;
nsString
mFilename
;
nsString
mLine
;
uint32_t
mLineNumber
;
uint32_t
mColumnNumber
;
uint32_t
mFlags
;
uint32_t
mErrorNumber
;
JSExnType
mExnType
;
bool
mMutedError
;
public
:
static
bool
ReportError
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aFireAtScope
WorkerPrivate
*
aTarget
const
nsString
&
aMessage
const
nsString
&
aFilename
const
nsString
&
aLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
uint32_t
aErrorNumber
JSExnType
aExnType
bool
aMutedError
uint64_t
aInnerWindowId
)
{
if
(
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
else
{
AssertIsOnMainThread
(
)
;
}
JS
:
:
Rooted
<
JSString
*
>
message
(
aCx
JS_NewUCStringCopyN
(
aCx
aMessage
.
get
(
)
aMessage
.
Length
(
)
)
)
;
if
(
!
message
)
{
return
false
;
}
JS
:
:
Rooted
<
JSString
*
>
filename
(
aCx
JS_NewUCStringCopyN
(
aCx
aFilename
.
get
(
)
aFilename
.
Length
(
)
)
)
;
if
(
!
filename
)
{
return
false
;
}
if
(
!
JSREPORT_IS_WARNING
(
aFlags
)
)
{
RootedDictionary
<
ErrorEventInit
>
init
(
aCx
)
;
if
(
aMutedError
)
{
init
.
mMessage
.
AssignLiteral
(
"
Script
error
.
"
)
;
}
else
{
init
.
mMessage
=
aMessage
;
init
.
mFilename
=
aFilename
;
init
.
mLineno
=
aLineNumber
;
}
init
.
mCancelable
=
true
;
init
.
mBubbles
=
false
;
if
(
aTarget
)
{
RefPtr
<
ErrorEvent
>
event
=
ErrorEvent
:
:
Constructor
(
aTarget
NS_LITERAL_STRING
(
"
error
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
aTarget
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
&
status
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
true
;
}
}
if
(
aFireAtScope
&
&
(
aTarget
|
|
aErrorNumber
!
=
JSMSG_OVER_RECURSED
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
NS_ASSERTION
(
global
"
This
should
never
be
null
!
"
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsIScriptGlobalObject
*
sgo
;
if
(
aWorkerPrivate
)
{
WorkerGlobalScope
*
globalScope
=
nullptr
;
UNWRAP_WORKER_OBJECT
(
WorkerGlobalScope
global
globalScope
)
;
if
(
!
globalScope
)
{
WorkerDebuggerGlobalScope
*
globalScope
=
nullptr
;
UNWRAP_OBJECT
(
WorkerDebuggerGlobalScope
global
globalScope
)
;
MOZ_ASSERT_IF
(
globalScope
globalScope
-
>
GetWrapperPreserveColor
(
)
=
=
global
)
;
MOZ_ASSERT_IF
(
!
globalScope
IsDebuggerSandbox
(
global
)
)
;
aWorkerPrivate
-
>
ReportErrorToDebugger
(
aFilename
aLineNumber
aMessage
)
;
return
true
;
}
MOZ_ASSERT
(
globalScope
-
>
GetWrapperPreserveColor
(
)
=
=
global
)
;
nsIDOMEventTarget
*
target
=
static_cast
<
nsIDOMEventTarget
*
>
(
globalScope
)
;
RefPtr
<
ErrorEvent
>
event
=
ErrorEvent
:
:
Constructor
(
aTarget
NS_LITERAL_STRING
(
"
error
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
if
(
NS_FAILED
(
EventDispatcher
:
:
DispatchDOMEvent
(
target
nullptr
event
nullptr
&
status
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
worker
thread
error
event
!
"
)
;
status
=
nsEventStatus_eIgnore
;
}
}
else
if
(
(
sgo
=
nsJSUtils
:
:
GetStaticScriptGlobal
(
global
)
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
sgo
-
>
HandleScriptError
(
init
&
status
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
main
thread
error
event
!
"
)
;
status
=
nsEventStatus_eIgnore
;
}
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
true
;
}
}
}
if
(
aWorkerPrivate
)
{
RefPtr
<
ReportErrorRunnable
>
runnable
=
new
ReportErrorRunnable
(
aWorkerPrivate
aMessage
aFilename
aLine
aLineNumber
aColumnNumber
aFlags
aErrorNumber
aExnType
aMutedError
)
;
return
runnable
-
>
Dispatch
(
aCx
)
;
}
LogErrorToConsole
(
aMessage
aFilename
aLine
aLineNumber
aColumnNumber
aFlags
aInnerWindowId
)
;
return
true
;
}
private
:
ReportErrorRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsString
&
aMessage
const
nsString
&
aFilename
const
nsString
&
aLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
uint32_t
aErrorNumber
JSExnType
aExnType
bool
aMutedError
)
:
WorkerRunnable
(
aWorkerPrivate
ParentThreadUnchangedBusyCount
)
mMessage
(
aMessage
)
mFilename
(
aFilename
)
mLine
(
aLine
)
mLineNumber
(
aLineNumber
)
mColumnNumber
(
aColumnNumber
)
mFlags
(
aFlags
)
mErrorNumber
(
aErrorNumber
)
mExnType
(
aExnType
)
mMutedError
(
aMutedError
)
{
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
JS
:
:
Rooted
<
JSObject
*
>
target
(
aCx
aWorkerPrivate
-
>
GetWrapper
(
)
)
;
uint64_t
innerWindowId
;
bool
fireAtScope
=
true
;
bool
workerIsAcceptingEvents
=
aWorkerPrivate
-
>
IsAcceptingEvents
(
)
;
WorkerPrivate
*
parent
=
aWorkerPrivate
-
>
GetParent
(
)
;
if
(
parent
)
{
innerWindowId
=
0
;
}
else
{
AssertIsOnMainThread
(
)
;
if
(
aWorkerPrivate
-
>
IsFrozen
(
)
|
|
aWorkerPrivate
-
>
IsSuspended
(
)
)
{
MOZ_ASSERT
(
!
IsDebuggerRunnable
(
)
)
;
aWorkerPrivate
-
>
QueueRunnable
(
this
)
;
return
true
;
}
if
(
aWorkerPrivate
-
>
IsSharedWorker
(
)
)
{
aWorkerPrivate
-
>
BroadcastErrorToSharedWorkers
(
aCx
mMessage
mFilename
mLine
mLineNumber
mColumnNumber
mFlags
)
;
return
true
;
}
if
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
{
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
MOZ_ASSERT
(
swm
)
;
swm
-
>
HandleError
(
aCx
aWorkerPrivate
-
>
GetPrincipal
(
)
aWorkerPrivate
-
>
WorkerName
(
)
aWorkerPrivate
-
>
ScriptURL
(
)
mMessage
mFilename
mLine
mLineNumber
mColumnNumber
mFlags
mExnType
)
;
return
true
;
}
if
(
workerIsAcceptingEvents
)
{
aWorkerPrivate
-
>
AssertInnerWindowIsCorrect
(
)
;
innerWindowId
=
aWorkerPrivate
-
>
WindowID
(
)
;
}
}
if
(
!
workerIsAcceptingEvents
)
{
return
true
;
}
return
ReportError
(
aCx
parent
fireAtScope
aWorkerPrivate
mMessage
mFilename
mLine
mLineNumber
mColumnNumber
mFlags
mErrorNumber
mExnType
mMutedError
innerWindowId
)
;
}
}
;
class
TimerRunnable
final
:
public
WorkerRunnable
public
nsITimerCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
explicit
TimerRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
private
:
~
TimerRunnable
(
)
{
}
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
RunExpiredTimeouts
(
aCx
)
;
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
return
Run
(
)
;
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
TimerRunnable
WorkerRunnable
nsITimerCallback
)
class
DebuggerImmediateRunnable
:
public
WorkerRunnable
{
RefPtr
<
dom
:
:
Function
>
mHandler
;
public
:
explicit
DebuggerImmediateRunnable
(
WorkerPrivate
*
aWorkerPrivate
dom
:
:
Function
&
aHandler
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mHandler
(
&
aHandler
)
{
}
private
:
virtual
bool
IsDebuggerRunnable
(
)
const
override
{
return
true
;
}
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
callable
(
aCx
JS
:
:
ObjectValue
(
*
mHandler
-
>
Callable
(
)
)
)
;
JS
:
:
HandleValueArray
args
=
JS
:
:
HandleValueArray
:
:
empty
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
aCx
)
;
if
(
!
JS_CallFunctionValue
(
aCx
global
callable
args
&
rval
)
&
&
!
JS_ReportPendingException
(
aCx
)
)
{
return
false
;
}
return
true
;
}
}
;
void
DummyCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
}
class
KillCloseEventRunnable
final
:
public
WorkerRunnable
{
nsCOMPtr
<
nsITimer
>
mTimer
;
class
KillScriptRunnable
final
:
public
WorkerControlRunnable
{
public
:
explicit
KillScriptRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
private
:
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
false
;
}
}
;
public
:
explicit
KillCloseEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
bool
SetTimeout
(
JSContext
*
aCx
uint32_t
aDelayMS
)
{
nsCOMPtr
<
nsITimer
>
timer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
if
(
!
timer
)
{
JS_ReportError
(
aCx
"
Failed
to
create
timer
!
"
)
;
return
false
;
}
RefPtr
<
KillScriptRunnable
>
runnable
=
new
KillScriptRunnable
(
mWorkerPrivate
)
;
RefPtr
<
TimerThreadEventTarget
>
target
=
new
TimerThreadEventTarget
(
mWorkerPrivate
runnable
)
;
if
(
NS_FAILED
(
timer
-
>
SetTarget
(
target
)
)
)
{
JS_ReportError
(
aCx
"
Failed
to
set
timer
'
s
target
!
"
)
;
return
false
;
}
if
(
NS_FAILED
(
timer
-
>
InitWithNamedFuncCallback
(
DummyCallback
nullptr
aDelayMS
nsITimer
:
:
TYPE_ONE_SHOT
"
dom
:
:
workers
:
:
DummyCallback
(
1
)
"
)
)
)
{
JS_ReportError
(
aCx
"
Failed
to
start
timer
!
"
)
;
return
false
;
}
mTimer
.
swap
(
timer
)
;
return
true
;
}
private
:
~
KillCloseEventRunnable
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_CRASH
(
"
Don
'
t
call
Dispatch
(
)
on
KillCloseEventRunnable
!
"
)
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
MOZ_CRASH
(
"
Don
'
t
call
Dispatch
(
)
on
KillCloseEventRunnable
!
"
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
return
true
;
}
NS_IMETHOD
Cancel
(
)
override
{
Run
(
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
}
;
class
UpdateRuntimeOptionsRunnable
final
:
public
WorkerControlRunnable
{
JS
:
:
RuntimeOptions
mRuntimeOptions
;
public
:
UpdateRuntimeOptionsRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
JS
:
:
RuntimeOptions
&
aRuntimeOptions
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mRuntimeOptions
(
aRuntimeOptions
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
UpdateRuntimeOptionsInternal
(
aCx
mRuntimeOptions
)
;
return
true
;
}
}
;
class
UpdatePreferenceRunnable
final
:
public
WorkerControlRunnable
{
WorkerPreference
mPref
;
bool
mValue
;
public
:
UpdatePreferenceRunnable
(
WorkerPrivate
*
aWorkerPrivate
WorkerPreference
aPref
bool
aValue
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mPref
(
aPref
)
mValue
(
aValue
)
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
UpdatePreferenceInternal
(
aCx
mPref
mValue
)
;
return
true
;
}
}
;
class
UpdateLanguagesRunnable
final
:
public
WorkerRunnable
{
nsTArray
<
nsString
>
mLanguages
;
public
:
UpdateLanguagesRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsTArray
<
nsString
>
&
aLanguages
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
mLanguages
(
aLanguages
)
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
UpdateLanguagesInternal
(
aCx
mLanguages
)
;
return
true
;
}
}
;
class
UpdateJSWorkerMemoryParameterRunnable
final
:
public
WorkerControlRunnable
{
uint32_t
mValue
;
JSGCParamKey
mKey
;
public
:
UpdateJSWorkerMemoryParameterRunnable
(
WorkerPrivate
*
aWorkerPrivate
JSGCParamKey
aKey
uint32_t
aValue
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mValue
(
aValue
)
mKey
(
aKey
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
UpdateJSWorkerMemoryParameterInternal
(
aCx
mKey
mValue
)
;
return
true
;
}
}
;
#
ifdef
JS_GC_ZEAL
class
UpdateGCZealRunnable
final
:
public
WorkerControlRunnable
{
uint8_t
mGCZeal
;
uint32_t
mFrequency
;
public
:
UpdateGCZealRunnable
(
WorkerPrivate
*
aWorkerPrivate
uint8_t
aGCZeal
uint32_t
aFrequency
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mGCZeal
(
aGCZeal
)
mFrequency
(
aFrequency
)
{
}
private
:
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
UpdateGCZealInternal
(
aCx
mGCZeal
mFrequency
)
;
return
true
;
}
}
;
#
endif
class
GarbageCollectRunnable
final
:
public
WorkerControlRunnable
{
bool
mShrinking
;
bool
mCollectChildren
;
public
:
GarbageCollectRunnable
(
WorkerPrivate
*
aWorkerPrivate
bool
aShrinking
bool
aCollectChildren
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mShrinking
(
aShrinking
)
mCollectChildren
(
aCollectChildren
)
{
}
private
:
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
GarbageCollectInternal
(
aCx
mShrinking
mCollectChildren
)
;
return
true
;
}
}
;
class
CycleCollectRunnable
:
public
WorkerControlRunnable
{
bool
mCollectChildren
;
public
:
CycleCollectRunnable
(
WorkerPrivate
*
aWorkerPrivate
bool
aCollectChildren
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mCollectChildren
(
aCollectChildren
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
CycleCollectInternal
(
aCx
mCollectChildren
)
;
return
true
;
}
}
;
class
OfflineStatusChangeRunnable
:
public
WorkerRunnable
{
public
:
OfflineStatusChangeRunnable
(
WorkerPrivate
*
aWorkerPrivate
bool
aIsOffline
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
mIsOffline
(
aIsOffline
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
OfflineStatusChangeEventInternal
(
aCx
mIsOffline
)
;
return
true
;
}
private
:
bool
mIsOffline
;
}
;
#
ifdef
DEBUG
static
bool
StartsWithExplicit
(
nsACString
&
s
)
{
return
StringBeginsWith
(
s
NS_LITERAL_CSTRING
(
"
explicit
/
"
)
)
;
}
#
endif
class
WorkerJSRuntimeStats
:
public
JS
:
:
RuntimeStats
{
const
nsACString
&
mRtPath
;
public
:
explicit
WorkerJSRuntimeStats
(
const
nsACString
&
aRtPath
)
:
JS
:
:
RuntimeStats
(
JsWorkerMallocSizeOf
)
mRtPath
(
aRtPath
)
{
}
~
WorkerJSRuntimeStats
(
)
{
for
(
size_t
i
=
0
;
i
!
=
zoneStatsVector
.
length
(
)
;
i
+
+
)
{
delete
static_cast
<
xpc
:
:
ZoneStatsExtras
*
>
(
zoneStatsVector
[
i
]
.
extra
)
;
}
for
(
size_t
i
=
0
;
i
!
=
compartmentStatsVector
.
length
(
)
;
i
+
+
)
{
delete
static_cast
<
xpc
:
:
CompartmentStatsExtras
*
>
(
compartmentStatsVector
[
i
]
.
extra
)
;
}
}
virtual
void
initExtraZoneStats
(
JS
:
:
Zone
*
aZone
JS
:
:
ZoneStats
*
aZoneStats
)
override
{
MOZ_ASSERT
(
!
aZoneStats
-
>
extra
)
;
xpc
:
:
ZoneStatsExtras
*
extras
=
new
xpc
:
:
ZoneStatsExtras
;
extras
-
>
pathPrefix
=
mRtPath
;
extras
-
>
pathPrefix
+
=
nsPrintfCString
(
"
zone
(
0x
%
p
)
/
"
(
void
*
)
aZone
)
;
MOZ_ASSERT
(
StartsWithExplicit
(
extras
-
>
pathPrefix
)
)
;
aZoneStats
-
>
extra
=
extras
;
}
virtual
void
initExtraCompartmentStats
(
JSCompartment
*
aCompartment
JS
:
:
CompartmentStats
*
aCompartmentStats
)
override
{
MOZ_ASSERT
(
!
aCompartmentStats
-
>
extra
)
;
xpc
:
:
CompartmentStatsExtras
*
extras
=
new
xpc
:
:
CompartmentStatsExtras
;
extras
-
>
jsPathPrefix
.
Assign
(
mRtPath
)
;
extras
-
>
jsPathPrefix
+
=
nsPrintfCString
(
"
zone
(
0x
%
p
)
/
"
(
void
*
)
js
:
:
GetCompartmentZone
(
aCompartment
)
)
;
extras
-
>
jsPathPrefix
+
=
js
:
:
IsAtomsCompartment
(
aCompartment
)
?
NS_LITERAL_CSTRING
(
"
compartment
(
web
-
worker
-
atoms
)
/
"
)
:
NS_LITERAL_CSTRING
(
"
compartment
(
web
-
worker
)
/
"
)
;
extras
-
>
domPathPrefix
.
AssignLiteral
(
"
explicit
/
workers
/
?
!
/
"
)
;
MOZ_ASSERT
(
StartsWithExplicit
(
extras
-
>
jsPathPrefix
)
)
;
MOZ_ASSERT
(
StartsWithExplicit
(
extras
-
>
domPathPrefix
)
)
;
extras
-
>
location
=
nullptr
;
aCompartmentStats
-
>
extra
=
extras
;
}
}
;
class
MessagePortRunnable
final
:
public
WorkerRunnable
{
MessagePortIdentifier
mPortIdentifier
;
public
:
MessagePortRunnable
(
WorkerPrivate
*
aWorkerPrivate
MessagePort
*
aPort
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
{
MOZ_ASSERT
(
aPort
)
;
aPort
-
>
CloneAndDisentangle
(
mPortIdentifier
)
;
}
private
:
~
MessagePortRunnable
(
)
{
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
aWorkerPrivate
-
>
ConnectMessagePort
(
aCx
mPortIdentifier
)
;
}
NS_IMETHOD
Cancel
(
)
override
{
MessagePort
:
:
ForceClose
(
mPortIdentifier
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
}
;
class
DummyRunnable
final
:
public
WorkerRunnable
{
public
:
explicit
DummyRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
private
:
~
DummyRunnable
(
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
virtual
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
never
call
Dispatch
on
this
!
"
)
;
return
true
;
}
virtual
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
never
call
Dispatch
on
this
!
"
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
}
;
PRThread
*
PRThreadFromThread
(
nsIThread
*
aThread
)
{
MOZ_ASSERT
(
aThread
)
;
PRThread
*
result
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
aThread
-
>
GetPRThread
(
&
result
)
)
)
;
MOZ_ASSERT
(
result
)
;
return
result
;
}
}
NS_IMPL_ISUPPORTS_INHERITED0
(
MainThreadReleaseRunnable
nsRunnable
)
NS_IMPL_ISUPPORTS_INHERITED0
(
TopLevelWorkerFinishedRunnable
nsRunnable
)
TimerThreadEventTarget
:
:
TimerThreadEventTarget
(
WorkerPrivate
*
aWorkerPrivate
WorkerRunnable
*
aWorkerRunnable
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mWorkerRunnable
(
aWorkerRunnable
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerRunnable
)
;
}
TimerThreadEventTarget
:
:
~
TimerThreadEventTarget
(
)
{
}
NS_IMETHODIMP
TimerThreadEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
Dispatch
(
runnable
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
TimerThreadEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint32_t
aFlags
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aFlags
=
=
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
RefPtr
<
TimerThreadEventTarget
>
kungFuDeathGrip
=
this
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
runnable
-
>
Run
(
)
;
mWorkerRunnable
-
>
Dispatch
(
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TimerThreadEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
MOZ_ASSERT
(
aIsOnCurrentThread
)
;
nsresult
rv
=
mWorkerPrivate
-
>
IsOnCurrentThread
(
aIsOnCurrentThread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
TimerThreadEventTarget
nsIEventTarget
)
WorkerLoadInfo
:
:
WorkerLoadInfo
(
)
:
mWindowID
(
UINT64_MAX
)
mServiceWorkerID
(
0
)
mFromWindow
(
false
)
mEvalAllowed
(
false
)
mReportCSPViolations
(
false
)
mXHRParamsAllowed
(
false
)
mPrincipalIsSystem
(
false
)
mIsInPrivilegedApp
(
false
)
mIsInCertifiedApp
(
false
)
mStorageAllowed
(
false
)
mPrivateBrowsing
(
true
)
mServiceWorkersTestingInWindow
(
false
)
{
MOZ_COUNT_CTOR
(
WorkerLoadInfo
)
;
}
WorkerLoadInfo
:
:
~
WorkerLoadInfo
(
)
{
MOZ_COUNT_DTOR
(
WorkerLoadInfo
)
;
}
void
WorkerLoadInfo
:
:
StealFrom
(
WorkerLoadInfo
&
aOther
)
{
MOZ_ASSERT
(
!
mBaseURI
)
;
aOther
.
mBaseURI
.
swap
(
mBaseURI
)
;
MOZ_ASSERT
(
!
mResolvedScriptURI
)
;
aOther
.
mResolvedScriptURI
.
swap
(
mResolvedScriptURI
)
;
MOZ_ASSERT
(
!
mPrincipal
)
;
aOther
.
mPrincipal
.
swap
(
mPrincipal
)
;
MOZ_ASSERT
(
!
mScriptContext
)
;
aOther
.
mScriptContext
.
swap
(
mScriptContext
)
;
MOZ_ASSERT
(
!
mWindow
)
;
aOther
.
mWindow
.
swap
(
mWindow
)
;
MOZ_ASSERT
(
!
mCSP
)
;
aOther
.
mCSP
.
swap
(
mCSP
)
;
MOZ_ASSERT
(
!
mChannel
)
;
aOther
.
mChannel
.
swap
(
mChannel
)
;
MOZ_ASSERT
(
!
mLoadGroup
)
;
aOther
.
mLoadGroup
.
swap
(
mLoadGroup
)
;
MOZ_ASSERT
(
!
mLoadFailedAsyncRunnable
)
;
aOther
.
mLoadFailedAsyncRunnable
.
swap
(
mLoadFailedAsyncRunnable
)
;
MOZ_ASSERT
(
!
mInterfaceRequestor
)
;
aOther
.
mInterfaceRequestor
.
swap
(
mInterfaceRequestor
)
;
MOZ_ASSERT
(
!
mPrincipalInfo
)
;
mPrincipalInfo
=
aOther
.
mPrincipalInfo
.
forget
(
)
;
mDomain
=
aOther
.
mDomain
;
mServiceWorkerCacheName
=
aOther
.
mServiceWorkerCacheName
;
mWindowID
=
aOther
.
mWindowID
;
mServiceWorkerID
=
aOther
.
mServiceWorkerID
;
mFromWindow
=
aOther
.
mFromWindow
;
mEvalAllowed
=
aOther
.
mEvalAllowed
;
mReportCSPViolations
=
aOther
.
mReportCSPViolations
;
mXHRParamsAllowed
=
aOther
.
mXHRParamsAllowed
;
mPrincipalIsSystem
=
aOther
.
mPrincipalIsSystem
;
mIsInPrivilegedApp
=
aOther
.
mIsInPrivilegedApp
;
mIsInCertifiedApp
=
aOther
.
mIsInCertifiedApp
;
mStorageAllowed
=
aOther
.
mStorageAllowed
;
mPrivateBrowsing
=
aOther
.
mPrivateBrowsing
;
mServiceWorkersTestingInWindow
=
aOther
.
mServiceWorkersTestingInWindow
;
}
template
<
class
Derived
>
class
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
final
:
public
nsIEventTarget
{
mozilla
:
:
Mutex
mMutex
;
WorkerPrivate
*
mWorkerPrivate
;
nsIEventTarget
*
mWeakNestedEventTarget
;
nsCOMPtr
<
nsIEventTarget
>
mNestedEventTarget
;
public
:
explicit
EventTarget
(
WorkerPrivate
*
aWorkerPrivate
)
:
mMutex
(
"
WorkerPrivateParent
:
:
EventTarget
:
:
mMutex
"
)
mWorkerPrivate
(
aWorkerPrivate
)
mWeakNestedEventTarget
(
nullptr
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
}
EventTarget
(
WorkerPrivate
*
aWorkerPrivate
nsIEventTarget
*
aNestedEventTarget
)
:
mMutex
(
"
WorkerPrivateParent
:
:
EventTarget
:
:
mMutex
"
)
mWorkerPrivate
(
aWorkerPrivate
)
mWeakNestedEventTarget
(
aNestedEventTarget
)
mNestedEventTarget
(
aNestedEventTarget
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aNestedEventTarget
)
;
}
void
Disable
(
)
{
nsCOMPtr
<
nsIEventTarget
>
nestedEventTarget
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mWorkerPrivate
)
;
mWorkerPrivate
=
nullptr
;
mNestedEventTarget
.
swap
(
nestedEventTarget
)
;
}
}
nsIEventTarget
*
GetWeakNestedEventTarget
(
)
const
{
MOZ_ASSERT
(
mWeakNestedEventTarget
)
;
return
mWeakNestedEventTarget
;
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET
private
:
~
EventTarget
(
)
{
}
}
;
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
InterfaceRequestor
(
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsCOMPtr
<
nsILoadContext
>
baseContext
;
if
(
aLoadGroup
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
callbacks
-
>
GetInterface
(
NS_GET_IID
(
nsILoadContext
)
getter_AddRefs
(
baseContext
)
)
;
}
mOuterRequestor
=
callbacks
;
}
mLoadContext
=
new
LoadContext
(
aPrincipal
baseContext
)
;
}
void
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
MaybeAddTabChild
(
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aLoadGroup
)
{
return
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
!
callbacks
)
{
return
;
}
nsCOMPtr
<
nsITabChild
>
tabChild
;
callbacks
-
>
GetInterface
(
NS_GET_IID
(
nsITabChild
)
getter_AddRefs
(
tabChild
)
)
;
if
(
!
tabChild
)
{
return
;
}
mTabChildList
.
AppendElement
(
do_GetWeakReference
(
tabChild
)
)
;
}
NS_IMETHODIMP
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mLoadContext
)
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
)
{
nsCOMPtr
<
nsILoadContext
>
ref
=
mLoadContext
;
ref
.
forget
(
aSink
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsITabChild
)
)
)
{
nsCOMPtr
<
nsITabChild
>
tabChild
=
GetAnyLiveTabChild
(
)
;
if
(
!
tabChild
)
{
return
NS_NOINTERFACE
;
}
tabChild
.
forget
(
aSink
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsINetworkInterceptController
)
)
&
&
mOuterRequestor
)
{
return
mOuterRequestor
-
>
GetInterface
(
aIID
aSink
)
;
}
return
NS_NOINTERFACE
;
}
already_AddRefed
<
nsITabChild
>
WorkerLoadInfo
:
:
InterfaceRequestor
:
:
GetAnyLiveTabChild
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
while
(
!
mTabChildList
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsITabChild
>
tabChild
=
do_QueryReferent
(
mTabChildList
.
LastElement
(
)
)
;
if
(
tabChild
&
&
!
static_cast
<
TabChild
*
>
(
tabChild
.
get
(
)
)
-
>
IsDestroyed
(
)
)
{
return
tabChild
.
forget
(
)
;
}
mTabChildList
.
RemoveElementAt
(
mTabChildList
.
Length
(
)
-
1
)
;
}
return
nullptr
;
}
NS_IMPL_ADDREF
(
WorkerLoadInfo
:
:
InterfaceRequestor
)
NS_IMPL_RELEASE
(
WorkerLoadInfo
:
:
InterfaceRequestor
)
NS_IMPL_QUERY_INTERFACE
(
WorkerLoadInfo
:
:
InterfaceRequestor
nsIInterfaceRequestor
)
struct
WorkerPrivate
:
:
TimeoutInfo
{
TimeoutInfo
(
)
:
mTimeoutCallable
(
JS
:
:
UndefinedValue
(
)
)
mLineNumber
(
0
)
mId
(
0
)
mIsInterval
(
false
)
mCanceled
(
false
)
{
MOZ_COUNT_CTOR
(
mozilla
:
:
dom
:
:
workers
:
:
WorkerPrivate
:
:
TimeoutInfo
)
;
}
~
TimeoutInfo
(
)
{
MOZ_COUNT_DTOR
(
mozilla
:
:
dom
:
:
workers
:
:
WorkerPrivate
:
:
TimeoutInfo
)
;
}
bool
operator
=
=
(
const
TimeoutInfo
&
aOther
)
{
return
mTargetTime
=
=
aOther
.
mTargetTime
;
}
bool
operator
<
(
const
TimeoutInfo
&
aOther
)
{
return
mTargetTime
<
aOther
.
mTargetTime
;
}
JS
:
:
Heap
<
JS
:
:
Value
>
mTimeoutCallable
;
nsString
mTimeoutString
;
nsTArray
<
JS
:
:
Heap
<
JS
:
:
Value
>
>
mExtraArgVals
;
mozilla
:
:
TimeStamp
mTargetTime
;
mozilla
:
:
TimeDuration
mInterval
;
nsCString
mFilename
;
uint32_t
mLineNumber
;
int32_t
mId
;
bool
mIsInterval
;
bool
mCanceled
;
}
;
class
WorkerPrivate
:
:
MemoryReporter
final
:
public
nsIMemoryReporter
{
NS_DECL_THREADSAFE_ISUPPORTS
friend
class
WorkerPrivate
;
SharedMutex
mMutex
;
WorkerPrivate
*
mWorkerPrivate
;
bool
mAlreadyMappedToAddon
;
public
:
explicit
MemoryReporter
(
WorkerPrivate
*
aWorkerPrivate
)
:
mMutex
(
aWorkerPrivate
-
>
mMutex
)
mWorkerPrivate
(
aWorkerPrivate
)
mAlreadyMappedToAddon
(
false
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
NS_IMETHOD
CollectReports
(
nsIMemoryReporterCallback
*
aCallback
nsISupports
*
aClosure
bool
aAnonymize
)
override
{
AssertIsOnMainThread
(
)
;
nsCString
path
;
WorkerJSRuntimeStats
rtStats
(
path
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_OK
;
}
path
.
AppendLiteral
(
"
explicit
/
workers
/
workers
(
"
)
;
if
(
aAnonymize
&
&
!
mWorkerPrivate
-
>
Domain
(
)
.
IsEmpty
(
)
)
{
path
.
AppendLiteral
(
"
<
anonymized
-
domain
>
)
/
worker
(
<
anonymized
-
url
>
"
)
;
}
else
{
nsCString
escapedDomain
(
mWorkerPrivate
-
>
Domain
(
)
)
;
if
(
escapedDomain
.
IsEmpty
(
)
)
{
escapedDomain
+
=
"
chrome
"
;
}
else
{
escapedDomain
.
ReplaceChar
(
'
/
'
'
\
\
'
)
;
}
path
.
Append
(
escapedDomain
)
;
path
.
AppendLiteral
(
"
)
/
worker
(
"
)
;
NS_ConvertUTF16toUTF8
escapedURL
(
mWorkerPrivate
-
>
ScriptURL
(
)
)
;
escapedURL
.
ReplaceChar
(
'
/
'
'
\
\
'
)
;
path
.
Append
(
escapedURL
)
;
}
path
.
AppendPrintf
(
"
0x
%
p
)
/
"
static_cast
<
void
*
>
(
mWorkerPrivate
)
)
;
TryToMapAddon
(
path
)
;
if
(
!
mWorkerPrivate
-
>
BlockAndCollectRuntimeStats
(
&
rtStats
aAnonymize
)
)
{
return
NS_OK
;
}
}
return
xpc
:
:
ReportJSRuntimeExplicitTreeStats
(
rtStats
path
aCallback
aClosure
aAnonymize
)
;
}
private
:
~
MemoryReporter
(
)
{
}
void
Disable
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
NS_ASSERTION
(
mWorkerPrivate
"
Disabled
more
than
once
!
"
)
;
mWorkerPrivate
=
nullptr
;
}
void
TryToMapAddon
(
nsACString
&
path
)
{
AssertIsOnMainThread
(
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
mAlreadyMappedToAddon
|
|
!
mWorkerPrivate
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
scriptURI
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
scriptURI
)
mWorkerPrivate
-
>
ScriptURL
(
)
)
)
)
{
return
;
}
mAlreadyMappedToAddon
=
true
;
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
nsAutoCString
addonId
;
bool
ok
;
nsCOMPtr
<
amIAddonManager
>
addonManager
=
do_GetService
(
"
mozilla
.
org
/
addons
/
integration
;
1
"
)
;
if
(
!
addonManager
|
|
NS_FAILED
(
addonManager
-
>
MapURIToAddonID
(
scriptURI
addonId
&
ok
)
)
|
|
!
ok
)
{
return
;
}
static
const
size_t
explicitLength
=
strlen
(
"
explicit
/
"
)
;
addonId
.
Insert
(
NS_LITERAL_CSTRING
(
"
add
-
ons
/
"
)
0
)
;
addonId
+
=
"
/
"
;
path
.
Insert
(
addonId
explicitLength
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
WorkerPrivate
:
:
MemoryReporter
nsIMemoryReporter
)
WorkerPrivate
:
:
SyncLoopInfo
:
:
SyncLoopInfo
(
EventTarget
*
aEventTarget
)
:
mEventTarget
(
aEventTarget
)
mCompleted
(
false
)
mResult
(
false
)
#
ifdef
DEBUG
mHasRun
(
false
)
#
endif
{
}
template
<
class
Derived
>
nsIDocument
*
WorkerPrivateParent
<
Derived
>
:
:
GetDocument
(
)
const
{
AssertIsOnMainThread
(
)
;
if
(
mLoadInfo
.
mWindow
)
{
return
mLoadInfo
.
mWindow
-
>
GetExtantDoc
(
)
;
}
WorkerPrivate
*
parent
=
mParent
;
while
(
parent
)
{
if
(
parent
-
>
mLoadInfo
.
mWindow
)
{
return
parent
-
>
mLoadInfo
.
mWindow
-
>
GetExtantDoc
(
)
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
return
nullptr
;
}
template
<
class
Derived
>
typename
WorkerPrivateParent
<
Derived
>
:
:
cycleCollection
WorkerPrivateParent
<
Derived
>
:
:
_cycleCollectorGlobal
=
WorkerPrivateParent
<
Derived
>
:
:
cycleCollection
(
)
;
template
<
class
Derived
>
WorkerPrivateParent
<
Derived
>
:
:
WorkerPrivateParent
(
JSContext
*
aCx
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsACString
&
aWorkerName
WorkerLoadInfo
&
aLoadInfo
)
:
mMutex
(
"
WorkerPrivateParent
Mutex
"
)
mCondVar
(
mMutex
"
WorkerPrivateParent
CondVar
"
)
mMemoryReportCondVar
(
mMutex
"
WorkerPrivateParent
Memory
Report
CondVar
"
)
mParent
(
aParent
)
mScriptURL
(
aScriptURL
)
mWorkerName
(
aWorkerName
)
mLoadingWorkerScript
(
false
)
mBusyCount
(
0
)
mParentStatus
(
Pending
)
mParentFrozen
(
false
)
mParentSuspended
(
false
)
mIsChromeWorker
(
aIsChromeWorker
)
mMainThreadObjectsForgotten
(
false
)
mWorkerType
(
aWorkerType
)
mCreationTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mCreationTimeHighRes
(
(
double
)
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
{
MOZ_ASSERT_IF
(
!
IsDedicatedWorker
(
)
!
aWorkerName
.
IsVoid
(
)
&
&
NS_IsMainThread
(
)
)
;
MOZ_ASSERT_IF
(
IsDedicatedWorker
(
)
aWorkerName
.
IsEmpty
(
)
)
;
if
(
aLoadInfo
.
mWindow
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aLoadInfo
.
mWindow
-
>
IsInnerWindow
(
)
"
Should
have
inner
window
here
!
"
)
;
BindToOwner
(
aLoadInfo
.
mWindow
)
;
}
mLoadInfo
.
StealFrom
(
aLoadInfo
)
;
if
(
aParent
)
{
aParent
-
>
AssertIsOnWorkerThread
(
)
;
aParent
-
>
CopyJSSettings
(
mJSSettings
)
;
MOZ_ASSERT
(
IsDedicatedWorker
(
)
)
;
mNowBaseTimeStamp
=
aParent
-
>
NowBaseTimeStamp
(
)
;
mNowBaseTimeHighRes
=
aParent
-
>
NowBaseTime
(
)
;
}
else
{
AssertIsOnMainThread
(
)
;
RuntimeService
:
:
GetDefaultJSSettings
(
mJSSettings
)
;
if
(
IsDedicatedWorker
(
)
&
&
mLoadInfo
.
mWindow
&
&
mLoadInfo
.
mWindow
-
>
GetPerformance
(
)
)
{
mNowBaseTimeStamp
=
mLoadInfo
.
mWindow
-
>
GetPerformance
(
)
-
>
GetDOMTiming
(
)
-
>
GetNavigationStartTimeStamp
(
)
;
mNowBaseTimeHighRes
=
mLoadInfo
.
mWindow
-
>
GetPerformance
(
)
-
>
GetDOMTiming
(
)
-
>
GetNavigationStartHighRes
(
)
;
}
else
{
mNowBaseTimeStamp
=
CreationTimeStamp
(
)
;
mNowBaseTimeHighRes
=
CreationTime
(
)
;
}
}
}
template
<
class
Derived
>
WorkerPrivateParent
<
Derived
>
:
:
~
WorkerPrivateParent
(
)
{
DropJSObjects
(
this
)
;
}
template
<
class
Derived
>
JSObject
*
WorkerPrivateParent
<
Derived
>
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
MOZ_ASSERT
(
!
IsSharedWorker
(
)
"
We
should
never
wrap
a
WorkerPrivate
for
a
SharedWorker
"
)
;
AssertIsOnParentThread
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
wrapper
(
aCx
WorkerBinding
:
:
Wrap
(
aCx
ParentAsWorkerPrivate
(
)
aGivenProto
)
)
;
if
(
wrapper
)
{
MOZ_ALWAYS_TRUE
(
TryPreserveWrapper
(
wrapper
)
)
;
}
return
wrapper
;
}
template
<
class
Derived
>
nsresult
WorkerPrivateParent
<
Derived
>
:
:
DispatchPrivate
(
already_AddRefed
<
WorkerRunnable
>
&
&
aRunnable
nsIEventTarget
*
aSyncLoopTarget
)
{
RefPtr
<
WorkerRunnable
>
runnable
(
aRunnable
)
;
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT_IF
(
aSyncLoopTarget
self
-
>
mThread
)
;
if
(
!
self
-
>
mThread
)
{
if
(
ParentStatus
(
)
=
=
Pending
|
|
self
-
>
mStatus
=
=
Pending
)
{
mPreStartRunnables
.
AppendElement
(
runnable
)
;
return
NS_OK
;
}
NS_WARNING
(
"
Using
a
worker
event
target
after
the
thread
has
already
"
"
been
released
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
self
-
>
mStatus
=
=
Dead
|
|
(
!
aSyncLoopTarget
&
&
ParentStatus
(
)
>
Running
)
)
{
NS_WARNING
(
"
A
runnable
was
posted
to
a
worker
that
is
already
shutting
"
"
down
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
;
if
(
aSyncLoopTarget
)
{
rv
=
aSyncLoopTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
else
{
rv
=
self
-
>
mThread
-
>
DispatchAnyThread
(
WorkerThreadFriendKey
(
)
runnable
.
forget
(
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mCondVar
.
Notify
(
)
;
}
return
NS_OK
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
EnableDebugger
(
)
{
AssertIsOnParentThread
(
)
;
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
if
(
NS_FAILED
(
RegisterWorkerDebugger
(
self
)
)
)
{
NS_WARNING
(
"
Failed
to
register
worker
debugger
!
"
)
;
return
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
DisableDebugger
(
)
{
AssertIsOnParentThread
(
)
;
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
if
(
NS_FAILED
(
UnregisterWorkerDebugger
(
self
)
)
)
{
NS_WARNING
(
"
Failed
to
unregister
worker
debugger
!
"
)
;
}
}
template
<
class
Derived
>
nsresult
WorkerPrivateParent
<
Derived
>
:
:
DispatchControlRunnable
(
already_AddRefed
<
WorkerControlRunnable
>
&
&
aWorkerControlRunnable
)
{
RefPtr
<
WorkerControlRunnable
>
runnable
(
aWorkerControlRunnable
)
;
MOZ_ASSERT
(
runnable
)
;
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
self
-
>
mStatus
=
=
Dead
)
{
NS_WARNING
(
"
A
control
runnable
was
posted
to
a
worker
that
is
already
"
"
shutting
down
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
self
-
>
mControlQueue
.
Push
(
runnable
.
forget
(
)
.
take
(
)
)
;
if
(
JSContext
*
cx
=
self
-
>
mJSContext
)
{
MOZ_ASSERT
(
self
-
>
mThread
)
;
JSRuntime
*
rt
=
JS_GetRuntime
(
cx
)
;
MOZ_ASSERT
(
rt
)
;
JS_RequestInterruptCallback
(
rt
)
;
}
mCondVar
.
Notify
(
)
;
}
return
NS_OK
;
}
template
<
class
Derived
>
nsresult
WorkerPrivateParent
<
Derived
>
:
:
DispatchDebuggerRunnable
(
already_AddRefed
<
WorkerRunnable
>
&
&
aDebuggerRunnable
)
{
RefPtr
<
WorkerRunnable
>
runnable
(
aDebuggerRunnable
)
;
MOZ_ASSERT
(
runnable
)
;
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
self
-
>
mStatus
=
=
Dead
)
{
NS_WARNING
(
"
A
debugger
runnable
was
posted
to
a
worker
that
is
already
"
"
shutting
down
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
self
-
>
mDebuggerQueue
.
Push
(
runnable
.
forget
(
)
.
take
(
)
)
;
mCondVar
.
Notify
(
)
;
}
return
NS_OK
;
}
template
<
class
Derived
>
already_AddRefed
<
WorkerRunnable
>
WorkerPrivateParent
<
Derived
>
:
:
MaybeWrapAsWorkerRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
MOZ_ASSERT
(
runnable
)
;
RefPtr
<
WorkerRunnable
>
workerRunnable
=
WorkerRunnable
:
:
FromRunnable
(
runnable
)
;
if
(
workerRunnable
)
{
return
workerRunnable
.
forget
(
)
;
}
nsCOMPtr
<
nsICancelableRunnable
>
cancelable
=
do_QueryInterface
(
runnable
)
;
if
(
!
cancelable
)
{
MOZ_CRASH
(
"
All
runnables
destined
for
a
worker
thread
must
be
cancelable
!
"
)
;
}
workerRunnable
=
new
ExternalRunnableWrapper
(
ParentAsWorkerPrivate
(
)
cancelable
)
;
return
workerRunnable
.
forget
(
)
;
}
template
<
class
Derived
>
already_AddRefed
<
nsIEventTarget
>
WorkerPrivateParent
<
Derived
>
:
:
GetEventTarget
(
)
{
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
nsCOMPtr
<
nsIEventTarget
>
target
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mEventTarget
&
&
ParentStatus
(
)
<
=
Running
&
&
self
-
>
mStatus
<
=
Running
)
{
mEventTarget
=
new
EventTarget
(
self
)
;
}
target
=
mEventTarget
;
}
NS_WARN_IF_FALSE
(
target
"
Requested
event
target
for
a
worker
that
is
already
"
"
shutting
down
!
"
)
;
return
target
.
forget
(
)
;
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
Start
(
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
NS_ASSERTION
(
mParentStatus
!
=
Running
"
How
can
this
be
?
!
"
)
;
if
(
mParentStatus
=
=
Pending
)
{
mParentStatus
=
Running
;
return
true
;
}
}
return
false
;
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
NotifyPrivate
(
JSContext
*
aCx
Status
aStatus
)
{
AssertIsOnParentThread
(
)
;
bool
pending
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mParentStatus
>
=
aStatus
)
{
return
true
;
}
pending
=
mParentStatus
=
=
Pending
;
mParentStatus
=
aStatus
;
}
if
(
IsSharedWorker
(
)
)
{
RuntimeService
*
runtime
=
RuntimeService
:
:
GetService
(
)
;
MOZ_ASSERT
(
runtime
)
;
runtime
-
>
ForgetSharedWorker
(
ParentAsWorkerPrivate
(
)
)
;
}
if
(
pending
)
{
WorkerPrivate
*
self
=
ParentAsWorkerPrivate
(
)
;
#
ifdef
DEBUG
{
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
currentThread
)
;
MOZ_ASSERT
(
!
self
-
>
mPRThread
)
;
self
-
>
mPRThread
=
PRThreadFromThread
(
currentThread
)
;
MOZ_ASSERT
(
self
-
>
mPRThread
)
;
}
#
endif
self
-
>
ScheduleDeletion
(
WorkerPrivate
:
:
WorkerNeverRan
)
;
return
true
;
}
NS_ASSERTION
(
aStatus
!
=
Terminating
|
|
mQueuedRunnables
.
IsEmpty
(
)
"
Shouldn
'
t
have
anything
queued
!
"
)
;
mQueuedRunnables
.
Clear
(
)
;
RefPtr
<
NotifyRunnable
>
runnable
=
new
NotifyRunnable
(
ParentAsWorkerPrivate
(
)
aStatus
)
;
return
runnable
-
>
Dispatch
(
aCx
)
;
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
Freeze
(
JSContext
*
aCx
nsPIDOMWindowInner
*
aWindow
)
{
AssertIsOnParentThread
(
)
;
MOZ_ASSERT
(
aCx
)
;
if
(
(
IsSharedWorker
(
)
|
|
IsServiceWorker
(
)
)
&
&
!
mSharedWorkers
.
IsEmpty
(
)
)
{
AssertIsOnMainThread
(
)
;
bool
allFrozen
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mSharedWorkers
.
Length
(
)
;
+
+
i
)
{
if
(
aWindow
&
&
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
=
=
aWindow
)
{
RefPtr
<
SharedWorker
>
kungFuDeathGrip
=
mSharedWorkers
[
i
]
;
mSharedWorkers
[
i
]
-
>
Freeze
(
)
;
}
else
{
MOZ_ASSERT_IF
(
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
&
&
aWindow
!
SameCOMIdentity
(
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
aWindow
)
)
;
if
(
!
mSharedWorkers
[
i
]
-
>
IsFrozen
(
)
)
{
allFrozen
=
false
;
}
}
}
if
(
!
allFrozen
|
|
mParentFrozen
)
{
return
true
;
}
}
mParentFrozen
=
true
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mParentStatus
>
=
Terminating
)
{
return
true
;
}
}
DisableDebugger
(
)
;
RefPtr
<
FreezeRunnable
>
runnable
=
new
FreezeRunnable
(
ParentAsWorkerPrivate
(
)
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
return
false
;
}
return
true
;
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
Thaw
(
JSContext
*
aCx
nsPIDOMWindowInner
*
aWindow
)
{
AssertIsOnParentThread
(
)
;
MOZ_ASSERT
(
aCx
)
;
if
(
IsDedicatedWorker
(
)
&
&
!
mParentFrozen
)
{
return
true
;
}
if
(
(
IsSharedWorker
(
)
|
|
IsServiceWorker
(
)
)
&
&
!
mSharedWorkers
.
IsEmpty
(
)
)
{
AssertIsOnMainThread
(
)
;
bool
anyRunning
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mSharedWorkers
.
Length
(
)
;
+
+
i
)
{
if
(
aWindow
&
&
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
=
=
aWindow
)
{
RefPtr
<
SharedWorker
>
kungFuDeathGrip
=
mSharedWorkers
[
i
]
;
mSharedWorkers
[
i
]
-
>
Thaw
(
)
;
anyRunning
=
true
;
}
else
{
MOZ_ASSERT_IF
(
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
&
&
aWindow
!
SameCOMIdentity
(
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
aWindow
)
)
;
if
(
!
mSharedWorkers
[
i
]
-
>
IsFrozen
(
)
)
{
anyRunning
=
true
;
}
}
}
if
(
!
anyRunning
|
|
!
mParentFrozen
)
{
return
true
;
}
}
MOZ_ASSERT
(
mParentFrozen
)
;
mParentFrozen
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mParentStatus
>
=
Terminating
)
{
return
true
;
}
}
EnableDebugger
(
)
;
if
(
!
IsSuspended
(
)
&
&
!
mQueuedRunnables
.
IsEmpty
(
)
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
IsDedicatedWorker
(
)
)
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
runnables
;
mQueuedRunnables
.
SwapElements
(
runnables
)
;
for
(
uint32_t
index
=
0
;
index
<
runnables
.
Length
(
)
;
index
+
+
)
{
runnables
[
index
]
-
>
Run
(
)
;
}
}
RefPtr
<
ThawRunnable
>
runnable
=
new
ThawRunnable
(
ParentAsWorkerPrivate
(
)
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
return
false
;
}
return
true
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
Suspend
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mParentSuspended
"
Suspended
more
than
once
!
"
)
;
mParentSuspended
=
true
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
Resume
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mParentSuspended
"
Resumed
more
than
once
!
"
)
;
mParentSuspended
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mParentStatus
>
=
Terminating
)
{
return
;
}
}
if
(
!
IsFrozen
(
)
&
&
!
mQueuedRunnables
.
IsEmpty
(
)
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
IsDedicatedWorker
(
)
)
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
runnables
;
mQueuedRunnables
.
SwapElements
(
runnables
)
;
for
(
uint32_t
index
=
0
;
index
<
runnables
.
Length
(
)
;
index
+
+
)
{
runnables
[
index
]
-
>
Run
(
)
;
}
}
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
Close
(
)
{
AssertIsOnParentThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mParentStatus
<
Closing
)
{
mParentStatus
=
Closing
;
}
}
return
true
;
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
ModifyBusyCount
(
JSContext
*
aCx
bool
aIncrease
)
{
AssertIsOnParentThread
(
)
;
NS_ASSERTION
(
aIncrease
|
|
mBusyCount
"
Mismatched
busy
count
mods
!
"
)
;
if
(
aIncrease
)
{
mBusyCount
+
+
;
return
true
;
}
if
(
-
-
mBusyCount
=
=
0
)
{
bool
shouldCancel
;
{
MutexAutoLock
lock
(
mMutex
)
;
shouldCancel
=
mParentStatus
=
=
Terminating
;
}
if
(
shouldCancel
&
&
!
Cancel
(
aCx
)
)
{
return
false
;
}
}
return
true
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
ForgetOverridenLoadGroup
(
nsCOMPtr
<
nsILoadGroup
>
&
aLoadGroupOut
)
{
AssertIsOnParentThread
(
)
;
if
(
!
mLoadInfo
.
mInterfaceRequestor
)
{
return
;
}
mLoadInfo
.
mLoadGroup
.
swap
(
aLoadGroupOut
)
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
ForgetMainThreadObjects
(
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
aDoomed
)
{
AssertIsOnParentThread
(
)
;
MOZ_ASSERT
(
!
mMainThreadObjectsForgotten
)
;
static
const
uint32_t
kDoomedCount
=
10
;
aDoomed
.
SetCapacity
(
kDoomedCount
)
;
SwapToISupportsArray
(
mLoadInfo
.
mWindow
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mScriptContext
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mBaseURI
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mResolvedScriptURI
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mPrincipal
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mChannel
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mCSP
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mLoadGroup
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mLoadFailedAsyncRunnable
aDoomed
)
;
SwapToISupportsArray
(
mLoadInfo
.
mInterfaceRequestor
aDoomed
)
;
MOZ_ASSERT
(
aDoomed
.
Length
(
)
=
=
kDoomedCount
)
;
mMainThreadObjectsForgotten
=
true
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
PostMessageInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
ErrorResult
&
aRv
)
{
AssertIsOnParentThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mParentStatus
>
Running
)
{
return
;
}
}
JS
:
:
Rooted
<
JS
:
:
Value
>
transferable
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
if
(
aTransferable
.
WasPassed
(
)
)
{
const
Sequence
<
JS
:
:
Value
>
&
realTransferable
=
aTransferable
.
Value
(
)
;
JS
:
:
HandleValueArray
elements
=
JS
:
:
HandleValueArray
:
:
fromMarkedLocation
(
realTransferable
.
Length
(
)
realTransferable
.
Elements
(
)
)
;
JSObject
*
array
=
JS_NewArrayObject
(
aCx
elements
)
;
if
(
!
array
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
transferable
.
setObject
(
*
array
)
;
}
RefPtr
<
MessageEventRunnable
>
runnable
=
new
MessageEventRunnable
(
ParentAsWorkerPrivate
(
)
WorkerRunnable
:
:
WorkerThreadModifyBusyCount
)
;
UniquePtr
<
AbstractTimelineMarker
>
start
;
UniquePtr
<
AbstractTimelineMarker
>
end
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
!
timelines
-
>
IsEmpty
(
)
;
if
(
isTimelineRecording
)
{
start
=
MakeUnique
<
WorkerTimelineMarker
>
(
NS_IsMainThread
(
)
?
ProfileTimelineWorkerOperationType
:
:
SerializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
SerializeDataOffMainThread
MarkerTracingType
:
:
START
)
;
}
runnable
-
>
Write
(
aCx
aMessage
transferable
aRv
)
;
if
(
isTimelineRecording
)
{
end
=
MakeUnique
<
WorkerTimelineMarker
>
(
NS_IsMainThread
(
)
?
ProfileTimelineWorkerOperationType
:
:
SerializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
SerializeDataOffMainThread
MarkerTracingType
:
:
END
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
start
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
end
)
;
}
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
runnable
-
>
SetMessageSource
(
Move
(
aClientInfo
)
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
PostMessage
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
ErrorResult
&
aRv
)
{
PostMessageInternal
(
aCx
aMessage
aTransferable
nullptr
aRv
)
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
PostMessageToServiceWorker
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
ErrorResult
&
aRv
)
{
AssertIsOnMainThread
(
)
;
PostMessageInternal
(
aCx
aMessage
aTransferable
Move
(
aClientInfo
)
aRv
)
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
UpdateRuntimeOptions
(
JSContext
*
aCx
const
JS
:
:
RuntimeOptions
&
aRuntimeOptions
)
{
AssertIsOnParentThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mJSSettings
.
runtimeOptions
=
aRuntimeOptions
;
}
RefPtr
<
UpdateRuntimeOptionsRunnable
>
runnable
=
new
UpdateRuntimeOptionsRunnable
(
ParentAsWorkerPrivate
(
)
aRuntimeOptions
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
update
worker
context
options
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
UpdatePreference
(
JSContext
*
aCx
WorkerPreference
aPref
bool
aValue
)
{
AssertIsOnParentThread
(
)
;
MOZ_ASSERT
(
aPref
>
=
0
&
&
aPref
<
WORKERPREF_COUNT
)
;
RefPtr
<
UpdatePreferenceRunnable
>
runnable
=
new
UpdatePreferenceRunnable
(
ParentAsWorkerPrivate
(
)
aPref
aValue
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
update
worker
preferences
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
UpdateLanguages
(
JSContext
*
aCx
const
nsTArray
<
nsString
>
&
aLanguages
)
{
AssertIsOnParentThread
(
)
;
RefPtr
<
UpdateLanguagesRunnable
>
runnable
=
new
UpdateLanguagesRunnable
(
ParentAsWorkerPrivate
(
)
aLanguages
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
update
worker
languages
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
UpdateJSWorkerMemoryParameter
(
JSContext
*
aCx
JSGCParamKey
aKey
uint32_t
aValue
)
{
AssertIsOnParentThread
(
)
;
bool
found
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
found
=
mJSSettings
.
ApplyGCSetting
(
aKey
aValue
)
;
}
if
(
found
)
{
RefPtr
<
UpdateJSWorkerMemoryParameterRunnable
>
runnable
=
new
UpdateJSWorkerMemoryParameterRunnable
(
ParentAsWorkerPrivate
(
)
aKey
aValue
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
update
memory
parameter
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
}
#
ifdef
JS_GC_ZEAL
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
UpdateGCZeal
(
JSContext
*
aCx
uint8_t
aGCZeal
uint32_t
aFrequency
)
{
AssertIsOnParentThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mJSSettings
.
gcZeal
=
aGCZeal
;
mJSSettings
.
gcZealFrequency
=
aFrequency
;
}
RefPtr
<
UpdateGCZealRunnable
>
runnable
=
new
UpdateGCZealRunnable
(
ParentAsWorkerPrivate
(
)
aGCZeal
aFrequency
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
update
worker
gczeal
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
#
endif
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
GarbageCollect
(
JSContext
*
aCx
bool
aShrinking
)
{
AssertIsOnParentThread
(
)
;
RefPtr
<
GarbageCollectRunnable
>
runnable
=
new
GarbageCollectRunnable
(
ParentAsWorkerPrivate
(
)
aShrinking
true
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
GC
worker
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
CycleCollect
(
JSContext
*
aCx
bool
aDummy
)
{
AssertIsOnParentThread
(
)
;
RefPtr
<
CycleCollectRunnable
>
runnable
=
new
CycleCollectRunnable
(
ParentAsWorkerPrivate
(
)
true
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
CC
worker
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
OfflineStatusChangeEvent
(
JSContext
*
aCx
bool
aIsOffline
)
{
AssertIsOnParentThread
(
)
;
RefPtr
<
OfflineStatusChangeRunnable
>
runnable
=
new
OfflineStatusChangeRunnable
(
ParentAsWorkerPrivate
(
)
aIsOffline
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
offline
status
change
event
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
}
}
void
WorkerPrivate
:
:
OfflineStatusChangeEventInternal
(
JSContext
*
aCx
bool
aIsOffline
)
{
AssertIsOnWorkerThread
(
)
;
if
(
mOnLine
=
=
!
aIsOffline
)
{
return
;
}
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
+
+
index
)
{
mChildWorkers
[
index
]
-
>
OfflineStatusChangeEvent
(
aCx
aIsOffline
)
;
}
mOnLine
=
!
aIsOffline
;
WorkerGlobalScope
*
globalScope
=
GlobalScope
(
)
;
RefPtr
<
WorkerNavigator
>
nav
=
globalScope
-
>
GetExistingNavigator
(
)
;
if
(
nav
)
{
nav
-
>
SetOnLine
(
mOnLine
)
;
}
nsString
eventType
;
if
(
aIsOffline
)
{
eventType
.
AssignLiteral
(
"
offline
"
)
;
}
else
{
eventType
.
AssignLiteral
(
"
online
"
)
;
}
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
globalScope
nullptr
nullptr
)
;
event
-
>
InitEvent
(
eventType
false
false
)
;
event
-
>
SetTrusted
(
true
)
;
globalScope
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
}
template
<
class
Derived
>
bool
WorkerPrivateParent
<
Derived
>
:
:
RegisterSharedWorker
(
JSContext
*
aCx
SharedWorker
*
aSharedWorker
MessagePort
*
aPort
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aSharedWorker
)
;
MOZ_ASSERT
(
IsSharedWorker
(
)
)
;
MOZ_ASSERT
(
!
mSharedWorkers
.
Contains
(
aSharedWorker
)
)
;
if
(
IsSharedWorker
(
)
)
{
RefPtr
<
MessagePortRunnable
>
runnable
=
new
MessagePortRunnable
(
ParentAsWorkerPrivate
(
)
aPort
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
return
false
;
}
}
mSharedWorkers
.
AppendElement
(
aSharedWorker
)
;
if
(
mSharedWorkers
.
Length
(
)
>
1
&
&
!
Thaw
(
aCx
nullptr
)
)
{
return
false
;
}
return
true
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
BroadcastErrorToSharedWorkers
(
JSContext
*
aCx
const
nsAString
&
aMessage
const
nsAString
&
aFilename
const
nsAString
&
aLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
)
{
AssertIsOnMainThread
(
)
;
AutoTArray
<
RefPtr
<
SharedWorker
>
10
>
sharedWorkers
;
GetAllSharedWorkers
(
sharedWorkers
)
;
if
(
sharedWorkers
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
WindowAction
10
>
windowActions
;
nsresult
rv
;
for
(
size_t
index
=
0
;
index
<
sharedWorkers
.
Length
(
)
;
index
+
+
)
{
RefPtr
<
SharedWorker
>
&
sharedWorker
=
sharedWorkers
[
index
]
;
nsPIDOMWindowInner
*
window
=
sharedWorker
-
>
GetOwner
(
)
;
RootedDictionary
<
ErrorEventInit
>
errorInit
(
aCx
)
;
errorInit
.
mBubbles
=
false
;
errorInit
.
mCancelable
=
true
;
errorInit
.
mMessage
=
aMessage
;
errorInit
.
mFilename
=
aFilename
;
errorInit
.
mLineno
=
aLineNumber
;
errorInit
.
mColno
=
aColumnNumber
;
RefPtr
<
ErrorEvent
>
errorEvent
=
ErrorEvent
:
:
Constructor
(
sharedWorker
NS_LITERAL_STRING
(
"
error
"
)
errorInit
)
;
if
(
!
errorEvent
)
{
ThrowAndReport
(
window
NS_ERROR_UNEXPECTED
)
;
continue
;
}
errorEvent
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
nsresult
rv
=
sharedWorker
-
>
DispatchEvent
(
errorEvent
&
defaultActionEnabled
)
;
if
(
NS_FAILED
(
rv
)
)
{
ThrowAndReport
(
window
rv
)
;
continue
;
}
if
(
defaultActionEnabled
)
{
if
(
!
windowActions
.
Contains
(
window
)
)
{
windowActions
.
AppendElement
(
WindowAction
(
window
)
)
;
}
}
else
{
size_t
actionsIndex
=
windowActions
.
LastIndexOf
(
WindowAction
(
window
)
)
;
if
(
actionsIndex
!
=
windowActions
.
NoIndex
)
{
windowActions
[
actionsIndex
]
.
mDefaultAction
=
false
;
}
}
}
if
(
windowActions
.
IsEmpty
(
)
)
{
return
;
}
bool
shouldLogErrorToConsole
=
true
;
for
(
uint32_t
index
=
0
;
index
<
windowActions
.
Length
(
)
;
index
+
+
)
{
WindowAction
&
windowAction
=
windowActions
[
index
]
;
if
(
!
windowAction
.
mWindow
|
|
!
windowAction
.
mDefaultAction
)
{
continue
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
sgo
=
do_QueryInterface
(
windowAction
.
mWindow
)
;
MOZ_ASSERT
(
sgo
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RootedDictionary
<
ErrorEventInit
>
init
(
aCx
)
;
init
.
mLineno
=
aLineNumber
;
init
.
mFilename
=
aFilename
;
init
.
mMessage
=
aMessage
;
init
.
mCancelable
=
true
;
init
.
mBubbles
=
true
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
rv
=
sgo
-
>
HandleScriptError
(
init
&
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
ThrowAndReport
(
windowAction
.
mWindow
rv
)
;
continue
;
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
shouldLogErrorToConsole
=
false
;
}
}
if
(
shouldLogErrorToConsole
)
{
LogErrorToConsole
(
aMessage
aFilename
aLine
aLineNumber
aColumnNumber
aFlags
0
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
GetAllSharedWorkers
(
nsTArray
<
RefPtr
<
SharedWorker
>
>
&
aSharedWorkers
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
IsSharedWorker
(
)
|
|
IsServiceWorker
(
)
)
;
if
(
!
aSharedWorkers
.
IsEmpty
(
)
)
{
aSharedWorkers
.
Clear
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mSharedWorkers
.
Length
(
)
;
+
+
i
)
{
aSharedWorkers
.
AppendElement
(
mSharedWorkers
[
i
]
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
CloseSharedWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
IsSharedWorker
(
)
|
|
IsServiceWorker
(
)
)
;
MOZ_ASSERT
(
aWindow
)
;
bool
someRemoved
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mSharedWorkers
.
Length
(
)
;
)
{
if
(
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
=
=
aWindow
)
{
mSharedWorkers
[
i
]
-
>
Close
(
)
;
mSharedWorkers
.
RemoveElementAt
(
i
)
;
someRemoved
=
true
;
}
else
{
MOZ_ASSERT
(
!
SameCOMIdentity
(
mSharedWorkers
[
i
]
-
>
GetOwner
(
)
aWindow
)
)
;
+
+
i
;
}
}
if
(
!
someRemoved
)
{
return
;
}
AutoSafeJSContext
cx
;
if
(
!
mSharedWorkers
.
IsEmpty
(
)
)
{
if
(
!
Freeze
(
cx
nullptr
)
)
{
JS_ReportPendingException
(
cx
)
;
}
}
else
if
(
!
Cancel
(
cx
)
)
{
JS_ReportPendingException
(
cx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
CloseAllSharedWorkers
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
IsSharedWorker
(
)
|
|
IsServiceWorker
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mSharedWorkers
.
Length
(
)
;
+
+
i
)
{
mSharedWorkers
[
i
]
-
>
Close
(
)
;
}
mSharedWorkers
.
Clear
(
)
;
AutoSafeJSContext
cx
;
if
(
!
Cancel
(
cx
)
)
{
JS_ReportPendingException
(
cx
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
WorkerScriptLoaded
(
)
{
AssertIsOnMainThread
(
)
;
if
(
IsSharedWorker
(
)
|
|
IsServiceWorker
(
)
)
{
mLoadInfo
.
mWindow
=
nullptr
;
mLoadInfo
.
mScriptContext
=
nullptr
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
SetBaseURI
(
nsIURI
*
aBaseURI
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mLoadInfo
.
mBaseURI
)
{
NS_ASSERTION
(
GetParent
(
)
"
Shouldn
'
t
happen
without
a
parent
!
"
)
;
mLoadInfo
.
mResolvedScriptURI
=
aBaseURI
;
}
mLoadInfo
.
mBaseURI
=
aBaseURI
;
if
(
NS_FAILED
(
aBaseURI
-
>
GetSpec
(
mLocationInfo
.
mHref
)
)
)
{
mLocationInfo
.
mHref
.
Truncate
(
)
;
}
mLocationInfo
.
mHostname
.
Truncate
(
)
;
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
aBaseURI
mLocationInfo
.
mHostname
)
;
nsCOMPtr
<
nsIURL
>
url
(
do_QueryInterface
(
aBaseURI
)
)
;
if
(
!
url
|
|
NS_FAILED
(
url
-
>
GetFilePath
(
mLocationInfo
.
mPathname
)
)
)
{
mLocationInfo
.
mPathname
.
Truncate
(
)
;
}
nsCString
temp
;
if
(
url
&
&
NS_SUCCEEDED
(
url
-
>
GetQuery
(
temp
)
)
&
&
!
temp
.
IsEmpty
(
)
)
{
mLocationInfo
.
mSearch
.
Assign
(
'
?
'
)
;
mLocationInfo
.
mSearch
.
Append
(
temp
)
;
}
if
(
NS_SUCCEEDED
(
aBaseURI
-
>
GetRef
(
temp
)
)
&
&
!
temp
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsITextToSubURI
>
converter
=
do_GetService
(
NS_ITEXTTOSUBURI_CONTRACTID
)
;
if
(
converter
&
&
nsContentUtils
:
:
GettersDecodeURLHash
(
)
)
{
nsCString
charset
;
nsAutoString
unicodeRef
;
if
(
NS_SUCCEEDED
(
aBaseURI
-
>
GetOriginCharset
(
charset
)
)
&
&
NS_SUCCEEDED
(
converter
-
>
UnEscapeURIForUI
(
charset
temp
unicodeRef
)
)
)
{
mLocationInfo
.
mHash
.
Assign
(
'
#
'
)
;
mLocationInfo
.
mHash
.
Append
(
NS_ConvertUTF16toUTF8
(
unicodeRef
)
)
;
}
}
if
(
mLocationInfo
.
mHash
.
IsEmpty
(
)
)
{
mLocationInfo
.
mHash
.
Assign
(
'
#
'
)
;
mLocationInfo
.
mHash
.
Append
(
temp
)
;
}
}
if
(
NS_SUCCEEDED
(
aBaseURI
-
>
GetScheme
(
mLocationInfo
.
mProtocol
)
)
)
{
mLocationInfo
.
mProtocol
.
Append
(
'
:
'
)
;
}
else
{
mLocationInfo
.
mProtocol
.
Truncate
(
)
;
}
int32_t
port
;
if
(
NS_SUCCEEDED
(
aBaseURI
-
>
GetPort
(
&
port
)
)
&
&
port
!
=
-
1
)
{
mLocationInfo
.
mPort
.
AppendInt
(
port
)
;
nsAutoCString
host
(
mLocationInfo
.
mHostname
)
;
host
.
Append
(
'
:
'
)
;
host
.
Append
(
mLocationInfo
.
mPort
)
;
mLocationInfo
.
mHost
.
Assign
(
host
)
;
}
else
{
mLocationInfo
.
mHost
.
Assign
(
mLocationInfo
.
mHostname
)
;
}
nsContentUtils
:
:
GetUTFOrigin
(
aBaseURI
mLocationInfo
.
mOrigin
)
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
SetPrincipal
(
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
NS_LoadGroupMatchesPrincipal
(
aLoadGroup
aPrincipal
)
)
;
MOZ_ASSERT
(
!
mLoadInfo
.
mPrincipalInfo
)
;
mLoadInfo
.
mPrincipal
=
aPrincipal
;
mLoadInfo
.
mPrincipalIsSystem
=
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
;
uint16_t
appStatus
=
aPrincipal
-
>
GetAppStatus
(
)
;
mLoadInfo
.
mIsInPrivilegedApp
=
(
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_CERTIFIED
|
|
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_PRIVILEGED
)
;
mLoadInfo
.
mIsInCertifiedApp
=
(
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_CERTIFIED
)
;
aPrincipal
-
>
GetCsp
(
getter_AddRefs
(
mLoadInfo
.
mCSP
)
)
;
if
(
mLoadInfo
.
mCSP
)
{
mLoadInfo
.
mCSP
-
>
GetAllowsEval
(
&
mLoadInfo
.
mReportCSPViolations
&
mLoadInfo
.
mEvalAllowed
)
;
}
else
{
mLoadInfo
.
mEvalAllowed
=
true
;
mLoadInfo
.
mReportCSPViolations
=
false
;
}
mLoadInfo
.
mLoadGroup
=
aLoadGroup
;
mLoadInfo
.
mPrincipalInfo
=
new
PrincipalInfo
(
)
;
mLoadInfo
.
mPrivateBrowsing
=
nsContentUtils
:
:
IsInPrivateBrowsing
(
aLoadGroup
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
PrincipalToPrincipalInfo
(
aPrincipal
mLoadInfo
.
mPrincipalInfo
)
)
)
;
}
template
<
class
Derived
>
JSContext
*
WorkerPrivateParent
<
Derived
>
:
:
ParentJSContext
(
)
const
{
AssertIsOnParentThread
(
)
;
if
(
mParent
)
{
return
mParent
-
>
GetJSContext
(
)
;
}
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mScriptContext
?
mLoadInfo
.
mScriptContext
-
>
GetNativeContext
(
)
:
nsContentUtils
:
:
GetSafeJSContext
(
)
;
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
UpdateOverridenLoadGroup
(
nsILoadGroup
*
aBaseLoadGroup
)
{
AssertIsOnMainThread
(
)
;
mLoadInfo
.
mInterfaceRequestor
-
>
MaybeAddTabChild
(
aBaseLoadGroup
)
;
}
template
<
class
Derived
>
NS_IMPL_ADDREF_INHERITED
(
WorkerPrivateParent
<
Derived
>
DOMEventTargetHelper
)
template
<
class
Derived
>
NS_IMPL_RELEASE_INHERITED
(
WorkerPrivateParent
<
Derived
>
DOMEventTargetHelper
)
template
<
class
Derived
>
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
WorkerPrivateParent
<
Derived
>
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
template
<
class
Derived
>
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
WorkerPrivateParent
<
Derived
>
DOMEventTargetHelper
)
tmp
-
>
AssertIsOnParentThread
(
)
;
if
(
!
tmp
-
>
mBusyCount
&
&
!
tmp
-
>
mMainThreadObjectsForgotten
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelfRef
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
template
<
class
Derived
>
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
WorkerPrivateParent
<
Derived
>
DOMEventTargetHelper
)
tmp
-
>
Terminate
(
nullptr
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
template
<
class
Derived
>
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
WorkerPrivateParent
<
Derived
>
DOMEventTargetHelper
)
tmp
-
>
AssertIsOnParentThread
(
)
;
NS_IMPL_CYCLE_COLLECTION_TRACE_END
#
ifdef
DEBUG
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
AssertIsOnParentThread
(
)
const
{
if
(
GetParent
(
)
)
{
GetParent
(
)
-
>
AssertIsOnWorkerThread
(
)
;
}
else
{
AssertIsOnMainThread
(
)
;
}
}
template
<
class
Derived
>
void
WorkerPrivateParent
<
Derived
>
:
:
AssertInnerWindowIsCorrect
(
)
const
{
AssertIsOnParentThread
(
)
;
if
(
mParent
|
|
!
mLoadInfo
.
mWindow
)
{
return
;
}
AssertIsOnMainThread
(
)
;
nsPIDOMWindowOuter
*
outer
=
mLoadInfo
.
mWindow
-
>
GetOuterWindow
(
)
;
NS_ASSERTION
(
outer
&
&
outer
-
>
GetCurrentInnerWindow
(
)
=
=
mLoadInfo
.
mWindow
"
Inner
window
no
longer
correct
!
"
)
;
}
#
endif
class
PostDebuggerMessageRunnable
final
:
public
nsRunnable
{
WorkerDebugger
*
mDebugger
;
nsString
mMessage
;
public
:
PostDebuggerMessageRunnable
(
WorkerDebugger
*
aDebugger
const
nsAString
&
aMessage
)
:
mDebugger
(
aDebugger
)
mMessage
(
aMessage
)
{
}
private
:
~
PostDebuggerMessageRunnable
(
)
{
}
NS_IMETHOD
Run
(
)
override
{
mDebugger
-
>
PostMessageToDebuggerOnMainThread
(
mMessage
)
;
return
NS_OK
;
}
}
;
class
ReportDebuggerErrorRunnable
final
:
public
nsRunnable
{
WorkerDebugger
*
mDebugger
;
nsString
mFilename
;
uint32_t
mLineno
;
nsString
mMessage
;
public
:
ReportDebuggerErrorRunnable
(
WorkerDebugger
*
aDebugger
const
nsAString
&
aFilename
uint32_t
aLineno
const
nsAString
&
aMessage
)
:
mDebugger
(
aDebugger
)
mFilename
(
aFilename
)
mLineno
(
aLineno
)
mMessage
(
aMessage
)
{
}
private
:
~
ReportDebuggerErrorRunnable
(
)
{
}
NS_IMETHOD
Run
(
)
override
{
mDebugger
-
>
ReportErrorToDebuggerOnMainThread
(
mFilename
mLineno
mMessage
)
;
return
NS_OK
;
}
}
;
WorkerDebugger
:
:
WorkerDebugger
(
WorkerPrivate
*
aWorkerPrivate
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mIsInitialized
(
false
)
{
AssertIsOnMainThread
(
)
;
}
WorkerDebugger
:
:
~
WorkerDebugger
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
if
(
NS_FAILED
(
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
)
)
{
NS_WARNING
(
"
Failed
to
proxy
release
of
listeners
leaking
instead
!
"
)
;
}
for
(
size_t
index
=
0
;
index
<
mListeners
.
Length
(
)
;
+
+
index
)
{
nsIWorkerDebuggerListener
*
listener
=
nullptr
;
mListeners
[
index
]
.
forget
(
&
listener
)
;
if
(
NS_FAILED
(
NS_ProxyRelease
(
mainThread
listener
)
)
)
{
NS_WARNING
(
"
Failed
to
proxy
release
of
listener
leaking
instead
!
"
)
;
}
}
}
}
NS_IMPL_ISUPPORTS
(
WorkerDebugger
nsIWorkerDebugger
)
NS_IMETHODIMP
WorkerDebugger
:
:
GetIsClosed
(
bool
*
aResult
)
{
AssertIsOnMainThread
(
)
;
*
aResult
=
!
mWorkerPrivate
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetIsChrome
(
bool
*
aResult
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mWorkerPrivate
-
>
IsChromeWorker
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetIsInitialized
(
bool
*
aResult
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mIsInitialized
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetParent
(
nsIWorkerDebugger
*
*
aResult
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
WorkerPrivate
*
parent
=
mWorkerPrivate
-
>
GetParent
(
)
;
if
(
!
parent
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
MOZ_ASSERT
(
mWorkerPrivate
-
>
IsDedicatedWorker
(
)
)
;
nsCOMPtr
<
nsIWorkerDebugger
>
debugger
=
parent
-
>
Debugger
(
)
;
debugger
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetType
(
uint32_t
*
aResult
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mWorkerPrivate
-
>
Type
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetUrl
(
nsAString
&
aResult
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
aResult
=
mWorkerPrivate
-
>
ScriptURL
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetWindow
(
mozIDOMWindow
*
*
aResult
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
mWorkerPrivate
-
>
GetParent
(
)
|
|
!
mWorkerPrivate
-
>
IsDedicatedWorker
(
)
)
{
*
aResult
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
mWorkerPrivate
-
>
GetWindow
(
)
;
window
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetPrincipal
(
nsIPrincipal
*
*
aResult
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aResult
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIPrincipal
>
prin
=
mWorkerPrivate
-
>
GetPrincipal
(
)
;
prin
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
GetServiceWorkerID
(
uint32_t
*
aResult
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aResult
)
;
if
(
!
mWorkerPrivate
|
|
!
mWorkerPrivate
-
>
IsServiceWorker
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
aResult
=
mWorkerPrivate
-
>
ServiceWorkerID
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
Initialize
(
const
nsAString
&
aURL
JSContext
*
aCx
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mIsInitialized
)
{
RefPtr
<
CompileDebuggerScriptRunnable
>
runnable
=
new
CompileDebuggerScriptRunnable
(
mWorkerPrivate
aURL
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
return
NS_ERROR_FAILURE
;
}
mIsInitialized
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
PostMessageMoz
(
const
nsAString
&
aMessage
JSContext
*
aCx
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mWorkerPrivate
|
|
!
mIsInitialized
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
DebuggerMessageEventRunnable
>
runnable
=
new
DebuggerMessageEventRunnable
(
mWorkerPrivate
aMessage
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
AddListener
(
nsIWorkerDebuggerListener
*
aListener
)
{
AssertIsOnMainThread
(
)
;
if
(
mListeners
.
Contains
(
aListener
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mListeners
.
AppendElement
(
aListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerDebugger
:
:
RemoveListener
(
nsIWorkerDebuggerListener
*
aListener
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mListeners
.
Contains
(
aListener
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mListeners
.
RemoveElement
(
aListener
)
;
return
NS_OK
;
}
void
WorkerDebugger
:
:
Close
(
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
mWorkerPrivate
=
nullptr
;
nsTArray
<
nsCOMPtr
<
nsIWorkerDebuggerListener
>
>
listeners
(
mListeners
)
;
for
(
size_t
index
=
0
;
index
<
listeners
.
Length
(
)
;
+
+
index
)
{
listeners
[
index
]
-
>
OnClose
(
)
;
}
}
void
WorkerDebugger
:
:
PostMessageToDebugger
(
const
nsAString
&
aMessage
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
PostDebuggerMessageRunnable
>
runnable
=
new
PostDebuggerMessageRunnable
(
this
aMessage
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
post
message
to
debugger
on
main
thread
!
"
)
;
}
}
void
WorkerDebugger
:
:
PostMessageToDebuggerOnMainThread
(
const
nsAString
&
aMessage
)
{
AssertIsOnMainThread
(
)
;
nsTArray
<
nsCOMPtr
<
nsIWorkerDebuggerListener
>
>
listeners
(
mListeners
)
;
for
(
size_t
index
=
0
;
index
<
listeners
.
Length
(
)
;
+
+
index
)
{
listeners
[
index
]
-
>
OnMessage
(
aMessage
)
;
}
}
void
WorkerDebugger
:
:
ReportErrorToDebugger
(
const
nsAString
&
aFilename
uint32_t
aLineno
const
nsAString
&
aMessage
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
ReportDebuggerErrorRunnable
>
runnable
=
new
ReportDebuggerErrorRunnable
(
this
aFilename
aLineno
aMessage
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
report
error
to
debugger
on
main
thread
!
"
)
;
}
}
void
WorkerDebugger
:
:
ReportErrorToDebuggerOnMainThread
(
const
nsAString
&
aFilename
uint32_t
aLineno
const
nsAString
&
aMessage
)
{
AssertIsOnMainThread
(
)
;
nsTArray
<
nsCOMPtr
<
nsIWorkerDebuggerListener
>
>
listeners
(
mListeners
)
;
for
(
size_t
index
=
0
;
index
<
listeners
.
Length
(
)
;
+
+
index
)
{
listeners
[
index
]
-
>
OnError
(
aFilename
aLineno
aMessage
)
;
}
LogErrorToConsole
(
aMessage
aFilename
nsString
(
)
aLineno
0
0
0
)
;
}
WorkerPrivate
:
:
WorkerPrivate
(
JSContext
*
aCx
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsACString
&
aWorkerName
WorkerLoadInfo
&
aLoadInfo
)
:
WorkerPrivateParent
<
WorkerPrivate
>
(
aCx
aParent
aScriptURL
aIsChromeWorker
aWorkerType
aWorkerName
aLoadInfo
)
mDebuggerRegistered
(
false
)
mDebugger
(
nullptr
)
mJSContext
(
nullptr
)
mPRThread
(
nullptr
)
mDebuggerEventLoopLevel
(
0
)
mErrorHandlerRecursionCount
(
0
)
mNextTimeoutId
(
1
)
mStatus
(
Pending
)
mFrozen
(
false
)
mTimerRunning
(
false
)
mRunningExpiredTimeouts
(
false
)
mCloseHandlerStarted
(
false
)
mCloseHandlerFinished
(
false
)
mPendingEventQueueClearing
(
false
)
mMemoryReporterRunning
(
false
)
mBlockedForMemoryReporter
(
false
)
mCancelAllPendingRunnables
(
false
)
mPeriodicGCTimerRunning
(
false
)
mIdleGCTimerRunning
(
false
)
mWorkerScriptExecutedSuccessfully
(
false
)
mOnLine
(
false
)
{
MOZ_ASSERT_IF
(
!
IsDedicatedWorker
(
)
!
aWorkerName
.
IsVoid
(
)
)
;
MOZ_ASSERT_IF
(
IsDedicatedWorker
(
)
aWorkerName
.
IsEmpty
(
)
)
;
if
(
aParent
)
{
aParent
-
>
AssertIsOnWorkerThread
(
)
;
aParent
-
>
GetAllPreferences
(
mPreferences
)
;
mOnLine
=
aParent
-
>
OnLine
(
)
;
}
else
{
AssertIsOnMainThread
(
)
;
RuntimeService
:
:
GetDefaultPreferences
(
mPreferences
)
;
mOnLine
=
!
NS_IsOffline
(
)
&
&
!
NS_IsAppOffline
(
aLoadInfo
.
mPrincipal
)
;
}
}
WorkerPrivate
:
:
~
WorkerPrivate
(
)
{
}
already_AddRefed
<
WorkerPrivate
>
WorkerPrivate
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aScriptURL
ErrorResult
&
aRv
)
{
return
WorkerPrivate
:
:
Constructor
(
aGlobal
aScriptURL
false
WorkerTypeDedicated
EmptyCString
(
)
nullptr
aRv
)
;
}
bool
WorkerPrivate
:
:
WorkerAvailable
(
JSContext
*
JSObject
*
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
true
;
}
if
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
return
true
;
}
return
Preferences
:
:
GetBool
(
PREF_WORKERS_ENABLED
)
;
}
already_AddRefed
<
ChromeWorkerPrivate
>
ChromeWorkerPrivate
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aScriptURL
ErrorResult
&
aRv
)
{
return
WorkerPrivate
:
:
Constructor
(
aGlobal
aScriptURL
true
WorkerTypeDedicated
EmptyCString
(
)
nullptr
aRv
)
.
downcast
<
ChromeWorkerPrivate
>
(
)
;
}
bool
ChromeWorkerPrivate
:
:
WorkerAvailable
(
JSContext
*
aCx
JSObject
*
)
{
if
(
NS_IsMainThread
(
)
)
{
return
nsContentUtils
:
:
IsCallerChrome
(
)
;
}
return
GetWorkerPrivateFromContext
(
aCx
)
-
>
IsChromeWorker
(
)
;
}
already_AddRefed
<
WorkerPrivate
>
WorkerPrivate
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsACString
&
aWorkerName
WorkerLoadInfo
*
aLoadInfo
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
return
Constructor
(
cx
aScriptURL
aIsChromeWorker
aWorkerType
aWorkerName
aLoadInfo
aRv
)
;
}
already_AddRefed
<
WorkerPrivate
>
WorkerPrivate
:
:
Constructor
(
JSContext
*
aCx
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsACString
&
aWorkerName
WorkerLoadInfo
*
aLoadInfo
ErrorResult
&
aRv
)
{
WorkerPrivate
*
parent
=
NS_IsMainThread
(
)
?
nullptr
:
GetCurrentThreadWorkerPrivate
(
)
;
if
(
parent
)
{
parent
-
>
AssertIsOnWorkerThread
(
)
;
}
else
{
AssertIsOnMainThread
(
)
;
}
MOZ_ASSERT_IF
(
aWorkerType
!
=
WorkerTypeDedicated
!
aWorkerName
.
IsVoid
(
)
)
;
MOZ_ASSERT_IF
(
aWorkerType
=
=
WorkerTypeDedicated
aWorkerName
.
IsEmpty
(
)
)
;
Maybe
<
WorkerLoadInfo
>
stackLoadInfo
;
if
(
!
aLoadInfo
)
{
stackLoadInfo
.
emplace
(
)
;
nsresult
rv
=
GetLoadInfo
(
aCx
nullptr
parent
aScriptURL
aIsChromeWorker
InheritLoadGroup
aWorkerType
stackLoadInfo
.
ptr
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
scriptloader
:
:
ReportLoadError
(
aCx
rv
)
;
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
aLoadInfo
=
stackLoadInfo
.
ptr
(
)
;
}
RuntimeService
*
runtimeService
;
if
(
!
parent
)
{
runtimeService
=
RuntimeService
:
:
GetOrCreateService
(
)
;
if
(
!
runtimeService
)
{
JS_ReportError
(
aCx
"
Failed
to
create
runtime
service
!
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
}
else
{
runtimeService
=
RuntimeService
:
:
GetService
(
)
;
}
MOZ_ASSERT
(
runtimeService
)
;
RefPtr
<
WorkerPrivate
>
worker
=
new
WorkerPrivate
(
aCx
parent
aScriptURL
aIsChromeWorker
aWorkerType
aWorkerName
*
aLoadInfo
)
;
if
(
!
runtimeService
-
>
RegisterWorker
(
aCx
worker
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
worker
-
>
EnableDebugger
(
)
;
RefPtr
<
CompileScriptRunnable
>
compiler
=
new
CompileScriptRunnable
(
worker
aScriptURL
)
;
if
(
!
compiler
-
>
Dispatch
(
aCx
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
worker
-
>
mSelfRef
=
worker
;
return
worker
.
forget
(
)
;
}
nsresult
WorkerPrivate
:
:
GetLoadInfo
(
JSContext
*
aCx
nsPIDOMWindowInner
*
aWindow
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
LoadGroupBehavior
aLoadGroupBehavior
WorkerType
aWorkerType
WorkerLoadInfo
*
aLoadInfo
)
{
using
namespace
mozilla
:
:
dom
:
:
workers
:
:
scriptloader
;
using
mozilla
:
:
dom
:
:
indexedDB
:
:
IDBFactory
;
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
aCx
=
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
;
if
(
aWindow
)
{
AssertIsOnMainThread
(
)
;
}
WorkerLoadInfo
loadInfo
;
nsresult
rv
;
if
(
aParent
)
{
aParent
-
>
AssertIsOnWorkerThread
(
)
;
Status
parentStatus
;
{
MutexAutoLock
lock
(
aParent
-
>
mMutex
)
;
parentStatus
=
aParent
-
>
mStatus
;
}
if
(
parentStatus
>
Running
)
{
NS_WARNING
(
"
Cannot
create
child
workers
from
the
close
handler
!
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
ChannelFromScriptURLWorkerThread
(
aCx
aParent
aScriptURL
loadInfo
.
mChannel
.
StartAssignment
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
{
MutexAutoLock
lock
(
aParent
-
>
mMutex
)
;
parentStatus
=
aParent
-
>
mStatus
;
}
if
(
parentStatus
>
Running
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
if
(
NS_FAILED
(
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
)
|
|
NS_FAILED
(
NS_ProxyRelease
(
mainThread
loadInfo
.
mChannel
)
)
)
{
NS_WARNING
(
"
Failed
to
proxy
release
of
channel
leaking
instead
!
"
)
;
}
return
NS_ERROR_FAILURE
;
}
loadInfo
.
mDomain
=
aParent
-
>
Domain
(
)
;
loadInfo
.
mFromWindow
=
aParent
-
>
IsFromWindow
(
)
;
loadInfo
.
mWindowID
=
aParent
-
>
WindowID
(
)
;
loadInfo
.
mStorageAllowed
=
aParent
-
>
IsStorageAllowed
(
)
;
loadInfo
.
mPrivateBrowsing
=
aParent
-
>
IsInPrivateBrowsing
(
)
;
loadInfo
.
mServiceWorkersTestingInWindow
=
aParent
-
>
ServiceWorkersTestingInWindow
(
)
;
}
else
{
AssertIsOnMainThread
(
)
;
NS_WARN_IF
(
!
indexedDB
:
:
IndexedDatabaseManager
:
:
GetOrCreate
(
)
)
;
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
MOZ_ASSERT
(
ssm
)
;
bool
isChrome
=
nsContentUtils
:
:
IsCallerChrome
(
)
;
if
(
aIsChromeWorker
&
&
!
isChrome
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
isChrome
)
{
rv
=
ssm
-
>
GetSystemPrincipal
(
getter_AddRefs
(
loadInfo
.
mPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadInfo
.
mPrincipalIsSystem
=
true
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
globalWindow
=
aWindow
;
if
(
!
globalWindow
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptGlobal
=
nsJSUtils
:
:
GetStaticScriptGlobal
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
scriptGlobal
)
{
globalWindow
=
do_QueryInterface
(
scriptGlobal
)
;
MOZ_ASSERT
(
globalWindow
)
;
}
}
nsCOMPtr
<
nsIDocument
>
document
;
if
(
globalWindow
)
{
if
(
nsPIDOMWindowOuter
*
outerWindow
=
globalWindow
-
>
GetOuterWindow
(
)
)
{
loadInfo
.
mWindow
=
outerWindow
-
>
GetCurrentInnerWindow
(
)
;
loadInfo
.
mServiceWorkersTestingInWindow
=
outerWindow
-
>
GetServiceWorkersTestingEnabled
(
)
;
}
if
(
!
loadInfo
.
mWindow
|
|
(
globalWindow
!
=
loadInfo
.
mWindow
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
loadInfo
.
mWindow
)
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
sgo
=
do_QueryInterface
(
loadInfo
.
mWindow
)
;
MOZ_ASSERT
(
sgo
)
;
loadInfo
.
mScriptContext
=
sgo
-
>
GetContext
(
)
;
NS_ENSURE_TRUE
(
loadInfo
.
mScriptContext
NS_ERROR_FAILURE
)
;
document
=
loadInfo
.
mWindow
-
>
GetExtantDoc
(
)
;
NS_ENSURE_TRUE
(
document
NS_ERROR_FAILURE
)
;
loadInfo
.
mBaseURI
=
document
-
>
GetDocBaseURI
(
)
;
loadInfo
.
mLoadGroup
=
document
-
>
GetDocumentLoadGroup
(
)
;
if
(
!
loadInfo
.
mPrincipal
)
{
loadInfo
.
mPrincipal
=
document
-
>
NodePrincipal
(
)
;
NS_ENSURE_TRUE
(
loadInfo
.
mPrincipal
NS_ERROR_FAILURE
)
;
if
(
document
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
{
nsCOMPtr
<
nsIDocument
>
tmpDoc
=
document
;
do
{
tmpDoc
=
tmpDoc
-
>
GetParentDocument
(
)
;
}
while
(
tmpDoc
&
&
tmpDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
;
if
(
tmpDoc
)
{
nsCOMPtr
<
nsIPrincipal
>
tmpPrincipal
=
tmpDoc
-
>
NodePrincipal
(
)
;
rv
=
tmpPrincipal
-
>
GetBaseDomain
(
loadInfo
.
mDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
loadInfo
.
mPrincipal
-
>
GetBaseDomain
(
loadInfo
.
mDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
rv
=
loadInfo
.
mPrincipal
-
>
GetBaseDomain
(
loadInfo
.
mDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
nsCOMPtr
<
nsIPermissionManager
>
permMgr
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
perm
;
rv
=
permMgr
-
>
TestPermissionFromPrincipal
(
loadInfo
.
mPrincipal
"
systemXHR
"
&
perm
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadInfo
.
mXHRParamsAllowed
=
perm
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
uint16_t
appStatus
=
loadInfo
.
mPrincipal
-
>
GetAppStatus
(
)
;
loadInfo
.
mIsInPrivilegedApp
=
(
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_CERTIFIED
|
|
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_PRIVILEGED
)
;
loadInfo
.
mIsInCertifiedApp
=
(
appStatus
=
=
nsIPrincipal
:
:
APP_STATUS_CERTIFIED
)
;
loadInfo
.
mFromWindow
=
true
;
loadInfo
.
mWindowID
=
globalWindow
-
>
WindowID
(
)
;
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForWindow
(
globalWindow
)
;
loadInfo
.
mStorageAllowed
=
access
>
nsContentUtils
:
:
StorageAccess
:
:
eDeny
;
loadInfo
.
mPrivateBrowsing
=
nsContentUtils
:
:
IsInPrivateBrowsing
(
document
)
;
}
else
{
MOZ_ASSERT
(
isChrome
)
;
JS
:
:
UniqueChars
fileName
;
if
(
JS
:
:
DescribeScriptedCaller
(
aCx
&
fileName
)
)
{
nsCOMPtr
<
nsIFile
>
scriptFile
=
do_CreateInstance
(
"
mozilla
.
org
/
file
/
local
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
scriptFile
-
>
InitWithPath
(
NS_ConvertUTF8toUTF16
(
fileName
.
get
(
)
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
NS_NewFileURI
(
getter_AddRefs
(
loadInfo
.
mBaseURI
)
scriptFile
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
loadInfo
.
mBaseURI
)
fileName
.
get
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
loadInfo
.
mXHRParamsAllowed
=
true
;
loadInfo
.
mFromWindow
=
false
;
loadInfo
.
mWindowID
=
UINT64_MAX
;
loadInfo
.
mStorageAllowed
=
true
;
loadInfo
.
mPrivateBrowsing
=
false
;
}
MOZ_ASSERT
(
loadInfo
.
mPrincipal
)
;
MOZ_ASSERT
(
isChrome
|
|
!
loadInfo
.
mDomain
.
IsEmpty
(
)
)
;
if
(
!
loadInfo
.
mLoadGroup
|
|
aLoadGroupBehavior
=
=
OverrideLoadGroup
)
{
OverrideLoadInfoLoadGroup
(
loadInfo
)
;
}
MOZ_ASSERT
(
NS_LoadGroupMatchesPrincipal
(
loadInfo
.
mLoadGroup
loadInfo
.
mPrincipal
)
)
;
rv
=
ChannelFromScriptURLMainThread
(
loadInfo
.
mPrincipal
loadInfo
.
mBaseURI
document
loadInfo
.
mLoadGroup
aScriptURL
ContentPolicyType
(
aWorkerType
)
getter_AddRefs
(
loadInfo
.
mChannel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
NS_GetFinalChannelURI
(
loadInfo
.
mChannel
getter_AddRefs
(
loadInfo
.
mResolvedScriptURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
aLoadInfo
-
>
StealFrom
(
loadInfo
)
;
return
NS_OK
;
}
void
WorkerPrivate
:
:
OverrideLoadInfoLoadGroup
(
WorkerLoadInfo
&
aLoadInfo
)
{
MOZ_ASSERT
(
!
aLoadInfo
.
mInterfaceRequestor
)
;
aLoadInfo
.
mInterfaceRequestor
=
new
WorkerLoadInfo
:
:
InterfaceRequestor
(
aLoadInfo
.
mPrincipal
aLoadInfo
.
mLoadGroup
)
;
aLoadInfo
.
mInterfaceRequestor
-
>
MaybeAddTabChild
(
aLoadInfo
.
mLoadGroup
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
do_CreateInstance
(
NS_LOADGROUP_CONTRACTID
)
;
nsresult
rv
=
loadGroup
-
>
SetNotificationCallbacks
(
aLoadInfo
.
mInterfaceRequestor
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
aLoadInfo
.
mLoadGroup
=
loadGroup
.
forget
(
)
;
}
void
WorkerPrivate
:
:
DoRunLoop
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mThread
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mJSContext
=
aCx
;
MOZ_ASSERT
(
mStatus
=
=
Pending
)
;
mStatus
=
Running
;
}
EnableMemoryReporter
(
)
;
InitializeGCTimers
(
)
;
Maybe
<
JSAutoCompartment
>
workerCompartment
;
for
(
;
;
)
{
Status
currentStatus
;
bool
debuggerRunnablesPending
=
false
;
bool
normalRunnablesPending
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
while
(
mControlQueue
.
IsEmpty
(
)
&
&
!
(
debuggerRunnablesPending
=
!
mDebuggerQueue
.
IsEmpty
(
)
)
&
&
!
(
normalRunnablesPending
=
NS_HasPendingEvents
(
mThread
)
)
)
{
WaitForWorkerEvents
(
)
;
}
ProcessAllControlRunnablesLocked
(
)
;
currentStatus
=
mStatus
;
}
if
(
currentStatus
!
=
Running
&
&
!
HasActiveFeatures
(
)
)
{
if
(
mCloseHandlerFinished
&
&
currentStatus
!
=
Killing
)
{
if
(
!
NotifyInternal
(
aCx
Killing
)
)
{
JS_ReportPendingException
(
aCx
)
;
}
#
ifdef
DEBUG
{
MutexAutoLock
lock
(
mMutex
)
;
currentStatus
=
mStatus
;
}
MOZ_ASSERT
(
currentStatus
=
=
Killing
)
;
#
else
currentStatus
=
Killing
;
#
endif
}
if
(
currentStatus
=
=
Killing
)
{
PromiseDebugging
:
:
FlushUncaughtRejections
(
)
;
ShutdownGCTimers
(
)
;
DisableMemoryReporter
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
mStatus
=
Dead
;
mJSContext
=
nullptr
;
}
if
(
!
mControlQueue
.
IsEmpty
(
)
)
{
WorkerControlRunnable
*
runnable
;
while
(
mControlQueue
.
Pop
(
runnable
)
)
{
runnable
-
>
Cancel
(
)
;
runnable
-
>
Release
(
)
;
}
}
mScope
=
nullptr
;
mDebuggerScope
=
nullptr
;
return
;
}
}
if
(
debuggerRunnablesPending
|
|
normalRunnablesPending
)
{
SetGCTimerMode
(
PeriodicTimer
)
;
}
if
(
debuggerRunnablesPending
)
{
WorkerRunnable
*
runnable
;
{
MutexAutoLock
lock
(
mMutex
)
;
mDebuggerQueue
.
Pop
(
runnable
)
;
debuggerRunnablesPending
=
!
mDebuggerQueue
.
IsEmpty
(
)
;
}
MOZ_ASSERT
(
runnable
)
;
static_cast
<
nsIRunnable
*
>
(
runnable
)
-
>
Run
(
)
;
runnable
-
>
Release
(
)
;
if
(
debuggerRunnablesPending
)
{
WorkerDebuggerGlobalScope
*
globalScope
=
DebuggerGlobalScope
(
)
;
MOZ_ASSERT
(
globalScope
)
;
JSAutoCompartment
ac
(
aCx
globalScope
-
>
GetGlobalJSObject
(
)
)
;
JS_MaybeGC
(
aCx
)
;
}
}
else
if
(
normalRunnablesPending
)
{
MOZ_ASSERT
(
NS_HasPendingEvents
(
mThread
)
)
;
MOZ_ALWAYS_TRUE
(
NS_ProcessNextEvent
(
mThread
false
)
)
;
normalRunnablesPending
=
NS_HasPendingEvents
(
mThread
)
;
if
(
normalRunnablesPending
&
&
GlobalScope
(
)
)
{
JSAutoCompartment
ac
(
aCx
GlobalScope
(
)
-
>
GetGlobalJSObject
(
)
)
;
JS_MaybeGC
(
aCx
)
;
}
}
if
(
!
debuggerRunnablesPending
&
&
!
normalRunnablesPending
)
{
SetGCTimerMode
(
IdleTimer
)
;
}
}
MOZ_CRASH
(
"
Shouldn
'
t
get
here
!
"
)
;
}
void
WorkerPrivate
:
:
OnProcessNextEvent
(
)
{
AssertIsOnWorkerThread
(
)
;
uint32_t
recursionDepth
=
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
RecursionDepth
(
)
;
MOZ_ASSERT
(
recursionDepth
)
;
if
(
recursionDepth
>
1
&
&
mSyncLoopStack
.
Length
(
)
<
recursionDepth
-
1
)
{
ProcessAllControlRunnables
(
)
;
}
}
void
WorkerPrivate
:
:
AfterProcessNextEvent
(
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
RecursionDepth
(
)
)
;
}
void
WorkerPrivate
:
:
MaybeDispatchLoadFailedRunnable
(
)
{
AssertIsOnWorkerThread
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
StealLoadFailedAsyncRunnable
(
)
;
if
(
!
runnable
)
{
return
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
)
)
;
}
void
WorkerPrivate
:
:
InitializeGCTimers
(
)
{
AssertIsOnWorkerThread
(
)
;
mGCTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
MOZ_ASSERT
(
mGCTimer
)
;
RefPtr
<
GarbageCollectRunnable
>
runnable
=
new
GarbageCollectRunnable
(
this
false
false
)
;
mPeriodicGCTimerTarget
=
new
TimerThreadEventTarget
(
this
runnable
)
;
runnable
=
new
GarbageCollectRunnable
(
this
true
false
)
;
mIdleGCTimerTarget
=
new
TimerThreadEventTarget
(
this
runnable
)
;
mPeriodicGCTimerRunning
=
false
;
mIdleGCTimerRunning
=
false
;
}
void
WorkerPrivate
:
:
SetGCTimerMode
(
GCTimerMode
aMode
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mGCTimer
)
;
MOZ_ASSERT
(
mPeriodicGCTimerTarget
)
;
MOZ_ASSERT
(
mIdleGCTimerTarget
)
;
if
(
(
aMode
=
=
PeriodicTimer
&
&
mPeriodicGCTimerRunning
)
|
|
(
aMode
=
=
IdleTimer
&
&
mIdleGCTimerRunning
)
)
{
return
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mGCTimer
-
>
Cancel
(
)
)
)
;
mPeriodicGCTimerRunning
=
false
;
mIdleGCTimerRunning
=
false
;
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
canceled
GC
timer
because
%
s
\
n
"
this
aMode
=
=
PeriodicTimer
?
"
periodic
"
:
aMode
=
=
IdleTimer
?
"
idle
"
:
"
none
"
)
)
;
if
(
aMode
=
=
NoTimer
)
{
return
;
}
MOZ_ASSERT
(
aMode
=
=
PeriodicTimer
|
|
aMode
=
=
IdleTimer
)
;
nsIEventTarget
*
target
;
uint32_t
delay
;
int16_t
type
;
if
(
aMode
=
=
PeriodicTimer
)
{
target
=
mPeriodicGCTimerTarget
;
delay
=
PERIODIC_GC_TIMER_DELAY_SEC
*
1000
;
type
=
nsITimer
:
:
TYPE_REPEATING_SLACK
;
}
else
{
target
=
mIdleGCTimerTarget
;
delay
=
IDLE_GC_TIMER_DELAY_SEC
*
1000
;
type
=
nsITimer
:
:
TYPE_ONE_SHOT
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mGCTimer
-
>
SetTarget
(
target
)
)
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mGCTimer
-
>
InitWithNamedFuncCallback
(
DummyCallback
nullptr
delay
type
"
dom
:
:
workers
:
:
DummyCallback
(
2
)
"
)
)
)
;
if
(
aMode
=
=
PeriodicTimer
)
{
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
scheduled
periodic
GC
timer
\
n
"
this
)
)
;
mPeriodicGCTimerRunning
=
true
;
}
else
{
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
scheduled
idle
GC
timer
\
n
"
this
)
)
;
mIdleGCTimerRunning
=
true
;
}
}
void
WorkerPrivate
:
:
ShutdownGCTimers
(
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mGCTimer
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mGCTimer
-
>
Cancel
(
)
)
)
;
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
killed
the
GC
timer
\
n
"
this
)
)
;
mGCTimer
=
nullptr
;
mPeriodicGCTimerTarget
=
nullptr
;
mIdleGCTimerTarget
=
nullptr
;
mPeriodicGCTimerRunning
=
false
;
mIdleGCTimerRunning
=
false
;
}
bool
WorkerPrivate
:
:
InterruptCallback
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
bool
mayContinue
=
true
;
bool
scheduledIdleGC
=
false
;
for
(
;
;
)
{
mayContinue
=
ProcessAllControlRunnables
(
)
;
bool
mayFreeze
=
mFrozen
;
if
(
mayFreeze
)
{
MutexAutoLock
lock
(
mMutex
)
;
mayFreeze
=
mStatus
<
=
Running
;
}
if
(
!
mayContinue
|
|
!
mayFreeze
)
{
break
;
}
if
(
!
scheduledIdleGC
)
{
SetGCTimerMode
(
IdleTimer
)
;
scheduledIdleGC
=
true
;
}
while
(
(
mayContinue
=
MayContinueRunning
(
)
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mControlQueue
.
IsEmpty
(
)
)
{
break
;
}
WaitForWorkerEvents
(
PR_MillisecondsToInterval
(
RemainingRunTimeMS
(
)
)
)
;
}
}
if
(
!
mayContinue
)
{
NS_ASSERTION
(
!
JS_IsExceptionPending
(
aCx
)
"
Should
not
have
an
exception
set
here
!
"
)
;
return
false
;
}
SetGCTimerMode
(
PeriodicTimer
)
;
return
true
;
}
nsresult
WorkerPrivate
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
MOZ_ASSERT
(
aIsOnCurrentThread
)
;
MOZ_ASSERT
(
mPRThread
)
;
*
aIsOnCurrentThread
=
PR_GetCurrentThread
(
)
=
=
mPRThread
;
return
NS_OK
;
}
void
WorkerPrivate
:
:
ScheduleDeletion
(
WorkerRanOrNot
aRanOrNot
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mChildWorkers
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mSyncLoopStack
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mPendingEventQueueClearing
)
;
ClearMainEventQueue
(
aRanOrNot
)
;
#
ifdef
DEBUG
if
(
WorkerRan
=
=
aRanOrNot
)
{
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
currentThread
)
;
MOZ_ASSERT
(
!
NS_HasPendingEvents
(
currentThread
)
)
;
}
#
endif
if
(
WorkerPrivate
*
parent
=
GetParent
(
)
)
{
RefPtr
<
WorkerFinishedRunnable
>
runnable
=
new
WorkerFinishedRunnable
(
parent
this
)
;
if
(
!
runnable
-
>
Dispatch
(
nullptr
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
runnable
!
"
)
;
}
}
else
{
RefPtr
<
TopLevelWorkerFinishedRunnable
>
runnable
=
new
TopLevelWorkerFinishedRunnable
(
this
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
runnable
!
"
)
;
}
}
}
bool
WorkerPrivate
:
:
BlockAndCollectRuntimeStats
(
JS
:
:
RuntimeStats
*
aRtStats
bool
aAnonymize
)
{
AssertIsOnMainThread
(
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
NS_ASSERTION
(
aRtStats
"
Null
RuntimeStats
!
"
)
;
NS_ASSERTION
(
!
mMemoryReporterRunning
"
How
can
we
get
reentered
here
?
!
"
)
;
mMemoryReporterRunning
=
true
;
NS_ASSERTION
(
mJSContext
"
This
must
never
be
null
!
"
)
;
JSRuntime
*
rt
=
JS_GetRuntime
(
mJSContext
)
;
if
(
!
mBlockedForMemoryReporter
)
{
JS_RequestInterruptCallback
(
rt
)
;
while
(
!
mBlockedForMemoryReporter
)
{
mMemoryReportCondVar
.
Wait
(
)
;
}
}
bool
succeeded
=
false
;
if
(
mMemoryReporter
)
{
MutexAutoUnlock
unlock
(
mMutex
)
;
succeeded
=
JS
:
:
CollectRuntimeStats
(
rt
aRtStats
nullptr
aAnonymize
)
;
}
NS_ASSERTION
(
mMemoryReporterRunning
"
This
isn
'
t
possible
!
"
)
;
NS_ASSERTION
(
mBlockedForMemoryReporter
"
Somehow
we
got
unblocked
!
"
)
;
mMemoryReporterRunning
=
false
;
mMemoryReportCondVar
.
Notify
(
)
;
return
succeeded
;
}
void
WorkerPrivate
:
:
EnableMemoryReporter
(
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mMemoryReporter
)
;
mMemoryReporter
=
new
MemoryReporter
(
this
)
;
if
(
NS_FAILED
(
RegisterWeakMemoryReporter
(
mMemoryReporter
)
)
)
{
NS_WARNING
(
"
Failed
to
register
memory
reporter
!
"
)
;
mMemoryReporter
=
nullptr
;
}
}
void
WorkerPrivate
:
:
DisableMemoryReporter
(
)
{
AssertIsOnWorkerThread
(
)
;
RefPtr
<
MemoryReporter
>
memoryReporter
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mMemoryReporter
)
{
return
;
}
mMemoryReporter
.
swap
(
memoryReporter
)
;
memoryReporter
-
>
Disable
(
)
;
if
(
mMemoryReporterRunning
)
{
NS_ASSERTION
(
!
mBlockedForMemoryReporter
"
Can
'
t
be
blocked
in
more
than
one
place
at
the
same
time
!
"
)
;
mBlockedForMemoryReporter
=
true
;
mMemoryReportCondVar
.
Notify
(
)
;
while
(
mMemoryReporterRunning
)
{
mMemoryReportCondVar
.
Wait
(
)
;
}
NS_ASSERTION
(
mBlockedForMemoryReporter
"
Somehow
we
got
unblocked
!
"
)
;
mBlockedForMemoryReporter
=
false
;
}
}
if
(
NS_FAILED
(
UnregisterWeakMemoryReporter
(
memoryReporter
)
)
)
{
NS_WARNING
(
"
Failed
to
unregister
memory
reporter
!
"
)
;
}
}
void
WorkerPrivate
:
:
WaitForWorkerEvents
(
PRIntervalTime
aInterval
)
{
AssertIsOnWorkerThread
(
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
NS_ASSERTION
(
!
mBlockedForMemoryReporter
"
Can
'
t
be
blocked
in
more
than
one
place
at
the
same
time
!
"
)
;
mBlockedForMemoryReporter
=
true
;
mMemoryReportCondVar
.
Notify
(
)
;
mCondVar
.
Wait
(
aInterval
)
;
while
(
mMemoryReporterRunning
)
{
mMemoryReportCondVar
.
Wait
(
)
;
}
NS_ASSERTION
(
mBlockedForMemoryReporter
"
Somehow
we
got
unblocked
!
"
)
;
mBlockedForMemoryReporter
=
false
;
}
bool
WorkerPrivate
:
:
ProcessAllControlRunnablesLocked
(
)
{
AssertIsOnWorkerThread
(
)
;
mMutex
.
AssertCurrentThreadOwns
(
)
;
bool
result
=
true
;
for
(
;
;
)
{
if
(
mMemoryReporterRunning
)
{
MOZ_ASSERT
(
!
mBlockedForMemoryReporter
)
;
mBlockedForMemoryReporter
=
true
;
mMemoryReportCondVar
.
Notify
(
)
;
while
(
mMemoryReporterRunning
)
{
mMemoryReportCondVar
.
Wait
(
)
;
}
MOZ_ASSERT
(
mBlockedForMemoryReporter
)
;
mBlockedForMemoryReporter
=
false
;
}
WorkerControlRunnable
*
event
;
if
(
!
mControlQueue
.
Pop
(
event
)
)
{
break
;
}
MutexAutoUnlock
unlock
(
mMutex
)
;
MOZ_ASSERT
(
event
)
;
if
(
NS_FAILED
(
static_cast
<
nsIRunnable
*
>
(
event
)
-
>
Run
(
)
)
)
{
result
=
false
;
}
event
-
>
Release
(
)
;
}
return
result
;
}
void
WorkerPrivate
:
:
ClearMainEventQueue
(
WorkerRanOrNot
aRanOrNot
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mSyncLoopStack
.
Length
(
)
)
;
MOZ_ASSERT
(
!
mCancelAllPendingRunnables
)
;
mCancelAllPendingRunnables
=
true
;
if
(
WorkerNeverRan
=
=
aRanOrNot
)
{
for
(
uint32_t
count
=
mPreStartRunnables
.
Length
(
)
index
=
0
;
index
<
count
;
index
+
+
)
{
RefPtr
<
WorkerRunnable
>
runnable
=
mPreStartRunnables
[
index
]
.
forget
(
)
;
static_cast
<
nsIRunnable
*
>
(
runnable
.
get
(
)
)
-
>
Run
(
)
;
}
}
else
{
nsIThread
*
currentThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
currentThread
)
;
NS_ProcessPendingEvents
(
currentThread
)
;
}
MOZ_ASSERT
(
mCancelAllPendingRunnables
)
;
mCancelAllPendingRunnables
=
false
;
}
uint32_t
WorkerPrivate
:
:
RemainingRunTimeMS
(
)
const
{
if
(
mKillTime
.
IsNull
(
)
)
{
return
UINT32_MAX
;
}
TimeDuration
runtime
=
mKillTime
-
TimeStamp
:
:
Now
(
)
;
double
ms
=
runtime
>
TimeDuration
(
0
)
?
runtime
.
ToMilliseconds
(
)
:
0
;
return
ms
>
double
(
UINT32_MAX
)
?
UINT32_MAX
:
uint32_t
(
ms
)
;
}
bool
WorkerPrivate
:
:
FreezeInternal
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
NS_ASSERTION
(
!
mFrozen
"
Already
frozen
!
"
)
;
mFrozen
=
true
;
return
true
;
}
bool
WorkerPrivate
:
:
ThawInternal
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
NS_ASSERTION
(
mFrozen
"
Not
yet
frozen
!
"
)
;
mFrozen
=
false
;
return
true
;
}
void
WorkerPrivate
:
:
TraceTimeouts
(
const
TraceCallbacks
&
aCallbacks
void
*
aClosure
)
const
{
AssertIsOnWorkerThread
(
)
;
for
(
uint32_t
index
=
0
;
index
<
mTimeouts
.
Length
(
)
;
index
+
+
)
{
TimeoutInfo
*
info
=
mTimeouts
[
index
]
;
if
(
info
-
>
mTimeoutCallable
.
isUndefined
(
)
)
{
continue
;
}
aCallbacks
.
Trace
(
&
info
-
>
mTimeoutCallable
"
mTimeoutCallable
"
aClosure
)
;
for
(
uint32_t
index2
=
0
;
index2
<
info
-
>
mExtraArgVals
.
Length
(
)
;
index2
+
+
)
{
aCallbacks
.
Trace
(
&
info
-
>
mExtraArgVals
[
index2
]
"
mExtraArgVals
[
i
]
"
aClosure
)
;
}
}
}
bool
WorkerPrivate
:
:
ModifyBusyCountFromWorker
(
JSContext
*
aCx
bool
aIncrease
)
{
AssertIsOnWorkerThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mStatus
>
=
Killing
)
{
return
true
;
}
}
RefPtr
<
ModifyBusyCountRunnable
>
runnable
=
new
ModifyBusyCountRunnable
(
this
aIncrease
)
;
return
runnable
-
>
Dispatch
(
aCx
)
;
}
bool
WorkerPrivate
:
:
AddChildWorker
(
JSContext
*
aCx
ParentType
*
aChildWorker
)
{
AssertIsOnWorkerThread
(
)
;
#
ifdef
DEBUG
{
Status
currentStatus
;
{
MutexAutoLock
lock
(
mMutex
)
;
currentStatus
=
mStatus
;
}
MOZ_ASSERT
(
currentStatus
=
=
Running
)
;
}
#
endif
NS_ASSERTION
(
!
mChildWorkers
.
Contains
(
aChildWorker
)
"
Already
know
about
this
one
!
"
)
;
mChildWorkers
.
AppendElement
(
aChildWorker
)
;
return
mChildWorkers
.
Length
(
)
=
=
1
?
ModifyBusyCountFromWorker
(
aCx
true
)
:
true
;
}
void
WorkerPrivate
:
:
RemoveChildWorker
(
JSContext
*
aCx
ParentType
*
aChildWorker
)
{
AssertIsOnWorkerThread
(
)
;
NS_ASSERTION
(
mChildWorkers
.
Contains
(
aChildWorker
)
"
Didn
'
t
know
about
this
one
!
"
)
;
mChildWorkers
.
RemoveElement
(
aChildWorker
)
;
if
(
mChildWorkers
.
IsEmpty
(
)
&
&
!
ModifyBusyCountFromWorker
(
aCx
false
)
)
{
NS_WARNING
(
"
Failed
to
modify
busy
count
!
"
)
;
}
}
bool
WorkerPrivate
:
:
AddFeature
(
JSContext
*
aCx
WorkerFeature
*
aFeature
)
{
AssertIsOnWorkerThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mStatus
>
=
Canceling
)
{
return
false
;
}
}
MOZ_ASSERT
(
!
mFeatures
.
Contains
(
aFeature
)
"
Already
know
about
this
one
!
"
)
;
if
(
mFeatures
.
IsEmpty
(
)
&
&
!
ModifyBusyCountFromWorker
(
aCx
true
)
)
{
return
false
;
}
mFeatures
.
AppendElement
(
aFeature
)
;
return
true
;
}
void
WorkerPrivate
:
:
RemoveFeature
(
JSContext
*
aCx
WorkerFeature
*
aFeature
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mFeatures
.
Contains
(
aFeature
)
"
Didn
'
t
know
about
this
one
!
"
)
;
mFeatures
.
RemoveElement
(
aFeature
)
;
if
(
mFeatures
.
IsEmpty
(
)
&
&
!
ModifyBusyCountFromWorker
(
aCx
false
)
)
{
NS_WARNING
(
"
Failed
to
modify
busy
count
!
"
)
;
}
}
void
WorkerPrivate
:
:
NotifyFeatures
(
JSContext
*
aCx
Status
aStatus
)
{
AssertIsOnWorkerThread
(
)
;
NS_ASSERTION
(
aStatus
>
Running
"
Bad
status
!
"
)
;
if
(
aStatus
>
=
Closing
)
{
CancelAllTimeouts
(
aCx
)
;
}
nsTObserverArray
<
WorkerFeature
*
>
:
:
ForwardIterator
iter
(
mFeatures
)
;
while
(
iter
.
HasMore
(
)
)
{
WorkerFeature
*
feature
=
iter
.
GetNext
(
)
;
if
(
!
feature
-
>
Notify
(
aCx
aStatus
)
)
{
NS_WARNING
(
"
Failed
to
notify
feature
!
"
)
;
}
}
AutoTArray
<
ParentType
*
10
>
children
;
children
.
AppendElements
(
mChildWorkers
)
;
for
(
uint32_t
index
=
0
;
index
<
children
.
Length
(
)
;
index
+
+
)
{
if
(
!
children
[
index
]
-
>
Notify
(
aCx
aStatus
)
)
{
NS_WARNING
(
"
Failed
to
notify
child
worker
!
"
)
;
}
}
}
void
WorkerPrivate
:
:
CancelAllTimeouts
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
LOG
(
TimeoutsLog
(
)
(
"
Worker
%
p
CancelAllTimeouts
.
\
n
"
this
)
)
;
if
(
mTimerRunning
)
{
NS_ASSERTION
(
mTimer
&
&
mTimerRunnable
"
Huh
?
!
"
)
;
NS_ASSERTION
(
!
mTimeouts
.
IsEmpty
(
)
"
Huh
?
!
"
)
;
if
(
NS_FAILED
(
mTimer
-
>
Cancel
(
)
)
)
{
NS_WARNING
(
"
Failed
to
cancel
timer
!
"
)
;
}
for
(
uint32_t
index
=
0
;
index
<
mTimeouts
.
Length
(
)
;
index
+
+
)
{
mTimeouts
[
index
]
-
>
mCanceled
=
true
;
}
if
(
!
RunExpiredTimeouts
(
aCx
)
)
{
JS_ReportPendingException
(
aCx
)
;
}
mTimerRunning
=
false
;
}
#
ifdef
DEBUG
else
if
(
!
mRunningExpiredTimeouts
)
{
NS_ASSERTION
(
mTimeouts
.
IsEmpty
(
)
"
Huh
?
!
"
)
;
}
#
endif
mTimer
=
nullptr
;
mTimerRunnable
=
nullptr
;
}
already_AddRefed
<
nsIEventTarget
>
WorkerPrivate
:
:
CreateNewSyncLoop
(
)
{
AssertIsOnWorkerThread
(
)
;
nsCOMPtr
<
nsIThreadInternal
>
thread
=
do_QueryInterface
(
NS_GetCurrentThread
(
)
)
;
MOZ_ASSERT
(
thread
)
;
nsCOMPtr
<
nsIEventTarget
>
realEventTarget
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
thread
-
>
PushEventQueue
(
getter_AddRefs
(
realEventTarget
)
)
)
)
;
RefPtr
<
EventTarget
>
workerEventTarget
=
new
EventTarget
(
this
realEventTarget
)
;
{
#
ifdef
DEBUG
MutexAutoLock
lock
(
mMutex
)
;
#
endif
mSyncLoopStack
.
AppendElement
(
new
SyncLoopInfo
(
workerEventTarget
)
)
;
}
return
workerEventTarget
.
forget
(
)
;
}
bool
WorkerPrivate
:
:
RunCurrentSyncLoop
(
)
{
AssertIsOnWorkerThread
(
)
;
JSContext
*
cx
=
GetJSContext
(
)
;
MOZ_ASSERT
(
cx
)
;
uint32_t
currentLoopIndex
=
mSyncLoopStack
.
Length
(
)
-
1
;
SyncLoopInfo
*
loopInfo
=
mSyncLoopStack
[
currentLoopIndex
]
;
MOZ_ASSERT
(
loopInfo
)
;
MOZ_ASSERT
(
!
loopInfo
-
>
mHasRun
)
;
MOZ_ASSERT
(
!
loopInfo
-
>
mCompleted
)
;
#
ifdef
DEBUG
loopInfo
-
>
mHasRun
=
true
;
#
endif
while
(
!
loopInfo
-
>
mCompleted
)
{
bool
normalRunnablesPending
=
false
;
if
(
!
NS_HasPendingEvents
(
mThread
)
)
{
SetGCTimerMode
(
IdleTimer
)
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
;
;
)
{
while
(
mControlQueue
.
IsEmpty
(
)
&
&
!
normalRunnablesPending
&
&
!
(
normalRunnablesPending
=
NS_HasPendingEvents
(
mThread
)
)
)
{
WaitForWorkerEvents
(
)
;
}
ProcessAllControlRunnablesLocked
(
)
;
if
(
normalRunnablesPending
|
|
loopInfo
-
>
mCompleted
)
{
break
;
}
}
}
if
(
normalRunnablesPending
)
{
SetGCTimerMode
(
PeriodicTimer
)
;
MOZ_ALWAYS_TRUE
(
NS_ProcessNextEvent
(
mThread
false
)
)
;
if
(
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
{
JS_MaybeGC
(
cx
)
;
}
}
}
MOZ_ASSERT
(
mSyncLoopStack
[
currentLoopIndex
]
=
=
loopInfo
)
;
return
DestroySyncLoop
(
currentLoopIndex
)
;
}
bool
WorkerPrivate
:
:
DestroySyncLoop
(
uint32_t
aLoopIndex
nsIThreadInternal
*
aThread
)
{
MOZ_ASSERT
(
!
mSyncLoopStack
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mSyncLoopStack
.
Length
(
)
-
1
=
=
aLoopIndex
)
;
if
(
!
aThread
)
{
aThread
=
mThread
;
}
SyncLoopInfo
*
loopInfo
=
mSyncLoopStack
[
aLoopIndex
]
;
nsIEventTarget
*
nestedEventTarget
=
loopInfo
-
>
mEventTarget
-
>
GetWeakNestedEventTarget
(
)
;
MOZ_ASSERT
(
nestedEventTarget
)
;
bool
result
=
loopInfo
-
>
mResult
;
{
#
ifdef
DEBUG
MutexAutoLock
lock
(
mMutex
)
;
#
endif
mSyncLoopStack
.
RemoveElementAt
(
aLoopIndex
)
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
aThread
-
>
PopEventQueue
(
nestedEventTarget
)
)
)
;
if
(
!
mSyncLoopStack
.
Length
(
)
&
&
mPendingEventQueueClearing
)
{
ClearMainEventQueue
(
WorkerRan
)
;
mPendingEventQueueClearing
=
false
;
}
return
result
;
}
void
WorkerPrivate
:
:
StopSyncLoop
(
nsIEventTarget
*
aSyncLoopTarget
bool
aResult
)
{
AssertIsOnWorkerThread
(
)
;
AssertValidSyncLoop
(
aSyncLoopTarget
)
;
MOZ_ASSERT
(
!
mSyncLoopStack
.
IsEmpty
(
)
)
;
for
(
uint32_t
index
=
mSyncLoopStack
.
Length
(
)
;
index
>
0
;
index
-
-
)
{
nsAutoPtr
<
SyncLoopInfo
>
&
loopInfo
=
mSyncLoopStack
[
index
-
1
]
;
MOZ_ASSERT
(
loopInfo
)
;
MOZ_ASSERT
(
loopInfo
-
>
mEventTarget
)
;
if
(
loopInfo
-
>
mEventTarget
=
=
aSyncLoopTarget
)
{
MOZ_ASSERT
(
!
loopInfo
-
>
mCompleted
)
;
loopInfo
-
>
mResult
=
aResult
;
loopInfo
-
>
mCompleted
=
true
;
loopInfo
-
>
mEventTarget
-
>
Disable
(
)
;
return
;
}
MOZ_ASSERT
(
!
SameCOMIdentity
(
loopInfo
-
>
mEventTarget
aSyncLoopTarget
)
)
;
}
MOZ_CRASH
(
"
Unknown
sync
loop
!
"
)
;
}
#
ifdef
DEBUG
void
WorkerPrivate
:
:
AssertValidSyncLoop
(
nsIEventTarget
*
aSyncLoopTarget
)
{
MOZ_ASSERT
(
aSyncLoopTarget
)
;
EventTarget
*
workerTarget
;
nsresult
rv
=
aSyncLoopTarget
-
>
QueryInterface
(
kDEBUGWorkerEventTargetIID
reinterpret_cast
<
void
*
*
>
(
&
workerTarget
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
workerTarget
)
;
bool
valid
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
for
(
uint32_t
index
=
0
;
index
<
mSyncLoopStack
.
Length
(
)
;
index
+
+
)
{
nsAutoPtr
<
SyncLoopInfo
>
&
loopInfo
=
mSyncLoopStack
[
index
]
;
MOZ_ASSERT
(
loopInfo
)
;
MOZ_ASSERT
(
loopInfo
-
>
mEventTarget
)
;
if
(
loopInfo
-
>
mEventTarget
=
=
aSyncLoopTarget
)
{
valid
=
true
;
break
;
}
MOZ_ASSERT
(
!
SameCOMIdentity
(
loopInfo
-
>
mEventTarget
aSyncLoopTarget
)
)
;
}
}
MOZ_ASSERT
(
valid
)
;
}
#
endif
void
WorkerPrivate
:
:
PostMessageToParentInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
ErrorResult
&
aRv
)
{
AssertIsOnWorkerThread
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
transferable
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
if
(
aTransferable
.
WasPassed
(
)
)
{
const
Sequence
<
JS
:
:
Value
>
&
realTransferable
=
aTransferable
.
Value
(
)
;
JS
:
:
HandleValueArray
elements
=
JS
:
:
HandleValueArray
:
:
fromMarkedLocation
(
realTransferable
.
Length
(
)
realTransferable
.
Elements
(
)
)
;
JSObject
*
array
=
JS_NewArrayObject
(
aCx
elements
)
;
if
(
!
array
)
{
aRv
=
NS_ERROR_OUT_OF_MEMORY
;
return
;
}
transferable
.
setObject
(
*
array
)
;
}
RefPtr
<
MessageEventRunnable
>
runnable
=
new
MessageEventRunnable
(
this
WorkerRunnable
:
:
ParentThreadUnchangedBusyCount
)
;
UniquePtr
<
AbstractTimelineMarker
>
start
;
UniquePtr
<
AbstractTimelineMarker
>
end
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
!
timelines
-
>
IsEmpty
(
)
;
if
(
isTimelineRecording
)
{
start
=
MakeUnique
<
WorkerTimelineMarker
>
(
NS_IsMainThread
(
)
?
ProfileTimelineWorkerOperationType
:
:
SerializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
SerializeDataOffMainThread
MarkerTracingType
:
:
START
)
;
}
runnable
-
>
Write
(
aCx
aMessage
transferable
aRv
)
;
if
(
isTimelineRecording
)
{
end
=
MakeUnique
<
WorkerTimelineMarker
>
(
NS_IsMainThread
(
)
?
ProfileTimelineWorkerOperationType
:
:
SerializeDataOnMainThread
:
ProfileTimelineWorkerOperationType
:
:
SerializeDataOffMainThread
MarkerTracingType
:
:
END
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
start
)
;
timelines
-
>
AddMarkerForAllObservedDocShells
(
end
)
;
}
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
aRv
=
NS_ERROR_FAILURE
;
}
}
void
WorkerPrivate
:
:
EnterDebuggerEventLoop
(
)
{
AssertIsOnWorkerThread
(
)
;
JSContext
*
cx
=
GetJSContext
(
)
;
MOZ_ASSERT
(
cx
)
;
uint32_t
currentEventLoopLevel
=
+
+
mDebuggerEventLoopLevel
;
while
(
currentEventLoopLevel
<
=
mDebuggerEventLoopLevel
)
{
bool
debuggerRunnablesPending
=
false
;
{
MutexAutoLock
lock
(
mMutex
)
;
debuggerRunnablesPending
=
!
mDebuggerQueue
.
IsEmpty
(
)
;
}
if
(
!
debuggerRunnablesPending
)
{
SetGCTimerMode
(
IdleTimer
)
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
while
(
mControlQueue
.
IsEmpty
(
)
&
&
!
(
debuggerRunnablesPending
=
!
mDebuggerQueue
.
IsEmpty
(
)
)
)
{
WaitForWorkerEvents
(
)
;
}
ProcessAllControlRunnablesLocked
(
)
;
}
if
(
debuggerRunnablesPending
)
{
SetGCTimerMode
(
PeriodicTimer
)
;
WorkerRunnable
*
runnable
;
{
MutexAutoLock
lock
(
mMutex
)
;
mDebuggerQueue
.
Pop
(
runnable
)
;
}
MOZ_ASSERT
(
runnable
)
;
static_cast
<
nsIRunnable
*
>
(
runnable
)
-
>
Run
(
)
;
runnable
-
>
Release
(
)
;
if
(
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
{
JS_MaybeGC
(
cx
)
;
}
}
}
}
void
WorkerPrivate
:
:
LeaveDebuggerEventLoop
(
)
{
AssertIsOnWorkerThread
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
mDebuggerEventLoopLevel
>
0
)
{
-
-
mDebuggerEventLoopLevel
;
}
}
void
WorkerPrivate
:
:
PostMessageToDebugger
(
const
nsAString
&
aMessage
)
{
mDebugger
-
>
PostMessageToDebugger
(
aMessage
)
;
}
void
WorkerPrivate
:
:
SetDebuggerImmediate
(
JSContext
*
aCx
dom
:
:
Function
&
aHandler
ErrorResult
&
aRv
)
{
AssertIsOnWorkerThread
(
)
;
RefPtr
<
DebuggerImmediateRunnable
>
runnable
=
new
DebuggerImmediateRunnable
(
this
aHandler
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
void
WorkerPrivate
:
:
ReportErrorToDebugger
(
const
nsAString
&
aFilename
uint32_t
aLineno
const
nsAString
&
aMessage
)
{
mDebugger
-
>
ReportErrorToDebugger
(
aFilename
aLineno
aMessage
)
;
}
bool
WorkerPrivate
:
:
NotifyInternal
(
JSContext
*
aCx
Status
aStatus
)
{
AssertIsOnWorkerThread
(
)
;
NS_ASSERTION
(
aStatus
>
Running
&
&
aStatus
<
Dead
"
Bad
status
!
"
)
;
RefPtr
<
EventTarget
>
eventTarget
;
Status
previousStatus
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mStatus
>
=
aStatus
)
{
MOZ_ASSERT
(
!
mEventTarget
)
;
return
true
;
}
previousStatus
=
mStatus
;
mStatus
=
aStatus
;
mEventTarget
.
swap
(
eventTarget
)
;
}
if
(
eventTarget
)
{
eventTarget
-
>
Disable
(
)
;
eventTarget
=
nullptr
;
}
if
(
mCrossThreadDispatcher
)
{
mCrossThreadDispatcher
-
>
Forget
(
)
;
mCrossThreadDispatcher
=
nullptr
;
}
MOZ_ASSERT
(
previousStatus
!
=
Pending
)
;
MOZ_ASSERT
(
previousStatus
>
=
Canceling
|
|
mKillTime
.
IsNull
(
)
)
;
NotifyFeatures
(
aCx
aStatus
)
;
if
(
previousStatus
=
=
Running
)
{
if
(
mSyncLoopStack
.
Length
(
)
)
{
mPendingEventQueueClearing
=
true
;
}
else
{
ClearMainEventQueue
(
WorkerRan
)
;
}
}
if
(
mCloseHandlerFinished
)
{
return
true
;
}
if
(
!
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
{
mCloseHandlerStarted
=
true
;
mCloseHandlerFinished
=
true
;
return
true
;
}
if
(
previousStatus
=
=
Running
&
&
aStatus
!
=
Killing
)
{
MOZ_ASSERT
(
!
mCloseHandlerStarted
&
&
!
mCloseHandlerFinished
)
;
RefPtr
<
CloseEventRunnable
>
closeRunnable
=
new
CloseEventRunnable
(
this
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToCurrentThread
(
closeRunnable
)
)
)
;
}
if
(
aStatus
=
=
Closing
)
{
RefPtr
<
CloseRunnable
>
runnable
=
new
CloseRunnable
(
this
)
;
if
(
!
runnable
-
>
Dispatch
(
aCx
)
)
{
return
false
;
}
return
true
;
}
if
(
aStatus
=
=
Terminating
)
{
return
mCloseHandlerStarted
;
}
if
(
aStatus
=
=
Canceling
)
{
MOZ_ASSERT
(
previousStatus
>
=
Running
&
&
previousStatus
<
=
Terminating
)
;
uint32_t
killSeconds
=
IsChromeWorker
(
)
?
RuntimeService
:
:
GetChromeCloseHandlerTimeoutSeconds
(
)
:
RuntimeService
:
:
GetContentCloseHandlerTimeoutSeconds
(
)
;
if
(
killSeconds
)
{
mKillTime
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromSeconds
(
killSeconds
)
;
if
(
!
mCloseHandlerFinished
&
&
!
ScheduleKillCloseEventRunnable
(
aCx
)
)
{
return
false
;
}
}
return
mCloseHandlerStarted
;
}
MOZ_ASSERT
(
aStatus
=
=
Killing
)
;
mKillTime
=
TimeStamp
:
:
Now
(
)
;
if
(
mCloseHandlerStarted
&
&
!
mCloseHandlerFinished
)
{
ScheduleKillCloseEventRunnable
(
aCx
)
;
}
return
false
;
}
bool
WorkerPrivate
:
:
ScheduleKillCloseEventRunnable
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mKillTime
.
IsNull
(
)
)
;
RefPtr
<
KillCloseEventRunnable
>
killCloseEventRunnable
=
new
KillCloseEventRunnable
(
this
)
;
if
(
!
killCloseEventRunnable
-
>
SetTimeout
(
aCx
RemainingRunTimeMS
(
)
)
)
{
return
false
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToCurrentThread
(
killCloseEventRunnable
)
)
)
;
return
true
;
}
void
WorkerPrivate
:
:
ReportError
(
JSContext
*
aCx
const
char
*
aMessage
JSErrorReport
*
aReport
)
{
AssertIsOnWorkerThread
(
)
;
if
(
!
MayContinueRunning
(
)
|
|
mErrorHandlerRecursionCount
=
=
2
)
{
return
;
}
NS_ASSERTION
(
mErrorHandlerRecursionCount
=
=
0
|
|
mErrorHandlerRecursionCount
=
=
1
"
Bad
recursion
logic
!
"
)
;
JS_ClearPendingException
(
aCx
)
;
nsString
message
filename
line
;
uint32_t
lineNumber
columnNumber
flags
errorNumber
;
JSExnType
exnType
=
JSEXN_ERR
;
bool
mutedError
=
aReport
&
&
aReport
-
>
isMuted
;
if
(
aReport
)
{
JS
:
:
Rooted
<
JSString
*
>
messageStr
(
aCx
js
:
:
ErrorReportToString
(
aCx
aReport
)
)
;
if
(
messageStr
)
{
nsAutoJSString
autoStr
;
if
(
autoStr
.
init
(
aCx
messageStr
)
)
{
message
=
autoStr
;
}
}
filename
=
NS_ConvertUTF8toUTF16
(
aReport
-
>
filename
)
;
line
=
aReport
-
>
uclinebuf
;
lineNumber
=
aReport
-
>
lineno
;
columnNumber
=
aReport
-
>
uctokenptr
-
aReport
-
>
uclinebuf
;
flags
=
aReport
-
>
flags
;
errorNumber
=
aReport
-
>
errorNumber
;
MOZ_ASSERT
(
aReport
-
>
exnType
>
=
JSEXN_NONE
&
&
aReport
-
>
exnType
<
JSEXN_LIMIT
)
;
exnType
=
JSExnType
(
aReport
-
>
exnType
)
;
}
else
{
lineNumber
=
columnNumber
=
errorNumber
=
0
;
flags
=
nsIScriptError
:
:
errorFlag
|
nsIScriptError
:
:
exceptionFlag
;
}
if
(
message
.
IsEmpty
(
)
)
{
message
=
NS_ConvertUTF8toUTF16
(
aMessage
)
;
}
mErrorHandlerRecursionCount
+
+
;
bool
fireAtScope
=
mErrorHandlerRecursionCount
=
=
1
&
&
!
mCloseHandlerStarted
&
&
errorNumber
!
=
JSMSG_OUT_OF_MEMORY
&
&
JS
:
:
CurrentGlobalOrNull
(
aCx
)
;
if
(
!
ReportErrorRunnable
:
:
ReportError
(
aCx
this
fireAtScope
nullptr
message
filename
line
lineNumber
columnNumber
flags
errorNumber
exnType
mutedError
0
)
)
{
JS_ReportPendingException
(
aCx
)
;
}
mErrorHandlerRecursionCount
-
-
;
}
int32_t
WorkerPrivate
:
:
SetTimeout
(
JSContext
*
aCx
dom
:
:
Function
*
aHandler
const
nsAString
&
aStringHandler
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
bool
aIsInterval
ErrorResult
&
aRv
)
{
AssertIsOnWorkerThread
(
)
;
const
int32_t
timerId
=
mNextTimeoutId
+
+
;
Status
currentStatus
;
{
MutexAutoLock
lock
(
mMutex
)
;
currentStatus
=
mStatus
;
}
if
(
currentStatus
=
=
Closing
)
{
JS_ReportError
(
aCx
"
Cannot
schedule
timeouts
from
the
close
handler
!
"
)
;
}
if
(
currentStatus
>
=
Closing
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
0
;
}
nsAutoPtr
<
TimeoutInfo
>
newInfo
(
new
TimeoutInfo
(
)
)
;
newInfo
-
>
mIsInterval
=
aIsInterval
;
newInfo
-
>
mId
=
timerId
;
if
(
MOZ_UNLIKELY
(
timerId
=
=
INT32_MAX
)
)
{
NS_WARNING
(
"
Timeout
ids
overflowed
!
"
)
;
mNextTimeoutId
=
1
;
}
if
(
aHandler
)
{
newInfo
-
>
mTimeoutCallable
=
JS
:
:
ObjectValue
(
*
aHandler
-
>
Callable
(
)
)
;
}
else
if
(
!
aStringHandler
.
IsEmpty
(
)
)
{
newInfo
-
>
mTimeoutString
=
aStringHandler
;
}
else
{
JS_ReportError
(
aCx
"
Useless
%
s
call
(
missing
quotes
around
argument
?
)
"
aIsInterval
?
"
setInterval
"
:
"
setTimeout
"
)
;
return
0
;
}
aTimeout
=
std
:
:
max
(
0
aTimeout
)
;
newInfo
-
>
mInterval
=
TimeDuration
:
:
FromMilliseconds
(
aTimeout
)
;
uint32_t
argc
=
aArguments
.
Length
(
)
;
if
(
argc
&
&
!
newInfo
-
>
mTimeoutCallable
.
isUndefined
(
)
)
{
nsTArray
<
JS
:
:
Heap
<
JS
:
:
Value
>
>
extraArgVals
(
argc
)
;
for
(
uint32_t
index
=
0
;
index
<
argc
;
index
+
+
)
{
extraArgVals
.
AppendElement
(
aArguments
[
index
]
)
;
}
newInfo
-
>
mExtraArgVals
.
SwapElements
(
extraArgVals
)
;
}
newInfo
-
>
mTargetTime
=
TimeStamp
:
:
Now
(
)
+
newInfo
-
>
mInterval
;
if
(
!
newInfo
-
>
mTimeoutString
.
IsEmpty
(
)
)
{
if
(
!
nsJSUtils
:
:
GetCallingLocation
(
aCx
newInfo
-
>
mFilename
&
newInfo
-
>
mLineNumber
)
)
{
NS_WARNING
(
"
Failed
to
get
calling
location
!
"
)
;
}
}
nsAutoPtr
<
TimeoutInfo
>
*
insertedInfo
=
mTimeouts
.
InsertElementSorted
(
newInfo
.
forget
(
)
GetAutoPtrComparator
(
mTimeouts
)
)
;
LOG
(
TimeoutsLog
(
)
(
"
Worker
%
p
has
new
timeout
:
delay
=
%
d
interval
=
%
s
\
n
"
this
aTimeout
aIsInterval
?
"
yes
"
:
"
no
"
)
)
;
if
(
insertedInfo
=
=
mTimeouts
.
Elements
(
)
&
&
!
mRunningExpiredTimeouts
)
{
nsresult
rv
;
if
(
!
mTimer
)
{
mTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
0
;
}
mTimerRunnable
=
new
TimerRunnable
(
this
)
;
}
if
(
!
mTimerRunning
)
{
if
(
!
ModifyBusyCountFromWorker
(
aCx
true
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
0
;
}
mTimerRunning
=
true
;
}
if
(
!
RescheduleTimeoutTimer
(
aCx
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
0
;
}
}
return
timerId
;
}
void
WorkerPrivate
:
:
ClearTimeout
(
int32_t
aId
)
{
AssertIsOnWorkerThread
(
)
;
if
(
!
mTimeouts
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
mTimerRunning
"
Huh
?
!
"
)
;
for
(
uint32_t
index
=
0
;
index
<
mTimeouts
.
Length
(
)
;
index
+
+
)
{
nsAutoPtr
<
TimeoutInfo
>
&
info
=
mTimeouts
[
index
]
;
if
(
info
-
>
mId
=
=
aId
)
{
info
-
>
mCanceled
=
true
;
break
;
}
}
}
}
bool
WorkerPrivate
:
:
RunExpiredTimeouts
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
if
(
mRunningExpiredTimeouts
|
|
!
mTimerRunning
)
{
return
true
;
}
NS_ASSERTION
(
mTimer
&
&
mTimerRunnable
"
Must
have
a
timer
!
"
)
;
NS_ASSERTION
(
!
mTimeouts
.
IsEmpty
(
)
"
Should
have
some
work
to
do
!
"
)
;
bool
retval
=
true
;
AutoPtrComparator
<
TimeoutInfo
>
comparator
=
GetAutoPtrComparator
(
mTimeouts
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
const
TimeStamp
actual_now
=
TimeStamp
:
:
Now
(
)
;
const
TimeStamp
now
=
std
:
:
max
(
actual_now
mTimeouts
[
0
]
-
>
mTargetTime
)
;
if
(
now
!
=
actual_now
)
{
LOG
(
TimeoutsLog
(
)
(
"
Worker
%
p
fudged
timeout
by
%
f
ms
.
\
n
"
this
(
now
-
actual_now
)
.
ToMilliseconds
(
)
)
)
;
}
AutoTArray
<
TimeoutInfo
*
10
>
expiredTimeouts
;
for
(
uint32_t
index
=
0
;
index
<
mTimeouts
.
Length
(
)
;
index
+
+
)
{
nsAutoPtr
<
TimeoutInfo
>
&
info
=
mTimeouts
[
index
]
;
if
(
info
-
>
mTargetTime
>
now
)
{
break
;
}
expiredTimeouts
.
AppendElement
(
info
)
;
}
mRunningExpiredTimeouts
=
true
;
for
(
uint32_t
index
=
0
;
index
<
expiredTimeouts
.
Length
(
)
;
index
+
+
)
{
TimeoutInfo
*
&
info
=
expiredTimeouts
[
index
]
;
if
(
info
-
>
mCanceled
)
{
continue
;
}
LOG
(
TimeoutsLog
(
)
(
"
Worker
%
p
executing
timeout
with
original
delay
%
f
ms
.
\
n
"
this
info
-
>
mInterval
.
ToMilliseconds
(
)
)
)
;
if
(
!
info
-
>
mTimeoutCallable
.
isUndefined
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
aCx
)
;
JS
:
:
HandleValueArray
args
=
JS
:
:
HandleValueArray
:
:
fromMarkedLocation
(
info
-
>
mExtraArgVals
.
Length
(
)
info
-
>
mExtraArgVals
.
Elements
(
)
-
>
address
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
callable
(
aCx
info
-
>
mTimeoutCallable
)
;
if
(
!
JS_CallFunctionValue
(
aCx
global
callable
args
&
rval
)
&
&
!
JS_ReportPendingException
(
aCx
)
)
{
retval
=
false
;
break
;
}
}
else
{
nsString
expression
=
info
-
>
mTimeoutString
;
JS
:
:
CompileOptions
options
(
aCx
)
;
options
.
setFileAndLine
(
info
-
>
mFilename
.
get
(
)
info
-
>
mLineNumber
)
.
setNoScriptRval
(
true
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
unused
(
aCx
)
;
if
(
(
expression
.
IsEmpty
(
)
|
|
!
JS
:
:
Evaluate
(
aCx
options
expression
.
get
(
)
expression
.
Length
(
)
&
unused
)
)
&
&
!
JS_ReportPendingException
(
aCx
)
)
{
retval
=
false
;
break
;
}
}
Promise
:
:
PerformMicroTaskCheckpoint
(
)
;
NS_ASSERTION
(
mRunningExpiredTimeouts
"
Someone
changed
this
!
"
)
;
}
mRunningExpiredTimeouts
=
false
;
for
(
uint32_t
index
=
0
expiredTimeoutIndex
=
0
expiredTimeoutLength
=
expiredTimeouts
.
Length
(
)
;
index
<
mTimeouts
.
Length
(
)
;
)
{
nsAutoPtr
<
TimeoutInfo
>
&
info
=
mTimeouts
[
index
]
;
if
(
(
expiredTimeoutIndex
<
expiredTimeoutLength
&
&
info
=
=
expiredTimeouts
[
expiredTimeoutIndex
]
&
&
+
+
expiredTimeoutIndex
)
|
|
info
-
>
mCanceled
)
{
if
(
info
-
>
mIsInterval
&
&
!
info
-
>
mCanceled
)
{
info
-
>
mTargetTime
=
info
-
>
mTargetTime
+
info
-
>
mInterval
;
+
+
index
;
}
else
{
mTimeouts
.
RemoveElement
(
info
)
;
}
}
else
{
NS_ASSERTION
(
!
expiredTimeouts
.
Contains
(
info
)
"
Our
timeouts
are
out
of
order
!
"
)
;
+
+
index
;
}
}
mTimeouts
.
Sort
(
comparator
)
;
if
(
mTimeouts
.
IsEmpty
(
)
)
{
if
(
!
ModifyBusyCountFromWorker
(
aCx
false
)
)
{
retval
=
false
;
}
mTimerRunning
=
false
;
}
else
if
(
retval
&
&
!
RescheduleTimeoutTimer
(
aCx
)
)
{
retval
=
false
;
}
return
retval
;
}
bool
WorkerPrivate
:
:
RescheduleTimeoutTimer
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mRunningExpiredTimeouts
)
;
NS_ASSERTION
(
!
mTimeouts
.
IsEmpty
(
)
"
Should
have
some
timeouts
!
"
)
;
NS_ASSERTION
(
mTimer
&
&
mTimerRunnable
"
Should
have
a
timer
!
"
)
;
mTimer
-
>
Cancel
(
)
;
double
delta
=
(
mTimeouts
[
0
]
-
>
mTargetTime
-
TimeStamp
:
:
Now
(
)
)
.
ToMilliseconds
(
)
;
uint32_t
delay
=
delta
>
0
?
std
:
:
min
(
delta
double
(
UINT32_MAX
)
)
:
0
;
LOG
(
TimeoutsLog
(
)
(
"
Worker
%
p
scheduled
timer
for
%
d
ms
%
d
pending
timeouts
\
n
"
this
delay
mTimeouts
.
Length
(
)
)
)
;
nsresult
rv
=
mTimer
-
>
InitWithCallback
(
mTimerRunnable
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS_ReportError
(
aCx
"
Failed
to
start
timer
!
"
)
;
return
false
;
}
return
true
;
}
void
WorkerPrivate
:
:
UpdateRuntimeOptionsInternal
(
JSContext
*
aCx
const
JS
:
:
RuntimeOptions
&
aRuntimeOptions
)
{
AssertIsOnWorkerThread
(
)
;
JS
:
:
RuntimeOptionsRef
(
aCx
)
=
aRuntimeOptions
;
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
UpdateRuntimeOptions
(
aCx
aRuntimeOptions
)
;
}
}
void
WorkerPrivate
:
:
UpdateLanguagesInternal
(
JSContext
*
aCx
const
nsTArray
<
nsString
>
&
aLanguages
)
{
WorkerGlobalScope
*
globalScope
=
GlobalScope
(
)
;
if
(
globalScope
)
{
RefPtr
<
WorkerNavigator
>
nav
=
globalScope
-
>
GetExistingNavigator
(
)
;
if
(
nav
)
{
nav
-
>
SetLanguages
(
aLanguages
)
;
}
}
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
UpdateLanguages
(
aCx
aLanguages
)
;
}
}
void
WorkerPrivate
:
:
UpdatePreferenceInternal
(
JSContext
*
aCx
WorkerPreference
aPref
bool
aValue
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aPref
>
=
0
&
&
aPref
<
WORKERPREF_COUNT
)
;
mPreferences
[
aPref
]
=
aValue
;
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
UpdatePreference
(
aCx
aPref
aValue
)
;
}
}
void
WorkerPrivate
:
:
UpdateJSWorkerMemoryParameterInternal
(
JSContext
*
aCx
JSGCParamKey
aKey
uint32_t
aValue
)
{
AssertIsOnWorkerThread
(
)
;
if
(
aValue
)
{
JS_SetGCParameter
(
JS_GetRuntime
(
aCx
)
aKey
aValue
)
;
}
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
UpdateJSWorkerMemoryParameter
(
aCx
aKey
aValue
)
;
}
}
#
ifdef
JS_GC_ZEAL
void
WorkerPrivate
:
:
UpdateGCZealInternal
(
JSContext
*
aCx
uint8_t
aGCZeal
uint32_t
aFrequency
)
{
AssertIsOnWorkerThread
(
)
;
JS_SetGCZeal
(
aCx
aGCZeal
aFrequency
)
;
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
UpdateGCZeal
(
aCx
aGCZeal
aFrequency
)
;
}
}
#
endif
void
WorkerPrivate
:
:
GarbageCollectInternal
(
JSContext
*
aCx
bool
aShrinking
bool
aCollectChildren
)
{
AssertIsOnWorkerThread
(
)
;
if
(
!
GlobalScope
(
)
)
{
return
;
}
if
(
aShrinking
|
|
aCollectChildren
)
{
JSRuntime
*
rt
=
JS_GetRuntime
(
aCx
)
;
JS
:
:
PrepareForFullGC
(
rt
)
;
if
(
aShrinking
)
{
JS
:
:
GCForReason
(
rt
GC_SHRINK
JS
:
:
gcreason
:
:
DOM_WORKER
)
;
if
(
!
aCollectChildren
)
{
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
collected
idle
garbage
\
n
"
this
)
)
;
}
}
else
{
JS
:
:
GCForReason
(
rt
GC_NORMAL
JS
:
:
gcreason
:
:
DOM_WORKER
)
;
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
collected
garbage
\
n
"
this
)
)
;
}
}
else
{
JS_MaybeGC
(
aCx
)
;
LOG
(
WorkerLog
(
)
(
"
Worker
%
p
collected
periodic
garbage
\
n
"
this
)
)
;
}
if
(
aCollectChildren
)
{
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
GarbageCollect
(
aCx
aShrinking
)
;
}
}
}
void
WorkerPrivate
:
:
CycleCollectInternal
(
JSContext
*
aCx
bool
aCollectChildren
)
{
AssertIsOnWorkerThread
(
)
;
nsCycleCollector_collect
(
nullptr
)
;
if
(
aCollectChildren
)
{
for
(
uint32_t
index
=
0
;
index
<
mChildWorkers
.
Length
(
)
;
index
+
+
)
{
mChildWorkers
[
index
]
-
>
CycleCollect
(
aCx
false
)
;
}
}
}
void
WorkerPrivate
:
:
SetThread
(
WorkerThread
*
aThread
)
{
if
(
aThread
)
{
#
ifdef
DEBUG
{
bool
isOnCurrentThread
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aThread
-
>
IsOnCurrentThread
(
&
isOnCurrentThread
)
)
)
;
MOZ_ASSERT
(
isOnCurrentThread
)
;
}
#
endif
MOZ_ASSERT
(
!
mPRThread
)
;
mPRThread
=
PRThreadFromThread
(
aThread
)
;
MOZ_ASSERT
(
mPRThread
)
;
}
else
{
MOZ_ASSERT
(
mPRThread
)
;
}
const
WorkerThreadFriendKey
friendKey
;
RefPtr
<
WorkerThread
>
doomedThread
;
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
aThread
)
{
MOZ_ASSERT
(
!
mThread
)
;
MOZ_ASSERT
(
mStatus
=
=
Pending
)
;
mThread
=
aThread
;
mThread
-
>
SetWorker
(
friendKey
this
)
;
if
(
!
mPreStartRunnables
.
IsEmpty
(
)
)
{
for
(
uint32_t
index
=
0
;
index
<
mPreStartRunnables
.
Length
(
)
;
index
+
+
)
{
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mThread
-
>
DispatchAnyThread
(
friendKey
mPreStartRunnables
[
index
]
.
forget
(
)
)
)
)
;
}
mPreStartRunnables
.
Clear
(
)
;
}
}
else
{
MOZ_ASSERT
(
mThread
)
;
mThread
-
>
SetWorker
(
friendKey
nullptr
)
;
mThread
.
swap
(
doomedThread
)
;
}
}
}
WorkerCrossThreadDispatcher
*
WorkerPrivate
:
:
GetCrossThreadDispatcher
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mCrossThreadDispatcher
&
&
mStatus
<
=
Running
)
{
mCrossThreadDispatcher
=
new
WorkerCrossThreadDispatcher
(
this
)
;
}
return
mCrossThreadDispatcher
;
}
void
WorkerPrivate
:
:
BeginCTypesCall
(
)
{
AssertIsOnWorkerThread
(
)
;
SetGCTimerMode
(
NoTimer
)
;
MutexAutoLock
lock
(
mMutex
)
;
NS_ASSERTION
(
!
mBlockedForMemoryReporter
"
Can
'
t
be
blocked
in
more
than
one
place
at
the
same
time
!
"
)
;
mBlockedForMemoryReporter
=
true
;
mMemoryReportCondVar
.
Notify
(
)
;
}
void
WorkerPrivate
:
:
EndCTypesCall
(
)
{
AssertIsOnWorkerThread
(
)
;
{
MutexAutoLock
lock
(
mMutex
)
;
NS_ASSERTION
(
mBlockedForMemoryReporter
"
Somehow
we
got
unblocked
!
"
)
;
while
(
mMemoryReporterRunning
)
{
mMemoryReportCondVar
.
Wait
(
)
;
}
mBlockedForMemoryReporter
=
false
;
}
SetGCTimerMode
(
PeriodicTimer
)
;
}
bool
WorkerPrivate
:
:
ConnectMessagePort
(
JSContext
*
aCx
MessagePortIdentifier
&
aIdentifier
)
{
AssertIsOnWorkerThread
(
)
;
WorkerGlobalScope
*
globalScope
=
GlobalScope
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
jsGlobal
(
aCx
globalScope
-
>
GetWrapper
(
)
)
;
MOZ_ASSERT
(
jsGlobal
)
;
ErrorResult
rv
;
RefPtr
<
MessagePort
>
port
=
MessagePort
:
:
Create
(
nullptr
aIdentifier
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
false
;
}
GlobalObject
globalObject
(
aCx
jsGlobal
)
;
if
(
globalObject
.
Failed
(
)
)
{
return
false
;
}
RootedDictionary
<
MessageEventInit
>
init
(
aCx
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mSource
.
SetValue
(
)
.
SetAsMessagePort
(
)
=
port
;
RefPtr
<
MessageEvent
>
event
=
MessageEvent
:
:
Constructor
(
globalObject
NS_LITERAL_STRING
(
"
connect
"
)
init
rv
)
;
event
-
>
SetTrusted
(
true
)
;
nsTArray
<
RefPtr
<
MessagePort
>
>
ports
;
ports
.
AppendElement
(
port
)
;
RefPtr
<
MessagePortList
>
portList
=
new
MessagePortList
(
static_cast
<
nsIDOMEventTarget
*
>
(
globalScope
)
ports
)
;
event
-
>
SetPorts
(
portList
)
;
nsCOMPtr
<
nsIDOMEvent
>
domEvent
=
do_QueryObject
(
event
)
;
nsEventStatus
dummy
=
nsEventStatus_eIgnore
;
globalScope
-
>
DispatchDOMEvent
(
nullptr
domEvent
nullptr
&
dummy
)
;
return
true
;
}
WorkerGlobalScope
*
WorkerPrivate
:
:
GetOrCreateGlobalScope
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
if
(
!
mScope
)
{
RefPtr
<
WorkerGlobalScope
>
globalScope
;
if
(
IsSharedWorker
(
)
)
{
globalScope
=
new
SharedWorkerGlobalScope
(
this
WorkerName
(
)
)
;
}
else
if
(
IsServiceWorker
(
)
)
{
globalScope
=
new
ServiceWorkerGlobalScope
(
this
WorkerName
(
)
)
;
}
else
{
globalScope
=
new
DedicatedWorkerGlobalScope
(
this
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
)
;
NS_ENSURE_TRUE
(
globalScope
-
>
WrapGlobalObject
(
aCx
&
global
)
nullptr
)
;
JSAutoCompartment
ac
(
aCx
global
)
;
mScope
=
Move
(
globalScope
)
;
if
(
!
RegisterBindings
(
aCx
global
)
)
{
mScope
=
nullptr
;
return
nullptr
;
}
JS_FireOnNewGlobalObject
(
aCx
global
)
;
}
return
mScope
;
}
WorkerDebuggerGlobalScope
*
WorkerPrivate
:
:
CreateDebuggerGlobalScope
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mDebuggerScope
)
;
RefPtr
<
WorkerDebuggerGlobalScope
>
globalScope
=
new
WorkerDebuggerGlobalScope
(
this
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
)
;
NS_ENSURE_TRUE
(
globalScope
-
>
WrapGlobalObject
(
aCx
&
global
)
nullptr
)
;
JSAutoCompartment
ac
(
aCx
global
)
;
if
(
!
JS_DefineDebuggerObject
(
aCx
global
)
)
{
return
nullptr
;
}
JS_FireOnNewGlobalObject
(
aCx
global
)
;
mDebuggerScope
=
globalScope
.
forget
(
)
;
return
mDebuggerScope
;
}
#
ifdef
DEBUG
void
WorkerPrivate
:
:
AssertIsOnWorkerThread
(
)
const
{
MOZ_ASSERT
(
mPRThread
"
AssertIsOnWorkerThread
(
)
called
before
a
thread
was
assigned
!
"
)
;
MOZ_ASSERT
(
nsThreadManager
:
:
get
(
)
)
;
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
nsThreadManager
:
:
get
(
)
-
>
GetThreadFromPRThread
(
mPRThread
getter_AddRefs
(
thread
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
thread
)
;
bool
current
;
rv
=
thread
-
>
IsOnCurrentThread
(
&
current
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
current
"
Wrong
thread
!
"
)
;
}
#
endif
NS_IMPL_ISUPPORTS_INHERITED0
(
ExternalRunnableWrapper
WorkerRunnable
)
template
<
class
Derived
>
NS_IMPL_ADDREF
(
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
)
template
<
class
Derived
>
NS_IMPL_RELEASE
(
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
)
template
<
class
Derived
>
NS_INTERFACE_MAP_BEGIN
(
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsIEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
#
ifdef
DEBUG
if
(
aIID
.
Equals
(
kDEBUGWorkerEventTargetIID
)
)
{
*
aInstancePtr
=
this
;
return
NS_OK
;
}
else
#
endif
NS_INTERFACE_MAP_END
template
<
class
Derived
>
NS_IMETHODIMP
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aRunnable
)
;
return
Dispatch
(
event
.
forget
(
)
aFlags
)
;
}
template
<
class
Derived
>
NS_IMETHODIMP
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aRunnable
)
;
if
(
NS_WARN_IF
(
aFlags
!
=
NS_DISPATCH_NORMAL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
WorkerRunnable
>
workerRunnable
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWorkerPrivate
)
{
NS_WARNING
(
"
A
runnable
was
posted
to
a
worker
that
is
already
shutting
"
"
down
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
event
)
{
workerRunnable
=
mWorkerPrivate
-
>
MaybeWrapAsWorkerRunnable
(
event
.
forget
(
)
)
;
}
nsresult
rv
=
mWorkerPrivate
-
>
DispatchPrivate
(
workerRunnable
.
forget
(
)
mNestedEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
template
<
class
Derived
>
NS_IMETHODIMP
WorkerPrivateParent
<
Derived
>
:
:
EventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
MOZ_ASSERT
(
aIsOnCurrentThread
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWorkerPrivate
)
{
NS_WARNING
(
"
A
worker
'
s
event
target
was
used
after
the
worker
has
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
mWorkerPrivate
-
>
IsOnCurrentThread
(
aIsOnCurrentThread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
BEGIN_WORKERS_NAMESPACE
WorkerCrossThreadDispatcher
*
GetWorkerCrossThreadDispatcher
(
JSContext
*
aCx
JS
:
:
Value
aWorker
)
{
if
(
!
aWorker
.
isObject
(
)
)
{
return
nullptr
;
}
WorkerPrivate
*
w
=
nullptr
;
UNWRAP_OBJECT
(
Worker
&
aWorker
.
toObject
(
)
w
)
;
MOZ_ASSERT
(
w
)
;
return
w
-
>
GetCrossThreadDispatcher
(
)
;
}
template
class
WorkerPrivateParent
<
WorkerPrivate
>
;
END_WORKERS_NAMESPACE
