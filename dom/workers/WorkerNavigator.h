#
ifndef
mozilla_dom_workernavigator_h__
#
define
mozilla_dom_workernavigator_h__
#
include
"
WorkerCommon
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
StorageManager
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
RuntimeService
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Promise
;
class
StorageManager
;
namespace
network
{
class
Connection
;
}
class
WorkerNavigator
final
:
public
nsWrapperCache
{
typedef
struct
workerinternals
:
:
RuntimeService
:
:
NavigatorProperties
NavigatorProperties
;
NavigatorProperties
mProperties
;
RefPtr
<
StorageManager
>
mStorageManager
;
RefPtr
<
network
:
:
Connection
>
mConnection
;
bool
mOnline
;
WorkerNavigator
(
const
NavigatorProperties
&
aProperties
bool
aOnline
)
;
~
WorkerNavigator
(
)
;
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
WorkerNavigator
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
WorkerNavigator
)
static
already_AddRefed
<
WorkerNavigator
>
Create
(
bool
aOnLine
)
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
nsISupports
*
GetParentObject
(
)
const
{
return
nullptr
;
}
void
GetAppCodeName
(
nsString
&
aAppCodeName
ErrorResult
&
)
const
{
aAppCodeName
.
AssignLiteral
(
"
Mozilla
"
)
;
}
void
GetAppName
(
nsString
&
aAppName
CallerType
aCallerType
)
const
;
void
GetAppVersion
(
nsString
&
aAppVersion
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
void
GetPlatform
(
nsString
&
aPlatform
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
void
GetProduct
(
nsString
&
aProduct
)
const
{
aProduct
.
AssignLiteral
(
"
Gecko
"
)
;
}
bool
TaintEnabled
(
)
const
{
return
false
;
}
void
GetLanguage
(
nsString
&
aLanguage
)
const
{
if
(
mProperties
.
mLanguages
.
Length
(
)
>
=
1
)
{
aLanguage
.
Assign
(
mProperties
.
mLanguages
[
0
]
)
;
}
else
{
aLanguage
.
Truncate
(
)
;
}
}
void
GetLanguages
(
nsTArray
<
nsString
>
&
aLanguages
)
const
{
aLanguages
=
mProperties
.
mLanguages
;
}
void
GetUserAgent
(
nsString
&
aUserAgent
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
bool
OnLine
(
)
const
{
return
mOnline
;
}
void
SetOnLine
(
bool
aOnline
)
{
mOnline
=
aOnline
;
}
void
SetLanguages
(
const
nsTArray
<
nsString
>
&
aLanguages
)
;
uint64_t
HardwareConcurrency
(
)
const
;
StorageManager
*
Storage
(
)
;
network
:
:
Connection
*
GetConnection
(
ErrorResult
&
aRv
)
;
}
;
}
}
#
endif
