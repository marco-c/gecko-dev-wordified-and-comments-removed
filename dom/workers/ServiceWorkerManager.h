#
ifndef
mozilla_dom_workers_serviceworkermanager_h
#
define
mozilla_dom_workers_serviceworkermanager_h
#
include
"
nsIServiceWorkerManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrar
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrarTypes
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsIIPCBackgroundChildCreateCallback
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsTObserverArray
.
h
"
class
mozIApplicationClearPrivateDataParams
;
namespace
mozilla
{
class
PrincipalOriginAttributes
;
namespace
dom
{
class
ServiceWorkerRegistrationListener
;
namespace
workers
{
class
ServiceWorker
;
class
ServiceWorkerClientInfo
;
class
ServiceWorkerInfo
;
class
ServiceWorkerJob
;
class
ServiceWorkerJobQueue
;
class
ServiceWorkerManagerChild
;
class
ServiceWorkerPrivate
;
class
ServiceWorkerRegistrationInfo
final
:
public
nsIServiceWorkerRegistrationInfo
{
uint32_t
mControlledDocumentsCounter
;
enum
{
NoUpdate
NeedTimeCheckAndUpdate
NeedUpdate
}
mUpdateState
;
uint64_t
mLastUpdateCheckTime
;
virtual
~
ServiceWorkerRegistrationInfo
(
)
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
nsCString
mScope
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
RefPtr
<
ServiceWorkerInfo
>
mActiveWorker
;
RefPtr
<
ServiceWorkerInfo
>
mWaitingWorker
;
RefPtr
<
ServiceWorkerInfo
>
mInstallingWorker
;
nsTArray
<
nsCOMPtr
<
nsIServiceWorkerRegistrationInfoListener
>
>
mListeners
;
bool
mUpdating
;
bool
mPendingUninstall
;
ServiceWorkerRegistrationInfo
(
const
nsACString
&
aScope
nsIPrincipal
*
aPrincipal
)
;
already_AddRefed
<
ServiceWorkerInfo
>
Newest
(
)
const
{
RefPtr
<
ServiceWorkerInfo
>
newest
;
if
(
mInstallingWorker
)
{
newest
=
mInstallingWorker
;
}
else
if
(
mWaitingWorker
)
{
newest
=
mWaitingWorker
;
}
else
{
newest
=
mActiveWorker
;
}
return
newest
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorkerInfo
>
GetServiceWorkerInfoById
(
uint64_t
aId
)
;
void
StartControllingADocument
(
)
{
+
+
mControlledDocumentsCounter
;
}
void
StopControllingADocument
(
)
{
MOZ_ASSERT
(
mControlledDocumentsCounter
)
;
-
-
mControlledDocumentsCounter
;
}
bool
IsControllingDocuments
(
)
const
{
return
mActiveWorker
&
&
mControlledDocumentsCounter
;
}
void
Clear
(
)
;
void
PurgeActiveWorker
(
)
;
void
TryToActivate
(
)
;
void
Activate
(
)
;
void
FinishActivate
(
bool
aSuccess
)
;
void
RefreshLastUpdateCheckTime
(
)
;
bool
IsLastUpdateCheckTimeOverOneDay
(
)
const
;
void
NotifyListenersOnChange
(
)
;
void
MaybeScheduleTimeCheckAndUpdate
(
)
;
void
MaybeScheduleUpdate
(
)
;
bool
CheckAndClearIfUpdateNeeded
(
)
;
}
;
class
ServiceWorkerUpdateFinishCallback
{
protected
:
virtual
~
ServiceWorkerUpdateFinishCallback
(
)
{
}
public
:
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerUpdateFinishCallback
)
virtual
void
UpdateSucceeded
(
ServiceWorkerRegistrationInfo
*
aInfo
)
=
0
;
virtual
void
UpdateFailed
(
ErrorResult
&
aStatus
)
=
0
;
}
;
class
ServiceWorkerInfo
final
:
public
nsIServiceWorkerInfo
{
private
:
const
ServiceWorkerRegistrationInfo
*
mRegistration
;
nsCString
mScriptSpec
;
nsString
mCacheName
;
ServiceWorkerState
mState
;
uint64_t
mServiceWorkerID
;
nsAutoTArray
<
ServiceWorker
*
1
>
mInstances
;
RefPtr
<
ServiceWorkerPrivate
>
mServiceWorkerPrivate
;
bool
mSkipWaitingFlag
;
~
ServiceWorkerInfo
(
)
;
uint64_t
GetNextID
(
)
const
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISERVICEWORKERINFO
class
ServiceWorkerPrivate
*
WorkerPrivate
(
)
const
{
MOZ_ASSERT
(
mServiceWorkerPrivate
)
;
return
mServiceWorkerPrivate
;
}
nsIPrincipal
*
GetPrincipal
(
)
const
{
return
mRegistration
-
>
mPrincipal
;
}
const
nsCString
&
ScriptSpec
(
)
const
{
return
mScriptSpec
;
}
const
nsCString
&
Scope
(
)
const
{
return
mRegistration
-
>
mScope
;
}
void
SetScriptSpec
(
const
nsCString
&
aSpec
)
{
MOZ_ASSERT
(
!
aSpec
.
IsEmpty
(
)
)
;
mScriptSpec
=
aSpec
;
}
bool
SkipWaitingFlag
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mSkipWaitingFlag
;
}
void
SetSkipWaitingFlag
(
)
{
AssertIsOnMainThread
(
)
;
mSkipWaitingFlag
=
true
;
}
ServiceWorkerInfo
(
ServiceWorkerRegistrationInfo
*
aReg
const
nsACString
&
aScriptSpec
const
nsAString
&
aCacheName
)
;
ServiceWorkerState
State
(
)
const
{
return
mState
;
}
const
nsString
&
CacheName
(
)
const
{
return
mCacheName
;
}
uint64_t
ID
(
)
const
{
return
mServiceWorkerID
;
}
void
UpdateState
(
ServiceWorkerState
aState
)
;
void
SetActivateStateUncheckedWithoutEvent
(
ServiceWorkerState
aState
)
{
AssertIsOnMainThread
(
)
;
mState
=
aState
;
}
void
AppendWorker
(
ServiceWorker
*
aWorker
)
;
void
RemoveWorker
(
ServiceWorker
*
aWorker
)
;
}
;
#
define
NS_SERVICEWORKERMANAGER_IMPL_IID
\
{
/
*
f4f8755a
-
69ca
-
46e8
-
a65d
-
775745535990
*
/
\
0xf4f8755a
\
0x69ca
\
0x46e8
\
{
0xa6
0x5d
0x77
0x57
0x45
0x53
0x59
0x90
}
\
}
class
ServiceWorkerManager
final
:
public
nsIServiceWorkerManager
public
nsIIPCBackgroundChildCreateCallback
public
nsIObserver
{
friend
class
GetReadyPromiseRunnable
;
friend
class
GetRegistrationsRunnable
;
friend
class
GetRegistrationRunnable
;
friend
class
ServiceWorkerJobQueue
;
friend
class
ServiceWorkerInstallJob
;
friend
class
ServiceWorkerRegisterJob
;
friend
class
ServiceWorkerJobBase
;
friend
class
ServiceWorkerScriptJobBase
;
friend
class
ServiceWorkerRegistrationInfo
;
friend
class
ServiceWorkerUnregisterJob
;
friend
class
UpdateTimerCallback
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISERVICEWORKERMANAGER
NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
NS_DECL_NSIOBSERVER
struct
RegistrationDataPerPrincipal
;
nsClassHashtable
<
nsCStringHashKey
RegistrationDataPerPrincipal
>
mRegistrationInfos
;
nsTObserverArray
<
ServiceWorkerRegistrationListener
*
>
mServiceWorkerRegistrationListeners
;
nsRefPtrHashtable
<
nsISupportsHashKey
ServiceWorkerRegistrationInfo
>
mControlledDocuments
;
nsTHashtable
<
nsISupportsHashKey
>
mAllDocuments
;
typedef
nsTArray
<
nsCOMPtr
<
nsIWeakReference
>
>
WeakDocumentList
;
nsClassHashtable
<
nsCStringHashKey
WeakDocumentList
>
mRegisteringDocuments
;
typedef
nsTArray
<
nsIInterceptedChannel
*
>
InterceptionList
;
nsClassHashtable
<
nsCStringHashKey
InterceptionList
>
mNavigationInterceptions
;
bool
IsAvailable
(
const
PrincipalOriginAttributes
&
aOriginAttributes
nsIURI
*
aURI
)
;
bool
IsControlled
(
nsIDocument
*
aDocument
ErrorResult
&
aRv
)
;
void
DispatchFetchEvent
(
const
PrincipalOriginAttributes
&
aOriginAttributes
nsIDocument
*
aDoc
const
nsAString
&
aDocumentIdForTopLevelNavigation
nsIInterceptedChannel
*
aChannel
bool
aIsReload
bool
aIsSubresourceLoad
ErrorResult
&
aRv
)
;
void
Update
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
ServiceWorkerUpdateFinishCallback
*
aCallback
)
;
void
SoftUpdate
(
const
PrincipalOriginAttributes
&
aOriginAttributes
const
nsACString
&
aScope
)
;
void
PropagateSoftUpdate
(
const
PrincipalOriginAttributes
&
aOriginAttributes
const
nsAString
&
aScope
)
;
void
PropagateRemove
(
const
nsACString
&
aHost
)
;
void
Remove
(
const
nsACString
&
aHost
)
;
void
PropagateRemoveAll
(
)
;
void
RemoveAll
(
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetRegistration
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
)
const
;
ServiceWorkerRegistrationInfo
*
CreateNewRegistration
(
const
nsCString
&
aScope
nsIPrincipal
*
aPrincipal
)
;
void
RemoveRegistration
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
StoreRegistration
(
nsIPrincipal
*
aPrincipal
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
FinishFetch
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
ReportToAllClients
(
const
nsCString
&
aScope
const
nsString
&
aMessage
const
nsString
&
aFilename
const
nsString
&
aLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
)
;
void
HandleError
(
JSContext
*
aCx
nsIPrincipal
*
aPrincipal
const
nsCString
&
aScope
const
nsString
&
aWorkerURL
const
nsString
&
aMessage
const
nsString
&
aFilename
const
nsString
&
aLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
JSExnType
aExnType
)
;
UniquePtr
<
ServiceWorkerClientInfo
>
GetClient
(
nsIPrincipal
*
aPrincipal
const
nsAString
&
aClientId
ErrorResult
&
aRv
)
;
void
GetAllClients
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aScope
bool
aIncludeUncontrolled
nsTArray
<
ServiceWorkerClientInfo
>
&
aDocuments
)
;
void
MaybeClaimClient
(
nsIDocument
*
aDocument
ServiceWorkerRegistrationInfo
*
aWorkerRegistration
)
;
nsresult
ClaimClients
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aScope
uint64_t
aId
)
;
nsresult
SetSkipWaitingFlag
(
nsIPrincipal
*
aPrincipal
const
nsCString
&
aScope
uint64_t
aServiceWorkerID
)
;
static
already_AddRefed
<
ServiceWorkerManager
>
GetInstance
(
)
;
void
LoadRegistration
(
const
ServiceWorkerRegistrationData
&
aRegistration
)
;
void
LoadRegistrations
(
const
nsTArray
<
ServiceWorkerRegistrationData
>
&
aRegistrations
)
;
void
ForceUnregister
(
RegistrationDataPerPrincipal
*
aRegistrationData
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
NS_IMETHOD
AddRegistrationEventListener
(
const
nsAString
&
aScope
ServiceWorkerRegistrationListener
*
aListener
)
;
NS_IMETHOD
RemoveRegistrationEventListener
(
const
nsAString
&
aScope
ServiceWorkerRegistrationListener
*
aListener
)
;
void
MaybeCheckNavigationUpdate
(
nsIDocument
*
aDoc
)
;
nsresult
SendPushEvent
(
const
nsACString
&
aOriginAttributes
const
nsACString
&
aScope
Maybe
<
nsTArray
<
uint8_t
>
>
aData
)
;
private
:
ServiceWorkerManager
(
)
;
~
ServiceWorkerManager
(
)
;
void
Init
(
)
;
ServiceWorkerJobQueue
*
GetOrCreateJobQueue
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aScope
)
;
void
MaybeRemoveRegistrationInfo
(
const
nsACString
&
aScopeKey
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetRegistration
(
const
nsACString
&
aScopeKey
const
nsACString
&
aScope
)
const
;
void
AbortCurrentUpdate
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
nsresult
Update
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
nsresult
GetDocumentRegistration
(
nsIDocument
*
aDoc
ServiceWorkerRegistrationInfo
*
*
aRegistrationInfo
)
;
nsresult
GetServiceWorkerForScope
(
nsPIDOMWindowInner
*
aWindow
const
nsAString
&
aScope
WhichServiceWorker
aWhichWorker
nsISupports
*
*
aServiceWorker
)
;
ServiceWorkerInfo
*
GetActiveWorkerInfoForScope
(
const
PrincipalOriginAttributes
&
aOriginAttributes
const
nsACString
&
aScope
)
;
ServiceWorkerInfo
*
GetActiveWorkerInfoForDocument
(
nsIDocument
*
aDocument
)
;
void
InvalidateServiceWorkerRegistrationWorker
(
ServiceWorkerRegistrationInfo
*
aRegistration
WhichServiceWorker
aWhichOnes
)
;
void
NotifyServiceWorkerRegistrationRemoved
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
StartControllingADocument
(
ServiceWorkerRegistrationInfo
*
aRegistration
nsIDocument
*
aDoc
const
nsAString
&
aDocumentId
)
;
void
StopControllingADocument
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetServiceWorkerRegistrationInfo
(
nsPIDOMWindowInner
*
aWindow
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetServiceWorkerRegistrationInfo
(
nsIDocument
*
aDoc
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetServiceWorkerRegistrationInfo
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetServiceWorkerRegistrationInfo
(
const
PrincipalOriginAttributes
&
aOriginAttributes
nsIURI
*
aURI
)
;
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
GetServiceWorkerRegistrationInfo
(
const
nsACString
&
aScopeKey
nsIURI
*
aURI
)
;
static
nsresult
PrincipalToScopeKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
;
static
void
AddScopeAndRegistration
(
const
nsACString
&
aScope
ServiceWorkerRegistrationInfo
*
aRegistation
)
;
static
bool
FindScopeForPath
(
const
nsACString
&
aScopeKey
const
nsACString
&
aPath
RegistrationDataPerPrincipal
*
*
aData
nsACString
&
aMatch
)
;
static
bool
HasScope
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
)
;
static
void
RemoveScopeAndRegistration
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
QueueFireEventOnServiceWorkerRegistrations
(
ServiceWorkerRegistrationInfo
*
aRegistration
const
nsAString
&
aName
)
;
void
FireUpdateFoundOnServiceWorkerRegistrations
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
FireControllerChange
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
StorePendingReadyPromise
(
nsPIDOMWindowInner
*
aWindow
nsIURI
*
aURI
Promise
*
aPromise
)
;
void
CheckPendingReadyPromises
(
)
;
bool
CheckReadyPromise
(
nsPIDOMWindowInner
*
aWindow
nsIURI
*
aURI
Promise
*
aPromise
)
;
struct
PendingReadyPromise
final
{
PendingReadyPromise
(
nsIURI
*
aURI
Promise
*
aPromise
)
:
mURI
(
aURI
)
mPromise
(
aPromise
)
{
}
nsCOMPtr
<
nsIURI
>
mURI
;
RefPtr
<
Promise
>
mPromise
;
}
;
void
AppendPendingOperation
(
nsIRunnable
*
aRunnable
)
;
void
AppendPendingOperation
(
ServiceWorkerJobQueue
*
aQueue
ServiceWorkerJob
*
aJob
)
;
bool
HasBackgroundActor
(
)
const
{
return
!
!
mActor
;
}
nsClassHashtable
<
nsISupportsHashKey
PendingReadyPromise
>
mPendingReadyPromises
;
void
MaybeRemoveRegistration
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
RemoveRegistrationInternal
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
RemoveAllRegistrations
(
OriginAttributesPattern
*
aPattern
)
;
RefPtr
<
ServiceWorkerManagerChild
>
mActor
;
struct
PendingOperation
;
nsTArray
<
PendingOperation
>
mPendingOperations
;
bool
mShuttingDown
;
nsTArray
<
nsCOMPtr
<
nsIServiceWorkerManagerListener
>
>
mListeners
;
void
NotifyListenersOnRegister
(
nsIServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
NotifyListenersOnUnregister
(
nsIServiceWorkerRegistrationInfo
*
aRegistration
)
;
void
AddRegisteringDocument
(
const
nsACString
&
aScope
nsIDocument
*
aDoc
)
;
class
InterceptionReleaseHandle
;
void
AddNavigationInterception
(
const
nsACString
&
aScope
nsIInterceptedChannel
*
aChannel
)
;
void
RemoveNavigationInterception
(
const
nsACString
&
aScope
nsIInterceptedChannel
*
aChannel
)
;
void
ScheduleUpdateTimer
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
)
;
void
UpdateTimerFired
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
)
;
}
;
}
}
}
#
endif
