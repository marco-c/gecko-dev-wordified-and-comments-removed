#
ifndef
mozilla_dom_workers_WorkerCommon_h
#
define
mozilla_dom_workers_WorkerCommon_h
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
<
stdint
.
h
>
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
mozilla
/
dom
/
ChannelInfo
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
define
BEGIN_WORKERS_NAMESPACE
\
namespace
mozilla
{
namespace
dom
{
namespace
workers
{
#
define
END_WORKERS_NAMESPACE
\
}
/
*
namespace
workers
*
/
}
/
*
namespace
dom
*
/
}
/
*
namespace
mozilla
*
/
#
define
USING_WORKERS_NAMESPACE
\
using
namespace
mozilla
:
:
dom
:
:
workers
;
#
define
WORKERS_SHUTDOWN_TOPIC
"
web
-
workers
-
shutdown
"
class
nsIGlobalObject
;
class
nsPIDOMWindowInner
;
namespace
mozilla
{
namespace
dom
{
enum
WorkerType
{
WorkerTypeDedicated
WorkerTypeShared
WorkerTypeService
}
;
}
}
BEGIN_WORKERS_NAMESPACE
class
WorkerPrivate
;
struct
PrivatizableBase
{
}
;
#
ifdef
DEBUG
void
AssertIsOnMainThread
(
)
;
#
else
inline
void
AssertIsOnMainThread
(
)
{
}
#
endif
struct
JSSettings
{
enum
{
JSSettings_JSGC_MAX_BYTES
=
0
JSSettings_JSGC_MAX_MALLOC_BYTES
JSSettings_JSGC_HIGH_FREQUENCY_TIME_LIMIT
JSSettings_JSGC_LOW_FREQUENCY_HEAP_GROWTH
JSSettings_JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN
JSSettings_JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX
JSSettings_JSGC_HIGH_FREQUENCY_LOW_LIMIT
JSSettings_JSGC_HIGH_FREQUENCY_HIGH_LIMIT
JSSettings_JSGC_ALLOCATION_THRESHOLD
JSSettings_JSGC_SLICE_TIME_BUDGET
JSSettings_JSGC_DYNAMIC_HEAP_GROWTH
JSSettings_JSGC_DYNAMIC_MARK_SLICE
kGCSettingsArraySize
}
;
struct
JSGCSetting
{
mozilla
:
:
Maybe
<
JSGCParamKey
>
key
;
uint32_t
value
;
JSGCSetting
(
)
:
key
(
)
value
(
0
)
{
}
}
;
typedef
JSGCSetting
JSGCSettingsArray
[
kGCSettingsArraySize
]
;
struct
JSContentChromeSettings
{
JS
:
:
CompartmentOptions
compartmentOptions
;
int32_t
maxScriptRuntime
;
JSContentChromeSettings
(
)
:
compartmentOptions
(
)
maxScriptRuntime
(
0
)
{
}
}
;
JSContentChromeSettings
chrome
;
JSContentChromeSettings
content
;
JSGCSettingsArray
gcSettings
;
JS
:
:
ContextOptions
contextOptions
;
#
ifdef
JS_GC_ZEAL
uint8_t
gcZeal
;
uint32_t
gcZealFrequency
;
#
endif
JSSettings
(
)
#
ifdef
JS_GC_ZEAL
:
gcZeal
(
0
)
gcZealFrequency
(
0
)
#
endif
{
for
(
uint32_t
index
=
0
;
index
<
ArrayLength
(
gcSettings
)
;
index
+
+
)
{
new
(
gcSettings
+
index
)
JSGCSetting
(
)
;
}
}
bool
ApplyGCSetting
(
JSGCParamKey
aKey
uint32_t
aValue
)
{
JSSettings
:
:
JSGCSetting
*
firstEmptySetting
=
nullptr
;
JSSettings
:
:
JSGCSetting
*
foundSetting
=
nullptr
;
for
(
uint32_t
index
=
0
;
index
<
ArrayLength
(
gcSettings
)
;
index
+
+
)
{
JSSettings
:
:
JSGCSetting
&
setting
=
gcSettings
[
index
]
;
if
(
setting
.
key
.
isSome
(
)
&
&
*
setting
.
key
=
=
aKey
)
{
foundSetting
=
&
setting
;
break
;
}
if
(
!
firstEmptySetting
&
&
setting
.
key
.
isNothing
(
)
)
{
firstEmptySetting
=
&
setting
;
}
}
if
(
aValue
)
{
if
(
!
foundSetting
)
{
foundSetting
=
firstEmptySetting
;
if
(
!
foundSetting
)
{
NS_ERROR
(
"
Not
enough
space
for
this
value
!
"
)
;
return
false
;
}
}
foundSetting
-
>
key
=
mozilla
:
:
Some
(
aKey
)
;
foundSetting
-
>
value
=
aValue
;
return
true
;
}
if
(
foundSetting
)
{
foundSetting
-
>
key
.
reset
(
)
;
return
true
;
}
return
false
;
}
}
;
void
CancelWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
;
void
FreezeWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
;
void
ThawWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
;
void
SuspendWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
;
void
ResumeWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
;
class
WorkerTask
{
protected
:
WorkerTask
(
)
{
}
virtual
~
WorkerTask
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WorkerTask
)
virtual
bool
RunTask
(
JSContext
*
aCx
)
=
0
;
}
;
class
WorkerCrossThreadDispatcher
{
friend
class
WorkerPrivate
;
Mutex
mMutex
;
WorkerPrivate
*
mWorkerPrivate
;
private
:
explicit
WorkerCrossThreadDispatcher
(
WorkerPrivate
*
aWorkerPrivate
)
;
void
Forget
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
mWorkerPrivate
=
nullptr
;
}
~
WorkerCrossThreadDispatcher
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WorkerCrossThreadDispatcher
)
bool
PostTask
(
WorkerTask
*
aTask
)
;
}
;
const
uint32_t
kJSPrincipalsDebugToken
=
0x7e2df9d2
;
bool
IsWorkerGlobal
(
JSObject
*
global
)
;
bool
IsDebuggerGlobal
(
JSObject
*
global
)
;
bool
IsDebuggerSandbox
(
JSObject
*
object
)
;
END_WORKERS_NAMESPACE
#
endif
