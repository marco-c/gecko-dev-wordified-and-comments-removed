#
include
"
WorkerEventTarget
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
mozilla
/
dom
/
ReferrerInfo
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
WrappedControlRunnable
final
:
public
WorkerControlRunnable
{
nsCOMPtr
<
nsIRunnable
>
mInner
;
~
WrappedControlRunnable
(
)
=
default
;
public
:
WrappedControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIRunnable
>
&
&
aInner
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mInner
(
std
:
:
move
(
aInner
)
)
{
}
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mInner
-
>
Run
(
)
;
return
true
;
}
nsresult
Cancel
(
)
override
{
nsCOMPtr
<
nsICancelableRunnable
>
cr
=
do_QueryInterface
(
mInner
)
;
if
(
!
cr
)
{
WorkerControlRunnable
:
:
Cancel
(
)
;
return
NS_OK
;
}
Unused
<
<
cr
-
>
Cancel
(
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
}
;
}
NS_IMPL_ISUPPORTS
(
WorkerEventTarget
nsIEventTarget
nsISerialEventTarget
)
WorkerEventTarget
:
:
WorkerEventTarget
(
WorkerPrivate
*
aWorkerPrivate
Behavior
aBehavior
)
:
mMutex
(
"
WorkerEventTarget
"
)
mWorkerPrivate
(
aWorkerPrivate
)
mBehavior
(
aBehavior
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWorkerPrivate
)
;
}
void
WorkerEventTarget
:
:
ForgetWorkerPrivate
(
WorkerPrivate
*
aWorkerPrivate
)
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWorkerPrivate
|
|
mWorkerPrivate
=
=
aWorkerPrivate
)
;
mWorkerPrivate
=
nullptr
;
}
NS_IMETHODIMP
WorkerEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
Dispatch
(
runnable
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
WorkerEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWorkerPrivate
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mBehavior
=
=
Behavior
:
:
Hybrid
)
{
RefPtr
<
WorkerRunnable
>
r
=
mWorkerPrivate
-
>
MaybeWrapAsWorkerRunnable
(
runnable
.
forget
(
)
)
;
if
(
r
-
>
Dispatch
(
)
)
{
return
NS_OK
;
}
runnable
=
std
:
:
move
(
r
)
;
}
RefPtr
<
WorkerControlRunnable
>
r
=
new
WrappedControlRunnable
(
mWorkerPrivate
std
:
:
move
(
runnable
)
)
;
if
(
!
r
-
>
Dispatch
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WorkerEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WorkerEventTarget
:
:
RegisterShutdownTask
(
nsITargetShutdownTask
*
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
WorkerEventTarget
:
:
UnregisterShutdownTask
(
nsITargetShutdownTask
*
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP_
(
bool
)
WorkerEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWorkerPrivate
)
{
return
false
;
}
return
mWorkerPrivate
-
>
IsOnCurrentThread
(
)
;
}
NS_IMETHODIMP
WorkerEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
MOZ_ASSERT
(
aIsOnCurrentThread
)
;
*
aIsOnCurrentThread
=
IsOnCurrentThreadInfallible
(
)
;
return
NS_OK
;
}
}
}
