#
include
"
SharedWorkerService
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
{
StaticMutex
sSharedWorkerMutex
;
SharedWorkerService
*
MOZ_NON_OWNING_REF
sSharedWorkerService
;
class
GetOrCreateWorkerManagerRunnable
final
:
public
Runnable
{
public
:
GetOrCreateWorkerManagerRunnable
(
SharedWorkerParent
*
aActor
const
SharedWorkerLoadInfo
&
aInfo
)
:
Runnable
(
"
GetOrCreateWorkerManagerRunnable
"
)
mBackgroundEventTarget
(
GetCurrentThreadEventTarget
(
)
)
mActor
(
aActor
)
mInfo
(
aInfo
)
{
}
NS_IMETHOD
Run
(
)
{
SharedWorkerService
*
service
=
SharedWorkerService
:
:
Get
(
)
;
MOZ_ASSERT
(
service
)
;
service
-
>
GetOrCreateWorkerManagerOnMainThread
(
mBackgroundEventTarget
mActor
mInfo
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIEventTarget
>
mBackgroundEventTarget
;
RefPtr
<
SharedWorkerParent
>
mActor
;
SharedWorkerLoadInfo
mInfo
;
}
;
class
RemoveWorkerManagerRunnable
final
:
public
Runnable
{
public
:
RemoveWorkerManagerRunnable
(
SharedWorkerService
*
aService
SharedWorkerManager
*
aManager
)
:
Runnable
(
"
RemoveWorkerManagerRunnable
"
)
mService
(
aService
)
mManager
(
aManager
)
{
MOZ_ASSERT
(
mService
)
;
MOZ_ASSERT
(
mManager
)
;
}
NS_IMETHOD
Run
(
)
{
mService
-
>
RemoveWorkerManagerOnMainThread
(
mManager
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SharedWorkerService
>
mService
;
RefPtr
<
SharedWorkerManager
>
mManager
;
}
;
class
WorkerManagerCreatedRunnable
final
:
public
Runnable
{
public
:
WorkerManagerCreatedRunnable
(
SharedWorkerManager
*
aManager
SharedWorkerParent
*
aActor
)
:
Runnable
(
"
WorkerManagerCreatedRunnable
"
)
mManager
(
aManager
)
mActor
(
aActor
)
{
}
NS_IMETHOD
Run
(
)
{
AssertIsOnBackgroundThread
(
)
;
mManager
-
>
AddActor
(
mActor
)
;
mActor
-
>
ManagerCreated
(
mManager
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SharedWorkerManager
>
mManager
;
RefPtr
<
SharedWorkerParent
>
mActor
;
}
;
class
ErrorPropagationRunnable
final
:
public
Runnable
{
public
:
ErrorPropagationRunnable
(
SharedWorkerParent
*
aActor
nsresult
aError
)
:
Runnable
(
"
ErrorPropagationRunnable
"
)
mActor
(
aActor
)
mError
(
aError
)
{
}
NS_IMETHOD
Run
(
)
{
AssertIsOnBackgroundThread
(
)
;
mActor
-
>
ErrorPropagation
(
mError
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SharedWorkerParent
>
mActor
;
nsresult
mError
;
}
;
}
already_AddRefed
<
SharedWorkerService
>
SharedWorkerService
:
:
GetOrCreate
(
)
{
AssertIsOnBackgroundThread
(
)
;
StaticMutexAutoLock
lock
(
sSharedWorkerMutex
)
;
if
(
sSharedWorkerService
)
{
RefPtr
<
SharedWorkerService
>
instance
=
sSharedWorkerService
;
return
instance
.
forget
(
)
;
}
RefPtr
<
SharedWorkerService
>
instance
=
new
SharedWorkerService
(
)
;
return
instance
.
forget
(
)
;
}
SharedWorkerService
*
SharedWorkerService
:
:
Get
(
)
{
StaticMutexAutoLock
lock
(
sSharedWorkerMutex
)
;
MOZ_ASSERT
(
sSharedWorkerService
)
;
return
sSharedWorkerService
;
}
SharedWorkerService
:
:
SharedWorkerService
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
sSharedWorkerService
)
;
sSharedWorkerService
=
this
;
}
SharedWorkerService
:
:
~
SharedWorkerService
(
)
{
StaticMutexAutoLock
lock
(
sSharedWorkerMutex
)
;
MOZ_ASSERT
(
sSharedWorkerService
=
=
this
)
;
sSharedWorkerService
=
nullptr
;
}
void
SharedWorkerService
:
:
GetOrCreateWorkerManager
(
SharedWorkerParent
*
aActor
const
SharedWorkerLoadInfo
&
aInfo
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
GetOrCreateWorkerManagerRunnable
>
r
=
new
GetOrCreateWorkerManagerRunnable
(
aActor
aInfo
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
nsresult
rv
=
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
void
SharedWorkerService
:
:
GetOrCreateWorkerManagerOnMainThread
(
nsIEventTarget
*
aBackgroundEventTarget
SharedWorkerParent
*
aActor
const
SharedWorkerLoadInfo
&
aInfo
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aBackgroundEventTarget
)
;
MOZ_ASSERT
(
aActor
)
;
RefPtr
<
SharedWorkerManager
>
manager
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
PrincipalInfoToPrincipal
(
aInfo
.
principalInfo
(
)
&
rv
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
ErrorPropagationOnMainThread
(
aBackgroundEventTarget
aActor
rv
)
;
return
;
}
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
PrincipalInfoToPrincipal
(
aInfo
.
loadingPrincipalInfo
(
)
&
rv
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
ErrorPropagationOnMainThread
(
aBackgroundEventTarget
aActor
rv
)
;
return
;
}
for
(
SharedWorkerManager
*
workerManager
:
mWorkerManagers
)
{
if
(
workerManager
-
>
MatchOnMainThread
(
aInfo
.
domain
(
)
aInfo
.
resolvedScriptURL
(
)
aInfo
.
name
(
)
loadingPrincipal
)
)
{
manager
=
workerManager
;
break
;
}
}
if
(
!
manager
)
{
manager
=
new
SharedWorkerManager
(
aInfo
principal
loadingPrincipal
)
;
rv
=
manager
-
>
CreateWorkerOnMainThread
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagationOnMainThread
(
aBackgroundEventTarget
aActor
rv
)
;
return
;
}
mWorkerManagers
.
AppendElement
(
manager
)
;
}
else
{
if
(
manager
-
>
IsSecureContext
(
)
!
=
aInfo
.
isSecureContext
(
)
)
{
ErrorPropagationOnMainThread
(
aBackgroundEventTarget
aActor
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
}
manager
-
>
ThawOnMainThread
(
)
;
manager
-
>
ConnectPortOnMainThread
(
aInfo
.
portIdentifier
(
)
)
;
RefPtr
<
WorkerManagerCreatedRunnable
>
r
=
new
WorkerManagerCreatedRunnable
(
manager
aActor
)
;
aBackgroundEventTarget
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
SharedWorkerService
:
:
ErrorPropagationOnMainThread
(
nsIEventTarget
*
aBackgroundEventTarget
SharedWorkerParent
*
aActor
nsresult
aError
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aBackgroundEventTarget
)
;
MOZ_ASSERT
(
aActor
)
;
MOZ_ASSERT
(
NS_FAILED
(
aError
)
)
;
RefPtr
<
ErrorPropagationRunnable
>
r
=
new
ErrorPropagationRunnable
(
aActor
aError
)
;
aBackgroundEventTarget
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
SharedWorkerService
:
:
RemoveWorkerManager
(
SharedWorkerManager
*
aManager
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
RemoveWorkerManagerRunnable
>
r
=
new
RemoveWorkerManagerRunnable
(
this
aManager
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
nsresult
rv
=
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
void
SharedWorkerService
:
:
RemoveWorkerManagerOnMainThread
(
SharedWorkerManager
*
aManager
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
mWorkerManagers
.
Contains
(
aManager
)
)
;
mWorkerManagers
.
RemoveElement
(
aManager
)
;
}
}
}
