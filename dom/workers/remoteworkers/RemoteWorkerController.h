#
ifndef
mozilla_dom_RemoteWorkerController_h
#
define
mozilla_dom_RemoteWorkerController_h
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerOpArgs
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerOpPromise
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ErrorValue
;
class
RemoteWorkerControllerParent
;
class
RemoteWorkerData
;
class
RemoteWorkerManager
;
class
RemoteWorkerParent
;
class
RemoteWorkerObserver
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
void
CreationFailed
(
)
=
0
;
virtual
void
CreationSucceeded
(
)
=
0
;
virtual
void
ErrorReceived
(
const
ErrorValue
&
aValue
)
=
0
;
virtual
void
Terminated
(
)
=
0
;
}
;
class
RemoteWorkerController
final
{
friend
class
RemoteWorkerControllerParent
;
friend
class
RemoteWorkerManager
;
friend
class
RemoteWorkerParent
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
RemoteWorkerController
)
static
already_AddRefed
<
RemoteWorkerController
>
Create
(
const
RemoteWorkerData
&
aData
RemoteWorkerObserver
*
aObserver
base
:
:
ProcessId
=
0
)
;
void
AddWindowID
(
uint64_t
aWindowID
)
;
void
RemoveWindowID
(
uint64_t
aWindowID
)
;
void
AddPortIdentifier
(
const
MessagePortIdentifier
&
aPortIdentifier
)
;
void
Terminate
(
)
;
void
Suspend
(
)
;
void
Resume
(
)
;
void
Freeze
(
)
;
void
Thaw
(
)
;
RefPtr
<
ServiceWorkerOpPromise
>
ExecServiceWorkerOp
(
ServiceWorkerOpArgs
&
&
aArgs
)
;
RefPtr
<
GenericPromise
>
SetServiceWorkerSkipWaitingFlag
(
)
const
;
bool
IsTerminated
(
)
const
;
private
:
RemoteWorkerController
(
const
RemoteWorkerData
&
aData
RemoteWorkerObserver
*
aObserver
)
;
~
RemoteWorkerController
(
)
;
void
SetWorkerActor
(
RemoteWorkerParent
*
aActor
)
;
void
NoteDeadWorkerActor
(
)
;
void
ErrorPropagation
(
const
ErrorValue
&
aValue
)
;
void
WorkerTerminated
(
)
;
void
Shutdown
(
)
;
void
CreationFailed
(
)
;
void
CreationSucceeded
(
)
;
void
CancelAllPendingOps
(
)
;
template
<
typename
.
.
.
Args
>
void
MaybeStartSharedWorkerOp
(
Args
&
&
.
.
.
aArgs
)
;
void
NoteDeadWorker
(
)
;
RefPtr
<
RemoteWorkerObserver
>
mObserver
;
RefPtr
<
RemoteWorkerParent
>
mActor
;
enum
{
ePending
eReady
eTerminated
}
mState
;
const
bool
mIsServiceWorker
;
class
PendingOp
{
public
:
PendingOp
(
)
=
default
;
PendingOp
(
const
PendingOp
&
)
=
delete
;
PendingOp
&
operator
=
(
const
PendingOp
&
)
=
delete
;
virtual
~
PendingOp
(
)
=
default
;
virtual
bool
MaybeStart
(
RemoteWorkerController
*
const
aOwner
)
=
0
;
virtual
void
Cancel
(
)
=
0
;
}
;
class
PendingSharedWorkerOp
final
:
public
PendingOp
{
public
:
enum
Type
{
eTerminate
eSuspend
eResume
eFreeze
eThaw
ePortIdentifier
eAddWindowID
eRemoveWindowID
}
;
explicit
PendingSharedWorkerOp
(
Type
aType
uint64_t
aWindowID
=
0
)
;
explicit
PendingSharedWorkerOp
(
const
MessagePortIdentifier
&
aPortIdentifier
)
;
~
PendingSharedWorkerOp
(
)
;
bool
MaybeStart
(
RemoteWorkerController
*
const
aOwner
)
override
;
void
Cancel
(
)
override
;
private
:
const
Type
mType
;
const
MessagePortIdentifier
mPortIdentifier
;
const
uint64_t
mWindowID
=
0
;
bool
mCompleted
=
false
;
}
;
class
PendingServiceWorkerOp
final
:
public
PendingOp
{
public
:
PendingServiceWorkerOp
(
ServiceWorkerOpArgs
&
&
aArgs
RefPtr
<
ServiceWorkerOpPromise
:
:
Private
>
aPromise
)
;
~
PendingServiceWorkerOp
(
)
;
bool
MaybeStart
(
RemoteWorkerController
*
const
aOwner
)
override
;
void
Cancel
(
)
override
;
private
:
ServiceWorkerOpArgs
mArgs
;
RefPtr
<
ServiceWorkerOpPromise
:
:
Private
>
mPromise
;
}
;
nsTArray
<
UniquePtr
<
PendingOp
>
>
mPendingOps
;
}
;
}
}
#
endif
