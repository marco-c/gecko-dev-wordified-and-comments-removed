#
ifndef
mozilla_dom_RemoteWorkerChild_h
#
define
mozilla_dom_RemoteWorkerChild_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ThreadBound
.
h
"
#
include
"
mozilla
/
dom
/
PRemoteWorkerChild
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerOpArgs
.
h
"
class
nsISerialEventTarget
;
class
nsIConsoleReportCollector
;
namespace
mozilla
:
:
dom
{
class
ErrorValue
;
class
FetchEventOpProxyChild
;
class
RemoteWorkerData
;
class
RemoteWorkerServiceKeepAlive
;
class
ServiceWorkerOp
;
class
UniqueMessagePortId
;
class
WeakWorkerRef
;
class
WorkerErrorReport
;
class
WorkerPrivate
;
class
RemoteWorkerChild
final
:
public
PRemoteWorkerChild
{
friend
class
FetchEventOpProxyChild
;
friend
class
PRemoteWorkerChild
;
friend
class
ServiceWorkerOp
;
~
RemoteWorkerChild
(
)
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteWorkerChild
final
)
explicit
RemoteWorkerChild
(
const
RemoteWorkerData
&
aData
)
;
void
ExecWorker
(
const
RemoteWorkerData
&
aData
)
;
void
ErrorPropagationOnMainThread
(
const
WorkerErrorReport
*
aReport
bool
aIsErrorEvent
)
;
void
NotifyLock
(
bool
aCreated
)
;
void
NotifyWebTransport
(
bool
aCreated
)
;
void
FlushReportsOnMainThread
(
nsIConsoleReportCollector
*
aReporter
)
;
void
AddPortIdentifier
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
UniqueMessagePortId
&
aPortIdentifier
)
;
RefPtr
<
GenericNonExclusivePromise
>
GetTerminationPromise
(
)
;
RefPtr
<
GenericPromise
>
MaybeSendSetServiceWorkerSkipWaitingFlag
(
)
;
const
nsTArray
<
uint64_t
>
&
WindowIDs
(
)
const
{
return
mWindowIDs
;
}
private
:
class
InitializeWorkerRunnable
;
class
Op
;
class
SharedWorkerOp
;
struct
WorkerPrivateAccessibleState
{
~
WorkerPrivateAccessibleState
(
)
;
RefPtr
<
WorkerPrivate
>
mWorkerPrivate
;
}
;
struct
Pending
:
WorkerPrivateAccessibleState
{
nsTArray
<
RefPtr
<
Op
>
>
mPendingOps
;
}
;
struct
Running
:
WorkerPrivateAccessibleState
{
}
;
struct
Canceled
{
}
;
struct
Killed
{
}
;
using
State
=
Variant
<
Pending
Running
Canceled
Killed
>
;
DataMutex
<
State
>
mState
;
const
RefPtr
<
RemoteWorkerServiceKeepAlive
>
mServiceKeepAlive
;
class
Op
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
~
Op
(
)
=
default
;
virtual
bool
MaybeStart
(
RemoteWorkerChild
*
aOwner
State
&
aState
)
=
0
;
virtual
void
StartOnMainThread
(
RefPtr
<
RemoteWorkerChild
>
&
aOwner
)
=
0
;
virtual
void
Cancel
(
)
=
0
;
}
;
void
ActorDestroy
(
ActorDestroyReason
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvExecOp
(
RemoteWorkerOp
&
&
aOp
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvExecServiceWorkerOp
(
ServiceWorkerOpArgs
&
&
aArgs
ExecServiceWorkerOpResolver
&
&
aResolve
)
;
already_AddRefed
<
PFetchEventOpProxyChild
>
AllocPFetchEventOpProxyChild
(
const
ParentToChildServiceWorkerFetchEventOpArgs
&
aArgs
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPFetchEventOpProxyConstructor
(
PFetchEventOpProxyChild
*
aActor
const
ParentToChildServiceWorkerFetchEventOpArgs
&
aArgs
)
override
;
nsresult
ExecWorkerOnMainThread
(
RemoteWorkerData
&
&
aData
)
;
void
ExceptionalErrorTransitionDuringExecWorker
(
)
;
void
RequestWorkerCancellation
(
)
;
void
InitializeOnWorker
(
)
;
void
CreationSucceededOnAnyThread
(
)
;
void
CreationFailedOnAnyThread
(
)
;
void
CreationSucceededOrFailedOnAnyThread
(
bool
aDidCreationSucceed
)
;
void
CloseWorkerOnMainThread
(
)
;
void
ErrorPropagation
(
const
ErrorValue
&
aValue
)
;
void
ErrorPropagationDispatch
(
nsresult
aError
)
;
void
OnWorkerCancellationTransitionStateFromPendingOrRunningToCanceled
(
)
;
void
TransitionStateFromPendingToCanceled
(
State
&
aState
)
;
void
TransitionStateFromCanceledToKilled
(
)
;
void
TransitionStateToRunning
(
)
;
void
TransitionStateToTerminated
(
)
;
void
TransitionStateToTerminated
(
State
&
aState
)
;
void
CancelAllPendingOps
(
State
&
aState
)
;
void
MaybeStartOp
(
RefPtr
<
Op
>
&
&
aOp
)
;
const
bool
mIsServiceWorker
;
nsTArray
<
uint64_t
>
mWindowIDs
;
struct
LauncherBoundData
{
MozPromiseHolder
<
GenericNonExclusivePromise
>
mTerminationPromise
;
bool
mDidSendCreated
=
false
;
}
;
ThreadBound
<
LauncherBoundData
>
mLauncherData
;
}
;
}
#
endif
