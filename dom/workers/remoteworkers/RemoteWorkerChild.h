#
ifndef
mozilla_dom_RemoteWorkerChild_h
#
define
mozilla_dom_RemoteWorkerChild_h
#
include
"
mozilla
/
dom
/
PRemoteWorkerChild
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
class
nsIConsoleReportCollector
;
namespace
mozilla
{
namespace
dom
{
class
RemoteWorkerData
;
class
WeakWorkerRef
;
class
WorkerErrorReport
;
class
WorkerPrivate
;
class
OptionalMessagePortIdentifier
;
class
RemoteWorkerChild
final
:
public
PRemoteWorkerChild
{
friend
class
PRemoteWorkerChild
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RemoteWorkerChild
)
RemoteWorkerChild
(
)
;
void
ExecWorker
(
const
RemoteWorkerData
&
aData
)
;
void
InitializeOnWorker
(
WorkerPrivate
*
aWorkerPrivate
)
;
void
ShutdownOnWorker
(
)
;
void
AddPortIdentifier
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
const
MessagePortIdentifier
&
aPortIdentifier
)
;
void
ErrorPropagationOnMainThread
(
const
WorkerErrorReport
*
aReport
bool
aIsErrorEvent
)
;
void
CloseWorkerOnMainThread
(
)
;
void
FlushReportsOnMainThread
(
nsIConsoleReportCollector
*
aReporter
)
;
private
:
class
InitializeWorkerRunnable
;
~
RemoteWorkerChild
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvExecOp
(
const
RemoteWorkerOp
&
aOp
)
override
;
void
RecvExecOpOnMainThread
(
const
RemoteWorkerOp
&
aOp
)
;
nsresult
ExecWorkerOnMainThread
(
const
RemoteWorkerData
&
aData
)
;
void
ErrorPropagation
(
const
ErrorValue
&
aValue
)
;
void
ErrorPropagationDispatch
(
nsresult
aError
)
;
void
CreationSucceededOnAnyThread
(
)
;
void
CreationSucceeded
(
)
;
void
CreationFailedOnAnyThread
(
)
;
void
CreationFailed
(
)
;
void
WorkerTerminated
(
)
;
nsTArray
<
uint64_t
>
mWindowIDs
;
RefPtr
<
WorkerPrivate
>
mWorkerPrivate
;
RefPtr
<
WeakWorkerRef
>
mWorkerRef
;
bool
mIPCActive
;
enum
WorkerState
{
ePending
ePendingTerminated
eRunning
eTerminated
}
;
WorkerState
mWorkerState
;
nsTArray
<
RemoteWorkerOp
>
mPendingOps
;
}
;
}
}
#
endif
