#
include
"
RemoteWorkerManager
.
h
"
#
include
<
utility
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
RemoteWorkerServiceParent
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
{
RemoteWorkerManager
*
sRemoteWorkerManager
;
bool
IsServiceWorker
(
const
RemoteWorkerData
&
aData
)
{
return
aData
.
serviceWorkerData
(
)
.
type
(
)
=
=
OptionalServiceWorkerData
:
:
TServiceWorkerData
;
}
void
TransmitPermissionsForPrincipalInfo
(
ContentParent
*
aContentParent
const
PrincipalInfo
&
aPrincipalInfo
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aContentParent
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
PrincipalInfoToPrincipal
(
aPrincipalInfo
)
;
MOZ_ALWAYS_SUCCEEDS
(
aContentParent
-
>
TransmitPermissionsForPrincipal
(
principal
)
)
;
}
}
already_AddRefed
<
RemoteWorkerManager
>
RemoteWorkerManager
:
:
GetOrCreate
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
if
(
!
sRemoteWorkerManager
)
{
sRemoteWorkerManager
=
new
RemoteWorkerManager
(
)
;
}
RefPtr
<
RemoteWorkerManager
>
rwm
=
sRemoteWorkerManager
;
return
rwm
.
forget
(
)
;
}
RemoteWorkerManager
:
:
RemoteWorkerManager
(
)
:
mParentActor
(
nullptr
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
sRemoteWorkerManager
)
;
}
RemoteWorkerManager
:
:
~
RemoteWorkerManager
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
sRemoteWorkerManager
=
=
this
)
;
sRemoteWorkerManager
=
nullptr
;
}
void
RemoteWorkerManager
:
:
RegisterActor
(
RemoteWorkerServiceParent
*
aActor
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
if
(
!
BackgroundParent
:
:
IsOtherProcessActor
(
aActor
-
>
Manager
(
)
)
)
{
MOZ_ASSERT
(
!
mParentActor
)
;
mParentActor
=
aActor
;
MOZ_ASSERT
(
mPendings
.
IsEmpty
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
mChildActors
.
Contains
(
aActor
)
)
;
mChildActors
.
AppendElement
(
aActor
)
;
if
(
!
mPendings
.
IsEmpty
(
)
)
{
for
(
const
Pending
&
p
:
mPendings
)
{
LaunchInternal
(
p
.
mController
aActor
p
.
mData
)
;
}
mPendings
.
Clear
(
)
;
Release
(
)
;
}
}
void
RemoteWorkerManager
:
:
UnregisterActor
(
RemoteWorkerServiceParent
*
aActor
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
if
(
aActor
=
=
mParentActor
)
{
mParentActor
=
nullptr
;
}
else
{
MOZ_ASSERT
(
mChildActors
.
Contains
(
aActor
)
)
;
mChildActors
.
RemoveElement
(
aActor
)
;
}
}
void
RemoteWorkerManager
:
:
Launch
(
RemoteWorkerController
*
aController
const
RemoteWorkerData
&
aData
base
:
:
ProcessId
aProcessId
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
RemoteWorkerServiceParent
*
targetActor
=
SelectTargetActor
(
aData
aProcessId
)
;
if
(
!
targetActor
)
{
if
(
mPendings
.
IsEmpty
(
)
)
{
AddRef
(
)
;
}
Pending
*
pending
=
mPendings
.
AppendElement
(
)
;
pending
-
>
mController
=
aController
;
pending
-
>
mData
=
aData
;
LaunchNewContentProcess
(
aData
)
;
return
;
}
LaunchInternal
(
aController
targetActor
aData
IsServiceWorker
(
aData
)
)
;
}
void
RemoteWorkerManager
:
:
LaunchInternal
(
RemoteWorkerController
*
aController
RemoteWorkerServiceParent
*
aTargetActor
const
RemoteWorkerData
&
aData
bool
aRemoteWorkerAlreadyRegistered
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aController
)
;
MOZ_ASSERT
(
aTargetActor
)
;
MOZ_ASSERT
(
aTargetActor
=
=
mParentActor
|
|
mChildActors
.
Contains
(
aTargetActor
)
)
;
RemoteWorkerParent
*
workerActor
=
static_cast
<
RemoteWorkerParent
*
>
(
aTargetActor
-
>
Manager
(
)
-
>
SendPRemoteWorkerConstructor
(
aData
)
)
;
if
(
NS_WARN_IF
(
!
workerActor
)
)
{
AsyncCreationFailed
(
aController
)
;
return
;
}
workerActor
-
>
Initialize
(
aRemoteWorkerAlreadyRegistered
)
;
aController
-
>
SetWorkerActor
(
workerActor
)
;
workerActor
-
>
SetController
(
aController
)
;
}
void
RemoteWorkerManager
:
:
AsyncCreationFailed
(
RemoteWorkerController
*
aController
)
{
RefPtr
<
RemoteWorkerController
>
controller
=
aController
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
RemoteWorkerManager
:
:
AsyncCreationFailed
"
[
controller
]
(
)
{
controller
-
>
CreationFailed
(
)
;
}
)
;
NS_DispatchToCurrentThread
(
r
.
forget
(
)
)
;
}
RemoteWorkerServiceParent
*
RemoteWorkerManager
:
:
SelectTargetActorForServiceWorker
(
const
RemoteWorkerData
&
aData
)
const
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mChildActors
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
IsServiceWorker
(
aData
)
)
;
nsTArray
<
RefPtr
<
ContentParent
>
>
contentParents
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
doomed
=
std
:
:
move
(
contentParents
)
]
(
)
mutable
{
doomed
.
Clear
(
)
;
}
)
;
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
;
}
)
;
uint32_t
random
=
uint32_t
(
rand
(
)
%
mChildActors
.
Length
(
)
)
;
uint32_t
i
=
random
;
do
{
auto
actor
=
mChildActors
[
i
]
;
PBackgroundParent
*
bgParent
=
actor
-
>
Manager
(
)
;
MOZ_ASSERT
(
bgParent
)
;
RefPtr
<
ContentParent
>
contentParent
=
BackgroundParent
:
:
GetContentParent
(
bgParent
)
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
contentParents
.
AppendElement
(
std
:
:
move
(
contentParent
)
)
;
}
)
;
const
nsAString
&
remoteType
=
contentParent
-
>
GetRemoteType
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
IsWebCoopCoepRemoteType
(
remoteType
)
"
COOP
+
COEP
processes
don
'
t
support
remote
workers
right
now
"
)
;
if
(
IsWebRemoteType
(
remoteType
)
)
{
auto
lock
=
contentParent
-
>
mRemoteWorkerActorData
.
Lock
(
)
;
if
(
lock
-
>
mCount
|
|
!
lock
-
>
mShutdownStarted
)
{
+
+
lock
-
>
mCount
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
contentParent
=
std
:
:
move
(
contentParent
)
principalInfo
=
aData
.
principalInfo
(
)
]
{
TransmitPermissionsForPrincipalInfo
(
contentParent
principalInfo
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
return
actor
;
}
}
i
=
(
i
+
1
)
%
mChildActors
.
Length
(
)
;
}
while
(
i
!
=
random
)
;
return
nullptr
;
}
RemoteWorkerServiceParent
*
RemoteWorkerManager
:
:
SelectTargetActor
(
const
RemoteWorkerData
&
aData
base
:
:
ProcessId
aProcessId
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
if
(
aData
.
principalInfo
(
)
.
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
{
MOZ_ASSERT
(
mParentActor
)
;
return
mParentActor
;
}
if
(
!
BrowserTabsRemoteAutostart
(
)
)
{
MOZ_ASSERT
(
mParentActor
)
;
return
mParentActor
;
}
MOZ_ASSERT
(
aProcessId
!
=
base
:
:
GetCurrentProcId
(
)
)
;
if
(
mChildActors
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
IsServiceWorker
(
aData
)
)
{
return
SelectTargetActorForServiceWorker
(
aData
)
;
}
for
(
RemoteWorkerServiceParent
*
actor
:
mChildActors
)
{
if
(
actor
-
>
OtherPid
(
)
=
=
aProcessId
)
{
return
actor
;
}
}
uint32_t
id
=
uint32_t
(
rand
(
)
)
%
mChildActors
.
Length
(
)
;
return
mChildActors
[
id
]
;
}
void
RemoteWorkerManager
:
:
LaunchNewContentProcess
(
const
RemoteWorkerData
&
aData
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
isServiceWorker
=
IsServiceWorker
(
aData
)
principalInfo
=
aData
.
principalInfo
(
)
]
{
RefPtr
<
ContentParent
>
contentParent
=
ContentParent
:
:
GetNewOrUsedBrowserProcess
(
nullptr
NS_LITERAL_STRING
(
DEFAULT_REMOTE_TYPE
)
)
;
if
(
isServiceWorker
)
{
TransmitPermissionsForPrincipalInfo
(
contentParent
principalInfo
)
;
}
}
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
;
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
}
}
