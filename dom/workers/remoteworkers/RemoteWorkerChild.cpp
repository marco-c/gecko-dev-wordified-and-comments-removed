#
include
"
RemoteWorkerChild
.
h
"
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIConsoleReportCollector
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
RemoteWorkerService
.
h
"
#
include
"
mozilla
/
ArrayAlgorithm
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
FetchEventOpProxyChild
.
h
"
#
include
"
mozilla
/
dom
/
IndexedDatabaseManager
.
h
"
#
include
"
mozilla
/
dom
/
MessagePort
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerManager
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerTypes
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerInterceptController
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerOp
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrationDescriptor
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerShutdownState
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
WorkerError
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
dom
/
WorkerScope
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
mozilla
:
:
LazyLogModule
gRemoteWorkerChildLog
(
"
RemoteWorkerChild
"
)
;
#
ifdef
LOG
#
undef
LOG
#
endif
#
define
LOG
(
fmt
)
MOZ_LOG
(
gRemoteWorkerChildLog
mozilla
:
:
LogLevel
:
:
Verbose
fmt
)
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
using
workerinternals
:
:
ChannelFromScriptURLMainThread
;
namespace
{
class
SharedWorkerInterfaceRequestor
final
:
public
nsIInterfaceRequestor
{
public
:
NS_DECL_ISUPPORTS
SharedWorkerInterfaceRequestor
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
mSWController
=
new
ServiceWorkerInterceptController
(
)
;
}
}
NS_IMETHOD
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mSWController
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsINetworkInterceptController
)
)
)
{
RefPtr
<
ServiceWorkerInterceptController
>
swController
=
mSWController
;
swController
.
forget
(
aSink
)
;
return
NS_OK
;
}
return
NS_NOINTERFACE
;
}
private
:
~
SharedWorkerInterfaceRequestor
(
)
=
default
;
RefPtr
<
ServiceWorkerInterceptController
>
mSWController
;
}
;
NS_IMPL_ADDREF
(
SharedWorkerInterfaceRequestor
)
NS_IMPL_RELEASE
(
SharedWorkerInterfaceRequestor
)
NS_IMPL_QUERY_INTERFACE
(
SharedWorkerInterfaceRequestor
nsIInterfaceRequestor
)
class
MessagePortIdentifierRunnable
final
:
public
WorkerRunnable
{
public
:
MessagePortIdentifierRunnable
(
WorkerPrivate
*
aWorkerPrivate
RemoteWorkerChild
*
aActor
const
MessagePortIdentifier
&
aPortIdentifier
)
:
WorkerRunnable
(
aWorkerPrivate
"
MessagePortIdentifierRunnable
"
)
mActor
(
aActor
)
mPortIdentifier
(
aPortIdentifier
)
{
}
private
:
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
if
(
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
IsDying
(
)
)
{
mPortIdentifier
.
ForceClose
(
)
;
return
true
;
}
mActor
-
>
AddPortIdentifier
(
aCx
aWorkerPrivate
mPortIdentifier
)
;
return
true
;
}
RefPtr
<
RemoteWorkerChild
>
mActor
;
UniqueMessagePortId
mPortIdentifier
;
}
;
class
RemoteWorkerCSPEventListener
final
:
public
nsICSPEventListener
{
public
:
NS_DECL_ISUPPORTS
explicit
RemoteWorkerCSPEventListener
(
RemoteWorkerChild
*
aActor
)
:
mActor
(
aActor
)
{
}
;
NS_IMETHOD
OnCSPViolationEvent
(
const
nsAString
&
aJSON
)
override
{
mActor
-
>
CSPViolationPropagationOnMainThread
(
aJSON
)
;
return
NS_OK
;
}
private
:
~
RemoteWorkerCSPEventListener
(
)
=
default
;
RefPtr
<
RemoteWorkerChild
>
mActor
;
}
;
NS_IMPL_ISUPPORTS
(
RemoteWorkerCSPEventListener
nsICSPEventListener
)
}
RemoteWorkerChild
:
:
RemoteWorkerChild
(
const
RemoteWorkerData
&
aData
)
:
mState
(
VariantType
<
Pending
>
(
)
"
RemoteWorkerChild
:
:
mState
"
)
mServiceKeepAlive
(
RemoteWorkerService
:
:
MaybeGetKeepAlive
(
)
)
mIsServiceWorker
(
aData
.
serviceWorkerData
(
)
.
type
(
)
=
=
OptionalServiceWorkerData
:
:
TServiceWorkerData
)
{
MOZ_ASSERT
(
RemoteWorkerService
:
:
Thread
(
)
-
>
IsOnCurrentThread
(
)
)
;
}
RemoteWorkerChild
:
:
~
RemoteWorkerChild
(
)
{
#
ifdef
DEBUG
auto
lock
=
mState
.
Lock
(
)
;
MOZ_ASSERT
(
lock
-
>
is
<
Killed
>
(
)
)
;
#
endif
}
void
RemoteWorkerChild
:
:
ActorDestroy
(
ActorDestroyReason
)
{
auto
launcherData
=
mLauncherData
.
Access
(
)
;
Unused
<
<
NS_WARN_IF
(
!
launcherData
-
>
mTerminationPromise
.
IsEmpty
(
)
)
;
launcherData
-
>
mTerminationPromise
.
RejectIfExists
(
NS_ERROR_DOM_ABORT_ERR
__func__
)
;
auto
lock
=
mState
.
Lock
(
)
;
if
(
NS_WARN_IF
(
!
lock
-
>
is
<
Killed
>
(
)
&
&
!
lock
-
>
is
<
Canceled
>
(
)
)
)
{
RefPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
RequestWorkerCancellation
"
this
&
RemoteWorkerChild
:
:
RequestWorkerCancellation
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
runnable
.
forget
(
)
)
)
;
}
}
void
RemoteWorkerChild
:
:
ExecWorker
(
const
RemoteWorkerData
&
aData
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
GetActorEventTarget
(
)
-
>
IsOnCurrentThread
(
)
)
;
auto
launcherData
=
mLauncherData
.
Access
(
)
;
MOZ_ASSERT
(
CanSend
(
)
)
;
#
endif
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
=
std
:
:
move
(
self
)
data
=
aData
]
(
)
mutable
{
nsresult
rv
=
self
-
>
ExecWorkerOnMainThread
(
std
:
:
move
(
data
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
}
nsresult
RemoteWorkerChild
:
:
ExecWorkerOnMainThread
(
RemoteWorkerData
&
&
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Unused
<
<
NS_WARN_IF
(
!
IndexedDatabaseManager
:
:
GetOrCreate
(
)
)
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
ExceptionalErrorTransitionDuringExecWorker
(
)
;
}
)
;
if
(
!
RemoteWorkerManager
:
:
IsRemoteTypeAllowed
(
aData
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
auto
principalOrErr
=
PrincipalInfoToPrincipal
(
aData
.
principalInfo
(
)
)
;
if
(
NS_WARN_IF
(
principalOrErr
.
isErr
(
)
)
)
{
return
principalOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
principalOrErr
.
unwrap
(
)
;
auto
loadingPrincipalOrErr
=
PrincipalInfoToPrincipal
(
aData
.
loadingPrincipalInfo
(
)
)
;
if
(
NS_WARN_IF
(
loadingPrincipalOrErr
.
isErr
(
)
)
)
{
return
loadingPrincipalOrErr
.
unwrapErr
(
)
;
}
auto
partitionedPrincipalOrErr
=
PrincipalInfoToPrincipal
(
aData
.
partitionedPrincipalInfo
(
)
)
;
if
(
NS_WARN_IF
(
partitionedPrincipalOrErr
.
isErr
(
)
)
)
{
return
partitionedPrincipalOrErr
.
unwrapErr
(
)
;
}
WorkerLoadInfo
info
;
info
.
mBaseURI
=
DeserializeURI
(
aData
.
baseScriptURL
(
)
)
;
info
.
mResolvedScriptURI
=
DeserializeURI
(
aData
.
resolvedScriptURL
(
)
)
;
info
.
mPrincipalInfo
=
MakeUnique
<
PrincipalInfo
>
(
aData
.
principalInfo
(
)
)
;
info
.
mPartitionedPrincipalInfo
=
MakeUnique
<
PrincipalInfo
>
(
aData
.
partitionedPrincipalInfo
(
)
)
;
info
.
mReferrerInfo
=
aData
.
referrerInfo
(
)
;
info
.
mDomain
=
aData
.
domain
(
)
;
info
.
mTrials
=
aData
.
originTrials
(
)
;
info
.
mPrincipal
=
principal
;
info
.
mPartitionedPrincipal
=
partitionedPrincipalOrErr
.
unwrap
(
)
;
info
.
mLoadingPrincipal
=
loadingPrincipalOrErr
.
unwrap
(
)
;
info
.
mStorageAccess
=
aData
.
storageAccess
(
)
;
info
.
mUseRegularPrincipal
=
aData
.
useRegularPrincipal
(
)
;
info
.
mUsingStorageAccess
=
aData
.
usingStorageAccess
(
)
;
info
.
mIsThirdPartyContextToTopWindow
=
aData
.
isThirdPartyContextToTopWindow
(
)
;
info
.
mOriginAttributes
=
BasePrincipal
:
:
Cast
(
principal
)
-
>
OriginAttributesRef
(
)
;
info
.
mShouldResistFingerprinting
=
aData
.
shouldResistFingerprinting
(
)
;
Maybe
<
RFPTarget
>
overriddenFingerprintingSettings
;
if
(
aData
.
overriddenFingerprintingSettings
(
)
.
isSome
(
)
)
{
overriddenFingerprintingSettings
.
emplace
(
RFPTarget
(
aData
.
overriddenFingerprintingSettings
(
)
.
ref
(
)
)
)
;
}
info
.
mOverriddenFingerprintingSettings
=
overriddenFingerprintingSettings
;
net
:
:
CookieJarSettings
:
:
Deserialize
(
aData
.
cookieJarSettings
(
)
getter_AddRefs
(
info
.
mCookieJarSettings
)
)
;
info
.
mCookieJarSettingsArgs
=
aData
.
cookieJarSettings
(
)
;
info
.
mEvalAllowed
=
true
;
info
.
mReportEvalCSPViolations
=
false
;
info
.
mWasmEvalAllowed
=
true
;
info
.
mReportWasmEvalCSPViolations
=
false
;
info
.
mSecureContext
=
aData
.
isSecureContext
(
)
?
WorkerLoadInfo
:
:
eSecureContext
:
WorkerLoadInfo
:
:
eInsecureContext
;
WorkerPrivate
:
:
OverrideLoadInfoLoadGroup
(
info
info
.
mLoadingPrincipal
)
;
RefPtr
<
SharedWorkerInterfaceRequestor
>
requestor
=
new
SharedWorkerInterfaceRequestor
(
)
;
info
.
mInterfaceRequestor
-
>
SetOuterRequestor
(
requestor
)
;
Maybe
<
ClientInfo
>
clientInfo
;
if
(
aData
.
clientInfo
(
)
.
isSome
(
)
)
{
clientInfo
.
emplace
(
ClientInfo
(
aData
.
clientInfo
(
)
.
ref
(
)
)
)
;
}
nsresult
rv
=
NS_OK
;
if
(
clientInfo
.
isSome
(
)
)
{
Maybe
<
mozilla
:
:
ipc
:
:
CSPInfo
>
cspInfo
=
clientInfo
.
ref
(
)
.
GetCspInfo
(
)
;
if
(
cspInfo
.
isSome
(
)
)
{
info
.
mCSP
=
CSPInfoToCSP
(
cspInfo
.
ref
(
)
nullptr
)
;
info
.
mCSPInfo
=
MakeUnique
<
CSPInfo
>
(
)
;
rv
=
CSPToCSPInfo
(
info
.
mCSP
info
.
mCSPInfo
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
rv
=
info
.
SetPrincipalsAndCSPOnMainThread
(
info
.
mPrincipal
info
.
mPartitionedPrincipal
info
.
mLoadGroup
info
.
mCSP
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsString
workerPrivateId
;
if
(
mIsServiceWorker
)
{
ServiceWorkerData
&
data
=
aData
.
serviceWorkerData
(
)
.
get_ServiceWorkerData
(
)
;
MOZ_ASSERT
(
!
data
.
id
(
)
.
IsEmpty
(
)
)
;
workerPrivateId
=
std
:
:
move
(
data
.
id
(
)
)
;
info
.
mServiceWorkerCacheName
=
data
.
cacheName
(
)
;
info
.
mServiceWorkerDescriptor
.
emplace
(
data
.
descriptor
(
)
)
;
info
.
mServiceWorkerRegistrationDescriptor
.
emplace
(
data
.
registrationDescriptor
(
)
)
;
info
.
mLoadFlags
=
static_cast
<
nsLoadFlags
>
(
data
.
loadFlags
(
)
)
;
}
else
{
rv
=
ChannelFromScriptURLMainThread
(
info
.
mLoadingPrincipal
nullptr
info
.
mLoadGroup
info
.
mResolvedScriptURI
aData
.
type
(
)
aData
.
credentials
(
)
clientInfo
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
info
.
mCookieJarSettings
info
.
mReferrerInfo
getter_AddRefs
(
info
.
mChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
info
.
mChannel
-
>
LoadInfo
(
)
;
auto
*
cspEventListener
=
new
RemoteWorkerCSPEventListener
(
this
)
;
rv
=
loadInfo
-
>
SetCspEventListener
(
cspEventListener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
info
.
mAgentClusterId
=
aData
.
agentClusterId
(
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
ErrorResult
error
;
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
RefPtr
<
WorkerPrivate
>
workerPrivate
=
WorkerPrivate
:
:
Constructor
(
jsapi
.
cx
(
)
aData
.
originalScriptURL
(
)
false
mIsServiceWorker
?
WorkerKindService
:
WorkerKindShared
aData
.
credentials
(
)
aData
.
type
(
)
aData
.
name
(
)
VoidCString
(
)
&
info
error
std
:
:
move
(
workerPrivateId
)
[
self
]
(
bool
aEverRan
)
{
self
-
>
OnWorkerCancellationTransitionStateFromPendingOrRunningToCanceled
(
)
;
}
[
self
]
(
)
{
self
-
>
TransitionStateFromCanceledToKilled
(
)
;
}
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
workerPrivate
)
;
rv
=
error
.
StealNSResult
(
)
;
return
rv
;
}
workerPrivate
-
>
SetRemoteWorkerController
(
this
)
;
nsCOMPtr
<
nsISerialEventTarget
>
workerTarget
=
workerPrivate
-
>
HybridEventTarget
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewCancelableRunnableMethod
(
"
InitialzeOnWorker
"
this
&
RemoteWorkerChild
:
:
InitializeOnWorker
)
;
{
MOZ_ASSERT
(
workerPrivate
)
;
auto
lock
=
mState
.
Lock
(
)
;
lock
-
>
as
<
Pending
>
(
)
.
mWorkerPrivate
=
std
:
:
move
(
workerPrivate
)
;
}
if
(
mIsServiceWorker
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
workerTarget
initializeWorkerRunnable
=
std
:
:
move
(
runnable
)
]
(
)
mutable
{
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
workerTarget
-
>
Dispatch
(
initializeWorkerRunnable
.
forget
(
)
)
)
)
;
}
)
;
RefPtr
<
PermissionManager
>
permissionManager
=
PermissionManager
:
:
GetInstance
(
)
;
if
(
!
permissionManager
)
{
return
NS_ERROR_FAILURE
;
}
permissionManager
-
>
WhenPermissionsAvailable
(
principal
r
)
;
}
else
{
if
(
NS_WARN_IF
(
NS_FAILED
(
workerTarget
-
>
Dispatch
(
runnable
.
forget
(
)
)
)
)
)
{
rv
=
NS_ERROR_FAILURE
;
return
rv
;
}
}
scopeExit
.
release
(
)
;
return
NS_OK
;
}
void
RemoteWorkerChild
:
:
RequestWorkerCancellation
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
(
"
RequestWorkerCancellation
[
this
=
%
p
]
"
this
)
)
;
RefPtr
<
WorkerPrivate
>
cancelWith
;
{
auto
lock
=
mState
.
Lock
(
)
;
if
(
lock
-
>
is
<
Pending
>
(
)
)
{
cancelWith
=
lock
-
>
as
<
Pending
>
(
)
.
mWorkerPrivate
;
}
else
if
(
lock
-
>
is
<
Running
>
(
)
)
{
cancelWith
=
lock
-
>
as
<
Running
>
(
)
.
mWorkerPrivate
;
}
}
if
(
cancelWith
)
{
cancelWith
-
>
Cancel
(
)
;
}
}
void
RemoteWorkerChild
:
:
InitializeOnWorker
(
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NewRunnableMethod
(
"
TransitionStateToRunning
"
this
&
RemoteWorkerChild
:
:
TransitionStateToRunning
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
}
RefPtr
<
GenericNonExclusivePromise
>
RemoteWorkerChild
:
:
GetTerminationPromise
(
)
{
auto
launcherData
=
mLauncherData
.
Access
(
)
;
return
launcherData
-
>
mTerminationPromise
.
Ensure
(
__func__
)
;
}
void
RemoteWorkerChild
:
:
CreationSucceededOnAnyThread
(
)
{
CreationSucceededOrFailedOnAnyThread
(
true
)
;
}
void
RemoteWorkerChild
:
:
CreationFailedOnAnyThread
(
)
{
CreationSucceededOrFailedOnAnyThread
(
false
)
;
}
void
RemoteWorkerChild
:
:
CreationSucceededOrFailedOnAnyThread
(
bool
aDidCreationSucceed
)
{
#
ifdef
DEBUG
{
auto
lock
=
mState
.
Lock
(
)
;
MOZ_ASSERT_IF
(
aDidCreationSucceed
lock
-
>
is
<
Running
>
(
)
)
;
MOZ_ASSERT_IF
(
!
aDidCreationSucceed
lock
-
>
is
<
Killed
>
(
)
)
;
}
#
endif
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
=
std
:
:
move
(
self
)
didCreationSucceed
=
aDidCreationSucceed
]
{
auto
launcherData
=
self
-
>
mLauncherData
.
Access
(
)
;
if
(
!
self
-
>
CanSend
(
)
|
|
launcherData
-
>
mDidSendCreated
)
{
return
;
}
Unused
<
<
self
-
>
SendCreated
(
didCreationSucceed
)
;
launcherData
-
>
mDidSendCreated
=
true
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
CloseWorkerOnMainThread
(
)
{
AssertIsOnMainThread
(
)
;
LOG
(
(
"
CloseWorkerOnMainThread
[
this
=
%
p
]
"
this
)
)
;
RefPtr
<
WorkerPrivate
>
cancelWith
;
{
auto
lock
=
mState
.
Lock
(
)
;
if
(
lock
-
>
is
<
Pending
>
(
)
)
{
cancelWith
=
lock
-
>
as
<
Pending
>
(
)
.
mWorkerPrivate
;
MOZ_DIAGNOSTIC_ASSERT
(
cancelWith
)
;
}
else
if
(
lock
-
>
is
<
Running
>
(
)
)
{
cancelWith
=
lock
-
>
as
<
Running
>
(
)
.
mWorkerPrivate
;
}
}
if
(
cancelWith
)
{
cancelWith
-
>
Cancel
(
)
;
}
}
void
RemoteWorkerChild
:
:
ErrorPropagation
(
const
ErrorValue
&
aValue
)
{
MOZ_ASSERT
(
GetActorEventTarget
(
)
-
>
IsOnCurrentThread
(
)
)
;
if
(
!
CanSend
(
)
)
{
return
;
}
Unused
<
<
SendError
(
aValue
)
;
}
void
RemoteWorkerChild
:
:
ErrorPropagationDispatch
(
nsresult
aError
)
{
MOZ_ASSERT
(
NS_FAILED
(
aError
)
)
;
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
RemoteWorkerChild
:
:
ErrorPropagationDispatch
"
[
self
=
std
:
:
move
(
self
)
aError
]
(
)
{
self
-
>
ErrorPropagation
(
aError
)
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
ErrorPropagationOnMainThread
(
const
WorkerErrorReport
*
aReport
bool
aIsErrorEvent
)
{
AssertIsOnMainThread
(
)
;
ErrorValue
value
;
if
(
aIsErrorEvent
)
{
ErrorData
data
(
aReport
-
>
mIsWarning
aReport
-
>
mLineNumber
aReport
-
>
mColumnNumber
aReport
-
>
mMessage
aReport
-
>
mFilename
aReport
-
>
mLine
TransformIntoNewArray
(
aReport
-
>
mNotes
[
]
(
const
WorkerErrorNote
&
note
)
{
return
ErrorDataNote
(
note
.
mLineNumber
note
.
mColumnNumber
note
.
mMessage
note
.
mFilename
)
;
}
)
)
;
value
=
data
;
}
else
{
value
=
void_t
(
)
;
}
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
RemoteWorkerChild
:
:
ErrorPropagationOnMainThread
"
[
self
=
std
:
:
move
(
self
)
value
]
(
)
{
self
-
>
ErrorPropagation
(
value
)
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
CSPViolationPropagationOnMainThread
(
const
nsAString
&
aJSON
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
RemoteWorkerChild
:
:
ErrorPropagationDispatch
"
[
self
=
std
:
:
move
(
self
)
json
=
nsString
(
aJSON
)
]
(
)
{
CSPViolation
violation
(
json
)
;
self
-
>
ErrorPropagation
(
violation
)
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
NotifyLock
(
bool
aCreated
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
aCreated
]
{
if
(
!
self
-
>
CanSend
(
)
)
{
return
;
}
Unused
<
<
self
-
>
SendNotifyLock
(
aCreated
)
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
NotifyWebTransport
(
bool
aCreated
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
aCreated
]
{
if
(
!
self
-
>
CanSend
(
)
)
{
return
;
}
Unused
<
<
self
-
>
SendNotifyWebTransport
(
aCreated
)
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
FlushReportsOnMainThread
(
nsIConsoleReportCollector
*
aReporter
)
{
AssertIsOnMainThread
(
)
;
bool
reportErrorToBrowserConsole
=
true
;
for
(
uint32_t
i
=
0
len
=
mWindowIDs
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
aReporter
-
>
FlushReportsToConsole
(
mWindowIDs
[
i
]
nsIConsoleReportCollector
:
:
ReportAction
:
:
Save
)
;
reportErrorToBrowserConsole
=
false
;
}
if
(
reportErrorToBrowserConsole
)
{
aReporter
-
>
FlushReportsToConsole
(
0
)
;
return
;
}
aReporter
-
>
ClearConsoleReports
(
)
;
}
RemoteWorkerChild
:
:
WorkerPrivateAccessibleState
:
:
~
WorkerPrivateAccessibleState
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
|
|
NS_IsMainThread
(
)
)
;
if
(
!
mWorkerPrivate
|
|
NS_IsMainThread
(
)
)
{
return
;
}
NS_ReleaseOnMainThread
(
"
RemoteWorkerChild
:
:
WorkerPrivateAccessibleState
:
:
mWorkerPrivate
"
mWorkerPrivate
.
forget
(
)
)
;
}
void
RemoteWorkerChild
:
:
OnWorkerCancellationTransitionStateFromPendingOrRunningToCanceled
(
)
{
auto
lock
=
mState
.
Lock
(
)
;
LOG
(
(
"
TransitionStateFromPendingOrRunningToCanceled
[
this
=
%
p
]
"
this
)
)
;
if
(
lock
-
>
is
<
Pending
>
(
)
)
{
TransitionStateFromPendingToCanceled
(
lock
.
ref
(
)
)
;
}
else
if
(
lock
-
>
is
<
Running
>
(
)
)
{
*
lock
=
VariantType
<
Canceled
>
(
)
;
}
else
{
MOZ_ASSERT
(
false
"
State
should
have
been
Pending
or
Running
"
)
;
}
}
void
RemoteWorkerChild
:
:
TransitionStateFromPendingToCanceled
(
State
&
aState
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aState
.
is
<
Pending
>
(
)
)
;
LOG
(
(
"
TransitionStateFromPendingToCanceled
[
this
=
%
p
]
"
this
)
)
;
CancelAllPendingOps
(
aState
)
;
aState
=
VariantType
<
Canceled
>
(
)
;
}
void
RemoteWorkerChild
:
:
TransitionStateFromCanceledToKilled
(
)
{
AssertIsOnMainThread
(
)
;
LOG
(
(
"
TransitionStateFromCanceledToKilled
[
this
=
%
p
]
"
this
)
)
;
auto
lock
=
mState
.
Lock
(
)
;
MOZ_ASSERT
(
lock
-
>
is
<
Canceled
>
(
)
)
;
*
lock
=
VariantType
<
Killed
>
(
)
;
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
]
(
)
{
auto
launcherData
=
self
-
>
mLauncherData
.
Access
(
)
;
launcherData
-
>
mTerminationPromise
.
ResolveIfExists
(
true
__func__
)
;
if
(
self
-
>
CanSend
(
)
)
{
Unused
<
<
self
-
>
SendClose
(
)
;
}
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RemoteWorkerChild
:
:
TransitionStateToRunning
(
)
{
AssertIsOnMainThread
(
)
;
LOG
(
(
"
TransitionStateToRunning
[
this
=
%
p
]
"
this
)
)
;
nsTArray
<
RefPtr
<
Op
>
>
pendingOps
;
{
auto
lock
=
mState
.
Lock
(
)
;
if
(
!
lock
-
>
is
<
Pending
>
(
)
)
{
LOG
(
(
"
State
is
already
not
pending
in
TransitionStateToRunning
[
this
=
%
p
]
!
"
this
)
)
;
return
;
}
RefPtr
<
WorkerPrivate
>
workerPrivate
=
std
:
:
move
(
lock
-
>
as
<
Pending
>
(
)
.
mWorkerPrivate
)
;
pendingOps
=
std
:
:
move
(
lock
-
>
as
<
Pending
>
(
)
.
mPendingOps
)
;
*
lock
=
VariantType
<
Running
>
(
)
;
lock
-
>
as
<
Running
>
(
)
.
mWorkerPrivate
=
std
:
:
move
(
workerPrivate
)
;
}
CreationSucceededOnAnyThread
(
)
;
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
for
(
auto
&
op
:
pendingOps
)
{
op
-
>
StartOnMainThread
(
self
)
;
}
}
void
RemoteWorkerChild
:
:
ExceptionalErrorTransitionDuringExecWorker
(
)
{
AssertIsOnMainThread
(
)
;
LOG
(
(
"
ExceptionalErrorTransitionDuringExecWorker
[
this
=
%
p
]
"
this
)
)
;
RefPtr
<
WorkerPrivate
>
cancelWith
;
{
auto
lock
=
mState
.
Lock
(
)
;
MOZ_ASSERT
(
lock
-
>
is
<
Pending
>
(
)
)
;
if
(
lock
-
>
is
<
Pending
>
(
)
)
{
cancelWith
=
lock
-
>
as
<
Pending
>
(
)
.
mWorkerPrivate
;
if
(
!
cancelWith
)
{
TransitionStateFromPendingToCanceled
(
lock
.
ref
(
)
)
;
}
}
}
if
(
cancelWith
)
{
cancelWith
-
>
Cancel
(
)
;
}
else
{
TransitionStateFromCanceledToKilled
(
)
;
CreationFailedOnAnyThread
(
)
;
}
}
class
RemoteWorkerChild
:
:
SharedWorkerOp
:
public
RemoteWorkerChild
:
:
Op
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SharedWorkerOp
override
)
explicit
SharedWorkerOp
(
RemoteWorkerOp
&
&
aOp
)
:
mOp
(
std
:
:
move
(
aOp
)
)
{
}
bool
MaybeStart
(
RemoteWorkerChild
*
aOwner
RemoteWorkerChild
:
:
State
&
aState
)
override
{
MOZ_ASSERT
(
!
mStarted
)
;
MOZ_ASSERT
(
aOwner
)
;
if
(
aState
.
is
<
Pending
>
(
)
&
&
!
IsTerminationOp
(
)
)
{
return
false
;
}
if
(
aState
.
is
<
Canceled
>
(
)
|
|
aState
.
is
<
Killed
>
(
)
)
{
#
ifdef
DEBUG
mStarted
=
true
;
#
endif
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerPortIdentifierOp
)
{
MessagePort
:
:
ForceClose
(
mOp
.
get_RemoteWorkerPortIdentifierOp
(
)
.
portIdentifier
(
)
)
;
}
return
true
;
}
MOZ_ASSERT
(
aState
.
is
<
Running
>
(
)
|
|
IsTerminationOp
(
)
)
;
RefPtr
<
SharedWorkerOp
>
self
=
this
;
RefPtr
<
RemoteWorkerChild
>
owner
=
aOwner
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
=
std
:
:
move
(
self
)
owner
=
std
:
:
move
(
owner
)
]
(
)
mutable
{
{
auto
lock
=
owner
-
>
mState
.
Lock
(
)
;
if
(
NS_WARN_IF
(
lock
-
>
is
<
Canceled
>
(
)
|
|
lock
-
>
is
<
Killed
>
(
)
)
)
{
self
-
>
Cancel
(
)
;
if
(
self
-
>
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerPortIdentifierOp
)
{
MessagePort
:
:
ForceClose
(
self
-
>
mOp
.
get_RemoteWorkerPortIdentifierOp
(
)
.
portIdentifier
(
)
)
;
}
return
;
}
}
self
-
>
StartOnMainThread
(
owner
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
#
ifdef
DEBUG
mStarted
=
true
;
#
endif
return
true
;
}
void
StartOnMainThread
(
RefPtr
<
RemoteWorkerChild
>
&
aOwner
)
final
{
using
Running
=
RemoteWorkerChild
:
:
Running
;
AssertIsOnMainThread
(
)
;
if
(
IsTerminationOp
(
)
)
{
aOwner
-
>
CloseWorkerOnMainThread
(
)
;
return
;
}
auto
lock
=
aOwner
-
>
mState
.
Lock
(
)
;
MOZ_ASSERT
(
lock
-
>
is
<
Running
>
(
)
)
;
if
(
!
lock
-
>
is
<
Running
>
(
)
)
{
aOwner
-
>
ErrorPropagationDispatch
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
RefPtr
<
WorkerPrivate
>
workerPrivate
=
lock
-
>
as
<
Running
>
(
)
.
mWorkerPrivate
;
MOZ_ASSERT
(
workerPrivate
)
;
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerSuspendOp
)
{
workerPrivate
-
>
ParentWindowPaused
(
)
;
}
else
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerResumeOp
)
{
workerPrivate
-
>
ParentWindowResumed
(
)
;
}
else
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerFreezeOp
)
{
workerPrivate
-
>
Freeze
(
nullptr
)
;
}
else
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerThawOp
)
{
workerPrivate
-
>
Thaw
(
nullptr
)
;
}
else
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerPortIdentifierOp
)
{
RefPtr
<
MessagePortIdentifierRunnable
>
r
=
new
MessagePortIdentifierRunnable
(
workerPrivate
aOwner
mOp
.
get_RemoteWorkerPortIdentifierOp
(
)
.
portIdentifier
(
)
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
aOwner
-
>
ErrorPropagationDispatch
(
NS_ERROR_FAILURE
)
;
}
}
else
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerAddWindowIDOp
)
{
aOwner
-
>
mWindowIDs
.
AppendElement
(
mOp
.
get_RemoteWorkerAddWindowIDOp
(
)
.
windowID
(
)
)
;
}
else
if
(
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerRemoveWindowIDOp
)
{
aOwner
-
>
mWindowIDs
.
RemoveElement
(
mOp
.
get_RemoteWorkerRemoveWindowIDOp
(
)
.
windowID
(
)
)
;
}
else
{
MOZ_CRASH
(
"
Unknown
RemoteWorkerOp
type
!
"
)
;
}
}
void
Cancel
(
)
override
{
#
ifdef
DEBUG
mStarted
=
true
;
#
endif
}
private
:
~
SharedWorkerOp
(
)
{
MOZ_ASSERT
(
mStarted
)
;
}
bool
IsTerminationOp
(
)
const
{
return
mOp
.
type
(
)
=
=
RemoteWorkerOp
:
:
TRemoteWorkerTerminateOp
;
}
RemoteWorkerOp
mOp
;
#
ifdef
DEBUG
bool
mStarted
=
false
;
#
endif
}
;
void
RemoteWorkerChild
:
:
AddPortIdentifier
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
UniqueMessagePortId
&
aPortIdentifier
)
{
if
(
NS_WARN_IF
(
!
aWorkerPrivate
-
>
ConnectMessagePort
(
aCx
aPortIdentifier
)
)
)
{
ErrorPropagationDispatch
(
NS_ERROR_FAILURE
)
;
}
}
void
RemoteWorkerChild
:
:
CancelAllPendingOps
(
State
&
aState
)
{
MOZ_ASSERT
(
aState
.
is
<
Pending
>
(
)
)
;
auto
pendingOps
=
std
:
:
move
(
aState
.
as
<
Pending
>
(
)
.
mPendingOps
)
;
for
(
auto
&
op
:
pendingOps
)
{
op
-
>
Cancel
(
)
;
}
}
void
RemoteWorkerChild
:
:
MaybeStartOp
(
RefPtr
<
Op
>
&
&
aOp
)
{
MOZ_ASSERT
(
aOp
)
;
auto
lock
=
mState
.
Lock
(
)
;
if
(
!
aOp
-
>
MaybeStart
(
this
lock
.
ref
(
)
)
)
{
lock
-
>
as
<
Pending
>
(
)
.
mPendingOps
.
AppendElement
(
std
:
:
move
(
aOp
)
)
;
}
}
IPCResult
RemoteWorkerChild
:
:
RecvExecOp
(
RemoteWorkerOp
&
&
aOp
)
{
MOZ_ASSERT
(
!
mIsServiceWorker
)
;
MaybeStartOp
(
new
SharedWorkerOp
(
std
:
:
move
(
aOp
)
)
)
;
return
IPC_OK
(
)
;
}
IPCResult
RemoteWorkerChild
:
:
RecvExecServiceWorkerOp
(
ServiceWorkerOpArgs
&
&
aArgs
ExecServiceWorkerOpResolver
&
&
aResolve
)
{
MOZ_ASSERT
(
mIsServiceWorker
)
;
MOZ_ASSERT
(
aArgs
.
type
(
)
!
=
ServiceWorkerOpArgs
:
:
TParentToChildServiceWorkerFetchEventOpArgs
"
FetchEvent
operations
should
be
sent
via
PFetchEventOp
(
Proxy
)
actors
!
"
)
;
MaybeReportServiceWorkerShutdownProgress
(
aArgs
)
;
MaybeStartOp
(
ServiceWorkerOp
:
:
Create
(
std
:
:
move
(
aArgs
)
std
:
:
move
(
aResolve
)
)
)
;
return
IPC_OK
(
)
;
}
RefPtr
<
GenericPromise
>
RemoteWorkerChild
:
:
MaybeSendSetServiceWorkerSkipWaitingFlag
(
)
{
RefPtr
<
GenericPromise
:
:
Private
>
promise
=
new
GenericPromise
:
:
Private
(
__func__
)
;
RefPtr
<
RemoteWorkerChild
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
self
=
std
:
:
move
(
self
)
promise
]
{
if
(
!
self
-
>
CanSend
(
)
)
{
promise
-
>
Reject
(
NS_ERROR_DOM_ABORT_ERR
__func__
)
;
return
;
}
self
-
>
SendSetServiceWorkerSkipWaitingFlag
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
const
SetServiceWorkerSkipWaitingFlagPromise
:
:
ResolveOrRejectValue
&
aResult
)
{
if
(
NS_WARN_IF
(
aResult
.
IsReject
(
)
)
)
{
promise
-
>
Reject
(
NS_ERROR_DOM_ABORT_ERR
__func__
)
;
return
;
}
promise
-
>
Resolve
(
aResult
.
ResolveValue
(
)
__func__
)
;
}
)
;
}
)
;
GetActorEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
return
promise
;
}
already_AddRefed
<
PFetchEventOpProxyChild
>
RemoteWorkerChild
:
:
AllocPFetchEventOpProxyChild
(
const
ParentToChildServiceWorkerFetchEventOpArgs
&
aArgs
)
{
return
RefPtr
{
new
FetchEventOpProxyChild
(
)
}
.
forget
(
)
;
}
IPCResult
RemoteWorkerChild
:
:
RecvPFetchEventOpProxyConstructor
(
PFetchEventOpProxyChild
*
aActor
const
ParentToChildServiceWorkerFetchEventOpArgs
&
aArgs
)
{
MOZ_ASSERT
(
aActor
)
;
(
static_cast
<
FetchEventOpProxyChild
*
>
(
aActor
)
)
-
>
Initialize
(
aArgs
)
;
return
IPC_OK
(
)
;
}
}
}
