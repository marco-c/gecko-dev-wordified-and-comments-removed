#
include
"
RemoteWorkerService
.
h
"
#
include
"
mozilla
/
dom
/
PRemoteWorkerParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
RemoteWorkerController
.
h
"
#
include
"
RemoteWorkerServiceChild
.
h
"
#
include
"
RemoteWorkerServiceParent
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
{
StaticMutex
sRemoteWorkerServiceMutex
;
StaticRefPtr
<
RemoteWorkerService
>
sRemoteWorkerService
;
}
class
RemoteWorkerServiceShutdownBlocker
final
{
~
RemoteWorkerServiceShutdownBlocker
(
)
=
default
;
public
:
explicit
RemoteWorkerServiceShutdownBlocker
(
RemoteWorkerService
*
aService
)
:
mService
(
aService
)
mBlockShutdown
(
true
)
{
}
void
RemoteWorkersAllGoneAllowShutdown
(
)
{
mService
-
>
FinishShutdown
(
)
;
mService
=
nullptr
;
mBlockShutdown
=
false
;
}
bool
ShouldBlockShutdown
(
)
{
return
mBlockShutdown
;
}
NS_INLINE_DECL_REFCOUNTING
(
RemoteWorkerServiceShutdownBlocker
)
;
RefPtr
<
RemoteWorkerService
>
mService
;
bool
mBlockShutdown
;
}
;
RemoteWorkerServiceKeepAlive
:
:
RemoteWorkerServiceKeepAlive
(
RemoteWorkerServiceShutdownBlocker
*
aBlocker
)
:
mBlocker
(
aBlocker
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
RemoteWorkerServiceKeepAlive
:
:
~
RemoteWorkerServiceKeepAlive
(
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
blocker
=
std
:
:
move
(
mBlocker
)
]
{
blocker
-
>
RemoteWorkersAllGoneAllowShutdown
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
}
void
RemoteWorkerService
:
:
InitializeParent
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
!
sRemoteWorkerService
)
;
RefPtr
<
RemoteWorkerService
>
service
=
new
RemoteWorkerService
(
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
;
}
nsresult
rv
=
obs
-
>
AddObserver
(
service
"
profile
-
after
-
change
"
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
sRemoteWorkerService
=
service
;
}
void
RemoteWorkerService
:
:
InitializeChild
(
mozilla
:
:
ipc
:
:
Endpoint
<
PRemoteWorkerServiceChild
>
aEndpoint
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
!
sRemoteWorkerService
)
;
RefPtr
<
RemoteWorkerService
>
service
=
new
RemoteWorkerService
(
)
;
nsresult
rv
=
service
-
>
InitializeOnMainThread
(
std
:
:
move
(
aEndpoint
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
sRemoteWorkerService
=
service
;
}
nsIThread
*
RemoteWorkerService
:
:
Thread
(
)
{
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
sRemoteWorkerService
)
;
MOZ_ASSERT
(
sRemoteWorkerService
-
>
mThread
)
;
return
sRemoteWorkerService
-
>
mThread
;
}
already_AddRefed
<
RemoteWorkerServiceKeepAlive
>
RemoteWorkerService
:
:
MaybeGetKeepAlive
(
)
{
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
sRemoteWorkerService
)
;
if
(
!
sRemoteWorkerService
)
{
return
nullptr
;
}
auto
lockedKeepAlive
=
sRemoteWorkerService
-
>
mKeepAlive
.
Lock
(
)
;
RefPtr
<
RemoteWorkerServiceKeepAlive
>
extraRef
=
*
lockedKeepAlive
;
return
extraRef
.
forget
(
)
;
}
nsresult
RemoteWorkerService
:
:
InitializeOnMainThread
(
mozilla
:
:
ipc
:
:
Endpoint
<
PRemoteWorkerServiceChild
>
aEndpoint
)
{
nsresult
rv
=
NS_NewNamedThread
(
"
Worker
Launcher
"
getter_AddRefs
(
mThread
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
obs
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mShutdownBlocker
=
new
RemoteWorkerServiceShutdownBlocker
(
this
)
;
{
RefPtr
<
RemoteWorkerServiceKeepAlive
>
keepAlive
=
new
RemoteWorkerServiceKeepAlive
(
mShutdownBlocker
)
;
auto
lockedKeepAlive
=
mKeepAlive
.
Lock
(
)
;
*
lockedKeepAlive
=
std
:
:
move
(
keepAlive
)
;
}
RefPtr
<
RemoteWorkerService
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
InitializeThread
"
[
self
endpoint
=
std
:
:
move
(
aEndpoint
)
]
(
)
mutable
{
self
-
>
InitializeOnTargetThread
(
std
:
:
move
(
endpoint
)
)
;
}
)
;
rv
=
mThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
RemoteWorkerService
:
:
RemoteWorkerService
(
)
:
mKeepAlive
(
nullptr
"
RemoteWorkerService
:
:
mKeepAlive
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
RemoteWorkerService
:
:
~
RemoteWorkerService
(
)
=
default
;
void
RemoteWorkerService
:
:
InitializeOnTargetThread
(
mozilla
:
:
ipc
:
:
Endpoint
<
PRemoteWorkerServiceChild
>
aEndpoint
)
{
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
mThread
-
>
IsOnCurrentThread
(
)
)
;
RefPtr
<
RemoteWorkerServiceChild
>
serviceActor
=
MakeAndAddRef
<
RemoteWorkerServiceChild
>
(
)
;
if
(
NS_WARN_IF
(
!
aEndpoint
.
Bind
(
serviceActor
)
)
)
{
return
;
}
mActor
=
serviceActor
;
}
void
RemoteWorkerService
:
:
CloseActorOnTargetThread
(
)
{
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
mThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
mActor
)
{
mActor
-
>
Close
(
)
;
mActor
=
nullptr
;
}
}
NS_IMETHODIMP
RemoteWorkerService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
MOZ_ASSERT
(
mThread
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
BeginShutdown
(
)
;
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
"
RemoteWorkerService
:
:
Observe
"
_ns
[
&
]
(
)
{
return
!
mShutdownBlocker
-
>
ShouldBlockShutdown
(
)
;
}
)
)
;
mShutdownBlocker
=
nullptr
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
profile
-
after
-
change
"
)
;
}
Endpoint
<
PRemoteWorkerServiceChild
>
childEp
;
RefPtr
<
RemoteWorkerServiceParent
>
parentActor
=
RemoteWorkerServiceParent
:
:
CreateForProcess
(
nullptr
&
childEp
)
;
NS_ENSURE_TRUE
(
parentActor
NS_ERROR_FAILURE
)
;
return
InitializeOnMainThread
(
std
:
:
move
(
childEp
)
)
;
}
void
RemoteWorkerService
:
:
BeginShutdown
(
)
{
auto
lockedKeepAlive
=
mKeepAlive
.
Lock
(
)
;
*
lockedKeepAlive
=
nullptr
;
}
void
RemoteWorkerService
:
:
FinishShutdown
(
)
{
{
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
sRemoteWorkerService
=
nullptr
;
}
RefPtr
<
RemoteWorkerService
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
RemoteWorkerService
:
:
CloseActorOnTargetThread
"
[
self
]
(
)
{
self
-
>
CloseActorOnTargetThread
(
)
;
}
)
;
mThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
RemoteWorkerService
nsIObserver
)
}
}
