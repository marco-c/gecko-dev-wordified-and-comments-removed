#
include
"
RemoteWorkerService
.
h
"
#
include
"
mozilla
/
dom
/
PRemoteWorkerParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
RemoteWorkerController
.
h
"
#
include
"
RemoteWorkerServiceChild
.
h
"
#
include
"
RemoteWorkerServiceParent
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
{
StaticMutex
sRemoteWorkerServiceMutex
;
StaticRefPtr
<
RemoteWorkerService
>
sRemoteWorkerService
;
}
class
RemoteWorkerServiceShutdownBlocker
final
:
public
nsIAsyncShutdownBlocker
{
~
RemoteWorkerServiceShutdownBlocker
(
)
=
default
;
public
:
RemoteWorkerServiceShutdownBlocker
(
RemoteWorkerService
*
aService
nsIAsyncShutdownClient
*
aShutdownClient
)
:
mService
(
aService
)
mShutdownClient
(
aShutdownClient
)
{
nsAutoString
blockerName
;
MOZ_ALWAYS_SUCCEEDS
(
GetName
(
blockerName
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
mShutdownClient
-
>
AddBlocker
(
this
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
blockerName
)
)
;
}
void
RemoteWorkersAllGoneAllowShutdown
(
)
{
mShutdownClient
-
>
RemoveBlocker
(
this
)
;
mShutdownClient
=
nullptr
;
mService
-
>
FinishShutdown
(
)
;
mService
=
nullptr
;
}
NS_IMETHOD
GetName
(
nsAString
&
aNameOut
)
override
{
aNameOut
=
nsLiteralString
(
u
"
RemoteWorkerService
:
waiting
for
RemoteWorkers
to
shutdown
"
)
;
return
NS_OK
;
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aClient
)
override
{
mService
-
>
BeginShutdown
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
RefPtr
<
RemoteWorkerService
>
mService
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
mShutdownClient
;
}
;
NS_IMPL_ISUPPORTS
(
RemoteWorkerServiceShutdownBlocker
nsIAsyncShutdownBlocker
)
RemoteWorkerServiceKeepAlive
:
:
RemoteWorkerServiceKeepAlive
(
RemoteWorkerServiceShutdownBlocker
*
aBlocker
)
:
mBlocker
(
aBlocker
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
RemoteWorkerServiceKeepAlive
:
:
~
RemoteWorkerServiceKeepAlive
(
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
blocker
=
std
:
:
move
(
mBlocker
)
]
{
blocker
-
>
RemoteWorkersAllGoneAllowShutdown
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
}
void
RemoteWorkerService
:
:
Initialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
!
sRemoteWorkerService
)
;
RefPtr
<
RemoteWorkerService
>
service
=
new
RemoteWorkerService
(
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
sRemoteWorkerService
=
service
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
initService
=
std
:
:
move
(
service
)
]
{
nsresult
rv
=
initService
-
>
InitializeOnMainThread
(
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
;
}
nsresult
rv
=
obs
-
>
AddObserver
(
service
"
profile
-
after
-
change
"
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
sRemoteWorkerService
=
service
;
}
nsIThread
*
RemoteWorkerService
:
:
Thread
(
)
{
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
sRemoteWorkerService
)
;
MOZ_ASSERT
(
sRemoteWorkerService
-
>
mThread
)
;
return
sRemoteWorkerService
-
>
mThread
;
}
already_AddRefed
<
RemoteWorkerServiceKeepAlive
>
RemoteWorkerService
:
:
MaybeGetKeepAlive
(
)
{
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
MOZ_ASSERT
(
sRemoteWorkerService
)
;
if
(
!
sRemoteWorkerService
)
{
return
nullptr
;
}
auto
lockedKeepAlive
=
sRemoteWorkerService
-
>
mKeepAlive
.
Lock
(
)
;
RefPtr
<
RemoteWorkerServiceKeepAlive
>
extraRef
=
*
lockedKeepAlive
;
return
extraRef
.
forget
(
)
;
}
nsresult
RemoteWorkerService
:
:
InitializeOnMainThread
(
)
{
nsresult
rv
=
NS_NewNamedThread
(
"
Worker
Launcher
"
getter_AddRefs
(
mThread
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIAsyncShutdownService
>
shutdownSvc
=
services
:
:
GetAsyncShutdownService
(
)
;
if
(
NS_WARN_IF
(
!
shutdownSvc
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownSvc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
phase
)
)
)
;
if
(
NS_WARN_IF
(
!
phase
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
RemoteWorkerServiceShutdownBlocker
>
blocker
=
new
RemoteWorkerServiceShutdownBlocker
(
this
phase
)
;
{
RefPtr
<
RemoteWorkerServiceKeepAlive
>
keepAlive
=
new
RemoteWorkerServiceKeepAlive
(
blocker
)
;
auto
lockedKeepAlive
=
mKeepAlive
.
Lock
(
)
;
*
lockedKeepAlive
=
std
:
:
move
(
keepAlive
)
;
}
RefPtr
<
RemoteWorkerService
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
InitializeThread
"
[
self
]
(
)
{
self
-
>
InitializeOnTargetThread
(
)
;
}
)
;
rv
=
mThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
RemoteWorkerService
:
:
RemoteWorkerService
(
)
:
mKeepAlive
(
nullptr
"
RemoteWorkerService
:
:
mKeepAlive
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
RemoteWorkerService
:
:
~
RemoteWorkerService
(
)
=
default
;
void
RemoteWorkerService
:
:
InitializeOnTargetThread
(
)
{
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
mThread
-
>
IsOnCurrentThread
(
)
)
;
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
;
}
RefPtr
<
RemoteWorkerServiceChild
>
serviceActor
=
MakeAndAddRef
<
RemoteWorkerServiceChild
>
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
-
>
SendPRemoteWorkerServiceConstructor
(
serviceActor
)
)
)
{
return
;
}
mActor
=
serviceActor
;
}
void
RemoteWorkerService
:
:
CloseActorOnTargetThread
(
)
{
MOZ_ASSERT
(
mThread
)
;
MOZ_ASSERT
(
mThread
-
>
IsOnCurrentThread
(
)
)
;
if
(
mActor
)
{
mActor
-
>
Send__delete__
(
mActor
)
;
mActor
=
nullptr
;
}
}
NS_IMETHODIMP
RemoteWorkerService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
profile
-
after
-
change
"
)
;
}
return
InitializeOnMainThread
(
)
;
}
void
RemoteWorkerService
:
:
BeginShutdown
(
)
{
auto
lockedKeepAlive
=
mKeepAlive
.
Lock
(
)
;
*
lockedKeepAlive
=
nullptr
;
}
void
RemoteWorkerService
:
:
FinishShutdown
(
)
{
{
StaticMutexAutoLock
lock
(
sRemoteWorkerServiceMutex
)
;
sRemoteWorkerService
=
nullptr
;
}
RefPtr
<
RemoteWorkerService
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
RemoteWorkerService
:
:
CloseActorOnTargetThread
"
[
self
]
(
)
{
self
-
>
CloseActorOnTargetThread
(
)
;
}
)
;
mThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
mThread
-
>
Shutdown
(
)
;
mThread
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
RemoteWorkerService
nsIObserver
)
}
}
