#
include
"
WorkerRef
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
WorkerHolder
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
WorkerPrivate
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
ReleaseRefControlRunnable
final
:
public
WorkerControlRunnable
{
public
:
ReleaseRefControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
already_AddRefed
<
StrongWorkerRef
>
aRef
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mRef
(
std
:
:
move
(
aRef
)
)
{
MOZ_ASSERT
(
mRef
)
;
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mRef
=
nullptr
;
return
true
;
}
private
:
RefPtr
<
StrongWorkerRef
>
mRef
;
}
;
}
class
WorkerRef
:
:
Holder
final
:
public
mozilla
:
:
dom
:
:
WorkerHolder
{
public
:
Holder
(
const
char
*
aName
WorkerRef
*
aWorkerRef
Behavior
aBehavior
)
:
mozilla
:
:
dom
:
:
WorkerHolder
(
aName
aBehavior
)
mWorkerRef
(
aWorkerRef
)
{
}
bool
Notify
(
WorkerStatus
aStatus
)
override
{
MOZ_ASSERT
(
mWorkerRef
)
;
if
(
aStatus
<
Canceling
)
{
return
true
;
}
RefPtr
<
WorkerRef
>
workerRef
;
workerRef
=
mWorkerRef
;
workerRef
-
>
Notify
(
)
;
return
true
;
}
public
:
WorkerRef
*
mWorkerRef
;
}
;
WorkerRef
:
:
WorkerRef
(
WorkerPrivate
*
aWorkerPrivate
)
:
mWorkerPrivate
(
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
WorkerRef
:
:
~
WorkerRef
(
)
{
NS_ASSERT_OWNINGTHREAD
(
WorkerRef
)
;
}
void
WorkerRef
:
:
Notify
(
)
{
MOZ_ASSERT
(
mHolder
)
;
NS_ASSERT_OWNINGTHREAD
(
WorkerRef
)
;
if
(
!
mCallback
)
{
return
;
}
std
:
:
function
<
void
(
)
>
callback
=
std
:
:
move
(
mCallback
)
;
MOZ_ASSERT
(
!
mCallback
)
;
callback
(
)
;
}
already_AddRefed
<
WeakWorkerRef
>
WeakWorkerRef
:
:
Create
(
WorkerPrivate
*
aWorkerPrivate
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
WeakWorkerRef
>
ref
=
new
WeakWorkerRef
(
aWorkerPrivate
)
;
UniquePtr
<
Holder
>
holder
(
new
Holder
(
"
WeakWorkerRef
:
:
Holder
"
ref
WorkerHolder
:
:
AllowIdleShutdownStart
)
)
;
if
(
NS_WARN_IF
(
!
holder
-
>
HoldWorker
(
aWorkerPrivate
Canceling
)
)
)
{
return
nullptr
;
}
ref
-
>
mHolder
=
std
:
:
move
(
holder
)
;
ref
-
>
mCallback
=
std
:
:
move
(
aCallback
)
;
return
ref
.
forget
(
)
;
}
WeakWorkerRef
:
:
WeakWorkerRef
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRef
(
aWorkerPrivate
)
{
}
WeakWorkerRef
:
:
~
WeakWorkerRef
(
)
=
default
;
void
WeakWorkerRef
:
:
Notify
(
)
{
WorkerRef
:
:
Notify
(
)
;
mHolder
=
nullptr
;
mWorkerPrivate
=
nullptr
;
}
WorkerPrivate
*
WeakWorkerRef
:
:
GetPrivate
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
WeakWorkerRef
)
;
return
mWorkerPrivate
;
}
WorkerPrivate
*
WeakWorkerRef
:
:
GetUnsafePrivate
(
)
const
{
return
mWorkerPrivate
;
}
already_AddRefed
<
StrongWorkerRef
>
StrongWorkerRef
:
:
Create
(
WorkerPrivate
*
const
aWorkerPrivate
const
char
*
const
aName
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
{
if
(
RefPtr
<
StrongWorkerRef
>
ref
=
CreateImpl
(
aWorkerPrivate
aName
Canceling
)
)
{
ref
-
>
mCallback
=
std
:
:
move
(
aCallback
)
;
return
ref
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
StrongWorkerRef
>
StrongWorkerRef
:
:
CreateForcibly
(
WorkerPrivate
*
const
aWorkerPrivate
const
char
*
const
aName
)
{
return
CreateImpl
(
aWorkerPrivate
aName
Killing
)
;
}
already_AddRefed
<
StrongWorkerRef
>
StrongWorkerRef
:
:
CreateImpl
(
WorkerPrivate
*
const
aWorkerPrivate
const
char
*
const
aName
WorkerStatus
const
aFailStatus
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aName
)
;
RefPtr
<
StrongWorkerRef
>
ref
=
new
StrongWorkerRef
(
aWorkerPrivate
)
;
UniquePtr
<
Holder
>
holder
(
new
Holder
(
aName
ref
WorkerHolder
:
:
PreventIdleShutdownStart
)
)
;
if
(
NS_WARN_IF
(
!
holder
-
>
HoldWorker
(
aWorkerPrivate
aFailStatus
)
)
)
{
return
nullptr
;
}
ref
-
>
mHolder
=
std
:
:
move
(
holder
)
;
return
ref
.
forget
(
)
;
}
StrongWorkerRef
:
:
StrongWorkerRef
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRef
(
aWorkerPrivate
)
{
}
StrongWorkerRef
:
:
~
StrongWorkerRef
(
)
{
NS_ASSERT_OWNINGTHREAD
(
StrongWorkerRef
)
;
}
WorkerPrivate
*
StrongWorkerRef
:
:
Private
(
)
const
{
MOZ_ASSERT
(
mHolder
)
;
NS_ASSERT_OWNINGTHREAD
(
StrongWorkerRef
)
;
return
mWorkerPrivate
;
}
ThreadSafeWorkerRef
:
:
ThreadSafeWorkerRef
(
StrongWorkerRef
*
aRef
)
:
mRef
(
aRef
)
{
MOZ_ASSERT
(
aRef
)
;
aRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
}
ThreadSafeWorkerRef
:
:
~
ThreadSafeWorkerRef
(
)
{
if
(
!
mRef
-
>
mWorkerPrivate
-
>
IsOnWorkerThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
mRef
-
>
mWorkerPrivate
;
RefPtr
<
ReleaseRefControlRunnable
>
r
=
new
ReleaseRefControlRunnable
(
workerPrivate
mRef
.
forget
(
)
)
;
r
-
>
Dispatch
(
)
;
return
;
}
}
WorkerPrivate
*
ThreadSafeWorkerRef
:
:
Private
(
)
const
{
return
mRef
-
>
mWorkerPrivate
;
}
already_AddRefed
<
IPCWorkerRef
>
IPCWorkerRef
:
:
Create
(
WorkerPrivate
*
aWorkerPrivate
const
char
*
aName
std
:
:
function
<
void
(
)
>
&
&
aCallback
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
IPCWorkerRef
>
ref
=
new
IPCWorkerRef
(
aWorkerPrivate
)
;
UniquePtr
<
Holder
>
holder
(
new
Holder
(
aName
ref
WorkerHolder
:
:
AllowIdleShutdownStart
)
)
;
if
(
NS_WARN_IF
(
!
holder
-
>
HoldWorker
(
aWorkerPrivate
Canceling
)
)
)
{
return
nullptr
;
}
ref
-
>
mHolder
=
std
:
:
move
(
holder
)
;
ref
-
>
mCallback
=
std
:
:
move
(
aCallback
)
;
return
ref
.
forget
(
)
;
}
IPCWorkerRef
:
:
IPCWorkerRef
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRef
(
aWorkerPrivate
)
{
}
IPCWorkerRef
:
:
~
IPCWorkerRef
(
)
=
default
;
WorkerPrivate
*
IPCWorkerRef
:
:
Private
(
)
const
{
MOZ_ASSERT
(
mHolder
)
;
NS_ASSERT_OWNINGTHREAD
(
IPCWorkerRef
)
;
return
mWorkerPrivate
;
}
}
}
