#
ifndef
mozilla_dom_workers_scriptloader_h__
#
define
mozilla_dom_workers_scriptloader_h__
#
include
"
js
/
loader
/
ScriptLoadRequest
.
h
"
#
include
"
js
/
loader
/
ModuleLoadRequest
.
h
"
#
include
"
js
/
loader
/
ModuleLoaderBase
.
h
"
#
include
"
mozilla
/
dom
/
WorkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerLoadContext
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
workerinternals
/
WorkerModuleLoader
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
class
nsIChannel
;
class
nsICookieJarSettings
;
class
nsILoadGroup
;
class
nsIPrincipal
;
class
nsIReferrerInfo
;
class
nsIURI
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
ClientInfo
;
class
Document
;
struct
WorkerLoadInfo
;
class
WorkerPrivate
;
class
SerializedStackHolder
;
enum
WorkerScriptType
{
WorkerScript
DebuggerScript
}
;
namespace
workerinternals
{
namespace
loader
{
class
ScriptExecutorRunnable
;
class
ScriptLoaderRunnable
;
class
CachePromiseHandler
;
class
CacheLoadHandler
;
class
CacheCreator
;
class
NetworkLoadHandler
;
class
WorkerScriptLoader
:
public
JS
:
:
loader
:
:
ScriptLoaderInterface
public
nsINamed
{
friend
class
ScriptExecutorRunnable
;
friend
class
ScriptLoaderRunnable
;
friend
class
CachePromiseHandler
;
friend
class
CacheLoadHandler
;
friend
class
CacheCreator
;
friend
class
NetworkLoadHandler
;
friend
class
WorkerModuleLoader
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
UniquePtr
<
SerializedStackHolder
>
mOriginStack
;
nsString
mOriginStackJSON
;
nsCOMPtr
<
nsISerialEventTarget
>
mSyncLoopTarget
;
ScriptLoadRequestList
mLoadingRequests
;
ScriptLoadRequestList
mLoadedRequests
;
Maybe
<
ServiceWorkerDescriptor
>
mController
;
WorkerScriptType
mWorkerScriptType
;
ErrorResult
&
mRv
;
bool
mExecutionAborted
=
false
;
bool
mMutedErrorFlag
=
false
;
uint32_t
mLoadingModuleRequestCount
;
bool
mCleanedUp
MOZ_GUARDED_BY
(
mCleanUpLock
)
;
Mutex
&
CleanUpLock
(
)
MOZ_RETURN_CAPABILITY
(
mCleanUpLock
)
{
return
mCleanUpLock
;
}
bool
CleanedUp
(
)
const
MOZ_REQUIRES
(
mCleanUpLock
)
{
mCleanUpLock
.
AssertCurrentThreadOwns
(
)
;
return
mCleanedUp
;
}
Mutex
mCleanUpLock
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
static
already_AddRefed
<
WorkerScriptLoader
>
Create
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
nsISerialEventTarget
*
aSyncLoopTarget
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
)
;
bool
CreateScriptRequests
(
const
nsTArray
<
nsString
>
&
aScriptURLs
const
mozilla
:
:
Encoding
*
aDocumentEncoding
bool
aIsMainScript
)
;
ScriptLoadRequest
*
GetMainScript
(
)
;
already_AddRefed
<
ScriptLoadRequest
>
CreateScriptLoadRequest
(
const
nsString
&
aScriptURL
const
mozilla
:
:
Encoding
*
aDocumentEncoding
bool
aIsMainScript
)
;
bool
DispatchLoadScript
(
ScriptLoadRequest
*
aRequest
)
;
bool
DispatchLoadScripts
(
)
;
void
TryShutdown
(
)
;
WorkerScriptType
GetWorkerScriptType
(
)
{
return
mWorkerScriptType
;
}
protected
:
nsIURI
*
GetBaseURI
(
)
const
override
;
nsIURI
*
GetInitialBaseURI
(
)
;
nsIGlobalObject
*
GetGlobal
(
)
;
void
MaybeMoveToLoadedList
(
ScriptLoadRequest
*
aRequest
)
;
bool
StoreCSP
(
)
;
bool
ProcessPendingRequests
(
JSContext
*
aCx
)
;
bool
AllScriptsExecuted
(
)
{
return
mLoadingRequests
.
isEmpty
(
)
&
&
mLoadedRequests
.
isEmpty
(
)
;
}
bool
IsDebuggerScript
(
)
const
{
return
mWorkerScriptType
=
=
DebuggerScript
;
}
void
SetController
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aDescriptor
)
{
mController
=
aDescriptor
;
}
Maybe
<
ServiceWorkerDescriptor
>
&
GetController
(
)
{
return
mController
;
}
nsresult
LoadScript
(
ThreadSafeRequestHandle
*
aRequestHandle
)
;
void
ShutdownScriptLoader
(
bool
aResult
bool
aMutedError
)
;
private
:
WorkerScriptLoader
(
UniquePtr
<
SerializedStackHolder
>
aOriginStack
nsISerialEventTarget
*
aSyncLoopTarget
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
)
;
~
WorkerScriptLoader
(
)
=
default
;
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
WorkerScriptLoader
"
)
;
return
NS_OK
;
}
void
InitModuleLoader
(
)
;
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
GetLoadingList
(
)
;
bool
IsDynamicImport
(
ScriptLoadRequest
*
aRequest
)
;
nsContentPolicyType
GetContentPolicyType
(
ScriptLoadRequest
*
aRequest
)
;
bool
EvaluateScript
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
)
;
nsresult
FillCompileOptionsForRequest
(
JSContext
*
cx
ScriptLoadRequest
*
aRequest
JS
:
:
CompileOptions
*
aOptions
JS
:
:
MutableHandle
<
JSScript
*
>
aIntroductionScript
)
override
;
void
ReportErrorToConsole
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
const
override
;
void
ReportWarningToConsole
(
ScriptLoadRequest
*
aRequest
const
char
*
aMessageName
const
nsTArray
<
nsString
>
&
aParams
=
nsTArray
<
nsString
>
(
)
)
const
override
{
MOZ_CRASH
(
"
Import
maps
have
not
been
implemented
for
this
context
"
)
;
}
void
LogExceptionToConsole
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
bool
AllModuleRequestsLoaded
(
)
const
;
void
IncreaseLoadingModuleRequestCount
(
)
;
void
DecreaseLoadingModuleRequestCount
(
)
;
}
;
class
ScriptLoaderRunnable
final
:
public
nsIRunnable
public
nsINamed
{
RefPtr
<
WorkerScriptLoader
>
mScriptLoader
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
nsTArrayView
<
RefPtr
<
ThreadSafeRequestHandle
>
>
mLoadingRequests
;
Maybe
<
nsresult
>
mCancelMainThread
;
RefPtr
<
CacheCreator
>
mCacheCreator
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
explicit
ScriptLoaderRunnable
(
WorkerScriptLoader
*
aScriptLoader
nsTArray
<
RefPtr
<
ThreadSafeRequestHandle
>
>
aLoadingRequests
)
;
nsresult
OnStreamComplete
(
ThreadSafeRequestHandle
*
aRequestHandle
nsresult
aStatus
)
;
void
LoadingFinished
(
ThreadSafeRequestHandle
*
aRequestHandle
nsresult
aRv
)
;
void
MaybeExecuteFinishedScripts
(
ThreadSafeRequestHandle
*
aRequestHandle
)
;
bool
IsCancelled
(
)
{
return
mCancelMainThread
.
isSome
(
)
;
}
nsresult
GetCancelResult
(
)
{
return
(
IsCancelled
(
)
)
?
mCancelMainThread
.
ref
(
)
:
NS_OK
;
}
void
CancelMainThreadWithBindingAborted
(
)
;
CacheCreator
*
GetCacheCreator
(
)
{
return
mCacheCreator
;
}
;
private
:
~
ScriptLoaderRunnable
(
)
=
default
;
void
CancelMainThread
(
nsresult
aCancelResult
)
;
void
DispatchProcessPendingRequests
(
)
;
NS_IMETHOD
Run
(
)
override
;
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
ScriptLoaderRunnable
"
)
;
return
NS_OK
;
}
}
;
}
nsresult
ChannelFromScriptURLMainThread
(
nsIPrincipal
*
aPrincipal
Document
*
aParentDoc
nsILoadGroup
*
aLoadGroup
nsIURI
*
aScriptURL
const
WorkerType
&
aWorkerType
const
RequestCredentials
&
aCredentials
const
Maybe
<
ClientInfo
>
&
aClientInfo
nsContentPolicyType
aContentPolicyType
nsICookieJarSettings
*
aCookieJarSettings
nsIReferrerInfo
*
aReferrerInfo
nsIChannel
*
*
aChannel
)
;
nsresult
ChannelFromScriptURLWorkerThread
(
JSContext
*
aCx
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
const
WorkerType
&
aWorkerType
const
RequestCredentials
&
aCredentials
WorkerLoadInfo
&
aLoadInfo
)
;
void
ReportLoadError
(
ErrorResult
&
aRv
nsresult
aLoadResult
const
nsAString
&
aScriptURL
)
;
void
LoadMainScript
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
const
nsAString
&
aScriptURL
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
const
mozilla
:
:
Encoding
*
aDocumentEncoding
)
;
void
Load
(
WorkerPrivate
*
aWorkerPrivate
UniquePtr
<
SerializedStackHolder
>
aOriginStack
const
nsTArray
<
nsString
>
&
aScriptURLs
WorkerScriptType
aWorkerScriptType
ErrorResult
&
aRv
)
;
}
}
}
#
endif
