#
include
"
ServiceWorkerPrivate
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
dom
/
FetchUtil
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
BEGIN_WORKERS_NAMESPACE
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ServiceWorkerPrivate
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ServiceWorkerPrivate
)
NS_IMPL_CYCLE_COLLECTION
(
ServiceWorkerPrivate
mSupportsArray
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ServiceWorkerPrivate
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
Atomic
<
uint32_t
>
gDOMDisableOpenClickDelay
(
0
)
;
class
KeepAliveToken
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveToken
(
ServiceWorkerPrivate
*
aPrivate
)
:
mPrivate
(
aPrivate
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrivate
)
;
mPrivate
-
>
AddToken
(
)
;
}
private
:
~
KeepAliveToken
(
)
{
AssertIsOnMainThread
(
)
;
mPrivate
-
>
ReleaseToken
(
)
;
}
RefPtr
<
ServiceWorkerPrivate
>
mPrivate
;
}
;
NS_IMPL_ISUPPORTS0
(
KeepAliveToken
)
ServiceWorkerPrivate
:
:
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
:
mInfo
(
aInfo
)
mIsPushWorker
(
false
)
mDebuggerCount
(
0
)
mTokenCount
(
0
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aInfo
)
;
mIdleWorkerTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
MOZ_ASSERT
(
mIdleWorkerTimer
)
;
}
ServiceWorkerPrivate
:
:
~
ServiceWorkerPrivate
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mTokenCount
)
;
MOZ_ASSERT
(
!
mInfo
)
;
MOZ_ASSERT
(
mSupportsArray
.
IsEmpty
(
)
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
}
nsresult
ServiceWorkerPrivate
:
:
SendMessageEvent
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
)
{
ErrorResult
rv
(
SpawnWorkerIfNeeded
(
MessageEvent
nullptr
)
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
mWorkerPrivate
-
>
PostMessageToServiceWorker
(
aCx
aMessage
aTransferable
Move
(
aClientInfo
)
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
namespace
{
class
CheckScriptEvaluationWithCallback
final
:
public
WorkerRunnable
{
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
RefPtr
<
LifeCycleEventCallback
>
mCallback
;
DebugOnly
<
bool
>
mDone
;
public
:
CheckScriptEvaluationWithCallback
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
LifeCycleEventCallback
*
aCallback
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
mKeepAliveToken
(
new
nsMainThreadPtrHolder
<
KeepAliveToken
>
(
aKeepAliveToken
)
)
mCallback
(
aCallback
)
mDone
(
false
)
{
AssertIsOnMainThread
(
)
;
}
~
CheckScriptEvaluationWithCallback
(
)
{
MOZ_ASSERT
(
mDone
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
Done
(
aWorkerPrivate
-
>
WorkerScriptExecutedSuccessfully
(
)
)
;
return
true
;
}
NS_IMETHOD
Cancel
(
)
override
{
Done
(
false
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
private
:
void
Done
(
bool
aResult
)
{
mDone
=
true
;
mCallback
-
>
SetResult
(
aResult
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
mCallback
)
)
)
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
CheckScriptEvaluation
(
LifeCycleEventCallback
*
aCallback
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
LifeCycleEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
CheckScriptEvaluationWithCallback
(
mWorkerPrivate
mKeepAliveToken
aCallback
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
KeepAliveHandler
final
:
public
PromiseNativeHandler
{
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
virtual
~
KeepAliveHandler
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveHandler
(
const
nsMainThreadPtrHandle
<
KeepAliveToken
>
&
aKeepAliveToken
)
:
mKeepAliveToken
(
aKeepAliveToken
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
#
ifdef
DEBUG
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
#
endif
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
#
ifdef
DEBUG
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
#
endif
}
}
;
NS_IMPL_ISUPPORTS0
(
KeepAliveHandler
)
class
RegistrationUpdateRunnable
:
public
nsRunnable
{
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
const
bool
mNeedTimeCheck
;
public
:
RegistrationUpdateRunnable
(
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
bool
aNeedTimeCheck
)
:
mRegistration
(
aRegistration
)
mNeedTimeCheck
(
aNeedTimeCheck
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mNeedTimeCheck
)
{
mRegistration
-
>
MaybeScheduleTimeCheckAndUpdate
(
)
;
}
else
{
mRegistration
-
>
MaybeScheduleUpdate
(
)
;
}
return
NS_OK
;
}
}
;
class
ExtendableEventWorkerRunnable
:
public
WorkerRunnable
{
protected
:
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
public
:
ExtendableEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aKeepAliveToken
)
;
mKeepAliveToken
=
new
nsMainThreadPtrHolder
<
KeepAliveToken
>
(
aKeepAliveToken
)
;
}
void
DispatchExtendableEventOnWorkerScope
(
JSContext
*
aCx
WorkerGlobalScope
*
aWorkerScope
ExtendableEvent
*
aEvent
Promise
*
*
aWaitUntilPromise
)
{
MOZ_ASSERT
(
aWorkerScope
)
;
MOZ_ASSERT
(
aEvent
)
;
nsCOMPtr
<
nsIGlobalObject
>
sgo
=
aWorkerScope
;
WidgetEvent
*
internalEvent
=
aEvent
-
>
GetInternalNSEvent
(
)
;
ErrorResult
result
;
result
=
aWorkerScope
-
>
DispatchDOMEvent
(
nullptr
aEvent
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
internalEvent
-
>
mFlags
.
mExceptionHasBeenRisen
)
{
result
.
SuppressException
(
)
;
return
;
}
RefPtr
<
Promise
>
waitUntilPromise
=
aEvent
-
>
GetPromise
(
)
;
if
(
!
waitUntilPromise
)
{
waitUntilPromise
=
Promise
:
:
Resolve
(
sgo
aCx
JS
:
:
UndefinedHandleValue
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
;
}
}
MOZ_ASSERT
(
waitUntilPromise
)
;
RefPtr
<
KeepAliveHandler
>
keepAliveHandler
=
new
KeepAliveHandler
(
mKeepAliveToken
)
;
waitUntilPromise
-
>
AppendNativeHandler
(
keepAliveHandler
)
;
if
(
aWaitUntilPromise
)
{
waitUntilPromise
.
forget
(
aWaitUntilPromise
)
;
}
}
}
;
class
ExtendableFunctionalEventWorkerRunnable
:
public
ExtendableEventWorkerRunnable
{
protected
:
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
public
:
ExtendableFunctionalEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mRegistration
(
aRegistration
)
{
MOZ_ASSERT
(
aRegistration
)
;
}
void
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
RegistrationUpdateRunnable
(
mRegistration
true
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
}
;
class
LifecycleEventWorkerRunnable
:
public
ExtendableEventWorkerRunnable
{
nsString
mEventName
;
RefPtr
<
LifeCycleEventCallback
>
mCallback
;
public
:
LifecycleEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aToken
const
nsAString
&
aEventName
LifeCycleEventCallback
*
aCallback
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aToken
)
mEventName
(
aEventName
)
mCallback
(
aCallback
)
{
AssertIsOnMainThread
(
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
return
DispatchLifecycleEvent
(
aCx
aWorkerPrivate
)
;
}
NS_IMETHOD
Cancel
(
)
override
{
mCallback
-
>
SetResult
(
false
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
mCallback
)
)
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
private
:
bool
DispatchLifecycleEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
}
;
class
LifeCycleEventWatcher
final
:
public
PromiseNativeHandler
public
WorkerFeature
{
WorkerPrivate
*
mWorkerPrivate
;
RefPtr
<
LifeCycleEventCallback
>
mCallback
;
bool
mDone
;
~
LifeCycleEventWatcher
(
)
{
if
(
mDone
)
{
return
;
}
MOZ_ASSERT
(
GetCurrentThreadWorkerPrivate
(
)
=
=
mWorkerPrivate
)
;
JSContext
*
cx
=
mWorkerPrivate
-
>
GetJSContext
(
)
;
ReportResult
(
cx
false
)
;
}
public
:
NS_DECL_ISUPPORTS
LifeCycleEventWatcher
(
WorkerPrivate
*
aWorkerPrivate
LifeCycleEventCallback
*
aCallback
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mCallback
(
aCallback
)
mDone
(
false
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
bool
Init
(
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
JSContext
*
cx
=
mWorkerPrivate
-
>
GetJSContext
(
)
;
if
(
NS_WARN_IF
(
!
mWorkerPrivate
-
>
AddFeature
(
cx
this
)
)
)
{
NS_WARNING
(
"
LifeCycleEventWatcher
failed
to
add
feature
.
"
)
;
ReportResult
(
cx
false
)
;
return
false
;
}
return
true
;
}
bool
Notify
(
JSContext
*
aCx
Status
aStatus
)
override
{
if
(
aStatus
<
Terminating
)
{
return
true
;
}
MOZ_ASSERT
(
GetCurrentThreadWorkerPrivate
(
)
=
=
mWorkerPrivate
)
;
ReportResult
(
aCx
false
)
;
return
true
;
}
void
ReportResult
(
JSContext
*
aCx
bool
aResult
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
mDone
)
{
return
;
}
mDone
=
true
;
mCallback
-
>
SetResult
(
aResult
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
mCallback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_RUNTIMEABORT
(
"
Failed
to
dispatch
life
cycle
event
handler
.
"
)
;
}
mWorkerPrivate
-
>
RemoveFeature
(
aCx
this
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
GetCurrentThreadWorkerPrivate
(
)
=
=
mWorkerPrivate
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
ReportResult
(
aCx
true
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
GetCurrentThreadWorkerPrivate
(
)
=
=
mWorkerPrivate
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
ReportResult
(
aCx
false
)
;
}
}
;
NS_IMPL_ISUPPORTS0
(
LifeCycleEventWatcher
)
bool
LifecycleEventWorkerRunnable
:
:
DispatchLifecycleEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
RefPtr
<
ExtendableEvent
>
event
;
RefPtr
<
EventTarget
>
target
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
if
(
mEventName
.
EqualsASCII
(
"
install
"
)
|
|
mEventName
.
EqualsASCII
(
"
activate
"
)
)
{
ExtendableEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
event
=
ExtendableEvent
:
:
Constructor
(
target
mEventName
init
)
;
}
else
{
MOZ_CRASH
(
"
Unexpected
lifecycle
event
"
)
;
}
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
LifeCycleEventWatcher
>
watcher
=
new
LifeCycleEventWatcher
(
aWorkerPrivate
mCallback
)
;
if
(
!
watcher
-
>
Init
(
)
)
{
return
true
;
}
RefPtr
<
Promise
>
waitUntil
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
getter_AddRefs
(
waitUntil
)
)
;
if
(
waitUntil
)
{
waitUntil
-
>
AppendNativeHandler
(
watcher
)
;
}
else
{
watcher
-
>
ReportResult
(
aCx
false
)
;
}
return
true
;
}
}
nsresult
ServiceWorkerPrivate
:
:
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
nsIRunnable
*
aLoadFailure
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
LifeCycleEvent
aLoadFailure
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
LifecycleEventWorkerRunnable
(
mWorkerPrivate
mKeepAliveToken
aEventType
aCallback
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
#
ifndef
MOZ_SIMPLEPUSH
namespace
{
class
SendPushEventRunnable
final
:
public
ExtendableFunctionalEventWorkerRunnable
{
Maybe
<
nsTArray
<
uint8_t
>
>
mData
;
public
:
SendPushEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
aRegistration
)
:
ExtendableFunctionalEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
aRegistration
)
mData
(
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
GlobalObject
globalObj
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
PushEventInit
pei
;
if
(
mData
)
{
const
nsTArray
<
uint8_t
>
&
bytes
=
mData
.
ref
(
)
;
JSObject
*
data
=
Uint8Array
:
:
Create
(
aCx
bytes
.
Length
(
)
bytes
.
Elements
(
)
)
;
if
(
!
data
)
{
return
false
;
}
pei
.
mData
.
Construct
(
)
.
SetAsArrayBufferView
(
)
.
Init
(
data
)
;
}
pei
.
mBubbles
=
false
;
pei
.
mCancelable
=
false
;
ErrorResult
result
;
RefPtr
<
PushEvent
>
event
=
PushEvent
:
:
Constructor
(
globalObj
NS_LITERAL_STRING
(
"
push
"
)
pei
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
nullptr
)
;
return
true
;
}
}
;
class
SendPushSubscriptionChangeEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
public
:
explicit
SendPushSubscriptionChangeEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
RefPtr
<
EventTarget
>
target
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
ExtendableEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
ExtendableEvent
>
event
=
ExtendableEvent
:
:
Constructor
(
target
NS_LITERAL_STRING
(
"
pushsubscriptionchange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
nullptr
)
;
return
true
;
}
}
;
}
#
endif
nsresult
ServiceWorkerPrivate
:
:
SendPushEvent
(
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
ServiceWorkerRegistrationInfo
*
aRegistration
)
{
#
ifdef
MOZ_SIMPLEPUSH
return
NS_ERROR_NOT_AVAILABLE
;
#
else
nsresult
rv
=
SpawnWorkerIfNeeded
(
PushEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
regInfo
(
new
nsMainThreadPtrHolder
<
ServiceWorkerRegistrationInfo
>
(
aRegistration
false
)
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
SendPushEventRunnable
(
mWorkerPrivate
mKeepAliveToken
aData
regInfo
)
;
if
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activating
)
{
mPendingFunctionalEvents
.
AppendElement
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activated
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
#
endif
}
nsresult
ServiceWorkerPrivate
:
:
SendPushSubscriptionChangeEvent
(
)
{
#
ifdef
MOZ_SIMPLEPUSH
return
NS_ERROR_NOT_AVAILABLE
;
#
else
nsresult
rv
=
SpawnWorkerIfNeeded
(
PushSubscriptionChangeEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
SendPushSubscriptionChangeEventRunnable
(
mWorkerPrivate
mKeepAliveToken
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
#
endif
}
namespace
{
static
void
DummyNotificationTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
}
class
AllowWindowInteractionHandler
;
class
ClearWindowAllowedRunnable
final
:
public
WorkerRunnable
{
public
:
ClearWindowAllowedRunnable
(
WorkerPrivate
*
aWorkerPrivate
AllowWindowInteractionHandler
*
aHandler
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mHandler
(
aHandler
)
{
}
private
:
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
;
RefPtr
<
AllowWindowInteractionHandler
>
mHandler
;
}
;
class
AllowWindowInteractionHandler
final
:
public
PromiseNativeHandler
{
friend
class
ClearWindowAllowedRunnable
;
nsCOMPtr
<
nsITimer
>
mTimer
;
~
AllowWindowInteractionHandler
(
)
{
}
void
ClearWindowAllowed
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
!
mTimer
)
{
return
;
}
WorkerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
if
(
!
globalScope
)
{
return
;
}
globalScope
-
>
ConsumeWindowInteraction
(
)
;
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
MOZ_ALWAYS_TRUE
(
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
aWorkerPrivate
-
>
GetJSContext
(
)
false
)
)
;
}
void
StartClearWindowTimer
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mTimer
)
;
nsresult
rv
;
nsCOMPtr
<
nsITimer
>
timer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
RefPtr
<
ClearWindowAllowedRunnable
>
r
=
new
ClearWindowAllowedRunnable
(
aWorkerPrivate
this
)
;
RefPtr
<
TimerThreadEventTarget
>
target
=
new
TimerThreadEventTarget
(
aWorkerPrivate
r
)
;
rv
=
timer
-
>
SetTarget
(
target
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
aWorkerPrivate
-
>
GetJSContext
(
)
true
)
)
)
{
return
;
}
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
AllowWindowInteraction
(
)
;
timer
.
swap
(
mTimer
)
;
rv
=
mTimer
-
>
InitWithFuncCallback
(
DummyNotificationTimerCallback
nullptr
gDOMDisableOpenClickDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ClearWindowAllowed
(
aWorkerPrivate
)
;
return
;
}
}
public
:
NS_DECL_ISUPPORTS
explicit
AllowWindowInteractionHandler
(
WorkerPrivate
*
aWorkerPrivate
)
{
StartClearWindowTimer
(
aWorkerPrivate
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
ClearWindowAllowed
(
workerPrivate
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
ClearWindowAllowed
(
workerPrivate
)
;
}
}
;
NS_IMPL_ISUPPORTS0
(
AllowWindowInteractionHandler
)
bool
ClearWindowAllowedRunnable
:
:
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
mHandler
-
>
ClearWindowAllowed
(
aWorkerPrivate
)
;
return
true
;
}
class
SendNotificationClickEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
const
nsString
mID
;
const
nsString
mTitle
;
const
nsString
mDir
;
const
nsString
mLang
;
const
nsString
mBody
;
const
nsString
mTag
;
const
nsString
mIcon
;
const
nsString
mData
;
const
nsString
mBehavior
;
const
nsString
mScope
;
public
:
SendNotificationClickEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mID
(
aID
)
mTitle
(
aTitle
)
mDir
(
aDir
)
mLang
(
aLang
)
mBody
(
aBody
)
mTag
(
aTag
)
mIcon
(
aIcon
)
mData
(
aData
)
mBehavior
(
aBehavior
)
mScope
(
aScope
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
RefPtr
<
EventTarget
>
target
=
do_QueryObject
(
aWorkerPrivate
-
>
GlobalScope
(
)
)
;
ErrorResult
result
;
RefPtr
<
Notification
>
notification
=
Notification
:
:
ConstructFromFields
(
aWorkerPrivate
-
>
GlobalScope
(
)
mID
mTitle
mDir
mLang
mBody
mTag
mIcon
mData
mScope
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
false
;
}
NotificationEventInit
nei
;
nei
.
mNotification
=
notification
;
nei
.
mBubbles
=
false
;
nei
.
mCancelable
=
false
;
RefPtr
<
NotificationEvent
>
event
=
NotificationEvent
:
:
Constructor
(
target
NS_LITERAL_STRING
(
"
notificationclick
"
)
nei
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
Promise
>
waitUntil
;
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
AllowWindowInteraction
(
)
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
getter_AddRefs
(
waitUntil
)
)
;
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
ConsumeWindowInteraction
(
)
;
if
(
waitUntil
)
{
RefPtr
<
AllowWindowInteractionHandler
>
allowWindowInteraction
=
new
AllowWindowInteractionHandler
(
aWorkerPrivate
)
;
waitUntil
-
>
AppendNativeHandler
(
allowWindowInteraction
)
;
}
return
true
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
SendNotificationClickEvent
(
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
NotificationClickEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
gDOMDisableOpenClickDelay
=
Preferences
:
:
GetInt
(
"
dom
.
disable_open_click_delay
"
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
SendNotificationClickEventRunnable
(
mWorkerPrivate
mKeepAliveToken
aID
aTitle
aDir
aLang
aBody
aTag
aIcon
aData
aBehavior
aScope
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
FetchEventRunnable
:
public
ExtendableFunctionalEventWorkerRunnable
public
nsIHttpHeaderVisitor
{
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
mInterceptedChannel
;
const
nsCString
mScriptSpec
;
nsTArray
<
nsCString
>
mHeaderNames
;
nsTArray
<
nsCString
>
mHeaderValues
;
nsCString
mSpec
;
nsCString
mMethod
;
nsString
mClientId
;
bool
mIsReload
;
DebugOnly
<
bool
>
mIsHttpChannel
;
RequestMode
mRequestMode
;
RequestRedirect
mRequestRedirect
;
RequestCredentials
mRequestCredentials
;
nsContentPolicyType
mContentPolicyType
;
nsCOMPtr
<
nsIInputStream
>
mUploadStream
;
nsCString
mReferrer
;
public
:
FetchEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
&
aChannel
const
nsACString
&
aScriptSpec
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
const
nsAString
&
aDocumentId
bool
aIsReload
)
:
ExtendableFunctionalEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
aRegistration
)
mInterceptedChannel
(
aChannel
)
mScriptSpec
(
aScriptSpec
)
mClientId
(
aDocumentId
)
mIsReload
(
aIsReload
)
mIsHttpChannel
(
false
)
mRequestMode
(
RequestMode
:
:
No_cors
)
mRequestRedirect
(
RequestRedirect
:
:
Follow
)
mRequestCredentials
(
RequestCredentials
:
:
Same_origin
)
mContentPolicyType
(
nsIContentPolicy
:
:
TYPE_INVALID
)
mReferrer
(
kFETCH_CLIENT_REFERRER_STR
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
mHeaderNames
.
AppendElement
(
aHeader
)
;
mHeaderValues
.
AppendElement
(
aValue
)
;
return
NS_OK
;
}
nsresult
Init
(
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
mInterceptedChannel
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
mInterceptedChannel
-
>
GetSecureUpgradedChannelURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uri
-
>
GetSpec
(
mSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
loadFlags
;
rv
=
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
channel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mContentPolicyType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
nsCOMPtr
<
nsIURI
>
referrerURI
;
rv
=
NS_GetReferrerFromChannel
(
channel
getter_AddRefs
(
referrerURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
referrerURI
)
{
rv
=
referrerURI
-
>
GetSpec
(
mReferrer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
;
if
(
httpChannel
)
{
mIsHttpChannel
=
true
;
rv
=
httpChannel
-
>
GetRequestMethod
(
mMethod
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
httpChannel
)
;
NS_ENSURE_TRUE
(
internalChannel
NS_ERROR_NOT_AVAILABLE
)
;
mRequestMode
=
InternalRequest
:
:
MapChannelToRequestMode
(
channel
)
;
uint32_t
redirectMode
;
internalChannel
-
>
GetRedirectMode
(
&
redirectMode
)
;
mRequestRedirect
=
static_cast
<
RequestRedirect
>
(
redirectMode
)
;
mRequestCredentials
=
InternalRequest
:
:
MapChannelToRequestCredentials
(
channel
)
;
rv
=
httpChannel
-
>
VisitNonDefaultRequestHeaders
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
uploadChannel
)
{
MOZ_ASSERT
(
!
mUploadStream
)
;
bool
bodyHasHeaders
=
false
;
rv
=
uploadChannel
-
>
GetUploadStreamHasHeaders
(
&
bodyHasHeaders
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
uploadStream
;
rv
=
uploadChannel
-
>
CloneUploadStream
(
getter_AddRefs
(
uploadStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
bodyHasHeaders
)
{
HandleBodyWithHeaders
(
uploadStream
)
;
}
else
{
mUploadStream
=
uploadStream
;
}
}
}
else
{
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
channel
)
;
NS_ENSURE_TRUE
(
jarChannel
NS_ERROR_NOT_AVAILABLE
)
;
mMethod
=
"
GET
"
;
mRequestMode
=
InternalRequest
:
:
MapChannelToRequestMode
(
channel
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
{
mRequestCredentials
=
RequestCredentials
:
:
Omit
;
}
}
return
NS_OK
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
return
DispatchFetchEvent
(
aCx
aWorkerPrivate
)
;
}
NS_IMETHOD
Cancel
(
)
override
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ResumeRequest
(
mInterceptedChannel
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
)
)
)
{
NS_WARNING
(
"
Failed
to
resume
channel
on
FetchEventRunnable
:
:
Cancel
(
)
!
\
n
"
)
;
}
WorkerRunnable
:
:
Cancel
(
)
;
return
NS_OK
;
}
private
:
~
FetchEventRunnable
(
)
{
}
class
ResumeRequest
final
:
public
nsRunnable
{
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
mChannel
;
public
:
explicit
ResumeRequest
(
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
&
aChannel
)
:
mChannel
(
aChannel
)
{
}
NS_IMETHOD
Run
(
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
=
mChannel
-
>
ResetInterception
(
)
;
NS_WARN_IF_FALSE
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
resume
intercepted
network
request
"
)
;
return
rv
;
}
}
;
bool
DispatchFetchEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
GlobalObject
globalObj
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
RefPtr
<
InternalHeaders
>
internalHeaders
=
new
InternalHeaders
(
HeadersGuardEnum
:
:
Request
)
;
MOZ_ASSERT
(
mHeaderNames
.
Length
(
)
=
=
mHeaderValues
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mHeaderNames
.
Length
(
)
;
i
+
+
)
{
ErrorResult
result
;
internalHeaders
-
>
Set
(
mHeaderNames
[
i
]
mHeaderValues
[
i
]
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
}
ErrorResult
result
;
internalHeaders
-
>
SetGuard
(
HeadersGuardEnum
:
:
Immutable
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
RefPtr
<
InternalRequest
>
internalReq
=
new
InternalRequest
(
mSpec
mMethod
internalHeaders
.
forget
(
)
mRequestMode
mRequestRedirect
mRequestCredentials
NS_ConvertUTF8toUTF16
(
mReferrer
)
mContentPolicyType
)
;
internalReq
-
>
SetBody
(
mUploadStream
)
;
internalReq
-
>
SetCreatedByFetchEvent
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
globalObj
.
GetAsSupports
(
)
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
false
;
}
RefPtr
<
Request
>
request
=
new
Request
(
global
internalReq
)
;
MOZ_ASSERT_IF
(
mIsHttpChannel
&
&
internalReq
-
>
IsNavigationRequest
(
)
request
-
>
Redirect
(
)
=
=
RequestRedirect
:
:
Manual
)
;
RootedDictionary
<
FetchEventInit
>
init
(
aCx
)
;
init
.
mRequest
=
request
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
true
;
if
(
!
mClientId
.
IsEmpty
(
)
)
{
init
.
mClientId
=
mClientId
;
}
init
.
mIsReload
=
mIsReload
;
RefPtr
<
FetchEvent
>
event
=
FetchEvent
:
:
Constructor
(
globalObj
NS_LITERAL_STRING
(
"
fetch
"
)
init
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
event
-
>
PostInit
(
mInterceptedChannel
mScriptSpec
)
;
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
EventTarget
>
target
=
do_QueryObject
(
aWorkerPrivate
-
>
GlobalScope
(
)
)
;
nsresult
rv2
=
target
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv2
)
)
|
|
!
event
-
>
WaitToRespond
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
;
if
(
event
-
>
DefaultPrevented
(
aCx
)
)
{
event
-
>
ReportCanceled
(
)
;
}
else
if
(
event
-
>
GetInternalNSEvent
(
)
-
>
mFlags
.
mExceptionHasBeenRisen
)
{
}
else
{
runnable
=
new
ResumeRequest
(
mInterceptedChannel
)
;
}
if
(
!
runnable
)
{
nsCOMPtr
<
nsIRunnable
>
updateRunnable
=
new
RegistrationUpdateRunnable
(
mRegistration
false
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
runnable
=
new
CancelChannelRunnable
(
mInterceptedChannel
NS_ERROR_INTERCEPTION_FAILED
)
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
)
)
)
;
}
RefPtr
<
Promise
>
waitUntilPromise
=
event
-
>
GetPromise
(
)
;
if
(
waitUntilPromise
)
{
RefPtr
<
KeepAliveHandler
>
keepAliveHandler
=
new
KeepAliveHandler
(
mKeepAliveToken
)
;
waitUntilPromise
-
>
AppendNativeHandler
(
keepAliveHandler
)
;
}
return
true
;
}
nsresult
HandleBodyWithHeaders
(
nsIInputStream
*
aUploadStream
)
{
bool
nonBlocking
=
false
;
nsresult
rv
=
aUploadStream
-
>
IsNonBlocking
(
&
nonBlocking
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_WARN_IF
(
!
nonBlocking
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
body
;
rv
=
NS_ConsumeStream
(
aUploadStream
UINT32_MAX
body
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
:
:
const_iterator
begin
end
;
body
.
BeginReading
(
begin
)
;
body
.
EndReading
(
end
)
;
const
nsAutoCString
:
:
const_iterator
body_end
=
end
;
nsAutoCString
headerName
headerValue
;
bool
emptyHeader
=
false
;
while
(
FetchUtil
:
:
ExtractHeader
(
begin
end
headerName
headerValue
&
emptyHeader
)
&
&
!
emptyHeader
)
{
mHeaderNames
.
AppendElement
(
headerName
)
;
mHeaderValues
.
AppendElement
(
headerValue
)
;
headerName
.
Truncate
(
)
;
headerValue
.
Truncate
(
)
;
}
nsCOMPtr
<
nsIStringInputStream
>
strStream
=
do_CreateInstance
(
NS_STRINGINPUTSTREAM_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
+
+
begin
;
+
+
begin
;
body
.
Assign
(
Substring
(
begin
body_end
)
)
;
rv
=
strStream
-
>
SetData
(
body
.
BeginReading
(
)
body
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mUploadStream
=
strStream
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
FetchEventRunnable
WorkerRunnable
nsIHttpHeaderVisitor
)
}
nsresult
ServiceWorkerPrivate
:
:
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
const
nsAString
&
aDocumentId
bool
aIsReload
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIRunnable
>
failRunnable
=
NS_NewRunnableMethod
(
aChannel
&
nsIInterceptedChannel
:
:
ResetInterception
)
;
nsresult
rv
=
SpawnWorkerIfNeeded
(
FetchEvent
failRunnable
aLoadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
handle
(
new
nsMainThreadPtrHolder
<
nsIInterceptedChannel
>
(
aChannel
false
)
)
;
if
(
NS_WARN_IF
(
!
mInfo
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
MOZ_ASSERT
(
swm
)
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
registration
=
swm
-
>
GetRegistration
(
mInfo
-
>
GetPrincipal
(
)
mInfo
-
>
Scope
(
)
)
;
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
regInfo
(
new
nsMainThreadPtrHolder
<
ServiceWorkerRegistrationInfo
>
(
registration
false
)
)
;
RefPtr
<
FetchEventRunnable
>
r
=
new
FetchEventRunnable
(
mWorkerPrivate
mKeepAliveToken
handle
mInfo
-
>
ScriptSpec
(
)
regInfo
aDocumentId
aIsReload
)
;
rv
=
r
-
>
Init
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activating
)
{
mPendingFunctionalEvents
.
AppendElement
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activated
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
nsIRunnable
*
aLoadFailedRunnable
nsILoadGroup
*
aLoadGroup
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
aWhy
=
=
FetchEvent
aLoadGroup
)
;
if
(
mWorkerPrivate
)
{
mWorkerPrivate
-
>
UpdateOverridenLoadGroup
(
aLoadGroup
)
;
RenewKeepAliveToken
(
aWhy
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mSupportsArray
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
!
mInfo
)
)
{
NS_WARNING
(
"
Trying
to
wake
up
a
dead
service
worker
.
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_WARN_IF
(
!
indexedDB
:
:
IndexedDatabaseManager
:
:
GetOrCreate
(
)
)
;
WorkerLoadInfo
info
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
info
.
mBaseURI
)
mInfo
-
>
ScriptSpec
(
)
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mResolvedScriptURI
=
info
.
mBaseURI
;
MOZ_ASSERT
(
!
mInfo
-
>
CacheName
(
)
.
IsEmpty
(
)
)
;
info
.
mServiceWorkerCacheName
=
mInfo
-
>
CacheName
(
)
;
info
.
mServiceWorkerID
=
mInfo
-
>
ID
(
)
;
info
.
mLoadGroup
=
aLoadGroup
;
info
.
mLoadFailedAsyncRunnable
=
aLoadFailedRunnable
;
rv
=
info
.
mBaseURI
-
>
GetHost
(
info
.
mDomain
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mPrincipal
=
mInfo
-
>
GetPrincipal
(
)
;
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForPrincipal
(
info
.
mPrincipal
)
;
info
.
mStorageAllowed
=
access
>
nsContentUtils
:
:
StorageAccess
:
:
ePrivateBrowsing
;
info
.
mPrivateBrowsing
=
false
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
rv
=
info
.
mPrincipal
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mCSP
=
csp
;
if
(
info
.
mCSP
)
{
rv
=
info
.
mCSP
-
>
GetAllowsEval
(
&
info
.
mReportCSPViolations
&
info
.
mEvalAllowed
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
info
.
mEvalAllowed
=
true
;
info
.
mReportCSPViolations
=
false
;
}
WorkerPrivate
:
:
OverrideLoadInfoLoadGroup
(
info
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
ErrorResult
error
;
NS_ConvertUTF8toUTF16
scriptSpec
(
mInfo
-
>
ScriptSpec
(
)
)
;
mWorkerPrivate
=
WorkerPrivate
:
:
Constructor
(
jsapi
.
cx
(
)
scriptSpec
false
WorkerTypeService
mInfo
-
>
Scope
(
)
&
info
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
mIsPushWorker
=
false
;
RenewKeepAliveToken
(
aWhy
)
;
return
NS_OK
;
}
void
ServiceWorkerPrivate
:
:
StoreISupports
(
nsISupports
*
aSupports
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mSupportsArray
.
Contains
(
aSupports
)
)
;
mSupportsArray
.
AppendElement
(
aSupports
)
;
}
void
ServiceWorkerPrivate
:
:
RemoveISupports
(
nsISupports
*
aSupports
)
{
AssertIsOnMainThread
(
)
;
mSupportsArray
.
RemoveElement
(
aSupports
)
;
}
void
ServiceWorkerPrivate
:
:
TerminateWorker
(
)
{
AssertIsOnMainThread
(
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
mKeepAliveToken
=
nullptr
;
if
(
mWorkerPrivate
)
{
if
(
Preferences
:
:
GetBool
(
"
dom
.
serviceWorkers
.
testing
.
enabled
"
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
this
"
service
-
worker
-
shutdown
"
nullptr
)
;
}
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
NS_WARN_IF
(
!
mWorkerPrivate
-
>
Terminate
(
jsapi
.
cx
(
)
)
)
;
mWorkerPrivate
=
nullptr
;
mSupportsArray
.
Clear
(
)
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
pendingEvents
;
mPendingFunctionalEvents
.
SwapElements
(
pendingEvents
)
;
for
(
uint32_t
i
=
0
;
i
<
pendingEvents
.
Length
(
)
;
+
+
i
)
{
pendingEvents
[
i
]
-
>
Cancel
(
)
;
}
}
}
void
ServiceWorkerPrivate
:
:
NoteDeadServiceWorkerInfo
(
)
{
AssertIsOnMainThread
(
)
;
mInfo
=
nullptr
;
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
NoteStoppedControllingDocuments
(
)
{
AssertIsOnMainThread
(
)
;
if
(
mIsPushWorker
|
|
mDebuggerCount
)
{
return
;
}
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
Activated
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
!
mPendingFunctionalEvents
.
IsEmpty
(
)
mWorkerPrivate
)
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
pendingEvents
;
mPendingFunctionalEvents
.
SwapElements
(
pendingEvents
)
;
for
(
uint32_t
i
=
0
;
i
<
pendingEvents
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
WorkerRunnable
>
r
=
pendingEvents
[
i
]
.
forget
(
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
pending
functional
event
!
"
)
;
}
}
}
nsresult
ServiceWorkerPrivate
:
:
GetDebugger
(
nsIWorkerDebugger
*
*
aResult
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aResult
)
;
if
(
!
mDebuggerCount
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mWorkerPrivate
)
;
nsCOMPtr
<
nsIWorkerDebugger
>
debugger
=
do_QueryInterface
(
mWorkerPrivate
-
>
Debugger
(
)
)
;
debugger
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
AttachDebugger
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mDebuggerCount
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
AttachEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
}
+
+
mDebuggerCount
;
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
DetachDebugger
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mDebuggerCount
)
{
return
NS_ERROR_UNEXPECTED
;
}
-
-
mDebuggerCount
;
if
(
!
mDebuggerCount
)
{
if
(
mTokenCount
)
{
ResetIdleTimeout
(
)
;
}
else
{
TerminateWorker
(
)
;
}
}
return
NS_OK
;
}
void
ServiceWorkerPrivate
:
:
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
void
*
aPrivate
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrivate
)
;
RefPtr
<
ServiceWorkerPrivate
>
swp
=
static_cast
<
ServiceWorkerPrivate
*
>
(
aPrivate
)
;
MOZ_ASSERT
(
aTimer
=
=
swp
-
>
mIdleWorkerTimer
"
Invalid
timer
!
"
)
;
swp
-
>
mKeepAliveToken
=
nullptr
;
if
(
swp
-
>
mWorkerPrivate
)
{
uint32_t
timeout
=
Preferences
:
:
GetInt
(
"
dom
.
serviceWorkers
.
idle_extended_timeout
"
)
;
DebugOnly
<
nsresult
>
rv
=
swp
-
>
mIdleWorkerTimer
-
>
InitWithFuncCallback
(
ServiceWorkerPrivate
:
:
TerminateWorkerCallback
aPrivate
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
void
ServiceWorkerPrivate
:
:
TerminateWorkerCallback
(
nsITimer
*
aTimer
void
*
aPrivate
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrivate
)
;
RefPtr
<
ServiceWorkerPrivate
>
serviceWorkerPrivate
=
static_cast
<
ServiceWorkerPrivate
*
>
(
aPrivate
)
;
MOZ_ASSERT
(
aTimer
=
=
serviceWorkerPrivate
-
>
mIdleWorkerTimer
"
Invalid
timer
!
"
)
;
serviceWorkerPrivate
-
>
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
RenewKeepAliveToken
(
WakeUpReason
aWhy
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
if
(
aWhy
=
=
PushEvent
|
|
aWhy
=
=
PushSubscriptionChangeEvent
)
{
mIsPushWorker
=
true
;
}
if
(
!
mDebuggerCount
)
{
ResetIdleTimeout
(
)
;
}
if
(
!
mKeepAliveToken
)
{
mKeepAliveToken
=
new
KeepAliveToken
(
this
)
;
}
}
void
ServiceWorkerPrivate
:
:
ResetIdleTimeout
(
)
{
uint32_t
timeout
=
Preferences
:
:
GetInt
(
"
dom
.
serviceWorkers
.
idle_timeout
"
)
;
DebugOnly
<
nsresult
>
rv
=
mIdleWorkerTimer
-
>
InitWithFuncCallback
(
ServiceWorkerPrivate
:
:
NoteIdleWorkerCallback
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
ServiceWorkerPrivate
:
:
AddToken
(
)
{
AssertIsOnMainThread
(
)
;
+
+
mTokenCount
;
}
void
ServiceWorkerPrivate
:
:
ReleaseToken
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mTokenCount
>
0
)
;
-
-
mTokenCount
;
if
(
!
mTokenCount
)
{
TerminateWorker
(
)
;
}
}
END_WORKERS_NAMESPACE
