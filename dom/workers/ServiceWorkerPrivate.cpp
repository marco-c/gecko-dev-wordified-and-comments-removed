#
include
"
ServiceWorkerPrivate
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
BEGIN_WORKERS_NAMESPACE
#
define
SERVICE_WORKER_IDLE_TIMEOUT
30000
/
/
ms
#
define
SERVICE_WORKER_WAITUNTIL_TIMEOUT
300000
/
/
ms
Atomic
<
uint32_t
>
gDOMDisableOpenClickDelay
(
0
)
;
class
KeepAliveToken
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveToken
(
ServiceWorkerPrivate
*
aPrivate
)
:
mPrivate
(
aPrivate
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrivate
)
;
mPrivate
-
>
AddToken
(
)
;
}
private
:
~
KeepAliveToken
(
)
{
AssertIsOnMainThread
(
)
;
mPrivate
-
>
ReleaseToken
(
)
;
}
nsRefPtr
<
ServiceWorkerPrivate
>
mPrivate
;
}
;
NS_IMPL_ISUPPORTS0
(
KeepAliveToken
)
ServiceWorkerPrivate
:
:
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
:
mInfo
(
aInfo
)
mIsPushWorker
(
false
)
mTokenCount
(
0
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aInfo
)
;
mIdleWorkerTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
MOZ_ASSERT
(
mIdleWorkerTimer
)
;
}
ServiceWorkerPrivate
:
:
~
ServiceWorkerPrivate
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mTokenCount
)
;
MOZ_ASSERT
(
!
mInfo
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
}
nsresult
ServiceWorkerPrivate
:
:
SendMessageEvent
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
)
{
ErrorResult
rv
(
SpawnWorkerIfNeeded
(
MessageEvent
nullptr
)
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
mWorkerPrivate
-
>
PostMessageToServiceWorker
(
aCx
aMessage
aTransferable
Move
(
aClientInfo
)
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
namespace
{
class
CheckScriptEvaluationWithCallback
final
:
public
WorkerRunnable
{
nsRefPtr
<
nsRunnable
>
mCallback
;
public
:
CheckScriptEvaluationWithCallback
(
WorkerPrivate
*
aWorkerPrivate
nsRunnable
*
aCallback
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mCallback
(
aCallback
)
{
AssertIsOnMainThread
(
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
aWorkerPrivate
-
>
WorkerScriptExecutedSuccessfully
(
)
)
{
nsresult
rv
=
NS_DispatchToMainThread
(
mCallback
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
CheckScriptEvaluation
callback
.
"
)
;
}
}
return
true
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
ContinueOnSuccessfulScriptEvaluation
(
nsRunnable
*
aCallback
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
LifeCycleEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsRefPtr
<
WorkerRunnable
>
r
=
new
CheckScriptEvaluationWithCallback
(
mWorkerPrivate
aCallback
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
KeepAliveHandler
final
:
public
PromiseNativeHandler
{
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
virtual
~
KeepAliveHandler
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveHandler
(
const
nsMainThreadPtrHandle
<
KeepAliveToken
>
&
aKeepAliveToken
)
:
mKeepAliveToken
(
aKeepAliveToken
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
#
ifdef
DEBUG
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
#
endif
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
#
ifdef
DEBUG
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
#
endif
}
}
;
NS_IMPL_ISUPPORTS0
(
KeepAliveHandler
)
class
ExtendableEventWorkerRunnable
:
public
WorkerRunnable
{
protected
:
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
public
:
ExtendableEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aKeepAliveToken
)
;
mKeepAliveToken
=
new
nsMainThreadPtrHolder
<
KeepAliveToken
>
(
aKeepAliveToken
)
;
}
void
DispatchExtendableEventOnWorkerScope
(
JSContext
*
aCx
WorkerGlobalScope
*
aWorkerScope
ExtendableEvent
*
aEvent
Promise
*
*
aWaitUntilPromise
)
{
MOZ_ASSERT
(
aWorkerScope
)
;
MOZ_ASSERT
(
aEvent
)
;
nsCOMPtr
<
nsIGlobalObject
>
sgo
=
aWorkerScope
;
WidgetEvent
*
internalEvent
=
aEvent
-
>
GetInternalNSEvent
(
)
;
ErrorResult
result
;
result
=
aWorkerScope
-
>
DispatchDOMEvent
(
nullptr
aEvent
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
|
|
internalEvent
-
>
mFlags
.
mExceptionHasBeenRisen
)
{
result
.
SuppressException
(
)
;
return
;
}
nsRefPtr
<
Promise
>
waitUntilPromise
=
aEvent
-
>
GetPromise
(
)
;
if
(
!
waitUntilPromise
)
{
waitUntilPromise
=
Promise
:
:
Resolve
(
sgo
aCx
JS
:
:
UndefinedHandleValue
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
;
}
}
MOZ_ASSERT
(
waitUntilPromise
)
;
nsRefPtr
<
KeepAliveHandler
>
keepAliveHandler
=
new
KeepAliveHandler
(
mKeepAliveToken
)
;
waitUntilPromise
-
>
AppendNativeHandler
(
keepAliveHandler
)
;
if
(
aWaitUntilPromise
)
{
waitUntilPromise
.
forget
(
aWaitUntilPromise
)
;
}
}
}
;
class
LifecycleEventWorkerRunnable
:
public
ExtendableEventWorkerRunnable
{
nsString
mEventName
;
nsRefPtr
<
LifeCycleEventCallback
>
mCallback
;
public
:
LifecycleEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aToken
const
nsAString
&
aEventName
LifeCycleEventCallback
*
aCallback
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aToken
)
mEventName
(
aEventName
)
mCallback
(
aCallback
)
{
AssertIsOnMainThread
(
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
return
DispatchLifecycleEvent
(
aCx
aWorkerPrivate
)
;
}
private
:
bool
DispatchLifecycleEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
}
;
class
LifecycleEventPromiseHandler
final
:
public
PromiseNativeHandler
{
nsRefPtr
<
LifeCycleEventCallback
>
mCallback
;
virtual
~
LifecycleEventPromiseHandler
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
LifecycleEventPromiseHandler
(
LifeCycleEventCallback
*
aCallback
)
:
mCallback
(
aCallback
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mCallback
-
>
SetResult
(
true
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
mCallback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_RUNTIMEABORT
(
"
Failed
to
dispatch
life
cycle
event
handler
.
"
)
;
}
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mCallback
-
>
SetResult
(
false
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
mCallback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_RUNTIMEABORT
(
"
Failed
to
dispatch
life
cycle
event
handler
.
"
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
workerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
JS
:
:
ExposeValueToActiveJS
(
aValue
)
;
js
:
:
ErrorReport
report
(
aCx
)
;
if
(
NS_WARN_IF
(
!
report
.
init
(
aCx
aValue
)
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
;
}
nsRefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
xpcReport
-
>
Init
(
report
.
report
(
)
report
.
message
(
)
false
0
)
;
nsRefPtr
<
AsyncErrorReporter
>
aer
=
new
AsyncErrorReporter
(
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
Runtime
(
)
xpcReport
)
;
NS_DispatchToMainThread
(
aer
)
;
}
}
;
NS_IMPL_ISUPPORTS0
(
LifecycleEventPromiseHandler
)
bool
LifecycleEventWorkerRunnable
:
:
DispatchLifecycleEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
nsRefPtr
<
ExtendableEvent
>
event
;
nsRefPtr
<
EventTarget
>
target
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
if
(
mEventName
.
EqualsASCII
(
"
install
"
)
|
|
mEventName
.
EqualsASCII
(
"
activate
"
)
)
{
ExtendableEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
event
=
ExtendableEvent
:
:
Constructor
(
target
mEventName
init
)
;
}
else
{
MOZ_CRASH
(
"
Unexpected
lifecycle
event
"
)
;
}
event
-
>
SetTrusted
(
true
)
;
nsRefPtr
<
Promise
>
waitUntil
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
getter_AddRefs
(
waitUntil
)
)
;
if
(
waitUntil
)
{
nsRefPtr
<
LifecycleEventPromiseHandler
>
handler
=
new
LifecycleEventPromiseHandler
(
mCallback
)
;
waitUntil
-
>
AppendNativeHandler
(
handler
)
;
}
else
{
mCallback
-
>
SetResult
(
false
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
mCallback
)
)
)
;
}
return
true
;
}
}
nsresult
ServiceWorkerPrivate
:
:
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
nsIRunnable
*
aLoadFailure
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
LifeCycleEvent
aLoadFailure
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
nsRefPtr
<
WorkerRunnable
>
r
=
new
LifecycleEventWorkerRunnable
(
mWorkerPrivate
mKeepAliveToken
aEventType
aCallback
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
#
ifndef
MOZ_SIMPLEPUSH
namespace
{
class
SendPushEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
Maybe
<
nsTArray
<
uint8_t
>
>
mData
;
public
:
SendPushEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mData
(
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
GlobalObject
globalObj
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
PushEventInit
pei
;
if
(
mData
)
{
const
nsTArray
<
uint8_t
>
&
bytes
=
mData
.
ref
(
)
;
JSObject
*
data
=
Uint8Array
:
:
Create
(
aCx
bytes
.
Length
(
)
bytes
.
Elements
(
)
)
;
if
(
!
data
)
{
return
false
;
}
pei
.
mData
.
Construct
(
)
.
SetAsArrayBufferView
(
)
.
Init
(
data
)
;
}
pei
.
mBubbles
=
false
;
pei
.
mCancelable
=
false
;
ErrorResult
result
;
nsRefPtr
<
PushEvent
>
event
=
PushEvent
:
:
Constructor
(
globalObj
NS_LITERAL_STRING
(
"
push
"
)
pei
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
nullptr
)
;
return
true
;
}
}
;
class
SendPushSubscriptionChangeEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
public
:
explicit
SendPushSubscriptionChangeEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
WorkerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
nsRefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
globalScope
nullptr
nullptr
)
;
nsresult
rv
=
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
pushsubscriptionchange
"
)
false
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
globalScope
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
return
true
;
}
}
;
}
#
endif
nsresult
ServiceWorkerPrivate
:
:
SendPushEvent
(
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
)
{
#
ifdef
MOZ_SIMPLEPUSH
return
NS_ERROR_NOT_AVAILABLE
;
#
else
nsresult
rv
=
SpawnWorkerIfNeeded
(
PushEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
nsRefPtr
<
WorkerRunnable
>
r
=
new
SendPushEventRunnable
(
mWorkerPrivate
mKeepAliveToken
aData
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
#
endif
}
nsresult
ServiceWorkerPrivate
:
:
SendPushSubscriptionChangeEvent
(
)
{
#
ifdef
MOZ_SIMPLEPUSH
return
NS_ERROR_NOT_AVAILABLE
;
#
else
nsresult
rv
=
SpawnWorkerIfNeeded
(
PushSubscriptionChangeEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
mKeepAliveToken
)
;
nsRefPtr
<
WorkerRunnable
>
r
=
new
SendPushSubscriptionChangeEventRunnable
(
mWorkerPrivate
mKeepAliveToken
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
#
endif
}
namespace
{
static
void
DummyNotificationTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
}
class
AllowWindowInteractionHandler
;
class
ClearWindowAllowedRunnable
final
:
public
WorkerRunnable
{
public
:
ClearWindowAllowedRunnable
(
WorkerPrivate
*
aWorkerPrivate
AllowWindowInteractionHandler
*
aHandler
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mHandler
(
aHandler
)
{
}
private
:
bool
PreDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
return
true
;
}
void
PostDispatch
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
;
nsRefPtr
<
AllowWindowInteractionHandler
>
mHandler
;
}
;
class
AllowWindowInteractionHandler
final
:
public
PromiseNativeHandler
{
friend
class
ClearWindowAllowedRunnable
;
nsCOMPtr
<
nsITimer
>
mTimer
;
~
AllowWindowInteractionHandler
(
)
{
}
void
ClearWindowAllowed
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
!
mTimer
)
{
return
;
}
WorkerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
if
(
!
globalScope
)
{
return
;
}
globalScope
-
>
ConsumeWindowInteraction
(
)
;
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
MOZ_ALWAYS_TRUE
(
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
aWorkerPrivate
-
>
GetJSContext
(
)
false
)
)
;
}
void
StartClearWindowTimer
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mTimer
)
;
nsresult
rv
;
nsCOMPtr
<
nsITimer
>
timer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsRefPtr
<
ClearWindowAllowedRunnable
>
r
=
new
ClearWindowAllowedRunnable
(
aWorkerPrivate
this
)
;
nsRefPtr
<
TimerThreadEventTarget
>
target
=
new
TimerThreadEventTarget
(
aWorkerPrivate
r
)
;
rv
=
timer
-
>
SetTarget
(
target
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
aWorkerPrivate
-
>
GetJSContext
(
)
true
)
)
)
{
return
;
}
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
AllowWindowInteraction
(
)
;
timer
.
swap
(
mTimer
)
;
rv
=
mTimer
-
>
InitWithFuncCallback
(
DummyNotificationTimerCallback
nullptr
gDOMDisableOpenClickDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ClearWindowAllowed
(
aWorkerPrivate
)
;
return
;
}
}
public
:
NS_DECL_ISUPPORTS
explicit
AllowWindowInteractionHandler
(
WorkerPrivate
*
aWorkerPrivate
)
{
StartClearWindowTimer
(
aWorkerPrivate
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
ClearWindowAllowed
(
workerPrivate
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
ClearWindowAllowed
(
workerPrivate
)
;
}
}
;
NS_IMPL_ISUPPORTS0
(
AllowWindowInteractionHandler
)
bool
ClearWindowAllowedRunnable
:
:
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
mHandler
-
>
ClearWindowAllowed
(
aWorkerPrivate
)
;
return
true
;
}
class
SendNotificationClickEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
const
nsString
mID
;
const
nsString
mTitle
;
const
nsString
mDir
;
const
nsString
mLang
;
const
nsString
mBody
;
const
nsString
mTag
;
const
nsString
mIcon
;
const
nsString
mData
;
const
nsString
mBehavior
;
const
nsString
mScope
;
public
:
SendNotificationClickEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mID
(
aID
)
mTitle
(
aTitle
)
mDir
(
aDir
)
mLang
(
aLang
)
mBody
(
aBody
)
mTag
(
aTag
)
mIcon
(
aIcon
)
mData
(
aData
)
mBehavior
(
aBehavior
)
mScope
(
aScope
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
nsRefPtr
<
EventTarget
>
target
=
do_QueryObject
(
aWorkerPrivate
-
>
GlobalScope
(
)
)
;
ErrorResult
result
;
nsRefPtr
<
Notification
>
notification
=
Notification
:
:
ConstructFromFields
(
aWorkerPrivate
-
>
GlobalScope
(
)
mID
mTitle
mDir
mLang
mBody
mTag
mIcon
mData
mScope
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
false
;
}
NotificationEventInit
nei
;
nei
.
mNotification
=
notification
;
nei
.
mBubbles
=
false
;
nei
.
mCancelable
=
false
;
nsRefPtr
<
NotificationEvent
>
event
=
NotificationEvent
:
:
Constructor
(
target
NS_LITERAL_STRING
(
"
notificationclick
"
)
nei
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
nsRefPtr
<
Promise
>
waitUntil
;
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
AllowWindowInteraction
(
)
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
getter_AddRefs
(
waitUntil
)
)
;
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
ConsumeWindowInteraction
(
)
;
if
(
waitUntil
)
{
nsRefPtr
<
AllowWindowInteractionHandler
>
allowWindowInteraction
=
new
AllowWindowInteractionHandler
(
aWorkerPrivate
)
;
waitUntil
-
>
AppendNativeHandler
(
allowWindowInteraction
)
;
}
return
true
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
SendNotificationClickEvent
(
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
NotificationClickEvent
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
gDOMDisableOpenClickDelay
=
Preferences
:
:
GetInt
(
"
dom
.
disable_open_click_delay
"
)
;
nsRefPtr
<
WorkerRunnable
>
r
=
new
SendNotificationClickEventRunnable
(
mWorkerPrivate
mKeepAliveToken
aID
aTitle
aDir
aLang
aBody
aTag
aIcon
aData
aBehavior
aScope
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
FetchEventRunnable
:
public
ExtendableEventWorkerRunnable
public
nsIHttpHeaderVisitor
{
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
mInterceptedChannel
;
const
nsCString
mScriptSpec
;
nsTArray
<
nsCString
>
mHeaderNames
;
nsTArray
<
nsCString
>
mHeaderValues
;
UniquePtr
<
ServiceWorkerClientInfo
>
mClientInfo
;
nsCString
mSpec
;
nsCString
mMethod
;
bool
mIsReload
;
DebugOnly
<
bool
>
mIsHttpChannel
;
RequestMode
mRequestMode
;
RequestRedirect
mRequestRedirect
;
RequestCredentials
mRequestCredentials
;
nsContentPolicyType
mContentPolicyType
;
nsCOMPtr
<
nsIInputStream
>
mUploadStream
;
nsCString
mReferrer
;
public
:
FetchEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
&
aChannel
const
nsACString
&
aScriptSpec
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
bool
aIsReload
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mInterceptedChannel
(
aChannel
)
mScriptSpec
(
aScriptSpec
)
mClientInfo
(
Move
(
aClientInfo
)
)
mIsReload
(
aIsReload
)
mIsHttpChannel
(
false
)
mRequestMode
(
RequestMode
:
:
No_cors
)
mRequestRedirect
(
RequestRedirect
:
:
Follow
)
mRequestCredentials
(
RequestCredentials
:
:
Same_origin
)
mContentPolicyType
(
nsIContentPolicy
:
:
TYPE_INVALID
)
mReferrer
(
kFETCH_CLIENT_REFERRER_STR
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
mHeaderNames
.
AppendElement
(
aHeader
)
;
mHeaderValues
.
AppendElement
(
aValue
)
;
return
NS_OK
;
}
nsresult
Init
(
)
{
AssertIsOnMainThread
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
mInterceptedChannel
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uri
-
>
GetSpec
(
mSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
loadFlags
;
rv
=
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
channel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mContentPolicyType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
nsCOMPtr
<
nsIURI
>
referrerURI
;
rv
=
NS_GetReferrerFromChannel
(
channel
getter_AddRefs
(
referrerURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
referrerURI
)
{
rv
=
referrerURI
-
>
GetSpec
(
mReferrer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
;
if
(
httpChannel
)
{
mIsHttpChannel
=
true
;
rv
=
httpChannel
-
>
GetRequestMethod
(
mMethod
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
httpChannel
)
;
NS_ENSURE_TRUE
(
internalChannel
NS_ERROR_NOT_AVAILABLE
)
;
mRequestMode
=
InternalRequest
:
:
MapChannelToRequestMode
(
channel
)
;
uint32_t
redirectMode
;
internalChannel
-
>
GetRedirectMode
(
&
redirectMode
)
;
mRequestRedirect
=
static_cast
<
RequestRedirect
>
(
redirectMode
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
{
mRequestCredentials
=
RequestCredentials
:
:
Omit
;
}
else
{
bool
includeCrossOrigin
;
internalChannel
-
>
GetCorsIncludeCredentials
(
&
includeCrossOrigin
)
;
if
(
includeCrossOrigin
)
{
mRequestCredentials
=
RequestCredentials
:
:
Include
;
}
}
rv
=
httpChannel
-
>
VisitNonDefaultRequestHeaders
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
uploadChannel
)
{
MOZ_ASSERT
(
!
mUploadStream
)
;
rv
=
uploadChannel
-
>
CloneUploadStream
(
getter_AddRefs
(
mUploadStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
else
{
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
channel
)
;
NS_ENSURE_TRUE
(
jarChannel
NS_ERROR_NOT_AVAILABLE
)
;
mMethod
=
"
GET
"
;
mRequestMode
=
InternalRequest
:
:
MapChannelToRequestMode
(
channel
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_ANONYMOUS
)
{
mRequestCredentials
=
RequestCredentials
:
:
Omit
;
}
}
return
NS_OK
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
return
DispatchFetchEvent
(
aCx
aWorkerPrivate
)
;
}
private
:
~
FetchEventRunnable
(
)
{
}
class
ResumeRequest
final
:
public
nsRunnable
{
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
mChannel
;
public
:
explicit
ResumeRequest
(
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
&
aChannel
)
:
mChannel
(
aChannel
)
{
}
NS_IMETHOD
Run
(
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
=
mChannel
-
>
ResetInterception
(
)
;
NS_WARN_IF_FALSE
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
resume
intercepted
network
request
"
)
;
return
rv
;
}
}
;
bool
DispatchFetchEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
GlobalObject
globalObj
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
NS_ConvertUTF8toUTF16
local
(
mSpec
)
;
RequestOrUSVString
requestInfo
;
requestInfo
.
SetAsUSVString
(
)
.
Rebind
(
local
.
Data
(
)
local
.
Length
(
)
)
;
RootedDictionary
<
RequestInit
>
reqInit
(
aCx
)
;
reqInit
.
mMethod
.
Construct
(
mMethod
)
;
nsRefPtr
<
InternalHeaders
>
internalHeaders
=
new
InternalHeaders
(
HeadersGuardEnum
:
:
Request
)
;
MOZ_ASSERT
(
mHeaderNames
.
Length
(
)
=
=
mHeaderValues
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mHeaderNames
.
Length
(
)
;
i
+
+
)
{
ErrorResult
result
;
internalHeaders
-
>
Set
(
mHeaderNames
[
i
]
mHeaderValues
[
i
]
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
}
nsRefPtr
<
Headers
>
headers
=
new
Headers
(
globalObj
.
GetAsSupports
(
)
internalHeaders
)
;
reqInit
.
mHeaders
.
Construct
(
)
;
reqInit
.
mHeaders
.
Value
(
)
.
SetAsHeaders
(
)
=
headers
;
reqInit
.
mMode
.
Construct
(
mRequestMode
)
;
reqInit
.
mRedirect
.
Construct
(
mRequestRedirect
)
;
reqInit
.
mCredentials
.
Construct
(
mRequestCredentials
)
;
ErrorResult
result
;
nsRefPtr
<
Request
>
request
=
Request
:
:
Constructor
(
globalObj
requestInfo
reqInit
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
nsRefPtr
<
InternalRequest
>
internalReq
=
request
-
>
GetInternalRequest
(
)
;
MOZ_ASSERT
(
internalReq
)
;
internalReq
-
>
SetCreatedByFetchEvent
(
)
;
internalReq
-
>
SetBody
(
mUploadStream
)
;
internalReq
-
>
SetReferrer
(
NS_ConvertUTF8toUTF16
(
mReferrer
)
)
;
request
-
>
SetContentPolicyType
(
mContentPolicyType
)
;
MOZ_ASSERT_IF
(
mIsHttpChannel
&
&
internalReq
-
>
IsNavigationRequest
(
)
request
-
>
Redirect
(
)
=
=
RequestRedirect
:
:
Manual
)
;
RootedDictionary
<
FetchEventInit
>
init
(
aCx
)
;
init
.
mRequest
.
Construct
(
)
;
init
.
mRequest
.
Value
(
)
=
request
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
true
;
init
.
mIsReload
.
Construct
(
mIsReload
)
;
nsRefPtr
<
FetchEvent
>
event
=
FetchEvent
:
:
Constructor
(
globalObj
NS_LITERAL_STRING
(
"
fetch
"
)
init
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
event
-
>
PostInit
(
mInterceptedChannel
mScriptSpec
Move
(
mClientInfo
)
)
;
event
-
>
SetTrusted
(
true
)
;
nsRefPtr
<
EventTarget
>
target
=
do_QueryObject
(
aWorkerPrivate
-
>
GlobalScope
(
)
)
;
nsresult
rv2
=
target
-
>
DispatchDOMEvent
(
nullptr
event
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv2
)
)
|
|
!
event
-
>
WaitToRespond
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
;
if
(
event
-
>
DefaultPrevented
(
aCx
)
)
{
runnable
=
new
CancelChannelRunnable
(
mInterceptedChannel
NS_ERROR_INTERCEPTION_CANCELED
)
;
}
else
{
runnable
=
new
ResumeRequest
(
mInterceptedChannel
)
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
)
)
)
;
}
return
true
;
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
FetchEventRunnable
WorkerRunnable
nsIHttpHeaderVisitor
)
}
nsresult
ServiceWorkerPrivate
:
:
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
bool
aIsReload
)
{
nsCOMPtr
<
nsIRunnable
>
failRunnable
=
NS_NewRunnableMethod
(
aChannel
&
nsIInterceptedChannel
:
:
ResetInterception
)
;
nsresult
rv
=
SpawnWorkerIfNeeded
(
FetchEvent
failRunnable
aLoadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
handle
(
new
nsMainThreadPtrHolder
<
nsIInterceptedChannel
>
(
aChannel
false
)
)
;
if
(
NS_WARN_IF
(
!
mInfo
)
)
{
return
NS_ERROR_FAILURE
;
}
nsRefPtr
<
FetchEventRunnable
>
r
=
new
FetchEventRunnable
(
mWorkerPrivate
mKeepAliveToken
handle
mInfo
-
>
ScriptSpec
(
)
Move
(
aClientInfo
)
aIsReload
)
;
rv
=
r
-
>
Init
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
jsapi
.
cx
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
nsIRunnable
*
aLoadFailedRunnable
nsILoadGroup
*
aLoadGroup
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
aWhy
=
=
FetchEvent
aLoadGroup
)
;
if
(
mWorkerPrivate
)
{
mWorkerPrivate
-
>
UpdateOverridenLoadGroup
(
aLoadGroup
)
;
ResetIdleTimeout
(
aWhy
)
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
mInfo
)
)
{
NS_WARNING
(
"
Trying
to
wake
up
a
dead
service
worker
.
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_WARN_IF
(
!
indexedDB
:
:
IndexedDatabaseManager
:
:
GetOrCreate
(
)
)
;
WorkerLoadInfo
info
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
info
.
mBaseURI
)
mInfo
-
>
ScriptSpec
(
)
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mResolvedScriptURI
=
info
.
mBaseURI
;
MOZ_ASSERT
(
!
mInfo
-
>
CacheName
(
)
.
IsEmpty
(
)
)
;
info
.
mServiceWorkerCacheName
=
mInfo
-
>
CacheName
(
)
;
info
.
mServiceWorkerID
=
mInfo
-
>
ID
(
)
;
info
.
mLoadGroup
=
aLoadGroup
;
info
.
mLoadFailedAsyncRunnable
=
aLoadFailedRunnable
;
rv
=
info
.
mBaseURI
-
>
GetHost
(
info
.
mDomain
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mPrincipal
=
mInfo
-
>
GetPrincipal
(
)
;
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForPrincipal
(
info
.
mPrincipal
)
;
info
.
mStorageAllowed
=
access
>
nsContentUtils
:
:
StorageAccess
:
:
ePrivateBrowsing
;
info
.
mPrivateBrowsing
=
false
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
rv
=
info
.
mPrincipal
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mCSP
=
csp
;
if
(
info
.
mCSP
)
{
rv
=
info
.
mCSP
-
>
GetAllowsEval
(
&
info
.
mReportCSPViolations
&
info
.
mEvalAllowed
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
info
.
mEvalAllowed
=
true
;
info
.
mReportCSPViolations
=
false
;
}
WorkerPrivate
:
:
OverrideLoadInfoLoadGroup
(
info
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
ErrorResult
error
;
NS_ConvertUTF8toUTF16
scriptSpec
(
mInfo
-
>
ScriptSpec
(
)
)
;
mWorkerPrivate
=
WorkerPrivate
:
:
Constructor
(
jsapi
.
cx
(
)
scriptSpec
false
WorkerTypeService
mInfo
-
>
Scope
(
)
&
info
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
mIsPushWorker
=
false
;
ResetIdleTimeout
(
aWhy
)
;
return
NS_OK
;
}
void
ServiceWorkerPrivate
:
:
TerminateWorker
(
)
{
AssertIsOnMainThread
(
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
mKeepAliveToken
=
nullptr
;
if
(
mWorkerPrivate
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
NS_WARN_IF
(
!
mWorkerPrivate
-
>
Terminate
(
jsapi
.
cx
(
)
)
)
;
mWorkerPrivate
=
nullptr
;
}
}
void
ServiceWorkerPrivate
:
:
NoteDeadServiceWorkerInfo
(
)
{
AssertIsOnMainThread
(
)
;
mInfo
=
nullptr
;
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
NoteStoppedControllingDocuments
(
)
{
AssertIsOnMainThread
(
)
;
if
(
mIsPushWorker
)
{
return
;
}
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
void
*
aPrivate
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrivate
)
;
nsRefPtr
<
ServiceWorkerPrivate
>
swp
=
static_cast
<
ServiceWorkerPrivate
*
>
(
aPrivate
)
;
MOZ_ASSERT
(
aTimer
=
=
swp
-
>
mIdleWorkerTimer
"
Invalid
timer
!
"
)
;
swp
-
>
mKeepAliveToken
=
nullptr
;
if
(
swp
-
>
mWorkerPrivate
)
{
DebugOnly
<
nsresult
>
rv
=
swp
-
>
mIdleWorkerTimer
-
>
InitWithFuncCallback
(
ServiceWorkerPrivate
:
:
TerminateWorkerCallback
aPrivate
SERVICE_WORKER_WAITUNTIL_TIMEOUT
nsITimer
:
:
TYPE_ONE_SHOT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
void
ServiceWorkerPrivate
:
:
TerminateWorkerCallback
(
nsITimer
*
aTimer
void
*
aPrivate
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aPrivate
)
;
nsRefPtr
<
ServiceWorkerPrivate
>
serviceWorkerPrivate
=
static_cast
<
ServiceWorkerPrivate
*
>
(
aPrivate
)
;
MOZ_ASSERT
(
aTimer
=
=
serviceWorkerPrivate
-
>
mIdleWorkerTimer
"
Invalid
timer
!
"
)
;
serviceWorkerPrivate
-
>
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
ResetIdleTimeout
(
WakeUpReason
aWhy
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
if
(
aWhy
=
=
PushEvent
|
|
aWhy
=
=
PushSubscriptionChangeEvent
)
{
mIsPushWorker
=
true
;
}
DebugOnly
<
nsresult
>
rv
=
mIdleWorkerTimer
-
>
InitWithFuncCallback
(
ServiceWorkerPrivate
:
:
NoteIdleWorkerCallback
this
SERVICE_WORKER_IDLE_TIMEOUT
nsITimer
:
:
TYPE_ONE_SHOT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
mKeepAliveToken
)
{
mKeepAliveToken
=
new
KeepAliveToken
(
this
)
;
}
}
void
ServiceWorkerPrivate
:
:
AddToken
(
)
{
AssertIsOnMainThread
(
)
;
+
+
mTokenCount
;
}
void
ServiceWorkerPrivate
:
:
ReleaseToken
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mTokenCount
>
0
)
;
-
-
mTokenCount
;
if
(
!
mTokenCount
)
{
TerminateWorker
(
)
;
}
}
END_WORKERS_NAMESPACE
