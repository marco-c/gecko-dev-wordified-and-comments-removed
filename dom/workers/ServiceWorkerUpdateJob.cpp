#
include
"
ServiceWorkerUpdateJob
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
ServiceWorkerScriptCache
.
h
"
#
include
"
Workers
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
workers
{
namespace
{
enum
ScopeStringPrefixMode
{
eUseDirectory
eUsePath
}
;
nsresult
GetRequiredScopeStringPrefix
(
nsIURI
*
aScriptURI
nsACString
&
aPrefix
ScopeStringPrefixMode
aPrefixMode
)
{
nsresult
rv
=
aScriptURI
-
>
GetPrePath
(
aPrefix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aPrefixMode
=
=
eUseDirectory
)
{
nsCOMPtr
<
nsIURL
>
scriptURL
(
do_QueryInterface
(
aScriptURI
)
)
;
if
(
NS_WARN_IF
(
!
scriptURL
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
dir
;
rv
=
scriptURL
-
>
GetDirectory
(
dir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aPrefix
.
Append
(
dir
)
;
}
else
if
(
aPrefixMode
=
=
eUsePath
)
{
nsAutoCString
path
;
rv
=
aScriptURI
-
>
GetPathQueryRef
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aPrefix
.
Append
(
path
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
value
for
aPrefixMode
"
)
;
}
return
NS_OK
;
}
}
class
ServiceWorkerUpdateJob
:
:
CompareCallback
final
:
public
serviceWorkerScriptCache
:
:
CompareCallback
{
RefPtr
<
ServiceWorkerUpdateJob
>
mJob
;
~
CompareCallback
(
)
{
}
public
:
explicit
CompareCallback
(
ServiceWorkerUpdateJob
*
aJob
)
:
mJob
(
aJob
)
{
MOZ_ASSERT
(
mJob
)
;
}
virtual
void
ComparisonResult
(
nsresult
aStatus
bool
aInCacheAndEqual
const
nsAString
&
aNewCacheName
const
nsACString
&
aMaxScope
nsLoadFlags
aLoadFlags
)
override
{
mJob
-
>
ComparisonResult
(
aStatus
aInCacheAndEqual
aNewCacheName
aMaxScope
aLoadFlags
)
;
}
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerUpdateJob
:
:
CompareCallback
override
)
}
;
class
ServiceWorkerUpdateJob
:
:
ContinueUpdateRunnable
final
:
public
LifeCycleEventCallback
{
nsMainThreadPtrHandle
<
ServiceWorkerUpdateJob
>
mJob
;
bool
mSuccess
;
public
:
explicit
ContinueUpdateRunnable
(
const
nsMainThreadPtrHandle
<
ServiceWorkerUpdateJob
>
&
aJob
)
:
mJob
(
aJob
)
mSuccess
(
false
)
{
AssertIsOnMainThread
(
)
;
}
void
SetResult
(
bool
aResult
)
override
{
mSuccess
=
aResult
;
}
NS_IMETHOD
Run
(
)
override
{
AssertIsOnMainThread
(
)
;
mJob
-
>
ContinueUpdateAfterScriptEval
(
mSuccess
)
;
mJob
=
nullptr
;
return
NS_OK
;
}
}
;
class
ServiceWorkerUpdateJob
:
:
ContinueInstallRunnable
final
:
public
LifeCycleEventCallback
{
nsMainThreadPtrHandle
<
ServiceWorkerUpdateJob
>
mJob
;
bool
mSuccess
;
public
:
explicit
ContinueInstallRunnable
(
const
nsMainThreadPtrHandle
<
ServiceWorkerUpdateJob
>
&
aJob
)
:
mJob
(
aJob
)
mSuccess
(
false
)
{
AssertIsOnMainThread
(
)
;
}
void
SetResult
(
bool
aResult
)
override
{
mSuccess
=
aResult
;
}
NS_IMETHOD
Run
(
)
override
{
AssertIsOnMainThread
(
)
;
mJob
-
>
ContinueAfterInstallEvent
(
mSuccess
)
;
mJob
=
nullptr
;
return
NS_OK
;
}
}
;
ServiceWorkerUpdateJob
:
:
ServiceWorkerUpdateJob
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
const
nsACString
&
aScriptSpec
nsILoadGroup
*
aLoadGroup
nsLoadFlags
aLoadFlags
)
:
ServiceWorkerJob
(
Type
:
:
Update
aPrincipal
aScope
aScriptSpec
)
mLoadGroup
(
aLoadGroup
)
mLoadFlags
(
aLoadFlags
)
{
}
already_AddRefed
<
ServiceWorkerRegistrationInfo
>
ServiceWorkerUpdateJob
:
:
GetRegistration
(
)
const
{
AssertIsOnMainThread
(
)
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
ref
=
mRegistration
;
return
ref
.
forget
(
)
;
}
ServiceWorkerUpdateJob
:
:
ServiceWorkerUpdateJob
(
Type
aType
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
const
nsACString
&
aScriptSpec
nsILoadGroup
*
aLoadGroup
nsLoadFlags
aLoadFlags
)
:
ServiceWorkerJob
(
aType
aPrincipal
aScope
aScriptSpec
)
mLoadGroup
(
aLoadGroup
)
mLoadFlags
(
aLoadFlags
)
{
}
ServiceWorkerUpdateJob
:
:
~
ServiceWorkerUpdateJob
(
)
{
}
void
ServiceWorkerUpdateJob
:
:
FailUpdateJob
(
ErrorResult
&
aRv
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aRv
.
Failed
(
)
)
;
if
(
mRegistration
)
{
mRegistration
-
>
ClearEvaluating
(
)
;
mRegistration
-
>
ClearInstalling
(
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
swm
)
{
swm
-
>
MaybeRemoveRegistration
(
mRegistration
)
;
}
}
mRegistration
=
nullptr
;
Finish
(
aRv
)
;
}
void
ServiceWorkerUpdateJob
:
:
FailUpdateJob
(
nsresult
aRv
)
{
ErrorResult
rv
(
aRv
)
;
FailUpdateJob
(
rv
)
;
}
void
ServiceWorkerUpdateJob
:
:
AsyncExecute
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
GetType
(
)
=
=
Type
:
:
Update
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
Canceled
(
)
|
|
!
swm
)
{
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
}
RefPtr
<
ServiceWorkerRegistrationInfo
>
registration
=
swm
-
>
GetRegistration
(
mPrincipal
mScope
)
;
if
(
!
registration
|
|
registration
-
>
mPendingUninstall
)
{
ErrorResult
rv
;
rv
.
ThrowTypeError
<
MSG_SW_UPDATE_BAD_REGISTRATION
>
(
NS_ConvertUTF8toUTF16
(
mScope
)
NS_LITERAL_STRING
(
"
uninstalled
"
)
)
;
FailUpdateJob
(
rv
)
;
return
;
}
RefPtr
<
ServiceWorkerInfo
>
newest
=
registration
-
>
Newest
(
)
;
if
(
newest
&
&
!
mScriptSpec
.
Equals
(
newest
-
>
ScriptSpec
(
)
)
)
{
ErrorResult
rv
;
rv
.
ThrowTypeError
<
MSG_SW_UPDATE_BAD_REGISTRATION
>
(
NS_ConvertUTF8toUTF16
(
mScope
)
NS_LITERAL_STRING
(
"
changed
"
)
)
;
FailUpdateJob
(
rv
)
;
return
;
}
SetRegistration
(
registration
)
;
Update
(
)
;
}
void
ServiceWorkerUpdateJob
:
:
SetRegistration
(
ServiceWorkerRegistrationInfo
*
aRegistration
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mRegistration
)
;
MOZ_ASSERT
(
aRegistration
)
;
mRegistration
=
aRegistration
;
}
void
ServiceWorkerUpdateJob
:
:
Update
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
Canceled
(
)
)
;
MOZ_ASSERT
(
mRegistration
)
;
MOZ_ASSERT
(
!
mRegistration
-
>
GetInstalling
(
)
)
;
RefPtr
<
ServiceWorkerInfo
>
workerInfo
=
mRegistration
-
>
Newest
(
)
;
nsAutoString
cacheName
;
if
(
workerInfo
&
&
workerInfo
-
>
ScriptSpec
(
)
.
Equals
(
mScriptSpec
)
)
{
cacheName
=
workerInfo
-
>
CacheName
(
)
;
}
RefPtr
<
CompareCallback
>
callback
=
new
CompareCallback
(
this
)
;
nsresult
rv
=
serviceWorkerScriptCache
:
:
Compare
(
mRegistration
mPrincipal
cacheName
NS_ConvertUTF8toUTF16
(
mScriptSpec
)
callback
mLoadGroup
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailUpdateJob
(
rv
)
;
return
;
}
}
nsLoadFlags
ServiceWorkerUpdateJob
:
:
GetLoadFlags
(
)
const
{
return
mLoadFlags
;
}
void
ServiceWorkerUpdateJob
:
:
ComparisonResult
(
nsresult
aStatus
bool
aInCacheAndEqual
const
nsAString
&
aNewCacheName
const
nsACString
&
aMaxScope
nsLoadFlags
aLoadFlags
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
Canceled
(
)
|
|
!
swm
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
aStatus
)
)
)
{
FailUpdateJob
(
aStatus
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
scriptURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
scriptURI
)
mScriptSpec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
maxScopeURI
;
if
(
!
aMaxScope
.
IsEmpty
(
)
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
maxScopeURI
)
aMaxScope
nullptr
scriptURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
}
mLoadFlags
=
aLoadFlags
;
nsAutoCString
defaultAllowedPrefix
;
rv
=
GetRequiredScopeStringPrefix
(
scriptURI
defaultAllowedPrefix
eUseDirectory
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsAutoCString
maxPrefix
(
defaultAllowedPrefix
)
;
if
(
maxScopeURI
)
{
rv
=
GetRequiredScopeStringPrefix
(
maxScopeURI
maxPrefix
eUsePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
}
if
(
!
StringBeginsWith
(
mRegistration
-
>
mScope
maxPrefix
)
)
{
nsAutoString
message
;
NS_ConvertUTF8toUTF16
reportScope
(
mRegistration
-
>
mScope
)
;
NS_ConvertUTF8toUTF16
reportMaxPrefix
(
maxPrefix
)
;
const
char16_t
*
params
[
]
=
{
reportScope
.
get
(
)
reportMaxPrefix
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
ServiceWorkerScopePathMismatch
"
params
message
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
format
localized
string
"
)
;
swm
-
>
ReportToAllClients
(
mScope
message
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
errorFlag
)
;
FailUpdateJob
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
aInCacheAndEqual
)
{
Finish
(
NS_OK
)
;
return
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_UPDATED
1
)
;
RefPtr
<
ServiceWorkerInfo
>
sw
=
new
ServiceWorkerInfo
(
mRegistration
-
>
mPrincipal
mRegistration
-
>
mScope
mScriptSpec
aNewCacheName
mLoadFlags
)
;
mRegistration
-
>
SetEvaluating
(
sw
)
;
nsMainThreadPtrHandle
<
ServiceWorkerUpdateJob
>
handle
(
new
nsMainThreadPtrHolder
<
ServiceWorkerUpdateJob
>
(
"
ServiceWorkerUpdateJob
"
this
)
)
;
RefPtr
<
LifeCycleEventCallback
>
callback
=
new
ContinueUpdateRunnable
(
handle
)
;
ServiceWorkerPrivate
*
workerPrivate
=
sw
-
>
WorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
rv
=
workerPrivate
-
>
CheckScriptEvaluation
(
callback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
}
}
void
ServiceWorkerUpdateJob
:
:
ContinueUpdateAfterScriptEval
(
bool
aScriptEvaluationResult
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
Canceled
(
)
|
|
!
swm
)
{
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
}
if
(
NS_WARN_IF
(
!
aScriptEvaluationResult
)
)
{
ErrorResult
error
;
NS_ConvertUTF8toUTF16
scriptSpec
(
mScriptSpec
)
;
NS_ConvertUTF8toUTF16
scope
(
mRegistration
-
>
mScope
)
;
error
.
ThrowTypeError
<
MSG_SW_SCRIPT_THREW
>
(
scriptSpec
scope
)
;
FailUpdateJob
(
error
)
;
return
;
}
Install
(
swm
)
;
}
void
ServiceWorkerUpdateJob
:
:
Install
(
ServiceWorkerManager
*
aSWM
)
{
AssertIsOnMainThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
Canceled
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aSWM
)
;
MOZ_ASSERT
(
!
mRegistration
-
>
GetInstalling
(
)
)
;
mRegistration
-
>
TransitionEvaluatingToInstalling
(
)
;
InvokeResultCallbacks
(
NS_OK
)
;
nsCOMPtr
<
nsIRunnable
>
upr
=
NewRunnableMethod
<
RefPtr
<
ServiceWorkerRegistrationInfo
>
>
(
"
dom
:
:
workers
:
:
ServiceWorkerManager
:
:
"
"
FireUpdateFoundOnServiceWorkerRegistrations
"
aSWM
&
ServiceWorkerManager
:
:
FireUpdateFoundOnServiceWorkerRegistrations
mRegistration
)
;
NS_DispatchToMainThread
(
upr
)
;
nsCOMPtr
<
nsIRunnable
>
failRunnable
=
NewRunnableMethod
<
bool
>
(
"
dom
:
:
workers
:
:
ServiceWorkerUpdateJob
:
:
ContinueAfterInstallEvent
"
this
&
ServiceWorkerUpdateJob
:
:
ContinueAfterInstallEvent
false
)
;
nsMainThreadPtrHandle
<
ServiceWorkerUpdateJob
>
handle
(
new
nsMainThreadPtrHolder
<
ServiceWorkerUpdateJob
>
(
"
ServiceWorkerUpdateJob
"
this
)
)
;
RefPtr
<
LifeCycleEventCallback
>
callback
=
new
ContinueInstallRunnable
(
handle
)
;
ServiceWorkerPrivate
*
workerPrivate
=
mRegistration
-
>
GetInstalling
(
)
-
>
WorkerPrivate
(
)
;
nsresult
rv
=
workerPrivate
-
>
SendLifeCycleEvent
(
NS_LITERAL_STRING
(
"
install
"
)
callback
failRunnable
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ContinueAfterInstallEvent
(
false
)
;
}
}
void
ServiceWorkerUpdateJob
:
:
ContinueAfterInstallEvent
(
bool
aInstallEventSuccess
)
{
if
(
Canceled
(
)
)
{
return
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mRegistration
)
;
if
(
!
mRegistration
)
{
return
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
if
(
NS_WARN_IF
(
!
aInstallEventSuccess
)
)
{
FailUpdateJob
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mRegistration
-
>
GetInstalling
(
)
)
;
mRegistration
-
>
TransitionInstallingToWaiting
(
)
;
Finish
(
NS_OK
)
;
mRegistration
-
>
TryToActivateAsync
(
)
;
}
}
}
}
