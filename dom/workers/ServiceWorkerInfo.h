#
ifndef
mozilla_dom_workers_serviceworkerinfo_h
#
define
mozilla_dom_workers_serviceworkerinfo_h
#
include
"
mozilla
/
dom
/
ServiceWorkerBinding
.
h
"
#
include
"
nsIServiceWorkerManager
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
workers
{
class
ServiceWorker
;
class
ServiceWorkerPrivate
;
class
ServiceWorkerInfo
final
:
public
nsIServiceWorkerInfo
{
private
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
const
nsCString
mScope
;
const
nsCString
mScriptSpec
;
const
nsString
mCacheName
;
ServiceWorkerState
mState
;
PrincipalOriginAttributes
mOriginAttributes
;
uint64_t
mServiceWorkerID
;
AutoTArray
<
ServiceWorker
*
1
>
mInstances
;
RefPtr
<
ServiceWorkerPrivate
>
mServiceWorkerPrivate
;
bool
mSkipWaitingFlag
;
~
ServiceWorkerInfo
(
)
;
uint64_t
GetNextID
(
)
const
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISERVICEWORKERINFO
class
ServiceWorkerPrivate
*
WorkerPrivate
(
)
const
{
MOZ_ASSERT
(
mServiceWorkerPrivate
)
;
return
mServiceWorkerPrivate
;
}
nsIPrincipal
*
GetPrincipal
(
)
const
{
return
mPrincipal
;
}
const
nsCString
&
ScriptSpec
(
)
const
{
return
mScriptSpec
;
}
const
nsCString
&
Scope
(
)
const
{
return
mScope
;
}
bool
SkipWaitingFlag
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mSkipWaitingFlag
;
}
void
SetSkipWaitingFlag
(
)
{
AssertIsOnMainThread
(
)
;
mSkipWaitingFlag
=
true
;
}
ServiceWorkerInfo
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
const
nsACString
&
aScriptSpec
const
nsAString
&
aCacheName
)
;
ServiceWorkerState
State
(
)
const
{
return
mState
;
}
const
PrincipalOriginAttributes
&
GetOriginAttributes
(
)
const
{
return
mOriginAttributes
;
}
const
nsString
&
CacheName
(
)
const
{
return
mCacheName
;
}
uint64_t
ID
(
)
const
{
return
mServiceWorkerID
;
}
void
UpdateState
(
ServiceWorkerState
aState
)
;
void
SetActivateStateUncheckedWithoutEvent
(
ServiceWorkerState
aState
)
{
AssertIsOnMainThread
(
)
;
mState
=
aState
;
}
void
AppendWorker
(
ServiceWorker
*
aWorker
)
;
void
RemoveWorker
(
ServiceWorker
*
aWorker
)
;
already_AddRefed
<
ServiceWorker
>
GetOrCreateInstance
(
nsPIDOMWindowInner
*
aWindow
)
;
}
;
}
}
}
#
endif
