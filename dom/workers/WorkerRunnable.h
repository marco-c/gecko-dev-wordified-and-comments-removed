#
ifndef
mozilla_dom_workers_workerrunnable_h__
#
define
mozilla_dom_workers_workerrunnable_h__
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerStatus
.
h
"
#
include
"
nsICancelableRunnable
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsThreadUtils
.
h
"
struct
JSContext
;
class
nsIEventTarget
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
WorkerPrivate
;
class
WorkerRunnable
:
public
nsIRunnable
public
nsICancelableRunnable
{
public
:
enum
TargetAndBusyBehavior
{
ParentThreadUnchangedBusyCount
WorkerThreadModifyBusyCount
WorkerThreadUnchangedBusyCount
}
;
protected
:
WorkerPrivate
*
mWorkerPrivate
;
TargetAndBusyBehavior
mBehavior
;
Atomic
<
uint32_t
>
mCanceled
;
private
:
bool
mCallingCancelWithinRun
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
nsresult
Cancel
(
)
override
;
bool
Dispatch
(
)
;
virtual
bool
IsCanceled
(
)
const
{
return
mCanceled
!
=
0
;
}
virtual
bool
IsDebuggeeRunnable
(
)
const
{
return
false
;
}
static
WorkerRunnable
*
FromRunnable
(
nsIRunnable
*
aRunnable
)
;
protected
:
WorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
=
WorkerThreadModifyBusyCount
)
#
ifdef
DEBUG
;
#
else
:
mWorkerPrivate
(
aWorkerPrivate
)
mBehavior
(
aBehavior
)
mCanceled
(
0
)
mCallingCancelWithinRun
(
false
)
{
}
#
endif
virtual
~
WorkerRunnable
(
)
=
default
;
virtual
bool
IsDebuggerRunnable
(
)
const
;
nsIGlobalObject
*
DefaultGlobalObject
(
)
const
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
;
virtual
bool
PreRun
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
virtual
void
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
;
virtual
bool
DispatchInternal
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
WorkerDebuggerRunnable
:
public
WorkerRunnable
{
protected
:
explicit
WorkerDebuggerRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
virtual
~
WorkerDebuggerRunnable
(
)
=
default
;
private
:
virtual
bool
IsDebuggerRunnable
(
)
const
override
{
return
true
;
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
final
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
}
;
class
WorkerSyncRunnable
:
public
WorkerRunnable
{
protected
:
nsCOMPtr
<
nsIEventTarget
>
mSyncLoopTarget
;
WorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsIEventTarget
*
aSyncLoopTarget
)
;
WorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIEventTarget
>
&
&
aSyncLoopTarget
)
;
virtual
~
WorkerSyncRunnable
(
)
;
virtual
bool
DispatchInternal
(
)
override
;
}
;
class
MainThreadWorkerSyncRunnable
:
public
WorkerSyncRunnable
{
protected
:
MainThreadWorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsIEventTarget
*
aSyncLoopTarget
)
:
WorkerSyncRunnable
(
aWorkerPrivate
aSyncLoopTarget
)
{
AssertIsOnMainThread
(
)
;
}
MainThreadWorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIEventTarget
>
&
&
aSyncLoopTarget
)
:
WorkerSyncRunnable
(
aWorkerPrivate
std
:
:
move
(
aSyncLoopTarget
)
)
{
AssertIsOnMainThread
(
)
;
}
virtual
~
MainThreadWorkerSyncRunnable
(
)
=
default
;
private
:
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
}
;
class
WorkerControlRunnable
:
public
WorkerRunnable
{
friend
class
WorkerPrivate
;
protected
:
WorkerControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
)
#
ifdef
DEBUG
;
#
else
:
WorkerRunnable
(
aWorkerPrivate
aBehavior
)
{
}
#
endif
virtual
~
WorkerControlRunnable
(
)
=
default
;
nsresult
Cancel
(
)
override
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
WorkerControlRunnable
WorkerRunnable
)
private
:
virtual
bool
DispatchInternal
(
)
override
;
using
WorkerRunnable
:
:
Cancel
;
}
;
class
MainThreadWorkerRunnable
:
public
WorkerRunnable
{
protected
:
explicit
MainThreadWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
AssertIsOnMainThread
(
)
;
}
virtual
~
MainThreadWorkerRunnable
(
)
=
default
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
AssertIsOnMainThread
(
)
;
}
}
;
class
MainThreadWorkerControlRunnable
:
public
WorkerControlRunnable
{
protected
:
explicit
MainThreadWorkerControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
{
}
virtual
~
MainThreadWorkerControlRunnable
(
)
=
default
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
AssertIsOnMainThread
(
)
;
}
}
;
class
WorkerSameThreadRunnable
:
public
WorkerRunnable
{
protected
:
explicit
WorkerSameThreadRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadModifyBusyCount
)
{
}
virtual
~
WorkerSameThreadRunnable
(
)
=
default
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
;
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
}
;
class
WorkerMainThreadRunnable
:
public
Runnable
{
protected
:
WorkerPrivate
*
mWorkerPrivate
;
nsCOMPtr
<
nsIEventTarget
>
mSyncLoopTarget
;
const
nsCString
mTelemetryKey
;
explicit
WorkerMainThreadRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsACString
&
aTelemetryKey
)
;
~
WorkerMainThreadRunnable
(
)
=
default
;
virtual
bool
MainThreadRun
(
)
=
0
;
public
:
void
Dispatch
(
WorkerStatus
aFailStatus
ErrorResult
&
aRv
)
;
private
:
NS_IMETHOD
Run
(
)
override
;
}
;
class
WorkerProxyToMainThreadRunnable
:
public
Runnable
{
protected
:
WorkerProxyToMainThreadRunnable
(
)
;
virtual
~
WorkerProxyToMainThreadRunnable
(
)
;
virtual
void
RunOnMainThread
(
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
virtual
void
RunBackOnWorkerThreadForCleanup
(
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
public
:
bool
Dispatch
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
bool
ForMessaging
(
)
const
{
return
false
;
}
private
:
NS_IMETHOD
Run
(
)
override
;
void
PostDispatchOnMainThread
(
)
;
void
ReleaseWorker
(
)
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
}
;
class
MainThreadStopSyncLoopRunnable
:
public
WorkerSyncRunnable
{
bool
mResult
;
public
:
MainThreadStopSyncLoopRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIEventTarget
>
&
&
aSyncLoopTarget
bool
aResult
)
;
nsresult
Cancel
(
)
override
;
protected
:
virtual
~
MainThreadStopSyncLoopRunnable
(
)
=
default
;
private
:
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
final
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
;
bool
DispatchInternal
(
)
final
;
}
;
class
WorkerDebuggeeRunnable
:
public
WorkerRunnable
{
protected
:
WorkerDebuggeeRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
=
ParentThreadUnchangedBusyCount
)
:
WorkerRunnable
(
aWorkerPrivate
aBehavior
)
{
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
;
private
:
bool
IsDebuggeeRunnable
(
)
const
override
{
return
true
;
}
RefPtr
<
ThreadSafeWorkerRef
>
mSender
;
}
;
}
}
#
endif
