#
ifndef
mozilla_dom_workers_workerrunnable_h__
#
define
mozilla_dom_workers_workerrunnable_h__
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerStatus
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nscore
.
h
"
struct
JSContext
;
class
nsIEventTarget
;
class
nsIGlobalObject
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
WorkerPrivate
;
class
WorkerRunnable
:
public
nsIRunnable
{
public
:
enum
Target
{
ParentThread
WorkerThread
}
;
protected
:
WorkerPrivate
*
mWorkerPrivate
;
Target
mTarget
;
private
:
bool
mCallingCancelWithinRun
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
virtual
nsresult
Cancel
(
)
;
bool
Dispatch
(
)
;
virtual
bool
IsDebuggeeRunnable
(
)
const
{
return
false
;
}
static
WorkerRunnable
*
FromRunnable
(
nsIRunnable
*
aRunnable
)
;
protected
:
WorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
Target
aTarget
=
WorkerThread
)
#
ifdef
DEBUG
;
#
else
:
mWorkerPrivate
(
aWorkerPrivate
)
mTarget
(
aTarget
)
mCallingCancelWithinRun
(
false
)
{
}
#
endif
virtual
~
WorkerRunnable
(
)
=
default
;
virtual
bool
IsDebuggerRunnable
(
)
const
;
nsIGlobalObject
*
DefaultGlobalObject
(
)
const
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
;
virtual
bool
PreRun
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
virtual
void
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
;
virtual
bool
DispatchInternal
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
WorkerDebuggerRunnable
:
public
WorkerRunnable
{
protected
:
explicit
WorkerDebuggerRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThread
)
{
}
virtual
~
WorkerDebuggerRunnable
(
)
=
default
;
private
:
virtual
bool
IsDebuggerRunnable
(
)
const
override
{
return
true
;
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
final
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
}
;
class
WorkerSyncRunnable
:
public
WorkerRunnable
{
protected
:
nsCOMPtr
<
nsIEventTarget
>
mSyncLoopTarget
;
WorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsIEventTarget
*
aSyncLoopTarget
)
;
WorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIEventTarget
>
&
&
aSyncLoopTarget
)
;
virtual
~
WorkerSyncRunnable
(
)
;
virtual
bool
DispatchInternal
(
)
override
;
}
;
class
MainThreadWorkerSyncRunnable
:
public
WorkerSyncRunnable
{
protected
:
MainThreadWorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsIEventTarget
*
aSyncLoopTarget
)
:
WorkerSyncRunnable
(
aWorkerPrivate
aSyncLoopTarget
)
{
AssertIsOnMainThread
(
)
;
}
MainThreadWorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIEventTarget
>
&
&
aSyncLoopTarget
)
:
WorkerSyncRunnable
(
aWorkerPrivate
std
:
:
move
(
aSyncLoopTarget
)
)
{
AssertIsOnMainThread
(
)
;
}
virtual
~
MainThreadWorkerSyncRunnable
(
)
=
default
;
private
:
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
}
;
class
WorkerControlRunnable
:
public
WorkerRunnable
{
friend
class
WorkerPrivate
;
protected
:
WorkerControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
Target
aTarget
)
#
ifdef
DEBUG
;
#
else
:
WorkerRunnable
(
aWorkerPrivate
aTarget
)
{
}
#
endif
virtual
~
WorkerControlRunnable
(
)
=
default
;
nsresult
Cancel
(
)
override
;
public
:
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
WorkerControlRunnable
WorkerRunnable
)
private
:
virtual
bool
DispatchInternal
(
)
override
;
using
WorkerRunnable
:
:
Cancel
;
}
;
class
MainThreadWorkerRunnable
:
public
WorkerRunnable
{
protected
:
explicit
MainThreadWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThread
)
{
AssertIsOnMainThread
(
)
;
}
virtual
~
MainThreadWorkerRunnable
(
)
=
default
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
AssertIsOnMainThread
(
)
;
}
}
;
class
MainThreadWorkerControlRunnable
:
public
WorkerControlRunnable
{
protected
:
explicit
MainThreadWorkerControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerControlRunnable
(
aWorkerPrivate
WorkerThread
)
{
}
virtual
~
MainThreadWorkerControlRunnable
(
)
=
default
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
{
AssertIsOnMainThread
(
)
;
}
}
;
class
WorkerSameThreadRunnable
:
public
WorkerRunnable
{
protected
:
explicit
WorkerSameThreadRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThread
)
{
}
virtual
~
WorkerSameThreadRunnable
(
)
=
default
;
virtual
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
;
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
}
;
class
WorkerMainThreadRunnable
:
public
Runnable
{
protected
:
WorkerPrivate
*
mWorkerPrivate
;
nsCOMPtr
<
nsISerialEventTarget
>
mSyncLoopTarget
;
const
nsCString
mTelemetryKey
;
explicit
WorkerMainThreadRunnable
(
WorkerPrivate
*
aWorkerPrivate
const
nsACString
&
aTelemetryKey
)
;
~
WorkerMainThreadRunnable
(
)
;
virtual
bool
MainThreadRun
(
)
=
0
;
public
:
void
Dispatch
(
WorkerStatus
aFailStatus
ErrorResult
&
aRv
)
;
private
:
NS_IMETHOD
Run
(
)
override
;
}
;
class
WorkerProxyToMainThreadRunnable
:
public
Runnable
{
protected
:
WorkerProxyToMainThreadRunnable
(
)
;
virtual
~
WorkerProxyToMainThreadRunnable
(
)
;
virtual
void
RunOnMainThread
(
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
virtual
void
RunBackOnWorkerThreadForCleanup
(
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
public
:
bool
Dispatch
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
bool
ForMessaging
(
)
const
{
return
false
;
}
private
:
NS_IMETHOD
Run
(
)
override
;
void
PostDispatchOnMainThread
(
)
;
void
ReleaseWorker
(
)
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
}
;
class
MainThreadStopSyncLoopRunnable
:
public
WorkerSyncRunnable
{
nsresult
mResult
;
public
:
MainThreadStopSyncLoopRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsCOMPtr
<
nsIEventTarget
>
&
&
aSyncLoopTarget
nsresult
aResult
)
;
nsresult
Cancel
(
)
override
;
protected
:
virtual
~
MainThreadStopSyncLoopRunnable
(
)
=
default
;
private
:
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
final
{
AssertIsOnMainThread
(
)
;
return
true
;
}
virtual
void
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
override
;
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
;
bool
DispatchInternal
(
)
final
;
}
;
class
WorkerDebuggeeRunnable
:
public
WorkerRunnable
{
protected
:
WorkerDebuggeeRunnable
(
WorkerPrivate
*
aWorkerPrivate
Target
aTarget
=
ParentThread
)
:
WorkerRunnable
(
aWorkerPrivate
aTarget
)
{
}
bool
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
override
;
private
:
bool
IsDebuggeeRunnable
(
)
const
override
{
return
true
;
}
RefPtr
<
ThreadSafeWorkerRef
>
mSender
;
}
;
}
}
#
endif
