#
ifndef
mozilla_dom_workers_workerprivate_h__
#
define
mozilla_dom_workers_workerprivate_h__
#
include
"
WorkerCommon
.
h
"
#
include
"
mozilla
/
CondVar
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
Queue
.
h
"
#
include
"
WorkerHolder
.
h
"
#
include
"
WorkerLoadInfo
.
h
"
#
ifdef
XP_WIN
#
undef
PostMessage
#
endif
class
nsIConsoleReportCollector
;
class
nsIThreadInternal
;
namespace
mozilla
{
namespace
dom
{
class
ClientInfo
;
class
ClientSource
;
class
Function
;
class
MessagePort
;
class
MessagePortIdentifier
;
class
PerformanceStorage
;
class
WorkerDebuggerGlobalScope
;
class
WorkerErrorReport
;
class
WorkerGlobalScope
;
struct
WorkerOptions
;
}
}
BEGIN_WORKERS_NAMESPACE
class
SharedWorker
;
class
WorkerControlRunnable
;
class
WorkerDebugger
;
class
WorkerEventTarget
;
class
WorkerRunnable
;
class
WorkerThread
;
class
SharedMutex
{
typedef
mozilla
:
:
Mutex
Mutex
;
class
RefCountedMutex
final
:
public
Mutex
{
public
:
explicit
RefCountedMutex
(
const
char
*
aName
)
:
Mutex
(
aName
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefCountedMutex
)
private
:
~
RefCountedMutex
(
)
{
}
}
;
RefPtr
<
RefCountedMutex
>
mMutex
;
public
:
explicit
SharedMutex
(
const
char
*
aName
)
:
mMutex
(
new
RefCountedMutex
(
aName
)
)
{
}
SharedMutex
(
SharedMutex
&
aOther
)
:
mMutex
(
aOther
.
mMutex
)
{
}
operator
Mutex
&
(
)
{
return
*
mMutex
;
}
operator
const
Mutex
&
(
)
const
{
return
*
mMutex
;
}
void
AssertCurrentThreadOwns
(
)
const
{
mMutex
-
>
AssertCurrentThreadOwns
(
)
;
}
}
;
template
<
class
Derived
>
class
WorkerPrivateParent
:
public
DOMEventTargetHelper
{
protected
:
class
EventTarget
;
friend
class
EventTarget
;
typedef
mozilla
:
:
ipc
:
:
PrincipalInfo
PrincipalInfo
;
public
:
struct
LocationInfo
{
nsCString
mHref
;
nsCString
mProtocol
;
nsCString
mHost
;
nsCString
mHostname
;
nsCString
mPort
;
nsCString
mPathname
;
nsCString
mSearch
;
nsCString
mHash
;
nsString
mOrigin
;
}
;
protected
:
typedef
mozilla
:
:
ErrorResult
ErrorResult
;
SharedMutex
mMutex
;
mozilla
:
:
CondVar
mCondVar
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
mPreStartRunnables
;
private
:
WorkerPrivate
*
mParent
;
nsString
mScriptURL
;
nsString
mWorkerName
;
LocationInfo
mLocationInfo
;
WorkerLoadInfo
mLoadInfo
;
Atomic
<
bool
>
mLoadingWorkerScript
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mQueuedRunnables
;
JSSettings
mJSSettings
;
nsTArray
<
RefPtr
<
SharedWorker
>
>
mSharedWorkers
;
Atomic
<
uint64_t
>
mBusyCount
;
uint32_t
mParentWindowPausedDepth
;
Status
mParentStatus
;
bool
mParentFrozen
;
bool
mIsChromeWorker
;
bool
mMainThreadObjectsForgotten
;
bool
mIsSecureContext
;
WorkerType
mWorkerType
;
TimeStamp
mCreationTimeStamp
;
DOMHighResTimeStamp
mCreationTimeHighRes
;
protected
:
RefPtr
<
WorkerPrivate
>
mSelfRef
;
WorkerPrivateParent
(
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsAString
&
aWorkerName
const
nsACString
&
aServiceWorkerScope
WorkerLoadInfo
&
aLoadInfo
)
;
~
WorkerPrivateParent
(
)
;
private
:
Derived
*
ParentAsWorkerPrivate
(
)
const
{
return
static_cast
<
Derived
*
>
(
const_cast
<
WorkerPrivateParent
*
>
(
this
)
)
;
}
bool
NotifyPrivate
(
Status
aStatus
)
;
bool
TerminatePrivate
(
)
{
return
NotifyPrivate
(
Terminating
)
;
}
void
PostMessageInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
;
nsresult
DispatchPrivate
(
already_AddRefed
<
WorkerRunnable
>
aRunnable
nsIEventTarget
*
aSyncLoopTarget
)
;
public
:
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
WorkerPrivateParent
DOMEventTargetHelper
)
void
EnableDebugger
(
)
;
void
DisableDebugger
(
)
;
void
ClearSelfRef
(
)
{
AssertIsOnParentThread
(
)
;
MOZ_ASSERT
(
mSelfRef
)
;
mSelfRef
=
nullptr
;
}
nsresult
Dispatch
(
already_AddRefed
<
WorkerRunnable
>
aRunnable
)
{
return
DispatchPrivate
(
Move
(
aRunnable
)
nullptr
)
;
}
nsresult
DispatchControlRunnable
(
already_AddRefed
<
WorkerControlRunnable
>
aWorkerControlRunnable
)
;
nsresult
DispatchDebuggerRunnable
(
already_AddRefed
<
WorkerRunnable
>
aDebuggerRunnable
)
;
already_AddRefed
<
WorkerRunnable
>
MaybeWrapAsWorkerRunnable
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
bool
Start
(
)
;
bool
Notify
(
Status
aStatus
)
{
return
NotifyPrivate
(
aStatus
)
;
}
bool
Cancel
(
)
{
return
Notify
(
Canceling
)
;
}
bool
Kill
(
)
{
return
Notify
(
Killing
)
;
}
bool
Freeze
(
nsPIDOMWindowInner
*
aWindow
)
;
bool
Thaw
(
nsPIDOMWindowInner
*
aWindow
)
;
void
ParentWindowPaused
(
)
;
void
ParentWindowResumed
(
)
;
bool
Terminate
(
)
{
AssertIsOnParentThread
(
)
;
return
TerminatePrivate
(
)
;
}
bool
Close
(
)
;
bool
ModifyBusyCount
(
bool
aIncrease
)
;
bool
ProxyReleaseMainThreadObjects
(
)
;
void
PostMessage
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
;
void
UpdateContextOptions
(
const
JS
:
:
ContextOptions
&
aContextOptions
)
;
void
UpdateLanguages
(
const
nsTArray
<
nsString
>
&
aLanguages
)
;
void
UpdateJSWorkerMemoryParameter
(
JSGCParamKey
key
uint32_t
value
)
;
#
ifdef
JS_GC_ZEAL
void
UpdateGCZeal
(
uint8_t
aGCZeal
uint32_t
aFrequency
)
;
#
endif
void
GarbageCollect
(
bool
aShrinking
)
;
void
CycleCollect
(
bool
aDummy
)
;
void
OfflineStatusChangeEvent
(
bool
aIsOffline
)
;
void
MemoryPressure
(
bool
aDummy
)
;
bool
RegisterSharedWorker
(
SharedWorker
*
aSharedWorker
MessagePort
*
aPort
)
;
void
BroadcastErrorToSharedWorkers
(
JSContext
*
aCx
const
WorkerErrorReport
*
aReport
bool
aIsErrorEvent
)
;
void
WorkerScriptLoaded
(
)
;
void
QueueRunnable
(
nsIRunnable
*
aRunnable
)
{
AssertIsOnParentThread
(
)
;
mQueuedRunnables
.
AppendElement
(
aRunnable
)
;
}
WorkerPrivate
*
GetParent
(
)
const
{
return
mParent
;
}
bool
IsFrozen
(
)
const
{
AssertIsOnParentThread
(
)
;
return
mParentFrozen
;
}
bool
IsParentWindowPaused
(
)
const
{
AssertIsOnParentThread
(
)
;
return
mParentWindowPausedDepth
>
0
;
}
bool
IsAcceptingEvents
(
)
{
AssertIsOnParentThread
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
return
mParentStatus
<
Terminating
;
}
Status
ParentStatus
(
)
const
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
return
mParentStatus
;
}
nsIScriptContext
*
GetScriptContext
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mScriptContext
;
}
const
nsString
&
ScriptURL
(
)
const
{
return
mScriptURL
;
}
const
nsCString
&
Domain
(
)
const
{
return
mLoadInfo
.
mDomain
;
}
bool
IsFromWindow
(
)
const
{
return
mLoadInfo
.
mFromWindow
;
}
nsLoadFlags
GetLoadFlags
(
)
const
{
return
mLoadInfo
.
mLoadFlags
;
}
uint64_t
WindowID
(
)
const
{
return
mLoadInfo
.
mWindowID
;
}
uint64_t
ServiceWorkerID
(
)
const
{
return
GetServiceWorkerDescriptor
(
)
.
Id
(
)
;
}
const
nsCString
&
ServiceWorkerScope
(
)
const
{
return
GetServiceWorkerDescriptor
(
)
.
Scope
(
)
;
}
nsIURI
*
GetBaseURI
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mBaseURI
;
}
void
SetBaseURI
(
nsIURI
*
aBaseURI
)
;
nsIURI
*
GetResolvedScriptURI
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mResolvedScriptURI
;
}
const
nsString
&
ServiceWorkerCacheName
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
IsServiceWorker
(
)
)
;
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mServiceWorkerCacheName
;
}
const
ServiceWorkerDescriptor
&
GetServiceWorkerDescriptor
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
IsServiceWorker
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mLoadInfo
.
mServiceWorkerDescriptor
.
isSome
(
)
)
;
return
mLoadInfo
.
mServiceWorkerDescriptor
.
ref
(
)
;
}
void
UpdateServiceWorkerState
(
ServiceWorkerState
aState
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsServiceWorker
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mLoadInfo
.
mServiceWorkerDescriptor
.
isSome
(
)
)
;
return
mLoadInfo
.
mServiceWorkerDescriptor
.
ref
(
)
.
SetState
(
aState
)
;
}
const
Maybe
<
ServiceWorkerDescriptor
>
&
GetParentController
(
)
const
{
return
mLoadInfo
.
mParentController
;
}
const
ChannelInfo
&
GetChannelInfo
(
)
const
{
return
mLoadInfo
.
mChannelInfo
;
}
void
SetChannelInfo
(
const
ChannelInfo
&
aChannelInfo
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mLoadInfo
.
mChannelInfo
.
IsInitialized
(
)
)
;
MOZ_ASSERT
(
aChannelInfo
.
IsInitialized
(
)
)
;
mLoadInfo
.
mChannelInfo
=
aChannelInfo
;
}
void
InitChannelInfo
(
nsIChannel
*
aChannel
)
{
mLoadInfo
.
mChannelInfo
.
InitFromChannel
(
aChannel
)
;
}
void
InitChannelInfo
(
const
ChannelInfo
&
aChannelInfo
)
{
mLoadInfo
.
mChannelInfo
=
aChannelInfo
;
}
bool
LoadScriptAsPartOfLoadingServiceWorkerScript
(
)
{
MOZ_ASSERT
(
IsServiceWorker
(
)
)
;
return
mLoadingWorkerScript
;
}
void
SetLoadingWorkerScript
(
bool
aLoadingWorkerScript
)
{
MOZ_ASSERT
(
IsServiceWorker
(
)
)
;
mLoadingWorkerScript
=
aLoadingWorkerScript
;
}
TimeStamp
CreationTimeStamp
(
)
const
{
return
mCreationTimeStamp
;
}
DOMHighResTimeStamp
CreationTime
(
)
const
{
return
mCreationTimeHighRes
;
}
DOMHighResTimeStamp
TimeStampToDOMHighRes
(
const
TimeStamp
&
aTimeStamp
)
const
{
MOZ_ASSERT
(
!
aTimeStamp
.
IsNull
(
)
)
;
TimeDuration
duration
=
aTimeStamp
-
mCreationTimeStamp
;
return
duration
.
ToMilliseconds
(
)
;
}
nsIPrincipal
*
GetPrincipal
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mPrincipal
;
}
nsIPrincipal
*
GetLoadingPrincipal
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mLoadingPrincipal
;
}
const
nsAString
&
Origin
(
)
const
{
return
mLoadInfo
.
mOrigin
;
}
nsILoadGroup
*
GetLoadGroup
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mLoadGroup
;
}
nsIPrincipal
*
GetPrincipalDontAssertMainThread
(
)
const
{
return
mLoadInfo
.
mPrincipal
;
}
nsresult
SetPrincipalOnMainThread
(
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
;
nsresult
SetPrincipalFromChannel
(
nsIChannel
*
aChannel
)
;
bool
FinalChannelPrincipalIsValid
(
nsIChannel
*
aChannel
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
PrincipalURIMatchesScriptURL
(
)
;
#
endif
bool
UsesSystemPrincipal
(
)
const
{
return
mLoadInfo
.
mPrincipalIsSystem
;
}
const
PrincipalInfo
&
GetPrincipalInfo
(
)
const
{
return
*
mLoadInfo
.
mPrincipalInfo
;
}
already_AddRefed
<
nsIChannel
>
ForgetWorkerChannel
(
)
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mChannel
.
forget
(
)
;
}
nsIDocument
*
GetDocument
(
)
const
;
nsPIDOMWindowInner
*
GetWindow
(
)
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mWindow
;
}
nsIContentSecurityPolicy
*
GetCSP
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mLoadInfo
.
mCSP
;
}
void
SetCSP
(
nsIContentSecurityPolicy
*
aCSP
)
;
nsresult
SetCSPFromHeaderValues
(
const
nsACString
&
aCSPHeaderValue
const
nsACString
&
aCSPReportOnlyHeaderValue
)
;
void
SetReferrerPolicyFromHeaderValue
(
const
nsACString
&
aReferrerPolicyHeaderValue
)
;
net
:
:
ReferrerPolicy
GetReferrerPolicy
(
)
const
{
return
mLoadInfo
.
mReferrerPolicy
;
}
void
SetReferrerPolicy
(
net
:
:
ReferrerPolicy
aReferrerPolicy
)
{
mLoadInfo
.
mReferrerPolicy
=
aReferrerPolicy
;
}
bool
IsEvalAllowed
(
)
const
{
return
mLoadInfo
.
mEvalAllowed
;
}
void
SetEvalAllowed
(
bool
aEvalAllowed
)
{
mLoadInfo
.
mEvalAllowed
=
aEvalAllowed
;
}
bool
GetReportCSPViolations
(
)
const
{
return
mLoadInfo
.
mReportCSPViolations
;
}
void
SetReportCSPViolations
(
bool
aReport
)
{
mLoadInfo
.
mReportCSPViolations
=
aReport
;
}
bool
XHRParamsAllowed
(
)
const
{
return
mLoadInfo
.
mXHRParamsAllowed
;
}
void
SetXHRParamsAllowed
(
bool
aAllowed
)
{
mLoadInfo
.
mXHRParamsAllowed
=
aAllowed
;
}
LocationInfo
&
GetLocationInfo
(
)
{
return
mLocationInfo
;
}
void
CopyJSSettings
(
JSSettings
&
aSettings
)
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
aSettings
=
mJSSettings
;
}
void
CopyJSCompartmentOptions
(
JS
:
:
CompartmentOptions
&
aOptions
)
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
aOptions
=
IsChromeWorker
(
)
?
mJSSettings
.
chrome
.
compartmentOptions
:
mJSSettings
.
content
.
compartmentOptions
;
}
bool
IsChromeWorker
(
)
const
{
return
mIsChromeWorker
;
}
WorkerType
Type
(
)
const
{
return
mWorkerType
;
}
bool
IsDedicatedWorker
(
)
const
{
return
mWorkerType
=
=
WorkerTypeDedicated
;
}
bool
IsSharedWorker
(
)
const
{
return
mWorkerType
=
=
WorkerTypeShared
;
}
bool
IsServiceWorker
(
)
const
{
return
mWorkerType
=
=
WorkerTypeService
;
}
nsContentPolicyType
ContentPolicyType
(
)
const
{
return
ContentPolicyType
(
mWorkerType
)
;
}
static
nsContentPolicyType
ContentPolicyType
(
WorkerType
aWorkerType
)
{
switch
(
aWorkerType
)
{
case
WorkerTypeDedicated
:
return
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
;
case
WorkerTypeShared
:
return
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
;
case
WorkerTypeService
:
return
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
worker
type
"
)
;
return
nsIContentPolicy
:
:
TYPE_INVALID
;
}
}
const
nsString
&
WorkerName
(
)
const
{
return
mWorkerName
;
}
bool
IsStorageAllowed
(
)
const
{
return
mLoadInfo
.
mStorageAllowed
;
}
const
OriginAttributes
&
GetOriginAttributes
(
)
const
{
return
mLoadInfo
.
mOriginAttributes
;
}
bool
ServiceWorkersTestingInWindow
(
)
const
{
return
mLoadInfo
.
mServiceWorkersTestingInWindow
;
}
void
GetAllSharedWorkers
(
nsTArray
<
RefPtr
<
SharedWorker
>
>
&
aSharedWorkers
)
;
void
CloseSharedWorkersForWindow
(
nsPIDOMWindowInner
*
aWindow
)
;
void
CloseAllSharedWorkers
(
)
;
void
UpdateOverridenLoadGroup
(
nsILoadGroup
*
aBaseLoadGroup
)
;
already_AddRefed
<
nsIRunnable
>
StealLoadFailedAsyncRunnable
(
)
{
return
mLoadInfo
.
mLoadFailedAsyncRunnable
.
forget
(
)
;
}
void
FlushReportsToSharedWorkers
(
nsIConsoleReportCollector
*
aReporter
)
;
IMPL_EVENT_HANDLER
(
message
)
IMPL_EVENT_HANDLER
(
messageerror
)
IMPL_EVENT_HANDLER
(
error
)
bool
IsSecureContext
(
)
const
{
return
mIsSecureContext
;
}
#
ifdef
DEBUG
void
AssertIsOnParentThread
(
)
const
;
void
AssertInnerWindowIsCorrect
(
)
const
;
#
else
void
AssertIsOnParentThread
(
)
const
{
}
void
AssertInnerWindowIsCorrect
(
)
const
{
}
#
endif
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
PrincipalIsValid
(
)
const
;
#
endif
uint32_t
BusyCount
(
)
{
return
mBusyCount
;
}
}
;
class
WorkerPrivate
:
public
WorkerPrivateParent
<
WorkerPrivate
>
{
friend
class
WorkerHolder
;
friend
class
WorkerPrivateParent
<
WorkerPrivate
>
;
typedef
WorkerPrivateParent
<
WorkerPrivate
>
ParentType
;
friend
class
AutoSyncLoopHolder
;
struct
TimeoutInfo
;
class
MemoryReporter
;
friend
class
MemoryReporter
;
friend
class
WorkerThread
;
enum
GCTimerMode
{
PeriodicTimer
=
0
IdleTimer
NoTimer
}
;
bool
mDebuggerRegistered
;
WorkerDebugger
*
mDebugger
;
Queue
<
WorkerControlRunnable
*
4
>
mControlQueue
;
Queue
<
WorkerRunnable
*
4
>
mDebuggerQueue
;
JSContext
*
mJSContext
;
RefPtr
<
WorkerCrossThreadDispatcher
>
mCrossThreadDispatcher
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mUndispatchedRunnablesForSyncLoop
;
RefPtr
<
WorkerThread
>
mThread
;
PRThread
*
mPRThread
;
RefPtr
<
WorkerGlobalScope
>
mScope
;
RefPtr
<
WorkerDebuggerGlobalScope
>
mDebuggerScope
;
nsTArray
<
ParentType
*
>
mChildWorkers
;
nsTObserverArray
<
WorkerHolder
*
>
mHolders
;
uint32_t
mNumHoldersPreventingShutdownStart
;
nsTArray
<
nsAutoPtr
<
TimeoutInfo
>
>
mTimeouts
;
uint32_t
mDebuggerEventLoopLevel
;
RefPtr
<
ThrottledEventQueue
>
mMainThreadThrottledEventQueue
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
RefPtr
<
WorkerEventTarget
>
mWorkerControlEventTarget
;
RefPtr
<
WorkerEventTarget
>
mWorkerHybridEventTarget
;
struct
SyncLoopInfo
{
explicit
SyncLoopInfo
(
EventTarget
*
aEventTarget
)
;
RefPtr
<
EventTarget
>
mEventTarget
;
bool
mCompleted
;
bool
mResult
;
#
ifdef
DEBUG
bool
mHasRun
;
#
endif
}
;
nsTArray
<
nsAutoPtr
<
SyncLoopInfo
>
>
mSyncLoopStack
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsCOMPtr
<
nsITimerCallback
>
mTimerRunnable
;
nsCOMPtr
<
nsITimer
>
mGCTimer
;
RefPtr
<
MemoryReporter
>
mMemoryReporter
;
nsCOMPtr
<
nsIRunnable
>
mLoadFailedRunnable
;
RefPtr
<
PerformanceStorage
>
mPerformanceStorage
;
JS
:
:
UniqueChars
mDefaultLocale
;
TimeStamp
mKillTime
;
uint32_t
mErrorHandlerRecursionCount
;
uint32_t
mNextTimeoutId
;
Status
mStatus
;
UniquePtr
<
ClientSource
>
mClientSource
;
bool
mFrozen
;
bool
mTimerRunning
;
bool
mRunningExpiredTimeouts
;
bool
mPendingEventQueueClearing
;
bool
mCancelAllPendingRunnables
;
bool
mPeriodicGCTimerRunning
;
bool
mIdleGCTimerRunning
;
bool
mWorkerScriptExecutedSuccessfully
;
bool
mFetchHandlerWasAdded
;
bool
mOnLine
;
protected
:
~
WorkerPrivate
(
)
;
public
:
static
already_AddRefed
<
WorkerPrivate
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aScriptURL
const
WorkerOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
WorkerPrivate
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsAString
&
aWorkerName
WorkerLoadInfo
*
aLoadInfo
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
WorkerPrivate
>
Constructor
(
JSContext
*
aCx
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsAString
&
aWorkerName
const
nsACString
&
aServiceWorkerScope
WorkerLoadInfo
*
aLoadInfo
ErrorResult
&
aRv
)
;
static
bool
WorkerAvailable
(
JSContext
*
JSObject
*
)
;
enum
LoadGroupBehavior
{
InheritLoadGroup
OverrideLoadGroup
}
;
static
nsresult
GetLoadInfo
(
JSContext
*
aCx
nsPIDOMWindowInner
*
aWindow
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
LoadGroupBehavior
aLoadGroupBehavior
WorkerType
aWorkerType
WorkerLoadInfo
*
aLoadInfo
)
;
static
void
OverrideLoadInfoLoadGroup
(
WorkerLoadInfo
&
aLoadInfo
nsIPrincipal
*
aPrincipal
)
;
bool
IsDebuggerRegistered
(
)
{
AssertIsOnMainThread
(
)
;
return
mDebuggerRegistered
;
}
void
SetIsDebuggerRegistered
(
bool
aDebuggerRegistered
)
{
AssertIsOnMainThread
(
)
;
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mDebuggerRegistered
!
=
aDebuggerRegistered
)
;
mDebuggerRegistered
=
aDebuggerRegistered
;
mCondVar
.
Notify
(
)
;
}
void
WaitForIsDebuggerRegistered
(
bool
aDebuggerRegistered
)
{
AssertIsOnParentThread
(
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
while
(
mDebuggerRegistered
!
=
aDebuggerRegistered
)
{
mCondVar
.
Wait
(
)
;
}
}
WorkerDebugger
*
Debugger
(
)
const
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mDebugger
)
;
return
mDebugger
;
}
void
SetDebugger
(
WorkerDebugger
*
aDebugger
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mDebugger
!
=
aDebugger
)
;
mDebugger
=
aDebugger
;
}
JS
:
:
UniqueChars
AdoptDefaultLocale
(
)
{
MOZ_ASSERT
(
mDefaultLocale
"
the
default
locale
must
have
been
successfully
set
for
anyone
"
"
to
be
trying
to
adopt
it
"
)
;
return
Move
(
mDefaultLocale
)
;
}
void
DoRunLoop
(
JSContext
*
aCx
)
;
bool
InterruptCallback
(
JSContext
*
aCx
)
;
bool
IsOnCurrentThread
(
)
;
bool
CloseInternal
(
JSContext
*
aCx
)
{
AssertIsOnWorkerThread
(
)
;
return
NotifyInternal
(
aCx
Closing
)
;
}
bool
FreezeInternal
(
)
;
bool
ThawInternal
(
)
;
void
TraverseTimeouts
(
nsCycleCollectionTraversalCallback
&
aCallback
)
;
void
UnlinkTimeouts
(
)
;
bool
ModifyBusyCountFromWorker
(
bool
aIncrease
)
;
bool
AddChildWorker
(
ParentType
*
aChildWorker
)
;
void
RemoveChildWorker
(
ParentType
*
aChildWorker
)
;
void
PostMessageToParent
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
{
PostMessageToParentInternal
(
aCx
aMessage
aTransferable
aRv
)
;
}
void
PostMessageToParentMessagePort
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
;
void
EnterDebuggerEventLoop
(
)
;
void
LeaveDebuggerEventLoop
(
)
;
void
PostMessageToDebugger
(
const
nsAString
&
aMessage
)
;
void
SetDebuggerImmediate
(
Function
&
aHandler
ErrorResult
&
aRv
)
;
void
ReportErrorToDebugger
(
const
nsAString
&
aFilename
uint32_t
aLineno
const
nsAString
&
aMessage
)
;
bool
NotifyInternal
(
JSContext
*
aCx
Status
aStatus
)
;
void
ReportError
(
JSContext
*
aCx
JS
:
:
ConstUTF8CharsZ
aToStringResult
JSErrorReport
*
aReport
)
;
static
void
ReportErrorToConsole
(
const
char
*
aMessage
)
;
int32_t
SetTimeout
(
JSContext
*
aCx
nsIScriptTimeoutHandler
*
aHandler
int32_t
aTimeout
bool
aIsInterval
ErrorResult
&
aRv
)
;
void
ClearTimeout
(
int32_t
aId
)
;
bool
RunExpiredTimeouts
(
JSContext
*
aCx
)
;
bool
RescheduleTimeoutTimer
(
JSContext
*
aCx
)
;
void
UpdateContextOptionsInternal
(
JSContext
*
aCx
const
JS
:
:
ContextOptions
&
aContextOptions
)
;
void
UpdateLanguagesInternal
(
const
nsTArray
<
nsString
>
&
aLanguages
)
;
void
UpdateJSWorkerMemoryParameterInternal
(
JSContext
*
aCx
JSGCParamKey
key
uint32_t
aValue
)
;
enum
WorkerRanOrNot
{
WorkerNeverRan
=
0
WorkerRan
}
;
void
ScheduleDeletion
(
WorkerRanOrNot
aRanOrNot
)
;
bool
CollectRuntimeStats
(
JS
:
:
RuntimeStats
*
aRtStats
bool
aAnonymize
)
;
#
ifdef
JS_GC_ZEAL
void
UpdateGCZealInternal
(
JSContext
*
aCx
uint8_t
aGCZeal
uint32_t
aFrequency
)
;
#
endif
void
GarbageCollectInternal
(
JSContext
*
aCx
bool
aShrinking
bool
aCollectChildren
)
;
void
CycleCollectInternal
(
bool
aCollectChildren
)
;
void
OfflineStatusChangeEventInternal
(
bool
aIsOffline
)
;
void
MemoryPressureInternal
(
)
;
void
SetFetchHandlerWasAdded
(
)
{
MOZ_ASSERT
(
IsServiceWorker
(
)
)
;
AssertIsOnWorkerThread
(
)
;
mFetchHandlerWasAdded
=
true
;
}
bool
FetchHandlerWasAdded
(
)
const
{
MOZ_ASSERT
(
IsServiceWorker
(
)
)
;
AssertIsOnWorkerThread
(
)
;
return
mFetchHandlerWasAdded
;
}
JSContext
*
GetJSContext
(
)
const
{
AssertIsOnWorkerThread
(
)
;
return
mJSContext
;
}
WorkerGlobalScope
*
GlobalScope
(
)
const
{
AssertIsOnWorkerThread
(
)
;
return
mScope
;
}
WorkerDebuggerGlobalScope
*
DebuggerGlobalScope
(
)
const
{
AssertIsOnWorkerThread
(
)
;
return
mDebuggerScope
;
}
void
SetThread
(
WorkerThread
*
aThread
)
;
void
AssertIsOnWorkerThread
(
)
const
#
ifdef
DEBUG
;
#
else
{
}
#
endif
WorkerCrossThreadDispatcher
*
GetCrossThreadDispatcher
(
)
;
void
BeginCTypesCall
(
)
;
void
EndCTypesCall
(
)
;
void
BeginCTypesCallback
(
)
{
EndCTypesCall
(
)
;
}
void
EndCTypesCallback
(
)
{
BeginCTypesCall
(
)
;
}
bool
ConnectMessagePort
(
JSContext
*
aCx
MessagePortIdentifier
&
aIdentifier
)
;
WorkerGlobalScope
*
GetOrCreateGlobalScope
(
JSContext
*
aCx
)
;
WorkerDebuggerGlobalScope
*
CreateDebuggerGlobalScope
(
JSContext
*
aCx
)
;
bool
RegisterBindings
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
;
bool
RegisterDebuggerBindings
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
;
bool
OnLine
(
)
const
{
AssertIsOnWorkerThread
(
)
;
return
mOnLine
;
}
void
StopSyncLoop
(
nsIEventTarget
*
aSyncLoopTarget
bool
aResult
)
;
bool
AllPendingRunnablesShouldBeCanceled
(
)
const
{
return
mCancelAllPendingRunnables
;
}
void
ClearMainEventQueue
(
WorkerRanOrNot
aRanOrNot
)
;
void
ClearDebuggerEventQueue
(
)
;
void
OnProcessNextEvent
(
)
;
void
AfterProcessNextEvent
(
)
;
void
AssertValidSyncLoop
(
nsIEventTarget
*
aSyncLoopTarget
)
#
ifdef
DEBUG
;
#
else
{
}
#
endif
void
SetWorkerScriptExecutedSuccessfully
(
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mWorkerScriptExecutedSuccessfully
)
;
mWorkerScriptExecutedSuccessfully
=
true
;
}
bool
WorkerScriptExecutedSuccessfully
(
)
const
{
AssertIsOnWorkerThread
(
)
;
return
mWorkerScriptExecutedSuccessfully
;
}
void
MaybeDispatchLoadFailedRunnable
(
)
;
nsIEventTarget
*
MainThreadEventTarget
(
)
;
nsresult
DispatchToMainThread
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
=
NS_DISPATCH_NORMAL
)
;
nsresult
DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
=
NS_DISPATCH_NORMAL
)
;
nsISerialEventTarget
*
ControlEventTarget
(
)
;
nsISerialEventTarget
*
HybridEventTarget
(
)
;
void
DumpCrashInformation
(
nsACString
&
aString
)
;
bool
EnsureClientSource
(
)
;
const
ClientInfo
&
GetClientInfo
(
)
const
;
const
ClientState
GetClientState
(
)
const
;
const
Maybe
<
ServiceWorkerDescriptor
>
GetController
(
)
const
;
void
Control
(
const
ServiceWorkerDescriptor
&
aServiceWorker
)
;
void
ExecutionReady
(
)
;
PerformanceStorage
*
GetPerformanceStorage
(
)
;
private
:
WorkerPrivate
(
WorkerPrivate
*
aParent
const
nsAString
&
aScriptURL
bool
aIsChromeWorker
WorkerType
aWorkerType
const
nsAString
&
aWorkerName
const
nsACString
&
aServiceWorkerScope
WorkerLoadInfo
&
aLoadInfo
)
;
bool
MayContinueRunning
(
)
{
AssertIsOnWorkerThread
(
)
;
Status
status
;
{
MutexAutoLock
lock
(
mMutex
)
;
status
=
mStatus
;
}
if
(
status
<
Terminating
)
{
return
true
;
}
return
false
;
}
void
CancelAllTimeouts
(
)
;
enum
class
ProcessAllControlRunnablesResult
{
Nothing
MayContinue
Abort
}
;
ProcessAllControlRunnablesResult
ProcessAllControlRunnables
(
)
{
MutexAutoLock
lock
(
mMutex
)
;
return
ProcessAllControlRunnablesLocked
(
)
;
}
ProcessAllControlRunnablesResult
ProcessAllControlRunnablesLocked
(
)
;
void
EnableMemoryReporter
(
)
;
void
DisableMemoryReporter
(
)
;
void
WaitForWorkerEvents
(
PRIntervalTime
interval
=
PR_INTERVAL_NO_TIMEOUT
)
;
void
PostMessageToParentInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsIEventTarget
>
CreateNewSyncLoop
(
Status
aFailStatus
)
;
bool
RunCurrentSyncLoop
(
)
;
bool
DestroySyncLoop
(
uint32_t
aLoopIndex
nsIThreadInternal
*
aThread
=
nullptr
)
;
void
InitializeGCTimers
(
)
;
void
SetGCTimerMode
(
GCTimerMode
aMode
)
;
void
ShutdownGCTimers
(
)
;
bool
AddHolder
(
WorkerHolder
*
aHolder
Status
aFailStatus
)
;
void
RemoveHolder
(
WorkerHolder
*
aHolder
)
;
void
NotifyHolders
(
JSContext
*
aCx
Status
aStatus
)
;
bool
HasActiveHolders
(
)
{
return
!
(
mChildWorkers
.
IsEmpty
(
)
&
&
mTimeouts
.
IsEmpty
(
)
&
&
mHolders
.
IsEmpty
(
)
)
;
}
}
;
class
ChromeWorkerPrivate
:
public
WorkerPrivate
{
public
:
static
already_AddRefed
<
ChromeWorkerPrivate
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aScriptURL
ErrorResult
&
rv
)
;
static
bool
WorkerAvailable
(
JSContext
*
aCx
JSObject
*
)
;
private
:
ChromeWorkerPrivate
(
)
=
delete
;
ChromeWorkerPrivate
(
const
ChromeWorkerPrivate
&
aRHS
)
=
delete
;
ChromeWorkerPrivate
&
operator
=
(
const
ChromeWorkerPrivate
&
aRHS
)
=
delete
;
}
;
WorkerPrivate
*
GetWorkerPrivateFromContext
(
JSContext
*
aCx
)
;
WorkerPrivate
*
GetCurrentThreadWorkerPrivate
(
)
;
bool
IsCurrentThreadRunningChromeWorker
(
)
;
JSContext
*
GetCurrentThreadJSContext
(
)
;
JSObject
*
GetCurrentThreadWorkerGlobal
(
)
;
class
AutoSyncLoopHolder
{
WorkerPrivate
*
mWorkerPrivate
;
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
uint32_t
mIndex
;
public
:
AutoSyncLoopHolder
(
WorkerPrivate
*
aWorkerPrivate
Status
aFailStatus
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mTarget
(
aWorkerPrivate
-
>
CreateNewSyncLoop
(
aFailStatus
)
)
mIndex
(
aWorkerPrivate
-
>
mSyncLoopStack
.
Length
(
)
-
1
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
~
AutoSyncLoopHolder
(
)
{
if
(
mWorkerPrivate
&
&
mTarget
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mWorkerPrivate
-
>
StopSyncLoop
(
mTarget
false
)
;
mWorkerPrivate
-
>
DestroySyncLoop
(
mIndex
)
;
}
}
bool
Run
(
)
{
WorkerPrivate
*
workerPrivate
=
mWorkerPrivate
;
mWorkerPrivate
=
nullptr
;
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
return
workerPrivate
-
>
RunCurrentSyncLoop
(
)
;
}
nsIEventTarget
*
GetEventTarget
(
)
const
{
return
mTarget
;
}
}
;
END_WORKERS_NAMESPACE
#
endif
