#
ifndef
mozilla_dom_workerinternals_JSSettings_h
#
define
mozilla_dom_workerinternals_JSSettings_h
#
include
<
stdint
.
h
>
#
include
"
jsapi
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
workerinternals
{
const
uint32_t
kJSPrincipalsDebugToken
=
0x7e2df9d2
;
struct
JSSettings
{
enum
{
JSSettings_JSGC_MAX_BYTES
=
0
JSSettings_JSGC_HIGH_FREQUENCY_TIME_LIMIT
JSSettings_JSGC_LOW_FREQUENCY_HEAP_GROWTH
JSSettings_JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN
JSSettings_JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX
JSSettings_JSGC_HIGH_FREQUENCY_LOW_LIMIT
JSSettings_JSGC_HIGH_FREQUENCY_HIGH_LIMIT
JSSettings_JSGC_ALLOCATION_THRESHOLD
JSSettings_JSGC_SLICE_TIME_BUDGET
JSSettings_JSGC_DYNAMIC_HEAP_GROWTH
JSSettings_JSGC_DYNAMIC_MARK_SLICE
kGCSettingsArraySize
}
;
struct
JSGCSetting
{
mozilla
:
:
Maybe
<
JSGCParamKey
>
key
;
uint32_t
value
;
JSGCSetting
(
)
:
key
(
)
value
(
0
)
{
}
}
;
typedef
JSGCSetting
JSGCSettingsArray
[
kGCSettingsArraySize
]
;
struct
JSContentChromeSettings
{
JS
:
:
RealmOptions
realmOptions
;
int32_t
maxScriptRuntime
;
JSContentChromeSettings
(
)
:
realmOptions
(
)
maxScriptRuntime
(
0
)
{
}
}
;
JSContentChromeSettings
chrome
;
JSContentChromeSettings
content
;
JSGCSettingsArray
gcSettings
;
JS
:
:
ContextOptions
contextOptions
;
#
ifdef
JS_GC_ZEAL
uint8_t
gcZeal
;
uint32_t
gcZealFrequency
;
#
endif
JSSettings
(
)
#
ifdef
JS_GC_ZEAL
:
gcZeal
(
0
)
gcZealFrequency
(
0
)
#
endif
{
for
(
uint32_t
index
=
0
;
index
<
ArrayLength
(
gcSettings
)
;
index
+
+
)
{
new
(
gcSettings
+
index
)
JSGCSetting
(
)
;
}
}
bool
ApplyGCSetting
(
JSGCParamKey
aKey
uint32_t
aValue
)
{
JSSettings
:
:
JSGCSetting
*
firstEmptySetting
=
nullptr
;
JSSettings
:
:
JSGCSetting
*
foundSetting
=
nullptr
;
for
(
uint32_t
index
=
0
;
index
<
ArrayLength
(
gcSettings
)
;
index
+
+
)
{
JSSettings
:
:
JSGCSetting
&
setting
=
gcSettings
[
index
]
;
if
(
setting
.
key
.
isSome
(
)
&
&
*
setting
.
key
=
=
aKey
)
{
foundSetting
=
&
setting
;
break
;
}
if
(
!
firstEmptySetting
&
&
setting
.
key
.
isNothing
(
)
)
{
firstEmptySetting
=
&
setting
;
}
}
if
(
aValue
)
{
if
(
!
foundSetting
)
{
foundSetting
=
firstEmptySetting
;
if
(
!
foundSetting
)
{
NS_ERROR
(
"
Not
enough
space
for
this
value
!
"
)
;
return
false
;
}
}
foundSetting
-
>
key
=
mozilla
:
:
Some
(
aKey
)
;
foundSetting
-
>
value
=
aValue
;
return
true
;
}
if
(
foundSetting
)
{
foundSetting
-
>
key
.
reset
(
)
;
return
true
;
}
return
false
;
}
}
;
}
}
}
#
endif
