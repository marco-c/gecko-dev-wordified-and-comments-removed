#
ifndef
mozilla_dom_workers_serviceworkerprivate_h
#
define
mozilla_dom_workers_serviceworkerprivate_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
WorkerPrivate
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
workers
{
class
ServiceWorkerInfo
;
class
LifeCycleEventCallback
:
public
nsRunnable
{
public
:
virtual
void
SetResult
(
bool
aResult
)
=
0
;
}
;
class
ServiceWorkerPrivate
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerPrivate
)
explicit
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
;
nsresult
SendMessageEvent
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
)
;
nsresult
ContinueOnSuccessfulScriptEvaluation
(
nsRunnable
*
aCallback
)
;
nsresult
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
nsIRunnable
*
aLoadFailure
)
;
nsresult
SendPushEvent
(
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
)
;
nsresult
SendPushSubscriptionChangeEvent
(
)
;
nsresult
SendNotificationClickEvent
(
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
;
nsresult
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
bool
aIsReload
)
;
void
TerminateWorker
(
)
;
private
:
enum
WakeUpReason
{
FetchEvent
=
0
PushEvent
PushSubscriptionChangeEvent
MessageEvent
NotificationClickEvent
LifeCycleEvent
}
;
nsresult
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
nsIRunnable
*
aLoadFailedRunnable
nsILoadGroup
*
aLoadGroup
=
nullptr
)
;
~
ServiceWorkerPrivate
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
}
ServiceWorkerInfo
*
MOZ_NON_OWNING_REF
mInfo
;
nsRefPtr
<
WorkerPrivate
>
mWorkerPrivate
;
}
;
}
}
}
#
endif
