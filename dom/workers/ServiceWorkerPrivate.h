#
ifndef
mozilla_dom_workers_serviceworkerprivate_h
#
define
mozilla_dom_workers_serviceworkerprivate_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
define
NOTIFICATION_CLICK_EVENT_NAME
"
notificationclick
"
#
define
NOTIFICATION_CLOSE_EVENT_NAME
"
notificationclose
"
class
nsIInterceptedChannel
;
namespace
mozilla
{
namespace
dom
{
namespace
workers
{
class
ServiceWorkerInfo
;
class
ServiceWorkerRegistrationInfo
;
class
KeepAliveToken
;
class
LifeCycleEventCallback
:
public
Runnable
{
public
:
virtual
void
SetResult
(
bool
aResult
)
=
0
;
}
;
class
ServiceWorkerPrivate
final
:
public
nsIObserver
{
friend
class
KeepAliveToken
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
ServiceWorkerPrivate
)
NS_DECL_NSIOBSERVER
explicit
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
;
nsresult
SendMessageEvent
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Optional
<
Sequence
<
JS
:
:
Value
>
>
&
aTransferable
UniquePtr
<
ServiceWorkerClientInfo
>
&
&
aClientInfo
)
;
nsresult
CheckScriptEvaluation
(
LifeCycleEventCallback
*
aCallback
)
;
nsresult
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
nsIRunnable
*
aLoadFailure
)
;
nsresult
SendPushEvent
(
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
nsresult
SendPushSubscriptionChangeEvent
(
)
;
nsresult
SendNotificationEvent
(
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
;
nsresult
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
const
nsAString
&
aDocumentId
bool
aIsReload
)
;
void
StoreISupports
(
nsISupports
*
aSupports
)
;
void
RemoveISupports
(
nsISupports
*
aSupports
)
;
void
TerminateWorker
(
)
;
void
NoteDeadServiceWorkerInfo
(
)
;
void
NoteStoppedControllingDocuments
(
)
;
void
Activated
(
)
;
nsresult
GetDebugger
(
nsIWorkerDebugger
*
*
aResult
)
;
nsresult
AttachDebugger
(
)
;
nsresult
DetachDebugger
(
)
;
bool
IsIdle
(
)
const
;
void
AddPendingWindow
(
Runnable
*
aPendingWindow
)
;
private
:
enum
WakeUpReason
{
FetchEvent
=
0
PushEvent
PushSubscriptionChangeEvent
MessageEvent
NotificationClickEvent
NotificationCloseEvent
LifeCycleEvent
AttachEvent
}
;
static
void
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
void
*
aPrivate
)
;
static
void
TerminateWorkerCallback
(
nsITimer
*
aTimer
void
*
aPrivate
)
;
void
RenewKeepAliveToken
(
WakeUpReason
aWhy
)
;
void
ResetIdleTimeout
(
)
;
void
AddToken
(
)
;
void
ReleaseToken
(
)
;
nsresult
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
nsIRunnable
*
aLoadFailedRunnable
nsILoadGroup
*
aLoadGroup
=
nullptr
)
;
~
ServiceWorkerPrivate
(
)
;
already_AddRefed
<
KeepAliveToken
>
CreateEventKeepAliveToken
(
)
;
ServiceWorkerInfo
*
MOZ_NON_OWNING_REF
mInfo
;
RefPtr
<
WorkerPrivate
>
mWorkerPrivate
;
nsCOMPtr
<
nsITimer
>
mIdleWorkerTimer
;
RefPtr
<
KeepAliveToken
>
mIdleKeepAliveToken
;
uint64_t
mDebuggerCount
;
uint64_t
mTokenCount
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
mSupportsArray
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
mPendingFunctionalEvents
;
nsTArray
<
Runnable
*
>
pendingWindows
;
}
;
}
}
}
#
endif
