#
include
"
WorkerRunnable
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
WorkerScope
.
h
"
USING_WORKERS_NAMESPACE
namespace
{
const
nsIID
kWorkerRunnableIID
=
{
0x320cc0b5
0xef12
0x4084
{
0x88
0x6e
0xca
0x6a
0x81
0xe4
0x1d
0x68
}
}
;
}
#
ifdef
DEBUG
WorkerRunnable
:
:
WorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mBehavior
(
aBehavior
)
mCanceled
(
0
)
mCallingCancelWithinRun
(
false
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
}
#
endif
bool
WorkerRunnable
:
:
IsDebuggerRunnable
(
)
const
{
return
false
;
}
nsIGlobalObject
*
WorkerRunnable
:
:
DefaultGlobalObject
(
)
const
{
if
(
IsDebuggerRunnable
(
)
)
{
return
mWorkerPrivate
-
>
DebuggerGlobalScope
(
)
;
}
else
{
return
mWorkerPrivate
-
>
GlobalScope
(
)
;
}
}
bool
WorkerRunnable
:
:
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aWorkerPrivate
)
;
switch
(
mBehavior
)
{
case
ParentThreadUnchangedBusyCount
:
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
break
;
case
WorkerThreadModifyBusyCount
:
case
WorkerThreadUnchangedBusyCount
:
aWorkerPrivate
-
>
AssertIsOnParentThread
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
behavior
!
"
)
;
}
#
endif
if
(
mBehavior
=
=
WorkerThreadModifyBusyCount
)
{
return
aWorkerPrivate
-
>
ModifyBusyCount
(
true
)
;
}
return
true
;
}
bool
WorkerRunnable
:
:
Dispatch
(
)
{
bool
ok
=
PreDispatch
(
mWorkerPrivate
)
;
if
(
ok
)
{
ok
=
DispatchInternal
(
)
;
}
PostDispatch
(
mWorkerPrivate
ok
)
;
return
ok
;
}
bool
WorkerRunnable
:
:
DispatchInternal
(
)
{
RefPtr
<
WorkerRunnable
>
runnable
(
this
)
;
if
(
mBehavior
=
=
WorkerThreadModifyBusyCount
|
|
mBehavior
=
=
WorkerThreadUnchangedBusyCount
)
{
if
(
IsDebuggerRunnable
(
)
)
{
return
NS_SUCCEEDED
(
mWorkerPrivate
-
>
DispatchDebuggerRunnable
(
runnable
.
forget
(
)
)
)
;
}
else
{
return
NS_SUCCEEDED
(
mWorkerPrivate
-
>
Dispatch
(
runnable
.
forget
(
)
)
)
;
}
}
MOZ_ASSERT
(
mBehavior
=
=
ParentThreadUnchangedBusyCount
)
;
if
(
WorkerPrivate
*
parent
=
mWorkerPrivate
-
>
GetParent
(
)
)
{
return
NS_SUCCEEDED
(
parent
-
>
Dispatch
(
runnable
.
forget
(
)
)
)
;
}
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
MOZ_ASSERT
(
mainThread
)
;
return
NS_SUCCEEDED
(
mainThread
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
void
WorkerRunnable
:
:
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
#
ifdef
DEBUG
switch
(
mBehavior
)
{
case
ParentThreadUnchangedBusyCount
:
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
break
;
case
WorkerThreadModifyBusyCount
:
aWorkerPrivate
-
>
AssertIsOnParentThread
(
)
;
break
;
case
WorkerThreadUnchangedBusyCount
:
aWorkerPrivate
-
>
AssertIsOnParentThread
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
behavior
!
"
)
;
}
#
endif
if
(
!
aDispatchResult
)
{
if
(
mBehavior
=
=
WorkerThreadModifyBusyCount
)
{
aWorkerPrivate
-
>
ModifyBusyCount
(
false
)
;
}
}
}
void
WorkerRunnable
:
:
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
#
ifdef
DEBUG
switch
(
mBehavior
)
{
case
ParentThreadUnchangedBusyCount
:
aWorkerPrivate
-
>
AssertIsOnParentThread
(
)
;
break
;
case
WorkerThreadModifyBusyCount
:
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
break
;
case
WorkerThreadUnchangedBusyCount
:
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
behavior
!
"
)
;
}
#
endif
if
(
mBehavior
=
=
WorkerThreadModifyBusyCount
)
{
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
false
)
;
}
if
(
!
aRunResult
)
{
JS_ReportPendingException
(
aCx
)
;
}
}
WorkerRunnable
*
WorkerRunnable
:
:
FromRunnable
(
nsIRunnable
*
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
WorkerRunnable
*
runnable
;
nsresult
rv
=
aRunnable
-
>
QueryInterface
(
kWorkerRunnableIID
reinterpret_cast
<
void
*
*
>
(
&
runnable
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
runnable
)
;
return
runnable
;
}
NS_IMPL_ADDREF
(
WorkerRunnable
)
NS_IMPL_RELEASE
(
WorkerRunnable
)
NS_INTERFACE_MAP_BEGIN
(
WorkerRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsIRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsICancelableRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
if
(
aIID
.
Equals
(
kWorkerRunnableIID
)
)
{
*
aInstancePtr
=
this
;
return
NS_OK
;
}
else
NS_INTERFACE_MAP_END
NS_IMETHODIMP
WorkerRunnable
:
:
Run
(
)
{
bool
targetIsWorkerThread
=
mBehavior
=
=
WorkerThreadModifyBusyCount
|
|
mBehavior
=
=
WorkerThreadUnchangedBusyCount
;
#
ifdef
DEBUG
MOZ_ASSERT_IF
(
mCallingCancelWithinRun
targetIsWorkerThread
)
;
if
(
targetIsWorkerThread
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
else
{
MOZ_ASSERT
(
mBehavior
=
=
ParentThreadUnchangedBusyCount
)
;
mWorkerPrivate
-
>
AssertIsOnParentThread
(
)
;
}
#
endif
if
(
IsCanceled
(
)
&
&
!
mCallingCancelWithinRun
)
{
return
NS_OK
;
}
if
(
targetIsWorkerThread
&
&
mWorkerPrivate
-
>
AllPendingRunnablesShouldBeCanceled
(
)
&
&
!
IsCanceled
(
)
&
&
!
mCallingCancelWithinRun
)
{
mCallingCancelWithinRun
=
true
;
Cancel
(
)
;
MOZ_ASSERT
(
mCallingCancelWithinRun
)
;
mCallingCancelWithinRun
=
false
;
MOZ_ASSERT
(
IsCanceled
(
)
"
Subclass
Cancel
(
)
didn
'
t
set
IsCanceled
(
)
!
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIGlobalObject
>
globalObject
;
bool
isMainThread
=
!
targetIsWorkerThread
&
&
!
mWorkerPrivate
-
>
GetParent
(
)
;
MOZ_ASSERT
(
isMainThread
=
=
NS_IsMainThread
(
)
)
;
RefPtr
<
WorkerPrivate
>
kungFuDeathGrip
;
if
(
targetIsWorkerThread
)
{
JSContext
*
cx
=
GetCurrentThreadJSContext
(
)
;
if
(
NS_WARN_IF
(
!
cx
)
)
{
return
NS_ERROR_FAILURE
;
}
JSObject
*
global
=
JS
:
:
CurrentGlobalOrNull
(
cx
)
;
if
(
global
)
{
globalObject
=
GetGlobalObjectForGlobal
(
global
)
;
}
else
{
globalObject
=
DefaultGlobalObject
(
)
;
}
}
else
{
kungFuDeathGrip
=
mWorkerPrivate
;
if
(
isMainThread
)
{
globalObject
=
nsGlobalWindow
:
:
Cast
(
mWorkerPrivate
-
>
GetWindow
(
)
)
;
}
else
{
globalObject
=
mWorkerPrivate
-
>
GetParent
(
)
-
>
GlobalScope
(
)
;
}
}
mozilla
:
:
dom
:
:
AutoJSAPI
jsapi
;
Maybe
<
mozilla
:
:
dom
:
:
AutoEntryScript
>
aes
;
JSContext
*
cx
;
if
(
globalObject
)
{
aes
.
emplace
(
globalObject
"
Worker
runnable
"
isMainThread
isMainThread
?
nullptr
:
GetCurrentThreadJSContext
(
)
)
;
cx
=
aes
-
>
cx
(
)
;
}
else
{
jsapi
.
Init
(
)
;
cx
=
jsapi
.
cx
(
)
;
}
MOZ_ASSERT_IF
(
!
targetIsWorkerThread
&
&
!
isMainThread
mWorkerPrivate
-
>
IsDedicatedWorker
(
)
&
&
globalObject
)
;
Maybe
<
JSAutoCompartment
>
ac
;
if
(
!
targetIsWorkerThread
&
&
mWorkerPrivate
-
>
GetWrapper
(
)
)
{
MOZ_ASSERT_IF
(
globalObject
js
:
:
GetObjectCompartment
(
mWorkerPrivate
-
>
GetWrapper
(
)
)
=
=
js
:
:
GetContextCompartment
(
cx
)
)
;
MOZ_ASSERT_IF
(
globalObject
js
:
:
GetObjectCompartment
(
mWorkerPrivate
-
>
GetWrapper
(
)
)
=
=
js
:
:
GetObjectCompartment
(
globalObject
-
>
GetGlobalJSObject
(
)
)
)
;
MOZ_ASSERT
(
!
js
:
:
GetContextCompartment
(
cx
)
|
|
js
:
:
GetObjectCompartment
(
mWorkerPrivate
-
>
GetWrapper
(
)
)
=
=
js
:
:
GetContextCompartment
(
cx
)
"
Must
either
be
in
the
null
compartment
or
in
our
reflector
"
"
compartment
"
)
;
ac
.
emplace
(
cx
mWorkerPrivate
-
>
GetWrapper
(
)
)
;
}
bool
result
=
WorkerRun
(
cx
mWorkerPrivate
)
;
if
(
targetIsWorkerThread
&
&
!
aes
&
&
DefaultGlobalObject
(
)
)
{
aes
.
emplace
(
DefaultGlobalObject
(
)
"
worker
runnable
"
false
GetCurrentThreadJSContext
(
)
)
;
cx
=
aes
-
>
cx
(
)
;
}
PostRun
(
cx
mWorkerPrivate
result
)
;
return
result
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
WorkerRunnable
:
:
Cancel
(
)
{
uint32_t
canceledCount
=
+
+
mCanceled
;
MOZ_ASSERT
(
canceledCount
"
Cancel
(
)
overflow
!
"
)
;
return
(
canceledCount
=
=
1
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
void
WorkerDebuggerRunnable
:
:
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
{
}
WorkerSyncRunnable
:
:
WorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
nsIEventTarget
*
aSyncLoopTarget
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mSyncLoopTarget
(
aSyncLoopTarget
)
{
#
ifdef
DEBUG
if
(
mSyncLoopTarget
)
{
mWorkerPrivate
-
>
AssertValidSyncLoop
(
mSyncLoopTarget
)
;
}
#
endif
}
WorkerSyncRunnable
:
:
WorkerSyncRunnable
(
WorkerPrivate
*
aWorkerPrivate
already_AddRefed
<
nsIEventTarget
>
&
&
aSyncLoopTarget
)
:
WorkerRunnable
(
aWorkerPrivate
WorkerThreadUnchangedBusyCount
)
mSyncLoopTarget
(
aSyncLoopTarget
)
{
#
ifdef
DEBUG
if
(
mSyncLoopTarget
)
{
mWorkerPrivate
-
>
AssertValidSyncLoop
(
mSyncLoopTarget
)
;
}
#
endif
}
WorkerSyncRunnable
:
:
~
WorkerSyncRunnable
(
)
{
}
bool
WorkerSyncRunnable
:
:
DispatchInternal
(
)
{
if
(
mSyncLoopTarget
)
{
RefPtr
<
WorkerSyncRunnable
>
runnable
(
this
)
;
return
NS_SUCCEEDED
(
mSyncLoopTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
return
WorkerRunnable
:
:
DispatchInternal
(
)
;
}
void
MainThreadWorkerSyncRunnable
:
:
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
{
}
StopSyncLoopRunnable
:
:
StopSyncLoopRunnable
(
WorkerPrivate
*
aWorkerPrivate
already_AddRefed
<
nsIEventTarget
>
&
&
aSyncLoopTarget
bool
aResult
)
:
WorkerSyncRunnable
(
aWorkerPrivate
Move
(
aSyncLoopTarget
)
)
mResult
(
aResult
)
{
#
ifdef
DEBUG
mWorkerPrivate
-
>
AssertValidSyncLoop
(
mSyncLoopTarget
)
;
#
endif
}
NS_IMETHODIMP
StopSyncLoopRunnable
:
:
Cancel
(
)
{
nsresult
rv
=
Run
(
)
;
NS_WARN_IF_FALSE
(
NS_SUCCEEDED
(
rv
)
"
Run
(
)
failed
"
)
;
nsresult
rv2
=
WorkerSyncRunnable
:
:
Cancel
(
)
;
NS_WARN_IF_FALSE
(
NS_SUCCEEDED
(
rv2
)
"
Cancel
(
)
failed
"
)
;
return
NS_FAILED
(
rv
)
?
rv
:
rv2
;
}
bool
StopSyncLoopRunnable
:
:
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mSyncLoopTarget
)
;
nsCOMPtr
<
nsIEventTarget
>
syncLoopTarget
;
mSyncLoopTarget
.
swap
(
syncLoopTarget
)
;
if
(
!
mResult
)
{
MaybeSetException
(
aCx
)
;
}
aWorkerPrivate
-
>
StopSyncLoop
(
syncLoopTarget
mResult
)
;
return
true
;
}
bool
StopSyncLoopRunnable
:
:
DispatchInternal
(
)
{
MOZ_ASSERT
(
mSyncLoopTarget
)
;
RefPtr
<
StopSyncLoopRunnable
>
runnable
(
this
)
;
return
NS_SUCCEEDED
(
mSyncLoopTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
void
MainThreadStopSyncLoopRunnable
:
:
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
{
}
#
ifdef
DEBUG
WorkerControlRunnable
:
:
WorkerControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
TargetAndBusyBehavior
aBehavior
)
:
WorkerRunnable
(
aWorkerPrivate
aBehavior
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aBehavior
=
=
ParentThreadUnchangedBusyCount
|
|
aBehavior
=
=
WorkerThreadUnchangedBusyCount
"
WorkerControlRunnables
should
not
modify
the
busy
count
"
)
;
}
#
endif
NS_IMETHODIMP
WorkerControlRunnable
:
:
Cancel
(
)
{
if
(
NS_FAILED
(
Run
(
)
)
)
{
NS_WARNING
(
"
WorkerControlRunnable
:
:
Run
(
)
failed
.
"
)
;
}
return
WorkerRunnable
:
:
Cancel
(
)
;
}
bool
WorkerControlRunnable
:
:
DispatchInternal
(
)
{
RefPtr
<
WorkerControlRunnable
>
runnable
(
this
)
;
if
(
mBehavior
=
=
WorkerThreadUnchangedBusyCount
)
{
return
NS_SUCCEEDED
(
mWorkerPrivate
-
>
DispatchControlRunnable
(
runnable
.
forget
(
)
)
)
;
}
if
(
WorkerPrivate
*
parent
=
mWorkerPrivate
-
>
GetParent
(
)
)
{
return
NS_SUCCEEDED
(
parent
-
>
DispatchControlRunnable
(
runnable
.
forget
(
)
)
)
;
}
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
MOZ_ASSERT
(
mainThread
)
;
return
NS_SUCCEEDED
(
mainThread
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
void
MainThreadWorkerControlRunnable
:
:
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
{
AssertIsOnMainThread
(
)
;
}
NS_IMPL_ISUPPORTS_INHERITED0
(
WorkerControlRunnable
WorkerRunnable
)
WorkerMainThreadRunnable
:
:
WorkerMainThreadRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
:
mWorkerPrivate
(
aWorkerPrivate
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
void
WorkerMainThreadRunnable
:
:
Dispatch
(
ErrorResult
&
aRv
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
AutoSyncLoopHolder
syncLoop
(
mWorkerPrivate
)
;
mSyncLoopTarget
=
syncLoop
.
EventTarget
(
)
;
RefPtr
<
WorkerMainThreadRunnable
>
runnable
(
this
)
;
DebugOnly
<
nsresult
>
rv
=
NS_DispatchToMainThread
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Should
only
fail
after
xpcom
-
shutdown
-
threads
and
we
'
re
gone
by
then
"
)
;
if
(
!
syncLoop
.
Run
(
)
)
{
aRv
.
ThrowUncatchableException
(
)
;
}
}
NS_IMETHODIMP
WorkerMainThreadRunnable
:
:
Run
(
)
{
AssertIsOnMainThread
(
)
;
bool
runResult
=
MainThreadRun
(
)
;
RefPtr
<
MainThreadStopSyncLoopRunnable
>
response
=
new
MainThreadStopSyncLoopRunnable
(
mWorkerPrivate
mSyncLoopTarget
.
forget
(
)
runResult
)
;
MOZ_ALWAYS_TRUE
(
response
-
>
Dispatch
(
)
)
;
return
NS_OK
;
}
bool
WorkerCheckAPIExposureOnMainThreadRunnable
:
:
Dispatch
(
)
{
ErrorResult
rv
;
WorkerMainThreadRunnable
:
:
Dispatch
(
rv
)
;
bool
ok
=
!
rv
.
Failed
(
)
;
rv
.
SuppressException
(
)
;
return
ok
;
}
bool
WorkerSameThreadRunnable
:
:
PreDispatch
(
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
return
true
;
}
void
WorkerSameThreadRunnable
:
:
PostDispatch
(
WorkerPrivate
*
aWorkerPrivate
bool
aDispatchResult
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
aDispatchResult
)
{
DebugOnly
<
bool
>
willIncrement
=
aWorkerPrivate
-
>
ModifyBusyCountFromWorker
(
true
)
;
MOZ_ASSERT
(
willIncrement
)
;
}
}
