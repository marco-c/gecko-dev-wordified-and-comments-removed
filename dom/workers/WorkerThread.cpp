#
include
"
WorkerThread
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
EventQueue
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
PerformanceCounter
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
ifdef
DEBUG
#
include
"
nsThreadManager
.
h
"
#
endif
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
{
const
uint32_t
kWorkerStackSize
=
256
*
sizeof
(
size_t
)
*
1024
-
8192
;
}
WorkerThreadFriendKey
:
:
WorkerThreadFriendKey
(
)
{
MOZ_COUNT_CTOR
(
WorkerThreadFriendKey
)
;
}
WorkerThreadFriendKey
:
:
~
WorkerThreadFriendKey
(
)
{
MOZ_COUNT_DTOR
(
WorkerThreadFriendKey
)
;
}
class
WorkerThread
:
:
Observer
final
:
public
nsIThreadObserver
{
WorkerPrivate
*
mWorkerPrivate
;
public
:
explicit
Observer
(
WorkerPrivate
*
aWorkerPrivate
)
:
mWorkerPrivate
(
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
NS_DECL_THREADSAFE_ISUPPORTS
private
:
~
Observer
(
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
NS_DECL_NSITHREADOBSERVER
}
;
WorkerThread
:
:
WorkerThread
(
)
:
nsThread
(
MakeNotNull
<
ThreadEventQueue
<
mozilla
:
:
EventQueue
>
*
>
(
MakeUnique
<
mozilla
:
:
EventQueue
>
(
)
)
nsThread
:
:
NOT_MAIN_THREAD
kWorkerStackSize
)
mLock
(
"
WorkerThread
:
:
mLock
"
)
mWorkerPrivateCondVar
(
mLock
"
WorkerThread
:
:
mWorkerPrivateCondVar
"
)
mWorkerPrivate
(
nullptr
)
mOtherThreadsDispatchingViaEventTarget
(
0
)
#
ifdef
DEBUG
mAcceptingNonWorkerRunnables
(
true
)
#
endif
{
}
WorkerThread
:
:
~
WorkerThread
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mOtherThreadsDispatchingViaEventTarget
)
;
MOZ_ASSERT
(
mAcceptingNonWorkerRunnables
)
;
}
already_AddRefed
<
WorkerThread
>
WorkerThread
:
:
Create
(
const
WorkerThreadFriendKey
&
)
{
RefPtr
<
WorkerThread
>
thread
=
new
WorkerThread
(
)
;
if
(
NS_FAILED
(
thread
-
>
Init
(
NS_LITERAL_CSTRING
(
"
DOM
Worker
"
)
)
)
)
{
NS_WARNING
(
"
Failed
to
create
new
thread
!
"
)
;
return
nullptr
;
}
return
thread
.
forget
(
)
;
}
void
WorkerThread
:
:
SetWorker
(
const
WorkerThreadFriendKey
&
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
mThread
)
;
if
(
aWorkerPrivate
)
{
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
MOZ_ASSERT
(
mAcceptingNonWorkerRunnables
)
;
mWorkerPrivate
=
aWorkerPrivate
;
#
ifdef
DEBUG
mAcceptingNonWorkerRunnables
=
false
;
#
endif
}
mObserver
=
new
Observer
(
aWorkerPrivate
)
;
MOZ_ALWAYS_SUCCEEDS
(
AddObserver
(
mObserver
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
RemoveObserver
(
mObserver
)
)
;
mObserver
=
nullptr
;
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mAcceptingNonWorkerRunnables
)
;
MOZ_ASSERT
(
!
mOtherThreadsDispatchingViaEventTarget
"
XPCOM
Dispatch
hapenning
at
the
same
time
our
thread
is
"
"
being
unset
!
This
should
not
be
possible
!
"
)
;
while
(
mOtherThreadsDispatchingViaEventTarget
)
{
mWorkerPrivateCondVar
.
Wait
(
)
;
}
#
ifdef
DEBUG
mAcceptingNonWorkerRunnables
=
true
;
#
endif
mWorkerPrivate
=
nullptr
;
}
}
}
void
WorkerThread
:
:
IncrementDispatchCounter
(
)
{
if
(
!
mozilla
:
:
StaticPrefs
:
:
dom_performance_enable_scheduler_timing
(
)
)
{
return
;
}
MutexAutoLock
lock
(
mLock
)
;
if
(
mWorkerPrivate
)
{
PerformanceCounter
*
performanceCounter
=
mWorkerPrivate
-
>
GetPerformanceCounter
(
)
;
if
(
performanceCounter
)
{
performanceCounter
-
>
IncrementDispatchCounter
(
DispatchCategory
:
:
Worker
)
;
}
}
}
nsresult
WorkerThread
:
:
DispatchPrimaryRunnable
(
const
WorkerThreadFriendKey
&
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
!
=
mThread
)
;
MOZ_ASSERT
(
runnable
)
;
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
MOZ_ASSERT
(
mAcceptingNonWorkerRunnables
)
;
}
#
endif
nsresult
rv
=
nsThread
:
:
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
WorkerThread
:
:
DispatchAnyThread
(
const
WorkerThreadFriendKey
&
already_AddRefed
<
WorkerRunnable
>
aWorkerRunnable
)
{
#
ifdef
DEBUG
{
const
bool
onWorkerThread
=
PR_GetCurrentThread
(
)
=
=
mThread
;
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mAcceptingNonWorkerRunnables
)
;
if
(
onWorkerThread
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
}
}
#
endif
IncrementDispatchCounter
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
aWorkerRunnable
)
;
nsresult
rv
=
nsThread
:
:
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WorkerThread
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
Dispatch
(
runnable
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
WorkerThread
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
if
(
NS_WARN_IF
(
aFlags
!
=
NS_DISPATCH_NORMAL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
const
bool
onWorkerThread
=
PR_GetCurrentThread
(
)
=
=
mThread
;
#
ifdef
DEBUG
if
(
runnable
&
&
!
onWorkerThread
)
{
nsCOMPtr
<
nsICancelableRunnable
>
cancelable
=
do_QueryInterface
(
runnable
)
;
{
MutexAutoLock
lock
(
mLock
)
;
if
(
!
mAcceptingNonWorkerRunnables
)
{
MOZ_ASSERT
(
cancelable
"
Only
nsICancelableRunnable
may
be
dispatched
to
a
worker
!
"
)
;
}
}
}
#
endif
WorkerPrivate
*
workerPrivate
=
nullptr
;
if
(
onWorkerThread
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
workerPrivate
=
mWorkerPrivate
;
}
else
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
mOtherThreadsDispatchingViaEventTarget
<
UINT32_MAX
)
;
if
(
mWorkerPrivate
)
{
workerPrivate
=
mWorkerPrivate
;
mOtherThreadsDispatchingViaEventTarget
+
+
;
}
}
IncrementDispatchCounter
(
)
;
nsresult
rv
;
if
(
runnable
&
&
onWorkerThread
)
{
RefPtr
<
WorkerRunnable
>
workerRunnable
=
workerPrivate
-
>
MaybeWrapAsWorkerRunnable
(
runnable
.
forget
(
)
)
;
rv
=
nsThread
:
:
Dispatch
(
workerRunnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
else
{
rv
=
nsThread
:
:
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
if
(
!
onWorkerThread
&
&
workerPrivate
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
MutexAutoLock
workerLock
(
workerPrivate
-
>
mMutex
)
;
workerPrivate
-
>
mCondVar
.
Notify
(
)
;
}
{
MutexAutoLock
lock
(
mLock
)
;
MOZ_ASSERT
(
mOtherThreadsDispatchingViaEventTarget
)
;
if
(
!
-
-
mOtherThreadsDispatchingViaEventTarget
)
{
mWorkerPrivateCondVar
.
Notify
(
)
;
}
}
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WorkerThread
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
uint32_t
WorkerThread
:
:
RecursionDepth
(
const
WorkerThreadFriendKey
&
)
const
{
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
mThread
)
;
return
mNestedEventLoopDepth
;
}
PerformanceCounter
*
WorkerThread
:
:
GetPerformanceCounter
(
nsIRunnable
*
aEvent
)
{
if
(
mWorkerPrivate
)
{
return
mWorkerPrivate
-
>
GetPerformanceCounter
(
)
;
}
return
nullptr
;
}
NS_IMPL_ISUPPORTS
(
WorkerThread
:
:
Observer
nsIThreadObserver
)
NS_IMETHODIMP
WorkerThread
:
:
Observer
:
:
OnDispatchedEvent
(
)
{
MOZ_CRASH
(
"
OnDispatchedEvent
(
)
should
never
be
called
!
"
)
;
}
NS_IMETHODIMP
WorkerThread
:
:
Observer
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
bool
aMayWait
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
aMayWait
)
{
MOZ_ASSERT
(
CycleCollectedJSContext
:
:
Get
(
)
-
>
RecursionDepth
(
)
=
=
2
)
;
MOZ_ASSERT
(
!
BackgroundChild
:
:
GetForCurrentThread
(
)
)
;
return
NS_OK
;
}
mWorkerPrivate
-
>
OnProcessNextEvent
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
WorkerThread
:
:
Observer
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
bool
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mWorkerPrivate
-
>
AfterProcessNextEvent
(
)
;
return
NS_OK
;
}
}
}
