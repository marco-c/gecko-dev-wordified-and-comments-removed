const
DIRPATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
"
)
;
const
TEST_BLOB_CONTENTS
=
I
'
m
a
disk
-
backed
test
blob
!
Hooray
!
;
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
tabs
.
remote
.
separatePrivilegedMozillaWebContentProcess
"
true
]
[
"
browser
.
tabs
.
remote
.
separatedMozillaDomains
"
"
example
.
org
"
]
[
"
dom
.
ipc
.
processCount
.
privilegedmozilla
"
1
]
[
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
idle_timeout
"
299999
]
[
"
dom
.
serviceWorkers
.
idle_extended_timeout
"
299999
]
]
}
)
;
}
)
;
function
countRemoteType
(
remoteType
)
{
return
ChromeUtils
.
getAllDOMProcesses
(
)
.
filter
(
p
=
>
p
.
remoteType
=
=
remoteType
)
.
length
;
}
function
debugRemotes
(
)
{
return
ChromeUtils
.
getAllDOMProcesses
(
)
.
map
(
p
=
>
p
.
remoteType
|
|
"
parent
"
)
.
join
(
"
"
)
;
}
async
function
waitForNoProcessesOfType
(
remoteType
)
{
info
(
waiting
for
there
to
be
no
{
remoteType
}
procs
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
countRemoteType
(
remoteType
)
=
=
0
"
wait
for
the
worker
'
s
process
to
shutdown
"
)
;
}
async
function
waitForWorkerAndProcessShutdown
(
swRegInfo
remoteType
)
{
info
(
terminating
worker
and
waiting
for
{
remoteType
}
procs
to
shut
down
)
;
ok
(
swRegInfo
.
activeWorker
"
worker
should
be
in
the
active
slot
"
)
;
is
(
countRemoteType
(
remoteType
)
1
should
have
a
single
{
remoteType
}
process
but
have
:
{
debugRemotes
(
)
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
serviceWorkers
.
idle_timeout
"
0
]
[
"
dom
.
serviceWorkers
.
idle_extended_timeout
"
0
]
]
}
)
;
swRegInfo
.
activeWorker
.
attachDebugger
(
)
;
await
new
Promise
(
resolve
=
>
Cu
.
dispatch
(
resolve
)
)
;
swRegInfo
.
activeWorker
.
detachDebugger
(
)
;
await
waitForNoProcessesOfType
(
remoteType
)
;
is
(
countRemoteType
(
remoteType
)
0
processes
with
remoteType
=
{
remoteType
}
type
should
have
shut
down
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
async
function
do_test_sw
(
host
remoteType
swMode
fileBlob
)
{
info
(
#
#
#
entering
test
:
host
=
{
host
}
remoteType
=
{
remoteType
}
mode
=
{
swMode
}
)
;
const
prin
=
Services
.
scriptSecurityManager
.
createContentPrincipal
(
Services
.
io
.
newURI
(
https
:
/
/
{
host
}
)
{
}
)
;
const
sw
=
https
:
/
/
{
host
}
/
{
DIRPATH
}
file_service_worker_fetch_synthetic
.
js
;
const
scope
=
https
:
/
/
{
host
}
/
{
DIRPATH
}
server_fetch_synthetic
.
sjs
;
const
swm
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
const
swRegInfo
=
await
swm
.
registerForTest
(
prin
scope
sw
)
;
swRegInfo
.
QueryInterface
(
Ci
.
nsIServiceWorkerRegistrationInfo
)
;
info
(
service
worker
registered
:
{
JSON
.
stringify
(
{
principal
:
swRegInfo
.
principal
.
spec
scope
:
swRegInfo
.
scope
}
)
}
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
swRegInfo
.
activeWorker
"
wait
for
the
worker
to
become
active
"
)
;
await
waitForWorkerAndProcessShutdown
(
swRegInfo
remoteType
)
;
info
(
test
navigation
interception
with
mode
=
{
swMode
}
starting
from
about
:
blank
)
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
async
browser
=
>
{
SpecialPowers
.
spawn
(
browser
[
scope
swMode
fileBlob
]
async
(
scope
swMode
fileBlob
)
=
>
{
const
pageUrl
=
{
scope
}
?
mode
=
{
swMode
}
;
if
(
!
fileBlob
)
{
content
.
location
.
href
=
pageUrl
;
}
else
{
const
doc
=
content
.
document
;
const
formElem
=
doc
.
createElement
(
"
form
"
)
;
doc
.
body
.
appendChild
(
formElem
)
;
formElem
.
action
=
pageUrl
;
formElem
.
method
=
"
POST
"
;
formElem
.
enctype
=
"
multipart
/
form
-
data
"
;
const
fileElem
=
doc
.
createElement
(
"
input
"
)
;
formElem
.
appendChild
(
fileElem
)
;
fileElem
.
type
=
"
file
"
;
fileElem
.
name
=
"
foo
"
;
fileElem
.
mozSetFileArray
(
[
fileBlob
]
)
;
formElem
.
submit
(
)
;
}
}
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
is
(
countRemoteType
(
remoteType
)
1
should
have
spawned
a
content
process
with
remoteType
=
{
remoteType
}
)
;
const
{
source
blobContents
}
=
await
SpecialPowers
.
spawn
(
browser
[
]
(
)
=
>
{
return
{
source
:
content
.
document
.
getElementById
(
"
source
"
)
.
textContent
blobContents
:
content
.
document
.
getElementById
(
"
blob
"
)
.
textContent
}
;
}
)
;
is
(
source
swMode
=
=
=
"
synthetic
"
?
"
ServiceWorker
"
:
"
ServerJS
"
"
The
page
contents
should
come
from
the
right
place
.
"
)
;
is
(
blobContents
fileBlob
?
TEST_BLOB_CONTENTS
:
"
"
"
The
request
blob
contents
should
be
the
blob
/
empty
as
appropriate
.
"
)
;
const
workerDebuggerURLs
=
await
SpecialPowers
.
spawn
(
browser
[
sw
]
async
url
=
>
{
if
(
!
content
.
navigator
.
serviceWorker
.
controller
)
{
throw
new
Error
(
"
document
not
controlled
!
"
)
;
}
const
wdm
=
Cc
[
"
mozilla
.
org
/
dom
/
workers
/
workerdebuggermanager
;
1
"
]
.
getService
(
Ci
.
nsIWorkerDebuggerManager
)
;
return
Array
.
from
(
wdm
.
getWorkerDebuggerEnumerator
(
)
)
.
map
(
wd
=
>
{
return
wd
.
url
;
}
)
.
filter
(
swURL
=
>
swURL
=
=
url
)
;
}
)
;
if
(
remoteType
.
startsWith
(
"
webServiceWorker
=
"
)
)
{
Assert
.
notDeepEqual
(
workerDebuggerURLs
[
sw
]
"
Isolated
workers
should
not
be
running
in
the
content
child
process
"
)
;
}
else
{
Assert
.
deepEqual
(
workerDebuggerURLs
[
sw
]
"
The
worker
should
be
running
in
the
correct
child
process
"
)
;
}
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
registration
=
await
content
.
navigator
.
serviceWorker
.
ready
;
await
registration
.
unregister
(
)
;
}
)
;
}
)
;
await
waitForNoProcessesOfType
(
remoteType
)
;
}
async
function
makeFileBlob
(
blobContents
)
{
const
tmpFile
=
Cc
[
"
mozilla
.
org
/
file
/
directory_service
;
1
"
]
.
getService
(
Ci
.
nsIDirectoryService
)
.
QueryInterface
(
Ci
.
nsIProperties
)
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
tmpFile
.
append
(
"
test
-
file
-
backed
-
blob
.
txt
"
)
;
tmpFile
.
createUnique
(
Ci
.
nsIFile
.
NORMAL_FILE_TYPE
0o600
)
;
var
outStream
=
Cc
[
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
]
.
createInstance
(
Ci
.
nsIFileOutputStream
)
;
outStream
.
init
(
tmpFile
0x02
|
0x08
|
0x20
0o666
0
)
;
outStream
.
write
(
blobContents
blobContents
.
length
)
;
outStream
.
close
(
)
;
const
fileBlob
=
await
File
.
createFromNsIFile
(
tmpFile
)
;
return
fileBlob
;
}
function
getSWTelemetrySums
(
)
{
let
telemetry
=
Cc
[
"
mozilla
.
org
/
base
/
telemetry
;
1
"
]
.
getService
(
Ci
.
nsITelemetry
)
;
let
keyedhistograms
=
telemetry
.
getSnapshotForKeyedHistograms
(
"
main
"
false
)
.
parent
;
let
keyedscalars
=
telemetry
.
getSnapshotForKeyedScalars
(
"
main
"
false
)
.
parent
;
return
{
SERVICE_WORKER_RUNNING_All
:
keyedhistograms
.
SERVICE_WORKER_RUNNING
?
keyedhistograms
.
SERVICE_WORKER_RUNNING
.
All
.
sum
:
0
SERVICE_WORKER_RUNNING_Fetch
:
keyedhistograms
.
SERVICE_WORKER_RUNNING
?
keyedhistograms
.
SERVICE_WORKER_RUNNING
.
Fetch
.
sum
:
0
}
;
}
add_task
(
async
function
test
(
)
{
let
oldCanRecord
=
Services
.
telemetry
.
canRecordExtended
;
Services
.
telemetry
.
canRecordExtended
=
true
;
registerCleanupFunction
(
(
)
=
>
{
Services
.
telemetry
.
canRecordExtended
=
oldCanRecord
;
}
)
;
let
initialSums
=
getSWTelemetrySums
(
)
;
await
do_test_sw
(
"
example
.
org
"
"
privilegedmozilla
"
"
synthetic
"
null
)
;
const
fileBlob
=
await
makeFileBlob
(
TEST_BLOB_CONTENTS
)
;
await
do_test_sw
(
"
example
.
org
"
"
privilegedmozilla
"
"
synthetic
"
fileBlob
)
;
await
do_test_sw
(
"
example
.
org
"
"
privilegedmozilla
"
"
fetch
"
fileBlob
)
;
await
do_test_sw
(
"
example
.
org
"
"
privilegedmozilla
"
"
clone
"
fileBlob
)
;
if
(
Services
.
appinfo
.
fissionAutostart
)
{
const
isolateUrl
=
"
example
.
com
"
;
const
isolateRemoteType
=
webServiceWorker
=
https
:
/
/
+
isolateUrl
;
await
do_test_sw
(
isolateUrl
isolateRemoteType
"
synthetic
"
null
)
;
await
do_test_sw
(
isolateUrl
isolateRemoteType
"
synthetic
"
fileBlob
)
;
}
let
telemetrySums
=
getSWTelemetrySums
(
)
;
info
(
JSON
.
stringify
(
telemetrySums
)
)
;
info
(
"
Initial
Running
All
:
"
+
initialSums
.
SERVICE_WORKER_RUNNING_All
+
"
Fetch
:
"
+
initialSums
.
SERVICE_WORKER_RUNNING_Fetch
)
;
info
(
"
Running
All
:
"
+
telemetrySums
.
SERVICE_WORKER_RUNNING_All
+
"
Fetch
:
"
+
telemetrySums
.
SERVICE_WORKER_RUNNING_Fetch
)
;
Assert
.
greater
(
telemetrySums
.
SERVICE_WORKER_RUNNING_All
initialSums
.
SERVICE_WORKER_RUNNING_All
"
ServiceWorker
running
count
changed
"
)
;
Assert
.
greater
(
telemetrySums
.
SERVICE_WORKER_RUNNING_Fetch
initialSums
.
SERVICE_WORKER_RUNNING_Fetch
"
ServiceWorker
running
count
changed
"
)
;
}
)
;
