addEventListener
(
"
install
"
evt
=
>
{
evt
.
waitUntil
(
self
.
skipWaiting
(
)
)
;
}
)
;
const
channel
=
new
BroadcastChannel
(
"
stream
-
closed
"
)
;
const
MAX_TICK_COUNT
=
3000
;
const
TICK_INTERVAL
=
4
;
function
handleStream
(
evt
filename
)
{
const
encoder
=
new
TextEncoder
(
)
;
let
strChunk
=
"
Static
routes
are
the
future
of
ServiceWorkers
!
So
say
we
all
!
\
n
"
;
while
(
strChunk
.
length
<
1024
)
{
strChunk
+
=
strChunk
;
}
const
dataChunk
=
encoder
.
encode
(
strChunk
)
;
evt
.
waitUntil
(
new
Promise
(
resolve
=
>
{
let
body
=
new
ReadableStream
(
{
start
:
controller
=
>
{
const
closeStream
=
(
why
)
=
>
{
console
.
log
(
"
closing
stream
:
"
+
JSON
.
stringify
(
why
)
+
"
\
n
"
)
;
clearInterval
(
intervalId
)
;
resolve
(
)
;
if
(
why
.
why
!
=
"
canceled
"
)
{
try
{
controller
.
close
(
)
;
}
catch
(
ex
)
{
channel
.
postMessage
(
{
what
:
filename
why
:
"
close
-
failure
"
message
:
ex
.
message
ticks
:
why
.
ticks
}
)
;
return
;
}
}
channel
.
postMessage
(
why
)
;
}
;
controller
.
enqueue
(
dataChunk
)
;
let
count
=
0
;
let
intervalId
;
function
tick
(
)
{
try
{
if
(
count
+
+
>
MAX_TICK_COUNT
)
{
closeStream
(
{
what
:
filename
why
:
"
timeout
"
message
:
"
timeout
"
ticks
:
count
}
)
;
return
;
}
controller
.
enqueue
(
dataChunk
)
;
}
catch
(
e
)
{
closeStream
(
{
what
:
filename
why
:
"
canceled
"
message
:
e
.
message
ticks
:
count
}
)
;
}
}
intervalId
=
setInterval
(
tick
TICK_INTERVAL
)
;
tick
(
)
;
}
}
)
;
evt
.
respondWith
(
new
Response
(
body
{
headers
:
{
"
Content
-
Disposition
"
:
attachment
;
filename
=
"
{
filename
}
"
"
Content
-
Type
"
:
"
application
/
octet
-
stream
"
}
}
)
)
;
}
)
)
;
}
function
handlePassThrough
(
evt
filename
)
{
evt
.
waitUntil
(
(
async
(
)
=
>
{
console
.
log
(
"
issuing
monitor
fetch
request
"
)
;
const
response
=
await
fetch
(
"
server
-
stream
-
download
.
sjs
?
monitor
"
)
;
console
.
log
(
"
monitor
headers
received
awaiting
body
"
)
;
const
data
=
await
response
.
json
(
)
;
console
.
log
(
"
passthrough
monitor
fetch
completed
notifying
.
"
)
;
channel
.
postMessage
(
{
what
:
filename
why
:
data
.
why
message
:
data
.
message
}
)
;
}
)
(
)
)
;
evt
.
respondWith
(
fetch
(
"
server
-
stream
-
download
.
sjs
"
)
.
then
(
response
=
>
{
console
.
log
(
"
server
-
stream
-
download
.
sjs
Response
received
propagating
"
)
;
return
response
;
}
)
)
;
}
addEventListener
(
"
fetch
"
evt
=
>
{
console
.
log
(
SW
processing
fetch
of
{
evt
.
request
.
url
}
)
;
if
(
evt
.
request
.
url
.
indexOf
(
"
sw
-
stream
-
download
"
)
>
=
0
)
{
return
handleStream
(
evt
"
sw
-
stream
-
download
"
)
;
}
if
(
evt
.
request
.
url
.
indexOf
(
"
sw
-
passthrough
-
download
"
)
>
=
0
)
{
return
handlePassThrough
(
evt
"
sw
-
passthrough
-
download
"
)
;
}
}
)
addEventListener
(
"
message
"
evt
=
>
{
if
(
evt
.
data
=
=
=
"
claim
"
)
{
evt
.
waitUntil
(
clients
.
claim
(
)
)
;
}
}
)
;
