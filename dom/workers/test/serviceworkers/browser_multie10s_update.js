"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
results
:
Cr
}
=
Components
;
const
BASE_URI
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
workers
/
test
/
serviceworkers
/
"
;
add_task
(
async
function
test_update
(
)
{
info
(
"
Setting
the
prefs
to
having
multi
-
e10s
enabled
"
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
"
set
"
:
[
[
"
dom
.
ipc
.
processCount
"
4
]
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
]
}
)
;
let
url
=
BASE_URI
+
"
file_multie10s_update
.
html
"
;
info
(
"
Creating
the
first
tab
.
.
.
"
)
;
let
tab1
=
BrowserTestUtils
.
addTab
(
gBrowser
url
)
;
let
browser1
=
gBrowser
.
getBrowserForTab
(
tab1
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser1
)
;
info
(
"
Creating
the
second
tab
.
.
.
"
)
;
let
tab2
=
BrowserTestUtils
.
addTab
(
gBrowser
url
)
;
let
browser2
=
gBrowser
.
getBrowserForTab
(
tab2
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser2
)
;
let
sw
=
BASE_URI
+
"
server_multie10s_update
.
sjs
"
;
info
(
"
Let
'
s
make
sure
there
are
no
existing
registrations
.
.
.
"
)
;
let
existingCount
=
await
ContentTask
.
spawn
(
browser1
null
async
function
(
)
{
const
regs
=
await
content
.
navigator
.
serviceWorker
.
getRegistrations
(
)
;
return
regs
.
length
;
}
)
;
is
(
existingCount
0
"
Previous
tests
should
have
cleaned
up
!
"
)
;
info
(
"
Let
'
s
start
the
test
.
.
.
"
)
;
let
status
=
await
ContentTask
.
spawn
(
browser1
sw
function
(
url
)
{
content
.
fetch
(
url
+
"
?
release
"
)
;
return
content
.
navigator
.
serviceWorker
.
register
(
url
)
.
then
(
function
(
r
)
{
content
.
registration
=
r
;
return
new
content
.
window
.
Promise
(
resolve
=
>
{
let
worker
=
r
.
installing
;
worker
.
addEventListener
(
'
statechange
'
(
)
=
>
{
if
(
worker
.
state
=
=
=
'
installed
'
)
{
resolve
(
true
)
;
}
}
)
;
}
)
;
}
)
.
then
(
(
)
=
>
{
return
new
content
.
window
.
Promise
(
resolveResults
=
>
{
let
updateCount
=
0
;
const
uc
=
new
content
.
window
.
BroadcastChannel
(
'
update
'
)
;
const
updatesIssued
=
new
Promise
(
resolveUpdatesIssued
=
>
{
uc
.
onmessage
=
function
(
e
)
{
updateCount
+
+
;
console
.
log
(
"
got
update
(
)
number
"
updateCount
)
;
if
(
updateCount
=
=
=
2
)
{
resolveUpdatesIssued
(
)
;
}
}
;
}
)
;
let
results
=
[
]
;
const
rc
=
new
content
.
window
.
BroadcastChannel
(
'
result
'
)
;
const
oneFailed
=
new
Promise
(
resolveOneFailed
=
>
{
rc
.
onmessage
=
function
(
e
)
{
console
.
log
(
"
got
result
"
e
.
data
)
;
results
.
push
(
e
.
data
)
;
if
(
e
.
data
=
=
=
1
)
{
resolveOneFailed
(
)
;
}
if
(
results
.
length
!
=
2
)
{
return
;
}
resolveResults
(
results
[
0
]
+
results
[
1
]
)
;
}
}
)
;
Promise
.
all
(
[
updatesIssued
oneFailed
]
)
.
then
(
(
)
=
>
{
console
.
log
(
"
releasing
update
"
)
;
content
.
fetch
(
url
+
"
?
release
"
)
.
catch
(
(
ex
)
=
>
{
console
.
error
(
"
problem
releasing
:
"
ex
)
;
}
)
;
}
)
;
const
sc
=
new
content
.
window
.
BroadcastChannel
(
'
start
'
)
;
sc
.
postMessage
(
'
go
'
)
;
}
)
;
}
)
;
}
)
;
if
(
status
=
=
0
)
{
ok
(
false
"
both
succeeded
.
This
is
wrong
.
"
)
;
}
else
if
(
status
=
=
1
)
{
ok
(
true
"
one
succeded
one
failed
.
This
is
good
.
"
)
;
}
else
{
ok
(
false
"
both
failed
.
This
is
definitely
wrong
.
"
)
;
}
const
count
=
await
ContentTask
.
spawn
(
browser1
sw
async
function
(
url
)
{
await
content
.
registration
.
unregister
(
)
;
const
{
count
}
=
await
content
.
fetch
(
url
+
"
?
get
-
and
-
clear
-
count
"
)
.
then
(
r
=
>
r
.
json
(
)
)
;
return
count
;
}
)
;
is
(
count
2
"
SW
should
have
been
fetched
only
twice
"
)
;
await
BrowserTestUtils
.
removeTab
(
tab1
)
;
await
BrowserTestUtils
.
removeTab
(
tab2
)
;
}
)
;
