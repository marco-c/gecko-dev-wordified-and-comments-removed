#
include
"
WorkletThread
.
h
"
#
include
"
prthread
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
mozilla
/
dom
/
AtomList
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
#
define
WORKLET_DEFAULT_RUNTIME_HEAPSIZE
32
*
1024
*
1024
#
define
WORKLET_DEFAULT_NURSERY_SIZE
1
*
1024
*
1024
const
uint32_t
kWorkletStackSize
=
256
*
sizeof
(
size_t
)
*
1024
;
class
WorkletThreadContextPrivate
:
private
PerThreadAtomCache
{
public
:
explicit
WorkletThreadContextPrivate
(
WorkletThread
*
aWorkletThread
)
:
mWorkletThread
(
aWorkletThread
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
memset
(
this
0
sizeof
(
PerThreadAtomCache
)
)
;
MOZ_ASSERT
(
mWorkletThread
)
;
}
~
WorkletThreadContextPrivate
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
WorkletThread
*
GetWorkletThread
(
)
const
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mWorkletThread
)
;
return
mWorkletThread
;
}
private
:
WorkletThreadContextPrivate
(
const
WorkletThreadContextPrivate
&
)
=
delete
;
WorkletThreadContextPrivate
&
operator
=
(
const
WorkletThreadContextPrivate
&
)
=
delete
;
RefPtr
<
WorkletThread
>
mWorkletThread
;
}
;
bool
PreserveWrapper
(
JSContext
*
aCx
JSObject
*
aObj
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aObj
)
;
MOZ_ASSERT
(
mozilla
:
:
dom
:
:
IsDOMObject
(
aObj
)
)
;
return
mozilla
:
:
dom
:
:
TryPreserveWrapper
(
aObj
)
;
}
void
DestroyWorkletPrincipals
(
JSPrincipals
*
aPrincipals
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Worklet
principals
refcount
should
never
fall
below
one
"
)
;
}
JSObject
*
Wrap
(
JSContext
*
aCx
JS
:
:
HandleObject
aExisting
JS
:
:
HandleObject
aObj
)
{
if
(
aExisting
)
{
js
:
:
Wrapper
:
:
Renew
(
aExisting
aObj
&
js
:
:
OpaqueCrossCompartmentWrapper
:
:
singleton
)
;
}
return
js
:
:
Wrapper
:
:
New
(
aCx
aObj
&
js
:
:
OpaqueCrossCompartmentWrapper
:
:
singleton
)
;
}
const
JSWrapObjectCallbacks
WrapObjectCallbacks
=
{
Wrap
nullptr
}
;
}
class
WorkletJSRuntime
final
:
public
mozilla
:
:
CycleCollectedJSRuntime
{
public
:
explicit
WorkletJSRuntime
(
JSContext
*
aCx
)
:
CycleCollectedJSRuntime
(
aCx
)
{
}
~
WorkletJSRuntime
(
)
override
=
default
;
virtual
void
PrepareForForgetSkippable
(
)
override
{
}
virtual
void
BeginCycleCollectionCallback
(
)
override
{
}
virtual
void
EndCycleCollectionCallback
(
CycleCollectorResults
&
aResults
)
override
{
}
virtual
void
DispatchDeferredDeletion
(
bool
aContinuation
bool
aPurge
)
override
{
MOZ_ASSERT
(
!
aContinuation
)
;
nsCycleCollector_doDeferredDeletion
(
)
;
}
virtual
void
CustomGCCallback
(
JSGCStatus
aStatus
)
override
{
if
(
aStatus
=
=
JSGC_END
&
&
!
Contexts
(
)
.
isEmpty
(
)
)
{
nsCycleCollector_collect
(
nullptr
)
;
}
}
}
;
class
WorkletJSContext
final
:
public
CycleCollectedJSContext
{
public
:
explicit
WorkletJSContext
(
WorkletThread
*
aWorkletThread
)
:
mWorkletThread
(
aWorkletThread
)
{
MOZ_ASSERT
(
aWorkletThread
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCycleCollector_startup
(
)
;
}
~
WorkletJSContext
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
JSContext
*
cx
=
MaybeContext
(
)
;
if
(
!
cx
)
{
return
;
}
delete
static_cast
<
WorkletThreadContextPrivate
*
>
(
JS_GetContextPrivate
(
cx
)
)
;
JS_SetContextPrivate
(
cx
nullptr
)
;
nsCycleCollector_shutdown
(
)
;
}
WorkletJSContext
*
GetAsWorkletJSContext
(
)
override
{
return
this
;
}
CycleCollectedJSRuntime
*
CreateRuntime
(
JSContext
*
aCx
)
override
{
return
new
WorkletJSRuntime
(
aCx
)
;
}
nsresult
Initialize
(
JSRuntime
*
aParentRuntime
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
CycleCollectedJSContext
:
:
Initialize
(
aParentRuntime
WORKLET_DEFAULT_RUNTIME_HEAPSIZE
WORKLET_DEFAULT_NURSERY_SIZE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
JSContext
*
cx
=
Context
(
)
;
JS_SetContextPrivate
(
cx
new
WorkletThreadContextPrivate
(
mWorkletThread
)
)
;
js
:
:
SetPreserveWrapperCallback
(
cx
PreserveWrapper
)
;
JS_InitDestroyPrincipalsCallback
(
cx
DestroyWorkletPrincipals
)
;
JS_SetWrapObjectCallbacks
(
cx
&
WrapObjectCallbacks
)
;
JS_SetFutexCanWait
(
cx
)
;
return
NS_OK
;
}
void
DispatchToMicroTask
(
already_AddRefed
<
MicroTaskRunnable
>
aRunnable
)
override
{
RefPtr
<
MicroTaskRunnable
>
runnable
(
aRunnable
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
runnable
)
;
WorkletThread
*
workletThread
=
WorkletThread
:
:
Get
(
)
;
MOZ_ASSERT
(
workletThread
)
;
JSContext
*
cx
=
workletThread
-
>
GetJSContext
(
)
;
MOZ_ASSERT
(
cx
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
MOZ_ASSERT
(
global
)
;
#
endif
GetMicroTaskQueue
(
)
.
push
(
runnable
.
forget
(
)
)
;
}
private
:
RefPtr
<
WorkletThread
>
mWorkletThread
;
}
;
class
WorkletThread
:
:
PrimaryRunnable
final
:
public
Runnable
{
public
:
explicit
PrimaryRunnable
(
WorkletThread
*
aWorkletThread
)
:
Runnable
(
"
WorkletThread
:
:
PrimaryRunnable
"
)
mWorkletThread
(
aWorkletThread
)
{
MOZ_ASSERT
(
aWorkletThread
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mParentRuntime
=
JS_GetParentRuntime
(
CycleCollectedJSContext
:
:
Get
(
)
-
>
Context
(
)
)
;
MOZ_ASSERT
(
mParentRuntime
)
;
}
NS_IMETHOD
Run
(
)
override
{
mWorkletThread
-
>
RunEventLoop
(
mParentRuntime
)
;
return
NS_OK
;
}
private
:
RefPtr
<
WorkletThread
>
mWorkletThread
;
JSRuntime
*
mParentRuntime
;
}
;
class
WorkletThread
:
:
TerminateRunnable
final
:
public
Runnable
{
public
:
explicit
TerminateRunnable
(
WorkletThread
*
aWorkletThread
)
:
Runnable
(
"
WorkletThread
:
:
TerminateRunnable
"
)
mWorkletThread
(
aWorkletThread
)
{
MOZ_ASSERT
(
aWorkletThread
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
mWorkletThread
-
>
TerminateInternal
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
WorkletThread
>
mWorkletThread
;
}
;
WorkletThread
:
:
WorkletThread
(
const
WorkletLoadInfo
&
aWorkletLoadInfo
)
:
nsThread
(
MakeNotNull
<
ThreadEventQueue
<
mozilla
:
:
EventQueue
>
*
>
(
MakeUnique
<
mozilla
:
:
EventQueue
>
(
)
)
nsThread
:
:
NOT_MAIN_THREAD
kWorkletStackSize
)
mWorkletLoadInfo
(
aWorkletLoadInfo
)
mCreationTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mJSContext
(
nullptr
)
mIsTerminating
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
}
WorkletThread
:
:
~
WorkletThread
(
)
{
MOZ_ASSERT
(
!
mJSContext
)
;
}
already_AddRefed
<
WorkletThread
>
WorkletThread
:
:
Create
(
const
WorkletLoadInfo
&
aWorkletLoadInfo
)
{
RefPtr
<
WorkletThread
>
thread
=
new
WorkletThread
(
aWorkletLoadInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
thread
-
>
Init
(
)
)
)
)
{
return
nullptr
;
}
RefPtr
<
PrimaryRunnable
>
runnable
=
new
PrimaryRunnable
(
thread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
thread
-
>
DispatchRunnable
(
runnable
.
forget
(
)
)
)
)
)
{
return
nullptr
;
}
return
thread
.
forget
(
)
;
}
nsresult
WorkletThread
:
:
DispatchRunnable
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
nsThread
:
:
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
WorkletThread
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
return
Dispatch
(
runnable
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
WorkletThread
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
if
(
NS_WARN_IF
(
aFlags
!
=
NS_DISPATCH_NORMAL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
nsThread
:
:
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
WorkletThread
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
aFlags
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
WorkletThread
:
:
RunEventLoop
(
JSRuntime
*
aParentRuntime
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
PR_SetCurrentThreadName
(
"
worklet
"
)
;
WorkletJSContext
context
(
this
)
;
nsresult
rv
=
context
.
Initialize
(
aParentRuntime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
!
JS
:
:
InitSelfHostedCode
(
context
.
Context
(
)
)
)
{
return
;
}
mJSContext
=
context
.
Context
(
)
;
while
(
mJSContext
)
{
MOZ_ALWAYS_TRUE
(
NS_ProcessNextEvent
(
this
true
)
)
;
}
MOZ_ASSERT
(
mJSContext
=
=
nullptr
)
;
}
void
WorkletThread
:
:
Terminate
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mIsTerminating
)
{
return
;
}
mIsTerminating
=
true
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
RefPtr
<
TerminateRunnable
>
runnable
=
new
TerminateRunnable
(
this
)
;
DispatchRunnable
(
runnable
.
forget
(
)
)
;
}
void
WorkletThread
:
:
TerminateInternal
(
)
{
AssertIsOnWorkletThread
(
)
;
mJSContext
=
nullptr
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
WorkletThread
:
:
Shutdown
"
this
&
WorkletThread
:
:
Shutdown
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
JSContext
*
WorkletThread
:
:
GetJSContext
(
)
const
{
AssertIsOnWorkletThread
(
)
;
MOZ_ASSERT
(
mJSContext
)
;
return
mJSContext
;
}
const
WorkletLoadInfo
&
WorkletThread
:
:
GetWorkletLoadInfo
(
)
const
{
return
mWorkletLoadInfo
;
}
bool
WorkletThread
:
:
IsOnWorkletThread
(
)
{
CycleCollectedJSContext
*
ccjscx
=
CycleCollectedJSContext
:
:
Get
(
)
;
return
ccjscx
&
&
ccjscx
-
>
GetAsWorkletJSContext
(
)
;
}
void
WorkletThread
:
:
AssertIsOnWorkletThread
(
)
{
MOZ_ASSERT
(
IsOnWorkletThread
(
)
)
;
}
WorkletThread
*
WorkletThread
:
:
Get
(
)
{
AssertIsOnWorkletThread
(
)
;
CycleCollectedJSContext
*
ccjscx
=
CycleCollectedJSContext
:
:
Get
(
)
;
MOZ_ASSERT
(
ccjscx
)
;
void
*
cxPrivate
=
JS_GetContextPrivate
(
ccjscx
-
>
Context
(
)
)
;
MOZ_ASSERT
(
cxPrivate
)
;
return
static_cast
<
WorkletThreadContextPrivate
*
>
(
cxPrivate
)
-
>
GetWorkletThread
(
)
;
}
NS_IMETHODIMP
WorkletThread
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
)
{
MOZ_ASSERT
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
;
Terminate
(
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
WorkletThread
nsThread
nsIObserver
)
}
}
