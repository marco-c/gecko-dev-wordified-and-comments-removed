#
include
"
WorkletFetchHandler
.
h
"
#
include
"
js
/
loader
/
ModuleLoadRequest
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Fetch
.
h
"
#
include
"
mozilla
/
dom
/
Request
.
h
"
#
include
"
mozilla
/
dom
/
Response
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
Worklet
.
h
"
#
include
"
mozilla
/
dom
/
WorkletBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkletGlobalScope
.
h
"
#
include
"
mozilla
/
dom
/
WorkletImpl
.
h
"
#
include
"
mozilla
/
dom
/
WorkletThread
.
h
"
#
include
"
mozilla
/
dom
/
worklet
/
WorkletModuleLoader
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
using
JS
:
:
loader
:
:
ModuleLoadRequest
;
using
JS
:
:
loader
:
:
ScriptFetchOptions
;
using
mozilla
:
:
dom
:
:
loader
:
:
WorkletModuleLoader
;
namespace
mozilla
:
:
dom
{
class
StartModuleLoadRunnable
final
:
public
Runnable
{
public
:
StartModuleLoadRunnable
(
WorkletImpl
*
aWorkletImpl
const
nsMainThreadPtrHandle
<
WorkletFetchHandler
>
&
aHandlerRef
nsCOMPtr
<
nsIURI
>
aURI
nsIURI
*
aReferrer
)
:
Runnable
(
"
Worklet
:
:
StartModuleLoadRunnable
"
)
mWorkletImpl
(
aWorkletImpl
)
mHandlerRef
(
aHandlerRef
)
mURI
(
std
:
:
move
(
aURI
)
)
mReferrer
(
aReferrer
)
mParentRuntime
(
JS_GetParentRuntime
(
CycleCollectedJSContext
:
:
Get
(
)
-
>
Context
(
)
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mParentRuntime
)
;
}
~
StartModuleLoadRunnable
(
)
=
default
;
NS_IMETHOD
Run
(
)
override
;
private
:
NS_IMETHOD
RunOnWorkletThread
(
)
;
RefPtr
<
WorkletImpl
>
mWorkletImpl
;
nsMainThreadPtrHandle
<
WorkletFetchHandler
>
mHandlerRef
;
nsCOMPtr
<
nsIURI
>
mURI
;
nsIURI
*
mReferrer
;
JSRuntime
*
mParentRuntime
;
}
;
NS_IMETHODIMP
StartModuleLoadRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
return
RunOnWorkletThread
(
)
;
}
NS_IMETHODIMP
StartModuleLoadRunnable
:
:
RunOnWorkletThread
(
)
{
WorkletThread
:
:
EnsureCycleCollectedJSContext
(
mParentRuntime
)
;
WorkletGlobalScope
*
globalScope
=
mWorkletImpl
-
>
GetGlobalScope
(
)
;
if
(
!
globalScope
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
ReferrerPolicy
referrerPolicy
=
ReferrerPolicy
:
:
_empty
;
RefPtr
<
ScriptFetchOptions
>
fetchOptions
=
new
ScriptFetchOptions
(
CORSMode
:
:
CORS_NONE
referrerPolicy
nullptr
)
;
WorkletModuleLoader
*
moduleLoader
=
static_cast
<
WorkletModuleLoader
*
>
(
globalScope
-
>
GetModuleLoader
(
)
)
;
MOZ_ASSERT
(
moduleLoader
)
;
RefPtr
<
WorkletLoadContext
>
loadContext
=
new
WorkletLoadContext
(
mHandlerRef
)
;
RefPtr
<
ModuleLoadRequest
>
request
=
new
ModuleLoadRequest
(
mURI
fetchOptions
SRIMetadata
(
)
mReferrer
loadContext
true
false
moduleLoader
ModuleLoadRequest
:
:
NewVisitedSetForTopLevelImport
(
mURI
)
nullptr
)
;
request
-
>
mURL
=
request
-
>
mURI
-
>
GetSpecOrDefault
(
)
;
return
request
-
>
StartModuleLoad
(
)
;
}
class
ExecutionRunnable
final
:
public
Runnable
{
public
:
ExecutionRunnable
(
WorkletFetchHandler
*
aHandler
WorkletImpl
*
aWorkletImpl
UniquePtr
<
Utf8Unit
[
]
JS
:
:
FreePolicy
>
aScriptBuffer
size_t
aScriptLength
)
:
Runnable
(
"
Worklet
:
:
ExecutionRunnable
"
)
mHandler
(
aHandler
)
mWorkletImpl
(
aWorkletImpl
)
mScriptBuffer
(
std
:
:
move
(
aScriptBuffer
)
)
mScriptLength
(
aScriptLength
)
mParentRuntime
(
JS_GetParentRuntime
(
CycleCollectedJSContext
:
:
Get
(
)
-
>
Context
(
)
)
)
mResult
(
NS_ERROR_FAILURE
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mParentRuntime
)
;
}
NS_IMETHOD
Run
(
)
override
;
private
:
void
RunOnWorkletThread
(
)
;
void
RunOnMainThread
(
)
;
bool
ParseAndLinkModule
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
;
RefPtr
<
WorkletFetchHandler
>
mHandler
;
RefPtr
<
WorkletImpl
>
mWorkletImpl
;
UniquePtr
<
Utf8Unit
[
]
JS
:
:
FreePolicy
>
mScriptBuffer
;
size_t
mScriptLength
;
JSRuntime
*
mParentRuntime
;
nsresult
mResult
;
}
;
NS_IMETHODIMP
ExecutionRunnable
:
:
Run
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
RunOnWorkletThread
(
)
;
return
NS_DispatchToMainThread
(
this
)
;
}
RunOnMainThread
(
)
;
return
NS_OK
;
}
bool
ExecutionRunnable
:
:
ParseAndLinkModule
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
{
JS
:
:
CompileOptions
compileOptions
(
aCx
)
;
compileOptions
.
setIntroductionType
(
"
Worklet
"
)
;
compileOptions
.
setIsRunOnce
(
true
)
;
compileOptions
.
setNoScriptRval
(
true
)
;
JS
:
:
SourceText
<
Utf8Unit
>
buffer
;
if
(
!
buffer
.
init
(
aCx
std
:
:
move
(
mScriptBuffer
)
mScriptLength
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
JS
:
:
CompileModule
(
aCx
compileOptions
buffer
)
)
;
if
(
!
module
)
{
return
false
;
}
if
(
!
JS
:
:
ModuleLink
(
aCx
module
)
)
{
return
false
;
}
aModule
.
set
(
module
)
;
return
true
;
}
void
ExecutionRunnable
:
:
RunOnWorkletThread
(
)
{
WorkletThread
:
:
EnsureCycleCollectedJSContext
(
mParentRuntime
)
;
WorkletGlobalScope
*
globalScope
=
mWorkletImpl
-
>
GetGlobalScope
(
)
;
if
(
!
globalScope
)
{
mResult
=
NS_ERROR_DOM_UNKNOWN_ERR
;
return
;
}
AutoEntryScript
aes
(
globalScope
"
Worklet
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
cx
)
;
if
(
!
ParseAndLinkModule
(
cx
&
module
)
)
{
mResult
=
NS_ERROR_DOM_ABORT_ERR
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
cx
)
;
JS
:
:
ModuleEvaluate
(
cx
module
&
rval
)
;
if
(
!
rval
.
isUndefined
(
)
&
&
rval
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
aEvaluationPromise
(
cx
)
;
aEvaluationPromise
.
set
(
&
rval
.
toObject
(
)
)
;
if
(
!
JS
:
:
ThrowOnModuleEvaluationFailure
(
cx
aEvaluationPromise
)
)
{
mResult
=
NS_ERROR_DOM_ABORT_ERR
;
return
;
}
}
mResult
=
NS_OK
;
}
void
ExecutionRunnable
:
:
RunOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
mResult
)
)
{
mHandler
-
>
ExecutionFailed
(
mResult
)
;
return
;
}
mHandler
-
>
ExecutionSucceeded
(
)
;
}
NS_IMPL_ISUPPORTS
(
WorkletFetchHandler
nsISupports
)
already_AddRefed
<
Promise
>
WorkletFetchHandler
:
:
AddModule
(
Worklet
*
aWorklet
JSContext
*
aCx
const
nsAString
&
aModuleURL
const
WorkletOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aWorklet
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aWorklet
-
>
Impl
(
)
-
>
OnAddModuleStarted
(
)
;
auto
promiseSettledGuard
=
MakeScopeExit
(
[
&
]
{
aWorklet
-
>
Impl
(
)
-
>
OnAddModulePromiseSettled
(
)
;
}
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aWorklet
-
>
GetParentObject
(
)
)
;
MOZ_ASSERT
(
global
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
aWorklet
-
>
GetParentObject
(
)
;
MOZ_ASSERT
(
window
)
;
nsCOMPtr
<
Document
>
doc
;
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
resolvedURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
resolvedURI
)
aModuleURL
nullptr
doc
-
>
GetBaseURI
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
rv
=
NS_ERROR_DOM_SYNTAX_ERR
;
promise
-
>
MaybeReject
(
rv
)
;
return
promise
.
forget
(
)
;
}
nsAutoCString
spec
;
rv
=
resolvedURI
-
>
GetSpec
(
spec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
rv
=
NS_ERROR_DOM_SYNTAX_ERR
;
promise
-
>
MaybeReject
(
rv
)
;
return
promise
.
forget
(
)
;
}
{
WorkletFetchHandler
*
handler
=
aWorklet
-
>
GetImportFetchHandler
(
spec
)
;
if
(
handler
)
{
handler
-
>
AddPromise
(
promise
)
;
return
promise
.
forget
(
)
;
}
}
RequestOrUSVString
requestInput
;
requestInput
.
SetAsUSVString
(
)
.
ShareOrDependUpon
(
aModuleURL
)
;
RootedDictionary
<
RequestInit
>
requestInit
(
aCx
)
;
requestInit
.
mCredentials
.
Construct
(
aOptions
.
mCredentials
)
;
SafeRefPtr
<
Request
>
request
=
Request
:
:
Constructor
(
global
aCx
requestInput
requestInit
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
request
-
>
OverrideContentPolicyType
(
aWorklet
-
>
Impl
(
)
-
>
ContentPolicyType
(
)
)
;
RequestOrUSVString
finalRequestInput
;
finalRequestInput
.
SetAsRequest
(
)
=
request
.
unsafeGetRawPtr
(
)
;
RefPtr
<
Promise
>
fetchPromise
=
FetchRequest
(
global
finalRequestInput
requestInit
CallerType
:
:
System
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
WorkletScriptHandler
>
scriptHandler
=
new
WorkletScriptHandler
(
aWorklet
)
;
fetchPromise
-
>
AppendNativeHandler
(
scriptHandler
)
;
RefPtr
<
WorkletFetchHandler
>
handler
=
new
WorkletFetchHandler
(
aWorklet
promise
)
;
nsMainThreadPtrHandle
<
WorkletFetchHandler
>
handlerRef
{
new
nsMainThreadPtrHolder
<
WorkletFetchHandler
>
(
"
FetchHandler
"
handler
)
}
;
nsIURI
*
referrer
=
doc
-
>
GetDocumentURIAsReferrer
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
StartModuleLoadRunnable
(
aWorklet
-
>
mImpl
handlerRef
std
:
:
move
(
resolvedURI
)
referrer
)
;
if
(
NS_FAILED
(
aWorklet
-
>
mImpl
-
>
SendControlMessage
(
runnable
.
forget
(
)
)
)
)
{
return
nullptr
;
}
promiseSettledGuard
.
release
(
)
;
aWorklet
-
>
AddImportFetchHandler
(
spec
handler
)
;
return
promise
.
forget
(
)
;
}
WorkletFetchHandler
:
:
WorkletFetchHandler
(
Worklet
*
aWorklet
Promise
*
aPromise
)
:
mWorklet
(
aWorklet
)
mStatus
(
ePending
)
{
MOZ_ASSERT
(
aWorklet
)
;
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mPromises
.
AppendElement
(
aPromise
)
;
}
void
WorkletFetchHandler
:
:
ExecutionFailed
(
nsresult
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RejectPromises
(
aRv
)
;
}
void
WorkletFetchHandler
:
:
ExecutionSucceeded
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ResolvePromises
(
)
;
}
void
WorkletFetchHandler
:
:
AddPromise
(
Promise
*
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
mStatus
)
{
case
ePending
:
mPromises
.
AppendElement
(
aPromise
)
;
return
;
case
eRejected
:
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
case
eResolved
:
aPromise
-
>
MaybeResolveWithUndefined
(
)
;
return
;
}
}
void
WorkletFetchHandler
:
:
RejectPromises
(
nsresult
aResult
)
{
MOZ_ASSERT
(
mStatus
=
=
ePending
)
;
MOZ_ASSERT
(
NS_FAILED
(
aResult
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWorklet
-
>
Impl
(
)
-
>
OnAddModulePromiseSettled
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mPromises
.
Length
(
)
;
+
+
i
)
{
mPromises
[
i
]
-
>
MaybeReject
(
aResult
)
;
}
mPromises
.
Clear
(
)
;
mStatus
=
eRejected
;
mWorklet
=
nullptr
;
}
void
WorkletFetchHandler
:
:
ResolvePromises
(
)
{
MOZ_ASSERT
(
mStatus
=
=
ePending
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWorklet
-
>
Impl
(
)
-
>
OnAddModulePromiseSettled
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mPromises
.
Length
(
)
;
+
+
i
)
{
mPromises
[
i
]
-
>
MaybeResolveWithUndefined
(
)
;
}
mPromises
.
Clear
(
)
;
mStatus
=
eResolved
;
mWorklet
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
WorkletScriptHandler
nsIStreamLoaderObserver
)
WorkletScriptHandler
:
:
WorkletScriptHandler
(
Worklet
*
aWorklet
)
:
mWorklet
(
aWorklet
)
{
}
void
WorkletScriptHandler
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aValue
.
isObject
(
)
)
{
HandleFailure
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
Response
>
response
;
nsresult
rv
=
UNWRAP_OBJECT
(
Response
&
aValue
.
toObject
(
)
response
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
HandleFailure
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
!
response
-
>
Ok
(
)
)
{
HandleFailure
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
response
-
>
GetBody
(
getter_AddRefs
(
inputStream
)
)
;
if
(
!
inputStream
)
{
HandleFailure
(
NS_ERROR_DOM_NETWORK_ERR
)
;
return
;
}
nsCOMPtr
<
nsIInputStreamPump
>
pump
;
rv
=
NS_NewInputStreamPump
(
getter_AddRefs
(
pump
)
inputStream
.
forget
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
HandleFailure
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIStreamLoader
>
loader
;
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
loader
)
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
HandleFailure
(
rv
)
;
return
;
}
rv
=
pump
-
>
AsyncRead
(
loader
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
HandleFailure
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIThreadRetargetableRequest
>
rr
=
do_QueryInterface
(
pump
)
;
if
(
rr
)
{
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
rv
=
rr
-
>
RetargetDeliveryTo
(
sts
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
the
nsIInputStreamPump
to
a
IO
thread
.
"
)
;
}
}
}
NS_IMETHODIMP
WorkletScriptHandler
:
:
OnStreamComplete
(
nsIStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aStringLen
const
uint8_t
*
aString
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
HandleFailure
(
aStatus
)
;
return
NS_OK
;
}
UniquePtr
<
Utf8Unit
[
]
JS
:
:
FreePolicy
>
scriptTextBuf
;
size_t
scriptTextLength
;
nsresult
rv
=
ScriptLoader
:
:
ConvertToUTF8
(
nullptr
aString
aStringLen
u
"
UTF
-
8
"
_ns
nullptr
scriptTextBuf
scriptTextLength
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
HandleFailure
(
rv
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ExecutionRunnable
(
nullptr
mWorklet
-
>
mImpl
std
:
:
move
(
scriptTextBuf
)
scriptTextLength
)
;
if
(
NS_FAILED
(
mWorklet
-
>
mImpl
-
>
SendControlMessage
(
runnable
.
forget
(
)
)
)
)
{
HandleFailure
(
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
void
WorkletScriptHandler
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
HandleFailure
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
void
WorkletScriptHandler
:
:
HandleFailure
(
nsresult
aResult
)
{
}
}
