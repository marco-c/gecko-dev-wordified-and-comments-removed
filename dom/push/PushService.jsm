"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
const
{
PushDB
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushDB
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
const
{
PushServiceWebSocket
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushServiceWebSocket
.
jsm
"
)
;
const
{
PushServiceHttp2
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushServiceHttp2
.
jsm
"
)
;
const
{
PushCrypto
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushCrypto
.
jsm
"
)
;
const
CONNECTION_PROTOCOLS
=
[
PushServiceWebSocket
PushServiceHttp2
]
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AlarmService
"
"
resource
:
/
/
gre
/
modules
/
AlarmService
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gContentSecurityManager
"
"
mozilla
.
org
/
contentsecuritymanager
;
1
"
"
nsIContentSecurityManager
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
PushService
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
dom
.
push
.
loglevel
"
prefix
:
"
PushService
"
}
)
;
}
)
;
const
prefs
=
new
Preferences
(
"
dom
.
push
.
"
)
;
const
kCHILD_PROCESS_MESSAGES
=
[
"
Push
:
Register
"
"
Push
:
Unregister
"
"
Push
:
Registration
"
"
Push
:
RegisterEventNotificationListener
"
"
Push
:
NotificationForOriginShown
"
"
Push
:
NotificationForOriginClosed
"
"
child
-
process
-
shutdown
"
]
;
const
PUSH_SERVICE_UNINIT
=
0
;
const
PUSH_SERVICE_INIT
=
1
;
const
PUSH_SERVICE_ACTIVATING
=
2
;
const
PUSH_SERVICE_CONNECTION_DISABLE
=
3
;
const
PUSH_SERVICE_ACTIVE_OFFLINE
=
4
;
const
PUSH_SERVICE_RUNNING
=
5
;
const
kDROP_NOTIFICATION_REASON_KEY_NOT_FOUND
=
0
;
const
kDROP_NOTIFICATION_REASON_NO_HISTORY
=
1
;
const
kDROP_NOTIFICATION_REASON_NO_VERSION_INCREMENT
=
2
;
const
kDROP_NOTIFICATION_REASON_EXPIRED
=
3
;
const
STARTING_SERVICE_EVENT
=
0
;
const
CHANGING_SERVICE_EVENT
=
1
;
const
STOPPING_SERVICE_EVENT
=
2
;
const
UNINIT_EVENT
=
3
;
this
.
PushService
=
{
_service
:
null
_state
:
PUSH_SERVICE_UNINIT
_db
:
null
_options
:
null
_alarmID
:
null
_visibleNotifications
:
new
Map
(
)
_updateQuotaTestCallback
:
null
_childListeners
:
[
]
_stateChangeProcessQueue
:
null
_stateChangeProcessEnqueue
:
function
(
op
)
{
if
(
!
this
.
_stateChangeProcessQueue
)
{
this
.
_stateChangeProcessQueue
=
Promise
.
resolve
(
)
;
}
this
.
_stateChangeProcessQueue
=
this
.
_stateChangeProcessQueue
.
then
(
op
)
.
catch
(
_
=
>
{
}
)
;
}
_pendingRegisterRequest
:
{
}
_notifyActivated
:
null
_activated
:
null
_checkActivated
:
function
(
)
{
if
(
this
.
_state
<
PUSH_SERVICE_ACTIVATING
)
{
return
Promise
.
reject
(
new
Error
(
"
Push
service
not
active
"
)
)
;
}
else
if
(
this
.
_state
>
PUSH_SERVICE_ACTIVATING
)
{
return
Promise
.
resolve
(
)
;
}
else
{
return
(
this
.
_activated
)
?
this
.
_activated
:
this
.
_activated
=
new
Promise
(
(
res
rej
)
=
>
this
.
_notifyActivated
=
{
resolve
:
res
reject
:
rej
}
)
;
}
}
_makePendingKey
:
function
(
aPageRecord
)
{
return
aPageRecord
.
scope
+
"
|
"
+
aPageRecord
.
originAttributes
;
}
_lookupOrPutPendingRequest
:
function
(
aPageRecord
)
{
let
key
=
this
.
_makePendingKey
(
aPageRecord
)
;
if
(
this
.
_pendingRegisterRequest
[
key
]
)
{
return
this
.
_pendingRegisterRequest
[
key
]
;
}
return
this
.
_pendingRegisterRequest
[
key
]
=
this
.
_registerWithServer
(
aPageRecord
)
;
}
_deletePendingRequest
:
function
(
aPageRecord
)
{
let
key
=
this
.
_makePendingKey
(
aPageRecord
)
;
if
(
this
.
_pendingRegisterRequest
[
key
]
)
{
delete
this
.
_pendingRegisterRequest
[
key
]
;
}
}
_setState
:
function
(
aNewState
)
{
console
.
debug
(
"
setState
(
)
"
"
new
state
"
aNewState
"
old
state
"
this
.
_state
)
;
if
(
this
.
_state
=
=
aNewState
)
{
return
;
}
if
(
this
.
_state
=
=
PUSH_SERVICE_ACTIVATING
)
{
this
.
_state
=
aNewState
;
if
(
this
.
_notifyActivated
)
{
if
(
aNewState
<
PUSH_SERVICE_ACTIVATING
)
{
this
.
_notifyActivated
.
reject
(
new
Error
(
"
Push
service
not
active
"
)
)
;
}
else
{
this
.
_notifyActivated
.
resolve
(
)
;
}
}
this
.
_notifyActivated
=
null
;
this
.
_activated
=
null
;
}
this
.
_state
=
aNewState
;
}
_changeStateOfflineEvent
:
function
(
offline
calledFromConnEnabledEvent
)
{
console
.
debug
(
"
changeStateOfflineEvent
(
)
"
offline
)
;
if
(
this
.
_state
<
PUSH_SERVICE_ACTIVE_OFFLINE
&
&
this
.
_state
!
=
PUSH_SERVICE_ACTIVATING
&
&
!
calledFromConnEnabledEvent
)
{
return
;
}
if
(
offline
)
{
if
(
this
.
_state
=
=
PUSH_SERVICE_RUNNING
)
{
this
.
_service
.
disconnect
(
)
;
}
this
.
_setState
(
PUSH_SERVICE_ACTIVE_OFFLINE
)
;
}
else
{
if
(
this
.
_state
=
=
PUSH_SERVICE_RUNNING
)
{
this
.
_service
.
disconnect
(
)
;
}
this
.
_db
.
getAllUnexpired
(
)
.
then
(
records
=
>
{
if
(
records
.
length
>
0
)
{
this
.
_service
.
connect
(
records
)
;
}
}
)
;
this
.
_setState
(
PUSH_SERVICE_RUNNING
)
;
}
}
_changeStateConnectionEnabledEvent
:
function
(
enabled
)
{
console
.
debug
(
"
changeStateConnectionEnabledEvent
(
)
"
enabled
)
;
if
(
this
.
_state
<
PUSH_SERVICE_CONNECTION_DISABLE
&
&
this
.
_state
!
=
PUSH_SERVICE_ACTIVATING
)
{
return
;
}
if
(
enabled
)
{
this
.
_changeStateOfflineEvent
(
Services
.
io
.
offline
true
)
;
}
else
{
if
(
this
.
_state
=
=
PUSH_SERVICE_RUNNING
)
{
this
.
_service
.
disconnect
(
)
;
}
this
.
_setState
(
PUSH_SERVICE_CONNECTION_DISABLE
)
;
}
}
observe
:
function
observe
(
aSubject
aTopic
aData
)
{
switch
(
aTopic
)
{
case
"
xpcom
-
shutdown
"
:
this
.
uninit
(
)
;
break
;
case
"
network
-
active
-
changed
"
:
case
"
network
:
offline
-
status
-
changed
"
:
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeStateOfflineEvent
(
aData
=
=
=
"
offline
"
false
)
)
;
break
;
case
"
nsPref
:
changed
"
:
if
(
aData
=
=
"
dom
.
push
.
serverURL
"
)
{
console
.
debug
(
"
observe
:
dom
.
push
.
serverURL
changed
for
websocket
"
prefs
.
get
(
"
serverURL
"
)
)
;
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeServerURL
(
prefs
.
get
(
"
serverURL
"
)
CHANGING_SERVICE_EVENT
)
)
;
}
else
if
(
aData
=
=
"
dom
.
push
.
connection
.
enabled
"
)
{
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeStateConnectionEnabledEvent
(
prefs
.
get
(
"
connection
.
enabled
"
)
)
)
;
}
break
;
case
"
idle
-
daily
"
:
this
.
_dropExpiredRegistrations
(
)
;
break
;
case
"
perm
-
changed
"
:
this
.
_onPermissionChange
(
aSubject
aData
)
.
catch
(
error
=
>
{
console
.
error
(
"
onPermissionChange
:
Error
updating
registrations
:
"
error
)
;
}
)
break
;
case
"
clear
-
origin
-
data
"
:
this
.
_clearOriginData
(
aData
)
.
catch
(
error
=
>
{
console
.
error
(
"
clearOriginData
:
Error
clearing
origin
data
:
"
error
)
;
}
)
;
break
;
}
}
_clearOriginData
:
function
(
data
)
{
console
.
log
(
"
clearOriginData
(
)
"
)
;
if
(
!
data
)
{
return
Promise
.
resolve
(
)
;
}
let
pattern
=
JSON
.
parse
(
data
)
;
return
this
.
_db
.
clearIf
(
record
=
>
{
if
(
!
record
.
matchesOriginAttributes
(
pattern
)
)
{
return
false
;
}
this
.
_backgroundUnregister
(
record
)
;
return
true
;
}
)
;
}
_backgroundUnregister
:
function
(
record
)
{
console
.
debug
(
"
backgroundUnregister
(
)
"
)
;
if
(
!
this
.
_service
.
isConnected
(
)
|
|
!
record
)
{
return
;
}
console
.
debug
(
"
backgroundUnregister
:
Notifying
server
"
record
)
;
this
.
_sendUnregister
(
record
)
.
catch
(
e
=
>
{
console
.
error
(
"
backgroundUnregister
:
Error
notifying
server
"
e
)
;
}
)
;
}
getNetworkStateChangeEventName
:
function
(
)
{
try
{
Cc
[
"
mozilla
.
org
/
network
/
manager
;
1
"
]
.
getService
(
Ci
.
nsINetworkManager
)
;
return
"
network
-
active
-
changed
"
;
}
catch
(
e
)
{
return
"
network
:
offline
-
status
-
changed
"
;
}
}
_findService
:
function
(
serverURL
)
{
console
.
debug
(
"
findService
(
)
"
)
;
let
uri
;
let
service
;
if
(
!
serverURL
)
{
console
.
warn
(
"
findService
:
No
dom
.
push
.
serverURL
found
"
)
;
return
[
]
;
}
try
{
uri
=
Services
.
io
.
newURI
(
serverURL
null
null
)
;
}
catch
(
e
)
{
console
.
warn
(
"
findService
:
Error
creating
valid
URI
from
"
"
dom
.
push
.
serverURL
"
serverURL
)
;
return
[
]
;
}
if
(
!
gContentSecurityManager
.
isURIPotentiallyTrustworthy
(
uri
)
)
{
console
.
warn
(
"
findService
:
Untrusted
server
URI
"
uri
.
spec
)
;
return
[
]
;
}
for
(
let
connProtocol
of
CONNECTION_PROTOCOLS
)
{
if
(
connProtocol
.
validServerURI
(
uri
)
)
{
service
=
connProtocol
;
break
;
}
}
return
[
service
uri
]
;
}
_changeServerURL
:
function
(
serverURI
event
)
{
console
.
debug
(
"
changeServerURL
(
)
"
)
;
switch
(
event
)
{
case
UNINIT_EVENT
:
return
this
.
_stopService
(
event
)
;
case
STARTING_SERVICE_EVENT
:
{
let
[
service
uri
]
=
this
.
_findService
(
serverURI
)
;
if
(
!
service
)
{
this
.
_setState
(
PUSH_SERVICE_INIT
)
;
return
Promise
.
resolve
(
)
;
}
return
this
.
_startService
(
service
uri
event
)
.
then
(
_
=
>
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeStateConnectionEnabledEvent
(
prefs
.
get
(
"
connection
.
enabled
"
)
)
)
)
;
}
case
CHANGING_SERVICE_EVENT
:
let
[
service
uri
]
=
this
.
_findService
(
serverURI
)
;
if
(
service
)
{
if
(
this
.
_state
=
=
PUSH_SERVICE_INIT
)
{
this
.
_setState
(
PUSH_SERVICE_ACTIVATING
)
;
return
this
.
_startService
(
service
uri
STARTING_SERVICE_EVENT
)
.
then
(
_
=
>
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeStateConnectionEnabledEvent
(
prefs
.
get
(
"
connection
.
enabled
"
)
)
)
)
;
}
else
{
this
.
_setState
(
PUSH_SERVICE_ACTIVATING
)
;
return
this
.
_stopService
(
CHANGING_SERVICE_EVENT
)
.
then
(
_
=
>
this
.
_startService
(
service
uri
CHANGING_SERVICE_EVENT
)
)
.
then
(
_
=
>
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeStateConnectionEnabledEvent
(
prefs
.
get
(
"
connection
.
enabled
"
)
)
)
)
;
}
}
else
{
if
(
this
.
_state
=
=
PUSH_SERVICE_INIT
)
{
return
Promise
.
resolve
(
)
;
}
else
{
this
.
_setState
(
PUSH_SERVICE_INIT
)
;
return
this
.
_stopService
(
STOPPING_SERVICE_EVENT
)
;
}
}
}
}
init
:
function
(
options
=
{
}
)
{
console
.
debug
(
"
init
(
)
"
)
;
if
(
this
.
_state
>
PUSH_SERVICE_UNINIT
)
{
return
;
}
this
.
_setState
(
PUSH_SERVICE_ACTIVATING
)
;
Services
.
obs
.
addObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
if
(
options
.
serverURI
)
{
let
[
service
uri
]
=
this
.
_findService
(
options
.
serverURI
)
;
if
(
!
service
)
{
this
.
_setState
(
PUSH_SERVICE_INIT
)
;
return
;
}
this
.
_startService
(
service
uri
false
options
)
.
then
(
_
=
>
{
this
.
_changeStateConnectionEnabledEvent
(
prefs
.
get
(
"
connection
.
enabled
"
)
)
;
}
)
;
}
else
{
prefs
.
observe
(
"
serverURL
"
this
)
;
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeServerURL
(
prefs
.
get
(
"
serverURL
"
)
STARTING_SERVICE_EVENT
)
)
;
}
}
_startObservers
:
function
(
)
{
console
.
debug
(
"
startObservers
(
)
"
)
;
if
(
this
.
_state
!
=
PUSH_SERVICE_ACTIVATING
)
{
return
;
}
Services
.
obs
.
addObserver
(
this
"
clear
-
origin
-
data
"
false
)
;
this
.
_networkStateChangeEventName
=
this
.
getNetworkStateChangeEventName
(
)
;
Services
.
obs
.
addObserver
(
this
this
.
_networkStateChangeEventName
false
)
;
prefs
.
observe
(
"
connection
.
enabled
"
this
)
;
Services
.
obs
.
addObserver
(
this
"
idle
-
daily
"
false
)
;
Services
.
obs
.
addObserver
(
this
"
perm
-
changed
"
false
)
;
}
_startService
:
function
(
service
serverURI
event
options
=
{
}
)
{
console
.
debug
(
"
startService
(
)
"
)
;
if
(
this
.
_state
!
=
PUSH_SERVICE_ACTIVATING
)
{
return
;
}
if
(
event
!
=
CHANGING_SERVICE_EVENT
)
{
let
ppmm
=
Cc
[
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageBroadcaster
)
;
kCHILD_PROCESS_MESSAGES
.
forEach
(
msgName
=
>
ppmm
.
addMessageListener
(
msgName
this
)
)
;
}
this
.
_service
=
service
;
this
.
_db
=
options
.
db
;
if
(
!
this
.
_db
)
{
this
.
_db
=
this
.
_service
.
newPushDB
(
)
;
}
this
.
_service
.
init
(
options
this
serverURI
)
;
this
.
_startObservers
(
)
;
return
this
.
_dropExpiredRegistrations
(
)
;
}
_stopService
:
function
(
event
)
{
console
.
debug
(
"
stopService
(
)
"
)
;
if
(
this
.
_state
<
PUSH_SERVICE_ACTIVATING
)
{
return
;
}
this
.
stopAlarm
(
)
;
this
.
_stopObservers
(
)
;
if
(
event
!
=
CHANGING_SERVICE_EVENT
)
{
let
ppmm
=
Cc
[
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
]
.
getService
(
Ci
.
nsIMessageBroadcaster
)
;
kCHILD_PROCESS_MESSAGES
.
forEach
(
msgName
=
>
ppmm
.
removeMessageListener
(
msgName
this
)
)
;
}
this
.
_service
.
disconnect
(
)
;
this
.
_service
.
uninit
(
)
;
this
.
_service
=
null
;
this
.
stopAlarm
(
)
;
if
(
!
this
.
_db
)
{
return
Promise
.
resolve
(
)
;
}
if
(
event
=
=
UNINIT_EVENT
)
{
this
.
_db
.
close
(
)
;
this
.
_db
=
null
;
return
Promise
.
resolve
(
)
;
}
return
this
.
dropUnexpiredRegistrations
(
)
.
then
(
_
=
>
{
this
.
_db
.
close
(
)
;
this
.
_db
=
null
;
}
err
=
>
{
this
.
_db
.
close
(
)
;
this
.
_db
=
null
;
}
)
;
}
_stopObservers
:
function
(
)
{
console
.
debug
(
"
stopObservers
(
)
"
)
;
if
(
this
.
_state
<
PUSH_SERVICE_ACTIVATING
)
{
return
;
}
prefs
.
ignore
(
"
connection
.
enabled
"
this
)
;
Services
.
obs
.
removeObserver
(
this
this
.
_networkStateChangeEventName
)
;
Services
.
obs
.
removeObserver
(
this
"
clear
-
origin
-
data
"
)
;
Services
.
obs
.
removeObserver
(
this
"
idle
-
daily
"
)
;
Services
.
obs
.
removeObserver
(
this
"
perm
-
changed
"
)
;
}
uninit
:
function
(
)
{
console
.
debug
(
"
uninit
(
)
"
)
;
this
.
_childListeners
=
[
]
;
if
(
this
.
_state
=
=
PUSH_SERVICE_UNINIT
)
{
return
;
}
this
.
_setState
(
PUSH_SERVICE_UNINIT
)
;
prefs
.
ignore
(
"
serverURL
"
this
)
;
Services
.
obs
.
removeObserver
(
this
"
xpcom
-
shutdown
"
)
;
this
.
_stateChangeProcessEnqueue
(
_
=
>
this
.
_changeServerURL
(
"
"
UNINIT_EVENT
)
)
;
console
.
debug
(
"
uninit
:
shutdown
complete
!
"
)
;
}
setAlarm
:
function
(
delay
)
{
if
(
this
.
_settingAlarm
)
{
this
.
_queuedAlarmDelay
=
delay
;
this
.
_waitingForAlarmSet
=
true
;
return
;
}
this
.
stopAlarm
(
)
;
this
.
_settingAlarm
=
true
;
AlarmService
.
add
(
{
date
:
new
Date
(
Date
.
now
(
)
+
delay
)
ignoreTimezone
:
true
}
(
)
=
>
{
if
(
this
.
_state
>
PUSH_SERVICE_ACTIVATING
)
{
this
.
_service
.
onAlarmFired
(
)
;
}
}
(
alarmID
)
=
>
{
this
.
_alarmID
=
alarmID
;
console
.
debug
(
"
setAlarm
:
Set
alarm
"
delay
"
in
the
future
"
this
.
_alarmID
)
;
this
.
_settingAlarm
=
false
;
if
(
this
.
_waitingForAlarmSet
)
{
this
.
_waitingForAlarmSet
=
false
;
this
.
setAlarm
(
this
.
_queuedAlarmDelay
)
;
}
}
)
;
}
stopAlarm
:
function
(
)
{
if
(
this
.
_alarmID
!
=
=
null
)
{
console
.
debug
(
"
stopAlarm
:
Stopped
existing
alarm
"
this
.
_alarmID
)
;
AlarmService
.
remove
(
this
.
_alarmID
)
;
this
.
_alarmID
=
null
;
}
}
dropUnexpiredRegistrations
:
function
(
)
{
let
subscriptionChanges
=
[
]
;
return
this
.
_db
.
clearIf
(
record
=
>
{
if
(
record
.
isExpired
(
)
)
{
return
false
;
}
subscriptionChanges
.
push
(
record
)
;
return
true
;
}
)
.
then
(
(
)
=
>
{
this
.
notifySubscriptionChanges
(
subscriptionChanges
)
;
}
)
;
}
_notifySubscriptionChangeObservers
:
function
(
record
)
{
if
(
!
record
)
{
return
;
}
Services
.
obs
.
notifyObservers
(
null
"
push
-
subscription
-
change
"
record
.
scope
)
;
let
data
=
{
originAttributes
:
record
.
originAttributes
scope
:
record
.
scope
}
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_NOTIFY_REGISTRATION_LOST
"
)
.
add
(
)
;
this
.
_notifyListeners
(
'
pushsubscriptionchange
'
data
)
;
}
_notifyListeners
:
function
(
name
data
)
{
if
(
this
.
_childListeners
.
length
>
0
)
{
for
(
var
i
=
this
.
_childListeners
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
try
{
this
.
_childListeners
[
i
]
.
sendAsyncMessage
(
name
data
)
;
}
catch
(
e
)
{
this
.
_childListeners
.
splice
(
i
1
)
;
}
}
}
else
{
let
ppmm
=
Cc
[
'
mozilla
.
org
/
parentprocessmessagemanager
;
1
'
]
.
getService
(
Ci
.
nsIMessageListenerManager
)
;
ppmm
.
broadcastAsyncMessage
(
name
data
)
;
}
}
dropRegistrationAndNotifyApp
:
function
(
aKeyID
)
{
return
this
.
_db
.
delete
(
aKeyID
)
.
then
(
record
=
>
this
.
_notifySubscriptionChangeObservers
(
record
)
)
;
}
updateRegistrationAndNotifyApp
:
function
(
aOldKey
aNewRecord
)
{
return
this
.
updateRecordAndNotifyApp
(
aOldKey
_
=
>
aNewRecord
)
;
}
updateRecordAndNotifyApp
:
function
(
aKeyID
aUpdateFunc
)
{
return
this
.
_db
.
update
(
aKeyID
aUpdateFunc
)
.
then
(
record
=
>
{
this
.
_notifySubscriptionChangeObservers
(
record
)
;
return
record
;
}
)
;
}
notifySubscriptionChanges
:
function
(
records
)
{
records
.
forEach
(
record
=
>
{
this
.
_notifySubscriptionChangeObservers
(
record
)
;
}
)
;
}
ensureCrypto
:
function
(
record
)
{
if
(
record
.
authenticationSecret
&
&
record
.
p256dhPublicKey
&
&
record
.
p256dhPrivateKey
)
{
return
Promise
.
resolve
(
record
)
;
}
let
keygen
=
Promise
.
resolve
(
[
]
)
;
if
(
!
record
.
p256dhPublicKey
|
|
!
record
.
p256dhPrivateKey
)
{
keygen
=
PushCrypto
.
generateKeys
(
)
;
}
return
keygen
.
then
(
(
[
pubKey
privKey
]
)
=
>
{
return
this
.
updateRecordAndNotifyApp
(
record
.
keyID
record
=
>
{
if
(
!
record
.
p256dhPublicKey
|
|
!
record
.
p256dhPrivateKey
)
{
record
.
p256dhPublicKey
=
pubKey
;
record
.
p256dhPrivateKey
=
privKey
;
}
if
(
!
record
.
authenticationSecret
)
{
record
.
authenticationSecret
=
PushCrypto
.
generateAuthenticationSecret
(
)
;
}
return
record
;
}
)
;
}
error
=
>
{
return
this
.
dropRegistrationAndNotifyApp
(
record
.
keyID
)
.
then
(
(
)
=
>
Promise
.
reject
(
error
)
)
;
}
)
;
}
_recordDidNotNotify
:
function
(
reason
)
{
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_NOTIFICATION_RECEIVED_BUT_DID_NOT_NOTIFY
"
)
.
add
(
reason
)
;
}
receivedPushMessage
:
function
(
keyID
message
cryptoParams
updateFunc
)
{
console
.
debug
(
"
receivedPushMessage
(
)
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_NOTIFICATION_RECEIVED
"
)
.
add
(
)
;
let
shouldNotify
=
false
;
return
this
.
getByKeyID
(
keyID
)
.
then
(
record
=
>
{
if
(
!
record
)
{
this
.
_recordDidNotNotify
(
kDROP_NOTIFICATION_REASON_KEY_NOT_FOUND
)
;
throw
new
Error
(
"
No
record
for
key
ID
"
+
keyID
)
;
}
return
record
.
getLastVisit
(
)
;
}
)
.
then
(
lastVisit
=
>
{
shouldNotify
=
isFinite
(
lastVisit
)
;
if
(
!
shouldNotify
)
{
this
.
_recordDidNotNotify
(
kDROP_NOTIFICATION_REASON_NO_HISTORY
)
;
}
return
this
.
_db
.
update
(
keyID
record
=
>
{
let
newRecord
=
updateFunc
(
record
)
;
if
(
!
newRecord
)
{
this
.
_recordDidNotNotify
(
kDROP_NOTIFICATION_REASON_NO_VERSION_INCREMENT
)
;
return
null
;
}
if
(
newRecord
.
isExpired
(
)
)
{
console
.
error
(
"
receivedPushMessage
:
Ignoring
update
for
expired
key
ID
"
keyID
)
;
return
null
;
}
newRecord
.
receivedPush
(
lastVisit
)
;
return
newRecord
;
}
)
;
}
)
.
then
(
record
=
>
{
var
notified
=
false
;
if
(
!
record
)
{
return
notified
;
}
let
decodedPromise
;
if
(
cryptoParams
)
{
decodedPromise
=
PushCrypto
.
decodeMsg
(
message
record
.
p256dhPrivateKey
record
.
p256dhPublicKey
cryptoParams
.
dh
cryptoParams
.
salt
cryptoParams
.
rs
cryptoParams
.
auth
?
record
.
authenticationSecret
:
null
)
;
}
else
{
decodedPromise
=
Promise
.
resolve
(
null
)
;
}
return
decodedPromise
.
then
(
message
=
>
{
if
(
shouldNotify
)
{
notified
=
this
.
_notifyApp
(
record
message
)
;
}
setTimeout
(
(
)
=
>
this
.
_updateQuota
(
keyID
)
prefs
.
get
(
"
quotaUpdateDelay
"
)
)
;
return
notified
;
}
error
=
>
{
console
.
error
(
"
receivedPushMessage
:
Error
decrypting
message
"
error
)
;
}
)
;
}
)
.
catch
(
error
=
>
{
console
.
error
(
"
receivedPushMessage
:
Error
notifying
app
"
error
)
;
}
)
;
}
_updateQuota
:
function
(
keyID
)
{
console
.
debug
(
"
updateQuota
(
)
"
)
;
this
.
_db
.
update
(
keyID
record
=
>
{
if
(
record
.
isExpired
(
)
)
{
console
.
debug
(
"
updateQuota
:
Trying
to
update
quota
for
expired
record
"
record
)
;
return
null
;
}
if
(
!
this
.
_visibleNotifications
.
has
(
record
.
uri
.
prePath
)
)
{
record
.
reduceQuota
(
)
;
}
return
record
;
}
)
.
then
(
record
=
>
{
if
(
record
&
&
record
.
isExpired
(
)
)
{
this
.
_recordDidNotNotify
(
kDROP_NOTIFICATION_REASON_EXPIRED
)
;
this
.
_backgroundUnregister
(
record
)
;
}
if
(
this
.
_updateQuotaTestCallback
)
{
this
.
_updateQuotaTestCallback
(
)
;
}
}
)
.
catch
(
error
=
>
{
console
.
debug
(
"
updateQuota
:
Error
while
trying
to
update
quota
"
error
)
;
}
)
;
}
_notificationForOriginShown
(
origin
)
{
console
.
debug
(
"
notificationForOriginShown
(
)
"
origin
)
;
let
count
;
if
(
this
.
_visibleNotifications
.
has
(
origin
)
)
{
count
=
this
.
_visibleNotifications
.
get
(
origin
)
;
}
else
{
count
=
0
;
}
this
.
_visibleNotifications
.
set
(
origin
count
+
1
)
;
}
_notificationForOriginClosed
(
origin
)
{
console
.
debug
(
"
notificationForOriginClosed
(
)
"
origin
)
;
let
count
;
if
(
this
.
_visibleNotifications
.
has
(
origin
)
)
{
count
=
this
.
_visibleNotifications
.
get
(
origin
)
;
}
else
{
console
.
debug
(
"
notificationForOriginClosed
:
closing
notification
that
has
not
been
shown
?
"
)
;
return
;
}
if
(
count
>
1
)
{
this
.
_visibleNotifications
.
set
(
origin
count
-
1
)
;
}
else
{
this
.
_visibleNotifications
.
delete
(
origin
)
;
}
}
_notifyApp
:
function
(
aPushRecord
message
)
{
if
(
!
aPushRecord
|
|
!
aPushRecord
.
scope
|
|
aPushRecord
.
originAttributes
=
=
=
undefined
)
{
console
.
error
(
"
notifyApp
:
Invalid
record
"
aPushRecord
)
;
return
false
;
}
console
.
debug
(
"
notifyApp
(
)
"
aPushRecord
.
scope
)
;
let
notification
=
Cc
[
"
mozilla
.
org
/
push
/
ObserverNotification
;
1
"
]
.
createInstance
(
Ci
.
nsIPushObserverNotification
)
;
notification
.
pushEndpoint
=
aPushRecord
.
pushEndpoint
;
notification
.
version
=
aPushRecord
.
version
;
let
payload
=
ArrayBuffer
.
isView
(
message
)
?
new
Uint8Array
(
message
.
buffer
)
:
message
;
if
(
payload
)
{
notification
.
data
=
"
"
;
for
(
let
i
=
0
;
i
<
payload
.
length
;
i
+
+
)
{
notification
.
data
+
=
String
.
fromCharCode
(
payload
[
i
]
)
;
}
}
notification
.
lastPush
=
aPushRecord
.
lastPush
;
notification
.
pushCount
=
aPushRecord
.
pushCount
;
Services
.
obs
.
notifyObservers
(
notification
"
push
-
notification
"
aPushRecord
.
scope
)
;
if
(
!
aPushRecord
.
hasPermission
(
)
)
{
console
.
warn
(
"
notifyApp
:
Missing
push
permission
"
aPushRecord
)
;
return
false
;
}
let
data
=
{
payload
:
payload
originAttributes
:
aPushRecord
.
originAttributes
scope
:
aPushRecord
.
scope
}
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_NOTIFY
"
)
.
add
(
)
;
this
.
_notifyListeners
(
'
push
'
data
)
;
return
true
;
}
getByKeyID
:
function
(
aKeyID
)
{
return
this
.
_db
.
getByKeyID
(
aKeyID
)
;
}
getAllUnexpired
:
function
(
)
{
return
this
.
_db
.
getAllUnexpired
(
)
;
}
_sendRequest
:
function
(
action
aRecord
)
{
if
(
this
.
_state
=
=
PUSH_SERVICE_CONNECTION_DISABLE
)
{
return
Promise
.
reject
(
new
Error
(
"
Push
service
disabled
"
)
)
;
}
else
if
(
this
.
_state
=
=
PUSH_SERVICE_ACTIVE_OFFLINE
)
{
if
(
this
.
_service
.
serviceType
(
)
=
=
"
WebSocket
"
&
&
action
=
=
"
unregister
"
)
{
return
Promise
.
resolve
(
)
;
}
return
Promise
.
reject
(
new
Error
(
"
Push
service
offline
"
)
)
;
}
return
this
.
_service
.
request
(
action
aRecord
)
;
}
_registerWithServer
:
function
(
aPageRecord
)
{
console
.
debug
(
"
registerWithServer
(
)
"
aPageRecord
)
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_SUBSCRIBE_ATTEMPT
"
)
.
add
(
)
;
return
this
.
_sendRequest
(
"
register
"
aPageRecord
)
.
then
(
record
=
>
this
.
_onRegisterSuccess
(
record
)
err
=
>
this
.
_onRegisterError
(
err
)
)
.
then
(
record
=
>
{
this
.
_deletePendingRequest
(
aPageRecord
)
;
return
record
.
toSubscription
(
)
;
}
err
=
>
{
this
.
_deletePendingRequest
(
aPageRecord
)
;
throw
err
;
}
)
;
}
_sendUnregister
:
function
(
aRecord
)
{
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_UNSUBSCRIBE_ATTEMPT
"
)
.
add
(
)
;
return
this
.
_sendRequest
(
"
unregister
"
aRecord
)
.
then
(
function
(
v
)
{
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_UNSUBSCRIBE_SUCCEEDED
"
)
.
add
(
)
;
return
v
;
}
)
.
catch
(
function
(
e
)
{
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_UNSUBSCRIBE_FAILED
"
)
.
add
(
)
;
return
Promise
.
reject
(
e
)
;
}
)
;
}
_onRegisterSuccess
:
function
(
aRecord
)
{
console
.
debug
(
"
_onRegisterSuccess
(
)
"
)
;
return
this
.
_db
.
put
(
aRecord
)
.
then
(
record
=
>
{
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_SUBSCRIBE_SUCCEEDED
"
)
.
add
(
)
;
return
record
;
}
)
.
catch
(
error
=
>
{
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_SUBSCRIBE_FAILED
"
)
.
add
(
)
this
.
_backgroundUnregister
(
aRecord
)
;
throw
error
;
}
)
;
}
_onRegisterError
:
function
(
reply
)
{
console
.
debug
(
"
_onRegisterError
(
)
"
)
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_SUBSCRIBE_FAILED
"
)
.
add
(
)
if
(
!
reply
.
error
)
{
console
.
warn
(
"
onRegisterError
:
Called
without
valid
error
message
!
"
reply
.
error
)
;
throw
new
Error
(
"
Registration
error
"
)
;
}
throw
reply
.
error
;
}
receiveMessage
:
function
(
aMessage
)
{
console
.
debug
(
"
receiveMessage
(
)
"
aMessage
.
name
)
;
if
(
kCHILD_PROCESS_MESSAGES
.
indexOf
(
aMessage
.
name
)
=
=
-
1
)
{
console
.
debug
(
"
receiveMessage
:
Invalid
message
from
child
"
aMessage
.
name
)
;
return
;
}
if
(
aMessage
.
name
=
=
=
"
Push
:
RegisterEventNotificationListener
"
)
{
console
.
debug
(
"
receiveMessage
:
Adding
child
listener
"
)
;
this
.
_childListeners
.
push
(
aMessage
.
target
)
;
return
;
}
if
(
aMessage
.
name
=
=
=
"
child
-
process
-
shutdown
"
)
{
console
.
debug
(
"
receiveMessage
:
Possibly
removing
child
listener
"
)
;
for
(
var
i
=
this
.
_childListeners
.
length
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
this
.
_childListeners
[
i
]
=
=
aMessage
.
target
)
{
console
.
debug
(
"
receiveMessage
:
Removed
child
listener
"
)
;
this
.
_childListeners
.
splice
(
i
1
)
;
}
}
console
.
debug
(
"
receiveMessage
:
Clearing
notifications
from
child
"
)
;
this
.
_visibleNotifications
.
clear
(
)
;
return
;
}
if
(
aMessage
.
name
=
=
=
"
Push
:
NotificationForOriginShown
"
)
{
console
.
debug
(
"
receiveMessage
:
Notification
shown
from
child
"
)
;
this
.
_notificationForOriginShown
(
aMessage
.
data
)
;
return
;
}
if
(
aMessage
.
name
=
=
=
"
Push
:
NotificationForOriginClosed
"
)
{
console
.
debug
(
"
receiveMessage
:
Notification
closed
from
child
"
)
;
this
.
_notificationForOriginClosed
(
aMessage
.
data
)
;
return
;
}
if
(
!
aMessage
.
target
.
assertPermission
(
"
push
"
)
)
{
console
.
debug
(
"
receiveMessage
:
Got
message
from
a
child
process
that
"
"
does
not
have
'
push
'
permission
"
)
;
return
null
;
}
let
mm
=
aMessage
.
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
let
name
=
aMessage
.
name
.
slice
(
"
Push
:
"
.
length
)
;
Promise
.
resolve
(
)
.
then
(
_
=
>
{
let
pageRecord
=
this
.
_validatePageRecord
(
aMessage
)
;
return
this
[
name
.
toLowerCase
(
)
]
(
pageRecord
)
;
}
)
.
then
(
result
=
>
{
mm
.
sendAsyncMessage
(
"
PushService
:
"
+
name
+
"
:
OK
"
{
requestID
:
aMessage
.
data
.
requestID
result
:
result
}
)
;
}
error
=
>
{
console
.
error
(
"
receiveMessage
:
Error
handling
message
"
aMessage
error
)
;
mm
.
sendAsyncMessage
(
"
PushService
:
"
+
name
+
"
:
KO
"
{
requestID
:
aMessage
.
data
.
requestID
}
)
;
}
)
.
catch
(
error
=
>
{
console
.
error
(
"
receiveMessage
:
Error
sending
reply
"
error
)
;
}
)
;
}
_validatePageRecord
:
function
(
aMessage
)
{
let
principal
=
aMessage
.
principal
;
if
(
!
principal
)
{
throw
new
Error
(
"
Missing
message
principal
"
)
;
}
let
pageRecord
=
aMessage
.
data
;
if
(
!
pageRecord
.
scope
)
{
throw
new
Error
(
"
Missing
page
record
scope
"
)
;
}
pageRecord
.
originAttributes
=
ChromeUtils
.
originAttributesToSuffix
(
principal
.
originAttributes
)
;
return
pageRecord
;
}
register
:
function
(
aPageRecord
)
{
console
.
debug
(
"
register
(
)
"
aPageRecord
)
;
if
(
!
aPageRecord
.
scope
|
|
aPageRecord
.
originAttributes
=
=
=
undefined
)
{
return
Promise
.
reject
(
new
Error
(
"
Invalid
page
record
"
)
)
;
}
return
this
.
_checkActivated
(
)
.
then
(
_
=
>
this
.
_db
.
getByIdentifiers
(
aPageRecord
)
)
.
then
(
record
=
>
{
if
(
!
record
)
{
return
this
.
_lookupOrPutPendingRequest
(
aPageRecord
)
;
}
if
(
record
.
isExpired
(
)
)
{
return
record
.
quotaChanged
(
)
.
then
(
isChanged
=
>
{
if
(
isChanged
)
{
return
this
.
dropRegistrationAndNotifyApp
(
record
.
keyID
)
;
}
throw
new
Error
(
"
Push
subscription
expired
"
)
;
}
)
.
then
(
_
=
>
this
.
_lookupOrPutPendingRequest
(
aPageRecord
)
)
;
}
return
record
.
toSubscription
(
)
;
}
)
;
}
unregister
:
function
(
aPageRecord
)
{
console
.
debug
(
"
unregister
(
)
"
aPageRecord
)
;
if
(
!
aPageRecord
.
scope
|
|
aPageRecord
.
originAttributes
=
=
=
undefined
)
{
return
Promise
.
reject
(
new
Error
(
"
Invalid
page
record
"
)
)
;
}
return
this
.
_checkActivated
(
)
.
then
(
_
=
>
this
.
_db
.
getByIdentifiers
(
aPageRecord
)
)
.
then
(
record
=
>
{
if
(
record
=
=
=
undefined
)
{
return
false
;
}
return
Promise
.
all
(
[
this
.
_sendUnregister
(
record
)
this
.
_db
.
delete
(
record
.
keyID
)
]
)
.
then
(
(
)
=
>
true
)
;
}
)
;
}
_clearAll
:
function
_clearAll
(
)
{
return
this
.
_checkActivated
(
)
.
then
(
_
=
>
this
.
_db
.
drop
(
)
)
.
catch
(
_
=
>
Promise
.
resolve
(
)
)
;
}
_clearForDomain
:
function
(
domain
)
{
function
hasRootDomain
(
str
aDomain
)
{
let
index
=
str
.
indexOf
(
aDomain
)
;
if
(
index
=
=
-
1
)
return
false
;
if
(
str
=
=
aDomain
)
return
true
;
let
prevChar
=
str
[
index
-
1
]
;
return
(
index
=
=
(
str
.
length
-
aDomain
.
length
)
)
&
&
(
prevChar
=
=
"
.
"
|
|
prevChar
=
=
"
/
"
)
;
}
let
clear
=
(
db
domain
)
=
>
{
db
.
clearIf
(
record
=
>
{
return
hasRootDomain
(
record
.
uri
.
prePath
domain
)
;
}
)
;
}
return
this
.
_checkActivated
(
)
.
then
(
_
=
>
clear
(
this
.
_db
domain
)
)
.
catch
(
e
=
>
{
console
.
warn
(
"
clearForDomain
:
Error
forgetting
about
domain
"
e
)
;
return
Promise
.
resolve
(
)
;
}
)
;
}
registration
:
function
(
aPageRecord
)
{
console
.
debug
(
"
registration
(
)
"
)
;
if
(
!
aPageRecord
.
scope
|
|
aPageRecord
.
originAttributes
=
=
=
undefined
)
{
return
Promise
.
reject
(
new
Error
(
"
Invalid
page
record
"
)
)
;
}
return
this
.
_checkActivated
(
)
.
then
(
_
=
>
this
.
_db
.
getByIdentifiers
(
aPageRecord
)
)
.
then
(
record
=
>
{
if
(
!
record
)
{
return
null
;
}
if
(
record
.
isExpired
(
)
)
{
return
record
.
quotaChanged
(
)
.
then
(
isChanged
=
>
{
if
(
isChanged
)
{
return
this
.
dropRegistrationAndNotifyApp
(
record
.
keyID
)
.
then
(
_
=
>
null
)
;
}
return
null
;
}
)
;
}
return
record
.
toSubscription
(
)
;
}
)
;
}
_dropExpiredRegistrations
:
function
(
)
{
console
.
debug
(
"
dropExpiredRegistrations
(
)
"
)
;
return
this
.
_db
.
getAllExpired
(
)
.
then
(
records
=
>
{
return
Promise
.
all
(
records
.
map
(
record
=
>
record
.
quotaChanged
(
)
.
then
(
isChanged
=
>
{
if
(
isChanged
)
{
return
this
.
dropRegistrationAndNotifyApp
(
record
.
keyID
)
;
}
}
)
.
catch
(
error
=
>
{
console
.
error
(
"
dropExpiredRegistrations
:
Error
dropping
registration
"
record
.
keyID
error
)
;
}
)
)
)
;
}
)
;
}
_onPermissionChange
:
function
(
subject
data
)
{
console
.
debug
(
"
onPermissionChange
(
)
"
)
;
if
(
data
=
=
"
cleared
"
)
{
return
this
.
_db
.
clearIf
(
record
=
>
{
if
(
record
.
quotaApplies
(
)
)
{
if
(
!
record
.
isExpired
(
)
)
{
this
.
_backgroundUnregister
(
record
)
;
}
return
true
;
}
return
false
;
}
)
;
}
let
permission
=
subject
.
QueryInterface
(
Ci
.
nsIPermission
)
;
if
(
permission
.
type
!
=
"
desktop
-
notification
"
)
{
return
Promise
.
resolve
(
)
;
}
return
this
.
_updatePermission
(
permission
data
)
;
}
_updatePermission
:
function
(
permission
type
)
{
console
.
debug
(
"
updatePermission
(
)
"
)
;
let
isAllow
=
permission
.
capability
=
=
Ci
.
nsIPermissionManager
.
ALLOW_ACTION
;
let
isChange
=
type
=
=
"
added
"
|
|
type
=
=
"
changed
"
;
if
(
isAllow
&
&
isChange
)
{
return
this
.
_reduceByPrincipal
(
permission
.
principal
(
subscriptionChanges
record
cursor
)
=
>
{
this
.
_permissionAllowed
(
subscriptionChanges
record
cursor
)
;
return
subscriptionChanges
;
}
[
]
)
.
then
(
subscriptionChanges
=
>
{
this
.
notifySubscriptionChanges
(
subscriptionChanges
)
;
}
)
;
}
else
if
(
isChange
|
|
(
isAllow
&
&
type
=
=
"
deleted
"
)
)
{
return
this
.
_reduceByPrincipal
(
permission
.
principal
(
memo
record
cursor
)
=
>
this
.
_permissionDenied
(
record
cursor
)
)
;
}
return
Promise
.
resolve
(
)
;
}
_reduceByPrincipal
:
function
(
principal
callback
initialValue
)
{
return
this
.
_db
.
reduceByOrigin
(
principal
.
URI
.
prePath
ChromeUtils
.
originAttributesToSuffix
(
principal
.
originAttributes
)
callback
initialValue
)
;
}
_permissionDenied
:
function
(
record
cursor
)
{
console
.
debug
(
"
permissionDenied
(
)
"
)
;
if
(
!
record
.
quotaApplies
(
)
|
|
record
.
isExpired
(
)
)
{
return
;
}
this
.
_backgroundUnregister
(
record
)
;
record
.
setQuota
(
0
)
;
cursor
.
update
(
record
)
;
}
_permissionAllowed
:
function
(
subscriptionChanges
record
cursor
)
{
console
.
debug
(
"
permissionAllowed
(
)
"
)
;
if
(
!
record
.
quotaApplies
(
)
)
{
return
;
}
if
(
record
.
isExpired
(
)
)
{
subscriptionChanges
.
push
(
record
)
;
cursor
.
delete
(
)
;
return
;
}
record
.
resetQuota
(
)
;
cursor
.
update
(
record
)
;
}
}
;
