"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
PushDB
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushDB
.
jsm
"
)
;
const
{
PushRecord
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushRecord
.
jsm
"
)
;
const
{
PushCrypto
getCryptoParams
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushCrypto
.
jsm
"
)
;
if
(
AppConstants
.
MOZ_B2G
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gPowerManagerService
"
"
mozilla
.
org
/
power
/
powermanagerservice
;
1
"
"
nsIPowerManagerService
"
)
;
}
const
kPUSHWSDB_DB_NAME
=
"
pushapi
"
;
const
kPUSHWSDB_DB_VERSION
=
5
;
const
kPUSHWSDB_STORE_NAME
=
"
pushapi
"
;
const
kBACKOFF_WS_STATUS_CODE
=
4774
;
const
kACK_STATUS_TO_CODE
=
{
[
Ci
.
nsIPushErrorReporter
.
ACK_DELIVERED
]
:
100
[
Ci
.
nsIPushErrorReporter
.
ACK_DECRYPTION_ERROR
]
:
101
[
Ci
.
nsIPushErrorReporter
.
ACK_NOT_DELIVERED
]
:
102
}
;
const
kUNREGISTER_REASON_TO_CODE
=
{
[
Ci
.
nsIPushErrorReporter
.
UNSUBSCRIBE_MANUAL
]
:
200
[
Ci
.
nsIPushErrorReporter
.
UNSUBSCRIBE_QUOTA_EXCEEDED
]
:
201
[
Ci
.
nsIPushErrorReporter
.
UNSUBSCRIBE_PERMISSION_REVOKED
]
:
202
}
;
const
kDELIVERY_REASON_TO_CODE
=
{
[
Ci
.
nsIPushErrorReporter
.
DELIVERY_UNCAUGHT_EXCEPTION
]
:
301
[
Ci
.
nsIPushErrorReporter
.
DELIVERY_UNHANDLED_REJECTION
]
:
302
[
Ci
.
nsIPushErrorReporter
.
DELIVERY_INTERNAL_ERROR
]
:
303
}
;
const
prefs
=
new
Preferences
(
"
dom
.
push
.
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
PushServiceWebSocket
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
dom
.
push
.
loglevel
"
prefix
:
"
PushServiceWebSocket
"
}
)
;
}
)
;
var
PushWebSocketListener
=
function
(
pushService
)
{
this
.
_pushService
=
pushService
;
}
;
PushWebSocketListener
.
prototype
=
{
onStart
:
function
(
context
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnStart
(
context
)
;
}
onStop
:
function
(
context
statusCode
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnStop
(
context
statusCode
)
;
}
onAcknowledge
:
function
(
context
size
)
{
}
onBinaryMessageAvailable
:
function
(
context
message
)
{
}
onMessageAvailable
:
function
(
context
message
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnMessageAvailable
(
context
message
)
;
}
onServerClose
:
function
(
context
aStatusCode
aReason
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnServerClose
(
context
aStatusCode
aReason
)
;
}
}
;
const
STATE_SHUT_DOWN
=
0
;
const
STATE_WAITING_FOR_WS_START
=
1
;
const
STATE_WAITING_FOR_HELLO
=
2
;
const
STATE_READY
=
3
;
this
.
PushServiceWebSocket
=
{
_mainPushService
:
null
_serverURI
:
null
newPushDB
:
function
(
)
{
return
new
PushDB
(
kPUSHWSDB_DB_NAME
kPUSHWSDB_DB_VERSION
kPUSHWSDB_STORE_NAME
"
channelID
"
PushRecordWebSocket
)
;
}
serviceType
:
function
(
)
{
return
"
WebSocket
"
;
}
disconnect
:
function
(
)
{
this
.
_shutdownWS
(
)
;
}
observe
:
function
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
&
&
aData
=
=
"
dom
.
push
.
userAgentID
"
)
{
this
.
_onUAIDChanged
(
)
;
}
else
if
(
aTopic
=
=
"
timer
-
callback
"
)
{
this
.
_onTimerFired
(
aSubject
)
;
}
}
_onUAIDChanged
(
)
{
console
.
debug
(
"
onUAIDChanged
(
)
"
)
;
this
.
_shutdownWS
(
)
;
this
.
_startBackoffTimer
(
)
;
}
_onTimerFired
(
timer
)
{
console
.
debug
(
"
onTimerFired
(
)
"
)
;
if
(
timer
=
=
this
.
_pingTimer
)
{
this
.
_sendPing
(
)
;
return
;
}
if
(
timer
=
=
this
.
_backoffTimer
)
{
console
.
debug
(
"
onTimerFired
:
Reconnecting
after
backoff
"
)
;
this
.
_beginWSSetup
(
)
;
return
;
}
if
(
timer
=
=
this
.
_requestTimeoutTimer
)
{
this
.
_timeOutRequests
(
)
;
return
;
}
}
_sendPing
(
)
{
console
.
debug
(
"
sendPing
(
)
"
)
;
this
.
_startRequestTimeoutTimer
(
)
;
try
{
this
.
_wsSendMessage
(
{
}
)
;
this
.
_lastPingTime
=
Date
.
now
(
)
;
}
catch
(
e
)
{
console
.
debug
(
"
sendPing
:
Error
sending
ping
"
e
)
;
this
.
_reconnect
(
)
;
}
}
_timeOutRequests
(
)
{
console
.
debug
(
"
timeOutRequests
(
)
"
)
;
if
(
!
this
.
_hasPendingRequests
(
)
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
return
;
}
let
now
=
Date
.
now
(
)
;
let
requestTimedOut
=
false
;
if
(
this
.
_lastPingTime
>
0
&
&
now
-
this
.
_lastPingTime
>
this
.
_requestTimeout
)
{
console
.
debug
(
"
timeOutRequests
:
Did
not
receive
pong
in
time
"
)
;
requestTimedOut
=
true
;
}
else
{
for
(
let
[
channelID
request
]
of
this
.
_registerRequests
)
{
let
duration
=
now
-
request
.
ctime
;
requestTimedOut
|
=
duration
>
this
.
_requestTimeout
;
if
(
requestTimedOut
)
{
request
.
reject
(
new
Error
(
"
Register
request
timed
out
for
channel
ID
"
+
channelID
)
)
;
this
.
_registerRequests
.
delete
(
channelID
)
;
}
}
}
if
(
requestTimedOut
)
{
this
.
_reconnect
(
)
;
}
}
validServerURI
:
function
(
serverURI
)
{
if
(
serverURI
.
scheme
=
=
"
ws
"
)
{
return
!
!
prefs
.
get
(
"
testing
.
allowInsecureServerURL
"
)
;
}
return
serverURI
.
scheme
=
=
"
wss
"
;
}
get
_UAID
(
)
{
return
prefs
.
get
(
"
userAgentID
"
)
;
}
set
_UAID
(
newID
)
{
if
(
typeof
(
newID
)
!
=
=
"
string
"
)
{
console
.
warn
(
"
Got
invalid
non
-
string
UAID
"
newID
"
Not
updating
userAgentID
"
)
;
return
;
}
console
.
debug
(
"
New
_UAID
"
newID
)
;
prefs
.
set
(
"
userAgentID
"
newID
)
;
}
_ws
:
null
_registerRequests
:
new
Map
(
)
_currentState
:
STATE_SHUT_DOWN
_requestTimeout
:
0
_requestTimeoutTimer
:
null
_retryFailCount
:
0
_skipReconnect
:
false
_dataEnabled
:
false
_lastPingTime
:
0
_pingTimer
:
null
_backoffTimer
:
null
_wsSendMessage
:
function
(
msg
)
{
if
(
!
this
.
_ws
)
{
console
.
warn
(
"
wsSendMessage
:
No
WebSocket
initialized
.
"
"
Cannot
send
a
message
"
)
;
return
;
}
msg
=
JSON
.
stringify
(
msg
)
;
console
.
debug
(
"
wsSendMessage
:
Sending
message
"
msg
)
;
this
.
_ws
.
sendMsg
(
msg
)
;
}
init
:
function
(
options
mainPushService
serverURI
)
{
console
.
debug
(
"
init
(
)
"
)
;
this
.
_mainPushService
=
mainPushService
;
this
.
_serverURI
=
serverURI
;
if
(
options
.
makeWebSocket
)
{
this
.
_makeWebSocket
=
options
.
makeWebSocket
;
}
this
.
_requestTimeout
=
prefs
.
get
(
"
requestTimeout
"
)
;
return
Promise
.
resolve
(
)
;
}
_reconnect
:
function
(
)
{
console
.
debug
(
"
reconnect
(
)
"
)
;
this
.
_shutdownWS
(
false
)
;
this
.
_startBackoffTimer
(
)
;
}
_shutdownWS
:
function
(
shouldCancelPending
=
true
)
{
console
.
debug
(
"
shutdownWS
(
)
"
)
;
this
.
_currentState
=
STATE_SHUT_DOWN
;
this
.
_skipReconnect
=
false
;
prefs
.
ignore
(
"
userAgentID
"
this
)
;
if
(
this
.
_wsListener
)
{
this
.
_wsListener
.
_pushService
=
null
;
}
try
{
this
.
_ws
.
close
(
0
null
)
;
}
catch
(
e
)
{
}
this
.
_ws
=
null
;
this
.
_lastPingTime
=
0
;
if
(
this
.
_pingTimer
)
{
this
.
_pingTimer
.
cancel
(
)
;
}
if
(
shouldCancelPending
)
{
this
.
_cancelRegisterRequests
(
)
;
}
if
(
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
}
uninit
:
function
(
)
{
this
.
_shutdownWS
(
)
;
if
(
this
.
_backoffTimer
)
{
this
.
_backoffTimer
.
cancel
(
)
;
}
if
(
this
.
_requestTimeoutTimer
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
}
this
.
_mainPushService
=
null
;
this
.
_dataEnabled
=
false
;
}
_startBackoffTimer
(
)
{
console
.
debug
(
"
startBackoffTimer
(
)
"
)
;
let
retryTimeout
=
prefs
.
get
(
"
retryBaseInterval
"
)
*
Math
.
pow
(
2
this
.
_retryFailCount
)
;
retryTimeout
=
Math
.
min
(
retryTimeout
prefs
.
get
(
"
pingInterval
"
)
)
;
this
.
_retryFailCount
+
+
;
console
.
debug
(
"
startBackoffTimer
:
Retry
in
"
retryTimeout
"
Try
number
"
this
.
_retryFailCount
)
;
if
(
!
this
.
_backoffTimer
)
{
this
.
_backoffTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_backoffTimer
.
init
(
this
retryTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_hasPendingRequests
(
)
{
return
this
.
_lastPingTime
>
0
|
|
this
.
_registerRequests
.
size
>
0
;
}
_startRequestTimeoutTimer
(
)
{
if
(
this
.
_hasPendingRequests
(
)
)
{
return
;
}
if
(
!
this
.
_requestTimeoutTimer
)
{
this
.
_requestTimeoutTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_requestTimeoutTimer
.
init
(
this
this
.
_requestTimeout
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
_startPingTimer
(
)
{
if
(
!
this
.
_pingTimer
)
{
this
.
_pingTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_pingTimer
.
init
(
this
prefs
.
get
(
"
pingInterval
"
)
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_makeWebSocket
:
function
(
uri
)
{
if
(
!
prefs
.
get
(
"
connection
.
enabled
"
)
)
{
console
.
warn
(
"
makeWebSocket
:
connection
.
enabled
is
not
set
to
true
.
"
"
Aborting
.
"
)
;
return
null
;
}
if
(
Services
.
io
.
offline
)
{
console
.
warn
(
"
makeWebSocket
:
Network
is
offline
.
"
)
;
return
null
;
}
let
socket
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
wss
"
]
.
createInstance
(
Ci
.
nsIWebSocketChannel
)
;
socket
.
initLoadInfo
(
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
)
;
return
socket
;
}
_beginWSSetup
:
function
(
)
{
console
.
debug
(
"
beginWSSetup
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_SHUT_DOWN
)
{
console
.
error
(
"
_beginWSSetup
:
Not
in
shutdown
state
!
Current
state
"
this
.
_currentState
)
;
return
;
}
if
(
this
.
_backoffTimer
)
{
this
.
_backoffTimer
.
cancel
(
)
;
}
let
uri
=
this
.
_serverURI
;
if
(
!
uri
)
{
return
;
}
let
socket
=
this
.
_makeWebSocket
(
uri
)
;
if
(
!
socket
)
{
return
;
}
this
.
_ws
=
socket
.
QueryInterface
(
Ci
.
nsIWebSocketChannel
)
;
console
.
debug
(
"
beginWSSetup
:
Connecting
to
"
uri
.
spec
)
;
this
.
_wsListener
=
new
PushWebSocketListener
(
this
)
;
this
.
_ws
.
protocol
=
"
push
-
notification
"
;
try
{
this
.
_ws
.
asyncOpen
(
uri
uri
.
spec
0
this
.
_wsListener
null
)
;
this
.
_acquireWakeLock
(
)
;
this
.
_currentState
=
STATE_WAITING_FOR_WS_START
;
}
catch
(
e
)
{
console
.
error
(
"
beginWSSetup
:
Error
opening
websocket
.
"
"
asyncOpen
failed
"
e
)
;
this
.
_reconnect
(
)
;
}
}
connect
:
function
(
records
)
{
console
.
debug
(
"
connect
(
)
"
)
;
if
(
records
.
length
>
0
)
{
this
.
_beginWSSetup
(
)
;
}
}
isConnected
:
function
(
)
{
return
!
!
this
.
_ws
;
}
_acquireWakeLock
:
function
(
)
{
if
(
!
AppConstants
.
MOZ_B2G
)
{
return
;
}
if
(
!
this
.
_socketWakeLock
)
{
console
.
debug
(
"
acquireWakeLock
:
Acquiring
Socket
Wakelock
"
)
;
this
.
_socketWakeLock
=
gPowerManagerService
.
newWakeLock
(
"
cpu
"
)
;
}
if
(
!
this
.
_socketWakeLockTimer
)
{
console
.
debug
(
"
acquireWakeLock
:
Creating
Socket
WakeLock
Timer
"
)
;
this
.
_socketWakeLockTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
console
.
debug
(
"
acquireWakeLock
:
Setting
Socket
WakeLock
Timer
"
)
;
this
.
_socketWakeLockTimer
.
initWithCallback
(
this
.
_releaseWakeLock
.
bind
(
this
)
this
.
_requestTimeout
+
1000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_releaseWakeLock
:
function
(
)
{
if
(
!
AppConstants
.
MOZ_B2G
)
{
return
;
}
console
.
debug
(
"
releaseWakeLock
:
Releasing
Socket
WakeLock
"
)
;
if
(
this
.
_socketWakeLockTimer
)
{
this
.
_socketWakeLockTimer
.
cancel
(
)
;
}
if
(
this
.
_socketWakeLock
)
{
this
.
_socketWakeLock
.
unlock
(
)
;
this
.
_socketWakeLock
=
null
;
}
}
_handleHelloReply
:
function
(
reply
)
{
console
.
debug
(
"
handleHelloReply
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_WAITING_FOR_HELLO
)
{
console
.
error
(
"
handleHelloReply
:
Unexpected
state
"
this
.
_currentState
"
(
expected
STATE_WAITING_FOR_HELLO
)
"
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
typeof
reply
.
uaid
!
=
=
"
string
"
)
{
console
.
error
(
"
handleHelloReply
:
Received
invalid
UAID
"
reply
.
uaid
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
reply
.
uaid
=
=
=
"
"
)
{
console
.
error
(
"
handleHelloReply
:
Received
empty
UAID
"
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
reply
.
uaid
.
length
>
128
)
{
console
.
error
(
"
handleHelloReply
:
UAID
received
from
server
was
too
long
"
reply
.
uaid
)
;
this
.
_shutdownWS
(
)
;
return
;
}
let
sendRequests
=
(
)
=
>
{
if
(
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
this
.
_sendRegisterRequests
(
)
;
}
;
function
finishHandshake
(
)
{
this
.
_UAID
=
reply
.
uaid
;
this
.
_currentState
=
STATE_READY
;
prefs
.
observe
(
"
userAgentID
"
this
)
;
this
.
_dataEnabled
=
!
!
reply
.
use_webpush
;
if
(
this
.
_dataEnabled
)
{
this
.
_mainPushService
.
getAllUnexpired
(
)
.
then
(
records
=
>
Promise
.
all
(
records
.
map
(
record
=
>
this
.
_mainPushService
.
ensureCrypto
(
record
)
.
catch
(
error
=
>
{
console
.
error
(
"
finishHandshake
:
Error
updating
record
"
record
.
keyID
error
)
;
}
)
)
)
)
.
then
(
sendRequests
)
;
}
else
{
sendRequests
(
)
;
}
}
if
(
this
.
_UAID
!
=
reply
.
uaid
)
{
console
.
debug
(
"
handleHelloReply
:
Received
new
UAID
"
)
;
this
.
_mainPushService
.
dropUnexpiredRegistrations
(
)
.
then
(
finishHandshake
.
bind
(
this
)
)
;
return
;
}
finishHandshake
.
bind
(
this
)
(
)
;
}
_handleRegisterReply
:
function
(
reply
)
{
console
.
debug
(
"
handleRegisterReply
(
)
"
)
;
if
(
typeof
reply
.
channelID
!
=
=
"
string
"
|
|
!
this
.
_registerRequests
.
has
(
reply
.
channelID
)
)
{
return
;
}
let
tmp
=
this
.
_registerRequests
.
get
(
reply
.
channelID
)
;
this
.
_registerRequests
.
delete
(
reply
.
channelID
)
;
if
(
!
this
.
_hasPendingRequests
(
)
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
}
if
(
reply
.
status
=
=
200
)
{
try
{
Services
.
io
.
newURI
(
reply
.
pushEndpoint
null
null
)
;
}
catch
(
e
)
{
tmp
.
reject
(
new
Error
(
"
Invalid
push
endpoint
:
"
+
reply
.
pushEndpoint
)
)
;
return
;
}
let
record
=
new
PushRecordWebSocket
(
{
channelID
:
reply
.
channelID
pushEndpoint
:
reply
.
pushEndpoint
scope
:
tmp
.
record
.
scope
originAttributes
:
tmp
.
record
.
originAttributes
version
:
null
systemRecord
:
tmp
.
record
.
systemRecord
appServerKey
:
tmp
.
record
.
appServerKey
ctime
:
Date
.
now
(
)
}
)
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_SUBSCRIBE_WS_TIME
"
)
.
add
(
Date
.
now
(
)
-
tmp
.
ctime
)
;
tmp
.
resolve
(
record
)
;
}
else
{
console
.
error
(
"
handleRegisterReply
:
Unexpected
server
response
"
reply
)
;
tmp
.
reject
(
new
Error
(
"
Wrong
status
code
for
register
reply
:
"
+
reply
.
status
)
)
;
}
}
_handleDataUpdate
:
function
(
update
)
{
let
promise
;
if
(
typeof
update
.
channelID
!
=
"
string
"
)
{
console
.
warn
(
"
handleDataUpdate
:
Discarding
update
without
channel
ID
"
update
)
;
return
;
}
if
(
typeof
update
.
data
!
=
"
string
"
)
{
promise
=
this
.
_mainPushService
.
receivedPushMessage
(
update
.
channelID
update
.
version
null
null
record
=
>
record
)
;
}
else
{
let
params
=
getCryptoParams
(
update
.
headers
)
;
if
(
params
)
{
let
message
=
ChromeUtils
.
base64URLDecode
(
update
.
data
{
padding
:
"
ignore
"
}
)
;
promise
=
this
.
_mainPushService
.
receivedPushMessage
(
update
.
channelID
update
.
version
message
params
record
=
>
record
)
;
}
else
{
promise
=
Promise
.
reject
(
new
Error
(
"
Invalid
crypto
headers
"
)
)
;
}
}
promise
.
then
(
status
=
>
{
this
.
_sendAck
(
update
.
channelID
update
.
version
status
)
;
}
err
=
>
{
console
.
error
(
"
handleDataUpdate
:
Error
delivering
message
"
update
err
)
;
this
.
_sendAck
(
update
.
channelID
update
.
version
Ci
.
nsIPushErrorReporter
.
ACK_DECRYPTION_ERROR
)
;
}
)
.
catch
(
err
=
>
{
console
.
error
(
"
handleDataUpdate
:
Error
acknowledging
message
"
update
err
)
;
}
)
;
}
_handleNotificationReply
:
function
(
reply
)
{
console
.
debug
(
"
handleNotificationReply
(
)
"
)
;
if
(
this
.
_dataEnabled
)
{
this
.
_handleDataUpdate
(
reply
)
;
return
;
}
if
(
typeof
reply
.
updates
!
=
=
'
object
'
)
{
console
.
warn
(
"
handleNotificationReply
:
Missing
updates
"
reply
.
updates
)
;
return
;
}
console
.
debug
(
"
handleNotificationReply
:
Got
updates
"
reply
.
updates
)
;
for
(
let
i
=
0
;
i
<
reply
.
updates
.
length
;
i
+
+
)
{
let
update
=
reply
.
updates
[
i
]
;
console
.
debug
(
"
handleNotificationReply
:
Handling
update
"
update
)
;
if
(
typeof
update
.
channelID
!
=
=
"
string
"
)
{
console
.
debug
(
"
handleNotificationReply
:
Invalid
update
at
index
"
i
update
)
;
continue
;
}
if
(
update
.
version
=
=
=
undefined
)
{
console
.
debug
(
"
handleNotificationReply
:
Missing
version
"
update
)
;
continue
;
}
let
version
=
update
.
version
;
if
(
typeof
version
=
=
=
"
string
"
)
{
version
=
parseInt
(
version
10
)
;
}
if
(
typeof
version
=
=
=
"
number
"
&
&
version
>
=
0
)
{
this
.
_receivedUpdate
(
update
.
channelID
version
)
;
}
}
}
reportDeliveryError
(
messageID
reason
)
{
console
.
debug
(
"
reportDeliveryError
(
)
"
)
;
let
code
=
kDELIVERY_REASON_TO_CODE
[
reason
]
;
if
(
!
code
)
{
throw
new
Error
(
'
Invalid
delivery
error
reason
'
)
;
}
let
data
=
{
messageType
:
'
nack
'
version
:
messageID
code
:
code
}
;
this
.
_queueRequest
(
data
)
;
}
_sendAck
(
channelID
version
status
)
{
console
.
debug
(
"
sendAck
(
)
"
)
;
let
code
=
kACK_STATUS_TO_CODE
[
status
]
;
if
(
!
code
)
{
throw
new
Error
(
'
Invalid
ack
status
'
)
;
}
let
data
=
{
messageType
:
'
ack
'
updates
:
[
{
channelID
:
channelID
version
:
version
code
:
code
}
]
}
;
this
.
_queueRequest
(
data
)
;
}
_generateID
:
function
(
)
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
return
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
register
(
record
)
{
console
.
debug
(
"
register
(
)
"
record
)
;
this
.
_startRequestTimeoutTimer
(
)
;
let
data
=
{
channelID
:
this
.
_generateID
(
)
messageType
:
"
register
"
}
;
if
(
record
.
appServerKey
)
{
data
.
key
=
ChromeUtils
.
base64URLEncode
(
record
.
appServerKey
{
pad
:
true
}
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_registerRequests
.
set
(
data
.
channelID
{
record
:
record
resolve
:
resolve
reject
:
reject
ctime
:
Date
.
now
(
)
}
)
;
this
.
_queueRequest
(
data
)
;
}
)
.
then
(
record
=
>
{
if
(
!
this
.
_dataEnabled
)
{
return
record
;
}
return
PushCrypto
.
generateKeys
(
)
.
then
(
(
[
publicKey
privateKey
]
)
=
>
{
record
.
p256dhPublicKey
=
publicKey
;
record
.
p256dhPrivateKey
=
privateKey
;
record
.
authenticationSecret
=
PushCrypto
.
generateAuthenticationSecret
(
)
;
return
record
;
}
)
;
}
)
;
}
unregister
(
record
reason
)
{
console
.
debug
(
"
unregister
(
)
"
record
reason
)
;
let
code
=
kUNREGISTER_REASON_TO_CODE
[
reason
]
;
if
(
!
code
)
{
return
Promise
.
reject
(
new
Error
(
'
Invalid
unregister
reason
'
)
)
;
}
let
data
=
{
channelID
:
record
.
channelID
messageType
:
"
unregister
"
code
:
code
}
;
this
.
_queueRequest
(
data
)
;
return
Promise
.
resolve
(
)
;
}
_queueStart
:
Promise
.
resolve
(
)
_notifyRequestQueue
:
null
_queue
:
null
_enqueue
:
function
(
op
)
{
console
.
debug
(
"
enqueue
(
)
"
)
;
if
(
!
this
.
_queue
)
{
this
.
_queue
=
this
.
_queueStart
;
}
this
.
_queue
=
this
.
_queue
.
then
(
op
)
.
catch
(
_
=
>
{
}
)
;
}
_send
(
data
)
{
if
(
this
.
_currentState
=
=
STATE_READY
)
{
if
(
data
.
messageType
!
=
"
register
"
|
|
this
.
_registerRequests
.
has
(
data
.
channelID
)
)
{
this
.
_wsSendMessage
(
data
)
;
}
}
}
_sendRegisterRequests
(
)
{
this
.
_enqueue
(
_
=
>
{
for
(
let
channelID
of
this
.
_registerRequests
.
keys
(
)
)
{
this
.
_send
(
{
messageType
:
"
register
"
channelID
:
channelID
}
)
;
}
}
)
;
}
_queueRequest
(
data
)
{
if
(
data
.
messageType
!
=
"
register
"
)
{
if
(
this
.
_currentState
!
=
STATE_READY
&
&
!
this
.
_notifyRequestQueue
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_notifyRequestQueue
=
resolve
;
}
)
;
this
.
_enqueue
(
_
=
>
promise
)
;
}
this
.
_enqueue
(
_
=
>
this
.
_send
(
data
)
)
;
}
else
if
(
this
.
_currentState
=
=
STATE_READY
)
{
this
.
_send
(
data
)
;
}
if
(
!
this
.
_ws
)
{
this
.
_beginWSSetup
(
)
;
if
(
!
this
.
_ws
&
&
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
}
}
_receivedUpdate
:
function
(
aChannelID
aLatestVersion
)
{
console
.
debug
(
"
receivedUpdate
:
Updating
"
aChannelID
"
-
>
"
aLatestVersion
)
;
this
.
_mainPushService
.
receivedPushMessage
(
aChannelID
"
"
null
null
record
=
>
{
if
(
record
.
version
=
=
=
null
|
|
record
.
version
<
aLatestVersion
)
{
console
.
debug
(
"
receivedUpdate
:
Version
changed
for
"
aChannelID
aLatestVersion
)
;
record
.
version
=
aLatestVersion
;
return
record
;
}
console
.
debug
(
"
receivedUpdate
:
No
significant
version
change
for
"
aChannelID
aLatestVersion
)
;
return
null
;
}
)
.
then
(
status
=
>
{
this
.
_sendAck
(
aChannelID
aLatestVersion
status
)
;
}
)
.
catch
(
err
=
>
{
console
.
error
(
"
receivedUpdate
:
Error
acknowledging
message
"
aChannelID
aLatestVersion
err
)
;
}
)
;
}
_wsOnStart
:
function
(
context
)
{
console
.
debug
(
"
wsOnStart
(
)
"
)
;
this
.
_releaseWakeLock
(
)
;
if
(
this
.
_currentState
!
=
STATE_WAITING_FOR_WS_START
)
{
console
.
error
(
"
wsOnStart
:
NOT
in
STATE_WAITING_FOR_WS_START
.
Current
"
"
state
"
this
.
_currentState
"
Skipping
"
)
;
return
;
}
let
data
=
{
messageType
:
"
hello
"
use_webpush
:
true
}
;
if
(
this
.
_UAID
)
{
data
.
uaid
=
this
.
_UAID
;
}
this
.
_wsSendMessage
(
data
)
;
this
.
_currentState
=
STATE_WAITING_FOR_HELLO
;
}
_wsOnStop
:
function
(
context
statusCode
)
{
console
.
debug
(
"
wsOnStop
(
)
"
)
;
this
.
_releaseWakeLock
(
)
;
if
(
statusCode
!
=
Cr
.
NS_OK
&
&
!
this
.
_skipReconnect
)
{
console
.
debug
(
"
wsOnStop
:
Reconnecting
after
socket
error
"
statusCode
)
;
this
.
_reconnect
(
)
;
return
;
}
this
.
_shutdownWS
(
)
;
}
_wsOnMessageAvailable
:
function
(
context
message
)
{
console
.
debug
(
"
wsOnMessageAvailable
(
)
"
message
)
;
this
.
_lastPingTime
=
0
;
let
reply
;
try
{
reply
=
JSON
.
parse
(
message
)
;
}
catch
(
e
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
Invalid
JSON
"
message
e
)
;
return
;
}
this
.
_retryFailCount
=
0
;
let
doNotHandle
=
false
;
if
(
(
message
=
=
=
'
{
}
'
)
|
|
(
reply
.
messageType
=
=
=
undefined
)
|
|
(
reply
.
messageType
=
=
=
"
ping
"
)
|
|
(
typeof
reply
.
messageType
!
=
"
string
"
)
)
{
console
.
debug
(
"
wsOnMessageAvailable
:
Pong
received
"
)
;
doNotHandle
=
true
;
}
this
.
_startPingTimer
(
)
;
if
(
doNotHandle
)
{
return
;
}
let
handlers
=
[
"
Hello
"
"
Register
"
"
Notification
"
]
;
let
handlerName
=
reply
.
messageType
[
0
]
.
toUpperCase
(
)
+
reply
.
messageType
.
slice
(
1
)
.
toLowerCase
(
)
;
if
(
handlers
.
indexOf
(
handlerName
)
=
=
-
1
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
No
whitelisted
handler
"
handlerName
"
for
message
"
reply
.
messageType
)
;
return
;
}
let
handler
=
"
_handle
"
+
handlerName
+
"
Reply
"
;
if
(
typeof
this
[
handler
]
!
=
=
"
function
"
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
Handler
"
handler
"
whitelisted
but
not
implemented
"
)
;
return
;
}
this
[
handler
]
(
reply
)
;
}
_wsOnServerClose
:
function
(
context
aStatusCode
aReason
)
{
console
.
debug
(
"
wsOnServerClose
(
)
"
aStatusCode
aReason
)
;
if
(
aStatusCode
=
=
kBACKOFF_WS_STATUS_CODE
)
{
console
.
debug
(
"
wsOnServerClose
:
Skipping
automatic
reconnect
"
)
;
this
.
_skipReconnect
=
true
;
}
}
_cancelRegisterRequests
:
function
(
)
{
for
(
let
request
of
this
.
_registerRequests
.
values
(
)
)
{
request
.
reject
(
new
Error
(
"
Register
request
aborted
"
)
)
;
}
this
.
_registerRequests
.
clear
(
)
;
}
}
;
function
PushRecordWebSocket
(
record
)
{
PushRecord
.
call
(
this
record
)
;
this
.
channelID
=
record
.
channelID
;
this
.
version
=
record
.
version
;
}
PushRecordWebSocket
.
prototype
=
Object
.
create
(
PushRecord
.
prototype
{
keyID
:
{
get
(
)
{
return
this
.
channelID
;
}
}
}
)
;
PushRecordWebSocket
.
prototype
.
toSubscription
=
function
(
)
{
let
subscription
=
PushRecord
.
prototype
.
toSubscription
.
call
(
this
)
;
subscription
.
version
=
this
.
version
;
return
subscription
;
}
;
