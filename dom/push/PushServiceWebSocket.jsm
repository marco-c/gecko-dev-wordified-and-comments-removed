"
use
strict
"
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
PushDB
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushDB
.
jsm
"
)
;
const
{
PushRecord
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushRecord
.
jsm
"
)
;
const
{
PushCrypto
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushCrypto
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
pushBroadcastService
"
"
resource
:
/
/
gre
/
modules
/
PushBroadcastService
.
jsm
"
)
;
ChromeUtils
.
defineModuleGetter
(
this
"
ObjectUtils
"
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
const
kPUSHWSDB_DB_NAME
=
"
pushapi
"
;
const
kPUSHWSDB_DB_VERSION
=
5
;
const
kPUSHWSDB_STORE_NAME
=
"
pushapi
"
;
const
kBACKOFF_WS_STATUS_CODE
=
4774
;
const
kACK_STATUS_TO_CODE
=
{
[
Ci
.
nsIPushErrorReporter
.
ACK_DELIVERED
]
:
100
[
Ci
.
nsIPushErrorReporter
.
ACK_DECRYPTION_ERROR
]
:
101
[
Ci
.
nsIPushErrorReporter
.
ACK_NOT_DELIVERED
]
:
102
}
;
const
kUNREGISTER_REASON_TO_CODE
=
{
[
Ci
.
nsIPushErrorReporter
.
UNSUBSCRIBE_MANUAL
]
:
200
[
Ci
.
nsIPushErrorReporter
.
UNSUBSCRIBE_QUOTA_EXCEEDED
]
:
201
[
Ci
.
nsIPushErrorReporter
.
UNSUBSCRIBE_PERMISSION_REVOKED
]
:
202
}
;
const
kDELIVERY_REASON_TO_CODE
=
{
[
Ci
.
nsIPushErrorReporter
.
DELIVERY_UNCAUGHT_EXCEPTION
]
:
301
[
Ci
.
nsIPushErrorReporter
.
DELIVERY_UNHANDLED_REJECTION
]
:
302
[
Ci
.
nsIPushErrorReporter
.
DELIVERY_INTERNAL_ERROR
]
:
303
}
;
const
prefs
=
Services
.
prefs
.
getBranch
(
"
dom
.
push
.
"
)
;
const
EXPORTED_SYMBOLS
=
[
"
PushServiceWebSocket
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
)
;
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
dom
.
push
.
loglevel
"
prefix
:
"
PushServiceWebSocket
"
}
)
;
}
)
;
var
PushWebSocketListener
=
function
(
pushService
)
{
this
.
_pushService
=
pushService
;
}
;
PushWebSocketListener
.
prototype
=
{
onStart
(
context
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnStart
(
context
)
;
}
onStop
(
context
statusCode
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnStop
(
context
statusCode
)
;
}
onAcknowledge
(
context
size
)
{
}
onBinaryMessageAvailable
(
context
message
)
{
}
onMessageAvailable
(
context
message
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnMessageAvailable
(
context
message
)
;
}
onServerClose
(
context
aStatusCode
aReason
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnServerClose
(
context
aStatusCode
aReason
)
;
}
}
;
const
STATE_SHUT_DOWN
=
0
;
const
STATE_WAITING_FOR_WS_START
=
1
;
const
STATE_WAITING_FOR_HELLO
=
2
;
const
STATE_READY
=
3
;
var
PushServiceWebSocket
=
{
_mainPushService
:
null
_serverURI
:
null
_currentlyRegistering
:
new
Set
(
)
newPushDB
(
)
{
return
new
PushDB
(
kPUSHWSDB_DB_NAME
kPUSHWSDB_DB_VERSION
kPUSHWSDB_STORE_NAME
"
channelID
"
PushRecordWebSocket
)
;
}
disconnect
(
)
{
this
.
_shutdownWS
(
)
;
}
observe
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
&
&
aData
=
=
"
dom
.
push
.
userAgentID
"
)
{
this
.
_onUAIDChanged
(
)
;
}
else
if
(
aTopic
=
=
"
timer
-
callback
"
)
{
this
.
_onTimerFired
(
aSubject
)
;
}
}
_onUAIDChanged
(
)
{
console
.
debug
(
"
onUAIDChanged
(
)
"
)
;
this
.
_shutdownWS
(
)
;
this
.
_startBackoffTimer
(
)
;
}
_onTimerFired
(
timer
)
{
console
.
debug
(
"
onTimerFired
(
)
"
)
;
if
(
timer
=
=
this
.
_pingTimer
)
{
this
.
_sendPing
(
)
;
return
;
}
if
(
timer
=
=
this
.
_backoffTimer
)
{
console
.
debug
(
"
onTimerFired
:
Reconnecting
after
backoff
"
)
;
this
.
_beginWSSetup
(
)
;
return
;
}
if
(
timer
=
=
this
.
_requestTimeoutTimer
)
{
this
.
_timeOutRequests
(
)
;
}
}
_sendPing
(
)
{
console
.
debug
(
"
sendPing
(
)
"
)
;
this
.
_startRequestTimeoutTimer
(
)
;
try
{
this
.
_wsSendMessage
(
{
}
)
;
this
.
_lastPingTime
=
Date
.
now
(
)
;
}
catch
(
e
)
{
console
.
debug
(
"
sendPing
:
Error
sending
ping
"
e
)
;
this
.
_reconnect
(
)
;
}
}
_timeOutRequests
(
)
{
console
.
debug
(
"
timeOutRequests
(
)
"
)
;
if
(
!
this
.
_hasPendingRequests
(
)
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
return
;
}
let
now
=
Date
.
now
(
)
;
let
requestTimedOut
=
false
;
if
(
this
.
_lastPingTime
>
0
&
&
now
-
this
.
_lastPingTime
>
this
.
_requestTimeout
)
{
console
.
debug
(
"
timeOutRequests
:
Did
not
receive
pong
in
time
"
)
;
requestTimedOut
=
true
;
}
else
{
for
(
let
[
key
request
]
of
this
.
_pendingRequests
)
{
let
duration
=
now
-
request
.
ctime
;
requestTimedOut
|
=
duration
>
this
.
_requestTimeout
;
if
(
requestTimedOut
)
{
request
.
reject
(
new
Error
(
"
Request
timed
out
:
"
+
key
)
)
;
this
.
_pendingRequests
.
delete
(
key
)
;
}
}
}
if
(
requestTimedOut
)
{
this
.
_reconnect
(
)
;
}
}
get
_UAID
(
)
{
return
prefs
.
getStringPref
(
"
userAgentID
"
)
;
}
set
_UAID
(
newID
)
{
if
(
typeof
newID
!
=
=
"
string
"
)
{
console
.
warn
(
"
Got
invalid
non
-
string
UAID
"
newID
"
Not
updating
userAgentID
"
)
;
return
;
}
console
.
debug
(
"
New
_UAID
"
newID
)
;
prefs
.
setStringPref
(
"
userAgentID
"
newID
)
;
}
_ws
:
null
_pendingRequests
:
new
Map
(
)
_currentState
:
STATE_SHUT_DOWN
_requestTimeout
:
0
_requestTimeoutTimer
:
null
_retryFailCount
:
0
_skipReconnect
:
false
_dataEnabled
:
false
_lastPingTime
:
0
_pingTimer
:
null
_backoffTimer
:
null
_wsSendMessage
(
msg
)
{
if
(
!
this
.
_ws
)
{
console
.
warn
(
"
wsSendMessage
:
No
WebSocket
initialized
.
"
"
Cannot
send
a
message
"
)
;
return
;
}
msg
=
JSON
.
stringify
(
msg
)
;
console
.
debug
(
"
wsSendMessage
:
Sending
message
"
msg
)
;
this
.
_ws
.
sendMsg
(
msg
)
;
}
init
(
options
mainPushService
serverURI
)
{
console
.
debug
(
"
init
(
)
"
)
;
this
.
_mainPushService
=
mainPushService
;
this
.
_serverURI
=
serverURI
;
this
.
_broadcastListeners
=
null
;
if
(
options
.
makeWebSocket
)
{
this
.
_makeWebSocket
=
options
.
makeWebSocket
;
}
this
.
_requestTimeout
=
prefs
.
getIntPref
(
"
requestTimeout
"
)
;
return
Promise
.
resolve
(
)
;
}
_reconnect
(
)
{
console
.
debug
(
"
reconnect
(
)
"
)
;
this
.
_shutdownWS
(
false
)
;
this
.
_startBackoffTimer
(
)
;
}
_shutdownWS
(
shouldCancelPending
=
true
)
{
console
.
debug
(
"
shutdownWS
(
)
"
)
;
if
(
this
.
_currentState
=
=
STATE_READY
)
{
prefs
.
removeObserver
(
"
userAgentID
"
this
)
;
}
this
.
_currentState
=
STATE_SHUT_DOWN
;
this
.
_skipReconnect
=
false
;
if
(
this
.
_wsListener
)
{
this
.
_wsListener
.
_pushService
=
null
;
}
try
{
this
.
_ws
.
close
(
0
null
)
;
}
catch
(
e
)
{
}
this
.
_ws
=
null
;
this
.
_lastPingTime
=
0
;
if
(
this
.
_pingTimer
)
{
this
.
_pingTimer
.
cancel
(
)
;
}
if
(
shouldCancelPending
)
{
this
.
_cancelPendingRequests
(
)
;
}
if
(
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
}
uninit
(
)
{
this
.
_shutdownWS
(
)
;
if
(
this
.
_backoffTimer
)
{
this
.
_backoffTimer
.
cancel
(
)
;
}
if
(
this
.
_requestTimeoutTimer
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
}
this
.
_mainPushService
=
null
;
this
.
_dataEnabled
=
false
;
}
_startBackoffTimer
(
)
{
console
.
debug
(
"
startBackoffTimer
(
)
"
)
;
let
retryTimeout
=
prefs
.
getIntPref
(
"
retryBaseInterval
"
)
*
Math
.
pow
(
2
this
.
_retryFailCount
)
;
retryTimeout
=
Math
.
min
(
retryTimeout
prefs
.
getIntPref
(
"
pingInterval
"
)
)
;
this
.
_retryFailCount
+
+
;
console
.
debug
(
"
startBackoffTimer
:
Retry
in
"
retryTimeout
"
Try
number
"
this
.
_retryFailCount
)
;
if
(
!
this
.
_backoffTimer
)
{
this
.
_backoffTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_backoffTimer
.
init
(
this
retryTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_hasPendingRequests
(
)
{
return
this
.
_lastPingTime
>
0
|
|
this
.
_pendingRequests
.
size
>
0
;
}
_startRequestTimeoutTimer
(
)
{
if
(
this
.
_hasPendingRequests
(
)
)
{
return
;
}
if
(
!
this
.
_requestTimeoutTimer
)
{
this
.
_requestTimeoutTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_requestTimeoutTimer
.
init
(
this
this
.
_requestTimeout
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
_startPingTimer
(
)
{
if
(
!
this
.
_pingTimer
)
{
this
.
_pingTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_pingTimer
.
init
(
this
prefs
.
getIntPref
(
"
pingInterval
"
)
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_makeWebSocket
(
uri
)
{
if
(
!
prefs
.
getBoolPref
(
"
connection
.
enabled
"
)
)
{
console
.
warn
(
"
makeWebSocket
:
connection
.
enabled
is
not
set
to
true
.
"
"
Aborting
.
"
)
;
return
null
;
}
if
(
Services
.
io
.
offline
)
{
console
.
warn
(
"
makeWebSocket
:
Network
is
offline
.
"
)
;
return
null
;
}
let
contractId
=
uri
.
scheme
=
=
"
ws
"
?
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
ws
"
:
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
wss
"
;
let
socket
=
Cc
[
contractId
]
.
createInstance
(
Ci
.
nsIWebSocketChannel
)
;
socket
.
initLoadInfo
(
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
)
;
return
socket
;
}
_beginWSSetup
(
)
{
console
.
debug
(
"
beginWSSetup
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_SHUT_DOWN
)
{
console
.
error
(
"
_beginWSSetup
:
Not
in
shutdown
state
!
Current
state
"
this
.
_currentState
)
;
return
;
}
if
(
this
.
_backoffTimer
)
{
this
.
_backoffTimer
.
cancel
(
)
;
}
let
uri
=
this
.
_serverURI
;
if
(
!
uri
)
{
return
;
}
let
socket
=
this
.
_makeWebSocket
(
uri
)
;
if
(
!
socket
)
{
return
;
}
this
.
_ws
=
socket
.
QueryInterface
(
Ci
.
nsIWebSocketChannel
)
;
console
.
debug
(
"
beginWSSetup
:
Connecting
to
"
uri
.
spec
)
;
this
.
_wsListener
=
new
PushWebSocketListener
(
this
)
;
this
.
_ws
.
protocol
=
"
push
-
notification
"
;
try
{
this
.
_ws
.
asyncOpen
(
uri
uri
.
spec
0
this
.
_wsListener
null
)
;
this
.
_currentState
=
STATE_WAITING_FOR_WS_START
;
}
catch
(
e
)
{
console
.
error
(
"
beginWSSetup
:
Error
opening
websocket
.
"
"
asyncOpen
failed
"
e
)
;
this
.
_reconnect
(
)
;
}
}
connect
(
broadcastListeners
)
{
console
.
debug
(
"
connect
(
)
"
broadcastListeners
)
;
this
.
_broadcastListeners
=
broadcastListeners
;
this
.
_beginWSSetup
(
)
;
}
isConnected
(
)
{
return
!
!
this
.
_ws
;
}
_handleHelloReply
(
reply
)
{
console
.
debug
(
"
handleHelloReply
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_WAITING_FOR_HELLO
)
{
console
.
error
(
"
handleHelloReply
:
Unexpected
state
"
this
.
_currentState
"
(
expected
STATE_WAITING_FOR_HELLO
)
"
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
typeof
reply
.
uaid
!
=
=
"
string
"
)
{
console
.
error
(
"
handleHelloReply
:
Received
invalid
UAID
"
reply
.
uaid
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
reply
.
uaid
=
=
=
"
"
)
{
console
.
error
(
"
handleHelloReply
:
Received
empty
UAID
"
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
reply
.
uaid
.
length
>
128
)
{
console
.
error
(
"
handleHelloReply
:
UAID
received
from
server
was
too
long
"
reply
.
uaid
)
;
this
.
_shutdownWS
(
)
;
return
;
}
let
sendRequests
=
(
)
=
>
{
if
(
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
this
.
_sendPendingRequests
(
)
;
}
;
function
finishHandshake
(
)
{
this
.
_UAID
=
reply
.
uaid
;
this
.
_currentState
=
STATE_READY
;
prefs
.
addObserver
(
"
userAgentID
"
this
)
;
if
(
!
ObjectUtils
.
isEmpty
(
reply
.
broadcasts
)
)
{
const
context
=
{
phase
:
pushBroadcastService
.
PHASES
.
HELLO
}
;
this
.
_mainPushService
.
receivedBroadcastMessage
(
reply
context
)
;
}
this
.
_dataEnabled
=
!
!
reply
.
use_webpush
;
if
(
this
.
_dataEnabled
)
{
this
.
_mainPushService
.
getAllUnexpired
(
)
.
then
(
records
=
>
Promise
.
all
(
records
.
map
(
record
=
>
this
.
_mainPushService
.
ensureCrypto
(
record
)
.
catch
(
error
=
>
{
console
.
error
(
"
finishHandshake
:
Error
updating
record
"
record
.
keyID
error
)
;
}
)
)
)
)
.
then
(
sendRequests
)
;
}
else
{
sendRequests
(
)
;
}
}
if
(
this
.
_UAID
!
=
reply
.
uaid
)
{
console
.
debug
(
"
handleHelloReply
:
Received
new
UAID
"
)
;
this
.
_mainPushService
.
dropUnexpiredRegistrations
(
)
.
then
(
finishHandshake
.
bind
(
this
)
)
;
return
;
}
finishHandshake
.
bind
(
this
)
(
)
;
}
_handleRegisterReply
(
reply
)
{
console
.
debug
(
"
handleRegisterReply
(
)
"
)
;
let
tmp
=
this
.
_takeRequestForReply
(
reply
)
;
if
(
!
tmp
)
{
return
;
}
if
(
reply
.
status
=
=
200
)
{
try
{
Services
.
io
.
newURI
(
reply
.
pushEndpoint
)
;
}
catch
(
e
)
{
tmp
.
reject
(
new
Error
(
"
Invalid
push
endpoint
:
"
+
reply
.
pushEndpoint
)
)
;
return
;
}
let
record
=
new
PushRecordWebSocket
(
{
channelID
:
reply
.
channelID
pushEndpoint
:
reply
.
pushEndpoint
scope
:
tmp
.
record
.
scope
originAttributes
:
tmp
.
record
.
originAttributes
version
:
null
systemRecord
:
tmp
.
record
.
systemRecord
appServerKey
:
tmp
.
record
.
appServerKey
ctime
:
Date
.
now
(
)
}
)
;
tmp
.
resolve
(
record
)
;
}
else
{
console
.
error
(
"
handleRegisterReply
:
Unexpected
server
response
"
reply
)
;
tmp
.
reject
(
new
Error
(
"
Wrong
status
code
for
register
reply
:
"
+
reply
.
status
)
)
;
}
}
_handleUnregisterReply
(
reply
)
{
console
.
debug
(
"
handleUnregisterReply
(
)
"
)
;
let
request
=
this
.
_takeRequestForReply
(
reply
)
;
if
(
!
request
)
{
return
;
}
let
success
=
reply
.
status
=
=
=
200
;
request
.
resolve
(
success
)
;
}
_handleDataUpdate
(
update
)
{
let
promise
;
if
(
typeof
update
.
channelID
!
=
"
string
"
)
{
console
.
warn
(
"
handleDataUpdate
:
Discarding
update
without
channel
ID
"
update
)
;
return
;
}
function
updateRecord
(
record
)
{
if
(
record
.
hasRecentMessageID
(
update
.
version
)
)
{
console
.
warn
(
"
handleDataUpdate
:
Ignoring
duplicate
message
"
update
.
version
)
;
return
null
;
}
record
.
noteRecentMessageID
(
update
.
version
)
;
return
record
;
}
if
(
typeof
update
.
data
!
=
"
string
"
)
{
promise
=
this
.
_mainPushService
.
receivedPushMessage
(
update
.
channelID
update
.
version
null
null
updateRecord
)
;
}
else
{
let
message
=
ChromeUtils
.
base64URLDecode
(
update
.
data
{
padding
:
"
ignore
"
}
)
;
promise
=
this
.
_mainPushService
.
receivedPushMessage
(
update
.
channelID
update
.
version
update
.
headers
message
updateRecord
)
;
}
promise
.
then
(
status
=
>
{
this
.
_sendAck
(
update
.
channelID
update
.
version
status
)
;
}
err
=
>
{
console
.
error
(
"
handleDataUpdate
:
Error
delivering
message
"
update
err
)
;
this
.
_sendAck
(
update
.
channelID
update
.
version
Ci
.
nsIPushErrorReporter
.
ACK_DECRYPTION_ERROR
)
;
}
)
.
catch
(
err
=
>
{
console
.
error
(
"
handleDataUpdate
:
Error
acknowledging
message
"
update
err
)
;
}
)
;
}
_handleNotificationReply
(
reply
)
{
console
.
debug
(
"
handleNotificationReply
(
)
"
)
;
if
(
this
.
_dataEnabled
)
{
this
.
_handleDataUpdate
(
reply
)
;
return
;
}
if
(
typeof
reply
.
updates
!
=
=
"
object
"
)
{
console
.
warn
(
"
handleNotificationReply
:
Missing
updates
"
reply
.
updates
)
;
return
;
}
console
.
debug
(
"
handleNotificationReply
:
Got
updates
"
reply
.
updates
)
;
for
(
let
i
=
0
;
i
<
reply
.
updates
.
length
;
i
+
+
)
{
let
update
=
reply
.
updates
[
i
]
;
console
.
debug
(
"
handleNotificationReply
:
Handling
update
"
update
)
;
if
(
typeof
update
.
channelID
!
=
=
"
string
"
)
{
console
.
debug
(
"
handleNotificationReply
:
Invalid
update
at
index
"
i
update
)
;
continue
;
}
if
(
update
.
version
=
=
=
undefined
)
{
console
.
debug
(
"
handleNotificationReply
:
Missing
version
"
update
)
;
continue
;
}
let
version
=
update
.
version
;
if
(
typeof
version
=
=
=
"
string
"
)
{
version
=
parseInt
(
version
10
)
;
}
if
(
typeof
version
=
=
=
"
number
"
&
&
version
>
=
0
)
{
this
.
_receivedUpdate
(
update
.
channelID
version
)
;
}
}
}
_handleBroadcastReply
(
reply
)
{
let
phase
=
pushBroadcastService
.
PHASES
.
BROADCAST
;
for
(
const
id
of
Object
.
keys
(
reply
.
broadcasts
)
)
{
const
wasRegistering
=
this
.
_currentlyRegistering
.
delete
(
id
)
;
if
(
wasRegistering
)
{
phase
=
pushBroadcastService
.
PHASES
.
REGISTER
;
}
}
const
context
=
{
phase
}
;
this
.
_mainPushService
.
receivedBroadcastMessage
(
reply
context
)
;
}
reportDeliveryError
(
messageID
reason
)
{
console
.
debug
(
"
reportDeliveryError
(
)
"
)
;
let
code
=
kDELIVERY_REASON_TO_CODE
[
reason
]
;
if
(
!
code
)
{
throw
new
Error
(
"
Invalid
delivery
error
reason
"
)
;
}
let
data
=
{
messageType
:
"
nack
"
version
:
messageID
code
}
;
this
.
_queueRequest
(
data
)
;
}
_sendAck
(
channelID
version
status
)
{
console
.
debug
(
"
sendAck
(
)
"
)
;
let
code
=
kACK_STATUS_TO_CODE
[
status
]
;
if
(
!
code
)
{
throw
new
Error
(
"
Invalid
ack
status
"
)
;
}
let
data
=
{
messageType
:
"
ack
"
updates
:
[
{
channelID
version
code
}
]
}
;
this
.
_queueRequest
(
data
)
;
}
_generateID
(
)
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
return
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
register
(
record
)
{
console
.
debug
(
"
register
(
)
"
record
)
;
let
data
=
{
channelID
:
this
.
_generateID
(
)
messageType
:
"
register
"
}
;
if
(
record
.
appServerKey
)
{
data
.
key
=
ChromeUtils
.
base64URLEncode
(
record
.
appServerKey
{
pad
:
true
}
)
;
}
return
this
.
_sendRequestForReply
(
record
data
)
.
then
(
record
=
>
{
if
(
!
this
.
_dataEnabled
)
{
return
record
;
}
return
PushCrypto
.
generateKeys
(
)
.
then
(
(
[
publicKey
privateKey
]
)
=
>
{
record
.
p256dhPublicKey
=
publicKey
;
record
.
p256dhPrivateKey
=
privateKey
;
record
.
authenticationSecret
=
PushCrypto
.
generateAuthenticationSecret
(
)
;
return
record
;
}
)
;
}
)
;
}
unregister
(
record
reason
)
{
console
.
debug
(
"
unregister
(
)
"
record
reason
)
;
return
Promise
.
resolve
(
)
.
then
(
_
=
>
{
let
code
=
kUNREGISTER_REASON_TO_CODE
[
reason
]
;
if
(
!
code
)
{
throw
new
Error
(
"
Invalid
unregister
reason
"
)
;
}
let
data
=
{
channelID
:
record
.
channelID
messageType
:
"
unregister
"
code
}
;
return
this
.
_sendRequestForReply
(
record
data
)
;
}
)
;
}
_queueStart
:
Promise
.
resolve
(
)
_notifyRequestQueue
:
null
_queue
:
null
_enqueue
(
op
)
{
console
.
debug
(
"
enqueue
(
)
"
)
;
if
(
!
this
.
_queue
)
{
this
.
_queue
=
this
.
_queueStart
;
}
this
.
_queue
=
this
.
_queue
.
then
(
op
)
.
catch
(
_
=
>
{
}
)
;
}
_send
(
data
)
{
if
(
this
.
_currentState
!
=
STATE_READY
)
{
console
.
warn
(
"
send
:
Unexpected
state
;
ignoring
message
"
this
.
_currentState
)
;
return
;
}
if
(
!
this
.
_requestHasReply
(
data
)
)
{
this
.
_wsSendMessage
(
data
)
;
return
;
}
let
key
=
this
.
_makePendingRequestKey
(
data
)
;
if
(
!
this
.
_pendingRequests
.
has
(
key
)
)
{
console
.
log
(
"
send
:
Request
cancelled
;
ignoring
message
"
key
)
;
return
;
}
this
.
_wsSendMessage
(
data
)
;
}
_requestHasReply
(
data
)
{
return
data
.
messageType
=
=
"
register
"
|
|
data
.
messageType
=
=
"
unregister
"
;
}
_sendPendingRequests
(
)
{
this
.
_enqueue
(
_
=
>
{
for
(
let
request
of
this
.
_pendingRequests
.
values
(
)
)
{
this
.
_send
(
request
.
data
)
;
}
}
)
;
}
_queueRequest
(
data
)
{
console
.
debug
(
"
queueRequest
(
)
"
data
)
;
if
(
this
.
_currentState
=
=
STATE_READY
)
{
this
.
_send
(
data
)
;
return
;
}
if
(
!
this
.
_notifyRequestQueue
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_notifyRequestQueue
=
resolve
;
}
)
;
this
.
_enqueue
(
_
=
>
promise
)
;
}
let
isRequest
=
this
.
_requestHasReply
(
data
)
;
if
(
!
isRequest
)
{
this
.
_enqueue
(
_
=
>
this
.
_send
(
data
)
)
;
}
if
(
!
this
.
_ws
)
{
this
.
_beginWSSetup
(
)
;
if
(
!
this
.
_ws
&
&
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
}
}
_receivedUpdate
(
aChannelID
aLatestVersion
)
{
console
.
debug
(
"
receivedUpdate
:
Updating
"
aChannelID
"
-
>
"
aLatestVersion
)
;
this
.
_mainPushService
.
receivedPushMessage
(
aChannelID
"
"
null
null
record
=
>
{
if
(
record
.
version
=
=
=
null
|
|
record
.
version
<
aLatestVersion
)
{
console
.
debug
(
"
receivedUpdate
:
Version
changed
for
"
aChannelID
aLatestVersion
)
;
record
.
version
=
aLatestVersion
;
return
record
;
}
console
.
debug
(
"
receivedUpdate
:
No
significant
version
change
for
"
aChannelID
aLatestVersion
)
;
return
null
;
}
)
.
then
(
status
=
>
{
this
.
_sendAck
(
aChannelID
aLatestVersion
status
)
;
}
)
.
catch
(
err
=
>
{
console
.
error
(
"
receivedUpdate
:
Error
acknowledging
message
"
aChannelID
aLatestVersion
err
)
;
}
)
;
}
_wsOnStart
(
context
)
{
console
.
debug
(
"
wsOnStart
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_WAITING_FOR_WS_START
)
{
console
.
error
(
"
wsOnStart
:
NOT
in
STATE_WAITING_FOR_WS_START
.
Current
"
"
state
"
this
.
_currentState
"
Skipping
"
)
;
return
;
}
this
.
_mainPushService
.
getAllUnexpired
(
)
.
then
(
records
=
>
this
.
_sendHello
(
records
)
err
=
>
{
console
.
warn
(
"
Error
fetching
existing
records
before
handshake
;
assuming
none
"
err
)
;
this
.
_sendHello
(
[
]
)
;
}
)
.
catch
(
err
=
>
{
console
.
warn
(
"
Failed
to
send
handshake
;
reconnecting
"
err
)
;
this
.
_reconnect
(
)
;
}
)
;
}
_sendHello
(
records
)
{
let
data
=
{
messageType
:
"
hello
"
broadcasts
:
this
.
_broadcastListeners
use_webpush
:
true
}
;
if
(
records
.
length
&
&
this
.
_UAID
)
{
data
.
uaid
=
this
.
_UAID
;
}
this
.
_wsSendMessage
(
data
)
;
this
.
_currentState
=
STATE_WAITING_FOR_HELLO
;
}
_wsOnStop
(
context
statusCode
)
{
console
.
debug
(
"
wsOnStop
(
)
"
)
;
if
(
statusCode
!
=
Cr
.
NS_OK
&
&
!
this
.
_skipReconnect
)
{
console
.
debug
(
"
wsOnStop
:
Reconnecting
after
socket
error
"
statusCode
)
;
this
.
_reconnect
(
)
;
return
;
}
this
.
_shutdownWS
(
)
;
}
_wsOnMessageAvailable
(
context
message
)
{
console
.
debug
(
"
wsOnMessageAvailable
(
)
"
message
)
;
this
.
_lastPingTime
=
0
;
let
reply
;
try
{
reply
=
JSON
.
parse
(
message
)
;
}
catch
(
e
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
Invalid
JSON
"
message
e
)
;
return
;
}
this
.
_retryFailCount
=
0
;
let
doNotHandle
=
false
;
if
(
message
=
=
=
"
{
}
"
|
|
reply
.
messageType
=
=
=
undefined
|
|
reply
.
messageType
=
=
=
"
ping
"
|
|
typeof
reply
.
messageType
!
=
"
string
"
)
{
console
.
debug
(
"
wsOnMessageAvailable
:
Pong
received
"
)
;
doNotHandle
=
true
;
}
this
.
_startPingTimer
(
)
;
if
(
doNotHandle
)
{
return
;
}
let
handlers
=
[
"
Hello
"
"
Register
"
"
Unregister
"
"
Notification
"
"
Broadcast
"
]
;
let
handlerName
=
reply
.
messageType
[
0
]
.
toUpperCase
(
)
+
reply
.
messageType
.
slice
(
1
)
.
toLowerCase
(
)
;
if
(
!
handlers
.
includes
(
handlerName
)
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
No
whitelisted
handler
"
handlerName
"
for
message
"
reply
.
messageType
)
;
return
;
}
let
handler
=
"
_handle
"
+
handlerName
+
"
Reply
"
;
if
(
typeof
this
[
handler
]
!
=
=
"
function
"
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
Handler
"
handler
"
whitelisted
but
not
implemented
"
)
;
return
;
}
this
[
handler
]
(
reply
)
;
}
_wsOnServerClose
(
context
aStatusCode
aReason
)
{
console
.
debug
(
"
wsOnServerClose
(
)
"
aStatusCode
aReason
)
;
if
(
aStatusCode
=
=
kBACKOFF_WS_STATUS_CODE
)
{
console
.
debug
(
"
wsOnServerClose
:
Skipping
automatic
reconnect
"
)
;
this
.
_skipReconnect
=
true
;
}
}
_cancelPendingRequests
(
)
{
for
(
let
request
of
this
.
_pendingRequests
.
values
(
)
)
{
request
.
reject
(
new
Error
(
"
Request
aborted
"
)
)
;
}
this
.
_pendingRequests
.
clear
(
)
;
}
_makePendingRequestKey
(
data
)
{
return
(
data
.
messageType
+
"
|
"
+
data
.
channelID
)
.
toLowerCase
(
)
;
}
_sendRequestForReply
(
record
data
)
{
return
Promise
.
resolve
(
)
.
then
(
_
=
>
{
this
.
_startRequestTimeoutTimer
(
)
;
let
key
=
this
.
_makePendingRequestKey
(
data
)
;
if
(
!
this
.
_pendingRequests
.
has
(
key
)
)
{
let
request
=
{
data
record
ctime
:
Date
.
now
(
)
}
;
request
.
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
request
.
resolve
=
resolve
;
request
.
reject
=
reject
;
}
)
;
this
.
_pendingRequests
.
set
(
key
request
)
;
this
.
_queueRequest
(
data
)
;
}
return
this
.
_pendingRequests
.
get
(
key
)
.
promise
;
}
)
;
}
_takeRequestForReply
(
reply
)
{
if
(
typeof
reply
.
channelID
!
=
=
"
string
"
)
{
return
null
;
}
let
key
=
this
.
_makePendingRequestKey
(
reply
)
;
let
request
=
this
.
_pendingRequests
.
get
(
key
)
;
if
(
!
request
)
{
return
null
;
}
this
.
_pendingRequests
.
delete
(
key
)
;
if
(
!
this
.
_hasPendingRequests
(
)
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
}
return
request
;
}
sendSubscribeBroadcast
(
serviceId
version
)
{
this
.
_currentlyRegistering
.
add
(
serviceId
)
;
let
data
=
{
messageType
:
"
broadcast_subscribe
"
broadcasts
:
{
[
serviceId
]
:
version
}
}
;
this
.
_queueRequest
(
data
)
;
}
}
;
function
PushRecordWebSocket
(
record
)
{
PushRecord
.
call
(
this
record
)
;
this
.
channelID
=
record
.
channelID
;
this
.
version
=
record
.
version
;
}
PushRecordWebSocket
.
prototype
=
Object
.
create
(
PushRecord
.
prototype
{
keyID
:
{
get
(
)
{
return
this
.
channelID
;
}
}
}
)
;
PushRecordWebSocket
.
prototype
.
toSubscription
=
function
(
)
{
let
subscription
=
PushRecord
.
prototype
.
toSubscription
.
call
(
this
)
;
subscription
.
version
=
this
.
version
;
return
subscription
;
}
;
