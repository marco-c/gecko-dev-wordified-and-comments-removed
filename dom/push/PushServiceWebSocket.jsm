"
use
strict
"
;
const
Cc
=
Components
.
classes
;
const
Ci
=
Components
.
interfaces
;
const
Cu
=
Components
.
utils
;
const
Cr
=
Components
.
results
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
PushDB
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushDB
.
jsm
"
)
;
const
{
PushRecord
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushRecord
.
jsm
"
)
;
const
{
PushCrypto
base64UrlDecode
getCryptoParams
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushCrypto
.
jsm
"
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gDNSService
"
"
mozilla
.
org
/
network
/
dns
-
service
;
1
"
"
nsIDNSService
"
)
;
if
(
AppConstants
.
MOZ_B2G
)
{
XPCOMUtils
.
defineLazyServiceGetter
(
this
"
gPowerManagerService
"
"
mozilla
.
org
/
power
/
powermanagerservice
;
1
"
"
nsIPowerManagerService
"
)
;
}
var
threadManager
=
Cc
[
"
mozilla
.
org
/
thread
-
manager
;
1
"
]
.
getService
(
Ci
.
nsIThreadManager
)
;
const
kPUSHWSDB_DB_NAME
=
"
pushapi
"
;
const
kPUSHWSDB_DB_VERSION
=
5
;
const
kPUSHWSDB_STORE_NAME
=
"
pushapi
"
;
const
kUDP_WAKEUP_WS_STATUS_CODE
=
4774
;
const
prefs
=
new
Preferences
(
"
dom
.
push
.
"
)
;
this
.
EXPORTED_SYMBOLS
=
[
"
PushServiceWebSocket
"
]
;
XPCOMUtils
.
defineLazyGetter
(
this
"
console
"
(
)
=
>
{
let
{
ConsoleAPI
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Console
.
jsm
"
{
}
)
;
return
new
ConsoleAPI
(
{
maxLogLevelPref
:
"
dom
.
push
.
loglevel
"
prefix
:
"
PushServiceWebSocket
"
}
)
;
}
)
;
var
PushWebSocketListener
=
function
(
pushService
)
{
this
.
_pushService
=
pushService
;
}
;
PushWebSocketListener
.
prototype
=
{
onStart
:
function
(
context
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnStart
(
context
)
;
}
onStop
:
function
(
context
statusCode
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnStop
(
context
statusCode
)
;
}
onAcknowledge
:
function
(
context
size
)
{
}
onBinaryMessageAvailable
:
function
(
context
message
)
{
}
onMessageAvailable
:
function
(
context
message
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnMessageAvailable
(
context
message
)
;
}
onServerClose
:
function
(
context
aStatusCode
aReason
)
{
if
(
!
this
.
_pushService
)
{
return
;
}
this
.
_pushService
.
_wsOnServerClose
(
context
aStatusCode
aReason
)
;
}
}
;
const
STATE_SHUT_DOWN
=
0
;
const
STATE_WAITING_FOR_WS_START
=
1
;
const
STATE_WAITING_FOR_HELLO
=
2
;
const
STATE_READY
=
3
;
this
.
PushServiceWebSocket
=
{
_mainPushService
:
null
_serverURI
:
null
newPushDB
:
function
(
)
{
return
new
PushDB
(
kPUSHWSDB_DB_NAME
kPUSHWSDB_DB_VERSION
kPUSHWSDB_STORE_NAME
"
channelID
"
PushRecordWebSocket
)
;
}
serviceType
:
function
(
)
{
return
"
WebSocket
"
;
}
disconnect
:
function
(
)
{
this
.
_shutdownWS
(
)
;
}
observe
:
function
(
aSubject
aTopic
aData
)
{
if
(
aTopic
=
=
"
nsPref
:
changed
"
&
&
aData
=
=
"
dom
.
push
.
userAgentID
"
)
{
this
.
_onUAIDChanged
(
)
;
}
else
if
(
aTopic
=
=
"
timer
-
callback
"
)
{
this
.
_onTimerFired
(
aSubject
)
;
}
}
_onUAIDChanged
(
)
{
console
.
debug
(
"
onUAIDChanged
(
)
"
)
;
this
.
_shutdownWS
(
)
;
this
.
_startBackoffTimer
(
)
;
}
_onTimerFired
(
timer
)
{
console
.
debug
(
"
onTimerFired
(
)
"
)
;
if
(
timer
=
=
this
.
_pingTimer
)
{
this
.
_sendPing
(
)
;
return
;
}
if
(
timer
=
=
this
.
_backoffTimer
)
{
console
.
debug
(
"
onTimerFired
:
Reconnecting
after
backoff
"
)
;
if
(
this
.
_reconnectTestCallback
)
{
let
actualRetryTimeout
=
Date
.
now
(
)
-
this
.
_lastDisconnect
;
this
.
_reconnectTestCallback
(
actualRetryTimeout
)
;
}
this
.
_beginWSSetup
(
)
;
return
;
}
if
(
timer
=
=
this
.
_requestTimeoutTimer
)
{
this
.
_timeOutRequests
(
)
;
return
;
}
}
_sendPing
(
)
{
console
.
debug
(
"
sendPing
(
)
"
)
;
this
.
_startRequestTimeoutTimer
(
)
;
try
{
this
.
_wsSendMessage
(
{
}
)
;
this
.
_lastPingTime
=
Date
.
now
(
)
;
}
catch
(
e
)
{
console
.
debug
(
"
sendPing
:
Error
sending
ping
"
e
)
;
this
.
_reconnect
(
)
;
}
}
_timeOutRequests
(
)
{
console
.
debug
(
"
timeOutRequests
(
)
"
)
;
if
(
!
this
.
_hasPendingRequests
(
)
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
return
;
}
let
now
=
Date
.
now
(
)
;
let
requestTimedOut
=
false
;
if
(
this
.
_lastPingTime
>
0
&
&
now
-
this
.
_lastPingTime
>
this
.
_requestTimeout
)
{
console
.
debug
(
"
timeOutRequests
:
Did
not
receive
pong
in
time
"
)
;
requestTimedOut
=
true
;
}
else
{
for
(
let
[
channelID
request
]
of
this
.
_registerRequests
)
{
let
duration
=
now
-
request
.
ctime
;
requestTimedOut
|
=
duration
>
this
.
_requestTimeout
;
if
(
requestTimedOut
)
{
request
.
reject
(
new
Error
(
"
Register
request
timed
out
for
channel
ID
"
+
channelID
)
)
;
this
.
_registerRequests
.
delete
(
channelID
)
;
}
}
}
if
(
requestTimedOut
)
{
this
.
_reconnect
(
)
;
}
}
validServerURI
:
function
(
serverURI
)
{
return
serverURI
.
scheme
=
=
"
ws
"
|
|
serverURI
.
scheme
=
=
"
wss
"
;
}
get
_UAID
(
)
{
return
prefs
.
get
(
"
userAgentID
"
)
;
}
set
_UAID
(
newID
)
{
if
(
typeof
(
newID
)
!
=
=
"
string
"
)
{
console
.
warn
(
"
Got
invalid
non
-
string
UAID
"
newID
"
Not
updating
userAgentID
"
)
;
return
;
}
console
.
debug
(
"
New
_UAID
"
newID
)
;
prefs
.
set
(
"
userAgentID
"
newID
)
;
}
_ws
:
null
_registerRequests
:
new
Map
(
)
_currentState
:
STATE_SHUT_DOWN
_requestTimeout
:
0
_requestTimeoutTimer
:
null
_retryFailCount
:
0
_willBeWokenUpByUDP
:
false
_adaptiveEnabled
:
false
_recalculatePing
:
true
_pingIntervalRetryTimes
:
{
}
_lastGoodPingInterval
:
0
_upperLimit
:
0
_dataEnabled
:
false
_lastPingTime
:
0
_lastDisconnect
:
0
_pingTimer
:
null
_backoffTimer
:
null
_reconnectTestCallback
:
null
_wsSendMessage
:
function
(
msg
)
{
if
(
!
this
.
_ws
)
{
console
.
warn
(
"
wsSendMessage
:
No
WebSocket
initialized
.
"
"
Cannot
send
a
message
"
)
;
return
;
}
msg
=
JSON
.
stringify
(
msg
)
;
console
.
debug
(
"
wsSendMessage
:
Sending
message
"
msg
)
;
this
.
_ws
.
sendMsg
(
msg
)
;
}
init
:
function
(
options
mainPushService
serverURI
)
{
console
.
debug
(
"
init
(
)
"
)
;
this
.
_mainPushService
=
mainPushService
;
this
.
_serverURI
=
serverURI
;
if
(
options
.
makeWebSocket
)
{
this
.
_makeWebSocket
=
options
.
makeWebSocket
;
}
if
(
options
.
makeUDPSocket
)
{
this
.
_makeUDPSocket
=
options
.
makeUDPSocket
;
}
this
.
_networkInfo
=
options
.
networkInfo
;
if
(
!
this
.
_networkInfo
)
{
this
.
_networkInfo
=
PushNetworkInfo
;
}
this
.
_requestTimeout
=
prefs
.
get
(
"
requestTimeout
"
)
;
this
.
_adaptiveEnabled
=
prefs
.
get
(
'
adaptive
.
enabled
'
)
;
this
.
_upperLimit
=
prefs
.
get
(
'
adaptive
.
upperLimit
'
)
;
return
Promise
.
resolve
(
)
;
}
_reconnect
:
function
(
)
{
console
.
debug
(
"
reconnect
(
)
"
)
;
this
.
_shutdownWS
(
false
)
;
this
.
_startBackoffTimer
(
)
;
}
_shutdownWS
:
function
(
shouldCancelPending
=
true
)
{
console
.
debug
(
"
shutdownWS
(
)
"
)
;
this
.
_currentState
=
STATE_SHUT_DOWN
;
this
.
_willBeWokenUpByUDP
=
false
;
prefs
.
ignore
(
"
userAgentID
"
this
)
;
if
(
this
.
_wsListener
)
{
this
.
_wsListener
.
_pushService
=
null
;
}
try
{
this
.
_ws
.
close
(
0
null
)
;
}
catch
(
e
)
{
}
this
.
_ws
=
null
;
this
.
_lastPingTime
=
0
;
if
(
this
.
_pingTimer
)
{
this
.
_pingTimer
.
cancel
(
)
;
}
if
(
shouldCancelPending
)
{
this
.
_cancelRegisterRequests
(
)
;
}
if
(
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
this
.
_lastDisconnect
=
Date
.
now
(
)
;
}
uninit
:
function
(
)
{
if
(
this
.
_udpServer
)
{
this
.
_udpServer
.
close
(
)
;
this
.
_udpServer
=
null
;
}
this
.
_shutdownWS
(
)
;
if
(
this
.
_backoffTimer
)
{
this
.
_backoffTimer
.
cancel
(
)
;
}
if
(
this
.
_requestTimeoutTimer
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
}
this
.
_mainPushService
=
null
;
this
.
_dataEnabled
=
false
;
}
_startBackoffTimer
(
)
{
console
.
debug
(
"
startBackoffTimer
(
)
"
)
;
this
.
_calculateAdaptivePing
(
true
)
;
let
retryTimeout
=
prefs
.
get
(
"
retryBaseInterval
"
)
*
Math
.
pow
(
2
this
.
_retryFailCount
)
;
retryTimeout
=
Math
.
min
(
retryTimeout
prefs
.
get
(
"
pingInterval
"
)
)
;
this
.
_retryFailCount
+
+
;
console
.
debug
(
"
startBackoffTimer
:
Retry
in
"
retryTimeout
"
Try
number
"
this
.
_retryFailCount
)
;
if
(
!
this
.
_backoffTimer
)
{
this
.
_backoffTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_backoffTimer
.
init
(
this
retryTimeout
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_hasPendingRequests
(
)
{
return
this
.
_lastPingTime
>
0
|
|
this
.
_registerRequests
.
size
>
0
;
}
_startRequestTimeoutTimer
(
)
{
if
(
this
.
_hasPendingRequests
(
)
)
{
return
;
}
if
(
!
this
.
_requestTimeoutTimer
)
{
this
.
_requestTimeoutTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_requestTimeoutTimer
.
init
(
this
this
.
_requestTimeout
Ci
.
nsITimer
.
TYPE_REPEATING_SLACK
)
;
}
_startPingTimer
(
)
{
if
(
!
this
.
_pingTimer
)
{
this
.
_pingTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
this
.
_pingTimer
.
init
(
this
prefs
.
get
(
"
pingInterval
"
)
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_calculateAdaptivePing
:
function
(
wsWentDown
)
{
console
.
debug
(
"
_calculateAdaptivePing
(
)
"
)
;
if
(
!
this
.
_adaptiveEnabled
)
{
console
.
debug
(
"
calculateAdaptivePing
:
Adaptive
ping
is
disabled
"
)
;
return
;
}
if
(
this
.
_retryFailCount
>
0
)
{
console
.
warn
(
"
calculateAdaptivePing
:
Push
has
failed
to
connect
to
the
"
"
Push
Server
"
this
.
_retryFailCount
"
times
.
Do
not
calculate
a
new
"
"
pingInterval
now
"
)
;
return
;
}
if
(
!
this
.
_recalculatePing
&
&
!
wsWentDown
)
{
console
.
debug
(
"
calculateAdaptivePing
:
We
do
not
need
to
recalculate
the
"
"
ping
now
based
on
previous
data
"
)
;
return
;
}
let
ns
=
this
.
_networkInfo
.
getNetworkInformation
(
)
;
if
(
ns
.
ip
)
{
console
.
debug
(
"
calculateAdaptivePing
:
mobile
"
)
;
let
oldNetwork
=
prefs
.
get
(
'
adaptive
.
mobile
'
)
;
let
newNetwork
=
'
mobile
-
'
+
ns
.
mcc
+
'
-
'
+
ns
.
mnc
;
if
(
oldNetwork
!
=
=
newNetwork
)
{
console
.
debug
(
"
calculateAdaptivePing
:
Mobile
networks
differ
.
Old
"
"
network
is
"
oldNetwork
"
and
new
is
"
newNetwork
)
;
prefs
.
set
(
'
adaptive
.
mobile
'
newNetwork
)
;
this
.
_recalculatePing
=
true
;
this
.
_pingIntervalRetryTimes
=
{
}
;
let
defaultPing
=
prefs
.
get
(
'
pingInterval
.
default
'
)
;
prefs
.
set
(
'
pingInterval
'
defaultPing
)
;
this
.
_lastGoodPingInterval
=
defaultPing
;
}
else
{
prefs
.
set
(
'
pingInterval
'
prefs
.
get
(
'
pingInterval
.
mobile
'
)
)
;
this
.
_lastGoodPingInterval
=
prefs
.
get
(
'
adaptive
.
lastGoodPingInterval
.
mobile
'
)
;
}
}
else
{
console
.
debug
(
"
calculateAdaptivePing
:
wifi
"
)
;
prefs
.
set
(
'
pingInterval
'
prefs
.
get
(
'
pingInterval
.
wifi
'
)
)
;
this
.
_lastGoodPingInterval
=
prefs
.
get
(
'
adaptive
.
lastGoodPingInterval
.
wifi
'
)
;
}
let
nextPingInterval
;
let
lastTriedPingInterval
=
prefs
.
get
(
'
pingInterval
'
)
;
if
(
wsWentDown
)
{
console
.
debug
(
"
calculateAdaptivePing
:
The
WebSocket
was
disconnected
.
"
"
Calculating
next
ping
"
)
;
this
.
_pingIntervalRetryTimes
[
lastTriedPingInterval
]
=
(
this
.
_pingIntervalRetryTimes
[
lastTriedPingInterval
]
|
|
0
)
+
1
;
if
(
this
.
_pingIntervalRetryTimes
[
lastTriedPingInterval
]
<
2
)
{
console
.
debug
(
"
calculateAdaptivePing
:
pingInterval
=
"
lastTriedPingInterval
"
tried
only
"
this
.
_pingIntervalRetryTimes
[
lastTriedPingInterval
]
"
times
"
)
;
return
;
}
nextPingInterval
=
Math
.
floor
(
lastTriedPingInterval
/
2
)
;
if
(
nextPingInterval
-
this
.
_lastGoodPingInterval
<
prefs
.
get
(
'
adaptive
.
gap
'
)
)
{
console
.
debug
(
"
calculateAdaptivePing
:
We
have
reached
the
gap
we
"
"
have
finished
the
calculation
.
nextPingInterval
=
"
nextPingInterval
"
lastGoodPing
=
"
this
.
_lastGoodPingInterval
)
;
nextPingInterval
=
this
.
_lastGoodPingInterval
;
this
.
_recalculatePing
=
false
;
}
else
{
console
.
debug
(
"
calculateAdaptivePing
:
We
need
to
calculate
next
time
"
)
;
this
.
_recalculatePing
=
true
;
}
}
else
{
console
.
debug
(
"
calculateAdaptivePing
:
The
WebSocket
is
still
up
"
)
;
this
.
_lastGoodPingInterval
=
lastTriedPingInterval
;
nextPingInterval
=
Math
.
floor
(
lastTriedPingInterval
*
1
.
5
)
;
}
if
(
this
.
_upperLimit
<
nextPingInterval
)
{
console
.
debug
(
"
calculateAdaptivePing
:
Next
ping
will
be
bigger
than
the
"
"
configured
upper
limit
capping
interval
"
)
;
this
.
_recalculatePing
=
false
;
this
.
_lastGoodPingInterval
=
lastTriedPingInterval
;
nextPingInterval
=
lastTriedPingInterval
;
}
console
.
debug
(
"
calculateAdaptivePing
:
Setting
the
pingInterval
to
"
nextPingInterval
)
;
prefs
.
set
(
'
pingInterval
'
nextPingInterval
)
;
if
(
ns
.
ip
)
{
prefs
.
set
(
'
pingInterval
.
mobile
'
nextPingInterval
)
;
prefs
.
set
(
'
adaptive
.
lastGoodPingInterval
.
mobile
'
this
.
_lastGoodPingInterval
)
;
}
else
{
prefs
.
set
(
'
pingInterval
.
wifi
'
nextPingInterval
)
;
prefs
.
set
(
'
adaptive
.
lastGoodPingInterval
.
wifi
'
this
.
_lastGoodPingInterval
)
;
}
}
_makeWebSocket
:
function
(
uri
)
{
if
(
!
prefs
.
get
(
"
connection
.
enabled
"
)
)
{
console
.
warn
(
"
makeWebSocket
:
connection
.
enabled
is
not
set
to
true
.
"
"
Aborting
.
"
)
;
return
null
;
}
if
(
Services
.
io
.
offline
)
{
console
.
warn
(
"
makeWebSocket
:
Network
is
offline
.
"
)
;
return
null
;
}
let
socket
=
Cc
[
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
wss
"
]
.
createInstance
(
Ci
.
nsIWebSocketChannel
)
;
socket
.
initLoadInfo
(
null
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
null
Ci
.
nsILoadInfo
.
SEC_NORMAL
Ci
.
nsIContentPolicy
.
TYPE_WEBSOCKET
)
;
return
socket
;
}
_beginWSSetup
:
function
(
)
{
console
.
debug
(
"
beginWSSetup
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_SHUT_DOWN
)
{
console
.
error
(
"
_beginWSSetup
:
Not
in
shutdown
state
!
Current
state
"
this
.
_currentState
)
;
return
;
}
if
(
this
.
_backoffTimer
)
{
this
.
_backoffTimer
.
cancel
(
)
;
}
let
uri
=
this
.
_serverURI
;
if
(
!
uri
)
{
return
;
}
let
socket
=
this
.
_makeWebSocket
(
uri
)
;
if
(
!
socket
)
{
return
;
}
this
.
_ws
=
socket
.
QueryInterface
(
Ci
.
nsIWebSocketChannel
)
;
console
.
debug
(
"
beginWSSetup
:
Connecting
to
"
uri
.
spec
)
;
this
.
_wsListener
=
new
PushWebSocketListener
(
this
)
;
this
.
_ws
.
protocol
=
"
push
-
notification
"
;
try
{
this
.
_ws
.
asyncOpen
(
uri
uri
.
spec
0
this
.
_wsListener
null
)
;
this
.
_acquireWakeLock
(
)
;
this
.
_currentState
=
STATE_WAITING_FOR_WS_START
;
}
catch
(
e
)
{
console
.
error
(
"
beginWSSetup
:
Error
opening
websocket
.
"
"
asyncOpen
failed
"
e
)
;
this
.
_reconnect
(
)
;
}
}
connect
:
function
(
records
)
{
console
.
debug
(
"
connect
(
)
"
)
;
if
(
records
.
length
>
0
)
{
this
.
_beginWSSetup
(
)
;
}
}
isConnected
:
function
(
)
{
return
!
!
this
.
_ws
;
}
_acquireWakeLock
:
function
(
)
{
if
(
!
AppConstants
.
MOZ_B2G
)
{
return
;
}
if
(
!
this
.
_socketWakeLock
)
{
console
.
debug
(
"
acquireWakeLock
:
Acquiring
Socket
Wakelock
"
)
;
this
.
_socketWakeLock
=
gPowerManagerService
.
newWakeLock
(
"
cpu
"
)
;
}
if
(
!
this
.
_socketWakeLockTimer
)
{
console
.
debug
(
"
acquireWakeLock
:
Creating
Socket
WakeLock
Timer
"
)
;
this
.
_socketWakeLockTimer
=
Cc
[
"
mozilla
.
org
/
timer
;
1
"
]
.
createInstance
(
Ci
.
nsITimer
)
;
}
console
.
debug
(
"
acquireWakeLock
:
Setting
Socket
WakeLock
Timer
"
)
;
this
.
_socketWakeLockTimer
.
initWithCallback
(
this
.
_releaseWakeLock
.
bind
(
this
)
this
.
_requestTimeout
+
1000
Ci
.
nsITimer
.
TYPE_ONE_SHOT
)
;
}
_releaseWakeLock
:
function
(
)
{
if
(
!
AppConstants
.
MOZ_B2G
)
{
return
;
}
console
.
debug
(
"
releaseWakeLock
:
Releasing
Socket
WakeLock
"
)
;
if
(
this
.
_socketWakeLockTimer
)
{
this
.
_socketWakeLockTimer
.
cancel
(
)
;
}
if
(
this
.
_socketWakeLock
)
{
this
.
_socketWakeLock
.
unlock
(
)
;
this
.
_socketWakeLock
=
null
;
}
}
_handleHelloReply
:
function
(
reply
)
{
console
.
debug
(
"
handleHelloReply
(
)
"
)
;
if
(
this
.
_currentState
!
=
STATE_WAITING_FOR_HELLO
)
{
console
.
error
(
"
handleHelloReply
:
Unexpected
state
"
this
.
_currentState
"
(
expected
STATE_WAITING_FOR_HELLO
)
"
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
typeof
reply
.
uaid
!
=
=
"
string
"
)
{
console
.
error
(
"
handleHelloReply
:
Received
invalid
UAID
"
reply
.
uaid
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
reply
.
uaid
=
=
=
"
"
)
{
console
.
error
(
"
handleHelloReply
:
Received
empty
UAID
"
)
;
this
.
_shutdownWS
(
)
;
return
;
}
if
(
reply
.
uaid
.
length
>
128
)
{
console
.
error
(
"
handleHelloReply
:
UAID
received
from
server
was
too
long
"
reply
.
uaid
)
;
this
.
_shutdownWS
(
)
;
return
;
}
let
sendRequests
=
(
)
=
>
{
if
(
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
this
.
_sendRegisterRequests
(
)
;
}
;
function
finishHandshake
(
)
{
this
.
_UAID
=
reply
.
uaid
;
this
.
_currentState
=
STATE_READY
;
prefs
.
observe
(
"
userAgentID
"
this
)
;
this
.
_dataEnabled
=
!
!
reply
.
use_webpush
;
if
(
this
.
_dataEnabled
)
{
this
.
_mainPushService
.
getAllUnexpired
(
)
.
then
(
records
=
>
Promise
.
all
(
records
.
map
(
record
=
>
this
.
_mainPushService
.
ensureCrypto
(
record
)
.
catch
(
error
=
>
{
console
.
error
(
"
finishHandshake
:
Error
updating
record
"
record
.
keyID
error
)
;
}
)
)
)
)
.
then
(
sendRequests
)
;
}
else
{
sendRequests
(
)
;
}
}
if
(
this
.
_UAID
!
=
reply
.
uaid
)
{
console
.
debug
(
"
handleHelloReply
:
Received
new
UAID
"
)
;
this
.
_mainPushService
.
dropUnexpiredRegistrations
(
)
.
then
(
finishHandshake
.
bind
(
this
)
)
;
return
;
}
finishHandshake
.
bind
(
this
)
(
)
;
}
_handleRegisterReply
:
function
(
reply
)
{
console
.
debug
(
"
handleRegisterReply
(
)
"
)
;
if
(
typeof
reply
.
channelID
!
=
=
"
string
"
|
|
!
this
.
_registerRequests
.
has
(
reply
.
channelID
)
)
{
return
;
}
let
tmp
=
this
.
_registerRequests
.
get
(
reply
.
channelID
)
;
this
.
_registerRequests
.
delete
(
reply
.
channelID
)
;
if
(
!
this
.
_hasPendingRequests
(
)
)
{
this
.
_requestTimeoutTimer
.
cancel
(
)
;
}
if
(
reply
.
status
=
=
200
)
{
try
{
Services
.
io
.
newURI
(
reply
.
pushEndpoint
null
null
)
;
}
catch
(
e
)
{
tmp
.
reject
(
new
Error
(
"
Invalid
push
endpoint
:
"
+
reply
.
pushEndpoint
)
)
;
return
;
}
let
record
=
new
PushRecordWebSocket
(
{
channelID
:
reply
.
channelID
pushEndpoint
:
reply
.
pushEndpoint
scope
:
tmp
.
record
.
scope
originAttributes
:
tmp
.
record
.
originAttributes
version
:
null
systemRecord
:
tmp
.
record
.
systemRecord
ctime
:
Date
.
now
(
)
}
)
;
Services
.
telemetry
.
getHistogramById
(
"
PUSH_API_SUBSCRIBE_WS_TIME
"
)
.
add
(
Date
.
now
(
)
-
tmp
.
ctime
)
;
tmp
.
resolve
(
record
)
;
}
else
{
console
.
error
(
"
handleRegisterReply
:
Unexpected
server
response
"
reply
)
;
tmp
.
reject
(
new
Error
(
"
Wrong
status
code
for
register
reply
:
"
+
reply
.
status
)
)
;
}
}
_handleDataUpdate
:
function
(
update
)
{
let
promise
;
if
(
typeof
update
.
channelID
!
=
"
string
"
)
{
console
.
warn
(
"
handleDataUpdate
:
Discarding
update
without
channel
ID
"
update
)
;
return
;
}
this
.
_sendAck
(
update
.
channelID
update
.
version
)
;
if
(
typeof
update
.
data
!
=
"
string
"
)
{
promise
=
this
.
_mainPushService
.
receivedPushMessage
(
update
.
channelID
null
null
record
=
>
record
)
;
}
else
{
let
params
=
getCryptoParams
(
update
.
headers
)
;
if
(
!
params
)
{
console
.
warn
(
"
handleDataUpdate
:
Discarding
invalid
encrypted
message
"
update
)
;
return
;
}
let
message
=
base64UrlDecode
(
update
.
data
)
;
promise
=
this
.
_mainPushService
.
receivedPushMessage
(
update
.
channelID
message
params
record
=
>
record
)
;
}
promise
.
catch
(
err
=
>
{
console
.
error
(
"
handleDataUpdate
:
Error
delivering
message
"
err
)
;
}
)
;
}
_handleNotificationReply
:
function
(
reply
)
{
console
.
debug
(
"
handleNotificationReply
(
)
"
)
;
if
(
this
.
_dataEnabled
)
{
this
.
_handleDataUpdate
(
reply
)
;
return
;
}
if
(
typeof
reply
.
updates
!
=
=
'
object
'
)
{
console
.
warn
(
"
handleNotificationReply
:
Missing
updates
"
reply
.
updates
)
;
return
;
}
console
.
debug
(
"
handleNotificationReply
:
Got
updates
"
reply
.
updates
)
;
for
(
let
i
=
0
;
i
<
reply
.
updates
.
length
;
i
+
+
)
{
let
update
=
reply
.
updates
[
i
]
;
console
.
debug
(
"
handleNotificationReply
:
Handling
update
"
update
)
;
if
(
typeof
update
.
channelID
!
=
=
"
string
"
)
{
console
.
debug
(
"
handleNotificationReply
:
Invalid
update
at
index
"
i
update
)
;
continue
;
}
if
(
update
.
version
=
=
=
undefined
)
{
console
.
debug
(
"
handleNotificationReply
:
Missing
version
"
update
)
;
continue
;
}
let
version
=
update
.
version
;
if
(
typeof
version
=
=
=
"
string
"
)
{
version
=
parseInt
(
version
10
)
;
}
if
(
typeof
version
=
=
=
"
number
"
&
&
version
>
=
0
)
{
this
.
_receivedUpdate
(
update
.
channelID
version
)
;
this
.
_sendAck
(
update
.
channelID
version
)
;
}
}
}
_sendAck
:
function
(
channelID
version
)
{
console
.
debug
(
"
sendAck
(
)
"
)
;
var
data
=
{
messageType
:
'
ack
'
updates
:
[
{
channelID
:
channelID
version
:
version
}
]
}
;
this
.
_queueRequest
(
data
)
;
}
_generateID
:
function
(
)
{
let
uuidGenerator
=
Cc
[
"
mozilla
.
org
/
uuid
-
generator
;
1
"
]
.
getService
(
Ci
.
nsIUUIDGenerator
)
;
return
uuidGenerator
.
generateUUID
(
)
.
toString
(
)
.
slice
(
1
-
1
)
;
}
request
:
function
(
action
record
)
{
console
.
debug
(
"
request
(
)
"
action
)
;
this
.
_startRequestTimeoutTimer
(
)
;
if
(
action
=
=
"
register
"
)
{
let
data
=
{
channelID
:
this
.
_generateID
(
)
messageType
:
action
}
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_registerRequests
.
set
(
data
.
channelID
{
record
:
record
resolve
:
resolve
reject
:
reject
ctime
:
Date
.
now
(
)
}
)
;
this
.
_queueRequest
(
data
)
;
}
)
.
then
(
record
=
>
{
if
(
!
this
.
_dataEnabled
)
{
return
record
;
}
return
PushCrypto
.
generateKeys
(
)
.
then
(
(
[
publicKey
privateKey
]
)
=
>
{
record
.
p256dhPublicKey
=
publicKey
;
record
.
p256dhPrivateKey
=
privateKey
;
record
.
authenticationSecret
=
PushCrypto
.
generateAuthenticationSecret
(
)
;
return
record
;
}
)
;
}
)
;
}
this
.
_queueRequest
(
{
channelID
:
record
.
channelID
messageType
:
action
}
)
;
return
Promise
.
resolve
(
)
;
}
_queueStart
:
Promise
.
resolve
(
)
_notifyRequestQueue
:
null
_queue
:
null
_enqueue
:
function
(
op
)
{
console
.
debug
(
"
enqueue
(
)
"
)
;
if
(
!
this
.
_queue
)
{
this
.
_queue
=
this
.
_queueStart
;
}
this
.
_queue
=
this
.
_queue
.
then
(
op
)
.
catch
(
_
=
>
{
}
)
;
}
_send
(
data
)
{
if
(
this
.
_currentState
=
=
STATE_READY
)
{
if
(
data
.
messageType
!
=
"
register
"
|
|
this
.
_registerRequests
.
has
(
data
.
channelID
)
)
{
this
.
_wsSendMessage
(
data
)
;
}
}
}
_sendRegisterRequests
(
)
{
this
.
_enqueue
(
_
=
>
{
for
(
let
channelID
of
this
.
_registerRequests
.
keys
(
)
)
{
this
.
_send
(
{
messageType
:
"
register
"
channelID
:
channelID
}
)
;
}
}
)
;
}
_queueRequest
(
data
)
{
if
(
data
.
messageType
!
=
"
register
"
)
{
if
(
this
.
_currentState
!
=
STATE_READY
&
&
!
this
.
_notifyRequestQueue
)
{
let
promise
=
new
Promise
(
(
resolve
reject
)
=
>
{
this
.
_notifyRequestQueue
=
resolve
;
}
)
;
this
.
_enqueue
(
_
=
>
promise
)
;
}
this
.
_enqueue
(
_
=
>
this
.
_send
(
data
)
)
;
}
else
if
(
this
.
_currentState
=
=
STATE_READY
)
{
this
.
_send
(
data
)
;
}
if
(
!
this
.
_ws
)
{
this
.
_beginWSSetup
(
)
;
if
(
!
this
.
_ws
&
&
this
.
_notifyRequestQueue
)
{
this
.
_notifyRequestQueue
(
)
;
this
.
_notifyRequestQueue
=
null
;
}
}
}
_receivedUpdate
:
function
(
aChannelID
aLatestVersion
)
{
console
.
debug
(
"
receivedUpdate
:
Updating
"
aChannelID
"
-
>
"
aLatestVersion
)
;
this
.
_mainPushService
.
receivedPushMessage
(
aChannelID
null
null
record
=
>
{
if
(
record
.
version
=
=
=
null
|
|
record
.
version
<
aLatestVersion
)
{
console
.
debug
(
"
receivedUpdate
:
Version
changed
for
"
aChannelID
aLatestVersion
)
;
record
.
version
=
aLatestVersion
;
return
record
;
}
console
.
debug
(
"
receivedUpdate
:
No
significant
version
change
for
"
aChannelID
aLatestVersion
)
;
return
null
;
}
)
;
}
_wsOnStart
:
function
(
context
)
{
console
.
debug
(
"
wsOnStart
(
)
"
)
;
this
.
_releaseWakeLock
(
)
;
if
(
this
.
_currentState
!
=
STATE_WAITING_FOR_WS_START
)
{
console
.
error
(
"
wsOnStart
:
NOT
in
STATE_WAITING_FOR_WS_START
.
Current
"
"
state
"
this
.
_currentState
"
Skipping
"
)
;
return
;
}
let
data
=
{
messageType
:
"
hello
"
use_webpush
:
true
}
;
if
(
this
.
_UAID
)
{
data
.
uaid
=
this
.
_UAID
;
}
this
.
_networkInfo
.
getNetworkState
(
(
networkState
)
=
>
{
if
(
networkState
.
ip
)
{
this
.
_listenForUDPWakeup
(
)
;
data
.
wakeup_hostport
=
{
ip
:
networkState
.
ip
port
:
this
.
_udpServer
&
&
this
.
_udpServer
.
port
}
;
data
.
mobilenetwork
=
{
mcc
:
networkState
.
mcc
mnc
:
networkState
.
mnc
netid
:
networkState
.
netid
}
;
}
this
.
_wsSendMessage
(
data
)
;
this
.
_currentState
=
STATE_WAITING_FOR_HELLO
;
}
)
;
}
_wsOnStop
:
function
(
context
statusCode
)
{
console
.
debug
(
"
wsOnStop
(
)
"
)
;
this
.
_releaseWakeLock
(
)
;
if
(
statusCode
!
=
Cr
.
NS_OK
&
&
!
(
statusCode
=
=
Cr
.
NS_BASE_STREAM_CLOSED
&
&
this
.
_willBeWokenUpByUDP
)
)
{
console
.
debug
(
"
wsOnStop
:
Socket
error
"
statusCode
)
;
this
.
_reconnect
(
)
;
return
;
}
this
.
_shutdownWS
(
)
;
}
_wsOnMessageAvailable
:
function
(
context
message
)
{
console
.
debug
(
"
wsOnMessageAvailable
(
)
"
message
)
;
this
.
_lastPingTime
=
0
;
let
reply
;
try
{
reply
=
JSON
.
parse
(
message
)
;
}
catch
(
e
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
Invalid
JSON
"
message
e
)
;
return
;
}
this
.
_retryFailCount
=
0
;
this
.
_pingIntervalRetryTimes
=
{
}
;
let
doNotHandle
=
false
;
if
(
(
message
=
=
=
'
{
}
'
)
|
|
(
reply
.
messageType
=
=
=
undefined
)
|
|
(
reply
.
messageType
=
=
=
"
ping
"
)
|
|
(
typeof
reply
.
messageType
!
=
"
string
"
)
)
{
console
.
debug
(
"
wsOnMessageAvailable
:
Pong
received
"
)
;
this
.
_calculateAdaptivePing
(
false
)
;
doNotHandle
=
true
;
}
this
.
_startPingTimer
(
)
;
if
(
doNotHandle
)
{
return
;
}
let
handlers
=
[
"
Hello
"
"
Register
"
"
Notification
"
]
;
let
handlerName
=
reply
.
messageType
[
0
]
.
toUpperCase
(
)
+
reply
.
messageType
.
slice
(
1
)
.
toLowerCase
(
)
;
if
(
handlers
.
indexOf
(
handlerName
)
=
=
-
1
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
No
whitelisted
handler
"
handlerName
"
for
message
"
reply
.
messageType
)
;
return
;
}
let
handler
=
"
_handle
"
+
handlerName
+
"
Reply
"
;
if
(
typeof
this
[
handler
]
!
=
=
"
function
"
)
{
console
.
warn
(
"
wsOnMessageAvailable
:
Handler
"
handler
"
whitelisted
but
not
implemented
"
)
;
return
;
}
this
[
handler
]
(
reply
)
;
}
_wsOnServerClose
:
function
(
context
aStatusCode
aReason
)
{
console
.
debug
(
"
wsOnServerClose
(
)
"
aStatusCode
aReason
)
;
if
(
aStatusCode
=
=
kUDP_WAKEUP_WS_STATUS_CODE
)
{
console
.
debug
(
"
wsOnServerClose
:
Server
closed
with
promise
to
wake
up
"
)
;
this
.
_willBeWokenUpByUDP
=
true
;
}
}
_cancelRegisterRequests
:
function
(
)
{
for
(
let
request
of
this
.
_registerRequests
.
values
(
)
)
{
request
.
reject
(
new
Error
(
"
Register
request
aborted
"
)
)
;
}
this
.
_registerRequests
.
clear
(
)
;
}
_makeUDPSocket
:
function
(
)
{
return
Cc
[
"
mozilla
.
org
/
network
/
udp
-
socket
;
1
"
]
.
createInstance
(
Ci
.
nsIUDPSocket
)
;
}
_listenForUDPWakeup
:
function
(
)
{
console
.
debug
(
"
listenForUDPWakeup
(
)
"
)
;
if
(
this
.
_udpServer
)
{
console
.
warn
(
"
listenForUDPWakeup
:
UDP
Server
already
running
"
)
;
return
;
}
if
(
!
prefs
.
get
(
"
udp
.
wakeupEnabled
"
)
)
{
console
.
debug
(
"
listenForUDPWakeup
:
UDP
support
disabled
"
)
;
return
;
}
let
socket
=
this
.
_makeUDPSocket
(
)
;
if
(
!
socket
)
{
return
;
}
this
.
_udpServer
=
socket
.
QueryInterface
(
Ci
.
nsIUDPSocket
)
;
this
.
_udpServer
.
init
(
-
1
false
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
)
;
this
.
_udpServer
.
asyncListen
(
this
)
;
console
.
debug
(
"
listenForUDPWakeup
:
Listening
on
"
this
.
_udpServer
.
port
)
;
return
this
.
_udpServer
.
port
;
}
onPacketReceived
:
function
(
aServ
aMessage
)
{
console
.
debug
(
"
onPacketReceived
:
Recv
UDP
datagram
on
port
"
this
.
_udpServer
.
port
)
;
this
.
_beginWSSetup
(
)
;
}
onStopListening
:
function
(
aServ
aStatus
)
{
console
.
debug
(
"
onStopListening
:
UDP
Server
socket
was
shutdown
.
Status
"
aStatus
)
;
this
.
_udpServer
=
undefined
;
this
.
_beginWSSetup
(
)
;
}
}
;
var
PushNetworkInfo
=
{
getNetworkInformation
:
function
(
)
{
console
.
debug
(
"
PushNetworkInfo
:
getNetworkInformation
(
)
"
)
;
try
{
if
(
!
prefs
.
get
(
"
udp
.
wakeupEnabled
"
)
)
{
console
.
debug
(
"
getNetworkInformation
:
UDP
support
disabled
we
do
not
"
"
send
any
carrier
info
"
)
;
throw
new
Error
(
"
UDP
disabled
"
)
;
}
let
nm
=
Cc
[
"
mozilla
.
org
/
network
/
manager
;
1
"
]
.
getService
(
Ci
.
nsINetworkManager
)
;
if
(
nm
.
activeNetworkInfo
&
&
nm
.
activeNetworkInfo
.
type
=
=
Ci
.
nsINetworkInfo
.
NETWORK_TYPE_MOBILE
)
{
let
iccService
=
Cc
[
"
mozilla
.
org
/
icc
/
iccservice
;
1
"
]
.
getService
(
Ci
.
nsIIccService
)
;
let
clientId
=
0
;
let
icc
=
iccService
.
getIccByServiceId
(
clientId
)
;
let
iccInfo
=
icc
&
&
icc
.
iccInfo
;
if
(
iccInfo
)
{
console
.
debug
(
"
getNetworkInformation
:
Running
on
mobile
data
"
)
;
let
ips
=
{
}
;
let
prefixLengths
=
{
}
;
nm
.
activeNetworkInfo
.
getAddresses
(
ips
prefixLengths
)
;
return
{
mcc
:
iccInfo
.
mcc
mnc
:
iccInfo
.
mnc
ip
:
ips
.
value
[
0
]
}
;
}
}
}
catch
(
e
)
{
console
.
error
(
"
getNetworkInformation
:
Error
recovering
mobile
network
"
"
information
"
e
)
;
}
console
.
debug
(
"
getNetworkInformation
:
Running
on
wifi
"
)
;
return
{
mcc
:
0
mnc
:
0
ip
:
undefined
}
;
}
getNetworkState
:
function
(
callback
)
{
console
.
debug
(
"
PushNetworkInfo
:
getNetworkState
(
)
"
)
;
if
(
typeof
callback
!
=
=
'
function
'
)
{
throw
new
Error
(
"
No
callback
method
.
Aborting
push
agent
!
"
)
;
}
var
networkInfo
=
this
.
getNetworkInformation
(
)
;
if
(
networkInfo
.
ip
)
{
this
.
_getMobileNetworkId
(
networkInfo
function
(
netid
)
{
console
.
debug
(
"
getNetworkState
:
Recovered
netID
"
netid
)
;
callback
(
{
mcc
:
networkInfo
.
mcc
mnc
:
networkInfo
.
mnc
ip
:
networkInfo
.
ip
netid
:
netid
}
)
;
}
)
;
}
else
{
callback
(
networkInfo
)
;
}
}
_getMobileNetworkId
:
function
(
networkInfo
callback
)
{
console
.
debug
(
"
PushNetworkInfo
:
getMobileNetworkId
(
)
"
)
;
if
(
typeof
callback
!
=
=
'
function
'
)
{
return
;
}
function
queryDNSForDomain
(
domain
)
{
console
.
debug
(
"
queryDNSForDomain
:
Querying
DNS
for
"
domain
)
;
let
netIDDNSListener
=
{
onLookupComplete
:
function
(
aRequest
aRecord
aStatus
)
{
if
(
aRecord
)
{
let
netid
=
aRecord
.
getNextAddrAsString
(
)
;
console
.
debug
(
"
queryDNSForDomain
:
NetID
found
"
netid
)
;
callback
(
netid
)
;
}
else
{
console
.
debug
(
"
queryDNSForDomain
:
NetID
not
found
"
)
;
callback
(
null
)
;
}
}
}
;
gDNSService
.
asyncResolve
(
domain
0
netIDDNSListener
threadManager
.
currentThread
)
;
return
[
]
;
}
console
.
debug
(
"
getMobileNetworkId
:
Getting
mobile
network
ID
"
)
;
let
netidAddress
=
"
wakeup
.
mnc
"
+
(
"
00
"
+
networkInfo
.
mnc
)
.
slice
(
-
3
)
+
"
.
mcc
"
+
(
"
00
"
+
networkInfo
.
mcc
)
.
slice
(
-
3
)
+
"
.
3gppnetwork
.
org
"
;
queryDNSForDomain
(
netidAddress
callback
)
;
}
}
;
function
PushRecordWebSocket
(
record
)
{
PushRecord
.
call
(
this
record
)
;
this
.
channelID
=
record
.
channelID
;
this
.
version
=
record
.
version
;
}
PushRecordWebSocket
.
prototype
=
Object
.
create
(
PushRecord
.
prototype
{
keyID
:
{
get
(
)
{
return
this
.
channelID
;
}
}
}
)
;
PushRecordWebSocket
.
prototype
.
toSubscription
=
function
(
)
{
let
subscription
=
PushRecord
.
prototype
.
toSubscription
.
call
(
this
)
;
subscription
.
version
=
this
.
version
;
return
subscription
;
}
;
