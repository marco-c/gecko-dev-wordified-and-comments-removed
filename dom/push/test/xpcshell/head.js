'
use
strict
'
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Task
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Preferences
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
PlacesUtils
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
'
)
;
const
serviceExports
=
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
PushService
.
jsm
'
{
}
)
;
const
servicePrefs
=
new
Preferences
(
'
dom
.
push
.
'
)
;
const
DEFAULT_TIMEOUT
=
5000
;
const
WEBSOCKET_CLOSE_GOING_AWAY
=
1001
;
var
isParent
=
Cc
[
'
mozilla
.
org
/
xre
/
runtime
;
1
'
]
.
getService
(
Ci
.
nsIXULRuntime
)
.
processType
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
Services
.
obs
.
addObserver
(
function
observe
(
subject
topic
data
)
{
Services
.
obs
.
removeObserver
(
observe
topic
false
)
;
serviceExports
.
PushService
.
uninit
(
)
;
let
done
=
false
;
setTimeout
(
(
)
=
>
done
=
true
1000
)
;
let
thread
=
Services
.
tm
.
mainThread
;
while
(
!
done
)
{
try
{
thread
.
processNextEvent
(
true
)
;
}
catch
(
e
)
{
Cu
.
reportError
(
e
)
;
}
}
}
'
profile
-
change
-
net
-
teardown
'
false
)
;
function
after
(
times
func
)
{
return
function
afterFunc
(
)
{
if
(
-
-
times
<
=
0
)
{
return
func
.
apply
(
this
arguments
)
;
}
}
;
}
function
addVisit
(
place
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
if
(
typeof
place
.
uri
=
=
'
string
'
)
{
place
.
uri
=
Services
.
io
.
newURI
(
place
.
uri
null
null
)
;
}
PlacesUtils
.
asyncHistory
.
updatePlaces
(
place
{
handleCompletion
:
resolve
handleError
:
reject
handleResult
(
)
{
}
}
)
;
}
)
;
}
function
waterfall
(
.
.
.
callbacks
)
{
callbacks
.
reduce
(
(
promise
callback
)
=
>
promise
.
then
(
(
)
=
>
{
callback
(
)
;
}
)
Promise
.
resolve
(
)
)
.
catch
(
Cu
.
reportError
)
;
}
function
promiseObserverNotification
(
topic
matchFunc
)
{
return
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
obs
.
addObserver
(
function
observe
(
subject
topic
data
)
{
let
matches
=
typeof
matchFunc
!
=
'
function
'
|
|
matchFunc
(
subject
data
)
;
if
(
!
matches
)
{
return
;
}
Services
.
obs
.
removeObserver
(
observe
topic
false
)
;
resolve
(
{
subject
data
}
)
;
}
topic
false
)
;
}
)
;
}
function
waitForPromise
(
promise
delay
message
=
'
Timed
out
waiting
on
promise
'
)
{
let
timeoutDefer
=
Promise
.
defer
(
)
;
let
id
=
setTimeout
(
(
)
=
>
timeoutDefer
.
reject
(
new
Error
(
message
)
)
delay
)
;
return
Promise
.
race
(
[
promise
.
then
(
value
=
>
{
clearTimeout
(
id
)
;
return
value
;
}
error
=
>
{
clearTimeout
(
id
)
;
throw
error
;
}
)
timeoutDefer
.
promise
]
)
;
}
function
makeStub
(
target
stubs
)
{
return
new
Proxy
(
target
{
get
(
target
property
)
{
if
(
!
stubs
|
|
typeof
stubs
!
=
'
object
'
|
|
!
(
property
in
stubs
)
)
{
return
target
[
property
]
;
}
let
stub
=
stubs
[
property
]
;
if
(
typeof
stub
!
=
'
function
'
)
{
return
stub
;
}
let
original
=
target
[
property
]
;
if
(
typeof
original
!
=
'
function
'
)
{
return
stub
.
call
(
this
original
)
;
}
return
function
callStub
(
.
.
.
params
)
{
return
stub
.
call
(
this
original
.
.
.
params
)
;
}
;
}
}
)
;
}
function
disableServiceWorkerEvents
(
.
.
.
scopes
)
{
for
(
let
scope
of
scopes
)
{
Services
.
perms
.
add
(
Services
.
io
.
newURI
(
scope
null
null
)
'
desktop
-
notification
'
Ci
.
nsIPermissionManager
.
DENY_ACTION
)
;
}
}
function
setPrefs
(
prefs
=
{
}
)
{
let
defaultPrefs
=
Object
.
assign
(
{
loglevel
:
'
all
'
serverURL
:
'
wss
:
/
/
push
.
example
.
org
'
'
connection
.
enabled
'
:
true
userAgentID
:
'
'
enabled
:
true
'
adaptive
.
enabled
'
:
false
'
udp
.
wakeupEnabled
'
:
false
requestTimeout
:
10000
retryBaseInterval
:
5000
pingInterval
:
30
*
60
*
1000
'
pingInterval
.
default
'
:
3
*
60
*
1000
'
pingInterval
.
mobile
'
:
3
*
60
*
1000
'
pingInterval
.
wifi
'
:
3
*
60
*
1000
'
adaptive
.
lastGoodPingInterval
'
:
3
*
60
*
1000
'
adaptive
.
lastGoodPingInterval
.
mobile
'
:
3
*
60
*
1000
'
adaptive
.
lastGoodPingInterval
.
wifi
'
:
3
*
60
*
1000
'
adaptive
.
gap
'
:
60000
'
adaptive
.
upperLimit
'
:
29
*
60
*
1000
'
adaptive
.
mobile
'
:
'
'
'
http2
.
maxRetries
'
:
2
'
http2
.
retryInterval
'
:
500
'
http2
.
reset_retry_count_after_ms
'
:
60000
maxQuotaPerSubscription
:
16
quotaUpdateDelay
:
3000
}
prefs
)
;
for
(
let
pref
in
defaultPrefs
)
{
servicePrefs
.
set
(
pref
defaultPrefs
[
pref
]
)
;
}
}
function
compareAscending
(
a
b
)
{
return
a
>
b
?
1
:
a
<
b
?
-
1
:
0
;
}
function
MockWebSocket
(
originalURI
handlers
=
{
}
)
{
this
.
_originalURI
=
originalURI
;
this
.
_onHello
=
handlers
.
onHello
;
this
.
_onRegister
=
handlers
.
onRegister
;
this
.
_onUnregister
=
handlers
.
onUnregister
;
this
.
_onACK
=
handlers
.
onACK
;
this
.
_onPing
=
handlers
.
onPing
;
}
MockWebSocket
.
prototype
=
{
_originalURI
:
null
_onHello
:
null
_onRegister
:
null
_onUnregister
:
null
_onACK
:
null
_onPing
:
null
_listener
:
null
_context
:
null
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsISupports
Ci
.
nsIWebSocketChannel
]
)
get
originalURI
(
)
{
return
this
.
_originalURI
;
}
asyncOpen
(
uri
origin
windowId
listener
context
)
{
this
.
_listener
=
listener
;
this
.
_context
=
context
;
waterfall
(
(
)
=
>
this
.
_listener
.
onStart
(
this
.
_context
)
)
;
}
_handleMessage
(
msg
)
{
let
messageType
request
;
if
(
msg
=
=
'
{
}
'
)
{
request
=
{
}
;
messageType
=
'
ping
'
;
}
else
{
request
=
JSON
.
parse
(
msg
)
;
messageType
=
request
.
messageType
;
}
switch
(
messageType
)
{
case
'
hello
'
:
if
(
typeof
this
.
_onHello
!
=
'
function
'
)
{
throw
new
Error
(
'
Unexpected
handshake
request
'
)
;
}
this
.
_onHello
(
request
)
;
break
;
case
'
register
'
:
if
(
typeof
this
.
_onRegister
!
=
'
function
'
)
{
throw
new
Error
(
'
Unexpected
register
request
'
)
;
}
this
.
_onRegister
(
request
)
;
break
;
case
'
unregister
'
:
if
(
typeof
this
.
_onUnregister
!
=
'
function
'
)
{
throw
new
Error
(
'
Unexpected
unregister
request
'
)
;
}
this
.
_onUnregister
(
request
)
;
break
;
case
'
ack
'
:
if
(
typeof
this
.
_onACK
!
=
'
function
'
)
{
throw
new
Error
(
'
Unexpected
acknowledgement
'
)
;
}
this
.
_onACK
(
request
)
;
break
;
case
'
ping
'
:
if
(
typeof
this
.
_onPing
=
=
'
function
'
)
{
this
.
_onPing
(
request
)
;
}
else
{
this
.
serverSendMsg
(
'
{
}
'
)
;
}
break
;
default
:
throw
new
Error
(
'
Unexpected
message
:
'
+
messageType
)
;
}
}
sendMsg
(
msg
)
{
this
.
_handleMessage
(
msg
)
;
}
close
(
code
reason
)
{
waterfall
(
(
)
=
>
this
.
_listener
.
onStop
(
this
.
_context
Cr
.
NS_OK
)
)
;
}
serverSendMsg
(
msg
)
{
if
(
typeof
msg
!
=
'
string
'
)
{
throw
new
Error
(
'
Invalid
response
message
'
)
;
}
waterfall
(
(
)
=
>
this
.
_listener
.
onMessageAvailable
(
this
.
_context
msg
)
(
)
=
>
this
.
_listener
.
onAcknowledge
(
this
.
_context
0
)
)
;
}
serverClose
(
statusCode
reason
=
'
'
)
{
if
(
!
isFinite
(
statusCode
)
)
{
statusCode
=
WEBSOCKET_CLOSE_GOING_AWAY
;
}
waterfall
(
(
)
=
>
this
.
_listener
.
onServerClose
(
this
.
_context
statusCode
reason
)
(
)
=
>
this
.
_listener
.
onStop
(
this
.
_context
Cr
.
NS_BASE_STREAM_CLOSED
)
)
;
}
serverInterrupt
(
result
=
Cr
.
NS_ERROR_NET_RESET
)
{
waterfall
(
(
)
=
>
this
.
_listener
.
onStop
(
this
.
_context
result
)
)
;
}
}
;
function
MockDesktopNetworkInfo
(
)
{
}
MockDesktopNetworkInfo
.
prototype
=
{
getNetworkInformation
(
)
{
return
{
mcc
:
'
'
mnc
:
'
'
ip
:
'
'
}
;
}
getNetworkState
(
callback
)
{
callback
(
{
mcc
:
'
'
mnc
:
'
'
ip
:
'
'
netid
:
'
'
}
)
;
}
getNetworkStateChangeEventName
(
)
{
return
'
network
:
offline
-
status
-
changed
'
;
}
}
;
function
MockMobileNetworkInfo
(
info
=
{
}
)
{
this
.
_info
=
info
;
}
MockMobileNetworkInfo
.
prototype
=
{
_info
:
null
getNetworkInformation
(
)
{
let
{
mcc
mnc
ip
}
=
this
.
_info
;
return
{
mcc
mnc
ip
}
;
}
getNetworkState
(
callback
)
{
let
{
mcc
mnc
ip
netid
}
=
this
.
_info
;
callback
(
{
mcc
mnc
ip
netid
}
)
;
}
getNetworkStateChangeEventName
(
)
{
return
'
network
-
active
-
changed
'
;
}
}
;
var
setUpServiceInParent
=
Task
.
async
(
function
*
(
service
db
)
{
if
(
!
isParent
)
{
return
;
}
let
userAgentID
=
'
ce704e41
-
cb77
-
4206
-
b07b
-
5bf47114791b
'
;
setPrefs
(
{
userAgentID
:
userAgentID
}
)
;
yield
db
.
put
(
{
channelID
:
'
6e2814e1
-
5f84
-
489e
-
b542
-
855cc1311f09
'
pushEndpoint
:
'
https
:
/
/
example
.
org
/
push
/
get
'
scope
:
'
https
:
/
/
example
.
com
/
get
/
ok
'
originAttributes
:
'
'
version
:
1
pushCount
:
10
lastPush
:
1438360548322
quota
:
16
}
)
;
yield
db
.
put
(
{
channelID
:
'
3a414737
-
2fd0
-
44c0
-
af05
-
7efc172475fc
'
pushEndpoint
:
'
https
:
/
/
example
.
org
/
push
/
unsub
'
scope
:
'
https
:
/
/
example
.
com
/
unsub
/
ok
'
originAttributes
:
'
'
version
:
2
pushCount
:
10
lastPush
:
1438360848322
quota
:
4
}
)
;
yield
db
.
put
(
{
channelID
:
'
ca3054e8
-
b59b
-
4ea0
-
9c23
-
4a3c518f3161
'
pushEndpoint
:
'
https
:
/
/
example
.
org
/
push
/
stale
'
scope
:
'
https
:
/
/
example
.
com
/
unsub
/
fail
'
originAttributes
:
'
'
version
:
3
pushCount
:
10
lastPush
:
1438362348322
quota
:
1
}
)
;
service
.
init
(
{
serverURI
:
'
wss
:
/
/
push
.
example
.
org
/
'
networkInfo
:
new
MockDesktopNetworkInfo
(
)
db
:
makeStub
(
db
{
put
(
prev
record
)
{
if
(
record
.
scope
=
=
'
https
:
/
/
example
.
com
/
sub
/
fail
'
)
{
return
Promise
.
reject
(
'
synergies
not
aligned
'
)
;
}
return
prev
.
call
(
this
record
)
;
}
delete
:
function
(
prev
channelID
)
{
if
(
channelID
=
=
'
ca3054e8
-
b59b
-
4ea0
-
9c23
-
4a3c518f3161
'
)
{
return
Promise
.
reject
(
'
splines
not
reticulated
'
)
;
}
return
prev
.
call
(
this
channelID
)
;
}
getByIdentifiers
(
prev
identifiers
)
{
if
(
identifiers
.
scope
=
=
'
https
:
/
/
example
.
com
/
get
/
fail
'
)
{
return
Promise
.
reject
(
'
qualia
unsynchronized
'
)
;
}
return
prev
.
call
(
this
identifiers
)
;
}
}
)
makeWebSocket
(
uri
)
{
return
new
MockWebSocket
(
uri
{
onHello
(
request
)
{
this
.
serverSendMsg
(
JSON
.
stringify
(
{
messageType
:
'
hello
'
uaid
:
userAgentID
status
:
200
}
)
)
;
}
onRegister
(
request
)
{
this
.
serverSendMsg
(
JSON
.
stringify
(
{
messageType
:
'
register
'
uaid
:
userAgentID
channelID
:
request
.
channelID
status
:
200
pushEndpoint
:
'
https
:
/
/
example
.
org
/
push
/
'
+
request
.
channelID
}
)
)
;
}
}
)
;
}
}
)
;
}
)
;
var
tearDownServiceInParent
=
Task
.
async
(
function
*
(
db
)
{
if
(
!
isParent
)
{
return
;
}
let
record
=
yield
db
.
getByIdentifiers
(
{
scope
:
'
https
:
/
/
example
.
com
/
sub
/
ok
'
originAttributes
:
'
'
}
)
;
ok
(
record
.
pushEndpoint
.
startsWith
(
'
https
:
/
/
example
.
org
/
push
'
)
'
Wrong
push
endpoint
in
subscription
record
'
)
;
record
=
yield
db
.
getByIdentifiers
(
{
scope
:
'
https
:
/
/
example
.
net
/
scope
/
1
'
originAttributes
:
ChromeUtils
.
originAttributesToSuffix
(
{
appId
:
1
inBrowser
:
true
}
)
}
)
;
ok
(
record
.
pushEndpoint
.
startsWith
(
'
https
:
/
/
example
.
org
/
push
'
)
'
Wrong
push
endpoint
in
app
record
'
)
;
record
=
yield
db
.
getByKeyID
(
'
3a414737
-
2fd0
-
44c0
-
af05
-
7efc172475fc
'
)
;
ok
(
!
record
'
Unsubscribed
record
should
not
exist
'
)
;
}
)
;
