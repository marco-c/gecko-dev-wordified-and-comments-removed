"
use
strict
"
;
const
{
XPCOMUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
const
{
Services
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
isParent
=
Services
.
appinfo
.
processType
=
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
XPCOMUtils
.
defineLazyGetter
(
this
"
PushService
"
function
(
)
{
if
(
Services
.
prefs
.
getBoolPref
(
"
dom
.
push
.
enabled
"
)
)
{
const
{
PushService
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushService
.
jsm
"
)
;
PushService
.
init
(
)
;
return
PushService
;
}
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_AVAILABLE
)
;
}
)
;
const
OBSERVER_TOPIC_PUSH
=
"
push
-
message
"
;
const
OBSERVER_TOPIC_SUBSCRIPTION_CHANGE
=
"
push
-
subscription
-
change
"
;
const
OBSERVER_TOPIC_SUBSCRIPTION_MODIFIED
=
"
push
-
subscription
-
modified
"
;
function
PushServiceBase
(
)
{
this
.
wrappedJSObject
=
this
;
this
.
_addListeners
(
)
;
}
PushServiceBase
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
daaa8d73
-
677e
-
4233
-
8acd
-
2c404bd01658
}
"
)
contractID
:
"
mozilla
.
org
/
push
/
Service
;
1
"
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
Ci
.
nsIPushService
Ci
.
nsIPushQuotaManager
Ci
.
nsIPushErrorReporter
]
)
pushTopic
:
OBSERVER_TOPIC_PUSH
subscriptionChangeTopic
:
OBSERVER_TOPIC_SUBSCRIPTION_CHANGE
subscriptionModifiedTopic
:
OBSERVER_TOPIC_SUBSCRIPTION_MODIFIED
ensureReady
(
)
{
}
_addListeners
(
)
{
for
(
let
message
of
this
.
_messages
)
{
this
.
_mm
.
addMessageListener
(
message
this
)
;
}
}
_isValidMessage
(
message
)
{
return
this
.
_messages
.
includes
(
message
.
name
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
android
-
push
-
service
"
)
{
this
.
ensureReady
(
)
;
}
}
_deliverSubscription
(
request
props
)
{
if
(
!
props
)
{
request
.
onPushSubscription
(
Cr
.
NS_OK
null
)
;
return
;
}
request
.
onPushSubscription
(
Cr
.
NS_OK
new
PushSubscription
(
props
)
)
;
}
_deliverSubscriptionError
(
request
error
)
{
let
result
=
typeof
error
.
result
=
=
"
number
"
?
error
.
result
:
Cr
.
NS_ERROR_FAILURE
;
request
.
onPushSubscription
(
result
null
)
;
}
}
;
let
parentInstance
;
function
PushServiceParent
(
)
{
if
(
parentInstance
)
{
return
parentInstance
;
}
parentInstance
=
this
;
PushServiceBase
.
call
(
this
)
;
}
PushServiceParent
.
prototype
=
Object
.
create
(
PushServiceBase
.
prototype
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PushServiceParent
.
prototype
"
_mm
"
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
"
nsISupports
"
)
;
Object
.
assign
(
PushServiceParent
.
prototype
{
_messages
:
[
"
Push
:
Register
"
"
Push
:
Registration
"
"
Push
:
Unregister
"
"
Push
:
Clear
"
"
Push
:
NotificationForOriginShown
"
"
Push
:
NotificationForOriginClosed
"
"
Push
:
ReportError
"
]
subscribe
(
scope
principal
callback
)
{
this
.
subscribeWithKey
(
scope
principal
[
]
callback
)
;
}
subscribeWithKey
(
scope
principal
key
callback
)
{
this
.
_handleRequest
(
"
Push
:
Register
"
principal
{
scope
appServerKey
:
key
}
)
.
then
(
result
=
>
{
this
.
_deliverSubscription
(
callback
result
)
;
}
error
=
>
{
this
.
_deliverSubscriptionError
(
callback
error
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
unsubscribe
(
scope
principal
callback
)
{
this
.
_handleRequest
(
"
Push
:
Unregister
"
principal
{
scope
}
)
.
then
(
result
=
>
{
callback
.
onUnsubscribe
(
Cr
.
NS_OK
result
)
;
}
error
=
>
{
callback
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
getSubscription
(
scope
principal
callback
)
{
return
this
.
_handleRequest
(
"
Push
:
Registration
"
principal
{
scope
}
)
.
then
(
result
=
>
{
this
.
_deliverSubscription
(
callback
result
)
;
}
error
=
>
{
this
.
_deliverSubscriptionError
(
callback
error
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
clearForDomain
(
domain
callback
)
{
return
this
.
_handleRequest
(
"
Push
:
Clear
"
null
{
domain
}
)
.
then
(
result
=
>
{
callback
.
onClear
(
Cr
.
NS_OK
)
;
}
error
=
>
{
callback
.
onClear
(
Cr
.
NS_ERROR_FAILURE
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
notificationForOriginShown
(
origin
)
{
this
.
service
.
notificationForOriginShown
(
origin
)
;
}
notificationForOriginClosed
(
origin
)
{
this
.
service
.
notificationForOriginClosed
(
origin
)
;
}
reportDeliveryError
(
messageId
reason
)
{
this
.
service
.
reportDeliveryError
(
messageId
reason
)
;
}
receiveMessage
(
message
)
{
if
(
!
this
.
_isValidMessage
(
message
)
)
{
return
;
}
let
{
name
target
data
}
=
message
;
if
(
name
=
=
=
"
Push
:
NotificationForOriginShown
"
)
{
this
.
notificationForOriginShown
(
data
)
;
return
;
}
if
(
name
=
=
=
"
Push
:
NotificationForOriginClosed
"
)
{
this
.
notificationForOriginClosed
(
data
)
;
return
;
}
if
(
name
=
=
=
"
Push
:
ReportError
"
)
{
this
.
reportDeliveryError
(
data
.
messageId
data
.
reason
)
;
return
;
}
this
.
_handleRequest
(
name
data
.
principal
data
)
.
then
(
result
=
>
{
target
.
sendAsyncMessage
(
this
.
_getResponseName
(
name
"
OK
"
)
{
requestID
:
data
.
requestID
result
}
)
;
}
error
=
>
{
target
.
sendAsyncMessage
(
this
.
_getResponseName
(
name
"
KO
"
)
{
requestID
:
data
.
requestID
result
:
error
.
result
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
ensureReady
(
)
{
this
.
service
.
init
(
)
;
}
_toPageRecord
(
principal
data
)
{
if
(
!
data
.
scope
)
{
throw
new
Error
(
"
Invalid
page
record
:
missing
scope
"
)
;
}
if
(
!
principal
)
{
throw
new
Error
(
"
Invalid
page
record
:
missing
principal
"
)
;
}
if
(
principal
.
isNullPrincipal
|
|
principal
.
isExpandedPrincipal
)
{
throw
new
Error
(
"
Invalid
page
record
:
unsupported
principal
"
)
;
}
data
.
systemRecord
=
principal
.
isSystemPrincipal
;
data
.
originAttributes
=
ChromeUtils
.
originAttributesToSuffix
(
principal
.
originAttributes
)
;
return
data
;
}
async
_handleRequest
(
name
principal
data
)
{
if
(
name
=
=
"
Push
:
Clear
"
)
{
return
this
.
service
.
clear
(
data
)
;
}
let
pageRecord
;
try
{
pageRecord
=
this
.
_toPageRecord
(
principal
data
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
if
(
name
=
=
=
"
Push
:
Register
"
)
{
return
this
.
service
.
register
(
pageRecord
)
;
}
if
(
name
=
=
=
"
Push
:
Registration
"
)
{
return
this
.
service
.
registration
(
pageRecord
)
;
}
if
(
name
=
=
=
"
Push
:
Unregister
"
)
{
return
this
.
service
.
unregister
(
pageRecord
)
;
}
return
Promise
.
reject
(
new
Error
(
"
Invalid
request
:
unknown
name
"
)
)
;
}
_getResponseName
(
requestName
suffix
)
{
let
name
=
requestName
.
slice
(
"
Push
:
"
.
length
)
;
return
"
PushService
:
"
+
name
+
"
:
"
+
suffix
;
}
replaceServiceBackend
(
options
)
{
return
this
.
service
.
changeTestServer
(
options
.
serverURI
options
)
;
}
restoreServiceBackend
(
)
{
var
defaultServerURL
=
Services
.
prefs
.
getCharPref
(
"
dom
.
push
.
serverURL
"
)
;
return
this
.
service
.
changeTestServer
(
defaultServerURL
)
;
}
}
)
;
Object
.
defineProperty
(
PushServiceParent
.
prototype
"
service
"
{
get
(
)
{
return
this
.
_service
|
|
PushService
;
}
set
(
impl
)
{
this
.
_service
=
impl
;
}
}
)
;
let
contentInstance
;
function
PushServiceContent
(
)
{
if
(
contentInstance
)
{
return
contentInstance
;
}
contentInstance
=
this
;
PushServiceBase
.
apply
(
this
arguments
)
;
this
.
_requests
=
new
Map
(
)
;
this
.
_requestId
=
0
;
}
PushServiceContent
.
prototype
=
Object
.
create
(
PushServiceBase
.
prototype
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PushServiceContent
.
prototype
"
_mm
"
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
"
nsISupports
"
)
;
Object
.
assign
(
PushServiceContent
.
prototype
{
_messages
:
[
"
PushService
:
Register
:
OK
"
"
PushService
:
Register
:
KO
"
"
PushService
:
Registration
:
OK
"
"
PushService
:
Registration
:
KO
"
"
PushService
:
Unregister
:
OK
"
"
PushService
:
Unregister
:
KO
"
"
PushService
:
Clear
:
OK
"
"
PushService
:
Clear
:
KO
"
]
subscribe
(
scope
principal
callback
)
{
this
.
subscribeWithKey
(
scope
principal
[
]
callback
)
;
}
subscribeWithKey
(
scope
principal
key
callback
)
{
let
requestID
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Register
"
{
scope
appServerKey
:
key
requestID
principal
}
)
;
}
unsubscribe
(
scope
principal
callback
)
{
let
requestID
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Unregister
"
{
scope
requestID
principal
}
)
;
}
getSubscription
(
scope
principal
callback
)
{
let
requestID
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Registration
"
{
scope
requestID
principal
}
)
;
}
clearForDomain
(
domain
callback
)
{
let
requestID
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Clear
"
{
domain
requestID
}
)
;
}
notificationForOriginShown
(
origin
)
{
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
NotificationForOriginShown
"
origin
)
;
}
notificationForOriginClosed
(
origin
)
{
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
NotificationForOriginClosed
"
origin
)
;
}
reportDeliveryError
(
messageId
reason
)
{
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
ReportError
"
{
messageId
reason
}
)
;
}
_addRequest
(
data
)
{
let
id
=
+
+
this
.
_requestId
;
this
.
_requests
.
set
(
id
data
)
;
return
id
;
}
_takeRequest
(
requestId
)
{
let
d
=
this
.
_requests
.
get
(
requestId
)
;
this
.
_requests
.
delete
(
requestId
)
;
return
d
;
}
receiveMessage
(
message
)
{
if
(
!
this
.
_isValidMessage
(
message
)
)
{
return
;
}
let
{
name
data
}
=
message
;
let
request
=
this
.
_takeRequest
(
data
.
requestID
)
;
if
(
!
request
)
{
return
;
}
switch
(
name
)
{
case
"
PushService
:
Register
:
OK
"
:
case
"
PushService
:
Registration
:
OK
"
:
this
.
_deliverSubscription
(
request
data
.
result
)
;
break
;
case
"
PushService
:
Register
:
KO
"
:
case
"
PushService
:
Registration
:
KO
"
:
this
.
_deliverSubscriptionError
(
request
data
)
;
break
;
case
"
PushService
:
Unregister
:
OK
"
:
if
(
typeof
data
.
result
=
=
=
"
boolean
"
)
{
request
.
onUnsubscribe
(
Cr
.
NS_OK
data
.
result
)
;
}
else
{
request
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
}
break
;
case
"
PushService
:
Unregister
:
KO
"
:
request
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
break
;
case
"
PushService
:
Clear
:
OK
"
:
request
.
onClear
(
Cr
.
NS_OK
)
;
break
;
case
"
PushService
:
Clear
:
KO
"
:
request
.
onClear
(
Cr
.
NS_ERROR_FAILURE
)
;
break
;
default
:
break
;
}
}
}
)
;
function
PushSubscription
(
props
)
{
this
.
_props
=
props
;
}
PushSubscription
.
prototype
=
{
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIPushSubscription
]
)
get
endpoint
(
)
{
return
this
.
_props
.
endpoint
;
}
get
lastPush
(
)
{
return
this
.
_props
.
lastPush
;
}
get
pushCount
(
)
{
return
this
.
_props
.
pushCount
;
}
get
quota
(
)
{
return
this
.
_props
.
quota
;
}
get
isSystemSubscription
(
)
{
return
!
!
this
.
_props
.
systemRecord
;
}
get
p256dhPrivateKey
(
)
{
return
this
.
_props
.
p256dhPrivateKey
;
}
quotaApplies
(
)
{
return
this
.
quota
>
=
0
;
}
isExpired
(
)
{
return
this
.
quota
=
=
=
0
;
}
getKey
(
name
)
{
switch
(
name
)
{
case
"
p256dh
"
:
return
this
.
_getRawKey
(
this
.
_props
.
p256dhKey
)
;
case
"
auth
"
:
return
this
.
_getRawKey
(
this
.
_props
.
authenticationSecret
)
;
case
"
appServer
"
:
return
this
.
_getRawKey
(
this
.
_props
.
appServerKey
)
;
}
return
[
]
;
}
_getRawKey
(
key
)
{
if
(
!
key
)
{
return
[
]
;
}
return
new
Uint8Array
(
key
)
;
}
}
;
let
Service
=
isParent
?
PushServiceParent
:
PushServiceContent
;
const
EXPORTED_SYMBOLS
=
[
"
Service
"
]
;
