"
use
strict
"
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
var
isParent
=
Services
.
appinfo
.
processType
=
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
function
PushServiceBase
(
)
{
this
.
wrappedJSObject
=
this
;
this
.
_addListeners
(
)
;
}
PushServiceBase
.
prototype
=
{
classID
:
Components
.
ID
(
"
{
daaa8d73
-
677e
-
4233
-
8acd
-
2c404bd01658
}
"
)
contractID
:
"
mozilla
.
org
/
push
/
Service
;
1
"
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIObserver
Ci
.
nsISupportsWeakReference
Ci
.
nsIPushService
Ci
.
nsIPushQuotaManager
]
)
_handleReady
(
)
{
}
_addListeners
(
)
{
for
(
let
message
of
this
.
_messages
)
{
this
.
_mm
.
addMessageListener
(
message
this
)
;
}
}
_isValidMessage
(
message
)
{
return
this
.
_messages
.
includes
(
message
.
name
)
;
}
observe
(
subject
topic
data
)
{
if
(
topic
=
=
=
"
app
-
startup
"
)
{
Services
.
obs
.
addObserver
(
this
"
sessionstore
-
windows
-
restored
"
true
)
;
return
;
}
if
(
topic
=
=
=
"
sessionstore
-
windows
-
restored
"
)
{
Services
.
obs
.
removeObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
this
.
_handleReady
(
)
;
return
;
}
}
_deliverSubscription
(
request
props
)
{
if
(
!
props
)
{
request
.
onPushSubscription
(
Cr
.
NS_OK
null
)
;
return
;
}
request
.
onPushSubscription
(
Cr
.
NS_OK
new
PushSubscription
(
props
)
)
;
}
}
;
function
PushServiceParent
(
)
{
PushServiceBase
.
call
(
this
)
;
}
PushServiceParent
.
prototype
=
Object
.
create
(
PushServiceBase
.
prototype
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PushServiceParent
.
prototype
"
_mm
"
"
mozilla
.
org
/
parentprocessmessagemanager
;
1
"
"
nsIMessageBroadcaster
"
)
;
XPCOMUtils
.
defineLazyGetter
(
PushServiceParent
.
prototype
"
_service
"
function
(
)
{
const
{
PushService
}
=
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
PushService
.
jsm
"
{
}
)
;
PushService
.
init
(
)
;
return
PushService
;
}
)
;
Object
.
assign
(
PushServiceParent
.
prototype
{
_xpcom_factory
:
XPCOMUtils
.
generateSingletonFactory
(
PushServiceParent
)
_messages
:
[
"
Push
:
Register
"
"
Push
:
Registration
"
"
Push
:
Unregister
"
"
Push
:
Clear
"
"
Push
:
NotificationForOriginShown
"
"
Push
:
NotificationForOriginClosed
"
]
subscribe
(
scope
principal
callback
)
{
return
this
.
_handleRequest
(
"
Push
:
Register
"
principal
{
scope
:
scope
}
)
.
then
(
result
=
>
{
this
.
_deliverSubscription
(
callback
result
)
;
}
error
=
>
{
callback
.
onPushSubscription
(
Cr
.
NS_ERROR_FAILURE
null
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
unsubscribe
(
scope
principal
callback
)
{
this
.
_handleRequest
(
"
Push
:
Unregister
"
principal
{
scope
:
scope
}
)
.
then
(
result
=
>
{
callback
.
onUnsubscribe
(
Cr
.
NS_OK
result
)
;
}
error
=
>
{
callback
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
getSubscription
(
scope
principal
callback
)
{
return
this
.
_handleRequest
(
"
Push
:
Registration
"
principal
{
scope
:
scope
}
)
.
then
(
result
=
>
{
this
.
_deliverSubscription
(
callback
result
)
;
}
error
=
>
{
callback
.
onPushSubscription
(
Cr
.
NS_ERROR_FAILURE
null
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
clearForDomain
(
domain
callback
)
{
return
this
.
_handleRequest
(
"
Push
:
Clear
"
null
{
domain
:
domain
}
)
.
then
(
result
=
>
{
callback
.
onClear
(
Cr
.
NS_OK
)
;
}
error
=
>
{
callback
.
onClear
(
Cr
.
NS_ERROR_FAILURE
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
notificationForOriginShown
(
origin
)
{
this
.
_service
.
notificationForOriginShown
(
origin
)
;
}
notificationForOriginClosed
(
origin
)
{
this
.
_service
.
notificationForOriginClosed
(
origin
)
;
}
receiveMessage
(
message
)
{
if
(
!
this
.
_isValidMessage
(
message
)
)
{
return
;
}
let
{
name
principal
target
data
}
=
message
;
if
(
name
=
=
=
"
Push
:
NotificationForOriginShown
"
)
{
this
.
notificationForOriginShown
(
data
)
;
return
;
}
if
(
name
=
=
=
"
Push
:
NotificationForOriginClosed
"
)
{
this
.
notificationForOriginClosed
(
data
)
;
return
;
}
if
(
!
target
.
assertPermission
(
"
push
"
)
)
{
return
;
}
let
sender
=
target
.
QueryInterface
(
Ci
.
nsIMessageSender
)
;
return
this
.
_handleRequest
(
name
principal
data
)
.
then
(
result
=
>
{
sender
.
sendAsyncMessage
(
this
.
_getResponseName
(
name
"
OK
"
)
{
requestID
:
data
.
requestID
result
:
result
}
)
;
}
error
=
>
{
sender
.
sendAsyncMessage
(
this
.
_getResponseName
(
name
"
KO
"
)
{
requestID
:
data
.
requestID
}
)
;
}
)
.
catch
(
Cu
.
reportError
)
;
}
_handleReady
(
)
{
this
.
_service
.
init
(
)
;
}
_toPageRecord
(
principal
data
)
{
if
(
!
data
.
scope
)
{
throw
new
Error
(
"
Invalid
page
record
:
missing
scope
"
)
;
}
if
(
!
principal
)
{
throw
new
Error
(
"
Invalid
page
record
:
missing
principal
"
)
;
}
if
(
principal
.
isNullPrincipal
|
|
principal
.
isExpandedPrincipal
)
{
throw
new
Error
(
"
Invalid
page
record
:
unsupported
principal
"
)
;
}
data
.
systemRecord
=
principal
.
isSystemPrincipal
;
data
.
originAttributes
=
ChromeUtils
.
originAttributesToSuffix
(
principal
.
originAttributes
)
;
return
data
;
}
_handleRequest
(
name
principal
data
)
{
if
(
name
=
=
"
Push
:
Clear
"
)
{
return
this
.
_service
.
clear
(
data
)
;
}
let
pageRecord
;
try
{
pageRecord
=
this
.
_toPageRecord
(
principal
data
)
;
}
catch
(
e
)
{
return
Promise
.
reject
(
e
)
;
}
if
(
name
=
=
=
"
Push
:
Register
"
)
{
return
this
.
_service
.
register
(
pageRecord
)
;
}
if
(
name
=
=
=
"
Push
:
Registration
"
)
{
return
this
.
_service
.
registration
(
pageRecord
)
;
}
if
(
name
=
=
=
"
Push
:
Unregister
"
)
{
return
this
.
_service
.
unregister
(
pageRecord
)
;
}
return
Promise
.
reject
(
new
Error
(
"
Invalid
request
:
unknown
name
"
)
)
;
}
_getResponseName
(
requestName
suffix
)
{
let
name
=
requestName
.
slice
(
"
Push
:
"
.
length
)
;
return
"
PushService
:
"
+
name
+
"
:
"
+
suffix
;
}
}
)
;
function
PushServiceContent
(
)
{
PushServiceBase
.
apply
(
this
arguments
)
;
this
.
_requests
=
new
Map
(
)
;
this
.
_requestId
=
0
;
}
PushServiceContent
.
prototype
=
Object
.
create
(
PushServiceBase
.
prototype
)
;
XPCOMUtils
.
defineLazyServiceGetter
(
PushServiceContent
.
prototype
"
_mm
"
"
mozilla
.
org
/
childprocessmessagemanager
;
1
"
"
nsISyncMessageSender
"
)
;
Object
.
assign
(
PushServiceContent
.
prototype
{
_xpcom_factory
:
XPCOMUtils
.
generateSingletonFactory
(
PushServiceContent
)
_messages
:
[
"
PushService
:
Register
:
OK
"
"
PushService
:
Register
:
KO
"
"
PushService
:
Registration
:
OK
"
"
PushService
:
Registration
:
KO
"
"
PushService
:
Unregister
:
OK
"
"
PushService
:
Unregister
:
KO
"
"
PushService
:
Clear
:
OK
"
"
PushService
:
Clear
:
KO
"
]
subscribe
(
scope
principal
callback
)
{
let
requestId
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Register
"
{
scope
:
scope
requestID
:
requestId
}
null
principal
)
;
}
unsubscribe
(
scope
principal
callback
)
{
let
requestId
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Unregister
"
{
scope
:
scope
requestID
:
requestId
}
null
principal
)
;
}
getSubscription
(
scope
principal
callback
)
{
let
requestId
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Registration
"
{
scope
:
scope
requestID
:
requestId
}
null
principal
)
;
}
clearForDomain
(
domain
callback
)
{
let
requestId
=
this
.
_addRequest
(
callback
)
;
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
Clear
"
{
domain
:
domain
requestID
:
requestId
}
)
;
}
notificationForOriginShown
(
origin
)
{
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
NotificationForOriginShown
"
origin
)
;
}
notificationForOriginClosed
(
origin
)
{
this
.
_mm
.
sendAsyncMessage
(
"
Push
:
NotificationForOriginClosed
"
origin
)
;
}
_addRequest
(
data
)
{
let
id
=
+
+
this
.
_requestId
;
this
.
_requests
.
set
(
id
data
)
;
return
id
;
}
_takeRequest
(
requestId
)
{
let
d
=
this
.
_requests
.
get
(
requestId
)
;
this
.
_requests
.
delete
(
requestId
)
;
return
d
;
}
receiveMessage
(
message
)
{
if
(
!
this
.
_isValidMessage
(
message
)
)
{
return
;
}
let
{
name
data
}
=
message
;
let
request
=
this
.
_takeRequest
(
data
.
requestID
)
;
if
(
!
request
)
{
return
;
}
switch
(
name
)
{
case
"
PushService
:
Register
:
OK
"
:
case
"
PushService
:
Registration
:
OK
"
:
this
.
_deliverSubscription
(
request
data
.
result
)
;
break
;
case
"
PushService
:
Register
:
KO
"
:
case
"
PushService
:
Registration
:
KO
"
:
request
.
onPushSubscription
(
Cr
.
NS_ERROR_FAILURE
null
)
;
break
;
case
"
PushService
:
Unregister
:
OK
"
:
if
(
typeof
data
.
result
=
=
=
"
boolean
"
)
{
request
.
onUnsubscribe
(
Cr
.
NS_OK
data
.
result
)
;
}
else
{
request
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
}
break
;
case
"
PushService
:
Unregister
:
KO
"
:
request
.
onUnsubscribe
(
Cr
.
NS_ERROR_FAILURE
false
)
;
break
;
case
"
PushService
:
Clear
:
OK
"
:
request
.
onClear
(
Cr
.
NS_OK
)
;
break
;
case
"
PushService
:
Clear
:
KO
"
:
request
.
onClear
(
Cr
.
NS_ERROR_FAILURE
)
;
break
;
default
:
break
;
}
}
}
)
;
function
PushSubscription
(
props
)
{
this
.
_props
=
props
;
}
PushSubscription
.
prototype
=
{
QueryInterface
:
XPCOMUtils
.
generateQI
(
[
Ci
.
nsIPushSubscription
]
)
get
endpoint
(
)
{
return
this
.
_props
.
endpoint
;
}
get
lastPush
(
)
{
return
this
.
_props
.
lastPush
;
}
get
pushCount
(
)
{
return
this
.
_props
.
pushCount
;
}
get
quota
(
)
{
return
this
.
_props
.
quota
;
}
quotaApplies
(
)
{
return
this
.
quota
>
=
0
;
}
isExpired
(
)
{
return
this
.
quota
=
=
=
0
;
}
getKey
(
name
outKeyLen
)
{
if
(
name
=
=
=
"
p256dh
"
)
{
return
this
.
_getRawKey
(
this
.
_props
.
p256dhKey
outKeyLen
)
;
}
if
(
name
=
=
=
"
auth
"
)
{
return
this
.
_getRawKey
(
this
.
_props
.
authenticationSecret
outKeyLen
)
;
}
return
null
;
}
_getRawKey
(
key
outKeyLen
)
{
if
(
!
key
)
{
return
null
;
}
let
rawKey
=
new
Uint8Array
(
key
)
;
if
(
outKeyLen
)
{
outKeyLen
.
value
=
rawKey
.
length
;
}
return
rawKey
;
}
}
;
this
.
NSGetFactory
=
XPCOMUtils
.
generateNSGetFactory
(
[
isParent
?
PushServiceParent
:
PushServiceContent
]
)
;
