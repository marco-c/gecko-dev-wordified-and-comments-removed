'
use
strict
'
;
const
Cu
=
Components
.
utils
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
Cu
.
import
(
'
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
'
)
;
XPCOMUtils
.
defineLazyGetter
(
this
'
gDOMBundle
'
(
)
=
>
Services
.
strings
.
createBundle
(
'
chrome
:
/
/
global
/
locale
/
dom
/
dom
.
properties
'
)
)
;
Cu
.
importGlobalProperties
(
[
'
crypto
'
]
)
;
this
.
EXPORTED_SYMBOLS
=
[
'
PushCrypto
'
'
concatArray
'
]
;
var
UTF8
=
new
TextEncoder
(
'
utf
-
8
'
)
;
var
AESGCM128_ENCODING
=
'
aesgcm128
'
;
var
AESGCM128_ENCRYPT_INFO
=
UTF8
.
encode
(
'
Content
-
Encoding
:
aesgcm128
'
)
;
var
AESGCM_ENCODING
=
'
aesgcm
'
;
var
AESGCM_ENCRYPT_INFO
=
UTF8
.
encode
(
'
Content
-
Encoding
:
aesgcm
'
)
;
var
NONCE_INFO
=
UTF8
.
encode
(
'
Content
-
Encoding
:
nonce
'
)
;
var
AUTH_INFO
=
UTF8
.
encode
(
'
Content
-
Encoding
:
auth
\
0
'
)
;
var
P256DH_INFO
=
UTF8
.
encode
(
'
P
-
256
\
0
'
)
;
var
ECDH_KEY
=
{
name
:
'
ECDH
'
namedCurve
:
'
P
-
256
'
}
;
var
ECDSA_KEY
=
{
name
:
'
ECDSA
'
namedCurve
:
'
P
-
256
'
}
;
var
DEFAULT_KEYID
=
'
'
;
const
BAD_ENCRYPTION_HEADER
=
'
PushMessageBadEncryptionHeader
'
;
const
BAD_CRYPTO_KEY_HEADER
=
'
PushMessageBadCryptoKeyHeader
'
;
const
BAD_ENCRYPTION_KEY_HEADER
=
'
PushMessageBadEncryptionKeyHeader
'
;
const
BAD_ENCODING_HEADER
=
'
PushMessageBadEncodingHeader
'
;
const
BAD_DH_PARAM
=
'
PushMessageBadSenderKey
'
;
const
BAD_SALT_PARAM
=
'
PushMessageBadSalt
'
;
const
BAD_RS_PARAM
=
'
PushMessageBadRecordSize
'
;
const
BAD_PADDING
=
'
PushMessageBadPaddingError
'
;
const
BAD_CRYPTO
=
'
PushMessageBadCryptoError
'
;
class
CryptoError
extends
Error
{
constructor
(
message
property
.
.
.
params
)
{
super
(
message
)
;
this
.
isCryptoError
=
true
;
this
.
property
=
property
;
this
.
params
=
params
;
}
format
(
scope
)
{
let
params
=
[
scope
.
.
.
this
.
params
]
.
map
(
String
)
;
return
gDOMBundle
.
formatStringFromName
(
this
.
property
params
params
.
length
)
;
}
}
function
getEncryptionKeyParams
(
encryptKeyField
)
{
if
(
!
encryptKeyField
)
{
return
null
;
}
var
params
=
encryptKeyField
.
split
(
'
'
)
;
return
params
.
reduce
(
(
m
p
)
=
>
{
var
pmap
=
p
.
split
(
'
;
'
)
.
reduce
(
parseHeaderFieldParams
{
}
)
;
if
(
pmap
.
keyid
&
&
pmap
.
dh
)
{
m
[
pmap
.
keyid
]
=
pmap
.
dh
;
}
if
(
!
m
[
DEFAULT_KEYID
]
&
&
pmap
.
dh
)
{
m
[
DEFAULT_KEYID
]
=
pmap
.
dh
;
}
return
m
;
}
{
}
)
;
}
function
getEncryptionParams
(
encryptField
)
{
if
(
!
encryptField
)
{
throw
new
CryptoError
(
'
Missing
encryption
header
'
BAD_ENCRYPTION_HEADER
)
;
}
var
p
=
encryptField
.
split
(
'
'
1
)
[
0
]
;
if
(
!
p
)
{
throw
new
CryptoError
(
'
Encryption
header
missing
params
'
BAD_ENCRYPTION_HEADER
)
;
}
return
p
.
split
(
'
;
'
)
.
reduce
(
parseHeaderFieldParams
{
}
)
;
}
function
getCryptoParams
(
headers
)
{
if
(
!
headers
)
{
return
null
;
}
var
keymap
;
var
padSize
;
if
(
!
headers
.
encoding
)
{
throw
new
CryptoError
(
'
Missing
Content
-
Encoding
header
'
BAD_ENCODING_HEADER
)
;
}
if
(
headers
.
encoding
=
=
AESGCM_ENCODING
)
{
keymap
=
getEncryptionKeyParams
(
headers
.
crypto_key
)
;
if
(
!
keymap
)
{
throw
new
CryptoError
(
'
Missing
Crypto
-
Key
header
'
BAD_CRYPTO_KEY_HEADER
)
;
}
padSize
=
2
;
}
else
if
(
headers
.
encoding
=
=
AESGCM128_ENCODING
)
{
keymap
=
getEncryptionKeyParams
(
headers
.
encryption_key
)
;
if
(
!
keymap
)
{
throw
new
CryptoError
(
'
Missing
Encryption
-
Key
header
'
BAD_ENCRYPTION_KEY_HEADER
)
;
}
padSize
=
1
;
}
else
{
throw
new
CryptoError
(
'
Unsupported
Content
-
Encoding
:
'
+
headers
.
encoding
BAD_ENCODING_HEADER
)
;
}
var
enc
=
getEncryptionParams
(
headers
.
encryption
)
;
var
dh
=
keymap
[
enc
.
keyid
|
|
DEFAULT_KEYID
]
;
if
(
!
dh
)
{
throw
new
CryptoError
(
'
Missing
dh
parameter
'
BAD_DH_PARAM
)
;
}
var
salt
=
enc
.
salt
;
if
(
!
salt
)
{
throw
new
CryptoError
(
'
Missing
salt
parameter
'
BAD_SALT_PARAM
)
;
}
var
rs
=
enc
.
rs
?
parseInt
(
enc
.
rs
10
)
:
4096
;
if
(
isNaN
(
rs
)
)
{
throw
new
CryptoError
(
'
rs
parameter
must
be
a
number
'
BAD_RS_PARAM
)
;
}
if
(
rs
<
=
padSize
)
{
throw
new
CryptoError
(
'
rs
parameter
must
be
at
least
'
+
padSize
BAD_RS_PARAM
padSize
)
;
}
return
{
dh
salt
rs
padSize
}
;
}
function
base64URLDecode
(
string
)
{
try
{
return
ChromeUtils
.
base64URLDecode
(
string
{
padding
:
'
reject
'
}
)
;
}
catch
(
ex
)
{
}
return
null
;
}
var
parseHeaderFieldParams
=
(
m
v
)
=
>
{
var
i
=
v
.
indexOf
(
'
=
'
)
;
if
(
i
>
=
0
)
{
m
[
v
.
substring
(
0
i
)
.
trim
(
)
]
=
v
.
substring
(
i
+
1
)
.
trim
(
)
.
replace
(
/
^
"
(
.
*
)
"
/
'
1
'
)
;
}
return
m
;
}
;
function
chunkArray
(
array
size
)
{
var
start
=
array
.
byteOffset
|
|
0
;
array
=
array
.
buffer
|
|
array
;
var
index
=
0
;
var
result
=
[
]
;
while
(
index
+
size
<
=
array
.
byteLength
)
{
result
.
push
(
new
Uint8Array
(
array
start
+
index
size
)
)
;
index
+
=
size
;
}
if
(
index
<
array
.
byteLength
)
{
result
.
push
(
new
Uint8Array
(
array
start
+
index
)
)
;
}
return
result
;
}
this
.
concatArray
=
function
(
arrays
)
{
var
size
=
arrays
.
reduce
(
(
total
a
)
=
>
total
+
a
.
byteLength
0
)
;
var
index
=
0
;
return
arrays
.
reduce
(
(
result
a
)
=
>
{
result
.
set
(
new
Uint8Array
(
a
)
index
)
;
index
+
=
a
.
byteLength
;
return
result
;
}
new
Uint8Array
(
size
)
)
;
}
;
var
HMAC_SHA256
=
{
name
:
'
HMAC
'
hash
:
'
SHA
-
256
'
}
;
function
hmac
(
key
)
{
this
.
keyPromise
=
crypto
.
subtle
.
importKey
(
'
raw
'
key
HMAC_SHA256
false
[
'
sign
'
]
)
;
}
hmac
.
prototype
.
hash
=
function
(
input
)
{
return
this
.
keyPromise
.
then
(
k
=
>
crypto
.
subtle
.
sign
(
'
HMAC
'
k
input
)
)
;
}
;
function
hkdf
(
salt
ikm
)
{
this
.
prkhPromise
=
new
hmac
(
salt
)
.
hash
(
ikm
)
.
then
(
prk
=
>
new
hmac
(
prk
)
)
;
}
hkdf
.
prototype
.
extract
=
function
(
info
len
)
{
var
input
=
concatArray
(
[
info
new
Uint8Array
(
[
1
]
)
]
)
;
return
this
.
prkhPromise
.
then
(
prkh
=
>
prkh
.
hash
(
input
)
)
.
then
(
h
=
>
{
if
(
h
.
byteLength
<
len
)
{
throw
new
CryptoError
(
'
HKDF
length
is
too
long
'
BAD_CRYPTO
)
;
}
return
h
.
slice
(
0
len
)
;
}
)
;
}
;
function
generateNonce
(
base
index
)
{
if
(
index
>
=
Math
.
pow
(
2
48
)
)
{
throw
new
CryptoError
(
'
Nonce
index
is
too
large
'
BAD_CRYPTO
)
;
}
var
nonce
=
base
.
slice
(
0
12
)
;
nonce
=
new
Uint8Array
(
nonce
)
;
for
(
var
i
=
0
;
i
<
6
;
+
+
i
)
{
nonce
[
nonce
.
byteLength
-
1
-
i
]
^
=
(
index
/
Math
.
pow
(
256
i
)
)
&
0xff
;
}
return
nonce
;
}
this
.
PushCrypto
=
{
generateAuthenticationSecret
(
)
{
return
crypto
.
getRandomValues
(
new
Uint8Array
(
16
)
)
;
}
validateAppServerKey
(
key
)
{
return
crypto
.
subtle
.
importKey
(
'
raw
'
key
ECDSA_KEY
true
[
'
verify
'
]
)
.
then
(
_
=
>
key
)
;
}
generateKeys
(
)
{
return
crypto
.
subtle
.
generateKey
(
ECDH_KEY
true
[
'
deriveBits
'
]
)
.
then
(
cryptoKey
=
>
Promise
.
all
(
[
crypto
.
subtle
.
exportKey
(
'
raw
'
cryptoKey
.
publicKey
)
crypto
.
subtle
.
exportKey
(
'
jwk
'
cryptoKey
.
privateKey
)
]
)
)
;
}
decrypt
(
privateKey
publicKey
authenticationSecret
headers
ciphertext
)
{
return
Promise
.
resolve
(
)
.
then
(
_
=
>
{
let
cryptoParams
=
getCryptoParams
(
headers
)
;
if
(
!
cryptoParams
)
{
return
null
;
}
return
this
.
_decodeMsg
(
ciphertext
privateKey
publicKey
cryptoParams
.
dh
cryptoParams
.
salt
cryptoParams
.
rs
authenticationSecret
cryptoParams
.
padSize
)
;
}
)
.
catch
(
error
=
>
{
if
(
error
.
isCryptoError
)
{
throw
error
;
}
throw
new
CryptoError
(
'
Bad
encryption
'
BAD_CRYPTO
)
;
}
)
;
}
_decodeMsg
(
aData
aPrivateKey
aPublicKey
aSenderPublicKey
aSalt
aRs
aAuthenticationSecret
aPadSize
)
{
if
(
aData
.
byteLength
=
=
=
0
)
{
return
null
;
}
if
(
aData
.
byteLength
%
(
aRs
+
16
)
=
=
=
0
)
{
throw
new
CryptoError
(
'
Encrypted
data
truncated
'
BAD_CRYPTO
)
;
}
let
senderKey
=
base64URLDecode
(
aSenderPublicKey
)
;
if
(
!
senderKey
)
{
throw
new
CryptoError
(
'
dh
parameter
is
not
base64url
-
encoded
'
BAD_DH_PARAM
)
;
}
let
salt
=
base64URLDecode
(
aSalt
)
;
if
(
!
salt
)
{
throw
new
CryptoError
(
'
salt
parameter
is
not
base64url
-
encoded
'
BAD_SALT_PARAM
)
;
}
return
Promise
.
all
(
[
crypto
.
subtle
.
importKey
(
'
raw
'
senderKey
ECDH_KEY
false
[
'
deriveBits
'
]
)
crypto
.
subtle
.
importKey
(
'
jwk
'
aPrivateKey
ECDH_KEY
false
[
'
deriveBits
'
]
)
]
)
.
then
(
(
[
appServerKey
subscriptionPrivateKey
]
)
=
>
crypto
.
subtle
.
deriveBits
(
{
name
:
'
ECDH
'
public
:
appServerKey
}
subscriptionPrivateKey
256
)
)
.
then
(
ikm
=
>
this
.
_deriveKeyAndNonce
(
aPadSize
new
Uint8Array
(
ikm
)
salt
aPublicKey
senderKey
aAuthenticationSecret
)
)
.
then
(
r
=
>
Promise
.
all
(
chunkArray
(
aData
aRs
+
16
)
.
map
(
(
slice
index
)
=
>
this
.
_decodeChunk
(
aPadSize
slice
index
r
[
1
]
r
[
0
]
)
)
)
)
.
then
(
r
=
>
concatArray
(
r
)
)
;
}
_deriveKeyAndNonce
(
padSize
ikm
salt
receiverKey
senderKey
authenticationSecret
)
{
var
kdfPromise
;
var
context
;
var
encryptInfo
;
if
(
padSize
=
=
2
)
{
var
authKdf
=
new
hkdf
(
authenticationSecret
ikm
)
;
kdfPromise
=
authKdf
.
extract
(
AUTH_INFO
32
)
.
then
(
ikm2
=
>
new
hkdf
(
salt
ikm2
)
)
;
context
=
concatArray
(
[
new
Uint8Array
(
[
0
]
)
P256DH_INFO
this
.
_encodeLength
(
receiverKey
)
receiverKey
this
.
_encodeLength
(
senderKey
)
senderKey
]
)
;
encryptInfo
=
AESGCM_ENCRYPT_INFO
;
}
else
{
kdfPromise
=
Promise
.
resolve
(
new
hkdf
(
salt
ikm
)
)
;
context
=
new
Uint8Array
(
0
)
;
encryptInfo
=
AESGCM128_ENCRYPT_INFO
;
}
return
kdfPromise
.
then
(
kdf
=
>
Promise
.
all
(
[
kdf
.
extract
(
concatArray
(
[
encryptInfo
context
]
)
16
)
.
then
(
gcmBits
=
>
crypto
.
subtle
.
importKey
(
'
raw
'
gcmBits
'
AES
-
GCM
'
false
[
'
decrypt
'
]
)
)
kdf
.
extract
(
concatArray
(
[
NONCE_INFO
context
]
)
12
)
]
)
)
;
}
_encodeLength
(
buffer
)
{
return
new
Uint8Array
(
[
0
buffer
.
byteLength
]
)
;
}
_decodeChunk
(
aPadSize
aSlice
aIndex
aNonce
aKey
)
{
let
params
=
{
name
:
'
AES
-
GCM
'
iv
:
generateNonce
(
aNonce
aIndex
)
}
;
return
crypto
.
subtle
.
decrypt
(
params
aKey
aSlice
)
.
then
(
decoded
=
>
this
.
_unpadChunk
(
aPadSize
new
Uint8Array
(
decoded
)
)
)
;
}
_unpadChunk
(
padSize
decoded
)
{
if
(
padSize
<
1
|
|
padSize
>
2
)
{
throw
new
CryptoError
(
'
Unsupported
pad
size
'
BAD_CRYPTO
)
;
}
if
(
decoded
.
length
<
padSize
)
{
throw
new
CryptoError
(
'
Decoded
array
is
too
short
!
'
BAD_PADDING
padSize
)
;
}
var
pad
=
decoded
[
0
]
;
if
(
padSize
=
=
2
)
{
pad
=
(
pad
<
<
8
)
|
decoded
[
1
]
;
}
if
(
pad
>
decoded
.
length
)
{
throw
new
CryptoError
(
'
Padding
is
wrong
!
'
BAD_PADDING
padSize
)
;
}
for
(
var
i
=
padSize
;
i
<
=
pad
;
i
+
+
)
{
if
(
decoded
[
i
]
!
=
=
0
)
{
throw
new
CryptoError
(
'
Padding
is
wrong
!
'
BAD_PADDING
padSize
)
;
}
}
return
decoded
.
slice
(
pad
+
padSize
)
;
}
}
;
