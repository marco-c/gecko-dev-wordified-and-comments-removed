#
include
"
txExecutionState
.
h
"
#
include
"
txInstructions
.
h
"
#
include
"
txLog
.
h
"
#
include
"
txRtfHandler
.
h
"
#
include
"
txSingleNodeContext
.
h
"
#
include
"
txStylesheet
.
h
"
#
include
"
txURIUtils
.
h
"
#
include
"
txVariableMap
.
h
"
#
include
"
txXMLParser
.
h
"
#
include
"
txXSLTProcessor
.
h
"
using
namespace
mozilla
;
const
int32_t
txExecutionState
:
:
kMaxRecursionDepth
=
20000
;
nsresult
txLoadedDocumentsHash
:
:
init
(
const
txXPathNode
&
aSource
)
{
mSourceDocument
=
Some
(
txXPathNodeUtils
:
:
getOwnerDocument
(
aSource
)
)
;
nsAutoString
baseURI
;
nsresult
rv
=
txXPathNodeUtils
:
:
getBaseURI
(
*
mSourceDocument
baseURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
WithEntryHandle
(
baseURI
[
&
aSource
]
(
auto
&
&
entry
)
{
entry
.
Insert
(
txLoadedDocumentEntry
{
txXPathNode
(
aSource
)
}
)
;
}
)
;
return
NS_OK
;
}
txExecutionState
:
:
txExecutionState
(
txStylesheet
*
aStylesheet
bool
aDisableLoads
)
:
mOutputHandler
(
nullptr
)
mResultHandler
(
nullptr
)
mOutputHandlerFactory
(
nullptr
)
mStylesheet
(
aStylesheet
)
mNextInstruction
(
nullptr
)
mLocalVariables
(
nullptr
)
mRecursionDepth
(
0
)
mEvalContext
(
nullptr
)
mInitialEvalContext
(
nullptr
)
mGlobalParams
(
nullptr
)
mKeyHash
(
aStylesheet
-
>
getKeyMap
(
)
)
mDisableLoads
(
aDisableLoads
)
{
MOZ_COUNT_CTOR
(
txExecutionState
)
;
}
txExecutionState
:
:
~
txExecutionState
(
)
{
MOZ_COUNT_DTOR
(
txExecutionState
)
;
delete
mResultHandler
;
delete
mLocalVariables
;
if
(
mEvalContext
!
=
mInitialEvalContext
)
{
delete
mEvalContext
;
}
txStackIterator
varsIter
(
&
mLocalVarsStack
)
;
while
(
varsIter
.
hasNext
(
)
)
{
delete
(
txVariableMap
*
)
varsIter
.
next
(
)
;
}
txStackIterator
contextIter
(
&
mEvalContextStack
)
;
while
(
contextIter
.
hasNext
(
)
)
{
txIEvalContext
*
context
=
(
txIEvalContext
*
)
contextIter
.
next
(
)
;
if
(
context
!
=
mInitialEvalContext
)
{
delete
context
;
}
}
txStackIterator
handlerIter
(
&
mResultHandlerStack
)
;
while
(
handlerIter
.
hasNext
(
)
)
{
delete
(
txAXMLEventHandler
*
)
handlerIter
.
next
(
)
;
}
delete
mInitialEvalContext
;
}
nsresult
txExecutionState
:
:
init
(
const
txXPathNode
&
aNode
txOwningExpandedNameMap
<
txIGlobalParameter
>
*
aGlobalParams
)
{
nsresult
rv
=
NS_OK
;
mGlobalParams
=
aGlobalParams
;
mEvalContext
=
new
txSingleNodeContext
(
aNode
this
)
;
mInitialEvalContext
=
mEvalContext
;
txAXMLEventHandler
*
handler
;
rv
=
mOutputHandlerFactory
-
>
createHandlerWith
(
mStylesheet
-
>
getOutputFormat
(
)
&
handler
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mOutputHandler
=
handler
;
mResultHandler
=
handler
;
mOutputHandler
-
>
startDocument
(
)
;
rv
=
mLoadedDocuments
.
init
(
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mKeyHash
.
init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mRecycler
=
new
txResultRecycler
;
mGlobalVarPlaceholderValue
=
new
StringResult
(
u
"
Error
"
_ns
nullptr
)
;
txStylesheet
:
:
ImportFrame
*
frame
=
0
;
txExpandedName
nullName
;
txInstruction
*
templ
;
rv
=
mStylesheet
-
>
findTemplate
(
aNode
nullName
this
nullptr
&
templ
&
frame
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
pushTemplateRule
(
frame
nullName
nullptr
)
;
return
runTemplate
(
templ
)
;
}
nsresult
txExecutionState
:
:
end
(
nsresult
aResult
)
{
NS_ASSERTION
(
NS_FAILED
(
aResult
)
|
|
mTemplateRules
.
Length
(
)
=
=
1
"
Didn
'
t
clean
up
template
rules
properly
"
)
;
if
(
NS_SUCCEEDED
(
aResult
)
)
{
popTemplateRule
(
)
;
}
else
if
(
!
mOutputHandler
)
{
return
NS_OK
;
}
return
mOutputHandler
-
>
endDocument
(
aResult
)
;
}
void
txExecutionState
:
:
popAndDeleteEvalContextUntil
(
txIEvalContext
*
aContext
)
{
auto
ctx
=
popEvalContext
(
)
;
while
(
ctx
&
&
ctx
!
=
aContext
)
{
MOZ_RELEASE_ASSERT
(
ctx
!
=
mInitialEvalContext
)
;
delete
ctx
;
ctx
=
popEvalContext
(
)
;
}
}
nsresult
txExecutionState
:
:
getVariable
(
int32_t
aNamespace
nsAtom
*
aLName
txAExprResult
*
&
aResult
)
{
nsresult
rv
=
NS_OK
;
txExpandedName
name
(
aNamespace
aLName
)
;
if
(
mLocalVariables
)
{
mLocalVariables
-
>
getVariable
(
name
&
aResult
)
;
if
(
aResult
)
{
return
NS_OK
;
}
}
mGlobalVariableValues
.
getVariable
(
name
&
aResult
)
;
if
(
aResult
)
{
if
(
aResult
=
=
mGlobalVarPlaceholderValue
)
{
NS_RELEASE
(
aResult
)
;
return
NS_ERROR_XSLT_BAD_RECURSION
;
}
return
NS_OK
;
}
txStylesheet
:
:
GlobalVariable
*
var
=
mStylesheet
-
>
getGlobalVariable
(
name
)
;
if
(
!
var
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
(
var
-
>
mExpr
&
&
!
var
-
>
mFirstInstruction
)
|
|
(
!
var
-
>
mExpr
&
&
var
-
>
mFirstInstruction
)
"
global
variable
should
have
either
instruction
or
expression
"
)
;
if
(
var
-
>
mIsParam
&
&
mGlobalParams
)
{
txIGlobalParameter
*
param
=
mGlobalParams
-
>
get
(
name
)
;
if
(
param
)
{
rv
=
param
-
>
getValue
(
&
aResult
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mGlobalVariableValues
.
bindVariable
(
name
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
aResult
)
;
return
rv
;
}
return
NS_OK
;
}
}
rv
=
mGlobalVariableValues
.
bindVariable
(
name
mGlobalVarPlaceholderValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
pushEvalContext
(
mInitialEvalContext
)
;
if
(
var
-
>
mExpr
)
{
txVariableMap
*
oldVars
=
mLocalVariables
;
mLocalVariables
=
nullptr
;
rv
=
var
-
>
mExpr
-
>
evaluate
(
getEvalContext
(
)
&
aResult
)
;
mLocalVariables
=
oldVars
;
if
(
NS_FAILED
(
rv
)
)
{
popAndDeleteEvalContextUntil
(
mInitialEvalContext
)
;
return
rv
;
}
}
else
{
pushResultHandler
(
new
txRtfHandler
)
;
txInstruction
*
prevInstr
=
mNextInstruction
;
mNextInstruction
=
nullptr
;
rv
=
runTemplate
(
var
-
>
mFirstInstruction
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
popAndDeleteEvalContextUntil
(
mInitialEvalContext
)
;
return
rv
;
}
pushTemplateRule
(
nullptr
txExpandedName
(
)
nullptr
)
;
rv
=
txXSLTProcessor
:
:
execute
(
*
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
popAndDeleteEvalContextUntil
(
mInitialEvalContext
)
;
return
rv
;
}
popTemplateRule
(
)
;
mNextInstruction
=
prevInstr
;
UniquePtr
<
txRtfHandler
>
rtfHandler
(
static_cast
<
txRtfHandler
*
>
(
popResultHandler
(
)
)
)
;
rv
=
rtfHandler
-
>
getAsRTF
(
&
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
popAndDeleteEvalContextUntil
(
mInitialEvalContext
)
;
return
rv
;
}
}
popEvalContext
(
)
;
mGlobalVariableValues
.
removeVariable
(
name
)
;
rv
=
mGlobalVariableValues
.
bindVariable
(
name
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
aResult
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
txExecutionState
:
:
isStripSpaceAllowed
(
const
txXPathNode
&
aNode
bool
&
aAllowed
)
{
return
mStylesheet
-
>
isStripSpaceAllowed
(
aNode
this
aAllowed
)
;
}
void
*
txExecutionState
:
:
getPrivateContext
(
)
{
return
this
;
}
txResultRecycler
*
txExecutionState
:
:
recycler
(
)
{
return
mRecycler
;
}
void
txExecutionState
:
:
receiveError
(
const
nsAString
&
aMsg
nsresult
aRes
)
{
}
void
txExecutionState
:
:
pushEvalContext
(
txIEvalContext
*
aContext
)
{
mEvalContextStack
.
push
(
mEvalContext
)
;
mEvalContext
=
aContext
;
}
txIEvalContext
*
txExecutionState
:
:
popEvalContext
(
)
{
txIEvalContext
*
prev
=
mEvalContext
;
mEvalContext
=
(
txIEvalContext
*
)
mEvalContextStack
.
pop
(
)
;
return
prev
;
}
void
txExecutionState
:
:
pushBool
(
bool
aBool
)
{
mBoolStack
.
AppendElement
(
aBool
)
;
}
bool
txExecutionState
:
:
popBool
(
)
{
NS_ASSERTION
(
mBoolStack
.
Length
(
)
"
popping
from
empty
stack
"
)
;
return
mBoolStack
.
IsEmpty
(
)
?
false
:
mBoolStack
.
PopLastElement
(
)
;
}
void
txExecutionState
:
:
pushResultHandler
(
txAXMLEventHandler
*
aHandler
)
{
mResultHandlerStack
.
push
(
mResultHandler
)
;
mResultHandler
=
aHandler
;
}
txAXMLEventHandler
*
txExecutionState
:
:
popResultHandler
(
)
{
txAXMLEventHandler
*
oldHandler
=
mResultHandler
;
mResultHandler
=
(
txAXMLEventHandler
*
)
mResultHandlerStack
.
pop
(
)
;
return
oldHandler
;
}
void
txExecutionState
:
:
pushTemplateRule
(
txStylesheet
:
:
ImportFrame
*
aFrame
const
txExpandedName
&
aMode
txParameterMap
*
aParams
)
{
TemplateRule
*
rule
=
mTemplateRules
.
AppendElement
(
)
;
rule
-
>
mFrame
=
aFrame
;
rule
-
>
mModeNsId
=
aMode
.
mNamespaceID
;
rule
-
>
mModeLocalName
=
aMode
.
mLocalName
;
rule
-
>
mParams
=
aParams
;
}
void
txExecutionState
:
:
popTemplateRule
(
)
{
MOZ_ASSERT
(
!
mTemplateRules
.
IsEmpty
(
)
"
No
rules
to
pop
"
)
;
mTemplateRules
.
RemoveLastElement
(
)
;
}
txIEvalContext
*
txExecutionState
:
:
getEvalContext
(
)
{
return
mEvalContext
;
}
const
txXPathNode
*
txExecutionState
:
:
retrieveDocument
(
const
nsAString
&
aUri
)
{
NS_ASSERTION
(
!
aUri
.
Contains
(
char16_t
(
'
#
'
)
)
"
Remove
the
fragment
.
"
)
;
if
(
mDisableLoads
)
{
return
nullptr
;
}
MOZ_LOG
(
txLog
:
:
xslt
mozilla
:
:
LogLevel
:
:
Debug
(
"
Retrieve
Document
%
s
"
NS_LossyConvertUTF16toASCII
(
aUri
)
.
get
(
)
)
)
;
const
Variant
<
txXPathNode
nsresult
>
&
result
=
mLoadedDocuments
.
LookupOrInsertWith
(
aUri
[
&
]
{
nsAutoString
errMsg
;
Result
<
txXPathNode
nsresult
>
loadResult
=
txParseDocumentFromURI
(
aUri
*
mLoadedDocuments
.
mSourceDocument
errMsg
)
;
if
(
loadResult
.
isErr
(
)
)
{
nsresult
rv
=
loadResult
.
unwrapErr
(
)
;
receiveError
(
u
"
Couldn
'
t
load
document
'
"
_ns
+
aUri
+
u
"
'
:
"
_ns
+
errMsg
rv
)
;
return
txLoadedDocumentEntry
(
rv
)
;
}
return
txLoadedDocumentEntry
(
loadResult
.
unwrap
(
)
)
;
}
)
;
return
result
.
is
<
txXPathNode
>
(
)
?
&
result
.
as
<
txXPathNode
>
(
)
:
nullptr
;
}
nsresult
txExecutionState
:
:
getKeyNodes
(
const
txExpandedName
&
aKeyName
const
txXPathNode
&
aRoot
const
nsAString
&
aKeyValue
bool
aIndexIfNotFound
txNodeSet
*
*
aResult
)
{
return
mKeyHash
.
getKeyNodes
(
aKeyName
aRoot
aKeyValue
aIndexIfNotFound
*
this
aResult
)
;
}
txExecutionState
:
:
TemplateRule
*
txExecutionState
:
:
getCurrentTemplateRule
(
)
{
MOZ_ASSERT
(
!
mTemplateRules
.
IsEmpty
(
)
"
No
current
rule
!
"
)
;
return
&
mTemplateRules
[
mTemplateRules
.
Length
(
)
-
1
]
;
}
mozilla
:
:
Result
<
txInstruction
*
nsresult
>
txExecutionState
:
:
getNextInstruction
(
)
{
if
(
mStopProcessing
)
{
return
mozilla
:
:
Err
(
NS_ERROR_FAILURE
)
;
}
txInstruction
*
instr
=
mNextInstruction
;
if
(
instr
)
{
mNextInstruction
=
instr
-
>
mNext
.
get
(
)
;
}
return
instr
;
}
nsresult
txExecutionState
:
:
runTemplate
(
txInstruction
*
aTemplate
)
{
NS_ENSURE_TRUE
(
+
+
mRecursionDepth
<
kMaxRecursionDepth
NS_ERROR_XSLT_BAD_RECURSION
)
;
mLocalVarsStack
.
push
(
mLocalVariables
)
;
mReturnStack
.
push
(
mNextInstruction
)
;
mLocalVariables
=
nullptr
;
mNextInstruction
=
aTemplate
;
return
NS_OK
;
}
void
txExecutionState
:
:
gotoInstruction
(
txInstruction
*
aNext
)
{
mNextInstruction
=
aNext
;
}
void
txExecutionState
:
:
returnFromTemplate
(
)
{
-
-
mRecursionDepth
;
NS_ASSERTION
(
!
mReturnStack
.
isEmpty
(
)
&
&
!
mLocalVarsStack
.
isEmpty
(
)
"
return
or
variable
stack
is
empty
"
)
;
delete
mLocalVariables
;
mNextInstruction
=
(
txInstruction
*
)
mReturnStack
.
pop
(
)
;
mLocalVariables
=
(
txVariableMap
*
)
mLocalVarsStack
.
pop
(
)
;
}
nsresult
txExecutionState
:
:
bindVariable
(
const
txExpandedName
&
aName
txAExprResult
*
aValue
)
{
if
(
!
mLocalVariables
)
{
mLocalVariables
=
new
txVariableMap
;
}
return
mLocalVariables
-
>
bindVariable
(
aName
aValue
)
;
}
void
txExecutionState
:
:
removeVariable
(
const
txExpandedName
&
aName
)
{
mLocalVariables
-
>
removeVariable
(
aName
)
;
}
void
txExecutionState
:
:
pushParamMap
(
txParameterMap
*
aParams
)
{
mParamStack
.
AppendElement
(
mTemplateParams
.
forget
(
)
)
;
mTemplateParams
=
aParams
;
}
already_AddRefed
<
txParameterMap
>
txExecutionState
:
:
popParamMap
(
)
{
RefPtr
<
txParameterMap
>
oldParams
=
std
:
:
move
(
mTemplateParams
)
;
mTemplateParams
=
mParamStack
.
PopLastElement
(
)
;
return
oldParams
.
forget
(
)
;
}
