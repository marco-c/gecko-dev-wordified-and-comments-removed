#
ifndef
TRANSFRMX_VARIABLEMAP_H
#
define
TRANSFRMX_VARIABLEMAP_H
#
include
"
nsError
.
h
"
#
include
"
txExpandedNameMap
.
h
"
#
include
"
txExprResult
.
h
"
#
include
"
txXMLUtils
.
h
"
class
txVariableMapBase
{
public
:
nsresult
bindVariable
(
const
txExpandedName
&
aName
txAExprResult
*
aValue
)
;
void
getVariable
(
const
txExpandedName
&
aName
txAExprResult
*
*
aResult
)
;
void
removeVariable
(
const
txExpandedName
&
aName
)
;
protected
:
txVariableMapBase
(
)
=
default
;
~
txVariableMapBase
(
)
;
txExpandedNameMap
<
txAExprResult
>
mMap
;
}
;
class
txVariableMap
:
public
txVariableMapBase
{
public
:
txVariableMap
(
)
{
MOZ_COUNT_CTOR
(
txVariableMap
)
;
}
MOZ_COUNTED_DTOR
(
txVariableMap
)
}
;
class
txParameterMap
:
public
txVariableMapBase
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
txParameterMap
)
private
:
~
txParameterMap
(
)
=
default
;
}
;
inline
txVariableMapBase
:
:
~
txVariableMapBase
(
)
{
txExpandedNameMap
<
txAExprResult
>
:
:
iterator
iter
(
mMap
)
;
while
(
iter
.
next
(
)
)
{
txAExprResult
*
res
=
iter
.
value
(
)
;
NS_RELEASE
(
res
)
;
}
}
inline
nsresult
txVariableMapBase
:
:
bindVariable
(
const
txExpandedName
&
aName
txAExprResult
*
aValue
)
{
NS_ASSERTION
(
aValue
"
can
'
t
add
null
-
variables
to
a
txVariableMap
"
)
;
nsresult
rv
=
mMap
.
add
(
aName
aValue
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ADDREF
(
aValue
)
;
}
else
if
(
rv
=
=
NS_ERROR_XSLT_ALREADY_SET
)
{
rv
=
NS_ERROR_XSLT_VAR_ALREADY_SET
;
}
return
rv
;
}
inline
void
txVariableMapBase
:
:
getVariable
(
const
txExpandedName
&
aName
txAExprResult
*
*
aResult
)
{
*
aResult
=
mMap
.
get
(
aName
)
;
if
(
*
aResult
)
{
NS_ADDREF
(
*
aResult
)
;
}
}
inline
void
txVariableMapBase
:
:
removeVariable
(
const
txExpandedName
&
aName
)
{
txAExprResult
*
var
=
mMap
.
remove
(
aName
)
;
NS_IF_RELEASE
(
var
)
;
}
#
endif
