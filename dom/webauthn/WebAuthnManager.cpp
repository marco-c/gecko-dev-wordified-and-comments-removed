#
include
"
hasht
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
WebAuthnCoseIdentifiers
.
h
"
#
include
"
mozilla
/
dom
/
AuthenticatorAssertionResponse
.
h
"
#
include
"
mozilla
/
dom
/
AuthenticatorAttestationResponse
.
h
"
#
include
"
mozilla
/
dom
/
PublicKeyCredential
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PWebAuthnTransaction
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnManager
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnTransactionChild
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnUtil
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
authenticator
/
src
/
u2fhid
-
capi
.
h
"
#
ifdef
OS_WIN
#
include
"
WinWebAuthnManager
.
h
"
#
endif
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
namespace
{
static
mozilla
:
:
LazyLogModule
gWebAuthnManagerLog
(
"
webauthnmanager
"
)
;
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
WebAuthnManager
WebAuthnManagerBase
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
WebAuthnManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
WebAuthnManager
WebAuthnManagerBase
)
AbortFollower
:
:
Unlink
(
static_cast
<
AbortFollower
*
>
(
tmp
)
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTransaction
)
tmp
-
>
mTransaction
.
reset
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
WebAuthnManager
WebAuthnManagerBase
)
AbortFollower
:
:
Traverse
(
static_cast
<
AbortFollower
*
>
(
tmp
)
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTransaction
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
static
nsresult
AssembleClientData
(
const
nsAString
&
aOrigin
const
CryptoBuffer
&
aChallenge
const
nsAString
&
aType
const
AuthenticationExtensionsClientInputs
&
aExtensions
nsACString
&
aJsonOut
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsString
challengeBase64
;
nsresult
rv
=
aChallenge
.
ToJwkBase64
(
challengeBase64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
CollectedClientData
clientDataObject
;
clientDataObject
.
mType
.
Assign
(
aType
)
;
clientDataObject
.
mChallenge
.
Assign
(
challengeBase64
)
;
clientDataObject
.
mOrigin
.
Assign
(
aOrigin
)
;
clientDataObject
.
mHashAlgorithm
.
AssignLiteral
(
u
"
SHA
-
256
"
)
;
clientDataObject
.
mClientExtensions
=
aExtensions
;
nsAutoString
temp
;
if
(
NS_WARN_IF
(
!
clientDataObject
.
ToJSON
(
temp
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aJsonOut
.
Assign
(
NS_ConvertUTF16toUTF8
(
temp
)
)
;
return
NS_OK
;
}
nsresult
GetOrigin
(
nsPIDOMWindowInner
*
aParent
nsAString
&
aOrigin
nsACString
&
aHost
)
{
MOZ_ASSERT
(
aParent
)
;
nsCOMPtr
<
Document
>
doc
=
aParent
-
>
GetDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
-
>
NodePrincipal
(
)
;
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
principal
aOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
|
|
NS_WARN_IF
(
aOrigin
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
principal
-
>
GetIsIpAddress
(
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
aOrigin
.
EqualsLiteral
(
"
null
"
)
)
{
MOZ_LOG
(
gWebAuthnManagerLog
LogLevel
:
:
Debug
(
"
Rejecting
due
to
opaque
origin
"
)
)
;
return
NS_ERROR_DOM_NOT_ALLOWED_ERR
;
}
nsCOMPtr
<
nsIURI
>
originUri
;
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
principal
)
;
if
(
NS_FAILED
(
basePrin
-
>
GetURI
(
getter_AddRefs
(
originUri
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_FAILED
(
originUri
-
>
GetAsciiHost
(
aHost
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
RelaxSameOrigin
(
nsPIDOMWindowInner
*
aParent
const
nsAString
&
aInputRpId
nsACString
&
aRelaxedRpId
)
{
MOZ_ASSERT
(
aParent
)
;
nsCOMPtr
<
Document
>
doc
=
aParent
-
>
GetDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
-
>
NodePrincipal
(
)
;
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
principal
)
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
NS_FAILED
(
basePrin
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
originHost
;
if
(
NS_FAILED
(
uri
-
>
GetAsciiHost
(
originHost
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
Document
>
document
=
aParent
-
>
GetDoc
(
)
;
if
(
!
document
|
|
!
document
-
>
IsHTMLDocument
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsHTMLDocument
*
html
=
document
-
>
AsHTMLDocument
(
)
;
nsCOMPtr
<
nsIURI
>
inputRpIdURI
;
nsresult
rv
=
NS_MutateURI
(
uri
)
.
SetHost
(
NS_ConvertUTF16toUTF8
(
aInputRpId
)
)
.
Finalize
(
inputRpIdURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
nsAutoCString
inputRpId
;
if
(
NS_FAILED
(
inputRpIdURI
-
>
GetAsciiHost
(
inputRpId
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
html
-
>
IsRegistrableDomainSuffixOfOrEqualTo
(
NS_ConvertUTF8toUTF16
(
inputRpId
)
originHost
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
aRelaxedRpId
.
Assign
(
inputRpId
)
;
return
NS_OK
;
}
void
WebAuthnManager
:
:
ClearTransaction
(
)
{
if
(
!
mTransaction
.
isNothing
(
)
)
{
StopListeningForVisibilityEvents
(
)
;
}
mTransaction
.
reset
(
)
;
Unfollow
(
)
;
}
void
WebAuthnManager
:
:
RejectTransaction
(
const
nsresult
&
aError
)
{
if
(
!
NS_WARN_IF
(
mTransaction
.
isNothing
(
)
)
)
{
mTransaction
.
ref
(
)
.
mPromise
-
>
MaybeReject
(
aError
)
;
}
ClearTransaction
(
)
;
}
void
WebAuthnManager
:
:
CancelTransaction
(
const
nsresult
&
aError
)
{
if
(
!
NS_WARN_IF
(
!
mChild
|
|
mTransaction
.
isNothing
(
)
)
)
{
mChild
-
>
SendRequestCancel
(
mTransaction
.
ref
(
)
.
mId
)
;
}
RejectTransaction
(
aError
)
;
}
void
WebAuthnManager
:
:
HandleVisibilityChange
(
)
{
if
(
mTransaction
.
isSome
(
)
)
{
mTransaction
.
ref
(
)
.
mVisibilityChanged
=
true
;
}
}
WebAuthnManager
:
:
~
WebAuthnManager
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransaction
.
isSome
(
)
)
{
ClearTransaction
(
)
;
}
if
(
mChild
)
{
RefPtr
<
WebAuthnTransactionChild
>
c
;
mChild
.
swap
(
c
)
;
c
-
>
Disconnect
(
)
;
}
}
already_AddRefed
<
Promise
>
WebAuthnManager
:
:
MakeCredential
(
const
PublicKeyCredentialCreationOptions
&
aOptions
const
Optional
<
OwningNonNull
<
AbortSignal
>
>
&
aSignal
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mParent
)
;
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mTransaction
.
isSome
(
)
)
{
if
(
!
mTransaction
.
ref
(
)
.
mVisibilityChanged
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
promise
.
forget
(
)
;
}
CancelTransaction
(
NS_ERROR_ABORT
)
;
}
if
(
aSignal
.
WasPassed
(
)
&
&
aSignal
.
Value
(
)
.
Aborted
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
promise
.
forget
(
)
;
}
nsString
origin
;
nsCString
rpId
;
rv
=
GetOrigin
(
mParent
origin
rpId
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
rv
)
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
userId
;
userId
.
Assign
(
aOptions
.
mUser
.
mId
)
;
if
(
userId
.
Length
(
)
>
64
)
{
promise
-
>
MaybeRejectWithTypeError
(
"
user
.
id
is
too
long
"
)
;
return
promise
.
forget
(
)
;
}
uint32_t
adjustedTimeout
=
30000
;
if
(
aOptions
.
mTimeout
.
WasPassed
(
)
)
{
adjustedTimeout
=
aOptions
.
mTimeout
.
Value
(
)
;
adjustedTimeout
=
std
:
:
max
(
15000u
adjustedTimeout
)
;
adjustedTimeout
=
std
:
:
min
(
120000u
adjustedTimeout
)
;
}
if
(
aOptions
.
mRp
.
mId
.
WasPassed
(
)
)
{
if
(
NS_FAILED
(
RelaxSameOrigin
(
mParent
aOptions
.
mRp
.
mId
.
Value
(
)
rpId
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
}
if
(
aOptions
.
mExtensions
.
mAppid
.
WasPassed
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
CoseAlg
>
coseAlgos
;
for
(
size_t
a
=
0
;
a
<
aOptions
.
mPubKeyCredParams
.
Length
(
)
;
+
+
a
)
{
if
(
aOptions
.
mPubKeyCredParams
[
a
]
.
mType
!
=
PublicKeyCredentialType
:
:
Public_key
)
{
continue
;
}
coseAlgos
.
AppendElement
(
aOptions
.
mPubKeyCredParams
[
a
]
.
mAlg
)
;
}
if
(
coseAlgos
.
IsEmpty
(
)
&
&
!
aOptions
.
mPubKeyCredParams
.
IsEmpty
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
challenge
;
if
(
!
challenge
.
Assign
(
aOptions
.
mChallenge
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsAutoCString
clientDataJSON
;
nsresult
srv
=
AssembleClientData
(
origin
challenge
u
"
webauthn
.
create
"
_ns
aOptions
.
mExtensions
clientDataJSON
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
WebAuthnScopedCredential
>
excludeList
;
for
(
const
auto
&
s
:
aOptions
.
mExcludeCredentials
)
{
WebAuthnScopedCredential
c
;
CryptoBuffer
cb
;
cb
.
Assign
(
s
.
mId
)
;
c
.
id
(
)
=
cb
;
excludeList
.
AppendElement
(
c
)
;
}
if
(
!
MaybeCreateBackgroundActor
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
WebAuthnExtension
>
extensions
;
if
(
aOptions
.
mExtensions
.
mHmacCreateSecret
.
WasPassed
(
)
)
{
bool
hmacCreateSecret
=
aOptions
.
mExtensions
.
mHmacCreateSecret
.
Value
(
)
;
if
(
hmacCreateSecret
)
{
extensions
.
AppendElement
(
WebAuthnExtensionHmacSecret
(
hmacCreateSecret
)
)
;
}
}
const
auto
&
selection
=
aOptions
.
mAuthenticatorSelection
;
const
auto
&
attachment
=
selection
.
mAuthenticatorAttachment
;
const
AttestationConveyancePreference
&
attestation
=
aOptions
.
mAttestation
;
Maybe
<
AuthenticatorAttachment
>
authenticatorAttachment
;
if
(
attachment
.
WasPassed
(
)
)
{
authenticatorAttachment
.
emplace
(
attachment
.
Value
(
)
)
;
}
WebAuthnAuthenticatorSelection
authSelection
(
selection
.
mRequireResidentKey
selection
.
mUserVerification
authenticatorAttachment
)
;
nsString
rpIcon
;
if
(
aOptions
.
mRp
.
mIcon
.
WasPassed
(
)
)
{
rpIcon
=
aOptions
.
mRp
.
mIcon
.
Value
(
)
;
}
nsString
userIcon
;
if
(
aOptions
.
mUser
.
mIcon
.
WasPassed
(
)
)
{
userIcon
=
aOptions
.
mUser
.
mIcon
.
Value
(
)
;
}
WebAuthnMakeCredentialRpInfo
rpInfo
(
aOptions
.
mRp
.
mName
rpIcon
)
;
WebAuthnMakeCredentialUserInfo
userInfo
(
userId
aOptions
.
mUser
.
mName
userIcon
aOptions
.
mUser
.
mDisplayName
)
;
WebAuthnMakeCredentialExtraInfo
extra
(
rpInfo
userInfo
coseAlgos
extensions
authSelection
attestation
)
;
BrowsingContext
*
context
=
mParent
-
>
GetBrowsingContext
(
)
;
if
(
!
context
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
promise
.
forget
(
)
;
}
WebAuthnMakeCredentialInfo
info
(
origin
NS_ConvertUTF8toUTF16
(
rpId
)
challenge
clientDataJSON
adjustedTimeout
excludeList
Some
(
extra
)
context
-
>
Top
(
)
-
>
Id
(
)
)
;
#
ifdef
OS_WIN
if
(
!
WinWebAuthnManager
:
:
AreWebAuthNApisAvailable
(
)
)
{
ListenForVisibilityEvents
(
)
;
}
#
else
ListenForVisibilityEvents
(
)
;
#
endif
AbortSignal
*
signal
=
nullptr
;
if
(
aSignal
.
WasPassed
(
)
)
{
signal
=
&
aSignal
.
Value
(
)
;
Follow
(
signal
)
;
}
MOZ_ASSERT
(
mTransaction
.
isNothing
(
)
)
;
mTransaction
=
Some
(
WebAuthnTransaction
(
promise
)
)
;
mChild
-
>
SendRequestRegister
(
mTransaction
.
ref
(
)
.
mId
info
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WebAuthnManager
:
:
GetAssertion
(
const
PublicKeyCredentialRequestOptions
&
aOptions
const
Optional
<
OwningNonNull
<
AbortSignal
>
>
&
aSignal
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mParent
)
;
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mTransaction
.
isSome
(
)
)
{
if
(
!
mTransaction
.
ref
(
)
.
mVisibilityChanged
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
promise
.
forget
(
)
;
}
CancelTransaction
(
NS_ERROR_ABORT
)
;
}
if
(
aSignal
.
WasPassed
(
)
&
&
aSignal
.
Value
(
)
.
Aborted
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
promise
.
forget
(
)
;
}
nsString
origin
;
nsCString
rpId
;
rv
=
GetOrigin
(
mParent
origin
rpId
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
rv
)
)
;
return
promise
.
forget
(
)
;
}
uint32_t
adjustedTimeout
=
30000
;
if
(
aOptions
.
mTimeout
.
WasPassed
(
)
)
{
adjustedTimeout
=
aOptions
.
mTimeout
.
Value
(
)
;
adjustedTimeout
=
std
:
:
max
(
15000u
adjustedTimeout
)
;
adjustedTimeout
=
std
:
:
min
(
120000u
adjustedTimeout
)
;
}
if
(
aOptions
.
mRpId
.
WasPassed
(
)
)
{
if
(
NS_FAILED
(
RelaxSameOrigin
(
mParent
aOptions
.
mRpId
.
Value
(
)
rpId
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
}
CryptoBuffer
rpIdHash
;
if
(
!
rpIdHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
challenge
;
if
(
!
challenge
.
Assign
(
aOptions
.
mChallenge
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsAutoCString
clientDataJSON
;
nsresult
srv
=
AssembleClientData
(
origin
challenge
u
"
webauthn
.
get
"
_ns
aOptions
.
mExtensions
clientDataJSON
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
WebAuthnScopedCredential
>
allowList
;
for
(
const
auto
&
s
:
aOptions
.
mAllowCredentials
)
{
if
(
s
.
mType
=
=
PublicKeyCredentialType
:
:
Public_key
)
{
WebAuthnScopedCredential
c
;
CryptoBuffer
cb
;
cb
.
Assign
(
s
.
mId
)
;
c
.
id
(
)
=
cb
;
if
(
s
.
mTransports
.
WasPassed
(
)
)
{
uint8_t
transports
=
0
;
for
(
const
nsAString
&
str
:
s
.
mTransports
.
Value
(
)
)
{
NS_ConvertUTF16toUTF8
cStr
(
str
)
;
int
i
=
FindEnumStringIndexImpl
(
cStr
.
get
(
)
cStr
.
Length
(
)
AuthenticatorTransportValues
:
:
strings
)
;
if
(
i
<
0
)
{
continue
;
}
AuthenticatorTransport
t
=
static_cast
<
AuthenticatorTransport
>
(
i
)
;
if
(
t
=
=
AuthenticatorTransport
:
:
Usb
)
{
transports
|
=
U2F_AUTHENTICATOR_TRANSPORT_USB
;
}
if
(
t
=
=
AuthenticatorTransport
:
:
Nfc
)
{
transports
|
=
U2F_AUTHENTICATOR_TRANSPORT_NFC
;
}
if
(
t
=
=
AuthenticatorTransport
:
:
Ble
)
{
transports
|
=
U2F_AUTHENTICATOR_TRANSPORT_BLE
;
}
if
(
t
=
=
AuthenticatorTransport
:
:
Internal
)
{
transports
|
=
CTAP_AUTHENTICATOR_TRANSPORT_INTERNAL
;
}
}
c
.
transports
(
)
=
transports
;
}
allowList
.
AppendElement
(
c
)
;
}
}
if
(
!
MaybeCreateBackgroundActor
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
WebAuthnExtension
>
extensions
;
if
(
aOptions
.
mExtensions
.
mAppid
.
WasPassed
(
)
)
{
nsString
appId
(
aOptions
.
mExtensions
.
mAppid
.
Value
(
)
)
;
if
(
!
EvaluateAppID
(
mParent
origin
appId
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
appIdHash
;
if
(
!
appIdHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
promise
.
forget
(
)
;
}
srv
=
HashCString
(
NS_ConvertUTF16toUTF8
(
appId
)
appIdHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
extensions
.
AppendElement
(
WebAuthnExtensionAppId
(
appIdHash
appId
)
)
;
}
WebAuthnGetAssertionExtraInfo
extra
(
extensions
aOptions
.
mUserVerification
)
;
BrowsingContext
*
context
=
mParent
-
>
GetBrowsingContext
(
)
;
if
(
!
context
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_OPERATION_ERR
)
;
return
promise
.
forget
(
)
;
}
WebAuthnGetAssertionInfo
info
(
origin
NS_ConvertUTF8toUTF16
(
rpId
)
challenge
clientDataJSON
adjustedTimeout
allowList
Some
(
extra
)
context
-
>
Top
(
)
-
>
Id
(
)
)
;
#
ifdef
OS_WIN
if
(
!
WinWebAuthnManager
:
:
AreWebAuthNApisAvailable
(
)
)
{
ListenForVisibilityEvents
(
)
;
}
#
else
ListenForVisibilityEvents
(
)
;
#
endif
AbortSignal
*
signal
=
nullptr
;
if
(
aSignal
.
WasPassed
(
)
)
{
signal
=
&
aSignal
.
Value
(
)
;
Follow
(
signal
)
;
}
MOZ_ASSERT
(
mTransaction
.
isNothing
(
)
)
;
mTransaction
=
Some
(
WebAuthnTransaction
(
promise
)
)
;
mChild
-
>
SendRequestSign
(
mTransaction
.
ref
(
)
.
mId
info
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WebAuthnManager
:
:
Store
(
const
Credential
&
aCredential
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
mParent
)
;
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mTransaction
.
isSome
(
)
)
{
if
(
!
mTransaction
.
ref
(
)
.
mVisibilityChanged
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
return
promise
.
forget
(
)
;
}
CancelTransaction
(
NS_ERROR_ABORT
)
;
}
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
promise
.
forget
(
)
;
}
void
WebAuthnManager
:
:
FinishMakeCredential
(
const
uint64_t
&
aTransactionId
const
WebAuthnMakeCredentialResult
&
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransaction
.
isNothing
(
)
|
|
mTransaction
.
ref
(
)
.
mId
!
=
aTransactionId
)
{
return
;
}
CryptoBuffer
clientDataBuf
;
if
(
NS_WARN_IF
(
!
clientDataBuf
.
Assign
(
aResult
.
ClientDataJSON
(
)
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
attObjBuf
;
if
(
NS_WARN_IF
(
!
attObjBuf
.
Assign
(
aResult
.
AttestationObject
(
)
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
keyHandleBuf
;
if
(
NS_WARN_IF
(
!
keyHandleBuf
.
Assign
(
aResult
.
KeyHandle
(
)
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
nsAutoString
keyHandleBase64Url
;
nsresult
rv
=
keyHandleBuf
.
ToJwkBase64
(
keyHandleBase64Url
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
RejectTransaction
(
rv
)
;
return
;
}
RefPtr
<
AuthenticatorAttestationResponse
>
attestation
=
new
AuthenticatorAttestationResponse
(
mParent
)
;
attestation
-
>
SetClientDataJSON
(
clientDataBuf
)
;
attestation
-
>
SetAttestationObject
(
attObjBuf
)
;
RefPtr
<
PublicKeyCredential
>
credential
=
new
PublicKeyCredential
(
mParent
)
;
credential
-
>
SetId
(
keyHandleBase64Url
)
;
credential
-
>
SetType
(
u
"
public
-
key
"
_ns
)
;
credential
-
>
SetRawId
(
keyHandleBuf
)
;
credential
-
>
SetResponse
(
attestation
)
;
for
(
auto
&
ext
:
aResult
.
Extensions
(
)
)
{
if
(
ext
.
type
(
)
=
=
WebAuthnExtensionResult
:
:
TWebAuthnExtensionResultHmacSecret
)
{
bool
hmacCreateSecret
=
ext
.
get_WebAuthnExtensionResultHmacSecret
(
)
.
hmacCreateSecret
(
)
;
credential
-
>
SetClientExtensionResultHmacSecret
(
hmacCreateSecret
)
;
}
}
mTransaction
.
ref
(
)
.
mPromise
-
>
MaybeResolve
(
credential
)
;
ClearTransaction
(
)
;
}
void
WebAuthnManager
:
:
FinishGetAssertion
(
const
uint64_t
&
aTransactionId
const
WebAuthnGetAssertionResult
&
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransaction
.
isNothing
(
)
|
|
mTransaction
.
ref
(
)
.
mId
!
=
aTransactionId
)
{
return
;
}
CryptoBuffer
clientDataBuf
;
if
(
!
clientDataBuf
.
Assign
(
aResult
.
ClientDataJSON
(
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
credentialBuf
;
if
(
!
credentialBuf
.
Assign
(
aResult
.
KeyHandle
(
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
signatureBuf
;
if
(
!
signatureBuf
.
Assign
(
aResult
.
Signature
(
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
authenticatorDataBuf
;
if
(
!
authenticatorDataBuf
.
Assign
(
aResult
.
AuthenticatorData
(
)
)
)
{
RejectTransaction
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
nsAutoString
credentialBase64Url
;
nsresult
rv
=
credentialBuf
.
ToJwkBase64
(
credentialBase64Url
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
RejectTransaction
(
rv
)
;
return
;
}
CryptoBuffer
userHandleBuf
;
userHandleBuf
.
Assign
(
aResult
.
UserHandle
(
)
)
;
RefPtr
<
AuthenticatorAssertionResponse
>
assertion
=
new
AuthenticatorAssertionResponse
(
mParent
)
;
assertion
-
>
SetClientDataJSON
(
clientDataBuf
)
;
assertion
-
>
SetAuthenticatorData
(
authenticatorDataBuf
)
;
assertion
-
>
SetSignature
(
signatureBuf
)
;
if
(
!
userHandleBuf
.
IsEmpty
(
)
)
{
assertion
-
>
SetUserHandle
(
userHandleBuf
)
;
}
RefPtr
<
PublicKeyCredential
>
credential
=
new
PublicKeyCredential
(
mParent
)
;
credential
-
>
SetId
(
credentialBase64Url
)
;
credential
-
>
SetType
(
u
"
public
-
key
"
_ns
)
;
credential
-
>
SetRawId
(
credentialBuf
)
;
credential
-
>
SetResponse
(
assertion
)
;
for
(
auto
&
ext
:
aResult
.
Extensions
(
)
)
{
if
(
ext
.
type
(
)
=
=
WebAuthnExtensionResult
:
:
TWebAuthnExtensionResultAppId
)
{
bool
appid
=
ext
.
get_WebAuthnExtensionResultAppId
(
)
.
AppId
(
)
;
credential
-
>
SetClientExtensionResultAppId
(
appid
)
;
}
}
mTransaction
.
ref
(
)
.
mPromise
-
>
MaybeResolve
(
credential
)
;
ClearTransaction
(
)
;
}
void
WebAuthnManager
:
:
RequestAborted
(
const
uint64_t
&
aTransactionId
const
nsresult
&
aError
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mTransaction
.
isSome
(
)
&
&
mTransaction
.
ref
(
)
.
mId
=
=
aTransactionId
)
{
RejectTransaction
(
aError
)
;
}
}
void
WebAuthnManager
:
:
RunAbortAlgorithm
(
)
{
CancelTransaction
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
}
}
