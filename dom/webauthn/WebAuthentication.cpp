#
include
"
mozilla
/
dom
/
WebAuthentication
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnAssertion
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnAttestation
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
pkix
/
Input
.
h
"
#
include
"
pkixutil
.
h
"
#
define
PREF_WEBAUTHN_SOFTTOKEN_ENABLED
"
security
.
webauth
.
webauthn_enable_softtoken
"
#
define
PREF_WEBAUTHN_USBTOKEN_ENABLED
"
security
.
webauth
.
webauthn_enable_usbtoken
"
namespace
mozilla
{
namespace
dom
{
static
mozilla
:
:
LazyLogModule
gWebauthLog
(
"
webauthn
"
)
;
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
WebAuthentication
mParent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WebAuthentication
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WebAuthentication
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WebAuthentication
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
template
<
class
OOS
>
static
nsresult
GetAlgorithmName
(
JSContext
*
aCx
const
OOS
&
aAlgorithm
nsString
&
aName
)
{
MOZ_ASSERT
(
aAlgorithm
.
IsString
(
)
)
;
if
(
aAlgorithm
.
IsString
(
)
)
{
aName
.
Assign
(
aAlgorithm
.
GetAsString
(
)
)
;
}
else
{
}
if
(
!
NormalizeToken
(
aName
aName
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
return
NS_OK
;
}
static
nsresult
HashCString
(
nsICryptoHash
*
aHashService
const
nsACString
&
aIn
CryptoBuffer
&
aOut
)
{
MOZ_ASSERT
(
aHashService
)
;
nsresult
rv
=
aHashService
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aHashService
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
aIn
.
BeginReading
(
)
)
aIn
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
fullHash
;
rv
=
aHashService
-
>
Finish
(
false
fullHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOut
.
Assign
(
fullHash
)
;
return
rv
;
}
static
nsresult
AssembleClientData
(
const
nsAString
&
aOrigin
const
CryptoBuffer
&
aChallenge
nsACString
&
aJsonOut
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsString
challengeBase64
;
nsresult
rv
=
aChallenge
.
ToJwkBase64
(
challengeBase64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
WebAuthnClientData
clientDataObject
;
clientDataObject
.
mOrigin
.
Assign
(
aOrigin
)
;
clientDataObject
.
mHashAlg
.
SetAsString
(
)
.
Assign
(
NS_LITERAL_STRING
(
"
S256
"
)
)
;
clientDataObject
.
mChallenge
.
Assign
(
challengeBase64
)
;
nsAutoString
temp
;
if
(
NS_WARN_IF
(
!
clientDataObject
.
ToJSON
(
temp
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aJsonOut
.
Assign
(
NS_ConvertUTF16toUTF8
(
temp
)
)
;
return
NS_OK
;
}
static
nsresult
ScopedCredentialGetData
(
const
ScopedCredentialDescriptor
&
aSCD
uint8_t
*
*
aBuf
uint32_t
*
aBufLen
)
{
MOZ_ASSERT
(
aBuf
)
;
MOZ_ASSERT
(
aBufLen
)
;
if
(
aSCD
.
mId
.
IsArrayBufferView
(
)
)
{
const
ArrayBufferView
&
view
=
aSCD
.
mId
.
GetAsArrayBufferView
(
)
;
view
.
ComputeLengthAndData
(
)
;
*
aBuf
=
view
.
Data
(
)
;
*
aBufLen
=
view
.
Length
(
)
;
}
else
if
(
aSCD
.
mId
.
IsArrayBuffer
(
)
)
{
const
ArrayBuffer
&
buffer
=
aSCD
.
mId
.
GetAsArrayBuffer
(
)
;
buffer
.
ComputeLengthAndData
(
)
;
*
aBuf
=
buffer
.
Data
(
)
;
*
aBufLen
=
buffer
.
Length
(
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
ReadToCryptoBuffer
(
pkix
:
:
Reader
&
aSrc
CryptoBuffer
&
aDest
uint32_t
aLen
)
{
if
(
aSrc
.
EnsureLength
(
aLen
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
aDest
.
ClearAndRetainStorage
(
)
;
for
(
uint32_t
offset
=
0
;
offset
<
aLen
;
+
+
offset
)
{
uint8_t
b
;
if
(
aSrc
.
Read
(
b
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
if
(
!
aDest
.
AppendElement
(
b
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
static
nsresult
U2FAssembleAuthenticatorData
(
CryptoBuffer
&
aAuthenticatorData
const
CryptoBuffer
&
aRpIdHash
const
CryptoBuffer
&
aSignatureData
)
{
if
(
aRpIdHash
.
Length
(
)
!
=
32
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aAuthenticatorData
.
AppendElements
(
aRpIdHash
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
aAuthenticatorData
.
AppendElements
(
aSignatureData
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
static
nsresult
U2FDecomposeRegistrationResponse
(
const
CryptoBuffer
&
aResponse
CryptoBuffer
&
aPubKeyBuf
CryptoBuffer
&
aKeyHandleBuf
CryptoBuffer
&
aAttestationCertBuf
CryptoBuffer
&
aSignatureBuf
)
{
pkix
:
:
Input
u2fResponse
;
u2fResponse
.
Init
(
aResponse
.
Elements
(
)
aResponse
.
Length
(
)
)
;
pkix
:
:
Reader
input
(
u2fResponse
)
;
uint8_t
b
;
if
(
input
.
Read
(
b
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
if
(
b
!
=
0x05
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
nsresult
rv
=
ReadToCryptoBuffer
(
input
aPubKeyBuf
65
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint8_t
handleLen
;
if
(
input
.
Read
(
handleLen
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
rv
=
ReadToCryptoBuffer
(
input
aKeyHandleBuf
handleLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
pkix
:
:
Input
cert
;
if
(
pkix
:
:
der
:
:
ExpectTagAndGetValue
(
input
pkix
:
:
der
:
:
SEQUENCE
cert
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
pkix
:
:
Reader
certInput
(
cert
)
;
rv
=
ReadToCryptoBuffer
(
certInput
aAttestationCertBuf
cert
.
GetLength
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
pkix
:
:
Input
u2fSig
;
input
.
SkipToEnd
(
u2fSig
)
;
pkix
:
:
Reader
sigInput
(
u2fSig
)
;
rv
=
ReadToCryptoBuffer
(
sigInput
aSignatureBuf
u2fSig
.
GetLength
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
WebAuthentication
:
:
WebAuthentication
(
nsPIDOMWindowInner
*
aParent
)
:
mInitialized
(
false
)
{
mParent
=
do_QueryInterface
(
aParent
)
;
MOZ_ASSERT
(
mParent
)
;
}
WebAuthentication
:
:
~
WebAuthentication
(
)
{
}
nsresult
WebAuthentication
:
:
InitLazily
(
)
{
if
(
mInitialized
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mParent
)
;
if
(
!
mParent
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mParent
-
>
GetDoc
(
)
;
MOZ_ASSERT
(
doc
)
;
nsIPrincipal
*
principal
=
doc
-
>
NodePrincipal
(
)
;
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
principal
mOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
mOrigin
.
IsEmpty
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
XRE_IsParentProcess
(
)
)
{
MOZ_LOG
(
gWebauthLog
LogLevel
:
:
Debug
(
"
Is
non
-
e10s
Process
WebAuthn
not
available
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
Preferences
:
:
GetBool
(
PREF_WEBAUTHN_SOFTTOKEN_ENABLED
)
)
{
if
(
!
mAuthenticators
.
AppendElement
(
new
NSSU2FTokenRemote
(
)
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
mInitialized
=
true
;
return
NS_OK
;
}
JSObject
*
WebAuthentication
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WebAuthenticationBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
WebAuthentication
:
:
U2FAuthMakeCredential
(
const
RefPtr
<
CredentialRequest
>
&
aRequest
const
Authenticator
&
aToken
CryptoBuffer
&
aRpIdHash
const
nsACString
&
aClientData
CryptoBuffer
&
aClientDataHash
const
Account
&
aAccount
const
nsTArray
<
ScopedCredentialParameters
>
&
aNormalizedParams
const
Optional
<
Sequence
<
ScopedCredentialDescriptor
>
>
&
aExcludeList
const
WebAuthnExtensions
&
aExtensions
)
{
MOZ_LOG
(
gWebauthLog
LogLevel
:
:
Debug
(
"
U2FAuthMakeCredential
"
)
)
;
aRequest
-
>
AddActiveToken
(
__func__
)
;
if
(
(
aRpIdHash
.
Length
(
)
!
=
SHA256_LENGTH
)
|
|
(
aClientDataHash
.
Length
(
)
!
=
SHA256_LENGTH
)
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
return
;
}
bool
isValidCombination
=
false
;
for
(
size_t
a
=
0
;
a
<
aNormalizedParams
.
Length
(
)
;
+
+
a
)
{
if
(
aNormalizedParams
[
a
]
.
mType
=
=
ScopedCredentialType
:
:
ScopedCred
&
&
aNormalizedParams
[
a
]
.
mAlgorithm
.
IsString
(
)
&
&
aNormalizedParams
[
a
]
.
mAlgorithm
.
GetAsString
(
)
.
EqualsLiteral
(
WEBCRYPTO_NAMED_CURVE_P256
)
)
{
isValidCombination
=
true
;
break
;
}
}
if
(
!
isValidCombination
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
if
(
aExcludeList
.
WasPassed
(
)
)
{
const
Sequence
<
ScopedCredentialDescriptor
>
&
list
=
aExcludeList
.
Value
(
)
;
for
(
const
ScopedCredentialDescriptor
&
scd
:
list
)
{
bool
isRegistered
=
false
;
uint8_t
*
data
;
uint32_t
len
;
if
(
NS_FAILED
(
ScopedCredentialGetData
(
scd
&
data
&
len
)
)
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
return
;
}
nsresult
rv
=
aToken
-
>
IsRegistered
(
data
len
&
isRegistered
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
if
(
isRegistered
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
)
;
return
;
}
}
}
uint8_t
*
buffer
;
uint32_t
bufferlen
;
nsresult
rv
=
aToken
-
>
Register
(
aRpIdHash
.
Elements
(
)
aRpIdHash
.
Length
(
)
aClientDataHash
.
Elements
(
)
aClientDataHash
.
Length
(
)
&
buffer
&
bufferlen
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_DOM_UNKNOWN_ERR
)
;
return
;
}
MOZ_ASSERT
(
buffer
)
;
CryptoBuffer
regData
;
if
(
NS_WARN_IF
(
!
regData
.
Assign
(
buffer
bufferlen
)
)
)
{
free
(
buffer
)
;
aRequest
-
>
SetFailure
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
free
(
buffer
)
;
CryptoBuffer
pubKeyBuf
;
CryptoBuffer
keyHandleBuf
;
CryptoBuffer
attestationCertBuf
;
CryptoBuffer
signatureBuf
;
rv
=
U2FDecomposeRegistrationResponse
(
regData
pubKeyBuf
keyHandleBuf
attestationCertBuf
signatureBuf
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
rv
=
aToken
-
>
Sign
(
aRpIdHash
.
Elements
(
)
aRpIdHash
.
Length
(
)
aClientDataHash
.
Elements
(
)
aClientDataHash
.
Length
(
)
keyHandleBuf
.
Elements
(
)
keyHandleBuf
.
Length
(
)
&
buffer
&
bufferlen
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
MOZ_ASSERT
(
buffer
)
;
CryptoBuffer
signatureData
;
if
(
NS_WARN_IF
(
!
signatureData
.
Assign
(
buffer
bufferlen
)
)
)
{
free
(
buffer
)
;
aRequest
-
>
SetFailure
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
free
(
buffer
)
;
CryptoBuffer
clientDataBuf
;
if
(
!
clientDataBuf
.
Assign
(
aClientData
)
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
authenticatorDataBuf
;
rv
=
U2FAssembleAuthenticatorData
(
authenticatorDataBuf
aRpIdHash
signatureData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
RefPtr
<
ScopedCredential
>
credential
=
new
ScopedCredential
(
this
)
;
credential
-
>
SetType
(
ScopedCredentialType
:
:
ScopedCred
)
;
credential
-
>
SetId
(
keyHandleBuf
)
;
RefPtr
<
WebAuthnAttestation
>
attestation
=
new
WebAuthnAttestation
(
this
)
;
attestation
-
>
SetFormat
(
NS_LITERAL_STRING
(
"
u2f
"
)
)
;
attestation
-
>
SetClientData
(
clientDataBuf
)
;
attestation
-
>
SetAuthenticatorData
(
authenticatorDataBuf
)
;
attestation
-
>
SetAttestation
(
regData
)
;
CredentialPtr
info
=
new
ScopedCredentialInfo
(
this
)
;
info
-
>
SetCredential
(
credential
)
;
info
-
>
SetAttestation
(
attestation
)
;
aRequest
-
>
SetSuccess
(
info
)
;
}
void
WebAuthentication
:
:
U2FAuthGetAssertion
(
const
RefPtr
<
AssertionRequest
>
&
aRequest
const
Authenticator
&
aToken
CryptoBuffer
&
aRpIdHash
const
nsACString
&
aClientData
CryptoBuffer
&
aClientDataHash
nsTArray
<
CryptoBuffer
>
&
aAllowList
const
WebAuthnExtensions
&
aExtensions
)
{
MOZ_LOG
(
gWebauthLog
LogLevel
:
:
Debug
(
"
U2FAuthGetAssertion
"
)
)
;
aRequest
-
>
AddActiveToken
(
__func__
)
;
for
(
CryptoBuffer
&
allowedCredential
:
aAllowList
)
{
bool
isRegistered
=
false
;
nsresult
rv
=
aToken
-
>
IsRegistered
(
allowedCredential
.
Elements
(
)
allowedCredential
.
Length
(
)
&
isRegistered
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
if
(
!
isRegistered
)
{
continue
;
}
uint8_t
*
buffer
;
uint32_t
bufferlen
;
rv
=
aToken
-
>
Sign
(
aRpIdHash
.
Elements
(
)
aRpIdHash
.
Length
(
)
aClientDataHash
.
Elements
(
)
aClientDataHash
.
Length
(
)
allowedCredential
.
Elements
(
)
allowedCredential
.
Length
(
)
&
buffer
&
bufferlen
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
MOZ_ASSERT
(
buffer
)
;
CryptoBuffer
signatureData
;
if
(
NS_WARN_IF
(
!
signatureData
.
Assign
(
buffer
bufferlen
)
)
)
{
free
(
buffer
)
;
aRequest
-
>
SetFailure
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
free
(
buffer
)
;
CryptoBuffer
clientDataBuf
;
if
(
!
clientDataBuf
.
Assign
(
aClientData
)
)
{
aRequest
-
>
SetFailure
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
CryptoBuffer
authenticatorDataBuf
;
rv
=
U2FAssembleAuthenticatorData
(
authenticatorDataBuf
aRpIdHash
signatureData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRequest
-
>
SetFailure
(
rv
)
;
return
;
}
RefPtr
<
ScopedCredential
>
credential
=
new
ScopedCredential
(
this
)
;
credential
-
>
SetType
(
ScopedCredentialType
:
:
ScopedCred
)
;
credential
-
>
SetId
(
allowedCredential
)
;
AssertionPtr
assertion
=
new
WebAuthnAssertion
(
this
)
;
assertion
-
>
SetCredential
(
credential
)
;
assertion
-
>
SetClientData
(
clientDataBuf
)
;
assertion
-
>
SetAuthenticatorData
(
authenticatorDataBuf
)
;
assertion
-
>
SetSignature
(
signatureData
)
;
aRequest
-
>
SetSuccess
(
assertion
)
;
return
;
}
aRequest
-
>
SetFailure
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
)
;
}
nsresult
WebAuthentication
:
:
RelaxSameOrigin
(
const
nsAString
&
aInputRpId
nsACString
&
aRelaxedRpId
)
{
MOZ_ASSERT
(
mParent
)
;
nsCOMPtr
<
nsIDocument
>
document
=
mParent
-
>
GetDoc
(
)
;
if
(
!
document
|
|
!
document
-
>
IsHTMLDocument
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aRelaxedRpId
.
Assign
(
NS_ConvertUTF16toUTF8
(
aInputRpId
)
)
;
return
NS_OK
;
}
already_AddRefed
<
Promise
>
WebAuthentication
:
:
MakeCredential
(
JSContext
*
aCx
const
Account
&
aAccount
const
Sequence
<
ScopedCredentialParameters
>
&
aCryptoParameters
const
ArrayBufferViewOrArrayBuffer
&
aChallenge
const
ScopedCredentialOptions
&
aOptions
)
{
MOZ_ASSERT
(
mParent
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
GetParentObject
(
)
)
;
if
(
!
global
)
{
return
nullptr
;
}
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
rv
)
;
nsresult
initRv
=
InitLazily
(
)
;
if
(
NS_FAILED
(
initRv
)
)
{
promise
-
>
MaybeReject
(
initRv
)
;
return
promise
.
forget
(
)
;
}
double
adjustedTimeout
=
30
.
0
;
if
(
aOptions
.
mTimeoutSeconds
.
WasPassed
(
)
)
{
adjustedTimeout
=
aOptions
.
mTimeoutSeconds
.
Value
(
)
;
adjustedTimeout
=
std
:
:
max
(
15
.
0
adjustedTimeout
)
;
adjustedTimeout
=
std
:
:
min
(
120
.
0
adjustedTimeout
)
;
}
RefPtr
<
CredentialRequest
>
requestMonitor
=
new
CredentialRequest
(
)
;
requestMonitor
-
>
SetDeadline
(
TimeDuration
:
:
FromSeconds
(
adjustedTimeout
)
)
;
if
(
mOrigin
.
EqualsLiteral
(
"
null
"
)
)
{
MOZ_LOG
(
gWebauthLog
LogLevel
:
:
Debug
(
"
Rejecting
due
to
opaque
origin
"
)
)
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
)
;
return
promise
.
forget
(
)
;
}
nsCString
rpId
;
if
(
!
aOptions
.
mRpId
.
WasPassed
(
)
)
{
rpId
.
Assign
(
NS_ConvertUTF16toUTF8
(
mOrigin
)
)
;
}
else
{
if
(
NS_FAILED
(
RelaxSameOrigin
(
aOptions
.
mRpId
.
Value
(
)
rpId
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
}
CryptoBuffer
rpIdHash
;
if
(
!
rpIdHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
promise
.
forget
(
)
;
}
nsresult
srv
;
nsCOMPtr
<
nsICryptoHash
>
hashService
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
srv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
srv
=
HashCString
(
hashService
rpId
rpIdHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsTArray
<
ScopedCredentialParameters
>
normalizedParams
;
for
(
size_t
a
=
0
;
a
<
aCryptoParameters
.
Length
(
)
;
+
+
a
)
{
if
(
aCryptoParameters
[
a
]
.
mType
!
=
ScopedCredentialType
:
:
ScopedCred
)
{
continue
;
}
nsString
algName
;
if
(
NS_FAILED
(
GetAlgorithmName
(
aCx
aCryptoParameters
[
a
]
.
mAlgorithm
algName
)
)
)
{
continue
;
}
ScopedCredentialParameters
normalizedObj
;
normalizedObj
.
mType
=
aCryptoParameters
[
a
]
.
mType
;
normalizedObj
.
mAlgorithm
.
SetAsString
(
)
.
Assign
(
algName
)
;
if
(
!
normalizedParams
.
AppendElement
(
normalizedObj
mozilla
:
:
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
promise
.
forget
(
)
;
}
}
if
(
normalizedParams
.
IsEmpty
(
)
&
&
!
aCryptoParameters
.
IsEmpty
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
challenge
;
if
(
!
challenge
.
Assign
(
aChallenge
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsAutoCString
clientDataJSON
;
srv
=
AssembleClientData
(
mOrigin
challenge
clientDataJSON
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
clientDataHash
;
if
(
!
clientDataHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
srv
=
HashCString
(
hashService
clientDataJSON
clientDataHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
CredentialPromise
>
monitorPromise
=
requestMonitor
-
>
Ensure
(
)
;
for
(
Authenticator
u2ftoken
:
mAuthenticators
)
{
U2FAuthMakeCredential
(
requestMonitor
u2ftoken
rpIdHash
clientDataJSON
clientDataHash
aAccount
normalizedParams
aOptions
.
mExcludeList
aOptions
.
mExtensions
)
;
}
requestMonitor
-
>
CompleteTask
(
)
;
monitorPromise
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
promise
]
(
CredentialPtr
aInfo
)
{
promise
-
>
MaybeResolve
(
aInfo
)
;
}
[
promise
]
(
nsresult
aErrorCode
)
{
promise
-
>
MaybeReject
(
aErrorCode
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
WebAuthentication
:
:
GetAssertion
(
const
ArrayBufferViewOrArrayBuffer
&
aChallenge
const
AssertionOptions
&
aOptions
)
{
MOZ_ASSERT
(
mParent
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
GetParentObject
(
)
)
;
if
(
!
global
)
{
return
nullptr
;
}
double
adjustedTimeout
=
30
.
0
;
if
(
aOptions
.
mTimeoutSeconds
.
WasPassed
(
)
)
{
adjustedTimeout
=
aOptions
.
mTimeoutSeconds
.
Value
(
)
;
adjustedTimeout
=
std
:
:
max
(
15
.
0
adjustedTimeout
)
;
adjustedTimeout
=
std
:
:
min
(
120
.
0
adjustedTimeout
)
;
}
RefPtr
<
AssertionRequest
>
requestMonitor
=
new
AssertionRequest
(
)
;
requestMonitor
-
>
SetDeadline
(
TimeDuration
:
:
FromSeconds
(
adjustedTimeout
)
)
;
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
rv
)
;
nsresult
initRv
=
InitLazily
(
)
;
if
(
NS_FAILED
(
initRv
)
)
{
promise
-
>
MaybeReject
(
initRv
)
;
return
promise
.
forget
(
)
;
}
if
(
mOrigin
.
EqualsLiteral
(
"
null
"
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
)
;
return
promise
.
forget
(
)
;
}
nsCString
rpId
;
if
(
!
aOptions
.
mRpId
.
WasPassed
(
)
)
{
rpId
.
Assign
(
NS_ConvertUTF16toUTF8
(
mOrigin
)
)
;
}
else
{
if
(
NS_FAILED
(
RelaxSameOrigin
(
aOptions
.
mRpId
.
Value
(
)
rpId
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
}
CryptoBuffer
rpIdHash
;
if
(
!
rpIdHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsresult
srv
;
nsCOMPtr
<
nsICryptoHash
>
hashService
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
srv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
srv
=
HashCString
(
hashService
rpId
rpIdHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
challenge
;
if
(
!
challenge
.
Assign
(
aChallenge
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
nsAutoCString
clientDataJSON
;
srv
=
AssembleClientData
(
mOrigin
challenge
clientDataJSON
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
CryptoBuffer
clientDataHash
;
if
(
!
clientDataHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
srv
=
HashCString
(
hashService
clientDataJSON
clientDataHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
!
aOptions
.
mAllowList
.
WasPassed
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_NOT_ALLOWED_ERR
)
;
return
promise
.
forget
(
)
;
}
const
Sequence
<
ScopedCredentialDescriptor
>
&
allowList
=
aOptions
.
mAllowList
.
Value
(
)
;
RefPtr
<
AssertionPromise
>
monitorPromise
=
requestMonitor
-
>
Ensure
(
)
;
for
(
Authenticator
u2ftoken
:
mAuthenticators
)
{
nsTArray
<
CryptoBuffer
>
credentialList
;
for
(
const
ScopedCredentialDescriptor
&
scd
:
allowList
)
{
CryptoBuffer
buf
;
if
(
NS_WARN_IF
(
!
buf
.
Assign
(
scd
.
mId
)
)
)
{
continue
;
}
if
(
!
credentialList
.
AppendElement
(
buf
mozilla
:
:
fallible
)
)
{
requestMonitor
-
>
CancelNow
(
)
;
promise
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
promise
.
forget
(
)
;
}
}
if
(
credentialList
.
IsEmpty
(
)
)
{
continue
;
}
U2FAuthGetAssertion
(
requestMonitor
u2ftoken
rpIdHash
clientDataJSON
clientDataHash
credentialList
aOptions
.
mExtensions
)
;
}
requestMonitor
-
>
CompleteTask
(
)
;
monitorPromise
-
>
Then
(
AbstractThread
:
:
MainThread
(
)
__func__
[
promise
]
(
AssertionPtr
aAssertion
)
{
promise
-
>
MaybeResolve
(
aAssertion
)
;
}
[
promise
]
(
nsresult
aErrorCode
)
{
promise
-
>
MaybeReject
(
aErrorCode
)
;
}
)
;
return
promise
.
forget
(
)
;
}
}
}
