#
include
"
mozilla
/
dom
/
WebAuthnUtil
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnCBORUtil
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
hasht
.
h
"
namespace
mozilla
:
:
dom
{
constexpr
auto
kGoogleAccountsAppId1
=
u
"
https
:
/
/
www
.
gstatic
.
com
/
securitykey
/
origins
.
json
"
_ns
;
constexpr
auto
kGoogleAccountsAppId2
=
u
"
https
:
/
/
www
.
gstatic
.
com
/
securitykey
/
a
/
google
.
com
/
origins
.
json
"
_ns
;
bool
EvaluateAppID
(
nsPIDOMWindowInner
*
aParent
const
nsString
&
aOrigin
nsString
&
aAppId
)
{
nsAutoCString
facetString
=
NS_ConvertUTF16toUTF8
(
aOrigin
)
;
nsCOMPtr
<
nsIURI
>
facetUri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
facetUri
)
facetString
)
)
)
{
return
false
;
}
if
(
!
facetUri
-
>
SchemeIs
(
"
https
"
)
)
{
return
false
;
}
if
(
aAppId
.
IsEmpty
(
)
|
|
aAppId
.
EqualsLiteral
(
"
null
"
)
)
{
aAppId
.
Assign
(
aOrigin
)
;
return
true
;
}
nsAutoCString
appIdString
=
NS_ConvertUTF16toUTF8
(
aAppId
)
;
nsCOMPtr
<
nsIURI
>
appIdUri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
appIdUri
)
appIdString
)
)
)
{
return
false
;
}
if
(
!
appIdUri
-
>
SchemeIs
(
"
https
"
)
)
{
return
false
;
}
nsAutoCString
appIdHost
;
if
(
NS_FAILED
(
appIdUri
-
>
GetAsciiHost
(
appIdHost
)
)
)
{
return
false
;
}
if
(
appIdHost
.
EqualsLiteral
(
"
localhost
"
)
)
{
nsAutoCString
facetHost
;
if
(
NS_FAILED
(
facetUri
-
>
GetAsciiHost
(
facetHost
)
)
)
{
return
false
;
}
if
(
facetHost
.
EqualsLiteral
(
"
localhost
"
)
)
{
return
true
;
}
}
nsCOMPtr
<
Document
>
document
=
aParent
-
>
GetDoc
(
)
;
if
(
!
document
|
|
!
document
-
>
IsHTMLDocument
(
)
)
{
return
false
;
}
nsHTMLDocument
*
html
=
document
-
>
AsHTMLDocument
(
)
;
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
return
false
;
}
nsAutoCString
lowestFacetHost
;
if
(
NS_FAILED
(
tldService
-
>
GetBaseDomain
(
facetUri
0
lowestFacetHost
)
)
)
{
return
false
;
}
if
(
html
-
>
IsRegistrableDomainSuffixOfOrEqualTo
(
NS_ConvertUTF8toUTF16
(
lowestFacetHost
)
appIdHost
)
)
{
return
true
;
}
if
(
lowestFacetHost
.
EqualsLiteral
(
"
google
.
com
"
)
&
&
(
aAppId
.
Equals
(
kGoogleAccountsAppId1
)
|
|
aAppId
.
Equals
(
kGoogleAccountsAppId2
)
)
)
{
return
true
;
}
return
false
;
}
nsresult
ReadToCryptoBuffer
(
pkix
:
:
Reader
&
aSrc
CryptoBuffer
&
aDest
uint32_t
aLen
)
{
if
(
aSrc
.
EnsureLength
(
aLen
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
if
(
!
aDest
.
SetCapacity
(
aLen
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
offset
=
0
;
offset
<
aLen
;
+
+
offset
)
{
uint8_t
b
;
if
(
aSrc
.
Read
(
b
)
!
=
pkix
:
:
Success
)
{
return
NS_ERROR_DOM_UNKNOWN_ERR
;
}
if
(
!
aDest
.
AppendElement
(
b
mozilla
:
:
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
static
nsresult
HashCString
(
nsICryptoHash
*
aHashService
const
nsACString
&
aIn
CryptoBuffer
&
aOut
)
{
MOZ_ASSERT
(
aHashService
)
;
nsresult
rv
=
aHashService
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aHashService
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
aIn
.
BeginReading
(
)
)
aIn
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
fullHash
;
rv
=
aHashService
-
>
Finish
(
false
fullHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
aOut
.
Assign
(
fullHash
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
nsresult
HashCString
(
const
nsACString
&
aIn
CryptoBuffer
&
aOut
)
{
nsresult
srv
;
nsCOMPtr
<
nsICryptoHash
>
hashService
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
srv
)
;
if
(
NS_FAILED
(
srv
)
)
{
return
srv
;
}
srv
=
HashCString
(
hashService
aIn
aOut
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
BuildTransactionHashes
(
const
nsCString
&
aRpId
const
nsCString
&
aClientDataJSON
CryptoBuffer
&
aRpIdHash
CryptoBuffer
&
aClientDataHash
)
{
nsresult
srv
;
nsCOMPtr
<
nsICryptoHash
>
hashService
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
srv
)
;
if
(
NS_FAILED
(
srv
)
)
{
return
srv
;
}
if
(
!
aRpIdHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
srv
=
HashCString
(
hashService
aRpId
aRpIdHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
aClientDataHash
.
SetLength
(
SHA256_LENGTH
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
srv
=
HashCString
(
hashService
aClientDataJSON
aClientDataHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
}
