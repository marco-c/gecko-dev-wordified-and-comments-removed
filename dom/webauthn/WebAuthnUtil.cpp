#
include
"
mozilla
/
dom
/
WebAuthnUtil
.
h
"
#
include
"
hasht
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozpkix
/
pkixutil
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
:
:
dom
{
bool
IsValidAppId
(
const
nsCOMPtr
<
nsIPrincipal
>
&
aPrincipal
const
nsCString
&
aAppId
)
{
auto
*
principal
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
nsCOMPtr
<
nsIURI
>
callerUri
;
nsresult
rv
=
principal
-
>
GetURI
(
getter_AddRefs
(
callerUri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
appIdUri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
appIdUri
)
aAppId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
!
appIdUri
-
>
SchemeIs
(
"
https
"
)
)
{
nsCString
facetId
;
rv
=
principal
-
>
GetWebExposedOriginSerialization
(
facetId
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
facetId
=
=
aAppId
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
return
false
;
}
nsAutoCString
baseDomainCaller
;
rv
=
tldService
-
>
GetBaseDomain
(
callerUri
0
baseDomainCaller
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
nsAutoCString
baseDomainAppId
;
rv
=
tldService
-
>
GetBaseDomain
(
appIdUri
0
baseDomainAppId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
baseDomainCaller
=
=
baseDomainAppId
)
{
return
true
;
}
if
(
baseDomainCaller
.
EqualsLiteral
(
"
google
.
com
"
)
&
&
(
aAppId
.
Equals
(
"
https
:
/
/
www
.
gstatic
.
com
/
securitykey
/
origins
.
json
"
_ns
)
|
|
aAppId
.
Equals
(
"
https
:
/
/
www
.
gstatic
.
com
/
securitykey
/
a
/
google
.
com
/
origins
.
json
"
_ns
)
)
)
{
return
true
;
}
return
false
;
}
nsresult
DefaultRpId
(
const
nsCOMPtr
<
nsIPrincipal
>
&
aPrincipal
nsACString
&
aRpId
)
{
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
NS_FAILED
(
basePrin
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
uri
-
>
GetAsciiHost
(
aRpId
)
;
}
bool
IsWebAuthnAllowedInDocument
(
const
nsCOMPtr
<
Document
>
&
aDoc
)
{
MOZ_ASSERT
(
aDoc
)
;
return
aDoc
-
>
IsHTMLOrXHTML
(
)
;
}
bool
IsWebAuthnAllowedForPrincipal
(
const
nsCOMPtr
<
nsIPrincipal
>
&
aPrincipal
)
{
MOZ_ASSERT
(
aPrincipal
)
;
if
(
aPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
false
;
}
if
(
aPrincipal
-
>
GetIsIpAddress
(
)
)
{
return
false
;
}
if
(
!
aPrincipal
-
>
GetIsOriginPotentiallyTrustworthy
(
)
)
{
return
false
;
}
return
true
;
}
bool
IsWebAuthnAllowedForTransportSecurityInfo
(
nsITransportSecurityInfo
*
aSecurityInfo
)
{
nsITransportSecurityInfo
:
:
OverridableErrorCategory
overridableErrorCategory
;
if
(
!
aSecurityInfo
|
|
NS_FAILED
(
aSecurityInfo
-
>
GetOverridableErrorCategory
(
&
overridableErrorCategory
)
)
)
{
return
false
;
}
switch
(
overridableErrorCategory
)
{
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_UNSET
:
return
true
;
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_TIME
:
return
true
;
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_TRUST
:
return
false
;
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_DOMAIN
:
return
false
;
default
:
return
false
;
}
}
bool
IsValidRpId
(
const
nsCOMPtr
<
nsIPrincipal
>
&
aPrincipal
const
nsACString
&
aRpId
)
{
nsCString
normalizedRpId
;
nsresult
rv
=
NS_DomainToASCII
(
aRpId
normalizedRpId
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
normalizedRpId
!
=
aRpId
)
{
return
false
;
}
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
nsCOMPtr
<
nsIURI
>
currentURI
;
if
(
NS_FAILED
(
basePrin
-
>
GetURI
(
getter_AddRefs
(
currentURI
)
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
targetURI
;
rv
=
NS_MutateURI
(
currentURI
)
.
SetHost
(
aRpId
)
.
Finalize
(
targetURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
Document
:
:
IsValidDomain
(
currentURI
targetURI
)
;
}
static
nsresult
HashCString
(
nsICryptoHash
*
aHashService
const
nsACString
&
aIn
nsTArray
<
uint8_t
>
&
aOut
)
{
MOZ_ASSERT
(
aHashService
)
;
nsresult
rv
=
aHashService
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aHashService
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
aIn
.
BeginReading
(
)
)
aIn
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
fullHash
;
rv
=
aHashService
-
>
Finish
(
false
fullHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOut
.
Clear
(
)
;
aOut
.
AppendElements
(
reinterpret_cast
<
uint8_t
const
*
>
(
fullHash
.
BeginReading
(
)
)
fullHash
.
Length
(
)
)
;
return
NS_OK
;
}
nsresult
HashCString
(
const
nsACString
&
aIn
nsTArray
<
uint8_t
>
&
aOut
)
{
nsresult
srv
;
nsCOMPtr
<
nsICryptoHash
>
hashService
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
srv
)
;
if
(
NS_FAILED
(
srv
)
)
{
return
srv
;
}
srv
=
HashCString
(
hashService
aIn
aOut
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
srv
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
}
