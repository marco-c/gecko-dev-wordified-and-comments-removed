#
ifndef
mozilla_dom_WebAuthnController_h
#
define
mozilla_dom_WebAuthnController_h
#
include
"
nsIWebAuthnController
.
h
"
#
include
"
mozilla
/
dom
/
PWebAuthnTransaction
.
h
"
#
include
"
mozilla
/
Tainting
.
h
"
namespace
mozilla
:
:
dom
{
class
WebAuthnController
final
:
public
nsIWebAuthnController
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIU2FTOKENMANAGER
NS_DECL_NSIWEBAUTHNCONTROLLER
static
void
Initialize
(
)
;
static
WebAuthnController
*
Get
(
)
;
void
Register
(
PWebAuthnTransactionParent
*
aTransactionParent
const
uint64_t
&
aTransactionId
const
WebAuthnMakeCredentialInfo
&
aInfo
)
;
void
Sign
(
PWebAuthnTransactionParent
*
aTransactionParent
const
uint64_t
&
aTransactionId
const
WebAuthnGetAssertionInfo
&
aInfo
)
;
void
Cancel
(
PWebAuthnTransactionParent
*
aTransactionParent
const
Tainted
<
uint64_t
>
&
aTransactionId
)
;
void
MaybeClearTransaction
(
PWebAuthnTransactionParent
*
aParent
)
;
uint64_t
GetCurrentTransactionId
(
)
{
return
mTransaction
.
isNothing
(
)
?
0
:
mTransaction
.
ref
(
)
.
mTransactionId
;
}
bool
CurrentTransactionIsRegister
(
)
{
return
mPendingRegisterInfo
.
isSome
(
)
;
}
bool
CurrentTransactionIsSign
(
)
{
return
mPendingSignInfo
.
isSome
(
)
;
}
template
<
typename
.
.
.
T
>
void
SendPromptNotification
(
const
char16_t
*
aFormat
T
.
.
.
aArgs
)
;
void
RunSendPromptNotification
(
const
nsString
&
aJSON
)
;
private
:
WebAuthnController
(
)
;
~
WebAuthnController
(
)
=
default
;
nsCOMPtr
<
nsIWebAuthnTransport
>
GetTransportImpl
(
)
;
void
AbortTransaction
(
const
uint64_t
&
aTransactionId
const
nsresult
&
aError
bool
shouldCancelActiveDialog
)
;
void
AbortOngoingTransaction
(
)
;
void
ClearTransaction
(
bool
cancel_prompt
)
;
void
DoRegister
(
const
WebAuthnMakeCredentialInfo
&
aInfo
bool
aForceNoneAttestation
)
;
void
DoSign
(
const
WebAuthnGetAssertionInfo
&
aTransactionInfo
)
;
void
RunFinishRegister
(
uint64_t
aTransactionId
const
RefPtr
<
nsICtapRegisterResult
>
&
aResult
)
;
void
RunFinishSign
(
uint64_t
aTransactionId
const
nsTArray
<
RefPtr
<
nsICtapSignResult
>
>
&
aResult
)
;
void
RunResumeRegister
(
uint64_t
aTransactionId
bool
aForceNoneAttestation
)
;
void
RunResumeSign
(
uint64_t
aTransactionId
)
;
void
RunResumeWithSelectedSignResult
(
uint64_t
aTransactionId
uint64_t
idx
)
;
void
RunPinCallback
(
uint64_t
aTransactionId
const
nsCString
&
aPin
)
;
void
RunCancel
(
uint64_t
aTransactionId
)
;
PWebAuthnTransactionParent
*
mTransactionParent
;
nsCOMPtr
<
nsIWebAuthnTransport
>
mTransportImpl
;
Maybe
<
WebAuthnMakeCredentialInfo
>
mPendingRegisterInfo
;
Maybe
<
WebAuthnGetAssertionInfo
>
mPendingSignInfo
;
nsTArray
<
RefPtr
<
nsICtapSignResult
>
>
mPendingSignResults
;
class
Transaction
{
public
:
Transaction
(
uint64_t
aTransactionId
const
nsTArray
<
uint8_t
>
&
aRpIdHash
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aAppIdHash
const
nsCString
&
aClientDataJSON
bool
aForceNoneAttestation
=
false
)
:
mTransactionId
(
aTransactionId
)
mRpIdHash
(
aRpIdHash
.
Clone
(
)
)
mClientDataJSON
(
aClientDataJSON
)
{
if
(
aAppIdHash
.
isSome
(
)
)
{
mAppIdHash
=
Some
(
aAppIdHash
.
ref
(
)
.
Clone
(
)
)
;
}
else
{
mAppIdHash
=
Nothing
(
)
;
}
}
uint64_t
mTransactionId
;
nsTArray
<
uint8_t
>
mRpIdHash
;
Maybe
<
nsTArray
<
uint8_t
>
>
mAppIdHash
;
nsCString
mClientDataJSON
;
}
;
Maybe
<
Transaction
>
mTransaction
;
}
;
}
#
endif
