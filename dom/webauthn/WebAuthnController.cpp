#
include
"
json
/
json
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnController
.
h
"
#
include
"
mozilla
/
dom
/
PWebAuthnTransactionParent
.
h
"
#
include
"
mozilla
/
dom
/
WebAuthnUtil
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsTextFormatter
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
AuthrsTransport
.
h
"
#
include
"
CtapArgs
.
h
"
#
include
"
CtapResults
.
h
"
#
include
"
U2FSoftTokenTransport
.
h
"
#
include
"
WebAuthnEnumStrings
.
h
"
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
mozilla
/
dom
/
AndroidWebAuthnTokenManager
.
h
"
#
endif
namespace
mozilla
:
:
dom
{
namespace
{
static
mozilla
:
:
LazyLogModule
gWebAuthnControllerLog
(
"
webauthncontroller
"
)
;
StaticRefPtr
<
WebAuthnController
>
gWebAuthnController
;
static
nsIThread
*
gWebAuthnBackgroundThread
;
}
static
const
char16_t
kRegisterPromptNotification
[
]
=
u
"
{
\
"
is_ctap2
\
"
:
true
\
"
action
\
"
:
\
"
register
\
"
\
"
tid
\
"
:
%
llu
"
u
"
\
"
origin
\
"
:
\
"
%
s
\
"
\
"
browsingContextId
\
"
:
%
llu
\
"
device_selected
\
"
:
%
s
}
"
;
static
const
char16_t
kRegisterDirectPromptNotification
[
]
=
u
"
{
\
"
is_ctap2
\
"
:
true
\
"
action
\
"
:
\
"
register
-
direct
\
"
\
"
tid
\
"
:
%
llu
"
u
"
\
"
origin
\
"
:
\
"
%
s
\
"
\
"
browsingContextId
\
"
:
%
llu
}
"
;
static
const
char16_t
kSignPromptNotification
[
]
=
u
"
{
\
"
is_ctap2
\
"
:
true
\
"
action
\
"
:
\
"
sign
\
"
\
"
tid
\
"
:
%
llu
\
"
origin
\
"
:
\
"
%
s
\
"
"
u
"
\
"
browsingContextId
\
"
:
%
llu
\
"
device_selected
\
"
:
%
s
}
"
;
static
const
char16_t
kCancelPromptNotification
[
]
=
u
"
{
\
"
is_ctap2
\
"
:
true
\
"
action
\
"
:
\
"
cancel
\
"
\
"
tid
\
"
:
%
llu
}
"
;
static
const
char16_t
kSelectSignResultNotification
[
]
=
u
"
{
\
"
is_ctap2
\
"
:
true
\
"
action
\
"
:
\
"
select
-
sign
-
result
\
"
\
"
tid
\
"
:
%
llu
"
u
"
\
"
origin
\
"
:
\
"
%
s
\
"
\
"
browsingContextId
\
"
:
%
llu
\
"
usernames
\
"
:
[
%
s
]
}
"
;
NS_IMPL_ISUPPORTS
(
WebAuthnController
nsIWebAuthnController
nsIU2FTokenManager
)
;
WebAuthnController
:
:
WebAuthnController
(
)
:
mTransactionParent
(
nullptr
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
WebAuthnController
:
:
Initialize
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
gWebAuthnController
)
;
gWebAuthnController
=
new
WebAuthnController
(
)
;
ClearOnShutdown
(
&
gWebAuthnController
)
;
}
WebAuthnController
*
WebAuthnController
:
:
Get
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
return
gWebAuthnController
;
}
void
WebAuthnController
:
:
AbortTransaction
(
const
uint64_t
&
aTransactionId
const
nsresult
&
aError
bool
shouldCancelActiveDialog
)
{
if
(
mTransactionParent
&
&
mTransaction
.
isSome
(
)
&
&
aTransactionId
>
0
&
&
aTransactionId
=
=
mTransaction
.
ref
(
)
.
mTransactionId
)
{
Unused
<
<
mTransactionParent
-
>
SendAbort
(
aTransactionId
aError
)
;
ClearTransaction
(
shouldCancelActiveDialog
)
;
}
}
void
WebAuthnController
:
:
AbortOngoingTransaction
(
)
{
if
(
mTransaction
.
isSome
(
)
)
{
AbortTransaction
(
mTransaction
.
ref
(
)
.
mTransactionId
NS_ERROR_DOM_ABORT_ERR
true
)
;
}
}
void
WebAuthnController
:
:
MaybeClearTransaction
(
PWebAuthnTransactionParent
*
aParent
)
{
if
(
mTransactionParent
=
=
aParent
)
{
ClearTransaction
(
true
)
;
}
}
void
WebAuthnController
:
:
ClearTransaction
(
bool
cancel_prompt
)
{
if
(
cancel_prompt
&
&
mTransaction
.
isSome
(
)
&
&
mTransaction
.
ref
(
)
.
mTransactionId
>
0
)
{
SendPromptNotification
(
kCancelPromptNotification
mTransaction
.
ref
(
)
.
mTransactionId
)
;
}
mTransactionParent
=
nullptr
;
mTransportImpl
=
nullptr
;
mPendingRegisterInfo
.
reset
(
)
;
mPendingSignInfo
.
reset
(
)
;
mPendingSignResults
.
Clear
(
)
;
mTransaction
.
reset
(
)
;
}
template
<
typename
.
.
.
T
>
void
WebAuthnController
:
:
SendPromptNotification
(
const
char16_t
*
aFormat
T
.
.
.
aArgs
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsAutoString
json
;
nsTextFormatter
:
:
ssprintf
(
json
aFormat
aArgs
.
.
.
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
nsString
>
(
"
WebAuthnController
:
:
RunSendPromptNotification
"
this
&
WebAuthnController
:
:
RunSendPromptNotification
json
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
GetMainThreadSerialEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
NS_IMETHODIMP
WebAuthnController
:
:
SendPromptNotificationPreformatted
(
uint64_t
aTransactionId
const
nsACString
&
aJson
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
nsString
>
(
"
WebAuthnController
:
:
RunSendPromptNotification
"
this
&
WebAuthnController
:
:
RunSendPromptNotification
NS_ConvertUTF8toUTF16
(
aJson
)
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
GetMainThreadSerialEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
return
NS_OK
;
}
void
WebAuthnController
:
:
RunSendPromptNotification
(
const
nsString
&
aJSON
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
os
)
)
{
return
;
}
nsCOMPtr
<
nsIWebAuthnController
>
self
=
this
;
MOZ_ALWAYS_SUCCEEDS
(
os
-
>
NotifyObservers
(
self
"
webauthn
-
prompt
"
aJSON
.
get
(
)
)
)
;
}
nsCOMPtr
<
nsIWebAuthnTransport
>
WebAuthnController
:
:
GetTransportImpl
(
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
mTransportImpl
)
{
return
mTransportImpl
;
}
#
if
0
#
ifdef
MOZ_WIDGET_ANDROID
if
(
StaticPrefs
:
:
security_webauth_webauthn_enable_android_fido2
(
)
)
{
nsCOMPtr
<
nsIWebAuthnTransport
>
transport
=
AndroidWebAuthnTokenManager
:
:
GetInstance
(
)
;
transport
-
>
SetController
(
this
)
;
return
transport
;
}
#
endif
#
endif
if
(
StaticPrefs
:
:
security_webauth_webauthn_enable_usbtoken
(
)
)
{
nsCOMPtr
<
nsIWebAuthnTransport
>
transport
=
NewAuthrsTransport
(
)
;
transport
-
>
SetController
(
this
)
;
return
transport
;
}
if
(
StaticPrefs
:
:
security_webauth_webauthn_enable_softtoken
(
)
)
{
nsCOMPtr
<
nsIWebAuthnTransport
>
transport
=
new
U2FSoftTokenTransport
(
StaticPrefs
:
:
security_webauth_softtoken_counter
(
)
)
;
transport
-
>
SetController
(
this
)
;
return
transport
;
}
return
nullptr
;
}
void
WebAuthnController
:
:
Cancel
(
PWebAuthnTransactionParent
*
aTransactionParent
const
Tainted
<
uint64_t
>
&
aTransactionId
)
{
if
(
mTransactionParent
!
=
aTransactionParent
|
|
mTransaction
.
isNothing
(
)
|
|
!
MOZ_IS_VALID
(
aTransactionId
mTransaction
.
ref
(
)
.
mTransactionId
=
=
aTransactionId
)
)
{
return
;
}
if
(
mTransportImpl
)
{
mTransportImpl
-
>
Cancel
(
)
;
}
ClearTransaction
(
true
)
;
}
void
WebAuthnController
:
:
Register
(
PWebAuthnTransactionParent
*
aTransactionParent
const
uint64_t
&
aTransactionId
const
WebAuthnMakeCredentialInfo
&
aInfo
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
MOZ_LOG
(
gWebAuthnControllerLog
LogLevel
:
:
Debug
(
"
WebAuthnController
:
:
Register
"
)
)
;
MOZ_ASSERT
(
aTransactionId
>
0
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
gWebAuthnBackgroundThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
gWebAuthnBackgroundThread
"
This
should
never
be
null
!
"
)
;
}
AbortOngoingTransaction
(
)
;
mTransactionParent
=
aTransactionParent
;
CryptoBuffer
rpIdHash
clientDataHash
;
NS_ConvertUTF16toUTF8
rpId
(
aInfo
.
RpId
(
)
)
;
nsresult
rv
=
BuildTransactionHashes
(
rpId
aInfo
.
ClientDataJSON
(
)
rpIdHash
clientDataHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Unused
<
<
mTransactionParent
-
>
SendAbort
(
aTransactionId
NS_ERROR_DOM_UNKNOWN_ERR
)
;
return
;
}
mTransaction
=
Some
(
Transaction
(
aTransactionId
rpIdHash
Nothing
(
)
aInfo
.
ClientDataJSON
(
)
)
)
;
MOZ_ASSERT
(
mPendingRegisterInfo
.
isNothing
(
)
)
;
mPendingRegisterInfo
=
Some
(
aInfo
)
;
bool
noneAttestationRequested
=
true
;
#
ifndef
MOZ_WIDGET_ANDROID
const
auto
&
extra
=
aInfo
.
Extra
(
)
.
ref
(
)
;
const
nsString
&
attestation
=
extra
.
attestationConveyancePreference
(
)
;
static_assert
(
MOZ_WEBAUTHN_ENUM_STRINGS_VERSION
=
=
2
)
;
if
(
attestation
.
EqualsLiteral
(
MOZ_WEBAUTHN_ATTESTATION_CONVEYANCE_PREFERENCE_DIRECT
)
|
|
attestation
.
EqualsLiteral
(
MOZ_WEBAUTHN_ATTESTATION_CONVEYANCE_PREFERENCE_INDIRECT
)
|
|
attestation
.
EqualsLiteral
(
MOZ_WEBAUTHN_ATTESTATION_CONVEYANCE_PREFERENCE_ENTERPRISE
)
)
{
noneAttestationRequested
=
false
;
}
#
endif
if
(
noneAttestationRequested
|
|
StaticPrefs
:
:
security_webauth_webauthn_testing_allow_direct_attestation
(
)
)
{
DoRegister
(
aInfo
noneAttestationRequested
)
;
return
;
}
NS_ConvertUTF16toUTF8
origin
(
aInfo
.
Origin
(
)
)
;
SendPromptNotification
(
kRegisterDirectPromptNotification
aTransactionId
origin
.
get
(
)
aInfo
.
BrowsingContextId
(
)
)
;
}
void
WebAuthnController
:
:
DoRegister
(
const
WebAuthnMakeCredentialInfo
&
aInfo
bool
aForceNoneAttestation
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mTransaction
.
isSome
(
)
)
;
if
(
NS_WARN_IF
(
mTransaction
.
isNothing
(
)
)
)
{
return
;
}
NS_ConvertUTF16toUTF8
origin
(
aInfo
.
Origin
(
)
)
;
SendPromptNotification
(
kRegisterPromptNotification
mTransaction
.
ref
(
)
.
mTransactionId
origin
.
get
(
)
aInfo
.
BrowsingContextId
(
)
"
false
"
)
;
RefPtr
<
CtapRegisterArgs
>
args
(
new
CtapRegisterArgs
(
aInfo
aForceNoneAttestation
)
)
;
mTransportImpl
=
GetTransportImpl
(
)
;
if
(
!
mTransportImpl
)
{
AbortTransaction
(
mTransaction
.
ref
(
)
.
mTransactionId
NS_ERROR_DOM_NOT_ALLOWED_ERR
true
)
;
return
;
}
nsresult
rv
=
mTransportImpl
-
>
MakeCredential
(
mTransaction
.
ref
(
)
.
mTransactionId
aInfo
.
BrowsingContextId
(
)
args
)
;
if
(
NS_FAILED
(
rv
)
)
{
AbortTransaction
(
mTransaction
.
ref
(
)
.
mTransactionId
rv
true
)
;
return
;
}
}
NS_IMETHODIMP
WebAuthnController
:
:
ResumeRegister
(
uint64_t
aTransactionId
bool
aForceNoneAttestation
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
uint64_t
bool
>
(
"
WebAuthnController
:
:
RunResumeRegister
"
this
&
WebAuthnController
:
:
RunResumeRegister
aTransactionId
aForceNoneAttestation
)
)
;
return
gWebAuthnBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
WebAuthnController
:
:
RunResumeRegister
(
uint64_t
aTransactionId
bool
aForceNoneAttestation
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
mPendingRegisterInfo
.
isNothing
(
)
)
)
{
return
;
}
if
(
mTransaction
.
isNothing
(
)
|
|
mTransaction
.
ref
(
)
.
mTransactionId
!
=
aTransactionId
)
{
return
;
}
DoRegister
(
mPendingRegisterInfo
.
ref
(
)
aForceNoneAttestation
)
;
}
NS_IMETHODIMP
WebAuthnController
:
:
FinishRegister
(
uint64_t
aTransactionId
nsICtapRegisterResult
*
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
uint64_t
RefPtr
<
nsICtapRegisterResult
>
>
(
"
WebAuthnController
:
:
RunFinishRegister
"
this
&
WebAuthnController
:
:
RunFinishRegister
aTransactionId
aResult
)
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
return
NS_ERROR_FAILURE
;
}
return
gWebAuthnBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
WebAuthnController
:
:
RunFinishRegister
(
uint64_t
aTransactionId
const
RefPtr
<
nsICtapRegisterResult
>
&
aResult
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
mTransaction
.
isNothing
(
)
|
|
aTransactionId
!
=
mTransaction
.
ref
(
)
.
mTransactionId
)
{
return
;
}
nsresult
status
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aResult
-
>
GetStatus
(
&
status
)
)
)
;
if
(
NS_FAILED
(
status
)
)
{
bool
shouldCancelActiveDialog
=
true
;
if
(
status
=
=
NS_ERROR_DOM_OPERATION_ERR
)
{
shouldCancelActiveDialog
=
false
;
}
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SECURITY_WEBAUTHN_USED
u
"
CTAPRegisterAbort
"
_ns
1
)
;
AbortTransaction
(
aTransactionId
status
shouldCancelActiveDialog
)
;
return
;
}
nsCString
clientDataJson
=
mPendingRegisterInfo
.
ref
(
)
.
ClientDataJSON
(
)
;
nsTArray
<
uint8_t
>
attObj
;
nsresult
rv
=
aResult
-
>
GetAttestationObject
(
attObj
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
AbortTransaction
(
aTransactionId
NS_ERROR_FAILURE
true
)
;
return
;
}
nsTArray
<
uint8_t
>
credentialId
;
rv
=
aResult
-
>
GetCredentialId
(
credentialId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
AbortTransaction
(
aTransactionId
NS_ERROR_FAILURE
true
)
;
return
;
}
nsTArray
<
WebAuthnExtensionResult
>
extensions
;
nsTArray
<
uint8_t
>
regData
;
WebAuthnMakeCredentialResult
result
(
clientDataJson
attObj
credentialId
regData
extensions
)
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SECURITY_WEBAUTHN_USED
u
"
CTAPRegisterFinish
"
_ns
1
)
;
Unused
<
<
mTransactionParent
-
>
SendConfirmRegister
(
aTransactionId
result
)
;
ClearTransaction
(
true
)
;
}
void
WebAuthnController
:
:
Sign
(
PWebAuthnTransactionParent
*
aTransactionParent
const
uint64_t
&
aTransactionId
const
WebAuthnGetAssertionInfo
&
aInfo
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
MOZ_LOG
(
gWebAuthnControllerLog
LogLevel
:
:
Debug
(
"
WebAuthnSign
"
)
)
;
MOZ_ASSERT
(
aTransactionId
>
0
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
gWebAuthnBackgroundThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
gWebAuthnBackgroundThread
"
This
should
never
be
null
!
"
)
;
}
AbortOngoingTransaction
(
)
;
mTransactionParent
=
aTransactionParent
;
CryptoBuffer
rpIdHash
clientDataHash
;
NS_ConvertUTF16toUTF8
rpId
(
aInfo
.
RpId
(
)
)
;
nsresult
rv
=
BuildTransactionHashes
(
rpId
aInfo
.
ClientDataJSON
(
)
rpIdHash
clientDataHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Unused
<
<
mTransactionParent
-
>
SendAbort
(
aTransactionId
NS_ERROR_DOM_UNKNOWN_ERR
)
;
return
;
}
Maybe
<
nsTArray
<
uint8_t
>
>
appIdHash
=
Nothing
(
)
;
if
(
aInfo
.
Extra
(
)
.
isSome
(
)
)
{
const
auto
&
extra
=
aInfo
.
Extra
(
)
.
ref
(
)
;
for
(
const
WebAuthnExtension
&
ext
:
extra
.
Extensions
(
)
)
{
if
(
ext
.
type
(
)
=
=
WebAuthnExtension
:
:
TWebAuthnExtensionAppId
)
{
appIdHash
=
Some
(
ext
.
get_WebAuthnExtensionAppId
(
)
.
AppId
(
)
.
Clone
(
)
)
;
}
}
}
mTransaction
=
Some
(
Transaction
(
aTransactionId
rpIdHash
appIdHash
aInfo
.
ClientDataJSON
(
)
)
)
;
mPendingSignInfo
=
Some
(
aInfo
)
;
NS_ConvertUTF16toUTF8
origin
(
aInfo
.
Origin
(
)
)
;
SendPromptNotification
(
kSignPromptNotification
mTransaction
.
ref
(
)
.
mTransactionId
origin
.
get
(
)
aInfo
.
BrowsingContextId
(
)
"
false
"
)
;
RefPtr
<
CtapSignArgs
>
args
(
new
CtapSignArgs
(
aInfo
)
)
;
mTransportImpl
=
GetTransportImpl
(
)
;
if
(
!
mTransportImpl
)
{
AbortTransaction
(
mTransaction
.
ref
(
)
.
mTransactionId
NS_ERROR_DOM_NOT_ALLOWED_ERR
true
)
;
return
;
}
rv
=
mTransportImpl
-
>
GetAssertion
(
mTransaction
.
ref
(
)
.
mTransactionId
aInfo
.
BrowsingContextId
(
)
args
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
AbortTransaction
(
mTransaction
.
ref
(
)
.
mTransactionId
rv
true
)
;
return
;
}
}
NS_IMETHODIMP
WebAuthnController
:
:
FinishSign
(
uint64_t
aTransactionId
const
nsTArray
<
RefPtr
<
nsICtapSignResult
>
>
&
aResult
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsTArray
<
RefPtr
<
nsICtapSignResult
>
>
ownedResult
=
aResult
.
Clone
(
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
uint64_t
nsTArray
<
RefPtr
<
nsICtapSignResult
>
>
>
(
"
WebAuthnController
:
:
RunFinishSign
"
this
&
WebAuthnController
:
:
RunFinishSign
aTransactionId
std
:
:
move
(
ownedResult
)
)
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
return
NS_ERROR_FAILURE
;
}
return
gWebAuthnBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
WebAuthnController
:
:
RunFinishSign
(
uint64_t
aTransactionId
const
nsTArray
<
RefPtr
<
nsICtapSignResult
>
>
&
aResult
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
mTransaction
.
isNothing
(
)
|
|
aTransactionId
!
=
mTransaction
.
ref
(
)
.
mTransactionId
)
{
return
;
}
if
(
aResult
.
Length
(
)
=
=
0
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SECURITY_WEBAUTHN_USED
u
"
CTAPSignAbort
"
_ns
1
)
;
AbortTransaction
(
aTransactionId
NS_ERROR_DOM_UNKNOWN_ERR
true
)
;
return
;
}
if
(
aResult
.
Length
(
)
=
=
1
)
{
nsresult
status
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aResult
[
0
]
-
>
GetStatus
(
&
status
)
)
)
;
if
(
NS_FAILED
(
status
)
)
{
bool
shouldCancelActiveDialog
=
true
;
if
(
status
=
=
NS_ERROR_DOM_OPERATION_ERR
)
{
shouldCancelActiveDialog
=
false
;
}
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SECURITY_WEBAUTHN_USED
u
"
CTAPSignAbort
"
_ns
1
)
;
AbortTransaction
(
aTransactionId
status
shouldCancelActiveDialog
)
;
return
;
}
mPendingSignResults
=
aResult
.
Clone
(
)
;
RunResumeWithSelectedSignResult
(
aTransactionId
0
)
;
return
;
}
for
(
const
auto
&
assertion
:
aResult
)
{
nsresult
status
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
assertion
-
>
GetStatus
(
&
status
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
status
)
)
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SECURITY_WEBAUTHN_USED
u
"
CTAPSignAbort
"
_ns
1
)
;
AbortTransaction
(
aTransactionId
status
true
)
;
return
;
}
}
nsCString
usernames
;
StringJoinAppend
(
usernames
"
"
_ns
aResult
[
]
(
nsACString
&
dst
const
RefPtr
<
nsICtapSignResult
>
&
assertion
)
{
nsCString
username
;
nsresult
rv
=
assertion
-
>
GetUserName
(
username
)
;
if
(
NS_FAILED
(
rv
)
)
{
username
.
Assign
(
"
<
Unknown
username
>
"
)
;
}
nsCString
escaped_username
;
NS_Escape
(
username
escaped_username
url_XAlphas
)
;
dst
.
Append
(
"
\
"
"
_ns
+
escaped_username
+
"
\
"
"
_ns
)
;
}
)
;
mPendingSignResults
=
aResult
.
Clone
(
)
;
NS_ConvertUTF16toUTF8
origin
(
mPendingSignInfo
.
ref
(
)
.
Origin
(
)
)
;
SendPromptNotification
(
kSelectSignResultNotification
mTransaction
.
ref
(
)
.
mTransactionId
origin
.
get
(
)
mPendingSignInfo
.
ref
(
)
.
BrowsingContextId
(
)
usernames
.
get
(
)
)
;
}
NS_IMETHODIMP
WebAuthnController
:
:
SignatureSelectionCallback
(
uint64_t
aTransactionId
uint64_t
idx
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
uint64_t
uint64_t
>
(
"
WebAuthnController
:
:
RunResumeWithSelectedSignResult
"
this
&
WebAuthnController
:
:
RunResumeWithSelectedSignResult
aTransactionId
idx
)
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
return
NS_ERROR_FAILURE
;
}
return
gWebAuthnBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
WebAuthnController
:
:
RunResumeWithSelectedSignResult
(
uint64_t
aTransactionId
uint64_t
idx
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
mTransaction
.
isNothing
(
)
|
|
mTransaction
.
ref
(
)
.
mTransactionId
!
=
aTransactionId
)
{
return
;
}
if
(
NS_WARN_IF
(
mPendingSignResults
.
Length
(
)
<
=
idx
)
)
{
return
;
}
RefPtr
<
nsICtapSignResult
>
&
selected
=
mPendingSignResults
[
idx
]
;
nsTArray
<
uint8_t
>
credentialId
;
nsresult
rv
=
selected
-
>
GetCredentialId
(
credentialId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
AbortTransaction
(
aTransactionId
NS_ERROR_FAILURE
true
)
;
return
;
}
nsTArray
<
uint8_t
>
signature
;
rv
=
selected
-
>
GetSignature
(
signature
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
AbortTransaction
(
aTransactionId
NS_ERROR_FAILURE
true
)
;
return
;
}
nsTArray
<
uint8_t
>
authenticatorData
;
rv
=
selected
-
>
GetAuthenticatorData
(
authenticatorData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
AbortTransaction
(
aTransactionId
NS_ERROR_FAILURE
true
)
;
return
;
}
nsTArray
<
uint8_t
>
rpIdHash
;
rv
=
selected
-
>
GetRpIdHash
(
rpIdHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
AbortTransaction
(
aTransactionId
NS_ERROR_FAILURE
true
)
;
return
;
}
nsTArray
<
uint8_t
>
userHandle
;
Unused
<
<
selected
-
>
GetUserHandle
(
userHandle
)
;
nsTArray
<
WebAuthnExtensionResult
>
extensions
;
if
(
mTransaction
.
ref
(
)
.
mAppIdHash
.
isSome
(
)
)
{
bool
usedAppId
=
(
rpIdHash
=
=
mTransaction
.
ref
(
)
.
mAppIdHash
.
ref
(
)
)
;
extensions
.
AppendElement
(
WebAuthnExtensionResultAppId
(
usedAppId
)
)
;
}
nsTArray
<
uint8_t
>
signatureData
;
WebAuthnGetAssertionResult
result
(
mTransaction
.
ref
(
)
.
mClientDataJSON
credentialId
signature
authenticatorData
extensions
signatureData
userHandle
)
;
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
SECURITY_WEBAUTHN_USED
u
"
CTAPSignFinish
"
_ns
1
)
;
Unused
<
<
mTransactionParent
-
>
SendConfirmSign
(
aTransactionId
result
)
;
ClearTransaction
(
true
)
;
}
NS_IMETHODIMP
WebAuthnController
:
:
PinCallback
(
uint64_t
aTransactionId
const
nsACString
&
aPin
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
uint64_t
nsCString
>
(
"
WebAuthnController
:
:
RunPinCallback
"
this
&
WebAuthnController
:
:
RunPinCallback
aTransactionId
aPin
)
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
return
NS_ERROR_FAILURE
;
}
return
gWebAuthnBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
WebAuthnController
:
:
RunPinCallback
(
uint64_t
aTransactionId
const
nsCString
&
aPin
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
mTransportImpl
)
{
mTransportImpl
-
>
PinCallback
(
aTransactionId
aPin
)
;
}
}
NS_IMETHODIMP
WebAuthnController
:
:
Cancel
(
uint64_t
aTransactionId
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewRunnableMethod
<
uint64_t
>
(
"
WebAuthnController
:
:
RunCancel
"
this
&
WebAuthnController
:
:
RunCancel
aTransactionId
)
)
;
if
(
!
gWebAuthnBackgroundThread
)
{
return
NS_ERROR_FAILURE
;
}
return
gWebAuthnBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
WebAuthnController
:
:
RunCancel
(
uint64_t
aTransactionId
)
{
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
(
)
;
if
(
mTransaction
.
isNothing
(
)
|
|
mTransaction
.
ref
(
)
.
mTransactionId
!
=
aTransactionId
)
{
return
;
}
if
(
mTransportImpl
)
{
mTransportImpl
-
>
Cancel
(
)
;
}
AbortTransaction
(
aTransactionId
NS_ERROR_DOM_NOT_ALLOWED_ERR
true
)
;
}
}
