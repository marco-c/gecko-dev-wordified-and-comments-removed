#
include
"
mozilla
/
dom
/
U2FHIDTokenManager
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
namespace
mozilla
{
namespace
dom
{
static
StaticMutex
gInstanceMutex
;
static
U2FHIDTokenManager
*
gInstance
;
static
nsIThread
*
gPBackgroundThread
;
static
void
u2f_register_callback
(
uint64_t
aTransactionId
rust_u2f_result
*
aResult
)
{
StaticMutexAutoLock
lock
(
gInstanceMutex
)
;
if
(
!
gInstance
|
|
NS_WARN_IF
(
!
gPBackgroundThread
)
)
{
return
;
}
UniquePtr
<
U2FResult
>
rv
=
MakeUnique
<
U2FResult
>
(
aTransactionId
aResult
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewNonOwningRunnableMethod
<
UniquePtr
<
U2FResult
>
&
&
>
(
"
U2FHIDTokenManager
:
:
HandleRegisterResult
"
gInstance
&
U2FHIDTokenManager
:
:
HandleRegisterResult
Move
(
rv
)
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
gPBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
static
void
u2f_sign_callback
(
uint64_t
aTransactionId
rust_u2f_result
*
aResult
)
{
StaticMutexAutoLock
lock
(
gInstanceMutex
)
;
if
(
!
gInstance
|
|
NS_WARN_IF
(
!
gPBackgroundThread
)
)
{
return
;
}
UniquePtr
<
U2FResult
>
rv
=
MakeUnique
<
U2FResult
>
(
aTransactionId
aResult
)
;
nsCOMPtr
<
nsIRunnable
>
r
(
NewNonOwningRunnableMethod
<
UniquePtr
<
U2FResult
>
&
&
>
(
"
U2FHIDTokenManager
:
:
HandleSignResult
"
gInstance
&
U2FHIDTokenManager
:
:
HandleSignResult
Move
(
rv
)
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
gPBackgroundThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
U2FHIDTokenManager
:
:
U2FHIDTokenManager
(
)
:
mTransactionId
(
0
)
{
StaticMutexAutoLock
lock
(
gInstanceMutex
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
gInstance
)
;
mU2FManager
=
rust_u2f_mgr_new
(
)
;
gPBackgroundThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
gPBackgroundThread
"
This
should
never
be
null
!
"
)
;
gInstance
=
this
;
}
U2FHIDTokenManager
:
:
~
U2FHIDTokenManager
(
)
{
{
StaticMutexAutoLock
lock
(
gInstanceMutex
)
;
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
gPBackgroundThread
)
;
mRegisterPromise
.
RejectIfExists
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
mSignPromise
.
RejectIfExists
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
gInstance
=
nullptr
;
}
rust_u2f_mgr_free
(
mU2FManager
)
;
mU2FManager
=
nullptr
;
}
RefPtr
<
U2FRegisterPromise
>
U2FHIDTokenManager
:
:
Register
(
const
nsTArray
<
WebAuthnScopedCredential
>
&
aCredentials
const
WebAuthnAuthenticatorSelection
&
aAuthenticatorSelection
const
nsTArray
<
uint8_t
>
&
aApplication
const
nsTArray
<
uint8_t
>
&
aChallenge
uint32_t
aTimeoutMS
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
gPBackgroundThread
)
;
uint64_t
registerFlags
=
0
;
if
(
aAuthenticatorSelection
.
requireResidentKey
(
)
)
{
registerFlags
|
=
U2F_FLAG_REQUIRE_RESIDENT_KEY
;
}
if
(
aAuthenticatorSelection
.
requireUserVerification
(
)
)
{
registerFlags
|
=
U2F_FLAG_REQUIRE_USER_VERIFICATION
;
}
if
(
aAuthenticatorSelection
.
requirePlatformAttachment
(
)
)
{
registerFlags
|
=
U2F_FLAG_REQUIRE_PLATFORM_ATTACHMENT
;
}
ClearPromises
(
)
;
mTransactionId
=
rust_u2f_mgr_register
(
mU2FManager
registerFlags
(
uint64_t
)
aTimeoutMS
u2f_register_callback
aChallenge
.
Elements
(
)
aChallenge
.
Length
(
)
aApplication
.
Elements
(
)
aApplication
.
Length
(
)
U2FKeyHandles
(
aCredentials
)
.
Get
(
)
)
;
if
(
mTransactionId
=
=
0
)
{
return
U2FRegisterPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
}
return
mRegisterPromise
.
Ensure
(
__func__
)
;
}
RefPtr
<
U2FSignPromise
>
U2FHIDTokenManager
:
:
Sign
(
const
nsTArray
<
WebAuthnScopedCredential
>
&
aCredentials
const
nsTArray
<
uint8_t
>
&
aApplication
const
nsTArray
<
uint8_t
>
&
aChallenge
bool
aRequireUserVerification
uint32_t
aTimeoutMS
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
gPBackgroundThread
)
;
uint64_t
signFlags
=
0
;
if
(
aRequireUserVerification
)
{
signFlags
|
=
U2F_FLAG_REQUIRE_USER_VERIFICATION
;
}
ClearPromises
(
)
;
mTransactionId
=
rust_u2f_mgr_sign
(
mU2FManager
signFlags
(
uint64_t
)
aTimeoutMS
u2f_sign_callback
aChallenge
.
Elements
(
)
aChallenge
.
Length
(
)
aApplication
.
Elements
(
)
aApplication
.
Length
(
)
U2FKeyHandles
(
aCredentials
)
.
Get
(
)
)
;
if
(
mTransactionId
=
=
0
)
{
return
U2FSignPromise
:
:
CreateAndReject
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
}
return
mSignPromise
.
Ensure
(
__func__
)
;
}
void
U2FHIDTokenManager
:
:
Cancel
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
gPBackgroundThread
)
;
ClearPromises
(
)
;
mTransactionId
=
rust_u2f_mgr_cancel
(
mU2FManager
)
;
}
void
U2FHIDTokenManager
:
:
HandleRegisterResult
(
UniquePtr
<
U2FResult
>
&
&
aResult
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
gPBackgroundThread
)
;
if
(
aResult
-
>
GetTransactionId
(
)
!
=
mTransactionId
)
{
return
;
}
MOZ_ASSERT
(
!
mRegisterPromise
.
IsEmpty
(
)
)
;
nsTArray
<
uint8_t
>
registration
;
if
(
!
aResult
-
>
CopyRegistration
(
registration
)
)
{
mRegisterPromise
.
Reject
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
return
;
}
WebAuthnMakeCredentialResult
result
(
registration
)
;
mRegisterPromise
.
Resolve
(
Move
(
result
)
__func__
)
;
}
void
U2FHIDTokenManager
:
:
HandleSignResult
(
UniquePtr
<
U2FResult
>
&
&
aResult
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
gPBackgroundThread
)
;
if
(
aResult
-
>
GetTransactionId
(
)
!
=
mTransactionId
)
{
return
;
}
MOZ_ASSERT
(
!
mSignPromise
.
IsEmpty
(
)
)
;
nsTArray
<
uint8_t
>
keyHandle
;
if
(
!
aResult
-
>
CopyKeyHandle
(
keyHandle
)
)
{
mSignPromise
.
Reject
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
return
;
}
nsTArray
<
uint8_t
>
signature
;
if
(
!
aResult
-
>
CopySignature
(
signature
)
)
{
mSignPromise
.
Reject
(
NS_ERROR_DOM_UNKNOWN_ERR
__func__
)
;
return
;
}
WebAuthnGetAssertionResult
result
(
keyHandle
signature
)
;
mSignPromise
.
Resolve
(
Move
(
result
)
__func__
)
;
}
}
}
