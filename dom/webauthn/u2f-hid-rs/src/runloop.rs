use
std
:
:
io
;
use
std
:
:
sync
:
:
{
Arc
Mutex
Weak
}
;
use
std
:
:
sync
:
:
atomic
:
:
{
AtomicBool
Ordering
}
;
use
std
:
:
thread
;
use
std
:
:
thread
:
:
JoinHandle
;
use
std
:
:
time
:
:
{
Duration
Instant
}
;
struct
Canary
{
alive
:
AtomicBool
thread
:
Mutex
<
Option
<
JoinHandle
<
(
)
>
>
>
}
impl
Canary
{
fn
new
(
)
-
>
Self
{
Self
{
alive
:
AtomicBool
:
:
new
(
true
)
thread
:
Mutex
:
:
new
(
None
)
}
}
}
pub
struct
RunLoop
{
flag
:
Weak
<
Canary
>
}
impl
RunLoop
{
pub
fn
new
<
F
T
>
(
fun
:
F
timeout_ms
:
u64
)
-
>
io
:
:
Result
<
Self
>
where
F
:
FnOnce
(
&
Fn
(
)
-
>
bool
)
-
>
T
F
:
Send
+
'
static
{
let
flag
=
Arc
:
:
new
(
Canary
:
:
new
(
)
)
;
let
flag_
=
flag
.
clone
(
)
;
let
thread
=
thread
:
:
Builder
:
:
new
(
)
.
spawn
(
move
|
|
{
let
timeout
=
Duration
:
:
from_millis
(
timeout_ms
)
;
let
start
=
Instant
:
:
now
(
)
;
let
still_alive
=
|
|
{
flag
.
alive
.
load
(
Ordering
:
:
Relaxed
)
&
&
(
timeout_ms
=
=
0
|
|
start
.
elapsed
(
)
<
timeout
)
}
;
let
_
=
fun
(
&
still_alive
)
;
}
)
?
;
let
mut
guard
=
(
*
flag_
)
.
thread
.
lock
(
)
.
map_err
(
|
_
|
{
io
:
:
Error
:
:
new
(
io
:
:
ErrorKind
:
:
Other
"
failed
to
lock
"
)
}
)
?
;
*
guard
=
Some
(
thread
)
;
Ok
(
Self
{
flag
:
Arc
:
:
downgrade
(
&
flag_
)
}
)
}
pub
fn
cancel
(
&
self
)
{
if
let
Some
(
flag
)
=
self
.
flag
.
upgrade
(
)
{
flag
.
alive
.
store
(
false
Ordering
:
:
Relaxed
)
;
if
let
Ok
(
mut
guard
)
=
flag
.
thread
.
lock
(
)
{
if
let
Some
(
handle
)
=
(
*
guard
)
.
take
(
)
{
let
_
=
handle
.
join
(
)
;
}
}
}
}
pub
fn
alive
(
&
self
)
-
>
bool
{
if
let
Some
(
flag
)
=
self
.
flag
.
upgrade
(
)
{
flag
.
alive
.
load
(
Ordering
:
:
Relaxed
)
}
else
{
false
}
}
}
#
[
cfg
(
test
)
]
mod
tests
{
use
std
:
:
sync
:
:
{
Arc
Barrier
}
;
use
super
:
:
RunLoop
;
#
[
test
]
fn
test_empty
(
)
{
let
thread
=
RunLoop
:
:
new
(
move
|
_
|
{
}
0
)
.
unwrap
(
)
;
while
thread
.
alive
(
)
{
}
thread
.
cancel
(
)
;
}
#
[
test
]
fn
test_cancel_early
(
)
{
RunLoop
:
:
new
(
|
alive
|
assert
!
(
!
alive
(
)
)
0
)
.
unwrap
(
)
.
cancel
(
)
;
}
#
[
test
]
fn
test_cancel_endless_loop
(
)
{
let
barrier
=
Arc
:
:
new
(
Barrier
:
:
new
(
2
)
)
;
let
b
=
barrier
.
clone
(
)
;
let
thread
=
RunLoop
:
:
new
(
move
|
alive
|
{
b
.
wait
(
)
;
while
alive
(
)
{
}
}
0
)
.
unwrap
(
)
;
barrier
.
wait
(
)
;
assert
!
(
thread
.
alive
(
)
)
;
thread
.
cancel
(
)
;
assert
!
(
!
thread
.
alive
(
)
)
;
}
#
[
test
]
fn
test_timeout
(
)
{
let
thread
=
RunLoop
:
:
new
(
|
alive
|
while
alive
(
)
{
}
1
)
.
unwrap
(
)
;
while
thread
.
alive
(
)
{
}
assert
!
(
!
thread
.
alive
(
)
)
;
thread
.
cancel
(
)
;
}
}
