extern
crate
libc
;
use
std
:
:
io
;
use
std
:
:
mem
;
use
std
:
:
os
:
:
unix
:
:
io
:
:
RawFd
;
use
consts
:
:
{
FIDO_USAGE_U2FHID
FIDO_USAGE_PAGE
}
;
use
util
:
:
{
from_unix_result
io_err
}
;
#
[
allow
(
non_camel_case_types
)
]
#
[
repr
(
C
)
]
pub
struct
ReportDescriptor
{
size
:
:
:
libc
:
:
c_int
value
:
[
u8
;
4096
]
}
impl
ReportDescriptor
{
fn
iter
(
self
)
-
>
ReportDescriptorIterator
{
ReportDescriptorIterator
:
:
new
(
self
)
}
}
const
NRBITS
:
u32
=
8
;
const
TYPEBITS
:
u32
=
8
;
const
READ
:
u8
=
2
;
const
SIZEBITS
:
u8
=
14
;
const
NRSHIFT
:
u32
=
0
;
const
TYPESHIFT
:
u32
=
NRSHIFT
+
NRBITS
as
u32
;
const
SIZESHIFT
:
u32
=
TYPESHIFT
+
TYPEBITS
as
u32
;
const
DIRSHIFT
:
u32
=
SIZESHIFT
+
SIZEBITS
as
u32
;
const
HID_MASK_LONG_ITEM_TAG
:
u8
=
0b11110000
;
const
HID_MASK_SHORT_ITEM_SIZE
:
u8
=
0b00000011
;
const
HID_MASK_ITEM_TAGTYPE
:
u8
=
0b11111100
;
const
HID_ITEM_TAGTYPE_USAGE
:
u8
=
0b00001000
;
const
HID_ITEM_TAGTYPE_USAGE_PAGE
:
u8
=
0b00000100
;
const
HID_MAX_DESCRIPTOR_SIZE
:
usize
=
4096
;
macro_rules
!
ioctl
{
(
dir
:
expr
name
:
ident
ioty
:
expr
nr
:
expr
;
ty
:
ty
)
=
>
{
pub
unsafe
fn
name
(
fd
:
libc
:
:
c_int
val
:
*
mut
ty
)
-
>
io
:
:
Result
<
libc
:
:
c_int
>
{
let
size
=
mem
:
:
size_of
:
:
<
ty
>
(
)
;
let
ioc
=
(
(
dir
as
u32
)
<
<
DIRSHIFT
)
|
(
(
ioty
as
u32
)
<
<
TYPESHIFT
)
|
(
(
nr
as
u32
)
<
<
NRSHIFT
)
|
(
(
size
as
u32
)
<
<
SIZESHIFT
)
;
#
[
cfg
(
not
(
target_env
=
"
musl
"
)
)
]
type
IocType
=
libc
:
:
c_ulong
;
#
[
cfg
(
target_env
=
"
musl
"
)
]
type
IocType
=
libc
:
:
c_int
;
from_unix_result
(
libc
:
:
ioctl
(
fd
ioc
as
IocType
val
)
)
}
}
;
}
ioctl
!
(
READ
hidiocgrdescsize
b
'
H
'
0x01
;
:
:
libc
:
:
c_int
)
;
ioctl
!
(
READ
hidiocgrdesc
b
'
H
'
0x02
;
/
*
struct
*
/
ReportDescriptor
)
;
enum
Data
{
UsagePage
{
data
:
u32
}
Usage
{
data
:
u32
}
}
struct
ReportDescriptorIterator
{
desc
:
ReportDescriptor
pos
:
usize
}
impl
ReportDescriptorIterator
{
fn
new
(
desc
:
ReportDescriptor
)
-
>
Self
{
Self
{
desc
pos
:
0
}
}
fn
next_item
(
&
mut
self
)
-
>
Option
<
Data
>
{
let
item
=
get_hid_item
(
&
self
.
desc
.
value
[
self
.
pos
.
.
]
)
;
if
item
.
is_none
(
)
{
self
.
pos
=
self
.
desc
.
size
as
usize
;
return
None
;
}
let
(
tag_type
key_len
data
)
=
item
.
unwrap
(
)
;
self
.
pos
+
=
key_len
+
data
.
len
(
)
;
if
key_len
>
1
{
return
None
;
}
assert
!
(
data
.
len
(
)
<
=
mem
:
:
size_of
:
:
<
u32
>
(
)
)
;
let
data
=
read_uint_le
(
data
)
;
match
tag_type
{
HID_ITEM_TAGTYPE_USAGE_PAGE
=
>
Some
(
Data
:
:
UsagePage
{
data
}
)
HID_ITEM_TAGTYPE_USAGE
=
>
Some
(
Data
:
:
Usage
{
data
}
)
_
=
>
None
}
}
}
impl
Iterator
for
ReportDescriptorIterator
{
type
Item
=
Data
;
fn
next
(
&
mut
self
)
-
>
Option
<
Self
:
:
Item
>
{
if
self
.
pos
>
=
self
.
desc
.
size
as
usize
{
return
None
;
}
self
.
next_item
(
)
.
or_else
(
|
|
self
.
next
(
)
)
}
}
fn
get_hid_item
<
'
a
>
(
buf
:
&
'
a
[
u8
]
)
-
>
Option
<
(
u8
usize
&
'
a
[
u8
]
)
>
{
if
(
buf
[
0
]
&
HID_MASK_LONG_ITEM_TAG
)
=
=
HID_MASK_LONG_ITEM_TAG
{
get_hid_long_item
(
buf
)
}
else
{
get_hid_short_item
(
buf
)
}
}
fn
get_hid_long_item
<
'
a
>
(
buf
:
&
'
a
[
u8
]
)
-
>
Option
<
(
u8
usize
&
'
a
[
u8
]
)
>
{
if
buf
.
len
(
)
<
3
{
return
None
;
}
let
len
=
buf
[
1
]
as
usize
;
if
len
>
buf
.
len
(
)
-
3
{
return
None
;
}
Some
(
(
buf
[
2
]
3
&
buf
[
3
.
.
]
)
)
}
fn
get_hid_short_item
<
'
a
>
(
buf
:
&
'
a
[
u8
]
)
-
>
Option
<
(
u8
usize
&
'
a
[
u8
]
)
>
{
let
len
=
match
buf
[
0
]
&
HID_MASK_SHORT_ITEM_SIZE
{
s
0
.
.
.
2
=
>
s
as
usize
_
=
>
4
}
;
if
len
>
buf
.
len
(
)
-
1
{
return
None
;
}
Some
(
(
buf
[
0
]
&
HID_MASK_ITEM_TAGTYPE
1
&
buf
[
1
.
.
1
+
len
]
)
)
}
fn
read_uint_le
(
buf
:
&
[
u8
]
)
-
>
u32
{
assert
!
(
buf
.
len
(
)
<
=
4
)
;
buf
.
iter
(
)
.
rev
(
)
.
fold
(
0
|
num
b
|
(
num
<
<
8
)
|
(
*
b
as
u32
)
)
}
pub
fn
is_u2f_device
(
fd
:
RawFd
)
-
>
bool
{
match
read_report_descriptor
(
fd
)
{
Ok
(
desc
)
=
>
has_fido_usage
(
desc
)
Err
(
_
)
=
>
false
}
}
fn
read_report_descriptor
(
fd
:
RawFd
)
-
>
io
:
:
Result
<
ReportDescriptor
>
{
let
mut
desc
=
ReportDescriptor
{
size
:
0
value
:
[
0
;
HID_MAX_DESCRIPTOR_SIZE
]
}
;
let
_
=
unsafe
{
hidiocgrdescsize
(
fd
&
mut
desc
.
size
)
?
}
;
if
desc
.
size
=
=
0
|
|
desc
.
size
as
usize
>
desc
.
value
.
len
(
)
{
return
Err
(
io_err
(
"
unexpected
hidiocgrdescsize
(
)
result
"
)
)
;
}
let
_
=
unsafe
{
hidiocgrdesc
(
fd
&
mut
desc
)
?
}
;
Ok
(
desc
)
}
fn
has_fido_usage
(
desc
:
ReportDescriptor
)
-
>
bool
{
let
mut
usage_page
=
None
;
let
mut
usage
=
None
;
for
data
in
desc
.
iter
(
)
{
match
data
{
Data
:
:
UsagePage
{
data
}
=
>
usage_page
=
Some
(
data
)
Data
:
:
Usage
{
data
}
=
>
usage
=
Some
(
data
)
}
if
let
(
Some
(
usage_page
)
Some
(
usage
)
)
=
(
usage_page
usage
)
{
return
usage_page
=
=
FIDO_USAGE_PAGE
as
u32
&
&
usage
=
=
FIDO_USAGE_U2FHID
as
u32
;
}
}
false
}
