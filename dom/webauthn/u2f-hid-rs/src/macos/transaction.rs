extern
crate
libc
;
use
core_foundation_sys
:
:
runloop
:
:
*
;
use
libc
:
:
c_void
;
use
platform
:
:
iohid
:
:
CFRunLoopEntryObserver
;
use
platform
:
:
iokit
:
:
{
IOHIDDeviceRef
SendableRunLoop
}
;
use
platform
:
:
monitor
:
:
Monitor
;
use
std
:
:
io
;
use
std
:
:
sync
:
:
mpsc
:
:
{
channel
Receiver
Sender
}
;
use
std
:
:
thread
;
use
util
:
:
{
io_err
to_io_err
OnceCallback
}
;
pub
struct
Transaction
{
runloop
:
SendableRunLoop
thread
:
Option
<
thread
:
:
JoinHandle
<
(
)
>
>
}
impl
Transaction
{
pub
fn
new
<
F
T
>
(
timeout
:
u64
callback
:
OnceCallback
<
T
>
new_device_cb
:
F
)
-
>
io
:
:
Result
<
Self
>
where
F
:
Fn
(
IOHIDDeviceRef
Receiver
<
Vec
<
u8
>
>
&
Fn
(
)
-
>
bool
)
+
Sync
+
Send
+
'
static
T
:
'
static
{
let
(
tx
rx
)
=
channel
(
)
;
let
cbc
=
callback
.
clone
(
)
;
let
timeout
=
(
timeout
as
f64
)
/
1000
.
0
;
let
builder
=
thread
:
:
Builder
:
:
new
(
)
;
let
thread
=
builder
.
spawn
(
move
|
|
{
let
context
=
&
tx
as
*
const
_
as
*
mut
c_void
;
let
obs
=
CFRunLoopEntryObserver
:
:
new
(
Transaction
:
:
observe
context
)
;
obs
.
add_to_current_runloop
(
)
;
let
mut
monitor
=
Monitor
:
:
new
(
new_device_cb
)
;
try_or
!
(
monitor
.
start
(
)
|
e
|
cbc
.
call
(
Err
(
e
)
)
)
;
unsafe
{
CFRunLoopRunInMode
(
kCFRunLoopDefaultMode
timeout
0
)
}
;
monitor
.
stop
(
)
;
cbc
.
call
(
Err
(
io_err
(
"
aborted
or
timed
out
"
)
)
)
;
}
)
?
;
let
runloop
=
rx
.
recv
(
)
.
map_err
(
to_io_err
)
?
;
Ok
(
Self
{
runloop
thread
:
Some
(
thread
)
}
)
}
extern
"
C
"
fn
observe
(
_
:
CFRunLoopObserverRef
_
:
CFRunLoopActivity
context
:
*
mut
c_void
)
{
let
tx
:
&
Sender
<
SendableRunLoop
>
=
unsafe
{
&
*
(
context
as
*
mut
_
)
}
;
let
_
=
tx
.
send
(
SendableRunLoop
(
unsafe
{
CFRunLoopGetCurrent
(
)
}
)
)
;
}
pub
fn
cancel
(
&
mut
self
)
{
unsafe
{
CFRunLoopStop
(
*
self
.
runloop
)
}
;
let
_
=
self
.
thread
.
take
(
)
.
unwrap
(
)
.
join
(
)
;
}
}
