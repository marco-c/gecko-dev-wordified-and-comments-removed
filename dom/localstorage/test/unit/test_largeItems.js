add_task
(
async
function
testSteps
(
)
{
const
globalLimitKB
=
5
*
1024
;
const
numberOfIterations
=
18
;
const
randomStringBlockSize
=
65536
;
function
getRandomString
(
size
)
{
let
crypto
=
this
.
window
?
this
.
window
.
crypto
:
this
.
crypto
;
let
decoder
=
new
TextDecoder
(
"
ISO
-
8859
-
2
"
)
;
function
getRandomStringBlock
(
array
)
{
crypto
.
getRandomValues
(
array
)
;
return
decoder
.
decode
(
array
)
;
}
let
string
=
"
"
;
let
quotient
=
size
/
randomStringBlockSize
;
if
(
quotient
)
{
let
array
=
new
Uint8Array
(
randomStringBlockSize
)
;
for
(
let
i
=
1
;
i
<
=
quotient
;
i
+
+
)
{
string
+
=
getRandomStringBlock
(
array
)
;
}
}
let
remainder
=
size
%
randomStringBlockSize
;
if
(
remainder
)
{
let
array
=
new
Uint8Array
(
remainder
)
;
string
+
=
getRandomStringBlock
(
array
)
;
}
return
string
;
}
const
data
=
{
}
;
data
.
key
=
"
foo
"
;
data
.
value
=
getRandomString
(
globalLimitKB
*
1024
-
data
.
key
.
length
-
numberOfIterations
.
toString
(
)
.
length
)
;
info
(
"
Setting
pref
"
)
;
if
(
this
.
window
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
storage
.
snapshot_reusing
"
false
]
]
}
)
;
}
else
{
Services
.
prefs
.
setBoolPref
(
"
dom
.
storage
.
snapshot_reusing
"
false
)
;
}
info
(
"
Getting
storage
"
)
;
let
storage
=
getLocalStorage
(
)
;
info
(
"
Adding
/
updating
item
"
)
;
for
(
var
i
=
0
;
i
<
numberOfIterations
;
i
+
+
)
{
storage
.
setItem
(
data
.
key
data
.
value
+
i
)
;
}
info
(
"
Returning
to
event
loop
"
)
;
await
returnToEventLoop
(
)
;
ok
(
!
storage
.
hasSnapshot
"
Snapshot
successfully
finished
"
)
;
}
)
;
