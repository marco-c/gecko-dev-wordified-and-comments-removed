#
ifndef
mozilla_dom_localstorage_LSValue_h
#
define
mozilla_dom_localstorage_LSValue_h
#
include
"
SnappyUtils
.
h
"
#
include
"
nsString
.
h
"
class
mozIStorageStatement
;
namespace
IPC
{
template
<
typename
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
dom
{
class
LSValue
final
{
friend
struct
IPC
:
:
ParamTraits
<
LSValue
>
;
nsCString
mBuffer
;
uint32_t
mUTF16Length
;
bool
mCompressed
;
public
:
LSValue
(
)
:
mUTF16Length
(
0
)
mCompressed
(
false
)
{
SetIsVoid
(
true
)
;
}
bool
InitFromString
(
const
nsAString
&
aBuffer
)
;
nsresult
InitFromStatement
(
mozIStorageStatement
*
aStatement
uint32_t
aIndex
)
;
bool
IsVoid
(
)
const
{
return
mBuffer
.
IsVoid
(
)
;
}
void
SetIsVoid
(
bool
aVal
)
{
mBuffer
.
SetIsVoid
(
aVal
)
;
}
uint32_t
Length
(
)
const
{
return
mBuffer
.
Length
(
)
;
}
uint32_t
UTF16Length
(
)
const
{
return
mUTF16Length
;
}
bool
IsCompressed
(
)
const
{
return
mCompressed
;
}
bool
Equals
(
const
LSValue
&
aOther
)
const
{
return
mBuffer
=
=
aOther
.
mBuffer
&
&
mBuffer
.
IsVoid
(
)
=
=
aOther
.
mBuffer
.
IsVoid
(
)
&
&
mUTF16Length
=
=
aOther
.
mUTF16Length
&
&
mCompressed
=
=
aOther
.
mCompressed
;
}
bool
operator
=
=
(
const
LSValue
&
aOther
)
const
{
return
Equals
(
aOther
)
;
}
bool
operator
!
=
(
const
LSValue
&
aOther
)
const
{
return
!
Equals
(
aOther
)
;
}
operator
const
nsCString
&
(
)
const
{
return
mBuffer
;
}
operator
Span
<
const
char
>
(
)
const
{
return
mBuffer
;
}
class
Converter
{
nsString
mBuffer
;
public
:
explicit
Converter
(
const
LSValue
&
aValue
)
{
if
(
aValue
.
mBuffer
.
IsVoid
(
)
)
{
mBuffer
.
SetIsVoid
(
true
)
;
}
else
if
(
aValue
.
mCompressed
)
{
nsCString
buffer
;
MOZ_ALWAYS_TRUE
(
SnappyUncompress
(
aValue
.
mBuffer
buffer
)
)
;
CopyUTF8toUTF16
(
buffer
mBuffer
)
;
}
else
{
CopyUTF8toUTF16
(
aValue
.
mBuffer
mBuffer
)
;
}
}
Converter
(
Converter
&
&
aOther
)
=
default
;
~
Converter
(
)
=
default
;
operator
const
nsString
&
(
)
const
{
return
mBuffer
;
}
private
:
Converter
(
)
=
delete
;
Converter
(
const
Converter
&
)
=
delete
;
Converter
&
operator
=
(
const
Converter
&
)
=
delete
;
Converter
&
operator
=
(
const
Converter
&
&
)
=
delete
;
}
;
Converter
AsString
(
)
const
{
return
Converter
{
*
this
}
;
}
}
;
const
LSValue
&
VoidLSValue
(
)
;
}
}
#
endif
