#
ifndef
mozilla_dom_localstorage_LSValue_h
#
define
mozilla_dom_localstorage_LSValue_h
#
include
<
cstdint
>
#
include
"
ErrorList
.
h
"
#
include
"
SnappyUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTStringRepr
.
h
"
class
mozIStorageStatement
;
namespace
IPC
{
template
<
typename
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
dom
{
class
LSValue
final
{
friend
struct
IPC
:
:
ParamTraits
<
LSValue
>
;
public
:
enum
class
ConversionType
:
uint8_t
{
NONE
=
0u
UTF16_UTF8
=
1u
NUM_TYPES
=
2u
}
;
enum
class
CompressionType
:
uint8_t
{
UNCOMPRESSED
=
0u
SNAPPY
=
1u
NUM_TYPES
=
2u
}
;
nsCString
mBuffer
;
uint32_t
mUTF16Length
;
ConversionType
mConversionType
;
CompressionType
mCompressionType
;
explicit
LSValue
(
)
:
mUTF16Length
(
0u
)
mConversionType
(
ConversionType
:
:
NONE
)
mCompressionType
(
CompressionType
:
:
UNCOMPRESSED
)
{
SetIsVoid
(
true
)
;
}
bool
InitFromString
(
const
nsAString
&
aBuffer
)
;
nsresult
InitFromStatement
(
mozIStorageStatement
*
aStatement
uint32_t
aIndex
)
;
bool
IsVoid
(
)
const
{
return
mBuffer
.
IsVoid
(
)
;
}
void
SetIsVoid
(
bool
aVal
)
{
mBuffer
.
SetIsVoid
(
aVal
)
;
}
uint32_t
Length
(
)
const
{
return
mBuffer
.
Length
(
)
;
}
uint32_t
UTF16Length
(
)
const
{
return
mUTF16Length
;
}
ConversionType
GetConversionType
(
)
const
{
return
mConversionType
;
}
CompressionType
GetCompressionType
(
)
const
{
return
mCompressionType
;
}
bool
Equals
(
const
LSValue
&
aOther
)
const
{
return
mBuffer
=
=
aOther
.
mBuffer
&
&
mBuffer
.
IsVoid
(
)
=
=
aOther
.
mBuffer
.
IsVoid
(
)
&
&
mUTF16Length
=
=
aOther
.
mUTF16Length
&
&
mConversionType
=
=
aOther
.
mConversionType
&
&
mCompressionType
=
=
aOther
.
mCompressionType
;
}
bool
operator
=
=
(
const
LSValue
&
aOther
)
const
{
return
Equals
(
aOther
)
;
}
bool
operator
!
=
(
const
LSValue
&
aOther
)
const
{
return
!
Equals
(
aOther
)
;
}
constexpr
const
nsCString
&
AsCString
(
)
const
{
return
mBuffer
;
}
class
Converter
{
nsString
mBuffer
;
public
:
explicit
Converter
(
const
LSValue
&
aValue
)
;
Converter
(
Converter
&
&
aOther
)
=
default
;
~
Converter
(
)
=
default
;
operator
const
nsString
&
(
)
const
{
return
mBuffer
;
}
private
:
Converter
(
)
=
delete
;
Converter
(
const
Converter
&
)
=
delete
;
Converter
&
operator
=
(
const
Converter
&
)
=
delete
;
Converter
&
operator
=
(
const
Converter
&
&
)
=
delete
;
}
;
Converter
AsString
(
)
const
{
return
Converter
{
*
this
}
;
}
}
;
const
LSValue
&
VoidLSValue
(
)
;
bool
PutCStringBytesToString
(
const
nsACString
&
aSrc
nsString
&
aDest
)
;
}
}
#
endif
