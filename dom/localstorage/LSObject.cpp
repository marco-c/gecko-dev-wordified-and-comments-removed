#
include
"
LSObject
.
h
"
#
include
"
ActorsChild
.
h
"
#
include
"
IPCBlobInputStreamThread
.
h
"
#
include
"
LocalStorageCommon
.
h
"
#
include
"
mozilla
/
ThreadEventQueue
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsThread
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
RequestHelper
;
StaticMutex
gRequestHelperMutex
;
RequestHelper
*
gRequestHelper
=
nullptr
;
class
RequestHelper
final
:
public
Runnable
public
LSRequestChildCallback
{
enum
class
State
{
Initial
ResponsePending
Finishing
Complete
}
;
RefPtr
<
LSObject
>
mObject
;
nsCOMPtr
<
nsIEventTarget
>
mOwningEventTarget
;
nsCOMPtr
<
nsIEventTarget
>
mNestedEventTarget
;
LSRequestChild
*
mActor
;
const
LSRequestParams
mParams
;
LSRequestResponse
mResponse
;
nsresult
mResultCode
;
State
mState
;
bool
mWaiting
;
public
:
RequestHelper
(
LSObject
*
aObject
const
LSRequestParams
&
aParams
)
:
Runnable
(
"
dom
:
:
RequestHelper
"
)
mObject
(
aObject
)
mOwningEventTarget
(
GetCurrentThreadEventTarget
(
)
)
mActor
(
nullptr
)
mParams
(
aParams
)
mResultCode
(
NS_OK
)
mState
(
State
:
:
Initial
)
mWaiting
(
true
)
{
StaticMutexAutoLock
lock
(
gRequestHelperMutex
)
;
gRequestHelper
=
this
;
}
bool
IsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
mOwningEventTarget
)
;
bool
current
;
return
NS_SUCCEEDED
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
;
}
void
AssertIsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsOnOwningThread
(
)
)
;
}
const
nsCOMPtr
<
nsIEventTarget
>
&
GetSyncLoopEventTarget
(
)
const
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
mNestedEventTarget
;
}
nsresult
StartAndReturnResponse
(
LSRequestResponse
&
aResponse
)
;
nsresult
CancelOnAnyThread
(
)
;
private
:
~
RequestHelper
(
)
{
StaticMutexAutoLock
lock
(
gRequestHelperMutex
)
;
gRequestHelper
=
nullptr
;
}
nsresult
Start
(
)
;
void
Finish
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
void
OnResponse
(
const
LSRequestResponse
&
aResponse
)
override
;
}
;
}
LSObject
:
:
LSObject
(
nsPIDOMWindowInner
*
aWindow
nsIPrincipal
*
aPrincipal
)
:
Storage
(
aWindow
aPrincipal
)
mPrivateBrowsingId
(
0
)
mInExplicitSnapshot
(
false
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
NextGenLocalStorageEnabled
(
)
)
;
}
LSObject
:
:
~
LSObject
(
)
{
AssertIsOnOwningThread
(
)
;
DropObserver
(
)
;
}
nsresult
LSObject
:
:
CreateForWindow
(
nsPIDOMWindowInner
*
aWindow
Storage
*
*
aStorage
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aStorage
)
;
MOZ_ASSERT
(
NextGenLocalStorageEnabled
(
)
)
;
MOZ_ASSERT
(
nsContentUtils
:
:
StorageAllowedForWindow
(
aWindow
)
>
nsContentUtils
:
:
StorageAccess
:
:
eDeny
)
;
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
aWindow
)
;
MOZ_ASSERT
(
sop
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
sop
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCString
dummyOriginAttrSuffix
;
nsCString
dummyOriginKey
;
nsresult
rv
=
GenerateOriginKey
(
principal
dummyOriginAttrSuffix
dummyOriginKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoPtr
<
PrincipalInfo
>
principalInfo
(
new
PrincipalInfo
(
)
)
;
rv
=
PrincipalToPrincipalInfo
(
principal
principalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
principalInfo
-
>
type
(
)
=
=
PrincipalInfo
:
:
TContentPrincipalInfo
)
;
nsCString
origin
;
rv
=
QuotaManager
:
:
GetInfoFromPrincipal
(
principal
nullptr
nullptr
&
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint32_t
privateBrowsingId
;
rv
=
principal
-
>
GetPrivateBrowsingId
(
&
privateBrowsingId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsString
documentURI
;
if
(
nsCOMPtr
<
nsIDocument
>
doc
=
aWindow
-
>
GetExtantDoc
(
)
)
{
rv
=
doc
-
>
GetDocumentURI
(
documentURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
RefPtr
<
LSObject
>
object
=
new
LSObject
(
aWindow
principal
)
;
object
-
>
mPrincipalInfo
=
std
:
:
move
(
principalInfo
)
;
object
-
>
mPrivateBrowsingId
=
privateBrowsingId
;
object
-
>
mOrigin
=
origin
;
object
-
>
mDocumentURI
=
documentURI
;
object
.
forget
(
aStorage
)
;
return
NS_OK
;
}
nsresult
LSObject
:
:
CreateForPrincipal
(
nsPIDOMWindowInner
*
aWindow
nsIPrincipal
*
aPrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
LSObject
*
*
aObject
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aObject
)
;
nsCString
dummyOriginAttrSuffix
;
nsCString
dummyOriginKey
;
nsresult
rv
=
GenerateOriginKey
(
aPrincipal
dummyOriginAttrSuffix
dummyOriginKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoPtr
<
PrincipalInfo
>
principalInfo
(
new
PrincipalInfo
(
)
)
;
rv
=
PrincipalToPrincipalInfo
(
aPrincipal
principalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
principalInfo
-
>
type
(
)
=
=
PrincipalInfo
:
:
TContentPrincipalInfo
|
|
principalInfo
-
>
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
;
nsCString
origin
;
if
(
principalInfo
-
>
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
{
QuotaManager
:
:
GetInfoForChrome
(
nullptr
nullptr
&
origin
)
;
}
else
{
rv
=
QuotaManager
:
:
GetInfoFromPrincipal
(
aPrincipal
nullptr
nullptr
&
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
RefPtr
<
LSObject
>
object
=
new
LSObject
(
aWindow
aPrincipal
)
;
object
-
>
mPrincipalInfo
=
std
:
:
move
(
principalInfo
)
;
object
-
>
mPrivateBrowsingId
=
aPrivate
?
1
:
0
;
object
-
>
mOrigin
=
origin
;
object
-
>
mDocumentURI
=
aDocumentURI
;
object
.
forget
(
aObject
)
;
return
NS_OK
;
}
already_AddRefed
<
nsIEventTarget
>
LSObject
:
:
GetSyncLoopEventTarget
(
)
{
RefPtr
<
RequestHelper
>
helper
;
{
StaticMutexAutoLock
lock
(
gRequestHelperMutex
)
;
helper
=
gRequestHelper
;
}
nsCOMPtr
<
nsIEventTarget
>
target
;
if
(
helper
)
{
target
=
helper
-
>
GetSyncLoopEventTarget
(
)
;
}
return
target
.
forget
(
)
;
}
void
LSObject
:
:
CancelSyncLoop
(
)
{
RefPtr
<
RequestHelper
>
helper
;
{
StaticMutexAutoLock
lock
(
gRequestHelperMutex
)
;
helper
=
gRequestHelper
;
}
if
(
helper
)
{
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
helper
-
>
CancelOnAnyThread
(
)
)
)
;
}
}
LSRequestChild
*
LSObject
:
:
StartRequest
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
LSRequestChildCallback
*
aCallback
)
{
AssertIsOnDOMFileThread
(
)
;
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
aMainEventTarget
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
nullptr
;
}
LSRequestChild
*
actor
=
new
LSRequestChild
(
aCallback
)
;
backgroundActor
-
>
SendPBackgroundLSRequestConstructor
(
actor
aParams
)
;
return
actor
;
}
Storage
:
:
StorageType
LSObject
:
:
Type
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
eLocalStorage
;
}
bool
LSObject
:
:
IsForkOf
(
const
Storage
*
aStorage
)
const
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aStorage
)
;
if
(
aStorage
-
>
Type
(
)
!
=
eLocalStorage
)
{
return
false
;
}
return
static_cast
<
const
LSObject
*
>
(
aStorage
)
-
>
mOrigin
=
=
mOrigin
;
}
int64_t
LSObject
:
:
GetOriginQuotaUsage
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
0
;
}
uint32_t
LSObject
:
:
GetLength
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
0
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
0
;
}
uint32_t
result
;
rv
=
mDatabase
-
>
GetLength
(
this
&
result
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
0
;
}
return
result
;
}
void
LSObject
:
:
Key
(
uint32_t
aIndex
nsAString
&
aResult
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
nsString
result
;
rv
=
mDatabase
-
>
GetKey
(
this
aIndex
result
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
aResult
=
result
;
}
void
LSObject
:
:
GetItem
(
const
nsAString
&
aKey
nsAString
&
aResult
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
nsString
result
;
rv
=
mDatabase
-
>
GetItem
(
this
aKey
result
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
aResult
=
result
;
}
void
LSObject
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
*
nsContentUtils
:
:
SubjectPrincipal
(
)
)
)
{
aNames
.
Clear
(
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
rv
=
mDatabase
-
>
GetKeys
(
this
aNames
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
void
LSObject
:
:
SetItem
(
const
nsAString
&
aKey
const
nsAString
&
aValue
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
LSNotifyInfo
info
;
rv
=
mDatabase
-
>
SetItem
(
this
aKey
aValue
info
)
;
if
(
rv
=
=
NS_ERROR_FILE_NO_DEVICE_SPACE
)
{
rv
=
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
if
(
info
.
changed
(
)
)
{
OnChange
(
aKey
info
.
oldValue
(
)
aValue
)
;
}
}
void
LSObject
:
:
RemoveItem
(
const
nsAString
&
aKey
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
LSNotifyInfo
info
;
rv
=
mDatabase
-
>
RemoveItem
(
this
aKey
info
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
if
(
info
.
changed
(
)
)
{
OnChange
(
aKey
info
.
oldValue
(
)
VoidString
(
)
)
;
}
}
void
LSObject
:
:
Clear
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
LSNotifyInfo
info
;
rv
=
mDatabase
-
>
Clear
(
this
info
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
if
(
info
.
changed
(
)
)
{
OnChange
(
VoidString
(
)
VoidString
(
)
VoidString
(
)
)
;
}
}
void
LSObject
:
:
Open
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
}
void
LSObject
:
:
Close
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
DropDatabase
(
)
;
}
void
LSObject
:
:
BeginExplicitSnapshot
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
mInExplicitSnapshot
)
{
aError
.
Throw
(
NS_ERROR_ALREADY_INITIALIZED
)
;
return
;
}
nsresult
rv
=
EnsureDatabase
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
rv
=
mDatabase
-
>
BeginExplicitSnapshot
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
mInExplicitSnapshot
=
true
;
}
void
LSObject
:
:
EndExplicitSnapshot
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CanUseStorage
(
aSubjectPrincipal
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
!
mInExplicitSnapshot
)
{
aError
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
;
}
nsresult
rv
=
EndExplicitSnapshotInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
}
NS_IMPL_ADDREF_INHERITED
(
LSObject
Storage
)
NS_IMPL_RELEASE_INHERITED
(
LSObject
Storage
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
LSObject
)
NS_INTERFACE_MAP_END_INHERITING
(
Storage
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
LSObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
LSObject
Storage
)
tmp
-
>
AssertIsOnOwningThread
(
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
LSObject
Storage
)
tmp
-
>
AssertIsOnOwningThread
(
)
;
tmp
-
>
DropDatabase
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
nsresult
LSObject
:
:
DoRequestSynchronously
(
const
LSRequestParams
&
aParams
LSRequestResponse
&
aResponse
)
{
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
RequestHelper
>
helper
=
new
RequestHelper
(
this
aParams
)
;
nsresult
rv
=
helper
-
>
StartAndReturnResponse
(
aResponse
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aResponse
.
type
(
)
=
=
LSRequestResponse
:
:
Tnsresult
)
{
nsresult
errorCode
=
aResponse
.
get_nsresult
(
)
;
if
(
errorCode
=
=
NS_ERROR_FILE_NO_DEVICE_SPACE
)
{
errorCode
=
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
;
}
return
errorCode
;
}
return
NS_OK
;
}
nsresult
LSObject
:
:
EnsureDatabase
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mDatabase
&
&
!
mDatabase
-
>
IsAllowedToClose
(
)
)
{
return
NS_OK
;
}
mDatabase
=
LSDatabase
:
:
Get
(
mOrigin
)
;
if
(
mDatabase
)
{
MOZ_ASSERT
(
!
mDatabase
-
>
IsAllowedToClose
(
)
)
;
return
NS_OK
;
}
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
NS_ERROR_FAILURE
;
}
LSRequestPrepareDatastoreParams
params
;
params
.
principalInfo
(
)
=
*
mPrincipalInfo
;
params
.
createIfNotExists
(
)
=
true
;
LSRequestResponse
response
;
nsresult
rv
=
DoRequestSynchronously
(
params
response
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
response
.
type
(
)
=
=
LSRequestResponse
:
:
TLSRequestPrepareDatastoreResponse
)
;
const
LSRequestPrepareDatastoreResponse
&
prepareDatastoreResponse
=
response
.
get_LSRequestPrepareDatastoreResponse
(
)
;
const
NullableDatastoreId
&
datastoreId
=
prepareDatastoreResponse
.
datastoreId
(
)
;
MOZ_ASSERT
(
datastoreId
.
type
(
)
=
=
NullableDatastoreId
:
:
Tuint64_t
)
;
RefPtr
<
LSDatabase
>
database
=
new
LSDatabase
(
mOrigin
)
;
LSDatabaseChild
*
actor
=
new
LSDatabaseChild
(
database
)
;
MOZ_ALWAYS_TRUE
(
backgroundActor
-
>
SendPBackgroundLSDatabaseConstructor
(
actor
*
mPrincipalInfo
mPrivateBrowsingId
datastoreId
)
)
;
database
-
>
SetActor
(
actor
)
;
mDatabase
=
std
:
:
move
(
database
)
;
return
NS_OK
;
}
void
LSObject
:
:
DropDatabase
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mInExplicitSnapshot
)
{
nsresult
rv
=
EndExplicitSnapshotInternal
(
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
mDatabase
=
nullptr
;
}
nsresult
LSObject
:
:
EnsureObserver
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mObserver
)
{
return
NS_OK
;
}
mObserver
=
LSObserver
:
:
Get
(
mOrigin
)
;
if
(
mObserver
)
{
return
NS_OK
;
}
LSRequestPrepareObserverParams
params
;
params
.
principalInfo
(
)
=
*
mPrincipalInfo
;
LSRequestResponse
response
;
nsresult
rv
=
DoRequestSynchronously
(
params
response
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
response
.
type
(
)
=
=
LSRequestResponse
:
:
TLSRequestPrepareObserverResponse
)
;
const
LSRequestPrepareObserverResponse
&
prepareObserverResponse
=
response
.
get_LSRequestPrepareObserverResponse
(
)
;
uint64_t
observerId
=
prepareObserverResponse
.
observerId
(
)
;
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetForCurrentThread
(
)
;
MOZ_ASSERT
(
backgroundActor
)
;
RefPtr
<
LSObserver
>
observer
=
new
LSObserver
(
mOrigin
)
;
LSObserverChild
*
actor
=
new
LSObserverChild
(
observer
)
;
MOZ_ALWAYS_TRUE
(
backgroundActor
-
>
SendPBackgroundLSObserverConstructor
(
actor
observerId
)
)
;
observer
-
>
SetActor
(
actor
)
;
mObserver
=
std
:
:
move
(
observer
)
;
return
NS_OK
;
}
void
LSObject
:
:
DropObserver
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mObserver
)
{
mObserver
=
nullptr
;
}
}
void
LSObject
:
:
OnChange
(
const
nsAString
&
aKey
const
nsAString
&
aOldValue
const
nsAString
&
aNewValue
)
{
AssertIsOnOwningThread
(
)
;
NotifyChange
(
this
Principal
(
)
aKey
aOldValue
aNewValue
kLocalStorageType
mDocumentURI
!
!
mPrivateBrowsingId
false
)
;
}
nsresult
LSObject
:
:
EndExplicitSnapshotInternal
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mInExplicitSnapshot
)
;
MOZ_ASSERT
(
mDatabase
)
;
MOZ_ASSERT
(
!
mDatabase
-
>
IsAllowedToClose
(
)
)
;
nsresult
rv
=
mDatabase
-
>
EndExplicitSnapshot
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mInExplicitSnapshot
=
false
;
return
NS_OK
;
}
void
LSObject
:
:
LastRelease
(
)
{
AssertIsOnOwningThread
(
)
;
DropDatabase
(
)
;
}
nsresult
RequestHelper
:
:
StartAndReturnResponse
(
LSRequestResponse
&
aResponse
)
{
AssertIsOnOwningThread
(
)
;
{
auto
thread
=
static_cast
<
nsThread
*
>
(
NS_GetCurrentThread
(
)
)
;
auto
queue
=
static_cast
<
ThreadEventQueue
<
EventQueue
>
*
>
(
thread
-
>
EventQueue
(
)
)
;
mNestedEventTarget
=
queue
-
>
PushEventQueue
(
)
;
MOZ_ASSERT
(
mNestedEventTarget
)
;
auto
autoPopEventQueue
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
queue
-
>
PopEventQueue
(
mNestedEventTarget
)
;
}
)
;
nsCOMPtr
<
nsIEventTarget
>
domFileThread
=
IPCBlobInputStreamThread
:
:
GetOrCreate
(
)
;
if
(
NS_WARN_IF
(
!
domFileThread
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
domFileThread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
mWaiting
;
}
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
mResultCode
)
)
)
{
return
mResultCode
;
}
aResponse
=
std
:
:
move
(
mResponse
)
;
return
NS_OK
;
}
nsresult
RequestHelper
:
:
CancelOnAnyThread
(
)
{
RefPtr
<
RequestHelper
>
self
=
this
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
RequestHelper
:
:
CancelOnAnyThread
"
[
self
]
(
)
{
LSRequestChild
*
actor
=
self
-
>
mActor
;
if
(
actor
&
&
!
actor
-
>
Finishing
(
)
)
{
actor
-
>
SendCancel
(
)
;
}
}
)
;
nsCOMPtr
<
nsIEventTarget
>
domFileThread
=
IPCBlobInputStreamThread
:
:
GetOrCreate
(
)
;
if
(
NS_WARN_IF
(
!
domFileThread
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
domFileThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
RequestHelper
:
:
Start
(
)
{
AssertIsOnDOMFileThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Initial
)
;
mState
=
State
:
:
ResponsePending
;
LSRequestChild
*
actor
=
mObject
-
>
StartRequest
(
mNestedEventTarget
mParams
this
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
NS_ERROR_FAILURE
;
}
mActor
=
actor
;
return
NS_OK
;
}
void
RequestHelper
:
:
Finish
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Finishing
)
;
mObject
=
nullptr
;
mWaiting
=
false
;
mState
=
State
:
:
Complete
;
}
NS_IMPL_ISUPPORTS_INHERITED0
(
RequestHelper
Runnable
)
NS_IMETHODIMP
RequestHelper
:
:
Run
(
)
{
nsresult
rv
;
switch
(
mState
)
{
case
State
:
:
Initial
:
rv
=
Start
(
)
;
break
;
case
State
:
:
Finishing
:
Finish
(
)
;
return
NS_OK
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
mState
!
=
State
:
:
Finishing
)
{
if
(
NS_SUCCEEDED
(
mResultCode
)
)
{
mResultCode
=
rv
;
}
mState
=
State
:
:
Finishing
;
if
(
IsOnOwningThread
(
)
)
{
Finish
(
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
mNestedEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
}
return
NS_OK
;
}
void
RequestHelper
:
:
OnResponse
(
const
LSRequestResponse
&
aResponse
)
{
AssertIsOnDOMFileThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
ResponsePending
)
;
mActor
=
nullptr
;
mResponse
=
aResponse
;
mState
=
State
:
:
Finishing
;
MOZ_ALWAYS_SUCCEEDS
(
mNestedEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
}
}
