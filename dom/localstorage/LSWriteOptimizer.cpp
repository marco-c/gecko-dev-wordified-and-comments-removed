#
include
"
LSWriteOptimizer
.
h
"
#
include
<
new
>
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
{
class
LSWriteOptimizerBase
:
:
WriteInfoComparator
{
public
:
bool
Equals
(
const
WriteInfo
*
a
const
WriteInfo
*
b
)
const
{
MOZ_ASSERT
(
a
&
&
b
)
;
return
a
-
>
SerialNumber
(
)
=
=
b
-
>
SerialNumber
(
)
;
}
bool
LessThan
(
const
WriteInfo
*
a
const
WriteInfo
*
b
)
const
{
MOZ_ASSERT
(
a
&
&
b
)
;
return
a
-
>
SerialNumber
(
)
<
b
-
>
SerialNumber
(
)
;
}
}
;
void
LSWriteOptimizerBase
:
:
DeleteItem
(
const
nsAString
&
aKey
int64_t
aDelta
)
{
AssertIsOnOwningThread
(
)
;
mWriteInfos
.
WithEntryHandle
(
aKey
[
&
]
(
auto
&
&
entry
)
{
if
(
entry
&
&
entry
.
Data
(
)
-
>
GetType
(
)
=
=
WriteInfo
:
:
InsertItem
)
{
entry
.
Remove
(
)
;
}
else
{
entry
.
InsertOrUpdate
(
MakeUnique
<
DeleteItemInfo
>
(
NextSerialNumber
(
)
aKey
)
)
;
}
}
)
;
mTotalDelta
+
=
aDelta
;
}
void
LSWriteOptimizerBase
:
:
Truncate
(
int64_t
aDelta
)
{
AssertIsOnOwningThread
(
)
;
mWriteInfos
.
Clear
(
)
;
if
(
!
mTruncateInfo
)
{
mTruncateInfo
=
MakeUnique
<
TruncateInfo
>
(
NextSerialNumber
(
)
)
;
}
mTotalDelta
+
=
aDelta
;
}
void
LSWriteOptimizerBase
:
:
GetSortedWriteInfos
(
nsTArray
<
NotNull
<
WriteInfo
*
>
>
&
aWriteInfos
)
{
AssertIsOnOwningThread
(
)
;
if
(
mTruncateInfo
)
{
aWriteInfos
.
InsertElementSorted
(
WrapNotNullUnchecked
(
mTruncateInfo
.
get
(
)
)
WriteInfoComparator
(
)
)
;
}
for
(
const
auto
&
entry
:
mWriteInfos
)
{
WriteInfo
*
writeInfo
=
entry
.
GetWeak
(
)
;
aWriteInfos
.
InsertElementSorted
(
WrapNotNull
(
writeInfo
)
WriteInfoComparator
(
)
)
;
}
}
}
