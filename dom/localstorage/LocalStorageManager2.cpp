#
include
"
LocalStorageManager2
.
h
"
#
include
"
LSObject
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
AsyncRequestHelper
final
:
public
Runnable
public
LSRequestChildCallback
{
enum
class
State
{
Initial
ResponsePending
Finishing
Complete
}
;
RefPtr
<
LocalStorageManager2
>
mManager
;
nsCOMPtr
<
nsIEventTarget
>
mOwningEventTarget
;
LSRequestChild
*
mActor
;
RefPtr
<
Promise
>
mPromise
;
const
LSRequestParams
mParams
;
LSRequestResponse
mResponse
;
nsresult
mResultCode
;
State
mState
;
public
:
AsyncRequestHelper
(
LocalStorageManager2
*
aManager
Promise
*
aPromise
const
LSRequestParams
&
aParams
)
:
Runnable
(
"
dom
:
:
LocalStorageManager2
:
:
AsyncRequestHelper
"
)
mManager
(
aManager
)
mOwningEventTarget
(
GetCurrentThreadEventTarget
(
)
)
mActor
(
nullptr
)
mPromise
(
aPromise
)
mParams
(
aParams
)
mResultCode
(
NS_OK
)
mState
(
State
:
:
Initial
)
{
}
bool
IsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
mOwningEventTarget
)
;
bool
current
;
return
NS_SUCCEEDED
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
;
}
void
AssertIsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsOnOwningThread
(
)
)
;
}
nsresult
Dispatch
(
)
;
private
:
~
AsyncRequestHelper
(
)
=
default
;
nsresult
Start
(
)
;
void
Finish
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
void
OnResponse
(
const
LSRequestResponse
&
aResponse
)
override
;
}
;
class
SimpleRequestResolver
final
:
public
LSSimpleRequestChildCallback
{
RefPtr
<
Promise
>
mPromise
;
public
:
explicit
SimpleRequestResolver
(
Promise
*
aPromise
)
:
mPromise
(
aPromise
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
SimpleRequestResolver
override
)
;
private
:
~
SimpleRequestResolver
(
)
=
default
;
void
HandleResponse
(
nsresult
aResponse
)
;
void
HandleResponse
(
bool
aResponse
)
;
void
OnResponse
(
const
LSSimpleRequestResponse
&
aResponse
)
override
;
}
;
nsresult
CreatePromise
(
JSContext
*
aContext
Promise
*
*
aPromise
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aContext
)
;
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
JS
:
:
CurrentGlobalOrNull
(
aContext
)
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
result
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
result
)
;
if
(
result
.
Failed
(
)
)
{
return
result
.
StealNSResult
(
)
;
}
promise
.
forget
(
aPromise
)
;
return
NS_OK
;
}
nsresult
CheckedPrincipalToPrincipalInfo
(
nsIPrincipal
*
aPrincipal
PrincipalInfo
&
aPrincipalInfo
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsresult
rv
=
PrincipalToPrincipalInfo
(
aPrincipal
&
aPrincipalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
IsPrincipalInfoValid
(
aPrincipalInfo
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aPrincipalInfo
.
type
(
)
!
=
PrincipalInfo
:
:
TContentPrincipalInfo
&
&
aPrincipalInfo
.
type
(
)
!
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
}
LocalStorageManager2
:
:
LocalStorageManager2
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
NextGenLocalStorageEnabled
(
)
)
;
}
LocalStorageManager2
:
:
~
LocalStorageManager2
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMPL_ISUPPORTS
(
LocalStorageManager2
nsIDOMStorageManager
nsILocalStorageManager
)
NS_IMETHODIMP
LocalStorageManager2
:
:
PrecacheStorage
(
nsIPrincipal
*
aPrincipal
Storage
*
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
_retval
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
CreateStorage
(
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
const
nsAString
&
aDocumentURI
bool
aPrivate
Storage
*
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aStoragePrincipal
)
;
MOZ_ASSERT
(
_retval
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
nsPIDOMWindowInner
:
:
From
(
aWindow
)
;
RefPtr
<
LSObject
>
object
;
nsresult
rv
=
LSObject
:
:
CreateForPrincipal
(
inner
aPrincipal
aStoragePrincipal
aDocumentURI
aPrivate
getter_AddRefs
(
object
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
object
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
GetStorage
(
mozIDOMWindow
*
aWindow
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
bool
aPrivate
Storage
*
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aStoragePrincipal
)
;
MOZ_ASSERT
(
_retval
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
CloneStorage
(
Storage
*
aStorageToCloneFrom
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aStorageToCloneFrom
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
CheckStorage
(
nsIPrincipal
*
aPrincipal
Storage
*
aStorage
bool
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aStorage
)
;
MOZ_ASSERT
(
_retval
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
GetNextGenLocalStorageEnabled
(
bool
*
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aResult
)
;
*
aResult
=
NextGenLocalStorageEnabled
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
Preload
(
nsIPrincipal
*
aPrincipal
JSContext
*
aContext
nsISupports
*
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
_retval
)
;
nsCString
originAttrSuffix
;
nsCString
originKey
;
nsresult
rv
=
GenerateOriginKey
(
aPrincipal
originAttrSuffix
originKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoPtr
<
PrincipalInfo
>
principalInfo
(
new
PrincipalInfo
(
)
)
;
rv
=
CheckedPrincipalToPrincipalInfo
(
aPrincipal
*
principalInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
Promise
>
promise
;
if
(
aContext
)
{
rv
=
CreatePromise
(
aContext
getter_AddRefs
(
promise
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
LSRequestCommonParams
commonParams
;
commonParams
.
principalInfo
(
)
=
*
principalInfo
;
commonParams
.
storagePrincipalInfo
(
)
=
*
principalInfo
;
commonParams
.
originKey
(
)
=
originKey
;
LSRequestPreloadDatastoreParams
params
(
commonParams
)
;
RefPtr
<
AsyncRequestHelper
>
helper
=
new
AsyncRequestHelper
(
this
promise
params
)
;
rv
=
helper
-
>
Dispatch
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
promise
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
LocalStorageManager2
:
:
IsPreloaded
(
nsIPrincipal
*
aPrincipal
JSContext
*
aContext
nsISupports
*
*
_retval
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
_retval
)
;
RefPtr
<
Promise
>
promise
;
nsresult
rv
=
CreatePromise
(
aContext
getter_AddRefs
(
promise
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
LSSimpleRequestPreloadedParams
params
;
rv
=
CheckedPrincipalToPrincipalInfo
(
aPrincipal
params
.
principalInfo
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
StartSimpleRequest
(
promise
params
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
promise
.
forget
(
_retval
)
;
return
NS_OK
;
}
LSRequestChild
*
LocalStorageManager2
:
:
StartRequest
(
const
LSRequestParams
&
aParams
LSRequestChildCallback
*
aCallback
)
{
AssertIsOnDOMFileThread
(
)
;
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
nullptr
;
}
auto
actor
=
new
LSRequestChild
(
aCallback
)
;
if
(
!
backgroundActor
-
>
SendPBackgroundLSRequestConstructor
(
actor
aParams
)
)
{
return
nullptr
;
}
return
actor
;
}
nsresult
LocalStorageManager2
:
:
StartSimpleRequest
(
Promise
*
aPromise
const
LSSimpleRequestParams
&
aParams
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
SimpleRequestResolver
>
resolver
=
new
SimpleRequestResolver
(
aPromise
)
;
auto
actor
=
new
LSSimpleRequestChild
(
resolver
)
;
if
(
!
backgroundActor
-
>
SendPBackgroundLSSimpleRequestConstructor
(
actor
aParams
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
AsyncRequestHelper
:
:
Dispatch
(
)
{
AssertIsOnOwningThread
(
)
;
nsCOMPtr
<
nsIEventTarget
>
domFileThread
=
IPCBlobInputStreamThread
:
:
GetOrCreate
(
)
;
if
(
NS_WARN_IF
(
!
domFileThread
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
domFileThread
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
AsyncRequestHelper
:
:
Start
(
)
{
AssertIsOnDOMFileThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Initial
)
;
mState
=
State
:
:
ResponsePending
;
LSRequestChild
*
actor
=
mManager
-
>
StartRequest
(
mParams
this
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
NS_ERROR_FAILURE
;
}
mActor
=
actor
;
return
NS_OK
;
}
void
AsyncRequestHelper
:
:
Finish
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Finishing
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
mResultCode
)
)
)
{
if
(
mPromise
)
{
mPromise
-
>
MaybeReject
(
mResultCode
)
;
}
}
else
{
switch
(
mResponse
.
type
(
)
)
{
case
LSRequestResponse
:
:
Tnsresult
:
if
(
mPromise
)
{
mPromise
-
>
MaybeReject
(
mResponse
.
get_nsresult
(
)
)
;
}
break
;
case
LSRequestResponse
:
:
TLSRequestPreloadDatastoreResponse
:
if
(
mPromise
)
{
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Unknown
response
type
!
"
)
;
}
}
mManager
=
nullptr
;
mState
=
State
:
:
Complete
;
}
NS_IMPL_ISUPPORTS_INHERITED0
(
AsyncRequestHelper
Runnable
)
NS_IMETHODIMP
AsyncRequestHelper
:
:
Run
(
)
{
nsresult
rv
;
switch
(
mState
)
{
case
State
:
:
Initial
:
rv
=
Start
(
)
;
break
;
case
State
:
:
Finishing
:
Finish
(
)
;
return
NS_OK
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
mState
!
=
State
:
:
Finishing
)
{
if
(
NS_SUCCEEDED
(
mResultCode
)
)
{
mResultCode
=
rv
;
}
mState
=
State
:
:
Finishing
;
if
(
IsOnOwningThread
(
)
)
{
Finish
(
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
mOwningEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
}
return
NS_OK
;
}
void
AsyncRequestHelper
:
:
OnResponse
(
const
LSRequestResponse
&
aResponse
)
{
AssertIsOnDOMFileThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
ResponsePending
)
;
mActor
=
nullptr
;
mResponse
=
aResponse
;
mState
=
State
:
:
Finishing
;
MOZ_ALWAYS_SUCCEEDS
(
mOwningEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
void
SimpleRequestResolver
:
:
HandleResponse
(
nsresult
aResponse
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
MaybeReject
(
aResponse
)
;
}
void
SimpleRequestResolver
:
:
HandleResponse
(
bool
aResponse
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPromise
)
;
mPromise
-
>
MaybeResolve
(
aResponse
)
;
}
void
SimpleRequestResolver
:
:
OnResponse
(
const
LSSimpleRequestResponse
&
aResponse
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
aResponse
.
type
(
)
)
{
case
LSSimpleRequestResponse
:
:
Tnsresult
:
HandleResponse
(
aResponse
.
get_nsresult
(
)
)
;
break
;
case
LSSimpleRequestResponse
:
:
TLSSimpleRequestPreloadedResponse
:
HandleResponse
(
aResponse
.
get_LSSimpleRequestPreloadedResponse
(
)
.
preloaded
(
)
)
;
break
;
default
:
MOZ_CRASH
(
"
Unknown
response
type
!
"
)
;
}
}
}
}
