#
include
"
ActorsParent
.
h
"
#
include
"
LSObject
.
h
"
#
include
"
ReportInternalError
.
h
"
#
include
<
cinttypes
>
#
include
<
cstdlib
>
#
include
<
cstring
>
#
include
<
new
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
CrashAnnotations
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozIStorageAsyncConnection
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozIStorageFunction
.
h
"
#
include
"
mozIStorageService
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozIStorageValueArray
.
h
"
#
include
"
mozStorageCID
.
h
"
#
include
"
mozStorageHelper
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
ClientManagerService
.
h
"
#
include
"
mozilla
/
dom
/
FlippedOnce
.
h
"
#
include
"
mozilla
/
dom
/
LSSnapshot
.
h
"
#
include
"
mozilla
/
dom
/
LSValue
.
h
"
#
include
"
mozilla
/
dom
/
LSWriteOptimizer
.
h
"
#
include
"
mozilla
/
dom
/
LSWriteOptimizerImpl
.
h
"
#
include
"
mozilla
/
dom
/
LocalStorageCommon
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSDatabase
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSDatabaseParent
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSObserverParent
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSRequestParent
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSSharedTypes
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSSimpleRequestParent
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundLSSnapshotParent
.
h
"
#
include
"
mozilla
/
dom
/
SnappyUtils
.
h
"
#
include
"
mozilla
/
dom
/
StorageDBUpdater
.
h
"
#
include
"
mozilla
/
dom
/
StorageUtils
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
CheckedUnsafePtr
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
Client
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
OriginScope
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
PersistenceType
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaObject
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
UsageInfo
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
storage
/
Variant
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIBinaryInputStream
.
h
"
#
include
"
nsIBinaryOutputStream
.
h
"
#
include
"
nsIDirectoryEnumerator
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPointerHashKeys
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsTLiteralString
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nscore
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prtime
.
h
"
#
define
DISABLE_ASSERTS_FOR_FUZZING
0
#
if
DISABLE_ASSERTS_FOR_FUZZING
#
define
ASSERT_UNLESS_FUZZING
(
.
.
.
)
\
do
{
\
}
while
(
0
)
#
else
#
define
ASSERT_UNLESS_FUZZING
(
.
.
.
)
MOZ_ASSERT
(
false
__VA_ARGS__
)
#
endif
#
define
LS_LOG_TEST
(
)
MOZ_LOG_TEST
(
GetLocalStorageLogger
(
)
LogLevel
:
:
Info
)
#
define
LS_LOG
(
_args
)
MOZ_LOG
(
GetLocalStorageLogger
(
)
LogLevel
:
:
Info
_args
)
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
define
LS_MOBILE
#
endif
namespace
mozilla
:
:
dom
{
using
namespace
mozilla
:
:
dom
:
:
quota
;
using
namespace
mozilla
:
:
dom
:
:
StorageUtils
;
using
namespace
mozilla
:
:
ipc
;
namespace
{
struct
ArchivedOriginInfo
;
class
ArchivedOriginScope
;
class
Connection
;
class
ConnectionThread
;
class
Database
;
class
Observer
;
class
PrepareDatastoreOp
;
class
PreparedDatastore
;
class
QuotaClient
;
class
Snapshot
;
typedef
nsClassHashtable
<
nsCStringHashKey
ArchivedOriginInfo
>
ArchivedOriginHashtable
;
const
uint32_t
kMajorSchemaVersion
=
4
;
const
uint32_t
kMinorSchemaVersion
=
0
;
static_assert
(
kMajorSchemaVersion
<
=
0xFFFFFFF
"
Major
version
needs
to
fit
in
28
bits
.
"
)
;
static_assert
(
kMinorSchemaVersion
<
=
0xF
"
Minor
version
needs
to
fit
in
4
bits
.
"
)
;
const
int32_t
kSQLiteSchemaVersion
=
int32_t
(
(
kMajorSchemaVersion
<
<
4
)
+
kMinorSchemaVersion
)
;
const
uint32_t
kSQLitePageSizeOverride
=
#
ifdef
LS_MOBILE
512
;
#
else
1024
;
#
endif
static_assert
(
kSQLitePageSizeOverride
=
=
0
|
|
(
kSQLitePageSizeOverride
%
2
=
=
0
&
&
kSQLitePageSizeOverride
>
=
512
&
&
kSQLitePageSizeOverride
<
=
65536
)
"
Must
be
0
(
disabled
)
or
a
power
of
2
between
512
and
65536
!
"
)
;
const
uint32_t
kSQLiteGrowthIncrement
=
kSQLitePageSizeOverride
*
2
;
static_assert
(
kSQLiteGrowthIncrement
>
=
0
&
&
kSQLiteGrowthIncrement
%
kSQLitePageSizeOverride
=
=
0
&
&
kSQLiteGrowthIncrement
<
uint32_t
(
INT32_MAX
)
"
Must
be
0
(
disabled
)
or
a
positive
multiple
of
the
page
size
!
"
)
;
constexpr
auto
kDataFileName
=
u
"
data
.
sqlite
"
_ns
;
constexpr
auto
kJournalFileName
=
u
"
data
.
sqlite
-
journal
"
_ns
;
constexpr
auto
kUsageFileName
=
u
"
usage
"
_ns
;
constexpr
auto
kUsageJournalFileName
=
u
"
usage
-
journal
"
_ns
;
static
const
uint32_t
kUsageFileSize
=
12
;
static
const
uint32_t
kUsageFileCookie
=
0x420a420a
;
const
uint32_t
kFlushTimeoutMs
=
5000
;
const
char
kPrivateBrowsingObserverTopic
[
]
=
"
last
-
pb
-
context
-
exited
"
;
const
uint32_t
kDefaultShadowWrites
=
true
;
const
uint32_t
kDefaultSnapshotPrefill
=
16384
;
const
uint32_t
kDefaultSnapshotGradualPrefill
=
4096
;
const
uint32_t
kDefaultClientValidation
=
true
;
const
char
kShadowWritesPref
[
]
=
"
dom
.
storage
.
shadow_writes
"
;
const
char
kSnapshotPrefillPref
[
]
=
"
dom
.
storage
.
snapshot_prefill
"
;
const
char
kSnapshotGradualPrefillPref
[
]
=
"
dom
.
storage
.
snapshot_gradual_prefill
"
;
const
char
kClientValidationPref
[
]
=
"
dom
.
storage
.
client_validation
"
;
const
uint32_t
kPreparedDatastoreTimeoutMs
=
20000
;
#
define
LS_ARCHIVE_FILE_NAME
u
"
ls
-
archive
.
sqlite
"
#
define
WEB_APPS_STORE_FILE_NAME
u
"
webappsstore
.
sqlite
"
const
uint32_t
kShadowMaxWALSize
=
512
*
1024
;
const
uint32_t
kShadowJournalSizeLimit
=
kShadowMaxWALSize
*
3
;
#
define
SHUTDOWN_FORCE_KILL_TIMEOUT_MS
5000
#
define
SHUTDOWN_FORCE_CRASH_TIMEOUT_MS
45000
bool
IsOnConnectionThread
(
)
;
void
AssertIsOnConnectionThread
(
)
;
int32_t
MakeSchemaVersion
(
uint32_t
aMajorSchemaVersion
uint32_t
aMinorSchemaVersion
)
{
return
int32_t
(
(
aMajorSchemaVersion
<
<
4
)
+
aMinorSchemaVersion
)
;
}
nsCString
GetArchivedOriginHashKey
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
{
return
aOriginSuffix
+
"
:
"
_ns
+
aOriginNoSuffix
;
}
nsresult
CreateTables
(
mozIStorageConnection
*
aConnection
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
database
"
"
(
origin
TEXT
NOT
NULL
"
"
usage
INTEGER
NOT
NULL
DEFAULT
0
"
"
last_vacuum_time
INTEGER
NOT
NULL
DEFAULT
0
"
"
last_analyze_time
INTEGER
NOT
NULL
DEFAULT
0
"
"
last_vacuum_size
INTEGER
NOT
NULL
DEFAULT
0
"
"
)
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
data
"
"
(
key
TEXT
PRIMARY
KEY
"
"
value
TEXT
NOT
NULL
"
"
utf16Length
INTEGER
NOT
NULL
DEFAULT
0
"
"
compressed
INTEGER
NOT
NULL
DEFAULT
0
"
"
lastAccessTime
INTEGER
NOT
NULL
DEFAULT
0
"
"
)
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
SetSchemaVersion
(
kSQLiteSchemaVersion
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
UpgradeSchemaFrom1_0To2_0
(
mozIStorageConnection
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
database
ADD
COLUMN
usage
INTEGER
NOT
NULL
DEFAULT
0
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
UPDATE
database
"
"
SET
usage
=
(
SELECT
total
(
utf16Length
(
key
)
+
utf16Length
(
value
)
)
"
"
FROM
data
)
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
SetSchemaVersion
(
MakeSchemaVersion
(
2
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
UpgradeSchemaFrom2_0To3_0
(
mozIStorageConnection
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
data
ADD
COLUMN
utf16Length
INTEGER
NOT
NULL
DEFAULT
0
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
"
UPDATE
data
SET
utf16Length
=
utf16Length
(
value
)
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
SetSchemaVersion
(
MakeSchemaVersion
(
3
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
UpgradeSchemaFrom3_0To4_0
(
mozIStorageConnection
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
SetSchemaVersion
(
MakeSchemaVersion
(
4
0
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
SetDefaultPragmas
(
mozIStorageConnection
*
aConnection
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
"
PRAGMA
synchronous
=
FULL
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifndef
LS_MOBILE
if
(
kSQLiteGrowthIncrement
)
{
rv
=
aConnection
-
>
SetGrowthIncrement
(
kSQLiteGrowthIncrement
"
"
_ns
)
;
if
(
rv
!
=
NS_ERROR_FILE_TOO_BIG
&
&
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
#
endif
return
NS_OK
;
}
nsresult
CreateStorageConnection
(
nsIFile
*
aDBFile
nsIFile
*
aUsageFile
const
nsACString
&
aOrigin
mozIStorageConnection
*
*
aConnection
bool
*
aRemovedUsageFile
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
aDBFile
)
;
MOZ_ASSERT
(
aUsageFile
)
;
MOZ_ASSERT
(
aConnection
)
;
MOZ_ASSERT
(
aRemovedUsageFile
)
;
*
aRemovedUsageFile
=
false
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageService
>
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
rv
=
ss
-
>
OpenDatabase
(
aDBFile
getter_AddRefs
(
connection
)
)
;
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
rv
=
aUsageFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aRemovedUsageFile
=
true
;
rv
=
aDBFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
ss
-
>
OpenDatabase
(
aDBFile
getter_AddRefs
(
connection
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
SetDefaultPragmas
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int32_t
schemaVersion
;
rv
=
connection
-
>
GetSchemaVersion
(
&
schemaVersion
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
schemaVersion
>
kSQLiteSchemaVersion
)
{
LS_WARNING
(
"
Unable
to
open
LocalStorage
database
schema
is
too
high
!
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
schemaVersion
!
=
kSQLiteSchemaVersion
)
{
const
bool
newDatabase
=
!
schemaVersion
;
if
(
newDatabase
)
{
if
(
kSQLitePageSizeOverride
)
{
rv
=
connection
-
>
ExecuteSimpleSQL
(
nsPrintfCString
(
"
PRAGMA
page_size
=
%
"
PRIu32
"
;
"
kSQLitePageSizeOverride
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
connection
-
>
ExecuteSimpleSQL
(
#
ifdef
LS_MOBILE
"
PRAGMA
auto_vacuum
=
FULL
;
"
_ns
#
else
"
PRAGMA
auto_vacuum
=
INCREMENTAL
;
"
_ns
#
endif
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
mozStorageTransaction
transaction
(
connection
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
if
(
newDatabase
)
{
rv
=
CreateTables
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
DEBUG
{
LS_TRY_INSPECT
(
const
int32_t
&
schemaVersion
MOZ_TO_RESULT_INVOKE
(
connection
GetSchemaVersion
)
QM_ASSERT_UNREACHABLE
)
;
MOZ_ASSERT
(
schemaVersion
=
=
kSQLiteSchemaVersion
)
;
}
#
endif
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
connection
-
>
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
database
(
origin
)
"
"
VALUES
(
:
origin
)
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindUTF8StringByName
(
"
origin
"
_ns
aOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
static_assert
(
kSQLiteSchemaVersion
=
=
int32_t
(
(
4
<
<
4
)
+
0
)
"
Upgrade
function
needed
due
to
schema
version
increase
.
"
)
;
while
(
schemaVersion
!
=
kSQLiteSchemaVersion
)
{
if
(
schemaVersion
=
=
MakeSchemaVersion
(
1
0
)
)
{
rv
=
UpgradeSchemaFrom1_0To2_0
(
connection
)
;
}
else
if
(
schemaVersion
=
=
MakeSchemaVersion
(
2
0
)
)
{
rv
=
UpgradeSchemaFrom2_0To3_0
(
connection
)
;
}
else
if
(
schemaVersion
=
=
MakeSchemaVersion
(
3
0
)
)
{
rv
=
UpgradeSchemaFrom3_0To4_0
(
connection
)
;
}
else
{
LS_WARNING
(
"
Unable
to
open
LocalStorage
database
no
upgrade
path
is
"
"
available
!
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
connection
-
>
GetSchemaVersion
(
&
schemaVersion
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
MOZ_ASSERT
(
schemaVersion
=
=
kSQLiteSchemaVersion
)
;
}
rv
=
transaction
.
Commit
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
newDatabase
)
{
bool
dummy
;
rv
=
aDBFile
-
>
Exists
(
&
dummy
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int64_t
fileSize
;
rv
=
aDBFile
-
>
GetFileSize
(
&
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
fileSize
>
0
)
;
PRTime
vacuumTime
=
PR_Now
(
)
;
MOZ_ASSERT
(
vacuumTime
)
;
nsCOMPtr
<
mozIStorageStatement
>
vacuumTimeStmt
;
rv
=
connection
-
>
CreateStatement
(
nsLiteralCString
(
"
UPDATE
database
"
"
SET
last_vacuum_time
=
:
time
"
"
last_vacuum_size
=
:
size
;
"
)
getter_AddRefs
(
vacuumTimeStmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
vacuumTimeStmt
-
>
BindInt64ByName
(
"
time
"
_ns
vacuumTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
vacuumTimeStmt
-
>
BindInt64ByName
(
"
size
"
_ns
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
vacuumTimeStmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
connection
.
forget
(
aConnection
)
;
return
NS_OK
;
}
nsresult
GetStorageConnection
(
const
nsAString
&
aDatabaseFilePath
mozIStorageConnection
*
*
aConnection
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
!
aDatabaseFilePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
StringEndsWith
(
aDatabaseFilePath
u
"
.
sqlite
"
_ns
)
)
;
MOZ_ASSERT
(
aConnection
)
;
auto
databaseFileOrErr
=
QM_NewLocalFile
(
aDatabaseFilePath
)
;
if
(
NS_WARN_IF
(
databaseFileOrErr
.
isErr
(
)
)
)
{
return
databaseFileOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIFile
>
databaseFile
=
databaseFileOrErr
.
unwrap
(
)
;
bool
exists
;
nsresult
rv
=
databaseFile
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
exists
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
mozIStorageService
>
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
rv
=
ss
-
>
OpenDatabase
(
databaseFile
getter_AddRefs
(
connection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
SetDefaultPragmas
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
connection
.
forget
(
aConnection
)
;
return
NS_OK
;
}
nsresult
GetArchiveFile
(
const
nsAString
&
aStoragePath
nsIFile
*
*
aArchiveFile
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
!
aStoragePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aArchiveFile
)
;
auto
archiveFileOrErr
=
QM_NewLocalFile
(
aStoragePath
)
;
if
(
NS_WARN_IF
(
archiveFileOrErr
.
isErr
(
)
)
)
{
return
archiveFileOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIFile
>
archiveFile
=
archiveFileOrErr
.
unwrap
(
)
;
nsresult
rv
=
archiveFile
-
>
Append
(
nsLiteralString
(
LS_ARCHIVE_FILE_NAME
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
archiveFile
.
forget
(
aArchiveFile
)
;
return
NS_OK
;
}
nsresult
CreateArchiveStorageConnection
(
const
nsAString
&
aStoragePath
mozIStorageConnection
*
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
!
aStoragePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsCOMPtr
<
nsIFile
>
archiveFile
;
nsresult
rv
=
GetArchiveFile
(
aStoragePath
getter_AddRefs
(
archiveFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
DebugOnly
<
bool
>
exists
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
archiveFile
-
>
Exists
(
&
exists
)
)
)
;
MOZ_ASSERT
(
exists
)
;
bool
isDirectory
;
rv
=
archiveFile
-
>
IsDirectory
(
&
isDirectory
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isDirectory
)
{
LS_WARNING
(
"
ls
-
archive
is
not
a
file
!
"
)
;
*
aConnection
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageService
>
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
rv
=
ss
-
>
OpenUnsharedDatabase
(
archiveFile
getter_AddRefs
(
connection
)
)
;
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
*
aConnection
=
nullptr
;
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
StorageDBUpdater
:
:
Update
(
connection
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aConnection
=
nullptr
;
return
NS_OK
;
}
connection
.
forget
(
aConnection
)
;
return
NS_OK
;
}
nsresult
AttachArchiveDatabase
(
const
nsAString
&
aStoragePath
mozIStorageConnection
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
!
aStoragePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsCOMPtr
<
nsIFile
>
archiveFile
;
nsresult
rv
=
GetArchiveFile
(
aStoragePath
getter_AddRefs
(
archiveFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
DEBUG
bool
exists
;
rv
=
archiveFile
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
exists
)
;
#
endif
nsString
path
;
rv
=
archiveFile
-
>
GetPath
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
aConnection
-
>
CreateStatement
(
"
ATTACH
DATABASE
:
path
AS
archive
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindStringByName
(
"
path
"
_ns
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
DetachArchiveDatabase
(
mozIStorageConnection
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
"
DETACH
DATABASE
archive
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
GetShadowFile
(
const
nsAString
&
aBasePath
nsIFile
*
*
aArchiveFile
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
!
aBasePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aArchiveFile
)
;
auto
archiveFileOrErr
=
QM_NewLocalFile
(
aBasePath
)
;
if
(
NS_WARN_IF
(
archiveFileOrErr
.
isErr
(
)
)
)
{
return
archiveFileOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIFile
>
archiveFile
=
archiveFileOrErr
.
unwrap
(
)
;
nsresult
rv
=
archiveFile
-
>
Append
(
nsLiteralString
(
WEB_APPS_STORE_FILE_NAME
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
archiveFile
.
forget
(
aArchiveFile
)
;
return
NS_OK
;
}
nsresult
SetShadowJournalMode
(
mozIStorageConnection
*
aConnection
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
constexpr
auto
journalModeQueryStart
=
"
PRAGMA
journal_mode
=
"
_ns
;
constexpr
auto
journalModeWAL
=
"
wal
"
_ns
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
aConnection
-
>
CreateStatement
(
journalModeQueryStart
+
journalModeWAL
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
hasResult
)
;
nsCString
journalMode
;
rv
=
stmt
-
>
GetUTF8String
(
0
journalMode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
journalMode
.
Equals
(
journalModeWAL
)
)
{
rv
=
aConnection
-
>
CreateStatement
(
"
PRAGMA
page_size
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
hasResult
)
;
int32_t
pageSize
;
rv
=
stmt
-
>
GetInt32
(
0
&
pageSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
pageSize
>
=
512
&
&
pageSize
<
=
65536
)
;
const
nsAutoCString
pageCount
=
IntToCString
(
static_cast
<
int32_t
>
(
kShadowMaxWALSize
/
pageSize
)
)
;
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
"
PRAGMA
wal_autocheckpoint
=
"
_ns
+
pageCount
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
const
nsAutoCString
sizeLimit
=
IntToCString
(
kShadowJournalSizeLimit
)
;
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
"
PRAGMA
journal_size_limit
=
"
_ns
+
sizeLimit
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
journalModeQueryStart
+
"
truncate
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
CreateShadowStorageConnection
(
const
nsAString
&
aBasePath
mozIStorageConnection
*
*
aConnection
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
!
aBasePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsCOMPtr
<
nsIFile
>
shadowFile
;
nsresult
rv
=
GetShadowFile
(
aBasePath
getter_AddRefs
(
shadowFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageService
>
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
rv
=
ss
-
>
OpenUnsharedDatabase
(
shadowFile
getter_AddRefs
(
connection
)
)
;
if
(
rv
=
=
NS_ERROR_FILE_CORRUPTED
)
{
rv
=
shadowFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
ss
-
>
OpenUnsharedDatabase
(
shadowFile
getter_AddRefs
(
connection
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
SetShadowJournalMode
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
StorageDBUpdater
:
:
Update
(
connection
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
connection
-
>
Close
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
shadowFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
ss
-
>
OpenUnsharedDatabase
(
shadowFile
getter_AddRefs
(
connection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
SetShadowJournalMode
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
StorageDBUpdater
:
:
Update
(
connection
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
connection
.
forget
(
aConnection
)
;
return
NS_OK
;
}
nsresult
GetShadowStorageConnection
(
const
nsAString
&
aBasePath
mozIStorageConnection
*
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
!
aBasePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsCOMPtr
<
nsIFile
>
shadowFile
;
nsresult
rv
=
GetShadowFile
(
aBasePath
getter_AddRefs
(
shadowFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
exists
;
rv
=
shadowFile
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
exists
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
mozIStorageService
>
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
rv
=
ss
-
>
OpenUnsharedDatabase
(
shadowFile
getter_AddRefs
(
connection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
connection
.
forget
(
aConnection
)
;
return
NS_OK
;
}
nsresult
AttachShadowDatabase
(
const
nsAString
&
aBasePath
mozIStorageConnection
*
aConnection
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
!
aBasePath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aConnection
)
;
nsCOMPtr
<
nsIFile
>
shadowFile
;
nsresult
rv
=
GetShadowFile
(
aBasePath
getter_AddRefs
(
shadowFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
DEBUG
bool
exists
;
rv
=
shadowFile
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
exists
)
;
#
endif
nsString
path
;
rv
=
shadowFile
-
>
GetPath
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
aConnection
-
>
CreateStatement
(
"
ATTACH
DATABASE
:
path
AS
shadow
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindStringByName
(
"
path
"
_ns
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
DetachShadowDatabase
(
mozIStorageConnection
*
aConnection
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
=
aConnection
-
>
ExecuteSimpleSQL
(
"
DETACH
DATABASE
shadow
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
GetUsageFile
(
const
nsAString
&
aDirectoryPath
nsIFile
*
*
aUsageFile
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
!
aDirectoryPath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aUsageFile
)
;
auto
usageFileOrErr
=
QM_NewLocalFile
(
aDirectoryPath
)
;
if
(
NS_WARN_IF
(
usageFileOrErr
.
isErr
(
)
)
)
{
return
usageFileOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIFile
>
usageFile
=
usageFileOrErr
.
unwrap
(
)
;
nsresult
rv
=
usageFile
-
>
Append
(
kUsageFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
usageFile
.
forget
(
aUsageFile
)
;
return
NS_OK
;
}
nsresult
GetUsageJournalFile
(
const
nsAString
&
aDirectoryPath
nsIFile
*
*
aUsageJournalFile
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
!
aDirectoryPath
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aUsageJournalFile
)
;
auto
usageJournalFileOrErr
=
QM_NewLocalFile
(
aDirectoryPath
)
;
if
(
NS_WARN_IF
(
usageJournalFileOrErr
.
isErr
(
)
)
)
{
return
usageJournalFileOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIFile
>
usageJournalFile
=
usageJournalFileOrErr
.
unwrap
(
)
;
nsresult
rv
=
usageJournalFile
-
>
Append
(
kUsageJournalFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
usageJournalFile
.
forget
(
aUsageJournalFile
)
;
return
NS_OK
;
}
Result
<
bool
nsresult
>
ExistsAsFile
(
nsIFile
&
aFile
)
{
enum
class
ExistsAsFileResult
{
DoesNotExist
IsDirectory
IsFile
}
;
QM_TRY_INSPECT
(
const
auto
&
res
MOZ_TO_RESULT_INVOKE
(
aFile
IsDirectory
)
.
map
(
[
]
(
const
bool
isDirectory
)
{
return
isDirectory
?
ExistsAsFileResult
:
:
IsDirectory
:
ExistsAsFileResult
:
:
IsFile
;
}
)
.
orElse
(
[
]
(
const
nsresult
rv
)
-
>
Result
<
ExistsAsFileResult
nsresult
>
{
if
(
rv
!
=
NS_ERROR_FILE_NOT_FOUND
&
&
rv
!
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
{
return
Err
(
rv
)
;
}
return
ExistsAsFileResult
:
:
DoesNotExist
;
}
)
)
;
QM_TRY
(
OkIf
(
res
!
=
ExistsAsFileResult
:
:
IsDirectory
)
Err
(
NS_ERROR_FAILURE
)
)
;
return
res
=
=
ExistsAsFileResult
:
:
IsFile
;
}
nsresult
UpdateUsageFile
(
nsIFile
*
aUsageFile
nsIFile
*
aUsageJournalFile
int64_t
aUsage
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
aUsageFile
)
;
MOZ_ASSERT
(
aUsageJournalFile
)
;
MOZ_ASSERT
(
aUsage
>
=
0
)
;
bool
isDirectory
;
nsresult
rv
=
aUsageJournalFile
-
>
IsDirectory
(
&
isDirectory
)
;
if
(
rv
!
=
NS_ERROR_FILE_NOT_FOUND
&
&
rv
!
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
isDirectory
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
rv
=
aUsageJournalFile
-
>
Create
(
nsIFile
:
:
NORMAL_FILE_TYPE
0644
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
nsIOutputStream
>
stream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
stream
)
aUsageFile
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIBinaryOutputStream
>
binaryStream
=
NS_NewObjectOutputStream
(
stream
)
;
rv
=
binaryStream
-
>
Write32
(
kUsageFileCookie
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
binaryStream
-
>
Write64
(
aUsage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stream
-
>
Close
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
LoadUsageFile
(
nsIFile
*
aUsageFile
int64_t
*
aUsage
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aUsageFile
)
;
MOZ_ASSERT
(
aUsage
)
;
int64_t
fileSize
;
nsresult
rv
=
aUsageFile
-
>
GetFileSize
(
&
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
fileSize
!
=
kUsageFileSize
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
stream
)
aUsageFile
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIInputStream
>
bufferedStream
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufferedStream
)
stream
.
forget
(
)
16
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIBinaryInputStream
>
binaryStream
=
NS_NewObjectInputStream
(
bufferedStream
)
;
uint32_t
cookie
;
rv
=
binaryStream
-
>
Read32
(
&
cookie
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
cookie
!
=
kUsageFileCookie
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
uint64_t
usage
;
rv
=
binaryStream
-
>
Read64
(
&
usage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aUsage
=
usage
;
return
NS_OK
;
}
class
DatastoreWriteOptimizer
final
:
public
LSWriteOptimizer
<
LSValue
>
{
public
:
void
ApplyAndReset
(
nsTArray
<
LSItemInfo
>
&
aOrderedItems
)
;
}
;
class
ConnectionWriteOptimizer
final
:
public
LSWriteOptimizer
<
LSValue
>
{
public
:
nsresult
Perform
(
Connection
*
aConnection
bool
aShadowWrites
int64_t
&
aOutUsage
)
;
private
:
nsresult
PerformInsertOrUpdate
(
Connection
*
aConnection
bool
aShadowWrites
const
nsAString
&
aKey
const
LSValue
&
aValue
)
;
nsresult
PerformDelete
(
Connection
*
aConnection
bool
aShadowWrites
const
nsAString
&
aKey
)
;
nsresult
PerformTruncate
(
Connection
*
aConnection
bool
aShadowWrites
)
;
}
;
class
DatastoreOperationBase
:
public
Runnable
{
nsCOMPtr
<
nsIEventTarget
>
mOwningEventTarget
;
nsresult
mResultCode
;
Atomic
<
bool
>
mMayProceedOnNonOwningThread
;
bool
mMayProceed
;
public
:
nsIEventTarget
*
OwningEventTarget
(
)
const
{
MOZ_ASSERT
(
mOwningEventTarget
)
;
return
mOwningEventTarget
;
}
bool
IsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
mOwningEventTarget
)
;
bool
current
;
return
NS_SUCCEEDED
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
;
}
void
AssertIsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
IsOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
IsOnOwningThread
(
)
)
;
}
nsresult
ResultCode
(
)
const
{
return
mResultCode
;
}
void
SetFailureCode
(
nsresult
aErrorCode
)
{
MOZ_ASSERT
(
NS_SUCCEEDED
(
mResultCode
)
)
;
MOZ_ASSERT
(
NS_FAILED
(
aErrorCode
)
)
;
mResultCode
=
aErrorCode
;
}
void
MaybeSetFailureCode
(
nsresult
aErrorCode
)
{
MOZ_ASSERT
(
NS_FAILED
(
aErrorCode
)
)
;
if
(
NS_SUCCEEDED
(
mResultCode
)
)
{
mResultCode
=
aErrorCode
;
}
}
void
NoteComplete
(
)
{
AssertIsOnOwningThread
(
)
;
mMayProceed
=
false
;
mMayProceedOnNonOwningThread
=
false
;
}
bool
MayProceed
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mMayProceed
;
}
bool
MayProceedOnNonOwningThread
(
)
const
{
return
mMayProceedOnNonOwningThread
;
}
protected
:
DatastoreOperationBase
(
)
:
Runnable
(
"
dom
:
:
DatastoreOperationBase
"
)
mOwningEventTarget
(
GetCurrentEventTarget
(
)
)
mResultCode
(
NS_OK
)
mMayProceedOnNonOwningThread
(
true
)
mMayProceed
(
true
)
{
}
~
DatastoreOperationBase
(
)
override
{
MOZ_ASSERT
(
!
mMayProceed
)
;
}
}
;
class
ConnectionDatastoreOperationBase
:
public
DatastoreOperationBase
{
protected
:
RefPtr
<
Connection
>
mConnection
;
const
bool
mEnsureStorageConnection
;
public
:
virtual
void
Cleanup
(
)
;
protected
:
ConnectionDatastoreOperationBase
(
Connection
*
aConnection
bool
aEnsureStorageConnection
=
true
)
;
~
ConnectionDatastoreOperationBase
(
)
;
virtual
nsresult
DoDatastoreWork
(
)
=
0
;
virtual
void
OnSuccess
(
)
;
virtual
void
OnFailure
(
nsresult
aResultCode
)
;
private
:
void
RunOnConnectionThread
(
)
;
void
RunOnOwningThread
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
Connection
final
{
friend
class
ConnectionThread
;
public
:
class
CachedStatement
;
private
:
class
InitStorageAndOriginHelper
;
class
FlushOp
;
class
CloseOp
;
RefPtr
<
ConnectionThread
>
mConnectionThread
;
RefPtr
<
QuotaClient
>
mQuotaClient
;
nsCOMPtr
<
nsITimer
>
mFlushTimer
;
nsCOMPtr
<
mozIStorageConnection
>
mStorageConnection
;
UniquePtr
<
ArchivedOriginScope
>
mArchivedOriginScope
;
nsInterfaceHashtable
<
nsCStringHashKey
mozIStorageStatement
>
mCachedStatements
;
ConnectionWriteOptimizer
mWriteOptimizer
;
const
QuotaInfo
mQuotaInfo
;
nsString
mDirectoryPath
;
const
bool
mDatabaseWasNotAvailable
;
bool
mHasCreatedDatabase
;
bool
mFlushScheduled
;
#
ifdef
DEBUG
bool
mInUpdateBatch
;
bool
mFinished
;
#
endif
public
:
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
Connection
)
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
Connection
)
;
}
QuotaClient
*
GetQuotaClient
(
)
const
{
MOZ_ASSERT
(
mQuotaClient
)
;
return
mQuotaClient
;
}
ArchivedOriginScope
*
GetArchivedOriginScope
(
)
const
{
return
mArchivedOriginScope
.
get
(
)
;
}
const
nsCString
&
Origin
(
)
const
{
return
mQuotaInfo
.
mOrigin
;
}
const
nsString
&
DirectoryPath
(
)
const
{
return
mDirectoryPath
;
}
void
GetFinishInfo
(
bool
&
aDatabaseWasNotAvailable
bool
&
aHasCreatedDatabase
)
const
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mFinished
)
;
aDatabaseWasNotAvailable
=
mDatabaseWasNotAvailable
;
aHasCreatedDatabase
=
mHasCreatedDatabase
;
}
void
Dispatch
(
ConnectionDatastoreOperationBase
*
aOp
)
;
void
Close
(
nsIRunnable
*
aCallback
)
;
void
SetItem
(
const
nsString
&
aKey
const
LSValue
&
aValue
int64_t
aDelta
bool
aIsNewItem
)
;
void
RemoveItem
(
const
nsString
&
aKey
int64_t
aDelta
)
;
void
Clear
(
int64_t
aDelta
)
;
void
BeginUpdateBatch
(
)
;
void
EndUpdateBatch
(
)
;
nsresult
EnsureStorageConnection
(
)
;
mozIStorageConnection
*
StorageConnection
(
)
const
{
AssertIsOnConnectionThread
(
)
;
return
mStorageConnection
;
}
void
CloseStorageConnection
(
)
;
nsresult
GetCachedStatement
(
const
nsACString
&
aQuery
CachedStatement
*
aCachedStatement
)
;
nsresult
BeginWriteTransaction
(
)
;
nsresult
CommitWriteTransaction
(
)
;
nsresult
RollbackWriteTransaction
(
)
;
private
:
Connection
(
ConnectionThread
*
aConnectionThread
const
QuotaInfo
&
aQuotaInfo
UniquePtr
<
ArchivedOriginScope
>
&
&
aArchivedOriginScope
bool
aDatabaseWasNotAvailable
)
;
~
Connection
(
)
;
void
ScheduleFlush
(
)
;
void
Flush
(
)
;
static
void
FlushTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
}
;
class
Connection
:
:
CachedStatement
final
{
friend
class
Connection
;
nsCOMPtr
<
mozIStorageStatement
>
mStatement
;
Maybe
<
mozStorageStatementScoper
>
mScoper
;
public
:
CachedStatement
(
)
;
~
CachedStatement
(
)
;
operator
mozIStorageStatement
*
(
)
const
;
mozIStorageStatement
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
;
private
:
void
Assign
(
Connection
*
aConnection
already_AddRefed
<
mozIStorageStatement
>
aStatement
)
;
CachedStatement
(
const
CachedStatement
&
)
=
delete
;
CachedStatement
&
operator
=
(
const
CachedStatement
&
)
=
delete
;
}
;
class
Connection
:
:
InitStorageAndOriginHelper
final
:
public
Runnable
{
mozilla
:
:
Monitor
mMonitor
;
const
QuotaInfo
mQuotaInfo
;
nsString
mOriginDirectoryPath
;
nsresult
mIOThreadResultCode
;
bool
mWaiting
;
public
:
explicit
InitStorageAndOriginHelper
(
const
QuotaInfo
&
aQuotaInfo
)
:
Runnable
(
"
dom
:
:
localstorage
:
:
Connection
:
:
InitStorageAndOriginHelper
"
)
mMonitor
(
"
InitStorageAndOriginHelper
:
:
mMonitor
"
)
mQuotaInfo
(
aQuotaInfo
)
mIOThreadResultCode
(
NS_OK
)
mWaiting
(
true
)
{
AssertIsOnConnectionThread
(
)
;
}
nsresult
BlockAndReturnOriginDirectoryPath
(
nsAString
&
aOriginDirectoryPath
)
;
private
:
~
InitStorageAndOriginHelper
(
)
=
default
;
nsresult
RunOnIOThread
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
Connection
:
:
FlushOp
final
:
public
ConnectionDatastoreOperationBase
{
ConnectionWriteOptimizer
mWriteOptimizer
;
bool
mShadowWrites
;
public
:
FlushOp
(
Connection
*
aConnection
ConnectionWriteOptimizer
&
&
aWriteOptimizer
)
;
private
:
nsresult
DoDatastoreWork
(
)
override
;
void
Cleanup
(
)
override
;
}
;
class
Connection
:
:
CloseOp
final
:
public
ConnectionDatastoreOperationBase
{
nsCOMPtr
<
nsIRunnable
>
mCallback
;
public
:
CloseOp
(
Connection
*
aConnection
nsIRunnable
*
aCallback
)
:
ConnectionDatastoreOperationBase
(
aConnection
false
)
mCallback
(
aCallback
)
{
}
private
:
nsresult
DoDatastoreWork
(
)
override
;
void
Cleanup
(
)
override
;
}
;
class
ConnectionThread
final
{
friend
class
Connection
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsRefPtrHashtable
<
nsCStringHashKey
Connection
>
mConnections
;
public
:
ConnectionThread
(
)
;
void
AssertIsOnOwningThread
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
ConnectionThread
)
;
}
bool
IsOnConnectionThread
(
)
;
void
AssertIsOnConnectionThread
(
)
;
already_AddRefed
<
Connection
>
CreateConnection
(
const
QuotaInfo
&
aQuotaInfo
UniquePtr
<
ArchivedOriginScope
>
&
&
aArchivedOriginScope
bool
aDatabaseWasNotAvailable
)
;
void
Shutdown
(
)
;
NS_INLINE_DECL_REFCOUNTING
(
ConnectionThread
)
private
:
~
ConnectionThread
(
)
;
}
;
class
Datastore
final
:
public
SupportsCheckedUnsafePtr
<
CheckIf
<
DiagnosticAssertEnabled
>
>
{
RefPtr
<
DirectoryLock
>
mDirectoryLock
;
RefPtr
<
Connection
>
mConnection
;
RefPtr
<
QuotaObject
>
mQuotaObject
;
nsCOMPtr
<
nsIRunnable
>
mCompleteCallback
;
nsTHashtable
<
nsPtrHashKey
<
PrepareDatastoreOp
>
>
mPrepareDatastoreOps
;
nsTHashtable
<
nsPtrHashKey
<
PreparedDatastore
>
>
mPreparedDatastores
;
nsTHashtable
<
nsPtrHashKey
<
Database
>
>
mDatabases
;
nsTHashtable
<
nsPtrHashKey
<
Database
>
>
mActiveDatabases
;
nsDataHashtable
<
nsStringHashKey
LSValue
>
mValues
;
nsTArray
<
LSItemInfo
>
mOrderedItems
;
nsTArray
<
int64_t
>
mPendingUsageDeltas
;
DatastoreWriteOptimizer
mWriteOptimizer
;
const
GroupAndOrigin
mGroupAndOrigin
;
const
uint32_t
mPrivateBrowsingId
;
int64_t
mUsage
;
int64_t
mUpdateBatchUsage
;
int64_t
mSizeOfKeys
;
int64_t
mSizeOfItems
;
bool
mClosed
;
bool
mInUpdateBatch
;
bool
mHasLivePrivateDatastore
;
public
:
Datastore
(
const
GroupAndOrigin
&
aGroupAndOrigin
uint32_t
aPrivateBrowsingId
int64_t
aUsage
int64_t
aSizeOfKeys
int64_t
aSizeOfItems
RefPtr
<
DirectoryLock
>
&
&
aDirectoryLock
RefPtr
<
Connection
>
&
&
aConnection
RefPtr
<
QuotaObject
>
&
&
aQuotaObject
nsDataHashtable
<
nsStringHashKey
LSValue
>
&
aValues
nsTArray
<
LSItemInfo
>
&
&
aOrderedItems
)
;
const
nsCString
&
Origin
(
)
const
{
return
mGroupAndOrigin
.
mOrigin
;
}
uint32_t
PrivateBrowsingId
(
)
const
{
return
mPrivateBrowsingId
;
}
bool
IsPersistent
(
)
const
{
return
mPrivateBrowsingId
=
=
0
;
}
void
Close
(
)
;
bool
IsClosed
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mClosed
;
}
void
WaitForConnectionToComplete
(
nsIRunnable
*
aCallback
)
;
void
NoteLivePrepareDatastoreOp
(
PrepareDatastoreOp
*
aPrepareDatastoreOp
)
;
void
NoteFinishedPrepareDatastoreOp
(
PrepareDatastoreOp
*
aPrepareDatastoreOp
)
;
void
NoteLivePrivateDatastore
(
)
;
void
NoteFinishedPrivateDatastore
(
)
;
void
NoteLivePreparedDatastore
(
PreparedDatastore
*
aPreparedDatastore
)
;
void
NoteFinishedPreparedDatastore
(
PreparedDatastore
*
aPreparedDatastore
)
;
void
NoteLiveDatabase
(
Database
*
aDatabase
)
;
void
NoteFinishedDatabase
(
Database
*
aDatabase
)
;
void
NoteActiveDatabase
(
Database
*
aDatabase
)
;
void
NoteInactiveDatabase
(
Database
*
aDatabase
)
;
void
GetSnapshotLoadInfo
(
const
nsString
&
aKey
bool
&
aAddKeyToUnknownItems
nsTHashtable
<
nsStringHashKey
>
&
aLoadedItems
nsTArray
<
LSItemInfo
>
&
aItemInfos
uint32_t
&
aNextLoadIndex
LSSnapshot
:
:
LoadState
&
aLoadState
)
;
uint32_t
GetLength
(
)
const
{
return
mValues
.
Count
(
)
;
}
const
nsTArray
<
LSItemInfo
>
&
GetOrderedItems
(
)
const
{
return
mOrderedItems
;
}
void
GetItem
(
const
nsString
&
aKey
LSValue
&
aValue
)
const
;
void
GetKeys
(
nsTArray
<
nsString
>
&
aKeys
)
const
;
void
SetItem
(
Database
*
aDatabase
const
nsString
&
aKey
const
LSValue
&
aValue
)
;
void
RemoveItem
(
Database
*
aDatabase
const
nsString
&
aKey
)
;
void
Clear
(
Database
*
aDatabase
)
;
void
BeginUpdateBatch
(
int64_t
aSnapshotInitialUsage
)
;
int64_t
EndUpdateBatch
(
int64_t
aSnapshotPeakUsage
)
;
int64_t
GetUsage
(
)
const
{
return
mUsage
;
}
int64_t
RequestUpdateUsage
(
int64_t
aRequestedSize
int64_t
aMinSize
)
;
bool
HasOtherProcessObservers
(
Database
*
aDatabase
)
;
void
NotifyOtherProcessObservers
(
Database
*
aDatabase
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
LSValue
&
aOldValue
const
LSValue
&
aNewValue
)
;
void
NoteChangedObserverArray
(
const
nsTArray
<
Observer
*
>
&
aObservers
)
;
void
Stringify
(
nsACString
&
aResult
)
const
;
NS_INLINE_DECL_REFCOUNTING
(
Datastore
)
private
:
~
Datastore
(
)
;
bool
UpdateUsage
(
int64_t
aDelta
)
;
void
MaybeClose
(
)
;
void
ConnectionClosedCallback
(
)
;
void
CleanupMetadata
(
)
;
void
NotifySnapshots
(
Database
*
aDatabase
const
nsAString
&
aKey
const
LSValue
&
aOldValue
bool
aAffectsOrder
)
;
}
;
class
PrivateDatastore
{
const
NotNull
<
RefPtr
<
Datastore
>
>
mDatastore
;
public
:
explicit
PrivateDatastore
(
MovingNotNull
<
RefPtr
<
Datastore
>
>
aDatastore
)
:
mDatastore
(
std
:
:
move
(
aDatastore
)
)
{
AssertIsOnBackgroundThread
(
)
;
mDatastore
-
>
NoteLivePrivateDatastore
(
)
;
}
~
PrivateDatastore
(
)
{
mDatastore
-
>
NoteFinishedPrivateDatastore
(
)
;
}
}
;
class
PreparedDatastore
{
RefPtr
<
Datastore
>
mDatastore
;
nsCOMPtr
<
nsITimer
>
mTimer
;
const
Maybe
<
ContentParentId
>
mContentParentId
;
const
nsCString
mOrigin
;
uint64_t
mDatastoreId
;
bool
mForPreload
;
bool
mInvalidated
;
public
:
PreparedDatastore
(
Datastore
*
aDatastore
const
Maybe
<
ContentParentId
>
&
aContentParentId
const
nsACString
&
aOrigin
uint64_t
aDatastoreId
bool
aForPreload
)
:
mDatastore
(
aDatastore
)
mTimer
(
NS_NewTimer
(
)
)
mContentParentId
(
aContentParentId
)
mOrigin
(
aOrigin
)
mDatastoreId
(
aDatastoreId
)
mForPreload
(
aForPreload
)
mInvalidated
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatastore
)
;
MOZ_ASSERT
(
mTimer
)
;
aDatastore
-
>
NoteLivePreparedDatastore
(
this
)
;
MOZ_ALWAYS_SUCCEEDS
(
mTimer
-
>
InitWithNamedFuncCallback
(
TimerCallback
this
kPreparedDatastoreTimeoutMs
nsITimer
:
:
TYPE_ONE_SHOT
"
PreparedDatastore
:
:
TimerCallback
"
)
)
;
}
~
PreparedDatastore
(
)
{
MOZ_ASSERT
(
mDatastore
)
;
MOZ_ASSERT
(
mTimer
)
;
mTimer
-
>
Cancel
(
)
;
mDatastore
-
>
NoteFinishedPreparedDatastore
(
this
)
;
}
Datastore
*
GetDatastore
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mDatastore
)
;
return
mDatastore
;
}
const
Maybe
<
ContentParentId
>
&
GetContentParentId
(
)
const
{
return
mContentParentId
;
}
const
nsCString
&
Origin
(
)
const
{
return
mOrigin
;
}
void
Invalidate
(
)
{
AssertIsOnBackgroundThread
(
)
;
mInvalidated
=
true
;
if
(
mForPreload
)
{
mTimer
-
>
Cancel
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
mTimer
-
>
InitWithNamedFuncCallback
(
TimerCallback
this
0
nsITimer
:
:
TYPE_ONE_SHOT
"
PreparedDatastore
:
:
TimerCallback
"
)
)
;
}
}
bool
IsInvalidated
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mInvalidated
;
}
private
:
void
Destroy
(
)
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
}
;
class
Database
final
:
public
PBackgroundLSDatabaseParent
public
SupportsCheckedUnsafePtr
<
CheckIf
<
DiagnosticAssertEnabled
>
>
{
RefPtr
<
Datastore
>
mDatastore
;
Snapshot
*
mSnapshot
;
const
PrincipalInfo
mPrincipalInfo
;
const
Maybe
<
ContentParentId
>
mContentParentId
;
nsCString
mOrigin
;
uint32_t
mPrivateBrowsingId
;
bool
mAllowedToClose
;
bool
mActorDestroyed
;
bool
mRequestedAllowToClose
;
#
ifdef
DEBUG
bool
mActorWasAlive
;
#
endif
public
:
Database
(
const
PrincipalInfo
&
aPrincipalInfo
const
Maybe
<
ContentParentId
>
&
aContentParentId
const
nsACString
&
aOrigin
uint32_t
aPrivateBrowsingId
)
;
Datastore
*
GetDatastore
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mDatastore
;
}
const
PrincipalInfo
&
GetPrincipalInfo
(
)
const
{
return
mPrincipalInfo
;
}
bool
IsOwnedByProcess
(
ContentParentId
aContentParentId
)
const
{
return
mContentParentId
&
&
mContentParentId
.
value
(
)
=
=
aContentParentId
;
}
uint32_t
PrivateBrowsingId
(
)
const
{
return
mPrivateBrowsingId
;
}
const
nsCString
&
Origin
(
)
const
{
return
mOrigin
;
}
void
SetActorAlive
(
Datastore
*
aDatastore
)
;
void
RegisterSnapshot
(
Snapshot
*
aSnapshot
)
;
void
UnregisterSnapshot
(
Snapshot
*
aSnapshot
)
;
Snapshot
*
GetSnapshot
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mSnapshot
;
}
void
RequestAllowToClose
(
)
;
void
ForceKill
(
)
;
void
Stringify
(
nsACString
&
aResult
)
const
;
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
Database
)
private
:
~
Database
(
)
;
void
AllowToClose
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDeleteMe
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvAllowToClose
(
)
override
;
PBackgroundLSSnapshotParent
*
AllocPBackgroundLSSnapshotParent
(
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
bool
&
aIncreasePeakUsage
const
int64_t
&
aRequestedSize
const
int64_t
&
aMinSize
LSSnapshotInitInfo
*
aInitInfo
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPBackgroundLSSnapshotConstructor
(
PBackgroundLSSnapshotParent
*
aActor
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
bool
&
aIncreasePeakUsage
const
int64_t
&
aRequestedSize
const
int64_t
&
aMinSize
LSSnapshotInitInfo
*
aInitInfo
)
override
;
bool
DeallocPBackgroundLSSnapshotParent
(
PBackgroundLSSnapshotParent
*
aActor
)
override
;
}
;
class
Snapshot
final
:
public
PBackgroundLSSnapshotParent
{
RefPtr
<
Database
>
mDatabase
;
RefPtr
<
Datastore
>
mDatastore
;
nsTHashtable
<
nsStringHashKey
>
mLoadedItems
;
nsTHashtable
<
nsStringHashKey
>
mUnknownItems
;
nsDataHashtable
<
nsStringHashKey
LSValue
>
mValues
;
nsTArray
<
nsString
>
mKeys
;
nsString
mDocumentURI
;
uint32_t
mNextLoadIndex
;
uint32_t
mTotalLength
;
int64_t
mUsage
;
int64_t
mPeakUsage
;
bool
mSavedKeys
;
bool
mActorDestroyed
;
bool
mFinishReceived
;
bool
mLoadedReceived
;
bool
mLoadedAllItems
;
bool
mLoadKeysReceived
;
bool
mSentMarkDirty
;
bool
mHasOtherProcessObservers
;
public
:
Snapshot
(
Database
*
aDatabase
const
nsAString
&
aDocumentURI
)
;
void
Init
(
nsTHashtable
<
nsStringHashKey
>
&
aLoadedItems
nsTHashtable
<
nsStringHashKey
>
&
aUnknownItems
uint32_t
aNextLoadIndex
uint32_t
aTotalLength
int64_t
aInitialUsage
int64_t
aPeakUsage
LSSnapshot
:
:
LoadState
aLoadState
bool
aHasOtherProcessObservers
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aInitialUsage
>
=
0
)
;
MOZ_ASSERT
(
aPeakUsage
>
=
aInitialUsage
)
;
MOZ_ASSERT_IF
(
aLoadState
!
=
LSSnapshot
:
:
LoadState
:
:
AllOrderedItems
aNextLoadIndex
<
aTotalLength
)
;
MOZ_ASSERT
(
mTotalLength
=
=
0
)
;
MOZ_ASSERT
(
mUsage
=
=
-
1
)
;
MOZ_ASSERT
(
mPeakUsage
=
=
-
1
)
;
mLoadedItems
.
SwapElements
(
aLoadedItems
)
;
mUnknownItems
.
SwapElements
(
aUnknownItems
)
;
mNextLoadIndex
=
aNextLoadIndex
;
mTotalLength
=
aTotalLength
;
mUsage
=
aInitialUsage
;
mPeakUsage
=
aPeakUsage
;
if
(
aLoadState
=
=
LSSnapshot
:
:
LoadState
:
:
AllOrderedKeys
)
{
MOZ_ASSERT
(
mUnknownItems
.
Count
(
)
=
=
0
)
;
mLoadKeysReceived
=
true
;
}
else
if
(
aLoadState
=
=
LSSnapshot
:
:
LoadState
:
:
AllOrderedItems
)
{
MOZ_ASSERT
(
mLoadedItems
.
Count
(
)
=
=
0
)
;
MOZ_ASSERT
(
mUnknownItems
.
Count
(
)
=
=
0
)
;
MOZ_ASSERT
(
mNextLoadIndex
=
=
mTotalLength
)
;
mLoadedReceived
=
true
;
mLoadedAllItems
=
true
;
mLoadKeysReceived
=
true
;
}
mHasOtherProcessObservers
=
aHasOtherProcessObservers
;
}
void
SaveItem
(
const
nsAString
&
aKey
const
LSValue
&
aOldValue
bool
aAffectsOrder
)
;
void
MarkDirty
(
)
;
bool
IsDirty
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mSentMarkDirty
;
}
bool
HasOtherProcessObservers
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mHasOtherProcessObservers
;
}
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
Snapshot
)
private
:
~
Snapshot
(
)
;
void
Finish
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDeleteMe
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCheckpoint
(
nsTArray
<
LSWriteInfo
>
&
&
aWriteInfos
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCheckpointAndNotify
(
nsTArray
<
LSWriteAndNotifyInfo
>
&
&
aWriteAndNotifyInfos
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFinish
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLoaded
(
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLoadValueAndMoreItems
(
const
nsString
&
aKey
LSValue
*
aValue
nsTArray
<
LSItemInfo
>
*
aItemInfos
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvLoadKeys
(
nsTArray
<
nsString
>
*
aKeys
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvIncreasePeakUsage
(
const
int64_t
&
aRequestedSize
const
int64_t
&
aMinSize
int64_t
*
aSize
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvPing
(
)
override
;
}
;
class
Observer
final
:
public
PBackgroundLSObserverParent
{
nsCString
mOrigin
;
bool
mActorDestroyed
;
public
:
explicit
Observer
(
const
nsACString
&
aOrigin
)
;
const
nsCString
&
Origin
(
)
const
{
return
mOrigin
;
}
void
Observe
(
Database
*
aDatabase
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
LSValue
&
aOldValue
const
LSValue
&
aNewValue
)
;
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
Observer
)
private
:
~
Observer
(
)
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
mozilla
:
:
ipc
:
:
IPCResult
RecvDeleteMe
(
)
override
;
}
;
class
LSRequestBase
:
public
DatastoreOperationBase
public
PBackgroundLSRequestParent
{
protected
:
enum
class
State
{
Initial
StartingRequest
Nesting
SendingReadyMessage
WaitingForFinish
SendingResults
Completed
}
;
nsCOMPtr
<
nsIEventTarget
>
mMainEventTarget
;
const
LSRequestParams
mParams
;
Maybe
<
ContentParentId
>
mContentParentId
;
State
mState
;
bool
mWaitingForFinish
;
public
:
LSRequestBase
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
;
void
Dispatch
(
)
;
void
StringifyState
(
nsACString
&
aResult
)
const
;
virtual
void
Stringify
(
nsACString
&
aResult
)
const
;
virtual
void
Log
(
)
;
protected
:
~
LSRequestBase
(
)
override
;
virtual
nsresult
Start
(
)
=
0
;
virtual
nsresult
NestedRun
(
)
;
virtual
void
GetResponse
(
LSRequestResponse
&
aResponse
)
=
0
;
virtual
void
Cleanup
(
)
{
}
private
:
bool
VerifyRequestParams
(
)
;
nsresult
StartRequest
(
)
;
void
SendReadyMessage
(
)
;
nsresult
SendReadyMessageInternal
(
)
;
void
Finish
(
)
;
void
FinishInternal
(
)
;
void
SendResults
(
)
;
protected
:
NS_IMETHOD
Run
(
)
final
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
private
:
mozilla
:
:
ipc
:
:
IPCResult
RecvCancel
(
)
final
;
mozilla
:
:
ipc
:
:
IPCResult
RecvFinish
(
)
final
;
}
;
class
PrepareDatastoreOp
:
public
LSRequestBase
public
OpenDirectoryListener
public
SupportsCheckedUnsafePtr
<
CheckIf
<
DiagnosticAssertEnabled
>
>
{
class
LoadDataOp
;
class
CompressFunction
;
class
CompressibleFunction
;
enum
class
NestedState
{
BeforeNesting
CheckExistingOperations
CheckClosingDatastore
PreparationPending
QuotaManagerPending
DirectoryOpenPending
DatabaseWorkOpen
BeginLoadData
DatabaseWorkLoadData
AfterNesting
}
;
nsCOMPtr
<
nsIEventTarget
>
mMainEventTarget
;
RefPtr
<
PrepareDatastoreOp
>
mDelayedOp
;
RefPtr
<
DirectoryLock
>
mPendingDirectoryLock
;
RefPtr
<
DirectoryLock
>
mDirectoryLock
;
RefPtr
<
Connection
>
mConnection
;
RefPtr
<
Datastore
>
mDatastore
;
UniquePtr
<
ArchivedOriginScope
>
mArchivedOriginScope
;
LoadDataOp
*
mLoadDataOp
;
nsDataHashtable
<
nsStringHashKey
LSValue
>
mValues
;
nsTArray
<
LSItemInfo
>
mOrderedItems
;
QuotaInfo
mQuotaInfo
;
nsCString
mMainThreadOrigin
;
nsString
mDatabaseFilePath
;
uint32_t
mPrivateBrowsingId
;
int64_t
mUsage
;
int64_t
mSizeOfKeys
;
int64_t
mSizeOfItems
;
uint64_t
mDatastoreId
;
NestedState
mNestedState
;
const
bool
mForPreload
;
bool
mDatabaseNotAvailable
;
bool
mRequestedDirectoryLock
;
FlippedOnce
<
false
>
mPrivateDatastoreRegistered
;
FlippedOnce
<
false
>
mPreparedDatastoreRegistered
;
bool
mInvalidated
;
#
ifdef
DEBUG
int64_t
mDEBUGUsage
;
#
endif
public
:
PrepareDatastoreOp
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
;
bool
OriginIsKnown
(
)
const
{
MOZ_ASSERT
(
IsOnOwningThread
(
)
|
|
IsOnIOThread
(
)
)
;
return
!
mQuotaInfo
.
mOrigin
.
IsEmpty
(
)
;
}
const
nsCString
&
Origin
(
)
const
{
MOZ_ASSERT
(
IsOnOwningThread
(
)
|
|
IsOnIOThread
(
)
)
;
MOZ_ASSERT
(
OriginIsKnown
(
)
)
;
return
mQuotaInfo
.
mOrigin
;
}
bool
RequestedDirectoryLock
(
)
const
{
AssertIsOnOwningThread
(
)
;
return
mRequestedDirectoryLock
;
}
void
Invalidate
(
)
{
AssertIsOnOwningThread
(
)
;
mInvalidated
=
true
;
}
void
StringifyNestedState
(
nsACString
&
aResult
)
const
;
void
Stringify
(
nsACString
&
aResult
)
const
override
;
void
Log
(
)
override
;
private
:
~
PrepareDatastoreOp
(
)
override
;
nsresult
Start
(
)
override
;
nsresult
CheckExistingOperations
(
)
;
nsresult
CheckClosingDatastoreInternal
(
)
;
nsresult
CheckClosingDatastore
(
)
;
nsresult
BeginDatastorePreparationInternal
(
)
;
nsresult
BeginDatastorePreparation
(
)
;
nsresult
QuotaManagerOpen
(
)
;
nsresult
OpenDirectory
(
)
;
void
SendToIOThread
(
)
;
nsresult
DatabaseWork
(
)
;
nsresult
DatabaseNotAvailable
(
)
;
nsresult
EnsureDirectoryEntry
(
nsIFile
*
aEntry
bool
aCreateIfNotExists
bool
aDirectory
bool
*
aAlreadyExisted
=
nullptr
)
;
nsresult
VerifyDatabaseInformation
(
mozIStorageConnection
*
aConnection
)
;
already_AddRefed
<
QuotaObject
>
GetQuotaObject
(
)
;
nsresult
BeginLoadData
(
)
;
void
FinishNesting
(
)
;
nsresult
FinishNestingOnNonOwningThread
(
)
;
nsresult
NestedRun
(
)
override
;
void
GetResponse
(
LSRequestResponse
&
aResponse
)
override
;
void
Cleanup
(
)
override
;
void
ConnectionClosedCallback
(
)
;
void
CleanupMetadata
(
)
;
NS_DECL_ISUPPORTS_INHERITED
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
void
DirectoryLockAcquired
(
DirectoryLock
*
aLock
)
override
;
void
DirectoryLockFailed
(
)
override
;
}
;
class
PrepareDatastoreOp
:
:
LoadDataOp
final
:
public
ConnectionDatastoreOperationBase
{
RefPtr
<
PrepareDatastoreOp
>
mPrepareDatastoreOp
;
public
:
explicit
LoadDataOp
(
PrepareDatastoreOp
*
aPrepareDatastoreOp
)
:
ConnectionDatastoreOperationBase
(
aPrepareDatastoreOp
-
>
mConnection
)
mPrepareDatastoreOp
(
aPrepareDatastoreOp
)
{
}
private
:
~
LoadDataOp
(
)
=
default
;
nsresult
DoDatastoreWork
(
)
override
;
void
OnSuccess
(
)
override
;
void
OnFailure
(
nsresult
aResultCode
)
override
;
void
Cleanup
(
)
override
;
}
;
class
PrepareDatastoreOp
:
:
CompressFunction
final
:
public
mozIStorageFunction
{
private
:
~
CompressFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
class
PrepareDatastoreOp
:
:
CompressibleFunction
final
:
public
mozIStorageFunction
{
private
:
~
CompressibleFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
class
PrepareObserverOp
:
public
LSRequestBase
{
nsCString
mOrigin
;
public
:
PrepareObserverOp
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
;
private
:
nsresult
Start
(
)
override
;
void
GetResponse
(
LSRequestResponse
&
aResponse
)
override
;
}
;
class
LSSimpleRequestBase
:
public
DatastoreOperationBase
public
PBackgroundLSSimpleRequestParent
{
protected
:
enum
class
State
{
Initial
StartingRequest
SendingResults
Completed
}
;
const
LSSimpleRequestParams
mParams
;
Maybe
<
ContentParentId
>
mContentParentId
;
State
mState
;
public
:
LSSimpleRequestBase
(
const
LSSimpleRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
;
void
Dispatch
(
)
;
protected
:
~
LSSimpleRequestBase
(
)
override
;
virtual
nsresult
Start
(
)
=
0
;
virtual
void
GetResponse
(
LSSimpleRequestResponse
&
aResponse
)
=
0
;
private
:
bool
VerifyRequestParams
(
)
;
nsresult
StartRequest
(
)
;
void
SendResults
(
)
;
NS_IMETHOD
Run
(
)
final
;
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
class
PreloadedOp
:
public
LSSimpleRequestBase
{
nsCString
mOrigin
;
public
:
PreloadedOp
(
const
LSSimpleRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
;
private
:
nsresult
Start
(
)
override
;
void
GetResponse
(
LSSimpleRequestResponse
&
aResponse
)
override
;
}
;
struct
ArchivedOriginInfo
{
OriginAttributes
mOriginAttributes
;
nsCString
mOriginNoSuffix
;
ArchivedOriginInfo
(
const
OriginAttributes
&
aOriginAttributes
const
nsACString
&
aOriginNoSuffix
)
:
mOriginAttributes
(
aOriginAttributes
)
mOriginNoSuffix
(
aOriginNoSuffix
)
{
}
}
;
class
ArchivedOriginScope
{
struct
Origin
{
nsCString
mOriginSuffix
;
nsCString
mOriginNoSuffix
;
Origin
(
const
nsACString
&
aOriginSuffix
const
nsACString
&
aOriginNoSuffix
)
:
mOriginSuffix
(
aOriginSuffix
)
mOriginNoSuffix
(
aOriginNoSuffix
)
{
}
const
nsACString
&
OriginSuffix
(
)
const
{
return
mOriginSuffix
;
}
const
nsACString
&
OriginNoSuffix
(
)
const
{
return
mOriginNoSuffix
;
}
}
;
struct
Prefix
{
nsCString
mOriginNoSuffix
;
explicit
Prefix
(
const
nsACString
&
aOriginNoSuffix
)
:
mOriginNoSuffix
(
aOriginNoSuffix
)
{
}
const
nsACString
&
OriginNoSuffix
(
)
const
{
return
mOriginNoSuffix
;
}
}
;
struct
Pattern
{
UniquePtr
<
OriginAttributesPattern
>
mPattern
;
explicit
Pattern
(
const
OriginAttributesPattern
&
aPattern
)
:
mPattern
(
MakeUnique
<
OriginAttributesPattern
>
(
aPattern
)
)
{
}
Pattern
(
const
Pattern
&
aOther
)
:
mPattern
(
MakeUnique
<
OriginAttributesPattern
>
(
*
aOther
.
mPattern
)
)
{
}
Pattern
(
Pattern
&
&
aOther
)
=
default
;
const
OriginAttributesPattern
&
GetPattern
(
)
const
{
MOZ_ASSERT
(
mPattern
)
;
return
*
mPattern
;
}
}
;
struct
Null
{
}
;
using
DataType
=
Variant
<
Origin
Pattern
Prefix
Null
>
;
DataType
mData
;
public
:
static
UniquePtr
<
ArchivedOriginScope
>
CreateFromOrigin
(
const
nsACString
&
aOriginAttrSuffix
const
nsACString
&
aOriginKey
)
;
static
UniquePtr
<
ArchivedOriginScope
>
CreateFromPrefix
(
const
nsACString
&
aOriginKey
)
;
static
UniquePtr
<
ArchivedOriginScope
>
CreateFromPattern
(
const
OriginAttributesPattern
&
aPattern
)
;
static
UniquePtr
<
ArchivedOriginScope
>
CreateFromNull
(
)
;
bool
IsOrigin
(
)
const
{
return
mData
.
is
<
Origin
>
(
)
;
}
bool
IsPrefix
(
)
const
{
return
mData
.
is
<
Prefix
>
(
)
;
}
bool
IsPattern
(
)
const
{
return
mData
.
is
<
Pattern
>
(
)
;
}
bool
IsNull
(
)
const
{
return
mData
.
is
<
Null
>
(
)
;
}
const
nsACString
&
OriginSuffix
(
)
const
{
MOZ_ASSERT
(
IsOrigin
(
)
)
;
return
mData
.
as
<
Origin
>
(
)
.
OriginSuffix
(
)
;
}
const
nsACString
&
OriginNoSuffix
(
)
const
{
MOZ_ASSERT
(
IsOrigin
(
)
|
|
IsPrefix
(
)
)
;
if
(
IsOrigin
(
)
)
{
return
mData
.
as
<
Origin
>
(
)
.
OriginNoSuffix
(
)
;
}
return
mData
.
as
<
Prefix
>
(
)
.
OriginNoSuffix
(
)
;
}
const
OriginAttributesPattern
&
GetPattern
(
)
const
{
MOZ_ASSERT
(
IsPattern
(
)
)
;
return
mData
.
as
<
Pattern
>
(
)
.
GetPattern
(
)
;
}
void
GetBindingClause
(
nsACString
&
aBindingClause
)
const
;
nsresult
BindToStatement
(
mozIStorageStatement
*
aStatement
)
const
;
bool
HasMatches
(
ArchivedOriginHashtable
*
aHashtable
)
const
;
void
RemoveMatches
(
ArchivedOriginHashtable
*
aHashtable
)
const
;
private
:
explicit
ArchivedOriginScope
(
const
Origin
&
&
aOrigin
)
:
mData
(
aOrigin
)
{
}
explicit
ArchivedOriginScope
(
const
Pattern
&
&
aPattern
)
:
mData
(
aPattern
)
{
}
explicit
ArchivedOriginScope
(
const
Prefix
&
&
aPrefix
)
:
mData
(
aPrefix
)
{
}
explicit
ArchivedOriginScope
(
const
Null
&
&
aNull
)
:
mData
(
aNull
)
{
}
}
;
class
QuotaClient
final
:
public
mozilla
:
:
dom
:
:
quota
:
:
Client
{
class
Observer
;
class
MatchFunction
;
static
QuotaClient
*
sInstance
;
Mutex
mShadowDatabaseMutex
;
bool
mShutdownRequested
;
public
:
QuotaClient
(
)
;
static
nsresult
Initialize
(
)
;
static
QuotaClient
*
GetInstance
(
)
{
AssertIsOnBackgroundThread
(
)
;
return
sInstance
;
}
static
bool
IsShuttingDownOnBackgroundThread
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
sInstance
)
{
return
sInstance
-
>
IsShuttingDown
(
)
;
}
return
QuotaManager
:
:
IsShuttingDown
(
)
;
}
static
bool
IsShuttingDownOnNonBackgroundThread
(
)
{
MOZ_ASSERT
(
!
IsOnBackgroundThread
(
)
)
;
return
QuotaManager
:
:
IsShuttingDown
(
)
;
}
mozilla
:
:
Mutex
&
ShadowDatabaseMutex
(
)
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
return
mShadowDatabaseMutex
;
}
bool
IsShuttingDown
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mShutdownRequested
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
mozilla
:
:
dom
:
:
QuotaClient
override
)
Type
GetType
(
)
override
;
Result
<
UsageInfo
nsresult
>
InitOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
override
;
nsresult
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
override
;
Result
<
UsageInfo
nsresult
>
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
override
;
nsresult
AboutToClearOrigins
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
)
override
;
void
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
override
;
void
ReleaseIOThreadObjects
(
)
override
;
void
AbortOperations
(
const
nsACString
&
aOrigin
)
override
;
void
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
override
;
void
StartIdleMaintenance
(
)
override
;
void
StopIdleMaintenance
(
)
override
;
void
ShutdownWorkThreads
(
)
override
;
private
:
~
QuotaClient
(
)
override
;
void
ShutdownTimedOut
(
)
;
nsresult
CreateArchivedOriginScope
(
const
OriginScope
&
aOriginScope
UniquePtr
<
ArchivedOriginScope
>
&
aArchivedOriginScope
)
;
nsresult
PerformDelete
(
mozIStorageConnection
*
aConnection
const
nsACString
&
aSchemaName
ArchivedOriginScope
*
aArchivedOriginScope
)
const
;
}
;
class
QuotaClient
:
:
Observer
final
:
public
nsIObserver
{
public
:
static
nsresult
Initialize
(
)
;
private
:
Observer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
~
Observer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
nsresult
Init
(
)
;
nsresult
Shutdown
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
class
QuotaClient
:
:
MatchFunction
final
:
public
mozIStorageFunction
{
OriginAttributesPattern
mPattern
;
public
:
explicit
MatchFunction
(
const
OriginAttributesPattern
&
aPattern
)
:
mPattern
(
aPattern
)
{
}
private
:
~
MatchFunction
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_MOZISTORAGEFUNCTION
}
;
class
MOZ_STACK_CLASS
AutoWriteTransaction
final
{
Connection
*
mConnection
;
Maybe
<
MutexAutoLock
>
mShadowDatabaseLock
;
bool
mShadowWrites
;
public
:
explicit
AutoWriteTransaction
(
bool
aShadowWrites
)
;
~
AutoWriteTransaction
(
)
;
nsresult
Start
(
Connection
*
aConnection
)
;
nsresult
Commit
(
)
;
private
:
nsresult
LockAndAttachShadowDatabase
(
Connection
*
aConnection
)
;
nsresult
DetachShadowDatabaseAndUnlock
(
)
;
}
;
#
ifdef
DEBUG
bool
gLocalStorageInitialized
=
false
;
#
endif
typedef
nsTArray
<
CheckedUnsafePtr
<
PrepareDatastoreOp
>
>
PrepareDatastoreOpArray
;
StaticAutoPtr
<
PrepareDatastoreOpArray
>
gPrepareDatastoreOps
;
class
nsCStringHashKeyDM
:
public
nsCStringHashKey
{
public
:
explicit
nsCStringHashKeyDM
(
const
nsCStringHashKey
:
:
KeyTypePointer
aKey
)
:
nsCStringHashKey
(
aKey
)
{
}
enum
{
ALLOW_MEMMOVE
=
false
}
;
}
;
typedef
std
:
:
conditional
<
DiagnosticAssertEnabled
:
:
value
nsCStringHashKeyDM
nsCStringHashKey
>
:
:
type
DatastoreHashKey
;
typedef
nsDataHashtable
<
DatastoreHashKey
CheckedUnsafePtr
<
Datastore
>
>
DatastoreHashtable
;
StaticAutoPtr
<
DatastoreHashtable
>
gDatastores
;
uint64_t
gLastDatastoreId
=
0
;
typedef
nsClassHashtable
<
nsUint64HashKey
PreparedDatastore
>
PreparedDatastoreHashtable
;
StaticAutoPtr
<
PreparedDatastoreHashtable
>
gPreparedDatastores
;
using
PrivateDatastoreHashtable
=
nsClassHashtable
<
nsCStringHashKey
PrivateDatastore
>
;
UniquePtr
<
PrivateDatastoreHashtable
>
gPrivateDatastores
;
typedef
nsTArray
<
CheckedUnsafePtr
<
Database
>
>
LiveDatabaseArray
;
StaticAutoPtr
<
LiveDatabaseArray
>
gLiveDatabases
;
StaticRefPtr
<
ConnectionThread
>
gConnectionThread
;
uint64_t
gLastObserverId
=
0
;
typedef
nsRefPtrHashtable
<
nsUint64HashKey
Observer
>
PreparedObserverHashtable
;
StaticAutoPtr
<
PreparedObserverHashtable
>
gPreparedObsevers
;
typedef
nsClassHashtable
<
nsCStringHashKey
nsTArray
<
Observer
*
>
>
ObserverHashtable
;
StaticAutoPtr
<
ObserverHashtable
>
gObservers
;
Atomic
<
bool
>
gShadowWrites
(
kDefaultShadowWrites
)
;
Atomic
<
int32_t
Relaxed
>
gSnapshotPrefill
(
kDefaultSnapshotPrefill
)
;
Atomic
<
int32_t
Relaxed
>
gSnapshotGradualPrefill
(
kDefaultSnapshotGradualPrefill
)
;
Atomic
<
bool
>
gClientValidation
(
kDefaultClientValidation
)
;
typedef
nsDataHashtable
<
nsCStringHashKey
int64_t
>
UsageHashtable
;
StaticAutoPtr
<
ArchivedOriginHashtable
>
gArchivedOrigins
;
bool
gInitializedShadowStorage
=
false
;
bool
IsOnConnectionThread
(
)
{
MOZ_ASSERT
(
gConnectionThread
)
;
return
gConnectionThread
-
>
IsOnConnectionThread
(
)
;
}
void
AssertIsOnConnectionThread
(
)
{
MOZ_ASSERT
(
gConnectionThread
)
;
gConnectionThread
-
>
AssertIsOnConnectionThread
(
)
;
}
already_AddRefed
<
Datastore
>
GetDatastore
(
const
nsACString
&
aOrigin
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
gDatastores
)
{
CheckedUnsafePtr
<
Datastore
>
datastore
;
if
(
gDatastores
-
>
Get
(
aOrigin
&
datastore
)
)
{
MOZ_ASSERT
(
datastore
)
;
RefPtr
<
Datastore
>
result
(
datastore
)
;
return
result
.
forget
(
)
;
}
}
return
nullptr
;
}
nsresult
LoadArchivedOrigins
(
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
!
gArchivedOrigins
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
nsresult
rv
=
quotaManager
-
>
EnsureStorageIsInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
rv
=
CreateArchiveStorageConnection
(
quotaManager
-
>
GetStoragePath
(
)
getter_AddRefs
(
connection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
connection
)
{
gArchivedOrigins
=
new
ArchivedOriginHashtable
(
)
;
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
connection
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
DISTINCT
originAttributes
originKey
"
"
FROM
webappsstore2
;
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
auto
archivedOrigins
=
MakeUnique
<
ArchivedOriginHashtable
>
(
)
;
bool
hasResult
;
while
(
NS_SUCCEEDED
(
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
nsCString
originSuffix
;
rv
=
stmt
-
>
GetUTF8String
(
0
originSuffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
originNoSuffix
;
rv
=
stmt
-
>
GetUTF8String
(
1
originNoSuffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
hashKey
=
GetArchivedOriginHashKey
(
originSuffix
originNoSuffix
)
;
OriginAttributes
originAttributes
;
if
(
NS_WARN_IF
(
!
originAttributes
.
PopulateFromSuffix
(
originSuffix
)
)
)
{
return
NS_ERROR_FAILURE
;
}
archivedOrigins
-
>
Put
(
hashKey
MakeUnique
<
ArchivedOriginInfo
>
(
originAttributes
originNoSuffix
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
gArchivedOrigins
=
archivedOrigins
.
release
(
)
;
return
NS_OK
;
}
nsresult
GetUsage
(
mozIStorageConnection
*
aConnection
ArchivedOriginScope
*
aArchivedOriginScope
int64_t
*
aUsage
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
MOZ_ASSERT
(
aUsage
)
;
nsresult
rv
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
if
(
aArchivedOriginScope
)
{
rv
=
aConnection
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
"
"
total
(
utf16Length
(
key
)
+
utf16Length
(
value
)
)
"
"
FROM
webappsstore2
"
"
WHERE
originKey
=
:
originKey
"
"
AND
originAttributes
=
:
originAttributes
;
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aArchivedOriginScope
-
>
BindToStatement
(
stmt
)
;
}
else
{
rv
=
aConnection
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
usage
"
"
FROM
database
"
)
getter_AddRefs
(
stmt
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
hasResult
)
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
usage
;
rv
=
stmt
-
>
GetInt64
(
0
&
usage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aUsage
=
usage
;
return
NS_OK
;
}
void
ShadowWritesPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
strcmp
(
aPrefName
kShadowWritesPref
)
)
;
MOZ_ASSERT
(
!
aClosure
)
;
gShadowWrites
=
Preferences
:
:
GetBool
(
aPrefName
kDefaultShadowWrites
)
;
}
void
SnapshotPrefillPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
strcmp
(
aPrefName
kSnapshotPrefillPref
)
)
;
MOZ_ASSERT
(
!
aClosure
)
;
int32_t
snapshotPrefill
=
Preferences
:
:
GetInt
(
aPrefName
kDefaultSnapshotPrefill
)
;
if
(
snapshotPrefill
=
=
-
1
)
{
snapshotPrefill
=
INT32_MAX
;
}
gSnapshotPrefill
=
snapshotPrefill
;
}
void
SnapshotGradualPrefillPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
strcmp
(
aPrefName
kSnapshotGradualPrefillPref
)
)
;
MOZ_ASSERT
(
!
aClosure
)
;
int32_t
snapshotGradualPrefill
=
Preferences
:
:
GetInt
(
aPrefName
kDefaultSnapshotGradualPrefill
)
;
if
(
snapshotGradualPrefill
=
=
-
1
)
{
snapshotGradualPrefill
=
INT32_MAX
;
}
gSnapshotGradualPrefill
=
snapshotGradualPrefill
;
}
void
ClientValidationPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
strcmp
(
aPrefName
kClientValidationPref
)
)
;
MOZ_ASSERT
(
!
aClosure
)
;
gClientValidation
=
Preferences
:
:
GetBool
(
aPrefName
kDefaultClientValidation
)
;
}
template
<
typename
P
>
void
CollectDatabases
(
P
aPredicate
nsTArray
<
RefPtr
<
Database
>
>
&
aDatabases
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
!
gLiveDatabases
)
{
return
;
}
for
(
const
auto
&
database
:
*
gLiveDatabases
)
{
if
(
aPredicate
(
database
)
)
{
aDatabases
.
AppendElement
(
database
)
;
}
}
}
template
<
typename
P
>
void
RequestAllowToCloseIf
(
P
aPredicate
)
{
AssertIsOnBackgroundThread
(
)
;
nsTArray
<
RefPtr
<
Database
>
>
databases
;
CollectDatabases
(
aPredicate
databases
)
;
for
(
const
auto
&
database
:
databases
)
{
MOZ_ASSERT
(
database
)
;
database
-
>
RequestAllowToClose
(
)
;
}
databases
.
Clear
(
)
;
}
void
ForceKillDatabases
(
)
{
AssertIsOnBackgroundThread
(
)
;
nsTArray
<
RefPtr
<
Database
>
>
databases
;
CollectDatabases
(
[
]
(
const
Database
*
const
)
{
return
true
;
}
databases
)
;
for
(
const
auto
&
database
:
databases
)
{
MOZ_ASSERT
(
database
)
;
database
-
>
ForceKill
(
)
;
}
databases
.
Clear
(
)
;
}
bool
VerifyPrincipalInfo
(
const
PrincipalInfo
&
aPrincipalInfo
const
PrincipalInfo
&
aStoragePrincipalInfo
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
IsPrincipalInfoValid
(
aPrincipalInfo
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
StoragePrincipalHelper
:
:
VerifyValidStoragePrincipalInfoForPrincipalInfo
(
aStoragePrincipalInfo
aPrincipalInfo
)
)
)
{
return
false
;
}
return
true
;
}
bool
VerifyClientId
(
const
Maybe
<
ContentParentId
>
&
aContentParentId
const
PrincipalInfo
&
aPrincipalInfo
const
Maybe
<
nsID
>
&
aClientId
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
gClientValidation
)
{
if
(
NS_WARN_IF
(
aClientId
.
isNothing
(
)
)
)
{
return
false
;
}
RefPtr
<
ClientManagerService
>
svc
=
ClientManagerService
:
:
GetInstance
(
)
;
if
(
svc
&
&
NS_WARN_IF
(
!
svc
-
>
HasWindow
(
aContentParentId
aPrincipalInfo
aClientId
.
ref
(
)
)
)
)
{
return
false
;
}
}
return
true
;
}
bool
VerifyOriginKey
(
const
nsACString
&
aOriginKey
const
PrincipalInfo
&
aPrincipalInfo
)
{
AssertIsOnBackgroundThread
(
)
;
nsCString
originAttrSuffix
;
nsCString
originKey
;
nsresult
rv
=
GenerateOriginKey2
(
aPrincipalInfo
originAttrSuffix
originKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
originKey
!
=
aOriginKey
)
)
{
LS_WARNING
(
"
originKey
(
%
s
)
doesn
'
t
match
passed
one
(
%
s
)
!
"
originKey
.
get
(
)
nsCString
(
aOriginKey
)
.
get
(
)
)
;
return
false
;
}
return
true
;
}
}
void
InitializeLocalStorage
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
gLocalStorageInitialized
)
;
if
(
!
QuotaManager
:
:
IsRunningGTests
(
)
)
{
nsCOMPtr
<
mozIStorageService
>
ss
;
if
(
NS_WARN_IF
(
!
(
ss
=
do_GetService
(
MOZ_STORAGE_SERVICE_CONTRACTID
)
)
)
)
{
NS_WARNING
(
"
Failed
to
get
storage
service
!
"
)
;
}
}
if
(
NS_FAILED
(
QuotaClient
:
:
Initialize
(
)
)
)
{
NS_WARNING
(
"
Failed
to
initialize
quota
client
!
"
)
;
}
Preferences
:
:
RegisterCallbackAndCall
(
ShadowWritesPrefChangedCallback
kShadowWritesPref
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SnapshotPrefillPrefChangedCallback
kSnapshotPrefillPref
)
;
Preferences
:
:
RegisterCallbackAndCall
(
SnapshotGradualPrefillPrefChangedCallback
kSnapshotGradualPrefillPref
)
;
Preferences
:
:
RegisterCallbackAndCall
(
ClientValidationPrefChangedCallback
kClientValidationPref
)
;
#
ifdef
DEBUG
gLocalStorageInitialized
=
true
;
#
endif
}
PBackgroundLSDatabaseParent
*
AllocPBackgroundLSDatabaseParent
(
const
PrincipalInfo
&
aPrincipalInfo
const
uint32_t
&
aPrivateBrowsingId
const
uint64_t
&
aDatastoreId
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
gPreparedDatastores
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
PreparedDatastore
*
preparedDatastore
=
gPreparedDatastores
-
>
Get
(
aDatastoreId
)
;
if
(
NS_WARN_IF
(
!
preparedDatastore
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
RefPtr
<
Database
>
database
=
new
Database
(
aPrincipalInfo
preparedDatastore
-
>
GetContentParentId
(
)
preparedDatastore
-
>
Origin
(
)
aPrivateBrowsingId
)
;
return
database
.
forget
(
)
.
take
(
)
;
}
bool
RecvPBackgroundLSDatabaseConstructor
(
PBackgroundLSDatabaseParent
*
aActor
const
PrincipalInfo
&
aPrincipalInfo
const
uint32_t
&
aPrivateBrowsingId
const
uint64_t
&
aDatastoreId
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
MOZ_ASSERT
(
gPreparedDatastores
)
;
MOZ_ASSERT
(
gPreparedDatastores
-
>
Get
(
aDatastoreId
)
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
mozilla
:
:
UniquePtr
<
PreparedDatastore
>
preparedDatastore
;
gPreparedDatastores
-
>
Remove
(
aDatastoreId
&
preparedDatastore
)
;
MOZ_ASSERT
(
preparedDatastore
)
;
auto
*
database
=
static_cast
<
Database
*
>
(
aActor
)
;
database
-
>
SetActorAlive
(
preparedDatastore
-
>
GetDatastore
(
)
)
;
if
(
preparedDatastore
-
>
IsInvalidated
(
)
)
{
database
-
>
RequestAllowToClose
(
)
;
}
return
true
;
}
bool
DeallocPBackgroundLSDatabaseParent
(
PBackgroundLSDatabaseParent
*
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
RefPtr
<
Database
>
actor
=
dont_AddRef
(
static_cast
<
Database
*
>
(
aActor
)
)
;
return
true
;
}
PBackgroundLSObserverParent
*
AllocPBackgroundLSObserverParent
(
const
uint64_t
&
aObserverId
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
gPreparedObsevers
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
RefPtr
<
Observer
>
observer
=
gPreparedObsevers
-
>
Get
(
aObserverId
)
;
if
(
NS_WARN_IF
(
!
observer
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
return
observer
.
forget
(
)
.
take
(
)
;
}
bool
RecvPBackgroundLSObserverConstructor
(
PBackgroundLSObserverParent
*
aActor
const
uint64_t
&
aObserverId
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
MOZ_ASSERT
(
gPreparedObsevers
)
;
MOZ_ASSERT
(
gPreparedObsevers
-
>
GetWeak
(
aObserverId
)
)
;
RefPtr
<
Observer
>
observer
;
gPreparedObsevers
-
>
Remove
(
aObserverId
observer
.
StartAssignment
(
)
)
;
MOZ_ASSERT
(
observer
)
;
if
(
!
gPreparedObsevers
-
>
Count
(
)
)
{
gPreparedObsevers
=
nullptr
;
}
if
(
!
gObservers
)
{
gObservers
=
new
ObserverHashtable
(
)
;
}
nsTArray
<
Observer
*
>
*
array
;
if
(
!
gObservers
-
>
Get
(
observer
-
>
Origin
(
)
&
array
)
)
{
array
=
new
nsTArray
<
Observer
*
>
(
)
;
gObservers
-
>
Put
(
observer
-
>
Origin
(
)
array
)
;
}
array
-
>
AppendElement
(
observer
)
;
if
(
RefPtr
<
Datastore
>
datastore
=
GetDatastore
(
observer
-
>
Origin
(
)
)
)
{
datastore
-
>
NoteChangedObserverArray
(
*
array
)
;
}
return
true
;
}
bool
DeallocPBackgroundLSObserverParent
(
PBackgroundLSObserverParent
*
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
RefPtr
<
Observer
>
actor
=
dont_AddRef
(
static_cast
<
Observer
*
>
(
aActor
)
)
;
return
true
;
}
PBackgroundLSRequestParent
*
AllocPBackgroundLSRequestParent
(
PBackgroundParent
*
aBackgroundActor
const
LSRequestParams
&
aParams
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParams
.
type
(
)
!
=
LSRequestParams
:
:
T__None
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
)
{
return
nullptr
;
}
Maybe
<
ContentParentId
>
contentParentId
;
uint64_t
childID
=
BackgroundParent
:
:
GetChildID
(
aBackgroundActor
)
;
if
(
childID
)
{
contentParentId
=
Some
(
ContentParentId
(
childID
)
)
;
}
nsCOMPtr
<
nsIEventTarget
>
mainEventTarget
;
if
(
!
BackgroundParent
:
:
IsOtherProcessActor
(
aBackgroundActor
)
)
{
mainEventTarget
=
LSObject
:
:
GetSyncLoopEventTarget
(
)
;
}
RefPtr
<
LSRequestBase
>
actor
;
switch
(
aParams
.
type
(
)
)
{
case
LSRequestParams
:
:
TLSRequestPreloadDatastoreParams
:
case
LSRequestParams
:
:
TLSRequestPrepareDatastoreParams
:
{
RefPtr
<
PrepareDatastoreOp
>
prepareDatastoreOp
=
new
PrepareDatastoreOp
(
mainEventTarget
aParams
contentParentId
)
;
if
(
!
gPrepareDatastoreOps
)
{
gPrepareDatastoreOps
=
new
PrepareDatastoreOpArray
(
)
;
}
gPrepareDatastoreOps
-
>
AppendElement
(
prepareDatastoreOp
)
;
actor
=
std
:
:
move
(
prepareDatastoreOp
)
;
break
;
}
case
LSRequestParams
:
:
TLSRequestPrepareObserverParams
:
{
RefPtr
<
PrepareObserverOp
>
prepareObserverOp
=
new
PrepareObserverOp
(
mainEventTarget
aParams
contentParentId
)
;
actor
=
std
:
:
move
(
prepareObserverOp
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
return
actor
.
forget
(
)
.
take
(
)
;
}
bool
RecvPBackgroundLSRequestConstructor
(
PBackgroundLSRequestParent
*
aActor
const
LSRequestParams
&
aParams
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
MOZ_ASSERT
(
aParams
.
type
(
)
!
=
LSRequestParams
:
:
T__None
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
auto
*
op
=
static_cast
<
LSRequestBase
*
>
(
aActor
)
;
op
-
>
Dispatch
(
)
;
return
true
;
}
bool
DeallocPBackgroundLSRequestParent
(
PBackgroundLSRequestParent
*
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
LSRequestBase
>
actor
=
dont_AddRef
(
static_cast
<
LSRequestBase
*
>
(
aActor
)
)
;
return
true
;
}
PBackgroundLSSimpleRequestParent
*
AllocPBackgroundLSSimpleRequestParent
(
PBackgroundParent
*
aBackgroundActor
const
LSSimpleRequestParams
&
aParams
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParams
.
type
(
)
!
=
LSSimpleRequestParams
:
:
T__None
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
)
{
return
nullptr
;
}
Maybe
<
ContentParentId
>
contentParentId
;
uint64_t
childID
=
BackgroundParent
:
:
GetChildID
(
aBackgroundActor
)
;
if
(
childID
)
{
contentParentId
=
Some
(
ContentParentId
(
childID
)
)
;
}
RefPtr
<
LSSimpleRequestBase
>
actor
;
switch
(
aParams
.
type
(
)
)
{
case
LSSimpleRequestParams
:
:
TLSSimpleRequestPreloadedParams
:
{
RefPtr
<
PreloadedOp
>
preloadedOp
=
new
PreloadedOp
(
aParams
contentParentId
)
;
actor
=
std
:
:
move
(
preloadedOp
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
return
actor
.
forget
(
)
.
take
(
)
;
}
bool
RecvPBackgroundLSSimpleRequestConstructor
(
PBackgroundLSSimpleRequestParent
*
aActor
const
LSSimpleRequestParams
&
aParams
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
MOZ_ASSERT
(
aParams
.
type
(
)
!
=
LSSimpleRequestParams
:
:
T__None
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
auto
*
op
=
static_cast
<
LSSimpleRequestBase
*
>
(
aActor
)
;
op
-
>
Dispatch
(
)
;
return
true
;
}
bool
DeallocPBackgroundLSSimpleRequestParent
(
PBackgroundLSSimpleRequestParent
*
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
LSSimpleRequestBase
>
actor
=
dont_AddRef
(
static_cast
<
LSSimpleRequestBase
*
>
(
aActor
)
)
;
return
true
;
}
bool
RecvLSClearPrivateBrowsing
(
)
{
AssertIsOnBackgroundThread
(
)
;
gPrivateDatastores
=
nullptr
;
if
(
gDatastores
)
{
for
(
const
auto
&
entry
:
*
gDatastores
)
{
const
auto
&
datastore
=
entry
.
GetData
(
)
;
MOZ_ASSERT
(
datastore
)
;
if
(
datastore
-
>
PrivateBrowsingId
(
)
)
{
datastore
-
>
Clear
(
nullptr
)
;
}
}
}
return
true
;
}
namespace
localstorage
{
already_AddRefed
<
mozilla
:
:
dom
:
:
quota
:
:
Client
>
CreateQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
CachedNextGenLocalStorageEnabled
(
)
)
;
RefPtr
<
QuotaClient
>
client
=
new
QuotaClient
(
)
;
return
client
.
forget
(
)
;
}
}
void
DatastoreWriteOptimizer
:
:
ApplyAndReset
(
nsTArray
<
LSItemInfo
>
&
aOrderedItems
)
{
AssertIsOnOwningThread
(
)
;
if
(
mTruncateInfo
)
{
aOrderedItems
.
Clear
(
)
;
mTruncateInfo
=
nullptr
;
}
for
(
int32_t
index
=
aOrderedItems
.
Length
(
)
-
1
;
index
>
=
0
;
index
-
-
)
{
LSItemInfo
&
item
=
aOrderedItems
[
index
]
;
if
(
auto
entry
=
mWriteInfos
.
Lookup
(
item
.
key
(
)
)
)
{
WriteInfo
*
writeInfo
=
entry
.
Data
(
)
.
get
(
)
;
switch
(
writeInfo
-
>
GetType
(
)
)
{
case
WriteInfo
:
:
DeleteItem
:
aOrderedItems
.
RemoveElementAt
(
index
)
;
entry
.
Remove
(
)
;
break
;
case
WriteInfo
:
:
UpdateItem
:
{
auto
updateItemInfo
=
static_cast
<
UpdateItemInfo
*
>
(
writeInfo
)
;
if
(
updateItemInfo
-
>
UpdateWithMove
(
)
)
{
aOrderedItems
.
RemoveElementAt
(
index
)
;
entry
.
Data
(
)
=
MakeUnique
<
InsertItemInfo
>
(
updateItemInfo
-
>
SerialNumber
(
)
updateItemInfo
-
>
GetKey
(
)
updateItemInfo
-
>
GetValue
(
)
)
;
}
else
{
item
.
value
(
)
=
updateItemInfo
-
>
GetValue
(
)
;
entry
.
Remove
(
)
;
}
break
;
}
case
WriteInfo
:
:
InsertItem
:
break
;
default
:
MOZ_CRASH
(
"
Bad
type
!
"
)
;
}
}
}
nsTArray
<
WriteInfo
*
>
writeInfos
;
GetSortedWriteInfos
(
writeInfos
)
;
for
(
WriteInfo
*
writeInfo
:
writeInfos
)
{
MOZ_ASSERT
(
writeInfo
-
>
GetType
(
)
=
=
WriteInfo
:
:
InsertItem
)
;
auto
insertItemInfo
=
static_cast
<
InsertItemInfo
*
>
(
writeInfo
)
;
LSItemInfo
*
itemInfo
=
aOrderedItems
.
AppendElement
(
)
;
itemInfo
-
>
key
(
)
=
insertItemInfo
-
>
GetKey
(
)
;
itemInfo
-
>
value
(
)
=
insertItemInfo
-
>
GetValue
(
)
;
}
mWriteInfos
.
Clear
(
)
;
}
nsresult
ConnectionWriteOptimizer
:
:
Perform
(
Connection
*
aConnection
bool
aShadowWrites
int64_t
&
aOutUsage
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsresult
rv
;
if
(
mTruncateInfo
)
{
rv
=
PerformTruncate
(
aConnection
aShadowWrites
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
for
(
auto
iter
=
mWriteInfos
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
WriteInfo
*
writeInfo
=
iter
.
Data
(
)
.
get
(
)
;
switch
(
writeInfo
-
>
GetType
(
)
)
{
case
WriteInfo
:
:
InsertItem
:
case
WriteInfo
:
:
UpdateItem
:
{
auto
insertItemInfo
=
static_cast
<
InsertItemInfo
*
>
(
writeInfo
)
;
rv
=
PerformInsertOrUpdate
(
aConnection
aShadowWrites
insertItemInfo
-
>
GetKey
(
)
insertItemInfo
-
>
GetValue
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
break
;
}
case
WriteInfo
:
:
DeleteItem
:
{
auto
deleteItemInfo
=
static_cast
<
DeleteItemInfo
*
>
(
writeInfo
)
;
rv
=
PerformDelete
(
aConnection
aShadowWrites
deleteItemInfo
-
>
GetKey
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Bad
type
!
"
)
;
}
}
Connection
:
:
CachedStatement
stmt
;
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
UPDATE
database
"
"
SET
usage
=
usage
+
:
delta
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindInt64ByName
(
"
delta
"
_ns
mTotalDelta
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
SELECT
usage
"
"
FROM
database
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
hasResult
)
)
{
return
NS_ERROR_FAILURE
;
}
int64_t
usage
;
rv
=
stmt
-
>
GetInt64
(
0
&
usage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aOutUsage
=
usage
;
return
NS_OK
;
}
nsresult
ConnectionWriteOptimizer
:
:
PerformInsertOrUpdate
(
Connection
*
aConnection
bool
aShadowWrites
const
nsAString
&
aKey
const
LSValue
&
aValue
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
Connection
:
:
CachedStatement
stmt
;
nsresult
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
INSERT
OR
REPLACE
INTO
data
(
key
value
utf16Length
compressed
)
"
"
VALUES
(
:
key
:
value
:
utf16Length
:
compressed
)
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindStringByName
(
"
key
"
_ns
aKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindUTF8StringByName
(
"
value
"
_ns
aValue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindInt32ByName
(
"
utf16Length
"
_ns
aValue
.
UTF16Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindInt32ByName
(
"
compressed
"
_ns
aValue
.
IsCompressed
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aShadowWrites
)
{
return
NS_OK
;
}
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
INSERT
OR
REPLACE
INTO
shadow
.
webappsstore2
"
"
(
originAttributes
originKey
scope
key
value
)
"
"
VALUES
(
:
originAttributes
:
originKey
:
scope
:
key
:
value
)
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
ArchivedOriginScope
*
archivedOriginScope
=
aConnection
-
>
GetArchivedOriginScope
(
)
;
rv
=
archivedOriginScope
-
>
BindToStatement
(
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
scope
=
Scheme0Scope
(
archivedOriginScope
-
>
OriginSuffix
(
)
archivedOriginScope
-
>
OriginNoSuffix
(
)
)
;
rv
=
stmt
-
>
BindUTF8StringByName
(
"
scope
"
_ns
scope
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindStringByName
(
"
key
"
_ns
aKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aValue
.
IsCompressed
(
)
)
{
nsCString
value
;
if
(
NS_WARN_IF
(
!
SnappyUncompress
(
aValue
value
)
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
stmt
-
>
BindUTF8StringByName
(
"
value
"
_ns
value
)
;
}
else
{
rv
=
stmt
-
>
BindUTF8StringByName
(
"
value
"
_ns
aValue
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
ConnectionWriteOptimizer
:
:
PerformDelete
(
Connection
*
aConnection
bool
aShadowWrites
const
nsAString
&
aKey
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
Connection
:
:
CachedStatement
stmt
;
nsresult
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
DELETE
FROM
data
"
"
WHERE
key
=
:
key
;
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindStringByName
(
"
key
"
_ns
aKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aShadowWrites
)
{
return
NS_OK
;
}
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
DELETE
FROM
shadow
.
webappsstore2
"
"
WHERE
originAttributes
=
:
originAttributes
"
"
AND
originKey
=
:
originKey
"
"
AND
key
=
:
key
;
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
GetArchivedOriginScope
(
)
-
>
BindToStatement
(
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindStringByName
(
"
key
"
_ns
aKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
ConnectionWriteOptimizer
:
:
PerformTruncate
(
Connection
*
aConnection
bool
aShadowWrites
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
Connection
:
:
CachedStatement
stmt
;
nsresult
rv
=
aConnection
-
>
GetCachedStatement
(
"
DELETE
FROM
data
;
"
_ns
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aShadowWrites
)
{
return
NS_OK
;
}
rv
=
aConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
DELETE
FROM
shadow
.
webappsstore2
"
"
WHERE
originAttributes
=
:
originAttributes
"
"
AND
originKey
=
:
originKey
;
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConnection
-
>
GetArchivedOriginScope
(
)
-
>
BindToStatement
(
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
ConnectionDatastoreOperationBase
:
:
ConnectionDatastoreOperationBase
(
Connection
*
aConnection
bool
aEnsureStorageConnection
)
:
mConnection
(
aConnection
)
mEnsureStorageConnection
(
aEnsureStorageConnection
)
{
MOZ_ASSERT
(
aConnection
)
;
}
ConnectionDatastoreOperationBase
:
:
~
ConnectionDatastoreOperationBase
(
)
{
MOZ_ASSERT
(
!
mConnection
"
ConnectionDatabaseOperationBase
:
:
Cleanup
(
)
was
not
called
by
a
"
"
subclass
!
"
)
;
}
void
ConnectionDatastoreOperationBase
:
:
Cleanup
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
mConnection
=
nullptr
;
NoteComplete
(
)
;
}
void
ConnectionDatastoreOperationBase
:
:
OnSuccess
(
)
{
AssertIsOnOwningThread
(
)
;
}
void
ConnectionDatastoreOperationBase
:
:
OnFailure
(
nsresult
aResultCode
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
NS_FAILED
(
aResultCode
)
)
;
}
void
ConnectionDatastoreOperationBase
:
:
RunOnConnectionThread
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
;
if
(
!
MayProceedOnNonOwningThread
(
)
)
{
SetFailureCode
(
NS_ERROR_FAILURE
)
;
}
else
{
nsresult
rv
=
NS_OK
;
if
(
mEnsureStorageConnection
)
{
rv
=
mConnection
-
>
EnsureStorageConnection
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
SetFailureCode
(
rv
)
;
}
else
{
MOZ_ASSERT
(
mConnection
-
>
StorageConnection
(
)
)
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
DoDatastoreWork
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
SetFailureCode
(
rv
)
;
}
}
}
MOZ_ALWAYS_SUCCEEDS
(
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
void
ConnectionDatastoreOperationBase
:
:
RunOnOwningThread
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
if
(
!
MayProceed
(
)
)
{
MaybeSetFailureCode
(
NS_ERROR_FAILURE
)
;
}
if
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
{
OnSuccess
(
)
;
}
else
{
OnFailure
(
ResultCode
(
)
)
;
}
Cleanup
(
)
;
}
NS_IMETHODIMP
ConnectionDatastoreOperationBase
:
:
Run
(
)
{
if
(
IsOnConnectionThread
(
)
)
{
RunOnConnectionThread
(
)
;
}
else
{
RunOnOwningThread
(
)
;
}
return
NS_OK
;
}
Connection
:
:
Connection
(
ConnectionThread
*
aConnectionThread
const
QuotaInfo
&
aQuotaInfo
UniquePtr
<
ArchivedOriginScope
>
&
&
aArchivedOriginScope
bool
aDatabaseWasNotAvailable
)
:
mConnectionThread
(
aConnectionThread
)
mQuotaClient
(
QuotaClient
:
:
GetInstance
(
)
)
mArchivedOriginScope
(
std
:
:
move
(
aArchivedOriginScope
)
)
mQuotaInfo
(
aQuotaInfo
)
mDatabaseWasNotAvailable
(
aDatabaseWasNotAvailable
)
mHasCreatedDatabase
(
false
)
mFlushScheduled
(
false
)
#
ifdef
DEBUG
mInUpdateBatch
(
false
)
mFinished
(
false
)
#
endif
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
aQuotaInfo
.
mGroup
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aQuotaInfo
.
mOrigin
.
IsEmpty
(
)
)
;
}
Connection
:
:
~
Connection
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mStorageConnection
)
;
MOZ_ASSERT
(
!
mCachedStatements
.
Count
(
)
)
;
MOZ_ASSERT
(
!
mFlushScheduled
)
;
MOZ_ASSERT
(
!
mInUpdateBatch
)
;
MOZ_ASSERT
(
mFinished
)
;
}
void
Connection
:
:
Dispatch
(
ConnectionDatastoreOperationBase
*
aOp
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mConnectionThread
)
;
MOZ_ALWAYS_SUCCEEDS
(
mConnectionThread
-
>
mThread
-
>
Dispatch
(
aOp
NS_DISPATCH_NORMAL
)
)
;
}
void
Connection
:
:
Close
(
nsIRunnable
*
aCallback
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aCallback
)
;
if
(
mFlushScheduled
)
{
MOZ_ASSERT
(
mFlushTimer
)
;
MOZ_ALWAYS_SUCCEEDS
(
mFlushTimer
-
>
Cancel
(
)
)
;
Flush
(
)
;
mFlushTimer
=
nullptr
;
}
RefPtr
<
CloseOp
>
op
=
new
CloseOp
(
this
aCallback
)
;
Dispatch
(
op
)
;
}
void
Connection
:
:
SetItem
(
const
nsString
&
aKey
const
LSValue
&
aValue
int64_t
aDelta
bool
aIsNewItem
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
if
(
aIsNewItem
)
{
mWriteOptimizer
.
InsertItem
(
aKey
aValue
aDelta
)
;
}
else
{
mWriteOptimizer
.
UpdateItem
(
aKey
aValue
aDelta
)
;
}
}
void
Connection
:
:
RemoveItem
(
const
nsString
&
aKey
int64_t
aDelta
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
mWriteOptimizer
.
DeleteItem
(
aKey
aDelta
)
;
}
void
Connection
:
:
Clear
(
int64_t
aDelta
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
mWriteOptimizer
.
Truncate
(
aDelta
)
;
}
void
Connection
:
:
BeginUpdateBatch
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mInUpdateBatch
)
;
#
ifdef
DEBUG
mInUpdateBatch
=
true
;
#
endif
}
void
Connection
:
:
EndUpdateBatch
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
if
(
mWriteOptimizer
.
HasWrites
(
)
&
&
!
mFlushScheduled
)
{
ScheduleFlush
(
)
;
}
#
ifdef
DEBUG
mInUpdateBatch
=
false
;
#
endif
}
nsresult
Connection
:
:
EnsureStorageConnection
(
)
{
AssertIsOnConnectionThread
(
)
;
if
(
mStorageConnection
)
{
return
NS_OK
;
}
nsresult
rv
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
if
(
!
mDatabaseWasNotAvailable
|
|
mHasCreatedDatabase
)
{
LS_TRY_UNWRAP
(
auto
directoryEntry
quotaManager
-
>
GetDirectoryForOrigin
(
PERSISTENCE_TYPE_DEFAULT
Origin
(
)
)
)
;
rv
=
directoryEntry
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
LS_DIRECTORY_NAME
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
directoryEntry
-
>
GetPath
(
mDirectoryPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
directoryEntry
-
>
Append
(
kDataFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsString
databaseFilePath
;
rv
=
directoryEntry
-
>
GetPath
(
databaseFilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
storageConnection
;
rv
=
GetStorageConnection
(
databaseFilePath
getter_AddRefs
(
storageConnection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mStorageConnection
=
storageConnection
;
return
NS_OK
;
}
RefPtr
<
InitStorageAndOriginHelper
>
helper
=
new
InitStorageAndOriginHelper
(
mQuotaInfo
)
;
nsString
originDirectoryPath
;
rv
=
helper
-
>
BlockAndReturnOriginDirectoryPath
(
originDirectoryPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
auto
directoryEntryOrErr
=
QM_NewLocalFile
(
originDirectoryPath
)
;
if
(
NS_WARN_IF
(
directoryEntryOrErr
.
isErr
(
)
)
)
{
return
directoryEntryOrErr
.
unwrapErr
(
)
;
}
nsCOMPtr
<
nsIFile
>
directoryEntry
=
directoryEntryOrErr
.
unwrap
(
)
;
rv
=
directoryEntry
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
LS_DIRECTORY_NAME
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
directoryEntry
-
>
GetPath
(
mDirectoryPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
exists
;
rv
=
directoryEntry
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
exists
)
{
rv
=
directoryEntry
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
directoryEntry
-
>
Append
(
kDataFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
DEBUG
rv
=
directoryEntry
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
!
exists
)
;
#
endif
nsCOMPtr
<
nsIFile
>
usageFile
;
rv
=
GetUsageFile
(
mDirectoryPath
getter_AddRefs
(
usageFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
storageConnection
;
bool
removedUsageFile
;
auto
autoRemove
=
MakeScopeExit
(
[
&
]
{
if
(
storageConnection
)
{
MOZ_ALWAYS_SUCCEEDS
(
storageConnection
-
>
Close
(
)
)
;
}
nsresult
rv
=
directoryEntry
-
>
Remove
(
false
)
;
if
(
rv
!
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
&
&
rv
!
=
NS_ERROR_FILE_NOT_FOUND
&
&
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
remove
database
file
!
"
)
;
}
}
)
;
rv
=
CreateStorageConnection
(
directoryEntry
usageFile
Origin
(
)
getter_AddRefs
(
storageConnection
)
&
removedUsageFile
)
;
MOZ_ASSERT
(
!
removedUsageFile
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
mQuotaClient
)
;
MutexAutoLock
shadowDatabaseLock
(
mQuotaClient
-
>
ShadowDatabaseMutex
(
)
)
;
nsCOMPtr
<
mozIStorageConnection
>
shadowConnection
;
if
(
!
gInitializedShadowStorage
)
{
rv
=
CreateShadowStorageConnection
(
quotaManager
-
>
GetBasePath
(
)
getter_AddRefs
(
shadowConnection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
gInitializedShadowStorage
=
true
;
}
autoRemove
.
release
(
)
;
if
(
!
mHasCreatedDatabase
)
{
mHasCreatedDatabase
=
true
;
}
mStorageConnection
=
storageConnection
;
return
NS_OK
;
}
void
Connection
:
:
CloseStorageConnection
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mStorageConnection
)
;
mCachedStatements
.
Clear
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
mStorageConnection
-
>
Close
(
)
)
;
mStorageConnection
=
nullptr
;
}
nsresult
Connection
:
:
GetCachedStatement
(
const
nsACString
&
aQuery
CachedStatement
*
aCachedStatement
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
!
aQuery
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aCachedStatement
)
;
MOZ_ASSERT
(
mStorageConnection
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
if
(
!
mCachedStatements
.
Get
(
aQuery
getter_AddRefs
(
stmt
)
)
)
{
nsresult
rv
=
mStorageConnection
-
>
CreateStatement
(
aQuery
getter_AddRefs
(
stmt
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
#
ifdef
DEBUG
nsCString
msg
;
MOZ_ALWAYS_SUCCEEDS
(
mStorageConnection
-
>
GetLastErrorString
(
msg
)
)
;
nsAutoCString
error
=
"
The
statement
'
"
_ns
+
aQuery
+
"
'
failed
to
compile
with
the
error
message
'
"
_ns
+
msg
+
"
'
.
"
_ns
;
NS_WARNING
(
error
.
get
(
)
)
;
#
endif
return
rv
;
}
mCachedStatements
.
Put
(
aQuery
stmt
)
;
}
aCachedStatement
-
>
Assign
(
this
stmt
.
forget
(
)
)
;
return
NS_OK
;
}
nsresult
Connection
:
:
BeginWriteTransaction
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mStorageConnection
)
;
CachedStatement
stmt
;
nsresult
rv
=
GetCachedStatement
(
"
BEGIN
IMMEDIATE
;
"
_ns
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
Connection
:
:
CommitWriteTransaction
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mStorageConnection
)
;
CachedStatement
stmt
;
nsresult
rv
=
GetCachedStatement
(
"
COMMIT
;
"
_ns
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
Connection
:
:
RollbackWriteTransaction
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mStorageConnection
)
;
CachedStatement
stmt
;
nsresult
rv
=
GetCachedStatement
(
"
ROLLBACK
;
"
_ns
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
Unused
<
<
stmt
-
>
Execute
(
)
;
return
NS_OK
;
}
void
Connection
:
:
ScheduleFlush
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mWriteOptimizer
.
HasWrites
(
)
)
;
MOZ_ASSERT
(
!
mFlushScheduled
)
;
if
(
!
mFlushTimer
)
{
mFlushTimer
=
NS_NewTimer
(
)
;
MOZ_ASSERT
(
mFlushTimer
)
;
}
MOZ_ALWAYS_SUCCEEDS
(
mFlushTimer
-
>
InitWithNamedFuncCallback
(
FlushTimerCallback
this
kFlushTimeoutMs
nsITimer
:
:
TYPE_ONE_SHOT
"
Connection
:
:
FlushTimerCallback
"
)
)
;
mFlushScheduled
=
true
;
}
void
Connection
:
:
Flush
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mFlushScheduled
)
;
if
(
mWriteOptimizer
.
HasWrites
(
)
)
{
RefPtr
<
FlushOp
>
op
=
new
FlushOp
(
this
std
:
:
move
(
mWriteOptimizer
)
)
;
Dispatch
(
op
)
;
}
mFlushScheduled
=
false
;
}
void
Connection
:
:
FlushTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MOZ_ASSERT
(
aClosure
)
;
auto
*
self
=
static_cast
<
Connection
*
>
(
aClosure
)
;
MOZ_ASSERT
(
self
)
;
MOZ_ASSERT
(
self
-
>
mFlushScheduled
)
;
self
-
>
Flush
(
)
;
}
Connection
:
:
CachedStatement
:
:
CachedStatement
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_COUNT_CTOR
(
Connection
:
:
CachedStatement
)
;
}
Connection
:
:
CachedStatement
:
:
~
CachedStatement
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_COUNT_DTOR
(
Connection
:
:
CachedStatement
)
;
}
Connection
:
:
CachedStatement
:
:
operator
mozIStorageStatement
*
(
)
const
{
AssertIsOnConnectionThread
(
)
;
return
mStatement
;
}
mozIStorageStatement
*
Connection
:
:
CachedStatement
:
:
operator
-
>
(
)
const
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mStatement
)
;
return
mStatement
;
}
void
Connection
:
:
CachedStatement
:
:
Assign
(
Connection
*
aConnection
already_AddRefed
<
mozIStorageStatement
>
aStatement
)
{
AssertIsOnConnectionThread
(
)
;
mScoper
.
reset
(
)
;
mStatement
=
aStatement
;
if
(
mStatement
)
{
mScoper
.
emplace
(
mStatement
)
;
}
}
nsresult
Connection
:
:
InitStorageAndOriginHelper
:
:
BlockAndReturnOriginDirectoryPath
(
nsAString
&
aOriginDirectoryPath
)
{
AssertIsOnConnectionThread
(
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
MOZ_ALWAYS_SUCCEEDS
(
quotaManager
-
>
IOThread
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mWaiting
)
{
lock
.
Wait
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
mIOThreadResultCode
)
)
)
{
return
mIOThreadResultCode
;
}
aOriginDirectoryPath
=
mOriginDirectoryPath
;
return
NS_OK
;
}
nsresult
Connection
:
:
InitStorageAndOriginHelper
:
:
RunOnIOThread
(
)
{
AssertIsOnIOThread
(
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
LS_TRY_INSPECT
(
const
auto
&
directoryEntry
quotaManager
-
>
EnsureStorageAndOriginIsInitialized
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
)
)
;
nsresult
rv
=
directoryEntry
-
>
GetPath
(
mOriginDirectoryPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_IMETHODIMP
Connection
:
:
InitStorageAndOriginHelper
:
:
Run
(
)
{
AssertIsOnIOThread
(
)
;
nsresult
rv
=
RunOnIOThread
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mIOThreadResultCode
=
rv
;
}
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mWaiting
)
;
mWaiting
=
false
;
lock
.
Notify
(
)
;
return
NS_OK
;
}
Connection
:
:
FlushOp
:
:
FlushOp
(
Connection
*
aConnection
ConnectionWriteOptimizer
&
&
aWriteOptimizer
)
:
ConnectionDatastoreOperationBase
(
aConnection
)
mWriteOptimizer
(
std
:
:
move
(
aWriteOptimizer
)
)
mShadowWrites
(
gShadowWrites
)
{
}
nsresult
Connection
:
:
FlushOp
:
:
DoDatastoreWork
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
AutoWriteTransaction
autoWriteTransaction
(
mShadowWrites
)
;
nsresult
rv
=
autoWriteTransaction
.
Start
(
mConnection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int64_t
usage
;
rv
=
mWriteOptimizer
.
Perform
(
mConnection
mShadowWrites
usage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
usageFile
;
rv
=
GetUsageFile
(
mConnection
-
>
DirectoryPath
(
)
getter_AddRefs
(
usageFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
usageJournalFile
;
rv
=
GetUsageJournalFile
(
mConnection
-
>
DirectoryPath
(
)
getter_AddRefs
(
usageJournalFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
UpdateUsageFile
(
usageFile
usageJournalFile
usage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
autoWriteTransaction
.
Commit
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
usageJournalFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
Connection
:
:
FlushOp
:
:
Cleanup
(
)
{
AssertIsOnOwningThread
(
)
;
mWriteOptimizer
.
Reset
(
)
;
MOZ_ASSERT
(
!
mWriteOptimizer
.
HasWrites
(
)
)
;
ConnectionDatastoreOperationBase
:
:
Cleanup
(
)
;
}
nsresult
Connection
:
:
CloseOp
:
:
DoDatastoreWork
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
if
(
mConnection
-
>
StorageConnection
(
)
)
{
mConnection
-
>
CloseStorageConnection
(
)
;
}
return
NS_OK
;
}
void
Connection
:
:
CloseOp
:
:
Cleanup
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
mConnection
-
>
mConnectionThread
-
>
mConnections
.
Remove
(
mConnection
-
>
Origin
(
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mConnection
-
>
mFinished
)
;
mConnection
-
>
mFinished
=
true
;
#
endif
nsCOMPtr
<
nsIRunnable
>
callback
;
mCallback
.
swap
(
callback
)
;
callback
-
>
Run
(
)
;
ConnectionDatastoreOperationBase
:
:
Cleanup
(
)
;
}
ConnectionThread
:
:
ConnectionThread
(
)
{
AssertIsOnOwningThread
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_NewNamedThread
(
"
LS
Thread
"
getter_AddRefs
(
mThread
)
)
)
;
}
ConnectionThread
:
:
~
ConnectionThread
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mConnections
.
Count
(
)
)
;
}
bool
ConnectionThread
:
:
IsOnConnectionThread
(
)
{
MOZ_ASSERT
(
mThread
)
;
bool
current
;
return
NS_SUCCEEDED
(
mThread
-
>
IsOnCurrentThread
(
&
current
)
)
&
&
current
;
}
void
ConnectionThread
:
:
AssertIsOnConnectionThread
(
)
{
MOZ_ASSERT
(
IsOnConnectionThread
(
)
)
;
}
already_AddRefed
<
Connection
>
ConnectionThread
:
:
CreateConnection
(
const
QuotaInfo
&
aQuotaInfo
UniquePtr
<
ArchivedOriginScope
>
&
&
aArchivedOriginScope
bool
aDatabaseWasNotAvailable
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
aQuotaInfo
.
mOrigin
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mConnections
.
GetWeak
(
aQuotaInfo
.
mOrigin
)
)
;
RefPtr
<
Connection
>
connection
=
new
Connection
(
this
aQuotaInfo
std
:
:
move
(
aArchivedOriginScope
)
aDatabaseWasNotAvailable
)
;
mConnections
.
Put
(
aQuotaInfo
.
mOrigin
RefPtr
{
connection
}
)
;
return
connection
.
forget
(
)
;
}
void
ConnectionThread
:
:
Shutdown
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mThread
)
;
mThread
-
>
Shutdown
(
)
;
}
Datastore
:
:
Datastore
(
const
GroupAndOrigin
&
aGroupAndOrigin
uint32_t
aPrivateBrowsingId
int64_t
aUsage
int64_t
aSizeOfKeys
int64_t
aSizeOfItems
RefPtr
<
DirectoryLock
>
&
&
aDirectoryLock
RefPtr
<
Connection
>
&
&
aConnection
RefPtr
<
QuotaObject
>
&
&
aQuotaObject
nsDataHashtable
<
nsStringHashKey
LSValue
>
&
aValues
nsTArray
<
LSItemInfo
>
&
&
aOrderedItems
)
:
mDirectoryLock
(
std
:
:
move
(
aDirectoryLock
)
)
mConnection
(
std
:
:
move
(
aConnection
)
)
mQuotaObject
(
std
:
:
move
(
aQuotaObject
)
)
mOrderedItems
(
std
:
:
move
(
aOrderedItems
)
)
mGroupAndOrigin
(
aGroupAndOrigin
)
mPrivateBrowsingId
(
aPrivateBrowsingId
)
mUsage
(
aUsage
)
mUpdateBatchUsage
(
-
1
)
mSizeOfKeys
(
aSizeOfKeys
)
mSizeOfItems
(
aSizeOfItems
)
mClosed
(
false
)
mInUpdateBatch
(
false
)
mHasLivePrivateDatastore
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
mValues
.
SwapElements
(
aValues
)
;
}
Datastore
:
:
~
Datastore
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mClosed
)
;
}
void
Datastore
:
:
Close
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
!
mPrepareDatastoreOps
.
Count
(
)
)
;
MOZ_ASSERT
(
!
mPreparedDatastores
.
Count
(
)
)
;
MOZ_ASSERT
(
!
mDatabases
.
Count
(
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
mClosed
=
true
;
if
(
IsPersistent
(
)
)
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mQuotaObject
)
;
nsCOMPtr
<
nsIRunnable
>
callback
=
NewRunnableMethod
(
"
dom
:
:
Datastore
:
:
ConnectionClosedCallback
"
this
&
Datastore
:
:
ConnectionClosedCallback
)
;
mConnection
-
>
Close
(
callback
)
;
}
else
{
MOZ_ASSERT
(
!
mConnection
)
;
MOZ_ASSERT
(
!
mQuotaObject
)
;
mDirectoryLock
=
nullptr
;
CleanupMetadata
(
)
;
}
}
void
Datastore
:
:
WaitForConnectionToComplete
(
nsIRunnable
*
aCallback
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aCallback
)
;
MOZ_ASSERT
(
!
mCompleteCallback
)
;
MOZ_ASSERT
(
mClosed
)
;
mCompleteCallback
=
aCallback
;
}
void
Datastore
:
:
NoteLivePrepareDatastoreOp
(
PrepareDatastoreOp
*
aPrepareDatastoreOp
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aPrepareDatastoreOp
)
;
MOZ_ASSERT
(
!
mPrepareDatastoreOps
.
GetEntry
(
aPrepareDatastoreOp
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mPrepareDatastoreOps
.
PutEntry
(
aPrepareDatastoreOp
)
;
}
void
Datastore
:
:
NoteFinishedPrepareDatastoreOp
(
PrepareDatastoreOp
*
aPrepareDatastoreOp
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aPrepareDatastoreOp
)
;
MOZ_ASSERT
(
mPrepareDatastoreOps
.
GetEntry
(
aPrepareDatastoreOp
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mPrepareDatastoreOps
.
RemoveEntry
(
aPrepareDatastoreOp
)
;
MaybeClose
(
)
;
}
void
Datastore
:
:
NoteLivePrivateDatastore
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mHasLivePrivateDatastore
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mHasLivePrivateDatastore
=
true
;
}
void
Datastore
:
:
NoteFinishedPrivateDatastore
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mHasLivePrivateDatastore
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mHasLivePrivateDatastore
=
false
;
MaybeClose
(
)
;
}
void
Datastore
:
:
NoteLivePreparedDatastore
(
PreparedDatastore
*
aPreparedDatastore
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aPreparedDatastore
)
;
MOZ_ASSERT
(
!
mPreparedDatastores
.
GetEntry
(
aPreparedDatastore
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mPreparedDatastores
.
PutEntry
(
aPreparedDatastore
)
;
}
void
Datastore
:
:
NoteFinishedPreparedDatastore
(
PreparedDatastore
*
aPreparedDatastore
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aPreparedDatastore
)
;
MOZ_ASSERT
(
mPreparedDatastores
.
GetEntry
(
aPreparedDatastore
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mPreparedDatastores
.
RemoveEntry
(
aPreparedDatastore
)
;
MaybeClose
(
)
;
}
void
Datastore
:
:
NoteLiveDatabase
(
Database
*
aDatabase
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
MOZ_ASSERT
(
!
mDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mDatabases
.
PutEntry
(
aDatabase
)
;
}
void
Datastore
:
:
NoteFinishedDatabase
(
Database
*
aDatabase
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
MOZ_ASSERT
(
mDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
!
mActiveDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mDatabases
.
RemoveEntry
(
aDatabase
)
;
MaybeClose
(
)
;
}
void
Datastore
:
:
NoteActiveDatabase
(
Database
*
aDatabase
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
MOZ_ASSERT
(
mDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
!
mActiveDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mActiveDatabases
.
PutEntry
(
aDatabase
)
;
}
void
Datastore
:
:
NoteInactiveDatabase
(
Database
*
aDatabase
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
MOZ_ASSERT
(
mDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
mActiveDatabases
.
GetEntry
(
aDatabase
)
)
;
MOZ_ASSERT
(
!
mClosed
)
;
mActiveDatabases
.
RemoveEntry
(
aDatabase
)
;
if
(
!
mActiveDatabases
.
Count
(
)
&
&
mPendingUsageDeltas
.
Length
(
)
)
{
int64_t
finalDelta
=
0
;
for
(
auto
delta
:
mPendingUsageDeltas
)
{
finalDelta
+
=
delta
;
}
MOZ_ASSERT
(
finalDelta
<
=
0
)
;
if
(
finalDelta
!
=
0
)
{
DebugOnly
<
bool
>
ok
=
UpdateUsage
(
finalDelta
)
;
MOZ_ASSERT
(
ok
)
;
}
mPendingUsageDeltas
.
Clear
(
)
;
}
}
void
Datastore
:
:
GetSnapshotLoadInfo
(
const
nsString
&
aKey
bool
&
aAddKeyToUnknownItems
nsTHashtable
<
nsStringHashKey
>
&
aLoadedItems
nsTArray
<
LSItemInfo
>
&
aItemInfos
uint32_t
&
aNextLoadIndex
LSSnapshot
:
:
LoadState
&
aLoadState
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
!
mInUpdateBatch
)
;
#
ifdef
DEBUG
int64_t
sizeOfKeys
=
0
;
int64_t
sizeOfItems
=
0
;
for
(
auto
item
:
mOrderedItems
)
{
int64_t
sizeOfKey
=
static_cast
<
int64_t
>
(
item
.
key
(
)
.
Length
(
)
)
;
sizeOfKeys
+
=
sizeOfKey
;
sizeOfItems
+
=
sizeOfKey
+
static_cast
<
int64_t
>
(
item
.
value
(
)
.
Length
(
)
)
;
}
MOZ_ASSERT
(
mSizeOfKeys
=
=
sizeOfKeys
)
;
MOZ_ASSERT
(
mSizeOfItems
=
=
sizeOfItems
)
;
#
endif
auto
GetLoadState
=
[
&
]
(
auto
aKeyLength
auto
aValueLength
)
{
if
(
mSizeOfKeys
-
aKeyLength
<
=
gSnapshotPrefill
)
{
if
(
mSizeOfItems
-
aKeyLength
-
aValueLength
<
=
gSnapshotPrefill
)
{
return
LSSnapshot
:
:
LoadState
:
:
AllOrderedItems
;
}
return
LSSnapshot
:
:
LoadState
:
:
AllOrderedKeys
;
}
return
LSSnapshot
:
:
LoadState
:
:
Partial
;
}
;
LSValue
value
;
bool
checkKey
=
false
;
LSSnapshot
:
:
LoadState
loadState
=
GetLoadState
(
0
0
)
;
if
(
loadState
!
=
LSSnapshot
:
:
LoadState
:
:
AllOrderedItems
&
&
!
aKey
.
IsVoid
(
)
)
{
GetItem
(
aKey
value
)
;
if
(
!
value
.
IsVoid
(
)
)
{
checkKey
=
true
;
loadState
=
GetLoadState
(
aKey
.
Length
(
)
value
.
Length
(
)
)
;
}
}
switch
(
loadState
)
{
case
LSSnapshot
:
:
LoadState
:
:
AllOrderedItems
:
{
aItemInfos
.
AppendElements
(
mOrderedItems
)
;
MOZ_ASSERT
(
aItemInfos
.
Length
(
)
=
=
mValues
.
Count
(
)
)
;
aNextLoadIndex
=
mValues
.
Count
(
)
;
aAddKeyToUnknownItems
=
false
;
break
;
}
case
LSSnapshot
:
:
LoadState
:
:
AllOrderedKeys
:
{
int64_t
size
=
mSizeOfKeys
;
bool
setVoidValue
=
false
;
bool
doneSendingValues
=
false
;
for
(
uint32_t
index
=
0
;
index
<
mOrderedItems
.
Length
(
)
;
index
+
+
)
{
const
LSItemInfo
&
item
=
mOrderedItems
[
index
]
;
const
nsString
&
key
=
item
.
key
(
)
;
const
LSValue
&
value
=
item
.
value
(
)
;
if
(
checkKey
&
&
key
=
=
aKey
)
{
checkKey
=
false
;
setVoidValue
=
false
;
}
else
if
(
!
setVoidValue
)
{
if
(
doneSendingValues
)
{
setVoidValue
=
true
;
}
else
{
size
+
=
static_cast
<
int64_t
>
(
value
.
Length
(
)
)
;
if
(
size
>
gSnapshotPrefill
)
{
setVoidValue
=
true
;
doneSendingValues
=
true
;
aNextLoadIndex
=
index
;
}
}
}
LSItemInfo
*
itemInfo
=
aItemInfos
.
AppendElement
(
)
;
itemInfo
-
>
key
(
)
=
key
;
if
(
setVoidValue
)
{
itemInfo
-
>
value
(
)
.
SetIsVoid
(
true
)
;
}
else
{
aLoadedItems
.
PutEntry
(
key
)
;
itemInfo
-
>
value
(
)
=
value
;
}
}
aAddKeyToUnknownItems
=
false
;
break
;
}
case
LSSnapshot
:
:
LoadState
:
:
Partial
:
{
int64_t
size
=
0
;
for
(
uint32_t
index
=
0
;
index
<
mOrderedItems
.
Length
(
)
;
index
+
+
)
{
const
LSItemInfo
&
item
=
mOrderedItems
[
index
]
;
const
nsString
&
key
=
item
.
key
(
)
;
const
LSValue
&
value
=
item
.
value
(
)
;
if
(
checkKey
&
&
key
=
=
aKey
)
{
checkKey
=
false
;
}
else
{
size
+
=
static_cast
<
int64_t
>
(
key
.
Length
(
)
)
+
static_cast
<
int64_t
>
(
value
.
Length
(
)
)
;
if
(
size
>
gSnapshotPrefill
)
{
aNextLoadIndex
=
index
;
break
;
}
}
aLoadedItems
.
PutEntry
(
key
)
;
LSItemInfo
*
itemInfo
=
aItemInfos
.
AppendElement
(
)
;
itemInfo
-
>
key
(
)
=
key
;
itemInfo
-
>
value
(
)
=
value
;
}
aAddKeyToUnknownItems
=
false
;
if
(
!
aKey
.
IsVoid
(
)
)
{
if
(
value
.
IsVoid
(
)
)
{
aAddKeyToUnknownItems
=
true
;
}
else
if
(
checkKey
)
{
LSItemInfo
*
itemInfo
=
aItemInfos
.
AppendElement
(
)
;
itemInfo
-
>
key
(
)
=
aKey
;
itemInfo
-
>
value
(
)
=
value
;
}
}
MOZ_ASSERT
(
aItemInfos
.
Length
(
)
<
mOrderedItems
.
Length
(
)
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Bad
load
state
value
!
"
)
;
}
aLoadState
=
loadState
;
}
void
Datastore
:
:
GetItem
(
const
nsString
&
aKey
LSValue
&
aValue
)
const
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mClosed
)
;
if
(
!
mValues
.
Get
(
aKey
&
aValue
)
)
{
aValue
.
SetIsVoid
(
true
)
;
}
}
void
Datastore
:
:
GetKeys
(
nsTArray
<
nsString
>
&
aKeys
)
const
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mClosed
)
;
for
(
auto
item
:
mOrderedItems
)
{
aKeys
.
AppendElement
(
item
.
key
(
)
)
;
}
}
void
Datastore
:
:
SetItem
(
Database
*
aDatabase
const
nsString
&
aKey
const
LSValue
&
aValue
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
LSValue
oldValue
;
GetItem
(
aKey
oldValue
)
;
if
(
oldValue
!
=
aValue
)
{
bool
isNewItem
=
oldValue
.
IsVoid
(
)
;
NotifySnapshots
(
aDatabase
aKey
oldValue
isNewItem
)
;
mValues
.
Put
(
aKey
aValue
)
;
int64_t
delta
;
if
(
isNewItem
)
{
mWriteOptimizer
.
InsertItem
(
aKey
aValue
)
;
int64_t
sizeOfKey
=
static_cast
<
int64_t
>
(
aKey
.
Length
(
)
)
;
delta
=
sizeOfKey
+
static_cast
<
int64_t
>
(
aValue
.
UTF16Length
(
)
)
;
mUpdateBatchUsage
+
=
delta
;
mSizeOfKeys
+
=
sizeOfKey
;
mSizeOfItems
+
=
sizeOfKey
+
static_cast
<
int64_t
>
(
aValue
.
Length
(
)
)
;
}
else
{
mWriteOptimizer
.
UpdateItem
(
aKey
aValue
)
;
delta
=
static_cast
<
int64_t
>
(
aValue
.
UTF16Length
(
)
)
-
static_cast
<
int64_t
>
(
oldValue
.
UTF16Length
(
)
)
;
mUpdateBatchUsage
+
=
delta
;
mSizeOfItems
+
=
static_cast
<
int64_t
>
(
aValue
.
Length
(
)
)
-
static_cast
<
int64_t
>
(
oldValue
.
Length
(
)
)
;
}
if
(
IsPersistent
(
)
)
{
mConnection
-
>
SetItem
(
aKey
aValue
delta
isNewItem
)
;
}
}
}
void
Datastore
:
:
RemoveItem
(
Database
*
aDatabase
const
nsString
&
aKey
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
LSValue
oldValue
;
GetItem
(
aKey
oldValue
)
;
if
(
!
oldValue
.
IsVoid
(
)
)
{
NotifySnapshots
(
aDatabase
aKey
oldValue
true
)
;
mValues
.
Remove
(
aKey
)
;
mWriteOptimizer
.
DeleteItem
(
aKey
)
;
int64_t
sizeOfKey
=
static_cast
<
int64_t
>
(
aKey
.
Length
(
)
)
;
int64_t
delta
=
-
sizeOfKey
-
static_cast
<
int64_t
>
(
oldValue
.
UTF16Length
(
)
)
;
mUpdateBatchUsage
+
=
delta
;
mSizeOfKeys
-
=
sizeOfKey
;
mSizeOfItems
-
=
sizeOfKey
+
static_cast
<
int64_t
>
(
oldValue
.
Length
(
)
)
;
if
(
IsPersistent
(
)
)
{
mConnection
-
>
RemoveItem
(
aKey
delta
)
;
}
}
}
void
Datastore
:
:
Clear
(
Database
*
aDatabase
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mClosed
)
;
if
(
mValues
.
Count
(
)
)
{
int64_t
delta
=
0
;
for
(
auto
iter
=
mValues
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsAString
&
key
=
iter
.
Key
(
)
;
const
LSValue
&
value
=
iter
.
Data
(
)
;
delta
+
=
-
static_cast
<
int64_t
>
(
key
.
Length
(
)
)
-
static_cast
<
int64_t
>
(
value
.
UTF16Length
(
)
)
;
NotifySnapshots
(
aDatabase
key
value
true
)
;
}
mValues
.
Clear
(
)
;
if
(
mInUpdateBatch
)
{
mWriteOptimizer
.
Truncate
(
)
;
mUpdateBatchUsage
+
=
delta
;
}
else
{
mOrderedItems
.
Clear
(
)
;
DebugOnly
<
bool
>
ok
=
UpdateUsage
(
delta
)
;
MOZ_ASSERT
(
ok
)
;
}
mSizeOfKeys
=
0
;
mSizeOfItems
=
0
;
if
(
IsPersistent
(
)
)
{
mConnection
-
>
Clear
(
delta
)
;
}
}
}
void
Datastore
:
:
BeginUpdateBatch
(
int64_t
aSnapshotInitialUsage
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aSnapshotInitialUsage
>
=
0
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
mUpdateBatchUsage
=
=
-
1
)
;
MOZ_ASSERT
(
!
mInUpdateBatch
)
;
mUpdateBatchUsage
=
aSnapshotInitialUsage
;
if
(
IsPersistent
(
)
)
{
mConnection
-
>
BeginUpdateBatch
(
)
;
}
mInUpdateBatch
=
true
;
}
int64_t
Datastore
:
:
EndUpdateBatch
(
int64_t
aSnapshotPeakUsage
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
mInUpdateBatch
)
;
mWriteOptimizer
.
ApplyAndReset
(
mOrderedItems
)
;
MOZ_ASSERT
(
!
mWriteOptimizer
.
HasWrites
(
)
)
;
if
(
aSnapshotPeakUsage
>
=
0
)
{
int64_t
delta
=
mUpdateBatchUsage
-
aSnapshotPeakUsage
;
if
(
mActiveDatabases
.
Count
(
)
)
{
mPendingUsageDeltas
.
AppendElement
(
delta
)
;
}
else
{
MOZ_ASSERT
(
delta
<
=
0
)
;
if
(
delta
!
=
0
)
{
DebugOnly
<
bool
>
ok
=
UpdateUsage
(
delta
)
;
MOZ_ASSERT
(
ok
)
;
}
}
}
int64_t
result
=
mUpdateBatchUsage
;
mUpdateBatchUsage
=
-
1
;
if
(
IsPersistent
(
)
)
{
mConnection
-
>
EndUpdateBatch
(
)
;
}
mInUpdateBatch
=
false
;
return
result
;
}
int64_t
Datastore
:
:
RequestUpdateUsage
(
int64_t
aRequestedSize
int64_t
aMinSize
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aRequestedSize
>
0
)
;
MOZ_ASSERT
(
aMinSize
>
0
)
;
if
(
UpdateUsage
(
aRequestedSize
)
)
{
return
aRequestedSize
;
}
if
(
UpdateUsage
(
aMinSize
)
)
{
return
aMinSize
;
}
return
0
;
}
bool
Datastore
:
:
HasOtherProcessObservers
(
Database
*
aDatabase
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
if
(
!
gObservers
)
{
return
false
;
}
nsTArray
<
Observer
*
>
*
array
;
if
(
!
gObservers
-
>
Get
(
mGroupAndOrigin
.
mOrigin
&
array
)
)
{
return
false
;
}
MOZ_ASSERT
(
array
)
;
PBackgroundParent
*
databaseBackgroundActor
=
aDatabase
-
>
Manager
(
)
;
for
(
Observer
*
observer
:
*
array
)
{
if
(
observer
-
>
Manager
(
)
!
=
databaseBackgroundActor
)
{
return
true
;
}
}
return
false
;
}
void
Datastore
:
:
NotifyOtherProcessObservers
(
Database
*
aDatabase
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
LSValue
&
aOldValue
const
LSValue
&
aNewValue
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
if
(
!
gObservers
)
{
return
;
}
nsTArray
<
Observer
*
>
*
array
;
if
(
!
gObservers
-
>
Get
(
mGroupAndOrigin
.
mOrigin
&
array
)
)
{
return
;
}
MOZ_ASSERT
(
array
)
;
PBackgroundParent
*
databaseBackgroundActor
=
aDatabase
-
>
Manager
(
)
;
for
(
Observer
*
observer
:
*
array
)
{
if
(
observer
-
>
Manager
(
)
!
=
databaseBackgroundActor
)
{
observer
-
>
Observe
(
aDatabase
aDocumentURI
aKey
aOldValue
aNewValue
)
;
}
}
}
void
Datastore
:
:
NoteChangedObserverArray
(
const
nsTArray
<
Observer
*
>
&
aObservers
)
{
AssertIsOnBackgroundThread
(
)
;
for
(
auto
iter
=
mActiveDatabases
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Database
*
database
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
Snapshot
*
snapshot
=
database
-
>
GetSnapshot
(
)
;
MOZ_ASSERT
(
snapshot
)
;
if
(
snapshot
-
>
IsDirty
(
)
)
{
continue
;
}
bool
hasOtherProcessObservers
=
false
;
PBackgroundParent
*
databaseBackgroundActor
=
database
-
>
Manager
(
)
;
for
(
Observer
*
observer
:
aObservers
)
{
if
(
observer
-
>
Manager
(
)
!
=
databaseBackgroundActor
)
{
hasOtherProcessObservers
=
true
;
break
;
}
}
if
(
snapshot
-
>
HasOtherProcessObservers
(
)
!
=
hasOtherProcessObservers
)
{
snapshot
-
>
MarkDirty
(
)
;
}
}
}
void
Datastore
:
:
Stringify
(
nsACString
&
aResult
)
const
{
AssertIsOnBackgroundThread
(
)
;
aResult
.
AppendLiteral
(
"
DirectoryLock
:
"
)
;
aResult
.
AppendInt
(
!
!
mDirectoryLock
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
Connection
:
"
)
;
aResult
.
AppendInt
(
!
!
mConnection
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
QuotaObject
:
"
)
;
aResult
.
AppendInt
(
!
!
mQuotaObject
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
PrepareDatastoreOps
:
"
)
;
aResult
.
AppendInt
(
mPrepareDatastoreOps
.
Count
(
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
PreparedDatastores
:
"
)
;
aResult
.
AppendInt
(
mPreparedDatastores
.
Count
(
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
Databases
:
"
)
;
aResult
.
AppendInt
(
mDatabases
.
Count
(
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
ActiveDatabases
:
"
)
;
aResult
.
AppendInt
(
mActiveDatabases
.
Count
(
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
Origin
:
"
)
;
aResult
.
Append
(
AnonymizedOriginString
(
mGroupAndOrigin
.
mOrigin
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
PrivateBrowsingId
:
"
)
;
aResult
.
AppendInt
(
mPrivateBrowsingId
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
Closed
:
"
)
;
aResult
.
AppendInt
(
mClosed
)
;
}
bool
Datastore
:
:
UpdateUsage
(
int64_t
aDelta
)
{
AssertIsOnBackgroundThread
(
)
;
int64_t
newUsage
=
mUsage
+
aDelta
;
MOZ_ASSERT
(
newUsage
>
=
0
)
;
if
(
newUsage
>
StaticPrefs
:
:
dom_storage_default_quota
(
)
*
1024
)
{
return
false
;
}
if
(
IsPersistent
(
)
)
{
MOZ_ASSERT
(
mQuotaObject
)
;
if
(
!
mQuotaObject
-
>
MaybeUpdateSize
(
newUsage
true
)
)
{
return
false
;
}
}
mUsage
=
newUsage
;
return
true
;
}
void
Datastore
:
:
MaybeClose
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
!
mPrepareDatastoreOps
.
Count
(
)
&
&
!
mHasLivePrivateDatastore
&
&
!
mPreparedDatastores
.
Count
(
)
&
&
!
mDatabases
.
Count
(
)
)
{
Close
(
)
;
}
}
void
Datastore
:
:
ConnectionClosedCallback
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mQuotaObject
)
;
MOZ_ASSERT
(
mClosed
)
;
mQuotaObject
=
nullptr
;
bool
databaseWasNotAvailable
;
bool
hasCreatedDatabase
;
mConnection
-
>
GetFinishInfo
(
databaseWasNotAvailable
hasCreatedDatabase
)
;
if
(
databaseWasNotAvailable
&
&
!
hasCreatedDatabase
)
{
MOZ_ASSERT
(
mUsage
=
=
0
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
quotaManager
-
>
ResetUsageForClient
(
PERSISTENCE_TYPE_DEFAULT
mGroupAndOrigin
mozilla
:
:
dom
:
:
quota
:
:
Client
:
:
LS
)
;
}
mConnection
=
nullptr
;
mDirectoryLock
=
nullptr
;
CleanupMetadata
(
)
;
if
(
mCompleteCallback
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
mCompleteCallback
.
forget
(
)
)
)
;
}
}
void
Datastore
:
:
CleanupMetadata
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
gDatastores
)
;
MOZ_ASSERT
(
gDatastores
-
>
Get
(
mGroupAndOrigin
.
mOrigin
)
)
;
gDatastores
-
>
Remove
(
mGroupAndOrigin
.
mOrigin
)
;
if
(
!
gDatastores
-
>
Count
(
)
)
{
gDatastores
=
nullptr
;
}
}
void
Datastore
:
:
NotifySnapshots
(
Database
*
aDatabase
const
nsAString
&
aKey
const
LSValue
&
aOldValue
bool
aAffectsOrder
)
{
AssertIsOnBackgroundThread
(
)
;
for
(
auto
iter
=
mDatabases
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Database
*
database
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
MOZ_ASSERT
(
database
)
;
if
(
database
=
=
aDatabase
)
{
continue
;
}
Snapshot
*
snapshot
=
database
-
>
GetSnapshot
(
)
;
if
(
snapshot
)
{
snapshot
-
>
SaveItem
(
aKey
aOldValue
aAffectsOrder
)
;
}
}
}
void
PreparedDatastore
:
:
Destroy
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
gPreparedDatastores
)
;
DebugOnly
<
bool
>
removed
=
gPreparedDatastores
-
>
Remove
(
mDatastoreId
)
;
MOZ_ASSERT
(
removed
)
;
}
void
PreparedDatastore
:
:
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
AssertIsOnBackgroundThread
(
)
;
auto
*
self
=
static_cast
<
PreparedDatastore
*
>
(
aClosure
)
;
MOZ_ASSERT
(
self
)
;
self
-
>
Destroy
(
)
;
}
Database
:
:
Database
(
const
PrincipalInfo
&
aPrincipalInfo
const
Maybe
<
ContentParentId
>
&
aContentParentId
const
nsACString
&
aOrigin
uint32_t
aPrivateBrowsingId
)
:
mSnapshot
(
nullptr
)
mPrincipalInfo
(
aPrincipalInfo
)
mContentParentId
(
aContentParentId
)
mOrigin
(
aOrigin
)
mPrivateBrowsingId
(
aPrivateBrowsingId
)
mAllowedToClose
(
false
)
mActorDestroyed
(
false
)
mRequestedAllowToClose
(
false
)
#
ifdef
DEBUG
mActorWasAlive
(
false
)
#
endif
{
AssertIsOnBackgroundThread
(
)
;
}
Database
:
:
~
Database
(
)
{
MOZ_ASSERT_IF
(
mActorWasAlive
mAllowedToClose
)
;
MOZ_ASSERT_IF
(
mActorWasAlive
mActorDestroyed
)
;
}
void
Database
:
:
SetActorAlive
(
Datastore
*
aDatastore
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorWasAlive
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
#
ifdef
DEBUG
mActorWasAlive
=
true
;
#
endif
mDatastore
=
aDatastore
;
mDatastore
-
>
NoteLiveDatabase
(
this
)
;
if
(
!
gLiveDatabases
)
{
gLiveDatabases
=
new
LiveDatabaseArray
(
)
;
}
gLiveDatabases
-
>
AppendElement
(
this
)
;
}
void
Database
:
:
RegisterSnapshot
(
Snapshot
*
aSnapshot
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aSnapshot
)
;
MOZ_ASSERT
(
!
mSnapshot
)
;
MOZ_ASSERT
(
!
mAllowedToClose
)
;
mSnapshot
=
aSnapshot
;
mDatastore
-
>
NoteActiveDatabase
(
this
)
;
}
void
Database
:
:
UnregisterSnapshot
(
Snapshot
*
aSnapshot
)
{
MOZ_ASSERT
(
aSnapshot
)
;
MOZ_ASSERT
(
mSnapshot
=
=
aSnapshot
)
;
mSnapshot
=
nullptr
;
mDatastore
-
>
NoteInactiveDatabase
(
this
)
;
}
void
Database
:
:
RequestAllowToClose
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mRequestedAllowToClose
)
{
return
;
}
mRequestedAllowToClose
=
true
;
if
(
mActorDestroyed
)
{
MOZ_ASSERT
(
mAllowedToClose
)
;
return
;
}
if
(
NS_WARN_IF
(
!
SendRequestAllowToClose
(
)
)
&
&
!
mSnapshot
)
{
AllowToClose
(
)
;
}
}
void
Database
:
:
ForceKill
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mActorDestroyed
)
{
MOZ_ASSERT
(
mAllowedToClose
)
;
return
;
}
Unused
<
<
PBackgroundLSDatabaseParent
:
:
Send__delete__
(
this
)
;
}
void
Database
:
:
Stringify
(
nsACString
&
aResult
)
const
{
AssertIsOnBackgroundThread
(
)
;
aResult
.
AppendLiteral
(
"
SnapshotRegistered
:
"
)
;
aResult
.
AppendInt
(
!
!
mSnapshot
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
OtherProcessActor
:
"
)
;
aResult
.
AppendInt
(
BackgroundParent
:
:
IsOtherProcessActor
(
Manager
(
)
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
Origin
:
"
)
;
aResult
.
Append
(
AnonymizedOriginString
(
mOrigin
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
PrivateBrowsingId
:
"
)
;
aResult
.
AppendInt
(
mPrivateBrowsingId
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
AllowedToClose
:
"
)
;
aResult
.
AppendInt
(
mAllowedToClose
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
ActorDestroyed
:
"
)
;
aResult
.
AppendInt
(
mActorDestroyed
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
RequestedAllowToClose
:
"
)
;
aResult
.
AppendInt
(
mRequestedAllowToClose
)
;
}
void
Database
:
:
AllowToClose
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mAllowedToClose
)
;
MOZ_ASSERT
(
mDatastore
)
;
MOZ_ASSERT
(
!
mSnapshot
)
;
mAllowedToClose
=
true
;
mDatastore
-
>
NoteFinishedDatabase
(
this
)
;
mDatastore
=
nullptr
;
MOZ_ASSERT
(
gLiveDatabases
)
;
gLiveDatabases
-
>
RemoveElement
(
this
)
;
if
(
gLiveDatabases
-
>
IsEmpty
(
)
)
{
gLiveDatabases
=
nullptr
;
}
}
void
Database
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
mActorDestroyed
=
true
;
if
(
!
mAllowedToClose
)
{
AllowToClose
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
Database
:
:
RecvDeleteMe
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
IProtocol
*
mgr
=
Manager
(
)
;
if
(
!
PBackgroundLSDatabaseParent
:
:
Send__delete__
(
this
)
)
{
return
IPC_FAIL_NO_REASON
(
mgr
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Database
:
:
RecvAllowToClose
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
mAllowedToClose
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
AllowToClose
(
)
;
return
IPC_OK
(
)
;
}
PBackgroundLSSnapshotParent
*
Database
:
:
AllocPBackgroundLSSnapshotParent
(
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
bool
&
aIncreasePeakUsage
const
int64_t
&
aRequestedSize
const
int64_t
&
aMinSize
LSSnapshotInitInfo
*
aInitInfo
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
aIncreasePeakUsage
&
&
aRequestedSize
<
=
0
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
if
(
NS_WARN_IF
(
aIncreasePeakUsage
&
&
aMinSize
<
=
0
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
if
(
NS_WARN_IF
(
mAllowedToClose
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
nullptr
;
}
RefPtr
<
Snapshot
>
snapshot
=
new
Snapshot
(
this
aDocumentURI
)
;
return
snapshot
.
forget
(
)
.
take
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Database
:
:
RecvPBackgroundLSSnapshotConstructor
(
PBackgroundLSSnapshotParent
*
aActor
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
bool
&
aIncreasePeakUsage
const
int64_t
&
aRequestedSize
const
int64_t
&
aMinSize
LSSnapshotInitInfo
*
aInitInfo
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT_IF
(
aIncreasePeakUsage
aRequestedSize
>
0
)
;
MOZ_ASSERT_IF
(
aIncreasePeakUsage
aMinSize
>
0
)
;
MOZ_ASSERT
(
aInitInfo
)
;
MOZ_ASSERT
(
!
mAllowedToClose
)
;
auto
*
snapshot
=
static_cast
<
Snapshot
*
>
(
aActor
)
;
bool
addKeyToUnknownItems
;
nsTHashtable
<
nsStringHashKey
>
loadedItems
;
nsTArray
<
LSItemInfo
>
itemInfos
;
uint32_t
nextLoadIndex
;
LSSnapshot
:
:
LoadState
loadState
;
mDatastore
-
>
GetSnapshotLoadInfo
(
aKey
addKeyToUnknownItems
loadedItems
itemInfos
nextLoadIndex
loadState
)
;
nsTHashtable
<
nsStringHashKey
>
unknownItems
;
if
(
addKeyToUnknownItems
)
{
unknownItems
.
PutEntry
(
aKey
)
;
}
uint32_t
totalLength
=
mDatastore
-
>
GetLength
(
)
;
int64_t
initialUsage
=
mDatastore
-
>
GetUsage
(
)
;
int64_t
peakUsage
=
initialUsage
;
if
(
aIncreasePeakUsage
)
{
int64_t
size
=
mDatastore
-
>
RequestUpdateUsage
(
aRequestedSize
aMinSize
)
;
peakUsage
+
=
size
;
}
bool
hasOtherProcessObservers
=
mDatastore
-
>
HasOtherProcessObservers
(
this
)
;
snapshot
-
>
Init
(
loadedItems
unknownItems
nextLoadIndex
totalLength
initialUsage
peakUsage
loadState
hasOtherProcessObservers
)
;
RegisterSnapshot
(
snapshot
)
;
aInitInfo
-
>
addKeyToUnknownItems
(
)
=
addKeyToUnknownItems
;
aInitInfo
-
>
itemInfos
(
)
=
std
:
:
move
(
itemInfos
)
;
aInitInfo
-
>
totalLength
(
)
=
totalLength
;
aInitInfo
-
>
initialUsage
(
)
=
initialUsage
;
aInitInfo
-
>
peakUsage
(
)
=
peakUsage
;
aInitInfo
-
>
loadState
(
)
=
loadState
;
aInitInfo
-
>
hasOtherProcessObservers
(
)
=
hasOtherProcessObservers
;
return
IPC_OK
(
)
;
}
bool
Database
:
:
DeallocPBackgroundLSSnapshotParent
(
PBackgroundLSSnapshotParent
*
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
RefPtr
<
Snapshot
>
actor
=
dont_AddRef
(
static_cast
<
Snapshot
*
>
(
aActor
)
)
;
return
true
;
}
Snapshot
:
:
Snapshot
(
Database
*
aDatabase
const
nsAString
&
aDocumentURI
)
:
mDatabase
(
aDatabase
)
mDatastore
(
aDatabase
-
>
GetDatastore
(
)
)
mDocumentURI
(
aDocumentURI
)
mTotalLength
(
0
)
mUsage
(
-
1
)
mPeakUsage
(
-
1
)
mSavedKeys
(
false
)
mActorDestroyed
(
false
)
mFinishReceived
(
false
)
mLoadedReceived
(
false
)
mLoadedAllItems
(
false
)
mLoadKeysReceived
(
false
)
mSentMarkDirty
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
}
Snapshot
:
:
~
Snapshot
(
)
{
MOZ_ASSERT
(
mActorDestroyed
)
;
MOZ_ASSERT
(
mFinishReceived
)
;
}
void
Snapshot
:
:
SaveItem
(
const
nsAString
&
aKey
const
LSValue
&
aOldValue
bool
aAffectsOrder
)
{
AssertIsOnBackgroundThread
(
)
;
MarkDirty
(
)
;
if
(
mLoadedAllItems
)
{
return
;
}
if
(
!
mLoadedItems
.
GetEntry
(
aKey
)
&
&
!
mUnknownItems
.
GetEntry
(
aKey
)
)
{
LSValue
oldValue
(
aOldValue
)
;
mValues
.
LookupForAdd
(
aKey
)
.
OrInsert
(
[
oldValue
]
(
)
{
return
oldValue
;
}
)
;
}
if
(
aAffectsOrder
&
&
!
mSavedKeys
)
{
mDatastore
-
>
GetKeys
(
mKeys
)
;
mSavedKeys
=
true
;
}
}
void
Snapshot
:
:
MarkDirty
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
!
mSentMarkDirty
)
{
Unused
<
<
SendMarkDirty
(
)
;
mSentMarkDirty
=
true
;
}
}
void
Snapshot
:
:
Finish
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mDatabase
)
;
MOZ_ASSERT
(
mDatastore
)
;
MOZ_ASSERT
(
!
mFinishReceived
)
;
mDatastore
-
>
BeginUpdateBatch
(
mUsage
)
;
mDatastore
-
>
EndUpdateBatch
(
mPeakUsage
)
;
mDatabase
-
>
UnregisterSnapshot
(
this
)
;
mFinishReceived
=
true
;
}
void
Snapshot
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
mActorDestroyed
=
true
;
if
(
!
mFinishReceived
)
{
Finish
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvDeleteMe
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
IProtocol
*
mgr
=
Manager
(
)
;
if
(
!
PBackgroundLSSnapshotParent
:
:
Send__delete__
(
this
)
)
{
return
IPC_FAIL_NO_REASON
(
mgr
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvCheckpoint
(
nsTArray
<
LSWriteInfo
>
&
&
aWriteInfos
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mUsage
>
=
0
)
;
MOZ_ASSERT
(
mPeakUsage
>
=
mUsage
)
;
if
(
NS_WARN_IF
(
aWriteInfos
.
IsEmpty
(
)
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mHasOtherProcessObservers
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mDatastore
-
>
BeginUpdateBatch
(
mUsage
)
;
for
(
uint32_t
index
=
0
;
index
<
aWriteInfos
.
Length
(
)
;
index
+
+
)
{
const
LSWriteInfo
&
writeInfo
=
aWriteInfos
[
index
]
;
switch
(
writeInfo
.
type
(
)
)
{
case
LSWriteInfo
:
:
TLSSetItemInfo
:
{
const
LSSetItemInfo
&
info
=
writeInfo
.
get_LSSetItemInfo
(
)
;
mDatastore
-
>
SetItem
(
mDatabase
info
.
key
(
)
info
.
value
(
)
)
;
break
;
}
case
LSWriteInfo
:
:
TLSRemoveItemInfo
:
{
const
LSRemoveItemInfo
&
info
=
writeInfo
.
get_LSRemoveItemInfo
(
)
;
mDatastore
-
>
RemoveItem
(
mDatabase
info
.
key
(
)
)
;
break
;
}
case
LSWriteInfo
:
:
TLSClearInfo
:
{
mDatastore
-
>
Clear
(
mDatabase
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
}
mUsage
=
mDatastore
-
>
EndUpdateBatch
(
-
1
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvCheckpointAndNotify
(
nsTArray
<
LSWriteAndNotifyInfo
>
&
&
aWriteAndNotifyInfos
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mUsage
>
=
0
)
;
MOZ_ASSERT
(
mPeakUsage
>
=
mUsage
)
;
if
(
NS_WARN_IF
(
aWriteAndNotifyInfos
.
IsEmpty
(
)
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
!
mHasOtherProcessObservers
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mDatastore
-
>
BeginUpdateBatch
(
mUsage
)
;
for
(
uint32_t
index
=
0
;
index
<
aWriteAndNotifyInfos
.
Length
(
)
;
index
+
+
)
{
const
LSWriteAndNotifyInfo
&
writeAndNotifyInfo
=
aWriteAndNotifyInfos
[
index
]
;
switch
(
writeAndNotifyInfo
.
type
(
)
)
{
case
LSWriteAndNotifyInfo
:
:
TLSSetItemAndNotifyInfo
:
{
const
LSSetItemAndNotifyInfo
&
info
=
writeAndNotifyInfo
.
get_LSSetItemAndNotifyInfo
(
)
;
mDatastore
-
>
SetItem
(
mDatabase
info
.
key
(
)
info
.
value
(
)
)
;
mDatastore
-
>
NotifyOtherProcessObservers
(
mDatabase
mDocumentURI
info
.
key
(
)
info
.
oldValue
(
)
info
.
value
(
)
)
;
break
;
}
case
LSWriteAndNotifyInfo
:
:
TLSRemoveItemAndNotifyInfo
:
{
const
LSRemoveItemAndNotifyInfo
&
info
=
writeAndNotifyInfo
.
get_LSRemoveItemAndNotifyInfo
(
)
;
mDatastore
-
>
RemoveItem
(
mDatabase
info
.
key
(
)
)
;
mDatastore
-
>
NotifyOtherProcessObservers
(
mDatabase
mDocumentURI
info
.
key
(
)
info
.
oldValue
(
)
VoidLSValue
(
)
)
;
break
;
}
case
LSWriteAndNotifyInfo
:
:
TLSClearInfo
:
{
mDatastore
-
>
Clear
(
mDatabase
)
;
mDatastore
-
>
NotifyOtherProcessObservers
(
mDatabase
mDocumentURI
VoidString
(
)
VoidLSValue
(
)
VoidLSValue
(
)
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
}
mUsage
=
mDatastore
-
>
EndUpdateBatch
(
-
1
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvFinish
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
mFinishReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
Finish
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvLoaded
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
mFinishReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadedReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadedAllItems
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadKeysReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mLoadedReceived
=
true
;
mLoadedItems
.
Clear
(
)
;
mUnknownItems
.
Clear
(
)
;
mValues
.
Clear
(
)
;
mKeys
.
Clear
(
)
;
mLoadedAllItems
=
true
;
mLoadKeysReceived
=
true
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvLoadValueAndMoreItems
(
const
nsString
&
aKey
LSValue
*
aValue
nsTArray
<
LSItemInfo
>
*
aItemInfos
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aValue
)
;
MOZ_ASSERT
(
aItemInfos
)
;
MOZ_ASSERT
(
mDatastore
)
;
if
(
NS_WARN_IF
(
mFinishReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadedReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadedAllItems
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
mLoadedItems
.
GetEntry
(
aKey
)
|
|
mUnknownItems
.
GetEntry
(
aKey
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
auto
entry
=
mValues
.
Lookup
(
aKey
)
)
{
*
aValue
=
entry
.
Data
(
)
;
entry
.
Remove
(
)
;
}
else
{
mDatastore
-
>
GetItem
(
aKey
*
aValue
)
;
}
if
(
aValue
-
>
IsVoid
(
)
)
{
mUnknownItems
.
PutEntry
(
aKey
)
;
}
else
{
mLoadedItems
.
PutEntry
(
aKey
)
;
}
if
(
gSnapshotGradualPrefill
>
0
)
{
const
nsTArray
<
LSItemInfo
>
&
orderedItems
=
mDatastore
-
>
GetOrderedItems
(
)
;
uint32_t
length
;
if
(
mSavedKeys
)
{
length
=
mKeys
.
Length
(
)
;
}
else
{
length
=
orderedItems
.
Length
(
)
;
}
int64_t
size
=
0
;
while
(
mNextLoadIndex
<
length
)
{
nsString
key
;
if
(
mSavedKeys
)
{
key
=
mKeys
[
mNextLoadIndex
]
;
}
else
{
key
=
orderedItems
[
mNextLoadIndex
]
.
key
(
)
;
}
uint32_t
countBeforePut
=
mLoadedItems
.
Count
(
)
;
auto
loadedItemEntry
=
mLoadedItems
.
PutEntry
(
key
)
;
if
(
countBeforePut
!
=
mLoadedItems
.
Count
(
)
)
{
LSValue
value
;
auto
valueEntry
=
mValues
.
Lookup
(
key
)
;
if
(
valueEntry
)
{
value
=
valueEntry
.
Data
(
)
;
}
else
if
(
mSavedKeys
)
{
mDatastore
-
>
GetItem
(
nsString
(
key
)
value
)
;
}
else
{
value
=
orderedItems
[
mNextLoadIndex
]
.
value
(
)
;
}
MOZ_ASSERT
(
!
value
.
IsVoid
(
)
)
;
size
+
=
static_cast
<
int64_t
>
(
key
.
Length
(
)
)
+
static_cast
<
int64_t
>
(
value
.
Length
(
)
)
;
if
(
size
>
gSnapshotGradualPrefill
)
{
mLoadedItems
.
RemoveEntry
(
loadedItemEntry
)
;
break
;
}
if
(
valueEntry
)
{
valueEntry
.
Remove
(
)
;
}
LSItemInfo
*
itemInfo
=
aItemInfos
-
>
AppendElement
(
)
;
itemInfo
-
>
key
(
)
=
key
;
itemInfo
-
>
value
(
)
=
value
;
}
mNextLoadIndex
+
+
;
}
}
if
(
mLoadedItems
.
Count
(
)
=
=
mTotalLength
)
{
mLoadedItems
.
Clear
(
)
;
mUnknownItems
.
Clear
(
)
;
#
ifdef
DEBUG
for
(
auto
iter
=
mValues
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
MOZ_ASSERT
(
iter
.
Data
(
)
.
IsVoid
(
)
)
;
}
#
endif
mValues
.
Clear
(
)
;
mLoadedAllItems
=
true
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvLoadKeys
(
nsTArray
<
nsString
>
*
aKeys
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aKeys
)
;
MOZ_ASSERT
(
mDatastore
)
;
if
(
NS_WARN_IF
(
mFinishReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadedReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mLoadKeysReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mLoadKeysReceived
=
true
;
if
(
mSavedKeys
)
{
aKeys
-
>
AppendElements
(
std
:
:
move
(
mKeys
)
)
;
}
else
{
mDatastore
-
>
GetKeys
(
*
aKeys
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvIncreasePeakUsage
(
const
int64_t
&
aRequestedSize
const
int64_t
&
aMinSize
int64_t
*
aSize
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aSize
)
;
if
(
NS_WARN_IF
(
aRequestedSize
<
=
0
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
aMinSize
<
=
0
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
NS_WARN_IF
(
mFinishReceived
)
)
{
ASSERT_UNLESS_FUZZING
(
)
;
return
IPC_FAIL_NO_REASON
(
this
)
;
}
int64_t
size
=
mDatastore
-
>
RequestUpdateUsage
(
aRequestedSize
aMinSize
)
;
mPeakUsage
+
=
size
;
*
aSize
=
size
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
Snapshot
:
:
RecvPing
(
)
{
AssertIsOnBackgroundThread
(
)
;
return
IPC_OK
(
)
;
}
Observer
:
:
Observer
(
const
nsACString
&
aOrigin
)
:
mOrigin
(
aOrigin
)
mActorDestroyed
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
}
Observer
:
:
~
Observer
(
)
{
MOZ_ASSERT
(
mActorDestroyed
)
;
}
void
Observer
:
:
Observe
(
Database
*
aDatabase
const
nsString
&
aDocumentURI
const
nsString
&
aKey
const
LSValue
&
aOldValue
const
LSValue
&
aNewValue
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aDatabase
)
;
Unused
<
<
SendObserve
(
aDatabase
-
>
GetPrincipalInfo
(
)
aDatabase
-
>
PrivateBrowsingId
(
)
aDocumentURI
aKey
aOldValue
aNewValue
)
;
}
void
Observer
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
mActorDestroyed
=
true
;
MOZ_ASSERT
(
gObservers
)
;
nsTArray
<
Observer
*
>
*
array
;
gObservers
-
>
Get
(
mOrigin
&
array
)
;
MOZ_ASSERT
(
array
)
;
array
-
>
RemoveElement
(
this
)
;
if
(
RefPtr
<
Datastore
>
datastore
=
GetDatastore
(
mOrigin
)
)
{
datastore
-
>
NoteChangedObserverArray
(
*
array
)
;
}
if
(
array
-
>
IsEmpty
(
)
)
{
gObservers
-
>
Remove
(
mOrigin
)
;
}
if
(
!
gObservers
-
>
Count
(
)
)
{
gObservers
=
nullptr
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
Observer
:
:
RecvDeleteMe
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
IProtocol
*
mgr
=
Manager
(
)
;
if
(
!
PBackgroundLSObserverParent
:
:
Send__delete__
(
this
)
)
{
return
IPC_FAIL_NO_REASON
(
mgr
)
;
}
return
IPC_OK
(
)
;
}
LSRequestBase
:
:
LSRequestBase
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
:
mMainEventTarget
(
aMainEventTarget
)
mParams
(
aParams
)
mContentParentId
(
aContentParentId
)
mState
(
State
:
:
Initial
)
mWaitingForFinish
(
false
)
{
}
LSRequestBase
:
:
~
LSRequestBase
(
)
{
MOZ_ASSERT_IF
(
MayProceedOnNonOwningThread
(
)
mState
=
=
State
:
:
Initial
|
|
mState
=
=
State
:
:
Completed
)
;
}
void
LSRequestBase
:
:
Dispatch
(
)
{
AssertIsOnOwningThread
(
)
;
mState
=
State
:
:
StartingRequest
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
this
)
)
;
}
void
LSRequestBase
:
:
StringifyState
(
nsACString
&
aResult
)
const
{
AssertIsOnOwningThread
(
)
;
switch
(
mState
)
{
case
State
:
:
Initial
:
aResult
.
AppendLiteral
(
"
Initial
"
)
;
return
;
case
State
:
:
StartingRequest
:
aResult
.
AppendLiteral
(
"
StartingRequest
"
)
;
return
;
case
State
:
:
Nesting
:
aResult
.
AppendLiteral
(
"
Nesting
"
)
;
return
;
case
State
:
:
SendingReadyMessage
:
aResult
.
AppendLiteral
(
"
SendingReadyMessage
"
)
;
return
;
case
State
:
:
WaitingForFinish
:
aResult
.
AppendLiteral
(
"
WaitingForFinish
"
)
;
return
;
case
State
:
:
SendingResults
:
aResult
.
AppendLiteral
(
"
SendingResults
"
)
;
return
;
case
State
:
:
Completed
:
aResult
.
AppendLiteral
(
"
Completed
"
)
;
return
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
}
void
LSRequestBase
:
:
Stringify
(
nsACString
&
aResult
)
const
{
AssertIsOnOwningThread
(
)
;
aResult
.
AppendLiteral
(
"
State
:
"
)
;
StringifyState
(
aResult
)
;
}
void
LSRequestBase
:
:
Log
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
LS_LOG_TEST
(
)
)
{
return
;
}
LS_LOG
(
(
"
LSRequestBase
[
%
p
]
"
this
)
)
;
nsCString
state
;
StringifyState
(
state
)
;
LS_LOG
(
(
"
mState
:
%
s
"
state
.
get
(
)
)
)
;
}
nsresult
LSRequestBase
:
:
NestedRun
(
)
{
return
NS_OK
;
}
bool
LSRequestBase
:
:
VerifyRequestParams
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mParams
.
type
(
)
!
=
LSRequestParams
:
:
T__None
)
;
switch
(
mParams
.
type
(
)
)
{
case
LSRequestParams
:
:
TLSRequestPreloadDatastoreParams
:
{
const
LSRequestCommonParams
&
params
=
mParams
.
get_LSRequestPreloadDatastoreParams
(
)
.
commonParams
(
)
;
if
(
NS_WARN_IF
(
!
VerifyPrincipalInfo
(
params
.
principalInfo
(
)
params
.
storagePrincipalInfo
(
)
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
VerifyOriginKey
(
params
.
originKey
(
)
params
.
principalInfo
(
)
)
)
)
{
return
false
;
}
break
;
}
case
LSRequestParams
:
:
TLSRequestPrepareDatastoreParams
:
{
const
LSRequestPrepareDatastoreParams
&
params
=
mParams
.
get_LSRequestPrepareDatastoreParams
(
)
;
const
LSRequestCommonParams
&
commonParams
=
params
.
commonParams
(
)
;
if
(
NS_WARN_IF
(
!
VerifyPrincipalInfo
(
commonParams
.
principalInfo
(
)
commonParams
.
storagePrincipalInfo
(
)
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
VerifyClientId
(
mContentParentId
commonParams
.
principalInfo
(
)
params
.
clientId
(
)
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
VerifyOriginKey
(
commonParams
.
originKey
(
)
commonParams
.
principalInfo
(
)
)
)
)
{
return
false
;
}
break
;
}
case
LSRequestParams
:
:
TLSRequestPrepareObserverParams
:
{
const
LSRequestPrepareObserverParams
&
params
=
mParams
.
get_LSRequestPrepareObserverParams
(
)
;
if
(
NS_WARN_IF
(
!
VerifyPrincipalInfo
(
params
.
principalInfo
(
)
params
.
storagePrincipalInfo
(
)
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
VerifyClientId
(
mContentParentId
params
.
principalInfo
(
)
params
.
clientId
(
)
)
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
return
true
;
}
nsresult
LSRequestBase
:
:
StartRequest
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
StartingRequest
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
DEBUG
bool
trustParams
=
false
;
#
else
bool
trustParams
=
!
BackgroundParent
:
:
IsOtherProcessActor
(
Manager
(
)
)
;
#
endif
if
(
!
trustParams
&
&
NS_WARN_IF
(
!
VerifyRequestParams
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Start
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
LSRequestBase
:
:
SendReadyMessage
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingReadyMessage
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
MaybeSetFailureCode
(
NS_ERROR_FAILURE
)
;
}
nsresult
rv
=
SendReadyMessageInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MaybeSetFailureCode
(
rv
)
;
FinishInternal
(
)
;
}
}
nsresult
LSRequestBase
:
:
SendReadyMessageInternal
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingReadyMessage
)
;
if
(
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
SendReady
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mState
=
State
:
:
WaitingForFinish
;
mWaitingForFinish
=
true
;
return
NS_OK
;
}
void
LSRequestBase
:
:
Finish
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
WaitingForFinish
)
;
mWaitingForFinish
=
false
;
FinishInternal
(
)
;
}
void
LSRequestBase
:
:
FinishInternal
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingReadyMessage
|
|
mState
=
=
State
:
:
WaitingForFinish
)
;
mState
=
State
:
:
SendingResults
;
RefPtr
<
LSRequestBase
>
kungFuDeathGrip
=
this
;
MOZ_ALWAYS_SUCCEEDS
(
this
-
>
Run
(
)
)
;
}
void
LSRequestBase
:
:
SendResults
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingResults
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
MaybeSetFailureCode
(
NS_ERROR_FAILURE
)
;
}
if
(
MayProceed
(
)
)
{
LSRequestResponse
response
;
if
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
{
GetResponse
(
response
)
;
MOZ_ASSERT
(
response
.
type
(
)
!
=
LSRequestResponse
:
:
T__None
)
;
if
(
response
.
type
(
)
=
=
LSRequestResponse
:
:
Tnsresult
)
{
MOZ_ASSERT
(
NS_FAILED
(
response
.
get_nsresult
(
)
)
)
;
SetFailureCode
(
response
.
get_nsresult
(
)
)
;
}
}
else
{
response
=
ResultCode
(
)
;
}
Unused
<
<
PBackgroundLSRequestParent
:
:
Send__delete__
(
this
response
)
;
}
Cleanup
(
)
;
mState
=
State
:
:
Completed
;
}
NS_IMETHODIMP
LSRequestBase
:
:
Run
(
)
{
nsresult
rv
;
switch
(
mState
)
{
case
State
:
:
StartingRequest
:
rv
=
StartRequest
(
)
;
break
;
case
State
:
:
Nesting
:
rv
=
NestedRun
(
)
;
break
;
case
State
:
:
SendingReadyMessage
:
SendReadyMessage
(
)
;
return
NS_OK
;
case
State
:
:
SendingResults
:
SendResults
(
)
;
return
NS_OK
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
mState
!
=
State
:
:
SendingReadyMessage
)
{
MaybeSetFailureCode
(
rv
)
;
mState
=
State
:
:
SendingReadyMessage
;
if
(
IsOnOwningThread
(
)
)
{
SendReadyMessage
(
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
}
return
NS_OK
;
}
void
LSRequestBase
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnOwningThread
(
)
;
NoteComplete
(
)
;
if
(
mWaitingForFinish
)
{
Finish
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
LSRequestBase
:
:
RecvCancel
(
)
{
AssertIsOnOwningThread
(
)
;
Log
(
)
;
const
char
*
crashOnCancel
=
PR_GetEnv
(
"
LSNG_CRASH_ON_CANCEL
"
)
;
if
(
crashOnCancel
)
{
MOZ_CRASH
(
"
LSNG
:
Crash
on
cancel
.
"
)
;
}
IProtocol
*
mgr
=
Manager
(
)
;
if
(
!
PBackgroundLSRequestParent
:
:
Send__delete__
(
this
NS_ERROR_FAILURE
)
)
{
return
IPC_FAIL_NO_REASON
(
mgr
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
LSRequestBase
:
:
RecvFinish
(
)
{
AssertIsOnOwningThread
(
)
;
Finish
(
)
;
return
IPC_OK
(
)
;
}
PrepareDatastoreOp
:
:
PrepareDatastoreOp
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
:
LSRequestBase
(
aMainEventTarget
aParams
aContentParentId
)
mMainEventTarget
(
aMainEventTarget
)
mLoadDataOp
(
nullptr
)
mPrivateBrowsingId
(
0
)
mUsage
(
0
)
mSizeOfKeys
(
0
)
mSizeOfItems
(
0
)
mDatastoreId
(
0
)
mNestedState
(
NestedState
:
:
BeforeNesting
)
mForPreload
(
aParams
.
type
(
)
=
=
LSRequestParams
:
:
TLSRequestPreloadDatastoreParams
)
mDatabaseNotAvailable
(
false
)
mRequestedDirectoryLock
(
false
)
mInvalidated
(
false
)
#
ifdef
DEBUG
mDEBUGUsage
(
0
)
#
endif
{
MOZ_ASSERT
(
aParams
.
type
(
)
=
=
LSRequestParams
:
:
TLSRequestPreloadDatastoreParams
|
|
aParams
.
type
(
)
=
=
LSRequestParams
:
:
TLSRequestPrepareDatastoreParams
)
;
}
PrepareDatastoreOp
:
:
~
PrepareDatastoreOp
(
)
{
MOZ_ASSERT
(
!
mDirectoryLock
)
;
MOZ_ASSERT_IF
(
MayProceedOnNonOwningThread
(
)
mState
=
=
State
:
:
Initial
|
|
mState
=
=
State
:
:
Completed
)
;
MOZ_ASSERT
(
!
mLoadDataOp
)
;
}
void
PrepareDatastoreOp
:
:
StringifyNestedState
(
nsACString
&
aResult
)
const
{
AssertIsOnOwningThread
(
)
;
switch
(
mNestedState
)
{
case
NestedState
:
:
BeforeNesting
:
aResult
.
AppendLiteral
(
"
BeforeNesting
"
)
;
return
;
case
NestedState
:
:
CheckExistingOperations
:
aResult
.
AppendLiteral
(
"
CheckExistingOperations
"
)
;
return
;
case
NestedState
:
:
CheckClosingDatastore
:
aResult
.
AppendLiteral
(
"
CheckClosingDatastore
"
)
;
return
;
case
NestedState
:
:
PreparationPending
:
aResult
.
AppendLiteral
(
"
PreparationPending
"
)
;
return
;
case
NestedState
:
:
QuotaManagerPending
:
aResult
.
AppendLiteral
(
"
QuotaManagerPending
"
)
;
return
;
case
NestedState
:
:
DirectoryOpenPending
:
aResult
.
AppendLiteral
(
"
DirectoryOpenPending
"
)
;
return
;
case
NestedState
:
:
DatabaseWorkOpen
:
aResult
.
AppendLiteral
(
"
DatabaseWorkOpen
"
)
;
return
;
case
NestedState
:
:
BeginLoadData
:
aResult
.
AppendLiteral
(
"
BeginLoadData
"
)
;
return
;
case
NestedState
:
:
DatabaseWorkLoadData
:
aResult
.
AppendLiteral
(
"
DatabaseWorkLoadData
"
)
;
return
;
case
NestedState
:
:
AfterNesting
:
aResult
.
AppendLiteral
(
"
AfterNesting
"
)
;
return
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
}
void
PrepareDatastoreOp
:
:
Stringify
(
nsACString
&
aResult
)
const
{
AssertIsOnOwningThread
(
)
;
LSRequestBase
:
:
Stringify
(
aResult
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
Origin
:
"
)
;
aResult
.
Append
(
AnonymizedOriginString
(
Origin
(
)
)
)
;
aResult
.
Append
(
kQuotaGenericDelimiter
)
;
aResult
.
AppendLiteral
(
"
NestedState
:
"
)
;
StringifyNestedState
(
aResult
)
;
}
void
PrepareDatastoreOp
:
:
Log
(
)
{
AssertIsOnOwningThread
(
)
;
LSRequestBase
:
:
Log
(
)
;
if
(
!
LS_LOG_TEST
(
)
)
{
return
;
}
nsCString
nestedState
;
StringifyNestedState
(
nestedState
)
;
LS_LOG
(
(
"
mNestedState
:
%
s
"
nestedState
.
get
(
)
)
)
;
switch
(
mNestedState
)
{
case
NestedState
:
:
CheckClosingDatastore
:
{
for
(
uint32_t
index
=
gPrepareDatastoreOps
-
>
Length
(
)
;
index
>
0
;
index
-
-
)
{
PrepareDatastoreOp
*
existingOp
=
(
*
gPrepareDatastoreOps
)
[
index
-
1
]
;
if
(
existingOp
-
>
mDelayedOp
=
=
this
)
{
LS_LOG
(
(
"
mDelayedBy
:
[
%
p
]
"
existingOp
)
)
;
existingOp
-
>
Log
(
)
;
break
;
}
}
break
;
}
case
NestedState
:
:
DirectoryOpenPending
:
{
MOZ_ASSERT
(
mPendingDirectoryLock
)
;
LS_LOG
(
(
"
mPendingDirectoryLock
:
[
%
p
]
"
mPendingDirectoryLock
.
get
(
)
)
)
;
mPendingDirectoryLock
-
>
Log
(
)
;
break
;
}
default
:
;
}
}
nsresult
PrepareDatastoreOp
:
:
Start
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
StartingRequest
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
BeforeNesting
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
const
LSRequestCommonParams
&
commonParams
=
mForPreload
?
mParams
.
get_LSRequestPreloadDatastoreParams
(
)
.
commonParams
(
)
:
mParams
.
get_LSRequestPrepareDatastoreParams
(
)
.
commonParams
(
)
;
const
PrincipalInfo
&
storagePrincipalInfo
=
commonParams
.
storagePrincipalInfo
(
)
;
if
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
{
mQuotaInfo
=
QuotaManager
:
:
GetInfoForChrome
(
)
;
}
else
{
MOZ_ASSERT
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TContentPrincipalInfo
)
;
QuotaInfo
quotaInfo
=
QuotaManager
:
:
GetInfoFromValidatedPrincipalInfo
(
storagePrincipalInfo
)
;
mQuotaInfo
.
mSuffix
=
std
:
:
move
(
quotaInfo
.
mSuffix
)
;
mQuotaInfo
.
mGroup
=
std
:
:
move
(
quotaInfo
.
mGroup
)
;
mMainThreadOrigin
=
std
:
:
move
(
quotaInfo
.
mOrigin
)
;
}
mState
=
State
:
:
Nesting
;
mNestedState
=
NestedState
:
:
CheckExistingOperations
;
MOZ_ALWAYS_SUCCEEDS
(
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
CheckExistingOperations
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
CheckExistingOperations
)
;
MOZ_ASSERT
(
gPrepareDatastoreOps
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
const
LSRequestCommonParams
&
commonParams
=
mForPreload
?
mParams
.
get_LSRequestPreloadDatastoreParams
(
)
.
commonParams
(
)
:
mParams
.
get_LSRequestPrepareDatastoreParams
(
)
.
commonParams
(
)
;
const
PrincipalInfo
&
storagePrincipalInfo
=
commonParams
.
storagePrincipalInfo
(
)
;
nsCString
originAttrSuffix
;
uint32_t
privateBrowsingId
;
if
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
{
privateBrowsingId
=
0
;
}
else
{
MOZ_ASSERT
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TContentPrincipalInfo
)
;
const
ContentPrincipalInfo
&
info
=
storagePrincipalInfo
.
get_ContentPrincipalInfo
(
)
;
const
OriginAttributes
&
attrs
=
info
.
attrs
(
)
;
attrs
.
CreateSuffix
(
originAttrSuffix
)
;
privateBrowsingId
=
attrs
.
mPrivateBrowsingId
;
}
mArchivedOriginScope
=
ArchivedOriginScope
:
:
CreateFromOrigin
(
originAttrSuffix
commonParams
.
originKey
(
)
)
;
MOZ_ASSERT
(
mArchivedOriginScope
)
;
mQuotaInfo
.
mOrigin
=
mMainThreadOrigin
;
MOZ_ASSERT
(
OriginIsKnown
(
)
)
;
mPrivateBrowsingId
=
privateBrowsingId
;
mNestedState
=
NestedState
:
:
CheckClosingDatastore
;
bool
foundThis
=
false
;
for
(
uint32_t
index
=
gPrepareDatastoreOps
-
>
Length
(
)
;
index
>
0
;
index
-
-
)
{
PrepareDatastoreOp
*
existingOp
=
(
*
gPrepareDatastoreOps
)
[
index
-
1
]
;
if
(
existingOp
=
=
this
)
{
foundThis
=
true
;
continue
;
}
if
(
foundThis
&
&
existingOp
-
>
Origin
(
)
=
=
Origin
(
)
)
{
MOZ_ASSERT
(
!
existingOp
-
>
mDelayedOp
)
;
existingOp
-
>
mDelayedOp
=
this
;
return
NS_OK
;
}
}
nsresult
rv
=
CheckClosingDatastoreInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
CheckClosingDatastore
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
CheckClosingDatastore
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
CheckClosingDatastoreInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
CheckClosingDatastoreInternal
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
CheckClosingDatastore
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
mNestedState
=
NestedState
:
:
PreparationPending
;
RefPtr
<
Datastore
>
datastore
;
if
(
(
datastore
=
GetDatastore
(
Origin
(
)
)
)
&
&
datastore
-
>
IsClosed
(
)
)
{
datastore
-
>
WaitForConnectionToComplete
(
this
)
;
return
NS_OK
;
}
nsresult
rv
=
BeginDatastorePreparationInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
BeginDatastorePreparation
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
PreparationPending
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
BeginDatastorePreparationInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
BeginDatastorePreparationInternal
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
PreparationPending
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
if
(
(
mDatastore
=
GetDatastore
(
Origin
(
)
)
)
)
{
MOZ_ASSERT
(
!
mDatastore
-
>
IsClosed
(
)
)
;
mDatastore
-
>
NoteLivePrepareDatastoreOp
(
this
)
;
FinishNesting
(
)
;
return
NS_OK
;
}
if
(
QuotaManager
:
:
Get
(
)
)
{
nsresult
rv
=
OpenDirectory
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
mNestedState
=
NestedState
:
:
QuotaManagerPending
;
QuotaManager
:
:
GetOrCreate
(
this
mMainEventTarget
)
;
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
QuotaManagerOpen
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
QuotaManagerPending
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
Get
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
OpenDirectory
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
OpenDirectory
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
PreparationPending
|
|
mNestedState
=
=
NestedState
:
:
QuotaManagerPending
)
;
MOZ_ASSERT
(
OriginIsKnown
(
)
)
;
MOZ_ASSERT
(
!
mDirectoryLock
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
MOZ_ASSERT
(
QuotaManager
:
:
Get
(
)
)
;
mNestedState
=
NestedState
:
:
DirectoryOpenPending
;
mPendingDirectoryLock
=
QuotaManager
:
:
Get
(
)
-
>
OpenDirectory
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
mozilla
:
:
dom
:
:
quota
:
:
Client
:
:
LS
false
this
)
;
mRequestedDirectoryLock
=
true
;
return
NS_OK
;
}
void
PrepareDatastoreOp
:
:
SendToIOThread
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
DirectoryOpenPending
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
if
(
mPrivateBrowsingId
)
{
FinishNesting
(
)
;
return
;
}
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
mNestedState
=
NestedState
:
:
DatabaseWorkOpen
;
MOZ_ALWAYS_SUCCEEDS
(
quotaManager
-
>
IOThread
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
nsresult
PrepareDatastoreOp
:
:
DatabaseWork
(
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
mArchivedOriginScope
)
;
MOZ_ASSERT
(
mUsage
=
=
0
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
DatabaseWorkOpen
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnNonBackgroundThread
(
)
)
|
|
!
MayProceedOnNonOwningThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
nsresult
rv
=
quotaManager
-
>
EnsureStorageIsInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
quotaManager
-
>
EnsureTemporaryStorageIsInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
const
UsageInfo
usageInfo
=
quotaManager
-
>
GetUsageForClient
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
mozilla
:
:
dom
:
:
quota
:
:
Client
:
:
LS
)
;
const
bool
hasUsage
=
usageInfo
.
DatabaseUsage
(
)
.
isSome
(
)
;
MOZ_ASSERT
(
usageInfo
.
FileUsage
(
)
.
isNothing
(
)
)
;
if
(
!
gArchivedOrigins
)
{
rv
=
LoadArchivedOrigins
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
gArchivedOrigins
)
;
}
bool
hasDataForMigration
=
mArchivedOriginScope
-
>
HasMatches
(
gArchivedOrigins
)
;
if
(
mForPreload
&
&
!
hasUsage
&
&
!
hasDataForMigration
)
{
return
DatabaseNotAvailable
(
)
;
}
LS_TRY_INSPECT
(
const
auto
&
directoryEntry
(
[
hasDataForMigration
&
quotaManager
this
]
(
)
-
>
mozilla
:
:
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
{
if
(
hasDataForMigration
)
{
LS_TRY_RETURN
(
quotaManager
-
>
EnsureStorageAndOriginIsInitialized
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
)
)
;
}
else
{
LS_TRY_UNWRAP
(
auto
directoryEntry
quotaManager
-
>
GetDirectoryForOrigin
(
PERSISTENCE_TYPE_DEFAULT
Origin
(
)
)
)
;
quotaManager
-
>
EnsureQuotaForOrigin
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
)
;
return
directoryEntry
;
}
}
(
)
)
)
;
rv
=
directoryEntry
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
LS_DIRECTORY_NAME
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsString
directoryPath
;
rv
=
directoryEntry
-
>
GetPath
(
directoryPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
EnsureDirectoryEntry
(
directoryEntry
hasDataForMigration
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
directoryEntry
-
>
Append
(
kDataFileName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
directoryEntry
-
>
GetPath
(
mDatabaseFilePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
alreadyExisted
;
rv
=
EnsureDirectoryEntry
(
directoryEntry
hasDataForMigration
false
&
alreadyExisted
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
alreadyExisted
)
{
MOZ_ASSERT
(
hasUsage
)
;
mUsage
=
usageInfo
.
DatabaseUsage
(
)
.
value
(
)
;
}
else
{
MOZ_ASSERT
(
!
hasUsage
)
;
if
(
!
hasDataForMigration
)
{
return
DatabaseNotAvailable
(
)
;
}
}
RefPtr
<
QuotaObject
>
quotaObject
;
nsCOMPtr
<
nsIFile
>
usageFile
;
rv
=
GetUsageFile
(
directoryPath
getter_AddRefs
(
usageFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
usageJournalFile
;
rv
=
GetUsageJournalFile
(
directoryPath
getter_AddRefs
(
usageJournalFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageConnection
>
connection
;
bool
removedUsageFile
;
rv
=
CreateStorageConnection
(
directoryEntry
usageFile
Origin
(
)
getter_AddRefs
(
connection
)
&
removedUsageFile
)
;
if
(
removedUsageFile
)
{
if
(
!
quotaObject
)
{
quotaObject
=
GetQuotaObject
(
)
;
if
(
!
quotaObject
)
{
return
NS_ERROR_FAILURE
;
}
}
MOZ_ALWAYS_TRUE
(
quotaObject
-
>
MaybeUpdateSize
(
0
true
)
)
;
mUsage
=
0
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
VerifyDatabaseInformation
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
hasDataForMigration
)
{
MOZ_ASSERT
(
mUsage
=
=
0
)
;
rv
=
AttachArchiveDatabase
(
quotaManager
-
>
GetStoragePath
(
)
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int64_t
newUsage
;
rv
=
GetUsage
(
connection
mArchivedOriginScope
.
get
(
)
&
newUsage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
quotaObject
)
{
quotaObject
=
GetQuotaObject
(
)
;
if
(
!
quotaObject
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
!
quotaObject
-
>
MaybeUpdateSize
(
newUsage
true
)
)
{
return
NS_ERROR_FILE_NO_DEVICE_SPACE
;
}
auto
autoUpdateSize
=
MakeScopeExit
(
[
&
quotaObject
]
{
MOZ_ALWAYS_TRUE
(
quotaObject
-
>
MaybeUpdateSize
(
0
true
)
)
;
}
)
;
mozStorageTransaction
transaction
(
connection
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
nsCOMPtr
<
mozIStorageFunction
>
function
=
new
CompressFunction
(
)
;
rv
=
connection
-
>
CreateFunction
(
"
compress
"
_ns
1
function
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
function
=
new
CompressibleFunction
(
)
;
rv
=
connection
-
>
CreateFunction
(
"
compressible
"
_ns
1
function
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
connection
-
>
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
data
(
key
value
utf16Length
compressed
)
"
"
SELECT
key
compress
(
value
)
utf16Length
(
value
)
"
"
compressible
(
value
)
"
"
FROM
webappsstore2
"
"
WHERE
originKey
=
:
originKey
"
"
AND
originAttributes
=
:
originAttributes
;
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mArchivedOriginScope
-
>
BindToStatement
(
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
connection
-
>
RemoveFunction
(
"
compress
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
connection
-
>
RemoveFunction
(
"
compressible
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
connection
-
>
CreateStatement
(
"
UPDATE
database
SET
usage
=
:
usage
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
BindInt64ByName
(
"
usage
"
_ns
newUsage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
connection
-
>
CreateStatement
(
nsLiteralCString
(
"
DELETE
FROM
webappsstore2
"
"
WHERE
originKey
=
:
originKey
"
"
AND
originAttributes
=
:
originAttributes
;
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mArchivedOriginScope
-
>
BindToStatement
(
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
UpdateUsageFile
(
usageFile
usageJournalFile
newUsage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
transaction
.
Commit
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
autoUpdateSize
.
release
(
)
;
rv
=
usageJournalFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
DetachArchiveDatabase
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
gArchivedOrigins
)
;
MOZ_ASSERT
(
mArchivedOriginScope
-
>
HasMatches
(
gArchivedOrigins
)
)
;
mArchivedOriginScope
-
>
RemoveMatches
(
gArchivedOrigins
)
;
mUsage
=
newUsage
;
}
nsCOMPtr
<
mozIStorageConnection
>
shadowConnection
;
if
(
!
gInitializedShadowStorage
)
{
rv
=
CreateShadowStorageConnection
(
quotaManager
-
>
GetBasePath
(
)
getter_AddRefs
(
shadowConnection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
gInitializedShadowStorage
=
true
;
}
MOZ_ALWAYS_SUCCEEDS
(
connection
-
>
Close
(
)
)
;
if
(
shadowConnection
)
{
MOZ_ALWAYS_SUCCEEDS
(
shadowConnection
-
>
Close
(
)
)
;
}
mNestedState
=
NestedState
:
:
BeginLoadData
;
rv
=
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
DatabaseNotAvailable
(
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
DatabaseWorkOpen
)
;
mDatabaseNotAvailable
=
true
;
nsresult
rv
=
FinishNestingOnNonOwningThread
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
EnsureDirectoryEntry
(
nsIFile
*
aEntry
bool
aCreateIfNotExists
bool
aIsDirectory
bool
*
aAlreadyExisted
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aEntry
)
;
bool
exists
;
nsresult
rv
=
aEntry
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
exists
)
{
if
(
!
aCreateIfNotExists
)
{
if
(
aAlreadyExisted
)
{
*
aAlreadyExisted
=
false
;
}
return
NS_OK
;
}
if
(
aIsDirectory
)
{
rv
=
aEntry
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
#
ifdef
DEBUG
else
{
bool
isDirectory
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aEntry
-
>
IsDirectory
(
&
isDirectory
)
)
)
;
MOZ_ASSERT
(
isDirectory
=
=
aIsDirectory
)
;
}
#
endif
if
(
aAlreadyExisted
)
{
*
aAlreadyExisted
=
exists
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
VerifyDatabaseInformation
(
mozIStorageConnection
*
aConnection
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
nsresult
rv
=
aConnection
-
>
CreateStatement
(
nsLiteralCString
(
"
SELECT
origin
"
"
FROM
database
"
)
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
hasResult
;
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
hasResult
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
nsCString
origin
;
rv
=
stmt
-
>
GetUTF8String
(
0
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
AreOriginsEqualOnDisk
(
Origin
(
)
origin
)
)
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
return
NS_OK
;
}
already_AddRefed
<
QuotaObject
>
PrepareDatastoreOp
:
:
GetQuotaObject
(
)
{
MOZ_ASSERT
(
IsOnOwningThread
(
)
|
|
IsOnIOThread
(
)
)
;
MOZ_ASSERT
(
!
mQuotaInfo
.
mGroup
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
OriginIsKnown
(
)
)
;
MOZ_ASSERT
(
!
mDatabaseFilePath
.
IsEmpty
(
)
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
RefPtr
<
QuotaObject
>
quotaObject
=
quotaManager
-
>
GetQuotaObject
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
mozilla
:
:
dom
:
:
quota
:
:
Client
:
:
LS
mDatabaseFilePath
mUsage
)
;
if
(
!
quotaObject
)
{
LS_WARNING
(
"
Failed
to
get
quota
object
for
group
(
%
s
)
and
origin
(
%
s
)
!
"
mQuotaInfo
.
mGroup
.
get
(
)
Origin
(
)
.
get
(
)
)
;
}
return
quotaObject
.
forget
(
)
;
}
nsresult
PrepareDatastoreOp
:
:
BeginLoadData
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
BeginLoadData
)
;
MOZ_ASSERT
(
!
mConnection
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
gConnectionThread
)
{
gConnectionThread
=
new
ConnectionThread
(
)
;
}
mConnection
=
gConnectionThread
-
>
CreateConnection
(
mQuotaInfo
std
:
:
move
(
mArchivedOriginScope
)
false
)
;
MOZ_ASSERT
(
mConnection
)
;
mNestedState
=
NestedState
:
:
DatabaseWorkLoadData
;
RefPtr
<
LoadDataOp
>
loadDataOp
=
new
LoadDataOp
(
this
)
;
mConnection
-
>
Dispatch
(
loadDataOp
)
;
mLoadDataOp
=
loadDataOp
;
return
NS_OK
;
}
void
PrepareDatastoreOp
:
:
FinishNesting
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
mState
=
State
:
:
SendingReadyMessage
;
mNestedState
=
NestedState
:
:
AfterNesting
;
MOZ_ALWAYS_SUCCEEDS
(
Run
(
)
)
;
}
nsresult
PrepareDatastoreOp
:
:
FinishNestingOnNonOwningThread
(
)
{
MOZ_ASSERT
(
!
IsOnOwningThread
(
)
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
mState
=
State
:
:
SendingReadyMessage
;
mNestedState
=
NestedState
:
:
AfterNesting
;
nsresult
rv
=
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
PrepareDatastoreOp
:
:
NestedRun
(
)
{
nsresult
rv
;
switch
(
mNestedState
)
{
case
NestedState
:
:
CheckExistingOperations
:
rv
=
CheckExistingOperations
(
)
;
break
;
case
NestedState
:
:
CheckClosingDatastore
:
rv
=
CheckClosingDatastore
(
)
;
break
;
case
NestedState
:
:
PreparationPending
:
rv
=
BeginDatastorePreparation
(
)
;
break
;
case
NestedState
:
:
QuotaManagerPending
:
rv
=
QuotaManagerOpen
(
)
;
break
;
case
NestedState
:
:
DatabaseWorkOpen
:
rv
=
DatabaseWork
(
)
;
break
;
case
NestedState
:
:
BeginLoadData
:
rv
=
BeginLoadData
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mNestedState
=
NestedState
:
:
AfterNesting
;
return
rv
;
}
return
NS_OK
;
}
void
PrepareDatastoreOp
:
:
GetResponse
(
LSRequestResponse
&
aResponse
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingResults
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
if
(
mDatabaseNotAvailable
&
&
mForPreload
)
{
LSRequestPreloadDatastoreResponse
preloadDatastoreResponse
;
aResponse
=
preloadDatastoreResponse
;
return
;
}
if
(
!
mDatastore
)
{
MOZ_ASSERT
(
mUsage
=
=
mDEBUGUsage
)
;
RefPtr
<
QuotaObject
>
quotaObject
;
if
(
mPrivateBrowsingId
=
=
0
)
{
if
(
!
mConnection
)
{
MOZ_ASSERT
(
mDatabaseNotAvailable
)
;
if
(
!
gConnectionThread
)
{
gConnectionThread
=
new
ConnectionThread
(
)
;
}
mConnection
=
gConnectionThread
-
>
CreateConnection
(
mQuotaInfo
std
:
:
move
(
mArchivedOriginScope
)
true
)
;
MOZ_ASSERT
(
mConnection
)
;
}
quotaObject
=
GetQuotaObject
(
)
;
if
(
!
quotaObject
)
{
aResponse
=
NS_ERROR_FAILURE
;
return
;
}
}
mDatastore
=
new
Datastore
(
mQuotaInfo
mPrivateBrowsingId
mUsage
mSizeOfKeys
mSizeOfItems
std
:
:
move
(
mDirectoryLock
)
std
:
:
move
(
mConnection
)
std
:
:
move
(
quotaObject
)
mValues
std
:
:
move
(
mOrderedItems
)
)
;
mDatastore
-
>
NoteLivePrepareDatastoreOp
(
this
)
;
if
(
!
gDatastores
)
{
gDatastores
=
new
DatastoreHashtable
(
)
;
}
MOZ_ASSERT
(
!
gDatastores
-
>
Get
(
Origin
(
)
)
)
;
gDatastores
-
>
Put
(
Origin
(
)
mDatastore
)
;
}
if
(
mPrivateBrowsingId
&
&
!
mInvalidated
)
{
if
(
!
gPrivateDatastores
)
{
gPrivateDatastores
=
MakeUnique
<
PrivateDatastoreHashtable
>
(
)
;
}
if
(
!
gPrivateDatastores
-
>
Get
(
Origin
(
)
)
)
{
auto
privateDatastore
=
MakeUnique
<
PrivateDatastore
>
(
WrapMovingNotNull
(
mDatastore
)
)
;
gPrivateDatastores
-
>
Put
(
Origin
(
)
std
:
:
move
(
privateDatastore
)
)
;
mPrivateDatastoreRegistered
.
Flip
(
)
;
}
}
mDatastoreId
=
+
+
gLastDatastoreId
;
auto
preparedDatastore
=
MakeUnique
<
PreparedDatastore
>
(
mDatastore
mContentParentId
Origin
(
)
mDatastoreId
mForPreload
)
;
if
(
!
gPreparedDatastores
)
{
gPreparedDatastores
=
new
PreparedDatastoreHashtable
(
)
;
}
gPreparedDatastores
-
>
Put
(
mDatastoreId
preparedDatastore
.
get
(
)
)
;
if
(
mInvalidated
)
{
preparedDatastore
-
>
Invalidate
(
)
;
}
mPreparedDatastoreRegistered
.
Flip
(
)
;
Unused
<
<
preparedDatastore
.
release
(
)
;
if
(
mForPreload
)
{
LSRequestPreloadDatastoreResponse
preloadDatastoreResponse
;
aResponse
=
preloadDatastoreResponse
;
}
else
{
LSRequestPrepareDatastoreResponse
prepareDatastoreResponse
;
prepareDatastoreResponse
.
datastoreId
(
)
=
mDatastoreId
;
aResponse
=
prepareDatastoreResponse
;
}
}
void
PrepareDatastoreOp
:
:
Cleanup
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mDatastore
)
{
MOZ_ASSERT
(
!
mDirectoryLock
)
;
MOZ_ASSERT
(
!
mConnection
)
;
if
(
NS_FAILED
(
ResultCode
(
)
)
)
{
if
(
mPrivateDatastoreRegistered
)
{
MOZ_ASSERT
(
gPrivateDatastores
)
;
DebugOnly
<
bool
>
removed
=
gPrivateDatastores
-
>
Remove
(
Origin
(
)
)
;
MOZ_ASSERT
(
removed
)
;
if
(
!
gPrivateDatastores
-
>
Count
(
)
)
{
gPrivateDatastores
=
nullptr
;
}
}
if
(
mPreparedDatastoreRegistered
)
{
MOZ_ASSERT
(
gPreparedDatastores
)
;
MOZ_ASSERT
(
mDatastoreId
>
0
)
;
DebugOnly
<
bool
>
removed
=
gPreparedDatastores
-
>
Remove
(
mDatastoreId
)
;
MOZ_ASSERT
(
removed
)
;
if
(
!
gPreparedDatastores
-
>
Count
(
)
)
{
gPreparedDatastores
=
nullptr
;
}
}
}
mDatastore
-
>
NoteFinishedPrepareDatastoreOp
(
this
)
;
mDatastore
=
nullptr
;
CleanupMetadata
(
)
;
}
else
if
(
mConnection
)
{
MOZ_ASSERT
(
NS_FAILED
(
ResultCode
(
)
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
nsCOMPtr
<
nsIRunnable
>
callback
=
NewRunnableMethod
(
"
dom
:
:
OpenDatabaseOp
:
:
ConnectionClosedCallback
"
this
&
PrepareDatastoreOp
:
:
ConnectionClosedCallback
)
;
mConnection
-
>
Close
(
callback
)
;
}
else
{
MOZ_ASSERT_IF
(
mDirectoryLock
NS_FAILED
(
ResultCode
(
)
)
|
|
mDatabaseNotAvailable
)
;
mDirectoryLock
=
nullptr
;
CleanupMetadata
(
)
;
}
}
void
PrepareDatastoreOp
:
:
ConnectionClosedCallback
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
NS_FAILED
(
ResultCode
(
)
)
)
;
MOZ_ASSERT
(
mDirectoryLock
)
;
MOZ_ASSERT
(
mConnection
)
;
mConnection
=
nullptr
;
mDirectoryLock
=
nullptr
;
CleanupMetadata
(
)
;
}
void
PrepareDatastoreOp
:
:
CleanupMetadata
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mDelayedOp
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
mDelayedOp
.
forget
(
)
)
)
;
}
MOZ_ASSERT
(
gPrepareDatastoreOps
)
;
gPrepareDatastoreOps
-
>
RemoveElement
(
this
)
;
if
(
gPrepareDatastoreOps
-
>
IsEmpty
(
)
)
{
gPrepareDatastoreOps
=
nullptr
;
}
}
NS_IMPL_ISUPPORTS_INHERITED0
(
PrepareDatastoreOp
LSRequestBase
)
void
PrepareDatastoreOp
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnOwningThread
(
)
;
LSRequestBase
:
:
ActorDestroy
(
aWhy
)
;
if
(
mLoadDataOp
)
{
mLoadDataOp
-
>
NoteComplete
(
)
;
}
}
void
PrepareDatastoreOp
:
:
DirectoryLockAcquired
(
DirectoryLock
*
aLock
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
DirectoryOpenPending
)
;
MOZ_ASSERT
(
!
mDirectoryLock
)
;
mPendingDirectoryLock
=
nullptr
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
MaybeSetFailureCode
(
NS_ERROR_FAILURE
)
;
FinishNesting
(
)
;
return
;
}
mDirectoryLock
=
aLock
;
SendToIOThread
(
)
;
}
void
PrepareDatastoreOp
:
:
DirectoryLockFailed
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mNestedState
=
=
NestedState
:
:
DirectoryOpenPending
)
;
MOZ_ASSERT
(
!
mDirectoryLock
)
;
mPendingDirectoryLock
=
nullptr
;
MaybeSetFailureCode
(
NS_ERROR_FAILURE
)
;
FinishNesting
(
)
;
}
nsresult
PrepareDatastoreOp
:
:
LoadDataOp
:
:
DoDatastoreWork
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mNestedState
=
=
NestedState
:
:
DatabaseWorkLoadData
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnNonBackgroundThread
(
)
)
|
|
!
MayProceedOnNonOwningThread
(
)
)
{
return
NS_ERROR_FAILURE
;
}
Connection
:
:
CachedStatement
stmt
;
nsresult
rv
=
mConnection
-
>
GetCachedStatement
(
nsLiteralCString
(
"
SELECT
key
value
utf16Length
compressed
"
"
FROM
data
;
"
)
&
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
hasResult
;
while
(
NS_SUCCEEDED
(
rv
=
stmt
-
>
ExecuteStep
(
&
hasResult
)
)
&
&
hasResult
)
{
nsString
key
;
rv
=
stmt
-
>
GetString
(
0
key
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
LSValue
value
;
rv
=
value
.
InitFromStatement
(
stmt
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mPrepareDatastoreOp
-
>
mValues
.
Put
(
key
value
)
;
auto
item
=
mPrepareDatastoreOp
-
>
mOrderedItems
.
AppendElement
(
)
;
item
-
>
key
(
)
=
key
;
item
-
>
value
(
)
=
value
;
mPrepareDatastoreOp
-
>
mSizeOfKeys
+
=
key
.
Length
(
)
;
mPrepareDatastoreOp
-
>
mSizeOfItems
+
=
key
.
Length
(
)
+
value
.
Length
(
)
;
#
ifdef
DEBUG
mPrepareDatastoreOp
-
>
mDEBUGUsage
+
=
key
.
Length
(
)
+
value
.
UTF16Length
(
)
;
#
endif
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
PrepareDatastoreOp
:
:
LoadDataOp
:
:
OnSuccess
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mNestedState
=
=
NestedState
:
:
DatabaseWorkLoadData
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mLoadDataOp
=
=
this
)
;
mPrepareDatastoreOp
-
>
FinishNesting
(
)
;
}
void
PrepareDatastoreOp
:
:
LoadDataOp
:
:
OnFailure
(
nsresult
aResultCode
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mState
=
=
State
:
:
Nesting
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mNestedState
=
=
NestedState
:
:
DatabaseWorkLoadData
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mLoadDataOp
=
=
this
)
;
mPrepareDatastoreOp
-
>
SetFailureCode
(
aResultCode
)
;
mPrepareDatastoreOp
-
>
FinishNesting
(
)
;
}
void
PrepareDatastoreOp
:
:
LoadDataOp
:
:
Cleanup
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
)
;
MOZ_ASSERT
(
mPrepareDatastoreOp
-
>
mLoadDataOp
=
=
this
)
;
mPrepareDatastoreOp
-
>
mLoadDataOp
=
nullptr
;
mPrepareDatastoreOp
=
nullptr
;
ConnectionDatastoreOperationBase
:
:
Cleanup
(
)
;
}
NS_IMPL_ISUPPORTS
(
PrepareDatastoreOp
:
:
CompressFunction
mozIStorageFunction
)
NS_IMETHODIMP
PrepareDatastoreOp
:
:
CompressFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aFunctionArguments
)
;
MOZ_ASSERT
(
aResult
)
;
#
ifdef
DEBUG
{
uint32_t
argCount
;
MOZ_ALWAYS_SUCCEEDS
(
aFunctionArguments
-
>
GetNumEntries
(
&
argCount
)
)
;
MOZ_ASSERT
(
argCount
=
=
1
)
;
int32_t
type
;
MOZ_ALWAYS_SUCCEEDS
(
aFunctionArguments
-
>
GetTypeOfIndex
(
0
&
type
)
)
;
MOZ_ASSERT
(
type
=
=
mozIStorageValueArray
:
:
VALUE_TYPE_TEXT
)
;
}
#
endif
nsCString
value
;
nsresult
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
value
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
compressed
;
if
(
NS_WARN_IF
(
!
SnappyCompress
(
value
compressed
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
compressed
.
IsVoid
(
)
)
{
value
=
compressed
;
}
nsCOMPtr
<
nsIVariant
>
result
=
new
storage
:
:
UTF8TextVariant
(
value
)
;
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
PrepareDatastoreOp
:
:
CompressibleFunction
mozIStorageFunction
)
NS_IMETHODIMP
PrepareDatastoreOp
:
:
CompressibleFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aFunctionArguments
)
;
MOZ_ASSERT
(
aResult
)
;
#
ifdef
DEBUG
{
uint32_t
argCount
;
MOZ_ALWAYS_SUCCEEDS
(
aFunctionArguments
-
>
GetNumEntries
(
&
argCount
)
)
;
MOZ_ASSERT
(
argCount
=
=
1
)
;
int32_t
type
;
MOZ_ALWAYS_SUCCEEDS
(
aFunctionArguments
-
>
GetTypeOfIndex
(
0
&
type
)
)
;
MOZ_ASSERT
(
type
=
=
mozIStorageValueArray
:
:
VALUE_TYPE_TEXT
)
;
}
#
endif
nsCString
value
;
nsresult
rv
=
aFunctionArguments
-
>
GetUTF8String
(
0
value
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
compressed
;
if
(
NS_WARN_IF
(
!
SnappyCompress
(
value
compressed
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
compressible
=
!
compressed
.
IsVoid
(
)
;
nsCOMPtr
<
nsIVariant
>
result
=
new
storage
:
:
IntegerVariant
(
compressible
)
;
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
PrepareObserverOp
:
:
PrepareObserverOp
(
nsIEventTarget
*
aMainEventTarget
const
LSRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
:
LSRequestBase
(
aMainEventTarget
aParams
aContentParentId
)
{
MOZ_ASSERT
(
aParams
.
type
(
)
=
=
LSRequestParams
:
:
TLSRequestPrepareObserverParams
)
;
}
nsresult
PrepareObserverOp
:
:
Start
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
StartingRequest
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
const
LSRequestPrepareObserverParams
params
=
mParams
.
get_LSRequestPrepareObserverParams
(
)
;
const
PrincipalInfo
&
storagePrincipalInfo
=
params
.
storagePrincipalInfo
(
)
;
if
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
)
{
mOrigin
=
QuotaManager
:
:
GetOriginForChrome
(
)
;
}
else
{
MOZ_ASSERT
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TContentPrincipalInfo
)
;
mOrigin
=
QuotaManager
:
:
GetOriginFromValidatedPrincipalInfo
(
storagePrincipalInfo
)
;
}
mState
=
State
:
:
SendingReadyMessage
;
MOZ_ALWAYS_SUCCEEDS
(
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
return
NS_OK
;
}
void
PrepareObserverOp
:
:
GetResponse
(
LSRequestResponse
&
aResponse
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingResults
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
uint64_t
observerId
=
+
+
gLastObserverId
;
RefPtr
<
Observer
>
observer
=
new
Observer
(
mOrigin
)
;
if
(
!
gPreparedObsevers
)
{
gPreparedObsevers
=
new
PreparedObserverHashtable
(
)
;
}
gPreparedObsevers
-
>
Put
(
observerId
std
:
:
move
(
observer
)
)
;
LSRequestPrepareObserverResponse
prepareObserverResponse
;
prepareObserverResponse
.
observerId
(
)
=
observerId
;
aResponse
=
prepareObserverResponse
;
}
LSSimpleRequestBase
:
:
LSSimpleRequestBase
(
const
LSSimpleRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
:
mParams
(
aParams
)
mContentParentId
(
aContentParentId
)
mState
(
State
:
:
Initial
)
{
}
LSSimpleRequestBase
:
:
~
LSSimpleRequestBase
(
)
{
MOZ_ASSERT_IF
(
MayProceedOnNonOwningThread
(
)
mState
=
=
State
:
:
Initial
|
|
mState
=
=
State
:
:
Completed
)
;
}
void
LSSimpleRequestBase
:
:
Dispatch
(
)
{
AssertIsOnOwningThread
(
)
;
mState
=
State
:
:
StartingRequest
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
this
)
)
;
}
bool
LSSimpleRequestBase
:
:
VerifyRequestParams
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mParams
.
type
(
)
!
=
LSSimpleRequestParams
:
:
T__None
)
;
switch
(
mParams
.
type
(
)
)
{
case
LSSimpleRequestParams
:
:
TLSSimpleRequestPreloadedParams
:
{
const
LSSimpleRequestPreloadedParams
&
params
=
mParams
.
get_LSSimpleRequestPreloadedParams
(
)
;
if
(
NS_WARN_IF
(
!
VerifyPrincipalInfo
(
params
.
principalInfo
(
)
params
.
storagePrincipalInfo
(
)
)
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Should
never
get
here
!
"
)
;
}
return
true
;
}
nsresult
LSSimpleRequestBase
:
:
StartRequest
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
StartingRequest
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
DEBUG
bool
trustParams
=
false
;
#
else
bool
trustParams
=
!
BackgroundParent
:
:
IsOtherProcessActor
(
Manager
(
)
)
;
#
endif
if
(
!
trustParams
&
&
NS_WARN_IF
(
!
VerifyRequestParams
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
Start
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
LSSimpleRequestBase
:
:
SendResults
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingResults
)
;
if
(
NS_WARN_IF
(
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
|
|
!
MayProceed
(
)
)
{
MaybeSetFailureCode
(
NS_ERROR_FAILURE
)
;
}
if
(
MayProceed
(
)
)
{
LSSimpleRequestResponse
response
;
if
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
{
GetResponse
(
response
)
;
}
else
{
response
=
ResultCode
(
)
;
}
Unused
<
<
PBackgroundLSSimpleRequestParent
:
:
Send__delete__
(
this
response
)
;
}
mState
=
State
:
:
Completed
;
}
NS_IMETHODIMP
LSSimpleRequestBase
:
:
Run
(
)
{
nsresult
rv
;
switch
(
mState
)
{
case
State
:
:
StartingRequest
:
rv
=
StartRequest
(
)
;
break
;
case
State
:
:
SendingResults
:
SendResults
(
)
;
return
NS_OK
;
default
:
MOZ_CRASH
(
"
Bad
state
!
"
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
mState
!
=
State
:
:
SendingResults
)
{
MaybeSetFailureCode
(
rv
)
;
mState
=
State
:
:
SendingResults
;
if
(
IsOnOwningThread
(
)
)
{
SendResults
(
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
}
return
NS_OK
;
}
void
LSSimpleRequestBase
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnOwningThread
(
)
;
NoteComplete
(
)
;
}
PreloadedOp
:
:
PreloadedOp
(
const
LSSimpleRequestParams
&
aParams
const
Maybe
<
ContentParentId
>
&
aContentParentId
)
:
LSSimpleRequestBase
(
aParams
aContentParentId
)
{
MOZ_ASSERT
(
aParams
.
type
(
)
=
=
LSSimpleRequestParams
:
:
TLSSimpleRequestPreloadedParams
)
;
}
nsresult
PreloadedOp
:
:
Start
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
StartingRequest
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
const
LSSimpleRequestPreloadedParams
&
params
=
mParams
.
get_LSSimpleRequestPreloadedParams
(
)
;
const
PrincipalInfo
&
storagePrincipalInfo
=
params
.
storagePrincipalInfo
(
)
;
MOZ_ASSERT
(
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
|
|
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TContentPrincipalInfo
)
;
mOrigin
=
storagePrincipalInfo
.
type
(
)
=
=
PrincipalInfo
:
:
TSystemPrincipalInfo
?
nsCString
{
QuotaManager
:
:
GetOriginForChrome
(
)
}
:
QuotaManager
:
:
GetOriginFromValidatedPrincipalInfo
(
storagePrincipalInfo
)
;
mState
=
State
:
:
SendingResults
;
MOZ_ALWAYS_SUCCEEDS
(
OwningEventTarget
(
)
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
return
NS_OK
;
}
void
PreloadedOp
:
:
GetResponse
(
LSSimpleRequestResponse
&
aResponse
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mState
=
=
State
:
:
SendingResults
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
ResultCode
(
)
)
)
;
MOZ_ASSERT
(
!
QuotaClient
:
:
IsShuttingDownOnBackgroundThread
(
)
)
;
MOZ_ASSERT
(
MayProceed
(
)
)
;
bool
preloaded
;
RefPtr
<
Datastore
>
datastore
;
if
(
(
datastore
=
GetDatastore
(
mOrigin
)
)
&
&
!
datastore
-
>
IsClosed
(
)
)
{
preloaded
=
true
;
}
else
{
preloaded
=
false
;
}
LSSimpleRequestPreloadedResponse
preloadedResponse
;
preloadedResponse
.
preloaded
(
)
=
preloaded
;
aResponse
=
preloadedResponse
;
}
UniquePtr
<
ArchivedOriginScope
>
ArchivedOriginScope
:
:
CreateFromOrigin
(
const
nsACString
&
aOriginAttrSuffix
const
nsACString
&
aOriginKey
)
{
return
WrapUnique
(
new
ArchivedOriginScope
(
Origin
(
aOriginAttrSuffix
aOriginKey
)
)
)
;
}
UniquePtr
<
ArchivedOriginScope
>
ArchivedOriginScope
:
:
CreateFromPrefix
(
const
nsACString
&
aOriginKey
)
{
return
WrapUnique
(
new
ArchivedOriginScope
(
Prefix
(
aOriginKey
)
)
)
;
}
UniquePtr
<
ArchivedOriginScope
>
ArchivedOriginScope
:
:
CreateFromPattern
(
const
OriginAttributesPattern
&
aPattern
)
{
return
WrapUnique
(
new
ArchivedOriginScope
(
Pattern
(
aPattern
)
)
)
;
}
UniquePtr
<
ArchivedOriginScope
>
ArchivedOriginScope
:
:
CreateFromNull
(
)
{
return
WrapUnique
(
new
ArchivedOriginScope
(
Null
(
)
)
)
;
}
void
ArchivedOriginScope
:
:
GetBindingClause
(
nsACString
&
aBindingClause
)
const
{
struct
Matcher
{
nsACString
*
mBindingClause
;
explicit
Matcher
(
nsACString
*
aBindingClause
)
:
mBindingClause
(
aBindingClause
)
{
}
void
operator
(
)
(
const
Origin
&
aOrigin
)
{
*
mBindingClause
=
nsLiteralCString
(
"
WHERE
originKey
=
:
originKey
"
"
AND
originAttributes
=
:
originAttributes
"
)
;
}
void
operator
(
)
(
const
Prefix
&
aPrefix
)
{
*
mBindingClause
=
"
WHERE
originKey
=
:
originKey
"
_ns
;
}
void
operator
(
)
(
const
Pattern
&
aPattern
)
{
*
mBindingClause
=
nsLiteralCString
(
"
WHERE
originAttributes
MATCH
:
originAttributesPattern
"
)
;
}
void
operator
(
)
(
const
Null
&
aNull
)
{
mBindingClause
-
>
Truncate
(
)
;
}
}
;
mData
.
match
(
Matcher
(
&
aBindingClause
)
)
;
}
nsresult
ArchivedOriginScope
:
:
BindToStatement
(
mozIStorageStatement
*
aStmt
)
const
{
MOZ_ASSERT
(
IsOnIOThread
(
)
|
|
IsOnConnectionThread
(
)
)
;
MOZ_ASSERT
(
aStmt
)
;
struct
Matcher
{
mozIStorageStatement
*
mStmt
;
explicit
Matcher
(
mozIStorageStatement
*
aStmt
)
:
mStmt
(
aStmt
)
{
}
nsresult
operator
(
)
(
const
Origin
&
aOrigin
)
{
nsresult
rv
=
mStmt
-
>
BindUTF8StringByName
(
"
originKey
"
_ns
aOrigin
.
OriginNoSuffix
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mStmt
-
>
BindUTF8StringByName
(
"
originAttributes
"
_ns
aOrigin
.
OriginSuffix
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
operator
(
)
(
const
Prefix
&
aPrefix
)
{
nsresult
rv
=
mStmt
-
>
BindUTF8StringByName
(
"
originKey
"
_ns
aPrefix
.
OriginNoSuffix
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
operator
(
)
(
const
Pattern
&
aPattern
)
{
nsresult
rv
=
mStmt
-
>
BindUTF8StringByName
(
"
originAttributesPattern
"
_ns
"
pattern1
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
operator
(
)
(
const
Null
&
aNull
)
{
return
NS_OK
;
}
}
;
nsresult
rv
=
mData
.
match
(
Matcher
(
aStmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
ArchivedOriginScope
:
:
HasMatches
(
ArchivedOriginHashtable
*
aHashtable
)
const
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aHashtable
)
;
struct
Matcher
{
ArchivedOriginHashtable
*
mHashtable
;
explicit
Matcher
(
ArchivedOriginHashtable
*
aHashtable
)
:
mHashtable
(
aHashtable
)
{
}
bool
operator
(
)
(
const
Origin
&
aOrigin
)
{
nsCString
hashKey
=
GetArchivedOriginHashKey
(
aOrigin
.
OriginSuffix
(
)
aOrigin
.
OriginNoSuffix
(
)
)
;
ArchivedOriginInfo
*
archivedOriginInfo
;
return
mHashtable
-
>
Get
(
hashKey
&
archivedOriginInfo
)
;
}
bool
operator
(
)
(
const
Prefix
&
aPrefix
)
{
for
(
auto
iter
=
mHashtable
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
auto
&
archivedOriginInfo
=
iter
.
Data
(
)
;
if
(
archivedOriginInfo
-
>
mOriginNoSuffix
=
=
aPrefix
.
OriginNoSuffix
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
operator
(
)
(
const
Pattern
&
aPattern
)
{
for
(
auto
iter
=
mHashtable
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
auto
&
archivedOriginInfo
=
iter
.
Data
(
)
;
if
(
aPattern
.
GetPattern
(
)
.
Matches
(
archivedOriginInfo
-
>
mOriginAttributes
)
)
{
return
true
;
}
}
return
false
;
}
bool
operator
(
)
(
const
Null
&
aNull
)
{
return
mHashtable
-
>
Count
(
)
;
}
}
;
return
mData
.
match
(
Matcher
(
aHashtable
)
)
;
}
void
ArchivedOriginScope
:
:
RemoveMatches
(
ArchivedOriginHashtable
*
aHashtable
)
const
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aHashtable
)
;
struct
Matcher
{
ArchivedOriginHashtable
*
mHashtable
;
explicit
Matcher
(
ArchivedOriginHashtable
*
aHashtable
)
:
mHashtable
(
aHashtable
)
{
}
void
operator
(
)
(
const
Origin
&
aOrigin
)
{
nsCString
hashKey
=
GetArchivedOriginHashKey
(
aOrigin
.
OriginSuffix
(
)
aOrigin
.
OriginNoSuffix
(
)
)
;
mHashtable
-
>
Remove
(
hashKey
)
;
}
void
operator
(
)
(
const
Prefix
&
aPrefix
)
{
for
(
auto
iter
=
mHashtable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
auto
&
archivedOriginInfo
=
iter
.
Data
(
)
;
if
(
archivedOriginInfo
-
>
mOriginNoSuffix
=
=
aPrefix
.
OriginNoSuffix
(
)
)
{
iter
.
Remove
(
)
;
}
}
}
void
operator
(
)
(
const
Pattern
&
aPattern
)
{
for
(
auto
iter
=
mHashtable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
auto
&
archivedOriginInfo
=
iter
.
Data
(
)
;
if
(
aPattern
.
GetPattern
(
)
.
Matches
(
archivedOriginInfo
-
>
mOriginAttributes
)
)
{
iter
.
Remove
(
)
;
}
}
}
void
operator
(
)
(
const
Null
&
aNull
)
{
mHashtable
-
>
Clear
(
)
;
}
}
;
mData
.
match
(
Matcher
(
aHashtable
)
)
;
}
QuotaClient
*
QuotaClient
:
:
sInstance
=
nullptr
;
QuotaClient
:
:
QuotaClient
(
)
:
mShadowDatabaseMutex
(
"
LocalStorage
mShadowDatabaseMutex
"
)
mShutdownRequested
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
sInstance
"
We
expect
this
to
be
a
singleton
!
"
)
;
sInstance
=
this
;
}
QuotaClient
:
:
~
QuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
sInstance
=
=
this
"
We
expect
this
to
be
a
singleton
!
"
)
;
sInstance
=
nullptr
;
}
nsresult
QuotaClient
:
:
Initialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
Observer
:
:
Initialize
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
mozilla
:
:
dom
:
:
quota
:
:
Client
:
:
Type
QuotaClient
:
:
GetType
(
)
{
return
QuotaClient
:
:
LS
;
}
Result
<
UsageInfo
nsresult
>
QuotaClient
:
:
InitOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aPersistenceType
=
=
PERSISTENCE_TYPE_DEFAULT
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
LS_TRY_INSPECT
(
const
auto
&
directory
quotaManager
-
>
GetDirectoryForOrigin
(
aPersistenceType
aGroupAndOrigin
.
mOrigin
)
)
;
MOZ_ASSERT
(
directory
)
;
LS_TRY
(
directory
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
LS_DIRECTORY_NAME
)
)
)
;
#
ifdef
DEBUG
{
LS_TRY_INSPECT
(
const
bool
&
exists
MOZ_TO_RESULT_INVOKE
(
directory
Exists
)
)
;
MOZ_ASSERT
(
exists
)
;
}
#
endif
LS_TRY_INSPECT
(
const
auto
&
directoryPath
MOZ_TO_RESULT_INVOKE_TYPED
(
nsString
directory
GetPath
)
)
;
LS_TRY_INSPECT
(
const
auto
&
usageFile
ToResultInvoke
<
nsCOMPtr
<
nsIFile
>
>
(
GetUsageFile
directoryPath
)
)
;
LS_TRY_UNWRAP
(
bool
usageFileExists
ExistsAsFile
(
*
usageFile
)
)
;
LS_TRY_INSPECT
(
const
auto
&
usageJournalFile
ToResultInvoke
<
nsCOMPtr
<
nsIFile
>
>
(
GetUsageJournalFile
directoryPath
)
)
;
LS_TRY_INSPECT
(
const
bool
&
usageJournalFileExists
ExistsAsFile
(
*
usageJournalFile
)
)
;
if
(
usageJournalFileExists
)
{
if
(
usageFileExists
)
{
LS_TRY
(
usageFile
-
>
Remove
(
false
)
)
;
usageFileExists
=
false
;
}
LS_TRY
(
usageJournalFile
-
>
Remove
(
false
)
)
;
}
LS_TRY_INSPECT
(
const
auto
&
file
CloneFileAndAppend
(
*
directory
kDataFileName
)
)
;
LS_TRY_INSPECT
(
const
bool
&
fileExists
ExistsAsFile
(
*
file
)
)
;
LS_TRY_INSPECT
(
const
UsageInfo
&
res
(
[
fileExists
usageFileExists
&
file
&
usageFile
&
usageJournalFile
&
aGroupAndOrigin
]
(
)
-
>
Result
<
UsageInfo
nsresult
>
{
if
(
fileExists
)
{
LS_TRY_INSPECT
(
const
int64_t
&
usage
(
ToResultInvoke
<
int64_t
>
(
LoadUsageFile
usageFile
)
.
orElse
(
[
&
file
&
usageFile
&
usageJournalFile
&
aGroupAndOrigin
]
(
const
nsresult
)
-
>
Result
<
int64_t
nsresult
>
{
nsCOMPtr
<
mozIStorageConnection
>
connection
;
bool
dummy
;
LS_TRY
(
CreateStorageConnection
(
file
usageFile
aGroupAndOrigin
.
mOrigin
getter_AddRefs
(
connection
)
&
dummy
)
)
;
LS_TRY_INSPECT
(
const
int64_t
&
usage
ToResultInvoke
<
int64_t
>
(
GetUsage
connection
nullptr
)
)
;
LS_TRY
(
UpdateUsageFile
(
usageFile
usageJournalFile
usage
)
)
;
LS_TRY
(
usageJournalFile
-
>
Remove
(
false
)
)
;
return
usage
;
}
)
)
)
;
MOZ_ASSERT
(
usage
>
=
0
)
;
return
UsageInfo
{
DatabaseUsageType
(
Some
(
uint64_t
(
usage
)
)
)
}
;
}
if
(
usageFileExists
)
{
LS_TRY
(
usageFile
-
>
Remove
(
false
)
)
;
}
return
UsageInfo
{
}
;
}
(
)
)
)
;
#
ifdef
DEBUG
{
LS_TRY_INSPECT
(
const
auto
&
directoryEntries
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
nsIDirectoryEnumerator
>
directory
GetDirectoryEntries
)
)
;
LS_TRY
(
CollectEach
(
[
&
directoryEntries
&
aCanceled
]
(
)
-
>
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
{
if
(
aCanceled
)
{
return
nsCOMPtr
<
nsIFile
>
{
}
;
}
LS_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
nsIFile
>
directoryEntries
GetNextFile
)
)
;
}
[
]
(
const
nsCOMPtr
<
nsIFile
>
&
file
)
-
>
Result
<
Ok
nsresult
>
{
LS_TRY_INSPECT
(
const
bool
&
isDirectory
MOZ_TO_RESULT_INVOKE
(
file
IsDirectory
)
)
;
if
(
isDirectory
)
{
Unused
<
<
WARN_IF_FILE_IS_UNKNOWN
(
*
file
)
;
return
Ok
{
}
;
}
LS_TRY_INSPECT
(
const
auto
&
leafName
MOZ_TO_RESULT_INVOKE_TYPED
(
nsString
file
GetLeafName
)
)
;
if
(
leafName
.
Equals
(
kDataFileName
)
|
|
leafName
.
Equals
(
kJournalFileName
)
|
|
leafName
.
Equals
(
kUsageFileName
)
|
|
leafName
.
Equals
(
kUsageJournalFileName
)
)
{
return
Ok
{
}
;
}
Unused
<
<
WARN_IF_FILE_IS_UNKNOWN
(
*
file
)
;
return
Ok
{
}
;
}
)
)
;
}
#
endif
return
res
;
}
nsresult
QuotaClient
:
:
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
UNKNOWN_FILE_WARNING
(
NS_LITERAL_STRING_FROM_CSTRING
(
LS_DIRECTORY_NAME
)
)
;
return
NS_OK
;
}
Result
<
UsageInfo
nsresult
>
QuotaClient
:
:
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aPersistenceType
=
=
PERSISTENCE_TYPE_DEFAULT
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
return
quotaManager
-
>
GetUsageForClient
(
PERSISTENCE_TYPE_DEFAULT
aGroupAndOrigin
Client
:
:
LS
)
;
}
nsresult
QuotaClient
:
:
AboutToClearOrigins
(
const
Nullable
<
PersistenceType
>
&
aPersistenceType
const
OriginScope
&
aOriginScope
)
{
AssertIsOnIOThread
(
)
;
if
(
!
aPersistenceType
.
IsNull
(
)
&
&
aPersistenceType
.
Value
(
)
!
=
PERSISTENCE_TYPE_DEFAULT
)
{
return
NS_OK
;
}
bool
shadowWrites
=
gShadowWrites
;
UniquePtr
<
ArchivedOriginScope
>
archivedOriginScope
;
nsresult
rv
=
CreateArchivedOriginScope
(
aOriginScope
archivedOriginScope
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
gArchivedOrigins
)
{
rv
=
LoadArchivedOrigins
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
gArchivedOrigins
)
;
}
bool
hasDataForRemoval
=
archivedOriginScope
-
>
HasMatches
(
gArchivedOrigins
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
nsString
basePath
=
quotaManager
-
>
GetBasePath
(
)
;
{
MutexAutoLock
shadowDatabaseLock
(
mShadowDatabaseMutex
)
;
nsCOMPtr
<
mozIStorageConnection
>
connection
;
if
(
gInitializedShadowStorage
)
{
rv
=
GetShadowStorageConnection
(
basePath
getter_AddRefs
(
connection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
rv
=
CreateShadowStorageConnection
(
basePath
getter_AddRefs
(
connection
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
gInitializedShadowStorage
=
true
;
}
if
(
hasDataForRemoval
)
{
rv
=
AttachArchiveDatabase
(
quotaManager
-
>
GetStoragePath
(
)
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
archivedOriginScope
-
>
IsPattern
(
)
)
{
nsCOMPtr
<
mozIStorageFunction
>
function
(
new
MatchFunction
(
archivedOriginScope
-
>
GetPattern
(
)
)
)
;
rv
=
connection
-
>
CreateFunction
(
"
match
"
_ns
2
function
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
connection
-
>
CreateStatement
(
"
BEGIN
IMMEDIATE
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
shadowWrites
)
{
rv
=
PerformDelete
(
connection
"
main
"
_ns
archivedOriginScope
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
hasDataForRemoval
)
{
rv
=
PerformDelete
(
connection
"
archive
"
_ns
archivedOriginScope
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
connection
-
>
CreateStatement
(
"
COMMIT
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
stmt
=
nullptr
;
if
(
archivedOriginScope
-
>
IsPattern
(
)
)
{
rv
=
connection
-
>
RemoveFunction
(
"
match
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
hasDataForRemoval
)
{
rv
=
DetachArchiveDatabase
(
connection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
gArchivedOrigins
)
;
MOZ_ASSERT
(
archivedOriginScope
-
>
HasMatches
(
gArchivedOrigins
)
)
;
archivedOriginScope
-
>
RemoveMatches
(
gArchivedOrigins
)
;
}
rv
=
connection
-
>
Close
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
aOriginScope
.
IsNull
(
)
)
{
nsCOMPtr
<
nsIFile
>
shadowFile
;
rv
=
GetShadowFile
(
basePath
getter_AddRefs
(
shadowFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
shadowFile
-
>
Remove
(
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
gInitializedShadowStorage
=
false
;
}
return
NS_OK
;
}
void
QuotaClient
:
:
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
{
AssertIsOnIOThread
(
)
;
}
void
QuotaClient
:
:
ReleaseIOThreadObjects
(
)
{
AssertIsOnIOThread
(
)
;
gArchivedOrigins
=
nullptr
;
}
void
QuotaClient
:
:
AbortOperations
(
const
nsACString
&
aOrigin
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
gPrepareDatastoreOps
)
{
for
(
PrepareDatastoreOp
*
prepareDatastoreOp
:
*
gPrepareDatastoreOps
)
{
MOZ_ASSERT
(
prepareDatastoreOp
)
;
if
(
!
prepareDatastoreOp
-
>
RequestedDirectoryLock
(
)
)
{
continue
;
}
MOZ_ASSERT
(
prepareDatastoreOp
-
>
OriginIsKnown
(
)
)
;
if
(
aOrigin
.
IsVoid
(
)
|
|
prepareDatastoreOp
-
>
Origin
(
)
=
=
aOrigin
)
{
prepareDatastoreOp
-
>
Invalidate
(
)
;
}
}
}
if
(
gPrivateDatastores
&
&
(
aOrigin
.
IsVoid
(
)
|
|
(
gPrivateDatastores
-
>
Remove
(
aOrigin
)
&
&
!
gPrivateDatastores
-
>
Count
(
)
)
)
)
{
gPrivateDatastores
=
nullptr
;
}
if
(
gPreparedDatastores
)
{
for
(
auto
iter
=
gPreparedDatastores
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
auto
&
preparedDatastore
=
iter
.
Data
(
)
;
MOZ_ASSERT
(
preparedDatastore
)
;
if
(
aOrigin
.
IsVoid
(
)
|
|
preparedDatastore
-
>
Origin
(
)
=
=
aOrigin
)
{
preparedDatastore
-
>
Invalidate
(
)
;
}
}
}
if
(
aOrigin
.
IsVoid
(
)
)
{
RequestAllowToCloseIf
(
[
]
(
const
Database
*
const
)
{
return
true
;
}
)
;
}
else
{
RequestAllowToCloseIf
(
[
&
aOrigin
]
(
const
Database
*
const
aDatabase
)
{
return
aDatabase
-
>
Origin
(
)
=
=
aOrigin
;
}
)
;
}
}
void
QuotaClient
:
:
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
{
AssertIsOnBackgroundThread
(
)
;
RequestAllowToCloseIf
(
[
aContentParentId
]
(
const
Database
*
const
aDatabase
)
{
return
aDatabase
-
>
IsOwnedByProcess
(
aContentParentId
)
;
}
)
;
}
void
QuotaClient
:
:
StartIdleMaintenance
(
)
{
AssertIsOnBackgroundThread
(
)
;
}
void
QuotaClient
:
:
StopIdleMaintenance
(
)
{
AssertIsOnBackgroundThread
(
)
;
}
void
QuotaClient
:
:
ShutdownWorkThreads
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mShutdownRequested
)
;
mShutdownRequested
=
true
;
if
(
gPrivateDatastores
)
{
gPrivateDatastores
-
>
Clear
(
)
;
gPrivateDatastores
=
nullptr
;
}
if
(
gPreparedDatastores
)
{
gPreparedDatastores
-
>
Clear
(
)
;
gPreparedDatastores
=
nullptr
;
}
RequestAllowToCloseIf
(
[
]
(
const
Database
*
const
)
{
return
true
;
}
)
;
if
(
gPreparedObsevers
)
{
gPreparedObsevers
-
>
Clear
(
)
;
gPreparedObsevers
=
nullptr
;
}
nsCOMPtr
<
nsITimer
>
timer
=
NS_NewTimer
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
timer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
ForceKillDatabases
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
aTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
quotaClient
=
static_cast
<
QuotaClient
*
>
(
aClosure
)
;
quotaClient
-
>
ShutdownTimedOut
(
)
;
}
aClosure
SHUTDOWN_FORCE_CRASH_TIMEOUT_MS
nsITimer
:
:
TYPE_ONE_SHOT
"
localstorage
:
:
QuotaClient
:
:
ShutdownWorkThreads
:
:
ForceCrashTimer
"
)
)
;
}
this
SHUTDOWN_FORCE_KILL_TIMEOUT_MS
nsITimer
:
:
TYPE_ONE_SHOT
"
localstorage
:
:
QuotaClient
:
:
ShutdownWorkThreads
:
:
ForceKillTimer
"
)
)
;
MOZ_ALWAYS_TRUE
(
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
gPrepareDatastoreOps
&
&
!
gDatastores
&
&
!
gLiveDatabases
;
}
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
timer
-
>
Cancel
(
)
)
;
if
(
gConnectionThread
)
{
gConnectionThread
-
>
Shutdown
(
)
;
gConnectionThread
=
nullptr
;
}
}
void
QuotaClient
:
:
ShutdownTimedOut
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
gPrepareDatastoreOps
|
|
gDatastores
|
|
gLiveDatabases
)
;
nsCString
data
;
if
(
gPrepareDatastoreOps
)
{
data
.
Append
(
"
PrepareDatastoreOperations
:
"
)
;
data
.
AppendInt
(
static_cast
<
uint32_t
>
(
gPrepareDatastoreOps
-
>
Length
(
)
)
)
;
data
.
Append
(
"
(
"
)
;
nsTHashtable
<
nsCStringHashKey
>
ids
;
for
(
const
auto
&
prepareDatastoreOp
:
*
gPrepareDatastoreOps
)
{
MOZ_ASSERT
(
prepareDatastoreOp
)
;
nsCString
id
;
prepareDatastoreOp
-
>
Stringify
(
id
)
;
ids
.
PutEntry
(
id
)
;
}
StringifyTableKeys
(
ids
data
)
;
data
.
Append
(
"
)
\
n
"
)
;
}
if
(
gDatastores
)
{
data
.
Append
(
"
Datastores
:
"
)
;
data
.
AppendInt
(
gDatastores
-
>
Count
(
)
)
;
data
.
Append
(
"
(
"
)
;
nsTHashtable
<
nsCStringHashKey
>
ids
;
for
(
const
auto
&
entry
:
*
gDatastores
)
{
MOZ_ASSERT
(
entry
.
GetData
(
)
)
;
nsCString
id
;
entry
.
GetData
(
)
-
>
Stringify
(
id
)
;
ids
.
PutEntry
(
id
)
;
}
StringifyTableKeys
(
ids
data
)
;
data
.
Append
(
"
)
\
n
"
)
;
}
if
(
gLiveDatabases
)
{
data
.
Append
(
"
LiveDatabases
:
"
)
;
data
.
AppendInt
(
static_cast
<
uint32_t
>
(
gLiveDatabases
-
>
Length
(
)
)
)
;
data
.
Append
(
"
(
"
)
;
nsTHashtable
<
nsCStringHashKey
>
ids
;
for
(
const
auto
&
database
:
*
gLiveDatabases
)
{
MOZ_ASSERT
(
database
)
;
nsCString
id
;
database
-
>
Stringify
(
id
)
;
ids
.
PutEntry
(
id
)
;
}
StringifyTableKeys
(
ids
data
)
;
data
.
Append
(
"
)
\
n
"
)
;
}
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
LocalStorageShutdownTimeout
data
)
;
MOZ_CRASH
(
"
LocalStorage
shutdown
timed
out
"
)
;
}
nsresult
QuotaClient
:
:
CreateArchivedOriginScope
(
const
OriginScope
&
aOriginScope
UniquePtr
<
ArchivedOriginScope
>
&
aArchivedOriginScope
)
{
AssertIsOnIOThread
(
)
;
nsresult
rv
;
UniquePtr
<
ArchivedOriginScope
>
archivedOriginScope
;
if
(
aOriginScope
.
IsOrigin
(
)
)
{
nsCString
spec
;
OriginAttributes
attrs
;
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
ParseOrigin
(
aOriginScope
.
GetOrigin
(
)
spec
&
attrs
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ContentPrincipalInfo
contentPrincipalInfo
;
contentPrincipalInfo
.
attrs
(
)
=
attrs
;
contentPrincipalInfo
.
spec
(
)
=
spec
;
PrincipalInfo
storagePrincipalInfo
(
contentPrincipalInfo
)
;
nsCString
originAttrSuffix
;
nsCString
originKey
;
rv
=
GenerateOriginKey2
(
storagePrincipalInfo
originAttrSuffix
originKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
archivedOriginScope
=
ArchivedOriginScope
:
:
CreateFromOrigin
(
originAttrSuffix
originKey
)
;
}
else
if
(
aOriginScope
.
IsPrefix
(
)
)
{
nsCString
spec
;
OriginAttributes
attrs
;
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
ParseOrigin
(
aOriginScope
.
GetOriginNoSuffix
(
)
spec
&
attrs
)
)
)
{
return
NS_ERROR_FAILURE
;
}
ContentPrincipalInfo
contentPrincipalInfo
;
contentPrincipalInfo
.
attrs
(
)
=
attrs
;
contentPrincipalInfo
.
spec
(
)
=
spec
;
PrincipalInfo
storagePrincipalInfo
(
contentPrincipalInfo
)
;
nsCString
originAttrSuffix
;
nsCString
originKey
;
rv
=
GenerateOriginKey2
(
storagePrincipalInfo
originAttrSuffix
originKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
archivedOriginScope
=
ArchivedOriginScope
:
:
CreateFromPrefix
(
originKey
)
;
}
else
if
(
aOriginScope
.
IsPattern
(
)
)
{
archivedOriginScope
=
ArchivedOriginScope
:
:
CreateFromPattern
(
aOriginScope
.
GetPattern
(
)
)
;
}
else
{
MOZ_ASSERT
(
aOriginScope
.
IsNull
(
)
)
;
archivedOriginScope
=
ArchivedOriginScope
:
:
CreateFromNull
(
)
;
}
MOZ_ASSERT
(
archivedOriginScope
)
;
aArchivedOriginScope
=
std
:
:
move
(
archivedOriginScope
)
;
return
NS_OK
;
}
nsresult
QuotaClient
:
:
PerformDelete
(
mozIStorageConnection
*
aConnection
const
nsACString
&
aSchemaName
ArchivedOriginScope
*
aArchivedOriginScope
)
const
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
MOZ_ASSERT
(
aArchivedOriginScope
)
;
nsresult
rv
;
nsCString
bindingClause
;
aArchivedOriginScope
-
>
GetBindingClause
(
bindingClause
)
;
nsCOMPtr
<
mozIStorageStatement
>
stmt
;
rv
=
aConnection
-
>
CreateStatement
(
"
DELETE
FROM
"
_ns
+
aSchemaName
+
"
.
webappsstore2
"
_ns
+
bindingClause
+
"
;
"
_ns
getter_AddRefs
(
stmt
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aArchivedOriginScope
-
>
BindToStatement
(
stmt
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stmt
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
QuotaClient
:
:
Observer
:
:
Initialize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
Observer
>
observer
=
new
Observer
(
)
;
nsresult
rv
=
observer
-
>
Init
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
QuotaClient
:
:
Observer
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
obs
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
obs
-
>
AddObserver
(
this
kPrivateBrowsingObserverTopic
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
QuotaClient
:
:
Observer
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ALWAYS_SUCCEEDS
(
obs
-
>
RemoveObserver
(
this
kPrivateBrowsingObserverTopic
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
obs
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
QuotaClient
:
:
Observer
nsIObserver
)
NS_IMETHODIMP
QuotaClient
:
:
Observer
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
;
if
(
!
strcmp
(
aTopic
kPrivateBrowsingObserverTopic
)
)
{
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
backgroundActor
-
>
SendLSClearPrivateBrowsing
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
rv
=
Shutdown
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
NS_WARNING
(
"
Unknown
observer
topic
!
"
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
QuotaClient
:
:
MatchFunction
mozIStorageFunction
)
NS_IMETHODIMP
QuotaClient
:
:
MatchFunction
:
:
OnFunctionCall
(
mozIStorageValueArray
*
aFunctionArguments
nsIVariant
*
*
aResult
)
{
AssertIsOnIOThread
(
)
;
MOZ_ASSERT
(
aFunctionArguments
)
;
MOZ_ASSERT
(
aResult
)
;
nsCString
suffix
;
nsresult
rv
=
aFunctionArguments
-
>
GetUTF8String
(
1
suffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
OriginAttributes
oa
;
if
(
NS_WARN_IF
(
!
oa
.
PopulateFromSuffix
(
suffix
)
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
result
=
mPattern
.
Matches
(
oa
)
;
RefPtr
<
nsVariant
>
outVar
(
new
nsVariant
(
)
)
;
rv
=
outVar
-
>
SetAsBool
(
result
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
outVar
.
forget
(
aResult
)
;
return
NS_OK
;
}
AutoWriteTransaction
:
:
AutoWriteTransaction
(
bool
aShadowWrites
)
:
mConnection
(
nullptr
)
mShadowWrites
(
aShadowWrites
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_COUNT_CTOR
(
mozilla
:
:
dom
:
:
AutoWriteTransaction
)
;
}
AutoWriteTransaction
:
:
~
AutoWriteTransaction
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_COUNT_DTOR
(
mozilla
:
:
dom
:
:
AutoWriteTransaction
)
;
if
(
mConnection
)
{
if
(
NS_FAILED
(
mConnection
-
>
RollbackWriteTransaction
(
)
)
)
{
NS_WARNING
(
"
Failed
to
rollback
write
transaction
!
"
)
;
}
if
(
mShadowWrites
&
&
NS_FAILED
(
DetachShadowDatabaseAndUnlock
(
)
)
)
{
NS_WARNING
(
"
Failed
to
detach
shadow
database
!
"
)
;
}
}
}
nsresult
AutoWriteTransaction
:
:
Start
(
Connection
*
aConnection
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
MOZ_ASSERT
(
!
mConnection
)
;
nsresult
rv
;
if
(
mShadowWrites
)
{
rv
=
LockAndAttachShadowDatabase
(
aConnection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
aConnection
-
>
BeginWriteTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mConnection
=
aConnection
;
return
NS_OK
;
}
nsresult
AutoWriteTransaction
:
:
Commit
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
nsresult
rv
=
mConnection
-
>
CommitWriteTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mShadowWrites
)
{
rv
=
DetachShadowDatabaseAndUnlock
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
mConnection
=
nullptr
;
return
NS_OK
;
}
nsresult
AutoWriteTransaction
:
:
LockAndAttachShadowDatabase
(
Connection
*
aConnection
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
aConnection
)
;
MOZ_ASSERT
(
!
mConnection
)
;
MOZ_ASSERT
(
mShadowDatabaseLock
.
isNothing
(
)
)
;
MOZ_ASSERT
(
mShadowWrites
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
nsCOMPtr
<
mozIStorageConnection
>
storageConnection
=
aConnection
-
>
StorageConnection
(
)
;
MOZ_ASSERT
(
storageConnection
)
;
mShadowDatabaseLock
.
emplace
(
aConnection
-
>
GetQuotaClient
(
)
-
>
ShadowDatabaseMutex
(
)
)
;
nsresult
rv
=
AttachShadowDatabase
(
quotaManager
-
>
GetBasePath
(
)
storageConnection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
AutoWriteTransaction
:
:
DetachShadowDatabaseAndUnlock
(
)
{
AssertIsOnConnectionThread
(
)
;
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
mShadowDatabaseLock
.
isSome
(
)
)
;
MOZ_ASSERT
(
mShadowWrites
)
;
nsCOMPtr
<
mozIStorageConnection
>
storageConnection
=
mConnection
-
>
StorageConnection
(
)
;
MOZ_ASSERT
(
storageConnection
)
;
nsresult
rv
=
DetachShadowDatabase
(
storageConnection
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mShadowDatabaseLock
.
reset
(
)
;
return
NS_OK
;
}
}
