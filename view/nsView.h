#
ifndef
nsView_h__
#
define
nsView_h__
#
include
"
nsCoord
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
class
nsViewManager
;
class
nsIWidget
;
class
nsIFrame
;
namespace
mozilla
{
class
PresShell
;
namespace
widget
{
struct
InitData
;
enum
class
TransparencyMode
:
uint8_t
;
enum
class
WindowType
:
uint8_t
;
}
}
enum
class
ViewVisibility
:
uint8_t
{
Hide
=
0
Show
=
1
}
;
#
define
NS_VIEW_FLAG_AUTO_ZINDEX
0x0004
#
define
NS_VIEW_FLAG_FLOATING
0x0008
class
nsView
final
:
public
nsIWidgetListener
{
public
:
friend
class
nsViewManager
;
typedef
mozilla
:
:
LayoutDeviceIntRect
LayoutDeviceIntRect
;
typedef
mozilla
:
:
LayoutDeviceIntRegion
LayoutDeviceIntRegion
;
void
operator
delete
(
void
*
ptr
)
{
:
:
operator
delete
(
ptr
)
;
}
nsViewManager
*
GetViewManager
(
)
const
{
return
mViewManager
;
}
static
nsView
*
GetViewFor
(
const
nsIWidget
*
aWidget
)
;
void
Destroy
(
)
;
nsPoint
GetPosition
(
)
const
{
NS_ASSERTION
(
!
IsRoot
(
)
|
|
(
mPosX
=
=
0
&
&
mPosY
=
=
0
)
"
root
views
should
always
have
explicit
position
of
(
0
0
)
"
)
;
return
nsPoint
(
mPosX
mPosY
)
;
}
nsRect
GetBounds
(
)
const
{
return
mDimBounds
;
}
nsRect
GetDimensions
(
)
const
{
nsRect
r
=
mDimBounds
;
r
.
MoveBy
(
-
mPosX
-
mPosY
)
;
return
r
;
}
nsPoint
GetOffsetTo
(
const
nsView
*
aOther
)
const
;
nsPoint
GetOffsetToWidget
(
nsIWidget
*
aWidget
)
const
;
ViewVisibility
GetVisibility
(
)
const
{
return
mVis
;
}
bool
GetFloating
(
)
const
{
return
(
mVFlags
&
NS_VIEW_FLAG_FLOATING
)
!
=
0
;
}
nsView
*
GetParent
(
)
const
{
return
mParent
;
}
nsView
*
GetFirstChild
(
)
const
{
return
mFirstChild
;
}
nsView
*
GetNextSibling
(
)
const
{
return
mNextSibling
;
}
void
SetFrame
(
nsIFrame
*
aRootFrame
)
{
mFrame
=
aRootFrame
;
}
nsIFrame
*
GetFrame
(
)
const
{
return
mFrame
;
}
nsIWidget
*
GetNearestWidget
(
nsPoint
*
aOffset
)
const
;
nsresult
CreateWidget
(
mozilla
:
:
widget
:
:
InitData
*
aWidgetInitData
=
nullptr
bool
aEnableDragDrop
=
true
bool
aResetVisibility
=
true
)
;
nsresult
CreateWidgetForParent
(
nsIWidget
*
aParentWidget
mozilla
:
:
widget
:
:
InitData
*
=
nullptr
bool
aEnableDragDrop
=
true
bool
aResetVisibility
=
true
)
;
nsresult
CreateWidgetForPopup
(
mozilla
:
:
widget
:
:
InitData
*
nsIWidget
*
aParentWidget
=
nullptr
)
;
void
DestroyWidget
(
)
;
nsresult
AttachToTopLevelWidget
(
nsIWidget
*
aWidget
)
;
nsresult
DetachFromTopLevelWidget
(
)
;
bool
IsAttachedToTopLevel
(
)
const
{
return
mWidgetIsTopLevel
;
}
nsIWidget
*
GetWidget
(
)
const
{
return
mWindow
;
}
void
SetPreviousWidget
(
nsIWidget
*
aWidget
)
{
mPreviousWindow
=
aWidget
;
}
bool
HasWidget
(
)
const
{
return
mWindow
!
=
nullptr
;
}
void
SetForcedRepaint
(
bool
aForceRepaint
)
{
mForcedRepaint
=
aForceRepaint
;
}
void
SetNeedsWindowPropertiesSync
(
)
;
void
AttachWidgetEventHandler
(
nsIWidget
*
aWidget
)
;
void
DetachWidgetEventHandler
(
nsIWidget
*
aWidget
)
;
#
ifdef
DEBUG
virtual
void
List
(
FILE
*
out
int32_t
aIndent
=
0
)
const
;
#
endif
bool
IsRoot
(
)
const
;
LayoutDeviceIntRect
CalcWidgetBounds
(
mozilla
:
:
widget
:
:
WindowType
mozilla
:
:
widget
:
:
TransparencyMode
)
;
LayoutDeviceIntRect
RecalcWidgetBounds
(
)
;
nsPoint
ViewToWidgetOffset
(
)
const
{
return
mViewToWidgetOffset
;
}
void
SetPosition
(
nscoord
aX
nscoord
aY
)
;
void
SetZIndex
(
bool
aAuto
int32_t
aZIndex
)
;
bool
GetZIndexIsAuto
(
)
const
{
return
(
mVFlags
&
NS_VIEW_FLAG_AUTO_ZINDEX
)
!
=
0
;
}
int32_t
GetZIndex
(
)
const
{
return
mZIndex
;
}
void
SetParent
(
nsView
*
aParent
)
{
mParent
=
aParent
;
}
void
SetNextSibling
(
nsView
*
aSibling
)
{
NS_ASSERTION
(
aSibling
!
=
this
"
Can
'
t
be
our
own
sibling
!
"
)
;
mNextSibling
=
aSibling
;
}
nsRegion
&
GetDirtyRegion
(
)
{
if
(
!
mDirtyRegion
)
{
NS_ASSERTION
(
!
mParent
|
|
GetFloating
(
)
"
Only
display
roots
should
have
dirty
regions
"
)
;
mDirtyRegion
=
mozilla
:
:
MakeUnique
<
nsRegion
>
(
)
;
}
return
*
mDirtyRegion
;
}
virtual
mozilla
:
:
PresShell
*
GetPresShell
(
)
override
;
virtual
nsView
*
GetView
(
)
override
{
return
this
;
}
virtual
bool
WindowMoved
(
nsIWidget
*
aWidget
int32_t
x
int32_t
y
ByMoveToRect
)
override
;
virtual
bool
WindowResized
(
nsIWidget
*
aWidget
int32_t
aWidth
int32_t
aHeight
)
override
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
virtual
void
DynamicToolbarMaxHeightChanged
(
mozilla
:
:
ScreenIntCoord
aHeight
)
override
;
virtual
void
DynamicToolbarOffsetChanged
(
mozilla
:
:
ScreenIntCoord
aOffset
)
override
;
#
endif
virtual
bool
RequestWindowClose
(
nsIWidget
*
aWidget
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
WillPaintWindow
(
nsIWidget
*
aWidget
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
bool
PaintWindow
(
nsIWidget
*
aWidget
LayoutDeviceIntRegion
aRegion
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
DidPaintWindow
(
)
override
;
virtual
void
DidCompositeWindow
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aCompositeStart
const
mozilla
:
:
TimeStamp
&
aCompositeEnd
)
override
;
virtual
void
RequestRepaint
(
)
override
;
virtual
bool
ShouldNotBeVisible
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsEventStatus
HandleEvent
(
mozilla
:
:
WidgetGUIEvent
*
aEvent
bool
aUseAttachedEvents
)
override
;
virtual
void
SafeAreaInsetsChanged
(
const
mozilla
:
:
ScreenIntMargin
&
)
override
;
virtual
~
nsView
(
)
;
nsPoint
GetOffsetTo
(
const
nsView
*
aOther
const
int32_t
aAPD
)
const
;
nsIWidget
*
GetNearestWidget
(
nsPoint
*
aOffset
const
int32_t
aAPD
)
const
;
bool
IsPrimaryFramePaintSuppressed
(
)
;
private
:
explicit
nsView
(
nsViewManager
*
=
nullptr
ViewVisibility
=
ViewVisibility
:
:
Show
)
;
bool
ForcedRepaint
(
)
{
return
mForcedRepaint
;
}
void
DoResetWidgetBounds
(
bool
aMoveOnly
bool
aInvalidateChangedSize
)
;
void
InitializeWindow
(
bool
aEnableDragDrop
bool
aResetVisibility
)
;
bool
IsEffectivelyVisible
(
)
;
void
SetDimensions
(
const
nsRect
&
aRect
bool
aPaint
=
true
bool
aResizeWidget
=
true
)
;
void
SetVisibility
(
ViewVisibility
visibility
)
;
void
SetFloating
(
bool
aFloatingView
)
;
void
DropMouseGrabbing
(
)
;
bool
HasNonEmptyDirtyRegion
(
)
{
return
mDirtyRegion
&
&
!
mDirtyRegion
-
>
IsEmpty
(
)
;
}
void
InsertChild
(
nsView
*
aChild
nsView
*
aSibling
)
;
void
RemoveChild
(
nsView
*
aChild
)
;
void
ResetWidgetBounds
(
bool
aRecurse
bool
aForceSync
)
;
void
AssertNoWindow
(
)
;
void
NotifyEffectiveVisibilityChanged
(
bool
aEffectivelyVisible
)
;
void
InvalidateHierarchy
(
)
;
nsViewManager
*
mViewManager
;
nsView
*
mParent
;
nsCOMPtr
<
nsIWidget
>
mWindow
;
nsCOMPtr
<
nsIWidget
>
mPreviousWindow
;
nsView
*
mNextSibling
;
nsView
*
mFirstChild
;
nsIFrame
*
mFrame
;
mozilla
:
:
UniquePtr
<
nsRegion
>
mDirtyRegion
;
int32_t
mZIndex
;
ViewVisibility
mVis
;
nscoord
mPosX
mPosY
;
nsRect
mDimBounds
;
nsPoint
mViewToWidgetOffset
;
uint32_t
mVFlags
;
bool
mWidgetIsTopLevel
;
bool
mForcedRepaint
;
bool
mNeedsWindowPropertiesSync
;
}
;
#
endif
