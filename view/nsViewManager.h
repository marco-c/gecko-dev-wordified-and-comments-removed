#
ifndef
nsViewManager_h___
#
define
nsViewManager_h___
#
include
"
nscore
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
class
nsIWidget
;
struct
nsRect
;
class
nsRegion
;
class
nsDeviceContext
;
namespace
mozilla
{
class
PresShell
;
}
class
nsViewManager
final
{
~
nsViewManager
(
)
;
public
:
friend
class
nsView
;
typedef
mozilla
:
:
LayoutDeviceIntRect
LayoutDeviceIntRect
;
typedef
mozilla
:
:
LayoutDeviceIntRegion
LayoutDeviceIntRegion
;
NS_INLINE_DECL_REFCOUNTING
(
nsViewManager
)
nsViewManager
(
)
;
nsresult
Init
(
nsDeviceContext
*
aContext
)
;
nsView
*
CreateView
(
const
nsRect
&
aBounds
nsView
*
aParent
nsViewVisibility
aVisibilityFlag
=
nsViewVisibility_kShow
)
;
nsView
*
GetRootView
(
)
{
return
mRootView
;
}
void
SetRootView
(
nsView
*
aView
)
;
void
GetWindowDimensions
(
nscoord
*
aWidth
nscoord
*
aHeight
)
;
void
SetWindowDimensions
(
nscoord
aWidth
nscoord
aHeight
bool
aDelayResize
=
false
)
;
void
FlushDelayedResize
(
bool
aDoReflow
)
;
void
InvalidateView
(
nsView
*
aView
)
;
void
InvalidateViewNoSuppression
(
nsView
*
aView
const
nsRect
&
aRect
)
;
void
InvalidateAllViews
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DispatchEvent
(
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsView
*
aViewTarget
nsEventStatus
*
aStatus
)
;
void
InsertChild
(
nsView
*
aParent
nsView
*
aChild
nsView
*
aSibling
bool
aAfter
)
;
void
RemoveChild
(
nsView
*
aChild
)
;
void
MoveViewTo
(
nsView
*
aView
nscoord
aX
nscoord
aY
)
;
void
ResizeView
(
nsView
*
aView
const
nsRect
&
aRect
bool
aRepaintExposedAreaOnly
=
false
)
;
void
SetViewVisibility
(
nsView
*
aView
nsViewVisibility
aVisible
)
;
void
SetViewZIndex
(
nsView
*
aView
bool
aAutoZIndex
int32_t
aZindex
)
;
void
SetViewFloating
(
nsView
*
aView
bool
aFloatingView
)
;
void
SetPresShell
(
mozilla
:
:
PresShell
*
aPresShell
)
{
mPresShell
=
aPresShell
;
}
mozilla
:
:
PresShell
*
GetPresShell
(
)
const
{
return
mPresShell
;
}
nsDeviceContext
*
GetDeviceContext
(
)
const
{
return
mContext
;
}
class
MOZ_STACK_CLASS
AutoDisableRefresh
{
public
:
explicit
AutoDisableRefresh
(
nsViewManager
*
aVM
)
{
if
(
aVM
)
{
mRootVM
=
aVM
-
>
IncrementDisableRefreshCount
(
)
;
}
}
~
AutoDisableRefresh
(
)
{
if
(
mRootVM
)
{
mRootVM
-
>
DecrementDisableRefreshCount
(
)
;
}
}
private
:
AutoDisableRefresh
(
const
AutoDisableRefresh
&
aOther
)
;
const
AutoDisableRefresh
&
operator
=
(
const
AutoDisableRefresh
&
aOther
)
;
RefPtr
<
nsViewManager
>
mRootVM
;
}
;
private
:
friend
class
AutoDisableRefresh
;
nsViewManager
*
IncrementDisableRefreshCount
(
)
;
void
DecrementDisableRefreshCount
(
)
;
public
:
already_AddRefed
<
nsIWidget
>
GetRootWidget
(
)
;
void
IsPainting
(
bool
&
aIsPainting
)
;
void
GetLastUserEventTime
(
uint32_t
&
aTime
)
;
static
nsView
*
GetDisplayRootFor
(
nsView
*
aView
)
;
MOZ_CAN_RUN_SCRIPT
void
ProcessPendingUpdates
(
)
;
MOZ_CAN_RUN_SCRIPT
void
UpdateWidgetGeometry
(
)
;
int32_t
AppUnitsPerDevPixel
(
)
const
{
return
mContext
-
>
AppUnitsPerDevPixel
(
)
;
}
private
:
static
uint32_t
gLastUserEventTime
;
void
InvalidateHierarchy
(
)
;
void
FlushPendingInvalidates
(
)
;
MOZ_CAN_RUN_SCRIPT
void
ProcessPendingUpdatesForView
(
nsView
*
aView
bool
aFlushDirtyRegion
=
true
)
;
void
ProcessPendingUpdatesRecurse
(
nsView
*
aView
AutoTArray
<
nsCOMPtr
<
nsIWidget
>
1
>
&
aWidgets
)
;
MOZ_CAN_RUN_SCRIPT
void
ProcessPendingUpdatesPaint
(
nsIWidget
*
aWidget
)
;
void
FlushDirtyRegionToWidget
(
nsView
*
aView
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
CallWillPaintOnObservers
(
)
;
void
ReparentChildWidgets
(
nsView
*
aView
nsIWidget
*
aNewWidget
)
;
void
ReparentWidgets
(
nsView
*
aView
nsView
*
aParent
)
;
void
InvalidateWidgetArea
(
nsView
*
aWidgetView
const
nsRegion
&
aDamagedRegion
)
;
void
InvalidateViews
(
nsView
*
aView
)
;
MOZ_CAN_RUN_SCRIPT
void
Refresh
(
nsView
*
aView
const
LayoutDeviceIntRegion
&
aRegion
)
;
bool
IsViewInserted
(
nsView
*
aView
)
;
LayoutDeviceIntRect
ViewToWidget
(
nsView
*
aView
const
nsRect
&
aRect
)
const
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
DoSetWindowDimensions
(
nscoord
aWidth
nscoord
aHeight
bool
aDoReflow
)
;
bool
ShouldDelayResize
(
)
const
;
bool
IsPainting
(
)
const
{
return
RootViewManager
(
)
-
>
mPainting
;
}
void
SetPainting
(
bool
aPainting
)
{
RootViewManager
(
)
-
>
mPainting
=
aPainting
;
}
void
InvalidateView
(
nsView
*
aView
const
nsRect
&
aRect
)
;
nsViewManager
*
RootViewManager
(
)
const
{
return
mRootViewManager
?
mRootViewManager
.
get
(
)
:
const_cast
<
nsViewManager
*
>
(
this
)
;
}
bool
IsRootVM
(
)
const
{
return
!
mRootViewManager
;
}
bool
IsPaintingAllowed
(
)
{
return
RootViewManager
(
)
-
>
mRefreshDisableCount
=
=
0
;
}
MOZ_CAN_RUN_SCRIPT
void
WillPaintWindow
(
nsIWidget
*
aWidget
)
;
MOZ_CAN_RUN_SCRIPT
bool
PaintWindow
(
nsIWidget
*
aWidget
const
LayoutDeviceIntRegion
&
aRegion
)
;
MOZ_CAN_RUN_SCRIPT
void
DidPaintWindow
(
)
;
void
PostPendingUpdate
(
)
;
RefPtr
<
nsDeviceContext
>
mContext
;
mozilla
:
:
PresShell
*
mPresShell
;
nsSize
mDelayedResize
;
nsView
*
mRootView
;
RefPtr
<
nsViewManager
>
mRootViewManager
;
int32_t
mRefreshDisableCount
;
bool
mPainting
;
bool
mRecursiveRefreshPending
;
bool
mHasPendingWidgetGeometryChanges
;
static
mozilla
:
:
StaticAutoPtr
<
nsTArray
<
nsViewManager
*
>
>
gViewManagers
;
}
;
#
endif
