from
__future__
import
absolute_import
import
argparse
import
glob
import
HTMLParser
import
logging
import
os
import
re
import
sys
import
urllib2
script_path
=
os
.
path
.
dirname
(
os
.
path
.
realpath
(
__file__
)
)
compare_locales_path
=
os
.
path
.
join
(
    
script_path
"
.
.
/
.
.
/
.
.
/
.
.
/
third_party
/
python
/
compare
-
locales
"
)
sys
.
path
.
insert
(
0
compare_locales_path
)
from
compare_locales
import
parser
logging
.
basicConfig
(
format
=
"
[
%
(
levelname
)
s
]
%
(
message
)
s
"
level
=
logging
.
INFO
)
DEFAULT_HEADER
=
(
    
"
#
This
Source
Code
Form
is
subject
to
the
terms
of
the
"
    
"
Mozilla
Public
\
n
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
"
    
"
was
not
distributed
with
this
\
n
#
file
You
can
obtain
"
    
"
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
\
n
"
)
CENTRAL_BASE_URL
=
(
    
"
https
:
/
/
hg
.
mozilla
.
org
/
"
    
"
mozilla
-
central
/
raw
-
file
/
tip
/
"
    
"
devtools
/
client
/
locales
/
en
-
US
/
"
)
HTML_PARSER
=
HTMLParser
.
HTMLParser
(
)
central_prop_cache
=
{
}
dtd_entities_cache
=
{
}
def
get_central_prop_content
(
prop_filename
)
:
    
if
prop_filename
in
central_prop_cache
:
        
return
central_prop_cache
[
prop_filename
]
    
url
=
CENTRAL_BASE_URL
+
prop_filename
    
logging
.
info
(
"
loading
localization
file
from
central
:
{
%
s
}
"
%
url
)
    
try
:
        
central_prop_cache
[
prop_filename
]
=
urllib2
.
urlopen
(
url
)
.
readlines
(
)
    
except
:
        
logging
.
error
(
"
failed
to
load
properties
file
from
central
:
{
%
s
}
"
%
url
)
        
central_prop_cache
[
prop_filename
]
=
[
]
    
return
central_prop_cache
[
prop_filename
]
def
get_localization_note
(
prop_name
prop_filename
)
:
    
prop_content
=
get_central_prop_content
(
prop_filename
)
    
comment_buffer
=
[
]
    
for
i
line
in
enumerate
(
prop_content
)
:
        
line
=
line
.
strip
(
"
\
n
"
)
.
strip
(
"
\
r
"
)
        
if
line
.
startswith
(
"
#
"
)
:
            
comment_buffer
.
append
(
line
)
        
elif
re
.
search
(
"
(
^
|
\
n
)
"
+
re
.
escape
(
prop_name
)
+
"
\
s
*
=
"
line
)
:
            
break
        
else
:
            
comment_buffer
=
[
]
    
return
"
\
n
"
.
join
(
comment_buffer
)
def
get_dtd_entities
(
dtd_path
)
:
    
if
dtd_path
in
dtd_entities_cache
:
        
return
dtd_entities_cache
[
dtd_path
]
    
dtd_parser
=
parser
.
getParser
(
"
.
dtd
"
)
    
dtd_parser
.
readFile
(
dtd_path
)
    
dtd_entities_cache
[
dtd_path
]
=
dtd_parser
.
parse
(
)
    
return
dtd_entities_cache
[
dtd_path
]
def
get_translation_from_dtd
(
dtd_path
entity_name
)
:
    
entities
map
=
get_dtd_entities
(
dtd_path
)
    
if
entity_name
not
in
map
:
        
return
    
key
=
map
[
entity_name
]
    
entity
=
entities
[
key
]
    
translation
=
HTML_PARSER
.
unescape
(
entity
.
val
)
    
return
translation
.
encode
(
"
utf
-
8
"
)
def
get_properties_header
(
prop_filename
)
:
    
prop_content
=
get_central_prop_content
(
prop_filename
)
    
if
len
(
prop_content
)
=
=
0
:
        
return
DEFAULT_HEADER
    
header_buffer
=
[
]
    
for
i
line
in
enumerate
(
prop_content
)
:
        
line
=
line
.
strip
(
"
\
n
"
)
.
strip
(
"
\
r
"
)
        
is_entity_line
=
re
.
search
(
            
"
^
(
\
s
*
)
"
"
(
(
?
:
[
#
!
]
.
*
?
\
n
\
s
*
)
*
)
"
"
(
[
^
#
!
\
s
\
n
]
[
^
=
:
\
n
]
*
?
)
\
s
*
[
:
=
]
[
\
t
]
*
"
line
        
)
        
is_loc_note
=
re
.
search
(
"
^
(
\
s
*
)
"
"
\
#
\
s
*
LOCALIZATION
NOTE
\
s
*
\
(
[
^
)
]
+
\
)
"
line
)
        
if
is_entity_line
or
is_loc_note
:
            
break
        
else
:
            
header_buffer
.
append
(
line
)
    
return
"
\
n
"
.
join
(
header_buffer
)
def
create_properties_file
(
prop_path
)
:
    
logging
.
info
(
"
creating
new
*
.
properties
file
:
{
%
s
}
"
%
prop_path
)
    
prop_filename
=
os
.
path
.
basename
(
prop_path
)
    
header
=
get_properties_header
(
prop_filename
)
    
prop_file
=
open
(
prop_path
"
w
+
"
)
    
prop_file
.
write
(
header
)
    
prop_file
.
close
(
)
def
migrate_string
(
dtd_path
prop_path
dtd_name
prop_name
)
:
    
if
not
os
.
path
.
isfile
(
dtd_path
)
:
        
logging
.
error
(
"
dtd
file
can
not
be
found
at
:
{
%
s
}
"
%
dtd_path
)
        
return
    
translation
=
get_translation_from_dtd
(
dtd_path
dtd_name
)
    
if
not
translation
:
        
logging
.
error
(
            
"
translation
could
not
be
found
for
:
{
%
s
}
in
{
%
s
}
"
%
(
dtd_name
dtd_path
)
        
)
        
return
    
if
not
os
.
path
.
isfile
(
prop_path
)
:
        
create_properties_file
(
prop_path
)
    
if
not
os
.
path
.
isfile
(
prop_path
)
:
        
logging
.
error
(
"
could
not
create
new
properties
file
at
:
{
%
s
}
"
%
prop_path
)
        
return
    
prop_line
=
prop_name
+
"
=
"
+
translation
+
"
\
n
"
    
prop_file_content
=
open
(
prop_path
"
r
"
)
.
read
(
)
    
if
prop_line
in
prop_file_content
:
        
logging
.
warning
(
"
string
already
migrated
skipping
:
{
%
s
}
"
%
prop_name
)
        
return
    
if
re
.
search
(
"
(
^
|
\
n
)
"
+
re
.
escape
(
prop_name
)
+
"
\
s
*
=
"
prop_file_content
)
:
        
logging
.
error
(
"
existing
string
found
skipping
:
{
%
s
}
"
%
prop_name
)
        
return
    
prop_filename
=
os
.
path
.
basename
(
prop_path
)
    
logging
.
info
(
"
migrating
{
%
s
}
in
{
%
s
}
"
%
(
prop_name
prop_filename
)
)
    
with
open
(
prop_path
"
a
"
)
as
prop_file
:
        
localization_note
=
get_localization_note
(
prop_name
prop_filename
)
        
if
len
(
localization_note
)
:
            
prop_file
.
write
(
"
\
n
"
+
localization_note
)
        
else
:
            
logging
.
warning
(
                
"
localization
notes
could
not
be
found
for
:
{
%
s
}
"
%
prop_name
            
)
        
prop_file
.
write
(
"
\
n
"
+
prop_line
)
def
migrate_conf
(
conf_path
l10n_path
)
:
    
f
=
open
(
conf_path
"
r
"
)
    
lines
=
f
.
readlines
(
)
    
f
.
close
(
)
    
for
i
line
in
enumerate
(
lines
)
:
        
line
=
line
.
strip
(
"
\
n
"
)
.
strip
(
"
\
r
"
)
        
if
"
=
"
not
in
line
:
            
continue
        
prop_info
dtd_info
=
line
.
split
(
"
=
"
)
        
prop_path
prop_name
=
prop_info
.
split
(
"
:
"
)
        
dtd_path
dtd_name
=
dtd_info
.
split
(
"
:
"
)
        
dtd_path
=
os
.
path
.
join
(
l10n_path
dtd_path
)
        
prop_path
=
os
.
path
.
join
(
l10n_path
prop_path
)
        
migrate_string
(
dtd_path
prop_path
dtd_name
prop_name
)
def
main
(
)
:
    
arg_parser
=
argparse
.
ArgumentParser
(
        
description
=
"
Migrate
devtools
localized
strings
.
"
    
)
    
arg_parser
.
add_argument
(
"
path
"
type
=
str
help
=
"
path
to
l10n
repository
"
)
    
arg_parser
.
add_argument
(
        
"
-
c
"
"
-
-
config
"
type
=
str
help
=
"
path
to
configuration
file
or
folder
"
    
)
    
args
=
arg_parser
.
parse_args
(
)
    
devtools_l10n_path
=
os
.
path
.
join
(
args
.
path
"
devtools
/
client
/
"
)
    
if
not
os
.
path
.
exists
(
devtools_l10n_path
)
:
        
logging
.
error
(
"
l10n
path
is
invalid
:
{
%
s
}
"
%
devtools_l10n_path
)
        
exit
(
)
    
logging
.
info
(
"
l10n
path
is
valid
:
{
%
s
}
"
%
devtools_l10n_path
)
    
if
os
.
path
.
isdir
(
args
.
config
)
:
        
conf_files
=
glob
.
glob
(
args
.
config
+
"
*
"
)
    
elif
os
.
path
.
isfile
(
args
.
config
)
:
        
conf_files
=
[
args
.
config
]
    
else
:
        
logging
.
error
(
"
config
path
is
invalid
:
{
%
s
}
"
%
args
.
config
)
        
exit
(
)
    
for
conf_file
in
conf_files
:
        
logging
.
info
(
"
performing
migration
for
config
file
:
{
%
s
}
"
%
conf_file
)
        
migrate_conf
(
conf_file
devtools_l10n_path
)
if
__name__
=
=
"
__main__
"
:
    
main
(
)
