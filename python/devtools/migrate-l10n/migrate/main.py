from
__future__
import
absolute_import
import
argparse
import
glob
import
HTMLParser
import
logging
import
os
import
re
import
sys
import
urllib2
script_path
=
os
.
path
.
dirname
(
os
.
path
.
realpath
(
__file__
)
)
compare_locales_path
=
os
.
path
.
join
(
script_path
'
.
.
/
.
.
/
.
.
/
.
.
/
third_party
/
python
/
compare
-
locales
'
)
sys
.
path
.
insert
(
0
compare_locales_path
)
from
compare_locales
import
parser
logging
.
basicConfig
(
format
=
'
[
%
(
levelname
)
s
]
%
(
message
)
s
'
level
=
logging
.
INFO
)
DEFAULT_HEADER
=
(
'
#
This
Source
Code
Form
is
subject
to
the
terms
of
the
'
                  
'
Mozilla
Public
\
n
#
License
v
.
2
.
0
.
If
a
copy
of
the
MPL
'
                  
'
was
not
distributed
with
this
\
n
#
file
You
can
obtain
'
                  
'
one
at
http
:
/
/
mozilla
.
org
/
MPL
/
2
.
0
/
.
\
n
'
)
CENTRAL_BASE_URL
=
(
'
https
:
/
/
hg
.
mozilla
.
org
/
'
                    
'
mozilla
-
central
/
raw
-
file
/
tip
/
'
                    
'
devtools
/
client
/
locales
/
en
-
US
/
'
)
HTML_PARSER
=
HTMLParser
.
HTMLParser
(
)
central_prop_cache
=
{
}
dtd_entities_cache
=
{
}
def
get_central_prop_content
(
prop_filename
)
:
    
if
prop_filename
in
central_prop_cache
:
        
return
central_prop_cache
[
prop_filename
]
    
url
=
CENTRAL_BASE_URL
+
prop_filename
    
logging
.
info
(
'
loading
localization
file
from
central
:
{
%
s
}
'
%
url
)
    
try
:
        
central_prop_cache
[
prop_filename
]
=
urllib2
.
urlopen
(
url
)
.
readlines
(
)
    
except
:
        
logging
.
error
(
'
failed
to
load
properties
file
from
central
:
{
%
s
}
'
                      
%
url
)
        
central_prop_cache
[
prop_filename
]
=
[
]
    
return
central_prop_cache
[
prop_filename
]
def
get_localization_note
(
prop_name
prop_filename
)
:
    
prop_content
=
get_central_prop_content
(
prop_filename
)
    
comment_buffer
=
[
]
    
for
i
line
in
enumerate
(
prop_content
)
:
        
line
=
line
.
strip
(
'
\
n
'
)
.
strip
(
'
\
r
'
)
        
if
line
.
startswith
(
'
#
'
)
:
            
comment_buffer
.
append
(
line
)
        
elif
re
.
search
(
'
(
^
|
\
n
)
'
+
re
.
escape
(
prop_name
)
+
'
\
s
*
=
'
line
)
:
            
break
;
        
else
:
            
comment_buffer
=
[
]
    
return
'
\
n
'
.
join
(
comment_buffer
)
def
get_dtd_entities
(
dtd_path
)
:
    
if
dtd_path
in
dtd_entities_cache
:
        
return
dtd_entities_cache
[
dtd_path
]
    
dtd_parser
=
parser
.
getParser
(
'
.
dtd
'
)
    
dtd_parser
.
readFile
(
dtd_path
)
    
dtd_entities_cache
[
dtd_path
]
=
dtd_parser
.
parse
(
)
    
return
dtd_entities_cache
[
dtd_path
]
def
get_translation_from_dtd
(
dtd_path
entity_name
)
:
    
entities
map
=
get_dtd_entities
(
dtd_path
)
    
if
entity_name
not
in
map
:
        
return
    
key
=
map
[
entity_name
]
    
entity
=
entities
[
key
]
    
translation
=
HTML_PARSER
.
unescape
(
entity
.
val
)
    
return
translation
.
encode
(
'
utf
-
8
'
)
def
get_properties_header
(
prop_filename
)
:
    
prop_content
=
get_central_prop_content
(
prop_filename
)
    
if
len
(
prop_content
)
=
=
0
:
        
return
DEFAULT_HEADER
    
header_buffer
=
[
]
    
for
i
line
in
enumerate
(
prop_content
)
:
        
line
=
line
.
strip
(
'
\
n
'
)
.
strip
(
'
\
r
'
)
        
is_entity_line
=
re
.
search
(
'
^
(
\
s
*
)
'
                                   
'
(
(
?
:
[
#
!
]
.
*
?
\
n
\
s
*
)
*
)
'
                                   
'
(
[
^
#
!
\
s
\
n
]
[
^
=
:
\
n
]
*
?
)
\
s
*
[
:
=
]
[
\
t
]
*
'
line
)
        
is_loc_note
=
re
.
search
(
'
^
(
\
s
*
)
'
                                
'
\
#
\
s
*
LOCALIZATION
NOTE
\
s
*
\
(
[
^
)
]
+
\
)
'
line
)
        
if
is_entity_line
or
is_loc_note
:
            
break
        
else
:
            
header_buffer
.
append
(
line
)
    
return
'
\
n
'
.
join
(
header_buffer
)
def
create_properties_file
(
prop_path
)
:
    
logging
.
info
(
'
creating
new
*
.
properties
file
:
{
%
s
}
'
%
prop_path
)
    
prop_filename
=
os
.
path
.
basename
(
prop_path
)
    
header
=
get_properties_header
(
prop_filename
)
    
prop_file
=
open
(
prop_path
'
w
+
'
)
    
prop_file
.
write
(
header
)
    
prop_file
.
close
(
)
def
migrate_string
(
dtd_path
prop_path
dtd_name
prop_name
)
:
    
if
not
os
.
path
.
isfile
(
dtd_path
)
:
        
logging
.
error
(
'
dtd
file
can
not
be
found
at
:
{
%
s
}
'
%
dtd_path
)
        
return
    
translation
=
get_translation_from_dtd
(
dtd_path
dtd_name
)
    
if
not
translation
:
        
logging
.
error
(
'
translation
could
not
be
found
for
:
{
%
s
}
in
{
%
s
}
'
                      
%
(
dtd_name
dtd_path
)
)
        
return
    
if
not
os
.
path
.
isfile
(
prop_path
)
:
        
create_properties_file
(
prop_path
)
    
if
not
os
.
path
.
isfile
(
prop_path
)
:
        
logging
.
error
(
'
could
not
create
new
properties
file
at
:
{
%
s
}
'
                      
%
prop_path
)
        
return
    
prop_line
=
prop_name
+
'
=
'
+
translation
+
'
\
n
'
    
prop_file_content
=
open
(
prop_path
'
r
'
)
.
read
(
)
    
if
prop_line
in
prop_file_content
:
        
logging
.
warning
(
'
string
already
migrated
skipping
:
{
%
s
}
'
%
prop_name
)
        
return
    
if
re
.
search
(
'
(
^
|
\
n
)
'
+
re
.
escape
(
prop_name
)
+
'
\
s
*
=
'
prop_file_content
)
:
        
logging
.
error
(
'
existing
string
found
skipping
:
{
%
s
}
'
%
prop_name
)
        
return
    
prop_filename
=
os
.
path
.
basename
(
prop_path
)
    
logging
.
info
(
'
migrating
{
%
s
}
in
{
%
s
}
'
%
(
prop_name
prop_filename
)
)
    
with
open
(
prop_path
'
a
'
)
as
prop_file
:
        
localization_note
=
get_localization_note
(
prop_name
prop_filename
)
        
if
len
(
localization_note
)
:
            
prop_file
.
write
(
'
\
n
'
+
localization_note
)
        
else
:
            
logging
.
warning
(
'
localization
notes
could
not
be
found
for
:
{
%
s
}
'
                            
%
prop_name
)
        
prop_file
.
write
(
'
\
n
'
+
prop_line
)
def
migrate_conf
(
conf_path
l10n_path
)
:
    
f
=
open
(
conf_path
'
r
'
)
    
lines
=
f
.
readlines
(
)
    
f
.
close
(
)
    
for
i
line
in
enumerate
(
lines
)
:
        
line
=
line
.
strip
(
'
\
n
'
)
.
strip
(
'
\
r
'
)
        
if
'
=
'
not
in
line
:
            
continue
        
prop_info
dtd_info
=
line
.
split
(
'
=
'
)
        
prop_path
prop_name
=
prop_info
.
split
(
'
:
'
)
        
dtd_path
dtd_name
=
dtd_info
.
split
(
'
:
'
)
        
dtd_path
=
os
.
path
.
join
(
l10n_path
dtd_path
)
        
prop_path
=
os
.
path
.
join
(
l10n_path
prop_path
)
        
migrate_string
(
dtd_path
prop_path
dtd_name
prop_name
)
def
main
(
)
:
    
arg_parser
=
argparse
.
ArgumentParser
(
            
description
=
'
Migrate
devtools
localized
strings
.
'
)
    
arg_parser
.
add_argument
(
'
path
'
type
=
str
help
=
'
path
to
l10n
repository
'
)
    
arg_parser
.
add_argument
(
'
-
c
'
'
-
-
config
'
type
=
str
                            
help
=
'
path
to
configuration
file
or
folder
'
)
    
args
=
arg_parser
.
parse_args
(
)
    
devtools_l10n_path
=
os
.
path
.
join
(
args
.
path
'
devtools
/
client
/
'
)
    
if
not
os
.
path
.
exists
(
devtools_l10n_path
)
:
        
logging
.
error
(
'
l10n
path
is
invalid
:
{
%
s
}
'
%
devtools_l10n_path
)
        
exit
(
)
    
logging
.
info
(
'
l10n
path
is
valid
:
{
%
s
}
'
%
devtools_l10n_path
)
    
if
os
.
path
.
isdir
(
args
.
config
)
:
        
conf_files
=
glob
.
glob
(
args
.
config
+
'
*
'
)
    
elif
os
.
path
.
isfile
(
args
.
config
)
:
        
conf_files
=
[
args
.
config
]
    
else
:
        
logging
.
error
(
'
config
path
is
invalid
:
{
%
s
}
'
%
args
.
config
)
        
exit
(
)
    
for
conf_file
in
conf_files
:
        
logging
.
info
(
'
performing
migration
for
config
file
:
{
%
s
}
'
%
conf_file
)
        
migrate_conf
(
conf_file
devtools_l10n_path
)
if
__name__
=
=
'
__main__
'
:
    
main
(
)
