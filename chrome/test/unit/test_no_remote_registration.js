var
manifests
=
[
do_get_file
(
"
data
/
test_no_remote_registration
.
manifest
"
)
]
;
registerManifests
(
manifests
)
;
function
ProtocolHandler
(
aScheme
)
{
this
.
scheme
=
aScheme
;
}
ProtocolHandler
.
prototype
=
{
allowPort
:
(
)
=
>
false
newChannel
(
)
{
throw
Components
.
Exception
(
"
"
Cr
.
NS_ERROR_NOT_IMPLEMENTED
)
;
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
"
nsIProtocolHandler
"
]
)
}
;
var
testProtocols
=
[
{
scheme
:
"
moz
-
protocol
-
ui
-
resource
"
flags
:
Ci
.
nsIProtocolHandler
.
URI_IS_UI_RESOURCE
shouldRegister
:
false
}
{
scheme
:
"
moz
-
protocol
-
local
-
file
"
flags
:
Ci
.
nsIProtocolHandler
.
URI_IS_LOCAL_FILE
shouldRegister
:
false
}
{
scheme
:
"
moz
-
protocol
-
loadable
-
by
-
anyone
"
flags
:
Ci
.
nsIProtocolHandler
.
URI_LOADABLE_BY_ANYONE
shouldRegister
:
false
}
{
scheme
:
"
moz
-
protocol
-
local
-
resource
"
flags
:
Ci
.
nsIProtocolHandler
.
URI_IS_LOCAL_RESOURCE
shouldRegister
:
true
}
]
;
function
run_test
(
)
{
const
{
newAppInfo
}
=
ChromeUtils
.
importESModule
(
"
resource
:
/
/
testing
-
common
/
AppInfo
.
sys
.
mjs
"
)
;
let
XULAppInfo
=
newAppInfo
(
{
name
:
"
XPCShell
"
ID
:
"
{
39885e5f
-
f6b4
-
4e2a
-
87e5
-
6259ecf79011
}
"
version
:
"
5
"
platformVersion
:
"
1
.
9
"
}
)
;
const
uuidGenerator
=
Services
.
uuid
;
let
XULAppInfoFactory
=
{
CID
:
uuidGenerator
.
generateUUID
(
)
scheme
:
"
XULAppInfo
"
contractID
:
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
createInstance
(
iid
)
{
return
XULAppInfo
.
QueryInterface
(
iid
)
;
}
}
;
for
(
let
protocol
of
testProtocols
)
{
Services
.
io
.
registerProtocolHandler
(
protocol
.
scheme
new
ProtocolHandler
(
protocol
.
scheme
)
protocol
.
flags
-
1
)
;
}
let
registrar
=
Components
.
manager
.
QueryInterface
(
Ci
.
nsIComponentRegistrar
)
;
let
old_factory
=
{
CID
:
"
"
factory
:
null
}
;
if
(
!
registrar
.
isCIDRegistered
(
XULAppInfoFactory
.
CID
)
)
{
if
(
registrar
.
isContractIDRegistered
(
XULAppInfoFactory
.
contractID
)
)
{
dump
(
XULAppInfoFactory
.
scheme
+
"
is
already
registered
.
Storing
currently
registered
object
for
restoration
later
.
"
)
;
old_factory
.
CID
=
registrar
.
contractIDToCID
(
XULAppInfoFactory
.
contractID
)
;
old_factory
.
factory
=
Components
.
manager
.
getClassObject
(
Cc
[
XULAppInfoFactory
.
contractID
]
Ci
.
nsIFactory
)
;
}
else
{
dump
(
XULAppInfoFactory
.
scheme
+
"
has
never
been
registered
.
Registering
.
.
.
"
)
;
}
registrar
.
registerFactory
(
XULAppInfoFactory
.
CID
"
test
-
"
+
XULAppInfoFactory
.
scheme
XULAppInfoFactory
.
contractID
XULAppInfoFactory
)
;
}
else
{
do_throw
(
"
CID
"
+
XULAppInfoFactory
.
CID
+
"
has
already
been
registered
!
"
)
;
}
let
cr
=
Cc
[
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
]
.
getService
(
Ci
.
nsIChromeRegistry
)
;
cr
.
checkForNewChrome
(
)
;
let
registrationTypes
=
[
"
content
"
"
locale
"
"
skin
"
"
override
"
"
resource
"
]
;
for
(
let
i
=
0
;
i
<
testProtocols
.
length
;
i
+
+
)
{
let
protocol
=
testProtocols
[
i
]
;
for
(
let
j
=
0
;
j
<
registrationTypes
.
length
;
j
+
+
)
{
let
type
=
registrationTypes
[
j
]
;
dump
(
"
Testing
protocol
'
"
+
protocol
.
scheme
+
"
'
with
type
'
"
+
type
+
"
'
\
n
"
)
;
let
expectedURI
=
protocol
.
scheme
+
"
:
/
/
foo
/
"
;
let
sourceURI
=
"
chrome
:
/
/
"
+
protocol
.
scheme
+
"
/
"
+
type
+
"
/
"
;
switch
(
type
)
{
case
"
content
"
:
expectedURI
+
=
protocol
.
scheme
+
"
.
xul
"
;
break
;
case
"
locale
"
:
expectedURI
+
=
protocol
.
scheme
+
"
.
dtd
"
;
break
;
case
"
skin
"
:
expectedURI
+
=
protocol
.
scheme
+
"
.
css
"
;
break
;
case
"
override
"
:
sourceURI
=
"
chrome
:
/
/
good
-
package
/
content
/
override
-
"
+
protocol
.
scheme
+
"
.
xul
"
;
break
;
case
"
resource
"
:
sourceURI
=
"
resource
:
/
/
"
+
protocol
.
scheme
+
"
/
"
;
break
;
}
try
{
sourceURI
=
Services
.
io
.
newURI
(
sourceURI
)
;
let
uri
;
if
(
type
=
=
"
resource
"
)
{
let
rph
=
Services
.
io
.
getProtocolHandler
(
"
resource
"
)
.
QueryInterface
(
Ci
.
nsIResProtocolHandler
)
;
uri
=
rph
.
resolveURI
(
sourceURI
)
;
}
else
{
uri
=
cr
.
convertChromeURL
(
sourceURI
)
.
spec
;
}
if
(
protocol
.
shouldRegister
)
{
Assert
.
equal
(
expectedURI
uri
)
;
}
else
{
Assert
.
notEqual
(
expectedURI
uri
)
;
}
}
catch
(
e
)
{
if
(
protocol
.
shouldRegister
)
{
dump
(
e
+
"
\
n
"
)
;
do_throw
(
"
Should
have
registered
our
URI
for
protocol
"
+
protocol
.
scheme
)
;
}
}
}
}
for
(
let
protocol
of
testProtocols
)
{
Services
.
io
.
unregisterProtocolHandler
(
protocol
.
scheme
)
;
}
registrar
.
unregisterFactory
(
XULAppInfoFactory
.
CID
XULAppInfoFactory
)
;
if
(
old_factory
.
factory
!
=
null
)
{
registrar
.
registerFactory
(
old_factory
.
CID
"
"
XULAppInfoFactory
.
contractID
null
)
;
}
}
