#
import
<
IOKit
/
IOKitLib
.
h
>
#
import
<
sys
/
sysctl
.
h
>
#
import
<
math
.
h
>
#
import
"
smslib
.
h
"
#
pragma
mark
Internal
structures
typedef
struct
axisStruct
{
int
enabled
;
int
index
;
int
size
;
float
zerog
;
float
oneg
;
}
axisStruct
;
typedef
struct
sensorSpec
{
const
char
*
model
;
const
char
*
name
;
unsigned
int
function
;
int
recordSize
;
axisStruct
axes
[
3
]
;
}
sensorSpec
;
static
const
sensorSpec
sensors
[
]
=
{
{
"
PowerBook5
6
"
"
IOI2CMotionSensor
"
21
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
-
51
.
5
}
{
1
2
1
0
-
51
.
5
}
}
}
{
"
PowerBook5
7
"
"
IOI2CMotionSensor
"
21
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
51
.
5
}
{
1
2
1
0
51
.
5
}
}
}
{
"
PowerBook5
8
"
"
PMUMotionSensor
"
21
60
{
{
1
0
1
0
-
51
.
5
}
{
1
1
1
0
51
.
5
}
{
1
2
1
0
-
51
.
5
}
}
}
{
"
PowerBook5
9
"
"
PMUMotionSensor
"
21
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
-
51
.
5
}
{
1
2
1
0
-
51
.
5
}
}
}
{
"
PowerBook6
7
"
"
IOI2CMotionSensor
"
21
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
51
.
5
}
{
1
2
1
0
51
.
5
}
}
}
{
"
PowerBook6
8
"
"
IOI2CMotionSensor
"
21
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
51
.
5
}
{
1
2
1
0
51
.
5
}
}
}
{
"
MacBookPro2
1
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
251
}
{
1
2
2
0
-
251
}
{
1
4
2
0
-
251
}
}
}
{
"
MacBookPro3
1
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
-
251
}
{
1
2
2
0
251
}
{
1
4
2
0
-
251
}
}
}
{
"
MacBook5
2
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
-
251
}
{
1
2
2
0
251
}
{
1
4
2
0
-
251
}
}
}
{
"
MacBookPro5
1
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
-
251
}
{
1
2
2
0
-
251
}
{
1
4
2
0
251
}
}
}
{
"
MacBookPro5
2
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
-
251
}
{
1
2
2
0
-
251
}
{
1
4
2
0
251
}
}
}
{
"
MacBookPro5
3
"
"
SMCMotionSensor
"
5
40
{
{
1
2
2
0
-
251
}
{
1
0
2
0
-
251
}
{
1
4
2
0
-
251
}
}
}
{
"
MacBookPro5
4
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
-
251
}
{
1
2
2
0
-
251
}
{
1
4
2
0
251
}
}
}
{
"
"
"
IOI2CMotionSensor
"
24
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
51
.
5
}
{
1
2
1
0
51
.
5
}
}
}
{
"
"
"
IOI2CMotionSensor
"
21
60
{
{
1
0
1
0
51
.
5
}
{
1
1
1
0
51
.
5
}
{
1
2
1
0
51
.
5
}
}
}
{
"
"
"
PMUMotionSensor
"
21
60
{
{
1
0
1
0
-
51
.
5
}
{
1
1
1
-
6
-
51
.
5
}
{
1
2
1
0
-
51
.
5
}
}
}
{
"
"
"
SMCMotionSensor
"
5
40
{
{
1
0
2
0
251
}
{
1
2
2
0
251
}
{
1
4
2
0
251
}
}
}
}
;
#
define
SENSOR_COUNT
(
sizeof
(
sensors
)
/
sizeof
(
sensorSpec
)
)
#
pragma
mark
Internal
prototypes
static
int
getData
(
sms_acceleration
*
accel
int
calibrated
id
logObject
SEL
logSelector
)
;
static
float
getAxis
(
int
which
int
calibrated
)
;
static
int
signExtend
(
int
value
int
size
)
;
static
NSString
*
getModelName
(
void
)
;
static
NSString
*
getOSVersion
(
void
)
;
static
BOOL
loadCalibration
(
void
)
;
static
void
storeCalibration
(
void
)
;
static
void
defaultCalibration
(
void
)
;
static
void
deleteCalibration
(
void
)
;
static
int
prefIntRead
(
NSString
*
prefName
BOOL
*
success
)
;
static
void
prefIntWrite
(
NSString
*
prefName
int
prefValue
)
;
static
float
prefFloatRead
(
NSString
*
prefName
BOOL
*
success
)
;
static
void
prefFloatWrite
(
NSString
*
prefName
float
prefValue
)
;
static
void
prefDelete
(
NSString
*
prefName
)
;
static
void
prefSynchronize
(
void
)
;
float
fakeData
(
NSTimeInterval
time
)
;
#
pragma
mark
Static
variables
static
int
debugging
=
NO
;
static
io_connect_t
connection
;
static
int
running
=
NO
;
static
unsigned
int
sensorNum
=
0
;
static
const
char
*
serviceName
;
static
char
*
iRecord
*
oRecord
;
static
int
recordSize
;
static
unsigned
int
function
;
static
float
zeros
[
3
]
;
static
float
onegs
[
3
]
;
#
pragma
mark
Defines
#
define
INT_TO_AXIS
(
a
)
(
a
=
=
0
?
"
X
"
:
a
=
=
1
?
"
Y
"
:
"
Z
"
)
#
define
ZERO_NAME
(
a
)
[
NSString
stringWithFormat
:
"
%
-
Axis
-
Zero
"
INT_TO_AXIS
(
a
)
]
#
define
ONEG_NAME
(
a
)
\
[
NSString
stringWithFormat
:
"
%
-
Axis
-
One
-
g
"
INT_TO_AXIS
(
a
)
]
#
define
CALIBRATED_NAME
(
"
Calibrated
"
)
#
define
APP_ID
(
(
CFStringRef
)
"
com
.
suitable
.
SeisMacLib
"
)
#
undef
LOG
#
define
LOG
(
message
)
\
if
(
logObject
)
{
\
[
logObject
performSelector
:
logSelector
withObject
:
message
]
;
\
}
#
define
LOG_ARG
(
format
var1
)
\
if
(
logObject
)
{
\
[
logObject
performSelector
:
logSelector
\
withObject
:
[
NSString
stringWithFormat
:
format
var1
]
]
;
\
}
#
define
LOG_2ARG
(
format
var1
var2
)
\
if
(
logObject
)
{
\
[
logObject
\
performSelector
:
logSelector
\
withObject
:
[
NSString
stringWithFormat
:
format
var1
var2
]
]
;
\
}
#
define
LOG_3ARG
(
format
var1
var2
var3
)
\
if
(
logObject
)
{
\
[
logObject
\
performSelector
:
logSelector
\
withObject
:
[
NSString
stringWithFormat
:
format
var1
var2
var3
]
]
;
\
}
#
pragma
mark
Function
definitions
int
smsStartup
(
id
logObject
SEL
logSelector
)
{
io_iterator_t
iterator
;
io_object_t
device
;
kern_return_t
result
;
sms_acceleration
accel
;
int
failure_result
=
SMS_FAIL_MODEL
;
running
=
NO
;
debugging
=
NO
;
NSString
*
modelName
=
getModelName
(
)
;
LOG_ARG
(
"
Machine
model
:
%
\
n
"
modelName
)
;
LOG_ARG
(
"
OS
X
version
:
%
\
n
"
getOSVersion
(
)
)
;
LOG_ARG
(
"
Accelerometer
library
version
:
%
s
\
n
"
SMSLIB_VERSION
)
;
for
(
sensorNum
=
0
;
sensorNum
<
SENSOR_COUNT
;
sensorNum
+
+
)
{
serviceName
=
sensors
[
sensorNum
]
.
name
;
recordSize
=
sensors
[
sensorNum
]
.
recordSize
;
function
=
sensors
[
sensorNum
]
.
function
;
LOG_3ARG
(
"
Trying
service
\
"
%
s
\
"
with
selector
%
d
and
%
d
byte
record
:
\
n
"
serviceName
function
recordSize
)
;
NSString
*
targetName
=
[
NSString
stringWithCString
:
sensors
[
sensorNum
]
.
model
encoding
:
NSMacOSRomanStringEncoding
]
;
LOG_ARG
(
"
Comparing
model
name
to
target
\
"
%
\
"
:
"
targetName
)
;
if
(
[
targetName
length
]
=
=
0
|
|
[
modelName
hasPrefix
:
targetName
]
)
{
LOG
(
"
success
.
\
n
"
)
;
}
else
{
LOG
(
"
failure
.
\
n
"
)
;
continue
;
}
LOG
(
"
Fetching
dictionary
for
service
:
"
)
;
CFMutableDictionaryRef
dict
=
IOServiceMatching
(
serviceName
)
;
if
(
dict
)
{
LOG
(
"
success
.
\
n
"
)
;
}
else
{
LOG
(
"
failure
.
\
n
"
)
;
if
(
failure_result
<
SMS_FAIL_DICTIONARY
)
{
failure_result
=
SMS_FAIL_DICTIONARY
;
}
continue
;
}
LOG
(
"
Getting
list
of
matching
services
:
"
)
;
result
=
IOServiceGetMatchingServices
(
kIOMasterPortDefault
dict
&
iterator
)
;
if
(
result
=
=
KERN_SUCCESS
)
{
LOG
(
"
success
.
\
n
"
)
;
}
else
{
LOG_ARG
(
"
failure
with
return
value
0x
%
x
.
\
n
"
result
)
;
if
(
failure_result
<
SMS_FAIL_LIST_SERVICES
)
{
failure_result
=
SMS_FAIL_LIST_SERVICES
;
}
continue
;
}
LOG
(
"
Getting
first
device
in
list
:
"
)
;
device
=
IOIteratorNext
(
iterator
)
;
if
(
device
=
=
0
)
{
LOG
(
"
failure
.
\
n
"
)
;
if
(
failure_result
<
SMS_FAIL_NO_SERVICES
)
{
failure_result
=
SMS_FAIL_NO_SERVICES
;
}
continue
;
}
else
{
LOG
(
"
success
.
\
n
"
)
;
LOG
(
"
Opening
device
:
"
)
;
}
result
=
IOServiceOpen
(
device
mach_task_self
(
)
0
&
connection
)
;
if
(
result
!
=
KERN_SUCCESS
)
{
LOG_ARG
(
"
failure
with
return
value
0x
%
x
.
\
n
"
result
)
;
IOObjectRelease
(
device
)
;
if
(
failure_result
<
SMS_FAIL_OPENING
)
{
failure_result
=
SMS_FAIL_OPENING
;
}
continue
;
}
else
if
(
connection
=
=
0
)
{
LOG_ARG
(
"
'
success
'
but
didn
'
t
get
a
connection
(
return
value
was
:
0x
%
x
)
.
\
n
"
result
)
;
IOObjectRelease
(
device
)
;
if
(
failure_result
<
SMS_FAIL_CONNECTION
)
{
failure_result
=
SMS_FAIL_CONNECTION
;
}
continue
;
}
else
{
IOObjectRelease
(
device
)
;
LOG
(
"
success
.
\
n
"
)
;
}
LOG
(
"
Testing
device
.
\
n
"
)
;
defaultCalibration
(
)
;
iRecord
=
(
char
*
)
malloc
(
recordSize
)
;
oRecord
=
(
char
*
)
malloc
(
recordSize
)
;
running
=
YES
;
result
=
getData
(
&
accel
true
logObject
logSelector
)
;
running
=
NO
;
if
(
result
)
{
LOG_ARG
(
"
Failure
testing
device
with
result
0x
%
x
.
\
n
"
result
)
;
free
(
iRecord
)
;
iRecord
=
0
;
free
(
oRecord
)
;
oRecord
=
0
;
if
(
failure_result
<
SMS_FAIL_ACCESS
)
{
failure_result
=
SMS_FAIL_ACCESS
;
}
continue
;
}
else
{
LOG
(
"
Success
testing
device
!
\
n
"
)
;
running
=
YES
;
return
SMS_SUCCESS
;
}
}
return
failure_result
;
}
int
smsDebugStartup
(
id
logObject
SEL
logSelector
)
{
LOG
(
"
Starting
up
in
debug
mode
\
n
"
)
;
debugging
=
YES
;
return
SMS_SUCCESS
;
}
void
smsGetCalibration
(
sms_calibration
*
calibrationRecord
)
{
int
x
;
for
(
x
=
0
;
x
<
3
;
x
+
+
)
{
calibrationRecord
-
>
zeros
[
x
]
=
(
debugging
?
0
:
zeros
[
x
]
)
;
calibrationRecord
-
>
onegs
[
x
]
=
(
debugging
?
256
:
onegs
[
x
]
)
;
}
}
void
smsSetCalibration
(
sms_calibration
*
calibrationRecord
)
{
int
x
;
if
(
!
debugging
)
{
if
(
calibrationRecord
)
{
for
(
x
=
0
;
x
<
3
;
x
+
+
)
{
zeros
[
x
]
=
calibrationRecord
-
>
zeros
[
x
]
;
onegs
[
x
]
=
calibrationRecord
-
>
onegs
[
x
]
;
}
}
else
{
defaultCalibration
(
)
;
}
}
}
void
smsStoreCalibration
(
void
)
{
if
(
!
debugging
)
storeCalibration
(
)
;
}
BOOL
smsLoadCalibration
(
void
)
{
if
(
debugging
)
{
return
YES
;
}
else
if
(
loadCalibration
(
)
)
{
return
YES
;
}
else
{
defaultCalibration
(
)
;
return
NO
;
}
}
void
smsDeleteCalibration
(
void
)
{
if
(
!
debugging
)
{
deleteCalibration
(
)
;
defaultCalibration
(
)
;
}
}
int
smsGetData
(
sms_acceleration
*
accel
)
{
NSTimeInterval
time
;
if
(
debugging
)
{
usleep
(
1500
)
;
time
=
[
NSDate
timeIntervalSinceReferenceDate
]
;
accel
-
>
x
=
fakeData
(
time
)
/
5
;
accel
-
>
y
=
fakeData
(
time
-
1
)
/
5
;
accel
-
>
z
=
fakeData
(
time
-
2
)
/
5
+
1
.
0
;
return
true
;
}
else
{
return
getData
(
accel
true
nil
nil
)
;
}
}
int
smsGetUncalibratedData
(
sms_acceleration
*
accel
)
{
NSTimeInterval
time
;
if
(
debugging
)
{
usleep
(
1500
)
;
time
=
[
NSDate
timeIntervalSinceReferenceDate
]
;
accel
-
>
x
=
fakeData
(
time
)
*
256
/
5
;
accel
-
>
y
=
fakeData
(
time
-
1
)
*
256
/
5
;
accel
-
>
z
=
fakeData
(
time
-
2
)
*
256
/
5
+
256
;
return
true
;
}
else
{
return
getData
(
accel
false
nil
nil
)
;
}
}
int
smsGetBufferLength
(
void
)
{
if
(
debugging
)
{
return
0
;
}
else
if
(
running
)
{
return
sensors
[
sensorNum
]
.
recordSize
;
}
else
{
return
0
;
}
}
void
smsGetBufferData
(
char
*
buffer
)
{
IOItemCount
iSize
=
recordSize
;
IOByteCount
oSize
=
recordSize
;
kern_return_t
result
;
if
(
debugging
|
|
running
=
=
NO
)
{
return
;
}
memset
(
iRecord
1
iSize
)
;
memset
(
buffer
0
oSize
)
;
#
if
__MAC_OS_X_VERSION_MIN_REQUIRED
>
=
1050
const
size_t
InStructSize
=
recordSize
;
size_t
OutStructSize
=
recordSize
;
result
=
IOConnectCallStructMethod
(
connection
function
(
const
void
*
)
iRecord
InStructSize
(
void
*
)
buffer
&
OutStructSize
)
;
#
else
result
=
IOConnectMethodStructureIStructureO
(
connection
function
iSize
&
oSize
iRecord
buffer
)
;
#
endif
if
(
result
!
=
KERN_SUCCESS
)
{
running
=
NO
;
}
}
NSString
*
smsGetCalibrationDescription
(
void
)
{
BOOL
success
;
NSMutableString
*
s
=
[
[
NSMutableString
alloc
]
init
]
;
if
(
debugging
)
{
[
s
release
]
;
return
"
Debugging
!
"
;
}
[
s
appendString
:
"
-
-
-
-
SeisMac
Calibration
Record
-
-
-
-
\
n
\
n
"
]
;
[
s
appendFormat
:
"
Machine
model
:
%
\
n
"
getModelName
(
)
]
;
[
s
appendFormat
:
"
OS
X
build
:
%
\
n
"
getOSVersion
(
)
]
;
[
s
appendFormat
:
"
SeisMacLib
version
%
s
record
%
d
\
n
\
n
"
SMSLIB_VERSION
sensorNum
]
;
[
s
appendFormat
:
"
Using
service
\
"
%
s
\
"
function
index
%
d
size
%
d
\
n
\
n
"
serviceName
function
recordSize
]
;
if
(
prefIntRead
(
CALIBRATED_NAME
&
success
)
&
&
success
)
{
[
s
appendString
:
"
Calibration
values
(
from
calibration
)
:
\
n
"
]
;
}
else
{
[
s
appendString
:
"
Calibration
values
(
from
defaults
)
:
\
n
"
]
;
}
[
s
appendFormat
:
"
X
-
Axis
-
Zero
=
%
.
2f
\
n
"
zeros
[
0
]
]
;
[
s
appendFormat
:
"
X
-
Axis
-
One
-
g
=
%
.
2f
\
n
"
onegs
[
0
]
]
;
[
s
appendFormat
:
"
Y
-
Axis
-
Zero
=
%
.
2f
\
n
"
zeros
[
1
]
]
;
[
s
appendFormat
:
"
Y
-
Axis
-
One
-
g
=
%
.
2f
\
n
"
onegs
[
1
]
]
;
[
s
appendFormat
:
"
Z
-
Axis
-
Zero
=
%
.
2f
\
n
"
zeros
[
2
]
]
;
[
s
appendFormat
:
"
Z
-
Axis
-
One
-
g
=
%
.
2f
\
n
\
n
"
onegs
[
2
]
]
;
[
s
appendString
:
"
-
-
-
-
End
Record
-
-
-
-
\
n
"
]
;
return
s
;
}
void
smsShutdown
(
void
)
{
if
(
!
debugging
)
{
running
=
NO
;
if
(
iRecord
)
free
(
iRecord
)
;
if
(
oRecord
)
free
(
oRecord
)
;
IOServiceClose
(
connection
)
;
}
}
#
pragma
mark
Internal
functions
BOOL
loadCalibration
(
void
)
{
BOOL
thisSuccess
allSuccess
;
int
x
;
prefSynchronize
(
)
;
if
(
prefIntRead
(
CALIBRATED_NAME
&
thisSuccess
)
&
&
thisSuccess
)
{
allSuccess
=
YES
;
for
(
x
=
0
;
x
<
3
;
x
+
+
)
{
zeros
[
x
]
=
prefFloatRead
(
ZERO_NAME
(
x
)
&
thisSuccess
)
;
allSuccess
&
=
thisSuccess
;
onegs
[
x
]
=
prefFloatRead
(
ONEG_NAME
(
x
)
&
thisSuccess
)
;
allSuccess
&
=
thisSuccess
;
}
return
allSuccess
;
}
return
NO
;
}
static
void
storeCalibration
(
void
)
{
int
x
;
prefIntWrite
(
CALIBRATED_NAME
1
)
;
for
(
x
=
0
;
x
<
3
;
x
+
+
)
{
prefFloatWrite
(
ZERO_NAME
(
x
)
zeros
[
x
]
)
;
prefFloatWrite
(
ONEG_NAME
(
x
)
onegs
[
x
]
)
;
}
prefSynchronize
(
)
;
}
void
defaultCalibration
(
void
)
{
int
x
;
for
(
x
=
0
;
x
<
3
;
x
+
+
)
{
zeros
[
x
]
=
sensors
[
sensorNum
]
.
axes
[
x
]
.
zerog
;
onegs
[
x
]
=
sensors
[
sensorNum
]
.
axes
[
x
]
.
oneg
;
}
}
static
void
deleteCalibration
(
void
)
{
int
x
;
prefDelete
(
CALIBRATED_NAME
)
;
for
(
x
=
0
;
x
<
3
;
x
+
+
)
{
prefDelete
(
ZERO_NAME
(
x
)
)
;
prefDelete
(
ONEG_NAME
(
x
)
)
;
}
prefSynchronize
(
)
;
}
static
float
prefFloatRead
(
NSString
*
prefName
BOOL
*
success
)
{
float
result
=
0
.
0f
;
CFPropertyListRef
ref
=
CFPreferencesCopyAppValue
(
(
CFStringRef
)
prefName
APP_ID
)
;
if
(
ref
=
=
NULL
)
{
*
success
=
NO
;
return
result
;
}
CFTypeID
typeID
=
CFGetTypeID
(
ref
)
;
if
(
typeID
=
=
CFNumberGetTypeID
(
)
)
{
if
(
CFNumberIsFloatType
(
(
CFNumberRef
)
ref
)
)
{
*
success
=
CFNumberGetValue
(
(
__CFNumber
*
)
ref
kCFNumberFloat32Type
&
result
)
;
}
else
{
long
num
;
if
(
CFNumberGetValue
(
(
CFNumberRef
)
ref
kCFNumberLongType
&
num
)
)
{
result
=
num
;
*
success
=
YES
;
}
else
{
*
success
=
NO
;
}
}
}
else
if
(
typeID
=
=
CFStringGetTypeID
(
)
)
{
result
=
(
float
)
CFStringGetDoubleValue
(
(
CFStringRef
)
ref
)
;
*
success
=
YES
;
}
else
{
*
success
=
NO
;
}
CFRelease
(
ref
)
;
return
result
;
}
static
void
prefFloatWrite
(
NSString
*
prefName
float
prefValue
)
{
CFNumberRef
cfFloat
=
CFNumberCreate
(
kCFAllocatorDefault
kCFNumberFloatType
&
prefValue
)
;
CFPreferencesSetAppValue
(
(
CFStringRef
)
prefName
cfFloat
APP_ID
)
;
CFRelease
(
cfFloat
)
;
}
static
int
prefIntRead
(
NSString
*
prefName
BOOL
*
success
)
{
Boolean
internalSuccess
;
CFIndex
result
=
CFPreferencesGetAppIntegerValue
(
(
CFStringRef
)
prefName
APP_ID
&
internalSuccess
)
;
*
success
=
internalSuccess
;
return
result
;
}
static
void
prefIntWrite
(
NSString
*
prefName
int
prefValue
)
{
CFPreferencesSetAppValue
(
(
CFStringRef
)
prefName
(
CFNumberRef
)
[
NSNumber
numberWithInt
:
prefValue
]
APP_ID
)
;
}
static
void
prefDelete
(
NSString
*
prefName
)
{
CFPreferencesSetAppValue
(
(
CFStringRef
)
prefName
NULL
APP_ID
)
;
}
static
void
prefSynchronize
(
void
)
{
CFPreferencesAppSynchronize
(
APP_ID
)
;
}
int
getData
(
sms_acceleration
*
accel
int
calibrated
id
logObject
SEL
logSelector
)
{
IOItemCount
iSize
=
recordSize
;
IOByteCount
oSize
=
recordSize
;
kern_return_t
result
;
if
(
running
=
=
NO
)
{
return
-
1
;
}
memset
(
iRecord
1
iSize
)
;
memset
(
oRecord
0
oSize
)
;
LOG_2ARG
(
"
Querying
device
(
%
u
%
d
)
:
"
sensors
[
sensorNum
]
.
function
sensors
[
sensorNum
]
.
recordSize
)
;
#
if
__MAC_OS_X_VERSION_MIN_REQUIRED
>
=
1050
const
size_t
InStructSize
=
recordSize
;
size_t
OutStructSize
=
recordSize
;
result
=
IOConnectCallStructMethod
(
connection
function
(
const
void
*
)
iRecord
InStructSize
(
void
*
)
oRecord
&
OutStructSize
)
;
#
else
result
=
IOConnectMethodStructureIStructureO
(
connection
function
iSize
&
oSize
iRecord
oRecord
)
;
#
endif
if
(
result
!
=
KERN_SUCCESS
)
{
LOG
(
"
failed
.
\
n
"
)
;
running
=
NO
;
return
result
;
}
else
{
LOG
(
"
succeeded
.
\
n
"
)
;
accel
-
>
x
=
getAxis
(
0
calibrated
)
;
accel
-
>
y
=
getAxis
(
1
calibrated
)
;
accel
-
>
z
=
getAxis
(
2
calibrated
)
;
return
0
;
}
}
float
getAxis
(
int
which
int
calibrated
)
{
int
indx
=
sensors
[
sensorNum
]
.
axes
[
which
]
.
index
;
int
size
=
sensors
[
sensorNum
]
.
axes
[
which
]
.
size
;
float
zerog
=
zeros
[
which
]
;
float
oneg
=
onegs
[
which
]
;
int
value
=
0
;
#
if
(
BYTE_ORDER
=
=
BIG_ENDIAN
)
memcpy
(
(
(
char
*
)
&
value
)
+
(
sizeof
(
int
)
-
size
)
&
oRecord
[
indx
]
size
)
;
#
endif
#
if
(
BYTE_ORDER
=
=
LITTLE_ENDIAN
)
memcpy
(
&
value
&
oRecord
[
indx
]
size
)
;
#
endif
value
=
signExtend
(
value
size
)
;
if
(
calibrated
)
{
return
(
(
float
)
(
value
-
zerog
)
)
/
oneg
;
}
else
{
return
value
;
}
}
int
signExtend
(
int
value
int
size
)
{
switch
(
size
)
{
case
1
:
if
(
value
&
0x00000080
)
value
|
=
0xffffff00
;
break
;
case
2
:
if
(
value
&
0x00008000
)
value
|
=
0xffff0000
;
break
;
case
3
:
if
(
value
&
0x00800000
)
value
|
=
0xff000000
;
break
;
}
return
value
;
}
NSString
*
getModelName
(
void
)
{
char
model
[
32
]
;
size_t
len
=
sizeof
(
model
)
;
int
name
[
2
]
=
{
CTL_HW
HW_MODEL
}
;
NSString
*
result
;
if
(
sysctl
(
name
2
&
model
&
len
NULL
0
)
=
=
0
)
{
result
=
[
NSString
stringWithFormat
:
"
%
s
"
model
]
;
}
else
{
result
=
"
"
;
}
return
result
;
}
NSString
*
getOSVersion
(
void
)
{
NSDictionary
*
dict
=
[
NSDictionary
dictionaryWithContentsOfFile
:
"
/
System
/
Library
/
CoreServices
/
SystemVersion
.
plist
"
]
;
NSString
*
versionString
=
[
dict
objectForKey
:
"
ProductVersion
"
]
;
NSString
*
buildString
=
[
dict
objectForKey
:
"
ProductBuildVersion
"
]
;
NSString
*
wholeString
=
[
NSString
stringWithFormat
:
"
%
(
build
%
)
"
versionString
buildString
]
;
return
wholeString
;
}
float
fakeData
(
NSTimeInterval
time
)
{
long
secs
=
lround
(
floor
(
time
)
)
;
int
secsMod3
=
secs
%
3
;
double
angle
=
time
*
10
*
M_PI
*
2
;
double
mag
=
exp
(
-
(
time
-
(
secs
-
secsMod3
)
)
*
2
)
;
return
sin
(
angle
)
*
mag
;
}
