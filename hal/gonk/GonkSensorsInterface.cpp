#
include
"
GonkSensorsInterface
.
h
"
#
include
"
GonkSensorsPollInterface
.
h
"
#
include
"
GonkSensorsRegistryInterface
.
h
"
#
include
"
HalLog
.
h
"
#
include
<
mozilla
/
ipc
/
DaemonSocket
.
h
>
#
include
<
mozilla
/
ipc
/
DaemonSocketConnector
.
h
>
#
include
<
mozilla
/
ipc
/
ListenSocket
.
h
>
namespace
mozilla
{
namespace
hal
{
using
namespace
mozilla
:
:
ipc
;
void
GonkSensorsResultHandler
:
:
OnError
(
SensorsError
aError
)
{
HAL_ERR
(
"
Received
error
code
%
d
"
static_cast
<
int
>
(
aError
)
)
;
}
void
GonkSensorsResultHandler
:
:
Connect
(
)
{
}
void
GonkSensorsResultHandler
:
:
Disconnect
(
)
{
}
GonkSensorsResultHandler
:
:
~
GonkSensorsResultHandler
(
)
{
}
void
GonkSensorsNotificationHandler
:
:
BackendErrorNotification
(
bool
aCrashed
)
{
if
(
aCrashed
)
{
HAL_ERR
(
"
Sensors
backend
crashed
"
)
;
}
else
{
HAL_ERR
(
"
Error
in
sensors
backend
"
)
;
}
}
GonkSensorsNotificationHandler
:
:
~
GonkSensorsNotificationHandler
(
)
{
}
class
GonkSensorsProtocol
final
:
public
DaemonSocketIOConsumer
public
GonkSensorsRegistryModule
public
GonkSensorsPollModule
{
public
:
GonkSensorsProtocol
(
)
;
void
SetConnection
(
DaemonSocket
*
aConnection
)
;
already_AddRefed
<
DaemonSocketResultHandler
>
FetchResultHandler
(
const
DaemonSocketPDUHeader
&
aHeader
)
;
nsresult
Send
(
DaemonSocketPDU
*
aPDU
DaemonSocketResultHandler
*
aRes
)
override
;
void
Handle
(
DaemonSocketPDU
&
aPDU
)
override
;
void
StoreResultHandler
(
const
DaemonSocketPDU
&
aPDU
)
override
;
private
:
void
HandleRegistrySvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
void
HandlePollSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
;
DaemonSocket
*
mConnection
;
nsTArray
<
RefPtr
<
DaemonSocketResultHandler
>
>
mResultHandlerQ
;
}
;
GonkSensorsProtocol
:
:
GonkSensorsProtocol
(
)
{
}
void
GonkSensorsProtocol
:
:
SetConnection
(
DaemonSocket
*
aConnection
)
{
mConnection
=
aConnection
;
}
already_AddRefed
<
DaemonSocketResultHandler
>
GonkSensorsProtocol
:
:
FetchResultHandler
(
const
DaemonSocketPDUHeader
&
aHeader
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
aHeader
.
mOpcode
&
0x80
)
{
return
nullptr
;
}
RefPtr
<
DaemonSocketResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
return
res
.
forget
(
)
;
}
void
GonkSensorsProtocol
:
:
HandleRegistrySvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
GonkSensorsRegistryModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
void
GonkSensorsProtocol
:
:
HandlePollSvc
(
const
DaemonSocketPDUHeader
&
aHeader
DaemonSocketPDU
&
aPDU
DaemonSocketResultHandler
*
aRes
)
{
GonkSensorsPollModule
:
:
HandleSvc
(
aHeader
aPDU
aRes
)
;
}
nsresult
GonkSensorsProtocol
:
:
Send
(
DaemonSocketPDU
*
aPDU
DaemonSocketResultHandler
*
aRes
)
{
MOZ_ASSERT
(
mConnection
)
;
MOZ_ASSERT
(
aPDU
)
;
aPDU
-
>
SetConsumer
(
this
)
;
aPDU
-
>
SetResultHandler
(
aRes
)
;
aPDU
-
>
UpdateHeader
(
)
;
if
(
mConnection
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
)
{
HAL_ERR
(
"
Sensors
socket
is
disconnected
"
)
;
return
NS_ERROR_FAILURE
;
}
mConnection
-
>
SendSocketData
(
aPDU
)
;
return
NS_OK
;
}
void
GonkSensorsProtocol
:
:
Handle
(
DaemonSocketPDU
&
aPDU
)
{
static
void
(
GonkSensorsProtocol
:
:
*
const
HandleSvc
[
]
)
(
const
DaemonSocketPDUHeader
&
DaemonSocketPDU
&
DaemonSocketResultHandler
*
)
=
{
[
GonkSensorsRegistryModule
:
:
SERVICE_ID
]
=
&
GonkSensorsProtocol
:
:
HandleRegistrySvc
[
GonkSensorsPollModule
:
:
SERVICE_ID
]
=
&
GonkSensorsProtocol
:
:
HandlePollSvc
}
;
DaemonSocketPDUHeader
header
;
if
(
NS_FAILED
(
UnpackPDU
(
aPDU
header
)
)
)
{
return
;
}
if
(
!
(
header
.
mService
<
MOZ_ARRAY_LENGTH
(
HandleSvc
)
)
|
|
!
HandleSvc
[
header
.
mService
]
)
{
HAL_ERR
(
"
Sensors
service
%
d
unknown
"
header
.
mService
)
;
return
;
}
RefPtr
<
DaemonSocketResultHandler
>
res
=
FetchResultHandler
(
header
)
;
(
this
-
>
*
(
HandleSvc
[
header
.
mService
]
)
)
(
header
aPDU
res
)
;
}
void
GonkSensorsProtocol
:
:
StoreResultHandler
(
const
DaemonSocketPDU
&
aPDU
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mResultHandlerQ
.
AppendElement
(
aPDU
.
GetResultHandler
(
)
)
;
}
GonkSensorsInterface
*
GonkSensorsInterface
:
:
GetInstance
(
)
{
static
GonkSensorsInterface
*
sGonkSensorsInterface
;
if
(
sGonkSensorsInterface
)
{
return
sGonkSensorsInterface
;
}
sGonkSensorsInterface
=
new
GonkSensorsInterface
(
)
;
return
sGonkSensorsInterface
;
}
void
GonkSensorsInterface
:
:
SetNotificationHandler
(
GonkSensorsNotificationHandler
*
aNotificationHandler
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mNotificationHandler
=
aNotificationHandler
;
}
void
GonkSensorsInterface
:
:
Connect
(
GonkSensorsNotificationHandler
*
aNotificationHandler
GonkSensorsResultHandler
*
aRes
)
{
#
define
BASE_SOCKET_NAME
"
sensorsd
"
static
unsigned
long
POSTFIX_LENGTH
=
16
;
mozilla
:
:
hal
:
:
StopSystemService
(
"
sensorsd
"
)
;
mNotificationHandler
=
aNotificationHandler
;
mResultHandlerQ
.
AppendElement
(
aRes
)
;
if
(
!
mProtocol
)
{
mProtocol
=
new
GonkSensorsProtocol
(
)
;
}
if
(
!
mListenSocket
)
{
mListenSocket
=
new
ListenSocket
(
this
LISTEN_SOCKET
)
;
}
if
(
!
mDataSocket
)
{
mDataSocket
=
new
DaemonSocket
(
mProtocol
this
DATA_SOCKET
)
;
}
else
if
(
mDataSocket
-
>
GetConnectionStatus
(
)
=
=
SOCKET_CONNECTED
)
{
mDataSocket
-
>
Close
(
)
;
}
nsresult
rv
=
DaemonSocketConnector
:
:
CreateRandomAddressString
(
NS_LITERAL_CSTRING
(
BASE_SOCKET_NAME
)
POSTFIX_LENGTH
mListenSocketName
)
;
if
(
NS_FAILED
(
rv
)
)
{
mListenSocketName
.
AssignLiteral
(
BASE_SOCKET_NAME
)
;
}
rv
=
mListenSocket
-
>
Listen
(
new
DaemonSocketConnector
(
mListenSocketName
)
mDataSocket
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnConnectError
(
DATA_SOCKET
)
;
return
;
}
mProtocol
-
>
SetConnection
(
mDataSocket
)
;
}
void
GonkSensorsInterface
:
:
Disconnect
(
GonkSensorsResultHandler
*
aRes
)
{
mNotificationHandler
=
nullptr
;
mDataSocket
-
>
Close
(
)
;
mResultHandlerQ
.
AppendElement
(
aRes
)
;
}
GonkSensorsRegistryInterface
*
GonkSensorsInterface
:
:
GetSensorsRegistryInterface
(
)
{
if
(
mRegistryInterface
)
{
return
mRegistryInterface
;
}
mRegistryInterface
=
new
GonkSensorsRegistryInterface
(
mProtocol
)
;
return
mRegistryInterface
;
}
GonkSensorsPollInterface
*
GonkSensorsInterface
:
:
GetSensorsPollInterface
(
)
{
if
(
mPollInterface
)
{
return
mPollInterface
;
}
mPollInterface
=
new
GonkSensorsPollInterface
(
mProtocol
)
;
return
mPollInterface
;
}
GonkSensorsInterface
:
:
GonkSensorsInterface
(
)
:
mNotificationHandler
(
nullptr
)
{
}
GonkSensorsInterface
:
:
~
GonkSensorsInterface
(
)
{
}
void
GonkSensorsInterface
:
:
DispatchError
(
GonkSensorsResultHandler
*
aRes
SensorsError
aError
)
{
DaemonResultRunnable1
<
GonkSensorsResultHandler
void
SensorsError
SensorsError
>
:
:
Dispatch
(
aRes
&
GonkSensorsResultHandler
:
:
OnError
ConstantInitOp1
<
SensorsError
>
(
aError
)
)
;
}
void
GonkSensorsInterface
:
:
DispatchError
(
GonkSensorsResultHandler
*
aRes
nsresult
aRv
)
{
SensorsError
error
;
if
(
NS_FAILED
(
Convert
(
aRv
error
)
)
)
{
error
=
SENSORS_ERROR_FAIL
;
}
DispatchError
(
aRes
error
)
;
}
void
GonkSensorsInterface
:
:
OnConnectSuccess
(
int
aIndex
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
;
switch
(
aIndex
)
{
case
LISTEN_SOCKET
:
{
nsCString
args
(
"
-
a
"
)
;
args
.
Append
(
mListenSocketName
)
;
mozilla
:
:
hal
:
:
StartSystemService
(
"
sensorsd
"
args
.
get
(
)
)
;
}
break
;
case
DATA_SOCKET
:
if
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
{
RefPtr
<
GonkSensorsResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
if
(
res
)
{
res
-
>
Connect
(
)
;
}
}
break
;
}
}
void
GonkSensorsInterface
:
:
OnConnectError
(
int
aIndex
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
;
switch
(
aIndex
)
{
case
DATA_SOCKET
:
mozilla
:
:
hal
:
:
StopSystemService
(
"
sensorsd
"
)
;
mListenSocket
-
>
Close
(
)
;
case
LISTEN_SOCKET
:
if
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
{
RefPtr
<
GonkSensorsResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
if
(
res
)
{
DispatchError
(
res
SENSORS_ERROR_FAIL
)
;
}
}
break
;
}
}
void
GonkSensorsInterface
:
:
OnDisconnect
(
int
aIndex
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
aIndex
)
{
case
DATA_SOCKET
:
mListenSocket
-
>
Close
(
)
;
break
;
case
LISTEN_SOCKET
:
if
(
!
mResultHandlerQ
.
IsEmpty
(
)
)
{
RefPtr
<
GonkSensorsResultHandler
>
res
=
mResultHandlerQ
.
ElementAt
(
0
)
;
mResultHandlerQ
.
RemoveElementAt
(
0
)
;
if
(
res
)
{
res
-
>
Disconnect
(
)
;
}
}
break
;
}
if
(
mNotificationHandler
&
&
mResultHandlerQ
.
IsEmpty
(
)
)
{
if
(
mListenSocket
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
&
&
mDataSocket
-
>
GetConnectionStatus
(
)
=
=
SOCKET_DISCONNECTED
)
{
mNotificationHandler
-
>
BackendErrorNotification
(
true
)
;
mNotificationHandler
=
nullptr
;
}
}
}
}
}
