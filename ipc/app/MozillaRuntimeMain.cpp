#
include
"
.
.
/
contentproc
/
plugin
-
container
.
cpp
"
#
include
"
mozilla
/
Bootstrap
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
WindowsDllBlocklist
.
h
"
#
include
"
mozilla
/
GeckoArgs
.
h
"
#
endif
using
namespace
mozilla
;
static
bool
UseForkServer
(
int
argc
char
*
argv
[
]
)
{
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
return
strcmp
(
argv
[
argc
-
1
]
"
forkserver
"
)
=
=
0
;
#
else
return
false
;
#
endif
}
static
int
RunForkServer
(
Bootstrap
:
:
UniquePtr
&
&
bootstrap
int
argc
char
*
argv
[
]
)
{
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
int
ret
=
0
;
bootstrap
-
>
NS_LogInit
(
)
;
if
(
bootstrap
-
>
XRE_ForkServer
(
&
argc
&
argv
)
)
{
}
else
{
ret
=
content_process_main
(
bootstrap
.
get
(
)
argc
argv
)
;
}
bootstrap
-
>
NS_LogTerm
(
)
;
return
ret
;
#
else
return
0
;
#
endif
}
int
main
(
int
argc
char
*
argv
[
]
)
{
auto
bootstrapResult
=
GetBootstrap
(
)
;
if
(
bootstrapResult
.
isErr
(
)
)
{
return
2
;
}
Bootstrap
:
:
UniquePtr
bootstrap
=
bootstrapResult
.
unwrap
(
)
;
int
ret
;
if
(
UseForkServer
(
argc
argv
)
)
{
ret
=
RunForkServer
(
std
:
:
move
(
bootstrap
)
argc
argv
)
;
}
else
{
SetGeckoProcessType
(
argv
[
argc
-
1
]
)
;
#
ifdef
HAS_DLL_BLOCKLIST
uint32_t
initFlags
=
eDllBlocklistInitFlagIsChildProcess
;
#
if
defined
(
MOZ_SANDBOX
)
Maybe
<
uint64_t
>
sandboxingKind
=
geckoargs
:
:
sSandboxingKind
.
Get
(
argc
argv
CheckArgFlag
:
:
None
)
;
if
(
sandboxingKind
.
isSome
(
)
)
{
initFlags
|
=
eDllBlocklistInitFlagIsUtilityProcess
;
}
#
endif
DllBlocklist_Initialize
(
initFlags
)
;
#
endif
ret
=
content_process_main
(
bootstrap
.
get
(
)
argc
argv
)
;
#
if
defined
(
DEBUG
)
&
&
defined
(
HAS_DLL_BLOCKLIST
)
DllBlocklist_Shutdown
(
)
;
#
endif
}
return
ret
;
}
