#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryCursor
.
h
"
#
ifdef
XP_LINUX
#
include
<
errno
.
h
>
#
include
<
linux
/
magic
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
statfs
.
h
>
#
include
<
sys
/
utsname
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
namespace
mozilla
{
TEST
(
IPCSharedMemory
FreezeAndMapRW
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shm
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
1
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
ASSERT_TRUE
(
shm
-
>
Freeze
(
)
)
;
ASSERT_FALSE
(
shm
-
>
Memory
(
)
)
;
auto
handle
=
shm
-
>
TakeHandleAndUnmap
(
)
;
ASSERT_TRUE
(
shm
-
>
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shm
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shm
-
>
SetHandle
(
std
:
:
move
(
handle
)
ipc
:
:
SharedMemory
:
:
OpenRights
:
:
RightsReadWrite
)
)
;
ASSERT_TRUE
(
shm
-
>
IsValid
(
)
)
;
EXPECT_FALSE
(
shm
-
>
Map
(
1
)
)
;
}
TEST
(
IPCSharedMemory
FreezeAndReprotect
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shm
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
1
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
ASSERT_TRUE
(
shm
-
>
Freeze
(
)
)
;
ASSERT_FALSE
(
shm
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
1
)
)
;
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
ASSERT_EQ
(
*
mem
'
A
'
)
;
EXPECT_FALSE
(
ipc
:
:
SharedMemory
:
:
SystemProtectFallible
(
mem
1
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
)
;
}
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
XP_DARWIN
)
TEST
(
IPCSharedMemory
Reprotect
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shm
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
1
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
auto
handle
=
shm
-
>
TakeHandleAndUnmap
(
)
;
ASSERT_TRUE
(
shm
-
>
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shm
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shm
-
>
SetHandle
(
std
:
:
move
(
handle
)
ipc
:
:
SharedMemory
:
:
OpenRights
:
:
RightsReadOnly
)
)
;
ASSERT_TRUE
(
shm
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
1
)
)
;
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
ASSERT_EQ
(
*
mem
'
A
'
)
;
EXPECT_TRUE
(
ipc
:
:
SharedMemory
:
:
SystemProtectFallible
(
mem
1
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
)
;
}
#
endif
#
ifdef
XP_WIN
TEST
(
IPCSharedMemory
WinUnfreeze
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shm
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
1
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
ASSERT_TRUE
(
shm
-
>
Freeze
(
)
)
;
ASSERT_FALSE
(
shm
-
>
Memory
(
)
)
;
auto
handle
=
shm
-
>
TakeHandleAndUnmap
(
)
;
ASSERT_TRUE
(
shm
-
>
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shm
-
>
IsValid
(
)
)
;
HANDLE
newHandle
=
INVALID_HANDLE_VALUE
;
bool
unfroze
=
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
handle
.
release
(
)
GetCurrentProcess
(
)
&
newHandle
FILE_MAP_ALL_ACCESS
false
DUPLICATE_CLOSE_SOURCE
)
;
ASSERT_FALSE
(
unfroze
)
;
}
#
endif
TEST
(
IPCSharedMemory
ROCopyAndWrite
)
{
auto
shmRW
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
auto
shmRO
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shmRW
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
-
>
Map
(
1
)
)
;
auto
*
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
ASSERT_TRUE
(
shmRW
-
>
ReadOnlyCopy
(
shmRO
)
)
;
EXPECT_FALSE
(
shmRW
-
>
IsValid
(
)
)
;
ASSERT_EQ
(
shmRW
-
>
Memory
(
)
memRW
)
;
ASSERT_EQ
(
shmRO
-
>
MaxSize
(
)
size_t
(
1
)
)
;
ASSERT_TRUE
(
shmRO
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
-
>
Map
(
1
)
)
;
const
auto
*
memRO
=
reinterpret_cast
<
const
char
*
>
(
shmRO
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
memRO
)
;
ASSERT_NE
(
memRW
memRO
)
;
*
memRW
=
'
A
'
;
EXPECT_EQ
(
*
memRO
'
A
'
)
;
}
TEST
(
IPCSharedMemory
ROCopyAndRewrite
)
{
auto
shmRW
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
auto
shmRO
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shmRW
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
-
>
Map
(
1
)
)
;
auto
*
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
*
memRW
=
'
A
'
;
ASSERT_TRUE
(
shmRW
-
>
ReadOnlyCopy
(
shmRO
)
)
;
EXPECT_FALSE
(
shmRW
-
>
IsValid
(
)
)
;
ASSERT_EQ
(
shmRW
-
>
Memory
(
)
memRW
)
;
ASSERT_EQ
(
shmRO
-
>
MaxSize
(
)
size_t
(
1
)
)
;
ASSERT_TRUE
(
shmRO
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
-
>
Map
(
1
)
)
;
const
auto
*
memRO
=
reinterpret_cast
<
const
char
*
>
(
shmRO
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
memRO
)
;
ASSERT_NE
(
memRW
memRO
)
;
ASSERT_EQ
(
*
memRW
'
A
'
)
;
EXPECT_EQ
(
*
memRO
'
A
'
)
;
*
memRW
=
'
X
'
;
EXPECT_EQ
(
*
memRO
'
X
'
)
;
}
TEST
(
IPCSharedMemory
ROCopyAndMapRW
)
{
auto
shmRW
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
auto
shmRO
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shmRW
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
-
>
Map
(
1
)
)
;
auto
*
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
*
memRW
=
'
A
'
;
ASSERT_TRUE
(
shmRW
-
>
ReadOnlyCopy
(
shmRO
)
)
;
ASSERT_TRUE
(
shmRO
-
>
IsValid
(
)
)
;
auto
handle
=
shmRO
-
>
TakeHandleAndUnmap
(
)
;
ASSERT_TRUE
(
shmRO
-
>
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shmRO
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
-
>
SetHandle
(
std
:
:
move
(
handle
)
ipc
:
:
SharedMemory
:
:
OpenRights
:
:
RightsReadWrite
)
)
;
ASSERT_TRUE
(
shmRO
-
>
IsValid
(
)
)
;
EXPECT_FALSE
(
shmRO
-
>
Map
(
1
)
)
;
}
TEST
(
IPCSharedMemory
ROCopyAndReprotect
)
{
auto
shmRW
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
auto
shmRO
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shmRW
-
>
CreateFreezable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
-
>
Map
(
1
)
)
;
auto
*
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
-
>
Memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
*
memRW
=
'
A
'
;
ASSERT_TRUE
(
shmRW
-
>
ReadOnlyCopy
(
shmRO
)
)
;
ASSERT_TRUE
(
shmRO
-
>
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
-
>
Map
(
1
)
)
;
auto
*
memRO
=
reinterpret_cast
<
char
*
>
(
shmRO
-
>
Memory
(
)
)
;
ASSERT_EQ
(
*
memRO
'
A
'
)
;
EXPECT_FALSE
(
ipc
:
:
SharedMemory
:
:
SystemProtectFallible
(
memRO
1
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
)
;
}
#
ifndef
FUZZING
TEST
(
IPCSharedMemory
BasicIsZero
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
static
constexpr
size_t
kSize
=
65536
;
ASSERT_TRUE
(
shm
-
>
Create
(
kSize
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
kSize
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
Memory
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kSize
;
+
+
i
)
{
ASSERT_EQ
(
mem
[
i
]
0
)
<
<
"
offset
"
<
<
i
;
}
}
#
endif
#
if
defined
(
XP_LINUX
)
&
&
!
defined
(
ANDROID
)
class
IPCSharedMemoryLinuxTest
:
public
:
:
testing
:
:
Test
{
int
mMajor
=
0
;
int
mMinor
=
0
;
protected
:
void
SetUp
(
)
override
{
if
(
mMajor
!
=
0
)
{
return
;
}
struct
utsname
uts
;
ASSERT_EQ
(
uname
(
&
uts
)
0
)
<
<
strerror
(
errno
)
;
ASSERT_STREQ
(
uts
.
sysname
"
Linux
"
)
;
ASSERT_EQ
(
sscanf
(
uts
.
release
"
%
d
.
%
d
"
&
mMajor
&
mMinor
)
2
)
;
}
bool
HaveKernelVersion
(
int
aMajor
int
aMinor
)
{
return
mMajor
>
aMajor
|
|
(
mMajor
=
=
aMajor
&
&
mMinor
>
=
aMinor
)
;
}
bool
ShouldHaveMemfd
(
)
{
return
HaveKernelVersion
(
3
17
)
;
}
bool
ShouldHaveMemfdNoExec
(
)
{
return
HaveKernelVersion
(
6
3
)
;
}
}
;
TEST_F
(
IPCSharedMemoryLinuxTest
IsMemfd
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shm
-
>
Create
(
1
)
)
;
UniqueFileHandle
fd
=
shm
-
>
TakeHandleAndUnmap
(
)
;
ASSERT_TRUE
(
fd
)
;
struct
statfs
fs
;
ASSERT_EQ
(
fstatfs
(
fd
.
get
(
)
&
fs
)
0
)
<
<
strerror
(
errno
)
;
EXPECT_EQ
(
fs
.
f_type
TMPFS_MAGIC
)
;
static
constexpr
decltype
(
fs
.
f_blocks
)
kNoLimit
=
0
;
if
(
ShouldHaveMemfd
(
)
)
{
EXPECT_EQ
(
fs
.
f_blocks
kNoLimit
)
;
}
else
{
EXPECT_NE
(
fs
.
f_blocks
kNoLimit
)
;
}
}
TEST_F
(
IPCSharedMemoryLinuxTest
MemfdNoExec
)
{
const
bool
expectExec
=
ShouldHaveMemfd
(
)
&
&
!
ShouldHaveMemfdNoExec
(
)
;
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemory
>
(
)
;
ASSERT_TRUE
(
shm
-
>
Create
(
1
)
)
;
UniqueFileHandle
fd
=
shm
-
>
TakeHandleAndUnmap
(
)
;
ASSERT_TRUE
(
fd
)
;
struct
stat
sb
;
ASSERT_EQ
(
fstat
(
fd
.
get
(
)
&
sb
)
0
)
<
<
strerror
(
errno
)
;
EXPECT_EQ
(
sb
.
st_mode
&
(
S_IRUSR
|
S_IWUSR
)
mode_t
(
S_IRUSR
|
S_IWUSR
)
)
;
EXPECT_EQ
(
sb
.
st_mode
&
S_IXUSR
mode_t
(
expectExec
?
S_IXUSR
:
0
)
)
;
}
#
endif
TEST
(
IPCSharedMemory
CursorWriteRead
)
{
const
size_t
chunkSize
=
ipc
:
:
shared_memory
:
:
SystemAllocationGranularity
(
)
;
ASSERT_TRUE
(
IsPowerOfTwo
(
chunkSize
)
)
;
const
uint64_t
fullSize
=
chunkSize
*
20
;
auto
handle
=
ipc
:
:
shared_memory
:
:
Create
(
fullSize
)
;
ASSERT_TRUE
(
handle
.
IsValid
(
)
)
;
ASSERT_EQ
(
handle
.
Size
(
)
fullSize
)
;
auto
mapping
=
handle
.
Map
(
)
;
ASSERT_TRUE
(
mapping
.
IsValid
(
)
)
;
ASSERT_EQ
(
mapping
.
Size
(
)
fullSize
)
;
ipc
:
:
shared_memory
:
:
Cursor
cursor
(
std
:
:
move
(
handle
)
)
;
ASSERT_EQ
(
cursor
.
Offset
(
)
0u
)
;
ASSERT_EQ
(
cursor
.
Size
(
)
fullSize
)
;
cursor
.
SetChunkSize
(
chunkSize
)
;
const
char
data
[
]
=
"
Hello
World
!
"
;
const
char
data2
[
]
=
"
AnotherString
"
;
auto
writeReadTest
=
[
&
]
(
)
{
uint64_t
initialOffset
=
cursor
.
Offset
(
)
;
memset
(
mapping
.
Data
(
)
0xe5
mapping
.
Size
(
)
)
;
ASSERT_TRUE
(
cursor
.
Write
(
data
std
:
:
size
(
data
)
)
)
;
ASSERT_EQ
(
cursor
.
Offset
(
)
initialOffset
+
std
:
:
size
(
data
)
)
;
ASSERT_STREQ
(
static_cast
<
char
*
>
(
mapping
.
Data
(
)
)
+
initialOffset
data
)
;
memcpy
(
static_cast
<
char
*
>
(
mapping
.
Data
(
)
)
+
initialOffset
data2
std
:
:
size
(
data2
)
)
;
cursor
.
Seek
(
initialOffset
)
;
ASSERT_EQ
(
cursor
.
Offset
(
)
initialOffset
)
;
char
buffer
[
std
:
:
size
(
data2
)
]
;
ASSERT_TRUE
(
cursor
.
Read
(
buffer
std
:
:
size
(
buffer
)
)
)
;
ASSERT_EQ
(
cursor
.
Offset
(
)
initialOffset
+
std
:
:
size
(
buffer
)
)
;
ASSERT_STREQ
(
buffer
data2
)
;
}
;
writeReadTest
(
)
;
for
(
size_t
offset
=
chunkSize
-
3
;
offset
<
fullSize
-
3
;
offset
+
=
chunkSize
/
2
)
{
cursor
.
Seek
(
offset
)
;
writeReadTest
(
)
;
}
cursor
.
Seek
(
mapping
.
Size
(
)
-
std
:
:
max
(
std
:
:
size
(
data
)
std
:
:
size
(
data2
)
)
)
;
writeReadTest
(
)
;
cursor
.
Seek
(
mapping
.
Size
(
)
-
3
)
;
ASSERT_FALSE
(
cursor
.
Write
(
data
std
:
:
size
(
data
)
)
)
;
}
}
