#
include
"
gtest
/
gtest
.
h
"
#
include
"
base
/
shared_memory
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
endif
namespace
mozilla
{
TEST
(
IPCSharedMemory
FreezeAndMapRW
)
{
base
:
:
SharedMemory
shm
;
ASSERT_TRUE
(
shm
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
1
)
)
;
auto
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
ASSERT_TRUE
(
shm
.
Freeze
(
)
)
;
ASSERT_FALSE
(
shm
.
memory
(
)
)
;
auto
handle
=
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
ASSERT_TRUE
(
shm
.
GiveToProcess
(
base
:
:
GetCurrentProcId
(
)
&
handle
)
)
;
ASSERT_TRUE
(
shm
.
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shm
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shm
.
SetHandle
(
handle
false
)
)
;
ASSERT_TRUE
(
shm
.
IsValid
(
)
)
;
EXPECT_FALSE
(
shm
.
Map
(
1
)
)
;
}
TEST
(
IPCSharedMemory
FreezeAndReprotect
)
{
base
:
:
SharedMemory
shm
;
ASSERT_TRUE
(
shm
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
1
)
)
;
auto
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
ASSERT_TRUE
(
shm
.
Freeze
(
)
)
;
ASSERT_FALSE
(
shm
.
memory
(
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
1
)
)
;
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
ASSERT_EQ
(
*
mem
'
A
'
)
;
EXPECT_FALSE
(
ipc
:
:
SharedMemory
:
:
SystemProtectFallible
(
mem
1
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
)
;
}
#
ifndef
XP_WIN
TEST
(
IPCSharedMemory
Reprotect
)
{
base
:
:
SharedMemory
shm
;
ASSERT_TRUE
(
shm
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
1
)
)
;
auto
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
auto
handle
=
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
ASSERT_TRUE
(
shm
.
GiveToProcess
(
base
:
:
GetCurrentProcId
(
)
&
handle
)
)
;
ASSERT_TRUE
(
shm
.
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shm
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shm
.
SetHandle
(
handle
true
)
)
;
ASSERT_TRUE
(
shm
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
1
)
)
;
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
ASSERT_EQ
(
*
mem
'
A
'
)
;
EXPECT_TRUE
(
ipc
:
:
SharedMemory
:
:
SystemProtectFallible
(
mem
1
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
)
;
}
#
endif
#
ifdef
XP_WIN
TEST
(
IPCSharedMemory
WinUnfreeze
)
{
base
:
:
SharedMemory
shm
;
ASSERT_TRUE
(
shm
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
1
)
)
;
auto
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
ASSERT_TRUE
(
mem
)
;
*
mem
=
'
A
'
;
ASSERT_TRUE
(
shm
.
Freeze
(
)
)
;
ASSERT_FALSE
(
shm
.
memory
(
)
)
;
auto
handle
=
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
ASSERT_TRUE
(
shm
.
GiveToProcess
(
base
:
:
GetCurrentProcId
(
)
&
handle
)
)
;
ASSERT_TRUE
(
shm
.
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shm
.
IsValid
(
)
)
;
bool
unfroze
=
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
handle
GetCurrentProcess
(
)
&
handle
FILE_MAP_ALL_ACCESS
false
DUPLICATE_CLOSE_SOURCE
)
;
ASSERT_FALSE
(
unfroze
)
;
}
#
endif
TEST
(
IPCSharedMemory
ROCopyAndWrite
)
{
base
:
:
SharedMemory
shmRW
shmRO
;
ASSERT_TRUE
(
shmRW
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
.
Map
(
1
)
)
;
auto
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
.
memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
ASSERT_TRUE
(
shmRW
.
ReadOnlyCopy
(
&
shmRO
)
)
;
EXPECT_FALSE
(
shmRW
.
IsValid
(
)
)
;
ASSERT_EQ
(
shmRW
.
memory
(
)
memRW
)
;
ASSERT_EQ
(
shmRO
.
max_size
(
)
size_t
(
1
)
)
;
ASSERT_TRUE
(
shmRO
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
.
Map
(
1
)
)
;
auto
memRO
=
reinterpret_cast
<
const
char
*
>
(
shmRO
.
memory
(
)
)
;
ASSERT_TRUE
(
memRO
)
;
ASSERT_NE
(
memRW
memRO
)
;
*
memRW
=
'
A
'
;
EXPECT_EQ
(
*
memRO
'
A
'
)
;
}
TEST
(
IPCSharedMemory
ROCopyAndRewrite
)
{
base
:
:
SharedMemory
shmRW
shmRO
;
ASSERT_TRUE
(
shmRW
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
.
Map
(
1
)
)
;
auto
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
.
memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
*
memRW
=
'
A
'
;
ASSERT_TRUE
(
shmRW
.
ReadOnlyCopy
(
&
shmRO
)
)
;
EXPECT_FALSE
(
shmRW
.
IsValid
(
)
)
;
ASSERT_EQ
(
shmRW
.
memory
(
)
memRW
)
;
ASSERT_EQ
(
shmRO
.
max_size
(
)
size_t
(
1
)
)
;
ASSERT_TRUE
(
shmRO
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
.
Map
(
1
)
)
;
auto
memRO
=
reinterpret_cast
<
const
char
*
>
(
shmRO
.
memory
(
)
)
;
ASSERT_TRUE
(
memRO
)
;
ASSERT_NE
(
memRW
memRO
)
;
ASSERT_EQ
(
*
memRW
'
A
'
)
;
EXPECT_EQ
(
*
memRO
'
A
'
)
;
*
memRW
=
'
X
'
;
EXPECT_EQ
(
*
memRO
'
X
'
)
;
}
TEST
(
IPCSharedMemory
ROCopyAndMapRW
)
{
base
:
:
SharedMemory
shmRW
shmRO
;
ASSERT_TRUE
(
shmRW
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
.
Map
(
1
)
)
;
auto
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
.
memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
*
memRW
=
'
A
'
;
ASSERT_TRUE
(
shmRW
.
ReadOnlyCopy
(
&
shmRO
)
)
;
ASSERT_TRUE
(
shmRO
.
IsValid
(
)
)
;
auto
handle
=
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
ASSERT_TRUE
(
shmRO
.
GiveToProcess
(
base
:
:
GetCurrentProcId
(
)
&
handle
)
)
;
ASSERT_TRUE
(
shmRO
.
IsHandleValid
(
handle
)
)
;
ASSERT_FALSE
(
shmRO
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
.
SetHandle
(
handle
false
)
)
;
ASSERT_TRUE
(
shmRO
.
IsValid
(
)
)
;
EXPECT_FALSE
(
shmRO
.
Map
(
1
)
)
;
}
TEST
(
IPCSharedMemory
ROCopyAndReprotect
)
{
base
:
:
SharedMemory
shmRW
shmRO
;
ASSERT_TRUE
(
shmRW
.
CreateFreezeable
(
1
)
)
;
ASSERT_TRUE
(
shmRW
.
Map
(
1
)
)
;
auto
memRW
=
reinterpret_cast
<
char
*
>
(
shmRW
.
memory
(
)
)
;
ASSERT_TRUE
(
memRW
)
;
*
memRW
=
'
A
'
;
ASSERT_TRUE
(
shmRW
.
ReadOnlyCopy
(
&
shmRO
)
)
;
ASSERT_TRUE
(
shmRO
.
IsValid
(
)
)
;
ASSERT_TRUE
(
shmRO
.
Map
(
1
)
)
;
auto
memRO
=
reinterpret_cast
<
char
*
>
(
shmRO
.
memory
(
)
)
;
ASSERT_EQ
(
*
memRO
'
A
'
)
;
EXPECT_FALSE
(
ipc
:
:
SharedMemory
:
:
SystemProtectFallible
(
memRO
1
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
)
;
}
TEST
(
IPCSharedMemory
IsZero
)
{
base
:
:
SharedMemory
shm
;
static
constexpr
size_t
kSize
=
65536
;
ASSERT_TRUE
(
shm
.
Create
(
kSize
)
)
;
ASSERT_TRUE
(
shm
.
Map
(
kSize
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
.
memory
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kSize
;
+
+
i
)
{
ASSERT_EQ
(
mem
[
i
]
0
)
<
<
"
offset
"
<
<
i
;
}
}
#
ifndef
FUZZING
TEST
(
IPCSharedMemory
BasicIsZero
)
{
auto
shm
=
MakeRefPtr
<
ipc
:
:
SharedMemoryBasic
>
(
)
;
static
constexpr
size_t
kSize
=
65536
;
ASSERT_TRUE
(
shm
-
>
Create
(
kSize
)
)
;
ASSERT_TRUE
(
shm
-
>
Map
(
kSize
)
)
;
auto
*
mem
=
reinterpret_cast
<
char
*
>
(
shm
-
>
memory
(
)
)
;
for
(
size_t
i
=
0
;
i
<
kSize
;
+
+
i
)
{
ASSERT_EQ
(
mem
[
i
]
0
)
<
<
"
offset
"
<
<
i
;
}
}
#
endif
}
