#
ifndef
mozilla_mscom_Ptr_h
#
define
mozilla_mscom_Ptr_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
mscom
/
EnsureMTA
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
{
namespace
mscom
{
namespace
detail
{
template
<
typename
T
>
struct
MainThreadRelease
{
void
operator
(
)
(
T
*
aPtr
)
{
if
(
!
aPtr
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
aPtr
-
>
Release
(
)
;
return
;
}
DebugOnly
<
nsresult
>
rv
=
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
aPtr
&
T
:
:
Release
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
;
template
<
typename
T
>
struct
MTARelease
{
void
operator
(
)
(
T
*
aPtr
)
{
if
(
!
aPtr
)
{
return
;
}
EnsureMTA
(
[
&
]
(
)
-
>
void
{
aPtr
-
>
Release
(
)
;
}
)
;
}
}
;
template
<
typename
T
>
struct
MTAReleaseInChildProcess
{
void
operator
(
)
(
T
*
aPtr
)
{
if
(
!
aPtr
)
{
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aPtr
-
>
Release
(
)
;
return
;
}
EnsureMTA
(
[
&
]
(
)
-
>
void
{
aPtr
-
>
Release
(
)
;
}
)
;
}
}
;
struct
InterceptorTargetDeleter
{
void
operator
(
)
(
IUnknown
*
aPtr
)
{
}
}
;
}
template
<
typename
T
>
using
STAUniquePtr
=
mozilla
:
:
UniquePtr
<
T
detail
:
:
MainThreadRelease
<
T
>
>
;
template
<
typename
T
>
using
MTAUniquePtr
=
mozilla
:
:
UniquePtr
<
T
detail
:
:
MTARelease
<
T
>
>
;
template
<
typename
T
>
using
ProxyUniquePtr
=
mozilla
:
:
UniquePtr
<
T
detail
:
:
MTAReleaseInChildProcess
<
T
>
>
;
template
<
typename
T
>
using
InterceptorTargetPtr
=
mozilla
:
:
UniquePtr
<
T
detail
:
:
InterceptorTargetDeleter
>
;
namespace
detail
{
template
<
typename
T
typename
Deleter
>
class
UniquePtrGetterAddRefs
{
public
:
explicit
UniquePtrGetterAddRefs
(
UniquePtr
<
T
Deleter
>
&
aSmartPtr
)
:
mTargetSmartPtr
(
aSmartPtr
)
mPtrStorage
(
nullptr
)
{
}
~
UniquePtrGetterAddRefs
(
)
{
mTargetSmartPtr
.
reset
(
mPtrStorage
)
;
}
operator
void
*
*
(
)
{
return
reinterpret_cast
<
void
*
*
>
(
&
mPtrStorage
)
;
}
operator
T
*
*
(
)
{
return
&
mPtrStorage
;
}
T
*
&
operator
*
(
)
{
return
mPtrStorage
;
}
private
:
UniquePtr
<
T
Deleter
>
&
mTargetSmartPtr
;
T
*
mPtrStorage
;
}
;
}
template
<
typename
T
>
inline
STAUniquePtr
<
T
>
ToSTAUniquePtr
(
RefPtr
<
T
>
&
&
aRefPtr
)
{
return
STAUniquePtr
<
T
>
(
aRefPtr
.
forget
(
)
.
take
(
)
)
;
}
template
<
typename
T
>
inline
STAUniquePtr
<
T
>
ToSTAUniquePtr
(
T
*
aRawPtr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aRawPtr
)
{
aRawPtr
-
>
AddRef
(
)
;
}
return
STAUniquePtr
<
T
>
(
aRawPtr
)
;
}
template
<
typename
T
>
inline
MTAUniquePtr
<
T
>
ToMTAUniquePtr
(
RefPtr
<
T
>
&
&
aRefPtr
)
{
return
MTAUniquePtr
<
T
>
(
aRefPtr
.
forget
(
)
.
take
(
)
)
;
}
template
<
typename
T
>
inline
MTAUniquePtr
<
T
>
ToMTAUniquePtr
(
T
*
aRawPtr
)
{
MOZ_ASSERT
(
IsCurrentThreadMTA
(
)
)
;
if
(
aRawPtr
)
{
aRawPtr
-
>
AddRef
(
)
;
}
return
MTAUniquePtr
<
T
>
(
aRawPtr
)
;
}
template
<
typename
T
>
inline
ProxyUniquePtr
<
T
>
ToProxyUniquePtr
(
RefPtr
<
T
>
&
&
aRefPtr
)
{
return
ProxyUniquePtr
<
T
>
(
aRefPtr
.
forget
(
)
.
take
(
)
)
;
}
template
<
typename
T
>
inline
ProxyUniquePtr
<
T
>
ToProxyUniquePtr
(
T
*
aRawPtr
)
{
MOZ_ASSERT
(
IsProxy
(
aRawPtr
)
)
;
MOZ_ASSERT
(
(
XRE_IsParentProcess
(
)
&
&
NS_IsMainThread
(
)
)
|
|
(
XRE_IsContentProcess
(
)
&
&
IsCurrentThreadMTA
(
)
)
)
;
if
(
aRawPtr
)
{
aRawPtr
-
>
AddRef
(
)
;
}
return
ProxyUniquePtr
<
T
>
(
aRawPtr
)
;
}
template
<
typename
T
typename
Deleter
>
inline
detail
:
:
UniquePtrGetterAddRefs
<
T
Deleter
>
getter_AddRefs
(
UniquePtr
<
T
Deleter
>
&
aSmartPtr
)
{
return
detail
:
:
UniquePtrGetterAddRefs
<
T
Deleter
>
(
aSmartPtr
)
;
}
}
}
namespace
detail
{
template
<
typename
T
>
struct
SmartPointerStorageClass
<
mozilla
:
:
mscom
:
:
STAUniquePtr
<
T
>
>
{
typedef
StoreCopyPassByRRef
<
mozilla
:
:
mscom
:
:
STAUniquePtr
<
T
>
>
Type
;
}
;
template
<
typename
T
>
struct
SmartPointerStorageClass
<
mozilla
:
:
mscom
:
:
MTAUniquePtr
<
T
>
>
{
typedef
StoreCopyPassByRRef
<
mozilla
:
:
mscom
:
:
MTAUniquePtr
<
T
>
>
Type
;
}
;
template
<
typename
T
>
struct
SmartPointerStorageClass
<
mozilla
:
:
mscom
:
:
ProxyUniquePtr
<
T
>
>
{
typedef
StoreCopyPassByRRef
<
mozilla
:
:
mscom
:
:
ProxyUniquePtr
<
T
>
>
Type
;
}
;
template
<
typename
T
>
struct
SmartPointerStorageClass
<
mozilla
:
:
mscom
:
:
InterceptorTargetPtr
<
T
>
>
{
typedef
StoreCopyPassByRRef
<
mozilla
:
:
mscom
:
:
InterceptorTargetPtr
<
T
>
>
Type
;
}
;
}
#
endif
