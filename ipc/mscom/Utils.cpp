#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
mscom
/
Registration
.
h
"
#
include
"
nsTArray
.
h
"
#
endif
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
<
objbase
.
h
>
#
include
<
objidl
.
h
>
namespace
mozilla
{
namespace
mscom
{
bool
IsCurrentThreadMTA
(
)
{
APTTYPE
aptType
;
APTTYPEQUALIFIER
aptTypeQualifier
;
HRESULT
hr
=
CoGetApartmentType
(
&
aptType
&
aptTypeQualifier
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
return
aptType
=
=
APTTYPE_MTA
;
}
bool
IsProxy
(
IUnknown
*
aUnknown
)
{
if
(
!
aUnknown
)
{
return
false
;
}
RefPtr
<
IClientSecurity
>
clientSecurity
;
HRESULT
hr
=
aUnknown
-
>
QueryInterface
(
IID_IClientSecurity
(
void
*
*
)
getter_AddRefs
(
clientSecurity
)
)
;
if
(
SUCCEEDED
(
hr
)
|
|
hr
=
=
RPC_E_WRONG_THREAD
)
{
return
true
;
}
return
false
;
}
#
ifdef
ACCESSIBILITY
static
bool
IsVtableIndexFromParentInterface
(
TYPEATTR
*
aTypeAttr
unsigned
long
aVtableIndex
)
{
MOZ_ASSERT
(
aTypeAttr
)
;
unsigned
int
numExclusiveFuncs
=
aTypeAttr
-
>
cFuncs
;
unsigned
int
numVtblEntries
=
aTypeAttr
-
>
cbSizeVft
/
sizeof
(
void
*
)
;
unsigned
int
firstVtblIndex
=
numVtblEntries
-
numExclusiveFuncs
;
return
aVtableIndex
<
firstVtblIndex
;
}
bool
IsVtableIndexFromParentInterface
(
REFIID
aInterface
unsigned
long
aVtableIndex
)
{
RefPtr
<
ITypeInfo
>
typeInfo
;
if
(
!
RegisteredProxy
:
:
Find
(
aInterface
getter_AddRefs
(
typeInfo
)
)
)
{
return
false
;
}
TYPEATTR
*
typeAttr
=
nullptr
;
HRESULT
hr
=
typeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
bool
result
=
IsVtableIndexFromParentInterface
(
typeAttr
aVtableIndex
)
;
typeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
return
result
;
}
bool
IsInterfaceEqualToOrInheritedFrom
(
REFIID
aInterface
REFIID
aFrom
unsigned
long
aVtableIndexHint
)
{
if
(
aInterface
=
=
aFrom
)
{
return
true
;
}
AutoTArray
<
RefPtr
<
ITypeInfo
>
1
>
typeInfos
;
RefPtr
<
ITypeInfo
>
typeInfo
;
if
(
RegisteredProxy
:
:
Find
(
aInterface
getter_AddRefs
(
typeInfo
)
)
)
{
typeInfos
.
AppendElement
(
Move
(
typeInfo
)
)
;
}
while
(
!
typeInfos
.
IsEmpty
(
)
)
{
RefPtr
<
ITypeInfo
>
curTypeInfo
(
Move
(
typeInfos
.
LastElement
(
)
)
)
;
typeInfos
.
RemoveElementAt
(
typeInfos
.
Length
(
)
-
1
)
;
TYPEATTR
*
typeAttr
=
nullptr
;
HRESULT
hr
=
curTypeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
break
;
}
bool
isFromParentVtable
=
IsVtableIndexFromParentInterface
(
typeAttr
aVtableIndexHint
)
;
WORD
numParentInterfaces
=
typeAttr
-
>
cImplTypes
;
curTypeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
typeAttr
=
nullptr
;
if
(
!
isFromParentVtable
)
{
continue
;
}
for
(
WORD
i
=
0
;
i
<
numParentInterfaces
;
+
+
i
)
{
HREFTYPE
refCookie
;
hr
=
curTypeInfo
-
>
GetRefTypeOfImplType
(
i
&
refCookie
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
RefPtr
<
ITypeInfo
>
nextTypeInfo
;
hr
=
curTypeInfo
-
>
GetRefTypeInfo
(
refCookie
getter_AddRefs
(
nextTypeInfo
)
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
hr
=
nextTypeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
IID
nextIid
=
typeAttr
-
>
guid
;
nextTypeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
typeAttr
=
nullptr
;
if
(
nextIid
=
=
aFrom
)
{
return
true
;
}
typeInfos
.
AppendElement
(
Move
(
nextTypeInfo
)
)
;
}
}
return
false
;
}
#
endif
}
}
