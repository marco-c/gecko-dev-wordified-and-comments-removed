#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
endif
#
if
defined
(
ACCESSIBILITY
)
#
include
"
mozilla
/
mscom
/
Registration
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
nsTArray
.
h
"
#
endif
#
endif
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
mscom
/
COMWrappers
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
mscom
/
Objref
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
objidl
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
winnt
.
h
>
#
include
<
utility
>
#
if
defined
(
_MSC_VER
)
extern
"
C
"
IMAGE_DOS_HEADER
__ImageBase
;
#
endif
namespace
mozilla
{
namespace
mscom
{
bool
IsCOMInitializedOnCurrentThread
(
)
{
APTTYPE
aptType
;
APTTYPEQUALIFIER
aptTypeQualifier
;
HRESULT
hr
=
wrapped
:
:
CoGetApartmentType
(
&
aptType
&
aptTypeQualifier
)
;
return
hr
!
=
CO_E_NOTINITIALIZED
;
}
bool
IsCurrentThreadMTA
(
)
{
APTTYPE
aptType
;
APTTYPEQUALIFIER
aptTypeQualifier
;
HRESULT
hr
=
wrapped
:
:
CoGetApartmentType
(
&
aptType
&
aptTypeQualifier
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
return
aptType
=
=
APTTYPE_MTA
;
}
bool
IsCurrentThreadExplicitMTA
(
)
{
APTTYPE
aptType
;
APTTYPEQUALIFIER
aptTypeQualifier
;
HRESULT
hr
=
wrapped
:
:
CoGetApartmentType
(
&
aptType
&
aptTypeQualifier
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
return
aptType
=
=
APTTYPE_MTA
&
&
aptTypeQualifier
!
=
APTTYPEQUALIFIER_IMPLICIT_MTA
;
}
bool
IsCurrentThreadImplicitMTA
(
)
{
APTTYPE
aptType
;
APTTYPEQUALIFIER
aptTypeQualifier
;
HRESULT
hr
=
wrapped
:
:
CoGetApartmentType
(
&
aptType
&
aptTypeQualifier
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
return
aptType
=
=
APTTYPE_MTA
&
&
aptTypeQualifier
=
=
APTTYPEQUALIFIER_IMPLICIT_MTA
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
bool
IsCurrentThreadNonMainMTA
(
)
{
if
(
NS_IsMainThread
(
)
)
{
return
false
;
}
return
IsCurrentThreadMTA
(
)
;
}
#
endif
bool
IsProxy
(
IUnknown
*
aUnknown
)
{
if
(
!
aUnknown
)
{
return
false
;
}
RefPtr
<
IClientSecurity
>
clientSecurity
;
HRESULT
hr
=
aUnknown
-
>
QueryInterface
(
IID_IClientSecurity
(
void
*
*
)
getter_AddRefs
(
clientSecurity
)
)
;
if
(
SUCCEEDED
(
hr
)
|
|
hr
=
=
RPC_E_WRONG_THREAD
)
{
return
true
;
}
return
false
;
}
bool
IsValidGUID
(
REFGUID
aCheckGuid
)
{
BYTE
variant
=
aCheckGuid
.
Data4
[
0
]
;
if
(
!
(
variant
&
0x80
)
)
{
return
false
;
}
if
(
(
variant
&
0xE0
)
=
=
0xE0
)
{
return
false
;
}
if
(
(
variant
&
0xC0
)
=
=
0xC0
)
{
return
true
;
}
BYTE
version
=
HIBYTE
(
aCheckGuid
.
Data3
)
>
>
4
;
return
version
=
=
1
|
|
version
=
=
4
;
}
uintptr_t
GetContainingModuleHandle
(
)
{
HMODULE
thisModule
=
nullptr
;
#
if
defined
(
_MSC_VER
)
thisModule
=
reinterpret_cast
<
HMODULE
>
(
&
__ImageBase
)
;
#
else
if
(
!
GetModuleHandleEx
(
GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
|
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
reinterpret_cast
<
LPCTSTR
>
(
&
GetContainingModuleHandle
)
&
thisModule
)
)
{
return
0
;
}
#
endif
return
reinterpret_cast
<
uintptr_t
>
(
thisModule
)
;
}
namespace
detail
{
long
BuildRegGuidPath
(
REFGUID
aGuid
const
GuidType
aGuidType
wchar_t
*
aBuf
const
size_t
aBufLen
)
{
constexpr
wchar_t
kClsid
[
]
=
L
"
CLSID
\
\
"
;
constexpr
wchar_t
kAppid
[
]
=
L
"
AppID
\
\
"
;
constexpr
wchar_t
kSubkeyBase
[
]
=
L
"
SOFTWARE
\
\
Classes
\
\
"
;
constexpr
size_t
kSubkeyBaseLen
=
mozilla
:
:
ArrayLength
(
kSubkeyBase
)
-
1
;
constexpr
size_t
kSubkeyLen
=
kSubkeyBaseLen
+
mozilla
:
:
ArrayLength
(
kClsid
)
-
1
;
constexpr
size_t
kGuidLen
=
kGuidRegFormatCharLenInclNul
-
1
;
constexpr
size_t
kExpectedPathLenInclNul
=
kSubkeyLen
+
kGuidLen
+
1
;
if
(
aBufLen
<
kExpectedPathLenInclNul
)
{
return
E_INVALIDARG
;
}
if
(
wcscpy_s
(
aBuf
aBufLen
kSubkeyBase
)
)
{
return
E_INVALIDARG
;
}
const
wchar_t
*
strGuidType
=
aGuidType
=
=
GuidType
:
:
CLSID
?
kClsid
:
kAppid
;
if
(
wcscat_s
(
aBuf
aBufLen
strGuidType
)
)
{
return
E_INVALIDARG
;
}
int
guidConversionResult
=
:
:
StringFromGUID2
(
aGuid
&
aBuf
[
kSubkeyLen
]
aBufLen
-
kSubkeyLen
)
;
if
(
!
guidConversionResult
)
{
return
E_INVALIDARG
;
}
return
S_OK
;
}
}
long
CreateStream
(
const
uint8_t
*
aInitBuf
const
uint32_t
aInitBufSize
IStream
*
*
aOutStream
)
{
if
(
!
aInitBufSize
|
|
!
aOutStream
)
{
return
E_INVALIDARG
;
}
*
aOutStream
=
nullptr
;
HRESULT
hr
;
RefPtr
<
IStream
>
stream
;
if
(
IsWin8OrLater
(
)
)
{
UINT
initSize
=
aInitBuf
?
aInitBufSize
:
0
;
stream
=
already_AddRefed
<
IStream
>
(
:
:
SHCreateMemStream
(
aInitBuf
initSize
)
)
;
if
(
!
stream
)
{
return
E_OUTOFMEMORY
;
}
if
(
!
aInitBuf
)
{
ULARGE_INTEGER
newSize
;
newSize
.
QuadPart
=
aInitBufSize
;
hr
=
stream
-
>
SetSize
(
newSize
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
}
}
else
{
HGLOBAL
hglobal
=
:
:
GlobalAlloc
(
GMEM_MOVEABLE
aInitBufSize
)
;
if
(
!
hglobal
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
hr
=
:
:
CreateStreamOnHGlobal
(
hglobal
TRUE
getter_AddRefs
(
stream
)
)
;
if
(
FAILED
(
hr
)
)
{
:
:
GlobalFree
(
hglobal
)
;
return
hr
;
}
ULARGE_INTEGER
streamSize
;
streamSize
.
QuadPart
=
aInitBufSize
;
hr
=
stream
-
>
SetSize
(
streamSize
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
aInitBuf
)
{
ULONG
bytesWritten
;
hr
=
stream
-
>
Write
(
aInitBuf
aInitBufSize
&
bytesWritten
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
bytesWritten
!
=
aInitBufSize
)
{
return
E_UNEXPECTED
;
}
}
}
LARGE_INTEGER
streamOffset
;
streamOffset
.
QuadPart
=
0LL
;
hr
=
stream
-
>
Seek
(
streamOffset
STREAM_SEEK_SET
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
stream
.
forget
(
aOutStream
)
;
return
S_OK
;
}
long
CopySerializedProxy
(
IStream
*
aInStream
IStream
*
*
aOutStream
)
{
if
(
!
aInStream
|
|
!
aOutStream
)
{
return
E_INVALIDARG
;
}
*
aOutStream
=
nullptr
;
uint32_t
desiredStreamSize
=
GetOBJREFSize
(
WrapNotNull
(
aInStream
)
)
;
if
(
!
desiredStreamSize
)
{
return
E_INVALIDARG
;
}
RefPtr
<
IStream
>
stream
;
HRESULT
hr
=
CreateStream
(
nullptr
desiredStreamSize
getter_AddRefs
(
stream
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
ULARGE_INTEGER
numBytesToCopy
;
numBytesToCopy
.
QuadPart
=
desiredStreamSize
;
hr
=
aInStream
-
>
CopyTo
(
stream
numBytesToCopy
nullptr
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
LARGE_INTEGER
seekTo
;
seekTo
.
QuadPart
=
0LL
;
hr
=
stream
-
>
Seek
(
seekTo
STREAM_SEEK_SET
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
stream
.
forget
(
aOutStream
)
;
return
S_OK
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
void
GUIDToString
(
REFGUID
aGuid
nsAString
&
aOutString
)
{
const
int
kBufLenWithNul
=
39
;
aOutString
.
SetLength
(
kBufLenWithNul
)
;
int
result
=
StringFromGUID2
(
aGuid
char16ptr_t
(
aOutString
.
BeginWriting
(
)
)
kBufLenWithNul
)
;
MOZ_ASSERT
(
result
)
;
if
(
result
)
{
aOutString
.
SetLength
(
result
-
1
)
;
}
}
static
const
IID
IID_ISCMLocalActivator
=
{
0x00000136
0x0000
0x0000
{
0xC0
0x00
0x00
0x00
0x00
0x00
0x00
0x46
}
}
;
static
const
IID
IID_IRundown
=
{
0x00000134
0x0000
0x0000
{
0xC0
0x00
0x00
0x00
0x00
0x00
0x00
0x46
}
}
;
static
const
IID
IID_IRemUnknown
=
{
0x00000131
0x0000
0x0000
{
0xC0
0x00
0x00
0x00
0x00
0x00
0x00
0x46
}
}
;
static
const
IID
IID_IRemUnknown2
=
{
0x00000143
0x0000
0x0000
{
0xC0
0x00
0x00
0x00
0x00
0x00
0x00
0x46
}
}
;
struct
IIDToLiteralMapEntry
{
constexpr
IIDToLiteralMapEntry
(
REFIID
aIid
nsLiteralCString
&
&
aStr
)
:
mIid
(
aIid
)
mStr
(
std
:
:
forward
<
nsLiteralCString
>
(
aStr
)
)
{
}
REFIID
mIid
;
const
nsLiteralCString
mStr
;
}
;
#
define
IID_ENTRY_STRINGIFY
(
iface
)
#
iface
#
#
_ns
#
define
IID_ENTRY
(
iface
)
IID_
#
#
iface
IID_ENTRY_STRINGIFY
(
iface
)
static
constexpr
IIDToLiteralMapEntry
sIidDiagStrs
[
]
=
{
{
IID_ENTRY
(
IUnknown
)
}
{
IID_IRemUnknown
"
cross
-
apartment
IUnknown
"
_ns
}
{
IID_IRundown
"
cross
-
apartment
object
management
"
_ns
}
{
IID_ISCMLocalActivator
"
out
-
of
-
process
object
instantiation
"
_ns
}
{
IID_IRemUnknown2
"
cross
-
apartment
IUnknown
"
_ns
}
}
;
#
undef
IID_ENTRY
#
undef
IID_ENTRY_STRINGIFY
void
DiagnosticNameForIID
(
REFIID
aIid
nsACString
&
aOutString
)
{
for
(
const
auto
&
curEntry
:
sIidDiagStrs
)
{
if
(
curEntry
.
mIid
=
=
aIid
)
{
aOutString
.
Assign
(
curEntry
.
mStr
)
;
return
;
}
}
nsAutoString
strIid
;
GUIDToString
(
aIid
strIid
)
;
aOutString
.
AssignLiteral
(
"
IID
"
)
;
AppendUTF16toUTF8
(
strIid
aOutString
)
;
}
#
else
void
GUIDToString
(
REFGUID
aGuid
wchar_t
(
&
aOutBuf
)
[
kGuidRegFormatCharLenInclNul
]
)
{
DebugOnly
<
int
>
result
=
:
:
StringFromGUID2
(
aGuid
aOutBuf
ArrayLength
(
aOutBuf
)
)
;
MOZ_ASSERT
(
result
)
;
}
#
endif
#
if
defined
(
ACCESSIBILITY
)
static
bool
IsVtableIndexFromParentInterface
(
TYPEATTR
*
aTypeAttr
unsigned
long
aVtableIndex
)
{
MOZ_ASSERT
(
aTypeAttr
)
;
unsigned
int
numExclusiveFuncs
=
aTypeAttr
-
>
cFuncs
;
unsigned
int
numVtblEntries
=
aTypeAttr
-
>
cbSizeVft
/
sizeof
(
void
*
)
;
unsigned
int
firstVtblIndex
=
numVtblEntries
-
numExclusiveFuncs
;
return
aVtableIndex
<
firstVtblIndex
;
}
bool
IsVtableIndexFromParentInterface
(
REFIID
aInterface
unsigned
long
aVtableIndex
)
{
RefPtr
<
ITypeInfo
>
typeInfo
;
if
(
!
RegisteredProxy
:
:
Find
(
aInterface
getter_AddRefs
(
typeInfo
)
)
)
{
return
false
;
}
TYPEATTR
*
typeAttr
=
nullptr
;
HRESULT
hr
=
typeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
bool
result
=
IsVtableIndexFromParentInterface
(
typeAttr
aVtableIndex
)
;
typeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
return
result
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
bool
IsCallerExternalProcess
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
DWORD
callerTid
;
if
(
:
:
CoGetCallerTID
(
&
callerTid
)
!
=
S_FALSE
)
{
return
false
;
}
const
DWORD
parentMainTid
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
GetChromeMainThreadId
(
)
;
return
callerTid
!
=
parentMainTid
;
}
bool
IsInterfaceEqualToOrInheritedFrom
(
REFIID
aInterface
REFIID
aFrom
unsigned
long
aVtableIndexHint
)
{
if
(
aInterface
=
=
aFrom
)
{
return
true
;
}
AutoTArray
<
RefPtr
<
ITypeInfo
>
1
>
typeInfos
;
RefPtr
<
ITypeInfo
>
typeInfo
;
if
(
RegisteredProxy
:
:
Find
(
aInterface
getter_AddRefs
(
typeInfo
)
)
)
{
typeInfos
.
AppendElement
(
std
:
:
move
(
typeInfo
)
)
;
}
while
(
!
typeInfos
.
IsEmpty
(
)
)
{
RefPtr
<
ITypeInfo
>
curTypeInfo
(
typeInfos
.
PopLastElement
(
)
)
;
TYPEATTR
*
typeAttr
=
nullptr
;
HRESULT
hr
=
curTypeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
break
;
}
bool
isFromParentVtable
=
IsVtableIndexFromParentInterface
(
typeAttr
aVtableIndexHint
)
;
WORD
numParentInterfaces
=
typeAttr
-
>
cImplTypes
;
curTypeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
typeAttr
=
nullptr
;
if
(
!
isFromParentVtable
)
{
continue
;
}
for
(
WORD
i
=
0
;
i
<
numParentInterfaces
;
+
+
i
)
{
HREFTYPE
refCookie
;
hr
=
curTypeInfo
-
>
GetRefTypeOfImplType
(
i
&
refCookie
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
RefPtr
<
ITypeInfo
>
nextTypeInfo
;
hr
=
curTypeInfo
-
>
GetRefTypeInfo
(
refCookie
getter_AddRefs
(
nextTypeInfo
)
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
hr
=
nextTypeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
IID
nextIid
=
typeAttr
-
>
guid
;
nextTypeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
typeAttr
=
nullptr
;
if
(
nextIid
=
=
aFrom
)
{
return
true
;
}
typeInfos
.
AppendElement
(
std
:
:
move
(
nextTypeInfo
)
)
;
}
}
return
false
;
}
#
endif
#
endif
#
if
defined
(
MOZILLA_INTERNAL_API
)
bool
IsClassThreadAwareInprocServer
(
REFCLSID
aClsid
)
{
nsAutoString
strClsid
;
GUIDToString
(
aClsid
strClsid
)
;
nsAutoString
inprocServerSubkey
(
u
"
CLSID
\
\
"
_ns
)
;
inprocServerSubkey
.
Append
(
strClsid
)
;
inprocServerSubkey
.
Append
(
u
"
\
\
InprocServer32
"
_ns
)
;
wchar_t
threadingModelBuf
[
ArrayLength
(
L
"
Apartment
"
)
]
=
{
}
;
DWORD
numBytes
=
sizeof
(
threadingModelBuf
)
;
LONG
result
=
:
:
RegGetValueW
(
HKEY_CLASSES_ROOT
inprocServerSubkey
.
get
(
)
L
"
ThreadingModel
"
RRF_RT_REG_SZ
nullptr
threadingModelBuf
&
numBytes
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
false
;
}
DWORD
numChars
=
numBytes
/
sizeof
(
wchar_t
)
;
if
(
numChars
<
=
1
)
{
return
false
;
}
nsDependentString
threadingModel
(
threadingModelBuf
numChars
-
1
)
;
return
threadingModel
.
LowerCaseEqualsLiteral
(
"
both
"
)
|
|
threadingModel
.
LowerCaseEqualsLiteral
(
"
free
"
)
|
|
threadingModel
.
LowerCaseEqualsLiteral
(
"
neutral
"
)
;
}
#
endif
}
}
