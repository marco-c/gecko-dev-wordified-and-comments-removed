#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
endif
#
if
defined
(
ACCESSIBILITY
)
#
include
"
mozilla
/
mscom
/
Registration
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
nsTArray
.
h
"
#
endif
#
endif
#
include
"
mozilla
/
mscom
/
Objref
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
objbase
.
h
>
#
include
<
objidl
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
winnt
.
h
>
#
if
defined
(
_MSC_VER
)
extern
"
C
"
IMAGE_DOS_HEADER
__ImageBase
;
#
endif
namespace
mozilla
{
namespace
mscom
{
bool
IsCurrentThreadMTA
(
)
{
APTTYPE
aptType
;
APTTYPEQUALIFIER
aptTypeQualifier
;
HRESULT
hr
=
CoGetApartmentType
(
&
aptType
&
aptTypeQualifier
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
return
aptType
=
=
APTTYPE_MTA
;
}
bool
IsProxy
(
IUnknown
*
aUnknown
)
{
if
(
!
aUnknown
)
{
return
false
;
}
RefPtr
<
IClientSecurity
>
clientSecurity
;
HRESULT
hr
=
aUnknown
-
>
QueryInterface
(
IID_IClientSecurity
(
void
*
*
)
getter_AddRefs
(
clientSecurity
)
)
;
if
(
SUCCEEDED
(
hr
)
|
|
hr
=
=
RPC_E_WRONG_THREAD
)
{
return
true
;
}
return
false
;
}
bool
IsValidGUID
(
REFGUID
aCheckGuid
)
{
BYTE
variant
=
aCheckGuid
.
Data4
[
0
]
;
if
(
!
(
variant
&
0x80
)
)
{
return
false
;
}
if
(
(
variant
&
0xE0
)
=
=
0xE0
)
{
return
false
;
}
if
(
(
variant
&
0xC0
)
=
=
0xC0
)
{
return
true
;
}
BYTE
version
=
HIBYTE
(
aCheckGuid
.
Data3
)
>
>
4
;
return
version
=
=
1
|
|
version
=
=
4
;
}
uintptr_t
GetContainingModuleHandle
(
)
{
HMODULE
thisModule
=
nullptr
;
#
if
defined
(
_MSC_VER
)
thisModule
=
reinterpret_cast
<
HMODULE
>
(
&
__ImageBase
)
;
#
else
if
(
!
GetModuleHandleEx
(
GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
|
GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT
reinterpret_cast
<
LPCTSTR
>
(
&
GetContainingModuleHandle
)
&
thisModule
)
)
{
return
0
;
}
#
endif
return
reinterpret_cast
<
uintptr_t
>
(
thisModule
)
;
}
uint32_t
CreateStream
(
const
uint8_t
*
aInitBuf
const
uint32_t
aInitBufSize
IStream
*
*
aOutStream
)
{
if
(
!
aInitBufSize
|
|
!
aOutStream
)
{
return
E_INVALIDARG
;
}
*
aOutStream
=
nullptr
;
HRESULT
hr
;
RefPtr
<
IStream
>
stream
;
if
(
IsWin8OrLater
(
)
)
{
UINT
initSize
=
aInitBuf
?
aInitBufSize
:
0
;
stream
=
already_AddRefed
<
IStream
>
(
:
:
SHCreateMemStream
(
aInitBuf
initSize
)
)
;
if
(
!
stream
)
{
return
E_OUTOFMEMORY
;
}
if
(
!
aInitBuf
)
{
ULARGE_INTEGER
newSize
;
newSize
.
QuadPart
=
aInitBufSize
;
hr
=
stream
-
>
SetSize
(
newSize
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
}
}
else
{
HGLOBAL
hglobal
=
:
:
GlobalAlloc
(
GMEM_MOVEABLE
aInitBufSize
)
;
if
(
!
hglobal
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
hr
=
:
:
CreateStreamOnHGlobal
(
hglobal
TRUE
getter_AddRefs
(
stream
)
)
;
if
(
FAILED
(
hr
)
)
{
:
:
GlobalFree
(
hglobal
)
;
return
hr
;
}
ULARGE_INTEGER
streamSize
;
streamSize
.
QuadPart
=
aInitBufSize
;
hr
=
stream
-
>
SetSize
(
streamSize
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
aInitBuf
)
{
ULONG
bytesWritten
;
hr
=
stream
-
>
Write
(
aInitBuf
aInitBufSize
&
bytesWritten
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
bytesWritten
!
=
aInitBufSize
)
{
return
E_UNEXPECTED
;
}
}
}
LARGE_INTEGER
streamOffset
;
streamOffset
.
QuadPart
=
0LL
;
hr
=
stream
-
>
Seek
(
streamOffset
STREAM_SEEK_SET
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
stream
.
forget
(
aOutStream
)
;
return
S_OK
;
}
uint32_t
CopySerializedProxy
(
IStream
*
aInStream
IStream
*
*
aOutStream
)
{
if
(
!
aInStream
|
|
!
aOutStream
)
{
return
E_INVALIDARG
;
}
*
aOutStream
=
nullptr
;
uint32_t
desiredStreamSize
=
GetOBJREFSize
(
WrapNotNull
(
aInStream
)
)
;
if
(
!
desiredStreamSize
)
{
return
E_INVALIDARG
;
}
RefPtr
<
IStream
>
stream
;
HRESULT
hr
=
CreateStream
(
nullptr
desiredStreamSize
getter_AddRefs
(
stream
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
ULARGE_INTEGER
numBytesToCopy
;
numBytesToCopy
.
QuadPart
=
desiredStreamSize
;
hr
=
aInStream
-
>
CopyTo
(
stream
numBytesToCopy
nullptr
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
LARGE_INTEGER
seekTo
;
seekTo
.
QuadPart
=
0LL
;
hr
=
stream
-
>
Seek
(
seekTo
STREAM_SEEK_SET
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
stream
.
forget
(
aOutStream
)
;
return
S_OK
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
void
GUIDToString
(
REFGUID
aGuid
nsAString
&
aOutString
)
{
const
int
kBufLenWithNul
=
39
;
aOutString
.
SetLength
(
kBufLenWithNul
)
;
int
result
=
StringFromGUID2
(
aGuid
char16ptr_t
(
aOutString
.
BeginWriting
(
)
)
kBufLenWithNul
)
;
MOZ_ASSERT
(
result
)
;
if
(
result
)
{
aOutString
.
SetLength
(
result
-
1
)
;
}
}
#
endif
#
if
defined
(
ACCESSIBILITY
)
static
bool
IsVtableIndexFromParentInterface
(
TYPEATTR
*
aTypeAttr
unsigned
long
aVtableIndex
)
{
MOZ_ASSERT
(
aTypeAttr
)
;
unsigned
int
numExclusiveFuncs
=
aTypeAttr
-
>
cFuncs
;
unsigned
int
numVtblEntries
=
aTypeAttr
-
>
cbSizeVft
/
sizeof
(
void
*
)
;
unsigned
int
firstVtblIndex
=
numVtblEntries
-
numExclusiveFuncs
;
return
aVtableIndex
<
firstVtblIndex
;
}
bool
IsVtableIndexFromParentInterface
(
REFIID
aInterface
unsigned
long
aVtableIndex
)
{
RefPtr
<
ITypeInfo
>
typeInfo
;
if
(
!
RegisteredProxy
:
:
Find
(
aInterface
getter_AddRefs
(
typeInfo
)
)
)
{
return
false
;
}
TYPEATTR
*
typeAttr
=
nullptr
;
HRESULT
hr
=
typeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
bool
result
=
IsVtableIndexFromParentInterface
(
typeAttr
aVtableIndex
)
;
typeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
return
result
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
bool
IsCallerExternalProcess
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
DWORD
callerTid
;
if
(
:
:
CoGetCallerTID
(
&
callerTid
)
!
=
S_FALSE
)
{
return
false
;
}
const
DWORD
parentMainTid
=
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
GetChromeMainThreadId
(
)
;
return
callerTid
!
=
parentMainTid
;
}
bool
IsInterfaceEqualToOrInheritedFrom
(
REFIID
aInterface
REFIID
aFrom
unsigned
long
aVtableIndexHint
)
{
if
(
aInterface
=
=
aFrom
)
{
return
true
;
}
AutoTArray
<
RefPtr
<
ITypeInfo
>
1
>
typeInfos
;
RefPtr
<
ITypeInfo
>
typeInfo
;
if
(
RegisteredProxy
:
:
Find
(
aInterface
getter_AddRefs
(
typeInfo
)
)
)
{
typeInfos
.
AppendElement
(
std
:
:
move
(
typeInfo
)
)
;
}
while
(
!
typeInfos
.
IsEmpty
(
)
)
{
RefPtr
<
ITypeInfo
>
curTypeInfo
(
typeInfos
.
PopLastElement
(
)
)
;
TYPEATTR
*
typeAttr
=
nullptr
;
HRESULT
hr
=
curTypeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
break
;
}
bool
isFromParentVtable
=
IsVtableIndexFromParentInterface
(
typeAttr
aVtableIndexHint
)
;
WORD
numParentInterfaces
=
typeAttr
-
>
cImplTypes
;
curTypeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
typeAttr
=
nullptr
;
if
(
!
isFromParentVtable
)
{
continue
;
}
for
(
WORD
i
=
0
;
i
<
numParentInterfaces
;
+
+
i
)
{
HREFTYPE
refCookie
;
hr
=
curTypeInfo
-
>
GetRefTypeOfImplType
(
i
&
refCookie
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
RefPtr
<
ITypeInfo
>
nextTypeInfo
;
hr
=
curTypeInfo
-
>
GetRefTypeInfo
(
refCookie
getter_AddRefs
(
nextTypeInfo
)
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
hr
=
nextTypeInfo
-
>
GetTypeAttr
(
&
typeAttr
)
;
if
(
FAILED
(
hr
)
)
{
continue
;
}
IID
nextIid
=
typeAttr
-
>
guid
;
nextTypeInfo
-
>
ReleaseTypeAttr
(
typeAttr
)
;
typeAttr
=
nullptr
;
if
(
nextIid
=
=
aFrom
)
{
return
true
;
}
typeInfos
.
AppendElement
(
std
:
:
move
(
nextTypeInfo
)
)
;
}
}
return
false
;
}
#
endif
#
endif
}
}
