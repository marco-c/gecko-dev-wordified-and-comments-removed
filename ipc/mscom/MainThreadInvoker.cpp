#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
HangMonitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
private
/
prpriv
.
h
"
#
include
<
winternl
.
h
>
namespace
{
class
SyncRunnable
:
public
mozilla
:
:
Runnable
{
public
:
SyncRunnable
(
HANDLE
aEvent
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
:
mDoneEvent
(
aEvent
)
mRunnable
(
aRunnable
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
mRunnable
)
;
}
NS_IMETHOD
Run
(
)
override
{
mRunnable
-
>
Run
(
)
;
:
:
SetEvent
(
mDoneEvent
)
;
return
NS_OK
;
}
private
:
HANDLE
mDoneEvent
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
}
;
typedef
NTSTATUS
(
NTAPI
*
NtTestAlertPtr
)
(
VOID
)
;
}
namespace
mozilla
{
namespace
mscom
{
HANDLE
MainThreadInvoker
:
:
sMainThread
=
nullptr
;
StaticRefPtr
<
nsIRunnable
>
MainThreadInvoker
:
:
sAlertRunnable
;
bool
MainThreadInvoker
:
:
InitStatics
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
:
:
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
PRThread
*
mainPrThread
=
nullptr
;
rv
=
mainThread
-
>
GetPRThread
(
&
mainPrThread
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
PRUint32
tid
=
:
:
PR_GetThreadID
(
mainPrThread
)
;
sMainThread
=
:
:
OpenThread
(
SYNCHRONIZE
|
THREAD_SET_CONTEXT
FALSE
tid
)
;
if
(
!
sMainThread
)
{
return
false
;
}
NtTestAlertPtr
NtTestAlert
=
reinterpret_cast
<
NtTestAlertPtr
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
"
NtTestAlert
"
)
)
;
sAlertRunnable
=
:
:
NS_NewRunnableFunction
(
[
NtTestAlert
]
(
)
-
>
void
{
NtTestAlert
(
)
;
}
)
.
take
(
)
;
if
(
sAlertRunnable
)
{
ClearOnShutdown
(
&
sAlertRunnable
)
;
}
return
!
!
sAlertRunnable
;
}
MainThreadInvoker
:
:
MainThreadInvoker
(
)
:
mDoneEvent
(
:
:
CreateEvent
(
nullptr
FALSE
FALSE
nullptr
)
)
{
static
const
bool
gotStatics
=
InitStatics
(
)
;
MOZ_ASSERT
(
gotStatics
)
;
}
MainThreadInvoker
:
:
~
MainThreadInvoker
(
)
{
if
(
mDoneEvent
)
{
:
:
CloseHandle
(
mDoneEvent
)
;
}
}
bool
MainThreadInvoker
:
:
WaitForCompletion
(
DWORD
aTimeout
)
{
HANDLE
handles
[
]
=
{
mDoneEvent
sMainThread
}
;
DWORD
waitResult
=
:
:
WaitForMultipleObjects
(
ArrayLength
(
handles
)
handles
FALSE
aTimeout
)
;
return
waitResult
=
=
WAIT_OBJECT_0
;
}
bool
MainThreadInvoker
:
:
Invoke
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
DWORD
aTimeout
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
Move
(
aRunnable
)
)
;
if
(
!
runnable
)
{
return
false
;
}
if
(
NS_IsMainThread
(
)
)
{
runnable
-
>
Run
(
)
;
return
true
;
}
RefPtr
<
SyncRunnable
>
wrappedRunnable
(
new
SyncRunnable
(
mDoneEvent
runnable
.
forget
(
)
)
)
;
wrappedRunnable
-
>
AddRef
(
)
;
if
(
!
:
:
QueueUserAPC
(
&
MainThreadAPC
sMainThread
reinterpret_cast
<
UINT_PTR
>
(
wrappedRunnable
.
get
(
)
)
)
)
{
wrappedRunnable
-
>
Release
(
)
;
return
false
;
}
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
NS_DispatchToMainThread
(
sAlertRunnable
)
)
)
;
return
WaitForCompletion
(
aTimeout
)
;
}
VOID
CALLBACK
MainThreadInvoker
:
:
MainThreadAPC
(
ULONG_PTR
aParam
)
{
GeckoProfilerWakeRAII
wakeProfiler
;
mozilla
:
:
HangMonitor
:
:
NotifyActivity
(
mozilla
:
:
HangMonitor
:
:
kGeneralActivity
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
SyncRunnable
>
runnable
(
already_AddRefed
<
SyncRunnable
>
(
reinterpret_cast
<
SyncRunnable
*
>
(
aParam
)
)
)
;
runnable
-
>
Run
(
)
;
}
}
}
