#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
mscom
/
SpinEvent
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
private
/
prpriv
.
h
"
#
include
<
winternl
.
h
>
namespace
{
typedef
NTSTATUS
(
NTAPI
*
NtTestAlertPtr
)
(
VOID
)
;
class
SyncRunnable
:
public
mozilla
:
:
Runnable
{
public
:
explicit
SyncRunnable
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
:
mozilla
:
:
Runnable
(
"
MainThreadInvoker
"
)
mRunnable
(
aRunnable
)
{
static
const
bool
gotStatics
=
InitStatics
(
)
;
MOZ_ASSERT
(
gotStatics
)
;
Unused
<
<
gotStatics
;
}
~
SyncRunnable
(
)
=
default
;
NS_IMETHOD
Run
(
)
override
{
if
(
mHasRun
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
sNtTestAlert
)
;
sNtTestAlert
(
)
;
return
NS_OK
;
}
void
APCRun
(
)
{
mHasRun
=
true
;
TimeStamp
runStart
(
TimeStamp
:
:
Now
(
)
)
;
mRunnable
-
>
Run
(
)
;
TimeStamp
runEnd
(
TimeStamp
:
:
Now
(
)
)
;
mDuration
=
runEnd
-
runStart
;
mEvent
.
Signal
(
)
;
}
bool
WaitUntilComplete
(
)
{
return
mEvent
.
Wait
(
mozilla
:
:
mscom
:
:
MainThreadInvoker
:
:
GetTargetThread
(
)
)
;
}
const
mozilla
:
:
TimeDuration
&
GetDuration
(
)
const
{
return
mDuration
;
}
private
:
bool
mHasRun
=
false
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
mozilla
:
:
mscom
:
:
SpinEvent
mEvent
;
mozilla
:
:
TimeDuration
mDuration
;
static
NtTestAlertPtr
sNtTestAlert
;
static
bool
InitStatics
(
)
{
sNtTestAlert
=
reinterpret_cast
<
NtTestAlertPtr
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
"
NtTestAlert
"
)
)
;
MOZ_ASSERT
(
sNtTestAlert
)
;
return
sNtTestAlert
;
}
}
;
NtTestAlertPtr
SyncRunnable
:
:
sNtTestAlert
=
nullptr
;
}
namespace
mozilla
{
namespace
mscom
{
HANDLE
MainThreadInvoker
:
:
sMainThread
=
nullptr
;
bool
MainThreadInvoker
:
:
InitStatics
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
:
:
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
PRThread
*
mainPrThread
=
nullptr
;
rv
=
mainThread
-
>
GetPRThread
(
&
mainPrThread
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
PRUint32
tid
=
:
:
PR_GetThreadID
(
mainPrThread
)
;
sMainThread
=
:
:
OpenThread
(
SYNCHRONIZE
|
THREAD_SET_CONTEXT
FALSE
tid
)
;
return
!
!
sMainThread
;
}
MainThreadInvoker
:
:
MainThreadInvoker
(
)
{
static
const
bool
gotStatics
=
InitStatics
(
)
;
MOZ_ASSERT
(
gotStatics
)
;
Unused
<
<
gotStatics
;
}
bool
MainThreadInvoker
:
:
Invoke
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
std
:
:
move
(
aRunnable
)
)
;
if
(
!
runnable
)
{
return
false
;
}
if
(
NS_IsMainThread
(
)
)
{
runnable
-
>
Run
(
)
;
return
true
;
}
RefPtr
<
SyncRunnable
>
syncRunnable
=
new
SyncRunnable
(
runnable
.
forget
(
)
)
;
SyncRunnable
*
syncRunnableRef
=
syncRunnable
.
get
(
)
;
NS_ADDREF
(
syncRunnableRef
)
;
if
(
!
:
:
QueueUserAPC
(
&
MainThreadAPC
sMainThread
reinterpret_cast
<
UINT_PTR
>
(
syncRunnableRef
)
)
)
{
return
false
;
}
if
(
NS_FAILED
(
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
syncRunnable
)
)
)
)
{
return
false
;
}
bool
result
=
syncRunnable
-
>
WaitUntilComplete
(
)
;
mDuration
=
syncRunnable
-
>
GetDuration
(
)
;
return
result
;
}
VOID
CALLBACK
MainThreadInvoker
:
:
MainThreadAPC
(
ULONG_PTR
aParam
)
{
AUTO_PROFILER_THREAD_WAKE
;
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
runnable
=
reinterpret_cast
<
SyncRunnable
*
>
(
aParam
)
;
runnable
-
>
APCRun
(
)
;
NS_RELEASE
(
runnable
)
;
}
}
}
