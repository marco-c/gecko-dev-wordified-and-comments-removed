#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
HangMonitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
private
/
prpriv
.
h
"
#
include
"
WinUtils
.
h
"
#
if
defined
(
_MSC_VER
)
#
include
<
intrin
.
h
>
#
pragma
intrinsic
(
_mm_pause
)
#
define
CPU_PAUSE
(
)
_mm_pause
(
)
#
elif
defined
(
__GNUC__
)
|
|
defined
(
__clang__
)
#
define
CPU_PAUSE
(
)
__builtin_ia32_pause
(
)
#
endif
static
bool
sIsMulticore
;
namespace
{
class
MOZ_RAII
SyncRunnable
{
public
:
explicit
SyncRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
:
mDoneEvent
(
sIsMulticore
?
nullptr
:
:
:
CreateEventW
(
nullptr
FALSE
FALSE
nullptr
)
)
mDone
(
false
)
mRunnable
(
aRunnable
)
{
MOZ_ASSERT
(
sIsMulticore
|
|
mDoneEvent
)
;
MOZ_ASSERT
(
mRunnable
)
;
}
~
SyncRunnable
(
)
{
if
(
mDoneEvent
)
{
:
:
CloseHandle
(
mDoneEvent
)
;
}
}
void
Run
(
)
{
mRunnable
-
>
Run
(
)
;
if
(
mDoneEvent
)
{
:
:
SetEvent
(
mDoneEvent
)
;
}
else
{
mDone
=
true
;
}
}
bool
WaitUntilComplete
(
)
{
if
(
mDoneEvent
)
{
HANDLE
handles
[
]
=
{
mDoneEvent
mozilla
:
:
mscom
:
:
MainThreadInvoker
:
:
GetTargetThread
(
)
}
;
DWORD
waitResult
=
:
:
WaitForMultipleObjects
(
mozilla
:
:
ArrayLength
(
handles
)
handles
FALSE
INFINITE
)
;
return
waitResult
=
=
WAIT_OBJECT_0
;
}
while
(
!
mDone
)
{
CPU_PAUSE
(
)
;
}
return
true
;
}
private
:
HANDLE
mDoneEvent
;
mozilla
:
:
Atomic
<
bool
>
mDone
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
}
;
}
namespace
mozilla
{
namespace
mscom
{
HANDLE
MainThreadInvoker
:
:
sMainThread
=
nullptr
;
bool
MainThreadInvoker
:
:
InitStatics
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
nsresult
rv
=
:
:
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
PRThread
*
mainPrThread
=
nullptr
;
rv
=
mainThread
-
>
GetPRThread
(
&
mainPrThread
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
PRUint32
tid
=
:
:
PR_GetThreadID
(
mainPrThread
)
;
sMainThread
=
:
:
OpenThread
(
SYNCHRONIZE
|
THREAD_SET_CONTEXT
FALSE
tid
)
;
nsCOMPtr
<
nsIPropertyBag2
>
infoService
=
do_GetService
(
NS_SYSTEMINFO_CONTRACTID
)
;
if
(
infoService
)
{
uint32_t
cpuCount
;
nsresult
rv
=
infoService
-
>
GetPropertyAsUint32
(
NS_LITERAL_STRING
(
"
cpucount
"
)
&
cpuCount
)
;
sIsMulticore
=
NS_SUCCEEDED
(
rv
)
&
&
cpuCount
>
1
;
}
return
!
!
sMainThread
;
}
MainThreadInvoker
:
:
MainThreadInvoker
(
)
{
static
const
bool
gotStatics
=
InitStatics
(
)
;
MOZ_ASSERT
(
gotStatics
)
;
}
bool
MainThreadInvoker
:
:
Invoke
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
Move
(
aRunnable
)
)
;
if
(
!
runnable
)
{
return
false
;
}
if
(
NS_IsMainThread
(
)
)
{
runnable
-
>
Run
(
)
;
return
true
;
}
SyncRunnable
syncRunnable
(
runnable
.
forget
(
)
)
;
if
(
!
:
:
QueueUserAPC
(
&
MainThreadAPC
sMainThread
reinterpret_cast
<
UINT_PTR
>
(
&
syncRunnable
)
)
)
{
return
false
;
}
widget
:
:
WinUtils
:
:
SetAPCPending
(
)
;
return
syncRunnable
.
WaitUntilComplete
(
)
;
}
VOID
CALLBACK
MainThreadInvoker
:
:
MainThreadAPC
(
ULONG_PTR
aParam
)
{
GeckoProfilerWakeRAII
wakeProfiler
;
mozilla
:
:
HangMonitor
:
:
NotifyActivity
(
mozilla
:
:
HangMonitor
:
:
kGeneralActivity
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
runnable
=
reinterpret_cast
<
SyncRunnable
*
>
(
aParam
)
;
runnable
-
>
Run
(
)
;
}
}
}
