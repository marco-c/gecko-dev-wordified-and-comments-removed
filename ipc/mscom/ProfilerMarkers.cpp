#
include
"
ProfilerMarkers
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
<
objbase
.
h
>
#
include
<
objidlbase
.
h
>
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
mozilla
/
ProfilerMarkerTypes
.
h
"
#
endif
static
const
GUID
GUID_MozProfilerMarkerExtension
=
{
0x9dbe6b28
0xe5e7
0x4fde
{
0xaf
0x0
0x94
0x4
0x60
0x4e
0x74
0xdc
}
}
;
namespace
{
class
ProfilerMarkerChannelHook
final
:
public
IChannelHook
{
~
ProfilerMarkerChannelHook
(
)
=
default
;
public
:
ProfilerMarkerChannelHook
(
)
:
mRefCnt
(
0
)
{
}
STDMETHODIMP
QueryInterface
(
REFIID
aIid
void
*
*
aOutInterface
)
override
;
STDMETHODIMP_
(
ULONG
)
AddRef
(
)
override
;
STDMETHODIMP_
(
ULONG
)
Release
(
)
override
;
STDMETHODIMP_
(
void
)
ClientGetSize
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
*
aOutDataSize
)
override
;
STDMETHODIMP_
(
void
)
ClientFillBuffer
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
*
aDataSize
void
*
aDataBuf
)
override
{
}
STDMETHODIMP_
(
void
)
ClientNotify
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
aDataSize
void
*
aDataBuffer
DWORD
aDataRep
HRESULT
aFault
)
override
;
STDMETHODIMP_
(
void
)
ServerNotify
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
aDataSize
void
*
aDataBuf
DWORD
aDataRep
)
override
{
}
STDMETHODIMP_
(
void
)
ServerGetSize
(
REFGUID
aExtensionId
REFIID
aIid
HRESULT
aFault
ULONG
*
aOutDataSize
)
override
{
}
STDMETHODIMP_
(
void
)
ServerFillBuffer
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
*
aDataSize
void
*
aDataBuf
HRESULT
aFault
)
override
{
}
private
:
void
BuildMarkerName
(
REFIID
aIid
nsACString
&
aOutMarkerName
)
;
private
:
mozilla
:
:
Atomic
<
ULONG
>
mRefCnt
;
}
;
HRESULT
ProfilerMarkerChannelHook
:
:
QueryInterface
(
REFIID
aIid
void
*
*
aOutInterface
)
{
if
(
aIid
=
=
IID_IChannelHook
|
|
aIid
=
=
IID_IUnknown
)
{
RefPtr
<
IChannelHook
>
ptr
(
this
)
;
ptr
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
return
E_NOINTERFACE
;
}
ULONG
ProfilerMarkerChannelHook
:
:
AddRef
(
)
{
return
+
+
mRefCnt
;
}
ULONG
ProfilerMarkerChannelHook
:
:
Release
(
)
{
ULONG
result
=
-
-
mRefCnt
;
if
(
!
result
)
{
delete
this
;
}
return
result
;
}
void
ProfilerMarkerChannelHook
:
:
BuildMarkerName
(
REFIID
aIid
nsACString
&
aOutMarkerName
)
{
aOutMarkerName
.
AssignLiteral
(
"
ORPC
Call
for
"
)
;
nsAutoCString
iidStr
;
mozilla
:
:
mscom
:
:
DiagnosticNameForIID
(
aIid
iidStr
)
;
aOutMarkerName
.
Append
(
iidStr
)
;
}
void
ProfilerMarkerChannelHook
:
:
ClientGetSize
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
*
aOutDataSize
)
{
if
(
aExtensionId
=
=
GUID_MozProfilerMarkerExtension
)
{
if
(
NS_IsMainThread
(
)
)
{
nsAutoCString
markerName
;
BuildMarkerName
(
aIid
markerName
)
;
PROFILER_MARKER
(
markerName
IPC
mozilla
:
:
MarkerTiming
:
:
IntervalStart
(
)
Tracing
"
MSCOM
"
)
;
}
if
(
aOutDataSize
)
{
*
aOutDataSize
=
0UL
;
}
}
}
void
ProfilerMarkerChannelHook
:
:
ClientNotify
(
REFGUID
aExtensionId
REFIID
aIid
ULONG
aDataSize
void
*
aDataBuffer
DWORD
aDataRep
HRESULT
aFault
)
{
if
(
NS_IsMainThread
(
)
&
&
aExtensionId
=
=
GUID_MozProfilerMarkerExtension
)
{
nsAutoCString
markerName
;
BuildMarkerName
(
aIid
markerName
)
;
PROFILER_MARKER
(
markerName
IPC
mozilla
:
:
MarkerTiming
:
:
IntervalEnd
(
)
Tracing
"
MSCOM
"
)
;
}
}
}
static
void
RegisterChannelHook
(
)
{
RefPtr
<
ProfilerMarkerChannelHook
>
hook
(
new
ProfilerMarkerChannelHook
(
)
)
;
mozilla
:
:
DebugOnly
<
HRESULT
>
hr
=
:
:
CoRegisterChannelHook
(
GUID_MozProfilerMarkerExtension
hook
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
)
;
}
namespace
{
class
ProfilerStartupObserver
final
:
public
nsIObserver
{
~
ProfilerStartupObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
ProfilerStartupObserver
nsIObserver
)
NS_IMETHODIMP
ProfilerStartupObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
"
profiler
-
started
"
)
)
{
return
NS_OK
;
}
RegisterChannelHook
(
)
;
nsCOMPtr
<
nsIObserverService
>
obsServ
(
mozilla
:
:
services
:
:
GetObserverService
(
)
)
;
MOZ_ASSERT
(
!
!
obsServ
)
;
if
(
!
obsServ
)
{
return
NS_OK
;
}
obsServ
-
>
RemoveObserver
(
this
"
profiler
-
started
"
)
;
return
NS_OK
;
}
}
namespace
mozilla
{
namespace
mscom
{
void
InitProfilerMarkers
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
if
(
profiler_is_active
(
)
)
{
RegisterChannelHook
(
)
;
return
;
}
nsCOMPtr
<
nsIObserverService
>
obsServ
(
mozilla
:
:
services
:
:
GetObserverService
(
)
)
;
MOZ_ASSERT
(
!
!
obsServ
)
;
if
(
!
obsServ
)
{
return
;
}
nsCOMPtr
<
nsIObserver
>
obs
(
new
ProfilerStartupObserver
(
)
)
;
obsServ
-
>
AddObserver
(
obs
"
profiler
-
started
"
false
)
;
}
}
}
