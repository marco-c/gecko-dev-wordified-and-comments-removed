#
ifndef
mozilla_mscom_AsyncInvoker_h
#
define
mozilla_mscom_AsyncInvoker_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
mscom
/
Aggregation
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
<
objidl
.
h
>
#
include
<
windows
.
h
>
namespace
mozilla
{
namespace
mscom
{
namespace
detail
{
template
<
typename
AsyncInterface
>
class
ForgettableAsyncCall
:
public
ISynchronize
{
public
:
explicit
ForgettableAsyncCall
(
ICallFactory
*
aCallFactory
)
:
mRefCnt
(
0
)
mAsyncCall
(
nullptr
)
{
StabilizedRefCount
<
Atomic
<
ULONG
>
>
stabilizer
(
mRefCnt
)
;
HRESULT
hr
=
aCallFactory
-
>
CreateCall
(
__uuidof
(
AsyncInterface
)
this
IID_IUnknown
getter_AddRefs
(
mInnerUnk
)
)
;
if
(
FAILED
(
hr
)
)
{
return
;
}
hr
=
mInnerUnk
-
>
QueryInterface
(
__uuidof
(
AsyncInterface
)
reinterpret_cast
<
void
*
*
>
(
&
mAsyncCall
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
mAsyncCall
-
>
Release
(
)
;
}
}
AsyncInterface
*
GetInterface
(
)
const
{
return
mAsyncCall
;
}
STDMETHODIMP
QueryInterface
(
REFIID
aIid
void
*
*
aOutInterface
)
override
{
if
(
aIid
=
=
IID_IUnknown
|
|
aIid
=
=
IID_ISynchronize
)
{
RefPtr
<
ISynchronize
>
ptr
(
this
)
;
ptr
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
return
mInnerUnk
-
>
QueryInterface
(
aIid
aOutInterface
)
;
}
STDMETHODIMP_
(
ULONG
)
AddRef
(
)
override
{
ULONG
result
=
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
result
"
ForgettableAsyncCall
"
sizeof
(
*
this
)
)
;
return
result
;
}
STDMETHODIMP_
(
ULONG
)
Release
(
)
override
{
ULONG
result
=
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
result
"
ForgettableAsyncCall
"
)
;
if
(
!
result
)
{
delete
this
;
}
return
result
;
}
STDMETHODIMP
Wait
(
DWORD
aFlags
DWORD
aTimeoutMilliseconds
)
override
{
return
E_NOTIMPL
;
}
STDMETHODIMP
Signal
(
)
override
{
return
S_OK
;
}
STDMETHODIMP
Reset
(
)
override
{
return
S_OK
;
}
protected
:
virtual
~
ForgettableAsyncCall
(
)
{
}
private
:
Atomic
<
ULONG
>
mRefCnt
;
RefPtr
<
IUnknown
>
mInnerUnk
;
AsyncInterface
*
mAsyncCall
;
}
;
template
<
typename
AsyncInterface
>
class
WaitableAsyncCall
:
public
ForgettableAsyncCall
<
AsyncInterface
>
{
public
:
explicit
WaitableAsyncCall
(
ICallFactory
*
aCallFactory
)
:
ForgettableAsyncCall
(
aCallFactory
)
mEvent
(
:
:
CreateEventW
(
nullptr
FALSE
FALSE
nullptr
)
)
{
}
STDMETHODIMP
Wait
(
DWORD
aFlags
DWORD
aTimeoutMilliseconds
)
override
{
const
DWORD
waitStart
=
aTimeoutMilliseconds
=
=
INFINITE
?
0
:
:
:
GetTickCount
(
)
;
DWORD
flags
=
aFlags
;
if
(
XRE_IsContentProcess
(
)
&
&
NS_IsMainThread
(
)
)
{
flags
|
=
COWAIT_ALERTABLE
;
}
HRESULT
hr
;
DWORD
signaledIdx
;
DWORD
elapsed
=
0
;
while
(
true
)
{
if
(
aTimeoutMilliseconds
!
=
INFINITE
)
{
elapsed
=
:
:
GetTickCount
(
)
-
waitStart
;
}
if
(
elapsed
>
=
aTimeoutMilliseconds
)
{
return
RPC_S_CALLPENDING
;
}
:
:
SetLastError
(
ERROR_SUCCESS
)
;
hr
=
:
:
CoWaitForMultipleHandles
(
flags
aTimeoutMilliseconds
-
elapsed
1
&
mEvent
&
signaledIdx
)
;
if
(
hr
=
=
RPC_S_CALLPENDING
|
|
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
hr
=
=
S_OK
&
&
signaledIdx
=
=
0
)
{
return
hr
;
}
}
}
STDMETHODIMP
Signal
(
)
override
{
if
(
!
:
:
SetEvent
(
mEvent
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
return
S_OK
;
}
protected
:
~
WaitableAsyncCall
(
)
{
if
(
mEvent
)
{
:
:
CloseHandle
(
mEvent
)
;
}
}
private
:
HANDLE
mEvent
;
}
;
template
<
typename
AsyncInterface
>
class
FireAndForgetInvoker
{
protected
:
typedef
ForgettableAsyncCall
<
AsyncInterface
>
AsyncCallType
;
RefPtr
<
ForgettableAsyncCall
<
AsyncInterface
>
>
mAsyncCall
;
}
;
template
<
typename
AsyncInterface
>
class
WaitableInvoker
{
public
:
HRESULT
Wait
(
DWORD
aTimeout
=
INFINITE
)
const
{
if
(
!
mAsyncCall
)
{
return
S_OK
;
}
return
mAsyncCall
-
>
Wait
(
0
aTimeout
)
;
}
protected
:
typedef
WaitableAsyncCall
<
AsyncInterface
>
AsyncCallType
;
RefPtr
<
WaitableAsyncCall
<
AsyncInterface
>
>
mAsyncCall
;
}
;
}
template
<
typename
SyncInterface
typename
AsyncInterface
template
<
typename
Iface
>
class
WaitPolicy
=
detail
:
:
FireAndForgetInvoker
>
class
MOZ_RAII
AsyncInvoker
final
:
public
WaitPolicy
<
AsyncInterface
>
{
public
:
typedef
SyncInterface
SyncInterfaceT
;
typedef
AsyncInterface
AsyncInterfaceT
;
explicit
AsyncInvoker
(
SyncInterface
*
aSyncObj
const
Maybe
<
bool
>
&
aIsProxy
=
Nothing
(
)
)
:
mSyncObj
(
ResolveIsProxy
(
aSyncObj
aIsProxy
)
?
nullptr
:
aSyncObj
)
{
MOZ_ASSERT
(
aSyncObj
)
;
if
(
mSyncObj
)
{
return
;
}
RefPtr
<
ICallFactory
>
callFactory
;
if
(
FAILED
(
aSyncObj
-
>
QueryInterface
(
IID_ICallFactory
getter_AddRefs
(
callFactory
)
)
)
)
{
return
;
}
mAsyncCall
=
new
AsyncCallType
(
callFactory
)
;
}
template
<
typename
SyncMethod
typename
AsyncMethod
typename
.
.
.
Args
>
HRESULT
Invoke
(
SyncMethod
aSyncMethod
AsyncMethod
aAsyncMethod
Args
.
.
.
aArgs
)
{
if
(
mSyncObj
)
{
return
(
mSyncObj
-
>
*
aSyncMethod
)
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
MOZ_ASSERT
(
mAsyncCall
)
;
if
(
!
mAsyncCall
)
{
return
E_POINTER
;
}
AsyncInterface
*
asyncInterface
=
mAsyncCall
-
>
GetInterface
(
)
;
MOZ_ASSERT
(
asyncInterface
)
;
if
(
!
asyncInterface
)
{
return
E_POINTER
;
}
return
(
asyncInterface
-
>
*
aAsyncMethod
)
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
AsyncInvoker
(
const
AsyncInvoker
&
aOther
)
=
delete
;
AsyncInvoker
(
AsyncInvoker
&
&
aOther
)
=
delete
;
AsyncInvoker
&
operator
=
(
const
AsyncInvoker
&
aOther
)
=
delete
;
AsyncInvoker
&
operator
=
(
AsyncInvoker
&
&
aOther
)
=
delete
;
private
:
static
bool
ResolveIsProxy
(
SyncInterface
*
aSyncObj
const
Maybe
<
bool
>
&
aIsProxy
)
{
MOZ_ASSERT
(
aSyncObj
)
;
return
aIsProxy
.
isSome
(
)
?
aIsProxy
.
value
(
)
:
IsProxy
(
aSyncObj
)
;
}
private
:
RefPtr
<
SyncInterface
>
mSyncObj
;
}
;
template
<
typename
SyncInterface
typename
AsyncInterface
>
using
WaitableAsyncInvoker
=
AsyncInvoker
<
SyncInterface
AsyncInterface
detail
:
:
WaitableInvoker
>
;
}
}
#
define
ASYNC_INVOKER_FOR
(
SyncIface
)
\
mozilla
:
:
mscom
:
:
AsyncInvoker
<
SyncIface
Async
#
#
SyncIface
>
#
define
WAITABLE_ASYNC_INVOKER_FOR
(
SyncIface
)
\
mozilla
:
:
mscom
:
:
WaitableAsyncInvoker
<
SyncIface
Async
#
#
SyncIface
>
#
define
ASYNC_INVOKE
(
InvokerObj
SyncMethodName
.
.
.
)
\
InvokerObj
.
Invoke
(
&
decltype
(
InvokerObj
)
:
:
SyncInterfaceT
:
:
SyncMethodName
\
&
decltype
(
InvokerObj
)
:
:
AsyncInterfaceT
:
:
Begin_
#
#
SyncMethodName
\
__VA_ARGS__
)
#
endif
