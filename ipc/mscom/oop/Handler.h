#
ifndef
mozilla_mscom_Handler_h
#
define
mozilla_mscom_Handler_h
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
error
This
code
is
NOT
for
internal
Gecko
use
!
#
endif
#
include
<
objidl
.
h
>
#
include
"
mozilla
/
mscom
/
Aggregation
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
namespace
mscom
{
class
Handler
:
public
IMarshal
{
public
:
STDMETHODIMP
GetUnmarshalClass
(
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
CLSID
*
pCid
)
override
;
STDMETHODIMP
GetMarshalSizeMax
(
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
DWORD
*
pSize
)
override
;
STDMETHODIMP
MarshalInterface
(
IStream
*
pStm
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
)
override
;
STDMETHODIMP
UnmarshalInterface
(
IStream
*
pStm
REFIID
riid
void
*
*
ppv
)
override
;
STDMETHODIMP
ReleaseMarshalData
(
IStream
*
pStm
)
override
;
STDMETHODIMP
DisconnectObject
(
DWORD
dwReserved
)
override
;
virtual
HRESULT
QueryHandlerInterface
(
IUnknown
*
aProxyUnknown
REFIID
aIid
void
*
*
aOutInterface
)
=
0
;
virtual
HRESULT
ReadHandlerPayload
(
IStream
*
aStream
REFIID
aIid
)
{
return
S_FALSE
;
}
virtual
REFIID
MarshalAs
(
REFIID
aRequestedIid
)
{
return
aRequestedIid
;
}
virtual
HRESULT
GetHandlerPayloadSize
(
REFIID
aIid
DWORD
*
aOutPayloadSize
)
{
if
(
!
aOutPayloadSize
)
{
return
E_INVALIDARG
;
}
*
aOutPayloadSize
=
0
;
return
S_OK
;
}
virtual
HRESULT
WriteHandlerPayload
(
IStream
*
aStream
REFIID
aIid
)
{
return
S_OK
;
}
IUnknown
*
GetProxy
(
)
const
{
return
mInnerUnk
;
}
static
HRESULT
Register
(
REFCLSID
aClsid
)
;
static
HRESULT
Unregister
(
REFCLSID
aClsid
)
;
protected
:
Handler
(
IUnknown
*
aOuter
HRESULT
&
aResult
)
;
virtual
~
Handler
(
)
{
}
bool
HasPayload
(
)
const
{
return
mHasPayload
;
}
IUnknown
*
GetOuter
(
)
const
{
return
mOuter
;
}
private
:
ULONG
mRefCnt
;
IUnknown
*
mOuter
;
RefPtr
<
IUnknown
>
mInnerUnk
;
IMarshal
*
mUnmarshal
;
bool
mHasPayload
;
DECLARE_AGGREGATABLE
(
Handler
)
;
}
;
}
}
#
endif
