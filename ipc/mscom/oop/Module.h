#
ifndef
mozilla_mscom_Module_h
#
define
mozilla_mscom_Module_h
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
error
This
code
is
NOT
for
internal
Gecko
use
!
#
endif
#
include
<
objbase
.
h
>
namespace
mozilla
{
namespace
mscom
{
class
Module
{
public
:
static
HRESULT
CanUnload
(
)
{
return
sRefCount
=
=
0
?
S_OK
:
S_FALSE
;
}
static
void
Lock
(
)
{
+
+
sRefCount
;
}
static
void
Unlock
(
)
{
-
-
sRefCount
;
}
enum
class
ThreadingModel
{
DedicatedUiThreadOnly
MultiThreadedApartmentOnly
DedicatedUiThreadXorMultiThreadedApartment
AllThreadsAllApartments
}
;
enum
class
ClassType
{
InprocServer
InprocHandler
}
;
static
HRESULT
Register
(
REFCLSID
aClsid
const
ThreadingModel
aThreadingModel
const
ClassType
aClassType
=
ClassType
:
:
InprocServer
const
GUID
*
const
aAppId
=
nullptr
const
bool
aMsixContainer
=
false
)
{
const
CLSID
*
clsidArray
[
]
=
{
&
aClsid
}
;
return
Register
(
clsidArray
aThreadingModel
aClassType
aAppId
aMsixContainer
)
;
}
template
<
size_t
N
>
static
HRESULT
Register
(
const
CLSID
*
(
&
aClsids
)
[
N
]
const
ThreadingModel
aThreadingModel
const
ClassType
aClassType
=
ClassType
:
:
InprocServer
const
GUID
*
const
aAppId
=
nullptr
const
bool
aMsixContainer
=
false
)
{
return
Register
(
aClsids
N
aThreadingModel
aClassType
aAppId
aMsixContainer
)
;
}
static
HRESULT
Deregister
(
REFCLSID
aClsid
const
GUID
*
const
aAppId
=
nullptr
)
{
const
CLSID
*
clsidArray
[
]
=
{
&
aClsid
}
;
return
Deregister
(
clsidArray
aAppId
)
;
}
template
<
size_t
N
>
static
HRESULT
Deregister
(
const
CLSID
*
(
&
aClsids
)
[
N
]
const
GUID
*
const
aAppId
=
nullptr
)
{
return
Deregister
(
aClsids
N
aAppId
)
;
}
private
:
static
HRESULT
Register
(
const
CLSID
*
const
*
aClsids
const
size_t
aNumClsids
const
ThreadingModel
aThreadingModel
const
ClassType
aClassType
const
GUID
*
const
aAppId
const
bool
aMsixContainer
)
;
static
HRESULT
Deregister
(
const
CLSID
*
const
*
aClsids
const
size_t
aNumClsids
const
GUID
*
const
aAppId
)
;
private
:
static
ULONG
sRefCount
;
}
;
}
}
#
endif
