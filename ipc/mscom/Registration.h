#
ifndef
mozilla_mscom_Registration_h
#
define
mozilla_mscom_Registration_h
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
objbase
.
h
>
struct
ITypeInfo
;
struct
ITypeLib
;
namespace
mozilla
{
namespace
mscom
{
class
RegisteredProxy
{
public
:
RegisteredProxy
(
uintptr_t
aModule
IUnknown
*
aClassObject
uint32_t
aRegCookie
ITypeLib
*
aTypeLib
)
;
RegisteredProxy
(
IUnknown
*
aClassObject
uint32_t
aRegCookie
ITypeLib
*
aTypeLib
)
;
explicit
RegisteredProxy
(
ITypeLib
*
aTypeLib
)
;
RegisteredProxy
(
RegisteredProxy
&
&
aOther
)
;
RegisteredProxy
&
operator
=
(
RegisteredProxy
&
&
aOther
)
;
~
RegisteredProxy
(
)
;
HRESULT
GetTypeInfoForGuid
(
REFGUID
aGuid
ITypeInfo
*
*
aOutTypeInfo
)
const
;
static
bool
Find
(
REFIID
aIid
ITypeInfo
*
*
aOutTypeInfo
)
;
private
:
RegisteredProxy
(
)
=
delete
;
RegisteredProxy
(
RegisteredProxy
&
)
=
delete
;
RegisteredProxy
&
operator
=
(
RegisteredProxy
&
)
=
delete
;
void
Clear
(
)
;
static
void
AddToRegistry
(
RegisteredProxy
*
aProxy
)
;
static
void
DeleteFromRegistry
(
RegisteredProxy
*
aProxy
)
;
private
:
uintptr_t
mModule
;
IUnknown
*
mClassObject
;
uint32_t
mRegCookie
;
ITypeLib
*
mTypeLib
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
bool
mIsRegisteredInMTA
;
#
endif
}
;
enum
class
RegistrationFlags
{
eUseBinDirectory
eUseSystemDirectory
}
;
UniquePtr
<
RegisteredProxy
>
RegisterProxy
(
const
wchar_t
*
aLeafName
RegistrationFlags
aFlags
=
RegistrationFlags
:
:
eUseBinDirectory
)
;
UniquePtr
<
RegisteredProxy
>
RegisterTypelib
(
const
wchar_t
*
aLeafName
RegistrationFlags
aFlags
=
RegistrationFlags
:
:
eUseBinDirectory
)
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
struct
ArrayData
{
enum
class
Flag
{
eNone
=
0
eAllocatedByServer
=
1
}
;
ArrayData
(
REFIID
aIid
ULONG
aMethodIndex
ULONG
aArrayParamIndex
VARTYPE
aArrayParamType
REFIID
aArrayParamIid
ULONG
aLengthParamIndex
Flag
aFlag
=
Flag
:
:
eNone
)
:
mIid
(
aIid
)
mMethodIndex
(
aMethodIndex
)
mArrayParamIndex
(
aArrayParamIndex
)
mArrayParamType
(
aArrayParamType
)
mArrayParamIid
(
aArrayParamIid
)
mLengthParamIndex
(
aLengthParamIndex
)
mFlag
(
aFlag
)
{
}
ArrayData
(
const
ArrayData
&
aOther
)
{
*
this
=
aOther
;
}
ArrayData
&
operator
=
(
const
ArrayData
&
aOther
)
{
mIid
=
aOther
.
mIid
;
mMethodIndex
=
aOther
.
mMethodIndex
;
mArrayParamIndex
=
aOther
.
mArrayParamIndex
;
mArrayParamType
=
aOther
.
mArrayParamType
;
mArrayParamIid
=
aOther
.
mArrayParamIid
;
mLengthParamIndex
=
aOther
.
mLengthParamIndex
;
mFlag
=
aOther
.
mFlag
;
return
*
this
;
}
IID
mIid
;
ULONG
mMethodIndex
;
ULONG
mArrayParamIndex
;
VARTYPE
mArrayParamType
;
IID
mArrayParamIid
;
ULONG
mLengthParamIndex
;
Flag
mFlag
;
}
;
void
RegisterArrayData
(
const
ArrayData
*
aArrayData
size_t
aLength
)
;
template
<
size_t
N
>
inline
void
RegisterArrayData
(
const
ArrayData
(
&
aData
)
[
N
]
)
{
RegisterArrayData
(
aData
N
)
;
}
const
ArrayData
*
FindArrayData
(
REFIID
aIid
ULONG
aMethodIndex
)
;
#
endif
}
}
#
endif
