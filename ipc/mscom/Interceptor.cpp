#
define
INITGUID
#
include
"
mozilla
/
mscom
/
Interceptor
.
h
"
#
include
"
mozilla
/
mscom
/
InterceptorLog
.
h
"
#
include
"
mozilla
/
mscom
/
DispatchForwarder
.
h
"
#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
mozilla
/
mscom
/
Registration
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
mscom
{
HRESULT
Interceptor
:
:
Create
(
STAUniquePtr
<
IUnknown
>
aTarget
IInterceptorSink
*
aSink
REFIID
aIid
void
*
*
aOutput
)
{
MOZ_ASSERT
(
aOutput
&
&
aTarget
&
&
aSink
)
;
if
(
!
aOutput
)
{
return
E_INVALIDARG
;
}
*
aOutput
=
nullptr
;
if
(
!
aTarget
|
|
!
aSink
)
{
return
E_INVALIDARG
;
}
RefPtr
<
WeakReferenceSupport
>
intcpt
(
new
Interceptor
(
Move
(
aTarget
)
aSink
)
)
;
return
intcpt
-
>
QueryInterface
(
aIid
aOutput
)
;
}
Interceptor
:
:
Interceptor
(
STAUniquePtr
<
IUnknown
>
aTarget
IInterceptorSink
*
aSink
)
:
WeakReferenceSupport
(
WeakReferenceSupport
:
:
Flags
:
:
eDestroyOnMainThread
)
mTarget
(
Move
(
aTarget
)
)
mEventSink
(
aSink
)
mMutex
(
"
mozilla
:
:
mscom
:
:
Interceptor
:
:
mMutex
"
)
mStdMarshal
(
nullptr
)
{
MOZ_ASSERT
(
aSink
)
;
MOZ_ASSERT
(
!
IsProxy
(
mTarget
.
get
(
)
)
)
;
RefPtr
<
IWeakReference
>
weakRef
;
if
(
SUCCEEDED
(
GetWeakReference
(
getter_AddRefs
(
weakRef
)
)
)
)
{
aSink
-
>
SetInterceptor
(
weakRef
)
;
}
}
Interceptor
:
:
~
Interceptor
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
index
=
0
len
=
mInterceptorMap
.
Length
(
)
;
index
<
len
;
+
+
index
)
{
MapEntry
&
entry
=
mInterceptorMap
[
index
]
;
entry
.
mInterceptor
=
nullptr
;
entry
.
mTargetInterface
-
>
Release
(
)
;
}
}
HRESULT
Interceptor
:
:
GetClassForHandler
(
DWORD
aDestContext
void
*
aDestContextPtr
CLSID
*
aHandlerClsid
)
{
if
(
aDestContextPtr
|
|
!
aHandlerClsid
|
|
aDestContext
=
=
MSHCTX_DIFFERENTMACHINE
)
{
return
E_INVALIDARG
;
}
MOZ_ASSERT
(
mEventSink
)
;
return
mEventSink
-
>
GetHandler
(
aHandlerClsid
)
;
}
HRESULT
Interceptor
:
:
GetUnmarshalClass
(
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
CLSID
*
pCid
)
{
return
mStdMarshal
-
>
GetUnmarshalClass
(
riid
pv
dwDestContext
pvDestContext
mshlflags
pCid
)
;
}
HRESULT
Interceptor
:
:
GetMarshalSizeMax
(
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
DWORD
*
pSize
)
{
HRESULT
hr
=
mStdMarshal
-
>
GetMarshalSizeMax
(
riid
pv
dwDestContext
pvDestContext
mshlflags
pSize
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
DWORD
payloadSize
=
0
;
hr
=
mEventSink
-
>
GetHandlerPayloadSize
(
riid
mTarget
.
get
(
)
&
payloadSize
)
;
*
pSize
+
=
payloadSize
;
return
hr
;
}
HRESULT
Interceptor
:
:
MarshalInterface
(
IStream
*
pStm
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
)
{
HRESULT
hr
=
mStdMarshal
-
>
MarshalInterface
(
pStm
riid
pv
dwDestContext
pvDestContext
mshlflags
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
return
mEventSink
-
>
WriteHandlerPayload
(
pStm
riid
mTarget
.
get
(
)
)
;
}
HRESULT
Interceptor
:
:
UnmarshalInterface
(
IStream
*
pStm
REFIID
riid
void
*
*
ppv
)
{
return
mStdMarshal
-
>
UnmarshalInterface
(
pStm
riid
ppv
)
;
}
HRESULT
Interceptor
:
:
ReleaseMarshalData
(
IStream
*
pStm
)
{
return
mStdMarshal
-
>
ReleaseMarshalData
(
pStm
)
;
}
HRESULT
Interceptor
:
:
DisconnectObject
(
DWORD
dwReserved
)
{
return
mStdMarshal
-
>
DisconnectObject
(
dwReserved
)
;
}
Interceptor
:
:
MapEntry
*
Interceptor
:
:
Lookup
(
REFIID
aIid
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
uint32_t
index
=
0
len
=
mInterceptorMap
.
Length
(
)
;
index
<
len
;
+
+
index
)
{
if
(
mInterceptorMap
[
index
]
.
mIID
=
=
aIid
)
{
return
&
mInterceptorMap
[
index
]
;
}
}
return
nullptr
;
}
HRESULT
Interceptor
:
:
GetTargetForIID
(
REFIID
aIid
InterceptorTargetPtr
&
aTarget
)
{
MutexAutoLock
lock
(
mMutex
)
;
MapEntry
*
entry
=
Lookup
(
aIid
)
;
if
(
entry
)
{
aTarget
.
reset
(
entry
-
>
mTargetInterface
)
;
return
S_OK
;
}
return
E_NOINTERFACE
;
}
static
const
HRESULT
kFileNotFound
=
0x80070002
;
HRESULT
Interceptor
:
:
CreateInterceptor
(
REFIID
aIid
IUnknown
*
aOuter
IUnknown
*
*
aOutput
)
{
HRESULT
hr
=
:
:
CoGetInterceptor
(
aIid
aOuter
IID_IUnknown
(
void
*
*
)
aOutput
)
;
if
(
hr
!
=
kFileNotFound
)
{
return
hr
;
}
RefPtr
<
ITypeInfo
>
typeInfo
;
bool
found
=
RegisteredProxy
:
:
Find
(
aIid
getter_AddRefs
(
typeInfo
)
)
;
MOZ_ASSERT
(
found
)
;
if
(
!
found
)
{
return
kFileNotFound
;
}
hr
=
:
:
CoGetInterceptorFromTypeInfo
(
aIid
aOuter
typeInfo
IID_IUnknown
(
void
*
*
)
aOutput
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
)
;
return
hr
;
}
HRESULT
Interceptor
:
:
GetInterceptorForIID
(
REFIID
aIid
void
*
*
aOutInterceptor
)
{
if
(
!
aOutInterceptor
)
{
return
E_INVALIDARG
;
}
if
(
aIid
=
=
IID_IUnknown
)
{
RefPtr
<
IInterceptor
>
intcpt
(
this
)
;
intcpt
.
forget
(
aOutInterceptor
)
;
return
S_OK
;
}
REFIID
interceptorIid
=
mEventSink
-
>
MarshalAs
(
aIid
)
;
RefPtr
<
IUnknown
>
unkInterceptor
;
IUnknown
*
interfaceForQILog
=
nullptr
;
{
MutexAutoLock
lock
(
mMutex
)
;
MapEntry
*
entry
=
Lookup
(
interceptorIid
)
;
if
(
entry
)
{
unkInterceptor
=
entry
-
>
mInterceptor
;
interfaceForQILog
=
entry
-
>
mTargetInterface
;
}
}
if
(
unkInterceptor
)
{
InterceptorLog
:
:
QI
(
S_OK
mTarget
.
get
(
)
aIid
interfaceForQILog
)
;
return
unkInterceptor
-
>
QueryInterface
(
interceptorIid
aOutInterceptor
)
;
}
HRESULT
hr
;
STAUniquePtr
<
IUnknown
>
targetInterface
;
IUnknown
*
rawTargetInterface
=
nullptr
;
hr
=
QueryInterfaceTarget
(
interceptorIid
(
void
*
*
)
&
rawTargetInterface
)
;
targetInterface
.
reset
(
rawTargetInterface
)
;
InterceptorLog
:
:
QI
(
hr
mTarget
.
get
(
)
aIid
targetInterface
.
get
(
)
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
|
|
hr
=
=
E_NOINTERFACE
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
MOZ_ASSERT
(
aIid
!
=
IID_IMarshal
)
;
RefPtr
<
IUnknown
>
kungFuDeathGrip
(
static_cast
<
IUnknown
*
>
(
static_cast
<
WeakReferenceSupport
*
>
(
this
)
)
)
;
hr
=
CreateInterceptor
(
interceptorIid
kungFuDeathGrip
getter_AddRefs
(
unkInterceptor
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
RefPtr
<
ICallInterceptor
>
interceptor
;
hr
=
unkInterceptor
-
>
QueryInterface
(
IID_ICallInterceptor
(
void
*
*
)
getter_AddRefs
(
interceptor
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
hr
=
interceptor
-
>
RegisterSink
(
mEventSink
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
MapEntry
*
entry
=
Lookup
(
interceptorIid
)
;
if
(
entry
&
&
entry
-
>
mInterceptor
)
{
unkInterceptor
=
entry
-
>
mInterceptor
;
}
else
{
IUnknown
*
rawTargetInterface
=
targetInterface
.
release
(
)
;
mInterceptorMap
.
AppendElement
(
MapEntry
(
interceptorIid
unkInterceptor
rawTargetInterface
)
)
;
}
}
return
unkInterceptor
-
>
QueryInterface
(
interceptorIid
aOutInterceptor
)
;
}
HRESULT
Interceptor
:
:
QueryInterfaceTarget
(
REFIID
aIid
void
*
*
aOutput
)
{
MainThreadInvoker
invoker
;
HRESULT
hr
;
auto
runOnMainThread
=
[
&
]
(
)
-
>
void
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
hr
=
mTarget
-
>
QueryInterface
(
aIid
aOutput
)
;
}
;
if
(
!
invoker
.
Invoke
(
NS_NewRunnableFunction
(
runOnMainThread
)
)
)
{
return
E_FAIL
;
}
return
hr
;
}
HRESULT
Interceptor
:
:
QueryInterface
(
REFIID
riid
void
*
*
ppv
)
{
return
WeakReferenceSupport
:
:
QueryInterface
(
riid
ppv
)
;
}
HRESULT
Interceptor
:
:
ThreadSafeQueryInterface
(
REFIID
aIid
IUnknown
*
*
aOutInterface
)
{
if
(
aIid
=
=
IID_INoMarshal
)
{
return
E_NOINTERFACE
;
}
if
(
aIid
=
=
IID_IStdMarshalInfo
)
{
CLSID
dummy
;
if
(
FAILED
(
mEventSink
-
>
GetHandler
(
&
dummy
)
)
)
{
return
E_NOINTERFACE
;
}
RefPtr
<
IStdMarshalInfo
>
std
(
this
)
;
std
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IMarshal
)
{
CLSID
dummy
;
if
(
FAILED
(
mEventSink
-
>
GetHandler
(
&
dummy
)
)
)
{
return
E_NOINTERFACE
;
}
if
(
!
mStdMarshalUnk
)
{
HRESULT
hr
=
:
:
CoGetStdMarshalEx
(
static_cast
<
IWeakReferenceSource
*
>
(
this
)
SMEXF_SERVER
getter_AddRefs
(
mStdMarshalUnk
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
}
if
(
!
mStdMarshal
)
{
HRESULT
hr
=
mStdMarshalUnk
-
>
QueryInterface
(
IID_IMarshal
(
void
*
*
)
&
mStdMarshal
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
mStdMarshal
-
>
Release
(
)
;
}
RefPtr
<
IMarshal
>
marshal
(
this
)
;
marshal
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IInterceptor
)
{
RefPtr
<
IInterceptor
>
intcpt
(
this
)
;
intcpt
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IDispatch
)
{
STAUniquePtr
<
IDispatch
>
disp
;
IDispatch
*
rawDisp
=
nullptr
;
HRESULT
hr
=
QueryInterfaceTarget
(
aIid
(
void
*
*
)
&
rawDisp
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
disp
.
reset
(
rawDisp
)
;
return
DispatchForwarder
:
:
Create
(
this
disp
aOutInterface
)
;
}
return
GetInterceptorForIID
(
aIid
(
void
*
*
)
aOutInterface
)
;
}
ULONG
Interceptor
:
:
AddRef
(
)
{
return
WeakReferenceSupport
:
:
AddRef
(
)
;
}
ULONG
Interceptor
:
:
Release
(
)
{
return
WeakReferenceSupport
:
:
Release
(
)
;
}
}
}
