#
define
INITGUID
#
include
"
mozilla
/
mscom
/
Interceptor
.
h
"
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
mscom
/
DispatchForwarder
.
h
"
#
include
"
mozilla
/
mscom
/
FastMarshaler
.
h
"
#
include
"
mozilla
/
mscom
/
InterceptorLog
.
h
"
#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
mozilla
/
mscom
/
Objref
.
h
"
#
include
"
mozilla
/
mscom
/
Registration
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
define
ENSURE_HR_SUCCEEDED
(
hr
)
\
MOZ_ASSERT
(
SUCCEEDED
(
(
HRESULT
)
hr
)
)
;
\
if
(
FAILED
(
(
HRESULT
)
hr
)
)
{
\
return
hr
;
\
}
namespace
mozilla
{
namespace
mscom
{
namespace
detail
{
class
CAPABILITY
LiveSet
final
{
public
:
LiveSet
(
)
:
mMutex
(
"
mozilla
:
:
mscom
:
:
LiveSet
:
:
mMutex
"
)
{
}
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
mMutex
)
{
mMutex
.
Lock
(
)
;
}
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
mMutex
)
{
mMutex
.
Unlock
(
)
;
}
void
Put
(
IUnknown
*
aKey
already_AddRefed
<
IWeakReference
>
aValue
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
mLiveSet
.
InsertOrUpdate
(
aKey
RefPtr
<
IWeakReference
>
{
std
:
:
move
(
aValue
)
}
)
;
}
RefPtr
<
IWeakReference
>
Get
(
IUnknown
*
aKey
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
RefPtr
<
IWeakReference
>
result
;
mLiveSet
.
Get
(
aKey
getter_AddRefs
(
result
)
)
;
return
result
;
}
void
Remove
(
IUnknown
*
aKey
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
mLiveSet
.
Remove
(
aKey
)
;
}
private
:
Mutex
mMutex
MOZ_UNANNOTATED
;
nsRefPtrHashtable
<
nsPtrHashKey
<
IUnknown
>
IWeakReference
>
mLiveSet
;
}
;
class
MOZ_RAII
MOZ_SCOPED_CAPABILITY
LiveSetAutoLock
final
{
public
:
explicit
LiveSetAutoLock
(
LiveSet
&
aLiveSet
)
MOZ_CAPABILITY_ACQUIRE
(
aLiveSet
)
:
mLiveSet
(
&
aLiveSet
)
{
aLiveSet
.
Lock
(
)
;
}
~
LiveSetAutoLock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
if
(
mLiveSet
)
{
mLiveSet
-
>
Unlock
(
)
;
}
}
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
MOZ_ASSERT
(
mLiveSet
)
;
if
(
mLiveSet
)
{
mLiveSet
-
>
Unlock
(
)
;
mLiveSet
=
nullptr
;
}
}
LiveSetAutoLock
(
const
LiveSetAutoLock
&
aOther
)
=
delete
;
LiveSetAutoLock
(
LiveSetAutoLock
&
&
aOther
)
=
delete
;
LiveSetAutoLock
&
operator
=
(
const
LiveSetAutoLock
&
aOther
)
=
delete
;
LiveSetAutoLock
&
operator
=
(
LiveSetAutoLock
&
&
aOther
)
=
delete
;
private
:
LiveSet
*
mLiveSet
;
}
;
class
MOZ_RAII
ReentrySentinel
final
{
public
:
explicit
ReentrySentinel
(
Interceptor
*
aCurrent
)
:
mCurInterceptor
(
aCurrent
)
{
static
const
bool
kHasTls
=
tlsSentinelStackTop
.
init
(
)
;
MOZ_RELEASE_ASSERT
(
kHasTls
)
;
mPrevSentinel
=
tlsSentinelStackTop
.
get
(
)
;
tlsSentinelStackTop
.
set
(
this
)
;
}
~
ReentrySentinel
(
)
{
tlsSentinelStackTop
.
set
(
mPrevSentinel
)
;
}
bool
IsOutermost
(
)
const
{
return
!
(
mPrevSentinel
&
&
mPrevSentinel
-
>
IsMarshaling
(
mCurInterceptor
)
)
;
}
ReentrySentinel
(
const
ReentrySentinel
&
)
=
delete
;
ReentrySentinel
(
ReentrySentinel
&
&
)
=
delete
;
ReentrySentinel
&
operator
=
(
const
ReentrySentinel
&
)
=
delete
;
ReentrySentinel
&
operator
=
(
ReentrySentinel
&
&
)
=
delete
;
private
:
bool
IsMarshaling
(
Interceptor
*
aTopInterceptor
)
const
{
return
aTopInterceptor
=
=
mCurInterceptor
|
|
(
mPrevSentinel
&
&
mPrevSentinel
-
>
IsMarshaling
(
aTopInterceptor
)
)
;
}
private
:
Interceptor
*
mCurInterceptor
;
ReentrySentinel
*
mPrevSentinel
;
static
MOZ_THREAD_LOCAL
(
ReentrySentinel
*
)
tlsSentinelStackTop
;
}
;
MOZ_THREAD_LOCAL
(
ReentrySentinel
*
)
ReentrySentinel
:
:
tlsSentinelStackTop
;
class
MOZ_RAII
LoggedQIResult
final
{
public
:
explicit
LoggedQIResult
(
REFIID
aIid
)
:
mIid
(
aIid
)
mHr
(
E_UNEXPECTED
)
mTarget
(
nullptr
)
mInterceptor
(
nullptr
)
mBegin
(
TimeStamp
:
:
Now
(
)
)
{
}
~
LoggedQIResult
(
)
{
if
(
!
mTarget
)
{
return
;
}
TimeStamp
end
(
TimeStamp
:
:
Now
(
)
)
;
TimeDuration
total
(
end
-
mBegin
)
;
TimeDuration
overhead
(
total
-
mNonOverheadDuration
)
;
InterceptorLog
:
:
QI
(
mHr
mTarget
mIid
mInterceptor
&
overhead
&
mNonOverheadDuration
)
;
}
void
Log
(
IUnknown
*
aTarget
IUnknown
*
aInterceptor
)
{
mTarget
=
aTarget
;
mInterceptor
=
aInterceptor
;
}
void
operator
=
(
HRESULT
aHr
)
{
mHr
=
aHr
;
}
operator
HRESULT
(
)
{
return
mHr
;
}
operator
TimeDuration
*
(
)
{
return
&
mNonOverheadDuration
;
}
LoggedQIResult
(
const
LoggedQIResult
&
)
=
delete
;
LoggedQIResult
(
LoggedQIResult
&
&
)
=
delete
;
LoggedQIResult
&
operator
=
(
const
LoggedQIResult
&
)
=
delete
;
LoggedQIResult
&
operator
=
(
LoggedQIResult
&
&
)
=
delete
;
private
:
REFIID
mIid
;
HRESULT
mHr
;
IUnknown
*
mTarget
;
IUnknown
*
mInterceptor
;
TimeDuration
mNonOverheadDuration
;
TimeStamp
mBegin
;
}
;
}
static
detail
:
:
LiveSet
&
GetLiveSet
(
)
{
static
detail
:
:
LiveSet
sLiveSet
;
return
sLiveSet
;
}
MOZ_THREAD_LOCAL
(
bool
)
Interceptor
:
:
tlsCreatingStdMarshal
;
HRESULT
Interceptor
:
:
Create
(
STAUniquePtr
<
IUnknown
>
aTarget
IInterceptorSink
*
aSink
REFIID
aInitialIid
void
*
*
aOutInterface
)
{
MOZ_ASSERT
(
aOutInterface
&
&
aTarget
&
&
aSink
)
;
if
(
!
aOutInterface
)
{
return
E_INVALIDARG
;
}
detail
:
:
LiveSetAutoLock
lock
(
GetLiveSet
(
)
)
;
RefPtr
<
IWeakReference
>
existingWeak
(
GetLiveSet
(
)
.
Get
(
aTarget
.
get
(
)
)
)
;
if
(
existingWeak
)
{
RefPtr
<
IWeakReferenceSource
>
existingStrong
;
if
(
SUCCEEDED
(
existingWeak
-
>
ToStrongRef
(
getter_AddRefs
(
existingStrong
)
)
)
)
{
lock
.
Unlock
(
)
;
return
existingStrong
-
>
QueryInterface
(
aInitialIid
aOutInterface
)
;
}
}
*
aOutInterface
=
nullptr
;
if
(
!
aTarget
|
|
!
aSink
)
{
return
E_INVALIDARG
;
}
RefPtr
<
Interceptor
>
intcpt
(
new
Interceptor
(
aSink
)
)
;
return
intcpt
-
>
GetInitialInterceptorForIID
(
lock
aInitialIid
std
:
:
move
(
aTarget
)
aOutInterface
)
;
}
Interceptor
:
:
Interceptor
(
IInterceptorSink
*
aSink
)
:
WeakReferenceSupport
(
WeakReferenceSupport
:
:
Flags
:
:
eDestroyOnMainThread
)
mEventSink
(
aSink
)
mInterceptorMapMutex
(
"
mozilla
:
:
mscom
:
:
Interceptor
:
:
mInterceptorMapMutex
"
)
mStdMarshalMutex
(
"
mozilla
:
:
mscom
:
:
Interceptor
:
:
mStdMarshalMutex
"
)
mStdMarshal
(
nullptr
)
{
static
const
bool
kHasTls
=
tlsCreatingStdMarshal
.
init
(
)
;
MOZ_ASSERT
(
kHasTls
)
;
Unused
<
<
kHasTls
;
MOZ_ASSERT
(
aSink
)
;
RefPtr
<
IWeakReference
>
weakRef
;
if
(
SUCCEEDED
(
GetWeakReference
(
getter_AddRefs
(
weakRef
)
)
)
)
{
aSink
-
>
SetInterceptor
(
weakRef
)
;
}
}
Interceptor
:
:
~
Interceptor
(
)
{
{
detail
:
:
LiveSetAutoLock
lock
(
GetLiveSet
(
)
)
;
GetLiveSet
(
)
.
Remove
(
mTarget
.
get
(
)
)
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
index
=
0
len
=
mInterceptorMap
.
Length
(
)
;
index
<
len
;
+
+
index
)
{
MapEntry
&
entry
=
mInterceptorMap
[
index
]
;
entry
.
mInterceptor
=
nullptr
;
entry
.
mTargetInterface
-
>
Release
(
)
;
}
}
HRESULT
Interceptor
:
:
GetClassForHandler
(
DWORD
aDestContext
void
*
aDestContextPtr
CLSID
*
aHandlerClsid
)
{
if
(
aDestContextPtr
|
|
!
aHandlerClsid
|
|
aDestContext
=
=
MSHCTX_DIFFERENTMACHINE
)
{
return
E_INVALIDARG
;
}
MOZ_ASSERT
(
mEventSink
)
;
return
mEventSink
-
>
GetHandler
(
WrapNotNull
(
aHandlerClsid
)
)
;
}
REFIID
Interceptor
:
:
MarshalAs
(
REFIID
aIid
)
const
{
#
if
defined
(
MOZ_MSCOM_REMARSHAL_NO_HANDLER
)
return
IsCallerExternalProcess
(
)
?
aIid
:
mEventSink
-
>
MarshalAs
(
aIid
)
;
#
else
return
mEventSink
-
>
MarshalAs
(
aIid
)
;
#
endif
}
HRESULT
Interceptor
:
:
GetUnmarshalClass
(
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
CLSID
*
pCid
)
{
return
mStdMarshal
-
>
GetUnmarshalClass
(
MarshalAs
(
riid
)
pv
dwDestContext
pvDestContext
mshlflags
pCid
)
;
}
HRESULT
Interceptor
:
:
GetMarshalSizeMax
(
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
DWORD
*
pSize
)
{
detail
:
:
ReentrySentinel
sentinel
(
this
)
;
HRESULT
hr
=
mStdMarshal
-
>
GetMarshalSizeMax
(
MarshalAs
(
riid
)
pv
dwDestContext
pvDestContext
mshlflags
pSize
)
;
if
(
FAILED
(
hr
)
|
|
!
sentinel
.
IsOutermost
(
)
)
{
return
hr
;
}
#
if
defined
(
MOZ_MSCOM_REMARSHAL_NO_HANDLER
)
if
(
XRE_IsContentProcess
(
)
&
&
IsCallerExternalProcess
(
)
)
{
return
hr
;
}
#
endif
DWORD
payloadSize
=
0
;
hr
=
mEventSink
-
>
GetHandlerPayloadSize
(
WrapNotNull
(
this
)
WrapNotNull
(
&
payloadSize
)
)
;
if
(
hr
=
=
E_NOTIMPL
)
{
return
S_OK
;
}
if
(
SUCCEEDED
(
hr
)
)
{
*
pSize
+
=
payloadSize
;
}
return
hr
;
}
HRESULT
Interceptor
:
:
MarshalInterface
(
IStream
*
pStm
REFIID
riid
void
*
pv
DWORD
dwDestContext
void
*
pvDestContext
DWORD
mshlflags
)
{
detail
:
:
ReentrySentinel
sentinel
(
this
)
;
HRESULT
hr
;
#
if
defined
(
MOZ_MSCOM_REMARSHAL_NO_HANDLER
)
LARGE_INTEGER
seekTo
;
seekTo
.
QuadPart
=
0
;
ULARGE_INTEGER
objrefPos
;
hr
=
pStm
-
>
Seek
(
seekTo
STREAM_SEEK_CUR
&
objrefPos
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
#
endif
hr
=
mStdMarshal
-
>
MarshalInterface
(
pStm
MarshalAs
(
riid
)
pv
dwDestContext
pvDestContext
mshlflags
)
;
if
(
FAILED
(
hr
)
|
|
!
sentinel
.
IsOutermost
(
)
)
{
return
hr
;
}
#
if
defined
(
MOZ_MSCOM_REMARSHAL_NO_HANDLER
)
if
(
XRE_IsContentProcess
(
)
&
&
IsCallerExternalProcess
(
)
)
{
ULARGE_INTEGER
endPos
;
hr
=
pStm
-
>
Seek
(
seekTo
STREAM_SEEK_CUR
&
endPos
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
if
(
!
StripHandlerFromOBJREF
(
WrapNotNull
(
pStm
)
objrefPos
.
QuadPart
endPos
.
QuadPart
)
)
{
return
E_FAIL
;
}
return
S_OK
;
}
#
endif
hr
=
mEventSink
-
>
WriteHandlerPayload
(
WrapNotNull
(
this
)
WrapNotNull
(
pStm
)
)
;
if
(
hr
=
=
E_NOTIMPL
)
{
return
S_OK
;
}
return
hr
;
}
HRESULT
Interceptor
:
:
UnmarshalInterface
(
IStream
*
pStm
REFIID
riid
void
*
*
ppv
)
{
return
mStdMarshal
-
>
UnmarshalInterface
(
pStm
riid
ppv
)
;
}
HRESULT
Interceptor
:
:
ReleaseMarshalData
(
IStream
*
pStm
)
{
return
mStdMarshal
-
>
ReleaseMarshalData
(
pStm
)
;
}
HRESULT
Interceptor
:
:
DisconnectObject
(
DWORD
dwReserved
)
{
mEventSink
-
>
DisconnectHandlerRemotes
(
)
;
return
mStdMarshal
-
>
DisconnectObject
(
dwReserved
)
;
}
Interceptor
:
:
MapEntry
*
Interceptor
:
:
Lookup
(
REFIID
aIid
)
{
mInterceptorMapMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
uint32_t
index
=
0
len
=
mInterceptorMap
.
Length
(
)
;
index
<
len
;
+
+
index
)
{
if
(
mInterceptorMap
[
index
]
.
mIID
=
=
aIid
)
{
return
&
mInterceptorMap
[
index
]
;
}
}
return
nullptr
;
}
HRESULT
Interceptor
:
:
GetTargetForIID
(
REFIID
aIid
InterceptorTargetPtr
<
IUnknown
>
&
aTarget
)
{
MutexAutoLock
lock
(
mInterceptorMapMutex
)
;
MapEntry
*
entry
=
Lookup
(
aIid
)
;
if
(
entry
)
{
aTarget
.
reset
(
entry
-
>
mTargetInterface
)
;
return
S_OK
;
}
return
E_NOINTERFACE
;
}
static
const
HRESULT
kFileNotFound
=
HRESULT_FROM_WIN32
(
ERROR_FILE_NOT_FOUND
)
;
HRESULT
Interceptor
:
:
CreateInterceptor
(
REFIID
aIid
IUnknown
*
aOuter
IUnknown
*
*
aOutput
)
{
HRESULT
hr
=
:
:
CoGetInterceptor
(
aIid
aOuter
IID_IUnknown
(
void
*
*
)
aOutput
)
;
if
(
hr
!
=
kFileNotFound
)
{
return
hr
;
}
RefPtr
<
ITypeInfo
>
typeInfo
;
bool
found
=
RegisteredProxy
:
:
Find
(
aIid
getter_AddRefs
(
typeInfo
)
)
;
MOZ_ASSERT
(
found
)
;
if
(
!
found
)
{
return
kFileNotFound
;
}
hr
=
:
:
CoGetInterceptorFromTypeInfo
(
aIid
aOuter
typeInfo
IID_IUnknown
(
void
*
*
)
aOutput
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
)
;
return
hr
;
}
HRESULT
Interceptor
:
:
PublishTarget
(
detail
:
:
LiveSetAutoLock
&
aLiveSetLock
RefPtr
<
IUnknown
>
aInterceptor
REFIID
aTargetIid
STAUniquePtr
<
IUnknown
>
aTarget
)
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
RefPtr
<
IWeakReference
>
weakRef
;
HRESULT
hr
=
GetWeakReference
(
getter_AddRefs
(
weakRef
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
mTarget
=
ToInterceptorTargetPtr
(
aTarget
)
;
GetLiveSet
(
)
.
Put
(
mTarget
.
get
(
)
weakRef
.
forget
(
)
)
;
mInterceptorMap
.
AppendElement
(
MapEntry
(
aTargetIid
aInterceptor
aTarget
.
release
(
)
)
)
;
aLiveSetLock
.
Unlock
(
)
;
return
S_OK
;
}
HRESULT
Interceptor
:
:
GetInitialInterceptorForIID
(
detail
:
:
LiveSetAutoLock
&
aLiveSetLock
REFIID
aTargetIid
STAUniquePtr
<
IUnknown
>
aTarget
void
*
*
aOutInterceptor
)
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
MOZ_ASSERT
(
aOutInterceptor
)
;
MOZ_ASSERT
(
aTargetIid
!
=
IID_IMarshal
)
;
MOZ_ASSERT
(
!
IsProxy
(
aTarget
.
get
(
)
)
)
;
HRESULT
hr
=
E_UNEXPECTED
;
auto
hasFailed
=
[
&
hr
]
(
)
-
>
bool
{
return
FAILED
(
hr
)
;
}
;
MOZ_PUSH_IGNORE_THREAD_SAFETY
auto
cleanup
=
[
&
aLiveSetLock
]
(
)
-
>
void
{
aLiveSetLock
.
Unlock
(
)
;
}
;
MOZ_POP_THREAD_SAFETY
ExecuteWhen
<
decltype
(
hasFailed
)
decltype
(
cleanup
)
>
onFail
(
hasFailed
cleanup
)
;
if
(
aTargetIid
=
=
IID_IUnknown
)
{
MutexAutoLock
lock
(
mInterceptorMapMutex
)
;
hr
=
PublishTarget
(
aLiveSetLock
nullptr
aTargetIid
std
:
:
move
(
aTarget
)
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
hr
=
QueryInterface
(
aTargetIid
aOutInterceptor
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
return
hr
;
}
WeakReferenceSupport
:
:
StabilizeRefCount
stabilizer
(
*
this
)
;
RefPtr
<
IUnknown
>
unkInterceptor
;
hr
=
CreateInterceptor
(
aTargetIid
static_cast
<
WeakReferenceSupport
*
>
(
this
)
getter_AddRefs
(
unkInterceptor
)
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
RefPtr
<
ICallInterceptor
>
interceptor
;
hr
=
unkInterceptor
-
>
QueryInterface
(
IID_ICallInterceptor
getter_AddRefs
(
interceptor
)
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
hr
=
interceptor
-
>
RegisterSink
(
mEventSink
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
MutexAutoLock
lock
(
mInterceptorMapMutex
)
;
hr
=
PublishTarget
(
aLiveSetLock
unkInterceptor
aTargetIid
std
:
:
move
(
aTarget
)
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
if
(
MarshalAs
(
aTargetIid
)
=
=
aTargetIid
)
{
hr
=
unkInterceptor
-
>
QueryInterface
(
aTargetIid
aOutInterceptor
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
return
hr
;
}
hr
=
GetInterceptorForIID
(
aTargetIid
aOutInterceptor
&
lock
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
return
hr
;
}
HRESULT
Interceptor
:
:
GetInterceptorForIID
(
REFIID
aIid
void
*
*
aOutInterceptor
)
{
return
GetInterceptorForIID
(
aIid
aOutInterceptor
nullptr
)
;
}
HRESULT
Interceptor
:
:
GetInterceptorForIID
(
REFIID
aIid
void
*
*
aOutInterceptor
MutexAutoLock
*
aAlreadyLocked
)
{
detail
:
:
LoggedQIResult
result
(
aIid
)
;
if
(
!
aOutInterceptor
)
{
return
E_INVALIDARG
;
}
if
(
aIid
=
=
IID_IUnknown
)
{
RefPtr
<
IInterceptor
>
intcpt
(
this
)
;
intcpt
.
forget
(
aOutInterceptor
)
;
return
S_OK
;
}
REFIID
interceptorIid
=
MarshalAs
(
aIid
)
;
RefPtr
<
IUnknown
>
unkInterceptor
;
IUnknown
*
interfaceForQILog
=
nullptr
;
auto
doLookup
=
[
&
]
(
)
-
>
void
{
MapEntry
*
entry
=
Lookup
(
interceptorIid
)
;
if
(
entry
)
{
unkInterceptor
=
entry
-
>
mInterceptor
;
interfaceForQILog
=
entry
-
>
mTargetInterface
;
}
}
;
if
(
aAlreadyLocked
)
{
doLookup
(
)
;
}
else
{
MutexAutoLock
lock
(
mInterceptorMapMutex
)
;
doLookup
(
)
;
}
if
(
unkInterceptor
)
{
result
.
Log
(
mTarget
.
get
(
)
interfaceForQILog
)
;
result
=
unkInterceptor
-
>
QueryInterface
(
interceptorIid
aOutInterceptor
)
;
ENSURE_HR_SUCCEEDED
(
result
)
;
return
result
;
}
HRESULT
hr
;
STAUniquePtr
<
IUnknown
>
targetInterface
;
IUnknown
*
rawTargetInterface
=
nullptr
;
hr
=
QueryInterfaceTarget
(
interceptorIid
(
void
*
*
)
&
rawTargetInterface
result
)
;
targetInterface
.
reset
(
rawTargetInterface
)
;
result
=
hr
;
result
.
Log
(
mTarget
.
get
(
)
targetInterface
.
get
(
)
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
|
|
hr
=
=
E_NOINTERFACE
)
;
if
(
hr
=
=
E_NOINTERFACE
)
{
return
hr
;
}
ENSURE_HR_SUCCEEDED
(
hr
)
;
MOZ_ASSERT
(
aIid
!
=
IID_IMarshal
)
;
WeakReferenceSupport
:
:
StabilizeRefCount
stabilizer
(
*
this
)
;
hr
=
CreateInterceptor
(
interceptorIid
static_cast
<
WeakReferenceSupport
*
>
(
this
)
getter_AddRefs
(
unkInterceptor
)
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
RefPtr
<
ICallInterceptor
>
interceptor
;
hr
=
unkInterceptor
-
>
QueryInterface
(
IID_ICallInterceptor
(
void
*
*
)
getter_AddRefs
(
interceptor
)
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
hr
=
interceptor
-
>
RegisterSink
(
mEventSink
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
auto
doInsertion
=
[
&
]
(
)
-
>
void
{
MapEntry
*
entry
=
Lookup
(
interceptorIid
)
;
if
(
entry
&
&
entry
-
>
mInterceptor
)
{
interceptor
=
nullptr
;
unkInterceptor
=
entry
-
>
mInterceptor
;
}
else
{
IUnknown
*
rawTargetInterface
=
targetInterface
.
release
(
)
;
mInterceptorMap
.
AppendElement
(
MapEntry
(
interceptorIid
unkInterceptor
rawTargetInterface
)
)
;
}
}
;
if
(
aAlreadyLocked
)
{
doInsertion
(
)
;
}
else
{
MutexAutoLock
lock
(
mInterceptorMapMutex
)
;
doInsertion
(
)
;
}
hr
=
unkInterceptor
-
>
QueryInterface
(
interceptorIid
aOutInterceptor
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
return
hr
;
}
HRESULT
Interceptor
:
:
QueryInterfaceTarget
(
REFIID
aIid
void
*
*
aOutput
TimeDuration
*
aOutDuration
)
{
if
(
!
NS_IsMainThread
(
)
&
&
tlsCreatingStdMarshal
.
get
(
)
)
{
mStdMarshalMutex
.
AssertCurrentThreadOwns
(
)
;
return
E_NOINTERFACE
;
}
if
(
mEventSink
-
>
IsInterfaceMaybeSupported
(
aIid
)
=
=
E_NOINTERFACE
)
{
return
E_NOINTERFACE
;
}
MainThreadInvoker
invoker
;
HRESULT
hr
;
auto
runOnMainThread
=
[
&
]
(
)
-
>
void
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
hr
=
mTarget
-
>
QueryInterface
(
aIid
aOutput
)
;
}
;
if
(
!
invoker
.
Invoke
(
NS_NewRunnableFunction
(
"
Interceptor
:
:
QueryInterface
"
runOnMainThread
)
)
)
{
return
E_FAIL
;
}
if
(
aOutDuration
)
{
*
aOutDuration
=
invoker
.
GetDuration
(
)
;
}
return
hr
;
}
HRESULT
Interceptor
:
:
QueryInterface
(
REFIID
riid
void
*
*
ppv
)
{
if
(
riid
=
=
IID_INoMarshal
)
{
return
E_NOINTERFACE
;
}
return
WeakReferenceSupport
:
:
QueryInterface
(
riid
ppv
)
;
}
HRESULT
Interceptor
:
:
WeakRefQueryInterface
(
REFIID
aIid
IUnknown
*
*
aOutInterface
)
{
if
(
aIid
=
=
IID_IStdMarshalInfo
)
{
detail
:
:
ReentrySentinel
sentinel
(
this
)
;
if
(
!
sentinel
.
IsOutermost
(
)
)
{
return
E_NOINTERFACE
;
}
CLSID
dummy
;
if
(
FAILED
(
mEventSink
-
>
GetHandler
(
WrapNotNull
(
&
dummy
)
)
)
)
{
return
E_NOINTERFACE
;
}
RefPtr
<
IStdMarshalInfo
>
std
(
this
)
;
std
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IMarshal
)
{
MutexAutoLock
lock
(
mStdMarshalMutex
)
;
HRESULT
hr
;
if
(
!
mStdMarshalUnk
)
{
MOZ_ASSERT
(
!
tlsCreatingStdMarshal
.
get
(
)
)
;
tlsCreatingStdMarshal
.
set
(
true
)
;
if
(
XRE_IsContentProcess
(
)
)
{
hr
=
FastMarshaler
:
:
Create
(
static_cast
<
IWeakReferenceSource
*
>
(
this
)
getter_AddRefs
(
mStdMarshalUnk
)
)
;
}
else
{
hr
=
:
:
CoGetStdMarshalEx
(
static_cast
<
IWeakReferenceSource
*
>
(
this
)
SMEXF_SERVER
getter_AddRefs
(
mStdMarshalUnk
)
)
;
}
tlsCreatingStdMarshal
.
set
(
false
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
}
if
(
!
mStdMarshal
)
{
hr
=
mStdMarshalUnk
-
>
QueryInterface
(
IID_IMarshal
(
void
*
*
)
&
mStdMarshal
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
mStdMarshal
-
>
Release
(
)
;
}
RefPtr
<
IMarshal
>
marshal
(
this
)
;
marshal
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IInterceptor
)
{
RefPtr
<
IInterceptor
>
intcpt
(
this
)
;
intcpt
.
forget
(
aOutInterface
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IDispatch
)
{
STAUniquePtr
<
IDispatch
>
disp
;
IDispatch
*
rawDisp
=
nullptr
;
HRESULT
hr
=
QueryInterfaceTarget
(
aIid
(
void
*
*
)
&
rawDisp
)
;
ENSURE_HR_SUCCEEDED
(
hr
)
;
disp
.
reset
(
rawDisp
)
;
return
DispatchForwarder
:
:
Create
(
this
disp
aOutInterface
)
;
}
return
GetInterceptorForIID
(
aIid
(
void
*
*
)
aOutInterface
nullptr
)
;
}
ULONG
Interceptor
:
:
AddRef
(
)
{
return
WeakReferenceSupport
:
:
AddRef
(
)
;
}
ULONG
Interceptor
:
:
Release
(
)
{
return
WeakReferenceSupport
:
:
Release
(
)
;
}
HRESULT
Interceptor
:
:
DisconnectRemotesForTarget
(
IUnknown
*
aTarget
)
{
MOZ_ASSERT
(
aTarget
)
;
detail
:
:
LiveSetAutoLock
lock
(
GetLiveSet
(
)
)
;
RefPtr
<
IWeakReference
>
existingWeak
(
GetLiveSet
(
)
.
Get
(
aTarget
)
)
;
if
(
!
existingWeak
)
{
return
S_FALSE
;
}
RefPtr
<
IWeakReferenceSource
>
existingStrong
;
if
(
FAILED
(
existingWeak
-
>
ToStrongRef
(
getter_AddRefs
(
existingStrong
)
)
)
)
{
return
S_FALSE
;
}
lock
.
Unlock
(
)
;
return
:
:
CoDisconnectObject
(
existingStrong
0
)
;
}
}
}
