#
define
INITGUID
#
include
"
mozilla
/
mscom
/
Interceptor
.
h
"
#
include
"
mozilla
/
mscom
/
InterceptorLog
.
h
"
#
include
"
mozilla
/
mscom
/
DispatchForwarder
.
h
"
#
include
"
mozilla
/
mscom
/
MainThreadInvoker
.
h
"
#
include
"
mozilla
/
mscom
/
Registration
.
h
"
#
include
"
mozilla
/
mscom
/
utils
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
mscom
{
HRESULT
Interceptor
:
:
Create
(
STAUniquePtr
<
IUnknown
>
&
aTarget
IInterceptorSink
*
aSink
REFIID
aIid
void
*
*
aOutput
)
{
if
(
!
aOutput
)
{
return
E_INVALIDARG
;
}
*
aOutput
=
nullptr
;
if
(
!
aTarget
|
|
!
aSink
)
{
return
E_INVALIDARG
;
}
Interceptor
*
intcpt
=
new
Interceptor
(
aTarget
aSink
)
;
HRESULT
hr
=
intcpt
-
>
QueryInterface
(
aIid
aOutput
)
;
static_cast
<
WeakReferenceSupport
*
>
(
intcpt
)
-
>
Release
(
)
;
return
hr
;
}
Interceptor
:
:
Interceptor
(
STAUniquePtr
<
IUnknown
>
&
aTarget
IInterceptorSink
*
aSink
)
:
WeakReferenceSupport
(
WeakReferenceSupport
:
:
Flags
:
:
eDestroyOnMainThread
)
mTarget
(
Move
(
aTarget
)
)
mEventSink
(
aSink
)
mMutex
(
"
mozilla
:
:
mscom
:
:
Interceptor
:
:
mMutex
"
)
{
MOZ_ASSERT
(
aSink
)
;
MOZ_ASSERT
(
!
IsProxy
(
mTarget
.
get
(
)
)
)
;
RefPtr
<
IWeakReference
>
weakRef
;
if
(
SUCCEEDED
(
GetWeakReference
(
getter_AddRefs
(
weakRef
)
)
)
)
{
aSink
-
>
SetInterceptor
(
weakRef
)
;
}
}
Interceptor
:
:
~
Interceptor
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
index
=
0
len
=
mInterceptorMap
.
Length
(
)
;
index
<
len
;
+
+
index
)
{
MapEntry
&
entry
=
mInterceptorMap
[
index
]
;
entry
.
mInterceptor
-
>
Release
(
)
;
entry
.
mTargetInterface
-
>
Release
(
)
;
}
}
Interceptor
:
:
MapEntry
*
Interceptor
:
:
Lookup
(
REFIID
aIid
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
for
(
uint32_t
index
=
0
len
=
mInterceptorMap
.
Length
(
)
;
index
<
len
;
+
+
index
)
{
if
(
mInterceptorMap
[
index
]
.
mIID
=
=
aIid
)
{
return
&
mInterceptorMap
[
index
]
;
}
}
return
nullptr
;
}
HRESULT
Interceptor
:
:
GetTargetForIID
(
REFIID
aIid
InterceptorTargetPtr
&
aTarget
)
{
MutexAutoLock
lock
(
mMutex
)
;
MapEntry
*
entry
=
Lookup
(
aIid
)
;
if
(
entry
)
{
aTarget
.
reset
(
entry
-
>
mTargetInterface
)
;
return
S_OK
;
}
return
E_NOINTERFACE
;
}
static
const
HRESULT
kFileNotFound
=
0x80070002
;
HRESULT
Interceptor
:
:
CreateInterceptor
(
REFIID
aIid
IUnknown
*
aOuter
IUnknown
*
*
aOutput
)
{
HRESULT
hr
=
:
:
CoGetInterceptor
(
aIid
aOuter
IID_IUnknown
(
void
*
*
)
aOutput
)
;
if
(
hr
!
=
kFileNotFound
)
{
return
hr
;
}
RefPtr
<
ITypeInfo
>
typeInfo
;
bool
found
=
RegisteredProxy
:
:
Find
(
aIid
getter_AddRefs
(
typeInfo
)
)
;
MOZ_ASSERT
(
found
)
;
if
(
!
found
)
{
return
kFileNotFound
;
}
hr
=
:
:
CoGetInterceptorFromTypeInfo
(
aIid
aOuter
typeInfo
IID_IUnknown
(
void
*
*
)
aOutput
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
)
;
return
hr
;
}
HRESULT
Interceptor
:
:
GetInterceptorForIID
(
REFIID
aIid
void
*
*
aOutInterceptor
)
{
if
(
!
aOutInterceptor
)
{
return
E_INVALIDARG
;
}
RefPtr
<
IUnknown
>
unkInterceptor
;
IUnknown
*
interfaceForQILog
=
nullptr
;
{
MutexAutoLock
lock
(
mMutex
)
;
MapEntry
*
entry
=
Lookup
(
aIid
)
;
if
(
entry
)
{
unkInterceptor
=
entry
-
>
mInterceptor
;
interfaceForQILog
=
entry
-
>
mTargetInterface
;
}
}
if
(
unkInterceptor
)
{
InterceptorLog
:
:
QI
(
S_OK
mTarget
.
get
(
)
aIid
interfaceForQILog
)
;
return
unkInterceptor
-
>
QueryInterface
(
aIid
aOutInterceptor
)
;
}
HRESULT
hr
;
STAUniquePtr
<
IUnknown
>
targetInterface
;
IUnknown
*
rawTargetInterface
=
nullptr
;
hr
=
QueryInterfaceTarget
(
aIid
(
void
*
*
)
&
rawTargetInterface
)
;
targetInterface
.
reset
(
rawTargetInterface
)
;
InterceptorLog
:
:
QI
(
hr
mTarget
.
get
(
)
aIid
targetInterface
.
get
(
)
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
|
|
hr
=
=
E_NOINTERFACE
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
MOZ_ASSERT
(
aIid
!
=
IID_IMarshal
)
;
RefPtr
<
IUnknown
>
kungFuDeathGrip
(
static_cast
<
IUnknown
*
>
(
static_cast
<
WeakReferenceSupport
*
>
(
this
)
)
)
;
hr
=
CreateInterceptor
(
aIid
kungFuDeathGrip
getter_AddRefs
(
unkInterceptor
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
RefPtr
<
ICallInterceptor
>
interceptor
;
hr
=
unkInterceptor
-
>
QueryInterface
(
IID_ICallInterceptor
(
void
*
*
)
getter_AddRefs
(
interceptor
)
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
hr
=
interceptor
-
>
RegisterSink
(
mEventSink
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
{
MutexAutoLock
lock
(
mMutex
)
;
MapEntry
*
entry
=
Lookup
(
aIid
)
;
if
(
entry
&
&
entry
-
>
mInterceptor
)
{
unkInterceptor
=
entry
-
>
mInterceptor
;
}
else
{
unkInterceptor
-
>
AddRef
(
)
;
IUnknown
*
rawTargetInterface
=
targetInterface
.
release
(
)
;
mInterceptorMap
.
AppendElement
(
MapEntry
(
aIid
unkInterceptor
rawTargetInterface
)
)
;
}
}
return
unkInterceptor
-
>
QueryInterface
(
aIid
aOutInterceptor
)
;
}
HRESULT
Interceptor
:
:
QueryInterfaceTarget
(
REFIID
aIid
void
*
*
aOutput
)
{
MainThreadInvoker
invoker
;
HRESULT
hr
;
auto
runOnMainThread
=
[
&
]
(
)
-
>
void
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
hr
=
mTarget
-
>
QueryInterface
(
aIid
aOutput
)
;
}
;
if
(
!
invoker
.
Invoke
(
NS_NewRunnableFunction
(
runOnMainThread
)
)
)
{
return
E_FAIL
;
}
return
hr
;
}
HRESULT
Interceptor
:
:
QueryInterface
(
REFIID
riid
void
*
*
ppv
)
{
return
WeakReferenceSupport
:
:
QueryInterface
(
riid
ppv
)
;
}
HRESULT
Interceptor
:
:
ThreadSafeQueryInterface
(
REFIID
aIid
IUnknown
*
*
aOutInterface
)
{
if
(
aIid
=
=
IID_IInterceptor
)
{
*
aOutInterface
=
static_cast
<
IInterceptor
*
>
(
this
)
;
(
*
aOutInterface
)
-
>
AddRef
(
)
;
return
S_OK
;
}
if
(
aIid
=
=
IID_IDispatch
)
{
STAUniquePtr
<
IDispatch
>
disp
;
IDispatch
*
rawDisp
=
nullptr
;
HRESULT
hr
=
QueryInterfaceTarget
(
aIid
(
void
*
*
)
&
rawDisp
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
disp
.
reset
(
rawDisp
)
;
return
DispatchForwarder
:
:
Create
(
this
disp
aOutInterface
)
;
}
return
GetInterceptorForIID
(
aIid
(
void
*
*
)
aOutInterface
)
;
}
ULONG
Interceptor
:
:
AddRef
(
)
{
return
WeakReferenceSupport
:
:
AddRef
(
)
;
}
ULONG
Interceptor
:
:
Release
(
)
{
return
WeakReferenceSupport
:
:
Release
(
)
;
}
}
}
