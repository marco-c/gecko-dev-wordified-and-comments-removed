#
include
"
mozilla
/
mscom
/
EnsureMTA
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
mscom
/
COMWrappers
.
h
"
#
include
"
mozilla
/
mscom
/
ProcessRuntime
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
StaticLocalPtr
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
private
/
pprthred
.
h
"
namespace
{
class
EnterMTARunnable
:
public
mozilla
:
:
Runnable
{
public
:
EnterMTARunnable
(
)
:
mozilla
:
:
Runnable
(
"
EnterMTARunnable
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
mozilla
:
:
DebugOnly
<
HRESULT
>
hr
=
mozilla
:
:
mscom
:
:
wrapped
:
:
CoInitializeEx
(
nullptr
COINIT_MULTITHREADED
)
;
MOZ_ASSERT
(
SUCCEEDED
(
hr
)
)
;
return
NS_OK
;
}
}
;
class
BackgroundMTAData
{
public
:
BackgroundMTAData
(
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
EnterMTARunnable
(
)
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
NS_NewNamedThread
(
"
COM
MTA
"
getter_AddRefs
(
mThread
)
runnable
.
forget
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
NS_NewNamedThread
failed
"
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
~
BackgroundMTAData
(
)
{
if
(
mThread
)
{
mThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
BackgroundMTAData
:
:
~
BackgroundMTAData
"
&
mozilla
:
:
mscom
:
:
wrapped
:
:
CoUninitialize
)
NS_DISPATCH_NORMAL
)
;
mThread
-
>
Shutdown
(
)
;
}
}
nsCOMPtr
<
nsIThread
>
GetThread
(
)
const
{
return
mThread
;
}
private
:
nsCOMPtr
<
nsIThread
>
mThread
;
}
;
}
namespace
mozilla
{
namespace
mscom
{
EnsureMTA
:
:
EnsureMTA
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
nsThreadManager
:
:
get
(
)
.
Init
(
)
;
CO_MTA_USAGE_COOKIE
mtaCookie
=
nullptr
;
HRESULT
hr
=
wrapped
:
:
CoIncrementMTAUsage
(
&
mtaCookie
)
;
if
(
SUCCEEDED
(
hr
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
Unused
<
<
GetPersistentMTAThread
(
)
;
}
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
EnsureMTA
:
:
EnsureMTA
(
)
"
[
]
(
)
{
MOZ_RELEASE_ASSERT
(
IsCurrentThreadExplicitMTA
(
)
)
;
}
)
)
;
SyncDispatchToPersistentThread
(
runnable
)
;
}
RefPtr
<
EnsureMTA
:
:
CreateInstanceAgileRefPromise
>
EnsureMTA
:
:
CreateInstanceInternal
(
REFCLSID
aClsid
REFIID
aIid
)
{
MOZ_ASSERT
(
IsCurrentThreadExplicitMTA
(
)
)
;
RefPtr
<
IUnknown
>
iface
;
HRESULT
hr
=
wrapped
:
:
CoCreateInstance
(
aClsid
nullptr
CLSCTX_INPROC_SERVER
aIid
getter_AddRefs
(
iface
)
)
;
if
(
FAILED
(
hr
)
)
{
return
CreateInstanceAgileRefPromise
:
:
CreateAndReject
(
hr
__func__
)
;
}
AgileReference
agileRef
(
aIid
iface
)
;
if
(
!
agileRef
)
{
return
CreateInstanceAgileRefPromise
:
:
CreateAndReject
(
agileRef
.
GetHResult
(
)
__func__
)
;
}
return
CreateInstanceAgileRefPromise
:
:
CreateAndResolve
(
std
:
:
move
(
agileRef
)
__func__
)
;
}
RefPtr
<
EnsureMTA
:
:
CreateInstanceAgileRefPromise
>
EnsureMTA
:
:
CreateInstance
(
REFCLSID
aClsid
REFIID
aIid
)
{
MOZ_ASSERT
(
IsCOMInitializedOnCurrentThread
(
)
)
;
const
bool
isClassOk
=
IsClassThreadAwareInprocServer
(
aClsid
)
;
MOZ_ASSERT
(
isClassOk
"
mozilla
:
:
mscom
:
:
EnsureMTA
:
:
CreateInstance
is
not
"
"
safe
/
performant
/
necessary
to
use
with
this
CLSID
.
This
CLSID
"
"
either
does
not
support
creation
from
within
a
multithreaded
"
"
apartment
or
it
is
not
an
in
-
process
server
.
"
)
;
if
(
!
isClassOk
)
{
return
CreateInstanceAgileRefPromise
:
:
CreateAndReject
(
CO_E_NOT_SUPPORTED
__func__
)
;
}
if
(
IsCurrentThreadExplicitMTA
(
)
)
{
return
CreateInstanceInternal
(
aClsid
aIid
)
;
}
CLSID
localClsid
=
aClsid
;
IID
localIid
=
aIid
;
auto
invoker
=
[
localClsid
localIid
]
(
)
-
>
RefPtr
<
CreateInstanceAgileRefPromise
>
{
return
CreateInstanceInternal
(
localClsid
localIid
)
;
}
;
nsCOMPtr
<
nsIThread
>
mtaThread
(
GetPersistentMTAThread
(
)
)
;
return
InvokeAsync
(
mtaThread
__func__
std
:
:
move
(
invoker
)
)
;
}
nsCOMPtr
<
nsIThread
>
EnsureMTA
:
:
GetPersistentMTAThread
(
)
{
static
StaticLocalAutoPtr
<
BackgroundMTAData
>
sMTAData
(
[
]
(
)
-
>
BackgroundMTAData
*
{
BackgroundMTAData
*
bgData
=
new
BackgroundMTAData
(
)
;
auto
setClearOnShutdown
=
[
ptr
=
&
sMTAData
]
(
)
-
>
void
{
ClearOnShutdown
(
ptr
ShutdownPhase
:
:
XPCOMShutdownThreads
)
;
}
;
if
(
NS_IsMainThread
(
)
)
{
setClearOnShutdown
(
)
;
return
bgData
;
}
SchedulerGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
NS_NewRunnableFunction
(
"
mscom
:
:
EnsureMTA
:
:
GetPersistentMTAThread
"
std
:
:
move
(
setClearOnShutdown
)
)
)
;
return
bgData
;
}
(
)
)
;
MOZ_ASSERT
(
sMTAData
)
;
return
sMTAData
-
>
GetThread
(
)
;
}
void
EnsureMTA
:
:
SyncDispatchToPersistentThread
(
nsIRunnable
*
aRunnable
)
{
nsCOMPtr
<
nsIThread
>
thread
(
GetPersistentMTAThread
(
)
)
;
MOZ_ASSERT
(
thread
)
;
if
(
!
thread
)
{
return
;
}
nsAutoHandle
event
(
:
:
CreateEventW
(
nullptr
FALSE
FALSE
nullptr
)
)
;
if
(
!
event
)
{
return
;
}
HANDLE
eventHandle
=
event
.
get
(
)
;
auto
eventSetter
=
[
&
aRunnable
eventHandle
]
(
)
-
>
void
{
aRunnable
-
>
Run
(
)
;
:
:
SetEvent
(
eventHandle
)
;
}
;
nsresult
rv
=
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
mscom
:
:
EnsureMTA
:
:
SyncDispatchToPersistentThread
"
std
:
:
move
(
eventSetter
)
)
NS_DISPATCH_NORMAL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
AUTO_PROFILER_THREAD_SLEEP
;
DWORD
waitResult
;
while
(
(
waitResult
=
:
:
WaitForSingleObjectEx
(
event
INFINITE
FALSE
)
)
=
=
WAIT_IO_COMPLETION
)
{
}
MOZ_ASSERT
(
waitResult
=
=
WAIT_OBJECT_0
)
;
}
void
EnsureMTA
:
:
SyncDispatch
(
nsCOMPtr
<
nsIRunnable
>
&
&
aRunnable
Option
aOpt
)
{
SyncDispatchToPersistentThread
(
aRunnable
)
;
}
}
}
