#
ifndef
mozilla_mscom_AgileReference_h
#
define
mozilla_mscom_AgileReference_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
<
objidl
.
h
>
namespace
mozilla
:
:
mscom
{
namespace
detail
{
HRESULT
AgileReference_CreateImpl
(
RefPtr
<
IAgileReference
>
&
REFIID
IUnknown
*
)
;
HRESULT
AgileReference_ResolveImpl
(
RefPtr
<
IAgileReference
>
const
&
REFIID
void
*
*
)
;
}
template
<
typename
InterfaceT
>
class
AgileReference
final
{
static_assert
(
std
:
:
is_base_of_v
<
IUnknown
InterfaceT
>
"
template
parameter
of
AgileReference
must
be
a
COM
interface
type
"
)
;
public
:
AgileReference
(
)
=
default
;
~
AgileReference
(
)
=
default
;
AgileReference
(
const
AgileReference
&
aOther
)
=
default
;
AgileReference
(
AgileReference
&
&
aOther
)
noexcept
=
default
;
AgileReference
&
operator
=
(
const
AgileReference
&
aOther
)
=
default
;
AgileReference
&
operator
=
(
AgileReference
&
&
aOther
)
noexcept
=
default
;
AgileReference
&
operator
=
(
std
:
:
nullptr_t
)
{
mAgileRef
=
nullptr
;
return
*
this
;
}
explicit
AgileReference
(
InterfaceT
*
aObject
)
{
HRESULT
const
hr
=
detail
:
:
AgileReference_CreateImpl
(
mAgileRef
__uuidof
(
InterfaceT
)
aObject
)
;
Unused
<
<
NS_WARN_IF
(
FAILED
(
hr
)
)
;
}
explicit
AgileReference
(
RefPtr
<
InterfaceT
>
const
&
aObject
)
:
AgileReference
(
aObject
.
get
(
)
)
{
}
static
Result
<
AgileReference
<
InterfaceT
>
HRESULT
>
Create
(
RefPtr
<
InterfaceT
>
const
&
aObject
)
{
AgileReference
ret
;
HRESULT
const
hr
=
detail
:
:
AgileReference_CreateImpl
(
ret
.
mAgileRef
__uuidof
(
InterfaceT
)
aObject
.
get
(
)
)
;
if
(
FAILED
(
hr
)
)
{
return
Err
(
hr
)
;
}
return
ret
;
}
explicit
operator
bool
(
)
const
{
return
!
!
mAgileRef
;
}
RefPtr
<
InterfaceT
>
Resolve
(
)
const
{
auto
res
=
ResolveAs
<
InterfaceT
>
(
)
;
if
(
res
.
isErr
(
)
)
return
nullptr
;
return
res
.
unwrap
(
)
;
}
template
<
typename
OtherInterface
=
InterfaceT
>
Result
<
RefPtr
<
OtherInterface
>
HRESULT
>
ResolveAs
(
)
const
{
RefPtr
<
OtherInterface
>
p
;
auto
const
hr
=
ResolveRaw
(
__uuidof
(
OtherInterface
)
getter_AddRefs
(
p
)
)
;
if
(
FAILED
(
hr
)
)
{
return
Err
(
hr
)
;
}
return
p
;
}
HRESULT
ResolveRaw
(
REFIID
aIid
void
*
*
aOutInterface
)
const
{
return
detail
:
:
AgileReference_ResolveImpl
(
mAgileRef
aIid
aOutInterface
)
;
}
private
:
RefPtr
<
IAgileReference
>
mAgileRef
;
}
;
template
<
typename
InterfaceT
>
inline
Result
<
AgileReference
<
InterfaceT
>
HRESULT
>
MakeAgileReference
(
RefPtr
<
InterfaceT
>
const
&
aObj
)
{
return
AgileReference
<
InterfaceT
>
:
:
Create
(
aObj
)
;
}
}
#
endif
