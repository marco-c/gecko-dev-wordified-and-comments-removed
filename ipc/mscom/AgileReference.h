#
ifndef
mozilla_mscom_AgileReference_h
#
define
mozilla_mscom_AgileReference_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
<
objidl
.
h
>
namespace
mozilla
:
:
mscom
{
class
AgileReference
final
{
public
:
AgileReference
(
)
;
template
<
typename
InterfaceT
>
explicit
AgileReference
(
RefPtr
<
InterfaceT
>
&
aObject
)
:
AgileReference
(
__uuidof
(
InterfaceT
)
aObject
)
{
}
AgileReference
(
REFIID
aIid
IUnknown
*
aObject
)
;
AgileReference
(
const
AgileReference
&
aOther
)
=
default
;
AgileReference
(
AgileReference
&
&
aOther
)
noexcept
;
~
AgileReference
(
)
;
explicit
operator
bool
(
)
const
{
return
!
!
mAgileRef
;
}
HRESULT
GetHResult
(
)
const
{
return
mHResult
;
}
template
<
typename
T
>
void
Assign
(
const
RefPtr
<
T
>
&
aOther
)
{
Assign
(
__uuidof
(
T
)
aOther
)
;
}
template
<
typename
T
>
AgileReference
&
operator
=
(
const
RefPtr
<
T
>
&
aOther
)
{
Assign
(
aOther
)
;
return
*
this
;
}
HRESULT
Resolve
(
REFIID
aIid
void
*
*
aOutInterface
)
const
;
AgileReference
&
operator
=
(
const
AgileReference
&
aOther
)
;
AgileReference
&
operator
=
(
AgileReference
&
&
aOther
)
noexcept
;
AgileReference
&
operator
=
(
decltype
(
nullptr
)
)
{
Clear
(
)
;
return
*
this
;
}
void
Clear
(
)
;
private
:
void
Assign
(
REFIID
aIid
IUnknown
*
aObject
)
;
void
AssignInternal
(
IUnknown
*
aObject
)
;
private
:
IID
mIid
;
RefPtr
<
IAgileReference
>
mAgileRef
;
HRESULT
mHResult
;
}
;
}
template
<
typename
T
>
RefPtr
<
T
>
:
:
RefPtr
(
const
mozilla
:
:
mscom
:
:
AgileReference
&
aAgileRef
)
:
mRawPtr
(
nullptr
)
{
(
*
this
)
=
aAgileRef
;
}
template
<
typename
T
>
RefPtr
<
T
>
&
RefPtr
<
T
>
:
:
operator
=
(
const
mozilla
:
:
mscom
:
:
AgileReference
&
aAgileRef
)
{
void
*
newRawPtr
;
if
(
FAILED
(
aAgileRef
.
Resolve
(
__uuidof
(
T
)
&
newRawPtr
)
)
)
{
newRawPtr
=
nullptr
;
}
assign_assuming_AddRef
(
static_cast
<
T
*
>
(
newRawPtr
)
)
;
return
*
this
;
}
#
endif
