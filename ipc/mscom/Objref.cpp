#
include
"
mozilla
/
mscom
/
Objref
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
mscom
/
Utils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
guiddef
.
h
>
#
include
<
objidl
.
h
>
namespace
{
#
pragma
pack
(
push
1
)
typedef
uint64_t
OID
;
typedef
uint64_t
OXID
;
typedef
GUID
IPID
;
struct
STDOBJREF
{
uint32_t
mFlags
;
uint32_t
mPublicRefs
;
OXID
mOxid
;
OID
mOid
;
IPID
mIpid
;
}
;
enum
STDOBJREF_FLAGS
{
SORF_PING
=
0
SORF_NOPING
=
0x1000
}
;
struct
DUALSTRINGARRAY
{
static
size_t
SizeFromNumEntries
(
const
uint16_t
aNumEntries
)
{
return
sizeof
(
mNumEntries
)
+
sizeof
(
mSecurityOffset
)
+
aNumEntries
*
sizeof
(
uint16_t
)
;
}
size_t
SizeOf
(
)
const
{
return
SizeFromNumEntries
(
mNumEntries
)
;
}
uint16_t
mNumEntries
;
uint16_t
mSecurityOffset
;
uint16_t
mStringArray
[
1
]
;
}
;
struct
OBJREF_STANDARD
{
size_t
SizeOf
(
)
const
{
return
sizeof
(
mStd
)
+
mResAddr
.
SizeOf
(
)
;
}
STDOBJREF
mStd
;
DUALSTRINGARRAY
mResAddr
;
}
;
struct
OBJREF_HANDLER
{
size_t
SizeOf
(
)
const
{
return
sizeof
(
mStd
)
+
sizeof
(
mClsid
)
+
mResAddr
.
SizeOf
(
)
;
}
STDOBJREF
mStd
;
CLSID
mClsid
;
DUALSTRINGARRAY
mResAddr
;
}
;
enum
OBJREF_FLAGS
{
OBJREF_TYPE_STANDARD
=
0x00000001UL
OBJREF_TYPE_HANDLER
=
0x00000002UL
OBJREF_TYPE_CUSTOM
=
0x00000004UL
OBJREF_TYPE_EXTENDED
=
0x00000008UL
}
;
struct
OBJREF
{
size_t
SizeOf
(
)
const
{
size_t
size
=
sizeof
(
mSignature
)
+
sizeof
(
mFlags
)
+
sizeof
(
mIid
)
;
switch
(
mFlags
)
{
case
OBJREF_TYPE_STANDARD
:
size
+
=
mObjRefStd
.
SizeOf
(
)
;
break
;
case
OBJREF_TYPE_HANDLER
:
size
+
=
mObjRefHandler
.
SizeOf
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
OBJREF
type
"
)
;
return
0
;
}
return
size
;
}
uint32_t
mSignature
;
uint32_t
mFlags
;
IID
mIid
;
union
{
OBJREF_STANDARD
mObjRefStd
;
OBJREF_HANDLER
mObjRefHandler
;
}
;
}
;
enum
OBJREF_SIGNATURES
{
OBJREF_SIGNATURE
=
0x574F454DUL
}
;
#
pragma
pack
(
pop
)
struct
ByteArrayDeleter
{
void
operator
(
)
(
void
*
aPtr
)
{
delete
[
]
reinterpret_cast
<
uint8_t
*
>
(
aPtr
)
;
}
}
;
template
<
typename
T
>
using
VarStructUniquePtr
=
mozilla
:
:
UniquePtr
<
T
ByteArrayDeleter
>
;
}
namespace
mozilla
{
namespace
mscom
{
bool
StripHandlerFromOBJREF
(
NotNull
<
IStream
*
>
aStream
)
{
LARGE_INTEGER
seekTo
;
seekTo
.
QuadPart
=
0
;
ULARGE_INTEGER
objrefPos
;
HRESULT
hr
=
aStream
-
>
Seek
(
seekTo
STREAM_SEEK_CUR
&
objrefPos
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
ULONG
bytesRead
;
uint32_t
signature
;
hr
=
aStream
-
>
Read
(
&
signature
sizeof
(
signature
)
&
bytesRead
)
;
if
(
FAILED
(
hr
)
|
|
bytesRead
!
=
sizeof
(
signature
)
|
|
signature
!
=
OBJREF_SIGNATURE
)
{
return
false
;
}
uint32_t
type
;
hr
=
aStream
-
>
Read
(
&
type
sizeof
(
type
)
&
bytesRead
)
;
if
(
FAILED
(
hr
)
|
|
bytesRead
!
=
sizeof
(
type
)
|
|
type
!
=
OBJREF_TYPE_HANDLER
)
{
return
true
;
}
IID
iid
;
hr
=
aStream
-
>
Read
(
&
iid
sizeof
(
iid
)
&
bytesRead
)
;
if
(
FAILED
(
hr
)
|
|
bytesRead
!
=
sizeof
(
iid
)
|
|
!
IsValidGUID
(
iid
)
)
{
return
false
;
}
seekTo
.
QuadPart
=
sizeof
(
STDOBJREF
)
+
sizeof
(
CLSID
)
;
hr
=
aStream
-
>
Seek
(
seekTo
STREAM_SEEK_CUR
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
hr
;
}
uint16_t
numEntries
;
hr
=
aStream
-
>
Read
(
&
numEntries
sizeof
(
numEntries
)
&
bytesRead
)
;
if
(
FAILED
(
hr
)
|
|
bytesRead
!
=
sizeof
(
numEntries
)
)
{
return
false
;
}
const
uint32_t
kMinDualStringArraySize
=
12
;
uint16_t
staticResAddrBuf
[
kMinDualStringArraySize
/
sizeof
(
uint16_t
)
]
;
size_t
resAddrSize
=
DUALSTRINGARRAY
:
:
SizeFromNumEntries
(
numEntries
)
;
DUALSTRINGARRAY
*
resAddr
;
VarStructUniquePtr
<
DUALSTRINGARRAY
>
dynamicResAddrBuf
;
if
(
resAddrSize
<
=
kMinDualStringArraySize
)
{
resAddr
=
reinterpret_cast
<
DUALSTRINGARRAY
*
>
(
staticResAddrBuf
)
;
}
else
{
dynamicResAddrBuf
.
reset
(
reinterpret_cast
<
DUALSTRINGARRAY
*
>
(
new
uint8_t
[
resAddrSize
]
)
)
;
resAddr
=
dynamicResAddrBuf
.
get
(
)
;
}
resAddr
-
>
mNumEntries
=
numEntries
;
ULONG
bytesToRead
=
resAddrSize
-
sizeof
(
numEntries
)
;
hr
=
aStream
-
>
Read
(
&
resAddr
-
>
mSecurityOffset
bytesToRead
&
bytesRead
)
;
if
(
FAILED
(
hr
)
|
|
bytesRead
!
=
bytesToRead
)
{
return
false
;
}
seekTo
.
QuadPart
=
objrefPos
.
QuadPart
+
sizeof
(
signature
)
;
hr
=
aStream
-
>
Seek
(
seekTo
STREAM_SEEK_SET
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
ULONG
bytesWritten
;
uint32_t
newType
=
OBJREF_TYPE_STANDARD
;
hr
=
aStream
-
>
Write
(
&
newType
sizeof
(
newType
)
&
bytesWritten
)
;
if
(
FAILED
(
hr
)
|
|
bytesWritten
!
=
sizeof
(
newType
)
)
{
return
false
;
}
seekTo
.
QuadPart
=
sizeof
(
IID
)
+
sizeof
(
STDOBJREF
)
;
hr
=
aStream
-
>
Seek
(
seekTo
STREAM_SEEK_CUR
nullptr
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
hr
=
aStream
-
>
Write
(
resAddr
resAddrSize
&
bytesWritten
)
;
if
(
FAILED
(
hr
)
|
|
bytesWritten
!
=
resAddrSize
)
{
return
false
;
}
CLSID
zeroClsid
=
{
0
}
;
hr
=
aStream
-
>
Write
(
&
zeroClsid
sizeof
(
CLSID
)
&
bytesWritten
)
;
if
(
FAILED
(
hr
)
|
|
bytesWritten
!
=
sizeof
(
CLSID
)
)
{
return
false
;
}
return
true
;
}
}
}
