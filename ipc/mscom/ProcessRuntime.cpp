#
include
"
mozilla
/
mscom
/
ProcessRuntime
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DynamicallyLinkedFunctionPtr
.
h
"
#
include
"
mozilla
/
mscom
/
COMWrappers
.
h
"
#
include
"
mozilla
/
mscom
/
ProcessRuntimeShared
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
include
"
mozilla
/
mscom
/
EnsureMTA
.
h
"
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
sandboxTarget
.
h
"
#
endif
#
endif
#
include
<
accctrl
.
h
>
#
include
<
aclapi
.
h
>
#
include
<
objbase
.
h
>
#
include
<
objidl
.
h
>
extern
"
C
"
void
__cdecl
SetOaNoCache
(
void
)
;
using
namespace
mozilla
:
:
mscom
:
:
detail
;
namespace
mozilla
{
namespace
mscom
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
ProcessRuntime
*
ProcessRuntime
:
:
sInstance
=
nullptr
;
ProcessRuntime
:
:
ProcessRuntime
(
)
:
ProcessRuntime
(
XRE_GetProcessType
(
)
)
{
}
ProcessRuntime
:
:
ProcessRuntime
(
const
GeckoProcessType
aProcessType
)
:
ProcessRuntime
(
aProcessType
=
=
GeckoProcessType_Default
?
ProcessCategory
:
:
GeckoBrowserParent
:
ProcessCategory
:
:
GeckoChild
)
{
}
#
endif
ProcessRuntime
:
:
ProcessRuntime
(
const
ProcessCategory
aProcessCategory
)
:
mInitResult
(
CO_E_NOTINITIALIZED
)
mProcessCategory
(
aProcessCategory
)
{
#
if
defined
(
MOZILLA_INTERNAL_API
)
MOZ_DIAGNOSTIC_ASSERT
(
!
sInstance
)
;
sInstance
=
this
;
EnsureMTA
(
)
;
const
bool
isCurThreadImplicitMTA
=
IsCurrentThreadImplicitMTA
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aProcessCategory
=
=
ProcessCategory
:
:
GeckoBrowserParent
|
|
isCurThreadImplicitMTA
)
;
#
if
defined
(
MOZ_SANDBOX
)
const
bool
isLockedDownChildProcess
=
mProcessCategory
=
=
ProcessCategory
:
:
GeckoChild
&
&
IsWin32kLockedDown
(
)
;
if
(
isLockedDownChildProcess
)
{
HANDLE
rawCurThreadImpToken
;
if
(
!
:
:
OpenThreadToken
(
:
:
GetCurrentThread
(
)
TOKEN_DUPLICATE
|
TOKEN_QUERY
FALSE
&
rawCurThreadImpToken
)
)
{
mInitResult
=
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
return
;
}
nsAutoHandle
curThreadImpToken
(
rawCurThreadImpToken
)
;
DWORD
len
;
TOKEN_TYPE
tokenType
;
MOZ_RELEASE_ASSERT
(
:
:
GetTokenInformation
(
rawCurThreadImpToken
TokenType
&
tokenType
sizeof
(
tokenType
)
&
len
)
&
&
len
=
=
sizeof
(
tokenType
)
&
&
tokenType
=
=
TokenImpersonation
)
;
if
(
!
isCurThreadImplicitMTA
)
{
InitUsingPersistentMTAThread
(
curThreadImpToken
)
;
return
;
}
}
#
endif
#
endif
mAptRegion
.
Init
(
GetDesiredApartmentType
(
mProcessCategory
)
)
;
if
(
!
mAptRegion
.
IsValidOutermost
(
)
)
{
mInitResult
=
mAptRegion
.
GetHResult
(
)
;
#
if
defined
(
MOZILLA_INTERNAL_API
)
MOZ_ASSERT
(
mProcessCategory
=
=
ProcessCategory
:
:
GeckoBrowserParent
)
;
if
(
mProcessCategory
!
=
ProcessCategory
:
:
GeckoBrowserParent
)
{
return
;
}
ProcessInitLock
lock
;
const
bool
prevInit
=
lock
.
GetInitState
(
)
=
=
ProcessInitState
:
:
FullyInitialized
;
MOZ_ASSERT
(
prevInit
)
;
if
(
prevInit
)
{
PostInit
(
)
;
}
#
endif
return
;
}
InitInsideApartment
(
)
;
if
(
FAILED
(
mInitResult
)
)
{
return
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
#
if
defined
(
MOZ_SANDBOX
)
if
(
isLockedDownChildProcess
)
{
SandboxTarget
:
:
Instance
(
)
-
>
RegisterSandboxStartCallback
(
[
self
=
this
]
(
)
{
if
(
self
=
=
sInstance
&
&
SUCCEEDED
(
self
-
>
mInitResult
)
)
{
PostInit
(
)
;
}
}
)
;
return
;
}
#
endif
PostInit
(
)
;
#
endif
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
ProcessRuntime
:
:
~
ProcessRuntime
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
=
=
this
)
;
sInstance
=
nullptr
;
}
#
if
defined
(
MOZ_SANDBOX
)
void
ProcessRuntime
:
:
InitUsingPersistentMTAThread
(
const
nsAutoHandle
&
aCurThreadToken
)
{
HANDLE
rawMtaThreadImpToken
=
nullptr
;
if
(
!
:
:
DuplicateToken
(
aCurThreadToken
SecurityImpersonation
&
rawMtaThreadImpToken
)
)
{
mInitResult
=
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
return
;
}
nsAutoHandle
mtaThreadImpToken
(
rawMtaThreadImpToken
)
;
bool
tokenSet
=
false
;
EnsureMTA
(
[
this
rawMtaThreadImpToken
&
tokenSet
]
(
)
-
>
void
{
if
(
!
:
:
SetThreadToken
(
nullptr
rawMtaThreadImpToken
)
)
{
mInitResult
=
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
return
;
}
tokenSet
=
true
;
InitInsideApartment
(
)
;
}
EnsureMTA
:
:
Option
:
:
ForceDispatchToPersistentThread
)
;
if
(
!
tokenSet
)
{
return
;
}
SandboxTarget
:
:
Instance
(
)
-
>
RegisterSandboxStartCallback
(
[
self
=
this
]
(
)
-
>
void
{
EnsureMTA
(
[
]
(
)
-
>
void
{
MOZ_RELEASE_ASSERT
(
:
:
RevertToSelf
(
)
"
mscom
:
:
ProcessRuntime
RevertToSelf
failed
"
)
;
}
EnsureMTA
:
:
Option
:
:
ForceDispatchToPersistentThread
)
;
if
(
self
=
=
sInstance
&
&
SUCCEEDED
(
self
-
>
mInitResult
)
)
{
PostInit
(
)
;
}
}
)
;
}
#
endif
#
endif
COINIT
ProcessRuntime
:
:
GetDesiredApartmentType
(
const
ProcessRuntime
:
:
ProcessCategory
aProcessCategory
)
{
switch
(
aProcessCategory
)
{
case
ProcessCategory
:
:
GeckoBrowserParent
:
return
COINIT_APARTMENTTHREADED
;
case
ProcessCategory
:
:
GeckoChild
:
if
(
!
IsWin32kLockedDown
(
)
)
{
return
static_cast
<
COINIT
>
(
COINIT_APARTMENTTHREADED
|
COINIT_DISABLE_OLE1DDE
)
;
}
[
[
fallthrough
]
]
;
default
:
return
COINIT_MULTITHREADED
;
}
}
void
ProcessRuntime
:
:
InitInsideApartment
(
)
{
ProcessInitLock
lock
;
const
ProcessInitState
prevInitState
=
lock
.
GetInitState
(
)
;
if
(
prevInitState
=
=
ProcessInitState
:
:
FullyInitialized
)
{
mInitResult
=
S_OK
;
return
;
}
if
(
prevInitState
<
ProcessInitState
:
:
PartialSecurityInitialized
)
{
mInitResult
=
InitializeSecurity
(
mProcessCategory
)
;
MOZ_DIAGNOSTIC_ASSERT
(
SUCCEEDED
(
mInitResult
)
)
;
if
(
FAILED
(
mInitResult
)
&
&
mInitResult
!
=
RPC_E_TOO_LATE
)
{
return
;
}
lock
.
SetInitState
(
ProcessInitState
:
:
PartialSecurityInitialized
)
;
}
if
(
prevInitState
<
ProcessInitState
:
:
PartialGlobalOptions
)
{
RefPtr
<
IGlobalOptions
>
globalOpts
;
mInitResult
=
wrapped
:
:
CoCreateInstance
(
CLSID_GlobalOptions
nullptr
CLSCTX_INPROC_SERVER
IID_IGlobalOptions
getter_AddRefs
(
globalOpts
)
)
;
MOZ_ASSERT
(
SUCCEEDED
(
mInitResult
)
)
;
if
(
FAILED
(
mInitResult
)
)
{
return
;
}
mInitResult
=
globalOpts
-
>
Set
(
COMGLB_EXCEPTION_HANDLING
COMGLB_EXCEPTION_DONOT_HANDLE_ANY
)
;
MOZ_ASSERT
(
SUCCEEDED
(
mInitResult
)
)
;
if
(
FAILED
(
mInitResult
)
)
{
return
;
}
lock
.
SetInitState
(
ProcessInitState
:
:
PartialGlobalOptions
)
;
}
:
:
SetOaNoCache
(
)
;
lock
.
SetInitState
(
ProcessInitState
:
:
FullyInitialized
)
;
}
#
if
defined
(
MOZILLA_INTERNAL_API
)
void
ProcessRuntime
:
:
PostInit
(
)
{
}
#
endif
DWORD
ProcessRuntime
:
:
GetClientThreadId
(
)
{
DWORD
callerTid
;
HRESULT
hr
=
:
:
CoGetCallerTID
(
&
callerTid
)
;
if
(
hr
!
=
S_FALSE
)
{
return
0
;
}
return
callerTid
;
}
HRESULT
ProcessRuntime
:
:
InitializeSecurity
(
const
ProcessCategory
aProcessCategory
)
{
HANDLE
rawToken
=
nullptr
;
BOOL
ok
=
:
:
OpenProcessToken
(
:
:
GetCurrentProcess
(
)
TOKEN_QUERY
&
rawToken
)
;
if
(
!
ok
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
nsAutoHandle
token
(
rawToken
)
;
DWORD
len
=
0
;
ok
=
:
:
GetTokenInformation
(
token
TokenUser
nullptr
len
&
len
)
;
DWORD
win32Error
=
:
:
GetLastError
(
)
;
if
(
!
ok
&
&
win32Error
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
return
HRESULT_FROM_WIN32
(
win32Error
)
;
}
auto
tokenUserBuf
=
MakeUnique
<
BYTE
[
]
>
(
len
)
;
TOKEN_USER
&
tokenUser
=
*
reinterpret_cast
<
TOKEN_USER
*
>
(
tokenUserBuf
.
get
(
)
)
;
ok
=
:
:
GetTokenInformation
(
token
TokenUser
tokenUserBuf
.
get
(
)
len
&
len
)
;
if
(
!
ok
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
len
=
0
;
ok
=
:
:
GetTokenInformation
(
token
TokenPrimaryGroup
nullptr
len
&
len
)
;
win32Error
=
:
:
GetLastError
(
)
;
if
(
!
ok
&
&
win32Error
!
=
ERROR_INSUFFICIENT_BUFFER
)
{
return
HRESULT_FROM_WIN32
(
win32Error
)
;
}
auto
tokenPrimaryGroupBuf
=
MakeUnique
<
BYTE
[
]
>
(
len
)
;
TOKEN_PRIMARY_GROUP
&
tokenPrimaryGroup
=
*
reinterpret_cast
<
TOKEN_PRIMARY_GROUP
*
>
(
tokenPrimaryGroupBuf
.
get
(
)
)
;
ok
=
:
:
GetTokenInformation
(
token
TokenPrimaryGroup
tokenPrimaryGroupBuf
.
get
(
)
len
&
len
)
;
if
(
!
ok
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
SECURITY_DESCRIPTOR
sd
;
if
(
!
:
:
InitializeSecurityDescriptor
(
&
sd
SECURITY_DESCRIPTOR_REVISION
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
BYTE
systemSid
[
SECURITY_MAX_SID_SIZE
]
;
DWORD
systemSidSize
=
sizeof
(
systemSid
)
;
if
(
!
:
:
CreateWellKnownSid
(
WinLocalSystemSid
nullptr
systemSid
&
systemSidSize
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
BYTE
adminSid
[
SECURITY_MAX_SID_SIZE
]
;
DWORD
adminSidSize
=
sizeof
(
adminSid
)
;
if
(
!
:
:
CreateWellKnownSid
(
WinBuiltinAdministratorsSid
nullptr
adminSid
&
adminSidSize
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
const
bool
appContainersSupported
=
IsWin8OrLater
(
)
;
const
bool
allowAllNonRestrictedAppContainers
=
aProcessCategory
=
=
ProcessCategory
:
:
GeckoBrowserParent
&
&
appContainersSupported
;
BYTE
appContainersSid
[
SECURITY_MAX_SID_SIZE
]
;
DWORD
appContainersSidSize
=
sizeof
(
appContainersSid
)
;
if
(
allowAllNonRestrictedAppContainers
)
{
if
(
!
:
:
CreateWellKnownSid
(
WinBuiltinAnyPackageSid
nullptr
appContainersSid
&
appContainersSidSize
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
}
UniquePtr
<
BYTE
[
]
>
tokenAppContainerInfBuf
;
if
(
appContainersSupported
)
{
len
=
0
;
:
:
GetTokenInformation
(
token
TokenAppContainerSid
nullptr
len
&
len
)
;
if
(
len
)
{
tokenAppContainerInfBuf
=
MakeUnique
<
BYTE
[
]
>
(
len
)
;
ok
=
:
:
GetTokenInformation
(
token
TokenAppContainerSid
tokenAppContainerInfBuf
.
get
(
)
len
&
len
)
;
if
(
!
ok
)
{
tokenAppContainerInfBuf
=
nullptr
;
}
}
}
const
size_t
kMaxInlineEntries
=
5
;
mozilla
:
:
Vector
<
EXPLICIT_ACCESS_W
kMaxInlineEntries
>
entries
;
Unused
<
<
entries
.
append
(
EXPLICIT_ACCESS_W
{
COM_RIGHTS_EXECUTE
GRANT_ACCESS
NO_INHERITANCE
{
nullptr
NO_MULTIPLE_TRUSTEE
TRUSTEE_IS_SID
TRUSTEE_IS_USER
reinterpret_cast
<
LPWSTR
>
(
systemSid
)
}
}
)
;
Unused
<
<
entries
.
append
(
EXPLICIT_ACCESS_W
{
COM_RIGHTS_EXECUTE
GRANT_ACCESS
NO_INHERITANCE
{
nullptr
NO_MULTIPLE_TRUSTEE
TRUSTEE_IS_SID
TRUSTEE_IS_WELL_KNOWN_GROUP
reinterpret_cast
<
LPWSTR
>
(
adminSid
)
}
}
)
;
Unused
<
<
entries
.
append
(
EXPLICIT_ACCESS_W
{
COM_RIGHTS_EXECUTE
GRANT_ACCESS
NO_INHERITANCE
{
nullptr
NO_MULTIPLE_TRUSTEE
TRUSTEE_IS_SID
TRUSTEE_IS_USER
reinterpret_cast
<
LPWSTR
>
(
tokenUser
.
User
.
Sid
)
}
}
)
;
if
(
allowAllNonRestrictedAppContainers
)
{
Unused
<
<
entries
.
append
(
EXPLICIT_ACCESS_W
{
COM_RIGHTS_EXECUTE
GRANT_ACCESS
NO_INHERITANCE
{
nullptr
NO_MULTIPLE_TRUSTEE
TRUSTEE_IS_SID
TRUSTEE_IS_WELL_KNOWN_GROUP
reinterpret_cast
<
LPWSTR
>
(
appContainersSid
)
}
}
)
;
}
if
(
tokenAppContainerInfBuf
)
{
TOKEN_APPCONTAINER_INFORMATION
&
tokenAppContainerInf
=
*
reinterpret_cast
<
TOKEN_APPCONTAINER_INFORMATION
*
>
(
tokenAppContainerInfBuf
.
get
(
)
)
;
if
(
tokenAppContainerInf
.
TokenAppContainer
)
{
Unused
<
<
entries
.
append
(
EXPLICIT_ACCESS_W
{
COM_RIGHTS_EXECUTE
GRANT_ACCESS
NO_INHERITANCE
{
nullptr
NO_MULTIPLE_TRUSTEE
TRUSTEE_IS_SID
TRUSTEE_IS_USER
reinterpret_cast
<
LPWSTR
>
(
tokenAppContainerInf
.
TokenAppContainer
)
}
}
)
;
}
}
PACL
rawDacl
=
nullptr
;
win32Error
=
:
:
SetEntriesInAclW
(
entries
.
length
(
)
entries
.
begin
(
)
nullptr
&
rawDacl
)
;
if
(
win32Error
!
=
ERROR_SUCCESS
)
{
return
HRESULT_FROM_WIN32
(
win32Error
)
;
}
UniquePtr
<
ACL
LocalFreeDeleter
>
dacl
(
rawDacl
)
;
if
(
!
:
:
SetSecurityDescriptorDacl
(
&
sd
TRUE
dacl
.
get
(
)
FALSE
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
if
(
!
:
:
SetSecurityDescriptorOwner
(
&
sd
tokenUser
.
User
.
Sid
FALSE
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
if
(
!
:
:
SetSecurityDescriptorGroup
(
&
sd
tokenPrimaryGroup
.
PrimaryGroup
FALSE
)
)
{
return
HRESULT_FROM_WIN32
(
:
:
GetLastError
(
)
)
;
}
return
wrapped
:
:
CoInitializeSecurity
(
&
sd
-
1
nullptr
nullptr
RPC_C_AUTHN_LEVEL_DEFAULT
RPC_C_IMP_LEVEL_IDENTIFY
nullptr
EOAC_NONE
nullptr
)
;
}
}
}
