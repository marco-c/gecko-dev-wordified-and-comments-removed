#
include
<
unistd
.
h
>
#
include
<
string
>
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
ProtocolUtils
.
h
"
using
namespace
std
;
using
base
:
:
ProcessHandle
;
namespace
mozilla
{
namespace
ipc
{
nsresult
CreateTransport
(
base
:
:
ProcessId
aProcIdOne
TransportDescriptor
*
aOne
TransportDescriptor
*
aTwo
)
{
wstring
id
=
IPC
:
:
Channel
:
:
GenerateVerifiedChannelID
(
std
:
:
wstring
(
)
)
;
Transport
t
(
id
Transport
:
:
MODE_SERVER
nullptr
)
;
int
fd1
=
t
.
GetFileDescriptor
(
)
;
int
fd2
dontcare
;
t
.
GetClientFileDescriptorMapping
(
&
fd2
&
dontcare
)
;
if
(
fd1
<
0
|
|
fd2
<
0
)
{
return
NS_ERROR_TRANSPORT_INIT
;
}
fd1
=
dup
(
fd1
)
;
fd2
=
dup
(
fd2
)
;
if
(
fd1
<
0
|
|
fd2
<
0
)
{
HANDLE_EINTR
(
close
(
fd1
)
)
;
HANDLE_EINTR
(
close
(
fd2
)
)
;
return
NS_ERROR_DUPLICATE_HANDLE
;
}
aOne
-
>
mFd
=
base
:
:
FileDescriptor
(
fd1
true
)
;
aTwo
-
>
mFd
=
base
:
:
FileDescriptor
(
fd2
true
)
;
return
NS_OK
;
}
UniquePtr
<
Transport
>
OpenDescriptor
(
const
TransportDescriptor
&
aTd
Transport
:
:
Mode
aMode
)
{
return
MakeUnique
<
Transport
>
(
aTd
.
mFd
.
fd
aMode
nullptr
)
;
}
UniquePtr
<
Transport
>
OpenDescriptor
(
const
FileDescriptor
&
aFd
Transport
:
:
Mode
aMode
)
{
auto
rawFD
=
aFd
.
ClonePlatformHandle
(
)
;
return
MakeUnique
<
Transport
>
(
rawFD
.
release
(
)
aMode
nullptr
)
;
}
TransportDescriptor
DuplicateDescriptor
(
const
TransportDescriptor
&
aTd
)
{
TransportDescriptor
result
=
aTd
;
result
.
mFd
.
fd
=
dup
(
aTd
.
mFd
.
fd
)
;
if
(
result
.
mFd
.
fd
=
=
-
1
)
{
AnnotateSystemError
(
)
;
}
MOZ_RELEASE_ASSERT
(
result
.
mFd
.
fd
!
=
-
1
"
DuplicateDescriptor
failed
"
)
;
return
result
;
}
void
CloseDescriptor
(
const
TransportDescriptor
&
aTd
)
{
close
(
aTd
.
mFd
.
fd
)
;
}
}
}
