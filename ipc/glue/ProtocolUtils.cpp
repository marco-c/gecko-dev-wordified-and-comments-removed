#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
task
.
h
"
#
ifdef
OS_POSIX
#
include
<
errno
.
h
>
#
endif
#
include
<
type_traits
>
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
#
include
"
mozilla
/
Tokenizer
.
h
"
#
endif
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
#
include
"
mozilla
/
sandboxTarget
.
h
"
#
endif
#
if
defined
(
XP_WIN
)
#
include
"
aclapi
.
h
"
#
include
"
sddl
.
h
"
#
endif
using
namespace
IPC
;
using
base
:
:
GetCurrentProcId
;
using
base
:
:
ProcessHandle
;
using
base
:
:
ProcessId
;
namespace
mozilla
{
#
if
defined
(
XP_WIN
)
MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE
(
ScopedLPTStr
std
:
:
remove_pointer_t
<
LPTSTR
>
:
:
LocalFree
)
MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE
(
ScopedPSecurityDescriptor
std
:
:
remove_pointer_t
<
PSECURITY_DESCRIPTOR
>
:
:
LocalFree
)
#
endif
namespace
ipc
{
IPCResult
IPCResult
:
:
Fail
(
NotNull
<
IProtocol
*
>
actor
const
char
*
where
const
char
*
why
)
{
nsPrintfCString
errorMsg
(
"
%
s
%
s
\
n
"
where
why
)
;
actor
-
>
GetIPCChannel
(
)
-
>
Listener
(
)
-
>
ProcessingError
(
HasResultCodes
:
:
MsgProcessingError
errorMsg
.
get
(
)
)
;
return
IPCResult
(
false
)
;
}
#
if
defined
(
XP_WIN
)
bool
DuplicateHandle
(
HANDLE
aSourceHandle
DWORD
aTargetProcessId
HANDLE
*
aTargetHandle
DWORD
aDesiredAccess
DWORD
aOptions
)
{
if
(
aTargetProcessId
=
=
base
:
:
GetCurrentProcId
(
)
)
{
return
!
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
aSourceHandle
:
:
GetCurrentProcess
(
)
aTargetHandle
aDesiredAccess
false
aOptions
)
;
}
#
if
defined
(
MOZ_SANDBOX
)
if
(
SandboxTarget
:
:
Instance
(
)
-
>
BrokerDuplicateHandle
(
aSourceHandle
aTargetProcessId
aTargetHandle
aDesiredAccess
aOptions
)
)
{
return
true
;
}
#
endif
ScopedProcessHandle
targetProcess
(
OpenProcess
(
PROCESS_DUP_HANDLE
FALSE
aTargetProcessId
)
)
;
if
(
!
targetProcess
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCTransportFailureReason
"
Failed
to
open
target
process
.
"
_ns
)
;
return
false
;
}
return
!
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
aSourceHandle
targetProcess
aTargetHandle
aDesiredAccess
FALSE
aOptions
)
;
}
#
endif
void
AnnotateSystemError
(
)
{
int64_t
error
=
0
;
#
if
defined
(
XP_WIN
)
error
=
:
:
GetLastError
(
)
;
#
elif
defined
(
OS_POSIX
)
error
=
errno
;
#
endif
if
(
error
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCSystemError
nsPrintfCString
(
"
%
"
PRId64
error
)
)
;
}
}
#
if
defined
(
XP_MACOSX
)
void
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
tag
int
error
)
{
CrashReporter
:
:
AnnotateCrashReport
(
tag
error
)
;
}
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
const
char
*
aFilter
)
{
if
(
!
aFilter
)
{
return
false
;
}
if
(
strcmp
(
aFilter
"
1
"
)
=
=
0
)
{
return
true
;
}
const
char
kDelimiters
[
]
=
"
"
;
Tokenizer
tokens
(
aFilter
kDelimiters
)
;
Tokenizer
:
:
Token
t
;
while
(
tokens
.
Next
(
t
)
)
{
if
(
t
.
Type
(
)
=
=
Tokenizer
:
:
TOKEN_WORD
&
&
t
.
AsString
(
)
=
=
aTopLevelProtocol
)
{
return
true
;
}
}
return
false
;
}
#
endif
void
LogMessageForProtocol
(
const
char
*
aTopLevelProtocol
base
:
:
ProcessId
aOtherPid
const
char
*
aContextDescription
uint32_t
aMessageId
MessageDirection
aDirection
)
{
nsPrintfCString
logMessage
(
"
[
time
:
%
"
PRId64
"
]
[
%
d
%
s
%
d
]
[
%
s
]
%
s
%
s
\
n
"
PR_Now
(
)
base
:
:
GetCurrentProcId
(
)
aDirection
=
=
MessageDirection
:
:
eReceiving
?
"
<
-
"
:
"
-
>
"
aOtherPid
aTopLevelProtocol
aContextDescription
StringFromIPCMessageType
(
aMessageId
)
)
;
#
ifdef
ANDROID
__android_log_write
(
ANDROID_LOG_INFO
"
GeckoIPC
"
logMessage
.
get
(
)
)
;
#
endif
fputs
(
logMessage
.
get
(
)
stderr
)
;
}
void
ProtocolErrorBreakpoint
(
const
char
*
aMsg
)
{
printf_stderr
(
"
IPDL
protocol
error
:
%
s
\
n
"
aMsg
)
;
}
void
FatalError
(
const
char
*
aMsg
bool
aIsParent
)
{
#
ifndef
FUZZING
ProtocolErrorBreakpoint
(
aMsg
)
;
#
endif
nsAutoCString
formattedMessage
(
"
IPDL
error
:
\
"
"
)
;
formattedMessage
.
AppendASCII
(
aMsg
)
;
if
(
aIsParent
)
{
formattedMessage
.
AppendLiteral
(
"
\
"
.
Intentionally
crashing
.
"
)
;
NS_ERROR
(
formattedMessage
.
get
(
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCFatalErrorMsg
nsDependentCString
(
aMsg
)
)
;
AnnotateSystemError
(
)
;
#
ifndef
FUZZING
MOZ_CRASH
(
"
IPC
FatalError
in
the
parent
process
!
"
)
;
#
endif
}
else
{
formattedMessage
.
AppendLiteral
(
"
\
"
.
abort
(
)
ing
as
a
result
.
"
)
;
#
ifndef
FUZZING
MOZ_CRASH_UNSAFE
(
formattedMessage
.
get
(
)
)
;
#
endif
}
}
void
LogicError
(
const
char
*
aMsg
)
{
MOZ_CRASH_UNSAFE
(
aMsg
)
;
}
void
ActorIdReadError
(
const
char
*
aActorDescription
)
{
#
ifndef
FUZZING
MOZ_CRASH_UNSAFE_PRINTF
(
"
Error
deserializing
id
for
%
s
"
aActorDescription
)
;
#
endif
}
void
BadActorIdError
(
const
char
*
aActorDescription
)
{
nsPrintfCString
message
(
"
bad
id
for
%
s
"
aActorDescription
)
;
ProtocolErrorBreakpoint
(
message
.
get
(
)
)
;
}
void
ActorLookupError
(
const
char
*
aActorDescription
)
{
nsPrintfCString
message
(
"
could
not
lookup
id
for
%
s
"
aActorDescription
)
;
ProtocolErrorBreakpoint
(
message
.
get
(
)
)
;
}
void
MismatchedActorTypeError
(
const
char
*
aActorDescription
)
{
nsPrintfCString
message
(
"
actor
that
should
be
of
type
%
s
has
different
type
"
aActorDescription
)
;
ProtocolErrorBreakpoint
(
message
.
get
(
)
)
;
}
void
UnionTypeReadError
(
const
char
*
aUnionName
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
error
deserializing
type
of
union
%
s
"
aUnionName
)
;
}
void
ArrayLengthReadError
(
const
char
*
aElementName
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
error
deserializing
length
of
%
s
[
]
"
aElementName
)
;
}
void
SentinelReadError
(
const
char
*
aClassName
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
incorrect
sentinel
when
reading
%
s
"
aClassName
)
;
}
void
TableToArray
(
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
&
aTable
nsTArray
<
void
*
>
&
aArray
)
{
uint32_t
i
=
0
;
void
*
*
elements
=
aArray
.
AppendElements
(
aTable
.
Count
(
)
)
;
for
(
auto
iter
=
aTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
elements
[
i
]
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
+
+
i
;
}
}
ActorLifecycleProxy
:
:
ActorLifecycleProxy
(
IProtocol
*
aActor
)
:
mActor
(
aActor
)
{
MOZ_ASSERT
(
mActor
)
;
MOZ_ASSERT
(
mActor
-
>
CanSend
(
)
"
Cannot
create
LifecycleProxy
for
non
-
connected
actor
!
"
)
;
if
(
mActor
-
>
mManager
)
{
mManager
=
mActor
-
>
mManager
-
>
mLifecycleProxy
;
}
mActor
-
>
ActorAlloc
(
)
;
}
ActorLifecycleProxy
:
:
~
ActorLifecycleProxy
(
)
{
if
(
!
mActor
)
{
return
;
}
MOZ_ASSERT
(
mActor
-
>
mLinkStatus
=
=
LinkStatus
:
:
Destroyed
"
Deallocating
non
-
destroyed
actor
!
"
)
;
mActor
-
>
mLifecycleProxy
=
nullptr
;
mActor
-
>
mLinkStatus
=
LinkStatus
:
:
Inactive
;
mActor
-
>
ActorDealloc
(
)
;
mActor
=
nullptr
;
}
IProtocol
:
:
~
IProtocol
(
)
{
if
(
mLifecycleProxy
)
{
NS_WARNING
(
"
Actor
destructor
called
before
IPC
lifecycle
complete
!
\
n
"
"
References
to
this
actor
may
unexpectedly
dangle
!
"
)
;
mLifecycleProxy
-
>
mActor
=
nullptr
;
MOZ_ASSERT
(
mLinkStatus
!
=
LinkStatus
:
:
Inactive
)
;
if
(
mLinkStatus
!
=
LinkStatus
:
:
Destroyed
)
{
NS_IF_RELEASE
(
mLifecycleProxy
)
;
}
mLifecycleProxy
=
nullptr
;
}
}
int32_t
IProtocol
:
:
Register
(
IProtocol
*
aRouted
)
{
return
mToplevel
-
>
Register
(
aRouted
)
;
}
int32_t
IProtocol
:
:
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
{
return
mToplevel
-
>
RegisterID
(
aRouted
aId
)
;
}
IProtocol
*
IProtocol
:
:
Lookup
(
int32_t
aId
)
{
return
mToplevel
-
>
Lookup
(
aId
)
;
}
void
IProtocol
:
:
Unregister
(
int32_t
aId
)
{
if
(
aId
=
=
mId
)
{
mId
=
kFreedActorId
;
}
return
mToplevel
-
>
Unregister
(
aId
)
;
}
Shmem
:
:
SharedMemory
*
IProtocol
:
:
CreateSharedMemory
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
bool
aUnsafe
int32_t
*
aId
)
{
return
mToplevel
-
>
CreateSharedMemory
(
aSize
aType
aUnsafe
aId
)
;
}
Shmem
:
:
SharedMemory
*
IProtocol
:
:
LookupSharedMemory
(
int32_t
aId
)
{
return
mToplevel
-
>
LookupSharedMemory
(
aId
)
;
}
bool
IProtocol
:
:
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
aSegment
)
{
return
mToplevel
-
>
IsTrackingSharedMemory
(
aSegment
)
;
}
bool
IProtocol
:
:
DestroySharedMemory
(
Shmem
&
aShmem
)
{
return
mToplevel
-
>
DestroySharedMemory
(
aShmem
)
;
}
MessageChannel
*
IProtocol
:
:
GetIPCChannel
(
)
{
return
mToplevel
-
>
GetIPCChannel
(
)
;
}
const
MessageChannel
*
IProtocol
:
:
GetIPCChannel
(
)
const
{
return
mToplevel
-
>
GetIPCChannel
(
)
;
}
void
IProtocol
:
:
SetEventTargetForActor
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
{
aActor
-
>
SetManager
(
this
)
;
mToplevel
-
>
SetEventTargetForActorInternal
(
aActor
aEventTarget
)
;
}
void
IProtocol
:
:
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
{
MOZ_ASSERT
(
aActor
-
>
Manager
(
)
)
;
mToplevel
-
>
ReplaceEventTargetForActor
(
aActor
aEventTarget
)
;
}
nsISerialEventTarget
*
IProtocol
:
:
GetActorEventTarget
(
)
{
RefPtr
<
nsISerialEventTarget
>
target
=
GetActorEventTarget
(
this
)
;
return
target
;
}
already_AddRefed
<
nsISerialEventTarget
>
IProtocol
:
:
GetActorEventTarget
(
IProtocol
*
aActor
)
{
return
mToplevel
-
>
GetActorEventTarget
(
aActor
)
;
}
ProcessId
IProtocol
:
:
OtherPid
(
)
const
{
return
mToplevel
-
>
OtherPid
(
)
;
}
void
IProtocol
:
:
SetId
(
int32_t
aId
)
{
MOZ_ASSERT
(
mId
=
=
aId
|
|
mLinkStatus
=
=
LinkStatus
:
:
Inactive
)
;
mId
=
aId
;
}
Maybe
<
IProtocol
*
>
IProtocol
:
:
ReadActor
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIter
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
{
int32_t
id
;
if
(
!
IPC
:
:
ReadParam
(
aMessage
aIter
&
id
)
)
{
ActorIdReadError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
if
(
id
=
=
1
|
|
(
id
=
=
0
&
&
!
aNullable
)
)
{
BadActorIdError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
if
(
id
=
=
0
)
{
return
Some
(
static_cast
<
IProtocol
*
>
(
nullptr
)
)
;
}
IProtocol
*
listener
=
this
-
>
Lookup
(
id
)
;
if
(
!
listener
)
{
ActorLookupError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
if
(
listener
-
>
GetProtocolId
(
)
!
=
aProtocolTypeId
)
{
MismatchedActorTypeError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
return
Some
(
listener
)
;
}
void
IProtocol
:
:
FatalError
(
const
char
*
const
aErrorMsg
)
const
{
HandleFatalError
(
aErrorMsg
)
;
}
void
IProtocol
:
:
HandleFatalError
(
const
char
*
aErrorMsg
)
const
{
if
(
IProtocol
*
manager
=
Manager
(
)
)
{
manager
-
>
HandleFatalError
(
aErrorMsg
)
;
return
;
}
mozilla
:
:
ipc
:
:
FatalError
(
aErrorMsg
mSide
=
=
ParentSide
)
;
}
bool
IProtocol
:
:
AllocShmem
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aOutMem
)
{
if
(
!
CanSend
(
)
)
{
NS_WARNING
(
"
Shmem
not
allocated
.
Cannot
communicate
with
the
other
actor
.
"
)
;
return
false
;
}
Shmem
:
:
id_t
id
;
Shmem
:
:
SharedMemory
*
rawmem
(
CreateSharedMemory
(
aSize
aType
false
&
id
)
)
;
if
(
!
rawmem
)
{
return
false
;
}
*
aOutMem
=
Shmem
(
Shmem
:
:
PrivateIPDLCaller
(
)
rawmem
id
)
;
return
true
;
}
bool
IProtocol
:
:
AllocUnsafeShmem
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aOutMem
)
{
if
(
!
CanSend
(
)
)
{
NS_WARNING
(
"
Shmem
not
allocated
.
Cannot
communicate
with
the
other
actor
.
"
)
;
return
false
;
}
Shmem
:
:
id_t
id
;
Shmem
:
:
SharedMemory
*
rawmem
(
CreateSharedMemory
(
aSize
aType
true
&
id
)
)
;
if
(
!
rawmem
)
{
return
false
;
}
*
aOutMem
=
Shmem
(
Shmem
:
:
PrivateIPDLCaller
(
)
rawmem
id
)
;
return
true
;
}
bool
IProtocol
:
:
DeallocShmem
(
Shmem
&
aMem
)
{
bool
ok
=
DestroySharedMemory
(
aMem
)
;
#
ifdef
DEBUG
if
(
!
ok
)
{
if
(
mSide
=
=
ChildSide
)
{
FatalError
(
"
bad
Shmem
"
)
;
}
else
{
NS_WARNING
(
"
bad
Shmem
"
)
;
}
return
false
;
}
#
endif
aMem
.
forget
(
Shmem
:
:
PrivateIPDLCaller
(
)
)
;
return
ok
;
}
void
IProtocol
:
:
SetManager
(
IProtocol
*
aManager
)
{
MOZ_RELEASE_ASSERT
(
!
mManager
|
|
mManager
=
=
aManager
)
;
mManager
=
aManager
;
mToplevel
=
aManager
-
>
mToplevel
;
}
void
IProtocol
:
:
SetManagerAndRegister
(
IProtocol
*
aManager
)
{
SetManager
(
aManager
)
;
aManager
-
>
Register
(
this
)
;
}
void
IProtocol
:
:
SetManagerAndRegister
(
IProtocol
*
aManager
int32_t
aId
)
{
SetManager
(
aManager
)
;
aManager
-
>
RegisterID
(
this
aId
)
;
}
bool
IProtocol
:
:
ChannelSend
(
IPC
:
:
Message
*
aMsg
)
{
UniquePtr
<
IPC
:
:
Message
>
msg
(
aMsg
)
;
if
(
CanSend
(
)
)
{
GetIPCChannel
(
)
-
>
Send
(
std
:
:
move
(
msg
)
)
;
return
true
;
}
NS_WARNING
(
"
IPC
message
discarded
:
actor
cannot
send
"
)
;
return
false
;
}
bool
IProtocol
:
:
ChannelSend
(
IPC
:
:
Message
*
aMsg
IPC
:
:
Message
*
aReply
)
{
UniquePtr
<
IPC
:
:
Message
>
msg
(
aMsg
)
;
if
(
CanSend
(
)
)
{
return
GetIPCChannel
(
)
-
>
Send
(
std
:
:
move
(
msg
)
aReply
)
;
}
NS_WARNING
(
"
IPC
message
discarded
:
actor
cannot
send
"
)
;
return
false
;
}
bool
IProtocol
:
:
ChannelCall
(
IPC
:
:
Message
*
aMsg
IPC
:
:
Message
*
aReply
)
{
UniquePtr
<
IPC
:
:
Message
>
msg
(
aMsg
)
;
if
(
CanSend
(
)
)
{
return
GetIPCChannel
(
)
-
>
Call
(
std
:
:
move
(
msg
)
aReply
)
;
}
NS_WARNING
(
"
IPC
message
discarded
:
actor
cannot
send
"
)
;
return
false
;
}
void
IProtocol
:
:
ActorConnected
(
)
{
if
(
mLinkStatus
!
=
LinkStatus
:
:
Inactive
)
{
return
;
}
mLinkStatus
=
LinkStatus
:
:
Connected
;
MOZ_ASSERT
(
!
mLifecycleProxy
"
double
-
connecting
live
actor
"
)
;
mLifecycleProxy
=
new
ActorLifecycleProxy
(
this
)
;
NS_ADDREF
(
mLifecycleProxy
)
;
}
void
IProtocol
:
:
DoomSubtree
(
)
{
MOZ_ASSERT
(
CanSend
(
)
"
dooming
non
-
connected
actor
"
)
;
MOZ_ASSERT
(
mLifecycleProxy
"
dooming
zombie
actor
"
)
;
nsTArray
<
RefPtr
<
ActorLifecycleProxy
>
>
managed
;
AllManagedActors
(
managed
)
;
for
(
ActorLifecycleProxy
*
proxy
:
managed
)
{
IProtocol
*
actor
=
proxy
-
>
Get
(
)
;
if
(
actor
&
&
actor
-
>
CanSend
(
)
)
{
actor
-
>
DoomSubtree
(
)
;
}
}
ActorDoom
(
)
;
mLinkStatus
=
LinkStatus
:
:
Doomed
;
}
void
IProtocol
:
:
DestroySubtree
(
ActorDestroyReason
aWhy
)
{
MOZ_ASSERT
(
CanRecv
(
)
"
destroying
non
-
connected
actor
"
)
;
MOZ_ASSERT
(
mLifecycleProxy
"
destroying
zombie
actor
"
)
;
if
(
Manager
(
)
)
{
Unregister
(
Id
(
)
)
;
}
ActorDestroyReason
subtreeWhy
=
aWhy
;
if
(
aWhy
=
=
Deletion
|
|
aWhy
=
=
FailedConstructor
)
{
subtreeWhy
=
AncestorDeletion
;
}
nsTArray
<
RefPtr
<
ActorLifecycleProxy
>
>
managed
;
AllManagedActors
(
managed
)
;
for
(
ActorLifecycleProxy
*
proxy
:
managed
)
{
IProtocol
*
actor
=
proxy
-
>
Get
(
)
;
if
(
actor
&
&
actor
-
>
CanRecv
(
)
)
{
actor
-
>
DestroySubtree
(
subtreeWhy
)
;
}
}
mLinkStatus
=
LinkStatus
:
:
Doomed
;
GetIPCChannel
(
)
-
>
RejectPendingResponsesForActor
(
this
)
;
ActorDestroy
(
aWhy
)
;
mLinkStatus
=
LinkStatus
:
:
Destroyed
;
}
IToplevelProtocol
:
:
IToplevelProtocol
(
const
char
*
aName
ProtocolId
aProtoId
Side
aSide
)
:
IProtocol
(
aProtoId
aSide
)
mOtherPid
(
mozilla
:
:
ipc
:
:
kInvalidProcessId
)
mLastLocalId
(
0
)
mEventTargetMutex
(
"
ProtocolEventTargetMutex
"
)
mChannel
(
aName
this
)
{
mToplevel
=
this
;
}
base
:
:
ProcessId
IToplevelProtocol
:
:
OtherPid
(
)
const
{
base
:
:
ProcessId
pid
=
OtherPidMaybeInvalid
(
)
;
MOZ_RELEASE_ASSERT
(
pid
!
=
kInvalidProcessId
)
;
return
pid
;
}
void
IToplevelProtocol
:
:
SetOtherProcessId
(
base
:
:
ProcessId
aOtherPid
)
{
mOtherPid
=
aOtherPid
;
}
bool
IToplevelProtocol
:
:
Open
(
UniquePtr
<
Transport
>
aTransport
base
:
:
ProcessId
aOtherPid
MessageLoop
*
aThread
mozilla
:
:
ipc
:
:
Side
aSide
)
{
SetOtherProcessId
(
aOtherPid
)
;
return
GetIPCChannel
(
)
-
>
Open
(
std
:
:
move
(
aTransport
)
aThread
aSide
)
;
}
bool
IToplevelProtocol
:
:
Open
(
MessageChannel
*
aChannel
nsISerialEventTarget
*
aEventTarget
mozilla
:
:
ipc
:
:
Side
aSide
)
{
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
return
GetIPCChannel
(
)
-
>
Open
(
aChannel
aEventTarget
aSide
)
;
}
bool
IToplevelProtocol
:
:
OpenOnSameThread
(
MessageChannel
*
aChannel
Side
aSide
)
{
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
return
GetIPCChannel
(
)
-
>
OpenOnSameThread
(
aChannel
aSide
)
;
}
void
IToplevelProtocol
:
:
NotifyImpendingShutdown
(
)
{
GetIPCChannel
(
)
-
>
NotifyImpendingShutdown
(
)
;
}
void
IToplevelProtocol
:
:
Close
(
)
{
GetIPCChannel
(
)
-
>
Close
(
)
;
}
void
IToplevelProtocol
:
:
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
{
GetIPCChannel
(
)
-
>
SetReplyTimeoutMs
(
aTimeoutMs
)
;
}
bool
IToplevelProtocol
:
:
IsOnCxxStack
(
)
const
{
return
GetIPCChannel
(
)
-
>
IsOnCxxStack
(
)
;
}
int32_t
IToplevelProtocol
:
:
NextId
(
)
{
int32_t
tag
=
0
;
if
(
GetSide
(
)
=
=
ParentSide
)
{
tag
|
=
1
<
<
1
;
}
MOZ_RELEASE_ASSERT
(
mLastLocalId
<
(
1
<
<
29
)
)
;
return
(
+
+
mLastLocalId
<
<
2
)
|
tag
;
}
int32_t
IToplevelProtocol
:
:
Register
(
IProtocol
*
aRouted
)
{
if
(
aRouted
-
>
Id
(
)
!
=
kNullActorId
&
&
aRouted
-
>
Id
(
)
!
=
kFreedActorId
)
{
return
aRouted
-
>
Id
(
)
;
}
int32_t
id
=
RegisterID
(
aRouted
NextId
(
)
)
;
if
(
IProtocol
*
manager
=
aRouted
-
>
Manager
(
)
)
{
MutexAutoLock
lock
(
mEventTargetMutex
)
;
if
(
nsCOMPtr
<
nsISerialEventTarget
>
target
=
mEventTargetMap
.
Get
(
manager
-
>
Id
(
)
)
)
{
MOZ_ASSERT
(
!
mEventTargetMap
.
Contains
(
id
)
"
Don
'
t
insert
with
an
existing
ID
"
)
;
mEventTargetMap
.
Put
(
id
target
)
;
}
}
return
id
;
}
int32_t
IToplevelProtocol
:
:
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
{
aRouted
-
>
SetId
(
aId
)
;
aRouted
-
>
ActorConnected
(
)
;
MOZ_ASSERT
(
!
mActorMap
.
Contains
(
aId
)
"
Don
'
t
insert
with
an
existing
ID
"
)
;
mActorMap
.
Put
(
aId
aRouted
)
;
return
aId
;
}
IProtocol
*
IToplevelProtocol
:
:
Lookup
(
int32_t
aId
)
{
return
mActorMap
.
Get
(
aId
)
;
}
void
IToplevelProtocol
:
:
Unregister
(
int32_t
aId
)
{
MOZ_ASSERT
(
mActorMap
.
Contains
(
aId
)
"
Attempting
to
remove
an
ID
not
in
the
actor
map
"
)
;
mActorMap
.
Remove
(
aId
)
;
MutexAutoLock
lock
(
mEventTargetMutex
)
;
mEventTargetMap
.
Remove
(
aId
)
;
}
Shmem
:
:
SharedMemory
*
IToplevelProtocol
:
:
CreateSharedMemory
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
bool
aUnsafe
Shmem
:
:
id_t
*
aId
)
{
RefPtr
<
Shmem
:
:
SharedMemory
>
segment
(
Shmem
:
:
Alloc
(
Shmem
:
:
PrivateIPDLCaller
(
)
aSize
aType
aUnsafe
)
)
;
if
(
!
segment
)
{
return
nullptr
;
}
int32_t
id
=
NextId
(
)
;
Shmem
shmem
(
Shmem
:
:
PrivateIPDLCaller
(
)
segment
.
get
(
)
id
)
;
base
:
:
ProcessId
pid
=
#
ifdef
ANDROID
OtherPidMaybeInvalid
(
)
;
#
else
OtherPid
(
)
;
#
endif
UniquePtr
<
Message
>
descriptor
=
shmem
.
ShareTo
(
Shmem
:
:
PrivateIPDLCaller
(
)
pid
MSG_ROUTING_CONTROL
)
;
if
(
!
descriptor
)
{
return
nullptr
;
}
Unused
<
<
GetIPCChannel
(
)
-
>
Send
(
std
:
:
move
(
descriptor
)
)
;
*
aId
=
shmem
.
Id
(
Shmem
:
:
PrivateIPDLCaller
(
)
)
;
Shmem
:
:
SharedMemory
*
rawSegment
=
segment
.
get
(
)
;
MOZ_ASSERT
(
!
mShmemMap
.
Contains
(
*
aId
)
"
Don
'
t
insert
with
an
existing
ID
"
)
;
mShmemMap
.
Put
(
*
aId
segment
.
forget
(
)
.
take
(
)
)
;
return
rawSegment
;
}
Shmem
:
:
SharedMemory
*
IToplevelProtocol
:
:
LookupSharedMemory
(
Shmem
:
:
id_t
aId
)
{
return
mShmemMap
.
Get
(
aId
)
;
}
bool
IToplevelProtocol
:
:
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
segment
)
{
for
(
const
auto
&
iter
:
mShmemMap
)
{
if
(
segment
=
=
iter
.
GetData
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
IToplevelProtocol
:
:
DestroySharedMemory
(
Shmem
&
shmem
)
{
Shmem
:
:
id_t
aId
=
shmem
.
Id
(
Shmem
:
:
PrivateIPDLCaller
(
)
)
;
Shmem
:
:
SharedMemory
*
segment
=
LookupSharedMemory
(
aId
)
;
if
(
!
segment
)
{
return
false
;
}
UniquePtr
<
Message
>
descriptor
=
shmem
.
UnshareFrom
(
Shmem
:
:
PrivateIPDLCaller
(
)
MSG_ROUTING_CONTROL
)
;
MOZ_ASSERT
(
mShmemMap
.
Contains
(
aId
)
"
Attempting
to
remove
an
ID
not
in
the
shmem
map
"
)
;
mShmemMap
.
Remove
(
aId
)
;
Shmem
:
:
Dealloc
(
Shmem
:
:
PrivateIPDLCaller
(
)
segment
)
;
MessageChannel
*
channel
=
GetIPCChannel
(
)
;
if
(
!
channel
-
>
CanSend
(
)
)
{
return
true
;
}
return
descriptor
&
&
channel
-
>
Send
(
std
:
:
move
(
descriptor
)
)
;
}
void
IToplevelProtocol
:
:
DeallocShmems
(
)
{
for
(
const
auto
&
cit
:
mShmemMap
)
{
Shmem
:
:
Dealloc
(
Shmem
:
:
PrivateIPDLCaller
(
)
cit
.
GetData
(
)
)
;
}
mShmemMap
.
Clear
(
)
;
}
bool
IToplevelProtocol
:
:
ShmemCreated
(
const
Message
&
aMsg
)
{
Shmem
:
:
id_t
id
;
RefPtr
<
Shmem
:
:
SharedMemory
>
rawmem
(
Shmem
:
:
OpenExisting
(
Shmem
:
:
PrivateIPDLCaller
(
)
aMsg
&
id
true
)
)
;
if
(
!
rawmem
)
{
return
false
;
}
MOZ_ASSERT
(
!
mShmemMap
.
Contains
(
id
)
"
Don
'
t
insert
with
an
existing
ID
"
)
;
mShmemMap
.
Put
(
id
rawmem
.
forget
(
)
.
take
(
)
)
;
return
true
;
}
bool
IToplevelProtocol
:
:
ShmemDestroyed
(
const
Message
&
aMsg
)
{
Shmem
:
:
id_t
id
;
PickleIterator
iter
=
PickleIterator
(
aMsg
)
;
if
(
!
IPC
:
:
ReadParam
(
&
aMsg
&
iter
&
id
)
)
{
return
false
;
}
aMsg
.
EndRead
(
iter
)
;
Shmem
:
:
SharedMemory
*
rawmem
=
LookupSharedMemory
(
id
)
;
if
(
rawmem
)
{
MOZ_ASSERT
(
mShmemMap
.
Contains
(
id
)
"
Attempting
to
remove
an
ID
not
in
the
shmem
map
"
)
;
mShmemMap
.
Remove
(
id
)
;
Shmem
:
:
Dealloc
(
Shmem
:
:
PrivateIPDLCaller
(
)
rawmem
)
;
}
return
true
;
}
already_AddRefed
<
nsISerialEventTarget
>
IToplevelProtocol
:
:
GetMessageEventTarget
(
const
Message
&
aMsg
)
{
int32_t
route
=
aMsg
.
routing_id
(
)
;
Maybe
<
MutexAutoLock
>
lock
;
lock
.
emplace
(
mEventTargetMutex
)
;
nsCOMPtr
<
nsISerialEventTarget
>
target
=
mEventTargetMap
.
Get
(
route
)
;
if
(
aMsg
.
is_constructor
(
)
)
{
ActorHandle
handle
;
PickleIterator
iter
=
PickleIterator
(
aMsg
)
;
if
(
!
IPC
:
:
ReadParam
(
&
aMsg
&
iter
&
handle
)
)
{
return
nullptr
;
}
#
ifdef
DEBUG
nsCOMPtr
<
nsISerialEventTarget
>
existingTgt
=
mEventTargetMap
.
Get
(
handle
.
mId
)
;
MOZ_ASSERT
(
existingTgt
=
=
target
|
|
existingTgt
=
=
nullptr
)
;
#
endif
mEventTargetMap
.
Put
(
handle
.
mId
target
)
;
}
return
target
.
forget
(
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
IToplevelProtocol
:
:
GetActorEventTarget
(
IProtocol
*
aActor
)
{
MOZ_RELEASE_ASSERT
(
aActor
-
>
Id
(
)
!
=
kNullActorId
&
&
aActor
-
>
Id
(
)
!
=
kFreedActorId
)
;
MutexAutoLock
lock
(
mEventTargetMutex
)
;
nsCOMPtr
<
nsISerialEventTarget
>
target
=
mEventTargetMap
.
Get
(
aActor
-
>
Id
(
)
)
;
return
target
.
forget
(
)
;
}
nsISerialEventTarget
*
IToplevelProtocol
:
:
GetActorEventTarget
(
)
{
return
nullptr
;
}
void
IToplevelProtocol
:
:
SetEventTargetForActorInternal
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
{
MOZ_RELEASE_ASSERT
(
aActor
!
=
this
)
;
MOZ_RELEASE_ASSERT
(
aActor
-
>
Id
(
)
=
=
kNullActorId
|
|
aActor
-
>
Id
(
)
=
=
kFreedActorId
)
;
MOZ_ASSERT
(
aActor
-
>
Manager
(
)
&
&
aActor
-
>
ToplevelProtocol
(
)
=
=
this
)
;
int32_t
id
=
Register
(
aActor
)
;
aActor
-
>
SetId
(
id
)
;
MutexAutoLock
lock
(
mEventTargetMutex
)
;
mEventTargetMap
.
Put
(
id
aEventTarget
)
;
}
void
IToplevelProtocol
:
:
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
{
MOZ_RELEASE_ASSERT
(
aActor
!
=
this
)
;
int32_t
id
=
aActor
-
>
Id
(
)
;
MOZ_RELEASE_ASSERT
(
id
!
=
kNullActorId
&
&
id
!
=
kFreedActorId
)
;
MutexAutoLock
lock
(
mEventTargetMutex
)
;
MOZ_ASSERT
(
mEventTargetMap
.
Contains
(
id
)
"
Only
replace
an
existing
ID
"
)
;
mEventTargetMap
.
Put
(
id
aEventTarget
)
;
}
}
}
