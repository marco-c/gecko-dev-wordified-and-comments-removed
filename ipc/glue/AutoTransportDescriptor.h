#
ifndef
mozilla_ipc_AutoTransportDescriptor_h
#
define
mozilla_ipc_AutoTransportDescriptor_h
#
include
<
utility
>
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
Result
.
h
"
namespace
mozilla
:
:
ipc
{
class
AutoTransportDescriptor
final
{
public
:
AutoTransportDescriptor
(
)
=
default
;
explicit
AutoTransportDescriptor
(
TransportDescriptor
aTransport
)
:
mTransport
(
aTransport
)
mValid
(
true
)
{
}
~
AutoTransportDescriptor
(
)
;
AutoTransportDescriptor
(
AutoTransportDescriptor
&
&
aOther
)
noexcept
;
AutoTransportDescriptor
&
operator
=
(
AutoTransportDescriptor
&
&
aOther
)
noexcept
;
static
Result
<
std
:
:
pair
<
AutoTransportDescriptor
AutoTransportDescriptor
>
nsresult
>
Create
(
)
;
AutoTransportDescriptor
Duplicate
(
)
const
;
UniquePtr
<
Transport
>
Open
(
Transport
:
:
Mode
aMode
)
;
explicit
operator
bool
(
)
const
{
return
mValid
;
}
private
:
friend
struct
IPC
:
:
ParamTraits
<
AutoTransportDescriptor
>
;
TransportDescriptor
mTransport
;
bool
mValid
=
false
;
}
;
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
AutoTransportDescriptor
>
{
using
paramType
=
mozilla
:
:
ipc
:
:
AutoTransportDescriptor
;
static
void
Write
(
Message
*
aMsg
paramType
&
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mValid
)
;
if
(
aParam
.
mValid
)
{
WriteParam
(
aMsg
aParam
.
mTransport
)
;
aParam
.
mValid
=
false
;
}
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
bool
valid
=
false
;
if
(
!
ReadParam
(
aMsg
aIter
&
valid
)
)
{
return
false
;
}
if
(
!
valid
)
{
*
aResult
=
mozilla
:
:
ipc
:
:
AutoTransportDescriptor
{
}
;
return
true
;
}
mozilla
:
:
ipc
:
:
TransportDescriptor
descr
;
if
(
!
ReadParam
(
aMsg
aIter
&
descr
)
)
{
return
false
;
}
*
aResult
=
mozilla
:
:
ipc
:
:
AutoTransportDescriptor
{
descr
}
;
return
true
;
}
}
;
}
#
endif
