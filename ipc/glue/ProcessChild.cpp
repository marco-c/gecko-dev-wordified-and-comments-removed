#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
Endpoint
.
h
"
#
include
"
nsDebug
.
h
"
#
ifdef
XP_WIN
#
include
<
stdlib
.
h
>
#
include
<
synchapi
.
h
>
#
else
#
include
<
unistd
.
h
>
#
include
<
time
.
h
>
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
prenv
.
h
"
#
endif
#
include
"
nsAppRunner
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ipc
/
IOThreadChild
.
h
"
#
include
"
mozilla
/
GeckoArgs
.
h
"
namespace
mozilla
{
namespace
ipc
{
ProcessChild
*
ProcessChild
:
:
gProcessChild
;
StaticMutex
ProcessChild
:
:
gIPCShutdownStateLock
;
nsCString
ProcessChild
:
:
gIPCShutdownStateAnnotation
;
static
Atomic
<
bool
>
sExpectingShutdown
(
false
)
;
ProcessChild
:
:
ProcessChild
(
IPC
:
:
Channel
:
:
ChannelHandle
aClientChannel
ProcessId
aParentPid
const
nsID
&
aMessageChannelId
)
:
ChildProcess
(
new
IOThreadChild
(
std
:
:
move
(
aClientChannel
)
aParentPid
)
)
mUILoop
(
MessageLoop
:
:
current
(
)
)
mParentPid
(
aParentPid
)
mMessageChannelId
(
aMessageChannelId
)
{
MOZ_ASSERT
(
mUILoop
"
UILoop
should
be
created
by
now
"
)
;
MOZ_ASSERT
(
!
gProcessChild
"
should
only
be
one
ProcessChild
"
)
;
CrashReporter
:
:
RegisterAnnotationNSCString
(
CrashReporter
:
:
Annotation
:
:
IPCShutdownState
&
gIPCShutdownStateAnnotation
)
;
gProcessChild
=
this
;
}
void
ProcessChild
:
:
AddPlatformBuildID
(
geckoargs
:
:
ChildProcessArgs
&
aExtraArgs
)
{
nsCString
parentBuildID
(
mozilla
:
:
PlatformBuildID
(
)
)
;
geckoargs
:
:
sParentBuildID
.
Put
(
parentBuildID
.
get
(
)
aExtraArgs
)
;
}
bool
ProcessChild
:
:
InitPrefs
(
int
aArgc
char
*
aArgv
[
]
)
{
Maybe
<
UniqueFileHandle
>
prefsHandle
=
geckoargs
:
:
sPrefsHandle
.
Get
(
aArgc
aArgv
)
;
Maybe
<
UniqueFileHandle
>
prefMapHandle
=
geckoargs
:
:
sPrefMapHandle
.
Get
(
aArgc
aArgv
)
;
Maybe
<
uint64_t
>
prefsLen
=
geckoargs
:
:
sPrefsLen
.
Get
(
aArgc
aArgv
)
;
Maybe
<
uint64_t
>
prefMapSize
=
geckoargs
:
:
sPrefMapSize
.
Get
(
aArgc
aArgv
)
;
if
(
prefsLen
.
isNothing
(
)
|
|
prefMapSize
.
isNothing
(
)
|
|
prefsHandle
.
isNothing
(
)
|
|
prefMapHandle
.
isNothing
(
)
)
{
return
false
;
}
SharedPreferenceDeserializer
deserializer
;
return
deserializer
.
DeserializeFromSharedMemory
(
std
:
:
move
(
*
prefsHandle
)
std
:
:
move
(
*
prefMapHandle
)
*
prefsLen
*
prefMapSize
)
;
}
#
ifdef
ENABLE_TESTS
#
ifdef
XP_UNIX
static
void
ReallySleep
(
int
aSeconds
)
{
struct
:
:
timespec
snooze
=
{
aSeconds
0
}
;
HANDLE_EINTR
(
nanosleep
(
&
snooze
&
snooze
)
)
;
}
#
else
static
void
ReallySleep
(
int
aSeconds
)
{
:
:
Sleep
(
aSeconds
*
1000
)
;
}
#
endif
static
void
SleepIfEnv
(
const
char
*
aName
)
{
if
(
auto
*
value
=
PR_GetEnv
(
aName
)
)
{
ReallySleep
(
atoi
(
value
)
)
;
}
}
#
else
static
void
SleepIfEnv
(
const
char
*
aName
)
{
}
#
endif
ProcessChild
:
:
~
ProcessChild
(
)
{
#
ifdef
NS_FREE_PERMANENT_DATA
SleepIfEnv
(
"
MOZ_TEST_CHILD_EXIT_HANG
"
)
;
#
endif
gIPCShutdownStateAnnotation
=
"
"
_ns
;
gProcessChild
=
nullptr
;
}
void
ProcessChild
:
:
NotifiedImpendingShutdown
(
)
{
sExpectingShutdown
=
true
;
ProcessChild
:
:
AppendToIPCShutdownStateAnnotation
(
"
NotifiedImpendingShutdown
"
_ns
)
;
}
bool
ProcessChild
:
:
ExpectingShutdown
(
)
{
return
sExpectingShutdown
;
}
void
ProcessChild
:
:
QuickExit
(
)
{
#
ifndef
NS_FREE_PERMANENT_DATA
SleepIfEnv
(
"
MOZ_TEST_CHILD_EXIT_HANG
"
)
;
#
endif
AppShutdown
:
:
DoImmediateExit
(
)
;
}
UntypedEndpoint
ProcessChild
:
:
TakeInitialEndpoint
(
)
{
return
UntypedEndpoint
{
PrivateIPDLInterface
{
}
child_thread
(
)
-
>
TakeInitialPort
(
)
mMessageChannelId
EndpointProcInfo
:
:
Current
(
)
EndpointProcInfo
{
.
mPid
=
mParentPid
.
mChildID
=
0
}
}
;
}
}
}
