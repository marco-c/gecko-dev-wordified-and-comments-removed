#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
Endpoint
.
h
"
#
include
"
nsDebug
.
h
"
#
ifdef
XP_WIN
#
include
<
stdlib
.
h
>
#
include
<
synchapi
.
h
>
#
else
#
include
<
unistd
.
h
>
#
include
<
time
.
h
>
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
prenv
.
h
"
#
endif
#
include
"
nsAppRunner
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
ipc
/
CrashReporterClient
.
h
"
#
include
"
mozilla
/
ipc
/
IOThreadChild
.
h
"
#
include
"
mozilla
/
GeckoArgs
.
h
"
namespace
mozilla
{
namespace
ipc
{
ProcessChild
*
ProcessChild
:
:
gProcessChild
;
static
Atomic
<
bool
>
sExpectingShutdown
(
false
)
;
ProcessChild
:
:
ProcessChild
(
ProcessId
aParentPid
const
nsID
&
aMessageChannelId
)
:
ChildProcess
(
new
IOThreadChild
(
)
)
mUILoop
(
MessageLoop
:
:
current
(
)
)
mParentPid
(
aParentPid
)
mMessageChannelId
(
aMessageChannelId
)
{
MOZ_ASSERT
(
mUILoop
"
UILoop
should
be
created
by
now
"
)
;
MOZ_ASSERT
(
!
gProcessChild
"
should
only
be
one
ProcessChild
"
)
;
gProcessChild
=
this
;
}
void
ProcessChild
:
:
AddPlatformBuildID
(
std
:
:
vector
<
std
:
:
string
>
&
aExtraArgs
)
{
nsCString
parentBuildID
(
mozilla
:
:
PlatformBuildID
(
)
)
;
geckoargs
:
:
sParentBuildID
.
Put
(
parentBuildID
.
get
(
)
aExtraArgs
)
;
}
bool
ProcessChild
:
:
InitPrefs
(
int
aArgc
char
*
aArgv
[
]
)
{
Maybe
<
uint64_t
>
prefsHandle
=
Some
(
0
)
;
Maybe
<
uint64_t
>
prefMapHandle
=
Some
(
0
)
;
Maybe
<
uint64_t
>
prefsLen
=
geckoargs
:
:
sPrefsLen
.
Get
(
aArgc
aArgv
)
;
Maybe
<
uint64_t
>
prefMapSize
=
geckoargs
:
:
sPrefMapSize
.
Get
(
aArgc
aArgv
)
;
if
(
prefsLen
.
isNothing
(
)
|
|
prefMapSize
.
isNothing
(
)
)
{
return
false
;
}
#
ifdef
XP_WIN
prefsHandle
=
geckoargs
:
:
sPrefsHandle
.
Get
(
aArgc
aArgv
)
;
prefMapHandle
=
geckoargs
:
:
sPrefMapHandle
.
Get
(
aArgc
aArgv
)
;
if
(
prefsHandle
.
isNothing
(
)
|
|
prefMapHandle
.
isNothing
(
)
)
{
return
false
;
}
#
endif
SharedPreferenceDeserializer
deserializer
;
return
deserializer
.
DeserializeFromSharedMemory
(
*
prefsHandle
*
prefMapHandle
*
prefsLen
*
prefMapSize
)
;
}
#
ifdef
ENABLE_TESTS
#
ifdef
XP_UNIX
static
void
ReallySleep
(
int
aSeconds
)
{
struct
:
:
timespec
snooze
=
{
aSeconds
0
}
;
HANDLE_EINTR
(
nanosleep
(
&
snooze
&
snooze
)
)
;
}
#
elif
defined
(
XP_WIN
)
static
void
ReallySleep
(
int
aSeconds
)
{
:
:
Sleep
(
aSeconds
*
1000
)
;
}
#
endif
static
void
SleepIfEnv
(
const
char
*
aName
)
{
if
(
auto
*
value
=
PR_GetEnv
(
aName
)
)
{
ReallySleep
(
atoi
(
value
)
)
;
}
}
#
else
static
void
SleepIfEnv
(
const
char
*
aName
)
{
}
#
endif
ProcessChild
:
:
~
ProcessChild
(
)
{
#
ifdef
NS_FREE_PERMANENT_DATA
SleepIfEnv
(
"
MOZ_TEST_CHILD_EXIT_HANG
"
)
;
#
endif
gProcessChild
=
nullptr
;
}
void
ProcessChild
:
:
NotifiedImpendingShutdown
(
)
{
sExpectingShutdown
=
true
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCShutdownState
"
NotifiedImpendingShutdown
"
_ns
)
;
}
bool
ProcessChild
:
:
ExpectingShutdown
(
)
{
return
sExpectingShutdown
;
}
void
ProcessChild
:
:
QuickExit
(
)
{
#
ifndef
NS_FREE_PERMANENT_DATA
SleepIfEnv
(
"
MOZ_TEST_CHILD_EXIT_HANG
"
)
;
#
endif
AppShutdown
:
:
DoImmediateExit
(
)
;
}
UntypedEndpoint
ProcessChild
:
:
TakeInitialEndpoint
(
)
{
return
UntypedEndpoint
{
PrivateIPDLInterface
{
}
child_thread
(
)
-
>
TakeInitialPort
(
)
mMessageChannelId
base
:
:
GetCurrentProcId
(
)
mParentPid
}
;
}
}
}
