#
ifndef
mozilla_ipc_FileDescriptor_h
#
define
mozilla_ipc_FileDescriptor_h
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
ipc
/
IPDLParamTraits
.
h
"
#
ifdef
XP_UNIX
#
include
"
base
/
file_descriptor_posix
.
h
"
#
endif
namespace
mozilla
{
namespace
ipc
{
class
FileDescriptor
{
public
:
typedef
base
:
:
ProcessId
ProcessId
;
using
UniquePlatformHandle
=
mozilla
:
:
UniqueFileHandle
;
using
PlatformHandleType
=
UniquePlatformHandle
:
:
ElementType
;
#
ifdef
XP_WIN
typedef
PlatformHandleType
PickleType
;
#
else
typedef
base
:
:
FileDescriptor
PickleType
;
#
endif
struct
IPDLPrivate
{
}
;
FileDescriptor
(
)
;
FileDescriptor
(
const
FileDescriptor
&
aOther
)
;
FileDescriptor
(
FileDescriptor
&
&
aOther
)
;
explicit
FileDescriptor
(
PlatformHandleType
aHandle
)
;
FileDescriptor
(
const
IPDLPrivate
&
const
PickleType
&
aPickle
)
;
~
FileDescriptor
(
)
;
FileDescriptor
&
operator
=
(
const
FileDescriptor
&
aOther
)
;
FileDescriptor
&
operator
=
(
FileDescriptor
&
&
aOther
)
;
PickleType
ShareTo
(
const
IPDLPrivate
&
ProcessId
aTargetPid
)
const
;
bool
IsValid
(
)
const
;
UniquePlatformHandle
ClonePlatformHandle
(
)
const
;
bool
operator
=
=
(
const
FileDescriptor
&
aOther
)
const
;
private
:
static
UniqueFileHandle
Clone
(
PlatformHandleType
aHandle
)
;
UniquePlatformHandle
mHandle
;
}
;
template
<
>
struct
IPDLParamTraits
<
FileDescriptor
>
{
typedef
FileDescriptor
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
;
}
;
}
}
#
endif
