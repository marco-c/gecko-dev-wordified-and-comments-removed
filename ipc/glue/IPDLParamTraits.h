#
ifndef
mozilla_ipc_IPDLParamTraits_h
#
define
mozilla_ipc_IPDLParamTraits_h
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
<
type_traits
>
namespace
mozilla
{
namespace
ipc
{
class
IProtocol
;
template
<
typename
P
>
struct
IPDLParamTraits
{
template
<
typename
R
>
static
inline
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
R
&
&
aParam
)
{
IPC
:
:
ParamTraits
<
P
>
:
:
Write
(
aMsg
std
:
:
forward
<
R
>
(
aParam
)
)
;
}
template
<
typename
R
>
static
inline
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
R
*
aResult
)
{
return
IPC
:
:
ParamTraits
<
P
>
:
:
Read
(
aMsg
aIter
aResult
)
;
}
}
;
template
<
typename
P
>
static
MOZ_NEVER_INLINE
void
WriteIPDLParam
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
P
&
&
aParam
)
{
IPDLParamTraits
<
typename
Decay
<
P
>
:
:
Type
>
:
:
Write
(
aMsg
aActor
std
:
:
forward
<
P
>
(
aParam
)
)
;
}
template
<
typename
P
>
static
MOZ_NEVER_INLINE
bool
ReadIPDLParam
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
P
*
aResult
)
{
return
IPDLParamTraits
<
P
>
:
:
Read
(
aMsg
aIter
aActor
aResult
)
;
}
template
<
typename
P
>
static
MOZ_NEVER_INLINE
bool
ReadIPDLParamInfallible
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
P
*
aResult
const
char
*
aCrashMessage
)
{
bool
ok
=
ReadIPDLParam
(
aMsg
aIter
aActor
aResult
)
;
if
(
!
ok
)
{
MOZ_CRASH_UNSAFE
(
aCrashMessage
)
;
}
return
ok
;
}
constexpr
void
WriteIPDLParamList
(
IPC
:
:
Message
*
IProtocol
*
)
{
}
template
<
typename
P
typename
.
.
.
Ps
>
static
void
WriteIPDLParamList
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
P
&
&
aParam
Ps
&
&
.
.
.
aParams
)
{
WriteIPDLParam
(
aMsg
aActor
std
:
:
forward
<
P
>
(
aParam
)
)
;
WriteIPDLParamList
(
aMsg
aActor
std
:
:
forward
<
Ps
>
(
aParams
)
.
.
.
)
;
}
constexpr
bool
ReadIPDLParamList
(
const
IPC
:
:
Message
*
PickleIterator
*
IProtocol
*
)
{
return
true
;
}
template
<
typename
P
typename
.
.
.
Ps
>
static
bool
ReadIPDLParamList
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
P
*
aResult
Ps
*
.
.
.
aResults
)
{
return
ReadIPDLParam
(
aMsg
aIter
aActor
aResult
)
&
&
ReadIPDLParamList
(
aMsg
aIter
aActor
aResults
.
.
.
)
;
}
template
<
typename
T
>
struct
IPDLParamTraits
<
RefPtr
<
T
>
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
RefPtr
<
T
>
&
aParam
)
{
IPDLParamTraits
<
T
*
>
:
:
Write
(
aMsg
aActor
aParam
.
get
(
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
RefPtr
<
T
>
*
aResult
)
{
return
IPDLParamTraits
<
T
*
>
:
:
Read
(
aMsg
aIter
aActor
aResult
)
;
}
}
;
template
<
typename
T
>
struct
IPDLParamTraits
<
nsCOMPtr
<
T
>
>
{
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
nsCOMPtr
<
T
>
&
aParam
)
{
IPDLParamTraits
<
T
*
>
:
:
Write
(
aMsg
aActor
aParam
.
get
(
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
nsCOMPtr
<
T
>
*
aResult
)
{
RefPtr
<
T
>
refptr
;
if
(
!
IPDLParamTraits
<
T
*
>
:
:
Read
(
aMsg
aIter
aActor
&
refptr
)
)
{
return
false
;
}
*
aResult
=
refptr
.
forget
(
)
;
return
true
;
}
}
;
template
<
typename
T
>
struct
IPDLParamTraits
<
nsTArray
<
T
>
>
{
template
<
typename
U
>
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
U
&
&
aParam
)
{
uint32_t
length
=
aParam
.
Length
(
)
;
WriteIPDLParam
(
aMsg
aActor
length
)
;
if
(
sUseWriteBytes
)
{
auto
pickledLength
=
CheckedInt
<
int
>
(
length
)
*
sizeof
(
T
)
;
MOZ_RELEASE_ASSERT
(
pickledLength
.
isValid
(
)
)
;
aMsg
-
>
WriteBytes
(
aParam
.
Elements
(
)
pickledLength
.
value
(
)
)
;
}
else
{
WriteValues
(
aMsg
aActor
std
:
:
forward
<
U
>
(
aParam
)
)
;
}
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
nsTArray
<
T
>
*
aResult
)
{
uint32_t
length
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
length
)
)
{
return
false
;
}
if
(
sUseWriteBytes
)
{
auto
pickledLength
=
CheckedInt
<
int
>
(
length
)
*
sizeof
(
T
)
;
if
(
!
pickledLength
.
isValid
(
)
|
|
!
aMsg
-
>
HasBytesAvailable
(
aIter
pickledLength
.
value
(
)
)
)
{
return
false
;
}
T
*
elements
=
aResult
-
>
AppendElements
(
length
)
;
return
aMsg
-
>
ReadBytesInto
(
aIter
elements
pickledLength
.
value
(
)
)
;
}
if
(
!
aMsg
-
>
HasBytesAvailable
(
aIter
length
)
)
{
return
false
;
}
aResult
-
>
SetCapacity
(
length
)
;
for
(
uint32_t
index
=
0
;
index
<
length
;
index
+
+
)
{
T
*
element
=
aResult
-
>
AppendElement
(
)
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
element
)
)
{
return
false
;
}
}
return
true
;
}
private
:
static
void
WriteValues
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
nsTArray
<
T
>
&
aParam
)
{
for
(
auto
&
elt
:
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
elt
)
;
}
}
static
void
WriteValues
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
nsTArray
<
T
>
&
&
aParam
)
{
for
(
auto
&
elt
:
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
std
:
:
move
(
elt
)
)
;
}
aParam
.
Clear
(
)
;
}
static
const
bool
sUseWriteBytes
=
(
std
:
:
is_integral_v
<
T
>
|
|
std
:
:
is_floating_point_v
<
T
>
)
;
}
;
template
<
typename
T
>
struct
IPDLParamTraits
<
Maybe
<
T
>
>
{
typedef
Maybe
<
T
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
Maybe
<
T
>
&
aParam
)
{
bool
isSome
=
aParam
.
isSome
(
)
;
WriteIPDLParam
(
aMsg
aActor
isSome
)
;
if
(
isSome
)
{
WriteIPDLParam
(
aMsg
aActor
aParam
.
ref
(
)
)
;
}
}
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
Maybe
<
T
>
&
&
aParam
)
{
bool
isSome
=
aParam
.
isSome
(
)
;
WriteIPDLParam
(
aMsg
aActor
isSome
)
;
if
(
isSome
)
{
WriteIPDLParam
(
aMsg
aActor
std
:
:
move
(
aParam
.
ref
(
)
)
)
;
}
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
Maybe
<
T
>
*
aResult
)
{
bool
isSome
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
isSome
)
)
{
return
false
;
}
if
(
isSome
)
{
aResult
-
>
emplace
(
)
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
aResult
-
>
ptr
(
)
)
)
{
return
false
;
}
}
else
{
aResult
-
>
reset
(
)
;
}
return
true
;
}
}
;
template
<
typename
T
>
struct
IPDLParamTraits
<
UniquePtr
<
T
>
>
{
typedef
UniquePtr
<
T
>
paramType
;
template
<
typename
U
>
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
U
&
&
aParam
)
{
bool
isNull
=
aParam
=
=
nullptr
;
WriteIPDLParam
(
aMsg
aActor
isNull
)
;
if
(
!
isNull
)
{
WriteValue
(
aMsg
aActor
std
:
:
forward
<
U
>
(
aParam
)
)
;
}
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
UniquePtr
<
T
>
*
aResult
)
{
bool
isNull
=
true
;
if
(
!
ReadParam
(
aMsg
aIter
&
isNull
)
)
{
return
false
;
}
if
(
isNull
)
{
aResult
-
>
reset
(
)
;
}
else
{
*
aResult
=
MakeUnique
<
T
>
(
)
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
aResult
-
>
get
(
)
)
)
{
return
false
;
}
}
return
true
;
}
private
:
static
void
WriteValue
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
UniquePtr
<
T
>
&
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
std
:
:
move
(
*
aParam
.
get
(
)
)
)
;
aParam
=
nullptr
;
}
static
void
WriteValue
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
UniquePtr
<
T
>
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
*
aParam
.
get
(
)
)
;
}
}
;
template
<
typename
.
.
.
Ts
>
struct
IPDLParamTraits
<
Tuple
<
Ts
.
.
.
>
>
{
typedef
Tuple
<
Ts
.
.
.
>
paramType
;
template
<
typename
U
>
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
U
&
&
aParam
)
{
WriteInternal
(
aMsg
aActor
std
:
:
forward
<
U
>
(
aParam
)
std
:
:
index_sequence_for
<
Ts
.
.
.
>
{
}
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
Tuple
<
Ts
.
.
.
>
*
aResult
)
{
return
ReadInternal
(
aMsg
aIter
aActor
*
aResult
std
:
:
index_sequence_for
<
Ts
.
.
.
>
{
}
)
;
}
private
:
template
<
size_t
.
.
.
Is
>
static
void
WriteInternal
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
Tuple
<
Ts
.
.
.
>
&
aParam
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
WriteIPDLParamList
(
aMsg
aActor
Get
<
Is
>
(
aParam
)
.
.
.
)
;
}
template
<
size_t
.
.
.
Is
>
static
void
WriteInternal
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
Tuple
<
Ts
.
.
.
>
&
&
aParam
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
WriteIPDLParamList
(
aMsg
aActor
std
:
:
move
(
Get
<
Is
>
(
aParam
)
)
.
.
.
)
;
}
template
<
size_t
.
.
.
Is
>
static
bool
ReadInternal
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
Tuple
<
Ts
.
.
.
>
&
aResult
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
return
ReadIPDLParamList
(
aMsg
aIter
aActor
&
Get
<
Is
>
(
aResult
)
.
.
.
)
;
}
}
;
template
<
class
.
.
.
Ts
>
struct
IPDLParamTraits
<
mozilla
:
:
Variant
<
Ts
.
.
.
>
>
{
typedef
mozilla
:
:
Variant
<
Ts
.
.
.
>
paramType
;
using
Tag
=
typename
mozilla
:
:
detail
:
:
VariantTag
<
Ts
.
.
.
>
:
:
Type
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
aParam
.
tag
)
;
aParam
.
match
(
[
aMsg
aActor
]
(
const
auto
&
t
)
{
WriteIPDLParam
(
aMsg
aActor
t
)
;
}
)
;
}
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
paramType
&
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
aParam
.
tag
)
;
aParam
.
match
(
[
aMsg
aActor
]
(
auto
&
t
)
{
WriteIPDLParam
(
aMsg
aActor
std
:
:
move
(
t
)
)
;
}
)
;
}
template
<
size_t
N
typename
dummy
=
void
>
struct
VariantReader
{
using
Next
=
VariantReader
<
N
-
1
>
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
Tag
aTag
paramType
*
aResult
)
{
if
(
aTag
=
=
N
-
1
)
{
return
ReadIPDLParam
(
aMsg
aIter
aActor
&
aResult
-
>
template
emplace
<
N
-
1
>
(
)
)
;
}
return
Next
:
:
Read
(
aMsg
aIter
aActor
aTag
aResult
)
;
}
}
;
template
<
typename
dummy
>
struct
VariantReader
<
0
dummy
>
{
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
Tag
aTag
paramType
*
aResult
)
{
return
false
;
}
}
;
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
Tag
tag
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
tag
)
)
{
return
false
;
}
return
VariantReader
<
sizeof
.
.
.
(
Ts
)
>
:
:
Read
(
aMsg
aIter
aActor
tag
aResult
)
;
}
}
;
}
}
#
endif
