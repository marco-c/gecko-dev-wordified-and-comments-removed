#
ifndef
mozilla_ipc_IPDLParamTraits_h
#
define
mozilla_ipc_IPDLParamTraits_h
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
IProtocol
;
template
<
typename
P
>
struct
IPDLParamTraits
{
template
<
typename
R
>
static
inline
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
R
&
&
aParam
)
{
static_assert
(
IsSame
<
P
typename
IPC
:
:
ParamTraitsSelector
<
R
>
:
:
Type
>
:
:
value
"
IPDLParamTraits
:
:
Write
only
forwards
calls
which
work
via
WriteParam
"
)
;
IPC
:
:
ParamTraits
<
P
>
:
:
Write
(
aMsg
std
:
:
forward
<
R
>
(
aParam
)
)
;
}
template
<
typename
R
>
static
inline
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
R
*
aResult
)
{
static_assert
(
IsSame
<
P
typename
IPC
:
:
ParamTraitsSelector
<
R
>
:
:
Type
>
:
:
value
"
IPDLParamTraits
:
:
Read
only
forwards
calls
which
work
via
ReadParam
"
)
;
return
IPC
:
:
ParamTraits
<
P
>
:
:
Read
(
aMsg
aIter
aResult
)
;
}
}
;
template
<
typename
P
>
static
MOZ_NEVER_INLINE
void
WriteIPDLParam
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
P
&
&
aParam
)
{
IPDLParamTraits
<
typename
IPC
:
:
ParamTraitsSelector
<
P
>
:
:
Type
>
:
:
Write
(
aMsg
aActor
std
:
:
forward
<
P
>
(
aParam
)
)
;
}
template
<
typename
P
>
static
MOZ_NEVER_INLINE
bool
ReadIPDLParam
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
P
*
aResult
)
{
return
IPDLParamTraits
<
typename
IPC
:
:
ParamTraitsSelector
<
P
>
:
:
Type
>
:
:
Read
(
aMsg
aIter
aActor
aResult
)
;
}
template
<
typename
T
>
struct
IPDLParamTraits
<
nsTArray
<
T
>
>
{
static
inline
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
nsTArray
<
T
>
&
aParam
)
{
WriteInternal
(
aMsg
aActor
aParam
)
;
}
static
inline
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
nsTArray
<
T
>
&
aParam
)
{
WriteInternal
(
aMsg
aActor
aParam
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
nsTArray
<
T
>
*
aResult
)
{
uint32_t
length
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
length
)
)
{
return
false
;
}
if
(
sUseWriteBytes
)
{
auto
pickledLength
=
CheckedInt
<
int
>
(
length
)
*
sizeof
(
T
)
;
if
(
!
pickledLength
.
isValid
(
)
|
|
!
aMsg
-
>
HasBytesAvailable
(
aIter
pickledLength
.
value
(
)
)
)
{
return
false
;
}
T
*
elements
=
aResult
-
>
AppendElements
(
length
)
;
return
aMsg
-
>
ReadBytesInto
(
aIter
elements
pickledLength
.
value
(
)
)
;
}
if
(
!
aMsg
-
>
HasBytesAvailable
(
aIter
length
)
)
{
return
false
;
}
aResult
-
>
SetCapacity
(
length
)
;
for
(
uint32_t
index
=
0
;
index
<
length
;
index
+
+
)
{
T
*
element
=
aResult
-
>
AppendElement
(
)
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
element
)
)
{
return
false
;
}
}
return
true
;
}
private
:
template
<
typename
U
>
static
inline
void
WriteInternal
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
U
&
&
aParam
)
{
uint32_t
length
=
aParam
.
Length
(
)
;
WriteIPDLParam
(
aMsg
aActor
length
)
;
if
(
sUseWriteBytes
)
{
auto
pickledLength
=
CheckedInt
<
int
>
(
length
)
*
sizeof
(
T
)
;
MOZ_RELEASE_ASSERT
(
pickledLength
.
isValid
(
)
)
;
aMsg
-
>
WriteBytes
(
aParam
.
Elements
(
)
pickledLength
.
value
(
)
)
;
}
else
{
for
(
uint32_t
index
=
0
;
index
<
length
;
index
+
+
)
{
WriteIPDLParam
(
aMsg
aActor
aParam
.
Elements
(
)
[
index
]
)
;
}
}
}
static
const
bool
sUseWriteBytes
=
(
mozilla
:
:
IsIntegral
<
T
>
:
:
value
|
|
mozilla
:
:
IsFloatingPoint
<
T
>
:
:
value
)
;
}
;
}
}
#
endif
