#
include
"
Shmem
.
h
"
#
include
"
ProtocolUtils
.
h
"
#
include
"
SharedMemoryBasic
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
ShmemCreated
:
public
IPC
:
:
Message
{
private
:
typedef
Shmem
:
:
id_t
id_t
;
public
:
ShmemCreated
(
int32_t
routingId
id_t
aIPDLId
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
)
:
IPC
:
:
Message
(
routingId
SHMEM_CREATED_MESSAGE_TYPE
0
HeaderFlags
(
NESTED_INSIDE_CPOW
)
)
{
MOZ_RELEASE_ASSERT
(
aSize
<
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
"
Tried
to
create
Shmem
with
size
larger
than
4GB
"
)
;
IPC
:
:
WriteParam
(
this
aIPDLId
)
;
IPC
:
:
WriteParam
(
this
uint32_t
(
aSize
)
)
;
IPC
:
:
WriteParam
(
this
int32_t
(
aType
)
)
;
}
static
bool
ReadInfo
(
const
Message
*
msg
PickleIterator
*
iter
id_t
*
aIPDLId
size_t
*
aSize
SharedMemory
:
:
SharedMemoryType
*
aType
)
{
uint32_t
size
=
0
;
if
(
!
IPC
:
:
ReadParam
(
msg
iter
aIPDLId
)
|
|
!
IPC
:
:
ReadParam
(
msg
iter
&
size
)
|
|
!
IPC
:
:
ReadParam
(
msg
iter
reinterpret_cast
<
int32_t
*
>
(
aType
)
)
)
{
return
false
;
}
*
aSize
=
size
;
return
true
;
}
void
Log
(
const
std
:
:
string
&
aPrefix
FILE
*
aOutf
)
const
{
fputs
(
"
(
special
ShmemCreated
msg
)
"
aOutf
)
;
}
}
;
class
ShmemDestroyed
:
public
IPC
:
:
Message
{
private
:
typedef
Shmem
:
:
id_t
id_t
;
public
:
ShmemDestroyed
(
int32_t
routingId
id_t
aIPDLId
)
:
IPC
:
:
Message
(
routingId
SHMEM_DESTROYED_MESSAGE_TYPE
)
{
IPC
:
:
WriteParam
(
this
aIPDLId
)
;
}
}
;
static
SharedMemory
*
NewSegment
(
SharedMemory
:
:
SharedMemoryType
aType
)
{
if
(
SharedMemory
:
:
TYPE_BASIC
=
=
aType
)
{
return
new
SharedMemoryBasic
;
}
else
{
NS_ERROR
(
"
unknown
Shmem
type
"
)
;
return
nullptr
;
}
}
static
already_AddRefed
<
SharedMemory
>
CreateSegment
(
SharedMemory
:
:
SharedMemoryType
aType
size_t
aNBytes
size_t
aExtraSize
)
{
RefPtr
<
SharedMemory
>
segment
=
NewSegment
(
aType
)
;
if
(
!
segment
)
{
return
nullptr
;
}
size_t
size
=
SharedMemory
:
:
PageAlignedSize
(
aNBytes
+
aExtraSize
)
;
if
(
!
segment
-
>
Create
(
size
)
|
|
!
segment
-
>
Map
(
size
)
)
{
return
nullptr
;
}
return
segment
.
forget
(
)
;
}
static
already_AddRefed
<
SharedMemory
>
ReadSegment
(
const
IPC
:
:
Message
&
aDescriptor
Shmem
:
:
id_t
*
aId
size_t
*
aNBytes
size_t
aExtraSize
)
{
if
(
SHMEM_CREATED_MESSAGE_TYPE
!
=
aDescriptor
.
type
(
)
)
{
NS_ERROR
(
"
expected
'
shmem
created
'
message
"
)
;
return
nullptr
;
}
SharedMemory
:
:
SharedMemoryType
type
;
PickleIterator
iter
(
aDescriptor
)
;
if
(
!
ShmemCreated
:
:
ReadInfo
(
&
aDescriptor
&
iter
aId
aNBytes
&
type
)
)
{
return
nullptr
;
}
RefPtr
<
SharedMemory
>
segment
=
NewSegment
(
type
)
;
if
(
!
segment
)
{
return
nullptr
;
}
if
(
!
segment
-
>
ReadHandle
(
&
aDescriptor
&
iter
)
)
{
NS_ERROR
(
"
trying
to
open
invalid
handle
"
)
;
return
nullptr
;
}
aDescriptor
.
EndRead
(
iter
)
;
size_t
size
=
SharedMemory
:
:
PageAlignedSize
(
*
aNBytes
+
aExtraSize
)
;
if
(
!
segment
-
>
Map
(
size
)
)
{
return
nullptr
;
}
segment
-
>
CloseHandle
(
)
;
return
segment
.
forget
(
)
;
}
static
void
DestroySegment
(
SharedMemory
*
aSegment
)
{
if
(
aSegment
)
{
aSegment
-
>
Release
(
)
;
}
}
#
if
defined
(
DEBUG
)
static
const
char
sMagic
[
]
=
"
This
little
piggy
went
to
market
.
\
n
"
"
This
little
piggy
stayed
at
home
.
\
n
"
"
This
little
piggy
has
roast
beef
\
n
"
"
This
little
piggy
had
none
.
\
n
"
"
And
this
little
piggy
cried
\
"
Wee
!
Wee
!
Wee
!
\
"
all
the
way
home
"
;
struct
Header
{
uint32_t
mSize
;
uint32_t
mUnsafe
;
char
mMagic
[
sizeof
(
sMagic
)
]
;
}
;
static
void
GetSections
(
Shmem
:
:
SharedMemory
*
aSegment
Header
*
*
aHeader
char
*
*
aFrontSentinel
char
*
*
aData
char
*
*
aBackSentinel
)
{
MOZ_ASSERT
(
aSegment
&
&
aFrontSentinel
&
&
aData
&
&
aBackSentinel
"
null
param
(
s
)
"
)
;
*
aFrontSentinel
=
reinterpret_cast
<
char
*
>
(
aSegment
-
>
memory
(
)
)
;
MOZ_ASSERT
(
*
aFrontSentinel
"
null
memory
(
)
"
)
;
*
aHeader
=
reinterpret_cast
<
Header
*
>
(
*
aFrontSentinel
)
;
size_t
pageSize
=
Shmem
:
:
SharedMemory
:
:
SystemPageSize
(
)
;
*
aData
=
*
aFrontSentinel
+
pageSize
;
*
aBackSentinel
=
*
aFrontSentinel
+
aSegment
-
>
Size
(
)
-
pageSize
;
}
static
Header
*
GetHeader
(
Shmem
:
:
SharedMemory
*
aSegment
)
{
Header
*
header
;
char
*
dontcare
;
GetSections
(
aSegment
&
header
&
dontcare
&
dontcare
&
dontcare
)
;
return
header
;
}
static
void
Protect
(
SharedMemory
*
aSegment
)
{
MOZ_ASSERT
(
aSegment
"
null
segment
"
)
;
aSegment
-
>
Protect
(
reinterpret_cast
<
char
*
>
(
aSegment
-
>
memory
(
)
)
aSegment
-
>
Size
(
)
RightsNone
)
;
}
static
void
Unprotect
(
SharedMemory
*
aSegment
)
{
MOZ_ASSERT
(
aSegment
"
null
segment
"
)
;
aSegment
-
>
Protect
(
reinterpret_cast
<
char
*
>
(
aSegment
-
>
memory
(
)
)
aSegment
-
>
Size
(
)
RightsRead
|
RightsWrite
)
;
}
Shmem
:
:
Shmem
(
PrivateIPDLCaller
SharedMemory
*
aSegment
id_t
aId
)
:
mSegment
(
aSegment
)
mData
(
nullptr
)
mSize
(
0
)
{
MOZ_ASSERT
(
mSegment
"
null
segment
"
)
;
MOZ_ASSERT
(
aId
!
=
0
"
invalid
ID
"
)
;
Unprotect
(
mSegment
)
;
Header
*
header
;
char
*
frontSentinel
;
char
*
data
;
char
*
backSentinel
;
GetSections
(
aSegment
&
header
&
frontSentinel
&
data
&
backSentinel
)
;
char
check
=
*
frontSentinel
;
(
void
)
check
;
MOZ_ASSERT
(
!
strncmp
(
header
-
>
mMagic
sMagic
sizeof
(
sMagic
)
)
"
invalid
segment
"
)
;
mSize
=
static_cast
<
size_t
>
(
header
-
>
mSize
)
;
size_t
pageSize
=
SharedMemory
:
:
SystemPageSize
(
)
;
mSegment
-
>
Protect
(
frontSentinel
pageSize
RightsNone
)
;
mSegment
-
>
Protect
(
backSentinel
pageSize
RightsNone
)
;
mData
=
data
;
mId
=
aId
;
}
void
Shmem
:
:
AssertInvariants
(
)
const
{
MOZ_ASSERT
(
mSegment
"
null
segment
"
)
;
MOZ_ASSERT
(
mData
"
null
data
pointer
"
)
;
MOZ_ASSERT
(
mSize
>
0
"
invalid
size
"
)
;
char
checkMappingFront
=
*
reinterpret_cast
<
char
*
>
(
mData
)
;
char
checkMappingBack
=
*
(
reinterpret_cast
<
char
*
>
(
mData
)
+
mSize
-
1
)
;
Unused
<
<
checkMappingFront
;
Unused
<
<
checkMappingBack
;
}
void
Shmem
:
:
RevokeRights
(
PrivateIPDLCaller
)
{
AssertInvariants
(
)
;
size_t
pageSize
=
SharedMemory
:
:
SystemPageSize
(
)
;
Header
*
header
=
GetHeader
(
mSegment
)
;
mSegment
-
>
Protect
(
reinterpret_cast
<
char
*
>
(
header
)
pageSize
RightsRead
)
;
if
(
!
header
-
>
mUnsafe
)
{
Protect
(
mSegment
)
;
}
else
{
mSegment
-
>
Protect
(
reinterpret_cast
<
char
*
>
(
header
)
pageSize
RightsNone
)
;
}
}
already_AddRefed
<
Shmem
:
:
SharedMemory
>
Shmem
:
:
Alloc
(
PrivateIPDLCaller
size_t
aNBytes
SharedMemoryType
aType
bool
aUnsafe
bool
aProtect
)
{
NS_ASSERTION
(
aNBytes
<
=
UINT32_MAX
"
Will
truncate
shmem
segment
size
!
"
)
;
MOZ_ASSERT
(
!
aProtect
|
|
!
aUnsafe
"
protect
=
>
!
unsafe
"
)
;
size_t
pageSize
=
SharedMemory
:
:
SystemPageSize
(
)
;
RefPtr
<
SharedMemory
>
segment
=
CreateSegment
(
aType
aNBytes
2
*
pageSize
)
;
if
(
!
segment
)
{
return
nullptr
;
}
Header
*
header
;
char
*
frontSentinel
;
char
*
data
;
char
*
backSentinel
;
GetSections
(
segment
&
header
&
frontSentinel
&
data
&
backSentinel
)
;
MOZ_ASSERT
(
sizeof
(
Header
)
<
=
pageSize
"
Shmem
:
:
Header
has
gotten
too
big
"
)
;
memcpy
(
header
-
>
mMagic
sMagic
sizeof
(
sMagic
)
)
;
header
-
>
mSize
=
static_cast
<
uint32_t
>
(
aNBytes
)
;
header
-
>
mUnsafe
=
aUnsafe
;
if
(
aProtect
)
Protect
(
segment
)
;
return
segment
.
forget
(
)
;
}
already_AddRefed
<
Shmem
:
:
SharedMemory
>
Shmem
:
:
OpenExisting
(
PrivateIPDLCaller
const
IPC
:
:
Message
&
aDescriptor
id_t
*
aId
bool
aProtect
)
{
size_t
size
;
size_t
pageSize
=
SharedMemory
:
:
SystemPageSize
(
)
;
RefPtr
<
SharedMemory
>
segment
=
ReadSegment
(
aDescriptor
aId
&
size
2
*
pageSize
)
;
if
(
!
segment
)
{
return
nullptr
;
}
Header
*
header
=
GetHeader
(
segment
)
;
if
(
size
!
=
header
-
>
mSize
)
{
if
(
header
-
>
mSize
|
|
header
-
>
mUnsafe
|
|
header
-
>
mMagic
[
0
]
|
|
memcmp
(
header
-
>
mMagic
&
header
-
>
mMagic
[
1
]
sizeof
(
header
-
>
mMagic
)
-
1
)
)
{
NS_ERROR
(
"
Wrong
size
for
this
Shmem
!
"
)
;
}
else
{
NS_WARNING
(
"
Shmem
was
deallocated
"
)
;
}
return
nullptr
;
}
if
(
!
header
-
>
mUnsafe
&
&
aProtect
)
Protect
(
segment
)
;
return
segment
.
forget
(
)
;
}
void
Shmem
:
:
Dealloc
(
PrivateIPDLCaller
SharedMemory
*
aSegment
)
{
if
(
!
aSegment
)
return
;
size_t
pageSize
=
SharedMemory
:
:
SystemPageSize
(
)
;
Header
*
header
;
char
*
frontSentinel
;
char
*
data
;
char
*
backSentinel
;
GetSections
(
aSegment
&
header
&
frontSentinel
&
data
&
backSentinel
)
;
aSegment
-
>
Protect
(
frontSentinel
pageSize
RightsWrite
|
RightsRead
)
;
memset
(
header
-
>
mMagic
0
sizeof
(
sMagic
)
)
;
header
-
>
mSize
=
0
;
header
-
>
mUnsafe
=
false
;
DestroySegment
(
aSegment
)
;
}
#
else
already_AddRefed
<
Shmem
:
:
SharedMemory
>
Shmem
:
:
Alloc
(
PrivateIPDLCaller
size_t
aNBytes
SharedMemoryType
aType
bool
bool
)
{
RefPtr
<
SharedMemory
>
segment
=
CreateSegment
(
aType
aNBytes
sizeof
(
uint32_t
)
)
;
if
(
!
segment
)
{
return
nullptr
;
}
*
PtrToSize
(
segment
)
=
static_cast
<
uint32_t
>
(
aNBytes
)
;
return
segment
.
forget
(
)
;
}
already_AddRefed
<
Shmem
:
:
SharedMemory
>
Shmem
:
:
OpenExisting
(
PrivateIPDLCaller
const
IPC
:
:
Message
&
aDescriptor
id_t
*
aId
bool
)
{
size_t
size
;
RefPtr
<
SharedMemory
>
segment
=
ReadSegment
(
aDescriptor
aId
&
size
sizeof
(
uint32_t
)
)
;
if
(
!
segment
)
{
return
nullptr
;
}
if
(
size
!
=
static_cast
<
size_t
>
(
*
PtrToSize
(
segment
)
)
)
{
return
nullptr
;
}
return
segment
.
forget
(
)
;
}
void
Shmem
:
:
Dealloc
(
PrivateIPDLCaller
SharedMemory
*
aSegment
)
{
DestroySegment
(
aSegment
)
;
}
#
endif
IPC
:
:
Message
*
Shmem
:
:
ShareTo
(
PrivateIPDLCaller
base
:
:
ProcessId
aTargetPid
int32_t
routingId
)
{
AssertInvariants
(
)
;
IPC
:
:
Message
*
msg
=
new
ShmemCreated
(
routingId
mId
mSize
mSegment
-
>
Type
(
)
)
;
if
(
!
mSegment
-
>
ShareHandle
(
aTargetPid
msg
)
)
{
return
nullptr
;
}
mSegment
-
>
CloseHandle
(
)
;
return
msg
;
}
IPC
:
:
Message
*
Shmem
:
:
UnshareFrom
(
PrivateIPDLCaller
int32_t
routingId
)
{
AssertInvariants
(
)
;
return
new
ShmemDestroyed
(
routingId
mId
)
;
}
void
IPDLParamTraits
<
Shmem
>
:
:
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
Shmem
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
aParam
.
mId
)
;
aParam
.
RevokeRights
(
Shmem
:
:
PrivateIPDLCaller
(
)
)
;
aParam
.
forget
(
Shmem
:
:
PrivateIPDLCaller
(
)
)
;
}
bool
IPDLParamTraits
<
Shmem
>
:
:
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
paramType
:
:
id_t
id
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
id
)
)
{
return
false
;
}
Shmem
:
:
SharedMemory
*
rawmem
=
aActor
-
>
LookupSharedMemory
(
id
)
;
if
(
rawmem
)
{
*
aResult
=
Shmem
(
Shmem
:
:
PrivateIPDLCaller
(
)
rawmem
id
)
;
return
true
;
}
*
aResult
=
Shmem
(
)
;
return
true
;
}
}
}
