#
include
"
MessagePump
.
h
"
#
include
"
base
/
scoped_nsautorelease_pool
.
h
"
using
namespace
mozilla
:
:
ipc
;
NS_IMPL_ADDREF_INHERITED
(
MessagePumpForNonMainUIThreads
MessagePump
)
NS_IMPL_RELEASE_INHERITED
(
MessagePumpForNonMainUIThreads
MessagePump
)
NS_IMPL_QUERY_INTERFACE
(
MessagePumpForNonMainUIThreads
nsIThreadObserver
)
#
define
CHECK_QUIT_STATE
\
{
\
if
(
state_
-
>
should_quit
)
{
\
break
;
\
}
\
}
void
MessagePumpForNonMainUIThreads
:
:
DoRunLoop
(
)
{
MOZ_RELEASE_ASSERT
(
!
NS_IsMainThread
(
)
"
Use
mozilla
:
:
ipc
:
:
MessagePump
instead
!
"
)
;
nsIThread
*
thread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
thread
)
;
nsCOMPtr
<
nsIThreadInternal
>
ti
(
do_QueryInterface
(
thread
)
)
;
MOZ_ASSERT
(
ti
)
;
ti
-
>
SetObserver
(
this
)
;
base
:
:
ScopedNSAutoreleasePool
autoReleasePool
;
for
(
;
;
)
{
autoReleasePool
.
Recycle
(
)
;
bool
didWork
=
NS_ProcessNextEvent
(
thread
false
)
;
didWork
|
=
ProcessNextWindowsMessage
(
)
;
CHECK_QUIT_STATE
didWork
|
=
state_
-
>
delegate
-
>
DoWork
(
)
;
CHECK_QUIT_STATE
didWork
|
=
state_
-
>
delegate
-
>
DoDelayedWork
(
&
delayed_work_time_
)
;
if
(
didWork
&
&
delayed_work_time_
.
is_null
(
)
)
{
KillTimer
(
message_hwnd_
reinterpret_cast
<
UINT_PTR
>
(
this
)
)
;
}
CHECK_QUIT_STATE
if
(
didWork
)
{
continue
;
}
DebugOnly
<
bool
>
didIdleWork
=
state_
-
>
delegate
-
>
DoIdleWork
(
)
;
MOZ_ASSERT
(
!
didIdleWork
)
;
CHECK_QUIT_STATE
SetInWait
(
)
;
bool
hasWork
=
NS_HasPendingEvents
(
thread
)
;
if
(
didWork
|
|
hasWork
)
{
ClearInWait
(
)
;
continue
;
}
WaitForWork
(
)
;
ClearInWait
(
)
;
}
ClearInWait
(
)
;
ti
-
>
SetObserver
(
nullptr
)
;
}
NS_IMETHODIMP
MessagePumpForNonMainUIThreads
:
:
OnDispatchedEvent
(
)
{
if
(
GetInWait
(
)
)
{
ScheduleWork
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
MessagePumpForNonMainUIThreads
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
thread
bool
mayWait
)
{
return
NS_OK
;
}
NS_IMETHODIMP
MessagePumpForNonMainUIThreads
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
thread
bool
eventWasProcessed
)
{
return
NS_OK
;
}
