#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
ifdef
XP_LINUX
#
include
"
base
/
linux_memfd_defs
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
endif
#
ifdef
__FreeBSD__
#
include
<
sys
/
capsicum
.
h
>
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
valgrind
.
h
>
#
endif
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfilerThreadSleep
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
prenv
.
h
"
namespace
mozilla
:
:
ipc
{
void
SharedMemory
:
:
ResetImpl
(
)
{
if
(
mFrozenFile
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
freezable
shared
memory
was
never
frozen
"
;
mFrozenFile
=
nullptr
;
}
mIsMemfd
=
false
;
}
;
SharedMemory
:
:
Handle
SharedMemory
:
:
CloneHandle
(
const
Handle
&
aHandle
)
{
const
int
new_fd
=
dup
(
aHandle
.
get
(
)
)
;
if
(
new_fd
<
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
duplicate
file
descriptor
:
"
<
<
strerror
(
errno
)
;
return
nullptr
;
}
return
mozilla
:
:
UniqueFileHandle
(
new_fd
)
;
}
void
*
SharedMemory
:
:
FindFreeAddressSpace
(
size_t
size
)
{
void
*
memory
=
mmap
(
nullptr
size
PROT_NONE
MAP_ANONYMOUS
|
MAP_NORESERVE
|
MAP_PRIVATE
-
1
0
)
;
if
(
memory
=
=
MAP_FAILED
)
{
return
nullptr
;
}
munmap
(
memory
size
)
;
return
memory
;
}
Maybe
<
void
*
>
SharedMemory
:
:
MapImpl
(
size_t
nBytes
void
*
fixedAddress
)
{
void
*
mem
=
mmap
(
fixedAddress
nBytes
PROT_READ
|
(
mReadOnly
?
0
:
PROT_WRITE
)
MAP_SHARED
mHandle
.
get
(
)
0
)
;
if
(
mem
=
=
MAP_FAILED
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Call
to
mmap
failed
:
"
<
<
strerror
(
errno
)
;
return
Nothing
(
)
;
}
if
(
fixedAddress
&
&
mem
!
=
fixedAddress
)
{
bool
munmap_succeeded
=
munmap
(
mem
nBytes
)
=
=
0
;
DCHECK
(
munmap_succeeded
)
<
<
"
Call
to
munmap
failed
errno
=
"
<
<
errno
;
return
Nothing
(
)
;
}
return
Some
(
mem
)
;
}
void
SharedMemory
:
:
UnmapImpl
(
size_t
nBytes
void
*
address
)
{
munmap
(
address
nBytes
)
;
}
#
if
!
defined
(
HAVE_MEMFD_CREATE
)
&
&
defined
(
XP_LINUX
)
&
&
\
defined
(
SYS_memfd_create
)
static
int
memfd_create
(
const
char
*
name
unsigned
int
flags
)
{
return
syscall
(
SYS_memfd_create
name
flags
)
;
}
#
define
HAVE_MEMFD_CREATE
1
#
endif
#
ifdef
HAVE_MEMFD_CREATE
#
ifdef
XP_LINUX
#
define
USE_MEMFD_CREATE
1
static
int
DupReadOnly
(
int
fd
)
{
std
:
:
string
path
=
StringPrintf
(
"
/
proc
/
self
/
fd
/
%
d
"
fd
)
;
return
HANDLE_EINTR
(
open
(
path
.
c_str
(
)
O_RDONLY
|
O_CLOEXEC
)
)
;
}
#
elif
defined
(
__FreeBSD__
)
#
define
USE_MEMFD_CREATE
1
static
int
DupReadOnly
(
int
fd
)
{
int
rofd
=
dup
(
fd
)
;
if
(
rofd
<
0
)
{
return
-
1
;
}
cap_rights_t
rights
;
cap_rights_init
(
&
rights
CAP_FSTAT
CAP_MMAP_R
)
;
if
(
cap_rights_limit
(
rofd
&
rights
)
<
0
)
{
int
err
=
errno
;
close
(
rofd
)
;
errno
=
err
;
return
-
1
;
}
return
rofd
;
}
#
else
#
warning
"
OS
has
memfd_create
but
no
DupReadOnly
implementation
"
#
endif
#
endif
static
bool
HaveMemfd
(
)
{
#
ifdef
USE_MEMFD_CREATE
static
const
bool
kHave
=
[
]
{
mozilla
:
:
UniqueFileHandle
fd
(
memfd_create
(
"
mozilla
-
ipc
-
test
"
MFD_CLOEXEC
|
MFD_ALLOW_SEALING
)
)
;
if
(
!
fd
)
{
DCHECK_EQ
(
errno
ENOSYS
)
;
return
false
;
}
if
(
!
PR_GetEnv
(
"
MOZ_SANDBOXED
"
)
)
{
mozilla
:
:
UniqueFileHandle
rofd
(
DupReadOnly
(
fd
.
get
(
)
)
)
;
if
(
!
rofd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
read
-
only
dup
failed
(
"
<
<
strerror
(
errno
)
<
<
"
)
;
not
using
memfd
"
;
return
false
;
}
}
return
true
;
}
(
)
;
return
kHave
;
#
else
return
false
;
#
endif
}
bool
SharedMemory
:
:
AppendPosixShmPrefix
(
std
:
:
string
*
str
pid_t
pid
)
{
if
(
HaveMemfd
(
)
)
{
return
false
;
}
*
str
+
=
'
/
'
;
#
ifdef
MOZ_WIDGET_GTK
if
(
const
char
*
snap
=
mozilla
:
:
widget
:
:
GetSnapInstanceName
(
)
)
{
StringAppendF
(
str
"
snap
.
%
s
.
"
snap
)
;
}
#
endif
StringAppendF
(
str
"
org
.
mozilla
.
ipc
.
%
d
.
"
static_cast
<
int
>
(
pid
)
)
;
return
true
;
}
bool
SharedMemory
:
:
CreateImpl
(
size_t
size
bool
freezable
)
{
DCHECK
(
size
>
0
)
;
DCHECK
(
!
mHandle
)
;
DCHECK
(
!
mFrozenFile
)
;
mozilla
:
:
UniqueFileHandle
fd
;
mozilla
:
:
UniqueFileHandle
frozen_fd
;
bool
is_memfd
=
false
;
#
ifdef
USE_MEMFD_CREATE
if
(
HaveMemfd
(
)
)
{
const
unsigned
flags
=
MFD_CLOEXEC
|
(
freezable
?
MFD_ALLOW_SEALING
:
0
)
;
fd
.
reset
(
memfd_create
(
"
mozilla
-
ipc
"
flags
)
)
;
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
create
memfd
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
is_memfd
=
true
;
if
(
freezable
)
{
frozen_fd
.
reset
(
DupReadOnly
(
fd
.
get
(
)
)
)
;
if
(
!
frozen_fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
create
read
-
only
memfd
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
}
#
endif
if
(
!
fd
)
{
do
{
static
mozilla
:
:
Atomic
<
size_t
>
sNameCounter
;
std
:
:
string
name
;
CHECK
(
AppendPosixShmPrefix
(
&
name
getpid
(
)
)
)
;
StringAppendF
(
&
name
"
%
zu
"
sNameCounter
+
+
)
;
fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDWR
|
O_CREAT
|
O_EXCL
0600
)
)
)
;
if
(
fd
)
{
if
(
freezable
)
{
frozen_fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDONLY
0400
)
)
)
;
if
(
!
frozen_fd
)
{
int
open_err
=
errno
;
shm_unlink
(
name
.
c_str
(
)
)
;
DLOG
(
FATAL
)
<
<
"
failed
to
re
-
open
freezable
shm
:
"
<
<
strerror
(
open_err
)
;
return
false
;
}
}
if
(
shm_unlink
(
name
.
c_str
(
)
)
!
=
0
)
{
DLOG
(
FATAL
)
<
<
"
failed
to
unlink
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
}
while
(
!
fd
&
&
errno
=
=
EEXIST
)
;
}
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
mozilla
:
:
Maybe
<
int
>
fallocateError
;
#
if
defined
(
HAVE_POSIX_FALLOCATE
)
if
(
!
is_memfd
)
{
int
rv
;
{
AUTO_PROFILER_THREAD_SLEEP
;
rv
=
HANDLE_RV_EINTR
(
posix_fallocate
(
fd
.
get
(
)
0
static_cast
<
off_t
>
(
size
)
)
)
;
}
if
(
rv
!
=
0
&
&
rv
!
=
EOPNOTSUPP
&
&
rv
!
=
EINVAL
&
&
rv
!
=
ENODEV
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fallocate
failed
to
set
shm
size
:
"
<
<
strerror
(
rv
)
;
return
false
;
}
fallocateError
=
mozilla
:
:
Some
(
rv
)
;
}
#
endif
if
(
fallocateError
!
=
mozilla
:
:
Some
(
0
)
)
{
int
rv
=
HANDLE_EINTR
(
ftruncate
(
fd
.
get
(
)
static_cast
<
off_t
>
(
size
)
)
)
;
if
(
rv
!
=
0
)
{
int
ftruncate_errno
=
errno
;
if
(
fallocateError
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fallocate
failed
to
set
shm
size
:
"
<
<
strerror
(
*
fallocateError
)
;
}
CHROMIUM_LOG
(
WARNING
)
<
<
"
ftruncate
failed
to
set
shm
size
:
"
<
<
strerror
(
ftruncate_errno
)
;
return
false
;
}
}
mHandle
=
std
:
:
move
(
fd
)
;
mFrozenFile
=
std
:
:
move
(
frozen_fd
)
;
mIsMemfd
=
is_memfd
;
return
true
;
}
Maybe
<
SharedMemory
:
:
Handle
>
SharedMemory
:
:
ReadOnlyCopyImpl
(
)
{
#
ifdef
USE_MEMFD_CREATE
#
ifdef
MOZ_VALGRIND
static
const
bool
haveSeals
=
RUNNING_ON_VALGRIND
=
=
0
;
#
else
static
const
bool
haveSeals
=
true
;
#
endif
static
const
bool
useSeals
=
!
PR_GetEnv
(
"
MOZ_SHM_NO_SEALS
"
)
;
if
(
mIsMemfd
&
&
haveSeals
&
&
useSeals
)
{
const
int
seals
=
F_SEAL_GROW
|
F_SEAL_SHRINK
|
F_SEAL_SEAL
;
int
sealError
=
EINVAL
;
#
ifdef
F_SEAL_FUTURE_WRITE
sealError
=
fcntl
(
mHandle
.
get
(
)
F_ADD_SEALS
seals
|
F_SEAL_FUTURE_WRITE
)
=
=
0
?
0
:
errno
;
#
endif
if
(
sealError
=
=
EINVAL
)
{
sealError
=
fcntl
(
mHandle
.
get
(
)
F_ADD_SEALS
seals
)
=
=
0
?
0
:
errno
;
}
if
(
sealError
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
seal
memfd
:
"
<
<
strerror
(
errno
)
;
return
Nothing
(
)
;
}
}
#
else
DCHECK
(
!
mIsMemfd
)
;
#
endif
DCHECK
(
mFrozenFile
)
;
DCHECK
(
mHandle
)
;
mozilla
:
:
UniqueFileHandle
ro_file
=
std
:
:
move
(
mFrozenFile
)
;
DCHECK
(
ro_file
)
;
return
Some
(
std
:
:
move
(
ro_file
)
)
;
}
void
SharedMemory
:
:
SystemProtect
(
char
*
aAddr
size_t
aSize
int
aRights
)
{
if
(
!
SystemProtectFallible
(
aAddr
aSize
aRights
)
)
{
MOZ_CRASH
(
"
can
'
t
mprotect
(
)
"
)
;
}
}
bool
SharedMemory
:
:
SystemProtectFallible
(
char
*
aAddr
size_t
aSize
int
aRights
)
{
int
flags
=
0
;
if
(
aRights
&
RightsRead
)
flags
|
=
PROT_READ
;
if
(
aRights
&
RightsWrite
)
flags
|
=
PROT_WRITE
;
if
(
RightsNone
=
=
aRights
)
flags
=
PROT_NONE
;
return
0
=
=
mprotect
(
aAddr
aSize
flags
)
;
}
size_t
SharedMemory
:
:
SystemPageSize
(
)
{
return
sysconf
(
_SC_PAGESIZE
)
;
}
bool
SharedMemory
:
:
UsingPosixShm
(
)
{
return
!
HaveMemfd
(
)
;
}
}
