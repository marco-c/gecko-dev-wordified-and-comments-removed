#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
#
include
"
mojo
/
core
/
ports
/
node
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
NodeController
.
h
"
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
namespace
ipc
{
MessageLink
:
:
MessageLink
(
MessageChannel
*
aChan
)
:
mChan
(
aChan
)
{
}
MessageLink
:
:
~
MessageLink
(
)
{
#
ifdef
DEBUG
mChan
=
nullptr
;
#
endif
}
ThreadLink
:
:
ThreadLink
(
MessageChannel
*
aChan
MessageChannel
*
aTargetChan
)
:
MessageLink
(
aChan
)
mTargetChan
(
aTargetChan
)
{
}
void
ThreadLink
:
:
PrepareToDestroy
(
)
{
MOZ_ASSERT
(
mChan
)
;
MOZ_ASSERT
(
mChan
-
>
mMonitor
)
;
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
if
(
mTargetChan
)
{
MOZ_ASSERT
(
mTargetChan
-
>
mLink
)
;
static_cast
<
ThreadLink
*
>
(
mTargetChan
-
>
mLink
.
get
(
)
)
-
>
mTargetChan
=
nullptr
;
}
mTargetChan
=
nullptr
;
}
void
ThreadLink
:
:
SendMessage
(
UniquePtr
<
Message
>
msg
)
{
if
(
!
mChan
-
>
mIsPostponingSends
)
{
mChan
-
>
AssertWorkerThread
(
)
;
}
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
mTargetChan
)
mTargetChan
-
>
OnMessageReceivedFromLink
(
std
:
:
move
(
*
msg
)
)
;
}
void
ThreadLink
:
:
SendClose
(
)
{
mChan
-
>
AssertWorkerThread
(
)
;
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mChan
-
>
mChannelState
=
ChannelClosed
;
if
(
mTargetChan
)
mTargetChan
-
>
OnChannelErrorFromLink
(
)
;
}
bool
ThreadLink
:
:
Unsound_IsClosed
(
)
const
{
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
return
mChan
-
>
mChannelState
=
=
ChannelClosed
;
}
uint32_t
ThreadLink
:
:
Unsound_NumQueuedMessages
(
)
const
{
return
0
;
}
class
PortLink
:
:
PortObserverThunk
:
public
NodeController
:
:
PortObserver
{
public
:
PortObserverThunk
(
RefCountedMonitor
*
aMonitor
PortLink
*
aLink
)
:
mMonitor
(
aMonitor
)
mLink
(
aLink
)
{
}
void
OnPortStatusChanged
(
)
override
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
mLink
)
{
mLink
-
>
OnPortStatusChanged
(
)
;
}
}
private
:
friend
class
PortLink
;
RefPtr
<
RefCountedMonitor
>
mMonitor
;
PortLink
*
MOZ_NON_OWNING_REF
mLink
;
}
;
PortLink
:
:
PortLink
(
MessageChannel
*
aChan
ScopedPort
aPort
)
:
MessageLink
(
aChan
)
mNode
(
aPort
.
Controller
(
)
)
mPort
(
aPort
.
Release
(
)
)
{
mObserver
=
new
PortObserverThunk
(
mChan
-
>
mMonitor
this
)
;
mNode
-
>
SetPortObserver
(
mPort
mObserver
)
;
mChan
-
>
mChannelState
=
ChannelConnected
;
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
NewRunnableMethod
(
"
PortLink
:
:
Open
"
mObserver
&
PortObserverThunk
:
:
OnPortStatusChanged
)
)
;
}
PortLink
:
:
~
PortLink
(
)
{
MOZ_RELEASE_ASSERT
(
!
mObserver
"
PortLink
destroyed
without
being
closed
!
"
)
;
}
void
PortLink
:
:
SendMessage
(
UniquePtr
<
Message
>
aMessage
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
aMessage
-
>
size
(
)
>
IPC
:
:
Channel
:
:
kMaximumMessageSize
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCMessageName
nsDependentCString
(
aMessage
-
>
name
(
)
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCMessageSize
static_cast
<
unsigned
int
>
(
aMessage
-
>
size
(
)
)
)
;
MOZ_CRASH
(
"
IPC
message
size
is
too
large
"
)
;
}
aMessage
-
>
AssertAsLargeAsHeader
(
)
;
RefPtr
<
PortObserverThunk
>
observer
=
mObserver
;
if
(
!
observer
)
{
NS_WARNING
(
"
Ignoring
message
to
closed
PortLink
"
)
;
return
;
}
RefPtr
<
RefCountedMonitor
>
monitor
=
mChan
-
>
mMonitor
;
RefPtr
<
NodeController
>
node
=
mNode
;
PortRef
port
=
mPort
;
bool
ok
=
false
;
{
MonitorAutoUnlock
guard
(
*
monitor
)
;
ok
=
node
-
>
SendUserMessage
(
port
std
:
:
move
(
aMessage
)
)
;
}
if
(
!
ok
)
{
if
(
observer
-
>
mLink
)
{
MOZ_CRASH
(
"
Invalid
argument
to
SendUserMessage
"
)
;
}
NS_WARNING
(
"
Message
dropped
as
PortLink
was
closed
"
)
;
}
}
void
PortLink
:
:
SendClose
(
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mChan
-
>
mChannelState
=
ChannelClosed
;
mChan
-
>
mMonitor
-
>
Notify
(
)
;
if
(
!
mObserver
)
{
return
;
}
Clear
(
)
;
}
void
PortLink
:
:
Clear
(
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mNode
-
>
SetPortObserver
(
mPort
nullptr
)
;
mObserver
-
>
mLink
=
nullptr
;
mObserver
=
nullptr
;
mNode
-
>
ClosePort
(
mPort
)
;
}
void
PortLink
:
:
OnPortStatusChanged
(
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
Maybe
<
PortStatus
>
status
=
mNode
-
>
GetStatus
(
mPort
)
;
status
&
&
status
-
>
peer_remote
!
=
mChan
-
>
IsCrossProcess
(
)
)
{
mChan
-
>
SetIsCrossProcess
(
status
-
>
peer_remote
)
;
}
while
(
mObserver
)
{
UniquePtr
<
IPC
:
:
Message
>
message
;
if
(
!
mNode
-
>
GetMessage
(
mPort
&
message
)
)
{
Clear
(
)
;
mChan
-
>
OnChannelErrorFromLink
(
)
;
return
;
}
if
(
!
message
)
{
return
;
}
mChan
-
>
OnMessageReceivedFromLink
(
std
:
:
move
(
*
message
)
)
;
}
}
bool
PortLink
:
:
Unsound_IsClosed
(
)
const
{
if
(
Maybe
<
PortStatus
>
status
=
mNode
-
>
GetStatus
(
mPort
)
)
{
return
!
(
status
-
>
has_messages
|
|
status
-
>
receiving_messages
)
;
}
return
true
;
}
uint32_t
PortLink
:
:
Unsound_NumQueuedMessages
(
)
const
{
return
0
;
}
}
}
