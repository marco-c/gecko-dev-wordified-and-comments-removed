#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
namespace
ipc
{
MessageLink
:
:
MessageLink
(
MessageChannel
*
aChan
)
:
mChan
(
aChan
)
{
}
MessageLink
:
:
~
MessageLink
(
)
{
#
ifdef
DEBUG
mChan
=
nullptr
;
#
endif
}
ProcessLink
:
:
ProcessLink
(
MessageChannel
*
aChan
)
:
MessageLink
(
aChan
)
mIOLoop
(
nullptr
)
mExistingListener
(
nullptr
)
{
}
ProcessLink
:
:
~
ProcessLink
(
)
{
RefPtr
<
DeleteTask
<
IPC
:
:
Channel
>
>
task
=
new
DeleteTask
<
IPC
:
:
Channel
>
(
mTransport
.
release
(
)
)
;
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
task
.
forget
(
)
)
;
#
ifdef
DEBUG
mIOLoop
=
nullptr
;
mExistingListener
=
nullptr
;
#
endif
}
void
ProcessLink
:
:
Open
(
UniquePtr
<
Transport
>
aTransport
MessageLoop
*
aIOLoop
Side
aSide
)
{
mChan
-
>
AssertWorkerThread
(
)
;
MOZ_ASSERT
(
aTransport
"
need
transport
layer
"
)
;
mTransport
=
std
:
:
move
(
aTransport
)
;
bool
needOpen
=
true
;
if
(
aIOLoop
)
{
needOpen
=
true
;
mChan
-
>
mSide
=
(
aSide
=
=
UnknownSide
)
?
ChildSide
:
aSide
;
}
else
{
MOZ_ASSERT
(
aSide
=
=
UnknownSide
"
expected
default
side
arg
"
)
;
mChan
-
>
mSide
=
ParentSide
;
needOpen
=
false
;
aIOLoop
=
XRE_GetIOMessageLoop
(
)
;
}
mIOLoop
=
aIOLoop
;
NS_ASSERTION
(
mIOLoop
"
need
an
IO
loop
"
)
;
NS_ASSERTION
(
mChan
-
>
mWorkerLoop
"
need
a
worker
loop
"
)
;
if
(
mTransport
-
>
Unsound_IsClosed
(
)
)
{
mIOLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
(
"
ipc
:
:
ProcessLink
:
:
OnChannelConnectError
"
this
&
ProcessLink
:
:
OnChannelConnectError
)
)
;
return
;
}
{
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
if
(
needOpen
)
{
mIOLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
(
"
ipc
:
:
ProcessLink
:
:
OnChannelOpened
"
this
&
ProcessLink
:
:
OnChannelOpened
)
)
;
}
else
{
mIOLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
(
"
ipc
:
:
ProcessLink
:
:
OnTakeConnectedChannel
"
this
&
ProcessLink
:
:
OnTakeConnectedChannel
)
)
;
}
while
(
mChan
-
>
mChannelState
=
=
ChannelClosed
)
{
mChan
-
>
mMonitor
-
>
Wait
(
)
;
}
}
}
void
ProcessLink
:
:
EchoMessage
(
Message
*
msg
)
{
mChan
-
>
AssertWorkerThread
(
)
;
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mIOLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
Message
*
>
(
"
ipc
:
:
ProcessLink
:
:
OnEchoMessage
"
this
&
ProcessLink
:
:
OnEchoMessage
msg
)
)
;
}
void
ProcessLink
:
:
SendMessage
(
Message
*
msg
)
{
if
(
msg
-
>
size
(
)
>
IPC
:
:
Channel
:
:
kMaximumMessageSize
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCMessageName
nsDependentCString
(
msg
-
>
name
(
)
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCMessageSize
static_cast
<
unsigned
int
>
(
msg
-
>
size
(
)
)
)
;
MOZ_CRASH
(
"
IPC
message
size
is
too
large
"
)
;
}
if
(
!
mChan
-
>
mIsPostponingSends
)
{
mChan
-
>
AssertWorkerThread
(
)
;
}
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mIOLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
Message
*
>
(
"
IPC
:
:
Channel
:
:
Send
"
mTransport
.
get
(
)
&
Transport
:
:
Send
msg
)
)
;
}
void
ProcessLink
:
:
SendClose
(
)
{
mChan
-
>
AssertWorkerThread
(
)
;
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mIOLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
(
"
ipc
:
:
ProcessLink
:
:
OnCloseChannel
"
this
&
ProcessLink
:
:
OnCloseChannel
)
)
;
}
ThreadLink
:
:
ThreadLink
(
MessageChannel
*
aChan
MessageChannel
*
aTargetChan
)
:
MessageLink
(
aChan
)
mTargetChan
(
aTargetChan
)
{
}
ThreadLink
:
:
~
ThreadLink
(
)
{
MOZ_ASSERT
(
mChan
)
;
MOZ_ASSERT
(
mChan
-
>
mMonitor
)
;
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
if
(
mTargetChan
)
{
MOZ_ASSERT
(
mTargetChan
-
>
mLink
)
;
static_cast
<
ThreadLink
*
>
(
mTargetChan
-
>
mLink
)
-
>
mTargetChan
=
nullptr
;
}
mTargetChan
=
nullptr
;
}
void
ThreadLink
:
:
EchoMessage
(
Message
*
msg
)
{
mChan
-
>
AssertWorkerThread
(
)
;
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mChan
-
>
OnMessageReceivedFromLink
(
std
:
:
move
(
*
msg
)
)
;
delete
msg
;
}
void
ThreadLink
:
:
SendMessage
(
Message
*
msg
)
{
if
(
!
mChan
-
>
mIsPostponingSends
)
{
mChan
-
>
AssertWorkerThread
(
)
;
}
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
mTargetChan
)
mTargetChan
-
>
OnMessageReceivedFromLink
(
std
:
:
move
(
*
msg
)
)
;
delete
msg
;
}
void
ThreadLink
:
:
SendClose
(
)
{
mChan
-
>
AssertWorkerThread
(
)
;
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mChan
-
>
mChannelState
=
ChannelClosed
;
if
(
mTargetChan
)
mTargetChan
-
>
OnChannelErrorFromLink
(
)
;
}
bool
ThreadLink
:
:
Unsound_IsClosed
(
)
const
{
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
return
mChan
-
>
mChannelState
=
=
ChannelClosed
;
}
uint32_t
ThreadLink
:
:
Unsound_NumQueuedMessages
(
)
const
{
return
0
;
}
void
ProcessLink
:
:
OnMessageReceived
(
Message
&
&
msg
)
{
AssertIOThread
(
)
;
NS_ASSERTION
(
mChan
-
>
mChannelState
!
=
ChannelError
"
Shouldn
'
t
get
here
!
"
)
;
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
mChan
-
>
OnMessageReceivedFromLink
(
std
:
:
move
(
msg
)
)
;
}
void
ProcessLink
:
:
OnEchoMessage
(
Message
*
msg
)
{
AssertIOThread
(
)
;
OnMessageReceived
(
std
:
:
move
(
*
msg
)
)
;
delete
msg
;
}
void
ProcessLink
:
:
OnChannelOpened
(
)
{
AssertIOThread
(
)
;
{
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
mExistingListener
=
mTransport
-
>
set_listener
(
this
)
;
#
ifdef
DEBUG
if
(
mExistingListener
)
{
std
:
:
queue
<
Message
>
pending
;
mExistingListener
-
>
GetQueuedMessages
(
pending
)
;
MOZ_ASSERT
(
pending
.
empty
(
)
)
;
}
#
endif
mChan
-
>
mChannelState
=
ChannelOpening
;
lock
.
Notify
(
)
;
}
if
(
!
mTransport
-
>
Connect
(
)
)
{
mTransport
-
>
Close
(
)
;
OnChannelError
(
)
;
}
}
void
ProcessLink
:
:
OnTakeConnectedChannel
(
)
{
AssertIOThread
(
)
;
std
:
:
queue
<
Message
>
pending
;
{
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
mChan
-
>
mChannelState
=
ChannelConnected
;
mExistingListener
=
mTransport
-
>
set_listener
(
this
)
;
if
(
mExistingListener
)
{
mExistingListener
-
>
GetQueuedMessages
(
pending
)
;
}
lock
.
Notify
(
)
;
}
while
(
!
pending
.
empty
(
)
)
{
OnMessageReceived
(
std
:
:
move
(
pending
.
front
(
)
)
)
;
pending
.
pop
(
)
;
}
}
void
ProcessLink
:
:
OnChannelConnected
(
int32_t
peer_pid
)
{
AssertIOThread
(
)
;
bool
notifyChannel
=
false
;
{
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
if
(
mChan
-
>
mChannelState
=
=
ChannelOpening
|
|
mChan
-
>
mChannelState
=
=
ChannelConnected
)
{
mChan
-
>
mChannelState
=
ChannelConnected
;
mChan
-
>
mMonitor
-
>
Notify
(
)
;
notifyChannel
=
true
;
}
}
if
(
mExistingListener
)
{
mExistingListener
-
>
OnChannelConnected
(
peer_pid
)
;
}
if
(
notifyChannel
)
{
mChan
-
>
OnChannelConnected
(
peer_pid
)
;
}
}
void
ProcessLink
:
:
OnChannelConnectError
(
)
{
AssertIOThread
(
)
;
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
mChan
-
>
OnChannelErrorFromLink
(
)
;
}
void
ProcessLink
:
:
OnChannelError
(
)
{
AssertIOThread
(
)
;
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
MOZ_ALWAYS_TRUE
(
this
=
=
mTransport
-
>
set_listener
(
mExistingListener
)
)
;
mChan
-
>
OnChannelErrorFromLink
(
)
;
}
void
ProcessLink
:
:
OnCloseChannel
(
)
{
AssertIOThread
(
)
;
mTransport
-
>
Close
(
)
;
MonitorAutoLock
lock
(
*
mChan
-
>
mMonitor
)
;
DebugOnly
<
IPC
:
:
Channel
:
:
Listener
*
>
previousListener
=
mTransport
-
>
set_listener
(
mExistingListener
)
;
MOZ_ASSERT
(
previousListener
=
=
this
|
|
previousListener
=
=
mExistingListener
)
;
mChan
-
>
mChannelState
=
ChannelClosed
;
mChan
-
>
mMonitor
-
>
Notify
(
)
;
}
bool
ProcessLink
:
:
Unsound_IsClosed
(
)
const
{
return
mTransport
-
>
Unsound_IsClosed
(
)
;
}
uint32_t
ProcessLink
:
:
Unsound_NumQueuedMessages
(
)
const
{
return
mTransport
-
>
Unsound_NumQueuedMessages
(
)
;
}
}
}
