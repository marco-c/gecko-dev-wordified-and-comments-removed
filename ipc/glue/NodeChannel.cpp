#
include
"
mozilla
/
ipc
/
NodeChannel
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mojo
/
core
/
ports
/
name
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolMessageUtils
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
template
<
>
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
ipc
:
:
NodeChannel
:
:
Introduction
>
{
using
paramType
=
mozilla
:
:
ipc
:
:
NodeChannel
:
:
Introduction
;
static
void
Write
(
Message
*
aMsg
paramType
&
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mName
)
;
WriteParam
(
aMsg
std
:
:
move
(
aParam
.
mTransport
)
)
;
WriteParam
(
aMsg
aParam
.
mMode
)
;
WriteParam
(
aMsg
aParam
.
mMyPid
)
;
WriteParam
(
aMsg
aParam
.
mOtherPid
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
ReadParam
(
aMsg
aIter
&
aResult
-
>
mName
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mTransport
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mMode
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mMyPid
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mOtherPid
)
;
}
}
;
namespace
mozilla
:
:
ipc
{
NodeChannel
:
:
NodeChannel
(
const
NodeName
&
aName
UniquePtr
<
IPC
:
:
Channel
>
aChannel
Listener
*
aListener
int32_t
aPid
)
:
mListener
(
aListener
)
mName
(
aName
)
mOtherPid
(
aPid
)
mChannel
(
std
:
:
move
(
aChannel
)
)
{
}
NodeChannel
:
:
~
NodeChannel
(
)
{
AssertIOThread
(
)
;
if
(
!
mClosed
)
{
mChannel
-
>
Close
(
)
;
}
}
void
NodeChannel
:
:
Destroy
(
)
{
MessageLoop
*
ioThread
=
XRE_GetIOMessageLoop
(
)
;
if
(
ioThread
-
>
IsAcceptingTasks
(
)
)
{
ioThread
-
>
PostTask
(
NewNonOwningRunnableMethod
(
"
NodeChannel
:
:
Destroy
"
this
&
NodeChannel
:
:
FinalDestroy
)
)
;
return
;
}
if
(
MessageLoop
:
:
current
(
)
=
=
ioThread
)
{
FinalDestroy
(
)
;
return
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Leaking
NodeChannel
after
IOThread
destroyed
!
"
)
;
}
void
NodeChannel
:
:
FinalDestroy
(
)
{
AssertIOThread
(
)
;
delete
this
;
}
void
NodeChannel
:
:
Start
(
bool
aCallConnect
)
{
AssertIOThread
(
)
;
mExistingListener
=
mChannel
-
>
set_listener
(
this
)
;
std
:
:
queue
<
IPC
:
:
Message
>
pending
;
if
(
mExistingListener
)
{
mExistingListener
-
>
GetQueuedMessages
(
pending
)
;
}
if
(
aCallConnect
)
{
MOZ_ASSERT
(
pending
.
empty
(
)
"
unopened
channel
with
pending
messages
?
"
)
;
if
(
!
mChannel
-
>
Connect
(
)
)
{
OnChannelError
(
)
;
}
}
else
{
int32_t
otherPid
=
mChannel
-
>
OtherPid
(
)
;
if
(
otherPid
!
=
-
1
)
{
SetOtherPid
(
otherPid
)
;
}
while
(
!
pending
.
empty
(
)
&
&
!
mClosed
)
{
OnMessageReceived
(
std
:
:
move
(
pending
.
front
(
)
)
)
;
pending
.
pop
(
)
;
}
}
}
void
NodeChannel
:
:
Close
(
)
{
AssertIOThread
(
)
;
if
(
!
mClosed
)
{
mChannel
-
>
Close
(
)
;
MOZ_ALWAYS_TRUE
(
this
=
=
mChannel
-
>
set_listener
(
mExistingListener
)
)
;
}
mClosed
=
true
;
}
void
NodeChannel
:
:
SetOtherPid
(
int32_t
aNewPid
)
{
AssertIOThread
(
)
;
MOZ_ASSERT
(
aNewPid
!
=
-
1
)
;
int32_t
previousPid
=
-
1
;
if
(
!
mOtherPid
.
compare_exchange_strong
(
previousPid
aNewPid
)
)
{
MOZ_RELEASE_ASSERT
(
previousPid
=
=
aNewPid
"
Different
sources
disagree
on
the
correct
pid
?
"
)
;
}
}
void
NodeChannel
:
:
SendEventMessage
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aMessage
-
>
type
(
)
!
=
BROADCAST_MESSAGE_TYPE
&
&
aMessage
-
>
type
(
)
!
=
INTRODUCE_MESSAGE_TYPE
&
&
aMessage
-
>
type
(
)
!
=
REQUEST_INTRODUCTION_MESSAGE_TYPE
&
&
aMessage
-
>
type
(
)
!
=
ACCEPT_INVITE_MESSAGE_TYPE
)
;
SendMessage
(
std
:
:
move
(
aMessage
)
)
;
}
void
NodeChannel
:
:
RequestIntroduction
(
const
NodeName
&
aPeerName
)
{
MOZ_ASSERT
(
aPeerName
!
=
mojo
:
:
core
:
:
ports
:
:
kInvalidNodeName
)
;
auto
message
=
MakeUnique
<
IPC
:
:
Message
>
(
MSG_ROUTING_CONTROL
REQUEST_INTRODUCTION_MESSAGE_TYPE
)
;
WriteParam
(
message
.
get
(
)
aPeerName
)
;
SendMessage
(
std
:
:
move
(
message
)
)
;
}
void
NodeChannel
:
:
Introduce
(
Introduction
aIntroduction
)
{
auto
message
=
MakeUnique
<
IPC
:
:
Message
>
(
MSG_ROUTING_CONTROL
INTRODUCE_MESSAGE_TYPE
)
;
WriteParam
(
message
.
get
(
)
std
:
:
move
(
aIntroduction
)
)
;
SendMessage
(
std
:
:
move
(
message
)
)
;
}
void
NodeChannel
:
:
Broadcast
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aMessage
-
>
type
(
)
=
=
BROADCAST_MESSAGE_TYPE
"
Can
only
broadcast
messages
with
the
correct
type
"
)
;
SendMessage
(
std
:
:
move
(
aMessage
)
)
;
}
void
NodeChannel
:
:
AcceptInvite
(
const
NodeName
&
aRealName
const
PortName
&
aInitialPort
)
{
MOZ_ASSERT
(
aRealName
!
=
mojo
:
:
core
:
:
ports
:
:
kInvalidNodeName
)
;
MOZ_ASSERT
(
aInitialPort
!
=
mojo
:
:
core
:
:
ports
:
:
kInvalidPortName
)
;
auto
message
=
MakeUnique
<
IPC
:
:
Message
>
(
MSG_ROUTING_CONTROL
ACCEPT_INVITE_MESSAGE_TYPE
)
;
WriteParam
(
message
.
get
(
)
aRealName
)
;
WriteParam
(
message
.
get
(
)
aInitialPort
)
;
SendMessage
(
std
:
:
move
(
message
)
)
;
}
void
NodeChannel
:
:
SendMessage
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
{
if
(
aMessage
-
>
size
(
)
>
IPC
:
:
Channel
:
:
kMaximumMessageSize
)
{
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCMessageName
nsDependentCString
(
aMessage
-
>
name
(
)
)
)
;
CrashReporter
:
:
AnnotateCrashReport
(
CrashReporter
:
:
Annotation
:
:
IPCMessageSize
static_cast
<
unsigned
int
>
(
aMessage
-
>
size
(
)
)
)
;
MOZ_CRASH
(
"
IPC
message
size
is
too
large
"
)
;
}
aMessage
-
>
AssertAsLargeAsHeader
(
)
;
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
NewRunnableMethod
<
StoreCopyPassByRRef
<
UniquePtr
<
IPC
:
:
Message
>
>
>
(
"
NodeChannel
:
:
DoSendMessage
"
this
&
NodeChannel
:
:
DoSendMessage
std
:
:
move
(
aMessage
)
)
)
;
}
void
NodeChannel
:
:
DoSendMessage
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
{
AssertIOThread
(
)
;
if
(
mClosed
)
{
NS_WARNING
(
"
Dropping
message
as
channel
has
been
closed
"
)
;
return
;
}
if
(
!
mChannel
-
>
Send
(
std
:
:
move
(
aMessage
)
)
)
{
NS_WARNING
(
"
Call
to
Send
(
)
failed
"
)
;
OnChannelError
(
)
;
}
}
void
NodeChannel
:
:
OnMessageReceived
(
IPC
:
:
Message
&
&
aMessage
)
{
AssertIOThread
(
)
;
if
(
!
aMessage
.
is_valid
(
)
)
{
NS_WARNING
(
"
Received
an
invalid
message
"
)
;
OnChannelError
(
)
;
return
;
}
PickleIterator
iter
(
aMessage
)
;
switch
(
aMessage
.
type
(
)
)
{
case
REQUEST_INTRODUCTION_MESSAGE_TYPE
:
{
NodeName
name
;
if
(
IPC
:
:
ReadParam
(
&
aMessage
&
iter
&
name
)
)
{
mListener
-
>
OnRequestIntroduction
(
mName
name
)
;
return
;
}
break
;
}
case
INTRODUCE_MESSAGE_TYPE
:
{
Introduction
introduction
;
if
(
IPC
:
:
ReadParam
(
&
aMessage
&
iter
&
introduction
)
)
{
mListener
-
>
OnIntroduce
(
mName
std
:
:
move
(
introduction
)
)
;
return
;
}
break
;
}
case
BROADCAST_MESSAGE_TYPE
:
{
mListener
-
>
OnBroadcast
(
mName
MakeUnique
<
IPC
:
:
Message
>
(
std
:
:
move
(
aMessage
)
)
)
;
return
;
}
case
ACCEPT_INVITE_MESSAGE_TYPE
:
{
NodeName
realName
;
PortName
initialPort
;
if
(
IPC
:
:
ReadParam
(
&
aMessage
&
iter
&
realName
)
&
&
IPC
:
:
ReadParam
(
&
aMessage
&
iter
&
initialPort
)
)
{
mListener
-
>
OnAcceptInvite
(
mName
realName
initialPort
)
;
return
;
}
break
;
}
case
EVENT_MESSAGE_TYPE
:
default
:
{
mListener
-
>
OnEventMessage
(
mName
MakeUnique
<
IPC
:
:
Message
>
(
std
:
:
move
(
aMessage
)
)
)
;
return
;
}
}
NS_WARNING
(
"
NodeChannel
received
a
malformed
message
"
)
;
OnChannelError
(
)
;
}
void
NodeChannel
:
:
OnChannelConnected
(
int32_t
aPeerPid
)
{
AssertIOThread
(
)
;
SetOtherPid
(
aPeerPid
)
;
if
(
mExistingListener
)
{
mExistingListener
-
>
OnChannelConnected
(
aPeerPid
)
;
}
}
void
NodeChannel
:
:
OnChannelError
(
)
{
AssertIOThread
(
)
;
mChannel
-
>
Close
(
)
;
MOZ_ALWAYS_TRUE
(
this
=
=
mChannel
-
>
set_listener
(
mExistingListener
)
)
;
mClosed
=
true
;
mListener
-
>
OnChannelError
(
mName
)
;
}
}
