#
include
"
BackgroundChild
.
h
"
#
include
"
BackgroundParent
.
h
"
#
include
"
BackgroundChildImpl
.
h
"
#
include
"
BackgroundParentImpl
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
FileDescriptor
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
InputStreamUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolTypes
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessChild
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessBridgeChild
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
prthread
.
h
"
#
include
<
functional
>
#
ifdef
RELEASE_OR_BETA
#
define
THREADSAFETY_ASSERT
MOZ_ASSERT
#
else
#
define
THREADSAFETY_ASSERT
MOZ_RELEASE_ASSERT
#
endif
#
define
CRASH_IN_CHILD_PROCESS
(
_msg
)
\
do
{
\
if
(
XRE_IsParentProcess
(
)
)
{
\
MOZ_ASSERT
(
false
_msg
)
;
\
}
else
{
\
MOZ_CRASH
(
_msg
)
;
\
}
\
}
while
(
0
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
net
;
namespace
{
class
ChildImpl
;
void
AssertIsInMainProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
void
AssertIsInMainOrSocketProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
)
;
}
void
AssertIsOnMainThread
(
)
{
THREADSAFETY_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
AssertIsNotOnMainThread
(
)
{
THREADSAFETY_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
class
ParentImpl
final
:
public
BackgroundParentImpl
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundParent
;
private
:
class
ShutdownObserver
;
class
CreateActorHelper
;
struct
MOZ_STACK_CLASS
TimerCallbackClosure
{
nsIThread
*
mThread
;
nsTArray
<
ParentImpl
*
>
*
mLiveActors
;
TimerCallbackClosure
(
nsIThread
*
aThread
nsTArray
<
ParentImpl
*
>
*
aLiveActors
)
:
mThread
(
aThread
)
mLiveActors
(
aLiveActors
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aThread
)
;
MOZ_ASSERT
(
aLiveActors
)
;
}
}
;
static
const
uint32_t
kShutdownTimerDelayMS
=
10000
;
static
StaticRefPtr
<
nsIThread
>
sBackgroundThread
;
static
nsTArray
<
ParentImpl
*
>
*
sLiveActorsForBackgroundThread
;
static
StaticRefPtr
<
nsITimer
>
sShutdownTimer
;
static
Atomic
<
PRThread
*
>
sBackgroundPRThread
;
static
uint64_t
sLiveActorCount
;
static
bool
sShutdownObserverRegistered
;
static
bool
sShutdownHasStarted
;
RefPtr
<
ContentParent
>
mContent
;
nsTArray
<
ParentImpl
*
>
*
mLiveActorArray
;
const
bool
mIsOtherProcessActor
;
bool
mActorDestroyed
;
public
:
static
already_AddRefed
<
ChildImpl
>
CreateActorForSameProcess
(
nsIEventTarget
*
aMainEventTarget
)
;
static
bool
IsOnBackgroundThread
(
)
{
return
PR_GetCurrentThread
(
)
=
=
sBackgroundPRThread
;
}
static
void
AssertIsOnBackgroundThread
(
)
{
THREADSAFETY_ASSERT
(
IsOnBackgroundThread
(
)
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DELETE_ON_MAIN_THREAD
(
ParentImpl
override
)
void
Destroy
(
)
;
private
:
static
bool
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
;
static
already_AddRefed
<
ContentParent
>
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
;
static
intptr_t
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
;
static
uint64_t
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
;
static
bool
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
;
static
bool
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
;
static
bool
CreateBackgroundThread
(
)
;
static
void
ShutdownBackgroundThread
(
)
;
static
void
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
ParentImpl
(
)
:
mLiveActorArray
(
nullptr
)
mIsOtherProcessActor
(
false
)
mActorDestroyed
(
false
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
}
explicit
ParentImpl
(
ContentParent
*
aContent
)
:
mContent
(
aContent
)
mLiveActorArray
(
nullptr
)
mIsOtherProcessActor
(
true
)
mActorDestroyed
(
false
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
)
;
AssertIsOnMainThread
(
)
;
}
~
ParentImpl
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mContent
)
;
}
void
MainThreadActorDestroy
(
)
;
void
SetLiveActorArray
(
nsTArray
<
ParentImpl
*
>
*
aLiveActorArray
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aLiveActorArray
)
;
MOZ_ASSERT
(
!
aLiveActorArray
-
>
Contains
(
this
)
)
;
MOZ_ASSERT
(
!
mLiveActorArray
)
;
MOZ_ASSERT
(
mIsOtherProcessActor
)
;
mLiveActorArray
=
aLiveActorArray
;
mLiveActorArray
-
>
AppendElement
(
this
)
;
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
class
ChildImpl
final
:
public
BackgroundChildImpl
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChild
;
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
class
ShutdownObserver
;
public
:
class
SendInitBackgroundRunnable
;
struct
ThreadLocalInfo
{
ThreadLocalInfo
(
)
#
ifdef
DEBUG
:
mClosed
(
false
)
#
endif
{
}
RefPtr
<
ChildImpl
>
mActor
;
RefPtr
<
SendInitBackgroundRunnable
>
mSendInitBackgroundRunnable
;
UniquePtr
<
BackgroundChildImpl
:
:
ThreadLocal
>
mConsumerThreadLocal
;
#
ifdef
DEBUG
bool
mClosed
;
#
endif
}
;
private
:
static
constexpr
unsigned
int
kBadThreadLocalIndex
=
static_cast
<
unsigned
int
>
(
-
1
)
;
class
ThreadInfoWrapper
final
{
friend
class
ChildImpl
;
public
:
using
ActorCreateFunc
=
void
(
*
)
(
ThreadLocalInfo
*
unsigned
int
nsIEventTarget
*
ChildImpl
*
*
)
;
constexpr
explicit
ThreadInfoWrapper
(
ActorCreateFunc
aFunc
)
:
mThreadLocalIndex
(
kBadThreadLocalIndex
)
mMainThreadInfo
(
nullptr
)
mCreateActorFunc
(
aFunc
)
{
}
void
Startup
(
)
{
MOZ_ASSERT
(
mThreadLocalIndex
=
=
kBadThreadLocalIndex
"
ThreadInfoWrapper
:
:
Startup
(
)
called
more
than
once
!
"
)
;
PRStatus
status
=
PR_NewThreadPrivateIndex
(
&
mThreadLocalIndex
ThreadLocalDestructor
)
;
MOZ_RELEASE_ASSERT
(
status
=
=
PR_SUCCESS
"
PR_NewThreadPrivateIndex
failed
!
"
)
;
MOZ_ASSERT
(
mThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
}
void
Shutdown
(
)
{
if
(
sShutdownHasStarted
)
{
MOZ_ASSERT_IF
(
mThreadLocalIndex
!
=
kBadThreadLocalIndex
!
PR_GetThreadPrivate
(
mThreadLocalIndex
)
)
;
return
;
}
if
(
mThreadLocalIndex
=
=
kBadThreadLocalIndex
)
{
return
;
}
ThreadLocalInfo
*
threadLocalInfo
;
#
ifdef
DEBUG
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
mThreadLocalIndex
)
)
;
MOZ_ASSERT
(
!
threadLocalInfo
)
;
#
endif
threadLocalInfo
=
mMainThreadInfo
;
if
(
threadLocalInfo
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mClosed
)
;
threadLocalInfo
-
>
mClosed
=
true
;
#
endif
ThreadLocalDestructor
(
threadLocalInfo
)
;
mMainThreadInfo
=
nullptr
;
}
}
void
CloseForCurrentThread
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mThreadLocalIndex
=
=
kBadThreadLocalIndex
)
{
return
;
}
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
mThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mClosed
)
;
threadLocalInfo
-
>
mClosed
=
true
;
#
endif
DebugOnly
<
PRStatus
>
status
=
PR_SetThreadPrivate
(
mThreadLocalIndex
nullptr
)
;
MOZ_ASSERT
(
status
=
=
PR_SUCCESS
)
;
}
PBackgroundChild
*
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
!
aMainEventTarget
)
;
if
(
mThreadLocalIndex
=
=
kBadThreadLocalIndex
)
{
NS_ERROR
(
"
BackgroundChild
:
:
Startup
(
)
was
never
called
"
)
;
return
nullptr
;
}
if
(
NS_IsMainThread
(
)
&
&
ChildImpl
:
:
sShutdownHasStarted
)
{
return
nullptr
;
}
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
mMainThreadInfo
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
mThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
auto
newInfo
=
MakeUnique
<
ThreadLocalInfo
>
(
)
;
if
(
NS_IsMainThread
(
)
)
{
mMainThreadInfo
=
newInfo
.
get
(
)
;
}
else
{
if
(
PR_SetThreadPrivate
(
mThreadLocalIndex
newInfo
.
get
(
)
)
!
=
PR_SUCCESS
)
{
CRASH_IN_CHILD_PROCESS
(
"
PR_SetThreadPrivate
failed
!
"
)
;
return
nullptr
;
}
}
threadLocalInfo
=
newInfo
.
release
(
)
;
}
PBackgroundChild
*
bgChild
=
GetFromThreadInfo
(
aMainEventTarget
threadLocalInfo
)
;
if
(
bgChild
)
{
return
bgChild
;
}
RefPtr
<
ChildImpl
>
actor
;
mCreateActorFunc
(
threadLocalInfo
mThreadLocalIndex
aMainEventTarget
getter_AddRefs
(
actor
)
)
;
return
actor
;
}
private
:
unsigned
int
mThreadLocalIndex
;
ThreadLocalInfo
*
mMainThreadInfo
;
ActorCreateFunc
mCreateActorFunc
;
}
;
static
ThreadInfoWrapper
sParentAndContentProcessThreadInfo
;
static
ThreadInfoWrapper
sSocketAndContentProcessThreadInfo
;
static
ThreadInfoWrapper
sSocketAndParentProcessThreadInfo
;
static
bool
sShutdownHasStarted
;
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
nsISerialEventTarget
*
mOwningEventTarget
;
#
endif
#
ifdef
DEBUG
bool
mActorWasAlive
;
bool
mActorDestroyed
;
#
endif
public
:
static
void
Shutdown
(
)
;
void
AssertIsOnOwningThread
(
)
{
THREADSAFETY_ASSERT
(
mOwningEventTarget
)
;
#
ifdef
RELEASE_OR_BETA
DebugOnly
<
bool
>
current
;
#
else
bool
current
;
#
endif
THREADSAFETY_ASSERT
(
NS_SUCCEEDED
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
)
;
THREADSAFETY_ASSERT
(
current
)
;
}
void
AssertActorDestroyed
(
)
{
MOZ_ASSERT
(
mActorDestroyed
"
ChildImpl
:
:
ActorDestroy
not
called
in
time
"
)
;
}
explicit
ChildImpl
(
)
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
:
mOwningEventTarget
(
GetCurrentSerialEventTarget
(
)
)
#
endif
#
ifdef
DEBUG
mActorWasAlive
(
false
)
mActorDestroyed
(
false
)
#
endif
{
AssertIsOnOwningThread
(
)
;
}
void
SetActorAlive
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mActorWasAlive
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
#
ifdef
DEBUG
mActorWasAlive
=
true
;
#
endif
}
NS_INLINE_DECL_REFCOUNTING
(
ChildImpl
override
)
private
:
static
void
Startup
(
)
;
static
PBackgroundChild
*
GetForCurrentThread
(
)
;
static
PBackgroundChild
*
GetFromThreadInfo
(
nsIEventTarget
*
aMainEventTarget
ThreadLocalInfo
*
aThreadLocalInfo
)
;
static
PBackgroundChild
*
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
;
static
PBackgroundChild
*
GetOrCreateSocketActorForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
;
static
PBackgroundChild
*
GetOrCreateForSocketParentBridgeForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
;
static
void
CloseForCurrentThread
(
)
;
static
BackgroundChildImpl
:
:
ThreadLocal
*
GetThreadLocalForCurrentThread
(
)
;
static
void
ThreadLocalDestructor
(
void
*
aThreadLocal
)
;
~
ChildImpl
(
)
{
MOZ_ASSERT_IF
(
mActorWasAlive
mActorDestroyed
)
;
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
class
ParentImpl
:
:
ShutdownObserver
final
:
public
nsIObserver
{
public
:
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ParentImpl
:
:
CreateActorHelper
final
:
public
Runnable
{
mozilla
:
:
Monitor
mMonitor
;
RefPtr
<
ParentImpl
>
mParentActor
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsresult
mMainThreadResultCode
;
bool
mWaiting
;
public
:
explicit
CreateActorHelper
(
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
CreateActorHelper
"
)
mMonitor
(
"
CreateActorHelper
:
:
mMonitor
"
)
mMainThreadResultCode
(
NS_OK
)
mWaiting
(
true
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsNotOnMainThread
(
)
;
}
nsresult
BlockAndGetResults
(
nsIEventTarget
*
aMainEventTarget
RefPtr
<
ParentImpl
>
&
aParentActor
nsCOMPtr
<
nsIThread
>
&
aThread
)
;
private
:
~
CreateActorHelper
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
}
nsresult
RunOnMainThread
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
ChildImpl
:
:
ShutdownObserver
final
:
public
nsIObserver
{
public
:
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ChildImpl
:
:
SendInitBackgroundRunnable
final
:
public
DiscardableRunnable
{
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
Endpoint
<
PBackgroundParent
>
mParent
;
mozilla
:
:
Mutex
mMutex
;
bool
mSentInitBackground
;
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
mSendInitfunc
;
unsigned
int
mThreadLocalIndex
;
public
:
static
already_AddRefed
<
SendInitBackgroundRunnable
>
Create
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
&
&
aFunc
unsigned
int
aThreadLocalIndex
)
;
void
ClearEventTarget
(
)
{
mWorkerRef
=
nullptr
;
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
mOwningEventTarget
=
nullptr
;
}
private
:
explicit
SendInitBackgroundRunnable
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
&
&
aFunc
unsigned
int
aThreadLocalIndex
)
:
DiscardableRunnable
(
"
Background
:
:
ChildImpl
:
:
SendInitBackgroundRunnable
"
)
mOwningEventTarget
(
GetCurrentSerialEventTarget
(
)
)
mParent
(
std
:
:
move
(
aParent
)
)
mMutex
(
"
SendInitBackgroundRunnable
:
:
mMutex
"
)
mSentInitBackground
(
false
)
mSendInitfunc
(
std
:
:
move
(
aFunc
)
)
mThreadLocalIndex
(
aThreadLocalIndex
)
{
}
~
SendInitBackgroundRunnable
(
)
=
default
;
NS_DECL_NSIRUNNABLE
}
;
}
namespace
mozilla
{
namespace
ipc
{
bool
IsOnBackgroundThread
(
)
{
return
ParentImpl
:
:
IsOnBackgroundThread
(
)
;
}
#
ifdef
DEBUG
void
AssertIsOnBackgroundThread
(
)
{
ParentImpl
:
:
AssertIsOnBackgroundThread
(
)
;
}
#
endif
}
}
bool
BackgroundParent
:
:
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
IsOtherProcessActor
(
aBackgroundActor
)
;
}
already_AddRefed
<
ContentParent
>
BackgroundParent
:
:
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetContentParent
(
aBackgroundActor
)
;
}
intptr_t
BackgroundParent
:
:
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetRawContentParentForComparison
(
aBackgroundActor
)
;
}
uint64_t
BackgroundParent
:
:
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetChildID
(
aBackgroundActor
)
;
}
bool
BackgroundParent
:
:
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
{
return
ParentImpl
:
:
GetLiveActorArray
(
aBackgroundActor
aLiveActorArray
)
;
}
bool
BackgroundParent
:
:
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
{
return
ParentImpl
:
:
Alloc
(
aContent
std
:
:
move
(
aEndpoint
)
)
;
}
void
BackgroundChild
:
:
Startup
(
)
{
ChildImpl
:
:
Startup
(
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetForCurrentThread
(
)
{
return
ChildImpl
:
:
GetForCurrentThread
(
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
ChildImpl
:
:
GetOrCreateForCurrentThread
(
aMainEventTarget
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetOrCreateSocketActorForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
ChildImpl
:
:
GetOrCreateSocketActorForCurrentThread
(
aMainEventTarget
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetOrCreateForSocketParentBridgeForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
ChildImpl
:
:
GetOrCreateForSocketParentBridgeForCurrentThread
(
aMainEventTarget
)
;
}
void
BackgroundChild
:
:
CloseForCurrentThread
(
)
{
ChildImpl
:
:
CloseForCurrentThread
(
)
;
}
BackgroundChildImpl
:
:
ThreadLocal
*
BackgroundChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
{
return
ChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
;
}
StaticRefPtr
<
nsIThread
>
ParentImpl
:
:
sBackgroundThread
;
nsTArray
<
ParentImpl
*
>
*
ParentImpl
:
:
sLiveActorsForBackgroundThread
;
StaticRefPtr
<
nsITimer
>
ParentImpl
:
:
sShutdownTimer
;
Atomic
<
PRThread
*
>
ParentImpl
:
:
sBackgroundPRThread
;
uint64_t
ParentImpl
:
:
sLiveActorCount
=
0
;
bool
ParentImpl
:
:
sShutdownObserverRegistered
=
false
;
bool
ParentImpl
:
:
sShutdownHasStarted
=
false
;
static
void
ParentContentActorCreateFunc
(
ChildImpl
:
:
ThreadLocalInfo
*
aThreadLocalInfo
unsigned
int
aThreadLocalIndex
nsIEventTarget
*
aMainEventTarget
ChildImpl
*
*
aOutput
)
{
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
ChildImpl
>
strongActor
=
ParentImpl
:
:
CreateActorForSameProcess
(
aMainEventTarget
)
;
if
(
NS_WARN_IF
(
!
strongActor
)
)
{
return
;
}
aThreadLocalInfo
-
>
mActor
=
strongActor
;
strongActor
.
forget
(
aOutput
)
;
return
;
}
RefPtr
<
ContentChild
>
content
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
content
)
;
if
(
content
-
>
IsShuttingDown
(
)
)
{
return
;
}
Endpoint
<
PBackgroundParent
>
parent
;
Endpoint
<
PBackgroundChild
>
child
;
nsresult
rv
;
rv
=
PBackground
:
:
CreateEndpoints
(
content
-
>
OtherPid
(
)
base
:
:
GetCurrentProcId
(
)
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
;
}
RefPtr
<
ChildImpl
:
:
SendInitBackgroundRunnable
>
runnable
;
if
(
!
NS_IsMainThread
(
)
)
{
runnable
=
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Create
(
std
:
:
move
(
parent
)
[
]
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
{
RefPtr
<
ContentChild
>
content
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
content
)
;
if
(
!
content
-
>
SendInitBackground
(
std
:
:
move
(
aParent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
}
}
aThreadLocalIndex
)
;
if
(
!
runnable
)
{
return
;
}
}
RefPtr
<
ChildImpl
>
strongActor
=
new
ChildImpl
(
)
;
if
(
!
child
.
Bind
(
strongActor
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
bind
ChildImpl
!
"
)
;
return
;
}
strongActor
-
>
SetActorAlive
(
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
content
-
>
SendInitBackground
(
std
:
:
move
(
parent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
;
}
}
else
{
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
runnable
)
)
;
}
aThreadLocalInfo
-
>
mSendInitBackgroundRunnable
=
runnable
;
}
aThreadLocalInfo
-
>
mActor
=
strongActor
;
strongActor
.
forget
(
aOutput
)
;
}
ChildImpl
:
:
ThreadInfoWrapper
ChildImpl
:
:
sParentAndContentProcessThreadInfo
(
ParentContentActorCreateFunc
)
;
static
void
SocketContentActorCreateFunc
(
ChildImpl
:
:
ThreadLocalInfo
*
aThreadLocalInfo
unsigned
int
aThreadLocalIndex
nsIEventTarget
*
aMainEventTarget
ChildImpl
*
*
aOutput
)
{
RefPtr
<
SocketProcessBridgeChild
>
bridgeChild
=
SocketProcessBridgeChild
:
:
GetSingleton
(
)
;
if
(
!
bridgeChild
|
|
bridgeChild
-
>
IsShuttingDown
(
)
)
{
return
;
}
Endpoint
<
PBackgroundParent
>
parent
;
Endpoint
<
PBackgroundChild
>
child
;
nsresult
rv
;
rv
=
PBackground
:
:
CreateEndpoints
(
bridgeChild
-
>
SocketProcessPid
(
)
base
:
:
GetCurrentProcId
(
)
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
;
}
RefPtr
<
ChildImpl
:
:
SendInitBackgroundRunnable
>
runnable
;
if
(
!
NS_IsMainThread
(
)
)
{
runnable
=
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Create
(
std
:
:
move
(
parent
)
[
]
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
{
RefPtr
<
SocketProcessBridgeChild
>
bridgeChild
=
SocketProcessBridgeChild
:
:
GetSingleton
(
)
;
if
(
!
bridgeChild
-
>
SendInitBackground
(
std
:
:
move
(
aParent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
}
}
aThreadLocalIndex
)
;
if
(
!
runnable
)
{
return
;
}
}
RefPtr
<
ChildImpl
>
strongActor
=
new
ChildImpl
(
)
;
if
(
!
child
.
Bind
(
strongActor
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
bind
ChildImpl
!
"
)
;
return
;
}
strongActor
-
>
SetActorAlive
(
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
bridgeChild
-
>
SendInitBackground
(
std
:
:
move
(
parent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
strongActor
-
>
Close
(
)
;
strongActor
-
>
AssertActorDestroyed
(
)
;
return
;
}
}
else
{
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
runnable
)
)
;
}
aThreadLocalInfo
-
>
mSendInitBackgroundRunnable
=
runnable
;
}
aThreadLocalInfo
-
>
mActor
=
strongActor
;
strongActor
.
forget
(
aOutput
)
;
}
ChildImpl
:
:
ThreadInfoWrapper
ChildImpl
:
:
sSocketAndContentProcessThreadInfo
(
SocketContentActorCreateFunc
)
;
static
void
SocketParentActorCreateFunc
(
ChildImpl
:
:
ThreadLocalInfo
*
aThreadLocalInfo
unsigned
int
aThreadLocalIndex
nsIEventTarget
*
aMainEventTarget
ChildImpl
*
*
aOutput
)
{
SocketProcessChild
*
socketChild
=
SocketProcessChild
:
:
GetSingleton
(
)
;
if
(
!
socketChild
|
|
socketChild
-
>
IsShuttingDown
(
)
)
{
return
;
}
Endpoint
<
PBackgroundParent
>
parent
;
Endpoint
<
PBackgroundChild
>
child
;
nsresult
rv
;
rv
=
PBackground
:
:
CreateEndpoints
(
socketChild
-
>
OtherPid
(
)
base
:
:
GetCurrentProcId
(
)
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
;
}
RefPtr
<
ChildImpl
:
:
SendInitBackgroundRunnable
>
runnable
;
if
(
!
NS_IsMainThread
(
)
)
{
runnable
=
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Create
(
std
:
:
move
(
parent
)
[
]
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
{
SocketProcessChild
*
socketChild
=
SocketProcessChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
socketChild
)
;
if
(
!
socketChild
-
>
SendInitBackground
(
std
:
:
move
(
aParent
)
)
)
{
MOZ_CRASH
(
"
Failed
to
create
top
level
actor
!
"
)
;
}
}
aThreadLocalIndex
)
;
if
(
!
runnable
)
{
return
;
}
}
RefPtr
<
ChildImpl
>
strongActor
=
new
ChildImpl
(
)
;
if
(
!
child
.
Bind
(
strongActor
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
bind
ChildImpl
!
"
)
;
return
;
}
strongActor
-
>
SetActorAlive
(
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
socketChild
-
>
SendInitBackground
(
std
:
:
move
(
parent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
;
}
}
else
{
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
runnable
)
)
;
}
aThreadLocalInfo
-
>
mSendInitBackgroundRunnable
=
runnable
;
}
aThreadLocalInfo
-
>
mActor
=
strongActor
;
strongActor
.
forget
(
aOutput
)
;
}
ChildImpl
:
:
ThreadInfoWrapper
ChildImpl
:
:
sSocketAndParentProcessThreadInfo
(
SocketParentActorCreateFunc
)
;
bool
ChildImpl
:
:
sShutdownHasStarted
=
false
;
bool
ParentImpl
:
:
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
return
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
-
>
mIsOtherProcessActor
;
}
already_AddRefed
<
ContentParent
>
ParentImpl
:
:
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetContentParent
called
after
ActorDestroy
was
called
!
"
)
;
return
nullptr
;
}
if
(
actor
-
>
mContent
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ContentParent
:
:
AddRef
"
actor
-
>
mContent
&
ContentParent
:
:
AddRef
)
)
)
;
}
return
already_AddRefed
<
ContentParent
>
(
actor
-
>
mContent
.
get
(
)
)
;
}
intptr_t
ParentImpl
:
:
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetRawContentParentForComparison
called
after
ActorDestroy
was
"
"
called
!
"
)
;
return
intptr_t
(
-
1
)
;
}
return
intptr_t
(
static_cast
<
ContentParent
*
>
(
actor
-
>
mContent
.
get
(
)
)
)
;
}
uint64_t
ParentImpl
:
:
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetContentParent
called
after
ActorDestroy
was
called
!
"
)
;
return
0
;
}
if
(
actor
-
>
mContent
)
{
return
actor
-
>
mContent
-
>
ChildID
(
)
;
}
return
0
;
}
bool
ParentImpl
:
:
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
MOZ_ASSERT
(
aLiveActorArray
.
IsEmpty
(
)
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetLiveActorArray
called
after
ActorDestroy
was
called
!
"
)
;
return
false
;
}
if
(
!
actor
-
>
mLiveActorArray
)
{
return
true
;
}
for
(
ParentImpl
*
liveActor
:
*
actor
-
>
mLiveActorArray
)
{
aLiveActorArray
.
AppendElement
(
liveActor
)
;
}
return
true
;
}
bool
ParentImpl
:
:
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aEndpoint
.
IsValid
(
)
)
;
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
false
;
}
MOZ_ASSERT
(
sLiveActorsForBackgroundThread
)
;
sLiveActorCount
+
+
;
RefPtr
<
ParentImpl
>
actor
=
new
ParentImpl
(
aContent
)
;
if
(
NS_FAILED
(
sBackgroundThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
Background
:
:
ParentImpl
:
:
ConnectActorRunnable
"
[
actor
=
std
:
:
move
(
actor
)
endpoint
=
std
:
:
move
(
aEndpoint
)
liveActorArray
=
sLiveActorsForBackgroundThread
]
(
)
mutable
{
MOZ_ASSERT
(
endpoint
.
IsValid
(
)
)
;
MOZ_ASSERT
(
liveActorArray
)
;
ParentImpl
*
actorTmp
;
actor
.
forget
(
&
actorTmp
)
;
if
(
!
endpoint
.
Bind
(
actorTmp
)
)
{
actorTmp
-
>
Destroy
(
)
;
return
;
}
actorTmp
-
>
SetLiveActorArray
(
liveActorArray
)
;
}
)
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
connect
runnable
!
"
)
;
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
}
return
true
;
}
already_AddRefed
<
ChildImpl
>
ParentImpl
:
:
CreateActorForSameProcess
(
nsIEventTarget
*
aMainEventTarget
)
{
AssertIsInMainProcess
(
)
;
RefPtr
<
ParentImpl
>
parentActor
;
nsCOMPtr
<
nsIThread
>
backgroundThread
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
nullptr
;
}
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
sLiveActorCount
+
+
;
parentActor
=
new
ParentImpl
(
)
;
backgroundThread
=
sBackgroundThread
.
get
(
)
;
}
else
{
RefPtr
<
CreateActorHelper
>
helper
=
new
CreateActorHelper
(
)
;
nsresult
rv
=
helper
-
>
BlockAndGetResults
(
aMainEventTarget
parentActor
backgroundThread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
RefPtr
<
ChildImpl
>
childActor
=
new
ChildImpl
(
)
;
MessageChannel
*
parentChannel
=
parentActor
-
>
GetIPCChannel
(
)
;
MOZ_ASSERT
(
parentChannel
)
;
if
(
!
childActor
-
>
Open
(
parentChannel
backgroundThread
ChildSide
)
)
{
NS_WARNING
(
"
Failed
to
open
ChildImpl
!
"
)
;
ParentImpl
*
actor
;
parentActor
.
forget
(
&
actor
)
;
actor
-
>
Destroy
(
)
;
return
nullptr
;
}
childActor
-
>
SetActorAlive
(
)
;
parentActor
-
>
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
Unused
<
<
parentActor
.
forget
(
)
;
return
childActor
.
forget
(
)
;
}
bool
ParentImpl
:
:
CreateBackgroundThread
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
sBackgroundThread
)
;
MOZ_ASSERT
(
!
sLiveActorsForBackgroundThread
)
;
if
(
sShutdownHasStarted
)
{
NS_WARNING
(
"
Trying
to
create
background
thread
after
shutdown
has
"
"
already
begun
!
"
)
;
return
false
;
}
nsCOMPtr
<
nsITimer
>
newShutdownTimer
;
if
(
!
sShutdownTimer
)
{
newShutdownTimer
=
NS_NewTimer
(
)
;
if
(
!
newShutdownTimer
)
{
return
false
;
}
}
if
(
!
sShutdownObserverRegistered
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
false
;
}
nsCOMPtr
<
nsIObserver
>
observer
=
new
ShutdownObserver
(
)
;
nsresult
rv
=
obs
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
sShutdownObserverRegistered
=
true
;
}
nsCOMPtr
<
nsIThread
>
thread
;
if
(
NS_FAILED
(
NS_NewNamedThread
(
"
IPDL
Background
"
getter_AddRefs
(
thread
)
NS_NewRunnableFunction
(
"
Background
:
:
ParentImpl
:
:
CreateBackgroundThreadRunnable
"
[
]
(
)
{
DebugOnly
<
PRThread
*
>
oldBackgroundThread
=
sBackgroundPRThread
.
exchange
(
PR_GetCurrentThread
(
)
)
;
MOZ_ASSERT_IF
(
oldBackgroundThread
PR_GetCurrentThread
(
)
!
=
oldBackgroundThread
)
;
}
)
)
)
)
{
NS_WARNING
(
"
NS_NewNamedThread
failed
!
"
)
;
return
false
;
}
sBackgroundThread
=
thread
.
forget
(
)
;
sLiveActorsForBackgroundThread
=
new
nsTArray
<
ParentImpl
*
>
(
1
)
;
if
(
!
sShutdownTimer
)
{
MOZ_ASSERT
(
newShutdownTimer
)
;
sShutdownTimer
=
newShutdownTimer
;
}
return
true
;
}
void
ParentImpl
:
:
ShutdownBackgroundThread
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
sShutdownHasStarted
)
;
MOZ_ASSERT_IF
(
!
sBackgroundThread
!
sLiveActorCount
)
;
MOZ_ASSERT_IF
(
sBackgroundThread
sShutdownTimer
)
;
nsCOMPtr
<
nsITimer
>
shutdownTimer
=
sShutdownTimer
.
get
(
)
;
sShutdownTimer
=
nullptr
;
if
(
sBackgroundThread
)
{
nsCOMPtr
<
nsIThread
>
thread
=
sBackgroundThread
.
get
(
)
;
sBackgroundThread
=
nullptr
;
UniquePtr
<
nsTArray
<
ParentImpl
*
>
>
liveActors
(
sLiveActorsForBackgroundThread
)
;
sLiveActorsForBackgroundThread
=
nullptr
;
MOZ_ASSERT_IF
(
!
sShutdownHasStarted
!
sLiveActorCount
)
;
if
(
sLiveActorCount
)
{
TimerCallbackClosure
closure
(
thread
liveActors
.
get
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownTimer
-
>
InitWithNamedFuncCallback
(
&
ShutdownTimerCallback
&
closure
kShutdownTimerDelayMS
nsITimer
:
:
TYPE_ONE_SHOT
"
ParentImpl
:
:
ShutdownTimerCallback
"
)
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
sLiveActorCount
;
}
)
;
MOZ_ASSERT
(
liveActors
-
>
IsEmpty
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownTimer
-
>
Cancel
(
)
)
;
}
MOZ_ALWAYS_SUCCEEDS
(
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
Background
:
:
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
"
[
]
(
)
{
sBackgroundPRThread
.
compareExchange
(
PR_GetCurrentThread
(
)
nullptr
)
;
}
)
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
thread
-
>
Shutdown
(
)
)
;
}
}
void
ParentImpl
:
:
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
sShutdownHasStarted
)
;
MOZ_ASSERT
(
sLiveActorCount
)
;
auto
closure
=
static_cast
<
TimerCallbackClosure
*
>
(
aClosure
)
;
MOZ_ASSERT
(
closure
)
;
sLiveActorCount
+
+
;
InvokeAsync
(
closure
-
>
mThread
__func__
[
liveActors
=
closure
-
>
mLiveActors
]
(
)
{
MOZ_ASSERT
(
liveActors
)
;
if
(
!
liveActors
-
>
IsEmpty
(
)
)
{
nsTArray
<
ParentImpl
*
>
actorsToClose
(
liveActors
-
>
Clone
(
)
)
;
for
(
ParentImpl
*
actor
:
actorsToClose
)
{
actor
-
>
Close
(
)
;
}
}
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
]
(
)
{
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
}
)
;
}
void
ParentImpl
:
:
Destroy
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ParentImpl
:
:
MainThreadActorDestroy
"
this
&
ParentImpl
:
:
MainThreadActorDestroy
)
)
)
;
}
void
ParentImpl
:
:
MainThreadActorDestroy
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
!
mIsOtherProcessActor
!
mContent
)
;
mContent
=
nullptr
;
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
Release
(
)
;
}
void
ParentImpl
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
MOZ_ASSERT_IF
(
mIsOtherProcessActor
mLiveActorArray
)
;
BackgroundParentImpl
:
:
ActorDestroy
(
aWhy
)
;
mActorDestroyed
=
true
;
if
(
mLiveActorArray
)
{
MOZ_ALWAYS_TRUE
(
mLiveActorArray
-
>
RemoveElement
(
this
)
)
;
mLiveActorArray
=
nullptr
;
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
NewNonOwningRunnableMethod
(
"
ParentImpl
:
:
Destroy
"
this
&
ParentImpl
:
:
Destroy
)
)
)
;
}
NS_IMPL_ISUPPORTS
(
ParentImpl
:
:
ShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ParentImpl
:
:
ShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
)
)
;
sShutdownHasStarted
=
true
;
ChildImpl
:
:
Shutdown
(
)
;
ShutdownBackgroundThread
(
)
;
return
NS_OK
;
}
nsresult
ParentImpl
:
:
CreateActorHelper
:
:
BlockAndGetResults
(
nsIEventTarget
*
aMainEventTarget
RefPtr
<
ParentImpl
>
&
aParentActor
nsCOMPtr
<
nsIThread
>
&
aThread
)
{
AssertIsNotOnMainThread
(
)
;
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
this
)
)
;
}
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mWaiting
)
{
lock
.
Wait
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
mMainThreadResultCode
)
)
)
{
return
mMainThreadResultCode
;
}
aParentActor
=
std
:
:
move
(
mParentActor
)
;
aThread
=
std
:
:
move
(
mThread
)
;
return
NS_OK
;
}
nsresult
ParentImpl
:
:
CreateActorHelper
:
:
RunOnMainThread
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
sLiveActorCount
+
+
;
mParentActor
=
new
ParentImpl
(
)
;
mThread
=
sBackgroundThread
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
CreateActorHelper
:
:
Run
(
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
=
RunOnMainThread
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mMainThreadResultCode
=
rv
;
}
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mWaiting
)
;
mWaiting
=
false
;
lock
.
Notify
(
)
;
return
NS_OK
;
}
void
ChildImpl
:
:
Startup
(
)
{
sParentAndContentProcessThreadInfo
.
Startup
(
)
;
sSocketAndContentProcessThreadInfo
.
Startup
(
)
;
sSocketAndParentProcessThreadInfo
.
Startup
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
observerService
)
;
nsCOMPtr
<
nsIObserver
>
observer
=
new
ShutdownObserver
(
)
;
nsresult
rv
=
observerService
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
false
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
ChildImpl
:
:
Shutdown
(
)
{
AssertIsOnMainThread
(
)
;
sParentAndContentProcessThreadInfo
.
Shutdown
(
)
;
sSocketAndContentProcessThreadInfo
.
Shutdown
(
)
;
sSocketAndParentProcessThreadInfo
.
Shutdown
(
)
;
sShutdownHasStarted
=
true
;
}
PBackgroundChild
*
ChildImpl
:
:
GetForCurrentThread
(
)
{
MOZ_ASSERT
(
sParentAndContentProcessThreadInfo
.
mThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
sParentAndContentProcessThreadInfo
.
mMainThreadInfo
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sParentAndContentProcessThreadInfo
.
mThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
nullptr
;
}
return
threadLocalInfo
-
>
mActor
;
}
PBackgroundChild
*
ChildImpl
:
:
GetFromThreadInfo
(
nsIEventTarget
*
aMainEventTarget
ThreadLocalInfo
*
aThreadLocalInfo
)
{
MOZ_ASSERT
(
aThreadLocalInfo
)
;
if
(
aThreadLocalInfo
-
>
mActor
)
{
RefPtr
<
SendInitBackgroundRunnable
>
&
runnable
=
aThreadLocalInfo
-
>
mSendInitBackgroundRunnable
;
if
(
aMainEventTarget
&
&
runnable
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
return
aThreadLocalInfo
-
>
mActor
;
}
return
nullptr
;
}
PBackgroundChild
*
ChildImpl
:
:
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
sParentAndContentProcessThreadInfo
.
GetOrCreateForCurrentThread
(
aMainEventTarget
)
;
}
PBackgroundChild
*
ChildImpl
:
:
GetOrCreateSocketActorForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
sSocketAndContentProcessThreadInfo
.
GetOrCreateForCurrentThread
(
aMainEventTarget
)
;
}
PBackgroundChild
*
ChildImpl
:
:
GetOrCreateForSocketParentBridgeForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
sSocketAndParentProcessThreadInfo
.
GetOrCreateForCurrentThread
(
aMainEventTarget
)
;
}
void
ChildImpl
:
:
CloseForCurrentThread
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
PBackground
for
the
main
thread
should
be
shut
down
via
"
"
ChildImpl
:
:
Shutdown
(
)
.
"
)
;
sParentAndContentProcessThreadInfo
.
CloseForCurrentThread
(
)
;
sSocketAndContentProcessThreadInfo
.
CloseForCurrentThread
(
)
;
sSocketAndParentProcessThreadInfo
.
CloseForCurrentThread
(
)
;
}
BackgroundChildImpl
:
:
ThreadLocal
*
ChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
{
MOZ_ASSERT
(
sParentAndContentProcessThreadInfo
.
mThreadLocalIndex
!
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
was
never
called
!
"
)
;
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
sParentAndContentProcessThreadInfo
.
mMainThreadInfo
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sParentAndContentProcessThreadInfo
.
mThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
nullptr
;
}
if
(
!
threadLocalInfo
-
>
mConsumerThreadLocal
)
{
threadLocalInfo
-
>
mConsumerThreadLocal
=
MakeUnique
<
BackgroundChildImpl
:
:
ThreadLocal
>
(
)
;
}
return
threadLocalInfo
-
>
mConsumerThreadLocal
.
get
(
)
;
}
void
ChildImpl
:
:
ThreadLocalDestructor
(
void
*
aThreadLocal
)
{
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
aThreadLocal
)
;
if
(
threadLocalInfo
)
{
MOZ_ASSERT
(
threadLocalInfo
-
>
mClosed
)
;
if
(
threadLocalInfo
-
>
mActor
)
{
threadLocalInfo
-
>
mActor
-
>
Close
(
)
;
threadLocalInfo
-
>
mActor
-
>
AssertActorDestroyed
(
)
;
}
if
(
threadLocalInfo
-
>
mSendInitBackgroundRunnable
)
{
threadLocalInfo
-
>
mSendInitBackgroundRunnable
-
>
ClearEventTarget
(
)
;
}
delete
threadLocalInfo
;
}
}
void
ChildImpl
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnOwningThread
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mActorDestroyed
)
;
mActorDestroyed
=
true
;
#
endif
BackgroundChildImpl
:
:
ActorDestroy
(
aWhy
)
;
}
NS_IMPL_ISUPPORTS
(
ChildImpl
:
:
ShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ChildImpl
:
:
ShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
)
)
;
ChildImpl
:
:
Shutdown
(
)
;
return
NS_OK
;
}
already_AddRefed
<
ChildImpl
:
:
SendInitBackgroundRunnable
>
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Create
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
&
&
aFunc
unsigned
int
aThreadLocalIndex
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
SendInitBackgroundRunnable
>
runnable
=
new
SendInitBackgroundRunnable
(
std
:
:
move
(
aParent
)
std
:
:
move
(
aFunc
)
aThreadLocalIndex
)
;
WorkerPrivate
*
workerPrivate
=
mozilla
:
:
dom
:
:
GetCurrentThreadWorkerPrivate
(
)
;
if
(
!
workerPrivate
)
{
return
runnable
.
forget
(
)
;
}
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
runnable
-
>
mWorkerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
ChildImpl
:
:
SendInitBackgroundRunnable
"
)
;
if
(
NS_WARN_IF
(
!
runnable
-
>
mWorkerRef
)
)
{
return
nullptr
;
}
return
runnable
.
forget
(
)
;
}
NS_IMETHODIMP
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Run
(
)
{
if
(
NS_IsMainThread
(
)
)
{
if
(
mSentInitBackground
)
{
return
NS_OK
;
}
mSentInitBackground
=
true
;
mSendInitfunc
(
std
:
:
move
(
mParent
)
)
;
nsCOMPtr
<
nsISerialEventTarget
>
owningEventTarget
;
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
owningEventTarget
=
mOwningEventTarget
;
}
if
(
!
owningEventTarget
)
{
return
NS_OK
;
}
nsresult
rv
=
owningEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
ClearEventTarget
(
)
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
mThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
NS_OK
;
}
threadLocalInfo
-
>
mSendInitBackgroundRunnable
=
nullptr
;
return
NS_OK
;
}
