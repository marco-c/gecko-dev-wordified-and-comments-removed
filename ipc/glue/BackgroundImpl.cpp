#
include
"
BackgroundChild
.
h
"
#
include
"
BackgroundParent
.
h
"
#
include
"
BackgroundChildImpl
.
h
"
#
include
"
BackgroundParentImpl
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
FileDescriptor
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
InputStreamUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolTypes
.
h
"
#
include
"
mozilla
/
net
/
SocketProcessBridgeChild
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
prthread
.
h
"
#
include
<
functional
>
#
ifdef
RELEASE_OR_BETA
#
define
THREADSAFETY_ASSERT
MOZ_ASSERT
#
else
#
define
THREADSAFETY_ASSERT
MOZ_RELEASE_ASSERT
#
endif
#
define
CRASH_IN_CHILD_PROCESS
(
_msg
)
\
do
{
\
if
(
XRE_IsParentProcess
(
)
)
{
\
MOZ_ASSERT
(
false
_msg
)
;
\
}
else
{
\
MOZ_CRASH
(
_msg
)
;
\
}
\
}
while
(
0
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
net
;
namespace
{
class
ChildImpl
;
void
AssertIsInMainProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
void
AssertIsInMainOrSocketProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
)
;
}
void
AssertIsOnMainThread
(
)
{
THREADSAFETY_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
AssertIsNotOnMainThread
(
)
{
THREADSAFETY_ASSERT
(
!
NS_IsMainThread
(
)
)
;
}
class
ParentImpl
final
:
public
BackgroundParentImpl
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundParent
;
public
:
class
CreateCallback
;
private
:
class
ShutdownObserver
;
class
RequestMessageLoopRunnable
;
class
ShutdownBackgroundThreadRunnable
;
class
ForceCloseBackgroundActorsRunnable
;
class
ConnectActorRunnable
;
class
CreateActorHelper
;
struct
MOZ_STACK_CLASS
TimerCallbackClosure
{
nsIThread
*
mThread
;
nsTArray
<
ParentImpl
*
>
*
mLiveActors
;
TimerCallbackClosure
(
nsIThread
*
aThread
nsTArray
<
ParentImpl
*
>
*
aLiveActors
)
:
mThread
(
aThread
)
mLiveActors
(
aLiveActors
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aThread
)
;
MOZ_ASSERT
(
aLiveActors
)
;
}
}
;
static
const
uint32_t
kShutdownTimerDelayMS
=
10000
;
static
StaticRefPtr
<
nsIThread
>
sBackgroundThread
;
static
nsTArray
<
ParentImpl
*
>
*
sLiveActorsForBackgroundThread
;
static
StaticRefPtr
<
nsITimer
>
sShutdownTimer
;
static
Atomic
<
PRThread
*
>
sBackgroundPRThread
;
static
MessageLoop
*
sBackgroundThreadMessageLoop
;
static
uint64_t
sLiveActorCount
;
static
bool
sShutdownObserverRegistered
;
static
bool
sShutdownHasStarted
;
RefPtr
<
ContentParent
>
mContent
;
nsTArray
<
ParentImpl
*
>
*
mLiveActorArray
;
const
bool
mIsOtherProcessActor
;
bool
mActorDestroyed
;
public
:
static
already_AddRefed
<
ChildImpl
>
CreateActorForSameProcess
(
nsIEventTarget
*
aMainEventTarget
)
;
static
bool
IsOnBackgroundThread
(
)
{
return
PR_GetCurrentThread
(
)
=
=
sBackgroundPRThread
;
}
static
void
AssertIsOnBackgroundThread
(
)
{
THREADSAFETY_ASSERT
(
IsOnBackgroundThread
(
)
)
;
}
NS_INLINE_DECL_REFCOUNTING
(
ParentImpl
)
void
Destroy
(
)
;
private
:
static
bool
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
;
static
already_AddRefed
<
ContentParent
>
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
;
static
intptr_t
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
;
static
uint64_t
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
;
static
bool
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
;
static
bool
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
;
static
bool
CreateBackgroundThread
(
)
;
static
void
ShutdownBackgroundThread
(
)
;
static
void
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
ParentImpl
(
)
:
mLiveActorArray
(
nullptr
)
mIsOtherProcessActor
(
false
)
mActorDestroyed
(
false
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
}
explicit
ParentImpl
(
ContentParent
*
aContent
)
:
mContent
(
aContent
)
mLiveActorArray
(
nullptr
)
mIsOtherProcessActor
(
true
)
mActorDestroyed
(
false
)
{
MOZ_ASSERT
(
(
XRE_IsParentProcess
(
)
&
&
aContent
)
|
|
XRE_IsSocketProcess
(
)
)
;
AssertIsOnMainThread
(
)
;
}
~
ParentImpl
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mContent
)
;
}
void
MainThreadActorDestroy
(
)
;
void
SetLiveActorArray
(
nsTArray
<
ParentImpl
*
>
*
aLiveActorArray
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aLiveActorArray
)
;
MOZ_ASSERT
(
!
aLiveActorArray
-
>
Contains
(
this
)
)
;
MOZ_ASSERT
(
!
mLiveActorArray
)
;
MOZ_ASSERT
(
mIsOtherProcessActor
)
;
mLiveActorArray
=
aLiveActorArray
;
mLiveActorArray
-
>
AppendElement
(
this
)
;
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
class
ChildImpl
final
:
public
BackgroundChildImpl
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChild
;
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
class
ShutdownObserver
;
class
SendInitBackgroundRunnable
;
static
const
unsigned
int
kBadThreadLocalIndex
=
static_cast
<
unsigned
int
>
(
-
1
)
;
static
unsigned
int
sThreadLocalIndex
;
static
unsigned
int
sThreadLocalIndexForSocketProcess
;
struct
ThreadLocalInfo
{
ThreadLocalInfo
(
)
#
ifdef
DEBUG
:
mClosed
(
false
)
#
endif
{
}
RefPtr
<
ChildImpl
>
mActor
;
RefPtr
<
SendInitBackgroundRunnable
>
mSendInitBackgroundRunnable
;
nsAutoPtr
<
BackgroundChildImpl
:
:
ThreadLocal
>
mConsumerThreadLocal
;
#
ifdef
DEBUG
bool
mClosed
;
#
endif
}
;
static
ThreadLocalInfo
*
sMainThreadInfo
;
static
ThreadLocalInfo
*
sMainThreadInfoForSocketProcess
;
static
bool
sShutdownHasStarted
;
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
nsISerialEventTarget
*
mOwningEventTarget
;
#
endif
#
ifdef
DEBUG
bool
mActorWasAlive
;
bool
mActorDestroyed
;
#
endif
public
:
static
void
Shutdown
(
)
;
static
void
ShutdownWithThreadLocalIndex
(
unsigned
int
aThreadLocalIndex
)
;
void
AssertIsOnOwningThread
(
)
{
THREADSAFETY_ASSERT
(
mOwningEventTarget
)
;
#
ifdef
RELEASE_OR_BETA
DebugOnly
<
bool
>
current
;
#
else
bool
current
;
#
endif
THREADSAFETY_ASSERT
(
NS_SUCCEEDED
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
)
;
THREADSAFETY_ASSERT
(
current
)
;
}
void
AssertActorDestroyed
(
)
{
MOZ_ASSERT
(
mActorDestroyed
"
ChildImpl
:
:
ActorDestroy
not
called
in
time
"
)
;
}
explicit
ChildImpl
(
)
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
:
mOwningEventTarget
(
GetCurrentThreadSerialEventTarget
(
)
)
#
endif
#
ifdef
DEBUG
mActorWasAlive
(
false
)
mActorDestroyed
(
false
)
#
endif
{
AssertIsOnOwningThread
(
)
;
}
void
SetActorAlive
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mActorWasAlive
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
#
ifdef
DEBUG
mActorWasAlive
=
true
;
#
endif
}
NS_INLINE_DECL_REFCOUNTING
(
ChildImpl
)
private
:
static
void
Startup
(
)
;
static
PBackgroundChild
*
GetForCurrentThread
(
)
;
static
PBackgroundChild
*
GetFromThreadInfo
(
nsIEventTarget
*
aMainEventTarget
ThreadLocalInfo
*
aThreadLocalInfo
)
;
static
PBackgroundChild
*
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
;
static
PBackgroundChild
*
GetOrCreateSocketActorForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
;
static
void
CloseForCurrentThread
(
)
;
static
void
CloseThreadWithIndex
(
unsigned
int
aThreadLocalIndex
)
;
static
BackgroundChildImpl
:
:
ThreadLocal
*
GetThreadLocalForCurrentThread
(
)
;
static
void
ThreadLocalDestructor
(
void
*
aThreadLocal
)
;
~
ChildImpl
(
)
{
MOZ_ASSERT_IF
(
mActorWasAlive
mActorDestroyed
)
;
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
class
ParentImpl
:
:
ShutdownObserver
final
:
public
nsIObserver
{
public
:
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ParentImpl
:
:
RequestMessageLoopRunnable
final
:
public
Runnable
{
nsCOMPtr
<
nsIThread
>
mTargetThread
;
MessageLoop
*
mMessageLoop
;
public
:
explicit
RequestMessageLoopRunnable
(
nsIThread
*
aTargetThread
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
RequestMessageLoopRunnable
"
)
mTargetThread
(
aTargetThread
)
mMessageLoop
(
nullptr
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aTargetThread
)
;
}
private
:
~
RequestMessageLoopRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
final
:
public
Runnable
{
public
:
ShutdownBackgroundThreadRunnable
(
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
"
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
}
private
:
~
ShutdownBackgroundThreadRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
ForceCloseBackgroundActorsRunnable
final
:
public
Runnable
{
nsTArray
<
ParentImpl
*
>
*
mActorArray
;
public
:
explicit
ForceCloseBackgroundActorsRunnable
(
nsTArray
<
ParentImpl
*
>
*
aActorArray
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
ForceCloseBackgroundActorsRunnable
"
)
mActorArray
(
aActorArray
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aActorArray
)
;
}
private
:
~
ForceCloseBackgroundActorsRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
ConnectActorRunnable
final
:
public
Runnable
{
RefPtr
<
ParentImpl
>
mActor
;
Endpoint
<
PBackgroundParent
>
mEndpoint
;
nsTArray
<
ParentImpl
*
>
*
mLiveActorArray
;
public
:
ConnectActorRunnable
(
ParentImpl
*
aActor
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
nsTArray
<
ParentImpl
*
>
*
aLiveActorArray
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
ConnectActorRunnable
"
)
mActor
(
aActor
)
mEndpoint
(
std
:
:
move
(
aEndpoint
)
)
mLiveActorArray
(
aLiveActorArray
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mEndpoint
.
IsValid
(
)
)
;
MOZ_ASSERT
(
aLiveActorArray
)
;
}
private
:
~
ConnectActorRunnable
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
CreateActorHelper
final
:
public
Runnable
{
mozilla
:
:
Monitor
mMonitor
;
RefPtr
<
ParentImpl
>
mParentActor
;
nsCOMPtr
<
nsIThread
>
mThread
;
nsresult
mMainThreadResultCode
;
bool
mWaiting
;
public
:
explicit
CreateActorHelper
(
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
CreateActorHelper
"
)
mMonitor
(
"
CreateActorHelper
:
:
mMonitor
"
)
mMainThreadResultCode
(
NS_OK
)
mWaiting
(
true
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsNotOnMainThread
(
)
;
}
nsresult
BlockAndGetResults
(
nsIEventTarget
*
aMainEventTarget
RefPtr
<
ParentImpl
>
&
aParentActor
nsCOMPtr
<
nsIThread
>
&
aThread
)
;
private
:
~
CreateActorHelper
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
}
nsresult
RunOnMainThread
(
)
;
NS_DECL_NSIRUNNABLE
}
;
class
NS_NO_VTABLE
ParentImpl
:
:
CreateCallback
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
CreateCallback
)
virtual
void
Success
(
already_AddRefed
<
ParentImpl
>
aActor
MessageLoop
*
aMessageLoop
)
=
0
;
virtual
void
Failure
(
)
=
0
;
protected
:
virtual
~
CreateCallback
(
)
{
}
}
;
class
ChildImpl
:
:
ShutdownObserver
final
:
public
nsIObserver
{
public
:
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ChildImpl
:
:
SendInitBackgroundRunnable
final
:
public
CancelableRunnable
{
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
Endpoint
<
PBackgroundParent
>
mParent
;
mozilla
:
:
Mutex
mMutex
;
bool
mSentInitBackground
;
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
mSendInitfunc
;
public
:
static
already_AddRefed
<
SendInitBackgroundRunnable
>
Create
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
&
&
aFunc
)
;
void
ClearEventTarget
(
)
{
mWorkerRef
=
nullptr
;
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
mOwningEventTarget
=
nullptr
;
}
private
:
explicit
SendInitBackgroundRunnable
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
&
&
aFunc
)
:
CancelableRunnable
(
"
Background
:
:
ChildImpl
:
:
SendInitBackgroundRunnable
"
)
mOwningEventTarget
(
GetCurrentThreadSerialEventTarget
(
)
)
mParent
(
std
:
:
move
(
aParent
)
)
mMutex
(
"
SendInitBackgroundRunnable
:
:
mMutex
"
)
mSentInitBackground
(
false
)
mSendInitfunc
(
std
:
:
move
(
aFunc
)
)
{
}
~
SendInitBackgroundRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
}
namespace
mozilla
{
namespace
ipc
{
bool
IsOnBackgroundThread
(
)
{
return
ParentImpl
:
:
IsOnBackgroundThread
(
)
;
}
#
ifdef
DEBUG
void
AssertIsOnBackgroundThread
(
)
{
ParentImpl
:
:
AssertIsOnBackgroundThread
(
)
;
}
#
endif
}
}
bool
BackgroundParent
:
:
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
IsOtherProcessActor
(
aBackgroundActor
)
;
}
already_AddRefed
<
ContentParent
>
BackgroundParent
:
:
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetContentParent
(
aBackgroundActor
)
;
}
intptr_t
BackgroundParent
:
:
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetRawContentParentForComparison
(
aBackgroundActor
)
;
}
uint64_t
BackgroundParent
:
:
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetChildID
(
aBackgroundActor
)
;
}
bool
BackgroundParent
:
:
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
{
return
ParentImpl
:
:
GetLiveActorArray
(
aBackgroundActor
aLiveActorArray
)
;
}
bool
BackgroundParent
:
:
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
{
return
ParentImpl
:
:
Alloc
(
aContent
std
:
:
move
(
aEndpoint
)
)
;
}
void
BackgroundChild
:
:
Startup
(
)
{
ChildImpl
:
:
Startup
(
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetForCurrentThread
(
)
{
return
ChildImpl
:
:
GetForCurrentThread
(
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
ChildImpl
:
:
GetOrCreateForCurrentThread
(
aMainEventTarget
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetOrCreateSocketActorForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
return
ChildImpl
:
:
GetOrCreateSocketActorForCurrentThread
(
aMainEventTarget
)
;
}
void
BackgroundChild
:
:
CloseForCurrentThread
(
)
{
ChildImpl
:
:
CloseForCurrentThread
(
)
;
}
BackgroundChildImpl
:
:
ThreadLocal
*
BackgroundChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
{
return
ChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
;
}
StaticRefPtr
<
nsIThread
>
ParentImpl
:
:
sBackgroundThread
;
nsTArray
<
ParentImpl
*
>
*
ParentImpl
:
:
sLiveActorsForBackgroundThread
;
StaticRefPtr
<
nsITimer
>
ParentImpl
:
:
sShutdownTimer
;
Atomic
<
PRThread
*
>
ParentImpl
:
:
sBackgroundPRThread
;
MessageLoop
*
ParentImpl
:
:
sBackgroundThreadMessageLoop
=
nullptr
;
uint64_t
ParentImpl
:
:
sLiveActorCount
=
0
;
bool
ParentImpl
:
:
sShutdownObserverRegistered
=
false
;
bool
ParentImpl
:
:
sShutdownHasStarted
=
false
;
unsigned
int
ChildImpl
:
:
sThreadLocalIndex
=
kBadThreadLocalIndex
;
unsigned
int
ChildImpl
:
:
sThreadLocalIndexForSocketProcess
=
kBadThreadLocalIndex
;
bool
ChildImpl
:
:
sShutdownHasStarted
=
false
;
bool
ParentImpl
:
:
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
return
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
-
>
mIsOtherProcessActor
;
}
already_AddRefed
<
ContentParent
>
ParentImpl
:
:
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetContentParent
called
after
ActorDestroy
was
called
!
"
)
;
return
nullptr
;
}
if
(
actor
-
>
mContent
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ContentParent
:
:
AddRef
"
actor
-
>
mContent
&
ContentParent
:
:
AddRef
)
)
)
;
}
return
already_AddRefed
<
ContentParent
>
(
actor
-
>
mContent
.
get
(
)
)
;
}
intptr_t
ParentImpl
:
:
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetRawContentParentForComparison
called
after
ActorDestroy
was
"
"
called
!
"
)
;
return
intptr_t
(
-
1
)
;
}
return
intptr_t
(
static_cast
<
ContentParent
*
>
(
actor
-
>
mContent
.
get
(
)
)
)
;
}
uint64_t
ParentImpl
:
:
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetContentParent
called
after
ActorDestroy
was
called
!
"
)
;
return
0
;
}
if
(
actor
-
>
mContent
)
{
return
actor
-
>
mContent
-
>
ChildID
(
)
;
}
return
0
;
}
bool
ParentImpl
:
:
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
MOZ_ASSERT
(
aLiveActorArray
.
IsEmpty
(
)
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetLiveActorArray
called
after
ActorDestroy
was
called
!
"
)
;
return
false
;
}
if
(
!
actor
-
>
mLiveActorArray
)
{
return
true
;
}
for
(
ParentImpl
*
liveActor
:
*
actor
-
>
mLiveActorArray
)
{
aLiveActorArray
.
AppendElement
(
liveActor
)
;
}
return
true
;
}
bool
ParentImpl
:
:
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aEndpoint
.
IsValid
(
)
)
;
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
false
;
}
MOZ_ASSERT
(
sLiveActorsForBackgroundThread
)
;
sLiveActorCount
+
+
;
RefPtr
<
ParentImpl
>
actor
=
new
ParentImpl
(
aContent
)
;
nsCOMPtr
<
nsIRunnable
>
connectRunnable
=
new
ConnectActorRunnable
(
actor
std
:
:
move
(
aEndpoint
)
sLiveActorsForBackgroundThread
)
;
if
(
NS_FAILED
(
sBackgroundThread
-
>
Dispatch
(
connectRunnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
connect
runnable
!
"
)
;
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
return
false
;
}
return
true
;
}
already_AddRefed
<
ChildImpl
>
ParentImpl
:
:
CreateActorForSameProcess
(
nsIEventTarget
*
aMainEventTarget
)
{
AssertIsInMainProcess
(
)
;
RefPtr
<
ParentImpl
>
parentActor
;
nsCOMPtr
<
nsIThread
>
backgroundThread
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
nullptr
;
}
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
sLiveActorCount
+
+
;
parentActor
=
new
ParentImpl
(
)
;
backgroundThread
=
sBackgroundThread
.
get
(
)
;
}
else
{
RefPtr
<
CreateActorHelper
>
helper
=
new
CreateActorHelper
(
)
;
nsresult
rv
=
helper
-
>
BlockAndGetResults
(
aMainEventTarget
parentActor
backgroundThread
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
}
RefPtr
<
ChildImpl
>
childActor
=
new
ChildImpl
(
)
;
MessageChannel
*
parentChannel
=
parentActor
-
>
GetIPCChannel
(
)
;
MOZ_ASSERT
(
parentChannel
)
;
if
(
!
childActor
-
>
Open
(
parentChannel
backgroundThread
ChildSide
)
)
{
NS_WARNING
(
"
Failed
to
open
ChildImpl
!
"
)
;
ParentImpl
*
actor
;
parentActor
.
forget
(
&
actor
)
;
actor
-
>
Destroy
(
)
;
return
nullptr
;
}
childActor
-
>
SetActorAlive
(
)
;
parentActor
-
>
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
Unused
<
<
parentActor
.
forget
(
)
;
return
childActor
.
forget
(
)
;
}
bool
ParentImpl
:
:
CreateBackgroundThread
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
sBackgroundThread
)
;
MOZ_ASSERT
(
!
sLiveActorsForBackgroundThread
)
;
if
(
sShutdownHasStarted
)
{
NS_WARNING
(
"
Trying
to
create
background
thread
after
shutdown
has
"
"
already
begun
!
"
)
;
return
false
;
}
nsCOMPtr
<
nsITimer
>
newShutdownTimer
;
if
(
!
sShutdownTimer
)
{
newShutdownTimer
=
NS_NewTimer
(
)
;
if
(
!
newShutdownTimer
)
{
return
false
;
}
}
if
(
!
sShutdownObserverRegistered
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
false
;
}
nsCOMPtr
<
nsIObserver
>
observer
=
new
ShutdownObserver
(
)
;
nsresult
rv
=
obs
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
sShutdownObserverRegistered
=
true
;
}
nsCOMPtr
<
nsIThread
>
thread
;
if
(
NS_FAILED
(
NS_NewNamedThread
(
"
IPDL
Background
"
getter_AddRefs
(
thread
)
)
)
)
{
NS_WARNING
(
"
NS_NewNamedThread
failed
!
"
)
;
return
false
;
}
nsCOMPtr
<
nsIRunnable
>
messageLoopRunnable
=
new
RequestMessageLoopRunnable
(
thread
)
;
if
(
NS_FAILED
(
thread
-
>
Dispatch
(
messageLoopRunnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
RequestMessageLoopRunnable
!
"
)
;
return
false
;
}
sBackgroundThread
=
thread
;
sLiveActorsForBackgroundThread
=
new
nsTArray
<
ParentImpl
*
>
(
1
)
;
if
(
!
sShutdownTimer
)
{
MOZ_ASSERT
(
newShutdownTimer
)
;
sShutdownTimer
=
newShutdownTimer
;
}
return
true
;
}
void
ParentImpl
:
:
ShutdownBackgroundThread
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
sShutdownHasStarted
)
;
MOZ_ASSERT_IF
(
!
sBackgroundThread
!
sLiveActorCount
)
;
MOZ_ASSERT_IF
(
sBackgroundThread
sShutdownTimer
)
;
nsCOMPtr
<
nsITimer
>
shutdownTimer
=
sShutdownTimer
.
get
(
)
;
sShutdownTimer
=
nullptr
;
if
(
sBackgroundThread
)
{
nsCOMPtr
<
nsIThread
>
thread
=
sBackgroundThread
.
get
(
)
;
sBackgroundThread
=
nullptr
;
nsAutoPtr
<
nsTArray
<
ParentImpl
*
>
>
liveActors
(
sLiveActorsForBackgroundThread
)
;
sLiveActorsForBackgroundThread
=
nullptr
;
MOZ_ASSERT_IF
(
!
sShutdownHasStarted
!
sLiveActorCount
)
;
if
(
sLiveActorCount
)
{
TimerCallbackClosure
closure
(
thread
liveActors
)
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownTimer
-
>
InitWithNamedFuncCallback
(
&
ShutdownTimerCallback
&
closure
kShutdownTimerDelayMS
nsITimer
:
:
TYPE_ONE_SHOT
"
ParentImpl
:
:
ShutdownTimerCallback
"
)
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
sLiveActorCount
;
}
)
;
MOZ_ASSERT
(
liveActors
-
>
IsEmpty
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownTimer
-
>
Cancel
(
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
shutdownRunnable
=
new
ShutdownBackgroundThreadRunnable
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
thread
-
>
Dispatch
(
shutdownRunnable
NS_DISPATCH_NORMAL
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
thread
-
>
Shutdown
(
)
)
;
}
}
void
ParentImpl
:
:
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
sShutdownHasStarted
)
;
MOZ_ASSERT
(
sLiveActorCount
)
;
auto
closure
=
static_cast
<
TimerCallbackClosure
*
>
(
aClosure
)
;
MOZ_ASSERT
(
closure
)
;
sLiveActorCount
+
+
;
nsCOMPtr
<
nsIRunnable
>
forceCloseRunnable
=
new
ForceCloseBackgroundActorsRunnable
(
closure
-
>
mLiveActors
)
;
MOZ_ALWAYS_SUCCEEDS
(
closure
-
>
mThread
-
>
Dispatch
(
forceCloseRunnable
NS_DISPATCH_NORMAL
)
)
;
}
void
ParentImpl
:
:
Destroy
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ParentImpl
:
:
MainThreadActorDestroy
"
this
&
ParentImpl
:
:
MainThreadActorDestroy
)
)
)
;
}
void
ParentImpl
:
:
MainThreadActorDestroy
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
mIsOtherProcessActor
&
&
XRE_IsParentProcess
(
)
mContent
)
;
MOZ_ASSERT_IF
(
!
mIsOtherProcessActor
!
mContent
)
;
mContent
=
nullptr
;
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
Release
(
)
;
}
void
ParentImpl
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
MOZ_ASSERT_IF
(
mIsOtherProcessActor
mLiveActorArray
)
;
BackgroundParentImpl
:
:
ActorDestroy
(
aWhy
)
;
mActorDestroyed
=
true
;
if
(
mLiveActorArray
)
{
MOZ_ALWAYS_TRUE
(
mLiveActorArray
-
>
RemoveElement
(
this
)
)
;
mLiveActorArray
=
nullptr
;
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
NewNonOwningRunnableMethod
(
"
ParentImpl
:
:
Destroy
"
this
&
ParentImpl
:
:
Destroy
)
)
)
;
}
NS_IMPL_ISUPPORTS
(
ParentImpl
:
:
ShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ParentImpl
:
:
ShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
)
)
;
sShutdownHasStarted
=
true
;
if
(
!
XRE_IsSocketProcess
(
)
)
{
ChildImpl
:
:
Shutdown
(
)
;
}
ShutdownBackgroundThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
RequestMessageLoopRunnable
:
:
Run
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
MOZ_ASSERT
(
mTargetThread
)
;
if
(
NS_IsMainThread
(
)
)
{
MOZ_ASSERT
(
mMessageLoop
)
;
if
(
!
sBackgroundThread
|
|
!
SameCOMIdentity
(
mTargetThread
.
get
(
)
sBackgroundThread
.
get
(
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
sBackgroundThreadMessageLoop
)
;
sBackgroundThreadMessageLoop
=
mMessageLoop
;
return
NS_OK
;
}
#
ifdef
DEBUG
{
bool
correctThread
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mTargetThread
-
>
IsOnCurrentThread
(
&
correctThread
)
)
)
;
MOZ_ASSERT
(
correctThread
)
;
}
#
endif
DebugOnly
<
PRThread
*
>
oldBackgroundThread
=
sBackgroundPRThread
.
exchange
(
PR_GetCurrentThread
(
)
)
;
MOZ_ASSERT_IF
(
oldBackgroundThread
PR_GetCurrentThread
(
)
!
=
oldBackgroundThread
)
;
MOZ_ASSERT
(
!
mMessageLoop
)
;
mMessageLoop
=
MessageLoop
:
:
current
(
)
;
MOZ_ASSERT
(
mMessageLoop
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
this
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
RequestMessageLoopRunnable
to
main
thread
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
:
:
Run
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
sBackgroundPRThread
.
compareExchange
(
PR_GetCurrentThread
(
)
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
ForceCloseBackgroundActorsRunnable
:
:
Run
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
MOZ_ASSERT
(
mActorArray
)
;
if
(
NS_IsMainThread
(
)
)
{
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
return
NS_OK
;
}
AssertIsOnBackgroundThread
(
)
;
if
(
!
mActorArray
-
>
IsEmpty
(
)
)
{
nsTArray
<
ParentImpl
*
>
actorsToClose
(
*
mActorArray
)
;
for
(
uint32_t
index
=
0
;
index
<
actorsToClose
.
Length
(
)
;
index
+
+
)
{
actorsToClose
[
index
]
-
>
Close
(
)
;
}
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
this
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
ConnectActorRunnable
:
:
Run
(
)
{
AssertIsInMainOrSocketProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
ParentImpl
*
actor
;
mActor
.
forget
(
&
actor
)
;
Endpoint
<
PBackgroundParent
>
endpoint
=
std
:
:
move
(
mEndpoint
)
;
if
(
!
endpoint
.
Bind
(
actor
)
)
{
actor
-
>
Destroy
(
)
;
return
NS_ERROR_FAILURE
;
}
actor
-
>
SetLiveActorArray
(
mLiveActorArray
)
;
return
NS_OK
;
}
nsresult
ParentImpl
:
:
CreateActorHelper
:
:
BlockAndGetResults
(
nsIEventTarget
*
aMainEventTarget
RefPtr
<
ParentImpl
>
&
aParentActor
nsCOMPtr
<
nsIThread
>
&
aThread
)
{
AssertIsNotOnMainThread
(
)
;
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
this
)
)
;
}
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mWaiting
)
{
lock
.
Wait
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
mMainThreadResultCode
)
)
)
{
return
mMainThreadResultCode
;
}
aParentActor
=
std
:
:
move
(
mParentActor
)
;
aThread
=
std
:
:
move
(
mThread
)
;
return
NS_OK
;
}
nsresult
ParentImpl
:
:
CreateActorHelper
:
:
RunOnMainThread
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
sLiveActorCount
+
+
;
mParentActor
=
new
ParentImpl
(
)
;
mThread
=
sBackgroundThread
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
CreateActorHelper
:
:
Run
(
)
{
AssertIsOnMainThread
(
)
;
nsresult
rv
=
RunOnMainThread
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mMainThreadResultCode
=
rv
;
}
mozilla
:
:
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mWaiting
)
;
mWaiting
=
false
;
lock
.
Notify
(
)
;
return
NS_OK
;
}
void
ChildImpl
:
:
Startup
(
)
{
MOZ_ASSERT
(
sThreadLocalIndex
=
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
called
more
than
once
!
"
)
;
MOZ_ASSERT
(
sThreadLocalIndexForSocketProcess
=
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
called
more
than
once
!
"
)
;
PRStatus
status
=
PR_NewThreadPrivateIndex
(
&
sThreadLocalIndex
ThreadLocalDestructor
)
;
MOZ_RELEASE_ASSERT
(
status
=
=
PR_SUCCESS
"
PR_NewThreadPrivateIndex
failed
!
"
)
;
status
=
PR_NewThreadPrivateIndex
(
&
sThreadLocalIndexForSocketProcess
ThreadLocalDestructor
)
;
MOZ_RELEASE_ASSERT
(
status
=
=
PR_SUCCESS
"
PR_NewThreadPrivateIndex
failed
!
"
)
;
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
MOZ_ASSERT
(
sThreadLocalIndexForSocketProcess
!
=
kBadThreadLocalIndex
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
observerService
)
;
nsCOMPtr
<
nsIObserver
>
observer
=
new
ShutdownObserver
(
)
;
nsresult
rv
=
observerService
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
false
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
ChildImpl
:
:
ShutdownWithThreadLocalIndex
(
unsigned
int
aThreadLocalIndex
)
{
MOZ_ASSERT
(
aThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
ThreadLocalInfo
*
threadLocalInfo
;
#
ifdef
DEBUG
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
aThreadLocalIndex
)
)
;
MOZ_ASSERT
(
!
threadLocalInfo
)
;
#
endif
threadLocalInfo
=
aThreadLocalIndex
=
=
sThreadLocalIndex
?
sMainThreadInfo
:
sMainThreadInfoForSocketProcess
;
if
(
threadLocalInfo
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mClosed
)
;
threadLocalInfo
-
>
mClosed
=
true
;
#
endif
ThreadLocalDestructor
(
threadLocalInfo
)
;
if
(
aThreadLocalIndex
=
=
sThreadLocalIndex
)
{
sMainThreadInfo
=
nullptr
;
}
else
{
sMainThreadInfoForSocketProcess
=
nullptr
;
}
}
}
void
ChildImpl
:
:
Shutdown
(
)
{
AssertIsOnMainThread
(
)
;
if
(
sShutdownHasStarted
)
{
MOZ_ASSERT_IF
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
!
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
MOZ_ASSERT_IF
(
sThreadLocalIndexForSocketProcess
!
=
kBadThreadLocalIndex
!
PR_GetThreadPrivate
(
sThreadLocalIndexForSocketProcess
)
)
;
return
;
}
sShutdownHasStarted
=
true
;
ShutdownWithThreadLocalIndex
(
sThreadLocalIndex
)
;
if
(
sThreadLocalIndexForSocketProcess
!
=
kBadThreadLocalIndex
)
{
ShutdownWithThreadLocalIndex
(
sThreadLocalIndexForSocketProcess
)
;
}
}
ChildImpl
:
:
ThreadLocalInfo
*
ChildImpl
:
:
sMainThreadInfo
=
nullptr
;
ChildImpl
:
:
ThreadLocalInfo
*
ChildImpl
:
:
sMainThreadInfoForSocketProcess
=
nullptr
;
PBackgroundChild
*
ChildImpl
:
:
GetForCurrentThread
(
)
{
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
sMainThreadInfo
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
nullptr
;
}
return
threadLocalInfo
-
>
mActor
;
}
PBackgroundChild
*
ChildImpl
:
:
GetFromThreadInfo
(
nsIEventTarget
*
aMainEventTarget
ThreadLocalInfo
*
aThreadLocalInfo
)
{
MOZ_ASSERT
(
aThreadLocalInfo
)
;
if
(
aThreadLocalInfo
-
>
mActor
)
{
RefPtr
<
SendInitBackgroundRunnable
>
&
runnable
=
aThreadLocalInfo
-
>
mSendInitBackgroundRunnable
;
if
(
aMainEventTarget
&
&
runnable
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
return
aThreadLocalInfo
-
>
mActor
;
}
return
nullptr
;
}
PBackgroundChild
*
ChildImpl
:
:
GetOrCreateForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
!
aMainEventTarget
)
;
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
was
never
called
!
"
)
;
if
(
NS_IsMainThread
(
)
&
&
sShutdownHasStarted
)
{
return
nullptr
;
}
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
sMainThreadInfo
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
nsAutoPtr
<
ThreadLocalInfo
>
newInfo
(
new
ThreadLocalInfo
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
sMainThreadInfo
=
newInfo
;
}
else
{
if
(
PR_SetThreadPrivate
(
sThreadLocalIndex
newInfo
)
!
=
PR_SUCCESS
)
{
CRASH_IN_CHILD_PROCESS
(
"
PR_SetThreadPrivate
failed
!
"
)
;
return
nullptr
;
}
}
threadLocalInfo
=
newInfo
.
forget
(
)
;
}
PBackgroundChild
*
bgChild
=
GetFromThreadInfo
(
aMainEventTarget
threadLocalInfo
)
;
if
(
bgChild
)
{
return
bgChild
;
}
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
ChildImpl
>
strongActor
=
ParentImpl
:
:
CreateActorForSameProcess
(
aMainEventTarget
)
;
if
(
NS_WARN_IF
(
!
strongActor
)
)
{
return
nullptr
;
}
RefPtr
<
ChildImpl
>
&
actor
=
threadLocalInfo
-
>
mActor
;
strongActor
.
swap
(
actor
)
;
return
actor
;
}
RefPtr
<
ContentChild
>
content
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
content
)
;
if
(
content
-
>
IsShuttingDown
(
)
)
{
return
nullptr
;
}
Endpoint
<
PBackgroundParent
>
parent
;
Endpoint
<
PBackgroundChild
>
child
;
nsresult
rv
;
rv
=
PBackground
:
:
CreateEndpoints
(
content
-
>
OtherPid
(
)
base
:
:
GetCurrentProcId
(
)
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
nullptr
;
}
RefPtr
<
SendInitBackgroundRunnable
>
runnable
;
if
(
!
NS_IsMainThread
(
)
)
{
runnable
=
SendInitBackgroundRunnable
:
:
Create
(
std
:
:
move
(
parent
)
[
]
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
{
RefPtr
<
ContentChild
>
content
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
content
)
;
if
(
!
content
-
>
SendInitBackground
(
std
:
:
move
(
aParent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
}
}
)
;
if
(
!
runnable
)
{
return
nullptr
;
}
}
RefPtr
<
ChildImpl
>
strongActor
=
new
ChildImpl
(
)
;
if
(
!
child
.
Bind
(
strongActor
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
bind
ChildImpl
!
"
)
;
return
nullptr
;
}
strongActor
-
>
SetActorAlive
(
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
content
-
>
SendInitBackground
(
std
:
:
move
(
parent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
nullptr
;
}
}
else
{
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
runnable
)
)
;
}
threadLocalInfo
-
>
mSendInitBackgroundRunnable
=
runnable
;
}
RefPtr
<
ChildImpl
>
&
actor
=
threadLocalInfo
-
>
mActor
;
strongActor
.
swap
(
actor
)
;
return
actor
;
}
PBackgroundChild
*
ChildImpl
:
:
GetOrCreateSocketActorForCurrentThread
(
nsIEventTarget
*
aMainEventTarget
)
{
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
!
aMainEventTarget
)
;
MOZ_ASSERT
(
sThreadLocalIndexForSocketProcess
!
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
was
never
called
!
"
)
;
if
(
NS_IsMainThread
(
)
&
&
sShutdownHasStarted
)
{
return
nullptr
;
}
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
sMainThreadInfoForSocketProcess
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndexForSocketProcess
)
)
;
if
(
!
threadLocalInfo
)
{
nsAutoPtr
<
ThreadLocalInfo
>
newInfo
(
new
ThreadLocalInfo
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
sMainThreadInfoForSocketProcess
=
newInfo
;
}
else
{
if
(
PR_SetThreadPrivate
(
sThreadLocalIndexForSocketProcess
newInfo
)
!
=
PR_SUCCESS
)
{
CRASH_IN_CHILD_PROCESS
(
"
PR_SetThreadPrivate
failed
!
"
)
;
return
nullptr
;
}
}
threadLocalInfo
=
newInfo
.
forget
(
)
;
}
PBackgroundChild
*
bgChild
=
GetFromThreadInfo
(
aMainEventTarget
threadLocalInfo
)
;
if
(
bgChild
)
{
return
bgChild
;
}
RefPtr
<
SocketProcessBridgeChild
>
bridgeChild
=
SocketProcessBridgeChild
:
:
GetSingleton
(
)
;
if
(
!
bridgeChild
|
|
bridgeChild
-
>
IsShuttingDown
(
)
)
{
return
nullptr
;
}
Endpoint
<
PBackgroundParent
>
parent
;
Endpoint
<
PBackgroundChild
>
child
;
nsresult
rv
;
rv
=
PBackground
:
:
CreateEndpoints
(
bridgeChild
-
>
SocketProcessPid
(
)
base
:
:
GetCurrentProcId
(
)
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
nullptr
;
}
RefPtr
<
SendInitBackgroundRunnable
>
runnable
;
if
(
!
NS_IsMainThread
(
)
)
{
runnable
=
SendInitBackgroundRunnable
:
:
Create
(
std
:
:
move
(
parent
)
[
]
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
{
RefPtr
<
SocketProcessBridgeChild
>
bridgeChild
=
SocketProcessBridgeChild
:
:
GetSingleton
(
)
;
if
(
!
bridgeChild
-
>
SendInitBackground
(
std
:
:
move
(
aParent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
}
}
)
;
if
(
!
runnable
)
{
return
nullptr
;
}
}
RefPtr
<
ChildImpl
>
strongActor
=
new
ChildImpl
(
)
;
if
(
!
child
.
Bind
(
strongActor
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
bind
ChildImpl
!
"
)
;
return
nullptr
;
}
strongActor
-
>
SetActorAlive
(
)
;
if
(
NS_IsMainThread
(
)
)
{
if
(
!
bridgeChild
-
>
SendInitBackground
(
std
:
:
move
(
parent
)
)
)
{
NS_WARNING
(
"
Failed
to
create
top
level
actor
!
"
)
;
strongActor
-
>
Close
(
)
;
strongActor
-
>
AssertActorDestroyed
(
)
;
return
nullptr
;
}
}
else
{
if
(
aMainEventTarget
)
{
MOZ_ALWAYS_SUCCEEDS
(
aMainEventTarget
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
;
}
else
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
runnable
)
)
;
}
threadLocalInfo
-
>
mSendInitBackgroundRunnable
=
runnable
;
}
RefPtr
<
ChildImpl
>
&
actor
=
threadLocalInfo
-
>
mActor
;
strongActor
.
swap
(
actor
)
;
return
actor
;
}
void
ChildImpl
:
:
CloseThreadWithIndex
(
unsigned
int
aThreadLocalIndex
)
{
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
aThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mClosed
)
;
threadLocalInfo
-
>
mClosed
=
true
;
#
endif
DebugOnly
<
PRStatus
>
status
=
PR_SetThreadPrivate
(
aThreadLocalIndex
nullptr
)
;
MOZ_ASSERT
(
status
=
=
PR_SUCCESS
)
;
}
void
ChildImpl
:
:
CloseForCurrentThread
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
PBackground
for
the
main
thread
should
be
shut
down
via
"
"
ChildImpl
:
:
Shutdown
(
)
.
"
)
;
if
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
)
{
CloseThreadWithIndex
(
sThreadLocalIndex
)
;
}
if
(
sThreadLocalIndexForSocketProcess
!
=
kBadThreadLocalIndex
)
{
CloseThreadWithIndex
(
sThreadLocalIndexForSocketProcess
)
;
}
}
BackgroundChildImpl
:
:
ThreadLocal
*
ChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
{
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
was
never
called
!
"
)
;
auto
threadLocalInfo
=
NS_IsMainThread
(
)
?
sMainThreadInfo
:
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
nullptr
;
}
if
(
!
threadLocalInfo
-
>
mConsumerThreadLocal
)
{
threadLocalInfo
-
>
mConsumerThreadLocal
=
new
BackgroundChildImpl
:
:
ThreadLocal
(
)
;
}
return
threadLocalInfo
-
>
mConsumerThreadLocal
;
}
void
ChildImpl
:
:
ThreadLocalDestructor
(
void
*
aThreadLocal
)
{
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
aThreadLocal
)
;
if
(
threadLocalInfo
)
{
MOZ_ASSERT
(
threadLocalInfo
-
>
mClosed
)
;
if
(
threadLocalInfo
-
>
mActor
)
{
threadLocalInfo
-
>
mActor
-
>
Close
(
)
;
threadLocalInfo
-
>
mActor
-
>
AssertActorDestroyed
(
)
;
}
if
(
threadLocalInfo
-
>
mSendInitBackgroundRunnable
)
{
threadLocalInfo
-
>
mSendInitBackgroundRunnable
-
>
ClearEventTarget
(
)
;
}
delete
threadLocalInfo
;
}
}
void
ChildImpl
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnOwningThread
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mActorDestroyed
)
;
mActorDestroyed
=
true
;
#
endif
BackgroundChildImpl
:
:
ActorDestroy
(
aWhy
)
;
}
NS_IMPL_ISUPPORTS
(
ChildImpl
:
:
ShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ChildImpl
:
:
ShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
)
)
;
ChildImpl
:
:
Shutdown
(
)
;
return
NS_OK
;
}
already_AddRefed
<
ChildImpl
:
:
SendInitBackgroundRunnable
>
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Create
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
std
:
:
function
<
void
(
Endpoint
<
PBackgroundParent
>
&
&
aParent
)
>
&
&
aFunc
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
SendInitBackgroundRunnable
>
runnable
=
new
SendInitBackgroundRunnable
(
std
:
:
move
(
aParent
)
std
:
:
move
(
aFunc
)
)
;
WorkerPrivate
*
workerPrivate
=
mozilla
:
:
dom
:
:
GetCurrentThreadWorkerPrivate
(
)
;
if
(
!
workerPrivate
)
{
return
runnable
.
forget
(
)
;
}
workerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
runnable
-
>
mWorkerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
ChildImpl
:
:
SendInitBackgroundRunnable
"
)
;
if
(
NS_WARN_IF
(
!
runnable
-
>
mWorkerRef
)
)
{
return
nullptr
;
}
return
runnable
.
forget
(
)
;
}
NS_IMETHODIMP
ChildImpl
:
:
SendInitBackgroundRunnable
:
:
Run
(
)
{
if
(
NS_IsMainThread
(
)
)
{
if
(
mSentInitBackground
)
{
return
NS_OK
;
}
mSentInitBackground
=
true
;
mSendInitfunc
(
std
:
:
move
(
mParent
)
)
;
nsCOMPtr
<
nsISerialEventTarget
>
owningEventTarget
;
{
mozilla
:
:
MutexAutoLock
lock
(
mMutex
)
;
owningEventTarget
=
mOwningEventTarget
;
}
if
(
!
owningEventTarget
)
{
return
NS_OK
;
}
nsresult
rv
=
owningEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
ClearEventTarget
(
)
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
NS_OK
;
}
threadLocalInfo
-
>
mSendInitBackgroundRunnable
=
nullptr
;
return
NS_OK
;
}
