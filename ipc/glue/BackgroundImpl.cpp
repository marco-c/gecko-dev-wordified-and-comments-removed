#
include
"
BackgroundChild
.
h
"
#
include
"
BackgroundParent
.
h
"
#
include
"
BackgroundChildImpl
.
h
"
#
include
"
BackgroundParentImpl
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
FileDescriptor
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
InputStreamUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolTypes
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIIPCBackgroundChildCreateCallback
.
h
"
#
include
"
nsIMutable
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
include
"
prthread
.
h
"
#
ifdef
RELEASE_OR_BETA
#
define
THREADSAFETY_ASSERT
MOZ_ASSERT
#
else
#
define
THREADSAFETY_ASSERT
MOZ_RELEASE_ASSERT
#
endif
#
define
CRASH_IN_CHILD_PROCESS
(
_msg
)
\
do
{
\
if
(
XRE_IsParentProcess
(
)
)
{
\
MOZ_ASSERT
(
false
_msg
)
;
\
}
else
{
\
MOZ_CRASH
(
_msg
)
;
\
}
\
}
\
while
(
0
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
namespace
{
void
AssertIsInMainProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
void
AssertIsInChildProcess
(
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
}
void
AssertIsOnMainThread
(
)
{
THREADSAFETY_ASSERT
(
NS_IsMainThread
(
)
)
;
}
class
ParentImpl
final
:
public
BackgroundParentImpl
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundParent
;
public
:
class
CreateCallback
;
private
:
class
ShutdownObserver
;
class
RequestMessageLoopRunnable
;
class
ShutdownBackgroundThreadRunnable
;
class
ForceCloseBackgroundActorsRunnable
;
class
CreateCallbackRunnable
;
class
ConnectActorRunnable
;
struct
MOZ_STACK_CLASS
TimerCallbackClosure
{
nsIThread
*
mThread
;
nsTArray
<
ParentImpl
*
>
*
mLiveActors
;
TimerCallbackClosure
(
nsIThread
*
aThread
nsTArray
<
ParentImpl
*
>
*
aLiveActors
)
:
mThread
(
aThread
)
mLiveActors
(
aLiveActors
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aThread
)
;
MOZ_ASSERT
(
aLiveActors
)
;
}
}
;
static
const
uint32_t
kShutdownTimerDelayMS
=
10000
;
static
StaticRefPtr
<
nsIThread
>
sBackgroundThread
;
static
nsTArray
<
ParentImpl
*
>
*
sLiveActorsForBackgroundThread
;
static
StaticRefPtr
<
nsITimer
>
sShutdownTimer
;
static
Atomic
<
PRThread
*
>
sBackgroundPRThread
;
static
MessageLoop
*
sBackgroundThreadMessageLoop
;
static
uint64_t
sLiveActorCount
;
static
bool
sShutdownObserverRegistered
;
static
bool
sShutdownHasStarted
;
static
StaticAutoPtr
<
nsTArray
<
RefPtr
<
CreateCallback
>
>
>
sPendingCallbacks
;
RefPtr
<
ContentParent
>
mContent
;
nsTArray
<
ParentImpl
*
>
*
mLiveActorArray
;
const
bool
mIsOtherProcessActor
;
bool
mActorDestroyed
;
public
:
static
bool
CreateActorForSameProcess
(
CreateCallback
*
aCallback
)
;
static
bool
IsOnBackgroundThread
(
)
{
return
PR_GetCurrentThread
(
)
=
=
sBackgroundPRThread
;
}
static
void
AssertIsOnBackgroundThread
(
)
{
THREADSAFETY_ASSERT
(
IsOnBackgroundThread
(
)
)
;
}
NS_INLINE_DECL_REFCOUNTING
(
ParentImpl
)
void
Destroy
(
)
;
private
:
static
bool
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
;
static
already_AddRefed
<
ContentParent
>
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
;
static
intptr_t
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
;
static
uint64_t
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
;
static
bool
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
;
static
bool
CreateBackgroundThread
(
)
;
static
void
ShutdownBackgroundThread
(
)
;
static
void
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
ParentImpl
(
)
:
mLiveActorArray
(
nullptr
)
mIsOtherProcessActor
(
false
)
mActorDestroyed
(
false
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
}
explicit
ParentImpl
(
ContentParent
*
aContent
)
:
mContent
(
aContent
)
mLiveActorArray
(
nullptr
)
mIsOtherProcessActor
(
true
)
mActorDestroyed
(
false
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aContent
)
;
}
~
ParentImpl
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mContent
)
;
}
void
MainThreadActorDestroy
(
)
;
void
SetLiveActorArray
(
nsTArray
<
ParentImpl
*
>
*
aLiveActorArray
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aLiveActorArray
)
;
MOZ_ASSERT
(
!
aLiveActorArray
-
>
Contains
(
this
)
)
;
MOZ_ASSERT
(
!
mLiveActorArray
)
;
MOZ_ASSERT
(
mIsOtherProcessActor
)
;
mLiveActorArray
=
aLiveActorArray
;
mLiveActorArray
-
>
AppendElement
(
this
)
;
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
}
;
class
ChildImpl
final
:
public
BackgroundChildImpl
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundChild
;
friend
class
mozilla
:
:
ipc
:
:
BackgroundChildImpl
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
class
ShutdownObserver
;
class
CreateActorRunnable
;
class
ParentCreateCallback
;
class
AlreadyCreatedCallbackRunnable
;
class
FailedCreateCallbackRunnable
;
class
OpenChildProcessActorRunnable
;
class
OpenMainProcessActorRunnable
;
static
const
unsigned
int
kBadThreadLocalIndex
=
static_cast
<
unsigned
int
>
(
-
1
)
;
static
unsigned
int
sThreadLocalIndex
;
struct
ThreadLocalInfo
{
explicit
ThreadLocalInfo
(
nsIIPCBackgroundChildCreateCallback
*
aCallback
)
#
ifdef
DEBUG
:
mClosed
(
false
)
#
endif
{
mCallbacks
.
AppendElement
(
aCallback
)
;
}
RefPtr
<
ChildImpl
>
mActor
;
nsTArray
<
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
>
mCallbacks
;
nsAutoPtr
<
BackgroundChildImpl
:
:
ThreadLocal
>
mConsumerThreadLocal
;
#
ifdef
DEBUG
bool
mClosed
;
#
endif
}
;
static
StaticAutoPtr
<
nsTArray
<
nsCOMPtr
<
nsIEventTarget
>
>
>
sPendingTargets
;
static
bool
sShutdownHasStarted
;
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
nsISerialEventTarget
*
mBoundEventTarget
;
#
endif
#
ifdef
DEBUG
bool
mActorDestroyed
;
#
endif
public
:
static
bool
OpenProtocolOnMainThread
(
nsIEventTarget
*
aEventTarget
)
;
static
void
Shutdown
(
)
;
void
AssertIsOnBoundThread
(
)
{
THREADSAFETY_ASSERT
(
mBoundEventTarget
)
;
#
ifdef
RELEASE_OR_BETA
DebugOnly
<
bool
>
current
;
#
else
bool
current
;
#
endif
THREADSAFETY_ASSERT
(
NS_SUCCEEDED
(
mBoundEventTarget
-
>
IsOnCurrentThread
(
&
current
)
)
)
;
THREADSAFETY_ASSERT
(
current
)
;
}
void
AssertActorDestroyed
(
)
{
MOZ_ASSERT
(
mActorDestroyed
"
ChildImpl
:
:
ActorDestroy
not
called
in
time
"
)
;
}
ChildImpl
(
)
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
:
mBoundEventTarget
(
nullptr
)
#
endif
#
ifdef
DEBUG
mActorDestroyed
(
false
)
#
endif
{
AssertIsOnMainThread
(
)
;
}
NS_INLINE_DECL_REFCOUNTING
(
ChildImpl
)
private
:
static
void
Startup
(
)
;
static
void
Alloc
(
Endpoint
<
PBackgroundChild
>
&
&
aEndpoint
)
;
static
PBackgroundChild
*
GetForCurrentThread
(
)
;
static
bool
GetOrCreateForCurrentThread
(
nsIIPCBackgroundChildCreateCallback
*
aCallback
)
;
static
PBackgroundChild
*
GetOrCreateForCurrentThread
(
)
;
static
void
CloseForCurrentThread
(
)
;
static
BackgroundChildImpl
:
:
ThreadLocal
*
GetThreadLocalForCurrentThread
(
)
;
static
void
ThreadLocalDestructor
(
void
*
aThreadLocal
)
{
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
aThreadLocal
)
;
if
(
threadLocalInfo
)
{
MOZ_ASSERT
(
threadLocalInfo
-
>
mClosed
)
;
if
(
threadLocalInfo
-
>
mActor
)
{
threadLocalInfo
-
>
mActor
-
>
Close
(
)
;
threadLocalInfo
-
>
mActor
-
>
AssertActorDestroyed
(
)
;
if
(
!
NS_IsMainThread
(
)
)
{
ChildImpl
*
actor
;
threadLocalInfo
-
>
mActor
.
forget
(
&
actor
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ChildImpl
:
:
Release
"
actor
&
ChildImpl
:
:
Release
)
)
)
;
}
}
delete
threadLocalInfo
;
}
}
static
void
DispatchFailureCallback
(
nsIEventTarget
*
aEventTarget
)
;
~
ChildImpl
(
)
{
AssertActorDestroyed
(
)
;
}
void
SetBoundThread
(
)
{
THREADSAFETY_ASSERT
(
!
mBoundEventTarget
)
;
#
if
defined
(
DEBUG
)
|
|
!
defined
(
RELEASE_OR_BETA
)
mBoundEventTarget
=
GetCurrentThreadSerialEventTarget
(
)
;
#
endif
THREADSAFETY_ASSERT
(
mBoundEventTarget
)
;
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
override
;
static
already_AddRefed
<
nsIIPCBackgroundChildCreateCallback
>
GetNextCallback
(
)
;
}
;
class
ParentImpl
:
:
ShutdownObserver
final
:
public
nsIObserver
{
public
:
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ParentImpl
:
:
RequestMessageLoopRunnable
final
:
public
Runnable
{
nsCOMPtr
<
nsIThread
>
mTargetThread
;
MessageLoop
*
mMessageLoop
;
public
:
explicit
RequestMessageLoopRunnable
(
nsIThread
*
aTargetThread
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
RequestMessageLoopRunnable
"
)
mTargetThread
(
aTargetThread
)
mMessageLoop
(
nullptr
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aTargetThread
)
;
}
private
:
~
RequestMessageLoopRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
final
:
public
Runnable
{
public
:
ShutdownBackgroundThreadRunnable
(
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
"
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
}
private
:
~
ShutdownBackgroundThreadRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
ForceCloseBackgroundActorsRunnable
final
:
public
Runnable
{
nsTArray
<
ParentImpl
*
>
*
mActorArray
;
public
:
explicit
ForceCloseBackgroundActorsRunnable
(
nsTArray
<
ParentImpl
*
>
*
aActorArray
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
ForceCloseBackgroundActorsRunnable
"
)
mActorArray
(
aActorArray
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aActorArray
)
;
}
private
:
~
ForceCloseBackgroundActorsRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
CreateCallbackRunnable
final
:
public
Runnable
{
RefPtr
<
CreateCallback
>
mCallback
;
public
:
explicit
CreateCallbackRunnable
(
CreateCallback
*
aCallback
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
CreateCallbackRunnable
"
)
mCallback
(
aCallback
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aCallback
)
;
}
private
:
~
CreateCallbackRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ParentImpl
:
:
ConnectActorRunnable
final
:
public
Runnable
{
RefPtr
<
ParentImpl
>
mActor
;
Endpoint
<
PBackgroundParent
>
mEndpoint
;
nsTArray
<
ParentImpl
*
>
*
mLiveActorArray
;
public
:
ConnectActorRunnable
(
ParentImpl
*
aActor
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
nsTArray
<
ParentImpl
*
>
*
aLiveActorArray
)
:
Runnable
(
"
Background
:
:
ParentImpl
:
:
ConnectActorRunnable
"
)
mActor
(
aActor
)
mEndpoint
(
Move
(
aEndpoint
)
)
mLiveActorArray
(
aLiveActorArray
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mEndpoint
.
IsValid
(
)
)
;
MOZ_ASSERT
(
aLiveActorArray
)
;
}
private
:
~
ConnectActorRunnable
(
)
{
AssertIsInMainProcess
(
)
;
}
NS_DECL_NSIRUNNABLE
}
;
class
NS_NO_VTABLE
ParentImpl
:
:
CreateCallback
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
CreateCallback
)
virtual
void
Success
(
already_AddRefed
<
ParentImpl
>
aActor
MessageLoop
*
aMessageLoop
)
=
0
;
virtual
void
Failure
(
)
=
0
;
protected
:
virtual
~
CreateCallback
(
)
{
}
}
;
class
ChildImpl
:
:
ShutdownObserver
final
:
public
nsIObserver
{
public
:
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ShutdownObserver
(
)
{
AssertIsOnMainThread
(
)
;
}
}
;
class
ChildImpl
:
:
CreateActorRunnable
final
:
public
Runnable
{
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
public
:
CreateActorRunnable
(
)
:
Runnable
(
"
Background
:
:
ChildImpl
:
:
CreateActorRunnable
"
)
mEventTarget
(
NS_GetCurrentThread
(
)
)
{
MOZ_ASSERT
(
mEventTarget
)
;
}
private
:
~
CreateActorRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ChildImpl
:
:
ParentCreateCallback
final
:
public
ParentImpl
:
:
CreateCallback
{
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
public
:
explicit
ParentCreateCallback
(
nsIEventTarget
*
aEventTarget
)
:
mEventTarget
(
aEventTarget
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aEventTarget
)
;
}
private
:
~
ParentCreateCallback
(
)
{
}
virtual
void
Success
(
already_AddRefed
<
ParentImpl
>
aActor
MessageLoop
*
aMessageLoop
)
override
;
virtual
void
Failure
(
)
override
;
}
;
class
ChildImpl
:
:
AlreadyCreatedCallbackRunnable
final
:
public
CancelableRunnable
{
public
:
AlreadyCreatedCallbackRunnable
(
)
:
CancelableRunnable
(
"
Background
:
:
ChildImpl
:
:
AlreadyCreatedCallbackRunnable
"
)
{
}
protected
:
virtual
~
AlreadyCreatedCallbackRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
nsresult
Cancel
(
)
override
;
}
;
class
ChildImpl
:
:
FailedCreateCallbackRunnable
final
:
public
Runnable
{
public
:
FailedCreateCallbackRunnable
(
)
:
Runnable
(
"
Background
:
:
ChildImpl
:
:
FailedCreateCallbackRunnable
"
)
{
}
protected
:
virtual
~
FailedCreateCallbackRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
class
ChildImpl
:
:
OpenChildProcessActorRunnable
final
:
public
Runnable
{
RefPtr
<
ChildImpl
>
mActor
;
Endpoint
<
PBackgroundChild
>
mEndpoint
;
public
:
OpenChildProcessActorRunnable
(
already_AddRefed
<
ChildImpl
>
&
&
aActor
Endpoint
<
PBackgroundChild
>
&
&
aEndpoint
)
:
Runnable
(
"
Background
:
:
ChildImpl
:
:
OpenChildProcessActorRunnable
"
)
mActor
(
aActor
)
mEndpoint
(
Move
(
aEndpoint
)
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mActor
)
;
MOZ_ASSERT
(
mEndpoint
.
IsValid
(
)
)
;
}
private
:
~
OpenChildProcessActorRunnable
(
)
{
if
(
mEndpoint
.
IsValid
(
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Leaking
endpoint
!
"
)
;
}
}
NS_DECL_NSIRUNNABLE
}
;
class
ChildImpl
:
:
OpenMainProcessActorRunnable
final
:
public
Runnable
{
RefPtr
<
ChildImpl
>
mActor
;
RefPtr
<
ParentImpl
>
mParentActor
;
MessageLoop
*
mParentMessageLoop
;
public
:
OpenMainProcessActorRunnable
(
already_AddRefed
<
ChildImpl
>
&
&
aChildActor
already_AddRefed
<
ParentImpl
>
aParentActor
MessageLoop
*
aParentMessageLoop
)
:
Runnable
(
"
ChildImpl
:
:
OpenMainProcessActorRunnable
"
)
mActor
(
aChildActor
)
mParentActor
(
aParentActor
)
mParentMessageLoop
(
aParentMessageLoop
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mParentActor
)
;
MOZ_ASSERT
(
aParentMessageLoop
)
;
}
private
:
~
OpenMainProcessActorRunnable
(
)
{
}
NS_DECL_NSIRUNNABLE
}
;
}
namespace
mozilla
{
namespace
ipc
{
bool
IsOnBackgroundThread
(
)
{
return
ParentImpl
:
:
IsOnBackgroundThread
(
)
;
}
#
ifdef
DEBUG
void
AssertIsOnBackgroundThread
(
)
{
ParentImpl
:
:
AssertIsOnBackgroundThread
(
)
;
}
#
endif
}
}
bool
BackgroundParent
:
:
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
IsOtherProcessActor
(
aBackgroundActor
)
;
}
already_AddRefed
<
ContentParent
>
BackgroundParent
:
:
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetContentParent
(
aBackgroundActor
)
;
}
intptr_t
BackgroundParent
:
:
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetRawContentParentForComparison
(
aBackgroundActor
)
;
}
uint64_t
BackgroundParent
:
:
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
{
return
ParentImpl
:
:
GetChildID
(
aBackgroundActor
)
;
}
bool
BackgroundParent
:
:
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
{
return
ParentImpl
:
:
Alloc
(
aContent
Move
(
aEndpoint
)
)
;
}
void
BackgroundChild
:
:
Startup
(
)
{
ChildImpl
:
:
Startup
(
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetForCurrentThread
(
)
{
return
ChildImpl
:
:
GetForCurrentThread
(
)
;
}
bool
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
nsIIPCBackgroundChildCreateCallback
*
aCallback
)
{
return
ChildImpl
:
:
GetOrCreateForCurrentThread
(
aCallback
)
;
}
PBackgroundChild
*
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
{
return
ChildImpl
:
:
GetOrCreateForCurrentThread
(
)
;
}
void
BackgroundChild
:
:
CloseForCurrentThread
(
)
{
ChildImpl
:
:
CloseForCurrentThread
(
)
;
}
BackgroundChildImpl
:
:
ThreadLocal
*
BackgroundChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
{
return
ChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
;
}
StaticRefPtr
<
nsIThread
>
ParentImpl
:
:
sBackgroundThread
;
nsTArray
<
ParentImpl
*
>
*
ParentImpl
:
:
sLiveActorsForBackgroundThread
;
StaticRefPtr
<
nsITimer
>
ParentImpl
:
:
sShutdownTimer
;
Atomic
<
PRThread
*
>
ParentImpl
:
:
sBackgroundPRThread
;
MessageLoop
*
ParentImpl
:
:
sBackgroundThreadMessageLoop
=
nullptr
;
uint64_t
ParentImpl
:
:
sLiveActorCount
=
0
;
bool
ParentImpl
:
:
sShutdownObserverRegistered
=
false
;
bool
ParentImpl
:
:
sShutdownHasStarted
=
false
;
StaticAutoPtr
<
nsTArray
<
RefPtr
<
ParentImpl
:
:
CreateCallback
>
>
>
ParentImpl
:
:
sPendingCallbacks
;
unsigned
int
ChildImpl
:
:
sThreadLocalIndex
=
kBadThreadLocalIndex
;
StaticAutoPtr
<
nsTArray
<
nsCOMPtr
<
nsIEventTarget
>
>
>
ChildImpl
:
:
sPendingTargets
;
bool
ChildImpl
:
:
sShutdownHasStarted
=
false
;
bool
ParentImpl
:
:
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
return
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
-
>
mIsOtherProcessActor
;
}
already_AddRefed
<
ContentParent
>
ParentImpl
:
:
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetContentParent
called
after
ActorDestroy
was
called
!
"
)
;
return
nullptr
;
}
if
(
actor
-
>
mContent
)
{
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ContentParent
:
:
AddRef
"
actor
-
>
mContent
&
ContentParent
:
:
AddRef
)
)
)
;
}
return
already_AddRefed
<
ContentParent
>
(
actor
-
>
mContent
.
get
(
)
)
;
}
intptr_t
ParentImpl
:
:
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetRawContentParentForComparison
called
after
ActorDestroy
was
"
"
called
!
"
)
;
return
intptr_t
(
-
1
)
;
}
return
intptr_t
(
static_cast
<
nsIContentParent
*
>
(
actor
-
>
mContent
.
get
(
)
)
)
;
}
uint64_t
ParentImpl
:
:
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aBackgroundActor
)
;
auto
actor
=
static_cast
<
ParentImpl
*
>
(
aBackgroundActor
)
;
if
(
actor
-
>
mActorDestroyed
)
{
MOZ_ASSERT
(
false
"
GetContentParent
called
after
ActorDestroy
was
called
!
"
)
;
return
0
;
}
if
(
actor
-
>
mContent
)
{
return
actor
-
>
mContent
-
>
ChildID
(
)
;
}
return
0
;
}
bool
ParentImpl
:
:
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aEndpoint
.
IsValid
(
)
)
;
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
false
;
}
MOZ_ASSERT
(
sLiveActorsForBackgroundThread
)
;
sLiveActorCount
+
+
;
RefPtr
<
ParentImpl
>
actor
=
new
ParentImpl
(
aContent
)
;
nsCOMPtr
<
nsIRunnable
>
connectRunnable
=
new
ConnectActorRunnable
(
actor
Move
(
aEndpoint
)
sLiveActorsForBackgroundThread
)
;
if
(
NS_FAILED
(
sBackgroundThread
-
>
Dispatch
(
connectRunnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
connect
runnable
!
"
)
;
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
return
false
;
}
return
true
;
}
bool
ParentImpl
:
:
CreateActorForSameProcess
(
CreateCallback
*
aCallback
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aCallback
)
;
if
(
!
sBackgroundThread
&
&
!
CreateBackgroundThread
(
)
)
{
NS_WARNING
(
"
Failed
to
create
background
thread
!
"
)
;
return
false
;
}
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
sLiveActorCount
+
+
;
if
(
sBackgroundThreadMessageLoop
)
{
nsCOMPtr
<
nsIRunnable
>
callbackRunnable
=
new
CreateCallbackRunnable
(
aCallback
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
callbackRunnable
)
)
;
return
true
;
}
if
(
!
sPendingCallbacks
)
{
sPendingCallbacks
=
new
nsTArray
<
RefPtr
<
CreateCallback
>
>
(
)
;
}
sPendingCallbacks
-
>
AppendElement
(
aCallback
)
;
return
true
;
}
bool
ParentImpl
:
:
CreateBackgroundThread
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
sBackgroundThread
)
;
MOZ_ASSERT
(
!
sLiveActorsForBackgroundThread
)
;
if
(
sShutdownHasStarted
)
{
NS_WARNING
(
"
Trying
to
create
background
thread
after
shutdown
has
"
"
already
begun
!
"
)
;
return
false
;
}
nsCOMPtr
<
nsITimer
>
newShutdownTimer
;
if
(
!
sShutdownTimer
)
{
nsresult
rv
;
newShutdownTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
}
if
(
!
sShutdownObserverRegistered
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
return
false
;
}
nsCOMPtr
<
nsIObserver
>
observer
=
new
ShutdownObserver
(
)
;
nsresult
rv
=
obs
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
sShutdownObserverRegistered
=
true
;
}
nsCOMPtr
<
nsIThread
>
thread
;
if
(
NS_FAILED
(
NS_NewNamedThread
(
"
IPDL
Background
"
getter_AddRefs
(
thread
)
)
)
)
{
NS_WARNING
(
"
NS_NewNamedThread
failed
!
"
)
;
return
false
;
}
nsCOMPtr
<
nsIRunnable
>
messageLoopRunnable
=
new
RequestMessageLoopRunnable
(
thread
)
;
if
(
NS_FAILED
(
thread
-
>
Dispatch
(
messageLoopRunnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
RequestMessageLoopRunnable
!
"
)
;
return
false
;
}
sBackgroundThread
=
thread
;
sLiveActorsForBackgroundThread
=
new
nsTArray
<
ParentImpl
*
>
(
1
)
;
if
(
!
sShutdownTimer
)
{
MOZ_ASSERT
(
newShutdownTimer
)
;
sShutdownTimer
=
newShutdownTimer
;
}
return
true
;
}
void
ParentImpl
:
:
ShutdownBackgroundThread
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
!
sBackgroundThread
!
sBackgroundThreadMessageLoop
)
;
MOZ_ASSERT
(
sShutdownHasStarted
)
;
MOZ_ASSERT_IF
(
!
sBackgroundThread
!
sLiveActorCount
)
;
MOZ_ASSERT_IF
(
sBackgroundThread
sShutdownTimer
)
;
if
(
sPendingCallbacks
)
{
if
(
!
sPendingCallbacks
-
>
IsEmpty
(
)
)
{
nsTArray
<
RefPtr
<
CreateCallback
>
>
callbacks
;
sPendingCallbacks
-
>
SwapElements
(
callbacks
)
;
for
(
uint32_t
index
=
0
;
index
<
callbacks
.
Length
(
)
;
index
+
+
)
{
RefPtr
<
CreateCallback
>
callback
;
callbacks
[
index
]
.
swap
(
callback
)
;
MOZ_ASSERT
(
callback
)
;
callback
-
>
Failure
(
)
;
}
}
sPendingCallbacks
=
nullptr
;
}
nsCOMPtr
<
nsITimer
>
shutdownTimer
=
sShutdownTimer
.
get
(
)
;
sShutdownTimer
=
nullptr
;
if
(
sBackgroundThread
)
{
nsCOMPtr
<
nsIThread
>
thread
=
sBackgroundThread
.
get
(
)
;
sBackgroundThread
=
nullptr
;
nsAutoPtr
<
nsTArray
<
ParentImpl
*
>
>
liveActors
(
sLiveActorsForBackgroundThread
)
;
sLiveActorsForBackgroundThread
=
nullptr
;
sBackgroundThreadMessageLoop
=
nullptr
;
MOZ_ASSERT_IF
(
!
sShutdownHasStarted
!
sLiveActorCount
)
;
if
(
sLiveActorCount
)
{
TimerCallbackClosure
closure
(
thread
liveActors
)
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownTimer
-
>
InitWithNamedFuncCallback
(
&
ShutdownTimerCallback
&
closure
kShutdownTimerDelayMS
nsITimer
:
:
TYPE_ONE_SHOT
"
ParentImpl
:
:
ShutdownTimerCallback
"
)
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
sLiveActorCount
;
}
)
;
MOZ_ASSERT
(
liveActors
-
>
IsEmpty
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
shutdownTimer
-
>
Cancel
(
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
shutdownRunnable
=
new
ShutdownBackgroundThreadRunnable
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
thread
-
>
Dispatch
(
shutdownRunnable
NS_DISPATCH_NORMAL
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
thread
-
>
Shutdown
(
)
)
;
}
}
void
ParentImpl
:
:
ShutdownTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
sShutdownHasStarted
)
;
MOZ_ASSERT
(
sLiveActorCount
)
;
auto
closure
=
static_cast
<
TimerCallbackClosure
*
>
(
aClosure
)
;
MOZ_ASSERT
(
closure
)
;
sLiveActorCount
+
+
;
nsCOMPtr
<
nsIRunnable
>
forceCloseRunnable
=
new
ForceCloseBackgroundActorsRunnable
(
closure
-
>
mLiveActors
)
;
MOZ_ALWAYS_SUCCEEDS
(
closure
-
>
mThread
-
>
Dispatch
(
forceCloseRunnable
NS_DISPATCH_NORMAL
)
)
;
}
void
ParentImpl
:
:
Destroy
(
)
{
AssertIsInMainProcess
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
NewNonOwningRunnableMethod
(
"
ParentImpl
:
:
MainThreadActorDestroy
"
this
&
ParentImpl
:
:
MainThreadActorDestroy
)
)
)
;
}
void
ParentImpl
:
:
MainThreadActorDestroy
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT_IF
(
mIsOtherProcessActor
mContent
)
;
MOZ_ASSERT_IF
(
!
mIsOtherProcessActor
!
mContent
)
;
mContent
=
nullptr
;
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
Release
(
)
;
}
void
ParentImpl
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mActorDestroyed
)
;
MOZ_ASSERT_IF
(
mIsOtherProcessActor
mLiveActorArray
)
;
BackgroundParentImpl
:
:
ActorDestroy
(
aWhy
)
;
mActorDestroyed
=
true
;
if
(
mLiveActorArray
)
{
MOZ_ALWAYS_TRUE
(
mLiveActorArray
-
>
RemoveElement
(
this
)
)
;
mLiveActorArray
=
nullptr
;
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
NewNonOwningRunnableMethod
(
"
ParentImpl
:
:
Destroy
"
this
&
ParentImpl
:
:
Destroy
)
)
)
;
}
NS_IMPL_ISUPPORTS
(
ParentImpl
:
:
ShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ParentImpl
:
:
ShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
sShutdownHasStarted
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
)
)
;
sShutdownHasStarted
=
true
;
ChildImpl
:
:
Shutdown
(
)
;
ShutdownBackgroundThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
RequestMessageLoopRunnable
:
:
Run
(
)
{
AssertIsInMainProcess
(
)
;
MOZ_ASSERT
(
mTargetThread
)
;
if
(
NS_IsMainThread
(
)
)
{
MOZ_ASSERT
(
mMessageLoop
)
;
if
(
!
sBackgroundThread
|
|
!
SameCOMIdentity
(
mTargetThread
.
get
(
)
sBackgroundThread
.
get
(
)
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
sBackgroundThreadMessageLoop
)
;
sBackgroundThreadMessageLoop
=
mMessageLoop
;
if
(
sPendingCallbacks
&
&
!
sPendingCallbacks
-
>
IsEmpty
(
)
)
{
nsTArray
<
RefPtr
<
CreateCallback
>
>
callbacks
;
sPendingCallbacks
-
>
SwapElements
(
callbacks
)
;
for
(
uint32_t
index
=
0
;
index
<
callbacks
.
Length
(
)
;
index
+
+
)
{
MOZ_ASSERT
(
callbacks
[
index
]
)
;
nsCOMPtr
<
nsIRunnable
>
callbackRunnable
=
new
CreateCallbackRunnable
(
callbacks
[
index
]
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThread
(
callbackRunnable
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
callback
runnable
!
"
)
;
}
}
}
return
NS_OK
;
}
#
ifdef
DEBUG
{
bool
correctThread
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mTargetThread
-
>
IsOnCurrentThread
(
&
correctThread
)
)
)
;
MOZ_ASSERT
(
correctThread
)
;
}
#
endif
DebugOnly
<
PRThread
*
>
oldBackgroundThread
=
sBackgroundPRThread
.
exchange
(
PR_GetCurrentThread
(
)
)
;
MOZ_ASSERT_IF
(
oldBackgroundThread
PR_GetCurrentThread
(
)
!
=
oldBackgroundThread
)
;
MOZ_ASSERT
(
!
mMessageLoop
)
;
mMessageLoop
=
MessageLoop
:
:
current
(
)
;
MOZ_ASSERT
(
mMessageLoop
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
this
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
RequestMessageLoopRunnable
to
main
thread
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
ShutdownBackgroundThreadRunnable
:
:
Run
(
)
{
AssertIsInMainProcess
(
)
;
sBackgroundPRThread
.
compareExchange
(
PR_GetCurrentThread
(
)
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
ForceCloseBackgroundActorsRunnable
:
:
Run
(
)
{
AssertIsInMainProcess
(
)
;
MOZ_ASSERT
(
mActorArray
)
;
if
(
NS_IsMainThread
(
)
)
{
MOZ_ASSERT
(
sLiveActorCount
)
;
sLiveActorCount
-
-
;
return
NS_OK
;
}
AssertIsOnBackgroundThread
(
)
;
if
(
!
mActorArray
-
>
IsEmpty
(
)
)
{
nsTArray
<
ParentImpl
*
>
actorsToClose
(
*
mActorArray
)
;
for
(
uint32_t
index
=
0
;
index
<
actorsToClose
.
Length
(
)
;
index
+
+
)
{
actorsToClose
[
index
]
-
>
Close
(
)
;
}
}
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
this
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
CreateCallbackRunnable
:
:
Run
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
sBackgroundThreadMessageLoop
)
;
MOZ_ASSERT
(
mCallback
)
;
RefPtr
<
CreateCallback
>
callback
;
mCallback
.
swap
(
callback
)
;
RefPtr
<
ParentImpl
>
actor
=
new
ParentImpl
(
)
;
callback
-
>
Success
(
actor
.
forget
(
)
sBackgroundThreadMessageLoop
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ParentImpl
:
:
ConnectActorRunnable
:
:
Run
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnBackgroundThread
(
)
;
ParentImpl
*
actor
;
mActor
.
forget
(
&
actor
)
;
Endpoint
<
PBackgroundParent
>
endpoint
=
Move
(
mEndpoint
)
;
if
(
!
endpoint
.
Bind
(
actor
)
)
{
actor
-
>
Destroy
(
)
;
return
NS_ERROR_FAILURE
;
}
actor
-
>
SetLiveActorArray
(
mLiveActorArray
)
;
return
NS_OK
;
}
void
ChildImpl
:
:
Startup
(
)
{
MOZ_ASSERT
(
sThreadLocalIndex
=
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
called
more
than
once
!
"
)
;
PRStatus
status
=
PR_NewThreadPrivateIndex
(
&
sThreadLocalIndex
ThreadLocalDestructor
)
;
MOZ_RELEASE_ASSERT
(
status
=
=
PR_SUCCESS
"
PR_NewThreadPrivateIndex
failed
!
"
)
;
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
MOZ_RELEASE_ASSERT
(
observerService
)
;
nsCOMPtr
<
nsIObserver
>
observer
=
new
ShutdownObserver
(
)
;
nsresult
rv
=
observerService
-
>
AddObserver
(
observer
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
false
)
;
MOZ_RELEASE_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
ChildImpl
:
:
Shutdown
(
)
{
AssertIsOnMainThread
(
)
;
if
(
sShutdownHasStarted
)
{
MOZ_ASSERT_IF
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
!
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
return
;
}
sShutdownHasStarted
=
true
;
#
ifdef
DEBUG
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
threadLocalInfo
)
{
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mClosed
)
;
threadLocalInfo
-
>
mClosed
=
true
;
}
#
endif
DebugOnly
<
PRStatus
>
status
=
PR_SetThreadPrivate
(
sThreadLocalIndex
nullptr
)
;
MOZ_ASSERT
(
status
=
=
PR_SUCCESS
)
;
}
void
ChildImpl
:
:
Alloc
(
Endpoint
<
PBackgroundChild
>
&
&
aEndpoint
)
{
AssertIsInChildProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aEndpoint
.
IsValid
(
)
)
;
MOZ_ASSERT
(
sPendingTargets
)
;
MOZ_ASSERT
(
!
sPendingTargets
-
>
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
sPendingTargets
-
>
ElementAt
(
0
)
.
swap
(
eventTarget
)
;
sPendingTargets
-
>
RemoveElementAt
(
0
)
;
RefPtr
<
ChildImpl
>
actor
=
new
ChildImpl
(
)
;
nsCOMPtr
<
nsIRunnable
>
openRunnable
=
new
OpenChildProcessActorRunnable
(
actor
.
forget
(
)
Move
(
aEndpoint
)
)
;
if
(
NS_FAILED
(
eventTarget
-
>
Dispatch
(
openRunnable
NS_DISPATCH_NORMAL
)
)
)
{
MOZ_CRASH
(
"
Failed
to
dispatch
OpenActorRunnable
!
"
)
;
}
}
PBackgroundChild
*
ChildImpl
:
:
GetForCurrentThread
(
)
{
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
)
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
nullptr
;
}
return
threadLocalInfo
-
>
mActor
;
}
bool
ChildImpl
:
:
GetOrCreateForCurrentThread
(
nsIIPCBackgroundChildCreateCallback
*
aCallback
)
{
MOZ_ASSERT
(
aCallback
)
;
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
was
never
called
!
"
)
;
bool
created
=
false
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
threadLocalInfo
)
{
threadLocalInfo
-
>
mCallbacks
.
AppendElement
(
aCallback
)
;
}
else
{
nsAutoPtr
<
ThreadLocalInfo
>
newInfo
(
new
ThreadLocalInfo
(
aCallback
)
)
;
if
(
PR_SetThreadPrivate
(
sThreadLocalIndex
newInfo
)
!
=
PR_SUCCESS
)
{
CRASH_IN_CHILD_PROCESS
(
"
PR_SetThreadPrivate
failed
!
"
)
;
return
false
;
}
created
=
true
;
threadLocalInfo
=
newInfo
.
forget
(
)
;
}
if
(
threadLocalInfo
-
>
mActor
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
AlreadyCreatedCallbackRunnable
(
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToCurrentThread
(
runnable
)
)
;
return
true
;
}
if
(
!
created
)
{
return
true
;
}
if
(
NS_IsMainThread
(
)
)
{
if
(
NS_WARN_IF
(
!
OpenProtocolOnMainThread
(
NS_GetCurrentThread
(
)
)
)
)
{
return
false
;
}
return
true
;
}
RefPtr
<
CreateActorRunnable
>
runnable
=
new
CreateActorRunnable
(
)
;
if
(
NS_FAILED
(
NS_DispatchToMainThread
(
runnable
)
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
dispatch
to
main
thread
!
"
)
;
return
false
;
}
return
true
;
}
namespace
{
class
Callback
final
:
public
nsIIPCBackgroundChildCreateCallback
{
bool
*
mDone
;
public
:
explicit
Callback
(
bool
*
aDone
)
:
mDone
(
aDone
)
{
MOZ_ASSERT
(
mDone
)
;
}
NS_DECL_ISUPPORTS
private
:
~
Callback
(
)
{
}
virtual
void
ActorCreated
(
PBackgroundChild
*
aActor
)
override
{
*
mDone
=
true
;
}
virtual
void
ActorFailed
(
)
override
{
*
mDone
=
true
;
}
}
;
NS_IMPL_ISUPPORTS
(
Callback
nsIIPCBackgroundChildCreateCallback
)
}
PBackgroundChild
*
ChildImpl
:
:
GetOrCreateForCurrentThread
(
)
{
bool
done
=
false
;
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
=
new
Callback
(
&
done
)
;
if
(
NS_WARN_IF
(
!
GetOrCreateForCurrentThread
(
callback
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
SpinEventLoopUntil
(
[
&
]
(
)
{
return
done
;
}
)
)
)
{
return
nullptr
;
}
return
GetForCurrentThread
(
)
;
}
void
ChildImpl
:
:
CloseForCurrentThread
(
)
{
if
(
sThreadLocalIndex
=
=
kBadThreadLocalIndex
)
{
return
;
}
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mClosed
)
;
threadLocalInfo
-
>
mClosed
=
true
;
#
endif
DebugOnly
<
PRStatus
>
status
=
PR_SetThreadPrivate
(
sThreadLocalIndex
nullptr
)
;
MOZ_ASSERT
(
status
=
=
PR_SUCCESS
)
;
}
BackgroundChildImpl
:
:
ThreadLocal
*
ChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
{
MOZ_ASSERT
(
sThreadLocalIndex
!
=
kBadThreadLocalIndex
"
BackgroundChild
:
:
Startup
(
)
was
never
called
!
"
)
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
if
(
!
threadLocalInfo
)
{
return
nullptr
;
}
if
(
!
threadLocalInfo
-
>
mConsumerThreadLocal
)
{
threadLocalInfo
-
>
mConsumerThreadLocal
=
new
BackgroundChildImpl
:
:
ThreadLocal
(
)
;
}
return
threadLocalInfo
-
>
mConsumerThreadLocal
;
}
already_AddRefed
<
nsIIPCBackgroundChildCreateCallback
>
ChildImpl
:
:
GetNextCallback
(
)
{
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
MOZ_ASSERT
(
threadLocalInfo
)
;
if
(
threadLocalInfo
-
>
mCallbacks
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
;
threadLocalInfo
-
>
mCallbacks
[
0
]
.
swap
(
callback
)
;
threadLocalInfo
-
>
mCallbacks
.
RemoveElementAt
(
0
)
;
return
callback
.
forget
(
)
;
}
NS_IMETHODIMP
ChildImpl
:
:
AlreadyCreatedCallbackRunnable
:
:
Run
(
)
{
PBackgroundChild
*
actor
=
ChildImpl
:
:
GetForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
while
(
callback
)
{
callback
-
>
ActorCreated
(
actor
)
;
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
}
return
NS_OK
;
}
nsresult
ChildImpl
:
:
AlreadyCreatedCallbackRunnable
:
:
Cancel
(
)
{
Run
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ChildImpl
:
:
FailedCreateCallbackRunnable
:
:
Run
(
)
{
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
while
(
callback
)
{
callback
-
>
ActorFailed
(
)
;
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ChildImpl
:
:
OpenChildProcessActorRunnable
:
:
Run
(
)
{
AssertIsInChildProcess
(
)
;
MOZ_ASSERT
(
mActor
)
;
MOZ_ASSERT
(
mEndpoint
.
IsValid
(
)
)
;
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
MOZ_ASSERT
(
callback
"
There
should
be
at
least
one
callback
when
first
creating
the
"
"
actor
!
"
)
;
RefPtr
<
ChildImpl
>
strongActor
;
mActor
.
swap
(
strongActor
)
;
Endpoint
<
PBackgroundChild
>
endpoint
=
Move
(
mEndpoint
)
;
if
(
!
endpoint
.
Bind
(
strongActor
)
)
{
CRASH_IN_CHILD_PROCESS
(
"
Failed
to
bind
ChildImpl
!
"
)
;
while
(
callback
)
{
callback
-
>
ActorFailed
(
)
;
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
}
return
NS_OK
;
}
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
MOZ_ASSERT
(
threadLocalInfo
)
;
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mActor
)
;
RefPtr
<
ChildImpl
>
&
actor
=
threadLocalInfo
-
>
mActor
;
strongActor
.
swap
(
actor
)
;
actor
-
>
SetBoundThread
(
)
;
while
(
callback
)
{
callback
-
>
ActorCreated
(
actor
)
;
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ChildImpl
:
:
OpenMainProcessActorRunnable
:
:
Run
(
)
{
AssertIsInMainProcess
(
)
;
MOZ_ASSERT
(
mActor
)
;
MOZ_ASSERT
(
mParentActor
)
;
MOZ_ASSERT
(
mParentMessageLoop
)
;
nsCOMPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
MOZ_ASSERT
(
callback
"
There
should
be
at
least
one
callback
when
first
creating
the
"
"
actor
!
"
)
;
RefPtr
<
ChildImpl
>
strongChildActor
;
mActor
.
swap
(
strongChildActor
)
;
RefPtr
<
ParentImpl
>
parentActor
;
mParentActor
.
swap
(
parentActor
)
;
MessageChannel
*
parentChannel
=
parentActor
-
>
GetIPCChannel
(
)
;
MOZ_ASSERT
(
parentChannel
)
;
if
(
!
strongChildActor
-
>
Open
(
parentChannel
mParentMessageLoop
ChildSide
)
)
{
NS_WARNING
(
"
Failed
to
open
ChildImpl
!
"
)
;
parentActor
-
>
Destroy
(
)
;
while
(
callback
)
{
callback
-
>
ActorFailed
(
)
;
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
}
return
NS_OK
;
}
parentActor
-
>
SetOtherProcessId
(
base
:
:
GetCurrentProcId
(
)
)
;
Unused
<
<
parentActor
.
forget
(
)
;
auto
threadLocalInfo
=
static_cast
<
ThreadLocalInfo
*
>
(
PR_GetThreadPrivate
(
sThreadLocalIndex
)
)
;
MOZ_ASSERT
(
threadLocalInfo
)
;
MOZ_ASSERT
(
!
threadLocalInfo
-
>
mActor
)
;
RefPtr
<
ChildImpl
>
&
childActor
=
threadLocalInfo
-
>
mActor
;
strongChildActor
.
swap
(
childActor
)
;
childActor
-
>
SetBoundThread
(
)
;
while
(
callback
)
{
callback
-
>
ActorCreated
(
childActor
)
;
callback
=
ChildImpl
:
:
GetNextCallback
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ChildImpl
:
:
CreateActorRunnable
:
:
Run
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
OpenProtocolOnMainThread
(
mEventTarget
)
)
{
NS_WARNING
(
"
OpenProtocolOnMainThread
failed
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
ChildImpl
:
:
ParentCreateCallback
:
:
Success
(
already_AddRefed
<
ParentImpl
>
aParentActor
MessageLoop
*
aParentMessageLoop
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
RefPtr
<
ParentImpl
>
parentActor
=
aParentActor
;
MOZ_ASSERT
(
parentActor
)
;
MOZ_ASSERT
(
aParentMessageLoop
)
;
MOZ_ASSERT
(
mEventTarget
)
;
RefPtr
<
ChildImpl
>
childActor
=
new
ChildImpl
(
)
;
nsCOMPtr
<
nsIEventTarget
>
target
;
mEventTarget
.
swap
(
target
)
;
nsCOMPtr
<
nsIRunnable
>
openRunnable
=
new
OpenMainProcessActorRunnable
(
childActor
.
forget
(
)
parentActor
.
forget
(
)
aParentMessageLoop
)
;
if
(
NS_FAILED
(
target
-
>
Dispatch
(
openRunnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
open
runnable
!
"
)
;
}
}
void
ChildImpl
:
:
ParentCreateCallback
:
:
Failure
(
)
{
AssertIsInMainProcess
(
)
;
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mEventTarget
)
;
nsCOMPtr
<
nsIEventTarget
>
target
;
mEventTarget
.
swap
(
target
)
;
DispatchFailureCallback
(
target
)
;
}
bool
ChildImpl
:
:
OpenProtocolOnMainThread
(
nsIEventTarget
*
aEventTarget
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aEventTarget
)
;
if
(
sShutdownHasStarted
)
{
MOZ_CRASH
(
"
Called
BackgroundChild
:
:
GetOrCreateForCurrentThread
after
"
"
shutdown
has
started
!
"
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
RefPtr
<
ParentImpl
:
:
CreateCallback
>
parentCallback
=
new
ParentCreateCallback
(
aEventTarget
)
;
if
(
!
ParentImpl
:
:
CreateActorForSameProcess
(
parentCallback
)
)
{
NS_WARNING
(
"
BackgroundParent
:
:
CreateActor
(
)
failed
!
"
)
;
DispatchFailureCallback
(
aEventTarget
)
;
return
false
;
}
return
true
;
}
ContentChild
*
content
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
content
)
;
if
(
content
-
>
IsShuttingDown
(
)
)
{
DispatchFailureCallback
(
aEventTarget
)
;
return
false
;
}
Endpoint
<
PBackgroundParent
>
parent
;
Endpoint
<
PBackgroundChild
>
child
;
nsresult
rv
;
rv
=
PBackground
:
:
CreateEndpoints
(
content
-
>
OtherPid
(
)
base
:
:
GetCurrentProcId
(
)
&
parent
&
child
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
false
;
}
if
(
!
content
-
>
SendInitBackground
(
Move
(
parent
)
)
)
{
MOZ_CRASH
(
"
Failed
to
create
top
level
actor
!
"
)
;
return
false
;
}
if
(
!
sPendingTargets
)
{
sPendingTargets
=
new
nsTArray
<
nsCOMPtr
<
nsIEventTarget
>
>
(
1
)
;
ClearOnShutdown
(
&
sPendingTargets
)
;
}
sPendingTargets
-
>
AppendElement
(
aEventTarget
)
;
Alloc
(
Move
(
child
)
)
;
return
true
;
}
void
ChildImpl
:
:
DispatchFailureCallback
(
nsIEventTarget
*
aEventTarget
)
{
MOZ_ASSERT
(
aEventTarget
)
;
nsCOMPtr
<
nsIRunnable
>
callbackRunnable
=
new
FailedCreateCallbackRunnable
(
)
;
if
(
NS_FAILED
(
aEventTarget
-
>
Dispatch
(
callbackRunnable
NS_DISPATCH_NORMAL
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
CreateCallbackRunnable
!
"
)
;
}
}
void
ChildImpl
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnBoundThread
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mActorDestroyed
)
;
mActorDestroyed
=
true
;
#
endif
BackgroundChildImpl
:
:
ActorDestroy
(
aWhy
)
;
}
NS_IMPL_ISUPPORTS
(
ChildImpl
:
:
ShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ChildImpl
:
:
ShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_THREADS_OBSERVER_ID
)
)
;
ChildImpl
:
:
Shutdown
(
)
;
return
NS_OK
;
}
