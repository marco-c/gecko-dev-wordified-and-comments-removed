#
ifndef
mozilla_ipc_CrashReporterHelper_h
#
define
mozilla_ipc_CrashReporterHelper_h
#
include
"
CrashReporterHost
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsICrashService
.
h
"
namespace
mozilla
{
namespace
ipc
{
template
<
GeckoProcessType
PT
>
class
CrashReporterHelper
{
public
:
CrashReporterHelper
(
)
:
mCrashReporter
(
nullptr
)
{
}
IPCResult
RecvInitCrashReporter
(
Shmem
&
&
aShmem
const
CrashReporter
:
:
ThreadId
&
aThreadId
)
{
mCrashReporter
=
MakeUnique
<
ipc
:
:
CrashReporterHost
>
(
PT
aShmem
aThreadId
)
;
return
IPC_OK
(
)
;
}
protected
:
bool
GenerateCrashReport
(
base
:
:
ProcessId
aPid
nsString
*
aMinidumpId
=
nullptr
)
{
if
(
!
mCrashReporter
)
{
HandleOrphanedMinidump
(
aPid
aMinidumpId
)
;
return
false
;
}
bool
generated
=
mCrashReporter
-
>
GenerateCrashReport
(
aPid
)
;
if
(
generated
&
&
aMinidumpId
)
{
*
aMinidumpId
=
mCrashReporter
-
>
MinidumpID
(
)
;
}
mCrashReporter
=
nullptr
;
return
generated
;
}
void
HandleOrphanedMinidump
(
base
:
:
ProcessId
aPid
nsString
*
aMinidumpId
)
{
if
(
CrashReporter
:
:
FinalizeOrphanedMinidump
(
aPid
PT
aMinidumpId
)
)
{
CrashReporterHost
:
:
RecordCrash
(
PT
nsICrashService
:
:
CRASH_TYPE_CRASH
*
aMinidumpId
)
;
}
else
{
NS_WARNING
(
nsPrintfCString
(
"
child
process
pid
=
%
d
crashed
without
"
"
leaving
a
minidump
behind
"
aPid
)
.
get
(
)
)
;
}
}
UniquePtr
<
ipc
:
:
CrashReporterHost
>
mCrashReporter
;
}
;
}
}
#
endif
