#
include
"
mozilla
/
ipc
/
SendStream
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
mozilla
/
dom
/
PContentChild
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
bindings
/
WorkerFeature
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsICancelableRunnable
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsStreamUtils
.
h
"
namespace
mozilla
{
namespace
ipc
{
using
mozilla
:
:
dom
:
:
PContentChild
;
using
mozilla
:
:
dom
:
:
workers
:
:
GetCurrentThreadWorkerPrivate
;
using
mozilla
:
:
dom
:
:
workers
:
:
Status
;
using
mozilla
:
:
dom
:
:
workers
:
:
WorkerFeature
;
using
mozilla
:
:
dom
:
:
workers
:
:
WorkerPrivate
;
namespace
{
class
SendStreamChildImpl
final
:
public
SendStreamChild
public
WorkerFeature
{
public
:
explicit
SendStreamChildImpl
(
nsIAsyncInputStream
*
aStream
)
;
~
SendStreamChildImpl
(
)
;
void
Start
(
)
override
;
void
StartDestroy
(
)
override
;
bool
AddAsWorkerFeature
(
dom
:
:
workers
:
:
WorkerPrivate
*
aWorkerPrivate
)
;
private
:
class
Callback
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
;
virtual
bool
RecvRequestClose
(
const
nsresult
&
aRv
)
override
;
virtual
bool
Notify
(
Status
aStatus
)
override
;
void
DoRead
(
)
;
void
Wait
(
)
;
void
OnStreamReady
(
Callback
*
aCallback
)
;
void
OnEnd
(
nsresult
aRv
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
mStream
;
RefPtr
<
Callback
>
mCallback
;
WorkerPrivate
*
mWorkerPrivate
;
bool
mClosed
;
NS_DECL_OWNINGTHREAD
}
;
class
SendStreamChildImpl
:
:
Callback
final
:
public
nsIInputStreamCallback
public
nsIRunnable
public
nsICancelableRunnable
{
public
:
explicit
Callback
(
SendStreamChildImpl
*
aActor
)
:
mActor
(
aActor
)
mOwningThread
(
NS_GetCurrentThread
(
)
)
{
MOZ_ASSERT
(
mActor
)
;
}
NS_IMETHOD
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
override
{
if
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
{
return
Run
(
)
;
}
nsresult
rv
=
mOwningThread
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
stream
readable
event
to
owning
thread
"
)
;
}
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
;
if
(
mActor
)
{
mActor
-
>
OnStreamReady
(
this
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
NS_OK
;
}
void
ClearActor
(
)
{
MOZ_ASSERT
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
;
MOZ_ASSERT
(
mActor
)
;
mActor
=
nullptr
;
}
private
:
~
Callback
(
)
{
MOZ_ASSERT
(
!
mActor
)
;
}
SendStreamChildImpl
*
mActor
;
nsCOMPtr
<
nsIThread
>
mOwningThread
;
NS_DECL_THREADSAFE_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
SendStreamChildImpl
:
:
Callback
nsIInputStreamCallback
nsIRunnable
nsICancelableRunnable
)
;
SendStreamChildImpl
:
:
SendStreamChildImpl
(
nsIAsyncInputStream
*
aStream
)
:
mStream
(
aStream
)
mWorkerPrivate
(
nullptr
)
mClosed
(
false
)
{
MOZ_ASSERT
(
mStream
)
;
}
SendStreamChildImpl
:
:
~
SendStreamChildImpl
(
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
mClosed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
}
void
SendStreamChildImpl
:
:
Start
(
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT_IF
(
!
NS_IsMainThread
(
)
mWorkerPrivate
)
;
DoRead
(
)
;
}
void
SendStreamChildImpl
:
:
StartDestroy
(
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
OnEnd
(
NS_ERROR_ABORT
)
;
}
bool
SendStreamChildImpl
:
:
AddAsWorkerFeature
(
WorkerPrivate
*
aWorkerPrivate
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
bool
result
=
aWorkerPrivate
-
>
AddFeature
(
this
)
;
if
(
result
)
{
mWorkerPrivate
=
aWorkerPrivate
;
}
return
result
;
}
void
SendStreamChildImpl
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
mClosed
)
;
if
(
mCallback
)
{
mCallback
-
>
ClearActor
(
)
;
mCallback
=
nullptr
;
}
if
(
mWorkerPrivate
)
{
mWorkerPrivate
-
>
RemoveFeature
(
this
)
;
mWorkerPrivate
=
nullptr
;
}
}
bool
SendStreamChildImpl
:
:
RecvRequestClose
(
const
nsresult
&
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
OnEnd
(
aRv
)
;
return
true
;
}
bool
SendStreamChildImpl
:
:
Notify
(
Status
aStatus
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
return
true
;
}
void
SendStreamChildImpl
:
:
DoRead
(
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
static
const
uint64_t
kMaxBytesPerMessage
=
32
*
1024
;
static_assert
(
kMaxBytesPerMessage
<
=
static_cast
<
uint64_t
>
(
UINT32_MAX
)
"
kMaxBytesPerMessage
must
cleanly
cast
to
uint32_t
"
)
;
while
(
true
)
{
MOZ_ASSERT
(
!
mClosed
)
;
nsCString
buffer
;
uint64_t
available
=
0
;
nsresult
rv
=
mStream
-
>
Available
(
&
available
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnEnd
(
rv
)
;
return
;
}
if
(
available
=
=
0
)
{
Wait
(
)
;
return
;
}
uint32_t
expectedBytes
=
static_cast
<
uint32_t
>
(
std
:
:
min
(
available
kMaxBytesPerMessage
)
)
;
buffer
.
SetLength
(
expectedBytes
)
;
uint32_t
bytesRead
=
0
;
rv
=
mStream
-
>
Read
(
buffer
.
BeginWriting
(
)
buffer
.
Length
(
)
&
bytesRead
)
;
MOZ_ASSERT_IF
(
NS_FAILED
(
rv
)
bytesRead
=
=
0
)
;
buffer
.
SetLength
(
bytesRead
)
;
if
(
!
buffer
.
IsEmpty
(
)
)
{
Unused
<
<
SendBuffer
(
buffer
)
;
}
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
Wait
(
)
;
return
;
}
if
(
NS_FAILED
(
rv
)
|
|
buffer
.
IsEmpty
(
)
)
{
OnEnd
(
rv
)
;
return
;
}
}
}
void
SendStreamChildImpl
:
:
Wait
(
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
!
mClosed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
mCallback
=
new
Callback
(
this
)
;
nsresult
rv
=
mStream
-
>
AsyncWait
(
mCallback
0
0
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnEnd
(
rv
)
;
return
;
}
}
void
SendStreamChildImpl
:
:
OnStreamReady
(
Callback
*
aCallback
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
mCallback
)
;
MOZ_ASSERT
(
aCallback
=
=
mCallback
)
;
mCallback
-
>
ClearActor
(
)
;
mCallback
=
nullptr
;
DoRead
(
)
;
}
void
SendStreamChildImpl
:
:
OnEnd
(
nsresult
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
SendStreamChild
)
;
MOZ_ASSERT
(
aRv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
;
if
(
mClosed
)
{
return
;
}
mClosed
=
true
;
mStream
-
>
CloseWithStatus
(
aRv
)
;
if
(
aRv
=
=
NS_BASE_STREAM_CLOSED
)
{
aRv
=
NS_OK
;
}
Unused
<
<
SendClose
(
aRv
)
;
}
bool
IsBlocking
(
nsIAsyncInputStream
*
aInputStream
)
{
bool
nonBlocking
=
false
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
aInputStream
-
>
IsNonBlocking
(
&
nonBlocking
)
)
)
;
return
!
nonBlocking
;
}
}
SendStreamChild
*
SendStreamChild
:
:
Create
(
nsIAsyncInputStream
*
aInputStream
PContentChild
*
aManager
)
{
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
IsBlocking
(
aInputStream
)
)
)
{
return
nullptr
;
}
SendStreamChild
*
actor
=
new
SendStreamChildImpl
(
aInputStream
)
;
aManager
-
>
SendPSendStreamConstructor
(
actor
)
;
return
actor
;
}
SendStreamChild
*
SendStreamChild
:
:
Create
(
nsIAsyncInputStream
*
aInputStream
PBackgroundChild
*
aManager
)
{
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
aManager
)
;
WorkerPrivate
*
workerPrivate
=
nullptr
;
if
(
!
NS_IsMainThread
(
)
)
{
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
}
if
(
NS_WARN_IF
(
IsBlocking
(
aInputStream
)
)
)
{
return
nullptr
;
}
SendStreamChildImpl
*
actor
=
new
SendStreamChildImpl
(
aInputStream
)
;
if
(
workerPrivate
&
&
!
actor
-
>
AddAsWorkerFeature
(
workerPrivate
)
)
{
delete
actor
;
return
nullptr
;
}
aManager
-
>
SendPSendStreamConstructor
(
actor
)
;
return
actor
;
}
SendStreamChild
:
:
~
SendStreamChild
(
)
{
}
void
DeallocPSendStreamChild
(
PSendStreamChild
*
aActor
)
{
delete
aActor
;
}
}
}
