#
ifndef
MOZILLA_IPC_RAWSHMEM_H_
#
define
MOZILLA_IPC_RAWSHMEM_H_
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
<
utility
>
namespace
mozilla
:
:
ipc
{
class
WritableSharedMemoryMapping
;
class
UnsafeSharedMemoryHandle
{
friend
class
WritableSharedMemoryMapping
;
friend
struct
IPC
:
:
ParamTraits
<
UnsafeSharedMemoryHandle
>
;
public
:
UnsafeSharedMemoryHandle
(
)
;
UnsafeSharedMemoryHandle
(
UnsafeSharedMemoryHandle
&
&
aOther
)
noexcept
;
UnsafeSharedMemoryHandle
&
operator
=
(
UnsafeSharedMemoryHandle
&
&
aOther
)
noexcept
;
static
Maybe
<
std
:
:
pair
<
UnsafeSharedMemoryHandle
WritableSharedMemoryMapping
>
>
CreateAndMap
(
size_t
aSize
)
;
private
:
UnsafeSharedMemoryHandle
(
SharedMemory
:
:
Handle
&
&
aHandle
uint64_t
aSize
)
:
mHandle
(
std
:
:
move
(
aHandle
)
)
mSize
(
aSize
)
{
}
SharedMemory
:
:
Handle
mHandle
;
uint64_t
mSize
;
}
;
class
WritableSharedMemoryMapping
{
friend
class
UnsafeSharedMemoryHandle
;
public
:
WritableSharedMemoryMapping
(
)
=
default
;
WritableSharedMemoryMapping
(
WritableSharedMemoryMapping
&
&
aMoved
)
=
default
;
WritableSharedMemoryMapping
&
operator
=
(
WritableSharedMemoryMapping
&
&
aMoved
)
=
default
;
static
Maybe
<
WritableSharedMemoryMapping
>
Open
(
UnsafeSharedMemoryHandle
aHandle
)
;
size_t
Size
(
)
const
;
Span
<
uint8_t
>
Bytes
(
)
;
private
:
explicit
WritableSharedMemoryMapping
(
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemory
>
&
&
aRef
)
;
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemory
>
mRef
;
}
;
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
UnsafeSharedMemoryHandle
>
{
typedef
mozilla
:
:
ipc
:
:
UnsafeSharedMemoryHandle
paramType
;
static
void
Write
(
IPC
:
:
MessageWriter
*
aWriter
paramType
&
&
aVar
)
;
static
bool
Read
(
IPC
:
:
MessageReader
*
aReader
paramType
*
aVar
)
;
}
;
}
#
endif
