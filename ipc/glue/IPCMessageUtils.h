#
ifndef
__IPC_GLUE_IPCMESSAGEUTILS_H__
#
define
__IPC_GLUE_IPCMESSAGEUTILS_H__
#
include
"
base
/
process_util
.
h
"
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
EnumTypeTraits
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
net
/
WebSocketFrame
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
TimeStamp_windows
.
h
"
#
endif
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
IntegerTypeTraits
.
h
"
#
include
<
limits
>
#
include
<
stdint
.
h
>
#
include
<
type_traits
>
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
js
/
StructuredClone
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
ifdef
_MSC_VER
#
pragma
warning
(
disable
:
4800
)
#
endif
#
if
!
defined
(
OS_POSIX
)
namespace
base
{
struct
FileDescriptor
{
}
;
}
#
endif
namespace
mozilla
{
typedef
uintptr_t
WindowsHandle
;
struct
void_t
{
bool
operator
=
=
(
const
void_t
&
)
const
{
return
true
;
}
}
;
struct
null_t
{
bool
operator
=
=
(
const
null_t
&
)
const
{
return
true
;
}
}
;
struct
SerializedStructuredCloneBuffer
final
{
SerializedStructuredCloneBuffer
(
)
{
}
SerializedStructuredCloneBuffer
(
const
SerializedStructuredCloneBuffer
&
aOther
)
{
*
this
=
aOther
;
}
SerializedStructuredCloneBuffer
&
operator
=
(
const
SerializedStructuredCloneBuffer
&
aOther
)
{
data
.
Clear
(
)
;
auto
iter
=
aOther
.
data
.
Iter
(
)
;
while
(
!
iter
.
Done
(
)
)
{
data
.
WriteBytes
(
iter
.
Data
(
)
iter
.
RemainingInSegment
(
)
)
;
iter
.
Advance
(
aOther
.
data
iter
.
RemainingInSegment
(
)
)
;
}
return
*
this
;
}
bool
operator
=
=
(
const
SerializedStructuredCloneBuffer
&
aOther
)
const
{
return
false
;
}
JSStructuredCloneData
data
;
}
;
}
namespace
IPC
{
static
const
uint32_t
MAX_MESSAGE_SIZE
=
65536
;
template
<
typename
E
typename
EnumValidator
>
struct
EnumSerializer
{
typedef
E
paramType
;
typedef
typename
mozilla
:
:
UnsignedStdintTypeForSize
<
sizeof
(
paramType
)
>
:
:
Type
uintParamType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aValue
)
{
MOZ_RELEASE_ASSERT
(
EnumValidator
:
:
IsLegalValue
(
aValue
)
)
;
WriteParam
(
aMsg
uintParamType
(
aValue
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
uintParamType
value
;
if
(
!
ReadParam
(
aMsg
aIter
&
value
)
)
{
CrashReporter
:
:
AnnotateCrashReport
(
NS_LITERAL_CSTRING
(
"
IPCReadErrorReason
"
)
NS_LITERAL_CSTRING
(
"
Bad
iter
"
)
)
;
return
false
;
}
else
if
(
!
EnumValidator
:
:
IsLegalValue
(
paramType
(
value
)
)
)
{
CrashReporter
:
:
AnnotateCrashReport
(
NS_LITERAL_CSTRING
(
"
IPCReadErrorReason
"
)
NS_LITERAL_CSTRING
(
"
Illegal
value
"
)
)
;
return
false
;
}
*
aResult
=
paramType
(
value
)
;
return
true
;
}
}
;
template
<
typename
E
E
MinLegal
E
HighBound
>
class
ContiguousEnumValidator
{
template
<
typename
T
>
static
bool
IsLessThanOrEqual
(
T
a
T
b
)
{
return
a
<
=
b
;
}
public
:
static
bool
IsLegalValue
(
E
e
)
{
return
IsLessThanOrEqual
(
MinLegal
e
)
&
&
e
<
HighBound
;
}
}
;
template
<
typename
E
E
MinLegal
E
MaxLegal
>
class
ContiguousEnumValidatorInclusive
{
template
<
typename
T
>
static
bool
IsLessThanOrEqual
(
T
a
T
b
)
{
return
a
<
=
b
;
}
public
:
static
bool
IsLegalValue
(
E
e
)
{
return
IsLessThanOrEqual
(
MinLegal
e
)
&
&
e
<
=
MaxLegal
;
}
}
;
template
<
typename
E
E
AllBits
>
struct
BitFlagsEnumValidator
{
static
bool
IsLegalValue
(
E
e
)
{
return
(
e
&
AllBits
)
=
=
e
;
}
}
;
template
<
typename
E
E
MinLegal
E
HighBound
>
struct
ContiguousEnumSerializer
:
EnumSerializer
<
E
ContiguousEnumValidator
<
E
MinLegal
HighBound
>
>
{
}
;
template
<
typename
E
E
MinLegal
E
MaxLegal
>
struct
ContiguousEnumSerializerInclusive
:
EnumSerializer
<
E
ContiguousEnumValidatorInclusive
<
E
MinLegal
MaxLegal
>
>
{
}
;
template
<
typename
E
E
AllBits
>
struct
BitFlagsEnumSerializer
:
EnumSerializer
<
E
BitFlagsEnumValidator
<
E
AllBits
>
>
{
}
;
template
<
typename
T
>
struct
PlainOldDataSerializer
{
typedef
T
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
aMsg
-
>
WriteBytes
(
&
aParam
sizeof
(
aParam
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
aMsg
-
>
ReadBytesInto
(
aIter
aResult
sizeof
(
paramType
)
)
;
}
}
;
template
<
typename
T
>
struct
EmptyStructSerializer
{
typedef
T
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
*
aResult
=
{
}
;
return
true
;
}
}
;
template
<
>
struct
ParamTraits
<
int8_t
>
{
typedef
int8_t
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
aMsg
-
>
WriteBytes
(
&
aParam
sizeof
(
aParam
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
aMsg
-
>
ReadBytesInto
(
aIter
aResult
sizeof
(
*
aResult
)
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
0x
%
02x
"
aParam
&
0xff
)
)
;
}
}
;
template
<
>
struct
ParamTraits
<
uint8_t
>
{
typedef
uint8_t
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
aMsg
-
>
WriteBytes
(
&
aParam
sizeof
(
aParam
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
aMsg
-
>
ReadBytesInto
(
aIter
aResult
sizeof
(
*
aResult
)
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
0x
%
02x
"
aParam
)
)
;
}
}
;
#
if
!
defined
(
OS_POSIX
)
template
<
>
struct
ParamTraits
<
base
:
:
FileDescriptor
>
{
typedef
base
:
:
FileDescriptor
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
MOZ_CRASH
(
"
FileDescriptor
isn
'
t
meaningful
on
this
platform
"
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
MOZ_CRASH
(
"
FileDescriptor
isn
'
t
meaningful
on
this
platform
"
)
;
return
false
;
}
}
;
#
endif
template
<
>
struct
ParamTraits
<
nsACString
>
{
typedef
nsACString
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
bool
isVoid
=
aParam
.
IsVoid
(
)
;
aMsg
-
>
WriteBool
(
isVoid
)
;
if
(
isVoid
)
return
;
uint32_t
length
=
aParam
.
Length
(
)
;
WriteParam
(
aMsg
length
)
;
aMsg
-
>
WriteBytes
(
aParam
.
BeginReading
(
)
length
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
bool
isVoid
;
if
(
!
aMsg
-
>
ReadBool
(
aIter
&
isVoid
)
)
return
false
;
if
(
isVoid
)
{
aResult
-
>
SetIsVoid
(
true
)
;
return
true
;
}
uint32_t
length
;
if
(
!
ReadParam
(
aMsg
aIter
&
length
)
)
{
return
false
;
}
aResult
-
>
SetLength
(
length
)
;
return
aMsg
-
>
ReadBytesInto
(
aIter
aResult
-
>
BeginWriting
(
)
length
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
if
(
aParam
.
IsVoid
(
)
)
aLog
-
>
append
(
L
"
(
NULL
)
"
)
;
else
aLog
-
>
append
(
UTF8ToWide
(
aParam
.
BeginReading
(
)
)
)
;
}
}
;
template
<
>
struct
ParamTraits
<
nsAString
>
{
typedef
nsAString
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
bool
isVoid
=
aParam
.
IsVoid
(
)
;
aMsg
-
>
WriteBool
(
isVoid
)
;
if
(
isVoid
)
return
;
uint32_t
length
=
aParam
.
Length
(
)
;
WriteParam
(
aMsg
length
)
;
aMsg
-
>
WriteBytes
(
aParam
.
BeginReading
(
)
length
*
sizeof
(
char16_t
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
bool
isVoid
;
if
(
!
aMsg
-
>
ReadBool
(
aIter
&
isVoid
)
)
return
false
;
if
(
isVoid
)
{
aResult
-
>
SetIsVoid
(
true
)
;
return
true
;
}
uint32_t
length
;
if
(
!
ReadParam
(
aMsg
aIter
&
length
)
)
{
return
false
;
}
aResult
-
>
SetLength
(
length
)
;
mozilla
:
:
CheckedInt
<
uint32_t
>
byteLength
=
mozilla
:
:
CheckedInt
<
uint32_t
>
(
length
)
*
sizeof
(
char16_t
)
;
if
(
!
byteLength
.
isValid
(
)
)
{
return
false
;
}
return
aMsg
-
>
ReadBytesInto
(
aIter
aResult
-
>
BeginWriting
(
)
byteLength
.
value
(
)
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
if
(
aParam
.
IsVoid
(
)
)
aLog
-
>
append
(
L
"
(
NULL
)
"
)
;
else
{
#
ifdef
WCHAR_T_IS_UTF16
aLog
-
>
append
(
reinterpret_cast
<
const
wchar_t
*
>
(
aParam
.
BeginReading
(
)
)
)
;
#
else
uint32_t
length
=
aParam
.
Length
(
)
;
for
(
uint32_t
index
=
0
;
index
<
length
;
index
+
+
)
{
aLog
-
>
push_back
(
std
:
:
wstring
:
:
value_type
(
aParam
[
index
]
)
)
;
}
#
endif
}
}
}
;
template
<
>
struct
ParamTraits
<
nsCString
>
:
ParamTraits
<
nsACString
>
{
typedef
nsCString
paramType
;
}
;
template
<
>
struct
ParamTraits
<
nsLiteralCString
>
:
ParamTraits
<
nsACString
>
{
typedef
nsLiteralCString
paramType
;
}
;
#
ifdef
MOZILLA_INTERNAL_API
template
<
>
struct
ParamTraits
<
nsAutoCString
>
:
ParamTraits
<
nsCString
>
{
typedef
nsAutoCString
paramType
;
}
;
#
endif
template
<
>
struct
ParamTraits
<
nsString
>
:
ParamTraits
<
nsAString
>
{
typedef
nsString
paramType
;
}
;
template
<
>
struct
ParamTraits
<
nsLiteralString
>
:
ParamTraits
<
nsAString
>
{
typedef
nsLiteralString
paramType
;
}
;
template
<
>
struct
ParamTraits
<
nsDependentSubstring
>
:
ParamTraits
<
nsAString
>
{
typedef
nsDependentSubstring
paramType
;
}
;
template
<
>
struct
ParamTraits
<
nsDependentCSubstring
>
:
ParamTraits
<
nsACString
>
{
typedef
nsDependentCSubstring
paramType
;
}
;
#
ifdef
MOZILLA_INTERNAL_API
template
<
>
struct
ParamTraits
<
nsAutoString
>
:
ParamTraits
<
nsString
>
{
typedef
nsAutoString
paramType
;
}
;
#
endif
bool
ByteLengthIsValid
(
uint32_t
aNumElements
size_t
aElementSize
int
*
aByteLength
)
;
template
<
typename
E
>
struct
ParamTraits
<
nsTArray
<
E
>
>
{
typedef
nsTArray
<
E
>
paramType
;
static
const
bool
sUseWriteBytes
=
(
mozilla
:
:
IsIntegral
<
E
>
:
:
value
|
|
mozilla
:
:
IsFloatingPoint
<
E
>
:
:
value
)
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
uint32_t
length
=
aParam
.
Length
(
)
;
WriteParam
(
aMsg
length
)
;
if
(
sUseWriteBytes
)
{
int
pickledLength
=
0
;
MOZ_RELEASE_ASSERT
(
ByteLengthIsValid
(
length
sizeof
(
E
)
&
pickledLength
)
)
;
aMsg
-
>
WriteBytes
(
aParam
.
Elements
(
)
pickledLength
)
;
}
else
{
const
E
*
elems
=
aParam
.
Elements
(
)
;
for
(
uint32_t
index
=
0
;
index
<
length
;
index
+
+
)
{
WriteParam
(
aMsg
elems
[
index
]
)
;
}
}
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
uint32_t
length
;
if
(
!
ReadParam
(
aMsg
aIter
&
length
)
)
{
return
false
;
}
if
(
sUseWriteBytes
)
{
int
pickledLength
=
0
;
if
(
!
ByteLengthIsValid
(
length
sizeof
(
E
)
&
pickledLength
)
)
{
return
false
;
}
E
*
elements
=
aResult
-
>
AppendElements
(
length
)
;
return
aMsg
-
>
ReadBytesInto
(
aIter
elements
pickledLength
)
;
}
else
{
aResult
-
>
SetCapacity
(
length
)
;
for
(
uint32_t
index
=
0
;
index
<
length
;
index
+
+
)
{
E
*
element
=
aResult
-
>
AppendElement
(
)
;
if
(
!
ReadParam
(
aMsg
aIter
element
)
)
{
return
false
;
}
}
return
true
;
}
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
for
(
uint32_t
index
=
0
;
index
<
aParam
.
Length
(
)
;
index
+
+
)
{
if
(
index
)
{
aLog
-
>
append
(
L
"
"
)
;
}
LogParam
(
aParam
[
index
]
aLog
)
;
}
}
}
;
template
<
typename
E
>
struct
ParamTraits
<
FallibleTArray
<
E
>
>
{
typedef
FallibleTArray
<
E
>
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
static_cast
<
const
nsTArray
<
E
>
&
>
(
aParam
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
nsTArray
<
E
>
temp
;
if
(
!
ReadParam
(
aMsg
aIter
&
temp
)
)
return
false
;
aResult
-
>
SwapElements
(
temp
)
;
return
true
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
LogParam
(
static_cast
<
const
nsTArray
<
E
>
&
>
(
aParam
)
aLog
)
;
}
}
;
template
<
typename
E
size_t
N
>
struct
ParamTraits
<
AutoTArray
<
E
N
>
>
:
ParamTraits
<
nsTArray
<
E
>
>
{
typedef
AutoTArray
<
E
N
>
paramType
;
}
;
template
<
>
struct
ParamTraits
<
float
>
{
typedef
float
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
aMsg
-
>
WriteBytes
(
&
aParam
sizeof
(
paramType
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
aMsg
-
>
ReadBytesInto
(
aIter
aResult
sizeof
(
*
aResult
)
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
%
g
"
aParam
)
)
;
}
}
;
template
<
>
struct
ParamTraits
<
nsCSSPropertyID
>
:
public
ContiguousEnumSerializer
<
nsCSSPropertyID
eCSSProperty_UNKNOWN
eCSSProperty_COUNT
>
{
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
void_t
>
{
typedef
mozilla
:
:
void_t
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
*
aResult
=
paramType
(
)
;
return
true
;
}
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
null_t
>
{
typedef
mozilla
:
:
null_t
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
*
aResult
=
paramType
(
)
;
return
true
;
}
}
;
template
<
>
struct
ParamTraits
<
nsID
>
{
typedef
nsID
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
m0
)
;
WriteParam
(
aMsg
aParam
.
m1
)
;
WriteParam
(
aMsg
aParam
.
m2
)
;
for
(
unsigned
int
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
aParam
.
m3
)
;
i
+
+
)
{
WriteParam
(
aMsg
aParam
.
m3
[
i
]
)
;
}
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
if
(
!
ReadParam
(
aMsg
aIter
&
(
aResult
-
>
m0
)
)
|
|
!
ReadParam
(
aMsg
aIter
&
(
aResult
-
>
m1
)
)
|
|
!
ReadParam
(
aMsg
aIter
&
(
aResult
-
>
m2
)
)
)
return
false
;
for
(
unsigned
int
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
aResult
-
>
m3
)
;
i
+
+
)
if
(
!
ReadParam
(
aMsg
aIter
&
(
aResult
-
>
m3
[
i
]
)
)
)
return
false
;
return
true
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
L
"
{
"
)
;
aLog
-
>
append
(
StringPrintf
(
L
"
%
8
.
8X
-
%
4
.
4X
-
%
4
.
4X
-
"
aParam
.
m0
aParam
.
m1
aParam
.
m2
)
)
;
for
(
unsigned
int
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
aParam
.
m3
)
;
i
+
+
)
aLog
-
>
append
(
StringPrintf
(
L
"
%
2
.
2X
"
aParam
.
m3
[
i
]
)
)
;
aLog
-
>
append
(
L
"
}
"
)
;
}
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
TimeDuration
>
{
typedef
mozilla
:
:
TimeDuration
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mValue
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
ReadParam
(
aMsg
aIter
&
aResult
-
>
mValue
)
;
}
;
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
TimeStamp
>
{
typedef
mozilla
:
:
TimeStamp
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mValue
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
ReadParam
(
aMsg
aIter
&
aResult
-
>
mValue
)
;
}
;
}
;
#
ifdef
XP_WIN
template
<
>
struct
ParamTraits
<
mozilla
:
:
TimeStampValue
>
{
typedef
mozilla
:
:
TimeStampValue
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mGTC
)
;
WriteParam
(
aMsg
aParam
.
mQPC
)
;
WriteParam
(
aMsg
aParam
.
mHasQPC
)
;
WriteParam
(
aMsg
aParam
.
mIsNull
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
(
ReadParam
(
aMsg
aIter
&
aResult
-
>
mGTC
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mQPC
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHasQPC
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mIsNull
)
)
;
}
}
;
#
endif
template
<
>
struct
ParamTraits
<
mozilla
:
:
dom
:
:
ipc
:
:
StructuredCloneData
>
{
typedef
mozilla
:
:
dom
:
:
ipc
:
:
StructuredCloneData
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
aParam
.
WriteIPCParams
(
aMsg
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
aResult
-
>
ReadIPCParams
(
aMsg
aIter
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
LogParam
(
aParam
.
DataLength
(
)
aLog
)
;
}
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
net
:
:
WebSocketFrameData
>
{
typedef
mozilla
:
:
net
:
:
WebSocketFrameData
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
aParam
.
WriteIPCParams
(
aMsg
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
aResult
-
>
ReadIPCParams
(
aMsg
aIter
)
;
}
}
;
template
<
>
struct
ParamTraits
<
JSStructuredCloneData
>
{
typedef
JSStructuredCloneData
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
!
(
aParam
.
Size
(
)
%
sizeof
(
uint64_t
)
)
)
;
WriteParam
(
aMsg
aParam
.
Size
(
)
)
;
auto
iter
=
aParam
.
Iter
(
)
;
while
(
!
iter
.
Done
(
)
)
{
aMsg
-
>
WriteBytes
(
iter
.
Data
(
)
iter
.
RemainingInSegment
(
)
sizeof
(
uint64_t
)
)
;
iter
.
Advance
(
aParam
iter
.
RemainingInSegment
(
)
)
;
}
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
size_t
length
=
0
;
if
(
!
ReadParam
(
aMsg
aIter
&
length
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
(
length
%
sizeof
(
uint64_t
)
)
)
;
mozilla
:
:
BufferList
<
InfallibleAllocPolicy
>
buffers
(
0
0
4096
)
;
if
(
length
&
&
!
aMsg
-
>
ExtractBuffers
(
aIter
length
&
buffers
sizeof
(
uint64_t
)
)
)
{
return
false
;
}
bool
success
;
mozilla
:
:
BufferList
<
js
:
:
SystemAllocPolicy
>
out
=
buffers
.
MoveFallible
<
js
:
:
SystemAllocPolicy
>
(
&
success
)
;
if
(
!
success
)
{
return
false
;
}
*
aResult
=
JSStructuredCloneData
(
Move
(
out
)
)
;
return
true
;
}
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
SerializedStructuredCloneBuffer
>
{
typedef
mozilla
:
:
SerializedStructuredCloneBuffer
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
data
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
return
ReadParam
(
aMsg
aIter
&
aResult
-
>
data
)
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
LogParam
(
aParam
.
data
.
Size
(
)
aLog
)
;
}
}
;
template
<
>
struct
ParamTraits
<
nsIWidget
:
:
TouchPointerState
>
:
public
BitFlagsEnumSerializer
<
nsIWidget
:
:
TouchPointerState
nsIWidget
:
:
TouchPointerState
:
:
ALL_BITS
>
{
}
;
template
<
class
T
>
struct
ParamTraits
<
mozilla
:
:
Maybe
<
T
>
>
{
typedef
mozilla
:
:
Maybe
<
T
>
paramType
;
static
void
Write
(
Message
*
msg
const
paramType
&
param
)
{
if
(
param
.
isSome
(
)
)
{
WriteParam
(
msg
true
)
;
WriteParam
(
msg
param
.
value
(
)
)
;
}
else
{
WriteParam
(
msg
false
)
;
}
}
static
bool
Read
(
const
Message
*
msg
PickleIterator
*
iter
paramType
*
result
)
{
bool
isSome
;
if
(
!
ReadParam
(
msg
iter
&
isSome
)
)
{
return
false
;
}
if
(
isSome
)
{
T
tmp
;
if
(
!
ReadParam
(
msg
iter
&
tmp
)
)
{
return
false
;
}
*
result
=
mozilla
:
:
Some
(
mozilla
:
:
Move
(
tmp
)
)
;
}
else
{
*
result
=
mozilla
:
:
Nothing
(
)
;
}
return
true
;
}
}
;
template
<
typename
T
>
struct
ParamTraits
<
mozilla
:
:
EnumSet
<
T
>
>
{
typedef
mozilla
:
:
EnumSet
<
T
>
paramType
;
typedef
typename
mozilla
:
:
EnumSet
<
T
>
:
:
serializedType
serializedType
;
static
void
Write
(
Message
*
msg
const
paramType
&
param
)
{
MOZ_RELEASE_ASSERT
(
IsLegalValue
(
param
.
serialize
(
)
)
)
;
WriteParam
(
msg
param
.
serialize
(
)
)
;
}
static
bool
Read
(
const
Message
*
msg
PickleIterator
*
iter
paramType
*
result
)
{
serializedType
tmp
;
if
(
ReadParam
(
msg
iter
&
tmp
)
)
{
if
(
IsLegalValue
(
tmp
)
)
{
result
-
>
deserialize
(
tmp
)
;
return
true
;
}
}
return
false
;
}
static
constexpr
serializedType
AllEnumBits
(
)
{
return
~
serializedType
(
0
)
>
>
(
std
:
:
numeric_limits
<
serializedType
>
:
:
digits
-
(
mozilla
:
:
MaxEnumValue
<
T
>
:
:
value
+
1
)
)
;
}
static
constexpr
bool
IsLegalValue
(
const
serializedType
value
)
{
static_assert
(
mozilla
:
:
MaxEnumValue
<
T
>
:
:
value
<
std
:
:
numeric_limits
<
serializedType
>
:
:
digits
"
Enum
max
value
is
not
in
the
range
!
"
)
;
static_assert
(
std
:
:
is_unsigned
<
decltype
(
mozilla
:
:
MaxEnumValue
<
T
>
:
:
value
)
>
:
:
value
"
Type
of
MaxEnumValue
<
T
>
:
:
value
specialization
should
be
unsigned
!
"
)
;
return
(
value
&
AllEnumBits
(
)
)
=
=
value
;
}
}
;
template
<
class
.
.
.
Ts
>
struct
ParamTraits
<
mozilla
:
:
Variant
<
Ts
.
.
.
>
>
{
typedef
mozilla
:
:
Variant
<
Ts
.
.
.
>
paramType
;
using
Tag
=
typename
mozilla
:
:
detail
:
:
VariantTag
<
Ts
.
.
.
>
:
:
Type
;
struct
VariantWriter
{
Message
*
msg
;
template
<
class
T
>
void
match
(
const
T
&
t
)
{
WriteParam
(
msg
t
)
;
}
}
;
static
void
Write
(
Message
*
msg
const
paramType
&
param
)
{
WriteParam
(
msg
param
.
tag
)
;
param
.
match
(
VariantWriter
{
msg
}
)
;
}
template
<
size_t
N
typename
dummy
=
void
>
struct
VariantReader
{
using
Next
=
VariantReader
<
N
-
1
>
;
static
bool
Read
(
const
Message
*
msg
PickleIterator
*
iter
Tag
tag
paramType
*
result
)
{
if
(
tag
=
=
N
-
1
)
{
typename
mozilla
:
:
detail
:
:
Nth
<
N
-
1
Ts
.
.
.
>
:
:
Type
val
;
if
(
ReadParam
(
msg
iter
&
val
)
)
{
*
result
=
mozilla
:
:
AsVariant
(
val
)
;
return
true
;
}
return
false
;
}
else
{
return
Next
:
:
Read
(
msg
iter
tag
result
)
;
}
}
}
;
template
<
typename
dummy
>
struct
VariantReader
<
0
dummy
>
{
static
bool
Read
(
const
Message
*
msg
PickleIterator
*
iter
Tag
tag
paramType
*
result
)
{
return
false
;
}
}
;
static
bool
Read
(
const
Message
*
msg
PickleIterator
*
iter
paramType
*
result
)
{
Tag
tag
;
if
(
ReadParam
(
msg
iter
&
tag
)
)
{
return
VariantReader
<
sizeof
.
.
.
(
Ts
)
>
:
:
Read
(
msg
iter
tag
result
)
;
}
return
false
;
}
}
;
template
<
typename
T
>
struct
ParamTraits
<
mozilla
:
:
dom
:
:
Optional
<
T
>
>
{
typedef
mozilla
:
:
dom
:
:
Optional
<
T
>
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
if
(
aParam
.
WasPassed
(
)
)
{
WriteParam
(
aMsg
true
)
;
WriteParam
(
aMsg
aParam
.
Value
(
)
)
;
return
;
}
WriteParam
(
aMsg
false
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
bool
wasPassed
=
false
;
if
(
!
ReadParam
(
aMsg
aIter
&
wasPassed
)
)
{
return
false
;
}
aResult
-
>
Reset
(
)
;
if
(
wasPassed
)
{
if
(
!
ReadParam
(
aMsg
aIter
&
aResult
-
>
Construct
(
)
)
)
{
return
false
;
}
}
return
true
;
}
}
;
}
#
endif
