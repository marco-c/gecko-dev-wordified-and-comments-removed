#
include
"
IPCStreamDestination
.
h
"
#
include
"
IPCStreamSource
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
nsIContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PChildToParentStreamChild
.
h
"
#
include
"
mozilla
/
ipc
/
PParentToChildStreamChild
.
h
"
namespace
mozilla
{
namespace
ipc
{
namespace
{
class
IPCStreamSourceChild
final
:
public
PChildToParentStreamChild
public
IPCStreamSource
{
public
:
static
IPCStreamSourceChild
*
Create
(
nsIAsyncInputStream
*
aInputStream
)
{
MOZ_ASSERT
(
aInputStream
)
;
IPCStreamSourceChild
*
source
=
new
IPCStreamSourceChild
(
aInputStream
)
;
if
(
!
source
-
>
Initialize
(
)
)
{
delete
source
;
return
nullptr
;
}
return
source
;
}
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
{
ActorDestroyed
(
)
;
}
IPCResult
RecvRequestClose
(
const
nsresult
&
aRv
)
override
{
OnEnd
(
aRv
)
;
return
IPC_OK
(
)
;
}
void
Close
(
nsresult
aRv
)
override
{
MOZ_ASSERT
(
IPCStreamSource
:
:
mState
=
=
IPCStreamSource
:
:
eClosed
)
;
Unused
<
<
SendClose
(
aRv
)
;
}
void
SendData
(
const
nsCString
&
aBuffer
)
override
{
Unused
<
<
SendBuffer
(
aBuffer
)
;
}
private
:
explicit
IPCStreamSourceChild
(
nsIAsyncInputStream
*
aInputStream
)
:
IPCStreamSource
(
aInputStream
)
{
}
}
;
}
PChildToParentStreamChild
*
IPCStreamSource
:
:
Create
(
nsIAsyncInputStream
*
aInputStream
dom
:
:
nsIContentChild
*
aManager
)
{
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
IPCStreamSourceChild
*
source
=
IPCStreamSourceChild
:
:
Create
(
aInputStream
)
;
if
(
!
source
)
{
return
nullptr
;
}
if
(
!
aManager
-
>
SendPChildToParentStreamConstructor
(
source
)
)
{
return
nullptr
;
}
source
-
>
ActorConstructed
(
)
;
return
source
;
}
PChildToParentStreamChild
*
IPCStreamSource
:
:
Create
(
nsIAsyncInputStream
*
aInputStream
PBackgroundChild
*
aManager
)
{
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
aManager
)
;
IPCStreamSourceChild
*
source
=
IPCStreamSourceChild
:
:
Create
(
aInputStream
)
;
if
(
!
source
)
{
return
nullptr
;
}
if
(
!
aManager
-
>
SendPChildToParentStreamConstructor
(
source
)
)
{
return
nullptr
;
}
source
-
>
ActorConstructed
(
)
;
return
source
;
}
IPCStreamSource
*
IPCStreamSource
:
:
Cast
(
PChildToParentStreamChild
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
return
static_cast
<
IPCStreamSourceChild
*
>
(
aActor
)
;
}
namespace
{
class
IPCStreamDestinationChild
final
:
public
PParentToChildStreamChild
public
IPCStreamDestination
{
public
:
nsresult
Initialize
(
)
{
return
IPCStreamDestination
:
:
Initialize
(
)
;
}
~
IPCStreamDestinationChild
(
)
{
}
private
:
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
{
ActorDestroyed
(
)
;
}
IPCResult
RecvBuffer
(
const
nsCString
&
aBuffer
)
override
{
BufferReceived
(
aBuffer
)
;
return
IPC_OK
(
)
;
}
IPCResult
RecvClose
(
const
nsresult
&
aRv
)
override
{
CloseReceived
(
aRv
)
;
return
IPC_OK
(
)
;
}
void
RequestClose
(
nsresult
aRv
)
override
{
Unused
<
<
SendRequestClose
(
aRv
)
;
}
void
TerminateDestination
(
)
override
{
Unused
<
<
Send__delete__
(
this
)
;
}
}
;
}
PParentToChildStreamChild
*
AllocPParentToChildStreamChild
(
)
{
IPCStreamDestinationChild
*
actor
=
new
IPCStreamDestinationChild
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
actor
-
>
Initialize
(
)
)
)
)
{
delete
actor
;
actor
=
nullptr
;
}
return
actor
;
}
void
DeallocPParentToChildStreamChild
(
PParentToChildStreamChild
*
aActor
)
{
delete
aActor
;
}
IPCStreamDestination
*
IPCStreamDestination
:
:
Cast
(
PParentToChildStreamChild
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
return
static_cast
<
IPCStreamDestinationChild
*
>
(
aActor
)
;
}
}
}
