#
ifndef
_include_ipc_glue_UtilityProcessManager_h_
#
define
_include_ipc_glue_UtilityProcessManager_h_
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessHost
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
PRemoteDecoderManagerChild
.
h
"
namespace
mozilla
{
class
MemoryReportingProcess
;
namespace
dom
{
class
JSOracleParent
;
class
WindowsUtilsParent
;
}
namespace
widget
:
:
filedialog
{
class
ProcessProxy
;
}
namespace
ipc
{
class
UtilityProcessParent
;
class
UtilityProcessManager
final
:
public
UtilityProcessHost
:
:
Listener
{
friend
class
UtilityProcessParent
;
public
:
template
<
typename
T
>
using
Promise
=
MozPromise
<
T
nsresult
true
>
;
using
StartRemoteDecodingUtilityPromise
=
Promise
<
Endpoint
<
PRemoteDecoderManagerChild
>
>
;
using
JSOraclePromise
=
GenericNonExclusivePromise
;
#
ifdef
XP_WIN
using
WindowsUtilsPromise
=
Promise
<
RefPtr
<
dom
:
:
WindowsUtilsParent
>
>
;
using
WinFileDialogPromise
=
Promise
<
widget
:
:
filedialog
:
:
ProcessProxy
>
;
#
endif
static
RefPtr
<
UtilityProcessManager
>
GetSingleton
(
)
;
static
RefPtr
<
UtilityProcessManager
>
GetIfExists
(
)
;
RefPtr
<
GenericNonExclusivePromise
>
LaunchProcess
(
SandboxingKind
aSandbox
)
;
template
<
typename
Actor
>
RefPtr
<
GenericNonExclusivePromise
>
StartUtility
(
RefPtr
<
Actor
>
aActor
SandboxingKind
aSandbox
)
;
RefPtr
<
StartRemoteDecodingUtilityPromise
>
StartProcessForRemoteMediaDecoding
(
base
:
:
ProcessId
aOtherProcess
SandboxingKind
aSandbox
)
;
RefPtr
<
JSOraclePromise
>
StartJSOracle
(
mozilla
:
:
dom
:
:
JSOracleParent
*
aParent
)
;
#
ifdef
XP_WIN
RefPtr
<
WindowsUtilsPromise
>
GetWindowsUtilsPromise
(
)
;
void
ReleaseWindowsUtils
(
)
;
RefPtr
<
WinFileDialogPromise
>
CreateWinFileDialogAsync
(
)
;
#
endif
void
OnProcessUnexpectedShutdown
(
UtilityProcessHost
*
aHost
)
;
Maybe
<
base
:
:
ProcessId
>
ProcessPid
(
SandboxingKind
aSandbox
)
;
RefPtr
<
MemoryReportingProcess
>
GetProcessMemoryReporter
(
UtilityProcessParent
*
parent
)
;
RefPtr
<
UtilityProcessParent
>
GetProcessParent
(
SandboxingKind
aSandbox
)
{
RefPtr
<
ProcessFields
>
p
=
GetProcess
(
aSandbox
)
;
if
(
!
p
)
{
return
nullptr
;
}
return
p
-
>
mProcessParent
;
}
nsTArray
<
RefPtr
<
UtilityProcessParent
>
>
GetAllProcessesProcessParent
(
)
{
nsTArray
<
RefPtr
<
UtilityProcessParent
>
>
rv
;
for
(
auto
&
p
:
mProcesses
)
{
if
(
p
&
&
p
-
>
mProcessParent
)
{
rv
.
AppendElement
(
p
-
>
mProcessParent
)
;
}
}
return
rv
;
}
UtilityProcessHost
*
Process
(
SandboxingKind
aSandbox
)
{
RefPtr
<
ProcessFields
>
p
=
GetProcess
(
aSandbox
)
;
if
(
!
p
)
{
return
nullptr
;
}
return
p
-
>
mProcess
;
}
void
RegisterActor
(
const
RefPtr
<
UtilityProcessParent
>
&
aParent
UtilityActorName
aActorName
)
{
for
(
auto
&
p
:
mProcesses
)
{
if
(
p
&
&
p
-
>
mProcessParent
&
&
p
-
>
mProcessParent
=
=
aParent
)
{
p
-
>
mActors
.
AppendElement
(
aActorName
)
;
return
;
}
}
}
Span
<
const
UtilityActorName
>
GetActors
(
const
RefPtr
<
UtilityProcessParent
>
&
aParent
)
{
for
(
auto
&
p
:
mProcesses
)
{
if
(
p
&
&
p
-
>
mProcessParent
&
&
p
-
>
mProcessParent
=
=
aParent
)
{
return
p
-
>
mActors
;
}
}
return
{
}
;
}
Span
<
const
UtilityActorName
>
GetActors
(
GeckoChildProcessHost
*
aHost
)
{
for
(
auto
&
p
:
mProcesses
)
{
if
(
p
&
&
p
-
>
mProcess
=
=
aHost
)
{
return
p
-
>
mActors
;
}
}
return
{
}
;
}
Span
<
const
UtilityActorName
>
GetActors
(
SandboxingKind
aSbKind
)
{
auto
proc
=
GetProcess
(
aSbKind
)
;
if
(
!
proc
)
{
return
{
}
;
}
return
proc
-
>
mActors
;
}
void
CleanShutdown
(
SandboxingKind
aSandbox
)
;
void
CleanShutdownAllProcesses
(
)
;
uint16_t
AliveProcesses
(
)
;
private
:
~
UtilityProcessManager
(
)
;
bool
IsProcessLaunching
(
SandboxingKind
aSandbox
)
;
bool
IsProcessDestroyed
(
SandboxingKind
aSandbox
)
;
void
OnXPCOMShutdown
(
)
;
void
OnPreferenceChange
(
const
char16_t
*
aData
)
;
UtilityProcessManager
(
)
;
void
Init
(
)
;
void
DestroyProcess
(
SandboxingKind
aSandbox
)
;
bool
IsShutdown
(
)
const
;
class
Observer
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
Observer
(
UtilityProcessManager
*
aManager
)
;
protected
:
~
Observer
(
)
=
default
;
RefPtr
<
UtilityProcessManager
>
mManager
;
}
;
friend
class
Observer
;
RefPtr
<
Observer
>
mObserver
;
class
ProcessFields
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
ProcessFields
)
;
explicit
ProcessFields
(
SandboxingKind
aSandbox
)
:
mSandbox
(
aSandbox
)
{
}
;
RefPtr
<
GenericNonExclusivePromise
>
mLaunchPromise
;
uint32_t
mNumProcessAttempts
=
0
;
uint32_t
mNumUnexpectedCrashes
=
0
;
UtilityProcessHost
*
mProcess
=
nullptr
;
RefPtr
<
UtilityProcessParent
>
mProcessParent
=
nullptr
;
nsTArray
<
dom
:
:
Pref
>
mQueuedPrefs
;
nsTArray
<
UtilityActorName
>
mActors
;
SandboxingKind
mSandbox
=
SandboxingKind
:
:
COUNT
;
protected
:
~
ProcessFields
(
)
=
default
;
}
;
EnumeratedArray
<
SandboxingKind
SandboxingKind
:
:
COUNT
RefPtr
<
ProcessFields
>
>
mProcesses
;
RefPtr
<
ProcessFields
>
GetProcess
(
SandboxingKind
)
;
bool
NoMoreProcesses
(
)
;
#
ifdef
XP_WIN
RefPtr
<
dom
:
:
WindowsUtilsParent
>
mWindowsUtils
;
#
endif
}
;
}
}
#
endif
