#
include
"
SharedMemoryPlatform
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
ifdef
XP_LINUX
#
include
"
base
/
linux_memfd_defs
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
endif
#
ifdef
__FreeBSD__
#
include
<
sys
/
capsicum
.
h
>
#
endif
#
ifdef
MOZ_VALGRIND
#
include
<
valgrind
/
valgrind
.
h
>
#
endif
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ProfilerThreadSleep
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsXULAppAPI
.
h
"
namespace
mozilla
:
:
ipc
:
:
shared_memory
{
#
if
!
defined
(
HAVE_MEMFD_CREATE
)
&
&
defined
(
XP_LINUX
)
&
&
\
defined
(
SYS_memfd_create
)
static
int
memfd_create
(
const
char
*
aName
unsigned
int
aFlags
)
{
return
syscall
(
SYS_memfd_create
aName
aFlags
)
;
}
#
define
HAVE_MEMFD_CREATE
1
#
endif
#
ifdef
HAVE_MEMFD_CREATE
#
ifdef
XP_LINUX
#
define
USE_MEMFD_CREATE
1
static
int
DupReadOnly
(
int
aFd
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
std
:
:
string
path
=
StringPrintf
(
"
/
proc
/
self
/
fd
/
%
d
"
aFd
)
;
return
HANDLE_EINTR
(
open
(
path
.
c_str
(
)
O_RDONLY
|
O_CLOEXEC
)
)
;
}
#
elif
defined
(
__FreeBSD__
)
#
define
USE_MEMFD_CREATE
1
static
int
DupReadOnly
(
int
aFd
)
{
int
rofd
=
dup
(
aFd
)
;
if
(
rofd
<
0
)
{
return
-
1
;
}
cap_rights_t
rights
;
cap_rights_init
(
&
rights
CAP_FSTAT
CAP_MMAP_R
)
;
if
(
cap_rights_limit
(
rofd
&
rights
)
<
0
)
{
int
err
=
errno
;
close
(
rofd
)
;
errno
=
err
;
return
-
1
;
}
return
rofd
;
}
#
else
#
warning
"
OS
has
memfd_create
but
no
DupReadOnly
implementation
"
#
endif
#
endif
static
Maybe
<
unsigned
>
HaveMemfd
(
)
{
#
ifdef
USE_MEMFD_CREATE
static
const
Maybe
<
unsigned
>
kHave
=
[
]
(
)
-
>
Maybe
<
unsigned
>
{
unsigned
flags
=
MFD_CLOEXEC
|
MFD_ALLOW_SEALING
;
#
ifdef
MFD_NOEXEC_SEAL
flags
|
=
MFD_NOEXEC_SEAL
;
#
endif
mozilla
:
:
UniqueFileHandle
fd
(
memfd_create
(
"
mozilla
-
ipc
-
test
"
flags
)
)
;
#
ifdef
MFD_NOEXEC_SEAL
if
(
!
fd
&
&
errno
=
=
EINVAL
)
{
flags
&
=
~
MFD_NOEXEC_SEAL
;
fd
.
reset
(
memfd_create
(
"
mozilla
-
ipc
-
test
"
flags
)
)
;
}
#
endif
if
(
!
fd
)
{
MOZ_ASSERT
(
errno
=
=
ENOSYS
)
;
return
Nothing
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
mozilla
:
:
UniqueFileHandle
rofd
(
DupReadOnly
(
fd
.
get
(
)
)
)
;
if
(
!
rofd
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
read
-
only
dup
failed
(
{
}
)
;
not
using
memfd
"
strerror
(
errno
)
)
;
return
Nothing
(
)
;
}
}
return
Some
(
flags
)
;
}
(
)
;
return
kHave
;
#
else
return
Nothing
(
)
;
#
endif
}
static
bool
AppendPosixShmPrefix
(
std
:
:
string
*
aStr
pid_t
aPid
)
{
if
(
HaveMemfd
(
)
)
{
return
false
;
}
*
aStr
+
=
'
/
'
;
#
ifdef
MOZ_WIDGET_GTK
if
(
const
char
*
snap
=
mozilla
:
:
widget
:
:
GetSnapInstanceName
(
)
)
{
StringAppendF
(
aStr
"
snap
.
%
s
.
"
snap
)
;
}
#
endif
StringAppendF
(
aStr
"
org
.
mozilla
.
ipc
.
%
d
.
"
static_cast
<
int
>
(
aPid
)
)
;
return
true
;
}
static
Maybe
<
PlatformHandle
>
CreateImpl
(
size_t
aSize
PlatformHandle
*
aFreezable
)
{
MOZ_ASSERT
(
aSize
>
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aFreezable
|
|
XRE_IsParentProcess
(
)
"
Child
processes
may
not
create
freezable
shared
memory
"
)
;
mozilla
:
:
UniqueFileHandle
fd
;
mozilla
:
:
UniqueFileHandle
frozen_fd
;
#
ifdef
USE_MEMFD_CREATE
if
(
auto
flags
=
HaveMemfd
(
)
)
{
fd
.
reset
(
memfd_create
(
"
mozilla
-
ipc
"
*
flags
)
)
;
if
(
!
fd
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
failed
to
create
memfd
:
{
}
"
strerror
(
errno
)
)
;
return
Nothing
(
)
;
}
if
(
aFreezable
)
{
frozen_fd
.
reset
(
DupReadOnly
(
fd
.
get
(
)
)
)
;
if
(
!
frozen_fd
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
failed
to
create
read
-
only
memfd
:
{
}
"
strerror
(
errno
)
)
;
return
Nothing
(
)
;
}
}
}
#
endif
if
(
!
fd
)
{
do
{
static
mozilla
:
:
Atomic
<
size_t
>
sNameCounter
;
std
:
:
string
name
;
CHECK
(
AppendPosixShmPrefix
(
&
name
getpid
(
)
)
)
;
StringAppendF
(
&
name
"
%
zu
"
sNameCounter
+
+
)
;
fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDWR
|
O_CREAT
|
O_EXCL
0600
)
)
)
;
if
(
fd
)
{
if
(
aFreezable
)
{
frozen_fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDONLY
0400
)
)
)
;
if
(
!
frozen_fd
)
{
int
open_err
=
errno
;
shm_unlink
(
name
.
c_str
(
)
)
;
DLOG
(
FATAL
)
<
<
"
failed
to
re
-
open
freezable
shm
:
"
<
<
strerror
(
open_err
)
;
return
Nothing
(
)
;
}
}
if
(
shm_unlink
(
name
.
c_str
(
)
)
!
=
0
)
{
DLOG
(
FATAL
)
<
<
"
failed
to
unlink
shm
:
"
<
<
strerror
(
errno
)
;
return
Nothing
(
)
;
}
}
}
while
(
!
fd
&
&
errno
=
=
EEXIST
)
;
}
if
(
!
fd
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
failed
to
open
shm
:
{
}
"
strerror
(
errno
)
)
;
return
Nothing
(
)
;
}
mozilla
:
:
Maybe
<
int
>
fallocateError
;
#
if
defined
(
HAVE_POSIX_FALLOCATE
)
if
(
!
HaveMemfd
(
)
)
{
int
rv
;
{
AUTO_PROFILER_THREAD_SLEEP
;
rv
=
HANDLE_RV_EINTR
(
posix_fallocate
(
fd
.
get
(
)
0
static_cast
<
off_t
>
(
aSize
)
)
)
;
}
if
(
rv
!
=
0
&
&
rv
!
=
EOPNOTSUPP
&
&
rv
!
=
EINVAL
&
&
rv
!
=
ENODEV
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
fallocate
failed
to
set
shm
size
:
{
}
"
strerror
(
rv
)
)
;
return
Nothing
(
)
;
}
fallocateError
=
mozilla
:
:
Some
(
rv
)
;
}
#
endif
if
(
fallocateError
!
=
mozilla
:
:
Some
(
0
)
)
{
int
rv
=
HANDLE_EINTR
(
ftruncate
(
fd
.
get
(
)
static_cast
<
off_t
>
(
aSize
)
)
)
;
if
(
rv
!
=
0
)
{
int
ftruncate_errno
=
errno
;
if
(
fallocateError
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
fallocate
failed
to
set
shm
size
:
{
}
"
strerror
(
*
fallocateError
)
)
;
}
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
fallocate
failed
to
set
shm
size
:
{
}
"
strerror
(
ftruncate_errno
)
)
;
return
Nothing
(
)
;
}
}
if
(
aFreezable
)
{
*
aFreezable
=
std
:
:
move
(
frozen_fd
)
;
}
return
Some
(
std
:
:
move
(
fd
)
)
;
}
bool
Platform
:
:
Create
(
Handle
&
aHandle
size_t
aSize
)
{
if
(
auto
ph
=
CreateImpl
(
aSize
nullptr
)
)
{
aHandle
.
mHandle
=
std
:
:
move
(
*
ph
)
;
aHandle
.
mSize
=
aSize
;
return
true
;
}
return
false
;
}
bool
Platform
:
:
CreateFreezable
(
FreezableHandle
&
aHandle
size_t
aSize
)
{
if
(
auto
ph
=
CreateImpl
(
aSize
&
aHandle
.
mFrozenFile
)
)
{
aHandle
.
mHandle
=
std
:
:
move
(
*
ph
)
;
aHandle
.
mSize
=
aSize
;
return
true
;
}
return
false
;
}
PlatformHandle
Platform
:
:
CloneHandle
(
const
PlatformHandle
&
aHandle
)
{
const
int
new_fd
=
dup
(
aHandle
.
get
(
)
)
;
if
(
new_fd
<
0
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
failed
to
duplicate
file
descriptor
:
{
}
"
strerror
(
errno
)
)
;
return
nullptr
;
}
return
mozilla
:
:
UniqueFileHandle
(
new_fd
)
;
}
bool
Platform
:
:
Freeze
(
FreezableHandle
&
aHandle
)
{
#
ifdef
USE_MEMFD_CREATE
#
ifdef
MOZ_VALGRIND
static
const
bool
haveSeals
=
RUNNING_ON_VALGRIND
=
=
0
;
#
else
static
const
bool
haveSeals
=
true
;
#
endif
static
const
bool
useSeals
=
!
PR_GetEnv
(
"
MOZ_SHM_NO_SEALS
"
)
;
if
(
HaveMemfd
(
)
&
&
haveSeals
&
&
useSeals
)
{
const
int
seals
=
F_SEAL_GROW
|
F_SEAL_SHRINK
|
F_SEAL_SEAL
;
int
sealError
=
EINVAL
;
#
ifdef
F_SEAL_FUTURE_WRITE
sealError
=
fcntl
(
aHandle
.
mHandle
.
get
(
)
F_ADD_SEALS
seals
|
F_SEAL_FUTURE_WRITE
)
=
=
0
?
0
:
errno
;
#
endif
if
(
sealError
=
=
EINVAL
)
{
sealError
=
fcntl
(
aHandle
.
mHandle
.
get
(
)
F_ADD_SEALS
seals
)
=
=
0
?
0
:
errno
;
}
if
(
sealError
!
=
0
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
failed
to
seal
memfd
:
{
}
"
strerror
(
errno
)
)
;
return
false
;
}
}
#
else
MOZ_ASSERT
(
!
HaveMemfd
(
)
)
;
#
endif
MOZ_ASSERT
(
aHandle
.
mFrozenFile
)
;
MOZ_ASSERT
(
aHandle
.
mHandle
)
;
aHandle
.
mHandle
=
std
:
:
move
(
aHandle
.
mFrozenFile
)
;
MOZ_ASSERT
(
aHandle
.
mHandle
)
;
return
true
;
}
Maybe
<
void
*
>
Platform
:
:
Map
(
const
HandleBase
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
bool
aReadOnly
)
{
void
*
mem
=
mmap
(
aFixedAddress
aSize
PROT_READ
|
(
aReadOnly
?
0
:
PROT_WRITE
)
MAP_SHARED
aHandle
.
mHandle
.
get
(
)
aOffset
)
;
if
(
mem
=
=
MAP_FAILED
)
{
MOZ_LOG_FMT
(
gSharedMemoryLog
LogLevel
:
:
Warning
"
call
to
mmap
failed
:
{
}
"
strerror
(
errno
)
)
;
return
Nothing
(
)
;
}
if
(
aFixedAddress
&
&
mem
!
=
aFixedAddress
)
{
DebugOnly
<
bool
>
munmap_succeeded
=
munmap
(
mem
aSize
)
=
=
0
;
MOZ_ASSERT
(
munmap_succeeded
"
call
to
munmap
failed
"
)
;
return
Nothing
(
)
;
}
return
Some
(
mem
)
;
}
void
Platform
:
:
Unmap
(
void
*
aMemory
size_t
aSize
)
{
munmap
(
aMemory
aSize
)
;
}
bool
Platform
:
:
Protect
(
char
*
aAddr
size_t
aSize
Access
aAccess
)
{
int
flags
=
PROT_NONE
;
if
(
aAccess
&
AccessRead
)
flags
|
=
PROT_READ
;
if
(
aAccess
&
AccessWrite
)
flags
|
=
PROT_WRITE
;
return
0
=
=
mprotect
(
aAddr
aSize
flags
)
;
}
void
*
Platform
:
:
FindFreeAddressSpace
(
size_t
aSize
)
{
void
*
memory
=
mmap
(
nullptr
aSize
PROT_NONE
MAP_ANONYMOUS
|
MAP_NORESERVE
|
MAP_PRIVATE
-
1
0
)
;
if
(
memory
=
=
MAP_FAILED
)
{
return
nullptr
;
}
munmap
(
memory
aSize
)
;
return
memory
;
}
size_t
Platform
:
:
PageSize
(
)
{
return
sysconf
(
_SC_PAGESIZE
)
;
}
size_t
Platform
:
:
AllocationGranularity
(
)
{
return
PageSize
(
)
;
}
bool
Platform
:
:
IsSafeToMap
(
const
PlatformHandle
&
)
{
return
true
;
}
}
