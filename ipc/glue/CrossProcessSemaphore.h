#
ifndef
mozilla_CrossProcessSemaphore_h
#
define
mozilla_CrossProcessSemaphore_h
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
if
!
defined
(
OS_WIN
)
&
&
!
defined
(
OS_MACOSX
)
#
include
<
pthread
.
h
>
#
include
<
semaphore
.
h
>
#
include
"
SharedMemoryBasic
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
endif
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
template
<
typename
T
>
inline
bool
IsHandleValid
(
const
T
&
handle
)
{
return
bool
(
handle
)
;
}
#
if
defined
(
OS_WIN
)
typedef
HANDLE
CrossProcessSemaphoreHandle
;
#
elif
!
defined
(
OS_MACOSX
)
typedef
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
CrossProcessSemaphoreHandle
;
template
<
>
inline
bool
IsHandleValid
<
CrossProcessSemaphoreHandle
>
(
const
CrossProcessSemaphoreHandle
&
handle
)
{
return
!
(
handle
=
=
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
NULLHandle
(
)
)
;
}
#
else
typedef
uintptr_t
CrossProcessSemaphoreHandle
;
#
endif
class
CrossProcessSemaphore
{
public
:
static
CrossProcessSemaphore
*
Create
(
const
char
*
aName
uint32_t
aInitialValue
)
;
static
CrossProcessSemaphore
*
Create
(
CrossProcessSemaphoreHandle
aHandle
)
;
~
CrossProcessSemaphore
(
)
;
bool
Wait
(
const
Maybe
<
TimeDuration
>
&
aWaitTime
=
Nothing
(
)
)
;
void
Signal
(
)
;
CrossProcessSemaphoreHandle
ShareToProcess
(
base
:
:
ProcessId
aTargetPid
)
;
void
CloseHandle
(
)
;
private
:
friend
struct
IPC
:
:
ParamTraits
<
CrossProcessSemaphore
>
;
CrossProcessSemaphore
(
)
;
CrossProcessSemaphore
(
const
CrossProcessSemaphore
&
)
;
CrossProcessSemaphore
&
operator
=
(
const
CrossProcessSemaphore
&
)
;
#
if
defined
(
OS_WIN
)
explicit
CrossProcessSemaphore
(
HANDLE
aSemaphore
)
;
HANDLE
mSemaphore
;
#
elif
!
defined
(
OS_MACOSX
)
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
mSharedBuffer
;
sem_t
*
mSemaphore
;
mozilla
:
:
Atomic
<
int32_t
>
*
mRefCount
;
#
endif
}
;
}
#
endif
