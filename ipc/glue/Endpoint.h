#
ifndef
IPC_GLUE_ENDPOINT_H_
#
define
IPC_GLUE_ENDPOINT_H_
#
include
<
utility
>
#
include
"
CrashAnnotations
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
NodeController
.
h
"
#
include
"
mozilla
/
ipc
/
ScopedPort
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nscore
.
h
"
namespace
IPC
{
template
<
class
P
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
ipc
{
namespace
endpoint_detail
{
template
<
class
T
>
static
auto
ActorNeedsOtherPidHelper
(
int
)
-
>
decltype
(
std
:
:
declval
<
T
>
(
)
.
OtherPid
(
)
std
:
:
true_type
{
}
)
;
template
<
class
>
static
auto
ActorNeedsOtherPidHelper
(
long
)
-
>
std
:
:
false_type
;
template
<
typename
T
>
constexpr
bool
ActorNeedsOtherPid
=
decltype
(
ActorNeedsOtherPidHelper
<
T
>
(
0
)
)
:
:
value
;
}
struct
PrivateIPDLInterface
{
}
;
template
<
class
PFooSide
>
class
Endpoint
{
public
:
using
ProcessId
=
base
:
:
ProcessId
;
Endpoint
(
)
=
default
;
Endpoint
(
const
PrivateIPDLInterface
&
ScopedPort
aPort
ProcessId
aMyPid
=
base
:
:
kInvalidProcessId
ProcessId
aOtherPid
=
base
:
:
kInvalidProcessId
)
:
mPort
(
std
:
:
move
(
aPort
)
)
mMyPid
(
aMyPid
)
mOtherPid
(
aOtherPid
)
{
}
Endpoint
(
const
Endpoint
&
)
=
delete
;
Endpoint
(
Endpoint
&
&
aOther
)
=
default
;
Endpoint
&
operator
=
(
const
Endpoint
&
)
=
delete
;
Endpoint
&
operator
=
(
Endpoint
&
&
aOther
)
=
default
;
base
:
:
ProcessId
OtherPid
(
)
const
{
static_assert
(
endpoint_detail
:
:
ActorNeedsOtherPid
<
PFooSide
>
"
OtherPid
may
only
be
called
on
Endpoints
for
actors
which
are
"
"
[
NeedsOtherPid
]
"
)
;
MOZ_RELEASE_ASSERT
(
mOtherPid
!
=
base
:
:
kInvalidProcessId
)
;
return
mOtherPid
;
}
bool
Bind
(
PFooSide
*
aActor
)
{
MOZ_RELEASE_ASSERT
(
IsValid
(
)
)
;
MOZ_RELEASE_ASSERT
(
mMyPid
=
=
base
:
:
kInvalidProcessId
|
|
mMyPid
=
=
base
:
:
GetCurrentProcId
(
)
)
;
return
aActor
-
>
Open
(
std
:
:
move
(
mPort
)
mOtherPid
)
;
}
bool
IsValid
(
)
const
{
return
mPort
.
IsValid
(
)
;
}
private
:
friend
struct
IPC
:
:
ParamTraits
<
Endpoint
<
PFooSide
>
>
;
ScopedPort
mPort
;
ProcessId
mMyPid
=
base
:
:
kInvalidProcessId
;
ProcessId
mOtherPid
=
base
:
:
kInvalidProcessId
;
}
;
#
if
defined
(
XP_MACOSX
)
void
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
tag
int
error
)
;
#
else
inline
void
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
tag
int
error
)
{
}
#
endif
template
<
class
PFooParent
class
PFooChild
>
nsresult
CreateEndpoints
(
const
PrivateIPDLInterface
&
aPrivate
Endpoint
<
PFooParent
>
*
aParentEndpoint
Endpoint
<
PFooChild
>
*
aChildEndpoint
)
{
static_assert
(
!
endpoint_detail
:
:
ActorNeedsOtherPid
<
PFooParent
>
&
&
!
endpoint_detail
:
:
ActorNeedsOtherPid
<
PFooChild
>
"
Pids
are
required
when
creating
endpoints
for
[
NeedsOtherPid
]
actors
"
)
;
auto
[
parentPort
childPort
]
=
NodeController
:
:
GetSingleton
(
)
-
>
CreatePortPair
(
)
;
*
aParentEndpoint
=
Endpoint
<
PFooParent
>
(
aPrivate
std
:
:
move
(
parentPort
)
)
;
*
aChildEndpoint
=
Endpoint
<
PFooChild
>
(
aPrivate
std
:
:
move
(
childPort
)
)
;
return
NS_OK
;
}
template
<
class
PFooParent
class
PFooChild
>
nsresult
CreateEndpoints
(
const
PrivateIPDLInterface
&
aPrivate
base
:
:
ProcessId
aParentDestPid
base
:
:
ProcessId
aChildDestPid
Endpoint
<
PFooParent
>
*
aParentEndpoint
Endpoint
<
PFooChild
>
*
aChildEndpoint
)
{
MOZ_RELEASE_ASSERT
(
aParentDestPid
!
=
base
:
:
kInvalidProcessId
)
;
MOZ_RELEASE_ASSERT
(
aChildDestPid
!
=
base
:
:
kInvalidProcessId
)
;
auto
[
parentPort
childPort
]
=
NodeController
:
:
GetSingleton
(
)
-
>
CreatePortPair
(
)
;
*
aParentEndpoint
=
Endpoint
<
PFooParent
>
(
aPrivate
std
:
:
move
(
parentPort
)
aParentDestPid
aChildDestPid
)
;
*
aChildEndpoint
=
Endpoint
<
PFooChild
>
(
aPrivate
std
:
:
move
(
childPort
)
aChildDestPid
aParentDestPid
)
;
return
NS_OK
;
}
class
UntypedManagedEndpoint
{
public
:
bool
IsValid
(
)
const
{
return
mInner
.
isSome
(
)
;
}
UntypedManagedEndpoint
(
const
UntypedManagedEndpoint
&
)
=
delete
;
UntypedManagedEndpoint
&
operator
=
(
const
UntypedManagedEndpoint
&
)
=
delete
;
protected
:
UntypedManagedEndpoint
(
)
=
default
;
explicit
UntypedManagedEndpoint
(
IProtocol
*
aActor
)
;
UntypedManagedEndpoint
(
UntypedManagedEndpoint
&
&
aOther
)
noexcept
:
mInner
(
std
:
:
move
(
aOther
.
mInner
)
)
{
aOther
.
mInner
=
Nothing
(
)
;
}
UntypedManagedEndpoint
&
operator
=
(
UntypedManagedEndpoint
&
&
aOther
)
noexcept
{
this
-
>
~
UntypedManagedEndpoint
(
)
;
new
(
this
)
UntypedManagedEndpoint
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
~
UntypedManagedEndpoint
(
)
noexcept
;
bool
BindCommon
(
IProtocol
*
aActor
IProtocol
*
aManager
)
;
private
:
friend
struct
IPDLParamTraits
<
UntypedManagedEndpoint
>
;
struct
Inner
{
RefPtr
<
WeakActorLifecycleProxy
>
mOtherSide
;
RefPtr
<
WeakActorLifecycleProxy
>
mToplevel
;
int32_t
mId
=
0
;
ProtocolId
mType
=
LastMsgIndex
;
int32_t
mManagerId
=
0
;
ProtocolId
mManagerType
=
LastMsgIndex
;
}
;
Maybe
<
Inner
>
mInner
;
}
;
template
<
class
PFooSide
>
class
ManagedEndpoint
:
public
UntypedManagedEndpoint
{
public
:
ManagedEndpoint
(
)
=
default
;
ManagedEndpoint
(
ManagedEndpoint
&
&
)
noexcept
=
default
;
ManagedEndpoint
&
operator
=
(
ManagedEndpoint
&
&
)
noexcept
=
default
;
ManagedEndpoint
(
const
PrivateIPDLInterface
&
IProtocol
*
aActor
)
:
UntypedManagedEndpoint
(
aActor
)
{
}
bool
Bind
(
const
PrivateIPDLInterface
&
PFooSide
*
aActor
IProtocol
*
aManager
ManagedContainer
<
PFooSide
>
&
aContainer
)
{
if
(
!
BindCommon
(
aActor
aManager
)
)
{
return
false
;
}
aContainer
.
Insert
(
aActor
)
;
return
true
;
}
bool
operator
=
=
(
const
ManagedEndpoint
&
_o
)
const
{
return
!
IsValid
(
)
&
&
!
_o
.
IsValid
(
)
;
}
}
;
}
}
#
endif
