#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
SizePrintfMacros
.
h
"
#
include
"
mozilla
/
Snprintf
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsContentUtils
.
h
"
#
undef
compress
#
ifdef
MOZ_B2G
#
define
IPC_LOG
(
.
.
.
)
#
else
static
LazyLogModule
sLogModule
(
"
ipc
"
)
;
#
define
IPC_LOG
(
.
.
.
)
MOZ_LOG
(
sLogModule
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
endif
using
namespace
mozilla
;
using
namespace
std
;
using
mozilla
:
:
dom
:
:
AutoNoJSAPI
;
using
mozilla
:
:
dom
:
:
ScriptSettingsInitialized
;
using
mozilla
:
:
MonitorAutoLock
;
using
mozilla
:
:
MonitorAutoUnlock
;
template
<
>
struct
RunnableMethodTraits
<
mozilla
:
:
ipc
:
:
MessageChannel
>
{
static
void
RetainCallee
(
mozilla
:
:
ipc
:
:
MessageChannel
*
obj
)
{
}
static
void
ReleaseCallee
(
mozilla
:
:
ipc
:
:
MessageChannel
*
obj
)
{
}
}
;
#
define
IPC_ASSERT
(
_cond
.
.
.
)
\
do
{
\
if
(
!
(
_cond
)
)
\
DebugAbort
(
__FILE__
__LINE__
#
_cond
#
#
__VA_ARGS__
)
;
\
}
while
(
0
)
static
MessageChannel
*
gParentProcessBlocker
;
namespace
mozilla
{
namespace
ipc
{
static
const
uint32_t
kMinTelemetryMessageSize
=
8192
;
const
int32_t
MessageChannel
:
:
kNoTimeout
=
INT32_MIN
;
bool
MessageChannel
:
:
sIsPumpingMessages
=
false
;
enum
Direction
{
IN_MESSAGE
OUT_MESSAGE
}
;
class
MessageChannel
:
:
InterruptFrame
{
private
:
enum
Semantics
{
INTR_SEMS
SYNC_SEMS
ASYNC_SEMS
}
;
public
:
InterruptFrame
(
Direction
direction
const
Message
*
msg
)
:
mMessageName
(
msg
-
>
name
(
)
)
mMessageRoutingId
(
msg
-
>
routing_id
(
)
)
mMesageSemantics
(
msg
-
>
is_interrupt
(
)
?
INTR_SEMS
:
msg
-
>
is_sync
(
)
?
SYNC_SEMS
:
ASYNC_SEMS
)
mDirection
(
direction
)
mMoved
(
false
)
{
MOZ_RELEASE_ASSERT
(
mMessageName
)
;
}
InterruptFrame
(
InterruptFrame
&
&
aOther
)
{
MOZ_RELEASE_ASSERT
(
aOther
.
mMessageName
)
;
mMessageName
=
aOther
.
mMessageName
;
aOther
.
mMessageName
=
nullptr
;
mMoved
=
aOther
.
mMoved
;
aOther
.
mMoved
=
true
;
mMessageRoutingId
=
aOther
.
mMessageRoutingId
;
mMesageSemantics
=
aOther
.
mMesageSemantics
;
mDirection
=
aOther
.
mDirection
;
}
~
InterruptFrame
(
)
{
MOZ_RELEASE_ASSERT
(
mMessageName
|
|
mMoved
)
;
}
InterruptFrame
&
operator
=
(
InterruptFrame
&
&
aOther
)
{
MOZ_RELEASE_ASSERT
(
&
aOther
!
=
this
)
;
this
-
>
~
InterruptFrame
(
)
;
new
(
this
)
InterruptFrame
(
mozilla
:
:
Move
(
aOther
)
)
;
return
*
this
;
}
bool
IsInterruptIncall
(
)
const
{
return
INTR_SEMS
=
=
mMesageSemantics
&
&
IN_MESSAGE
=
=
mDirection
;
}
bool
IsInterruptOutcall
(
)
const
{
return
INTR_SEMS
=
=
mMesageSemantics
&
&
OUT_MESSAGE
=
=
mDirection
;
}
bool
IsOutgoingSync
(
)
const
{
return
(
mMesageSemantics
=
=
INTR_SEMS
|
|
mMesageSemantics
=
=
SYNC_SEMS
)
&
&
mDirection
=
=
OUT_MESSAGE
;
}
void
Describe
(
int32_t
*
id
const
char
*
*
dir
const
char
*
*
sems
const
char
*
*
name
)
const
{
*
id
=
mMessageRoutingId
;
*
dir
=
(
IN_MESSAGE
=
=
mDirection
)
?
"
in
"
:
"
out
"
;
*
sems
=
(
INTR_SEMS
=
=
mMesageSemantics
)
?
"
intr
"
:
(
SYNC_SEMS
=
=
mMesageSemantics
)
?
"
sync
"
:
"
async
"
;
*
name
=
mMessageName
;
}
int32_t
GetRoutingId
(
)
const
{
return
mMessageRoutingId
;
}
private
:
const
char
*
mMessageName
;
int32_t
mMessageRoutingId
;
Semantics
mMesageSemantics
;
Direction
mDirection
;
bool
mMoved
;
InterruptFrame
(
const
InterruptFrame
&
aOther
)
=
delete
;
InterruptFrame
&
operator
=
(
const
InterruptFrame
&
)
=
delete
;
}
;
class
MOZ_STACK_CLASS
MessageChannel
:
:
CxxStackFrame
{
public
:
CxxStackFrame
(
MessageChannel
&
that
Direction
direction
const
Message
*
msg
)
:
mThat
(
that
)
{
mThat
.
AssertWorkerThread
(
)
;
if
(
mThat
.
mCxxStackFrames
.
empty
(
)
)
mThat
.
EnteredCxxStack
(
)
;
if
(
!
mThat
.
mCxxStackFrames
.
append
(
InterruptFrame
(
direction
msg
)
)
)
MOZ_CRASH
(
)
;
const
InterruptFrame
&
frame
=
mThat
.
mCxxStackFrames
.
back
(
)
;
if
(
frame
.
IsInterruptIncall
(
)
)
mThat
.
EnteredCall
(
)
;
if
(
frame
.
IsOutgoingSync
(
)
)
mThat
.
EnteredSyncSend
(
)
;
mThat
.
mSawInterruptOutMsg
|
=
frame
.
IsInterruptOutcall
(
)
;
}
~
CxxStackFrame
(
)
{
mThat
.
AssertWorkerThread
(
)
;
MOZ_RELEASE_ASSERT
(
!
mThat
.
mCxxStackFrames
.
empty
(
)
)
;
const
InterruptFrame
&
frame
=
mThat
.
mCxxStackFrames
.
back
(
)
;
bool
exitingSync
=
frame
.
IsOutgoingSync
(
)
;
bool
exitingCall
=
frame
.
IsInterruptIncall
(
)
;
mThat
.
mCxxStackFrames
.
shrinkBy
(
1
)
;
bool
exitingStack
=
mThat
.
mCxxStackFrames
.
empty
(
)
;
if
(
!
mThat
.
mListener
)
return
;
if
(
exitingCall
)
mThat
.
ExitedCall
(
)
;
if
(
exitingSync
)
mThat
.
ExitedSyncSend
(
)
;
if
(
exitingStack
)
mThat
.
ExitedCxxStack
(
)
;
}
private
:
MessageChannel
&
mThat
;
CxxStackFrame
(
)
=
delete
;
CxxStackFrame
(
const
CxxStackFrame
&
)
=
delete
;
CxxStackFrame
&
operator
=
(
const
CxxStackFrame
&
)
=
delete
;
}
;
class
AutoEnterTransaction
{
public
:
explicit
AutoEnterTransaction
(
MessageChannel
*
aChan
int32_t
aMsgSeqno
int32_t
aTransactionID
int
aPriority
)
:
mChan
(
aChan
)
mActive
(
true
)
mOutgoing
(
true
)
mPriority
(
aPriority
)
mSeqno
(
aMsgSeqno
)
mTransaction
(
aTransactionID
)
mNext
(
mChan
-
>
mTransactionStack
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mChan
-
>
mTransactionStack
=
this
;
}
explicit
AutoEnterTransaction
(
MessageChannel
*
aChan
const
IPC
:
:
Message
&
aMessage
)
:
mChan
(
aChan
)
mActive
(
true
)
mOutgoing
(
false
)
mPriority
(
aMessage
.
priority
(
)
)
mSeqno
(
aMessage
.
seqno
(
)
)
mTransaction
(
aMessage
.
transaction_id
(
)
)
mNext
(
mChan
-
>
mTransactionStack
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
!
aMessage
.
is_sync
(
)
)
{
mActive
=
false
;
return
;
}
mChan
-
>
mTransactionStack
=
this
;
}
~
AutoEnterTransaction
(
)
{
mChan
-
>
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
mActive
)
{
mChan
-
>
mTransactionStack
=
mNext
;
}
}
void
Cancel
(
)
{
AutoEnterTransaction
*
cur
=
mChan
-
>
mTransactionStack
;
MOZ_RELEASE_ASSERT
(
cur
=
=
this
)
;
while
(
cur
&
&
cur
-
>
mPriority
!
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
)
{
MOZ_RELEASE_ASSERT
(
cur
-
>
mActive
)
;
cur
-
>
mActive
=
false
;
cur
=
cur
-
>
mNext
;
}
mChan
-
>
mTransactionStack
=
cur
;
MOZ_RELEASE_ASSERT
(
IsComplete
(
)
)
;
}
bool
AwaitingSyncReply
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
if
(
mOutgoing
)
{
return
true
;
}
return
mNext
?
mNext
-
>
AwaitingSyncReply
(
)
:
false
;
}
int
AwaitingSyncReplyPriority
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
if
(
mOutgoing
)
{
return
mPriority
;
}
return
mNext
?
mNext
-
>
AwaitingSyncReplyPriority
(
)
:
0
;
}
bool
DispatchingSyncMessage
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
if
(
!
mOutgoing
)
{
return
true
;
}
return
mNext
?
mNext
-
>
DispatchingSyncMessage
(
)
:
false
;
}
int
DispatchingSyncMessagePriority
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
if
(
!
mOutgoing
)
{
return
mPriority
;
}
return
mNext
?
mNext
-
>
DispatchingSyncMessagePriority
(
)
:
0
;
}
int
Priority
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
return
mPriority
;
}
int32_t
SequenceNumber
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
return
mSeqno
;
}
int32_t
TransactionID
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActive
)
;
return
mTransaction
;
}
void
ReceivedReply
(
const
IPC
:
:
Message
&
aMessage
)
{
MOZ_RELEASE_ASSERT
(
aMessage
.
seqno
(
)
=
=
mSeqno
)
;
MOZ_RELEASE_ASSERT
(
aMessage
.
transaction_id
(
)
=
=
mTransaction
)
;
MOZ_RELEASE_ASSERT
(
!
mReply
)
;
IPC_LOG
(
"
Reply
received
on
worker
thread
:
seqno
=
%
d
"
mSeqno
)
;
mReply
=
new
IPC
:
:
Message
(
aMessage
)
;
MOZ_RELEASE_ASSERT
(
IsComplete
(
)
)
;
}
void
HandleReply
(
const
IPC
:
:
Message
&
aMessage
)
{
AutoEnterTransaction
*
cur
=
mChan
-
>
mTransactionStack
;
MOZ_RELEASE_ASSERT
(
cur
=
=
this
)
;
while
(
cur
)
{
MOZ_RELEASE_ASSERT
(
cur
-
>
mActive
)
;
if
(
aMessage
.
seqno
(
)
=
=
cur
-
>
mSeqno
)
{
cur
-
>
ReceivedReply
(
aMessage
)
;
break
;
}
cur
=
cur
-
>
mNext
;
MOZ_RELEASE_ASSERT
(
cur
)
;
}
}
bool
IsComplete
(
)
{
return
!
mActive
|
|
mReply
;
}
bool
IsOutgoing
(
)
{
return
mOutgoing
;
}
bool
IsCanceled
(
)
{
return
!
mActive
;
}
bool
IsBottom
(
)
const
{
return
!
mNext
;
}
bool
IsError
(
)
{
MOZ_RELEASE_ASSERT
(
mReply
)
;
return
mReply
-
>
is_reply_error
(
)
;
}
nsAutoPtr
<
IPC
:
:
Message
>
GetReply
(
)
{
return
Move
(
mReply
)
;
}
private
:
MessageChannel
*
mChan
;
bool
mActive
;
bool
mOutgoing
;
int
mPriority
;
int32_t
mSeqno
;
int32_t
mTransaction
;
AutoEnterTransaction
*
mNext
;
nsAutoPtr
<
IPC
:
:
Message
>
mReply
;
}
;
MessageChannel
:
:
MessageChannel
(
MessageListener
*
aListener
)
:
mListener
(
aListener
)
mChannelState
(
ChannelClosed
)
mSide
(
UnknownSide
)
mLink
(
nullptr
)
mWorkerLoop
(
nullptr
)
mChannelErrorTask
(
nullptr
)
mWorkerLoopID
(
-
1
)
mTimeoutMs
(
kNoTimeout
)
mInTimeoutSecondHalf
(
false
)
mNextSeqno
(
0
)
mLastSendError
(
SyncSendError
:
:
SendSuccess
)
mDispatchingAsyncMessage
(
false
)
mDispatchingAsyncMessagePriority
(
0
)
mTransactionStack
(
nullptr
)
mTimedOutMessageSeqno
(
0
)
mTimedOutMessagePriority
(
0
)
mRemoteStackDepthGuess
(
false
)
mSawInterruptOutMsg
(
false
)
mIsWaitingForIncoming
(
false
)
mAbortOnError
(
false
)
mFlags
(
REQUIRE_DEFAULT
)
mPeerPidSet
(
false
)
mPeerPid
(
-
1
)
{
MOZ_COUNT_CTOR
(
ipc
:
:
MessageChannel
)
;
#
ifdef
OS_WIN
mTopFrame
=
nullptr
;
mIsSyncWaitingOnNonMainThread
=
false
;
#
endif
mDequeueOneTask
=
new
RefCountedTask
(
NewRunnableMethod
(
this
&
MessageChannel
:
:
OnMaybeDequeueOne
)
)
;
mOnChannelConnectedTask
=
new
RefCountedTask
(
NewRunnableMethod
(
this
&
MessageChannel
:
:
DispatchOnChannelConnected
)
)
;
#
ifdef
OS_WIN
mEvent
=
CreateEventW
(
nullptr
TRUE
FALSE
nullptr
)
;
MOZ_RELEASE_ASSERT
(
mEvent
"
CreateEvent
failed
!
Nothing
is
going
to
work
!
"
)
;
#
endif
}
MessageChannel
:
:
~
MessageChannel
(
)
{
MOZ_COUNT_DTOR
(
ipc
:
:
MessageChannel
)
;
IPC_ASSERT
(
mCxxStackFrames
.
empty
(
)
"
mismatched
CxxStackFrame
ctor
/
dtors
"
)
;
#
ifdef
OS_WIN
if
(
mEvent
)
{
BOOL
ok
=
CloseHandle
(
mEvent
)
;
mEvent
=
nullptr
;
if
(
!
ok
)
{
gfxDevCrash
(
mozilla
:
:
gfx
:
:
LogReason
:
:
MessageChannelCloseFailure
)
<
<
"
MessageChannel
failed
to
close
.
GetLastError
:
"
<
<
GetLastError
(
)
;
}
MOZ_RELEASE_ASSERT
(
ok
)
;
}
else
{
gfxDevCrash
(
mozilla
:
:
gfx
:
:
LogReason
:
:
MessageChannelCloseFailure
)
<
<
"
MessageChannel
destructor
ran
without
an
mEvent
Handle
"
;
}
#
endif
Clear
(
)
;
}
int32_t
MessageChannel
:
:
CurrentHighPriorityTransaction
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
!
mTransactionStack
)
{
return
0
;
}
MOZ_RELEASE_ASSERT
(
mTransactionStack
-
>
Priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_HIGH
)
;
return
mTransactionStack
-
>
TransactionID
(
)
;
}
bool
MessageChannel
:
:
AwaitingSyncReply
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mTransactionStack
?
mTransactionStack
-
>
AwaitingSyncReply
(
)
:
false
;
}
int
MessageChannel
:
:
AwaitingSyncReplyPriority
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mTransactionStack
?
mTransactionStack
-
>
AwaitingSyncReplyPriority
(
)
:
0
;
}
bool
MessageChannel
:
:
DispatchingSyncMessage
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mTransactionStack
?
mTransactionStack
-
>
DispatchingSyncMessage
(
)
:
false
;
}
int
MessageChannel
:
:
DispatchingSyncMessagePriority
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mTransactionStack
?
mTransactionStack
-
>
DispatchingSyncMessagePriority
(
)
:
0
;
}
static
void
PrintErrorMessage
(
Side
side
const
char
*
channelName
const
char
*
msg
)
{
const
char
*
from
=
(
side
=
=
ChildSide
)
?
"
Child
"
:
(
(
side
=
=
ParentSide
)
?
"
Parent
"
:
"
Unknown
"
)
;
printf_stderr
(
"
\
n
#
#
#
!
!
!
[
%
s
]
[
%
s
]
Error
:
%
s
\
n
\
n
"
from
channelName
msg
)
;
}
bool
MessageChannel
:
:
Connected
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
(
ChannelOpening
=
=
mChannelState
|
|
ChannelConnected
=
=
mChannelState
)
;
}
bool
MessageChannel
:
:
CanSend
(
)
const
{
if
(
!
mMonitor
)
{
return
false
;
}
MonitorAutoLock
lock
(
*
mMonitor
)
;
return
Connected
(
)
;
}
void
MessageChannel
:
:
Clear
(
)
{
if
(
gParentProcessBlocker
=
=
this
)
{
gParentProcessBlocker
=
nullptr
;
}
mDequeueOneTask
-
>
Cancel
(
)
;
mWorkerLoop
=
nullptr
;
delete
mLink
;
mLink
=
nullptr
;
mOnChannelConnectedTask
-
>
Cancel
(
)
;
if
(
mChannelErrorTask
)
{
mChannelErrorTask
-
>
Cancel
(
)
;
mChannelErrorTask
=
nullptr
;
}
mPending
.
clear
(
)
;
mOutOfTurnReplies
.
clear
(
)
;
while
(
!
mDeferred
.
empty
(
)
)
{
mDeferred
.
pop
(
)
;
}
}
bool
MessageChannel
:
:
Open
(
Transport
*
aTransport
MessageLoop
*
aIOLoop
Side
aSide
)
{
NS_PRECONDITION
(
!
mLink
"
Open
(
)
called
>
once
"
)
;
mMonitor
=
new
RefCountedMonitor
(
)
;
mWorkerLoop
=
MessageLoop
:
:
current
(
)
;
mWorkerLoopID
=
mWorkerLoop
-
>
id
(
)
;
ProcessLink
*
link
=
new
ProcessLink
(
this
)
;
link
-
>
Open
(
aTransport
aIOLoop
aSide
)
;
mLink
=
link
;
return
true
;
}
bool
MessageChannel
:
:
Open
(
MessageChannel
*
aTargetChan
MessageLoop
*
aTargetLoop
Side
aSide
)
{
NS_PRECONDITION
(
aTargetChan
"
Need
a
target
channel
"
)
;
NS_PRECONDITION
(
ChannelClosed
=
=
mChannelState
"
Not
currently
closed
"
)
;
CommonThreadOpenInit
(
aTargetChan
aSide
)
;
Side
oppSide
=
UnknownSide
;
switch
(
aSide
)
{
case
ChildSide
:
oppSide
=
ParentSide
;
break
;
case
ParentSide
:
oppSide
=
ChildSide
;
break
;
case
UnknownSide
:
break
;
}
mMonitor
=
new
RefCountedMonitor
(
)
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
mChannelState
=
ChannelOpening
;
aTargetLoop
-
>
PostTask
(
NewRunnableMethod
(
aTargetChan
&
MessageChannel
:
:
OnOpenAsSlave
this
oppSide
)
)
;
while
(
ChannelOpening
=
=
mChannelState
)
mMonitor
-
>
Wait
(
)
;
MOZ_RELEASE_ASSERT
(
ChannelConnected
=
=
mChannelState
"
not
connected
when
awoken
"
)
;
return
(
ChannelConnected
=
=
mChannelState
)
;
}
void
MessageChannel
:
:
OnOpenAsSlave
(
MessageChannel
*
aTargetChan
Side
aSide
)
{
NS_PRECONDITION
(
ChannelClosed
=
=
mChannelState
"
Not
currently
closed
"
)
;
NS_PRECONDITION
(
ChannelOpening
=
=
aTargetChan
-
>
mChannelState
"
Target
channel
not
in
the
process
of
opening
"
)
;
CommonThreadOpenInit
(
aTargetChan
aSide
)
;
mMonitor
=
aTargetChan
-
>
mMonitor
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
MOZ_RELEASE_ASSERT
(
ChannelOpening
=
=
aTargetChan
-
>
mChannelState
"
Target
channel
not
in
the
process
of
opening
"
)
;
mChannelState
=
ChannelConnected
;
aTargetChan
-
>
mChannelState
=
ChannelConnected
;
aTargetChan
-
>
mMonitor
-
>
Notify
(
)
;
}
void
MessageChannel
:
:
CommonThreadOpenInit
(
MessageChannel
*
aTargetChan
Side
aSide
)
{
mWorkerLoop
=
MessageLoop
:
:
current
(
)
;
mWorkerLoopID
=
mWorkerLoop
-
>
id
(
)
;
mLink
=
new
ThreadLink
(
this
aTargetChan
)
;
mSide
=
aSide
;
}
bool
MessageChannel
:
:
Echo
(
Message
*
aMsg
)
{
nsAutoPtr
<
Message
>
msg
(
aMsg
)
;
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
if
(
MSG_ROUTING_NONE
=
=
msg
-
>
routing_id
(
)
)
{
ReportMessageRouteError
(
"
MessageChannel
:
:
Echo
"
)
;
return
false
;
}
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
"
msg
)
;
return
false
;
}
mLink
-
>
EchoMessage
(
msg
.
forget
(
)
)
;
return
true
;
}
bool
MessageChannel
:
:
Send
(
Message
*
aMsg
)
{
if
(
aMsg
-
>
capacity
(
)
>
=
kMinTelemetryMessageSize
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IPC_MESSAGE_SIZE
nsDependentCString
(
aMsg
-
>
name
(
)
)
aMsg
-
>
capacity
(
)
)
;
}
CxxStackFrame
frame
(
*
this
OUT_MESSAGE
aMsg
)
;
nsAutoPtr
<
Message
>
msg
(
aMsg
)
;
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
if
(
MSG_ROUTING_NONE
=
=
msg
-
>
routing_id
(
)
)
{
ReportMessageRouteError
(
"
MessageChannel
:
:
Send
"
)
;
return
false
;
}
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
"
msg
)
;
return
false
;
}
mLink
-
>
SendMessage
(
msg
.
forget
(
)
)
;
return
true
;
}
class
CancelMessage
:
public
IPC
:
:
Message
{
public
:
explicit
CancelMessage
(
int
transaction
)
:
IPC
:
:
Message
(
MSG_ROUTING_NONE
CANCEL_MESSAGE_TYPE
PRIORITY_NORMAL
)
{
set_transaction_id
(
transaction
)
;
}
static
bool
Read
(
const
Message
*
msg
)
{
return
true
;
}
void
Log
(
const
std
:
:
string
&
aPrefix
FILE
*
aOutf
)
const
{
fputs
(
"
(
special
Cancel
'
message
)
"
aOutf
)
;
}
}
;
bool
MessageChannel
:
:
MaybeInterceptSpecialIOMessage
(
const
Message
&
aMsg
)
{
AssertLinkThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
MSG_ROUTING_NONE
=
=
aMsg
.
routing_id
(
)
)
{
if
(
GOODBYE_MESSAGE_TYPE
=
=
aMsg
.
type
(
)
)
{
mChannelState
=
ChannelClosing
;
if
(
LoggingEnabled
(
)
)
{
printf
(
"
NOTE
:
%
s
process
received
Goodbye
'
closing
down
\
n
"
(
mSide
=
=
ChildSide
)
?
"
child
"
:
"
parent
"
)
;
}
return
true
;
}
else
if
(
CANCEL_MESSAGE_TYPE
=
=
aMsg
.
type
(
)
)
{
IPC_LOG
(
"
Cancel
from
message
"
)
;
CancelTransaction
(
aMsg
.
transaction_id
(
)
)
;
NotifyWorkerThread
(
)
;
return
true
;
}
}
return
false
;
}
bool
MessageChannel
:
:
ShouldDeferMessage
(
const
Message
&
aMsg
)
{
if
(
aMsg
.
priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
)
return
false
;
if
(
!
aMsg
.
is_sync
(
)
)
{
MOZ_RELEASE_ASSERT
(
aMsg
.
priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
)
;
return
true
;
}
int
msgPrio
=
aMsg
.
priority
(
)
;
int
waitingPrio
=
AwaitingSyncReplyPriority
(
)
;
if
(
msgPrio
<
waitingPrio
)
return
true
;
if
(
msgPrio
>
waitingPrio
)
return
false
;
return
mSide
=
=
ParentSide
&
&
aMsg
.
transaction_id
(
)
!
=
CurrentHighPriorityTransaction
(
)
;
}
class
MatchingKinds
{
typedef
IPC
:
:
Message
Message
;
Message
:
:
msgid_t
mType
;
int32_t
mRoutingId
;
public
:
MatchingKinds
(
Message
:
:
msgid_t
aType
int32_t
aRoutingId
)
:
mType
(
aType
)
mRoutingId
(
aRoutingId
)
{
}
bool
operator
(
)
(
const
Message
&
msg
)
{
return
msg
.
type
(
)
=
=
mType
&
&
msg
.
routing_id
(
)
=
=
mRoutingId
;
}
}
;
void
MessageChannel
:
:
OnMessageReceivedFromLink
(
Message
&
&
aMsg
)
{
AssertLinkThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
MaybeInterceptSpecialIOMessage
(
aMsg
)
)
return
;
if
(
aMsg
.
is_sync
(
)
&
&
aMsg
.
is_reply
(
)
)
{
IPC_LOG
(
"
Received
reply
seqno
=
%
d
xid
=
%
d
"
aMsg
.
seqno
(
)
aMsg
.
transaction_id
(
)
)
;
if
(
aMsg
.
seqno
(
)
=
=
mTimedOutMessageSeqno
)
{
IPC_LOG
(
"
Received
reply
to
timedout
message
;
igoring
;
xid
=
%
d
"
mTimedOutMessageSeqno
)
;
EndTimeout
(
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
AwaitingSyncReply
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mTimedOutMessageSeqno
)
;
mTransactionStack
-
>
HandleReply
(
aMsg
)
;
NotifyWorkerThread
(
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
aMsg
.
compress_type
(
)
=
=
IPC
:
:
Message
:
:
COMPRESSION_NONE
|
|
aMsg
.
priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
)
;
bool
compress
=
false
;
if
(
aMsg
.
compress_type
(
)
=
=
IPC
:
:
Message
:
:
COMPRESSION_ENABLED
)
{
compress
=
(
!
mPending
.
empty
(
)
&
&
mPending
.
back
(
)
.
type
(
)
=
=
aMsg
.
type
(
)
&
&
mPending
.
back
(
)
.
routing_id
(
)
=
=
aMsg
.
routing_id
(
)
)
;
if
(
compress
)
{
MOZ_RELEASE_ASSERT
(
mPending
.
back
(
)
.
compress_type
(
)
=
=
IPC
:
:
Message
:
:
COMPRESSION_ENABLED
)
;
mPending
.
pop_back
(
)
;
}
}
else
if
(
aMsg
.
compress_type
(
)
=
=
IPC
:
:
Message
:
:
COMPRESSION_ALL
)
{
auto
it
=
std
:
:
find_if
(
mPending
.
rbegin
(
)
mPending
.
rend
(
)
MatchingKinds
(
aMsg
.
type
(
)
aMsg
.
routing_id
(
)
)
)
;
if
(
it
!
=
mPending
.
rend
(
)
)
{
compress
=
true
;
MOZ_RELEASE_ASSERT
(
(
*
it
)
.
compress_type
(
)
=
=
IPC
:
:
Message
:
:
COMPRESSION_ALL
)
;
mPending
.
erase
(
(
+
+
it
)
.
base
(
)
)
;
}
}
bool
wakeUpSyncSend
=
AwaitingSyncReply
(
)
&
&
!
ShouldDeferMessage
(
aMsg
)
;
bool
shouldWakeUp
=
AwaitingInterruptReply
(
)
|
|
wakeUpSyncSend
|
|
AwaitingIncomingMessage
(
)
;
bool
shouldPostTask
=
!
shouldWakeUp
|
|
wakeUpSyncSend
;
IPC_LOG
(
"
Receive
on
link
thread
;
seqno
=
%
d
xid
=
%
d
shouldWakeUp
=
%
d
"
aMsg
.
seqno
(
)
aMsg
.
transaction_id
(
)
shouldWakeUp
)
;
mPending
.
push_back
(
Move
(
aMsg
)
)
;
if
(
shouldWakeUp
)
{
NotifyWorkerThread
(
)
;
}
if
(
shouldPostTask
)
{
if
(
!
compress
)
{
RefPtr
<
DequeueTask
>
task
=
new
DequeueTask
(
mDequeueOneTask
)
;
mWorkerLoop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
}
}
void
MessageChannel
:
:
PeekMessages
(
mozilla
:
:
function
<
bool
(
const
Message
&
aMsg
)
>
aInvoke
)
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
for
(
MessageQueue
:
:
iterator
it
=
mPending
.
begin
(
)
;
it
!
=
mPending
.
end
(
)
;
it
+
+
)
{
Message
&
msg
=
*
it
;
if
(
!
aInvoke
(
msg
)
)
{
break
;
}
}
}
void
MessageChannel
:
:
ProcessPendingRequests
(
AutoEnterTransaction
&
aTransaction
)
{
IPC_LOG
(
"
ProcessPendingRequests
for
seqno
=
%
d
xid
=
%
d
"
aTransaction
.
SequenceNumber
(
)
aTransaction
.
TransactionID
(
)
)
;
for
(
;
;
)
{
if
(
aTransaction
.
IsCanceled
(
)
)
{
return
;
}
mozilla
:
:
Vector
<
Message
>
toProcess
;
for
(
MessageQueue
:
:
iterator
it
=
mPending
.
begin
(
)
;
it
!
=
mPending
.
end
(
)
;
)
{
Message
&
msg
=
*
it
;
MOZ_RELEASE_ASSERT
(
!
aTransaction
.
IsCanceled
(
)
"
Calling
ShouldDeferMessage
when
cancelled
"
)
;
bool
defer
=
ShouldDeferMessage
(
msg
)
;
if
(
msg
.
is_sync
(
)
|
|
msg
.
priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
)
{
IPC_LOG
(
"
ShouldDeferMessage
(
seqno
=
%
d
)
=
%
d
"
msg
.
seqno
(
)
defer
)
;
}
if
(
!
defer
)
{
if
(
!
toProcess
.
append
(
Move
(
msg
)
)
)
MOZ_CRASH
(
)
;
it
=
mPending
.
erase
(
it
)
;
continue
;
}
it
+
+
;
}
if
(
toProcess
.
empty
(
)
)
{
break
;
}
for
(
auto
it
=
toProcess
.
begin
(
)
;
it
!
=
toProcess
.
end
(
)
;
it
+
+
)
{
ProcessPendingRequest
(
*
it
)
;
}
}
}
bool
MessageChannel
:
:
Send
(
Message
*
aMsg
Message
*
aReply
)
{
if
(
aMsg
-
>
capacity
(
)
>
=
kMinTelemetryMessageSize
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IPC_MESSAGE_SIZE
nsDependentCString
(
aMsg
-
>
name
(
)
)
aMsg
-
>
capacity
(
)
)
;
}
nsAutoPtr
<
Message
>
msg
(
aMsg
)
;
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
#
ifdef
OS_WIN
SyncStackFrame
frame
(
this
false
)
;
NeuteredWindowRegion
neuteredRgn
(
mFlags
&
REQUIRE_DEFERRED_MESSAGE_PROTECTION
)
;
#
endif
CxxStackFrame
f
(
*
this
OUT_MESSAGE
msg
)
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
mTimedOutMessageSeqno
)
{
IPC_LOG
(
"
Send
(
)
failed
due
to
previous
timeout
"
)
;
mLastSendError
=
SyncSendError
:
:
PreviousTimeout
;
return
false
;
}
if
(
DispatchingSyncMessagePriority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
&
&
msg
-
>
priority
(
)
>
IPC
:
:
Message
:
:
PRIORITY_NORMAL
)
{
IPC_LOG
(
"
Prio
forbids
send
"
)
;
mLastSendError
=
SyncSendError
:
:
SendingCPOWWhileDispatchingSync
;
return
false
;
}
if
(
DispatchingSyncMessagePriority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
|
|
DispatchingAsyncMessagePriority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
)
{
MOZ_RELEASE_ASSERT
(
msg
-
>
priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_HIGH
)
;
IPC_LOG
(
"
Sending
while
dispatching
urgent
message
"
)
;
mLastSendError
=
SyncSendError
:
:
SendingCPOWWhileDispatchingUrgent
;
return
false
;
}
if
(
msg
-
>
priority
(
)
<
DispatchingSyncMessagePriority
(
)
|
|
msg
-
>
priority
(
)
<
AwaitingSyncReplyPriority
(
)
)
{
MOZ_RELEASE_ASSERT
(
DispatchingSyncMessage
(
)
|
|
DispatchingAsyncMessage
(
)
)
;
IPC_LOG
(
"
Cancel
from
Send
"
)
;
CancelMessage
*
cancel
=
new
CancelMessage
(
CurrentHighPriorityTransaction
(
)
)
;
CancelTransaction
(
CurrentHighPriorityTransaction
(
)
)
;
mLink
-
>
SendMessage
(
cancel
)
;
}
IPC_ASSERT
(
msg
-
>
is_sync
(
)
"
can
only
Send
(
)
sync
messages
here
"
)
;
IPC_ASSERT
(
msg
-
>
priority
(
)
>
=
DispatchingSyncMessagePriority
(
)
"
can
'
t
send
sync
message
of
a
lesser
priority
than
what
'
s
being
dispatched
"
)
;
IPC_ASSERT
(
AwaitingSyncReplyPriority
(
)
<
=
msg
-
>
priority
(
)
"
nested
sync
message
sends
must
be
of
increasing
priority
"
)
;
IPC_ASSERT
(
DispatchingSyncMessagePriority
(
)
!
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
"
not
allowed
to
send
messages
while
dispatching
urgent
messages
"
)
;
IPC_ASSERT
(
DispatchingAsyncMessagePriority
(
)
!
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
"
not
allowed
to
send
messages
while
dispatching
urgent
messages
"
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
SendAndWait
"
msg
)
;
mLastSendError
=
SyncSendError
:
:
NotConnectedBeforeSend
;
return
false
;
}
msg
-
>
set_seqno
(
NextSeqno
(
)
)
;
int32_t
seqno
=
msg
-
>
seqno
(
)
;
int
prio
=
msg
-
>
priority
(
)
;
msgid_t
replyType
=
msg
-
>
type
(
)
+
1
;
AutoEnterTransaction
*
stackTop
=
mTransactionStack
;
bool
nest
=
stackTop
&
&
stackTop
-
>
Priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_HIGH
;
int32_t
transaction
=
nest
?
stackTop
-
>
TransactionID
(
)
:
seqno
;
msg
-
>
set_transaction_id
(
transaction
)
;
bool
handleWindowsMessages
=
mListener
-
>
HandleWindowsMessages
(
*
aMsg
)
;
AutoEnterTransaction
transact
(
this
seqno
transaction
prio
)
;
IPC_LOG
(
"
Send
seqno
=
%
d
xid
=
%
d
"
seqno
transaction
)
;
const
char
*
msgName
=
msg
-
>
name
(
)
;
mLink
-
>
SendMessage
(
msg
.
forget
(
)
)
;
while
(
true
)
{
MOZ_RELEASE_ASSERT
(
!
transact
.
IsCanceled
(
)
)
;
ProcessPendingRequests
(
transact
)
;
if
(
transact
.
IsComplete
(
)
)
{
break
;
}
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
Send
"
)
;
mLastSendError
=
SyncSendError
:
:
DisconnectedDuringSend
;
return
false
;
}
MOZ_RELEASE_ASSERT
(
!
mTimedOutMessageSeqno
)
;
MOZ_RELEASE_ASSERT
(
!
transact
.
IsComplete
(
)
)
;
MOZ_RELEASE_ASSERT
(
mTransactionStack
=
=
&
transact
)
;
bool
maybeTimedOut
=
!
WaitForSyncNotify
(
handleWindowsMessages
)
;
if
(
mListener
-
>
NeedArtificialSleep
(
)
)
{
MonitorAutoUnlock
unlock
(
*
mMonitor
)
;
mListener
-
>
ArtificialSleep
(
)
;
}
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
SendAndWait
"
)
;
mLastSendError
=
SyncSendError
:
:
DisconnectedDuringSend
;
return
false
;
}
if
(
transact
.
IsCanceled
(
)
)
{
break
;
}
MOZ_RELEASE_ASSERT
(
mTransactionStack
=
=
&
transact
)
;
bool
canTimeOut
=
transact
.
IsBottom
(
)
;
if
(
maybeTimedOut
&
&
canTimeOut
&
&
!
ShouldContinueFromTimeout
(
)
)
{
if
(
transact
.
IsComplete
(
)
)
{
break
;
}
IPC_LOG
(
"
Timing
out
Send
:
xid
=
%
d
"
transaction
)
;
mTimedOutMessageSeqno
=
seqno
;
mTimedOutMessagePriority
=
prio
;
mLastSendError
=
SyncSendError
:
:
TimedOut
;
return
false
;
}
if
(
transact
.
IsCanceled
(
)
)
{
break
;
}
}
if
(
transact
.
IsCanceled
(
)
)
{
IPC_LOG
(
"
Other
side
canceled
seqno
=
%
d
xid
=
%
d
"
seqno
transaction
)
;
mLastSendError
=
SyncSendError
:
:
CancelledAfterSend
;
return
false
;
}
if
(
transact
.
IsError
(
)
)
{
IPC_LOG
(
"
Error
:
seqno
=
%
d
xid
=
%
d
"
seqno
transaction
)
;
mLastSendError
=
SyncSendError
:
:
ReplyError
;
return
false
;
}
IPC_LOG
(
"
Got
reply
:
seqno
=
%
d
xid
=
%
d
"
seqno
transaction
)
;
nsAutoPtr
<
Message
>
reply
=
transact
.
GetReply
(
)
;
MOZ_RELEASE_ASSERT
(
reply
)
;
MOZ_RELEASE_ASSERT
(
reply
-
>
is_reply
(
)
"
expected
reply
"
)
;
MOZ_RELEASE_ASSERT
(
!
reply
-
>
is_reply_error
(
)
)
;
MOZ_RELEASE_ASSERT
(
reply
-
>
seqno
(
)
=
=
seqno
)
;
MOZ_RELEASE_ASSERT
(
reply
-
>
type
(
)
=
=
replyType
"
wrong
reply
type
"
)
;
MOZ_RELEASE_ASSERT
(
reply
-
>
is_sync
(
)
)
;
*
aReply
=
Move
(
*
reply
)
;
if
(
aReply
-
>
capacity
(
)
>
=
kMinTelemetryMessageSize
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IPC_REPLY_SIZE
nsDependentCString
(
msgName
)
aReply
-
>
capacity
(
)
)
;
}
return
true
;
}
bool
MessageChannel
:
:
Call
(
Message
*
aMsg
Message
*
aReply
)
{
nsAutoPtr
<
Message
>
msg
(
aMsg
)
;
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
#
ifdef
OS_WIN
SyncStackFrame
frame
(
this
true
)
;
#
endif
CxxStackFrame
cxxframe
(
*
this
OUT_MESSAGE
msg
)
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
Call
"
msg
)
;
return
false
;
}
IPC_ASSERT
(
!
AwaitingSyncReply
(
)
"
cannot
issue
Interrupt
call
while
blocked
on
sync
request
"
)
;
IPC_ASSERT
(
!
DispatchingSyncMessage
(
)
"
violation
of
sync
handler
invariant
"
)
;
IPC_ASSERT
(
msg
-
>
is_interrupt
(
)
"
can
only
Call
(
)
Interrupt
messages
here
"
)
;
msg
-
>
set_seqno
(
NextSeqno
(
)
)
;
msg
-
>
set_interrupt_remote_stack_depth_guess
(
mRemoteStackDepthGuess
)
;
msg
-
>
set_interrupt_local_stack_depth
(
1
+
InterruptStackDepth
(
)
)
;
mInterruptStack
.
push
(
MessageInfo
(
*
msg
)
)
;
mLink
-
>
SendMessage
(
msg
.
forget
(
)
)
;
while
(
true
)
{
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
Call
"
)
;
return
false
;
}
#
ifdef
OS_WIN
{
NeuteredWindowRegion
neuteredRgn
(
mFlags
&
REQUIRE_DEFERRED_MESSAGE_PROTECTION
)
;
neuteredRgn
.
PumpOnce
(
)
;
}
#
endif
MaybeUndeferIncall
(
)
;
while
(
!
InterruptEventOccurred
(
)
)
{
bool
maybeTimedOut
=
!
WaitForInterruptNotify
(
)
;
if
(
InterruptEventOccurred
(
)
|
|
(
!
maybeTimedOut
&
&
(
!
mDeferred
.
empty
(
)
|
|
!
mOutOfTurnReplies
.
empty
(
)
)
)
)
{
break
;
}
if
(
maybeTimedOut
&
&
!
ShouldContinueFromTimeout
(
)
)
return
false
;
}
Message
recvd
;
MessageMap
:
:
iterator
it
;
if
(
(
it
=
mOutOfTurnReplies
.
find
(
mInterruptStack
.
top
(
)
.
seqno
(
)
)
)
!
=
mOutOfTurnReplies
.
end
(
)
)
{
recvd
=
Move
(
it
-
>
second
)
;
mOutOfTurnReplies
.
erase
(
it
)
;
}
else
if
(
!
mPending
.
empty
(
)
)
{
recvd
=
Move
(
mPending
.
front
(
)
)
;
mPending
.
pop_front
(
)
;
}
else
{
continue
;
}
if
(
!
recvd
.
is_interrupt
(
)
)
{
DispatchMessage
(
recvd
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
DispatchMessage
"
)
;
return
false
;
}
continue
;
}
if
(
recvd
.
is_reply
(
)
)
{
IPC_ASSERT
(
!
mInterruptStack
.
empty
(
)
"
invalid
Interrupt
stack
"
)
;
{
const
MessageInfo
&
outcall
=
mInterruptStack
.
top
(
)
;
if
(
(
mSide
=
=
ChildSide
&
&
recvd
.
seqno
(
)
>
outcall
.
seqno
(
)
)
|
|
(
mSide
!
=
ChildSide
&
&
recvd
.
seqno
(
)
<
outcall
.
seqno
(
)
)
)
{
mOutOfTurnReplies
[
recvd
.
seqno
(
)
]
=
Move
(
recvd
)
;
continue
;
}
IPC_ASSERT
(
recvd
.
is_reply_error
(
)
|
|
(
recvd
.
type
(
)
=
=
(
outcall
.
type
(
)
+
1
)
&
&
recvd
.
seqno
(
)
=
=
outcall
.
seqno
(
)
)
"
somebody
'
s
misbehavin
'
"
true
)
;
}
mInterruptStack
.
pop
(
)
;
bool
is_reply_error
=
recvd
.
is_reply_error
(
)
;
if
(
!
is_reply_error
)
{
*
aReply
=
Move
(
recvd
)
;
}
IPC_ASSERT
(
!
mInterruptStack
.
empty
(
)
|
|
mOutOfTurnReplies
.
empty
(
)
"
still
have
pending
replies
with
no
pending
out
-
calls
"
true
)
;
return
!
is_reply_error
;
}
size_t
stackDepth
=
InterruptStackDepth
(
)
;
{
MonitorAutoUnlock
unlock
(
*
mMonitor
)
;
CxxStackFrame
frame
(
*
this
IN_MESSAGE
&
recvd
)
;
DispatchInterruptMessage
(
recvd
stackDepth
)
;
}
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
DispatchInterruptMessage
"
)
;
return
false
;
}
}
return
true
;
}
bool
MessageChannel
:
:
WaitForIncomingMessage
(
)
{
#
ifdef
OS_WIN
SyncStackFrame
frame
(
this
true
)
;
NeuteredWindowRegion
neuteredRgn
(
mFlags
&
REQUIRE_DEFERRED_MESSAGE_PROTECTION
)
;
#
endif
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
AutoEnterWaitForIncoming
waitingForIncoming
(
*
this
)
;
if
(
mChannelState
!
=
ChannelConnected
)
{
return
false
;
}
if
(
!
HasPendingEvents
(
)
)
{
return
WaitForInterruptNotify
(
)
;
}
}
return
OnMaybeDequeueOne
(
)
;
}
bool
MessageChannel
:
:
HasPendingEvents
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
Connected
(
)
&
&
!
mPending
.
empty
(
)
;
}
bool
MessageChannel
:
:
InterruptEventOccurred
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
IPC_ASSERT
(
InterruptStackDepth
(
)
>
0
"
not
in
wait
loop
"
)
;
return
(
!
Connected
(
)
|
|
!
mPending
.
empty
(
)
|
|
(
!
mOutOfTurnReplies
.
empty
(
)
&
&
mOutOfTurnReplies
.
find
(
mInterruptStack
.
top
(
)
.
seqno
(
)
)
!
=
mOutOfTurnReplies
.
end
(
)
)
)
;
}
bool
MessageChannel
:
:
ProcessPendingRequest
(
const
Message
&
aUrgent
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
IPC_LOG
(
"
Process
pending
:
seqno
=
%
d
xid
=
%
d
"
aUrgent
.
seqno
(
)
aUrgent
.
transaction_id
(
)
)
;
DispatchMessage
(
aUrgent
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
MessageChannel
:
:
ProcessPendingRequest
"
)
;
return
false
;
}
return
true
;
}
bool
MessageChannel
:
:
DequeueOne
(
Message
*
recvd
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
!
Connected
(
)
)
{
ReportConnectionError
(
"
OnMaybeDequeueOne
"
)
;
return
false
;
}
if
(
!
mDeferred
.
empty
(
)
)
MaybeUndeferIncall
(
)
;
if
(
mTimedOutMessageSeqno
)
{
for
(
MessageQueue
:
:
iterator
it
=
mPending
.
begin
(
)
;
it
!
=
mPending
.
end
(
)
;
it
+
+
)
{
Message
&
msg
=
*
it
;
if
(
msg
.
priority
(
)
>
mTimedOutMessagePriority
|
|
(
msg
.
priority
(
)
=
=
mTimedOutMessagePriority
&
&
msg
.
transaction_id
(
)
=
=
mTimedOutMessageSeqno
)
)
{
*
recvd
=
Move
(
msg
)
;
mPending
.
erase
(
it
)
;
return
true
;
}
}
return
false
;
}
if
(
mPending
.
empty
(
)
)
return
false
;
*
recvd
=
Move
(
mPending
.
front
(
)
)
;
mPending
.
pop_front
(
)
;
return
true
;
}
bool
MessageChannel
:
:
OnMaybeDequeueOne
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
Message
recvd
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
!
DequeueOne
(
&
recvd
)
)
return
false
;
if
(
IsOnCxxStack
(
)
&
&
recvd
.
is_interrupt
(
)
&
&
recvd
.
is_reply
(
)
)
{
mOutOfTurnReplies
[
recvd
.
seqno
(
)
]
=
Move
(
recvd
)
;
return
false
;
}
DispatchMessage
(
recvd
)
;
return
true
;
}
void
MessageChannel
:
:
DispatchMessage
(
const
Message
&
aMsg
)
{
Maybe
<
AutoNoJSAPI
>
nojsapi
;
if
(
ScriptSettingsInitialized
(
)
&
&
NS_IsMainThread
(
)
)
nojsapi
.
emplace
(
)
;
nsAutoPtr
<
Message
>
reply
;
IPC_LOG
(
"
DispatchMessage
:
seqno
=
%
d
xid
=
%
d
"
aMsg
.
seqno
(
)
aMsg
.
transaction_id
(
)
)
;
{
AutoEnterTransaction
transaction
(
this
aMsg
)
;
int
id
=
aMsg
.
transaction_id
(
)
;
MOZ_RELEASE_ASSERT
(
!
aMsg
.
is_sync
(
)
|
|
id
=
=
transaction
.
TransactionID
(
)
)
;
{
MonitorAutoUnlock
unlock
(
*
mMonitor
)
;
CxxStackFrame
frame
(
*
this
IN_MESSAGE
&
aMsg
)
;
mListener
-
>
ArtificialSleep
(
)
;
if
(
aMsg
.
is_sync
(
)
)
DispatchSyncMessage
(
aMsg
*
getter_Transfers
(
reply
)
)
;
else
if
(
aMsg
.
is_interrupt
(
)
)
DispatchInterruptMessage
(
aMsg
0
)
;
else
DispatchAsyncMessage
(
aMsg
)
;
mListener
-
>
ArtificialSleep
(
)
;
}
if
(
reply
&
&
transaction
.
IsCanceled
(
)
)
{
IPC_LOG
(
"
Nulling
out
reply
due
to
cancellation
seqno
=
%
d
xid
=
%
d
"
aMsg
.
seqno
(
)
id
)
;
reply
=
nullptr
;
}
}
if
(
reply
&
&
ChannelConnected
=
=
mChannelState
)
{
IPC_LOG
(
"
Sending
reply
seqno
=
%
d
xid
=
%
d
"
aMsg
.
seqno
(
)
aMsg
.
transaction_id
(
)
)
;
mLink
-
>
SendMessage
(
reply
.
forget
(
)
)
;
}
}
void
MessageChannel
:
:
DispatchSyncMessage
(
const
Message
&
aMsg
Message
*
&
aReply
)
{
AssertWorkerThread
(
)
;
int
prio
=
aMsg
.
priority
(
)
;
MOZ_RELEASE_ASSERT
(
prio
=
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
|
|
NS_IsMainThread
(
)
)
;
MessageChannel
*
dummy
;
MessageChannel
*
&
blockingVar
=
mSide
=
=
ChildSide
&
&
NS_IsMainThread
(
)
?
gParentProcessBlocker
:
dummy
;
Result
rv
;
{
AutoSetValue
<
MessageChannel
*
>
blocked
(
blockingVar
this
)
;
rv
=
mListener
-
>
OnMessageReceived
(
aMsg
aReply
)
;
}
if
(
!
MaybeHandleError
(
rv
aMsg
"
DispatchSyncMessage
"
)
)
{
aReply
=
new
Message
(
)
;
aReply
-
>
set_sync
(
)
;
aReply
-
>
set_priority
(
aMsg
.
priority
(
)
)
;
aReply
-
>
set_reply
(
)
;
aReply
-
>
set_reply_error
(
)
;
}
aReply
-
>
set_seqno
(
aMsg
.
seqno
(
)
)
;
aReply
-
>
set_transaction_id
(
aMsg
.
transaction_id
(
)
)
;
}
void
MessageChannel
:
:
DispatchAsyncMessage
(
const
Message
&
aMsg
)
{
AssertWorkerThread
(
)
;
MOZ_RELEASE_ASSERT
(
!
aMsg
.
is_interrupt
(
)
&
&
!
aMsg
.
is_sync
(
)
)
;
if
(
aMsg
.
routing_id
(
)
=
=
MSG_ROUTING_NONE
)
{
NS_RUNTIMEABORT
(
"
unhandled
special
message
!
"
)
;
}
Result
rv
;
{
int
prio
=
aMsg
.
priority
(
)
;
AutoSetValue
<
bool
>
async
(
mDispatchingAsyncMessage
true
)
;
AutoSetValue
<
int
>
prioSet
(
mDispatchingAsyncMessagePriority
prio
)
;
rv
=
mListener
-
>
OnMessageReceived
(
aMsg
)
;
}
MaybeHandleError
(
rv
aMsg
"
DispatchAsyncMessage
"
)
;
}
void
MessageChannel
:
:
DispatchInterruptMessage
(
const
Message
&
aMsg
size_t
stackDepth
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
IPC_ASSERT
(
aMsg
.
is_interrupt
(
)
&
&
!
aMsg
.
is_reply
(
)
"
wrong
message
type
"
)
;
if
(
aMsg
.
interrupt_remote_stack_depth_guess
(
)
!
=
RemoteViewOfStackDepth
(
stackDepth
)
)
{
bool
defer
;
const
char
*
winner
;
const
MessageInfo
parentMsgInfo
=
(
mSide
=
=
ChildSide
)
?
MessageInfo
(
aMsg
)
:
mInterruptStack
.
top
(
)
;
const
MessageInfo
childMsgInfo
=
(
mSide
=
=
ChildSide
)
?
mInterruptStack
.
top
(
)
:
MessageInfo
(
aMsg
)
;
switch
(
mListener
-
>
MediateInterruptRace
(
parentMsgInfo
childMsgInfo
)
)
{
case
RIPChildWins
:
winner
=
"
child
"
;
defer
=
(
mSide
=
=
ChildSide
)
;
break
;
case
RIPParentWins
:
winner
=
"
parent
"
;
defer
=
(
mSide
!
=
ChildSide
)
;
break
;
case
RIPError
:
NS_RUNTIMEABORT
(
"
NYI
:
'
Error
'
Interrupt
race
policy
"
)
;
return
;
default
:
NS_RUNTIMEABORT
(
"
not
reached
"
)
;
return
;
}
if
(
LoggingEnabled
(
)
)
{
printf_stderr
(
"
(
%
s
:
%
s
won
so
we
'
re
%
sdeferring
)
\
n
"
(
mSide
=
=
ChildSide
)
?
"
child
"
:
"
parent
"
winner
defer
?
"
"
:
"
not
"
)
;
}
if
(
defer
)
{
+
+
mRemoteStackDepthGuess
;
mDeferred
.
push
(
aMsg
)
;
return
;
}
}
#
ifdef
OS_WIN
SyncStackFrame
frame
(
this
true
)
;
#
endif
nsAutoPtr
<
Message
>
reply
;
+
+
mRemoteStackDepthGuess
;
Result
rv
=
mListener
-
>
OnCallReceived
(
aMsg
*
getter_Transfers
(
reply
)
)
;
-
-
mRemoteStackDepthGuess
;
if
(
!
MaybeHandleError
(
rv
aMsg
"
DispatchInterruptMessage
"
)
)
{
reply
=
new
Message
(
)
;
reply
-
>
set_interrupt
(
)
;
reply
-
>
set_reply
(
)
;
reply
-
>
set_reply_error
(
)
;
}
reply
-
>
set_seqno
(
aMsg
.
seqno
(
)
)
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
ChannelConnected
=
=
mChannelState
)
{
mLink
-
>
SendMessage
(
reply
.
forget
(
)
)
;
}
}
void
MessageChannel
:
:
MaybeUndeferIncall
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
mDeferred
.
empty
(
)
)
return
;
size_t
stackDepth
=
InterruptStackDepth
(
)
;
IPC_ASSERT
(
mDeferred
.
top
(
)
.
interrupt_remote_stack_depth_guess
(
)
<
=
stackDepth
"
fatal
logic
error
"
)
;
Message
call
(
Move
(
mDeferred
.
top
(
)
)
)
;
mDeferred
.
pop
(
)
;
IPC_ASSERT
(
0
<
mRemoteStackDepthGuess
"
fatal
logic
error
"
)
;
-
-
mRemoteStackDepthGuess
;
MOZ_RELEASE_ASSERT
(
call
.
priority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
)
;
mPending
.
push_back
(
Move
(
call
)
)
;
}
void
MessageChannel
:
:
FlushPendingInterruptQueue
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
mDeferred
.
empty
(
)
)
{
if
(
mPending
.
empty
(
)
)
return
;
const
Message
&
last
=
mPending
.
back
(
)
;
if
(
!
last
.
is_interrupt
(
)
|
|
last
.
is_reply
(
)
)
return
;
}
}
while
(
OnMaybeDequeueOne
(
)
)
;
}
void
MessageChannel
:
:
ExitedCxxStack
(
)
{
mListener
-
>
OnExitedCxxStack
(
)
;
if
(
mSawInterruptOutMsg
)
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
EnqueuePendingMessages
(
)
;
mSawInterruptOutMsg
=
false
;
}
}
void
MessageChannel
:
:
EnqueuePendingMessages
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
MaybeUndeferIncall
(
)
;
for
(
size_t
i
=
0
;
i
<
mDeferred
.
size
(
)
;
+
+
i
)
{
RefPtr
<
DequeueTask
>
task
=
new
DequeueTask
(
mDequeueOneTask
)
;
mWorkerLoop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
for
(
size_t
i
=
0
;
i
<
mPending
.
size
(
)
;
+
+
i
)
{
RefPtr
<
DequeueTask
>
task
=
new
DequeueTask
(
mDequeueOneTask
)
;
mWorkerLoop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
}
static
inline
bool
IsTimeoutExpired
(
PRIntervalTime
aStart
PRIntervalTime
aTimeout
)
{
return
(
aTimeout
!
=
PR_INTERVAL_NO_TIMEOUT
)
&
&
(
aTimeout
<
=
(
PR_IntervalNow
(
)
-
aStart
)
)
;
}
bool
MessageChannel
:
:
WaitResponse
(
bool
aWaitTimedOut
)
{
if
(
aWaitTimedOut
)
{
if
(
mInTimeoutSecondHalf
)
{
return
false
;
}
mInTimeoutSecondHalf
=
true
;
}
else
{
mInTimeoutSecondHalf
=
false
;
}
return
true
;
}
#
ifndef
OS_WIN
bool
MessageChannel
:
:
WaitForSyncNotify
(
bool
)
{
#
ifdef
DEBUG
if
(
mListener
-
>
ArtificialTimeout
(
)
)
{
return
false
;
}
#
endif
PRIntervalTime
timeout
=
(
kNoTimeout
=
=
mTimeoutMs
)
?
PR_INTERVAL_NO_TIMEOUT
:
PR_MillisecondsToInterval
(
mTimeoutMs
)
;
PRIntervalTime
waitStart
=
PR_IntervalNow
(
)
;
mMonitor
-
>
Wait
(
timeout
)
;
return
WaitResponse
(
IsTimeoutExpired
(
waitStart
timeout
)
)
;
}
bool
MessageChannel
:
:
WaitForInterruptNotify
(
)
{
return
WaitForSyncNotify
(
true
)
;
}
void
MessageChannel
:
:
NotifyWorkerThread
(
)
{
mMonitor
-
>
Notify
(
)
;
}
#
endif
bool
MessageChannel
:
:
ShouldContinueFromTimeout
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
bool
cont
;
{
MonitorAutoUnlock
unlock
(
*
mMonitor
)
;
cont
=
mListener
-
>
OnReplyTimeout
(
)
;
mListener
-
>
ArtificialSleep
(
)
;
}
static
enum
{
UNKNOWN
NOT_DEBUGGING
DEBUGGING
}
sDebuggingChildren
=
UNKNOWN
;
if
(
sDebuggingChildren
=
=
UNKNOWN
)
{
sDebuggingChildren
=
getenv
(
"
MOZ_DEBUG_CHILD_PROCESS
"
)
?
DEBUGGING
:
NOT_DEBUGGING
;
}
if
(
sDebuggingChildren
=
=
DEBUGGING
)
{
return
true
;
}
return
cont
;
}
void
MessageChannel
:
:
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
{
AssertWorkerThread
(
)
;
mTimeoutMs
=
(
aTimeoutMs
<
=
0
)
?
kNoTimeout
:
(
int32_t
)
ceil
(
(
double
)
aTimeoutMs
/
2
.
0
)
;
}
void
MessageChannel
:
:
OnChannelConnected
(
int32_t
peer_id
)
{
MOZ_RELEASE_ASSERT
(
!
mPeerPidSet
)
;
mPeerPidSet
=
true
;
mPeerPid
=
peer_id
;
RefPtr
<
DequeueTask
>
task
=
new
DequeueTask
(
mOnChannelConnectedTask
)
;
mWorkerLoop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
void
MessageChannel
:
:
DispatchOnChannelConnected
(
)
{
AssertWorkerThread
(
)
;
MOZ_RELEASE_ASSERT
(
mPeerPidSet
)
;
if
(
mListener
)
mListener
-
>
OnChannelConnected
(
mPeerPid
)
;
}
void
MessageChannel
:
:
ReportMessageRouteError
(
const
char
*
channelName
)
const
{
PrintErrorMessage
(
mSide
channelName
"
Need
a
route
"
)
;
mListener
-
>
OnProcessingError
(
MsgRouteError
"
MsgRouteError
"
)
;
}
void
MessageChannel
:
:
ReportConnectionError
(
const
char
*
aChannelName
Message
*
aMsg
)
const
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
const
char
*
errorMsg
=
nullptr
;
switch
(
mChannelState
)
{
case
ChannelClosed
:
errorMsg
=
"
Closed
channel
:
cannot
send
/
recv
"
;
break
;
case
ChannelOpening
:
errorMsg
=
"
Opening
channel
:
not
yet
ready
for
send
/
recv
"
;
break
;
case
ChannelTimeout
:
errorMsg
=
"
Channel
timeout
:
cannot
send
/
recv
"
;
break
;
case
ChannelClosing
:
errorMsg
=
"
Channel
closing
:
too
late
to
send
/
recv
messages
will
be
lost
"
;
break
;
case
ChannelError
:
errorMsg
=
"
Channel
error
:
cannot
send
/
recv
"
;
break
;
default
:
NS_RUNTIMEABORT
(
"
unreached
"
)
;
}
if
(
aMsg
)
{
char
reason
[
512
]
;
snprintf_literal
(
reason
"
(
msgtype
=
0x
%
X
name
=
%
s
)
%
s
"
aMsg
-
>
type
(
)
aMsg
-
>
name
(
)
errorMsg
)
;
PrintErrorMessage
(
mSide
aChannelName
reason
)
;
}
else
{
PrintErrorMessage
(
mSide
aChannelName
errorMsg
)
;
}
MonitorAutoUnlock
unlock
(
*
mMonitor
)
;
mListener
-
>
OnProcessingError
(
MsgDropped
errorMsg
)
;
}
bool
MessageChannel
:
:
MaybeHandleError
(
Result
code
const
Message
&
aMsg
const
char
*
channelName
)
{
if
(
MsgProcessed
=
=
code
)
return
true
;
const
char
*
errorMsg
=
nullptr
;
switch
(
code
)
{
case
MsgNotKnown
:
errorMsg
=
"
Unknown
message
:
not
processed
"
;
break
;
case
MsgNotAllowed
:
errorMsg
=
"
Message
not
allowed
:
cannot
be
sent
/
recvd
in
this
state
"
;
break
;
case
MsgPayloadError
:
errorMsg
=
"
Payload
error
:
message
could
not
be
deserialized
"
;
break
;
case
MsgProcessingError
:
errorMsg
=
"
Processing
error
:
message
was
deserialized
but
the
handler
returned
false
(
indicating
failure
)
"
;
break
;
case
MsgRouteError
:
errorMsg
=
"
Route
error
:
message
sent
to
unknown
actor
ID
"
;
break
;
case
MsgValueError
:
errorMsg
=
"
Value
error
:
message
was
deserialized
but
contained
an
illegal
value
"
;
break
;
default
:
NS_RUNTIMEABORT
(
"
unknown
Result
code
"
)
;
return
false
;
}
char
reason
[
512
]
;
snprintf_literal
(
reason
"
(
msgtype
=
0x
%
X
name
=
%
s
)
%
s
"
aMsg
.
type
(
)
aMsg
.
name
(
)
errorMsg
)
;
PrintErrorMessage
(
mSide
channelName
reason
)
;
mListener
-
>
OnProcessingError
(
code
reason
)
;
return
false
;
}
void
MessageChannel
:
:
OnChannelErrorFromLink
(
)
{
AssertLinkThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
IPC_LOG
(
"
OnChannelErrorFromLink
"
)
;
if
(
InterruptStackDepth
(
)
>
0
)
NotifyWorkerThread
(
)
;
if
(
AwaitingSyncReply
(
)
|
|
AwaitingIncomingMessage
(
)
)
NotifyWorkerThread
(
)
;
if
(
ChannelClosing
!
=
mChannelState
)
{
if
(
mAbortOnError
)
{
NS_RUNTIMEABORT
(
"
Aborting
on
channel
error
.
"
)
;
}
mChannelState
=
ChannelError
;
mMonitor
-
>
Notify
(
)
;
}
PostErrorNotifyTask
(
)
;
}
void
MessageChannel
:
:
NotifyMaybeChannelError
(
)
{
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
if
(
ChannelClosing
=
=
mChannelState
)
{
mChannelState
=
ChannelClosed
;
NotifyChannelClosed
(
)
;
return
;
}
mChannelState
=
ChannelError
;
mListener
-
>
OnChannelError
(
)
;
Clear
(
)
;
}
void
MessageChannel
:
:
OnNotifyMaybeChannelError
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
mChannelErrorTask
=
nullptr
;
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
}
if
(
IsOnCxxStack
(
)
)
{
mChannelErrorTask
=
NewRunnableMethod
(
this
&
MessageChannel
:
:
OnNotifyMaybeChannelError
)
;
RefPtr
<
Runnable
>
task
=
mChannelErrorTask
;
mWorkerLoop
-
>
PostDelayedTask
(
task
.
forget
(
)
10
)
;
return
;
}
NotifyMaybeChannelError
(
)
;
}
void
MessageChannel
:
:
PostErrorNotifyTask
(
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
if
(
mChannelErrorTask
)
return
;
mChannelErrorTask
=
NewRunnableMethod
(
this
&
MessageChannel
:
:
OnNotifyMaybeChannelError
)
;
RefPtr
<
Runnable
>
task
=
mChannelErrorTask
;
mWorkerLoop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
class
GoodbyeMessage
:
public
IPC
:
:
Message
{
public
:
GoodbyeMessage
(
)
:
IPC
:
:
Message
(
MSG_ROUTING_NONE
GOODBYE_MESSAGE_TYPE
PRIORITY_NORMAL
)
{
}
static
bool
Read
(
const
Message
*
msg
)
{
return
true
;
}
void
Log
(
const
std
:
:
string
&
aPrefix
FILE
*
aOutf
)
const
{
fputs
(
"
(
special
Goodbye
'
message
)
"
aOutf
)
;
}
}
;
void
MessageChannel
:
:
SynchronouslyClose
(
)
{
AssertWorkerThread
(
)
;
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
mLink
-
>
SendClose
(
)
;
while
(
ChannelClosed
!
=
mChannelState
)
mMonitor
-
>
Wait
(
)
;
}
void
MessageChannel
:
:
CloseWithError
(
)
{
AssertWorkerThread
(
)
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
ChannelConnected
!
=
mChannelState
)
{
return
;
}
SynchronouslyClose
(
)
;
mChannelState
=
ChannelError
;
PostErrorNotifyTask
(
)
;
}
void
MessageChannel
:
:
CloseWithTimeout
(
)
{
AssertWorkerThread
(
)
;
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
ChannelConnected
!
=
mChannelState
)
{
return
;
}
SynchronouslyClose
(
)
;
mChannelState
=
ChannelTimeout
;
}
void
MessageChannel
:
:
Close
(
)
{
AssertWorkerThread
(
)
;
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
ChannelError
=
=
mChannelState
|
|
ChannelTimeout
=
=
mChannelState
)
{
if
(
mListener
)
{
MonitorAutoUnlock
unlock
(
*
mMonitor
)
;
NotifyMaybeChannelError
(
)
;
}
return
;
}
if
(
ChannelOpening
=
=
mChannelState
)
{
SynchronouslyClose
(
)
;
mChannelState
=
ChannelError
;
NotifyMaybeChannelError
(
)
;
return
;
}
if
(
ChannelConnected
!
=
mChannelState
)
{
NS_RUNTIMEABORT
(
"
Close
(
)
called
on
closed
channel
!
"
)
;
}
mLink
-
>
SendMessage
(
new
GoodbyeMessage
(
)
)
;
SynchronouslyClose
(
)
;
}
NotifyChannelClosed
(
)
;
}
void
MessageChannel
:
:
NotifyChannelClosed
(
)
{
mMonitor
-
>
AssertNotCurrentThreadOwns
(
)
;
if
(
ChannelClosed
!
=
mChannelState
)
NS_RUNTIMEABORT
(
"
channel
should
have
been
closed
!
"
)
;
mListener
-
>
OnChannelClose
(
)
;
Clear
(
)
;
}
void
MessageChannel
:
:
DebugAbort
(
const
char
*
file
int
line
const
char
*
cond
const
char
*
why
bool
reply
)
const
{
printf_stderr
(
"
#
#
#
!
!
!
[
MessageChannel
]
[
%
s
]
[
%
s
:
%
d
]
"
"
Assertion
(
%
s
)
failed
.
%
s
%
s
\
n
"
mSide
=
=
ChildSide
?
"
Child
"
:
"
Parent
"
file
line
cond
why
reply
?
"
(
reply
)
"
:
"
"
)
;
DumpInterruptStack
(
"
"
)
;
printf_stderr
(
"
remote
Interrupt
stack
guess
:
%
"
PRIuSIZE
"
\
n
"
mRemoteStackDepthGuess
)
;
printf_stderr
(
"
deferred
stack
size
:
%
"
PRIuSIZE
"
\
n
"
mDeferred
.
size
(
)
)
;
printf_stderr
(
"
out
-
of
-
turn
Interrupt
replies
stack
size
:
%
"
PRIuSIZE
"
\
n
"
mOutOfTurnReplies
.
size
(
)
)
;
printf_stderr
(
"
Pending
queue
size
:
%
"
PRIuSIZE
"
front
to
back
:
\
n
"
mPending
.
size
(
)
)
;
MessageQueue
pending
=
mPending
;
while
(
!
pending
.
empty
(
)
)
{
printf_stderr
(
"
[
%
s
%
s
]
\
n
"
pending
.
front
(
)
.
is_interrupt
(
)
?
"
intr
"
:
(
pending
.
front
(
)
.
is_sync
(
)
?
"
sync
"
:
"
async
"
)
pending
.
front
(
)
.
is_reply
(
)
?
"
reply
"
:
"
"
)
;
pending
.
pop_front
(
)
;
}
NS_RUNTIMEABORT
(
why
)
;
}
void
MessageChannel
:
:
DumpInterruptStack
(
const
char
*
const
pfx
)
const
{
NS_WARN_IF_FALSE
(
MessageLoop
:
:
current
(
)
!
=
mWorkerLoop
"
The
worker
thread
had
better
be
paused
in
a
debugger
!
"
)
;
printf_stderr
(
"
%
sMessageChannel
'
backtrace
'
:
\
n
"
pfx
)
;
for
(
uint32_t
i
=
0
;
i
<
mCxxStackFrames
.
length
(
)
;
+
+
i
)
{
int32_t
id
;
const
char
*
dir
;
const
char
*
sems
;
const
char
*
name
;
mCxxStackFrames
[
i
]
.
Describe
(
&
id
&
dir
&
sems
&
name
)
;
printf_stderr
(
"
%
s
[
(
%
u
)
%
s
%
s
%
s
(
actor
=
%
d
)
]
\
n
"
pfx
i
dir
sems
name
id
)
;
}
}
int32_t
MessageChannel
:
:
GetTopmostMessageRoutingId
(
)
const
{
MOZ_RELEASE_ASSERT
(
MessageLoop
:
:
current
(
)
=
=
mWorkerLoop
)
;
if
(
mCxxStackFrames
.
empty
(
)
)
{
return
MSG_ROUTING_NONE
;
}
const
InterruptFrame
&
frame
=
mCxxStackFrames
.
back
(
)
;
return
frame
.
GetRoutingId
(
)
;
}
void
MessageChannel
:
:
EndTimeout
(
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
IPC_LOG
(
"
Ending
timeout
of
seqno
=
%
d
"
mTimedOutMessageSeqno
)
;
mTimedOutMessageSeqno
=
0
;
mTimedOutMessagePriority
=
0
;
for
(
size_t
i
=
0
;
i
<
mPending
.
size
(
)
;
i
+
+
)
{
RefPtr
<
DequeueTask
>
task
=
new
DequeueTask
(
mDequeueOneTask
)
;
mWorkerLoop
-
>
PostTask
(
task
.
forget
(
)
)
;
}
}
void
MessageChannel
:
:
CancelTransaction
(
int
transaction
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
IPC_LOG
(
"
CancelTransaction
:
xid
=
%
d
"
transaction
)
;
if
(
transaction
=
=
mTimedOutMessageSeqno
)
{
IPC_LOG
(
"
Cancelled
timed
out
message
%
d
"
mTimedOutMessageSeqno
)
;
EndTimeout
(
)
;
MOZ_RELEASE_ASSERT
(
!
mTransactionStack
|
|
mTransactionStack
-
>
TransactionID
(
)
=
=
transaction
)
;
if
(
mTransactionStack
)
{
mTransactionStack
-
>
Cancel
(
)
;
}
}
else
{
MOZ_RELEASE_ASSERT
(
mTransactionStack
-
>
TransactionID
(
)
=
=
transaction
)
;
mTransactionStack
-
>
Cancel
(
)
;
}
bool
foundSync
=
false
;
for
(
MessageQueue
:
:
iterator
it
=
mPending
.
begin
(
)
;
it
!
=
mPending
.
end
(
)
;
)
{
Message
&
msg
=
*
it
;
if
(
msg
.
is_sync
(
)
&
&
msg
.
priority
(
)
!
=
IPC
:
:
Message
:
:
PRIORITY_NORMAL
)
{
MOZ_RELEASE_ASSERT
(
!
foundSync
)
;
MOZ_RELEASE_ASSERT
(
msg
.
transaction_id
(
)
!
=
transaction
)
;
IPC_LOG
(
"
Removing
msg
from
queue
seqno
=
%
d
xid
=
%
d
"
msg
.
seqno
(
)
msg
.
transaction_id
(
)
)
;
foundSync
=
true
;
it
=
mPending
.
erase
(
it
)
;
continue
;
}
it
+
+
;
}
}
bool
MessageChannel
:
:
IsInTransaction
(
)
const
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
return
!
!
mTransactionStack
;
}
void
MessageChannel
:
:
CancelCurrentTransaction
(
)
{
MonitorAutoLock
lock
(
*
mMonitor
)
;
if
(
DispatchingSyncMessagePriority
(
)
>
=
IPC
:
:
Message
:
:
PRIORITY_HIGH
)
{
if
(
DispatchingSyncMessagePriority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
|
|
DispatchingAsyncMessagePriority
(
)
=
=
IPC
:
:
Message
:
:
PRIORITY_URGENT
)
{
mListener
-
>
IntentionalCrash
(
)
;
}
IPC_LOG
(
"
Cancel
requested
:
current
xid
=
%
d
"
CurrentHighPriorityTransaction
(
)
)
;
MOZ_RELEASE_ASSERT
(
DispatchingSyncMessage
(
)
)
;
CancelMessage
*
cancel
=
new
CancelMessage
(
CurrentHighPriorityTransaction
(
)
)
;
CancelTransaction
(
CurrentHighPriorityTransaction
(
)
)
;
mLink
-
>
SendMessage
(
cancel
)
;
}
}
void
CancelCPOWs
(
)
{
if
(
gParentProcessBlocker
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
IPC_TRANSACTION_CANCEL
true
)
;
gParentProcessBlocker
-
>
CancelCurrentTransaction
(
)
;
}
}
}
}
