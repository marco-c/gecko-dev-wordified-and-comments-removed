#
include
"
IPCStreamDestination
.
h
"
#
include
"
mozilla
/
dom
/
nsIContentParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PChildToParentStreamParent
.
h
"
#
include
"
mozilla
/
ipc
/
PParentToChildStreamParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
namespace
mozilla
{
namespace
ipc
{
namespace
{
class
IPCStreamSourceParent
final
:
public
PParentToChildStreamParent
public
IPCStreamSource
{
public
:
static
IPCStreamSourceParent
*
Create
(
nsIAsyncInputStream
*
aInputStream
)
{
MOZ_ASSERT
(
aInputStream
)
;
IPCStreamSourceParent
*
source
=
new
IPCStreamSourceParent
(
aInputStream
)
;
if
(
!
source
-
>
Initialize
(
)
)
{
delete
source
;
return
nullptr
;
}
return
source
;
}
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
{
ActorDestroyed
(
)
;
}
IPCResult
RecvStartReading
(
)
override
{
Start
(
)
;
return
IPC_OK
(
)
;
}
IPCResult
RecvRequestClose
(
const
nsresult
&
aRv
)
override
{
OnEnd
(
aRv
)
;
return
IPC_OK
(
)
;
}
void
Close
(
nsresult
aRv
)
override
{
MOZ_ASSERT
(
IPCStreamSource
:
:
mState
=
=
IPCStreamSource
:
:
eClosed
)
;
Unused
<
<
SendClose
(
aRv
)
;
}
void
SendData
(
const
nsCString
&
aBuffer
)
override
{
Unused
<
<
SendBuffer
(
aBuffer
)
;
}
private
:
explicit
IPCStreamSourceParent
(
nsIAsyncInputStream
*
aInputStream
)
:
IPCStreamSource
(
aInputStream
)
{
}
}
;
}
PParentToChildStreamParent
*
IPCStreamSource
:
:
Create
(
nsIAsyncInputStream
*
aInputStream
dom
:
:
nsIContentParent
*
aManager
)
{
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
IPCStreamSourceParent
*
source
=
IPCStreamSourceParent
:
:
Create
(
aInputStream
)
;
if
(
!
source
)
{
return
nullptr
;
}
if
(
!
aManager
-
>
SendPParentToChildStreamConstructor
(
source
)
)
{
return
nullptr
;
}
source
-
>
ActorConstructed
(
)
;
return
source
;
}
PParentToChildStreamParent
*
IPCStreamSource
:
:
Create
(
nsIAsyncInputStream
*
aInputStream
PBackgroundParent
*
aManager
)
{
MOZ_ASSERT
(
aInputStream
)
;
MOZ_ASSERT
(
aManager
)
;
IPCStreamSourceParent
*
source
=
IPCStreamSourceParent
:
:
Create
(
aInputStream
)
;
if
(
!
source
)
{
return
nullptr
;
}
if
(
!
aManager
-
>
SendPParentToChildStreamConstructor
(
source
)
)
{
return
nullptr
;
}
source
-
>
ActorConstructed
(
)
;
return
source
;
}
IPCStreamSource
*
IPCStreamSource
:
:
Cast
(
PParentToChildStreamParent
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
return
static_cast
<
IPCStreamSourceParent
*
>
(
aActor
)
;
}
namespace
{
class
IPCStreamDestinationParent
final
:
public
PChildToParentStreamParent
public
IPCStreamDestination
{
public
:
nsresult
Initialize
(
)
{
return
IPCStreamDestination
:
:
Initialize
(
)
;
}
~
IPCStreamDestinationParent
(
)
{
}
private
:
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
{
ActorDestroyed
(
)
;
}
IPCResult
RecvBuffer
(
const
nsCString
&
aBuffer
)
override
{
BufferReceived
(
aBuffer
)
;
return
IPC_OK
(
)
;
}
IPCResult
RecvClose
(
const
nsresult
&
aRv
)
override
{
CloseReceived
(
aRv
)
;
return
IPC_OK
(
)
;
}
void
StartReading
(
)
override
{
MOZ_ASSERT
(
HasDelayedStart
(
)
)
;
Unused
<
<
SendStartReading
(
)
;
}
void
RequestClose
(
nsresult
aRv
)
override
{
Unused
<
<
SendRequestClose
(
aRv
)
;
}
void
TerminateDestination
(
)
override
{
Unused
<
<
Send__delete__
(
this
)
;
}
}
;
}
PChildToParentStreamParent
*
AllocPChildToParentStreamParent
(
)
{
IPCStreamDestinationParent
*
actor
=
new
IPCStreamDestinationParent
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
actor
-
>
Initialize
(
)
)
)
)
{
delete
actor
;
actor
=
nullptr
;
}
return
actor
;
}
void
DeallocPChildToParentStreamParent
(
PChildToParentStreamParent
*
aActor
)
{
delete
aActor
;
}
IPCStreamDestination
*
IPCStreamDestination
:
:
Cast
(
PChildToParentStreamParent
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
return
static_cast
<
IPCStreamDestinationParent
*
>
(
aActor
)
;
}
}
}
