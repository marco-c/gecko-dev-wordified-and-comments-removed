#
ifndef
__IPC_GLUE_MESSAGEPUMP_H__
#
define
__IPC_GLUE_MESSAGEPUMP_H__
#
include
"
base
/
message_pump_default
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
base
/
message_pump_win
.
h
"
#
endif
#
include
"
base
/
time
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIThreadInternal
.
h
"
class
nsIEventTarget
;
class
nsITimer
;
namespace
mozilla
{
namespace
ipc
{
class
DoWorkRunnable
;
class
MessagePump
:
public
base
:
:
MessagePumpDefault
{
friend
class
DoWorkRunnable
;
public
:
explicit
MessagePump
(
nsISerialEventTarget
*
aEventTarget
)
;
virtual
void
Run
(
base
:
:
MessagePump
:
:
Delegate
*
aDelegate
)
override
;
virtual
void
ScheduleWork
(
)
override
;
virtual
void
ScheduleWorkForNestedLoop
(
)
override
;
virtual
void
ScheduleDelayedWork
(
const
base
:
:
TimeTicks
&
aDelayedWorkTime
)
override
;
virtual
nsISerialEventTarget
*
GetXPCOMThread
(
)
override
;
protected
:
virtual
~
MessagePump
(
)
;
private
:
void
DoDelayedWork
(
base
:
:
MessagePump
:
:
Delegate
*
aDelegate
)
;
protected
:
nsISerialEventTarget
*
mEventTarget
;
nsCOMPtr
<
nsITimer
>
mDelayedWorkTimer
;
private
:
RefPtr
<
DoWorkRunnable
>
mDoWorkEvent
;
}
;
class
MessagePumpForChildProcess
final
:
public
MessagePump
{
public
:
MessagePumpForChildProcess
(
)
:
MessagePump
(
nullptr
)
mFirstRun
(
true
)
{
}
virtual
void
Run
(
base
:
:
MessagePump
:
:
Delegate
*
aDelegate
)
override
;
private
:
~
MessagePumpForChildProcess
(
)
=
default
;
bool
mFirstRun
;
}
;
class
MessagePumpForNonMainThreads
final
:
public
MessagePump
{
public
:
explicit
MessagePumpForNonMainThreads
(
nsISerialEventTarget
*
aEventTarget
)
:
MessagePump
(
aEventTarget
)
{
}
virtual
void
Run
(
base
:
:
MessagePump
:
:
Delegate
*
aDelegate
)
override
;
private
:
~
MessagePumpForNonMainThreads
(
)
=
default
;
}
;
#
if
defined
(
XP_WIN
)
class
MessagePumpForNonMainUIThreads
final
:
public
base
:
:
MessagePumpForUI
public
nsIThreadObserver
{
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
override
{
return
2
;
}
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
override
{
return
1
;
}
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
;
NS_DECL_NSITHREADOBSERVER
public
:
explicit
MessagePumpForNonMainUIThreads
(
nsIEventTarget
*
aEventTarget
)
:
mInWait
(
false
)
mWaitLock
(
"
mInWait
"
)
{
}
virtual
void
DoRunLoop
(
)
override
;
virtual
nsISerialEventTarget
*
GetXPCOMThread
(
)
override
{
return
nullptr
;
}
protected
:
void
SetInWait
(
)
{
MutexAutoLock
lock
(
mWaitLock
)
;
mInWait
=
true
;
}
void
ClearInWait
(
)
{
MutexAutoLock
lock
(
mWaitLock
)
;
mInWait
=
false
;
}
bool
GetInWait
(
)
{
MutexAutoLock
lock
(
mWaitLock
)
;
return
mInWait
;
}
private
:
~
MessagePumpForNonMainUIThreads
(
)
{
}
bool
mInWait
MOZ_GUARDED_BY
(
mWaitLock
)
;
mozilla
:
:
Mutex
mWaitLock
;
}
;
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
class
MessagePumpForAndroidUI
:
public
base
:
:
MessagePump
{
public
:
explicit
MessagePumpForAndroidUI
(
nsISerialEventTarget
*
aEventTarget
)
:
mEventTarget
(
aEventTarget
)
{
}
virtual
void
Run
(
Delegate
*
delegate
)
;
virtual
void
Quit
(
)
;
virtual
void
ScheduleWork
(
)
;
virtual
void
ScheduleDelayedWork
(
const
base
:
:
TimeTicks
&
delayed_work_time
)
;
virtual
nsISerialEventTarget
*
GetXPCOMThread
(
)
{
return
mEventTarget
;
}
private
:
~
MessagePumpForAndroidUI
(
)
{
}
MessagePumpForAndroidUI
(
)
{
}
nsISerialEventTarget
*
mEventTarget
;
}
;
#
endif
}
}
#
endif
