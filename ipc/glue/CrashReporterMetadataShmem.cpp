#
include
"
CrashReporterMetadataShmem
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
ipc
{
enum
class
EntryType
:
uint8_t
{
None
Annotation
}
;
CrashReporterMetadataShmem
:
:
CrashReporterMetadataShmem
(
const
Shmem
&
aShmem
)
:
mShmem
(
aShmem
)
{
MOZ_COUNT_CTOR
(
CrashReporterMetadataShmem
)
;
}
CrashReporterMetadataShmem
:
:
~
CrashReporterMetadataShmem
(
)
{
MOZ_COUNT_DTOR
(
CrashReporterMetadataShmem
)
;
}
void
CrashReporterMetadataShmem
:
:
AnnotateCrashReport
(
const
nsCString
&
aKey
const
nsCString
&
aData
)
{
mNotes
.
Put
(
aKey
aData
)
;
SyncNotesToShmem
(
)
;
}
void
CrashReporterMetadataShmem
:
:
AppendAppNotes
(
const
nsCString
&
aData
)
{
mAppNotes
.
Append
(
aData
)
;
mNotes
.
Put
(
NS_LITERAL_CSTRING
(
"
Notes
"
)
mAppNotes
)
;
SyncNotesToShmem
(
)
;
}
class
MOZ_STACK_CLASS
MetadataShmemWriter
{
public
:
explicit
MetadataShmemWriter
(
const
Shmem
&
aShmem
)
:
mCursor
(
aShmem
.
get
<
uint8_t
>
(
)
)
mEnd
(
mCursor
+
aShmem
.
Size
<
uint8_t
>
(
)
)
{
*
mCursor
=
uint8_t
(
EntryType
:
:
None
)
;
}
MOZ_MUST_USE
bool
WriteAnnotation
(
const
nsCString
&
aKey
const
nsCString
&
aValue
)
{
if
(
mCursor
>
=
mEnd
)
{
return
false
;
}
uint8_t
*
start
=
mCursor
+
+
;
if
(
!
Write
(
aKey
)
|
|
!
Write
(
aValue
)
)
{
return
false
;
}
return
Commit
(
start
EntryType
:
:
Annotation
)
;
}
private
:
MOZ_MUST_USE
bool
Commit
(
uint8_t
*
aStart
EntryType
aType
)
{
MOZ_ASSERT
(
aStart
<
mEnd
)
;
MOZ_ASSERT
(
EntryType
(
*
aStart
)
=
=
EntryType
:
:
None
)
;
if
(
mCursor
>
=
mEnd
)
{
mCursor
=
aStart
;
return
false
;
}
*
aStart
=
uint8_t
(
aType
)
;
*
mCursor
=
uint8_t
(
EntryType
:
:
None
)
;
return
true
;
}
MOZ_MUST_USE
bool
Write
(
const
nsCString
&
aString
)
{
return
Write
(
static_cast
<
uint32_t
>
(
aString
.
Length
(
)
)
)
&
&
Write
(
aString
.
get
(
)
aString
.
Length
(
)
)
;
}
template
<
typename
T
>
MOZ_MUST_USE
bool
Write
(
const
T
&
aT
)
{
return
Write
(
&
aT
sizeof
(
T
)
)
;
}
MOZ_MUST_USE
bool
Write
(
const
void
*
aData
size_t
aLength
)
{
if
(
size_t
(
mEnd
-
mCursor
)
<
aLength
)
{
return
false
;
}
memcpy
(
mCursor
aData
aLength
)
;
mCursor
+
=
aLength
;
return
true
;
}
private
:
uint8_t
*
mCursor
;
uint8_t
*
mEnd
;
}
;
void
CrashReporterMetadataShmem
:
:
SyncNotesToShmem
(
)
{
MetadataShmemWriter
writer
(
mShmem
)
;
for
(
auto
it
=
mNotes
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
nsCString
key
=
nsCString
(
it
.
Key
(
)
)
;
nsCString
value
=
nsCString
(
it
.
Data
(
)
)
;
if
(
!
writer
.
WriteAnnotation
(
key
value
)
)
{
return
;
}
}
}
class
MOZ_STACK_CLASS
MetadataShmemReader
{
public
:
explicit
MetadataShmemReader
(
const
Shmem
&
aShmem
)
:
mEntryType
(
EntryType
:
:
None
)
{
mCursor
=
aShmem
.
get
<
uint8_t
>
(
)
;
mEnd
=
mCursor
+
aShmem
.
Size
<
uint8_t
>
(
)
;
Next
(
)
;
}
bool
Done
(
)
const
{
return
mCursor
>
=
mEnd
|
|
Type
(
)
=
=
EntryType
:
:
None
;
}
EntryType
Type
(
)
const
{
return
mEntryType
;
}
void
Next
(
)
{
if
(
mCursor
<
mEnd
)
{
mEntryType
=
EntryType
(
*
mCursor
+
+
)
;
}
else
{
mEntryType
=
EntryType
:
:
None
;
}
}
bool
Read
(
nsCString
&
aOut
)
{
uint32_t
length
=
0
;
if
(
!
Read
(
&
length
)
)
{
return
false
;
}
const
uint8_t
*
src
=
Read
(
length
)
;
if
(
!
src
)
{
return
false
;
}
aOut
.
Assign
(
(
const
char
*
)
src
length
)
;
return
true
;
}
private
:
template
<
typename
T
>
bool
Read
(
T
*
aOut
)
{
return
Read
(
aOut
sizeof
(
T
)
)
;
}
bool
Read
(
void
*
aOut
size_t
aLength
)
{
const
uint8_t
*
src
=
Read
(
aLength
)
;
if
(
!
src
)
{
return
false
;
}
memcpy
(
aOut
src
aLength
)
;
return
true
;
}
const
uint8_t
*
Read
(
size_t
aLength
)
{
if
(
size_t
(
mEnd
-
mCursor
)
<
aLength
)
{
return
nullptr
;
}
const
uint8_t
*
result
=
mCursor
;
mCursor
+
=
aLength
;
return
result
;
}
private
:
const
uint8_t
*
mCursor
;
const
uint8_t
*
mEnd
;
EntryType
mEntryType
;
}
;
#
ifdef
MOZ_CRASHREPORTER
void
CrashReporterMetadataShmem
:
:
ReadAppNotes
(
const
Shmem
&
aShmem
CrashReporter
:
:
AnnotationTable
*
aNotes
)
{
for
(
MetadataShmemReader
reader
(
aShmem
)
;
!
reader
.
Done
(
)
;
reader
.
Next
(
)
)
{
switch
(
reader
.
Type
(
)
)
{
case
EntryType
:
:
Annotation
:
{
nsCString
key
value
;
if
(
!
reader
.
Read
(
key
)
|
|
!
reader
.
Read
(
value
)
)
{
return
;
}
aNotes
-
>
Put
(
key
value
)
;
break
;
}
default
:
NS_ASSERTION
(
false
"
Unknown
metadata
entry
type
"
)
;
break
;
}
}
}
#
endif
}
}
