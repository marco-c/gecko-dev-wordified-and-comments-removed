#
include
"
mozilla
/
ipc
/
IdleSchedulerChild
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerParent
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
PrioritizedEventQueue
.
h
"
#
include
"
BackgroundChild
.
h
"
namespace
mozilla
{
namespace
ipc
{
static
IdleSchedulerChild
*
sMainThreadIdleScheduler
=
nullptr
;
IdleSchedulerChild
:
:
~
IdleSchedulerChild
(
)
{
if
(
sMainThreadIdleScheduler
=
=
this
)
{
sMainThreadIdleScheduler
=
nullptr
;
}
MOZ_ASSERT
(
!
mEventQueue
)
;
}
void
IdleSchedulerChild
:
:
Init
(
PrioritizedEventQueue
*
aEventQueue
)
{
mEventQueue
=
aEventQueue
;
RefPtr
<
IdleSchedulerChild
>
scheduler
=
this
;
auto
resolve
=
[
&
]
(
Tuple
<
mozilla
:
:
Maybe
<
SharedMemoryHandle
>
uint32_t
>
&
&
aResult
)
{
if
(
Get
<
0
>
(
aResult
)
)
{
mActiveCounter
.
SetHandle
(
*
Get
<
0
>
(
aResult
)
false
)
;
mActiveCounter
.
Map
(
sizeof
(
int32_t
)
)
;
mChildId
=
Get
<
1
>
(
aResult
)
;
if
(
mChildId
&
&
mEventQueue
&
&
mEventQueue
-
>
IsActive
(
)
)
{
SetActive
(
)
;
}
}
}
;
auto
reject
=
[
&
]
(
ResponseRejectReason
)
{
}
;
SendInitForIdleUse
(
std
:
:
move
(
resolve
)
std
:
:
move
(
reject
)
)
;
}
IPCResult
IdleSchedulerChild
:
:
RecvIdleTime
(
uint64_t
aId
TimeDuration
aBudget
)
{
if
(
mEventQueue
)
{
mEventQueue
-
>
SetIdleToken
(
aId
aBudget
)
;
}
return
IPC_OK
(
)
;
}
void
IdleSchedulerChild
:
:
SetActive
(
)
{
if
(
mChildId
&
&
CanSend
(
)
&
&
mActiveCounter
.
memory
(
)
)
{
+
+
(
static_cast
<
Atomic
<
int32_t
>
*
>
(
mActiveCounter
.
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
)
;
+
+
(
static_cast
<
Atomic
<
int32_t
>
*
>
(
mActiveCounter
.
memory
(
)
)
[
mChildId
]
)
;
}
}
bool
IdleSchedulerChild
:
:
SetPaused
(
)
{
if
(
mChildId
&
&
CanSend
(
)
&
&
mActiveCounter
.
memory
(
)
)
{
-
-
(
static_cast
<
Atomic
<
int32_t
>
*
>
(
mActiveCounter
.
memory
(
)
)
[
mChildId
]
)
;
return
(
static_cast
<
Atomic
<
int32_t
>
*
>
(
mActiveCounter
.
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
)
-
-
=
=
static_cast
<
Atomic
<
int32_t
>
*
>
(
mActiveCounter
.
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
;
}
return
false
;
}
IdleSchedulerChild
*
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sMainThreadIdleScheduler
)
{
return
sMainThreadIdleScheduler
;
}
ipc
:
:
PBackgroundChild
*
background
=
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
background
)
{
sMainThreadIdleScheduler
=
new
ipc
:
:
IdleSchedulerChild
(
)
;
background
-
>
SendPIdleSchedulerConstructor
(
sMainThreadIdleScheduler
)
;
}
return
sMainThreadIdleScheduler
;
}
}
}
