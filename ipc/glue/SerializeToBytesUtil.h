#
ifndef
mozilla_ipc_SerializeToBytesUtil_h
#
define
mozilla_ipc_SerializeToBytesUtil_h
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
namespace
mozilla
:
:
ipc
{
template
<
typename
T
>
void
SerializeToBytesUtil
(
T
&
&
aValue
nsTArray
<
char
>
&
aBytes
)
{
IPC
:
:
Message
tmpMessage
(
MSG_ROUTING_NONE
-
1
)
;
{
IPC
:
:
MessageWriter
writer
(
tmpMessage
)
;
IPC
:
:
WriteParam
(
&
writer
std
:
:
forward
<
T
>
(
aValue
)
)
;
}
MOZ_RELEASE_ASSERT
(
!
tmpMessage
.
has_any_attachments
(
)
"
Value
contains
attachments
(
e
.
g
.
endpoints
file
"
"
handles
)
which
cannot
be
serialized
as
bytes
"
)
;
aBytes
.
SetLength
(
tmpMessage
.
size
(
)
-
IPC
:
:
Message
:
:
HeaderSize
(
)
)
;
IPC
:
:
MessageReader
reader
(
tmpMessage
)
;
bool
readOk
=
reader
.
ReadBytesInto
(
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
)
;
MOZ_RELEASE_ASSERT
(
readOk
)
;
MOZ_RELEASE_ASSERT
(
!
reader
.
HasBytesAvailable
(
1
)
)
;
}
template
<
typename
T
>
IPC
:
:
ReadResult
<
T
>
DeserializeFromBytesUtil
(
const
Span
<
char
>
&
aBytes
)
{
IPC
:
:
Message
tmpMessage
(
MSG_ROUTING_NONE
-
1
)
;
{
IPC
:
:
MessageWriter
writer
(
tmpMessage
)
;
writer
.
WriteBytes
(
aBytes
.
Elements
(
)
aBytes
.
Length
(
)
)
;
}
IPC
:
:
MessageReader
reader
(
tmpMessage
)
;
auto
rv
=
IPC
:
:
ReadParam
<
T
>
(
&
reader
)
;
if
(
rv
.
isOk
(
)
&
&
reader
.
HasBytesAvailable
(
1
)
)
{
return
{
}
;
}
return
rv
;
}
}
#
endif
