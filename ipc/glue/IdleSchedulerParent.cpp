#
include
"
mozilla
/
StaticPrefs_page_load
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerParent
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIThread
.
h
"
namespace
mozilla
{
namespace
ipc
{
base
:
:
SharedMemory
*
IdleSchedulerParent
:
:
sActiveChildCounter
=
nullptr
;
std
:
:
bitset
<
NS_IDLE_SCHEDULER_COUNTER_ARRAY_LENGHT
>
IdleSchedulerParent
:
:
sInUseChildCounters
;
LinkedList
<
IdleSchedulerParent
>
IdleSchedulerParent
:
:
sWaitingForIdle
;
Atomic
<
int32_t
>
IdleSchedulerParent
:
:
sMaxConcurrentIdleTasksInChildProcesses
(
-
1
)
;
uint32_t
IdleSchedulerParent
:
:
sChildProcessesRunningPrioritizedOperation
=
0
;
uint32_t
IdleSchedulerParent
:
:
sChildProcessesAlive
=
0
;
nsITimer
*
IdleSchedulerParent
:
:
sStarvationPreventer
=
nullptr
;
IdleSchedulerParent
:
:
IdleSchedulerParent
(
)
{
sChildProcessesAlive
+
+
;
if
(
sMaxConcurrentIdleTasksInChildProcesses
=
=
-
1
)
{
sMaxConcurrentIdleTasksInChildProcesses
=
1
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
cpucount
getter
"
[
thread
]
(
)
{
ProcessInfo
processInfo
=
{
}
;
if
(
NS_SUCCEEDED
(
CollectProcessInfo
(
processInfo
)
)
&
&
processInfo
.
cpuCount
>
1
)
{
sMaxConcurrentIdleTasksInChildProcesses
=
std
:
:
max
(
processInfo
.
cpuCount
-
1
1
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
IdleSchedulerParent
:
:
Schedule
"
[
]
(
)
{
if
(
sActiveChildCounter
&
&
sActiveChildCounter
-
>
memory
(
)
)
{
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
=
static_cast
<
int32_t
>
(
sMaxConcurrentIdleTasksInChildProcesses
)
;
}
IdleSchedulerParent
:
:
Schedule
(
nullptr
)
;
}
)
;
thread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
}
)
;
NS_DispatchBackgroundTask
(
runnable
.
forget
(
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
}
}
IdleSchedulerParent
:
:
~
IdleSchedulerParent
(
)
{
if
(
mChildId
)
{
sInUseChildCounters
[
mChildId
]
=
false
;
if
(
sActiveChildCounter
&
&
sActiveChildCounter
-
>
memory
(
)
&
&
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
mChildId
]
)
{
-
-
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
;
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
mChildId
]
=
0
;
}
}
if
(
mRunningPrioritizedOperation
)
{
-
-
sChildProcessesRunningPrioritizedOperation
;
}
if
(
isInList
(
)
)
{
remove
(
)
;
}
MOZ_ASSERT
(
sChildProcessesAlive
>
0
)
;
sChildProcessesAlive
-
-
;
if
(
sChildProcessesAlive
=
=
0
)
{
MOZ_ASSERT
(
sWaitingForIdle
.
isEmpty
(
)
)
;
delete
sActiveChildCounter
;
sActiveChildCounter
=
nullptr
;
if
(
sStarvationPreventer
)
{
sStarvationPreventer
-
>
Cancel
(
)
;
NS_RELEASE
(
sStarvationPreventer
)
;
}
}
Schedule
(
nullptr
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvInitForIdleUse
(
InitForIdleUseResolver
&
&
aResolve
)
{
MOZ_ASSERT
(
sChildProcessesAlive
>
0
)
;
MOZ_ASSERT
(
IsNotDoingIdleTask
(
)
)
;
if
(
!
sActiveChildCounter
)
{
sActiveChildCounter
=
new
base
:
:
SharedMemory
(
)
;
size_t
shmemSize
=
NS_IDLE_SCHEDULER_COUNTER_ARRAY_LENGHT
*
sizeof
(
int32_t
)
;
if
(
sActiveChildCounter
-
>
Create
(
shmemSize
)
&
&
sActiveChildCounter
-
>
Map
(
shmemSize
)
)
{
memset
(
sActiveChildCounter
-
>
memory
(
)
0
shmemSize
)
;
sInUseChildCounters
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
=
true
;
sInUseChildCounters
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
=
true
;
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
=
static_cast
<
int32_t
>
(
sMaxConcurrentIdleTasksInChildProcesses
)
;
}
else
{
delete
sActiveChildCounter
;
sActiveChildCounter
=
nullptr
;
}
}
Maybe
<
SharedMemoryHandle
>
activeCounter
;
SharedMemoryHandle
handle
;
if
(
sActiveChildCounter
&
&
sActiveChildCounter
-
>
ShareToProcess
(
OtherPid
(
)
&
handle
)
)
{
activeCounter
.
emplace
(
handle
)
;
}
uint32_t
unusedId
=
0
;
for
(
uint32_t
i
=
0
;
i
<
NS_IDLE_SCHEDULER_COUNTER_ARRAY_LENGHT
;
+
+
i
)
{
if
(
!
sInUseChildCounters
[
i
]
)
{
sInUseChildCounters
[
i
]
=
true
;
unusedId
=
i
;
break
;
}
}
mChildId
=
unusedId
;
aResolve
(
Tuple
<
const
mozilla
:
:
Maybe
<
SharedMemoryHandle
>
&
const
uint32_t
&
>
(
activeCounter
mChildId
)
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvRequestIdleTime
(
uint64_t
aId
TimeDuration
aBudget
)
{
MOZ_ASSERT
(
aBudget
)
;
MOZ_ASSERT
(
IsNotDoingIdleTask
(
)
)
;
mCurrentRequestId
=
aId
;
mRequestedIdleBudget
=
aBudget
;
sWaitingForIdle
.
insertBack
(
this
)
;
Schedule
(
this
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvIdleTimeUsed
(
uint64_t
aId
)
{
MOZ_ASSERT
(
IsWaitingForIdle
(
)
|
|
IsDoingIdleTask
(
)
)
;
MOZ_ASSERT
(
mCurrentRequestId
=
=
aId
)
;
if
(
IsWaitingForIdle
(
)
)
{
remove
(
)
;
}
mRequestedIdleBudget
=
TimeDuration
(
)
;
Schedule
(
nullptr
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvSchedule
(
)
{
Schedule
(
nullptr
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvRunningPrioritizedOperation
(
)
{
+
+
mRunningPrioritizedOperation
;
if
(
mRunningPrioritizedOperation
=
=
1
)
{
+
+
sChildProcessesRunningPrioritizedOperation
;
}
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvPrioritizedOperationDone
(
)
{
MOZ_ASSERT
(
mRunningPrioritizedOperation
)
;
-
-
mRunningPrioritizedOperation
;
if
(
mRunningPrioritizedOperation
=
=
0
)
{
-
-
sChildProcessesRunningPrioritizedOperation
;
Schedule
(
nullptr
)
;
}
return
IPC_OK
(
)
;
}
int32_t
IdleSchedulerParent
:
:
ActiveCount
(
)
{
if
(
sActiveChildCounter
)
{
return
(
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
)
;
}
return
0
;
}
bool
IdleSchedulerParent
:
:
HasSpareCycles
(
int32_t
aActiveCount
)
{
MOZ_ASSERT
(
sMaxConcurrentIdleTasksInChildProcesses
>
0
)
;
return
sChildProcessesRunningPrioritizedOperation
?
sMaxConcurrentIdleTasksInChildProcesses
/
2
>
aActiveCount
:
sMaxConcurrentIdleTasksInChildProcesses
>
aActiveCount
;
}
void
IdleSchedulerParent
:
:
SendIdleTime
(
)
{
MOZ_ASSERT
(
IsDoingIdleTask
(
)
)
;
Unused
<
<
SendIdleTime
(
mCurrentRequestId
mRequestedIdleBudget
)
;
}
void
IdleSchedulerParent
:
:
Schedule
(
IdleSchedulerParent
*
aRequester
)
{
int32_t
activeCount
=
ActiveCount
(
)
;
if
(
aRequester
&
&
aRequester
-
>
mRunningPrioritizedOperation
)
{
if
(
aRequester
-
>
isInList
(
)
)
{
aRequester
-
>
remove
(
)
;
}
aRequester
-
>
SendIdleTime
(
)
;
activeCount
+
+
;
}
while
(
!
sWaitingForIdle
.
isEmpty
(
)
&
&
HasSpareCycles
(
activeCount
)
)
{
RefPtr
<
IdleSchedulerParent
>
idleRequester
=
sWaitingForIdle
.
popFirst
(
)
;
idleRequester
-
>
SendIdleTime
(
)
;
activeCount
+
+
;
}
if
(
!
sWaitingForIdle
.
isEmpty
(
)
)
{
EnsureStarvationTimer
(
)
;
}
}
void
IdleSchedulerParent
:
:
EnsureStarvationTimer
(
)
{
if
(
!
sStarvationPreventer
)
{
NS_NewTimerWithFuncCallback
(
&
sStarvationPreventer
StarvationCallback
nullptr
StaticPrefs
:
:
page_load_deprioritization_period
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
StarvationCallback
"
)
;
}
}
void
IdleSchedulerParent
:
:
StarvationCallback
(
nsITimer
*
aTimer
void
*
aData
)
{
if
(
!
sWaitingForIdle
.
isEmpty
(
)
)
{
RefPtr
<
IdleSchedulerParent
>
first
=
sWaitingForIdle
.
getFirst
(
)
;
+
+
first
-
>
mRunningPrioritizedOperation
;
+
+
sChildProcessesRunningPrioritizedOperation
;
Schedule
(
first
)
;
-
-
first
-
>
mRunningPrioritizedOperation
;
-
-
sChildProcessesRunningPrioritizedOperation
;
}
NS_RELEASE
(
sStarvationPreventer
)
;
}
}
}
