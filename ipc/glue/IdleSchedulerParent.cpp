#
include
"
mozilla
/
StaticPrefs_page_load
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerParent
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
namespace
mozilla
:
:
ipc
{
base
:
:
SharedMemory
*
IdleSchedulerParent
:
:
sActiveChildCounter
=
nullptr
;
std
:
:
bitset
<
NS_IDLE_SCHEDULER_COUNTER_ARRAY_LENGHT
>
IdleSchedulerParent
:
:
sInUseChildCounters
;
LinkedList
<
IdleSchedulerParent
>
IdleSchedulerParent
:
:
sIdleAndGCRequests
;
int32_t
IdleSchedulerParent
:
:
sMaxConcurrentIdleTasksInChildProcesses
=
1
;
uint32_t
IdleSchedulerParent
:
:
sMaxConcurrentGCs
=
1
;
uint32_t
IdleSchedulerParent
:
:
sActiveGCs
=
0
;
bool
IdleSchedulerParent
:
:
sRecordGCTelemetry
=
false
;
uint32_t
IdleSchedulerParent
:
:
sNumWaitingGC
=
0
;
uint32_t
IdleSchedulerParent
:
:
sChildProcessesRunningPrioritizedOperation
=
0
;
uint32_t
IdleSchedulerParent
:
:
sChildProcessesAlive
=
0
;
nsITimer
*
IdleSchedulerParent
:
:
sStarvationPreventer
=
nullptr
;
uint32_t
IdleSchedulerParent
:
:
sNumCPUs
=
0
;
uint32_t
IdleSchedulerParent
:
:
sPrefConcurrentGCsMax
=
0
;
uint32_t
IdleSchedulerParent
:
:
sPrefConcurrentGCsCPUDivisor
=
0
;
IdleSchedulerParent
:
:
IdleSchedulerParent
(
)
{
sChildProcessesAlive
+
+
;
uint32_t
max_gcs_pref
=
StaticPrefs
:
:
javascript_options_concurrent_multiprocess_gcs_max
(
)
;
uint32_t
cpu_divisor_pref
=
StaticPrefs
:
:
javascript_options_concurrent_multiprocess_gcs_cpu_divisor
(
)
;
if
(
!
max_gcs_pref
)
{
max_gcs_pref
=
UINT32_MAX
;
}
if
(
!
cpu_divisor_pref
)
{
cpu_divisor_pref
=
4
;
}
if
(
!
sNumCPUs
)
{
sNumCPUs
=
1
;
nsCOMPtr
<
nsIThread
>
thread
=
do_GetCurrentThread
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
cpucount
getter
"
[
thread
]
(
)
{
ProcessInfo
processInfo
=
{
}
;
if
(
NS_SUCCEEDED
(
CollectProcessInfo
(
processInfo
)
)
)
{
uint32_t
num_cpus
=
processInfo
.
cpuCount
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
"
IdleSchedulerParent
:
:
CalculateNumIdleTasks
"
[
num_cpus
]
(
)
{
sNumCPUs
=
num_cpus
;
CalculateNumIdleTasks
(
)
;
}
)
;
if
(
MOZ_LIKELY
(
!
gXPCOMThreadsShutDown
)
)
{
thread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
;
}
}
}
)
;
NS_DispatchBackgroundTask
(
runnable
.
forget
(
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
}
if
(
sPrefConcurrentGCsMax
!
=
max_gcs_pref
|
|
sPrefConcurrentGCsCPUDivisor
!
=
cpu_divisor_pref
)
{
sPrefConcurrentGCsMax
=
max_gcs_pref
;
sPrefConcurrentGCsCPUDivisor
=
cpu_divisor_pref
;
CalculateNumIdleTasks
(
)
;
}
}
void
IdleSchedulerParent
:
:
CalculateNumIdleTasks
(
)
{
MOZ_ASSERT
(
sNumCPUs
)
;
MOZ_ASSERT
(
sPrefConcurrentGCsMax
)
;
MOZ_ASSERT
(
sPrefConcurrentGCsCPUDivisor
)
;
sMaxConcurrentIdleTasksInChildProcesses
=
int32_t
(
std
:
:
max
(
sNumCPUs
1u
)
)
;
sMaxConcurrentGCs
=
std
:
:
min
(
std
:
:
max
(
sNumCPUs
/
sPrefConcurrentGCsCPUDivisor
1u
)
sPrefConcurrentGCsMax
)
;
if
(
sActiveChildCounter
&
&
sActiveChildCounter
-
>
memory
(
)
)
{
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
=
static_cast
<
int32_t
>
(
sMaxConcurrentIdleTasksInChildProcesses
)
;
}
IdleSchedulerParent
:
:
Schedule
(
nullptr
)
;
}
IdleSchedulerParent
:
:
~
IdleSchedulerParent
(
)
{
if
(
mChildId
)
{
sInUseChildCounters
[
mChildId
]
=
false
;
if
(
sActiveChildCounter
&
&
sActiveChildCounter
-
>
memory
(
)
&
&
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
mChildId
]
)
{
-
-
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
;
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
mChildId
]
=
0
;
}
}
if
(
mRunningPrioritizedOperation
)
{
-
-
sChildProcessesRunningPrioritizedOperation
;
}
if
(
mDoingGC
)
{
sActiveGCs
-
-
;
}
if
(
mRequestingGC
)
{
mRequestingGC
.
value
(
)
(
false
)
;
mRequestingGC
=
Nothing
(
)
;
}
if
(
isInList
(
)
)
{
remove
(
)
;
}
MOZ_ASSERT
(
sChildProcessesAlive
>
0
)
;
sChildProcessesAlive
-
-
;
if
(
sChildProcessesAlive
=
=
0
)
{
MOZ_ASSERT
(
sIdleAndGCRequests
.
isEmpty
(
)
)
;
delete
sActiveChildCounter
;
sActiveChildCounter
=
nullptr
;
if
(
sStarvationPreventer
)
{
sStarvationPreventer
-
>
Cancel
(
)
;
NS_RELEASE
(
sStarvationPreventer
)
;
}
}
Schedule
(
nullptr
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvInitForIdleUse
(
InitForIdleUseResolver
&
&
aResolve
)
{
MOZ_ASSERT
(
sChildProcessesAlive
>
0
)
;
MOZ_ASSERT
(
IsNotDoingIdleTask
(
)
)
;
if
(
!
sActiveChildCounter
)
{
sActiveChildCounter
=
new
base
:
:
SharedMemory
(
)
;
size_t
shmemSize
=
NS_IDLE_SCHEDULER_COUNTER_ARRAY_LENGHT
*
sizeof
(
int32_t
)
;
if
(
sActiveChildCounter
-
>
Create
(
shmemSize
)
&
&
sActiveChildCounter
-
>
Map
(
shmemSize
)
)
{
memset
(
sActiveChildCounter
-
>
memory
(
)
0
shmemSize
)
;
sInUseChildCounters
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
=
true
;
sInUseChildCounters
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
=
true
;
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_CPU_COUNTER
]
=
static_cast
<
int32_t
>
(
sMaxConcurrentIdleTasksInChildProcesses
)
;
}
else
{
delete
sActiveChildCounter
;
sActiveChildCounter
=
nullptr
;
}
}
Maybe
<
SharedMemoryHandle
>
activeCounter
;
if
(
SharedMemoryHandle
handle
=
sActiveChildCounter
?
sActiveChildCounter
-
>
CloneHandle
(
)
:
nullptr
)
{
activeCounter
.
emplace
(
std
:
:
move
(
handle
)
)
;
}
uint32_t
unusedId
=
0
;
for
(
uint32_t
i
=
0
;
i
<
NS_IDLE_SCHEDULER_COUNTER_ARRAY_LENGHT
;
+
+
i
)
{
if
(
!
sInUseChildCounters
[
i
]
)
{
sInUseChildCounters
[
i
]
=
true
;
unusedId
=
i
;
break
;
}
}
mChildId
=
unusedId
;
aResolve
(
Tuple
<
mozilla
:
:
Maybe
<
SharedMemoryHandle
>
&
&
const
uint32_t
&
>
(
std
:
:
move
(
activeCounter
)
mChildId
)
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvRequestIdleTime
(
uint64_t
aId
TimeDuration
aBudget
)
{
MOZ_ASSERT
(
aBudget
)
;
MOZ_ASSERT
(
IsNotDoingIdleTask
(
)
)
;
mCurrentRequestId
=
aId
;
mRequestedIdleBudget
=
aBudget
;
if
(
!
isInList
(
)
)
{
sIdleAndGCRequests
.
insertBack
(
this
)
;
}
Schedule
(
this
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvIdleTimeUsed
(
uint64_t
aId
)
{
MOZ_ASSERT
(
IsWaitingForIdle
(
)
|
|
IsDoingIdleTask
(
)
)
;
MOZ_ASSERT
(
mCurrentRequestId
=
=
aId
)
;
if
(
IsWaitingForIdle
(
)
&
&
!
mRequestingGC
)
{
remove
(
)
;
}
mRequestedIdleBudget
=
TimeDuration
(
)
;
Schedule
(
nullptr
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvSchedule
(
)
{
Schedule
(
nullptr
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvRunningPrioritizedOperation
(
)
{
+
+
mRunningPrioritizedOperation
;
if
(
mRunningPrioritizedOperation
=
=
1
)
{
+
+
sChildProcessesRunningPrioritizedOperation
;
}
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvPrioritizedOperationDone
(
)
{
MOZ_ASSERT
(
mRunningPrioritizedOperation
)
;
-
-
mRunningPrioritizedOperation
;
if
(
mRunningPrioritizedOperation
=
=
0
)
{
-
-
sChildProcessesRunningPrioritizedOperation
;
Schedule
(
nullptr
)
;
}
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvRequestGC
(
RequestGCResolver
&
&
aResolver
)
{
MOZ_ASSERT
(
!
mDoingGC
)
;
MOZ_ASSERT
(
!
mRequestingGC
)
;
mRequestingGC
=
Some
(
aResolver
)
;
if
(
!
isInList
(
)
)
{
sIdleAndGCRequests
.
insertBack
(
this
)
;
}
sRecordGCTelemetry
=
true
;
sNumWaitingGC
+
+
;
Schedule
(
nullptr
)
;
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvStartedGC
(
)
{
if
(
mDoingGC
)
{
return
IPC_OK
(
)
;
}
mDoingGC
=
true
;
sActiveGCs
+
+
;
if
(
mRequestingGC
)
{
sNumWaitingGC
-
-
;
mRequestingGC
.
value
(
)
(
true
)
;
mRequestingGC
=
Nothing
(
)
;
if
(
!
IsWaitingForIdle
(
)
)
{
remove
(
)
;
}
sRecordGCTelemetry
=
true
;
}
return
IPC_OK
(
)
;
}
IPCResult
IdleSchedulerParent
:
:
RecvDoneGC
(
)
{
MOZ_ASSERT
(
mDoingGC
)
;
sActiveGCs
-
-
;
mDoingGC
=
false
;
sRecordGCTelemetry
=
true
;
Schedule
(
nullptr
)
;
return
IPC_OK
(
)
;
}
int32_t
IdleSchedulerParent
:
:
ActiveCount
(
)
{
if
(
sActiveChildCounter
)
{
return
(
static_cast
<
Atomic
<
int32_t
>
*
>
(
sActiveChildCounter
-
>
memory
(
)
)
[
NS_IDLE_SCHEDULER_INDEX_OF_ACTIVITY_COUNTER
]
)
;
}
return
0
;
}
bool
IdleSchedulerParent
:
:
HasSpareCycles
(
int32_t
aActiveCount
)
{
MOZ_ASSERT
(
sMaxConcurrentIdleTasksInChildProcesses
>
0
)
;
return
sChildProcessesRunningPrioritizedOperation
?
sMaxConcurrentIdleTasksInChildProcesses
/
2
>
aActiveCount
:
sMaxConcurrentIdleTasksInChildProcesses
>
aActiveCount
;
}
bool
IdleSchedulerParent
:
:
HasSpareGCCycles
(
)
{
return
sMaxConcurrentGCs
>
sActiveGCs
;
}
void
IdleSchedulerParent
:
:
SendIdleTime
(
)
{
MOZ_ASSERT
(
mRequestedIdleBudget
)
;
Unused
<
<
SendIdleTime
(
mCurrentRequestId
mRequestedIdleBudget
)
;
}
void
IdleSchedulerParent
:
:
SendMayGC
(
)
{
MOZ_ASSERT
(
mRequestingGC
)
;
mRequestingGC
.
value
(
)
(
true
)
;
mRequestingGC
=
Nothing
(
)
;
mDoingGC
=
true
;
sActiveGCs
+
+
;
sRecordGCTelemetry
=
true
;
MOZ_ASSERT
(
sNumWaitingGC
>
0
)
;
sNumWaitingGC
-
-
;
}
void
IdleSchedulerParent
:
:
Schedule
(
IdleSchedulerParent
*
aRequester
)
{
int32_t
activeCount
=
ActiveCount
(
)
;
if
(
aRequester
&
&
aRequester
-
>
mRunningPrioritizedOperation
)
{
MOZ_ASSERT
(
aRequester
-
>
IsWaitingForIdle
(
)
)
;
if
(
aRequester
-
>
isInList
(
)
&
&
!
aRequester
-
>
mRequestingGC
)
{
aRequester
-
>
remove
(
)
;
}
aRequester
-
>
SendIdleTime
(
)
;
activeCount
+
+
;
}
RefPtr
<
IdleSchedulerParent
>
idleRequester
=
sIdleAndGCRequests
.
getFirst
(
)
;
bool
has_spare_cycles
=
HasSpareCycles
(
activeCount
)
;
bool
has_spare_gc_cycles
=
HasSpareGCCycles
(
)
;
while
(
idleRequester
&
&
(
has_spare_cycles
|
|
has_spare_gc_cycles
)
)
{
RefPtr
<
IdleSchedulerParent
>
next
=
idleRequester
-
>
getNext
(
)
;
if
(
has_spare_cycles
&
&
idleRequester
-
>
IsWaitingForIdle
(
)
)
{
activeCount
+
+
;
if
(
!
idleRequester
-
>
mRequestingGC
)
{
idleRequester
-
>
remove
(
)
;
}
idleRequester
-
>
SendIdleTime
(
)
;
has_spare_cycles
=
HasSpareCycles
(
activeCount
)
;
}
if
(
has_spare_gc_cycles
&
&
idleRequester
-
>
mRequestingGC
)
{
if
(
!
idleRequester
-
>
IsWaitingForIdle
(
)
)
{
idleRequester
-
>
remove
(
)
;
}
idleRequester
-
>
SendMayGC
(
)
;
has_spare_gc_cycles
=
HasSpareGCCycles
(
)
;
}
idleRequester
=
next
;
}
if
(
!
sIdleAndGCRequests
.
isEmpty
(
)
&
&
HasSpareCycles
(
activeCount
)
)
{
EnsureStarvationTimer
(
)
;
}
if
(
sRecordGCTelemetry
)
{
sRecordGCTelemetry
=
false
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
GC_WAIT_FOR_IDLE_COUNT
sNumWaitingGC
)
;
}
}
void
IdleSchedulerParent
:
:
EnsureStarvationTimer
(
)
{
if
(
!
sStarvationPreventer
)
{
NS_NewTimerWithFuncCallback
(
&
sStarvationPreventer
StarvationCallback
nullptr
StaticPrefs
:
:
page_load_deprioritization_period
(
)
nsITimer
:
:
TYPE_ONE_SHOT_LOW_PRIORITY
"
StarvationCallback
"
)
;
}
}
void
IdleSchedulerParent
:
:
StarvationCallback
(
nsITimer
*
aTimer
void
*
aData
)
{
RefPtr
<
IdleSchedulerParent
>
idleRequester
=
sIdleAndGCRequests
.
getFirst
(
)
;
while
(
idleRequester
)
{
if
(
idleRequester
-
>
IsWaitingForIdle
(
)
)
{
+
+
idleRequester
-
>
mRunningPrioritizedOperation
;
+
+
sChildProcessesRunningPrioritizedOperation
;
Schedule
(
idleRequester
)
;
-
-
idleRequester
-
>
mRunningPrioritizedOperation
;
-
-
sChildProcessesRunningPrioritizedOperation
;
break
;
}
idleRequester
=
idleRequester
-
>
getNext
(
)
;
}
NS_RELEASE
(
sStarvationPreventer
)
;
}
}
