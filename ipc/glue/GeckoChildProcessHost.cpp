#
include
"
GeckoChildProcessHost
.
h
"
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
chrome
/
common
/
process_watcher
.
h
"
#
ifdef
MOZ_WIDGET_COCOA
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
base
/
rand_util
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
SharedMemoryBasic
.
h
"
#
endif
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
endif
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
ipc
/
EnvironmentMap
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
"
mozilla
/
RDDProcessHost
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SharedThreadPool
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
ProtocolUtils
.
h
"
#
include
<
sys
/
stat
.
h
>
#
ifdef
XP_WIN
#
include
"
nsIWinTaskbar
.
h
"
#
include
<
stdlib
.
h
>
#
define
NS_TASKBAR_CONTRACTID
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
sandboxing
/
sandboxLogging
.
h
"
#
include
"
WinUtils
.
h
"
#
if
defined
(
_ARM64_
)
#
include
"
mozilla
/
remoteSandboxBroker
.
h
"
#
endif
#
endif
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
endif
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
GMPProcessParent
.
h
"
#
include
"
nsMacUtilsImpl
.
h
"
#
endif
#
include
"
nsTArray
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
private
/
pprio
.
h
"
using
mozilla
:
:
MonitorAutoLock
;
using
mozilla
:
:
Preferences
;
using
mozilla
:
:
StaticMutexAutoLock
;
namespace
mozilla
{
MOZ_TYPE_SPECIFIC_SCOPED_POINTER_TEMPLATE
(
ScopedPRFileDesc
PRFileDesc
PR_Close
)
}
using
mozilla
:
:
ScopedPRFileDesc
;
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidBridge
.
h
"
#
include
"
GeneratedJNIWrappers
.
h
"
#
include
"
mozilla
/
jni
/
Refs
.
h
"
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
static
bool
ShouldHaveDirectoryService
(
)
{
return
GeckoProcessType_Default
=
=
XRE_GetProcessType
(
)
;
}
namespace
mozilla
{
namespace
ipc
{
static
Atomic
<
int32_t
>
gChildCounter
;
class
BaseProcessLauncher
{
public
:
BaseProcessLauncher
(
GeckoChildProcessHost
*
aHost
std
:
:
vector
<
std
:
:
string
>
&
&
aExtraOpts
)
:
mProcessType
(
aHost
-
>
mProcessType
)
mLaunchOptions
(
std
:
:
move
(
aHost
-
>
mLaunchOptions
)
)
mExtraOpts
(
std
:
:
move
(
aExtraOpts
)
)
#
ifdef
XP_WIN
mGroupId
(
aHost
-
>
mGroupId
)
#
endif
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
mAllowedFilesRead
(
aHost
-
>
mAllowedFilesRead
)
mSandboxLevel
(
aHost
-
>
mSandboxLevel
)
mIsFileContent
(
aHost
-
>
mIsFileContent
)
mEnableSandboxLogging
(
aHost
-
>
mEnableSandboxLogging
)
#
endif
mTmpDirName
(
aHost
-
>
mTmpDirName
)
mChildId
(
+
+
gChildCounter
)
{
SprintfLiteral
(
mPidString
"
%
d
"
base
:
:
GetCurrentProcId
(
)
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
BaseProcessLauncher
)
;
RefPtr
<
ProcessLaunchPromise
>
Launch
(
GeckoChildProcessHost
*
)
;
protected
:
virtual
~
BaseProcessLauncher
(
)
=
default
;
RefPtr
<
ProcessLaunchPromise
>
PerformAsyncLaunch
(
)
;
static
BinPathType
GetPathToBinary
(
FilePath
&
GeckoProcessType
)
;
void
GetChildLogName
(
const
char
*
origLogName
nsACString
&
buffer
)
;
const
char
*
ChildProcessType
(
)
{
return
XRE_ChildProcessTypeToString
(
mProcessType
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
LaunchAndroidService
(
const
char
*
type
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
base
:
:
file_handle_mapping_vector
&
fds_to_remap
base
:
:
ProcessHandle
*
process_handle
)
;
#
endif
GeckoProcessType
mProcessType
;
UniquePtr
<
base
:
:
LaunchOptions
>
mLaunchOptions
;
std
:
:
vector
<
std
:
:
string
>
mExtraOpts
;
#
ifdef
XP_WIN
nsString
mGroupId
;
#
endif
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
std
:
:
vector
<
std
:
:
wstring
>
mAllowedFilesRead
;
int32_t
mSandboxLevel
;
bool
mIsFileContent
;
bool
mEnableSandboxLogging
;
#
endif
nsCString
mTmpDirName
;
LaunchResults
mResults
=
LaunchResults
(
)
;
int32_t
mChildId
;
TimeStamp
mStartTimeStamp
=
TimeStamp
:
:
Now
(
)
;
char
mPidString
[
32
]
;
IPC
:
:
Channel
*
mChannel
=
nullptr
;
std
:
:
wstring
mChannelId
;
ScopedPRFileDesc
mCrashAnnotationReadPipe
;
ScopedPRFileDesc
mCrashAnnotationWritePipe
;
}
;
#
ifdef
XP_WIN
class
WindowsProcessLauncher
:
public
BaseProcessLauncher
{
public
:
WindowsProcessLauncher
(
GeckoChildProcessHost
*
aHost
std
:
:
vector
<
std
:
:
string
>
&
&
aExtraOpts
)
:
BaseProcessLauncher
(
aHost
std
:
:
move
(
aExtraOpts
)
)
{
}
}
;
typedef
WindowsProcessLauncher
ProcessLauncher
;
#
endif
#
ifdef
OS_POSIX
class
PosixProcessLauncher
:
public
BaseProcessLauncher
{
public
:
PosixProcessLauncher
(
GeckoChildProcessHost
*
aHost
std
:
:
vector
<
std
:
:
string
>
&
&
aExtraOpts
)
:
BaseProcessLauncher
(
aHost
std
:
:
move
(
aExtraOpts
)
)
{
}
}
;
#
if
defined
(
XP_MACOSX
)
class
MacProcessLauncher
:
public
PosixProcessLauncher
{
public
:
MacProcessLauncher
(
GeckoChildProcessHost
*
aHost
std
:
:
vector
<
std
:
:
string
>
&
&
aExtraOpts
)
:
PosixProcessLauncher
(
aHost
std
:
:
move
(
aExtraOpts
)
)
{
}
}
;
typedef
MacProcessLauncher
ProcessLauncher
;
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
class
AndroidProcessLauncher
:
public
PosixProcessLauncher
{
public
:
AndroidProcessLauncher
(
GeckoChildProcessHost
*
aHost
std
:
:
vector
<
std
:
:
string
>
&
&
aExtraOpts
)
:
PosixProcessLauncher
(
aHost
std
:
:
move
(
aExtraOpts
)
)
{
}
}
;
typedef
AndroidProcessLauncher
ProcessLauncher
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
class
LinuxProcessLauncher
:
public
PosixProcessLauncher
{
public
:
LinuxProcessLauncher
(
GeckoChildProcessHost
*
aHost
std
:
:
vector
<
std
:
:
string
>
&
&
aExtraOpts
)
:
PosixProcessLauncher
(
aHost
std
:
:
move
(
aExtraOpts
)
)
{
}
}
;
typedef
LinuxProcessLauncher
ProcessLauncher
;
#
elif
#
error
"
Unknown
platform
"
#
endif
#
endif
using
mozilla
:
:
ipc
:
:
BaseProcessLauncher
;
using
mozilla
:
:
ipc
:
:
ProcessLauncher
;
mozilla
:
:
StaticAutoPtr
<
mozilla
:
:
LinkedList
<
GeckoChildProcessHost
>
>
GeckoChildProcessHost
:
:
sGeckoChildProcessHosts
;
mozilla
:
:
StaticMutex
GeckoChildProcessHost
:
:
sMutex
;
GeckoChildProcessHost
:
:
GeckoChildProcessHost
(
GeckoProcessType
aProcessType
bool
aIsFileContent
)
:
mProcessType
(
aProcessType
)
mIsFileContent
(
aIsFileContent
)
mMonitor
(
"
mozilla
.
ipc
.
GeckChildProcessHost
.
mMonitor
"
)
mLaunchOptions
(
MakeUnique
<
base
:
:
LaunchOptions
>
(
)
)
mProcessState
(
CREATING_CHANNEL
)
#
ifdef
XP_WIN
mGroupId
(
u
"
-
"
)
#
endif
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
mEnableSandboxLogging
(
false
)
mSandboxLevel
(
0
)
#
endif
mChildProcessHandle
(
0
)
#
if
defined
(
MOZ_WIDGET_COCOA
)
mChildTask
(
MACH_PORT_NULL
)
#
endif
mDestroying
(
false
)
{
MOZ_COUNT_CTOR
(
GeckoChildProcessHost
)
;
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
!
sGeckoChildProcessHosts
)
{
sGeckoChildProcessHosts
=
new
mozilla
:
:
LinkedList
<
GeckoChildProcessHost
>
(
)
;
}
sGeckoChildProcessHosts
-
>
insertBack
(
this
)
;
}
GeckoChildProcessHost
:
:
~
GeckoChildProcessHost
(
)
{
AssertIOThread
(
)
;
MOZ_RELEASE_ASSERT
(
mDestroying
)
;
MOZ_COUNT_DTOR
(
GeckoChildProcessHost
)
;
if
(
mChildProcessHandle
!
=
0
)
{
#
if
defined
(
MOZ_WIDGET_COCOA
)
SharedMemoryBasic
:
:
CleanupForPid
(
mChildProcessHandle
)
;
#
endif
ProcessWatcher
:
:
EnsureProcessTerminated
(
mChildProcessHandle
#
ifdef
NS_FREE_PERMANENT_DATA
false
#
endif
)
;
}
#
if
defined
(
MOZ_WIDGET_COCOA
)
if
(
mChildTask
!
=
MACH_PORT_NULL
)
mach_port_deallocate
(
mach_task_self
(
)
mChildTask
)
;
#
endif
if
(
mChildProcessHandle
!
=
0
)
{
#
if
defined
(
XP_WIN
)
CrashReporter
:
:
DeregisterChildCrashAnnotationFileDescriptor
(
base
:
:
GetProcId
(
mChildProcessHandle
)
)
;
#
else
CrashReporter
:
:
DeregisterChildCrashAnnotationFileDescriptor
(
mChildProcessHandle
)
;
#
endif
}
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
if
(
mSandboxBroker
)
{
mSandboxBroker
-
>
Shutdown
(
)
;
mSandboxBroker
=
nullptr
;
}
#
endif
}
void
GeckoChildProcessHost
:
:
RemoveFromProcessList
(
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
if
(
!
sGeckoChildProcessHosts
)
{
return
;
}
LinkedListElement
<
GeckoChildProcessHost
>
:
:
removeFrom
(
*
sGeckoChildProcessHosts
)
;
}
void
GeckoChildProcessHost
:
:
Destroy
(
)
{
MOZ_RELEASE_ASSERT
(
!
mDestroying
)
;
RemoveFromProcessList
(
)
;
RefPtr
<
ProcessHandlePromise
>
whenReady
=
mHandlePromise
;
if
(
!
whenReady
)
{
whenReady
=
ProcessHandlePromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
using
Value
=
ProcessHandlePromise
:
:
ResolveOrRejectValue
;
mDestroying
=
true
;
whenReady
-
>
Then
(
XRE_GetIOMessageLoop
(
)
-
>
SerialEventTarget
(
)
__func__
[
this
]
(
const
Value
&
)
{
delete
this
;
}
)
;
}
mozilla
:
:
BinPathType
BaseProcessLauncher
:
:
GetPathToBinary
(
FilePath
&
exePath
GeckoProcessType
processType
)
{
BinPathType
pathType
=
XRE_GetChildProcBinPathType
(
processType
)
;
if
(
pathType
=
=
BinPathType
:
:
Self
)
{
#
if
defined
(
OS_WIN
)
wchar_t
exePathBuf
[
MAXPATHLEN
]
;
if
(
!
:
:
GetModuleFileNameW
(
nullptr
exePathBuf
MAXPATHLEN
)
)
{
MOZ_CRASH
(
"
GetModuleFileNameW
failed
(
FIXME
)
"
)
;
}
#
if
defined
(
MOZ_SANDBOX
)
std
:
:
wstring
exePathStr
=
exePathBuf
;
if
(
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
exePathStr
)
)
{
exePath
=
FilePath
:
:
FromWStringHack
(
exePathStr
)
;
}
else
#
endif
{
exePath
=
FilePath
:
:
FromWStringHack
(
exePathBuf
)
;
}
#
elif
defined
(
OS_POSIX
)
exePath
=
FilePath
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
;
#
else
#
error
Sorry
;
target
OS
not
supported
yet
.
#
endif
return
pathType
;
}
if
(
ShouldHaveDirectoryService
(
)
)
{
MOZ_ASSERT
(
gGREBinPath
)
;
#
ifdef
OS_WIN
exePath
=
FilePath
(
char16ptr_t
(
gGREBinPath
)
)
;
#
elif
MOZ_WIDGET_COCOA
nsCOMPtr
<
nsIFile
>
childProcPath
;
NS_NewLocalFile
(
nsDependentString
(
gGREBinPath
)
false
getter_AddRefs
(
childProcPath
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
plugin
-
container
.
app
"
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
Contents
"
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
MacOS
"
)
)
;
nsCString
tempCPath
;
childProcPath
-
>
GetNativePath
(
tempCPath
)
;
exePath
=
FilePath
(
tempCPath
.
get
(
)
)
;
#
else
nsCString
path
;
NS_CopyUnicodeToNative
(
nsDependentString
(
gGREBinPath
)
path
)
;
exePath
=
FilePath
(
path
.
get
(
)
)
;
#
endif
}
if
(
exePath
.
empty
(
)
)
{
#
ifdef
OS_WIN
exePath
=
FilePath
:
:
FromWStringHack
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
program
(
)
)
;
#
else
exePath
=
FilePath
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
;
#
endif
exePath
=
exePath
.
DirName
(
)
;
}
exePath
=
exePath
.
AppendASCII
(
MOZ_CHILD_PROCESS_NAME
)
;
return
pathType
;
}
#
ifdef
MOZ_WIDGET_COCOA
class
AutoCFTypeObject
{
public
:
explicit
AutoCFTypeObject
(
CFTypeRef
object
)
{
mObject
=
object
;
}
~
AutoCFTypeObject
(
)
{
:
:
CFRelease
(
mObject
)
;
}
private
:
CFTypeRef
mObject
;
}
;
#
endif
uint32_t
GeckoChildProcessHost
:
:
sNextUniqueID
=
1
;
uint32_t
GeckoChildProcessHost
:
:
GetUniqueID
(
)
{
return
sNextUniqueID
+
+
;
}
void
GeckoChildProcessHost
:
:
PrepareLaunch
(
)
{
if
(
CrashReporter
:
:
GetEnabled
(
)
)
{
CrashReporter
:
:
OOPInit
(
)
;
}
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
SandboxLaunchPrepare
(
mProcessType
mLaunchOptions
.
get
(
)
)
;
#
endif
#
ifdef
XP_WIN
if
(
mProcessType
=
=
GeckoProcessType_Plugin
)
{
InitWindowsGroupID
(
)
;
}
#
if
defined
(
MOZ_SANDBOX
)
if
(
mProcessType
=
=
GeckoProcessType_Content
)
{
mSandboxLevel
=
GetEffectiveContentSandboxLevel
(
)
;
mEnableSandboxLogging
=
Preferences
:
:
GetBool
(
"
security
.
sandbox
.
logging
.
enabled
"
)
;
nsAutoString
readPaths
;
nsresult
rv
=
Preferences
:
:
GetString
(
"
security
.
sandbox
.
content
.
read_path_whitelist
"
readPaths
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
const
nsAString
&
readPath
:
readPaths
.
Split
(
'
'
)
)
{
nsString
trimmedPath
(
readPath
)
;
trimmedPath
.
Trim
(
"
"
true
true
)
;
std
:
:
wstring
resolvedPath
(
trimmedPath
.
Data
(
)
)
;
bool
addWildcard
=
(
resolvedPath
.
back
(
)
=
=
L
'
\
\
'
)
;
if
(
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
resolvedPath
)
)
{
NS_ERROR
(
"
Failed
to
resolve
test
read
policy
rule
.
"
)
;
continue
;
}
if
(
addWildcard
)
{
resolvedPath
.
append
(
L
"
\
\
*
"
)
;
}
mAllowedFilesRead
.
push_back
(
resolvedPath
)
;
}
}
}
#
endif
#
if
defined
(
MOZ_SANDBOX
)
mEnableSandboxLogging
=
mEnableSandboxLogging
|
|
!
!
PR_GetEnv
(
"
MOZ_SANDBOX_LOGGING
"
)
;
#
endif
#
elif
defined
(
XP_LINUX
)
#
if
defined
(
MOZ_SANDBOX
)
if
(
ShouldHaveDirectoryService
(
)
)
{
nsCOMPtr
<
nsIFile
>
contentTempDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_CONTENT_PROCESS_TEMP_DIR
getter_AddRefs
(
contentTempDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
contentTempDir
-
>
GetNativePath
(
mTmpDirName
)
;
}
}
#
endif
#
endif
}
#
ifdef
XP_WIN
void
GeckoChildProcessHost
:
:
InitWindowsGroupID
(
)
{
nsCOMPtr
<
nsIWinTaskbar
>
taskbarInfo
=
do_GetService
(
NS_TASKBAR_CONTRACTID
)
;
if
(
taskbarInfo
)
{
bool
isSupported
=
false
;
taskbarInfo
-
>
GetAvailable
(
&
isSupported
)
;
nsAutoString
appId
;
if
(
isSupported
&
&
NS_SUCCEEDED
(
taskbarInfo
-
>
GetDefaultGroupId
(
appId
)
)
)
{
MOZ_ASSERT
(
mGroupId
.
EqualsLiteral
(
"
-
"
)
)
;
mGroupId
.
Assign
(
appId
)
;
}
}
}
#
endif
bool
GeckoChildProcessHost
:
:
SyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
int
aTimeoutMs
)
{
if
(
!
AsyncLaunch
(
std
:
:
move
(
aExtraOpts
)
)
)
{
return
false
;
}
return
WaitUntilConnected
(
aTimeoutMs
)
;
}
static
inline
nsISerialEventTarget
*
IOThread
(
)
{
return
XRE_GetIOMessageLoop
(
)
-
>
SerialEventTarget
(
)
;
}
bool
GeckoChildProcessHost
:
:
AsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
)
{
PrepareLaunch
(
)
;
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
MOZ_SANDBOX
)
if
(
IsMacSandboxLaunchEnabled
(
)
&
&
!
AppendMacSandboxParams
(
aExtraOpts
)
)
{
return
false
;
}
#
endif
RefPtr
<
BaseProcessLauncher
>
launcher
=
new
ProcessLauncher
(
this
std
:
:
move
(
aExtraOpts
)
)
;
MOZ_ASSERT
(
mHandlePromise
=
=
nullptr
)
;
RefPtr
<
ProcessHandlePromise
:
:
Private
>
p
=
new
ProcessHandlePromise
:
:
Private
(
__func__
)
;
mHandlePromise
=
p
;
mozilla
:
:
InvokeAsync
<
GeckoChildProcessHost
*
>
(
IOThread
(
)
launcher
.
get
(
)
__func__
&
BaseProcessLauncher
:
:
Launch
this
)
-
>
Then
(
IOThread
(
)
__func__
[
this
p
]
(
const
LaunchResults
aResults
)
{
{
if
(
!
OpenPrivilegedHandle
(
base
:
:
GetProcId
(
aResults
.
mHandle
)
)
#
ifdef
XP_WIN
&
&
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
aResults
.
mHandle
:
:
GetCurrentProcess
(
)
&
mChildProcessHandle
PROCESS_DUP_HANDLE
|
PROCESS_TERMINATE
|
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
|
SYNCHRONIZE
FALSE
0
)
#
endif
)
{
MOZ_CRASH
(
"
cannot
open
handle
to
child
process
"
)
;
}
#
ifdef
XP_MACOSX
this
-
>
mChildTask
=
aResults
.
mChildTask
;
#
endif
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
this
-
>
mSandboxBroker
=
aResults
.
mSandboxBroker
;
#
endif
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mProcessState
<
PROCESS_CREATED
)
{
mProcessState
=
PROCESS_CREATED
;
}
lock
.
Notify
(
)
;
}
p
-
>
Resolve
(
aResults
.
mHandle
__func__
)
;
}
[
this
p
]
(
const
LaunchError
aError
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
Failed
to
launch
"
<
<
XRE_ChildProcessTypeToString
(
mProcessType
)
<
<
"
subprocess
"
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SUBPROCESS_LAUNCH_FAILURE
nsDependentCString
(
XRE_ChildProcessTypeToString
(
mProcessType
)
)
)
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_ERROR
;
lock
.
Notify
(
)
;
}
p
-
>
Reject
(
aError
__func__
)
;
}
)
;
return
true
;
}
bool
GeckoChildProcessHost
:
:
WaitUntilConnected
(
int32_t
aTimeoutMs
)
{
AUTO_PROFILER_LABEL
(
"
GeckoChildProcessHost
:
:
WaitUntilConnected
"
OTHER
)
;
TimeDuration
timeout
=
(
aTimeoutMs
>
0
)
?
TimeDuration
:
:
FromMilliseconds
(
aTimeoutMs
)
:
TimeDuration
:
:
Forever
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
TimeStamp
waitStart
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
current
;
while
(
mProcessState
!
=
PROCESS_CONNECTED
)
{
if
(
mProcessState
=
=
PROCESS_ERROR
)
{
break
;
}
CVStatus
status
=
lock
.
Wait
(
timeout
)
;
if
(
status
=
=
CVStatus
:
:
Timeout
)
{
break
;
}
if
(
timeout
!
=
TimeDuration
:
:
Forever
(
)
)
{
current
=
TimeStamp
:
:
Now
(
)
;
timeout
-
=
current
-
waitStart
;
waitStart
=
current
;
}
}
return
mProcessState
=
=
PROCESS_CONNECTED
;
}
bool
GeckoChildProcessHost
:
:
LaunchAndWaitForProcessHandle
(
StringVector
aExtraOpts
)
{
if
(
!
AsyncLaunch
(
std
:
:
move
(
aExtraOpts
)
)
)
{
return
false
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mProcessState
<
PROCESS_CREATED
)
{
lock
.
Wait
(
)
;
}
MOZ_ASSERT
(
mProcessState
=
=
PROCESS_ERROR
|
|
mChildProcessHandle
)
;
return
mProcessState
<
PROCESS_ERROR
;
}
void
GeckoChildProcessHost
:
:
InitializeChannel
(
)
{
CreateChannel
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
CHANNEL_INITIALIZED
;
lock
.
Notify
(
)
;
}
void
GeckoChildProcessHost
:
:
Join
(
)
{
AssertIOThread
(
)
;
if
(
!
mChildProcessHandle
)
{
return
;
}
base
:
:
KillProcess
(
mChildProcessHandle
0
true
)
;
SetAlreadyDead
(
)
;
}
void
GeckoChildProcessHost
:
:
SetAlreadyDead
(
)
{
if
(
mChildProcessHandle
&
&
mChildProcessHandle
!
=
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
mChildProcessHandle
)
;
}
mChildProcessHandle
=
0
;
}
void
BaseProcessLauncher
:
:
GetChildLogName
(
const
char
*
origLogName
nsACString
&
buffer
)
{
#
ifdef
XP_WIN
char
absPath
[
MAX_PATH
+
2
]
;
if
(
_fullpath
(
absPath
origLogName
sizeof
(
absPath
)
)
)
{
#
ifdef
MOZ_SANDBOX
std
:
:
wstring
resolvedPath
(
NS_ConvertUTF8toUTF16
(
absPath
)
.
get
(
)
)
;
if
(
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
resolvedPath
)
)
{
AppendUTF16toUTF8
(
MakeSpan
(
reinterpret_cast
<
const
char16_t
*
>
(
resolvedPath
.
data
(
)
)
resolvedPath
.
size
(
)
)
buffer
)
;
}
else
#
endif
{
buffer
.
Append
(
absPath
)
;
}
}
else
#
endif
{
buffer
.
Append
(
origLogName
)
;
}
buffer
.
AppendLiteral
(
"
.
child
-
"
)
;
buffer
.
AppendInt
(
gChildCounter
)
;
}
namespace
{
#
ifdef
XP_WIN
static
mozilla
:
:
StaticMutex
gIPCLaunchThreadMutex
;
static
mozilla
:
:
StaticRefPtr
<
nsIThread
>
gIPCLaunchThread
;
class
IPCLaunchThreadObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
protected
:
virtual
~
IPCLaunchThreadObserver
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
IPCLaunchThreadObserver
nsIObserver
nsISupports
)
NS_IMETHODIMP
IPCLaunchThreadObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_RELEASE_ASSERT
(
strcmp
(
aTopic
"
xpcom
-
shutdown
-
threads
"
)
=
=
0
)
;
StaticMutexAutoLock
lock
(
gIPCLaunchThreadMutex
)
;
nsresult
rv
=
NS_OK
;
if
(
gIPCLaunchThread
)
{
rv
=
gIPCLaunchThread
-
>
Shutdown
(
)
;
gIPCLaunchThread
=
nullptr
;
}
mozilla
:
:
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
static
nsCOMPtr
<
nsIEventTarget
>
GetIPCLauncher
(
)
{
StaticMutexAutoLock
lock
(
gIPCLaunchThreadMutex
)
;
if
(
!
gIPCLaunchThread
)
{
nsCOMPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
NS_LITERAL_CSTRING
(
"
IPC
Launch
"
)
getter_AddRefs
(
thread
)
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
GeckoChildProcessHost
:
:
GetIPCLauncher
"
[
]
{
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
nsCOMPtr
<
nsIObserver
>
obs
=
new
IPCLaunchThreadObserver
(
)
;
obsService
-
>
AddObserver
(
obs
"
xpcom
-
shutdown
-
threads
"
false
)
;
}
)
)
;
gIPCLaunchThread
=
thread
.
forget
(
)
;
}
}
nsCOMPtr
<
nsIEventTarget
>
thread
=
gIPCLaunchThread
.
get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
thread
)
;
return
thread
;
}
#
else
static
nsCOMPtr
<
nsIEventTarget
>
GetIPCLauncher
(
)
{
nsCOMPtr
<
nsIEventTarget
>
pool
=
mozilla
:
:
SharedThreadPool
:
:
Get
(
NS_LITERAL_CSTRING
(
"
IPC
Launch
"
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
pool
)
;
return
pool
;
}
#
endif
}
void
#
if
defined
(
XP_WIN
)
AddAppDirToCommandLine
(
CommandLine
&
aCmdLine
)
#
else
AddAppDirToCommandLine
(
std
:
:
vector
<
std
:
:
string
>
&
aCmdLine
)
#
endif
{
if
(
ShouldHaveDirectoryService
(
)
)
{
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
)
;
NS_ASSERTION
(
directoryService
"
Expected
XPCOM
to
be
available
"
)
;
if
(
directoryService
)
{
nsCOMPtr
<
nsIFile
>
appDir
;
nsresult
rv
=
directoryService
-
>
Get
(
NS_XPCOM_CURRENT_PROCESS_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
#
if
defined
(
XP_WIN
)
nsString
path
;
MOZ_ALWAYS_SUCCEEDS
(
appDir
-
>
GetPath
(
path
)
)
;
aCmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
appdir
"
)
)
;
std
:
:
wstring
wpath
(
path
.
get
(
)
)
;
aCmdLine
.
AppendLooseValue
(
wpath
)
;
#
else
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
appDir
-
>
GetNativePath
(
path
)
)
;
aCmdLine
.
push_back
(
"
-
appdir
"
)
;
aCmdLine
.
push_back
(
path
.
get
(
)
)
;
#
endif
}
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
MOZ_SANDBOX
)
nsCOMPtr
<
nsIFile
>
profileDir
;
rv
=
directoryService
-
>
Get
(
NS_APP_USER_PROFILE_50_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
profileDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mozilla
:
:
Unused
<
<
profileDir
-
>
Normalize
(
)
;
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
profileDir
-
>
GetNativePath
(
path
)
)
;
aCmdLine
.
push_back
(
"
-
profile
"
)
;
aCmdLine
.
push_back
(
path
.
get
(
)
)
;
}
#
endif
}
}
}
#
if
defined
(
XP_WIN
)
&
&
(
defined
(
MOZ_SANDBOX
)
|
|
defined
(
_ARM64_
)
)
static
bool
Contains
(
const
std
:
:
vector
<
std
:
:
string
>
&
aExtraOpts
const
char
*
aValue
)
{
return
std
:
:
any_of
(
aExtraOpts
.
begin
(
)
aExtraOpts
.
end
(
)
[
&
]
(
const
std
:
:
string
arg
)
{
return
arg
.
find
(
aValue
)
!
=
std
:
:
string
:
:
npos
;
}
)
;
}
#
endif
RefPtr
<
ProcessLaunchPromise
>
BaseProcessLauncher
:
:
PerformAsyncLaunch
(
)
{
#
ifdef
MOZ_GECKO_PROFILER
RefPtr
<
BaseProcessLauncher
>
self
=
this
;
GetProfilerEnvVarsForChildProcess
(
[
self
]
(
const
char
*
key
const
char
*
value
)
{
self
-
>
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_STRING
(
key
)
]
=
ENVIRONMENT_STRING
(
value
)
;
}
)
;
#
endif
const
char
*
origNSPRLogName
=
PR_GetEnv
(
"
NSPR_LOG_FILE
"
)
;
const
char
*
origMozLogName
=
PR_GetEnv
(
"
MOZ_LOG_FILE
"
)
;
if
(
origNSPRLogName
)
{
nsAutoCString
nsprLogName
;
GetChildLogName
(
origNSPRLogName
nsprLogName
)
;
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
NSPR_LOG_FILE
"
)
]
=
ENVIRONMENT_STRING
(
nsprLogName
.
get
(
)
)
;
}
if
(
origMozLogName
)
{
nsAutoCString
mozLogName
;
GetChildLogName
(
origMozLogName
mozLogName
)
;
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
MOZ_LOG_FILE
"
)
]
=
ENVIRONMENT_STRING
(
mozLogName
.
get
(
)
)
;
}
nsAutoCString
childRustLog
(
PR_GetEnv
(
"
RUST_LOG_CHILD
"
)
)
;
if
(
!
childRustLog
.
IsEmpty
(
)
)
{
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
RUST_LOG
"
)
]
=
ENVIRONMENT_STRING
(
childRustLog
.
get
(
)
)
;
}
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
if
(
!
mTmpDirName
.
IsEmpty
(
)
)
{
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
TMPDIR
"
)
]
=
ENVIRONMENT_STRING
(
mTmpDirName
.
get
(
)
)
;
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
MESA_GLSL_CACHE_DIR
"
)
]
=
ENVIRONMENT_STRING
(
mTmpDirName
.
get
(
)
)
;
}
#
endif
if
(
PR_CreatePipe
(
&
mCrashAnnotationReadPipe
.
rwget
(
)
&
mCrashAnnotationWritePipe
.
rwget
(
)
)
!
=
PR_SUCCESS
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
#
if
defined
(
OS_POSIX
)
#
if
defined
(
OS_POSIX
)
#
if
defined
(
MOZ_WIDGET_GTK
)
if
(
mProcessType
=
=
GeckoProcessType_Content
)
{
mLaunchOptions
-
>
env_map
[
"
GTK_IM_MODULE
"
]
=
"
gtk
-
im
-
context
-
simple
"
;
mLaunchOptions
-
>
env_map
[
"
NO_AT_BRIDGE
"
]
=
"
1
"
;
}
#
endif
if
(
ShouldHaveDirectoryService
(
)
)
{
MOZ_ASSERT
(
gGREBinPath
)
;
nsCString
path
;
NS_CopyUnicodeToNative
(
nsDependentString
(
gGREBinPath
)
path
)
;
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_BSD
)
const
char
*
ld_library_path
=
PR_GetEnv
(
"
LD_LIBRARY_PATH
"
)
;
nsCString
new_ld_lib_path
(
path
.
get
(
)
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
mProcessType
=
=
GeckoProcessType_Plugin
)
{
new_ld_lib_path
.
AppendLiteral
(
"
/
gtk2
:
"
)
;
new_ld_lib_path
.
Append
(
path
.
get
(
)
)
;
}
#
endif
if
(
ld_library_path
&
&
*
ld_library_path
)
{
new_ld_lib_path
.
Append
(
'
:
'
)
;
new_ld_lib_path
.
Append
(
ld_library_path
)
;
}
mLaunchOptions
-
>
env_map
[
"
LD_LIBRARY_PATH
"
]
=
new_ld_lib_path
.
get
(
)
;
#
elif
OS_MACOSX
mLaunchOptions
-
>
env_map
[
"
DYLD_LIBRARY_PATH
"
]
=
path
.
get
(
)
;
const
char
*
prevInterpose
=
PR_GetEnv
(
"
DYLD_INSERT_LIBRARIES
"
)
;
nsCString
interpose
;
if
(
prevInterpose
&
&
strlen
(
prevInterpose
)
>
0
)
{
interpose
.
Assign
(
prevInterpose
)
;
interpose
.
Append
(
'
:
'
)
;
}
interpose
.
Append
(
path
.
get
(
)
)
;
interpose
.
AppendLiteral
(
"
/
libplugin_child_interpose
.
dylib
"
)
;
mLaunchOptions
-
>
env_map
[
"
DYLD_INSERT_LIBRARIES
"
]
=
interpose
.
get
(
)
;
#
endif
}
#
endif
FilePath
exePath
;
BinPathType
pathType
=
GetPathToBinary
(
exePath
mProcessType
)
;
int
srcChannelFd
dstChannelFd
;
mChannel
-
>
GetClientFileDescriptorMapping
(
&
srcChannelFd
&
dstChannelFd
)
;
mLaunchOptions
-
>
fds_to_remap
.
push_back
(
std
:
:
pair
<
int
int
>
(
srcChannelFd
dstChannelFd
)
)
;
std
:
:
vector
<
std
:
:
string
>
childArgv
;
childArgv
.
push_back
(
exePath
.
value
(
)
)
;
if
(
pathType
=
=
BinPathType
:
:
Self
)
{
childArgv
.
push_back
(
"
-
contentproc
"
)
;
}
childArgv
.
insert
(
childArgv
.
end
(
)
mExtraOpts
.
begin
(
)
mExtraOpts
.
end
(
)
)
;
if
(
mProcessType
!
=
GeckoProcessType_GMPlugin
)
{
if
(
Omnijar
:
:
IsInitialized
(
)
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIFile
>
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
GRE
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
childArgv
.
push_back
(
"
-
greomni
"
)
;
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
APP
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
childArgv
.
push_back
(
"
-
appomni
"
)
;
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
}
AddAppDirToCommandLine
(
childArgv
)
;
}
childArgv
.
push_back
(
mPidString
)
;
if
(
!
CrashReporter
:
:
IsDummy
(
)
)
{
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_BSD
)
|
|
defined
(
OS_SOLARIS
)
int
childCrashFd
childCrashRemapFd
;
if
(
!
CrashReporter
:
:
CreateNotificationPipeForChild
(
&
childCrashFd
&
childCrashRemapFd
)
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
if
(
0
<
=
childCrashFd
)
{
mLaunchOptions
-
>
fds_to_remap
.
push_back
(
std
:
:
pair
<
int
int
>
(
childCrashFd
childCrashRemapFd
)
)
;
childArgv
.
push_back
(
"
true
"
)
;
}
else
{
childArgv
.
push_back
(
"
false
"
)
;
}
#
elif
defined
(
MOZ_WIDGET_COCOA
)
childArgv
.
push_back
(
CrashReporter
:
:
GetChildNotificationPipe
(
)
)
;
#
endif
}
int
fd
=
PR_FileDesc2NativeHandle
(
mCrashAnnotationWritePipe
)
;
mLaunchOptions
-
>
fds_to_remap
.
push_back
(
std
:
:
make_pair
(
fd
CrashReporter
:
:
GetAnnotationTimeCrashFd
(
)
)
)
;
#
ifdef
MOZ_WIDGET_COCOA
std
:
:
string
mach_connection_name
=
StringPrintf
(
"
org
.
mozilla
.
machname
.
%
d
"
base
:
:
RandInt
(
0
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
)
;
childArgv
.
push_back
(
mach_connection_name
.
c_str
(
)
)
;
#
endif
childArgv
.
push_back
(
ChildProcessType
(
)
)
;
#
ifdef
MOZ_WIDGET_COCOA
ReceivePort
parent_recv_port
(
mach_connection_name
.
c_str
(
)
)
;
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
LaunchAndroidService
(
ChildProcessType
(
)
childArgv
mLaunchOptions
-
>
fds_to_remap
&
mResults
.
mHandle
)
;
if
(
mResults
.
mHandle
=
=
0
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
#
else
if
(
!
base
:
:
LaunchApp
(
childArgv
*
mLaunchOptions
&
mResults
.
mHandle
)
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
#
endif
mChannel
-
>
CloseClientFileDescriptor
(
)
;
#
ifdef
MOZ_WIDGET_COCOA
const
int
kTimeoutMs
=
10000
;
MachReceiveMessage
child_message
;
kern_return_t
err
=
parent_recv_port
.
WaitForMessage
(
&
child_message
kTimeoutMs
)
;
if
(
err
!
=
KERN_SUCCESS
)
{
std
:
:
string
errString
=
StringPrintf
(
"
0x
%
x
%
s
"
err
mach_error_string
(
err
)
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
WaitForMessage
(
)
failed
:
"
<
<
errString
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
task_t
child_task
=
child_message
.
GetTranslatedPort
(
0
)
;
if
(
child_task
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
0
)
failed
.
"
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
if
(
child_message
.
GetTranslatedPort
(
1
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
1
)
failed
.
"
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
MachPortSender
parent_sender
(
child_message
.
GetTranslatedPort
(
1
)
)
;
if
(
child_message
.
GetTranslatedPort
(
2
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
2
)
failed
.
"
;
}
auto
*
parent_recv_port_memory_ack
=
new
MachPortSender
(
child_message
.
GetTranslatedPort
(
2
)
)
;
if
(
child_message
.
GetTranslatedPort
(
3
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
3
)
failed
.
"
;
}
auto
*
parent_send_port_memory
=
new
MachPortSender
(
child_message
.
GetTranslatedPort
(
3
)
)
;
MachSendMessage
parent_message
(
0
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
bootstrap_port
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
bootstrap_port
<
<
"
)
failed
.
"
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
auto
*
parent_recv_port_memory
=
new
ReceivePort
(
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
parent_recv_port_memory
-
>
GetPort
(
)
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
parent_recv_port_memory
-
>
GetPort
(
)
<
<
"
)
failed
.
"
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
auto
*
parent_send_port_memory_ack
=
new
ReceivePort
(
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
parent_send_port_memory_ack
-
>
GetPort
(
)
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
parent_send_port_memory_ack
-
>
GetPort
(
)
<
<
"
)
failed
.
"
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
err
=
parent_sender
.
SendMessage
(
parent_message
kTimeoutMs
)
;
if
(
err
!
=
KERN_SUCCESS
)
{
std
:
:
string
errString
=
StringPrintf
(
"
0x
%
x
%
s
"
err
mach_error_string
(
err
)
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
SendMessage
(
)
failed
:
"
<
<
errString
;
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
SharedMemoryBasic
:
:
SetupMachMemory
(
mResults
.
mHandle
parent_recv_port_memory
parent_recv_port_memory_ack
parent_send_port_memory
parent_send_port_memory_ack
false
)
;
#
endif
#
elif
defined
(
OS_WIN
)
FilePath
exePath
;
BinPathType
pathType
=
GetPathToBinary
(
exePath
mProcessType
)
;
#
if
defined
(
MOZ_SANDBOX
)
|
|
defined
(
_ARM64_
)
const
bool
isGMP
=
mProcessType
=
=
GeckoProcessType_GMPlugin
;
const
bool
isWidevine
=
isGMP
&
&
Contains
(
mExtraOpts
"
gmp
-
widevinecdm
"
)
;
#
if
defined
(
_ARM64_
)
const
bool
isClearKey
=
isGMP
&
&
Contains
(
mExtraOpts
"
gmp
-
clearkey
"
)
;
const
bool
isSandboxBroker
=
mProcessType
=
=
GeckoProcessType_RemoteSandboxBroker
;
if
(
isClearKey
|
|
isWidevine
|
|
isSandboxBroker
)
{
exePath
=
exePath
.
DirName
(
)
.
AppendASCII
(
"
i686
"
)
.
Append
(
exePath
.
BaseName
(
)
)
;
}
#
endif
#
endif
CommandLine
cmdLine
(
exePath
.
ToWStringHack
(
)
)
;
if
(
pathType
=
=
BinPathType
:
:
Self
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
contentproc
"
)
)
;
}
cmdLine
.
AppendSwitchWithValue
(
switches
:
:
kProcessChannelID
mChannelId
)
;
for
(
std
:
:
vector
<
std
:
:
string
>
:
:
iterator
it
=
mExtraOpts
.
begin
(
)
;
it
!
=
mExtraOpts
.
end
(
)
;
+
+
it
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
*
it
)
)
;
}
if
(
Omnijar
:
:
IsInitialized
(
)
)
{
nsAutoString
path
;
nsCOMPtr
<
nsIFile
>
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
GRE
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetPath
(
path
)
)
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
greomni
"
)
)
;
cmdLine
.
AppendLooseValue
(
path
.
get
(
)
)
;
}
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
APP
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetPath
(
path
)
)
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
appomni
"
)
)
;
cmdLine
.
AppendLooseValue
(
path
.
get
(
)
)
;
}
}
#
if
defined
(
MOZ_SANDBOX
)
#
if
defined
(
_ARM64_
)
if
(
isClearKey
|
|
isWidevine
)
mResults
.
mSandboxBroker
=
new
RemoteSandboxBroker
(
)
;
else
#
endif
mResults
.
mSandboxBroker
=
new
SandboxBroker
(
)
;
bool
shouldSandboxCurrentProcess
=
false
;
switch
(
mProcessType
)
{
case
GeckoProcessType_Content
:
if
(
mSandboxLevel
>
0
)
{
mResults
.
mSandboxBroker
-
>
SetSecurityLevelForContentProcess
(
mSandboxLevel
mIsFileContent
)
;
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_Plugin
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_NPAPI_SANDBOX
"
)
)
{
bool
ok
=
mResults
.
mSandboxBroker
-
>
SetSecurityLevelForPluginProcess
(
mSandboxLevel
)
;
if
(
!
ok
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_IPDLUnitTest
:
break
;
case
GeckoProcessType_GMPlugin
:
if
(
!
PR_GetEnv
(
"
MOZ_DISABLE_GMP_SANDBOX
"
)
)
{
auto
level
=
isWidevine
?
SandboxBroker
:
:
Restricted
:
SandboxBroker
:
:
LockDown
;
bool
ok
=
mResults
.
mSandboxBroker
-
>
SetSecurityLevelForGMPlugin
(
level
)
;
if
(
!
ok
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_GPU
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_GPU_SANDBOX
"
)
)
{
mResults
.
mSandboxBroker
-
>
SetSecurityLevelForGPUProcess
(
mSandboxLevel
)
;
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_VR
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_VR_SANDBOX
"
)
)
{
}
break
;
case
GeckoProcessType_RDD
:
if
(
!
PR_GetEnv
(
"
MOZ_DISABLE_RDD_SANDBOX
"
)
)
{
if
(
!
mResults
.
mSandboxBroker
-
>
SetSecurityLevelForRDDProcess
(
)
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_Socket
:
break
;
case
GeckoProcessType_RemoteSandboxBroker
:
break
;
case
GeckoProcessType_Default
:
default
:
MOZ_CRASH
(
"
Bad
process
type
in
GeckoChildProcessHost
"
)
;
break
;
}
;
if
(
shouldSandboxCurrentProcess
)
{
for
(
auto
it
=
mAllowedFilesRead
.
begin
(
)
;
it
!
=
mAllowedFilesRead
.
end
(
)
;
+
+
it
)
{
mResults
.
mSandboxBroker
-
>
AllowReadFile
(
it
-
>
c_str
(
)
)
;
}
}
#
endif
AddAppDirToCommandLine
(
cmdLine
)
;
cmdLine
.
AppendLooseValue
(
mGroupId
.
get
(
)
)
;
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
mPidString
)
)
;
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
CrashReporter
:
:
GetChildNotificationPipe
(
)
)
)
;
if
(
!
CrashReporter
:
:
IsDummy
(
)
)
{
PROsfd
h
=
PR_FileDesc2NativeHandle
(
mCrashAnnotationWritePipe
)
;
mLaunchOptions
-
>
handles_to_inherit
.
push_back
(
reinterpret_cast
<
HANDLE
>
(
h
)
)
;
std
:
:
string
hStr
=
std
:
:
to_string
(
h
)
;
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
hStr
)
)
;
}
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
ChildProcessType
(
)
)
)
;
#
if
defined
(
MOZ_SANDBOX
)
if
(
shouldSandboxCurrentProcess
)
{
for
(
HANDLE
h
:
mLaunchOptions
-
>
handles_to_inherit
)
{
mResults
.
mSandboxBroker
-
>
AddHandleToShare
(
h
)
;
}
if
(
mResults
.
mSandboxBroker
-
>
LaunchApp
(
cmdLine
.
program
(
)
.
c_str
(
)
cmdLine
.
command_line_string
(
)
.
c_str
(
)
mLaunchOptions
-
>
env_map
mProcessType
mEnableSandboxLogging
&
mResults
.
mHandle
)
)
{
EnvironmentLog
(
"
MOZ_PROCESS_LOG
"
)
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
(
%
S
)
\
n
"
base
:
:
GetCurrentProcId
(
)
base
:
:
GetProcId
(
mResults
.
mHandle
)
cmdLine
.
command_line_string
(
)
.
c_str
(
)
)
;
}
else
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
}
else
#
endif
{
if
(
!
base
:
:
LaunchApp
(
cmdLine
*
mLaunchOptions
&
mResults
.
mHandle
)
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
#
ifdef
MOZ_SANDBOX
switch
(
mProcessType
)
{
case
GeckoProcessType_Default
:
MOZ_CRASH
(
"
shouldn
'
t
be
launching
a
parent
process
"
)
;
case
GeckoProcessType_Plugin
:
case
GeckoProcessType_IPDLUnitTest
:
break
;
default
:
if
(
!
SandboxBroker
:
:
AddTargetPeer
(
mResults
.
mHandle
)
)
{
NS_WARNING
(
"
Failed
to
add
child
process
as
target
peer
.
"
)
;
}
break
;
}
#
endif
}
#
else
#
error
Sorry
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
mResults
.
mHandle
)
;
#
ifdef
XP_MACOSX
mResults
.
mChildTask
=
child_task
;
#
endif
CrashReporter
:
:
RegisterChildCrashAnnotationFileDescriptor
(
base
:
:
GetProcId
(
mResults
.
mHandle
)
mCrashAnnotationReadPipe
.
forget
(
)
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
CHILD_PROCESS_LAUNCH_MS
mStartTimeStamp
)
;
return
ProcessLaunchPromise
:
:
CreateAndResolve
(
mResults
__func__
)
;
}
bool
GeckoChildProcessHost
:
:
OpenPrivilegedHandle
(
base
:
:
ProcessId
aPid
)
{
if
(
mChildProcessHandle
)
{
MOZ_ASSERT
(
aPid
=
=
base
:
:
GetProcId
(
mChildProcessHandle
)
)
;
return
true
;
}
return
base
:
:
OpenPrivilegedProcessHandle
(
aPid
&
mChildProcessHandle
)
;
}
void
GeckoChildProcessHost
:
:
OnChannelConnected
(
int32_t
peer_pid
)
{
if
(
!
OpenPrivilegedHandle
(
peer_pid
)
)
{
MOZ_CRASH
(
"
can
'
t
open
handle
to
child
process
"
)
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_CONNECTED
;
lock
.
Notify
(
)
;
}
void
GeckoChildProcessHost
:
:
OnMessageReceived
(
IPC
:
:
Message
&
&
aMsg
)
{
mQueue
.
push
(
std
:
:
move
(
aMsg
)
)
;
}
void
GeckoChildProcessHost
:
:
OnChannelError
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mProcessState
<
PROCESS_CONNECTED
)
{
mProcessState
=
PROCESS_ERROR
;
lock
.
Notify
(
)
;
}
}
RefPtr
<
ProcessHandlePromise
>
GeckoChildProcessHost
:
:
WhenProcessHandleReady
(
)
{
MOZ_ASSERT
(
mHandlePromise
!
=
nullptr
)
;
return
mHandlePromise
;
}
void
GeckoChildProcessHost
:
:
GetQueuedMessages
(
std
:
:
queue
<
IPC
:
:
Message
>
&
queue
)
{
DCHECK
(
MessageLoopForIO
:
:
current
(
)
)
;
swap
(
queue
mQueue
)
;
}
#
ifdef
MOZ_WIDGET_ANDROID
void
BaseProcessLauncher
:
:
LaunchAndroidService
(
const
char
*
type
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
base
:
:
file_handle_mapping_vector
&
fds_to_remap
base
:
:
ProcessHandle
*
process_handle
)
{
MOZ_RELEASE_ASSERT
(
(
2
<
=
fds_to_remap
.
size
(
)
)
&
&
(
fds_to_remap
.
size
(
)
<
=
5
)
)
;
JNIEnv
*
const
env
=
mozilla
:
:
jni
:
:
GetEnvForThread
(
)
;
MOZ_ASSERT
(
env
)
;
const
int
argvSize
=
argv
.
size
(
)
;
jni
:
:
ObjectArray
:
:
LocalRef
jargs
=
jni
:
:
ObjectArray
:
:
New
<
jni
:
:
String
>
(
argvSize
)
;
for
(
int
ix
=
0
;
ix
<
argvSize
;
ix
+
+
)
{
jargs
-
>
SetElement
(
ix
jni
:
:
StringParam
(
argv
[
ix
]
.
c_str
(
)
env
)
)
;
}
int32_t
prefsFd
=
fds_to_remap
[
0
]
.
first
;
int32_t
prefMapFd
=
fds_to_remap
[
1
]
.
first
;
int32_t
ipcFd
=
fds_to_remap
[
2
]
.
first
;
int32_t
crashFd
=
-
1
;
int32_t
crashAnnotationFd
=
-
1
;
if
(
fds_to_remap
.
size
(
)
=
=
4
)
{
crashAnnotationFd
=
fds_to_remap
[
3
]
.
first
;
}
if
(
fds_to_remap
.
size
(
)
=
=
5
)
{
crashFd
=
fds_to_remap
[
3
]
.
first
;
crashAnnotationFd
=
fds_to_remap
[
4
]
.
first
;
}
int32_t
handle
=
java
:
:
GeckoProcessManager
:
:
Start
(
type
jargs
prefsFd
prefMapFd
ipcFd
crashFd
crashAnnotationFd
)
;
if
(
process_handle
)
{
*
process_handle
=
handle
;
}
}
#
endif
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
MOZ_SANDBOX
)
bool
GeckoChildProcessHost
:
:
AppendMacSandboxParams
(
StringVector
&
aArgs
)
{
MacSandboxInfo
info
;
if
(
!
FillMacSandboxInfo
(
info
)
)
{
return
false
;
}
info
.
AppendAsParams
(
aArgs
)
;
return
true
;
}
bool
GeckoChildProcessHost
:
:
StaticFillMacSandboxInfo
(
MacSandboxInfo
&
aInfo
)
{
aInfo
.
type
=
GetDefaultMacSandboxType
(
)
;
aInfo
.
shouldLog
=
Preferences
:
:
GetBool
(
"
security
.
sandbox
.
logging
.
enabled
"
)
|
|
PR_GetEnv
(
"
MOZ_SANDBOX_LOGGING
"
)
;
nsAutoCString
appPath
;
if
(
!
nsMacUtilsImpl
:
:
GetAppPath
(
appPath
)
)
{
MOZ_CRASH
(
"
Failed
to
get
app
path
"
)
;
}
aInfo
.
appPath
.
assign
(
appPath
.
get
(
)
)
;
return
true
;
}
bool
GeckoChildProcessHost
:
:
FillMacSandboxInfo
(
MacSandboxInfo
&
aInfo
)
{
return
GeckoChildProcessHost
:
:
StaticFillMacSandboxInfo
(
aInfo
)
;
}
bool
GeckoChildProcessHost
:
:
StartMacSandbox
(
int
aArgc
char
*
*
aArgv
std
:
:
string
&
aErrorMessage
)
{
MacSandboxType
sandboxType
=
MacSandboxType_Invalid
;
switch
(
XRE_GetProcessType
(
)
)
{
case
GeckoProcessType_Content
:
sandboxType
=
MacSandboxType_Content
;
break
;
case
GeckoProcessType_RDD
:
sandboxType
=
RDDProcessHost
:
:
GetMacSandboxType
(
)
;
break
;
case
GeckoProcessType_GMPlugin
:
sandboxType
=
gmp
:
:
GMPProcessParent
:
:
GetMacSandboxType
(
)
;
break
;
default
:
return
true
;
}
return
mozilla
:
:
StartMacSandboxIfEnabled
(
sandboxType
aArgc
aArgv
aErrorMessage
)
;
}
#
endif
void
GeckoChildProcessHost
:
:
GetAll
(
const
GeckoProcessCallback
&
aCallback
)
{
StaticMutexAutoLock
lock
(
sMutex
)
;
for
(
GeckoChildProcessHost
*
gp
=
sGeckoChildProcessHosts
-
>
getFirst
(
)
;
gp
;
gp
=
static_cast
<
mozilla
:
:
LinkedListElement
<
GeckoChildProcessHost
>
*
>
(
gp
)
-
>
getNext
(
)
)
{
aCallback
(
gp
)
;
}
}
RefPtr
<
ProcessLaunchPromise
>
BaseProcessLauncher
:
:
Launch
(
GeckoChildProcessHost
*
aHost
)
{
AssertIOThread
(
)
;
aHost
-
>
InitializeChannel
(
)
;
mChannel
=
aHost
-
>
GetChannel
(
)
;
if
(
!
mChannel
)
{
return
ProcessLaunchPromise
:
:
CreateAndReject
(
LaunchError
{
}
__func__
)
;
}
mChannelId
=
aHost
-
>
GetChannelId
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
launchThread
;
if
(
mozilla
:
:
recordreplay
:
:
IsMiddleman
(
)
)
{
launchThread
=
IOThread
(
)
;
}
else
{
nsCOMPtr
<
nsIEventTarget
>
threadOrPool
=
GetIPCLauncher
(
)
;
launchThread
=
new
TaskQueue
(
threadOrPool
.
forget
(
)
)
;
}
return
InvokeAsync
(
launchThread
this
__func__
&
BaseProcessLauncher
:
:
PerformAsyncLaunch
)
;
}
}
}
