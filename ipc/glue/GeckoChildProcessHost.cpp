#
include
"
GeckoChildProcessHost
.
h
"
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
chrome
/
common
/
process_watcher
.
h
"
#
ifdef
MOZ_WIDGET_COCOA
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
base
/
rand_util
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
SharedMemoryBasic
.
h
"
#
endif
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
if
defined
(
XP_MACOSX
)
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
endif
#
endif
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
ProtocolUtils
.
h
"
#
include
<
sys
/
stat
.
h
>
#
ifdef
XP_WIN
#
include
"
nsIWinTaskbar
.
h
"
#
include
<
stdlib
.
h
>
#
define
NS_TASKBAR_CONTRACTID
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
sandboxing
/
sandboxLogging
.
h
"
#
endif
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxReporter
.
h
"
#
endif
#
include
"
nsTArray
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nscore
.
h
"
using
mozilla
:
:
MonitorAutoLock
;
using
mozilla
:
:
ipc
:
:
GeckoChildProcessHost
;
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidBridge
.
h
"
#
include
"
GeneratedJNIWrappers
.
h
"
#
include
"
mozilla
/
jni
/
Refs
.
h
"
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
static
const
bool
kLowRightsSubprocesses
=
#
ifdef
MOZ_WIDGET_GONK
true
#
else
false
#
endif
;
static
bool
ShouldHaveDirectoryService
(
)
{
return
GeckoProcessType_Default
=
=
XRE_GetProcessType
(
)
;
}
base
:
:
ChildPrivileges
GeckoChildProcessHost
:
:
DefaultChildPrivileges
(
)
{
return
(
kLowRightsSubprocesses
?
base
:
:
PRIVILEGES_UNPRIVILEGED
:
base
:
:
PRIVILEGES_INHERIT
)
;
}
GeckoChildProcessHost
:
:
GeckoChildProcessHost
(
GeckoProcessType
aProcessType
ChildPrivileges
aPrivileges
)
:
mProcessType
(
aProcessType
)
mPrivileges
(
aPrivileges
)
mMonitor
(
"
mozilla
.
ipc
.
GeckChildProcessHost
.
mMonitor
"
)
mProcessState
(
CREATING_CHANNEL
)
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
mEnableSandboxLogging
(
false
)
mSandboxLevel
(
0
)
#
endif
mChildProcessHandle
(
0
)
#
if
defined
(
MOZ_WIDGET_COCOA
)
mChildTask
(
MACH_PORT_NULL
)
#
endif
{
MOZ_COUNT_CTOR
(
GeckoChildProcessHost
)
;
}
GeckoChildProcessHost
:
:
~
GeckoChildProcessHost
(
)
{
AssertIOThread
(
)
;
MOZ_COUNT_DTOR
(
GeckoChildProcessHost
)
;
if
(
mChildProcessHandle
!
=
0
)
{
#
if
defined
(
MOZ_WIDGET_COCOA
)
SharedMemoryBasic
:
:
CleanupForPid
(
mChildProcessHandle
)
;
#
endif
ProcessWatcher
:
:
EnsureProcessTerminated
(
mChildProcessHandle
#
ifdef
NS_FREE_PERMANENT_DATA
false
#
endif
)
;
}
#
if
defined
(
MOZ_WIDGET_COCOA
)
if
(
mChildTask
!
=
MACH_PORT_NULL
)
mach_port_deallocate
(
mach_task_self
(
)
mChildTask
)
;
#
endif
}
auto
GeckoChildProcessHost
:
:
GetPathToBinary
(
FilePath
&
exePath
GeckoProcessType
processType
)
-
>
BinaryPathType
{
if
(
sRunSelfAsContentProc
&
&
(
processType
=
=
GeckoProcessType_Content
|
|
processType
=
=
GeckoProcessType_GPU
)
)
{
#
if
defined
(
OS_WIN
)
wchar_t
exePathBuf
[
MAXPATHLEN
]
;
if
(
!
:
:
GetModuleFileNameW
(
nullptr
exePathBuf
MAXPATHLEN
)
)
{
MOZ_CRASH
(
"
GetModuleFileNameW
failed
(
FIXME
)
"
)
;
}
exePath
=
FilePath
:
:
FromWStringHack
(
exePathBuf
)
;
#
elif
defined
(
OS_POSIX
)
exePath
=
FilePath
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
;
#
else
#
error
Sorry
;
target
OS
not
supported
yet
.
#
endif
return
BinaryPathType
:
:
Self
;
}
if
(
ShouldHaveDirectoryService
(
)
)
{
MOZ_ASSERT
(
gGREBinPath
)
;
#
ifdef
OS_WIN
exePath
=
FilePath
(
char16ptr_t
(
gGREBinPath
)
)
;
#
elif
MOZ_WIDGET_COCOA
nsCOMPtr
<
nsIFile
>
childProcPath
;
NS_NewLocalFile
(
nsDependentString
(
gGREBinPath
)
false
getter_AddRefs
(
childProcPath
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
plugin
-
container
.
app
"
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
Contents
"
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
MacOS
"
)
)
;
nsCString
tempCPath
;
childProcPath
-
>
GetNativePath
(
tempCPath
)
;
exePath
=
FilePath
(
tempCPath
.
get
(
)
)
;
#
else
nsCString
path
;
NS_CopyUnicodeToNative
(
nsDependentString
(
gGREBinPath
)
path
)
;
exePath
=
FilePath
(
path
.
get
(
)
)
;
#
endif
}
if
(
exePath
.
empty
(
)
)
{
#
ifdef
OS_WIN
exePath
=
FilePath
:
:
FromWStringHack
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
program
(
)
)
;
#
else
exePath
=
FilePath
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
;
#
endif
exePath
=
exePath
.
DirName
(
)
;
}
exePath
=
exePath
.
AppendASCII
(
MOZ_CHILD_PROCESS_NAME
)
;
return
BinaryPathType
:
:
PluginContainer
;
}
#
ifdef
MOZ_WIDGET_COCOA
class
AutoCFTypeObject
{
public
:
explicit
AutoCFTypeObject
(
CFTypeRef
object
)
{
mObject
=
object
;
}
~
AutoCFTypeObject
(
)
{
:
:
CFRelease
(
mObject
)
;
}
private
:
CFTypeRef
mObject
;
}
;
#
endif
nsresult
GeckoChildProcessHost
:
:
GetArchitecturesForBinary
(
const
char
*
path
uint32_t
*
result
)
{
*
result
=
0
;
#
ifdef
MOZ_WIDGET_COCOA
CFURLRef
url
=
:
:
CFURLCreateFromFileSystemRepresentation
(
kCFAllocatorDefault
(
const
UInt8
*
)
path
strlen
(
path
)
false
)
;
if
(
!
url
)
{
return
NS_ERROR_FAILURE
;
}
AutoCFTypeObject
autoPluginContainerURL
(
url
)
;
CFArrayRef
pluginContainerArchs
=
:
:
CFBundleCopyExecutableArchitecturesForURL
(
url
)
;
if
(
!
pluginContainerArchs
)
{
return
NS_ERROR_FAILURE
;
}
AutoCFTypeObject
autoPluginContainerArchs
(
pluginContainerArchs
)
;
CFIndex
pluginArchCount
=
:
:
CFArrayGetCount
(
pluginContainerArchs
)
;
for
(
CFIndex
i
=
0
;
i
<
pluginArchCount
;
i
+
+
)
{
CFNumberRef
currentArch
=
static_cast
<
CFNumberRef
>
(
:
:
CFArrayGetValueAtIndex
(
pluginContainerArchs
i
)
)
;
int
currentArchInt
=
0
;
if
(
!
:
:
CFNumberGetValue
(
currentArch
kCFNumberIntType
&
currentArchInt
)
)
{
continue
;
}
switch
(
currentArchInt
)
{
case
kCFBundleExecutableArchitectureI386
:
*
result
|
=
base
:
:
PROCESS_ARCH_I386
;
break
;
case
kCFBundleExecutableArchitectureX86_64
:
*
result
|
=
base
:
:
PROCESS_ARCH_X86_64
;
break
;
case
kCFBundleExecutableArchitecturePPC
:
*
result
|
=
base
:
:
PROCESS_ARCH_PPC
;
break
;
default
:
break
;
}
}
return
(
*
result
?
NS_OK
:
NS_ERROR_FAILURE
)
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
uint32_t
GeckoChildProcessHost
:
:
GetSupportedArchitecturesForProcessType
(
GeckoProcessType
type
)
{
#
ifdef
MOZ_WIDGET_COCOA
if
(
type
=
=
GeckoProcessType_Plugin
)
{
static
uint32_t
pluginContainerArchs
=
0
;
if
(
pluginContainerArchs
=
=
0
)
{
FilePath
exePath
;
GetPathToBinary
(
exePath
type
)
;
nsresult
rv
=
GetArchitecturesForBinary
(
exePath
.
value
(
)
.
c_str
(
)
&
pluginContainerArchs
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
&
&
pluginContainerArchs
!
=
0
"
Getting
architecture
of
plugin
container
failed
!
"
)
;
if
(
NS_FAILED
(
rv
)
|
|
pluginContainerArchs
=
=
0
)
{
pluginContainerArchs
=
base
:
:
GetCurrentProcessArchitecture
(
)
;
}
}
return
pluginContainerArchs
;
}
#
endif
return
base
:
:
GetCurrentProcessArchitecture
(
)
;
}
uint32_t
GeckoChildProcessHost
:
:
sNextUniqueID
=
1
;
uint32_t
GeckoChildProcessHost
:
:
GetUniqueID
(
)
{
return
sNextUniqueID
+
+
;
}
void
GeckoChildProcessHost
:
:
PrepareLaunch
(
)
{
#
ifdef
MOZ_CRASHREPORTER
if
(
CrashReporter
:
:
GetEnabled
(
)
)
{
CrashReporter
:
:
OOPInit
(
)
;
}
#
endif
#
ifdef
XP_WIN
if
(
mProcessType
=
=
GeckoProcessType_Plugin
)
{
InitWindowsGroupID
(
)
;
}
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
mProcessType
=
=
GeckoProcessType_Content
)
{
mSandboxLevel
=
GetEffectiveContentSandboxLevel
(
)
;
mEnableSandboxLogging
=
Preferences
:
:
GetBool
(
"
security
.
sandbox
.
logging
.
enabled
"
)
;
}
#
endif
#
if
defined
(
MOZ_SANDBOX
)
mEnableSandboxLogging
=
mEnableSandboxLogging
|
|
!
!
PR_GetEnv
(
"
MOZ_SANDBOX_LOGGING
"
)
;
#
endif
#
endif
}
#
ifdef
XP_WIN
void
GeckoChildProcessHost
:
:
InitWindowsGroupID
(
)
{
nsCOMPtr
<
nsIWinTaskbar
>
taskbarInfo
=
do_GetService
(
NS_TASKBAR_CONTRACTID
)
;
if
(
taskbarInfo
)
{
bool
isSupported
=
false
;
taskbarInfo
-
>
GetAvailable
(
&
isSupported
)
;
nsAutoString
appId
;
if
(
isSupported
&
&
NS_SUCCEEDED
(
taskbarInfo
-
>
GetDefaultGroupId
(
appId
)
)
)
{
mGroupId
.
Append
(
appId
)
;
}
else
{
mGroupId
.
Assign
(
'
-
'
)
;
}
}
}
#
endif
bool
GeckoChildProcessHost
:
:
SyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
int
aTimeoutMs
base
:
:
ProcessArchitecture
arch
)
{
PrepareLaunch
(
)
;
MessageLoop
*
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
NS_ASSERTION
(
MessageLoop
:
:
current
(
)
!
=
ioLoop
"
sync
launch
from
the
IO
thread
NYI
"
)
;
ioLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
std
:
:
vector
<
std
:
:
string
>
base
:
:
ProcessArchitecture
>
(
this
&
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
aExtraOpts
arch
)
)
;
return
WaitUntilConnected
(
aTimeoutMs
)
;
}
bool
GeckoChildProcessHost
:
:
AsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
base
:
:
ProcessArchitecture
arch
)
{
PrepareLaunch
(
)
;
MessageLoop
*
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
ioLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
std
:
:
vector
<
std
:
:
string
>
base
:
:
ProcessArchitecture
>
(
this
&
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
aExtraOpts
arch
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mProcessState
<
CHANNEL_INITIALIZED
)
{
lock
.
Wait
(
)
;
}
return
true
;
}
bool
GeckoChildProcessHost
:
:
WaitUntilConnected
(
int32_t
aTimeoutMs
)
{
PROFILER_LABEL_FUNC
(
js
:
:
ProfileEntry
:
:
Category
:
:
OTHER
)
;
PRIntervalTime
timeoutTicks
=
(
aTimeoutMs
>
0
)
?
PR_MillisecondsToInterval
(
aTimeoutMs
)
:
PR_INTERVAL_NO_TIMEOUT
;
MonitorAutoLock
lock
(
mMonitor
)
;
PRIntervalTime
waitStart
=
PR_IntervalNow
(
)
;
PRIntervalTime
current
;
while
(
mProcessState
!
=
PROCESS_CONNECTED
)
{
if
(
mProcessState
=
=
PROCESS_ERROR
)
{
break
;
}
lock
.
Wait
(
timeoutTicks
)
;
if
(
timeoutTicks
!
=
PR_INTERVAL_NO_TIMEOUT
)
{
current
=
PR_IntervalNow
(
)
;
PRIntervalTime
elapsed
=
current
-
waitStart
;
if
(
elapsed
>
timeoutTicks
)
{
break
;
}
timeoutTicks
=
timeoutTicks
-
elapsed
;
waitStart
=
current
;
}
}
return
mProcessState
=
=
PROCESS_CONNECTED
;
}
bool
GeckoChildProcessHost
:
:
LaunchAndWaitForProcessHandle
(
StringVector
aExtraOpts
)
{
PrepareLaunch
(
)
;
MessageLoop
*
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
ioLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
std
:
:
vector
<
std
:
:
string
>
base
:
:
ProcessArchitecture
>
(
this
&
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
aExtraOpts
base
:
:
GetCurrentProcessArchitecture
(
)
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mProcessState
<
PROCESS_CREATED
)
{
lock
.
Wait
(
)
;
}
MOZ_ASSERT
(
mProcessState
=
=
PROCESS_ERROR
|
|
mChildProcessHandle
)
;
return
mProcessState
<
PROCESS_ERROR
;
}
void
GeckoChildProcessHost
:
:
InitializeChannel
(
)
{
CreateChannel
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
CHANNEL_INITIALIZED
;
lock
.
Notify
(
)
;
}
void
GeckoChildProcessHost
:
:
Join
(
)
{
AssertIOThread
(
)
;
if
(
!
mChildProcessHandle
)
{
return
;
}
base
:
:
KillProcess
(
mChildProcessHandle
0
true
)
;
SetAlreadyDead
(
)
;
}
void
GeckoChildProcessHost
:
:
SetAlreadyDead
(
)
{
if
(
mChildProcessHandle
&
&
mChildProcessHandle
!
=
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
mChildProcessHandle
)
;
}
mChildProcessHandle
=
0
;
}
int32_t
GeckoChildProcessHost
:
:
mChildCounter
=
0
;
void
GeckoChildProcessHost
:
:
SetChildLogName
(
const
char
*
varName
const
char
*
origLogName
nsACString
&
buffer
)
{
buffer
.
Assign
(
varName
)
;
#
ifdef
XP_WIN
char
absPath
[
MAX_PATH
+
2
]
;
if
(
_fullpath
(
absPath
origLogName
sizeof
(
absPath
)
)
)
{
buffer
.
Append
(
absPath
)
;
}
else
#
endif
{
buffer
.
Append
(
origLogName
)
;
}
buffer
.
AppendLiteral
(
"
.
child
-
"
)
;
buffer
.
AppendInt
(
mChildCounter
)
;
PR_SetEnv
(
buffer
.
BeginReading
(
)
)
;
}
bool
GeckoChildProcessHost
:
:
PerformAsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
base
:
:
ProcessArchitecture
arch
)
{
const
char
*
origNSPRLogName
=
PR_GetEnv
(
"
NSPR_LOG_FILE
"
)
;
const
char
*
origMozLogName
=
PR_GetEnv
(
"
MOZ_LOG_FILE
"
)
;
if
(
!
origNSPRLogName
&
&
!
origMozLogName
)
{
return
PerformAsyncLaunchInternal
(
aExtraOpts
arch
)
;
}
+
+
mChildCounter
;
nsAutoCString
nsprLogName
;
nsAutoCString
mozLogName
;
if
(
origNSPRLogName
)
{
if
(
mRestoreOrigNSPRLogName
.
IsEmpty
(
)
)
{
mRestoreOrigNSPRLogName
.
AssignLiteral
(
"
NSPR_LOG_FILE
=
"
)
;
mRestoreOrigNSPRLogName
.
Append
(
origNSPRLogName
)
;
}
SetChildLogName
(
"
NSPR_LOG_FILE
=
"
origNSPRLogName
nsprLogName
)
;
}
if
(
origMozLogName
)
{
if
(
mRestoreOrigMozLogName
.
IsEmpty
(
)
)
{
mRestoreOrigMozLogName
.
AssignLiteral
(
"
MOZ_LOG_FILE
=
"
)
;
mRestoreOrigMozLogName
.
Append
(
origMozLogName
)
;
}
SetChildLogName
(
"
MOZ_LOG_FILE
=
"
origMozLogName
mozLogName
)
;
}
bool
retval
=
PerformAsyncLaunchInternal
(
aExtraOpts
arch
)
;
if
(
origNSPRLogName
)
{
PR_SetEnv
(
mRestoreOrigNSPRLogName
.
get
(
)
)
;
}
if
(
origMozLogName
)
{
PR_SetEnv
(
mRestoreOrigMozLogName
.
get
(
)
)
;
}
return
retval
;
}
bool
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
base
:
:
ProcessArchitecture
aArch
)
{
InitializeChannel
(
)
;
bool
ok
=
PerformAsyncLaunch
(
aExtraOpts
aArch
)
;
if
(
!
ok
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_ERROR
;
lock
.
Notify
(
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
Failed
to
launch
"
<
<
XRE_ChildProcessTypeToString
(
mProcessType
)
<
<
"
subprocess
"
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SUBPROCESS_LAUNCH_FAILURE
nsDependentCString
(
XRE_ChildProcessTypeToString
(
mProcessType
)
)
)
;
}
return
ok
;
}
void
#
if
defined
(
XP_WIN
)
AddAppDirToCommandLine
(
CommandLine
&
aCmdLine
)
#
else
AddAppDirToCommandLine
(
std
:
:
vector
<
std
:
:
string
>
&
aCmdLine
)
#
endif
{
if
(
ShouldHaveDirectoryService
(
)
)
{
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
)
;
NS_ASSERTION
(
directoryService
"
Expected
XPCOM
to
be
available
"
)
;
if
(
directoryService
)
{
nsCOMPtr
<
nsIFile
>
appDir
;
nsresult
rv
=
directoryService
-
>
Get
(
NS_XPCOM_CURRENT_PROCESS_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
#
if
defined
(
XP_WIN
)
nsString
path
;
MOZ_ALWAYS_SUCCEEDS
(
appDir
-
>
GetPath
(
path
)
)
;
aCmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
appdir
"
)
)
;
std
:
:
wstring
wpath
(
path
.
get
(
)
)
;
aCmdLine
.
AppendLooseValue
(
wpath
)
;
#
else
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
appDir
-
>
GetNativePath
(
path
)
)
;
aCmdLine
.
push_back
(
"
-
appdir
"
)
;
aCmdLine
.
push_back
(
path
.
get
(
)
)
;
#
endif
}
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
MOZ_CONTENT_SANDBOX
)
nsCOMPtr
<
nsIFile
>
profileDir
;
rv
=
directoryService
-
>
Get
(
NS_APP_USER_PROFILE_50_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
profileDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
profileDir
-
>
GetNativePath
(
path
)
)
;
aCmdLine
.
push_back
(
"
-
profile
"
)
;
aCmdLine
.
push_back
(
path
.
get
(
)
)
;
}
#
endif
}
}
}
bool
GeckoChildProcessHost
:
:
PerformAsyncLaunchInternal
(
std
:
:
vector
<
std
:
:
string
>
&
aExtraOpts
base
:
:
ProcessArchitecture
arch
)
{
if
(
!
GetChannel
(
)
)
{
return
false
;
}
base
:
:
ProcessHandle
process
=
0
;
char
pidstring
[
32
]
;
SprintfLiteral
(
pidstring
"
%
d
"
base
:
:
Process
:
:
Current
(
)
.
pid
(
)
)
;
const
char
*
const
childProcessType
=
XRE_ChildProcessTypeToString
(
mProcessType
)
;
#
if
defined
(
OS_POSIX
)
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_MACOSX
)
|
|
defined
(
OS_BSD
)
|
|
defined
(
OS_SOLARIS
)
base
:
:
environment_map
newEnvVars
;
ChildPrivileges
privs
=
mPrivileges
;
if
(
privs
=
=
base
:
:
PRIVILEGES_DEFAULT
|
|
privs
=
=
base
:
:
PRIVILEGES_FILEREAD
)
{
privs
=
DefaultChildPrivileges
(
)
;
}
#
if
defined
(
MOZ_WIDGET_GTK
)
if
(
mProcessType
=
=
GeckoProcessType_Content
)
{
newEnvVars
[
"
GTK_IM_MODULE
"
]
=
"
gtk
-
im
-
context
-
simple
"
;
newEnvVars
[
"
NO_AT_BRIDGE
"
]
=
"
1
"
;
}
#
endif
if
(
ShouldHaveDirectoryService
(
)
)
{
MOZ_ASSERT
(
gGREBinPath
)
;
nsCString
path
;
NS_CopyUnicodeToNative
(
nsDependentString
(
gGREBinPath
)
path
)
;
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_BSD
)
const
char
*
ld_library_path
=
PR_GetEnv
(
"
LD_LIBRARY_PATH
"
)
;
nsCString
new_ld_lib_path
(
path
.
get
(
)
)
;
#
if
(
MOZ_WIDGET_GTK
=
=
3
)
if
(
mProcessType
=
=
GeckoProcessType_Plugin
)
{
new_ld_lib_path
.
Append
(
"
/
gtk2
:
"
)
;
new_ld_lib_path
.
Append
(
path
.
get
(
)
)
;
}
#
endif
if
(
ld_library_path
&
&
*
ld_library_path
)
{
new_ld_lib_path
.
Append
(
'
:
'
)
;
new_ld_lib_path
.
Append
(
ld_library_path
)
;
}
newEnvVars
[
"
LD_LIBRARY_PATH
"
]
=
new_ld_lib_path
.
get
(
)
;
#
elif
OS_MACOSX
newEnvVars
[
"
DYLD_LIBRARY_PATH
"
]
=
path
.
get
(
)
;
const
char
*
prevInterpose
=
PR_GetEnv
(
"
DYLD_INSERT_LIBRARIES
"
)
;
nsCString
interpose
;
if
(
prevInterpose
&
&
strlen
(
prevInterpose
)
>
0
)
{
interpose
.
Assign
(
prevInterpose
)
;
interpose
.
Append
(
'
:
'
)
;
}
interpose
.
Append
(
path
.
get
(
)
)
;
interpose
.
AppendLiteral
(
"
/
libplugin_child_interpose
.
dylib
"
)
;
newEnvVars
[
"
DYLD_INSERT_LIBRARIES
"
]
=
interpose
.
get
(
)
;
#
endif
}
#
endif
FilePath
exePath
;
BinaryPathType
pathType
=
GetPathToBinary
(
exePath
mProcessType
)
;
#
ifdef
MOZ_WIDGET_GONK
if
(
const
char
*
ldPreloadPath
=
getenv
(
"
LD_PRELOAD
"
)
)
{
newEnvVars
[
"
LD_PRELOAD
"
]
=
ldPreloadPath
;
}
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
{
nsAutoCString
preload
;
preload
.
AssignLiteral
(
"
libmozsandbox
.
so
"
)
;
if
(
const
char
*
oldPreload
=
PR_GetEnv
(
"
LD_PRELOAD
"
)
)
{
preload
.
Append
(
'
'
)
;
preload
.
Append
(
oldPreload
)
;
}
newEnvVars
[
"
LD_PRELOAD
"
]
=
std
:
:
string
(
preload
.
get
(
)
)
;
}
#
endif
int
srcChannelFd
dstChannelFd
;
channel
(
)
.
GetClientFileDescriptorMapping
(
&
srcChannelFd
&
dstChannelFd
)
;
mFileMap
.
push_back
(
std
:
:
pair
<
int
int
>
(
srcChannelFd
dstChannelFd
)
)
;
std
:
:
vector
<
std
:
:
string
>
childArgv
;
childArgv
.
push_back
(
exePath
.
value
(
)
)
;
if
(
pathType
=
=
BinaryPathType
:
:
Self
)
{
childArgv
.
push_back
(
"
-
contentproc
"
)
;
}
childArgv
.
insert
(
childArgv
.
end
(
)
aExtraOpts
.
begin
(
)
aExtraOpts
.
end
(
)
)
;
if
(
Omnijar
:
:
IsInitialized
(
)
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIFile
>
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
GRE
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
childArgv
.
push_back
(
"
-
greomni
"
)
;
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
APP
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
childArgv
.
push_back
(
"
-
appomni
"
)
;
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
}
AddAppDirToCommandLine
(
childArgv
)
;
childArgv
.
push_back
(
pidstring
)
;
#
if
defined
(
MOZ_CRASHREPORTER
)
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_BSD
)
|
|
defined
(
OS_SOLARIS
)
int
childCrashFd
childCrashRemapFd
;
if
(
!
CrashReporter
:
:
CreateNotificationPipeForChild
(
&
childCrashFd
&
childCrashRemapFd
)
)
return
false
;
if
(
0
<
=
childCrashFd
)
{
mFileMap
.
push_back
(
std
:
:
pair
<
int
int
>
(
childCrashFd
childCrashRemapFd
)
)
;
childArgv
.
push_back
(
"
true
"
)
;
}
else
{
childArgv
.
push_back
(
"
false
"
)
;
}
#
elif
defined
(
MOZ_WIDGET_COCOA
)
childArgv
.
push_back
(
CrashReporter
:
:
GetChildNotificationPipe
(
)
)
;
#
endif
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
{
int
srcFd
dstFd
;
SandboxReporter
:
:
Singleton
(
)
-
>
GetClientFileDescriptorMapping
(
&
srcFd
&
dstFd
)
;
mFileMap
.
push_back
(
std
:
:
make_pair
(
srcFd
dstFd
)
)
;
}
#
endif
#
ifdef
MOZ_WIDGET_COCOA
std
:
:
string
mach_connection_name
=
StringPrintf
(
"
org
.
mozilla
.
machname
.
%
d
"
base
:
:
RandInt
(
0
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
)
;
childArgv
.
push_back
(
mach_connection_name
.
c_str
(
)
)
;
#
endif
childArgv
.
push_back
(
childProcessType
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
LaunchAndroidService
(
childProcessType
childArgv
mFileMap
&
process
)
;
#
else
base
:
:
LaunchApp
(
childArgv
mFileMap
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_MACOSX
)
|
|
defined
(
OS_BSD
)
|
|
defined
(
OS_SOLARIS
)
newEnvVars
privs
#
endif
false
&
process
arch
)
;
#
endif
GetChannel
(
)
-
>
CloseClientFileDescriptor
(
)
;
#
ifdef
MOZ_WIDGET_COCOA
const
int
kTimeoutMs
=
10000
;
MachReceiveMessage
child_message
;
ReceivePort
parent_recv_port
(
mach_connection_name
.
c_str
(
)
)
;
kern_return_t
err
=
parent_recv_port
.
WaitForMessage
(
&
child_message
kTimeoutMs
)
;
if
(
err
!
=
KERN_SUCCESS
)
{
std
:
:
string
errString
=
StringPrintf
(
"
0x
%
x
%
s
"
err
mach_error_string
(
err
)
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
WaitForMessage
(
)
failed
:
"
<
<
errString
;
return
false
;
}
task_t
child_task
=
child_message
.
GetTranslatedPort
(
0
)
;
if
(
child_task
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
0
)
failed
.
"
;
return
false
;
}
if
(
child_message
.
GetTranslatedPort
(
1
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
1
)
failed
.
"
;
return
false
;
}
MachPortSender
parent_sender
(
child_message
.
GetTranslatedPort
(
1
)
)
;
if
(
child_message
.
GetTranslatedPort
(
2
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
2
)
failed
.
"
;
}
auto
*
parent_recv_port_memory_ack
=
new
MachPortSender
(
child_message
.
GetTranslatedPort
(
2
)
)
;
if
(
child_message
.
GetTranslatedPort
(
3
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
3
)
failed
.
"
;
}
auto
*
parent_send_port_memory
=
new
MachPortSender
(
child_message
.
GetTranslatedPort
(
3
)
)
;
MachSendMessage
parent_message
(
0
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
bootstrap_port
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
bootstrap_port
<
<
"
)
failed
.
"
;
return
false
;
}
auto
*
parent_recv_port_memory
=
new
ReceivePort
(
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
parent_recv_port_memory
-
>
GetPort
(
)
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
parent_recv_port_memory
-
>
GetPort
(
)
<
<
"
)
failed
.
"
;
return
false
;
}
auto
*
parent_send_port_memory_ack
=
new
ReceivePort
(
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
parent_send_port_memory_ack
-
>
GetPort
(
)
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
parent_send_port_memory_ack
-
>
GetPort
(
)
<
<
"
)
failed
.
"
;
return
false
;
}
err
=
parent_sender
.
SendMessage
(
parent_message
kTimeoutMs
)
;
if
(
err
!
=
KERN_SUCCESS
)
{
std
:
:
string
errString
=
StringPrintf
(
"
0x
%
x
%
s
"
err
mach_error_string
(
err
)
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
SendMessage
(
)
failed
:
"
<
<
errString
;
return
false
;
}
SharedMemoryBasic
:
:
SetupMachMemory
(
process
parent_recv_port_memory
parent_recv_port_memory_ack
parent_send_port_memory
parent_send_port_memory_ack
false
)
;
#
endif
#
elif
defined
(
OS_WIN
)
FilePath
exePath
;
BinaryPathType
pathType
=
GetPathToBinary
(
exePath
mProcessType
)
;
CommandLine
cmdLine
(
exePath
.
ToWStringHack
(
)
)
;
if
(
pathType
=
=
BinaryPathType
:
:
Self
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
contentproc
"
)
)
;
}
cmdLine
.
AppendSwitchWithValue
(
switches
:
:
kProcessChannelID
channel_id
(
)
)
;
for
(
std
:
:
vector
<
std
:
:
string
>
:
:
iterator
it
=
aExtraOpts
.
begin
(
)
;
it
!
=
aExtraOpts
.
end
(
)
;
+
+
it
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
*
it
)
)
;
}
if
(
Omnijar
:
:
IsInitialized
(
)
)
{
nsAutoString
path
;
nsCOMPtr
<
nsIFile
>
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
GRE
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetPath
(
path
)
)
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
greomni
"
)
)
;
cmdLine
.
AppendLooseValue
(
path
.
get
(
)
)
;
}
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
APP
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetPath
(
path
)
)
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
appomni
"
)
)
;
cmdLine
.
AppendLooseValue
(
path
.
get
(
)
)
;
}
}
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
bool
shouldSandboxCurrentProcess
=
false
;
switch
(
mProcessType
)
{
case
GeckoProcessType_Content
:
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_CONTENT_SANDBOX
"
)
)
{
mSandboxBroker
.
SetSecurityLevelForContentProcess
(
mSandboxLevel
mPrivileges
)
;
shouldSandboxCurrentProcess
=
true
;
}
#
endif
break
;
case
GeckoProcessType_Plugin
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_NPAPI_SANDBOX
"
)
)
{
bool
ok
=
mSandboxBroker
.
SetSecurityLevelForPluginProcess
(
mSandboxLevel
)
;
if
(
!
ok
)
{
return
false
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_IPDLUnitTest
:
break
;
case
GeckoProcessType_GMPlugin
:
if
(
!
PR_GetEnv
(
"
MOZ_DISABLE_GMP_SANDBOX
"
)
)
{
bool
isWidevine
=
std
:
:
any_of
(
aExtraOpts
.
begin
(
)
aExtraOpts
.
end
(
)
[
]
(
const
std
:
:
string
arg
)
{
return
arg
.
find
(
"
gmp
-
widevinecdm
"
)
!
=
std
:
:
string
:
:
npos
;
}
)
;
auto
level
=
isWidevine
?
SandboxBroker
:
:
Restricted
:
SandboxBroker
:
:
LockDown
;
bool
ok
=
mSandboxBroker
.
SetSecurityLevelForGMPlugin
(
level
)
;
if
(
!
ok
)
{
return
false
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_GPU
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_GPU_SANDBOX
"
)
)
{
mSandboxBroker
.
SetSecurityLevelForGPUProcess
(
mSandboxLevel
)
;
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_Default
:
default
:
MOZ_CRASH
(
"
Bad
process
type
in
GeckoChildProcessHost
"
)
;
break
;
}
;
if
(
shouldSandboxCurrentProcess
)
{
for
(
auto
it
=
mAllowedFilesRead
.
begin
(
)
;
it
!
=
mAllowedFilesRead
.
end
(
)
;
+
+
it
)
{
mSandboxBroker
.
AllowReadFile
(
it
-
>
c_str
(
)
)
;
}
}
#
endif
AddAppDirToCommandLine
(
cmdLine
)
;
cmdLine
.
AppendLooseValue
(
mGroupId
.
get
(
)
)
;
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
pidstring
)
)
;
#
if
defined
(
MOZ_CRASHREPORTER
)
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
CrashReporter
:
:
GetChildNotificationPipe
(
)
)
)
;
#
endif
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
childProcessType
)
)
;
#
if
defined
(
XP_WIN
)
&
&
defined
(
MOZ_SANDBOX
)
if
(
shouldSandboxCurrentProcess
)
{
if
(
mSandboxBroker
.
LaunchApp
(
cmdLine
.
program
(
)
.
c_str
(
)
cmdLine
.
command_line_string
(
)
.
c_str
(
)
mEnableSandboxLogging
&
process
)
)
{
EnvironmentLog
(
"
MOZ_PROCESS_LOG
"
)
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
(
%
S
)
\
n
"
base
:
:
GetCurrentProcId
(
)
base
:
:
GetProcId
(
process
)
cmdLine
.
command_line_string
(
)
.
c_str
(
)
)
;
}
}
else
#
endif
{
base
:
:
LaunchApp
(
cmdLine
false
false
&
process
)
;
#
ifdef
MOZ_SANDBOX
if
(
mProcessType
=
=
GeckoProcessType_Content
|
|
mProcessType
=
=
GeckoProcessType_GPU
|
|
mProcessType
=
=
GeckoProcessType_GMPlugin
)
{
if
(
!
mSandboxBroker
.
AddTargetPeer
(
process
)
)
{
NS_WARNING
(
"
Failed
to
add
content
process
as
target
peer
.
"
)
;
}
}
#
endif
}
#
else
#
error
Sorry
#
endif
if
(
!
process
)
{
return
false
;
}
#
if
defined
(
MOZ_WIDGET_COCOA
)
mChildTask
=
child_task
;
#
endif
if
(
!
OpenPrivilegedHandle
(
base
:
:
GetProcId
(
process
)
)
#
ifdef
XP_WIN
&
&
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
process
:
:
GetCurrentProcess
(
)
&
mChildProcessHandle
PROCESS_DUP_HANDLE
|
PROCESS_TERMINATE
|
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
|
SYNCHRONIZE
FALSE
0
)
#
endif
)
{
MOZ_CRASH
(
"
cannot
open
handle
to
child
process
"
)
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_CREATED
;
lock
.
Notify
(
)
;
return
true
;
}
bool
GeckoChildProcessHost
:
:
OpenPrivilegedHandle
(
base
:
:
ProcessId
aPid
)
{
if
(
mChildProcessHandle
)
{
MOZ_ASSERT
(
aPid
=
=
base
:
:
GetProcId
(
mChildProcessHandle
)
)
;
return
true
;
}
return
base
:
:
OpenPrivilegedProcessHandle
(
aPid
&
mChildProcessHandle
)
;
}
void
GeckoChildProcessHost
:
:
OnChannelConnected
(
int32_t
peer_pid
)
{
if
(
!
OpenPrivilegedHandle
(
peer_pid
)
)
{
MOZ_CRASH
(
"
can
'
t
open
handle
to
child
process
"
)
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_CONNECTED
;
lock
.
Notify
(
)
;
}
void
GeckoChildProcessHost
:
:
OnMessageReceived
(
IPC
:
:
Message
&
&
aMsg
)
{
mQueue
.
push
(
Move
(
aMsg
)
)
;
}
void
GeckoChildProcessHost
:
:
OnChannelError
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mProcessState
<
PROCESS_CONNECTED
)
{
mProcessState
=
PROCESS_ERROR
;
lock
.
Notify
(
)
;
}
}
void
GeckoChildProcessHost
:
:
GetQueuedMessages
(
std
:
:
queue
<
IPC
:
:
Message
>
&
queue
)
{
DCHECK
(
MessageLoopForIO
:
:
current
(
)
)
;
swap
(
queue
mQueue
)
;
}
bool
GeckoChildProcessHost
:
:
sRunSelfAsContentProc
(
false
)
;
#
ifdef
MOZ_WIDGET_ANDROID
void
GeckoChildProcessHost
:
:
LaunchAndroidService
(
const
char
*
type
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
base
:
:
file_handle_mapping_vector
&
fds_to_remap
ProcessHandle
*
process_handle
)
{
MOZ_ASSERT
(
(
fds_to_remap
.
size
(
)
>
0
)
&
&
(
fds_to_remap
.
size
(
)
<
=
2
)
)
;
JNIEnv
*
env
=
mozilla
:
:
jni
:
:
GetEnvForThread
(
)
;
MOZ_ASSERT
(
env
)
;
int
argvSize
=
argv
.
size
(
)
;
jni
:
:
ObjectArray
:
:
LocalRef
jargs
=
jni
:
:
ObjectArray
:
:
LocalRef
:
:
Adopt
(
env
-
>
NewObjectArray
(
argvSize
env
-
>
FindClass
(
"
java
/
lang
/
String
"
)
nullptr
)
)
;
for
(
int
ix
=
0
;
ix
<
argvSize
;
ix
+
+
)
{
jargs
-
>
SetElement
(
ix
jni
:
:
StringParam
(
argv
[
ix
]
.
c_str
(
)
env
)
)
;
}
base
:
:
file_handle_mapping_vector
:
:
const_iterator
it
=
fds_to_remap
.
begin
(
)
;
int32_t
ipcFd
=
it
-
>
first
;
it
+
+
;
int32_t
crashFd
=
(
it
!
=
fds_to_remap
.
end
(
)
)
?
it
-
>
first
:
-
1
;
int32_t
handle
=
java
:
:
GeckoAppShell
:
:
StartGeckoServiceChildProcess
(
type
jargs
crashFd
ipcFd
)
;
if
(
process_handle
)
{
*
process_handle
=
handle
;
}
}
#
endif
