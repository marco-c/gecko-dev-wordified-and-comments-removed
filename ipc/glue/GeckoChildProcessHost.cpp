#
include
"
GeckoChildProcessHost
.
h
"
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
chrome
/
common
/
process_watcher
.
h
"
#
ifdef
MOZ_WIDGET_COCOA
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
include
"
base
/
rand_util
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
SharedMemoryBasic
.
h
"
#
endif
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsXPCOMPrivate
.
h
"
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
#
include
"
mozilla
/
SandboxSettings
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
endif
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ipc
/
BrowserProcessSubThread
.
h
"
#
include
"
mozilla
/
ipc
/
EnvironmentMap
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
ProtocolUtils
.
h
"
#
include
<
sys
/
stat
.
h
>
#
ifdef
XP_WIN
#
include
"
nsIWinTaskbar
.
h
"
#
include
<
stdlib
.
h
>
#
define
NS_TASKBAR_CONTRACTID
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
sandboxing
/
sandboxLogging
.
h
"
#
include
"
WinUtils
.
h
"
#
endif
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
endif
#
include
"
nsTArray
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
private
/
pprio
.
h
"
using
mozilla
:
:
MonitorAutoLock
;
using
mozilla
:
:
ipc
:
:
GeckoChildProcessHost
;
#
ifdef
MOZ_WIDGET_ANDROID
#
include
"
AndroidBridge
.
h
"
#
include
"
GeneratedJNIWrappers
.
h
"
#
include
"
mozilla
/
jni
/
Refs
.
h
"
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
endif
static
bool
ShouldHaveDirectoryService
(
)
{
return
GeckoProcessType_Default
=
=
XRE_GetProcessType
(
)
;
}
GeckoChildProcessHost
:
:
GeckoChildProcessHost
(
GeckoProcessType
aProcessType
bool
aIsFileContent
)
:
mProcessType
(
aProcessType
)
mIsFileContent
(
aIsFileContent
)
mMonitor
(
"
mozilla
.
ipc
.
GeckChildProcessHost
.
mMonitor
"
)
mLaunchOptions
(
MakeUnique
<
base
:
:
LaunchOptions
>
(
)
)
mProcessState
(
CREATING_CHANNEL
)
#
ifdef
XP_WIN
mGroupId
(
u
"
-
"
)
#
endif
#
if
defined
(
MOZ_SANDBOX
)
&
&
defined
(
XP_WIN
)
mEnableSandboxLogging
(
false
)
mSandboxLevel
(
0
)
#
endif
mChildProcessHandle
(
0
)
#
if
defined
(
MOZ_WIDGET_COCOA
)
mChildTask
(
MACH_PORT_NULL
)
#
endif
{
MOZ_COUNT_CTOR
(
GeckoChildProcessHost
)
;
}
GeckoChildProcessHost
:
:
~
GeckoChildProcessHost
(
)
{
AssertIOThread
(
)
;
MOZ_COUNT_DTOR
(
GeckoChildProcessHost
)
;
if
(
mChildProcessHandle
!
=
0
)
{
#
if
defined
(
MOZ_WIDGET_COCOA
)
SharedMemoryBasic
:
:
CleanupForPid
(
mChildProcessHandle
)
;
#
endif
ProcessWatcher
:
:
EnsureProcessTerminated
(
mChildProcessHandle
#
ifdef
NS_FREE_PERMANENT_DATA
false
#
endif
)
;
}
#
if
defined
(
MOZ_WIDGET_COCOA
)
if
(
mChildTask
!
=
MACH_PORT_NULL
)
mach_port_deallocate
(
mach_task_self
(
)
mChildTask
)
;
#
endif
if
(
mChildProcessHandle
!
=
0
)
{
#
if
defined
(
XP_WIN
)
CrashReporter
:
:
DeregisterChildCrashAnnotationFileDescriptor
(
base
:
:
GetProcId
(
mChildProcessHandle
)
)
;
#
else
CrashReporter
:
:
DeregisterChildCrashAnnotationFileDescriptor
(
mChildProcessHandle
)
;
#
endif
}
}
auto
GeckoChildProcessHost
:
:
GetPathToBinary
(
FilePath
&
exePath
GeckoProcessType
processType
)
-
>
BinaryPathType
{
if
(
sRunSelfAsContentProc
&
&
(
processType
=
=
GeckoProcessType_Content
|
|
processType
=
=
GeckoProcessType_GPU
)
)
{
#
if
defined
(
OS_WIN
)
wchar_t
exePathBuf
[
MAXPATHLEN
]
;
if
(
!
:
:
GetModuleFileNameW
(
nullptr
exePathBuf
MAXPATHLEN
)
)
{
MOZ_CRASH
(
"
GetModuleFileNameW
failed
(
FIXME
)
"
)
;
}
#
if
defined
(
MOZ_SANDBOX
)
std
:
:
wstring
exePathStr
=
exePathBuf
;
if
(
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
exePathStr
)
)
{
exePath
=
FilePath
:
:
FromWStringHack
(
exePathStr
)
;
}
else
#
endif
{
exePath
=
FilePath
:
:
FromWStringHack
(
exePathBuf
)
;
}
#
elif
defined
(
OS_POSIX
)
exePath
=
FilePath
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
;
#
else
#
error
Sorry
;
target
OS
not
supported
yet
.
#
endif
return
BinaryPathType
:
:
Self
;
}
if
(
ShouldHaveDirectoryService
(
)
)
{
MOZ_ASSERT
(
gGREBinPath
)
;
#
ifdef
OS_WIN
exePath
=
FilePath
(
char16ptr_t
(
gGREBinPath
)
)
;
#
elif
MOZ_WIDGET_COCOA
nsCOMPtr
<
nsIFile
>
childProcPath
;
NS_NewLocalFile
(
nsDependentString
(
gGREBinPath
)
false
getter_AddRefs
(
childProcPath
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
plugin
-
container
.
app
"
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
Contents
"
)
)
;
childProcPath
-
>
AppendNative
(
NS_LITERAL_CSTRING
(
"
MacOS
"
)
)
;
nsCString
tempCPath
;
childProcPath
-
>
GetNativePath
(
tempCPath
)
;
exePath
=
FilePath
(
tempCPath
.
get
(
)
)
;
#
else
nsCString
path
;
NS_CopyUnicodeToNative
(
nsDependentString
(
gGREBinPath
)
path
)
;
exePath
=
FilePath
(
path
.
get
(
)
)
;
#
endif
}
if
(
exePath
.
empty
(
)
)
{
#
ifdef
OS_WIN
exePath
=
FilePath
:
:
FromWStringHack
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
program
(
)
)
;
#
else
exePath
=
FilePath
(
CommandLine
:
:
ForCurrentProcess
(
)
-
>
argv
(
)
[
0
]
)
;
#
endif
exePath
=
exePath
.
DirName
(
)
;
}
exePath
=
exePath
.
AppendASCII
(
MOZ_CHILD_PROCESS_NAME
)
;
return
BinaryPathType
:
:
PluginContainer
;
}
#
ifdef
MOZ_WIDGET_COCOA
class
AutoCFTypeObject
{
public
:
explicit
AutoCFTypeObject
(
CFTypeRef
object
)
{
mObject
=
object
;
}
~
AutoCFTypeObject
(
)
{
:
:
CFRelease
(
mObject
)
;
}
private
:
CFTypeRef
mObject
;
}
;
#
endif
uint32_t
GeckoChildProcessHost
:
:
sNextUniqueID
=
1
;
uint32_t
GeckoChildProcessHost
:
:
GetUniqueID
(
)
{
return
sNextUniqueID
+
+
;
}
void
GeckoChildProcessHost
:
:
PrepareLaunch
(
)
{
if
(
CrashReporter
:
:
GetEnabled
(
)
)
{
CrashReporter
:
:
OOPInit
(
)
;
}
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
SandboxLaunchPrepare
(
mProcessType
mLaunchOptions
.
get
(
)
)
;
#
endif
#
ifdef
XP_WIN
if
(
mProcessType
=
=
GeckoProcessType_Plugin
)
{
InitWindowsGroupID
(
)
;
}
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
mProcessType
=
=
GeckoProcessType_Content
)
{
mSandboxLevel
=
GetEffectiveContentSandboxLevel
(
)
;
mEnableSandboxLogging
=
Preferences
:
:
GetBool
(
"
security
.
sandbox
.
logging
.
enabled
"
)
;
nsAutoString
readPaths
;
nsresult
rv
=
Preferences
:
:
GetString
(
"
security
.
sandbox
.
content
.
read_path_whitelist
"
readPaths
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
for
(
const
nsAString
&
readPath
:
readPaths
.
Split
(
'
'
)
)
{
nsString
trimmedPath
(
readPath
)
;
trimmedPath
.
Trim
(
"
"
true
true
)
;
std
:
:
wstring
resolvedPath
(
trimmedPath
.
Data
(
)
)
;
bool
addWildcard
=
(
resolvedPath
.
back
(
)
=
=
L
'
\
\
'
)
;
if
(
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
resolvedPath
)
)
{
NS_ERROR
(
"
Failed
to
resolve
test
read
policy
rule
.
"
)
;
continue
;
}
if
(
addWildcard
)
{
resolvedPath
.
append
(
L
"
\
\
*
"
)
;
}
mAllowedFilesRead
.
push_back
(
resolvedPath
)
;
}
}
}
#
endif
#
if
defined
(
MOZ_SANDBOX
)
mEnableSandboxLogging
=
mEnableSandboxLogging
|
|
!
!
PR_GetEnv
(
"
MOZ_SANDBOX_LOGGING
"
)
;
#
endif
#
elif
defined
(
XP_LINUX
)
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
ShouldHaveDirectoryService
(
)
)
{
nsCOMPtr
<
nsIFile
>
contentTempDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_APP_CONTENT_PROCESS_TEMP_DIR
getter_AddRefs
(
contentTempDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
contentTempDir
-
>
GetNativePath
(
mTmpDirName
)
;
}
}
#
endif
#
endif
}
#
ifdef
XP_WIN
void
GeckoChildProcessHost
:
:
InitWindowsGroupID
(
)
{
nsCOMPtr
<
nsIWinTaskbar
>
taskbarInfo
=
do_GetService
(
NS_TASKBAR_CONTRACTID
)
;
if
(
taskbarInfo
)
{
bool
isSupported
=
false
;
taskbarInfo
-
>
GetAvailable
(
&
isSupported
)
;
nsAutoString
appId
;
if
(
isSupported
&
&
NS_SUCCEEDED
(
taskbarInfo
-
>
GetDefaultGroupId
(
appId
)
)
)
{
MOZ_ASSERT
(
mGroupId
.
EqualsLiteral
(
"
-
"
)
)
;
mGroupId
.
Assign
(
appId
)
;
}
}
}
#
endif
bool
GeckoChildProcessHost
:
:
SyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
int
aTimeoutMs
)
{
PrepareLaunch
(
)
;
MessageLoop
*
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
NS_ASSERTION
(
MessageLoop
:
:
current
(
)
!
=
ioLoop
"
sync
launch
from
the
IO
thread
NYI
"
)
;
ioLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
std
:
:
vector
<
std
:
:
string
>
>
(
"
ipc
:
:
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
"
this
&
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
aExtraOpts
)
)
;
return
WaitUntilConnected
(
aTimeoutMs
)
;
}
bool
GeckoChildProcessHost
:
:
AsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
)
{
PrepareLaunch
(
)
;
MessageLoop
*
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
ioLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
std
:
:
vector
<
std
:
:
string
>
>
(
"
ipc
:
:
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
"
this
&
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
aExtraOpts
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mProcessState
<
CHANNEL_INITIALIZED
)
{
lock
.
Wait
(
)
;
}
return
true
;
}
bool
GeckoChildProcessHost
:
:
WaitUntilConnected
(
int32_t
aTimeoutMs
)
{
AUTO_PROFILER_LABEL
(
"
GeckoChildProcessHost
:
:
WaitUntilConnected
"
OTHER
)
;
TimeDuration
timeout
=
(
aTimeoutMs
>
0
)
?
TimeDuration
:
:
FromMilliseconds
(
aTimeoutMs
)
:
TimeDuration
:
:
Forever
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
TimeStamp
waitStart
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
current
;
while
(
mProcessState
!
=
PROCESS_CONNECTED
)
{
if
(
mProcessState
=
=
PROCESS_ERROR
)
{
break
;
}
CVStatus
status
=
lock
.
Wait
(
timeout
)
;
if
(
status
=
=
CVStatus
:
:
Timeout
)
{
break
;
}
if
(
timeout
!
=
TimeDuration
:
:
Forever
(
)
)
{
current
=
TimeStamp
:
:
Now
(
)
;
timeout
-
=
current
-
waitStart
;
waitStart
=
current
;
}
}
return
mProcessState
=
=
PROCESS_CONNECTED
;
}
bool
GeckoChildProcessHost
:
:
LaunchAndWaitForProcessHandle
(
StringVector
aExtraOpts
)
{
PrepareLaunch
(
)
;
MessageLoop
*
ioLoop
=
XRE_GetIOMessageLoop
(
)
;
ioLoop
-
>
PostTask
(
NewNonOwningRunnableMethod
<
std
:
:
vector
<
std
:
:
string
>
>
(
"
ipc
:
:
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
"
this
&
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
aExtraOpts
)
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
mProcessState
<
PROCESS_CREATED
)
{
lock
.
Wait
(
)
;
}
MOZ_ASSERT
(
mProcessState
=
=
PROCESS_ERROR
|
|
mChildProcessHandle
)
;
return
mProcessState
<
PROCESS_ERROR
;
}
void
GeckoChildProcessHost
:
:
InitializeChannel
(
)
{
CreateChannel
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
CHANNEL_INITIALIZED
;
lock
.
Notify
(
)
;
}
void
GeckoChildProcessHost
:
:
Join
(
)
{
AssertIOThread
(
)
;
if
(
!
mChildProcessHandle
)
{
return
;
}
base
:
:
KillProcess
(
mChildProcessHandle
0
true
)
;
SetAlreadyDead
(
)
;
}
void
GeckoChildProcessHost
:
:
SetAlreadyDead
(
)
{
if
(
mChildProcessHandle
&
&
mChildProcessHandle
!
=
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
mChildProcessHandle
)
;
}
mChildProcessHandle
=
0
;
}
int32_t
GeckoChildProcessHost
:
:
mChildCounter
=
0
;
void
GeckoChildProcessHost
:
:
GetChildLogName
(
const
char
*
origLogName
nsACString
&
buffer
)
{
#
ifdef
XP_WIN
char
absPath
[
MAX_PATH
+
2
]
;
if
(
_fullpath
(
absPath
origLogName
sizeof
(
absPath
)
)
)
{
#
ifdef
MOZ_SANDBOX
std
:
:
wstring
resolvedPath
(
NS_ConvertUTF8toUTF16
(
absPath
)
.
get
(
)
)
;
if
(
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
resolvedPath
)
)
{
AppendUTF16toUTF8
(
resolvedPath
.
c_str
(
)
buffer
)
;
}
else
#
endif
{
buffer
.
Append
(
absPath
)
;
}
}
else
#
endif
{
buffer
.
Append
(
origLogName
)
;
}
buffer
.
AppendLiteral
(
"
.
child
-
"
)
;
buffer
.
AppendInt
(
mChildCounter
)
;
}
bool
GeckoChildProcessHost
:
:
PerformAsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
)
{
#
ifdef
MOZ_GECKO_PROFILER
AutoSetProfilerEnvVarsForChildProcess
profilerEnvironment
;
#
endif
+
+
mChildCounter
;
const
char
*
origNSPRLogName
=
PR_GetEnv
(
"
NSPR_LOG_FILE
"
)
;
const
char
*
origMozLogName
=
PR_GetEnv
(
"
MOZ_LOG_FILE
"
)
;
if
(
origNSPRLogName
)
{
nsAutoCString
nsprLogName
;
GetChildLogName
(
origNSPRLogName
nsprLogName
)
;
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
NSPR_LOG_FILE
"
)
]
=
ENVIRONMENT_STRING
(
nsprLogName
)
;
}
if
(
origMozLogName
)
{
nsAutoCString
mozLogName
;
GetChildLogName
(
origMozLogName
mozLogName
)
;
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
MOZ_LOG_FILE
"
)
]
=
ENVIRONMENT_STRING
(
mozLogName
)
;
}
nsAutoCString
childRustLog
(
PR_GetEnv
(
"
RUST_LOG_CHILD
"
)
)
;
if
(
!
childRustLog
.
IsEmpty
(
)
)
{
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
RUST_LOG
"
)
]
=
ENVIRONMENT_STRING
(
childRustLog
)
;
}
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
!
mTmpDirName
.
IsEmpty
(
)
)
{
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
TMPDIR
"
)
]
=
ENVIRONMENT_STRING
(
mTmpDirName
)
;
mLaunchOptions
-
>
env_map
[
ENVIRONMENT_LITERAL
(
"
MESA_GLSL_CACHE_DIR
"
)
]
=
ENVIRONMENT_STRING
(
mTmpDirName
)
;
}
#
endif
return
PerformAsyncLaunchInternal
(
aExtraOpts
)
;
}
bool
GeckoChildProcessHost
:
:
RunPerformAsyncLaunch
(
std
:
:
vector
<
std
:
:
string
>
aExtraOpts
)
{
InitializeChannel
(
)
;
bool
ok
=
PerformAsyncLaunch
(
aExtraOpts
)
;
if
(
!
ok
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_ERROR
;
lock
.
Notify
(
)
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
OnProcessLaunchError
(
)
;
#
endif
CHROMIUM_LOG
(
ERROR
)
<
<
"
Failed
to
launch
"
<
<
XRE_ChildProcessTypeToString
(
mProcessType
)
<
<
"
subprocess
"
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SUBPROCESS_LAUNCH_FAILURE
nsDependentCString
(
XRE_ChildProcessTypeToString
(
mProcessType
)
)
)
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
}
else
{
OnProcessHandleReady
(
mChildProcessHandle
)
;
#
endif
}
return
ok
;
}
void
#
if
defined
(
XP_WIN
)
AddAppDirToCommandLine
(
CommandLine
&
aCmdLine
)
#
else
AddAppDirToCommandLine
(
std
:
:
vector
<
std
:
:
string
>
&
aCmdLine
)
#
endif
{
if
(
ShouldHaveDirectoryService
(
)
)
{
nsCOMPtr
<
nsIProperties
>
directoryService
(
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
)
;
NS_ASSERTION
(
directoryService
"
Expected
XPCOM
to
be
available
"
)
;
if
(
directoryService
)
{
nsCOMPtr
<
nsIFile
>
appDir
;
nsresult
rv
=
directoryService
-
>
Get
(
NS_XPCOM_CURRENT_PROCESS_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
appDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
#
if
defined
(
XP_WIN
)
nsString
path
;
MOZ_ALWAYS_SUCCEEDS
(
appDir
-
>
GetPath
(
path
)
)
;
aCmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
appdir
"
)
)
;
std
:
:
wstring
wpath
(
path
.
get
(
)
)
;
aCmdLine
.
AppendLooseValue
(
wpath
)
;
#
else
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
appDir
-
>
GetNativePath
(
path
)
)
;
aCmdLine
.
push_back
(
"
-
appdir
"
)
;
aCmdLine
.
push_back
(
path
.
get
(
)
)
;
#
endif
}
#
if
defined
(
XP_MACOSX
)
&
&
defined
(
MOZ_CONTENT_SANDBOX
)
nsCOMPtr
<
nsIFile
>
profileDir
;
rv
=
directoryService
-
>
Get
(
NS_APP_USER_PROFILE_50_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
profileDir
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
profileDir
-
>
GetNativePath
(
path
)
)
;
aCmdLine
.
push_back
(
"
-
profile
"
)
;
aCmdLine
.
push_back
(
path
.
get
(
)
)
;
}
#
endif
}
}
}
bool
GeckoChildProcessHost
:
:
PerformAsyncLaunchInternal
(
std
:
:
vector
<
std
:
:
string
>
&
aExtraOpts
)
{
if
(
!
GetChannel
(
)
)
{
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
1
=
=
2
)
;
#
endif
return
false
;
}
base
:
:
ProcessHandle
process
=
0
;
char
pidstring
[
32
]
;
SprintfLiteral
(
pidstring
"
%
d
"
base
:
:
GetCurrentProcId
(
)
)
;
const
char
*
const
childProcessType
=
XRE_ChildProcessTypeToString
(
mProcessType
)
;
PRFileDesc
*
crashAnnotationReadPipe
;
PRFileDesc
*
crashAnnotationWritePipe
;
if
(
PR_CreatePipe
(
&
crashAnnotationReadPipe
&
crashAnnotationWritePipe
)
!
=
PR_SUCCESS
)
{
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
2
=
=
3
)
;
#
endif
return
false
;
}
#
if
defined
(
OS_POSIX
)
#
if
defined
(
OS_POSIX
)
#
if
defined
(
MOZ_WIDGET_GTK
)
if
(
mProcessType
=
=
GeckoProcessType_Content
)
{
mLaunchOptions
-
>
env_map
[
"
GTK_IM_MODULE
"
]
=
"
gtk
-
im
-
context
-
simple
"
;
mLaunchOptions
-
>
env_map
[
"
NO_AT_BRIDGE
"
]
=
"
1
"
;
}
#
endif
if
(
ShouldHaveDirectoryService
(
)
)
{
MOZ_ASSERT
(
gGREBinPath
)
;
nsCString
path
;
NS_CopyUnicodeToNative
(
nsDependentString
(
gGREBinPath
)
path
)
;
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_BSD
)
const
char
*
ld_library_path
=
PR_GetEnv
(
"
LD_LIBRARY_PATH
"
)
;
nsCString
new_ld_lib_path
(
path
.
get
(
)
)
;
#
ifdef
MOZ_WIDGET_GTK
if
(
mProcessType
=
=
GeckoProcessType_Plugin
)
{
new_ld_lib_path
.
AppendLiteral
(
"
/
gtk2
:
"
)
;
new_ld_lib_path
.
Append
(
path
.
get
(
)
)
;
}
#
endif
if
(
ld_library_path
&
&
*
ld_library_path
)
{
new_ld_lib_path
.
Append
(
'
:
'
)
;
new_ld_lib_path
.
Append
(
ld_library_path
)
;
}
mLaunchOptions
-
>
env_map
[
"
LD_LIBRARY_PATH
"
]
=
new_ld_lib_path
.
get
(
)
;
#
elif
OS_MACOSX
mLaunchOptions
-
>
env_map
[
"
DYLD_LIBRARY_PATH
"
]
=
path
.
get
(
)
;
const
char
*
prevInterpose
=
PR_GetEnv
(
"
DYLD_INSERT_LIBRARIES
"
)
;
nsCString
interpose
;
if
(
prevInterpose
&
&
strlen
(
prevInterpose
)
>
0
)
{
interpose
.
Assign
(
prevInterpose
)
;
interpose
.
Append
(
'
:
'
)
;
}
interpose
.
Append
(
path
.
get
(
)
)
;
interpose
.
AppendLiteral
(
"
/
libplugin_child_interpose
.
dylib
"
)
;
mLaunchOptions
-
>
env_map
[
"
DYLD_INSERT_LIBRARIES
"
]
=
interpose
.
get
(
)
;
#
endif
}
#
endif
FilePath
exePath
;
BinaryPathType
pathType
=
GetPathToBinary
(
exePath
mProcessType
)
;
int
srcChannelFd
dstChannelFd
;
channel
(
)
.
GetClientFileDescriptorMapping
(
&
srcChannelFd
&
dstChannelFd
)
;
mLaunchOptions
-
>
fds_to_remap
.
push_back
(
std
:
:
pair
<
int
int
>
(
srcChannelFd
dstChannelFd
)
)
;
std
:
:
vector
<
std
:
:
string
>
childArgv
;
childArgv
.
push_back
(
exePath
.
value
(
)
)
;
if
(
pathType
=
=
BinaryPathType
:
:
Self
)
{
childArgv
.
push_back
(
"
-
contentproc
"
)
;
}
childArgv
.
insert
(
childArgv
.
end
(
)
aExtraOpts
.
begin
(
)
aExtraOpts
.
end
(
)
)
;
if
(
Omnijar
:
:
IsInitialized
(
)
)
{
nsAutoCString
path
;
nsCOMPtr
<
nsIFile
>
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
GRE
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
childArgv
.
push_back
(
"
-
greomni
"
)
;
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
APP
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
childArgv
.
push_back
(
"
-
appomni
"
)
;
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
}
AddAppDirToCommandLine
(
childArgv
)
;
if
(
mProcessType
=
=
GeckoProcessType_GPU
)
{
nsCOMPtr
<
nsIFile
>
file
;
CrashReporter
:
:
GetChildProcessTmpDir
(
getter_AddRefs
(
file
)
)
;
nsAutoCString
path
;
if
(
file
)
{
file
-
>
GetNativePath
(
path
)
;
}
childArgv
.
push_back
(
path
.
get
(
)
)
;
}
childArgv
.
push_back
(
pidstring
)
;
if
(
!
CrashReporter
:
:
IsDummy
(
)
)
{
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_BSD
)
|
|
defined
(
OS_SOLARIS
)
int
childCrashFd
childCrashRemapFd
;
if
(
!
CrashReporter
:
:
CreateNotificationPipeForChild
(
&
childCrashFd
&
childCrashRemapFd
)
)
{
return
false
;
}
if
(
0
<
=
childCrashFd
)
{
mLaunchOptions
-
>
fds_to_remap
.
push_back
(
std
:
:
pair
<
int
int
>
(
childCrashFd
childCrashRemapFd
)
)
;
childArgv
.
push_back
(
"
true
"
)
;
}
else
{
childArgv
.
push_back
(
"
false
"
)
;
}
#
elif
defined
(
MOZ_WIDGET_COCOA
)
childArgv
.
push_back
(
CrashReporter
:
:
GetChildNotificationPipe
(
)
)
;
#
endif
}
int
fd
=
PR_FileDesc2NativeHandle
(
crashAnnotationWritePipe
)
;
mLaunchOptions
-
>
fds_to_remap
.
push_back
(
std
:
:
make_pair
(
fd
CrashReporter
:
:
GetAnnotationTimeCrashFd
(
)
)
)
;
#
ifdef
MOZ_WIDGET_COCOA
std
:
:
string
mach_connection_name
=
StringPrintf
(
"
org
.
mozilla
.
machname
.
%
d
"
base
:
:
RandInt
(
0
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
)
;
childArgv
.
push_back
(
mach_connection_name
.
c_str
(
)
)
;
#
endif
childArgv
.
push_back
(
childProcessType
)
;
#
ifdef
MOZ_WIDGET_COCOA
ReceivePort
parent_recv_port
(
mach_connection_name
.
c_str
(
)
)
;
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
LaunchAndroidService
(
childProcessType
childArgv
mLaunchOptions
-
>
fds_to_remap
&
process
)
;
#
else
base
:
:
LaunchApp
(
childArgv
*
mLaunchOptions
&
process
)
;
#
endif
GetChannel
(
)
-
>
CloseClientFileDescriptor
(
)
;
#
ifdef
MOZ_WIDGET_COCOA
const
int
kTimeoutMs
=
10000
;
MachReceiveMessage
child_message
;
kern_return_t
err
=
parent_recv_port
.
WaitForMessage
(
&
child_message
kTimeoutMs
)
;
if
(
err
!
=
KERN_SUCCESS
)
{
std
:
:
string
errString
=
StringPrintf
(
"
0x
%
x
%
s
"
err
mach_error_string
(
err
)
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
WaitForMessage
(
)
failed
:
"
<
<
errString
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
3
=
=
4
)
;
#
endif
return
false
;
}
task_t
child_task
=
child_message
.
GetTranslatedPort
(
0
)
;
if
(
child_task
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
0
)
failed
.
"
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
4
=
=
5
)
;
#
endif
return
false
;
}
if
(
child_message
.
GetTranslatedPort
(
1
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
1
)
failed
.
"
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
5
=
=
6
)
;
#
endif
return
false
;
}
MachPortSender
parent_sender
(
child_message
.
GetTranslatedPort
(
1
)
)
;
if
(
child_message
.
GetTranslatedPort
(
2
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
2
)
failed
.
"
;
}
auto
*
parent_recv_port_memory_ack
=
new
MachPortSender
(
child_message
.
GetTranslatedPort
(
2
)
)
;
if
(
child_message
.
GetTranslatedPort
(
3
)
=
=
MACH_PORT_NULL
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
GetTranslatedPort
(
3
)
failed
.
"
;
}
auto
*
parent_send_port_memory
=
new
MachPortSender
(
child_message
.
GetTranslatedPort
(
3
)
)
;
MachSendMessage
parent_message
(
0
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
bootstrap_port
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
bootstrap_port
<
<
"
)
failed
.
"
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
6
=
=
7
)
;
#
endif
return
false
;
}
auto
*
parent_recv_port_memory
=
new
ReceivePort
(
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
parent_recv_port_memory
-
>
GetPort
(
)
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
parent_recv_port_memory
-
>
GetPort
(
)
<
<
"
)
failed
.
"
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
7
=
=
8
)
;
#
endif
return
false
;
}
auto
*
parent_send_port_memory_ack
=
new
ReceivePort
(
)
;
if
(
!
parent_message
.
AddDescriptor
(
MachMsgPortDescriptor
(
parent_send_port_memory_ack
-
>
GetPort
(
)
)
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
AddDescriptor
(
"
<
<
parent_send_port_memory_ack
-
>
GetPort
(
)
<
<
"
)
failed
.
"
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
8
=
=
9
)
;
#
endif
return
false
;
}
err
=
parent_sender
.
SendMessage
(
parent_message
kTimeoutMs
)
;
if
(
err
!
=
KERN_SUCCESS
)
{
std
:
:
string
errString
=
StringPrintf
(
"
0x
%
x
%
s
"
err
mach_error_string
(
err
)
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
parent
SendMessage
(
)
failed
:
"
<
<
errString
;
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
9
=
=
10
)
;
#
endif
return
false
;
}
SharedMemoryBasic
:
:
SetupMachMemory
(
process
parent_recv_port_memory
parent_recv_port_memory_ack
parent_send_port_memory
parent_send_port_memory_ack
false
)
;
#
endif
#
elif
defined
(
OS_WIN
)
FilePath
exePath
;
BinaryPathType
pathType
=
GetPathToBinary
(
exePath
mProcessType
)
;
CommandLine
cmdLine
(
exePath
.
ToWStringHack
(
)
)
;
if
(
pathType
=
=
BinaryPathType
:
:
Self
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
contentproc
"
)
)
;
}
cmdLine
.
AppendSwitchWithValue
(
switches
:
:
kProcessChannelID
channel_id
(
)
)
;
for
(
std
:
:
vector
<
std
:
:
string
>
:
:
iterator
it
=
aExtraOpts
.
begin
(
)
;
it
!
=
aExtraOpts
.
end
(
)
;
+
+
it
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
*
it
)
)
;
}
if
(
Omnijar
:
:
IsInitialized
(
)
)
{
nsAutoString
path
;
nsCOMPtr
<
nsIFile
>
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
GRE
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetPath
(
path
)
)
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
greomni
"
)
)
;
cmdLine
.
AppendLooseValue
(
path
.
get
(
)
)
;
}
file
=
Omnijar
:
:
GetPath
(
Omnijar
:
:
APP
)
;
if
(
file
&
&
NS_SUCCEEDED
(
file
-
>
GetPath
(
path
)
)
)
{
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
"
-
appomni
"
)
)
;
cmdLine
.
AppendLooseValue
(
path
.
get
(
)
)
;
}
}
#
if
defined
(
MOZ_SANDBOX
)
bool
shouldSandboxCurrentProcess
=
false
;
switch
(
mProcessType
)
{
case
GeckoProcessType_Content
:
#
if
defined
(
MOZ_CONTENT_SANDBOX
)
if
(
mSandboxLevel
>
0
)
{
mSandboxBroker
.
SetSecurityLevelForContentProcess
(
mSandboxLevel
mIsFileContent
)
;
shouldSandboxCurrentProcess
=
true
;
}
#
endif
break
;
case
GeckoProcessType_Plugin
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_NPAPI_SANDBOX
"
)
)
{
bool
ok
=
mSandboxBroker
.
SetSecurityLevelForPluginProcess
(
mSandboxLevel
)
;
if
(
!
ok
)
{
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
10
=
=
11
)
;
#
endif
return
false
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
#
ifdef
MOZ_ENABLE_SKIA_PDF
case
GeckoProcessType_PDFium
:
if
(
!
PR_GetEnv
(
"
MOZ_DISABLE_PDFIUM_SANDBOX
"
)
)
{
bool
ok
=
mSandboxBroker
.
SetSecurityLevelForPDFiumProcess
(
)
;
if
(
!
ok
)
{
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
11
=
=
12
)
;
#
endif
return
false
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
#
endif
case
GeckoProcessType_IPDLUnitTest
:
break
;
case
GeckoProcessType_GMPlugin
:
if
(
!
PR_GetEnv
(
"
MOZ_DISABLE_GMP_SANDBOX
"
)
)
{
bool
isWidevine
=
std
:
:
any_of
(
aExtraOpts
.
begin
(
)
aExtraOpts
.
end
(
)
[
]
(
const
std
:
:
string
arg
)
{
return
arg
.
find
(
"
gmp
-
widevinecdm
"
)
!
=
std
:
:
string
:
:
npos
;
}
)
;
auto
level
=
isWidevine
?
SandboxBroker
:
:
Restricted
:
SandboxBroker
:
:
LockDown
;
bool
ok
=
mSandboxBroker
.
SetSecurityLevelForGMPlugin
(
level
)
;
if
(
!
ok
)
{
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
12
=
=
13
)
;
#
endif
return
false
;
}
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_GPU
:
if
(
mSandboxLevel
>
0
&
&
!
PR_GetEnv
(
"
MOZ_DISABLE_GPU_SANDBOX
"
)
)
{
mSandboxBroker
.
SetSecurityLevelForGPUProcess
(
mSandboxLevel
)
;
shouldSandboxCurrentProcess
=
true
;
}
break
;
case
GeckoProcessType_Default
:
default
:
MOZ_CRASH
(
"
Bad
process
type
in
GeckoChildProcessHost
"
)
;
break
;
}
;
if
(
shouldSandboxCurrentProcess
)
{
for
(
auto
it
=
mAllowedFilesRead
.
begin
(
)
;
it
!
=
mAllowedFilesRead
.
end
(
)
;
+
+
it
)
{
mSandboxBroker
.
AllowReadFile
(
it
-
>
c_str
(
)
)
;
}
}
#
endif
AddAppDirToCommandLine
(
cmdLine
)
;
cmdLine
.
AppendLooseValue
(
mGroupId
.
get
(
)
)
;
if
(
mProcessType
=
=
GeckoProcessType_GPU
)
{
nsCOMPtr
<
nsIFile
>
file
;
CrashReporter
:
:
GetChildProcessTmpDir
(
getter_AddRefs
(
file
)
)
;
nsString
path
;
if
(
file
)
{
MOZ_ALWAYS_SUCCEEDS
(
file
-
>
GetPath
(
path
)
)
;
}
std
:
:
wstring
wpath
(
path
.
get
(
)
)
;
cmdLine
.
AppendLooseValue
(
wpath
)
;
}
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
pidstring
)
)
;
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
CrashReporter
:
:
GetChildNotificationPipe
(
)
)
)
;
if
(
!
CrashReporter
:
:
IsDummy
(
)
)
{
PROsfd
h
=
PR_FileDesc2NativeHandle
(
crashAnnotationWritePipe
)
;
mLaunchOptions
-
>
handles_to_inherit
.
push_back
(
reinterpret_cast
<
HANDLE
>
(
h
)
)
;
std
:
:
string
hStr
=
std
:
:
to_string
(
h
)
;
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
hStr
)
)
;
}
cmdLine
.
AppendLooseValue
(
UTF8ToWide
(
childProcessType
)
)
;
#
if
defined
(
MOZ_SANDBOX
)
if
(
shouldSandboxCurrentProcess
)
{
for
(
HANDLE
h
:
mLaunchOptions
-
>
handles_to_inherit
)
{
mSandboxBroker
.
AddHandleToShare
(
h
)
;
}
if
(
mSandboxBroker
.
LaunchApp
(
cmdLine
.
program
(
)
.
c_str
(
)
cmdLine
.
command_line_string
(
)
.
c_str
(
)
mLaunchOptions
-
>
env_map
mProcessType
mEnableSandboxLogging
&
process
)
)
{
EnvironmentLog
(
"
MOZ_PROCESS_LOG
"
)
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
(
%
S
)
\
n
"
base
:
:
GetCurrentProcId
(
)
base
:
:
GetProcId
(
process
)
cmdLine
.
command_line_string
(
)
.
c_str
(
)
)
;
}
}
else
#
endif
{
base
:
:
LaunchApp
(
cmdLine
*
mLaunchOptions
&
process
)
;
#
ifdef
MOZ_SANDBOX
if
(
mProcessType
=
=
GeckoProcessType_Content
|
|
mProcessType
=
=
GeckoProcessType_GPU
|
|
mProcessType
=
=
GeckoProcessType_GMPlugin
)
{
if
(
!
mSandboxBroker
.
AddTargetPeer
(
process
)
)
{
NS_WARNING
(
"
Failed
to
add
content
process
as
target
peer
.
"
)
;
}
}
#
endif
}
#
else
#
error
Sorry
#
endif
if
(
!
process
)
{
#
ifdef
ASYNC_CONTENTPROC_LAUNCH
MOZ_RELEASE_ASSERT
(
13
=
=
14
)
;
#
endif
return
false
;
}
#
if
defined
(
MOZ_WIDGET_COCOA
)
mChildTask
=
child_task
;
#
endif
if
(
!
OpenPrivilegedHandle
(
base
:
:
GetProcId
(
process
)
)
#
ifdef
XP_WIN
&
&
!
:
:
DuplicateHandle
(
:
:
GetCurrentProcess
(
)
process
:
:
GetCurrentProcess
(
)
&
mChildProcessHandle
PROCESS_DUP_HANDLE
|
PROCESS_TERMINATE
|
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
|
SYNCHRONIZE
FALSE
0
)
#
endif
)
{
MOZ_CRASH
(
"
cannot
open
handle
to
child
process
"
)
;
}
#
if
defined
(
XP_WIN
)
CrashReporter
:
:
RegisterChildCrashAnnotationFileDescriptor
(
base
:
:
GetProcId
(
process
)
crashAnnotationReadPipe
)
;
#
else
CrashReporter
:
:
RegisterChildCrashAnnotationFileDescriptor
(
process
crashAnnotationReadPipe
)
;
#
endif
PR_Close
(
crashAnnotationWritePipe
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_CREATED
;
lock
.
Notify
(
)
;
mLaunchOptions
=
nullptr
;
return
true
;
}
bool
GeckoChildProcessHost
:
:
OpenPrivilegedHandle
(
base
:
:
ProcessId
aPid
)
{
if
(
mChildProcessHandle
)
{
MOZ_ASSERT
(
aPid
=
=
base
:
:
GetProcId
(
mChildProcessHandle
)
)
;
return
true
;
}
return
base
:
:
OpenPrivilegedProcessHandle
(
aPid
&
mChildProcessHandle
)
;
}
void
GeckoChildProcessHost
:
:
OnProcessHandleReady
(
ProcessHandle
aProcessHandle
)
{
}
void
GeckoChildProcessHost
:
:
OnProcessLaunchError
(
)
{
}
void
GeckoChildProcessHost
:
:
OnChannelConnected
(
int32_t
peer_pid
)
{
if
(
!
OpenPrivilegedHandle
(
peer_pid
)
)
{
MOZ_CRASH
(
"
can
'
t
open
handle
to
child
process
"
)
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
mProcessState
=
PROCESS_CONNECTED
;
lock
.
Notify
(
)
;
}
void
GeckoChildProcessHost
:
:
OnMessageReceived
(
IPC
:
:
Message
&
&
aMsg
)
{
mQueue
.
push
(
std
:
:
move
(
aMsg
)
)
;
}
void
GeckoChildProcessHost
:
:
OnChannelError
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mProcessState
<
PROCESS_CONNECTED
)
{
mProcessState
=
PROCESS_ERROR
;
lock
.
Notify
(
)
;
}
}
void
GeckoChildProcessHost
:
:
GetQueuedMessages
(
std
:
:
queue
<
IPC
:
:
Message
>
&
queue
)
{
DCHECK
(
MessageLoopForIO
:
:
current
(
)
)
;
swap
(
queue
mQueue
)
;
}
bool
GeckoChildProcessHost
:
:
sRunSelfAsContentProc
(
false
)
;
#
ifdef
MOZ_WIDGET_ANDROID
void
GeckoChildProcessHost
:
:
LaunchAndroidService
(
const
char
*
type
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
base
:
:
file_handle_mapping_vector
&
fds_to_remap
ProcessHandle
*
process_handle
)
{
MOZ_RELEASE_ASSERT
(
(
2
<
=
fds_to_remap
.
size
(
)
)
&
&
(
fds_to_remap
.
size
(
)
<
=
4
)
)
;
JNIEnv
*
const
env
=
mozilla
:
:
jni
:
:
GetEnvForThread
(
)
;
MOZ_ASSERT
(
env
)
;
const
int
argvSize
=
argv
.
size
(
)
;
jni
:
:
ObjectArray
:
:
LocalRef
jargs
=
jni
:
:
ObjectArray
:
:
New
<
jni
:
:
String
>
(
argvSize
)
;
for
(
int
ix
=
0
;
ix
<
argvSize
;
ix
+
+
)
{
jargs
-
>
SetElement
(
ix
jni
:
:
StringParam
(
argv
[
ix
]
.
c_str
(
)
env
)
)
;
}
int32_t
prefsFd
=
fds_to_remap
[
0
]
.
first
;
int32_t
ipcFd
=
fds_to_remap
[
1
]
.
first
;
int32_t
crashFd
=
-
1
;
int32_t
crashAnnotationFd
=
-
1
;
if
(
fds_to_remap
.
size
(
)
=
=
3
)
{
crashAnnotationFd
=
fds_to_remap
[
2
]
.
first
;
}
if
(
fds_to_remap
.
size
(
)
=
=
4
)
{
crashFd
=
fds_to_remap
[
2
]
.
first
;
crashAnnotationFd
=
fds_to_remap
[
3
]
.
first
;
}
int32_t
handle
=
java
:
:
GeckoProcessManager
:
:
Start
(
type
jargs
prefsFd
ipcFd
crashFd
crashAnnotationFd
)
;
if
(
process_handle
)
{
*
process_handle
=
handle
;
}
}
#
endif
