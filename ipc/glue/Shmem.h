#
ifndef
mozilla_ipc_Shmem_h
#
define
mozilla_ipc_Shmem_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
layers
{
class
ShadowLayerForwarder
;
}
namespace
ipc
{
class
IProtocol
;
class
IToplevelProtocol
;
template
<
typename
P
>
struct
IPDLParamTraits
;
class
Shmem
final
{
friend
struct
IPDLParamTraits
<
mozilla
:
:
ipc
:
:
Shmem
>
;
friend
class
mozilla
:
:
ipc
:
:
IProtocol
;
friend
class
mozilla
:
:
ipc
:
:
IToplevelProtocol
;
#
ifdef
DEBUG
friend
class
mozilla
:
:
layers
:
:
ShadowLayerForwarder
;
#
endif
public
:
typedef
int32_t
id_t
;
typedef
mozilla
:
:
ipc
:
:
SharedMemory
SharedMemory
;
Shmem
(
)
:
mSegment
(
nullptr
)
mData
(
nullptr
)
mSize
(
0
)
mId
(
0
)
{
}
Shmem
(
const
Shmem
&
aOther
)
=
default
;
~
Shmem
(
)
{
forget
(
)
;
}
Shmem
&
operator
=
(
const
Shmem
&
aRhs
)
=
default
;
bool
operator
=
=
(
const
Shmem
&
aRhs
)
const
{
return
mSegment
=
=
aRhs
.
mSegment
;
}
bool
IsWritable
(
)
const
{
return
mSegment
!
=
nullptr
;
}
bool
IsReadable
(
)
const
{
return
mSegment
!
=
nullptr
;
}
template
<
typename
T
>
T
*
get
(
)
const
{
AssertInvariants
(
)
;
AssertAligned
<
T
>
(
)
;
return
reinterpret_cast
<
T
*
>
(
mData
)
;
}
template
<
typename
T
>
size_t
Size
(
)
const
{
AssertInvariants
(
)
;
AssertAligned
<
T
>
(
)
;
return
mSize
/
sizeof
(
T
)
;
}
template
<
typename
T
>
Range
<
T
>
Range
(
)
const
{
return
{
get
<
T
>
(
)
Size
<
T
>
(
)
}
;
}
private
:
Shmem
(
SharedMemory
*
aSegment
id_t
aId
)
;
id_t
Id
(
)
const
{
return
mId
;
}
SharedMemory
*
Segment
(
)
const
{
return
mSegment
;
}
#
ifndef
DEBUG
void
RevokeRights
(
)
{
}
#
else
void
RevokeRights
(
)
;
#
endif
void
forget
(
)
{
mSegment
=
nullptr
;
mData
=
nullptr
;
mSize
=
0
;
mId
=
0
;
}
static
already_AddRefed
<
Shmem
:
:
SharedMemory
>
Alloc
(
size_t
aNBytes
bool
aUnsafe
bool
aProtect
=
false
)
;
UniquePtr
<
IPC
:
:
Message
>
MkCreatedMessage
(
int32_t
routingId
)
;
UniquePtr
<
IPC
:
:
Message
>
MkDestroyedMessage
(
int32_t
routingId
)
;
static
already_AddRefed
<
SharedMemory
>
OpenExisting
(
const
IPC
:
:
Message
&
aDescriptor
id_t
*
aId
bool
aProtect
=
false
)
;
static
void
Dealloc
(
SharedMemory
*
aSegment
)
;
template
<
typename
T
>
void
AssertAligned
(
)
const
{
if
(
0
!
=
(
mSize
%
sizeof
(
T
)
)
)
MOZ_CRASH
(
"
shmem
is
not
T
-
aligned
"
)
;
}
#
if
!
defined
(
DEBUG
)
void
AssertInvariants
(
)
const
{
}
static
uint32_t
*
PtrToSize
(
SharedMemory
*
aSegment
)
{
char
*
endOfSegment
=
reinterpret_cast
<
char
*
>
(
aSegment
-
>
memory
(
)
)
+
aSegment
-
>
Size
(
)
;
return
reinterpret_cast
<
uint32_t
*
>
(
endOfSegment
-
sizeof
(
uint32_t
)
)
;
}
#
else
void
AssertInvariants
(
)
const
;
#
endif
RefPtr
<
SharedMemory
>
mSegment
;
void
*
mData
;
size_t
mSize
;
id_t
mId
;
}
;
}
}
#
endif
