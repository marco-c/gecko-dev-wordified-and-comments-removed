#
ifndef
mozilla_ipc_SharedMemoryMapping_h
#
define
mozilla_ipc_SharedMemoryMapping_h
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
SharedMemoryHandle
.
h
"
namespace
mozilla
:
:
ipc
{
namespace
shared_memory
{
struct
LeakedMapping
:
Span
<
uint8_t
>
{
using
Span
:
:
Span
;
}
;
struct
LeakedReadOnlyMapping
:
Span
<
const
uint8_t
>
{
using
Span
:
:
Span
;
}
;
class
MappingBase
{
public
:
size_t
Size
(
)
const
{
return
mSize
;
}
void
*
Address
(
)
const
;
bool
IsValid
(
)
const
{
return
(
bool
)
*
this
;
}
explicit
operator
bool
(
)
const
{
return
(
bool
)
mMemory
;
}
protected
:
MappingBase
(
)
;
MOZ_IMPLICIT
MappingBase
(
std
:
:
nullptr_t
)
{
}
~
MappingBase
(
)
{
Unmap
(
)
;
}
MappingBase
(
MappingBase
&
&
aOther
)
:
mMemory
(
std
:
:
exchange
(
aOther
.
mMemory
nullptr
)
)
mSize
(
std
:
:
exchange
(
aOther
.
mSize
0
)
)
{
}
MappingBase
&
operator
=
(
MappingBase
&
&
aOther
)
;
MappingBase
(
const
MappingBase
&
)
=
delete
;
MappingBase
&
operator
=
(
const
MappingBase
&
)
=
delete
;
bool
Map
(
const
HandleBase
&
aHandle
void
*
aFixedAddress
bool
aReadOnly
)
;
bool
MapSubregion
(
const
HandleBase
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
bool
aReadOnly
)
;
void
Unmap
(
)
;
template
<
typename
Derived
>
Derived
ConvertTo
(
)
&
&
{
Derived
d
;
static_cast
<
MappingBase
&
>
(
d
)
=
std
:
:
move
(
*
this
)
;
return
d
;
}
LeakedMapping
ReleaseMapping
(
)
&
&
;
private
:
void
*
mMemory
=
nullptr
;
size_t
mSize
=
0
;
}
;
template
<
bool
CONST_MEMORY
>
struct
MappingData
:
MappingBase
{
private
:
template
<
typename
T
>
using
DataType
=
std
:
:
conditional_t
<
CONST_MEMORY
std
:
:
add_const_t
<
std
:
:
remove_const_t
<
T
>
>
T
>
;
public
:
template
<
typename
T
>
DataType
<
T
>
*
DataAs
(
)
const
{
MOZ_ASSERT
(
(
reinterpret_cast
<
uintptr_t
>
(
Address
(
)
)
%
alignof
(
T
)
)
=
=
0
"
memory
map
does
not
meet
alignment
requirements
of
type
"
)
;
return
static_cast
<
DataType
<
T
>
*
>
(
Address
(
)
)
;
}
template
<
typename
T
>
Span
<
DataType
<
T
>
>
DataAsSpan
(
)
const
{
return
{
DataAs
<
T
>
(
)
Size
(
)
/
sizeof
(
T
)
}
;
}
}
;
struct
Mapping
:
MappingData
<
false
>
{
Mapping
(
)
=
default
;
MOZ_IMPLICIT
Mapping
(
std
:
:
nullptr_t
)
{
}
explicit
Mapping
(
const
Handle
&
aHandle
void
*
aFixedAddress
=
nullptr
)
;
Mapping
(
const
Handle
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
;
LeakedMapping
Release
(
)
&
&
{
return
std
:
:
move
(
*
this
)
.
ReleaseMapping
(
)
;
}
}
;
struct
ReadOnlyMapping
:
MappingData
<
true
>
{
ReadOnlyMapping
(
)
=
default
;
MOZ_IMPLICIT
ReadOnlyMapping
(
std
:
:
nullptr_t
)
{
}
explicit
ReadOnlyMapping
(
const
ReadOnlyHandle
&
aHandle
void
*
aFixedAddress
=
nullptr
)
;
ReadOnlyMapping
(
const
ReadOnlyHandle
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
;
LeakedReadOnlyMapping
Release
(
)
&
&
{
auto
mapping
=
std
:
:
move
(
*
this
)
.
ReleaseMapping
(
)
;
return
LeakedReadOnlyMapping
{
mapping
.
data
(
)
mapping
.
size
(
)
}
;
}
}
;
struct
FreezableMapping
:
MappingData
<
false
>
{
FreezableMapping
(
)
=
default
;
MOZ_IMPLICIT
FreezableMapping
(
std
:
:
nullptr_t
)
{
}
explicit
FreezableMapping
(
FreezableHandle
&
&
aHandle
void
*
aFixedAddress
=
nullptr
)
;
FreezableMapping
(
FreezableHandle
&
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
;
std
:
:
tuple
<
Mapping
ReadOnlyHandle
>
Freeze
(
)
&
&
;
FreezableHandle
Unmap
(
)
&
&
;
private
:
FreezableHandle
mHandle
;
}
;
enum
Access
{
AccessNone
=
0
AccessRead
=
1
<
<
0
AccessWrite
=
1
<
<
1
AccessReadWrite
=
AccessRead
|
AccessWrite
}
;
bool
LocalProtect
(
char
*
aAddr
size_t
aSize
Access
aAccess
)
;
void
*
FindFreeAddressSpace
(
size_t
aSize
)
;
size_t
SystemPageSize
(
)
;
size_t
SystemAllocationGranularity
(
)
;
size_t
PageAlignedSize
(
size_t
aMinimum
)
;
}
using
SharedMemoryMapping
=
shared_memory
:
:
Mapping
;
using
ReadOnlySharedMemoryMapping
=
shared_memory
:
:
ReadOnlyMapping
;
using
FreezableSharedMemoryMapping
=
shared_memory
:
:
FreezableMapping
;
}
#
endif
