#
ifndef
mozilla_ipc_SharedMemoryMapping_h
#
define
mozilla_ipc_SharedMemoryMapping_h
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
SharedMemoryHandle
.
h
"
namespace
mozilla
:
:
ipc
{
namespace
shared_memory
{
template
<
Type
T
>
struct
LeakedMapping
:
Span
<
uint8_t
>
{
using
Span
:
:
Span
;
}
;
template
<
>
struct
LeakedMapping
<
Type
:
:
ReadOnly
>
:
Span
<
const
uint8_t
>
{
using
Span
:
:
Span
;
}
;
using
LeakedMutableMapping
=
LeakedMapping
<
Type
:
:
Mutable
>
;
using
LeakedReadOnlyMapping
=
LeakedMapping
<
Type
:
:
ReadOnly
>
;
class
MappingBase
{
public
:
size_t
Size
(
)
const
{
return
mSize
;
}
void
*
Address
(
)
const
;
bool
IsValid
(
)
const
{
return
(
bool
)
*
this
;
}
explicit
operator
bool
(
)
const
{
return
(
bool
)
mMemory
;
}
protected
:
MappingBase
(
)
;
MOZ_IMPLICIT
MappingBase
(
std
:
:
nullptr_t
)
{
}
~
MappingBase
(
)
{
Unmap
(
)
;
}
MappingBase
(
MappingBase
&
&
aOther
)
:
mMemory
(
std
:
:
exchange
(
aOther
.
mMemory
nullptr
)
)
mSize
(
std
:
:
exchange
(
aOther
.
mSize
0
)
)
{
}
MappingBase
&
operator
=
(
MappingBase
&
&
aOther
)
;
MappingBase
(
const
MappingBase
&
)
=
delete
;
MappingBase
&
operator
=
(
const
MappingBase
&
)
=
delete
;
bool
Map
(
const
HandleBase
&
aHandle
void
*
aFixedAddress
bool
aReadOnly
)
;
bool
MapSubregion
(
const
HandleBase
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
bool
aReadOnly
)
;
void
Unmap
(
)
;
template
<
Type
T
Type
S
>
static
Mapping
<
T
>
ConvertMappingTo
(
Mapping
<
S
>
&
&
from
)
{
Mapping
<
T
>
to
;
static_cast
<
MappingBase
&
>
(
to
)
=
std
:
:
move
(
from
)
;
return
to
;
}
std
:
:
tuple
<
void
*
size_t
>
Release
(
)
&
&
;
private
:
void
*
mMemory
=
nullptr
;
size_t
mSize
=
0
;
}
;
template
<
bool
CONST_MEMORY
>
struct
MappingData
:
MappingBase
{
private
:
template
<
typename
T
>
using
DataType
=
std
:
:
conditional_t
<
CONST_MEMORY
std
:
:
add_const_t
<
std
:
:
remove_const_t
<
T
>
>
T
>
;
public
:
template
<
typename
T
>
DataType
<
T
>
*
DataAs
(
)
const
{
MOZ_ASSERT
(
(
reinterpret_cast
<
uintptr_t
>
(
Address
(
)
)
%
alignof
(
T
)
)
=
=
0
"
memory
map
does
not
meet
alignment
requirements
of
type
"
)
;
return
static_cast
<
DataType
<
T
>
*
>
(
Address
(
)
)
;
}
template
<
typename
T
>
Span
<
DataType
<
T
>
>
DataAsSpan
(
)
const
{
return
{
DataAs
<
T
>
(
)
Size
(
)
/
sizeof
(
T
)
}
;
}
}
;
template
<
Type
T
>
struct
Mapping
<
T
>
:
MappingData
<
T
=
=
Type
:
:
ReadOnly
>
{
Mapping
(
)
=
default
;
MOZ_IMPLICIT
Mapping
(
std
:
:
nullptr_t
)
{
}
explicit
Mapping
(
const
Handle
<
T
>
&
aHandle
void
*
aFixedAddress
=
nullptr
)
{
MappingBase
:
:
Map
(
aHandle
aFixedAddress
T
=
=
Type
:
:
ReadOnly
)
;
}
Mapping
(
const
Handle
<
T
>
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
{
MappingBase
:
:
MapSubregion
(
aHandle
aOffset
aSize
aFixedAddress
T
=
=
Type
:
:
ReadOnly
)
;
}
LeakedMapping
<
T
>
Release
(
)
&
&
{
auto
[
ptr
size
]
=
std
:
:
move
(
*
this
)
.
MappingBase
:
:
Release
(
)
;
return
LeakedMapping
<
T
>
{
static_cast
<
typename
LeakedMapping
<
T
>
:
:
pointer
>
(
ptr
)
size
}
;
}
}
;
template
<
>
struct
Mapping
<
Type
:
:
Freezable
>
:
MappingData
<
false
>
{
Mapping
(
)
=
default
;
MOZ_IMPLICIT
Mapping
(
std
:
:
nullptr_t
)
{
}
explicit
Mapping
(
FreezableHandle
&
&
aHandle
void
*
aFixedAddress
=
nullptr
)
;
Mapping
(
FreezableHandle
&
&
aHandle
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
;
std
:
:
tuple
<
MutableMapping
ReadOnlyHandle
>
Freeze
(
)
&
&
;
FreezableHandle
Unmap
(
)
&
&
;
protected
:
FreezableHandle
mHandle
;
}
;
template
<
Type
T
>
struct
Mapping
<
T
true
>
:
public
Mapping
<
T
>
{
Mapping
(
)
{
}
MOZ_IMPLICIT
Mapping
(
std
:
:
nullptr_t
)
:
Mapping
<
T
>
(
nullptr
)
{
}
explicit
Mapping
(
Handle
<
T
>
&
&
aHandle
void
*
aFixedAddress
=
nullptr
)
:
Mapping
<
T
>
(
aHandle
aFixedAddress
)
mHandle
(
std
:
:
move
(
aHandle
)
)
{
}
const
Handle
<
T
>
&
Handle
(
)
const
{
return
mHandle
;
}
;
std
:
:
tuple
<
shared_memory
:
:
Handle
<
T
>
Mapping
<
T
>
>
Split
(
)
&
&
{
auto
handle
=
std
:
:
move
(
mHandle
)
;
return
std
:
:
make_tuple
(
std
:
:
move
(
handle
)
std
:
:
move
(
*
this
)
)
;
}
private
:
shared_memory
:
:
Handle
<
T
>
mHandle
;
}
;
template
<
>
struct
Mapping
<
Type
:
:
Freezable
true
>
;
enum
Access
{
AccessNone
=
0
AccessRead
=
1
<
<
0
AccessWrite
=
1
<
<
1
AccessReadWrite
=
AccessRead
|
AccessWrite
}
;
bool
LocalProtect
(
char
*
aAddr
size_t
aSize
Access
aAccess
)
;
void
*
FindFreeAddressSpace
(
size_t
aSize
)
;
size_t
SystemPageSize
(
)
;
size_t
SystemAllocationGranularity
(
)
;
size_t
PageAlignedSize
(
size_t
aMinimum
)
;
}
using
SharedMemoryMapping
=
shared_memory
:
:
MutableMapping
;
using
ReadOnlySharedMemoryMapping
=
shared_memory
:
:
ReadOnlyMapping
;
using
FreezableSharedMemoryMapping
=
shared_memory
:
:
FreezableMapping
;
using
SharedMemoryMappingWithHandle
=
shared_memory
:
:
MutableMappingWithHandle
;
using
ReadOnlySharedMemoryMappingWithHandle
=
shared_memory
:
:
ReadOnlyMappingWithHandle
;
}
#
endif
