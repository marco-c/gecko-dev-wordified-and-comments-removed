#
include
"
IPCStreamSource
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsICancelableRunnable
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsStreamUtils
.
h
"
using
mozilla
:
:
dom
:
:
workers
:
:
Canceling
;
using
mozilla
:
:
dom
:
:
workers
:
:
GetCurrentThreadWorkerPrivate
;
using
mozilla
:
:
dom
:
:
workers
:
:
Status
;
using
mozilla
:
:
dom
:
:
workers
:
:
WorkerPrivate
;
namespace
mozilla
{
namespace
ipc
{
class
IPCStreamSource
:
:
Callback
final
:
public
nsIInputStreamCallback
public
nsIRunnable
public
nsICancelableRunnable
{
public
:
explicit
Callback
(
IPCStreamSource
*
aSource
)
:
mSource
(
aSource
)
mOwningThread
(
NS_GetCurrentThread
(
)
)
{
MOZ_ASSERT
(
mSource
)
;
}
NS_IMETHOD
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
override
{
if
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
{
return
Run
(
)
;
}
nsresult
rv
=
mOwningThread
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
stream
readable
event
to
owning
thread
"
)
;
}
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
;
if
(
mSource
)
{
mSource
-
>
OnStreamReady
(
this
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
return
NS_OK
;
}
void
ClearSource
(
)
{
MOZ_ASSERT
(
mOwningThread
=
=
NS_GetCurrentThread
(
)
)
;
MOZ_ASSERT
(
mSource
)
;
mSource
=
nullptr
;
}
private
:
~
Callback
(
)
{
MOZ_ASSERT
(
!
mSource
)
;
}
IPCStreamSource
*
mSource
;
nsCOMPtr
<
nsIThread
>
mOwningThread
;
NS_DECL_THREADSAFE_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
IPCStreamSource
:
:
Callback
nsIInputStreamCallback
nsIRunnable
nsICancelableRunnable
)
;
IPCStreamSource
:
:
IPCStreamSource
(
nsIAsyncInputStream
*
aInputStream
)
:
mStream
(
aInputStream
)
mWorkerPrivate
(
nullptr
)
mState
(
ePending
)
{
MOZ_ASSERT
(
aInputStream
)
;
}
IPCStreamSource
:
:
~
IPCStreamSource
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
}
bool
IPCStreamSource
:
:
Initialize
(
)
{
bool
nonBlocking
=
false
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mStream
-
>
IsNonBlocking
(
&
nonBlocking
)
)
)
;
if
(
!
nonBlocking
)
{
return
false
;
}
WorkerPrivate
*
workerPrivate
=
nullptr
;
if
(
!
NS_IsMainThread
(
)
)
{
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
if
(
workerPrivate
)
{
bool
result
=
HoldWorker
(
workerPrivate
Canceling
)
;
if
(
!
result
)
{
return
false
;
}
mWorkerPrivate
=
workerPrivate
;
}
else
{
AssertIsOnBackgroundThread
(
)
;
}
}
return
true
;
}
void
IPCStreamSource
:
:
ActorConstructed
(
)
{
MOZ_ASSERT
(
mState
=
=
ePending
)
;
mState
=
eActorConstructed
;
}
bool
IPCStreamSource
:
:
Notify
(
Status
aStatus
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
return
true
;
}
void
IPCStreamSource
:
:
ActorDestroyed
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
mState
=
eClosed
;
if
(
mCallback
)
{
mCallback
-
>
ClearSource
(
)
;
mCallback
=
nullptr
;
}
if
(
mWorkerPrivate
)
{
ReleaseWorker
(
)
;
mWorkerPrivate
=
nullptr
;
}
}
void
IPCStreamSource
:
:
Start
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
DoRead
(
)
;
}
void
IPCStreamSource
:
:
StartDestroy
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
OnEnd
(
NS_ERROR_ABORT
)
;
}
void
IPCStreamSource
:
:
DoRead
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mState
=
=
eActorConstructed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
static
const
uint64_t
kMaxBytesPerMessage
=
32
*
1024
;
static_assert
(
kMaxBytesPerMessage
<
=
static_cast
<
uint64_t
>
(
UINT32_MAX
)
"
kMaxBytesPerMessage
must
cleanly
cast
to
uint32_t
"
)
;
while
(
true
)
{
MOZ_ASSERT
(
mState
=
=
eActorConstructed
)
;
nsCString
buffer
;
uint64_t
available
=
0
;
nsresult
rv
=
mStream
-
>
Available
(
&
available
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnEnd
(
rv
)
;
return
;
}
if
(
available
=
=
0
)
{
Wait
(
)
;
return
;
}
uint32_t
expectedBytes
=
static_cast
<
uint32_t
>
(
std
:
:
min
(
available
kMaxBytesPerMessage
)
)
;
buffer
.
SetLength
(
expectedBytes
)
;
uint32_t
bytesRead
=
0
;
rv
=
mStream
-
>
Read
(
buffer
.
BeginWriting
(
)
buffer
.
Length
(
)
&
bytesRead
)
;
MOZ_ASSERT_IF
(
NS_FAILED
(
rv
)
bytesRead
=
=
0
)
;
buffer
.
SetLength
(
bytesRead
)
;
if
(
!
buffer
.
IsEmpty
(
)
)
{
SendData
(
buffer
)
;
}
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
Wait
(
)
;
return
;
}
if
(
NS_FAILED
(
rv
)
|
|
buffer
.
IsEmpty
(
)
)
{
OnEnd
(
rv
)
;
return
;
}
}
}
void
IPCStreamSource
:
:
Wait
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mState
=
=
eActorConstructed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
mCallback
=
new
Callback
(
this
)
;
nsresult
rv
=
mStream
-
>
AsyncWait
(
mCallback
0
0
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnEnd
(
rv
)
;
return
;
}
}
void
IPCStreamSource
:
:
OnStreamReady
(
Callback
*
aCallback
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mCallback
)
;
MOZ_ASSERT
(
aCallback
=
=
mCallback
)
;
mCallback
-
>
ClearSource
(
)
;
mCallback
=
nullptr
;
DoRead
(
)
;
}
void
IPCStreamSource
:
:
OnEnd
(
nsresult
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
aRv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
;
if
(
mState
=
=
eClosed
)
{
return
;
}
mState
=
eClosed
;
mStream
-
>
CloseWithStatus
(
aRv
)
;
if
(
aRv
=
=
NS_BASE_STREAM_CLOSED
)
{
aRv
=
NS_OK
;
}
Close
(
aRv
)
;
}
}
}
