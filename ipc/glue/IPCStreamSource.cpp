#
include
"
IPCStreamSource
.
h
"
#
include
"
BackgroundParent
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerService
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsICancelableRunnable
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIThread
.
h
"
using
mozilla
:
:
wr
:
:
ByteBuffer
;
namespace
mozilla
{
namespace
ipc
{
class
IPCStreamSource
:
:
Callback
final
:
public
DiscardableRunnable
public
nsIInputStreamCallback
{
public
:
explicit
Callback
(
IPCStreamSource
*
aSource
)
:
DiscardableRunnable
(
"
IPCStreamSource
:
:
Callback
"
)
mSource
(
aSource
)
mOwningEventTarget
(
GetCurrentSerialEventTarget
(
)
)
{
MOZ_ASSERT
(
mSource
)
;
}
NS_IMETHOD
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
override
{
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
return
Run
(
)
;
}
nsresult
rv
=
mOwningEventTarget
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
stream
readable
event
to
owning
thread
"
)
;
}
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mSource
)
{
mSource
-
>
OnStreamReady
(
this
)
;
}
return
NS_OK
;
}
void
ClearSource
(
)
{
MOZ_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_ASSERT
(
mSource
)
;
mSource
=
nullptr
;
}
private
:
~
Callback
(
)
{
MOZ_ASSERT
(
!
mSource
)
;
}
IPCStreamSource
*
mSource
;
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
NS_DECL_ISUPPORTS_INHERITED
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
IPCStreamSource
:
:
Callback
DiscardableRunnable
nsIInputStreamCallback
)
;
IPCStreamSource
:
:
IPCStreamSource
(
nsIAsyncInputStream
*
aInputStream
)
:
mStream
(
aInputStream
)
mState
(
ePending
)
{
MOZ_ASSERT
(
aInputStream
)
;
}
IPCStreamSource
:
:
~
IPCStreamSource
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mState
=
=
eClosed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
MOZ_ASSERT
(
!
mWorkerRef
)
;
}
bool
IPCStreamSource
:
:
Initialize
(
)
{
bool
nonBlocking
=
false
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mStream
-
>
IsNonBlocking
(
&
nonBlocking
)
)
)
;
if
(
!
nonBlocking
)
{
return
false
;
}
if
(
!
NS_IsMainThread
(
)
)
{
if
(
const
auto
workerPrivate
=
dom
:
:
GetCurrentThreadWorkerPrivate
(
)
)
{
RefPtr
<
dom
:
:
StrongWorkerRef
>
workerRef
=
dom
:
:
StrongWorkerRef
:
:
CreateForcibly
(
workerPrivate
"
IPCStreamSource
"
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
return
false
;
}
mWorkerRef
=
std
:
:
move
(
workerRef
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
IsOnBackgroundThread
(
)
|
|
dom
:
:
RemoteWorkerService
:
:
Thread
(
)
-
>
IsOnCurrentThread
(
)
)
;
}
}
return
true
;
}
void
IPCStreamSource
:
:
ActorConstructed
(
)
{
MOZ_ASSERT
(
mState
=
=
ePending
)
;
mState
=
eActorConstructed
;
}
void
IPCStreamSource
:
:
ActorDestroyed
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
mState
=
eClosed
;
if
(
mCallback
)
{
mCallback
-
>
ClearSource
(
)
;
mCallback
=
nullptr
;
}
mWorkerRef
=
nullptr
;
}
void
IPCStreamSource
:
:
Start
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
DoRead
(
)
;
}
void
IPCStreamSource
:
:
StartDestroy
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
OnEnd
(
NS_ERROR_ABORT
)
;
}
void
IPCStreamSource
:
:
DoRead
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mState
=
=
eActorConstructed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
static
const
uint64_t
kMaxBytesPerMessage
=
32
*
1024
;
static_assert
(
kMaxBytesPerMessage
<
=
static_cast
<
uint64_t
>
(
UINT32_MAX
)
"
kMaxBytesPerMessage
must
cleanly
cast
to
uint32_t
"
)
;
UniquePtr
<
char
[
]
>
buffer
(
new
char
[
kMaxBytesPerMessage
]
)
;
while
(
true
)
{
MOZ_ASSERT
(
mState
=
=
eActorConstructed
)
;
uint64_t
dummy
;
nsresult
rv
=
mStream
-
>
Available
(
&
dummy
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnEnd
(
rv
)
;
return
;
}
uint32_t
bytesRead
=
0
;
rv
=
mStream
-
>
Read
(
buffer
.
get
(
)
kMaxBytesPerMessage
&
bytesRead
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
MOZ_ASSERT
(
bytesRead
=
=
0
)
;
Wait
(
)
;
return
;
}
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
bytesRead
=
=
0
)
;
OnEnd
(
rv
)
;
return
;
}
if
(
bytesRead
=
=
0
)
{
OnEnd
(
NS_BASE_STREAM_CLOSED
)
;
return
;
}
SendData
(
ByteBuffer
(
bytesRead
reinterpret_cast
<
uint8_t
*
>
(
buffer
.
get
(
)
)
)
)
;
}
}
void
IPCStreamSource
:
:
Wait
(
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mState
=
=
eActorConstructed
)
;
MOZ_ASSERT
(
!
mCallback
)
;
mCallback
=
new
Callback
(
this
)
;
nsresult
rv
=
mStream
-
>
AsyncWait
(
mCallback
0
0
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnEnd
(
rv
)
;
return
;
}
}
void
IPCStreamSource
:
:
OnStreamReady
(
Callback
*
aCallback
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
mCallback
)
;
MOZ_ASSERT
(
aCallback
=
=
mCallback
)
;
mCallback
-
>
ClearSource
(
)
;
mCallback
=
nullptr
;
if
(
mState
=
=
eClosed
)
{
return
;
}
DoRead
(
)
;
}
void
IPCStreamSource
:
:
OnEnd
(
nsresult
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
IPCStreamSource
)
;
MOZ_ASSERT
(
aRv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
;
if
(
mState
=
=
eClosed
)
{
return
;
}
mState
=
eClosed
;
mStream
-
>
CloseWithStatus
(
aRv
)
;
if
(
aRv
=
=
NS_BASE_STREAM_CLOSED
)
{
aRv
=
NS_OK
;
}
Close
(
aRv
)
;
}
}
}
