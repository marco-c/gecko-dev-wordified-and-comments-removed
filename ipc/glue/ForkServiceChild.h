#
ifndef
__FORKSERVICE_CHILD_H_
#
define
__FORKSERVICE_CHILD_H_
#
include
"
nsIObserver
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ipc
/
MiniTransceiver
.
h
"
#
include
<
sys
/
types
.
h
>
#
include
<
poll
.
h
>
namespace
mozilla
{
namespace
ipc
{
class
GeckoChildProcessHost
;
class
ForkServiceChild
{
public
:
ForkServiceChild
(
int
aFd
GeckoChildProcessHost
*
aProcess
)
;
virtual
~
ForkServiceChild
(
)
;
bool
SendForkNewSubprocess
(
const
nsTArray
<
nsCString
>
&
aArgv
const
nsTArray
<
EnvVar
>
&
aEnvMap
const
nsTArray
<
FdMapping
>
&
aFdsRemap
pid_t
*
aPid
)
;
static
void
StartForkServer
(
)
;
static
void
StopForkServer
(
)
;
static
ForkServiceChild
*
Get
(
)
{
auto
child
=
sForkServiceChild
.
get
(
)
;
return
child
=
=
nullptr
|
|
child
-
>
mFailed
?
nullptr
:
child
;
}
private
:
void
OnMessageReceived
(
IPC
:
:
Message
&
&
message
)
;
void
OnError
(
)
;
UniquePtr
<
MiniTransceiver
>
mTcver
;
static
UniquePtr
<
ForkServiceChild
>
sForkServiceChild
;
pid_t
mRecvPid
;
bool
mWaitForHello
;
bool
mFailed
;
GeckoChildProcessHost
*
mProcess
;
}
;
class
ForkServerLauncher
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
ForkServerLauncher
(
)
;
static
already_AddRefed
<
ForkServerLauncher
>
Create
(
)
;
private
:
friend
class
ForkServiceChild
;
virtual
~
ForkServerLauncher
(
)
;
static
void
RestartForkServer
(
)
;
static
bool
mHaveStartedClient
;
static
StaticRefPtr
<
ForkServerLauncher
>
mSingleton
;
}
;
}
}
#
endif
