#
ifndef
__FORKSERVICE_CHILD_H_
#
define
__FORKSERVICE_CHILD_H_
#
include
"
base
/
process_util
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ipc
/
MiniTransceiver
.
h
"
#
include
"
mozilla
/
ipc
/
LaunchError
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
<
sys
/
types
.
h
>
#
include
<
poll
.
h
>
namespace
mozilla
{
namespace
ipc
{
class
GeckoChildProcessHost
;
class
ForkServiceChild
{
public
:
ForkServiceChild
(
int
aFd
GeckoChildProcessHost
*
aProcess
)
;
virtual
~
ForkServiceChild
(
)
;
struct
Args
{
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
int
mForkFlags
=
0
;
bool
mChroot
=
false
;
#
endif
nsTArray
<
nsCString
>
mArgv
;
nsTArray
<
EnvVar
>
mEnv
;
nsTArray
<
FdMapping
>
mFdsRemap
;
}
;
Result
<
Ok
LaunchError
>
SendForkNewSubprocess
(
const
Args
&
aArgs
pid_t
*
aPid
)
;
static
void
StartForkServer
(
)
;
static
void
StopForkServer
(
)
;
static
ForkServiceChild
*
Get
(
)
{
auto
child
=
sForkServiceChild
.
get
(
)
;
return
child
=
=
nullptr
|
|
child
-
>
mFailed
?
nullptr
:
child
;
}
static
bool
WasUsed
(
)
{
return
sForkServiceUsed
;
}
private
:
void
OnMessageReceived
(
UniquePtr
<
IPC
:
:
Message
>
message
)
;
void
OnError
(
)
;
UniquePtr
<
MiniTransceiver
>
mTcver
;
static
UniquePtr
<
ForkServiceChild
>
sForkServiceChild
;
static
Atomic
<
bool
>
sForkServiceUsed
;
pid_t
mRecvPid
;
bool
mFailed
;
GeckoChildProcessHost
*
mProcess
;
}
;
class
ForkServerLauncher
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
ForkServerLauncher
(
)
;
static
already_AddRefed
<
ForkServerLauncher
>
Create
(
)
;
private
:
friend
class
ForkServiceChild
;
virtual
~
ForkServerLauncher
(
)
;
static
void
RestartForkServer
(
)
;
static
bool
mHaveStartedClient
;
static
StaticRefPtr
<
ForkServerLauncher
>
mSingleton
;
}
;
}
}
#
endif
