#
include
"
CrossProcessMutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryHandle
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
{
struct
MutexData
{
pthread_mutex_t
mMutex
;
mozilla
:
:
Atomic
<
int32_t
>
mCount
;
}
;
}
namespace
mozilla
{
static
void
InitMutex
(
pthread_mutex_t
*
mMutex
)
{
pthread_mutexattr_t
mutexAttributes
;
pthread_mutexattr_init
(
&
mutexAttributes
)
;
if
(
pthread_mutexattr_settype
(
&
mutexAttributes
PTHREAD_MUTEX_RECURSIVE
)
)
{
MOZ_CRASH
(
)
;
}
if
(
pthread_mutexattr_setpshared
(
&
mutexAttributes
PTHREAD_PROCESS_SHARED
)
)
{
MOZ_CRASH
(
)
;
}
if
(
pthread_mutex_init
(
mMutex
&
mutexAttributes
)
)
{
MOZ_CRASH
(
)
;
}
}
CrossProcessMutex
:
:
CrossProcessMutex
(
const
char
*
)
:
mMutex
(
nullptr
)
mCount
(
nullptr
)
{
#
if
defined
(
MOZ_SANDBOX
)
MOZ_RELEASE_ASSERT
(
false
)
;
#
endif
mSharedBuffer
=
ipc
:
:
shared_memory
:
:
Create
(
sizeof
(
MutexData
)
)
.
MapWithHandle
(
)
;
if
(
!
mSharedBuffer
)
{
MOZ_CRASH
(
)
;
}
MutexData
*
data
=
mSharedBuffer
.
DataAs
<
MutexData
>
(
)
;
if
(
!
data
)
{
MOZ_CRASH
(
)
;
}
mMutex
=
&
(
data
-
>
mMutex
)
;
mCount
=
&
(
data
-
>
mCount
)
;
*
mCount
=
1
;
InitMutex
(
mMutex
)
;
MOZ_COUNT_CTOR
(
CrossProcessMutex
)
;
}
CrossProcessMutex
:
:
CrossProcessMutex
(
CrossProcessMutexHandle
aHandle
)
:
mMutex
(
nullptr
)
mCount
(
nullptr
)
{
mSharedBuffer
=
std
:
:
move
(
aHandle
)
.
MapWithHandle
(
)
;
if
(
!
mSharedBuffer
)
{
MOZ_CRASH
(
)
;
}
MutexData
*
data
=
mSharedBuffer
.
DataAs
<
MutexData
>
(
)
;
if
(
!
data
)
{
MOZ_CRASH
(
)
;
}
mMutex
=
&
(
data
-
>
mMutex
)
;
mCount
=
&
(
data
-
>
mCount
)
;
int32_t
count
=
(
*
mCount
)
+
+
;
if
(
count
=
=
0
)
{
InitMutex
(
mMutex
)
;
}
MOZ_COUNT_CTOR
(
CrossProcessMutex
)
;
}
CrossProcessMutex
:
:
~
CrossProcessMutex
(
)
{
int32_t
count
=
-
-
(
*
mCount
)
;
if
(
count
=
=
0
)
{
Unused
<
<
pthread_mutex_destroy
(
mMutex
)
;
}
MOZ_COUNT_DTOR
(
CrossProcessMutex
)
;
}
void
CrossProcessMutex
:
:
Lock
(
)
{
MOZ_ASSERT
(
*
mCount
>
0
"
Attempting
to
lock
mutex
with
zero
ref
count
"
)
;
pthread_mutex_lock
(
mMutex
)
;
}
void
CrossProcessMutex
:
:
Unlock
(
)
{
MOZ_ASSERT
(
*
mCount
>
0
"
Attempting
to
unlock
mutex
with
zero
ref
count
"
)
;
pthread_mutex_unlock
(
mMutex
)
;
}
CrossProcessMutexHandle
CrossProcessMutex
:
:
CloneHandle
(
)
{
if
(
mSharedBuffer
)
{
auto
handle
=
mSharedBuffer
.
Handle
(
)
.
Clone
(
)
;
if
(
!
handle
)
{
MOZ_CRASH
(
)
;
}
return
handle
;
}
return
nullptr
;
}
}
