"
use
strict
"
;
SimpleTest
.
requestCompleteLog
(
)
;
function
untilChildProcessDead
(
pid
)
{
return
utilityProcessTest
(
)
.
untilChildProcessDead
(
pid
)
;
}
async
function
fileDialogProcessExists
(
)
{
return
!
!
(
await
tryGetUtilityPid
(
"
windowsFileDialog
"
)
)
;
}
function
untilFileDialogProcessExists
(
options
=
{
maxTime
:
2000
}
)
{
const
maxTime
=
options
.
maxTime
?
?
2000
pollTime
=
options
.
pollTime
?
?
100
;
const
count
=
maxTime
/
pollTime
;
return
TestUtils
.
waitForCondition
(
(
)
=
>
tryGetUtilityPid
(
"
windowsFileDialog
"
{
quiet
:
true
}
)
"
waiting
for
file
dialog
process
"
pollTime
count
)
;
}
function
openFileDialog
(
)
{
const
process
=
(
async
(
)
=
>
{
await
untilFileDialogProcessExists
(
)
;
let
pid
=
await
tryGetUtilityPid
(
"
windowsFileDialog
"
)
;
ok
(
pid
pid
should
be
acquired
in
openFileDialog
:
:
process
(
got
{
pid
}
)
)
;
await
new
Promise
(
res
=
>
setTimeout
(
res
1000
)
)
;
return
pid
;
}
)
(
)
;
const
file
=
new
Promise
(
resolve
=
>
{
info
(
"
Opening
Windows
file
dialog
"
)
;
let
fp
=
Cc
[
"
mozilla
.
org
/
filepicker
;
1
"
]
.
createInstance
(
Ci
.
nsIFilePicker
)
;
fp
.
init
(
window
.
browsingContext
"
Test
:
browser_utility_filepicker_crashed
.
js
"
fp
.
modeOpen
)
;
fp
.
open
(
result
=
>
{
Assert
.
equal
(
result
fp
.
returnCancel
"
filepicker
should
resolve
to
cancellation
"
)
;
resolve
(
)
;
}
)
;
}
)
;
return
{
process
file
}
;
}
add_setup
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
widget
.
windows
.
utility_process_file_picker
"
2
]
]
}
)
;
}
)
;
function
makeTask
(
description
Describe
action
)
{
let
task
=
async
function
(
)
{
if
(
await
fileDialogProcessExists
(
)
)
{
ok
(
false
"
another
test
has
a
file
dialog
open
;
aborting
"
)
;
return
;
}
const
{
process
file
}
=
openFileDialog
(
)
;
const
pid
=
await
process
;
const
untilDead
=
untilChildProcessDead
(
pid
)
;
info
(
Describe
+
"
the
file
-
dialog
utility
process
"
)
;
await
action
(
)
;
const
_before
=
Date
.
now
(
)
;
await
file
;
const
_after
=
Date
.
now
(
)
;
const
delta
=
_after
-
_before
;
info
(
file
callback
resolved
after
{
description
}
after
{
delta
}
ms
)
;
await
untilDead
;
}
;
Object
.
defineProperty
(
task
"
name
"
{
value
:
"
testFileDialogProcess
-
"
+
Describe
.
replace
(
"
"
"
"
)
}
)
;
return
task
;
}
for
(
let
[
description
Describe
action
]
of
[
[
"
crash
"
"
Crash
"
(
)
=
>
crashSomeUtilityActor
(
"
windowsFileDialog
"
)
]
[
"
being
killed
"
"
Kill
"
(
)
=
>
cleanUtilityProcessShutdown
(
"
windowsFileDialog
"
true
)
]
]
)
{
add_task
(
makeTask
(
description
Describe
action
)
)
;
add_task
(
testCleanup
)
;
}
async
function
testCleanup
(
)
{
const
killFileDialogProcess
=
async
(
)
=
>
{
if
(
await
tryGetUtilityPid
(
"
windowsFileDialog
"
{
quiet
:
true
}
)
)
{
await
cleanUtilityProcessShutdown
(
"
windowsFileDialog
"
true
)
;
return
true
;
}
return
false
;
}
;
if
(
await
killFileDialogProcess
(
)
)
{
console
.
warn
(
"
File
dialog
process
found
and
killed
"
)
;
return
;
}
info
(
"
Active
file
dialog
process
not
found
;
waiting
.
.
.
"
)
;
try
{
await
untilFileDialogProcessExists
(
{
maxTime
:
1000
}
)
;
}
catch
(
e
)
{
info
(
"
File
dialog
process
not
found
during
cleanup
(
as
expected
)
"
)
;
return
;
}
await
killFileDialogProcess
(
)
;
console
.
warn
(
"
Delayed
file
dialog
process
found
and
killed
"
)
;
}
