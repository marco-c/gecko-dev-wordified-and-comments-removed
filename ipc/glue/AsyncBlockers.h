#
ifndef
mozilla_ipc_AsyncBlockers_h
#
define
mozilla_ipc_AsyncBlockers_h
namespace
mozilla
:
:
ipc
{
class
AsyncBlockers
{
public
:
AsyncBlockers
(
)
:
mLock
(
"
AsyncRegistrar
"
)
mPromise
(
new
GenericPromise
:
:
Private
(
__func__
)
)
{
}
void
Register
(
void
*
aBlocker
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mResolved
)
{
return
;
}
mBlockers
.
insert
(
{
aBlocker
true
}
)
;
}
void
Deregister
(
void
*
aBlocker
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mResolved
)
{
return
;
}
auto
it
=
mBlockers
.
find
(
aBlocker
)
;
MOZ_ASSERT
(
it
!
=
mBlockers
.
end
(
)
)
;
mBlockers
.
erase
(
it
)
;
MaybeResolve
(
)
;
}
RefPtr
<
GenericPromise
>
WaitUntilClear
(
uint32_t
aTimeOutInMs
=
0
)
{
if
(
!
aTimeOutInMs
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
!
mResolved
)
{
mPromise
-
>
Resolve
(
true
__func__
)
;
mResolved
=
true
;
}
}
else
{
GetCurrentEventTarget
(
)
-
>
DelayedDispatch
(
NS_NewRunnableFunction
(
"
AsyncBlockers
:
:
WaitUntilClear
"
[
promise
=
mPromise
]
(
)
{
promise
-
>
Resolve
(
true
__func__
)
;
}
)
aTimeOutInMs
)
;
}
return
mPromise
;
}
virtual
~
AsyncBlockers
(
)
{
if
(
!
mResolved
)
{
mPromise
-
>
Resolve
(
true
__func__
)
;
}
}
private
:
void
MaybeResolve
(
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mResolved
)
{
return
;
}
if
(
!
mBlockers
.
empty
(
)
)
{
return
;
}
mPromise
-
>
Resolve
(
true
__func__
)
;
mResolved
=
true
;
}
Mutex
mLock
MOZ_UNANNOTATED
;
std
:
:
map
<
void
*
bool
>
mBlockers
;
bool
mResolved
=
false
;
const
RefPtr
<
GenericPromise
:
:
Private
>
mPromise
;
}
;
}
#
endif
