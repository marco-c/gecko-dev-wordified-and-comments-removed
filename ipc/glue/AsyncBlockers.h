#
ifndef
mozilla_ipc_AsyncBlockers_h
#
define
mozilla_ipc_AsyncBlockers_h
#
include
"
mozilla
/
ThreadSafety
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
ipc
{
class
AsyncBlockers
{
public
:
AsyncBlockers
(
)
:
mLock
(
"
AsyncRegistrar
"
)
mPromise
(
new
GenericPromise
:
:
Private
(
__func__
)
)
{
}
void
Register
(
void
*
aBlocker
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mResolved
)
{
return
;
}
mBlockers
.
InsertElementSorted
(
aBlocker
)
;
}
void
Deregister
(
void
*
aBlocker
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
mResolved
)
{
return
;
}
MOZ_ASSERT
(
mBlockers
.
ContainsSorted
(
aBlocker
)
)
;
MOZ_ALWAYS_TRUE
(
mBlockers
.
RemoveElementSorted
(
aBlocker
)
)
;
MaybeResolve
(
)
;
}
RefPtr
<
GenericPromise
>
WaitUntilClear
(
uint32_t
aTimeOutInMs
=
0
)
{
if
(
!
aTimeOutInMs
)
{
MutexAutoLock
lock
(
mLock
)
;
if
(
!
mResolved
)
{
mPromise
-
>
Resolve
(
true
__func__
)
;
mResolved
=
true
;
}
}
else
{
GetCurrentEventTarget
(
)
-
>
DelayedDispatch
(
NS_NewRunnableFunction
(
"
AsyncBlockers
:
:
WaitUntilClear
"
[
promise
=
mPromise
]
(
)
{
promise
-
>
Resolve
(
true
__func__
)
;
}
)
aTimeOutInMs
)
;
}
return
mPromise
;
}
virtual
~
AsyncBlockers
(
)
{
if
(
!
mResolved
)
{
mPromise
-
>
Resolve
(
true
__func__
)
;
}
}
private
:
void
MaybeResolve
(
)
REQUIRES
(
mLock
)
{
mLock
.
AssertCurrentThreadOwns
(
)
;
if
(
mResolved
)
{
return
;
}
if
(
!
mBlockers
.
IsEmpty
(
)
)
{
return
;
}
mPromise
-
>
Resolve
(
true
__func__
)
;
mResolved
=
true
;
}
Mutex
mLock
;
nsTArray
<
void
*
>
mBlockers
GUARDED_BY
(
mLock
)
;
bool
mResolved
GUARDED_BY
(
mLock
)
=
false
;
const
RefPtr
<
GenericPromise
:
:
Private
>
mPromise
;
}
;
}
#
endif
