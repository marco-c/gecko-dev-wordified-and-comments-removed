#
include
"
mozilla
/
ipc
/
ForkServer
.
h
"
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
ipc
/
IPCMessageUtilsSpecializations
.
h
"
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
GeckoArgs
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
ProcessType
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
ipc
/
IPDLParamTraits
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessUtils
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolMessageUtils
.
h
"
#
include
"
mozilla
/
ipc
/
SetProcessTitle
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
string
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
endif
#
if
defined
(
XP_OPENBSD
)
#
include
"
BinaryPath
.
h
"
#
include
<
err
.
h
>
#
endif
#
include
<
algorithm
>
namespace
mozilla
{
namespace
ipc
{
LazyLogModule
gForkServiceLog
(
"
ForkService
"
)
;
static
int
gSignalPipe
=
-
1
;
static
void
HandleSigChld
(
int
aSignal
)
{
MOZ_ASSERT
(
aSignal
=
=
SIGCHLD
)
;
const
char
msg
=
0
;
HANDLE_EINTR
(
write
(
gSignalPipe
&
msg
1
)
)
;
}
ForkServer
:
:
ForkServer
(
int
*
aArgc
char
*
*
*
aArgv
)
:
mArgc
(
aArgc
)
mArgv
(
aArgv
)
{
SetThisProcessName
(
"
forkserver
"
)
;
Maybe
<
UniqueFileHandle
>
ipcHandle
=
geckoargs
:
:
sIPCHandle
.
Get
(
*
aArgc
*
aArgv
)
;
if
(
!
ipcHandle
)
{
MOZ_CRASH
(
"
forkserver
missing
ipcHandle
argument
"
)
;
}
mIpcFd
=
ipcHandle
.
extract
(
)
;
mTcver
=
MakeUnique
<
MiniTransceiver
>
(
mIpcFd
.
get
(
)
DataBufferClear
:
:
AfterReceiving
)
;
auto
signalPipe
=
geckoargs
:
:
sSignalPipe
.
Get
(
*
aArgc
*
aArgv
)
;
if
(
signalPipe
)
{
gSignalPipe
=
signalPipe
-
>
release
(
)
;
signal
(
SIGCHLD
HandleSigChld
)
;
}
else
{
signal
(
SIGCHLD
SIG_IGN
)
;
}
}
static
void
ForkServerPreload
(
int
&
aArgc
char
*
*
aArgv
)
{
Omnijar
:
:
ChildProcessInit
(
aArgc
aArgv
)
;
#
if
defined
(
XP_OPENBSD
)
char
binaryPath
[
MAXPATHLEN
]
;
nsresult
rv
=
mozilla
:
:
BinaryPath
:
:
Get
(
binaryPath
)
;
if
(
NS_FAILED
(
rv
)
)
{
errx
(
1
"
failed
to
cache
binary
path
?
"
)
;
}
#
endif
}
bool
ForkServer
:
:
HandleMessages
(
)
{
while
(
true
)
{
UniquePtr
<
IPC
:
:
Message
>
msg
;
if
(
!
mTcver
-
>
Recv
(
msg
)
)
{
break
;
}
switch
(
msg
-
>
type
(
)
)
{
case
Msg_ForkNewSubprocess__ID
:
if
(
HandleForkNewSubprocess
(
std
:
:
move
(
msg
)
)
)
{
return
false
;
}
break
;
case
Msg_WaitPid__ID
:
HandleWaitPid
(
std
:
:
move
(
msg
)
)
;
break
;
default
:
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
unknown
message
type
%
d
\
n
"
msg
-
>
type
(
)
)
)
;
}
}
return
true
;
}
template
<
class
P
>
static
void
ReadParamInfallible
(
IPC
:
:
MessageReader
*
aReader
P
*
aResult
const
char
*
aCrashMessage
)
{
if
(
!
IPC
:
:
ReadParam
(
aReader
aResult
)
)
{
MOZ_CRASH_UNSAFE
(
aCrashMessage
)
;
}
}
static
bool
ParseForkNewSubprocess
(
IPC
:
:
Message
&
aMsg
UniqueFileHandle
*
aExecFd
base
:
:
LaunchOptions
*
aOptions
)
{
MOZ_ASSERT
(
aMsg
.
type
(
)
=
=
Msg_ForkNewSubprocess__ID
)
;
IPC
:
:
MessageReader
reader
(
aMsg
)
;
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
ReadParamInfallible
(
&
reader
&
aOptions
-
>
fork_flags
"
Error
deserializing
'
int
'
"
)
;
ReadParamInfallible
(
&
reader
&
aOptions
-
>
sandbox_chroot_server
"
Error
deserializing
'
UniqueFileHandle
'
"
)
;
#
endif
ReadParamInfallible
(
&
reader
aExecFd
"
Error
deserializing
'
UniqueFileHandle
'
"
)
;
reader
.
EndRead
(
)
;
return
true
;
}
static
bool
ParseSubprocessExecInfo
(
IPC
:
:
Message
&
aMsg
geckoargs
:
:
ChildProcessArgs
*
aArgs
base
:
:
environment_map
*
aEnv
)
{
if
(
aMsg
.
type
(
)
!
=
Msg_SubprocessExecInfo__ID
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
unknown
message
type
%
d
(
!
=
%
d
)
\
n
"
aMsg
.
type
(
)
Msg_SubprocessExecInfo__ID
)
)
;
return
false
;
}
IPC
:
:
MessageReader
reader
(
aMsg
)
;
ReadParamInfallible
(
&
reader
aEnv
"
Error
deserializing
'
env_map
'
"
)
;
ReadParamInfallible
(
&
reader
&
aArgs
-
>
mArgs
"
Error
deserializing
'
mArgs
'
"
)
;
ReadParamInfallible
(
&
reader
&
aArgs
-
>
mFiles
"
Error
deserializing
'
mFiles
'
"
)
;
reader
.
EndRead
(
)
;
return
true
;
}
static
void
ForkedChildProcessInit
(
int
aExecFd
int
*
aArgc
char
*
*
*
aArgv
)
{
signal
(
SIGCHLD
SIG_DFL
)
;
if
(
gSignalPipe
>
=
0
)
{
close
(
gSignalPipe
)
;
gSignalPipe
=
-
1
;
}
MiniTransceiver
execTcver
(
aExecFd
)
;
UniquePtr
<
IPC
:
:
Message
>
execMsg
;
if
(
!
execTcver
.
Recv
(
execMsg
)
)
{
printf_stderr
(
"
ForkServer
:
SubprocessExecInfo
receive
error
\
n
"
)
;
MOZ_CRASH
(
)
;
}
geckoargs
:
:
ChildProcessArgs
args
;
base
:
:
environment_map
env
;
if
(
!
ParseSubprocessExecInfo
(
*
execMsg
&
args
&
env
)
)
{
printf_stderr
(
"
ForkServer
:
SubprocessExecInfo
parse
error
\
n
"
)
;
MOZ_CRASH
(
)
;
}
for
(
auto
&
elt
:
env
)
{
setenv
(
elt
.
first
.
c_str
(
)
elt
.
second
.
c_str
(
)
1
)
;
}
geckoargs
:
:
SetPassedFileHandles
(
std
:
:
move
(
args
.
mFiles
)
)
;
char
*
*
argv
=
new
char
*
[
args
.
mArgs
.
size
(
)
+
1
]
;
char
*
*
p
=
argv
;
for
(
auto
&
elt
:
args
.
mArgs
)
{
*
p
+
+
=
strdup
(
elt
.
c_str
(
)
)
;
}
*
p
=
nullptr
;
*
aArgv
=
argv
;
*
aArgc
=
args
.
mArgs
.
size
(
)
;
mozilla
:
:
SetProcessTitle
(
args
.
mArgs
)
;
}
bool
ForkServer
:
:
HandleForkNewSubprocess
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
{
UniqueFileHandle
execFd
;
base
:
:
LaunchOptions
options
;
if
(
!
ParseForkNewSubprocess
(
*
aMessage
&
execFd
&
options
)
)
{
return
false
;
}
#
if
defined
(
MOZ_MEMORY
)
&
&
defined
(
DEBUG
)
jemalloc_stats_t
stats
;
jemalloc_stats
(
&
stats
)
;
MOZ_ASSERT
(
stats
.
narenas
=
=
1
"
ForkServer
before
fork
(
)
/
clone
(
)
should
have
a
single
arena
.
"
)
;
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
mozilla
:
:
SandboxLaunch
launcher
;
if
(
!
launcher
.
Prepare
(
&
options
)
)
{
MOZ_CRASH
(
"
SandboxLaunch
:
:
Prepare
failed
"
)
;
}
#
else
struct
{
pid_t
Fork
(
)
{
return
fork
(
)
;
}
}
launcher
;
#
endif
fflush
(
stdout
)
;
fflush
(
stderr
)
;
pid_t
pid
=
launcher
.
Fork
(
)
;
if
(
pid
<
0
)
{
MOZ_CRASH
(
"
failed
to
fork
"
)
;
}
if
(
pid
=
=
0
)
{
ForkedChildProcessInit
(
execFd
.
get
(
)
mArgc
mArgv
)
;
return
true
;
}
IPC
:
:
Message
reply
(
MSG_ROUTING_CONTROL
Reply_ForkNewSubprocess__ID
)
;
IPC
:
:
MessageWriter
writer
(
reply
)
;
WriteIPDLParam
(
&
writer
nullptr
pid
)
;
mTcver
-
>
SendInfallible
(
reply
"
failed
to
send
a
reply
message
"
)
;
return
false
;
}
void
ForkServer
:
:
HandleWaitPid
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
{
MOZ_ASSERT
(
aMessage
-
>
type
(
)
=
=
Msg_WaitPid__ID
)
;
IPC
:
:
MessageReader
reader
(
*
aMessage
)
;
pid_t
pid
;
bool
block
;
ReadParamInfallible
(
&
reader
&
pid
"
Error
deserializing
'
pid_t
'
"
)
;
ReadParamInfallible
(
&
reader
&
block
"
Error
deserializing
'
bool
'
"
)
;
int
status
;
pid_t
rv
=
HANDLE_EINTR
(
waitpid
(
pid
&
status
block
?
0
:
WNOHANG
)
)
;
bool
isErr
=
rv
<
=
0
;
int
err
=
rv
<
0
?
errno
:
0
;
MOZ_ASSERT
(
isErr
|
|
rv
=
=
pid
)
;
IPC
:
:
Message
reply
(
MSG_ROUTING_CONTROL
Reply_WaitPid__ID
)
;
IPC
:
:
MessageWriter
writer
(
reply
)
;
WriteParam
(
&
writer
isErr
)
;
WriteParam
(
&
writer
isErr
?
err
:
status
)
;
mTcver
-
>
SendInfallible
(
reply
"
failed
to
send
a
reply
message
"
)
;
}
bool
ForkServer
:
:
RunForkServer
(
int
*
aArgc
char
*
*
*
aArgv
)
{
MOZ_ASSERT
(
XRE_IsForkServerProcess
(
)
"
fork
server
process
only
"
)
;
#
ifdef
DEBUG
if
(
getenv
(
"
MOZ_FORKSERVER_WAIT_GDB
"
)
)
{
printf
(
"
Waiting
for
30
seconds
.
"
"
Attach
the
fork
server
with
gdb
%
s
%
d
\
n
"
(
*
aArgv
)
[
0
]
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
30
)
;
}
bool
sleep_newproc
=
!
!
getenv
(
"
MOZ_FORKSERVER_WAIT_GDB_NEWPROC
"
)
;
#
endif
SetProcessTitleInit
(
*
aArgv
)
;
ForkServer
forkserver
(
aArgc
aArgv
)
;
NS_LogInit
(
)
;
mozilla
:
:
LogModule
:
:
Init
(
0
nullptr
)
;
ForkServerPreload
(
*
aArgc
*
aArgv
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Start
a
fork
server
"
)
)
;
{
DebugOnly
<
base
:
:
ProcessHandle
>
forkserver_pid
=
base
:
:
GetCurrentProcId
(
)
;
if
(
forkserver
.
HandleMessages
(
)
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Terminate
the
fork
server
"
)
)
;
Omnijar
:
:
CleanUp
(
)
;
NS_LogTerm
(
)
;
return
true
;
}
MOZ_ASSERT
(
base
:
:
GetCurrentProcId
(
)
!
=
forkserver_pid
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Fork
a
new
content
process
"
)
)
;
}
#
ifdef
DEBUG
if
(
sleep_newproc
)
{
printf
(
"
Waiting
for
30
seconds
.
"
"
Attach
the
new
process
with
gdb
%
s
%
d
\
n
"
(
*
aArgv
)
[
0
]
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
30
)
;
}
#
endif
NS_LogTerm
(
)
;
nsTraceRefcnt
:
:
CloseLogFilesAfterFork
(
)
;
if
(
*
aArgc
<
2
)
{
MOZ_CRASH
(
"
forked
process
missing
process
type
and
childid
arguments
"
)
;
}
SetGeckoProcessType
(
(
*
aArgv
)
[
-
-
*
aArgc
]
)
;
SetGeckoChildID
(
(
*
aArgv
)
[
-
-
*
aArgc
]
)
;
MOZ_ASSERT
(
!
XRE_IsForkServerProcess
(
)
"
fork
server
created
another
fork
server
?
"
)
;
#
if
defined
(
MOZ_MEMORY
)
jemalloc_reset_small_alloc_randomization
(
!
XRE_IsContentProcess
(
)
)
;
#
endif
nsTraceRefcnt
:
:
ReopenLogFilesAfterFork
(
XRE_GetProcessTypeString
(
)
)
;
return
false
;
}
}
}
