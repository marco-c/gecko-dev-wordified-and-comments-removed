#
include
"
mozilla
/
ipc
/
ForkServer
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
ipc
/
IPCMessageUtilsSpecializations
.
h
"
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Omnijar
.
h
"
#
include
"
mozilla
/
ProcessType
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
ipc
/
IPDLParamTraits
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolMessageUtils
.
h
"
#
include
"
mozilla
/
ipc
/
SetProcessTitle
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
<
fcntl
.
h
>
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
endif
#
include
<
algorithm
>
namespace
mozilla
{
namespace
ipc
{
LazyLogModule
gForkServiceLog
(
"
ForkService
"
)
;
ForkServer
:
:
ForkServer
(
)
{
}
void
ForkServer
:
:
InitProcess
(
int
*
aArgc
char
*
*
*
aArgv
)
{
base
:
:
InitForkServerProcess
(
)
;
mTcver
=
MakeUnique
<
MiniTransceiver
>
(
kClientPipeFd
DataBufferClear
:
:
AfterReceiving
)
;
}
static
void
ForkServerPreload
(
int
&
aArgc
char
*
*
aArgv
)
{
Omnijar
:
:
ChildProcessInit
(
aArgc
aArgv
)
;
}
bool
ForkServer
:
:
HandleMessages
(
)
{
while
(
true
)
{
UniquePtr
<
IPC
:
:
Message
>
msg
;
if
(
!
mTcver
-
>
Recv
(
msg
)
)
{
break
;
}
OnMessageReceived
(
std
:
:
move
(
msg
)
)
;
if
(
mAppProcBuilder
)
{
return
false
;
}
}
return
true
;
}
inline
void
CleanCString
(
nsCString
&
str
)
{
char
*
data
;
int
sz
=
str
.
GetMutableData
(
&
data
)
;
memset
(
data
'
'
sz
)
;
}
inline
void
CleanString
(
std
:
:
string
&
str
)
{
const
char
deadbeef
[
]
=
"
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
"
"
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
"
;
int
pos
=
0
;
size_t
sz
=
str
.
size
(
)
;
while
(
sz
>
0
)
{
int
toclean
=
std
:
:
min
(
sz
sizeof
(
deadbeef
)
-
1
)
;
str
.
replace
(
pos
toclean
deadbeef
)
;
sz
-
=
toclean
;
pos
+
=
toclean
;
}
}
inline
void
PrepareArguments
(
std
:
:
vector
<
std
:
:
string
>
&
aArgv
nsTArray
<
nsCString
>
&
aArgvArray
)
{
for
(
auto
&
elt
:
aArgvArray
)
{
aArgv
.
push_back
(
elt
.
get
(
)
)
;
CleanCString
(
elt
)
;
}
}
inline
void
PrepareEnv
(
base
:
:
LaunchOptions
*
aOptions
nsTArray
<
EnvVar
>
&
aEnvMap
)
{
for
(
auto
&
elt
:
aEnvMap
)
{
nsCString
&
var
=
std
:
:
get
<
0
>
(
elt
)
;
nsCString
&
val
=
std
:
:
get
<
1
>
(
elt
)
;
aOptions
-
>
env_map
[
var
.
get
(
)
]
=
val
.
get
(
)
;
CleanCString
(
var
)
;
CleanCString
(
val
)
;
}
}
inline
void
PrepareFdsRemap
(
base
:
:
LaunchOptions
*
aOptions
nsTArray
<
FdMapping
>
&
aFdsRemap
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
fds
mapping
:
"
)
)
;
for
(
auto
&
elt
:
aFdsRemap
)
{
int
fd
=
std
:
:
get
<
0
>
(
elt
)
.
ClonePlatformHandle
(
)
.
release
(
)
;
std
:
:
pair
<
int
int
>
fdmap
(
fd
std
:
:
get
<
1
>
(
elt
)
)
;
aOptions
-
>
fds_to_remap
.
push_back
(
fdmap
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
\
t
%
d
=
>
%
d
"
fdmap
.
first
fdmap
.
second
)
)
;
}
}
template
<
class
P
>
static
void
ReadParamInfallible
(
IPC
:
:
MessageReader
*
aReader
P
*
aResult
const
char
*
aCrashMessage
)
{
if
(
!
IPC
:
:
ReadParam
(
aReader
aResult
)
)
{
MOZ_CRASH_UNSAFE
(
aCrashMessage
)
;
}
}
inline
bool
ParseForkNewSubprocess
(
IPC
:
:
Message
&
aMsg
std
:
:
vector
<
std
:
:
string
>
&
aArgv
base
:
:
LaunchOptions
*
aOptions
)
{
if
(
aMsg
.
type
(
)
!
=
Msg_ForkNewSubprocess__ID
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
unknown
message
type
%
d
\
n
"
aMsg
.
type
(
)
)
)
;
return
false
;
}
IPC
:
:
MessageReader
reader
(
aMsg
)
;
nsTArray
<
nsCString
>
argv_array
;
nsTArray
<
EnvVar
>
env_map
;
nsTArray
<
FdMapping
>
fds_remap
;
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
ReadParamInfallible
(
&
reader
&
aOptions
-
>
fork_flags
"
Error
deserializing
'
int
'
"
)
;
ReadParamInfallible
(
&
reader
&
aOptions
-
>
sandbox_chroot
"
Error
deserializing
'
bool
'
"
)
;
#
endif
ReadParamInfallible
(
&
reader
&
argv_array
"
Error
deserializing
'
nsCString
[
]
'
"
)
;
ReadParamInfallible
(
&
reader
&
env_map
"
Error
deserializing
'
EnvVar
[
]
'
"
)
;
ReadParamInfallible
(
&
reader
&
fds_remap
"
Error
deserializing
'
FdMapping
[
]
'
"
)
;
reader
.
EndRead
(
)
;
PrepareArguments
(
aArgv
argv_array
)
;
PrepareEnv
(
aOptions
env_map
)
;
PrepareFdsRemap
(
aOptions
fds_remap
)
;
return
true
;
}
inline
void
SanitizeBuffers
(
IPC
:
:
Message
&
aMsg
std
:
:
vector
<
std
:
:
string
>
&
aArgv
base
:
:
LaunchOptions
&
aOptions
)
{
auto
&
blist
=
aMsg
.
Buffers
(
)
;
for
(
auto
itr
=
blist
.
Iter
(
)
;
!
itr
.
Done
(
)
;
itr
.
Advance
(
blist
itr
.
RemainingInSegment
(
)
)
)
{
memset
(
itr
.
Data
(
)
0
itr
.
RemainingInSegment
(
)
)
;
}
for
(
auto
&
var
:
aOptions
.
env_map
)
{
CleanString
(
*
const_cast
<
std
:
:
string
*
>
(
&
var
.
first
)
)
;
CleanString
(
var
.
second
)
;
}
for
(
auto
&
arg
:
aArgv
)
{
CleanString
(
arg
)
;
}
}
void
ForkServer
:
:
OnMessageReceived
(
UniquePtr
<
IPC
:
:
Message
>
message
)
{
std
:
:
vector
<
std
:
:
string
>
argv
;
base
:
:
LaunchOptions
options
;
if
(
!
ParseForkNewSubprocess
(
*
message
argv
&
options
)
)
{
return
;
}
base
:
:
ProcessHandle
child_pid
=
-
1
;
mAppProcBuilder
=
MakeUnique
<
base
:
:
AppProcessBuilder
>
(
)
;
if
(
!
mAppProcBuilder
-
>
ForkProcess
(
argv
std
:
:
move
(
options
)
&
child_pid
)
)
{
MOZ_CRASH
(
"
fail
to
fork
"
)
;
}
MOZ_ASSERT
(
child_pid
>
=
0
)
;
if
(
child_pid
=
=
0
)
{
return
;
}
mAppProcBuilder
=
nullptr
;
IPC
:
:
Message
reply
(
MSG_ROUTING_CONTROL
Reply_ForkNewSubprocess__ID
)
;
IPC
:
:
MessageWriter
writer
(
reply
)
;
WriteIPDLParam
(
&
writer
nullptr
child_pid
)
;
mTcver
-
>
SendInfallible
(
reply
"
failed
to
send
a
reply
message
"
)
;
SanitizeBuffers
(
*
message
argv
options
)
;
}
bool
ForkServer
:
:
RunForkServer
(
int
*
aArgc
char
*
*
*
aArgv
)
{
MOZ_ASSERT
(
XRE_IsForkServerProcess
(
)
"
fork
server
process
only
"
)
;
#
ifdef
DEBUG
if
(
getenv
(
"
MOZ_FORKSERVER_WAIT_GDB
"
)
)
{
printf
(
"
Waiting
for
30
seconds
.
"
"
Attach
the
fork
server
with
gdb
%
s
%
d
\
n
"
(
*
aArgv
)
[
0
]
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
30
)
;
}
bool
sleep_newproc
=
!
!
getenv
(
"
MOZ_FORKSERVER_WAIT_GDB_NEWPROC
"
)
;
#
endif
SetProcessTitleInit
(
*
aArgv
)
;
ForkServer
forkserver
;
forkserver
.
InitProcess
(
aArgc
aArgv
)
;
NS_LogInit
(
)
;
mozilla
:
:
LogModule
:
:
Init
(
0
nullptr
)
;
ForkServerPreload
(
*
aArgc
*
aArgv
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Start
a
fork
server
"
)
)
;
{
DebugOnly
<
base
:
:
ProcessHandle
>
forkserver_pid
=
base
:
:
GetCurrentProcId
(
)
;
if
(
forkserver
.
HandleMessages
(
)
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Terminate
the
fork
server
"
)
)
;
Omnijar
:
:
CleanUp
(
)
;
NS_LogTerm
(
)
;
return
true
;
}
MOZ_ASSERT
(
base
:
:
GetCurrentProcId
(
)
!
=
forkserver_pid
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Fork
a
new
content
process
"
)
)
;
}
#
ifdef
DEBUG
if
(
sleep_newproc
)
{
printf
(
"
Waiting
for
30
seconds
.
"
"
Attach
the
new
process
with
gdb
%
s
%
d
\
n
"
(
*
aArgv
)
[
0
]
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
30
)
;
}
#
endif
NS_LogTerm
(
)
;
MOZ_ASSERT
(
forkserver
.
mAppProcBuilder
)
;
nsTraceRefcnt
:
:
CloseLogFilesAfterFork
(
)
;
forkserver
.
mAppProcBuilder
-
>
InitAppProcess
(
aArgc
aArgv
)
;
forkserver
.
mAppProcBuilder
.
reset
(
)
;
if
(
*
aArgc
<
2
)
{
MOZ_CRASH
(
"
forked
process
missing
process
type
and
childid
arguments
"
)
;
}
SetGeckoProcessType
(
(
*
aArgv
)
[
-
-
*
aArgc
]
)
;
SetGeckoChildID
(
(
*
aArgv
)
[
-
-
*
aArgc
]
)
;
MOZ_ASSERT
(
!
XRE_IsForkServerProcess
(
)
"
fork
server
created
another
fork
server
?
"
)
;
nsTraceRefcnt
:
:
ReopenLogFilesAfterFork
(
XRE_GetProcessTypeString
(
)
)
;
return
false
;
}
}
}
