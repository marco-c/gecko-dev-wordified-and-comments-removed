#
include
"
mozilla
/
ipc
/
ForkServer
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
mozilla
/
BlockingResourceBase
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolMessageUtils
.
h
"
#
include
"
nsTraceRefcnt
.
h
"
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
include
<
fcntl
.
h
>
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
#
include
"
mozilla
/
SandboxLaunch
.
h
"
#
endif
#
include
<
algorithm
>
namespace
mozilla
{
namespace
ipc
{
static
const
int
sClientFd
=
3
;
LazyLogModule
gForkServiceLog
(
"
ForkService
"
)
;
ForkServer
:
:
ForkServer
(
)
{
}
void
ForkServer
:
:
InitProcess
(
int
*
aArgc
char
*
*
*
aArgv
)
{
base
:
:
InitForkServerProcess
(
)
;
int
fd
=
sClientFd
;
int
fd_flags
=
fcntl
(
sClientFd
F_GETFL
0
)
;
fcntl
(
fd
F_SETFL
fd_flags
&
~
O_NONBLOCK
)
;
mTcver
=
MakeUnique
<
MiniTransceiver
>
(
fd
DataBufferClear
:
:
AfterReceiving
)
;
}
bool
ForkServer
:
:
HandleMessages
(
)
{
IPC
:
:
Message
hello
;
mTcver
-
>
RecvInfallible
(
hello
"
Expect
to
receive
a
HELLO
message
from
the
parent
process
!
"
)
;
MOZ_ASSERT
(
hello
.
type
(
)
=
=
kHELLO_MESSAGE_TYPE
)
;
mTcver
-
>
SendInfallible
(
hello
"
Fail
to
ack
the
received
HELLO
!
"
)
;
while
(
true
)
{
IPC
:
:
Message
msg
;
if
(
!
mTcver
-
>
Recv
(
msg
)
)
{
break
;
}
OnMessageReceived
(
std
:
:
move
(
msg
)
)
;
if
(
mAppProcBuilder
)
{
return
false
;
}
}
return
true
;
}
inline
void
CleanCString
(
nsCString
&
str
)
{
char
*
data
;
int
sz
=
str
.
GetMutableData
(
&
data
)
;
memset
(
data
'
'
sz
)
;
}
inline
void
CleanString
(
std
:
:
string
&
str
)
{
const
char
deadbeef
[
]
=
"
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
"
"
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
\
xde
\
xad
\
xbe
\
xef
"
;
int
pos
=
0
;
size_t
sz
=
str
.
size
(
)
;
while
(
sz
>
0
)
{
int
toclean
=
std
:
:
min
(
sz
sizeof
(
deadbeef
)
-
1
)
;
str
.
replace
(
pos
toclean
deadbeef
)
;
sz
-
=
toclean
;
pos
+
=
toclean
;
}
}
inline
void
PrepareArguments
(
std
:
:
vector
<
std
:
:
string
>
&
aArgv
nsTArray
<
nsCString
>
&
aArgvArray
)
{
for
(
auto
&
elt
:
aArgvArray
)
{
aArgv
.
push_back
(
elt
.
get
(
)
)
;
CleanCString
(
elt
)
;
}
}
inline
void
PrepareEnv
(
base
:
:
LaunchOptions
*
aOptions
nsTArray
<
EnvVar
>
&
aEnvMap
)
{
for
(
auto
&
elt
:
aEnvMap
)
{
nsCString
&
var
=
Get
<
0
>
(
elt
)
;
nsCString
&
val
=
Get
<
1
>
(
elt
)
;
aOptions
-
>
env_map
[
var
.
get
(
)
]
=
val
.
get
(
)
;
CleanCString
(
var
)
;
CleanCString
(
val
)
;
}
}
inline
void
PrepareFdsRemap
(
base
:
:
LaunchOptions
*
aOptions
nsTArray
<
FdMapping
>
&
aFdsRemap
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
fds
mapping
:
"
)
)
;
for
(
auto
&
elt
:
aFdsRemap
)
{
int
fd
=
Get
<
0
>
(
elt
)
.
ClonePlatformHandle
(
)
.
release
(
)
;
std
:
:
pair
<
int
int
>
fdmap
(
fd
Get
<
1
>
(
elt
)
)
;
aOptions
-
>
fds_to_remap
.
push_back
(
fdmap
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
\
t
%
d
=
>
%
d
"
fdmap
.
first
fdmap
.
second
)
)
;
}
}
inline
bool
ParseForkNewSubprocess
(
IPC
:
:
Message
&
aMsg
std
:
:
vector
<
std
:
:
string
>
&
aArgv
base
:
:
LaunchOptions
*
aOptions
)
{
if
(
aMsg
.
type
(
)
!
=
Msg_ForkNewSubprocess__ID
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
unknown
message
type
%
d
\
n
"
aMsg
.
type
(
)
)
)
;
return
false
;
}
PickleIterator
iter
(
aMsg
)
;
nsTArray
<
nsCString
>
argv_array
;
nsTArray
<
EnvVar
>
env_map
;
nsTArray
<
FdMapping
>
fds_remap
;
ReadIPDLParamInfallible
(
&
aMsg
&
iter
nullptr
&
argv_array
"
Error
deserializing
'
nsCString
[
]
'
"
)
;
ReadIPDLParamInfallible
(
&
aMsg
&
iter
nullptr
&
env_map
"
Error
deserializing
'
EnvVar
[
]
'
"
)
;
ReadIPDLParamInfallible
(
&
aMsg
&
iter
nullptr
&
fds_remap
"
Error
deserializing
'
FdMapping
[
]
'
"
)
;
aMsg
.
EndRead
(
iter
aMsg
.
type
(
)
)
;
PrepareArguments
(
aArgv
argv_array
)
;
PrepareEnv
(
aOptions
env_map
)
;
PrepareFdsRemap
(
aOptions
fds_remap
)
;
return
true
;
}
inline
void
SanitizeBuffers
(
IPC
:
:
Message
&
aMsg
std
:
:
vector
<
std
:
:
string
>
&
aArgv
base
:
:
LaunchOptions
&
aOptions
)
{
auto
&
blist
=
aMsg
.
Buffers
(
)
;
for
(
auto
itr
=
blist
.
Iter
(
)
;
!
itr
.
Done
(
)
;
itr
.
Advance
(
blist
itr
.
RemainingInSegment
(
)
)
)
{
memset
(
itr
.
Data
(
)
0
itr
.
RemainingInSegment
(
)
)
;
}
for
(
auto
&
var
:
aOptions
.
env_map
)
{
CleanString
(
*
const_cast
<
std
:
:
string
*
>
(
&
var
.
first
)
)
;
CleanString
(
var
.
second
)
;
}
for
(
auto
&
arg
:
aArgv
)
{
CleanString
(
arg
)
;
}
}
void
ForkServer
:
:
OnMessageReceived
(
IPC
:
:
Message
&
&
message
)
{
IPC
:
:
Message
msg
(
std
:
:
move
(
message
)
)
;
std
:
:
vector
<
std
:
:
string
>
argv
;
base
:
:
LaunchOptions
options
;
if
(
!
ParseForkNewSubprocess
(
msg
argv
&
options
)
)
{
return
;
}
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
mozilla
:
:
SandboxLaunchForkServerPrepare
(
argv
options
)
;
#
endif
base
:
:
ProcessHandle
child_pid
=
-
1
;
mAppProcBuilder
=
MakeUnique
<
base
:
:
AppProcessBuilder
>
(
)
;
if
(
!
mAppProcBuilder
-
>
ForkProcess
(
argv
options
&
child_pid
)
)
{
MOZ_CRASH
(
"
fail
to
fork
"
)
;
}
MOZ_ASSERT
(
child_pid
>
=
0
)
;
if
(
child_pid
=
=
0
)
{
return
;
}
mAppProcBuilder
=
nullptr
;
IPC
:
:
Message
reply
(
MSG_ROUTING_CONTROL
Reply_ForkNewSubprocess__ID
)
;
WriteIPDLParam
(
&
reply
nullptr
child_pid
)
;
mTcver
-
>
SendInfallible
(
reply
"
failed
to
send
a
reply
message
"
)
;
SanitizeBuffers
(
msg
argv
options
)
;
}
bool
ForkServer
:
:
RunForkServer
(
int
*
aArgc
char
*
*
*
aArgv
)
{
#
ifdef
DEBUG
if
(
getenv
(
"
MOZ_FORKSERVER_WAIT_GDB
"
)
)
{
printf
(
"
Waiting
for
30
seconds
.
"
"
Attach
the
fork
server
with
gdb
%
s
%
d
\
n
"
(
*
aArgv
)
[
0
]
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
30
)
;
}
bool
sleep_newproc
=
!
!
getenv
(
"
MOZ_FORKSERVER_WAIT_GDB_NEWPROC
"
)
;
#
endif
ForkServer
forkserver
;
forkserver
.
InitProcess
(
aArgc
aArgv
)
;
XRE_SetProcessType
(
"
forkserver
"
)
;
NS_LogInit
(
)
;
mozilla
:
:
LogModule
:
:
Init
(
0
nullptr
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Start
a
fork
server
"
)
)
;
{
DebugOnly
<
base
:
:
ProcessHandle
>
forkserver_pid
=
base
:
:
GetCurrentProcId
(
)
;
if
(
forkserver
.
HandleMessages
(
)
)
{
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Terminate
the
fork
server
"
)
)
;
NS_LogTerm
(
)
;
return
true
;
}
MOZ_ASSERT
(
base
:
:
GetCurrentProcId
(
)
!
=
forkserver_pid
)
;
MOZ_LOG
(
gForkServiceLog
LogLevel
:
:
Verbose
(
"
Fork
a
new
content
process
"
)
)
;
}
#
ifdef
DEBUG
if
(
sleep_newproc
)
{
printf
(
"
Waiting
for
30
seconds
.
"
"
Attach
the
new
process
with
gdb
%
s
%
d
\
n
"
(
*
aArgv
)
[
0
]
base
:
:
GetCurrentProcId
(
)
)
;
sleep
(
30
)
;
}
#
endif
NS_LogTerm
(
)
;
MOZ_ASSERT
(
forkserver
.
mAppProcBuilder
)
;
forkserver
.
mAppProcBuilder
-
>
InitAppProcess
(
aArgc
aArgv
)
;
forkserver
.
mAppProcBuilder
.
reset
(
)
;
MOZ_ASSERT
(
"
tab
"
_ns
=
=
(
*
aArgv
)
[
*
aArgc
-
1
]
"
Only
|
tab
|
is
allowed
!
"
)
;
nsTraceRefcnt
:
:
ResetLogFiles
(
(
*
aArgv
)
[
*
aArgc
-
1
]
)
;
return
false
;
}
}
}
