#
include
"
base
/
message_loop
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
<
windows
.
h
>
using
base
:
:
ProcessHandle
;
namespace
mozilla
{
namespace
ipc
{
nsresult
CreateTransport
(
TransportDescriptor
*
aOne
TransportDescriptor
*
aTwo
)
{
auto
id
=
IPC
:
:
Channel
:
:
GenerateVerifiedChannelID
(
)
;
Transport
t
(
id
Transport
:
:
MODE_SERVER
nullptr
)
;
HANDLE
serverPipe
=
t
.
GetServerPipeHandle
(
)
;
if
(
!
serverPipe
)
{
return
NS_ERROR_TRANSPORT_INIT
;
}
if
(
!
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
serverPipe
GetCurrentProcess
(
)
&
aOne
-
>
mServerPipeHandle
0
false
DUPLICATE_SAME_ACCESS
)
)
{
return
NS_ERROR_DUPLICATE_HANDLE
;
}
aOne
-
>
mPipeName
=
aTwo
-
>
mPipeName
=
id
;
aTwo
-
>
mServerPipeHandle
=
INVALID_HANDLE_VALUE
;
return
NS_OK
;
}
UniquePtr
<
Transport
>
OpenDescriptor
(
const
TransportDescriptor
&
aTd
Transport
:
:
Mode
aMode
)
{
return
MakeUnique
<
Transport
>
(
aTd
.
mPipeName
aTd
.
mServerPipeHandle
aMode
nullptr
)
;
}
TransportDescriptor
DuplicateDescriptor
(
const
TransportDescriptor
&
aTd
)
{
if
(
aTd
.
mServerPipeHandle
=
=
INVALID_HANDLE_VALUE
)
{
return
aTd
;
}
HANDLE
serverDup
;
bool
ok
=
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
aTd
.
mServerPipeHandle
GetCurrentProcess
(
)
&
serverDup
0
false
DUPLICATE_SAME_ACCESS
)
;
if
(
!
ok
)
{
AnnotateSystemError
(
)
;
}
MOZ_RELEASE_ASSERT
(
ok
)
;
TransportDescriptor
desc
=
aTd
;
desc
.
mServerPipeHandle
=
serverDup
;
return
desc
;
}
void
CloseDescriptor
(
const
TransportDescriptor
&
aTd
)
{
CloseHandle
(
aTd
.
mServerPipeHandle
)
;
}
}
}
