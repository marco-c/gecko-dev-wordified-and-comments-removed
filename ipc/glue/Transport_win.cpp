#
include
"
base
/
message_loop
.
h
"
#
include
"
chrome
/
common
/
child_process_info
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
using
namespace
std
;
using
base
:
:
ProcessHandle
;
namespace
mozilla
{
namespace
ipc
{
nsresult
CreateTransport
(
base
:
:
ProcessId
aProcIdOne
TransportDescriptor
*
aOne
TransportDescriptor
*
aTwo
)
{
wstring
id
=
IPC
:
:
Channel
:
:
GenerateVerifiedChannelID
(
std
:
:
wstring
(
)
)
;
Transport
t
(
id
Transport
:
:
MODE_SERVER
nullptr
)
;
HANDLE
serverPipe
=
t
.
GetServerPipeHandle
(
)
;
if
(
!
serverPipe
)
{
return
NS_ERROR_TRANSPORT_INIT
;
}
HANDLE
serverDup
;
DWORD
access
=
0
;
DWORD
options
=
DUPLICATE_SAME_ACCESS
;
if
(
!
DuplicateHandle
(
serverPipe
base
:
:
GetCurrentProcId
(
)
&
serverDup
access
options
)
)
{
return
NS_ERROR_DUPLICATE_HANDLE
;
}
aOne
-
>
mPipeName
=
aTwo
-
>
mPipeName
=
id
;
aOne
-
>
mServerPipeHandle
=
serverDup
;
aOne
-
>
mDestinationProcessId
=
aProcIdOne
;
aTwo
-
>
mServerPipeHandle
=
INVALID_HANDLE_VALUE
;
aTwo
-
>
mDestinationProcessId
=
0
;
return
NS_OK
;
}
HANDLE
TransferHandleToProcess
(
HANDLE
source
base
:
:
ProcessId
pid
)
{
if
(
source
=
=
INVALID_HANDLE_VALUE
)
{
return
source
;
}
HANDLE
handleDup
;
DWORD
access
=
0
;
DWORD
options
=
DUPLICATE_SAME_ACCESS
;
bool
ok
=
DuplicateHandle
(
source
pid
&
handleDup
access
options
)
;
if
(
!
ok
)
{
return
nullptr
;
}
CloseHandle
(
source
)
;
return
handleDup
;
}
Transport
*
OpenDescriptor
(
const
TransportDescriptor
&
aTd
Transport
:
:
Mode
aMode
)
{
if
(
aTd
.
mServerPipeHandle
!
=
INVALID_HANDLE_VALUE
)
{
MOZ_RELEASE_ASSERT
(
aTd
.
mDestinationProcessId
=
=
base
:
:
GetCurrentProcId
(
)
)
;
}
return
new
Transport
(
aTd
.
mPipeName
aTd
.
mServerPipeHandle
aMode
nullptr
)
;
}
Transport
*
OpenDescriptor
(
const
FileDescriptor
&
aFd
Transport
:
:
Mode
aMode
)
{
NS_NOTREACHED
(
"
Not
implemented
!
"
)
;
return
nullptr
;
}
TransportDescriptor
DuplicateDescriptor
(
const
TransportDescriptor
&
aTd
)
{
if
(
aTd
.
mServerPipeHandle
=
=
INVALID_HANDLE_VALUE
)
{
return
aTd
;
}
HANDLE
serverDup
;
DWORD
access
=
0
;
DWORD
options
=
DUPLICATE_SAME_ACCESS
;
bool
ok
=
DuplicateHandle
(
aTd
.
mServerPipeHandle
base
:
:
GetCurrentProcId
(
)
&
serverDup
access
options
)
;
if
(
!
ok
)
{
AnnotateSystemError
(
)
;
}
MOZ_RELEASE_ASSERT
(
ok
)
;
TransportDescriptor
desc
=
aTd
;
desc
.
mServerPipeHandle
=
serverDup
;
return
desc
;
}
void
CloseDescriptor
(
const
TransportDescriptor
&
aTd
)
{
CloseHandle
(
aTd
.
mServerPipeHandle
)
;
}
}
}
