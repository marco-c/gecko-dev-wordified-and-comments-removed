#
include
"
mozilla
/
ipc
/
SerializedStructuredCloneBuffer
.
h
"
#
include
"
js
/
StructuredClone
.
h
"
namespace
IPC
{
void
ParamTraits
<
JSStructuredCloneData
>
:
:
Write
(
MessageWriter
*
aWriter
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
!
(
aParam
.
Size
(
)
%
sizeof
(
uint64_t
)
)
)
;
mozilla
:
:
CheckedUint32
size
=
aParam
.
Size
(
)
;
if
(
!
size
.
isValid
(
)
)
{
aWriter
-
>
FatalError
(
"
JSStructuredCloneData
over
4Gb
in
size
"
)
;
return
;
}
WriteParam
(
aWriter
size
.
value
(
)
)
;
MessageBufferWriter
bufWriter
(
aWriter
size
.
value
(
)
)
;
aParam
.
ForEachDataChunk
(
[
&
]
(
const
char
*
aData
size_t
aSize
)
{
return
bufWriter
.
WriteBytes
(
aData
aSize
)
;
}
)
;
}
bool
ParamTraits
<
JSStructuredCloneData
>
:
:
Read
(
MessageReader
*
aReader
paramType
*
aResult
)
{
uint32_t
length
=
0
;
if
(
!
ReadParam
(
aReader
&
length
)
)
{
aReader
-
>
FatalError
(
"
JSStructuredCloneData
length
read
failed
"
)
;
return
false
;
}
MOZ_ASSERT
(
!
(
length
%
sizeof
(
uint64_t
)
)
)
;
mozilla
:
:
BufferList
<
js
:
:
SystemAllocPolicy
>
buffers
(
0
0
4096
)
;
MessageBufferReader
bufReader
(
aReader
length
)
;
uint32_t
read
=
0
;
while
(
read
<
length
)
{
size_t
bufLen
;
char
*
buf
=
buffers
.
AllocateBytes
(
length
-
read
&
bufLen
)
;
if
(
!
buf
)
{
NS_ABORT_OOM
(
length
-
read
)
;
return
false
;
}
if
(
!
bufReader
.
ReadBytesInto
(
buf
bufLen
)
)
{
aReader
-
>
FatalError
(
"
JSStructuredCloneData
ReadBytesInto
failed
"
)
;
return
false
;
}
read
+
=
bufLen
;
}
MOZ_ASSERT
(
read
=
=
length
)
;
*
aResult
=
JSStructuredCloneData
(
std
:
:
move
(
buffers
)
JS
:
:
StructuredCloneScope
:
:
DifferentProcess
OwnTransferablePolicy
:
:
IgnoreTransferablesIfAny
)
;
return
true
;
}
}
