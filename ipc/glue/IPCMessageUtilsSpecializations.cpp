#
include
"
IPCMessageUtilsSpecializations
.
h
"
#
include
"
nsGkAtoms
.
h
"
namespace
IPC
{
static
const
uint16_t
kDynamicAtomToken
=
0xffff
;
static
const
uint16_t
kAtomsCount
=
static_cast
<
uint16_t
>
(
mozilla
:
:
detail
:
:
GkAtoms
:
:
Atoms
:
:
AtomsCount
)
;
static_assert
(
static_cast
<
size_t
>
(
mozilla
:
:
detail
:
:
GkAtoms
:
:
Atoms
:
:
AtomsCount
)
=
=
kAtomsCount
"
Number
of
static
atoms
must
fit
in
a
uint16_t
"
)
;
static_assert
(
kDynamicAtomToken
>
=
kAtomsCount
"
Exceeded
supported
number
of
static
atoms
"
)
;
void
ParamTraits
<
nsAtom
*
>
:
:
Write
(
Message
*
aMsg
const
nsAtom
*
aParam
)
{
MOZ_ASSERT
(
aParam
)
;
if
(
aParam
-
>
IsStatic
(
)
)
{
const
nsStaticAtom
*
atom
=
aParam
-
>
AsStatic
(
)
;
uint16_t
index
=
static_cast
<
uint16_t
>
(
nsGkAtoms
:
:
IndexOf
(
atom
)
)
;
MOZ_ASSERT
(
index
<
kAtomsCount
)
;
WriteParam
(
aMsg
index
)
;
return
;
}
WriteParam
(
aMsg
kDynamicAtomToken
)
;
nsDependentAtomString
atomStr
(
aParam
)
;
nsString
&
str
=
atomStr
;
WriteParam
(
aMsg
str
)
;
}
bool
ParamTraits
<
nsAtom
*
>
:
:
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
RefPtr
<
nsAtom
>
*
aResult
)
{
uint16_t
token
;
if
(
!
ReadParam
(
aMsg
aIter
&
token
)
)
{
return
false
;
}
if
(
token
!
=
kDynamicAtomToken
)
{
if
(
token
>
=
kAtomsCount
)
{
return
false
;
}
*
aResult
=
nsGkAtoms
:
:
GetAtomByIndex
(
token
)
;
return
true
;
}
nsAutoString
str
;
if
(
!
ReadParam
(
aMsg
aIter
static_cast
<
nsString
*
>
(
&
str
)
)
)
{
return
false
;
}
*
aResult
=
NS_Atomize
(
str
)
;
MOZ_ASSERT
(
*
aResult
)
;
return
true
;
}
}
