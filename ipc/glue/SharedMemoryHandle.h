#
ifndef
mozilla_ipc_SharedMemoryHandle_h
#
define
mozilla_ipc_SharedMemoryHandle_h
#
include
<
utility
>
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
namespace
mozilla
:
:
ipc
{
namespace
shared_memory
{
#
if
defined
(
RUST_BINDGEN
)
using
PlatformHandle
=
void
*
;
#
elif
defined
(
XP_DARWIN
)
using
PlatformHandle
=
mozilla
:
:
UniqueMachSendRight
;
#
else
using
PlatformHandle
=
mozilla
:
:
UniqueFileHandle
;
#
endif
struct
Handle
;
struct
ReadOnlyHandle
;
class
HandleBase
{
public
:
uint64_t
Size
(
)
const
{
return
mSize
;
}
bool
IsValid
(
)
const
{
return
(
bool
)
*
this
;
}
explicit
operator
bool
(
)
const
{
return
(
bool
)
mHandle
;
}
friend
class
Platform
;
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
Handle
>
;
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
>
;
protected
:
HandleBase
(
)
;
MOZ_IMPLICIT
HandleBase
(
std
:
:
nullptr_t
)
{
}
~
HandleBase
(
)
;
HandleBase
(
HandleBase
&
&
aOther
)
:
mHandle
(
std
:
:
move
(
aOther
.
mHandle
)
)
mSize
(
std
:
:
exchange
(
aOther
.
mSize
0
)
)
{
}
HandleBase
&
operator
=
(
HandleBase
&
&
aOther
)
;
HandleBase
(
const
HandleBase
&
)
=
delete
;
HandleBase
&
operator
=
(
const
HandleBase
&
)
=
delete
;
HandleBase
Clone
(
)
const
;
template
<
typename
Derived
>
Derived
CloneAs
(
)
const
{
return
Clone
(
)
.
ConvertTo
<
Derived
>
(
)
;
}
template
<
typename
Derived
>
Derived
ConvertTo
(
)
&
&
{
Derived
d
;
static_cast
<
HandleBase
&
>
(
d
)
=
std
:
:
move
(
*
this
)
;
return
d
;
}
void
ToMessageWriter
(
IPC
:
:
MessageWriter
*
aWriter
)
&
&
;
bool
FromMessageReader
(
IPC
:
:
MessageReader
*
aReader
)
;
private
:
PlatformHandle
mHandle
=
nullptr
;
uint64_t
mSize
=
0
;
}
;
struct
Handle
:
HandleBase
{
Handle
(
)
=
default
;
MOZ_IMPLICIT
Handle
(
std
:
:
nullptr_t
)
{
}
Handle
Clone
(
)
const
{
return
CloneAs
<
Handle
>
(
)
;
}
struct
Mapping
Map
(
void
*
aFixedAddress
=
nullptr
)
const
;
struct
Mapping
MapSubregion
(
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
const
;
}
;
struct
ReadOnlyHandle
:
HandleBase
{
ReadOnlyHandle
(
)
=
default
;
MOZ_IMPLICIT
ReadOnlyHandle
(
std
:
:
nullptr_t
)
{
}
ReadOnlyHandle
Clone
(
)
const
{
return
CloneAs
<
ReadOnlyHandle
>
(
)
;
}
struct
ReadOnlyMapping
Map
(
void
*
aFixedAddress
=
nullptr
)
const
;
struct
ReadOnlyMapping
MapSubregion
(
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
const
;
}
;
struct
FreezableHandle
:
HandleBase
{
FreezableHandle
(
)
=
default
;
MOZ_IMPLICIT
FreezableHandle
(
std
:
:
nullptr_t
)
{
}
~
FreezableHandle
(
)
;
FreezableHandle
(
FreezableHandle
&
&
)
=
default
;
FreezableHandle
&
operator
=
(
FreezableHandle
&
&
)
=
default
;
Handle
WontFreeze
(
)
&
&
;
ReadOnlyHandle
Freeze
(
)
&
&
;
struct
FreezableMapping
Map
(
void
*
aFixedAddress
=
nullptr
)
&
&
;
struct
FreezableMapping
MapSubregion
(
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
&
&
;
friend
class
Platform
;
#
if
!
defined
(
XP_DARWIN
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
ANDROID
)
private
:
PlatformHandle
mFrozenFile
;
#
endif
}
;
Handle
Create
(
uint64_t
aSize
)
;
FreezableHandle
CreateFreezable
(
uint64_t
aSize
)
;
}
using
MutableSharedMemoryHandle
=
shared_memory
:
:
Handle
;
using
ReadOnlySharedMemoryHandle
=
shared_memory
:
:
ReadOnlyHandle
;
using
FreezableSharedMemoryHandle
=
shared_memory
:
:
FreezableHandle
;
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
Handle
>
{
static
void
Write
(
MessageWriter
*
aWriter
mozilla
:
:
ipc
:
:
shared_memory
:
:
Handle
&
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
mozilla
:
:
ipc
:
:
shared_memory
:
:
Handle
*
aResult
)
;
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
>
{
static
void
Write
(
MessageWriter
*
aWriter
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
&
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
*
aResult
)
;
}
;
}
#
endif
