#
ifndef
mozilla_ipc_SharedMemoryHandle_h
#
define
mozilla_ipc_SharedMemoryHandle_h
#
include
<
utility
>
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
namespace
IPC
{
template
<
class
P
>
struct
ParamTraits
;
class
MessageWriter
;
class
MessageReader
;
}
namespace
mozilla
:
:
geckoargs
{
template
<
typename
T
>
struct
CommandLineArg
;
}
namespace
mozilla
:
:
ipc
{
namespace
shared_memory
{
enum
class
Type
{
Mutable
ReadOnly
Freezable
}
;
#
if
defined
(
RUST_BINDGEN
)
using
PlatformHandle
=
void
*
;
#
elif
defined
(
XP_DARWIN
)
using
PlatformHandle
=
mozilla
:
:
UniqueMachSendRight
;
#
else
using
PlatformHandle
=
mozilla
:
:
UniqueFileHandle
;
#
endif
template
<
Type
T
>
struct
Handle
;
template
<
Type
T
bool
WithHandle
=
false
>
struct
Mapping
;
using
MutableHandle
=
Handle
<
Type
:
:
Mutable
>
;
using
ReadOnlyHandle
=
Handle
<
Type
:
:
ReadOnly
>
;
using
FreezableHandle
=
Handle
<
Type
:
:
Freezable
>
;
using
MutableMapping
=
Mapping
<
Type
:
:
Mutable
>
;
using
ReadOnlyMapping
=
Mapping
<
Type
:
:
ReadOnly
>
;
using
FreezableMapping
=
Mapping
<
Type
:
:
Freezable
>
;
using
MutableMappingWithHandle
=
Mapping
<
Type
:
:
Mutable
true
>
;
using
ReadOnlyMappingWithHandle
=
Mapping
<
Type
:
:
ReadOnly
true
>
;
class
HandleBase
{
public
:
uint64_t
Size
(
)
const
{
return
mSize
;
}
bool
IsValid
(
)
const
{
return
(
bool
)
*
this
;
}
explicit
operator
bool
(
)
const
{
return
(
bool
)
mHandle
;
}
PlatformHandle
TakePlatformHandle
(
)
&
&
{
return
std
:
:
move
(
mHandle
)
;
}
friend
class
Platform
;
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
MutableHandle
>
;
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
>
;
friend
struct
mozilla
:
:
geckoargs
:
:
CommandLineArg
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
>
;
protected
:
HandleBase
(
)
;
MOZ_IMPLICIT
HandleBase
(
std
:
:
nullptr_t
)
{
}
~
HandleBase
(
)
;
HandleBase
(
HandleBase
&
&
aOther
)
:
mHandle
(
std
:
:
move
(
aOther
.
mHandle
)
)
mSize
(
std
:
:
exchange
(
aOther
.
mSize
0
)
)
{
}
HandleBase
&
operator
=
(
HandleBase
&
&
aOther
)
;
HandleBase
(
const
HandleBase
&
)
=
delete
;
HandleBase
&
operator
=
(
const
HandleBase
&
)
=
delete
;
HandleBase
Clone
(
)
const
;
template
<
Type
T
>
Handle
<
T
>
CloneAs
(
)
const
{
return
Clone
(
)
.
ConvertTo
<
T
>
(
)
;
}
template
<
Type
T
>
Handle
<
T
>
ConvertTo
(
)
&
&
{
Handle
<
T
>
d
;
static_cast
<
HandleBase
&
>
(
d
)
=
std
:
:
move
(
*
this
)
;
return
d
;
}
void
ToMessageWriter
(
IPC
:
:
MessageWriter
*
aWriter
)
&
&
;
bool
FromMessageReader
(
IPC
:
:
MessageReader
*
aReader
)
;
private
:
void
SetSize
(
uint64_t
aSize
)
;
PlatformHandle
mHandle
=
nullptr
;
uint64_t
mSize
=
0
;
}
;
template
<
>
struct
Handle
<
Type
:
:
Mutable
>
:
HandleBase
{
Handle
(
)
=
default
;
MOZ_IMPLICIT
Handle
(
std
:
:
nullptr_t
)
{
}
Handle
Clone
(
)
const
{
return
CloneAs
<
Type
:
:
Mutable
>
(
)
;
}
ReadOnlyHandle
ToReadOnly
(
)
&
&
;
const
ReadOnlyHandle
&
AsReadOnly
(
)
const
;
MutableMapping
Map
(
void
*
aFixedAddress
=
nullptr
)
const
;
MutableMapping
MapSubregion
(
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
const
;
MutableMappingWithHandle
MapWithHandle
(
void
*
aFixedAddress
=
nullptr
)
&
&
;
}
;
template
<
>
struct
Handle
<
Type
:
:
ReadOnly
>
:
HandleBase
{
Handle
(
)
=
default
;
MOZ_IMPLICIT
Handle
(
std
:
:
nullptr_t
)
{
}
Handle
Clone
(
)
const
{
return
CloneAs
<
Type
:
:
ReadOnly
>
(
)
;
}
ReadOnlyMapping
Map
(
void
*
aFixedAddress
=
nullptr
)
const
;
ReadOnlyMapping
MapSubregion
(
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
const
;
ReadOnlyMappingWithHandle
MapWithHandle
(
void
*
aFixedAddress
=
nullptr
)
&
&
;
}
;
template
<
>
struct
Handle
<
Type
:
:
Freezable
>
:
HandleBase
{
Handle
(
)
=
default
;
MOZ_IMPLICIT
Handle
(
std
:
:
nullptr_t
)
{
}
~
Handle
(
)
;
Handle
(
Handle
&
&
)
=
default
;
Handle
&
operator
=
(
Handle
&
&
)
=
default
;
MutableHandle
WontFreeze
(
)
&
&
;
ReadOnlyHandle
Freeze
(
)
&
&
;
FreezableMapping
Map
(
void
*
aFixedAddress
=
nullptr
)
&
&
;
FreezableMapping
MapSubregion
(
uint64_t
aOffset
size_t
aSize
void
*
aFixedAddress
=
nullptr
)
&
&
;
friend
class
Platform
;
#
if
!
defined
(
XP_DARWIN
)
&
&
!
defined
(
XP_WIN
)
&
&
!
defined
(
ANDROID
)
private
:
PlatformHandle
mFrozenFile
;
#
endif
}
;
MutableHandle
Create
(
uint64_t
aSize
)
;
FreezableHandle
CreateFreezable
(
uint64_t
aSize
)
;
#
if
defined
(
XP_LINUX
)
bool
AppendPosixShmPrefix
(
std
:
:
string
*
str
pid_t
pid
)
;
bool
UsingPosixShm
(
)
;
#
endif
}
using
MutableSharedMemoryHandle
=
shared_memory
:
:
MutableHandle
;
using
ReadOnlySharedMemoryHandle
=
shared_memory
:
:
ReadOnlyHandle
;
using
FreezableSharedMemoryHandle
=
shared_memory
:
:
FreezableHandle
;
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
MutableHandle
>
{
static
void
Write
(
MessageWriter
*
aWriter
mozilla
:
:
ipc
:
:
shared_memory
:
:
MutableHandle
&
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
mozilla
:
:
ipc
:
:
shared_memory
:
:
MutableHandle
*
aResult
)
;
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
>
{
static
void
Write
(
MessageWriter
*
aWriter
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
&
&
aParam
)
;
static
bool
Read
(
MessageReader
*
aReader
mozilla
:
:
ipc
:
:
shared_memory
:
:
ReadOnlyHandle
*
aResult
)
;
}
;
}
#
endif
