#
ifndef
mozilla_ipc_backgroundparent_h__
#
define
mozilla_ipc_backgroundparent_h__
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
ifdef
DEBUG
#
include
"
nsXULAppAPI
.
h
"
#
endif
template
<
class
>
struct
already_AddRefed
;
namespace
mozilla
{
namespace
net
{
class
SocketProcessBridgeParent
;
class
SocketProcessParent
;
}
namespace
dom
{
class
BlobImpl
;
class
ContentParent
;
}
namespace
ipc
{
class
BackgroundStarterParent
;
class
PBackgroundParent
;
class
PBackgroundStarterParent
;
template
<
class
PFooSide
>
class
Endpoint
;
class
BackgroundParent
final
{
friend
class
mozilla
:
:
ipc
:
:
BackgroundStarterParent
;
friend
class
mozilla
:
:
dom
:
:
ContentParent
;
friend
class
mozilla
:
:
net
:
:
SocketProcessBridgeParent
;
friend
class
mozilla
:
:
net
:
:
SocketProcessParent
;
using
ProcessId
=
base
:
:
ProcessId
;
using
BlobImpl
=
mozilla
:
:
dom
:
:
BlobImpl
;
using
ContentParent
=
mozilla
:
:
dom
:
:
ContentParent
;
using
ThreadsafeContentParentHandle
=
mozilla
:
:
dom
:
:
ThreadsafeContentParentHandle
;
public
:
static
bool
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
;
static
ThreadsafeContentParentHandle
*
GetContentParentHandle
(
PBackgroundParent
*
aBackgroundActor
)
;
static
uint64_t
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
;
static
void
KillHardAsync
(
PBackgroundParent
*
aBackgroundActor
const
nsACString
&
aReason
)
;
private
:
static
bool
AllocStarter
(
ContentParent
*
aContent
Endpoint
<
PBackgroundStarterParent
>
&
&
aEndpoint
)
;
static
bool
AllocStarter
(
Endpoint
<
PBackgroundStarterParent
>
&
&
aEndpoint
)
;
}
;
bool
IsOnBackgroundThread
(
)
;
#
ifdef
DEBUG
void
AssertIsOnBackgroundThread
(
)
;
#
else
inline
void
AssertIsOnBackgroundThread
(
)
{
}
#
endif
inline
void
AssertIsInMainProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
}
}
#
endif
