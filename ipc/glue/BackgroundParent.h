#
ifndef
mozilla_ipc_backgroundparent_h__
#
define
mozilla_ipc_backgroundparent_h__
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
ifdef
DEBUG
#
include
"
nsXULAppAPI
.
h
"
#
endif
template
<
class
>
struct
already_AddRefed
;
namespace
mozilla
{
namespace
net
{
class
SocketProcessBridgeParent
;
class
SocketProcessParent
;
}
namespace
dom
{
class
BlobImpl
;
class
ContentParent
;
}
namespace
ipc
{
class
PBackgroundParent
;
template
<
class
PFooSide
>
class
Endpoint
;
class
BackgroundParent
final
{
friend
class
mozilla
:
:
dom
:
:
ContentParent
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
mozilla
:
:
dom
:
:
BlobImpl
BlobImpl
;
typedef
mozilla
:
:
dom
:
:
ContentParent
ContentParent
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
friend
class
mozilla
:
:
net
:
:
SocketProcessBridgeParent
;
friend
class
mozilla
:
:
net
:
:
SocketProcessParent
;
public
:
static
bool
IsOtherProcessActor
(
PBackgroundParent
*
aBackgroundActor
)
;
static
already_AddRefed
<
ContentParent
>
GetContentParent
(
PBackgroundParent
*
aBackgroundActor
)
;
static
intptr_t
GetRawContentParentForComparison
(
PBackgroundParent
*
aBackgroundActor
)
;
static
uint64_t
GetChildID
(
PBackgroundParent
*
aBackgroundActor
)
;
static
bool
GetLiveActorArray
(
PBackgroundParent
*
aBackgroundActor
nsTArray
<
PBackgroundParent
*
>
&
aLiveActorArray
)
;
private
:
static
bool
Alloc
(
ContentParent
*
aContent
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
;
static
bool
Alloc
(
Endpoint
<
PBackgroundParent
>
&
&
aEndpoint
)
;
}
;
bool
IsOnBackgroundThread
(
)
;
#
ifdef
DEBUG
void
AssertIsOnBackgroundThread
(
)
;
#
else
inline
void
AssertIsOnBackgroundThread
(
)
{
}
#
endif
inline
void
AssertIsInMainProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
inline
void
AssertIsInMainOrSocketProcess
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
|
|
XRE_IsSocketProcess
(
)
)
;
}
}
}
#
endif
