#
ifndef
mozilla_ipc_ProtocolUtils_h
#
define
mozilla_ipc_ProtocolUtils_h
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
IPCMessageStart
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
"
mojo
/
core
/
ports
/
port_ref
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FunctionRef
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MoveOnlyFunction
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
prenv
.
h
"
#
if
defined
(
ANDROID
)
&
&
defined
(
DEBUG
)
#
include
<
android
/
log
.
h
>
#
endif
template
<
typename
T
>
class
nsPtrHashKey
;
namespace
{
enum
{
DATA_PIPE_CLOSED_MESSAGE_TYPE
=
kuint16max
-
18
DATA_PIPE_BYTES_CONSUMED_MESSAGE_TYPE
=
kuint16max
-
17
ACCEPT_INVITE_MESSAGE_TYPE
=
kuint16max
-
16
REQUEST_INTRODUCTION_MESSAGE_TYPE
=
kuint16max
-
15
INTRODUCE_MESSAGE_TYPE
=
kuint16max
-
14
BROADCAST_MESSAGE_TYPE
=
kuint16max
-
13
EVENT_MESSAGE_TYPE
=
kuint16max
-
12
MANAGED_ENDPOINT_DROPPED_MESSAGE_TYPE
=
kuint16max
-
11
MANAGED_ENDPOINT_BOUND_MESSAGE_TYPE
=
kuint16max
-
10
IMPENDING_SHUTDOWN_MESSAGE_TYPE
=
kuint16max
-
9
BUILD_IDS_MATCH_MESSAGE_TYPE
=
kuint16max
-
8
BUILD_ID_MESSAGE_TYPE
=
kuint16max
-
7
CHANNEL_OPENED_MESSAGE_TYPE
=
kuint16max
-
6
SHMEM_DESTROYED_MESSAGE_TYPE
=
kuint16max
-
5
SHMEM_CREATED_MESSAGE_TYPE
=
kuint16max
-
4
GOODBYE_MESSAGE_TYPE
=
kuint16max
-
3
CANCEL_MESSAGE_TYPE
=
kuint16max
-
2
}
;
}
class
MessageLoop
;
class
PickleIterator
;
class
nsISerialEventTarget
;
namespace
mozilla
{
class
SchedulerGroup
;
class
UntypedManagedContainer
;
namespace
dom
{
class
ContentParent
;
}
namespace
net
{
class
NeckoParent
;
}
namespace
ipc
{
class
ProtocolFdMapping
;
class
ProtocolCloneContext
;
struct
EndpointProcInfo
{
base
:
:
ProcessId
mPid
=
base
:
:
kInvalidProcessId
;
GeckoChildID
mChildID
=
kInvalidGeckoChildID
;
bool
operator
=
=
(
const
EndpointProcInfo
&
aOther
)
const
{
return
mPid
=
=
aOther
.
mPid
&
&
mChildID
=
=
aOther
.
mChildID
;
}
bool
operator
!
=
(
const
EndpointProcInfo
&
aOther
)
const
{
return
!
operator
=
=
(
aOther
)
;
}
static
EndpointProcInfo
Invalid
(
)
{
return
{
}
;
}
static
EndpointProcInfo
Current
(
)
;
}
;
struct
ActorHandle
{
int
mId
;
}
;
enum
class
LinkStatus
:
uint8_t
{
Inactive
Connected
Doomed
Destroyed
}
;
typedef
IPCMessageStart
ProtocolId
;
const
char
*
ProtocolIdToName
(
IPCMessageStart
aId
)
;
class
IRefCountedProtocol
;
class
IToplevelProtocol
;
class
ActorLifecycleProxy
;
class
WeakActorLifecycleProxy
;
class
IPDLResolverInner
;
class
UntypedManagedEndpoint
;
class
IProtocol
:
public
HasResultCodes
{
public
:
enum
ActorDestroyReason
{
FailedConstructor
Deletion
AncestorDeletion
NormalShutdown
AbnormalShutdown
ManagedEndpointDropped
}
;
using
ProcessId
=
base
:
:
ProcessId
;
using
Message
=
IPC
:
:
Message
;
IProtocol
(
ProtocolId
aProtoId
Side
aSide
)
:
mId
(
0
)
mProtocolId
(
aProtoId
)
mSide
(
aSide
)
mLinkStatus
(
LinkStatus
:
:
Inactive
)
mLifecycleProxy
(
nullptr
)
mManager
(
nullptr
)
mToplevel
(
nullptr
)
{
}
IToplevelProtocol
*
ToplevelProtocol
(
)
{
return
mToplevel
;
}
const
IToplevelProtocol
*
ToplevelProtocol
(
)
const
{
return
mToplevel
;
}
IProtocol
*
Lookup
(
int32_t
aId
)
;
Shmem
CreateSharedMemory
(
size_t
aSize
bool
aUnsafe
)
;
Shmem
:
:
Segment
*
LookupSharedMemory
(
int32_t
aId
)
;
bool
IsTrackingSharedMemory
(
const
Shmem
:
:
Segment
*
aSegment
)
;
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
;
MessageChannel
*
GetIPCChannel
(
)
;
const
MessageChannel
*
GetIPCChannel
(
)
const
;
nsISerialEventTarget
*
GetActorEventTarget
(
)
;
ProtocolId
GetProtocolId
(
)
const
{
return
mProtocolId
;
}
const
char
*
GetProtocolName
(
)
const
{
return
ProtocolIdToName
(
mProtocolId
)
;
}
int32_t
Id
(
)
const
{
return
mId
;
}
IRefCountedProtocol
*
Manager
(
)
const
{
return
mManager
;
}
uint32_t
AllManagedActorsCount
(
)
const
;
ActorLifecycleProxy
*
GetLifecycleProxy
(
)
{
return
mLifecycleProxy
;
}
WeakActorLifecycleProxy
*
GetWeakLifecycleProxy
(
)
;
Side
GetSide
(
)
const
{
return
mSide
;
}
bool
CanSend
(
)
const
{
return
mLinkStatus
=
=
LinkStatus
:
:
Connected
;
}
bool
CanRecv
(
)
const
{
return
mLinkStatus
=
=
LinkStatus
:
:
Connected
|
|
mLinkStatus
=
=
LinkStatus
:
:
Doomed
;
}
virtual
void
DeallocManagee
(
int32_t
IProtocol
*
)
=
0
;
Maybe
<
IProtocol
*
>
ReadActor
(
IPC
:
:
MessageReader
*
aReader
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
)
=
0
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
UniquePtr
<
Message
>
&
aReply
)
=
0
;
bool
AllocShmem
(
size_t
aSize
Shmem
*
aOutMem
)
;
bool
AllocUnsafeShmem
(
size_t
aSize
Shmem
*
aOutMem
)
;
bool
DeallocShmem
(
Shmem
&
aMem
)
;
void
FatalError
(
const
char
*
const
aErrorMsg
)
;
virtual
void
HandleFatalError
(
const
char
*
aErrorMsg
)
;
protected
:
virtual
~
IProtocol
(
)
;
friend
class
IToplevelProtocol
;
friend
class
ActorLifecycleProxy
;
friend
class
IPDLResolverInner
;
friend
class
UntypedManagedEndpoint
;
void
SetManager
(
IRefCountedProtocol
*
aManager
)
;
void
UnlinkManager
(
)
;
bool
SetManagerAndRegister
(
IRefCountedProtocol
*
aManager
int32_t
aId
=
kNullActorId
)
;
bool
ChannelSend
(
UniquePtr
<
IPC
:
:
Message
>
aMsg
int32_t
*
aSeqno
=
nullptr
)
;
bool
ChannelSend
(
UniquePtr
<
IPC
:
:
Message
>
aMsg
UniquePtr
<
IPC
:
:
Message
>
*
aReply
)
;
already_AddRefed
<
ActorLifecycleProxy
>
ActorConnected
(
)
;
void
ActorDisconnected
(
ActorDestroyReason
aWhy
)
;
virtual
Span
<
const
ProtocolId
>
ManagedProtocolIds
(
)
const
=
0
;
virtual
UntypedManagedContainer
*
GetManagedActors
(
ProtocolId
aProtocol
)
=
0
;
const
UntypedManagedContainer
*
GetManagedActors
(
ProtocolId
aProtocol
)
const
{
return
const_cast
<
IProtocol
*
>
(
this
)
-
>
GetManagedActors
(
aProtocol
)
;
}
virtual
void
RejectPendingResponses
(
ResponseRejectReason
aReason
)
{
}
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
}
virtual
void
ActorAlloc
(
)
=
0
;
virtual
void
ActorDealloc
(
)
=
0
;
static
const
int32_t
kNullActorId
=
0
;
static
const
int32_t
kFreedActorId
=
1
;
private
:
#
ifdef
DEBUG
void
WarnMessageDiscarded
(
IPC
:
:
Message
*
aMsg
)
;
#
else
void
WarnMessageDiscarded
(
IPC
:
:
Message
*
)
{
}
#
endif
void
DoomSubtree
(
)
;
IProtocol
*
PeekManagedActor
(
)
const
;
int32_t
mId
;
const
ProtocolId
mProtocolId
;
const
Side
mSide
;
LinkStatus
mLinkStatus
;
ActorLifecycleProxy
*
mLifecycleProxy
;
RefPtr
<
IRefCountedProtocol
>
mManager
;
IToplevelProtocol
*
mToplevel
;
}
;
#
define
IPC_OK
(
)
mozilla
:
:
ipc
:
:
IPCResult
:
:
Ok
(
)
#
define
IPC_FAIL
(
actor
why
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
(
why
)
)
#
define
IPC_FAIL_NO_REASON
(
actor
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
)
#
define
IPC_FAIL_UNSAFE_PRINTF
(
actor
format
.
.
.
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
FailUnsafePrintfImpl
(
\
WrapNotNull
(
actor
)
__func__
nsPrintfCString
(
format
#
#
__VA_ARGS__
)
)
#
define
IPC_TEST_FAIL
(
actor
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
FailForTesting
(
WrapNotNull
(
actor
)
__func__
"
"
)
class
IPCResult
{
public
:
static
IPCResult
Ok
(
)
{
return
IPCResult
(
true
)
;
}
template
<
size_t
N
size_t
M
>
static
IPCResult
Fail
(
NotNull
<
IProtocol
*
>
aActor
const
char
(
&
aWhere
)
[
N
]
const
char
(
&
aWhy
)
[
M
]
)
{
return
FailImpl
(
aActor
aWhere
aWhy
)
;
}
template
<
size_t
N
>
static
IPCResult
Fail
(
NotNull
<
IProtocol
*
>
aActor
const
char
(
&
aWhere
)
[
N
]
)
{
return
FailImpl
(
aActor
aWhere
"
"
)
;
}
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mSuccess
;
}
template
<
size_t
N
>
static
IPCResult
FailUnsafePrintfImpl
(
NotNull
<
IProtocol
*
>
aActor
const
char
(
&
aWhere
)
[
N
]
nsPrintfCString
const
&
aWhy
)
{
return
FailImpl
(
aActor
aWhere
aWhy
.
get
(
)
)
;
}
static
IPCResult
FailForTesting
(
NotNull
<
IProtocol
*
>
aActor
const
char
*
aWhere
const
char
*
aWhy
)
;
private
:
static
IPCResult
FailImpl
(
NotNull
<
IProtocol
*
>
aActor
const
char
*
aWhere
const
char
*
aWhy
)
;
explicit
IPCResult
(
bool
aResult
)
:
mSuccess
(
aResult
)
{
}
bool
mSuccess
;
}
;
class
UntypedEndpoint
;
template
<
class
PFooSide
>
class
Endpoint
;
template
<
class
PFooSide
>
class
ManagedEndpoint
;
class
IRefCountedProtocol
:
public
IProtocol
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
using
IProtocol
:
:
IProtocol
;
}
;
class
IToplevelProtocol
:
public
IRefCountedProtocol
{
friend
class
IProtocol
;
template
<
class
PFooSide
>
friend
class
Endpoint
;
protected
:
explicit
IToplevelProtocol
(
const
char
*
aName
ProtocolId
aProtoId
Side
aSide
)
;
~
IToplevelProtocol
(
)
=
default
;
public
:
IProtocol
*
Lookup
(
int32_t
aId
)
;
Shmem
CreateSharedMemory
(
size_t
aSize
bool
aUnsafe
)
;
Shmem
:
:
Segment
*
LookupSharedMemory
(
int32_t
aId
)
;
bool
IsTrackingSharedMemory
(
const
Shmem
:
:
Segment
*
aSegment
)
;
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
;
MessageChannel
*
GetIPCChannel
(
)
{
return
&
mChannel
;
}
const
MessageChannel
*
GetIPCChannel
(
)
const
{
return
&
mChannel
;
}
void
SetOtherEndpointProcInfo
(
EndpointProcInfo
aOtherProcInfo
)
;
virtual
void
ProcessingError
(
Result
aError
const
char
*
aMsgName
)
{
}
bool
Open
(
ScopedPort
aPort
const
nsID
&
aMessageChannelId
EndpointProcInfo
aOtherProcInfo
nsISerialEventTarget
*
aEventTarget
=
nullptr
)
;
bool
Open
(
IToplevelProtocol
*
aTarget
nsISerialEventTarget
*
aEventTarget
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
OpenOnSameThread
(
IToplevelProtocol
*
aTarget
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
void
NotifyImpendingShutdown
(
)
;
void
Close
(
)
;
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
void
DeallocShmems
(
)
;
bool
ShmemCreated
(
const
Message
&
aMsg
)
;
bool
ShmemDestroyed
(
const
Message
&
aMsg
)
;
virtual
bool
ShouldContinueFromReplyTimeout
(
)
{
return
false
;
}
virtual
void
IntentionalCrash
(
)
{
MOZ_CRASH
(
"
Intentional
IPDL
crash
"
)
;
}
#
ifdef
DEBUG
virtual
bool
ArtificialTimeout
(
)
{
return
false
;
}
virtual
bool
NeedArtificialSleep
(
)
{
return
false
;
}
virtual
void
ArtificialSleep
(
)
{
}
#
else
bool
ArtificialTimeout
(
)
{
return
false
;
}
bool
NeedArtificialSleep
(
)
{
return
false
;
}
void
ArtificialSleep
(
)
{
}
#
endif
bool
IsOnCxxStack
(
)
const
;
virtual
void
ProcessRemoteNativeEventsInInterruptCall
(
)
{
}
virtual
void
OnChannelReceivedMessage
(
const
Message
&
aMsg
)
{
}
void
OnIPCChannelOpened
(
)
{
Unused
<
<
ActorConnected
(
)
;
}
void
OnChannelClose
(
)
{
RefPtr
<
ActorLifecycleProxy
>
proxy
=
dont_AddRef
(
GetLifecycleProxy
(
)
)
;
ActorDisconnected
(
NormalShutdown
)
;
DeallocShmems
(
)
;
}
void
OnChannelError
(
)
{
RefPtr
<
ActorLifecycleProxy
>
proxy
=
dont_AddRef
(
GetLifecycleProxy
(
)
)
;
ActorDisconnected
(
AbnormalShutdown
)
;
DeallocShmems
(
)
;
}
base
:
:
ProcessId
OtherPidMaybeInvalid
(
)
const
{
return
mOtherPid
;
}
GeckoChildID
OtherChildIDMaybeInvalid
(
)
const
{
return
mOtherChildID
;
}
private
:
int32_t
NextId
(
)
;
template
<
class
T
>
using
IDMap
=
nsTHashMap
<
nsUint32HashKey
T
>
;
base
:
:
ProcessId
mOtherPid
;
GeckoChildID
mOtherChildID
;
int32_t
mLastLocalId
;
IDMap
<
RefPtr
<
ActorLifecycleProxy
>
>
mActorMap
;
IDMap
<
RefPtr
<
Shmem
:
:
Segment
>
>
mShmemMap
;
MessageChannel
mChannel
;
}
;
class
IShmemAllocator
{
public
:
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
=
0
;
}
;
#
define
FORWARD_SHMEM_ALLOCATOR_TO
(
aImplClass
)
\
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
\
override
{
\
return
aImplClass
:
:
AllocShmem
(
aSize
aShmem
)
;
\
}
\
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
\
override
{
\
return
aImplClass
:
:
AllocUnsafeShmem
(
aSize
aShmem
)
;
\
}
\
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
{
\
return
aImplClass
:
:
DeallocShmem
(
aShmem
)
;
\
}
inline
bool
LoggingEnabled
(
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
!
!
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
#
else
return
false
;
#
endif
}
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
mozilla
:
:
ipc
:
:
Side
aSide
const
char
*
aFilter
)
;
#
endif
inline
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
mozilla
:
:
ipc
:
:
Side
aSide
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
LoggingEnabledFor
(
aTopLevelProtocol
aSide
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
)
;
#
else
return
false
;
#
endif
}
MOZ_NEVER_INLINE
void
LogMessageForProtocol
(
const
char
*
aTopLevelProtocol
base
:
:
ProcessId
aOtherPid
const
char
*
aContextDescription
uint32_t
aMessageId
MessageDirection
aDirection
)
;
MOZ_NEVER_INLINE
void
ProtocolErrorBreakpoint
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
PickleFatalError
(
const
char
*
aMsg
IProtocol
*
aActor
)
;
MOZ_NEVER_INLINE
void
FatalError
(
const
char
*
aMsg
bool
aIsParent
)
;
MOZ_NEVER_INLINE
void
LogicError
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
ActorIdReadError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
BadActorIdError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
ActorLookupError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
MismatchedActorTypeError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
UnionTypeReadError
(
const
char
*
aUnionName
)
;
MOZ_NEVER_INLINE
void
ArrayLengthReadError
(
const
char
*
aElementName
)
;
MOZ_NEVER_INLINE
void
SentinelReadError
(
const
char
*
aElementName
)
;
void
AnnotateSystemError
(
)
;
class
ActorLifecycleProxy
{
public
:
NS_INLINE_DECL_REFCOUNTING_ONEVENTTARGET
(
ActorLifecycleProxy
)
IProtocol
*
Get
(
)
{
return
mActor
;
}
WeakActorLifecycleProxy
*
GetWeakProxy
(
)
;
private
:
friend
class
IProtocol
;
explicit
ActorLifecycleProxy
(
IProtocol
*
aActor
)
;
~
ActorLifecycleProxy
(
)
;
ActorLifecycleProxy
(
const
ActorLifecycleProxy
&
)
=
delete
;
ActorLifecycleProxy
&
operator
=
(
const
ActorLifecycleProxy
&
)
=
delete
;
IProtocol
*
MOZ_NON_OWNING_REF
mActor
;
RefPtr
<
WeakActorLifecycleProxy
>
mWeakProxy
;
}
;
class
WeakActorLifecycleProxy
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WeakActorLifecycleProxy
)
IProtocol
*
Get
(
)
const
;
nsISerialEventTarget
*
ActorEventTarget
(
)
const
{
return
mActorEventTarget
;
}
private
:
friend
class
ActorLifecycleProxy
;
explicit
WeakActorLifecycleProxy
(
ActorLifecycleProxy
*
aProxy
)
;
~
WeakActorLifecycleProxy
(
)
;
WeakActorLifecycleProxy
(
const
WeakActorLifecycleProxy
&
)
=
delete
;
WeakActorLifecycleProxy
&
operator
=
(
const
WeakActorLifecycleProxy
&
)
=
delete
;
ActorLifecycleProxy
*
MOZ_NON_OWNING_REF
mProxy
;
const
nsCOMPtr
<
nsISerialEventTarget
>
mActorEventTarget
;
}
;
class
IPDLResolverInner
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DESTROY
(
IPDLResolverInner
Destroy
(
)
)
explicit
IPDLResolverInner
(
UniquePtr
<
IPC
:
:
Message
>
aReply
IProtocol
*
aActor
)
;
template
<
typename
F
>
void
Resolve
(
F
&
&
aWrite
)
{
ResolveOrReject
(
true
std
:
:
forward
<
F
>
(
aWrite
)
)
;
}
private
:
void
ResolveOrReject
(
bool
aResolve
FunctionRef
<
void
(
IPC
:
:
Message
*
IProtocol
*
)
>
aWrite
)
;
void
Destroy
(
)
;
~
IPDLResolverInner
(
)
;
UniquePtr
<
IPC
:
:
Message
>
mReply
;
RefPtr
<
WeakActorLifecycleProxy
>
mWeakProxy
;
}
;
class
IPDLAsyncReturnsCallbacks
:
public
HasResultCodes
{
public
:
using
Callback
=
mozilla
:
:
MoveOnlyFunction
<
Result
(
IPC
:
:
MessageReader
*
IProtocol
)
>
;
using
msgid_t
=
IPC
:
:
Message
:
:
msgid_t
;
void
AddCallback
(
int32_t
aSeqno
msgid_t
aType
Callback
aResolve
RejectCallback
aReject
)
;
Result
GotReply
(
IProtocol
*
aActor
const
IPC
:
:
Message
&
aMessage
)
;
void
RejectPendingResponses
(
ResponseRejectReason
aReason
)
;
private
:
struct
EntryKey
{
int32_t
mSeqno
;
msgid_t
mType
;
bool
operator
=
=
(
const
EntryKey
&
aOther
)
const
;
bool
operator
<
(
const
EntryKey
&
aOther
)
const
;
}
;
struct
Entry
:
EntryKey
{
Callback
mResolve
;
RejectCallback
mReject
;
}
;
nsTArray
<
Entry
>
mMap
;
}
;
}
class
UntypedManagedContainer
{
public
:
using
iterator
=
nsTArray
<
mozilla
:
:
ipc
:
:
IProtocol
*
>
:
:
const_iterator
;
iterator
begin
(
)
const
{
return
mArray
.
cbegin
(
)
;
}
iterator
end
(
)
const
{
return
mArray
.
cend
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mArray
.
IsEmpty
(
)
;
}
uint32_t
Count
(
)
const
{
return
mArray
.
Length
(
)
;
}
protected
:
explicit
UntypedManagedContainer
(
mozilla
:
:
ipc
:
:
ProtocolId
aProtocolId
)
#
ifdef
DEBUG
:
mProtocolId
(
aProtocolId
)
#
endif
{
}
private
:
friend
class
mozilla
:
:
ipc
:
:
IProtocol
;
bool
EnsureRemoved
(
mozilla
:
:
ipc
:
:
IProtocol
*
aElement
)
{
return
mArray
.
RemoveElementSorted
(
aElement
)
;
}
void
Insert
(
mozilla
:
:
ipc
:
:
IProtocol
*
aElement
)
{
MOZ_ASSERT
(
aElement
-
>
GetProtocolId
(
)
=
=
mProtocolId
"
ManagedContainer
can
only
contain
a
single
protocol
"
)
;
size_t
index
=
mArray
.
IndexOfFirstElementGt
(
aElement
)
;
if
(
index
=
=
0
|
|
mArray
[
index
-
1
]
!
=
aElement
)
{
mArray
.
InsertElementAt
(
index
aElement
)
;
}
}
nsTArray
<
mozilla
:
:
ipc
:
:
IProtocol
*
>
mArray
;
#
ifdef
DEBUG
mozilla
:
:
ipc
:
:
ProtocolId
mProtocolId
;
#
endif
}
;
template
<
typename
Protocol
>
class
ManagedContainer
:
public
UntypedManagedContainer
{
public
:
ManagedContainer
(
)
:
UntypedManagedContainer
(
Protocol
:
:
kProtocolId
)
{
}
class
iterator
{
public
:
using
value_type
=
Protocol
*
;
using
difference_type
=
ptrdiff_t
;
using
pointer
=
value_type
*
;
using
reference
=
value_type
;
using
iterator_category
=
std
:
:
input_iterator_tag
;
private
:
friend
class
ManagedContainer
;
explicit
iterator
(
const
UntypedManagedContainer
:
:
iterator
&
aIter
)
:
mIter
(
aIter
)
{
}
UntypedManagedContainer
:
:
iterator
mIter
;
public
:
iterator
(
)
=
default
;
bool
operator
=
=
(
const
iterator
&
aRhs
)
const
{
return
mIter
=
=
aRhs
.
mIter
;
}
bool
operator
!
=
(
const
iterator
&
aRhs
)
const
{
return
mIter
!
=
aRhs
.
mIter
;
}
reference
operator
*
(
)
const
{
return
static_cast
<
value_type
>
(
*
mIter
)
;
}
iterator
&
operator
+
+
(
)
{
+
+
mIter
;
return
*
this
;
}
iterator
operator
+
+
(
int
)
{
return
iterator
{
mIter
+
+
}
;
}
}
;
iterator
begin
(
)
const
{
return
iterator
{
UntypedManagedContainer
:
:
begin
(
)
}
;
}
iterator
end
(
)
const
{
return
iterator
{
UntypedManagedContainer
:
:
end
(
)
}
;
}
void
ToArray
(
nsTArray
<
Protocol
*
>
&
aArray
)
const
{
aArray
.
SetCapacity
(
Count
(
)
)
;
for
(
Protocol
*
p
:
*
this
)
{
aArray
.
AppendElement
(
p
)
;
}
}
}
;
template
<
typename
Protocol
>
Protocol
*
LoneManagedOrNullAsserts
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aManagees
.
Count
(
)
=
=
1
)
;
return
*
aManagees
.
begin
(
)
;
}
template
<
typename
Protocol
>
Protocol
*
SingleManagedOrNull
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
Count
(
)
!
=
1
)
{
return
nullptr
;
}
return
*
aManagees
.
begin
(
)
;
}
}
#
endif
