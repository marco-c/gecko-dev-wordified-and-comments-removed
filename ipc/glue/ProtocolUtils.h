#
ifndef
mozilla_ipc_ProtocolUtils_h
#
define
mozilla_ipc_ProtocolUtils_h
1
#
include
"
base
/
id_map
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
IPCMessageStart
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ipc
/
ByteBuf
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
recordreplay
/
ChildIPC
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsICrashReporter
.
h
"
#
include
"
nsILabelableRunnable
.
h
"
#
if
defined
(
ANDROID
)
&
&
defined
(
DEBUG
)
#
include
<
android
/
log
.
h
>
#
endif
template
<
typename
T
>
class
nsTHashtable
;
template
<
typename
T
>
class
nsPtrHashKey
;
namespace
{
enum
{
BUILD_IDS_MATCH_MESSAGE_TYPE
=
kuint16max
-
8
BUILD_ID_MESSAGE_TYPE
=
kuint16max
-
7
CHANNEL_OPENED_MESSAGE_TYPE
=
kuint16max
-
6
SHMEM_DESTROYED_MESSAGE_TYPE
=
kuint16max
-
5
SHMEM_CREATED_MESSAGE_TYPE
=
kuint16max
-
4
GOODBYE_MESSAGE_TYPE
=
kuint16max
-
3
CANCEL_MESSAGE_TYPE
=
kuint16max
-
2
}
;
}
class
nsIEventTarget
;
namespace
mozilla
{
class
SchedulerGroup
;
namespace
dom
{
class
ContentParent
;
}
namespace
net
{
class
NeckoParent
;
}
namespace
ipc
{
#
ifdef
FUZZING
class
ProtocolFuzzerHelper
;
#
endif
class
MessageChannel
;
#
ifdef
XP_WIN
const
base
:
:
ProcessHandle
kInvalidProcessHandle
=
INVALID_HANDLE_VALUE
;
const
base
:
:
ProcessId
kInvalidProcessId
=
kuint32max
;
#
else
const
base
:
:
ProcessHandle
kInvalidProcessHandle
=
-
1
;
const
base
:
:
ProcessId
kInvalidProcessId
=
-
1
;
#
endif
struct
ScopedProcessHandleTraits
{
typedef
base
:
:
ProcessHandle
type
;
static
type
empty
(
)
{
return
kInvalidProcessHandle
;
}
static
void
release
(
type
aProcessHandle
)
{
if
(
aProcessHandle
&
&
aProcessHandle
!
=
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
aProcessHandle
)
;
}
}
}
;
typedef
mozilla
:
:
Scoped
<
ScopedProcessHandleTraits
>
ScopedProcessHandle
;
class
ProtocolFdMapping
;
class
ProtocolCloneContext
;
struct
ActorHandle
{
int
mId
;
}
;
enum
RacyInterruptPolicy
{
RIPError
RIPChildWins
RIPParentWins
}
;
class
IToplevelProtocol
;
class
IProtocol
:
public
HasResultCodes
{
#
ifdef
FUZZING
friend
class
mozilla
:
:
ipc
:
:
ProtocolFuzzerHelper
;
#
endif
public
:
enum
ActorDestroyReason
{
FailedConstructor
Deletion
AncestorDeletion
NormalShutdown
AbnormalShutdown
}
;
class
ProtocolState
{
public
:
ProtocolState
(
)
:
mChannel
(
nullptr
)
{
}
virtual
~
ProtocolState
(
)
=
default
;
virtual
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
SharedMemory
:
:
SharedMemoryType
bool
int32_t
*
)
=
0
;
virtual
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
)
=
0
;
virtual
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
)
=
0
;
virtual
bool
DestroySharedMemory
(
Shmem
&
)
=
0
;
virtual
int32_t
Register
(
IProtocol
*
)
=
0
;
virtual
int32_t
RegisterID
(
IProtocol
*
int32_t
)
=
0
;
virtual
IProtocol
*
Lookup
(
int32_t
)
=
0
;
virtual
void
Unregister
(
int32_t
)
=
0
;
virtual
nsIEventTarget
*
GetActorEventTarget
(
)
=
0
;
virtual
void
SetEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
=
0
;
virtual
void
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
=
0
;
virtual
already_AddRefed
<
nsIEventTarget
>
GetActorEventTarget
(
IProtocol
*
aActor
)
=
0
;
virtual
const
MessageChannel
*
GetIPCChannel
(
)
const
=
0
;
virtual
MessageChannel
*
GetIPCChannel
(
)
=
0
;
void
SetIPCChannel
(
MessageChannel
*
aChannel
)
{
mChannel
=
aChannel
;
}
protected
:
MessageChannel
*
mChannel
;
}
;
class
ManagedState
final
:
public
ProtocolState
{
public
:
explicit
ManagedState
(
IProtocol
*
aProtocol
)
:
ProtocolState
(
)
mProtocol
(
aProtocol
)
{
}
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
SharedMemory
:
:
SharedMemoryType
bool
int32_t
*
)
override
;
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
)
override
;
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
)
override
;
bool
DestroySharedMemory
(
Shmem
&
)
override
;
int32_t
Register
(
IProtocol
*
)
override
;
int32_t
RegisterID
(
IProtocol
*
int32_t
)
override
;
IProtocol
*
Lookup
(
int32_t
)
override
;
void
Unregister
(
int32_t
)
override
;
nsIEventTarget
*
GetActorEventTarget
(
)
override
;
void
SetEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
override
;
void
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
override
;
already_AddRefed
<
nsIEventTarget
>
GetActorEventTarget
(
IProtocol
*
aActor
)
override
;
const
MessageChannel
*
GetIPCChannel
(
)
const
override
;
MessageChannel
*
GetIPCChannel
(
)
override
;
private
:
IProtocol
*
const
mProtocol
;
}
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
IPC
:
:
Message
Message
;
typedef
IPC
:
:
MessageInfo
MessageInfo
;
explicit
IProtocol
(
Side
aSide
)
:
IProtocol
(
aSide
MakeUnique
<
ManagedState
>
(
this
)
)
{
}
int32_t
Register
(
IProtocol
*
aRouted
)
{
return
mState
-
>
Register
(
aRouted
)
;
}
int32_t
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
{
return
mState
-
>
RegisterID
(
aRouted
aId
)
;
}
IProtocol
*
Lookup
(
int32_t
aId
)
{
return
mState
-
>
Lookup
(
aId
)
;
}
void
Unregister
(
int32_t
aId
)
{
return
mState
-
>
Unregister
(
aId
)
;
}
virtual
void
RemoveManagee
(
int32_t
IProtocol
*
)
=
0
;
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
bool
aUnsafe
int32_t
*
aId
)
{
return
mState
-
>
CreateSharedMemory
(
aSize
aType
aUnsafe
aId
)
;
}
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
aId
)
{
return
mState
-
>
LookupSharedMemory
(
aId
)
;
}
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
aSegment
)
{
return
mState
-
>
IsTrackingSharedMemory
(
aSegment
)
;
}
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
{
return
mState
-
>
DestroySharedMemory
(
aShmem
)
;
}
MessageChannel
*
GetIPCChannel
(
)
{
return
mState
-
>
GetIPCChannel
(
)
;
}
const
MessageChannel
*
GetIPCChannel
(
)
const
{
return
mState
-
>
GetIPCChannel
(
)
;
}
void
SetMiddlemanIPCChannel
(
MessageChannel
*
aChannel
)
{
MOZ_RELEASE_ASSERT
(
recordreplay
:
:
IsMiddleman
(
)
)
;
mState
-
>
SetIPCChannel
(
aChannel
)
;
}
virtual
ProcessId
OtherPid
(
)
const
;
Side
GetSide
(
)
const
{
return
mSide
;
}
void
FatalError
(
const
char
*
const
aErrorMsg
)
const
;
virtual
void
HandleFatalError
(
const
char
*
aErrorMsg
)
const
;
Maybe
<
IProtocol
*
>
ReadActor
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIter
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
)
=
0
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
Message
*
&
aReply
)
=
0
;
virtual
Result
OnCallReceived
(
const
Message
&
aMessage
Message
*
&
aReply
)
=
0
;
virtual
int32_t
GetProtocolTypeId
(
)
=
0
;
int32_t
Id
(
)
const
{
return
mId
;
}
IProtocol
*
Manager
(
)
const
{
return
mManager
;
}
bool
AllocShmem
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aOutMem
)
;
bool
AllocUnsafeShmem
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aOutMem
)
;
bool
DeallocShmem
(
Shmem
&
aMem
)
;
void
SetEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
;
void
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
;
nsIEventTarget
*
GetActorEventTarget
(
)
;
already_AddRefed
<
nsIEventTarget
>
GetActorEventTarget
(
IProtocol
*
aActor
)
;
protected
:
IProtocol
(
Side
aSide
UniquePtr
<
ProtocolState
>
aState
)
:
mId
(
0
)
mSide
(
aSide
)
mManager
(
nullptr
)
mState
(
std
:
:
move
(
aState
)
)
{
}
friend
class
IToplevelProtocol
;
void
SetId
(
int32_t
aId
)
{
mId
=
aId
;
}
void
ResetManager
(
)
{
mManager
=
nullptr
;
}
void
SetManager
(
IProtocol
*
aManager
)
;
void
SetManagerAndRegister
(
IProtocol
*
aManager
)
;
void
SetManagerAndRegister
(
IProtocol
*
aManager
int32_t
aId
)
;
static
const
int32_t
kNullActorId
=
0
;
static
const
int32_t
kFreedActorId
=
1
;
private
:
int32_t
mId
;
Side
mSide
;
IProtocol
*
mManager
;
UniquePtr
<
ProtocolState
>
mState
;
}
;
typedef
IPCMessageStart
ProtocolId
;
#
define
IPC_OK
(
)
mozilla
:
:
ipc
:
:
IPCResult
:
:
Ok
(
)
#
define
IPC_FAIL
(
actor
why
)
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
(
why
)
)
#
define
IPC_FAIL_NO_REASON
(
actor
)
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
)
class
IPCResult
{
public
:
static
IPCResult
Ok
(
)
{
return
IPCResult
(
true
)
;
}
static
IPCResult
Fail
(
NotNull
<
IProtocol
*
>
aActor
const
char
*
aWhere
const
char
*
aWhy
=
"
"
)
;
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mSuccess
;
}
private
:
explicit
IPCResult
(
bool
aResult
)
:
mSuccess
(
aResult
)
{
}
bool
mSuccess
;
}
;
template
<
class
PFooSide
>
class
Endpoint
;
class
IToplevelProtocol
:
public
IProtocol
{
template
<
class
PFooSide
>
friend
class
Endpoint
;
protected
:
explicit
IToplevelProtocol
(
const
char
*
aName
ProtocolId
aProtoId
Side
aSide
)
;
~
IToplevelProtocol
(
)
;
public
:
enum
ProcessIdState
{
eUnstarted
ePending
eReady
eError
}
;
class
ToplevelState
final
:
public
ProtocolState
{
#
ifdef
FUZZING
friend
class
mozilla
:
:
ipc
:
:
ProtocolFuzzerHelper
;
#
endif
public
:
ToplevelState
(
const
char
*
aName
IToplevelProtocol
*
aProtocol
Side
aSide
)
;
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
SharedMemory
:
:
SharedMemoryType
bool
int32_t
*
)
override
;
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
)
override
;
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
)
override
;
bool
DestroySharedMemory
(
Shmem
&
)
override
;
void
DeallocShmems
(
)
;
bool
ShmemCreated
(
const
Message
&
aMsg
)
;
bool
ShmemDestroyed
(
const
Message
&
aMsg
)
;
int32_t
Register
(
IProtocol
*
)
override
;
int32_t
RegisterID
(
IProtocol
*
int32_t
)
override
;
IProtocol
*
Lookup
(
int32_t
)
override
;
void
Unregister
(
int32_t
)
override
;
nsIEventTarget
*
GetActorEventTarget
(
)
override
;
void
SetEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
override
;
void
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsIEventTarget
*
aEventTarget
)
override
;
already_AddRefed
<
nsIEventTarget
>
GetActorEventTarget
(
IProtocol
*
aActor
)
override
;
virtual
already_AddRefed
<
nsIEventTarget
>
GetMessageEventTarget
(
const
Message
&
aMsg
)
;
const
MessageChannel
*
GetIPCChannel
(
)
const
override
;
MessageChannel
*
GetIPCChannel
(
)
override
;
private
:
IToplevelProtocol
*
const
mProtocol
;
IDMap
<
IProtocol
*
>
mActorMap
;
int32_t
mLastRouteId
;
IDMap
<
Shmem
:
:
SharedMemory
*
>
mShmemMap
;
Shmem
:
:
id_t
mLastShmemId
;
Mutex
mEventTargetMutex
;
IDMap
<
nsCOMPtr
<
nsIEventTarget
>
>
mEventTargetMap
;
MessageChannel
mChannel
;
}
;
using
SchedulerGroupSet
=
nsILabelableRunnable
:
:
SchedulerGroupSet
;
void
SetTransport
(
UniquePtr
<
Transport
>
aTrans
)
{
mTrans
=
std
:
:
move
(
aTrans
)
;
}
Transport
*
GetTransport
(
)
const
{
return
mTrans
.
get
(
)
;
}
ProtocolId
GetProtocolId
(
)
const
{
return
mProtocolId
;
}
base
:
:
ProcessId
OtherPid
(
)
const
final
;
void
SetOtherProcessId
(
base
:
:
ProcessId
aOtherPid
ProcessIdState
aState
=
ProcessIdState
:
:
eReady
)
;
bool
TakeMinidump
(
nsIFile
*
*
aDump
uint32_t
*
aSequence
)
;
virtual
void
OnChannelClose
(
)
=
0
;
virtual
void
OnChannelError
(
)
=
0
;
virtual
void
ProcessingError
(
Result
aError
const
char
*
aMsgName
)
{
}
virtual
void
OnChannelConnected
(
int32_t
peer_pid
)
{
}
bool
Open
(
mozilla
:
:
ipc
:
:
Transport
*
aTransport
base
:
:
ProcessId
aOtherPid
MessageLoop
*
aThread
=
nullptr
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
Open
(
MessageChannel
*
aChannel
MessageLoop
*
aMessageLoop
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
Open
(
MessageChannel
*
aChannel
nsIEventTarget
*
aEventTarget
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
OpenWithAsyncPid
(
mozilla
:
:
ipc
:
:
Transport
*
aTransport
MessageLoop
*
aThread
=
nullptr
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
OpenOnSameThread
(
MessageChannel
*
aChannel
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
void
Close
(
)
;
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
void
DeallocShmems
(
)
{
DowncastState
(
)
-
>
DeallocShmems
(
)
;
}
bool
ShmemCreated
(
const
Message
&
aMsg
)
{
return
DowncastState
(
)
-
>
ShmemCreated
(
aMsg
)
;
}
bool
ShmemDestroyed
(
const
Message
&
aMsg
)
{
return
DowncastState
(
)
-
>
ShmemDestroyed
(
aMsg
)
;
}
virtual
bool
ShouldContinueFromReplyTimeout
(
)
{
return
false
;
}
virtual
void
IntentionalCrash
(
)
{
MOZ_CRASH
(
"
Intentional
IPDL
crash
"
)
;
}
#
ifdef
DEBUG
virtual
bool
ArtificialTimeout
(
)
{
return
false
;
}
virtual
bool
NeedArtificialSleep
(
)
{
return
false
;
}
virtual
void
ArtificialSleep
(
)
{
}
#
else
bool
ArtificialTimeout
(
)
{
return
false
;
}
bool
NeedArtificialSleep
(
)
{
return
false
;
}
void
ArtificialSleep
(
)
{
}
#
endif
virtual
void
EnteredCxxStack
(
)
{
}
virtual
void
ExitedCxxStack
(
)
{
}
virtual
void
EnteredCall
(
)
{
}
virtual
void
ExitedCall
(
)
{
}
bool
IsOnCxxStack
(
)
const
;
virtual
RacyInterruptPolicy
MediateInterruptRace
(
const
MessageInfo
&
parent
const
MessageInfo
&
child
)
{
return
RIPChildWins
;
}
virtual
bool
HandleWindowsMessages
(
const
Message
&
aMsg
)
const
{
return
true
;
}
virtual
void
OnEnteredSyncSend
(
)
{
}
virtual
void
OnExitedSyncSend
(
)
{
}
virtual
void
ProcessRemoteNativeEventsInInterruptCall
(
)
{
}
virtual
bool
GetMessageSchedulerGroups
(
const
Message
&
aMsg
SchedulerGroupSet
&
aGroups
)
{
return
false
;
}
#
ifdef
EARLY_BETA_OR_EARLIER
virtual
void
OnChannelReceivedMessage
(
const
Message
&
aMsg
)
{
}
#
endif
bool
IsMainThreadProtocol
(
)
const
{
return
mIsMainThreadProtocol
;
}
void
SetIsMainThreadProtocol
(
)
{
mIsMainThreadProtocol
=
NS_IsMainThread
(
)
;
}
already_AddRefed
<
nsIEventTarget
>
GetMessageEventTarget
(
const
Message
&
aMsg
)
{
return
DowncastState
(
)
-
>
GetMessageEventTarget
(
aMsg
)
;
}
protected
:
ToplevelState
*
DowncastState
(
)
const
{
return
static_cast
<
ToplevelState
*
>
(
mState
.
get
(
)
)
;
}
virtual
already_AddRefed
<
nsIEventTarget
>
GetConstructedEventTarget
(
const
Message
&
aMsg
)
{
return
nullptr
;
}
virtual
already_AddRefed
<
nsIEventTarget
>
GetSpecificMessageEventTarget
(
const
Message
&
aMsg
)
{
return
nullptr
;
}
mutable
mozilla
:
:
Monitor
mMonitor
;
private
:
base
:
:
ProcessId
OtherPidMaybeInvalid
(
)
const
;
ProtocolId
mProtocolId
;
UniquePtr
<
Transport
>
mTrans
;
base
:
:
ProcessId
mOtherPid
;
ProcessIdState
mOtherPidState
;
bool
mIsMainThreadProtocol
;
}
;
class
IShmemAllocator
{
public
:
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
=
0
;
}
;
#
define
FORWARD_SHMEM_ALLOCATOR_TO
(
aImplClass
)
\
virtual
bool
AllocShmem
(
size_t
aSize
\
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
\
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
\
{
return
aImplClass
:
:
AllocShmem
(
aSize
aShmType
aShmem
)
;
}
\
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
\
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
\
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
\
{
return
aImplClass
:
:
AllocUnsafeShmem
(
aSize
aShmType
aShmem
)
;
}
\
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
\
{
return
aImplClass
:
:
DeallocShmem
(
aShmem
)
;
}
inline
bool
LoggingEnabled
(
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
!
!
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
#
else
return
false
;
#
endif
}
inline
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
const
char
*
filter
=
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
if
(
!
filter
)
{
return
false
;
}
return
strcmp
(
filter
"
1
"
)
=
=
0
|
|
strcmp
(
filter
aTopLevelProtocol
)
=
=
0
;
#
else
return
false
;
#
endif
}
enum
class
MessageDirection
{
eSending
eReceiving
}
;
MOZ_NEVER_INLINE
void
LogMessageForProtocol
(
const
char
*
aTopLevelProtocol
base
:
:
ProcessId
aOtherPid
const
char
*
aContextDescription
uint32_t
aMessageId
MessageDirection
aDirection
)
;
MOZ_NEVER_INLINE
void
ProtocolErrorBreakpoint
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
FatalError
(
const
char
*
aMsg
bool
aIsParent
)
;
MOZ_NEVER_INLINE
void
LogicError
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
ActorIdReadError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
BadActorIdError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
ActorLookupError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
MismatchedActorTypeError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
UnionTypeReadError
(
const
char
*
aUnionName
)
;
MOZ_NEVER_INLINE
void
ArrayLengthReadError
(
const
char
*
aElementName
)
;
MOZ_NEVER_INLINE
void
SentinelReadError
(
const
char
*
aElementName
)
;
struct
PrivateIPDLInterface
{
}
;
nsresult
Bridge
(
const
PrivateIPDLInterface
&
MessageChannel
*
base
:
:
ProcessId
MessageChannel
*
base
:
:
ProcessId
ProtocolId
ProtocolId
)
;
bool
Open
(
const
PrivateIPDLInterface
&
MessageChannel
*
base
:
:
ProcessId
Transport
:
:
Mode
ProtocolId
ProtocolId
)
;
bool
UnpackChannelOpened
(
const
PrivateIPDLInterface
&
const
IPC
:
:
Message
&
TransportDescriptor
*
base
:
:
ProcessId
*
ProtocolId
*
)
;
#
if
defined
(
XP_WIN
)
bool
DuplicateHandle
(
HANDLE
aSourceHandle
DWORD
aTargetProcessId
HANDLE
*
aTargetHandle
DWORD
aDesiredAccess
DWORD
aOptions
)
;
#
endif
void
AnnotateSystemError
(
)
;
enum
class
LivenessState
{
Dead
Null
Start
=
Null
}
;
bool
StateTransition
(
bool
aIsDelete
LivenessState
*
aNext
)
;
enum
class
ReEntrantDeleteLivenessState
{
Dead
Null
Dying
Start
=
Null
}
;
bool
ReEntrantDeleteStateTransition
(
bool
aIsDelete
bool
aIsDeleteReply
ReEntrantDeleteLivenessState
*
aNext
)
;
template
<
class
PFooSide
>
class
Endpoint
{
public
:
typedef
base
:
:
ProcessId
ProcessId
;
Endpoint
(
)
:
mValid
(
false
)
mMode
(
static_cast
<
mozilla
:
:
ipc
:
:
Transport
:
:
Mode
>
(
0
)
)
mMyPid
(
0
)
mOtherPid
(
0
)
{
}
Endpoint
(
const
PrivateIPDLInterface
&
mozilla
:
:
ipc
:
:
Transport
:
:
Mode
aMode
TransportDescriptor
aTransport
ProcessId
aMyPid
ProcessId
aOtherPid
)
:
mValid
(
true
)
mMode
(
aMode
)
mTransport
(
aTransport
)
mMyPid
(
aMyPid
)
mOtherPid
(
aOtherPid
)
{
}
Endpoint
(
Endpoint
&
&
aOther
)
:
mValid
(
aOther
.
mValid
)
mTransport
(
aOther
.
mTransport
)
mMyPid
(
aOther
.
mMyPid
)
mOtherPid
(
aOther
.
mOtherPid
)
{
if
(
aOther
.
mValid
)
{
mMode
=
aOther
.
mMode
;
}
aOther
.
mValid
=
false
;
}
Endpoint
&
operator
=
(
Endpoint
&
&
aOther
)
{
mValid
=
aOther
.
mValid
;
if
(
aOther
.
mValid
)
{
mMode
=
aOther
.
mMode
;
}
mTransport
=
aOther
.
mTransport
;
mMyPid
=
aOther
.
mMyPid
;
mOtherPid
=
aOther
.
mOtherPid
;
aOther
.
mValid
=
false
;
return
*
this
;
}
~
Endpoint
(
)
{
if
(
mValid
)
{
CloseDescriptor
(
mTransport
)
;
}
}
ProcessId
OtherPid
(
)
const
{
return
mOtherPid
;
}
bool
Bind
(
PFooSide
*
aActor
)
{
MOZ_RELEASE_ASSERT
(
mValid
)
;
if
(
mMyPid
!
=
base
:
:
GetCurrentProcId
(
)
)
{
MOZ_RELEASE_ASSERT
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
;
MOZ_RELEASE_ASSERT
(
recordreplay
:
:
IsReplaying
(
)
|
|
mMyPid
=
=
recordreplay
:
:
child
:
:
MiddlemanProcessId
(
)
)
;
mMyPid
=
base
:
:
GetCurrentProcId
(
)
;
}
UniquePtr
<
Transport
>
t
=
mozilla
:
:
ipc
:
:
OpenDescriptor
(
mTransport
mMode
)
;
if
(
!
t
)
{
return
false
;
}
if
(
!
aActor
-
>
Open
(
t
.
get
(
)
mOtherPid
XRE_GetIOMessageLoop
(
)
mMode
=
=
Transport
:
:
MODE_SERVER
?
ParentSide
:
ChildSide
)
)
{
return
false
;
}
mValid
=
false
;
aActor
-
>
SetTransport
(
std
:
:
move
(
t
)
)
;
return
true
;
}
bool
IsValid
(
)
const
{
return
mValid
;
}
private
:
friend
struct
IPC
:
:
ParamTraits
<
Endpoint
<
PFooSide
>
>
;
Endpoint
(
const
Endpoint
&
)
=
delete
;
Endpoint
&
operator
=
(
const
Endpoint
&
)
=
delete
;
bool
mValid
;
mozilla
:
:
ipc
:
:
Transport
:
:
Mode
mMode
;
TransportDescriptor
mTransport
;
ProcessId
mMyPid
mOtherPid
;
}
;
#
if
defined
(
XP_MACOSX
)
void
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
tag
int
error
)
;
#
else
static
inline
void
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
tag
int
error
)
{
}
#
endif
template
<
class
PFooParent
class
PFooChild
>
nsresult
CreateEndpoints
(
const
PrivateIPDLInterface
&
aPrivate
base
:
:
ProcessId
aParentDestPid
base
:
:
ProcessId
aChildDestPid
Endpoint
<
PFooParent
>
*
aParentEndpoint
Endpoint
<
PFooChild
>
*
aChildEndpoint
)
{
MOZ_RELEASE_ASSERT
(
aParentDestPid
)
;
MOZ_RELEASE_ASSERT
(
aChildDestPid
)
;
TransportDescriptor
parentTransport
childTransport
;
nsresult
rv
;
if
(
NS_FAILED
(
rv
=
CreateTransport
(
aParentDestPid
&
parentTransport
&
childTransport
)
)
)
{
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
:
:
IpcCreateEndpointsNsresult
int
(
rv
)
)
;
return
rv
;
}
*
aParentEndpoint
=
Endpoint
<
PFooParent
>
(
aPrivate
mozilla
:
:
ipc
:
:
Transport
:
:
MODE_SERVER
parentTransport
aParentDestPid
aChildDestPid
)
;
*
aChildEndpoint
=
Endpoint
<
PFooChild
>
(
aPrivate
mozilla
:
:
ipc
:
:
Transport
:
:
MODE_CLIENT
childTransport
aChildDestPid
aParentDestPid
)
;
return
NS_OK
;
}
void
TableToArray
(
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
&
aTable
nsTArray
<
void
*
>
&
aArray
)
;
}
template
<
typename
Protocol
>
class
ManagedContainer
:
public
nsTHashtable
<
nsPtrHashKey
<
Protocol
>
>
{
typedef
nsTHashtable
<
nsPtrHashKey
<
Protocol
>
>
BaseClass
;
public
:
void
ToArray
(
nsTArray
<
Protocol
*
>
&
aArray
)
const
{
:
:
mozilla
:
:
ipc
:
:
TableToArray
(
*
reinterpret_cast
<
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
*
>
(
static_cast
<
const
BaseClass
*
>
(
this
)
)
reinterpret_cast
<
nsTArray
<
void
*
>
&
>
(
aArray
)
)
;
}
}
;
template
<
typename
Protocol
>
Protocol
*
LoneManagedOrNullAsserts
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aManagees
.
Count
(
)
=
=
1
)
;
return
aManagees
.
ConstIter
(
)
.
Get
(
)
-
>
GetKey
(
)
;
}
template
<
typename
Protocol
>
Protocol
*
SingleManagedOrNull
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
Count
(
)
!
=
1
)
{
return
nullptr
;
}
return
aManagees
.
ConstIter
(
)
.
Get
(
)
-
>
GetKey
(
)
;
}
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
ActorHandle
>
{
typedef
mozilla
:
:
ipc
:
:
ActorHandle
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
IPC
:
:
WriteParam
(
aMsg
aParam
.
mId
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
int
id
;
if
(
IPC
:
:
ReadParam
(
aMsg
aIter
&
id
)
)
{
aResult
-
>
mId
=
id
;
return
true
;
}
return
false
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
(
%
d
)
"
aParam
.
mId
)
)
;
}
}
;
template
<
class
PFooSide
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
Endpoint
<
PFooSide
>
>
{
typedef
mozilla
:
:
ipc
:
:
Endpoint
<
PFooSide
>
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
IPC
:
:
WriteParam
(
aMsg
aParam
.
mValid
)
;
if
(
!
aParam
.
mValid
)
{
return
;
}
IPC
:
:
WriteParam
(
aMsg
static_cast
<
uint32_t
>
(
aParam
.
mMode
)
)
;
mozilla
:
:
ipc
:
:
TransportDescriptor
desc
=
mozilla
:
:
ipc
:
:
DuplicateDescriptor
(
aParam
.
mTransport
)
;
IPC
:
:
WriteParam
(
aMsg
desc
)
;
IPC
:
:
WriteParam
(
aMsg
aParam
.
mMyPid
)
;
IPC
:
:
WriteParam
(
aMsg
aParam
.
mOtherPid
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
MOZ_RELEASE_ASSERT
(
!
aResult
-
>
mValid
)
;
if
(
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mValid
)
)
{
return
false
;
}
if
(
!
aResult
-
>
mValid
)
{
return
true
;
}
uint32_t
mode
;
if
(
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
mode
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mTransport
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mMyPid
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mOtherPid
)
)
{
return
false
;
}
aResult
-
>
mMode
=
Channel
:
:
Mode
(
mode
)
;
return
true
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
Endpoint
"
)
)
;
}
}
;
}
#
endif
