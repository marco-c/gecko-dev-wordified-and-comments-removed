#
ifndef
mozilla_ipc_ProtocolUtils_h
#
define
mozilla_ipc_ProtocolUtils_h
1
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
IPCMessageStart
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
prenv
.
h
"
#
if
defined
(
ANDROID
)
&
&
defined
(
DEBUG
)
#
include
<
android
/
log
.
h
>
#
endif
template
<
typename
T
>
class
nsPtrHashKey
;
namespace
{
enum
{
IMPENDING_SHUTDOWN_MESSAGE_TYPE
=
kuint16max
-
9
BUILD_IDS_MATCH_MESSAGE_TYPE
=
kuint16max
-
8
BUILD_ID_MESSAGE_TYPE
=
kuint16max
-
7
CHANNEL_OPENED_MESSAGE_TYPE
=
kuint16max
-
6
SHMEM_DESTROYED_MESSAGE_TYPE
=
kuint16max
-
5
SHMEM_CREATED_MESSAGE_TYPE
=
kuint16max
-
4
GOODBYE_MESSAGE_TYPE
=
kuint16max
-
3
CANCEL_MESSAGE_TYPE
=
kuint16max
-
2
}
;
}
class
MessageLoop
;
class
PickleIterator
;
class
nsISerialEventTarget
;
class
nsUint32HashKey
;
namespace
mozilla
{
class
SchedulerGroup
;
namespace
dom
{
class
ContentParent
;
}
namespace
net
{
class
NeckoParent
;
}
namespace
ipc
{
#
ifdef
FUZZING
class
ProtocolFuzzerHelper
;
#
endif
#
ifdef
XP_WIN
const
base
:
:
ProcessHandle
kInvalidProcessHandle
=
INVALID_HANDLE_VALUE
;
const
base
:
:
ProcessId
kInvalidProcessId
=
kuint32max
;
#
else
const
base
:
:
ProcessHandle
kInvalidProcessHandle
=
-
1
;
const
base
:
:
ProcessId
kInvalidProcessId
=
-
1
;
#
endif
struct
ScopedProcessHandleTraits
{
typedef
base
:
:
ProcessHandle
type
;
static
type
empty
(
)
{
return
kInvalidProcessHandle
;
}
static
void
release
(
type
aProcessHandle
)
{
if
(
aProcessHandle
&
&
aProcessHandle
!
=
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
aProcessHandle
)
;
}
}
}
;
typedef
mozilla
:
:
Scoped
<
ScopedProcessHandleTraits
>
ScopedProcessHandle
;
class
ProtocolFdMapping
;
class
ProtocolCloneContext
;
struct
ActorHandle
{
int
mId
;
}
;
enum
RacyInterruptPolicy
{
RIPError
RIPChildWins
RIPParentWins
}
;
enum
class
LinkStatus
:
uint8_t
{
Inactive
Connected
Doomed
Destroyed
}
;
typedef
IPCMessageStart
ProtocolId
;
const
char
*
ProtocolIdToName
(
IPCMessageStart
aId
)
;
class
IToplevelProtocol
;
class
ActorLifecycleProxy
;
class
IProtocol
:
public
HasResultCodes
{
public
:
enum
ActorDestroyReason
{
FailedConstructor
Deletion
AncestorDeletion
NormalShutdown
AbnormalShutdown
}
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
IPC
:
:
Message
Message
;
typedef
IPC
:
:
MessageInfo
MessageInfo
;
IProtocol
(
ProtocolId
aProtoId
Side
aSide
)
:
mId
(
0
)
mProtocolId
(
aProtoId
)
mSide
(
aSide
)
mLinkStatus
(
LinkStatus
:
:
Inactive
)
mLifecycleProxy
(
nullptr
)
mManager
(
nullptr
)
mToplevel
(
nullptr
)
{
}
IToplevelProtocol
*
ToplevelProtocol
(
)
{
return
mToplevel
;
}
int32_t
Register
(
IProtocol
*
aRouted
)
;
int32_t
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
;
IProtocol
*
Lookup
(
int32_t
aId
)
;
void
Unregister
(
int32_t
aId
)
;
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
bool
aUnsafe
int32_t
*
aId
)
;
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
aId
)
;
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
aSegment
)
;
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
;
MessageChannel
*
GetIPCChannel
(
)
;
const
MessageChannel
*
GetIPCChannel
(
)
const
;
void
SetEventTargetForActor
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
;
void
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
;
nsISerialEventTarget
*
GetActorEventTarget
(
)
;
already_AddRefed
<
nsISerialEventTarget
>
GetActorEventTarget
(
IProtocol
*
aActor
)
;
ProcessId
OtherPid
(
)
const
;
ProtocolId
GetProtocolId
(
)
const
{
return
mProtocolId
;
}
const
char
*
GetProtocolName
(
)
const
{
return
ProtocolIdToName
(
mProtocolId
)
;
}
int32_t
Id
(
)
const
{
return
mId
;
}
IProtocol
*
Manager
(
)
const
{
return
mManager
;
}
ActorLifecycleProxy
*
GetLifecycleProxy
(
)
{
return
mLifecycleProxy
;
}
Side
GetSide
(
)
const
{
return
mSide
;
}
bool
CanSend
(
)
const
{
return
mLinkStatus
=
=
LinkStatus
:
:
Connected
;
}
bool
CanRecv
(
)
const
{
return
mLinkStatus
=
=
LinkStatus
:
:
Connected
|
|
mLinkStatus
=
=
LinkStatus
:
:
Doomed
;
}
virtual
void
RemoveManagee
(
int32_t
IProtocol
*
)
=
0
;
virtual
void
DeallocManagee
(
int32_t
IProtocol
*
)
=
0
;
Maybe
<
IProtocol
*
>
ReadActor
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIter
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
)
=
0
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
Message
*
&
aReply
)
=
0
;
virtual
Result
OnCallReceived
(
const
Message
&
aMessage
Message
*
&
aReply
)
=
0
;
bool
AllocShmem
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aOutMem
)
;
bool
AllocUnsafeShmem
(
size_t
aSize
Shmem
:
:
SharedMemory
:
:
SharedMemoryType
aType
Shmem
*
aOutMem
)
;
bool
DeallocShmem
(
Shmem
&
aMem
)
;
void
FatalError
(
const
char
*
const
aErrorMsg
)
const
;
virtual
void
HandleFatalError
(
const
char
*
aErrorMsg
)
const
;
protected
:
virtual
~
IProtocol
(
)
;
friend
class
IToplevelProtocol
;
friend
class
ActorLifecycleProxy
;
void
SetId
(
int32_t
aId
)
;
void
SetManager
(
IProtocol
*
aManager
)
;
void
SetManagerAndRegister
(
IProtocol
*
aManager
)
;
void
SetManagerAndRegister
(
IProtocol
*
aManager
int32_t
aId
)
;
bool
ChannelSend
(
IPC
:
:
Message
*
aMsg
)
;
bool
ChannelSend
(
IPC
:
:
Message
*
aMsg
IPC
:
:
Message
*
aReply
)
;
bool
ChannelCall
(
IPC
:
:
Message
*
aMsg
IPC
:
:
Message
*
aReply
)
;
template
<
typename
Value
>
void
ChannelSend
(
IPC
:
:
Message
*
aMsg
ResolveCallback
<
Value
>
&
&
aResolve
RejectCallback
&
&
aReject
)
{
UniquePtr
<
IPC
:
:
Message
>
msg
(
aMsg
)
;
if
(
CanSend
(
)
)
{
GetIPCChannel
(
)
-
>
Send
(
std
:
:
move
(
msg
)
this
std
:
:
move
(
aResolve
)
std
:
:
move
(
aReject
)
)
;
}
else
{
NS_WARNING
(
"
IPC
message
discarded
:
actor
cannot
send
"
)
;
aReject
(
ResponseRejectReason
:
:
SendError
)
;
}
}
virtual
void
AllManagedActors
(
nsTArray
<
RefPtr
<
ActorLifecycleProxy
>
>
&
aActors
)
const
=
0
;
void
ActorConnected
(
)
;
virtual
void
ActorDoom
(
)
{
}
void
DoomSubtree
(
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
}
void
DestroySubtree
(
ActorDestroyReason
aWhy
)
;
virtual
void
ActorAlloc
(
)
{
}
virtual
void
ActorDealloc
(
)
{
if
(
Manager
(
)
)
{
Manager
(
)
-
>
DeallocManagee
(
mProtocolId
this
)
;
}
}
static
const
int32_t
kNullActorId
=
0
;
static
const
int32_t
kFreedActorId
=
1
;
private
:
int32_t
mId
;
ProtocolId
mProtocolId
;
Side
mSide
;
LinkStatus
mLinkStatus
;
ActorLifecycleProxy
*
mLifecycleProxy
;
IProtocol
*
mManager
;
IToplevelProtocol
*
mToplevel
;
}
;
#
define
IPC_OK
(
)
mozilla
:
:
ipc
:
:
IPCResult
:
:
Ok
(
)
#
define
IPC_FAIL
(
actor
why
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
(
why
)
)
#
define
IPC_FAIL_NO_REASON
(
actor
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
)
class
IPCResult
{
public
:
static
IPCResult
Ok
(
)
{
return
IPCResult
(
true
)
;
}
static
IPCResult
Fail
(
NotNull
<
IProtocol
*
>
aActor
const
char
*
aWhere
const
char
*
aWhy
=
"
"
)
;
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mSuccess
;
}
private
:
explicit
IPCResult
(
bool
aResult
)
:
mSuccess
(
aResult
)
{
}
bool
mSuccess
;
}
;
template
<
class
PFooSide
>
class
Endpoint
;
template
<
class
PFooSide
>
class
ManagedEndpoint
;
class
IToplevelProtocol
:
public
IProtocol
{
#
ifdef
FUZZING
friend
class
mozilla
:
:
ipc
:
:
ProtocolFuzzerHelper
;
#
endif
template
<
class
PFooSide
>
friend
class
Endpoint
;
protected
:
explicit
IToplevelProtocol
(
const
char
*
aName
ProtocolId
aProtoId
Side
aSide
)
;
~
IToplevelProtocol
(
)
=
default
;
public
:
int32_t
Register
(
IProtocol
*
aRouted
)
;
int32_t
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
;
IProtocol
*
Lookup
(
int32_t
aId
)
;
void
Unregister
(
int32_t
aId
)
;
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
aSize
SharedMemory
:
:
SharedMemoryType
aType
bool
aUnsafe
int32_t
*
aId
)
;
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
aId
)
;
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
aSegment
)
;
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
;
MessageChannel
*
GetIPCChannel
(
)
{
return
&
mChannel
;
}
const
MessageChannel
*
GetIPCChannel
(
)
const
{
return
&
mChannel
;
}
void
SetEventTargetForActorInternal
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
;
void
ReplaceEventTargetForActor
(
IProtocol
*
aActor
nsISerialEventTarget
*
aEventTarget
)
;
nsISerialEventTarget
*
GetActorEventTarget
(
)
;
already_AddRefed
<
nsISerialEventTarget
>
GetActorEventTarget
(
IProtocol
*
aActor
)
;
ProcessId
OtherPid
(
)
const
;
void
SetOtherProcessId
(
base
:
:
ProcessId
aOtherPid
)
;
virtual
void
OnChannelClose
(
)
=
0
;
virtual
void
OnChannelError
(
)
=
0
;
virtual
void
ProcessingError
(
Result
aError
const
char
*
aMsgName
)
{
}
virtual
void
OnChannelConnected
(
int32_t
peer_pid
)
{
}
bool
Open
(
UniquePtr
<
Transport
>
aTransport
base
:
:
ProcessId
aOtherPid
MessageLoop
*
aThread
=
nullptr
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
Open
(
MessageChannel
*
aChannel
nsISerialEventTarget
*
aEventTarget
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
OpenOnSameThread
(
MessageChannel
*
aChannel
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
void
NotifyImpendingShutdown
(
)
;
void
Close
(
)
;
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
void
DeallocShmems
(
)
;
bool
ShmemCreated
(
const
Message
&
aMsg
)
;
bool
ShmemDestroyed
(
const
Message
&
aMsg
)
;
virtual
bool
ShouldContinueFromReplyTimeout
(
)
{
return
false
;
}
virtual
void
IntentionalCrash
(
)
{
MOZ_CRASH
(
"
Intentional
IPDL
crash
"
)
;
}
#
ifdef
DEBUG
virtual
bool
ArtificialTimeout
(
)
{
return
false
;
}
virtual
bool
NeedArtificialSleep
(
)
{
return
false
;
}
virtual
void
ArtificialSleep
(
)
{
}
#
else
bool
ArtificialTimeout
(
)
{
return
false
;
}
bool
NeedArtificialSleep
(
)
{
return
false
;
}
void
ArtificialSleep
(
)
{
}
#
endif
virtual
void
EnteredCxxStack
(
)
{
}
virtual
void
ExitedCxxStack
(
)
{
}
virtual
void
EnteredCall
(
)
{
}
virtual
void
ExitedCall
(
)
{
}
bool
IsOnCxxStack
(
)
const
;
virtual
RacyInterruptPolicy
MediateInterruptRace
(
const
MessageInfo
&
parent
const
MessageInfo
&
child
)
{
return
RIPChildWins
;
}
virtual
bool
HandleWindowsMessages
(
const
Message
&
aMsg
)
const
{
return
true
;
}
virtual
void
OnEnteredSyncSend
(
)
{
}
virtual
void
OnExitedSyncSend
(
)
{
}
virtual
void
ProcessRemoteNativeEventsInInterruptCall
(
)
{
}
virtual
void
OnChannelReceivedMessage
(
const
Message
&
aMsg
)
{
}
void
OnIPCChannelOpened
(
)
{
ActorConnected
(
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
GetMessageEventTarget
(
const
Message
&
aMsg
)
;
base
:
:
ProcessId
OtherPidMaybeInvalid
(
)
const
{
return
mOtherPid
;
}
private
:
int32_t
NextId
(
)
;
template
<
class
T
>
using
IDMap
=
nsDataHashtable
<
nsUint32HashKey
T
>
;
base
:
:
ProcessId
mOtherPid
;
int32_t
mLastLocalId
;
IDMap
<
IProtocol
*
>
mActorMap
;
IDMap
<
Shmem
:
:
SharedMemory
*
>
mShmemMap
;
Mutex
mEventTargetMutex
;
IDMap
<
nsCOMPtr
<
nsISerialEventTarget
>
>
mEventTargetMap
;
MessageChannel
mChannel
;
}
;
class
IShmemAllocator
{
public
:
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
=
0
;
}
;
#
define
FORWARD_SHMEM_ALLOCATOR_TO
(
aImplClass
)
\
virtual
bool
AllocShmem
(
\
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
\
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
{
\
return
aImplClass
:
:
AllocShmem
(
aSize
aShmType
aShmem
)
;
\
}
\
virtual
bool
AllocUnsafeShmem
(
\
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
\
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
{
\
return
aImplClass
:
:
AllocUnsafeShmem
(
aSize
aShmType
aShmem
)
;
\
}
\
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
{
\
return
aImplClass
:
:
DeallocShmem
(
aShmem
)
;
\
}
inline
bool
LoggingEnabled
(
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
!
!
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
#
else
return
false
;
#
endif
}
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
const
char
*
aFilter
)
;
#
endif
inline
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
LoggingEnabledFor
(
aTopLevelProtocol
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
)
;
#
else
return
false
;
#
endif
}
MOZ_NEVER_INLINE
void
LogMessageForProtocol
(
const
char
*
aTopLevelProtocol
base
:
:
ProcessId
aOtherPid
const
char
*
aContextDescription
uint32_t
aMessageId
MessageDirection
aDirection
)
;
MOZ_NEVER_INLINE
void
ProtocolErrorBreakpoint
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
FatalError
(
const
char
*
aMsg
bool
aIsParent
)
;
MOZ_NEVER_INLINE
void
LogicError
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
ActorIdReadError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
BadActorIdError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
ActorLookupError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
MismatchedActorTypeError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
UnionTypeReadError
(
const
char
*
aUnionName
)
;
MOZ_NEVER_INLINE
void
ArrayLengthReadError
(
const
char
*
aElementName
)
;
MOZ_NEVER_INLINE
void
SentinelReadError
(
const
char
*
aElementName
)
;
#
if
defined
(
XP_WIN
)
bool
DuplicateHandle
(
HANDLE
aSourceHandle
DWORD
aTargetProcessId
HANDLE
*
aTargetHandle
DWORD
aDesiredAccess
DWORD
aOptions
)
;
#
endif
void
AnnotateSystemError
(
)
;
class
ActorLifecycleProxy
{
public
:
NS_INLINE_DECL_REFCOUNTING_ONEVENTTARGET
(
ActorLifecycleProxy
)
IProtocol
*
Get
(
)
{
return
mActor
;
}
private
:
friend
class
IProtocol
;
explicit
ActorLifecycleProxy
(
IProtocol
*
aActor
)
;
~
ActorLifecycleProxy
(
)
;
ActorLifecycleProxy
(
const
ActorLifecycleProxy
&
)
=
delete
;
ActorLifecycleProxy
&
operator
=
(
const
ActorLifecycleProxy
&
)
=
delete
;
IProtocol
*
MOZ_NON_OWNING_REF
mActor
;
RefPtr
<
ActorLifecycleProxy
>
mManager
;
}
;
void
TableToArray
(
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
&
aTable
nsTArray
<
void
*
>
&
aArray
)
;
}
template
<
typename
Protocol
>
class
ManagedContainer
:
public
nsTHashtable
<
nsPtrHashKey
<
Protocol
>
>
{
typedef
nsTHashtable
<
nsPtrHashKey
<
Protocol
>
>
BaseClass
;
public
:
void
ToArray
(
nsTArray
<
Protocol
*
>
&
aArray
)
const
{
:
:
mozilla
:
:
ipc
:
:
TableToArray
(
*
reinterpret_cast
<
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
*
>
(
static_cast
<
const
BaseClass
*
>
(
this
)
)
reinterpret_cast
<
nsTArray
<
void
*
>
&
>
(
aArray
)
)
;
}
}
;
template
<
typename
Protocol
>
Protocol
*
LoneManagedOrNullAsserts
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aManagees
.
Count
(
)
=
=
1
)
;
return
aManagees
.
ConstIter
(
)
.
Get
(
)
-
>
GetKey
(
)
;
}
template
<
typename
Protocol
>
Protocol
*
SingleManagedOrNull
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
Count
(
)
!
=
1
)
{
return
nullptr
;
}
return
aManagees
.
ConstIter
(
)
.
Get
(
)
-
>
GetKey
(
)
;
}
}
#
endif
