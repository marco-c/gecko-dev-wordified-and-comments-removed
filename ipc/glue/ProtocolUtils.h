#
ifndef
mozilla_ipc_ProtocolUtils_h
#
define
mozilla_ipc_ProtocolUtils_h
1
#
include
"
base
/
process
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
prenv
.
h
"
#
include
"
IPCMessageStart
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
if
defined
(
ANDROID
)
&
&
defined
(
DEBUG
)
#
include
<
android
/
log
.
h
>
#
endif
template
<
typename
T
>
class
nsTHashtable
;
template
<
typename
T
>
class
nsPtrHashKey
;
namespace
{
enum
{
CHANNEL_OPENED_MESSAGE_TYPE
=
kuint16max
-
6
SHMEM_DESTROYED_MESSAGE_TYPE
=
kuint16max
-
5
SHMEM_CREATED_MESSAGE_TYPE
=
kuint16max
-
4
GOODBYE_MESSAGE_TYPE
=
kuint16max
-
3
CANCEL_MESSAGE_TYPE
=
kuint16max
-
2
}
;
}
namespace
mozilla
{
namespace
dom
{
class
ContentParent
;
}
namespace
net
{
class
NeckoParent
;
}
namespace
ipc
{
#
ifdef
XP_WIN
const
base
:
:
ProcessHandle
kInvalidProcessHandle
=
INVALID_HANDLE_VALUE
;
const
base
:
:
ProcessId
kInvalidProcessId
=
kuint32max
;
#
else
const
base
:
:
ProcessHandle
kInvalidProcessHandle
=
-
1
;
const
base
:
:
ProcessId
kInvalidProcessId
=
-
1
;
#
endif
struct
ScopedProcessHandleTraits
{
typedef
base
:
:
ProcessHandle
type
;
static
type
empty
(
)
{
return
kInvalidProcessHandle
;
}
static
void
release
(
type
aProcessHandle
)
{
if
(
aProcessHandle
&
&
aProcessHandle
!
=
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
aProcessHandle
)
;
}
}
}
;
typedef
mozilla
:
:
Scoped
<
ScopedProcessHandleTraits
>
ScopedProcessHandle
;
class
ProtocolFdMapping
;
class
ProtocolCloneContext
;
struct
ActorHandle
{
int
mId
;
}
;
struct
Trigger
{
enum
Action
{
Send
Recv
}
;
Trigger
(
Action
action
int32_t
msg
)
:
mAction
(
action
)
mMessage
(
msg
)
{
MOZ_ASSERT
(
0
<
=
msg
&
&
msg
<
INT32_MAX
)
;
}
uint32_t
mAction
:
1
;
uint32_t
mMessage
:
31
;
}
;
class
ProtocolCloneContext
{
typedef
mozilla
:
:
dom
:
:
ContentParent
ContentParent
;
typedef
mozilla
:
:
net
:
:
NeckoParent
NeckoParent
;
RefPtr
<
ContentParent
>
mContentParent
;
NeckoParent
*
mNeckoParent
;
public
:
ProtocolCloneContext
(
)
;
~
ProtocolCloneContext
(
)
;
void
SetContentParent
(
ContentParent
*
aContentParent
)
;
ContentParent
*
GetContentParent
(
)
{
return
mContentParent
;
}
void
SetNeckoParent
(
NeckoParent
*
aNeckoParent
)
{
mNeckoParent
=
aNeckoParent
;
}
NeckoParent
*
GetNeckoParent
(
)
{
return
mNeckoParent
;
}
}
;
template
<
class
ListenerT
>
class
IProtocolManager
{
public
:
enum
ActorDestroyReason
{
FailedConstructor
Deletion
AncestorDeletion
NormalShutdown
AbnormalShutdown
}
;
typedef
base
:
:
ProcessId
ProcessId
;
virtual
int32_t
Register
(
ListenerT
*
)
=
0
;
virtual
int32_t
RegisterID
(
ListenerT
*
int32_t
)
=
0
;
virtual
ListenerT
*
Lookup
(
int32_t
)
=
0
;
virtual
void
Unregister
(
int32_t
)
=
0
;
virtual
void
RemoveManagee
(
int32_t
ListenerT
*
)
=
0
;
virtual
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
SharedMemory
:
:
SharedMemoryType
bool
int32_t
*
)
=
0
;
virtual
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
)
=
0
;
virtual
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
)
=
0
;
virtual
bool
DestroySharedMemory
(
Shmem
&
)
=
0
;
virtual
ProcessId
OtherPid
(
)
const
=
0
;
virtual
MessageChannel
*
GetIPCChannel
(
)
=
0
;
virtual
void
FatalError
(
const
char
*
const
aProtocolName
const
char
*
const
aErrorMsg
)
const
=
0
;
Maybe
<
ListenerT
*
>
ReadActor
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIter
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
;
}
;
typedef
IPCMessageStart
ProtocolId
;
class
IProtocol
:
public
MessageListener
{
public
:
virtual
IProtocol
*
CloneProtocol
(
MessageChannel
*
aChannel
ProtocolCloneContext
*
aCtx
)
=
0
;
}
;
template
<
class
PFooSide
>
class
Endpoint
;
class
IToplevelProtocol
{
template
<
class
PFooSide
>
friend
class
Endpoint
;
protected
:
explicit
IToplevelProtocol
(
ProtocolId
aProtoId
)
;
~
IToplevelProtocol
(
)
;
public
:
void
SetTransport
(
UniquePtr
<
Transport
>
aTrans
)
{
mTrans
=
Move
(
aTrans
)
;
}
Transport
*
GetTransport
(
)
const
{
return
mTrans
.
get
(
)
;
}
ProtocolId
GetProtocolId
(
)
const
{
return
mProtocolId
;
}
virtual
MessageChannel
*
GetIPCChannel
(
)
=
0
;
private
:
ProtocolId
mProtocolId
;
UniquePtr
<
Transport
>
mTrans
;
}
;
class
IShmemAllocator
{
public
:
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
=
0
;
}
;
#
define
FORWARD_SHMEM_ALLOCATOR_TO
(
aImplClass
)
\
virtual
bool
AllocShmem
(
size_t
aSize
\
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
\
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
\
{
return
aImplClass
:
:
AllocShmem
(
aSize
aShmType
aShmem
)
;
}
\
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
\
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
\
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
override
\
{
return
aImplClass
:
:
AllocUnsafeShmem
(
aSize
aShmType
aShmem
)
;
}
\
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
\
{
return
aImplClass
:
:
DeallocShmem
(
aShmem
)
;
}
inline
bool
LoggingEnabled
(
)
{
#
if
defined
(
DEBUG
)
return
!
!
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
#
else
return
false
;
#
endif
}
inline
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
)
{
#
if
defined
(
DEBUG
)
const
char
*
filter
=
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
if
(
!
filter
)
{
return
false
;
}
return
strcmp
(
filter
"
1
"
)
=
=
0
|
|
strcmp
(
filter
aTopLevelProtocol
)
=
=
0
;
#
else
return
false
;
#
endif
}
enum
class
MessageDirection
{
eSending
eReceiving
}
;
MOZ_NEVER_INLINE
void
LogMessageForProtocol
(
const
char
*
aTopLevelProtocol
base
:
:
ProcessId
aOtherPid
const
char
*
aContextDescription
const
char
*
aMessageDescription
MessageDirection
aDirection
)
;
MOZ_NEVER_INLINE
void
ProtocolErrorBreakpoint
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
FatalError
(
const
char
*
aProtocolName
const
char
*
aMsg
bool
aIsParent
)
;
MOZ_NEVER_INLINE
void
LogicError
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
ActorIdReadError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
BadActorIdError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
ActorLookupError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
MismatchedActorTypeError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
UnionTypeReadError
(
const
char
*
aUnionName
)
;
MOZ_NEVER_INLINE
void
ArrayLengthReadError
(
const
char
*
aElementName
)
;
struct
PrivateIPDLInterface
{
}
;
nsresult
Bridge
(
const
PrivateIPDLInterface
&
MessageChannel
*
base
:
:
ProcessId
MessageChannel
*
base
:
:
ProcessId
ProtocolId
ProtocolId
)
;
bool
Open
(
const
PrivateIPDLInterface
&
MessageChannel
*
base
:
:
ProcessId
Transport
:
:
Mode
ProtocolId
ProtocolId
)
;
bool
UnpackChannelOpened
(
const
PrivateIPDLInterface
&
const
IPC
:
:
Message
&
TransportDescriptor
*
base
:
:
ProcessId
*
ProtocolId
*
)
;
template
<
typename
ListenerT
>
Maybe
<
ListenerT
*
>
IProtocolManager
<
ListenerT
>
:
:
ReadActor
(
const
IPC
:
:
Message
*
aMessage
PickleIterator
*
aIter
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
{
int32_t
id
;
if
(
!
IPC
:
:
ReadParam
(
aMessage
aIter
&
id
)
)
{
ActorIdReadError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
if
(
id
=
=
1
|
|
(
id
=
=
0
&
&
!
aNullable
)
)
{
BadActorIdError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
if
(
id
=
=
0
)
{
return
Some
(
static_cast
<
ListenerT
*
>
(
nullptr
)
)
;
}
ListenerT
*
listener
=
this
-
>
Lookup
(
id
)
;
if
(
!
listener
)
{
ActorLookupError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
if
(
static_cast
<
MessageListener
*
>
(
listener
)
-
>
GetProtocolTypeId
(
)
!
=
aProtocolTypeId
)
{
MismatchedActorTypeError
(
aActorDescription
)
;
return
Nothing
(
)
;
}
return
Some
(
listener
)
;
}
#
if
defined
(
XP_WIN
)
bool
DuplicateHandle
(
HANDLE
aSourceHandle
DWORD
aTargetProcessId
HANDLE
*
aTargetHandle
DWORD
aDesiredAccess
DWORD
aOptions
)
;
#
endif
#
ifdef
MOZ_CRASHREPORTER
void
AnnotateSystemError
(
)
;
#
else
#
define
AnnotateSystemError
(
)
do
{
}
while
(
0
)
#
endif
template
<
class
PFooSide
>
class
Endpoint
{
public
:
typedef
base
:
:
ProcessId
ProcessId
;
Endpoint
(
)
:
mValid
(
false
)
{
}
Endpoint
(
const
PrivateIPDLInterface
&
mozilla
:
:
ipc
:
:
Transport
:
:
Mode
aMode
TransportDescriptor
aTransport
ProcessId
aMyPid
ProcessId
aOtherPid
ProtocolId
aProtocolId
)
:
mValid
(
true
)
mMode
(
aMode
)
mTransport
(
aTransport
)
mMyPid
(
aMyPid
)
mOtherPid
(
aOtherPid
)
mProtocolId
(
aProtocolId
)
{
}
Endpoint
(
Endpoint
&
&
aOther
)
:
mValid
(
aOther
.
mValid
)
mMode
(
aOther
.
mMode
)
mTransport
(
aOther
.
mTransport
)
mMyPid
(
aOther
.
mMyPid
)
mOtherPid
(
aOther
.
mOtherPid
)
mProtocolId
(
aOther
.
mProtocolId
)
{
aOther
.
mValid
=
false
;
}
Endpoint
&
operator
=
(
Endpoint
&
&
aOther
)
{
mValid
=
aOther
.
mValid
;
mMode
=
aOther
.
mMode
;
mTransport
=
aOther
.
mTransport
;
mMyPid
=
aOther
.
mMyPid
;
mOtherPid
=
aOther
.
mOtherPid
;
mProtocolId
=
aOther
.
mProtocolId
;
aOther
.
mValid
=
false
;
return
*
this
;
}
~
Endpoint
(
)
{
if
(
mValid
)
{
CloseDescriptor
(
mTransport
)
;
}
}
ProcessId
OtherPid
(
)
const
{
return
mOtherPid
;
}
bool
Bind
(
PFooSide
*
aActor
)
{
MOZ_RELEASE_ASSERT
(
mValid
)
;
MOZ_RELEASE_ASSERT
(
mMyPid
=
=
base
:
:
GetCurrentProcId
(
)
)
;
UniquePtr
<
Transport
>
t
=
mozilla
:
:
ipc
:
:
OpenDescriptor
(
mTransport
mMode
)
;
if
(
!
t
)
{
return
false
;
}
if
(
!
aActor
-
>
Open
(
t
.
get
(
)
mOtherPid
XRE_GetIOMessageLoop
(
)
mMode
=
=
Transport
:
:
MODE_SERVER
?
ParentSide
:
ChildSide
)
)
{
return
false
;
}
mValid
=
false
;
aActor
-
>
SetTransport
(
Move
(
t
)
)
;
return
true
;
}
bool
IsValid
(
)
const
{
return
mValid
;
}
private
:
friend
struct
IPC
:
:
ParamTraits
<
Endpoint
<
PFooSide
>
>
;
Endpoint
(
const
Endpoint
&
)
=
delete
;
Endpoint
&
operator
=
(
const
Endpoint
&
)
=
delete
;
bool
mValid
;
mozilla
:
:
ipc
:
:
Transport
:
:
Mode
mMode
;
TransportDescriptor
mTransport
;
ProcessId
mMyPid
mOtherPid
;
ProtocolId
mProtocolId
;
}
;
#
if
defined
(
MOZ_CRASHREPORTER
)
&
&
defined
(
XP_MACOSX
)
void
AnnotateCrashReportWithErrno
(
const
char
*
tag
int
error
)
;
#
else
static
inline
void
AnnotateCrashReportWithErrno
(
const
char
*
tag
int
error
)
{
}
#
endif
template
<
class
PFooParent
class
PFooChild
>
nsresult
CreateEndpoints
(
const
PrivateIPDLInterface
&
aPrivate
base
:
:
ProcessId
aParentDestPid
base
:
:
ProcessId
aChildDestPid
ProtocolId
aProtocol
ProtocolId
aChildProtocol
Endpoint
<
PFooParent
>
*
aParentEndpoint
Endpoint
<
PFooChild
>
*
aChildEndpoint
)
{
MOZ_RELEASE_ASSERT
(
aParentDestPid
)
;
MOZ_RELEASE_ASSERT
(
aChildDestPid
)
;
TransportDescriptor
parentTransport
childTransport
;
nsresult
rv
;
if
(
NS_FAILED
(
rv
=
CreateTransport
(
aParentDestPid
&
parentTransport
&
childTransport
)
)
)
{
AnnotateCrashReportWithErrno
(
"
IpcCreateEndpointsNsresult
"
int
(
rv
)
)
;
return
rv
;
}
*
aParentEndpoint
=
Endpoint
<
PFooParent
>
(
aPrivate
mozilla
:
:
ipc
:
:
Transport
:
:
MODE_SERVER
parentTransport
aParentDestPid
aChildDestPid
aProtocol
)
;
*
aChildEndpoint
=
Endpoint
<
PFooChild
>
(
aPrivate
mozilla
:
:
ipc
:
:
Transport
:
:
MODE_CLIENT
childTransport
aChildDestPid
aParentDestPid
aChildProtocol
)
;
return
NS_OK
;
}
void
TableToArray
(
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
&
aTable
nsTArray
<
void
*
>
&
aArray
)
;
}
template
<
typename
Protocol
>
class
ManagedContainer
:
public
nsTHashtable
<
nsPtrHashKey
<
Protocol
>
>
{
typedef
nsTHashtable
<
nsPtrHashKey
<
Protocol
>
>
BaseClass
;
public
:
void
ToArray
(
nsTArray
<
Protocol
*
>
&
aArray
)
const
{
:
:
mozilla
:
:
ipc
:
:
TableToArray
(
*
reinterpret_cast
<
const
nsTHashtable
<
nsPtrHashKey
<
void
>
>
*
>
(
static_cast
<
const
BaseClass
*
>
(
this
)
)
reinterpret_cast
<
nsTArray
<
void
*
>
&
>
(
aArray
)
)
;
}
}
;
template
<
typename
Protocol
>
Protocol
*
LoneManagedOrNullAsserts
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aManagees
.
Count
(
)
=
=
1
)
;
return
aManagees
.
ConstIter
(
)
.
Get
(
)
-
>
GetKey
(
)
;
}
template
<
typename
Protocol
>
Protocol
*
SingleManagedOrNull
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
Count
(
)
!
=
1
)
{
return
nullptr
;
}
return
aManagees
.
ConstIter
(
)
.
Get
(
)
-
>
GetKey
(
)
;
}
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
ActorHandle
>
{
typedef
mozilla
:
:
ipc
:
:
ActorHandle
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
IPC
:
:
WriteParam
(
aMsg
aParam
.
mId
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
int
id
;
if
(
IPC
:
:
ReadParam
(
aMsg
aIter
&
id
)
)
{
aResult
-
>
mId
=
id
;
return
true
;
}
return
false
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
(
%
d
)
"
aParam
.
mId
)
)
;
}
}
;
template
<
class
PFooSide
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
Endpoint
<
PFooSide
>
>
{
typedef
mozilla
:
:
ipc
:
:
Endpoint
<
PFooSide
>
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
IPC
:
:
WriteParam
(
aMsg
aParam
.
mValid
)
;
if
(
!
aParam
.
mValid
)
{
return
;
}
IPC
:
:
WriteParam
(
aMsg
static_cast
<
uint32_t
>
(
aParam
.
mMode
)
)
;
mozilla
:
:
ipc
:
:
TransportDescriptor
desc
=
mozilla
:
:
ipc
:
:
DuplicateDescriptor
(
aParam
.
mTransport
)
;
IPC
:
:
WriteParam
(
aMsg
desc
)
;
IPC
:
:
WriteParam
(
aMsg
aParam
.
mMyPid
)
;
IPC
:
:
WriteParam
(
aMsg
aParam
.
mOtherPid
)
;
IPC
:
:
WriteParam
(
aMsg
static_cast
<
uint32_t
>
(
aParam
.
mProtocolId
)
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
MOZ_RELEASE_ASSERT
(
!
aResult
-
>
mValid
)
;
if
(
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mValid
)
)
{
return
false
;
}
if
(
!
aResult
-
>
mValid
)
{
return
true
;
}
uint32_t
mode
protocolId
;
if
(
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
mode
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mTransport
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mMyPid
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
aResult
-
>
mOtherPid
)
|
|
!
IPC
:
:
ReadParam
(
aMsg
aIter
&
protocolId
)
)
{
return
false
;
}
aResult
-
>
mMode
=
Channel
:
:
Mode
(
mode
)
;
aResult
-
>
mProtocolId
=
mozilla
:
:
ipc
:
:
ProtocolId
(
protocolId
)
;
return
true
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
Endpoint
"
)
)
;
}
}
;
}
#
endif
