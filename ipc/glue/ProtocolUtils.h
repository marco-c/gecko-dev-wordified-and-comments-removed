#
ifndef
mozilla_ipc_ProtocolUtils_h
#
define
mozilla_ipc_ProtocolUtils_h
1
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
IPCMessageStart
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
"
mojo
/
core
/
ports
/
port_ref
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FunctionRef
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Scoped
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
prenv
.
h
"
#
if
defined
(
ANDROID
)
&
&
defined
(
DEBUG
)
#
include
<
android
/
log
.
h
>
#
endif
template
<
typename
T
>
class
nsPtrHashKey
;
namespace
{
enum
{
DATA_PIPE_CLOSED_MESSAGE_TYPE
=
kuint16max
-
18
DATA_PIPE_BYTES_CONSUMED_MESSAGE_TYPE
=
kuint16max
-
17
ACCEPT_INVITE_MESSAGE_TYPE
=
kuint16max
-
16
REQUEST_INTRODUCTION_MESSAGE_TYPE
=
kuint16max
-
15
INTRODUCE_MESSAGE_TYPE
=
kuint16max
-
14
BROADCAST_MESSAGE_TYPE
=
kuint16max
-
13
EVENT_MESSAGE_TYPE
=
kuint16max
-
12
MANAGED_ENDPOINT_DROPPED_MESSAGE_TYPE
=
kuint16max
-
11
MANAGED_ENDPOINT_BOUND_MESSAGE_TYPE
=
kuint16max
-
10
IMPENDING_SHUTDOWN_MESSAGE_TYPE
=
kuint16max
-
9
BUILD_IDS_MATCH_MESSAGE_TYPE
=
kuint16max
-
8
BUILD_ID_MESSAGE_TYPE
=
kuint16max
-
7
CHANNEL_OPENED_MESSAGE_TYPE
=
kuint16max
-
6
SHMEM_DESTROYED_MESSAGE_TYPE
=
kuint16max
-
5
SHMEM_CREATED_MESSAGE_TYPE
=
kuint16max
-
4
GOODBYE_MESSAGE_TYPE
=
kuint16max
-
3
CANCEL_MESSAGE_TYPE
=
kuint16max
-
2
}
;
}
class
MessageLoop
;
class
PickleIterator
;
class
nsISerialEventTarget
;
namespace
mozilla
{
class
SchedulerGroup
;
namespace
dom
{
class
ContentParent
;
}
namespace
net
{
class
NeckoParent
;
}
namespace
ipc
{
#
ifdef
FUZZING
class
ProtocolFuzzerHelper
;
#
endif
struct
ScopedProcessHandleTraits
{
typedef
base
:
:
ProcessHandle
type
;
static
type
empty
(
)
{
return
base
:
:
kInvalidProcessHandle
;
}
static
void
release
(
type
aProcessHandle
)
{
if
(
aProcessHandle
&
&
aProcessHandle
!
=
base
:
:
kInvalidProcessHandle
)
{
base
:
:
CloseProcessHandle
(
aProcessHandle
)
;
}
}
}
;
typedef
mozilla
:
:
Scoped
<
ScopedProcessHandleTraits
>
ScopedProcessHandle
;
class
ProtocolFdMapping
;
class
ProtocolCloneContext
;
struct
ActorHandle
{
int
mId
;
}
;
enum
RacyInterruptPolicy
{
RIPError
RIPChildWins
RIPParentWins
}
;
enum
class
LinkStatus
:
uint8_t
{
Inactive
Connected
Doomed
Destroyed
}
;
typedef
IPCMessageStart
ProtocolId
;
const
char
*
ProtocolIdToName
(
IPCMessageStart
aId
)
;
class
IToplevelProtocol
;
class
ActorLifecycleProxy
;
class
WeakActorLifecycleProxy
;
class
IPDLResolverInner
;
class
UntypedManagedEndpoint
;
class
IProtocol
:
public
HasResultCodes
{
public
:
enum
ActorDestroyReason
{
FailedConstructor
Deletion
AncestorDeletion
NormalShutdown
AbnormalShutdown
ManagedEndpointDropped
}
;
typedef
base
:
:
ProcessId
ProcessId
;
typedef
IPC
:
:
Message
Message
;
IProtocol
(
ProtocolId
aProtoId
Side
aSide
)
:
mId
(
0
)
mProtocolId
(
aProtoId
)
mSide
(
aSide
)
mLinkStatus
(
LinkStatus
:
:
Inactive
)
mLifecycleProxy
(
nullptr
)
mManager
(
nullptr
)
mToplevel
(
nullptr
)
{
}
IToplevelProtocol
*
ToplevelProtocol
(
)
{
return
mToplevel
;
}
const
IToplevelProtocol
*
ToplevelProtocol
(
)
const
{
return
mToplevel
;
}
int32_t
Register
(
IProtocol
*
aRouted
)
;
int32_t
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
;
IProtocol
*
Lookup
(
int32_t
aId
)
;
void
Unregister
(
int32_t
aId
)
;
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
aSize
bool
aUnsafe
int32_t
*
aId
)
;
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
aId
)
;
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
aSegment
)
;
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
;
MessageChannel
*
GetIPCChannel
(
)
;
const
MessageChannel
*
GetIPCChannel
(
)
const
;
nsISerialEventTarget
*
GetActorEventTarget
(
)
;
ProtocolId
GetProtocolId
(
)
const
{
return
mProtocolId
;
}
const
char
*
GetProtocolName
(
)
const
{
return
ProtocolIdToName
(
mProtocolId
)
;
}
int32_t
Id
(
)
const
{
return
mId
;
}
IProtocol
*
Manager
(
)
const
{
return
mManager
;
}
ActorLifecycleProxy
*
GetLifecycleProxy
(
)
{
return
mLifecycleProxy
;
}
WeakActorLifecycleProxy
*
GetWeakLifecycleProxy
(
)
;
Side
GetSide
(
)
const
{
return
mSide
;
}
bool
CanSend
(
)
const
{
return
mLinkStatus
=
=
LinkStatus
:
:
Connected
;
}
bool
CanRecv
(
)
const
{
return
mLinkStatus
=
=
LinkStatus
:
:
Connected
|
|
mLinkStatus
=
=
LinkStatus
:
:
Doomed
;
}
virtual
void
RemoveManagee
(
int32_t
IProtocol
*
)
=
0
;
virtual
void
DeallocManagee
(
int32_t
IProtocol
*
)
=
0
;
Maybe
<
IProtocol
*
>
ReadActor
(
IPC
:
:
MessageReader
*
aReader
bool
aNullable
const
char
*
aActorDescription
int32_t
aProtocolTypeId
)
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
)
=
0
;
virtual
Result
OnMessageReceived
(
const
Message
&
aMessage
UniquePtr
<
Message
>
&
aReply
)
=
0
;
virtual
Result
OnCallReceived
(
const
Message
&
aMessage
UniquePtr
<
Message
>
&
aReply
)
=
0
;
bool
AllocShmem
(
size_t
aSize
Shmem
*
aOutMem
)
;
bool
AllocUnsafeShmem
(
size_t
aSize
Shmem
*
aOutMem
)
;
bool
DeallocShmem
(
Shmem
&
aMem
)
;
void
FatalError
(
const
char
*
const
aErrorMsg
)
const
;
virtual
void
HandleFatalError
(
const
char
*
aErrorMsg
)
const
;
protected
:
virtual
~
IProtocol
(
)
;
friend
class
IToplevelProtocol
;
friend
class
ActorLifecycleProxy
;
friend
class
IPDLResolverInner
;
friend
class
UntypedManagedEndpoint
;
void
SetId
(
int32_t
aId
)
;
void
SetManager
(
IProtocol
*
aManager
)
;
void
SetManagerAndRegister
(
IProtocol
*
aManager
)
;
void
SetManagerAndRegister
(
IProtocol
*
aManager
int32_t
aId
)
;
bool
ChannelSend
(
UniquePtr
<
IPC
:
:
Message
>
aMsg
)
;
bool
ChannelSend
(
UniquePtr
<
IPC
:
:
Message
>
aMsg
UniquePtr
<
IPC
:
:
Message
>
*
aReply
)
;
template
<
typename
Value
>
void
ChannelSend
(
UniquePtr
<
IPC
:
:
Message
>
aMsg
ResolveCallback
<
Value
>
&
&
aResolve
RejectCallback
&
&
aReject
)
{
if
(
CanSend
(
)
)
{
GetIPCChannel
(
)
-
>
Send
(
std
:
:
move
(
aMsg
)
this
std
:
:
move
(
aResolve
)
std
:
:
move
(
aReject
)
)
;
}
else
{
WarnMessageDiscarded
(
aMsg
.
get
(
)
)
;
aReject
(
ResponseRejectReason
:
:
SendError
)
;
}
}
virtual
void
AllManagedActors
(
nsTArray
<
RefPtr
<
ActorLifecycleProxy
>
>
&
aActors
)
const
=
0
;
void
ActorConnected
(
)
;
virtual
void
ActorDoom
(
)
{
}
void
DoomSubtree
(
)
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
}
void
DestroySubtree
(
ActorDestroyReason
aWhy
)
;
virtual
void
ActorAlloc
(
)
{
}
virtual
void
ActorDealloc
(
)
{
if
(
Manager
(
)
)
{
Manager
(
)
-
>
DeallocManagee
(
mProtocolId
this
)
;
}
}
static
const
int32_t
kNullActorId
=
0
;
static
const
int32_t
kFreedActorId
=
1
;
private
:
#
ifdef
DEBUG
void
WarnMessageDiscarded
(
IPC
:
:
Message
*
aMsg
)
;
#
else
void
WarnMessageDiscarded
(
IPC
:
:
Message
*
)
{
}
#
endif
int32_t
mId
;
ProtocolId
mProtocolId
;
Side
mSide
;
LinkStatus
mLinkStatus
;
ActorLifecycleProxy
*
mLifecycleProxy
;
IProtocol
*
mManager
;
IToplevelProtocol
*
mToplevel
;
}
;
#
define
IPC_OK
(
)
mozilla
:
:
ipc
:
:
IPCResult
:
:
Ok
(
)
#
define
IPC_FAIL
(
actor
why
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
(
why
)
)
#
define
IPC_FAIL_NO_REASON
(
actor
)
\
mozilla
:
:
ipc
:
:
IPCResult
:
:
Fail
(
WrapNotNull
(
actor
)
__func__
)
class
IPCResult
{
public
:
static
IPCResult
Ok
(
)
{
return
IPCResult
(
true
)
;
}
static
IPCResult
Fail
(
NotNull
<
IProtocol
*
>
aActor
const
char
*
aWhere
const
char
*
aWhy
=
"
"
)
;
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mSuccess
;
}
private
:
explicit
IPCResult
(
bool
aResult
)
:
mSuccess
(
aResult
)
{
}
bool
mSuccess
;
}
;
class
UntypedEndpoint
;
template
<
class
PFooSide
>
class
Endpoint
;
template
<
class
PFooSide
>
class
ManagedEndpoint
;
class
IToplevelProtocol
:
public
IProtocol
{
#
ifdef
FUZZING
friend
class
mozilla
:
:
ipc
:
:
ProtocolFuzzerHelper
;
#
endif
template
<
class
PFooSide
>
friend
class
Endpoint
;
protected
:
explicit
IToplevelProtocol
(
const
char
*
aName
ProtocolId
aProtoId
Side
aSide
)
;
~
IToplevelProtocol
(
)
=
default
;
public
:
int32_t
Register
(
IProtocol
*
aRouted
)
;
int32_t
RegisterID
(
IProtocol
*
aRouted
int32_t
aId
)
;
IProtocol
*
Lookup
(
int32_t
aId
)
;
void
Unregister
(
int32_t
aId
)
;
Shmem
:
:
SharedMemory
*
CreateSharedMemory
(
size_t
aSize
bool
aUnsafe
int32_t
*
aId
)
;
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
aId
)
;
bool
IsTrackingSharedMemory
(
Shmem
:
:
SharedMemory
*
aSegment
)
;
bool
DestroySharedMemory
(
Shmem
&
aShmem
)
;
MessageChannel
*
GetIPCChannel
(
)
{
return
&
mChannel
;
}
const
MessageChannel
*
GetIPCChannel
(
)
const
{
return
&
mChannel
;
}
void
SetOtherProcessId
(
base
:
:
ProcessId
aOtherPid
)
;
virtual
void
OnChannelClose
(
)
=
0
;
virtual
void
OnChannelError
(
)
=
0
;
virtual
void
ProcessingError
(
Result
aError
const
char
*
aMsgName
)
{
}
bool
Open
(
ScopedPort
aPort
base
:
:
ProcessId
aOtherPid
nsISerialEventTarget
*
aEventTarget
=
nullptr
)
;
bool
Open
(
IToplevelProtocol
*
aTarget
nsISerialEventTarget
*
aEventTarget
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
bool
OpenOnSameThread
(
IToplevelProtocol
*
aTarget
mozilla
:
:
ipc
:
:
Side
aSide
=
mozilla
:
:
ipc
:
:
UnknownSide
)
;
void
NotifyImpendingShutdown
(
)
;
void
Close
(
)
;
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
void
DeallocShmems
(
)
;
bool
ShmemCreated
(
const
Message
&
aMsg
)
;
bool
ShmemDestroyed
(
const
Message
&
aMsg
)
;
virtual
bool
ShouldContinueFromReplyTimeout
(
)
{
return
false
;
}
virtual
void
IntentionalCrash
(
)
{
MOZ_CRASH
(
"
Intentional
IPDL
crash
"
)
;
}
#
ifdef
DEBUG
virtual
bool
ArtificialTimeout
(
)
{
return
false
;
}
virtual
bool
NeedArtificialSleep
(
)
{
return
false
;
}
virtual
void
ArtificialSleep
(
)
{
}
#
else
bool
ArtificialTimeout
(
)
{
return
false
;
}
bool
NeedArtificialSleep
(
)
{
return
false
;
}
void
ArtificialSleep
(
)
{
}
#
endif
bool
IsOnCxxStack
(
)
const
;
virtual
bool
HandleWindowsMessages
(
const
Message
&
aMsg
)
const
{
return
true
;
}
virtual
void
ProcessRemoteNativeEventsInInterruptCall
(
)
{
}
virtual
void
OnChannelReceivedMessage
(
const
Message
&
aMsg
)
{
}
void
OnIPCChannelOpened
(
)
{
ActorConnected
(
)
;
}
base
:
:
ProcessId
OtherPidMaybeInvalid
(
)
const
{
return
mOtherPid
;
}
private
:
int32_t
NextId
(
)
;
template
<
class
T
>
using
IDMap
=
nsTHashMap
<
nsUint32HashKey
T
>
;
base
:
:
ProcessId
mOtherPid
;
int32_t
mLastLocalId
;
IDMap
<
IProtocol
*
>
mActorMap
;
IDMap
<
Shmem
:
:
SharedMemory
*
>
mShmemMap
;
MessageChannel
mChannel
;
}
;
class
IShmemAllocator
{
public
:
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
=
0
;
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
=
0
;
}
;
#
define
FORWARD_SHMEM_ALLOCATOR_TO
(
aImplClass
)
\
virtual
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
\
override
{
\
return
aImplClass
:
:
AllocShmem
(
aSize
aShmem
)
;
\
}
\
virtual
bool
AllocUnsafeShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
\
override
{
\
return
aImplClass
:
:
AllocUnsafeShmem
(
aSize
aShmem
)
;
\
}
\
virtual
bool
DeallocShmem
(
mozilla
:
:
ipc
:
:
Shmem
&
aShmem
)
override
{
\
return
aImplClass
:
:
DeallocShmem
(
aShmem
)
;
\
}
inline
bool
LoggingEnabled
(
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
!
!
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
;
#
else
return
false
;
#
endif
}
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
const
char
*
aFilter
)
;
#
endif
inline
bool
LoggingEnabledFor
(
const
char
*
aTopLevelProtocol
)
{
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
return
LoggingEnabledFor
(
aTopLevelProtocol
PR_GetEnv
(
"
MOZ_IPC_MESSAGE_LOG
"
)
)
;
#
else
return
false
;
#
endif
}
MOZ_NEVER_INLINE
void
LogMessageForProtocol
(
const
char
*
aTopLevelProtocol
base
:
:
ProcessId
aOtherPid
const
char
*
aContextDescription
uint32_t
aMessageId
MessageDirection
aDirection
)
;
MOZ_NEVER_INLINE
void
ProtocolErrorBreakpoint
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
PickleFatalError
(
const
char
*
aMsg
IProtocol
*
aActor
)
;
MOZ_NEVER_INLINE
void
FatalError
(
const
char
*
aMsg
bool
aIsParent
)
;
MOZ_NEVER_INLINE
void
LogicError
(
const
char
*
aMsg
)
;
MOZ_NEVER_INLINE
void
ActorIdReadError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
BadActorIdError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
ActorLookupError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
MismatchedActorTypeError
(
const
char
*
aActorDescription
)
;
MOZ_NEVER_INLINE
void
UnionTypeReadError
(
const
char
*
aUnionName
)
;
MOZ_NEVER_INLINE
void
ArrayLengthReadError
(
const
char
*
aElementName
)
;
MOZ_NEVER_INLINE
void
SentinelReadError
(
const
char
*
aElementName
)
;
void
AnnotateSystemError
(
)
;
class
ActorLifecycleProxy
{
public
:
NS_INLINE_DECL_REFCOUNTING_ONEVENTTARGET
(
ActorLifecycleProxy
)
IProtocol
*
Get
(
)
{
return
mActor
;
}
WeakActorLifecycleProxy
*
GetWeakProxy
(
)
;
private
:
friend
class
IProtocol
;
explicit
ActorLifecycleProxy
(
IProtocol
*
aActor
)
;
~
ActorLifecycleProxy
(
)
;
ActorLifecycleProxy
(
const
ActorLifecycleProxy
&
)
=
delete
;
ActorLifecycleProxy
&
operator
=
(
const
ActorLifecycleProxy
&
)
=
delete
;
IProtocol
*
MOZ_NON_OWNING_REF
mActor
;
RefPtr
<
ActorLifecycleProxy
>
mManager
;
RefPtr
<
WeakActorLifecycleProxy
>
mWeakProxy
;
}
;
class
WeakActorLifecycleProxy
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WeakActorLifecycleProxy
)
IProtocol
*
Get
(
)
const
;
nsISerialEventTarget
*
ActorEventTarget
(
)
const
{
return
mActorEventTarget
;
}
private
:
friend
class
ActorLifecycleProxy
;
explicit
WeakActorLifecycleProxy
(
ActorLifecycleProxy
*
aProxy
)
;
~
WeakActorLifecycleProxy
(
)
;
WeakActorLifecycleProxy
(
const
WeakActorLifecycleProxy
&
)
=
delete
;
WeakActorLifecycleProxy
&
operator
=
(
const
WeakActorLifecycleProxy
&
)
=
delete
;
ActorLifecycleProxy
*
MOZ_NON_OWNING_REF
mProxy
;
const
nsCOMPtr
<
nsISerialEventTarget
>
mActorEventTarget
;
}
;
class
IPDLResolverInner
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DESTROY
(
IPDLResolverInner
Destroy
(
)
)
explicit
IPDLResolverInner
(
UniquePtr
<
IPC
:
:
Message
>
aReply
IProtocol
*
aActor
)
;
template
<
typename
F
>
void
Resolve
(
F
&
&
aWrite
)
{
ResolveOrReject
(
true
aWrite
)
;
}
private
:
void
ResolveOrReject
(
bool
aResolve
FunctionRef
<
void
(
IPC
:
:
Message
*
IProtocol
*
)
>
aWrite
)
;
void
Destroy
(
)
;
~
IPDLResolverInner
(
)
;
UniquePtr
<
IPC
:
:
Message
>
mReply
;
RefPtr
<
WeakActorLifecycleProxy
>
mWeakProxy
;
}
;
}
template
<
typename
Protocol
>
class
ManagedContainer
{
public
:
using
iterator
=
typename
nsTArray
<
Protocol
*
>
:
:
const_iterator
;
iterator
begin
(
)
const
{
return
mArray
.
begin
(
)
;
}
iterator
end
(
)
const
{
return
mArray
.
end
(
)
;
}
iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
iterator
cend
(
)
const
{
return
end
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mArray
.
IsEmpty
(
)
;
}
uint32_t
Count
(
)
const
{
return
mArray
.
Length
(
)
;
}
void
ToArray
(
nsTArray
<
Protocol
*
>
&
aArray
)
const
{
aArray
.
AppendElements
(
mArray
)
;
}
bool
EnsureRemoved
(
Protocol
*
aElement
)
{
return
mArray
.
RemoveElementSorted
(
aElement
)
;
}
void
Insert
(
Protocol
*
aElement
)
{
size_t
index
=
mArray
.
IndexOfFirstElementGt
(
aElement
)
;
if
(
index
=
=
0
|
|
mArray
[
index
-
1
]
!
=
aElement
)
{
mArray
.
InsertElementAt
(
index
aElement
)
;
}
}
void
Clear
(
)
{
mArray
.
Clear
(
)
;
}
private
:
nsTArray
<
Protocol
*
>
mArray
;
}
;
template
<
typename
Protocol
>
Protocol
*
LoneManagedOrNullAsserts
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
IsEmpty
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aManagees
.
Count
(
)
=
=
1
)
;
return
*
aManagees
.
cbegin
(
)
;
}
template
<
typename
Protocol
>
Protocol
*
SingleManagedOrNull
(
const
ManagedContainer
<
Protocol
>
&
aManagees
)
{
if
(
aManagees
.
Count
(
)
!
=
1
)
{
return
nullptr
;
}
return
*
aManagees
.
cbegin
(
)
;
}
}
#
endif
