#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
include
<
windows
.
h
>
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
win_util
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
RandomNum
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsString
.
h
"
#
ifdef
MOZ_MEMORY
#
include
"
mozmemory_utils
.
h
"
#
endif
namespace
{
typedef
enum
_SECTION_INFORMATION_CLASS
{
SectionBasicInformation
}
SECTION_INFORMATION_CLASS
;
typedef
struct
_SECTION_BASIC_INFORMATION
{
PVOID
BaseAddress
;
ULONG
Attributes
;
LARGE_INTEGER
Size
;
}
SECTION_BASIC_INFORMATION
*
PSECTION_BASIC_INFORMATION
;
typedef
ULONG
(
__stdcall
*
NtQuerySectionType
)
(
HANDLE
SectionHandle
SECTION_INFORMATION_CLASS
SectionInformationClass
PVOID
SectionInformation
ULONG
SectionInformationLength
PULONG
ResultLength
)
;
bool
IsSectionSafeToMap
(
HANDLE
handle
)
{
static
NtQuerySectionType
nt_query_section_func
=
reinterpret_cast
<
NtQuerySectionType
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandle
(
L
"
ntdll
.
dll
"
)
"
NtQuerySection
"
)
)
;
DCHECK
(
nt_query_section_func
)
;
SECTION_BASIC_INFORMATION
basic_information
=
{
}
;
ULONG
status
=
nt_query_section_func
(
handle
SectionBasicInformation
&
basic_information
sizeof
(
basic_information
)
nullptr
)
;
if
(
status
)
{
return
false
;
}
return
(
basic_information
.
Attributes
&
SEC_IMAGE
)
!
=
SEC_IMAGE
;
}
}
namespace
mozilla
:
:
ipc
{
void
SharedMemory
:
:
ResetImpl
(
)
{
}
;
SharedMemory
:
:
Handle
SharedMemory
:
:
CloneHandle
(
const
Handle
&
aHandle
)
{
HANDLE
handle
=
INVALID_HANDLE_VALUE
;
if
(
DuplicateHandle
(
GetCurrentProcess
(
)
aHandle
.
get
(
)
GetCurrentProcess
(
)
&
handle
0
false
DUPLICATE_SAME_ACCESS
)
)
{
return
SharedMemoryHandle
(
handle
)
;
}
NS_WARNING
(
"
DuplicateHandle
Failed
!
"
)
;
return
nullptr
;
}
void
*
SharedMemory
:
:
FindFreeAddressSpace
(
size_t
size
)
{
void
*
memory
=
VirtualAlloc
(
NULL
size
MEM_RESERVE
PAGE_NOACCESS
)
;
if
(
memory
)
{
VirtualFree
(
memory
0
MEM_RELEASE
)
;
}
return
memory
;
}
Maybe
<
void
*
>
SharedMemory
:
:
MapImpl
(
size_t
nBytes
void
*
fixedAddress
)
{
if
(
mExternalHandle
&
&
!
IsSectionSafeToMap
(
mHandle
.
get
(
)
)
)
{
return
Nothing
(
)
;
}
void
*
mem
=
MapViewOfFileEx
(
mHandle
.
get
(
)
mReadOnly
?
FILE_MAP_READ
:
FILE_MAP_READ
|
FILE_MAP_WRITE
0
0
nBytes
fixedAddress
)
;
if
(
mem
)
{
MOZ_ASSERT
(
!
fixedAddress
|
|
mem
=
=
fixedAddress
"
MapViewOfFileEx
returned
an
expected
address
"
)
;
return
Some
(
mem
)
;
}
return
Nothing
(
)
;
}
void
SharedMemory
:
:
UnmapImpl
(
size_t
nBytes
void
*
address
)
{
UnmapViewOfFile
(
address
)
;
}
static
HANDLE
MozCreateFileMappingW
(
LPSECURITY_ATTRIBUTES
lpFileMappingAttributes
DWORD
flProtect
DWORD
dwMaximumSizeHigh
DWORD
dwMaximumSizeLow
LPCWSTR
lpName
)
{
#
ifdef
MOZ_MEMORY
constexpr
auto
IsOOMError
=
[
]
{
return
:
:
GetLastError
(
)
=
=
ERROR_COMMITMENT_LIMIT
;
}
;
{
HANDLE
handle
=
:
:
CreateFileMappingW
(
INVALID_HANDLE_VALUE
lpFileMappingAttributes
flProtect
dwMaximumSizeHigh
dwMaximumSizeLow
lpName
)
;
if
(
MOZ_LIKELY
(
handle
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
handle
!
=
INVALID_HANDLE_VALUE
"
:
:
CreateFileMapping
should
return
NULL
not
"
"
INVALID_HANDLE_VALUE
on
failure
"
)
;
return
handle
;
}
if
(
!
IsOOMError
(
)
)
{
return
nullptr
;
}
}
const
mozilla
:
:
StallSpecs
stallSpecs
=
mozilla
:
:
GetAllocatorStallSpecs
(
)
;
const
auto
ret
=
stallSpecs
.
StallAndRetry
(
&
:
:
Sleep
[
&
]
(
)
-
>
std
:
:
optional
<
HANDLE
>
{
HANDLE
handle
=
:
:
CreateFileMappingW
(
INVALID_HANDLE_VALUE
lpFileMappingAttributes
flProtect
dwMaximumSizeHigh
dwMaximumSizeLow
lpName
)
;
if
(
handle
)
{
MOZ_DIAGNOSTIC_ASSERT
(
handle
!
=
INVALID_HANDLE_VALUE
"
:
:
CreateFileMapping
should
return
NULL
not
"
"
INVALID_HANDLE_VALUE
on
failure
"
)
;
return
handle
;
}
if
(
!
IsOOMError
(
)
)
{
return
nullptr
;
}
return
std
:
:
nullopt
;
}
)
;
return
ret
.
value_or
(
nullptr
)
;
#
else
return
:
:
CreateFileMappingW
(
INVALID_HANDLE_VALUE
lpFileMappingAttributes
flProtect
dwMaximumSizeHigh
dwMaximumSizeLow
lpName
)
;
#
endif
}
bool
SharedMemory
:
:
CreateImpl
(
size_t
size
bool
freezable
)
{
SECURITY_ATTRIBUTES
sa
*
psa
=
nullptr
;
SECURITY_DESCRIPTOR
sd
;
ACL
dacl
;
if
(
freezable
)
{
psa
=
&
sa
;
sa
.
nLength
=
sizeof
(
sa
)
;
sa
.
lpSecurityDescriptor
=
&
sd
;
sa
.
bInheritHandle
=
FALSE
;
if
(
NS_WARN_IF
(
!
InitializeAcl
(
&
dacl
sizeof
(
dacl
)
ACL_REVISION
)
)
|
|
NS_WARN_IF
(
!
InitializeSecurityDescriptor
(
&
sd
SECURITY_DESCRIPTOR_REVISION
)
)
|
|
NS_WARN_IF
(
!
SetSecurityDescriptorDacl
(
&
sd
TRUE
&
dacl
FALSE
)
)
)
{
return
false
;
}
}
mHandle
.
reset
(
MozCreateFileMappingW
(
psa
PAGE_READWRITE
0
static_cast
<
DWORD
>
(
size
)
nullptr
)
)
;
return
(
bool
)
mHandle
;
}
Maybe
<
SharedMemory
:
:
Handle
>
SharedMemory
:
:
ReadOnlyCopyImpl
(
)
{
HANDLE
ro_handle
;
if
(
!
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
mHandle
.
get
(
)
GetCurrentProcess
(
)
&
ro_handle
GENERIC_READ
|
FILE_MAP_READ
false
0
)
)
{
return
Nothing
(
)
;
}
return
Some
(
ro_handle
)
;
}
void
SharedMemory
:
:
SystemProtect
(
char
*
aAddr
size_t
aSize
int
aRights
)
{
if
(
!
SystemProtectFallible
(
aAddr
aSize
aRights
)
)
{
MOZ_CRASH
(
"
can
'
t
VirtualProtect
(
)
"
)
;
}
}
bool
SharedMemory
:
:
SystemProtectFallible
(
char
*
aAddr
size_t
aSize
int
aRights
)
{
DWORD
flags
;
if
(
(
aRights
&
RightsRead
)
&
&
(
aRights
&
RightsWrite
)
)
flags
=
PAGE_READWRITE
;
else
if
(
aRights
&
RightsRead
)
flags
=
PAGE_READONLY
;
else
flags
=
PAGE_NOACCESS
;
DWORD
oldflags
;
return
VirtualProtect
(
aAddr
aSize
flags
&
oldflags
)
;
}
size_t
SharedMemory
:
:
SystemPageSize
(
)
{
SYSTEM_INFO
si
;
GetSystemInfo
(
&
si
)
;
return
si
.
dwPageSize
;
}
}
