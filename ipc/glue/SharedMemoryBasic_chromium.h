#
ifndef
mozilla_ipc_SharedMemoryBasic_chromium_h
#
define
mozilla_ipc_SharedMemoryBasic_chromium_h
#
include
"
base
/
shared_memory
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemory
.
h
"
#
ifdef
FUZZING
#
include
"
mozilla
/
ipc
/
SharedMemoryFuzzer
.
h
"
#
endif
#
include
"
nsDebug
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
SharedMemoryBasic
final
:
public
SharedMemoryCommon
<
base
:
:
SharedMemoryHandle
>
{
public
:
SharedMemoryBasic
(
)
=
default
;
virtual
bool
SetHandle
(
Handle
aHandle
OpenRights
aRights
)
override
{
return
mSharedMemory
.
SetHandle
(
std
:
:
move
(
aHandle
)
aRights
=
=
RightsReadOnly
)
;
}
virtual
bool
Create
(
size_t
aNbytes
)
override
{
bool
ok
=
mSharedMemory
.
Create
(
aNbytes
)
;
if
(
ok
)
{
Created
(
aNbytes
)
;
}
return
ok
;
}
virtual
bool
Map
(
size_t
nBytes
void
*
fixed_address
=
nullptr
)
override
{
bool
ok
=
mSharedMemory
.
Map
(
nBytes
fixed_address
)
;
if
(
ok
)
{
Mapped
(
nBytes
)
;
}
return
ok
;
}
virtual
void
Unmap
(
)
override
{
mSharedMemory
.
Unmap
(
)
;
}
virtual
void
CloseHandle
(
)
override
{
mSharedMemory
.
Close
(
false
)
;
}
virtual
void
*
memory
(
)
const
override
{
#
ifdef
FUZZING
return
SharedMemoryFuzzer
:
:
MutateSharedMemory
(
mSharedMemory
.
memory
(
)
mAllocSize
)
;
#
else
return
mSharedMemory
.
memory
(
)
;
#
endif
}
virtual
SharedMemoryType
Type
(
)
const
override
{
return
TYPE_BASIC
;
}
static
Handle
NULLHandle
(
)
{
return
base
:
:
SharedMemory
:
:
NULLHandle
(
)
;
}
virtual
bool
IsHandleValid
(
const
Handle
&
aHandle
)
const
override
{
return
base
:
:
SharedMemory
:
:
IsHandleValid
(
aHandle
)
;
}
virtual
bool
ShareToProcess
(
base
:
:
ProcessId
aProcessId
Handle
*
new_handle
)
override
{
*
new_handle
=
mSharedMemory
.
CloneHandle
(
)
;
return
base
:
:
SharedMemory
:
:
IsHandleValid
(
*
new_handle
)
;
}
static
void
*
FindFreeAddressSpace
(
size_t
size
)
{
return
base
:
:
SharedMemory
:
:
FindFreeAddressSpace
(
size
)
;
}
private
:
~
SharedMemoryBasic
(
)
=
default
;
base
:
:
SharedMemory
mSharedMemory
;
}
;
}
}
#
endif
