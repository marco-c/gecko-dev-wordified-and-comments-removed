#
ifndef
ipc_glue_MessageChannel_h
#
define
ipc_glue_MessageChannel_h
1
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
mozilla
/
Function
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
if
defined
(
OS_WIN
)
#
include
"
mozilla
/
ipc
/
Neutering
.
h
"
#
endif
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
if
defined
(
MOZ_CRASHREPORTER
)
&
&
defined
(
OS_WIN
)
#
include
"
mozilla
/
mozalloc_oom
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
endif
#
include
"
MessageLink
.
h
"
#
include
<
deque
>
#
include
<
stack
>
#
include
<
math
.
h
>
namespace
mozilla
{
namespace
ipc
{
class
MessageChannel
;
class
RefCountedMonitor
:
public
Monitor
{
public
:
RefCountedMonitor
(
)
:
Monitor
(
"
mozilla
.
ipc
.
MessageChannel
.
mMonitor
"
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefCountedMonitor
)
private
:
~
RefCountedMonitor
(
)
{
}
}
;
enum
class
SyncSendError
{
SendSuccess
PreviousTimeout
SendingCPOWWhileDispatchingSync
SendingCPOWWhileDispatchingUrgent
NotConnectedBeforeSend
DisconnectedDuringSend
CancelledBeforeSend
CancelledAfterSend
TimedOut
ReplyError
}
;
class
AutoEnterTransaction
;
class
MessageChannel
:
HasResultCodes
{
friend
class
ProcessLink
;
friend
class
ThreadLink
;
class
CxxStackFrame
;
class
InterruptFrame
;
typedef
mozilla
:
:
Monitor
Monitor
;
public
:
static
const
int32_t
kNoTimeout
;
typedef
IPC
:
:
Message
Message
;
typedef
IPC
:
:
MessageInfo
MessageInfo
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
explicit
MessageChannel
(
MessageListener
*
aListener
)
;
~
MessageChannel
(
)
;
bool
Open
(
Transport
*
aTransport
MessageLoop
*
aIOLoop
=
0
Side
aSide
=
UnknownSide
)
;
bool
Open
(
MessageChannel
*
aTargetChan
MessageLoop
*
aTargetLoop
Side
aSide
)
;
void
Close
(
)
;
void
CloseWithError
(
)
;
void
CloseWithTimeout
(
)
;
void
SetAbortOnError
(
bool
abort
)
{
mAbortOnError
=
abort
;
}
void
PeekMessages
(
mozilla
:
:
function
<
bool
(
const
Message
&
aMsg
)
>
aInvoke
)
;
enum
ChannelFlags
{
REQUIRE_DEFAULT
=
0
REQUIRE_DEFERRED_MESSAGE_PROTECTION
=
1
<
<
0
REQUIRE_A11Y_REENTRY
=
1
<
<
1
}
;
void
SetChannelFlags
(
ChannelFlags
aFlags
)
{
mFlags
=
aFlags
;
}
ChannelFlags
GetChannelFlags
(
)
{
return
mFlags
;
}
bool
Send
(
Message
*
aMsg
)
;
bool
Echo
(
Message
*
aMsg
)
;
bool
Send
(
Message
*
aMsg
Message
*
aReply
)
;
bool
Call
(
Message
*
aMsg
Message
*
aReply
)
;
bool
WaitForIncomingMessage
(
)
;
bool
CanSend
(
)
const
;
SyncSendError
LastSendError
(
)
const
{
AssertWorkerThread
(
)
;
return
mLastSendError
;
}
ChannelState
GetChannelState__TotallyRacy
(
)
const
{
return
mChannelState
;
}
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
bool
IsOnCxxStack
(
)
const
{
return
!
mCxxStackFrames
.
empty
(
)
;
}
bool
IsInTransaction
(
)
const
;
void
CancelCurrentTransaction
(
)
;
int32_t
GetTopmostMessageRoutingId
(
)
const
;
bool
Unsound_IsClosed
(
)
const
{
return
mLink
?
mLink
-
>
Unsound_IsClosed
(
)
:
true
;
}
uint32_t
Unsound_NumQueuedMessages
(
)
const
{
return
mLink
?
mLink
-
>
Unsound_NumQueuedMessages
(
)
:
0
;
}
static
bool
IsPumpingMessages
(
)
{
return
sIsPumpingMessages
;
}
static
void
SetIsPumpingMessages
(
bool
aIsPumping
)
{
sIsPumpingMessages
=
aIsPumping
;
}
#
ifdef
OS_WIN
struct
MOZ_STACK_CLASS
SyncStackFrame
{
SyncStackFrame
(
MessageChannel
*
channel
bool
interrupt
)
;
~
SyncStackFrame
(
)
;
bool
mInterrupt
;
bool
mSpinNestedEvents
;
bool
mListenerNotified
;
MessageChannel
*
mChannel
;
SyncStackFrame
*
mPrev
;
SyncStackFrame
*
mStaticPrev
;
}
;
friend
struct
MessageChannel
:
:
SyncStackFrame
;
static
bool
IsSpinLoopActive
(
)
{
for
(
SyncStackFrame
*
frame
=
sStaticTopFrame
;
frame
;
frame
=
frame
-
>
mPrev
)
{
if
(
frame
-
>
mSpinNestedEvents
)
return
true
;
}
return
false
;
}
protected
:
SyncStackFrame
*
mTopFrame
;
bool
mIsSyncWaitingOnNonMainThread
;
static
SyncStackFrame
*
sStaticTopFrame
;
public
:
void
ProcessNativeEventsInInterruptCall
(
)
;
static
void
NotifyGeckoEventDispatch
(
)
;
private
:
void
SpinInternalEventLoop
(
)
;
#
if
defined
(
ACCESSIBILITY
)
bool
WaitForSyncNotifyWithA11yReentry
(
)
;
#
endif
#
endif
private
:
void
CommonThreadOpenInit
(
MessageChannel
*
aTargetChan
Side
aSide
)
;
void
OnOpenAsSlave
(
MessageChannel
*
aTargetChan
Side
aSide
)
;
void
PostErrorNotifyTask
(
)
;
void
OnNotifyMaybeChannelError
(
)
;
void
ReportConnectionError
(
const
char
*
aChannelName
Message
*
aMsg
=
nullptr
)
const
;
void
ReportMessageRouteError
(
const
char
*
channelName
)
const
;
bool
MaybeHandleError
(
Result
code
const
Message
&
aMsg
const
char
*
channelName
)
;
void
Clear
(
)
;
void
DispatchOnChannelConnected
(
)
;
bool
InterruptEventOccurred
(
)
;
bool
HasPendingEvents
(
)
;
void
ProcessPendingRequests
(
AutoEnterTransaction
&
aTransaction
)
;
bool
ProcessPendingRequest
(
Message
&
&
aUrgent
)
;
void
MaybeUndeferIncall
(
)
;
void
EnqueuePendingMessages
(
)
;
void
DispatchMessage
(
Message
&
&
aMsg
)
;
void
DispatchSyncMessage
(
const
Message
&
aMsg
Message
*
&
aReply
)
;
void
DispatchUrgentMessage
(
const
Message
&
aMsg
)
;
void
DispatchAsyncMessage
(
const
Message
&
aMsg
)
;
void
DispatchRPCMessage
(
const
Message
&
aMsg
)
;
void
DispatchInterruptMessage
(
Message
&
&
aMsg
size_t
aStackDepth
)
;
bool
WaitForSyncNotify
(
bool
aHandleWindowsMessages
)
;
bool
WaitForInterruptNotify
(
)
;
bool
WaitResponse
(
bool
aWaitTimedOut
)
;
bool
ShouldContinueFromTimeout
(
)
;
void
EndTimeout
(
)
;
void
CancelTransaction
(
int
transaction
)
;
void
RepostAllMessages
(
)
;
size_t
RemoteViewOfStackDepth
(
size_t
stackDepth
)
const
{
AssertWorkerThread
(
)
;
return
stackDepth
-
mOutOfTurnReplies
.
size
(
)
;
}
int32_t
NextSeqno
(
)
{
AssertWorkerThread
(
)
;
return
(
mSide
=
=
ChildSide
)
?
-
-
mNextSeqno
:
+
+
mNextSeqno
;
}
void
EnteredCxxStack
(
)
{
mListener
-
>
OnEnteredCxxStack
(
)
;
}
void
ExitedCxxStack
(
)
;
void
EnteredCall
(
)
{
mListener
-
>
OnEnteredCall
(
)
;
}
void
ExitedCall
(
)
{
mListener
-
>
OnExitedCall
(
)
;
}
void
EnteredSyncSend
(
)
{
mListener
-
>
OnEnteredSyncSend
(
)
;
}
void
ExitedSyncSend
(
)
{
mListener
-
>
OnExitedSyncSend
(
)
;
}
MessageListener
*
Listener
(
)
const
{
return
mListener
;
}
void
DebugAbort
(
const
char
*
file
int
line
const
char
*
cond
const
char
*
why
bool
reply
=
false
)
;
void
DumpInterruptStack
(
const
char
*
const
pfx
=
"
"
)
const
;
private
:
size_t
InterruptStackDepth
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mInterruptStack
.
size
(
)
;
}
bool
AwaitingInterruptReply
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
!
mInterruptStack
.
empty
(
)
;
}
bool
AwaitingIncomingMessage
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mIsWaitingForIncoming
;
}
class
MOZ_STACK_CLASS
AutoEnterWaitForIncoming
{
public
:
explicit
AutoEnterWaitForIncoming
(
MessageChannel
&
aChannel
)
:
mChannel
(
aChannel
)
{
aChannel
.
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
aChannel
.
mIsWaitingForIncoming
=
true
;
}
~
AutoEnterWaitForIncoming
(
)
{
mChannel
.
mIsWaitingForIncoming
=
false
;
}
private
:
MessageChannel
&
mChannel
;
}
;
friend
class
AutoEnterWaitForIncoming
;
bool
DispatchingAsyncMessage
(
)
const
{
AssertWorkerThread
(
)
;
return
mDispatchingAsyncMessage
;
}
int
DispatchingAsyncMessageNestedLevel
(
)
const
{
AssertWorkerThread
(
)
;
return
mDispatchingAsyncMessageNestedLevel
;
}
bool
Connected
(
)
const
;
private
:
void
NotifyWorkerThread
(
)
;
bool
MaybeInterceptSpecialIOMessage
(
const
Message
&
aMsg
)
;
void
OnChannelConnected
(
int32_t
peer_id
)
;
void
SynchronouslyClose
(
)
;
bool
WasTransactionCanceled
(
int
transaction
)
;
bool
ShouldDeferMessage
(
const
Message
&
aMsg
)
;
void
OnMessageReceivedFromLink
(
Message
&
&
aMsg
)
;
void
OnChannelErrorFromLink
(
)
;
private
:
void
NotifyChannelClosed
(
)
;
void
NotifyMaybeChannelError
(
)
;
private
:
void
AssertWorkerThread
(
)
const
{
MOZ_RELEASE_ASSERT
(
mWorkerLoopID
=
=
MessageLoop
:
:
current
(
)
-
>
id
(
)
"
not
on
worker
thread
!
"
)
;
}
void
AssertLinkThread
(
)
const
{
MOZ_RELEASE_ASSERT
(
mWorkerLoopID
!
=
MessageLoop
:
:
current
(
)
-
>
id
(
)
"
on
worker
thread
but
should
not
be
!
"
)
;
}
private
:
class
MessageTask
:
public
CancelableRunnable
public
LinkedListElement
<
RefPtr
<
MessageTask
>
>
{
public
:
explicit
MessageTask
(
MessageChannel
*
aChannel
Message
&
&
aMessage
)
:
mChannel
(
aChannel
)
mMessage
(
Move
(
aMessage
)
)
mScheduled
(
false
)
{
}
NS_IMETHOD
Run
(
)
override
;
nsresult
Cancel
(
)
override
;
void
Post
(
)
;
void
Clear
(
)
;
bool
IsScheduled
(
)
const
{
return
mScheduled
;
}
Message
&
Msg
(
)
{
return
mMessage
;
}
const
Message
&
Msg
(
)
const
{
return
mMessage
;
}
private
:
MessageTask
(
)
=
delete
;
MessageTask
(
const
MessageTask
&
)
=
delete
;
MessageChannel
*
mChannel
;
Message
mMessage
;
bool
mScheduled
:
1
;
}
;
bool
ShouldRunMessage
(
const
Message
&
aMsg
)
;
void
RunMessage
(
MessageTask
&
aTask
)
;
typedef
LinkedList
<
RefPtr
<
MessageTask
>
>
MessageQueue
;
typedef
std
:
:
map
<
size_t
Message
>
MessageMap
;
typedef
IPC
:
:
Message
:
:
msgid_t
msgid_t
;
private
:
MessageListener
*
mListener
;
ChannelState
mChannelState
;
RefPtr
<
RefCountedMonitor
>
mMonitor
;
Side
mSide
;
MessageLink
*
mLink
;
MessageLoop
*
mWorkerLoop
;
RefPtr
<
CancelableRunnable
>
mChannelErrorTask
;
int
mWorkerLoopID
;
int32_t
mTimeoutMs
;
bool
mInTimeoutSecondHalf
;
int32_t
mNextSeqno
;
static
bool
sIsPumpingMessages
;
SyncSendError
mLastSendError
;
template
<
class
T
>
class
AutoSetValue
{
public
:
explicit
AutoSetValue
(
T
&
var
const
T
&
newValue
)
:
mVar
(
var
)
mPrev
(
var
)
mNew
(
newValue
)
{
mVar
=
newValue
;
}
~
AutoSetValue
(
)
{
if
(
mVar
=
=
mNew
)
{
mVar
=
mPrev
;
}
}
private
:
T
&
mVar
;
T
mPrev
;
T
mNew
;
}
;
bool
mDispatchingAsyncMessage
;
int
mDispatchingAsyncMessageNestedLevel
;
friend
class
AutoEnterTransaction
;
AutoEnterTransaction
*
mTransactionStack
;
int32_t
CurrentNestedInsideSyncTransaction
(
)
const
;
bool
AwaitingSyncReply
(
)
const
;
int
AwaitingSyncReplyNestedLevel
(
)
const
;
bool
DispatchingSyncMessage
(
)
const
;
int
DispatchingSyncMessageNestedLevel
(
)
const
;
int32_t
mTimedOutMessageSeqno
;
int
mTimedOutMessageNestedLevel
;
MessageQueue
mPending
;
std
:
:
stack
<
MessageInfo
>
mInterruptStack
;
size_t
mRemoteStackDepthGuess
;
mozilla
:
:
Vector
<
InterruptFrame
>
mCxxStackFrames
;
bool
mSawInterruptOutMsg
;
bool
mIsWaitingForIncoming
;
MessageMap
mOutOfTurnReplies
;
std
:
:
stack
<
Message
>
mDeferred
;
#
ifdef
OS_WIN
HANDLE
mEvent
;
#
endif
bool
mAbortOnError
;
bool
mNotifiedChannelDone
;
ChannelFlags
mFlags
;
RefPtr
<
CancelableRunnable
>
mOnChannelConnectedTask
;
bool
mPeerPidSet
;
int32_t
mPeerPid
;
}
;
void
CancelCPOWs
(
)
;
}
}
#
endif
