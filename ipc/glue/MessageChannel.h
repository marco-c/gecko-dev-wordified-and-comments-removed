#
ifndef
ipc_glue_MessageChannel_h
#
define
ipc_glue_MessageChannel_h
1
#
include
"
ipc
/
EnumSerializer
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
BaseProfilerMarkers
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
if
defined
(
OS_WIN
)
#
include
"
mozilla
/
ipc
/
Neutering
.
h
"
#
endif
#
include
<
functional
>
#
include
<
map
>
#
include
<
stack
>
#
include
<
vector
>
#
include
"
MessageLink
.
h
"
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
include
"
mozilla
/
ipc
/
ScopedPort
.
h
"
class
MessageLoop
;
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
ipc
{
class
IToplevelProtocol
;
class
ActorLifecycleProxy
;
class
RefCountedMonitor
:
public
Monitor
{
public
:
RefCountedMonitor
(
)
:
Monitor
(
"
mozilla
.
ipc
.
MessageChannel
.
mMonitor
"
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefCountedMonitor
)
private
:
~
RefCountedMonitor
(
)
=
default
;
}
;
enum
class
MessageDirection
{
eSending
eReceiving
}
;
enum
class
MessagePhase
{
Endpoint
TransferStart
TransferEnd
}
;
enum
class
SyncSendError
{
SendSuccess
PreviousTimeout
SendingCPOWWhileDispatchingSync
SendingCPOWWhileDispatchingUrgent
NotConnectedBeforeSend
DisconnectedDuringSend
CancelledBeforeSend
CancelledAfterSend
TimedOut
ReplyError
}
;
enum
class
ResponseRejectReason
{
SendError
ChannelClosed
HandlerRejected
ActorDestroyed
ResolverDestroyed
EndGuard_
}
;
template
<
typename
T
>
using
ResolveCallback
=
std
:
:
function
<
void
(
T
&
&
)
>
;
using
RejectCallback
=
std
:
:
function
<
void
(
ResponseRejectReason
)
>
;
enum
ChannelState
{
ChannelClosed
ChannelConnected
ChannelTimeout
ChannelClosing
ChannelError
}
;
class
AutoEnterTransaction
;
class
MessageChannel
:
HasResultCodes
{
friend
class
PortLink
;
#
ifdef
FUZZING
friend
class
ProtocolFuzzerHelper
;
#
endif
class
CxxStackFrame
;
class
InterruptFrame
;
typedef
mozilla
:
:
Monitor
Monitor
;
typedef
void
*
ActorIdType
;
public
:
struct
UntypedCallbackHolder
{
UntypedCallbackHolder
(
ActorIdType
aActorId
RejectCallback
&
&
aReject
)
:
mActorId
(
aActorId
)
mReject
(
std
:
:
move
(
aReject
)
)
{
}
virtual
~
UntypedCallbackHolder
(
)
=
default
;
void
Reject
(
ResponseRejectReason
&
&
aReason
)
{
mReject
(
std
:
:
move
(
aReason
)
)
;
}
ActorIdType
mActorId
;
RejectCallback
mReject
;
}
;
template
<
typename
Value
>
struct
CallbackHolder
:
public
UntypedCallbackHolder
{
CallbackHolder
(
ActorIdType
aActorId
ResolveCallback
<
Value
>
&
&
aResolve
RejectCallback
&
&
aReject
)
:
UntypedCallbackHolder
(
aActorId
std
:
:
move
(
aReject
)
)
mResolve
(
std
:
:
move
(
aResolve
)
)
{
}
void
Resolve
(
Value
&
&
aReason
)
{
mResolve
(
std
:
:
move
(
aReason
)
)
;
}
ResolveCallback
<
Value
>
mResolve
;
}
;
private
:
static
Atomic
<
size_t
>
gUnresolvedResponses
;
friend
class
PendingResponseReporter
;
public
:
static
constexpr
int32_t
kNoTimeout
=
INT32_MIN
;
typedef
IPC
:
:
Message
Message
;
typedef
IPC
:
:
MessageInfo
MessageInfo
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
using
ScopedPort
=
mozilla
:
:
ipc
:
:
ScopedPort
;
explicit
MessageChannel
(
const
char
*
aName
IToplevelProtocol
*
aListener
)
;
~
MessageChannel
(
)
;
IToplevelProtocol
*
Listener
(
)
const
{
return
mListener
;
}
bool
Open
(
ScopedPort
aPort
Side
aSide
nsISerialEventTarget
*
aEventTarget
=
nullptr
)
;
bool
Open
(
MessageChannel
*
aTargetChan
nsISerialEventTarget
*
aEventTarget
Side
aSide
)
;
bool
OpenOnSameThread
(
MessageChannel
*
aTargetChan
Side
aSide
)
;
void
NotifyImpendingShutdown
(
)
;
void
Close
(
)
;
void
CloseWithError
(
)
;
void
CloseWithTimeout
(
)
;
void
SetAbortOnError
(
bool
abort
)
{
mAbortOnError
=
abort
;
}
void
PeekMessages
(
const
std
:
:
function
<
bool
(
const
Message
&
aMsg
)
>
&
aInvoke
)
;
enum
ChannelFlags
{
REQUIRE_DEFAULT
=
0
REQUIRE_DEFERRED_MESSAGE_PROTECTION
=
1
<
<
0
REQUIRE_A11Y_REENTRY
=
1
<
<
1
}
;
void
SetChannelFlags
(
ChannelFlags
aFlags
)
{
mFlags
=
aFlags
;
}
ChannelFlags
GetChannelFlags
(
)
{
return
mFlags
;
}
bool
Send
(
UniquePtr
<
Message
>
aMsg
)
;
template
<
typename
Value
>
void
Send
(
UniquePtr
<
Message
>
aMsg
ActorIdType
aActorId
ResolveCallback
<
Value
>
&
&
aResolve
RejectCallback
&
&
aReject
)
{
int32_t
seqno
=
NextSeqno
(
)
;
aMsg
-
>
set_seqno
(
seqno
)
;
if
(
!
Send
(
std
:
:
move
(
aMsg
)
)
)
{
aReject
(
ResponseRejectReason
:
:
SendError
)
;
return
;
}
UniquePtr
<
UntypedCallbackHolder
>
callback
=
MakeUnique
<
CallbackHolder
<
Value
>
>
(
aActorId
std
:
:
move
(
aResolve
)
std
:
:
move
(
aReject
)
)
;
mPendingResponses
.
insert
(
std
:
:
make_pair
(
seqno
std
:
:
move
(
callback
)
)
)
;
gUnresolvedResponses
+
+
;
}
bool
SendBuildIDsMatchMessage
(
const
char
*
aParentBuildI
)
;
bool
DoBuildIDsMatch
(
)
{
return
mBuildIDsConfirmedMatch
;
}
bool
Send
(
UniquePtr
<
Message
>
aMsg
Message
*
aReply
)
;
bool
Call
(
UniquePtr
<
Message
>
aMsg
Message
*
aReply
)
;
bool
CanSend
(
)
const
;
UniquePtr
<
UntypedCallbackHolder
>
PopCallback
(
const
Message
&
aMsg
)
;
void
RejectPendingResponsesForActor
(
ActorIdType
aActorId
)
;
SyncSendError
LastSendError
(
)
const
{
AssertWorkerThread
(
)
;
return
mLastSendError
;
}
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
bool
IsOnCxxStack
(
)
const
{
return
!
mCxxStackFrames
.
empty
(
)
;
}
void
CancelCurrentTransaction
(
)
;
void
BeginPostponingSends
(
)
;
void
StopPostponingSends
(
)
;
bool
Unsound_IsClosed
(
)
const
{
return
mLink
?
mLink
-
>
Unsound_IsClosed
(
)
:
true
;
}
uint32_t
Unsound_NumQueuedMessages
(
)
const
{
return
mLink
?
mLink
-
>
Unsound_NumQueuedMessages
(
)
:
0
;
}
static
bool
IsPumpingMessages
(
)
{
return
sIsPumpingMessages
;
}
static
void
SetIsPumpingMessages
(
bool
aIsPumping
)
{
sIsPumpingMessages
=
aIsPumping
;
}
bool
IsCrossProcess
(
)
const
;
void
SetIsCrossProcess
(
bool
aIsCrossProcess
)
;
#
ifdef
OS_WIN
struct
MOZ_STACK_CLASS
SyncStackFrame
{
SyncStackFrame
(
MessageChannel
*
channel
bool
interrupt
)
;
~
SyncStackFrame
(
)
;
bool
mInterrupt
;
bool
mSpinNestedEvents
;
bool
mListenerNotified
;
MessageChannel
*
mChannel
;
SyncStackFrame
*
mPrev
;
SyncStackFrame
*
mStaticPrev
;
}
;
friend
struct
MessageChannel
:
:
SyncStackFrame
;
static
bool
IsSpinLoopActive
(
)
{
for
(
SyncStackFrame
*
frame
=
sStaticTopFrame
;
frame
;
frame
=
frame
-
>
mPrev
)
{
if
(
frame
-
>
mSpinNestedEvents
)
return
true
;
}
return
false
;
}
protected
:
SyncStackFrame
*
mTopFrame
=
nullptr
;
bool
mIsSyncWaitingOnNonMainThread
=
false
;
static
SyncStackFrame
*
sStaticTopFrame
;
public
:
void
ProcessNativeEventsInInterruptCall
(
)
;
static
void
NotifyGeckoEventDispatch
(
)
;
private
:
void
SpinInternalEventLoop
(
)
;
#
if
defined
(
ACCESSIBILITY
)
bool
WaitForSyncNotifyWithA11yReentry
(
)
;
#
endif
#
endif
private
:
void
PostErrorNotifyTask
(
)
;
void
OnNotifyMaybeChannelError
(
)
;
void
ReportConnectionError
(
const
char
*
aChannelName
Message
*
aMsg
=
nullptr
)
const
;
void
ReportMessageRouteError
(
const
char
*
channelName
)
const
;
bool
MaybeHandleError
(
Result
code
const
Message
&
aMsg
const
char
*
channelName
)
;
void
Clear
(
)
;
bool
InterruptEventOccurred
(
)
;
bool
HasPendingEvents
(
)
;
void
ProcessPendingRequests
(
AutoEnterTransaction
&
aTransaction
)
;
bool
ProcessPendingRequest
(
Message
&
&
aUrgent
)
;
void
MaybeUndeferIncall
(
)
;
void
EnqueuePendingMessages
(
)
;
void
DispatchMessage
(
Message
&
&
aMsg
)
;
void
DispatchSyncMessage
(
ActorLifecycleProxy
*
aProxy
const
Message
&
aMsg
Message
*
&
aReply
)
;
void
DispatchAsyncMessage
(
ActorLifecycleProxy
*
aProxy
const
Message
&
aMsg
)
;
void
DispatchInterruptMessage
(
ActorLifecycleProxy
*
aProxy
Message
&
&
aMsg
size_t
aStackDepth
)
;
bool
WaitForSyncNotify
(
bool
aHandleWindowsMessages
)
;
bool
WaitForInterruptNotify
(
)
;
bool
WaitResponse
(
bool
aWaitTimedOut
)
;
bool
ShouldContinueFromTimeout
(
)
;
void
EndTimeout
(
)
;
void
CancelTransaction
(
int
transaction
)
;
void
RepostAllMessages
(
)
;
size_t
RemoteViewOfStackDepth
(
size_t
stackDepth
)
const
{
AssertWorkerThread
(
)
;
return
stackDepth
-
mOutOfTurnReplies
.
size
(
)
;
}
int32_t
NextSeqno
(
)
{
AssertWorkerThread
(
)
;
return
(
mSide
=
=
ChildSide
)
?
-
-
mNextSeqno
:
+
+
mNextSeqno
;
}
void
EnteredCxxStack
(
)
;
void
ExitedCxxStack
(
)
;
void
EnteredCall
(
)
;
void
ExitedCall
(
)
;
void
EnteredSyncSend
(
)
;
void
ExitedSyncSend
(
)
;
void
DebugAbort
(
const
char
*
file
int
line
const
char
*
cond
const
char
*
why
bool
reply
=
false
)
;
void
DumpInterruptStack
(
const
char
*
const
pfx
=
"
"
)
const
;
void
AddProfilerMarker
(
const
IPC
:
:
Message
&
aMessage
MessageDirection
aDirection
)
;
private
:
size_t
InterruptStackDepth
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mInterruptStack
.
size
(
)
;
}
bool
AwaitingInterruptReply
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
!
mInterruptStack
.
empty
(
)
;
}
bool
DispatchingAsyncMessage
(
)
const
{
AssertWorkerThread
(
)
;
return
mDispatchingAsyncMessage
;
}
int
DispatchingAsyncMessageNestedLevel
(
)
const
{
AssertWorkerThread
(
)
;
return
mDispatchingAsyncMessageNestedLevel
;
}
bool
Connected
(
)
const
;
private
:
void
NotifyWorkerThread
(
)
;
bool
MaybeInterceptSpecialIOMessage
(
const
Message
&
aMsg
)
;
void
SynchronouslyClose
(
)
;
static
bool
IsAlwaysDeferred
(
const
Message
&
aMsg
)
;
void
SendMessageToLink
(
UniquePtr
<
Message
>
aMsg
)
;
bool
WasTransactionCanceled
(
int
transaction
)
;
bool
ShouldDeferMessage
(
const
Message
&
aMsg
)
;
bool
ShouldDeferInterruptMessage
(
const
Message
&
aMsg
size_t
aStackDepth
)
;
void
OnMessageReceivedFromLink
(
Message
&
&
aMsg
)
;
void
OnChannelErrorFromLink
(
)
;
private
:
void
NotifyChannelClosed
(
Maybe
<
MonitorAutoLock
>
&
aLock
)
;
void
NotifyMaybeChannelError
(
Maybe
<
MonitorAutoLock
>
&
aLock
)
;
private
:
void
AssertWorkerThread
(
)
const
{
MOZ_ASSERT
(
mWorkerThread
"
Channel
hasn
'
t
been
opened
yet
"
)
;
MOZ_RELEASE_ASSERT
(
mWorkerThread
&
&
mWorkerThread
-
>
IsOnCurrentThread
(
)
"
not
on
worker
thread
!
"
)
;
}
private
:
class
MessageTask
:
public
CancelableRunnable
public
LinkedListElement
<
RefPtr
<
MessageTask
>
>
public
nsIRunnablePriority
public
nsIRunnableIPCMessageType
{
public
:
explicit
MessageTask
(
MessageChannel
*
aChannel
Message
&
&
aMessage
)
;
MessageTask
(
)
=
delete
;
MessageTask
(
const
MessageTask
&
)
=
delete
;
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
Run
(
)
override
;
nsresult
Cancel
(
)
override
;
NS_IMETHOD
GetPriority
(
uint32_t
*
aPriority
)
override
;
NS_DECL_NSIRUNNABLEIPCMESSAGETYPE
void
Post
(
)
;
bool
IsScheduled
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mScheduled
;
}
Message
&
Msg
(
)
{
return
mMessage
;
}
const
Message
&
Msg
(
)
const
{
return
mMessage
;
}
private
:
~
MessageTask
(
)
=
default
;
MessageChannel
*
Channel
(
)
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
MOZ_RELEASE_ASSERT
(
isInList
(
)
)
;
return
mChannel
;
}
RefPtr
<
RefCountedMonitor
>
const
mMonitor
;
MessageChannel
*
const
mChannel
;
Message
mMessage
;
bool
mScheduled
:
1
;
}
;
bool
ShouldRunMessage
(
const
Message
&
aMsg
)
;
void
RunMessage
(
MessageTask
&
aTask
)
;
typedef
LinkedList
<
RefPtr
<
MessageTask
>
>
MessageQueue
;
typedef
std
:
:
map
<
size_t
Message
>
MessageMap
;
typedef
std
:
:
map
<
size_t
UniquePtr
<
UntypedCallbackHolder
>
>
CallbackMap
;
typedef
IPC
:
:
Message
:
:
msgid_t
msgid_t
;
private
:
const
char
*
const
mName
;
IToplevelProtocol
*
const
mListener
;
RefPtr
<
RefCountedMonitor
>
const
mMonitor
;
ChannelState
mChannelState
=
ChannelClosed
;
Side
mSide
=
UnknownSide
;
bool
mIsCrossProcess
=
false
;
UniquePtr
<
MessageLink
>
mLink
;
RefPtr
<
CancelableRunnable
>
mChannelErrorTask
;
nsCOMPtr
<
nsISerialEventTarget
>
mWorkerThread
;
int32_t
mTimeoutMs
=
kNoTimeout
;
bool
mInTimeoutSecondHalf
=
false
;
int32_t
mNextSeqno
=
0
;
static
bool
sIsPumpingMessages
;
SyncSendError
mLastSendError
=
SyncSendError
:
:
SendSuccess
;
template
<
class
T
>
class
AutoSetValue
{
public
:
explicit
AutoSetValue
(
T
&
var
const
T
&
newValue
)
:
mVar
(
var
)
mPrev
(
var
)
mNew
(
newValue
)
{
mVar
=
newValue
;
}
~
AutoSetValue
(
)
{
if
(
mVar
=
=
mNew
)
{
mVar
=
mPrev
;
}
}
private
:
T
&
mVar
;
T
mPrev
;
T
mNew
;
}
;
bool
mDispatchingAsyncMessage
=
false
;
int
mDispatchingAsyncMessageNestedLevel
=
0
;
friend
class
AutoEnterTransaction
;
AutoEnterTransaction
*
mTransactionStack
=
nullptr
;
int32_t
CurrentNestedInsideSyncTransaction
(
)
const
;
bool
AwaitingSyncReply
(
)
const
;
int
AwaitingSyncReplyNestedLevel
(
)
const
;
bool
DispatchingSyncMessage
(
)
const
;
int
DispatchingSyncMessageNestedLevel
(
)
const
;
#
ifdef
DEBUG
void
AssertMaybeDeferredCountCorrect
(
)
;
#
else
void
AssertMaybeDeferredCountCorrect
(
)
{
}
#
endif
int32_t
mTimedOutMessageSeqno
=
0
;
int
mTimedOutMessageNestedLevel
=
0
;
MessageQueue
mPending
;
size_t
mMaybeDeferredPendingCount
=
0
;
std
:
:
stack
<
MessageInfo
>
mInterruptStack
;
size_t
mRemoteStackDepthGuess
=
0
;
mozilla
:
:
Vector
<
InterruptFrame
>
mCxxStackFrames
;
bool
mSawInterruptOutMsg
=
false
;
MessageMap
mOutOfTurnReplies
;
CallbackMap
mPendingResponses
;
std
:
:
stack
<
Message
>
mDeferred
;
#
ifdef
OS_WIN
HANDLE
mEvent
;
#
endif
bool
mAbortOnError
=
false
;
bool
mNotifiedChannelDone
=
false
;
ChannelFlags
mFlags
=
REQUIRE_DEFAULT
;
bool
mIsPostponingSends
=
false
;
std
:
:
vector
<
UniquePtr
<
Message
>
>
mPostponedSends
;
bool
mBuildIDsConfirmedMatch
=
false
;
bool
mIsSameThreadChannel
=
false
;
}
;
void
CancelCPOWs
(
)
;
}
}
namespace
IPC
{
template
<
>
struct
ParamTraits
<
mozilla
:
:
ipc
:
:
ResponseRejectReason
>
:
public
ContiguousEnumSerializer
<
mozilla
:
:
ipc
:
:
ResponseRejectReason
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
SendError
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
EndGuard_
>
{
}
;
}
namespace
geckoprofiler
:
:
markers
{
struct
IPCMarker
{
static
constexpr
mozilla
:
:
Span
<
const
char
>
MarkerTypeName
(
)
{
return
mozilla
:
:
MakeStringSpan
(
"
IPC
"
)
;
}
static
void
StreamJSONMarkerData
(
mozilla
:
:
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
mozilla
:
:
TimeStamp
aStart
mozilla
:
:
TimeStamp
aEnd
int32_t
aOtherPid
int32_t
aMessageSeqno
IPC
:
:
Message
:
:
msgid_t
aMessageType
mozilla
:
:
ipc
:
:
Side
aSide
mozilla
:
:
ipc
:
:
MessageDirection
aDirection
mozilla
:
:
ipc
:
:
MessagePhase
aPhase
bool
aSync
)
{
using
namespace
mozilla
:
:
ipc
;
aWriter
.
TimeProperty
(
"
startTime
"
aStart
)
;
aWriter
.
TimeProperty
(
"
endTime
"
aEnd
)
;
aWriter
.
IntProperty
(
"
otherPid
"
aOtherPid
)
;
aWriter
.
IntProperty
(
"
messageSeqno
"
aMessageSeqno
)
;
aWriter
.
StringProperty
(
"
messageType
"
mozilla
:
:
MakeStringSpan
(
IPC
:
:
StringFromIPCMessageType
(
aMessageType
)
)
)
;
aWriter
.
StringProperty
(
"
side
"
IPCSideToString
(
aSide
)
)
;
aWriter
.
StringProperty
(
"
direction
"
aDirection
=
=
MessageDirection
:
:
eSending
?
mozilla
:
:
MakeStringSpan
(
"
sending
"
)
:
mozilla
:
:
MakeStringSpan
(
"
receiving
"
)
)
;
aWriter
.
StringProperty
(
"
phase
"
IPCPhaseToString
(
aPhase
)
)
;
aWriter
.
BoolProperty
(
"
sync
"
aSync
)
;
}
static
mozilla
:
:
MarkerSchema
MarkerTypeDisplay
(
)
{
return
mozilla
:
:
MarkerSchema
:
:
SpecialFrontendLocation
{
}
;
}
private
:
static
mozilla
:
:
Span
<
const
char
>
IPCSideToString
(
mozilla
:
:
ipc
:
:
Side
aSide
)
{
switch
(
aSide
)
{
case
mozilla
:
:
ipc
:
:
ParentSide
:
return
mozilla
:
:
MakeStringSpan
(
"
parent
"
)
;
case
mozilla
:
:
ipc
:
:
ChildSide
:
return
mozilla
:
:
MakeStringSpan
(
"
child
"
)
;
case
mozilla
:
:
ipc
:
:
UnknownSide
:
return
mozilla
:
:
MakeStringSpan
(
"
unknown
"
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
IPC
side
"
)
;
return
mozilla
:
:
MakeStringSpan
(
"
<
invalid
IPC
side
>
"
)
;
}
}
static
mozilla
:
:
Span
<
const
char
>
IPCPhaseToString
(
mozilla
:
:
ipc
:
:
MessagePhase
aPhase
)
{
switch
(
aPhase
)
{
case
mozilla
:
:
ipc
:
:
MessagePhase
:
:
Endpoint
:
return
mozilla
:
:
MakeStringSpan
(
"
endpoint
"
)
;
case
mozilla
:
:
ipc
:
:
MessagePhase
:
:
TransferStart
:
return
mozilla
:
:
MakeStringSpan
(
"
transferStart
"
)
;
case
mozilla
:
:
ipc
:
:
MessagePhase
:
:
TransferEnd
:
return
mozilla
:
:
MakeStringSpan
(
"
transferEnd
"
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
IPC
phase
"
)
;
return
mozilla
:
:
MakeStringSpan
(
"
<
invalid
IPC
phase
>
"
)
;
}
}
}
;
}
#
endif
