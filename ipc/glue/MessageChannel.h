#
ifndef
ipc_glue_MessageChannel_h
#
define
ipc_glue_MessageChannel_h
1
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
mozilla
/
Function
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
if
defined
(
OS_WIN
)
#
include
"
mozilla
/
ipc
/
Neutering
.
h
"
#
endif
#
include
"
mozilla
/
ipc
/
Transport
.
h
"
#
if
defined
(
MOZ_CRASHREPORTER
)
&
&
defined
(
OS_WIN
)
#
include
"
mozilla
/
mozalloc_oom
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
endif
#
include
"
MessageLink
.
h
"
#
include
<
deque
>
#
include
<
stack
>
#
include
<
math
.
h
>
namespace
mozilla
{
namespace
ipc
{
class
MessageChannel
;
class
RefCountedMonitor
:
public
Monitor
{
public
:
RefCountedMonitor
(
)
:
Monitor
(
"
mozilla
.
ipc
.
MessageChannel
.
mMonitor
"
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefCountedMonitor
)
private
:
~
RefCountedMonitor
(
)
{
}
}
;
enum
class
SyncSendError
{
SendSuccess
PreviousTimeout
SendingCPOWWhileDispatchingSync
SendingCPOWWhileDispatchingUrgent
NotConnectedBeforeSend
DisconnectedDuringSend
CancelledBeforeSend
CancelledAfterSend
TimedOut
ReplyError
}
;
class
AutoEnterTransaction
;
class
MessageChannel
:
HasResultCodes
{
friend
class
ProcessLink
;
friend
class
ThreadLink
;
class
CxxStackFrame
;
class
InterruptFrame
;
typedef
mozilla
:
:
Monitor
Monitor
;
public
:
static
const
int32_t
kNoTimeout
;
typedef
IPC
:
:
Message
Message
;
typedef
IPC
:
:
MessageInfo
MessageInfo
;
typedef
mozilla
:
:
ipc
:
:
Transport
Transport
;
explicit
MessageChannel
(
MessageListener
*
aListener
)
;
~
MessageChannel
(
)
;
bool
Open
(
Transport
*
aTransport
MessageLoop
*
aIOLoop
=
0
Side
aSide
=
UnknownSide
)
;
bool
Open
(
MessageChannel
*
aTargetChan
MessageLoop
*
aTargetLoop
Side
aSide
)
;
void
Close
(
)
;
void
CloseWithError
(
)
;
void
CloseWithTimeout
(
)
;
void
SetAbortOnError
(
bool
abort
)
{
mAbortOnError
=
abort
;
}
void
PeekMessages
(
mozilla
:
:
function
<
bool
(
const
Message
&
aMsg
)
>
aInvoke
)
;
enum
ChannelFlags
{
REQUIRE_DEFAULT
=
0
REQUIRE_DEFERRED_MESSAGE_PROTECTION
=
1
<
<
0
REQUIRE_A11Y_REENTRY
=
1
<
<
1
}
;
void
SetChannelFlags
(
ChannelFlags
aFlags
)
{
mFlags
=
aFlags
;
}
ChannelFlags
GetChannelFlags
(
)
{
return
mFlags
;
}
bool
Send
(
Message
*
aMsg
)
;
bool
Echo
(
Message
*
aMsg
)
;
bool
Send
(
Message
*
aMsg
Message
*
aReply
)
;
bool
Call
(
Message
*
aMsg
Message
*
aReply
)
;
bool
WaitForIncomingMessage
(
)
;
bool
CanSend
(
)
const
;
SyncSendError
LastSendError
(
)
const
{
AssertWorkerThread
(
)
;
return
mLastSendError
;
}
ChannelState
GetChannelState__TotallyRacy
(
)
const
{
return
mChannelState
;
}
void
SetReplyTimeoutMs
(
int32_t
aTimeoutMs
)
;
bool
IsOnCxxStack
(
)
const
{
return
!
mCxxStackFrames
.
empty
(
)
;
}
bool
IsInTransaction
(
)
const
;
void
CancelCurrentTransaction
(
)
;
int32_t
GetTopmostMessageRoutingId
(
)
const
;
void
FlushPendingInterruptQueue
(
)
;
bool
Unsound_IsClosed
(
)
const
{
return
mLink
?
mLink
-
>
Unsound_IsClosed
(
)
:
true
;
}
uint32_t
Unsound_NumQueuedMessages
(
)
const
{
return
mLink
?
mLink
-
>
Unsound_NumQueuedMessages
(
)
:
0
;
}
static
bool
IsPumpingMessages
(
)
{
return
sIsPumpingMessages
;
}
static
void
SetIsPumpingMessages
(
bool
aIsPumping
)
{
sIsPumpingMessages
=
aIsPumping
;
}
#
ifdef
OS_WIN
struct
MOZ_STACK_CLASS
SyncStackFrame
{
SyncStackFrame
(
MessageChannel
*
channel
bool
interrupt
)
;
~
SyncStackFrame
(
)
;
bool
mInterrupt
;
bool
mSpinNestedEvents
;
bool
mListenerNotified
;
MessageChannel
*
mChannel
;
SyncStackFrame
*
mPrev
;
SyncStackFrame
*
mStaticPrev
;
}
;
friend
struct
MessageChannel
:
:
SyncStackFrame
;
static
bool
IsSpinLoopActive
(
)
{
for
(
SyncStackFrame
*
frame
=
sStaticTopFrame
;
frame
;
frame
=
frame
-
>
mPrev
)
{
if
(
frame
-
>
mSpinNestedEvents
)
return
true
;
}
return
false
;
}
protected
:
SyncStackFrame
*
mTopFrame
;
bool
mIsSyncWaitingOnNonMainThread
;
static
SyncStackFrame
*
sStaticTopFrame
;
public
:
void
ProcessNativeEventsInInterruptCall
(
)
;
static
void
NotifyGeckoEventDispatch
(
)
;
private
:
void
SpinInternalEventLoop
(
)
;
#
if
defined
(
ACCESSIBILITY
)
bool
WaitForSyncNotifyWithA11yReentry
(
)
;
#
endif
#
endif
private
:
void
CommonThreadOpenInit
(
MessageChannel
*
aTargetChan
Side
aSide
)
;
void
OnOpenAsSlave
(
MessageChannel
*
aTargetChan
Side
aSide
)
;
void
PostErrorNotifyTask
(
)
;
void
OnNotifyMaybeChannelError
(
)
;
void
ReportConnectionError
(
const
char
*
aChannelName
Message
*
aMsg
=
nullptr
)
const
;
void
ReportMessageRouteError
(
const
char
*
channelName
)
const
;
bool
MaybeHandleError
(
Result
code
const
Message
&
aMsg
const
char
*
channelName
)
;
void
Clear
(
)
;
void
DispatchOnChannelConnected
(
)
;
bool
InterruptEventOccurred
(
)
;
bool
HasPendingEvents
(
)
;
void
ProcessPendingRequests
(
AutoEnterTransaction
&
aTransaction
)
;
bool
ProcessPendingRequest
(
Message
&
&
aUrgent
)
;
void
MaybeUndeferIncall
(
)
;
void
EnqueuePendingMessages
(
)
;
bool
OnMaybeDequeueOne
(
)
;
bool
DequeueOne
(
Message
*
recvd
)
;
void
DispatchMessage
(
Message
&
&
aMsg
)
;
void
DispatchSyncMessage
(
const
Message
&
aMsg
Message
*
&
aReply
)
;
void
DispatchUrgentMessage
(
const
Message
&
aMsg
)
;
void
DispatchAsyncMessage
(
const
Message
&
aMsg
)
;
void
DispatchRPCMessage
(
const
Message
&
aMsg
)
;
void
DispatchInterruptMessage
(
Message
&
&
aMsg
size_t
aStackDepth
)
;
bool
WaitForSyncNotify
(
bool
aHandleWindowsMessages
)
;
bool
WaitForInterruptNotify
(
)
;
bool
WaitResponse
(
bool
aWaitTimedOut
)
;
bool
ShouldContinueFromTimeout
(
)
;
void
EndTimeout
(
)
;
void
CancelTransaction
(
int
transaction
)
;
size_t
RemoteViewOfStackDepth
(
size_t
stackDepth
)
const
{
AssertWorkerThread
(
)
;
return
stackDepth
-
mOutOfTurnReplies
.
size
(
)
;
}
int32_t
NextSeqno
(
)
{
AssertWorkerThread
(
)
;
return
(
mSide
=
=
ChildSide
)
?
-
-
mNextSeqno
:
+
+
mNextSeqno
;
}
void
EnteredCxxStack
(
)
{
mListener
-
>
OnEnteredCxxStack
(
)
;
}
void
ExitedCxxStack
(
)
;
void
EnteredCall
(
)
{
mListener
-
>
OnEnteredCall
(
)
;
}
void
ExitedCall
(
)
{
mListener
-
>
OnExitedCall
(
)
;
}
void
EnteredSyncSend
(
)
{
mListener
-
>
OnEnteredSyncSend
(
)
;
}
void
ExitedSyncSend
(
)
{
mListener
-
>
OnExitedSyncSend
(
)
;
}
MessageListener
*
Listener
(
)
const
{
return
mListener
;
}
void
DebugAbort
(
const
char
*
file
int
line
const
char
*
cond
const
char
*
why
bool
reply
=
false
)
;
void
DumpInterruptStack
(
const
char
*
const
pfx
=
"
"
)
const
;
private
:
size_t
InterruptStackDepth
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mInterruptStack
.
size
(
)
;
}
bool
AwaitingInterruptReply
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
!
mInterruptStack
.
empty
(
)
;
}
bool
AwaitingIncomingMessage
(
)
const
{
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
return
mIsWaitingForIncoming
;
}
class
MOZ_STACK_CLASS
AutoEnterWaitForIncoming
{
public
:
explicit
AutoEnterWaitForIncoming
(
MessageChannel
&
aChannel
)
:
mChannel
(
aChannel
)
{
aChannel
.
mMonitor
-
>
AssertCurrentThreadOwns
(
)
;
aChannel
.
mIsWaitingForIncoming
=
true
;
}
~
AutoEnterWaitForIncoming
(
)
{
mChannel
.
mIsWaitingForIncoming
=
false
;
}
private
:
MessageChannel
&
mChannel
;
}
;
friend
class
AutoEnterWaitForIncoming
;
bool
DispatchingAsyncMessage
(
)
const
{
AssertWorkerThread
(
)
;
return
mDispatchingAsyncMessage
;
}
int
DispatchingAsyncMessageNestedLevel
(
)
const
{
AssertWorkerThread
(
)
;
return
mDispatchingAsyncMessageNestedLevel
;
}
bool
Connected
(
)
const
;
private
:
void
NotifyWorkerThread
(
)
;
bool
MaybeInterceptSpecialIOMessage
(
const
Message
&
aMsg
)
;
void
OnChannelConnected
(
int32_t
peer_id
)
;
void
SynchronouslyClose
(
)
;
bool
WasTransactionCanceled
(
int
transaction
)
;
bool
ShouldDeferMessage
(
const
Message
&
aMsg
)
;
void
OnMessageReceivedFromLink
(
Message
&
&
aMsg
)
;
void
OnChannelErrorFromLink
(
)
;
private
:
void
NotifyChannelClosed
(
)
;
void
NotifyMaybeChannelError
(
)
;
private
:
void
AssertWorkerThread
(
)
const
{
MOZ_RELEASE_ASSERT
(
mWorkerLoopID
=
=
MessageLoop
:
:
current
(
)
-
>
id
(
)
"
not
on
worker
thread
!
"
)
;
}
void
AssertLinkThread
(
)
const
{
MOZ_RELEASE_ASSERT
(
mWorkerLoopID
!
=
MessageLoop
:
:
current
(
)
-
>
id
(
)
"
on
worker
thread
but
should
not
be
!
"
)
;
}
private
:
#
if
defined
(
MOZ_CRASHREPORTER
)
&
&
defined
(
OS_WIN
)
template
<
class
T
>
struct
AnnotateAllocator
{
typedef
T
value_type
;
AnnotateAllocator
(
MessageChannel
&
channel
)
:
mChannel
(
channel
)
{
}
template
<
class
U
>
AnnotateAllocator
(
const
AnnotateAllocator
<
U
>
&
other
)
:
mChannel
(
other
.
mChannel
)
{
}
template
<
class
U
>
bool
operator
=
=
(
const
AnnotateAllocator
<
U
>
&
)
{
return
true
;
}
template
<
class
U
>
bool
operator
!
=
(
const
AnnotateAllocator
<
U
>
&
)
{
return
false
;
}
T
*
allocate
(
size_t
n
)
{
void
*
p
=
:
:
operator
new
(
n
*
sizeof
(
T
)
std
:
:
nothrow
)
;
if
(
!
p
&
&
n
)
{
MessageQueue
&
q
=
mChannel
.
mPending
;
std
:
:
sort
(
q
.
begin
(
)
q
.
end
(
)
[
]
(
const
Message
&
a
const
Message
&
b
)
{
return
a
.
type
(
)
<
b
.
type
(
)
;
}
)
;
const
char
*
topName
=
nullptr
;
const
char
*
curName
=
nullptr
;
msgid_t
topType
=
0
curType
=
0
;
uint32_t
topCount
=
0
curCount
=
0
;
for
(
MessageQueue
:
:
iterator
it
=
q
.
begin
(
)
;
it
!
=
q
.
end
(
)
;
+
+
it
)
{
Message
&
msg
=
*
it
;
if
(
msg
.
type
(
)
=
=
curType
)
{
+
+
curCount
;
}
else
{
if
(
curCount
>
topCount
)
{
topName
=
curName
;
topType
=
curType
;
topCount
=
curCount
;
}
curName
=
StringFromIPCMessageType
(
msg
.
type
(
)
)
;
curType
=
msg
.
type
(
)
;
curCount
=
1
;
}
}
if
(
curCount
>
topCount
)
{
topName
=
curName
;
topType
=
curType
;
topCount
=
curCount
;
}
CrashReporter
:
:
AnnotatePendingIPC
(
q
.
size
(
)
topCount
topName
topType
)
;
mozalloc_handle_oom
(
n
*
sizeof
(
T
)
)
;
}
return
static_cast
<
T
*
>
(
p
)
;
}
void
deallocate
(
T
*
p
size_t
n
)
{
:
:
operator
delete
(
p
)
;
}
MessageChannel
&
mChannel
;
}
;
typedef
std
:
:
deque
<
Message
AnnotateAllocator
<
Message
>
>
MessageQueue
;
#
else
typedef
std
:
:
deque
<
Message
>
MessageQueue
;
#
endif
typedef
std
:
:
map
<
size_t
Message
>
MessageMap
;
typedef
IPC
:
:
Message
:
:
msgid_t
msgid_t
;
class
RefCountedTask
{
public
:
explicit
RefCountedTask
(
already_AddRefed
<
CancelableRunnable
>
aTask
)
:
mTask
(
aTask
)
{
}
private
:
~
RefCountedTask
(
)
{
}
public
:
void
Run
(
)
{
mTask
-
>
Run
(
)
;
}
void
Cancel
(
)
{
mTask
-
>
Cancel
(
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefCountedTask
)
private
:
RefPtr
<
CancelableRunnable
>
mTask
;
}
;
class
DequeueTask
:
public
CancelableRunnable
{
public
:
explicit
DequeueTask
(
RefCountedTask
*
aTask
)
:
mTask
(
aTask
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mTask
)
{
mTask
-
>
Run
(
)
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mTask
=
nullptr
;
return
NS_OK
;
}
private
:
RefPtr
<
RefCountedTask
>
mTask
;
}
;
private
:
MessageListener
*
mListener
;
ChannelState
mChannelState
;
RefPtr
<
RefCountedMonitor
>
mMonitor
;
Side
mSide
;
MessageLink
*
mLink
;
MessageLoop
*
mWorkerLoop
;
RefPtr
<
CancelableRunnable
>
mChannelErrorTask
;
int
mWorkerLoopID
;
RefPtr
<
RefCountedTask
>
mDequeueOneTask
;
int32_t
mTimeoutMs
;
bool
mInTimeoutSecondHalf
;
int32_t
mNextSeqno
;
static
bool
sIsPumpingMessages
;
SyncSendError
mLastSendError
;
template
<
class
T
>
class
AutoSetValue
{
public
:
explicit
AutoSetValue
(
T
&
var
const
T
&
newValue
)
:
mVar
(
var
)
mPrev
(
var
)
mNew
(
newValue
)
{
mVar
=
newValue
;
}
~
AutoSetValue
(
)
{
if
(
mVar
=
=
mNew
)
{
mVar
=
mPrev
;
}
}
private
:
T
&
mVar
;
T
mPrev
;
T
mNew
;
}
;
bool
mDispatchingAsyncMessage
;
int
mDispatchingAsyncMessageNestedLevel
;
friend
class
AutoEnterTransaction
;
AutoEnterTransaction
*
mTransactionStack
;
int32_t
CurrentNestedInsideSyncTransaction
(
)
const
;
bool
AwaitingSyncReply
(
)
const
;
int
AwaitingSyncReplyNestedLevel
(
)
const
;
bool
DispatchingSyncMessage
(
)
const
;
int
DispatchingSyncMessageNestedLevel
(
)
const
;
int32_t
mTimedOutMessageSeqno
;
int
mTimedOutMessageNestedLevel
;
MessageQueue
mPending
;
std
:
:
stack
<
MessageInfo
>
mInterruptStack
;
size_t
mRemoteStackDepthGuess
;
mozilla
:
:
Vector
<
InterruptFrame
>
mCxxStackFrames
;
bool
mSawInterruptOutMsg
;
bool
mIsWaitingForIncoming
;
MessageMap
mOutOfTurnReplies
;
std
:
:
stack
<
Message
>
mDeferred
;
#
ifdef
OS_WIN
HANDLE
mEvent
;
#
endif
bool
mAbortOnError
;
bool
mNotifiedChannelDone
;
ChannelFlags
mFlags
;
RefPtr
<
CancelableRunnable
>
mOnChannelConnectedTask
;
bool
mPeerPidSet
;
int32_t
mPeerPid
;
}
;
void
CancelCPOWs
(
)
;
}
}
#
endif
