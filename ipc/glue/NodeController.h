#
ifndef
mozilla_ipc_NodeController_h
#
define
mozilla_ipc_NodeController_h
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
#
include
"
mojo
/
core
/
ports
/
name
.
h
"
#
include
"
mojo
/
core
/
ports
/
node
.
h
"
#
include
"
mojo
/
core
/
ports
/
node_delegate
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
NodeChannel
.
h
"
namespace
mozilla
:
:
ipc
{
class
GeckoChildProcessHost
;
class
NodeController
final
:
public
mojo
:
:
core
:
:
ports
:
:
NodeDelegate
public
NodeChannel
:
:
Listener
{
using
NodeName
=
mojo
:
:
core
:
:
ports
:
:
NodeName
;
using
PortName
=
mojo
:
:
core
:
:
ports
:
:
PortName
;
using
PortRef
=
mojo
:
:
core
:
:
ports
:
:
PortRef
;
using
Event
=
mojo
:
:
core
:
:
ports
:
:
Event
;
using
Node
=
mojo
:
:
core
:
:
ports
:
:
Node
;
using
UserData
=
mojo
:
:
core
:
:
ports
:
:
UserData
;
using
PortStatus
=
mojo
:
:
core
:
:
ports
:
:
PortStatus
;
using
UserMessageEvent
=
mojo
:
:
core
:
:
ports
:
:
UserMessageEvent
;
using
UserMessage
=
mojo
:
:
core
:
:
ports
:
:
UserMessage
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NodeController
override
)
static
NodeController
*
GetSingleton
(
)
;
class
PortObserver
:
public
UserData
{
public
:
virtual
void
OnPortStatusChanged
(
)
=
0
;
protected
:
~
PortObserver
(
)
override
=
default
;
}
;
static
constexpr
NodeName
kBrokerNodeName
{
0x1
0x1
}
;
bool
IsBroker
(
)
const
{
return
mName
=
=
kBrokerNodeName
;
}
std
:
:
pair
<
ScopedPort
ScopedPort
>
CreatePortPair
(
)
;
PortRef
GetPort
(
const
PortName
&
aName
)
;
void
SetPortObserver
(
const
PortRef
&
aPort
PortObserver
*
aObserver
)
;
Maybe
<
PortStatus
>
GetStatus
(
const
PortRef
&
aPort
)
;
void
ClosePort
(
const
PortRef
&
aPort
)
;
bool
SendUserMessage
(
const
PortRef
&
aPort
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
;
bool
GetMessage
(
const
PortRef
&
aPort
UniquePtr
<
IPC
:
:
Message
>
*
aMessage
)
;
std
:
:
tuple
<
ScopedPort
RefPtr
<
NodeChannel
>
>
InviteChildProcess
(
IPC
:
:
Channel
*
aChannel
GeckoChildProcessHost
*
aChildProcessHost
)
;
static
void
InitBrokerProcess
(
)
;
static
ScopedPort
InitChildProcess
(
IPC
:
:
Channel
*
aChannel
base
:
:
ProcessId
aParentPid
)
;
static
void
CleanUp
(
)
;
private
:
explicit
NodeController
(
const
NodeName
&
aName
)
;
~
NodeController
(
)
;
UniquePtr
<
IPC
:
:
Message
>
SerializeEventMessage
(
UniquePtr
<
Event
>
aEvent
const
NodeName
*
aRelayTarget
=
nullptr
uint32_t
aType
=
EVENT_MESSAGE_TYPE
)
;
UniquePtr
<
Event
>
DeserializeEventMessage
(
UniquePtr
<
IPC
:
:
Message
>
aMessage
NodeName
*
aRelayTarget
=
nullptr
)
;
already_AddRefed
<
NodeChannel
>
GetNodeChannel
(
const
NodeName
&
aName
)
;
void
DropPeer
(
NodeName
aNodeName
)
;
void
ContactRemotePeer
(
const
NodeName
&
aNode
UniquePtr
<
Event
>
aEvent
)
;
void
OnEventMessage
(
const
NodeName
&
aFromNode
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
override
;
void
OnBroadcast
(
const
NodeName
&
aFromNode
UniquePtr
<
IPC
:
:
Message
>
aMessage
)
override
;
void
OnIntroduce
(
const
NodeName
&
aFromNode
NodeChannel
:
:
Introduction
aIntroduction
)
override
;
void
OnRequestIntroduction
(
const
NodeName
&
aFromNode
const
NodeName
&
aName
)
override
;
void
OnAcceptInvite
(
const
NodeName
&
aFromNode
const
NodeName
&
aRealName
const
PortName
&
aInitialPort
)
override
;
void
OnChannelError
(
const
NodeName
&
aFromNode
)
override
;
void
ForwardEvent
(
const
NodeName
&
aNode
UniquePtr
<
Event
>
aEvent
)
override
;
void
BroadcastEvent
(
UniquePtr
<
Event
>
aEvent
)
override
;
void
PortStatusChanged
(
const
PortRef
&
aPortRef
)
override
;
void
ObserveRemoteNode
(
const
NodeName
&
aNode
)
override
;
const
NodeName
mName
;
const
UniquePtr
<
Node
>
mNode
;
template
<
class
T
>
using
NodeMap
=
nsTHashMap
<
NodeNameHashKey
T
>
;
struct
Invite
{
RefPtr
<
NodeChannel
>
mChannel
;
PortRef
mToMerge
;
}
;
struct
State
{
NodeMap
<
RefPtr
<
NodeChannel
>
>
mPeers
;
NodeMap
<
Queue
<
UniquePtr
<
IPC
:
:
Message
>
64
>
>
mPendingMessages
;
NodeMap
<
Invite
>
mInvites
;
NodeMap
<
nsTArray
<
PortRef
>
>
mPendingMerges
;
}
;
DataMutex
<
State
>
mState
{
"
NodeController
:
:
mState
"
}
;
}
;
}
#
endif
