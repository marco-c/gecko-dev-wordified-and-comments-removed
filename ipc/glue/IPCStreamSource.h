#
ifndef
mozilla_ipc_IPCStreamSource_h
#
define
mozilla_ipc_IPCStreamSource_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
bindings
/
WorkerHolder
.
h
"
class
nsIAsyncInputStream
;
namespace
mozilla
{
namespace
dom
{
class
nsIContentChild
;
class
nsIContentParent
;
}
namespace
ipc
{
class
PBackgroundChild
;
class
PBackgroundParent
;
class
IPCStreamSource
:
public
dom
:
:
workers
:
:
WorkerHolder
{
public
:
static
PChildToParentStreamChild
*
Create
(
nsIAsyncInputStream
*
aInputStream
dom
:
:
nsIContentChild
*
aManager
)
;
static
PChildToParentStreamChild
*
Create
(
nsIAsyncInputStream
*
aInputStream
PBackgroundChild
*
aManager
)
;
static
PParentToChildStreamParent
*
Create
(
nsIAsyncInputStream
*
aInputStream
dom
:
:
nsIContentParent
*
aManager
)
;
static
PParentToChildStreamParent
*
Create
(
nsIAsyncInputStream
*
aInputStream
PBackgroundParent
*
aManager
)
;
static
IPCStreamSource
*
Cast
(
PChildToParentStreamChild
*
aActor
)
;
static
IPCStreamSource
*
Cast
(
PParentToChildStreamParent
*
aActor
)
;
void
Start
(
)
;
void
StartDestroy
(
)
;
protected
:
IPCStreamSource
(
nsIAsyncInputStream
*
aInputStream
)
;
virtual
~
IPCStreamSource
(
)
;
bool
Initialize
(
)
;
void
ActorDestroyed
(
)
;
void
OnEnd
(
nsresult
aRv
)
;
virtual
void
Close
(
nsresult
aRv
)
=
0
;
virtual
void
SendData
(
const
nsCString
&
aBuffer
)
=
0
;
void
ActorConstructed
(
)
;
private
:
class
Callback
;
virtual
bool
Notify
(
dom
:
:
workers
:
:
Status
aStatus
)
override
;
enum
class
ReadReason
{
Starting
Notified
}
;
void
DoRead
(
ReadReason
aReadReason
)
;
void
Wait
(
)
;
void
OnStreamReady
(
Callback
*
aCallback
)
;
nsCOMPtr
<
nsIAsyncInputStream
>
mStream
;
RefPtr
<
Callback
>
mCallback
;
dom
:
:
workers
:
:
WorkerPrivate
*
mWorkerPrivate
;
#
ifdef
DEBUG
protected
:
#
endif
enum
{
ePending
eActorConstructed
eClosed
}
mState
;
private
:
NS_DECL_OWNINGTHREAD
}
;
}
}
#
endif
