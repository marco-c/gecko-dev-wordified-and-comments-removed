#
ifndef
mozilla_ipc_IPCStreamDestination_h
#
define
mozilla_ipc_IPCStreamDestination_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
class
nsIInputStream
;
class
nsIAsyncInputStream
;
class
nsIAsyncOutputStream
;
namespace
mozilla
{
namespace
wr
{
struct
ByteBuffer
;
}
namespace
ipc
{
class
PChildToParentStreamParent
;
class
PParentToChildStreamChild
;
class
IPCStreamDestination
{
public
:
static
IPCStreamDestination
*
Cast
(
PChildToParentStreamParent
*
aActor
)
;
static
IPCStreamDestination
*
Cast
(
PParentToChildStreamChild
*
aActor
)
;
void
SetDelayedStart
(
bool
aDelayedStart
)
;
void
SetLength
(
int64_t
aLength
)
;
already_AddRefed
<
nsIInputStream
>
TakeReader
(
)
;
bool
IsOnOwningThread
(
)
const
;
void
DispatchRunnable
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
protected
:
IPCStreamDestination
(
)
;
virtual
~
IPCStreamDestination
(
)
;
nsresult
Initialize
(
)
;
void
ActorDestroyed
(
)
;
void
BufferReceived
(
const
wr
:
:
ByteBuffer
&
aBuffer
)
;
void
CloseReceived
(
nsresult
aRv
)
;
#
ifdef
DEBUG
bool
HasDelayedStart
(
)
const
{
return
mDelayedStart
;
}
#
endif
virtual
void
StartReading
(
)
=
0
;
virtual
void
RequestClose
(
nsresult
aRv
)
=
0
;
virtual
void
TerminateDestination
(
)
=
0
;
private
:
nsCOMPtr
<
nsIAsyncInputStream
>
mReader
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mWriter
;
class
DelayedStartInputStream
;
RefPtr
<
DelayedStartInputStream
>
mDelayedStartInputStream
;
int64_t
mLength
=
-
1
;
nsCOMPtr
<
nsIThread
>
mOwningThread
;
bool
mDelayedStart
;
#
ifdef
MOZ_DEBUG
bool
mLengthSet
;
#
endif
}
;
}
}
#
endif
