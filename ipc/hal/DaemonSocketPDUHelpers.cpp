#
include
"
DaemonSocketPDUHelpers
.
h
"
#
include
<
limits
>
namespace
mozilla
{
namespace
ipc
{
namespace
DaemonSocketPDUHelpers
{
nsresult
Convert
(
bool
aIn
uint8_t
&
aOut
)
{
static
const
uint8_t
sValue
[
]
=
{
[
false
]
=
0x00
[
true
]
=
0x01
}
;
if
(
NS_WARN_IF
(
aIn
>
=
MOZ_ARRAY_LENGTH
(
sValue
)
)
)
{
aOut
=
0
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
sValue
[
aIn
]
;
return
NS_OK
;
}
nsresult
Convert
(
bool
aIn
int32_t
&
aOut
)
{
uint8_t
out
;
nsresult
rv
=
Convert
(
aIn
out
)
;
if
(
NS_FAILED
(
rv
)
)
{
out
=
0
;
return
rv
;
}
aOut
=
static_cast
<
int32_t
>
(
out
)
;
return
NS_OK
;
}
nsresult
Convert
(
int
aIn
uint8_t
&
aOut
)
{
if
(
NS_WARN_IF
(
aIn
<
std
:
:
numeric_limits
<
uint8_t
>
:
:
min
(
)
)
|
|
NS_WARN_IF
(
aIn
>
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
(
)
)
)
{
aOut
=
0
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
static_cast
<
uint8_t
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
int
aIn
int16_t
&
aOut
)
{
if
(
NS_WARN_IF
(
aIn
<
std
:
:
numeric_limits
<
int16_t
>
:
:
min
(
)
)
|
|
NS_WARN_IF
(
aIn
>
std
:
:
numeric_limits
<
int16_t
>
:
:
max
(
)
)
)
{
aOut
=
0
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
static_cast
<
int16_t
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
int
aIn
int32_t
&
aOut
)
{
if
(
NS_WARN_IF
(
aIn
<
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
)
|
|
NS_WARN_IF
(
aIn
>
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
)
{
aOut
=
0
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
static_cast
<
int32_t
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
uint8_t
aIn
bool
&
aOut
)
{
static
const
bool
sBool
[
]
=
{
[
0x00
]
=
false
[
0x01
]
=
true
}
;
if
(
NS_WARN_IF
(
aIn
>
=
MOZ_ARRAY_LENGTH
(
sBool
)
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
sBool
[
aIn
]
;
return
NS_OK
;
}
nsresult
Convert
(
uint8_t
aIn
char
&
aOut
)
{
aOut
=
static_cast
<
char
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
uint8_t
aIn
int
&
aOut
)
{
aOut
=
static_cast
<
int
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
uint8_t
aIn
unsigned
long
&
aOut
)
{
aOut
=
static_cast
<
unsigned
long
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
uint32_t
aIn
int
&
aOut
)
{
aOut
=
static_cast
<
int
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
uint32_t
aIn
uint8_t
&
aOut
)
{
if
(
NS_WARN_IF
(
aIn
<
std
:
:
numeric_limits
<
uint8_t
>
:
:
min
(
)
)
|
|
NS_WARN_IF
(
aIn
>
std
:
:
numeric_limits
<
uint8_t
>
:
:
max
(
)
)
)
{
aOut
=
0
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
static_cast
<
uint8_t
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
Convert
(
size_t
aIn
uint16_t
&
aOut
)
{
if
(
NS_WARN_IF
(
aIn
>
=
(
1ul
<
<
16
)
)
)
{
aOut
=
0
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
=
static_cast
<
uint16_t
>
(
aIn
)
;
return
NS_OK
;
}
nsresult
PackPDU
(
const
DaemonSocketPDUHeader
&
aIn
DaemonSocketPDU
&
aPDU
)
{
nsresult
rv
=
PackPDU
(
aIn
.
mService
aPDU
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
PackPDU
(
aIn
.
mOpcode
aPDU
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
PackPDU
(
aIn
.
mLength
aPDU
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
UnpackPDU
(
DaemonSocketPDU
&
aPDU
nsDependentCString
&
aOut
)
{
const
char
*
str
=
reinterpret_cast
<
const
char
*
>
(
aPDU
.
Consume
(
1
)
)
;
if
(
NS_WARN_IF
(
!
str
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
const
char
*
end
=
static_cast
<
char
*
>
(
memchr
(
str
'
\
0
'
aPDU
.
GetSize
(
)
+
1
)
)
;
if
(
NS_WARN_IF
(
!
end
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
ptrdiff_t
len
=
end
-
str
;
const
uint8_t
*
rest
=
aPDU
.
Consume
(
len
)
;
if
(
NS_WARN_IF
(
!
rest
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
.
Rebind
(
str
len
)
;
return
NS_OK
;
}
nsresult
UnpackPDU
(
DaemonSocketPDU
&
aPDU
const
UnpackCString0
&
aOut
)
{
nsDependentCString
cstring
;
nsresult
rv
=
UnpackPDU
(
aPDU
cstring
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
aOut
.
mString
-
>
AssignASCII
(
cstring
.
get
(
)
cstring
.
Length
(
)
)
;
return
NS_OK
;
}
nsresult
UnpackPDU
(
DaemonSocketPDU
&
aPDU
const
UnpackString0
&
aOut
)
{
nsDependentCString
cstring
;
nsresult
rv
=
UnpackPDU
(
aPDU
cstring
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
*
aOut
.
mString
=
NS_ConvertUTF8toUTF16
(
cstring
)
;
return
NS_OK
;
}
}
}
}
