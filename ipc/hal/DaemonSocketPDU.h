#
ifndef
mozilla_ipc_DaemonSocketPDU_h
#
define
mozilla_ipc_DaemonSocketPDU_h
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
ipc
/
SocketBase
.
h
"
#
include
"
mozilla
/
ipc
/
DaemonSocketMessageHandlers
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
ipc
{
static
const
size_t
MAX_NFDS
=
16
;
class
DaemonSocketIOConsumer
;
class
DaemonSocketPDU
final
:
public
UnixSocketIOBuffer
{
public
:
enum
{
PDU_OFF_SERVICE
=
0
PDU_OFF_OPCODE
=
1
PDU_OFF_LENGTH
=
2
PDU_OFF_PAYLOAD
=
4
PDU_HEADER_SIZE
=
PDU_OFF_PAYLOAD
PDU_MAX_PAYLOAD_LENGTH
=
1
<
<
16
}
;
DaemonSocketPDU
(
uint8_t
aService
uint8_t
aOpcode
uint16_t
aPayloadSize
)
;
DaemonSocketPDU
(
size_t
aPayloadSize
)
;
~
DaemonSocketPDU
(
)
;
void
SetConsumer
(
DaemonSocketIOConsumer
*
aConsumer
)
{
mConsumer
=
aConsumer
;
}
void
SetResultHandler
(
DaemonSocketResultHandler
*
aRes
)
{
mRes
=
aRes
;
}
DaemonSocketResultHandler
*
GetResultHandler
(
)
const
{
return
mRes
;
}
void
GetHeader
(
uint8_t
&
aService
uint8_t
&
aOpcode
uint16_t
&
aPayloadSize
)
;
ssize_t
Send
(
int
aFd
)
override
;
ssize_t
Receive
(
int
aFd
)
override
;
nsTArray
<
int
>
AcquireFds
(
)
;
nsresult
UpdateHeader
(
)
;
private
:
size_t
GetPayloadSize
(
)
const
;
void
OnError
(
const
char
*
aFunction
int
aErrno
)
;
DaemonSocketIOConsumer
*
mConsumer
;
RefPtr
<
DaemonSocketResultHandler
>
mRes
;
nsTArray
<
ScopedClose
>
mReceivedFds
;
}
;
}
}
#
endif
