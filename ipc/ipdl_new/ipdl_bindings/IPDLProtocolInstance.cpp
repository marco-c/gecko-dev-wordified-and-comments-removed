#
include
"
IPDLProtocolInstance
.
h
"
#
include
<
cfloat
>
#
include
"
IPCInterface
.
h
"
#
include
"
ipdl_ffi_generated
.
h
"
#
include
"
mozilla
/
dom
/
DOMMozPromiseRequestHolder
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
wrapper
.
h
"
#
include
"
mozilla
/
dom
/
IPDL
.
h
"
namespace
mozilla
{
namespace
ipdl
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
IPDLProtocolInstance
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
IPDLProtocolInstance
)
tmp
-
>
mInstanceObject
=
nullptr
;
tmp
-
>
mAsyncReturnOverride
=
nullptr
;
mozilla
:
:
DropJSObjects
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
IPDLProtocolInstance
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
IPDLProtocolInstance
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mInstanceObject
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mAsyncReturnOverride
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IPDLProtocolInstance
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IPDLProtocolInstance
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IPDLProtocolInstance
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
IPDLProtocolInstance
:
:
IPDLProtocolInstance
(
ipc
:
:
IPCInterface
*
aIPCInterface
uint32_t
aChannelId
IPDLProtocol
*
aIPDLProtocol
JS
:
:
HandleObject
aInstanceObject
)
:
mChannelId
(
aChannelId
)
mIPDLProtocol
(
aIPDLProtocol
)
mInstanceObject
(
aInstanceObject
)
mAsyncReturnOverride
(
nullptr
)
mConstructing
(
true
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
SetIPCInterface
(
aIPCInterface
)
;
}
IPDLProtocolInstance
:
:
~
IPDLProtocolInstance
(
)
{
mInstanceObject
=
nullptr
;
mAsyncReturnOverride
=
nullptr
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
void
IPDLProtocolInstance
:
:
SetIPCInterface
(
ipc
:
:
IPCInterface
*
aIPCInterface
)
{
mIPCInterface
=
aIPCInterface
;
if
(
mIPCInterface
)
{
mConstructing
=
false
;
NS_NAMED_LITERAL_CSTRING
(
parentSuffix
"
Parent
"
)
;
NS_NAMED_LITERAL_CSTRING
(
childSuffix
"
Child
"
)
;
mIPCInterface
-
>
SetIPDLInstance
(
mChannelId
mIPDLProtocol
-
>
GetProtocolName
(
)
+
(
mIPDLProtocol
-
>
GetSide
(
)
=
=
IPDLSide
:
:
Child
?
childSuffix
:
parentSuffix
)
this
)
;
}
}
bool
IPDLProtocolInstance
:
:
SendConstructor
(
JSContext
*
aCx
JS
:
:
HandleObject
aThisObj
const
nsCString
&
aFuncName
JS
:
:
CallArgs
aArgs
)
{
if
(
!
CheckIsAvailable
(
aCx
)
)
{
return
false
;
}
NS_NAMED_LITERAL_CSTRING
(
sendPrefix
"
send
"
)
;
NS_NAMED_LITERAL_CSTRING
(
constructorSuffix
"
Constructor
"
)
;
nsAutoCString
allocName
(
NS_LITERAL_CSTRING
(
"
alloc
"
)
)
;
allocName
.
Append
(
Substring
(
aFuncName
sendPrefix
.
Length
(
)
aFuncName
.
Length
(
)
-
sendPrefix
.
Length
(
)
-
constructorSuffix
.
Length
(
)
)
)
;
JS
:
:
HandleValueArray
argsArray
(
aArgs
)
;
JS
:
:
RootedValue
constructedValue
(
aCx
)
;
if
(
!
JS_CallFunctionName
(
aCx
aThisObj
allocName
.
get
(
)
argsArray
&
constructedValue
)
)
{
aArgs
.
rval
(
)
.
setUndefined
(
)
;
return
false
;
}
JS
:
:
RootedObject
constructedObject
(
aCx
&
constructedValue
.
toObject
(
)
)
;
auto
instance
=
static_cast
<
IPDLProtocolInstance
*
>
(
JS_GetPrivate
(
constructedObject
.
get
(
)
)
)
;
if
(
!
instance
)
{
JS_ReportErrorUTF8
(
aCx
"
Couldn
'
t
get
protocol
instance
object
from
private
date
field
"
)
;
return
false
;
}
instance
-
>
SetIPCInterface
(
mIPCInterface
)
;
JS
:
:
AutoValueVector
newArgsVec
(
aCx
)
;
if
(
!
newArgsVec
.
initCapacity
(
aArgs
.
length
(
)
+
3
)
)
{
JS_ReportErrorUTF8
(
aCx
"
Could
not
initialize
new
argument
vector
for
constructor
"
)
;
aArgs
.
rval
(
)
.
setUndefined
(
)
;
return
false
;
}
JS
:
:
CallArgs
newArgs
=
JS
:
:
CallArgsFromVp
(
aArgs
.
length
(
)
+
1
newArgsVec
.
begin
(
)
)
;
newArgs
.
setThis
(
aArgs
.
thisv
(
)
.
get
(
)
)
;
newArgs
.
setCallee
(
aArgs
.
calleev
(
)
.
get
(
)
)
;
JS
:
:
RootedValue
channelID
(
aCx
JS
:
:
NumberValue
(
instance
-
>
ChannelId
(
)
)
)
;
newArgs
[
0
]
.
set
(
channelID
)
;
for
(
unsigned
int
i
=
0
;
i
<
aArgs
.
length
(
)
;
i
+
+
)
{
newArgs
[
i
+
1
]
.
set
(
aArgs
[
i
]
)
;
}
bool
res
=
SendMessage
(
aCx
aFuncName
newArgs
constructedObject
)
;
aArgs
.
rval
(
)
.
set
(
newArgs
.
rval
(
)
)
;
return
res
;
}
bool
IPDLProtocolInstance
:
:
SendDelete
(
JSContext
*
aCx
const
nsCString
&
aFuncName
JS
:
:
CallArgs
aArgs
)
{
if
(
!
CheckIsAvailable
(
aCx
)
)
{
return
false
;
}
bool
res
=
SendMessage
(
aCx
aFuncName
aArgs
)
;
return
res
;
}
bool
IPDLProtocolInstance
:
:
SendMessage
(
JSContext
*
aCx
const
nsCString
&
aFuncName
JS
:
:
CallArgs
aArgs
JS
:
:
HandleObject
aReturnOverride
)
{
if
(
!
CheckIsAvailable
(
aCx
)
)
{
return
false
;
}
auto
message
=
mIPDLProtocol
-
>
GetMessageDecl
(
aFuncName
)
;
MOZ_ASSERT
(
message
)
;
auto
&
inParams
=
message
-
>
in_params
;
auto
expectedArgCount
=
inParams
.
Length
(
)
;
if
(
!
aArgs
.
requireAtLeast
(
aCx
aFuncName
.
get
(
)
expectedArgCount
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
inParams
.
Length
(
)
;
i
+
+
)
{
if
(
!
mIPDLProtocol
-
>
CheckParamTypeSpec
(
aCx
aArgs
.
get
(
i
)
inParams
.
ElementAt
(
i
)
)
)
{
JS_ReportErrorUTF8
(
aCx
"
Type
mismatch
on
%
zuth
argument
of
%
s
:
expected
%
s
got
%
s
"
i
aFuncName
.
get
(
)
IPDLProtocol
:
:
JoinQualifiedId
(
inParams
.
ElementAt
(
i
)
.
type_spec
.
spec
)
.
get
(
)
InformalValueTypeName
(
aArgs
.
get
(
i
)
)
)
;
aArgs
.
rval
(
)
.
setUndefined
(
)
;
return
false
;
}
}
NS_NAMED_LITERAL_CSTRING
(
sendPrefix
"
send
"
)
;
nsAutoCString
messageName
(
Substring
(
aFuncName
sendPrefix
.
Length
(
)
aFuncName
.
Length
(
)
-
sendPrefix
.
Length
(
)
)
)
;
auto
argArray
=
JS
:
:
HandleValueArray
(
aArgs
)
;
JS
:
:
RootedValue
retVal
(
aCx
)
;
bool
ret
;
switch
(
message
-
>
send_semantics
)
{
case
ffi
:
:
SendSemantics
:
:
Async
:
retVal
=
SendAsyncMessage
(
aCx
messageName
argArray
aReturnOverride
)
;
ret
=
true
;
break
;
case
ffi
:
:
SendSemantics
:
:
Sync
:
ret
=
SendSyncMessage
(
aCx
messageName
argArray
&
retVal
)
;
if
(
aReturnOverride
.
get
(
)
)
{
retVal
.
setObject
(
*
aReturnOverride
)
;
}
break
;
case
ffi
:
:
SendSemantics
:
:
Intr
:
ret
=
SendIntrMessage
(
aCx
messageName
argArray
&
retVal
)
;
if
(
aReturnOverride
.
get
(
)
)
{
retVal
.
setObject
(
*
aReturnOverride
)
;
}
break
;
}
aArgs
.
rval
(
)
.
set
(
retVal
)
;
return
ret
;
}
JS
:
:
Value
IPDLProtocolInstance
:
:
SendAsyncMessage
(
JSContext
*
aCx
const
nsCString
&
aFuncName
const
JS
:
:
HandleValueArray
&
aArgArray
JS
:
:
HandleObject
aReturnOverride
)
{
ErrorResult
aRv
;
RefPtr
<
dom
:
:
Promise
>
outer
=
dom
:
:
Promise
:
:
Create
(
mIPDLProtocol
-
>
GetGlobal
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
auto
promiseHolder
=
MakeRefPtr
<
dom
:
:
DOMMozPromiseRequestHolder
<
ipc
:
:
IPCInterface
:
:
AsyncMessagePromise
>
>
(
mIPDLProtocol
-
>
GetGlobal
(
)
)
;
bool
hasReturnOverride
=
(
aReturnOverride
.
get
(
)
)
;
mAsyncReturnOverride
=
aReturnOverride
;
mIPCInterface
-
>
SendAsyncMessage
(
aCx
mIPDLProtocol
-
>
GetProtocolName
(
)
mChannelId
aFuncName
aArgArray
)
-
>
Then
(
mIPDLProtocol
-
>
GetGlobal
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
__func__
[
&
asyncReturnOverride
=
mAsyncReturnOverride
promiseHolder
outer
hasReturnOverride
]
(
const
JS
:
:
Value
&
aResult
)
{
promiseHolder
-
>
Complete
(
)
;
nsIGlobalObject
*
global
=
promiseHolder
-
>
GetParentObject
(
)
;
NS_ENSURE_TRUE_VOID
(
global
)
;
if
(
hasReturnOverride
)
{
outer
-
>
MaybeResolve
(
JS
:
:
ObjectValue
(
*
asyncReturnOverride
)
)
;
asyncReturnOverride
=
nullptr
;
}
else
{
outer
-
>
MaybeResolve
(
aResult
)
;
}
}
[
promiseHolder
outer
aCx
]
(
nsCString
aRv
)
{
promiseHolder
-
>
Complete
(
)
;
JS
:
:
RootedValue
retVal
(
aCx
JS
:
:
StringValue
(
JS_NewStringCopyZ
(
aCx
aRv
.
get
(
)
)
)
)
;
outer
-
>
MaybeReject
(
aCx
retVal
)
;
}
)
-
>
Track
(
*
promiseHolder
)
;
JS
:
:
RootedObject
retObj
(
aCx
outer
-
>
PromiseObj
(
)
)
;
return
JS
:
:
ObjectValue
(
*
retObj
)
;
}
bool
IPDLProtocolInstance
:
:
SendSyncMessage
(
JSContext
*
aCx
const
nsCString
&
aFuncName
const
JS
:
:
HandleValueArray
&
aArgArray
JS
:
:
MutableHandleValue
aRet
)
{
return
mIPCInterface
-
>
SendSyncMessage
(
aCx
mIPDLProtocol
-
>
GetProtocolName
(
)
mChannelId
aFuncName
aArgArray
aRet
)
;
}
bool
IPDLProtocolInstance
:
:
SendIntrMessage
(
JSContext
*
aCx
const
nsCString
&
aFuncName
const
JS
:
:
HandleValueArray
&
aArgArray
JS
:
:
MutableHandleValue
aRet
)
{
return
mIPCInterface
-
>
SendIntrMessage
(
aCx
mIPDLProtocol
-
>
GetProtocolName
(
)
mChannelId
aFuncName
aArgArray
aRet
)
;
}
bool
IPDLProtocolInstance
:
:
RecvMessage
(
JSContext
*
aCx
const
nsCString
&
aMessageName
const
JS
:
:
HandleValueArray
&
aArgArray
JS
:
:
MutableHandleValue
aRet
)
{
if
(
!
CheckIsAvailable
(
aCx
)
)
{
return
false
;
}
const
nsAutoCString
&
funcName
=
NS_LITERAL_CSTRING
(
"
recv
"
)
+
aMessageName
;
JS
:
:
RootedValue
prop
(
aCx
)
;
NS_NAMED_LITERAL_CSTRING
(
constructorSuffix
"
Constructor
"
)
;
if
(
aMessageName
.
RFind
(
constructorSuffix
.
get
(
)
false
-
1
constructorSuffix
.
Length
(
)
)
!
=
kNotFound
)
{
nsAutoCString
protocolName
(
Substring
(
aMessageName
0
aMessageName
.
Length
(
)
-
constructorSuffix
.
Length
(
)
)
)
;
nsAutoCString
allocName
(
protocolName
)
;
allocName
.
InsertLiteral
(
"
alloc
"
0
)
;
JS
:
:
RootedValue
allocatedProtocolValue
(
aCx
)
;
JS
:
:
RootedObject
objectInstance
(
aCx
mInstanceObject
)
;
JS_CallFunctionName
(
aCx
objectInstance
allocName
.
get
(
)
JS
:
:
HandleValueArray
:
:
subarray
(
aArgArray
1
aArgArray
.
length
(
)
-
1
)
&
allocatedProtocolValue
)
;
JS
:
:
RootedObject
allocatedProtocol
(
aCx
&
allocatedProtocolValue
.
toObject
(
)
)
;
auto
instance
=
static_cast
<
IPDLProtocolInstance
*
>
(
JS_GetPrivate
(
allocatedProtocol
.
get
(
)
)
)
;
if
(
!
instance
)
{
JS_ReportErrorUTF8
(
aCx
"
Couldn
'
t
get
protocol
instance
object
from
private
date
field
"
)
;
return
false
;
}
instance
-
>
SetIPCInterface
(
mIPCInterface
)
;
nsAutoCString
constructorName
(
protocolName
)
;
constructorName
.
InsertLiteral
(
"
recv
"
0
)
;
constructorName
.
AppendLiteral
(
"
Constructor
"
)
;
JS
:
:
RootedValue
unusedResult
(
aCx
)
;
JS_CallFunctionName
(
aCx
objectInstance
constructorName
.
get
(
)
JS
:
:
HandleValueArray
(
allocatedProtocolValue
)
&
unusedResult
)
;
return
true
;
}
JS
:
:
RootedObject
objInstance
(
aCx
mInstanceObject
)
;
if
(
!
JS_GetProperty
(
aCx
objInstance
funcName
.
get
(
)
&
prop
)
)
{
aRet
.
setUndefined
(
)
;
return
false
;
}
if
(
!
JS_CallFunctionValue
(
aCx
objInstance
prop
aArgArray
aRet
)
)
{
aRet
.
setUndefined
(
)
;
return
false
;
}
if
(
aMessageName
.
Equals
(
"
__delete__
"
)
)
{
aRet
.
setUndefined
(
)
;
JS_SetPrivate
(
mInstanceObject
nullptr
)
;
mIPCInterface
-
>
RemoveIPDLInstance
(
mChannelId
mIPDLProtocol
-
>
GetProtocolName
(
)
)
;
mIPDLProtocol
-
>
RemoveInstance
(
this
)
;
}
return
true
;
}
JSObject
*
IPDLProtocolInstance
:
:
GetInstanceObject
(
)
{
return
mInstanceObject
;
}
}
}
