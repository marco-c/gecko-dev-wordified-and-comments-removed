#
include
"
IPDLProtocol
.
h
"
#
include
<
cfloat
>
#
include
"
ipdl_ffi_generated
.
h
"
#
include
"
mozilla
/
dom
/
DOMMozPromiseRequestHolder
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
wrapper
.
h
"
#
include
"
mozilla
/
dom
/
IPDL
.
h
"
#
include
"
IPCInterface
.
h
"
#
include
"
IPDLProtocolInstance
.
h
"
namespace
mozilla
{
namespace
ipdl
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
IPDLProtocol
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
IPDLProtocol
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mInstances
)
tmp
-
>
mProtoObj
=
nullptr
;
tmp
-
>
mConstructorObj
=
nullptr
;
mozilla
:
:
DropJSObjects
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
IPDLProtocol
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInstances
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
IPDLProtocol
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mProtoObj
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mConstructorObj
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IPDLProtocol
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IPDLProtocol
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IPDLProtocol
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
IPDLProtocol
:
:
ASTDeletePolicy
:
:
operator
(
)
(
const
mozilla
:
:
ipdl
:
:
ffi
:
:
AST
*
aASTPtr
)
{
if
(
!
aASTPtr
)
{
return
;
}
wrapper
:
:
FreeAST
(
aASTPtr
)
;
}
IPDLProtocol
:
:
IPDLProtocol
(
dom
:
:
IPDL
*
aIPDL
IPDLSide
aSide
const
nsACString
&
aIPDLFile
nsIGlobalObject
*
aGlobal
JS
:
:
HandleObject
aParent
JSContext
*
aCx
)
:
mSide
(
aSide
)
mGlobal
(
aGlobal
)
mIPDL
(
aIPDL
)
mNextProtocolInstanceChannelId
(
0
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
nsCString
errorString
;
mAST
.
reset
(
wrapper
:
:
Parse
(
aIPDLFile
errorString
)
)
;
if
(
!
mAST
)
{
JS_ReportErrorUTF8
(
aCx
"
IPDL
:
%
s
"
errorString
.
get
(
)
)
;
return
;
}
auto
mainTU
=
GetMainTU
(
)
;
MOZ_ASSERT
(
mainTU
-
>
protocol
"
should
have
a
protocol
in
protocol
file
"
)
;
mProtocolName
=
JoinNamespace
(
mainTU
-
>
protocol
-
>
ns
)
;
auto
&
manages
=
mainTU
-
>
protocol
-
>
protocol
.
manages
;
auto
&
messages
=
mainTU
-
>
protocol
-
>
protocol
.
messages
;
NS_NAMED_LITERAL_CSTRING
(
sendPrefix
"
send
"
)
;
NS_NAMED_LITERAL_CSTRING
(
recvPrefix
"
recv
"
)
;
NS_NAMED_LITERAL_CSTRING
(
allocPrefix
"
alloc
"
)
;
NS_NAMED_LITERAL_CSTRING
(
constructorSuffix
"
Constructor
"
)
;
nsTHashtable
<
nsCStringHashKey
>
managedProtocols
;
for
(
auto
&
managedProtocol
:
manages
)
{
managedProtocols
.
PutEntry
(
managedProtocol
.
id
)
;
}
nsTArray
<
JSFunctionSpec
>
funcs
;
nsTArray
<
nsCString
>
functionNames
;
for
(
auto
&
message
:
messages
)
{
if
(
(
message
.
direction
=
=
ffi
:
:
Direction
:
:
ToChild
&
&
mSide
=
=
IPDLSide
:
:
Parent
)
|
|
(
message
.
direction
=
=
ffi
:
:
Direction
:
:
ToParent
&
&
mSide
=
=
IPDLSide
:
:
Child
)
|
|
message
.
direction
=
=
ffi
:
:
Direction
:
:
ToParentOrChild
)
{
if
(
managedProtocols
.
Contains
(
message
.
name
.
id
)
)
{
const
nsAutoCString
&
constructorName
=
sendPrefix
+
message
.
name
.
id
+
constructorSuffix
;
functionNames
.
AppendElement
(
constructorName
)
;
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FN
(
functionNames
.
LastElement
(
)
.
get
(
)
SendConstructorDispatch
static_cast
<
uint16_t
>
(
message
.
in_params
.
Length
(
)
)
0
)
)
;
mMessageTable
.
Put
(
constructorName
&
message
)
;
const
nsAutoCString
&
allocName
=
allocPrefix
+
message
.
name
.
id
;
functionNames
.
AppendElement
(
allocName
)
;
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FN
(
functionNames
.
LastElement
(
)
.
get
(
)
AbstractAlloc
static_cast
<
uint16_t
>
(
message
.
in_params
.
Length
(
)
)
0
)
)
;
mMessageTable
.
Put
(
allocName
&
message
)
;
}
else
{
const
nsAutoCString
&
funcName
=
sendPrefix
+
message
.
name
.
id
;
functionNames
.
AppendElement
(
funcName
)
;
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FN
(
functionNames
.
LastElement
(
)
.
get
(
)
message
.
name
.
id
.
Equals
(
"
__delete__
"
)
?
SendDeleteDispatch
:
SendMessageDispatch
static_cast
<
uint16_t
>
(
message
.
in_params
.
Length
(
)
)
0
)
)
;
mMessageTable
.
Put
(
funcName
&
message
)
;
}
}
if
(
(
message
.
direction
=
=
ffi
:
:
Direction
:
:
ToChild
&
&
mSide
=
=
IPDLSide
:
:
Child
)
|
|
(
message
.
direction
=
=
ffi
:
:
Direction
:
:
ToParent
&
&
mSide
=
=
IPDLSide
:
:
Parent
)
|
|
message
.
direction
=
=
ffi
:
:
Direction
:
:
ToParentOrChild
)
{
if
(
managedProtocols
.
Contains
(
message
.
name
.
id
)
)
{
const
nsAutoCString
&
constructorName
=
recvPrefix
+
message
.
name
.
id
+
constructorSuffix
;
functionNames
.
AppendElement
(
constructorName
)
;
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FN
(
functionNames
.
LastElement
(
)
.
get
(
)
RecvConstructor
static_cast
<
uint16_t
>
(
message
.
in_params
.
Length
(
)
)
0
)
)
;
mMessageTable
.
Put
(
constructorName
&
message
)
;
const
nsAutoCString
&
allocName
=
allocPrefix
+
message
.
name
.
id
;
functionNames
.
AppendElement
(
allocName
)
;
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FN
(
functionNames
.
LastElement
(
)
.
get
(
)
AbstractAlloc
static_cast
<
uint16_t
>
(
message
.
in_params
.
Length
(
)
)
0
)
)
;
mMessageTable
.
Put
(
allocName
&
message
)
;
}
else
{
const
nsAutoCString
&
funcName
=
recvPrefix
+
message
.
name
.
id
;
functionNames
.
AppendElement
(
funcName
)
;
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FN
(
functionNames
.
LastElement
(
)
.
get
(
)
message
.
name
.
id
.
Equals
(
"
__delete__
"
)
?
RecvDelete
:
AbstractRecvMessage
static_cast
<
uint16_t
>
(
message
.
in_params
.
Length
(
)
)
0
)
)
;
mMessageTable
.
Put
(
funcName
&
message
)
;
}
}
}
funcs
.
AppendElement
<
JSFunctionSpec
>
(
JS_FS_END
)
;
mSidedProtocolName
=
GetSidedProtocolName
(
mProtocolName
mSide
)
;
mProtocolClass
=
{
mSidedProtocolName
.
get
(
)
JSCLASS_HAS_PRIVATE
&
sIPDLJSClassOps
}
;
JS
:
:
RootedObject
parentProto
(
aCx
)
;
JS_GetClassPrototype
(
aCx
JSProto_Object
&
parentProto
)
;
mProtoObj
=
JS_InitClass
(
aCx
aParent
parentProto
&
mProtocolClass
Constructor
0
nullptr
funcs
.
Elements
(
)
nullptr
nullptr
)
;
JS
:
:
RootedObject
protoObj
(
aCx
mProtoObj
)
;
JS_SetPrivate
(
protoObj
this
)
;
mConstructorObj
=
JS_GetConstructor
(
aCx
protoObj
)
;
BuildNameLookupTables
(
)
;
}
nsCString
IPDLProtocol
:
:
GetProtocolName
(
)
{
return
mProtocolName
;
}
JSObject
*
IPDLProtocol
:
:
GetProtocolClassConstructor
(
)
{
return
mConstructorObj
.
get
(
)
;
}
uint32_t
IPDLProtocol
:
:
RegisterExternalInstance
(
)
{
auto
childID
=
mNextProtocolInstanceChannelId
+
+
;
return
childID
;
}
JSClass
&
IPDLProtocol
:
:
GetProtocolClass
(
)
{
return
mProtocolClass
;
}
const
ffi
:
:
TranslationUnit
*
IPDLProtocol
:
:
GetMainTU
(
)
{
return
wrapper
:
:
GetTU
(
mAST
.
get
(
)
wrapper
:
:
GetMainTUId
(
mAST
.
get
(
)
)
)
;
}
void
IPDLProtocol
:
:
BuildNameLookupTables
(
)
{
nsTHashtable
<
nsUint32HashKey
>
visitedTUId
;
nsTArray
<
ffi
:
:
TUId
>
workList
;
const
ffi
:
:
TranslationUnit
*
currentTU
=
nullptr
;
ffi
:
:
TUId
currentTUId
=
-
1
;
ffi
:
:
TUId
mainTUId
=
wrapper
:
:
GetMainTUId
(
mAST
.
get
(
)
)
;
workList
.
AppendElement
(
mainTUId
)
;
while
(
!
workList
.
IsEmpty
(
)
)
{
currentTUId
=
workList
.
PopLastElement
(
)
;
currentTU
=
wrapper
:
:
GetTU
(
mAST
.
get
(
)
currentTUId
)
;
if
(
currentTU
-
>
file_type
=
=
ffi
:
:
FileType
:
:
Protocol
)
{
if
(
currentTU
-
>
protocol
)
{
mProtocolTable
.
Put
(
JoinNamespace
(
currentTU
-
>
protocol
-
>
ns
)
currentTU
-
>
protocol
.
ptr
(
)
)
;
}
}
if
(
currentTU
-
>
file_type
=
=
ffi
:
:
FileType
:
:
Header
|
|
currentTUId
=
=
mainTUId
)
{
for
(
size_t
i
=
0
;
i
<
currentTU
-
>
structs
.
Length
(
)
;
i
+
+
)
{
const
auto
*
s
=
currentTU
-
>
structs
.
Elements
(
)
+
i
;
mStructTable
.
Put
(
JoinNamespace
(
s
-
>
ns
)
s
)
;
}
for
(
size_t
i
=
0
;
i
<
currentTU
-
>
unions
.
Length
(
)
;
i
+
+
)
{
const
auto
*
u
=
currentTU
-
>
unions
.
Elements
(
)
+
i
;
mUnionTable
.
Put
(
JoinNamespace
(
u
-
>
ns
)
u
)
;
}
workList
.
AppendElements
(
currentTU
-
>
includes
)
;
}
}
}
bool
IPDLProtocol
:
:
SendMessageDispatch
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
auto
args
=
JS
:
:
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
RootedObject
thisObj
(
aCx
)
;
args
.
computeThis
(
aCx
&
thisObj
)
;
auto
*
instance
=
static_cast
<
IPDLProtocolInstance
*
>
(
JS_GetPrivate
(
thisObj
)
)
;
if
(
!
instance
)
{
JS_ReportErrorUTF8
(
aCx
"
Cannot
use
deleted
protocol
"
)
;
return
false
;
}
auto
function
=
JS_GetObjectFunction
(
&
args
.
callee
(
)
)
;
nsAutoJSString
functionName
;
if
(
!
functionName
.
init
(
aCx
JS_GetFunctionId
(
function
)
)
)
{
return
false
;
}
return
instance
-
>
SendMessage
(
aCx
NS_ConvertUTF16toUTF8
(
functionName
)
args
)
;
}
bool
IPDLProtocol
:
:
SendConstructorDispatch
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
auto
args
=
JS
:
:
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
RootedObject
thisObj
(
aCx
)
;
args
.
computeThis
(
aCx
&
thisObj
)
;
auto
*
instance
=
static_cast
<
IPDLProtocolInstance
*
>
(
JS_GetPrivate
(
thisObj
)
)
;
if
(
!
instance
)
{
JS_ReportErrorUTF8
(
aCx
"
Cannot
use
deleted
protocol
"
)
;
return
false
;
}
auto
function
=
JS_GetObjectFunction
(
&
args
.
callee
(
)
)
;
nsAutoJSString
functionName
;
if
(
!
functionName
.
init
(
aCx
JS_GetFunctionId
(
function
)
)
)
{
return
false
;
}
return
instance
-
>
SendConstructor
(
aCx
thisObj
NS_ConvertUTF16toUTF8
(
functionName
)
args
)
;
}
bool
IPDLProtocol
:
:
SendDeleteDispatch
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
auto
args
=
JS
:
:
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
RootedObject
thisObj
(
aCx
)
;
args
.
computeThis
(
aCx
&
thisObj
)
;
auto
*
instance
=
static_cast
<
IPDLProtocolInstance
*
>
(
JS_GetPrivate
(
thisObj
)
)
;
if
(
!
instance
)
{
JS_ReportErrorUTF8
(
aCx
"
Cannot
use
deleted
protocol
"
)
;
return
false
;
}
auto
function
=
JS_GetObjectFunction
(
&
args
.
callee
(
)
)
;
nsAutoJSString
functionName
;
if
(
!
functionName
.
init
(
aCx
JS_GetFunctionId
(
function
)
)
)
{
return
false
;
}
return
instance
-
>
SendDelete
(
aCx
NS_ConvertUTF16toUTF8
(
functionName
)
args
)
;
}
void
IPDLProtocol
:
:
RemoveInstance
(
IPDLProtocolInstance
*
instance
)
{
mInstances
.
RemoveEntry
(
instance
)
;
}
bool
IPDLProtocol
:
:
CheckParamTypeSpec
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
Param
aParam
)
{
return
CheckTypeSpec
(
aCx
aJSVal
aParam
.
type_spec
)
;
}
bool
IPDLProtocol
:
:
CheckTypeSpec
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
TypeSpec
aTypeSpec
)
{
if
(
aTypeSpec
.
nullable
&
&
aJSVal
.
isNull
(
)
)
{
return
true
;
}
if
(
aTypeSpec
.
array
)
{
bool
isArray
=
false
;
JS_IsArrayObject
(
aCx
aJSVal
&
isArray
)
;
if
(
!
isArray
)
{
return
false
;
}
JS
:
:
RootedObject
jsArray
(
aCx
&
aJSVal
.
toObject
(
)
)
;
uint32_t
arrayLength
=
0
;
JS_GetArrayLength
(
aCx
jsArray
&
arrayLength
)
;
for
(
size_t
i
=
0
;
i
<
arrayLength
;
i
+
+
)
{
JS
:
:
RootedValue
arrayVal
(
aCx
)
;
JS_GetElement
(
aCx
jsArray
i
&
arrayVal
)
;
if
(
!
CheckType
(
aCx
arrayVal
aTypeSpec
.
spec
)
)
{
return
false
;
}
}
return
true
;
}
return
CheckType
(
aCx
aJSVal
aTypeSpec
.
spec
)
;
}
bool
IPDLProtocol
:
:
CheckType
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
QualifiedId
aType
)
{
if
(
CheckBuiltinType
(
aCx
aJSVal
aType
)
)
{
return
true
;
}
if
(
CheckProtocolType
(
aCx
aJSVal
aType
)
)
{
return
true
;
}
if
(
CheckStructType
(
aCx
aJSVal
aType
)
)
{
return
true
;
}
if
(
CheckUnionType
(
aCx
aJSVal
aType
)
)
{
return
true
;
}
return
false
;
}
bool
IPDLProtocol
:
:
CheckProtocolType
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
QualifiedId
aType
)
{
auto
typeString
=
JoinQualifiedId
(
aType
)
;
if
(
!
mProtocolTable
.
Contains
(
typeString
)
)
{
return
false
;
}
if
(
!
aJSVal
.
isObject
(
)
)
{
return
false
;
}
JS
:
:
RootedObject
jsObj
(
aCx
&
aJSVal
.
toObject
(
)
)
;
if
(
typeString
.
Equals
(
JS_GetClass
(
jsObj
)
-
>
name
)
!
=
0
)
{
return
false
;
}
auto
*
protocolObj
=
static_cast
<
IPDLProtocol
*
>
(
JS_GetPrivate
(
jsObj
)
)
;
if
(
!
protocolObj
)
{
JS_ReportErrorUTF8
(
aCx
"
Couldn
'
t
get
protocol
object
from
private
date
field
"
)
;
return
false
;
}
return
protocolObj
-
>
GetProtocolName
(
)
.
Equals
(
typeString
)
;
}
bool
IPDLProtocol
:
:
CheckStructType
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
QualifiedId
aType
)
{
auto
*
ipdlStruct
=
mStructTable
.
Get
(
JoinQualifiedId
(
aType
)
)
;
if
(
!
ipdlStruct
)
{
return
false
;
}
if
(
!
aJSVal
.
isObject
(
)
)
{
return
false
;
}
JS
:
:
RootedObject
jsObj
(
aCx
&
aJSVal
.
toObject
(
)
)
;
for
(
auto
&
field
:
ipdlStruct
-
>
fields
)
{
JS
:
:
RootedValue
propertyValue
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
jsObj
field
.
name
.
id
.
get
(
)
&
propertyValue
)
)
{
return
false
;
}
if
(
propertyValue
.
isUndefined
(
)
)
{
return
false
;
}
if
(
!
CheckTypeSpec
(
aCx
propertyValue
field
.
type_spec
)
)
{
return
false
;
}
}
return
true
;
}
bool
IPDLProtocol
:
:
CheckUnionType
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
QualifiedId
aType
)
{
auto
*
ipdlUnion
=
mUnionTable
.
Get
(
JoinQualifiedId
(
aType
)
)
;
if
(
!
ipdlUnion
)
{
return
false
;
}
for
(
auto
&
type
:
ipdlUnion
-
>
types
)
{
if
(
CheckTypeSpec
(
aCx
aJSVal
type
)
)
{
return
true
;
}
}
return
false
;
}
bool
IPDLProtocol
:
:
CheckBuiltinType
(
JSContext
*
aCx
JS
:
:
HandleValue
aJSVal
ffi
:
:
QualifiedId
type
)
{
auto
typeString
=
JoinQualifiedId
(
type
)
;
if
(
typeString
.
Equals
(
"
bool
"
)
)
{
return
aJSVal
.
isBoolean
(
)
;
}
if
(
typeString
.
Equals
(
"
char
"
)
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
size_t
length
;
if
(
!
aJSVal
.
isString
(
)
)
{
return
false
;
}
JS_GetLatin1StringCharsAndLength
(
aCx
nogc
aJSVal
.
toString
(
)
&
length
)
;
return
length
=
=
1
;
}
if
(
typeString
.
Equals
(
"
nsString
"
)
|
|
typeString
.
Equals
(
"
nsCString
"
)
)
{
return
aJSVal
.
isString
(
)
;
}
if
(
typeString
.
Equals
(
"
short
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
SHRT_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
SHRT_MIN
)
;
}
if
(
typeString
.
Equals
(
"
int
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
INT_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
INT_MIN
)
;
}
if
(
typeString
.
Equals
(
"
long
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
LONG_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
LONG_MIN
)
;
}
if
(
typeString
.
Equals
(
"
float
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
FLT_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
FLT_MIN
)
;
}
if
(
typeString
.
Equals
(
"
double
"
)
)
{
return
aJSVal
.
isNumber
(
)
;
}
if
(
typeString
.
Equals
(
"
int8_t
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
INT8_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
INT8_MIN
)
;
}
if
(
typeString
.
Equals
(
"
uint8_t
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
UINT8_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
0
)
;
}
if
(
typeString
.
Equals
(
"
int16_t
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
INT16_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
INT16_MIN
)
;
}
if
(
typeString
.
Equals
(
"
uint16_t
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
UINT16_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
0
)
;
}
if
(
typeString
.
Equals
(
"
int32_t
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
INT32_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
INT32_MIN
)
;
}
if
(
typeString
.
Equals
(
"
uint32_t
"
)
)
{
return
aJSVal
.
isNumber
(
)
&
&
(
trunc
(
aJSVal
.
toNumber
(
)
)
=
=
aJSVal
.
toNumber
(
)
)
&
&
(
aJSVal
.
toNumber
(
)
<
=
UINT32_MAX
)
&
&
(
aJSVal
.
toNumber
(
)
>
=
0
)
;
}
if
(
typeString
.
Equals
(
"
int64_t
"
)
|
|
typeString
.
Equals
(
"
uint64_t
"
)
|
|
typeString
.
Equals
(
"
size_t
"
)
|
|
typeString
.
Equals
(
"
ssize_t
"
)
|
|
typeString
.
Equals
(
"
nsresult
"
)
|
|
typeString
.
Equals
(
"
mozilla
:
:
ipc
:
:
Shmem
"
)
|
|
typeString
.
Equals
(
"
mozilla
:
:
ipc
:
:
ByteBuf
"
)
|
|
typeString
.
Equals
(
"
mozilla
:
:
ipc
:
:
FileDescriptor
"
)
)
{
JS_ReportErrorUTF8
(
aCx
"
IPDL
:
cannot
use
type
%
s
from
JS
"
typeString
.
get
(
)
)
;
return
false
;
}
return
false
;
}
IPDLProtocol
:
:
~
IPDLProtocol
(
)
{
mProtoObj
=
nullptr
;
mConstructorObj
=
nullptr
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
bool
IPDLProtocol
:
:
Constructor
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
RootedValue
newTargetObjProtov
(
aCx
)
;
JS
:
:
RootedObject
newTargetObj
(
aCx
&
args
.
newTarget
(
)
.
toObject
(
)
)
;
if
(
!
JS_GetProperty
(
aCx
newTargetObj
"
prototype
"
&
newTargetObjProtov
)
)
{
return
false
;
}
JS
:
:
RootedObject
newTargetObjProto
(
aCx
&
newTargetObjProtov
.
toObject
(
)
)
;
JS
:
:
RootedObject
callee
(
aCx
&
args
.
callee
(
)
)
;
JS
:
:
RootedValue
prototypev
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
callee
"
prototype
"
&
prototypev
)
)
{
return
false
;
}
JS
:
:
RootedObject
prototype
(
aCx
&
prototypev
.
toObject
(
)
)
;
auto
protocol
=
static_cast
<
IPDLProtocol
*
>
(
JS_GetPrivate
(
prototype
)
)
;
if
(
!
protocol
)
{
JS_ReportErrorUTF8
(
aCx
"
Couldn
'
t
get
protocol
object
from
private
date
field
"
)
;
return
false
;
}
JS
:
:
RootedObject
newClassObject
(
aCx
JS_NewObjectWithGivenProto
(
aCx
&
protocol
-
>
GetProtocolClass
(
)
newTargetObjProto
)
)
;
auto
newInstance
=
MakeRefPtr
<
IPDLProtocolInstance
>
(
nullptr
protocol
-
>
RegisterExternalInstance
(
)
protocol
newClassObject
)
;
protocol
-
>
mInstances
.
PutEntry
(
newInstance
)
;
JS_SetPrivate
(
newClassObject
newInstance
)
;
args
.
rval
(
)
.
setObject
(
*
newClassObject
)
;
return
true
;
}
bool
IPDLProtocol
:
:
RecvDelete
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
return
true
;
}
bool
IPDLProtocol
:
:
RecvConstructor
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
return
true
;
}
bool
IPDLProtocol
:
:
AbstractRecvMessage
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS_ReportErrorUTF8
(
aCx
"
Received
message
but
recv
method
not
overriden
!
"
)
;
return
false
;
}
bool
IPDLProtocol
:
:
AbstractAlloc
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS_ReportErrorUTF8
(
aCx
"
Cannot
alloc
from
abstract
IPDL
protocol
class
!
"
)
;
return
false
;
}
nsCString
IPDLProtocol
:
:
JoinQualifiedId
(
const
ffi
:
:
QualifiedId
aQid
)
{
nsAutoCString
ret
;
for
(
auto
&
qual
:
aQid
.
quals
)
{
ret
.
Append
(
qual
)
;
ret
.
Append
(
"
:
:
"
)
;
}
ret
.
Append
(
aQid
.
base_id
.
id
)
;
return
std
:
:
move
(
ret
)
;
}
nsCString
IPDLProtocol
:
:
JoinNamespace
(
const
ffi
:
:
Namespace
aNs
)
{
nsAutoCString
ret
;
for
(
auto
&
name
:
aNs
.
namespaces
)
{
ret
.
Append
(
name
)
;
ret
.
Append
(
"
:
:
"
)
;
}
ret
.
Append
(
aNs
.
name
.
id
)
;
return
std
:
:
move
(
ret
)
;
}
constexpr
JSClassOps
IPDLProtocol
:
:
sIPDLJSClassOps
;
}
}
