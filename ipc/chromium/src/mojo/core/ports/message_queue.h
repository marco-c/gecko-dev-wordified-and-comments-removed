#
ifndef
MOJO_CORE_PORTS_MESSAGE_QUEUE_H_
#
define
MOJO_CORE_PORTS_MESSAGE_QUEUE_H_
#
include
<
stdint
.
h
>
#
include
<
limits
>
#
include
<
memory
>
#
include
<
vector
>
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
namespace
mojo
{
namespace
core
{
namespace
ports
{
constexpr
uint64_t
kInitialSequenceNum
=
1
;
constexpr
uint64_t
kInvalidSequenceNum
=
std
:
:
numeric_limits
<
uint64_t
>
:
:
max
(
)
;
class
MessageFilter
;
class
MessageQueue
{
public
:
explicit
MessageQueue
(
)
;
explicit
MessageQueue
(
uint64_t
next_sequence_num
)
;
~
MessageQueue
(
)
;
MessageQueue
(
const
MessageQueue
&
)
=
delete
;
void
operator
=
(
const
MessageQueue
&
)
=
delete
;
void
set_signalable
(
bool
value
)
{
signalable_
=
value
;
}
uint64_t
next_sequence_num
(
)
const
{
return
next_sequence_num_
;
}
bool
HasNextMessage
(
)
const
;
void
GetNextMessage
(
mozilla
:
:
UniquePtr
<
UserMessageEvent
>
*
message
MessageFilter
*
filter
)
;
void
MessageProcessed
(
)
;
void
AcceptMessage
(
mozilla
:
:
UniquePtr
<
UserMessageEvent
>
message
bool
*
has_next_message
)
;
void
TakeAllMessages
(
std
:
:
vector
<
mozilla
:
:
UniquePtr
<
UserMessageEvent
>
>
*
messages
)
;
size_t
queued_message_count
(
)
const
{
return
heap_
.
size
(
)
;
}
size_t
queued_num_bytes
(
)
const
{
return
total_queued_bytes_
;
}
private
:
std
:
:
vector
<
mozilla
:
:
UniquePtr
<
UserMessageEvent
>
>
heap_
;
uint64_t
next_sequence_num_
;
bool
signalable_
=
true
;
size_t
total_queued_bytes_
=
0
;
}
;
}
}
}
#
endif
