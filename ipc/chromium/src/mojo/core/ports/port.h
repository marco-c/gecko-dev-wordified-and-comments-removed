#
ifndef
MOJO_CORE_PORTS_PORT_H_
#
define
MOJO_CORE_PORTS_PORT_H_
#
include
<
memory
>
#
include
<
queue
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
#
include
"
mojo
/
core
/
ports
/
message_queue
.
h
"
#
include
"
mojo
/
core
/
ports
/
user_data
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mojo
{
namespace
core
{
namespace
ports
{
class
PortLocker
;
class
Port
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Port
)
public
:
enum
State
{
kUninitialized
kReceiving
kBuffering
kProxying
kClosed
}
;
State
state
;
NodeName
peer_node_name
;
PortName
peer_port_name
;
uint64_t
next_sequence_num_to_send
;
uint64_t
last_sequence_num_acknowledged
;
uint64_t
sequence_num_acknowledge_interval
;
uint64_t
last_sequence_num_to_receive
;
uint64_t
sequence_num_to_acknowledge
;
MessageQueue
message_queue
;
mozilla
:
:
UniquePtr
<
std
:
:
pair
<
NodeName
ScopedEvent
>
>
send_on_proxy_removal
;
RefPtr
<
UserData
>
user_data
;
bool
remove_proxy_on_last_message
;
bool
peer_closed
;
bool
peer_lost_unexpectedly
;
Port
(
uint64_t
next_sequence_num_to_send
uint64_t
next_sequence_num_to_receive
)
;
Port
(
const
Port
&
)
=
delete
;
void
operator
=
(
const
Port
&
)
=
delete
;
void
AssertLockAcquired
(
)
{
lock_
.
AssertCurrentThreadOwns
(
)
;
}
private
:
friend
class
PortLocker
;
~
Port
(
)
;
mozilla
:
:
Mutex
lock_
MOZ_UNANNOTATED
{
"
Port
State
"
}
;
}
;
}
}
}
#
endif
