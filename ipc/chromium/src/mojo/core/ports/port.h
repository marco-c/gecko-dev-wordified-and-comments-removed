#
ifndef
MOJO_CORE_PORTS_PORT_H_
#
define
MOJO_CORE_PORTS_PORT_H_
#
include
<
memory
>
#
include
<
queue
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
base
/
macros
.
h
"
#
include
"
base
/
memory
/
ref_counted
.
h
"
#
include
"
base
/
synchronization
/
lock
.
h
"
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
#
include
"
mojo
/
core
/
ports
/
message_queue
.
h
"
#
include
"
mojo
/
core
/
ports
/
user_data
.
h
"
namespace
mojo
{
namespace
core
{
namespace
ports
{
class
PortLocker
;
class
Port
:
public
base
:
:
RefCountedThreadSafe
<
Port
>
{
public
:
enum
State
{
kUninitialized
kReceiving
kBuffering
kProxying
kClosed
}
;
State
state
;
NodeName
peer_node_name
;
PortName
peer_port_name
;
uint64_t
next_sequence_num_to_send
;
uint64_t
last_sequence_num_acknowledged
;
uint64_t
sequence_num_acknowledge_interval
;
uint64_t
last_sequence_num_to_receive
;
uint64_t
sequence_num_to_acknowledge
;
MessageQueue
message_queue
;
std
:
:
unique_ptr
<
std
:
:
pair
<
NodeName
ScopedEvent
>
>
send_on_proxy_removal
;
scoped_refptr
<
UserData
>
user_data
;
bool
remove_proxy_on_last_message
;
bool
peer_closed
;
bool
peer_lost_unexpectedly
;
Port
(
uint64_t
next_sequence_num_to_send
uint64_t
next_sequence_num_to_receive
)
;
void
AssertLockAcquired
(
)
{
#
if
DCHECK_IS_ON
(
)
lock_
.
AssertAcquired
(
)
;
#
endif
}
private
:
friend
class
base
:
:
RefCountedThreadSafe
<
Port
>
;
friend
class
PortLocker
;
~
Port
(
)
;
base
:
:
Lock
lock_
;
DISALLOW_COPY_AND_ASSIGN
(
Port
)
;
}
;
}
}
}
#
endif
