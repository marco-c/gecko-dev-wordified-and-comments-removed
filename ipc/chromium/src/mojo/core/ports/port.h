#
ifndef
MOJO_CORE_PORTS_PORT_H_
#
define
MOJO_CORE_PORTS_PORT_H_
#
include
<
memory
>
#
include
<
queue
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
mojo
/
core
/
ports
/
event
.
h
"
#
include
"
mojo
/
core
/
ports
/
message_queue
.
h
"
#
include
"
mojo
/
core
/
ports
/
user_data
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
PlatformMutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mojo
{
namespace
core
{
namespace
ports
{
class
PortLocker
;
namespace
detail
{
class
MOZ_CAPABILITY
PortMutex
:
private
:
:
mozilla
:
:
detail
:
:
MutexImpl
{
public
:
void
AssertCurrentThreadOwns
(
)
const
MOZ_ASSERT_CAPABILITY
(
this
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mOwningThread
=
=
PR_GetCurrentThread
(
)
)
;
#
endif
}
private
:
friend
class
:
:
mojo
:
:
core
:
:
ports
:
:
PortLocker
;
void
Lock
(
)
MOZ_CAPABILITY_ACQUIRE
(
)
{
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
lock
(
)
;
#
ifdef
DEBUG
mOwningThread
=
PR_GetCurrentThread
(
)
;
#
endif
}
void
Unlock
(
)
MOZ_CAPABILITY_RELEASE
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mOwningThread
=
=
PR_GetCurrentThread
(
)
)
;
mOwningThread
=
nullptr
;
#
endif
:
:
mozilla
:
:
detail
:
:
MutexImpl
:
:
unlock
(
)
;
}
#
ifdef
DEBUG
mozilla
:
:
Atomic
<
PRThread
*
mozilla
:
:
Relaxed
>
mOwningThread
;
#
endif
}
;
}
class
Port
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Port
)
public
:
enum
State
{
kUninitialized
kReceiving
kBuffering
kProxying
kClosed
}
;
State
state
;
NodeName
peer_node_name
;
PortName
peer_port_name
;
uint64_t
next_sequence_num_to_send
;
uint64_t
last_sequence_num_acknowledged
;
uint64_t
sequence_num_acknowledge_interval
;
uint64_t
last_sequence_num_to_receive
;
uint64_t
sequence_num_to_acknowledge
;
MessageQueue
message_queue
;
mozilla
:
:
UniquePtr
<
std
:
:
pair
<
NodeName
ScopedEvent
>
>
send_on_proxy_removal
;
RefPtr
<
UserData
>
user_data
;
bool
remove_proxy_on_last_message
;
bool
peer_closed
;
bool
peer_lost_unexpectedly
;
Port
(
uint64_t
next_sequence_num_to_send
uint64_t
next_sequence_num_to_receive
)
;
Port
(
const
Port
&
)
=
delete
;
void
operator
=
(
const
Port
&
)
=
delete
;
void
AssertLockAcquired
(
)
{
lock_
.
AssertCurrentThreadOwns
(
)
;
}
private
:
friend
class
PortLocker
;
~
Port
(
)
;
detail
:
:
PortMutex
lock_
MOZ_ANNOTATED
;
}
;
}
}
}
#
endif
