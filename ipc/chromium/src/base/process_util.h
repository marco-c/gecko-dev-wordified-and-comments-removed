#
ifndef
BASE_PROCESS_UTIL_H_
#
define
BASE_PROCESS_UTIL_H_
#
include
"
base
/
basictypes
.
h
"
#
if
defined
(
OS_WIN
)
#
include
<
windows
.
h
>
#
include
<
tlhelp32
.
h
>
#
include
<
io
.
h
>
#
ifndef
STDOUT_FILENO
#
define
STDOUT_FILENO
1
#
endif
#
elif
defined
(
OS_LINUX
)
|
|
defined
(
__GLIBC__
)
#
include
<
dirent
.
h
>
#
include
<
limits
.
h
>
#
include
<
sys
/
types
.
h
>
#
elif
defined
(
OS_MACOSX
)
#
include
<
mach
/
mach
.
h
>
#
endif
#
include
<
functional
>
#
include
<
map
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
#
ifndef
OS_WIN
#
include
<
unistd
.
h
>
#
endif
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
ipc
/
EnvironmentMap
.
h
"
#
if
defined
(
OS_MACOSX
)
struct
kinfo_proc
;
#
endif
namespace
base
{
enum
{
PROCESS_END_NORMAL_TERMINATON
=
0
PROCESS_END_KILLED_BY_USER
=
1
PROCESS_END_PROCESS_WAS_HUNG
=
2
}
;
ProcessId
GetCurrentProcId
(
)
;
ProcessHandle
GetCurrentProcessHandle
(
)
;
bool
OpenProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
;
bool
OpenPrivilegedProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
;
void
CloseProcessHandle
(
ProcessHandle
process
)
;
ProcessId
GetProcId
(
ProcessHandle
process
)
;
#
if
defined
(
OS_POSIX
)
void
SetAllFDsToCloseOnExec
(
)
;
void
CloseSuperfluousFds
(
std
:
:
function
<
bool
(
int
)
>
&
&
should_preserve
)
;
typedef
std
:
:
vector
<
std
:
:
pair
<
int
int
>
>
file_handle_mapping_vector
;
typedef
std
:
:
map
<
std
:
:
string
std
:
:
string
>
environment_map
;
#
endif
struct
LaunchOptions
{
bool
wait
=
false
;
#
if
defined
(
OS_WIN
)
bool
start_hidden
=
false
;
EnvironmentMap
env_map
;
std
:
:
vector
<
HANDLE
>
handles_to_inherit
;
#
endif
#
if
defined
(
OS_POSIX
)
environment_map
env_map
;
file_handle_mapping_vector
fds_to_remap
;
#
endif
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_SOLARIS
)
struct
ForkDelegate
{
virtual
~
ForkDelegate
(
)
{
}
virtual
pid_t
Fork
(
)
=
0
;
}
;
mozilla
:
:
UniquePtr
<
ForkDelegate
>
fork_delegate
=
nullptr
;
#
endif
}
;
#
if
defined
(
OS_WIN
)
bool
LaunchApp
(
const
std
:
:
wstring
&
cmdline
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
;
#
elif
defined
(
OS_POSIX
)
bool
LaunchApp
(
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
;
struct
FreeEnvVarsArray
{
void
operator
(
)
(
char
*
*
array
)
;
}
;
typedef
mozilla
:
:
UniquePtr
<
char
*
[
]
FreeEnvVarsArray
>
EnvironmentArray
;
EnvironmentArray
BuildEnvironmentArray
(
const
environment_map
&
env_vars_to_set
)
;
#
endif
bool
LaunchApp
(
const
CommandLine
&
cl
const
LaunchOptions
&
ProcessHandle
*
process_handle
)
;
bool
KillProcess
(
ProcessHandle
process
int
exit_code
bool
wait
)
;
bool
DidProcessCrash
(
bool
*
child_exited
ProcessHandle
handle
)
;
}
namespace
mozilla
{
class
EnvironmentLog
{
public
:
explicit
EnvironmentLog
(
const
char
*
varname
)
{
const
char
*
e
=
getenv
(
varname
)
;
if
(
e
&
&
*
e
)
{
fname_
=
e
;
}
}
~
EnvironmentLog
(
)
{
}
void
print
(
const
char
*
format
.
.
.
)
{
if
(
!
fname_
.
size
(
)
)
return
;
FILE
*
f
;
if
(
fname_
.
compare
(
"
-
"
)
=
=
0
)
{
f
=
fdopen
(
dup
(
STDOUT_FILENO
)
"
a
"
)
;
}
else
{
f
=
fopen
(
fname_
.
c_str
(
)
"
a
"
)
;
}
if
(
!
f
)
return
;
va_list
a
;
va_start
(
a
format
)
;
vfprintf
(
f
format
a
)
;
va_end
(
a
)
;
fclose
(
f
)
;
}
private
:
std
:
:
string
fname_
;
DISALLOW_EVIL_CONSTRUCTORS
(
EnvironmentLog
)
;
}
;
}
#
if
defined
(
OS_WIN
)
#
undef
GetMessage
#
undef
CreateEvent
#
undef
GetClassName
#
undef
GetBinaryType
#
undef
RemoveDirectory
#
undef
LoadImage
#
undef
LoadIcon
#
endif
#
endif
