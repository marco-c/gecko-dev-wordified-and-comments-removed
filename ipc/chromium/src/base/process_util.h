#
ifndef
BASE_PROCESS_UTIL_H_
#
define
BASE_PROCESS_UTIL_H_
#
include
"
base
/
basictypes
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
ipc
/
EnvironmentMap
.
h
"
#
include
<
windows
.
h
>
#
include
<
tlhelp32
.
h
>
#
elif
defined
(
XP_LINUX
)
|
|
defined
(
__GLIBC__
)
#
include
<
dirent
.
h
>
#
include
<
limits
.
h
>
#
include
<
sys
/
types
.
h
>
#
elif
defined
(
XP_DARWIN
)
#
include
<
mach
/
mach
.
h
>
#
endif
#
include
<
cstddef
>
#
include
<
map
>
#
include
<
string
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
ipc
/
LaunchError
.
h
"
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
#
include
"
nsStringFwd
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorShuffle
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
FileDescriptor
;
}
}
#
endif
#
if
defined
(
XP_DARWIN
)
struct
kinfo_proc
;
#
endif
class
CommandLine
;
namespace
base
{
using
mozilla
:
:
Err
;
using
mozilla
:
:
Ok
;
using
mozilla
:
:
Result
;
using
mozilla
:
:
ipc
:
:
LaunchError
;
enum
ProcessArchitecture
{
PROCESS_ARCH_INVALID
=
0x0
PROCESS_ARCH_I386
=
0x1
PROCESS_ARCH_X86_64
=
0x2
PROCESS_ARCH_PPC
=
0x4
PROCESS_ARCH_PPC_64
=
0x8
PROCESS_ARCH_ARM
=
0x10
PROCESS_ARCH_ARM_64
=
0x20
}
;
enum
{
PROCESS_END_NORMAL_TERMINATON
=
0
PROCESS_END_KILLED_BY_USER
=
1
PROCESS_END_PROCESS_WAS_HUNG
=
2
}
;
ProcessId
GetCurrentProcId
(
)
;
ProcessHandle
GetCurrentProcessHandle
(
)
;
bool
OpenProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
;
bool
OpenPrivilegedProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
;
void
CloseProcessHandle
(
ProcessHandle
process
)
;
ProcessId
GetProcId
(
ProcessHandle
process
)
;
#
if
defined
(
XP_UNIX
)
void
CloseSuperfluousFds
(
void
*
aCtx
bool
(
*
aShouldPreserve
)
(
void
*
int
)
)
;
typedef
std
:
:
vector
<
std
:
:
pair
<
int
int
>
>
file_handle_mapping_vector
;
typedef
std
:
:
map
<
std
:
:
string
std
:
:
string
>
environment_map
;
struct
FreeEnvVarsArray
{
void
operator
(
)
(
char
*
*
array
)
;
}
;
typedef
mozilla
:
:
UniquePtr
<
char
*
[
]
FreeEnvVarsArray
>
EnvironmentArray
;
#
endif
struct
LaunchOptions
{
bool
wait
=
false
;
#
if
defined
(
XP_WIN
)
bool
start_hidden
=
false
;
bool
start_independent
=
false
;
EnvironmentMap
env_map
;
std
:
:
vector
<
HANDLE
>
handles_to_inherit
;
#
endif
#
if
defined
(
XP_UNIX
)
environment_map
env_map
;
EnvironmentArray
full_env
;
std
:
:
string
workdir
;
file_handle_mapping_vector
fds_to_remap
;
#
endif
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
bool
use_forkserver
=
false
;
#
endif
#
if
defined
(
XP_LINUX
)
&
&
defined
(
MOZ_SANDBOX
)
int
fork_flags
=
0
;
mozilla
:
:
UniqueFileHandle
sandbox_chroot_server
;
#
endif
#
ifdef
XP_DARWIN
bool
disclaim
=
false
;
#
ifdef
__aarch64__
uint32_t
arch
=
PROCESS_ARCH_INVALID
;
#
endif
#
endif
}
;
#
if
defined
(
XP_WIN
)
Result
<
Ok
LaunchError
>
LaunchApp
(
const
std
:
:
wstring
&
cmdline
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
;
Result
<
Ok
LaunchError
>
LaunchApp
(
const
CommandLine
&
cl
const
LaunchOptions
&
ProcessHandle
*
process_handle
)
;
#
else
Result
<
Ok
LaunchError
>
LaunchApp
(
const
std
:
:
vector
<
std
:
:
string
>
&
argv
LaunchOptions
&
&
options
ProcessHandle
*
process_handle
)
;
EnvironmentArray
BuildEnvironmentArray
(
const
environment_map
&
env_vars_to_set
)
;
#
endif
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
class
AppProcessBuilder
{
public
:
AppProcessBuilder
(
)
;
bool
ForkProcess
(
LaunchOptions
&
&
options
ProcessHandle
*
process_handle
)
;
void
SetExecInfo
(
std
:
:
vector
<
std
:
:
string
>
&
&
aArgv
environment_map
&
&
aEnv
)
;
void
InitAppProcess
(
int
*
argcp
char
*
*
*
argvp
)
;
private
:
void
ReplaceArguments
(
int
*
argcp
char
*
*
*
argvp
)
;
mozilla
:
:
ipc
:
:
FileDescriptorShuffle
shuffle_
;
std
:
:
vector
<
std
:
:
string
>
argv_
;
environment_map
env_
;
}
;
void
InitForkServerProcess
(
)
;
#
endif
bool
KillProcess
(
ProcessHandle
process
int
exit_code
)
;
#
ifdef
XP_UNIX
bool
IsProcessDead
(
ProcessHandle
handle
bool
blocking
=
false
)
;
#
endif
}
namespace
mozilla
{
class
EnvironmentLog
{
public
:
template
<
size_t
N
>
explicit
EnvironmentLog
(
const
char
(
&
varname
)
[
N
]
)
:
EnvironmentLog
(
varname
N
)
{
}
~
EnvironmentLog
(
)
{
}
void
print
(
const
char
*
format
.
.
.
)
;
private
:
explicit
EnvironmentLog
(
const
char
*
varname
size_t
len
)
;
#
if
defined
(
XP_WIN
)
std
:
:
wstring
fname_
;
#
else
std
:
:
string
fname_
;
#
endif
DISALLOW_EVIL_CONSTRUCTORS
(
EnvironmentLog
)
;
}
;
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
typedef
std
:
:
tuple
<
nsCString
nsCString
>
EnvVar
;
typedef
std
:
:
tuple
<
mozilla
:
:
ipc
:
:
FileDescriptor
int
>
FdMapping
;
#
endif
}
#
if
defined
(
XP_WIN
)
#
undef
GetMessage
#
undef
CreateEvent
#
undef
GetClassName
#
undef
GetBinaryType
#
undef
RemoveDirectory
#
undef
LoadImage
#
undef
LoadIcon
#
endif
#
endif
