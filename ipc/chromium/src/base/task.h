#
ifndef
BASE_TASK_H_
#
define
BASE_TASK_H_
#
include
"
base
/
non_thread_safe
.
h
"
#
include
"
base
/
revocable_store
.
h
"
#
include
"
base
/
tracked
.
h
"
#
include
"
base
/
tuple
.
h
"
#
include
"
mozilla
/
IndexSequence
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
namespace
details
{
template
<
size_t
.
.
.
Indices
class
ObjT
class
Method
typename
.
.
.
Args
>
void
CallMethod
(
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
ObjT
*
obj
Method
method
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
(
obj
-
>
*
method
)
(
mozilla
:
:
Move
(
mozilla
:
:
Get
<
Indices
>
(
arg
)
)
.
.
.
)
;
}
template
<
size_t
.
.
.
Indices
typename
Function
typename
.
.
.
Args
>
void
CallFunction
(
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
Function
function
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
(
*
function
)
(
mozilla
:
:
Move
(
mozilla
:
:
Get
<
Indices
>
(
arg
)
)
.
.
.
)
;
}
}
template
<
class
ObjT
class
Method
typename
.
.
.
Args
>
void
DispatchTupleToMethod
(
ObjT
*
obj
Method
method
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
details
:
:
CallMethod
(
typename
mozilla
:
:
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
obj
method
arg
)
;
}
template
<
typename
Function
typename
.
.
.
Args
>
void
DispatchTupleToFunction
(
Function
function
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
details
:
:
CallFunction
(
typename
mozilla
:
:
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
function
arg
)
;
}
class
Task
:
public
tracked_objects
:
:
Tracked
{
public
:
Task
(
)
{
}
virtual
B2G_ACL_EXPORT
~
Task
(
)
{
}
virtual
void
Run
(
)
=
0
;
}
;
class
CancelableTask
:
public
Task
{
public
:
virtual
void
Cancel
(
)
=
0
;
}
;
template
<
class
TaskType
>
class
ScopedTaskFactory
:
public
RevocableStore
{
public
:
ScopedTaskFactory
(
)
{
}
inline
TaskType
*
NewTask
(
)
{
return
new
TaskWrapper
(
this
)
;
}
class
TaskWrapper
:
public
TaskType
public
NonThreadSafe
{
public
:
explicit
TaskWrapper
(
RevocableStore
*
store
)
:
revocable_
(
store
)
{
}
virtual
void
Run
(
)
{
if
(
!
revocable_
.
revoked
(
)
)
TaskType
:
:
Run
(
)
;
}
private
:
Revocable
revocable_
;
DISALLOW_EVIL_CONSTRUCTORS
(
TaskWrapper
)
;
}
;
private
:
DISALLOW_EVIL_CONSTRUCTORS
(
ScopedTaskFactory
)
;
}
;
template
<
class
T
>
class
ScopedRunnableMethodFactory
:
public
RevocableStore
{
public
:
explicit
ScopedRunnableMethodFactory
(
T
*
object
)
:
object_
(
object
)
{
}
template
<
class
Method
typename
.
.
.
Elements
>
inline
Task
*
NewRunnableMethod
(
Method
method
Elements
&
&
.
.
.
elements
)
{
typedef
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Elements
>
:
:
Type
.
.
.
>
ArgsTuple
;
typedef
RunnableMethod
<
Method
ArgsTuple
>
Runnable
;
typedef
typename
ScopedTaskFactory
<
Runnable
>
:
:
TaskWrapper
TaskWrapper
;
TaskWrapper
*
task
=
new
TaskWrapper
(
this
)
;
task
-
>
Init
(
object_
method
mozilla
:
:
MakeTuple
(
mozilla
:
:
Forward
<
Elements
>
(
elements
)
.
.
.
)
)
;
return
task
;
}
protected
:
template
<
class
Method
class
Params
>
class
RunnableMethod
:
public
Task
{
public
:
RunnableMethod
(
)
{
}
void
Init
(
T
*
obj
Method
meth
Params
&
&
params
)
{
obj_
=
obj
;
meth_
=
meth
;
params_
=
mozilla
:
:
Forward
<
Params
>
(
params
)
;
}
virtual
void
Run
(
)
{
DispatchTupleToMethod
(
obj_
meth_
params_
)
;
}
private
:
T
*
MOZ_UNSAFE_REF
(
"
The
validity
of
this
pointer
must
be
enforced
by
"
"
external
factors
.
"
)
obj_
;
Method
meth_
;
Params
params_
;
DISALLOW_EVIL_CONSTRUCTORS
(
RunnableMethod
)
;
}
;
private
:
T
*
object_
;
DISALLOW_EVIL_CONSTRUCTORS
(
ScopedRunnableMethodFactory
)
;
}
;
template
<
class
T
>
class
DeleteTask
:
public
CancelableTask
{
public
:
explicit
DeleteTask
(
T
*
obj
)
:
obj_
(
obj
)
{
}
virtual
void
Run
(
)
{
delete
obj_
;
}
virtual
void
Cancel
(
)
{
obj_
=
NULL
;
}
private
:
T
*
MOZ_UNSAFE_REF
(
"
The
validity
of
this
pointer
must
be
enforced
by
"
"
external
factors
.
"
)
obj_
;
}
;
template
<
class
T
>
struct
RunnableMethodTraits
{
static
void
RetainCallee
(
T
*
obj
)
{
obj
-
>
AddRef
(
)
;
}
static
void
ReleaseCallee
(
T
*
obj
)
{
obj
-
>
Release
(
)
;
}
}
;
template
<
class
T
>
struct
RunnableMethodTraits
<
const
T
>
{
static
void
RetainCallee
(
const
T
*
obj
)
{
const_cast
<
T
*
>
(
obj
)
-
>
AddRef
(
)
;
}
static
void
ReleaseCallee
(
const
T
*
obj
)
{
const_cast
<
T
*
>
(
obj
)
-
>
Release
(
)
;
}
}
;
template
<
class
T
class
Method
class
Params
>
class
RunnableMethod
:
public
CancelableTask
public
RunnableMethodTraits
<
T
>
{
public
:
RunnableMethod
(
T
*
obj
Method
meth
Params
&
&
params
)
:
obj_
(
obj
)
meth_
(
meth
)
params_
(
mozilla
:
:
Forward
<
Params
>
(
params
)
)
{
this
-
>
RetainCallee
(
obj_
)
;
}
~
RunnableMethod
(
)
{
ReleaseCallee
(
)
;
}
virtual
void
Run
(
)
{
if
(
obj_
)
DispatchTupleToMethod
(
obj_
meth_
params_
)
;
}
virtual
void
Cancel
(
)
{
ReleaseCallee
(
)
;
}
private
:
void
ReleaseCallee
(
)
{
if
(
obj_
)
{
RunnableMethodTraits
<
T
>
:
:
ReleaseCallee
(
obj_
)
;
obj_
=
nullptr
;
}
}
T
*
MOZ_OWNING_REF
obj_
;
Method
meth_
;
Params
params_
;
}
;
template
<
class
T
class
Method
typename
.
.
.
Args
>
inline
CancelableTask
*
NewRunnableMethod
(
T
*
object
Method
method
Args
&
&
.
.
.
args
)
{
typedef
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Args
>
:
:
Type
.
.
.
>
ArgsTuple
;
return
new
RunnableMethod
<
T
Method
ArgsTuple
>
(
object
method
mozilla
:
:
MakeTuple
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
class
Function
class
Params
>
class
RunnableFunction
:
public
CancelableTask
{
public
:
RunnableFunction
(
Function
function
Params
&
&
params
)
:
function_
(
function
)
params_
(
mozilla
:
:
Forward
<
Params
>
(
params
)
)
{
}
~
RunnableFunction
(
)
{
}
virtual
void
Run
(
)
{
if
(
function_
)
DispatchTupleToFunction
(
function_
params_
)
;
}
virtual
void
Cancel
(
)
{
function_
=
nullptr
;
}
Function
function_
;
Params
params_
;
}
;
template
<
class
Function
typename
.
.
.
Args
>
inline
CancelableTask
*
NewRunnableFunction
(
Function
function
Args
&
&
.
.
.
args
)
{
typedef
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Args
>
:
:
Type
.
.
.
>
ArgsTuple
;
return
new
RunnableFunction
<
Function
ArgsTuple
>
(
function
mozilla
:
:
MakeTuple
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
#
endif
