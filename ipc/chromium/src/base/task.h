#
ifndef
BASE_TASK_H_
#
define
BASE_TASK_H_
#
include
"
base
/
non_thread_safe
.
h
"
#
include
"
base
/
revocable_store
.
h
"
#
include
"
base
/
tracked
.
h
"
#
include
"
base
/
tuple
.
h
"
#
include
"
mozilla
/
IndexSequence
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
namespace
details
{
template
<
size_t
.
.
.
Indices
class
ObjT
class
Method
typename
.
.
.
Args
>
void
CallMethod
(
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
ObjT
*
obj
Method
method
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
(
obj
-
>
*
method
)
(
mozilla
:
:
Move
(
mozilla
:
:
Get
<
Indices
>
(
arg
)
)
.
.
.
)
;
}
template
<
size_t
.
.
.
Indices
typename
Function
typename
.
.
.
Args
>
void
CallFunction
(
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
Function
function
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
(
*
function
)
(
mozilla
:
:
Move
(
mozilla
:
:
Get
<
Indices
>
(
arg
)
)
.
.
.
)
;
}
}
template
<
class
ObjT
class
Method
typename
.
.
.
Args
>
void
DispatchTupleToMethod
(
ObjT
*
obj
Method
method
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
details
:
:
CallMethod
(
typename
mozilla
:
:
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
obj
method
arg
)
;
}
template
<
typename
Function
typename
.
.
.
Args
>
void
DispatchTupleToFunction
(
Function
function
mozilla
:
:
Tuple
<
Args
.
.
.
>
&
arg
)
{
details
:
:
CallFunction
(
typename
mozilla
:
:
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
function
arg
)
;
}
class
Task
:
public
tracked_objects
:
:
Tracked
{
public
:
Task
(
)
{
}
virtual
B2G_ACL_EXPORT
~
Task
(
)
{
}
virtual
void
Run
(
)
=
0
;
}
;
class
CancelableTask
:
public
Task
{
public
:
virtual
void
Cancel
(
)
=
0
;
}
;
template
<
class
TaskType
>
class
ScopedTaskFactory
:
public
RevocableStore
{
public
:
ScopedTaskFactory
(
)
{
}
inline
TaskType
*
NewTask
(
)
{
return
new
TaskWrapper
(
this
)
;
}
class
TaskWrapper
:
public
TaskType
public
NonThreadSafe
{
public
:
explicit
TaskWrapper
(
RevocableStore
*
store
)
:
revocable_
(
store
)
{
}
virtual
void
Run
(
)
{
if
(
!
revocable_
.
revoked
(
)
)
TaskType
:
:
Run
(
)
;
}
private
:
Revocable
revocable_
;
DISALLOW_EVIL_CONSTRUCTORS
(
TaskWrapper
)
;
}
;
private
:
DISALLOW_EVIL_CONSTRUCTORS
(
ScopedTaskFactory
)
;
}
;
template
<
class
T
>
class
ScopedRunnableMethodFactory
:
public
RevocableStore
{
public
:
explicit
ScopedRunnableMethodFactory
(
T
*
object
)
:
object_
(
object
)
{
}
template
<
class
Method
typename
.
.
.
Elements
>
inline
Task
*
NewRunnableMethod
(
Method
method
Elements
&
&
.
.
.
elements
)
{
typedef
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Elements
>
:
:
Type
.
.
.
>
ArgsTuple
;
typedef
RunnableMethod
<
Method
ArgsTuple
>
Runnable
;
typedef
typename
ScopedTaskFactory
<
Runnable
>
:
:
TaskWrapper
TaskWrapper
;
TaskWrapper
*
task
=
new
TaskWrapper
(
this
)
;
task
-
>
Init
(
object_
method
mozilla
:
:
MakeTuple
(
mozilla
:
:
Forward
<
Elements
>
(
elements
)
.
.
.
)
)
;
return
task
;
}
protected
:
template
<
class
Method
class
Params
>
class
RunnableMethod
:
public
Task
{
public
:
RunnableMethod
(
)
{
}
void
Init
(
T
*
obj
Method
meth
Params
&
&
params
)
{
obj_
=
obj
;
meth_
=
meth
;
params_
=
mozilla
:
:
Forward
<
Params
>
(
params
)
;
}
virtual
void
Run
(
)
{
DispatchTupleToMethod
(
obj_
meth_
params_
)
;
}
private
:
T
*
MOZ_UNSAFE_REF
(
"
The
validity
of
this
pointer
must
be
enforced
by
"
"
external
factors
.
"
)
obj_
;
Method
meth_
;
Params
params_
;
DISALLOW_EVIL_CONSTRUCTORS
(
RunnableMethod
)
;
}
;
private
:
T
*
object_
;
DISALLOW_EVIL_CONSTRUCTORS
(
ScopedRunnableMethodFactory
)
;
}
;
template
<
class
T
>
class
DeleteTask
:
public
CancelableTask
{
public
:
explicit
DeleteTask
(
T
*
obj
)
:
obj_
(
obj
)
{
}
virtual
void
Run
(
)
{
delete
obj_
;
}
virtual
void
Cancel
(
)
{
obj_
=
NULL
;
}
private
:
T
*
MOZ_UNSAFE_REF
(
"
The
validity
of
this
pointer
must
be
enforced
by
"
"
external
factors
.
"
)
obj_
;
}
;
template
<
class
T
>
class
ReleaseTask
:
public
CancelableTask
{
public
:
explicit
ReleaseTask
(
T
*
obj
)
:
obj_
(
obj
)
{
}
virtual
void
Run
(
)
{
if
(
obj_
)
obj_
-
>
Release
(
)
;
}
virtual
void
Cancel
(
)
{
obj_
=
NULL
;
}
private
:
T
*
MOZ_UNSAFE_REF
(
"
The
validity
of
this
pointer
must
be
enforced
by
"
"
external
factors
.
"
)
obj_
;
}
;
template
<
class
T
>
struct
RunnableMethodTraits
{
static
void
RetainCallee
(
T
*
obj
)
{
obj
-
>
AddRef
(
)
;
}
static
void
ReleaseCallee
(
T
*
obj
)
{
obj
-
>
Release
(
)
;
}
}
;
template
<
class
T
>
struct
RunnableMethodTraits
<
const
T
>
{
static
void
RetainCallee
(
const
T
*
obj
)
{
const_cast
<
T
*
>
(
obj
)
-
>
AddRef
(
)
;
}
static
void
ReleaseCallee
(
const
T
*
obj
)
{
const_cast
<
T
*
>
(
obj
)
-
>
Release
(
)
;
}
}
;
template
<
class
T
class
Method
class
Params
>
class
RunnableMethod
:
public
CancelableTask
public
RunnableMethodTraits
<
T
>
{
public
:
RunnableMethod
(
T
*
obj
Method
meth
Params
&
&
params
)
:
obj_
(
obj
)
meth_
(
meth
)
params_
(
mozilla
:
:
Forward
<
Params
>
(
params
)
)
{
this
-
>
RetainCallee
(
obj_
)
;
}
~
RunnableMethod
(
)
{
ReleaseCallee
(
)
;
}
virtual
void
Run
(
)
{
if
(
obj_
)
DispatchTupleToMethod
(
obj_
meth_
params_
)
;
}
virtual
void
Cancel
(
)
{
ReleaseCallee
(
)
;
}
private
:
void
ReleaseCallee
(
)
{
if
(
obj_
)
{
RunnableMethodTraits
<
T
>
:
:
ReleaseCallee
(
obj_
)
;
obj_
=
nullptr
;
}
}
T
*
MOZ_OWNING_REF
obj_
;
Method
meth_
;
Params
params_
;
}
;
template
<
class
T
class
Method
typename
.
.
.
Args
>
inline
CancelableTask
*
NewRunnableMethod
(
T
*
object
Method
method
Args
&
&
.
.
.
args
)
{
typedef
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Args
>
:
:
Type
.
.
.
>
ArgsTuple
;
return
new
RunnableMethod
<
T
Method
ArgsTuple
>
(
object
method
mozilla
:
:
MakeTuple
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
class
Function
class
Params
>
class
RunnableFunction
:
public
CancelableTask
{
public
:
RunnableFunction
(
Function
function
Params
&
&
params
)
:
function_
(
function
)
params_
(
mozilla
:
:
Forward
<
Params
>
(
params
)
)
{
}
~
RunnableFunction
(
)
{
}
virtual
void
Run
(
)
{
if
(
function_
)
DispatchTupleToFunction
(
function_
params_
)
;
}
virtual
void
Cancel
(
)
{
function_
=
nullptr
;
}
Function
function_
;
Params
params_
;
}
;
template
<
class
Function
typename
.
.
.
Args
>
inline
CancelableTask
*
NewRunnableFunction
(
Function
function
Args
&
&
.
.
.
args
)
{
typedef
mozilla
:
:
Tuple
<
typename
mozilla
:
:
Decay
<
Args
>
:
:
Type
.
.
.
>
ArgsTuple
;
return
new
RunnableFunction
<
Function
ArgsTuple
>
(
function
mozilla
:
:
MakeTuple
(
mozilla
:
:
Forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
class
T
typename
Method
>
class
CallbackStorage
{
public
:
CallbackStorage
(
T
*
obj
Method
meth
)
:
obj_
(
obj
)
meth_
(
meth
)
{
}
protected
:
T
*
MOZ_UNSAFE_REF
(
"
The
validity
of
this
pointer
must
be
enforced
by
"
"
external
factors
.
"
)
obj_
;
Method
meth_
;
}
;
template
<
typename
Params
>
class
CallbackRunner
{
public
:
typedef
Params
TupleType
;
virtual
~
CallbackRunner
(
)
{
}
virtual
void
RunWithParams
(
const
Params
&
params
)
=
0
;
inline
void
Run
(
)
{
RunWithParams
(
Tuple0
(
)
)
;
}
template
<
typename
Arg1
>
inline
void
Run
(
const
Arg1
&
a
)
{
RunWithParams
(
Params
(
a
)
)
;
}
template
<
typename
Arg1
typename
Arg2
>
inline
void
Run
(
const
Arg1
&
a
const
Arg2
&
b
)
{
RunWithParams
(
Params
(
a
b
)
)
;
}
template
<
typename
Arg1
typename
Arg2
typename
Arg3
>
inline
void
Run
(
const
Arg1
&
a
const
Arg2
&
b
const
Arg3
&
c
)
{
RunWithParams
(
Params
(
a
b
c
)
)
;
}
template
<
typename
Arg1
typename
Arg2
typename
Arg3
typename
Arg4
>
inline
void
Run
(
const
Arg1
&
a
const
Arg2
&
b
const
Arg3
&
c
const
Arg4
&
d
)
{
RunWithParams
(
Params
(
a
b
c
d
)
)
;
}
template
<
typename
Arg1
typename
Arg2
typename
Arg3
typename
Arg4
typename
Arg5
>
inline
void
Run
(
const
Arg1
&
a
const
Arg2
&
b
const
Arg3
&
c
const
Arg4
&
d
const
Arg5
&
e
)
{
RunWithParams
(
Params
(
a
b
c
d
e
)
)
;
}
}
;
template
<
class
T
typename
Method
typename
Params
>
class
CallbackImpl
:
public
CallbackStorage
<
T
Method
>
public
CallbackRunner
<
Params
>
{
public
:
CallbackImpl
(
T
*
obj
Method
meth
)
:
CallbackStorage
<
T
Method
>
(
obj
meth
)
{
}
virtual
void
RunWithParams
(
const
Params
&
params
)
{
DispatchToMethod
(
this
-
>
obj_
this
-
>
meth_
params
)
;
}
}
;
struct
Callback0
{
typedef
CallbackRunner
<
Tuple0
>
Type
;
}
;
template
<
class
T
>
typename
Callback0
:
:
Type
*
NewCallback
(
T
*
object
void
(
T
:
:
*
method
)
(
)
)
{
return
new
CallbackImpl
<
T
void
(
T
:
:
*
)
(
)
Tuple0
>
(
object
method
)
;
}
template
<
typename
Arg1
>
struct
Callback1
{
typedef
CallbackRunner
<
Tuple1
<
Arg1
>
>
Type
;
}
;
template
<
class
T
typename
Arg1
>
typename
Callback1
<
Arg1
>
:
:
Type
*
NewCallback
(
T
*
object
void
(
T
:
:
*
method
)
(
Arg1
)
)
{
return
new
CallbackImpl
<
T
void
(
T
:
:
*
)
(
Arg1
)
Tuple1
<
Arg1
>
>
(
object
method
)
;
}
template
<
typename
Arg1
typename
Arg2
>
struct
Callback2
{
typedef
CallbackRunner
<
Tuple2
<
Arg1
Arg2
>
>
Type
;
}
;
template
<
class
T
typename
Arg1
typename
Arg2
>
typename
Callback2
<
Arg1
Arg2
>
:
:
Type
*
NewCallback
(
T
*
object
void
(
T
:
:
*
method
)
(
Arg1
Arg2
)
)
{
return
new
CallbackImpl
<
T
void
(
T
:
:
*
)
(
Arg1
Arg2
)
Tuple2
<
Arg1
Arg2
>
>
(
object
method
)
;
}
template
<
typename
Arg1
typename
Arg2
typename
Arg3
>
struct
Callback3
{
typedef
CallbackRunner
<
Tuple3
<
Arg1
Arg2
Arg3
>
>
Type
;
}
;
template
<
class
T
typename
Arg1
typename
Arg2
typename
Arg3
>
typename
Callback3
<
Arg1
Arg2
Arg3
>
:
:
Type
*
NewCallback
(
T
*
object
void
(
T
:
:
*
method
)
(
Arg1
Arg2
Arg3
)
)
{
return
new
CallbackImpl
<
T
void
(
T
:
:
*
)
(
Arg1
Arg2
Arg3
)
Tuple3
<
Arg1
Arg2
Arg3
>
>
(
object
method
)
;
}
template
<
typename
Arg1
typename
Arg2
typename
Arg3
typename
Arg4
>
struct
Callback4
{
typedef
CallbackRunner
<
Tuple4
<
Arg1
Arg2
Arg3
Arg4
>
>
Type
;
}
;
template
<
class
T
typename
Arg1
typename
Arg2
typename
Arg3
typename
Arg4
>
typename
Callback4
<
Arg1
Arg2
Arg3
Arg4
>
:
:
Type
*
NewCallback
(
T
*
object
void
(
T
:
:
*
method
)
(
Arg1
Arg2
Arg3
Arg4
)
)
{
return
new
CallbackImpl
<
T
void
(
T
:
:
*
)
(
Arg1
Arg2
Arg3
Arg4
)
Tuple4
<
Arg1
Arg2
Arg3
Arg4
>
>
(
object
method
)
;
}
template
<
typename
Arg1
typename
Arg2
typename
Arg3
typename
Arg4
typename
Arg5
>
struct
Callback5
{
typedef
CallbackRunner
<
Tuple5
<
Arg1
Arg2
Arg3
Arg4
Arg5
>
>
Type
;
}
;
template
<
class
T
typename
Arg1
typename
Arg2
typename
Arg3
typename
Arg4
typename
Arg5
>
typename
Callback5
<
Arg1
Arg2
Arg3
Arg4
Arg5
>
:
:
Type
*
NewCallback
(
T
*
object
void
(
T
:
:
*
method
)
(
Arg1
Arg2
Arg3
Arg4
Arg5
)
)
{
return
new
CallbackImpl
<
T
void
(
T
:
:
*
)
(
Arg1
Arg2
Arg3
Arg4
Arg5
)
Tuple5
<
Arg1
Arg2
Arg3
Arg4
Arg5
>
>
(
object
method
)
;
}
template
<
class
T
class
Method
class
Params
>
class
UnboundMethod
{
public
:
UnboundMethod
(
Method
m
Params
p
)
:
m_
(
m
)
p_
(
p
)
{
}
void
Run
(
T
*
obj
)
const
{
DispatchToMethod
(
obj
m_
p_
)
;
}
private
:
Method
m_
;
Params
p_
;
}
;
#
endif
