#
undef
_WIN32_WINNT
#
define
_WIN32_WINNT
0x0600
#
include
"
base
/
process_util
.
h
"
#
include
<
windows
.
h
>
#
include
<
winternl
.
h
>
#
include
<
psapi
.
h
>
#
include
<
io
.
h
>
#
ifndef
STDOUT_FILENO
#
define
STDOUT_FILENO
1
#
endif
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
histogram
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
win_util
.
h
"
#
include
<
algorithm
>
#
include
<
stdio
.
h
>
#
include
<
stdlib
.
h
>
namespace
{
typedef
BOOL
(
WINAPI
*
InitializeProcThreadAttributeListFn
)
(
LPPROC_THREAD_ATTRIBUTE_LIST
lpAttributeList
DWORD
dwAttributeCount
DWORD
dwFlags
PSIZE_T
lpSize
)
;
typedef
BOOL
(
WINAPI
*
DeleteProcThreadAttributeListFn
)
(
LPPROC_THREAD_ATTRIBUTE_LIST
lpAttributeList
)
;
typedef
BOOL
(
WINAPI
*
UpdateProcThreadAttributeFn
)
(
LPPROC_THREAD_ATTRIBUTE_LIST
lpAttributeList
DWORD
dwFlags
DWORD_PTR
Attribute
PVOID
lpValue
SIZE_T
cbSize
PVOID
lpPreviousValue
PSIZE_T
lpReturnSize
)
;
static
InitializeProcThreadAttributeListFn
InitializeProcThreadAttributeListPtr
;
static
DeleteProcThreadAttributeListFn
DeleteProcThreadAttributeListPtr
;
static
UpdateProcThreadAttributeFn
UpdateProcThreadAttributePtr
;
static
mozilla
:
:
EnvironmentLog
gProcessLog
(
"
MOZ_PROCESS_LOG
"
)
;
}
namespace
base
{
ProcessId
GetCurrentProcId
(
)
{
return
:
:
GetCurrentProcessId
(
)
;
}
ProcessHandle
GetCurrentProcessHandle
(
)
{
return
:
:
GetCurrentProcess
(
)
;
}
bool
OpenProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
{
ProcessHandle
result
=
OpenProcess
(
PROCESS_DUP_HANDLE
|
PROCESS_TERMINATE
|
PROCESS_QUERY_INFORMATION
|
SYNCHRONIZE
FALSE
pid
)
;
if
(
result
=
=
NULL
)
{
return
false
;
}
*
handle
=
result
;
return
true
;
}
bool
OpenPrivilegedProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
{
ProcessHandle
result
=
OpenProcess
(
PROCESS_DUP_HANDLE
|
PROCESS_TERMINATE
|
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
|
SYNCHRONIZE
FALSE
pid
)
;
if
(
result
=
=
NULL
)
{
return
false
;
}
*
handle
=
result
;
return
true
;
}
void
CloseProcessHandle
(
ProcessHandle
process
)
{
BOOL
ok
=
CloseHandle
(
process
)
;
DCHECK
(
ok
)
;
}
bool
GetProcIdViaGetProcessId
(
ProcessHandle
process
DWORD
*
id
)
{
typedef
DWORD
(
WINAPI
*
GetProcessIdFunction
)
(
HANDLE
)
;
static
GetProcessIdFunction
GetProcessIdPtr
=
NULL
;
static
bool
initialize_get_process_id
=
true
;
if
(
initialize_get_process_id
)
{
initialize_get_process_id
=
false
;
HMODULE
kernel32_handle
=
GetModuleHandle
(
L
"
kernel32
.
dll
"
)
;
if
(
!
kernel32_handle
)
{
NOTREACHED
(
)
;
return
false
;
}
GetProcessIdPtr
=
reinterpret_cast
<
GetProcessIdFunction
>
(
GetProcAddress
(
kernel32_handle
"
GetProcessId
"
)
)
;
}
if
(
!
GetProcessIdPtr
)
return
false
;
*
id
=
(
*
GetProcessIdPtr
)
(
process
)
;
return
true
;
}
bool
GetProcIdViaNtQueryInformationProcess
(
ProcessHandle
process
DWORD
*
id
)
{
typedef
NTSTATUS
(
WINAPI
*
NtQueryInformationProcessFunction
)
(
HANDLE
PROCESSINFOCLASS
PVOID
ULONG
PULONG
)
;
static
NtQueryInformationProcessFunction
NtQueryInformationProcessPtr
=
NULL
;
static
bool
initialize_query_information_process
=
true
;
if
(
initialize_query_information_process
)
{
initialize_query_information_process
=
false
;
HMODULE
ntdll_handle
=
GetModuleHandle
(
L
"
ntdll
.
dll
"
)
;
if
(
!
ntdll_handle
)
{
NOTREACHED
(
)
;
return
false
;
}
NtQueryInformationProcessPtr
=
reinterpret_cast
<
NtQueryInformationProcessFunction
>
(
GetProcAddress
(
ntdll_handle
"
NtQueryInformationProcess
"
)
)
;
}
if
(
!
NtQueryInformationProcessPtr
)
return
false
;
PROCESS_BASIC_INFORMATION
info
;
ULONG
bytes_returned
;
NTSTATUS
status
=
(
*
NtQueryInformationProcessPtr
)
(
process
ProcessBasicInformation
&
info
sizeof
info
&
bytes_returned
)
;
if
(
!
SUCCEEDED
(
status
)
|
|
(
bytes_returned
!
=
(
sizeof
info
)
)
)
return
false
;
*
id
=
static_cast
<
DWORD
>
(
info
.
UniqueProcessId
)
;
return
true
;
}
ProcessId
GetProcId
(
ProcessHandle
process
)
{
HANDLE
current_process
=
GetCurrentProcess
(
)
;
HANDLE
process_with_query_rights
;
if
(
DuplicateHandle
(
current_process
process
current_process
&
process_with_query_rights
PROCESS_QUERY_INFORMATION
false
0
)
)
{
DWORD
id
;
bool
success
=
GetProcIdViaGetProcessId
(
process_with_query_rights
&
id
)
|
|
GetProcIdViaNtQueryInformationProcess
(
process_with_query_rights
&
id
)
;
CloseHandle
(
process_with_query_rights
)
;
if
(
success
)
return
id
;
}
NOTREACHED
(
)
;
return
0
;
}
bool
IsInheritableHandle
(
HANDLE
handle
)
{
if
(
!
handle
)
return
false
;
if
(
handle
=
=
INVALID_HANDLE_VALUE
)
return
false
;
DWORD
handle_type
=
GetFileType
(
handle
)
;
return
handle_type
=
=
FILE_TYPE_DISK
|
|
handle_type
=
=
FILE_TYPE_PIPE
;
}
void
LoadThreadAttributeFunctions
(
)
{
HMODULE
kernel32
=
GetModuleHandle
(
L
"
kernel32
.
dll
"
)
;
InitializeProcThreadAttributeListPtr
=
reinterpret_cast
<
InitializeProcThreadAttributeListFn
>
(
GetProcAddress
(
kernel32
"
InitializeProcThreadAttributeList
"
)
)
;
DeleteProcThreadAttributeListPtr
=
reinterpret_cast
<
DeleteProcThreadAttributeListFn
>
(
GetProcAddress
(
kernel32
"
DeleteProcThreadAttributeList
"
)
)
;
UpdateProcThreadAttributePtr
=
reinterpret_cast
<
UpdateProcThreadAttributeFn
>
(
GetProcAddress
(
kernel32
"
UpdateProcThreadAttribute
"
)
)
;
}
LPPROC_THREAD_ATTRIBUTE_LIST
CreateThreadAttributeList
(
HANDLE
*
handlesToInherit
int
handleCount
)
{
if
(
!
InitializeProcThreadAttributeListPtr
|
|
!
DeleteProcThreadAttributeListPtr
|
|
!
UpdateProcThreadAttributePtr
)
LoadThreadAttributeFunctions
(
)
;
if
(
!
InitializeProcThreadAttributeListPtr
|
|
!
DeleteProcThreadAttributeListPtr
|
|
!
UpdateProcThreadAttributePtr
)
return
NULL
;
SIZE_T
threadAttrSize
;
LPPROC_THREAD_ATTRIBUTE_LIST
lpAttributeList
=
NULL
;
if
(
!
(
*
InitializeProcThreadAttributeListPtr
)
(
NULL
1
0
&
threadAttrSize
)
&
&
GetLastError
(
)
!
=
ERROR_INSUFFICIENT_BUFFER
)
goto
fail
;
lpAttributeList
=
reinterpret_cast
<
LPPROC_THREAD_ATTRIBUTE_LIST
>
(
malloc
(
threadAttrSize
)
)
;
if
(
!
lpAttributeList
|
|
!
(
*
InitializeProcThreadAttributeListPtr
)
(
lpAttributeList
1
0
&
threadAttrSize
)
)
goto
fail
;
if
(
!
(
*
UpdateProcThreadAttributePtr
)
(
lpAttributeList
0
PROC_THREAD_ATTRIBUTE_HANDLE_LIST
handlesToInherit
sizeof
(
handlesToInherit
[
0
]
)
*
handleCount
NULL
NULL
)
)
{
(
*
DeleteProcThreadAttributeListPtr
)
(
lpAttributeList
)
;
goto
fail
;
}
return
lpAttributeList
;
fail
:
if
(
lpAttributeList
)
free
(
lpAttributeList
)
;
return
NULL
;
}
void
FreeThreadAttributeList
(
LPPROC_THREAD_ATTRIBUTE_LIST
lpAttributeList
)
{
(
*
DeleteProcThreadAttributeListPtr
)
(
lpAttributeList
)
;
free
(
lpAttributeList
)
;
}
static
size_t
ParseEnvLine
(
const
NativeEnvironmentString
:
:
value_type
*
input
NativeEnvironmentString
*
key
)
{
size_t
cur
=
0
;
while
(
input
[
cur
]
&
&
input
[
cur
]
!
=
'
=
'
)
cur
+
+
;
*
key
=
NativeEnvironmentString
(
&
input
[
0
]
cur
)
;
while
(
input
[
cur
]
)
cur
+
+
;
return
cur
+
1
;
}
std
:
:
wstring
AlterEnvironment
(
const
wchar_t
*
env
const
EnvironmentMap
&
changes
)
{
std
:
:
wstring
result
;
size_t
cur_env
=
0
;
std
:
:
wstring
key
;
while
(
env
[
cur_env
]
)
{
const
wchar_t
*
line
=
&
env
[
cur_env
]
;
size_t
line_length
=
ParseEnvLine
(
line
&
key
)
;
EnvironmentMap
:
:
const_iterator
found_change
=
changes
.
find
(
key
)
;
if
(
found_change
=
=
changes
.
end
(
)
)
result
.
append
(
line
line_length
)
;
cur_env
+
=
line_length
;
}
for
(
EnvironmentMap
:
:
const_iterator
i
=
changes
.
begin
(
)
;
i
!
=
changes
.
end
(
)
;
+
+
i
)
{
if
(
!
i
-
>
second
.
empty
(
)
)
{
result
.
append
(
i
-
>
first
)
;
result
.
push_back
(
'
=
'
)
;
result
.
append
(
i
-
>
second
)
;
result
.
push_back
(
0
)
;
}
}
if
(
result
.
empty
(
)
)
result
.
push_back
(
0
)
;
result
.
push_back
(
0
)
;
return
result
;
}
bool
LaunchApp
(
const
std
:
:
wstring
&
cmdline
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
DWORD
dwCreationFlags
=
0
;
BOOL
bInheritHandles
=
FALSE
;
STARTUPINFOEX
startup_info_ex
;
ZeroMemory
(
&
startup_info_ex
sizeof
(
startup_info_ex
)
)
;
STARTUPINFO
&
startup_info
=
startup_info_ex
.
StartupInfo
;
startup_info
.
cb
=
sizeof
(
startup_info
)
;
startup_info
.
dwFlags
=
STARTF_USESHOWWINDOW
|
STARTF_FORCEOFFFEEDBACK
;
startup_info
.
wShowWindow
=
options
.
start_hidden
?
SW_HIDE
:
SW_SHOW
;
LPPROC_THREAD_ATTRIBUTE_LIST
lpAttributeList
=
NULL
;
std
:
:
vector
<
HANDLE
>
handlesToInherit
;
for
(
HANDLE
h
:
options
.
handles_to_inherit
)
{
if
(
SetHandleInformation
(
h
HANDLE_FLAG_INHERIT
HANDLE_FLAG_INHERIT
)
=
=
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
SetHandleInformation
failed
"
)
;
return
false
;
}
handlesToInherit
.
push_back
(
h
)
;
}
HANDLE
stdOut
=
:
:
GetStdHandle
(
STD_OUTPUT_HANDLE
)
;
HANDLE
stdErr
=
:
:
GetStdHandle
(
STD_ERROR_HANDLE
)
;
if
(
IsInheritableHandle
(
stdOut
)
)
handlesToInherit
.
push_back
(
stdOut
)
;
if
(
stdErr
!
=
stdOut
&
&
IsInheritableHandle
(
stdErr
)
)
handlesToInherit
.
push_back
(
stdErr
)
;
if
(
!
handlesToInherit
.
empty
(
)
)
{
lpAttributeList
=
CreateThreadAttributeList
(
handlesToInherit
.
data
(
)
handlesToInherit
.
size
(
)
)
;
if
(
lpAttributeList
)
{
startup_info
.
cb
=
sizeof
(
startup_info_ex
)
;
startup_info
.
dwFlags
|
=
STARTF_USESTDHANDLES
;
startup_info
.
hStdOutput
=
stdOut
;
startup_info
.
hStdError
=
stdErr
;
startup_info
.
hStdInput
=
INVALID_HANDLE_VALUE
;
startup_info_ex
.
lpAttributeList
=
lpAttributeList
;
dwCreationFlags
|
=
EXTENDED_STARTUPINFO_PRESENT
;
bInheritHandles
=
TRUE
;
}
}
dwCreationFlags
|
=
CREATE_UNICODE_ENVIRONMENT
;
LPTCH
original_environment
=
GetEnvironmentStrings
(
)
;
base
:
:
NativeEnvironmentString
new_environment
=
AlterEnvironment
(
original_environment
options
.
env_map
)
;
FreeEnvironmentStrings
(
original_environment
)
;
LPVOID
new_env_ptr
=
(
void
*
)
new_environment
.
data
(
)
;
PROCESS_INFORMATION
process_info
;
BOOL
createdOK
=
CreateProcess
(
NULL
const_cast
<
wchar_t
*
>
(
cmdline
.
c_str
(
)
)
NULL
NULL
bInheritHandles
dwCreationFlags
new_env_ptr
NULL
&
startup_info
&
process_info
)
;
if
(
lpAttributeList
)
FreeThreadAttributeList
(
lpAttributeList
)
;
if
(
!
createdOK
)
{
DLOG
(
WARNING
)
<
<
"
CreateProcess
Failed
:
"
<
<
GetLastError
(
)
;
return
false
;
}
gProcessLog
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
(
%
S
)
\
n
"
GetCurrentProcId
(
)
process_info
.
dwProcessId
cmdline
.
c_str
(
)
)
;
CloseHandle
(
process_info
.
hThread
)
;
if
(
options
.
wait
)
WaitForSingleObject
(
process_info
.
hProcess
INFINITE
)
;
if
(
process_handle
)
{
*
process_handle
=
process_info
.
hProcess
;
}
else
{
CloseHandle
(
process_info
.
hProcess
)
;
}
return
true
;
}
bool
LaunchApp
(
const
CommandLine
&
cl
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
return
LaunchApp
(
cl
.
command_line_string
(
)
options
process_handle
)
;
}
bool
KillProcess
(
ProcessHandle
process
int
exit_code
)
{
if
(
!
process
|
|
process
=
=
INVALID_HANDLE_VALUE
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
base
:
:
KillProcess
refusing
to
terminate
process
handle
"
<
<
process
;
return
false
;
}
bool
result
=
(
TerminateProcess
(
process
exit_code
)
!
=
FALSE
)
;
if
(
!
result
)
{
DLOG
(
ERROR
)
<
<
"
Unable
to
terminate
process
:
"
<
<
GetLastError
(
)
;
}
return
result
;
}
bool
DidProcessCrash
(
bool
*
child_exited
ProcessHandle
handle
)
{
DWORD
exitcode
=
0
;
if
(
child_exited
)
*
child_exited
=
true
;
if
(
!
:
:
GetExitCodeProcess
(
handle
&
exitcode
)
)
{
NOTREACHED
(
)
;
return
false
;
}
if
(
exitcode
=
=
STILL_ACTIVE
)
{
NOTREACHED
(
)
;
return
false
;
}
if
(
exitcode
=
=
PROCESS_END_NORMAL_TERMINATON
|
|
exitcode
=
=
PROCESS_END_KILLED_BY_USER
|
|
exitcode
=
=
PROCESS_END_PROCESS_WAS_HUNG
|
|
exitcode
=
=
0xC0000354
|
|
exitcode
=
=
0xC000013A
|
|
exitcode
=
=
0x40010004
)
{
return
false
;
}
return
true
;
}
}
namespace
mozilla
{
EnvironmentLog
:
:
EnvironmentLog
(
const
char
*
varname
size_t
len
)
{
wchar_t
wvarname
[
len
]
;
std
:
:
copy
(
varname
varname
+
len
wvarname
)
;
const
wchar_t
*
e
=
_wgetenv
(
wvarname
)
;
if
(
e
&
&
*
e
)
{
fname_
=
e
;
}
}
void
EnvironmentLog
:
:
print
(
const
char
*
format
.
.
.
)
{
if
(
!
fname_
.
size
(
)
)
return
;
FILE
*
f
;
if
(
fname_
.
compare
(
L
"
-
"
)
=
=
0
)
{
f
=
fdopen
(
dup
(
STDOUT_FILENO
)
"
a
"
)
;
}
else
{
f
=
_wfopen
(
fname_
.
c_str
(
)
L
"
a
"
)
;
}
if
(
!
f
)
return
;
va_list
a
;
va_start
(
a
format
)
;
vfprintf
(
f
format
a
)
;
va_end
(
a
)
;
fclose
(
f
)
;
}
}
