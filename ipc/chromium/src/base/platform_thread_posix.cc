#
include
"
base
/
platform_thread
.
h
"
#
include
<
errno
.
h
>
#
include
<
sched
.
h
>
#
if
defined
(
XP_DARWIN
)
#
include
<
mach
/
mach
.
h
>
#
elif
defined
(
XP_NETBSD
)
#
include
<
lwp
.
h
>
#
elif
defined
(
XP_LINUX
)
#
include
<
sys
/
syscall
.
h
>
#
include
<
sys
/
prctl
.
h
>
#
endif
#
if
!
defined
(
XP_DARWIN
)
#
include
<
unistd
.
h
>
#
endif
#
if
(
defined
(
__DragonFly__
)
|
|
defined
(
XP_FREEBSD
)
|
|
defined
(
XP_OPENBSD
)
)
&
&
\
!
defined
(
__GLIBC__
)
#
include
<
pthread_np
.
h
>
#
endif
#
include
"
nsThreadUtils
.
h
"
#
if
defined
(
XP_DARWIN
)
namespace
base
{
void
InitThreading
(
)
;
}
#
endif
static
void
*
ThreadFunc
(
void
*
closure
)
{
PlatformThread
:
:
Delegate
*
delegate
=
static_cast
<
PlatformThread
:
:
Delegate
*
>
(
closure
)
;
delegate
-
>
ThreadMain
(
)
;
return
NULL
;
}
PlatformThreadId
PlatformThread
:
:
CurrentId
(
)
{
#
if
defined
(
XP_DARWIN
)
mach_port_t
port
=
mach_thread_self
(
)
;
mach_port_deallocate
(
mach_task_self
(
)
port
)
;
return
port
;
#
elif
defined
(
XP_LINUX
)
return
syscall
(
__NR_gettid
)
;
#
elif
defined
(
XP_OPENBSD
)
|
|
defined
(
XP_SOLARIS
)
|
|
defined
(
__GLIBC__
)
return
(
intptr_t
)
(
pthread_self
(
)
)
;
#
elif
defined
(
XP_NETBSD
)
return
_lwp_self
(
)
;
#
elif
defined
(
__DragonFly__
)
return
lwp_gettid
(
)
;
#
elif
defined
(
XP_FREEBSD
)
return
pthread_getthreadid_np
(
)
;
#
endif
}
void
PlatformThread
:
:
YieldCurrentThread
(
)
{
sched_yield
(
)
;
}
void
PlatformThread
:
:
Sleep
(
int
duration_ms
)
{
struct
timespec
sleep_time
remaining
;
sleep_time
.
tv_sec
=
duration_ms
/
1000
;
duration_ms
-
=
sleep_time
.
tv_sec
*
1000
;
sleep_time
.
tv_nsec
=
duration_ms
*
1000
*
1000
;
while
(
nanosleep
(
&
sleep_time
&
remaining
)
=
=
-
1
&
&
errno
=
=
EINTR
)
sleep_time
=
remaining
;
}
#
ifndef
XP_DARWIN
void
PlatformThread
:
:
SetName
(
const
char
*
name
)
{
if
(
PlatformThread
:
:
CurrentId
(
)
=
=
getpid
(
)
)
return
;
NS_SetCurrentThreadName
(
name
)
;
}
#
endif
namespace
{
bool
CreateThread
(
size_t
stack_size
bool
joinable
PlatformThread
:
:
Delegate
*
delegate
PlatformThreadHandle
*
thread_handle
)
{
#
if
defined
(
XP_DARWIN
)
base
:
:
InitThreading
(
)
;
#
endif
bool
success
=
false
;
pthread_attr_t
attributes
;
pthread_attr_init
(
&
attributes
)
;
if
(
!
joinable
)
{
pthread_attr_setdetachstate
(
&
attributes
PTHREAD_CREATE_DETACHED
)
;
}
if
(
stack_size
=
=
0
)
stack_size
=
nsIThreadManager
:
:
DEFAULT_STACK_SIZE
;
pthread_attr_setstacksize
(
&
attributes
stack_size
)
;
success
=
!
pthread_create
(
thread_handle
&
attributes
ThreadFunc
delegate
)
;
pthread_attr_destroy
(
&
attributes
)
;
return
success
;
}
}
bool
PlatformThread
:
:
Create
(
size_t
stack_size
Delegate
*
delegate
PlatformThreadHandle
*
thread_handle
)
{
return
CreateThread
(
stack_size
true
delegate
thread_handle
)
;
}
bool
PlatformThread
:
:
CreateNonJoinable
(
size_t
stack_size
Delegate
*
delegate
)
{
PlatformThreadHandle
unused
;
bool
result
=
CreateThread
(
stack_size
false
delegate
&
unused
)
;
return
result
;
}
void
PlatformThread
:
:
Join
(
PlatformThreadHandle
thread_handle
)
{
pthread_join
(
thread_handle
NULL
)
;
}
