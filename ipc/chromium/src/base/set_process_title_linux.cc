#
include
"
content
/
common
/
set_process_title_linux
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
stddef
.
h
>
#
include
<
stdint
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
unistd
.
h
>
#
include
<
string
>
#
include
<
vector
>
#
include
"
base
/
files
/
file_util
.
h
"
#
include
"
base
/
no_destructor
.
h
"
extern
char
*
*
environ
;
static
const
char
*
g_orig_argv0
=
nullptr
;
static
char
*
g_argv_start
=
nullptr
;
static
char
*
g_argv_end
=
nullptr
;
static
char
*
g_envp_end
=
nullptr
;
void
setproctitle
(
const
char
*
fmt
.
.
.
)
{
va_list
ap
;
if
(
!
g_orig_argv0
|
|
!
fmt
)
return
;
const
size_t
avail_size
=
g_envp_end
-
g_argv_start
-
1
;
static
const
bool
buggy_kernel
=
[
avail_size
]
(
)
{
memset
(
g_argv_start
0
avail_size
+
1
)
;
g_argv_end
[
-
1
]
=
'
.
'
;
std
:
:
string
cmdline
;
if
(
!
base
:
:
ReadFileToString
(
base
:
:
FilePath
(
"
/
proc
/
self
/
cmdline
"
)
&
cmdline
)
)
{
return
false
;
}
return
cmdline
.
size
(
)
>
=
2
;
}
(
)
;
memset
(
g_argv_start
0
avail_size
+
1
)
;
size_t
size
;
va_start
(
ap
fmt
)
;
if
(
fmt
[
0
]
=
=
'
-
'
)
{
size
=
vsnprintf
(
g_argv_start
avail_size
&
fmt
[
1
]
ap
)
;
}
else
{
size
=
snprintf
(
g_argv_start
avail_size
"
%
s
"
g_orig_argv0
)
;
if
(
size
<
avail_size
)
size
+
=
vsnprintf
(
&
g_argv_start
[
size
]
avail_size
-
size
fmt
ap
)
;
}
va_end
(
ap
)
;
const
size_t
argv_size
=
g_argv_end
-
g_argv_start
-
1
;
if
(
!
buggy_kernel
&
&
size
<
argv_size
)
g_argv_end
[
-
1
]
=
'
.
'
;
}
void
setproctitle_init
(
const
char
*
*
main_argv
)
{
static
bool
init_called
=
false
;
if
(
init_called
)
return
;
init_called
=
true
;
if
(
!
main_argv
)
return
;
char
*
*
argv
=
const_cast
<
char
*
*
>
(
main_argv
)
;
char
*
argv_start
=
argv
[
0
]
;
char
*
p
=
argv_start
;
for
(
size_t
i
=
0
;
argv
[
i
]
;
+
+
i
)
{
if
(
p
!
=
argv
[
i
]
)
return
;
p
+
=
strlen
(
p
)
+
1
;
}
char
*
argv_end
=
p
;
size_t
environ_size
=
0
;
for
(
size_t
i
=
0
;
environ
[
i
]
;
+
+
i
+
+
environ_size
)
{
if
(
p
!
=
environ
[
i
]
)
return
;
p
+
=
strlen
(
p
)
+
1
;
}
char
*
envp_end
=
p
;
static
base
:
:
NoDestructor
<
std
:
:
vector
<
std
:
:
string
>
>
environ_copy
(
environ_size
)
;
for
(
size_t
i
=
0
;
environ
[
i
]
;
+
+
i
)
{
(
*
environ_copy
)
[
i
]
=
environ
[
i
]
;
environ
[
i
]
=
&
(
*
environ_copy
)
[
i
]
[
0
]
;
}
if
(
!
argv
[
0
]
)
return
;
static
base
:
:
NoDestructor
<
std
:
:
string
>
argv0_storage
(
argv
[
0
]
)
;
g_orig_argv0
=
argv0_storage
-
>
data
(
)
;
g_argv_start
=
argv_start
;
g_argv_end
=
argv_end
;
g_envp_end
=
envp_end
;
}
