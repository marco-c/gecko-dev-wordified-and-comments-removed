#
include
<
dirent
.
h
>
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
signal
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
sys
/
resource
.
h
>
#
include
<
sys
/
time
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
<
limits
>
#
include
<
set
>
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
platform_thread
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
sys_info
.
h
"
#
include
"
base
/
time
.
h
"
#
include
"
base
/
waitable_event
.
h
"
#
include
"
base
/
dir_reader_posix
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prmem
.
h
"
const
int
kMicrosecondsPerSecond
=
1000000
;
namespace
base
{
ProcessId
GetCurrentProcId
(
)
{
return
getpid
(
)
;
}
ProcessHandle
GetCurrentProcessHandle
(
)
{
return
GetCurrentProcId
(
)
;
}
bool
OpenProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
{
*
handle
=
pid
;
return
true
;
}
bool
OpenPrivilegedProcessHandle
(
ProcessId
pid
ProcessHandle
*
handle
)
{
return
OpenProcessHandle
(
pid
handle
)
;
}
void
CloseProcessHandle
(
ProcessHandle
process
)
{
return
;
}
ProcessId
GetProcId
(
ProcessHandle
process
)
{
return
process
;
}
bool
KillProcess
(
ProcessHandle
process_id
int
exit_code
bool
wait
)
{
bool
result
=
kill
(
process_id
SIGTERM
)
=
=
0
;
if
(
!
result
&
&
(
errno
=
=
ESRCH
)
)
{
result
=
true
;
wait
=
false
;
}
if
(
result
&
&
wait
)
{
int
tries
=
60
;
bool
exited
=
false
;
while
(
tries
-
-
>
0
)
{
int
pid
=
HANDLE_EINTR
(
waitpid
(
process_id
NULL
WNOHANG
)
)
;
if
(
pid
=
=
process_id
)
{
exited
=
true
;
break
;
}
else
if
(
errno
=
=
ECHILD
)
{
exited
=
true
;
break
;
}
sleep
(
1
)
;
}
if
(
!
exited
)
{
result
=
kill
(
process_id
SIGKILL
)
=
=
0
;
}
}
if
(
!
result
)
DLOG
(
ERROR
)
<
<
"
Unable
to
terminate
process
.
"
;
return
result
;
}
#
ifdef
ANDROID
typedef
unsigned
long
int
rlim_t
;
#
endif
class
ScopedDIRClose
{
public
:
inline
void
operator
(
)
(
DIR
*
x
)
const
{
if
(
x
)
{
closedir
(
x
)
;
}
}
}
;
typedef
mozilla
:
:
UniquePtr
<
DIR
ScopedDIRClose
>
ScopedDIR
;
void
CloseSuperfluousFds
(
const
base
:
:
InjectiveMultimap
&
saved_mapping
)
{
#
if
defined
(
ANDROID
)
static
const
rlim_t
kSystemDefaultMaxFds
=
1024
;
static
const
char
kFDDir
[
]
=
"
/
proc
/
self
/
fd
"
;
#
elif
defined
(
OS_LINUX
)
|
|
defined
(
OS_SOLARIS
)
static
const
rlim_t
kSystemDefaultMaxFds
=
8192
;
static
const
char
kFDDir
[
]
=
"
/
proc
/
self
/
fd
"
;
#
elif
defined
(
OS_MACOSX
)
static
const
rlim_t
kSystemDefaultMaxFds
=
256
;
static
const
char
kFDDir
[
]
=
"
/
dev
/
fd
"
;
#
elif
defined
(
OS_BSD
)
static
const
rlim_t
kSystemDefaultMaxFds
=
1024
;
static
const
char
kFDDir
[
]
=
"
/
dev
/
fd
"
;
#
endif
struct
rlimit
nofile
;
rlim_t
max_fds
;
if
(
getrlimit
(
RLIMIT_NOFILE
&
nofile
)
)
{
max_fds
=
kSystemDefaultMaxFds
;
DLOG
(
ERROR
)
<
<
"
getrlimit
(
RLIMIT_NOFILE
)
failed
:
"
<
<
errno
;
}
else
{
max_fds
=
nofile
.
rlim_cur
;
}
if
(
max_fds
>
INT_MAX
)
max_fds
=
INT_MAX
;
DirReaderPosix
fd_dir
(
kFDDir
)
;
if
(
!
fd_dir
.
IsValid
(
)
)
{
for
(
rlim_t
i
=
0
;
i
<
max_fds
;
+
+
i
)
{
const
int
fd
=
static_cast
<
int
>
(
i
)
;
if
(
fd
=
=
STDIN_FILENO
|
|
fd
=
=
STDOUT_FILENO
|
|
fd
=
=
STDERR_FILENO
)
continue
;
InjectiveMultimap
:
:
const_iterator
j
;
for
(
j
=
saved_mapping
.
begin
(
)
;
j
!
=
saved_mapping
.
end
(
)
;
j
+
+
)
{
if
(
fd
=
=
j
-
>
dest
)
break
;
}
if
(
j
!
=
saved_mapping
.
end
(
)
)
continue
;
HANDLE_EINTR
(
close
(
fd
)
)
;
}
return
;
}
const
int
dir_fd
=
fd_dir
.
fd
(
)
;
for
(
;
fd_dir
.
Next
(
)
;
)
{
if
(
fd_dir
.
name
(
)
[
0
]
=
=
'
.
'
)
continue
;
char
*
endptr
;
errno
=
0
;
const
long
int
fd
=
strtol
(
fd_dir
.
name
(
)
&
endptr
10
)
;
if
(
fd_dir
.
name
(
)
[
0
]
=
=
0
|
|
*
endptr
|
|
fd
<
0
|
|
errno
)
continue
;
if
(
fd
=
=
STDIN_FILENO
|
|
fd
=
=
STDOUT_FILENO
|
|
fd
=
=
STDERR_FILENO
)
continue
;
InjectiveMultimap
:
:
const_iterator
i
;
for
(
i
=
saved_mapping
.
begin
(
)
;
i
!
=
saved_mapping
.
end
(
)
;
i
+
+
)
{
if
(
fd
=
=
i
-
>
dest
)
break
;
}
if
(
i
!
=
saved_mapping
.
end
(
)
)
continue
;
if
(
fd
=
=
dir_fd
)
continue
;
if
(
fd
<
static_cast
<
int
>
(
max_fds
)
)
{
int
ret
=
HANDLE_EINTR
(
close
(
fd
)
)
;
if
(
ret
!
=
0
)
{
DLOG
(
ERROR
)
<
<
"
Problem
closing
fd
"
;
}
}
}
}
void
SetAllFDsToCloseOnExec
(
)
{
#
if
defined
(
OS_LINUX
)
|
|
defined
(
OS_SOLARIS
)
const
char
fd_dir
[
]
=
"
/
proc
/
self
/
fd
"
;
#
elif
defined
(
OS_MACOSX
)
|
|
defined
(
OS_BSD
)
const
char
fd_dir
[
]
=
"
/
dev
/
fd
"
;
#
endif
ScopedDIR
dir_closer
(
opendir
(
fd_dir
)
)
;
DIR
*
dir
=
dir_closer
.
get
(
)
;
if
(
NULL
=
=
dir
)
{
DLOG
(
ERROR
)
<
<
"
Unable
to
open
"
<
<
fd_dir
;
return
;
}
struct
dirent
*
ent
;
while
(
(
ent
=
readdir
(
dir
)
)
)
{
if
(
ent
-
>
d_name
[
0
]
=
=
'
.
'
)
continue
;
int
i
=
atoi
(
ent
-
>
d_name
)
;
if
(
i
<
=
STDERR_FILENO
)
continue
;
int
flags
=
fcntl
(
i
F_GETFD
)
;
if
(
(
flags
=
=
-
1
)
|
|
(
fcntl
(
i
F_SETFD
flags
|
FD_CLOEXEC
)
=
=
-
1
)
)
{
DLOG
(
ERROR
)
<
<
"
fcntl
failure
.
"
;
}
}
}
bool
DidProcessCrash
(
bool
*
child_exited
ProcessHandle
handle
)
{
int
status
;
const
int
result
=
HANDLE_EINTR
(
waitpid
(
handle
&
status
WNOHANG
)
)
;
if
(
result
=
=
-
1
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
waitpid
failed
pid
:
"
<
<
handle
<
<
"
errno
:
"
<
<
errno
;
if
(
child_exited
)
*
child_exited
=
true
;
return
false
;
}
else
if
(
result
=
=
0
)
{
if
(
child_exited
)
*
child_exited
=
false
;
return
false
;
}
if
(
child_exited
)
*
child_exited
=
true
;
if
(
WIFSIGNALED
(
status
)
)
{
switch
(
WTERMSIG
(
status
)
)
{
case
SIGSYS
:
case
SIGSEGV
:
case
SIGILL
:
case
SIGABRT
:
case
SIGFPE
:
return
true
;
default
:
return
false
;
}
}
if
(
WIFEXITED
(
status
)
)
return
WEXITSTATUS
(
status
)
!
=
0
;
return
false
;
}
namespace
{
int64_t
TimeValToMicroseconds
(
const
struct
timeval
&
tv
)
{
return
tv
.
tv_sec
*
kMicrosecondsPerSecond
+
tv
.
tv_usec
;
}
}
void
FreeEnvVarsArray
:
:
operator
(
)
(
char
*
*
array
)
{
for
(
char
*
*
varPtr
=
array
;
*
varPtr
!
=
nullptr
;
+
+
varPtr
)
{
free
(
*
varPtr
)
;
}
delete
[
]
array
;
}
EnvironmentArray
BuildEnvironmentArray
(
const
environment_map
&
env_vars_to_set
)
{
base
:
:
environment_map
combined_env_vars
=
env_vars_to_set
;
char
*
*
environ
=
PR_DuplicateEnvironment
(
)
;
for
(
char
*
*
varPtr
=
environ
;
*
varPtr
!
=
nullptr
;
+
+
varPtr
)
{
std
:
:
string
varString
=
*
varPtr
;
size_t
equalPos
=
varString
.
find_first_of
(
'
=
'
)
;
std
:
:
string
varName
=
varString
.
substr
(
0
equalPos
)
;
std
:
:
string
varValue
=
varString
.
substr
(
equalPos
+
1
)
;
if
(
combined_env_vars
.
find
(
varName
)
=
=
combined_env_vars
.
end
(
)
)
{
combined_env_vars
[
varName
]
=
varValue
;
}
PR_Free
(
*
varPtr
)
;
}
PR_Free
(
environ
)
;
EnvironmentArray
array
(
new
char
*
[
combined_env_vars
.
size
(
)
+
1
]
)
;
size_t
i
=
0
;
for
(
const
auto
&
key_val
:
combined_env_vars
)
{
std
:
:
string
entry
(
key_val
.
first
)
;
entry
+
=
"
=
"
;
entry
+
=
key_val
.
second
;
array
[
i
]
=
strdup
(
entry
.
c_str
(
)
)
;
i
+
+
;
}
array
[
i
]
=
nullptr
;
return
array
;
}
}
