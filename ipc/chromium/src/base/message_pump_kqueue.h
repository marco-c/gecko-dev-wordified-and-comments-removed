#
ifndef
BASE_MESSAGE_PUMP_KQUEUE_H_
#
define
BASE_MESSAGE_PUMP_KQUEUE_H_
#
include
<
mach
/
mach
.
h
>
#
include
<
stdint
.
h
>
#
include
<
sys
/
event
.
h
>
#
include
<
vector
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
time
.
h
"
#
include
"
base
/
message_pump
.
h
"
namespace
base
{
class
MessagePumpKqueue
:
public
MessagePump
{
public
:
class
Watcher
{
public
:
virtual
~
Watcher
(
)
{
}
virtual
void
OnFileCanReadWithoutBlocking
(
int
fd
)
=
0
;
virtual
void
OnFileCanWriteWithoutBlocking
(
int
fd
)
=
0
;
}
;
class
FileDescriptorWatcher
{
public
:
explicit
FileDescriptorWatcher
(
)
;
~
FileDescriptorWatcher
(
)
;
bool
StopWatchingFileDescriptor
(
)
;
protected
:
friend
class
MessagePumpKqueue
;
void
Init
(
MessagePumpKqueue
*
pump
int
fd
int
mode
Watcher
*
watcher
)
;
void
Reset
(
)
;
int
fd
(
)
{
return
fd_
;
}
int
mode
(
)
{
return
mode_
;
}
Watcher
*
watcher
(
)
{
return
watcher_
;
}
private
:
int
fd_
=
-
1
;
int
mode_
=
0
;
Watcher
*
watcher_
=
nullptr
;
RefPtr
<
MessagePumpKqueue
>
pump_
;
DISALLOW_COPY_AND_ASSIGN
(
FileDescriptorWatcher
)
;
}
;
enum
Mode
{
WATCH_READ
=
1
<
<
0
WATCH_WRITE
=
1
<
<
1
WATCH_READ_WRITE
=
WATCH_READ
|
WATCH_WRITE
}
;
class
MachPortWatcher
{
public
:
virtual
~
MachPortWatcher
(
)
{
}
virtual
void
OnMachMessageReceived
(
mach_port_t
port
)
=
0
;
}
;
class
MachPortWatchController
{
public
:
explicit
MachPortWatchController
(
)
;
~
MachPortWatchController
(
)
;
bool
StopWatchingMachPort
(
)
;
protected
:
friend
class
MessagePumpKqueue
;
void
Init
(
MessagePumpKqueue
*
pump
mach_port_t
port
MachPortWatcher
*
watcher
)
;
void
Reset
(
)
;
mach_port_t
port
(
)
{
return
port_
;
}
MachPortWatcher
*
watcher
(
)
{
return
watcher_
;
}
private
:
mach_port_t
port_
=
MACH_PORT_NULL
;
MachPortWatcher
*
watcher_
=
nullptr
;
RefPtr
<
MessagePumpKqueue
>
pump_
;
DISALLOW_COPY_AND_ASSIGN
(
MachPortWatchController
)
;
}
;
MessagePumpKqueue
(
)
;
~
MessagePumpKqueue
(
)
override
;
void
Run
(
Delegate
*
delegate
)
override
;
void
Quit
(
)
override
;
void
ScheduleWork
(
)
override
;
void
ScheduleDelayedWork
(
const
TimeTicks
&
delayed_work_time
)
override
;
bool
WatchMachReceivePort
(
mach_port_t
port
MachPortWatchController
*
controller
MachPortWatcher
*
delegate
)
;
bool
WatchFileDescriptor
(
int
fd
bool
persistent
int
mode
FileDescriptorWatcher
*
controller
Watcher
*
delegate
)
;
private
:
bool
StopWatchingMachPort
(
MachPortWatchController
*
controller
)
;
bool
StopWatchingFileDescriptor
(
FileDescriptorWatcher
*
controller
)
;
bool
DoInternalWork
(
Delegate
*
delegate
TimeTicks
*
delayed_work_time
)
;
bool
ProcessEvents
(
Delegate
*
delegate
int
count
)
;
void
UpdateWakeupTimer
(
const
base
:
:
TimeTicks
&
wakeup_time
)
;
mozilla
:
:
UniqueMachReceiveRight
wakeup_
;
mach_msg_empty_rcv_t
wakeup_buffer_
{
}
;
nsTHashMap
<
uint64_t
FileDescriptorWatcher
*
>
fd_controllers_
;
uint64_t
next_fd_controller_id_
=
0
;
nsTHashMap
<
mach_port_name_t
MachPortWatchController
*
>
port_controllers_
;
mozilla
:
:
UniqueFileHandle
kqueue_
;
bool
keep_running_
=
true
;
base
:
:
TimeTicks
delayed_work_time_
;
size_t
event_count_
=
1
;
std
:
:
vector
<
kevent64_s
>
events_
{
event_count_
}
;
DISALLOW_COPY_AND_ASSIGN
(
MessagePumpKqueue
)
;
}
;
}
#
endif
