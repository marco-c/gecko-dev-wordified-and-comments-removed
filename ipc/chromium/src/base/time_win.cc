#
include
"
base
/
time
.
h
"
#
ifndef
__MINGW32__
#
pragma
comment
(
lib
"
winmm
.
lib
"
)
#
endif
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
using
base
:
:
Time
;
using
base
:
:
TimeDelta
;
using
base
:
:
TimeTicks
;
using
mozilla
:
:
BitwiseCast
;
namespace
{
int64_t
FileTimeToMicroseconds
(
const
FILETIME
&
ft
)
{
return
BitwiseCast
<
int64_t
>
(
ft
)
/
10
;
}
void
MicrosecondsToFileTime
(
int64_t
us
FILETIME
*
ft
)
{
DCHECK
(
us
>
=
0
)
<
<
"
Time
is
less
than
0
negative
values
are
not
"
"
representable
in
FILETIME
"
;
*
ft
=
BitwiseCast
<
FILETIME
>
(
us
*
10
)
;
}
int64_t
CurrentWallclockMicroseconds
(
)
{
FILETIME
ft
;
:
:
GetSystemTimeAsFileTime
(
&
ft
)
;
return
FileTimeToMicroseconds
(
ft
)
;
}
const
int
kMaxMillisecondsToAvoidDrift
=
60
*
Time
:
:
kMillisecondsPerSecond
;
int64_t
initial_time
=
0
;
TimeTicks
initial_ticks
;
void
InitializeClock
(
)
{
initial_ticks
=
TimeTicks
:
:
Now
(
)
;
initial_time
=
CurrentWallclockMicroseconds
(
)
;
}
}
const
int64_t
Time
:
:
kTimeTToMicrosecondsOffset
=
GG_INT64_C
(
11644473600000000
)
;
Time
Time
:
:
Now
(
)
{
if
(
initial_time
=
=
0
)
InitializeClock
(
)
;
while
(
true
)
{
TimeTicks
ticks
=
TimeTicks
:
:
Now
(
)
;
TimeDelta
elapsed
=
ticks
-
initial_ticks
;
if
(
elapsed
.
InMilliseconds
(
)
>
kMaxMillisecondsToAvoidDrift
)
{
InitializeClock
(
)
;
continue
;
}
return
Time
(
elapsed
+
Time
(
initial_time
)
)
;
}
}
Time
Time
:
:
NowFromSystemTime
(
)
{
InitializeClock
(
)
;
return
Time
(
initial_time
)
;
}
Time
Time
:
:
FromExploded
(
bool
is_local
const
Exploded
&
exploded
)
{
SYSTEMTIME
st
;
st
.
wYear
=
exploded
.
year
;
st
.
wMonth
=
exploded
.
month
;
st
.
wDayOfWeek
=
exploded
.
day_of_week
;
st
.
wDay
=
exploded
.
day_of_month
;
st
.
wHour
=
exploded
.
hour
;
st
.
wMinute
=
exploded
.
minute
;
st
.
wSecond
=
exploded
.
second
;
st
.
wMilliseconds
=
exploded
.
millisecond
;
FILETIME
ft
;
if
(
!
SystemTimeToFileTime
(
&
st
&
ft
)
)
{
NOTREACHED
(
)
<
<
"
Unable
to
convert
time
"
;
return
Time
(
0
)
;
}
if
(
is_local
)
{
FILETIME
utc_ft
;
LocalFileTimeToFileTime
(
&
ft
&
utc_ft
)
;
return
Time
(
FileTimeToMicroseconds
(
utc_ft
)
)
;
}
return
Time
(
FileTimeToMicroseconds
(
ft
)
)
;
}
void
Time
:
:
Explode
(
bool
is_local
Exploded
*
exploded
)
const
{
FILETIME
utc_ft
;
MicrosecondsToFileTime
(
us_
&
utc_ft
)
;
BOOL
success
=
TRUE
;
FILETIME
ft
;
if
(
is_local
)
success
=
FileTimeToLocalFileTime
(
&
utc_ft
&
ft
)
;
else
ft
=
utc_ft
;
SYSTEMTIME
st
;
if
(
!
success
|
|
!
FileTimeToSystemTime
(
&
ft
&
st
)
)
{
NOTREACHED
(
)
<
<
"
Unable
to
convert
time
don
'
t
know
why
"
;
ZeroMemory
(
exploded
sizeof
(
*
exploded
)
)
;
return
;
}
exploded
-
>
year
=
st
.
wYear
;
exploded
-
>
month
=
st
.
wMonth
;
exploded
-
>
day_of_week
=
st
.
wDayOfWeek
;
exploded
-
>
day_of_month
=
st
.
wDay
;
exploded
-
>
hour
=
st
.
wHour
;
exploded
-
>
minute
=
st
.
wMinute
;
exploded
-
>
second
=
st
.
wSecond
;
exploded
-
>
millisecond
=
st
.
wMilliseconds
;
}
namespace
{
DWORD
timeGetTimeWrapper
(
)
{
return
timeGetTime
(
)
;
}
DWORD
(
*
tick_function
)
(
void
)
=
&
timeGetTimeWrapper
;
static
mozilla
:
:
StaticMutex
sNowSingletonLock
;
class
NowSingleton
{
public
:
TimeDelta
Now
(
)
{
mozilla
:
:
StaticMutexAutoLock
locked
(
sNowSingletonLock
)
;
DWORD
now
=
tick_function
(
)
;
if
(
now
<
last_seen_
)
rollover_
+
=
TimeDelta
:
:
FromMilliseconds
(
GG_LONGLONG
(
0x100000000
)
)
;
last_seen_
=
now
;
return
TimeDelta
:
:
FromMilliseconds
(
now
)
+
rollover_
;
}
static
NowSingleton
&
instance
(
)
{
static
NowSingleton
now
;
return
now
;
}
private
:
explicit
NowSingleton
(
)
:
rollover_
(
TimeDelta
:
:
FromMilliseconds
(
0
)
)
last_seen_
(
0
)
{
}
~
NowSingleton
(
)
=
default
;
TimeDelta
rollover_
GUARDED_BY
(
sNowSingletonLock
)
;
DWORD
last_seen_
GUARDED_BY
(
sNowSingletonLock
)
;
DISALLOW_COPY_AND_ASSIGN
(
NowSingleton
)
;
}
;
}
TimeTicks
TimeTicks
:
:
Now
(
)
{
return
TimeTicks
(
)
+
NowSingleton
:
:
instance
(
)
.
Now
(
)
;
}
