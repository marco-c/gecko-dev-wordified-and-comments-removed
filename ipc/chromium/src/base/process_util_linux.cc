#
include
"
base
/
process_util
.
h
"
#
include
<
string
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
{
static
mozilla
:
:
EnvironmentLog
gProcessLog
(
"
MOZ_PROCESS_LOG
"
)
;
}
namespace
base
{
bool
LaunchApp
(
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
mozilla
:
:
UniquePtr
<
char
*
[
]
>
argv_cstr
(
new
char
*
[
argv
.
size
(
)
+
1
]
)
;
InjectiveMultimap
fd_shuffle1
fd_shuffle2
;
fd_shuffle1
.
reserve
(
options
.
fds_to_remap
.
size
(
)
)
;
fd_shuffle2
.
reserve
(
options
.
fds_to_remap
.
size
(
)
)
;
EnvironmentArray
envp
=
BuildEnvironmentArray
(
options
.
env_map
)
;
pid_t
pid
=
fork
(
)
;
if
(
pid
<
0
)
return
false
;
if
(
pid
=
=
0
)
{
for
(
const
auto
&
fd_map
:
options
.
fds_to_remap
)
{
fd_shuffle1
.
push_back
(
InjectionArc
(
fd_map
.
first
fd_map
.
second
false
)
)
;
fd_shuffle2
.
push_back
(
InjectionArc
(
fd_map
.
first
fd_map
.
second
false
)
)
;
}
if
(
!
ShuffleFileDescriptors
(
&
fd_shuffle1
)
)
_exit
(
127
)
;
CloseSuperfluousFds
(
fd_shuffle2
)
;
for
(
size_t
i
=
0
;
i
<
argv
.
size
(
)
;
i
+
+
)
argv_cstr
[
i
]
=
const_cast
<
char
*
>
(
argv
[
i
]
.
c_str
(
)
)
;
argv_cstr
[
argv
.
size
(
)
]
=
NULL
;
execve
(
argv_cstr
[
0
]
argv_cstr
.
get
(
)
envp
.
get
(
)
)
;
DLOG
(
ERROR
)
<
<
"
FAILED
TO
exec
(
)
CHILD
PROCESS
path
:
"
<
<
argv_cstr
[
0
]
;
_exit
(
127
)
;
}
gProcessLog
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
\
n
"
GetCurrentProcId
(
)
pid
)
;
if
(
options
.
wait
)
HANDLE_EINTR
(
waitpid
(
pid
0
0
)
)
;
if
(
process_handle
)
*
process_handle
=
pid
;
return
true
;
}
bool
LaunchApp
(
const
CommandLine
&
cl
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
return
LaunchApp
(
cl
.
argv
(
)
options
process_handle
)
;
}
}
