#
include
"
base
/
process_util
.
h
"
#
include
<
string
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
if
defined
(
MOZ_CODE_COVERAGE
)
#
include
"
nsString
.
h
"
#
endif
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
#
include
<
stdlib
.
h
>
#
include
<
fcntl
.
h
>
#
if
defined
(
DEBUG
)
#
include
"
base
/
message_loop
.
h
"
#
endif
#
include
"
mozilla
/
ipc
/
ForkServiceChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessUtils
.
h
"
using
namespace
mozilla
:
:
ipc
;
#
endif
#
if
defined
(
MOZ_CODE_COVERAGE
)
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
ipc
/
EnvironmentMap
.
h
"
#
endif
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorShuffle
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
namespace
{
static
mozilla
:
:
EnvironmentLog
gProcessLog
(
"
MOZ_PROCESS_LOG
"
)
;
}
namespace
base
{
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
static
mozilla
:
:
StaticAutoPtr
<
std
:
:
vector
<
int
>
>
sNoCloseFDs
;
void
RegisterForkServerNoCloseFD
(
int
fd
)
{
if
(
!
sNoCloseFDs
)
{
sNoCloseFDs
=
new
std
:
:
vector
<
int
>
(
)
;
}
sNoCloseFDs
-
>
push_back
(
fd
)
;
}
static
bool
IsNoCloseFd
(
int
fd
)
{
if
(
!
sNoCloseFDs
)
{
return
false
;
}
return
std
:
:
any_of
(
sNoCloseFDs
-
>
begin
(
)
sNoCloseFDs
-
>
end
(
)
[
fd
]
(
int
regfd
)
-
>
bool
{
return
regfd
=
=
fd
;
}
)
;
}
AppProcessBuilder
:
:
AppProcessBuilder
(
)
{
}
static
void
ReplaceEnviroment
(
const
LaunchOptions
&
options
)
{
for
(
auto
&
elt
:
options
.
env_map
)
{
setenv
(
elt
.
first
.
c_str
(
)
elt
.
second
.
c_str
(
)
1
)
;
}
}
bool
AppProcessBuilder
:
:
ForkProcess
(
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
auto
cleanFDs
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
for
(
auto
&
elt
:
options
.
fds_to_remap
)
{
auto
fd
=
std
:
:
get
<
0
>
(
elt
)
;
close
(
fd
)
;
}
}
)
;
argv_
=
argv
;
if
(
!
shuffle_
.
Init
(
options
.
fds_to_remap
)
)
{
return
false
;
}
fflush
(
stdout
)
;
fflush
(
stderr
)
;
#
ifdef
OS_LINUX
pid_t
pid
=
options
.
fork_delegate
?
options
.
fork_delegate
-
>
Fork
(
)
:
fork
(
)
;
#
else
pid_t
pid
=
fork
(
)
;
#
endif
if
(
pid
<
0
)
{
return
false
;
}
if
(
pid
=
=
0
)
{
cleanFDs
.
release
(
)
;
ReplaceEnviroment
(
options
)
;
}
else
{
gProcessLog
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
\
n
"
GetCurrentProcId
(
)
pid
)
;
if
(
options
.
wait
)
HANDLE_EINTR
(
waitpid
(
pid
0
0
)
)
;
}
if
(
process_handle
)
*
process_handle
=
pid
;
return
true
;
}
void
AppProcessBuilder
:
:
ReplaceArguments
(
int
*
argcp
char
*
*
*
argvp
)
{
char
*
*
argv
=
new
char
*
[
argv_
.
size
(
)
+
1
]
;
char
*
*
p
=
argv
;
for
(
auto
&
elt
:
argv_
)
{
*
p
+
+
=
strdup
(
elt
.
c_str
(
)
)
;
}
*
p
=
nullptr
;
*
argvp
=
argv
;
*
argcp
=
argv_
.
size
(
)
;
}
void
AppProcessBuilder
:
:
InitAppProcess
(
int
*
argcp
char
*
*
*
argvp
)
{
MOZ_ASSERT
(
MessageLoop
:
:
current
(
)
=
=
nullptr
"
The
message
loop
of
the
main
thread
should
have
been
destroyed
"
)
;
signal
(
SIGCHLD
SIG_DFL
)
;
for
(
const
auto
&
fds
:
shuffle_
.
Dup2Sequence
(
)
)
{
int
fd
=
HANDLE_EINTR
(
dup2
(
fds
.
first
fds
.
second
)
)
;
MOZ_RELEASE_ASSERT
(
fd
=
=
fds
.
second
"
dup2
failed
"
)
;
}
CloseSuperfluousFds
(
&
shuffle_
[
]
(
void
*
ctx
int
fd
)
{
return
static_cast
<
decltype
(
&
shuffle_
)
>
(
ctx
)
-
>
MapsTo
(
fd
)
|
|
IsNoCloseFd
(
fd
)
;
}
)
;
shuffle_
.
Forget
(
)
;
ReplaceArguments
(
argcp
argvp
)
;
}
static
void
handle_sigchld
(
int
s
)
{
while
(
true
)
{
if
(
waitpid
(
-
1
nullptr
WNOHANG
)
<
=
0
)
{
break
;
}
}
}
static
void
InstallChildSignalHandler
(
)
{
signal
(
SIGCHLD
handle_sigchld
)
;
}
static
void
ReserveFileDescriptors
(
)
{
int
fd
=
open
(
"
/
dev
/
null
"
O_RDONLY
)
;
for
(
int
i
=
1
;
i
<
10
;
i
+
+
)
{
mozilla
:
:
Unused
<
<
dup
(
fd
)
;
}
}
void
InitForkServerProcess
(
)
{
InstallChildSignalHandler
(
)
;
ReserveFileDescriptors
(
)
;
SetThisProcessName
(
"
forkserver
"
)
;
}
static
bool
LaunchAppWithForkServer
(
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
MOZ_ASSERT
(
ForkServiceChild
:
:
Get
(
)
)
;
nsTArray
<
nsCString
>
_argv
(
argv
.
size
(
)
)
;
nsTArray
<
mozilla
:
:
EnvVar
>
env
(
options
.
env_map
.
size
(
)
)
;
nsTArray
<
mozilla
:
:
FdMapping
>
fdsremap
(
options
.
fds_to_remap
.
size
(
)
)
;
for
(
auto
&
arg
:
argv
)
{
_argv
.
AppendElement
(
arg
.
c_str
(
)
)
;
}
for
(
auto
&
vv
:
options
.
env_map
)
{
env
.
AppendElement
(
mozilla
:
:
EnvVar
(
nsCString
(
vv
.
first
.
c_str
(
)
)
nsCString
(
vv
.
second
.
c_str
(
)
)
)
)
;
}
for
(
auto
&
fdmapping
:
options
.
fds_to_remap
)
{
fdsremap
.
AppendElement
(
mozilla
:
:
FdMapping
(
mozilla
:
:
ipc
:
:
FileDescriptor
(
fdmapping
.
first
)
fdmapping
.
second
)
)
;
}
return
ForkServiceChild
:
:
Get
(
)
-
>
SendForkNewSubprocess
(
_argv
env
fdsremap
process_handle
)
;
}
#
endif
bool
LaunchApp
(
const
std
:
:
vector
<
std
:
:
string
>
&
argv
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
#
if
defined
(
MOZ_ENABLE_FORKSERVER
)
if
(
options
.
use_forkserver
&
&
ForkServiceChild
:
:
Get
(
)
)
{
return
LaunchAppWithForkServer
(
argv
options
process_handle
)
;
}
#
endif
mozilla
:
:
UniquePtr
<
char
*
[
]
>
argv_cstr
(
new
char
*
[
argv
.
size
(
)
+
1
]
)
;
EnvironmentArray
env_storage
;
const
EnvironmentArray
&
envp
=
options
.
full_env
?
options
.
full_env
:
(
env_storage
=
BuildEnvironmentArray
(
options
.
env_map
)
)
;
mozilla
:
:
ipc
:
:
FileDescriptorShuffle
shuffle
;
if
(
!
shuffle
.
Init
(
options
.
fds_to_remap
)
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
FileDescriptorShuffle
:
:
Init
failed
"
;
return
false
;
}
#
ifdef
MOZ_CODE_COVERAGE
void
(
*
ccovSigHandler
)
(
int
)
=
signal
(
SIGUSR1
SIG_IGN
)
;
const
char
*
gcov_child_prefix
=
PR_GetEnv
(
"
GCOV_CHILD_PREFIX
"
)
;
#
endif
#
ifdef
OS_LINUX
pid_t
pid
=
options
.
fork_delegate
?
options
.
fork_delegate
-
>
Fork
(
)
:
fork
(
)
;
#
else
pid_t
pid
=
fork
(
)
;
#
endif
if
(
pid
<
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fork
(
)
failed
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
pid
=
=
0
)
{
if
(
!
options
.
workdir
.
empty
(
)
)
{
if
(
chdir
(
options
.
workdir
.
c_str
(
)
)
!
=
0
)
{
DLOG
(
ERROR
)
<
<
"
chdir
failed
"
<
<
options
.
workdir
;
_exit
(
127
)
;
}
}
for
(
const
auto
&
fds
:
shuffle
.
Dup2Sequence
(
)
)
{
if
(
HANDLE_EINTR
(
dup2
(
fds
.
first
fds
.
second
)
)
!
=
fds
.
second
)
{
DLOG
(
ERROR
)
<
<
"
dup2
failed
"
;
_exit
(
127
)
;
}
}
CloseSuperfluousFds
(
&
shuffle
[
]
(
void
*
aCtx
int
aFd
)
{
return
static_cast
<
decltype
(
&
shuffle
)
>
(
aCtx
)
-
>
MapsTo
(
aFd
)
;
}
)
;
for
(
size_t
i
=
0
;
i
<
argv
.
size
(
)
;
i
+
+
)
argv_cstr
[
i
]
=
const_cast
<
char
*
>
(
argv
[
i
]
.
c_str
(
)
)
;
argv_cstr
[
argv
.
size
(
)
]
=
NULL
;
#
ifdef
MOZ_CODE_COVERAGE
if
(
gcov_child_prefix
&
&
!
options
.
full_env
)
{
const
pid_t
child_pid
=
getpid
(
)
;
nsAutoCString
new_gcov_prefix
(
gcov_child_prefix
)
;
new_gcov_prefix
.
Append
(
std
:
:
to_string
(
(
size_t
)
child_pid
)
)
;
EnvironmentMap
new_map
=
options
.
env_map
;
new_map
[
ENVIRONMENT_LITERAL
(
"
GCOV_PREFIX
"
)
]
=
ENVIRONMENT_STRING
(
new_gcov_prefix
.
get
(
)
)
;
env_storage
=
BuildEnvironmentArray
(
new_map
)
;
}
#
endif
execve
(
argv_cstr
[
0
]
argv_cstr
.
get
(
)
envp
.
get
(
)
)
;
DLOG
(
ERROR
)
<
<
"
FAILED
TO
exec
(
)
CHILD
PROCESS
path
:
"
<
<
argv_cstr
[
0
]
;
_exit
(
127
)
;
}
#
ifdef
MOZ_CODE_COVERAGE
signal
(
SIGUSR1
ccovSigHandler
)
;
#
endif
gProcessLog
.
print
(
"
=
=
>
process
%
d
launched
child
process
%
d
\
n
"
GetCurrentProcId
(
)
pid
)
;
if
(
options
.
wait
)
HANDLE_EINTR
(
waitpid
(
pid
0
0
)
)
;
if
(
process_handle
)
*
process_handle
=
pid
;
return
true
;
}
bool
LaunchApp
(
const
CommandLine
&
cl
const
LaunchOptions
&
options
ProcessHandle
*
process_handle
)
{
return
LaunchApp
(
cl
.
argv
(
)
options
process_handle
)
;
}
}
