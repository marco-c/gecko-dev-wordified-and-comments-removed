#
include
"
base
/
message_pump_mac
.
h
"
#
import
<
AppKit
/
AppKit
.
h
>
#
import
<
Foundation
/
Foundation
.
h
>
#
include
<
IOKit
/
IOMessage
.
h
>
#
include
<
IOKit
/
pwr_mgt
/
IOPMLib
.
h
>
#
include
<
limits
>
#
import
"
base
/
chrome_application_mac
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
time
.
h
"
namespace
{
void
NoOp
(
void
*
info
)
{
}
const
CFTimeInterval
kCFTimeIntervalMax
=
std
:
:
numeric_limits
<
CFTimeInterval
>
:
:
max
(
)
;
}
namespace
base
{
class
MessagePumpScopedAutoreleasePool
{
public
:
explicit
MessagePumpScopedAutoreleasePool
(
MessagePumpCFRunLoopBase
*
pump
)
:
pool_
(
pump
-
>
CreateAutoreleasePool
(
)
)
{
}
~
MessagePumpScopedAutoreleasePool
(
)
{
[
pool_
drain
]
;
}
private
:
NSAutoreleasePool
*
pool_
;
DISALLOW_COPY_AND_ASSIGN
(
MessagePumpScopedAutoreleasePool
)
;
}
;
MessagePumpCFRunLoopBase
:
:
MessagePumpCFRunLoopBase
(
)
:
delegate_
(
NULL
)
delayed_work_fire_time_
(
kCFTimeIntervalMax
)
nesting_level_
(
0
)
run_nesting_level_
(
0
)
deepest_nesting_level_
(
0
)
delegateless_work_
(
false
)
delegateless_delayed_work_
(
false
)
delegateless_idle_work_
(
false
)
{
run_loop_
=
CFRunLoopGetCurrent
(
)
;
CFRetain
(
run_loop_
)
;
CFRunLoopTimerContext
timer_context
=
CFRunLoopTimerContext
(
)
;
timer_context
.
info
=
this
;
delayed_work_timer_
=
CFRunLoopTimerCreate
(
NULL
kCFTimeIntervalMax
kCFTimeIntervalMax
0
0
RunDelayedWorkTimer
&
timer_context
)
;
CFRunLoopAddTimer
(
run_loop_
delayed_work_timer_
kCFRunLoopCommonModes
)
;
CFRunLoopSourceContext
source_context
=
CFRunLoopSourceContext
(
)
;
source_context
.
info
=
this
;
source_context
.
perform
=
RunWorkSource
;
work_source_
=
CFRunLoopSourceCreate
(
NULL
1
&
source_context
)
;
CFRunLoopAddSource
(
run_loop_
work_source_
kCFRunLoopCommonModes
)
;
source_context
.
perform
=
RunDelayedWorkSource
;
delayed_work_source_
=
CFRunLoopSourceCreate
(
NULL
2
&
source_context
)
;
CFRunLoopAddSource
(
run_loop_
delayed_work_source_
kCFRunLoopCommonModes
)
;
source_context
.
perform
=
RunIdleWorkSource
;
idle_work_source_
=
CFRunLoopSourceCreate
(
NULL
3
&
source_context
)
;
CFRunLoopAddSource
(
run_loop_
idle_work_source_
kCFRunLoopCommonModes
)
;
source_context
.
perform
=
RunNestingDeferredWorkSource
;
nesting_deferred_work_source_
=
CFRunLoopSourceCreate
(
NULL
0
&
source_context
)
;
CFRunLoopAddSource
(
run_loop_
nesting_deferred_work_source_
kCFRunLoopCommonModes
)
;
CFRunLoopObserverContext
observer_context
=
CFRunLoopObserverContext
(
)
;
observer_context
.
info
=
this
;
pre_wait_observer_
=
CFRunLoopObserverCreate
(
NULL
kCFRunLoopBeforeWaiting
true
0
PreWaitObserver
&
observer_context
)
;
CFRunLoopAddObserver
(
run_loop_
pre_wait_observer_
kCFRunLoopCommonModes
)
;
pre_source_observer_
=
CFRunLoopObserverCreate
(
NULL
kCFRunLoopBeforeSources
true
0
PreSourceObserver
&
observer_context
)
;
CFRunLoopAddObserver
(
run_loop_
pre_source_observer_
kCFRunLoopCommonModes
)
;
enter_exit_observer_
=
CFRunLoopObserverCreate
(
NULL
kCFRunLoopEntry
|
kCFRunLoopExit
true
0
EnterExitObserver
&
observer_context
)
;
CFRunLoopAddObserver
(
run_loop_
enter_exit_observer_
kCFRunLoopCommonModes
)
;
root_power_domain_
=
IORegisterForSystemPower
(
this
&
power_notification_port_
PowerStateNotification
&
power_notification_object_
)
;
if
(
root_power_domain_
!
=
MACH_PORT_NULL
)
{
CFRunLoopAddSource
(
run_loop_
IONotificationPortGetRunLoopSource
(
power_notification_port_
)
kCFRunLoopCommonModes
)
;
}
}
MessagePumpCFRunLoopBase
:
:
~
MessagePumpCFRunLoopBase
(
)
{
if
(
root_power_domain_
!
=
MACH_PORT_NULL
)
{
CFRunLoopRemoveSource
(
run_loop_
IONotificationPortGetRunLoopSource
(
power_notification_port_
)
kCFRunLoopCommonModes
)
;
IODeregisterForSystemPower
(
&
power_notification_object_
)
;
IOServiceClose
(
root_power_domain_
)
;
IONotificationPortDestroy
(
power_notification_port_
)
;
}
CFRunLoopRemoveObserver
(
run_loop_
enter_exit_observer_
kCFRunLoopCommonModes
)
;
CFRelease
(
enter_exit_observer_
)
;
CFRunLoopRemoveObserver
(
run_loop_
pre_source_observer_
kCFRunLoopCommonModes
)
;
CFRelease
(
pre_source_observer_
)
;
CFRunLoopRemoveObserver
(
run_loop_
pre_wait_observer_
kCFRunLoopCommonModes
)
;
CFRelease
(
pre_wait_observer_
)
;
CFRunLoopRemoveSource
(
run_loop_
nesting_deferred_work_source_
kCFRunLoopCommonModes
)
;
CFRelease
(
nesting_deferred_work_source_
)
;
CFRunLoopRemoveSource
(
run_loop_
idle_work_source_
kCFRunLoopCommonModes
)
;
CFRelease
(
idle_work_source_
)
;
CFRunLoopRemoveSource
(
run_loop_
delayed_work_source_
kCFRunLoopCommonModes
)
;
CFRelease
(
delayed_work_source_
)
;
CFRunLoopRemoveSource
(
run_loop_
work_source_
kCFRunLoopCommonModes
)
;
CFRelease
(
work_source_
)
;
CFRunLoopRemoveTimer
(
run_loop_
delayed_work_timer_
kCFRunLoopCommonModes
)
;
CFRelease
(
delayed_work_timer_
)
;
CFRelease
(
run_loop_
)
;
}
void
MessagePumpCFRunLoopBase
:
:
Run
(
Delegate
*
delegate
)
{
int
last_run_nesting_level
=
run_nesting_level_
;
run_nesting_level_
=
nesting_level_
+
1
;
Delegate
*
last_delegate
=
delegate_
;
delegate_
=
delegate
;
if
(
delegate
)
{
if
(
delegateless_work_
)
{
CFRunLoopSourceSignal
(
work_source_
)
;
delegateless_work_
=
false
;
}
if
(
delegateless_delayed_work_
)
{
CFRunLoopSourceSignal
(
delayed_work_source_
)
;
delegateless_delayed_work_
=
false
;
}
if
(
delegateless_idle_work_
)
{
CFRunLoopSourceSignal
(
idle_work_source_
)
;
delegateless_idle_work_
=
false
;
}
}
DoRun
(
delegate
)
;
delegate_
=
last_delegate
;
run_nesting_level_
=
last_run_nesting_level
;
}
void
MessagePumpCFRunLoopBase
:
:
ScheduleWork
(
)
{
CFRunLoopSourceSignal
(
work_source_
)
;
CFRunLoopWakeUp
(
run_loop_
)
;
}
void
MessagePumpCFRunLoopBase
:
:
ScheduleDelayedWork
(
const
TimeTicks
&
delayed_work_time
)
{
TimeDelta
delta
=
delayed_work_time
-
TimeTicks
:
:
Now
(
)
;
delayed_work_fire_time_
=
CFAbsoluteTimeGetCurrent
(
)
+
delta
.
InSecondsF
(
)
;
CFRunLoopTimerSetNextFireDate
(
delayed_work_timer_
delayed_work_fire_time_
)
;
}
void
MessagePumpCFRunLoopBase
:
:
RunDelayedWorkTimer
(
CFRunLoopTimerRef
timer
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
delayed_work_fire_time_
=
kCFTimeIntervalMax
;
CFRunLoopSourceSignal
(
self
-
>
delayed_work_source_
)
;
}
void
MessagePumpCFRunLoopBase
:
:
RunWorkSource
(
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
RunWork
(
)
;
}
bool
MessagePumpCFRunLoopBase
:
:
RunWork
(
)
{
if
(
!
delegate_
)
{
delegateless_work_
=
true
;
return
false
;
}
MessagePumpScopedAutoreleasePool
autorelease_pool
(
this
)
;
bool
did_work
=
delegate_
-
>
DoWork
(
)
;
if
(
did_work
)
{
CFRunLoopSourceSignal
(
work_source_
)
;
}
return
did_work
;
}
void
MessagePumpCFRunLoopBase
:
:
RunDelayedWorkSource
(
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
RunDelayedWork
(
)
;
}
bool
MessagePumpCFRunLoopBase
:
:
RunDelayedWork
(
)
{
if
(
!
delegate_
)
{
delegateless_delayed_work_
=
true
;
return
false
;
}
MessagePumpScopedAutoreleasePool
autorelease_pool
(
this
)
;
TimeTicks
next_time
;
delegate_
-
>
DoDelayedWork
(
&
next_time
)
;
bool
more_work
=
!
next_time
.
is_null
(
)
;
if
(
more_work
)
{
TimeDelta
delay
=
next_time
-
TimeTicks
:
:
Now
(
)
;
if
(
delay
>
TimeDelta
(
)
)
{
ScheduleDelayedWork
(
next_time
)
;
}
else
{
CFRunLoopSourceSignal
(
delayed_work_source_
)
;
}
}
return
more_work
;
}
void
MessagePumpCFRunLoopBase
:
:
RunIdleWorkSource
(
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
RunIdleWork
(
)
;
}
bool
MessagePumpCFRunLoopBase
:
:
RunIdleWork
(
)
{
if
(
!
delegate_
)
{
delegateless_idle_work_
=
true
;
return
false
;
}
MessagePumpScopedAutoreleasePool
autorelease_pool
(
this
)
;
bool
did_work
=
delegate_
-
>
DoIdleWork
(
)
;
if
(
did_work
)
{
CFRunLoopSourceSignal
(
idle_work_source_
)
;
}
return
did_work
;
}
void
MessagePumpCFRunLoopBase
:
:
RunNestingDeferredWorkSource
(
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
RunNestingDeferredWork
(
)
;
}
bool
MessagePumpCFRunLoopBase
:
:
RunNestingDeferredWork
(
)
{
if
(
!
delegate_
)
{
return
false
;
}
if
(
!
RunWork
(
)
)
{
if
(
!
RunDelayedWork
(
)
)
{
if
(
!
RunIdleWork
(
)
)
{
return
false
;
}
}
else
{
CFRunLoopSourceSignal
(
idle_work_source_
)
;
}
}
else
{
CFRunLoopSourceSignal
(
delayed_work_source_
)
;
CFRunLoopSourceSignal
(
idle_work_source_
)
;
}
return
true
;
}
void
MessagePumpCFRunLoopBase
:
:
MaybeScheduleNestingDeferredWork
(
)
{
if
(
deepest_nesting_level_
>
nesting_level_
)
{
deepest_nesting_level_
=
nesting_level_
;
CFRunLoopSourceSignal
(
nesting_deferred_work_source_
)
;
}
}
void
MessagePumpCFRunLoopBase
:
:
PreWaitObserver
(
CFRunLoopObserverRef
observer
CFRunLoopActivity
activity
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
RunIdleWork
(
)
;
self
-
>
MaybeScheduleNestingDeferredWork
(
)
;
}
void
MessagePumpCFRunLoopBase
:
:
PreSourceObserver
(
CFRunLoopObserverRef
observer
CFRunLoopActivity
activity
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
self
-
>
MaybeScheduleNestingDeferredWork
(
)
;
}
void
MessagePumpCFRunLoopBase
:
:
EnterExitObserver
(
CFRunLoopObserverRef
observer
CFRunLoopActivity
activity
void
*
info
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
switch
(
activity
)
{
case
kCFRunLoopEntry
:
+
+
self
-
>
nesting_level_
;
if
(
self
-
>
nesting_level_
>
self
-
>
deepest_nesting_level_
)
{
self
-
>
deepest_nesting_level_
=
self
-
>
nesting_level_
;
}
break
;
case
kCFRunLoopExit
:
self
-
>
MaybeScheduleNestingDeferredWork
(
)
;
-
-
self
-
>
nesting_level_
;
break
;
default
:
break
;
}
self
-
>
EnterExitRunLoop
(
activity
)
;
}
void
MessagePumpCFRunLoopBase
:
:
PowerStateNotification
(
void
*
info
io_service_t
service
uint32_t
message_type
void
*
message_argument
)
{
MessagePumpCFRunLoopBase
*
self
=
static_cast
<
MessagePumpCFRunLoopBase
*
>
(
info
)
;
switch
(
message_type
)
{
case
kIOMessageSystemWillPowerOn
:
if
(
self
-
>
delayed_work_fire_time_
!
=
kCFTimeIntervalMax
)
{
CFRunLoopTimerSetNextFireDate
(
self
-
>
delayed_work_timer_
self
-
>
delayed_work_fire_time_
)
;
}
break
;
case
kIOMessageSystemWillSleep
:
case
kIOMessageCanSystemSleep
:
IOAllowPowerChange
(
self
-
>
root_power_domain_
reinterpret_cast
<
long
>
(
message_argument
)
)
;
break
;
default
:
break
;
}
}
void
MessagePumpCFRunLoopBase
:
:
EnterExitRunLoop
(
CFRunLoopActivity
activity
)
{
}
NSAutoreleasePool
*
MessagePumpCFRunLoopBase
:
:
CreateAutoreleasePool
(
)
{
return
[
[
NSAutoreleasePool
alloc
]
init
]
;
}
MessagePumpCFRunLoop
:
:
MessagePumpCFRunLoop
(
)
:
quit_pending_
(
false
)
{
}
void
MessagePumpCFRunLoop
:
:
DoRun
(
Delegate
*
delegate
)
{
int
result
;
do
{
MessagePumpScopedAutoreleasePool
autorelease_pool
(
this
)
;
result
=
CFRunLoopRunInMode
(
kCFRunLoopDefaultMode
kCFTimeIntervalMax
false
)
;
}
while
(
result
!
=
kCFRunLoopRunStopped
&
&
result
!
=
kCFRunLoopRunFinished
)
;
}
void
MessagePumpCFRunLoop
:
:
Quit
(
)
{
if
(
nesting_level
(
)
=
=
run_nesting_level
(
)
)
{
CFRunLoopStop
(
run_loop
(
)
)
;
}
else
{
quit_pending_
=
true
;
}
}
void
MessagePumpCFRunLoop
:
:
EnterExitRunLoop
(
CFRunLoopActivity
activity
)
{
if
(
activity
=
=
kCFRunLoopExit
&
&
nesting_level
(
)
=
=
run_nesting_level
(
)
&
&
quit_pending_
)
{
CFRunLoopStop
(
run_loop
(
)
)
;
quit_pending_
=
false
;
}
}
MessagePumpNSRunLoop
:
:
MessagePumpNSRunLoop
(
)
:
keep_running_
(
true
)
{
CFRunLoopSourceContext
source_context
=
CFRunLoopSourceContext
(
)
;
source_context
.
perform
=
NoOp
;
quit_source_
=
CFRunLoopSourceCreate
(
NULL
0
&
source_context
)
;
CFRunLoopAddSource
(
run_loop
(
)
quit_source_
kCFRunLoopCommonModes
)
;
}
MessagePumpNSRunLoop
:
:
~
MessagePumpNSRunLoop
(
)
{
CFRunLoopRemoveSource
(
run_loop
(
)
quit_source_
kCFRunLoopCommonModes
)
;
CFRelease
(
quit_source_
)
;
}
void
MessagePumpNSRunLoop
:
:
DoRun
(
Delegate
*
delegate
)
{
while
(
keep_running_
)
{
[
[
NSRunLoop
currentRunLoop
]
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
;
}
keep_running_
=
true
;
}
void
MessagePumpNSRunLoop
:
:
Quit
(
)
{
keep_running_
=
false
;
CFRunLoopSourceSignal
(
quit_source_
)
;
CFRunLoopWakeUp
(
run_loop
(
)
)
;
}
MessagePumpNSApplication
:
:
MessagePumpNSApplication
(
)
:
keep_running_
(
true
)
running_own_loop_
(
false
)
{
}
void
MessagePumpNSApplication
:
:
DoRun
(
Delegate
*
delegate
)
{
bool
last_running_own_loop_
=
running_own_loop_
;
[
CrApplication
sharedApplication
]
;
if
(
!
[
NSApp
isRunning
]
)
{
running_own_loop_
=
false
;
[
NSApp
run
]
;
}
else
{
running_own_loop_
=
true
;
NSDate
*
distant_future
=
[
NSDate
distantFuture
]
;
while
(
keep_running_
)
{
MessagePumpScopedAutoreleasePool
autorelease_pool
(
this
)
;
NSEvent
*
event
=
[
NSApp
nextEventMatchingMask
:
NSEventMaskAny
untilDate
:
distant_future
inMode
:
NSDefaultRunLoopMode
dequeue
:
YES
]
;
if
(
event
)
{
[
NSApp
sendEvent
:
event
]
;
}
}
keep_running_
=
true
;
}
running_own_loop_
=
last_running_own_loop_
;
}
void
MessagePumpNSApplication
:
:
Quit
(
)
{
if
(
!
running_own_loop_
)
{
[
NSApp
stop
:
nil
]
;
}
else
{
keep_running_
=
false
;
}
[
NSApp
postEvent
:
[
NSEvent
otherEventWithType
:
NSEventTypeApplicationDefined
location
:
NSMakePoint
(
0
0
)
modifierFlags
:
0
timestamp
:
0
windowNumber
:
0
context
:
NULL
subtype
:
0
data1
:
0
data2
:
0
]
atStart
:
NO
]
;
}
NSAutoreleasePool
*
MessagePumpNSApplication
:
:
CreateAutoreleasePool
(
)
{
NSAutoreleasePool
*
pool
=
nil
;
DCHECK
(
[
NSApp
isKindOfClass
:
[
CrApplication
class
]
]
)
;
if
(
!
[
static_cast
<
CrApplication
*
>
(
NSApp
)
isHandlingSendEvent
]
)
{
pool
=
MessagePumpCFRunLoopBase
:
:
CreateAutoreleasePool
(
)
;
}
return
pool
;
}
MessagePump
*
MessagePumpMac
:
:
Create
(
)
{
if
(
[
NSThread
isMainThread
]
)
{
return
new
MessagePumpNSApplication
;
}
return
new
MessagePumpNSRunLoop
;
}
}
