#
include
"
base
/
waitable_event_watcher
.
h
"
#
include
"
base
/
condition_variable
.
h
"
#
include
"
base
/
lock
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
waitable_event
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
namespace
base
{
class
Flag
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Flag
)
Flag
(
)
{
flag_
=
false
;
}
void
Set
(
)
{
AutoLock
locked
(
lock_
)
;
flag_
=
true
;
}
bool
value
(
)
const
{
AutoLock
locked
(
lock_
)
;
return
flag_
;
}
protected
:
~
Flag
(
)
{
}
private
:
mutable
Lock
lock_
;
bool
flag_
;
}
;
class
AsyncWaiter
final
:
public
WaitableEvent
:
:
Waiter
{
public
:
AsyncWaiter
(
MessageLoop
*
message_loop
already_AddRefed
<
mozilla
:
:
Runnable
>
task
Flag
*
flag
)
:
message_loop_
(
message_loop
)
cb_task_
(
task
)
flag_
(
flag
)
{
}
bool
Fire
(
WaitableEvent
*
event
)
{
if
(
flag_
-
>
value
(
)
)
{
cb_task_
=
nullptr
;
}
else
{
message_loop_
-
>
PostTask
(
cb_task_
.
forget
(
)
)
;
}
delete
this
;
return
true
;
}
bool
Compare
(
void
*
tag
)
{
return
tag
=
=
flag_
.
get
(
)
;
}
private
:
MessageLoop
*
const
message_loop_
;
RefPtr
<
mozilla
:
:
Runnable
>
cb_task_
;
RefPtr
<
Flag
>
flag_
;
}
;
class
AsyncCallbackTask
:
public
mozilla
:
:
Runnable
{
public
:
AsyncCallbackTask
(
Flag
*
flag
WaitableEventWatcher
:
:
Delegate
*
delegate
WaitableEvent
*
event
)
:
flag_
(
flag
)
delegate_
(
delegate
)
event_
(
event
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
flag_
-
>
value
(
)
)
{
flag_
-
>
Set
(
)
;
delegate_
-
>
OnWaitableEventSignaled
(
event_
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Flag
>
flag_
;
WaitableEventWatcher
:
:
Delegate
*
const
delegate_
;
WaitableEvent
*
const
event_
;
}
;
WaitableEventWatcher
:
:
WaitableEventWatcher
(
)
:
event_
(
NULL
)
message_loop_
(
NULL
)
cancel_flag_
(
NULL
)
{
}
WaitableEventWatcher
:
:
~
WaitableEventWatcher
(
)
{
StopWatching
(
)
;
}
bool
WaitableEventWatcher
:
:
StartWatching
(
WaitableEvent
*
event
WaitableEventWatcher
:
:
Delegate
*
delegate
)
{
MessageLoop
*
const
current_ml
=
MessageLoop
:
:
current
(
)
;
DCHECK
(
current_ml
)
<
<
"
Cannot
create
WaitableEventWatcher
without
a
"
"
current
MessageLoop
"
;
if
(
cancel_flag_
.
get
(
)
&
&
cancel_flag_
-
>
value
(
)
)
{
if
(
message_loop_
)
{
message_loop_
-
>
RemoveDestructionObserver
(
this
)
;
message_loop_
=
NULL
;
}
cancel_flag_
=
NULL
;
}
DCHECK
(
!
cancel_flag_
.
get
(
)
)
<
<
"
StartWatching
called
while
still
watching
"
;
cancel_flag_
=
new
Flag
;
callback_task_
=
new
AsyncCallbackTask
(
cancel_flag_
delegate
event
)
;
WaitableEvent
:
:
WaitableEventKernel
*
kernel
=
event
-
>
kernel_
.
get
(
)
;
AutoLock
locked
(
kernel
-
>
lock_
)
;
if
(
kernel
-
>
signaled_
)
{
if
(
!
kernel
-
>
manual_reset_
)
kernel
-
>
signaled_
=
false
;
RefPtr
<
AsyncCallbackTask
>
addrefedTask
=
callback_task_
;
current_ml
-
>
PostTask
(
addrefedTask
.
forget
(
)
)
;
return
true
;
}
message_loop_
=
current_ml
;
current_ml
-
>
AddDestructionObserver
(
this
)
;
event_
=
event
;
kernel_
=
kernel
;
RefPtr
<
AsyncCallbackTask
>
addrefedTask
=
callback_task_
;
waiter_
=
new
AsyncWaiter
(
current_ml
addrefedTask
.
forget
(
)
cancel_flag_
)
;
event
-
>
Enqueue
(
waiter_
)
;
return
true
;
}
void
WaitableEventWatcher
:
:
StopWatching
(
)
{
if
(
message_loop_
)
{
message_loop_
-
>
RemoveDestructionObserver
(
this
)
;
message_loop_
=
NULL
;
}
if
(
!
cancel_flag_
.
get
(
)
)
return
;
if
(
cancel_flag_
-
>
value
(
)
)
{
cancel_flag_
=
NULL
;
return
;
}
if
(
!
kernel_
.
get
(
)
)
{
cancel_flag_
-
>
Set
(
)
;
cancel_flag_
=
NULL
;
return
;
}
AutoLock
locked
(
kernel_
-
>
lock_
)
;
if
(
kernel_
-
>
Dequeue
(
waiter_
cancel_flag_
.
get
(
)
)
)
{
delete
waiter_
;
callback_task_
=
nullptr
;
cancel_flag_
=
NULL
;
return
;
}
cancel_flag_
-
>
Set
(
)
;
cancel_flag_
=
NULL
;
}
WaitableEvent
*
WaitableEventWatcher
:
:
GetWatchedEvent
(
)
{
if
(
!
cancel_flag_
.
get
(
)
)
return
NULL
;
if
(
cancel_flag_
-
>
value
(
)
)
return
NULL
;
return
event_
;
}
void
WaitableEventWatcher
:
:
WillDestroyCurrentMessageLoop
(
)
{
StopWatching
(
)
;
}
}
