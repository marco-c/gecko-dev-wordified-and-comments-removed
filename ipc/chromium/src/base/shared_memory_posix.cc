#
include
"
base
/
shared_memory
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
ifdef
ANDROID
#
include
"
mozilla
/
Ashmem
.
h
"
#
endif
#
ifdef
OS_LINUX
#
include
"
linux_memfd_defs
.
h
"
#
endif
#
ifdef
__FreeBSD__
#
include
<
sys
/
capsicum
.
h
>
#
endif
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
prenv
.
h
"
#
include
"
GeckoProfiler
.
h
"
namespace
base
{
void
SharedMemory
:
:
MappingDeleter
:
:
operator
(
)
(
void
*
ptr
)
{
DCHECK
(
mapped_size_
!
=
0
)
;
munmap
(
ptr
mapped_size_
)
;
mapped_size_
=
0
;
}
SharedMemory
:
:
~
SharedMemory
(
)
{
Close
(
)
;
}
bool
SharedMemory
:
:
SetHandle
(
SharedMemoryHandle
handle
bool
read_only
)
{
DCHECK
(
!
mapped_file_
)
;
DCHECK
(
!
frozen_file_
)
;
freezeable_
=
false
;
mapped_file_
.
reset
(
handle
.
fd
)
;
read_only_
=
read_only
;
return
true
;
}
bool
SharedMemory
:
:
IsHandleValid
(
const
SharedMemoryHandle
&
handle
)
{
return
handle
.
fd
>
=
0
;
}
SharedMemoryHandle
SharedMemory
:
:
NULLHandle
(
)
{
return
SharedMemoryHandle
(
)
;
}
#
if
!
defined
(
HAVE_MEMFD_CREATE
)
&
&
defined
(
OS_LINUX
)
&
&
\
defined
(
SYS_memfd_create
)
static
int
memfd_create
(
const
char
*
name
unsigned
int
flags
)
{
return
syscall
(
SYS_memfd_create
name
flags
)
;
}
#
define
HAVE_MEMFD_CREATE
1
#
endif
#
ifdef
HAVE_MEMFD_CREATE
#
define
USE_MEMFD_CREATE
1
#
ifdef
OS_LINUX
static
int
DupReadOnly
(
int
fd
)
{
std
:
:
string
path
=
StringPrintf
(
"
/
proc
/
self
/
fd
/
%
d
"
fd
)
;
return
HANDLE_EINTR
(
open
(
path
.
c_str
(
)
O_RDONLY
|
O_CLOEXEC
)
)
;
}
#
elif
defined
(
__FreeBSD__
)
static
int
DupReadOnly
(
int
fd
)
{
int
rofd
=
dup
(
fd
)
;
if
(
rofd
<
0
)
{
return
-
1
;
}
cap_rights_t
rights
;
cap_rights_init
(
&
rights
CAP_FSTAT
CAP_MMAP_R
)
;
if
(
cap_rights_limit
(
rofd
&
rights
)
<
0
)
{
int
err
=
errno
;
close
(
rofd
)
;
errno
=
err
;
return
-
1
;
}
return
rofd
;
}
#
else
#
warning
"
OS
has
memfd_create
but
no
DupReadOnly
implementation
"
#
undef
USE_MEMFD_CREATE
#
endif
#
endif
static
bool
HaveMemfd
(
)
{
#
ifdef
USE_MEMFD_CREATE
static
const
bool
kHave
=
[
]
{
#
ifdef
OS_LINUX
if
(
!
PR_GetEnv
(
"
MOZ_SANDBOXED
"
)
&
&
access
(
"
/
proc
/
self
/
fd
"
R_OK
|
X_OK
)
<
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
can
'
t
use
memfd
without
procfs
"
;
return
false
;
}
#
endif
int
fd
=
memfd_create
(
"
mozilla
-
ipc
-
test
"
MFD_CLOEXEC
|
MFD_ALLOW_SEALING
)
;
if
(
fd
<
0
)
{
DCHECK_EQ
(
errno
ENOSYS
)
;
return
false
;
}
close
(
fd
)
;
return
true
;
}
(
)
;
return
kHave
;
#
else
return
false
;
#
endif
}
bool
SharedMemory
:
:
AppendPosixShmPrefix
(
std
:
:
string
*
str
pid_t
pid
)
{
#
if
defined
(
ANDROID
)
return
false
;
#
else
if
(
HaveMemfd
(
)
)
{
return
false
;
}
*
str
+
=
'
/
'
;
#
ifdef
OS_LINUX
static
const
char
*
const
kSnap
=
[
]
{
auto
instanceName
=
PR_GetEnv
(
"
SNAP_INSTANCE_NAME
"
)
;
if
(
instanceName
!
=
nullptr
)
{
return
instanceName
;
}
return
PR_GetEnv
(
"
SNAP_NAME
"
)
;
}
(
)
;
if
(
kSnap
)
{
StringAppendF
(
str
"
snap
.
%
s
.
"
kSnap
)
;
}
#
endif
StringAppendF
(
str
"
org
.
mozilla
.
ipc
.
%
d
.
"
static_cast
<
int
>
(
pid
)
)
;
return
true
;
#
endif
}
bool
SharedMemory
:
:
CreateInternal
(
size_t
size
bool
freezeable
)
{
read_only_
=
false
;
DCHECK
(
size
>
0
)
;
DCHECK
(
!
mapped_file_
)
;
DCHECK
(
!
frozen_file_
)
;
mozilla
:
:
UniqueFileHandle
fd
;
mozilla
:
:
UniqueFileHandle
frozen_fd
;
bool
needs_truncate
=
true
;
bool
is_memfd
=
false
;
#
ifdef
USE_MEMFD_CREATE
if
(
HaveMemfd
(
)
)
{
const
unsigned
flags
=
MFD_CLOEXEC
|
(
freezeable
?
MFD_ALLOW_SEALING
:
0
)
;
fd
.
reset
(
memfd_create
(
"
mozilla
-
ipc
"
flags
)
)
;
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
create
memfd
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
is_memfd
=
true
;
if
(
freezeable
)
{
frozen_fd
.
reset
(
DupReadOnly
(
fd
.
get
(
)
)
)
;
if
(
!
frozen_fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
create
read
-
only
memfd
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
}
#
endif
if
(
!
fd
)
{
#
ifdef
ANDROID
fd
.
reset
(
mozilla
:
:
android
:
:
ashmem_create
(
nullptr
size
)
)
;
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
needs_truncate
=
false
;
#
else
do
{
static
mozilla
:
:
Atomic
<
size_t
>
sNameCounter
;
std
:
:
string
name
;
CHECK
(
AppendPosixShmPrefix
(
&
name
getpid
(
)
)
)
;
StringAppendF
(
&
name
"
%
zu
"
sNameCounter
+
+
)
;
fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDWR
|
O_CREAT
|
O_EXCL
0600
)
)
)
;
if
(
fd
)
{
if
(
freezeable
)
{
frozen_fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDONLY
0400
)
)
)
;
if
(
!
frozen_fd
)
{
int
open_err
=
errno
;
shm_unlink
(
name
.
c_str
(
)
)
;
DLOG
(
FATAL
)
<
<
"
failed
to
re
-
open
freezeable
shm
:
"
<
<
strerror
(
open_err
)
;
return
false
;
}
}
if
(
shm_unlink
(
name
.
c_str
(
)
)
!
=
0
)
{
DLOG
(
FATAL
)
<
<
"
failed
to
unlink
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
}
while
(
!
fd
&
&
errno
=
=
EEXIST
)
;
#
endif
}
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
needs_truncate
)
{
#
if
defined
(
HAVE_POSIX_FALLOCATE
)
int
rv
;
{
AUTO_PROFILER_THREAD_SLEEP
;
rv
=
HANDLE_RV_EINTR
(
posix_fallocate
(
fd
.
get
(
)
0
static_cast
<
off_t
>
(
size
)
)
)
;
}
if
(
rv
!
=
0
)
{
if
(
rv
=
=
EOPNOTSUPP
|
|
rv
=
=
EINVAL
|
|
rv
=
=
ENODEV
)
{
int
fallocate_errno
=
rv
;
rv
=
HANDLE_EINTR
(
ftruncate
(
fd
.
get
(
)
static_cast
<
off_t
>
(
size
)
)
)
;
if
(
rv
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fallocate
failed
to
set
shm
size
:
"
<
<
strerror
(
fallocate_errno
)
;
CHROMIUM_LOG
(
WARNING
)
<
<
"
ftruncate
failed
to
set
shm
size
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
else
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fallocate
failed
to
set
shm
size
:
"
<
<
strerror
(
rv
)
;
return
false
;
}
}
#
else
int
rv
=
HANDLE_EINTR
(
ftruncate
(
fd
.
get
(
)
static_cast
<
off_t
>
(
size
)
)
)
;
if
(
rv
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
ftruncate
failed
to
set
shm
size
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
#
endif
}
mapped_file_
=
std
:
:
move
(
fd
)
;
frozen_file_
=
std
:
:
move
(
frozen_fd
)
;
max_size_
=
size
;
freezeable_
=
freezeable
;
is_memfd_
=
is_memfd
;
return
true
;
}
bool
SharedMemory
:
:
ReadOnlyCopy
(
SharedMemory
*
ro_out
)
{
DCHECK
(
mapped_file_
)
;
DCHECK
(
!
read_only_
)
;
CHECK
(
freezeable_
)
;
if
(
ro_out
=
=
this
)
{
DCHECK
(
!
memory_
)
;
}
mozilla
:
:
UniqueFileHandle
ro_file
;
bool
is_ashmem
=
false
;
#
ifdef
ANDROID
if
(
!
is_memfd_
)
{
is_ashmem
=
true
;
DCHECK
(
!
frozen_file_
)
;
ro_file
=
std
:
:
move
(
mapped_file_
)
;
if
(
mozilla
:
:
android
:
:
ashmem_setProt
(
ro_file
.
get
(
)
PROT_READ
)
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
set
ashmem
read
-
only
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
#
endif
#
ifdef
USE_MEMFD_CREATE
static
const
bool
useSeals
=
!
PR_GetEnv
(
"
MOZ_SHM_NO_SEALS
"
)
;
if
(
is_memfd_
&
&
useSeals
)
{
const
int
seals
=
F_SEAL_GROW
|
F_SEAL_SHRINK
|
F_SEAL_SEAL
;
int
sealError
=
EINVAL
;
#
ifdef
F_SEAL_FUTURE_WRITE
sealError
=
fcntl
(
mapped_file_
.
get
(
)
F_ADD_SEALS
seals
|
F_SEAL_FUTURE_WRITE
)
=
=
0
?
0
:
errno
;
#
endif
if
(
sealError
=
=
EINVAL
)
{
sealError
=
fcntl
(
mapped_file_
.
get
(
)
F_ADD_SEALS
seals
)
=
=
0
?
0
:
errno
;
}
if
(
sealError
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
seal
memfd
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
#
else
DCHECK
(
!
is_memfd_
)
;
#
endif
if
(
!
is_ashmem
)
{
DCHECK
(
frozen_file_
)
;
DCHECK
(
mapped_file_
)
;
mapped_file_
=
nullptr
;
ro_file
=
std
:
:
move
(
frozen_file_
)
;
}
DCHECK
(
ro_file
)
;
freezeable_
=
false
;
ro_out
-
>
Close
(
)
;
ro_out
-
>
mapped_file_
=
std
:
:
move
(
ro_file
)
;
ro_out
-
>
max_size_
=
max_size_
;
ro_out
-
>
read_only_
=
true
;
ro_out
-
>
freezeable_
=
false
;
return
true
;
}
bool
SharedMemory
:
:
Map
(
size_t
bytes
void
*
fixed_address
)
{
if
(
!
mapped_file_
)
{
return
false
;
}
DCHECK
(
!
memory_
)
;
void
*
mem
=
mmap
(
fixed_address
bytes
PROT_READ
|
(
read_only_
?
0
:
PROT_WRITE
)
MAP_SHARED
mapped_file_
.
get
(
)
0
)
;
if
(
mem
=
=
MAP_FAILED
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Call
to
mmap
failed
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
fixed_address
&
&
mem
!
=
fixed_address
)
{
bool
munmap_succeeded
=
munmap
(
mem
bytes
)
=
=
0
;
DCHECK
(
munmap_succeeded
)
<
<
"
Call
to
munmap
failed
errno
=
"
<
<
errno
;
return
false
;
}
memory_
=
UniqueMapping
(
mem
MappingDeleter
(
bytes
)
)
;
return
true
;
}
void
*
SharedMemory
:
:
FindFreeAddressSpace
(
size_t
size
)
{
void
*
memory
=
mmap
(
NULL
size
PROT_NONE
MAP_PRIVATE
|
MAP_ANONYMOUS
-
1
0
)
;
munmap
(
memory
size
)
;
return
memory
!
=
MAP_FAILED
?
memory
:
NULL
;
}
bool
SharedMemory
:
:
ShareToProcessCommon
(
ProcessId
processId
SharedMemoryHandle
*
new_handle
bool
close_self
)
{
freezeable_
=
false
;
const
int
new_fd
=
dup
(
mapped_file_
.
get
(
)
)
;
DCHECK
(
new_fd
>
=
-
1
)
;
new_handle
-
>
fd
=
new_fd
;
new_handle
-
>
auto_close
=
true
;
if
(
close_self
)
Close
(
)
;
return
true
;
}
void
SharedMemory
:
:
Close
(
bool
unmap_view
)
{
if
(
unmap_view
)
{
Unmap
(
)
;
}
mapped_file_
=
nullptr
;
if
(
frozen_file_
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
freezeable
shared
memory
was
never
frozen
"
;
frozen_file_
=
nullptr
;
}
}
}
