#
include
"
base
/
shared_memory
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
ifdef
ANDROID
#
include
<
linux
/
ashmem
.
h
>
#
endif
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
prenv
.
h
"
namespace
base
{
SharedMemory
:
:
SharedMemory
(
)
:
mapped_file_
(
-
1
)
memory_
(
NULL
)
read_only_
(
false
)
max_size_
(
0
)
{
}
SharedMemory
:
:
~
SharedMemory
(
)
{
Close
(
)
;
}
bool
SharedMemory
:
:
SetHandle
(
SharedMemoryHandle
handle
bool
read_only
)
{
DCHECK
(
mapped_file_
=
=
-
1
)
;
mapped_file_
=
handle
.
fd
;
read_only_
=
read_only
;
return
true
;
}
bool
SharedMemory
:
:
IsHandleValid
(
const
SharedMemoryHandle
&
handle
)
{
return
handle
.
fd
>
=
0
;
}
SharedMemoryHandle
SharedMemory
:
:
NULLHandle
(
)
{
return
SharedMemoryHandle
(
)
;
}
bool
SharedMemory
:
:
AppendPosixShmPrefix
(
std
:
:
string
*
str
pid_t
pid
)
{
#
if
defined
(
ANDROID
)
|
|
defined
(
SHM_ANON
)
return
false
;
#
else
*
str
+
=
'
/
'
;
#
ifdef
OS_LINUX
static
const
char
*
const
kSnap
=
PR_GetEnv
(
"
SNAP_NAME
"
)
;
if
(
kSnap
)
{
StringAppendF
(
str
"
snap
.
%
s
.
"
kSnap
)
;
}
#
endif
StringAppendF
(
str
"
org
.
mozilla
.
ipc
.
%
d
.
"
static_cast
<
int
>
(
pid
)
)
;
return
true
;
#
endif
}
bool
SharedMemory
:
:
Create
(
size_t
size
)
{
read_only_
=
false
;
DCHECK
(
size
>
0
)
;
DCHECK
(
mapped_file_
=
=
-
1
)
;
int
fd
;
bool
needs_truncate
=
true
;
#
ifdef
ANDROID
fd
=
open
(
"
/
"
ASHMEM_NAME_DEF
O_RDWR
0600
)
;
if
(
fd
<
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
ioctl
(
fd
ASHMEM_SET_SIZE
size
)
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
set
shm
size
:
"
<
<
strerror
(
errno
)
;
close
(
fd
)
;
return
false
;
}
needs_truncate
=
false
;
#
elif
defined
(
SHM_ANON
)
fd
=
shm_open
(
SHM_ANON
O_RDWR
0600
)
;
#
else
do
{
static
mozilla
:
:
Atomic
<
size_t
>
sNameCounter
;
std
:
:
string
name
;
CHECK
(
AppendPosixShmPrefix
(
&
name
getpid
(
)
)
)
;
StringAppendF
(
&
name
"
%
zu
"
sNameCounter
+
+
)
;
fd
=
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDWR
|
O_CREAT
|
O_EXCL
0600
)
)
;
if
(
fd
>
=
0
)
{
if
(
shm_unlink
(
name
.
c_str
(
)
)
!
=
0
)
{
DLOG
(
FATAL
)
<
<
"
failed
to
unlink
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
}
while
(
fd
<
0
&
&
errno
=
=
EEXIST
)
;
#
endif
if
(
fd
<
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
needs_truncate
)
{
if
(
HANDLE_EINTR
(
ftruncate
(
fd
static_cast
<
off_t
>
(
size
)
)
)
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
set
shm
size
:
"
<
<
strerror
(
errno
)
;
close
(
fd
)
;
return
false
;
}
}
mapped_file_
=
fd
;
max_size_
=
size
;
return
true
;
}
bool
SharedMemory
:
:
Map
(
size_t
bytes
)
{
if
(
mapped_file_
=
=
-
1
)
return
false
;
memory_
=
mmap
(
NULL
bytes
PROT_READ
|
(
read_only_
?
0
:
PROT_WRITE
)
MAP_SHARED
mapped_file_
0
)
;
if
(
memory_
)
max_size_
=
bytes
;
bool
mmap_succeeded
=
(
memory_
!
=
(
void
*
)
-
1
)
;
DCHECK
(
mmap_succeeded
)
<
<
"
Call
to
mmap
failed
errno
=
"
<
<
errno
;
return
mmap_succeeded
;
}
bool
SharedMemory
:
:
Unmap
(
)
{
if
(
memory_
=
=
NULL
)
return
false
;
munmap
(
memory_
max_size_
)
;
memory_
=
NULL
;
max_size_
=
0
;
return
true
;
}
bool
SharedMemory
:
:
ShareToProcessCommon
(
ProcessId
processId
SharedMemoryHandle
*
new_handle
bool
close_self
)
{
const
int
new_fd
=
dup
(
mapped_file_
)
;
DCHECK
(
new_fd
>
=
-
1
)
;
new_handle
-
>
fd
=
new_fd
;
new_handle
-
>
auto_close
=
true
;
if
(
close_self
)
Close
(
)
;
return
true
;
}
void
SharedMemory
:
:
Close
(
bool
unmap_view
)
{
if
(
unmap_view
)
{
Unmap
(
)
;
}
if
(
mapped_file_
>
=
0
)
{
close
(
mapped_file_
)
;
mapped_file_
=
-
1
;
}
}
SharedMemoryHandle
SharedMemory
:
:
handle
(
)
const
{
return
FileDescriptor
(
mapped_file_
false
)
;
}
}
