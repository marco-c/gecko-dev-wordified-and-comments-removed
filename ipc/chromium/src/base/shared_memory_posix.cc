#
include
"
base
/
shared_memory
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
unistd
.
h
>
#
ifdef
ANDROID
#
include
"
mozilla
/
Ashmem
.
h
"
#
endif
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
prenv
.
h
"
#
include
"
GeckoProfiler
.
h
"
namespace
base
{
SharedMemory
:
:
SharedMemory
(
)
:
memory_
(
nullptr
)
max_size_
(
0
)
mapped_file_
(
nullptr
)
frozen_file_
(
nullptr
)
mapped_size_
(
0
)
read_only_
(
false
)
freezeable_
(
false
)
{
}
SharedMemory
:
:
SharedMemory
(
SharedMemory
&
&
other
)
{
memory_
=
other
.
memory_
;
max_size_
=
other
.
max_size_
;
mapped_file_
=
std
:
:
move
(
other
.
mapped_file_
)
;
frozen_file_
=
std
:
:
move
(
other
.
frozen_file_
)
;
mapped_size_
=
other
.
mapped_size_
;
read_only_
=
other
.
read_only_
;
freezeable_
=
other
.
freezeable_
;
other
.
mapped_size_
=
0
;
other
.
memory_
=
nullptr
;
}
SharedMemory
:
:
~
SharedMemory
(
)
{
Close
(
)
;
}
bool
SharedMemory
:
:
SetHandle
(
SharedMemoryHandle
handle
bool
read_only
)
{
DCHECK
(
!
mapped_file_
)
;
DCHECK
(
!
frozen_file_
)
;
freezeable_
=
false
;
mapped_file_
.
reset
(
handle
.
fd
)
;
read_only_
=
read_only
;
return
true
;
}
bool
SharedMemory
:
:
IsHandleValid
(
const
SharedMemoryHandle
&
handle
)
{
return
handle
.
fd
>
=
0
;
}
SharedMemoryHandle
SharedMemory
:
:
NULLHandle
(
)
{
return
SharedMemoryHandle
(
)
;
}
bool
SharedMemory
:
:
AppendPosixShmPrefix
(
std
:
:
string
*
str
pid_t
pid
)
{
#
if
defined
(
ANDROID
)
return
false
;
#
else
*
str
+
=
'
/
'
;
#
ifdef
OS_LINUX
static
const
char
*
const
kSnap
=
[
]
{
auto
instanceName
=
PR_GetEnv
(
"
SNAP_INSTANCE_NAME
"
)
;
if
(
instanceName
!
=
nullptr
)
{
return
instanceName
;
}
return
PR_GetEnv
(
"
SNAP_NAME
"
)
;
}
(
)
;
if
(
kSnap
)
{
StringAppendF
(
str
"
snap
.
%
s
.
"
kSnap
)
;
}
#
endif
StringAppendF
(
str
"
org
.
mozilla
.
ipc
.
%
d
.
"
static_cast
<
int
>
(
pid
)
)
;
return
true
;
#
endif
}
bool
SharedMemory
:
:
CreateInternal
(
size_t
size
bool
freezeable
)
{
read_only_
=
false
;
DCHECK
(
size
>
0
)
;
DCHECK
(
!
mapped_file_
)
;
DCHECK
(
!
frozen_file_
)
;
mozilla
:
:
UniqueFileHandle
fd
;
mozilla
:
:
UniqueFileHandle
frozen_fd
;
bool
needs_truncate
=
true
;
#
ifdef
ANDROID
fd
.
reset
(
mozilla
:
:
android
:
:
ashmem_create
(
nullptr
size
)
)
;
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
needs_truncate
=
false
;
#
else
do
{
static
mozilla
:
:
Atomic
<
size_t
>
sNameCounter
;
std
:
:
string
name
;
CHECK
(
AppendPosixShmPrefix
(
&
name
getpid
(
)
)
)
;
StringAppendF
(
&
name
"
%
zu
"
sNameCounter
+
+
)
;
fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDWR
|
O_CREAT
|
O_EXCL
0600
)
)
)
;
if
(
fd
)
{
if
(
freezeable
)
{
frozen_fd
.
reset
(
HANDLE_EINTR
(
shm_open
(
name
.
c_str
(
)
O_RDONLY
0400
)
)
)
;
if
(
!
frozen_fd
)
{
int
open_err
=
errno
;
shm_unlink
(
name
.
c_str
(
)
)
;
DLOG
(
FATAL
)
<
<
"
failed
to
re
-
open
freezeable
shm
:
"
<
<
strerror
(
open_err
)
;
return
false
;
}
}
if
(
shm_unlink
(
name
.
c_str
(
)
)
!
=
0
)
{
DLOG
(
FATAL
)
<
<
"
failed
to
unlink
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
}
while
(
!
fd
&
&
errno
=
=
EEXIST
)
;
#
endif
if
(
!
fd
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
open
shm
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
needs_truncate
)
{
#
if
defined
(
HAVE_POSIX_FALLOCATE
)
int
rv
;
{
AUTO_PROFILER_THREAD_SLEEP
;
rv
=
HANDLE_RV_EINTR
(
posix_fallocate
(
fd
.
get
(
)
0
static_cast
<
off_t
>
(
size
)
)
)
;
}
if
(
rv
!
=
0
)
{
if
(
rv
=
=
EOPNOTSUPP
|
|
rv
=
=
EINVAL
|
|
rv
=
=
ENODEV
)
{
int
fallocate_errno
=
rv
;
rv
=
HANDLE_EINTR
(
ftruncate
(
fd
.
get
(
)
static_cast
<
off_t
>
(
size
)
)
)
;
if
(
rv
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fallocate
failed
to
set
shm
size
:
"
<
<
strerror
(
fallocate_errno
)
;
CHROMIUM_LOG
(
WARNING
)
<
<
"
ftruncate
failed
to
set
shm
size
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
}
else
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
fallocate
failed
to
set
shm
size
:
"
<
<
strerror
(
rv
)
;
return
false
;
}
}
#
else
int
rv
=
HANDLE_EINTR
(
ftruncate
(
fd
.
get
(
)
static_cast
<
off_t
>
(
size
)
)
)
;
if
(
rv
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
ftruncate
failed
to
set
shm
size
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
#
endif
}
mapped_file_
=
std
:
:
move
(
fd
)
;
frozen_file_
=
std
:
:
move
(
frozen_fd
)
;
max_size_
=
size
;
freezeable_
=
freezeable
;
return
true
;
}
bool
SharedMemory
:
:
ReadOnlyCopy
(
SharedMemory
*
ro_out
)
{
DCHECK
(
mapped_file_
)
;
DCHECK
(
!
read_only_
)
;
CHECK
(
freezeable_
)
;
if
(
ro_out
=
=
this
)
{
DCHECK
(
!
memory_
)
;
}
mozilla
:
:
UniqueFileHandle
ro_file
;
#
ifdef
ANDROID
ro_file
=
std
:
:
move
(
mapped_file_
)
;
if
(
mozilla
:
:
android
:
:
ashmem_setProt
(
ro_file
.
get
(
)
PROT_READ
)
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
set
ashmem
read
-
only
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
#
else
DCHECK
(
frozen_file_
)
;
mapped_file_
=
nullptr
;
ro_file
=
std
:
:
move
(
frozen_file_
)
;
#
endif
DCHECK
(
ro_file
)
;
freezeable_
=
false
;
ro_out
-
>
Close
(
)
;
ro_out
-
>
mapped_file_
=
std
:
:
move
(
ro_file
)
;
ro_out
-
>
max_size_
=
max_size_
;
ro_out
-
>
read_only_
=
true
;
ro_out
-
>
freezeable_
=
false
;
return
true
;
}
bool
SharedMemory
:
:
Map
(
size_t
bytes
void
*
fixed_address
)
{
if
(
!
mapped_file_
)
{
return
false
;
}
DCHECK
(
!
memory_
)
;
void
*
mem
=
mmap
(
fixed_address
bytes
PROT_READ
|
(
read_only_
?
0
:
PROT_WRITE
)
MAP_SHARED
mapped_file_
.
get
(
)
0
)
;
if
(
mem
=
=
MAP_FAILED
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Call
to
mmap
failed
:
"
<
<
strerror
(
errno
)
;
return
false
;
}
if
(
fixed_address
&
&
mem
!
=
fixed_address
)
{
bool
munmap_succeeded
=
munmap
(
mem
bytes
)
=
=
0
;
DCHECK
(
munmap_succeeded
)
<
<
"
Call
to
munmap
failed
errno
=
"
<
<
errno
;
return
false
;
}
memory_
=
mem
;
mapped_size_
=
bytes
;
return
true
;
}
bool
SharedMemory
:
:
Unmap
(
)
{
if
(
memory_
=
=
NULL
)
return
false
;
munmap
(
memory_
mapped_size_
)
;
memory_
=
NULL
;
mapped_size_
=
0
;
return
true
;
}
void
*
SharedMemory
:
:
FindFreeAddressSpace
(
size_t
size
)
{
void
*
memory
=
mmap
(
NULL
size
PROT_NONE
MAP_PRIVATE
|
MAP_ANONYMOUS
-
1
0
)
;
munmap
(
memory
size
)
;
return
memory
!
=
MAP_FAILED
?
memory
:
NULL
;
}
bool
SharedMemory
:
:
ShareToProcessCommon
(
ProcessId
processId
SharedMemoryHandle
*
new_handle
bool
close_self
)
{
freezeable_
=
false
;
const
int
new_fd
=
dup
(
mapped_file_
.
get
(
)
)
;
DCHECK
(
new_fd
>
=
-
1
)
;
new_handle
-
>
fd
=
new_fd
;
new_handle
-
>
auto_close
=
true
;
if
(
close_self
)
Close
(
)
;
return
true
;
}
void
SharedMemory
:
:
Close
(
bool
unmap_view
)
{
if
(
unmap_view
)
{
Unmap
(
)
;
}
mapped_file_
=
nullptr
;
if
(
frozen_file_
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
freezeable
shared
memory
was
never
frozen
"
;
frozen_file_
=
nullptr
;
}
}
}
