#
include
"
base
/
object_watcher
.
h
"
#
include
"
base
/
logging
.
h
"
namespace
base
{
class
ObjectWatcher
:
:
Watch
:
public
mozilla
:
:
Runnable
{
public
:
ObjectWatcher
*
watcher
;
HANDLE
object
;
HANDLE
wait_object
;
MessageLoop
*
origin_loop
;
Delegate
*
delegate
;
bool
did_signal
;
Watch
(
)
:
mozilla
:
:
Runnable
(
"
ObjectWatcher
:
:
Watch
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
watcher
)
return
NS_OK
;
DCHECK
(
did_signal
)
;
watcher
-
>
StopWatching
(
)
;
delegate
-
>
OnObjectSignaled
(
object
)
;
return
NS_OK
;
}
}
;
ObjectWatcher
:
:
ObjectWatcher
(
)
:
watch_
(
nullptr
)
{
}
ObjectWatcher
:
:
~
ObjectWatcher
(
)
{
StopWatching
(
)
;
}
bool
ObjectWatcher
:
:
StartWatching
(
HANDLE
object
Delegate
*
delegate
)
{
if
(
watch_
)
{
NOTREACHED
(
)
<
<
"
Already
watching
an
object
"
;
return
false
;
}
RefPtr
<
Watch
>
watch
=
new
Watch
;
watch
-
>
watcher
=
this
;
watch
-
>
object
=
object
;
watch
-
>
origin_loop
=
MessageLoop
:
:
current
(
)
;
watch
-
>
delegate
=
delegate
;
watch
-
>
did_signal
=
false
;
DWORD
wait_flags
=
WT_EXECUTEDEFAULT
|
WT_EXECUTEONLYONCE
;
if
(
!
RegisterWaitForSingleObject
(
&
watch
-
>
wait_object
object
DoneWaiting
watch
.
get
(
)
INFINITE
wait_flags
)
)
{
NOTREACHED
(
)
<
<
"
RegisterWaitForSingleObject
failed
:
"
<
<
GetLastError
(
)
;
return
false
;
}
watch_
=
watch
.
forget
(
)
;
MessageLoop
:
:
current
(
)
-
>
AddDestructionObserver
(
this
)
;
return
true
;
}
bool
ObjectWatcher
:
:
StopWatching
(
)
{
if
(
!
watch_
)
return
false
;
DCHECK
(
watch_
-
>
origin_loop
=
=
MessageLoop
:
:
current
(
)
)
;
if
(
!
UnregisterWaitEx
(
watch_
-
>
wait_object
INVALID_HANDLE_VALUE
)
)
{
NOTREACHED
(
)
<
<
"
UnregisterWaitEx
failed
:
"
<
<
GetLastError
(
)
;
return
false
;
}
MemoryBarrier
(
)
;
watch_
-
>
watcher
=
NULL
;
watch_
=
nullptr
;
MessageLoop
:
:
current
(
)
-
>
RemoveDestructionObserver
(
this
)
;
return
true
;
}
HANDLE
ObjectWatcher
:
:
GetWatchedObject
(
)
{
if
(
!
watch_
)
return
NULL
;
return
watch_
-
>
object
;
}
void
CALLBACK
ObjectWatcher
:
:
DoneWaiting
(
void
*
param
BOOLEAN
timed_out
)
{
DCHECK
(
!
timed_out
)
;
Watch
*
watch
=
static_cast
<
Watch
*
>
(
param
)
;
RefPtr
<
Watch
>
addrefedWatch
=
watch
;
watch
-
>
did_signal
=
true
;
watch
-
>
origin_loop
-
>
PostTask
(
addrefedWatch
.
forget
(
)
)
;
}
void
ObjectWatcher
:
:
WillDestroyCurrentMessageLoop
(
)
{
StopWatching
(
)
;
}
}
