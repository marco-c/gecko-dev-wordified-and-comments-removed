#
include
"
chrome
/
common
/
ipc_channel_win
.
h
"
#
include
<
windows
.
h
>
#
include
<
sstream
>
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
rand_util
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
base
/
win_util
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
chrome
/
common
/
ipc_channel_utils
.
h
"
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
LateWriteChecks
.
h
"
#
include
"
mozilla
/
RandomNum
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
FUZZING
#
include
"
mozilla
/
ipc
/
Faulty
.
h
"
#
endif
using
namespace
mozilla
:
:
ipc
;
#
ifdef
DEBUG
#
define
ASSERT_OWNINGTHREAD
(
_class
)
\
if
(
nsAutoOwningThread
*
owningThread
=
_mOwningThread
.
get
(
)
)
{
\
owningThread
-
>
AssertOwnership
(
#
_class
"
not
thread
-
safe
"
)
;
\
}
#
else
#
define
ASSERT_OWNINGTHREAD
(
_class
)
(
(
void
)
0
)
#
endif
namespace
IPC
{
Channel
:
:
ChannelImpl
:
:
State
:
:
State
(
ChannelImpl
*
channel
)
:
is_pending
(
false
)
{
memset
(
&
context
.
overlapped
0
sizeof
(
context
.
overlapped
)
)
;
context
.
handler
=
channel
;
}
Channel
:
:
ChannelImpl
:
:
State
:
:
~
State
(
)
{
COMPILE_ASSERT
(
!
offsetof
(
Channel
:
:
ChannelImpl
:
:
State
context
)
starts_with_io_context
)
;
}
Channel
:
:
ChannelImpl
:
:
ChannelImpl
(
const
ChannelId
&
channel_id
Mode
mode
Listener
*
listener
)
:
ALLOW_THIS_IN_INITIALIZER_LIST
(
input_state_
(
this
)
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
output_state_
(
this
)
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
factory_
(
this
)
)
{
Init
(
mode
listener
)
;
if
(
!
CreatePipe
(
channel_id
mode
)
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Unable
to
create
pipe
named
\
"
"
<
<
channel_id
<
<
"
\
"
in
"
<
<
(
mode
=
=
0
?
"
server
"
:
"
client
"
)
<
<
"
mode
.
"
;
}
}
Channel
:
:
ChannelImpl
:
:
ChannelImpl
(
ChannelHandle
pipe
Mode
mode
Listener
*
listener
)
:
ALLOW_THIS_IN_INITIALIZER_LIST
(
input_state_
(
this
)
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
output_state_
(
this
)
)
ALLOW_THIS_IN_INITIALIZER_LIST
(
factory_
(
this
)
)
{
Init
(
mode
listener
)
;
if
(
!
pipe
)
{
closed_
=
true
;
return
;
}
shared_secret_
=
0
;
waiting_for_shared_secret_
=
false
;
pipe_
=
pipe
.
release
(
)
;
EnqueueHelloMessage
(
)
;
}
void
Channel
:
:
ChannelImpl
:
:
Init
(
Mode
mode
Listener
*
listener
)
{
static_assert
(
sizeof
(
*
this
)
<
=
512
"
Exceeded
expected
size
class
"
)
;
pipe_
=
INVALID_HANDLE_VALUE
;
listener_
=
listener
;
waiting_connect_
=
(
mode
=
=
MODE_SERVER
)
;
processing_incoming_
=
false
;
closed_
=
false
;
input_buf_offset_
=
0
;
input_buf_
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
Channel
:
:
kReadBufferSize
)
;
accept_handles_
=
false
;
privileged_
=
false
;
other_process_
=
INVALID_HANDLE_VALUE
;
}
void
Channel
:
:
ChannelImpl
:
:
OutputQueuePush
(
mozilla
:
:
UniquePtr
<
Message
>
msg
)
{
mozilla
:
:
LogIPCMessage
:
:
LogDispatchWithPid
(
msg
.
get
(
)
other_pid_
)
;
output_queue_
.
Push
(
std
:
:
move
(
msg
)
)
;
}
void
Channel
:
:
ChannelImpl
:
:
OutputQueuePop
(
)
{
mozilla
:
:
UniquePtr
<
Message
>
message
=
output_queue_
.
Pop
(
)
;
}
void
Channel
:
:
ChannelImpl
:
:
Close
(
)
{
ASSERT_OWNINGTHREAD
(
ChannelImpl
)
;
if
(
input_state_
.
is_pending
|
|
output_state_
.
is_pending
)
{
CancelIo
(
pipe_
)
;
}
if
(
pipe_
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
pipe_
)
;
pipe_
=
INVALID_HANDLE_VALUE
;
}
if
(
other_process_
!
=
INVALID_HANDLE_VALUE
)
{
CloseHandle
(
other_process_
)
;
other_process_
=
INVALID_HANDLE_VALUE
;
}
while
(
input_state_
.
is_pending
|
|
output_state_
.
is_pending
)
{
MessageLoopForIO
:
:
current
(
)
-
>
WaitForIOCompletion
(
INFINITE
this
)
;
}
while
(
!
output_queue_
.
IsEmpty
(
)
)
{
OutputQueuePop
(
)
;
}
#
ifdef
DEBUG
_mOwningThread
=
nullptr
;
#
endif
closed_
=
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
{
ASSERT_OWNINGTHREAD
(
ChannelImpl
)
;
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
sending
message
"
<
<
message
.
get
(
)
<
<
"
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
message
-
>
type
(
)
<
<
"
(
"
<
<
output_queue_
.
Count
(
)
<
<
"
in
queue
)
"
;
#
endif
#
ifdef
FUZZING
message
=
mozilla
:
:
ipc
:
:
Faulty
:
:
instance
(
)
.
MutateIPCMessage
(
"
Channel
:
:
ChannelImpl
:
:
Send
"
std
:
:
move
(
message
)
)
;
#
endif
if
(
closed_
)
{
if
(
mozilla
:
:
ipc
:
:
LoggingEnabled
(
)
)
{
fprintf
(
stderr
"
Can
'
t
send
message
%
s
because
this
channel
is
closed
.
\
n
"
message
-
>
name
(
)
)
;
}
return
false
;
}
OutputQueuePush
(
std
:
:
move
(
message
)
)
;
if
(
!
waiting_connect_
)
{
if
(
!
output_state_
.
is_pending
)
{
if
(
!
ProcessOutgoingMessages
(
NULL
0
)
)
return
false
;
}
}
return
true
;
}
const
Channel
:
:
ChannelId
Channel
:
:
ChannelImpl
:
:
PipeName
(
const
ChannelId
&
channel_id
int32_t
*
secret
)
const
{
MOZ_ASSERT
(
secret
)
;
std
:
:
wostringstream
ss
;
ss
<
<
L
"
\
\
\
\
.
\
\
pipe
\
\
chrome
.
"
;
size_t
index
=
channel_id
.
find_first_of
(
L
'
\
\
'
)
;
if
(
index
!
=
std
:
:
string
:
:
npos
)
{
StringToInt
(
channel_id
.
substr
(
index
+
1
)
secret
)
;
ss
<
<
channel_id
.
substr
(
0
index
-
1
)
;
}
else
{
*
secret
=
0
;
ss
<
<
channel_id
;
}
return
ss
.
str
(
)
;
}
bool
Channel
:
:
ChannelImpl
:
:
CreatePipe
(
const
ChannelId
&
channel_id
Mode
mode
)
{
DCHECK
(
pipe_
=
=
INVALID_HANDLE_VALUE
)
;
const
ChannelId
pipe_name
=
PipeName
(
channel_id
&
shared_secret_
)
;
if
(
mode
=
=
MODE_SERVER
)
{
waiting_for_shared_secret_
=
!
!
shared_secret_
;
pipe_
=
CreateNamedPipeW
(
pipe_name
.
c_str
(
)
PIPE_ACCESS_DUPLEX
|
FILE_FLAG_OVERLAPPED
|
FILE_FLAG_FIRST_PIPE_INSTANCE
PIPE_TYPE_BYTE
|
PIPE_READMODE_BYTE
1
Channel
:
:
kReadBufferSize
Channel
:
:
kReadBufferSize
5000
NULL
)
;
}
else
{
pipe_
=
CreateFileW
(
pipe_name
.
c_str
(
)
GENERIC_READ
|
GENERIC_WRITE
0
NULL
OPEN_EXISTING
SECURITY_SQOS_PRESENT
|
SECURITY_IDENTIFICATION
|
FILE_FLAG_OVERLAPPED
NULL
)
;
}
if
(
pipe_
=
=
INVALID_HANDLE_VALUE
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
create
pipe
:
"
<
<
GetLastError
(
)
;
closed_
=
true
;
return
false
;
}
return
EnqueueHelloMessage
(
)
;
}
bool
Channel
:
:
ChannelImpl
:
:
EnqueueHelloMessage
(
)
{
auto
m
=
mozilla
:
:
MakeUnique
<
Message
>
(
MSG_ROUTING_NONE
HELLO_MESSAGE_TYPE
)
;
int32_t
secret
=
waiting_for_shared_secret_
?
0
:
shared_secret_
;
if
(
!
m
-
>
WriteInt
(
GetCurrentProcessId
(
)
)
|
|
(
secret
&
&
!
m
-
>
WriteUInt32
(
secret
)
)
)
{
CloseHandle
(
pipe_
)
;
pipe_
=
INVALID_HANDLE_VALUE
;
return
false
;
}
OutputQueuePush
(
std
:
:
move
(
m
)
)
;
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
Connect
(
)
{
#
ifdef
DEBUG
if
(
!
_mOwningThread
)
{
_mOwningThread
=
mozilla
:
:
MakeUnique
<
nsAutoOwningThread
>
(
)
;
}
#
endif
if
(
pipe_
=
=
INVALID_HANDLE_VALUE
)
return
false
;
MessageLoopForIO
:
:
current
(
)
-
>
RegisterIOHandler
(
pipe_
this
)
;
if
(
waiting_connect_
)
{
if
(
!
ProcessConnection
(
)
)
{
return
false
;
}
}
if
(
!
input_state_
.
is_pending
)
{
MessageLoopForIO
:
:
current
(
)
-
>
PostTask
(
factory_
.
NewRunnableMethod
(
&
Channel
:
:
ChannelImpl
:
:
OnIOCompleted
&
input_state_
.
context
0
0
)
)
;
}
if
(
!
waiting_connect_
)
ProcessOutgoingMessages
(
NULL
0
)
;
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
ProcessConnection
(
)
{
ASSERT_OWNINGTHREAD
(
ChannelImpl
)
;
if
(
input_state_
.
is_pending
)
input_state_
.
is_pending
=
false
;
if
(
INVALID_HANDLE_VALUE
=
=
pipe_
)
return
false
;
BOOL
ok
=
ConnectNamedPipe
(
pipe_
&
input_state_
.
context
.
overlapped
)
;
DWORD
err
=
GetLastError
(
)
;
if
(
ok
)
{
NOTREACHED
(
)
;
return
false
;
}
switch
(
err
)
{
case
ERROR_IO_PENDING
:
input_state_
.
is_pending
=
true
;
break
;
case
ERROR_PIPE_CONNECTED
:
waiting_connect_
=
false
;
break
;
case
ERROR_NO_DATA
:
return
false
;
default
:
NOTREACHED
(
)
;
return
false
;
}
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
ProcessIncomingMessages
(
MessageLoopForIO
:
:
IOContext
*
context
DWORD
bytes_read
)
{
ASSERT_OWNINGTHREAD
(
ChannelImpl
)
;
if
(
input_state_
.
is_pending
)
{
input_state_
.
is_pending
=
false
;
DCHECK
(
context
)
;
if
(
!
context
|
|
!
bytes_read
)
return
false
;
}
else
{
DCHECK
(
!
bytes_read
&
&
context
=
=
&
input_state_
.
context
)
;
}
for
(
;
;
)
{
if
(
bytes_read
=
=
0
)
{
if
(
INVALID_HANDLE_VALUE
=
=
pipe_
)
return
false
;
BOOL
ok
=
ReadFile
(
pipe_
input_buf_
.
get
(
)
+
input_buf_offset_
Channel
:
:
kReadBufferSize
-
input_buf_offset_
&
bytes_read
&
input_state_
.
context
.
overlapped
)
;
if
(
!
ok
)
{
DWORD
err
=
GetLastError
(
)
;
if
(
err
=
=
ERROR_IO_PENDING
)
{
input_state_
.
is_pending
=
true
;
return
true
;
}
if
(
err
!
=
ERROR_BROKEN_PIPE
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
pipe
error
:
"
<
<
err
;
}
return
false
;
}
input_state_
.
is_pending
=
true
;
return
true
;
}
DCHECK
(
bytes_read
)
;
const
char
*
p
=
input_buf_
.
get
(
)
;
const
char
*
end
=
input_buf_
.
get
(
)
+
input_buf_offset_
+
bytes_read
;
while
(
p
<
end
)
{
uint32_t
message_length
=
0
;
if
(
incoming_message_
.
isSome
(
)
)
{
message_length
=
incoming_message_
.
ref
(
)
.
size
(
)
;
}
else
{
message_length
=
Message
:
:
MessageSize
(
p
end
)
;
}
if
(
!
message_length
)
{
MOZ_ASSERT
(
incoming_message_
.
isNothing
(
)
)
;
memmove
(
input_buf_
.
get
(
)
p
end
-
p
)
;
input_buf_offset_
=
end
-
p
;
break
;
}
input_buf_offset_
=
0
;
bool
partial
;
if
(
incoming_message_
.
isSome
(
)
)
{
Message
&
m
=
incoming_message_
.
ref
(
)
;
MOZ_ASSERT
(
message_length
>
m
.
CurrentSize
(
)
)
;
uint32_t
remaining
=
message_length
-
m
.
CurrentSize
(
)
;
uint32_t
in_buf
=
std
:
:
min
(
remaining
uint32_t
(
end
-
p
)
)
;
m
.
InputBytes
(
p
in_buf
)
;
p
+
=
in_buf
;
partial
=
in_buf
!
=
remaining
;
}
else
{
uint32_t
in_buf
=
std
:
:
min
(
message_length
uint32_t
(
end
-
p
)
)
;
incoming_message_
.
emplace
(
p
in_buf
)
;
p
+
=
in_buf
;
partial
=
in_buf
!
=
message_length
;
}
if
(
partial
)
{
break
;
}
Message
&
m
=
incoming_message_
.
ref
(
)
;
AddIPCProfilerMarker
(
m
other_pid_
MessageDirection
:
:
eReceiving
MessagePhase
:
:
TransferEnd
)
;
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
received
message
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
m
.
type
(
)
;
#
endif
if
(
m
.
routing_id
(
)
=
=
MSG_ROUTING_NONE
&
&
m
.
type
(
)
=
=
HELLO_MESSAGE_TYPE
)
{
MessageIterator
it
=
MessageIterator
(
m
)
;
other_pid_
=
it
.
NextInt
(
)
;
if
(
waiting_for_shared_secret_
&
&
(
it
.
NextInt
(
)
!
=
shared_secret_
)
)
{
NOTREACHED
(
)
;
Close
(
)
;
listener_
-
>
OnChannelError
(
)
;
return
false
;
}
waiting_for_shared_secret_
=
false
;
if
(
privileged_
&
&
other_process_
=
=
INVALID_HANDLE_VALUE
)
{
other_process_
=
OpenProcess
(
PROCESS_DUP_HANDLE
false
other_pid_
)
;
if
(
!
other_process_
)
{
other_process_
=
INVALID_HANDLE_VALUE
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
Failed
to
acquire
privileged
handle
to
"
<
<
other_pid_
<
<
"
cannot
accept
handles
"
;
}
}
listener_
-
>
OnChannelConnected
(
other_pid_
)
;
}
else
{
mozilla
:
:
LogIPCMessage
:
:
Run
run
(
&
m
)
;
if
(
!
AcceptHandles
(
m
)
)
{
return
false
;
}
listener_
-
>
OnMessageReceived
(
std
:
:
move
(
m
)
)
;
}
incoming_message_
.
reset
(
)
;
}
bytes_read
=
0
;
}
}
bool
Channel
:
:
ChannelImpl
:
:
ProcessOutgoingMessages
(
MessageLoopForIO
:
:
IOContext
*
context
DWORD
bytes_written
)
{
DCHECK
(
!
waiting_connect_
)
;
ASSERT_OWNINGTHREAD
(
ChannelImpl
)
;
if
(
output_state_
.
is_pending
)
{
DCHECK
(
context
)
;
output_state_
.
is_pending
=
false
;
if
(
!
context
|
|
bytes_written
=
=
0
)
{
DWORD
err
=
GetLastError
(
)
;
if
(
err
!
=
ERROR_BROKEN_PIPE
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
pipe
error
:
"
<
<
err
;
}
return
false
;
}
DCHECK
(
!
output_queue_
.
IsEmpty
(
)
)
;
Message
*
m
=
output_queue_
.
FirstElement
(
)
.
get
(
)
;
MOZ_RELEASE_ASSERT
(
partial_write_iter_
.
isSome
(
)
)
;
Pickle
:
:
BufferList
:
:
IterImpl
&
iter
=
partial_write_iter_
.
ref
(
)
;
iter
.
Advance
(
m
-
>
Buffers
(
)
bytes_written
)
;
if
(
iter
.
Done
(
)
)
{
AddIPCProfilerMarker
(
*
m
other_pid_
MessageDirection
:
:
eSending
MessagePhase
:
:
TransferEnd
)
;
partial_write_iter_
.
reset
(
)
;
OutputQueuePop
(
)
;
m
=
nullptr
;
}
}
if
(
output_queue_
.
IsEmpty
(
)
)
return
true
;
if
(
INVALID_HANDLE_VALUE
=
=
pipe_
)
return
false
;
Message
*
m
=
output_queue_
.
FirstElement
(
)
.
get
(
)
;
if
(
partial_write_iter_
.
isNothing
(
)
)
{
AddIPCProfilerMarker
(
*
m
other_pid_
MessageDirection
:
:
eSending
MessagePhase
:
:
TransferStart
)
;
if
(
!
TransferHandles
(
*
m
)
)
{
return
false
;
}
Pickle
:
:
BufferList
:
:
IterImpl
iter
(
m
-
>
Buffers
(
)
)
;
partial_write_iter_
.
emplace
(
iter
)
;
}
Pickle
:
:
BufferList
:
:
IterImpl
&
iter
=
partial_write_iter_
.
ref
(
)
;
mozilla
:
:
PushSuspendLateWriteChecks
(
)
;
BOOL
ok
=
WriteFile
(
pipe_
iter
.
Data
(
)
iter
.
RemainingInSegment
(
)
&
bytes_written
&
output_state_
.
context
.
overlapped
)
;
mozilla
:
:
PopSuspendLateWriteChecks
(
)
;
if
(
!
ok
)
{
DWORD
err
=
GetLastError
(
)
;
if
(
err
=
=
ERROR_IO_PENDING
)
{
output_state_
.
is_pending
=
true
;
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
sent
pending
message
"
<
<
m
<
<
"
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
m
-
>
type
(
)
;
#
endif
return
true
;
}
if
(
err
!
=
ERROR_BROKEN_PIPE
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
pipe
error
:
"
<
<
err
;
}
return
false
;
}
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
sent
message
"
<
<
m
<
<
"
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
m
-
>
type
(
)
;
#
endif
output_state_
.
is_pending
=
true
;
return
true
;
}
void
Channel
:
:
ChannelImpl
:
:
OnIOCompleted
(
MessageLoopForIO
:
:
IOContext
*
context
DWORD
bytes_transfered
DWORD
error
)
{
bool
ok
;
ASSERT_OWNINGTHREAD
(
ChannelImpl
)
;
if
(
context
=
=
&
input_state_
.
context
)
{
if
(
waiting_connect_
)
{
if
(
!
ProcessConnection
(
)
)
return
;
if
(
!
output_queue_
.
IsEmpty
(
)
&
&
!
output_state_
.
is_pending
)
ProcessOutgoingMessages
(
NULL
0
)
;
if
(
input_state_
.
is_pending
)
return
;
}
DCHECK
(
!
processing_incoming_
)
;
processing_incoming_
=
true
;
ok
=
ProcessIncomingMessages
(
context
bytes_transfered
)
;
processing_incoming_
=
false
;
}
else
{
DCHECK
(
context
=
=
&
output_state_
.
context
)
;
ok
=
ProcessOutgoingMessages
(
context
bytes_transfered
)
;
}
if
(
!
ok
&
&
INVALID_HANDLE_VALUE
!
=
pipe_
)
{
Close
(
)
;
listener_
-
>
OnChannelError
(
)
;
}
}
void
Channel
:
:
ChannelImpl
:
:
StartAcceptingHandles
(
Mode
mode
)
{
if
(
accept_handles_
)
{
MOZ_ASSERT
(
privileged_
=
=
(
mode
=
=
MODE_SERVER
)
)
;
return
;
}
accept_handles_
=
true
;
privileged_
=
mode
=
=
MODE_SERVER
;
if
(
privileged_
&
&
other_pid_
!
=
-
1
&
&
other_process_
=
=
INVALID_HANDLE_VALUE
)
{
other_process_
=
OpenProcess
(
PROCESS_DUP_HANDLE
false
other_pid_
)
;
if
(
!
other_process_
)
{
other_process_
=
INVALID_HANDLE_VALUE
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
Failed
to
acquire
privileged
handle
to
"
<
<
other_pid_
<
<
"
cannot
accept
handles
"
;
}
}
}
static
uint32_t
HandleToUint32
(
HANDLE
h
)
{
return
static_cast
<
uint32_t
>
(
reinterpret_cast
<
uintptr_t
>
(
h
)
)
;
}
static
HANDLE
Uint32ToHandle
(
uint32_t
h
)
{
return
reinterpret_cast
<
HANDLE
>
(
static_cast
<
uintptr_t
>
(
static_cast
<
int32_t
>
(
h
)
)
)
;
}
bool
Channel
:
:
ChannelImpl
:
:
AcceptHandles
(
Message
&
msg
)
{
MOZ_ASSERT
(
msg
.
num_handles
(
)
=
=
0
)
;
uint32_t
num_handles
=
msg
.
header
(
)
-
>
num_handles
;
if
(
num_handles
=
=
0
)
{
return
true
;
}
if
(
!
accept_handles_
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
invalid
message
:
"
<
<
msg
.
name
(
)
<
<
"
.
channel
is
not
configured
to
accept
handles
"
;
return
false
;
}
nsTArray
<
uint32_t
>
payload
;
payload
.
AppendElements
(
num_handles
)
;
if
(
!
msg
.
ReadFooter
(
payload
.
Elements
(
)
num_handles
*
sizeof
(
uint32_t
)
true
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
failed
to
read
handle
payload
from
message
"
;
return
false
;
}
msg
.
header
(
)
-
>
num_handles
=
0
;
nsTArray
<
mozilla
:
:
UniqueFileHandle
>
handles
(
num_handles
)
;
for
(
uint32_t
handleValue
:
payload
)
{
HANDLE
handle
=
Uint32ToHandle
(
handleValue
)
;
if
(
privileged_
)
{
if
(
other_process_
=
=
INVALID_HANDLE_VALUE
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
other_process_
is
invalid
in
AcceptHandles
"
;
return
false
;
}
if
(
!
:
:
DuplicateHandle
(
other_process_
handle
GetCurrentProcess
(
)
&
handle
0
FALSE
DUPLICATE_SAME_ACCESS
|
DUPLICATE_CLOSE_SOURCE
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
DuplicateHandle
failed
for
handle
"
<
<
handle
<
<
"
in
AcceptHandles
"
;
return
false
;
}
}
handles
.
AppendElement
(
mozilla
:
:
UniqueFileHandle
(
handle
)
)
;
}
msg
.
SetAttachedFileHandles
(
std
:
:
move
(
handles
)
)
;
MOZ_ASSERT
(
msg
.
num_handles
(
)
=
=
num_handles
)
;
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
TransferHandles
(
Message
&
msg
)
{
MOZ_ASSERT
(
msg
.
header
(
)
-
>
num_handles
=
=
0
)
;
uint32_t
num_handles
=
msg
.
num_handles
(
)
;
if
(
num_handles
=
=
0
)
{
return
true
;
}
if
(
!
accept_handles_
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
cannot
send
message
:
"
<
<
msg
.
name
(
)
<
<
"
.
channel
is
not
configured
to
accept
handles
"
;
return
false
;
}
#
ifdef
DEBUG
uint32_t
handles_offset
=
msg
.
header
(
)
-
>
payload_size
;
#
endif
nsTArray
<
uint32_t
>
payload
(
num_handles
)
;
for
(
uint32_t
i
=
0
;
i
<
num_handles
;
+
+
i
)
{
HANDLE
handle
=
msg
.
attached_handles_
[
i
]
.
release
(
)
;
if
(
privileged_
)
{
if
(
other_process_
=
=
INVALID_HANDLE_VALUE
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
other_process_
is
invalid
in
TransferHandles
"
;
return
false
;
}
if
(
!
:
:
DuplicateHandle
(
GetCurrentProcess
(
)
handle
other_process_
&
handle
0
FALSE
DUPLICATE_SAME_ACCESS
|
DUPLICATE_CLOSE_SOURCE
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
DuplicateHandle
failed
for
handle
"
<
<
handle
<
<
"
in
TransferHandles
"
;
return
false
;
}
}
payload
.
AppendElement
(
HandleToUint32
(
handle
)
)
;
}
msg
.
attached_handles_
.
Clear
(
)
;
msg
.
WriteFooter
(
payload
.
Elements
(
)
payload
.
Length
(
)
*
sizeof
(
uint32_t
)
)
;
msg
.
header
(
)
-
>
num_handles
=
num_handles
;
MOZ_ASSERT
(
msg
.
header
(
)
-
>
payload_size
=
=
handles_offset
+
(
sizeof
(
uint32_t
)
*
num_handles
)
"
Unexpected
number
of
bytes
written
for
handles
footer
?
"
)
;
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
IsClosed
(
)
const
{
return
closed_
;
}
Channel
:
:
Channel
(
const
ChannelId
&
channel_id
Mode
mode
Listener
*
listener
)
:
channel_impl_
(
new
ChannelImpl
(
channel_id
mode
listener
)
)
{
MOZ_COUNT_CTOR
(
IPC
:
:
Channel
)
;
}
Channel
:
:
Channel
(
ChannelHandle
pipe
Mode
mode
Listener
*
listener
)
:
channel_impl_
(
new
ChannelImpl
(
std
:
:
move
(
pipe
)
mode
listener
)
)
{
MOZ_COUNT_CTOR
(
IPC
:
:
Channel
)
;
}
Channel
:
:
~
Channel
(
)
{
MOZ_COUNT_DTOR
(
IPC
:
:
Channel
)
;
delete
channel_impl_
;
}
bool
Channel
:
:
Connect
(
)
{
return
channel_impl_
-
>
Connect
(
)
;
}
void
Channel
:
:
Close
(
)
{
channel_impl_
-
>
Close
(
)
;
}
void
Channel
:
:
StartAcceptingHandles
(
Mode
mode
)
{
channel_impl_
-
>
StartAcceptingHandles
(
mode
)
;
}
Channel
:
:
Listener
*
Channel
:
:
set_listener
(
Listener
*
listener
)
{
return
channel_impl_
-
>
set_listener
(
listener
)
;
}
bool
Channel
:
:
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
{
return
channel_impl_
-
>
Send
(
std
:
:
move
(
message
)
)
;
}
int32_t
Channel
:
:
OtherPid
(
)
const
{
return
channel_impl_
-
>
OtherPid
(
)
;
}
bool
Channel
:
:
IsClosed
(
)
const
{
return
channel_impl_
-
>
IsClosed
(
)
;
}
namespace
{
mozilla
:
:
Atomic
<
int
>
g_last_id
;
}
Channel
:
:
ChannelId
Channel
:
:
GenerateVerifiedChannelID
(
)
{
int
secret
;
do
{
secret
=
base
:
:
RandInt
(
0
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
;
}
while
(
secret
=
=
0
)
;
return
StringPrintf
(
L
"
%
d
.
%
u
.
%
d
\
\
%
d
"
base
:
:
GetCurrentProcId
(
)
g_last_id
+
+
base
:
:
RandInt
(
0
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
secret
)
;
}
Channel
:
:
ChannelId
Channel
:
:
ChannelIDForCurrentProcess
(
)
{
return
CommandLine
:
:
ForCurrentProcess
(
)
-
>
GetSwitchValue
(
switches
:
:
kProcessChannelID
)
;
}
bool
Channel
:
:
CreateRawPipe
(
ChannelHandle
*
server
ChannelHandle
*
client
)
{
std
:
:
wstring
pipe_name
=
StringPrintf
(
L
"
\
\
\
\
.
\
\
pipe
\
\
gecko
.
%
lu
.
%
lu
.
%
I64u
"
:
:
GetCurrentProcessId
(
)
:
:
GetCurrentThreadId
(
)
mozilla
:
:
RandomUint64OrDie
(
)
)
;
const
DWORD
kOpenMode
=
PIPE_ACCESS_DUPLEX
|
FILE_FLAG_OVERLAPPED
|
FILE_FLAG_FIRST_PIPE_INSTANCE
;
const
DWORD
kPipeMode
=
PIPE_TYPE_BYTE
|
PIPE_READMODE_BYTE
;
*
server
=
mozilla
:
:
UniqueFileHandle
(
:
:
CreateNamedPipeW
(
pipe_name
.
c_str
(
)
kOpenMode
kPipeMode
1
Channel
:
:
kReadBufferSize
Channel
:
:
kReadBufferSize
5000
nullptr
)
)
;
if
(
!
server
)
{
NS_WARNING
(
nsPrintfCString
(
"
CreateNamedPipeW
Failed
%
lu
"
:
:
GetLastError
(
)
)
.
get
(
)
)
;
return
false
;
}
const
DWORD
kDesiredAccess
=
GENERIC_READ
|
GENERIC_WRITE
;
const
DWORD
kFlags
=
SECURITY_SQOS_PRESENT
|
SECURITY_ANONYMOUS
|
FILE_FLAG_OVERLAPPED
;
*
client
=
mozilla
:
:
UniqueFileHandle
(
:
:
CreateFileW
(
pipe_name
.
c_str
(
)
kDesiredAccess
0
nullptr
OPEN_EXISTING
kFlags
nullptr
)
)
;
if
(
!
client
)
{
NS_WARNING
(
nsPrintfCString
(
"
CreateFileW
Failed
%
lu
"
:
:
GetLastError
(
)
)
.
get
(
)
)
;
return
false
;
}
if
(
:
:
ConnectNamedPipe
(
server
-
>
get
(
)
nullptr
)
|
|
:
:
GetLastError
(
)
!
=
ERROR_PIPE_CONNECTED
)
{
NS_WARNING
(
nsPrintfCString
(
"
ConnectNamedPipe
Failed
%
lu
"
:
:
GetLastError
(
)
)
.
get
(
)
)
;
return
false
;
}
return
true
;
}
}
