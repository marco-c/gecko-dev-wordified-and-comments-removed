#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
import
<
Foundation
/
Foundation
.
h
>
#
include
<
stdio
.
h
>
#
include
"
base
/
logging
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsDebug
.
h
"
MachSendMessage
:
:
MachSendMessage
(
int32_t
message_id
)
:
MachMessage
(
)
{
Initialize
(
message_id
)
;
}
MachSendMessage
:
:
MachSendMessage
(
void
*
storage
size_t
storage_length
int32_t
message_id
)
:
MachMessage
(
storage
storage_length
)
{
Initialize
(
message_id
)
;
}
void
MachSendMessage
:
:
Initialize
(
int32_t
message_id
)
{
Head
(
)
-
>
msgh_bits
=
MACH_MSGH_BITS
(
MACH_MSG_TYPE_COPY_SEND
0
)
;
Head
(
)
-
>
msgh_local_port
=
MACH_PORT_NULL
;
Head
(
)
-
>
msgh_reserved
=
0
;
Head
(
)
-
>
msgh_id
=
0
;
SetDescriptorCount
(
0
)
;
SetMessageID
(
message_id
)
;
SetData
(
NULL
0
)
;
}
MachMessage
:
:
MachMessage
(
)
:
storage_
(
new
MachMessageData
)
storage_length_bytes_
(
sizeof
(
MachMessageData
)
)
own_storage_
(
true
)
{
memset
(
storage_
0
storage_length_bytes_
)
;
}
MachMessage
:
:
MachMessage
(
void
*
storage
size_t
storage_length
)
:
storage_
(
static_cast
<
MachMessageData
*
>
(
storage
)
)
storage_length_bytes_
(
storage_length
)
own_storage_
(
false
)
{
DCHECK
(
storage
)
;
DCHECK
(
storage_length
>
=
kEmptyMessageSize
)
;
}
MachMessage
:
:
~
MachMessage
(
)
{
if
(
own_storage_
)
{
delete
storage_
;
storage_
=
NULL
;
}
}
u_int32_t
MachMessage
:
:
GetDataLength
(
)
{
return
EndianU32_LtoN
(
GetDataPacket
(
)
-
>
data_length
)
;
}
void
MachMessage
:
:
SetMessageID
(
int32_t
message_id
)
{
GetDataPacket
(
)
-
>
id
=
EndianU32_NtoL
(
message_id
)
;
}
int32_t
MachMessage
:
:
GetMessageID
(
)
{
return
EndianU32_LtoN
(
GetDataPacket
(
)
-
>
id
)
;
}
bool
MachMessage
:
:
SetData
(
const
void
*
data
int32_t
data_length
)
{
DCHECK
(
GetDataPacket
(
)
-
>
data_length
=
=
0
)
;
int
size
=
CalculateSize
(
)
;
int
new_size
=
size
+
data_length
;
if
(
(
unsigned
)
new_size
>
storage_length_bytes_
)
{
return
false
;
}
GetDataPacket
(
)
-
>
data_length
=
EndianU32_NtoL
(
data_length
)
;
if
(
data
)
memcpy
(
GetDataPacket
(
)
-
>
data
data
data_length
)
;
CalculateSize
(
)
;
return
true
;
}
int
MachMessage
:
:
CalculateSize
(
)
{
int
size
=
sizeof
(
mach_msg_header_t
)
+
sizeof
(
mach_msg_body_t
)
;
int32_t
alignedDataLength
=
(
GetDataLength
(
)
+
3
)
&
~
0x3
;
size
+
=
2
*
sizeof
(
int32_t
)
+
alignedDataLength
;
size
+
=
GetDescriptorCount
(
)
*
sizeof
(
MachMsgPortDescriptor
)
;
Head
(
)
-
>
msgh_size
=
size
;
return
size
;
}
MachMessage
:
:
MessageDataPacket
*
MachMessage
:
:
GetDataPacket
(
)
{
int
desc_size
=
sizeof
(
MachMsgPortDescriptor
)
*
GetDescriptorCount
(
)
;
MessageDataPacket
*
packet
=
reinterpret_cast
<
MessageDataPacket
*
>
(
storage_
-
>
padding
+
desc_size
)
;
return
packet
;
}
void
MachMessage
:
:
SetDescriptor
(
int
n
const
MachMsgPortDescriptor
&
desc
)
{
MachMsgPortDescriptor
*
desc_array
=
reinterpret_cast
<
MachMsgPortDescriptor
*
>
(
storage_
-
>
padding
)
;
desc_array
[
n
]
=
desc
;
}
bool
MachMessage
:
:
AddDescriptor
(
const
MachMsgPortDescriptor
&
desc
)
{
int
size
=
CalculateSize
(
)
;
int
new_size
=
size
+
sizeof
(
MachMsgPortDescriptor
)
;
if
(
(
unsigned
)
new_size
>
storage_length_bytes_
)
{
return
false
;
}
u_int8_t
*
p
=
reinterpret_cast
<
u_int8_t
*
>
(
GetDataPacket
(
)
)
;
bcopy
(
p
p
+
sizeof
(
MachMsgPortDescriptor
)
GetDataLength
(
)
+
2
*
sizeof
(
int32_t
)
)
;
SetDescriptor
(
GetDescriptorCount
(
)
desc
)
;
SetDescriptorCount
(
GetDescriptorCount
(
)
+
1
)
;
CalculateSize
(
)
;
return
true
;
}
void
MachMessage
:
:
SetDescriptorCount
(
int
n
)
{
storage_
-
>
body
.
msgh_descriptor_count
=
n
;
if
(
n
>
0
)
{
Head
(
)
-
>
msgh_bits
|
=
MACH_MSGH_BITS_COMPLEX
;
}
else
{
Head
(
)
-
>
msgh_bits
&
=
~
MACH_MSGH_BITS_COMPLEX
;
}
}
MachMsgPortDescriptor
*
MachMessage
:
:
GetDescriptor
(
int
n
)
{
if
(
n
<
GetDescriptorCount
(
)
)
{
MachMsgPortDescriptor
*
desc
=
reinterpret_cast
<
MachMsgPortDescriptor
*
>
(
storage_
-
>
padding
)
;
return
desc
+
n
;
}
return
nil
;
}
mach_port_t
MachMessage
:
:
GetTranslatedPort
(
int
n
)
{
if
(
n
<
GetDescriptorCount
(
)
)
{
return
GetDescriptor
(
n
)
-
>
GetMachPort
(
)
;
}
return
MACH_PORT_NULL
;
}
#
pragma
mark
-
ReceivePort
:
:
ReceivePort
(
const
char
*
receive_port_name
)
{
mach_port_t
current_task
=
mach_task_self
(
)
;
init_result_
=
mach_port_allocate
(
current_task
MACH_PORT_RIGHT_RECEIVE
&
port_
)
;
if
(
init_result_
!
=
KERN_SUCCESS
)
return
;
init_result_
=
mach_port_insert_right
(
current_task
port_
port_
MACH_MSG_TYPE_MAKE_SEND
)
;
if
(
init_result_
!
=
KERN_SUCCESS
)
return
;
NSPort
*
ns_port
=
[
NSMachPort
portWithMachPort
:
port_
]
;
NSString
*
port_name
=
[
NSString
stringWithUTF8String
:
receive_port_name
]
;
[
[
NSMachBootstrapServer
sharedInstance
]
registerPort
:
ns_port
name
:
port_name
]
;
}
ReceivePort
:
:
ReceivePort
(
)
{
mach_port_t
current_task
=
mach_task_self
(
)
;
init_result_
=
mach_port_allocate
(
current_task
MACH_PORT_RIGHT_RECEIVE
&
port_
)
;
if
(
init_result_
!
=
KERN_SUCCESS
)
return
;
init_result_
=
mach_port_insert_right
(
current_task
port_
port_
MACH_MSG_TYPE_MAKE_SEND
)
;
}
ReceivePort
:
:
ReceivePort
(
mach_port_t
receive_port
)
:
port_
(
receive_port
)
init_result_
(
KERN_SUCCESS
)
{
}
ReceivePort
:
:
~
ReceivePort
(
)
{
if
(
init_result_
=
=
KERN_SUCCESS
)
mach_port_deallocate
(
mach_task_self
(
)
port_
)
;
}
kern_return_t
ReceivePort
:
:
WaitForMessage
(
MachReceiveMessage
*
out_message
mach_msg_timeout_t
timeout
)
{
if
(
!
out_message
)
{
return
KERN_INVALID_ARGUMENT
;
}
if
(
init_result_
!
=
KERN_SUCCESS
)
return
init_result_
;
out_message
-
>
Head
(
)
-
>
msgh_bits
=
0
;
out_message
-
>
Head
(
)
-
>
msgh_local_port
=
port_
;
out_message
-
>
Head
(
)
-
>
msgh_remote_port
=
MACH_PORT_NULL
;
out_message
-
>
Head
(
)
-
>
msgh_reserved
=
0
;
out_message
-
>
Head
(
)
-
>
msgh_id
=
0
;
kern_return_t
result
=
mach_msg
(
out_message
-
>
Head
(
)
MACH_RCV_MSG
|
(
timeout
=
=
MACH_MSG_TIMEOUT_NONE
?
0
:
MACH_RCV_TIMEOUT
)
0
out_message
-
>
MaxSize
(
)
port_
timeout
MACH_PORT_NULL
)
;
return
result
;
}
kern_return_t
ReceivePort
:
:
SendMessageToSelf
(
MachSendMessage
&
message
mach_msg_timeout_t
timeout
)
{
if
(
message
.
Head
(
)
-
>
msgh_size
=
=
0
)
{
NOTREACHED
(
)
;
return
KERN_INVALID_VALUE
;
}
;
if
(
init_result_
!
=
KERN_SUCCESS
)
return
init_result_
;
message
.
Head
(
)
-
>
msgh_remote_port
=
port_
;
message
.
Head
(
)
-
>
msgh_bits
=
MACH_MSGH_BITS
(
MACH_MSG_TYPE_MAKE_SEND
MACH_MSG_TYPE_MAKE_SEND_ONCE
)
;
kern_return_t
result
=
mach_msg
(
message
.
Head
(
)
MACH_SEND_MSG
|
(
timeout
=
=
MACH_MSG_TIMEOUT_NONE
?
0
:
MACH_SEND_TIMEOUT
)
message
.
Head
(
)
-
>
msgh_size
0
MACH_PORT_NULL
timeout
MACH_PORT_NULL
)
;
return
result
;
}
#
pragma
mark
-
MachPortSender
:
:
MachPortSender
(
const
char
*
receive_port_name
)
{
mach_port_t
bootstrap_port
=
0
;
init_result_
=
task_get_bootstrap_port
(
mach_task_self
(
)
&
bootstrap_port
)
;
if
(
init_result_
!
=
KERN_SUCCESS
)
return
;
init_result_
=
bootstrap_look_up
(
bootstrap_port
const_cast
<
char
*
>
(
receive_port_name
)
&
send_port_
)
;
}
MachPortSender
:
:
MachPortSender
(
mach_port_t
send_port
)
:
send_port_
(
send_port
)
init_result_
(
KERN_SUCCESS
)
{
}
kern_return_t
MachPortSender
:
:
SendMessage
(
MachSendMessage
&
message
mach_msg_timeout_t
timeout
)
{
if
(
message
.
Head
(
)
-
>
msgh_size
=
=
0
)
{
NOTREACHED
(
)
;
return
KERN_INVALID_VALUE
;
}
;
if
(
init_result_
!
=
KERN_SUCCESS
)
return
init_result_
;
message
.
Head
(
)
-
>
msgh_remote_port
=
send_port_
;
kern_return_t
result
=
mach_msg
(
message
.
Head
(
)
MACH_SEND_MSG
|
(
timeout
=
=
MACH_MSG_TIMEOUT_NONE
?
0
:
MACH_SEND_TIMEOUT
)
message
.
Head
(
)
-
>
msgh_size
0
MACH_PORT_NULL
timeout
MACH_PORT_NULL
)
;
return
result
;
}
namespace
{
struct
MachSinglePortMessage
{
mach_msg_header_t
header
;
mach_msg_body_t
body
;
mach_msg_port_descriptor_t
data
;
}
;
struct
MachSinglePortMessageTrailer
:
MachSinglePortMessage
{
mach_msg_audit_trailer_t
trailer
;
}
;
}
kern_return_t
MachSendPortSendRight
(
mach_port_t
endpoint
mach_port_t
attachment
mozilla
:
:
Maybe
<
mach_msg_timeout_t
>
opt_timeout
mach_msg_type_name_t
endpoint_disposition
)
{
mach_msg_option_t
opts
=
MACH_SEND_MSG
;
mach_msg_timeout_t
timeout
=
MACH_MSG_TIMEOUT_NONE
;
if
(
opt_timeout
)
{
opts
|
=
MACH_SEND_TIMEOUT
;
timeout
=
*
opt_timeout
;
}
MachSinglePortMessage
send_msg
{
}
;
send_msg
.
header
.
msgh_bits
=
MACH_MSGH_BITS
(
endpoint_disposition
0
)
|
MACH_MSGH_BITS_COMPLEX
;
send_msg
.
header
.
msgh_size
=
sizeof
(
send_msg
)
;
send_msg
.
header
.
msgh_remote_port
=
endpoint
;
send_msg
.
header
.
msgh_local_port
=
MACH_PORT_NULL
;
send_msg
.
header
.
msgh_reserved
=
0
;
send_msg
.
header
.
msgh_id
=
0
;
send_msg
.
body
.
msgh_descriptor_count
=
1
;
send_msg
.
data
.
name
=
attachment
;
send_msg
.
data
.
disposition
=
MACH_MSG_TYPE_COPY_SEND
;
send_msg
.
data
.
type
=
MACH_MSG_PORT_DESCRIPTOR
;
return
mach_msg
(
&
send_msg
.
header
opts
send_msg
.
header
.
msgh_size
0
MACH_PORT_NULL
timeout
MACH_PORT_NULL
)
;
}
kern_return_t
MachReceivePortSendRight
(
const
mozilla
:
:
UniqueMachReceiveRight
&
endpoint
mozilla
:
:
Maybe
<
mach_msg_timeout_t
>
opt_timeout
mozilla
:
:
UniqueMachSendRight
*
attachment
audit_token_t
*
audit_token
)
{
mach_msg_option_t
opts
=
MACH_RCV_MSG
|
MACH_RCV_TRAILER_TYPE
(
MACH_MSG_TRAILER_FORMAT_0
)
|
MACH_RCV_TRAILER_ELEMENTS
(
MACH_RCV_TRAILER_AUDIT
)
;
mach_msg_timeout_t
timeout
=
MACH_MSG_TIMEOUT_NONE
;
if
(
opt_timeout
)
{
opts
|
=
MACH_RCV_TIMEOUT
;
timeout
=
*
opt_timeout
;
}
MachSinglePortMessageTrailer
recv_msg
{
}
;
recv_msg
.
header
.
msgh_local_port
=
endpoint
.
get
(
)
;
recv_msg
.
header
.
msgh_size
=
sizeof
(
recv_msg
)
;
kern_return_t
kr
=
mach_msg
(
&
recv_msg
.
header
opts
0
recv_msg
.
header
.
msgh_size
endpoint
.
get
(
)
timeout
MACH_PORT_NULL
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
return
kr
;
}
if
(
NS_WARN_IF
(
!
(
recv_msg
.
header
.
msgh_bits
&
MACH_MSGH_BITS_COMPLEX
)
)
|
|
NS_WARN_IF
(
recv_msg
.
body
.
msgh_descriptor_count
!
=
1
)
|
|
NS_WARN_IF
(
recv_msg
.
data
.
type
!
=
MACH_MSG_PORT_DESCRIPTOR
)
|
|
NS_WARN_IF
(
recv_msg
.
data
.
disposition
!
=
MACH_MSG_TYPE_MOVE_SEND
)
|
|
NS_WARN_IF
(
recv_msg
.
header
.
msgh_size
!
=
sizeof
(
MachSinglePortMessage
)
)
)
{
mach_msg_destroy
(
&
recv_msg
.
header
)
;
return
KERN_FAILURE
;
}
attachment
-
>
reset
(
recv_msg
.
data
.
name
)
;
if
(
audit_token
)
{
*
audit_token
=
recv_msg
.
trailer
.
msgh_audit
;
}
return
KERN_SUCCESS
;
}
