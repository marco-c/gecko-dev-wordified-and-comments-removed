#
ifndef
CHROME_COMMON_IPC_CHANNEL_WIN_H_
#
define
CHROME_COMMON_IPC_CHANNEL_WIN_H_
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
chrome
/
common
/
ipc_message
.
h
"
#
include
<
atomic
>
#
include
<
string
>
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
EventTargetCapability
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
EventTargetAndLockCapability
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
IPC
{
class
Channel
:
:
ChannelImpl
:
public
MessageLoopForIO
:
:
IOHandler
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DELETE_ON_EVENT_TARGET
(
ChannelImpl
IOThread
(
)
.
GetEventTarget
(
)
)
;
using
ChannelHandle
=
Channel
:
:
ChannelHandle
;
ChannelImpl
(
ChannelHandle
pipe
Mode
mode
base
:
:
ProcessId
other_pid
)
;
bool
Connect
(
Listener
*
listener
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
void
Close
(
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
void
StartAcceptingHandles
(
Mode
mode
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
bool
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
void
SetOtherPid
(
base
:
:
ProcessId
other_pid
)
;
bool
IsClosed
(
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
{
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteLockHeld
(
)
;
return
pipe_
=
=
INVALID_HANDLE_VALUE
;
}
private
:
~
ChannelImpl
(
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
if
(
pipe_
!
=
INVALID_HANDLE_VALUE
|
|
other_process_
!
=
INVALID_HANDLE_VALUE
)
{
Close
(
)
;
}
}
void
Init
(
Mode
mode
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
void
OutputQueuePush
(
mozilla
:
:
UniquePtr
<
Message
>
msg
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
void
OutputQueuePop
(
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
bool
EnqueueHelloMessage
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
void
CloseLocked
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
bool
ProcessIncomingMessages
(
MessageLoopForIO
:
:
IOContext
*
context
DWORD
bytes_read
bool
was_pending
)
MOZ_REQUIRES
(
IOThread
(
)
)
;
bool
ProcessOutgoingMessages
(
MessageLoopForIO
:
:
IOContext
*
context
DWORD
bytes_written
bool
was_pending
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
bool
AcceptHandles
(
Message
&
msg
)
MOZ_REQUIRES
(
IOThread
(
)
)
;
bool
TransferHandles
(
Message
&
msg
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
virtual
void
OnIOCompleted
(
MessageLoopForIO
:
:
IOContext
*
context
DWORD
bytes_transfered
DWORD
error
)
;
const
mozilla
:
:
EventTargetCapability
<
nsISerialEventTarget
>
&
IOThread
(
)
const
MOZ_RETURN_CAPABILITY
(
chan_cap_
.
Target
(
)
)
{
return
chan_cap_
.
Target
(
)
;
}
mozilla
:
:
Mutex
&
SendMutex
(
)
MOZ_RETURN_CAPABILITY
(
chan_cap_
.
Lock
(
)
)
{
return
chan_cap_
.
Lock
(
)
;
}
private
:
mozilla
:
:
EventTargetAndLockCapability
<
nsISerialEventTarget
mozilla
:
:
Mutex
>
chan_cap_
;
Mode
mode_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
struct
State
{
explicit
State
(
ChannelImpl
*
channel
)
;
~
State
(
)
;
MessageLoopForIO
:
:
IOContext
context
;
RefPtr
<
ChannelImpl
>
is_pending
;
}
;
State
input_state_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
State
output_state_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
HANDLE
pipe_
MOZ_GUARDED_BY
(
chan_cap_
)
=
INVALID_HANDLE_VALUE
;
Listener
*
listener_
MOZ_GUARDED_BY
(
IOThread
(
)
)
=
nullptr
;
mozilla
:
:
Queue
<
mozilla
:
:
UniquePtr
<
Message
>
64
>
output_queue_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
mozilla
:
:
Maybe
<
Pickle
:
:
BufferList
:
:
IterImpl
>
partial_write_iter_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
input_buf_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
size_t
input_buf_offset_
MOZ_GUARDED_BY
(
IOThread
(
)
)
=
0
;
mozilla
:
:
UniquePtr
<
Message
>
incoming_message_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
bool
waiting_connect_
MOZ_GUARDED_BY
(
chan_cap_
)
=
true
;
bool
processing_incoming_
MOZ_GUARDED_BY
(
IOThread
(
)
)
=
false
;
base
:
:
ProcessId
other_pid_
MOZ_GUARDED_BY
(
chan_cap_
)
=
base
:
:
kInvalidProcessId
;
bool
accept_handles_
MOZ_GUARDED_BY
(
chan_cap_
)
=
false
;
bool
privileged_
MOZ_GUARDED_BY
(
chan_cap_
)
=
false
;
HANDLE
other_process_
MOZ_GUARDED_BY
(
chan_cap_
)
=
INVALID_HANDLE_VALUE
;
DISALLOW_COPY_AND_ASSIGN
(
ChannelImpl
)
;
}
;
}
#
endif
