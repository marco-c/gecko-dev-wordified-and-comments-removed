#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
mutex
>
#
include
<
signal
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
chrome
/
common
/
process_watcher
.
h
"
#
ifdef
MOZ_ENABLE_FORKSERVER
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
endif
#
if
defined
(
XP_UNIX
)
&
&
!
defined
(
XP_MACOSX
)
&
&
0
#
define
HAVE_PIPE2
1
#
endif
static
const
int
kMaxWaitMs
=
2000
;
namespace
{
struct
PendingChild
{
pid_t
mPid
;
nsCOMPtr
<
nsITimer
>
mForce
;
}
;
static
mozilla
:
:
StaticDataMutex
<
mozilla
:
:
StaticAutoPtr
<
nsTArray
<
PendingChild
>
>
>
gPendingChildren
(
"
ProcessWatcher
:
:
gPendingChildren
"
)
;
static
int
gSignalPipe
[
2
]
=
{
-
1
-
1
}
;
enum
class
BlockingWait
{
NO
YES
}
;
#
ifdef
MOZ_ENABLE_FORKSERVER
static
bool
IsForkServerEnabled
(
)
{
return
mozilla
:
:
StaticPrefs
:
:
dom_ipc_forkserver_enable_AtStartup
(
)
;
}
static
pid_t
FakeWaitpid
(
pid_t
pid
int
*
wstatus
int
options
)
{
int
real_rv
=
HANDLE_EINTR
(
waitpid
(
pid
wstatus
options
|
WNOHANG
)
)
;
if
(
real_rv
!
=
-
1
|
|
errno
!
=
ECHILD
)
{
return
real_rv
;
}
static
constexpr
long
kDelayMS
=
500
;
static
constexpr
int
kAttempts
=
10
;
if
(
options
&
~
WNOHANG
)
{
errno
=
EINVAL
;
return
-
1
;
}
static
constexpr
int
kZero
=
0
;
static_assert
(
WIFEXITED
(
kZero
)
)
;
static_assert
(
WEXITSTATUS
(
kZero
)
=
=
0
)
;
if
(
wstatus
)
{
*
wstatus
=
0
;
}
for
(
int
attempt
=
0
;
attempt
<
kAttempts
;
+
+
attempt
)
{
int
rv
=
kill
(
pid
0
)
;
if
(
rv
=
=
0
)
{
if
(
options
&
WNOHANG
)
{
return
0
;
}
}
else
{
if
(
errno
=
=
ESRCH
)
{
return
pid
;
}
return
-
1
;
}
struct
timespec
delay
=
{
(
kDelayMS
/
1000
)
(
kDelayMS
%
1000
)
*
1000
*
1000
}
;
HANDLE_EINTR
(
nanosleep
(
&
delay
&
delay
)
)
;
}
errno
=
ETIME
;
return
-
1
;
}
#
endif
static
bool
WaitForProcess
(
pid_t
pid
BlockingWait
aBlock
)
{
int
wstatus
;
int
flags
=
aBlock
=
=
BlockingWait
:
:
NO
?
WNOHANG
:
0
;
pid_t
(
*
waitpidImpl
)
(
pid_t
int
*
int
)
=
waitpid
;
#
ifdef
MOZ_ENABLE_FORKSERVER
if
(
IsForkServerEnabled
(
)
)
{
waitpidImpl
=
FakeWaitpid
;
}
#
endif
pid_t
rv
=
HANDLE_EINTR
(
waitpidImpl
(
pid
&
wstatus
flags
)
)
;
if
(
rv
<
0
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
waitpid
failed
(
pid
"
<
<
pid
<
<
"
)
:
"
<
<
strerror
(
errno
)
;
return
true
;
}
if
(
rv
=
=
0
)
{
MOZ_ASSERT
(
aBlock
=
=
BlockingWait
:
:
NO
)
;
return
false
;
}
if
(
WIFEXITED
(
wstatus
)
&
&
WEXITSTATUS
(
wstatus
)
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
process
"
<
<
pid
<
<
"
exited
with
status
"
<
<
WEXITSTATUS
(
wstatus
)
;
}
else
if
(
WIFSIGNALED
(
wstatus
)
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
process
"
<
<
pid
<
<
"
exited
on
signal
"
<
<
WTERMSIG
(
wstatus
)
;
}
return
true
;
}
already_AddRefed
<
nsITimer
>
DelayedKill
(
pid_t
aPid
)
{
nsCOMPtr
<
nsITimer
>
timer
;
nsresult
rv
=
NS_NewTimerWithCallback
(
getter_AddRefs
(
timer
)
[
aPid
]
(
nsITimer
*
)
{
if
(
kill
(
aPid
SIGKILL
)
!
=
0
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
failed
to
send
SIGKILL
to
process
"
<
<
aPid
;
}
}
kMaxWaitMs
nsITimer
:
:
TYPE_ONE_SHOT
"
ProcessWatcher
:
:
DelayedKill
"
XRE_GetIOMessageLoop
(
)
-
>
SerialEventTarget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
failed
to
start
kill
timer
for
process
"
<
<
aPid
<
<
"
;
killing
immediately
"
;
kill
(
aPid
SIGKILL
)
;
return
nullptr
;
}
return
timer
.
forget
(
)
;
}
class
ProcessCleaner
final
:
public
MessageLoopForIO
:
:
Watcher
public
MessageLoop
:
:
DestructionObserver
{
public
:
void
Register
(
)
{
MessageLoopForIO
*
loop
=
MessageLoopForIO
:
:
current
(
)
;
loop
-
>
AddDestructionObserver
(
this
)
;
loop
-
>
WatchFileDescriptor
(
gSignalPipe
[
0
]
true
MessageLoopForIO
:
:
WATCH_READ
&
mWatcher
this
)
;
}
void
OnFileCanReadWithoutBlocking
(
int
fd
)
override
{
DCHECK
(
fd
=
=
gSignalPipe
[
0
]
)
;
ssize_t
rv
;
do
{
char
msg
;
rv
=
HANDLE_EINTR
(
read
(
gSignalPipe
[
0
]
&
msg
1
)
)
;
CHECK
(
rv
!
=
0
)
;
if
(
rv
<
0
)
{
DCHECK
(
errno
=
=
EAGAIN
|
|
errno
=
=
EWOULDBLOCK
)
;
}
else
{
DCHECK
(
msg
=
=
0
)
;
}
}
while
(
rv
>
0
)
;
PruneDeadProcesses
(
)
;
}
void
OnFileCanWriteWithoutBlocking
(
int
fd
)
override
{
CHROMIUM_LOG
(
FATAL
)
<
<
"
unreachable
"
;
}
void
WillDestroyCurrentMessageLoop
(
)
override
{
mWatcher
.
StopWatchingFileDescriptor
(
)
;
auto
lock
=
gPendingChildren
.
Lock
(
)
;
auto
&
children
=
lock
.
ref
(
)
;
if
(
children
)
{
for
(
const
auto
&
child
:
*
children
)
{
if
(
child
.
mForce
)
{
if
(
kill
(
child
.
mPid
SIGKILL
)
!
=
0
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
failed
to
send
SIGKILL
to
process
"
<
<
child
.
mPid
;
continue
;
}
}
else
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Waiting
in
WillDestroyCurrentMessageLoop
for
pid
"
<
<
child
.
mPid
;
}
WaitForProcess
(
child
.
mPid
BlockingWait
:
:
YES
)
;
}
children
=
nullptr
;
}
delete
this
;
}
private
:
MessageLoopForIO
:
:
FileDescriptorWatcher
mWatcher
;
static
void
PruneDeadProcesses
(
)
{
auto
lock
=
gPendingChildren
.
Lock
(
)
;
auto
&
children
=
lock
.
ref
(
)
;
if
(
!
children
|
|
children
-
>
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
PendingChild
>
live
;
for
(
const
auto
&
child
:
*
children
)
{
if
(
WaitForProcess
(
child
.
mPid
BlockingWait
:
:
NO
)
)
{
if
(
child
.
mForce
)
{
child
.
mForce
-
>
Cancel
(
)
;
}
}
else
{
live
.
AppendElement
(
child
)
;
}
}
*
children
=
std
:
:
move
(
live
)
;
}
}
;
static
void
HandleSigChld
(
int
signum
)
{
DCHECK
(
signum
=
=
SIGCHLD
)
;
char
msg
=
0
;
HANDLE_EINTR
(
write
(
gSignalPipe
[
1
]
&
msg
1
)
)
;
}
static
void
ProcessWatcherInit
(
)
{
int
rv
;
#
ifdef
HAVE_PIPE2
rv
=
pipe2
(
gSignalPipe
O_NONBLOCK
|
O_CLOEXEC
)
;
CHECK
(
rv
=
=
0
)
<
<
"
pipe2
(
)
failed
"
;
#
else
rv
=
pipe
(
gSignalPipe
)
;
CHECK
(
rv
=
=
0
)
<
<
"
pipe
(
)
failed
"
;
for
(
int
fd
:
gSignalPipe
)
{
rv
=
fcntl
(
fd
F_SETFL
O_NONBLOCK
)
;
CHECK
(
rv
=
=
0
)
<
<
"
O_NONBLOCK
failed
"
;
rv
=
fcntl
(
fd
F_SETFD
FD_CLOEXEC
)
;
CHECK
(
rv
=
=
0
)
<
<
"
FD_CLOEXEC
failed
"
;
}
#
endif
auto
oldHandler
=
signal
(
SIGCHLD
HandleSigChld
)
;
CHECK
(
oldHandler
!
=
SIG_ERR
)
;
DCHECK
(
oldHandler
=
=
SIG_DFL
)
;
XRE_GetIOMessageLoop
(
)
-
>
PostTask
(
NS_NewRunnableFunction
(
"
ProcessCleaner
:
:
Register
"
[
]
{
ProcessCleaner
*
pc
=
new
ProcessCleaner
(
)
;
pc
-
>
Register
(
)
;
}
)
)
;
}
}
void
ProcessWatcher
:
:
EnsureProcessTerminated
(
base
:
:
ProcessHandle
process
bool
force
)
{
DCHECK
(
process
!
=
base
:
:
GetCurrentProcId
(
)
)
;
DCHECK
(
process
>
0
)
;
static
std
:
:
once_flag
sInited
;
std
:
:
call_once
(
sInited
ProcessWatcherInit
)
;
auto
lock
=
gPendingChildren
.
Lock
(
)
;
auto
&
children
=
lock
.
ref
(
)
;
if
(
WaitForProcess
(
process
BlockingWait
:
:
NO
)
)
{
return
;
}
if
(
!
children
)
{
children
=
new
nsTArray
<
PendingChild
>
(
)
;
}
for
(
const
auto
&
child
:
*
children
)
{
if
(
child
.
mPid
=
=
process
)
{
#
ifdef
MOZ_ENABLE_FORKSERVER
if
(
IsForkServerEnabled
(
)
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
EnsureProcessTerminated
:
duplicate
process
"
"
ID
"
<
<
process
<
<
"
;
assuming
this
is
because
of
the
fork
"
"
server
.
"
;
return
;
}
#
endif
MOZ_ASSERT
(
false
"
EnsureProcessTerminated
must
be
called
at
most
once
for
a
"
"
given
process
"
)
;
return
;
}
}
PendingChild
child
{
}
;
child
.
mPid
=
process
;
if
(
force
)
{
child
.
mForce
=
DelayedKill
(
process
)
;
}
children
-
>
AppendElement
(
std
:
:
move
(
child
)
)
;
}
