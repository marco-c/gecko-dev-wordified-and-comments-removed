#
include
<
errno
.
h
>
#
include
<
signal
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
wait
.
h
>
#
include
<
unistd
.
h
>
#
include
<
time
.
h
>
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
prenv
.
h
"
#
include
"
chrome
/
common
/
process_watcher
.
h
"
static
constexpr
int
kMaxWaitMs
=
2000
;
#
if
defined
(
MOZ_ASAN
)
|
|
defined
(
MOZ_TSAN
)
static
constexpr
int
kShutdownWaitMs
=
40000
;
#
else
static
constexpr
int
kShutdownWaitMs
=
8000
;
#
endif
namespace
{
class
ChildReaper
:
public
base
:
:
MessagePumpLibevent
:
:
SignalEvent
public
base
:
:
MessagePumpLibevent
:
:
SignalWatcher
{
public
:
explicit
ChildReaper
(
pid_t
process
)
:
process_
(
process
)
{
}
virtual
~
ChildReaper
(
)
{
DCHECK
(
!
process_
)
;
}
virtual
void
OnSignal
(
int
sig
)
override
{
DCHECK
(
SIGCHLD
=
=
sig
)
;
DCHECK
(
process_
)
;
if
(
base
:
:
IsProcessDead
(
process_
)
)
{
process_
=
0
;
StopCatching
(
)
;
}
}
protected
:
void
WaitForChildExit
(
)
{
CHECK
(
process_
)
;
while
(
!
base
:
:
IsProcessDead
(
process_
true
)
)
{
sleep
(
1
)
;
}
}
pid_t
process_
;
private
:
ChildReaper
(
const
ChildReaper
&
)
=
delete
;
const
ChildReaper
&
operator
=
(
const
ChildReaper
&
)
=
delete
;
}
;
class
ChildGrimReaper
:
public
ChildReaper
public
mozilla
:
:
Runnable
{
public
:
explicit
ChildGrimReaper
(
pid_t
process
)
:
ChildReaper
(
process
)
mozilla
:
:
Runnable
(
"
ChildGrimReaper
"
)
{
}
virtual
~
ChildGrimReaper
(
)
{
if
(
process_
)
KillProcess
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
process_
)
KillProcess
(
)
;
return
NS_OK
;
}
private
:
void
KillProcess
(
)
{
DCHECK
(
process_
)
;
if
(
base
:
:
IsProcessDead
(
process_
)
)
{
process_
=
0
;
return
;
}
if
(
0
=
=
kill
(
process_
SIGKILL
)
)
{
WaitForChildExit
(
)
;
}
else
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
Failed
to
deliver
SIGKILL
to
"
<
<
process_
<
<
"
!
"
<
<
"
(
"
<
<
errno
<
<
"
)
.
"
;
}
process_
=
0
;
}
ChildGrimReaper
(
const
ChildGrimReaper
&
)
=
delete
;
const
ChildGrimReaper
&
operator
=
(
const
ChildGrimReaper
&
)
=
delete
;
}
;
class
ChildLaxReaper
:
public
ChildReaper
public
MessageLoop
:
:
DestructionObserver
{
public
:
explicit
ChildLaxReaper
(
pid_t
process
)
:
ChildReaper
(
process
)
{
}
virtual
~
ChildLaxReaper
(
)
{
DCHECK
(
!
process_
)
;
}
virtual
void
OnSignal
(
int
sig
)
override
{
ChildReaper
:
:
OnSignal
(
sig
)
;
if
(
!
process_
)
{
MessageLoop
:
:
current
(
)
-
>
RemoveDestructionObserver
(
this
)
;
delete
this
;
}
}
virtual
void
WillDestroyCurrentMessageLoop
(
)
override
{
DCHECK
(
process_
)
;
if
(
!
process_
)
{
return
;
}
if
(
!
PR_GetEnv
(
"
MOZ_TEST_CHILD_EXIT_HANG
"
)
)
{
CrashProcessIfHanging
(
)
;
}
if
(
process_
)
{
WaitForChildExit
(
)
;
process_
=
0
;
}
MessageLoop
:
:
current
(
)
-
>
RemoveDestructionObserver
(
this
)
;
delete
this
;
}
private
:
ChildLaxReaper
(
const
ChildLaxReaper
&
)
=
delete
;
void
CrashProcessIfHanging
(
)
{
if
(
base
:
:
IsProcessDead
(
process_
)
)
{
process_
=
0
;
return
;
}
static
int
sWaitMs
=
kShutdownWaitMs
;
if
(
sWaitMs
>
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Process
"
<
<
process_
<
<
"
may
be
hanging
at
shutdown
;
will
wait
for
up
to
"
<
<
sWaitMs
<
<
"
ms
"
;
}
while
(
sWaitMs
>
0
)
{
static
constexpr
int
kWaitTickMs
=
200
;
struct
timespec
ts
=
{
kWaitTickMs
/
1000
(
kWaitTickMs
%
1000
)
*
1000000
}
;
HANDLE_EINTR
(
nanosleep
(
&
ts
&
ts
)
)
;
sWaitMs
-
=
kWaitTickMs
;
if
(
base
:
:
IsProcessDead
(
process_
)
)
{
process_
=
0
;
return
;
}
}
CHROMIUM_LOG
(
ERROR
)
<
<
"
Process
"
<
<
process_
<
<
"
hanging
at
shutdown
;
attempting
crash
report
(
fatal
error
)
.
"
;
kill
(
process_
SIGABRT
)
;
}
const
ChildLaxReaper
&
operator
=
(
const
ChildLaxReaper
&
)
=
delete
;
}
;
}
void
ProcessWatcher
:
:
EnsureProcessTerminated
(
base
:
:
ProcessHandle
process
bool
force
)
{
DCHECK
(
process
!
=
base
:
:
GetCurrentProcId
(
)
)
;
DCHECK
(
process
>
0
)
;
if
(
base
:
:
IsProcessDead
(
process
)
)
return
;
MessageLoopForIO
*
loop
=
MessageLoopForIO
:
:
current
(
)
;
if
(
force
)
{
RefPtr
<
ChildGrimReaper
>
reaper
=
new
ChildGrimReaper
(
process
)
;
loop
-
>
CatchSignal
(
SIGCHLD
reaper
reaper
)
;
loop
-
>
PostDelayedTask
(
reaper
.
forget
(
)
kMaxWaitMs
)
;
}
else
{
ChildLaxReaper
*
reaper
=
new
ChildLaxReaper
(
process
)
;
loop
-
>
CatchSignal
(
SIGCHLD
reaper
reaper
)
;
loop
-
>
AddDestructionObserver
(
reaper
)
;
}
}
