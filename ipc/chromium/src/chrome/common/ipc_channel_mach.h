#
ifndef
CHROME_COMMON_IPC_CHANNEL_MACH_H_
#
define
CHROME_COMMON_IPC_CHANNEL_MACH_H_
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
EventTargetAndLockCapability
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsISupports
.
h
"
namespace
IPC
{
class
ChannelMach
final
:
public
Channel
public
MessageLoopForIO
:
:
MachPortWatcher
{
public
:
ChannelMach
(
mozilla
:
:
UniqueMachReceiveRight
receive
mozilla
:
:
UniqueMachSendRight
send
Mode
mode
base
:
:
ProcessId
other_pid
)
;
bool
Connect
(
Listener
*
listener
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
override
;
void
Close
(
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
override
;
bool
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
override
;
void
SetOtherPid
(
base
:
:
ProcessId
other_pid
)
override
;
void
SetOtherMachTask
(
task_t
)
override
{
}
void
StartAcceptingMachPorts
(
Mode
)
override
{
}
static
bool
CreateRawPipe
(
ChannelHandle
*
server
ChannelHandle
*
client
)
;
static
bool
CreateRawPipe
(
mozilla
:
:
UniqueMachReceiveRight
*
server
mozilla
:
:
UniqueMachSendRight
*
client
)
;
private
:
~
ChannelMach
(
)
{
Close
(
)
;
}
bool
EnqueueHelloMessage
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
bool
ContinueConnect
(
mozilla
:
:
UniqueMachSendRight
send_port
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
void
CloseLocked
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
bool
ProcessIncomingMessage
(
)
MOZ_REQUIRES
(
IOThread
(
)
)
;
bool
ProcessOutgoingMessages
(
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
virtual
void
OnMachMessageReceived
(
mach_port_t
port
)
override
;
void
OutputQueuePush
(
mozilla
:
:
UniquePtr
<
Message
>
msg
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
void
OutputQueuePop
(
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
MessageLoopForIO
:
:
MachPortWatchController
watch_controller_
;
mozilla
:
:
UniqueMachReceiveRight
receive_port_
MOZ_GUARDED_BY
(
chan_cap_
)
;
mozilla
:
:
UniqueMachSendRight
send_port_
MOZ_GUARDED_BY
(
chan_cap_
)
;
Listener
*
listener_
MOZ_GUARDED_BY
(
IOThread
(
)
)
=
nullptr
;
mozilla
:
:
UniquePtr
<
char
[
]
>
send_buffer_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
receive_buffer_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
mozilla
:
:
Queue
<
mozilla
:
:
UniquePtr
<
Message
>
64
>
output_queue_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
bool
send_buffer_has_message_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
=
false
;
bool
waiting_connect_
MOZ_GUARDED_BY
(
chan_cap_
)
=
true
;
base
:
:
ProcessId
other_pid_
MOZ_GUARDED_BY
(
chan_cap_
)
=
base
:
:
kInvalidProcessId
;
mozilla
:
:
Maybe
<
audit_token_t
>
peer_audit_token_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
}
;
}
#
endif
