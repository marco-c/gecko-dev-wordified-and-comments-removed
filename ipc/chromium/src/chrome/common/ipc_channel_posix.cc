#
include
"
chrome
/
common
/
ipc_channel_posix
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
limits
.
h
>
#
include
"
mozilla
/
Mutex
.
h
"
#
if
defined
(
OS_MACOSX
)
#
include
<
mach
/
message
.
h
>
#
include
<
mach
/
port
.
h
>
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
chrome
/
common
/
mach_ipc_mac
.
h
"
#
endif
#
if
defined
(
OS_MACOSX
)
|
|
defined
(
OS_NETBSD
)
#
include
<
sched
.
h
>
#
endif
#
include
<
stddef
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
socket
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
sys
/
un
.
h
>
#
include
<
sys
/
uio
.
h
>
#
include
<
string
>
#
include
<
map
>
#
include
"
base
/
command_line
.
h
"
#
include
"
base
/
eintr_wrapper
.
h
"
#
include
"
base
/
logging
.
h
"
#
include
"
base
/
process_util
.
h
"
#
include
"
base
/
string_util
.
h
"
#
include
"
chrome
/
common
/
chrome_switches
.
h
"
#
include
"
chrome
/
common
/
ipc_channel_utils
.
h
"
#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
ifdef
FUZZING
#
include
"
mozilla
/
ipc
/
Faulty
.
h
"
#
endif
#
if
defined
(
IOV_MAX
)
static
const
size_t
kMaxIOVecSize
=
IOV_MAX
;
#
elif
defined
(
ANDROID
)
static
const
size_t
kMaxIOVecSize
=
256
;
#
else
static
const
size_t
kMaxIOVecSize
=
16
;
#
endif
using
namespace
mozilla
:
:
ipc
;
namespace
IPC
{
namespace
{
static
int
gClientChannelFd
=
#
if
defined
(
MOZ_WIDGET_ANDROID
)
-
1
#
else
3
#
endif
;
bool
ErrorIsBrokenPipe
(
int
err
)
{
return
err
=
=
EPIPE
|
|
err
=
=
ECONNRESET
;
}
static
inline
ssize_t
corrected_sendmsg
(
int
socket
const
struct
msghdr
*
message
int
flags
)
{
#
if
defined
(
ANDROID
)
&
&
\
(
defined
(
__aarch64__
)
|
|
(
defined
(
DEBUG
)
&
&
defined
(
__x86_64__
)
)
)
static
constexpr
auto
kBadValue
=
static_cast
<
ssize_t
>
(
0xFFFFFFFF
)
;
static_assert
(
kBadValue
>
0
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
errno
=
0
;
#
endif
ssize_t
bytes_written
=
sendmsg
(
socket
message
flags
)
;
if
(
bytes_written
=
=
kBadValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
errno
!
=
0
)
;
bytes_written
=
-
1
;
}
MOZ_DIAGNOSTIC_ASSERT
(
bytes_written
<
kBadValue
)
;
return
bytes_written
;
#
else
return
sendmsg
(
socket
message
flags
)
;
#
endif
}
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
Channel
:
:
SetClientChannelFd
(
int
fd
)
{
gClientChannelFd
=
fd
;
}
#
endif
Channel
:
:
ChannelImpl
:
:
ChannelImpl
(
const
ChannelId
&
channel_id
Mode
mode
Listener
*
listener
)
:
chan_cap_
(
"
ChannelImpl
:
:
SendMutex
"
MessageLoopForIO
:
:
current
(
)
-
>
SerialEventTarget
(
)
)
{
Init
(
mode
listener
)
;
if
(
!
CreatePipe
(
mode
)
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Unable
to
create
pipe
in
"
<
<
(
mode
=
=
MODE_SERVER
?
"
server
"
:
"
client
"
)
<
<
"
mode
error
(
"
<
<
strerror
(
errno
)
<
<
"
)
.
"
;
return
;
}
EnqueueHelloMessage
(
)
;
}
Channel
:
:
ChannelImpl
:
:
ChannelImpl
(
ChannelHandle
pipe
Mode
mode
Listener
*
listener
)
:
chan_cap_
(
"
ChannelImpl
:
:
SendMutex
"
MessageLoopForIO
:
:
current
(
)
-
>
SerialEventTarget
(
)
)
{
Init
(
mode
listener
)
;
SetPipe
(
pipe
.
release
(
)
)
;
EnqueueHelloMessage
(
)
;
}
void
Channel
:
:
ChannelImpl
:
:
SetPipe
(
int
fd
)
{
chan_cap_
.
NoteExclusiveAccess
(
)
;
pipe_
=
fd
;
pipe_buf_len_
=
0
;
if
(
fd
>
=
0
)
{
int
buf_len
;
socklen_t
optlen
=
sizeof
(
buf_len
)
;
if
(
getsockopt
(
fd
SOL_SOCKET
SO_SNDBUF
&
buf_len
&
optlen
)
!
=
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Unable
to
determine
pipe
buffer
size
:
"
<
<
strerror
(
errno
)
;
return
;
}
CHECK
(
optlen
=
=
sizeof
(
buf_len
)
)
;
CHECK
(
buf_len
>
0
)
;
pipe_buf_len_
=
static_cast
<
unsigned
>
(
buf_len
)
;
}
}
bool
Channel
:
:
ChannelImpl
:
:
PipeBufHasSpaceAfter
(
size_t
already_written
)
{
return
pipe_buf_len_
=
=
0
|
|
static_cast
<
size_t
>
(
pipe_buf_len_
)
>
already_written
;
}
void
Channel
:
:
ChannelImpl
:
:
Init
(
Mode
mode
Listener
*
listener
)
{
static_assert
(
sizeof
(
*
this
)
<
=
512
"
Exceeded
expected
size
class
"
)
;
MOZ_RELEASE_ASSERT
(
kControlBufferHeaderSize
>
=
CMSG_SPACE
(
0
)
)
;
MOZ_RELEASE_ASSERT
(
kControlBufferSize
>
=
CMSG_SPACE
(
sizeof
(
int
)
*
kControlBufferMaxFds
)
)
;
chan_cap_
.
NoteExclusiveAccess
(
)
;
mode_
=
mode
;
is_blocked_on_write_
=
false
;
partial_write_
.
reset
(
)
;
input_buf_offset_
=
0
;
input_buf_
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
Channel
:
:
kReadBufferSize
)
;
input_cmsg_buf_
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
kControlBufferSize
)
;
SetPipe
(
-
1
)
;
client_pipe_
=
-
1
;
listener_
=
listener
;
waiting_connect_
=
true
;
#
if
defined
(
OS_MACOSX
)
last_pending_fd_id_
=
0
;
other_task_
=
nullptr
;
#
endif
}
bool
Channel
:
:
ChannelImpl
:
:
CreatePipe
(
Mode
mode
)
{
chan_cap_
.
NoteExclusiveAccess
(
)
;
DCHECK
(
pipe_
=
=
-
1
)
;
if
(
mode
=
=
MODE_SERVER
)
{
ChannelHandle
server
client
;
if
(
!
Channel
:
:
CreateRawPipe
(
&
server
&
client
)
)
{
return
false
;
}
SetPipe
(
server
.
release
(
)
)
;
client_pipe_
=
client
.
release
(
)
;
}
else
{
static
mozilla
:
:
Atomic
<
bool
>
consumed
(
false
)
;
CHECK
(
!
consumed
.
exchange
(
true
)
)
<
<
"
child
process
main
channel
can
be
created
only
once
"
;
SetPipe
(
gClientChannelFd
)
;
}
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
EnqueueHelloMessage
(
)
{
mozilla
:
:
UniquePtr
<
Message
>
msg
(
new
Message
(
MSG_ROUTING_NONE
HELLO_MESSAGE_TYPE
)
)
;
if
(
!
msg
-
>
WriteInt
(
base
:
:
GetCurrentProcId
(
)
)
)
{
CloseLocked
(
)
;
return
false
;
}
OutputQueuePush
(
std
:
:
move
(
msg
)
)
;
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
Connect
(
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
return
ConnectLocked
(
)
;
}
bool
Channel
:
:
ChannelImpl
:
:
ConnectLocked
(
)
{
chan_cap_
.
NoteExclusiveAccess
(
)
;
if
(
pipe_
=
=
-
1
)
{
return
false
;
}
#
if
defined
(
OS_MACOSX
)
if
(
accept_mach_ports_
&
&
privileged_
&
&
!
other_task_
)
{
MOZ_ASSERT
(
waiting_connect_
)
;
return
true
;
}
#
endif
MessageLoopForIO
:
:
current
(
)
-
>
WatchFileDescriptor
(
pipe_
true
MessageLoopForIO
:
:
WATCH_READ
&
read_watcher_
this
)
;
waiting_connect_
=
false
;
return
ProcessOutgoingMessages
(
)
;
}
bool
Channel
:
:
ChannelImpl
:
:
ProcessIncomingMessages
(
)
{
chan_cap_
.
NoteOnIOThread
(
)
;
struct
msghdr
msg
=
{
0
}
;
struct
iovec
iov
;
msg
.
msg_iov
=
&
iov
;
msg
.
msg_iovlen
=
1
;
msg
.
msg_control
=
input_cmsg_buf_
.
get
(
)
;
for
(
;
;
)
{
msg
.
msg_controllen
=
kControlBufferSize
;
if
(
pipe_
=
=
-
1
)
return
false
;
iov
.
iov_base
=
input_buf_
.
get
(
)
+
input_buf_offset_
;
iov
.
iov_len
=
Channel
:
:
kReadBufferSize
-
input_buf_offset_
;
ssize_t
bytes_read
=
HANDLE_EINTR
(
recvmsg
(
pipe_
&
msg
MSG_DONTWAIT
)
)
;
if
(
bytes_read
<
0
)
{
if
(
errno
=
=
EAGAIN
)
{
return
true
;
}
else
{
if
(
!
ErrorIsBrokenPipe
(
errno
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
pipe
error
(
fd
"
<
<
pipe_
<
<
"
)
:
"
<
<
strerror
(
errno
)
;
}
return
false
;
}
}
else
if
(
bytes_read
=
=
0
)
{
Close
(
)
;
return
false
;
}
DCHECK
(
bytes_read
)
;
const
int
*
wire_fds
=
NULL
;
unsigned
num_wire_fds
=
0
;
if
(
msg
.
msg_controllen
>
0
)
{
for
(
struct
cmsghdr
*
cmsg
=
CMSG_FIRSTHDR
(
&
msg
)
;
cmsg
;
cmsg
=
CMSG_NXTHDR
(
&
msg
cmsg
)
)
{
if
(
cmsg
-
>
cmsg_level
=
=
SOL_SOCKET
&
&
cmsg
-
>
cmsg_type
=
=
SCM_RIGHTS
)
{
const
unsigned
payload_len
=
cmsg
-
>
cmsg_len
-
CMSG_LEN
(
0
)
;
DCHECK
(
payload_len
%
sizeof
(
int
)
=
=
0
)
;
wire_fds
=
reinterpret_cast
<
int
*
>
(
CMSG_DATA
(
cmsg
)
)
;
num_wire_fds
=
payload_len
/
4
;
if
(
msg
.
msg_flags
&
MSG_CTRUNC
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
SCM_RIGHTS
message
was
truncated
"
<
<
"
cmsg_len
:
"
<
<
cmsg
-
>
cmsg_len
<
<
"
fd
:
"
<
<
pipe_
;
for
(
unsigned
i
=
0
;
i
<
num_wire_fds
;
+
+
i
)
IGNORE_EINTR
(
close
(
wire_fds
[
i
]
)
)
;
return
false
;
}
break
;
}
}
}
const
char
*
p
=
input_buf_
.
get
(
)
;
const
char
*
end
=
input_buf_
.
get
(
)
+
input_buf_offset_
+
bytes_read
;
const
int
*
fds
;
unsigned
num_fds
;
unsigned
fds_i
=
0
;
if
(
input_overflow_fds_
.
empty
(
)
)
{
fds
=
wire_fds
;
num_fds
=
num_wire_fds
;
}
else
{
if
(
num_wire_fds
>
0
)
{
const
size_t
prev_size
=
input_overflow_fds_
.
size
(
)
;
input_overflow_fds_
.
resize
(
prev_size
+
num_wire_fds
)
;
memcpy
(
&
input_overflow_fds_
[
prev_size
]
wire_fds
num_wire_fds
*
sizeof
(
int
)
)
;
}
fds
=
&
input_overflow_fds_
[
0
]
;
num_fds
=
input_overflow_fds_
.
size
(
)
;
}
while
(
p
<
end
&
&
pipe_
!
=
-
1
)
{
uint32_t
message_length
=
0
;
if
(
incoming_message_
)
{
message_length
=
incoming_message_
-
>
size
(
)
;
}
else
{
message_length
=
Message
:
:
MessageSize
(
p
end
)
;
}
if
(
!
message_length
)
{
MOZ_ASSERT
(
!
incoming_message_
)
;
memmove
(
input_buf_
.
get
(
)
p
end
-
p
)
;
input_buf_offset_
=
end
-
p
;
break
;
}
input_buf_offset_
=
0
;
bool
partial
;
if
(
incoming_message_
)
{
Message
&
m
=
*
incoming_message_
;
MOZ_DIAGNOSTIC_ASSERT
(
message_length
>
m
.
CurrentSize
(
)
)
;
uint32_t
remaining
=
message_length
-
m
.
CurrentSize
(
)
;
uint32_t
in_buf
=
std
:
:
min
(
remaining
uint32_t
(
end
-
p
)
)
;
m
.
InputBytes
(
p
in_buf
)
;
p
+
=
in_buf
;
partial
=
in_buf
!
=
remaining
;
}
else
{
uint32_t
in_buf
=
std
:
:
min
(
message_length
uint32_t
(
end
-
p
)
)
;
incoming_message_
=
mozilla
:
:
MakeUnique
<
Message
>
(
p
in_buf
)
;
p
+
=
in_buf
;
partial
=
in_buf
!
=
message_length
;
}
if
(
partial
)
{
break
;
}
Message
&
m
=
*
incoming_message_
;
if
(
m
.
header
(
)
-
>
num_handles
)
{
const
char
*
error
=
NULL
;
if
(
m
.
header
(
)
-
>
num_handles
>
num_fds
-
fds_i
)
{
error
=
"
Message
needs
unreceived
descriptors
"
;
}
if
(
m
.
header
(
)
-
>
num_handles
>
IPC
:
:
Message
:
:
MAX_DESCRIPTORS_PER_MESSAGE
)
{
error
=
"
Message
requires
an
excessive
number
of
descriptors
"
;
}
if
(
error
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
error
<
<
"
channel
:
"
<
<
this
<
<
"
message
-
type
:
"
<
<
m
.
type
(
)
<
<
"
header
(
)
-
>
num_handles
:
"
<
<
m
.
header
(
)
-
>
num_handles
<
<
"
num_fds
:
"
<
<
num_fds
<
<
"
fds_i
:
"
<
<
fds_i
;
for
(
unsigned
i
=
fds_i
;
i
<
num_fds
;
+
+
i
)
IGNORE_EINTR
(
close
(
fds
[
i
]
)
)
;
input_overflow_fds_
.
clear
(
)
;
return
false
;
}
#
if
defined
(
OS_MACOSX
)
auto
fdAck
=
mozilla
:
:
MakeUnique
<
Message
>
(
MSG_ROUTING_NONE
RECEIVED_FDS_MESSAGE_TYPE
)
;
DCHECK
(
m
.
fd_cookie
(
)
!
=
0
)
;
fdAck
-
>
set_fd_cookie
(
m
.
fd_cookie
(
)
)
;
{
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
OutputQueuePush
(
std
:
:
move
(
fdAck
)
)
;
}
#
endif
nsTArray
<
mozilla
:
:
UniqueFileHandle
>
handles
(
m
.
header
(
)
-
>
num_handles
)
;
for
(
unsigned
end_i
=
fds_i
+
m
.
header
(
)
-
>
num_handles
;
fds_i
<
end_i
;
+
+
fds_i
)
{
handles
.
AppendElement
(
mozilla
:
:
UniqueFileHandle
(
fds
[
fds_i
]
)
)
;
}
m
.
SetAttachedFileHandles
(
std
:
:
move
(
handles
)
)
;
}
AddIPCProfilerMarker
(
m
other_pid_
MessageDirection
:
:
eReceiving
MessagePhase
:
:
TransferEnd
)
;
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
received
message
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
m
.
type
(
)
;
#
endif
if
(
m
.
routing_id
(
)
=
=
MSG_ROUTING_NONE
&
&
m
.
type
(
)
=
=
HELLO_MESSAGE_TYPE
)
{
int32_t
other_pid
=
MessageIterator
(
m
)
.
NextInt
(
)
;
SetOtherPid
(
other_pid
)
;
listener_
-
>
OnChannelConnected
(
other_pid
)
;
#
if
defined
(
OS_MACOSX
)
}
else
if
(
m
.
routing_id
(
)
=
=
MSG_ROUTING_NONE
&
&
m
.
type
(
)
=
=
RECEIVED_FDS_MESSAGE_TYPE
)
{
DCHECK
(
m
.
fd_cookie
(
)
!
=
0
)
;
CloseDescriptors
(
m
.
fd_cookie
(
)
)
;
#
endif
}
else
{
mozilla
:
:
LogIPCMessage
:
:
Run
run
(
&
m
)
;
#
if
defined
(
OS_MACOSX
)
if
(
!
AcceptMachPorts
(
m
)
)
{
return
false
;
}
#
endif
listener_
-
>
OnMessageReceived
(
std
:
:
move
(
incoming_message_
)
)
;
}
incoming_message_
=
nullptr
;
}
input_overflow_fds_
=
std
:
:
vector
<
int
>
(
&
fds
[
fds_i
]
&
fds
[
num_fds
]
)
;
if
(
!
incoming_message_
&
&
input_buf_offset_
=
=
0
&
&
!
input_overflow_fds_
.
empty
(
)
)
{
return
false
;
}
}
}
bool
Channel
:
:
ChannelImpl
:
:
ProcessOutgoingMessages
(
)
{
chan_cap_
.
NoteSendMutex
(
)
;
DCHECK
(
!
waiting_connect_
)
;
is_blocked_on_write_
=
false
;
if
(
output_queue_
.
IsEmpty
(
)
)
return
true
;
if
(
pipe_
=
=
-
1
)
return
false
;
while
(
!
output_queue_
.
IsEmpty
(
)
)
{
#
ifdef
FUZZING
mozilla
:
:
ipc
:
:
Faulty
:
:
instance
(
)
.
MaybeCollectAndClosePipe
(
pipe_
)
;
#
endif
Message
*
msg
=
output_queue_
.
FirstElement
(
)
.
get
(
)
;
struct
msghdr
msgh
=
{
0
}
;
char
cmsgBuf
[
kControlBufferSize
]
;
if
(
partial_write_
.
isNothing
(
)
)
{
#
if
defined
(
OS_MACOSX
)
if
(
!
TransferMachPorts
(
*
msg
)
)
{
return
false
;
}
#
endif
if
(
msg
-
>
attached_handles_
.
Length
(
)
>
IPC
:
:
Message
:
:
MAX_DESCRIPTORS_PER_MESSAGE
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Too
many
file
descriptors
!
"
)
;
CHROMIUM_LOG
(
FATAL
)
<
<
"
Too
many
file
descriptors
!
"
;
return
false
;
}
msg
-
>
header
(
)
-
>
num_handles
=
msg
-
>
attached_handles_
.
Length
(
)
;
#
if
defined
(
OS_MACOSX
)
if
(
!
msg
-
>
attached_handles_
.
IsEmpty
(
)
)
{
msg
-
>
set_fd_cookie
(
+
+
last_pending_fd_id_
)
;
}
#
endif
Pickle
:
:
BufferList
:
:
IterImpl
iter
(
msg
-
>
Buffers
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
iter
.
Done
(
)
"
empty
message
"
)
;
partial_write_
.
emplace
(
PartialWrite
{
iter
msg
-
>
attached_handles_
}
)
;
AddIPCProfilerMarker
(
*
msg
other_pid_
MessageDirection
:
:
eSending
MessagePhase
:
:
TransferStart
)
;
}
if
(
partial_write_
-
>
iter_
.
Done
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
partial_write_
-
>
iter_
should
not
be
done
"
)
;
return
false
;
}
Pickle
:
:
BufferList
:
:
IterImpl
iter
=
partial_write_
-
>
iter_
;
auto
handles
=
partial_write_
-
>
handles_
;
const
size_t
num_fds
=
std
:
:
min
(
handles
.
Length
(
)
kControlBufferMaxFds
)
;
size_t
max_amt_to_write
=
iter
.
TotalBytesAvailable
(
msg
-
>
Buffers
(
)
)
;
if
(
num_fds
>
0
)
{
msgh
.
msg_control
=
cmsgBuf
;
msgh
.
msg_controllen
=
CMSG_LEN
(
sizeof
(
int
)
*
num_fds
)
;
struct
cmsghdr
*
cmsg
=
CMSG_FIRSTHDR
(
&
msgh
)
;
cmsg
-
>
cmsg_level
=
SOL_SOCKET
;
cmsg
-
>
cmsg_type
=
SCM_RIGHTS
;
cmsg
-
>
cmsg_len
=
msgh
.
msg_controllen
;
for
(
size_t
i
=
0
;
i
<
num_fds
;
+
+
i
)
{
reinterpret_cast
<
int
*
>
(
CMSG_DATA
(
cmsg
)
)
[
i
]
=
handles
[
i
]
.
get
(
)
;
}
size_t
remaining
=
handles
.
Length
(
)
-
num_fds
;
MOZ_ASSERT
(
max_amt_to_write
>
remaining
"
must
be
at
least
one
byte
in
the
message
for
each
handle
"
)
;
max_amt_to_write
-
=
remaining
;
}
struct
iovec
iov
[
kMaxIOVecSize
]
;
size_t
iov_count
=
0
;
size_t
amt_to_write
=
0
;
while
(
!
iter
.
Done
(
)
&
&
iov_count
<
kMaxIOVecSize
&
&
PipeBufHasSpaceAfter
(
amt_to_write
)
&
&
amt_to_write
<
max_amt_to_write
)
{
char
*
data
=
iter
.
Data
(
)
;
size_t
size
=
std
:
:
min
(
iter
.
RemainingInSegment
(
)
max_amt_to_write
-
amt_to_write
)
;
iov
[
iov_count
]
.
iov_base
=
data
;
iov
[
iov_count
]
.
iov_len
=
size
;
iov_count
+
+
;
amt_to_write
+
=
size
;
iter
.
Advance
(
msg
-
>
Buffers
(
)
size
)
;
}
MOZ_ASSERT
(
amt_to_write
<
=
max_amt_to_write
)
;
MOZ_ASSERT
(
amt_to_write
>
0
)
;
const
bool
intentional_short_write
=
!
iter
.
Done
(
)
;
msgh
.
msg_iov
=
iov
;
msgh
.
msg_iovlen
=
iov_count
;
ssize_t
bytes_written
=
HANDLE_EINTR
(
corrected_sendmsg
(
pipe_
&
msgh
MSG_DONTWAIT
)
)
;
if
(
bytes_written
<
0
)
{
switch
(
errno
)
{
case
EAGAIN
:
break
;
#
if
defined
(
OS_MACOSX
)
|
|
defined
(
OS_NETBSD
)
case
EMSGSIZE
:
if
(
IOThread
(
)
.
IsOnCurrentThread
(
)
)
{
sched_yield
(
)
;
}
break
;
#
endif
default
:
if
(
!
ErrorIsBrokenPipe
(
errno
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
pipe
error
:
"
<
<
strerror
(
errno
)
;
}
return
false
;
}
}
if
(
intentional_short_write
|
|
static_cast
<
size_t
>
(
bytes_written
)
!
=
amt_to_write
)
{
if
(
bytes_written
>
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
intentional_short_write
|
|
static_cast
<
size_t
>
(
bytes_written
)
<
amt_to_write
)
;
partial_write_
-
>
iter_
.
AdvanceAcrossSegments
(
msg
-
>
Buffers
(
)
bytes_written
)
;
partial_write_
-
>
handles_
=
handles
.
From
(
num_fds
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
partial_write_
-
>
iter_
.
Done
(
)
)
;
}
is_blocked_on_write_
=
true
;
if
(
IOThread
(
)
.
IsOnCurrentThread
(
)
)
{
MessageLoopForIO
:
:
current
(
)
-
>
WatchFileDescriptor
(
pipe_
false
MessageLoopForIO
:
:
WATCH_WRITE
&
write_watcher_
this
)
;
}
else
{
IOThread
(
)
.
Dispatch
(
mozilla
:
:
NewRunnableMethod
<
int
>
(
"
ChannelImpl
:
:
ContinueProcessOutgoing
"
this
&
ChannelImpl
:
:
OnFileCanWriteWithoutBlocking
-
1
)
)
;
}
return
true
;
}
else
{
MOZ_ASSERT
(
partial_write_
-
>
handles_
.
Length
(
)
=
=
num_fds
"
not
all
handles
were
sent
"
)
;
partial_write_
.
reset
(
)
;
#
if
defined
(
OS_MACOSX
)
if
(
!
msg
-
>
attached_handles_
.
IsEmpty
(
)
)
{
pending_fds_
.
push_back
(
PendingDescriptors
{
msg
-
>
fd_cookie
(
)
std
:
:
move
(
msg
-
>
attached_handles_
)
}
)
;
}
#
else
if
(
bytes_written
>
0
)
{
msg
-
>
attached_handles_
.
Clear
(
)
;
}
#
endif
AddIPCProfilerMarker
(
*
msg
other_pid_
MessageDirection
:
:
eSending
MessagePhase
:
:
TransferEnd
)
;
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
sent
message
"
<
<
msg
<
<
"
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
msg
-
>
type
(
)
;
#
endif
OutputQueuePop
(
)
;
msg
=
nullptr
;
}
}
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
{
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteSendMutex
(
)
;
#
ifdef
IPC_MESSAGE_DEBUG_EXTRA
DLOG
(
INFO
)
<
<
"
sending
message
"
<
<
message
.
get
(
)
<
<
"
on
channel
"
<
<
this
<
<
"
with
type
"
<
<
message
-
>
type
(
)
<
<
"
(
"
<
<
output_queue_
.
Count
(
)
<
<
"
in
queue
)
"
;
#
endif
#
ifdef
FUZZING
message
=
mozilla
:
:
ipc
:
:
Faulty
:
:
instance
(
)
.
MutateIPCMessage
(
"
Channel
:
:
ChannelImpl
:
:
Send
"
std
:
:
move
(
message
)
)
;
#
endif
if
(
pipe_
=
=
-
1
)
{
if
(
mozilla
:
:
ipc
:
:
LoggingEnabled
(
)
)
{
fprintf
(
stderr
"
Can
'
t
send
message
%
s
because
this
channel
is
closed
.
\
n
"
message
-
>
name
(
)
)
;
}
return
false
;
}
OutputQueuePush
(
std
:
:
move
(
message
)
)
;
if
(
!
waiting_connect_
)
{
if
(
!
is_blocked_on_write_
)
{
if
(
!
ProcessOutgoingMessages
(
)
)
return
false
;
}
}
return
true
;
}
void
Channel
:
:
ChannelImpl
:
:
GetClientFileDescriptorMapping
(
int
*
src_fd
int
*
dest_fd
)
const
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
DCHECK
(
mode_
=
=
MODE_SERVER
)
;
*
src_fd
=
client_pipe_
;
*
dest_fd
=
gClientChannelFd
;
}
void
Channel
:
:
ChannelImpl
:
:
CloseClientFileDescriptor
(
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
if
(
client_pipe_
!
=
-
1
)
{
IGNORE_EINTR
(
close
(
client_pipe_
)
)
;
client_pipe_
=
-
1
;
}
}
void
Channel
:
:
ChannelImpl
:
:
OnFileCanReadWithoutBlocking
(
int
fd
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
chan_cap_
.
NoteOnIOThread
(
)
;
if
(
!
waiting_connect_
&
&
fd
=
=
pipe_
&
&
pipe_
!
=
-
1
)
{
if
(
!
ProcessIncomingMessages
(
)
)
{
Close
(
)
;
listener_
-
>
OnChannelError
(
)
;
return
;
}
}
}
#
if
defined
(
OS_MACOSX
)
void
Channel
:
:
ChannelImpl
:
:
CloseDescriptors
(
uint32_t
pending_fd_id
)
{
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteExclusiveAccess
(
)
;
DCHECK
(
pending_fd_id
!
=
0
)
;
for
(
std
:
:
list
<
PendingDescriptors
>
:
:
iterator
i
=
pending_fds_
.
begin
(
)
;
i
!
=
pending_fds_
.
end
(
)
;
i
+
+
)
{
if
(
(
*
i
)
.
id
=
=
pending_fd_id
)
{
pending_fds_
.
erase
(
i
)
;
return
;
}
}
DCHECK
(
false
)
<
<
"
pending_fd_id
not
in
our
list
!
"
;
}
#
endif
void
Channel
:
:
ChannelImpl
:
:
OutputQueuePush
(
mozilla
:
:
UniquePtr
<
Message
>
msg
)
{
chan_cap_
.
NoteSendMutex
(
)
;
mozilla
:
:
LogIPCMessage
:
:
LogDispatchWithPid
(
msg
.
get
(
)
other_pid_
)
;
MOZ_DIAGNOSTIC_ASSERT
(
pipe_
!
=
-
1
)
;
msg
-
>
AssertAsLargeAsHeader
(
)
;
output_queue_
.
Push
(
std
:
:
move
(
msg
)
)
;
}
void
Channel
:
:
ChannelImpl
:
:
OutputQueuePop
(
)
{
partial_write_
.
reset
(
)
;
mozilla
:
:
UniquePtr
<
Message
>
message
=
output_queue_
.
Pop
(
)
;
}
void
Channel
:
:
ChannelImpl
:
:
OnFileCanWriteWithoutBlocking
(
int
fd
)
{
RefPtr
<
ChannelImpl
>
grip
(
this
)
;
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
mozilla
:
:
ReleasableMutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteExclusiveAccess
(
)
;
if
(
pipe_
!
=
-
1
&
&
!
ProcessOutgoingMessages
(
)
)
{
CloseLocked
(
)
;
lock
.
Unlock
(
)
;
listener_
-
>
OnChannelError
(
)
;
}
}
void
Channel
:
:
ChannelImpl
:
:
Close
(
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
CloseLocked
(
)
;
}
void
Channel
:
:
ChannelImpl
:
:
CloseLocked
(
)
{
chan_cap_
.
NoteExclusiveAccess
(
)
;
read_watcher_
.
StopWatchingFileDescriptor
(
)
;
write_watcher_
.
StopWatchingFileDescriptor
(
)
;
if
(
pipe_
!
=
-
1
)
{
IGNORE_EINTR
(
close
(
pipe_
)
)
;
SetPipe
(
-
1
)
;
}
if
(
client_pipe_
!
=
-
1
)
{
IGNORE_EINTR
(
close
(
client_pipe_
)
)
;
client_pipe_
=
-
1
;
}
while
(
!
output_queue_
.
IsEmpty
(
)
)
{
OutputQueuePop
(
)
;
}
for
(
std
:
:
vector
<
int
>
:
:
iterator
i
=
input_overflow_fds_
.
begin
(
)
;
i
!
=
input_overflow_fds_
.
end
(
)
;
+
+
i
)
{
IGNORE_EINTR
(
close
(
*
i
)
)
;
}
input_overflow_fds_
.
clear
(
)
;
#
if
defined
(
OS_MACOSX
)
pending_fds_
.
clear
(
)
;
other_task_
=
nullptr
;
#
endif
}
#
if
defined
(
OS_MACOSX
)
void
Channel
:
:
ChannelImpl
:
:
SetOtherMachTask
(
task_t
task
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteExclusiveAccess
(
)
;
if
(
NS_WARN_IF
(
pipe_
=
=
-
1
)
)
{
return
;
}
MOZ_ASSERT
(
accept_mach_ports_
&
&
privileged_
&
&
waiting_connect_
)
;
other_task_
=
mozilla
:
:
RetainMachSendRight
(
task
)
;
ConnectLocked
(
)
;
}
void
Channel
:
:
ChannelImpl
:
:
StartAcceptingMachPorts
(
Mode
mode
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteExclusiveAccess
(
)
;
if
(
accept_mach_ports_
)
{
MOZ_ASSERT
(
privileged_
=
=
(
MODE_SERVER
=
=
mode
)
)
;
return
;
}
accept_mach_ports_
=
true
;
privileged_
=
MODE_SERVER
=
=
mode
;
}
static
mozilla
:
:
UniqueMachSendRight
BrokerExtractSendRight
(
task_t
task
mach_port_name_t
name
)
{
mach_port_t
extractedRight
=
MACH_PORT_NULL
;
mach_msg_type_name_t
extractedRightType
;
kern_return_t
kr
=
mach_port_extract_right
(
task
name
MACH_MSG_TYPE_MOVE_SEND
&
extractedRight
&
extractedRightType
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
failed
to
extract
port
right
from
other
process
.
"
<
<
mach_error_string
(
kr
)
;
return
nullptr
;
}
MOZ_ASSERT
(
extractedRightType
=
=
MACH_MSG_TYPE_PORT_SEND
"
We
asked
the
OS
for
a
send
port
"
)
;
return
mozilla
:
:
UniqueMachSendRight
(
extractedRight
)
;
}
static
mozilla
:
:
Maybe
<
mach_port_name_t
>
BrokerTransferSendRight
(
task_t
task
mozilla
:
:
UniqueMachSendRight
port_to_send
)
{
mach_port_name_t
endpoint
;
kern_return_t
kr
=
mach_port_allocate
(
task
MACH_PORT_RIGHT_RECEIVE
&
endpoint
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
Unable
to
create
receive
right
in
TransferMachPorts
.
"
<
<
mach_error_string
(
kr
)
;
return
mozilla
:
:
Nothing
(
)
;
}
auto
destroyEndpoint
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
mach_port_deallocate
(
task
endpoint
)
;
}
)
;
mach_port_limits
limits
=
{
}
;
limits
.
mpl_qlimit
=
1
;
kr
=
mach_port_set_attributes
(
task
endpoint
MACH_PORT_LIMITS_INFO
reinterpret_cast
<
mach_port_info_t
>
(
&
limits
)
MACH_PORT_LIMITS_INFO_COUNT
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
Unable
configure
receive
right
in
TransferMachPorts
.
"
<
<
mach_error_string
(
kr
)
;
return
mozilla
:
:
Nothing
(
)
;
}
mach_port_t
send_once_right
;
mach_msg_type_name_t
send_right_type
;
kr
=
mach_port_extract_right
(
task
endpoint
MACH_MSG_TYPE_MAKE_SEND_ONCE
&
send_once_right
&
send_right_type
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
Unable
extract
send
right
in
TransferMachPorts
.
"
<
<
mach_error_string
(
kr
)
;
return
mozilla
:
:
Nothing
(
)
;
}
MOZ_ASSERT
(
MACH_MSG_TYPE_PORT_SEND_ONCE
=
=
send_right_type
)
;
kr
=
MachSendPortSendRight
(
send_once_right
port_to_send
.
get
(
)
mozilla
:
:
Some
(
0
)
MACH_MSG_TYPE_MOVE_SEND_ONCE
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
mach_port_deallocate
(
mach_task_self
(
)
send_once_right
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
Unable
to
transfer
right
in
TransferMachPorts
.
"
<
<
mach_error_string
(
kr
)
;
return
mozilla
:
:
Nothing
(
)
;
}
destroyEndpoint
.
release
(
)
;
return
mozilla
:
:
Some
(
endpoint
)
;
}
bool
Channel
:
:
ChannelImpl
:
:
AcceptMachPorts
(
Message
&
msg
)
{
chan_cap_
.
NoteOnIOThread
(
)
;
uint32_t
num_send_rights
=
msg
.
header
(
)
-
>
num_send_rights
;
if
(
num_send_rights
=
=
0
)
{
return
true
;
}
if
(
!
accept_mach_ports_
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
invalid
message
:
"
<
<
msg
.
name
(
)
<
<
"
.
channel
is
not
configured
to
accept
mach
ports
"
;
return
false
;
}
nsTArray
<
uint32_t
>
payload
;
payload
.
AppendElements
(
num_send_rights
)
;
if
(
!
msg
.
ReadFooter
(
payload
.
Elements
(
)
num_send_rights
*
sizeof
(
uint32_t
)
true
)
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
failed
to
read
mach
port
payload
from
message
"
;
return
false
;
}
msg
.
header
(
)
-
>
num_send_rights
=
0
;
nsTArray
<
mozilla
:
:
UniqueMachSendRight
>
rights
(
num_send_rights
)
;
for
(
uint32_t
name
:
payload
)
{
mozilla
:
:
UniqueMachSendRight
right
;
if
(
privileged_
)
{
if
(
!
other_task_
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
other_task_
is
invalid
in
AcceptMachPorts
"
;
return
false
;
}
right
=
BrokerExtractSendRight
(
other_task_
.
get
(
)
name
)
;
}
else
{
kern_return_t
kr
=
MachReceivePortSendRight
(
mozilla
:
:
UniqueMachReceiveRight
(
name
)
mozilla
:
:
Some
(
0
)
&
right
)
;
if
(
kr
!
=
KERN_SUCCESS
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
failed
to
receive
mach
send
right
.
"
<
<
mach_error_string
(
kr
)
;
return
false
;
}
}
if
(
!
right
)
{
return
false
;
}
rights
.
AppendElement
(
std
:
:
move
(
right
)
)
;
}
msg
.
attached_send_rights_
=
std
:
:
move
(
rights
)
;
MOZ_ASSERT
(
msg
.
num_send_rights
(
)
=
=
num_send_rights
)
;
return
true
;
}
bool
Channel
:
:
ChannelImpl
:
:
TransferMachPorts
(
Message
&
msg
)
{
uint32_t
num_send_rights
=
msg
.
num_send_rights
(
)
;
if
(
num_send_rights
=
=
0
)
{
return
true
;
}
if
(
!
accept_mach_ports_
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
cannot
send
message
:
"
<
<
msg
.
name
(
)
<
<
"
.
channel
is
not
configured
to
accept
mach
ports
"
;
return
false
;
}
#
ifdef
DEBUG
uint32_t
rights_offset
=
msg
.
header
(
)
-
>
payload_size
;
#
endif
nsTArray
<
uint32_t
>
payload
(
num_send_rights
)
;
for
(
auto
&
port_to_send
:
msg
.
attached_send_rights_
)
{
if
(
privileged_
)
{
if
(
!
other_task_
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
other_task_
is
invalid
in
TransferMachPorts
"
;
return
false
;
}
mozilla
:
:
Maybe
<
mach_port_name_t
>
endpoint
=
BrokerTransferSendRight
(
other_task_
.
get
(
)
std
:
:
move
(
port_to_send
)
)
;
if
(
!
endpoint
)
{
return
false
;
}
payload
.
AppendElement
(
*
endpoint
)
;
}
else
{
payload
.
AppendElement
(
port_to_send
.
release
(
)
)
;
}
}
msg
.
attached_send_rights_
.
Clear
(
)
;
msg
.
WriteFooter
(
payload
.
Elements
(
)
payload
.
Length
(
)
*
sizeof
(
uint32_t
)
)
;
msg
.
header
(
)
-
>
num_send_rights
=
num_send_rights
;
MOZ_ASSERT
(
msg
.
header
(
)
-
>
payload_size
=
=
rights_offset
+
(
sizeof
(
uint32_t
)
*
num_send_rights
)
"
Unexpected
number
of
bytes
written
for
send
rights
footer
?
"
)
;
return
true
;
}
#
endif
Channel
:
:
Channel
(
const
ChannelId
&
channel_id
Mode
mode
Listener
*
listener
)
:
channel_impl_
(
new
ChannelImpl
(
channel_id
mode
listener
)
)
{
MOZ_COUNT_CTOR
(
IPC
:
:
Channel
)
;
}
Channel
:
:
Channel
(
ChannelHandle
pipe
Mode
mode
Listener
*
listener
)
:
channel_impl_
(
new
ChannelImpl
(
std
:
:
move
(
pipe
)
mode
listener
)
)
{
MOZ_COUNT_CTOR
(
IPC
:
:
Channel
)
;
}
Channel
:
:
~
Channel
(
)
{
MOZ_COUNT_DTOR
(
IPC
:
:
Channel
)
;
}
bool
Channel
:
:
Connect
(
)
{
return
channel_impl_
-
>
Connect
(
)
;
}
void
Channel
:
:
Close
(
)
{
channel_impl_
-
>
Close
(
)
;
}
Channel
:
:
Listener
*
Channel
:
:
set_listener
(
Listener
*
listener
)
{
return
channel_impl_
-
>
set_listener
(
listener
)
;
}
bool
Channel
:
:
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
{
return
channel_impl_
-
>
Send
(
std
:
:
move
(
message
)
)
;
}
void
Channel
:
:
GetClientFileDescriptorMapping
(
int
*
src_fd
int
*
dest_fd
)
const
{
return
channel_impl_
-
>
GetClientFileDescriptorMapping
(
src_fd
dest_fd
)
;
}
void
Channel
:
:
CloseClientFileDescriptor
(
)
{
channel_impl_
-
>
CloseClientFileDescriptor
(
)
;
}
int32_t
Channel
:
:
OtherPid
(
)
const
{
return
channel_impl_
-
>
OtherPid
(
)
;
}
bool
Channel
:
:
IsClosed
(
)
const
{
return
channel_impl_
-
>
IsClosed
(
)
;
}
#
if
defined
(
OS_MACOSX
)
void
Channel
:
:
SetOtherMachTask
(
task_t
task
)
{
channel_impl_
-
>
SetOtherMachTask
(
task
)
;
}
void
Channel
:
:
StartAcceptingMachPorts
(
Mode
mode
)
{
channel_impl_
-
>
StartAcceptingMachPorts
(
mode
)
;
}
#
endif
Channel
:
:
ChannelId
Channel
:
:
GenerateVerifiedChannelID
(
)
{
return
{
}
;
}
Channel
:
:
ChannelId
Channel
:
:
ChannelIDForCurrentProcess
(
)
{
return
{
}
;
}
bool
Channel
:
:
CreateRawPipe
(
ChannelHandle
*
server
ChannelHandle
*
client
)
{
int
fds
[
2
]
;
if
(
socketpair
(
AF_UNIX
SOCK_STREAM
0
fds
)
<
0
)
{
mozilla
:
:
ipc
:
:
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
:
:
IpcCreatePipeSocketPairErrno
errno
)
;
return
false
;
}
auto
configureFd
=
[
]
(
int
fd
)
-
>
bool
{
if
(
fcntl
(
fd
F_SETFL
O_NONBLOCK
)
=
=
-
1
)
{
mozilla
:
:
ipc
:
:
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
:
:
IpcCreatePipeFcntlErrno
errno
)
;
return
false
;
}
int
flags
=
fcntl
(
fd
F_GETFD
)
;
if
(
flags
=
=
-
1
)
{
mozilla
:
:
ipc
:
:
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
:
:
IpcCreatePipeCloExecErrno
errno
)
;
return
false
;
}
flags
|
=
FD_CLOEXEC
;
if
(
fcntl
(
fd
F_SETFD
flags
)
=
=
-
1
)
{
mozilla
:
:
ipc
:
:
AnnotateCrashReportWithErrno
(
CrashReporter
:
:
Annotation
:
:
IpcCreatePipeCloExecErrno
errno
)
;
return
false
;
}
return
true
;
}
;
if
(
!
configureFd
(
fds
[
0
]
)
|
|
!
configureFd
(
fds
[
1
]
)
)
{
IGNORE_EINTR
(
close
(
fds
[
0
]
)
)
;
IGNORE_EINTR
(
close
(
fds
[
1
]
)
)
;
return
false
;
}
server
-
>
reset
(
fds
[
0
]
)
;
client
-
>
reset
(
fds
[
1
]
)
;
return
true
;
}
}
