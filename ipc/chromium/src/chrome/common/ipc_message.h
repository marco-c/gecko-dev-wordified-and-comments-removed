#
ifndef
CHROME_COMMON_IPC_MESSAGE_H__
#
define
CHROME_COMMON_IPC_MESSAGE_H__
#
include
<
string
>
#
include
"
base
/
basictypes
.
h
"
#
include
"
base
/
pickle
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
#
endif
#
if
defined
(
OS_POSIX
)
#
include
"
nsAutoPtr
.
h
"
#
endif
#
ifdef
FUZZING
#
include
"
mozilla
/
ipc
/
Faulty
.
h
"
#
endif
namespace
base
{
struct
FileDescriptor
;
}
class
FileDescriptorSet
;
namespace
IPC
{
const
char
*
StringFromIPCMessageType
(
uint32_t
aMessageType
)
;
class
Channel
;
class
Message
;
#
ifdef
FUZZING
class
Faulty
;
#
endif
struct
LogData
;
class
Message
:
public
Pickle
{
public
:
typedef
uint32_t
msgid_t
;
enum
NestedLevel
{
NOT_NESTED
=
1
NESTED_INSIDE_SYNC
=
2
NESTED_INSIDE_CPOW
=
3
}
;
enum
PriorityValue
{
NORMAL_PRIORITY
=
0
INPUT_PRIORITY
=
1
HIGH_PRIORITY
=
2
}
;
enum
MessageCompression
{
COMPRESSION_NONE
COMPRESSION_ENABLED
COMPRESSION_ALL
}
;
enum
Sync
{
SYNC
=
0
ASYNC
=
1
}
;
enum
Interrupt
{
NOT_INTERRUPT
=
0
INTERRUPT
=
1
}
;
enum
Constructor
{
NOT_CONSTRUCTOR
=
0
CONSTRUCTOR
=
1
}
;
enum
Reply
{
NOT_REPLY
=
0
REPLY
=
1
}
;
class
HeaderFlags
{
friend
class
Message
;
enum
{
NESTED_MASK
=
0x0003
PRIO_MASK
=
0x000C
SYNC_BIT
=
0x0010
REPLY_BIT
=
0x0020
REPLY_ERROR_BIT
=
0x0040
INTERRUPT_BIT
=
0x0080
COMPRESS_BIT
=
0x0100
COMPRESSALL_BIT
=
0x0200
COMPRESS_MASK
=
0x0300
CONSTRUCTOR_BIT
=
0x0400
#
ifdef
MOZ_TASK_TRACER
TASKTRACER_BIT
=
0x0800
#
endif
}
;
public
:
constexpr
HeaderFlags
(
)
:
mFlags
(
NOT_NESTED
)
{
}
explicit
constexpr
HeaderFlags
(
NestedLevel
level
)
:
mFlags
(
level
)
{
}
constexpr
HeaderFlags
(
NestedLevel
level
PriorityValue
priority
MessageCompression
compression
Constructor
constructor
Sync
sync
Interrupt
interrupt
Reply
reply
)
:
mFlags
(
level
|
(
priority
<
<
2
)
|
(
compression
=
=
COMPRESSION_ENABLED
?
COMPRESS_BIT
:
compression
=
=
COMPRESSION_ALL
?
COMPRESSALL_BIT
:
0
)
|
(
constructor
=
=
CONSTRUCTOR
?
CONSTRUCTOR_BIT
:
0
)
|
(
sync
=
=
SYNC
?
SYNC_BIT
:
0
)
|
(
interrupt
=
=
INTERRUPT
?
INTERRUPT_BIT
:
0
)
|
(
reply
=
=
REPLY
?
REPLY_BIT
:
0
)
)
{
}
NestedLevel
Level
(
)
const
{
return
static_cast
<
NestedLevel
>
(
mFlags
&
NESTED_MASK
)
;
}
PriorityValue
Priority
(
)
const
{
return
static_cast
<
PriorityValue
>
(
(
mFlags
&
PRIO_MASK
)
>
>
2
)
;
}
MessageCompression
Compression
(
)
const
{
return
(
(
mFlags
&
COMPRESS_BIT
)
?
COMPRESSION_ENABLED
:
(
mFlags
&
COMPRESSALL_BIT
)
?
COMPRESSION_ALL
:
COMPRESSION_NONE
)
;
}
bool
IsConstructor
(
)
const
{
return
(
mFlags
&
CONSTRUCTOR_BIT
)
!
=
0
;
}
bool
IsSync
(
)
const
{
return
(
mFlags
&
SYNC_BIT
)
!
=
0
;
}
bool
IsInterrupt
(
)
const
{
return
(
mFlags
&
INTERRUPT_BIT
)
!
=
0
;
}
bool
IsReply
(
)
const
{
return
(
mFlags
&
REPLY_BIT
)
!
=
0
;
}
bool
IsReplyError
(
)
const
{
return
(
mFlags
&
REPLY_ERROR_BIT
)
!
=
0
;
}
#
ifdef
MOZ_TASK_TRACER
bool
IsTaskTracer
(
)
const
{
return
(
mFlags
&
TASKTRACER_BIT
)
!
=
0
;
}
#
endif
private
:
void
SetSync
(
)
{
mFlags
|
=
SYNC_BIT
;
}
void
SetInterrupt
(
)
{
mFlags
|
=
INTERRUPT_BIT
;
}
void
SetReply
(
)
{
mFlags
|
=
REPLY_BIT
;
}
void
SetReplyError
(
)
{
mFlags
|
=
REPLY_ERROR_BIT
;
}
#
ifdef
MOZ_TASK_TRACER
void
SetTaskTracer
(
)
{
mFlags
|
=
TASKTRACER_BIT
;
}
#
endif
uint32_t
mFlags
;
}
;
virtual
~
Message
(
)
;
Message
(
)
;
Message
(
int32_t
routing_id
msgid_t
type
uint32_t
segmentCapacity
=
0
HeaderFlags
flags
=
HeaderFlags
(
)
bool
recordWriteLatency
=
false
)
;
Message
(
const
char
*
data
int
data_len
)
;
Message
(
const
Message
&
other
)
=
delete
;
Message
(
Message
&
&
other
)
;
Message
&
operator
=
(
const
Message
&
other
)
=
delete
;
Message
&
operator
=
(
Message
&
&
other
)
;
void
CopyFrom
(
const
Message
&
other
)
;
static
Message
*
IPDLMessage
(
int32_t
routing_id
msgid_t
type
HeaderFlags
flags
)
;
static
Message
*
ForSyncDispatchError
(
NestedLevel
level
)
;
static
Message
*
ForInterruptDispatchError
(
)
;
NestedLevel
nested_level
(
)
const
{
return
header
(
)
-
>
flags
.
Level
(
)
;
}
PriorityValue
priority
(
)
const
{
return
header
(
)
-
>
flags
.
Priority
(
)
;
}
bool
is_constructor
(
)
const
{
return
header
(
)
-
>
flags
.
IsConstructor
(
)
;
}
bool
is_sync
(
)
const
{
return
header
(
)
-
>
flags
.
IsSync
(
)
;
}
bool
is_interrupt
(
)
const
{
return
header
(
)
-
>
flags
.
IsInterrupt
(
)
;
}
MessageCompression
compress_type
(
)
const
{
return
header
(
)
-
>
flags
.
Compression
(
)
;
}
bool
is_reply
(
)
const
{
return
header
(
)
-
>
flags
.
IsReply
(
)
;
}
bool
is_reply_error
(
)
const
{
return
header
(
)
-
>
flags
.
IsReplyError
(
)
;
}
msgid_t
type
(
)
const
{
return
header
(
)
-
>
type
;
}
int32_t
routing_id
(
)
const
{
return
header
(
)
-
>
routing
;
}
void
set_routing_id
(
int32_t
new_id
)
{
header
(
)
-
>
routing
=
new_id
;
}
int32_t
transaction_id
(
)
const
{
return
header
(
)
-
>
txid
;
}
void
set_transaction_id
(
int32_t
txid
)
{
header
(
)
-
>
txid
=
txid
;
}
uint32_t
interrupt_remote_stack_depth_guess
(
)
const
{
return
header
(
)
-
>
interrupt_remote_stack_depth_guess
;
}
void
set_interrupt_remote_stack_depth_guess
(
uint32_t
depth
)
{
DCHECK
(
is_interrupt
(
)
)
;
header
(
)
-
>
interrupt_remote_stack_depth_guess
=
depth
;
}
uint32_t
interrupt_local_stack_depth
(
)
const
{
return
header
(
)
-
>
interrupt_local_stack_depth
;
}
void
set_interrupt_local_stack_depth
(
uint32_t
depth
)
{
DCHECK
(
is_interrupt
(
)
)
;
header
(
)
-
>
interrupt_local_stack_depth
=
depth
;
}
int32_t
seqno
(
)
const
{
return
header
(
)
-
>
seqno
;
}
void
set_seqno
(
int32_t
aSeqno
)
{
header
(
)
-
>
seqno
=
aSeqno
;
}
const
char
*
name
(
)
const
{
return
StringFromIPCMessageType
(
type
(
)
)
;
}
const
mozilla
:
:
TimeStamp
&
create_time
(
)
const
{
return
create_time_
;
}
#
if
defined
(
OS_POSIX
)
uint32_t
num_fds
(
)
const
;
#
endif
template
<
class
T
>
static
bool
Dispatch
(
const
Message
*
msg
T
*
obj
void
(
T
:
:
*
func
)
(
)
)
{
(
obj
-
>
*
func
)
(
)
;
return
true
;
}
template
<
class
T
>
static
bool
Dispatch
(
const
Message
*
msg
T
*
obj
void
(
T
:
:
*
func
)
(
)
const
)
{
(
obj
-
>
*
func
)
(
)
;
return
true
;
}
template
<
class
T
>
static
bool
Dispatch
(
const
Message
*
msg
T
*
obj
void
(
T
:
:
*
func
)
(
const
Message
&
)
)
{
(
obj
-
>
*
func
)
(
*
msg
)
;
return
true
;
}
template
<
class
T
>
static
bool
Dispatch
(
const
Message
*
msg
T
*
obj
void
(
T
:
:
*
func
)
(
const
Message
&
)
const
)
{
(
obj
-
>
*
func
)
(
*
msg
)
;
return
true
;
}
static
void
Log
(
const
Message
*
msg
std
:
:
wstring
*
l
)
{
}
static
int
HeaderSizeFromData
(
const
char
*
range_start
const
char
*
range_end
)
{
#
ifdef
MOZ_TASK_TRACER
return
(
(
static_cast
<
unsigned
int
>
(
range_end
-
range_start
)
>
=
sizeof
(
Header
)
)
&
&
(
reinterpret_cast
<
const
Header
*
>
(
range_start
)
-
>
flags
.
IsTaskTracer
(
)
)
)
?
sizeof
(
HeaderTaskTracer
)
:
sizeof
(
Header
)
;
#
else
return
sizeof
(
Header
)
;
#
endif
}
static
uint32_t
MessageSize
(
const
char
*
range_start
const
char
*
range_end
)
{
return
Pickle
:
:
MessageSize
(
HeaderSizeFromData
(
range_start
range_end
)
range_start
range_end
)
;
}
#
if
defined
(
OS_POSIX
)
bool
WriteFileDescriptor
(
const
base
:
:
FileDescriptor
&
descriptor
)
;
bool
ReadFileDescriptor
(
PickleIterator
*
iter
base
:
:
FileDescriptor
*
descriptor
)
const
;
#
if
defined
(
OS_MACOSX
)
void
set_fd_cookie
(
uint32_t
cookie
)
{
header
(
)
-
>
cookie
=
cookie
;
}
uint32_t
fd_cookie
(
)
const
{
return
header
(
)
-
>
cookie
;
}
#
endif
#
endif
friend
class
Channel
;
friend
class
MessageReplyDeserializer
;
friend
class
SyncMessage
;
#
ifdef
FUZZING
friend
class
mozilla
:
:
ipc
:
:
Faulty
;
#
endif
#
ifdef
MOZ_TASK_TRACER
void
TaskTracerDispatch
(
)
;
class
AutoTaskTracerRun
:
public
mozilla
:
:
tasktracer
:
:
AutoSaveCurTraceInfo
{
Message
&
mMsg
;
uint64_t
mTaskId
;
uint64_t
mSourceEventId
;
public
:
explicit
AutoTaskTracerRun
(
Message
&
aMsg
)
;
~
AutoTaskTracerRun
(
)
;
}
;
#
endif
#
if
!
defined
(
OS_MACOSX
)
protected
:
#
endif
struct
Header
:
Pickle
:
:
Header
{
int32_t
routing
;
msgid_t
type
;
HeaderFlags
flags
;
#
if
defined
(
OS_POSIX
)
uint32_t
num_fds
;
#
if
defined
(
OS_MACOSX
)
uint32_t
cookie
;
#
endif
#
endif
union
{
uint32_t
interrupt_remote_stack_depth_guess
;
int32_t
txid
;
}
;
uint32_t
interrupt_local_stack_depth
;
int32_t
seqno
;
}
;
#
ifdef
MOZ_TASK_TRACER
struct
HeaderTaskTracer
:
public
Header
{
uint64_t
task_id
;
uint64_t
source_event_id
;
uint64_t
parent_task_id
;
mozilla
:
:
tasktracer
:
:
SourceEventType
source_event_type
;
}
;
#
endif
#
ifdef
MOZ_TASK_TRACER
bool
UseTaskTracerHeader
(
)
const
{
return
sizeof
(
HeaderTaskTracer
)
=
=
(
size
(
)
-
payload_size
(
)
)
;
}
Header
*
header
(
)
{
return
UseTaskTracerHeader
(
)
?
headerT
<
HeaderTaskTracer
>
(
)
:
headerT
<
Header
>
(
)
;
}
const
Header
*
header
(
)
const
{
return
UseTaskTracerHeader
(
)
?
headerT
<
HeaderTaskTracer
>
(
)
:
headerT
<
Header
>
(
)
;
}
#
else
Header
*
header
(
)
{
return
headerT
<
Header
>
(
)
;
}
const
Header
*
header
(
)
const
{
return
headerT
<
Header
>
(
)
;
}
#
endif
#
if
defined
(
OS_POSIX
)
RefPtr
<
FileDescriptorSet
>
file_descriptor_set_
;
void
EnsureFileDescriptorSet
(
)
;
FileDescriptorSet
*
file_descriptor_set
(
)
{
EnsureFileDescriptorSet
(
)
;
return
file_descriptor_set_
.
get
(
)
;
}
const
FileDescriptorSet
*
file_descriptor_set
(
)
const
{
return
file_descriptor_set_
.
get
(
)
;
}
#
endif
mozilla
:
:
TimeStamp
create_time_
;
}
;
class
MessageInfo
{
public
:
typedef
uint32_t
msgid_t
;
explicit
MessageInfo
(
const
Message
&
aMsg
)
:
mSeqno
(
aMsg
.
seqno
(
)
)
mType
(
aMsg
.
type
(
)
)
{
}
int32_t
seqno
(
)
const
{
return
mSeqno
;
}
msgid_t
type
(
)
const
{
return
mType
;
}
private
:
int32_t
mSeqno
;
msgid_t
mType
;
}
;
}
enum
SpecialRoutingIDs
{
MSG_ROUTING_NONE
=
kint32min
MSG_ROUTING_CONTROL
=
kint32max
}
;
#
define
IPC_REPLY_ID
0xFFF0
/
/
Special
message
id
for
replies
#
define
IPC_LOGGING_ID
0xFFF1
/
/
Special
message
id
for
logging
#
endif
