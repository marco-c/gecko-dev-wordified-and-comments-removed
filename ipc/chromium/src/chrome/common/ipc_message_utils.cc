#
include
"
chrome
/
common
/
ipc_message_utils
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryCursor
.
h
"
namespace
IPC
{
MessageBufferWriter
:
:
MessageBufferWriter
(
MessageWriter
*
writer
uint32_t
full_len
)
:
writer_
(
writer
)
{
if
(
full_len
>
kMessageBufferShmemThreshold
)
{
auto
handle
=
mozilla
:
:
ipc
:
:
shared_memory
:
:
Create
(
full_len
)
;
bool
shmem_ok
=
handle
.
IsValid
(
)
;
writer
-
>
WriteBool
(
shmem_ok
)
;
if
(
shmem_ok
)
{
shmem_cursor_
=
mozilla
:
:
MakeUnique
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
Cursor
>
(
std
:
:
move
(
handle
)
)
;
MOZ_ASSERT
(
shmem_cursor_
-
>
IsValid
(
)
)
;
}
else
{
writer
-
>
NoteLargeBufferShmemFailure
(
full_len
)
;
}
}
remaining_
=
full_len
;
}
MessageBufferWriter
:
:
~
MessageBufferWriter
(
)
{
if
(
remaining_
!
=
0
)
{
writer_
-
>
FatalError
(
"
didn
'
t
fully
write
message
buffer
"
)
;
}
if
(
shmem_cursor_
)
{
IPC
:
:
WriteParam
(
writer_
shmem_cursor_
-
>
TakeHandle
(
)
)
;
}
}
bool
MessageBufferWriter
:
:
WriteBytes
(
const
void
*
data
uint32_t
len
)
{
MOZ_RELEASE_ASSERT
(
len
=
=
remaining_
|
|
(
len
%
4
)
=
=
0
"
all
writes
except
for
the
final
write
must
be
a
multiple
"
"
of
4
bytes
in
length
due
to
padding
"
)
;
if
(
len
>
remaining_
)
{
writer_
-
>
FatalError
(
"
MessageBufferWriter
overrun
"
)
;
return
false
;
}
remaining_
-
=
len
;
if
(
shmem_cursor_
)
{
return
shmem_cursor_
-
>
Write
(
data
len
)
;
}
return
writer_
-
>
WriteBytes
(
data
len
)
;
}
MessageBufferReader
:
:
MessageBufferReader
(
MessageReader
*
reader
uint32_t
full_len
)
:
reader_
(
reader
)
{
if
(
full_len
>
kMessageBufferShmemThreshold
)
{
bool
shmem_ok
=
false
;
if
(
!
reader
-
>
ReadBool
(
&
shmem_ok
)
)
{
reader
-
>
FatalError
(
"
MessageReader
:
:
ReadBool
failed
!
"
)
;
return
;
}
if
(
shmem_ok
)
{
mozilla
:
:
ipc
:
:
shared_memory
:
:
MutableHandle
handle
;
if
(
!
IPC
:
:
ReadParam
(
reader
&
handle
)
)
{
reader
-
>
FatalError
(
"
failed
to
read
shared
memory
handle
"
)
;
return
;
}
if
(
!
handle
.
IsValid
(
)
)
{
reader
-
>
FatalError
(
"
invalid
shared
memory
handle
"
)
;
return
;
}
if
(
handle
.
Size
(
)
<
full_len
)
{
reader
-
>
FatalError
(
"
too
small
shared
memory
handle
"
)
;
return
;
}
shmem_cursor_
=
mozilla
:
:
MakeUnique
<
mozilla
:
:
ipc
:
:
shared_memory
:
:
Cursor
>
(
std
:
:
move
(
handle
)
)
;
MOZ_ASSERT
(
shmem_cursor_
-
>
IsValid
(
)
)
;
}
}
remaining_
=
full_len
;
}
MessageBufferReader
:
:
~
MessageBufferReader
(
)
{
if
(
remaining_
!
=
0
)
{
reader_
-
>
FatalError
(
"
didn
'
t
fully
write
message
buffer
"
)
;
}
}
bool
MessageBufferReader
:
:
ReadBytesInto
(
void
*
data
uint32_t
len
)
{
MOZ_RELEASE_ASSERT
(
len
=
=
remaining_
|
|
(
len
%
4
)
=
=
0
"
all
reads
except
for
the
final
read
must
be
a
multiple
"
"
of
4
bytes
in
length
due
to
padding
"
)
;
if
(
len
>
remaining_
)
{
reader_
-
>
FatalError
(
"
MessageBufferReader
overrun
"
)
;
return
false
;
}
remaining_
-
=
len
;
if
(
shmem_cursor_
)
{
return
shmem_cursor_
-
>
Read
(
data
len
)
;
}
return
reader_
-
>
ReadBytesInto
(
data
len
)
;
}
}
