#
include
"
chrome
/
common
/
process_watcher
.
h
"
#
include
<
algorithm
>
#
include
<
processthreadsapi
.
h
>
#
include
<
synchapi
.
h
>
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
object_watcher
.
h
"
#
include
"
prenv
.
h
"
static
constexpr
int
kWaitInterval
=
2000
;
#
ifdef
MOZ_CODE_COVERAGE
static
constexpr
DWORD
kShutdownWaitMs
=
80000
;
#
elif
defined
(
MOZ_ASAN
)
|
|
defined
(
MOZ_TSAN
)
static
constexpr
DWORD
kShutdownWaitMs
=
40000
;
#
else
static
constexpr
DWORD
kShutdownWaitMs
=
8000
;
#
endif
namespace
{
static
bool
IsProcessDead
(
base
:
:
ProcessHandle
process
)
{
return
WaitForSingleObject
(
process
0
)
=
=
WAIT_OBJECT_0
;
}
class
ChildReaper
:
public
mozilla
:
:
Runnable
public
base
:
:
ObjectWatcher
:
:
Delegate
public
MessageLoop
:
:
DestructionObserver
{
public
:
explicit
ChildReaper
(
base
:
:
ProcessHandle
process
bool
force
)
:
mozilla
:
:
Runnable
(
"
ChildReaper
"
)
process_
(
process
)
force_
(
force
)
{
watcher_
.
StartWatching
(
process_
this
)
;
}
virtual
~
ChildReaper
(
)
{
if
(
process_
)
{
KillProcess
(
)
;
DCHECK
(
!
process_
)
<
<
"
Make
sure
to
close
the
handle
.
"
;
}
}
virtual
void
WillDestroyCurrentMessageLoop
(
)
{
MOZ_ASSERT
(
!
force_
)
;
if
(
process_
)
{
if
(
!
PR_GetEnv
(
"
MOZ_TEST_CHILD_EXIT_HANG
"
)
)
{
CrashProcessIfHanging
(
)
;
}
WaitForSingleObject
(
process_
INFINITE
)
;
base
:
:
CloseProcessHandle
(
process_
)
;
process_
=
0
;
MessageLoop
:
:
current
(
)
-
>
RemoveDestructionObserver
(
this
)
;
delete
this
;
}
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
force_
)
;
if
(
process_
)
{
KillProcess
(
)
;
}
return
NS_OK
;
}
virtual
void
OnObjectSignaled
(
HANDLE
object
)
{
watcher_
.
StopWatching
(
)
;
base
:
:
CloseProcessHandle
(
process_
)
;
process_
=
0
;
if
(
!
force_
)
{
MessageLoop
:
:
current
(
)
-
>
RemoveDestructionObserver
(
this
)
;
delete
this
;
}
}
private
:
void
KillProcess
(
)
{
MOZ_ASSERT
(
force_
)
;
TerminateProcess
(
process_
base
:
:
PROCESS_END_PROCESS_WAS_HUNG
)
;
OnObjectSignaled
(
process_
)
;
}
void
CrashProcessIfHanging
(
)
{
if
(
IsProcessDead
(
process_
)
)
{
return
;
}
DWORD
pid
=
GetProcessId
(
process_
)
;
DCHECK
(
pid
!
=
0
)
;
static
DWORD
sWaitMs
=
kShutdownWaitMs
;
if
(
sWaitMs
>
0
)
{
CHROMIUM_LOG
(
WARNING
)
<
<
"
Process
"
<
<
pid
<
<
"
may
be
hanging
at
shutdown
;
will
wait
for
up
to
"
<
<
sWaitMs
<
<
"
ms
"
;
}
const
auto
beforeWait
=
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
;
const
DWORD
waitStatus
=
WaitForSingleObject
(
process_
sWaitMs
)
;
const
double
elapsed
=
(
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
-
beforeWait
)
.
ToMilliseconds
(
)
;
sWaitMs
-
=
static_cast
<
DWORD
>
(
std
:
:
clamp
(
elapsed
0
.
0
static_cast
<
double
>
(
sWaitMs
)
)
)
;
switch
(
waitStatus
)
{
case
WAIT_TIMEOUT
:
break
;
case
WAIT_OBJECT_0
:
return
;
case
WAIT_FAILED
:
CHROMIUM_LOG
(
ERROR
)
<
<
"
Waiting
for
process
"
<
<
pid
<
<
"
failed
;
error
"
<
<
GetLastError
(
)
;
DCHECK
(
false
)
<
<
"
WaitForSingleObject
failed
"
;
return
;
default
:
DCHECK
(
false
)
<
<
"
WaitForSingleObject
returned
"
<
<
waitStatus
;
return
;
}
CHROMIUM_LOG
(
ERROR
)
<
<
"
Process
"
<
<
pid
<
<
"
hanging
at
shutdown
;
attempting
crash
report
(
fatal
error
)
"
;
static
constexpr
uint64_t
kIpcMagic
=
0x43504900435049
;
const
HMODULE
ntdll
=
GetModuleHandleW
(
L
"
ntdll
.
dll
"
)
;
if
(
!
ntdll
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
couldn
'
t
find
ntdll
.
dll
:
error
"
<
<
GetLastError
(
)
;
return
;
}
const
auto
dbgBreak
=
reinterpret_cast
<
LPTHREAD_START_ROUTINE
>
(
GetProcAddress
(
ntdll
"
DbgBreakPoint
"
)
)
;
if
(
!
dbgBreak
)
{
CHROMIUM_LOG
(
ERROR
)
<
<
"
couldn
'
t
find
DbgBreakPoint
:
error
"
<
<
GetLastError
(
)
;
return
;
}
const
DWORD
rights
=
PROCESS_CREATE_THREAD
|
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_OPERATION
|
PROCESS_VM_WRITE
|
PROCESS_VM_READ
;
HANDLE
process_priv
=
nullptr
;
if
(
!
DuplicateHandle
(
GetCurrentProcess
(
)
process_
GetCurrentProcess
(
)
&
process_priv
rights
FALSE
0
)
)
{
const
auto
error
=
GetLastError
(
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
OpenProcess
:
error
"
<
<
error
;
}
else
{
DCHECK
(
process_priv
)
;
HANDLE
thread
=
CreateRemoteThread
(
process_priv
nullptr
0
dbgBreak
(
LPVOID
)
kIpcMagic
0
nullptr
)
;
if
(
!
thread
)
{
const
auto
error
=
GetLastError
(
)
;
CHROMIUM_LOG
(
ERROR
)
<
<
"
CreateRemoteThread
:
error
"
<
<
error
;
}
else
{
CloseHandle
(
thread
)
;
}
CloseHandle
(
process_priv
)
;
}
}
base
:
:
ProcessHandle
process_
;
base
:
:
ObjectWatcher
watcher_
;
bool
force_
;
DISALLOW_EVIL_CONSTRUCTORS
(
ChildReaper
)
;
}
;
}
void
ProcessWatcher
:
:
EnsureProcessTerminated
(
base
:
:
ProcessHandle
process
bool
force
)
{
DCHECK
(
process
!
=
GetCurrentProcess
(
)
)
;
if
(
IsProcessDead
(
process
)
)
{
base
:
:
CloseProcessHandle
(
process
)
;
return
;
}
MessageLoopForIO
*
loop
=
MessageLoopForIO
:
:
current
(
)
;
if
(
force
)
{
RefPtr
<
mozilla
:
:
Runnable
>
task
=
new
ChildReaper
(
process
force
)
;
loop
-
>
PostDelayedTask
(
task
.
forget
(
)
kWaitInterval
)
;
}
else
{
loop
-
>
AddDestructionObserver
(
new
ChildReaper
(
process
force
)
)
;
}
}
