#
ifndef
CHROME_COMMON_IPC_CHANNEL_POSIX_H_
#
define
CHROME_COMMON_IPC_CHANNEL_POSIX_H_
#
include
"
chrome
/
common
/
ipc_channel
.
h
"
#
include
"
chrome
/
common
/
ipc_channel_capability
.
h
"
#
include
<
sys
/
socket
.
h
>
#
include
<
atomic
>
#
include
<
string
>
#
include
<
vector
>
#
include
<
list
>
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Queue
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsISupports
.
h
"
namespace
IPC
{
class
Channel
:
:
ChannelImpl
:
public
MessageLoopForIO
:
:
Watcher
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING_WITH_DELETE_ON_EVENT_TARGET
(
ChannelImpl
IOThread
(
)
.
GetEventTarget
(
)
)
;
using
ChannelId
=
Channel
:
:
ChannelId
;
ChannelImpl
(
const
ChannelId
&
channel_id
Mode
mode
Listener
*
listener
)
;
ChannelImpl
(
ChannelHandle
pipe
Mode
mode
Listener
*
listener
)
;
bool
Connect
(
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
void
Close
(
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
Listener
*
set_listener
(
Listener
*
listener
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
chan_cap_
.
NoteOnIOThread
(
)
;
Listener
*
old
=
listener_
;
listener_
=
listener
;
return
old
;
}
bool
Send
(
mozilla
:
:
UniquePtr
<
Message
>
message
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
void
GetClientFileDescriptorMapping
(
int
*
src_fd
int
*
dest_fd
)
const
;
void
CloseClientFileDescriptor
(
)
;
int32_t
OtherPid
(
)
{
IOThread
(
)
.
AssertOnCurrentThread
(
)
;
chan_cap_
.
NoteOnIOThread
(
)
;
return
other_pid_
;
}
bool
IsClosed
(
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
{
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteSendMutex
(
)
;
return
pipe_
=
=
-
1
;
}
#
if
defined
(
OS_MACOSX
)
void
SetOtherMachTask
(
task_t
task
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
void
StartAcceptingMachPorts
(
Mode
mode
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
#
endif
private
:
~
ChannelImpl
(
)
{
Close
(
)
;
}
void
Init
(
Mode
mode
Listener
*
listener
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
bool
CreatePipe
(
Mode
mode
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
void
SetPipe
(
int
fd
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
void
SetOtherPid
(
int
other_pid
)
MOZ_REQUIRES
(
IOThread
(
)
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
{
mozilla
:
:
MutexAutoLock
lock
(
SendMutex
(
)
)
;
chan_cap_
.
NoteExclusiveAccess
(
)
;
other_pid_
=
other_pid
;
}
bool
PipeBufHasSpaceAfter
(
size_t
already_written
)
MOZ_REQUIRES_SHARED
(
chan_cap_
)
;
bool
EnqueueHelloMessage
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
bool
ConnectLocked
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
void
CloseLocked
(
)
MOZ_REQUIRES
(
SendMutex
(
)
IOThread
(
)
)
;
bool
ProcessIncomingMessages
(
)
MOZ_REQUIRES
(
IOThread
(
)
)
;
bool
ProcessOutgoingMessages
(
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
virtual
void
OnFileCanReadWithoutBlocking
(
int
fd
)
override
;
virtual
void
OnFileCanWriteWithoutBlocking
(
int
fd
)
override
;
#
if
defined
(
OS_MACOSX
)
void
CloseDescriptors
(
uint32_t
pending_fd_id
)
MOZ_REQUIRES
(
IOThread
(
)
)
MOZ_EXCLUDES
(
SendMutex
(
)
)
;
bool
AcceptMachPorts
(
Message
&
msg
)
MOZ_REQUIRES
(
IOThread
(
)
)
;
bool
TransferMachPorts
(
Message
&
msg
)
MOZ_REQUIRES_SHARED
(
chan_cap_
)
;
#
endif
void
OutputQueuePush
(
mozilla
:
:
UniquePtr
<
Message
>
msg
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
void
OutputQueuePop
(
)
MOZ_REQUIRES
(
SendMutex
(
)
)
;
const
ChannelCapability
:
:
Thread
&
IOThread
(
)
const
MOZ_RETURN_CAPABILITY
(
chan_cap_
.
IOThread
(
)
)
{
return
chan_cap_
.
IOThread
(
)
;
}
ChannelCapability
:
:
Mutex
&
SendMutex
(
)
MOZ_RETURN_CAPABILITY
(
chan_cap_
.
SendMutex
(
)
)
{
return
chan_cap_
.
SendMutex
(
)
;
}
ChannelCapability
chan_cap_
;
Mode
mode_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
MessageLoopForIO
:
:
FileDescriptorWatcher
read_watcher_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
MessageLoopForIO
:
:
FileDescriptorWatcher
write_watcher_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
bool
is_blocked_on_write_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
=
false
;
struct
PartialWrite
{
Pickle
:
:
BufferList
:
:
IterImpl
iter_
;
mozilla
:
:
Span
<
const
mozilla
:
:
UniqueFileHandle
>
handles_
;
}
;
mozilla
:
:
Maybe
<
PartialWrite
>
partial_write_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
int
pipe_
MOZ_GUARDED_BY
(
chan_cap_
)
;
int
client_pipe_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
unsigned
pipe_buf_len_
MOZ_GUARDED_BY
(
chan_cap_
)
;
Listener
*
listener_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
mozilla
:
:
Queue
<
mozilla
:
:
UniquePtr
<
Message
>
64
>
output_queue_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
size_t
input_buf_offset_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
input_buf_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
mozilla
:
:
UniquePtr
<
char
[
]
>
input_cmsg_buf_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
static
constexpr
size_t
kControlBufferMaxFds
=
200
;
static
constexpr
size_t
kControlBufferHeaderSize
=
32
;
static
constexpr
size_t
kControlBufferSize
=
kControlBufferMaxFds
*
sizeof
(
int
)
+
kControlBufferHeaderSize
;
mozilla
:
:
UniquePtr
<
Message
>
incoming_message_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
std
:
:
vector
<
int
>
input_overflow_fds_
MOZ_GUARDED_BY
(
IOThread
(
)
)
;
bool
waiting_connect_
MOZ_GUARDED_BY
(
chan_cap_
)
=
true
;
int32_t
other_pid_
MOZ_GUARDED_BY
(
chan_cap_
)
=
-
1
;
#
if
defined
(
OS_MACOSX
)
struct
PendingDescriptors
{
uint32_t
id
;
nsTArray
<
mozilla
:
:
UniqueFileHandle
>
handles
;
}
;
std
:
:
list
<
PendingDescriptors
>
pending_fds_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
;
uint32_t
last_pending_fd_id_
MOZ_GUARDED_BY
(
SendMutex
(
)
)
=
0
;
bool
accept_mach_ports_
MOZ_GUARDED_BY
(
chan_cap_
)
=
false
;
bool
privileged_
MOZ_GUARDED_BY
(
chan_cap_
)
=
false
;
mozilla
:
:
UniqueMachSendRight
other_task_
MOZ_GUARDED_BY
(
chan_cap_
)
;
#
endif
DISALLOW_COPY_AND_ASSIGN
(
ChannelImpl
)
;
}
;
}
#
endif
