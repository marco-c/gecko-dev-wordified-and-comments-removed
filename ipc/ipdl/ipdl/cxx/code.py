import
re
import
math
import
textwrap
from
ipdl
.
cxx
.
ast
import
Node
Whitespace
GroupNode
VerbatimNode
def
StmtCode
(
tmpl
*
*
kwargs
)
:
    
"
"
"
Perform
template
substitution
to
build
opaque
C
+
+
AST
nodes
.
See
the
    
module
documentation
for
more
information
on
the
templating
syntax
.
    
StmtCode
nodes
should
be
used
where
Stmt
*
nodes
are
used
.
They
are
placed
    
on
their
own
line
and
indented
.
"
"
"
    
return
_code
(
tmpl
False
kwargs
)
def
ExprCode
(
tmpl
*
*
kwargs
)
:
    
"
"
"
Perform
template
substitution
to
build
opaque
C
+
+
AST
nodes
.
See
the
    
module
documentation
for
more
information
on
the
templating
syntax
.
    
ExprCode
nodes
should
be
used
where
Expr
*
nodes
are
used
.
They
are
placed
    
inline
and
no
trailing
newline
is
added
.
"
"
"
    
return
_code
(
tmpl
True
kwargs
)
def
StmtVerbatim
(
text
)
:
    
"
"
"
Build
an
opaque
C
+
+
AST
node
which
emits
input
text
verbatim
.
    
StmtVerbatim
nodes
should
be
used
where
Stmt
*
nodes
are
used
.
They
are
placed
    
on
their
own
line
and
indented
.
"
"
"
    
return
_verbatim
(
text
False
)
def
ExprVerbatim
(
text
)
:
    
"
"
"
Build
an
opaque
C
+
+
AST
node
which
emits
input
text
verbatim
.
    
ExprVerbatim
nodes
should
be
used
where
Expr
*
nodes
are
used
.
They
are
    
placed
inline
and
no
trailing
newline
is
added
.
"
"
"
    
return
_verbatim
(
text
True
)
def
_code
(
tmpl
inline
context
)
:
    
if
tmpl
.
startswith
(
"
\
n
"
)
:
        
tmpl
=
tmpl
[
1
:
]
    
tmpl
=
textwrap
.
dedent
(
tmpl
)
    
nodes
=
[
]
    
for
idx
line
in
enumerate
(
tmpl
.
splitlines
(
)
)
:
        
if
idx
>
0
:
            
nodes
.
append
(
Whitespace
.
NL
)
        
skip_indent
=
inline
and
idx
=
=
0
        
nodes
.
append
(
_line
(
line
.
rstrip
(
)
skip_indent
idx
+
1
context
)
)
    
if
not
inline
:
        
nodes
.
append
(
Whitespace
.
NL
)
    
return
GroupNode
(
nodes
)
def
_verbatim
(
text
inline
)
:
    
return
_code
(
text
.
replace
(
"
"
"
"
)
inline
{
}
)
_substPat
=
re
.
compile
(
    
r
"
"
"
    
\
(
?
:
        
(
?
P
<
escaped
>
\
)
|
#
'
'
is
an
escaped
'
'
        
(
?
P
<
list
>
[
*
]
)
?
{
(
?
P
<
expr
>
[
^
}
]
+
)
}
|
#
{
expr
}
*
{
expr
}
or
{
expr
}
        
(
?
P
<
invalid
>
)
#
For
error
reporting
    
)
    
"
"
"
    
re
.
IGNORECASE
|
re
.
VERBOSE
)
def
_line
(
raw
skip_indent
lineno
context
)
:
    
assert
"
\
n
"
not
in
raw
    
line
=
raw
.
lstrip
(
)
    
offset
=
int
(
math
.
ceil
(
(
len
(
raw
)
-
len
(
line
)
)
/
4
)
)
    
if
line
.
startswith
(
"
#
"
)
:
        
skip_indent
=
True
    
column
=
0
    
children
=
[
]
    
for
match
in
_substPat
.
finditer
(
line
)
:
        
if
match
.
group
(
"
invalid
"
)
is
not
None
:
            
raise
ValueError
(
"
Invalid
substitution
on
line
%
d
"
%
lineno
)
        
if
match
.
start
(
)
>
column
:
            
before
=
line
[
column
:
match
.
start
(
)
]
            
children
.
append
(
VerbatimNode
(
before
)
)
        
column
=
match
.
end
(
)
        
if
match
.
group
(
"
escaped
"
)
is
not
None
:
            
children
.
append
(
VerbatimNode
(
"
"
)
)
            
continue
        
list_chr
=
match
.
group
(
"
list
"
)
        
expr
=
match
.
group
(
"
expr
"
)
        
assert
expr
is
not
None
        
try
:
            
values
=
eval
(
expr
context
{
}
)
        
except
Exception
as
e
:
            
msg
=
"
%
s
in
substitution
on
line
%
d
"
%
(
repr
(
e
)
lineno
)
            
raise
ValueError
(
msg
)
from
e
        
if
list_chr
is
None
:
            
values
=
[
values
]
        
inline
=
match
.
span
(
)
!
=
(
0
len
(
line
)
)
        
for
idx
value
in
enumerate
(
values
)
:
            
multiline_list
=
list_chr
=
=
"
"
and
not
inline
            
if
idx
>
0
and
list_chr
=
=
"
"
:
                
children
.
append
(
VerbatimNode
(
"
\
n
"
if
multiline_list
else
"
"
)
)
            
if
multiline_list
:
                
children
.
append
(
VerbatimNode
(
"
"
indent
=
True
)
)
            
if
not
isinstance
(
value
Node
)
:
                
value
=
_verbatim
(
str
(
value
)
skip_indent
or
inline
)
            
children
.
append
(
value
)
        
if
not
inline
:
            
skip_indent
=
True
    
if
len
(
line
)
>
column
:
        
children
.
append
(
VerbatimNode
(
line
[
column
:
]
)
)
    
if
len
(
children
)
=
=
0
:
        
return
VerbatimNode
(
"
"
)
    
if
not
skip_indent
:
        
children
.
insert
(
0
VerbatimNode
(
"
"
indent
=
True
)
)
    
return
GroupNode
(
children
offset
=
offset
)
