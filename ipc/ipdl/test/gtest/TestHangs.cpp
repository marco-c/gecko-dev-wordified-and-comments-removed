#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
_ipdltest
/
IPDLUnitTest
.
h
"
#
include
"
mozilla
/
_ipdltest
/
PTestHangsChild
.
h
"
#
include
"
mozilla
/
_ipdltest
/
PTestHangsParent
.
h
"
#
include
"
mozilla
/
ipc
/
CrossProcessSemaphore
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
_ipdltest
{
enum
class
HangMode
:
uint32_t
{
None
Hang
HangButReceive
HangPermitted
}
;
class
TestHangsChild
:
public
PTestHangsChild
{
NS_INLINE_DECL_REFCOUNTING
(
TestHangsChild
override
)
TestHangsChild
(
)
:
timeout
(
CrossProcessSemaphore
:
:
Create
(
"
timeout
"
0
)
)
{
}
private
:
IPCResult
RecvStart
(
const
uint32_t
&
hangMode
StartResolver
&
&
resolve
)
final
override
{
SetReplyTimeoutMs
(
2
)
;
this
-
>
hangMode
=
(
HangMode
)
hangMode
;
auto
result
=
SendHang
(
hangMode
timeout
-
>
CloneHandle
(
)
)
;
if
(
this
-
>
hangMode
=
=
HangMode
:
:
Hang
)
{
timeout
-
>
Signal
(
)
;
EXPECT_FALSE
(
result
)
;
}
else
{
EXPECT_TRUE
(
result
)
;
}
resolve
(
detectedHang
)
;
return
IPC_OK
(
)
;
}
bool
ShouldContinueFromReplyTimeout
(
)
final
override
{
timeout
-
>
Signal
(
)
;
detectedHang
=
true
;
if
(
hangMode
=
=
HangMode
:
:
HangButReceive
)
{
while
(
!
GetIPCChannel
(
)
-
>
TestOnlyIsTransactionComplete
(
)
)
{
PR_Sleep
(
ticksPerSecond
/
1000
)
;
}
}
return
hangMode
=
=
HangMode
:
:
HangPermitted
;
}
~
TestHangsChild
(
)
=
default
;
HangMode
hangMode
=
HangMode
:
:
None
;
uint32_t
ticksPerSecond
=
PR_TicksPerSecond
(
)
;
UniquePtr
<
CrossProcessSemaphore
>
timeout
;
public
:
bool
detectedHang
=
false
;
}
;
class
TestHangsParent
:
public
PTestHangsParent
{
NS_INLINE_DECL_REFCOUNTING
(
TestHangsParent
override
)
private
:
IPCResult
RecvHang
(
const
uint32_t
&
hangMode
CrossProcessSemaphoreHandle
&
&
timeout_handle
)
final
override
{
UniquePtr
<
CrossProcessSemaphore
>
timeout
(
CrossProcessSemaphore
:
:
Create
(
std
:
:
move
(
timeout_handle
)
)
)
;
if
(
hangMode
!
=
(
uint32_t
)
HangMode
:
:
None
)
{
timeout
-
>
Wait
(
)
;
if
(
hangMode
=
=
(
uint32_t
)
HangMode
:
:
Hang
)
{
timeout
-
>
Wait
(
)
;
}
}
return
IPC_OK
(
)
;
}
~
TestHangsParent
(
)
=
default
;
}
;
#
define
TEST_HANGS
(
mode
)
\
IPDL_TEST
(
TestHangs
mode
)
{
\
mActor
-
>
SendStart
(
\
(
uint32_t
)
HangMode
:
:
mode
\
[
=
]
(
bool
detectedHang
)
{
\
EXPECT_EQ
(
detectedHang
HangMode
:
:
mode
!
=
HangMode
:
:
None
)
;
\
mActor
-
>
Close
(
)
;
\
}
\
[
]
(
auto
&
&
reason
)
{
FAIL
(
)
<
<
"
failed
to
send
start
"
;
}
)
;
\
}
TEST_HANGS
(
None
)
TEST_HANGS
(
Hang
)
TEST_HANGS
(
HangButReceive
)
TEST_HANGS
(
HangPermitted
)
#
undef
TEST_HANGS
}
