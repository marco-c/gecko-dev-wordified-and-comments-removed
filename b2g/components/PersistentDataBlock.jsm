"
use
strict
"
;
const
DEBUG
=
false
;
this
.
EXPORTED_SYMBOLS
=
[
"
PersistentDataBlock
"
]
;
const
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
const
PARTITION_MAGIC
=
0x19901873
;
const
MAX_DATA_BLOCK_SIZE
=
1024
*
100
;
const
DIGEST_SIZE_BYTES
=
32
;
const
HEADER_SIZE_BYTES
=
8
;
const
PARTITION_MAGIC_SIZE_BYTES
=
4
;
const
DATA_SIZE_BYTES
=
4
;
const
OEM_UNLOCK_ENABLED_BYTES
=
1
;
const
DIGEST_OFFSET
=
0
;
const
XPCOM_SHUTDOWN_OBSERVER_TOPIC
=
"
xpcom
-
shutdown
"
;
const
PERSISTENT_DATA_BLOCK_PROPERTY
=
"
ro
.
frp
.
pst
"
;
const
OEM_UNLOCK_PROPERTY
=
"
sys
.
oem_unlock_allowed
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
XPCOMUtils
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
OS
"
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
Promise
"
"
resource
:
/
/
gre
/
modules
/
Promise
.
jsm
"
)
;
XPCOMUtils
.
defineLazyModuleGetter
(
this
"
AppConstants
"
"
resource
:
/
/
gre
/
modules
/
AppConstants
.
jsm
"
)
;
XPCOMUtils
.
defineLazyGetter
(
this
"
libcutils
"
function
(
)
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
systemlibs
.
js
"
)
;
return
libcutils
;
}
)
;
var
inParent
=
Cc
[
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
]
.
getService
(
Ci
.
nsIXULRuntime
)
.
processType
=
=
=
Ci
.
nsIXULRuntime
.
PROCESS_TYPE_DEFAULT
;
function
log
(
str
)
{
dump
(
"
PersistentDataBlock
.
jsm
:
"
+
str
+
"
\
n
"
)
;
}
function
debug
(
str
)
{
DEBUG
&
&
log
(
str
)
;
}
function
toHexString
(
data
)
{
function
toHexChar
(
charCode
)
{
return
(
"
0
"
+
charCode
.
toString
(
16
)
.
slice
(
-
2
)
)
;
}
let
hexString
=
"
"
;
if
(
typeof
data
=
=
=
"
string
"
)
{
hexString
=
Array
.
from
(
data
(
c
i
)
=
>
toHexChar
(
data
.
charCodeAt
(
i
)
)
)
.
join
(
"
"
)
;
}
else
if
(
typeof
data
=
=
=
"
array
"
)
{
hexString
=
data
.
map
(
toHexChar
)
.
join
(
"
"
)
;
}
return
hexString
;
}
function
arr2bstr
(
arr
)
{
let
bstr
=
"
"
;
for
(
let
i
=
0
;
i
<
arr
.
length
;
i
+
+
)
{
bstr
+
=
String
.
fromCharCode
(
arr
[
i
]
)
;
}
return
bstr
;
}
this
.
PersistentDataBlock
=
{
_libc
:
{
handler
:
null
open
:
function
(
)
{
}
close
:
function
(
)
{
}
ioctl
:
function
(
)
{
}
}
_libcutils
:
null
_blockDeviceSize
:
-
1
_dataBlockFile
:
"
"
_testing
:
false
setTestingMode
:
function
(
enabled
)
{
this
.
_testing
=
enabled
|
|
false
;
}
init
:
function
(
mode
)
{
debug
(
"
init
(
)
"
)
;
if
(
libcutils
)
{
this
.
_libcutils
=
libcutils
;
}
if
(
!
this
.
ctypes
)
{
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
ctypes
.
jsm
"
this
)
;
}
if
(
this
.
_libc
.
handler
=
=
=
null
)
{
if
(
AppConstants
.
platform
!
=
"
gonk
"
)
{
log
(
"
This
component
requires
Gonk
!
"
)
;
throw
Cr
.
NS_ERROR_ABORT
;
}
try
{
this
.
_libc
.
handler
=
this
.
ctypes
.
open
(
this
.
ctypes
.
libraryName
(
"
c
"
)
)
;
this
.
_libc
.
close
=
this
.
_libc
.
handler
.
declare
(
"
close
"
this
.
ctypes
.
default_abi
this
.
ctypes
.
int
this
.
ctypes
.
int
)
;
this
.
_libc
.
open
=
this
.
_libc
.
handler
.
declare
(
"
open
"
this
.
ctypes
.
default_abi
this
.
ctypes
.
int
this
.
ctypes
.
char
.
ptr
this
.
ctypes
.
int
)
;
this
.
_libc
.
ioctl
=
this
.
_libc
.
handler
.
declare
(
"
ioctl
"
this
.
ctypes
.
default_abi
this
.
ctypes
.
int
this
.
ctypes
.
int
this
.
ctypes
.
unsigned_long
this
.
ctypes
.
unsigned_long
.
ptr
)
;
}
catch
(
ex
)
{
log
(
"
Unable
to
open
libc
.
so
:
ex
=
"
+
ex
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
}
this
.
_dataBlockFile
=
this
.
_libcutils
.
property_get
(
PERSISTENT_DATA_BLOCK_PROPERTY
)
;
if
(
this
.
_dataBlockFile
=
=
=
null
)
{
log
(
"
init
:
ERROR
:
property
"
+
PERSISTENT_DATA_BLOCK_PROPERTY
+
"
doesn
'
t
exist
!
"
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
Services
.
obs
.
addObserver
(
this
XPCOM_SHUTDOWN_OBSERVER_TOPIC
false
)
;
}
uninit
:
function
(
)
{
debug
(
"
uninit
(
)
"
)
;
this
.
_libc
.
handler
.
close
(
)
;
Services
.
obs
.
removeObserver
(
this
XPCOM_SHUTDOWN_OBSERVER_TOPIC
)
;
}
_checkLibcUtils
:
function
(
)
{
debug
(
"
_checkLibcUtils
"
)
;
if
(
!
this
.
_libcutils
)
{
log
(
"
No
proper
libcutils
binding
aborting
.
"
)
;
throw
Cr
.
NS_ERROR_NO_INTERFACE
;
}
return
true
;
}
observe
:
function
(
aSubject
aTopic
aData
)
{
debug
(
"
observe
(
)
"
)
;
switch
(
aTopic
)
{
case
XPCOM_SHUTDOWN_OBSERVER_TOPIC
:
this
.
uninit
(
)
;
break
;
default
:
log
(
"
Wrong
observer
topic
:
"
+
aTopic
)
;
break
;
}
}
start
:
function
(
)
{
debug
(
"
start
(
)
"
)
;
return
this
.
_enforceChecksumValidity
(
)
.
then
(
(
)
=
>
{
return
this
.
_formatIfOemUnlockEnabled
(
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
true
)
;
}
)
}
)
.
catch
(
ex
=
>
{
return
Promise
.
reject
(
ex
)
;
}
)
;
}
_computeDigest
:
function
(
isStoredDigestReturned
)
{
debug
(
"
_computeDigest
(
)
"
)
;
let
digest
=
{
calculated
:
"
"
stored
:
"
"
}
;
let
partition
;
debug
(
"
_computeDigest
:
_dataBlockFile
=
"
+
this
.
_dataBlockFile
)
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
existing
:
true
append
:
false
read
:
true
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
read
(
DIGEST_SIZE_BYTES
)
;
}
)
.
then
(
digestDataRead
=
>
{
if
(
isStoredDigestReturned
=
=
=
true
)
{
debug
(
"
_computeDigest
:
get
stored
digest
from
the
partition
"
)
;
digest
.
stored
=
arr2bstr
(
digestDataRead
)
;
}
return
partition
.
read
(
)
;
}
)
.
then
(
data
=
>
{
let
hasher
=
Cc
[
"
mozilla
.
org
/
security
/
hash
;
1
"
]
.
createInstance
(
Ci
.
nsICryptoHash
)
;
hasher
.
init
(
hasher
.
SHA256
)
;
hasher
.
update
(
data
data
.
byteLength
)
;
digest
.
calculated
=
hasher
.
finish
(
false
)
;
debug
(
"
_computeDigest
(
)
:
Digest
=
"
+
toHexString
(
digest
.
calculated
)
+
"
(
"
+
digest
.
calculated
.
length
+
"
)
"
)
;
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
digest
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
_computeDigest
(
)
:
Failed
to
read
partition
:
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
_getBlockDeviceSize
:
function
(
)
{
debug
(
"
_getBlockDeviceSize
(
)
"
)
;
if
(
this
.
_testing
=
=
=
true
)
{
debug
(
"
_getBlockDeviceSize
:
No
real
block
device
size
in
testing
mode
!
.
Returning
1024
.
"
)
;
return
1024
;
}
if
(
AppConstants
.
platform
!
=
"
gonk
"
)
{
log
(
"
_getBlockDeviceSize
:
ERROR
:
This
feature
is
only
supported
in
Gonk
!
"
)
;
return
-
1
;
}
const
O_READONLY
=
0
;
const
O_NONBLOCK
=
1
<
<
11
;
const
BLKGETSIZE64_32_BITS
=
0x80041272
;
const
BLKGETSIZE64_64_BITS
=
0x80081272
;
const
ENOTTY
=
25
;
debug
(
"
_getBlockDeviceSize
:
_dataBlockFile
=
"
+
this
.
_dataBlockFile
)
;
let
fd
=
this
.
_libc
.
open
(
this
.
_dataBlockFile
O_READONLY
|
O_NONBLOCK
)
;
if
(
fd
<
0
)
{
log
(
"
_getBlockDeviceSize
:
couldn
'
t
open
partition
!
:
errno
=
"
+
this
.
ctypes
.
errno
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
let
size
=
new
this
.
ctypes
.
unsigned_long
(
)
;
let
sizeAddress
=
size
.
address
(
)
;
let
ret
=
this
.
_libc
.
ioctl
(
fd
BLKGETSIZE64_32_BITS
sizeAddress
)
;
if
(
ret
<
0
)
{
if
(
this
.
ctypes
.
errno
=
=
=
ENOTTY
)
{
log
(
"
_getBlockDeviceSize
:
errno
is
ENOTTY
falling
back
to
64
bit
version
of
BLKGETSIZE64
.
.
.
"
)
;
ret
=
this
.
_libc
.
ioctl
(
fd
BLKGETSIZE64_64_BITS
sizeAddress
)
;
if
(
ret
<
0
)
{
this
.
_libc
.
close
(
fd
)
;
log
(
"
_getBlockDeviceSize
:
BLKGETSIZE64
failed
again
!
.
errno
=
"
+
this
.
ctypes
.
errno
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
}
else
{
this
.
_libc
.
close
(
fd
)
;
log
(
"
_getBlockDeviceSize
:
couldn
'
t
get
block
device
size
!
:
errno
=
"
+
this
.
ctypes
.
errno
)
;
throw
Cr
.
NS_ERROR_FAILURE
;
}
}
this
.
_libc
.
close
(
fd
)
;
debug
(
"
_getBlockDeviceSize
:
size
=
"
+
size
.
value
)
;
return
size
.
value
;
}
_doSetOemUnlockEnabled
:
function
(
isSetOemUnlockEnabled
)
{
debug
(
"
_doSetOemUnlockEnabled
(
)
"
)
;
let
partition
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
existing
:
true
append
:
false
write
:
true
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
setPosition
(
this
.
_getBlockDeviceSize
(
)
-
OEM_UNLOCK_ENABLED_BYTES
OS
.
File
.
POS_START
)
;
}
)
.
then
(
(
)
=
>
{
return
partition
.
write
(
new
Uint8Array
(
[
isSetOemUnlockEnabled
=
=
=
true
?
1
:
0
]
)
)
;
}
)
.
then
(
bytesWrittenLength
=
>
{
if
(
bytesWrittenLength
!
=
1
)
{
log
(
"
_doSetOemUnlockEnabled
:
Error
writting
OEM
Unlock
Enabled
byte
!
"
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
let
oemUnlockByte
=
(
isSetOemUnlockEnabled
=
=
=
true
?
"
1
"
:
"
0
"
)
;
debug
(
"
_doSetOemUnlockEnabled
:
OEM
unlock
enabled
written
to
"
+
oemUnlockByte
)
;
this
.
_libcutils
.
property_set
(
OEM_UNLOCK_PROPERTY
oemUnlockByte
)
;
return
Promise
.
resolve
(
)
;
}
)
.
catch
(
ex
=
>
{
return
Promise
.
reject
(
ex
)
;
}
)
;
}
_computeAndWriteDigest
:
function
(
)
{
debug
(
"
_computeAndWriteDigest
(
)
"
)
;
let
digest
;
let
partition
;
return
this
.
_computeDigest
(
)
.
then
(
_digest
=
>
{
digest
=
_digest
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
write
:
true
existing
:
true
append
:
false
}
)
;
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
setPosition
(
DIGEST_OFFSET
OS
.
File
.
POS_START
)
;
}
)
.
then
(
(
)
=
>
{
return
partition
.
write
(
new
Uint8Array
(
Array
.
from
(
digest
.
calculated
(
c
i
)
=
>
digest
.
calculated
.
charCodeAt
(
i
)
)
)
)
;
}
)
.
then
(
bytesWrittenLength
=
>
{
if
(
bytesWrittenLength
!
=
DIGEST_SIZE_BYTES
)
{
log
(
"
_computeAndWriteDigest
:
Error
writting
digest
to
partition
!
.
Expected
:
"
+
DIGEST_SIZE_BYTES
+
"
Written
:
"
+
bytesWrittenLength
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
debug
(
"
_computeAndWriteDigest
:
digest
written
to
partition
"
)
;
return
Promise
.
resolve
(
true
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
_computeAndWriteDigest
:
Couldn
'
t
write
digest
in
the
persistent
partion
.
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
_formatIfOemUnlockEnabled
:
function
(
)
{
debug
(
"
_formatIfOemUnlockEnabled
(
)
"
)
;
return
this
.
getOemUnlockEnabled
(
)
.
then
(
enabled
=
>
{
this
.
_libcutils
.
property_set
(
OEM_UNLOCK_PROPERTY
(
enabled
=
=
=
true
?
"
1
"
:
"
0
"
)
)
;
if
(
enabled
=
=
=
true
)
{
return
this
.
_formatPartition
(
true
)
;
}
return
Promise
.
resolve
(
false
)
;
}
)
.
then
(
result
=
>
{
if
(
result
=
=
=
false
)
{
return
Promise
.
resolve
(
false
)
;
}
else
{
return
Promise
.
resolve
(
true
)
;
}
}
)
.
catch
(
ex
=
>
{
log
(
"
_formatIfOemUnlockEnabled
:
An
error
ocurred
!
.
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
_formatPartition
:
function
(
isSetOemUnlockEnabled
)
{
debug
(
"
_formatPartition
(
)
"
)
;
let
partition
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
write
:
true
existing
:
true
append
:
false
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
write
(
new
Uint8Array
(
DIGEST_SIZE_BYTES
)
)
;
}
)
.
then
(
bytesWrittenLength
=
>
{
if
(
bytesWrittenLength
!
=
DIGEST_SIZE_BYTES
)
{
log
(
"
_formatPartition
Error
writting
zero
-
digest
!
.
Expected
:
"
+
DIGEST_SIZE_BYTES
+
"
Written
:
"
+
bytesWrittenLength
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
write
(
new
Uint32Array
(
[
PARTITION_MAGIC
]
)
)
;
}
)
.
then
(
bytesWrittenLength
=
>
{
if
(
bytesWrittenLength
!
=
PARTITION_MAGIC_SIZE_BYTES
)
{
log
(
"
_formatPartition
Error
writting
magic
number
!
.
Expected
:
"
+
PARTITION_MAGIC_SIZE_BYTES
+
"
Written
:
"
+
bytesWrittenLength
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
write
(
new
Uint8Array
(
DATA_SIZE_BYTES
)
)
;
}
)
.
then
(
bytesWrittenLength
=
>
{
if
(
bytesWrittenLength
!
=
DATA_SIZE_BYTES
)
{
log
(
"
_formatPartition
Error
writting
data
size
!
.
Expected
:
"
+
DATA_SIZE_BYTES
+
"
Written
:
"
+
bytesWrittenLength
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
return
this
.
_doSetOemUnlockEnabled
(
isSetOemUnlockEnabled
)
;
}
)
.
then
(
(
)
=
>
{
return
this
.
_computeAndWriteDigest
(
)
;
}
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
_formatPartition
:
Failed
to
format
block
device
!
:
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
_enforceChecksumValidity
:
function
(
)
{
debug
(
"
_enforceChecksumValidity
"
)
;
return
this
.
_computeDigest
(
true
)
.
then
(
digest
=
>
{
if
(
digest
.
stored
!
=
digest
.
calculated
)
{
log
(
"
_enforceChecksumValidity
:
Validation
failed
!
Stored
digest
:
"
+
toHexString
(
digest
.
stored
)
+
"
is
not
the
same
as
the
calculated
one
:
"
+
toHexString
(
digest
.
calculated
)
)
;
return
Promise
.
reject
(
)
;
}
debug
(
"
_enforceChecksumValidity
:
Digest
computation
succeed
.
"
)
;
return
Promise
.
resolve
(
true
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
_enforceChecksumValidity
:
Digest
computation
failed
:
ex
=
"
+
ex
)
;
log
(
"
_enforceChecksumValidity
:
Formatting
FRP
partition
.
.
.
"
)
;
return
this
.
_formatPartition
(
false
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
false
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
_enforceChecksumValidity
:
Error
ocurred
while
formating
the
partition
!
:
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
)
;
}
read
:
function
(
)
{
debug
(
"
read
(
)
"
)
;
let
partition
;
let
bytes
;
let
dataSize
;
return
this
.
getDataFieldSize
(
)
.
then
(
_dataSize
=
>
{
dataSize
=
_dataSize
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
read
:
true
existing
:
true
append
:
false
}
)
;
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
setPosition
(
DIGEST_SIZE_BYTES
+
HEADER_SIZE_BYTES
OS
.
File
.
POS_START
)
;
}
)
.
then
(
(
)
=
>
{
return
partition
.
read
(
dataSize
)
;
}
)
.
then
(
_bytes
=
>
{
bytes
=
_bytes
;
if
(
bytes
.
byteLength
<
dataSize
)
{
log
(
"
read
:
Failed
to
read
entire
data
block
.
Bytes
read
:
"
+
bytes
.
byteLength
+
"
/
"
+
dataSize
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
bytes
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
read
:
Failed
to
read
entire
data
block
.
Exception
:
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
write
:
function
(
data
)
{
debug
(
"
write
(
)
"
)
;
let
maxBlockSize
=
this
.
_getBlockDeviceSize
(
)
-
(
DIGEST_SIZE_BYTES
+
HEADER_SIZE_BYTES
+
1
)
;
if
(
data
.
byteLength
>
maxBlockSize
)
{
log
(
"
write
:
Couldn
'
t
write
more
than
"
+
maxBlockSize
+
"
bytes
to
the
partition
.
"
+
maxBlockSize
+
"
bytes
given
.
"
)
;
return
Promise
.
reject
(
)
;
}
let
partition
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
write
:
true
existing
:
true
append
:
false
}
)
.
then
(
_partition
=
>
{
let
digest
=
new
Uint8Array
(
DIGEST_SIZE_BYTES
)
;
let
magic
=
new
Uint8Array
(
(
new
Uint32Array
(
[
PARTITION_MAGIC
]
)
)
.
buffer
)
;
let
dataLength
=
new
Uint8Array
(
(
new
Uint32Array
(
[
data
.
byteLength
]
)
)
.
buffer
)
;
let
bufferToWrite
=
new
Uint8Array
(
digest
.
byteLength
+
magic
.
byteLength
+
dataLength
.
byteLength
+
data
.
byteLength
)
;
let
offset
=
0
;
bufferToWrite
.
set
(
digest
offset
)
;
offset
+
=
digest
.
byteLength
;
bufferToWrite
.
set
(
magic
offset
)
;
offset
+
=
magic
.
byteLength
;
bufferToWrite
.
set
(
dataLength
offset
)
;
offset
+
=
dataLength
.
byteLength
;
bufferToWrite
.
set
(
data
offset
)
;
partition
=
_partition
;
return
partition
.
write
(
bufferToWrite
)
;
}
)
.
then
(
bytesWrittenLength
=
>
{
let
expectedWrittenLength
=
DIGEST_SIZE_BYTES
+
HEADER_SIZE_BYTES
+
data
.
byteLength
;
if
(
bytesWrittenLength
!
=
expectedWrittenLength
)
{
log
(
"
write
:
Error
writting
data
to
partition
!
:
Expected
:
"
+
expectedWrittenLength
+
"
Written
:
"
+
bytesWrittenLength
)
;
return
Promise
.
reject
(
)
;
}
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
return
this
.
_computeAndWriteDigest
(
)
;
}
)
.
then
(
couldComputeAndWriteDigest
=
>
{
if
(
couldComputeAndWriteDigest
=
=
=
true
)
{
return
Promise
.
resolve
(
data
.
byteLength
)
;
}
else
{
log
(
"
write
:
Failed
to
compute
and
write
the
digest
"
)
;
return
Promise
.
reject
(
)
;
}
}
)
.
catch
(
ex
=
>
{
log
(
"
write
:
Failed
to
write
to
the
persistent
partition
:
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
wipe
:
function
(
)
{
debug
(
"
wipe
(
)
"
)
;
if
(
this
.
_testing
=
=
=
true
)
{
log
(
"
wipe
:
No
wipe
(
)
funcionality
in
testing
mode
"
)
;
return
Promise
.
resolve
(
)
;
}
if
(
AppConstants
.
platform
!
=
"
gonk
"
)
{
log
(
"
wipe
:
ERROR
:
This
feature
is
only
supported
in
Gonk
!
"
)
;
return
Promise
.
reject
(
)
;
}
const
O_READONLY
=
0
;
const
O_RDWR
=
2
;
const
O_NONBLOCK
=
1
<
<
11
;
const
BLKSECDISCARD
=
0x127D
;
const
BLKDISCARD
=
0x1277
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
range
=
new
this
.
ctypes
.
unsigned_long
(
)
;
let
rangeAddress
=
range
.
address
(
)
;
let
blockDeviceLength
=
this
.
_getBlockDeviceSize
(
)
;
range
[
0
]
=
0
;
range
[
1
]
=
blockDeviceLength
;
if
(
range
[
1
]
=
=
=
0
)
{
log
(
"
wipe
:
Block
device
size
is
0
!
"
)
;
return
reject
(
)
;
}
let
fd
=
this
.
_libc
.
open
(
this
.
_dataBlockFile
O_RDWR
)
;
if
(
fd
<
0
)
{
log
(
"
wipe
:
ERROR
couldn
'
t
open
partition
!
:
error
=
"
+
this
.
ctypes
.
errno
)
;
return
reject
(
)
;
}
let
ret
=
this
.
_libc
.
ioctl
(
fd
BLKSECDISCARD
rangeAddress
)
;
if
(
ret
<
0
)
{
log
(
"
wipe
:
Something
went
wrong
secure
discarding
block
:
errno
:
"
+
this
.
ctypes
.
errno
+
"
:
Falling
back
to
non
-
secure
discarding
.
.
.
"
)
;
ret
=
this
.
_libc
.
ioctl
(
fd
BLKDISCARD
rangeAddress
)
;
if
(
ret
<
0
)
{
this
.
_libc
.
close
(
fd
)
;
log
(
"
wipe
:
CRITICAL
:
non
-
secure
discarding
failed
too
!
!
:
errno
:
"
+
this
.
ctypes
.
errno
)
;
return
reject
(
)
;
}
else
{
this
.
_libc
.
close
(
fd
)
;
log
(
"
wipe
:
non
-
secure
discard
used
and
succeed
"
)
;
return
resolve
(
)
;
}
}
this
.
_libc
.
close
(
fd
)
;
log
(
"
wipe
:
secure
discard
succeed
"
)
;
return
resolve
(
)
;
}
)
;
}
setOemUnlockEnabled
:
function
(
enabled
)
{
debug
(
"
setOemUnlockEnabled
(
)
"
)
;
return
this
.
_doSetOemUnlockEnabled
(
enabled
)
.
then
(
(
)
=
>
{
return
this
.
_computeAndWriteDigest
(
)
;
}
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
)
;
}
)
.
catch
(
ex
=
>
{
return
Promise
.
reject
(
ex
)
;
}
)
;
}
getOemUnlockEnabled
:
function
(
)
{
log
(
"
getOemUnlockEnabled
(
)
"
)
;
let
ret
=
false
;
let
partition
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
existing
:
true
append
:
false
read
:
true
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
setPosition
(
this
.
_getBlockDeviceSize
(
)
-
OEM_UNLOCK_ENABLED_BYTES
OS
.
File
.
POS_START
)
;
}
)
.
then
(
(
)
=
>
{
return
partition
.
read
(
OEM_UNLOCK_ENABLED_BYTES
)
;
}
)
.
then
(
data
=
>
{
debug
(
"
getOemUnlockEnabled
:
OEM
unlock
enabled
byte
=
'
"
+
data
[
0
]
+
"
'
"
)
;
ret
=
(
data
[
0
]
=
=
=
1
?
true
:
false
)
;
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
return
Promise
.
resolve
(
ret
)
;
}
)
.
catch
(
ex
=
>
{
log
(
"
getOemUnlockEnabled
:
Error
reading
OEM
unlock
enabled
byte
from
partition
:
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
getDataFieldSize
:
function
(
)
{
debug
(
"
getDataFieldSize
(
)
"
)
;
let
partition
let
dataLength
=
0
;
return
OS
.
File
.
open
(
this
.
_dataBlockFile
{
read
:
true
existing
:
true
append
:
false
}
)
.
then
(
_partition
=
>
{
partition
=
_partition
;
return
partition
.
setPosition
(
DIGEST_SIZE_BYTES
OS
.
File
.
POS_START
)
;
}
)
.
then
(
(
)
=
>
{
return
partition
.
read
(
PARTITION_MAGIC_SIZE_BYTES
)
;
}
)
.
then
(
_magic
=
>
{
let
magic
=
new
Uint32Array
(
_magic
.
buffer
)
[
0
]
;
if
(
magic
=
=
=
PARTITION_MAGIC
)
{
return
partition
.
read
(
PARTITION_MAGIC_SIZE_BYTES
)
;
}
else
{
log
(
"
getDataFieldSize
:
ERROR
:
Invalid
Magic
number
!
"
)
;
return
Promise
.
reject
(
)
;
}
}
)
.
then
(
_dataLength
=
>
{
if
(
_dataLength
)
{
dataLength
=
new
Uint32Array
(
_dataLength
.
buffer
)
[
0
]
;
}
return
partition
.
close
(
)
;
}
)
.
then
(
(
)
=
>
{
if
(
dataLength
&
&
dataLength
!
=
0
)
{
return
Promise
.
resolve
(
dataLength
)
;
}
else
{
return
Promise
.
reject
(
)
;
}
}
)
.
catch
(
ex
=
>
{
log
(
"
getDataFieldSize
:
Couldn
'
t
get
data
field
size
:
ex
=
"
+
ex
)
;
return
Promise
.
reject
(
ex
)
;
}
)
;
}
getMaximumDataBlockSize
:
function
(
)
{
debug
(
"
getMaximumDataBlockSize
(
)
"
)
;
return
new
Promise
(
(
resolve
reject
)
=
>
{
let
actualSize
=
this
.
_getBlockDeviceSize
(
)
-
HEADER_SIZE_BYTES
-
OEM_UNLOCK_ENABLED_BYTES
;
resolve
(
actualSize
<
=
MAX_DATA_BLOCK_SIZE
?
actualSize
:
MAX_DATA_BLOCK_SIZE
)
;
}
)
;
}
}
;
if
(
!
inParent
)
{
log
(
"
PersistentDataBlock
should
only
be
living
on
parent
side
.
"
)
;
throw
Cr
.
NS_ERROR_ABORT
;
}
else
{
this
.
PersistentDataBlock
.
init
(
)
;
}
