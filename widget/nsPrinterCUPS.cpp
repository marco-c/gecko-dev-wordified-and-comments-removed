#
include
"
nsPrinterCUPS
.
h
"
#
include
"
mozilla
/
GkRustUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsPaper
.
h
"
#
include
"
nsPrinterBase
.
h
"
#
include
"
nsPrintSettingsImpl
.
h
"
#
include
"
plstr
.
h
"
using
namespace
mozilla
;
static
constexpr
Array
<
const
char
*
const
1
>
requestedAttributes
{
"
cups
-
version
"
}
;
static
constexpr
double
kPointsPerHundredthMillimeter
=
72
.
0
/
2540
.
0
;
static
PaperInfo
MakePaperInfo
(
const
nsAString
&
aName
const
cups_size_t
&
aMedia
)
{
NS_ConvertUTF8toUTF16
paperId
(
aMedia
.
media
)
;
return
PaperInfo
(
paperId
aName
{
aMedia
.
width
*
kPointsPerHundredthMillimeter
aMedia
.
length
*
kPointsPerHundredthMillimeter
}
Some
(
gfx
:
:
MarginDouble
{
aMedia
.
top
*
kPointsPerHundredthMillimeter
aMedia
.
right
*
kPointsPerHundredthMillimeter
aMedia
.
bottom
*
kPointsPerHundredthMillimeter
aMedia
.
left
*
kPointsPerHundredthMillimeter
}
)
)
;
}
static
void
FetchCUPSVersionForPrinter
(
const
nsCUPSShim
&
aShim
const
cups_dest_t
*
const
aDest
uint64_t
&
aOutMajor
uint64_t
&
aOutMinor
uint64_t
&
aOutPatch
)
{
const
char
*
const
uri
=
aShim
.
cupsGetOption
(
"
printer
-
uri
-
supported
"
aDest
-
>
num_options
aDest
-
>
options
)
;
if
(
!
uri
)
{
return
;
}
ipp_t
*
const
ippRequest
=
aShim
.
ippNewRequest
(
IPP_OP_GET_PRINTER_ATTRIBUTES
)
;
aShim
.
ippAddString
(
ippRequest
IPP_TAG_OPERATION
IPP_TAG_URI
"
printer
-
uri
"
nullptr
uri
)
;
aShim
.
ippAddStrings
(
ippRequest
IPP_TAG_OPERATION
IPP_TAG_KEYWORD
"
requested
-
attributes
"
requestedAttributes
.
Length
nullptr
&
(
requestedAttributes
[
0
]
)
)
;
if
(
ipp_t
*
const
ippResponse
=
aShim
.
cupsDoRequest
(
CUPS_HTTP_DEFAULT
ippRequest
"
/
"
)
)
{
ipp_attribute_t
*
const
versionAttrib
=
aShim
.
ippFindAttribute
(
ippResponse
"
cups
-
version
"
IPP_TAG_TEXT
)
;
if
(
versionAttrib
&
&
aShim
.
ippGetCount
(
versionAttrib
)
=
=
1
)
{
const
char
*
versionString
=
aShim
.
ippGetString
(
versionAttrib
0
nullptr
)
;
MOZ_ASSERT
(
versionString
)
;
GkRustUtils
:
:
ParseSemVer
(
nsDependentCSubstring
{
MakeStringSpan
(
versionString
)
}
aOutMajor
aOutMinor
aOutPatch
)
;
}
aShim
.
ippDelete
(
ippResponse
)
;
}
}
nsPrinterCUPS
:
:
~
nsPrinterCUPS
(
)
{
auto
printerInfoLock
=
mPrinterInfoMutex
.
Lock
(
)
;
if
(
printerInfoLock
-
>
mPrinterInfo
)
{
mShim
.
cupsFreeDestInfo
(
printerInfoLock
-
>
mPrinterInfo
)
;
}
if
(
mPrinter
)
{
mShim
.
cupsFreeDests
(
1
mPrinter
)
;
mPrinter
=
nullptr
;
}
}
NS_IMETHODIMP
nsPrinterCUPS
:
:
GetName
(
nsAString
&
aName
)
{
GetPrinterName
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrinterCUPS
:
:
GetSystemName
(
nsAString
&
aName
)
{
CopyUTF8toUTF16
(
MakeStringSpan
(
mPrinter
-
>
name
)
aName
)
;
return
NS_OK
;
}
void
nsPrinterCUPS
:
:
GetPrinterName
(
nsAString
&
aName
)
const
{
if
(
mDisplayName
.
IsEmpty
(
)
)
{
aName
.
Truncate
(
)
;
CopyUTF8toUTF16
(
MakeStringSpan
(
mPrinter
-
>
name
)
aName
)
;
}
else
{
aName
=
mDisplayName
;
}
}
const
char
*
nsPrinterCUPS
:
:
LocalizeMediaName
(
http_t
&
aConnection
cups_size_t
&
aMedia
)
const
{
auto
printerInfoLock
=
mPrinterInfoMutex
.
Lock
(
)
;
TryEnsurePrinterInfo
(
*
printerInfoLock
)
;
cups_dinfo_t
*
const
printerInfo
=
printerInfoLock
-
>
mPrinterInfo
;
return
mShim
.
cupsLocalizeDestMedia
(
&
aConnection
mPrinter
printerInfo
CUPS_MEDIA_FLAGS_DEFAULT
&
aMedia
)
;
}
bool
nsPrinterCUPS
:
:
SupportsDuplex
(
)
const
{
return
Supports
(
CUPS_SIDES
CUPS_SIDES_TWO_SIDED_PORTRAIT
)
;
}
bool
nsPrinterCUPS
:
:
SupportsMonochrome
(
)
const
{
if
(
!
SupportsColor
(
)
)
{
return
true
;
}
return
StaticPrefs
:
:
print_cups_monochrome_enabled
(
)
;
}
bool
nsPrinterCUPS
:
:
SupportsColor
(
)
const
{
if
(
!
IsCUPSVersionAtLeast
(
2
2
0
)
)
{
return
true
;
}
return
Supports
(
CUPS_PRINT_COLOR_MODE
CUPS_PRINT_COLOR_MODE_AUTO
)
|
|
Supports
(
CUPS_PRINT_COLOR_MODE
CUPS_PRINT_COLOR_MODE_COLOR
)
|
|
!
Supports
(
CUPS_PRINT_COLOR_MODE
CUPS_PRINT_COLOR_MODE_MONOCHROME
)
;
}
bool
nsPrinterCUPS
:
:
SupportsCollation
(
)
const
{
const
char
*
const
value
=
mShim
.
cupsGetOption
(
"
printer
-
type
"
mPrinter
-
>
num_options
mPrinter
-
>
options
)
;
if
(
!
value
)
{
return
false
;
}
const
int
type
=
atoi
(
value
)
;
return
type
&
CUPS_PRINTER_COLLATE
;
}
nsPrinterBase
:
:
PrinterInfo
nsPrinterCUPS
:
:
CreatePrinterInfo
(
)
const
{
Connection
connection
{
mShim
}
;
return
PrinterInfo
{
PaperList
(
connection
)
DefaultSettings
(
connection
)
}
;
}
bool
nsPrinterCUPS
:
:
Supports
(
const
char
*
aOption
const
char
*
aValue
)
const
{
auto
printerInfoLock
=
mPrinterInfoMutex
.
Lock
(
)
;
TryEnsurePrinterInfo
(
*
printerInfoLock
)
;
cups_dinfo_t
*
const
printerInfo
=
printerInfoLock
-
>
mPrinterInfo
;
return
mShim
.
cupsCheckDestSupported
(
CUPS_HTTP_DEFAULT
mPrinter
printerInfo
aOption
aValue
)
;
}
bool
nsPrinterCUPS
:
:
IsCUPSVersionAtLeast
(
uint64_t
aCUPSMajor
uint64_t
aCUPSMinor
uint64_t
aCUPSPatch
)
const
{
auto
printerInfoLock
=
mPrinterInfoMutex
.
Lock
(
)
;
TryEnsurePrinterInfo
(
*
printerInfoLock
)
;
if
(
printerInfoLock
-
>
mCUPSMajor
>
aCUPSMajor
)
{
return
true
;
}
if
(
printerInfoLock
-
>
mCUPSMajor
<
aCUPSMajor
)
{
return
false
;
}
if
(
printerInfoLock
-
>
mCUPSMinor
>
aCUPSMinor
)
{
return
true
;
}
if
(
printerInfoLock
-
>
mCUPSMinor
<
aCUPSMinor
)
{
return
false
;
}
return
aCUPSPatch
<
=
printerInfoLock
-
>
mCUPSPatch
;
}
http_t
*
nsPrinterCUPS
:
:
Connection
:
:
GetConnection
(
cups_dest_t
*
aDest
)
{
if
(
mWasInited
)
{
return
mConnection
;
}
mWasInited
=
true
;
http_t
*
const
connection
=
mShim
.
cupsConnectDest
(
aDest
CUPS_DEST_FLAGS_NONE
5000
nullptr
nullptr
0
nullptr
nullptr
)
;
if
(
connection
)
{
mConnection
=
connection
;
}
return
mConnection
;
}
nsPrinterCUPS
:
:
Connection
:
:
~
Connection
(
)
{
if
(
mWasInited
&
&
mConnection
)
{
mShim
.
httpClose
(
mConnection
)
;
}
}
PrintSettingsInitializer
nsPrinterCUPS
:
:
DefaultSettings
(
Connection
&
aConnection
)
const
{
nsString
printerName
;
GetPrinterName
(
printerName
)
;
auto
printerInfoLock
=
mPrinterInfoMutex
.
Lock
(
)
;
TryEnsurePrinterInfo
(
*
printerInfoLock
)
;
cups_dinfo_t
*
const
printerInfo
=
printerInfoLock
-
>
mPrinterInfo
;
cups_size_t
media
;
#
ifdef
XP_MACOSX
bool
hasDefaultMedia
=
mShim
.
cupsGetDestMediaDefault
(
CUPS_HTTP_DEFAULT
mPrinter
printerInfo
CUPS_MEDIA_FLAGS_DEFAULT
&
media
)
;
#
else
ipp_attribute_t
*
defaultMediaIPP
=
mShim
.
cupsFindDestDefault
(
CUPS_HTTP_DEFAULT
mPrinter
printerInfo
"
media
"
)
;
const
char
*
defaultMediaName
=
mShim
.
ippGetString
(
defaultMediaIPP
0
nullptr
)
;
bool
hasDefaultMedia
=
mShim
.
cupsGetDestMediaByName
(
CUPS_HTTP_DEFAULT
mPrinter
printerInfo
defaultMediaName
CUPS_MEDIA_FLAGS_DEFAULT
&
media
)
;
#
endif
if
(
!
hasDefaultMedia
)
{
return
PrintSettingsInitializer
{
std
:
:
move
(
printerName
)
PaperInfo
(
)
SupportsColor
(
)
}
;
}
const
gfx
:
:
SizeDouble
sizeDouble
{
media
.
width
*
kPointsPerHundredthMillimeter
media
.
length
*
kPointsPerHundredthMillimeter
}
;
if
(
const
PaperInfo
*
const
paperInfo
=
FindCommonPaperSize
(
sizeDouble
)
)
{
return
PrintSettingsInitializer
{
std
:
:
move
(
printerName
)
MakePaperInfo
(
paperInfo
-
>
mName
media
)
SupportsColor
(
)
}
;
}
http_t
*
const
connection
=
aConnection
.
GetConnection
(
mPrinter
)
;
NS_ConvertUTF8toUTF16
localizedName
{
connection
?
LocalizeMediaName
(
*
connection
media
)
:
"
"
}
;
return
PrintSettingsInitializer
{
std
:
:
move
(
printerName
)
MakePaperInfo
(
localizedName
media
)
SupportsColor
(
)
}
;
}
nsTArray
<
mozilla
:
:
PaperInfo
>
nsPrinterCUPS
:
:
PaperList
(
Connection
&
aConnection
)
const
{
http_t
*
const
connection
=
aConnection
.
GetConnection
(
mPrinter
)
;
auto
printerInfoLock
=
mPrinterInfoMutex
.
Lock
(
)
;
TryEnsurePrinterInfo
(
*
printerInfoLock
connection
)
;
cups_dinfo_t
*
const
printerInfo
=
printerInfoLock
-
>
mPrinterInfo
;
if
(
!
printerInfo
)
{
return
{
}
;
}
const
int
paperCount
=
mShim
.
cupsGetDestMediaCount
(
connection
mPrinter
printerInfo
CUPS_MEDIA_FLAGS_DEFAULT
)
;
nsTArray
<
PaperInfo
>
paperList
;
nsTHashtable
<
nsCharPtrHashKey
>
paperSet
(
std
:
:
max
(
paperCount
0
)
)
;
paperList
.
SetCapacity
(
paperCount
)
;
for
(
int
i
=
0
;
i
<
paperCount
;
+
+
i
)
{
cups_size_t
media
;
const
int
getInfoSucceeded
=
mShim
.
cupsGetDestMediaByIndex
(
connection
mPrinter
printerInfo
i
CUPS_MEDIA_FLAGS_DEFAULT
&
media
)
;
if
(
!
getInfoSucceeded
|
|
!
paperSet
.
EnsureInserted
(
media
.
media
)
)
{
continue
;
}
const
gfx
:
:
SizeDouble
sizeDouble
{
media
.
width
*
kPointsPerHundredthMillimeter
media
.
length
*
kPointsPerHundredthMillimeter
}
;
if
(
const
PaperInfo
*
const
paperInfo
=
FindCommonPaperSize
(
sizeDouble
)
)
{
paperList
.
AppendElement
(
MakePaperInfo
(
paperInfo
-
>
mName
media
)
)
;
}
else
{
const
char
*
const
mediaName
=
connection
?
LocalizeMediaName
(
*
connection
media
)
:
media
.
media
;
paperList
.
AppendElement
(
MakePaperInfo
(
NS_ConvertUTF8toUTF16
(
mediaName
)
media
)
)
;
}
}
return
paperList
;
}
void
nsPrinterCUPS
:
:
TryEnsurePrinterInfo
(
CUPSPrinterInfo
&
aInOutPrinterInfo
http_t
*
const
aConnection
)
const
{
if
(
aInOutPrinterInfo
.
mPrinterInfo
)
{
return
;
}
if
(
aConnection
=
=
CUPS_HTTP_DEFAULT
)
{
if
(
aInOutPrinterInfo
.
mTriedInitWithDefault
)
{
return
;
}
aInOutPrinterInfo
.
mTriedInitWithDefault
=
true
;
}
else
{
if
(
aInOutPrinterInfo
.
mTriedInitWithConnection
)
{
return
;
}
aInOutPrinterInfo
.
mTriedInitWithConnection
=
true
;
}
aInOutPrinterInfo
.
mPrinterInfo
=
mShim
.
cupsCopyDestInfo
(
aConnection
mPrinter
)
;
FetchCUPSVersionForPrinter
(
mShim
mPrinter
aInOutPrinterInfo
.
mCUPSMajor
aInOutPrinterInfo
.
mCUPSMinor
aInOutPrinterInfo
.
mCUPSPatch
)
;
}
