#
include
"
nsPrinterCUPS
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
GkRustUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsPaper
.
h
"
#
include
"
nsPrinterBase
.
h
"
#
include
"
nsPrintSettingsImpl
.
h
"
#
include
"
plstr
.
h
"
using
namespace
mozilla
;
using
MarginDouble
=
mozilla
:
:
gfx
:
:
MarginDouble
;
static
constexpr
Array
<
const
char
*
const
1
>
requestedAttributes
{
"
cups
-
version
"
}
;
static
constexpr
double
kPointsPerHundredthMillimeter
=
72
.
0
/
2540
.
0
;
static
PaperInfo
MakePaperInfo
(
const
nsAString
&
aName
const
cups_size_t
&
aMedia
)
{
NS_ConvertUTF8toUTF16
paperId
(
aMedia
.
media
)
;
return
PaperInfo
(
paperId
aName
{
aMedia
.
width
*
kPointsPerHundredthMillimeter
aMedia
.
length
*
kPointsPerHundredthMillimeter
}
Some
(
gfx
:
:
MarginDouble
{
aMedia
.
top
*
kPointsPerHundredthMillimeter
aMedia
.
right
*
kPointsPerHundredthMillimeter
aMedia
.
bottom
*
kPointsPerHundredthMillimeter
aMedia
.
left
*
kPointsPerHundredthMillimeter
}
)
)
;
}
static
void
FetchCUPSVersionForPrinter
(
const
nsCUPSShim
&
aShim
const
cups_dest_t
*
const
aDest
uint64_t
&
aOutMajor
uint64_t
&
aOutMinor
uint64_t
&
aOutPatch
)
{
const
char
*
const
uri
=
aShim
.
cupsGetOption
(
"
printer
-
uri
-
supported
"
aDest
-
>
num_options
aDest
-
>
options
)
;
if
(
!
uri
)
{
return
;
}
ipp_t
*
const
ippRequest
=
aShim
.
ippNewRequest
(
IPP_OP_GET_PRINTER_ATTRIBUTES
)
;
aShim
.
ippAddString
(
ippRequest
IPP_TAG_OPERATION
IPP_TAG_URI
"
printer
-
uri
"
nullptr
uri
)
;
aShim
.
ippAddStrings
(
ippRequest
IPP_TAG_OPERATION
IPP_TAG_KEYWORD
"
requested
-
attributes
"
requestedAttributes
.
Length
nullptr
&
(
requestedAttributes
[
0
]
)
)
;
if
(
ipp_t
*
const
ippResponse
=
aShim
.
cupsDoRequest
(
CUPS_HTTP_DEFAULT
ippRequest
"
/
"
)
)
{
ipp_attribute_t
*
const
versionAttrib
=
aShim
.
ippFindAttribute
(
ippResponse
"
cups
-
version
"
IPP_TAG_TEXT
)
;
if
(
versionAttrib
&
&
aShim
.
ippGetCount
(
versionAttrib
)
=
=
1
)
{
const
char
*
versionString
=
aShim
.
ippGetString
(
versionAttrib
0
nullptr
)
;
MOZ_ASSERT
(
versionString
)
;
GkRustUtils
:
:
ParseSemVer
(
nsDependentCSubstring
{
MakeStringSpan
(
versionString
)
}
aOutMajor
aOutMinor
aOutPatch
)
;
}
aShim
.
ippDelete
(
ippResponse
)
;
}
}
nsPrinterCUPS
:
:
~
nsPrinterCUPS
(
)
{
PrinterInfoLock
lock
=
mPrinterInfoMutex
.
Lock
(
)
;
if
(
lock
-
>
mPrinterInfo
)
{
mShim
.
cupsFreeDestInfo
(
lock
-
>
mPrinterInfo
)
;
}
if
(
lock
-
>
mPrinter
)
{
mShim
.
cupsFreeDests
(
1
lock
-
>
mPrinter
)
;
}
}
NS_IMETHODIMP
nsPrinterCUPS
:
:
GetName
(
nsAString
&
aName
)
{
GetPrinterName
(
aName
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrinterCUPS
:
:
GetSystemName
(
nsAString
&
aName
)
{
PrinterInfoLock
lock
=
mPrinterInfoMutex
.
Lock
(
)
;
CopyUTF8toUTF16
(
MakeStringSpan
(
lock
-
>
mPrinter
-
>
name
)
aName
)
;
return
NS_OK
;
}
void
nsPrinterCUPS
:
:
GetPrinterName
(
nsAString
&
aName
)
const
{
if
(
mDisplayName
.
IsEmpty
(
)
)
{
aName
.
Truncate
(
)
;
PrinterInfoLock
lock
=
mPrinterInfoMutex
.
Lock
(
)
;
CopyUTF8toUTF16
(
MakeStringSpan
(
lock
-
>
mPrinter
-
>
name
)
aName
)
;
}
else
{
aName
=
mDisplayName
;
}
}
const
char
*
nsPrinterCUPS
:
:
LocalizeMediaName
(
http_t
&
aConnection
cups_size_t
&
aMedia
)
const
{
if
(
!
mShim
.
cupsLocalizeDestMedia
)
{
return
aMedia
.
media
;
}
PrinterInfoLock
lock
=
TryEnsurePrinterInfo
(
)
;
return
mShim
.
cupsLocalizeDestMedia
(
&
aConnection
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
CUPS_MEDIA_FLAGS_DEFAULT
&
aMedia
)
;
}
bool
nsPrinterCUPS
:
:
SupportsDuplex
(
)
const
{
return
Supports
(
CUPS_SIDES
CUPS_SIDES_TWO_SIDED_PORTRAIT
)
;
}
bool
nsPrinterCUPS
:
:
SupportsMonochrome
(
)
const
{
if
(
!
SupportsColor
(
)
)
{
return
true
;
}
return
StaticPrefs
:
:
print_cups_monochrome_enabled
(
)
;
}
bool
nsPrinterCUPS
:
:
SupportsColor
(
)
const
{
if
(
!
IsCUPSVersionAtLeast
(
2
2
0
)
)
{
return
true
;
}
return
Supports
(
CUPS_PRINT_COLOR_MODE
CUPS_PRINT_COLOR_MODE_AUTO
)
|
|
Supports
(
CUPS_PRINT_COLOR_MODE
CUPS_PRINT_COLOR_MODE_COLOR
)
|
|
!
Supports
(
CUPS_PRINT_COLOR_MODE
CUPS_PRINT_COLOR_MODE_MONOCHROME
)
;
}
bool
nsPrinterCUPS
:
:
SupportsCollation
(
)
const
{
PrinterInfoLock
lock
=
mPrinterInfoMutex
.
Lock
(
)
;
const
char
*
const
value
=
FindCUPSOption
(
lock
"
printer
-
type
"
)
;
if
(
!
value
)
{
return
false
;
}
const
int
type
=
atoi
(
value
)
;
return
type
&
CUPS_PRINTER_COLLATE
;
}
nsPrinterBase
:
:
PrinterInfo
nsPrinterCUPS
:
:
CreatePrinterInfo
(
)
const
{
Connection
connection
{
mShim
}
;
return
PrinterInfo
{
PaperList
(
connection
)
DefaultSettings
(
connection
)
}
;
}
bool
nsPrinterCUPS
:
:
Supports
(
const
char
*
aOption
const
char
*
aValue
)
const
{
PrinterInfoLock
lock
=
TryEnsurePrinterInfo
(
)
;
return
mShim
.
cupsCheckDestSupported
(
CUPS_HTTP_DEFAULT
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
aOption
aValue
)
;
}
bool
nsPrinterCUPS
:
:
IsCUPSVersionAtLeast
(
uint64_t
aCUPSMajor
uint64_t
aCUPSMinor
uint64_t
aCUPSPatch
)
const
{
PrinterInfoLock
lock
=
TryEnsurePrinterInfo
(
)
;
if
(
lock
-
>
mCUPSMajor
>
aCUPSMajor
)
{
return
true
;
}
if
(
lock
-
>
mCUPSMajor
<
aCUPSMajor
)
{
return
false
;
}
if
(
lock
-
>
mCUPSMinor
>
aCUPSMinor
)
{
return
true
;
}
if
(
lock
-
>
mCUPSMinor
<
aCUPSMinor
)
{
return
false
;
}
return
aCUPSPatch
<
=
lock
-
>
mCUPSPatch
;
}
http_t
*
nsPrinterCUPS
:
:
Connection
:
:
GetConnection
(
cups_dest_t
*
aDest
)
{
if
(
mWasInited
)
{
return
mConnection
;
}
mWasInited
=
true
;
http_t
*
const
connection
=
mShim
.
cupsConnectDest
(
aDest
CUPS_DEST_FLAGS_NONE
5000
nullptr
nullptr
0
nullptr
nullptr
)
;
if
(
connection
)
{
mConnection
=
connection
;
}
return
mConnection
;
}
nsPrinterCUPS
:
:
Connection
:
:
~
Connection
(
)
{
if
(
mWasInited
&
&
mConnection
)
{
mShim
.
httpClose
(
mConnection
)
;
}
}
PrintSettingsInitializer
nsPrinterCUPS
:
:
DefaultSettings
(
Connection
&
aConnection
)
const
{
nsString
printerName
;
GetPrinterName
(
printerName
)
;
PrinterInfoLock
lock
=
TryEnsurePrinterInfo
(
)
;
cups_size_t
media
;
bool
hasDefaultMedia
=
false
;
#
ifdef
XP_MACOSX
hasDefaultMedia
=
mShim
.
cupsGetDestMediaDefault
(
CUPS_HTTP_DEFAULT
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
CUPS_MEDIA_FLAGS_DEFAULT
&
media
)
;
#
else
{
ipp_attribute_t
*
defaultMediaIPP
=
mShim
.
cupsFindDestDefault
?
mShim
.
cupsFindDestDefault
(
CUPS_HTTP_DEFAULT
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
"
media
"
)
:
nullptr
;
const
char
*
defaultMediaName
=
defaultMediaIPP
?
mShim
.
ippGetString
(
defaultMediaIPP
0
nullptr
)
:
nullptr
;
hasDefaultMedia
=
defaultMediaName
&
&
mShim
.
cupsGetDestMediaByName
(
CUPS_HTTP_DEFAULT
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
defaultMediaName
CUPS_MEDIA_FLAGS_DEFAULT
&
media
)
;
}
#
endif
if
(
!
hasDefaultMedia
)
{
return
PrintSettingsInitializer
{
std
:
:
move
(
printerName
)
PaperInfo
(
)
SupportsColor
(
)
}
;
}
const
gfx
:
:
SizeDouble
sizeDouble
{
media
.
width
*
kPointsPerHundredthMillimeter
media
.
length
*
kPointsPerHundredthMillimeter
}
;
if
(
const
PaperInfo
*
const
paperInfo
=
FindCommonPaperSize
(
sizeDouble
)
)
{
return
PrintSettingsInitializer
{
std
:
:
move
(
printerName
)
MakePaperInfo
(
paperInfo
-
>
mName
media
)
SupportsColor
(
)
}
;
}
http_t
*
const
connection
=
aConnection
.
GetConnection
(
lock
-
>
mPrinter
)
;
NS_ConvertUTF8toUTF16
localizedName
{
connection
?
LocalizeMediaName
(
*
connection
media
)
:
"
"
}
;
return
PrintSettingsInitializer
{
std
:
:
move
(
printerName
)
MakePaperInfo
(
localizedName
media
)
SupportsColor
(
)
}
;
}
nsTArray
<
mozilla
:
:
PaperInfo
>
nsPrinterCUPS
:
:
PaperList
(
Connection
&
aConnection
)
const
{
PrinterInfoLock
lock
=
mPrinterInfoMutex
.
Lock
(
)
;
http_t
*
const
connection
=
aConnection
.
GetConnection
(
lock
-
>
mPrinter
)
;
TryEnsurePrinterInfo
(
lock
connection
)
;
if
(
!
lock
-
>
mPrinterInfo
)
{
return
{
}
;
}
const
int
paperCount
=
mShim
.
cupsGetDestMediaCount
?
mShim
.
cupsGetDestMediaCount
(
connection
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
CUPS_MEDIA_FLAGS_DEFAULT
)
:
0
;
nsTArray
<
PaperInfo
>
paperList
;
nsTHashtable
<
nsCharPtrHashKey
>
paperSet
(
std
:
:
max
(
paperCount
0
)
)
;
paperList
.
SetCapacity
(
paperCount
)
;
for
(
int
i
=
0
;
i
<
paperCount
;
+
+
i
)
{
cups_size_t
media
;
const
int
getInfoSucceeded
=
mShim
.
cupsGetDestMediaByIndex
(
connection
lock
-
>
mPrinter
lock
-
>
mPrinterInfo
i
CUPS_MEDIA_FLAGS_DEFAULT
&
media
)
;
if
(
!
getInfoSucceeded
|
|
!
paperSet
.
EnsureInserted
(
media
.
media
)
)
{
continue
;
}
const
gfx
:
:
SizeDouble
sizeDouble
{
media
.
width
*
kPointsPerHundredthMillimeter
media
.
length
*
kPointsPerHundredthMillimeter
}
;
if
(
const
PaperInfo
*
const
paperInfo
=
FindCommonPaperSize
(
sizeDouble
)
)
{
paperList
.
AppendElement
(
MakePaperInfo
(
paperInfo
-
>
mName
media
)
)
;
}
else
{
const
char
*
const
mediaName
=
connection
?
LocalizeMediaName
(
*
connection
media
)
:
media
.
media
;
paperList
.
AppendElement
(
MakePaperInfo
(
NS_ConvertUTF8toUTF16
(
mediaName
)
media
)
)
;
}
}
return
paperList
;
}
void
nsPrinterCUPS
:
:
TryEnsurePrinterInfo
(
PrinterInfoLock
&
aLock
http_t
*
const
aConnection
)
const
{
if
(
aLock
-
>
mPrinterInfo
|
|
(
aConnection
=
=
CUPS_HTTP_DEFAULT
?
aLock
-
>
mTriedInitWithDefault
:
aLock
-
>
mTriedInitWithConnection
)
)
{
return
;
}
if
(
aConnection
=
=
CUPS_HTTP_DEFAULT
)
{
aLock
-
>
mTriedInitWithDefault
=
true
;
}
else
{
aLock
-
>
mTriedInitWithConnection
=
true
;
}
MOZ_ASSERT
(
aLock
-
>
mPrinter
)
;
if
(
aConnection
&
&
MOZ_LIKELY
(
mShim
.
httpGetAddress
&
&
mShim
.
httpAddrPort
)
)
{
const
char
*
const
serverNameBytes
=
mShim
.
cupsServer
(
)
;
if
(
MOZ_LIKELY
(
serverNameBytes
)
)
{
const
nsDependentCString
serverName
{
serverNameBytes
}
;
const
size_t
hostnameMemLength
=
serverName
.
Length
(
)
+
2
;
auto
hostnameMem
=
MakeUnique
<
char
[
]
>
(
hostnameMemLength
)
;
const
char
*
const
hostnameBytes
=
mShim
.
httpGetHostname
(
aConnection
hostnameMem
.
get
(
)
hostnameMemLength
)
;
if
(
MOZ_LIKELY
(
hostnameBytes
)
)
{
const
nsDependentCString
hostname
{
hostnameBytes
}
;
const
bool
namesMightNotMatch
=
hostname
!
=
serverName
|
|
hostname
=
=
"
localhost
"
;
const
bool
portsDiffer
=
mShim
.
httpAddrPort
(
mShim
.
httpGetAddress
(
aConnection
)
)
!
=
mShim
.
ippPort
(
)
;
const
bool
cupsDestDeviceFlag
=
(
namesMightNotMatch
&
&
serverName
[
0
]
!
=
'
/
'
)
|
|
portsDiffer
;
if
(
(
cupsDestDeviceFlag
|
|
!
FindCUPSOption
(
aLock
"
printer
-
uri
-
supported
"
)
)
&
&
!
FindCUPSOption
(
aLock
"
device
-
uri
"
)
)
{
return
;
}
}
}
}
aLock
-
>
mPrinterInfo
=
mShim
.
cupsCopyDestInfo
(
aConnection
aLock
-
>
mPrinter
)
;
FetchCUPSVersionForPrinter
(
mShim
aLock
-
>
mPrinter
aLock
-
>
mCUPSMajor
aLock
-
>
mCUPSMinor
aLock
-
>
mCUPSPatch
)
;
}
void
nsPrinterCUPS
:
:
ForEachExtraMonochromeSetting
(
FunctionRef
<
void
(
const
nsACString
&
const
nsACString
&
)
>
aCallback
)
{
nsAutoCString
pref
;
Preferences
:
:
GetCString
(
"
print
.
cups
.
monochrome
.
extra_settings
"
pref
)
;
if
(
pref
.
IsEmpty
(
)
)
{
return
;
}
for
(
const
auto
&
pair
:
pref
.
Split
(
'
'
)
)
{
auto
splitter
=
pair
.
Split
(
'
:
'
)
;
auto
end
=
splitter
.
end
(
)
;
auto
key
=
splitter
.
begin
(
)
;
if
(
key
=
=
end
)
{
continue
;
}
auto
value
=
+
+
splitter
.
begin
(
)
;
if
(
value
=
=
end
)
{
continue
;
}
aCallback
(
*
key
*
value
)
;
}
}
