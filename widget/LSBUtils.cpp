#
include
"
LSBUtils
.
h
"
#
include
<
fstream
>
#
include
<
string
>
#
include
<
string_view
>
#
include
<
unistd
.
h
>
#
include
"
base
/
process_util
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
ipc
/
LaunchError
.
h
"
namespace
mozilla
:
:
widget
:
:
lsb
{
static
const
char
gLsbReleasePath
[
]
=
"
/
usr
/
bin
/
lsb_release
"
;
static
const
char
gEtcOsReleasePath
[
]
=
"
/
etc
/
os
-
release
"
;
static
const
char
gUsrOsReleasePath
[
]
=
"
/
usr
/
lib
/
os
-
release
"
;
bool
ExtractAndSetValue
(
nsACString
&
aContainer
std
:
:
string_view
&
aValue
)
{
if
(
aValue
.
size
(
)
>
1
&
&
(
aValue
.
front
(
)
=
=
'
"
'
|
|
aValue
.
front
(
)
=
=
'
\
'
'
)
)
{
aValue
=
aValue
.
substr
(
1
aValue
.
size
(
)
-
2
)
;
}
aContainer
.
Assign
(
aValue
.
data
(
)
aValue
.
size
(
)
)
;
return
!
aValue
.
empty
(
)
;
}
bool
GetOSRelease
(
nsACString
&
aDistributor
nsACString
&
aDescription
nsACString
&
aRelease
nsACString
&
aCodename
)
{
std
:
:
ifstream
stream
(
gEtcOsReleasePath
)
;
if
(
stream
.
fail
(
)
)
{
stream
.
open
(
gUsrOsReleasePath
)
;
if
(
stream
.
fail
(
)
)
{
return
false
;
}
}
bool
seen_id
=
false
seen_pretty_name
=
false
seen_version_id
=
false
;
std
:
:
string
rawline
;
nsAutoCString
name
;
while
(
std
:
:
getline
(
stream
rawline
)
)
{
std
:
:
string_view
line
(
rawline
)
;
size_t
pos
=
line
.
find
(
'
=
'
)
;
if
(
pos
!
=
std
:
:
string_view
:
:
npos
)
{
auto
key
=
line
.
substr
(
0
pos
)
;
auto
value
=
line
.
substr
(
pos
+
1
)
;
if
(
key
=
=
"
ID
"
)
{
if
(
ExtractAndSetValue
(
aDistributor
value
)
)
{
char
*
c
=
aDistributor
.
BeginWriting
(
)
;
if
(
*
c
>
=
'
a
'
&
&
*
c
<
=
'
z
'
)
{
*
c
-
=
(
'
a
'
-
'
A
'
)
;
}
seen_id
=
true
;
}
}
else
if
(
key
=
=
"
NAME
"
)
{
ExtractAndSetValue
(
name
value
)
;
}
else
if
(
key
=
=
"
PRETTY_NAME
"
)
{
if
(
ExtractAndSetValue
(
aDescription
value
)
)
seen_pretty_name
=
true
;
}
else
if
(
key
=
=
"
VERSION_ID
"
)
{
if
(
ExtractAndSetValue
(
aRelease
value
)
)
seen_version_id
=
true
;
}
else
if
(
key
=
=
"
VERSION_CODENAME
"
)
{
ExtractAndSetValue
(
aCodename
value
)
;
}
}
}
if
(
seen_id
&
&
!
name
.
IsEmpty
(
)
&
&
name
.
EqualsIgnoreCase
(
aDistributor
)
)
{
aDistributor
=
name
;
}
return
seen_id
&
&
seen_pretty_name
&
&
seen_version_id
;
}
bool
GetLSBRelease
(
nsACString
&
aDistributor
nsACString
&
aDescription
nsACString
&
aRelease
nsACString
&
aCodename
)
{
if
(
GetOSRelease
(
aDistributor
aDescription
aRelease
aCodename
)
)
{
return
true
;
}
if
(
access
(
gLsbReleasePath
R_OK
)
!
=
0
)
return
false
;
int
pipefd
[
2
]
;
if
(
pipe
(
pipefd
)
=
=
-
1
)
{
NS_WARNING
(
"
pipe
(
)
failed
!
"
)
;
return
false
;
}
std
:
:
vector
<
std
:
:
string
>
argv
=
{
gLsbReleasePath
"
-
idrc
"
}
;
base
:
:
LaunchOptions
options
;
options
.
fds_to_remap
.
push_back
(
{
pipefd
[
1
]
STDOUT_FILENO
}
)
;
options
.
wait
=
true
;
base
:
:
ProcessHandle
process
;
Result
<
Ok
ipc
:
:
LaunchError
>
err
=
base
:
:
LaunchApp
(
argv
std
:
:
move
(
options
)
&
process
)
;
close
(
pipefd
[
1
]
)
;
if
(
err
.
isErr
(
)
)
{
NS_WARNING
(
"
Failed
to
spawn
lsb_release
!
"
)
;
close
(
pipefd
[
0
]
)
;
return
false
;
}
ScopedCloseFile
stream
(
fdopen
(
pipefd
[
0
]
"
r
"
)
)
;
if
(
!
stream
)
{
NS_WARNING
(
"
Could
not
wrap
fd
!
"
)
;
close
(
pipefd
[
0
]
)
;
return
false
;
}
char
dist
[
256
]
desc
[
256
]
release
[
256
]
codename
[
256
]
;
if
(
fscanf
(
stream
.
get
(
)
"
Distributor
ID
:
\
t
%
255
[
^
\
n
]
\
n
"
"
Description
:
\
t
%
255
[
^
\
n
]
\
n
"
"
Release
:
\
t
%
255
[
^
\
n
]
\
n
"
"
Codename
:
\
t
%
255
[
^
\
n
]
\
n
"
dist
desc
release
codename
)
!
=
4
)
{
NS_WARNING
(
"
Failed
to
parse
lsb_release
!
"
)
;
return
false
;
}
aDistributor
.
Assign
(
dist
)
;
aDescription
.
Assign
(
desc
)
;
aRelease
.
Assign
(
release
)
;
aCodename
.
Assign
(
codename
)
;
return
true
;
}
}
