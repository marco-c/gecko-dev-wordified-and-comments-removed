#
include
"
SwipeTracker
.
h
"
#
include
"
InputData
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
dom
/
SimpleGestureEventBinding
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
UnitTransforms
.
h
"
static
const
double
kSpringForce
=
250
.
0
;
static
const
double
kSwipeSuccessThreshold
=
0
.
25
;
namespace
mozilla
{
static
already_AddRefed
<
nsRefreshDriver
>
GetRefreshDriver
(
nsIWidget
&
aWidget
)
{
nsIWidgetListener
*
widgetListener
=
aWidget
.
GetWidgetListener
(
)
;
PresShell
*
presShell
=
widgetListener
?
widgetListener
-
>
GetPresShell
(
)
:
nullptr
;
nsPresContext
*
presContext
=
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
RefPtr
<
nsRefreshDriver
>
refreshDriver
=
presContext
?
presContext
-
>
RefreshDriver
(
)
:
nullptr
;
return
refreshDriver
.
forget
(
)
;
}
SwipeTracker
:
:
SwipeTracker
(
nsIWidget
&
aWidget
const
PanGestureInput
&
aSwipeStartEvent
uint32_t
aAllowedDirections
uint32_t
aSwipeDirection
)
:
mWidget
(
aWidget
)
mRefreshDriver
(
GetRefreshDriver
(
mWidget
)
)
mAxis
(
0
.
0
0
.
0
0
.
0
kSpringForce
1
.
0
)
mEventPosition
(
RoundedToInt
(
ViewAs
<
LayoutDevicePixel
>
(
aSwipeStartEvent
.
mPanStartPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
)
)
mLastEventTimeStamp
(
aSwipeStartEvent
.
mTimeStamp
)
mAllowedDirections
(
aAllowedDirections
)
mSwipeDirection
(
aSwipeDirection
)
mGestureAmount
(
0
.
0
)
mCurrentVelocity
(
0
.
0
)
mEventsAreControllingSwipe
(
true
)
mEventsHaveStartedNewGesture
(
false
)
mRegisteredWithRefreshDriver
(
false
)
{
SendSwipeEvent
(
eSwipeGestureStart
0
0
.
0
aSwipeStartEvent
.
mTimeStamp
)
;
ProcessEvent
(
aSwipeStartEvent
true
)
;
}
void
SwipeTracker
:
:
Destroy
(
)
{
UnregisterFromRefreshDriver
(
)
;
}
SwipeTracker
:
:
~
SwipeTracker
(
)
{
MOZ_ASSERT
(
!
mRegisteredWithRefreshDriver
"
Destroy
needs
to
be
called
before
deallocating
"
)
;
}
double
SwipeTracker
:
:
SwipeSuccessTargetValue
(
)
const
{
return
(
mSwipeDirection
=
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_RIGHT
)
?
-
1
.
0
:
1
.
0
;
}
double
SwipeTracker
:
:
ClampToAllowedRange
(
double
aGestureAmount
)
const
{
double
min
=
(
mSwipeDirection
=
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_RIGHT
)
?
-
1
.
0
:
0
.
0
;
double
max
=
(
mSwipeDirection
=
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_LEFT
)
?
1
.
0
:
0
.
0
;
return
clamped
(
aGestureAmount
min
max
)
;
}
bool
SwipeTracker
:
:
ComputeSwipeSuccess
(
)
const
{
double
targetValue
=
SwipeSuccessTargetValue
(
)
;
if
(
mCurrentVelocity
*
targetValue
<
-
StaticPrefs
:
:
widget_swipe_velocity_twitch_tolerance
(
)
)
{
return
false
;
}
return
(
mGestureAmount
*
targetValue
+
mCurrentVelocity
*
targetValue
*
StaticPrefs
:
:
widget_swipe_success_velocity_contribution
(
)
)
>
=
kSwipeSuccessThreshold
;
}
nsEventStatus
SwipeTracker
:
:
ProcessEvent
(
const
PanGestureInput
&
aEvent
bool
aProcessingFirstEvent
)
{
if
(
!
mEventsAreControllingSwipe
|
|
!
SwipingInAllowedDirection
(
)
)
{
if
(
aEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_MAYSTART
|
|
aEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_START
)
{
mEventsHaveStartedNewGesture
=
true
;
}
return
mEventsHaveStartedNewGesture
?
nsEventStatus_eIgnore
:
nsEventStatus_eConsumeNoDefault
;
}
double
delta
=
-
aEvent
.
mPanDisplacement
.
x
/
mWidget
.
GetDefaultScaleInternal
(
)
/
StaticPrefs
:
:
widget_swipe_whole_page_pixel_size
(
)
;
mGestureAmount
=
ClampToAllowedRange
(
mGestureAmount
+
delta
)
;
if
(
aEvent
.
mType
!
=
PanGestureInput
:
:
PANGESTURE_END
)
{
if
(
!
aProcessingFirstEvent
)
{
double
elapsedSeconds
=
std
:
:
max
(
0
.
008
(
aEvent
.
mTimeStamp
-
mLastEventTimeStamp
)
.
ToSeconds
(
)
)
;
mCurrentVelocity
=
delta
/
elapsedSeconds
;
}
mLastEventTimeStamp
=
aEvent
.
mTimeStamp
;
}
const
bool
computedSwipeSuccess
=
ComputeSwipeSuccess
(
)
;
double
eventAmount
=
mGestureAmount
;
if
(
computedSwipeSuccess
)
{
eventAmount
=
kSwipeSuccessThreshold
;
if
(
mGestureAmount
<
0
.
f
)
{
eventAmount
=
-
eventAmount
;
}
}
SendSwipeEvent
(
eSwipeGestureUpdate
0
eventAmount
aEvent
.
mTimeStamp
)
;
if
(
aEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_END
)
{
mEventsAreControllingSwipe
=
false
;
if
(
computedSwipeSuccess
)
{
SendSwipeEvent
(
eSwipeGesture
mSwipeDirection
0
.
0
aEvent
.
mTimeStamp
)
;
UnregisterFromRefreshDriver
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
SwipeTracker
:
:
SwipeFinished
"
[
swipeTracker
=
RefPtr
<
SwipeTracker
>
(
this
)
timeStamp
=
aEvent
.
mTimeStamp
]
{
swipeTracker
-
>
SwipeFinished
(
timeStamp
)
;
}
)
)
;
}
else
{
StartAnimating
(
0
.
0
)
;
}
}
return
nsEventStatus_eConsumeNoDefault
;
}
void
SwipeTracker
:
:
StartAnimating
(
double
aTargetValue
)
{
mAxis
.
SetPosition
(
mGestureAmount
)
;
mAxis
.
SetDestination
(
aTargetValue
)
;
mAxis
.
SetVelocity
(
mCurrentVelocity
)
;
mLastAnimationFrameTime
=
TimeStamp
:
:
Now
(
)
;
MOZ_ASSERT
(
!
mRegisteredWithRefreshDriver
)
;
if
(
mRefreshDriver
)
{
mRefreshDriver
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
"
Swipe
animation
"
)
;
mRegisteredWithRefreshDriver
=
true
;
}
}
void
SwipeTracker
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
mAxis
.
Simulate
(
now
-
mLastAnimationFrameTime
)
;
mLastAnimationFrameTime
=
now
;
bool
isFinished
=
mAxis
.
IsFinished
(
1
.
0
/
StaticPrefs
:
:
widget_swipe_whole_page_pixel_size
(
)
)
;
mGestureAmount
=
(
isFinished
?
mAxis
.
GetDestination
(
)
:
mAxis
.
GetPosition
(
)
)
;
SendSwipeEvent
(
eSwipeGestureUpdate
0
mGestureAmount
now
)
;
if
(
isFinished
)
{
UnregisterFromRefreshDriver
(
)
;
SwipeFinished
(
now
)
;
}
}
void
SwipeTracker
:
:
CancelSwipe
(
const
TimeStamp
&
aTimeStamp
)
{
SendSwipeEvent
(
eSwipeGestureEnd
0
0
.
0
aTimeStamp
)
;
}
void
SwipeTracker
:
:
SwipeFinished
(
const
TimeStamp
&
aTimeStamp
)
{
SendSwipeEvent
(
eSwipeGestureEnd
0
0
.
0
aTimeStamp
)
;
mWidget
.
SwipeFinished
(
)
;
}
void
SwipeTracker
:
:
UnregisterFromRefreshDriver
(
)
{
if
(
mRegisteredWithRefreshDriver
)
{
MOZ_ASSERT
(
mRefreshDriver
"
How
were
we
able
to
register
then
?
"
)
;
mRefreshDriver
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
}
mRegisteredWithRefreshDriver
=
false
;
}
WidgetSimpleGestureEvent
SwipeTracker
:
:
CreateSwipeGestureEvent
(
EventMessage
aMsg
nsIWidget
*
aWidget
const
LayoutDeviceIntPoint
&
aPosition
const
TimeStamp
&
aTimeStamp
)
{
WidgetSimpleGestureEvent
geckoEvent
(
true
aMsg
aWidget
)
;
geckoEvent
.
mModifiers
=
0
;
geckoEvent
.
mTimeStamp
=
aTimeStamp
;
geckoEvent
.
mRefPoint
=
aPosition
;
geckoEvent
.
mButtons
=
0
;
return
geckoEvent
;
}
bool
SwipeTracker
:
:
SendSwipeEvent
(
EventMessage
aMsg
uint32_t
aDirection
double
aDelta
const
TimeStamp
&
aTimeStamp
)
{
WidgetSimpleGestureEvent
geckoEvent
=
CreateSwipeGestureEvent
(
aMsg
&
mWidget
mEventPosition
aTimeStamp
)
;
geckoEvent
.
mDirection
=
aDirection
;
geckoEvent
.
mDelta
=
aDelta
;
geckoEvent
.
mAllowedDirections
=
mAllowedDirections
;
return
mWidget
.
DispatchWindowEvent
(
geckoEvent
)
;
}
bool
SwipeTracker
:
:
CanTriggerSwipe
(
const
PanGestureInput
&
aPanInput
)
{
if
(
StaticPrefs
:
:
widget_disable_swipe_tracker
(
)
)
{
return
false
;
}
if
(
aPanInput
.
mType
!
=
PanGestureInput
:
:
PANGESTURE_START
)
{
return
false
;
}
return
std
:
:
abs
(
aPanInput
.
mPanDisplacement
.
x
)
>
std
:
:
abs
(
aPanInput
.
mPanDisplacement
.
y
)
*
8
;
}
}
