#
ifndef
nsBaseClipboard_h__
#
define
nsBaseClipboard_h__
#
include
"
mozilla
/
contentanalysis
/
ContentAnalysisIPCTypes
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MoveOnlyFunction
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIContentAnalysis
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsCOMPtr
.
h
"
static
mozilla
:
:
LazyLogModule
sWidgetClipboardLog
(
"
WidgetClipboard
"
)
;
#
define
MOZ_CLIPBOARD_LOG
(
.
.
.
)
\
MOZ_LOG
(
sWidgetClipboardLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
MOZ_CLIPBOARD_LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
sWidgetClipboardLog
mozilla
:
:
LogLevel
:
:
Debug
)
class
nsITransferable
;
class
nsIClipboardOwner
;
class
nsIPrincipal
;
class
nsIWidget
;
namespace
mozilla
:
:
dom
{
class
WindowContext
;
}
class
nsBaseClipboard
:
public
nsIClipboard
{
public
:
explicit
nsBaseClipboard
(
const
mozilla
:
:
dom
:
:
ClipboardCapabilities
&
aClipboardCaps
)
;
NS_DECL_ISUPPORTS
NS_IMETHOD
SetData
(
nsITransferable
*
aTransferable
nsIClipboardOwner
*
aOwner
int32_t
aWhichClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aWindowContext
)
override
final
;
NS_IMETHOD
AsyncSetData
(
int32_t
aWhichClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aSettingWindowContext
nsIAsyncClipboardRequestCallback
*
aCallback
nsIAsyncSetClipboardData
*
*
_retval
)
override
final
;
NS_IMETHOD
GetData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aWindowContext
)
override
final
;
NS_IMETHOD
AsyncGetData
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
nsIPrincipal
*
aRequestingPrincipal
nsIAsyncClipboardGetCallback
*
aCallback
)
override
final
;
NS_IMETHOD
GetDataSnapshotSync
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
nsIAsyncGetClipboardData
*
*
_retval
)
override
final
;
NS_IMETHOD
EmptyClipboard
(
int32_t
aWhichClipboard
)
override
final
;
NS_IMETHOD
HasDataMatchingFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
bool
*
aOutResult
)
override
final
;
NS_IMETHOD
IsClipboardTypeSupported
(
int32_t
aWhichClipboard
bool
*
aRetval
)
override
final
;
void
AsyncGetDataInternal
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aClipboardType
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
nsIAsyncClipboardGetCallback
*
aCallback
)
;
using
GetDataCallback
=
mozilla
:
:
MoveOnlyFunction
<
void
(
nsresult
)
>
;
using
HasMatchingFlavorsCallback
=
mozilla
:
:
MoveOnlyFunction
<
void
(
mozilla
:
:
Result
<
nsTArray
<
nsCString
>
nsresult
>
)
>
;
protected
:
virtual
~
nsBaseClipboard
(
)
;
NS_IMETHOD
SetNativeClipboardData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
)
=
0
;
NS_IMETHOD
GetNativeClipboardData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
)
=
0
;
virtual
void
AsyncGetNativeClipboardData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
GetDataCallback
&
&
aCallback
)
;
virtual
nsresult
EmptyNativeClipboardData
(
int32_t
aWhichClipboard
)
=
0
;
virtual
mozilla
:
:
Result
<
int32_t
nsresult
>
GetNativeClipboardSequenceNumber
(
int32_t
aWhichClipboard
)
=
0
;
virtual
mozilla
:
:
Result
<
bool
nsresult
>
HasNativeClipboardDataMatchingFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
)
=
0
;
virtual
void
AsyncHasNativeClipboardDataMatchingFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
HasMatchingFlavorsCallback
&
&
aCallback
)
;
void
ClearClipboardCache
(
int32_t
aClipboardType
)
;
private
:
void
RejectPendingAsyncSetDataRequestIfAny
(
int32_t
aClipboardType
)
;
class
AsyncSetClipboardData
final
:
public
nsIAsyncSetClipboardData
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIASYNCSETCLIPBOARDDATA
AsyncSetClipboardData
(
int32_t
aClipboardType
nsBaseClipboard
*
aClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
nsIAsyncClipboardRequestCallback
*
aCallback
)
;
private
:
virtual
~
AsyncSetClipboardData
(
)
=
default
;
bool
IsValid
(
)
const
{
MOZ_ASSERT_IF
(
!
mClipboard
!
mCallback
)
;
return
!
!
mClipboard
;
}
void
MaybeNotifyCallback
(
nsresult
aResult
)
;
int32_t
mClipboardType
;
nsBaseClipboard
*
mClipboard
;
RefPtr
<
mozilla
:
:
dom
:
:
WindowContext
>
mWindowContext
;
nsCOMPtr
<
nsIAsyncClipboardRequestCallback
>
mCallback
;
}
;
class
AsyncGetClipboardData
final
:
public
nsIAsyncGetClipboardData
{
public
:
AsyncGetClipboardData
(
int32_t
aClipboardType
int32_t
aSequenceNumber
nsTArray
<
nsCString
>
&
&
aFlavors
bool
aFromCache
nsBaseClipboard
*
aClipboard
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIASYNCGETCLIPBOARDDATA
private
:
virtual
~
AsyncGetClipboardData
(
)
=
default
;
bool
IsValid
(
)
;
const
int32_t
mClipboardType
;
const
int32_t
mSequenceNumber
;
const
nsTArray
<
nsCString
>
mFlavors
;
const
bool
mFromCache
;
RefPtr
<
nsBaseClipboard
>
mClipboard
;
RefPtr
<
mozilla
:
:
dom
:
:
WindowContext
>
mRequestingWindowContext
;
}
;
class
ClipboardCache
final
{
public
:
~
ClipboardCache
(
)
{
Clear
(
)
;
}
void
Clear
(
)
;
void
Update
(
nsITransferable
*
aTransferable
nsIClipboardOwner
*
aClipboardOwner
int32_t
aSequenceNumber
mozilla
:
:
Maybe
<
uint64_t
>
aInnerWindowId
)
{
Clear
(
)
;
mTransferable
=
aTransferable
;
mClipboardOwner
=
aClipboardOwner
;
mSequenceNumber
=
aSequenceNumber
;
mInnerWindowId
=
aInnerWindowId
;
}
nsITransferable
*
GetTransferable
(
)
const
{
return
mTransferable
;
}
nsIClipboardOwner
*
GetClipboardOwner
(
)
const
{
return
mClipboardOwner
;
}
int32_t
GetSequenceNumber
(
)
const
{
return
mSequenceNumber
;
}
mozilla
:
:
Maybe
<
uint64_t
>
GetInnerWindowId
(
)
const
{
return
mInnerWindowId
;
}
nsresult
GetData
(
nsITransferable
*
aTransferable
)
const
;
private
:
nsCOMPtr
<
nsITransferable
>
mTransferable
;
nsCOMPtr
<
nsIClipboardOwner
>
mClipboardOwner
;
int32_t
mSequenceNumber
=
-
1
;
mozilla
:
:
Maybe
<
uint64_t
>
mInnerWindowId
;
}
;
class
SafeContentAnalysisResultCallback
final
:
public
nsIContentAnalysisCallback
{
public
:
explicit
SafeContentAnalysisResultCallback
(
std
:
:
function
<
void
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
)
>
aResolver
)
:
mResolver
(
std
:
:
move
(
aResolver
)
)
{
}
void
Callback
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
aResult
)
{
MOZ_ASSERT
(
mResolver
"
Called
SafeContentAnalysisResultCallback
twice
!
"
)
;
if
(
auto
resolver
=
std
:
:
move
(
mResolver
)
)
{
resolver
(
std
:
:
move
(
aResult
)
)
;
}
}
NS_IMETHODIMP
ContentResult
(
nsIContentAnalysisResponse
*
aResponse
)
override
{
using
namespace
mozilla
:
:
contentanalysis
;
RefPtr
<
ContentAnalysisResult
>
result
=
ContentAnalysisResult
:
:
FromContentAnalysisResponse
(
aResponse
)
;
Callback
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
Error
(
nsresult
aError
)
override
{
using
namespace
mozilla
:
:
contentanalysis
;
Callback
(
ContentAnalysisResult
:
:
FromNoResult
(
NoContentAnalysisResult
:
:
DENY_DUE_TO_OTHER_ERROR
)
)
;
return
NS_OK
;
}
NS_DECL_THREADSAFE_ISUPPORTS
private
:
~
SafeContentAnalysisResultCallback
(
)
{
MOZ_ASSERT
(
!
mResolver
"
SafeContentAnalysisResultCallback
never
called
!
"
)
;
}
mozilla
:
:
MoveOnlyFunction
<
void
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
)
>
mResolver
;
}
;
void
MaybeRetryGetAvailableFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
nsIAsyncClipboardGetCallback
*
aCallback
int32_t
aRetryCount
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
)
;
ClipboardCache
*
GetClipboardCacheIfValid
(
int32_t
aClipboardType
)
;
mozilla
:
:
Result
<
nsTArray
<
nsCString
>
nsresult
>
GetFlavorsFromClipboardCache
(
int32_t
aClipboardType
)
;
nsresult
GetDataFromClipboardCache
(
nsITransferable
*
aTransferable
int32_t
aClipboardType
)
;
bool
CheckClipboardContentAnalysisSync
(
mozilla
:
:
dom
:
:
WindowGlobalParent
*
aWindow
const
nsCOMPtr
<
nsITransferable
>
&
trans
int32_t
aClipboardType
)
;
void
CheckClipboardContentAnalysis
(
mozilla
:
:
dom
:
:
WindowGlobalParent
*
aWindow
nsITransferable
*
aTransferable
int32_t
aClipboardType
SafeContentAnalysisResultCallback
*
aResolver
)
;
using
ClipboardContentAnalysisResult
=
mozilla
:
:
Result
<
bool
mozilla
:
:
contentanalysis
:
:
NoContentAnalysisResult
>
;
ClipboardContentAnalysisResult
CheckClipboardContentAnalysisAsText
(
uint64_t
aInnerWindowId
SafeContentAnalysisResultCallback
*
aResolver
nsIURI
*
aDocumentURI
nsIContentAnalysis
*
aContentAnalysis
nsITransferable
*
aTextTrans
)
;
ClipboardContentAnalysisResult
CheckClipboardContentAnalysisAsFile
(
uint64_t
aInnerWindowId
SafeContentAnalysisResultCallback
*
aResolver
nsIURI
*
aDocumentURI
nsIContentAnalysis
*
aContentAnalysis
nsITransferable
*
aFileTrans
)
;
void
RequestUserConfirmation
(
int32_t
aClipboardType
const
nsTArray
<
nsCString
>
&
aFlavorList
mozilla
:
:
dom
:
:
WindowContext
*
aWindowContext
nsIPrincipal
*
aRequestingPrincipal
nsIAsyncClipboardGetCallback
*
aCallback
)
;
already_AddRefed
<
nsIAsyncGetClipboardData
>
MaybeCreateGetRequestFromClipboardCache
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aClipboardType
mozilla
:
:
dom
:
:
WindowContext
*
aRequestingWindowContext
)
;
RefPtr
<
AsyncSetClipboardData
>
mPendingWriteRequests
[
nsIClipboard
:
:
kClipboardTypeCount
]
;
mozilla
:
:
UniquePtr
<
ClipboardCache
>
mCaches
[
nsIClipboard
:
:
kClipboardTypeCount
]
;
const
mozilla
:
:
dom
:
:
ClipboardCapabilities
mClipboardCaps
;
bool
mIgnoreEmptyNotification
=
false
;
}
;
#
endif
