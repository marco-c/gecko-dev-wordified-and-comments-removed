#
include
"
base
/
basictypes
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
layers
/
APZChild
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
PuppetWidget
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsXPLookAndFeel
.
h
"
#
include
"
nsPrintfCString
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
hal
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
static
void
InvalidateRegion
(
nsIWidget
*
aWidget
const
LayoutDeviceIntRegion
&
aRegion
)
{
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aWidget
-
>
Invalidate
(
iter
.
Get
(
)
)
;
}
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreatePuppetWidget
(
TabChild
*
aTabChild
)
{
MOZ_ASSERT
(
!
aTabChild
|
|
nsIWidget
:
:
UsePuppetWidgets
(
)
"
PuppetWidgets
not
allowed
in
this
configuration
"
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
new
PuppetWidget
(
aTabChild
)
;
return
widget
.
forget
(
)
;
}
namespace
mozilla
{
namespace
widget
{
static
bool
IsPopup
(
const
nsWidgetInitData
*
aInitData
)
{
return
aInitData
&
&
aInitData
-
>
mWindowType
=
=
eWindowType_popup
;
}
static
bool
MightNeedIMEFocus
(
const
nsWidgetInitData
*
aInitData
)
{
#
ifdef
MOZ_CROSS_PROCESS_IME
return
!
IsPopup
(
aInitData
)
;
#
else
return
false
;
#
endif
}
const
size_t
PuppetWidget
:
:
kMaxDimension
=
4000
;
static
bool
gRemoteDesktopBehaviorEnabled
=
false
;
static
bool
gRemoteDesktopBehaviorInitialized
=
false
;
NS_IMPL_ISUPPORTS_INHERITED
(
PuppetWidget
nsBaseWidget
TextEventDispatcherListener
)
PuppetWidget
:
:
PuppetWidget
(
TabChild
*
aTabChild
)
:
mTabChild
(
aTabChild
)
mMemoryPressureObserver
(
nullptr
)
mDPI
(
-
1
)
mRounding
(
1
)
mDefaultScale
(
-
1
)
mCursorHotspotX
(
0
)
mCursorHotspotY
(
0
)
mEnabled
(
false
)
mVisible
(
false
)
mNeedIMEStateInit
(
false
)
mIgnoreCompositionEvents
(
false
)
{
mInputContext
.
mIMEState
.
mEnabled
=
IMEState
:
:
UNKNOWN
;
if
(
!
gRemoteDesktopBehaviorInitialized
)
{
Preferences
:
:
AddBoolVarCache
(
&
gRemoteDesktopBehaviorEnabled
"
browser
.
tabs
.
remote
.
desktopbehavior
"
false
)
;
gRemoteDesktopBehaviorInitialized
=
true
;
}
}
PuppetWidget
:
:
~
PuppetWidget
(
)
{
Destroy
(
)
;
}
void
PuppetWidget
:
:
InfallibleCreate
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
MOZ_ASSERT
(
!
aNativeParent
"
got
a
non
-
Puppet
native
parent
"
)
;
BaseCreate
(
nullptr
aInitData
)
;
mBounds
=
aRect
;
mEnabled
=
true
;
mVisible
=
true
;
mDrawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
mNeedIMEStateInit
=
MightNeedIMEFocus
(
aInitData
)
;
PuppetWidget
*
parent
=
static_cast
<
PuppetWidget
*
>
(
aParent
)
;
if
(
parent
)
{
parent
-
>
SetChild
(
this
)
;
mLayerManager
=
parent
-
>
GetLayerManager
(
)
;
}
else
{
Resize
(
mBounds
.
X
(
)
mBounds
.
Y
(
)
mBounds
.
Width
(
)
mBounds
.
Height
(
)
false
)
;
}
mMemoryPressureObserver
=
MemoryPressureObserver
:
:
Create
(
this
)
;
}
nsresult
PuppetWidget
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
InfallibleCreate
(
aParent
aNativeParent
aRect
aInitData
)
;
return
NS_OK
;
}
void
PuppetWidget
:
:
InitIMEState
(
)
{
MOZ_ASSERT
(
mTabChild
)
;
if
(
mNeedIMEStateInit
)
{
mContentCache
.
Clear
(
)
;
mTabChild
-
>
SendUpdateContentCache
(
mContentCache
)
;
mIMENotificationRequestsOfParent
=
IMENotificationRequests
(
)
;
mNeedIMEStateInit
=
false
;
}
}
already_AddRefed
<
nsIWidget
>
PuppetWidget
:
:
CreateChild
(
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
bool
aForceUseIWidgetParent
)
{
bool
isPopup
=
IsPopup
(
aInitData
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
nsIWidget
:
:
CreatePuppetWidget
(
mTabChild
)
;
return
(
(
widget
&
&
NS_SUCCEEDED
(
widget
-
>
Create
(
isPopup
?
nullptr
:
this
nullptr
aRect
aInitData
)
)
)
?
widget
.
forget
(
)
:
nullptr
)
;
}
void
PuppetWidget
:
:
Destroy
(
)
{
if
(
mOnDestroyCalled
)
{
return
;
}
mOnDestroyCalled
=
true
;
Base
:
:
OnDestroy
(
)
;
Base
:
:
Destroy
(
)
;
mPaintTask
.
Revoke
(
)
;
if
(
mMemoryPressureObserver
)
{
mMemoryPressureObserver
-
>
Unregister
(
)
;
mMemoryPressureObserver
=
nullptr
;
}
mChild
=
nullptr
;
if
(
mLayerManager
)
{
mLayerManager
-
>
Destroy
(
)
;
}
mLayerManager
=
nullptr
;
mTabChild
=
nullptr
;
}
void
PuppetWidget
:
:
Show
(
bool
aState
)
{
NS_ASSERTION
(
mEnabled
"
does
it
make
sense
to
Show
(
)
/
Hide
(
)
a
disabled
widget
?
"
)
;
bool
wasVisible
=
mVisible
;
mVisible
=
aState
;
if
(
mChild
)
{
mChild
-
>
mVisible
=
aState
;
}
if
(
!
wasVisible
&
&
mVisible
)
{
mPreviouslyAttachedWidgetListener
=
nullptr
;
Resize
(
mBounds
.
Width
(
)
mBounds
.
Height
(
)
false
)
;
Invalidate
(
mBounds
)
;
}
}
void
PuppetWidget
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
LayoutDeviceIntRect
oldBounds
=
mBounds
;
mBounds
.
SizeTo
(
LayoutDeviceIntSize
(
NSToIntRound
(
aWidth
)
NSToIntRound
(
aHeight
)
)
)
;
if
(
mChild
)
{
mChild
-
>
Resize
(
aWidth
aHeight
aRepaint
)
;
return
;
}
if
(
oldBounds
.
Size
(
)
<
mBounds
.
Size
(
)
&
&
aRepaint
)
{
LayoutDeviceIntRegion
dirty
(
mBounds
)
;
dirty
.
Sub
(
dirty
oldBounds
)
;
InvalidateRegion
(
this
dirty
)
;
}
if
(
!
oldBounds
.
IsEqualEdges
(
mBounds
)
&
&
mAttachedWidgetListener
)
{
if
(
GetCurrentWidgetListener
(
)
&
&
GetCurrentWidgetListener
(
)
!
=
mAttachedWidgetListener
)
{
GetCurrentWidgetListener
(
)
-
>
WindowResized
(
this
mBounds
.
Width
(
)
mBounds
.
Height
(
)
)
;
}
mAttachedWidgetListener
-
>
WindowResized
(
this
mBounds
.
Width
(
)
mBounds
.
Height
(
)
)
;
}
}
nsresult
PuppetWidget
:
:
ConfigureChildren
(
const
nsTArray
<
Configuration
>
&
aConfigurations
)
{
for
(
uint32_t
i
=
0
;
i
<
aConfigurations
.
Length
(
)
;
+
+
i
)
{
const
Configuration
&
configuration
=
aConfigurations
[
i
]
;
PuppetWidget
*
w
=
static_cast
<
PuppetWidget
*
>
(
configuration
.
mChild
.
get
(
)
)
;
NS_ASSERTION
(
w
-
>
GetParent
(
)
=
=
this
"
Configured
widget
is
not
a
child
"
)
;
w
-
>
SetWindowClipRegion
(
configuration
.
mClipRegion
true
)
;
LayoutDeviceIntRect
bounds
=
w
-
>
GetBounds
(
)
;
if
(
bounds
.
Size
(
)
!
=
configuration
.
mBounds
.
Size
(
)
)
{
w
-
>
Resize
(
configuration
.
mBounds
.
X
(
)
configuration
.
mBounds
.
Y
(
)
configuration
.
mBounds
.
Width
(
)
configuration
.
mBounds
.
Height
(
)
true
)
;
}
else
if
(
bounds
.
TopLeft
(
)
!
=
configuration
.
mBounds
.
TopLeft
(
)
)
{
w
-
>
Move
(
configuration
.
mBounds
.
X
(
)
configuration
.
mBounds
.
Y
(
)
)
;
}
w
-
>
SetWindowClipRegion
(
configuration
.
mClipRegion
false
)
;
}
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SetFocus
(
bool
aRaise
)
{
if
(
aRaise
&
&
mTabChild
)
{
mTabChild
-
>
SendRequestFocus
(
true
)
;
}
return
NS_OK
;
}
void
PuppetWidget
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
#
ifdef
DEBUG
debug_DumpInvalidate
(
stderr
this
&
aRect
"
PuppetWidget
"
0
)
;
#
endif
if
(
mChild
)
{
mChild
-
>
Invalidate
(
aRect
)
;
return
;
}
mDirtyRegion
.
Or
(
mDirtyRegion
aRect
)
;
if
(
mTabChild
&
&
!
mDirtyRegion
.
IsEmpty
(
)
&
&
!
mPaintTask
.
IsPending
(
)
)
{
mPaintTask
=
new
PaintTask
(
this
)
;
nsCOMPtr
<
nsIRunnable
>
event
(
mPaintTask
.
get
(
)
)
;
mTabChild
-
>
TabGroup
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
return
;
}
}
void
PuppetWidget
:
:
InitEvent
(
WidgetGUIEvent
&
aEvent
LayoutDeviceIntPoint
*
aPoint
)
{
if
(
nullptr
=
=
aPoint
)
{
aEvent
.
mRefPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
}
else
{
aEvent
.
mRefPoint
=
*
aPoint
;
}
aEvent
.
mTime
=
PR_Now
(
)
/
1000
;
}
nsresult
PuppetWidget
:
:
DispatchEvent
(
WidgetGUIEvent
*
aEvent
nsEventStatus
&
aStatus
)
{
#
ifdef
DEBUG
debug_DumpEvent
(
stdout
aEvent
-
>
mWidget
aEvent
"
PuppetWidget
"
0
)
;
#
endif
MOZ_ASSERT
(
!
mChild
|
|
mChild
-
>
mWindowType
=
=
eWindowType_popup
"
Unexpected
event
dispatch
!
"
)
;
MOZ_ASSERT
(
!
aEvent
-
>
AsKeyboardEvent
(
)
|
|
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
|
|
aEvent
-
>
AsKeyboardEvent
(
)
-
>
AreAllEditCommandsInitialized
(
)
"
Non
-
sysnthesized
keyboard
events
should
have
edit
commands
for
"
"
all
types
"
"
before
dispatched
"
)
;
if
(
aEvent
-
>
mClass
=
=
eCompositionEventClass
)
{
if
(
mIgnoreCompositionEvents
)
{
if
(
aEvent
-
>
mMessage
!
=
eCompositionStart
)
{
aStatus
=
nsEventStatus_eIgnore
;
return
NS_OK
;
}
mIgnoreCompositionEvents
=
false
;
}
WidgetCompositionEvent
*
compositionEvent
=
aEvent
-
>
AsCompositionEvent
(
)
;
#
ifdef
DEBUG
if
(
mNativeIMEContext
.
IsValid
(
)
&
&
mNativeIMEContext
!
=
compositionEvent
-
>
mNativeIMEContext
)
{
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
this
)
;
MOZ_ASSERT
(
!
composition
"
When
there
is
composition
caused
by
old
native
IME
context
"
"
composition
events
caused
by
different
native
IME
context
are
not
"
"
allowed
"
)
;
}
#
endif
mNativeIMEContext
=
compositionEvent
-
>
mNativeIMEContext
;
}
if
(
aEvent
-
>
mClass
=
=
eCompositionEventClass
|
|
aEvent
-
>
mClass
=
=
eKeyboardEventClass
)
{
TextEventDispatcher
*
dispatcher
=
GetTextEventDispatcher
(
)
;
if
(
!
dispatcher
-
>
IsDispatchingEvent
(
)
&
&
!
(
mNativeTextEventDispatcherListener
&
&
!
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
)
)
{
DebugOnly
<
nsresult
>
rv
=
dispatcher
-
>
BeginInputTransactionFor
(
aEvent
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
The
text
event
dispatcher
should
always
succeed
to
start
input
"
"
transaction
for
the
event
"
)
;
}
}
aStatus
=
nsEventStatus_eIgnore
;
if
(
GetCurrentWidgetListener
(
)
)
{
aStatus
=
GetCurrentWidgetListener
(
)
-
>
HandleEvent
(
aEvent
mUseAttachedEvents
)
;
}
return
NS_OK
;
}
nsEventStatus
PuppetWidget
:
:
DispatchInputEvent
(
WidgetInputEvent
*
aEvent
)
{
if
(
!
AsyncPanZoomEnabled
(
)
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
DispatchEvent
(
aEvent
status
)
;
return
status
;
}
if
(
!
mTabChild
)
{
return
nsEventStatus_eIgnore
;
}
if
(
nsCOMPtr
<
nsIPresShell
>
presShell
=
mTabChild
-
>
GetPresShell
(
)
)
{
LayoutDevicePoint
pt
(
aEvent
-
>
mRefPoint
)
;
pt
=
pt
*
presShell
-
>
GetResolution
(
)
;
aEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
:
:
Round
(
pt
)
;
}
switch
(
aEvent
-
>
mClass
)
{
case
eWheelEventClass
:
Unused
<
<
mTabChild
-
>
SendDispatchWheelEvent
(
*
aEvent
-
>
AsWheelEvent
(
)
)
;
break
;
case
eMouseEventClass
:
Unused
<
<
mTabChild
-
>
SendDispatchMouseEvent
(
*
aEvent
-
>
AsMouseEvent
(
)
)
;
break
;
case
eKeyboardEventClass
:
Unused
<
<
mTabChild
-
>
SendDispatchKeyboardEvent
(
*
aEvent
-
>
AsKeyboardEvent
(
)
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unsupported
event
type
"
)
;
}
return
nsEventStatus_eIgnore
;
}
nsresult
PuppetWidget
:
:
SynthesizeNativeKeyEvent
(
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
keyevent
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSynthesizeNativeKeyEvent
(
aNativeKeyboardLayout
aNativeKeyCode
aModifierFlags
nsString
(
aCharacters
)
nsString
(
aUnmodifiedCharacters
)
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SynthesizeNativeMouseEvent
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
uint32_t
aModifierFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mouseevent
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSynthesizeNativeMouseEvent
(
aPoint
aNativeMessage
aModifierFlags
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SynthesizeNativeMouseMove
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mousemove
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSynthesizeNativeMouseMove
(
aPoint
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SynthesizeNativeMouseScrollEvent
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
double
aDeltaX
double
aDeltaY
double
aDeltaZ
uint32_t
aModifierFlags
uint32_t
aAdditionalFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mousescrollevent
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSynthesizeNativeMouseScrollEvent
(
aPoint
aNativeMessage
aDeltaX
aDeltaY
aDeltaZ
aModifierFlags
aAdditionalFlags
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SynthesizeNativeTouchPoint
(
uint32_t
aPointerId
TouchPointerState
aPointerState
LayoutDeviceIntPoint
aPoint
double
aPointerPressure
uint32_t
aPointerOrientation
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
touchpoint
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSynthesizeNativeTouchPoint
(
aPointerId
aPointerState
aPoint
aPointerPressure
aPointerOrientation
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SynthesizeNativeTouchTap
(
LayoutDeviceIntPoint
aPoint
bool
aLongTap
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
touchtap
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSynthesizeNativeTouchTap
(
aPoint
aLongTap
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
ClearNativeTouchSequence
(
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
cleartouch
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendClearNativeTouchSequence
(
notifier
.
SaveObserver
(
)
)
;
return
NS_OK
;
}
void
PuppetWidget
:
:
SetConfirmedTargetAPZC
(
uint64_t
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
const
{
if
(
mTabChild
)
{
mTabChild
-
>
SetTargetAPZC
(
aInputBlockId
aTargets
)
;
}
}
void
PuppetWidget
:
:
UpdateZoomConstraints
(
const
uint32_t
&
aPresShellId
const
ScrollableLayerGuid
:
:
ViewID
&
aViewId
const
Maybe
<
ZoomConstraints
>
&
aConstraints
)
{
if
(
mTabChild
)
{
mTabChild
-
>
DoUpdateZoomConstraints
(
aPresShellId
aViewId
aConstraints
)
;
}
}
bool
PuppetWidget
:
:
AsyncPanZoomEnabled
(
)
const
{
return
mTabChild
&
&
mTabChild
-
>
AsyncPanZoomEnabled
(
)
;
}
void
PuppetWidget
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
nsIWidget
:
:
GetEditCommands
(
aType
aEvent
aCommands
)
;
mTabChild
-
>
RequestEditCommands
(
aType
aEvent
aCommands
)
;
}
LayerManager
*
PuppetWidget
:
:
GetLayerManager
(
PLayerTransactionChild
*
aShadowManager
LayersBackend
aBackendHint
LayerManagerPersistence
aPersistence
)
{
if
(
!
mLayerManager
)
{
if
(
XRE_IsParentProcess
(
)
)
{
mLayerManager
=
new
BasicLayerManager
(
BasicLayerManager
:
:
BLM_OFFSCREEN
)
;
return
mLayerManager
;
}
MOZ_ASSERT
(
!
mTabChild
|
|
mTabChild
-
>
IsLayersConnected
(
)
!
=
Some
(
true
)
)
;
mLayerManager
=
new
BasicLayerManager
(
this
)
;
}
return
mLayerManager
;
}
bool
PuppetWidget
:
:
CreateRemoteLayerManager
(
const
std
:
:
function
<
bool
(
LayerManager
*
)
>
&
aInitializeFunc
)
{
RefPtr
<
LayerManager
>
lm
;
MOZ_ASSERT
(
mTabChild
)
;
if
(
mTabChild
-
>
GetCompositorOptions
(
)
.
UseWebRender
(
)
)
{
lm
=
new
WebRenderLayerManager
(
this
)
;
}
else
{
lm
=
new
ClientLayerManager
(
this
)
;
}
if
(
!
aInitializeFunc
(
lm
)
)
{
return
false
;
}
DestroyLayerManager
(
)
;
mLayerManager
=
lm
.
forget
(
)
;
return
true
;
}
nsresult
PuppetWidget
:
:
RequestIMEToCommitComposition
(
bool
aCancel
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
Destroyed
(
)
)
;
if
(
NS_WARN_IF
(
!
mNativeIMEContext
.
IsValid
(
)
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
mIgnoreCompositionEvents
)
)
{
#
ifdef
DEBUG
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
this
)
;
MOZ_ASSERT
(
!
composition
)
;
#
endif
return
NS_OK
;
}
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
this
)
;
if
(
NS_WARN_IF
(
!
composition
)
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
composition
-
>
IsRequestingCommitOrCancelComposition
(
)
"
Requesting
commit
or
cancel
composition
should
be
requested
via
"
"
TextComposition
instance
"
)
;
bool
isCommitted
=
false
;
nsAutoString
committedString
;
if
(
NS_WARN_IF
(
!
mTabChild
-
>
SendRequestIMEToCommitComposition
(
aCancel
&
isCommitted
&
committedString
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
isCommitted
)
{
return
NS_OK
;
}
WidgetCompositionEvent
compositionCommitEvent
(
true
eCompositionCommit
this
)
;
InitEvent
(
compositionCommitEvent
nullptr
)
;
compositionCommitEvent
.
mData
=
committedString
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
DispatchEvent
(
&
compositionCommitEvent
status
)
;
#
ifdef
DEBUG
RefPtr
<
TextComposition
>
currentComposition
=
IMEStateManager
:
:
GetTextCompositionFor
(
this
)
;
MOZ_ASSERT
(
!
currentComposition
)
;
#
endif
mIgnoreCompositionEvents
=
true
;
Unused
<
<
mTabChild
-
>
SendOnEventNeedingAckHandled
(
eCompositionCommitRequestHandled
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
StartPluginIME
(
const
WidgetKeyboardEvent
&
aKeyboardEvent
int32_t
aPanelX
int32_t
aPanelY
nsString
&
aCommitted
)
{
DebugOnly
<
bool
>
propagationAlreadyStopped
=
aKeyboardEvent
.
mFlags
.
mPropagationStopped
;
DebugOnly
<
bool
>
immediatePropagationAlreadyStopped
=
aKeyboardEvent
.
mFlags
.
mImmediatePropagationStopped
;
if
(
!
mTabChild
|
|
!
mTabChild
-
>
SendStartPluginIME
(
aKeyboardEvent
aPanelX
aPanelY
&
aCommitted
)
)
{
return
NS_ERROR_FAILURE
;
}
const_cast
<
WidgetKeyboardEvent
&
>
(
aKeyboardEvent
)
.
ResetCrossProcessDispatchingState
(
)
;
MOZ_ASSERT
(
propagationAlreadyStopped
=
=
aKeyboardEvent
.
mFlags
.
mPropagationStopped
)
;
MOZ_ASSERT
(
immediatePropagationAlreadyStopped
=
=
aKeyboardEvent
.
mFlags
.
mImmediatePropagationStopped
)
;
return
NS_OK
;
}
void
PuppetWidget
:
:
SetPluginFocused
(
bool
&
aFocused
)
{
if
(
mTabChild
)
{
mTabChild
-
>
SendSetPluginFocused
(
aFocused
)
;
}
}
void
PuppetWidget
:
:
DefaultProcOfPluginEvent
(
const
WidgetPluginEvent
&
aEvent
)
{
if
(
!
mTabChild
)
{
return
;
}
mTabChild
-
>
SendDefaultProcOfPluginEvent
(
aEvent
)
;
}
bool
PuppetWidget
:
:
HaveValidInputContextCache
(
)
const
{
return
(
mInputContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
UNKNOWN
&
&
IMEStateManager
:
:
GetWidgetForActiveInputContext
(
)
=
=
this
)
;
}
void
PuppetWidget
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
mInputContext
=
aContext
;
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
OPEN_STATE_NOT_SUPPORTED
;
if
(
!
mTabChild
)
{
return
;
}
mTabChild
-
>
SendSetInputContext
(
aContext
aAction
)
;
}
InputContext
PuppetWidget
:
:
GetInputContext
(
)
{
if
(
HaveValidInputContextCache
(
)
)
{
return
mInputContext
;
}
NS_WARNING
(
"
PuppetWidget
:
:
GetInputContext
(
)
needs
to
retrieve
it
with
IPC
"
)
;
InputContext
context
;
if
(
mTabChild
)
{
mTabChild
-
>
SendGetInputContext
(
&
context
.
mIMEState
)
;
}
return
context
;
}
NativeIMEContext
PuppetWidget
:
:
GetNativeIMEContext
(
)
{
return
mNativeIMEContext
;
}
nsresult
PuppetWidget
:
:
NotifyIMEOfFocusChange
(
const
IMENotification
&
aIMENotification
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
bool
gotFocus
=
aIMENotification
.
mMessage
=
=
NOTIFY_IME_OF_FOCUS
;
if
(
gotFocus
)
{
if
(
mInputContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
PLUGIN
)
{
if
(
NS_WARN_IF
(
!
mContentCache
.
CacheAll
(
this
&
aIMENotification
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
if
(
NS_WARN_IF
(
!
mContentCache
.
CacheEditorRect
(
this
&
aIMENotification
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
else
{
mContentCache
.
Clear
(
)
;
}
mIMENotificationRequestsOfParent
=
IMENotificationRequests
(
IMENotificationRequests
:
:
NOTIFY_ALL
)
;
RefPtr
<
PuppetWidget
>
self
=
this
;
mTabChild
-
>
SendNotifyIMEFocus
(
mContentCache
aIMENotification
)
-
>
Then
(
mTabChild
-
>
TabGroup
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
UI
)
__func__
[
self
]
(
IMENotificationRequests
&
&
aRequests
)
{
self
-
>
mIMENotificationRequestsOfParent
=
aRequests
;
}
[
self
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
&
&
aReason
)
{
NS_WARNING
(
"
SendNotifyIMEFocus
got
rejected
.
"
)
;
}
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
NotifyIMEOfCompositionUpdate
(
const
IMENotification
&
aIMENotification
)
{
if
(
NS_WARN_IF
(
!
mTabChild
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mInputContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
PLUGIN
&
&
NS_WARN_IF
(
!
mContentCache
.
CacheSelection
(
this
&
aIMENotification
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendNotifyIMECompositionUpdate
(
mContentCache
aIMENotification
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
NotifyIMEOfTextChange
(
const
IMENotification
&
aIMENotification
)
{
MOZ_ASSERT
(
aIMENotification
.
mMessage
=
=
NOTIFY_IME_OF_TEXT_CHANGE
"
Passed
wrong
notification
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mContentCache
.
CacheText
(
this
&
aIMENotification
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mIMENotificationRequestsOfParent
.
WantTextChange
(
)
)
{
mTabChild
-
>
SendNotifyIMETextChange
(
mContentCache
aIMENotification
)
;
}
else
{
mTabChild
-
>
SendUpdateContentCache
(
mContentCache
)
;
}
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
NotifyIMEOfSelectionChange
(
const
IMENotification
&
aIMENotification
)
{
MOZ_ASSERT
(
aIMENotification
.
mMessage
=
=
NOTIFY_IME_OF_SELECTION_CHANGE
"
Passed
wrong
notification
"
)
;
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
)
{
return
NS_ERROR_FAILURE
;
}
mContentCache
.
SetSelection
(
this
aIMENotification
.
mSelectionChangeData
.
mOffset
aIMENotification
.
mSelectionChangeData
.
Length
(
)
aIMENotification
.
mSelectionChangeData
.
mReversed
aIMENotification
.
mSelectionChangeData
.
GetWritingMode
(
)
)
;
mTabChild
-
>
SendNotifyIMESelection
(
mContentCache
aIMENotification
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
NotifyIMEOfMouseButtonEvent
(
const
IMENotification
&
aIMENotification
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
consumedByIME
=
false
;
if
(
!
mTabChild
-
>
SendNotifyIMEMouseButtonEvent
(
aIMENotification
&
consumedByIME
)
)
{
return
NS_ERROR_FAILURE
;
}
return
consumedByIME
?
NS_SUCCESS_EVENT_CONSUMED
:
NS_OK
;
}
nsresult
PuppetWidget
:
:
NotifyIMEOfPositionChange
(
const
IMENotification
&
aIMENotification
)
{
if
(
NS_WARN_IF
(
!
mTabChild
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mContentCache
.
CacheEditorRect
(
this
&
aIMENotification
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mInputContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
PLUGIN
&
&
NS_WARN_IF
(
!
mContentCache
.
CacheSelection
(
this
&
aIMENotification
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mIMENotificationRequestsOfParent
.
WantPositionChanged
(
)
)
{
mTabChild
-
>
SendNotifyIMEPositionChange
(
mContentCache
aIMENotification
)
;
}
else
{
mTabChild
-
>
SendUpdateContentCache
(
mContentCache
)
;
}
return
NS_OK
;
}
struct
CursorSurface
{
UniquePtr
<
char
[
]
>
mData
;
IntSize
mSize
;
}
;
void
PuppetWidget
:
:
SetCursor
(
nsCursor
aCursor
imgIContainer
*
aCursorImage
uint32_t
aHotspotX
uint32_t
aHotspotY
)
{
if
(
!
mTabChild
)
{
return
;
}
#
if
!
defined
(
XP_WIN
)
if
(
!
mUpdateCursor
&
&
mCursor
=
=
aCursor
&
&
mCustomCursor
=
=
aCursorImage
&
&
(
!
aCursorImage
|
|
(
mCursorHotspotX
=
=
aHotspotX
&
&
mCursorHotspotY
=
=
aHotspotY
)
)
)
{
return
;
}
#
endif
bool
hasCustomCursor
=
false
;
UniquePtr
<
char
[
]
>
customCursorData
;
size_t
length
=
0
;
IntSize
customCursorSize
;
int32_t
stride
=
0
;
auto
format
=
SurfaceFormat
:
:
B8G8R8A8
;
bool
force
=
mUpdateCursor
;
if
(
aCursorImage
)
{
RefPtr
<
SourceSurface
>
surface
=
aCursorImage
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
if
(
surface
)
{
if
(
RefPtr
<
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
)
{
hasCustomCursor
=
true
;
customCursorData
=
nsContentUtils
:
:
GetSurfaceData
(
WrapNotNull
(
dataSurface
)
&
length
&
stride
)
;
customCursorSize
=
dataSurface
-
>
GetSize
(
)
;
format
=
dataSurface
-
>
GetFormat
(
)
;
}
}
}
mCustomCursor
=
nullptr
;
nsDependentCString
cursorData
(
customCursorData
?
customCursorData
.
get
(
)
:
"
"
length
)
;
if
(
!
mTabChild
-
>
SendSetCursor
(
aCursor
hasCustomCursor
cursorData
customCursorSize
.
width
customCursorSize
.
height
stride
format
aHotspotX
aHotspotY
force
)
)
{
return
;
}
mCursor
=
aCursor
;
mCustomCursor
=
aCursorImage
;
mCursorHotspotX
=
aHotspotX
;
mCursorHotspotY
=
aHotspotY
;
mUpdateCursor
=
false
;
}
void
PuppetWidget
:
:
ClearCachedCursor
(
)
{
nsBaseWidget
:
:
ClearCachedCursor
(
)
;
mCustomCursor
=
nullptr
;
}
nsresult
PuppetWidget
:
:
Paint
(
)
{
MOZ_ASSERT
(
!
mDirtyRegion
.
IsEmpty
(
)
"
paint
event
logic
messed
up
"
)
;
if
(
!
GetCurrentWidgetListener
(
)
)
return
NS_OK
;
LayoutDeviceIntRegion
region
=
mDirtyRegion
;
mDirtyRegion
.
SetEmpty
(
)
;
mPaintTask
.
Revoke
(
)
;
RefPtr
<
PuppetWidget
>
strongThis
(
this
)
;
GetCurrentWidgetListener
(
)
-
>
WillPaintWindow
(
this
)
;
if
(
GetCurrentWidgetListener
(
)
)
{
#
ifdef
DEBUG
debug_DumpPaintEvent
(
stderr
this
region
.
ToUnknownRegion
(
)
"
PuppetWidget
"
0
)
;
#
endif
if
(
mLayerManager
-
>
GetBackendType
(
)
=
=
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_CLIENT
|
|
mLayerManager
-
>
GetBackendType
(
)
=
=
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_WR
|
|
(
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_BASIC
=
=
mLayerManager
-
>
GetBackendType
(
)
&
&
mTabChild
&
&
mTabChild
-
>
IsLayersConnected
(
)
.
isSome
(
)
)
)
{
if
(
mTabChild
)
{
mTabChild
-
>
NotifyPainted
(
)
;
}
}
else
if
(
mozilla
:
:
layers
:
:
LayersBackend
:
:
LAYERS_BASIC
=
=
mLayerManager
-
>
GetBackendType
(
)
)
{
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
mDrawTarget
)
;
if
(
!
ctx
)
{
gfxDevCrash
(
LogReason
:
:
InvalidContext
)
<
<
"
PuppetWidget
context
problem
"
<
<
gfx
:
:
hexa
(
mDrawTarget
)
;
return
NS_ERROR_FAILURE
;
}
ctx
-
>
Rectangle
(
gfxRect
(
0
0
0
0
)
)
;
ctx
-
>
Clip
(
)
;
AutoLayerManagerSetup
setupLayerManager
(
this
ctx
BufferMode
:
:
BUFFER_NONE
)
;
GetCurrentWidgetListener
(
)
-
>
PaintWindow
(
this
region
)
;
if
(
mTabChild
)
{
mTabChild
-
>
NotifyPainted
(
)
;
}
}
}
if
(
GetCurrentWidgetListener
(
)
)
{
GetCurrentWidgetListener
(
)
-
>
DidPaintWindow
(
)
;
}
return
NS_OK
;
}
void
PuppetWidget
:
:
SetChild
(
PuppetWidget
*
aChild
)
{
MOZ_ASSERT
(
this
!
=
aChild
"
can
'
t
parent
a
widget
to
itself
"
)
;
MOZ_ASSERT
(
!
aChild
-
>
mChild
"
fake
widget
'
hierarchy
'
only
expected
to
have
one
level
"
)
;
mChild
=
aChild
;
}
NS_IMETHODIMP
PuppetWidget
:
:
PaintTask
:
:
Run
(
)
{
if
(
mWidget
)
{
mWidget
-
>
Paint
(
)
;
}
return
NS_OK
;
}
void
PuppetWidget
:
:
PaintNowIfNeeded
(
)
{
if
(
IsVisible
(
)
&
&
mPaintTask
.
IsPending
(
)
)
{
Paint
(
)
;
}
}
void
PuppetWidget
:
:
OnMemoryPressure
(
layers
:
:
MemoryPressureReason
aWhy
)
{
if
(
aWhy
!
=
MemoryPressureReason
:
:
LOW_MEMORY_ONGOING
&
&
!
mVisible
&
&
mLayerManager
&
&
XRE_IsContentProcess
(
)
)
{
mLayerManager
-
>
ClearCachedResources
(
)
;
}
}
bool
PuppetWidget
:
:
NeedsPaint
(
)
{
if
(
XRE_IsContentProcess
(
)
&
&
gRemoteDesktopBehaviorEnabled
&
&
mWindowType
=
=
eWindowType_popup
)
{
NS_WARNING
(
"
Trying
to
paint
an
e10s
popup
in
the
child
process
!
"
)
;
return
false
;
}
return
mVisible
;
}
float
PuppetWidget
:
:
GetDPI
(
)
{
return
mDPI
;
}
double
PuppetWidget
:
:
GetDefaultScaleInternal
(
)
{
return
mDefaultScale
;
}
int32_t
PuppetWidget
:
:
RoundsWidgetCoordinatesTo
(
)
{
return
mRounding
;
}
void
*
PuppetWidget
:
:
GetNativeData
(
uint32_t
aDataType
)
{
switch
(
aDataType
)
{
case
NS_NATIVE_SHAREABLE_WINDOW
:
{
if
(
!
mTabChild
)
{
NS_WARNING
(
"
Need
TabChild
to
get
the
nativeWindow
from
!
"
)
;
}
mozilla
:
:
WindowsHandle
nativeData
=
0
;
if
(
mTabChild
)
{
nativeData
=
mTabChild
-
>
WidgetNativeData
(
)
;
}
return
(
void
*
)
nativeData
;
}
case
NS_NATIVE_WINDOW
:
case
NS_NATIVE_WIDGET
:
case
NS_NATIVE_DISPLAY
:
break
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
MOZ_CRASH
(
"
You
need
to
call
GetNativeIMEContext
(
)
instead
"
)
;
case
NS_NATIVE_PLUGIN_PORT
:
case
NS_NATIVE_GRAPHIC
:
case
NS_NATIVE_SHELLWIDGET
:
default
:
NS_WARNING
(
"
nsWindow
:
:
GetNativeData
called
with
bad
value
"
)
;
break
;
}
return
nullptr
;
}
#
if
defined
(
XP_WIN
)
void
PuppetWidget
:
:
SetNativeData
(
uint32_t
aDataType
uintptr_t
aVal
)
{
switch
(
aDataType
)
{
case
NS_NATIVE_CHILD_OF_SHAREABLE_WINDOW
:
MOZ_ASSERT
(
mTabChild
"
Need
TabChild
to
send
the
message
.
"
)
;
if
(
mTabChild
)
{
mTabChild
-
>
SendSetNativeChildOfShareableWindow
(
aVal
)
;
}
break
;
default
:
NS_WARNING
(
"
SetNativeData
called
with
unsupported
data
type
.
"
)
;
}
}
#
endif
LayoutDeviceIntPoint
PuppetWidget
:
:
GetChromeOffset
(
)
{
if
(
!
GetOwningTabChild
(
)
)
{
NS_WARNING
(
"
PuppetWidget
without
Tab
does
not
have
chrome
information
.
"
)
;
return
LayoutDeviceIntPoint
(
)
;
}
return
GetOwningTabChild
(
)
-
>
GetChromeOffset
(
)
;
}
LayoutDeviceIntPoint
PuppetWidget
:
:
GetWindowPosition
(
)
{
if
(
!
GetOwningTabChild
(
)
)
{
return
LayoutDeviceIntPoint
(
)
;
}
int32_t
winX
winY
winW
winH
;
NS_ENSURE_SUCCESS
(
GetOwningTabChild
(
)
-
>
GetDimensions
(
0
&
winX
&
winY
&
winW
&
winH
)
LayoutDeviceIntPoint
(
)
)
;
return
LayoutDeviceIntPoint
(
winX
winY
)
+
GetOwningTabChild
(
)
-
>
GetClientOffset
(
)
;
}
LayoutDeviceIntRect
PuppetWidget
:
:
GetScreenBounds
(
)
{
return
LayoutDeviceIntRect
(
WidgetToScreenOffset
(
)
mBounds
.
Size
(
)
)
;
}
uint32_t
PuppetWidget
:
:
GetMaxTouchPoints
(
)
const
{
uint32_t
maxTouchPoints
=
0
;
if
(
mTabChild
)
{
mTabChild
-
>
GetMaxTouchPoints
(
&
maxTouchPoints
)
;
}
return
maxTouchPoints
;
}
void
PuppetWidget
:
:
StartAsyncScrollbarDrag
(
const
AsyncDragMetrics
&
aDragMetrics
)
{
mTabChild
-
>
StartScrollbarDrag
(
aDragMetrics
)
;
}
PuppetScreen
:
:
PuppetScreen
(
void
*
nativeScreen
)
{
}
PuppetScreen
:
:
~
PuppetScreen
(
)
{
}
static
ScreenConfiguration
ScreenConfig
(
)
{
ScreenConfiguration
config
;
hal
:
:
GetCurrentScreenConfiguration
(
&
config
)
;
return
config
;
}
nsIntSize
PuppetWidget
:
:
GetScreenDimensions
(
)
{
nsIntRect
r
=
ScreenConfig
(
)
.
rect
(
)
;
return
nsIntSize
(
r
.
Width
(
)
r
.
Height
(
)
)
;
}
NS_IMETHODIMP
PuppetScreen
:
:
GetRect
(
int32_t
*
outLeft
int32_t
*
outTop
int32_t
*
outWidth
int32_t
*
outHeight
)
{
nsIntRect
r
=
ScreenConfig
(
)
.
rect
(
)
;
r
.
GetRect
(
outLeft
outTop
outWidth
outHeight
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PuppetScreen
:
:
GetAvailRect
(
int32_t
*
outLeft
int32_t
*
outTop
int32_t
*
outWidth
int32_t
*
outHeight
)
{
return
GetRect
(
outLeft
outTop
outWidth
outHeight
)
;
}
NS_IMETHODIMP
PuppetScreen
:
:
GetPixelDepth
(
int32_t
*
aPixelDepth
)
{
*
aPixelDepth
=
ScreenConfig
(
)
.
pixelDepth
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PuppetScreen
:
:
GetColorDepth
(
int32_t
*
aColorDepth
)
{
*
aColorDepth
=
ScreenConfig
(
)
.
colorDepth
(
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
PuppetScreenManager
nsIScreenManager
)
PuppetScreenManager
:
:
PuppetScreenManager
(
)
{
mOneScreen
=
new
PuppetScreen
(
nullptr
)
;
}
PuppetScreenManager
:
:
~
PuppetScreenManager
(
)
{
}
NS_IMETHODIMP
PuppetScreenManager
:
:
GetPrimaryScreen
(
nsIScreen
*
*
outScreen
)
{
NS_IF_ADDREF
(
*
outScreen
=
mOneScreen
.
get
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PuppetScreenManager
:
:
ScreenForRect
(
int32_t
inLeft
int32_t
inTop
int32_t
inWidth
int32_t
inHeight
nsIScreen
*
*
outScreen
)
{
return
GetPrimaryScreen
(
outScreen
)
;
}
nsIWidgetListener
*
PuppetWidget
:
:
GetCurrentWidgetListener
(
)
{
if
(
!
mPreviouslyAttachedWidgetListener
|
|
!
mAttachedWidgetListener
)
{
return
mAttachedWidgetListener
;
}
if
(
mAttachedWidgetListener
-
>
GetView
(
)
-
>
IsPrimaryFramePaintSuppressed
(
)
)
{
return
mPreviouslyAttachedWidgetListener
;
}
return
mAttachedWidgetListener
;
}
void
PuppetWidget
:
:
SetCandidateWindowForPlugin
(
const
CandidateWindowPosition
&
aPosition
)
{
if
(
!
mTabChild
)
{
return
;
}
mTabChild
-
>
SendSetCandidateWindowForPlugin
(
aPosition
)
;
}
void
PuppetWidget
:
:
EnableIMEForPlugin
(
bool
aEnable
)
{
if
(
!
mTabChild
)
{
return
;
}
if
(
NS_WARN_IF
(
HaveValidInputContextCache
(
)
&
&
mInputContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
UNKNOWN
&
&
mInputContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
PLUGIN
)
)
{
return
;
}
mTabChild
-
>
SendEnableIMEForPlugin
(
aEnable
)
;
}
void
PuppetWidget
:
:
ZoomToRect
(
const
uint32_t
&
aPresShellId
const
ScrollableLayerGuid
:
:
ViewID
&
aViewId
const
CSSRect
&
aRect
const
uint32_t
&
aFlags
)
{
if
(
!
mTabChild
)
{
return
;
}
mTabChild
-
>
ZoomToRect
(
aPresShellId
aViewId
aRect
aFlags
)
;
}
void
PuppetWidget
:
:
LookUpDictionary
(
const
nsAString
&
aText
const
nsTArray
<
mozilla
:
:
FontRange
>
&
aFontRangeArray
const
bool
aIsVertical
const
LayoutDeviceIntPoint
&
aPoint
)
{
if
(
!
mTabChild
)
{
return
;
}
mTabChild
-
>
SendLookUpDictionary
(
nsString
(
aText
)
aFontRangeArray
aIsVertical
aPoint
)
;
}
bool
PuppetWidget
:
:
HasPendingInputEvent
(
)
{
if
(
!
mTabChild
)
{
return
false
;
}
bool
ret
=
false
;
mTabChild
-
>
GetIPCChannel
(
)
-
>
PeekMessages
(
[
&
ret
]
(
const
IPC
:
:
Message
&
aMsg
)
-
>
bool
{
if
(
nsContentUtils
:
:
IsMessageInputEvent
(
aMsg
)
)
{
ret
=
true
;
return
false
;
}
return
true
;
}
)
;
return
ret
;
}
void
PuppetWidget
:
:
HandledWindowedPluginKeyEvent
(
const
NativeEventData
&
aKeyEventData
bool
aIsConsumed
)
{
if
(
NS_WARN_IF
(
mKeyEventInPluginCallbacks
.
IsEmpty
(
)
)
)
{
return
;
}
nsCOMPtr
<
nsIKeyEventInPluginCallback
>
callback
=
mKeyEventInPluginCallbacks
[
0
]
;
MOZ_ASSERT
(
callback
)
;
mKeyEventInPluginCallbacks
.
RemoveElementAt
(
0
)
;
callback
-
>
HandledWindowedPluginKeyEvent
(
aKeyEventData
aIsConsumed
)
;
}
nsresult
PuppetWidget
:
:
OnWindowedPluginKeyEvent
(
const
NativeEventData
&
aKeyEventData
nsIKeyEventInPluginCallback
*
aCallback
)
{
if
(
NS_WARN_IF
(
!
mTabChild
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
NS_WARN_IF
(
!
mTabChild
-
>
SendOnWindowedPluginKeyEvent
(
aKeyEventData
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mKeyEventInPluginCallbacks
.
AppendElement
(
aCallback
)
;
return
NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY
;
}
NS_IMETHODIMP
PuppetWidget
:
:
NotifyIME
(
TextEventDispatcher
*
aTextEventDispatcher
const
IMENotification
&
aIMENotification
)
{
MOZ_ASSERT
(
aTextEventDispatcher
=
=
mTextEventDispatcher
)
;
if
(
mNativeTextEventDispatcherListener
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
switch
(
aIMENotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
return
RequestIMEToCommitComposition
(
false
)
;
case
REQUEST_TO_CANCEL_COMPOSITION
:
return
RequestIMEToCommitComposition
(
true
)
;
case
NOTIFY_IME_OF_FOCUS
:
case
NOTIFY_IME_OF_BLUR
:
return
NotifyIMEOfFocusChange
(
aIMENotification
)
;
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
return
NotifyIMEOfSelectionChange
(
aIMENotification
)
;
case
NOTIFY_IME_OF_TEXT_CHANGE
:
return
NotifyIMEOfTextChange
(
aIMENotification
)
;
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
return
NotifyIMEOfCompositionUpdate
(
aIMENotification
)
;
case
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
:
return
NotifyIMEOfMouseButtonEvent
(
aIMENotification
)
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
return
NotifyIMEOfPositionChange
(
aIMENotification
)
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP_
(
IMENotificationRequests
)
PuppetWidget
:
:
GetIMENotificationRequests
(
)
{
if
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
{
return
IMENotificationRequests
(
mIMENotificationRequestsOfParent
.
mWantUpdates
|
IMENotificationRequests
:
:
NOTIFY_POSITION_CHANGE
)
;
}
return
IMENotificationRequests
(
mIMENotificationRequestsOfParent
.
mWantUpdates
|
IMENotificationRequests
:
:
NOTIFY_TEXT_CHANGE
|
IMENotificationRequests
:
:
NOTIFY_POSITION_CHANGE
)
;
}
NS_IMETHODIMP_
(
void
)
PuppetWidget
:
:
OnRemovedFrom
(
TextEventDispatcher
*
aTextEventDispatcher
)
{
MOZ_ASSERT
(
aTextEventDispatcher
=
=
mTextEventDispatcher
)
;
}
NS_IMETHODIMP_
(
void
)
PuppetWidget
:
:
WillDispatchKeyboardEvent
(
TextEventDispatcher
*
aTextEventDispatcher
WidgetKeyboardEvent
&
aKeyboardEvent
uint32_t
aIndexOfKeypress
void
*
aData
)
{
MOZ_ASSERT
(
aTextEventDispatcher
=
=
mTextEventDispatcher
)
;
}
nsresult
PuppetWidget
:
:
SetSystemFont
(
const
nsCString
&
aFontName
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendSetSystemFont
(
aFontName
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
GetSystemFont
(
nsCString
&
aFontName
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
mTabChild
-
>
SendGetSystemFont
(
&
aFontName
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
SetPrefersReducedMotionOverrideForTest
(
bool
aValue
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
nsXPLookAndFeel
:
:
GetInstance
(
)
-
>
SetPrefersReducedMotionOverrideForTest
(
aValue
)
;
mTabChild
-
>
SendSetPrefersReducedMotionOverrideForTest
(
aValue
)
;
return
NS_OK
;
}
nsresult
PuppetWidget
:
:
ResetPrefersReducedMotionOverrideForTest
(
)
{
if
(
!
mTabChild
)
{
return
NS_ERROR_FAILURE
;
}
nsXPLookAndFeel
:
:
GetInstance
(
)
-
>
ResetPrefersReducedMotionOverrideForTest
(
)
;
mTabChild
-
>
SendResetPrefersReducedMotionOverrideForTest
(
)
;
return
NS_OK
;
}
}
}
