#
ifndef
mozilla_ContentCache_h
#
define
mozilla_ContentCache_h
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
Units
.
h
"
namespace
mozilla
{
class
ContentCacheInParent
;
class
ContentCache
{
public
:
typedef
InfallibleTArray
<
LayoutDeviceIntRect
>
RectArray
;
typedef
widget
:
:
IMENotification
IMENotification
;
ContentCache
(
)
;
protected
:
nsString
mText
;
uint32_t
mCompositionStart
;
enum
{
ePrevCharRect
=
1
eNextCharRect
=
0
}
;
struct
Selection
final
{
uint32_t
mAnchor
;
uint32_t
mFocus
;
WritingMode
mWritingMode
;
LayoutDeviceIntRect
mAnchorCharRects
[
2
]
;
LayoutDeviceIntRect
mFocusCharRects
[
2
]
;
LayoutDeviceIntRect
mRect
;
Selection
(
)
:
mAnchor
(
UINT32_MAX
)
mFocus
(
UINT32_MAX
)
{
}
void
Clear
(
)
{
mAnchor
=
mFocus
=
UINT32_MAX
;
mWritingMode
=
WritingMode
(
)
;
ClearAnchorCharRects
(
)
;
ClearFocusCharRects
(
)
;
mRect
.
SetEmpty
(
)
;
}
void
ClearAnchorCharRects
(
)
{
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mAnchorCharRects
)
;
i
+
+
)
{
mAnchorCharRects
[
i
]
.
SetEmpty
(
)
;
}
}
void
ClearFocusCharRects
(
)
{
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mFocusCharRects
)
;
i
+
+
)
{
mFocusCharRects
[
i
]
.
SetEmpty
(
)
;
}
}
bool
IsValid
(
)
const
{
return
mAnchor
!
=
UINT32_MAX
&
&
mFocus
!
=
UINT32_MAX
;
}
bool
Collapsed
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
mFocus
=
=
mAnchor
;
}
bool
Reversed
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
mFocus
<
mAnchor
;
}
uint32_t
StartOffset
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
Reversed
(
)
?
mFocus
:
mAnchor
;
}
uint32_t
EndOffset
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
Reversed
(
)
?
mAnchor
:
mFocus
;
}
uint32_t
Length
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
Reversed
(
)
?
mAnchor
-
mFocus
:
mFocus
-
mAnchor
;
}
LayoutDeviceIntRect
StartCharRect
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
Reversed
(
)
?
mFocusCharRects
[
eNextCharRect
]
:
mAnchorCharRects
[
eNextCharRect
]
;
}
LayoutDeviceIntRect
EndCharRect
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
selection
is
valid
"
)
;
return
Reversed
(
)
?
mAnchorCharRects
[
eNextCharRect
]
:
mFocusCharRects
[
eNextCharRect
]
;
}
}
mSelection
;
bool
IsSelectionValid
(
)
const
{
return
mSelection
.
IsValid
(
)
&
&
mSelection
.
EndOffset
(
)
<
=
mText
.
Length
(
)
;
}
LayoutDeviceIntRect
mFirstCharRect
;
struct
Caret
final
{
uint32_t
mOffset
;
LayoutDeviceIntRect
mRect
;
Caret
(
)
:
mOffset
(
UINT32_MAX
)
{
}
void
Clear
(
)
{
mOffset
=
UINT32_MAX
;
mRect
.
SetEmpty
(
)
;
}
bool
IsValid
(
)
const
{
return
mOffset
!
=
UINT32_MAX
;
}
uint32_t
Offset
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
caret
is
valid
"
)
;
return
mOffset
;
}
}
mCaret
;
struct
TextRectArray
final
{
uint32_t
mStart
;
RectArray
mRects
;
TextRectArray
(
)
:
mStart
(
UINT32_MAX
)
{
}
void
Clear
(
)
{
mStart
=
UINT32_MAX
;
mRects
.
Clear
(
)
;
}
bool
IsValid
(
)
const
{
if
(
mStart
=
=
UINT32_MAX
)
{
return
false
;
}
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
mStart
)
+
mRects
.
Length
(
)
;
return
endOffset
.
isValid
(
)
;
}
bool
HasRects
(
)
const
{
return
IsValid
(
)
&
&
!
mRects
.
IsEmpty
(
)
;
}
uint32_t
StartOffset
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
caret
is
valid
"
)
;
return
mStart
;
}
uint32_t
EndOffset
(
)
const
{
NS_ASSERTION
(
IsValid
(
)
"
The
caller
should
check
if
the
caret
is
valid
"
)
;
if
(
!
IsValid
(
)
)
{
return
UINT32_MAX
;
}
return
mStart
+
mRects
.
Length
(
)
;
}
bool
InRange
(
uint32_t
aOffset
)
const
{
return
IsValid
(
)
&
&
StartOffset
(
)
<
=
aOffset
&
&
aOffset
<
EndOffset
(
)
;
}
bool
InRange
(
uint32_t
aOffset
uint32_t
aLength
)
const
{
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
aOffset
)
+
aLength
;
if
(
NS_WARN_IF
(
!
endOffset
.
isValid
(
)
)
)
{
return
false
;
}
return
InRange
(
aOffset
)
&
&
aOffset
+
aLength
<
=
EndOffset
(
)
;
}
bool
IsOverlappingWith
(
uint32_t
aOffset
uint32_t
aLength
)
const
{
if
(
!
HasRects
(
)
|
|
aOffset
=
=
UINT32_MAX
|
|
!
aLength
)
{
return
false
;
}
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
aOffset
)
+
aLength
;
if
(
NS_WARN_IF
(
!
endOffset
.
isValid
(
)
)
)
{
return
false
;
}
return
aOffset
<
EndOffset
(
)
&
&
endOffset
.
value
(
)
>
mStart
;
}
LayoutDeviceIntRect
GetRect
(
uint32_t
aOffset
)
const
;
LayoutDeviceIntRect
GetUnionRect
(
uint32_t
aOffset
uint32_t
aLength
)
const
;
LayoutDeviceIntRect
GetUnionRectAsFarAsPossible
(
uint32_t
aOffset
uint32_t
aLength
bool
aRoundToExistingOffset
)
const
;
}
mTextRectArray
;
LayoutDeviceIntRect
mEditorRect
;
friend
class
ContentCacheInParent
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
>
;
}
;
class
ContentCacheInChild
final
:
public
ContentCache
{
public
:
ContentCacheInChild
(
)
;
void
Clear
(
)
;
bool
CacheEditorRect
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheSelection
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheText
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheAll
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
void
SetSelection
(
nsIWidget
*
aWidget
uint32_t
aStartOffset
uint32_t
aLength
bool
aReversed
const
WritingMode
&
aWritingMode
)
;
private
:
bool
QueryCharRect
(
nsIWidget
*
aWidget
uint32_t
aOffset
LayoutDeviceIntRect
&
aCharRect
)
const
;
bool
QueryCharRectArray
(
nsIWidget
*
aWidget
uint32_t
aOffset
uint32_t
aLength
RectArray
&
aCharRectArray
)
const
;
bool
CacheCaret
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheTextRects
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
}
;
class
ContentCacheInParent
final
:
public
ContentCache
{
public
:
ContentCacheInParent
(
)
;
void
AssignContent
(
const
ContentCache
&
aOther
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
HandleQueryContentEvent
(
WidgetQueryContentEvent
&
aEvent
nsIWidget
*
aWidget
)
const
;
bool
OnCompositionEvent
(
const
WidgetCompositionEvent
&
aCompositionEvent
)
;
void
OnSelectionEvent
(
const
WidgetSelectionEvent
&
aSelectionEvent
)
;
void
OnEventNeedingAckHandled
(
nsIWidget
*
aWidget
EventMessage
aMessage
)
;
bool
RequestIMEToCommitComposition
(
nsIWidget
*
aWidget
bool
aCancel
nsAString
&
aCommittedString
)
;
void
MaybeNotifyIME
(
nsIWidget
*
aWidget
const
IMENotification
&
aNotification
)
;
private
:
IMENotification
mPendingSelectionChange
;
IMENotification
mPendingTextChange
;
IMENotification
mPendingLayoutChange
;
IMENotification
mPendingCompositionUpdate
;
nsAString
*
mCommitStringByRequest
;
uint32_t
mPendingEventsNeedingAck
;
uint32_t
mCompositionStartInChild
;
uint8_t
mPendingCompositionCount
;
bool
mWidgetHasComposition
;
bool
GetCaretRect
(
uint32_t
aOffset
bool
aRoundToExistingOffset
LayoutDeviceIntRect
&
aCaretRect
)
const
;
bool
GetTextRect
(
uint32_t
aOffset
bool
aRoundToExistingOffset
LayoutDeviceIntRect
&
aTextRect
)
const
;
bool
GetUnionTextRects
(
uint32_t
aOffset
uint32_t
aLength
bool
aRoundToExistingOffset
LayoutDeviceIntRect
&
aUnionTextRect
)
const
;
void
FlushPendingNotifications
(
nsIWidget
*
aWidget
)
;
}
;
}
#
endif
