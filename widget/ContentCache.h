#
ifndef
mozilla_ContentCache_h
#
define
mozilla_ContentCache_h
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
widget
/
IMEData
.
h
"
#
include
"
mozilla
/
ipc
/
IPCForwards
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
Units
.
h
"
class
nsIWidget
;
namespace
mozilla
{
class
ContentCacheInParent
;
namespace
dom
{
class
BrowserParent
;
}
class
ContentCache
{
public
:
using
RectArray
=
CopyableTArray
<
LayoutDeviceIntRect
>
;
using
IMENotification
=
widget
:
:
IMENotification
;
ContentCache
(
)
=
default
;
[
[
nodiscard
]
]
bool
IsValid
(
)
const
;
protected
:
Maybe
<
nsString
>
mText
;
Maybe
<
uint32_t
>
mCompositionStart
;
enum
{
ePrevCharRect
=
1
eNextCharRect
=
0
}
;
struct
Selection
final
{
uint32_t
mAnchor
;
uint32_t
mFocus
;
WritingMode
mWritingMode
;
bool
mHasRange
;
LayoutDeviceIntRect
mAnchorCharRects
[
2
]
;
LayoutDeviceIntRect
mFocusCharRects
[
2
]
;
LayoutDeviceIntRect
mRect
;
Selection
(
)
:
mAnchor
(
UINT32_MAX
)
mFocus
(
UINT32_MAX
)
mHasRange
(
false
)
{
ClearRects
(
)
;
}
;
explicit
Selection
(
const
IMENotification
:
:
SelectionChangeDataBase
&
aSelectionChangeData
)
:
mAnchor
(
UINT32_MAX
)
mFocus
(
UINT32_MAX
)
mWritingMode
(
aSelectionChangeData
.
GetWritingMode
(
)
)
mHasRange
(
aSelectionChangeData
.
HasRange
(
)
)
{
if
(
mHasRange
)
{
mAnchor
=
aSelectionChangeData
.
AnchorOffset
(
)
;
mFocus
=
aSelectionChangeData
.
FocusOffset
(
)
;
}
}
[
[
nodiscard
]
]
bool
IsValidIn
(
const
nsAString
&
aText
)
const
{
return
!
mHasRange
|
|
(
mAnchor
<
=
aText
.
Length
(
)
&
&
mFocus
<
=
aText
.
Length
(
)
)
;
}
explicit
Selection
(
const
WidgetQueryContentEvent
&
aQuerySelectedTextEvent
)
;
void
ClearRects
(
)
{
for
(
auto
&
rect
:
mAnchorCharRects
)
{
rect
.
SetEmpty
(
)
;
}
for
(
auto
&
rect
:
mFocusCharRects
)
{
rect
.
SetEmpty
(
)
;
}
mRect
.
SetEmpty
(
)
;
}
bool
HasRects
(
)
const
{
for
(
const
auto
&
rect
:
mAnchorCharRects
)
{
if
(
!
rect
.
IsEmpty
(
)
)
{
return
true
;
}
}
for
(
const
auto
&
rect
:
mFocusCharRects
)
{
if
(
!
rect
.
IsEmpty
(
)
)
{
return
true
;
}
}
return
!
mRect
.
IsEmpty
(
)
;
}
bool
IsCollapsed
(
)
const
{
return
!
mHasRange
|
|
mFocus
=
=
mAnchor
;
}
bool
Reversed
(
)
const
{
MOZ_ASSERT
(
mHasRange
)
;
return
mFocus
<
mAnchor
;
}
uint32_t
StartOffset
(
)
const
{
MOZ_ASSERT
(
mHasRange
)
;
return
Reversed
(
)
?
mFocus
:
mAnchor
;
}
uint32_t
EndOffset
(
)
const
{
MOZ_ASSERT
(
mHasRange
)
;
return
Reversed
(
)
?
mAnchor
:
mFocus
;
}
uint32_t
Length
(
)
const
{
MOZ_ASSERT
(
mHasRange
)
;
return
Reversed
(
)
?
mAnchor
-
mFocus
:
mFocus
-
mAnchor
;
}
LayoutDeviceIntRect
StartCharRect
(
)
const
{
return
Reversed
(
)
?
mFocusCharRects
[
eNextCharRect
]
:
mAnchorCharRects
[
eNextCharRect
]
;
}
LayoutDeviceIntRect
EndCharRect
(
)
const
{
return
Reversed
(
)
?
mAnchorCharRects
[
eNextCharRect
]
:
mFocusCharRects
[
eNextCharRect
]
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Selection
&
aSelection
)
{
aStream
<
<
"
{
"
;
if
(
!
aSelection
.
mHasRange
)
{
aStream
<
<
"
HasRange
(
)
=
false
"
;
}
else
{
aStream
<
<
"
mAnchor
=
"
<
<
aSelection
.
mAnchor
<
<
"
mFocus
=
"
<
<
aSelection
.
mFocus
<
<
"
mWritingMode
=
"
<
<
ToString
(
aSelection
.
mWritingMode
)
.
c_str
(
)
;
}
if
(
aSelection
.
HasRects
(
)
)
{
if
(
aSelection
.
mAnchor
>
0
)
{
aStream
<
<
"
mAnchorCharRects
[
ePrevCharRect
]
=
"
<
<
aSelection
.
mAnchorCharRects
[
ContentCache
:
:
ePrevCharRect
]
;
}
aStream
<
<
"
mAnchorCharRects
[
eNextCharRect
]
=
"
<
<
aSelection
.
mAnchorCharRects
[
ContentCache
:
:
eNextCharRect
]
;
if
(
aSelection
.
mFocus
>
0
)
{
aStream
<
<
"
mFocusCharRects
[
ePrevCharRect
]
=
"
<
<
aSelection
.
mFocusCharRects
[
ContentCache
:
:
ePrevCharRect
]
;
}
aStream
<
<
"
mFocusCharRects
[
eNextCharRect
]
=
"
<
<
aSelection
.
mFocusCharRects
[
ContentCache
:
:
eNextCharRect
]
<
<
"
mRect
=
"
<
<
aSelection
.
mRect
;
}
if
(
aSelection
.
mHasRange
)
{
aStream
<
<
"
Reversed
(
)
=
"
<
<
(
aSelection
.
Reversed
(
)
?
"
true
"
:
"
false
"
)
<
<
"
StartOffset
(
)
=
"
<
<
aSelection
.
StartOffset
(
)
<
<
"
EndOffset
(
)
=
"
<
<
aSelection
.
EndOffset
(
)
<
<
"
IsCollapsed
(
)
=
"
<
<
(
aSelection
.
IsCollapsed
(
)
?
"
true
"
:
"
false
"
)
<
<
"
Length
(
)
=
"
<
<
aSelection
.
Length
(
)
;
}
aStream
<
<
"
}
"
;
return
aStream
;
}
}
;
Maybe
<
Selection
>
mSelection
;
LayoutDeviceIntRect
mFirstCharRect
;
struct
Caret
final
{
uint32_t
mOffset
=
0u
;
LayoutDeviceIntRect
mRect
;
explicit
Caret
(
uint32_t
aOffset
LayoutDeviceIntRect
aCaretRect
)
:
mOffset
(
aOffset
)
mRect
(
aCaretRect
)
{
}
uint32_t
Offset
(
)
const
{
return
mOffset
;
}
bool
HasRect
(
)
const
{
return
!
mRect
.
IsEmpty
(
)
;
}
[
[
nodiscard
]
]
bool
IsValidIn
(
const
nsAString
&
aText
)
const
{
return
mOffset
<
=
aText
.
Length
(
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Caret
&
aCaret
)
{
aStream
<
<
"
{
mOffset
=
"
<
<
aCaret
.
mOffset
;
if
(
aCaret
.
HasRect
(
)
)
{
aStream
<
<
"
mRect
=
"
<
<
aCaret
.
mRect
;
}
return
aStream
<
<
"
}
"
;
}
private
:
Caret
(
)
=
default
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
:
:
Caret
>
;
ALLOW_DEPRECATED_READPARAM
}
;
Maybe
<
Caret
>
mCaret
;
struct
TextRectArray
final
{
uint32_t
mStart
=
0u
;
RectArray
mRects
;
explicit
TextRectArray
(
uint32_t
aStartOffset
)
:
mStart
(
aStartOffset
)
{
}
bool
HasRects
(
)
const
{
return
Length
(
)
>
0
;
}
uint32_t
StartOffset
(
)
const
{
return
mStart
;
}
uint32_t
EndOffset
(
)
const
{
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
mStart
)
+
mRects
.
Length
(
)
;
return
endOffset
.
isValid
(
)
?
endOffset
.
value
(
)
:
UINT32_MAX
;
}
uint32_t
Length
(
)
const
{
return
EndOffset
(
)
-
mStart
;
}
bool
IsOffsetInRange
(
uint32_t
aOffset
)
const
{
return
StartOffset
(
)
<
=
aOffset
&
&
aOffset
<
EndOffset
(
)
;
}
bool
IsRangeCompletelyInRange
(
uint32_t
aOffset
uint32_t
aLength
)
const
{
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
aOffset
)
+
aLength
;
if
(
NS_WARN_IF
(
!
endOffset
.
isValid
(
)
)
)
{
return
false
;
}
return
IsOffsetInRange
(
aOffset
)
&
&
aOffset
+
aLength
<
=
EndOffset
(
)
;
}
bool
IsOverlappingWith
(
uint32_t
aOffset
uint32_t
aLength
)
const
{
if
(
!
HasRects
(
)
|
|
aOffset
=
=
UINT32_MAX
|
|
!
aLength
)
{
return
false
;
}
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
aOffset
)
+
aLength
;
if
(
NS_WARN_IF
(
!
endOffset
.
isValid
(
)
)
)
{
return
false
;
}
return
aOffset
<
EndOffset
(
)
&
&
endOffset
.
value
(
)
>
mStart
;
}
LayoutDeviceIntRect
GetRect
(
uint32_t
aOffset
)
const
;
LayoutDeviceIntRect
GetUnionRect
(
uint32_t
aOffset
uint32_t
aLength
)
const
;
LayoutDeviceIntRect
GetUnionRectAsFarAsPossible
(
uint32_t
aOffset
uint32_t
aLength
bool
aRoundToExistingOffset
)
const
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
TextRectArray
&
aTextRectArray
)
{
aStream
<
<
"
{
mStart
=
"
<
<
aTextRectArray
.
mStart
<
<
"
mRects
=
{
Length
(
)
=
"
<
<
aTextRectArray
.
Length
(
)
;
if
(
aTextRectArray
.
HasRects
(
)
)
{
aStream
<
<
"
Elements
(
)
=
[
"
;
static
constexpr
uint32_t
kMaxPrintRects
=
4
;
const
uint32_t
kFirstHalf
=
aTextRectArray
.
Length
(
)
<
=
kMaxPrintRects
?
UINT32_MAX
:
(
kMaxPrintRects
+
1
)
/
2
;
const
uint32_t
kSecondHalf
=
aTextRectArray
.
Length
(
)
<
=
kMaxPrintRects
?
0
:
kMaxPrintRects
/
2
;
for
(
uint32_t
i
=
0
;
i
<
aTextRectArray
.
Length
(
)
;
i
+
+
)
{
if
(
i
>
0
)
{
aStream
<
<
"
"
;
}
aStream
<
<
ToString
(
aTextRectArray
.
mRects
[
i
]
)
.
c_str
(
)
;
if
(
i
+
1
=
=
kFirstHalf
)
{
aStream
<
<
"
.
.
.
"
;
i
=
aTextRectArray
.
Length
(
)
-
kSecondHalf
-
1
;
}
}
}
return
aStream
<
<
"
]
}
}
"
;
}
private
:
TextRectArray
(
)
=
default
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
:
:
TextRectArray
>
;
ALLOW_DEPRECATED_READPARAM
}
;
Maybe
<
TextRectArray
>
mTextRectArray
;
Maybe
<
TextRectArray
>
mLastCommitStringTextRectArray
;
LayoutDeviceIntRect
mEditorRect
;
friend
class
ContentCacheInParent
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
>
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
:
:
Selection
>
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
:
:
Caret
>
;
friend
struct
IPC
:
:
ParamTraits
<
ContentCache
:
:
TextRectArray
>
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Selection
&
aSelection
)
;
ALLOW_DEPRECATED_READPARAM
}
;
class
ContentCacheInChild
final
:
public
ContentCache
{
public
:
ContentCacheInChild
(
)
=
default
;
void
OnCompositionEvent
(
const
WidgetCompositionEvent
&
aCompositionEvent
)
;
void
Clear
(
)
;
bool
CacheEditorRect
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheCaretAndTextRects
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheText
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheAll
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
[
[
nodiscard
]
]
bool
SetSelection
(
nsIWidget
*
aWidget
const
IMENotification
:
:
SelectionChangeDataBase
&
aSelectionChangeData
)
;
private
:
bool
QueryCharRect
(
nsIWidget
*
aWidget
uint32_t
aOffset
LayoutDeviceIntRect
&
aCharRect
)
const
;
bool
QueryCharRectArray
(
nsIWidget
*
aWidget
uint32_t
aOffset
uint32_t
aLength
RectArray
&
aCharRectArray
)
const
;
bool
CacheSelection
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheCaret
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
CacheTextRects
(
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
Maybe
<
OffsetAndData
<
uint32_t
>
>
mLastCommit
;
}
;
class
ContentCacheInParent
final
:
public
ContentCache
{
public
:
ContentCacheInParent
(
)
=
delete
;
explicit
ContentCacheInParent
(
dom
:
:
BrowserParent
&
aBrowserParent
)
;
void
AssignContent
(
const
ContentCache
&
aOther
nsIWidget
*
aWidget
const
IMENotification
*
aNotification
=
nullptr
)
;
bool
HandleQueryContentEvent
(
WidgetQueryContentEvent
&
aEvent
nsIWidget
*
aWidget
)
const
;
bool
OnCompositionEvent
(
const
WidgetCompositionEvent
&
aCompositionEvent
)
;
void
OnSelectionEvent
(
const
WidgetSelectionEvent
&
aSelectionEvent
)
;
void
OnEventNeedingAckHandled
(
nsIWidget
*
aWidget
EventMessage
aMessage
uint32_t
aCompositionId
)
;
bool
RequestIMEToCommitComposition
(
nsIWidget
*
aWidget
bool
aCancel
uint32_t
aCompositionId
nsAString
&
aCommittedString
)
;
void
MaybeNotifyIME
(
nsIWidget
*
aWidget
const
IMENotification
&
aNotification
)
;
private
:
struct
HandlingCompositionData
;
[
[
nodiscard
]
]
bool
WidgetHasComposition
(
)
const
{
return
!
mHandlingCompositions
.
IsEmpty
(
)
&
&
!
mHandlingCompositions
.
LastElement
(
)
.
mSentCommitEvent
;
}
[
[
nodiscard
]
]
bool
HasPendingCommit
(
)
const
{
for
(
const
HandlingCompositionData
&
data
:
mHandlingCompositions
)
{
if
(
data
.
mSentCommitEvent
)
{
return
true
;
}
}
return
false
;
}
[
[
nodiscard
]
]
uint32_t
PendingEventsNeedingAck
(
)
const
{
uint32_t
ret
=
mPendingSetSelectionEventNeedingAck
;
for
(
const
HandlingCompositionData
&
data
:
mHandlingCompositions
)
{
ret
+
=
data
.
mPendingEventsNeedingAck
;
}
return
ret
;
}
[
[
nodiscard
]
]
HandlingCompositionData
*
GetHandlingCompositionData
(
uint32_t
aCompositionId
)
{
for
(
HandlingCompositionData
&
data
:
mHandlingCompositions
)
{
if
(
data
.
mCompositionId
=
=
aCompositionId
)
{
return
&
data
;
}
}
return
nullptr
;
}
[
[
nodiscard
]
]
const
HandlingCompositionData
*
GetHandlingCompositionData
(
uint32_t
aCompositionId
)
const
{
return
const_cast
<
ContentCacheInParent
*
>
(
this
)
-
>
GetHandlingCompositionData
(
aCompositionId
)
;
}
IMENotification
mPendingSelectionChange
;
IMENotification
mPendingTextChange
;
IMENotification
mPendingLayoutChange
;
IMENotification
mPendingCompositionUpdate
;
#
if
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsTArray
<
EventMessage
>
mDispatchedEventMessages
;
nsTArray
<
EventMessage
>
mReceivedEventMessages
;
enum
class
RequestIMEToCommitCompositionResult
:
uint8_t
{
eToOldCompositionReceived
eToUnknownCompositionReceived
eToCommittedCompositionReceived
eReceivedAfterBrowserParentBlur
eReceivedButNoTextComposition
eReceivedButForDifferentTextComposition
eHandledAsynchronously
eHandledSynchronously
}
;
const
char
*
ToReadableText
(
RequestIMEToCommitCompositionResult
aResult
)
const
{
switch
(
aResult
)
{
case
RequestIMEToCommitCompositionResult
:
:
eToOldCompositionReceived
:
return
"
Commit
request
is
not
handled
because
it
'
s
for
"
"
older
composition
"
;
case
RequestIMEToCommitCompositionResult
:
:
eToUnknownCompositionReceived
:
return
"
Commit
request
is
not
handled
because
it
'
s
for
"
"
unknown
composition
"
;
case
RequestIMEToCommitCompositionResult
:
:
eToCommittedCompositionReceived
:
return
"
Commit
request
is
not
handled
because
BrowserParent
has
"
"
already
"
"
sent
commit
event
for
the
composition
"
;
case
RequestIMEToCommitCompositionResult
:
:
eReceivedAfterBrowserParentBlur
:
return
"
Commit
request
is
handled
with
stored
composition
string
"
"
because
BrowserParent
has
already
lost
focus
"
;
case
RequestIMEToCommitCompositionResult
:
:
eReceivedButNoTextComposition
:
return
"
Commit
request
is
not
handled
because
there
is
no
"
"
TextComposition
instance
"
;
case
RequestIMEToCommitCompositionResult
:
:
eReceivedButForDifferentTextComposition
:
return
"
Commit
request
is
handled
with
stored
composition
string
"
"
because
new
TextComposition
is
active
"
;
case
RequestIMEToCommitCompositionResult
:
:
eHandledAsynchronously
:
return
"
Commit
request
is
handled
but
IME
doesn
'
t
commit
current
"
"
composition
synchronously
"
;
case
RequestIMEToCommitCompositionResult
:
:
eHandledSynchronously
:
return
"
Commit
request
is
handled
synchronously
"
;
default
:
return
"
Unknown
reason
"
;
}
}
nsTArray
<
RequestIMEToCommitCompositionResult
>
mRequestIMEToCommitCompositionResults
;
#
endif
struct
HandlingCompositionData
{
nsString
mCompositionString
;
uint32_t
mCompositionId
;
uint32_t
mPendingEventsNeedingAck
=
0u
;
bool
mSentCommitEvent
=
false
;
explicit
HandlingCompositionData
(
uint32_t
aCompositionId
)
:
mCompositionId
(
aCompositionId
)
{
}
}
;
AutoTArray
<
HandlingCompositionData
2
>
mHandlingCompositions
;
dom
:
:
BrowserParent
&
MOZ_NON_OWNING_REF
mBrowserParent
;
nsAString
*
mCommitStringByRequest
;
Maybe
<
uint32_t
>
mCompositionStartInChild
;
uint32_t
mPendingSetSelectionEventNeedingAck
=
0u
;
uint32_t
mPendingCommitLength
;
bool
mIsChildIgnoringCompositionEvents
;
bool
GetCaretRect
(
uint32_t
aOffset
bool
aRoundToExistingOffset
LayoutDeviceIntRect
&
aCaretRect
)
const
;
bool
GetTextRect
(
uint32_t
aOffset
bool
aRoundToExistingOffset
LayoutDeviceIntRect
&
aTextRect
)
const
;
bool
GetUnionTextRects
(
uint32_t
aOffset
uint32_t
aLength
bool
aRoundToExistingOffset
LayoutDeviceIntRect
&
aUnionTextRect
)
const
;
void
FlushPendingNotifications
(
nsIWidget
*
aWidget
)
;
#
if
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
RemoveUnnecessaryEventMessageLog
(
)
;
void
AppendEventMessageLog
(
nsACString
&
aLog
)
const
;
#
endif
}
;
}
#
endif
