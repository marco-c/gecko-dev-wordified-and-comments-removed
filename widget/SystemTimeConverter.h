#
ifndef
SystemTimeConverter_h
#
define
SystemTimeConverter_h
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
mozilla
/
TimeStamp
.
h
"
namespace
mozilla
{
template
<
typename
Time
typename
TimeStampNowProvider
=
TimeStamp
>
class
SystemTimeConverter
{
public
:
SystemTimeConverter
(
)
:
mReferenceTime
(
Time
(
0
)
)
mReferenceTimeStamp
(
)
mLastBackwardsSkewCheck
(
Time
(
0
)
)
kTimeRange
(
std
:
:
numeric_limits
<
Time
>
:
:
max
(
)
)
kTimeHalfRange
(
kTimeRange
/
2
)
kBackwardsSkewCheckInterval
(
Time
(
2000
)
)
{
static_assert
(
!
std
:
:
is_signed_v
<
Time
>
"
Expected
Time
to
be
unsigned
"
)
;
}
template
<
typename
CurrentTimeGetter
>
mozilla
:
:
TimeStamp
GetTimeStampFromSystemTime
(
Time
aTime
CurrentTimeGetter
&
aCurrentTimeGetter
)
{
TimeStamp
roughlyNow
=
TimeStampNowProvider
:
:
Now
(
)
;
if
(
mReferenceTimeStamp
.
IsNull
(
)
)
{
if
(
!
aTime
)
return
roughlyNow
;
UpdateReferenceTime
(
aTime
aCurrentTimeGetter
)
;
}
Time
deltaFromNow
;
bool
newer
=
IsTimeNewerThanTimestamp
(
aTime
roughlyNow
&
deltaFromNow
)
;
static
const
Time
kTolerance
=
30
;
if
(
newer
)
{
UpdateReferenceTime
(
aTime
roughlyNow
)
;
mLastBackwardsSkewCheck
=
aTime
;
return
roughlyNow
;
}
if
(
deltaFromNow
<
=
kTolerance
)
{
mLastBackwardsSkewCheck
=
aTime
;
}
else
if
(
aTime
-
mLastBackwardsSkewCheck
>
kBackwardsSkewCheckInterval
)
{
aCurrentTimeGetter
.
GetTimeAsyncForPossibleBackwardsSkew
(
roughlyNow
)
;
mLastBackwardsSkewCheck
=
aTime
;
}
return
roughlyNow
-
TimeDuration
:
:
FromMilliseconds
(
deltaFromNow
)
;
}
void
CompensateForBackwardsSkew
(
Time
aReferenceTime
const
TimeStamp
&
aLowerBound
)
{
Time
delta
;
if
(
IsTimeNewerThanTimestamp
(
aReferenceTime
aLowerBound
&
delta
)
)
{
return
;
}
UpdateReferenceTime
(
aReferenceTime
aLowerBound
)
;
}
private
:
template
<
typename
CurrentTimeGetter
>
void
UpdateReferenceTime
(
Time
aReferenceTime
const
CurrentTimeGetter
&
aCurrentTimeGetter
)
{
Time
currentTime
=
aCurrentTimeGetter
.
GetCurrentTime
(
)
;
TimeStamp
currentTimeStamp
=
TimeStampNowProvider
:
:
Now
(
)
;
Time
timeSinceReference
=
currentTime
-
aReferenceTime
;
TimeStamp
referenceTimeStamp
=
currentTimeStamp
-
TimeDuration
:
:
FromMilliseconds
(
timeSinceReference
)
;
UpdateReferenceTime
(
aReferenceTime
referenceTimeStamp
)
;
}
void
UpdateReferenceTime
(
Time
aReferenceTime
const
TimeStamp
&
aReferenceTimeStamp
)
{
mReferenceTime
=
aReferenceTime
;
mReferenceTimeStamp
=
aReferenceTimeStamp
;
}
bool
IsTimeNewerThanTimestamp
(
Time
aTime
TimeStamp
aTimeStamp
Time
*
aDelta
)
{
Time
timeDelta
=
aTime
-
mReferenceTime
;
Time
timeStampDelta
=
static_cast
<
int64_t
>
(
(
aTimeStamp
-
mReferenceTimeStamp
)
.
ToMilliseconds
(
)
)
;
Time
timeToTimeStamp
=
timeStampDelta
-
timeDelta
;
bool
isNewer
=
false
;
if
(
timeToTimeStamp
=
=
0
)
{
*
aDelta
=
0
;
}
else
if
(
timeToTimeStamp
<
kTimeHalfRange
)
{
*
aDelta
=
timeToTimeStamp
;
}
else
{
isNewer
=
true
;
*
aDelta
=
timeDelta
-
timeStampDelta
;
}
return
isNewer
;
}
Time
mReferenceTime
;
TimeStamp
mReferenceTimeStamp
;
Time
mLastBackwardsSkewCheck
;
const
Time
kTimeRange
;
const
Time
kTimeHalfRange
;
const
Time
kBackwardsSkewCheckInterval
;
}
;
}
#
endif
