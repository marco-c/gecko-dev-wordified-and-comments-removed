"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
gfx
/
layers
/
apz
/
test
/
mochitest
/
apz_test_utils
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
gfx
/
layers
/
apz
/
test
/
mochitest
/
apz_test_native_event_utils
.
js
"
this
)
;
async
function
waitForWhile
(
)
{
await
new
Promise
(
resolve
=
>
{
requestIdleCallback
(
resolve
{
timeout
:
300
}
)
;
}
)
;
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
}
const
NativePanHandlerForWindows
=
{
beginPhase
:
SpecialPowers
.
DOMWindowUtils
.
PHASE_BEGIN
updatePhase
:
SpecialPowers
.
DOMWindowUtils
.
PHASE_UPDATE
endPhase
:
SpecialPowers
.
DOMWindowUtils
.
PHASE_END
promiseNativePanEvent
:
promiseNativeTouchpadPanEventAndWaitForObserver
deltaOnRTL
:
50
}
;
const
NativePanHandlerForMac
=
{
beginPhase
:
1
updatePhase
:
2
endPhase
:
4
promiseNativePanEvent
:
promiseNativePanGestureEventAndWaitForObserver
deltaOnRTL
:
-
50
}
;
function
getPanHandler
(
)
{
switch
(
getPlatform
(
)
)
{
case
"
windows
"
:
return
NativePanHandlerForWindows
;
case
"
mac
"
:
return
NativePanHandlerForMac
;
default
:
throw
new
Error
(
"
There
'
s
no
native
pan
handler
on
platform
"
+
getPlatform
(
)
)
;
}
}
const
NativePanHandler
=
getPanHandler
(
)
;
async
function
panRightToLeft
(
aElement
aX
aY
aMultiplier
)
{
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
NativePanHandler
.
deltaOnRTL
*
aMultiplier
0
NativePanHandler
.
beginPhase
)
;
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
NativePanHandler
.
deltaOnRTL
0
NativePanHandler
.
updatePhase
)
;
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
NativePanHandler
.
deltaOnRTL
*
aMultiplier
0
NativePanHandler
.
updatePhase
)
;
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
0
0
NativePanHandler
.
endPhase
)
;
}
async
function
panLeftToRight
(
aElement
aX
aY
aMultiplier
)
{
await
panLeftToRightBegin
(
aElement
aX
aY
aMultiplier
)
;
await
panLeftToRightUpdate
(
aElement
aX
aY
aMultiplier
)
;
await
panLeftToRightEnd
(
aElement
aX
aY
aMultiplier
)
;
}
async
function
panLeftToRightBegin
(
aElement
aX
aY
aMultiplier
)
{
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
-
NativePanHandler
.
deltaOnRTL
*
aMultiplier
0
NativePanHandler
.
beginPhase
)
;
}
async
function
panLeftToRightUpdate
(
aElement
aX
aY
aMultiplier
)
{
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
-
NativePanHandler
.
deltaOnRTL
*
aMultiplier
0
NativePanHandler
.
updatePhase
)
;
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
-
NativePanHandler
.
deltaOnRTL
*
aMultiplier
0
NativePanHandler
.
updatePhase
)
;
}
async
function
panLeftToRightEnd
(
aElement
aX
aY
aMultiplier
)
{
await
NativePanHandler
.
promiseNativePanEvent
(
aElement
aX
aY
0
0
NativePanHandler
.
endPhase
)
;
}
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
3
"
Received
3
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
wheelEventCount
=
0
;
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
secondPage
)
;
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
secondPage
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
wheelEventCount
=
0
;
let
wheelEventListener
=
event
=
>
{
event
.
preventDefault
(
)
;
}
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
wheelEventListener
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
3
"
Received
all
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
removeEventListener
(
"
wheel
"
wheelEventListener
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
widget
.
disable
-
swipe
-
tracker
"
true
]
]
}
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
3
"
Received
all
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
browser
.
swipe
.
navigation
-
icon
-
move
-
distance
"
0
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
whole
-
page
-
pixel
-
size
"
550
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
let
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
0
.
98
<
computedOpacity
&
&
computedOpacity
<
0
.
99
"
opacity
of
prevbox
is
not
quite
1
"
)
;
let
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
0
.
98
<
opacity
&
&
opacity
<
0
.
99
"
opacity
of
prevbox
is
not
quite
1
"
)
;
const
translateDistance
=
Services
.
prefs
.
getIntPref
(
"
browser
.
swipe
.
navigation
-
icon
-
move
-
distance
"
0
)
;
if
(
translateDistance
!
=
0
)
{
isnot
(
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
translate
"
)
"
none
"
"
translate
of
prevbox
is
not
none
during
gestures
"
)
;
}
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
computedOpacity
=
=
1
"
computed
opacity
of
prevbox
is
1
"
)
;
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
opacity
=
=
0
"
element
.
style
opacity
of
prevbox
0
"
)
;
if
(
translateDistance
!
=
0
)
{
isnot
(
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
translate
"
)
"
none
"
"
translate
of
prevbox
is
not
none
during
the
opacity
transition
"
)
;
}
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
whole
-
page
-
pixel
-
size
"
1100
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
1
.
8
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
1
.
8
)
;
let
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
0
.
98
<
computedOpacity
&
&
computedOpacity
<
0
.
99
"
opacity
of
prevbox
is
not
quite
1
"
)
;
let
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
0
.
98
<
opacity
&
&
opacity
<
0
.
99
"
opacity
of
prevbox
is
not
quite
1
"
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
1
.
8
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
2
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
computedOpacity
=
=
1
"
computed
opacity
of
prevbox
is
1
"
)
;
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
opacity
=
=
0
"
element
.
style
opacity
of
prevbox
0
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
2
.
0
]
[
"
widget
.
swipe
.
whole
-
page
-
pixel
-
size
"
550
.
0
]
]
}
)
;
async
function
runTest
(
)
{
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
let
startTime
=
performance
.
now
(
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
0
.
2
)
;
let
endTime
=
performance
.
now
(
)
;
if
(
endTime
-
startTime
>
230
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
return
false
;
}
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
let
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
computedOpacity
=
=
1
"
computed
opacity
of
prevbox
is
1
"
)
;
let
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
opacity
=
=
0
"
element
.
style
opacity
of
prevbox
0
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
return
true
;
}
let
numTries
=
15
;
while
(
numTries
>
0
)
{
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
await
new
Promise
(
resolve
=
>
requestIdleCallback
(
resolve
)
)
;
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
if
(
await
runTest
(
)
)
{
break
;
}
numTries
-
-
;
}
ok
(
numTries
>
0
"
never
ran
the
test
"
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
whole
-
page
-
pixel
-
size
"
550
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
2
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
while
(
gHistorySwipeAnimation
.
_prevBox
!
=
null
|
|
gHistorySwipeAnimation
.
_nextBox
!
=
null
)
{
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
}
ok
(
gHistorySwipeAnimation
.
_prevBox
=
=
null
&
&
gHistorySwipeAnimation
.
_nextBox
=
=
null
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
whole
-
page
-
pixel
-
size
"
550
.
0
]
]
}
)
;
function
swipeGestureEndPromise
(
)
{
return
new
Promise
(
resolve
=
>
{
let
promiseObserver
=
{
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozSwipeGestureEnd
"
:
gBrowser
.
tabbox
.
removeEventListener
(
"
MozSwipeGestureEnd
"
promiseObserver
true
)
;
resolve
(
)
;
break
;
}
}
}
;
gBrowser
.
tabbox
.
addEventListener
(
"
MozSwipeGestureEnd
"
promiseObserver
true
)
;
}
)
;
}
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
numSwipeGestureEndEvents
=
0
;
var
anObserver
=
{
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozSwipeGestureEnd
"
:
numSwipeGestureEndEvents
+
+
;
break
;
}
}
}
;
gBrowser
.
tabbox
.
addEventListener
(
"
MozSwipeGestureEnd
"
anObserver
true
)
;
let
gestureEndPromise
=
swipeGestureEndPromise
(
)
;
is
(
numSwipeGestureEndEvents
0
"
expected
no
MozSwipeGestureEnd
got
"
+
numSwipeGestureEndEvents
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
await
gestureEndPromise
;
is
(
numSwipeGestureEndEvents
1
"
expected
one
MozSwipeGestureEnd
got
"
+
numSwipeGestureEndEvents
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
gestureEndPromise
=
swipeGestureEndPromise
(
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
await
gestureEndPromise
;
is
(
numSwipeGestureEndEvents
2
"
expected
one
MozSwipeGestureEnd
got
"
+
(
numSwipeGestureEndEvents
-
1
)
)
;
gBrowser
.
tabbox
.
removeEventListener
(
"
MozSwipeGestureEnd
"
anObserver
true
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
999999
.
0
]
[
"
widget
.
swipe
.
whole
-
page
-
pixel
-
size
"
1
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
100
)
;
ok
(
gHistorySwipeAnimation
.
_prevBox
!
=
null
"
should
have
prevbox
"
)
;
let
transitionPromise
=
new
Promise
(
resolve
=
>
{
gHistorySwipeAnimation
.
_prevBox
.
addEventListener
(
"
transitionstart
"
resolve
{
once
:
true
}
)
;
}
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
100
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
100
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
await
transitionPromise
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
(
gHistorySwipeAnimation
.
_prevBox
=
=
null
&
&
gHistorySwipeAnimation
.
_nextBox
=
=
null
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
