"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
gfx
/
layers
/
apz
/
test
/
mochitest
/
apz_test_utils
.
js
"
this
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
gfx
/
layers
/
apz
/
test
/
mochitest
/
apz_test_native_event_utils
.
js
"
this
)
;
async
function
waitForWhile
(
)
{
await
new
Promise
(
resolve
=
>
{
requestIdleCallback
(
resolve
{
timeout
:
300
}
)
;
}
)
;
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
}
requestLongerTimeout
(
2
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
pixel
-
size
"
550
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
let
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
is
(
computedOpacity
"
1
"
"
opacity
of
prevbox
is
1
"
)
;
let
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
is
(
opacity
"
"
"
opacity
style
isn
'
t
explicitly
set
"
)
;
const
isTranslatingIcon
=
Services
.
prefs
.
getIntPref
(
"
browser
.
swipe
.
navigation
-
icon
-
start
-
position
"
0
)
!
=
0
|
|
Services
.
prefs
.
getIntPref
(
"
browser
.
swipe
.
navigation
-
icon
-
end
-
position
"
0
)
!
=
0
;
if
(
isTranslatingIcon
!
=
0
)
{
isnot
(
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
translate
"
)
"
none
"
"
translate
of
prevbox
is
not
none
during
gestures
"
)
;
}
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
computedOpacity
=
=
1
"
computed
opacity
of
prevbox
is
1
"
)
;
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
opacity
=
=
0
"
element
.
style
opacity
of
prevbox
0
"
)
;
if
(
isTranslatingIcon
)
{
isnot
(
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
translate
"
)
"
none
"
"
translate
of
prevbox
is
not
none
during
the
opacity
transition
"
)
;
}
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
pixel
-
size
"
1100
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
1
.
8
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
1
.
8
)
;
let
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
is
(
computedOpacity
"
1
"
"
opacity
of
prevbox
is
1
"
)
;
let
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
is
(
opacity
"
"
"
opacity
style
isn
'
t
explicitly
set
"
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
1
.
8
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
2
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
computedOpacity
=
=
1
"
computed
opacity
of
prevbox
is
1
"
)
;
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
opacity
=
=
0
"
element
.
style
opacity
of
prevbox
0
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
2
.
0
]
[
"
widget
.
swipe
.
pixel
-
size
"
550
.
0
]
]
}
)
;
async
function
runTest
(
)
{
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
let
startTime
=
performance
.
now
(
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
0
.
2
)
;
let
endTime
=
performance
.
now
(
)
;
if
(
endTime
-
startTime
>
230
)
{
BrowserTestUtils
.
removeTab
(
tab
)
;
return
false
;
}
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
let
computedOpacity
=
window
.
getComputedStyle
(
gHistorySwipeAnimation
.
_prevBox
)
.
getPropertyValue
(
"
opacity
"
)
;
ok
(
computedOpacity
=
=
1
"
computed
opacity
of
prevbox
is
1
"
)
;
let
opacity
=
gHistorySwipeAnimation
.
_prevBox
.
style
.
opacity
;
ok
(
opacity
=
=
0
"
element
.
style
opacity
of
prevbox
0
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
return
true
;
}
let
numTries
=
15
;
while
(
numTries
>
0
)
{
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
await
new
Promise
(
resolve
=
>
requestIdleCallback
(
resolve
)
)
;
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
if
(
await
runTest
(
)
)
{
break
;
}
numTries
-
-
;
}
ok
(
numTries
>
0
"
never
ran
the
test
"
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
pixel
-
size
"
550
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
2
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
while
(
gHistorySwipeAnimation
.
_prevBox
!
=
null
|
|
gHistorySwipeAnimation
.
_nextBox
!
=
null
)
{
await
new
Promise
(
r
=
>
requestAnimationFrame
(
r
)
)
;
}
ok
(
gHistorySwipeAnimation
.
_prevBox
=
=
null
&
&
gHistorySwipeAnimation
.
_nextBox
=
=
null
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
0
]
[
"
widget
.
swipe
.
pixel
-
size
"
550
.
0
]
]
}
)
;
function
swipeGestureEndPromise
(
)
{
return
new
Promise
(
resolve
=
>
{
let
promiseObserver
=
{
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozSwipeGestureEnd
"
:
gBrowser
.
tabbox
.
removeEventListener
(
"
MozSwipeGestureEnd
"
promiseObserver
true
)
;
resolve
(
)
;
break
;
}
}
}
;
gBrowser
.
tabbox
.
addEventListener
(
"
MozSwipeGestureEnd
"
promiseObserver
true
)
;
}
)
;
}
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
numSwipeGestureEndEvents
=
0
;
var
anObserver
=
{
handleEvent
(
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
"
MozSwipeGestureEnd
"
:
numSwipeGestureEndEvents
+
+
;
break
;
}
}
}
;
gBrowser
.
tabbox
.
addEventListener
(
"
MozSwipeGestureEnd
"
anObserver
true
)
;
let
gestureEndPromise
=
swipeGestureEndPromise
(
)
;
is
(
numSwipeGestureEndEvents
0
"
expected
no
MozSwipeGestureEnd
got
"
+
numSwipeGestureEndEvents
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
0
.
9
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
await
gestureEndPromise
;
is
(
numSwipeGestureEndEvents
1
"
expected
one
MozSwipeGestureEnd
got
"
+
numSwipeGestureEndEvents
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
gestureEndPromise
=
swipeGestureEndPromise
(
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
await
gestureEndPromise
;
is
(
numSwipeGestureEndEvents
2
"
expected
one
MozSwipeGestureEnd
got
"
+
(
numSwipeGestureEndEvents
-
1
)
)
;
gBrowser
.
tabbox
.
removeEventListener
(
"
MozSwipeGestureEnd
"
anObserver
true
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
999999
.
0
]
[
"
widget
.
swipe
.
pixel
-
size
"
1
.
0
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
100
)
;
ok
(
gHistorySwipeAnimation
.
_prevBox
!
=
null
"
should
have
prevbox
"
)
;
let
transitionCancelPromise
=
new
Promise
(
resolve
=
>
{
gHistorySwipeAnimation
.
_prevBox
.
addEventListener
(
"
transitioncancel
"
event
=
>
{
if
(
event
.
propertyName
=
=
"
opacity
"
&
&
event
.
target
=
=
gHistorySwipeAnimation
.
_prevBox
)
{
resolve
(
)
;
}
}
{
once
:
true
}
)
;
}
)
;
let
transitionStartPromise
=
new
Promise
(
resolve
=
>
{
gHistorySwipeAnimation
.
_prevBox
.
addEventListener
(
"
transitionstart
"
event
=
>
{
if
(
event
.
propertyName
=
=
"
opacity
"
&
&
event
.
target
=
=
gHistorySwipeAnimation
.
_prevBox
)
{
resolve
(
)
;
}
}
{
once
:
true
}
)
;
}
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
100
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
100
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
await
Promise
.
any
(
[
transitionStartPromise
transitionCancelPromise
]
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
(
gHistorySwipeAnimation
.
_prevBox
=
=
null
&
&
gHistorySwipeAnimation
.
_nextBox
=
=
null
)
;
}
)
;
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
secondPage
)
;
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
secondPage
)
;
await
panRightToLeftBegin
(
tab
.
linkedBrowser
100
100
100
)
;
ok
(
gHistorySwipeAnimation
.
_nextBox
!
=
null
"
should
have
nextbox
"
)
;
transitionCancelPromise
=
new
Promise
(
resolve
=
>
{
gHistorySwipeAnimation
.
_nextBox
.
addEventListener
(
"
transitioncancel
"
event
=
>
{
if
(
event
.
propertyName
=
=
"
opacity
"
&
&
event
.
target
=
=
gHistorySwipeAnimation
.
_nextBox
)
{
resolve
(
)
;
}
}
)
;
}
)
;
transitionStartPromise
=
new
Promise
(
resolve
=
>
{
gHistorySwipeAnimation
.
_nextBox
.
addEventListener
(
"
transitionstart
"
event
=
>
{
if
(
event
.
propertyName
=
=
"
opacity
"
&
&
event
.
target
=
=
gHistorySwipeAnimation
.
_nextBox
)
{
resolve
(
)
;
}
}
)
;
}
)
;
await
panRightToLeftUpdate
(
tab
.
linkedBrowser
100
100
100
)
;
await
panRightToLeftEnd
(
tab
.
linkedBrowser
100
100
100
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
await
Promise
.
any
(
[
transitionStartPromise
transitionCancelPromise
]
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
(
gHistorySwipeAnimation
.
_nextBox
=
=
null
&
&
gHistorySwipeAnimation
.
_prevBox
=
=
null
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
[
"
intl
.
l10n
.
pseudo
"
"
bidi
"
]
]
}
)
;
const
newWin
=
await
BrowserTestUtils
.
openNewBrowserWindow
(
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
newWin
.
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
newWin
.
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
newWin
.
gBrowser
.
webNavigation
.
canGoForward
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
return
newWin
.
gHistorySwipeAnimation
.
active
;
}
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
1
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
newWin
.
gBrowser
.
webNavigation
.
canGoForward
)
;
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
secondPage
)
;
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
secondPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
newWin
.
gBrowser
.
webNavigation
.
canGoBack
)
;
await
BrowserTestUtils
.
closeWindow
(
newWin
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
[
"
apz
.
overscroll
.
enabled
"
true
]
[
"
apz
.
test
.
logging_enabled
"
true
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
about
"
true
)
;
const
URL_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
content
.
document
.
documentElement
.
style
.
overscrollBehaviorX
=
"
contain
"
;
content
.
document
.
documentElement
.
getBoundingClientRect
(
)
;
await
content
.
wrappedJSObject
.
promiseApzFlushedRepaints
(
)
;
}
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
2
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
await
content
.
wrappedJSObject
.
promiseApzFlushedRepaints
(
)
;
}
)
;
const
isOverscrolled
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
{
const
scrollId
=
SpecialPowers
.
DOMWindowUtils
.
getViewId
(
content
.
document
.
scrollingElement
)
;
const
data
=
SpecialPowers
.
DOMWindowUtils
.
getCompositorAPZTestData
(
)
;
return
data
.
additionalData
.
some
(
entry
=
>
{
return
(
entry
.
key
=
=
scrollId
&
&
entry
.
value
.
split
(
"
"
)
.
includes
(
"
overscrolled
"
)
)
;
}
)
;
}
)
;
ok
(
isOverscrolled
"
The
root
scroller
should
have
overscrolled
"
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
2
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
2
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
apz
.
overscroll
.
enabled
"
true
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
about
"
true
)
;
const
URL_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
const
overscrollBehaviorX
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
{
return
content
.
window
.
getComputedStyle
(
content
.
document
.
documentElement
)
.
overscrollBehaviorX
;
}
)
;
is
(
overscrollBehaviorX
"
auto
"
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
2
)
;
ok
(
!
gHistorySwipeAnimation
.
_prevBox
.
collapsed
)
;
await
panLeftToRightUpdate
(
tab
.
linkedBrowser
100
100
2
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
2
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
[
"
apz
.
overscroll
.
enabled
"
true
]
[
"
apz
.
test
.
logging_enabled
"
true
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
about
"
true
)
;
const
URL_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
2
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
await
content
.
wrappedJSObject
.
promiseApzFlushedRepaints
(
)
;
}
)
;
const
isOverscrolled
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
(
)
=
>
{
const
scrollId
=
SpecialPowers
.
DOMWindowUtils
.
getViewId
(
content
.
document
.
scrollingElement
)
;
const
data
=
SpecialPowers
.
DOMWindowUtils
.
getCompositorAPZTestData
(
)
;
return
data
.
additionalData
.
some
(
entry
=
>
{
return
entry
.
key
=
=
scrollId
&
&
entry
.
value
.
includes
(
"
overscrolled
"
)
;
}
)
;
}
)
;
ok
(
!
isOverscrolled
"
The
root
scroller
should
not
have
overscrolled
"
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
0
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
about
"
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
"
about
:
mozilla
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
"
about
:
mozilla
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
"
about
:
home
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
"
about
:
home
"
)
;
gBrowser
.
goBack
(
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
"
about
:
mozilla
"
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
await
panLeftToRightBegin
(
tab
.
linkedBrowser
100
100
1
)
;
ok
(
!
gHistorySwipeAnimation
.
_prevBox
.
collapsed
"
The
icon
box
for
the
previous
navigation
should
NOT
be
collapsed
"
)
;
ok
(
gHistorySwipeAnimation
.
_nextBox
.
collapsed
"
The
icon
box
for
the
next
navigation
should
be
collapsed
"
)
;
await
NativePanHandler
.
promiseNativePanEvent
(
tab
.
linkedBrowser
100
100
NativePanHandler
.
delta
0
NativePanHandler
.
updatePhase
)
;
ok
(
gHistorySwipeAnimation
.
_prevBox
.
collapsed
"
The
icon
box
for
the
previous
navigation
should
be
collapsed
"
)
;
ok
(
gHistorySwipeAnimation
.
_nextBox
.
collapsed
"
The
icon
box
for
the
next
navigation
should
be
collapsed
"
)
;
await
panLeftToRightEnd
(
tab
.
linkedBrowser
100
100
0
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
[
"
apz
.
overscroll
.
enabled
"
true
]
[
"
apz
.
overscroll
.
damping
"
5
.
0
]
[
"
apz
.
content_response_timeout
"
0
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
"
about
:
about
"
true
)
;
const
URL_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
URL_ROOT
+
"
helper_swipe_gesture
.
html
"
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
content
.
document
.
documentElement
.
scrollLeft
=
1
;
content
.
document
.
documentElement
.
getBoundingClientRect
(
)
;
await
content
.
wrappedJSObject
.
promiseApzFlushedRepaints
(
)
;
}
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
1
100
1
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
1
100
1
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
await
new
Promise
(
(
resolve
reject
)
=
>
{
SpecialPowers
.
Services
.
obs
.
addObserver
(
function
observer
(
subject
topic
data
)
{
try
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
resolve
(
[
subject
data
]
)
;
}
catch
(
ex
)
{
SpecialPowers
.
Services
.
obs
.
removeObserver
(
observer
topic
)
;
reject
(
ex
)
;
}
}
"
APZ
:
TransformEnd
"
)
;
}
)
;
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
content
.
document
.
documentElement
.
addEventListener
(
"
wheel
"
e
=
>
{
}
{
passive
:
false
}
)
;
await
content
.
wrappedJSObject
.
promiseApzFlushedRepaints
(
)
;
}
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
"
about
:
about
"
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
"
about
:
about
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
right
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
[
"
widget
.
disable
-
swipe
-
tracker
"
false
]
[
"
widget
.
swipe
.
velocity
-
twitch
-
tolerance
"
0
.
0000001
]
[
"
widget
.
swipe
.
success
-
velocity
-
contribution
"
0
.
5
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
2
"
Received
2
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
wheelEventCount
=
0
;
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
secondPage
)
;
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
secondPage
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
wheelEventCount
=
0
;
let
wheelEventListener
=
event
=
>
{
event
.
preventDefault
(
)
;
}
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
wheelEventListener
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
3
"
Received
all
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
removeEventListener
(
"
wheel
"
wheelEventListener
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
widget
.
disable
-
swipe
-
tracker
"
true
]
]
}
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
1
)
;
is
(
wheelEventCount
3
"
Received
all
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
SpecialPowers
.
popPrefEnv
(
)
;
}
)
;
