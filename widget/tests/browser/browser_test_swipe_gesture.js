"
use
strict
"
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
gfx
/
layers
/
apz
/
test
/
mochitest
/
apz_test_native_event_utils
.
js
"
this
)
;
function
waitForWhile
(
)
{
return
new
Promise
(
resolve
=
>
{
requestIdleCallback
(
resolve
{
timeout
:
300
}
)
;
}
)
;
}
const
kCGScrollPhaseBegan
=
1
;
const
kCGScrollPhaseChanged
=
2
;
const
kCGScrollPhaseEnded
=
4
;
async
function
panRightToLeft
(
aElement
aX
aY
)
{
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
-
50
0
kCGScrollPhaseBegan
)
;
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
-
50
0
kCGScrollPhaseChanged
)
;
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
-
50
0
kCGScrollPhaseChanged
)
;
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
0
0
kCGScrollPhaseEnded
)
;
}
async
function
panLeftToRight
(
aElement
aX
aY
)
{
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
50
0
kCGScrollPhaseBegan
)
;
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
50
0
kCGScrollPhaseChanged
)
;
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
50
0
kCGScrollPhaseChanged
)
;
await
promiseNativePanGestureEventAndWaitForObserver
(
aElement
aX
aY
0
0
kCGScrollPhaseEnded
)
;
}
add_task
(
async
(
)
=
>
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
browser
.
gesture
.
swipe
.
left
"
"
Browser
:
BackOrBackDuplicate
"
]
[
"
browser
.
gesture
.
swipe
.
eight
"
"
Browser
:
ForwardOrForwardDuplicate
"
]
]
}
)
;
const
firstPage
=
"
about
:
about
"
;
const
secondPage
=
"
about
:
mozilla
"
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
firstPage
true
)
;
BrowserTestUtils
.
loadURI
(
tab
.
linkedBrowser
secondPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
false
secondPage
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
ok
(
!
gBrowser
.
webNavigation
.
canGoForward
)
;
let
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
(
)
=
>
{
wheelEventCount
+
+
;
}
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
)
;
is
(
wheelEventCount
3
"
Received
3
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
wheelEventCount
=
0
;
let
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
firstPage
)
;
let
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
firstPage
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoForward
)
;
wheelEventCount
=
0
;
startLoadingPromise
=
BrowserTestUtils
.
browserStarted
(
tab
.
linkedBrowser
secondPage
)
;
stoppedLoadingPromise
=
BrowserTestUtils
.
browserStopped
(
tab
.
linkedBrowser
secondPage
)
;
await
panRightToLeft
(
tab
.
linkedBrowser
100
100
)
;
is
(
wheelEventCount
1
"
Received
a
wheel
event
"
)
;
await
Promise
.
all
(
[
startLoadingPromise
stoppedLoadingPromise
]
)
;
ok
(
gBrowser
.
webNavigation
.
canGoBack
)
;
wheelEventCount
=
0
;
tab
.
linkedBrowser
.
addEventListener
(
"
wheel
"
event
=
>
{
event
.
preventDefault
(
)
;
}
)
;
await
panLeftToRight
(
tab
.
linkedBrowser
100
100
)
;
is
(
wheelEventCount
3
"
Received
all
wheel
events
"
)
;
await
waitForWhile
(
)
;
is
(
tab
.
linkedBrowser
.
currentURI
.
spec
secondPage
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
}
)
;
