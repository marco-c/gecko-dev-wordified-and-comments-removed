#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
SystemTimeConverter
.
h
"
using
mozilla
:
:
SystemTimeConverter
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
namespace
{
template
<
typename
Time
>
class
MockCurrentTimeGetter
{
public
:
MockCurrentTimeGetter
(
)
:
mTime
(
0
)
{
}
explicit
MockCurrentTimeGetter
(
Time
aTime
)
:
mTime
(
aTime
)
{
}
Time
GetCurrentTime
(
)
const
{
return
mTime
;
}
void
GetTimeAsyncForPossibleBackwardsSkew
(
const
TimeStamp
&
aNow
)
{
}
private
:
Time
mTime
;
}
;
template
<
typename
Time
>
class
UnusedCurrentTimeGetter
{
public
:
Time
GetCurrentTime
(
)
const
{
EXPECT_TRUE
(
false
)
;
return
0
;
}
void
GetTimeAsyncForPossibleBackwardsSkew
(
const
TimeStamp
&
aNow
)
{
EXPECT_TRUE
(
false
)
;
}
}
;
class
MockTimeStamp
{
public
:
static
void
Init
(
)
{
sBaseline
=
TimeStamp
:
:
Now
(
)
;
sTimeStamp
=
sBaseline
;
}
static
void
Advance
(
double
ms
)
{
sTimeStamp
+
=
TimeDuration
:
:
FromMilliseconds
(
ms
)
;
}
static
TimeStamp
Baseline
(
)
{
return
sBaseline
;
}
static
TimeStamp
Now
(
)
{
return
sTimeStamp
;
}
private
:
static
TimeStamp
sTimeStamp
;
static
TimeStamp
sBaseline
;
}
;
TimeStamp
MockTimeStamp
:
:
sTimeStamp
;
TimeStamp
MockTimeStamp
:
:
sBaseline
;
using
GTestTime
=
uint32_t
;
using
TimeConverter
=
SystemTimeConverter
<
GTestTime
MockTimeStamp
>
;
}
#
define
EXPECT_TS
(
ts
ms
)
\
EXPECT_EQ
(
(
ts
)
-
MockTimeStamp
:
:
Baseline
(
)
\
TimeDuration
:
:
FromMilliseconds
(
ms
)
)
#
define
EXPECT_TS_FUZZY
(
ts
ms
)
\
EXPECT_DOUBLE_EQ
(
(
(
ts
)
-
MockTimeStamp
:
:
Baseline
(
)
)
.
ToMilliseconds
(
)
ms
)
TEST
(
TimeConverter
SanityCheck
)
{
MockTimeStamp
:
:
Init
(
)
;
MockCurrentTimeGetter
timeGetter
(
10
)
;
UnusedCurrentTimeGetter
<
GTestTime
>
unused
;
TimeConverter
converter
;
TimeStamp
ts
=
converter
.
GetTimeStampFromSystemTime
(
10
timeGetter
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
10
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
10
unused
)
;
EXPECT_TS
(
ts
0
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
30
unused
)
;
EXPECT_TS
(
ts
10
)
;
}
TEST
(
TimeConverter
Overflow
)
{
MockTimeStamp
:
:
Init
(
)
;
const
GTestTime
max
=
std
:
:
numeric_limits
<
GTestTime
>
:
:
max
(
)
;
const
GTestTime
min
=
std
:
:
numeric_limits
<
GTestTime
>
:
:
min
(
)
;
double
fullRange
=
(
double
)
max
-
(
double
)
min
;
double
wrapPeriod
=
fullRange
+
1
.
0
;
GTestTime
almostOverflowed
=
max
-
100
;
GTestTime
overflowed
=
max
+
100
;
MockCurrentTimeGetter
timeGetter
(
almostOverflowed
)
;
UnusedCurrentTimeGetter
<
GTestTime
>
unused
;
TimeConverter
converter
;
TimeStamp
ts
=
converter
.
GetTimeStampFromSystemTime
(
almostOverflowed
timeGetter
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
200
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
overflowed
unused
)
;
EXPECT_TS
(
ts
200
)
;
MockTimeStamp
:
:
Advance
(
wrapPeriod
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
overflowed
unused
)
;
EXPECT_TS_FUZZY
(
ts
200
.
0
+
wrapPeriod
)
;
}
TEST
(
TimeConverter
InvertedOverflow
)
{
MockTimeStamp
:
:
Init
(
)
;
const
GTestTime
max
=
std
:
:
numeric_limits
<
GTestTime
>
:
:
max
(
)
;
const
GTestTime
min
=
std
:
:
numeric_limits
<
GTestTime
>
:
:
min
(
)
;
double
fullRange
=
(
double
)
max
-
(
double
)
min
;
double
wrapPeriod
=
fullRange
+
1
.
0
;
GTestTime
nearRangeMin
=
min
+
100
;
GTestTime
nearRangeMax
=
max
-
100
;
double
gap
=
(
double
)
nearRangeMax
-
(
double
)
nearRangeMin
;
MockCurrentTimeGetter
timeGetter
(
nearRangeMin
)
;
UnusedCurrentTimeGetter
<
GTestTime
>
unused
;
TimeConverter
converter
;
TimeStamp
ts
=
converter
.
GetTimeStampFromSystemTime
(
nearRangeMin
timeGetter
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
gap
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
nearRangeMax
unused
)
;
EXPECT_TS
(
ts
gap
)
;
MockTimeStamp
:
:
Advance
(
wrapPeriod
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
nearRangeMax
unused
)
;
EXPECT_TS_FUZZY
(
ts
gap
+
wrapPeriod
)
;
}
TEST
(
TimeConverter
HalfRangeBoundary
)
{
MockTimeStamp
:
:
Init
(
)
;
GTestTime
max
=
std
:
:
numeric_limits
<
GTestTime
>
:
:
max
(
)
;
GTestTime
min
=
std
:
:
numeric_limits
<
GTestTime
>
:
:
min
(
)
;
double
fullRange
=
(
double
)
max
-
(
double
)
min
;
double
wrapPeriod
=
fullRange
+
1
.
0
;
GTestTime
halfRange
=
(
GTestTime
)
(
fullRange
/
2
.
0
)
;
GTestTime
halfWrapPeriod
=
(
GTestTime
)
(
wrapPeriod
/
2
.
0
)
;
TimeConverter
converter
;
GTestTime
firstEvent
=
10
;
MockCurrentTimeGetter
timeGetter
(
firstEvent
)
;
UnusedCurrentTimeGetter
<
GTestTime
>
unused
;
TimeStamp
ts
=
converter
.
GetTimeStampFromSystemTime
(
firstEvent
timeGetter
)
;
EXPECT_TS
(
ts
0
)
;
GTestTime
secondEvent
=
firstEvent
+
(
halfWrapPeriod
-
1
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
secondEvent
unused
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
halfRange
-
1
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
secondEvent
unused
)
;
EXPECT_TS
(
ts
0
)
;
}
TEST
(
TimeConverter
FractionalMillisBug1626734
)
{
MockTimeStamp
:
:
Init
(
)
;
TimeConverter
converter
;
GTestTime
eventTime
=
10
;
MockCurrentTimeGetter
timeGetter
(
eventTime
)
;
UnusedCurrentTimeGetter
<
GTestTime
>
unused
;
TimeStamp
ts
=
converter
.
GetTimeStampFromSystemTime
(
eventTime
timeGetter
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
0
.
2
)
;
ts
=
converter
.
GetTimeStampFromSystemTime
(
eventTime
unused
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
0
.
9
)
;
TimeStamp
ts2
=
converter
.
GetTimeStampFromSystemTime
(
eventTime
unused
)
;
EXPECT_TS
(
ts2
0
)
;
EXPECT_TRUE
(
ts
<
=
ts2
)
;
}
TEST
(
TimeConverter
UnderflowWrapBaseline
)
{
MockTimeStamp
:
:
Init
(
)
;
TimeConverter
converter
;
MockCurrentTimeGetter
<
GTestTime
>
timeGetter
(
300
)
;
TimeStamp
ts
=
converter
.
GetTimeStampFromSystemTime
(
300
timeGetter
)
;
EXPECT_TS
(
ts
0
)
;
MockTimeStamp
:
:
Advance
(
200
)
;
{
UnusedCurrentTimeGetter
<
GTestTime
>
unused
;
TimeStamp
ts2
=
converter
.
GetTimeStampFromSystemTime
(
299
unused
)
;
ASSERT_GE
(
ts2
MockTimeStamp
:
:
Baseline
(
)
)
<
<
"
Should
not
go
behind
the
baseline
!
"
;
}
}
