#
ifndef
mozilla_textcompositionsynthesizer_h_
#
define
mozilla_textcompositionsynthesizer_h_
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
TextEventDispatcherListener
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
class
nsIWidget
;
namespace
mozilla
{
namespace
widget
{
struct
IMENotification
;
class
TextEventDispatcher
final
{
~
TextEventDispatcher
(
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
TextEventDispatcher
)
public
:
explicit
TextEventDispatcher
(
nsIWidget
*
aWidget
)
;
nsresult
BeginInputTransaction
(
TextEventDispatcherListener
*
aListener
)
;
nsresult
BeginTestInputTransaction
(
TextEventDispatcherListener
*
aListener
bool
aIsAPZAware
)
;
nsresult
BeginNativeInputTransaction
(
)
;
void
EndInputTransaction
(
TextEventDispatcherListener
*
aListener
)
;
void
OnDestroyWidget
(
)
;
nsIWidget
*
GetWidget
(
)
const
{
return
mWidget
;
}
nsresult
GetState
(
)
const
;
bool
IsComposing
(
)
const
{
return
mIsComposing
;
}
bool
IsDispatchingEvent
(
)
const
{
return
mDispatchingEvent
>
0
;
}
void
*
GetPseudoIMEContext
(
)
const
{
if
(
mInputTransactionType
=
=
eNoInputTransaction
|
|
mInputTransactionType
=
=
eNativeInputTransaction
)
{
return
nullptr
;
}
return
const_cast
<
TextEventDispatcher
*
>
(
this
)
;
}
nsresult
StartComposition
(
nsEventStatus
&
aStatus
)
;
nsresult
CommitComposition
(
nsEventStatus
&
aStatus
const
nsAString
*
aCommitString
=
nullptr
)
;
nsresult
SetPendingCompositionString
(
const
nsAString
&
aString
)
{
return
mPendingComposition
.
SetString
(
aString
)
;
}
nsresult
AppendClauseToPendingComposition
(
uint32_t
aLength
uint32_t
aAttribute
)
{
return
mPendingComposition
.
AppendClause
(
aLength
aAttribute
)
;
}
nsresult
SetCaretInPendingComposition
(
uint32_t
aOffset
uint32_t
aLength
)
{
return
mPendingComposition
.
SetCaret
(
aOffset
aLength
)
;
}
nsresult
FlushPendingComposition
(
nsEventStatus
&
aStatus
)
{
return
mPendingComposition
.
Flush
(
this
aStatus
)
;
}
void
ClearPendingComposition
(
)
{
mPendingComposition
.
Clear
(
)
;
}
nsresult
NotifyIME
(
const
IMENotification
&
aIMENotification
)
;
bool
DispatchKeyboardEvent
(
EventMessage
aMessage
const
WidgetKeyboardEvent
&
aKeyboardEvent
nsEventStatus
&
aStatus
)
;
bool
MaybeDispatchKeypressEvents
(
const
WidgetKeyboardEvent
&
aKeyboardEvent
nsEventStatus
&
aStatus
)
;
private
:
nsIWidget
*
mWidget
;
nsWeakPtr
mListener
;
class
PendingComposition
{
public
:
PendingComposition
(
)
;
nsresult
SetString
(
const
nsAString
&
aString
)
;
nsresult
AppendClause
(
uint32_t
aLength
uint32_t
aAttribute
)
;
nsresult
SetCaret
(
uint32_t
aOffset
uint32_t
aLength
)
;
nsresult
Flush
(
TextEventDispatcher
*
aDispatcher
nsEventStatus
&
aStatus
)
;
void
Clear
(
)
;
private
:
nsString
mString
;
RefPtr
<
TextRangeArray
>
mClauses
;
TextRange
mCaret
;
void
EnsureClauseArray
(
)
;
}
;
PendingComposition
mPendingComposition
;
uint16_t
mDispatchingEvent
;
enum
InputTransactionType
:
uint8_t
{
eNoInputTransaction
eNativeInputTransaction
eAsyncTestInputTransaction
eSameProcessSyncTestInputTransaction
eSameProcessSyncInputTransaction
}
;
InputTransactionType
mInputTransactionType
;
bool
IsForTests
(
)
const
{
return
mInputTransactionType
=
=
eAsyncTestInputTransaction
|
|
mInputTransactionType
=
=
eSameProcessSyncTestInputTransaction
;
}
bool
ShouldSendInputEventToAPZ
(
)
const
{
switch
(
mInputTransactionType
)
{
case
eNativeInputTransaction
:
case
eAsyncTestInputTransaction
:
return
true
;
case
eSameProcessSyncTestInputTransaction
:
case
eSameProcessSyncInputTransaction
:
return
false
;
case
eNoInputTransaction
:
NS_WARNING
(
"
Why
does
the
caller
need
to
dispatch
an
event
when
"
"
there
is
no
input
transaction
?
"
)
;
return
true
;
default
:
MOZ_CRASH
(
"
Define
the
behavior
of
new
InputTransactionType
"
)
;
}
}
bool
mIsComposing
;
static
bool
sDispatchKeyEventsDuringComposition
;
nsresult
BeginInputTransactionInternal
(
TextEventDispatcherListener
*
aListener
InputTransactionType
aType
)
;
void
InitEvent
(
WidgetGUIEvent
&
aEvent
)
const
;
nsresult
DispatchEvent
(
nsIWidget
*
aWidget
WidgetGUIEvent
&
aEvent
nsEventStatus
&
aStatus
)
;
nsresult
DispatchInputEvent
(
nsIWidget
*
aWidget
WidgetInputEvent
&
aEvent
nsEventStatus
&
aStatus
)
;
nsresult
StartCompositionAutomaticallyIfNecessary
(
nsEventStatus
&
aStatus
)
;
bool
DispatchKeyboardEventInternal
(
EventMessage
aMessage
const
WidgetKeyboardEvent
&
aKeyboardEvent
nsEventStatus
&
aStatus
uint32_t
aIndexOfKeypress
=
0
)
;
}
;
}
}
#
endif
