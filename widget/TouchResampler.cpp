#
include
"
TouchResampler
.
h
"
#
include
"
nsAlgorithm
.
h
"
namespace
mozilla
{
namespace
widget
{
static
const
double
kTouchResampleWindowSize
=
40
.
0
;
static
const
double
kTouchResampleMaxPredictMs
=
8
.
0
;
static
const
double
kTouchResampleMaxBacksampleMs
=
20
.
0
;
static
const
double
kTouchResampleOldTouchThresholdMs
=
17
.
0
;
uint64_t
TouchResampler
:
:
ProcessEvent
(
MultiTouchInput
&
&
aInput
)
{
mCurrentTouches
.
UpdateFromEvent
(
aInput
)
;
uint64_t
eventId
=
mNextEventId
;
mNextEventId
+
+
;
if
(
aInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_MOVE
)
{
mDeferredTouchMoveEvents
.
push
(
{
std
:
:
move
(
aInput
)
eventId
}
)
;
}
else
{
FlushDeferredTouchMoveEventsUnresampled
(
)
;
if
(
mInResampledState
)
{
ReturnToNonResampledState
(
)
;
}
EmitEvent
(
std
:
:
move
(
aInput
)
eventId
)
;
}
return
eventId
;
}
void
TouchResampler
:
:
NotifyFrame
(
const
TimeStamp
&
aTimeStamp
)
{
TimeStamp
lastTouchTime
=
mCurrentTouches
.
LatestDataPointTime
(
)
;
if
(
mDeferredTouchMoveEvents
.
empty
(
)
|
|
(
lastTouchTime
&
&
lastTouchTime
<
aTimeStamp
-
TimeDuration
:
:
FromMilliseconds
(
kTouchResampleOldTouchThresholdMs
)
)
)
{
FlushDeferredTouchMoveEventsUnresampled
(
)
;
if
(
mInResampledState
)
{
ReturnToNonResampledState
(
)
;
}
mCurrentTouches
.
ClearDataPoints
(
)
;
return
;
}
MOZ_RELEASE_ASSERT
(
lastTouchTime
)
;
TimeStamp
lowerBound
=
lastTouchTime
-
TimeDuration
:
:
FromMilliseconds
(
kTouchResampleMaxBacksampleMs
)
;
TimeStamp
upperBound
=
lastTouchTime
+
TimeDuration
:
:
FromMilliseconds
(
kTouchResampleMaxPredictMs
)
;
TimeStamp
sampleTime
=
clamped
(
aTimeStamp
lowerBound
upperBound
)
;
if
(
mLastEmittedEventTime
&
&
sampleTime
<
mLastEmittedEventTime
)
{
sampleTime
=
mLastEmittedEventTime
;
}
MultiTouchInput
input
;
uint64_t
eventId
;
while
(
true
)
{
MOZ_RELEASE_ASSERT
(
!
mDeferredTouchMoveEvents
.
empty
(
)
)
;
std
:
:
tie
(
input
eventId
)
=
std
:
:
move
(
mDeferredTouchMoveEvents
.
front
(
)
)
;
mDeferredTouchMoveEvents
.
pop
(
)
;
if
(
mDeferredTouchMoveEvents
.
empty
(
)
|
|
input
.
mTimeStamp
>
=
sampleTime
)
{
break
;
}
PrependLeftoverHistoricalData
(
&
input
)
;
MOZ_RELEASE_ASSERT
(
input
.
mTimeStamp
<
sampleTime
)
;
EmitEvent
(
std
:
:
move
(
input
)
eventId
)
;
}
mOriginalOfResampledTouchMove
=
Nothing
(
)
;
nsTArray
<
ScreenIntPoint
>
resampledPositions
;
bool
anyPositionDifferentFromOriginal
=
false
;
for
(
const
auto
&
touch
:
input
.
mTouches
)
{
ScreenIntPoint
resampledPosition
=
mCurrentTouches
.
ResampleTouchPositionAtTime
(
touch
.
mIdentifier
touch
.
mScreenPoint
sampleTime
)
;
if
(
resampledPosition
!
=
touch
.
mScreenPoint
)
{
anyPositionDifferentFromOriginal
=
true
;
}
resampledPositions
.
AppendElement
(
resampledPosition
)
;
}
if
(
anyPositionDifferentFromOriginal
)
{
mOriginalOfResampledTouchMove
=
Some
(
input
)
;
PrependLeftoverHistoricalData
(
&
input
)
;
for
(
size_t
i
=
0
;
i
<
input
.
mTouches
.
Length
(
)
;
i
+
+
)
{
auto
&
touch
=
input
.
mTouches
[
i
]
;
touch
.
mHistoricalData
.
AppendElement
(
SingleTouchData
:
:
HistoricalTouchData
{
input
.
mTimeStamp
touch
.
mScreenPoint
touch
.
mLocalScreenPoint
touch
.
mRadius
touch
.
mRotationAngle
touch
.
mForce
}
)
;
auto
futureDataStart
=
std
:
:
find_if
(
touch
.
mHistoricalData
.
begin
(
)
touch
.
mHistoricalData
.
end
(
)
[
sampleTime
]
(
const
SingleTouchData
:
:
HistoricalTouchData
&
aHistoricalData
)
{
return
aHistoricalData
.
mTimeStamp
>
sampleTime
;
}
)
;
if
(
futureDataStart
!
=
touch
.
mHistoricalData
.
end
(
)
)
{
nsTArray
<
SingleTouchData
:
:
HistoricalTouchData
>
futureData
(
Span
<
SingleTouchData
:
:
HistoricalTouchData
>
(
touch
.
mHistoricalData
)
.
From
(
futureDataStart
.
GetIndex
(
)
)
)
;
touch
.
mHistoricalData
.
TruncateLength
(
futureDataStart
.
GetIndex
(
)
)
;
mRemainingTouchData
.
insert
(
{
touch
.
mIdentifier
std
:
:
move
(
futureData
)
}
)
;
}
touch
.
mScreenPoint
=
resampledPositions
[
i
]
;
}
input
.
mTimeStamp
=
sampleTime
;
}
EmitEvent
(
std
:
:
move
(
input
)
eventId
)
;
mInResampledState
=
anyPositionDifferentFromOriginal
;
}
void
TouchResampler
:
:
PrependLeftoverHistoricalData
(
MultiTouchInput
*
aInput
)
{
for
(
auto
&
touch
:
aInput
-
>
mTouches
)
{
auto
leftoverData
=
mRemainingTouchData
.
find
(
touch
.
mIdentifier
)
;
if
(
leftoverData
!
=
mRemainingTouchData
.
end
(
)
)
{
nsTArray
<
SingleTouchData
:
:
HistoricalTouchData
>
data
=
std
:
:
move
(
leftoverData
-
>
second
)
;
mRemainingTouchData
.
erase
(
leftoverData
)
;
touch
.
mHistoricalData
.
InsertElementsAt
(
0
data
)
;
}
if
(
TimeStamp
cutoffTime
=
mLastEmittedEventTime
)
{
touch
.
mHistoricalData
.
RemoveElementsBy
(
[
cutoffTime
]
(
const
SingleTouchData
:
:
HistoricalTouchData
&
aTouchData
)
{
return
aTouchData
.
mTimeStamp
<
cutoffTime
;
}
)
;
}
}
mRemainingTouchData
.
clear
(
)
;
}
void
TouchResampler
:
:
FlushDeferredTouchMoveEventsUnresampled
(
)
{
while
(
!
mDeferredTouchMoveEvents
.
empty
(
)
)
{
MultiTouchInput
input
;
uint64_t
eventId
;
std
:
:
tie
(
input
eventId
)
=
std
:
:
move
(
mDeferredTouchMoveEvents
.
front
(
)
)
;
mDeferredTouchMoveEvents
.
pop
(
)
;
PrependLeftoverHistoricalData
(
&
input
)
;
EmitEvent
(
std
:
:
move
(
input
)
eventId
)
;
mInResampledState
=
false
;
mOriginalOfResampledTouchMove
=
Nothing
(
)
;
}
}
void
TouchResampler
:
:
ReturnToNonResampledState
(
)
{
MOZ_RELEASE_ASSERT
(
mInResampledState
)
;
MOZ_RELEASE_ASSERT
(
mDeferredTouchMoveEvents
.
empty
(
)
"
Don
'
t
call
this
if
there
is
a
deferred
touch
move
event
.
"
"
We
can
return
to
the
non
-
resampled
state
by
sending
that
"
"
event
rather
than
a
copy
of
a
previous
event
.
"
)
;
MultiTouchInput
input
=
std
:
:
move
(
*
mOriginalOfResampledTouchMove
)
;
mOriginalOfResampledTouchMove
=
Nothing
(
)
;
if
(
mLastEmittedEventTime
>
input
.
mTimeStamp
)
{
input
.
mTimeStamp
=
mLastEmittedEventTime
;
}
for
(
auto
&
touch
:
input
.
mTouches
)
{
touch
.
mHistoricalData
.
Clear
(
)
;
}
PrependLeftoverHistoricalData
(
&
input
)
;
for
(
auto
&
touch
:
input
.
mTouches
)
{
touch
.
mHistoricalData
.
RemoveElementsBy
(
[
&
]
(
const
auto
&
histData
)
{
return
histData
.
mTimeStamp
>
=
input
.
mTimeStamp
;
}
)
;
}
EmitExtraEvent
(
std
:
:
move
(
input
)
)
;
mInResampledState
=
false
;
}
void
TouchResampler
:
:
TouchInfo
:
:
Update
(
const
SingleTouchData
&
aTouch
const
TimeStamp
&
aEventTime
)
{
for
(
const
auto
&
historicalData
:
aTouch
.
mHistoricalData
)
{
mBaseDataPoint
=
mLatestDataPoint
;
mLatestDataPoint
=
Some
(
DataPoint
{
historicalData
.
mTimeStamp
historicalData
.
mScreenPoint
}
)
;
}
mBaseDataPoint
=
mLatestDataPoint
;
mLatestDataPoint
=
Some
(
DataPoint
{
aEventTime
aTouch
.
mScreenPoint
}
)
;
}
ScreenIntPoint
TouchResampler
:
:
TouchInfo
:
:
ResampleAtTime
(
const
ScreenIntPoint
&
aLastObservedPosition
const
TimeStamp
&
aTimeStamp
)
{
TimeStamp
cutoff
=
aTimeStamp
-
TimeDuration
:
:
FromMilliseconds
(
kTouchResampleWindowSize
)
;
if
(
!
mBaseDataPoint
|
|
!
mLatestDataPoint
|
|
!
(
mBaseDataPoint
-
>
mTimeStamp
<
mLatestDataPoint
-
>
mTimeStamp
)
|
|
mBaseDataPoint
-
>
mTimeStamp
<
cutoff
)
{
return
aLastObservedPosition
;
}
TimeStamp
t1
=
mBaseDataPoint
-
>
mTimeStamp
;
TimeStamp
t2
=
mLatestDataPoint
-
>
mTimeStamp
;
double
t
=
(
aTimeStamp
-
t1
)
/
(
t2
-
t1
)
;
double
x1
=
mBaseDataPoint
-
>
mPosition
.
x
;
double
x2
=
mLatestDataPoint
-
>
mPosition
.
x
;
double
y1
=
mBaseDataPoint
-
>
mPosition
.
y
;
double
y2
=
mLatestDataPoint
-
>
mPosition
.
y
;
int32_t
resampledX
=
round
(
x1
+
t
*
(
x2
-
x1
)
)
;
int32_t
resampledY
=
round
(
y1
+
t
*
(
y2
-
y1
)
)
;
return
ScreenIntPoint
(
resampledX
resampledY
)
;
}
void
TouchResampler
:
:
CurrentTouches
:
:
UpdateFromEvent
(
const
MultiTouchInput
&
aInput
)
{
switch
(
aInput
.
mType
)
{
case
MultiTouchInput
:
:
MULTITOUCH_START
:
{
nsTArray
<
TouchInfo
>
newTouches
;
for
(
const
auto
&
touch
:
aInput
.
mTouches
)
{
const
auto
touchInfo
=
TouchByIdentifier
(
touch
.
mIdentifier
)
;
if
(
touchInfo
!
=
mTouches
.
end
(
)
)
{
newTouches
.
AppendElement
(
std
:
:
move
(
*
touchInfo
)
)
;
mTouches
.
RemoveElementAt
(
touchInfo
)
;
}
else
{
newTouches
.
AppendElement
(
TouchInfo
{
touch
.
mIdentifier
Nothing
(
)
Some
(
DataPoint
{
aInput
.
mTimeStamp
touch
.
mScreenPoint
}
)
}
)
;
}
}
MOZ_ASSERT
(
mTouches
.
IsEmpty
(
)
"
Missing
touch
end
before
touch
start
?
"
)
;
mTouches
=
std
:
:
move
(
newTouches
)
;
break
;
}
case
MultiTouchInput
:
:
MULTITOUCH_MOVE
:
{
for
(
const
auto
&
touch
:
aInput
.
mTouches
)
{
const
auto
touchInfo
=
TouchByIdentifier
(
touch
.
mIdentifier
)
;
MOZ_ASSERT
(
touchInfo
!
=
mTouches
.
end
(
)
)
;
if
(
touchInfo
!
=
mTouches
.
end
(
)
)
{
touchInfo
-
>
Update
(
touch
aInput
.
mTimeStamp
)
;
}
}
mLatestDataPointTime
=
aInput
.
mTimeStamp
;
break
;
}
case
MultiTouchInput
:
:
MULTITOUCH_END
:
{
MOZ_RELEASE_ASSERT
(
aInput
.
mTouches
.
Length
(
)
=
=
1
)
;
const
auto
touchInfo
=
TouchByIdentifier
(
aInput
.
mTouches
[
0
]
.
mIdentifier
)
;
MOZ_ASSERT
(
touchInfo
!
=
mTouches
.
end
(
)
)
;
if
(
touchInfo
!
=
mTouches
.
end
(
)
)
{
mTouches
.
RemoveElementAt
(
touchInfo
)
;
}
break
;
}
case
MultiTouchInput
:
:
MULTITOUCH_CANCEL
:
mTouches
.
Clear
(
)
;
break
;
}
}
nsTArray
<
TouchResampler
:
:
TouchInfo
>
:
:
iterator
TouchResampler
:
:
CurrentTouches
:
:
TouchByIdentifier
(
int32_t
aIdentifier
)
{
return
std
:
:
find_if
(
mTouches
.
begin
(
)
mTouches
.
end
(
)
[
aIdentifier
]
(
const
TouchInfo
&
info
)
{
return
info
.
mIdentifier
=
=
aIdentifier
;
}
)
;
}
ScreenIntPoint
TouchResampler
:
:
CurrentTouches
:
:
ResampleTouchPositionAtTime
(
int32_t
aIdentifier
const
ScreenIntPoint
&
aLastObservedPosition
const
TimeStamp
&
aTimeStamp
)
{
const
auto
touchInfo
=
TouchByIdentifier
(
aIdentifier
)
;
MOZ_ASSERT
(
touchInfo
!
=
mTouches
.
end
(
)
)
;
if
(
touchInfo
!
=
mTouches
.
end
(
)
)
{
return
touchInfo
-
>
ResampleAtTime
(
aLastObservedPosition
aTimeStamp
)
;
}
return
aLastObservedPosition
;
}
}
}
