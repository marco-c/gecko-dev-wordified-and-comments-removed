#
ifndef
nsTransferable_h__
#
define
nsTransferable_h__
#
include
"
nsIFormatConverter
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
prio
.
h
"
class
nsIMutableArray
;
struct
DataStruct
{
explicit
DataStruct
(
const
char
*
aFlavor
)
:
mDataLen
(
0
)
mCacheFD
(
nullptr
)
mFlavor
(
aFlavor
)
{
}
DataStruct
(
DataStruct
&
&
aRHS
)
;
~
DataStruct
(
)
;
const
nsCString
&
GetFlavor
(
)
const
{
return
mFlavor
;
}
void
SetData
(
nsISupports
*
inData
uint32_t
inDataLen
bool
aIsPrivateData
)
;
void
GetData
(
nsISupports
*
*
outData
uint32_t
*
outDataLen
)
;
bool
IsDataAvailable
(
)
const
{
return
mData
?
mDataLen
>
0
:
mCacheFD
!
=
nullptr
;
}
protected
:
enum
{
kLargeDatasetSize
=
1000000
}
;
nsresult
WriteCache
(
nsISupports
*
aData
uint32_t
aDataLen
)
;
nsresult
ReadCache
(
nsISupports
*
*
aData
uint32_t
*
aDataLen
)
;
nsCOMPtr
<
nsISupports
>
mData
;
uint32_t
mDataLen
;
PRFileDesc
*
mCacheFD
;
const
nsCString
mFlavor
;
private
:
DataStruct
(
const
DataStruct
&
)
=
delete
;
DataStruct
&
operator
=
(
const
DataStruct
&
)
=
delete
;
}
;
class
nsTransferable
:
public
nsITransferable
{
public
:
nsTransferable
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSITRANSFERABLE
protected
:
virtual
~
nsTransferable
(
)
;
already_AddRefed
<
nsIMutableArray
>
GetTransferDataFlavors
(
)
;
nsTArray
<
DataStruct
>
mDataArray
;
nsCOMPtr
<
nsIFormatConverter
>
mFormatConv
;
bool
mPrivateData
;
nsCOMPtr
<
nsIPrincipal
>
mRequestingPrincipal
;
nsContentPolicyType
mContentPolicyType
;
#
if
DEBUG
bool
mInitialized
;
#
endif
}
;
#
endif
