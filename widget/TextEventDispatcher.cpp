#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsView
.
h
"
namespace
mozilla
{
namespace
widget
{
bool
TextEventDispatcher
:
:
sDispatchKeyEventsDuringComposition
=
false
;
TextEventDispatcher
:
:
TextEventDispatcher
(
nsIWidget
*
aWidget
)
:
mWidget
(
aWidget
)
mDispatchingEvent
(
0
)
mInputTransactionType
(
eNoInputTransaction
)
mIsComposing
(
false
)
{
MOZ_RELEASE_ASSERT
(
mWidget
"
aWidget
must
not
be
nullptr
"
)
;
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
Preferences
:
:
AddBoolVarCache
(
&
sDispatchKeyEventsDuringComposition
"
dom
.
keyboardevent
.
dispatch_during_composition
"
false
)
;
sInitialized
=
true
;
}
}
nsresult
TextEventDispatcher
:
:
BeginInputTransaction
(
TextEventDispatcherListener
*
aListener
)
{
return
BeginInputTransactionInternal
(
aListener
eSameProcessSyncInputTransaction
)
;
}
nsresult
TextEventDispatcher
:
:
BeginTestInputTransaction
(
TextEventDispatcherListener
*
aListener
bool
aIsAPZAware
)
{
return
BeginInputTransactionInternal
(
aListener
aIsAPZAware
?
eAsyncTestInputTransaction
:
eSameProcessSyncTestInputTransaction
)
;
}
nsresult
TextEventDispatcher
:
:
BeginNativeInputTransaction
(
)
{
if
(
NS_WARN_IF
(
!
mWidget
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
TextEventDispatcherListener
>
listener
=
mWidget
-
>
GetNativeTextEventDispatcherListener
(
)
;
if
(
NS_WARN_IF
(
!
listener
)
)
{
return
NS_ERROR_FAILURE
;
}
return
BeginInputTransactionInternal
(
listener
eNativeInputTransaction
)
;
}
nsresult
TextEventDispatcher
:
:
BeginInputTransactionInternal
(
TextEventDispatcherListener
*
aListener
InputTransactionType
aType
)
{
if
(
NS_WARN_IF
(
!
aListener
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
TextEventDispatcherListener
>
listener
=
do_QueryReferent
(
mListener
)
;
if
(
listener
)
{
if
(
listener
=
=
aListener
&
&
mInputTransactionType
=
=
aType
)
{
return
NS_OK
;
}
if
(
IsComposing
(
)
|
|
IsDispatchingEvent
(
)
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
}
mListener
=
do_GetWeakReference
(
aListener
)
;
mInputTransactionType
=
aType
;
if
(
listener
&
&
listener
!
=
aListener
)
{
listener
-
>
OnRemovedFrom
(
this
)
;
}
return
NS_OK
;
}
void
TextEventDispatcher
:
:
EndInputTransaction
(
TextEventDispatcherListener
*
aListener
)
{
if
(
NS_WARN_IF
(
IsComposing
(
)
)
|
|
NS_WARN_IF
(
IsDispatchingEvent
(
)
)
)
{
return
;
}
mInputTransactionType
=
eNoInputTransaction
;
nsCOMPtr
<
TextEventDispatcherListener
>
listener
=
do_QueryReferent
(
mListener
)
;
if
(
NS_WARN_IF
(
!
listener
)
)
{
return
;
}
if
(
NS_WARN_IF
(
listener
!
=
aListener
)
)
{
return
;
}
mListener
=
nullptr
;
listener
-
>
OnRemovedFrom
(
this
)
;
}
void
TextEventDispatcher
:
:
OnDestroyWidget
(
)
{
mWidget
=
nullptr
;
mPendingComposition
.
Clear
(
)
;
nsCOMPtr
<
TextEventDispatcherListener
>
listener
=
do_QueryReferent
(
mListener
)
;
mListener
=
nullptr
;
mInputTransactionType
=
eNoInputTransaction
;
if
(
listener
)
{
listener
-
>
OnRemovedFrom
(
this
)
;
}
}
nsresult
TextEventDispatcher
:
:
GetState
(
)
const
{
nsCOMPtr
<
TextEventDispatcherListener
>
listener
=
do_QueryReferent
(
mListener
)
;
if
(
!
listener
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
!
mWidget
|
|
mWidget
-
>
Destroyed
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
}
void
TextEventDispatcher
:
:
InitEvent
(
WidgetGUIEvent
&
aEvent
)
const
{
aEvent
.
mTime
=
PR_IntervalNow
(
)
;
aEvent
.
mRefPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
aEvent
.
mFlags
.
mIsSynthesizedForTests
=
IsForTests
(
)
;
if
(
aEvent
.
mClass
!
=
eCompositionEventClass
)
{
return
;
}
void
*
pseudoIMEContext
=
GetPseudoIMEContext
(
)
;
if
(
pseudoIMEContext
)
{
aEvent
.
AsCompositionEvent
(
)
-
>
mNativeIMEContext
.
InitWithRawNativeIMEContext
(
pseudoIMEContext
)
;
}
#
ifdef
DEBUG
else
{
MOZ_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Why
did
the
content
process
start
native
event
transaction
?
"
)
;
MOZ_ASSERT
(
aEvent
.
AsCompositionEvent
(
)
-
>
mNativeIMEContext
.
IsValid
(
)
"
Native
IME
context
shouldn
'
t
be
invalid
"
)
;
}
#
endif
}
nsresult
TextEventDispatcher
:
:
DispatchEvent
(
nsIWidget
*
aWidget
WidgetGUIEvent
&
aEvent
nsEventStatus
&
aStatus
)
{
MOZ_ASSERT
(
!
aEvent
.
AsInputEvent
(
)
"
Use
DispatchInputEvent
(
)
"
)
;
RefPtr
<
TextEventDispatcher
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIWidget
>
widget
(
aWidget
)
;
mDispatchingEvent
+
+
;
nsresult
rv
=
widget
-
>
DispatchEvent
(
&
aEvent
aStatus
)
;
mDispatchingEvent
-
-
;
return
rv
;
}
nsresult
TextEventDispatcher
:
:
DispatchInputEvent
(
nsIWidget
*
aWidget
WidgetInputEvent
&
aEvent
nsEventStatus
&
aStatus
)
{
RefPtr
<
TextEventDispatcher
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIWidget
>
widget
(
aWidget
)
;
mDispatchingEvent
+
+
;
nsresult
rv
=
NS_OK
;
if
(
ShouldSendInputEventToAPZ
(
)
)
{
aStatus
=
widget
-
>
DispatchInputEvent
(
&
aEvent
)
;
}
else
{
rv
=
widget
-
>
DispatchEvent
(
&
aEvent
aStatus
)
;
}
mDispatchingEvent
-
-
;
return
rv
;
}
nsresult
TextEventDispatcher
:
:
StartComposition
(
nsEventStatus
&
aStatus
const
WidgetEventTime
*
aEventTime
)
{
aStatus
=
nsEventStatus_eIgnore
;
nsresult
rv
=
GetState
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
mIsComposing
)
)
{
return
NS_ERROR_FAILURE
;
}
mIsComposing
=
true
;
WidgetCompositionEvent
compositionStartEvent
(
true
eCompositionStart
mWidget
)
;
InitEvent
(
compositionStartEvent
)
;
if
(
aEventTime
)
{
compositionStartEvent
.
AssignEventTime
(
*
aEventTime
)
;
}
rv
=
DispatchEvent
(
mWidget
compositionStartEvent
aStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TextEventDispatcher
:
:
StartCompositionAutomaticallyIfNecessary
(
nsEventStatus
&
aStatus
const
WidgetEventTime
*
aEventTime
)
{
if
(
IsComposing
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
StartComposition
(
aStatus
aEventTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
IsComposing
(
)
)
{
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
rv
=
GetState
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
rv
!
=
NS_ERROR_NOT_INITIALIZED
"
aDispatcher
must
still
be
initialized
in
this
case
"
)
;
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
aStatus
=
nsEventStatus_eIgnore
;
return
NS_OK
;
}
nsresult
TextEventDispatcher
:
:
CommitComposition
(
nsEventStatus
&
aStatus
const
nsAString
*
aCommitString
const
WidgetEventTime
*
aEventTime
)
{
aStatus
=
nsEventStatus_eIgnore
;
nsresult
rv
=
GetState
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
IsComposing
(
)
&
&
(
!
aCommitString
|
|
aCommitString
-
>
IsEmpty
(
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIWidget
>
widget
(
mWidget
)
;
rv
=
StartCompositionAutomaticallyIfNecessary
(
aStatus
aEventTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
NS_OK
;
}
mIsComposing
=
false
;
EventMessage
message
=
aCommitString
?
eCompositionCommit
:
eCompositionCommitAsIs
;
WidgetCompositionEvent
compositionCommitEvent
(
true
message
widget
)
;
InitEvent
(
compositionCommitEvent
)
;
if
(
aEventTime
)
{
compositionCommitEvent
.
AssignEventTime
(
*
aEventTime
)
;
}
if
(
message
=
=
eCompositionCommit
)
{
compositionCommitEvent
.
mData
=
*
aCommitString
;
compositionCommitEvent
.
mData
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
}
rv
=
DispatchEvent
(
widget
compositionCommitEvent
aStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
TextEventDispatcher
:
:
NotifyIME
(
const
IMENotification
&
aIMENotification
)
{
nsresult
rv
=
NS_ERROR_NOT_IMPLEMENTED
;
nsCOMPtr
<
TextEventDispatcherListener
>
listener
=
do_QueryReferent
(
mListener
)
;
if
(
listener
)
{
rv
=
listener
-
>
NotifyIME
(
this
aIMENotification
)
;
}
if
(
mInputTransactionType
=
=
eNativeInputTransaction
|
|
!
mWidget
)
{
return
rv
;
}
nsCOMPtr
<
TextEventDispatcherListener
>
nativeListener
=
mWidget
-
>
GetNativeTextEventDispatcherListener
(
)
;
if
(
!
nativeListener
)
{
return
rv
;
}
switch
(
aIMENotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
case
REQUEST_TO_CANCEL_COMPOSITION
:
return
rv
;
default
:
{
nsresult
rv2
=
nativeListener
-
>
NotifyIME
(
this
aIMENotification
)
;
return
rv
=
=
NS_ERROR_NOT_IMPLEMENTED
?
rv2
:
rv
;
}
}
}
bool
TextEventDispatcher
:
:
DispatchKeyboardEvent
(
EventMessage
aMessage
const
WidgetKeyboardEvent
&
aKeyboardEvent
nsEventStatus
&
aStatus
void
*
aData
)
{
return
DispatchKeyboardEventInternal
(
aMessage
aKeyboardEvent
aStatus
aData
)
;
}
bool
TextEventDispatcher
:
:
DispatchKeyboardEventInternal
(
EventMessage
aMessage
const
WidgetKeyboardEvent
&
aKeyboardEvent
nsEventStatus
&
aStatus
void
*
aData
uint32_t
aIndexOfKeypress
bool
aNeedsCallback
)
{
MOZ_ASSERT
(
WidgetKeyboardEvent
:
:
IsKeyDownOrKeyDownOnPlugin
(
aMessage
)
|
|
WidgetKeyboardEvent
:
:
IsKeyUpOrKeyUpOnPlugin
(
aMessage
)
|
|
aMessage
=
=
eKeyPress
"
Invalid
aMessage
value
"
)
;
nsresult
rv
=
GetState
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
if
(
aMessage
=
=
eKeyPress
&
&
!
aKeyboardEvent
.
ShouldCauseKeypressEvents
(
)
)
{
return
false
;
}
if
(
IsComposing
(
)
&
&
!
WidgetKeyboardEvent
:
:
IsKeyEventOnPlugin
(
aMessage
)
)
{
if
(
!
sDispatchKeyEventsDuringComposition
|
|
aMessage
=
=
eKeyPress
)
{
return
false
;
}
}
WidgetKeyboardEvent
keyEvent
(
true
aMessage
mWidget
)
;
InitEvent
(
keyEvent
)
;
keyEvent
.
AssignKeyEventData
(
aKeyboardEvent
false
)
;
if
(
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
keyEvent
.
PreventDefaultBeforeDispatch
(
)
;
}
if
(
keyEvent
.
mKeyNameIndex
!
=
KEY_NAME_INDEX_USE_STRING
)
{
MOZ_ASSERT
(
!
aIndexOfKeypress
"
aIndexOfKeypress
must
be
0
for
non
-
printable
key
"
)
;
keyEvent
.
SetCharCode
(
0
)
;
}
else
{
if
(
WidgetKeyboardEvent
:
:
IsKeyDownOrKeyDownOnPlugin
(
aMessage
)
|
|
WidgetKeyboardEvent
:
:
IsKeyUpOrKeyUpOnPlugin
(
aMessage
)
)
{
MOZ_RELEASE_ASSERT
(
!
aIndexOfKeypress
"
aIndexOfKeypress
must
be
0
for
either
eKeyDown
or
eKeyUp
"
)
;
}
else
{
MOZ_RELEASE_ASSERT
(
!
aIndexOfKeypress
|
|
aIndexOfKeypress
<
keyEvent
.
mKeyValue
.
Length
(
)
"
aIndexOfKeypress
must
be
0
-
mKeyValue
.
Length
(
)
-
1
"
)
;
}
wchar_t
ch
=
keyEvent
.
mKeyValue
.
IsEmpty
(
)
?
0
:
keyEvent
.
mKeyValue
[
aIndexOfKeypress
]
;
keyEvent
.
SetCharCode
(
static_cast
<
uint32_t
>
(
ch
)
)
;
if
(
aMessage
=
=
eKeyPress
)
{
keyEvent
.
mKeyCode
=
0
;
if
(
ch
)
{
keyEvent
.
mKeyValue
.
Assign
(
ch
)
;
}
else
{
keyEvent
.
mKeyValue
.
Truncate
(
)
;
}
}
}
if
(
WidgetKeyboardEvent
:
:
IsKeyUpOrKeyUpOnPlugin
(
aMessage
)
)
{
keyEvent
.
mIsRepeat
=
false
;
}
keyEvent
.
mIsComposing
=
false
;
if
(
mInputTransactionType
=
=
eNativeInputTransaction
)
{
keyEvent
.
mNativeKeyEvent
=
aKeyboardEvent
.
mNativeKeyEvent
;
}
else
{
keyEvent
.
mNativeKeyEvent
=
nullptr
;
keyEvent
.
mPluginEvent
.
Clear
(
)
;
}
keyEvent
.
mAlternativeCharCodes
.
Clear
(
)
;
if
(
(
WidgetKeyboardEvent
:
:
IsKeyDownOrKeyDownOnPlugin
(
aMessage
)
|
|
aMessage
=
=
eKeyPress
)
&
&
(
aNeedsCallback
|
|
keyEvent
.
IsControl
(
)
|
|
keyEvent
.
IsAlt
(
)
|
|
keyEvent
.
IsMeta
(
)
|
|
keyEvent
.
IsOS
(
)
)
)
{
nsCOMPtr
<
TextEventDispatcherListener
>
listener
=
do_QueryReferent
(
mListener
)
;
if
(
listener
)
{
DebugOnly
<
WidgetKeyboardEvent
>
original
(
keyEvent
)
;
listener
-
>
WillDispatchKeyboardEvent
(
this
keyEvent
aIndexOfKeypress
aData
)
;
MOZ_ASSERT
(
keyEvent
.
mMessage
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mMessage
)
;
MOZ_ASSERT
(
keyEvent
.
mKeyCode
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mKeyCode
)
;
MOZ_ASSERT
(
keyEvent
.
mLocation
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mLocation
)
;
MOZ_ASSERT
(
keyEvent
.
mIsRepeat
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mIsRepeat
)
;
MOZ_ASSERT
(
keyEvent
.
mIsComposing
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mIsComposing
)
;
MOZ_ASSERT
(
keyEvent
.
mKeyNameIndex
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mKeyNameIndex
)
;
MOZ_ASSERT
(
keyEvent
.
mCodeNameIndex
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mCodeNameIndex
)
;
MOZ_ASSERT
(
keyEvent
.
mKeyValue
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mKeyValue
)
;
MOZ_ASSERT
(
keyEvent
.
mCodeValue
=
=
static_cast
<
WidgetKeyboardEvent
&
>
(
original
)
.
mCodeValue
)
;
}
}
DispatchInputEvent
(
mWidget
keyEvent
aStatus
)
;
return
true
;
}
bool
TextEventDispatcher
:
:
MaybeDispatchKeypressEvents
(
const
WidgetKeyboardEvent
&
aKeyboardEvent
nsEventStatus
&
aStatus
void
*
aData
bool
aNeedsCallback
)
{
if
(
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
if
(
!
aKeyboardEvent
.
ShouldCauseKeypressEvents
(
)
)
{
return
false
;
}
size_t
keypressCount
=
aKeyboardEvent
.
mKeyNameIndex
!
=
KEY_NAME_INDEX_USE_STRING
?
1
:
std
:
:
max
(
static_cast
<
nsAString
:
:
size_type
>
(
1
)
aKeyboardEvent
.
mKeyValue
.
Length
(
)
)
;
bool
isDispatched
=
false
;
bool
consumed
=
false
;
for
(
size_t
i
=
0
;
i
<
keypressCount
;
i
+
+
)
{
aStatus
=
nsEventStatus_eIgnore
;
if
(
!
DispatchKeyboardEventInternal
(
eKeyPress
aKeyboardEvent
aStatus
aData
i
aNeedsCallback
)
)
{
break
;
}
isDispatched
=
true
;
if
(
!
consumed
)
{
consumed
=
(
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
;
}
}
if
(
consumed
)
{
aStatus
=
nsEventStatus_eConsumeNoDefault
;
}
return
isDispatched
;
}
TextEventDispatcher
:
:
PendingComposition
:
:
PendingComposition
(
)
{
Clear
(
)
;
}
void
TextEventDispatcher
:
:
PendingComposition
:
:
Clear
(
)
{
mString
.
Truncate
(
)
;
mClauses
=
nullptr
;
mCaret
.
mRangeType
=
TextRangeType
:
:
eUninitialized
;
}
void
TextEventDispatcher
:
:
PendingComposition
:
:
EnsureClauseArray
(
)
{
if
(
mClauses
)
{
return
;
}
mClauses
=
new
TextRangeArray
(
)
;
}
nsresult
TextEventDispatcher
:
:
PendingComposition
:
:
SetString
(
const
nsAString
&
aString
)
{
mString
=
aString
;
return
NS_OK
;
}
nsresult
TextEventDispatcher
:
:
PendingComposition
:
:
AppendClause
(
uint32_t
aLength
TextRangeType
aTextRangeType
)
{
if
(
NS_WARN_IF
(
!
aLength
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
switch
(
aTextRangeType
)
{
case
TextRangeType
:
:
eRawClause
:
case
TextRangeType
:
:
eSelectedRawClause
:
case
TextRangeType
:
:
eConvertedClause
:
case
TextRangeType
:
:
eSelectedClause
:
{
EnsureClauseArray
(
)
;
TextRange
textRange
;
textRange
.
mStartOffset
=
mClauses
-
>
IsEmpty
(
)
?
0
:
mClauses
-
>
LastElement
(
)
.
mEndOffset
;
textRange
.
mEndOffset
=
textRange
.
mStartOffset
+
aLength
;
textRange
.
mRangeType
=
aTextRangeType
;
mClauses
-
>
AppendElement
(
textRange
)
;
return
NS_OK
;
}
default
:
return
NS_ERROR_INVALID_ARG
;
}
}
nsresult
TextEventDispatcher
:
:
PendingComposition
:
:
SetCaret
(
uint32_t
aOffset
uint32_t
aLength
)
{
mCaret
.
mStartOffset
=
aOffset
;
mCaret
.
mEndOffset
=
mCaret
.
mStartOffset
+
aLength
;
mCaret
.
mRangeType
=
TextRangeType
:
:
eCaret
;
return
NS_OK
;
}
nsresult
TextEventDispatcher
:
:
PendingComposition
:
:
Set
(
const
nsAString
&
aString
const
TextRangeArray
*
aRanges
)
{
Clear
(
)
;
nsAutoString
str
(
aString
)
;
str
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
nsresult
rv
=
SetString
(
str
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aRanges
|
|
aRanges
-
>
IsEmpty
(
)
)
{
if
(
!
aString
.
IsEmpty
(
)
)
{
rv
=
AppendClause
(
str
.
Length
(
)
TextRangeType
:
:
eRawClause
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
for
(
uint32_t
i
=
0
;
i
<
aRanges
-
>
Length
(
)
;
+
+
i
)
{
TextRange
range
=
aRanges
-
>
ElementAt
(
i
)
;
TextRange
nativeRange
=
range
;
if
(
nativeRange
.
mStartOffset
>
0
)
{
nsAutoString
preText
(
Substring
(
aString
0
nativeRange
.
mStartOffset
)
)
;
preText
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
range
.
mStartOffset
=
preText
.
Length
(
)
;
}
if
(
nativeRange
.
Length
(
)
=
=
0
)
{
range
.
mEndOffset
=
range
.
mStartOffset
;
}
else
{
nsAutoString
clause
(
Substring
(
aString
nativeRange
.
mStartOffset
nativeRange
.
Length
(
)
)
)
;
clause
.
ReplaceSubstring
(
NS_LITERAL_STRING
(
"
\
r
\
n
"
)
NS_LITERAL_STRING
(
"
\
n
"
)
)
;
range
.
mEndOffset
=
range
.
mStartOffset
+
clause
.
Length
(
)
;
}
if
(
range
.
mRangeType
=
=
TextRangeType
:
:
eCaret
)
{
mCaret
=
range
;
}
else
{
EnsureClauseArray
(
)
;
mClauses
-
>
AppendElement
(
range
)
;
}
}
return
NS_OK
;
}
nsresult
TextEventDispatcher
:
:
PendingComposition
:
:
Flush
(
TextEventDispatcher
*
aDispatcher
nsEventStatus
&
aStatus
const
WidgetEventTime
*
aEventTime
)
{
aStatus
=
nsEventStatus_eIgnore
;
nsresult
rv
=
aDispatcher
-
>
GetState
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mClauses
&
&
!
mClauses
-
>
IsEmpty
(
)
&
&
mClauses
-
>
LastElement
(
)
.
mEndOffset
!
=
mString
.
Length
(
)
)
{
NS_WARNING
(
"
Sum
of
length
of
the
all
clauses
must
be
same
as
the
string
"
"
length
"
)
;
Clear
(
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mCaret
.
mRangeType
=
=
TextRangeType
:
:
eCaret
)
{
if
(
mCaret
.
mEndOffset
>
mString
.
Length
(
)
)
{
NS_WARNING
(
"
Caret
position
is
out
of
the
composition
string
"
)
;
Clear
(
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
EnsureClauseArray
(
)
;
mClauses
-
>
AppendElement
(
mCaret
)
;
}
RefPtr
<
TextEventDispatcher
>
kungFuDeathGrip
(
aDispatcher
)
;
nsCOMPtr
<
nsIWidget
>
widget
(
aDispatcher
-
>
mWidget
)
;
WidgetCompositionEvent
compChangeEvent
(
true
eCompositionChange
widget
)
;
aDispatcher
-
>
InitEvent
(
compChangeEvent
)
;
if
(
aEventTime
)
{
compChangeEvent
.
AssignEventTime
(
*
aEventTime
)
;
}
compChangeEvent
.
mData
=
mString
;
if
(
mClauses
)
{
MOZ_ASSERT
(
!
mClauses
-
>
IsEmpty
(
)
"
mClauses
must
be
non
-
empty
array
when
it
'
s
not
nullptr
"
)
;
compChangeEvent
.
mRanges
=
mClauses
;
}
Clear
(
)
;
rv
=
aDispatcher
-
>
StartCompositionAutomaticallyIfNecessary
(
aStatus
aEventTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
NS_OK
;
}
rv
=
aDispatcher
-
>
DispatchEvent
(
widget
compChangeEvent
aStatus
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
}
