#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsLinebreakConverter
.
h
"
#
include
"
nsReadableUtils
.
h
"
void
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
const
char
*
aFlavor
const
void
*
aDataBuff
uint32_t
aDataLen
nsISupports
*
*
aPrimitive
)
{
if
(
!
aPrimitive
)
return
;
if
(
strcmp
(
aFlavor
kTextMime
)
=
=
0
|
|
strcmp
(
aFlavor
kNativeHTMLMime
)
=
=
0
)
{
nsCOMPtr
<
nsISupportsCString
>
primitive
=
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
;
if
(
primitive
)
{
const
char
*
start
=
reinterpret_cast
<
const
char
*
>
(
aDataBuff
)
;
primitive
-
>
SetData
(
Substring
(
start
start
+
aDataLen
)
)
;
NS_ADDREF
(
*
aPrimitive
=
primitive
)
;
}
}
else
{
nsCOMPtr
<
nsISupportsString
>
primitive
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
)
;
if
(
primitive
)
{
if
(
aDataLen
%
2
)
{
auto
buffer
=
MakeUnique
<
char
[
]
>
(
aDataLen
+
1
)
;
if
(
!
MOZ_LIKELY
(
buffer
)
)
return
;
memcpy
(
buffer
.
get
(
)
aDataBuff
aDataLen
)
;
buffer
[
aDataLen
]
=
0
;
const
char16_t
*
start
=
reinterpret_cast
<
const
char16_t
*
>
(
buffer
.
get
(
)
)
;
primitive
-
>
SetData
(
Substring
(
start
start
+
(
aDataLen
+
1
)
/
2
)
)
;
}
else
{
const
char16_t
*
start
=
reinterpret_cast
<
const
char16_t
*
>
(
aDataBuff
)
;
primitive
-
>
SetData
(
Substring
(
start
start
+
(
aDataLen
/
2
)
)
)
;
}
NS_ADDREF
(
*
aPrimitive
=
primitive
)
;
}
}
}
void
nsPrimitiveHelpers
:
:
CreatePrimitiveForCFHTML
(
const
void
*
aDataBuff
uint32_t
*
aDataLen
nsISupports
*
*
aPrimitive
)
{
if
(
!
aPrimitive
)
return
;
nsCOMPtr
<
nsISupportsString
>
primitive
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
)
;
if
(
!
primitive
)
return
;
void
*
utf8
=
moz_xmalloc
(
*
aDataLen
)
;
if
(
!
utf8
)
return
;
memcpy
(
utf8
aDataBuff
*
aDataLen
)
;
int32_t
signedLen
=
static_cast
<
int32_t
>
(
*
aDataLen
)
;
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
kTextMime
&
utf8
&
signedLen
)
;
*
aDataLen
=
signedLen
;
nsAutoString
str
(
NS_ConvertUTF8toUTF16
(
reinterpret_cast
<
const
char
*
>
(
utf8
)
*
aDataLen
)
)
;
free
(
utf8
)
;
*
aDataLen
=
str
.
Length
(
)
*
sizeof
(
char16_t
)
;
primitive
-
>
SetData
(
str
)
;
NS_ADDREF
(
*
aPrimitive
=
primitive
)
;
}
void
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
const
char
*
aFlavor
nsISupports
*
aPrimitive
void
*
*
aDataBuff
uint32_t
aDataLen
)
{
if
(
!
aDataBuff
)
return
;
*
aDataBuff
=
nullptr
;
if
(
strcmp
(
aFlavor
kTextMime
)
=
=
0
)
{
nsCOMPtr
<
nsISupportsCString
>
plainText
(
do_QueryInterface
(
aPrimitive
)
)
;
if
(
plainText
)
{
nsAutoCString
data
;
plainText
-
>
GetData
(
data
)
;
*
aDataBuff
=
ToNewCString
(
data
)
;
}
}
else
{
nsCOMPtr
<
nsISupportsString
>
doubleByteText
(
do_QueryInterface
(
aPrimitive
)
)
;
if
(
doubleByteText
)
{
nsAutoString
data
;
doubleByteText
-
>
GetData
(
data
)
;
*
aDataBuff
=
ToNewUnicode
(
data
)
;
}
}
}
nsresult
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
const
char
*
inFlavor
void
*
*
ioData
int32_t
*
ioLengthInBytes
)
{
NS_ASSERTION
(
ioData
&
&
*
ioData
&
&
ioLengthInBytes
"
Bad
Params
"
)
;
if
(
!
(
ioData
&
&
*
ioData
&
&
ioLengthInBytes
)
)
return
NS_ERROR_INVALID_ARG
;
nsresult
retVal
=
NS_OK
;
if
(
strcmp
(
inFlavor
"
text
/
plain
"
)
=
=
0
)
{
char
*
buffAsChars
=
reinterpret_cast
<
char
*
>
(
*
ioData
)
;
char
*
oldBuffer
=
buffAsChars
;
retVal
=
nsLinebreakConverter
:
:
ConvertLineBreaksInSitu
(
&
buffAsChars
nsLinebreakConverter
:
:
eLinebreakAny
nsLinebreakConverter
:
:
eLinebreakContent
*
ioLengthInBytes
ioLengthInBytes
)
;
if
(
NS_SUCCEEDED
(
retVal
)
)
{
if
(
buffAsChars
!
=
oldBuffer
)
free
(
oldBuffer
)
;
*
ioData
=
buffAsChars
;
}
}
else
if
(
strcmp
(
inFlavor
"
image
/
jpeg
"
)
=
=
0
)
{
}
else
{
char16_t
*
buffAsUnichar
=
reinterpret_cast
<
char16_t
*
>
(
*
ioData
)
;
char16_t
*
oldBuffer
=
buffAsUnichar
;
int32_t
newLengthInChars
;
retVal
=
nsLinebreakConverter
:
:
ConvertUnicharLineBreaksInSitu
(
&
buffAsUnichar
nsLinebreakConverter
:
:
eLinebreakAny
nsLinebreakConverter
:
:
eLinebreakContent
*
ioLengthInBytes
/
sizeof
(
char16_t
)
&
newLengthInChars
)
;
if
(
NS_SUCCEEDED
(
retVal
)
)
{
if
(
buffAsUnichar
!
=
oldBuffer
)
free
(
oldBuffer
)
;
*
ioData
=
buffAsUnichar
;
*
ioLengthInBytes
=
newLengthInChars
*
sizeof
(
char16_t
)
;
}
}
return
retVal
;
}
