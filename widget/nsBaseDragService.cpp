#
include
"
nsBaseDragService
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMDragEvent
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsISelectionPrivate
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIDOMDataTransfer
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
SVGImageContext
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferItemList
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
TabParent
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
#
define
DRAGIMAGES_PREF
"
nglayout
.
enable_drag_images
"
nsBaseDragService
:
:
nsBaseDragService
(
)
:
mCanDrop
(
false
)
mOnlyChromeDrop
(
false
)
mDoingDrag
(
false
)
mHasImage
(
false
)
mUserCancelled
(
false
)
mDragEventDispatchedToChildProcess
(
false
)
mDragAction
(
DRAGDROP_ACTION_NONE
)
mDragActionFromChildProcess
(
DRAGDROP_ACTION_UNINITIALIZED
)
mTargetSize
(
0
0
)
mContentPolicyType
(
nsIContentPolicy
:
:
TYPE_OTHER
)
mSuppressLevel
(
0
)
mInputSource
(
nsIDOMMouseEvent
:
:
MOZ_SOURCE_MOUSE
)
{
}
nsBaseDragService
:
:
~
nsBaseDragService
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
nsBaseDragService
nsIDragService
nsIDragSession
)
NS_IMETHODIMP
nsBaseDragService
:
:
SetCanDrop
(
bool
aCanDrop
)
{
mCanDrop
=
aCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetCanDrop
(
bool
*
aCanDrop
)
{
*
aCanDrop
=
mCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetOnlyChromeDrop
(
bool
aOnlyChrome
)
{
mOnlyChromeDrop
=
aOnlyChrome
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetOnlyChromeDrop
(
bool
*
aOnlyChrome
)
{
*
aOnlyChrome
=
mOnlyChromeDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetDragAction
(
uint32_t
anAction
)
{
mDragAction
=
anAction
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetDragAction
(
uint32_t
*
anAction
)
{
*
anAction
=
mDragAction
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetTargetSize
(
nsSize
aDragTargetSize
)
{
mTargetSize
=
aDragTargetSize
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetTargetSize
(
nsSize
*
aDragTargetSize
)
{
*
aDragTargetSize
=
mTargetSize
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
*
aNumItems
=
0
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetSourceDocument
(
nsIDOMDocument
*
*
aSourceDocument
)
{
*
aSourceDocument
=
mSourceDocument
.
get
(
)
;
NS_IF_ADDREF
(
*
aSourceDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetSourceNode
(
nsIDOMNode
*
*
aSourceNode
)
{
*
aSourceNode
=
mSourceNode
.
get
(
)
;
NS_IF_ADDREF
(
*
aSourceNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetDataTransfer
(
nsIDOMDataTransfer
*
*
aDataTransfer
)
{
*
aDataTransfer
=
mDataTransfer
;
NS_IF_ADDREF
(
*
aDataTransfer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetDataTransfer
(
nsIDOMDataTransfer
*
aDataTransfer
)
{
mDataTransfer
=
aDataTransfer
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSession
(
nsIDOMNode
*
aDOMNode
nsIArray
*
aTransferableArray
nsIScriptableRegion
*
aDragRgn
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_OTHER
)
{
AUTO_PROFILER_LABEL
(
"
nsBaseDragService
:
:
InvokeDragSession
"
OTHER
)
;
NS_ENSURE_TRUE
(
aDOMNode
NS_ERROR_INVALID_ARG
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
aDOMNode
-
>
GetOwnerDocument
(
getter_AddRefs
(
mSourceDocument
)
)
;
mSourceNode
=
aDOMNode
;
mContentPolicyType
=
aContentPolicyType
;
mEndDragPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
nsIPresShell
:
:
ClearMouseCapture
(
nullptr
)
;
nsresult
rv
=
InvokeDragSessionImpl
(
aTransferableArray
aDragRgn
aActionType
)
;
if
(
NS_FAILED
(
rv
)
)
{
mSourceNode
=
nullptr
;
mSourceDocument
=
nullptr
;
}
return
rv
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSessionWithImage
(
nsIDOMNode
*
aDOMNode
nsIArray
*
aTransferableArray
nsIScriptableRegion
*
aRegion
uint32_t
aActionType
nsIDOMNode
*
aImage
int32_t
aImageX
int32_t
aImageY
nsIDOMDragEvent
*
aDragEvent
nsIDOMDataTransfer
*
aDataTransfer
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aDataTransfer
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
mDataTransfer
=
aDataTransfer
;
mSelection
=
nullptr
;
mHasImage
=
true
;
mDragPopup
=
nullptr
;
mImage
=
aImage
;
mImageOffset
=
CSSIntPoint
(
aImageX
aImageY
)
;
aDragEvent
-
>
GetScreenX
(
&
mScreenPosition
.
x
)
;
aDragEvent
-
>
GetScreenY
(
&
mScreenPosition
.
y
)
;
aDragEvent
-
>
GetMozInputSource
(
&
mInputSource
)
;
nsresult
rv
=
InvokeDragSession
(
aDOMNode
aTransferableArray
aRegion
aActionType
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
)
;
if
(
NS_FAILED
(
rv
)
)
{
mImage
=
nullptr
;
mHasImage
=
false
;
mDataTransfer
=
nullptr
;
}
return
rv
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSessionWithSelection
(
nsISelection
*
aSelection
nsIArray
*
aTransferableArray
uint32_t
aActionType
nsIDOMDragEvent
*
aDragEvent
nsIDOMDataTransfer
*
aDataTransfer
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aDragEvent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
mDataTransfer
=
aDataTransfer
;
mSelection
=
aSelection
;
mHasImage
=
true
;
mDragPopup
=
nullptr
;
mImage
=
nullptr
;
mImageOffset
=
CSSIntPoint
(
)
;
aDragEvent
-
>
GetScreenX
(
&
mScreenPosition
.
x
)
;
aDragEvent
-
>
GetScreenY
(
&
mScreenPosition
.
y
)
;
aDragEvent
-
>
GetMozInputSource
(
&
mInputSource
)
;
nsCOMPtr
<
nsIDOMNode
>
node
;
aSelection
-
>
GetFocusNode
(
getter_AddRefs
(
node
)
)
;
nsresult
rv
=
InvokeDragSession
(
node
aTransferableArray
nullptr
aActionType
nsIContentPolicy
:
:
TYPE_OTHER
)
;
if
(
NS_FAILED
(
rv
)
)
{
mHasImage
=
false
;
mSelection
=
nullptr
;
mDataTransfer
=
nullptr
;
}
return
rv
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetCurrentSession
(
nsIDragSession
*
*
aSession
)
{
if
(
!
aSession
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mSuppressLevel
&
&
mDoingDrag
)
{
*
aSession
=
this
;
NS_ADDREF
(
*
aSession
)
;
}
else
*
aSession
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
StartDragSession
(
)
{
if
(
mDoingDrag
)
{
return
NS_ERROR_FAILURE
;
}
mDoingDrag
=
true
;
mOnlyChromeDrop
=
false
;
return
NS_OK
;
}
void
nsBaseDragService
:
:
OpenDragPopup
(
)
{
if
(
mDragPopup
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
ShowPopupAtScreen
(
mDragPopup
mScreenPosition
.
x
-
mImageOffset
.
x
mScreenPosition
.
y
-
mImageOffset
.
y
false
nullptr
)
;
}
}
}
int32_t
nsBaseDragService
:
:
TakeChildProcessDragAction
(
)
{
int32_t
retval
=
DRAGDROP_ACTION_UNINITIALIZED
;
if
(
TakeDragEventDispatchedToChildProcess
(
)
&
&
mDragActionFromChildProcess
!
=
DRAGDROP_ACTION_UNINITIALIZED
)
{
retval
=
mDragActionFromChildProcess
;
}
return
retval
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
if
(
!
mDoingDrag
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aDoneDrag
&
&
!
mSuppressLevel
)
{
FireDragEventAtSource
(
eDragEnd
aKeyModifiers
)
;
}
if
(
mDragPopup
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
HidePopup
(
mDragPopup
false
true
false
false
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mChildProcesses
.
Length
(
)
;
+
+
i
)
{
mozilla
:
:
Unused
<
<
mChildProcesses
[
i
]
-
>
SendEndDragSession
(
aDoneDrag
mUserCancelled
mEndDragPoint
aKeyModifiers
)
;
mChildProcesses
[
i
]
-
>
SetInputPriorityEventEnabled
(
true
)
;
}
mChildProcesses
.
Clear
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
DiscardInternalTransferData
(
)
;
}
mDoingDrag
=
false
;
mCanDrop
=
false
;
mSourceDocument
=
nullptr
;
mSourceNode
=
nullptr
;
mSelection
=
nullptr
;
mDataTransfer
=
nullptr
;
mHasImage
=
false
;
mUserCancelled
=
false
;
mDragPopup
=
nullptr
;
mImage
=
nullptr
;
mImageOffset
=
CSSIntPoint
(
)
;
mScreenPosition
=
CSSIntPoint
(
)
;
mEndDragPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
mInputSource
=
nsIDOMMouseEvent
:
:
MOZ_SOURCE_MOUSE
;
return
NS_OK
;
}
void
nsBaseDragService
:
:
DiscardInternalTransferData
(
)
{
if
(
mDataTransfer
&
&
mSourceNode
)
{
MOZ_ASSERT
(
!
!
DataTransfer
:
:
Cast
(
mDataTransfer
)
)
;
DataTransferItemList
*
items
=
DataTransfer
:
:
Cast
(
mDataTransfer
)
-
>
Items
(
)
;
for
(
size_t
i
=
0
;
i
<
items
-
>
Length
(
)
;
i
+
+
)
{
bool
found
;
DataTransferItem
*
item
=
items
-
>
IndexedGetter
(
i
found
)
;
if
(
!
found
|
|
item
-
>
Kind
(
)
!
=
DataTransferItem
:
:
KIND_OTHER
)
{
continue
;
}
nsCOMPtr
<
nsIVariant
>
variant
=
item
-
>
DataNoSecurityCheck
(
)
;
nsCOMPtr
<
nsIWritableVariant
>
writable
=
do_QueryInterface
(
variant
)
;
if
(
writable
)
{
writable
-
>
SetAsEmpty
(
)
;
}
}
}
}
NS_IMETHODIMP
nsBaseDragService
:
:
FireDragEventAtSource
(
EventMessage
aEventMessage
uint32_t
aKeyModifiers
)
{
if
(
mSourceNode
&
&
!
mSuppressLevel
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
mSourceDocument
)
;
if
(
doc
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
doc
-
>
GetShell
(
)
;
if
(
presShell
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetDragEvent
event
(
true
aEventMessage
nullptr
)
;
event
.
inputSource
=
mInputSource
;
if
(
aEventMessage
=
=
eDragEnd
)
{
event
.
mRefPoint
=
mEndDragPoint
;
event
.
mUserCancelled
=
mUserCancelled
;
}
event
.
mModifiers
=
aKeyModifiers
;
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
presContext
-
>
GetRootWidget
(
)
)
{
widget
-
>
DispatchEventToAPZOnly
(
&
event
)
;
}
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mSourceNode
)
;
return
presShell
-
>
HandleDOMEventWithTarget
(
content
&
event
&
status
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
DragMoved
(
int32_t
aX
int32_t
aY
)
{
if
(
mDragPopup
)
{
nsIFrame
*
frame
=
mDragPopup
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsMenuPopupFrame
(
)
)
{
CSSIntPoint
cssPos
=
RoundedToInt
(
LayoutDeviceIntPoint
(
aX
aY
)
/
frame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
)
-
mImageOffset
;
(
static_cast
<
nsMenuPopupFrame
*
>
(
frame
)
)
-
>
MoveTo
(
cssPos
true
)
;
}
}
return
NS_OK
;
}
static
nsIPresShell
*
GetPresShellForContent
(
nsIDOMNode
*
aDOMNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aDOMNode
)
;
if
(
!
content
)
return
nullptr
;
nsCOMPtr
<
nsIDocument
>
document
=
content
-
>
GetUncomposedDoc
(
)
;
if
(
document
)
{
document
-
>
FlushPendingNotifications
(
FlushType
:
:
Display
)
;
return
document
-
>
GetShell
(
)
;
}
return
nullptr
;
}
nsresult
nsBaseDragService
:
:
DrawDrag
(
nsIDOMNode
*
aDOMNode
nsIScriptableRegion
*
aRegion
CSSIntPoint
aScreenPosition
LayoutDeviceIntRect
*
aScreenDragRect
RefPtr
<
SourceSurface
>
*
aSurface
nsPresContext
*
*
aPresContext
)
{
*
aSurface
=
nullptr
;
*
aPresContext
=
nullptr
;
aScreenDragRect
-
>
MoveTo
(
aScreenPosition
.
x
-
mImageOffset
.
x
aScreenPosition
.
y
-
mImageOffset
.
y
)
;
aScreenDragRect
-
>
SizeTo
(
1
1
)
;
nsCOMPtr
<
nsIDOMNode
>
dragNode
=
mImage
?
mImage
.
get
(
)
:
aDOMNode
;
nsIPresShell
*
presShell
=
GetPresShellForContent
(
dragNode
)
;
if
(
!
presShell
&
&
mImage
)
presShell
=
GetPresShellForContent
(
aDOMNode
)
;
if
(
!
presShell
)
return
NS_ERROR_FAILURE
;
*
aPresContext
=
presShell
-
>
GetPresContext
(
)
;
nsCOMPtr
<
nsIFrameLoaderOwner
>
flo
=
do_QueryInterface
(
dragNode
)
;
if
(
flo
)
{
RefPtr
<
nsFrameLoader
>
fl
=
flo
-
>
GetFrameLoader
(
)
;
if
(
fl
)
{
auto
*
tp
=
static_cast
<
mozilla
:
:
dom
:
:
TabParent
*
>
(
fl
-
>
GetRemoteBrowser
(
)
)
;
if
(
tp
&
&
tp
-
>
TakeDragVisualization
(
*
aSurface
aScreenDragRect
)
)
{
if
(
mImage
)
{
*
aSurface
=
nullptr
;
}
return
NS_OK
;
}
}
}
CSSIntPoint
screenPosition
(
aScreenPosition
)
;
screenPosition
.
x
-
=
mImageOffset
.
x
;
screenPosition
.
y
-
=
mImageOffset
.
y
;
LayoutDeviceIntPoint
screenPoint
=
ConvertToUnscaledDevPixels
(
*
aPresContext
screenPosition
)
;
aScreenDragRect
-
>
x
=
screenPoint
.
x
;
aScreenDragRect
-
>
y
=
screenPoint
.
y
;
bool
enableDragImages
=
Preferences
:
:
GetBool
(
DRAGIMAGES_PREF
true
)
;
if
(
!
enableDragImages
|
|
!
mHasImage
)
{
CSSIntRect
dragRect
;
if
(
aRegion
)
{
aRegion
-
>
GetBoundingBox
(
&
dragRect
.
x
&
dragRect
.
y
&
dragRect
.
width
&
dragRect
.
height
)
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
CSSIntRect
screenRect
=
rootFrame
-
>
GetScreenRect
(
)
;
dragRect
.
MoveBy
(
screenRect
.
TopLeft
(
)
)
;
}
else
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
dragNode
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
dragRect
=
frame
-
>
GetScreenRect
(
)
;
}
}
nsIntRect
dragRectDev
=
ToAppUnits
(
dragRect
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
.
ToOutsidePixels
(
(
*
aPresContext
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aScreenDragRect
-
>
SizeTo
(
dragRectDev
.
width
dragRectDev
.
height
)
;
return
NS_OK
;
}
if
(
mSelection
)
{
LayoutDeviceIntPoint
pnt
(
aScreenDragRect
-
>
TopLeft
(
)
)
;
*
aSurface
=
presShell
-
>
RenderSelection
(
mSelection
pnt
aScreenDragRect
mImage
?
0
:
nsIPresShell
:
:
RENDER_AUTO_SCALE
)
;
return
NS_OK
;
}
if
(
mImage
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
dragNode
)
;
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromContentOrNull
(
content
)
;
if
(
canvas
)
{
return
DrawDragForImage
(
*
aPresContext
nullptr
canvas
aScreenDragRect
aSurface
)
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
dragNode
)
;
if
(
imageLoader
)
{
return
DrawDragForImage
(
*
aPresContext
imageLoader
nullptr
aScreenDragRect
aSurface
)
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsMenuPopupFrame
(
)
)
{
mDragPopup
=
content
;
}
}
if
(
!
mDragPopup
)
{
nsIntRegion
clipRegion
;
uint32_t
renderFlags
=
mImage
?
0
:
nsIPresShell
:
:
RENDER_AUTO_SCALE
;
if
(
aRegion
)
{
aRegion
-
>
GetRegion
(
&
clipRegion
)
;
}
if
(
renderFlags
)
{
nsCOMPtr
<
nsIDOMNode
>
child
;
nsCOMPtr
<
nsIDOMNodeList
>
childList
;
uint32_t
length
;
uint32_t
count
=
0
;
nsAutoString
childNodeName
;
if
(
NS_SUCCEEDED
(
dragNode
-
>
GetChildNodes
(
getter_AddRefs
(
childList
)
)
)
&
&
NS_SUCCEEDED
(
childList
-
>
GetLength
(
&
length
)
)
)
{
while
(
count
<
length
)
{
if
(
NS_FAILED
(
childList
-
>
Item
(
count
getter_AddRefs
(
child
)
)
)
|
|
NS_FAILED
(
child
-
>
GetNodeName
(
childNodeName
)
)
)
{
break
;
}
if
(
childNodeName
.
LowerCaseEqualsLiteral
(
"
img
"
)
)
{
renderFlags
=
renderFlags
|
nsIPresShell
:
:
RENDER_IS_IMAGE
;
break
;
}
count
+
+
;
}
}
}
LayoutDeviceIntPoint
pnt
(
aScreenDragRect
-
>
TopLeft
(
)
)
;
*
aSurface
=
presShell
-
>
RenderNode
(
dragNode
aRegion
?
&
clipRegion
:
nullptr
pnt
aScreenDragRect
renderFlags
)
;
}
if
(
mImage
)
{
aScreenDragRect
-
>
x
=
screenPoint
.
x
;
aScreenDragRect
-
>
y
=
screenPoint
.
y
;
}
return
NS_OK
;
}
nsresult
nsBaseDragService
:
:
DrawDragForImage
(
nsPresContext
*
aPresContext
nsIImageLoadingContent
*
aImageLoader
HTMLCanvasElement
*
aCanvas
LayoutDeviceIntRect
*
aScreenDragRect
RefPtr
<
SourceSurface
>
*
aSurface
)
{
nsCOMPtr
<
imgIContainer
>
imgContainer
;
if
(
aImageLoader
)
{
nsCOMPtr
<
imgIRequest
>
imgRequest
;
nsresult
rv
=
aImageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgRequest
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
imgRequest
)
return
NS_ERROR_NOT_AVAILABLE
;
rv
=
imgRequest
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
imgContainer
)
return
NS_ERROR_NOT_AVAILABLE
;
int32_t
imageWidth
imageHeight
;
rv
=
imgContainer
-
>
GetWidth
(
&
imageWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
imgContainer
-
>
GetHeight
(
&
imageHeight
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aScreenDragRect
-
>
width
=
aPresContext
-
>
CSSPixelsToDevPixels
(
imageWidth
)
;
aScreenDragRect
-
>
height
=
aPresContext
-
>
CSSPixelsToDevPixels
(
imageHeight
)
;
}
else
{
NS_ASSERTION
(
aCanvas
"
both
image
and
canvas
are
null
"
)
;
nsIntSize
sz
=
aCanvas
-
>
GetSize
(
)
;
aScreenDragRect
-
>
width
=
sz
.
width
;
aScreenDragRect
-
>
height
=
sz
.
height
;
}
nsIntSize
destSize
;
destSize
.
width
=
aScreenDragRect
-
>
width
;
destSize
.
height
=
aScreenDragRect
-
>
height
;
if
(
destSize
.
width
=
=
0
|
|
destSize
.
height
=
=
0
)
return
NS_ERROR_FAILURE
;
nsresult
result
=
NS_OK
;
if
(
aImageLoader
)
{
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
destSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
return
NS_ERROR_FAILURE
;
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
if
(
!
ctx
)
return
NS_ERROR_FAILURE
;
ImgDrawResult
res
=
imgContainer
-
>
Draw
(
ctx
destSize
ImageRegion
:
:
Create
(
destSize
)
imgIContainer
:
:
FRAME_CURRENT
SamplingFilter
:
:
GOOD
Nothing
(
)
imgIContainer
:
:
FLAG_SYNC_DECODE
1
.
0
)
;
if
(
res
=
=
ImgDrawResult
:
:
BAD_IMAGE
|
|
res
=
=
ImgDrawResult
:
:
BAD_ARGS
)
{
return
NS_ERROR_FAILURE
;
}
*
aSurface
=
dt
-
>
Snapshot
(
)
;
}
else
{
*
aSurface
=
aCanvas
-
>
GetSurfaceSnapshot
(
)
;
}
return
result
;
}
LayoutDeviceIntPoint
nsBaseDragService
:
:
ConvertToUnscaledDevPixels
(
nsPresContext
*
aPresContext
CSSIntPoint
aScreenPosition
)
{
int32_t
adj
=
aPresContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
return
LayoutDeviceIntPoint
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aScreenPosition
.
x
)
/
adj
nsPresContext
:
:
CSSPixelsToAppUnits
(
aScreenPosition
.
y
)
/
adj
)
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
Suppress
(
)
{
EndDragSession
(
false
0
)
;
+
+
mSuppressLevel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
Unsuppress
(
)
{
-
-
mSuppressLevel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
UserCancelled
(
)
{
mUserCancelled
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
UpdateDragEffect
(
)
{
mDragActionFromChildProcess
=
mDragAction
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
UpdateDragImage
(
nsIDOMNode
*
aImage
int32_t
aImageX
int32_t
aImageY
)
{
if
(
!
mSourceNode
|
|
mDragPopup
)
return
NS_OK
;
mImage
=
aImage
;
mImageOffset
=
CSSIntPoint
(
aImageX
aImageY
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
DragEventDispatchedToChildProcess
(
)
{
mDragEventDispatchedToChildProcess
=
true
;
return
NS_OK
;
}
bool
nsBaseDragService
:
:
MaybeAddChildProcess
(
mozilla
:
:
dom
:
:
ContentParent
*
aChild
)
{
if
(
!
mChildProcesses
.
Contains
(
aChild
)
)
{
mChildProcesses
.
AppendElement
(
aChild
)
;
return
true
;
}
return
false
;
}
