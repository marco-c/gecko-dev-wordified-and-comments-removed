#
include
"
nsBaseDragService
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
SVGImageContext
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsTreeBodyFrame
.
h
"
#
endif
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
DataTransferItemList
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
BrowserParent
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
#
define
DRAGIMAGES_PREF
"
nglayout
.
enable_drag_images
"
nsBaseDragService
:
:
nsBaseDragService
(
)
:
mCanDrop
(
false
)
mOnlyChromeDrop
(
false
)
mDoingDrag
(
false
)
mHasImage
(
false
)
mUserCancelled
(
false
)
mDragEventDispatchedToChildProcess
(
false
)
mDragAction
(
DRAGDROP_ACTION_NONE
)
mDragActionFromChildProcess
(
DRAGDROP_ACTION_UNINITIALIZED
)
mContentPolicyType
(
nsIContentPolicy
:
:
TYPE_OTHER
)
mSuppressLevel
(
0
)
mInputSource
(
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
)
{
}
nsBaseDragService
:
:
~
nsBaseDragService
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
nsBaseDragService
nsIDragService
nsIDragSession
)
NS_IMETHODIMP
nsBaseDragService
:
:
SetCanDrop
(
bool
aCanDrop
)
{
mCanDrop
=
aCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetCanDrop
(
bool
*
aCanDrop
)
{
*
aCanDrop
=
mCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetOnlyChromeDrop
(
bool
aOnlyChrome
)
{
mOnlyChromeDrop
=
aOnlyChrome
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetOnlyChromeDrop
(
bool
*
aOnlyChrome
)
{
*
aOnlyChrome
=
mOnlyChromeDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetDragAction
(
uint32_t
anAction
)
{
mDragAction
=
anAction
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetDragAction
(
uint32_t
*
anAction
)
{
*
anAction
=
mDragAction
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
*
aNumItems
=
0
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetSourceDocument
(
Document
*
*
aSourceDocument
)
{
*
aSourceDocument
=
mSourceDocument
.
get
(
)
;
NS_IF_ADDREF
(
*
aSourceDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetSourceNode
(
nsINode
*
*
aSourceNode
)
{
*
aSourceNode
=
do_AddRef
(
mSourceNode
)
.
take
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetTriggeringPrincipal
(
nsIPrincipal
*
*
aPrincipal
)
{
NS_IF_ADDREF
(
*
aPrincipal
=
mTriggeringPrincipal
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetTriggeringPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
mTriggeringPrincipal
=
aPrincipal
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetCsp
(
nsIContentSecurityPolicy
*
*
aCsp
)
{
NS_IF_ADDREF
(
*
aCsp
=
mCsp
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetCsp
(
nsIContentSecurityPolicy
*
aCsp
)
{
mCsp
=
aCsp
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetDataTransferXPCOM
(
DataTransfer
*
*
aDataTransfer
)
{
*
aDataTransfer
=
mDataTransfer
;
NS_IF_ADDREF
(
*
aDataTransfer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
SetDataTransferXPCOM
(
DataTransfer
*
aDataTransfer
)
{
NS_ENSURE_STATE
(
aDataTransfer
)
;
mDataTransfer
=
aDataTransfer
;
return
NS_OK
;
}
DataTransfer
*
nsBaseDragService
:
:
GetDataTransfer
(
)
{
return
mDataTransfer
;
}
void
nsBaseDragService
:
:
SetDataTransfer
(
DataTransfer
*
aDataTransfer
)
{
mDataTransfer
=
aDataTransfer
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSession
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsIArray
*
aTransferableArray
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_OTHER
)
{
AUTO_PROFILER_LABEL
(
"
nsBaseDragService
:
:
InvokeDragSession
"
OTHER
)
;
if
(
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT
(
!
xpc
:
:
IsInAutomation
(
)
"
About
to
start
drag
-
drop
native
loop
on
which
will
prevent
later
"
"
tests
from
running
properly
.
"
)
;
}
NS_ENSURE_TRUE
(
aDOMNode
NS_ERROR_INVALID_ARG
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
mSourceDocument
=
aDOMNode
-
>
OwnerDoc
(
)
;
mTriggeringPrincipal
=
aPrincipal
;
mCsp
=
aCsp
;
mSourceNode
=
aDOMNode
;
mContentPolicyType
=
aContentPolicyType
;
mEndDragPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
PresShell
:
:
ClearMouseCapture
(
nullptr
)
;
uint32_t
length
=
0
;
mozilla
:
:
Unused
<
<
aTransferableArray
-
>
GetLength
(
&
length
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
nsCOMPtr
<
nsITransferable
>
trans
=
do_QueryElementAt
(
aTransferableArray
i
)
;
if
(
trans
)
{
trans
-
>
SetRequestingPrincipal
(
mSourceNode
-
>
NodePrincipal
(
)
)
;
trans
-
>
SetContentPolicyType
(
mContentPolicyType
)
;
}
}
nsresult
rv
=
InvokeDragSessionImpl
(
aTransferableArray
mRegion
aActionType
)
;
if
(
NS_FAILED
(
rv
)
)
{
mDoingDrag
=
true
;
EndDragSession
(
true
0
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSessionWithImage
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsIArray
*
aTransferableArray
uint32_t
aActionType
nsINode
*
aImage
int32_t
aImageX
int32_t
aImageY
DragEvent
*
aDragEvent
DataTransfer
*
aDataTransfer
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aDataTransfer
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
mDataTransfer
=
aDataTransfer
;
mSelection
=
nullptr
;
mHasImage
=
true
;
mDragPopup
=
nullptr
;
mImage
=
aImage
;
mImageOffset
=
CSSIntPoint
(
aImageX
aImageY
)
;
mDragStartData
=
nullptr
;
mScreenPosition
.
x
=
aDragEvent
-
>
ScreenX
(
CallerType
:
:
System
)
;
mScreenPosition
.
y
=
aDragEvent
-
>
ScreenY
(
CallerType
:
:
System
)
;
mInputSource
=
aDragEvent
-
>
MozInputSource
(
)
;
mRegion
=
Nothing
(
)
;
#
ifdef
MOZ_XUL
if
(
aDOMNode
&
&
aDOMNode
-
>
IsContent
(
)
&
&
!
aImage
)
{
if
(
aDOMNode
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
treechildren
kNameSpaceID_XUL
)
)
{
nsTreeBodyFrame
*
treeBody
=
do_QueryFrame
(
aDOMNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
treeBody
)
{
mRegion
=
treeBody
-
>
GetSelectionRegion
(
)
;
}
}
}
#
endif
nsresult
rv
=
InvokeDragSession
(
aDOMNode
aPrincipal
aCsp
aTransferableArray
aActionType
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
)
;
mRegion
=
Nothing
(
)
;
return
rv
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSessionWithRemoteImage
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsIArray
*
aTransferableArray
uint32_t
aActionType
RemoteDragStartData
*
aDragStartData
DragEvent
*
aDragEvent
DataTransfer
*
aDataTransfer
)
{
NS_ENSURE_TRUE
(
aDragEvent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aDataTransfer
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
mDataTransfer
=
aDataTransfer
;
mSelection
=
nullptr
;
mHasImage
=
true
;
mDragPopup
=
nullptr
;
mImage
=
nullptr
;
mDragStartData
=
aDragStartData
;
mImageOffset
=
CSSIntPoint
(
0
0
)
;
mScreenPosition
.
x
=
aDragEvent
-
>
ScreenX
(
CallerType
:
:
System
)
;
mScreenPosition
.
y
=
aDragEvent
-
>
ScreenY
(
CallerType
:
:
System
)
;
mInputSource
=
aDragEvent
-
>
MozInputSource
(
)
;
nsresult
rv
=
InvokeDragSession
(
aDOMNode
aPrincipal
aCsp
aTransferableArray
aActionType
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
)
;
mRegion
=
Nothing
(
)
;
return
rv
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
InvokeDragSessionWithSelection
(
Selection
*
aSelection
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsIArray
*
aTransferableArray
uint32_t
aActionType
DragEvent
*
aDragEvent
DataTransfer
*
aDataTransfer
)
{
NS_ENSURE_TRUE
(
aSelection
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aDragEvent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
mSuppressLevel
=
=
0
NS_ERROR_FAILURE
)
;
mDataTransfer
=
aDataTransfer
;
mSelection
=
aSelection
;
mHasImage
=
true
;
mDragPopup
=
nullptr
;
mImage
=
nullptr
;
mImageOffset
=
CSSIntPoint
(
)
;
mDragStartData
=
nullptr
;
mRegion
=
Nothing
(
)
;
mScreenPosition
.
x
=
aDragEvent
-
>
ScreenX
(
CallerType
:
:
System
)
;
mScreenPosition
.
y
=
aDragEvent
-
>
ScreenY
(
CallerType
:
:
System
)
;
mInputSource
=
aDragEvent
-
>
MozInputSource
(
)
;
nsCOMPtr
<
nsINode
>
node
=
aSelection
-
>
GetFocusNode
(
)
;
return
InvokeDragSession
(
node
aPrincipal
aCsp
aTransferableArray
aActionType
nsIContentPolicy
:
:
TYPE_OTHER
)
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
GetCurrentSession
(
nsIDragSession
*
*
aSession
)
{
if
(
!
aSession
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mSuppressLevel
&
&
mDoingDrag
)
{
*
aSession
=
this
;
NS_ADDREF
(
*
aSession
)
;
}
else
*
aSession
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
StartDragSession
(
)
{
if
(
mDoingDrag
)
{
return
NS_ERROR_FAILURE
;
}
mDoingDrag
=
true
;
mOnlyChromeDrop
=
false
;
return
NS_OK
;
}
void
nsBaseDragService
:
:
OpenDragPopup
(
)
{
if
(
mDragPopup
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
ShowPopupAtScreen
(
mDragPopup
mScreenPosition
.
x
-
mImageOffset
.
x
mScreenPosition
.
y
-
mImageOffset
.
y
false
nullptr
)
;
}
}
}
int32_t
nsBaseDragService
:
:
TakeChildProcessDragAction
(
)
{
int32_t
retval
=
DRAGDROP_ACTION_UNINITIALIZED
;
if
(
TakeDragEventDispatchedToChildProcess
(
)
&
&
mDragActionFromChildProcess
!
=
DRAGDROP_ACTION_UNINITIALIZED
)
{
retval
=
mDragActionFromChildProcess
;
}
return
retval
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
if
(
!
mDoingDrag
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aDoneDrag
&
&
!
mSuppressLevel
)
{
FireDragEventAtSource
(
eDragEnd
aKeyModifiers
)
;
}
if
(
mDragPopup
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
HidePopup
(
mDragPopup
false
true
false
false
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mChildProcesses
.
Length
(
)
;
+
+
i
)
{
mozilla
:
:
Unused
<
<
mChildProcesses
[
i
]
-
>
SendEndDragSession
(
aDoneDrag
mUserCancelled
mEndDragPoint
aKeyModifiers
)
;
mChildProcesses
[
i
]
-
>
SetInputPriorityEventEnabled
(
true
)
;
}
mChildProcesses
.
Clear
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
DiscardInternalTransferData
(
)
;
}
mDoingDrag
=
false
;
mCanDrop
=
false
;
mSourceDocument
=
nullptr
;
mSourceNode
=
nullptr
;
mTriggeringPrincipal
=
nullptr
;
mCsp
=
nullptr
;
mSelection
=
nullptr
;
mDataTransfer
=
nullptr
;
mHasImage
=
false
;
mUserCancelled
=
false
;
mDragPopup
=
nullptr
;
mDragStartData
=
nullptr
;
mImage
=
nullptr
;
mImageOffset
=
CSSIntPoint
(
)
;
mScreenPosition
=
CSSIntPoint
(
)
;
mEndDragPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
;
mRegion
=
Nothing
(
)
;
return
NS_OK
;
}
void
nsBaseDragService
:
:
DiscardInternalTransferData
(
)
{
if
(
mDataTransfer
&
&
mSourceNode
)
{
MOZ_ASSERT
(
mDataTransfer
)
;
DataTransferItemList
*
items
=
mDataTransfer
-
>
Items
(
)
;
for
(
size_t
i
=
0
;
i
<
items
-
>
Length
(
)
;
i
+
+
)
{
bool
found
;
DataTransferItem
*
item
=
items
-
>
IndexedGetter
(
i
found
)
;
if
(
!
found
|
|
item
-
>
Kind
(
)
!
=
DataTransferItem
:
:
KIND_OTHER
)
{
continue
;
}
nsCOMPtr
<
nsIVariant
>
variant
=
item
-
>
DataNoSecurityCheck
(
)
;
nsCOMPtr
<
nsIWritableVariant
>
writable
=
do_QueryInterface
(
variant
)
;
if
(
writable
)
{
writable
-
>
SetAsEmpty
(
)
;
}
}
}
}
NS_IMETHODIMP
nsBaseDragService
:
:
FireDragEventAtSource
(
EventMessage
aEventMessage
uint32_t
aKeyModifiers
)
{
if
(
mSourceNode
&
&
mSourceDocument
&
&
!
mSuppressLevel
)
{
RefPtr
<
PresShell
>
presShell
=
mSourceDocument
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetDragEvent
event
(
true
aEventMessage
nullptr
)
;
event
.
mInputSource
=
mInputSource
;
if
(
aEventMessage
=
=
eDragEnd
)
{
event
.
mRefPoint
=
mEndDragPoint
;
event
.
mUserCancelled
=
mUserCancelled
;
}
event
.
mModifiers
=
aKeyModifiers
;
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
presContext
-
>
GetRootWidget
(
)
)
{
widget
-
>
DispatchEventToAPZOnly
(
&
event
)
;
}
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mSourceNode
)
;
return
presShell
-
>
HandleDOMEventWithTarget
(
content
&
event
&
status
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
DragMoved
(
int32_t
aX
int32_t
aY
)
{
if
(
mDragPopup
)
{
nsIFrame
*
frame
=
mDragPopup
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsMenuPopupFrame
(
)
)
{
CSSIntPoint
cssPos
=
RoundedToInt
(
LayoutDeviceIntPoint
(
aX
aY
)
/
frame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
)
-
mImageOffset
;
(
static_cast
<
nsMenuPopupFrame
*
>
(
frame
)
)
-
>
MoveTo
(
cssPos
true
)
;
}
}
return
NS_OK
;
}
static
PresShell
*
GetPresShellForContent
(
nsINode
*
aDOMNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aDOMNode
)
;
if
(
!
content
)
return
nullptr
;
RefPtr
<
Document
>
document
=
content
-
>
GetComposedDoc
(
)
;
if
(
document
)
{
document
-
>
FlushPendingNotifications
(
FlushType
:
:
Display
)
;
return
document
-
>
GetPresShell
(
)
;
}
return
nullptr
;
}
nsresult
nsBaseDragService
:
:
DrawDrag
(
nsINode
*
aDOMNode
const
Maybe
<
CSSIntRegion
>
&
aRegion
CSSIntPoint
aScreenPosition
LayoutDeviceIntRect
*
aScreenDragRect
RefPtr
<
SourceSurface
>
*
aSurface
nsPresContext
*
*
aPresContext
)
{
*
aSurface
=
nullptr
;
*
aPresContext
=
nullptr
;
aScreenDragRect
-
>
SetRect
(
aScreenPosition
.
x
-
mImageOffset
.
x
aScreenPosition
.
y
-
mImageOffset
.
y
1
1
)
;
nsCOMPtr
<
nsINode
>
dragNode
=
mImage
?
mImage
.
get
(
)
:
aDOMNode
;
PresShell
*
presShell
=
GetPresShellForContent
(
dragNode
)
;
if
(
!
presShell
&
&
mImage
)
{
presShell
=
GetPresShellForContent
(
aDOMNode
)
;
}
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
*
aPresContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
mDragStartData
)
{
if
(
mImage
)
{
*
aSurface
=
nullptr
;
}
else
{
*
aSurface
=
mDragStartData
-
>
TakeVisualization
(
aScreenDragRect
)
;
}
mDragStartData
=
nullptr
;
return
NS_OK
;
}
CSSIntPoint
screenPosition
(
aScreenPosition
)
;
screenPosition
.
x
-
=
mImageOffset
.
x
;
screenPosition
.
y
-
=
mImageOffset
.
y
;
LayoutDeviceIntPoint
screenPoint
=
ConvertToUnscaledDevPixels
(
*
aPresContext
screenPosition
)
;
aScreenDragRect
-
>
MoveTo
(
screenPoint
.
x
screenPoint
.
y
)
;
bool
enableDragImages
=
Preferences
:
:
GetBool
(
DRAGIMAGES_PREF
true
)
;
if
(
!
enableDragImages
|
|
!
mHasImage
)
{
CSSIntRect
dragRect
;
if
(
aRegion
)
{
dragRect
=
aRegion
-
>
GetBounds
(
)
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
CSSIntRect
screenRect
=
rootFrame
-
>
GetScreenRect
(
)
;
dragRect
.
MoveBy
(
screenRect
.
TopLeft
(
)
)
;
}
else
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
dragNode
)
;
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
dragRect
=
frame
-
>
GetScreenRect
(
)
;
}
}
nsIntRect
dragRectDev
=
ToAppUnits
(
dragRect
AppUnitsPerCSSPixel
(
)
)
.
ToOutsidePixels
(
(
*
aPresContext
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aScreenDragRect
-
>
SizeTo
(
dragRectDev
.
Width
(
)
dragRectDev
.
Height
(
)
)
;
return
NS_OK
;
}
if
(
mSelection
)
{
LayoutDeviceIntPoint
pnt
(
aScreenDragRect
-
>
TopLeft
(
)
)
;
*
aSurface
=
presShell
-
>
RenderSelection
(
mSelection
pnt
aScreenDragRect
mImage
?
RenderImageFlags
:
:
None
:
RenderImageFlags
:
:
AutoScale
)
;
return
NS_OK
;
}
if
(
mImage
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
dragNode
)
;
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNodeOrNull
(
content
)
;
if
(
canvas
)
{
return
DrawDragForImage
(
*
aPresContext
nullptr
canvas
aScreenDragRect
aSurface
)
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
dragNode
)
;
if
(
imageLoader
)
{
return
DrawDragForImage
(
*
aPresContext
imageLoader
nullptr
aScreenDragRect
aSurface
)
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsMenuPopupFrame
(
)
)
{
mDragPopup
=
content
;
}
}
if
(
!
mDragPopup
)
{
RenderImageFlags
renderFlags
=
mImage
?
RenderImageFlags
:
:
None
:
RenderImageFlags
:
:
AutoScale
;
if
(
renderFlags
!
=
RenderImageFlags
:
:
None
)
{
if
(
dragNode
-
>
NodeName
(
)
.
LowerCaseEqualsLiteral
(
"
img
"
)
)
{
renderFlags
=
renderFlags
|
RenderImageFlags
:
:
IsImage
;
}
else
{
nsINodeList
*
childList
=
dragNode
-
>
ChildNodes
(
)
;
uint32_t
length
=
childList
-
>
Length
(
)
;
for
(
uint32_t
count
=
0
;
count
<
length
;
+
+
count
)
{
if
(
childList
-
>
Item
(
count
)
-
>
NodeName
(
)
.
LowerCaseEqualsLiteral
(
"
img
"
)
)
{
renderFlags
=
renderFlags
|
RenderImageFlags
:
:
IsImage
;
break
;
}
}
}
}
LayoutDeviceIntPoint
pnt
(
aScreenDragRect
-
>
TopLeft
(
)
)
;
*
aSurface
=
presShell
-
>
RenderNode
(
dragNode
aRegion
pnt
aScreenDragRect
renderFlags
)
;
}
if
(
mImage
)
{
aScreenDragRect
-
>
MoveTo
(
screenPoint
.
x
screenPoint
.
y
)
;
}
return
NS_OK
;
}
nsresult
nsBaseDragService
:
:
DrawDragForImage
(
nsPresContext
*
aPresContext
nsIImageLoadingContent
*
aImageLoader
HTMLCanvasElement
*
aCanvas
LayoutDeviceIntRect
*
aScreenDragRect
RefPtr
<
SourceSurface
>
*
aSurface
)
{
nsCOMPtr
<
imgIContainer
>
imgContainer
;
if
(
aImageLoader
)
{
nsCOMPtr
<
imgIRequest
>
imgRequest
;
nsresult
rv
=
aImageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgRequest
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
imgRequest
)
return
NS_ERROR_NOT_AVAILABLE
;
rv
=
imgRequest
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
imgContainer
)
return
NS_ERROR_NOT_AVAILABLE
;
int32_t
imageWidth
imageHeight
;
rv
=
imgContainer
-
>
GetWidth
(
&
imageWidth
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
imgContainer
-
>
GetHeight
(
&
imageHeight
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aScreenDragRect
-
>
SizeTo
(
aPresContext
-
>
CSSPixelsToDevPixels
(
imageWidth
)
aPresContext
-
>
CSSPixelsToDevPixels
(
imageHeight
)
)
;
}
else
{
NS_ASSERTION
(
aCanvas
"
both
image
and
canvas
are
null
"
)
;
nsIntSize
sz
=
aCanvas
-
>
GetSize
(
)
;
aScreenDragRect
-
>
SizeTo
(
sz
.
width
sz
.
height
)
;
}
nsIntSize
destSize
;
destSize
.
width
=
aScreenDragRect
-
>
Width
(
)
;
destSize
.
height
=
aScreenDragRect
-
>
Height
(
)
;
if
(
destSize
.
width
=
=
0
|
|
destSize
.
height
=
=
0
)
return
NS_ERROR_FAILURE
;
nsresult
result
=
NS_OK
;
if
(
aImageLoader
)
{
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
destSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
return
NS_ERROR_FAILURE
;
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
if
(
!
ctx
)
return
NS_ERROR_FAILURE
;
ImgDrawResult
res
=
imgContainer
-
>
Draw
(
ctx
destSize
ImageRegion
:
:
Create
(
destSize
)
imgIContainer
:
:
FRAME_CURRENT
SamplingFilter
:
:
GOOD
Nothing
(
)
imgIContainer
:
:
FLAG_SYNC_DECODE
1
.
0
)
;
if
(
res
=
=
ImgDrawResult
:
:
BAD_IMAGE
|
|
res
=
=
ImgDrawResult
:
:
BAD_ARGS
|
|
res
=
=
ImgDrawResult
:
:
NOT_SUPPORTED
)
{
return
NS_ERROR_FAILURE
;
}
*
aSurface
=
dt
-
>
Snapshot
(
)
;
}
else
{
*
aSurface
=
aCanvas
-
>
GetSurfaceSnapshot
(
)
;
}
return
result
;
}
LayoutDeviceIntPoint
nsBaseDragService
:
:
ConvertToUnscaledDevPixels
(
nsPresContext
*
aPresContext
CSSIntPoint
aScreenPosition
)
{
int32_t
adj
=
aPresContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
return
LayoutDeviceIntPoint
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aScreenPosition
.
x
)
/
adj
nsPresContext
:
:
CSSPixelsToAppUnits
(
aScreenPosition
.
y
)
/
adj
)
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
Suppress
(
)
{
EndDragSession
(
false
0
)
;
+
+
mSuppressLevel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
Unsuppress
(
)
{
-
-
mSuppressLevel
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
UserCancelled
(
)
{
mUserCancelled
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
UpdateDragEffect
(
)
{
mDragActionFromChildProcess
=
mDragAction
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
UpdateDragImage
(
nsINode
*
aImage
int32_t
aImageX
int32_t
aImageY
)
{
if
(
!
mSourceNode
|
|
mDragPopup
)
return
NS_OK
;
mImage
=
aImage
;
mImageOffset
=
CSSIntPoint
(
aImageX
aImageY
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseDragService
:
:
DragEventDispatchedToChildProcess
(
)
{
mDragEventDispatchedToChildProcess
=
true
;
return
NS_OK
;
}
bool
nsBaseDragService
:
:
MaybeAddChildProcess
(
mozilla
:
:
dom
:
:
ContentParent
*
aChild
)
{
if
(
!
mChildProcesses
.
Contains
(
aChild
)
)
{
mChildProcesses
.
AppendElement
(
aChild
)
;
return
true
;
}
return
false
;
}
