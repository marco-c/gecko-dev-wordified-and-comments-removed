#
ifndef
nsNativeThemeWin_h
#
define
nsNativeThemeWin_h
#
include
"
nsITheme
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsNativeTheme
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
#
include
"
nsUXThemeData
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
<
windows
.
h
>
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsSize
.
h
"
class
nsNativeThemeWin
:
private
nsNativeTheme
public
nsITheme
{
virtual
~
nsNativeThemeWin
(
)
;
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
TimeDuration
TimeDuration
;
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
)
override
;
MOZ_MUST_USE
LayoutDeviceIntMargin
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
override
;
bool
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
LayoutDeviceIntMargin
*
aResult
)
override
;
virtual
bool
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
nsRect
*
aOverflowRect
)
override
;
NS_IMETHOD
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
mozilla
:
:
LayoutDeviceIntSize
*
aResult
bool
*
aIsOverridable
)
override
;
virtual
Transparency
GetWidgetTransparency
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
override
;
NS_IMETHOD
WidgetStateChanged
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
nsAtom
*
aAttribute
bool
*
aShouldRepaint
const
nsAttrValue
*
aOldValue
)
override
;
NS_IMETHOD
ThemeChanged
(
)
override
;
bool
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
override
;
bool
WidgetIsContainer
(
WidgetType
aWidgetType
)
override
;
bool
ThemeDrawsFocusForWidget
(
WidgetType
aWidgetType
)
override
;
bool
ThemeNeedsComboboxDropmarker
(
)
override
;
virtual
bool
WidgetAppearanceDependsOnWindowFocus
(
WidgetType
aWidgetType
)
override
;
enum
{
eThemeGeometryTypeWindowButtons
=
eThemeGeometryTypeUnknown
+
1
}
;
virtual
ThemeGeometryType
ThemeGeometryTypeForWidget
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
override
;
nsNativeThemeWin
(
)
;
protected
:
mozilla
:
:
Maybe
<
nsUXThemeClass
>
GetThemeClass
(
WidgetType
aWidgetType
)
;
HANDLE
GetTheme
(
WidgetType
aWidgetType
)
;
nsresult
GetThemePartAndState
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
int32_t
&
aPart
int32_t
&
aState
)
;
nsresult
ClassicGetThemePartAndState
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
int32_t
&
aPart
int32_t
&
aState
bool
&
aFocused
)
;
nsresult
ClassicDrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
const
nsRect
&
aRect
const
nsRect
&
aClipRect
)
;
MOZ_MUST_USE
LayoutDeviceIntMargin
ClassicGetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
;
bool
ClassicGetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
LayoutDeviceIntMargin
*
aResult
)
;
nsresult
ClassicGetMinimumWidgetSize
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
mozilla
:
:
LayoutDeviceIntSize
*
aResult
bool
*
aIsOverridable
)
;
bool
ClassicThemeSupportsWidget
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
;
void
DrawCheckedRect
(
HDC
hdc
const
RECT
&
rc
int32_t
fore
int32_t
back
HBRUSH
defaultBack
)
;
nsresult
DrawCustomScrollbarPart
(
gfxContext
*
aContext
nsIFrame
*
aFrame
mozilla
:
:
ComputedStyle
*
aStyle
WidgetType
aWidgetType
const
nsRect
&
aRect
const
nsRect
&
aClipRect
)
;
uint32_t
GetWidgetNativeDrawingFlags
(
WidgetType
aWidgetType
)
;
int32_t
StandardGetState
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
bool
wantFocused
)
;
bool
IsMenuActive
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
;
RECT
CalculateProgressOverlayRect
(
nsIFrame
*
aFrame
RECT
*
aWidgetRect
bool
aIsVertical
bool
aIsIndeterminate
bool
aIsClassic
)
;
void
DrawThemedProgressMeter
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
HANDLE
aTheme
HDC
aHdc
int
aPart
int
aState
RECT
*
aWidgetRect
RECT
*
aClipRect
)
;
MOZ_MUST_USE
LayoutDeviceIntMargin
GetCachedWidgetBorder
(
HANDLE
aTheme
nsUXThemeClass
aThemeClass
WidgetType
aWidgetType
int32_t
aPart
int32_t
aState
)
;
nsresult
GetCachedMinimumWidgetSize
(
nsIFrame
*
aFrame
HANDLE
aTheme
nsUXThemeClass
aThemeClass
WidgetType
aWidgetType
int32_t
aPart
int32_t
aState
THEMESIZE
aSizeReq
mozilla
:
:
LayoutDeviceIntSize
*
aResult
)
;
SIZE
GetCachedGutterSize
(
HANDLE
theme
)
;
private
:
TimeStamp
mProgressDeterminateTimeStamp
;
TimeStamp
mProgressIndeterminateTimeStamp
;
uint8_t
mBorderCacheValid
[
(
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
+
7
)
/
8
]
;
LayoutDeviceIntMargin
mBorderCache
[
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
]
;
uint8_t
mMinimumWidgetSizeCacheValid
[
(
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
+
7
)
/
8
]
;
mozilla
:
:
LayoutDeviceIntSize
mMinimumWidgetSizeCache
[
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
]
;
bool
mGutterSizeCacheValid
;
SIZE
mGutterSizeCache
;
}
;
#
endif
