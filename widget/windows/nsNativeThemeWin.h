#
ifndef
nsNativeThemeWin_h
#
define
nsNativeThemeWin_h
#
include
<
windows
.
h
>
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
Theme
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
#
include
"
nsUXThemeData
.
h
"
namespace
mozilla
:
:
widget
{
class
nsNativeThemeWin
:
public
Theme
{
protected
:
virtual
~
nsNativeThemeWin
(
)
;
public
:
enum
class
NonNative
{
No
Always
BecauseColorMismatch
}
;
static
bool
IsWidgetAlwaysNonNative
(
nsIFrame
*
StyleAppearance
)
;
NonNative
IsWidgetNonNative
(
nsIFrame
*
StyleAppearance
)
;
NS_IMETHOD
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
DrawOverflow
)
override
;
bool
CreateWebRenderCommandsForWidget
(
wr
:
:
DisplayListBuilder
&
wr
:
:
IpcResourceUpdateQueue
&
const
layers
:
:
StackingContextHelper
&
layers
:
:
RenderRootStateManager
*
nsIFrame
*
StyleAppearance
const
nsRect
&
)
override
;
[
[
nodiscard
]
]
LayoutDeviceIntMargin
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
bool
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
override
;
virtual
bool
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
override
;
LayoutDeviceIntSize
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
virtual
Transparency
GetWidgetTransparency
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
bool
WidgetAttributeChangeRequiresRepaint
(
StyleAppearance
aAppearance
nsAtom
*
aAttribute
)
override
;
NS_IMETHOD
ThemeChanged
(
)
override
;
bool
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
bool
ThemeDrawsFocusForWidget
(
nsIFrame
*
StyleAppearance
)
override
;
bool
ThemeWantsButtonInnerFocusRing
(
)
override
{
return
true
;
}
bool
ThemeNeedsComboboxDropmarker
(
)
override
;
nsNativeThemeWin
(
)
;
protected
:
Maybe
<
nsUXThemeClass
>
GetThemeClass
(
StyleAppearance
aAppearance
)
;
HANDLE
GetTheme
(
StyleAppearance
aAppearance
)
;
nsresult
GetThemePartAndState
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
int32_t
&
aPart
int32_t
&
aState
)
;
nsresult
ClassicGetThemePartAndState
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
int32_t
&
aPart
int32_t
&
aState
bool
&
aFocused
)
;
nsresult
ClassicDrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aClipRect
)
;
[
[
nodiscard
]
]
LayoutDeviceIntMargin
ClassicGetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
;
bool
ClassicGetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
;
LayoutDeviceIntSize
ClassicGetMinimumWidgetSize
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
;
bool
ClassicThemeSupportsWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
;
void
DrawCheckedRect
(
HDC
hdc
const
RECT
&
rc
int32_t
fore
int32_t
back
HBRUSH
defaultBack
)
;
uint32_t
GetWidgetNativeDrawingFlags
(
StyleAppearance
aAppearance
)
;
int32_t
StandardGetState
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
bool
wantFocused
)
;
bool
IsMenuActive
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
;
RECT
CalculateProgressOverlayRect
(
nsIFrame
*
aFrame
RECT
*
aWidgetRect
bool
aIsVertical
bool
aIsIndeterminate
bool
aIsClassic
)
;
void
DrawThemedProgressMeter
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
HANDLE
aTheme
HDC
aHdc
int
aPart
int
aState
RECT
*
aWidgetRect
RECT
*
aClipRect
)
;
[
[
nodiscard
]
]
LayoutDeviceIntMargin
GetCachedWidgetBorder
(
HANDLE
aTheme
nsUXThemeClass
aThemeClass
StyleAppearance
aAppearance
int32_t
aPart
int32_t
aState
)
;
nsresult
GetCachedMinimumWidgetSize
(
nsIFrame
*
aFrame
HANDLE
aTheme
nsUXThemeClass
aThemeClass
StyleAppearance
aAppearance
int32_t
aPart
int32_t
aState
THEMESIZE
aSizeReq
LayoutDeviceIntSize
*
aResult
)
;
SIZE
GetCachedGutterSize
(
HANDLE
theme
)
;
private
:
TimeStamp
mProgressDeterminateTimeStamp
;
TimeStamp
mProgressIndeterminateTimeStamp
;
uint8_t
mBorderCacheValid
[
(
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
+
7
)
/
8
]
;
LayoutDeviceIntMargin
mBorderCache
[
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
]
;
uint8_t
mMinimumWidgetSizeCacheValid
[
(
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
+
7
)
/
8
]
;
LayoutDeviceIntSize
mMinimumWidgetSizeCache
[
eUXNumClasses
*
THEME_PART_DISTINCT_VALUE_COUNT
]
;
bool
mGutterSizeCacheValid
;
SIZE
mGutterSizeCache
;
}
;
}
#
endif
