#
include
"
nsScreenManagerWin
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsScreenWin
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
WinUtils
.
h
"
using
namespace
mozilla
;
BOOL
CALLBACK
CountMonitors
(
HMONITOR
HDC
LPRECT
LPARAM
ioCount
)
;
nsScreenManagerWin
:
:
nsScreenManagerWin
(
)
:
mNumberOfScreens
(
0
)
{
}
nsScreenManagerWin
:
:
~
nsScreenManagerWin
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsScreenManagerWin
nsIScreenManager
)
nsIScreen
*
nsScreenManagerWin
:
:
CreateNewScreenObject
(
HMONITOR
inScreen
)
{
nsIScreen
*
retScreen
=
nullptr
;
for
(
unsigned
i
=
0
;
i
<
mScreenList
.
Length
(
)
;
+
+
i
)
{
ScreenListItem
&
curr
=
mScreenList
[
i
]
;
if
(
inScreen
=
=
curr
.
mMon
)
{
NS_IF_ADDREF
(
retScreen
=
curr
.
mScreen
.
get
(
)
)
;
return
retScreen
;
}
}
retScreen
=
new
nsScreenWin
(
inScreen
)
;
mScreenList
.
AppendElement
(
ScreenListItem
(
inScreen
retScreen
)
)
;
NS_IF_ADDREF
(
retScreen
)
;
return
retScreen
;
}
NS_IMETHODIMP
nsScreenManagerWin
:
:
ScreenForId
(
uint32_t
aId
nsIScreen
*
*
outScreen
)
{
*
outScreen
=
nullptr
;
for
(
unsigned
i
=
0
;
i
<
mScreenList
.
Length
(
)
;
+
+
i
)
{
ScreenListItem
&
curr
=
mScreenList
[
i
]
;
uint32_t
id
;
nsresult
rv
=
curr
.
mScreen
-
>
GetId
(
&
id
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
id
=
=
aId
)
{
NS_IF_ADDREF
(
*
outScreen
=
curr
.
mScreen
.
get
(
)
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsScreenManagerWin
:
:
ScreenForRect
(
int32_t
inLeft
int32_t
inTop
int32_t
inWidth
int32_t
inHeight
nsIScreen
*
*
outScreen
)
{
if
(
!
(
inWidth
|
|
inHeight
)
)
{
NS_WARNING
(
"
trying
to
find
screen
for
sizeless
window
using
primary
monitor
"
)
;
*
outScreen
=
CreateNewScreenObject
(
nullptr
)
;
return
NS_OK
;
}
gfx
:
:
Rect
logicalBounds
(
inLeft
inTop
inWidth
inHeight
)
;
HMONITOR
genScreen
=
widget
:
:
WinUtils
:
:
MonitorFromRect
(
logicalBounds
)
;
*
outScreen
=
CreateNewScreenObject
(
genScreen
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsScreenManagerWin
:
:
GetPrimaryScreen
(
nsIScreen
*
*
aPrimaryScreen
)
{
*
aPrimaryScreen
=
CreateNewScreenObject
(
nullptr
)
;
return
NS_OK
;
}
BOOL
CALLBACK
CountMonitors
(
HMONITOR
HDC
LPRECT
LPARAM
ioParam
)
{
uint32_t
*
countPtr
=
reinterpret_cast
<
uint32_t
*
>
(
ioParam
)
;
+
+
(
*
countPtr
)
;
return
TRUE
;
}
NS_IMETHODIMP
nsScreenManagerWin
:
:
GetNumberOfScreens
(
uint32_t
*
aNumberOfScreens
)
{
if
(
mNumberOfScreens
)
*
aNumberOfScreens
=
mNumberOfScreens
;
else
{
uint32_t
count
=
0
;
BOOL
result
=
:
:
EnumDisplayMonitors
(
nullptr
nullptr
(
MONITORENUMPROC
)
CountMonitors
(
LPARAM
)
&
count
)
;
if
(
!
result
)
return
NS_ERROR_FAILURE
;
*
aNumberOfScreens
=
mNumberOfScreens
=
count
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsScreenManagerWin
:
:
GetSystemDefaultScale
(
float
*
aDefaultScale
)
{
HMONITOR
primary
=
widget
:
:
WinUtils
:
:
GetPrimaryMonitor
(
)
;
*
aDefaultScale
=
float
(
widget
:
:
WinUtils
:
:
LogToPhysFactor
(
primary
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsScreenManagerWin
:
:
ScreenForNativeWidget
(
void
*
aWidget
nsIScreen
*
*
outScreen
)
{
HMONITOR
mon
=
MonitorFromWindow
(
(
HWND
)
aWidget
MONITOR_DEFAULTTOPRIMARY
)
;
*
outScreen
=
CreateNewScreenObject
(
mon
)
;
return
NS_OK
;
}
