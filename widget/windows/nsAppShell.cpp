#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
ipc
/
WindowsMessageLoop
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
WinTaskbar
.
h
"
#
include
"
WinMouseScrollHandler
.
h
"
#
include
"
nsWindowDefs
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsString
.
h
"
#
include
"
WinIMEHandler
.
h
"
#
include
"
mozilla
/
widget
/
AudioSession
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
nsIDOMWakeLockListener
.
h
"
#
include
"
nsIPowerManagerService
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
ScreenHelperWin
.
h
"
#
include
"
HeadlessScreenHelper
.
h
"
#
include
"
mozilla
/
widget
/
ScreenManager
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
NativeNt
.
h
"
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
#
include
<
winternl
.
h
>
#
ifdef
MOZ_BACKGROUNDTASKS
#
include
"
mozilla
/
BackgroundTasks
.
h
"
#
endif
#
if
defined
(
ACCESSIBILITY
)
#
include
"
mozilla
/
a11y
/
Compatibility
.
h
"
#
include
"
mozilla
/
a11y
/
Platform
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
#
define
WAKE_LOCK_LOG
(
.
.
.
)
\
MOZ_LOG
(
gWinWakeLockLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
static
mozilla
:
:
LazyLogModule
gWinWakeLockLog
(
"
WinWakeLock
"
)
;
class
WinWakeLockListener
final
:
public
nsIDOMMozWakeLockListener
{
public
:
NS_DECL_ISUPPORTS
WinWakeLockListener
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
private
:
~
WinWakeLockListener
(
)
{
ReleaseWakelockIfNeeded
(
PowerRequestDisplayRequired
)
;
ReleaseWakelockIfNeeded
(
PowerRequestExecutionRequired
)
;
}
void
SetHandle
(
HANDLE
aHandle
POWER_REQUEST_TYPE
aType
)
{
switch
(
aType
)
{
case
PowerRequestDisplayRequired
:
{
if
(
!
aHandle
&
&
mDisplayHandle
)
{
CloseHandle
(
mDisplayHandle
)
;
}
mDisplayHandle
=
aHandle
;
return
;
}
case
PowerRequestExecutionRequired
:
{
if
(
!
aHandle
&
&
mNonDisplayHandle
)
{
CloseHandle
(
mNonDisplayHandle
)
;
}
mNonDisplayHandle
=
aHandle
;
return
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
request
type
"
)
;
return
;
}
}
HANDLE
GetHandle
(
POWER_REQUEST_TYPE
aType
)
const
{
switch
(
aType
)
{
case
PowerRequestDisplayRequired
:
return
mDisplayHandle
;
case
PowerRequestExecutionRequired
:
return
mNonDisplayHandle
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
request
type
"
)
;
return
nullptr
;
}
}
HANDLE
CreateHandle
(
POWER_REQUEST_TYPE
aType
)
{
MOZ_ASSERT
(
!
GetHandle
(
aType
)
)
;
REASON_CONTEXT
context
=
{
0
}
;
context
.
Version
=
POWER_REQUEST_CONTEXT_VERSION
;
context
.
Flags
=
POWER_REQUEST_CONTEXT_SIMPLE_STRING
;
context
.
Reason
.
SimpleReasonString
=
RequestTypeLPWSTR
(
aType
)
;
HANDLE
handle
=
PowerCreateRequest
(
&
context
)
;
if
(
!
handle
)
{
WAKE_LOCK_LOG
(
"
Failed
to
create
handle
for
%
s
error
=
%
lu
"
RequestTypeStr
(
aType
)
GetLastError
(
)
)
;
return
nullptr
;
}
SetHandle
(
handle
aType
)
;
return
handle
;
}
LPWSTR
RequestTypeLPWSTR
(
POWER_REQUEST_TYPE
aType
)
const
{
switch
(
aType
)
{
case
PowerRequestDisplayRequired
:
return
const_cast
<
LPWSTR
>
(
L
"
display
request
"
)
;
case
PowerRequestExecutionRequired
:
return
const_cast
<
LPWSTR
>
(
L
"
non
-
display
request
"
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
request
type
"
)
;
return
const_cast
<
LPWSTR
>
(
L
"
unknown
"
)
;
}
}
const
char
*
RequestTypeStr
(
POWER_REQUEST_TYPE
aType
)
const
{
switch
(
aType
)
{
case
PowerRequestDisplayRequired
:
return
"
display
request
"
;
case
PowerRequestExecutionRequired
:
return
"
non
-
display
request
"
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
request
type
"
)
;
return
"
unknown
"
;
}
}
void
RequestWakelockIfNeeded
(
POWER_REQUEST_TYPE
aType
)
{
if
(
GetHandle
(
aType
)
)
{
WAKE_LOCK_LOG
(
"
Already
requested
lock
for
%
s
"
RequestTypeStr
(
aType
)
)
;
return
;
}
WAKE_LOCK_LOG
(
"
Prepare
a
wakelock
for
%
s
"
RequestTypeStr
(
aType
)
)
;
HANDLE
handle
=
CreateHandle
(
aType
)
;
if
(
!
handle
)
{
WAKE_LOCK_LOG
(
"
Failed
due
to
no
handle
for
%
s
"
RequestTypeStr
(
aType
)
)
;
return
;
}
if
(
PowerSetRequest
(
handle
aType
)
)
{
WAKE_LOCK_LOG
(
"
Requested
%
s
lock
"
RequestTypeStr
(
aType
)
)
;
}
else
{
WAKE_LOCK_LOG
(
"
Failed
to
request
%
s
lock
error
=
%
lu
"
RequestTypeStr
(
aType
)
GetLastError
(
)
)
;
SetHandle
(
nullptr
aType
)
;
}
}
void
ReleaseWakelockIfNeeded
(
POWER_REQUEST_TYPE
aType
)
{
if
(
!
GetHandle
(
aType
)
)
{
WAKE_LOCK_LOG
(
"
Already
released
lock
for
%
s
"
RequestTypeStr
(
aType
)
)
;
return
;
}
WAKE_LOCK_LOG
(
"
Prepare
to
release
wakelock
for
%
s
"
RequestTypeStr
(
aType
)
)
;
if
(
!
PowerClearRequest
(
GetHandle
(
aType
)
aType
)
)
{
WAKE_LOCK_LOG
(
"
Failed
to
release
%
s
lock
error
=
%
lu
"
RequestTypeStr
(
aType
)
GetLastError
(
)
)
;
return
;
}
SetHandle
(
nullptr
aType
)
;
WAKE_LOCK_LOG
(
"
Released
wakelock
for
%
s
"
RequestTypeStr
(
aType
)
)
;
}
NS_IMETHOD
Callback
(
const
nsAString
&
aTopic
const
nsAString
&
aState
)
override
{
WAKE_LOCK_LOG
(
"
topic
=
%
s
state
=
%
s
"
NS_ConvertUTF16toUTF8
(
aTopic
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aState
)
.
get
(
)
)
;
if
(
!
aTopic
.
EqualsASCII
(
"
screen
"
)
&
&
!
aTopic
.
EqualsASCII
(
"
audio
-
playing
"
)
&
&
!
aTopic
.
EqualsASCII
(
"
video
-
playing
"
)
)
{
return
NS_OK
;
}
const
bool
isNonDisplayLock
=
aTopic
.
EqualsASCII
(
"
audio
-
playing
"
)
;
bool
requestLock
=
false
;
if
(
isNonDisplayLock
)
{
requestLock
=
aState
.
EqualsASCII
(
"
locked
-
foreground
"
)
|
|
aState
.
EqualsASCII
(
"
locked
-
background
"
)
;
}
else
{
requestLock
=
aState
.
EqualsASCII
(
"
locked
-
foreground
"
)
;
}
if
(
isNonDisplayLock
)
{
if
(
requestLock
)
{
RequestWakelockIfNeeded
(
PowerRequestExecutionRequired
)
;
}
else
{
ReleaseWakelockIfNeeded
(
PowerRequestExecutionRequired
)
;
}
}
else
{
if
(
requestLock
)
{
RequestWakelockIfNeeded
(
PowerRequestDisplayRequired
)
;
}
else
{
ReleaseWakelockIfNeeded
(
PowerRequestDisplayRequired
)
;
}
}
return
NS_OK
;
}
HANDLE
mDisplayHandle
=
nullptr
;
HANDLE
mNonDisplayHandle
=
nullptr
;
}
;
NS_IMPL_ISUPPORTS
(
WinWakeLockListener
nsIDOMMozWakeLockListener
)
StaticRefPtr
<
nsIDOMMozWakeLockListener
>
sWakeLockListener
;
static
void
AddScreenWakeLockListener
(
)
{
nsCOMPtr
<
nsIPowerManagerService
>
sPowerManagerService
=
do_GetService
(
POWERMANAGERSERVICE_CONTRACTID
)
;
if
(
sPowerManagerService
)
{
sWakeLockListener
=
new
WinWakeLockListener
(
)
;
sPowerManagerService
-
>
AddWakeLockListener
(
sWakeLockListener
)
;
}
else
{
NS_WARNING
(
"
Failed
to
retrieve
PowerManagerService
wakelocks
will
be
broken
!
"
)
;
}
}
static
void
RemoveScreenWakeLockListener
(
)
{
nsCOMPtr
<
nsIPowerManagerService
>
sPowerManagerService
=
do_GetService
(
POWERMANAGERSERVICE_CONTRACTID
)
;
if
(
sPowerManagerService
)
{
sPowerManagerService
-
>
RemoveWakeLockListener
(
sWakeLockListener
)
;
sPowerManagerService
=
nullptr
;
sWakeLockListener
=
nullptr
;
}
}
class
SingleNativeEventPump
final
:
public
nsIThreadObserver
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADOBSERVER
SingleNativeEventPump
(
)
{
MOZ_ASSERT
(
!
XRE_UseNativeEventProcessing
(
)
"
Should
only
be
used
when
not
properly
processing
events
.
"
)
;
}
private
:
~
SingleNativeEventPump
(
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
SingleNativeEventPump
nsIThreadObserver
)
NS_IMETHODIMP
SingleNativeEventPump
:
:
OnDispatchedEvent
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
SingleNativeEventPump
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
{
MSG
msg
;
bool
gotMessage
=
WinUtils
:
:
PeekMessage
(
&
msg
nullptr
0
0
PM_REMOVE
)
;
if
(
gotMessage
)
{
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessageW
(
&
msg
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SingleNativeEventPump
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
{
return
NS_OK
;
}
const
wchar_t
*
kAppShellGeckoEventId
=
L
"
nsAppShell
:
EventID
"
;
UINT
sAppShellGeckoMsgId
=
0x10001
;
const
wchar_t
*
kTaskbarButtonEventId
=
L
"
TaskbarButtonCreated
"
;
UINT
sTaskbarButtonCreatedMsg
=
0x10002
;
UINT
nsAppShell
:
:
GetTaskbarButtonCreatedMessage
(
)
{
return
sTaskbarButtonCreatedMsg
;
}
namespace
mozilla
{
namespace
crashreporter
{
void
LSPAnnotate
(
)
;
}
}
using
mozilla
:
:
crashreporter
:
:
LSPAnnotate
;
static
Atomic
<
size_t
ReleaseAcquire
>
sOutstandingNativeEventCallbacks
;
LRESULT
CALLBACK
nsAppShell
:
:
EventWindowProc
(
HWND
hwnd
UINT
uMsg
WPARAM
wParam
LPARAM
lParam
)
{
NativeEventLogger
eventLogger
(
"
AppShell
"
hwnd
uMsg
wParam
lParam
)
;
if
(
uMsg
=
=
sAppShellGeckoMsgId
)
{
if
(
!
sOutstandingNativeEventCallbacks
)
{
return
TRUE
;
}
nsAppShell
*
as
=
reinterpret_cast
<
nsAppShell
*
>
(
lParam
)
;
as
-
>
NativeEventCallback
(
)
;
-
-
sOutstandingNativeEventCallbacks
;
return
TRUE
;
}
LRESULT
ret
=
DefWindowProc
(
hwnd
uMsg
wParam
lParam
)
;
eventLogger
.
SetResult
(
ret
false
)
;
return
ret
;
}
nsAppShell
:
:
~
nsAppShell
(
)
{
hal
:
:
Shutdown
(
)
;
if
(
mEventWnd
)
{
SendMessage
(
mEventWnd
WM_CLOSE
0
0
)
;
}
sOutstandingNativeEventCallbacks
=
0
;
}
NS_IMETHODIMP
nsAppShell
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obsServ
(
mozilla
:
:
services
:
:
GetObserverService
(
)
)
;
if
(
!
strcmp
(
aTopic
"
sessionstore
-
restoring
-
on
-
startup
"
)
)
{
nsWindow
:
:
SetIsRestoringSession
(
true
)
;
obsServ
-
>
RemoveObserver
(
this
"
sessionstore
-
restoring
-
on
-
startup
"
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
"
sessionstore
-
windows
-
restored
"
)
)
{
nsWindow
:
:
SetIsRestoringSession
(
false
)
;
obsServ
-
>
RemoveObserver
(
this
"
sessionstore
-
windows
-
restored
"
)
;
return
NS_OK
;
}
}
return
nsBaseAppShell
:
:
Observe
(
aSubject
aTopic
aData
)
;
}
namespace
{
struct
WinErrorState
{
DWORD
error
=
~
0
;
NTSTATUS
ntStatus
=
~
0
;
private
:
constexpr
static
size_t
kLastNtStatusOffset
=
sizeof
(
size_t
)
=
=
8
?
0x1250
:
0xbf4
;
static
void
SetLastNtStatus
(
NTSTATUS
status
)
{
auto
*
teb
=
:
:
NtCurrentTeb
(
)
;
*
reinterpret_cast
<
NTSTATUS
*
>
(
reinterpret_cast
<
char
*
>
(
teb
)
+
kLastNtStatusOffset
)
=
status
;
}
static
NTSTATUS
GetLastNtStatus
(
)
{
auto
const
*
teb
=
:
:
NtCurrentTeb
(
)
;
return
*
reinterpret_cast
<
NTSTATUS
const
*
>
(
reinterpret_cast
<
char
const
*
>
(
teb
)
+
kLastNtStatusOffset
)
;
}
public
:
static
void
Apply
(
WinErrorState
const
&
state
)
{
SetLastNtStatus
(
state
.
ntStatus
)
;
:
:
SetLastError
(
state
.
error
)
;
}
static
void
Clear
(
)
{
Apply
(
{
.
error
=
0
.
ntStatus
=
0
}
)
;
}
static
WinErrorState
Get
(
)
{
return
WinErrorState
{
.
error
=
:
:
GetLastError
(
)
.
ntStatus
=
GetLastNtStatus
(
)
}
;
}
bool
operator
=
=
(
WinErrorState
const
&
that
)
const
{
return
this
-
>
error
=
=
that
.
error
&
&
this
-
>
ntStatus
=
=
that
.
ntStatus
;
}
bool
operator
!
=
(
WinErrorState
const
&
that
)
const
{
return
!
operator
=
=
(
that
)
;
}
}
;
struct
AtomTableInformation
{
UINT
in_use
=
0
;
UINT
free
=
0
;
UINT
errors
=
0
;
UINT
lastErrorAtom
=
~
0u
;
WinErrorState
lastErrorState
;
}
;
MOZ_NEVER_INLINE
static
AtomTableInformation
DiagnoseUserAtomTable
(
)
{
auto
const
_restoreErrState
=
mozilla
:
:
MakeScopeExit
(
[
oldErrState
=
WinErrorState
:
:
Get
(
)
]
(
)
{
WinErrorState
:
:
Apply
(
oldErrState
)
;
}
)
;
AtomTableInformation
retval
;
constexpr
WinErrorState
kBufferTooSmall
=
{
.
error
=
ERROR_INSUFFICIENT_BUFFER
.
ntStatus
=
(
(
NTSTATUS
)
0xC0000023
)
}
;
constexpr
WinErrorState
kInvalidAtom
=
{
.
error
=
ERROR_INVALID_HANDLE
.
ntStatus
=
(
(
NTSTATUS
)
STATUS_INVALID_HANDLE
)
}
;
for
(
UINT
atom
=
0xC000
;
atom
<
=
0xFFFF
;
+
+
atom
)
{
WCHAR
buf
[
2
]
=
{
}
;
BOOL
const
ok
=
:
:
GetClipboardFormatNameW
(
atom
buf
1
)
;
WinErrorState
const
errState
=
WinErrorState
:
:
Get
(
)
;
if
(
ok
|
|
errState
=
=
kBufferTooSmall
)
{
+
+
retval
.
in_use
;
}
else
if
(
errState
=
=
kInvalidAtom
)
{
+
+
retval
.
free
;
}
else
{
+
+
retval
.
errors
;
retval
.
lastErrorAtom
=
atom
;
retval
.
lastErrorState
=
errState
;
}
}
return
retval
;
}
}
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
&
&
defined
(
_M_X64
)
MOZ_NEVER_INLINE
__attribute__
(
(
naked
)
)
void
EnableTrapFlag
(
)
{
asm
volatile
(
"
pushfq
;
"
"
orw
0x100
(
%
rsp
)
;
"
"
popfq
;
"
"
retq
;
"
)
;
}
MOZ_NEVER_INLINE
__attribute__
(
(
naked
)
)
void
DisableTrapFlag
(
)
{
asm
volatile
(
"
retq
;
"
)
;
}
#
define
SSD_MAX_USER32_STEPS
0x1800
#
define
SSD_MAX_ERROR_STATES
0x200
struct
SingleStepData
{
uint32_t
mUser32StepsLog
[
SSD_MAX_USER32_STEPS
]
{
}
;
WinErrorState
mErrorStatesLog
[
SSD_MAX_ERROR_STATES
]
;
uint16_t
mUser32StepsAtErrorState
[
SSD_MAX_ERROR_STATES
]
{
}
;
}
;
struct
SingleStepStaticState
{
SingleStepData
*
mData
{
}
;
uintptr_t
mUser32Start
{
}
;
uintptr_t
mUser32End
{
}
;
uint32_t
mUser32Steps
{
}
;
uint32_t
mErrorStates
{
}
;
WinErrorState
mLastRecordedErrorState
;
constexpr
void
Reset
(
)
{
*
this
=
SingleStepStaticState
{
}
;
}
}
;
static
SingleStepStaticState
sSingleStepStaticState
{
}
;
LONG
SingleStepExceptionHandler
(
_EXCEPTION_POINTERS
*
aExceptionInfo
)
{
auto
&
state
=
sSingleStepStaticState
;
if
(
state
.
mData
&
&
aExceptionInfo
-
>
ExceptionRecord
-
>
ExceptionCode
=
=
EXCEPTION_SINGLE_STEP
)
{
auto
instructionPointer
=
aExceptionInfo
-
>
ContextRecord
-
>
Rip
;
if
(
instructionPointer
=
=
reinterpret_cast
<
uintptr_t
>
(
&
DisableTrapFlag
)
)
{
state
.
mData
=
nullptr
;
}
else
{
if
(
state
.
mUser32Start
<
=
instructionPointer
&
&
instructionPointer
<
state
.
mUser32End
)
{
if
(
state
.
mUser32Steps
<
SSD_MAX_USER32_STEPS
)
{
state
.
mData
-
>
mUser32StepsLog
[
state
.
mUser32Steps
]
=
static_cast
<
uint32_t
>
(
instructionPointer
-
state
.
mUser32Start
)
;
}
auto
currentErrorState
{
WinErrorState
:
:
Get
(
)
}
;
if
(
currentErrorState
!
=
state
.
mLastRecordedErrorState
)
{
state
.
mLastRecordedErrorState
=
currentErrorState
;
if
(
state
.
mErrorStates
<
SSD_MAX_ERROR_STATES
)
{
state
.
mData
-
>
mErrorStatesLog
[
state
.
mErrorStates
]
=
currentErrorState
;
state
.
mData
-
>
mUser32StepsAtErrorState
[
state
.
mErrorStates
]
=
state
.
mUser32Steps
;
}
+
+
state
.
mErrorStates
;
}
+
+
state
.
mUser32Steps
;
}
aExceptionInfo
-
>
ContextRecord
-
>
EFlags
|
=
0x100
;
}
return
EXCEPTION_CONTINUE_EXECUTION
;
}
return
EXCEPTION_CONTINUE_SEARCH
;
}
enum
CSSD_RESULT
{
CSSD_SUCCESS
=
0
CSSD_ERROR_DEBUGGER_PRESENT
=
1
CSSD_ERROR_GET_MODULE_HANDLE
=
2
CSSD_ERROR_PARSING_USER32
=
3
CSSD_ERROR_ADD_VECTORED_EXCEPTION_HANDLER
=
4
}
;
template
<
typename
CallbackToRun
typename
PostCollectionCallback
>
[
[
clang
:
:
optnone
]
]
MOZ_NEVER_INLINE
CSSD_RESULT
CollectSingleStepData
(
CallbackToRun
aCallbackToRun
PostCollectionCallback
aPostCollectionCallback
)
{
if
(
:
:
IsDebuggerPresent
(
)
)
{
return
CSSD_ERROR_DEBUGGER_PRESENT
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
sSingleStepStaticState
.
mData
"
Single
-
stepping
is
already
active
"
)
;
HANDLE
user32
=
:
:
GetModuleHandleW
(
L
"
user32
.
dll
"
)
;
if
(
!
user32
)
{
return
CSSD_ERROR_GET_MODULE_HANDLE
;
}
nt
:
:
PEHeaders
user32Headers
{
user32
}
;
auto
bounds
=
user32Headers
.
GetBounds
(
)
;
if
(
bounds
.
isNothing
(
)
)
{
return
CSSD_ERROR_PARSING_USER32
;
}
SingleStepData
singleStepData
{
}
;
sSingleStepStaticState
.
Reset
(
)
;
sSingleStepStaticState
.
mUser32Start
=
reinterpret_cast
<
uintptr_t
>
(
bounds
.
ref
(
)
.
begin
(
)
.
get
(
)
)
;
sSingleStepStaticState
.
mUser32End
=
reinterpret_cast
<
uintptr_t
>
(
bounds
.
ref
(
)
.
end
(
)
.
get
(
)
)
;
sSingleStepStaticState
.
mData
=
&
singleStepData
;
auto
veh
=
:
:
AddVectoredExceptionHandler
(
TRUE
SingleStepExceptionHandler
)
;
if
(
!
veh
)
{
sSingleStepStaticState
.
mData
=
nullptr
;
return
CSSD_ERROR_ADD_VECTORED_EXCEPTION_HANDLER
;
}
EnableTrapFlag
(
)
;
aCallbackToRun
(
)
;
DisableTrapFlag
(
)
;
:
:
RemoveVectoredExceptionHandler
(
veh
)
;
sSingleStepStaticState
.
mData
=
nullptr
;
aPostCollectionCallback
(
)
;
return
CSSD_SUCCESS
;
}
#
endif
[
[
clang
:
:
optnone
]
]
MOZ_NEVER_INLINE
nsresult
nsAppShell
:
:
InitHiddenWindow
(
)
{
auto
_initialErr
[
[
maybe_unused
]
]
=
WinErrorState
:
:
Get
(
)
;
WinErrorState
:
:
Clear
(
)
;
AtomTableInformation
_atomTableInfo
[
[
maybe_unused
]
]
;
auto
const
_msgId
=
:
:
RegisterWindowMessageW
(
kAppShellGeckoEventId
)
;
if
(
_msgId
)
{
sAppShellGeckoMsgId
=
_msgId
;
}
auto
const
_sAppShellGeckoMsgId
[
[
maybe_unused
]
]
=
sAppShellGeckoMsgId
;
auto
const
_rwmErr
[
[
maybe_unused
]
]
=
WinErrorState
:
:
Get
(
)
;
if
(
!
_msgId
)
_atomTableInfo
=
DiagnoseUserAtomTable
(
)
;
NS_ASSERTION
(
sAppShellGeckoMsgId
"
Could
not
register
hidden
window
event
message
!
"
)
;
mLastNativeEventScheduled
=
TimeStamp
:
:
NowLoRes
(
)
;
WNDCLASSW
wc
;
HINSTANCE
const
module
=
GetModuleHandle
(
nullptr
)
;
constexpr
const
wchar_t
*
kWindowClass
=
L
"
nsAppShell
:
EventWindowClass
"
;
BOOL
const
_gciwRet
=
:
:
GetClassInfoW
(
module
kWindowClass
&
wc
)
;
auto
const
_gciwErr
[
[
maybe_unused
]
]
=
WinErrorState
:
:
Get
(
)
;
WinErrorState
:
:
Clear
(
)
;
WinErrorState
_rcErr
[
[
maybe_unused
]
]
;
if
(
!
_gciwRet
)
{
wc
.
style
=
0
;
wc
.
lpfnWndProc
=
EventWindowProc
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
module
;
wc
.
hIcon
=
nullptr
;
wc
.
hCursor
=
nullptr
;
wc
.
hbrBackground
=
(
HBRUSH
)
nullptr
;
wc
.
lpszMenuName
=
(
LPCWSTR
)
nullptr
;
wc
.
lpszClassName
=
kWindowClass
;
ATOM
_windowClassAtom
=
:
:
RegisterClassW
(
&
wc
)
;
_rcErr
=
WinErrorState
:
:
Get
(
)
;
if
(
!
_windowClassAtom
)
_atomTableInfo
=
DiagnoseUserAtomTable
(
)
;
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
&
&
defined
(
_M_X64
)
if
(
!
_windowClassAtom
)
{
auto
cssdResult
=
CollectSingleStepData
(
[
&
wc
&
_windowClassAtom
]
(
)
{
_windowClassAtom
=
:
:
RegisterClassW
(
&
wc
)
;
}
[
&
_windowClassAtom
]
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
_windowClassAtom
"
RegisterClassW
for
EventWindowClass
failed
twice
"
)
;
}
)
;
auto
const
_cssdErr
[
[
maybe_unused
]
]
=
WinErrorState
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cssdResult
=
=
CSSD_SUCCESS
"
Failed
to
collect
single
step
data
for
RegisterClassW
"
)
;
}
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
_windowClassAtom
"
RegisterClassW
for
EventWindowClass
failed
"
)
;
WinErrorState
:
:
Clear
(
)
;
}
mEventWnd
=
CreateWindowW
(
kWindowClass
L
"
nsAppShell
:
EventWindow
"
0
0
0
10
10
HWND_MESSAGE
nullptr
module
nullptr
)
;
auto
const
_cwErr
[
[
maybe_unused
]
]
=
WinErrorState
:
:
Get
(
)
;
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
&
&
defined
(
_M_X64
)
if
(
!
mEventWnd
)
{
HWND
eventWnd
{
}
;
auto
cssdResult
=
CollectSingleStepData
(
[
module
&
eventWnd
]
(
)
{
eventWnd
=
CreateWindowW
(
kWindowClass
L
"
nsAppShell
:
EventWindow
"
0
0
0
10
10
HWND_MESSAGE
nullptr
module
nullptr
)
;
}
[
&
eventWnd
]
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
eventWnd
"
CreateWindowW
for
EventWindow
failed
twice
"
)
;
}
)
;
auto
const
_cssdErr
[
[
maybe_unused
]
]
=
WinErrorState
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cssdResult
=
=
CSSD_SUCCESS
"
Failed
to
collect
single
step
data
for
CreateWindowW
"
)
;
mEventWnd
=
eventWnd
;
}
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
mEventWnd
"
CreateWindowW
for
EventWindow
failed
"
)
;
NS_ENSURE_STATE
(
mEventWnd
)
;
return
NS_OK
;
}
nsresult
nsAppShell
:
:
Init
(
)
{
LSPAnnotate
(
)
;
hal
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
sTaskbarButtonCreatedMsg
=
:
:
RegisterWindowMessageW
(
kTaskbarButtonEventId
)
;
NS_ASSERTION
(
sTaskbarButtonCreatedMsg
"
Could
not
register
taskbar
button
creation
message
"
)
;
}
if
(
XRE_UseNativeEventProcessing
(
)
)
{
if
(
nsresult
rv
=
this
-
>
InitHiddenWindow
(
)
;
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
if
(
XRE_IsContentProcess
(
)
&
&
!
IsWin32kLockedDown
(
)
)
{
nsCOMPtr
<
nsIThreadInternal
>
threadInt
=
do_QueryInterface
(
NS_GetCurrentThread
(
)
)
;
if
(
threadInt
)
{
threadInt
-
>
SetObserver
(
new
SingleNativeEventPump
(
)
)
;
}
}
if
(
XRE_IsParentProcess
(
)
)
{
ScreenManager
&
screenManager
=
ScreenManager
:
:
GetSingleton
(
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
screenManager
.
SetHelper
(
mozilla
:
:
MakeUnique
<
HeadlessScreenHelper
>
(
)
)
;
}
else
{
screenManager
.
SetHelper
(
mozilla
:
:
MakeUnique
<
ScreenHelperWin
>
(
)
)
;
ScreenHelperWin
:
:
RefreshScreens
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsServ
(
mozilla
:
:
services
:
:
GetObserverService
(
)
)
;
obsServ
-
>
AddObserver
(
this
"
sessionstore
-
restoring
-
on
-
startup
"
false
)
;
obsServ
-
>
AddObserver
(
this
"
sessionstore
-
windows
-
restored
"
false
)
;
}
if
(
!
WinUtils
:
:
GetTimezoneName
(
mTimezoneName
)
)
{
NS_WARNING
(
"
Unable
to
get
system
timezone
name
timezone
may
be
invalid
\
n
"
)
;
}
return
nsBaseAppShell
:
:
Init
(
)
;
}
NS_IMETHODIMP
nsAppShell
:
:
Run
(
void
)
{
bool
wantAudio
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
#
ifdef
MOZ_BACKGROUNDTASKS
if
(
BackgroundTasks
:
:
IsBackgroundTaskMode
(
)
)
{
wantAudio
=
false
;
}
#
endif
if
(
MOZ_LIKELY
(
wantAudio
)
)
{
mozilla
:
:
widget
:
:
StartAudioSession
(
)
;
}
AddScreenWakeLockListener
(
)
;
}
nsresult
rv
=
nsBaseAppShell
:
:
Run
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
RemoveScreenWakeLockListener
(
)
;
if
(
MOZ_LIKELY
(
wantAudio
)
)
{
mozilla
:
:
widget
:
:
StopAudioSession
(
)
;
}
}
return
rv
;
}
void
nsAppShell
:
:
DoProcessMoreGeckoEvents
(
)
{
if
(
mEventloopNestingLevel
<
2
)
{
OnDispatchedEvent
(
)
;
mNativeCallbackPending
=
false
;
}
else
{
mNativeCallbackPending
=
true
;
}
}
void
nsAppShell
:
:
ScheduleNativeEventCallback
(
)
{
MOZ_ASSERT
(
mEventWnd
"
We
should
have
created
mEventWnd
in
Init
if
this
is
called
.
"
)
;
+
+
sOutstandingNativeEventCallbacks
;
{
MutexAutoLock
lock
(
mLastNativeEventScheduledMutex
)
;
mLastNativeEventScheduled
=
TimeStamp
:
:
NowLoRes
(
)
;
}
:
:
PostMessage
(
mEventWnd
sAppShellGeckoMsgId
0
reinterpret_cast
<
LPARAM
>
(
this
)
)
;
}
bool
nsAppShell
:
:
ProcessNextNativeEvent
(
bool
mayWait
)
{
mozilla
:
:
ipc
:
:
MessageChannel
:
:
NotifyGeckoEventDispatch
(
)
;
bool
gotMessage
=
false
;
do
{
MSG
msg
;
if
(
mozilla
:
:
widget
:
:
MouseScrollHandler
:
:
IsWaitingInternalMessage
(
)
)
{
gotMessage
=
WinUtils
:
:
PeekMessage
(
&
msg
nullptr
MOZ_WM_MOUSEWHEEL_FIRST
MOZ_WM_MOUSEWHEEL_LAST
PM_REMOVE
)
;
NS_ASSERTION
(
gotMessage
"
waiting
internal
wheel
message
but
it
has
not
come
"
)
;
}
if
(
!
gotMessage
)
{
gotMessage
=
WinUtils
:
:
PeekMessage
(
&
msg
nullptr
0
0
PM_REMOVE
)
;
}
if
(
gotMessage
)
{
if
(
msg
.
message
=
=
WM_QUIT
)
{
:
:
PostQuitMessage
(
msg
.
wParam
)
;
Exit
(
)
;
}
else
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
if
(
msg
.
message
>
=
WM_KEYFIRST
&
&
msg
.
message
<
=
WM_KEYLAST
&
&
IMEHandler
:
:
ProcessRawKeyMessage
(
msg
)
)
{
continue
;
}
#
if
defined
(
_X86_
)
if
(
msg
.
message
=
=
0x5b7a
|
|
msg
.
message
=
=
0x5b7f
|
|
msg
.
message
=
=
0x5b80
|
|
msg
.
message
=
=
0x5b81
)
{
mMsgsToRepost
.
push_back
(
msg
)
;
continue
;
}
#
endif
if
(
msg
.
message
=
=
WM_TIMECHANGE
)
{
wchar_t
systemTimezone
[
128
]
;
bool
getSystemTimeSucceeded
=
WinUtils
:
:
GetTimezoneName
(
systemTimezone
)
;
if
(
getSystemTimeSucceeded
&
&
wcscmp
(
systemTimezone
mTimezoneName
)
)
{
nsBaseAppShell
:
:
OnSystemTimezoneChange
(
)
;
wcscpy_s
(
mTimezoneName
128
systemTimezone
)
;
}
}
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessageW
(
&
msg
)
;
}
}
else
if
(
mayWait
)
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
{
AUTO_PROFILER_LABEL
(
"
nsAppShell
:
:
ProcessNextNativeEvent
:
:
Wait
"
IDLE
)
;
WinUtils
:
:
WaitForMessage
(
)
;
}
}
}
while
(
!
gotMessage
&
&
mayWait
)
;
if
(
mNativeCallbackPending
&
&
mEventloopNestingLevel
=
=
1
)
DoProcessMoreGeckoEvents
(
)
;
static
const
mozilla
:
:
TimeDuration
nativeEventStarvationLimit
=
mozilla
:
:
TimeDuration
:
:
FromSeconds
(
NATIVE_EVENT_STARVATION_LIMIT
)
;
TimeDuration
timeSinceLastNativeEventScheduled
;
{
MutexAutoLock
lock
(
mLastNativeEventScheduledMutex
)
;
timeSinceLastNativeEventScheduled
=
TimeStamp
:
:
NowLoRes
(
)
-
mLastNativeEventScheduled
;
}
if
(
timeSinceLastNativeEventScheduled
>
nativeEventStarvationLimit
)
{
ScheduleNativeEventCallback
(
)
;
}
return
gotMessage
;
}
nsresult
nsAppShell
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
bool
)
{
if
(
!
mMsgsToRepost
.
empty
(
)
)
{
for
(
MSG
msg
:
mMsgsToRepost
)
{
:
:
PostMessageW
(
msg
.
hwnd
msg
.
message
msg
.
wParam
msg
.
lParam
)
;
}
mMsgsToRepost
.
clear
(
)
;
}
return
NS_OK
;
}
