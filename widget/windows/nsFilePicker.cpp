#
include
"
nsFilePicker
.
h
"
#
include
<
cderr
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
sysinfoapi
.
h
>
#
include
<
winerror
.
h
>
#
include
<
winuser
.
h
>
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessManager
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsEnumeratorUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
widget
/
filedialog
/
WinFileDialogCommands
.
h
"
#
include
"
mozilla
/
widget
/
filedialog
/
WinFileDialogParent
.
h
"
using
mozilla
:
:
UniquePtr
;
using
namespace
mozilla
:
:
widget
;
UniquePtr
<
char16_t
[
]
nsFilePicker
:
:
FreeDeleter
>
nsFilePicker
:
:
sLastUsedUnicodeDirectory
;
using
mozilla
:
:
LogLevel
;
#
define
MAX_EXTENSION_LENGTH
10
class
AutoWidgetPickerState
{
public
:
explicit
AutoWidgetPickerState
(
nsIWidget
*
aWidget
)
:
mWindow
(
static_cast
<
nsWindow
*
>
(
aWidget
)
)
{
PickerState
(
true
)
;
}
AutoWidgetPickerState
(
AutoWidgetPickerState
const
&
)
=
delete
;
AutoWidgetPickerState
(
AutoWidgetPickerState
&
&
that
)
noexcept
=
default
;
~
AutoWidgetPickerState
(
)
{
PickerState
(
false
)
;
}
private
:
void
PickerState
(
bool
aFlag
)
{
if
(
mWindow
)
{
if
(
aFlag
)
mWindow
-
>
PickerOpen
(
)
;
else
mWindow
-
>
PickerClosed
(
)
;
}
}
RefPtr
<
nsWindow
>
mWindow
;
}
;
nsFilePicker
:
:
nsFilePicker
(
)
:
mSelectedType
(
1
)
{
}
NS_IMPL_ISUPPORTS
(
nsFilePicker
nsIFilePicker
)
NS_IMETHODIMP
nsFilePicker
:
:
Init
(
mozIDOMWindowProxy
*
aParent
const
nsAString
&
aTitle
nsIFilePicker
:
:
Mode
aMode
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
nsresult
:
:
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
do_QueryInterface
(
aParent
)
;
nsIDocShell
*
docShell
=
window
?
window
-
>
GetDocShell
(
)
:
nullptr
;
mLoadContext
=
do_QueryInterface
(
docShell
)
;
return
nsBaseFilePicker
:
:
Init
(
aParent
aTitle
aMode
)
;
}
namespace
mozilla
:
:
detail
{
template
<
typename
ActionType
typename
ReturnType
=
typename
decltype
(
std
:
:
declval
<
ActionType
>
(
)
(
nullptr
)
)
:
:
element_type
:
:
ResolveValueType
>
static
auto
ShowRemote
(
HWND
parent
ActionType
&
&
action
)
-
>
RefPtr
<
MozPromise
<
ReturnType
HRESULT
true
>
>
{
using
RetPromise
=
MozPromise
<
ReturnType
HRESULT
true
>
;
constexpr
static
const
auto
fail
=
[
]
(
)
{
return
RetPromise
:
:
CreateAndReject
(
E_FAIL
__PRETTY_FUNCTION__
)
;
}
;
auto
mgr
=
mozilla
:
:
ipc
:
:
UtilityProcessManager
:
:
GetSingleton
(
)
;
if
(
!
mgr
)
{
MOZ_ASSERT
(
false
)
;
return
fail
(
)
;
}
auto
wfda
=
mgr
-
>
CreateWinFileDialogActor
(
)
;
if
(
!
wfda
)
{
return
fail
(
)
;
}
using
mozilla
:
:
widget
:
:
filedialog
:
:
sLogFileDialog
;
struct
WindowEnabler
{
HWND
hwnd
;
BOOL
enabled
;
explicit
WindowEnabler
(
HWND
hwnd
)
:
hwnd
(
hwnd
)
enabled
(
:
:
IsWindowEnabled
(
hwnd
)
)
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Info
(
"
ShowRemote
:
HWND
%
08zX
enabled
=
%
u
"
uintptr_t
(
hwnd
)
enabled
)
)
;
}
WindowEnabler
(
WindowEnabler
const
&
)
=
default
;
void
restore
(
)
const
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Info
(
"
ShowRemote
:
HWND
%
08zX
enabled
=
%
u
(
restoring
to
%
u
)
"
uintptr_t
(
hwnd
)
:
:
IsWindowEnabled
(
hwnd
)
enabled
)
)
;
:
:
EnableWindow
(
hwnd
enabled
)
;
}
}
;
HWND
const
rootWindow
=
:
:
GetAncestor
(
parent
GA_ROOT
)
;
return
wfda
-
>
Then
(
mozilla
:
:
GetMainThreadSerialEventTarget
(
)
"
nsFilePicker
ShowRemote
acquire
"
[
action
=
std
:
:
forward
<
ActionType
>
(
action
)
rootWindow
]
(
filedialog
:
:
ProcessProxy
const
&
p
)
-
>
RefPtr
<
RetPromise
>
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Info
(
"
nsFilePicker
ShowRemote
first
callback
:
p
=
[
%
p
]
"
p
.
get
(
)
)
)
;
WindowEnabler
enabledState
(
rootWindow
)
;
return
action
(
p
.
get
(
)
)
-
>
Then
(
mozilla
:
:
GetMainThreadSerialEventTarget
(
)
"
nsFilePicker
ShowRemote
call
"
[
p
]
(
ReturnType
ret
)
{
return
RetPromise
:
:
CreateAndResolve
(
std
:
:
move
(
ret
)
__PRETTY_FUNCTION__
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
error
)
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Error
(
"
IPC
call
rejected
:
%
zu
"
size_t
(
error
)
)
)
;
return
fail
(
)
;
}
)
-
>
Then
(
mozilla
:
:
GetMainThreadSerialEventTarget
(
)
"
nsFilePicker
ShowRemote
cleanup
"
[
enabledState
]
(
typename
RetPromise
:
:
ResolveOrRejectValue
const
&
val
)
{
enabledState
.
restore
(
)
;
return
RetPromise
:
:
CreateAndResolveOrReject
(
val
"
nsFilePicker
ShowRemote
cleanup
fmap
"
)
;
}
)
;
}
[
]
(
nsresult
error
)
-
>
RefPtr
<
RetPromise
>
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Error
(
"
could
not
acquire
WinFileDialog
:
%
zu
"
size_t
(
error
)
)
)
;
return
fail
(
)
;
}
)
;
}
namespace
fd_async
{
namespace
details
{
template
<
typename
T
>
static
T
Copy
(
T
const
&
val
)
{
return
val
;
}
template
<
typename
T
>
static
nsTArray
<
T
>
Copy
(
nsTArray
<
T
>
const
&
arr
)
{
return
arr
.
Clone
(
)
;
}
enum
Strategy
{
Local
Remote
RemoteWithFallback
}
;
static
Strategy
GetStrategy
(
)
{
int32_t
const
pref
=
mozilla
:
:
StaticPrefs
:
:
widget_windows_utility_process_file_picker
(
)
;
switch
(
pref
)
{
case
-
1
:
return
Local
;
case
2
:
return
Remote
;
case
1
:
return
RemoteWithFallback
;
default
:
#
ifdef
NIGHTLY_BUILD
return
RemoteWithFallback
;
#
else
return
Local
;
#
endif
}
}
;
namespace
telemetry
{
static
uint32_t
Delta
(
uint64_t
tb
uint64_t
ta
)
{
return
uint32_t
(
(
tb
-
ta
)
/
10
'
000
)
;
}
;
static
nsCString
HexString
(
HRESULT
val
)
{
return
nsPrintfCString
(
"
%
08lX
"
val
)
;
}
;
static
void
RecordSuccess
(
uint64_t
(
&
&
time
)
[
2
]
)
{
auto
[
t0
t1
]
=
time
;
namespace
glean_fd
=
mozilla
:
:
glean
:
:
file_dialog
;
glean_fd
:
:
FallbackExtra
extra
{
.
hresultLocal
=
Nothing
(
)
.
hresultRemote
=
Nothing
(
)
.
succeeded
=
Some
(
true
)
.
timeLocal
=
Nothing
(
)
.
timeRemote
=
Some
(
Delta
(
t1
t0
)
)
}
;
glean_fd
:
:
fallback
.
Record
(
Some
(
extra
)
)
;
}
static
void
RecordFailure
(
uint64_t
(
&
&
time
)
[
3
]
HRESULT
hrRemote
HRESULT
hrLocal
)
{
auto
[
t0
t1
t2
]
=
time
;
{
namespace
glean_fd
=
mozilla
:
:
glean
:
:
file_dialog
;
glean_fd
:
:
FallbackExtra
extra
{
.
hresultLocal
=
Some
(
HexString
(
hrLocal
)
)
.
hresultRemote
=
Some
(
HexString
(
hrRemote
)
)
.
succeeded
=
Some
(
false
)
.
timeLocal
=
Some
(
Delta
(
t2
t1
)
)
.
timeRemote
=
Some
(
Delta
(
t1
t0
)
)
}
;
glean_fd
:
:
fallback
.
Record
(
Some
(
extra
)
)
;
}
}
}
}
template
<
typename
Fn1
typename
Fn2
typename
.
.
.
Args
>
static
auto
AsyncExecute
(
Fn1
local
Fn2
remote
Args
const
&
.
.
.
args
)
-
>
std
:
:
invoke_result_t
<
Fn1
Args
.
.
.
>
{
using
namespace
details
;
static_assert
(
std
:
:
is_same_v
<
std
:
:
invoke_result_t
<
Fn1
Args
.
.
.
>
std
:
:
invoke_result_t
<
Fn2
Args
.
.
.
>
>
)
;
using
PromiseT
=
typename
std
:
:
invoke_result_t
<
Fn1
Args
.
.
.
>
:
:
element_type
;
constexpr
static
char
kFunctionName
[
]
=
"
LocalAndOrRemote
:
:
AsyncExecute
"
;
switch
(
GetStrategy
(
)
)
{
case
Local
:
return
local
(
args
.
.
.
)
;
case
Remote
:
return
remote
(
args
.
.
.
)
;
case
RemoteWithFallback
:
break
;
}
constexpr
static
const
auto
GetTime
=
[
]
(
)
-
>
uint64_t
{
FILETIME
t
;
:
:
GetSystemTimeAsFileTime
(
&
t
)
;
return
(
uint64_t
(
t
.
dwHighDateTime
)
<
<
32
)
|
t
.
dwLowDateTime
;
}
;
uint64_t
const
t0
=
GetTime
(
)
;
return
remote
(
args
.
.
.
)
-
>
Then
(
NS_GetCurrentThread
(
)
kFunctionName
[
t0
]
(
typename
PromiseT
:
:
ResolveValueType
result
)
-
>
RefPtr
<
PromiseT
>
{
auto
const
t1
=
GetTime
(
)
;
telemetry
:
:
RecordSuccess
(
{
t0
t1
}
)
;
return
PromiseT
:
:
CreateAndResolve
(
result
kFunctionName
)
;
}
[
=
tuple
=
std
:
:
make_tuple
(
Copy
(
args
)
.
.
.
)
]
(
typename
PromiseT
:
:
RejectValueType
err
)
mutable
-
>
RefPtr
<
PromiseT
>
{
auto
const
t1
=
GetTime
(
)
;
HRESULT
const
hrRemote
=
err
;
auto
p0
=
std
:
:
apply
(
local
std
:
:
move
(
tuple
)
)
;
return
p0
-
>
Then
(
NS_GetCurrentThread
(
)
kFunctionName
[
t0
t1
hrRemote
]
(
typename
PromiseT
:
:
ResolveOrRejectValue
const
&
val
)
-
>
RefPtr
<
PromiseT
>
{
auto
const
t2
=
GetTime
(
)
;
HRESULT
const
hrLocal
=
val
.
IsReject
(
)
?
val
.
RejectValue
(
)
:
S_OK
;
telemetry
:
:
RecordFailure
(
{
t0
t1
t2
}
hrRemote
hrLocal
)
;
return
PromiseT
:
:
CreateAndResolveOrReject
(
val
kFunctionName
)
;
}
)
;
}
)
;
}
}
using
fd_async
:
:
AsyncExecute
;
}
nsFilePicker
:
:
FPPromise
<
filedialog
:
:
Results
>
nsFilePicker
:
:
ShowFilePickerRemote
(
HWND
parent
filedialog
:
:
FileDialogType
type
nsTArray
<
filedialog
:
:
Command
>
const
&
commands
)
{
using
mozilla
:
:
widget
:
:
filedialog
:
:
sLogFileDialog
;
return
mozilla
:
:
detail
:
:
ShowRemote
(
parent
[
parent
type
commands
=
commands
.
Clone
(
)
]
(
filedialog
:
:
WinFileDialogParent
*
p
)
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Info
(
"
%
s
:
p
=
[
%
p
]
"
__PRETTY_FUNCTION__
p
)
)
;
return
p
-
>
SendShowFileDialog
(
(
uintptr_t
)
parent
type
commands
)
;
}
)
;
}
nsFilePicker
:
:
FPPromise
<
nsString
>
nsFilePicker
:
:
ShowFolderPickerRemote
(
HWND
parent
nsTArray
<
filedialog
:
:
Command
>
const
&
commands
)
{
using
mozilla
:
:
widget
:
:
filedialog
:
:
sLogFileDialog
;
return
mozilla
:
:
detail
:
:
ShowRemote
(
parent
[
parent
commands
=
commands
.
Clone
(
)
]
(
filedialog
:
:
WinFileDialogParent
*
p
)
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Info
(
"
%
s
:
p
=
[
%
p
]
"
__PRETTY_FUNCTION__
p
)
)
;
return
p
-
>
SendShowFolderDialog
(
(
uintptr_t
)
parent
commands
)
;
}
)
;
}
nsFilePicker
:
:
FPPromise
<
filedialog
:
:
Results
>
nsFilePicker
:
:
ShowFilePickerLocal
(
HWND
parent
filedialog
:
:
FileDialogType
type
nsTArray
<
filedialog
:
:
Command
>
const
&
commands
)
{
return
filedialog
:
:
SpawnFilePicker
(
parent
type
commands
.
Clone
(
)
)
;
}
nsFilePicker
:
:
FPPromise
<
nsString
>
nsFilePicker
:
:
ShowFolderPickerLocal
(
HWND
parent
nsTArray
<
filedialog
:
:
Command
>
const
&
commands
)
{
return
filedialog
:
:
SpawnFolderPicker
(
parent
commands
.
Clone
(
)
)
;
}
RefPtr
<
mozilla
:
:
MozPromise
<
bool
HRESULT
true
>
>
nsFilePicker
:
:
ShowFolderPicker
(
const
nsString
&
aInitialDir
)
{
using
Promise
=
mozilla
:
:
MozPromise
<
bool
HRESULT
true
>
;
constexpr
static
auto
Ok
=
[
]
(
bool
val
)
{
return
Promise
:
:
CreateAndResolve
(
val
"
nsFilePicker
:
:
ShowFolderPicker
"
)
;
}
;
constexpr
static
auto
NotOk
=
[
]
(
HRESULT
val
=
E_FAIL
)
{
return
Promise
:
:
CreateAndReject
(
val
"
nsFilePicker
:
:
ShowFolderPicker
"
)
;
}
;
namespace
fd
=
:
:
mozilla
:
:
widget
:
:
filedialog
;
nsTArray
<
fd
:
:
Command
>
commands
=
{
fd
:
:
SetOptions
(
FOS_PICKFOLDERS
)
fd
:
:
SetTitle
(
mTitle
)
}
;
if
(
!
mOkButtonLabel
.
IsEmpty
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetOkButtonLabel
(
mOkButtonLabel
)
)
;
}
if
(
!
aInitialDir
.
IsEmpty
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetFolder
(
aInitialDir
)
)
;
}
ScopedRtlShimWindow
shim
(
mParentWidget
.
get
(
)
)
;
AutoWidgetPickerState
awps
(
mParentWidget
)
;
return
mozilla
:
:
detail
:
:
AsyncExecute
(
&
ShowFolderPickerLocal
&
ShowFolderPickerRemote
shim
.
get
(
)
commands
)
-
>
Then
(
NS_GetCurrentThread
(
)
__PRETTY_FUNCTION__
[
self
=
RefPtr
(
this
)
shim
=
std
:
:
move
(
shim
)
awps
=
std
:
:
move
(
awps
)
]
(
Maybe
<
nsString
>
val
)
{
if
(
val
)
{
self
-
>
mUnicodeFile
=
val
.
extract
(
)
;
return
Ok
(
true
)
;
}
return
Ok
(
false
)
;
}
[
]
(
HRESULT
err
)
{
NS_WARNING
(
"
ShowFolderPicker
failed
"
)
;
return
NotOk
(
err
)
;
}
)
;
}
RefPtr
<
mozilla
:
:
MozPromise
<
bool
HRESULT
true
>
>
nsFilePicker
:
:
ShowFilePicker
(
const
nsString
&
aInitialDir
)
{
AUTO_PROFILER_LABEL
(
"
nsFilePicker
:
:
ShowFilePicker
"
OTHER
)
;
using
Promise
=
mozilla
:
:
MozPromise
<
bool
HRESULT
true
>
;
constexpr
static
auto
Ok
=
[
]
(
bool
val
)
{
return
Promise
:
:
CreateAndResolve
(
val
"
nsFilePicker
:
:
ShowFilePicker
"
)
;
}
;
constexpr
static
auto
NotOk
=
[
]
(
HRESULT
val
=
E_FAIL
)
{
return
Promise
:
:
CreateAndReject
(
val
"
nsFilePicker
:
:
ShowFilePicker
"
)
;
}
;
namespace
fd
=
:
:
mozilla
:
:
widget
:
:
filedialog
;
nsTArray
<
fd
:
:
Command
>
commands
;
{
FILEOPENDIALOGOPTIONS
fos
=
0
;
fos
|
=
FOS_SHAREAWARE
|
FOS_OVERWRITEPROMPT
|
FOS_FORCEFILESYSTEM
;
if
(
IsPrivacyModeEnabled
(
)
|
|
!
mAddToRecentDocs
)
{
fos
|
=
FOS_DONTADDTORECENT
;
}
switch
(
mMode
)
{
case
modeOpen
:
fos
|
=
FOS_FILEMUSTEXIST
;
break
;
case
modeOpenMultiple
:
fos
|
=
FOS_FILEMUSTEXIST
|
FOS_ALLOWMULTISELECT
;
break
;
case
modeSave
:
fos
|
=
FOS_NOREADONLYRETURN
;
if
(
IsDefaultPathLink
(
)
)
fos
|
=
FOS_NODEREFERENCELINKS
;
break
;
case
modeGetFolder
:
MOZ_ASSERT
(
false
"
file
-
picker
opened
in
directory
-
picker
mode
"
)
;
return
NotOk
(
E_FAIL
)
;
}
commands
.
AppendElement
(
fd
:
:
SetOptions
(
fos
)
)
;
}
commands
.
AppendElement
(
fd
:
:
SetTitle
(
mTitle
)
)
;
if
(
!
mDefaultFilename
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedFilename
(
mDefaultFilename
)
;
sanitizedFilename
.
ReplaceChar
(
'
%
'
'
_
'
)
;
commands
.
AppendElement
(
fd
:
:
SetFileName
(
sanitizedFilename
)
)
;
}
if
(
!
mDefaultExtension
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedExtension
(
mDefaultExtension
)
;
sanitizedExtension
.
ReplaceChar
(
'
%
'
'
_
'
)
;
commands
.
AppendElement
(
fd
:
:
SetDefaultExtension
(
sanitizedExtension
)
)
;
}
else
if
(
IsDefaultPathHtml
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetDefaultExtension
(
u
"
html
"
_ns
)
)
;
}
if
(
!
aInitialDir
.
IsEmpty
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetFolder
(
aInitialDir
)
)
;
}
if
(
!
mFilterList
.
IsEmpty
(
)
)
{
nsTArray
<
fd
:
:
ComDlgFilterSpec
>
fileTypes
;
for
(
auto
const
&
filter
:
mFilterList
)
{
fileTypes
.
EmplaceBack
(
filter
.
title
filter
.
filter
)
;
}
commands
.
AppendElement
(
fd
:
:
SetFileTypes
(
std
:
:
move
(
fileTypes
)
)
)
;
commands
.
AppendElement
(
fd
:
:
SetFileTypeIndex
(
mSelectedType
)
)
;
}
ScopedRtlShimWindow
shim
(
mParentWidget
.
get
(
)
)
;
AutoWidgetPickerState
awps
(
mParentWidget
)
;
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
auto
type
=
mMode
=
=
modeSave
?
FileDialogType
:
:
Save
:
FileDialogType
:
:
Open
;
auto
promise
=
mozilla
:
:
detail
:
:
AsyncExecute
(
&
ShowFilePickerLocal
&
ShowFilePickerRemote
shim
.
get
(
)
type
commands
)
;
return
promise
-
>
Then
(
mozilla
:
:
GetMainThreadSerialEventTarget
(
)
__PRETTY_FUNCTION__
[
self
=
RefPtr
(
this
)
mode
=
mMode
shim
=
std
:
:
move
(
shim
)
awps
=
std
:
:
move
(
awps
)
]
(
Maybe
<
Results
>
res_opt
)
{
if
(
!
res_opt
)
{
return
Ok
(
false
)
;
}
auto
result
=
res_opt
.
extract
(
)
;
self
-
>
mSelectedType
=
int32_t
(
result
.
selectedFileTypeIndex
(
)
)
;
auto
const
&
paths
=
result
.
paths
(
)
;
if
(
mode
!
=
modeOpenMultiple
)
{
if
(
!
paths
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
paths
.
Length
(
)
=
=
1
)
;
self
-
>
mUnicodeFile
=
paths
[
0
]
;
return
Ok
(
true
)
;
}
return
Ok
(
false
)
;
}
for
(
auto
const
&
str
:
paths
)
{
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_SUCCEEDED
(
NS_NewLocalFile
(
str
false
getter_AddRefs
(
file
)
)
)
)
{
self
-
>
mFiles
.
AppendObject
(
file
)
;
}
}
return
Ok
(
true
)
;
}
[
]
(
HRESULT
err
)
{
NS_WARNING
(
"
ShowFilePicker
failed
"
)
;
return
NotOk
(
err
)
;
}
)
;
}
void
nsFilePicker
:
:
ClearFiles
(
)
{
mUnicodeFile
.
Truncate
(
)
;
mFiles
.
Clear
(
)
;
}
nsresult
nsFilePicker
:
:
Open
(
nsIFilePickerShownCallback
*
aCallback
)
{
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
nsresult
:
:
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoString
initialDir
;
if
(
mDisplayDirectory
)
mDisplayDirectory
-
>
GetPath
(
initialDir
)
;
if
(
initialDir
.
IsEmpty
(
)
)
{
initialDir
=
sLastUsedUnicodeDirectory
.
get
(
)
;
}
ClearFiles
(
)
;
auto
promise
=
mMode
=
=
modeGetFolder
?
ShowFolderPicker
(
initialDir
)
:
ShowFilePicker
(
initialDir
)
;
auto
p2
=
promise
-
>
Then
(
mozilla
:
:
GetMainThreadSerialEventTarget
(
)
__PRETTY_FUNCTION__
[
self
=
RefPtr
(
this
)
callback
=
RefPtr
(
aCallback
)
]
(
bool
selectionMade
)
-
>
void
{
if
(
!
selectionMade
)
{
callback
-
>
Done
(
ResultCode
:
:
returnCancel
)
;
return
;
}
self
-
>
RememberLastUsedDirectory
(
)
;
nsIFilePicker
:
:
ResultCode
retValue
=
ResultCode
:
:
returnOK
;
if
(
self
-
>
mMode
=
=
modeSave
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
self
-
>
mUnicodeFile
false
getter_AddRefs
(
file
)
)
;
bool
flag
=
false
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
file
-
>
Exists
(
&
flag
)
)
&
&
flag
)
{
retValue
=
ResultCode
:
:
returnReplace
;
}
}
callback
-
>
Done
(
retValue
)
;
}
[
callback
=
RefPtr
(
aCallback
)
]
(
HRESULT
err
)
{
using
mozilla
:
:
widget
:
:
filedialog
:
:
sLogFileDialog
;
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Error
(
"
nsFilePicker
:
Show
failed
with
hr
=
0x
%
08lX
"
err
)
)
;
callback
-
>
Done
(
ResultCode
:
:
returnCancel
)
;
}
)
;
return
NS_OK
;
}
nsresult
nsFilePicker
:
:
Show
(
nsIFilePicker
:
:
ResultCode
*
aReturnVal
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFile
(
nsIFile
*
*
aFile
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
*
aFile
=
nullptr
;
if
(
mUnicodeFile
.
IsEmpty
(
)
)
return
NS_OK
;
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
mUnicodeFile
false
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
file
.
forget
(
aFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFileURL
(
nsIURI
*
*
aFileURL
)
{
*
aFileURL
=
nullptr
;
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
return
rv
;
return
NS_NewFileURI
(
aFileURL
file
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFiles
(
nsISimpleEnumerator
*
*
aFiles
)
{
NS_ENSURE_ARG_POINTER
(
aFiles
)
;
return
NS_NewArrayEnumerator
(
aFiles
mFiles
NS_GET_IID
(
nsIFile
)
)
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
SetDefaultString
(
const
nsAString
&
aString
)
{
mDefaultFilePath
=
aString
;
int32_t
nameLength
;
int32_t
nameIndex
=
mDefaultFilePath
.
RFind
(
u
"
\
\
"
)
;
if
(
nameIndex
=
=
kNotFound
)
nameIndex
=
0
;
else
nameIndex
+
+
;
nameLength
=
mDefaultFilePath
.
Length
(
)
-
nameIndex
;
mDefaultFilename
.
Assign
(
Substring
(
mDefaultFilePath
nameIndex
)
)
;
if
(
nameLength
>
MAX_PATH
)
{
int32_t
extIndex
=
mDefaultFilePath
.
RFind
(
u
"
.
"
)
;
if
(
extIndex
=
=
kNotFound
)
extIndex
=
mDefaultFilePath
.
Length
(
)
;
int32_t
charsToRemove
=
nameLength
-
MAX_PATH
;
if
(
extIndex
-
nameIndex
>
=
charsToRemove
)
{
mDefaultFilePath
.
Cut
(
extIndex
-
charsToRemove
charsToRemove
)
;
}
}
mDefaultFilePath
.
ReplaceChar
(
u
"
"
FILE_ILLEGAL_CHARACTERS
u
'
-
'
)
;
mDefaultFilename
.
ReplaceChar
(
u
"
"
FILE_ILLEGAL_CHARACTERS
u
'
-
'
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
GetDefaultString
(
nsAString
&
aString
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
GetDefaultExtension
(
nsAString
&
aExtension
)
{
aExtension
=
mDefaultExtension
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
SetDefaultExtension
(
const
nsAString
&
aExtension
)
{
mDefaultExtension
=
aExtension
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFilterIndex
(
int32_t
*
aFilterIndex
)
{
*
aFilterIndex
=
mSelectedType
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
SetFilterIndex
(
int32_t
aFilterIndex
)
{
mSelectedType
=
aFilterIndex
+
1
;
return
NS_OK
;
}
void
nsFilePicker
:
:
InitNative
(
nsIWidget
*
aParent
const
nsAString
&
aTitle
)
{
mParentWidget
=
aParent
;
mTitle
.
Assign
(
aTitle
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
AppendFilter
(
const
nsAString
&
aTitle
const
nsAString
&
aFilter
)
{
nsString
sanitizedFilter
(
aFilter
)
;
sanitizedFilter
.
ReplaceChar
(
'
%
'
'
_
'
)
;
if
(
sanitizedFilter
=
=
u
"
.
.
apps
"
_ns
)
{
sanitizedFilter
=
u
"
*
.
exe
;
*
.
com
"
_ns
;
}
else
{
sanitizedFilter
.
StripWhitespace
(
)
;
if
(
sanitizedFilter
=
=
u
"
*
"
_ns
)
{
sanitizedFilter
=
u
"
*
.
*
"
_ns
;
}
}
mFilterList
.
AppendElement
(
Filter
{
.
title
=
nsString
(
aTitle
)
.
filter
=
std
:
:
move
(
sanitizedFilter
)
}
)
;
return
NS_OK
;
}
void
nsFilePicker
:
:
RememberLastUsedDirectory
(
)
{
if
(
IsPrivacyModeEnabled
(
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_FAILED
(
NS_NewLocalFile
(
mUnicodeFile
false
getter_AddRefs
(
file
)
)
)
)
{
NS_WARNING
(
"
RememberLastUsedDirectory
failed
to
init
file
path
.
"
)
;
return
;
}
nsCOMPtr
<
nsIFile
>
dir
;
nsAutoString
newDir
;
if
(
NS_FAILED
(
file
-
>
GetParent
(
getter_AddRefs
(
dir
)
)
)
|
|
!
(
mDisplayDirectory
=
dir
)
|
|
NS_FAILED
(
mDisplayDirectory
-
>
GetPath
(
newDir
)
)
|
|
newDir
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
RememberLastUsedDirectory
failed
to
get
parent
directory
.
"
)
;
return
;
}
sLastUsedUnicodeDirectory
.
reset
(
ToNewUnicode
(
newDir
)
)
;
}
bool
nsFilePicker
:
:
IsPrivacyModeEnabled
(
)
{
return
mLoadContext
&
&
mLoadContext
-
>
UsePrivateBrowsing
(
)
;
}
bool
nsFilePicker
:
:
IsDefaultPathLink
(
)
{
NS_ConvertUTF16toUTF8
ext
(
mDefaultFilePath
)
;
ext
.
Trim
(
"
.
"
false
true
)
;
ToLowerCase
(
ext
)
;
return
StringEndsWith
(
ext
"
.
lnk
"
_ns
)
|
|
StringEndsWith
(
ext
"
.
pif
"
_ns
)
|
|
StringEndsWith
(
ext
"
.
url
"
_ns
)
;
}
bool
nsFilePicker
:
:
IsDefaultPathHtml
(
)
{
int32_t
extIndex
=
mDefaultFilePath
.
RFind
(
u
"
.
"
)
;
if
(
extIndex
>
=
0
)
{
nsAutoString
ext
;
mDefaultFilePath
.
Right
(
ext
mDefaultFilePath
.
Length
(
)
-
extIndex
)
;
if
(
ext
.
LowerCaseEqualsLiteral
(
"
.
htm
"
)
|
|
ext
.
LowerCaseEqualsLiteral
(
"
.
html
"
)
|
|
ext
.
LowerCaseEqualsLiteral
(
"
.
shtml
"
)
)
return
true
;
}
return
false
;
}
