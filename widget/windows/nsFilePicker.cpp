#
include
"
nsFilePicker
.
h
"
#
include
<
shlobj
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
cderr
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsEnumeratorUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
widget
/
filedialog
/
WinFileDialogCommands
.
h
"
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
Result
;
using
mozilla
:
:
UniquePtr
;
using
namespace
mozilla
:
:
widget
;
UniquePtr
<
char16_t
[
]
nsFilePicker
:
:
FreeDeleter
>
nsFilePicker
:
:
sLastUsedUnicodeDirectory
;
#
define
MAX_EXTENSION_LENGTH
10
class
AutoWidgetPickerState
{
public
:
explicit
AutoWidgetPickerState
(
nsIWidget
*
aWidget
)
:
mWindow
(
static_cast
<
nsWindow
*
>
(
aWidget
)
)
{
PickerState
(
true
)
;
}
~
AutoWidgetPickerState
(
)
{
PickerState
(
false
)
;
}
private
:
void
PickerState
(
bool
aFlag
)
{
if
(
mWindow
)
{
if
(
aFlag
)
mWindow
-
>
PickerOpen
(
)
;
else
mWindow
-
>
PickerClosed
(
)
;
}
}
RefPtr
<
nsWindow
>
mWindow
;
}
;
nsFilePicker
:
:
nsFilePicker
(
)
:
mSelectedType
(
1
)
{
}
NS_IMPL_ISUPPORTS
(
nsFilePicker
nsIFilePicker
)
NS_IMETHODIMP
nsFilePicker
:
:
Init
(
mozIDOMWindowProxy
*
aParent
const
nsAString
&
aTitle
nsIFilePicker
:
:
Mode
aMode
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
do_QueryInterface
(
aParent
)
;
nsIDocShell
*
docShell
=
window
?
window
-
>
GetDocShell
(
)
:
nullptr
;
mLoadContext
=
do_QueryInterface
(
docShell
)
;
return
nsBaseFilePicker
:
:
Init
(
aParent
aTitle
aMode
)
;
}
Result
<
Maybe
<
filedialog
:
:
Results
>
HRESULT
>
nsFilePicker
:
:
ShowFilePickerLocal
(
HWND
parent
filedialog
:
:
FileDialogType
type
nsTArray
<
filedialog
:
:
Command
>
const
&
commands
)
{
using
mozilla
:
:
Err
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
namespace
fd
=
filedialog
;
RefPtr
<
IFileDialog
>
dialog
;
MOZ_TRY_VAR
(
dialog
fd
:
:
MakeFileDialog
(
type
)
)
;
if
(
auto
const
res
=
fd
:
:
ApplyCommands
(
dialog
.
get
(
)
commands
)
;
FAILED
(
res
)
)
{
return
Err
(
res
)
;
}
auto
const
ret
=
dialog
-
>
Show
(
parent
)
;
if
(
ret
=
=
HRESULT_FROM_WIN32
(
ERROR_CANCELLED
)
)
{
return
Maybe
<
fd
:
:
Results
>
(
Nothing
(
)
)
;
}
if
(
FAILED
(
ret
)
)
{
return
Err
(
ret
)
;
}
return
fd
:
:
GetFileResults
(
dialog
.
get
(
)
)
.
map
(
mozilla
:
:
Some
<
fd
:
:
Results
>
)
;
}
Result
<
Maybe
<
nsString
>
HRESULT
>
nsFilePicker
:
:
ShowFolderPickerLocal
(
HWND
parent
nsTArray
<
filedialog
:
:
Command
>
const
&
commands
)
{
using
mozilla
:
:
Err
;
using
mozilla
:
:
Nothing
;
using
mozilla
:
:
Some
;
namespace
fd
=
filedialog
;
RefPtr
<
IFileDialog
>
dialog
;
MOZ_TRY_VAR
(
dialog
fd
:
:
MakeFileDialog
(
fd
:
:
FileDialogType
:
:
Open
)
)
;
if
(
auto
const
res
=
fd
:
:
ApplyCommands
(
dialog
.
get
(
)
commands
)
;
FAILED
(
res
)
)
{
return
Err
(
res
)
;
}
auto
const
ret
=
dialog
-
>
Show
(
parent
)
;
if
(
ret
=
=
HRESULT_FROM_WIN32
(
ERROR_CANCELLED
)
)
{
return
Maybe
<
nsString
>
(
Nothing
(
)
)
;
}
if
(
FAILED
(
ret
)
)
{
return
Err
(
ret
)
;
}
return
fd
:
:
GetFolderResults
(
dialog
.
get
(
)
)
.
map
(
mozilla
:
:
Some
<
nsString
>
)
;
}
bool
nsFilePicker
:
:
ShowFolderPicker
(
const
nsString
&
aInitialDir
)
{
namespace
fd
=
:
:
mozilla
:
:
widget
:
:
filedialog
;
nsTArray
<
fd
:
:
Command
>
commands
=
{
fd
:
:
SetOptions
(
FOS_PICKFOLDERS
)
fd
:
:
SetTitle
(
mTitle
)
}
;
if
(
!
mOkButtonLabel
.
IsEmpty
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetOkButtonLabel
(
mOkButtonLabel
)
)
;
}
if
(
!
aInitialDir
.
IsEmpty
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetFolder
(
aInitialDir
)
)
;
}
nsString
result
;
{
ScopedRtlShimWindow
shim
(
mParentWidget
.
get
(
)
)
;
AutoWidgetPickerState
awps
(
mParentWidget
)
;
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
auto
res
=
ShowFolderPickerLocal
(
shim
.
get
(
)
commands
)
;
if
(
res
.
isErr
(
)
)
{
NS_WARNING
(
"
ShowFolderPickerImpl
failed
"
)
;
return
false
;
}
auto
optResults
=
res
.
unwrap
(
)
;
if
(
!
optResults
)
{
return
false
;
}
result
=
optResults
.
extract
(
)
;
}
mUnicodeFile
=
result
;
return
true
;
}
bool
nsFilePicker
:
:
ShowFilePicker
(
const
nsString
&
aInitialDir
)
{
AUTO_PROFILER_LABEL
(
"
nsFilePicker
:
:
ShowFilePicker
"
OTHER
)
;
namespace
fd
=
:
:
mozilla
:
:
widget
:
:
filedialog
;
nsTArray
<
fd
:
:
Command
>
commands
;
{
FILEOPENDIALOGOPTIONS
fos
=
0
;
fos
|
=
FOS_SHAREAWARE
|
FOS_OVERWRITEPROMPT
|
FOS_FORCEFILESYSTEM
;
if
(
IsPrivacyModeEnabled
(
)
|
|
!
mAddToRecentDocs
)
{
fos
|
=
FOS_DONTADDTORECENT
;
}
switch
(
mMode
)
{
case
modeOpen
:
fos
|
=
FOS_FILEMUSTEXIST
;
break
;
case
modeOpenMultiple
:
fos
|
=
FOS_FILEMUSTEXIST
|
FOS_ALLOWMULTISELECT
;
break
;
case
modeSave
:
fos
|
=
FOS_NOREADONLYRETURN
;
if
(
IsDefaultPathLink
(
)
)
fos
|
=
FOS_NODEREFERENCELINKS
;
break
;
case
modeGetFolder
:
MOZ_ASSERT
(
false
"
file
-
picker
opened
in
directory
-
picker
mode
"
)
;
return
false
;
}
commands
.
AppendElement
(
fd
:
:
SetOptions
(
fos
)
)
;
}
commands
.
AppendElement
(
fd
:
:
SetTitle
(
mTitle
)
)
;
if
(
!
mDefaultFilename
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedFilename
(
mDefaultFilename
)
;
sanitizedFilename
.
ReplaceChar
(
'
%
'
'
_
'
)
;
commands
.
AppendElement
(
fd
:
:
SetFileName
(
sanitizedFilename
)
)
;
}
if
(
!
mDefaultExtension
.
IsEmpty
(
)
)
{
nsAutoString
sanitizedExtension
(
mDefaultExtension
)
;
sanitizedExtension
.
ReplaceChar
(
'
%
'
'
_
'
)
;
commands
.
AppendElement
(
fd
:
:
SetDefaultExtension
(
sanitizedExtension
)
)
;
}
else
if
(
IsDefaultPathHtml
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetDefaultExtension
(
u
"
html
"
_ns
)
)
;
}
if
(
!
aInitialDir
.
IsEmpty
(
)
)
{
commands
.
AppendElement
(
fd
:
:
SetFolder
(
aInitialDir
)
)
;
}
if
(
!
mFilterList
.
IsEmpty
(
)
)
{
nsTArray
<
fd
:
:
ComDlgFilterSpec
>
fileTypes
;
for
(
auto
const
&
filter
:
mFilterList
)
{
fileTypes
.
EmplaceBack
(
filter
.
title
filter
.
filter
)
;
}
commands
.
AppendElement
(
fd
:
:
SetFileTypes
(
std
:
:
move
(
fileTypes
)
)
)
;
commands
.
AppendElement
(
fd
:
:
SetFileTypeIndex
(
mSelectedType
)
)
;
}
fd
:
:
Results
result
;
{
ScopedRtlShimWindow
shim
(
mParentWidget
.
get
(
)
)
;
AutoWidgetPickerState
awps
(
mParentWidget
)
;
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
auto
res
=
ShowFilePickerLocal
(
shim
.
get
(
)
mMode
=
=
modeSave
?
FileDialogType
:
:
Save
:
FileDialogType
:
:
Open
commands
)
;
if
(
res
.
isErr
(
)
)
{
NS_WARNING
(
"
ShowFilePickerImpl
failed
"
)
;
return
false
;
}
auto
optResults
=
res
.
unwrap
(
)
;
if
(
!
optResults
)
{
return
false
;
}
result
=
optResults
.
extract
(
)
;
}
mSelectedType
=
int32_t
(
result
.
selectedFileTypeIndex
(
)
)
;
auto
const
&
paths
=
result
.
paths
(
)
;
if
(
mMode
!
=
modeOpenMultiple
)
{
if
(
!
paths
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
paths
.
Length
(
)
=
=
1
)
;
mUnicodeFile
=
paths
[
0
]
;
return
true
;
}
return
false
;
}
for
(
auto
const
&
str
:
paths
)
{
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_SUCCEEDED
(
NS_NewLocalFile
(
str
false
getter_AddRefs
(
file
)
)
)
)
{
mFiles
.
AppendObject
(
file
)
;
}
}
return
true
;
}
nsresult
nsFilePicker
:
:
ShowW
(
nsIFilePicker
:
:
ResultCode
*
aReturnVal
)
{
NS_ENSURE_ARG_POINTER
(
aReturnVal
)
;
*
aReturnVal
=
returnCancel
;
nsAutoString
initialDir
;
if
(
mDisplayDirectory
)
mDisplayDirectory
-
>
GetPath
(
initialDir
)
;
if
(
initialDir
.
IsEmpty
(
)
)
{
initialDir
=
sLastUsedUnicodeDirectory
.
get
(
)
;
}
mUnicodeFile
.
Truncate
(
)
;
mFiles
.
Clear
(
)
;
WinUtils
:
:
AutoSystemDpiAware
dpiAwareness
;
bool
result
=
false
;
if
(
mMode
=
=
modeGetFolder
)
{
result
=
ShowFolderPicker
(
initialDir
)
;
}
else
{
result
=
ShowFilePicker
(
initialDir
)
;
}
if
(
!
result
)
return
NS_OK
;
RememberLastUsedDirectory
(
)
;
nsIFilePicker
:
:
ResultCode
retValue
=
returnOK
;
if
(
mMode
=
=
modeSave
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
mUnicodeFile
false
getter_AddRefs
(
file
)
)
;
bool
flag
=
false
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
file
-
>
Exists
(
&
flag
)
)
&
&
flag
)
{
retValue
=
returnReplace
;
}
}
*
aReturnVal
=
retValue
;
return
NS_OK
;
}
nsresult
nsFilePicker
:
:
Show
(
nsIFilePicker
:
:
ResultCode
*
aReturnVal
)
{
return
ShowW
(
aReturnVal
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFile
(
nsIFile
*
*
aFile
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
*
aFile
=
nullptr
;
if
(
mUnicodeFile
.
IsEmpty
(
)
)
return
NS_OK
;
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
mUnicodeFile
false
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
file
.
forget
(
aFile
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFileURL
(
nsIURI
*
*
aFileURL
)
{
*
aFileURL
=
nullptr
;
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
!
file
)
return
rv
;
return
NS_NewFileURI
(
aFileURL
file
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFiles
(
nsISimpleEnumerator
*
*
aFiles
)
{
NS_ENSURE_ARG_POINTER
(
aFiles
)
;
return
NS_NewArrayEnumerator
(
aFiles
mFiles
NS_GET_IID
(
nsIFile
)
)
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
SetDefaultString
(
const
nsAString
&
aString
)
{
mDefaultFilePath
=
aString
;
int32_t
nameLength
;
int32_t
nameIndex
=
mDefaultFilePath
.
RFind
(
u
"
\
\
"
)
;
if
(
nameIndex
=
=
kNotFound
)
nameIndex
=
0
;
else
nameIndex
+
+
;
nameLength
=
mDefaultFilePath
.
Length
(
)
-
nameIndex
;
mDefaultFilename
.
Assign
(
Substring
(
mDefaultFilePath
nameIndex
)
)
;
if
(
nameLength
>
MAX_PATH
)
{
int32_t
extIndex
=
mDefaultFilePath
.
RFind
(
u
"
.
"
)
;
if
(
extIndex
=
=
kNotFound
)
extIndex
=
mDefaultFilePath
.
Length
(
)
;
int32_t
charsToRemove
=
nameLength
-
MAX_PATH
;
if
(
extIndex
-
nameIndex
>
=
charsToRemove
)
{
mDefaultFilePath
.
Cut
(
extIndex
-
charsToRemove
charsToRemove
)
;
}
}
mDefaultFilePath
.
ReplaceChar
(
u
"
"
FILE_ILLEGAL_CHARACTERS
u
'
-
'
)
;
mDefaultFilename
.
ReplaceChar
(
u
"
"
FILE_ILLEGAL_CHARACTERS
u
'
-
'
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
GetDefaultString
(
nsAString
&
aString
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
GetDefaultExtension
(
nsAString
&
aExtension
)
{
aExtension
=
mDefaultExtension
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseWinFilePicker
:
:
SetDefaultExtension
(
const
nsAString
&
aExtension
)
{
mDefaultExtension
=
aExtension
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFilterIndex
(
int32_t
*
aFilterIndex
)
{
*
aFilterIndex
=
mSelectedType
-
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
SetFilterIndex
(
int32_t
aFilterIndex
)
{
mSelectedType
=
aFilterIndex
+
1
;
return
NS_OK
;
}
void
nsFilePicker
:
:
InitNative
(
nsIWidget
*
aParent
const
nsAString
&
aTitle
)
{
mParentWidget
=
aParent
;
mTitle
.
Assign
(
aTitle
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
AppendFilter
(
const
nsAString
&
aTitle
const
nsAString
&
aFilter
)
{
nsString
sanitizedFilter
(
aFilter
)
;
sanitizedFilter
.
ReplaceChar
(
'
%
'
'
_
'
)
;
if
(
sanitizedFilter
=
=
u
"
.
.
apps
"
_ns
)
{
sanitizedFilter
=
u
"
*
.
exe
;
*
.
com
"
_ns
;
}
else
{
sanitizedFilter
.
StripWhitespace
(
)
;
if
(
sanitizedFilter
=
=
u
"
*
"
_ns
)
{
sanitizedFilter
=
u
"
*
.
*
"
_ns
;
}
}
mFilterList
.
AppendElement
(
Filter
{
.
title
=
nsString
(
aTitle
)
.
filter
=
std
:
:
move
(
sanitizedFilter
)
}
)
;
return
NS_OK
;
}
void
nsFilePicker
:
:
RememberLastUsedDirectory
(
)
{
if
(
IsPrivacyModeEnabled
(
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_FAILED
(
NS_NewLocalFile
(
mUnicodeFile
false
getter_AddRefs
(
file
)
)
)
)
{
NS_WARNING
(
"
RememberLastUsedDirectory
failed
to
init
file
path
.
"
)
;
return
;
}
nsCOMPtr
<
nsIFile
>
dir
;
nsAutoString
newDir
;
if
(
NS_FAILED
(
file
-
>
GetParent
(
getter_AddRefs
(
dir
)
)
)
|
|
!
(
mDisplayDirectory
=
dir
)
|
|
NS_FAILED
(
mDisplayDirectory
-
>
GetPath
(
newDir
)
)
|
|
newDir
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
RememberLastUsedDirectory
failed
to
get
parent
directory
.
"
)
;
return
;
}
sLastUsedUnicodeDirectory
.
reset
(
ToNewUnicode
(
newDir
)
)
;
}
bool
nsFilePicker
:
:
IsPrivacyModeEnabled
(
)
{
return
mLoadContext
&
&
mLoadContext
-
>
UsePrivateBrowsing
(
)
;
}
bool
nsFilePicker
:
:
IsDefaultPathLink
(
)
{
NS_ConvertUTF16toUTF8
ext
(
mDefaultFilePath
)
;
ext
.
Trim
(
"
.
"
false
true
)
;
ToLowerCase
(
ext
)
;
return
StringEndsWith
(
ext
"
.
lnk
"
_ns
)
|
|
StringEndsWith
(
ext
"
.
pif
"
_ns
)
|
|
StringEndsWith
(
ext
"
.
url
"
_ns
)
;
}
bool
nsFilePicker
:
:
IsDefaultPathHtml
(
)
{
int32_t
extIndex
=
mDefaultFilePath
.
RFind
(
u
"
.
"
)
;
if
(
extIndex
>
=
0
)
{
nsAutoString
ext
;
mDefaultFilePath
.
Right
(
ext
mDefaultFilePath
.
Length
(
)
-
extIndex
)
;
if
(
ext
.
LowerCaseEqualsLiteral
(
"
.
htm
"
)
|
|
ext
.
LowerCaseEqualsLiteral
(
"
.
html
"
)
|
|
ext
.
LowerCaseEqualsLiteral
(
"
.
shtml
"
)
)
return
true
;
}
return
false
;
}
