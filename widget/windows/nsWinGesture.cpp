#
include
"
nscore
.
h
"
#
include
"
nsWinGesture
.
h
"
#
include
"
nsUXThemeData
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
dom
/
SimpleGestureEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
WheelEventBinding
.
h
"
#
include
<
cmath
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
extern
mozilla
:
:
LazyLogModule
gWindowsLog
;
static
bool
gEnableSingleFingerPanEvents
=
false
;
nsWinGesture
:
:
nsWinGesture
(
)
:
mPanActive
(
false
)
mFeedbackActive
(
false
)
mXAxisFeedback
(
false
)
mYAxisFeedback
(
false
)
mPanInertiaActive
(
false
)
{
(
void
)
InitLibrary
(
)
;
mPixelScrollOverflow
=
0
;
}
bool
nsWinGesture
:
:
InitLibrary
(
)
{
gEnableSingleFingerPanEvents
=
Preferences
:
:
GetBool
(
"
gestures
.
enable_single_finger_input
"
false
)
;
return
true
;
}
#
define
GCOUNT
5
bool
nsWinGesture
:
:
SetWinGestureSupport
(
HWND
hWnd
WidgetGestureNotifyEvent
:
:
PanDirection
aDirection
)
{
GESTURECONFIG
config
[
GCOUNT
]
;
memset
(
&
config
0
sizeof
(
config
)
)
;
config
[
0
]
.
dwID
=
GID_ZOOM
;
config
[
0
]
.
dwWant
=
GC_ZOOM
;
config
[
0
]
.
dwBlock
=
0
;
config
[
1
]
.
dwID
=
GID_ROTATE
;
config
[
1
]
.
dwWant
=
GC_ROTATE
;
config
[
1
]
.
dwBlock
=
0
;
config
[
2
]
.
dwID
=
GID_PAN
;
config
[
2
]
.
dwWant
=
GC_PAN
|
GC_PAN_WITH_INERTIA
|
GC_PAN_WITH_GUTTER
;
config
[
2
]
.
dwBlock
=
GC_PAN_WITH_SINGLE_FINGER_VERTICALLY
|
GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY
;
if
(
gEnableSingleFingerPanEvents
)
{
if
(
aDirection
=
=
WidgetGestureNotifyEvent
:
:
ePanVertical
|
|
aDirection
=
=
WidgetGestureNotifyEvent
:
:
ePanBoth
)
{
config
[
2
]
.
dwWant
|
=
GC_PAN_WITH_SINGLE_FINGER_VERTICALLY
;
config
[
2
]
.
dwBlock
-
=
GC_PAN_WITH_SINGLE_FINGER_VERTICALLY
;
}
if
(
aDirection
=
=
WidgetGestureNotifyEvent
:
:
ePanHorizontal
|
|
aDirection
=
=
WidgetGestureNotifyEvent
:
:
ePanBoth
)
{
config
[
2
]
.
dwWant
|
=
GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY
;
config
[
2
]
.
dwBlock
-
=
GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY
;
}
}
config
[
3
]
.
dwWant
=
GC_TWOFINGERTAP
;
config
[
3
]
.
dwID
=
GID_TWOFINGERTAP
;
config
[
3
]
.
dwBlock
=
0
;
config
[
4
]
.
dwWant
=
GC_PRESSANDTAP
;
config
[
4
]
.
dwID
=
GID_PRESSANDTAP
;
config
[
4
]
.
dwBlock
=
0
;
return
SetGestureConfig
(
hWnd
0
GCOUNT
(
PGESTURECONFIG
)
&
config
sizeof
(
GESTURECONFIG
)
)
;
}
bool
nsWinGesture
:
:
IsPanEvent
(
LPARAM
lParam
)
{
GESTUREINFO
gi
;
ZeroMemory
(
&
gi
sizeof
(
GESTUREINFO
)
)
;
gi
.
cbSize
=
sizeof
(
GESTUREINFO
)
;
BOOL
result
=
GetGestureInfo
(
(
HGESTUREINFO
)
lParam
&
gi
)
;
if
(
!
result
)
return
false
;
if
(
gi
.
dwID
=
=
GID_PAN
)
return
true
;
return
false
;
}
bool
nsWinGesture
:
:
ProcessGestureMessage
(
HWND
hWnd
WPARAM
wParam
LPARAM
lParam
WidgetSimpleGestureEvent
&
evt
)
{
GESTUREINFO
gi
;
ZeroMemory
(
&
gi
sizeof
(
GESTUREINFO
)
)
;
gi
.
cbSize
=
sizeof
(
GESTUREINFO
)
;
BOOL
result
=
GetGestureInfo
(
(
HGESTUREINFO
)
lParam
&
gi
)
;
if
(
!
result
)
return
false
;
nsPointWin
coord
;
coord
=
gi
.
ptsLocation
;
coord
.
ScreenToClient
(
hWnd
)
;
evt
.
mRefPoint
=
LayoutDeviceIntPoint
(
coord
.
x
coord
.
y
)
;
switch
(
gi
.
dwID
)
{
case
GID_BEGIN
:
case
GID_END
:
return
false
;
break
;
case
GID_ZOOM
:
{
if
(
gi
.
dwFlags
&
GF_BEGIN
)
{
mZoomIntermediate
=
(
float
)
gi
.
ullArguments
;
evt
.
mMessage
=
eMagnifyGestureStart
;
evt
.
mDelta
=
0
.
0
;
}
else
if
(
gi
.
dwFlags
&
GF_END
)
{
evt
.
mMessage
=
eMagnifyGesture
;
evt
.
mDelta
=
-
1
.
0
*
(
mZoomIntermediate
-
(
float
)
gi
.
ullArguments
)
;
mZoomIntermediate
=
(
float
)
gi
.
ullArguments
;
}
else
{
evt
.
mMessage
=
eMagnifyGestureUpdate
;
evt
.
mDelta
=
-
1
.
0
*
(
mZoomIntermediate
-
(
float
)
gi
.
ullArguments
)
;
mZoomIntermediate
=
(
float
)
gi
.
ullArguments
;
}
}
break
;
case
GID_ROTATE
:
{
double
radians
=
0
.
0
;
if
(
gi
.
ullArguments
!
=
0
)
radians
=
GID_ROTATE_ANGLE_FROM_ARGUMENT
(
gi
.
ullArguments
)
;
double
degrees
=
-
1
*
radians
*
(
180
/
M_PI
)
;
if
(
gi
.
dwFlags
&
GF_BEGIN
)
{
degrees
=
mRotateIntermediate
=
0
.
0
;
}
evt
.
mDirection
=
0
;
evt
.
mDelta
=
degrees
-
mRotateIntermediate
;
mRotateIntermediate
=
degrees
;
if
(
evt
.
mDelta
>
0
)
{
evt
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_COUNTERCLOCKWISE
;
}
else
if
(
evt
.
mDelta
<
0
)
{
evt
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_CLOCKWISE
;
}
if
(
gi
.
dwFlags
&
GF_BEGIN
)
{
evt
.
mMessage
=
eRotateGestureStart
;
}
else
if
(
gi
.
dwFlags
&
GF_END
)
{
evt
.
mMessage
=
eRotateGesture
;
}
else
{
evt
.
mMessage
=
eRotateGestureUpdate
;
}
}
break
;
case
GID_TWOFINGERTAP
:
evt
.
mMessage
=
eTapGesture
;
evt
.
mClickCount
=
1
;
break
;
case
GID_PRESSANDTAP
:
evt
.
mMessage
=
ePressTapGesture
;
evt
.
mClickCount
=
1
;
break
;
}
return
true
;
}
bool
nsWinGesture
:
:
ProcessPanMessage
(
HWND
hWnd
WPARAM
wParam
LPARAM
lParam
)
{
GESTUREINFO
gi
;
ZeroMemory
(
&
gi
sizeof
(
GESTUREINFO
)
)
;
gi
.
cbSize
=
sizeof
(
GESTUREINFO
)
;
BOOL
result
=
GetGestureInfo
(
(
HGESTUREINFO
)
lParam
&
gi
)
;
if
(
!
result
)
return
false
;
nsPointWin
coord
;
coord
=
mPanRefPoint
=
gi
.
ptsLocation
;
mPanRefPoint
.
ScreenToClient
(
hWnd
)
;
switch
(
gi
.
dwID
)
{
case
GID_BEGIN
:
case
GID_END
:
return
false
;
break
;
case
GID_PAN
:
{
if
(
gi
.
dwFlags
&
GF_BEGIN
)
{
mPanIntermediate
=
coord
;
mPixelScrollDelta
=
0
;
mPanActive
=
true
;
mPanInertiaActive
=
false
;
}
else
{
#
ifdef
DBG_jimm
int32_t
deltaX
=
mPanIntermediate
.
x
-
coord
.
x
;
int32_t
deltaY
=
mPanIntermediate
.
y
-
coord
.
y
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
coordX
=
%
d
coordY
=
%
d
deltaX
=
%
d
deltaY
=
%
d
x
:
%
d
y
:
%
d
\
n
"
coord
.
x
coord
.
y
deltaX
deltaY
mXAxisFeedback
mYAxisFeedback
)
)
;
#
endif
mPixelScrollDelta
.
x
=
mPanIntermediate
.
x
-
coord
.
x
;
mPixelScrollDelta
.
y
=
mPanIntermediate
.
y
-
coord
.
y
;
mPanIntermediate
=
coord
;
if
(
gi
.
dwFlags
&
GF_INERTIA
)
mPanInertiaActive
=
true
;
if
(
gi
.
dwFlags
&
GF_END
)
{
mPanActive
=
false
;
mPanInertiaActive
=
false
;
PanFeedbackFinalize
(
hWnd
true
)
;
}
}
}
break
;
}
return
true
;
}
inline
bool
TestTransition
(
int32_t
a
int32_t
b
)
{
if
(
a
=
=
0
|
|
b
=
=
0
)
return
true
;
return
(
a
<
0
)
=
=
(
b
<
0
)
;
}
void
nsWinGesture
:
:
UpdatePanFeedbackX
(
HWND
hWnd
int32_t
scrollOverflow
bool
&
endFeedback
)
{
if
(
scrollOverflow
!
=
0
)
{
if
(
!
mFeedbackActive
)
{
BeginPanningFeedback
(
hWnd
)
;
mFeedbackActive
=
true
;
}
endFeedback
=
false
;
mXAxisFeedback
=
true
;
return
;
}
if
(
mXAxisFeedback
)
{
int32_t
newOverflow
=
mPixelScrollOverflow
.
x
-
mPixelScrollDelta
.
x
;
if
(
!
TestTransition
(
newOverflow
mPixelScrollOverflow
.
x
)
|
|
newOverflow
=
=
0
)
return
;
mPixelScrollOverflow
.
x
=
newOverflow
;
endFeedback
=
false
;
}
}
void
nsWinGesture
:
:
UpdatePanFeedbackY
(
HWND
hWnd
int32_t
scrollOverflow
bool
&
endFeedback
)
{
if
(
scrollOverflow
!
=
0
)
{
if
(
!
mFeedbackActive
)
{
BeginPanningFeedback
(
hWnd
)
;
mFeedbackActive
=
true
;
}
endFeedback
=
false
;
mYAxisFeedback
=
true
;
return
;
}
if
(
mYAxisFeedback
)
{
int32_t
newOverflow
=
mPixelScrollOverflow
.
y
-
mPixelScrollDelta
.
y
;
if
(
!
TestTransition
(
newOverflow
mPixelScrollOverflow
.
y
)
|
|
newOverflow
=
=
0
)
return
;
mPixelScrollOverflow
.
y
=
newOverflow
;
endFeedback
=
false
;
}
}
void
nsWinGesture
:
:
PanFeedbackFinalize
(
HWND
hWnd
bool
endFeedback
)
{
if
(
!
mFeedbackActive
)
return
;
if
(
endFeedback
)
{
mFeedbackActive
=
false
;
mXAxisFeedback
=
false
;
mYAxisFeedback
=
false
;
mPixelScrollOverflow
=
0
;
EndPanningFeedback
(
hWnd
TRUE
)
;
return
;
}
UpdatePanningFeedback
(
hWnd
mPixelScrollOverflow
.
x
mPixelScrollOverflow
.
y
mPanInertiaActive
)
;
}
bool
nsWinGesture
:
:
PanDeltaToPixelScroll
(
WidgetWheelEvent
&
aWheelEvent
)
{
aWheelEvent
.
mDeltaX
=
aWheelEvent
.
mDeltaY
=
aWheelEvent
.
mDeltaZ
=
0
.
0
;
aWheelEvent
.
mLineOrPageDeltaX
=
aWheelEvent
.
mLineOrPageDeltaY
=
0
;
aWheelEvent
.
mRefPoint
=
LayoutDeviceIntPoint
(
mPanRefPoint
.
x
mPanRefPoint
.
y
)
;
aWheelEvent
.
mDeltaMode
=
dom
:
:
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
;
aWheelEvent
.
mScrollType
=
WidgetWheelEvent
:
:
SCROLL_SYNCHRONOUSLY
;
aWheelEvent
.
mIsNoLineOrPageDelta
=
true
;
aWheelEvent
.
mOverflowDeltaX
=
0
.
0
;
aWheelEvent
.
mOverflowDeltaY
=
0
.
0
;
if
(
!
mXAxisFeedback
)
{
aWheelEvent
.
mDeltaX
=
mPixelScrollDelta
.
x
;
}
if
(
!
mYAxisFeedback
)
{
aWheelEvent
.
mDeltaY
=
mPixelScrollDelta
.
y
;
}
return
(
aWheelEvent
.
mDeltaX
!
=
0
|
|
aWheelEvent
.
mDeltaY
!
=
0
)
;
}
