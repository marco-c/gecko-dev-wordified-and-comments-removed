#
include
"
WinCompositorWidget
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
VsyncDispatcher
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
widget
/
PlatformWidgetTypes
.
h
"
namespace
mozilla
{
namespace
widget
{
using
namespace
mozilla
:
:
gfx
;
RefPtr
<
CompositorWidget
>
CompositorWidget
:
:
CreateLocal
(
const
CompositorWidgetInitData
&
aInitData
nsIWidget
*
aWidget
)
{
return
new
WinCompositorWidget
(
aInitData
static_cast
<
nsWindow
*
>
(
aWidget
)
)
;
}
WinCompositorWidget
:
:
WinCompositorWidget
(
const
CompositorWidgetInitData
&
aInitData
nsWindow
*
aWindow
)
:
mWindow
(
aWindow
)
mWidgetKey
(
aInitData
.
widgetKey
(
)
)
mWnd
(
reinterpret_cast
<
HWND
>
(
aInitData
.
hWnd
(
)
)
)
mTransparencyMode
(
static_cast
<
nsTransparencyMode
>
(
aInitData
.
transparencyMode
(
)
)
)
mMemoryDC
(
nullptr
)
mCompositeDC
(
nullptr
)
mLockedBackBufferData
(
nullptr
)
{
MOZ_ASSERT
(
mWnd
&
&
:
:
IsWindow
(
mWnd
)
)
;
}
void
WinCompositorWidget
:
:
OnDestroyWindow
(
)
{
mTransparentSurface
=
nullptr
;
mMemoryDC
=
nullptr
;
}
bool
WinCompositorWidget
:
:
PreRender
(
layers
:
:
LayerManagerComposite
*
aManager
)
{
mPresentLock
.
Enter
(
)
;
return
true
;
}
void
WinCompositorWidget
:
:
PostRender
(
layers
:
:
LayerManagerComposite
*
aManager
)
{
mPresentLock
.
Leave
(
)
;
}
nsIWidget
*
WinCompositorWidget
:
:
RealWidget
(
)
{
MOZ_ASSERT
(
mWindow
)
;
return
mWindow
;
}
LayoutDeviceIntSize
WinCompositorWidget
:
:
GetClientSize
(
)
{
RECT
r
;
if
(
!
:
:
GetClientRect
(
mWnd
&
r
)
)
{
return
LayoutDeviceIntSize
(
)
;
}
return
LayoutDeviceIntSize
(
r
.
right
-
r
.
left
r
.
bottom
-
r
.
top
)
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
WinCompositorWidget
:
:
StartRemoteDrawing
(
)
{
MOZ_ASSERT
(
!
mCompositeDC
)
;
RefPtr
<
gfxASurface
>
surf
;
if
(
mTransparencyMode
=
=
eTransparencyTransparent
)
{
surf
=
EnsureTransparentSurface
(
)
;
}
HDC
dc
=
GetWindowSurface
(
)
;
if
(
!
surf
)
{
if
(
!
dc
)
{
return
nullptr
;
}
uint32_t
flags
=
(
mTransparencyMode
=
=
eTransparencyOpaque
)
?
0
:
gfxWindowsSurface
:
:
FLAG_IS_TRANSPARENT
;
surf
=
new
gfxWindowsSurface
(
dc
flags
)
;
}
IntSize
size
=
surf
-
>
GetSize
(
)
;
if
(
size
.
width
<
=
0
|
|
size
.
height
<
=
0
)
{
if
(
dc
)
{
FreeWindowSurface
(
dc
)
;
}
return
nullptr
;
}
MOZ_ASSERT
(
!
mCompositeDC
)
;
mCompositeDC
=
dc
;
return
mozilla
:
:
gfx
:
:
Factory
:
:
CreateDrawTargetForCairoSurface
(
surf
-
>
CairoSurface
(
)
size
)
;
}
void
WinCompositorWidget
:
:
EndRemoteDrawing
(
)
{
MOZ_ASSERT
(
!
mLockedBackBufferData
)
;
if
(
mTransparencyMode
=
=
eTransparencyTransparent
)
{
MOZ_ASSERT
(
mTransparentSurface
)
;
RedrawTransparentWindow
(
)
;
}
if
(
mCompositeDC
)
{
FreeWindowSurface
(
mCompositeDC
)
;
}
mCompositeDC
=
nullptr
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
WinCompositorWidget
:
:
GetBackBufferDrawTarget
(
gfx
:
:
DrawTarget
*
aScreenTarget
const
LayoutDeviceIntRect
&
aRect
const
LayoutDeviceIntRect
&
aClearRect
)
{
MOZ_ASSERT
(
!
mLockedBackBufferData
)
;
RefPtr
<
gfx
:
:
DrawTarget
>
target
=
CompositorWidget
:
:
GetBackBufferDrawTarget
(
aScreenTarget
aRect
aClearRect
)
;
if
(
!
target
)
{
return
nullptr
;
}
MOZ_ASSERT
(
target
-
>
GetBackendType
(
)
=
=
BackendType
:
:
CAIRO
)
;
uint8_t
*
destData
;
IntSize
destSize
;
int32_t
destStride
;
SurfaceFormat
destFormat
;
if
(
!
target
-
>
LockBits
(
&
destData
&
destSize
&
destStride
&
destFormat
)
)
{
return
target
.
forget
(
)
;
}
RefPtr
<
gfx
:
:
DrawTarget
>
dataTarget
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
destData
destSize
destStride
destFormat
)
;
mLockedBackBufferData
=
destData
;
return
dataTarget
.
forget
(
)
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
WinCompositorWidget
:
:
EndBackBufferDrawing
(
)
{
if
(
mLockedBackBufferData
)
{
MOZ_ASSERT
(
mLastBackBuffer
)
;
mLastBackBuffer
-
>
ReleaseBits
(
mLockedBackBufferData
)
;
mLockedBackBufferData
=
nullptr
;
}
return
CompositorWidget
:
:
EndBackBufferDrawing
(
)
;
}
void
WinCompositorWidget
:
:
ObserveVsync
(
VsyncObserver
*
aObserver
)
{
RefPtr
<
CompositorVsyncDispatcher
>
cvd
=
mWindow
-
>
GetCompositorVsyncDispatcher
(
)
;
cvd
-
>
SetCompositorVsyncObserver
(
aObserver
)
;
}
uintptr_t
WinCompositorWidget
:
:
GetWidgetKey
(
)
{
return
mWidgetKey
;
}
void
WinCompositorWidget
:
:
EnterPresentLock
(
)
{
mPresentLock
.
Enter
(
)
;
}
void
WinCompositorWidget
:
:
LeavePresentLock
(
)
{
mPresentLock
.
Leave
(
)
;
}
RefPtr
<
gfxASurface
>
WinCompositorWidget
:
:
EnsureTransparentSurface
(
)
{
MOZ_ASSERT
(
mTransparencyMode
=
=
eTransparencyTransparent
)
;
if
(
!
mTransparentSurface
)
{
LayoutDeviceIntSize
size
=
GetClientSize
(
)
;
CreateTransparentSurface
(
IntSize
(
size
.
width
size
.
height
)
)
;
}
RefPtr
<
gfxASurface
>
surface
=
mTransparentSurface
;
return
surface
.
forget
(
)
;
}
void
WinCompositorWidget
:
:
CreateTransparentSurface
(
const
gfx
:
:
IntSize
&
aSize
)
{
MOZ_ASSERT
(
!
mTransparentSurface
&
&
!
mMemoryDC
)
;
RefPtr
<
gfxWindowsSurface
>
surface
=
new
gfxWindowsSurface
(
aSize
SurfaceFormat
:
:
A8R8G8B8_UINT32
)
;
mTransparentSurface
=
surface
;
mMemoryDC
=
surface
-
>
GetDC
(
)
;
}
void
WinCompositorWidget
:
:
UpdateTransparency
(
nsTransparencyMode
aMode
)
{
if
(
mTransparencyMode
=
=
aMode
)
{
return
;
}
mTransparencyMode
=
aMode
;
mTransparentSurface
=
nullptr
;
mMemoryDC
=
nullptr
;
if
(
mTransparencyMode
=
=
eTransparencyTransparent
)
{
EnsureTransparentSurface
(
)
;
}
}
void
WinCompositorWidget
:
:
ClearTransparentWindow
(
)
{
if
(
!
mTransparentSurface
)
{
return
;
}
IntSize
size
=
mTransparentSurface
-
>
GetSize
(
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForSurface
(
mTransparentSurface
size
)
;
drawTarget
-
>
ClearRect
(
Rect
(
0
0
size
.
width
size
.
height
)
)
;
RedrawTransparentWindow
(
)
;
}
void
WinCompositorWidget
:
:
ResizeTransparentWindow
(
const
gfx
:
:
IntSize
&
aSize
)
{
MOZ_ASSERT
(
mTransparencyMode
=
=
eTransparencyTransparent
)
;
if
(
mTransparentSurface
&
&
mTransparentSurface
-
>
GetSize
(
)
=
=
aSize
)
{
return
;
}
mTransparentSurface
=
nullptr
;
mMemoryDC
=
nullptr
;
CreateTransparentSurface
(
aSize
)
;
}
bool
WinCompositorWidget
:
:
RedrawTransparentWindow
(
)
{
MOZ_ASSERT
(
mTransparencyMode
=
=
eTransparencyTransparent
)
;
LayoutDeviceIntSize
size
=
GetClientSize
(
)
;
:
:
GdiFlush
(
)
;
BLENDFUNCTION
bf
=
{
AC_SRC_OVER
0
255
AC_SRC_ALPHA
}
;
SIZE
winSize
=
{
size
.
width
size
.
height
}
;
POINT
srcPos
=
{
0
0
}
;
HWND
hWnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
true
)
;
RECT
winRect
;
:
:
GetWindowRect
(
hWnd
&
winRect
)
;
return
!
!
:
:
UpdateLayeredWindow
(
hWnd
nullptr
(
POINT
*
)
&
winRect
&
winSize
mMemoryDC
&
srcPos
0
&
bf
ULW_ALPHA
)
;
}
HDC
WinCompositorWidget
:
:
GetWindowSurface
(
)
{
return
eTransparencyTransparent
=
=
mTransparencyMode
?
mMemoryDC
:
:
:
GetDC
(
mWnd
)
;
}
void
WinCompositorWidget
:
:
FreeWindowSurface
(
HDC
dc
)
{
if
(
eTransparencyTransparent
!
=
mTransparencyMode
)
:
:
ReleaseDC
(
mWnd
dc
)
;
}
}
}
