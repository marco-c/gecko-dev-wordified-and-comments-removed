#
include
"
PDFViaEMFPrintHelper
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
WindowsEMF
.
h
"
#
include
"
nsFileStreams
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
static
float
ComputeScaleFactor
(
int
aDCWidth
int
aDCHeight
int
aPageWidth
int
aPageHeight
)
{
MOZ_ASSERT
(
aPageWidth
!
=
0
&
&
aPageWidth
!
=
0
)
;
return
(
aDCWidth
>
=
aPageWidth
&
&
aDCHeight
>
=
aPageHeight
)
?
1
.
0
:
std
:
:
min
(
static_cast
<
float
>
(
aDCWidth
)
/
static_cast
<
float
>
(
aPageWidth
)
static_cast
<
float
>
(
aDCHeight
)
/
static_cast
<
float
>
(
aPageHeight
)
)
;
}
PDFViaEMFPrintHelper
:
:
PDFViaEMFPrintHelper
(
)
:
mPDFDoc
(
nullptr
)
mPrfile
(
nullptr
)
{
}
PDFViaEMFPrintHelper
:
:
~
PDFViaEMFPrintHelper
(
)
{
CloseDocument
(
)
;
}
nsresult
PDFViaEMFPrintHelper
:
:
OpenDocument
(
nsIFile
*
aFile
)
{
MOZ_ASSERT
(
aFile
)
;
if
(
mPDFDoc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
We
can
only
open
one
PDF
at
a
time
"
"
Use
CloseDocument
(
)
to
close
the
opened
file
"
"
before
calling
OpenDocument
(
)
"
)
;
return
NS_ERROR_FAILURE
;
}
AutoFDClose
prFileDesc
;
nsresult
rv
=
aFile
-
>
OpenNSPRFileDesc
(
PR_RDONLY
0
&
prFileDesc
.
rwget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
OpenDocument
(
FileDescriptor
(
FileDescriptor
:
:
PlatformHandleType
(
PR_FileDesc2NativeHandle
(
prFileDesc
)
)
)
)
;
}
nsresult
PDFViaEMFPrintHelper
:
:
OpenDocument
(
const
FileDescriptor
&
aFD
)
{
MOZ_ASSERT
(
!
mPrfile
"
Forget
to
call
CloseDocument
?
"
)
;
if
(
mPDFDoc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
We
can
only
open
one
PDF
at
a
time
"
"
Use
CloseDocument
(
)
to
close
the
opened
file
"
"
before
calling
OpenDocument
(
)
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_TRUE
(
CreatePDFiumEngineIfNeed
(
)
NS_ERROR_FAILURE
)
;
auto
rawFD
=
aFD
.
ClonePlatformHandle
(
)
;
PRFileDesc
*
prfile
=
PR_ImportFile
(
PROsfd
(
rawFD
.
release
(
)
)
)
;
NS_ENSURE_TRUE
(
prfile
NS_ERROR_FAILURE
)
;
mPDFDoc
=
mPDFiumEngine
-
>
LoadDocument
(
prfile
nullptr
)
;
if
(
!
mPDFDoc
)
{
PR_Close
(
prfile
)
;
return
NS_ERROR_FAILURE
;
}
mPrfile
=
prfile
;
return
NS_OK
;
}
bool
PDFViaEMFPrintHelper
:
:
RenderPageToDC
(
HDC
aDC
unsigned
int
aPageIndex
int
aPageWidth
int
aPageHeight
)
{
MOZ_ASSERT
(
aDC
&
&
mPDFDoc
)
;
MOZ_ASSERT
(
static_cast
<
int
>
(
aPageIndex
)
<
mPDFiumEngine
-
>
GetPageCount
(
mPDFDoc
)
)
;
if
(
aPageWidth
<
=
0
|
|
aPageHeight
<
=
0
)
{
return
false
;
}
FPDF_PAGE
pdfPage
=
mPDFiumEngine
-
>
LoadPage
(
mPDFDoc
aPageIndex
)
;
NS_ENSURE_TRUE
(
pdfPage
false
)
;
float
scaleFactor
=
ComputeScaleFactor
(
:
:
GetDeviceCaps
(
aDC
HORZRES
)
:
:
GetDeviceCaps
(
aDC
VERTRES
)
aPageWidth
aPageHeight
)
;
int
savedState
=
:
:
SaveDC
(
aDC
)
;
:
:
SetGraphicsMode
(
aDC
GM_ADVANCED
)
;
XFORM
xform
=
{
0
}
;
xform
.
eM11
=
xform
.
eM22
=
scaleFactor
;
:
:
ModifyWorldTransform
(
aDC
&
xform
MWT_LEFTMULTIPLY
)
;
:
:
IntersectClipRect
(
aDC
0
0
aPageWidth
aPageHeight
)
;
mPDFiumEngine
-
>
RenderPage
(
aDC
pdfPage
0
0
aPageWidth
aPageHeight
0
FPDF_ANNOT
|
FPDF_PRINTING
|
FPDF_NO_CATCH
)
;
mPDFiumEngine
-
>
ClosePage
(
pdfPage
)
;
:
:
RestoreDC
(
aDC
savedState
)
;
return
true
;
}
bool
PDFViaEMFPrintHelper
:
:
DrawPage
(
HDC
aPrinterDC
unsigned
int
aPageIndex
int
aPageWidth
int
aPageHeight
)
{
MOZ_ASSERT
(
aPrinterDC
)
;
if
(
!
mPDFDoc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Make
sure
OpenDocument
return
true
before
"
"
using
DrawPage
.
"
)
;
return
false
;
}
WindowsEMF
emf
;
bool
result
=
emf
.
InitForDrawing
(
)
;
NS_ENSURE_TRUE
(
result
false
)
;
result
=
RenderPageToDC
(
emf
.
GetDC
(
)
aPageIndex
aPageWidth
aPageHeight
)
;
NS_ENSURE_TRUE
(
result
false
)
;
RECT
printRect
=
{
0
0
aPageWidth
aPageHeight
}
;
result
=
emf
.
Playback
(
aPrinterDC
printRect
)
;
return
result
;
}
bool
PDFViaEMFPrintHelper
:
:
SavePageToFile
(
const
wchar_t
*
aFilePath
unsigned
int
aPageIndex
int
aPageWidth
int
aPageHeight
)
{
MOZ_ASSERT
(
aFilePath
)
;
if
(
!
mPDFDoc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Make
sure
OpenDocument
return
true
before
"
"
using
DrawPageToFile
.
"
)
;
return
false
;
}
WindowsEMF
emf
;
bool
result
=
emf
.
InitForDrawing
(
aFilePath
)
;
NS_ENSURE_TRUE
(
result
false
)
;
result
=
RenderPageToDC
(
emf
.
GetDC
(
)
aPageIndex
aPageWidth
aPageHeight
)
;
NS_ENSURE_TRUE
(
result
false
)
;
return
emf
.
SaveToFile
(
)
;
}
bool
PDFViaEMFPrintHelper
:
:
SavePageToBuffer
(
unsigned
int
aPageIndex
int
aPageWidth
int
aPageHeight
ipc
:
:
Shmem
&
aMem
mozilla
:
:
ipc
:
:
IShmemAllocator
*
aAllocator
)
{
MOZ_ASSERT
(
aAllocator
)
;
if
(
!
mPDFDoc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Make
sure
OpenDocument
return
true
before
"
"
using
DrawPageToFile
.
"
)
;
return
false
;
}
WindowsEMF
emf
;
bool
result
=
emf
.
InitForDrawing
(
)
;
NS_ENSURE_TRUE
(
result
false
)
;
result
=
RenderPageToDC
(
emf
.
GetDC
(
)
aPageIndex
aPageWidth
aPageHeight
)
;
NS_ENSURE_TRUE
(
result
false
)
;
UINT
emfSize
=
emf
.
GetEMFContentSize
(
)
;
NS_ENSURE_TRUE
(
emfSize
!
=
0
false
)
;
auto
shmType
=
ipc
:
:
SharedMemory
:
:
SharedMemoryType
:
:
TYPE_BASIC
;
result
=
aAllocator
-
>
AllocShmem
(
emfSize
shmType
&
aMem
)
;
NS_ENSURE_TRUE
(
result
false
)
;
if
(
!
emf
.
GetEMFContentBits
(
aMem
.
get
<
BYTE
>
(
)
)
)
{
aAllocator
-
>
DeallocShmem
(
aMem
)
;
return
false
;
;
}
return
true
;
}
void
PDFViaEMFPrintHelper
:
:
CloseDocument
(
)
{
if
(
mPDFDoc
)
{
mPDFiumEngine
-
>
CloseDocument
(
mPDFDoc
)
;
mPDFDoc
=
nullptr
;
}
if
(
mPrfile
)
{
PR_Close
(
mPrfile
)
;
mPrfile
=
nullptr
;
}
}
bool
PDFViaEMFPrintHelper
:
:
CreatePDFiumEngineIfNeed
(
)
{
if
(
!
mPDFiumEngine
)
{
mPDFiumEngine
=
PDFiumEngineShim
:
:
GetInstanceOrNull
(
)
;
MOZ_ASSERT
(
mPDFiumEngine
)
;
}
return
!
!
mPDFiumEngine
;
}
