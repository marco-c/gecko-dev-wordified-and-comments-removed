#
include
"
WinUtils
.
h
"
#
include
<
knownfolders
.
h
>
#
include
<
winioctl
.
h
>
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsWindowDefs
.
h
"
#
include
"
InputDeviceUtils
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
DisplayConfigWindows
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerThreadSleep
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
WindowsUIUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
prtime
.
h
"
#
ifdef
MOZ_PLACES
#
include
"
nsIFaviconService
.
h
"
#
endif
#
include
"
nsIDownloader
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
WinWindowOcclusionTracker
.
h
"
#
include
<
textstor
.
h
>
#
include
"
TSFTextStore
.
h
"
#
include
<
shellscalingapi
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
shlwapi
.
h
>
mozilla
:
:
LazyLogModule
gWindowsLog
(
"
Widget
"
)
;
#
define
LOG_E
(
.
.
.
)
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
__VA_ARGS__
)
)
#
define
LOG_D
(
.
.
.
)
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
widget
{
#
ifdef
MOZ_PLACES
NS_IMPL_ISUPPORTS
(
myDownloadObserver
nsIDownloadObserver
)
NS_IMPL_ISUPPORTS
(
AsyncFaviconDataReady
nsIFaviconDataCallback
)
#
endif
NS_IMPL_ISUPPORTS
(
AsyncEncodeAndWriteIcon
nsIRunnable
)
NS_IMPL_ISUPPORTS
(
AsyncDeleteAllFaviconsFromDisk
nsIRunnable
)
const
char
FaviconHelper
:
:
kJumpListCacheDir
[
]
=
"
jumpListCache
"
;
const
char
FaviconHelper
:
:
kShortcutCacheDir
[
]
=
"
shortcutCache
"
;
struct
CoTaskMemFreePolicy
{
void
operator
(
)
(
void
*
aPtr
)
{
:
:
CoTaskMemFree
(
aPtr
)
;
}
}
;
SetThreadDpiAwarenessContextProc
WinUtils
:
:
sSetThreadDpiAwarenessContext
=
NULL
;
EnableNonClientDpiScalingProc
WinUtils
:
:
sEnableNonClientDpiScaling
=
NULL
;
GetSystemMetricsForDpiProc
WinUtils
:
:
sGetSystemMetricsForDpi
=
NULL
;
bool
WinUtils
:
:
sHasPackageIdentity
=
false
;
using
GetDpiForWindowProc
=
UINT
(
WINAPI
*
)
(
HWND
)
;
static
GetDpiForWindowProc
sGetDpiForWindow
=
NULL
;
void
WinUtils
:
:
Initialize
(
)
{
if
(
!
IsWin32kLockedDown
(
)
)
{
HMODULE
user32Dll
=
:
:
GetModuleHandleW
(
L
"
user32
"
)
;
if
(
user32Dll
)
{
auto
getThreadDpiAwarenessContext
=
(
decltype
(
GetThreadDpiAwarenessContext
)
*
)
:
:
GetProcAddress
(
user32Dll
"
GetThreadDpiAwarenessContext
"
)
;
auto
areDpiAwarenessContextsEqual
=
(
decltype
(
AreDpiAwarenessContextsEqual
)
*
)
:
:
GetProcAddress
(
user32Dll
"
AreDpiAwarenessContextsEqual
"
)
;
if
(
getThreadDpiAwarenessContext
&
&
areDpiAwarenessContextsEqual
&
&
areDpiAwarenessContextsEqual
(
getThreadDpiAwarenessContext
(
)
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE
)
)
{
sEnableNonClientDpiScaling
=
(
EnableNonClientDpiScalingProc
)
:
:
GetProcAddress
(
user32Dll
"
EnableNonClientDpiScaling
"
)
;
sSetThreadDpiAwarenessContext
=
(
SetThreadDpiAwarenessContextProc
)
:
:
GetProcAddress
(
user32Dll
"
SetThreadDpiAwarenessContext
"
)
;
}
sGetSystemMetricsForDpi
=
(
GetSystemMetricsForDpiProc
)
:
:
GetProcAddress
(
user32Dll
"
GetSystemMetricsForDpi
"
)
;
sGetDpiForWindow
=
(
GetDpiForWindowProc
)
:
:
GetProcAddress
(
user32Dll
"
GetDpiForWindow
"
)
;
}
}
sHasPackageIdentity
=
mozilla
:
:
HasPackageIdentity
(
)
;
}
LRESULT
WINAPI
WinUtils
:
:
NonClientDpiScalingDefWindowProcW
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsWin32kLockedDown
(
)
)
;
if
(
msg
=
=
WM_NCCREATE
&
&
sEnableNonClientDpiScaling
)
{
sEnableNonClientDpiScaling
(
hWnd
)
;
}
return
:
:
DefWindowProcW
(
hWnd
msg
wParam
lParam
)
;
}
void
WinUtils
:
:
LogW
(
const
wchar_t
*
fmt
.
.
.
)
{
va_list
args
=
nullptr
;
if
(
!
lstrlenW
(
fmt
)
)
{
return
;
}
va_start
(
args
fmt
)
;
int
buflen
=
_vscwprintf
(
fmt
args
)
;
wchar_t
*
buffer
=
new
wchar_t
[
buflen
+
1
]
;
if
(
!
buffer
)
{
va_end
(
args
)
;
return
;
}
vswprintf
(
buffer
buflen
fmt
args
)
;
va_end
(
args
)
;
OutputDebugStringW
(
buffer
)
;
OutputDebugStringW
(
L
"
\
n
"
)
;
int
len
=
WideCharToMultiByte
(
CP_ACP
0
buffer
-
1
nullptr
0
nullptr
nullptr
)
;
if
(
len
)
{
char
*
utf8
=
new
char
[
len
]
;
if
(
WideCharToMultiByte
(
CP_ACP
0
buffer
-
1
utf8
len
nullptr
nullptr
)
>
0
)
{
printf
(
"
%
s
\
n
"
utf8
)
;
NS_ASSERTION
(
gWindowsLog
"
Called
WinUtils
Log
(
)
but
Widget
"
"
log
module
doesn
'
t
exist
!
"
)
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
"
%
s
"
utf8
)
)
;
}
delete
[
]
utf8
;
}
delete
[
]
buffer
;
}
void
WinUtils
:
:
Log
(
const
char
*
fmt
.
.
.
)
{
va_list
args
=
nullptr
;
if
(
!
strlen
(
fmt
)
)
{
return
;
}
va_start
(
args
fmt
)
;
int
buflen
=
_vscprintf
(
fmt
args
)
;
char
*
buffer
=
new
char
[
buflen
+
1
]
;
if
(
!
buffer
)
{
va_end
(
args
)
;
return
;
}
vsprintf
(
buffer
fmt
args
)
;
va_end
(
args
)
;
OutputDebugStringA
(
buffer
)
;
OutputDebugStringW
(
L
"
\
n
"
)
;
printf
(
"
%
s
\
n
"
buffer
)
;
NS_ASSERTION
(
gWindowsLog
"
Called
WinUtils
Log
(
)
but
Widget
"
"
log
module
doesn
'
t
exist
!
"
)
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
"
%
s
"
buffer
)
)
;
delete
[
]
buffer
;
}
float
WinUtils
:
:
SystemDPI
(
)
{
static
float
dpi
=
0
;
if
(
dpi
<
=
0
)
{
HDC
screenDC
=
GetDC
(
nullptr
)
;
dpi
=
GetDeviceCaps
(
screenDC
LOGPIXELSY
)
;
ReleaseDC
(
nullptr
screenDC
)
;
}
return
dpi
>
0
?
dpi
:
96
;
}
double
WinUtils
:
:
SystemScaleFactor
(
)
{
return
SystemDPI
(
)
/
96
.
0
;
}
typedef
HRESULT
(
WINAPI
*
GETDPIFORMONITORPROC
)
(
HMONITOR
MONITOR_DPI_TYPE
UINT
*
UINT
*
)
;
typedef
HRESULT
(
WINAPI
*
GETPROCESSDPIAWARENESSPROC
)
(
HANDLE
PROCESS_DPI_AWARENESS
*
)
;
GETDPIFORMONITORPROC
sGetDpiForMonitor
;
GETPROCESSDPIAWARENESSPROC
sGetProcessDpiAwareness
;
static
bool
SlowIsPerMonitorDPIAware
(
)
{
HMODULE
shcore
=
LoadLibraryEx
(
L
"
shcore
"
NULL
LOAD_LIBRARY_SEARCH_SYSTEM32
)
;
if
(
shcore
)
{
sGetDpiForMonitor
=
(
GETDPIFORMONITORPROC
)
GetProcAddress
(
shcore
"
GetDpiForMonitor
"
)
;
sGetProcessDpiAwareness
=
(
GETPROCESSDPIAWARENESSPROC
)
GetProcAddress
(
shcore
"
GetProcessDpiAwareness
"
)
;
}
PROCESS_DPI_AWARENESS
dpiAwareness
;
return
sGetDpiForMonitor
&
&
sGetProcessDpiAwareness
&
&
SUCCEEDED
(
sGetProcessDpiAwareness
(
GetCurrentProcess
(
)
&
dpiAwareness
)
)
&
&
dpiAwareness
=
=
PROCESS_PER_MONITOR_DPI_AWARE
;
}
bool
WinUtils
:
:
IsPerMonitorDPIAware
(
)
{
static
bool
perMonitorDPIAware
=
SlowIsPerMonitorDPIAware
(
)
;
return
perMonitorDPIAware
;
}
float
WinUtils
:
:
MonitorDPI
(
HMONITOR
aMonitor
)
{
if
(
IsPerMonitorDPIAware
(
)
)
{
UINT
dpiX
dpiY
=
96
;
sGetDpiForMonitor
(
aMonitor
?
aMonitor
:
GetPrimaryMonitor
(
)
MDT_EFFECTIVE_DPI
&
dpiX
&
dpiY
)
;
return
dpiY
;
}
return
SystemDPI
(
)
;
}
double
WinUtils
:
:
LogToPhysFactor
(
HMONITOR
aMonitor
)
{
return
MonitorDPI
(
aMonitor
)
/
96
.
0
;
}
int32_t
WinUtils
:
:
LogToPhys
(
HMONITOR
aMonitor
double
aValue
)
{
return
int32_t
(
NS_round
(
aValue
*
LogToPhysFactor
(
aMonitor
)
)
)
;
}
double
WinUtils
:
:
LogToPhysFactor
(
HWND
aWnd
)
{
HWND
ancestor
=
:
:
GetAncestor
(
aWnd
GA_ROOTOWNER
)
;
if
(
sGetDpiForWindow
)
{
UINT
dpi
=
sGetDpiForWindow
(
ancestor
?
ancestor
:
aWnd
)
;
if
(
dpi
>
0
)
{
return
static_cast
<
double
>
(
dpi
)
/
96
.
0
;
}
}
return
LogToPhysFactor
(
:
:
MonitorFromWindow
(
ancestor
?
ancestor
:
aWnd
MONITOR_DEFAULTTOPRIMARY
)
)
;
}
HMONITOR
WinUtils
:
:
GetPrimaryMonitor
(
)
{
const
POINT
pt
=
{
0
0
}
;
return
:
:
MonitorFromPoint
(
pt
MONITOR_DEFAULTTOPRIMARY
)
;
}
HMONITOR
WinUtils
:
:
MonitorFromRect
(
const
gfx
:
:
Rect
&
rect
)
{
double
dpiScale
=
IsPerMonitorDPIAware
(
)
?
1
.
0
:
LogToPhysFactor
(
GetPrimaryMonitor
(
)
)
;
RECT
globalWindowBounds
=
{
NSToIntRound
(
dpiScale
*
rect
.
X
(
)
)
NSToIntRound
(
dpiScale
*
rect
.
Y
(
)
)
NSToIntRound
(
dpiScale
*
(
rect
.
XMost
(
)
)
)
NSToIntRound
(
dpiScale
*
(
rect
.
YMost
(
)
)
)
}
;
return
:
:
MonitorFromRect
(
&
globalWindowBounds
MONITOR_DEFAULTTONEAREST
)
;
}
bool
WinUtils
:
:
HasSystemMetricsForDpi
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsWin32kLockedDown
(
)
)
;
return
(
sGetSystemMetricsForDpi
!
=
NULL
)
;
}
int
WinUtils
:
:
GetSystemMetricsForDpi
(
int
nIndex
UINT
dpi
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsWin32kLockedDown
(
)
)
;
if
(
HasSystemMetricsForDpi
(
)
)
{
return
sGetSystemMetricsForDpi
(
nIndex
dpi
)
;
}
else
{
double
scale
=
IsPerMonitorDPIAware
(
)
?
dpi
/
SystemDPI
(
)
:
1
.
0
;
return
NSToIntRound
(
:
:
GetSystemMetrics
(
nIndex
)
*
scale
)
;
}
}
gfx
:
:
MarginDouble
WinUtils
:
:
GetUnwriteableMarginsForDeviceInInches
(
HDC
aHdc
)
{
if
(
!
aHdc
)
{
return
gfx
:
:
MarginDouble
(
)
;
}
int
pixelsPerInchY
=
:
:
GetDeviceCaps
(
aHdc
LOGPIXELSY
)
;
int
marginTop
=
:
:
GetDeviceCaps
(
aHdc
PHYSICALOFFSETY
)
;
int
printableAreaHeight
=
:
:
GetDeviceCaps
(
aHdc
VERTRES
)
;
int
physicalHeight
=
:
:
GetDeviceCaps
(
aHdc
PHYSICALHEIGHT
)
;
double
marginTopInch
=
double
(
marginTop
)
/
pixelsPerInchY
;
double
printableAreaHeightInch
=
double
(
printableAreaHeight
)
/
pixelsPerInchY
;
double
physicalHeightInch
=
double
(
physicalHeight
)
/
pixelsPerInchY
;
double
marginBottomInch
=
physicalHeightInch
-
printableAreaHeightInch
-
marginTopInch
;
int
pixelsPerInchX
=
:
:
GetDeviceCaps
(
aHdc
LOGPIXELSX
)
;
int
marginLeft
=
:
:
GetDeviceCaps
(
aHdc
PHYSICALOFFSETX
)
;
int
printableAreaWidth
=
:
:
GetDeviceCaps
(
aHdc
HORZRES
)
;
int
physicalWidth
=
:
:
GetDeviceCaps
(
aHdc
PHYSICALWIDTH
)
;
double
marginLeftInch
=
double
(
marginLeft
)
/
pixelsPerInchX
;
double
printableAreaWidthInch
=
double
(
printableAreaWidth
)
/
pixelsPerInchX
;
double
physicalWidthInch
=
double
(
physicalWidth
)
/
pixelsPerInchX
;
double
marginRightInch
=
physicalWidthInch
-
printableAreaWidthInch
-
marginLeftInch
;
return
gfx
:
:
MarginDouble
(
marginTopInch
marginRightInch
marginBottomInch
marginLeftInch
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
LocalAccessible
*
WinUtils
:
:
GetRootAccessibleForHWND
(
HWND
aHwnd
)
{
nsWindow
*
window
=
GetNSWindowPtr
(
aHwnd
)
;
if
(
!
window
)
{
return
nullptr
;
}
return
window
-
>
GetAccessible
(
)
;
}
#
endif
bool
WinUtils
:
:
PeekMessage
(
LPMSG
aMsg
HWND
aWnd
UINT
aFirstMessage
UINT
aLastMessage
UINT
aOption
)
{
RefPtr
<
ITfMessagePump
>
msgPump
=
TSFTextStore
:
:
GetMessagePump
(
)
;
if
(
msgPump
)
{
BOOL
ret
=
FALSE
;
HRESULT
hr
=
msgPump
-
>
PeekMessageW
(
aMsg
aWnd
aFirstMessage
aLastMessage
aOption
&
ret
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
return
ret
;
}
return
:
:
PeekMessageW
(
aMsg
aWnd
aFirstMessage
aLastMessage
aOption
)
;
}
bool
WinUtils
:
:
GetMessage
(
LPMSG
aMsg
HWND
aWnd
UINT
aFirstMessage
UINT
aLastMessage
)
{
RefPtr
<
ITfMessagePump
>
msgPump
=
TSFTextStore
:
:
GetMessagePump
(
)
;
if
(
msgPump
)
{
BOOL
ret
=
FALSE
;
HRESULT
hr
=
msgPump
-
>
GetMessageW
(
aMsg
aWnd
aFirstMessage
aLastMessage
&
ret
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
return
ret
;
}
return
:
:
GetMessageW
(
aMsg
aWnd
aFirstMessage
aLastMessage
)
;
}
#
if
defined
(
ACCESSIBILITY
)
static
DWORD
GetWaitFlags
(
)
{
DWORD
result
=
MWMO_INPUTAVAILABLE
;
if
(
XRE_IsContentProcess
(
)
)
{
result
|
=
MWMO_ALERTABLE
;
}
return
result
;
}
#
endif
void
WinUtils
:
:
WaitForMessage
(
DWORD
aTimeoutMs
)
{
#
if
defined
(
ACCESSIBILITY
)
static
const
DWORD
waitFlags
=
GetWaitFlags
(
)
;
#
else
const
DWORD
waitFlags
=
MWMO_INPUTAVAILABLE
;
#
endif
const
DWORD
waitStart
=
:
:
GetTickCount
(
)
;
DWORD
elapsed
=
0
;
while
(
true
)
{
if
(
aTimeoutMs
!
=
INFINITE
)
{
elapsed
=
:
:
GetTickCount
(
)
-
waitStart
;
}
if
(
elapsed
>
=
aTimeoutMs
)
{
break
;
}
DWORD
result
;
{
AUTO_PROFILER_THREAD_SLEEP
;
result
=
:
:
MsgWaitForMultipleObjectsEx
(
0
NULL
aTimeoutMs
-
elapsed
MOZ_QS_ALLEVENT
waitFlags
)
;
}
NS_WARNING_ASSERTION
(
result
!
=
WAIT_FAILED
"
Wait
failed
"
)
;
if
(
result
=
=
WAIT_TIMEOUT
)
{
break
;
}
#
if
defined
(
ACCESSIBILITY
)
if
(
result
=
=
WAIT_IO_COMPLETION
)
{
if
(
NS_IsMainThread
(
)
)
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
}
continue
;
}
#
endif
bool
haveSentMessagesPending
=
(
HIWORD
(
:
:
GetQueueStatus
(
QS_SENDMESSAGE
)
)
&
QS_SENDMESSAGE
)
!
=
0
;
MSG
msg
=
{
0
}
;
if
(
haveSentMessagesPending
|
|
:
:
PeekMessageW
(
&
msg
nullptr
0
0
PM_NOREMOVE
)
)
{
break
;
}
:
:
SwitchToThread
(
)
;
}
}
HWND
WinUtils
:
:
GetTopLevelHWND
(
HWND
aWnd
bool
aStopIfNotChild
bool
aStopIfNotPopup
)
{
HWND
curWnd
=
aWnd
;
HWND
topWnd
=
nullptr
;
while
(
curWnd
)
{
topWnd
=
curWnd
;
if
(
aStopIfNotChild
)
{
DWORD_PTR
style
=
:
:
GetWindowLongPtrW
(
curWnd
GWL_STYLE
)
;
VERIFY_WINDOW_STYLE
(
style
)
;
if
(
!
(
style
&
WS_CHILD
)
)
break
;
}
HWND
upWnd
=
:
:
GetParent
(
curWnd
)
;
if
(
!
upWnd
&
&
!
aStopIfNotPopup
)
{
upWnd
=
:
:
GetWindow
(
curWnd
GW_OWNER
)
;
}
curWnd
=
upWnd
;
}
return
topWnd
;
}
static
nsTHashMap
<
HWND
nsWindow
*
>
sExtantNSWindows
;
void
WinUtils
:
:
SetNSWindowPtr
(
HWND
aWnd
nsWindow
*
aWindow
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
aWindow
)
{
sExtantNSWindows
.
Remove
(
aWnd
)
;
}
else
{
sExtantNSWindows
.
InsertOrUpdate
(
aWnd
aWindow
)
;
}
}
nsWindow
*
WinUtils
:
:
GetNSWindowPtr
(
HWND
aWnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
sExtantNSWindows
.
Get
(
aWnd
)
;
}
bool
WinUtils
:
:
IsOurProcessWindow
(
HWND
aWnd
)
{
if
(
!
aWnd
)
{
return
false
;
}
DWORD
processId
=
0
;
:
:
GetWindowThreadProcessId
(
aWnd
&
processId
)
;
return
(
processId
=
=
:
:
GetCurrentProcessId
(
)
)
;
}
HWND
WinUtils
:
:
FindOurProcessWindow
(
HWND
aWnd
)
{
for
(
HWND
wnd
=
:
:
GetParent
(
aWnd
)
;
wnd
;
wnd
=
:
:
GetParent
(
wnd
)
)
{
if
(
IsOurProcessWindow
(
wnd
)
)
{
return
wnd
;
}
}
return
nullptr
;
}
static
bool
IsPointInWindow
(
HWND
aWnd
const
POINT
&
aPointInScreen
)
{
RECT
bounds
;
if
(
!
:
:
GetWindowRect
(
aWnd
&
bounds
)
)
{
return
false
;
}
return
(
aPointInScreen
.
x
>
=
bounds
.
left
&
&
aPointInScreen
.
x
<
bounds
.
right
&
&
aPointInScreen
.
y
>
=
bounds
.
top
&
&
aPointInScreen
.
y
<
bounds
.
bottom
)
;
}
static
HWND
FindTopmostWindowAtPoint
(
HWND
aWnd
const
POINT
&
aPointInScreen
)
{
if
(
!
:
:
IsWindowVisible
(
aWnd
)
|
|
!
IsPointInWindow
(
aWnd
aPointInScreen
)
)
{
return
nullptr
;
}
HWND
childWnd
=
:
:
GetTopWindow
(
aWnd
)
;
while
(
childWnd
)
{
HWND
topmostWnd
=
FindTopmostWindowAtPoint
(
childWnd
aPointInScreen
)
;
if
(
topmostWnd
)
{
return
topmostWnd
;
}
childWnd
=
:
:
GetNextWindow
(
childWnd
GW_HWNDNEXT
)
;
}
return
aWnd
;
}
struct
FindOurWindowAtPointInfo
{
POINT
mInPointInScreen
;
HWND
mOutWnd
;
}
;
static
BOOL
CALLBACK
FindOurWindowAtPointCallback
(
HWND
aWnd
LPARAM
aLPARAM
)
{
if
(
!
WinUtils
:
:
IsOurProcessWindow
(
aWnd
)
)
{
return
TRUE
;
}
FindOurWindowAtPointInfo
*
info
=
reinterpret_cast
<
FindOurWindowAtPointInfo
*
>
(
aLPARAM
)
;
HWND
childWnd
=
FindTopmostWindowAtPoint
(
aWnd
info
-
>
mInPointInScreen
)
;
if
(
!
childWnd
)
{
return
TRUE
;
}
info
-
>
mOutWnd
=
childWnd
;
return
FALSE
;
}
HWND
WinUtils
:
:
FindOurWindowAtPoint
(
const
POINT
&
aPointInScreen
)
{
FindOurWindowAtPointInfo
info
;
info
.
mInPointInScreen
=
aPointInScreen
;
info
.
mOutWnd
=
nullptr
;
EnumWindows
(
FindOurWindowAtPointCallback
reinterpret_cast
<
LPARAM
>
(
&
info
)
)
;
return
info
.
mOutWnd
;
}
UINT
WinUtils
:
:
GetInternalMessage
(
UINT
aNativeMessage
)
{
switch
(
aNativeMessage
)
{
case
WM_MOUSEWHEEL
:
return
MOZ_WM_MOUSEVWHEEL
;
case
WM_MOUSEHWHEEL
:
return
MOZ_WM_MOUSEHWHEEL
;
case
WM_VSCROLL
:
return
MOZ_WM_VSCROLL
;
case
WM_HSCROLL
:
return
MOZ_WM_HSCROLL
;
default
:
return
aNativeMessage
;
}
}
UINT
WinUtils
:
:
GetNativeMessage
(
UINT
aInternalMessage
)
{
switch
(
aInternalMessage
)
{
case
MOZ_WM_MOUSEVWHEEL
:
return
WM_MOUSEWHEEL
;
case
MOZ_WM_MOUSEHWHEEL
:
return
WM_MOUSEHWHEEL
;
case
MOZ_WM_VSCROLL
:
return
WM_VSCROLL
;
case
MOZ_WM_HSCROLL
:
return
WM_HSCROLL
;
default
:
return
aInternalMessage
;
}
}
uint16_t
WinUtils
:
:
GetMouseInputSource
(
)
{
int32_t
inputSource
=
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
;
LPARAM
lParamExtraInfo
=
:
:
GetMessageExtraInfo
(
)
;
if
(
(
lParamExtraInfo
&
TABLET_INK_SIGNATURE
)
=
=
TABLET_INK_CHECK
)
{
inputSource
=
(
lParamExtraInfo
&
TABLET_INK_TOUCH
)
?
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
:
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
;
}
return
static_cast
<
uint16_t
>
(
inputSource
)
;
}
uint16_t
WinUtils
:
:
GetMousePointerID
(
)
{
LPARAM
lParamExtraInfo
=
:
:
GetMessageExtraInfo
(
)
;
return
lParamExtraInfo
&
TABLET_INK_ID_MASK
;
}
bool
WinUtils
:
:
GetIsMouseFromTouch
(
EventMessage
aEventMessage
)
{
const
uint32_t
MOZ_T_I_SIGNATURE
=
TABLET_INK_TOUCH
|
TABLET_INK_SIGNATURE
;
const
uint32_t
MOZ_T_I_CHECK_TCH
=
TABLET_INK_TOUCH
|
TABLET_INK_CHECK
;
return
(
(
aEventMessage
=
=
eMouseMove
|
|
aEventMessage
=
=
eMouseDown
|
|
aEventMessage
=
=
eMouseUp
|
|
aEventMessage
=
=
ePointerAuxClick
|
|
aEventMessage
=
=
eMouseDoubleClick
)
&
&
(
GetMessageExtraInfo
(
)
&
MOZ_T_I_SIGNATURE
)
=
=
MOZ_T_I_CHECK_TCH
)
;
}
MSG
WinUtils
:
:
InitMSG
(
UINT
aMessage
WPARAM
wParam
LPARAM
lParam
HWND
aWnd
)
{
MSG
msg
;
msg
.
message
=
aMessage
;
msg
.
wParam
=
wParam
;
msg
.
lParam
=
lParam
;
msg
.
hwnd
=
aWnd
;
return
msg
;
}
#
ifdef
MOZ_PLACES
AsyncFaviconDataReady
:
:
AsyncFaviconDataReady
(
nsIURI
*
aNewURI
RefPtr
<
nsISerialEventTarget
>
aIOThread
const
bool
aURLShortcut
already_AddRefed
<
nsIRunnable
>
aRunnable
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
aPromiseHolder
)
:
mNewURI
(
aNewURI
)
mIOThread
(
aIOThread
)
mRunnable
(
aRunnable
)
mPromiseHolder
(
std
:
:
move
(
aPromiseHolder
)
)
mURLShortcut
(
aURLShortcut
)
{
}
NS_IMETHODIMP
myDownloadObserver
:
:
OnDownloadComplete
(
nsIDownloader
*
downloader
nsIRequest
*
request
nsresult
status
nsIFile
*
result
)
{
return
NS_OK
;
}
nsresult
AsyncFaviconDataReady
:
:
OnFaviconDataNotAvailable
(
void
)
{
if
(
!
mURLShortcut
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
icoFile
;
nsresult
rv
=
FaviconHelper
:
:
GetOutputIconPath
(
mNewURI
icoFile
mURLShortcut
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
mozIconURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
mozIconURI
)
"
moz
-
icon
:
/
/
.
html
?
size
=
32
"
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
mozIconURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDownloadObserver
>
downloadObserver
=
new
myDownloadObserver
;
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
NS_NewDownloader
(
getter_AddRefs
(
listener
)
downloadObserver
icoFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
channel
-
>
AsyncOpen
(
listener
)
;
}
NS_IMETHODIMP
AsyncFaviconDataReady
:
:
OnComplete
(
nsIURI
*
aFaviconURI
uint32_t
aDataLen
const
uint8_t
*
aData
const
nsACString
&
aMimeType
uint16_t
aWidth
)
{
if
(
!
aDataLen
|
|
!
aData
)
{
if
(
mURLShortcut
)
{
OnFaviconDataNotAvailable
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
icoFile
;
nsresult
rv
=
FaviconHelper
:
:
GetOutputIconPath
(
mNewURI
icoFile
mURLShortcut
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
path
;
rv
=
icoFile
-
>
GetPath
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
imgIContainer
>
container
;
nsCOMPtr
<
imgITools
>
imgtool
=
do_CreateInstance
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
rv
=
imgtool
-
>
DecodeImageFromBuffer
(
reinterpret_cast
<
const
char
*
>
(
aData
)
aDataLen
aMimeType
getter_AddRefs
(
container
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
SourceSurface
>
surface
=
container
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
NS_ENSURE_TRUE
(
surface
NS_ERROR_FAILURE
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
;
IntSize
size
;
if
(
mURLShortcut
&
&
(
surface
-
>
GetSize
(
)
.
width
<
48
|
|
surface
-
>
GetSize
(
)
.
height
<
48
)
)
{
size
.
width
=
std
:
:
max
(
surface
-
>
GetSize
(
)
.
width
48
)
;
size
.
height
=
std
:
:
max
(
surface
-
>
GetSize
(
)
.
height
48
)
;
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
size
SurfaceFormat
:
:
B8G8R8A8
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
WRITE
&
map
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
map
.
mData
dataSurface
-
>
GetSize
(
)
map
.
mStride
dataSurface
-
>
GetFormat
(
)
)
;
if
(
!
dt
)
{
gfxWarning
(
)
<
<
"
AsyncFaviconDataReady
:
:
OnComplete
failed
in
"
"
CreateDrawTargetForData
"
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
dt
-
>
FillRect
(
Rect
(
0
0
size
.
width
size
.
height
)
ColorPattern
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueWhite
(
)
)
)
)
;
IntPoint
point
;
point
.
x
=
(
size
.
width
-
surface
-
>
GetSize
(
)
.
width
)
/
2
;
point
.
y
=
(
size
.
height
-
surface
-
>
GetSize
(
)
.
height
)
/
2
;
dt
-
>
DrawSurface
(
surface
Rect
(
point
.
x
point
.
y
surface
-
>
GetSize
(
)
.
width
surface
-
>
GetSize
(
)
.
height
)
Rect
(
Point
(
0
0
)
Size
(
surface
-
>
GetSize
(
)
.
width
surface
-
>
GetSize
(
)
.
height
)
)
)
;
dataSurface
-
>
Unmap
(
)
;
}
else
{
size
.
width
=
surface
-
>
GetSize
(
)
.
width
;
size
.
height
=
surface
-
>
GetSize
(
)
.
height
;
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
}
UniquePtr
<
uint8_t
[
]
>
data
=
SurfaceToPackedBGRA
(
dataSurface
)
;
if
(
!
data
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
int32_t
stride
=
4
*
size
.
width
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncEncodeAndWriteIcon
(
path
std
:
:
move
(
data
)
stride
size
.
width
size
.
height
mRunnable
.
forget
(
)
std
:
:
move
(
mPromiseHolder
)
)
;
mIOThread
-
>
Dispatch
(
event
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
#
endif
AsyncEncodeAndWriteIcon
:
:
AsyncEncodeAndWriteIcon
(
const
nsAString
&
aIconPath
UniquePtr
<
uint8_t
[
]
>
aBuffer
uint32_t
aStride
uint32_t
aWidth
uint32_t
aHeight
already_AddRefed
<
nsIRunnable
>
aRunnable
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
aPromiseHolder
)
:
mIconPath
(
aIconPath
)
mBuffer
(
std
:
:
move
(
aBuffer
)
)
mRunnable
(
aRunnable
)
mPromiseHolder
(
std
:
:
move
(
aPromiseHolder
)
)
mStride
(
aStride
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
{
}
NS_IMETHODIMP
AsyncEncodeAndWriteIcon
:
:
Run
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Should
not
be
called
on
the
main
thread
.
"
)
;
RefPtr
<
DataSourceSurface
>
surface
=
Factory
:
:
CreateWrappingDataSourceSurface
(
mBuffer
.
get
(
)
mStride
IntSize
(
mWidth
mHeight
)
SurfaceFormat
:
:
B8G8R8A8
)
;
FILE
*
file
=
_wfopen
(
mIconPath
.
get
(
)
L
"
wb
"
)
;
if
(
!
file
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIFile
>
comFile
=
do_CreateInstance
(
"
mozilla
.
org
/
file
/
local
;
1
"
)
;
if
(
comFile
)
{
rv
=
comFile
-
>
InitWithPath
(
mIconPath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
dirPath
;
comFile
-
>
GetParent
(
getter_AddRefs
(
dirPath
)
)
;
if
(
dirPath
)
{
rv
=
dirPath
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0777
)
;
if
(
NS_SUCCEEDED
(
rv
)
|
|
rv
=
=
NS_ERROR_FILE_ALREADY_EXISTS
)
{
file
=
_wfopen
(
mIconPath
.
get
(
)
L
"
wb
"
)
;
if
(
!
file
)
{
rv
=
NS_ERROR_FAILURE
;
}
}
}
}
}
if
(
!
file
)
{
return
rv
;
}
}
nsresult
rv
=
gfxUtils
:
:
EncodeSourceSurface
(
surface
ImageType
:
:
ICO
u
"
"
_ns
gfxUtils
:
:
eBinaryEncode
file
)
;
fclose
(
file
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mRunnable
)
{
mRunnable
-
>
Run
(
)
;
}
if
(
mPromiseHolder
)
{
mPromiseHolder
-
>
ResolveIfExists
(
mIconPath
__func__
)
;
}
return
rv
;
}
AsyncEncodeAndWriteIcon
:
:
~
AsyncEncodeAndWriteIcon
(
)
{
if
(
mPromiseHolder
)
{
mPromiseHolder
-
>
RejectIfExists
(
NS_ERROR_FAILURE
__func__
)
;
}
}
AsyncDeleteAllFaviconsFromDisk
:
:
AsyncDeleteAllFaviconsFromDisk
(
bool
aIgnoreRecent
)
:
mIgnoreRecent
(
aIgnoreRecent
)
{
mIcoNoDeleteSeconds
=
FaviconHelper
:
:
GetICOCacheSecondsTimeout
(
)
+
600
;
Unused
<
<
NS_GetSpecialDirectory
(
"
ProfLDS
"
getter_AddRefs
(
mJumpListCacheDir
)
)
;
}
NS_IMETHODIMP
AsyncDeleteAllFaviconsFromDisk
:
:
Run
(
)
{
if
(
!
mJumpListCacheDir
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
mJumpListCacheDir
-
>
AppendNative
(
nsDependentCString
(
FaviconHelper
:
:
kJumpListCacheDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
rv
=
mJumpListCacheDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
do
{
nsCOMPtr
<
nsIFile
>
currFile
;
if
(
NS_FAILED
(
entries
-
>
GetNextFile
(
getter_AddRefs
(
currFile
)
)
)
|
|
!
currFile
)
break
;
nsAutoString
path
;
if
(
NS_FAILED
(
currFile
-
>
GetPath
(
path
)
)
)
continue
;
if
(
StringTail
(
path
4
)
.
LowerCaseEqualsASCII
(
"
.
ico
"
)
)
{
bool
exists
;
if
(
NS_FAILED
(
currFile
-
>
Exists
(
&
exists
)
)
|
|
!
exists
)
continue
;
if
(
mIgnoreRecent
)
{
int64_t
fileModTime
=
0
;
rv
=
currFile
-
>
GetLastModifiedTime
(
&
fileModTime
)
;
fileModTime
/
=
PR_MSEC_PER_SEC
;
int64_t
nowTime
=
PR_Now
(
)
/
int64_t
(
PR_USEC_PER_SEC
)
;
if
(
NS_FAILED
(
rv
)
|
|
(
nowTime
-
fileModTime
)
<
mIcoNoDeleteSeconds
)
{
continue
;
}
}
currFile
-
>
Remove
(
false
)
;
}
}
while
(
true
)
;
return
NS_OK
;
}
AsyncDeleteAllFaviconsFromDisk
:
:
~
AsyncDeleteAllFaviconsFromDisk
(
)
{
}
nsresult
FaviconHelper
:
:
ObtainCachedIconFile
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsString
&
aICOFilePath
RefPtr
<
LazyIdleThread
>
&
aIOThread
bool
aURLShortcut
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
nsCOMPtr
<
nsIFile
>
icoFile
;
nsresult
rv
=
GetOutputIconPath
(
aFaviconPageURI
icoFile
aURLShortcut
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
exists
;
rv
=
icoFile
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
exists
)
{
int64_t
fileModTime
=
0
;
rv
=
icoFile
-
>
GetLastModifiedTime
(
&
fileModTime
)
;
fileModTime
/
=
PR_MSEC_PER_SEC
;
int32_t
icoReCacheSecondsTimeout
=
GetICOCacheSecondsTimeout
(
)
;
int64_t
nowTime
=
PR_Now
(
)
/
int64_t
(
PR_USEC_PER_SEC
)
;
if
(
NS_FAILED
(
rv
)
|
|
(
nowTime
-
fileModTime
)
>
icoReCacheSecondsTimeout
)
{
CacheIconFileFromFaviconURIAsync
(
aFaviconPageURI
icoFile
aIOThread
aURLShortcut
runnable
.
forget
(
)
nullptr
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
}
else
{
CacheIconFileFromFaviconURIAsync
(
aFaviconPageURI
icoFile
aIOThread
aURLShortcut
runnable
.
forget
(
)
nullptr
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
icoFile
-
>
GetPath
(
aICOFilePath
)
;
return
rv
;
}
auto
FaviconHelper
:
:
ObtainCachedIconFileAsync
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
RefPtr
<
LazyIdleThread
>
&
aIOThread
FaviconHelper
:
:
IconCacheDir
aCacheDir
)
-
>
RefPtr
<
ObtainCachedIconFileAsyncPromise
>
{
bool
useShortcutCacheDir
=
aCacheDir
=
=
FaviconHelper
:
:
IconCacheDir
:
:
ShortcutCacheDir
;
nsCOMPtr
<
nsIFile
>
icoFile
;
nsresult
rv
=
GetOutputIconPath
(
aFaviconPageURI
icoFile
useShortcutCacheDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ObtainCachedIconFileAsyncPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
int32_t
icoReCacheSecondsTimeout
=
GetICOCacheSecondsTimeout
(
)
;
return
InvokeAsync
(
aIOThread
"
FaviconHelper
:
:
ObtainCachedIconFileAsync
disk
cache
check
"
[
icoFile
=
std
:
:
move
(
icoFile
)
icoReCacheSecondsTimeout
pageURI
=
std
:
:
move
(
aFaviconPageURI
)
useShortcutCacheDir
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
bool
exists
;
nsresult
rv
=
icoFile
-
>
Exists
(
&
exists
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ObtainCachedIconFileAsyncPromise
:
:
CreateAndReject
(
rv
"
ObtainCachedIconFileAsync
disk
cache
check
:
exists
failed
"
)
;
}
if
(
exists
)
{
int64_t
fileModTime
=
0
;
rv
=
icoFile
-
>
GetLastModifiedTime
(
&
fileModTime
)
;
fileModTime
/
=
PR_MSEC_PER_SEC
;
int64_t
nowTime
=
PR_Now
(
)
/
int64_t
(
PR_USEC_PER_SEC
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
(
nowTime
-
fileModTime
)
<
icoReCacheSecondsTimeout
)
{
nsAutoString
icoFilePath
;
rv
=
icoFile
-
>
GetPath
(
icoFilePath
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
ObtainCachedIconFileAsyncPromise
:
:
CreateAndResolve
(
icoFilePath
"
ObtainCachedIconFileAsync
disk
cache
check
:
found
"
)
;
}
}
}
RefPtr
<
nsISerialEventTarget
>
currentThread
=
GetCurrentSerialEventTarget
(
)
;
return
InvokeAsync
(
GetMainThreadSerialEventTarget
(
)
"
ObtainCachedIconFileAsync
call
to
"
"
PromiseCacheIconFileFromFaviconURIAsync
"
[
useShortcutCacheDir
pageURI
=
std
:
:
move
(
pageURI
)
icoFile
=
std
:
:
move
(
icoFile
)
aIOThread
=
std
:
:
move
(
currentThread
)
]
(
)
{
auto
holder
=
MakeUnique
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
(
)
;
RefPtr
<
ObtainCachedIconFileAsyncPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
CacheIconFileFromFaviconURIAsync
(
pageURI
icoFile
aIOThread
useShortcutCacheDir
nullptr
std
:
:
move
(
holder
)
)
;
return
promise
;
}
)
;
}
)
;
}
static
nsresult
HashURI
(
nsIURI
*
aUri
nsACString
&
aUriHash
)
{
nsAutoCString
spec
;
nsresult
rv
=
aUri
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsICryptoHash
>
cryptoHash
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
cryptoHash
-
>
Init
(
nsICryptoHash
:
:
SHA256
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
char
kHashUriContext
[
]
=
"
firefox
-
uri
"
;
rv
=
cryptoHash
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
kHashUriContext
)
sizeof
(
kHashUriContext
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
cryptoHash
-
>
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
spec
.
BeginReading
(
)
)
spec
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
cryptoHash
-
>
Finish
(
true
aUriHash
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
FaviconHelper
:
:
GetOutputIconPath
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsCOMPtr
<
nsIFile
>
&
aICOFile
bool
aURLShortcut
)
{
nsAutoCString
inputURIHash
;
nsresult
rv
=
HashURI
(
aFaviconPageURI
inputURIHash
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
char
*
cur
=
inputURIHash
.
BeginWriting
(
)
;
char
*
end
=
inputURIHash
.
EndWriting
(
)
;
for
(
;
cur
<
end
;
+
+
cur
)
{
if
(
'
/
'
=
=
*
cur
)
{
*
cur
=
'
_
'
;
}
}
rv
=
NS_GetSpecialDirectory
(
"
ProfLDS
"
getter_AddRefs
(
aICOFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aURLShortcut
)
rv
=
aICOFile
-
>
AppendNative
(
nsDependentCString
(
kJumpListCacheDir
)
)
;
else
rv
=
aICOFile
-
>
AppendNative
(
nsDependentCString
(
kShortcutCacheDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
inputURIHash
.
AppendLiteral
(
"
.
ico
"
)
;
rv
=
aICOFile
-
>
AppendNative
(
inputURIHash
)
;
return
rv
;
}
nsresult
FaviconHelper
:
:
CacheIconFileFromFaviconURIAsync
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsCOMPtr
<
nsIFile
>
aICOFile
RefPtr
<
nsISerialEventTarget
>
aIOThread
bool
aURLShortcut
already_AddRefed
<
nsIRunnable
>
aRunnable
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
aPromiseHolder
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
#
ifdef
MOZ_PLACES
nsCOMPtr
<
nsIFaviconService
>
favIconSvc
(
do_GetService
(
"
mozilla
.
org
/
browser
/
favicon
-
service
;
1
"
)
)
;
NS_ENSURE_TRUE
(
favIconSvc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIFaviconDataCallback
>
callback
=
new
mozilla
:
:
widget
:
:
AsyncFaviconDataReady
(
aFaviconPageURI
aIOThread
aURLShortcut
runnable
.
forget
(
)
std
:
:
move
(
aPromiseHolder
)
)
;
favIconSvc
-
>
GetFaviconDataForPage
(
aFaviconPageURI
callback
0
)
;
#
endif
return
NS_OK
;
}
int32_t
FaviconHelper
:
:
GetICOCacheSecondsTimeout
(
)
{
const
int32_t
kSecondsPerDay
=
86400
;
static
bool
alreadyObtained
=
false
;
static
int32_t
icoReCacheSecondsTimeout
=
kSecondsPerDay
;
if
(
alreadyObtained
)
{
return
icoReCacheSecondsTimeout
;
}
const
char
PREF_ICOTIMEOUT
[
]
=
"
browser
.
taskbar
.
lists
.
icoTimeoutInSeconds
"
;
icoReCacheSecondsTimeout
=
Preferences
:
:
GetInt
(
PREF_ICOTIMEOUT
kSecondsPerDay
)
;
alreadyObtained
=
true
;
return
icoReCacheSecondsTimeout
;
}
LayoutDeviceIntRegion
WinUtils
:
:
ConvertHRGNToRegion
(
HRGN
aRgn
)
{
NS_ASSERTION
(
aRgn
"
Don
'
t
pass
NULL
region
here
"
)
;
LayoutDeviceIntRegion
rgn
;
DWORD
size
=
:
:
GetRegionData
(
aRgn
0
nullptr
)
;
AutoTArray
<
uint8_t
100
>
buffer
;
buffer
.
SetLength
(
size
)
;
RGNDATA
*
data
=
reinterpret_cast
<
RGNDATA
*
>
(
buffer
.
Elements
(
)
)
;
if
(
!
:
:
GetRegionData
(
aRgn
size
data
)
)
return
rgn
;
if
(
data
-
>
rdh
.
nCount
>
MAX_RECTS_IN_REGION
)
{
rgn
=
ToIntRect
(
data
-
>
rdh
.
rcBound
)
;
return
rgn
;
}
RECT
*
rects
=
reinterpret_cast
<
RECT
*
>
(
data
-
>
Buffer
)
;
for
(
uint32_t
i
=
0
;
i
<
data
-
>
rdh
.
nCount
;
+
+
i
)
{
RECT
*
r
=
rects
+
i
;
rgn
.
Or
(
rgn
ToIntRect
(
*
r
)
)
;
}
return
rgn
;
}
nsAutoRegion
WinUtils
:
:
RegionToHRGN
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
const
uint32_t
count
=
aRegion
.
GetNumRects
(
)
;
const
size_t
regionBytes
=
count
*
sizeof
(
RECT
)
;
const
size_t
regionDataBytes
=
sizeof
(
RGNDATAHEADER
)
+
regionBytes
;
auto
buffer
=
MakeUnique
<
char
[
]
>
(
regionDataBytes
)
;
auto
*
data
=
reinterpret_cast
<
RGNDATA
*
>
(
buffer
.
get
(
)
)
;
data
-
>
rdh
.
dwSize
=
sizeof
(
RGNDATAHEADER
)
;
data
-
>
rdh
.
iType
=
RDH_RECTANGLES
;
data
-
>
rdh
.
nCount
=
count
;
data
-
>
rdh
.
nRgnSize
=
regionBytes
;
data
-
>
rdh
.
rcBound
=
ToWinRect
(
aRegion
.
GetBounds
(
)
)
;
RECT
*
buf
=
(
RECT
*
)
data
-
>
Buffer
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
*
buf
+
+
=
ToWinRect
(
iter
.
Get
(
)
)
;
}
return
nsAutoRegion
(
:
:
ExtCreateRegion
(
nullptr
regionDataBytes
data
)
)
;
}
LayoutDeviceIntRect
WinUtils
:
:
ToIntRect
(
const
RECT
&
aRect
)
{
return
LayoutDeviceIntRect
(
aRect
.
left
aRect
.
top
aRect
.
right
-
aRect
.
left
aRect
.
bottom
-
aRect
.
top
)
;
}
RECT
WinUtils
:
:
ToWinRect
(
const
LayoutDeviceIntRect
&
aRect
)
{
return
{
.
left
=
aRect
.
x
.
top
=
aRect
.
y
.
right
=
aRect
.
XMost
(
)
.
bottom
=
aRect
.
YMost
(
)
}
;
}
bool
WinUtils
:
:
IsIMEEnabled
(
const
InputContext
&
aInputContext
)
{
return
IsIMEEnabled
(
aInputContext
.
mIMEState
.
mEnabled
)
;
}
bool
WinUtils
:
:
IsIMEEnabled
(
IMEEnabled
aIMEState
)
{
return
aIMEState
=
=
IMEEnabled
:
:
Enabled
;
}
void
WinUtils
:
:
SetupKeyModifiersSequence
(
nsTArray
<
KeyPair
>
*
aArray
uint32_t
aModifiers
UINT
aMessage
)
{
MOZ_ASSERT
(
!
(
aModifiers
&
nsIWidget
:
:
ALTGRAPH
)
|
|
!
(
aModifiers
&
(
nsIWidget
:
:
CTRL_L
|
nsIWidget
:
:
ALT_R
)
)
)
;
if
(
aMessage
=
=
WM_KEYUP
)
{
if
(
aModifiers
&
nsIWidget
:
:
ALTGRAPH
)
{
aArray
-
>
AppendElement
(
KeyPair
(
VK_CONTROL
VK_LCONTROL
ScanCode
:
:
eControlLeft
)
)
;
aArray
-
>
AppendElement
(
KeyPair
(
VK_MENU
VK_RMENU
ScanCode
:
:
eAltRight
)
)
;
}
for
(
uint32_t
i
=
ArrayLength
(
sModifierKeyMap
)
;
i
;
-
-
i
)
{
const
uint32_t
*
map
=
sModifierKeyMap
[
i
-
1
]
;
if
(
aModifiers
&
map
[
0
]
)
{
aArray
-
>
AppendElement
(
KeyPair
(
map
[
1
]
map
[
2
]
map
[
3
]
)
)
;
}
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sModifierKeyMap
)
;
+
+
i
)
{
const
uint32_t
*
map
=
sModifierKeyMap
[
i
]
;
if
(
aModifiers
&
map
[
0
]
)
{
aArray
-
>
AppendElement
(
KeyPair
(
map
[
1
]
map
[
2
]
map
[
3
]
)
)
;
}
}
if
(
aModifiers
&
nsIWidget
:
:
ALTGRAPH
)
{
aArray
-
>
AppendElement
(
KeyPair
(
VK_CONTROL
VK_LCONTROL
ScanCode
:
:
eControlLeft
)
)
;
aArray
-
>
AppendElement
(
KeyPair
(
VK_MENU
VK_RMENU
ScanCode
:
:
eAltRight
)
)
;
}
}
}
nsresult
WinUtils
:
:
WriteBitmap
(
nsIFile
*
aFile
imgIContainer
*
aImage
)
{
RefPtr
<
SourceSurface
>
surface
=
aImage
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
NS_ENSURE_TRUE
(
surface
NS_ERROR_FAILURE
)
;
return
WriteBitmap
(
aFile
surface
)
;
}
nsresult
WinUtils
:
:
WriteBitmap
(
nsIFile
*
aFile
SourceSurface
*
surface
)
{
nsresult
rv
;
MOZ_ASSERT
(
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
int32_t
width
=
dataSurface
-
>
GetSize
(
)
.
width
;
int32_t
height
=
dataSurface
-
>
GetSize
(
)
.
height
;
int32_t
bytesPerPixel
=
4
*
sizeof
(
uint8_t
)
;
uint32_t
bytesPerRow
=
bytesPerPixel
*
width
;
bool
hasAlpha
=
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
;
BITMAPV4HEADER
bmi
;
memset
(
&
bmi
0
sizeof
(
BITMAPV4HEADER
)
)
;
bmi
.
bV4Size
=
sizeof
(
BITMAPV4HEADER
)
;
bmi
.
bV4Width
=
width
;
bmi
.
bV4Height
=
height
;
bmi
.
bV4Planes
=
1
;
bmi
.
bV4BitCount
=
(
WORD
)
bytesPerPixel
*
8
;
bmi
.
bV4V4Compression
=
hasAlpha
?
BI_BITFIELDS
:
BI_RGB
;
bmi
.
bV4SizeImage
=
bytesPerRow
*
height
;
bmi
.
bV4CSType
=
LCS_sRGB
;
if
(
hasAlpha
)
{
bmi
.
bV4RedMask
=
0x00FF0000
;
bmi
.
bV4GreenMask
=
0x0000FF00
;
bmi
.
bV4BlueMask
=
0x000000FF
;
bmi
.
bV4AlphaMask
=
0xFF000000
;
}
BITMAPFILEHEADER
bf
;
DWORD
colormask
[
3
]
;
bf
.
bfType
=
0x4D42
;
bf
.
bfReserved1
=
0
;
bf
.
bfReserved2
=
0
;
bf
.
bfOffBits
=
sizeof
(
BITMAPFILEHEADER
)
+
sizeof
(
BITMAPV4HEADER
)
+
(
hasAlpha
?
sizeof
(
colormask
)
:
0
)
;
bf
.
bfSize
=
bf
.
bfOffBits
+
bmi
.
bV4SizeImage
;
nsCOMPtr
<
nsIOutputStream
>
stream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
stream
)
aFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
NS_ERROR_FAILURE
;
if
(
stream
)
{
uint32_t
written
;
stream
-
>
Write
(
(
const
char
*
)
&
bf
sizeof
(
BITMAPFILEHEADER
)
&
written
)
;
if
(
written
=
=
sizeof
(
BITMAPFILEHEADER
)
)
{
stream
-
>
Write
(
(
const
char
*
)
&
bmi
sizeof
(
BITMAPV4HEADER
)
&
written
)
;
if
(
written
=
=
sizeof
(
BITMAPV4HEADER
)
)
{
if
(
hasAlpha
)
{
colormask
[
0
]
=
0x00FF0000
;
colormask
[
1
]
=
0x0000FF00
;
colormask
[
2
]
=
0x000000FF
;
stream
-
>
Write
(
(
const
char
*
)
colormask
sizeof
(
colormask
)
&
written
)
;
}
if
(
!
hasAlpha
|
|
written
=
=
sizeof
(
colormask
)
)
{
uint32_t
i
=
map
.
mStride
*
height
;
do
{
i
-
=
map
.
mStride
;
stream
-
>
Write
(
(
(
const
char
*
)
map
.
mData
)
+
i
bytesPerRow
&
written
)
;
if
(
written
=
=
bytesPerRow
)
{
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
}
while
(
i
!
=
0
)
;
}
}
}
stream
-
>
Close
(
)
;
}
dataSurface
-
>
Unmap
(
)
;
return
rv
;
}
uint32_t
WinUtils
:
:
IsTouchDeviceSupportPresent
(
)
{
int32_t
touchCapabilities
=
:
:
GetSystemMetrics
(
SM_DIGITIZER
)
;
int32_t
touchFlags
=
NID_EXTERNAL_TOUCH
|
NID_INTEGRATED_TOUCH
;
if
(
StaticPrefs
:
:
dom_w3c_pointer_events_scroll_by_pen_enabled
(
)
)
{
touchFlags
|
=
NID_EXTERNAL_PEN
|
NID_INTEGRATED_PEN
;
}
return
(
touchCapabilities
&
NID_READY
)
&
&
(
touchCapabilities
&
touchFlags
)
;
}
uint32_t
WinUtils
:
:
GetMaxTouchPoints
(
)
{
if
(
IsTouchDeviceSupportPresent
(
)
)
{
return
GetSystemMetrics
(
SM_MAXIMUMTOUCHES
)
;
}
return
0
;
}
POWER_PLATFORM_ROLE
WinUtils
:
:
GetPowerPlatformRole
(
)
{
typedef
POWER_PLATFORM_ROLE
(
WINAPI
*
PowerDeterminePlatformRoleEx
)
(
ULONG
Version
)
;
static
PowerDeterminePlatformRoleEx
power_determine_platform_role
=
reinterpret_cast
<
PowerDeterminePlatformRoleEx
>
(
:
:
GetProcAddress
(
:
:
LoadLibraryW
(
L
"
PowrProf
.
dll
"
)
"
PowerDeterminePlatformRoleEx
"
)
)
;
POWER_PLATFORM_ROLE
powerPlatformRole
=
PlatformRoleUnspecified
;
if
(
!
power_determine_platform_role
)
{
return
powerPlatformRole
;
}
return
power_determine_platform_role
(
POWER_PLATFORM_ROLE_V2
)
;
}
bool
WinUtils
:
:
GetAutoRotationState
(
AR_STATE
*
aRotationState
)
{
typedef
BOOL
(
WINAPI
*
GetAutoRotationStateFunc
)
(
PAR_STATE
pState
)
;
static
GetAutoRotationStateFunc
get_auto_rotation_state_func
=
reinterpret_cast
<
GetAutoRotationStateFunc
>
(
:
:
GetProcAddress
(
GetModuleHandleW
(
L
"
user32
.
dll
"
)
"
GetAutoRotationState
"
)
)
;
if
(
get_auto_rotation_state_func
)
{
ZeroMemory
(
aRotationState
sizeof
(
AR_STATE
)
)
;
return
get_auto_rotation_state_func
(
aRotationState
)
;
}
return
false
;
}
void
WinUtils
:
:
GetClipboardFormatAsString
(
UINT
aFormat
nsAString
&
aOutput
)
{
wchar_t
buf
[
256
]
=
{
}
;
if
(
:
:
GetClipboardFormatNameW
(
aFormat
buf
ARRAYSIZE
(
buf
)
-
1
)
)
{
aOutput
.
Append
(
buf
)
;
return
;
}
switch
(
aFormat
)
{
case
CF_TEXT
:
aOutput
.
Append
(
u
"
CF_TEXT
"
_ns
)
;
break
;
case
CF_BITMAP
:
aOutput
.
Append
(
u
"
CF_BITMAP
"
_ns
)
;
break
;
case
CF_DIB
:
aOutput
.
Append
(
u
"
CF_DIB
"
_ns
)
;
break
;
case
CF_UNICODETEXT
:
aOutput
.
Append
(
u
"
CF_UNICODETEXT
"
_ns
)
;
break
;
case
CF_HDROP
:
aOutput
.
Append
(
u
"
CF_HDROP
"
_ns
)
;
break
;
case
CF_DIBV5
:
aOutput
.
Append
(
u
"
CF_DIBV5
"
_ns
)
;
break
;
default
:
aOutput
.
AppendPrintf
(
"
%
u
"
aFormat
)
;
break
;
}
}
static
bool
IsTabletDevice
(
)
{
if
(
WindowsUIUtils
:
:
GetInTabletMode
(
)
)
{
return
true
;
}
if
(
!
GetSystemMetrics
(
SM_MAXIMUMTOUCHES
)
)
{
return
false
;
}
if
(
GetSystemMetrics
(
SM_SYSTEMDOCKED
)
)
{
return
false
;
}
AR_STATE
rotation_state
;
if
(
WinUtils
:
:
GetAutoRotationState
(
&
rotation_state
)
&
&
(
rotation_state
&
(
AR_NOT_SUPPORTED
|
AR_LAPTOP
|
AR_NOSENSOR
)
)
)
{
return
false
;
}
POWER_PLATFORM_ROLE
role
=
WinUtils
:
:
GetPowerPlatformRole
(
)
;
if
(
role
=
=
PlatformRoleMobile
|
|
role
=
=
PlatformRoleSlate
)
{
return
!
GetSystemMetrics
(
SM_CONVERTIBLESLATEMODE
)
;
}
return
false
;
}
static
bool
SystemHasMouse
(
)
{
return
!
!
:
:
GetSystemMetrics
(
SM_MOUSEPRESENT
)
;
}
PointerCapabilities
WinUtils
:
:
GetPrimaryPointerCapabilities
(
)
{
if
(
IsTabletDevice
(
)
)
{
return
PointerCapabilities
:
:
Coarse
;
}
if
(
SystemHasMouse
(
)
)
{
return
PointerCapabilities
:
:
Fine
|
PointerCapabilities
:
:
Hover
;
}
if
(
IsTouchDeviceSupportPresent
(
)
)
{
return
PointerCapabilities
:
:
Coarse
;
}
return
PointerCapabilities
:
:
None
;
}
static
bool
SystemHasTouchscreen
(
)
{
int
digitizerMetrics
=
:
:
GetSystemMetrics
(
SM_DIGITIZER
)
;
return
(
digitizerMetrics
&
NID_INTEGRATED_TOUCH
)
|
|
(
digitizerMetrics
&
NID_EXTERNAL_TOUCH
)
;
}
static
bool
SystemHasPenDigitizer
(
)
{
int
digitizerMetrics
=
:
:
GetSystemMetrics
(
SM_DIGITIZER
)
;
return
(
digitizerMetrics
&
NID_INTEGRATED_PEN
)
|
|
(
digitizerMetrics
&
NID_EXTERNAL_PEN
)
;
}
PointerCapabilities
WinUtils
:
:
GetAllPointerCapabilities
(
)
{
PointerCapabilities
pointerCapabilities
=
PointerCapabilities
:
:
None
;
if
(
SystemHasTouchscreen
(
)
)
{
pointerCapabilities
|
=
PointerCapabilities
:
:
Coarse
;
}
if
(
SystemHasPenDigitizer
(
)
|
|
SystemHasMouse
(
)
)
{
pointerCapabilities
|
=
PointerCapabilities
:
:
Fine
|
PointerCapabilities
:
:
Hover
;
}
return
pointerCapabilities
;
}
void
WinUtils
:
:
GetPointerExplanation
(
nsAString
*
aExplanation
)
{
*
aExplanation
=
u
"
pointing
-
device
-
none
"
;
bool
first
=
true
;
auto
append
=
[
&
]
(
const
char16_t
*
str
)
{
if
(
first
)
{
aExplanation
-
>
Truncate
(
)
;
first
=
false
;
}
else
{
aExplanation
-
>
Append
(
u
"
"
)
;
}
aExplanation
-
>
Append
(
str
)
;
}
;
if
(
SystemHasTouchscreen
(
)
)
{
append
(
u
"
pointing
-
device
-
touchscreen
"
)
;
}
if
(
SystemHasPenDigitizer
(
)
)
{
append
(
u
"
pointing
-
device
-
pen
-
digitizer
"
)
;
}
if
(
SystemHasMouse
(
)
)
{
append
(
u
"
pointing
-
device
-
mouse
"
)
;
}
}
bool
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
std
:
:
wstring
&
aPath
)
{
LOG_D
(
"
ResolveJunctionPointsAndSymLinks
:
Resolving
path
:
%
S
"
aPath
.
c_str
(
)
)
;
wchar_t
path
[
MAX_PATH
]
=
{
0
}
;
nsAutoHandle
handle
(
:
:
CreateFileW
(
aPath
.
c_str
(
)
0
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
)
;
if
(
handle
=
=
INVALID_HANDLE_VALUE
)
{
LOG_E
(
"
Failed
to
open
file
handle
to
resolve
path
.
GetLastError
=
%
lu
"
GetLastError
(
)
)
;
return
false
;
}
DWORD
pathLen
=
GetFinalPathNameByHandleW
(
handle
path
MAX_PATH
FILE_NAME_NORMALIZED
|
VOLUME_NAME_DOS
)
;
if
(
pathLen
=
=
0
|
|
pathLen
>
=
MAX_PATH
)
{
LOG_E
(
"
GetFinalPathNameByHandleW
failed
.
GetLastError
=
%
lu
"
GetLastError
(
)
)
;
return
false
;
}
aPath
=
path
;
if
(
aPath
.
compare
(
0
7
L
"
\
\
\
\
?
\
\
UNC
"
)
=
=
0
)
{
aPath
.
erase
(
2
6
)
;
}
else
if
(
aPath
.
compare
(
0
4
L
"
\
\
\
\
?
\
\
"
)
=
=
0
)
{
aPath
.
erase
(
0
4
)
;
}
LOG_D
(
"
ResolveJunctionPointsAndSymLinks
:
Resolved
path
to
:
%
S
"
aPath
.
c_str
(
)
)
;
return
true
;
}
bool
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
nsIFile
*
aPath
)
{
MOZ_ASSERT
(
aPath
)
;
nsAutoString
filePath
;
nsresult
rv
=
aPath
-
>
GetPath
(
filePath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
std
:
:
wstring
resolvedPath
(
filePath
.
get
(
)
)
;
if
(
!
ResolveJunctionPointsAndSymLinks
(
resolvedPath
)
)
{
return
false
;
}
rv
=
aPath
-
>
InitWithPath
(
nsDependentString
(
resolvedPath
.
c_str
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
true
;
}
bool
WinUtils
:
:
RunningFromANetworkDrive
(
)
{
wchar_t
exePath
[
MAX_PATH
]
;
if
(
!
:
:
GetModuleFileNameW
(
nullptr
exePath
MAX_PATH
)
)
{
return
false
;
}
std
:
:
wstring
exeString
(
exePath
)
;
if
(
!
widget
:
:
WinUtils
:
:
ResolveJunctionPointsAndSymLinks
(
exeString
)
)
{
return
false
;
}
wchar_t
volPath
[
MAX_PATH
]
;
if
(
!
:
:
GetVolumePathNameW
(
exeString
.
c_str
(
)
volPath
MAX_PATH
)
)
{
return
false
;
}
return
(
:
:
GetDriveTypeW
(
volPath
)
=
=
DRIVE_REMOTE
)
;
}
bool
WinUtils
:
:
CanonicalizePath
(
nsAString
&
aPath
)
{
wchar_t
tempPath
[
MAX_PATH
+
1
]
;
if
(
!
PathCanonicalizeW
(
tempPath
(
char16ptr_t
)
PromiseFlatString
(
aPath
)
.
get
(
)
)
)
{
return
false
;
}
aPath
=
tempPath
;
MOZ_ASSERT
(
aPath
.
Length
(
)
<
=
MAX_PATH
)
;
return
true
;
}
bool
WinUtils
:
:
MakeLongPath
(
nsAString
&
aPath
)
{
wchar_t
tempPath
[
MAX_PATH
+
1
]
;
DWORD
longResult
=
GetLongPathNameW
(
(
char16ptr_t
)
PromiseFlatString
(
aPath
)
.
get
(
)
tempPath
ArrayLength
(
tempPath
)
)
;
if
(
longResult
>
ArrayLength
(
tempPath
)
)
{
return
false
;
}
else
if
(
longResult
)
{
aPath
=
tempPath
;
MOZ_ASSERT
(
aPath
.
Length
(
)
<
=
MAX_PATH
)
;
}
return
true
;
}
bool
WinUtils
:
:
UnexpandEnvVars
(
nsAString
&
aPath
)
{
wchar_t
tempPath
[
MAX_PATH
+
1
]
;
if
(
PathUnExpandEnvStringsW
(
(
char16ptr_t
)
PromiseFlatString
(
aPath
)
.
get
(
)
tempPath
ArrayLength
(
tempPath
)
)
)
{
aPath
=
tempPath
;
MOZ_ASSERT
(
aPath
.
Length
(
)
<
=
MAX_PATH
)
;
}
return
true
;
}
WinUtils
:
:
WhitelistVec
WinUtils
:
:
BuildWhitelist
(
)
{
WhitelistVec
result
;
Unused
<
<
result
.
emplaceBack
(
std
:
:
make_pair
(
nsString
(
u
"
%
ProgramFiles
%
"
_ns
)
nsDependentString
(
)
)
)
;
result
.
back
(
)
.
second
.
SetIsVoid
(
true
)
;
Unused
<
<
result
.
emplaceBack
(
std
:
:
make_pair
(
nsString
(
u
"
%
SystemRoot
%
"
_ns
)
nsDependentString
(
)
)
)
;
result
.
back
(
)
.
second
.
SetIsVoid
(
true
)
;
wchar_t
tmpPath
[
MAX_PATH
+
1
]
=
{
}
;
if
(
GetTempPath
(
MAX_PATH
tmpPath
)
)
{
uint32_t
tmpPathLen
=
wcslen
(
tmpPath
)
;
if
(
tmpPathLen
)
{
tmpPath
[
tmpPathLen
-
1
]
=
0
;
}
nsAutoString
cleanTmpPath
(
tmpPath
)
;
if
(
UnexpandEnvVars
(
cleanTmpPath
)
)
{
constexpr
auto
tempVar
=
u
"
%
TEMP
%
"
_ns
;
Unused
<
<
result
.
emplaceBack
(
std
:
:
make_pair
(
nsString
(
cleanTmpPath
)
nsDependentString
(
tempVar
0
)
)
)
;
}
}
MOZ_ASSERT
(
result
.
length
(
)
<
=
kMaxWhitelistedItems
)
;
return
result
;
}
const
WinUtils
:
:
WhitelistVec
&
WinUtils
:
:
GetWhitelistedPaths
(
)
{
static
WhitelistVec
sWhitelist
(
[
]
(
)
-
>
WhitelistVec
{
auto
setClearFn
=
[
ptr
=
&
sWhitelist
]
(
)
-
>
void
{
RunOnShutdown
(
[
ptr
]
(
)
-
>
void
{
ptr
-
>
clear
(
)
;
}
ShutdownPhase
:
:
XPCOMShutdownFinal
)
;
}
;
if
(
NS_IsMainThread
(
)
)
{
setClearFn
(
)
;
}
else
{
SchedulerGroup
:
:
Dispatch
(
NS_NewRunnableFunction
(
"
WinUtils
:
:
GetWhitelistedPaths
"
std
:
:
move
(
setClearFn
)
)
)
;
}
return
BuildWhitelist
(
)
;
}
(
)
)
;
return
sWhitelist
;
}
bool
WinUtils
:
:
GetAppInitDLLs
(
nsAString
&
aOutput
)
{
aOutput
.
Truncate
(
)
;
HKEY
hkey
=
NULL
;
if
(
RegOpenKeyExW
(
HKEY_LOCAL_MACHINE
L
"
SOFTWARE
\
\
Microsoft
\
\
Windows
NT
\
\
CurrentVersion
\
\
Windows
"
0
KEY_QUERY_VALUE
&
hkey
)
)
{
return
false
;
}
nsAutoRegKey
key
(
hkey
)
;
LONG
status
;
const
wchar_t
kLoadAppInitDLLs
[
]
=
L
"
LoadAppInit_DLLs
"
;
DWORD
loadAppInitDLLs
=
0
;
DWORD
loadAppInitDLLsLen
=
sizeof
(
loadAppInitDLLs
)
;
status
=
RegQueryValueExW
(
hkey
kLoadAppInitDLLs
nullptr
nullptr
(
LPBYTE
)
&
loadAppInitDLLs
&
loadAppInitDLLsLen
)
;
if
(
status
!
=
ERROR_SUCCESS
)
{
return
false
;
}
if
(
!
loadAppInitDLLs
)
{
return
true
;
}
DWORD
numBytes
=
0
;
const
wchar_t
kAppInitDLLs
[
]
=
L
"
AppInit_DLLs
"
;
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
nullptr
&
numBytes
)
;
if
(
status
!
=
ERROR_SUCCESS
)
{
return
false
;
}
mozilla
:
:
UniquePtr
<
wchar_t
[
]
>
data
=
mozilla
:
:
MakeUnique
<
wchar_t
[
]
>
(
numBytes
/
sizeof
(
wchar_t
)
)
;
status
=
RegQueryValueExW
(
hkey
kAppInitDLLs
nullptr
nullptr
(
LPBYTE
)
data
.
get
(
)
&
numBytes
)
;
if
(
status
!
=
ERROR_SUCCESS
)
{
return
false
;
}
const
wchar_t
kDelimiters
[
]
=
L
"
"
;
wchar_t
*
tokenContext
=
nullptr
;
wchar_t
*
token
=
wcstok_s
(
data
.
get
(
)
kDelimiters
&
tokenContext
)
;
while
(
token
)
{
nsAutoString
cleanPath
(
token
)
;
if
(
PreparePathForTelemetry
(
cleanPath
)
)
{
if
(
!
aOutput
.
IsEmpty
(
)
)
{
aOutput
+
=
L
"
;
"
;
}
aOutput
+
=
cleanPath
;
}
token
=
wcstok_s
(
nullptr
kDelimiters
&
tokenContext
)
;
}
return
true
;
}
bool
WinUtils
:
:
PreparePathForTelemetry
(
nsAString
&
aPath
PathTransformFlags
aFlags
)
{
if
(
aFlags
&
PathTransformFlags
:
:
Canonicalize
)
{
if
(
!
CanonicalizePath
(
aPath
)
)
{
return
false
;
}
}
if
(
aFlags
&
PathTransformFlags
:
:
Lengthen
)
{
if
(
!
MakeLongPath
(
aPath
)
)
{
return
false
;
}
}
if
(
aFlags
&
PathTransformFlags
:
:
UnexpandEnvVars
)
{
if
(
!
UnexpandEnvVars
(
aPath
)
)
{
return
false
;
}
}
const
WhitelistVec
&
whitelistedPaths
=
GetWhitelistedPaths
(
)
;
for
(
uint32_t
i
=
0
;
i
<
whitelistedPaths
.
length
(
)
;
+
+
i
)
{
const
nsString
&
testPath
=
whitelistedPaths
[
i
]
.
first
;
const
nsDependentString
&
substitution
=
whitelistedPaths
[
i
]
.
second
;
if
(
StringBeginsWith
(
aPath
testPath
nsCaseInsensitiveStringComparator
)
)
{
if
(
!
substitution
.
IsVoid
(
)
)
{
aPath
.
Replace
(
0
testPath
.
Length
(
)
substitution
)
;
}
return
true
;
}
}
const
nsString
&
flatPath
=
PromiseFlatString
(
aPath
)
;
LPCWSTR
leafStart
=
:
:
PathFindFileNameW
(
flatPath
.
get
(
)
)
;
ptrdiff_t
cutLen
=
leafStart
-
flatPath
.
get
(
)
;
if
(
cutLen
)
{
aPath
.
Cut
(
0
cutLen
)
;
}
else
if
(
aFlags
&
PathTransformFlags
:
:
RequireFilePath
)
{
return
false
;
}
return
true
;
}
nsString
WinUtils
:
:
GetPackageFamilyName
(
)
{
nsString
rv
;
UniquePtr
<
wchar_t
[
]
>
packageIdentity
=
mozilla
:
:
GetPackageFamilyName
(
)
;
if
(
packageIdentity
)
{
rv
=
packageIdentity
.
get
(
)
;
}
return
rv
;
}
bool
WinUtils
:
:
GetClassName
(
HWND
aHwnd
nsAString
&
aClassName
)
{
const
int
bufferLength
=
256
;
aClassName
.
SetLength
(
bufferLength
)
;
int
length
=
:
:
GetClassNameW
(
aHwnd
(
char16ptr_t
)
aClassName
.
BeginWriting
(
)
bufferLength
)
;
if
(
length
=
=
0
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
length
<
=
(
bufferLength
-
1
)
)
;
aClassName
.
Truncate
(
length
)
;
return
true
;
}
static
BOOL
CALLBACK
EnumUpdateWindowOcclusionProc
(
HWND
aHwnd
LPARAM
aLParam
)
{
const
bool
*
const
enable
=
reinterpret_cast
<
bool
*
>
(
aLParam
)
;
nsWindow
*
window
=
WinUtils
:
:
GetNSWindowPtr
(
aHwnd
)
;
if
(
window
)
{
window
-
>
MaybeEnableWindowOcclusion
(
*
enable
)
;
}
return
TRUE
;
}
void
WinUtils
:
:
EnableWindowOcclusion
(
const
bool
aEnable
)
{
if
(
aEnable
)
{
WinWindowOcclusionTracker
:
:
Ensure
(
)
;
}
:
:
EnumWindows
(
EnumUpdateWindowOcclusionProc
reinterpret_cast
<
LPARAM
>
(
&
aEnable
)
)
;
}
bool
WinUtils
:
:
GetTimezoneName
(
wchar_t
*
aBuffer
)
{
DYNAMIC_TIME_ZONE_INFORMATION
tzInfo
;
DWORD
tzid
=
GetDynamicTimeZoneInformation
(
&
tzInfo
)
;
if
(
tzid
=
=
TIME_ZONE_ID_INVALID
)
{
return
false
;
}
wcscpy_s
(
aBuffer
128
tzInfo
.
TimeZoneKeyName
)
;
return
true
;
}
#
ifdef
DEBUG
#
define
DISPLAYCONFIG_DEVICE_INFO_SET_SOURCE_DPI_SCALE
(
int
)
-
4
#
define
DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_DPI_SCALE
(
int
)
-
3
struct
DISPLAYCONFIG_SOURCE_DPI_SCALE_GET
{
DISPLAYCONFIG_DEVICE_INFO_HEADER
header
;
int32_t
minScaleRel
;
int32_t
curScaleRel
;
int32_t
maxScaleRel
;
}
;
struct
DISPLAYCONFIG_SOURCE_DPI_SCALE_SET
{
DISPLAYCONFIG_DEVICE_INFO_HEADER
header
;
int32_t
scaleRel
;
}
;
static
int32_t
sCurRelativeScaleStep
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
;
static
LONG
SetRelativeScaleStep
(
LUID
aAdapterId
int32_t
aRelativeScaleStep
)
{
DISPLAYCONFIG_SOURCE_DPI_SCALE_SET
setDPIScale
=
{
}
;
setDPIScale
.
header
.
adapterId
=
aAdapterId
;
setDPIScale
.
header
.
type
=
(
DISPLAYCONFIG_DEVICE_INFO_TYPE
)
DISPLAYCONFIG_DEVICE_INFO_SET_SOURCE_DPI_SCALE
;
setDPIScale
.
header
.
size
=
sizeof
(
setDPIScale
)
;
setDPIScale
.
scaleRel
=
aRelativeScaleStep
;
return
DisplayConfigSetDeviceInfo
(
&
setDPIScale
.
header
)
;
}
nsresult
WinUtils
:
:
SetHiDPIMode
(
bool
aHiDPI
)
{
auto
config
=
GetDisplayConfig
(
)
;
if
(
!
config
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
config
-
>
mPaths
.
empty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
DISPLAYCONFIG_SOURCE_DPI_SCALE_GET
dpiScale
=
{
}
;
dpiScale
.
header
.
adapterId
=
config
-
>
mPaths
[
0
]
.
targetInfo
.
adapterId
;
dpiScale
.
header
.
type
=
(
DISPLAYCONFIG_DEVICE_INFO_TYPE
)
DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_DPI_SCALE
;
dpiScale
.
header
.
size
=
sizeof
(
dpiScale
)
;
LONG
result
=
:
:
DisplayConfigGetDeviceInfo
(
&
dpiScale
.
header
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
if
(
dpiScale
.
minScaleRel
=
=
dpiScale
.
maxScaleRel
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aHiDPI
&
&
dpiScale
.
curScaleRel
=
=
dpiScale
.
maxScaleRel
)
{
if
(
sCurRelativeScaleStep
=
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
{
sCurRelativeScaleStep
=
dpiScale
.
curScaleRel
;
}
return
NS_OK
;
}
if
(
!
aHiDPI
&
&
dpiScale
.
curScaleRel
=
=
dpiScale
.
minScaleRel
)
{
if
(
sCurRelativeScaleStep
=
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
)
{
sCurRelativeScaleStep
=
dpiScale
.
curScaleRel
;
}
return
NS_OK
;
}
result
=
SetRelativeScaleStep
(
config
-
>
mPaths
[
0
]
.
targetInfo
.
adapterId
aHiDPI
?
dpiScale
.
maxScaleRel
:
dpiScale
.
minScaleRel
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
if
(
sCurRelativeScaleStep
=
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
sCurRelativeScaleStep
=
dpiScale
.
curScaleRel
;
}
return
NS_OK
;
}
nsresult
WinUtils
:
:
RestoreHiDPIMode
(
)
{
if
(
sCurRelativeScaleStep
=
=
std
:
:
numeric_limits
<
int
>
:
:
max
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
auto
config
=
GetDisplayConfig
(
)
;
if
(
!
config
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
config
-
>
mPaths
.
empty
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
LONG
result
=
SetRelativeScaleStep
(
config
-
>
mPaths
[
0
]
.
targetInfo
.
adapterId
sCurRelativeScaleStep
)
;
sCurRelativeScaleStep
=
std
:
:
numeric_limits
<
int32_t
>
:
:
max
(
)
;
if
(
result
!
=
ERROR_SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
#
endif
const
char
*
WinUtils
:
:
WinEventToEventName
(
UINT
msg
)
{
const
auto
eventMsgInfo
=
mozilla
:
:
widget
:
:
gAllEvents
.
find
(
msg
)
;
return
eventMsgInfo
!
=
mozilla
:
:
widget
:
:
gAllEvents
.
end
(
)
?
eventMsgInfo
-
>
second
.
mStr
:
nullptr
;
}
ScopedRtlShimWindow
:
:
ScopedRtlShimWindow
(
nsIWidget
*
aParent
)
:
mWnd
(
nullptr
)
{
NS_ENSURE_TRUE_VOID
(
aParent
)
;
HWND
const
hwnd
=
(
HWND
)
aParent
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
NS_ENSURE_TRUE_VOID
(
hwnd
)
;
nsWindow
*
const
win
=
WinUtils
:
:
GetNSWindowPtr
(
hwnd
)
;
NS_ENSURE_TRUE_VOID
(
win
)
;
ATOM
const
wclass
=
:
:
GetClassWord
(
hwnd
GCW_ATOM
)
;
mWnd
=
:
:
CreateWindowExW
(
win
-
>
IsRTL
(
)
?
WS_EX_LAYOUTRTL
:
0
(
LPCWSTR
)
(
uintptr_t
)
wclass
L
"
"
WS_CHILD
CW_USEDEFAULT
CW_USEDEFAULT
CW_USEDEFAULT
CW_USEDEFAULT
hwnd
nullptr
nsToolkit
:
:
mDllInstance
nullptr
)
;
MOZ_ASSERT
(
mWnd
)
;
}
ScopedRtlShimWindow
:
:
~
ScopedRtlShimWindow
(
)
{
if
(
mWnd
)
{
:
:
DestroyWindow
(
mWnd
)
;
}
}
}
}
