#
include
<
objectarray
.
h
>
#
include
<
shobjidl
.
h
>
#
include
<
windows
.
h
>
#
include
<
string
.
h
>
#
include
<
propvarutil
.
h
>
#
include
<
propkey
.
h
>
#
ifdef
__MINGW32__
#
include
<
propsys
.
h
>
PSSTDAPI
PropVariantToString
(
REFPROPVARIANT
propvar
PWSTR
psz
UINT
cch
)
;
#
endif
#
include
"
gtest
/
gtest
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
WindowsJumpListShortcutDescriptionBinding
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
JumpListBuilder
.
h
"
using
namespace
mozilla
;
using
namespace
testing
;
using
mozilla
:
:
dom
:
:
AutoJSAPI
;
using
mozilla
:
:
dom
:
:
Promise
;
using
mozilla
:
:
dom
:
:
PromiseNativeHandler
;
using
mozilla
:
:
dom
:
:
ToJSValue
;
using
mozilla
:
:
dom
:
:
WindowsJumpListShortcutDescription
;
using
mozilla
:
:
widget
:
:
JumpListBackend
;
using
mozilla
:
:
widget
:
:
JumpListBuilder
;
MATCHER_P
(
LPCWSTREq
value
"
The
equivalent
of
StrEq
for
LPCWSTRs
"
)
{
return
(
wcscmp
(
arg
value
)
)
=
=
0
;
}
MATCHER_P
(
ShellLinksEq
descs
"
Comparing
generated
IShellLinkW
with
"
"
WindowsJumpListShortcutDescription
definitions
"
)
{
uint32_t
count
=
0
;
HRESULT
hr
=
arg
-
>
GetCount
(
&
count
)
;
if
(
FAILED
(
hr
)
|
|
count
!
=
descs
-
>
Length
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
descs
-
>
Length
(
)
;
+
+
i
)
{
RefPtr
<
IShellLinkW
>
link
;
if
(
FAILED
(
arg
-
>
GetAt
(
i
IID_IShellLinkW
static_cast
<
void
*
*
>
(
getter_AddRefs
(
link
)
)
)
)
)
{
return
false
;
}
if
(
!
link
)
{
return
false
;
}
const
WindowsJumpListShortcutDescription
&
desc
=
descs
-
>
ElementAt
(
i
)
;
IPropertyStore
*
propStore
=
nullptr
;
hr
=
link
-
>
QueryInterface
(
IID_IPropertyStore
(
LPVOID
*
)
&
propStore
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
PROPVARIANT
pv
;
hr
=
propStore
-
>
GetValue
(
PKEY_Title
&
pv
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
wchar_t
title
[
PKEYSTR_MAX
]
;
hr
=
PropVariantToString
(
pv
title
PKEYSTR_MAX
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
if
(
!
desc
.
mTitle
.
Equals
(
title
)
)
{
return
false
;
}
wchar_t
pathBuf
[
MAX_PATH
]
;
hr
=
link
-
>
GetPath
(
pathBuf
MAX_PATH
nullptr
SLGP_SHORTPATH
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
if
(
!
desc
.
mPath
.
Equals
(
pathBuf
)
)
{
return
false
;
}
wchar_t
argsBuf
[
MAX_PATH
]
;
hr
=
link
-
>
GetArguments
(
argsBuf
MAX_PATH
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
if
(
desc
.
mArguments
.
WasPassed
(
)
)
{
if
(
!
desc
.
mArguments
.
Value
(
)
.
Equals
(
argsBuf
)
)
{
return
false
;
}
}
else
{
if
(
wcsnlen
(
argsBuf
MAX_PATH
)
!
=
0
)
{
return
false
;
}
}
wchar_t
descBuf
[
MAX_PATH
]
;
hr
=
link
-
>
GetDescription
(
descBuf
MAX_PATH
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
if
(
!
desc
.
mDescription
.
Equals
(
descBuf
)
)
{
return
false
;
}
int
iconIdx
=
0
;
wchar_t
iconPathBuf
[
MAX_PATH
]
;
hr
=
link
-
>
GetIconLocation
(
iconPathBuf
MAX_PATH
&
iconIdx
)
;
if
(
FAILED
(
hr
)
)
{
return
false
;
}
if
(
desc
.
mIconPath
.
WasPassed
(
)
&
&
!
desc
.
mIconPath
.
Value
(
)
.
IsEmpty
(
)
)
{
if
(
!
desc
.
mIconPath
.
Value
(
)
.
Equals
(
iconPathBuf
)
|
|
iconIdx
!
=
0
)
{
return
false
;
}
}
else
{
if
(
!
desc
.
mPath
.
Equals
(
iconPathBuf
)
|
|
desc
.
mFallbackIconIndex
!
=
iconIdx
)
{
return
false
;
}
}
}
return
true
;
}
class
WaitForResolver
:
public
PromiseNativeHandler
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WaitForResolver
override
)
NS_IMETHODIMP
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
{
nsresult
rv
=
NS_ERROR_UNEXPECTED
;
NS_INTERFACE_TABLE0
(
WaitForResolver
)
return
rv
;
}
WaitForResolver
(
)
:
mIsDone
(
false
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aError
)
override
{
mResult
=
aValue
;
mIsDone
=
true
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aError
)
override
{
ASSERT_TRUE
(
false
)
;
}
void
SpinUntilResolved
(
)
{
SpinEventLoopUntil
(
"
WaitForResolver
:
:
SpinUntilResolved
"
_ns
[
&
]
(
)
{
return
mIsDone
;
}
)
;
}
void
SpinUntilResolvedWithResult
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
{
SpinEventLoopUntil
(
"
WaitForResolver
:
:
SpinUntilResolved
"
_ns
[
&
]
(
)
{
return
mIsDone
;
}
)
;
aRetval
.
set
(
mResult
)
;
}
private
:
virtual
~
WaitForResolver
(
)
=
default
;
JS
:
:
Heap
<
JS
:
:
Value
>
mResult
;
bool
mIsDone
;
}
;
class
TestingJumpListBackend
:
public
JumpListBackend
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
JumpListBackend
override
)
TestingJumpListBackend
(
)
:
mMonitor
(
"
TestingJumpListBackend
:
:
mMonitor
"
)
{
}
virtual
bool
IsAvailable
(
)
override
{
return
true
;
}
MOCK_METHOD
(
HRESULT
SetAppID
(
LPCWSTR
)
)
;
MOCK_METHOD
(
HRESULT
BeginList
(
UINT
*
REFIID
void
*
*
)
)
;
MOCK_METHOD
(
HRESULT
AddUserTasks
(
IObjectArray
*
)
)
;
MOCK_METHOD
(
HRESULT
AppendCategory
(
LPCWSTR
IObjectArray
*
)
)
;
MOCK_METHOD
(
HRESULT
CommitList
(
)
)
;
MOCK_METHOD
(
HRESULT
AbortList
(
)
)
;
MOCK_METHOD
(
HRESULT
DeleteList
(
LPCWSTR
)
)
;
virtual
HRESULT
AppendKnownCategory
(
KNOWNDESTCATEGORY
category
)
override
{
return
0
;
}
Monitor
&
GetMonitor
(
)
{
return
mMonitor
;
}
protected
:
virtual
~
TestingJumpListBackend
(
)
override
{
}
;
private
:
Monitor
mMonitor
;
}
;
void
GenerateWindowsJumpListShortcutDescriptions
(
JSContext
*
aCx
uint32_t
howMany
bool
longDescription
nsTArray
<
WindowsJumpListShortcutDescription
>
&
aArray
nsTArray
<
JS
:
:
Value
>
&
aJSValArray
)
{
for
(
uint32_t
i
=
0
;
i
<
howMany
;
+
+
i
)
{
WindowsJumpListShortcutDescription
desc
;
nsAutoString
title
(
u
"
Test
Task
#
"
)
;
title
.
AppendInt
(
i
)
;
desc
.
mTitle
=
title
;
nsAutoString
path
(
u
"
C
:
\
\
Some
\
\
Test
\
\
Path
.
exe
"
)
;
desc
.
mPath
=
path
;
nsAutoString
description
;
if
(
longDescription
)
{
description
.
AppendPrintf
(
"
For
item
#
%
i
this
is
a
very
very
very
very
VERY
VERY
very
very
"
"
very
very
very
very
very
very
very
very
very
very
VERY
VERY
very
"
"
very
very
very
very
very
very
very
very
very
very
very
VERY
VERY
"
"
very
very
very
very
very
very
very
very
very
very
very
very
VERY
"
"
VERY
very
very
very
very
very
very
very
very
very
very
very
very
"
"
VERY
VERY
very
very
very
very
very
very
very
very
very
very
very
"
"
very
VERY
VERY
very
very
very
very
very
very
very
very
long
test
"
"
description
for
an
item
"
i
)
;
}
else
{
description
.
AppendPrintf
(
"
This
is
a
test
description
for
an
item
#
%
i
"
i
)
;
}
desc
.
mDescription
=
description
;
desc
.
mFallbackIconIndex
=
0
;
if
(
!
(
i
%
2
)
)
{
nsAutoString
arguments
(
u
"
-
arg1
-
arg2
-
arg3
"
)
;
desc
.
mArguments
.
Construct
(
arguments
)
;
nsAutoString
iconPath
(
u
"
C
:
\
\
Some
\
\
icon
.
png
"
)
;
desc
.
mIconPath
.
Construct
(
iconPath
)
;
}
aArray
.
AppendElement
(
desc
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
descJSValue
(
aCx
)
;
ASSERT_TRUE
(
ToJSValue
(
aCx
desc
&
descJSValue
)
)
;
aJSValArray
.
AppendElement
(
std
:
:
move
(
descJSValue
)
)
;
}
}
TEST
(
JumpListBuilder
Construction
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
ASSERT_TRUE
(
testBackend
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
LPCWSTR
passedID
=
aumid
.
get
(
)
;
Monitor
&
mon
=
testBackend
-
>
GetMonitor
(
)
;
MonitorAutoLock
lock
(
mon
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
LPCWSTREq
(
passedID
)
)
)
.
WillOnce
(
[
&
mon
]
{
MonitorAutoLock
lock
(
mon
)
;
mon
.
Notify
(
)
;
return
S_OK
;
}
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
const
int
kWaitTimeoutMs
=
5000
;
ASSERT_TRUE
(
mon
.
Wait
(
TimeDuration
:
:
FromMilliseconds
(
kWaitTimeoutMs
)
)
!
=
CVStatus
:
:
Timeout
)
;
}
TEST
(
JumpListBuilder
CheckForRemovals
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
2
)
;
EXPECT_CALL
(
*
testBackend
BeginList
)
.
WillOnce
(
[
]
(
UINT
*
pcMinSlots
REFIID
riid
void
*
*
ppv
)
{
RefPtr
<
IObjectCollection
>
collection
;
HRESULT
hr
=
CoCreateInstance
(
CLSID_EnumerableObjectCollection
nullptr
CLSCTX_INPROC_SERVER
IID_IObjectCollection
getter_AddRefs
(
collection
)
)
;
MOZ_RELEASE_ASSERT
(
SUCCEEDED
(
hr
)
)
;
RefPtr
<
IShellLinkW
>
link
;
hr
=
CoCreateInstance
(
CLSID_ShellLink
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLinkW
getter_AddRefs
(
link
)
)
;
MOZ_RELEASE_ASSERT
(
SUCCEEDED
(
hr
)
)
;
nsAutoString
firstLinkHref
(
u
"
https
:
/
/
example
.
com
"
_ns
)
;
link
-
>
SetArguments
(
firstLinkHref
.
get
(
)
)
;
nsAutoString
appPath
(
u
"
C
:
\
\
Tmp
\
\
firefox
.
exe
"
_ns
)
;
link
-
>
SetIconLocation
(
appPath
.
get
(
)
0
)
;
collection
-
>
AddObject
(
link
)
;
nsAutoString
secondLinkHref
(
u
"
https
:
/
/
mozilla
.
org
"
_ns
)
;
link
-
>
SetArguments
(
secondLinkHref
.
get
(
)
)
;
collection
-
>
AddObject
(
link
)
;
RefPtr
<
IObjectArray
>
pArray
;
hr
=
collection
-
>
QueryInterface
(
IID_IObjectArray
getter_AddRefs
(
pArray
)
)
;
MOZ_RELEASE_ASSERT
(
SUCCEEDED
(
hr
)
)
;
*
ppv
=
static_cast
<
IObjectArray
*
>
(
pArray
)
;
(
static_cast
<
IUnknown
*
>
(
*
ppv
)
)
-
>
AddRef
(
)
;
*
pcMinSlots
=
10
;
return
S_OK
;
}
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
nsresult
rv
=
builder
-
>
CheckForRemovals
(
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolvedWithResult
(
&
result
)
;
ASSERT_TRUE
(
result
.
isObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
result
.
toObjectOrNull
(
)
)
;
bool
isArray
;
ASSERT_TRUE
(
JS
:
:
IsArrayObject
(
cx
obj
&
isArray
)
)
;
ASSERT_TRUE
(
isArray
)
;
uint32_t
length
=
0
;
ASSERT_TRUE
(
JS
:
:
GetArrayLength
(
cx
obj
&
length
)
)
;
ASSERT_EQ
(
length
2U
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
firstURLValue
(
cx
)
;
ASSERT_TRUE
(
JS_GetElement
(
cx
obj
0
&
firstURLValue
)
)
;
JS
:
:
Rooted
<
JSString
*
>
firstURLJSString
(
cx
firstURLValue
.
toString
(
)
)
;
nsAutoJSString
firstURLAutoString
;
ASSERT_TRUE
(
firstURLAutoString
.
init
(
cx
firstURLJSString
)
)
;
ASSERT_TRUE
(
firstURLAutoString
.
EqualsLiteral
(
"
https
:
/
/
example
.
com
"
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
secondURLValue
(
cx
)
;
ASSERT_TRUE
(
JS_GetElement
(
cx
obj
1
&
secondURLValue
)
)
;
JS
:
:
Rooted
<
JSString
*
>
secondURLJSString
(
cx
secondURLValue
.
toString
(
)
)
;
nsAutoJSString
secondURLAutoString
;
ASSERT_TRUE
(
secondURLAutoString
.
init
(
cx
secondURLJSString
)
)
;
ASSERT_TRUE
(
secondURLAutoString
.
EqualsLiteral
(
"
https
:
/
/
mozilla
.
org
"
)
)
;
}
TEST
(
JumpListBuilder
PopulateJumpListEmpty
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
nsTArray
<
JS
:
:
Value
>
taskDescJSVals
;
nsAutoString
customTitle
(
u
"
"
)
;
nsTArray
<
JS
:
:
Value
>
customDescJSVals
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
BeginList
(
_
_
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
CommitList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
DeleteList
(
_
)
)
.
Times
(
0
)
;
nsresult
rv
=
builder
-
>
PopulateJumpList
(
taskDescJSVals
customTitle
customDescJSVals
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolved
(
)
;
}
TEST
(
JumpListBuilder
PopulateJumpListOnlyTasks
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
nsTArray
<
JS
:
:
Value
>
taskDescJSVals
;
nsTArray
<
WindowsJumpListShortcutDescription
>
taskDescs
;
GenerateWindowsJumpListShortcutDescriptions
(
cx
2
false
taskDescs
taskDescJSVals
)
;
nsAutoString
customTitle
(
u
"
"
)
;
nsTArray
<
JS
:
:
Value
>
customDescJSVals
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
BeginList
(
_
_
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AddUserTasks
(
ShellLinksEq
(
&
taskDescs
)
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AppendCategory
(
_
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
CommitList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
DeleteList
(
_
)
)
.
Times
(
0
)
;
nsresult
rv
=
builder
-
>
PopulateJumpList
(
taskDescJSVals
customTitle
customDescJSVals
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolved
(
)
;
}
TEST
(
JumpListBuilder
PopulateJumpListOnlyCustomItems
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
nsTArray
<
WindowsJumpListShortcutDescription
>
descs
;
nsTArray
<
JS
:
:
Value
>
customDescJSVals
;
GenerateWindowsJumpListShortcutDescriptions
(
cx
2
false
descs
customDescJSVals
)
;
nsAutoString
customTitle
(
u
"
My
custom
title
"
)
;
nsTArray
<
JS
:
:
Value
>
taskDescJSVals
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
BeginList
(
_
_
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AddUserTasks
(
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
AppendCategory
(
LPCWSTREq
(
customTitle
.
get
(
)
)
ShellLinksEq
(
&
descs
)
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
CommitList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
DeleteList
(
_
)
)
.
Times
(
0
)
;
nsresult
rv
=
builder
-
>
PopulateJumpList
(
taskDescJSVals
customTitle
customDescJSVals
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolved
(
)
;
}
TEST
(
JumpListBuilder
PopulateJumpList
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
nsTArray
<
WindowsJumpListShortcutDescription
>
taskDescs
;
nsTArray
<
JS
:
:
Value
>
taskDescJSVals
;
GenerateWindowsJumpListShortcutDescriptions
(
cx
2
false
taskDescs
taskDescJSVals
)
;
nsTArray
<
WindowsJumpListShortcutDescription
>
customDescs
;
nsTArray
<
JS
:
:
Value
>
customDescJSVals
;
GenerateWindowsJumpListShortcutDescriptions
(
cx
2
false
customDescs
customDescJSVals
)
;
nsAutoString
customTitle
(
u
"
My
custom
title
"
)
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
BeginList
(
_
_
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AddUserTasks
(
ShellLinksEq
(
&
taskDescs
)
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AppendCategory
(
LPCWSTREq
(
customTitle
.
get
(
)
)
ShellLinksEq
(
&
customDescs
)
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
CommitList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
DeleteList
(
_
)
)
.
Times
(
0
)
;
nsresult
rv
=
builder
-
>
PopulateJumpList
(
taskDescJSVals
customTitle
customDescJSVals
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolved
(
)
;
}
TEST
(
JumpListBuilder
ClearJumpList
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
BeginList
(
_
_
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
AddUserTasks
(
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
AppendCategory
(
_
_
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
CommitList
(
)
)
.
Times
(
0
)
;
EXPECT_CALL
(
*
testBackend
DeleteList
(
LPCWSTREq
(
aumid
.
get
(
)
)
)
)
.
Times
(
1
)
;
nsresult
rv
=
builder
-
>
ClearJumpList
(
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolved
(
)
;
}
TEST
(
JumpListBuilder
TruncateDescription
)
{
RefPtr
<
StrictMock
<
TestingJumpListBackend
>
>
testBackend
=
new
StrictMock
<
TestingJumpListBackend
>
(
)
;
nsAutoString
aumid
(
u
"
TestApplicationID
"
)
;
EXPECT_CALL
(
*
testBackend
SetAppID
(
_
)
)
.
Times
(
1
)
;
nsCOMPtr
<
nsIJumpListBuilder
>
builder
=
new
JumpListBuilder
(
aumid
testBackend
)
;
ASSERT_TRUE
(
builder
)
;
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
RefPtr
<
Promise
>
promise
;
nsTArray
<
WindowsJumpListShortcutDescription
>
taskDescs
;
nsTArray
<
JS
:
:
Value
>
taskDescJSVals
;
GenerateWindowsJumpListShortcutDescriptions
(
cx
2
true
taskDescs
taskDescJSVals
)
;
nsTArray
<
WindowsJumpListShortcutDescription
>
customDescs
;
nsTArray
<
JS
:
:
Value
>
customDescJSVals
;
GenerateWindowsJumpListShortcutDescriptions
(
cx
2
true
customDescs
customDescJSVals
)
;
for
(
auto
&
taskDesc
:
taskDescs
)
{
taskDesc
.
mDescription
.
SetLength
(
MAX_PATH
-
1
)
;
}
for
(
auto
&
customDesc
:
customDescs
)
{
customDesc
.
mDescription
.
SetLength
(
MAX_PATH
-
1
)
;
}
nsAutoString
customTitle
(
u
"
My
custom
title
"
)
;
EXPECT_CALL
(
*
testBackend
AbortList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
BeginList
(
_
_
_
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AddUserTasks
(
ShellLinksEq
(
&
taskDescs
)
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
AppendCategory
(
LPCWSTREq
(
customTitle
.
get
(
)
)
ShellLinksEq
(
&
customDescs
)
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
CommitList
(
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
*
testBackend
DeleteList
(
_
)
)
.
Times
(
0
)
;
nsresult
rv
=
builder
-
>
PopulateJumpList
(
taskDescJSVals
customTitle
customDescJSVals
cx
getter_AddRefs
(
promise
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_TRUE
(
promise
)
;
RefPtr
<
WaitForResolver
>
resolver
=
new
WaitForResolver
(
)
;
promise
-
>
AppendNativeHandler
(
resolver
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
)
;
resolver
-
>
SpinUntilResolved
(
)
;
}
