#
include
"
nsLookAndFeel
.
h
"
#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsUXThemeData
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
gfxFontConstants
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
LookAndFeel
:
:
OperatingSystemVersion
nsLookAndFeel
:
:
GetOperatingSystemVersion
(
)
{
static
OperatingSystemVersion
version
=
eOperatingSystemVersion_Unknown
;
if
(
version
!
=
eOperatingSystemVersion_Unknown
)
{
return
version
;
}
if
(
IsWin10OrLater
(
)
)
{
version
=
eOperatingSystemVersion_Windows10
;
}
else
if
(
IsWin8OrLater
(
)
)
{
version
=
eOperatingSystemVersion_Windows8
;
}
else
{
version
=
eOperatingSystemVersion_Windows7
;
}
return
version
;
}
static
nsresult
GetColorFromTheme
(
nsUXThemeClass
cls
int32_t
aPart
int32_t
aState
int32_t
aPropId
nscolor
&
aColor
)
{
COLORREF
color
;
HRESULT
hr
=
GetThemeColor
(
nsUXThemeData
:
:
GetTheme
(
cls
)
aPart
aState
aPropId
&
color
)
;
if
(
hr
=
=
S_OK
)
{
aColor
=
COLOREF_2_NSRGB
(
color
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
static
int32_t
GetSystemParam
(
long
flag
int32_t
def
)
{
DWORD
value
;
return
:
:
SystemParametersInfo
(
flag
0
&
value
0
)
?
value
:
def
;
}
static
nsresult
SystemWantsDarkTheme
(
int32_t
&
darkThemeEnabled
)
{
if
(
!
IsWin10OrLater
(
)
)
{
darkThemeEnabled
=
0
;
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIWindowsRegKey
>
personalizeKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
personalizeKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
NS_LITERAL_STRING
(
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
CurrentVersion
\
\
Themes
\
\
Personalize
"
)
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
lightThemeEnabled
;
rv
=
personalizeKey
-
>
ReadIntValue
(
NS_LITERAL_STRING
(
"
AppsUseLightTheme
"
)
&
lightThemeEnabled
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
darkThemeEnabled
=
!
lightThemeEnabled
;
}
return
rv
;
}
nsLookAndFeel
:
:
nsLookAndFeel
(
)
:
nsXPLookAndFeel
(
)
mUseAccessibilityTheme
(
0
)
mUseDefaultTheme
(
0
)
mNativeThemeId
(
eWindowsTheme_Generic
)
mCaretBlinkTime
(
-
1
)
mHasColorMenuHoverText
(
false
)
mHasColorAccent
(
false
)
mHasColorAccentText
(
false
)
mHasColorMediaText
(
false
)
mHasColorCommunicationsText
(
false
)
mInitialized
(
false
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
TOUCH_ENABLED_DEVICE
WinUtils
:
:
IsTouchDeviceSupportPresent
(
)
)
;
}
nsLookAndFeel
:
:
~
nsLookAndFeel
(
)
{
}
void
nsLookAndFeel
:
:
NativeInit
(
)
{
EnsureInit
(
)
;
}
void
nsLookAndFeel
:
:
RefreshImpl
(
)
{
nsXPLookAndFeel
:
:
RefreshImpl
(
)
;
for
(
auto
e
=
mSystemFontCache
.
begin
(
)
end
=
mSystemFontCache
.
end
(
)
;
e
!
=
end
;
+
+
e
)
{
e
-
>
mCacheValid
=
false
;
}
mCaretBlinkTime
=
-
1
;
mInitialized
=
false
;
}
nsresult
nsLookAndFeel
:
:
NativeGetColor
(
ColorID
aID
nscolor
&
aColor
)
{
EnsureInit
(
)
;
nsresult
res
=
NS_OK
;
int
idx
;
switch
(
aID
)
{
case
ColorID
:
:
WindowBackground
:
idx
=
COLOR_WINDOW
;
break
;
case
ColorID
:
:
WindowForeground
:
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
WidgetBackground
:
idx
=
COLOR_BTNFACE
;
break
;
case
ColorID
:
:
WidgetForeground
:
idx
=
COLOR_BTNTEXT
;
break
;
case
ColorID
:
:
WidgetSelectBackground
:
idx
=
COLOR_HIGHLIGHT
;
break
;
case
ColorID
:
:
WidgetSelectForeground
:
idx
=
COLOR_HIGHLIGHTTEXT
;
break
;
case
ColorID
:
:
Widget3DHighlight
:
idx
=
COLOR_BTNHIGHLIGHT
;
break
;
case
ColorID
:
:
Widget3DShadow
:
idx
=
COLOR_BTNSHADOW
;
break
;
case
ColorID
:
:
TextBackground
:
idx
=
COLOR_WINDOW
;
break
;
case
ColorID
:
:
TextForeground
:
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
TextSelectBackground
:
case
ColorID
:
:
IMESelectedRawTextBackground
:
case
ColorID
:
:
IMESelectedConvertedTextBackground
:
idx
=
COLOR_HIGHLIGHT
;
break
;
case
ColorID
:
:
TextSelectForeground
:
case
ColorID
:
:
IMESelectedRawTextForeground
:
case
ColorID
:
:
IMESelectedConvertedTextForeground
:
idx
=
COLOR_HIGHLIGHTTEXT
;
break
;
case
ColorID
:
:
IMERawInputBackground
:
case
ColorID
:
:
IMEConvertedTextBackground
:
aColor
=
NS_TRANSPARENT
;
return
NS_OK
;
case
ColorID
:
:
IMERawInputForeground
:
case
ColorID
:
:
IMEConvertedTextForeground
:
aColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
return
NS_OK
;
case
ColorID
:
:
IMERawInputUnderline
:
case
ColorID
:
:
IMEConvertedTextUnderline
:
aColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
return
NS_OK
;
case
ColorID
:
:
IMESelectedRawTextUnderline
:
case
ColorID
:
:
IMESelectedConvertedTextUnderline
:
aColor
=
NS_TRANSPARENT
;
return
NS_OK
;
case
ColorID
:
:
SpellCheckerUnderline
:
aColor
=
NS_RGB
(
0xff
0
0
)
;
return
NS_OK
;
case
ColorID
:
:
Activeborder
:
idx
=
COLOR_ACTIVEBORDER
;
break
;
case
ColorID
:
:
Activecaption
:
idx
=
COLOR_ACTIVECAPTION
;
break
;
case
ColorID
:
:
Appworkspace
:
idx
=
COLOR_APPWORKSPACE
;
break
;
case
ColorID
:
:
Background
:
idx
=
COLOR_BACKGROUND
;
break
;
case
ColorID
:
:
Buttonface
:
case
ColorID
:
:
MozButtonhoverface
:
idx
=
COLOR_BTNFACE
;
break
;
case
ColorID
:
:
Buttonhighlight
:
idx
=
COLOR_BTNHIGHLIGHT
;
break
;
case
ColorID
:
:
Buttonshadow
:
idx
=
COLOR_BTNSHADOW
;
break
;
case
ColorID
:
:
Buttontext
:
case
ColorID
:
:
MozButtonhovertext
:
idx
=
COLOR_BTNTEXT
;
break
;
case
ColorID
:
:
Captiontext
:
idx
=
COLOR_CAPTIONTEXT
;
break
;
case
ColorID
:
:
Graytext
:
idx
=
COLOR_GRAYTEXT
;
break
;
case
ColorID
:
:
Highlight
:
case
ColorID
:
:
MozHtmlCellhighlight
:
case
ColorID
:
:
MozMenuhover
:
idx
=
COLOR_HIGHLIGHT
;
break
;
case
ColorID
:
:
MozMenubarhovertext
:
if
(
!
IsAppThemed
(
)
)
{
idx
=
nsUXThemeData
:
:
sFlatMenus
?
COLOR_HIGHLIGHTTEXT
:
COLOR_MENUTEXT
;
break
;
}
case
ColorID
:
:
MozMenuhovertext
:
if
(
mHasColorMenuHoverText
)
{
aColor
=
mColorMenuHoverText
;
return
NS_OK
;
}
case
ColorID
:
:
Highlighttext
:
case
ColorID
:
:
MozHtmlCellhighlighttext
:
idx
=
COLOR_HIGHLIGHTTEXT
;
break
;
case
ColorID
:
:
Inactiveborder
:
idx
=
COLOR_INACTIVEBORDER
;
break
;
case
ColorID
:
:
Inactivecaption
:
idx
=
COLOR_INACTIVECAPTION
;
break
;
case
ColorID
:
:
Inactivecaptiontext
:
idx
=
COLOR_INACTIVECAPTIONTEXT
;
break
;
case
ColorID
:
:
Infobackground
:
idx
=
COLOR_INFOBK
;
break
;
case
ColorID
:
:
Infotext
:
idx
=
COLOR_INFOTEXT
;
break
;
case
ColorID
:
:
Menu
:
idx
=
COLOR_MENU
;
break
;
case
ColorID
:
:
Menutext
:
case
ColorID
:
:
MozMenubartext
:
idx
=
COLOR_MENUTEXT
;
break
;
case
ColorID
:
:
Scrollbar
:
idx
=
COLOR_SCROLLBAR
;
break
;
case
ColorID
:
:
Threeddarkshadow
:
idx
=
COLOR_3DDKSHADOW
;
break
;
case
ColorID
:
:
Threedface
:
idx
=
COLOR_3DFACE
;
break
;
case
ColorID
:
:
Threedhighlight
:
idx
=
COLOR_3DHIGHLIGHT
;
break
;
case
ColorID
:
:
Threedlightshadow
:
idx
=
COLOR_3DLIGHT
;
break
;
case
ColorID
:
:
Threedshadow
:
idx
=
COLOR_3DSHADOW
;
break
;
case
ColorID
:
:
Window
:
idx
=
COLOR_WINDOW
;
break
;
case
ColorID
:
:
Windowframe
:
idx
=
COLOR_WINDOWFRAME
;
break
;
case
ColorID
:
:
Windowtext
:
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
MozEventreerow
:
case
ColorID
:
:
MozOddtreerow
:
case
ColorID
:
:
Field
:
case
ColorID
:
:
MozCombobox
:
idx
=
COLOR_WINDOW
;
break
;
case
ColorID
:
:
Fieldtext
:
case
ColorID
:
:
MozComboboxtext
:
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
MozDialog
:
case
ColorID
:
:
MozCellhighlight
:
idx
=
COLOR_3DFACE
;
break
;
case
ColorID
:
:
MozWinAccentcolor
:
if
(
mHasColorAccent
)
{
aColor
=
mColorAccent
;
}
else
{
aColor
=
NS_RGB
(
158
158
158
)
;
}
return
NS_OK
;
case
ColorID
:
:
MozWinAccentcolortext
:
if
(
mHasColorAccentText
)
{
aColor
=
mColorAccentText
;
}
else
{
aColor
=
NS_RGB
(
0
0
0
)
;
}
return
NS_OK
;
case
ColorID
:
:
MozWinMediatext
:
if
(
mHasColorMediaText
)
{
aColor
=
mColorMediaText
;
return
NS_OK
;
}
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
MozWinCommunicationstext
:
if
(
mHasColorCommunicationsText
)
{
aColor
=
mColorCommunicationsText
;
return
NS_OK
;
}
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
MozDialogtext
:
case
ColorID
:
:
MozCellhighlighttext
:
idx
=
COLOR_WINDOWTEXT
;
break
;
case
ColorID
:
:
MozDragtargetzone
:
idx
=
COLOR_HIGHLIGHTTEXT
;
break
;
case
ColorID
:
:
MozButtondefault
:
idx
=
COLOR_3DDKSHADOW
;
break
;
case
ColorID
:
:
MozNativehyperlinktext
:
idx
=
COLOR_HOTLIGHT
;
break
;
default
:
NS_WARNING
(
"
Unknown
color
for
nsLookAndFeel
"
)
;
idx
=
COLOR_WINDOW
;
res
=
NS_ERROR_FAILURE
;
break
;
}
aColor
=
GetColorForSysColorIndex
(
idx
)
;
return
res
;
}
nsresult
nsLookAndFeel
:
:
GetIntImpl
(
IntID
aID
int32_t
&
aResult
)
{
nsresult
res
=
nsXPLookAndFeel
:
:
GetIntImpl
(
aID
aResult
)
;
if
(
NS_SUCCEEDED
(
res
)
)
return
res
;
res
=
NS_OK
;
switch
(
aID
)
{
case
eIntID_CaretBlinkTime
:
if
(
mCaretBlinkTime
<
0
)
{
mCaretBlinkTime
=
static_cast
<
int32_t
>
(
:
:
GetCaretBlinkTime
(
)
)
;
}
aResult
=
mCaretBlinkTime
;
break
;
case
eIntID_CaretWidth
:
aResult
=
1
;
break
;
case
eIntID_ShowCaretDuringSelection
:
aResult
=
0
;
break
;
case
eIntID_SelectTextfieldsOnKeyFocus
:
aResult
=
1
;
break
;
case
eIntID_SubmenuDelay
:
aResult
=
GetSystemParam
(
SPI_GETMENUSHOWDELAY
400
)
;
break
;
case
eIntID_TooltipDelay
:
aResult
=
500
;
break
;
case
eIntID_MenusCanOverlapOSBar
:
aResult
=
1
;
break
;
case
eIntID_DragThresholdX
:
aResult
=
:
:
GetSystemMetrics
(
SM_CXDRAG
)
-
1
;
break
;
case
eIntID_DragThresholdY
:
aResult
=
:
:
GetSystemMetrics
(
SM_CYDRAG
)
-
1
;
break
;
case
eIntID_UseAccessibilityTheme
:
if
(
XRE_IsContentProcess
(
)
)
{
aResult
=
mUseAccessibilityTheme
;
}
else
{
aResult
=
nsUXThemeData
:
:
IsHighContrastOn
(
)
;
}
break
;
case
eIntID_ScrollArrowStyle
:
aResult
=
eScrollArrowStyle_Single
;
break
;
case
eIntID_ScrollSliderStyle
:
aResult
=
eScrollThumbStyle_Proportional
;
break
;
case
eIntID_TreeOpenDelay
:
aResult
=
1000
;
break
;
case
eIntID_TreeCloseDelay
:
aResult
=
0
;
break
;
case
eIntID_TreeLazyScrollDelay
:
aResult
=
150
;
break
;
case
eIntID_TreeScrollDelay
:
aResult
=
100
;
break
;
case
eIntID_TreeScrollLinesMax
:
aResult
=
3
;
break
;
case
eIntID_WindowsClassic
:
aResult
=
!
IsAppThemed
(
)
;
break
;
case
eIntID_TouchEnabled
:
aResult
=
WinUtils
:
:
IsTouchDeviceSupportPresent
(
)
;
break
;
case
eIntID_WindowsDefaultTheme
:
if
(
XRE_IsContentProcess
(
)
)
{
aResult
=
mUseDefaultTheme
;
}
else
{
aResult
=
nsUXThemeData
:
:
IsDefaultWindowTheme
(
)
;
}
break
;
case
eIntID_WindowsThemeIdentifier
:
if
(
XRE_IsContentProcess
(
)
)
{
aResult
=
mNativeThemeId
;
}
else
{
aResult
=
nsUXThemeData
:
:
GetNativeThemeId
(
)
;
}
break
;
case
eIntID_OperatingSystemVersionIdentifier
:
{
aResult
=
GetOperatingSystemVersion
(
)
;
break
;
}
case
eIntID_MacGraphiteTheme
:
aResult
=
0
;
res
=
NS_ERROR_NOT_IMPLEMENTED
;
break
;
case
eIntID_DWMCompositor
:
aResult
=
nsUXThemeData
:
:
CheckForCompositor
(
)
;
break
;
case
eIntID_WindowsAccentColorInTitlebar
:
{
nscolor
unused
;
if
(
NS_WARN_IF
(
NS_FAILED
(
GetAccentColor
(
unused
)
)
)
)
{
aResult
=
0
;
break
;
}
uint32_t
colorPrevalence
;
nsresult
rv
=
mDwmKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
NS_LITERAL_STRING
(
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
DWM
"
)
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aResult
=
(
NS_SUCCEEDED
(
mDwmKey
-
>
ReadIntValue
(
NS_LITERAL_STRING
(
"
ColorPrevalence
"
)
&
colorPrevalence
)
)
&
&
colorPrevalence
=
=
1
)
?
1
:
0
;
mDwmKey
-
>
Close
(
)
;
}
break
;
case
eIntID_WindowsGlass
:
aResult
=
(
nsUXThemeData
:
:
CheckForCompositor
(
)
&
&
!
IsWin8OrLater
(
)
)
;
break
;
case
eIntID_AlertNotificationOrigin
:
aResult
=
0
;
{
HWND
shellWindow
=
FindWindowW
(
L
"
Shell_TrayWnd
"
nullptr
)
;
if
(
shellWindow
!
=
nullptr
)
{
APPBARDATA
appBarData
;
appBarData
.
hWnd
=
shellWindow
;
appBarData
.
cbSize
=
sizeof
(
appBarData
)
;
if
(
SHAppBarMessage
(
ABM_GETTASKBARPOS
&
appBarData
)
)
{
switch
(
appBarData
.
uEdge
)
{
case
ABE_LEFT
:
aResult
=
NS_ALERT_HORIZONTAL
|
NS_ALERT_LEFT
;
break
;
case
ABE_RIGHT
:
aResult
=
NS_ALERT_HORIZONTAL
;
break
;
case
ABE_TOP
:
aResult
=
NS_ALERT_TOP
;
case
ABE_BOTTOM
:
if
(
:
:
GetWindowLong
(
shellWindow
GWL_EXSTYLE
)
&
WS_EX_LAYOUTRTL
)
aResult
|
=
NS_ALERT_LEFT
;
break
;
}
}
}
}
break
;
case
eIntID_IMERawInputUnderlineStyle
:
case
eIntID_IMEConvertedTextUnderlineStyle
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_DASHED
;
break
;
case
eIntID_IMESelectedRawTextUnderlineStyle
:
case
eIntID_IMESelectedConvertedTextUnderline
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
;
break
;
case
eIntID_SpellCheckerUnderlineStyle
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
;
break
;
case
eIntID_ScrollbarButtonAutoRepeatBehavior
:
aResult
=
0
;
break
;
case
eIntID_SwipeAnimationEnabled
:
aResult
=
0
;
break
;
case
eIntID_UseOverlayScrollbars
:
aResult
=
false
;
break
;
case
eIntID_AllowOverlayScrollbarsOverlap
:
aResult
=
0
;
break
;
case
eIntID_ScrollbarDisplayOnMouseMove
:
aResult
=
1
;
break
;
case
eIntID_ScrollbarFadeBeginDelay
:
aResult
=
2500
;
break
;
case
eIntID_ScrollbarFadeDuration
:
aResult
=
350
;
break
;
case
eIntID_ContextMenuOffsetVertical
:
case
eIntID_ContextMenuOffsetHorizontal
:
aResult
=
2
;
break
;
case
eIntID_SystemUsesDarkTheme
:
res
=
SystemWantsDarkTheme
(
aResult
)
;
break
;
case
eIntID_PrefersReducedMotion
:
{
BOOL
enableAnimation
=
TRUE
;
:
:
SystemParametersInfoW
(
SPI_GETCLIENTAREAANIMATION
0
&
enableAnimation
0
)
;
aResult
=
enableAnimation
?
0
:
1
;
break
;
}
case
eIntID_PrimaryPointerCapabilities
:
{
PointerCapabilities
caps
=
widget
:
:
WinUtils
:
:
GetPrimaryPointerCapabilities
(
)
;
aResult
=
static_cast
<
int32_t
>
(
caps
)
;
break
;
}
case
eIntID_AllPointerCapabilities
:
{
PointerCapabilities
caps
=
widget
:
:
WinUtils
:
:
GetAllPointerCapabilities
(
)
;
aResult
=
static_cast
<
int32_t
>
(
caps
)
;
break
;
}
default
:
aResult
=
0
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
nsresult
nsLookAndFeel
:
:
GetFloatImpl
(
FloatID
aID
float
&
aResult
)
{
nsresult
res
=
nsXPLookAndFeel
:
:
GetFloatImpl
(
aID
aResult
)
;
if
(
NS_SUCCEEDED
(
res
)
)
return
res
;
res
=
NS_OK
;
switch
(
aID
)
{
case
eFloatID_IMEUnderlineRelativeSize
:
aResult
=
1
.
0f
;
break
;
case
eFloatID_SpellCheckerUnderlineRelativeSize
:
aResult
=
1
.
0f
;
break
;
default
:
aResult
=
-
1
.
0
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
static
bool
GetSysFontInfo
(
HDC
aHDC
LookAndFeel
:
:
FontID
anID
nsString
&
aFontName
gfxFontStyle
&
aFontStyle
)
{
const
LOGFONTW
*
ptrLogFont
=
nullptr
;
LOGFONTW
logFont
;
NONCLIENTMETRICSW
ncm
;
char16_t
name
[
LF_FACESIZE
]
;
bool
useShellDlg
=
false
;
switch
(
anID
)
{
case
LookAndFeel
:
:
eFont_Icon
:
if
(
!
:
:
SystemParametersInfoW
(
SPI_GETICONTITLELOGFONT
sizeof
(
logFont
)
(
PVOID
)
&
logFont
0
)
)
return
false
;
ptrLogFont
=
&
logFont
;
break
;
default
:
ncm
.
cbSize
=
sizeof
(
NONCLIENTMETRICSW
)
;
if
(
!
:
:
SystemParametersInfoW
(
SPI_GETNONCLIENTMETRICS
sizeof
(
ncm
)
(
PVOID
)
&
ncm
0
)
)
return
false
;
switch
(
anID
)
{
case
LookAndFeel
:
:
eFont_Menu
:
case
LookAndFeel
:
:
eFont_PullDownMenu
:
ptrLogFont
=
&
ncm
.
lfMenuFont
;
break
;
case
LookAndFeel
:
:
eFont_Caption
:
ptrLogFont
=
&
ncm
.
lfCaptionFont
;
break
;
case
LookAndFeel
:
:
eFont_SmallCaption
:
ptrLogFont
=
&
ncm
.
lfSmCaptionFont
;
break
;
case
LookAndFeel
:
:
eFont_StatusBar
:
case
LookAndFeel
:
:
eFont_Tooltips
:
ptrLogFont
=
&
ncm
.
lfStatusFont
;
break
;
case
LookAndFeel
:
:
eFont_Widget
:
case
LookAndFeel
:
:
eFont_Dialog
:
case
LookAndFeel
:
:
eFont_Button
:
case
LookAndFeel
:
:
eFont_Field
:
case
LookAndFeel
:
:
eFont_List
:
useShellDlg
=
true
;
default
:
ptrLogFont
=
&
ncm
.
lfMessageFont
;
break
;
}
break
;
}
double
pixelScale
=
1
.
0
/
WinUtils
:
:
SystemScaleFactor
(
)
;
float
pixelHeight
=
-
ptrLogFont
-
>
lfHeight
;
if
(
pixelHeight
<
0
)
{
HFONT
hFont
=
:
:
CreateFontIndirectW
(
ptrLogFont
)
;
if
(
!
hFont
)
return
false
;
HGDIOBJ
hObject
=
:
:
SelectObject
(
aHDC
hFont
)
;
TEXTMETRIC
tm
;
:
:
GetTextMetrics
(
aHDC
&
tm
)
;
:
:
SelectObject
(
aHDC
hObject
)
;
:
:
DeleteObject
(
hFont
)
;
pixelHeight
=
tm
.
tmAscent
;
}
pixelHeight
*
=
pixelScale
;
if
(
pixelHeight
<
12
&
&
:
:
GetACP
(
)
=
=
936
)
pixelHeight
=
12
;
aFontStyle
.
size
=
pixelHeight
;
aFontStyle
.
style
=
(
ptrLogFont
-
>
lfItalic
)
?
FontSlantStyle
:
:
Italic
(
)
:
FontSlantStyle
:
:
Normal
(
)
;
aFontStyle
.
weight
=
(
ptrLogFont
-
>
lfWeight
=
=
FW_BOLD
?
FontWeight
:
:
Bold
(
)
:
FontWeight
:
:
Normal
(
)
)
;
aFontStyle
.
stretch
=
FontStretch
:
:
Normal
(
)
;
aFontStyle
.
systemFont
=
true
;
if
(
useShellDlg
)
{
aFontName
=
NS_LITERAL_STRING
(
"
MS
Shell
Dlg
2
"
)
;
}
else
{
memcpy
(
name
ptrLogFont
-
>
lfFaceName
LF_FACESIZE
*
sizeof
(
char16_t
)
)
;
aFontName
=
name
;
}
return
true
;
}
bool
nsLookAndFeel
:
:
GetFontImpl
(
FontID
anID
nsString
&
aFontName
gfxFontStyle
&
aFontStyle
)
{
CachedSystemFont
&
cacheSlot
=
mSystemFontCache
[
anID
]
;
bool
status
;
if
(
cacheSlot
.
mCacheValid
)
{
status
=
cacheSlot
.
mHaveFont
;
if
(
status
)
{
aFontName
=
cacheSlot
.
mFontName
;
aFontStyle
=
cacheSlot
.
mFontStyle
;
}
}
else
{
HDC
tdc
=
GetDC
(
nullptr
)
;
status
=
GetSysFontInfo
(
tdc
anID
aFontName
aFontStyle
)
;
ReleaseDC
(
nullptr
tdc
)
;
cacheSlot
.
mCacheValid
=
true
;
cacheSlot
.
mHaveFont
=
status
;
if
(
status
)
{
cacheSlot
.
mFontName
=
aFontName
;
cacheSlot
.
mFontStyle
=
aFontStyle
;
}
}
return
status
;
}
char16_t
nsLookAndFeel
:
:
GetPasswordCharacterImpl
(
)
{
#
define
UNICODE_BLACK_CIRCLE_CHAR
0x25cf
return
UNICODE_BLACK_CIRCLE_CHAR
;
}
nsTArray
<
LookAndFeelInt
>
nsLookAndFeel
:
:
GetIntCacheImpl
(
)
{
nsTArray
<
LookAndFeelInt
>
lookAndFeelIntCache
=
nsXPLookAndFeel
:
:
GetIntCacheImpl
(
)
;
LookAndFeelInt
lafInt
;
lafInt
.
id
=
eIntID_UseAccessibilityTheme
;
lafInt
.
value
=
GetInt
(
eIntID_UseAccessibilityTheme
)
;
lookAndFeelIntCache
.
AppendElement
(
lafInt
)
;
lafInt
.
id
=
eIntID_WindowsDefaultTheme
;
lafInt
.
value
=
GetInt
(
eIntID_WindowsDefaultTheme
)
;
lookAndFeelIntCache
.
AppendElement
(
lafInt
)
;
lafInt
.
id
=
eIntID_WindowsThemeIdentifier
;
lafInt
.
value
=
GetInt
(
eIntID_WindowsThemeIdentifier
)
;
lookAndFeelIntCache
.
AppendElement
(
lafInt
)
;
return
lookAndFeelIntCache
;
}
void
nsLookAndFeel
:
:
SetIntCacheImpl
(
const
nsTArray
<
LookAndFeelInt
>
&
aLookAndFeelIntCache
)
{
for
(
auto
entry
:
aLookAndFeelIntCache
)
{
switch
(
entry
.
id
)
{
case
eIntID_UseAccessibilityTheme
:
mUseAccessibilityTheme
=
entry
.
value
;
break
;
case
eIntID_WindowsDefaultTheme
:
mUseDefaultTheme
=
entry
.
value
;
break
;
case
eIntID_WindowsThemeIdentifier
:
mNativeThemeId
=
entry
.
value
;
break
;
}
}
}
nsresult
nsLookAndFeel
:
:
GetAccentColor
(
nscolor
&
aColor
)
{
nsresult
rv
;
if
(
!
mDwmKey
)
{
mDwmKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
mDwmKey
-
>
Open
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
NS_LITERAL_STRING
(
"
SOFTWARE
\
\
Microsoft
\
\
Windows
\
\
DWM
"
)
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uint32_t
accentColor
;
if
(
NS_SUCCEEDED
(
mDwmKey
-
>
ReadIntValue
(
NS_LITERAL_STRING
(
"
AccentColor
"
)
&
accentColor
)
)
)
{
aColor
=
accentColor
;
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
}
mDwmKey
-
>
Close
(
)
;
return
rv
;
}
nsresult
nsLookAndFeel
:
:
GetAccentColorText
(
nscolor
&
aColor
)
{
nscolor
accentColor
;
nsresult
rv
=
GetAccentColor
(
accentColor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
float
luminance
=
(
NS_GET_R
(
accentColor
)
*
2
+
NS_GET_G
(
accentColor
)
*
5
+
NS_GET_B
(
accentColor
)
)
/
8
;
aColor
=
(
luminance
<
=
128
)
?
NS_RGB
(
255
255
255
)
:
NS_RGB
(
0
0
0
)
;
return
NS_OK
;
}
nscolor
nsLookAndFeel
:
:
GetColorForSysColorIndex
(
int
index
)
{
MOZ_ASSERT
(
index
>
=
SYS_COLOR_MIN
&
&
index
<
=
SYS_COLOR_MAX
)
;
return
mSysColorTable
[
index
-
SYS_COLOR_MIN
]
;
}
void
nsLookAndFeel
:
:
EnsureInit
(
)
{
if
(
mInitialized
)
{
return
;
}
mInitialized
=
true
;
nsresult
res
;
res
=
GetAccentColor
(
mColorAccent
)
;
mHasColorAccent
=
NS_SUCCEEDED
(
res
)
;
res
=
GetAccentColorText
(
mColorAccentText
)
;
mHasColorAccentText
=
NS_SUCCEEDED
(
res
)
;
if
(
IsAppThemed
(
)
)
{
res
=
:
:
GetColorFromTheme
(
eUXMenu
MENU_POPUPITEM
MPI_HOT
TMT_TEXTCOLOR
mColorMenuHoverText
)
;
mHasColorMenuHoverText
=
NS_SUCCEEDED
(
res
)
;
res
=
:
:
GetColorFromTheme
(
eUXMediaToolbar
TP_BUTTON
TS_NORMAL
TMT_TEXTCOLOR
mColorMediaText
)
;
mHasColorMediaText
=
NS_SUCCEEDED
(
res
)
;
res
=
:
:
GetColorFromTheme
(
eUXCommunicationsToolbar
TP_BUTTON
TS_NORMAL
TMT_TEXTCOLOR
mColorCommunicationsText
)
;
mHasColorCommunicationsText
=
NS_SUCCEEDED
(
res
)
;
}
for
(
int
i
=
SYS_COLOR_MIN
;
i
<
=
SYS_COLOR_MAX
;
+
+
i
)
{
DWORD
color
=
:
:
GetSysColor
(
i
)
;
mSysColorTable
[
i
-
SYS_COLOR_MIN
]
=
COLOREF_2_NSRGB
(
color
)
;
}
}
