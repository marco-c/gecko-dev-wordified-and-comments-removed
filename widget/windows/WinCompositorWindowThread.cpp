#
include
"
base
/
platform_thread
.
h
"
#
include
"
WinCompositorWindowThread
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
layers
/
SynchronousTask
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
if
WINVER
<
0x0602
#
define
WS_EX_NOREDIRECTIONBITMAP
0x00200000L
#
endif
namespace
mozilla
{
namespace
widget
{
static
StaticRefPtr
<
WinCompositorWindowThread
>
sWinCompositorWindowThread
;
static
LRESULT
CALLBACK
InputEventRejectingWindowProc
(
HWND
window
UINT
msg
WPARAM
wparam
LPARAM
lparam
)
{
switch
(
msg
)
{
case
WM_LBUTTONDOWN
:
case
WM_LBUTTONUP
:
case
WM_RBUTTONDOWN
:
case
WM_RBUTTONUP
:
case
WM_MBUTTONDOWN
:
case
WM_MBUTTONUP
:
case
WM_MOUSEWHEEL
:
case
WM_MOUSEHWHEEL
:
case
WM_MOUSEMOVE
:
case
WM_KEYDOWN
:
case
WM_KEYUP
:
case
WM_SYSKEYDOWN
:
case
WM_SYSKEYUP
:
gfxCriticalNoteOnce
<
<
"
The
compositor
window
received
an
input
event
even
though
it
'
s
"
"
disabled
.
There
is
likely
malfunctioning
"
"
software
on
the
user
'
s
machine
.
"
;
break
;
default
:
break
;
}
return
:
:
DefWindowProcW
(
window
msg
wparam
lparam
)
;
}
WinCompositorWindowThread
:
:
WinCompositorWindowThread
(
base
:
:
Thread
*
aThread
)
:
mThread
(
aThread
)
mMonitor
(
"
WinCompositorWindowThread
"
)
{
}
WinCompositorWindowThread
*
WinCompositorWindowThread
:
:
Get
(
)
{
return
sWinCompositorWindowThread
;
}
void
WinCompositorWindowThread
:
:
Start
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
base
:
:
Thread
:
:
Options
options
;
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_UI
;
if
(
sWinCompositorWindowThread
)
{
sWinCompositorWindowThread
-
>
mThread
-
>
Stop
(
)
;
if
(
sWinCompositorWindowThread
-
>
mThread
-
>
StartWithOptions
(
options
)
)
{
return
;
}
sWinCompositorWindowThread
=
nullptr
;
}
base
:
:
Thread
*
thread
=
new
base
:
:
Thread
(
"
WinCompositor
"
)
;
if
(
!
thread
-
>
StartWithOptions
(
options
)
)
{
delete
thread
;
return
;
}
sWinCompositorWindowThread
=
new
WinCompositorWindowThread
(
thread
)
;
}
void
WinCompositorWindowThread
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
sWinCompositorWindowThread
)
;
static
const
TimeDuration
TIMEOUT
=
TimeDuration
:
:
FromSeconds
(
2
.
0
)
;
RefPtr
<
Runnable
>
runnable
=
NewRunnableMethod
(
"
WinCompositorWindowThread
:
:
ShutDownTask
"
sWinCompositorWindowThread
.
get
(
)
&
WinCompositorWindowThread
:
:
ShutDownTask
)
;
Loop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
CVStatus
status
;
{
MonitorAutoLock
lock
(
sWinCompositorWindowThread
-
>
mMonitor
)
;
status
=
sWinCompositorWindowThread
-
>
mMonitor
.
Wait
(
TIMEOUT
)
;
}
if
(
status
=
=
CVStatus
:
:
NoTimeout
)
{
sWinCompositorWindowThread
=
nullptr
;
}
}
void
WinCompositorWindowThread
:
:
ShutDownTask
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
IsInCompositorWindowThread
(
)
)
;
mMonitor
.
NotifyAll
(
)
;
}
MessageLoop
*
WinCompositorWindowThread
:
:
Loop
(
)
{
return
sWinCompositorWindowThread
?
sWinCompositorWindowThread
-
>
mThread
-
>
message_loop
(
)
:
nullptr
;
}
bool
WinCompositorWindowThread
:
:
IsInCompositorWindowThread
(
)
{
return
sWinCompositorWindowThread
&
&
sWinCompositorWindowThread
-
>
mThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
const
wchar_t
kClassNameCompositorInitalParent
[
]
=
L
"
MozillaCompositorInitialParentClass
"
;
const
wchar_t
kClassNameCompositor
[
]
=
L
"
MozillaCompositorWindowClass
"
;
ATOM
g_compositor_inital_parent_window_class
;
ATOM
g_compositor_window_class
;
void
InitializeInitialParentWindowClass
(
)
{
if
(
g_compositor_inital_parent_window_class
)
{
return
;
}
WNDCLASSW
wc
;
wc
.
style
=
0
;
wc
.
lpfnWndProc
=
:
:
DefWindowProcW
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
GetModuleHandle
(
nullptr
)
;
wc
.
hIcon
=
nullptr
;
wc
.
hCursor
=
nullptr
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
kClassNameCompositorInitalParent
;
g_compositor_inital_parent_window_class
=
:
:
RegisterClassW
(
&
wc
)
;
}
void
InitializeWindowClass
(
)
{
if
(
g_compositor_window_class
)
{
return
;
}
WNDCLASSW
wc
;
wc
.
style
=
CS_OWNDC
;
wc
.
lpfnWndProc
=
InputEventRejectingWindowProc
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
GetModuleHandle
(
nullptr
)
;
wc
.
hIcon
=
nullptr
;
wc
.
hCursor
=
nullptr
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
kClassNameCompositor
;
g_compositor_window_class
=
:
:
RegisterClassW
(
&
wc
)
;
}
WinCompositorWnds
WinCompositorWindowThread
:
:
CreateCompositorWindow
(
)
{
MOZ_ASSERT
(
Loop
(
)
)
;
if
(
!
Loop
(
)
)
{
return
WinCompositorWnds
(
nullptr
nullptr
)
;
}
layers
:
:
SynchronousTask
task
(
"
Create
compositor
window
"
)
;
HWND
initialParentWnd
=
nullptr
;
HWND
compositorWnd
=
nullptr
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
WinCompositorWindowThread
:
:
CreateCompositorWindow
:
:
Runnable
"
[
&
]
(
)
{
layers
:
:
AutoCompleteTask
complete
(
&
task
)
;
InitializeInitialParentWindowClass
(
)
;
InitializeWindowClass
(
)
;
initialParentWnd
=
:
:
CreateWindowEx
(
WS_EX_TOOLWINDOW
kClassNameCompositorInitalParent
nullptr
WS_POPUP
|
WS_DISABLED
0
0
1
1
nullptr
0
GetModuleHandle
(
nullptr
)
0
)
;
if
(
!
initialParentWnd
)
{
gfxCriticalNoteOnce
<
<
"
Inital
parent
window
failed
"
<
<
:
:
GetLastError
(
)
;
return
;
}
DWORD
extendedStyle
=
WS_EX_NOPARENTNOTIFY
|
WS_EX_NOREDIRECTIONBITMAP
;
if
(
!
StaticPrefs
:
:
apz_windows_force_disable_direct_manipulation
(
)
)
{
extendedStyle
|
=
WS_EX_LAYERED
|
WS_EX_TRANSPARENT
;
}
compositorWnd
=
:
:
CreateWindowEx
(
extendedStyle
kClassNameCompositor
nullptr
WS_CHILDWINDOW
|
WS_DISABLED
|
WS_VISIBLE
0
0
1
1
initialParentWnd
0
GetModuleHandle
(
nullptr
)
0
)
;
if
(
!
compositorWnd
)
{
gfxCriticalNoteOnce
<
<
"
Compositor
window
failed
"
<
<
:
:
GetLastError
(
)
;
}
}
)
;
Loop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
task
.
Wait
(
)
;
return
WinCompositorWnds
(
compositorWnd
initialParentWnd
)
;
}
void
WinCompositorWindowThread
:
:
DestroyCompositorWindow
(
WinCompositorWnds
aWnds
)
{
MOZ_ASSERT
(
aWnds
.
mCompositorWnd
)
;
MOZ_ASSERT
(
aWnds
.
mInitialParentWnd
)
;
MOZ_ASSERT
(
Loop
(
)
)
;
if
(
!
Loop
(
)
)
{
return
;
}
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
WinCompositorWidget
:
:
CreateNativeWindow
:
:
Runnable
"
[
aWnds
]
(
)
{
:
:
DestroyWindow
(
aWnds
.
mCompositorWnd
)
;
:
:
DestroyWindow
(
aWnds
.
mInitialParentWnd
)
;
}
)
;
Loop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
}
}
}
