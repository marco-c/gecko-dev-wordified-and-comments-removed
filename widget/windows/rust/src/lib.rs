use
nserror
:
:
{
nsresult
NS_OK
}
;
use
nsstring
:
:
{
nsAString
nsString
}
;
use
thin_vec
:
:
ThinVec
;
use
windows
:
:
core
:
:
HSTRING
;
use
windows
:
:
UI
:
:
Notifications
:
:
{
ToastNotification
ToastNotificationManager
}
;
use
windows_collections
:
:
IVectorView
;
use
xpcom
:
:
{
xpcom
xpcom_method
}
;
#
[
xpcom
(
implement
(
nsIAlertsServiceRust
)
nonatomic
)
]
struct
AlertsServiceRust
{
}
impl
AlertsServiceRust
{
xpcom_method
!
(
get_history
=
>
GetHistory
(
aumid
:
*
const
nsAString
result
:
*
mut
ThinVec
<
nsString
>
)
)
;
fn
get_history
(
&
self
aumid
:
&
nsAString
result
:
*
mut
ThinVec
<
nsString
>
)
-
>
Result
<
(
)
nsresult
>
{
if
result
=
=
std
:
:
ptr
:
:
null_mut
(
)
{
return
Err
(
nserror
:
:
NS_ERROR_INVALID_ARG
)
;
}
let
result
=
unsafe
{
&
mut
*
result
}
;
|
|
-
>
windows
:
:
core
:
:
Result
<
(
)
>
{
let
history
=
ToastNotificationManager
:
:
History
(
)
?
;
let
notifications
:
IVectorView
<
ToastNotification
>
=
history
.
GetHistoryWithId
(
&
HSTRING
:
:
from_wide
(
&
aumid
[
.
.
]
)
)
?
;
for
n
in
notifications
{
let
tag
=
n
.
Tag
(
)
?
;
result
.
push
(
(
&
tag
.
to_string
(
)
)
.
into
(
)
)
;
}
Ok
(
(
)
)
}
(
)
.
map_err
(
|
_
|
nserror
:
:
NS_ERROR_UNEXPECTED
)
}
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
new_windows_alerts_service
(
iid
:
*
const
xpcom
:
:
nsIID
result
:
*
mut
*
mut
xpcom
:
:
reexports
:
:
libc
:
:
c_void
)
-
>
nsresult
{
let
service
=
AlertsServiceRust
:
:
allocate
(
InitAlertsServiceRust
{
}
)
;
unsafe
{
service
.
QueryInterface
(
iid
result
)
}
}
