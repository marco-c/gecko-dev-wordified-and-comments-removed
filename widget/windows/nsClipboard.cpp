#
include
"
nsClipboard
.
h
"
#
include
<
shlobj
.
h
>
#
include
<
intshcut
.
h
>
#
include
<
shellapi
.
h
>
#
include
<
functional
>
#
include
<
thread
>
#
include
<
chrono
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_clipboard
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDataObj
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFileProtocolHandler
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
imgITools
.
h
"
using
mozilla
:
:
LogLevel
;
static
mozilla
:
:
LazyLogModule
gWin32ClipboardLog
(
"
nsClipboard
"
)
;
UINT
nsClipboard
:
:
GetHtmlClipboardFormat
(
)
{
static
UINT
format
=
:
:
RegisterClipboardFormatW
(
L
"
HTML
Format
"
)
;
return
format
;
}
UINT
nsClipboard
:
:
GetCustomClipboardFormat
(
)
{
static
UINT
format
=
:
:
RegisterClipboardFormatW
(
L
"
application
/
x
-
moz
-
custom
-
clipdata
"
)
;
return
format
;
}
nsClipboard
:
:
nsClipboard
(
)
:
nsBaseClipboard
(
)
{
mWindow
=
nullptr
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
NS_XPCOM_WILL_SHUTDOWN_OBSERVER_ID
PR_FALSE
)
;
}
}
nsClipboard
:
:
~
nsClipboard
(
)
{
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsClipboard
nsBaseClipboard
nsIObserver
)
NS_IMETHODIMP
nsClipboard
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
:
:
OleFlushClipboard
(
)
;
:
:
CloseClipboard
(
)
;
return
NS_OK
;
}
UINT
nsClipboard
:
:
GetFormat
(
const
char
*
aMimeStr
bool
aMapHTMLMime
)
{
UINT
format
;
if
(
strcmp
(
aMimeStr
kTextMime
)
=
=
0
)
{
format
=
CF_TEXT
;
}
else
if
(
strcmp
(
aMimeStr
kUnicodeMime
)
=
=
0
)
{
format
=
CF_UNICODETEXT
;
}
else
if
(
strcmp
(
aMimeStr
kRTFMime
)
=
=
0
)
{
format
=
:
:
RegisterClipboardFormat
(
L
"
Rich
Text
Format
"
)
;
}
else
if
(
strcmp
(
aMimeStr
kJPEGImageMime
)
=
=
0
|
|
strcmp
(
aMimeStr
kJPGImageMime
)
=
=
0
|
|
strcmp
(
aMimeStr
kPNGImageMime
)
=
=
0
)
{
format
=
CF_DIBV5
;
}
else
if
(
strcmp
(
aMimeStr
kFileMime
)
=
=
0
|
|
strcmp
(
aMimeStr
kFilePromiseMime
)
=
=
0
)
{
format
=
CF_HDROP
;
}
else
if
(
(
strcmp
(
aMimeStr
kNativeHTMLMime
)
=
=
0
)
|
|
(
aMapHTMLMime
&
&
strcmp
(
aMimeStr
kHTMLMime
)
=
=
0
)
)
{
format
=
GetHtmlClipboardFormat
(
)
;
}
else
if
(
strcmp
(
aMimeStr
kCustomTypesMime
)
=
=
0
)
{
format
=
GetCustomClipboardFormat
(
)
;
}
else
{
format
=
:
:
RegisterClipboardFormatW
(
NS_ConvertASCIItoUTF16
(
aMimeStr
)
.
get
(
)
)
;
}
return
format
;
}
nsresult
nsClipboard
:
:
CreateNativeDataObject
(
nsITransferable
*
aTransferable
IDataObject
*
*
aDataObj
nsIURI
*
uri
)
{
if
(
nullptr
=
=
aTransferable
)
{
return
NS_ERROR_FAILURE
;
}
nsDataObj
*
dataObj
=
new
nsDataObj
(
uri
)
;
if
(
!
dataObj
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
dataObj
-
>
AddRef
(
)
;
nsresult
res
=
SetupNativeDataObject
(
aTransferable
dataObj
)
;
if
(
NS_OK
=
=
res
)
{
*
aDataObj
=
dataObj
;
}
else
{
dataObj
-
>
Release
(
)
;
}
return
res
;
}
static
nsresult
StoreValueInDataObject
(
nsDataObj
*
aObj
LPCWSTR
aClipboardFormat
DWORD
value
)
{
HGLOBAL
hGlobalMemory
=
:
:
GlobalAlloc
(
GMEM_MOVEABLE
sizeof
(
DWORD
)
)
;
if
(
!
hGlobalMemory
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DWORD
*
pdw
=
(
DWORD
*
)
:
:
GlobalLock
(
hGlobalMemory
)
;
*
pdw
=
value
;
:
:
GlobalUnlock
(
hGlobalMemory
)
;
STGMEDIUM
stg
;
stg
.
tymed
=
TYMED_HGLOBAL
;
stg
.
pUnkForRelease
=
nullptr
;
stg
.
hGlobal
=
hGlobalMemory
;
FORMATETC
fe
;
SET_FORMATETC
(
fe
:
:
RegisterClipboardFormat
(
aClipboardFormat
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
aObj
-
>
SetData
(
&
fe
&
stg
TRUE
)
;
return
NS_OK
;
}
nsresult
nsClipboard
:
:
SetupNativeDataObject
(
nsITransferable
*
aTransferable
IDataObject
*
aDataObj
)
{
if
(
nullptr
=
=
aTransferable
|
|
nullptr
=
=
aDataObj
)
{
return
NS_ERROR_FAILURE
;
}
nsDataObj
*
dObj
=
static_cast
<
nsDataObj
*
>
(
aDataObj
)
;
dObj
-
>
SetTransferable
(
aTransferable
)
;
nsTArray
<
nsCString
>
flavors
;
aTransferable
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
i
+
+
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
UINT
format
=
GetFormat
(
flavorStr
.
get
(
)
false
)
;
FORMATETC
fe
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
dObj
-
>
AddDataFlavor
(
flavorStr
.
get
(
)
&
fe
)
;
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
FORMATETC
textFE
;
SET_FORMATETC
(
textFE
CF_TEXT
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
dObj
-
>
AddDataFlavor
(
kTextMime
&
textFE
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kHTMLMime
)
)
{
FORMATETC
htmlFE
;
SET_FORMATETC
(
htmlFE
GetHtmlClipboardFormat
(
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
dObj
-
>
AddDataFlavor
(
kHTMLMime
&
htmlFE
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
FORMATETC
shortcutFE
;
SET_FORMATETC
(
shortcutFE
:
:
RegisterClipboardFormat
(
CFSTR_FILEDESCRIPTORA
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
kURLMime
&
shortcutFE
)
;
SET_FORMATETC
(
shortcutFE
:
:
RegisterClipboardFormat
(
CFSTR_FILEDESCRIPTORW
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
kURLMime
&
shortcutFE
)
;
SET_FORMATETC
(
shortcutFE
:
:
RegisterClipboardFormat
(
CFSTR_FILECONTENTS
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
kURLMime
&
shortcutFE
)
;
SET_FORMATETC
(
shortcutFE
:
:
RegisterClipboardFormat
(
CFSTR_INETURLA
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
kURLMime
&
shortcutFE
)
;
SET_FORMATETC
(
shortcutFE
:
:
RegisterClipboardFormat
(
CFSTR_INETURLW
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
kURLMime
&
shortcutFE
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kPNGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kGIFImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kNativeImageMime
)
)
{
FORMATETC
imageFE
;
SET_FORMATETC
(
imageFE
CF_DIBV5
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
flavorStr
.
get
(
)
&
imageFE
)
;
SET_FORMATETC
(
imageFE
CF_DIB
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
flavorStr
.
get
(
)
&
imageFE
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kFilePromiseMime
)
)
{
FORMATETC
shortcutFE
;
SET_FORMATETC
(
shortcutFE
:
:
RegisterClipboardFormat
(
CFSTR_PREFERREDDROPEFFECT
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
dObj
-
>
AddDataFlavor
(
kFilePromiseMime
&
shortcutFE
)
;
}
}
if
(
!
StaticPrefs
:
:
clipboard_copyPrivateDataToClipboardCloudOrHistory
(
)
)
{
if
(
aTransferable
-
>
GetIsPrivateData
(
)
)
{
nsresult
rv
=
StoreValueInDataObject
(
dObj
TEXT
(
"
CanUploadToCloudClipboard
"
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
StoreValueInDataObject
(
dObj
TEXT
(
"
CanIncludeInClipboardHistory
"
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
StoreValueInDataObject
(
dObj
TEXT
(
"
ExcludeClipboardContentFromMonitorProcessing
"
)
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
static
void
IDataObjectMethodResultToString
(
const
HRESULT
aHres
nsACString
&
aResult
)
{
switch
(
aHres
)
{
case
E_INVALIDARG
:
aResult
=
"
E_INVALIDARG
"
;
break
;
case
E_UNEXPECTED
:
aResult
=
"
E_UNEXPECTED
"
;
break
;
case
E_OUTOFMEMORY
:
aResult
=
"
E_OUTOFMEMORY
"
;
break
;
case
DV_E_LINDEX
:
aResult
=
"
DV_E_LINDEX
"
;
break
;
case
DV_E_FORMATETC
:
aResult
=
"
DV_E_FORMATETC
"
;
break
;
case
DV_E_TYMED
:
aResult
=
"
DV_E_TYMED
"
;
break
;
case
DV_E_DVASPECT
:
aResult
=
"
DV_E_DVASPECT
"
;
break
;
case
OLE_E_NOTRUNNING
:
aResult
=
"
OLE_E_NOTRUNNING
"
;
break
;
case
STG_E_MEDIUMFULL
:
aResult
=
"
STG_E_MEDIUMFULL
"
;
break
;
case
DV_E_CLIPFORMAT
:
aResult
=
"
DV_E_CLIPFORMAT
"
;
break
;
case
S_OK
:
aResult
=
"
S_OK
"
;
break
;
default
:
constexpr
int
kRadix
=
16
;
aResult
=
IntToCString
<
int32_t
>
(
aHres
kRadix
)
;
break
;
}
}
static
void
OleGetClipboardResultToString
(
const
HRESULT
aHres
nsACString
&
aResult
)
{
switch
(
aHres
)
{
case
S_OK
:
aResult
=
"
S_OK
"
;
break
;
case
CLIPBRD_E_CANT_OPEN
:
aResult
=
"
CLIPBRD_E_CANT_OPEN
"
;
break
;
case
CLIPBRD_E_CANT_CLOSE
:
aResult
=
"
CLIPBRD_E_CANT_CLOSE
"
;
break
;
default
:
constexpr
int
kRadix
=
16
;
aResult
=
IntToCString
<
int32_t
>
(
aHres
kRadix
)
;
break
;
}
}
static
void
LogOleGetClipboardResult
(
const
HRESULT
aHres
)
{
if
(
MOZ_LOG_TEST
(
gWin32ClipboardLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
hresString
;
OleGetClipboardResultToString
(
aHres
hresString
)
;
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
OleGetClipboard
result
:
%
s
"
hresString
.
get
(
)
)
)
;
}
}
static
void
OleSetClipboardResultToString
(
HRESULT
aHres
nsACString
&
aResult
)
{
switch
(
aHres
)
{
case
S_OK
:
aResult
=
"
S_OK
"
;
break
;
case
CLIPBRD_E_CANT_OPEN
:
aResult
=
"
CLIPBRD_E_CANT_OPEN
"
;
break
;
case
CLIPBRD_E_CANT_EMPTY
:
aResult
=
"
CLIPBRD_E_CANT_EMPTY
"
;
break
;
case
CLIPBRD_E_CANT_CLOSE
:
aResult
=
"
CLIPBRD_E_CANT_CLOSE
"
;
break
;
case
CLIPBRD_E_CANT_SET
:
aResult
=
"
CLIPBRD_E_CANT_SET
"
;
break
;
default
:
constexpr
int
kRadix
=
16
;
aResult
=
IntToCString
<
int32_t
>
(
aHres
kRadix
)
;
break
;
}
}
static
void
LogOleSetClipboardResult
(
const
HRESULT
aHres
)
{
if
(
MOZ_LOG_TEST
(
gWin32ClipboardLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
hresString
;
OleSetClipboardResultToString
(
aHres
hresString
)
;
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
OleSetClipboard
result
:
%
s
"
hresString
.
get
(
)
)
)
;
}
}
template
<
typename
Function
typename
LogFunction
typename
.
.
.
Args
>
static
HRESULT
RepeatedlyTry
(
Function
aFunction
LogFunction
aLogFunction
Args
.
.
.
aArgs
)
{
static
constexpr
int
kNumberOfTries
=
3
;
static
constexpr
int
kDelayInMs
=
3
;
HRESULT
hres
;
for
(
int
i
=
0
;
i
<
kNumberOfTries
;
+
+
i
)
{
hres
=
aFunction
(
aArgs
.
.
.
)
;
aLogFunction
(
hres
)
;
if
(
hres
=
=
S_OK
)
{
break
;
}
std
:
:
this_thread
:
:
sleep_for
(
std
:
:
chrono
:
:
milliseconds
(
kDelayInMs
)
)
;
}
return
hres
;
}
static
void
RepeatedlyTryOleSetClipboard
(
IDataObject
*
aDataObj
)
{
RepeatedlyTry
(
:
:
OleSetClipboard
LogOleSetClipboardResult
aDataObj
)
;
}
NS_IMETHODIMP
nsClipboard
:
:
SetNativeClipboardData
(
int32_t
aWhichClipboard
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
if
(
aWhichClipboard
!
=
kGlobalClipboard
)
{
return
NS_ERROR_FAILURE
;
}
if
(
nullptr
=
=
mTransferable
)
{
return
NS_ERROR_FAILURE
;
}
IDataObject
*
dataObj
;
if
(
NS_SUCCEEDED
(
CreateNativeDataObject
(
mTransferable
&
dataObj
nullptr
)
)
)
{
RepeatedlyTryOleSetClipboard
(
dataObj
)
;
dataObj
-
>
Release
(
)
;
}
else
{
RepeatedlyTryOleSetClipboard
(
nullptr
)
;
}
return
NS_OK
;
}
nsresult
nsClipboard
:
:
GetGlobalData
(
HGLOBAL
aHGBL
void
*
*
aData
uint32_t
*
aLen
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Verbose
(
"
%
s
"
__FUNCTION__
)
)
;
nsresult
result
=
NS_ERROR_FAILURE
;
if
(
aHGBL
!
=
nullptr
)
{
LPSTR
lpStr
=
(
LPSTR
)
GlobalLock
(
aHGBL
)
;
mozilla
:
:
CheckedInt
<
uint32_t
>
allocSize
=
mozilla
:
:
CheckedInt
<
uint32_t
>
(
GlobalSize
(
aHGBL
)
)
+
3
;
if
(
!
allocSize
.
isValid
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
char
*
data
=
static_cast
<
char
*
>
(
malloc
(
allocSize
.
value
(
)
)
)
;
if
(
data
)
{
uint32_t
size
=
allocSize
.
value
(
)
-
3
;
memcpy
(
data
lpStr
size
)
;
data
[
size
]
=
data
[
size
+
1
]
=
data
[
size
+
2
]
=
'
\
0
'
;
GlobalUnlock
(
aHGBL
)
;
*
aData
=
data
;
*
aLen
=
size
;
result
=
NS_OK
;
}
}
else
{
*
aData
=
nullptr
;
*
aLen
=
0
;
LPVOID
lpMsgBuf
;
FormatMessageW
(
FORMAT_MESSAGE_ALLOCATE_BUFFER
|
FORMAT_MESSAGE_FROM_SYSTEM
nullptr
GetLastError
(
)
MAKELANGID
(
LANG_NEUTRAL
SUBLANG_DEFAULT
)
(
LPWSTR
)
&
lpMsgBuf
0
nullptr
)
;
MessageBoxW
(
nullptr
(
LPCWSTR
)
lpMsgBuf
L
"
GetLastError
"
MB_OK
|
MB_ICONINFORMATION
)
;
LocalFree
(
lpMsgBuf
)
;
}
return
result
;
}
nsresult
nsClipboard
:
:
GetNativeDataOffClipboard
(
nsIWidget
*
aWidget
UINT
UINT
aFormat
void
*
*
aData
uint32_t
*
aLen
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
:
overload
taking
nsIWidget
*
.
"
__FUNCTION__
)
)
;
HGLOBAL
hglb
;
nsresult
result
=
NS_ERROR_FAILURE
;
HWND
nativeWin
=
nullptr
;
if
(
:
:
OpenClipboard
(
nativeWin
)
)
{
hglb
=
:
:
GetClipboardData
(
aFormat
)
;
result
=
GetGlobalData
(
hglb
aData
aLen
)
;
:
:
CloseClipboard
(
)
;
}
return
result
;
}
static
void
LogIDataObjectMethodResult
(
const
HRESULT
aHres
const
nsCString
&
aMethodName
)
{
if
(
MOZ_LOG_TEST
(
gWin32ClipboardLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
hresString
;
IDataObjectMethodResultToString
(
aHres
hresString
)
;
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
IDataObject
:
:
%
s
result
:
%
s
"
aMethodName
.
get
(
)
hresString
.
get
(
)
)
)
;
}
}
static
HRESULT
RepeatedlyTryGetData
(
IDataObject
&
aDataObject
LPFORMATETC
pFE
LPSTGMEDIUM
pSTM
)
{
return
RepeatedlyTry
(
[
&
aDataObject
&
pFE
&
pSTM
]
(
)
{
return
aDataObject
.
GetData
(
pFE
pSTM
)
;
}
std
:
:
bind
(
LogIDataObjectMethodResult
std
:
:
placeholders
:
:
_1
"
GetData
"
_ns
)
)
;
}
HRESULT
nsClipboard
:
:
FillSTGMedium
(
IDataObject
*
aDataObject
UINT
aFormat
LPFORMATETC
pFE
LPSTGMEDIUM
pSTM
DWORD
aTymed
)
{
SET_FORMATETC
(
*
pFE
aFormat
0
DVASPECT_CONTENT
-
1
aTymed
)
;
HRESULT
hres
=
S_FALSE
;
hres
=
aDataObject
-
>
QueryGetData
(
pFE
)
;
LogIDataObjectMethodResult
(
hres
"
QueryGetData
"
_ns
)
;
if
(
S_OK
=
=
hres
)
{
hres
=
RepeatedlyTryGetData
(
*
aDataObject
pFE
pSTM
)
;
}
return
hres
;
}
nsresult
nsClipboard
:
:
GetNativeDataOffClipboard
(
IDataObject
*
aDataObject
UINT
aIndex
UINT
aFormat
const
char
*
aMIMEImageFormat
void
*
*
aData
uint32_t
*
aLen
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
:
overload
taking
IDataObject
*
.
"
__FUNCTION__
)
)
;
nsresult
result
=
NS_ERROR_FAILURE
;
*
aData
=
nullptr
;
*
aLen
=
0
;
if
(
!
aDataObject
)
{
return
result
;
}
UINT
format
=
aFormat
;
HRESULT
hres
=
S_FALSE
;
FORMATETC
fe
;
STGMEDIUM
stm
;
hres
=
FillSTGMedium
(
aDataObject
format
&
fe
&
stm
TYMED_HGLOBAL
)
;
if
(
S_OK
=
=
hres
)
{
static
CLIPFORMAT
fileDescriptorFlavorA
=
:
:
RegisterClipboardFormat
(
CFSTR_FILEDESCRIPTORA
)
;
static
CLIPFORMAT
fileDescriptorFlavorW
=
:
:
RegisterClipboardFormat
(
CFSTR_FILEDESCRIPTORW
)
;
static
CLIPFORMAT
fileFlavor
=
:
:
RegisterClipboardFormat
(
CFSTR_FILECONTENTS
)
;
static
CLIPFORMAT
preferredDropEffect
=
:
:
RegisterClipboardFormat
(
CFSTR_PREFERREDDROPEFFECT
)
;
switch
(
stm
.
tymed
)
{
case
TYMED_HGLOBAL
:
{
switch
(
fe
.
cfFormat
)
{
case
CF_TEXT
:
{
uint32_t
allocLen
=
0
;
if
(
NS_SUCCEEDED
(
GetGlobalData
(
stm
.
hGlobal
aData
&
allocLen
)
)
)
{
*
aLen
=
strlen
(
reinterpret_cast
<
char
*
>
(
*
aData
)
)
;
result
=
NS_OK
;
}
}
break
;
case
CF_UNICODETEXT
:
{
uint32_t
allocLen
=
0
;
if
(
NS_SUCCEEDED
(
GetGlobalData
(
stm
.
hGlobal
aData
&
allocLen
)
)
)
{
*
aLen
=
NS_strlen
(
reinterpret_cast
<
char16_t
*
>
(
*
aData
)
)
*
2
;
result
=
NS_OK
;
}
}
break
;
case
CF_DIBV5
:
if
(
aMIMEImageFormat
)
{
uint32_t
allocLen
=
0
;
const
char
*
clipboardData
;
if
(
NS_SUCCEEDED
(
GetGlobalData
(
stm
.
hGlobal
(
void
*
*
)
&
clipboardData
&
allocLen
)
)
)
{
nsCOMPtr
<
imgIContainer
>
container
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_CreateInstance
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
result
=
imgTools
-
>
DecodeImageFromBuffer
(
clipboardData
allocLen
nsLiteralCString
(
IMAGE_BMP_MS_CLIPBOARD
)
getter_AddRefs
(
container
)
)
;
if
(
NS_FAILED
(
result
)
)
{
break
;
}
nsAutoCString
mimeType
;
if
(
strcmp
(
aMIMEImageFormat
kJPGImageMime
)
=
=
0
)
{
mimeType
.
Assign
(
IMAGE_JPEG
)
;
}
else
{
mimeType
.
Assign
(
aMIMEImageFormat
)
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
result
=
imgTools
-
>
EncodeImage
(
container
mimeType
u
"
"
_ns
getter_AddRefs
(
inputStream
)
)
;
if
(
NS_FAILED
(
result
)
)
{
break
;
}
if
(
!
inputStream
)
{
result
=
NS_ERROR_FAILURE
;
break
;
}
*
aData
=
inputStream
.
forget
(
)
.
take
(
)
;
*
aLen
=
sizeof
(
nsIInputStream
*
)
;
}
}
break
;
case
CF_HDROP
:
{
HDROP
dropFiles
=
(
HDROP
)
GlobalLock
(
stm
.
hGlobal
)
;
UINT
numFiles
=
:
:
DragQueryFileW
(
dropFiles
0xFFFFFFFF
nullptr
0
)
;
NS_ASSERTION
(
numFiles
>
0
"
File
drop
flavor
but
no
files
.
.
.
hmmmm
"
)
;
NS_ASSERTION
(
aIndex
<
numFiles
"
Asked
for
a
file
index
out
of
range
of
list
"
)
;
if
(
numFiles
>
0
)
{
UINT
fileNameLen
=
:
:
DragQueryFileW
(
dropFiles
aIndex
nullptr
0
)
;
wchar_t
*
buffer
=
reinterpret_cast
<
wchar_t
*
>
(
moz_xmalloc
(
(
fileNameLen
+
1
)
*
sizeof
(
wchar_t
)
)
)
;
:
:
DragQueryFileW
(
dropFiles
aIndex
buffer
fileNameLen
+
1
)
;
*
aData
=
buffer
;
*
aLen
=
fileNameLen
*
sizeof
(
char16_t
)
;
result
=
NS_OK
;
}
GlobalUnlock
(
stm
.
hGlobal
)
;
}
break
;
default
:
{
if
(
fe
.
cfFormat
=
=
fileDescriptorFlavorA
|
|
fe
.
cfFormat
=
=
fileDescriptorFlavorW
|
|
fe
.
cfFormat
=
=
fileFlavor
)
{
NS_WARNING
(
"
Mozilla
doesn
'
t
yet
understand
how
to
read
this
type
of
"
"
file
flavor
"
)
;
}
else
{
uint32_t
allocLen
=
0
;
if
(
NS_SUCCEEDED
(
GetGlobalData
(
stm
.
hGlobal
aData
&
allocLen
)
)
)
{
if
(
fe
.
cfFormat
=
=
GetHtmlClipboardFormat
(
)
)
{
*
aLen
=
allocLen
;
}
else
if
(
fe
.
cfFormat
=
=
GetCustomClipboardFormat
(
)
)
{
*
aLen
=
allocLen
;
}
else
if
(
fe
.
cfFormat
=
=
preferredDropEffect
)
{
NS_ASSERTION
(
allocLen
=
=
sizeof
(
DWORD
)
"
CFSTR_PREFERREDDROPEFFECT
should
return
a
DWORD
"
)
;
*
aLen
=
allocLen
;
}
else
{
*
aLen
=
NS_strlen
(
reinterpret_cast
<
char16_t
*
>
(
*
aData
)
)
*
sizeof
(
char16_t
)
;
}
result
=
NS_OK
;
}
}
}
break
;
}
}
break
;
case
TYMED_GDI
:
{
#
ifdef
DEBUG
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Info
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
TYMED_GDI
\
n
"
)
)
;
#
endif
}
break
;
default
:
break
;
}
ReleaseStgMedium
(
&
stm
)
;
}
return
result
;
}
nsresult
nsClipboard
:
:
GetDataFromDataObject
(
IDataObject
*
aDataObject
UINT
anIndex
nsIWidget
*
aWindow
nsITransferable
*
aTransferable
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
if
(
!
aTransferable
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
res
=
NS_ERROR_FAILURE
;
nsTArray
<
nsCString
>
flavors
;
res
=
aTransferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
if
(
NS_FAILED
(
res
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
i
+
+
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
UINT
format
=
GetFormat
(
flavorStr
.
get
(
)
)
;
void
*
data
=
nullptr
;
uint32_t
dataLen
=
0
;
bool
dataFound
=
false
;
if
(
nullptr
!
=
aDataObject
)
{
if
(
NS_SUCCEEDED
(
GetNativeDataOffClipboard
(
aDataObject
anIndex
format
flavorStr
.
get
(
)
&
data
&
dataLen
)
)
)
{
dataFound
=
true
;
}
}
else
if
(
nullptr
!
=
aWindow
)
{
if
(
NS_SUCCEEDED
(
GetNativeDataOffClipboard
(
aWindow
anIndex
format
&
data
&
dataLen
)
)
)
{
dataFound
=
true
;
}
}
if
(
!
dataFound
)
{
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
dataFound
=
FindUnicodeFromPlainText
(
aDataObject
anIndex
&
data
&
dataLen
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
dataFound
=
FindURLFromNativeURL
(
aDataObject
anIndex
&
data
&
dataLen
)
;
if
(
!
dataFound
)
{
dataFound
=
FindURLFromLocalFile
(
aDataObject
anIndex
&
data
&
dataLen
)
;
}
}
}
if
(
dataFound
)
{
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
if
(
flavorStr
.
EqualsLiteral
(
kFileMime
)
)
{
nsDependentString
filepath
(
reinterpret_cast
<
char16_t
*
>
(
data
)
)
;
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_SUCCEEDED
(
NS_NewLocalFile
(
filepath
false
getter_AddRefs
(
file
)
)
)
)
{
genericDataWrapper
=
do_QueryInterface
(
file
)
;
}
free
(
data
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kNativeHTMLMime
)
)
{
uint32_t
dummy
;
if
(
FindPlatformHTML
(
aDataObject
anIndex
&
data
&
dummy
&
dataLen
)
)
{
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
flavorStr
data
dataLen
getter_AddRefs
(
genericDataWrapper
)
)
;
}
else
{
free
(
data
)
;
continue
;
}
free
(
data
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kHTMLMime
)
)
{
uint32_t
startOfData
=
0
;
if
(
FindPlatformHTML
(
aDataObject
anIndex
&
data
&
startOfData
&
dataLen
)
)
{
dataLen
-
=
startOfData
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForCFHTML
(
static_cast
<
char
*
>
(
data
)
+
startOfData
&
dataLen
getter_AddRefs
(
genericDataWrapper
)
)
;
}
else
{
free
(
data
)
;
continue
;
}
free
(
data
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kPNGImageMime
)
)
{
nsIInputStream
*
imageStream
=
reinterpret_cast
<
nsIInputStream
*
>
(
data
)
;
genericDataWrapper
=
do_QueryInterface
(
imageStream
)
;
NS_IF_RELEASE
(
imageStream
)
;
}
else
{
if
(
!
flavorStr
.
EqualsLiteral
(
kCustomTypesMime
)
)
{
int32_t
signedLen
=
static_cast
<
int32_t
>
(
dataLen
)
;
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
flavorStr
&
data
&
signedLen
)
;
dataLen
=
signedLen
;
if
(
flavorStr
.
EqualsLiteral
(
kRTFMime
)
)
{
if
(
dataLen
>
0
&
&
static_cast
<
char
*
>
(
data
)
[
dataLen
-
1
]
=
=
'
\
0
'
)
{
dataLen
-
-
;
}
}
}
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
flavorStr
data
dataLen
getter_AddRefs
(
genericDataWrapper
)
)
;
free
(
data
)
;
}
NS_ASSERTION
(
genericDataWrapper
"
About
to
put
null
data
into
the
transferable
"
)
;
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
genericDataWrapper
)
;
res
=
NS_OK
;
break
;
}
}
return
res
;
}
bool
nsClipboard
:
:
FindPlatformHTML
(
IDataObject
*
inDataObject
UINT
inIndex
void
*
*
outData
uint32_t
*
outStartOfData
uint32_t
*
outDataLen
)
{
if
(
!
outData
|
|
!
*
outData
)
{
return
false
;
}
char
version
[
8
]
=
{
0
}
;
int32_t
startOfData
=
0
;
int32_t
endOfData
=
0
;
int
numFound
=
sscanf
(
(
char
*
)
*
outData
"
Version
:
%
7s
\
nStartHTML
:
%
d
\
nEndHTML
:
%
d
"
version
&
startOfData
&
endOfData
)
;
if
(
numFound
!
=
3
|
|
startOfData
<
-
1
|
|
endOfData
<
-
1
)
{
return
false
;
}
if
(
startOfData
=
=
-
1
)
{
startOfData
=
0
;
}
if
(
endOfData
=
=
-
1
)
{
endOfData
=
*
outDataLen
;
}
if
(
!
endOfData
|
|
startOfData
>
=
endOfData
|
|
static_cast
<
uint32_t
>
(
endOfData
)
>
*
outDataLen
)
{
return
false
;
}
*
outStartOfData
=
startOfData
;
*
outDataLen
=
endOfData
;
return
true
;
}
bool
nsClipboard
:
:
FindUnicodeFromPlainText
(
IDataObject
*
inDataObject
UINT
inIndex
void
*
*
outData
uint32_t
*
outDataLen
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
nsresult
rv
=
GetNativeDataOffClipboard
(
inDataObject
inIndex
GetFormat
(
kTextMime
)
nullptr
outData
outDataLen
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
*
outData
)
{
return
false
;
}
const
char
*
castedText
=
static_cast
<
char
*
>
(
*
outData
)
;
nsAutoString
tmp
;
rv
=
NS_CopyNativeToUnicode
(
nsDependentCSubstring
(
castedText
*
outDataLen
)
tmp
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
free
(
*
outData
)
;
*
outData
=
ToNewUnicode
(
tmp
)
;
*
outDataLen
=
tmp
.
Length
(
)
*
sizeof
(
char16_t
)
;
return
true
;
}
bool
nsClipboard
:
:
FindURLFromLocalFile
(
IDataObject
*
inDataObject
UINT
inIndex
void
*
*
outData
uint32_t
*
outDataLen
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
bool
dataFound
=
false
;
nsresult
loadResult
=
GetNativeDataOffClipboard
(
inDataObject
inIndex
GetFormat
(
kFileMime
)
nullptr
outData
outDataLen
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
*
outData
)
{
const
nsDependentString
filepath
(
static_cast
<
char16_t
*
>
(
*
outData
)
)
;
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
NS_NewLocalFile
(
filepath
true
getter_AddRefs
(
file
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
free
(
*
outData
)
;
return
dataFound
;
}
if
(
IsInternetShortcut
(
filepath
)
)
{
free
(
*
outData
)
;
nsAutoCString
url
;
ResolveShortcut
(
file
url
)
;
if
(
!
url
.
IsEmpty
(
)
)
{
NS_ConvertUTF8toUTF16
urlString
(
url
)
;
nsAutoString
title
;
file
-
>
GetLeafName
(
title
)
;
title
.
SetLength
(
title
.
Length
(
)
-
4
)
;
if
(
title
.
IsEmpty
(
)
)
{
title
=
urlString
;
}
*
outData
=
ToNewUnicode
(
urlString
+
u
"
\
n
"
_ns
+
title
)
;
*
outDataLen
=
NS_strlen
(
static_cast
<
char16_t
*
>
(
*
outData
)
)
*
sizeof
(
char16_t
)
;
dataFound
=
true
;
}
}
else
{
nsAutoCString
urlSpec
;
NS_GetURLSpecFromFile
(
file
urlSpec
)
;
free
(
*
outData
)
;
*
outData
=
UTF8ToNewUnicode
(
urlSpec
)
;
*
outDataLen
=
NS_strlen
(
static_cast
<
char16_t
*
>
(
*
outData
)
)
*
sizeof
(
char16_t
)
;
dataFound
=
true
;
}
}
return
dataFound
;
}
bool
nsClipboard
:
:
FindURLFromNativeURL
(
IDataObject
*
inDataObject
UINT
inIndex
void
*
*
outData
uint32_t
*
outDataLen
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
"
__FUNCTION__
)
)
;
bool
dataFound
=
false
;
void
*
tempOutData
=
nullptr
;
uint32_t
tempDataLen
=
0
;
nsresult
loadResult
=
GetNativeDataOffClipboard
(
inDataObject
inIndex
:
:
RegisterClipboardFormat
(
CFSTR_INETURLW
)
nullptr
&
tempOutData
&
tempDataLen
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
tempOutData
)
{
nsDependentString
urlString
(
static_cast
<
char16_t
*
>
(
tempOutData
)
)
;
*
outData
=
ToNewUnicode
(
urlString
+
u
"
\
n
"
_ns
+
urlString
)
;
*
outDataLen
=
NS_strlen
(
static_cast
<
char16_t
*
>
(
*
outData
)
)
*
sizeof
(
char16_t
)
;
free
(
tempOutData
)
;
dataFound
=
true
;
}
else
{
loadResult
=
GetNativeDataOffClipboard
(
inDataObject
inIndex
:
:
RegisterClipboardFormat
(
CFSTR_INETURLA
)
nullptr
&
tempOutData
&
tempDataLen
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
tempOutData
)
{
nsCString
urlUnescapedA
;
bool
unescaped
=
NS_UnescapeURL
(
static_cast
<
char
*
>
(
tempOutData
)
tempDataLen
esc_OnlyNonASCII
|
esc_SkipControl
urlUnescapedA
)
;
nsString
urlString
;
if
(
unescaped
)
{
NS_CopyNativeToUnicode
(
urlUnescapedA
urlString
)
;
}
else
{
NS_CopyNativeToUnicode
(
nsDependentCString
(
static_cast
<
char
*
>
(
tempOutData
)
tempDataLen
)
urlString
)
;
}
*
outData
=
ToNewUnicode
(
urlString
+
u
"
\
n
"
_ns
+
urlString
)
;
*
outDataLen
=
NS_strlen
(
static_cast
<
char16_t
*
>
(
*
outData
)
)
*
sizeof
(
char16_t
)
;
free
(
tempOutData
)
;
dataFound
=
true
;
}
}
return
dataFound
;
}
static
HRESULT
RepeatedlyTryOleGetClipboard
(
IDataObject
*
*
aDataObj
)
{
return
RepeatedlyTry
(
:
:
OleGetClipboard
LogOleGetClipboardResult
aDataObj
)
;
}
void
nsClipboard
:
:
ResolveShortcut
(
nsIFile
*
aFile
nsACString
&
outURL
)
{
nsCOMPtr
<
nsIFileProtocolHandler
>
fph
;
nsresult
rv
=
NS_GetFileProtocolHandler
(
getter_AddRefs
(
fph
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
fph
-
>
ReadURLFile
(
aFile
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
uri
-
>
GetSpec
(
outURL
)
;
}
bool
nsClipboard
:
:
IsInternetShortcut
(
const
nsAString
&
inFileName
)
{
return
StringEndsWith
(
inFileName
u
"
.
url
"
_ns
nsCaseInsensitiveStringComparator
)
;
}
NS_IMETHODIMP
nsClipboard
:
:
GetNativeClipboardData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Debug
(
"
%
s
aWhichClipboard
=
%
i
"
__FUNCTION__
aWhichClipboard
)
)
;
if
(
!
aTransferable
|
|
aWhichClipboard
!
=
kGlobalClipboard
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
res
;
IDataObject
*
dataObj
;
if
(
S_OK
=
=
RepeatedlyTryOleGetClipboard
(
&
dataObj
)
)
{
MOZ_LOG
(
gWin32ClipboardLog
LogLevel
:
:
Verbose
(
"
%
s
:
use
OLE
IDataObject
.
"
__FUNCTION__
)
)
;
res
=
GetDataFromDataObject
(
dataObj
0
nullptr
aTransferable
)
;
dataObj
-
>
Release
(
)
;
}
else
{
res
=
GetDataFromDataObject
(
nullptr
0
mWindow
aTransferable
)
;
}
return
res
;
}
NS_IMETHODIMP
nsClipboard
:
:
EmptyClipboard
(
int32_t
aWhichClipboard
)
{
if
(
aWhichClipboard
=
=
kGlobalClipboard
&
&
!
mEmptyingForSetData
)
{
RepeatedlyTryOleSetClipboard
(
nullptr
)
;
}
return
nsBaseClipboard
:
:
EmptyClipboard
(
aWhichClipboard
)
;
}
NS_IMETHODIMP
nsClipboard
:
:
HasDataMatchingFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
bool
*
_retval
)
{
*
_retval
=
false
;
if
(
aWhichClipboard
!
=
kGlobalClipboard
)
{
return
NS_OK
;
}
for
(
auto
&
flavor
:
aFlavorList
)
{
#
ifdef
DEBUG
if
(
flavor
.
EqualsLiteral
(
kTextMime
)
)
{
NS_WARNING
(
"
DO
NOT
USE
THE
text
/
plain
DATA
FLAVOR
ANY
MORE
.
USE
text
/
unicode
"
"
INSTEAD
"
)
;
}
#
endif
UINT
format
=
GetFormat
(
flavor
.
get
(
)
)
;
if
(
IsClipboardFormatAvailable
(
format
)
)
{
*
_retval
=
true
;
break
;
}
else
{
if
(
flavor
.
EqualsLiteral
(
kUnicodeMime
)
)
{
if
(
IsClipboardFormatAvailable
(
GetFormat
(
kTextMime
)
)
)
{
*
_retval
=
true
;
break
;
}
}
}
}
return
NS_OK
;
}
