#
include
<
strsafe
.
h
>
#
include
"
SystemStatusBar
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
widget
/
IconLoader
.
h
"
#
include
"
mozilla
/
widget
/
NativeMenu
.
h
"
#
include
"
mozilla
/
dom
/
XULButtonElement
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsWindowGfx
.
h
"
#
include
"
shellapi
.
h
"
namespace
mozilla
:
:
widget
{
using
mozilla
:
:
LinkedListElement
;
using
mozilla
:
:
dom
:
:
Element
;
class
StatusBarEntry
final
:
public
LinkedListElement
<
RefPtr
<
StatusBarEntry
>
>
public
IconLoader
:
:
Listener
public
nsISupports
{
public
:
explicit
StatusBarEntry
(
Element
*
aMenu
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
StatusBarEntry
)
nsresult
Init
(
)
;
void
Destroy
(
)
;
MOZ_CAN_RUN_SCRIPT
LRESULT
OnMessage
(
HWND
hWnd
UINT
msg
WPARAM
wp
LPARAM
lp
)
;
const
Element
*
GetMenu
(
)
{
return
mMenu
;
}
;
nsresult
OnComplete
(
imgIContainer
*
aImage
)
override
;
private
:
~
StatusBarEntry
(
)
;
RefPtr
<
mozilla
:
:
widget
:
:
IconLoader
>
mIconLoader
;
MOZ_KNOWN_LIVE
RefPtr
<
Element
>
mMenu
;
NOTIFYICONDATAW
mIconData
;
boolean
mInitted
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
StatusBarEntry
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
StatusBarEntry
)
tmp
-
>
Destroy
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
StatusBarEntry
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIconLoader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMenu
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
StatusBarEntry
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
StatusBarEntry
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
StatusBarEntry
)
StatusBarEntry
:
:
StatusBarEntry
(
Element
*
aMenu
)
:
mMenu
(
aMenu
)
mInitted
(
false
)
{
mIconData
=
{
sizeof
(
NOTIFYICONDATA
)
0
2
NIF_ICON
|
NIF_MESSAGE
|
NIF_TIP
|
NIF_SHOWTIP
WM_USER
0
L
"
"
0
0
L
"
"
{
NOTIFYICON_VERSION_4
}
L
"
"
0
}
;
MOZ_ASSERT
(
mMenu
)
;
}
StatusBarEntry
:
:
~
StatusBarEntry
(
)
{
if
(
!
mInitted
)
{
return
;
}
Destroy
(
)
;
:
:
Shell_NotifyIconW
(
NIM_DELETE
&
mIconData
)
;
VERIFY
(
:
:
DestroyWindow
(
mIconData
.
hWnd
)
)
;
}
void
StatusBarEntry
:
:
Destroy
(
)
{
if
(
mIconLoader
)
{
mIconLoader
-
>
Destroy
(
)
;
mIconLoader
=
nullptr
;
}
}
nsresult
StatusBarEntry
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIconLoader
=
new
IconLoader
(
this
)
;
if
(
auto
icon
=
NativeMenu
:
:
GetIcon
(
*
mMenu
)
)
{
mIconLoader
-
>
LoadIcon
(
icon
.
mURI
mMenu
)
;
}
HWND
iconWindow
;
NS_ENSURE_TRUE
(
iconWindow
=
:
:
CreateWindowExW
(
0
L
"
IconWindowClass
"
0
WS_CAPTION
0
0
0
0
0
0
0
0
)
NS_ERROR_FAILURE
)
;
:
:
SetWindowLongPtr
(
iconWindow
GWLP_USERDATA
(
LONG_PTR
)
this
)
;
mIconData
.
hWnd
=
iconWindow
;
mIconData
.
hIcon
=
:
:
LoadIcon
(
:
:
GetModuleHandle
(
NULL
)
IDI_APPLICATION
)
;
nsAutoString
labelAttr
;
mMenu
-
>
GetAttr
(
nsGkAtoms
:
:
label
labelAttr
)
;
const
nsString
&
label
=
PromiseFlatString
(
labelAttr
)
;
size_t
destLength
=
sizeof
mIconData
.
szTip
/
(
sizeof
mIconData
.
szTip
[
0
]
)
;
wchar_t
*
tooltip
=
&
(
mIconData
.
szTip
[
0
]
)
;
:
:
StringCchCopyNW
(
tooltip
destLength
label
.
get
(
)
label
.
Length
(
)
)
;
:
:
Shell_NotifyIconW
(
NIM_ADD
&
mIconData
)
;
:
:
Shell_NotifyIconW
(
NIM_SETVERSION
&
mIconData
)
;
mInitted
=
true
;
return
NS_OK
;
}
nsresult
StatusBarEntry
:
:
OnComplete
(
imgIContainer
*
aImage
)
{
NS_ENSURE_ARG_POINTER
(
aImage
)
;
RefPtr
<
StatusBarEntry
>
kungFuDeathGrip
=
this
;
nsresult
rv
=
nsWindowGfx
:
:
CreateIcon
(
aImage
nullptr
false
LayoutDeviceIntPoint
(
)
nsWindowGfx
:
:
GetIconMetrics
(
nsWindowGfx
:
:
kRegularIcon
)
&
mIconData
.
hIcon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
:
:
Shell_NotifyIconW
(
NIM_MODIFY
&
mIconData
)
;
if
(
mIconData
.
hIcon
)
{
:
:
DestroyIcon
(
mIconData
.
hIcon
)
;
mIconData
.
hIcon
=
nullptr
;
}
mIconLoader
-
>
Destroy
(
)
;
mIconLoader
=
nullptr
;
return
NS_OK
;
}
LRESULT
StatusBarEntry
:
:
OnMessage
(
HWND
hWnd
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
if
(
msg
=
=
WM_USER
&
&
(
LOWORD
(
lp
)
=
=
NIN_SELECT
|
|
LOWORD
(
lp
)
=
=
NIN_KEYSELECT
|
|
LOWORD
(
lp
)
=
=
WM_CONTEXTMENU
)
)
{
auto
*
menu
=
dom
:
:
XULButtonElement
:
:
FromNode
(
mMenu
)
;
if
(
!
menu
)
{
return
TRUE
;
}
nsMenuPopupFrame
*
popupFrame
=
menu
-
>
GetMenuPopup
(
FlushType
:
:
None
)
;
if
(
NS_WARN_IF
(
!
popupFrame
)
)
{
return
TRUE
;
}
nsIWidget
*
widget
=
popupFrame
-
>
GetNearestWidget
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
widget
)
;
if
(
!
widget
)
{
return
TRUE
;
}
HWND
win
=
static_cast
<
HWND
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
win
)
;
if
(
!
win
)
{
return
TRUE
;
}
if
(
LOWORD
(
lp
)
=
=
NIN_KEYSELECT
&
&
:
:
GetForegroundWindow
(
)
=
=
win
)
{
return
TRUE
;
}
if
(
LOWORD
(
lp
)
!
=
WM_CONTEXTMENU
&
&
mMenu
-
>
HasAttr
(
nsGkAtoms
:
:
contextmenu
)
)
{
:
:
SetForegroundWindow
(
win
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULSystemStatusBarClick
nullptr
WidgetMouseEvent
:
:
eReal
)
;
RefPtr
<
nsPresContext
>
presContext
=
popupFrame
-
>
PresContext
(
)
;
EventDispatcher
:
:
Dispatch
(
mMenu
presContext
&
event
nullptr
&
status
)
;
return
DefWindowProc
(
hWnd
msg
wp
lp
)
;
}
nsPresContext
*
pc
=
popupFrame
-
>
PresContext
(
)
;
const
CSSIntPoint
point
=
gfx
:
:
RoundedToInt
(
LayoutDeviceIntPoint
(
GET_X_LPARAM
(
wp
)
GET_Y_LPARAM
(
wp
)
)
/
pc
-
>
CSSToDevPixelScale
(
)
)
;
:
:
SetForegroundWindow
(
win
)
;
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
pm
-
>
ShowPopupAtScreen
(
popupFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
point
.
x
point
.
y
false
nullptr
)
;
}
return
DefWindowProc
(
hWnd
msg
wp
lp
)
;
}
NS_IMPL_ISUPPORTS
(
SystemStatusBar
nsISystemStatusBar
)
MOZ_CAN_RUN_SCRIPT
static
LRESULT
CALLBACK
WindowProc
(
HWND
hWnd
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
if
(
RefPtr
<
StatusBarEntry
>
entry
=
(
StatusBarEntry
*
)
GetWindowLongPtr
(
hWnd
GWLP_USERDATA
)
)
{
return
entry
-
>
OnMessage
(
hWnd
msg
wp
lp
)
;
}
return
TRUE
;
}
static
StaticRefPtr
<
SystemStatusBar
>
sSingleton
;
SystemStatusBar
&
SystemStatusBar
:
:
GetSingleton
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
new
SystemStatusBar
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
*
sSingleton
;
}
already_AddRefed
<
SystemStatusBar
>
SystemStatusBar
:
:
GetAddRefedSingleton
(
)
{
RefPtr
<
SystemStatusBar
>
sm
=
&
GetSingleton
(
)
;
return
sm
.
forget
(
)
;
}
nsresult
SystemStatusBar
:
:
Init
(
)
{
WNDCLASS
classStruct
=
{
0
&
WindowProc
0
0
0
0
0
0
0
L
"
IconWindowClass
"
}
;
NS_ENSURE_TRUE
(
:
:
RegisterClass
(
&
classStruct
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SystemStatusBar
:
:
AddItem
(
Element
*
aElement
)
{
RefPtr
<
StatusBarEntry
>
entry
=
new
StatusBarEntry
(
aElement
)
;
nsresult
rv
=
entry
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStatusBarEntries
.
insertBack
(
entry
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SystemStatusBar
:
:
RemoveItem
(
Element
*
aElement
)
{
for
(
StatusBarEntry
*
entry
:
mStatusBarEntries
)
{
if
(
entry
-
>
GetMenu
(
)
=
=
aElement
)
{
entry
-
>
removeFrom
(
mStatusBarEntries
)
;
return
NS_OK
;
}
}
return
NS_ERROR_NOT_AVAILABLE
;
}
}
