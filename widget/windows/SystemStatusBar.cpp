#
include
<
strsafe
.
h
>
#
include
"
SystemStatusBar
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
IconLoaderHelperWin
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShell
.
h
"
namespace
mozilla
:
:
widget
{
using
mozilla
:
:
LinkedListElement
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
widget
:
:
IconLoaderListenerWin
;
class
StatusBarEntry
final
:
public
LinkedListElement
<
RefPtr
<
StatusBarEntry
>
>
public
IconLoaderListenerWin
{
public
:
explicit
StatusBarEntry
(
Element
*
aMenu
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
StatusBarEntry
)
nsresult
Init
(
)
;
LRESULT
OnMessage
(
HWND
hWnd
UINT
msg
WPARAM
wp
LPARAM
lp
)
;
const
Element
*
GetMenu
(
)
{
return
mMenu
;
}
;
nsresult
OnComplete
(
)
;
private
:
~
StatusBarEntry
(
)
;
RefPtr
<
mozilla
:
:
widget
:
:
IconLoader
>
mIconLoader
;
RefPtr
<
mozilla
:
:
widget
:
:
IconLoaderHelperWin
>
mIconLoaderHelper
;
RefPtr
<
Element
>
mMenu
;
NOTIFYICONDATAW
mIconData
;
boolean
mInitted
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
StatusBarEntry
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
StatusBarEntry
)
tmp
-
>
OnComplete
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
StatusBarEntry
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIconLoader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIconLoaderHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMenu
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
StatusBarEntry
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
StatusBarEntry
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
StatusBarEntry
)
StatusBarEntry
:
:
StatusBarEntry
(
Element
*
aMenu
)
:
mMenu
(
aMenu
)
mInitted
(
false
)
{
mIconData
=
{
sizeof
(
NOTIFYICONDATA
)
0
2
NIF_ICON
|
NIF_MESSAGE
|
NIF_TIP
|
NIF_SHOWTIP
WM_USER
0
L
"
"
0
0
L
"
"
{
NOTIFYICON_VERSION_4
}
L
"
"
0
}
;
MOZ_ASSERT
(
mMenu
)
;
}
StatusBarEntry
:
:
~
StatusBarEntry
(
)
{
if
(
!
mInitted
)
{
return
;
}
:
:
Shell_NotifyIconW
(
NIM_DELETE
&
mIconData
)
;
VERIFY
(
:
:
DestroyWindow
(
mIconData
.
hWnd
)
)
;
}
nsresult
StatusBarEntry
:
:
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsAutoString
imageURIString
;
bool
hasImageAttr
=
mMenu
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
image
imageURIString
)
;
nsresult
rv
;
RefPtr
<
ComputedStyle
>
sc
;
nsCOMPtr
<
nsIURI
>
iconURI
;
if
(
!
hasImageAttr
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
document
=
mMenu
-
>
GetComposedDoc
(
)
;
if
(
!
document
)
{
return
NS_ERROR_FAILURE
;
}
sc
=
nsComputedDOMStyle
:
:
GetComputedStyle
(
mMenu
nullptr
)
;
if
(
!
sc
)
{
return
NS_ERROR_FAILURE
;
}
iconURI
=
sc
-
>
StyleList
(
)
-
>
GetListStyleImageURI
(
)
;
}
else
{
uint64_t
dummy
=
0
;
nsContentPolicyType
policyType
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
mMenu
-
>
NodePrincipal
(
)
;
nsContentUtils
:
:
GetContentPolicyTypeForUIImageLoading
(
mMenu
getter_AddRefs
(
triggeringPrincipal
)
policyType
&
dummy
)
;
if
(
policyType
!
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
iconURI
)
imageURIString
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
mIconLoaderHelper
=
new
IconLoaderHelperWin
(
this
)
;
nsIntRect
rect
;
mIconLoader
=
new
IconLoader
(
mIconLoaderHelper
rect
)
;
if
(
iconURI
)
{
rv
=
mIconLoader
-
>
LoadIcon
(
iconURI
mMenu
)
;
}
HWND
iconWindow
;
NS_ENSURE_TRUE
(
iconWindow
=
:
:
CreateWindowExW
(
0
L
"
IconWindowClass
"
0
WS_CAPTION
0
0
0
0
0
0
0
0
)
NS_ERROR_FAILURE
)
;
:
:
SetWindowLongPtr
(
iconWindow
GWLP_USERDATA
(
LONG_PTR
)
this
)
;
mIconData
.
hWnd
=
iconWindow
;
mIconData
.
hIcon
=
mIconLoaderHelper
-
>
GetNativeIconImage
(
)
;
nsAutoString
labelAttr
;
mMenu
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
labelAttr
)
;
const
nsString
&
label
=
PromiseFlatString
(
labelAttr
)
;
size_t
destLength
=
sizeof
mIconData
.
szTip
/
(
sizeof
mIconData
.
szTip
[
0
]
)
;
wchar_t
*
tooltip
=
&
(
mIconData
.
szTip
[
0
]
)
;
:
:
StringCchCopyNW
(
tooltip
destLength
label
.
get
(
)
label
.
Length
(
)
)
;
:
:
Shell_NotifyIconW
(
NIM_ADD
&
mIconData
)
;
:
:
Shell_NotifyIconW
(
NIM_SETVERSION
&
mIconData
)
;
mInitted
=
true
;
return
NS_OK
;
}
nsresult
StatusBarEntry
:
:
OnComplete
(
)
{
RefPtr
<
StatusBarEntry
>
kungFuDeathGrip
=
this
;
mIconData
.
hIcon
=
mIconLoaderHelper
-
>
GetNativeIconImage
(
)
;
:
:
Shell_NotifyIconW
(
NIM_MODIFY
&
mIconData
)
;
mIconLoaderHelper
-
>
Destroy
(
)
;
mIconLoader
-
>
Destroy
(
)
;
mIconLoader
=
nullptr
;
mIconLoaderHelper
=
nullptr
;
return
NS_OK
;
}
LRESULT
StatusBarEntry
:
:
OnMessage
(
HWND
hWnd
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
if
(
msg
=
=
WM_USER
&
&
(
LOWORD
(
lp
)
=
=
WM_LBUTTONUP
|
|
LOWORD
(
lp
)
=
=
WM_RBUTTONUP
)
)
{
nsMenuFrame
*
menu
=
do_QueryFrame
(
mMenu
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
menu
)
{
return
TRUE
;
}
nsMenuPopupFrame
*
popupFrame
=
menu
-
>
GetPopup
(
)
;
if
(
!
popupFrame
)
{
return
TRUE
;
}
nsIWidget
*
widget
=
popupFrame
-
>
GetNearestWidget
(
)
;
if
(
!
widget
)
{
return
TRUE
;
}
HWND
win
=
static_cast
<
HWND
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
if
(
!
win
)
{
return
TRUE
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
popupFrame
-
>
PresContext
(
)
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWin
=
do_QueryInterface
(
docShell
)
;
if
(
!
baseWin
)
{
return
TRUE
;
}
double
scale
=
1
.
0
;
baseWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
int32_t
x
=
NSToIntRound
(
GET_X_LPARAM
(
wp
)
/
scale
)
;
int32_t
y
=
NSToIntRound
(
GET_Y_LPARAM
(
wp
)
/
scale
)
;
:
:
SetForegroundWindow
(
win
)
;
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
pm
-
>
ShowPopupAtScreen
(
popupFrame
-
>
GetContent
(
)
x
y
false
nullptr
)
;
}
return
DefWindowProc
(
hWnd
msg
wp
lp
)
;
}
NS_IMPL_ISUPPORTS
(
SystemStatusBar
nsISystemStatusBar
)
static
LRESULT
CALLBACK
WindowProc
(
HWND
hWnd
UINT
msg
WPARAM
wp
LPARAM
lp
)
{
StatusBarEntry
*
entry
=
(
StatusBarEntry
*
)
GetWindowLongPtr
(
hWnd
GWLP_USERDATA
)
;
if
(
entry
)
{
return
entry
-
>
OnMessage
(
hWnd
msg
wp
lp
)
;
}
return
TRUE
;
}
static
StaticRefPtr
<
SystemStatusBar
>
sSingleton
;
SystemStatusBar
&
SystemStatusBar
:
:
GetSingleton
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
new
SystemStatusBar
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
*
sSingleton
;
}
already_AddRefed
<
SystemStatusBar
>
SystemStatusBar
:
:
GetAddRefedSingleton
(
)
{
RefPtr
<
SystemStatusBar
>
sm
=
&
GetSingleton
(
)
;
return
sm
.
forget
(
)
;
}
nsresult
SystemStatusBar
:
:
Init
(
)
{
WNDCLASS
classStruct
=
{
0
&
WindowProc
0
0
0
0
0
0
0
L
"
IconWindowClass
"
}
;
NS_ENSURE_TRUE
(
:
:
RegisterClass
(
&
classStruct
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SystemStatusBar
:
:
AddItem
(
Element
*
aElement
)
{
RefPtr
<
StatusBarEntry
>
entry
=
new
StatusBarEntry
(
aElement
)
;
nsresult
rv
=
entry
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStatusBarEntries
.
insertBack
(
entry
)
;
return
NS_OK
;
}
NS_IMETHODIMP
SystemStatusBar
:
:
RemoveItem
(
Element
*
aElement
)
{
for
(
StatusBarEntry
*
entry
:
mStatusBarEntries
)
{
if
(
entry
-
>
GetMenu
(
)
=
=
aElement
)
{
entry
-
>
removeFrom
(
mStatusBarEntries
)
;
return
NS_OK
;
}
}
return
NS_ERROR_NOT_AVAILABLE
;
}
}
