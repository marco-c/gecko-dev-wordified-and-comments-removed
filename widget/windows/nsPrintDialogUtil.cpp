#
include
"
plstr
.
h
"
#
include
<
windows
.
h
>
#
include
<
tchar
.
h
>
#
include
<
unknwn
.
h
>
#
include
<
commdlg
.
h
>
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsIPrintSettingsWin
.
h
"
#
include
"
nsIPrinterList
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
prenv
.
h
"
#
include
<
windows
.
h
>
#
include
<
winspool
.
h
>
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
<
dlgs
.
h
>
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
WinUtils
.
h
"
static
HWND
gParentWnd
=
nullptr
;
static
nsReturnRef
<
nsHGLOBAL
>
CreateGlobalDevModeAndInit
(
const
nsString
&
aPrintName
nsIPrintSettings
*
aPS
)
{
nsHPRINTER
hPrinter
=
nullptr
;
LPWSTR
printName
=
const_cast
<
wchar_t
*
>
(
static_cast
<
const
wchar_t
*
>
(
aPrintName
.
get
(
)
)
)
;
BOOL
status
=
:
:
OpenPrinterW
(
printName
&
hPrinter
nullptr
)
;
if
(
!
status
)
{
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
nsAutoPrinter
autoPrinter
(
hPrinter
)
;
LONG
needed
=
:
:
DocumentPropertiesW
(
gParentWnd
hPrinter
printName
nullptr
nullptr
0
)
;
if
(
needed
<
0
)
{
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
needed
*
=
2
;
nsAutoDevMode
newDevMode
(
(
LPDEVMODEW
)
:
:
HeapAlloc
(
:
:
GetProcessHeap
(
)
HEAP_ZERO_MEMORY
needed
)
)
;
if
(
!
newDevMode
)
{
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
nsHGLOBAL
hDevMode
=
:
:
GlobalAlloc
(
GHND
needed
)
;
nsAutoGlobalMem
globalDevMode
(
hDevMode
)
;
if
(
!
hDevMode
)
{
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
LONG
ret
=
:
:
DocumentPropertiesW
(
gParentWnd
hPrinter
printName
newDevMode
nullptr
DM_OUT_BUFFER
)
;
if
(
ret
!
=
IDOK
)
{
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
LPDEVMODEW
devMode
=
(
DEVMODEW
*
)
:
:
GlobalLock
(
hDevMode
)
;
if
(
!
devMode
)
{
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
memcpy
(
devMode
newDevMode
.
get
(
)
needed
)
;
nsCOMPtr
<
nsIPrintSettingsWin
>
psWin
=
do_QueryInterface
(
aPS
)
;
MOZ_ASSERT
(
psWin
)
;
psWin
-
>
CopyToNative
(
devMode
)
;
ret
=
:
:
DocumentPropertiesW
(
gParentWnd
hPrinter
printName
devMode
devMode
DM_IN_BUFFER
|
DM_OUT_BUFFER
)
;
if
(
ret
!
=
IDOK
)
{
:
:
GlobalUnlock
(
hDevMode
)
;
return
nsReturnRef
<
nsHGLOBAL
>
(
)
;
}
:
:
GlobalUnlock
(
hDevMode
)
;
return
globalDevMode
.
out
(
)
;
}
static
void
GetDefaultPrinterNameFromGlobalPrinters
(
nsAString
&
aPrinterName
)
{
aPrinterName
.
Truncate
(
)
;
nsCOMPtr
<
nsIPrinterList
>
printerList
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
printerlist
;
1
"
)
;
if
(
printerList
)
{
printerList
-
>
GetSystemDefaultPrinterName
(
aPrinterName
)
;
}
}
nsresult
NativeShowPrintDialog
(
HWND
aHWnd
bool
aHaveSelection
nsIPrintSettings
*
aPrintSettings
)
{
NS_ENSURE_ARG_POINTER
(
aPrintSettings
)
;
nsString
printerName
;
aPrintSettings
-
>
GetPrinterName
(
printerName
)
;
if
(
printerName
.
IsEmpty
(
)
)
{
GetDefaultPrinterNameFromGlobalPrinters
(
printerName
)
;
}
else
{
HANDLE
hPrinter
=
nullptr
;
if
(
!
:
:
OpenPrinterW
(
const_cast
<
wchar_t
*
>
(
static_cast
<
const
wchar_t
*
>
(
printerName
.
get
(
)
)
)
&
hPrinter
nullptr
)
)
{
GetDefaultPrinterNameFromGlobalPrinters
(
printerName
)
;
}
else
{
:
:
ClosePrinter
(
hPrinter
)
;
}
}
uint32_t
len
=
printerName
.
Length
(
)
;
nsHGLOBAL
hDevNames
=
:
:
GlobalAlloc
(
GHND
sizeof
(
wchar_t
)
*
(
len
+
1
)
+
sizeof
(
DEVNAMES
)
)
;
nsAutoGlobalMem
autoDevNames
(
hDevNames
)
;
if
(
!
hDevNames
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DEVNAMES
*
pDevNames
=
(
DEVNAMES
*
)
:
:
GlobalLock
(
hDevNames
)
;
if
(
!
pDevNames
)
{
return
NS_ERROR_FAILURE
;
}
pDevNames
-
>
wDriverOffset
=
sizeof
(
DEVNAMES
)
/
sizeof
(
wchar_t
)
;
pDevNames
-
>
wDeviceOffset
=
sizeof
(
DEVNAMES
)
/
sizeof
(
wchar_t
)
;
pDevNames
-
>
wOutputOffset
=
sizeof
(
DEVNAMES
)
/
sizeof
(
wchar_t
)
+
len
;
pDevNames
-
>
wDefault
=
0
;
memcpy
(
pDevNames
+
1
printerName
.
get
(
)
(
len
+
1
)
*
sizeof
(
wchar_t
)
)
;
:
:
GlobalUnlock
(
hDevNames
)
;
nsAutoGlobalMem
autoDevMode
(
CreateGlobalDevModeAndInit
(
printerName
aPrintSettings
)
)
;
PRINTDLGEXW
prntdlg
;
memset
(
&
prntdlg
0
sizeof
(
prntdlg
)
)
;
prntdlg
.
lStructSize
=
sizeof
(
prntdlg
)
;
prntdlg
.
hwndOwner
=
aHWnd
;
prntdlg
.
hDevMode
=
autoDevMode
.
get
(
)
;
prntdlg
.
hDevNames
=
hDevNames
;
prntdlg
.
hDC
=
nullptr
;
prntdlg
.
Flags
=
PD_ALLPAGES
|
PD_RETURNIC
|
PD_USEDEVMODECOPIESANDCOLLATE
|
PD_COLLATE
|
PD_NOCURRENTPAGE
;
if
(
!
aHaveSelection
)
{
prntdlg
.
Flags
|
=
PD_NOSELECTION
;
}
constexpr
size_t
kMinSupportedRanges
=
10
;
AutoTArray
<
PRINTPAGERANGE
kMinSupportedRanges
>
winPageRanges
;
{
AutoTArray
<
int32_t
kMinSupportedRanges
*
2
>
pageRanges
;
aPrintSettings
-
>
GetPageRanges
(
pageRanges
)
;
if
(
!
pageRanges
.
IsEmpty
(
)
)
{
prntdlg
.
Flags
|
=
PD_PAGENUMS
;
}
const
size_t
specifiedRanges
=
pageRanges
.
Length
(
)
/
2
;
const
size_t
maxRanges
=
std
:
:
max
(
kMinSupportedRanges
specifiedRanges
)
;
prntdlg
.
nMaxPageRanges
=
maxRanges
;
prntdlg
.
nPageRanges
=
specifiedRanges
;
winPageRanges
.
SetCapacity
(
maxRanges
)
;
for
(
size_t
i
=
0
;
i
<
pageRanges
.
Length
(
)
;
i
+
=
2
)
{
PRINTPAGERANGE
*
range
=
winPageRanges
.
AppendElement
(
)
;
range
-
>
nFromPage
=
pageRanges
[
i
]
;
range
-
>
nToPage
=
pageRanges
[
i
+
1
]
;
}
prntdlg
.
lpPageRanges
=
winPageRanges
.
Elements
(
)
;
prntdlg
.
nMinPage
=
1
;
prntdlg
.
nMaxPage
=
0xFFFF
;
}
prntdlg
.
nCopies
=
1
;
prntdlg
.
hInstance
=
nullptr
;
prntdlg
.
lpPrintTemplateName
=
nullptr
;
prntdlg
.
lpCallback
=
nullptr
;
prntdlg
.
nPropertyPages
=
0
;
prntdlg
.
lphPropertyPages
=
nullptr
;
prntdlg
.
nStartPage
=
START_PAGE_GENERAL
;
prntdlg
.
dwResultAction
=
0
;
HRESULT
result
;
{
mozilla
:
:
widget
:
:
WinUtils
:
:
AutoSystemDpiAware
dpiAwareness
;
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
result
=
:
:
PrintDlgExW
(
&
prntdlg
)
;
}
auto
cancelOnExit
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
:
:
SetFocus
(
aHWnd
)
;
}
)
;
if
(
NS_WARN_IF
(
!
SUCCEEDED
(
result
)
)
)
{
#
ifdef
DEBUG
printf_stderr
(
"
PrintDlgExW
failed
with
%
lx
\
n
"
result
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
prntdlg
.
dwResultAction
!
=
PD_RESULT_PRINT
)
)
{
return
NS_ERROR_ABORT
;
}
NS_ENSURE_TRUE
(
prntdlg
.
hDevMode
NS_ERROR_ABORT
)
;
NS_ENSURE_TRUE
(
prntdlg
.
hDevNames
NS_ERROR_ABORT
)
;
DEVNAMES
*
devnames
=
(
DEVNAMES
*
)
:
:
GlobalLock
(
prntdlg
.
hDevNames
)
;
NS_ENSURE_TRUE
(
devnames
NS_ERROR_ABORT
)
;
char16_t
*
device
=
&
(
(
(
char16_t
*
)
devnames
)
[
devnames
-
>
wDeviceOffset
]
)
;
char16_t
*
driver
=
&
(
(
(
char16_t
*
)
devnames
)
[
devnames
-
>
wDriverOffset
]
)
;
if
(
prntdlg
.
Flags
&
PD_PRINTTOFILE
)
{
char16ptr_t
fileName
=
&
(
(
(
wchar_t
*
)
devnames
)
[
devnames
-
>
wOutputOffset
]
)
;
NS_ASSERTION
(
wcscmp
(
fileName
L
"
FILE
:
"
)
=
=
0
"
FileName
must
be
FILE
:
"
)
;
aPrintSettings
-
>
SetOutputDestination
(
nsIPrintSettings
:
:
kOutputDestinationFile
)
;
aPrintSettings
-
>
SetToFileName
(
nsDependentString
(
fileName
)
)
;
}
else
{
aPrintSettings
-
>
SetOutputDestination
(
nsIPrintSettings
:
:
kOutputDestinationPrinter
)
;
aPrintSettings
-
>
SetToFileName
(
u
"
"
_ns
)
;
}
nsCOMPtr
<
nsIPrintSettingsWin
>
psWin
(
do_QueryInterface
(
aPrintSettings
)
)
;
MOZ_RELEASE_ASSERT
(
psWin
)
;
psWin
-
>
SetDeviceName
(
nsDependentString
(
device
)
)
;
psWin
-
>
SetDriverName
(
nsDependentString
(
driver
)
)
;
aPrintSettings
-
>
SetPrinterName
(
nsDependentString
(
device
)
)
;
aPrintSettings
-
>
SetPrintSelectionOnly
(
prntdlg
.
Flags
&
PD_SELECTION
)
;
AutoTArray
<
int32_t
kMinSupportedRanges
*
2
>
pageRanges
;
if
(
prntdlg
.
Flags
&
PD_PAGENUMS
)
{
pageRanges
.
SetCapacity
(
prntdlg
.
nPageRanges
*
2
)
;
for
(
const
auto
&
range
:
mozilla
:
:
Span
(
prntdlg
.
lpPageRanges
prntdlg
.
nPageRanges
)
)
{
pageRanges
.
AppendElement
(
range
.
nFromPage
)
;
pageRanges
.
AppendElement
(
range
.
nToPage
)
;
}
}
aPrintSettings
-
>
SetPageRanges
(
pageRanges
)
;
:
:
GlobalUnlock
(
prntdlg
.
hDevNames
)
;
LPDEVMODEW
devMode
=
(
LPDEVMODEW
)
:
:
GlobalLock
(
prntdlg
.
hDevMode
)
;
if
(
!
devMode
|
|
!
prntdlg
.
hDC
)
{
return
NS_ERROR_FAILURE
;
}
psWin
-
>
SetDevMode
(
devMode
)
;
psWin
-
>
CopyFromNative
(
prntdlg
.
hDC
devMode
)
;
:
:
GlobalUnlock
(
prntdlg
.
hDevMode
)
;
:
:
DeleteDC
(
prntdlg
.
hDC
)
;
cancelOnExit
.
release
(
)
;
return
NS_OK
;
}
