#
ifndef
mozilla_WinHeaderOnlyUtils_h
#
define
mozilla_WinHeaderOnlyUtils_h
#
include
<
windows
.
h
>
#
include
<
winerror
.
h
>
#
include
<
winternl
.
h
>
#
include
<
ntstatus
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DynamicallyLinkedFunctionPtr
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
if
_WIN32_WINNT
<
_WIN32_WINNT_WIN8
typedef
struct
_FILE_ID_INFO
{
ULONGLONG
VolumeSerialNumber
;
FILE_ID_128
FileId
;
}
FILE_ID_INFO
;
#
define
FileIdInfo
(
(
FILE_INFO_BY_HANDLE_CLASS
)
18
)
#
endif
namespace
mozilla
{
class
WindowsError
final
{
private
:
explicit
WindowsError
(
HRESULT
aHResult
)
:
mHResult
(
aHResult
)
{
}
public
:
using
UniqueString
=
UniquePtr
<
WCHAR
[
]
LocalFreeDeleter
>
;
static
WindowsError
FromNtStatus
(
NTSTATUS
aNtStatus
)
{
if
(
aNtStatus
=
=
STATUS_SUCCESS
)
{
return
WindowsError
(
S_OK
)
;
}
return
WindowsError
(
HRESULT_FROM_NT
(
aNtStatus
)
)
;
}
static
WindowsError
FromHResult
(
HRESULT
aHResult
)
{
return
WindowsError
(
aHResult
)
;
}
static
WindowsError
FromWin32Error
(
DWORD
aWin32Err
)
{
return
WindowsError
(
HRESULT_FROM_WIN32
(
aWin32Err
)
)
;
}
static
WindowsError
FromLastError
(
)
{
return
FromWin32Error
(
:
:
GetLastError
(
)
)
;
}
static
WindowsError
CreateSuccess
(
)
{
return
WindowsError
(
S_OK
)
;
}
static
WindowsError
CreateGeneric
(
)
{
return
FromWin32Error
(
ERROR_UNIDENTIFIED_ERROR
)
;
}
explicit
operator
bool
(
)
const
{
return
SUCCEEDED
(
mHResult
)
;
}
bool
IsAvailableAsWin32Error
(
)
const
{
return
IsAvailableAsNtStatus
(
)
|
|
HRESULT_FACILITY
(
mHResult
)
=
=
FACILITY_WIN32
;
}
bool
IsAvailableAsNtStatus
(
)
const
{
return
mHResult
=
=
S_OK
|
|
(
mHResult
&
FACILITY_NT_BIT
)
;
}
bool
IsAvailableAsHResult
(
)
const
{
return
true
;
}
UniqueString
AsString
(
)
const
{
LPWSTR
rawMsgBuf
=
nullptr
;
DWORD
result
=
:
:
FormatMessageW
(
FORMAT_MESSAGE_ALLOCATE_BUFFER
|
FORMAT_MESSAGE_FROM_SYSTEM
|
FORMAT_MESSAGE_IGNORE_INSERTS
nullptr
mHResult
0
reinterpret_cast
<
LPWSTR
>
(
&
rawMsgBuf
)
0
nullptr
)
;
if
(
!
result
)
{
return
nullptr
;
}
return
UniqueString
(
rawMsgBuf
)
;
}
HRESULT
AsHResult
(
)
const
{
return
mHResult
;
}
Maybe
<
DWORD
>
AsWin32Error
(
)
const
{
if
(
mHResult
=
=
S_OK
)
{
return
Some
(
static_cast
<
DWORD
>
(
ERROR_SUCCESS
)
)
;
}
if
(
HRESULT_FACILITY
(
mHResult
)
=
=
FACILITY_WIN32
)
{
return
Some
(
static_cast
<
DWORD
>
(
HRESULT_CODE
(
mHResult
)
)
)
;
}
if
(
mHResult
&
FACILITY_NT_BIT
)
{
return
Some
(
NtStatusToWin32Error
(
static_cast
<
NTSTATUS
>
(
mHResult
&
~
FACILITY_NT_BIT
)
)
)
;
}
return
Nothing
(
)
;
}
Maybe
<
NTSTATUS
>
AsNtStatus
(
)
const
{
if
(
mHResult
=
=
S_OK
)
{
return
Some
(
STATUS_SUCCESS
)
;
}
if
(
mHResult
&
FACILITY_NT_BIT
)
{
return
Some
(
static_cast
<
NTSTATUS
>
(
mHResult
&
~
FACILITY_NT_BIT
)
)
;
}
return
Nothing
(
)
;
}
static
DWORD
NtStatusToWin32Error
(
NTSTATUS
aNtStatus
)
{
static
const
DynamicallyLinkedFunctionPtr
<
decltype
(
&
RtlNtStatusToDosError
)
>
pRtlNtStatusToDosError
(
L
"
ntdll
.
dll
"
"
RtlNtStatusToDosError
"
)
;
MOZ_ASSERT
(
!
!
pRtlNtStatusToDosError
)
;
if
(
!
pRtlNtStatusToDosError
)
{
return
ERROR_UNIDENTIFIED_ERROR
;
}
return
pRtlNtStatusToDosError
(
aNtStatus
)
;
}
private
:
HRESULT
mHResult
;
}
;
template
<
typename
T
>
using
WindowsErrorResult
=
Result
<
T
WindowsError
>
;
const
DWORD
kWaitForInputIdleTimeoutMS
=
10
*
1000
;
inline
bool
WaitForInputIdle
(
HANDLE
aProcess
DWORD
aTimeoutMs
=
kWaitForInputIdleTimeoutMS
)
{
const
DWORD
kSleepTimeMs
=
10
;
const
DWORD
waitStart
=
aTimeoutMs
=
=
INFINITE
?
0
:
:
:
GetTickCount
(
)
;
DWORD
elapsed
=
0
;
while
(
true
)
{
if
(
aTimeoutMs
!
=
INFINITE
)
{
elapsed
=
:
:
GetTickCount
(
)
-
waitStart
;
}
if
(
elapsed
>
=
aTimeoutMs
)
{
return
false
;
}
DWORD
waitResult
=
:
:
WaitForInputIdle
(
aProcess
aTimeoutMs
-
elapsed
)
;
if
(
!
waitResult
)
{
return
true
;
}
if
(
waitResult
=
=
WAIT_FAILED
&
&
:
:
GetLastError
(
)
=
=
ERROR_NOT_GUI_PROCESS
)
{
:
:
Sleep
(
kSleepTimeMs
)
;
continue
;
}
return
false
;
}
}
enum
class
PathType
{
eNtPath
eDosPath
}
;
class
FileUniqueId
final
{
public
:
explicit
FileUniqueId
(
const
wchar_t
*
aPath
PathType
aPathType
)
:
mId
(
)
{
if
(
!
aPath
)
{
return
;
}
nsAutoHandle
file
;
switch
(
aPathType
)
{
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
PathType
"
)
;
return
;
case
PathType
:
:
eNtPath
:
{
UNICODE_STRING
unicodeString
;
:
:
RtlInitUnicodeString
(
&
unicodeString
aPath
)
;
OBJECT_ATTRIBUTES
objectAttributes
;
InitializeObjectAttributes
(
&
objectAttributes
&
unicodeString
OBJ_CASE_INSENSITIVE
nullptr
nullptr
)
;
IO_STATUS_BLOCK
ioStatus
=
{
}
;
HANDLE
ntHandle
;
NTSTATUS
status
=
:
:
NtOpenFile
(
&
ntHandle
SYNCHRONIZE
|
FILE_READ_ATTRIBUTES
&
objectAttributes
&
ioStatus
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
FILE_SYNCHRONOUS_IO_NONALERT
|
FILE_OPEN_FOR_BACKUP_INTENT
)
;
if
(
!
NT_SUCCESS
(
status
)
)
{
mError
=
Some
(
WindowsError
:
:
FromNtStatus
(
status
)
)
;
return
;
}
file
.
own
(
ntHandle
)
;
}
break
;
case
PathType
:
:
eDosPath
:
{
file
.
own
(
:
:
CreateFileW
(
aPath
0
FILE_SHARE_READ
|
FILE_SHARE_WRITE
|
FILE_SHARE_DELETE
nullptr
OPEN_EXISTING
FILE_FLAG_BACKUP_SEMANTICS
nullptr
)
)
;
if
(
file
=
=
INVALID_HANDLE_VALUE
)
{
mError
=
Some
(
WindowsError
:
:
FromLastError
(
)
)
;
return
;
}
break
;
}
}
GetId
(
file
)
;
}
explicit
FileUniqueId
(
const
nsAutoHandle
&
aFile
)
:
mId
(
)
{
GetId
(
aFile
)
;
}
FileUniqueId
(
const
FileUniqueId
&
aOther
)
:
mId
(
aOther
.
mId
)
mError
(
aOther
.
mError
)
{
}
~
FileUniqueId
(
)
=
default
;
explicit
operator
bool
(
)
const
{
FILE_ID_INFO
zeros
=
{
}
;
return
!
mError
&
&
memcmp
(
&
mId
&
zeros
sizeof
(
FILE_ID_INFO
)
)
;
}
Maybe
<
WindowsError
>
GetError
(
)
const
{
return
mError
;
}
FileUniqueId
&
operator
=
(
const
FileUniqueId
&
aOther
)
{
mId
=
aOther
.
mId
;
mError
=
aOther
.
mError
;
return
*
this
;
}
FileUniqueId
(
FileUniqueId
&
&
aOther
)
=
delete
;
FileUniqueId
&
operator
=
(
FileUniqueId
&
&
aOther
)
=
delete
;
bool
operator
=
=
(
const
FileUniqueId
&
aOther
)
const
{
return
!
mError
&
&
!
aOther
.
mError
&
&
!
memcmp
(
&
mId
&
aOther
.
mId
sizeof
(
FILE_ID_INFO
)
)
;
}
bool
operator
!
=
(
const
FileUniqueId
&
aOther
)
const
{
return
!
(
(
*
this
)
=
=
aOther
)
;
}
private
:
void
GetId
(
const
nsAutoHandle
&
aFile
)
{
if
(
IsWin8OrLater
(
)
)
{
if
(
:
:
GetFileInformationByHandleEx
(
aFile
.
get
(
)
FileIdInfo
&
mId
sizeof
(
mId
)
)
)
{
return
;
}
}
BY_HANDLE_FILE_INFORMATION
info
=
{
}
;
if
(
!
:
:
GetFileInformationByHandle
(
aFile
.
get
(
)
&
info
)
)
{
mError
=
Some
(
WindowsError
:
:
FromLastError
(
)
)
;
return
;
}
mId
.
VolumeSerialNumber
=
info
.
dwVolumeSerialNumber
;
memcpy
(
&
mId
.
FileId
.
Identifier
[
0
]
&
info
.
nFileIndexLow
sizeof
(
DWORD
)
)
;
memcpy
(
&
mId
.
FileId
.
Identifier
[
sizeof
(
DWORD
)
]
&
info
.
nFileIndexHigh
sizeof
(
DWORD
)
)
;
}
private
:
FILE_ID_INFO
mId
;
Maybe
<
WindowsError
>
mError
;
}
;
inline
WindowsErrorResult
<
bool
>
DoPathsPointToIdenticalFile
(
const
wchar_t
*
aPath1
const
wchar_t
*
aPath2
PathType
aPathType1
=
PathType
:
:
eDosPath
PathType
aPathType2
=
PathType
:
:
eDosPath
)
{
FileUniqueId
id1
(
aPath1
aPathType1
)
;
if
(
!
id1
)
{
Maybe
<
WindowsError
>
error
=
id1
.
GetError
(
)
;
return
Err
(
error
.
valueOr
(
WindowsError
:
:
CreateGeneric
(
)
)
)
;
}
FileUniqueId
id2
(
aPath2
aPathType2
)
;
if
(
!
id2
)
{
Maybe
<
WindowsError
>
error
=
id2
.
GetError
(
)
;
return
Err
(
error
.
valueOr
(
WindowsError
:
:
CreateGeneric
(
)
)
)
;
}
return
id1
=
=
id2
;
}
}
#
endif
