#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
<
windows
.
h
>
#
include
<
psapi
.
h
>
#
include
<
tlhelp32
.
h
>
typedef
HRESULT
(
WINAPI
*
GETTHREADDESCRIPTION
)
(
HANDLE
hThread
PWSTR
*
threadDescription
)
;
namespace
mozilla
{
uint64_t
ToNanoSeconds
(
const
FILETIME
&
aFileTime
)
{
ULARGE_INTEGER
usec
=
{
{
aFileTime
.
dwLowDateTime
aFileTime
.
dwHighDateTime
}
}
;
return
usec
.
QuadPart
*
100
;
}
RefPtr
<
ProcInfoPromise
>
GetProcInfo
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
{
auto
holder
=
MakeUnique
<
MozPromiseHolder
<
ProcInfoPromise
>
>
(
)
;
RefPtr
<
ProcInfoPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
stream
transport
service
"
)
;
holder
-
>
Reject
(
rv
__func__
)
;
return
promise
;
}
RefPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
holder
=
std
:
:
move
(
holder
)
requests
=
std
:
:
move
(
aRequests
)
]
(
)
-
>
void
{
HashMap
<
base
:
:
ProcessId
ProcInfo
>
gathered
;
if
(
!
gathered
.
reserve
(
requests
.
Length
(
)
)
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
for
(
const
auto
&
request
:
requests
)
{
nsAutoHandle
handle
(
OpenProcess
(
PROCESS_QUERY_INFORMATION
|
PROCESS_VM_READ
FALSE
request
.
pid
)
)
;
if
(
!
handle
)
{
continue
;
}
wchar_t
filename
[
MAX_PATH
]
;
if
(
GetProcessImageFileNameW
(
handle
.
get
(
)
filename
MAX_PATH
)
=
=
0
)
{
continue
;
}
FILETIME
createTime
exitTime
kernelTime
userTime
;
if
(
!
GetProcessTimes
(
handle
.
get
(
)
&
createTime
&
exitTime
&
kernelTime
&
userTime
)
)
{
continue
;
}
PROCESS_MEMORY_COUNTERS
memoryCounters
;
if
(
!
GetProcessMemoryInfo
(
handle
.
get
(
)
(
PPROCESS_MEMORY_COUNTERS
)
&
memoryCounters
sizeof
(
memoryCounters
)
)
)
{
continue
;
}
ProcInfo
info
;
info
.
pid
=
request
.
pid
;
info
.
childId
=
request
.
childId
;
info
.
type
=
request
.
processType
;
info
.
origin
=
request
.
origin
;
info
.
filename
.
Assign
(
filename
)
;
info
.
cpuKernel
=
ToNanoSeconds
(
kernelTime
)
;
info
.
cpuUser
=
ToNanoSeconds
(
userTime
)
;
info
.
residentSetSize
=
memoryCounters
.
WorkingSetSize
;
info
.
virtualMemorySize
=
memoryCounters
.
PagefileUsage
;
info
.
residentUniqueSize
=
nsMemoryReporterManager
:
:
ResidentUnique
(
handle
.
get
(
)
)
;
if
(
!
gathered
.
put
(
request
.
pid
std
:
:
move
(
info
)
)
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
}
nsAutoHandle
hThreadSnap
(
CreateToolhelp32Snapshot
(
TH32CS_SNAPTHREAD
0
)
)
;
if
(
!
hThreadSnap
)
{
holder
-
>
Reject
(
NS_ERROR_UNEXPECTED
__func__
)
;
return
;
}
auto
getThreadDescription
=
reinterpret_cast
<
GETTHREADDESCRIPTION
>
(
:
:
GetProcAddress
(
:
:
GetModuleHandleW
(
L
"
Kernel32
.
dll
"
)
"
GetThreadDescription
"
)
)
;
THREADENTRY32
te32
;
te32
.
dwSize
=
sizeof
(
THREADENTRY32
)
;
for
(
auto
success
=
Thread32First
(
hThreadSnap
.
get
(
)
&
te32
)
;
success
;
success
=
Thread32Next
(
hThreadSnap
.
get
(
)
&
te32
)
)
{
auto
processLookup
=
gathered
.
lookup
(
te32
.
th32OwnerProcessID
)
;
if
(
!
processLookup
)
{
continue
;
}
ThreadInfo
*
threadInfo
=
processLookup
-
>
value
(
)
.
threads
.
AppendElement
(
fallible
)
;
if
(
!
threadInfo
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
nsAutoHandle
hThread
(
OpenThread
(
THREAD_QUERY_INFORMATION
FALSE
te32
.
th32ThreadID
)
)
;
if
(
!
hThread
)
{
processLookup
-
>
value
(
)
.
threads
.
RemoveLastElement
(
)
;
continue
;
}
threadInfo
-
>
tid
=
te32
.
th32ThreadID
;
FILETIME
createTime
exitTime
kernelTime
userTime
;
if
(
GetThreadTimes
(
hThread
.
get
(
)
&
createTime
&
exitTime
&
kernelTime
&
userTime
)
)
{
threadInfo
-
>
cpuKernel
=
ToNanoSeconds
(
kernelTime
)
;
threadInfo
-
>
cpuUser
=
ToNanoSeconds
(
userTime
)
;
}
if
(
getThreadDescription
)
{
PWSTR
threadName
=
nullptr
;
if
(
getThreadDescription
(
hThread
.
get
(
)
&
threadName
)
&
&
threadName
)
{
threadInfo
-
>
name
=
threadName
;
}
if
(
threadName
)
{
LocalFree
(
threadName
)
;
}
}
}
holder
-
>
Resolve
(
std
:
:
move
(
gathered
)
__func__
)
;
}
)
;
rv
=
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
the
LoadDataRunnable
.
"
)
;
}
return
promise
;
}
}
