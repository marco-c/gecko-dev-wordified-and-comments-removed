#
include
"
nsColorPicker
.
h
"
#
include
<
algorithm
>
#
include
<
shlwapi
.
h
>
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsString
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
using
namespace
mozilla
:
:
widget
;
namespace
{
static
DWORD
ColorStringToRGB
(
const
nsAString
&
aColor
)
{
DWORD
result
=
0
;
for
(
uint32_t
i
=
1
;
i
<
aColor
.
Length
(
)
;
+
+
i
)
{
result
*
=
16
;
char16_t
c
=
aColor
[
i
]
;
if
(
c
>
=
'
0
'
&
&
c
<
=
'
9
'
)
{
result
+
=
c
-
'
0
'
;
}
else
if
(
c
>
=
'
a
'
&
&
c
<
=
'
f
'
)
{
result
+
=
10
+
(
c
-
'
a
'
)
;
}
else
{
result
+
=
10
+
(
c
-
'
A
'
)
;
}
}
DWORD
r
=
result
&
0x00FF0000
;
DWORD
g
=
result
&
0x0000FF00
;
DWORD
b
=
result
&
0x000000FF
;
r
=
r
>
>
16
;
b
=
b
<
<
16
;
result
=
r
|
g
|
b
;
return
result
;
}
static
nsString
ToHexString
(
BYTE
n
)
{
nsString
result
;
if
(
n
<
=
0x0F
)
{
result
.
Append
(
'
0
'
)
;
}
result
.
AppendInt
(
n
16
)
;
return
result
;
}
static
void
BGRIntToRGBString
(
DWORD
color
nsAString
&
aResult
)
{
BYTE
r
=
GetRValue
(
color
)
;
BYTE
g
=
GetGValue
(
color
)
;
BYTE
b
=
GetBValue
(
color
)
;
aResult
.
Assign
(
'
#
'
)
;
aResult
.
Append
(
ToHexString
(
r
)
)
;
aResult
.
Append
(
ToHexString
(
g
)
)
;
aResult
.
Append
(
ToHexString
(
b
)
)
;
}
}
static
AsyncColorChooser
*
gColorChooser
;
AsyncColorChooser
:
:
AsyncColorChooser
(
COLORREF
aInitialColor
const
nsTArray
<
nsString
>
&
aDefaultColors
nsIWidget
*
aParentWidget
nsIColorPickerShownCallback
*
aCallback
)
:
mozilla
:
:
Runnable
(
"
AsyncColorChooser
"
)
mInitialColor
(
aInitialColor
)
mDefaultColors
(
aDefaultColors
.
Clone
(
)
)
mColor
(
aInitialColor
)
mParentWidget
(
aParentWidget
)
mCallback
(
aCallback
)
{
}
NS_IMETHODIMP
AsyncColorChooser
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Color
pickers
can
only
be
opened
from
main
thread
currently
"
)
;
static
COLORREF
sCustomColors
[
16
]
;
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
std
:
:
fill
(
std
:
:
begin
(
sCustomColors
)
std
:
:
end
(
sCustomColors
)
0x00FFFFFF
)
;
sInitialized
=
true
;
}
if
(
!
gColorChooser
)
{
mozilla
:
:
AutoRestore
<
AsyncColorChooser
*
>
restoreColorChooser
(
gColorChooser
)
;
gColorChooser
=
this
;
ScopedRtlShimWindow
shim
(
mParentWidget
.
get
(
)
)
;
for
(
size_t
i
=
0
;
i
<
std
:
:
min
(
std
:
:
size
(
sCustomColors
)
mDefaultColors
.
Length
(
)
)
;
i
+
+
)
{
sCustomColors
[
i
]
=
ColorStringToRGB
(
mDefaultColors
[
i
]
)
;
}
CHOOSECOLOR
options
;
options
.
lStructSize
=
sizeof
(
options
)
;
options
.
hwndOwner
=
shim
.
get
(
)
;
options
.
Flags
=
CC_RGBINIT
|
CC_FULLOPEN
|
CC_ENABLEHOOK
;
options
.
rgbResult
=
mInitialColor
;
options
.
lpCustColors
=
sCustomColors
;
options
.
lpfnHook
=
HookProc
;
mColor
=
ChooseColor
(
&
options
)
?
options
.
rgbResult
:
mInitialColor
;
}
else
{
NS_WARNING
(
"
Currently
it
'
s
not
possible
to
open
more
than
one
color
"
"
picker
at
a
time
"
)
;
mColor
=
mInitialColor
;
}
if
(
mCallback
)
{
nsAutoString
colorStr
;
BGRIntToRGBString
(
mColor
colorStr
)
;
mCallback
-
>
Done
(
colorStr
)
;
}
return
NS_OK
;
}
void
AsyncColorChooser
:
:
Update
(
COLORREF
aColor
)
{
if
(
mColor
!
=
aColor
)
{
mColor
=
aColor
;
nsAutoString
colorStr
;
BGRIntToRGBString
(
mColor
colorStr
)
;
mCallback
-
>
Update
(
colorStr
)
;
}
}
UINT_PTR
CALLBACK
AsyncColorChooser
:
:
HookProc
(
HWND
aDialog
UINT
aMsg
WPARAM
aWParam
LPARAM
aLParam
)
{
if
(
!
gColorChooser
)
{
return
0
;
}
if
(
aMsg
=
=
WM_INITDIALOG
)
{
return
1
;
}
if
(
aMsg
=
=
WM_CTLCOLORSTATIC
)
{
const
int
kCurrentColorBoxID
=
709
;
if
(
(
HWND
)
aLParam
=
=
GetDlgItem
(
aDialog
kCurrentColorBoxID
)
)
{
gColorChooser
-
>
Update
(
GetPixel
(
(
HDC
)
aWParam
0
0
)
)
;
}
}
return
0
;
}
nsColorPicker
:
:
nsColorPicker
(
)
{
}
nsColorPicker
:
:
~
nsColorPicker
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsColorPicker
nsIColorPicker
)
NS_IMETHODIMP
nsColorPicker
:
:
Init
(
mozIDOMWindowProxy
*
parent
const
nsAString
&
title
const
nsAString
&
aInitialColor
const
nsTArray
<
nsString
>
&
aDefaultColors
)
{
MOZ_ASSERT
(
parent
"
Null
parent
passed
to
colorpicker
no
color
picker
for
you
!
"
)
;
mParentWidget
=
WidgetUtils
:
:
DOMWindowToWidget
(
nsPIDOMWindowOuter
:
:
From
(
parent
)
)
;
mInitialColor
=
ColorStringToRGB
(
aInitialColor
)
;
mDefaultColors
.
Assign
(
aDefaultColors
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsColorPicker
:
:
Open
(
nsIColorPickerShownCallback
*
aCallback
)
{
NS_ENSURE_ARG
(
aCallback
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncColorChooser
(
mInitialColor
mDefaultColors
mParentWidget
aCallback
)
;
return
NS_DispatchToMainThread
(
event
)
;
}
