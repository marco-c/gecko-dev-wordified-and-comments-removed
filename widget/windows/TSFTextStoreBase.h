#
ifndef
TSFTextStoreBase_h
#
define
TSFTextStoreBase_h
#
include
"
nsIWidget
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
TSFUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
WritingModes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
widget
/
IMEData
.
h
"
#
include
<
msctf
.
h
>
#
include
<
textstor
.
h
>
struct
ITfDocumentMgr
;
class
nsWindow
;
namespace
mozilla
:
:
widget
{
class
TSFTextStoreBase
:
public
ITextStoreACP
{
protected
:
using
SelectionChangeDataBase
=
IMENotification
:
:
SelectionChangeDataBase
;
using
SelectionChangeData
=
IMENotification
:
:
SelectionChangeData
;
using
TextChangeDataBase
=
IMENotification
:
:
TextChangeDataBase
;
using
TextChangeData
=
IMENotification
:
:
TextChangeData
;
public
:
STDMETHODIMP
QueryInterface
(
REFIID
void
*
*
)
;
NS_INLINE_DECL_IUNKNOWN_REFCOUNTING
(
TSFTextStoreBase
)
public
:
STDMETHODIMP
AdviseSink
(
REFIID
IUnknown
*
DWORD
)
;
STDMETHODIMP
UnadviseSink
(
IUnknown
*
)
;
STDMETHODIMP
RequestLock
(
DWORD
HRESULT
*
)
;
STDMETHODIMP
GetStatus
(
TS_STATUS
*
)
;
STDMETHODIMP
QueryInsert
(
LONG
LONG
ULONG
LONG
*
LONG
*
)
;
STDMETHODIMP
GetSelection
(
ULONG
ULONG
TS_SELECTION_ACP
*
ULONG
*
)
;
STDMETHODIMP
SetSelection
(
ULONG
const
TS_SELECTION_ACP
*
)
;
STDMETHODIMP
GetText
(
LONG
LONG
WCHAR
*
ULONG
ULONG
*
TS_RUNINFO
*
ULONG
ULONG
*
LONG
*
)
;
STDMETHODIMP
SetText
(
DWORD
LONG
LONG
const
WCHAR
*
ULONG
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
GetFormattedText
(
LONG
LONG
IDataObject
*
*
)
;
STDMETHODIMP
GetEmbedded
(
LONG
REFGUID
REFIID
IUnknown
*
*
)
;
STDMETHODIMP
QueryInsertEmbedded
(
const
GUID
*
const
FORMATETC
*
BOOL
*
)
;
STDMETHODIMP
InsertEmbedded
(
DWORD
LONG
LONG
IDataObject
*
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
RequestAttrsTransitioningAtPosition
(
LONG
ULONG
const
TS_ATTRID
*
DWORD
)
;
STDMETHODIMP
FindNextAttrTransition
(
LONG
LONG
ULONG
const
TS_ATTRID
*
DWORD
LONG
*
BOOL
*
LONG
*
)
;
STDMETHODIMP
GetEndACP
(
LONG
*
)
;
STDMETHODIMP
GetActiveView
(
TsViewCookie
*
)
;
STDMETHODIMP
GetACPFromPoint
(
TsViewCookie
const
POINT
*
DWORD
LONG
*
)
;
STDMETHODIMP
GetTextExt
(
TsViewCookie
LONG
LONG
RECT
*
BOOL
*
)
;
STDMETHODIMP
GetScreenExt
(
TsViewCookie
RECT
*
)
;
STDMETHODIMP
GetWnd
(
TsViewCookie
HWND
*
)
;
STDMETHODIMP
InsertTextAtSelection
(
DWORD
const
WCHAR
*
ULONG
LONG
*
LONG
*
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
InsertEmbeddedAtSelection
(
DWORD
IDataObject
*
LONG
*
LONG
*
TS_TEXTCHANGE
*
)
;
public
:
[
[
nodiscard
]
]
bool
MaybeHasFocus
(
)
const
{
return
mContext
;
}
[
[
nodiscard
]
]
ITfDocumentMgr
*
GetDocumentMgr
(
)
const
{
return
mDocumentMgr
;
}
[
[
nodiscard
]
]
ITfContext
*
GetContext
(
)
const
{
return
mContext
;
}
[
[
nodiscard
]
]
nsWindow
*
GetWindow
(
)
const
{
return
mWidget
;
}
virtual
void
Destroy
(
)
=
0
;
protected
:
TSFTextStoreBase
(
)
=
default
;
virtual
~
TSFTextStoreBase
(
)
=
default
;
[
[
nodiscard
]
]
bool
InitBase
(
nsWindow
*
aWidget
const
InputContext
&
aContext
)
;
[
[
nodiscard
]
]
static
bool
IsReadLock
(
DWORD
aLock
)
{
return
(
TS_LF_READ
=
=
(
aLock
&
TS_LF_READ
)
)
;
}
[
[
nodiscard
]
]
static
bool
IsReadWriteLock
(
DWORD
aLock
)
{
return
(
TS_LF_READWRITE
=
=
(
aLock
&
TS_LF_READWRITE
)
)
;
}
[
[
nodiscard
]
]
bool
IsReadLocked
(
)
const
{
return
IsReadLock
(
mLock
)
;
}
[
[
nodiscard
]
]
bool
IsReadWriteLocked
(
)
const
{
return
IsReadWriteLock
(
mLock
)
;
}
virtual
void
DidLockGranted
(
)
{
}
[
[
nodiscard
]
]
bool
GetScreenExtInternal
(
RECT
&
aScreenExt
)
;
void
DispatchEvent
(
WidgetGUIEvent
&
aEvent
)
;
void
SetInputScope
(
const
nsString
&
aHTMLInputType
const
nsString
&
aHTMLInputMode
)
;
BSTR
GetExposingURL
(
)
const
;
void
PrintExposingURL
(
const
char
*
aPrefix
)
const
;
RefPtr
<
nsWindow
>
mWidget
;
RefPtr
<
TextEventDispatcher
>
mDispatcher
;
RefPtr
<
ITfDocumentMgr
>
mDocumentMgr
;
DWORD
mEditCookie
=
0
;
RefPtr
<
ITfContext
>
mContext
;
RefPtr
<
ITextStoreACPSink
>
mSink
;
DWORD
mSinkMask
=
0
;
DWORD
mLock
=
0
;
DWORD
mLockQueued
=
0
;
[
[
nodiscard
]
]
bool
IsHandlingCompositionInParent
(
)
const
{
return
mDispatcher
&
&
mDispatcher
-
>
IsComposing
(
)
;
}
[
[
nodiscard
]
]
bool
IsHandlingCompositionInContent
(
)
const
{
return
mDispatcher
&
&
mDispatcher
-
>
IsHandlingComposition
(
)
;
}
nsTArray
<
InputScope
>
mInputScopes
;
nsString
mDocumentURL
;
bool
mWaitingQueryLayout
=
false
;
bool
mPendingDestroy
=
false
;
bool
mDeferNotifyingTSF
=
false
;
bool
mDeferNotifyingTSFUntilNextUpdate
=
false
;
bool
mDestroyed
=
false
;
bool
mBeingDestroyed
=
false
;
bool
mInPrivateBrowsing
=
true
;
}
;
}
#
endif
