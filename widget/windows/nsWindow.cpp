#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
AppShutdown
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
PreXULSkeletonUI
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SwipeTracker
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
nsWindow
.
h
"
#
include
"
nsWindowTaskbarConcealer
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
<
shellapi
.
h
>
#
include
<
windows
.
h
>
#
include
<
wtsapi32
.
h
>
#
include
<
process
.
h
>
#
include
<
commctrl
.
h
>
#
include
<
dbt
.
h
>
#
include
<
unknwn
.
h
>
#
include
<
psapi
.
h
>
#
include
<
rpc
.
h
>
#
include
<
propvarutil
.
h
>
#
include
<
propkey
.
h
>
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prtime
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
WidgetTraceEvent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
WinMouseScrollHandler
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIFontEnumerator
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
nsNativeThemeWin
.
h
"
#
include
"
nsWindowsDllInterceptor
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsWindowGfx
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
gfxDWriteFonts
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
SystemTimeConverter
.
h
"
#
include
"
WinTaskbar
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
WinWindowOcclusionTracker
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TextEventDispatcherListener
.
h
"
#
include
"
mozilla
/
widget
/
nsAutoRollup
.
h
"
#
include
"
mozilla
/
widget
/
PlatformWidgetTypes
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsBidiKeyboard
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
InProcessWinCompositorWidget
.
h
"
#
include
"
InputDeviceUtils
.
h
"
#
include
"
ScreenHelperWin
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
nsNativeAppSupportWin
.
h
"
#
include
"
mozilla
/
browser
/
NimbusFeatures
.
h
"
#
include
"
nsIGfxInfo
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
"
nsNativeDragTarget
.
h
"
#
include
<
mmsystem
.
h
>
#
include
<
zmouse
.
h
>
#
include
<
richedit
.
h
>
#
if
defined
(
ACCESSIBILITY
)
#
ifdef
DEBUG
#
include
"
mozilla
/
a11y
/
Logging
.
h
"
#
endif
#
include
"
oleidl
.
h
"
#
include
<
winuser
.
h
>
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
LazyInstantiator
.
h
"
#
include
"
mozilla
/
a11y
/
Platform
.
h
"
#
if
!
defined
(
WINABLEAPI
)
#
include
<
winable
.
h
>
#
endif
#
endif
#
include
"
WindowsUIUtils
.
h
"
#
include
"
nsWindowDefs
.
h
"
#
include
"
nsCrashOnException
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
WinIMEHandler
.
h
"
#
include
"
npapi
.
h
"
#
include
<
d3d11
.
h
>
#
include
"
InkCollector
.
h
"
#
define
ERROR
0
#
if
!
defined
(
SM_CONVERTIBLESLATEMODE
)
#
define
SM_CONVERTIBLESLATEMODE
0x2003
#
endif
#
if
!
defined
(
WM_DPICHANGED
)
#
define
WM_DPICHANGED
0x02E0
#
endif
#
if
!
defined
(
EVENT_OBJECT_CLOAKED
)
#
define
EVENT_OBJECT_CLOAKED
0x8017
#
define
EVENT_OBJECT_UNCLOAKED
0x8018
#
endif
#
include
"
mozilla
/
gfx
/
DeviceManagerDx
.
h
"
#
include
"
mozilla
/
layers
/
APZInputBridge
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
KnowsCompositor
.
h
"
#
include
"
InputData
.
h
"
#
include
"
mozilla
/
TaskController
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
DirectManipulationOwner
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
:
:
plugins
;
static
const
wchar_t
kUser32LibName
[
]
=
L
"
user32
.
dll
"
;
uint32_t
nsWindow
:
:
sInstanceCount
=
0
;
bool
nsWindow
:
:
sIsOleInitialized
=
false
;
nsIWidget
:
:
Cursor
nsWindow
:
:
sCurrentCursor
=
{
}
;
nsWindow
*
nsWindow
:
:
sCurrentWindow
=
nullptr
;
bool
nsWindow
:
:
sJustGotDeactivate
=
false
;
bool
nsWindow
:
:
sJustGotActivate
=
false
;
bool
nsWindow
:
:
sIsInMouseCapture
=
false
;
HHOOK
nsWindow
:
:
sMsgFilterHook
=
nullptr
;
HHOOK
nsWindow
:
:
sCallProcHook
=
nullptr
;
HHOOK
nsWindow
:
:
sCallMouseHook
=
nullptr
;
bool
nsWindow
:
:
sProcessHook
=
false
;
UINT
nsWindow
:
:
sRollupMsgId
=
0
;
HWND
nsWindow
:
:
sRollupMsgWnd
=
nullptr
;
UINT
nsWindow
:
:
sHookTimerId
=
0
;
POINT
nsWindow
:
:
sLastMouseMovePoint
=
{
0
}
;
bool
nsWindow
:
:
sIsRestoringSession
=
false
;
bool
nsWindow
:
:
sTouchInjectInitialized
=
false
;
InjectTouchInputPtr
nsWindow
:
:
sInjectTouchFuncPtr
;
static
SystemTimeConverter
<
DWORD
>
&
TimeConverter
(
)
{
static
SystemTimeConverter
<
DWORD
>
timeConverterSingleton
;
return
timeConverterSingleton
;
}
static
mozilla
:
:
Maybe
<
HWINEVENTHOOK
>
sWinCloakEventHook
=
IsWin8OrLater
(
)
?
Nothing
(
)
:
Some
(
HWINEVENTHOOK
(
nullptr
)
)
;
static
mozilla
:
:
LazyLogModule
sCloakingLog
(
"
DWMCloaking
"
)
;
namespace
mozilla
{
class
CurrentWindowsTimeGetter
{
public
:
explicit
CurrentWindowsTimeGetter
(
HWND
aWnd
)
:
mWnd
(
aWnd
)
{
}
DWORD
GetCurrentTime
(
)
const
{
return
:
:
GetTickCount
(
)
;
}
void
GetTimeAsyncForPossibleBackwardsSkew
(
const
TimeStamp
&
aNow
)
{
DWORD
currentTime
=
GetCurrentTime
(
)
;
if
(
sBackwardsSkewStamp
&
&
currentTime
=
=
sLastPostTime
)
{
return
;
}
sBackwardsSkewStamp
=
Some
(
aNow
)
;
sLastPostTime
=
currentTime
;
static_assert
(
sizeof
(
WPARAM
)
>
=
sizeof
(
DWORD
)
"
Can
'
t
fit
a
DWORD
in
a
WPARAM
"
)
;
:
:
PostMessage
(
mWnd
MOZ_WM_SKEWFIX
sLastPostTime
0
)
;
}
static
bool
GetAndClearBackwardsSkewStamp
(
DWORD
aPostTime
TimeStamp
*
aOutSkewStamp
)
{
if
(
aPostTime
!
=
sLastPostTime
)
{
return
false
;
}
MOZ_ASSERT
(
sBackwardsSkewStamp
)
;
*
aOutSkewStamp
=
sBackwardsSkewStamp
.
value
(
)
;
sBackwardsSkewStamp
=
Nothing
(
)
;
return
true
;
}
private
:
static
Maybe
<
TimeStamp
>
sBackwardsSkewStamp
;
static
DWORD
sLastPostTime
;
HWND
mWnd
;
}
;
Maybe
<
TimeStamp
>
CurrentWindowsTimeGetter
:
:
sBackwardsSkewStamp
;
DWORD
CurrentWindowsTimeGetter
:
:
sLastPostTime
=
0
;
}
static
const
char
*
sScreenManagerContractID
=
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
;
extern
mozilla
:
:
LazyLogModule
gWindowsLog
;
static
NS_DEFINE_CID
(
kCClipboardCID
NS_CLIPBOARD_CID
)
;
static
WindowsDllInterceptor
sUser32Intercept
;
static
const
int32_t
kGlassMarginAdjustment
=
2
;
static
const
int32_t
kResizableBorderMinSize
=
3
;
StaticRefPtr
<
IVirtualDesktopManager
>
gVirtualDesktopManager
;
static
bool
gInitializedVirtualDesktopManager
=
false
;
#
define
MAX_ACCELERATED_DIMENSION
8192
#
define
HITTEST_CACHE_LIFETIME_MS
50
#
if
defined
(
ACCESSIBILITY
)
namespace
mozilla
{
class
TIPMessageHandler
{
public
:
~
TIPMessageHandler
(
)
{
if
(
mHook
)
{
:
:
UnhookWindowsHookEx
(
mHook
)
;
}
}
static
void
Initialize
(
)
{
if
(
!
IsWin8OrLater
(
)
)
{
return
;
}
if
(
sInstance
)
{
return
;
}
sInstance
=
new
TIPMessageHandler
(
)
;
ClearOnShutdown
(
&
sInstance
)
;
}
static
bool
IsA11yBlocked
(
)
{
if
(
!
sInstance
)
{
return
false
;
}
return
sInstance
-
>
mA11yBlockCount
>
0
;
}
private
:
TIPMessageHandler
(
)
:
mHook
(
nullptr
)
mA11yBlockCount
(
0
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMessages
[
0
]
=
:
:
RegisterWindowMessage
(
L
"
ImmersiveFocusNotification
"
)
;
mMessages
[
1
]
=
:
:
RegisterWindowMessage
(
L
"
TipCloseMenus
"
)
;
mMessages
[
2
]
=
:
:
RegisterWindowMessage
(
L
"
TabletInputPanelOpening
"
)
;
mMessages
[
3
]
=
:
:
RegisterWindowMessage
(
L
"
IHM
Pen
or
Touch
Event
noticed
"
)
;
mMessages
[
4
]
=
:
:
RegisterWindowMessage
(
L
"
ProgrammabilityCaretVisibility
"
)
;
mMessages
[
5
]
=
:
:
RegisterWindowMessage
(
L
"
CaretTrackingUpdateIPHidden
"
)
;
mMessages
[
6
]
=
:
:
RegisterWindowMessage
(
L
"
CaretTrackingUpdateIPInfo
"
)
;
mHook
=
:
:
SetWindowsHookEx
(
WH_GETMESSAGE
&
TIPHook
nullptr
:
:
GetCurrentThreadId
(
)
)
;
MOZ_ASSERT
(
mHook
)
;
if
(
!
IsWin10OrLater
(
)
&
&
GetModuleHandle
(
L
"
tiptsf
.
dll
"
)
&
&
!
sProcessCaretEventsStub
)
{
sTipTsfInterceptor
.
Init
(
"
tiptsf
.
dll
"
)
;
DebugOnly
<
bool
>
ok
=
sProcessCaretEventsStub
.
Set
(
sTipTsfInterceptor
"
ProcessCaretEvents
"
&
ProcessCaretEventsHook
)
;
MOZ_ASSERT
(
ok
)
;
}
if
(
!
sSendMessageTimeoutWStub
)
{
sUser32Intercept
.
Init
(
"
user32
.
dll
"
)
;
DebugOnly
<
bool
>
hooked
=
sSendMessageTimeoutWStub
.
Set
(
sUser32Intercept
"
SendMessageTimeoutW
"
&
SendMessageTimeoutWHook
)
;
MOZ_ASSERT
(
hooked
)
;
}
}
class
MOZ_RAII
A11yInstantiationBlocker
{
public
:
A11yInstantiationBlocker
(
)
{
if
(
!
TIPMessageHandler
:
:
sInstance
)
{
return
;
}
+
+
TIPMessageHandler
:
:
sInstance
-
>
mA11yBlockCount
;
}
~
A11yInstantiationBlocker
(
)
{
if
(
!
TIPMessageHandler
:
:
sInstance
)
{
return
;
}
MOZ_ASSERT
(
TIPMessageHandler
:
:
sInstance
-
>
mA11yBlockCount
>
0
)
;
-
-
TIPMessageHandler
:
:
sInstance
-
>
mA11yBlockCount
;
}
}
;
friend
class
A11yInstantiationBlocker
;
static
LRESULT
CALLBACK
TIPHook
(
int
aCode
WPARAM
aWParam
LPARAM
aLParam
)
{
if
(
aCode
<
0
|
|
!
sInstance
)
{
return
:
:
CallNextHookEx
(
nullptr
aCode
aWParam
aLParam
)
;
}
MSG
*
msg
=
reinterpret_cast
<
MSG
*
>
(
aLParam
)
;
UINT
&
msgCode
=
msg
-
>
message
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sInstance
-
>
mMessages
)
;
+
+
i
)
{
if
(
msgCode
=
=
sInstance
-
>
mMessages
[
i
]
)
{
A11yInstantiationBlocker
block
;
return
:
:
CallNextHookEx
(
nullptr
aCode
aWParam
aLParam
)
;
}
}
return
:
:
CallNextHookEx
(
nullptr
aCode
aWParam
aLParam
)
;
}
static
void
CALLBACK
ProcessCaretEventsHook
(
HWINEVENTHOOK
aWinEventHook
DWORD
aEvent
HWND
aHwnd
LONG
aObjectId
LONG
aChildId
DWORD
aGeneratingTid
DWORD
aEventTime
)
{
A11yInstantiationBlocker
block
;
sProcessCaretEventsStub
(
aWinEventHook
aEvent
aHwnd
aObjectId
aChildId
aGeneratingTid
aEventTime
)
;
}
static
LRESULT
WINAPI
SendMessageTimeoutWHook
(
HWND
aHwnd
UINT
aMsgCode
WPARAM
aWParam
LPARAM
aLParam
UINT
aFlags
UINT
aTimeout
PDWORD_PTR
aMsgResult
)
{
if
(
!
aMsgResult
|
|
aMsgCode
!
=
WM_GETOBJECT
|
|
static_cast
<
LONG
>
(
aLParam
)
!
=
OBJID_CLIENT
|
|
!
:
:
NS_IsMainThread
(
)
|
|
!
WinUtils
:
:
GetNSWindowPtr
(
aHwnd
)
|
|
!
IsA11yBlocked
(
)
)
{
return
sSendMessageTimeoutWStub
(
aHwnd
aMsgCode
aWParam
aLParam
aFlags
aTimeout
aMsgResult
)
;
}
*
aMsgResult
=
static_cast
<
DWORD_PTR
>
(
:
:
DefWindowProcW
(
aHwnd
aMsgCode
aWParam
aLParam
)
)
;
return
static_cast
<
LRESULT
>
(
TRUE
)
;
}
static
WindowsDllInterceptor
sTipTsfInterceptor
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
WINEVENTPROC
>
sProcessCaretEventsStub
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
decltype
(
&
SendMessageTimeoutW
)
>
sSendMessageTimeoutWStub
;
static
StaticAutoPtr
<
TIPMessageHandler
>
sInstance
;
HHOOK
mHook
;
UINT
mMessages
[
7
]
;
uint32_t
mA11yBlockCount
;
}
;
WindowsDllInterceptor
TIPMessageHandler
:
:
sTipTsfInterceptor
;
WindowsDllInterceptor
:
:
FuncHookType
<
WINEVENTPROC
>
TIPMessageHandler
:
:
sProcessCaretEventsStub
;
WindowsDllInterceptor
:
:
FuncHookType
<
decltype
(
&
SendMessageTimeoutW
)
>
TIPMessageHandler
:
:
sSendMessageTimeoutWStub
;
StaticAutoPtr
<
TIPMessageHandler
>
TIPMessageHandler
:
:
sInstance
;
}
#
endif
namespace
mozilla
{
class
InitializeVirtualDesktopManagerTask
:
public
Task
{
public
:
InitializeVirtualDesktopManagerTask
(
)
:
Task
(
false
kDefaultPriorityValue
)
{
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
bool
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
InitializeVirtualDesktopManagerTask
"
)
;
return
true
;
}
#
endif
virtual
bool
Run
(
)
override
{
#
ifndef
__MINGW32__
if
(
!
IsWin10OrLater
(
)
)
{
return
true
;
}
RefPtr
<
IVirtualDesktopManager
>
desktopManager
;
HRESULT
hr
=
:
:
CoCreateInstance
(
CLSID_VirtualDesktopManager
NULL
CLSCTX_INPROC_SERVER
__uuidof
(
IVirtualDesktopManager
)
getter_AddRefs
(
desktopManager
)
)
;
if
(
FAILED
(
hr
)
)
{
return
true
;
}
gVirtualDesktopManager
=
desktopManager
;
#
endif
return
true
;
}
}
;
static
bool
GetMouseVanishSystemPref
(
bool
aShouldUpdate
)
{
static
Maybe
<
bool
>
sCachedMouseVanishSystemPref
;
if
(
aShouldUpdate
)
{
sCachedMouseVanishSystemPref
.
reset
(
)
;
}
if
(
sCachedMouseVanishSystemPref
.
isNothing
(
)
)
{
BOOL
mouseVanishSystemPref
;
BOOL
ok
=
:
:
SystemParametersInfo
(
SPI_GETMOUSEVANISH
0
&
mouseVanishSystemPref
0
)
;
sCachedMouseVanishSystemPref
.
emplace
(
ok
?
mouseVanishSystemPref
:
StaticPrefs
:
:
widget_windows_hide_cursor_when_typing
(
)
)
;
}
return
*
sCachedMouseVanishSystemPref
;
}
static
bool
IsMouseVanishKey
(
WPARAM
aVirtKey
)
{
switch
(
aVirtKey
)
{
case
VK_SHIFT
:
case
VK_LSHIFT
:
case
VK_RSHIFT
:
case
VK_CONTROL
:
case
VK_LCONTROL
:
case
VK_RCONTROL
:
case
VK_MENU
:
case
VK_LMENU
:
case
VK_RMENU
:
case
VK_LWIN
:
case
VK_RWIN
:
case
VK_INSERT
:
case
VK_DELETE
:
case
VK_HOME
:
case
VK_END
:
case
VK_ESCAPE
:
case
VK_PRINT
:
case
VK_UP
:
case
VK_DOWN
:
case
VK_LEFT
:
case
VK_RIGHT
:
case
VK_PRIOR
:
case
VK_NEXT
:
case
0xff
:
return
false
;
default
:
return
(
GetKeyState
(
VK_CONTROL
)
&
0x8000
)
!
=
0x8000
&
&
(
GetKeyState
(
VK_MENU
)
&
0x8000
)
!
=
0x8000
&
&
(
aVirtKey
<
VK_F1
|
|
aVirtKey
>
VK_LAUNCH_APP2
)
;
}
}
static
void
MaybeHideCursor
(
bool
aShouldHide
)
{
static
bool
sMouseExists
=
[
]
{
int
count
=
:
:
ShowCursor
(
FALSE
)
;
:
:
ShowCursor
(
TRUE
)
;
return
count
=
=
-
1
;
}
(
)
;
if
(
!
sMouseExists
)
{
return
;
}
static
bool
sIsHidden
=
false
;
bool
shouldHide
=
aShouldHide
&
&
StaticPrefs
:
:
widget_windows_hide_cursor_when_typing
(
)
&
&
GetMouseVanishSystemPref
(
false
)
;
if
(
shouldHide
!
=
sIsHidden
)
{
[
[
maybe_unused
]
]
int
count
=
:
:
ShowCursor
(
aShouldHide
?
FALSE
:
TRUE
)
;
MOZ_ASSERT
(
count
=
=
(
aShouldHide
?
-
1
:
0
)
)
;
sIsHidden
=
shouldHide
;
}
}
static
bool
IsCloaked
(
HWND
hwnd
)
{
DWORD
cloakedState
;
HRESULT
hr
=
:
:
DwmGetWindowAttribute
(
hwnd
DWMWA_CLOAKED
&
cloakedState
sizeof
(
cloakedState
)
)
;
if
(
FAILED
(
hr
)
)
{
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Warning
(
"
failed
(
%
08lX
)
to
query
cloaking
state
for
HWND
%
p
"
hr
hwnd
)
)
;
return
false
;
}
return
cloakedState
!
=
0
;
}
}
nsWindow
:
:
nsWindow
(
bool
aIsChildWindow
)
:
nsBaseWidget
(
eBorderStyle_default
)
mBrush
(
:
:
CreateSolidBrush
(
NSRGB_2_COLOREF
(
:
:
GetSysColor
(
COLOR_BTNFACE
)
)
)
)
mFrameState
(
std
:
:
in_place
this
)
mIsChildWindow
(
aIsChildWindow
)
mLastPaintEndTime
(
TimeStamp
:
:
Now
(
)
)
mCachedHitTestTime
(
TimeStamp
:
:
Now
(
)
)
mSizeConstraintsScale
(
GetDefaultScale
(
)
.
scale
)
mDesktopId
(
"
DesktopIdMutex
"
)
{
MOZ_ASSERT
(
mWindowType
=
=
eWindowType_child
)
;
if
(
!
gInitializedVirtualDesktopManager
)
{
TaskController
:
:
Get
(
)
-
>
AddTask
(
MakeAndAddRef
<
InitializeVirtualDesktopManagerTask
>
(
)
)
;
gInitializedVirtualDesktopManager
=
true
;
}
if
(
!
sInstanceCount
)
{
if
(
!
WinUtils
:
:
HasPackageIdentity
(
)
)
{
mozilla
:
:
widget
:
:
WinTaskbar
:
:
RegisterAppUserModelID
(
)
;
}
KeyboardLayout
:
:
GetInstance
(
)
-
>
OnLayoutChange
(
:
:
GetKeyboardLayout
(
0
)
)
;
#
if
defined
(
ACCESSIBILITY
)
mozilla
:
:
TIPMessageHandler
:
:
Initialize
(
)
;
#
endif
if
(
SUCCEEDED
(
:
:
OleInitialize
(
nullptr
)
)
)
{
sIsOleInitialized
=
true
;
}
NS_ASSERTION
(
sIsOleInitialized
"
*
*
*
*
*
OLE
is
not
initialized
!
\
n
"
)
;
MouseScrollHandler
:
:
Initialize
(
)
;
nsUXThemeData
:
:
UpdateNativeThemeInfo
(
)
;
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
if
(
mPointerEvents
.
ShouldEnableInkCollector
(
)
)
{
InkCollector
:
:
sInkCollector
=
new
InkCollector
(
)
;
}
}
sInstanceCount
+
+
;
}
nsWindow
:
:
~
nsWindow
(
)
{
mInDtor
=
true
;
Destroy
(
)
;
if
(
mIconSmall
)
:
:
DestroyIcon
(
mIconSmall
)
;
if
(
mIconBig
)
:
:
DestroyIcon
(
mIconBig
)
;
sInstanceCount
-
-
;
if
(
sInstanceCount
=
=
0
)
{
if
(
InkCollector
:
:
sInkCollector
)
{
InkCollector
:
:
sInkCollector
-
>
Shutdown
(
)
;
InkCollector
:
:
sInkCollector
=
nullptr
;
}
IMEHandler
:
:
Terminate
(
)
;
sCurrentCursor
=
{
}
;
if
(
sIsOleInitialized
)
{
:
:
OleFlushClipboard
(
)
;
:
:
OleUninitialize
(
)
;
sIsOleInitialized
=
false
;
}
}
NS_IF_RELEASE
(
mNativeDragTarget
)
;
}
int32_t
nsWindow
:
:
GetHeight
(
int32_t
aProposedHeight
)
{
return
aProposedHeight
;
}
static
bool
ShouldCacheTitleBarInfo
(
nsWindowType
aWindowType
nsBorderStyle
aBorderStyle
)
{
return
(
aWindowType
=
=
eWindowType_toplevel
)
&
&
(
aBorderStyle
=
=
eBorderStyle_default
|
|
aBorderStyle
=
=
eBorderStyle_all
)
&
&
(
!
nsUXThemeData
:
:
sTitlebarInfoPopulatedThemed
|
|
!
nsUXThemeData
:
:
sTitlebarInfoPopulatedAero
)
;
}
void
nsWindow
:
:
SendAnAPZEvent
(
InputData
&
aEvent
)
{
LRESULT
popupHandlingResult
;
if
(
DealWithPopups
(
mWnd
MOZ_WM_DMANIP
0
0
&
popupHandlingResult
)
)
{
return
;
}
if
(
mSwipeTracker
&
&
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
)
{
nsEventStatus
status
=
mSwipeTracker
-
>
ProcessEvent
(
aEvent
.
AsPanGestureInput
(
)
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
}
APZEventResult
result
;
if
(
mAPZC
)
{
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aEvent
)
;
}
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
MOZ_ASSERT
(
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
|
|
aEvent
.
mInputType
=
=
PINCHGESTURE_INPUT
)
;
if
(
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
)
{
PanGestureInput
&
panInput
=
aEvent
.
AsPanGestureInput
(
)
;
WidgetWheelEvent
event
=
panInput
.
ToWidgetEvent
(
this
)
;
bool
canTriggerSwipe
=
SwipeTracker
:
:
CanTriggerSwipe
(
panInput
)
;
if
(
!
mAPZC
)
{
if
(
MayStartSwipeForNonAPZ
(
panInput
CanTriggerSwipe
{
canTriggerSwipe
}
)
)
{
return
;
}
}
else
{
event
=
MayStartSwipeForAPZ
(
panInput
result
CanTriggerSwipe
{
canTriggerSwipe
}
)
;
}
ProcessUntransformedAPZEvent
(
&
event
result
)
;
return
;
}
PinchGestureInput
&
pinchInput
=
aEvent
.
AsPinchGestureInput
(
)
;
WidgetWheelEvent
event
=
pinchInput
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
event
result
)
;
}
void
nsWindow
:
:
RecreateDirectManipulationIfNeeded
(
)
{
DestroyDirectManipulation
(
)
;
if
(
mWindowType
!
=
eWindowType_toplevel
&
&
mWindowType
!
=
eWindowType_popup
)
{
return
;
}
if
(
!
(
StaticPrefs
:
:
apz_allow_zooming
(
)
|
|
StaticPrefs
:
:
apz_windows_use_direct_manipulation
(
)
)
|
|
StaticPrefs
:
:
apz_windows_force_disable_direct_manipulation
(
)
)
{
return
;
}
if
(
!
IsWin10OrLater
(
)
)
{
return
;
}
mDmOwner
=
MakeUnique
<
DirectManipulationOwner
>
(
this
)
;
LayoutDeviceIntRect
bounds
(
mBounds
.
X
(
)
mBounds
.
Y
(
)
mBounds
.
Width
(
)
GetHeight
(
mBounds
.
Height
(
)
)
)
;
mDmOwner
-
>
Init
(
bounds
)
;
}
void
nsWindow
:
:
ResizeDirectManipulationViewport
(
)
{
if
(
mDmOwner
)
{
LayoutDeviceIntRect
bounds
(
mBounds
.
X
(
)
mBounds
.
Y
(
)
mBounds
.
Width
(
)
GetHeight
(
mBounds
.
Height
(
)
)
)
;
mDmOwner
-
>
ResizeViewport
(
bounds
)
;
}
}
void
nsWindow
:
:
DestroyDirectManipulation
(
)
{
if
(
mDmOwner
)
{
mDmOwner
-
>
Destroy
(
)
;
mDmOwner
.
reset
(
)
;
}
}
nsresult
nsWindow
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsWidgetInitData
defaultInitData
;
if
(
!
aInitData
)
aInitData
=
&
defaultInitData
;
nsIWidget
*
baseParent
=
aInitData
-
>
mWindowType
=
=
eWindowType_dialog
|
|
aInitData
-
>
mWindowType
=
=
eWindowType_toplevel
|
|
aInitData
-
>
mWindowType
=
=
eWindowType_invisible
?
nullptr
:
aParent
;
mIsTopWidgetWindow
=
(
nullptr
=
=
baseParent
)
;
mBounds
=
aRect
;
nsToolkit
:
:
GetToolkit
(
)
;
BaseCreate
(
baseParent
aInitData
)
;
HWND
parent
;
if
(
aParent
)
{
parent
=
aParent
?
(
HWND
)
aParent
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
:
nullptr
;
mParent
=
aParent
;
}
else
{
parent
=
(
HWND
)
aNativeParent
;
mParent
=
aNativeParent
?
WinUtils
:
:
GetNSWindowPtr
(
(
HWND
)
aNativeParent
)
:
nullptr
;
}
mIsRTL
=
aInitData
-
>
mRTL
;
mForMenupopupFrame
=
aInitData
-
>
mForMenupopupFrame
;
mOpeningAnimationSuppressed
=
aInitData
-
>
mIsAnimationSuppressed
;
mAlwaysOnTop
=
aInitData
-
>
mAlwaysOnTop
;
mResizable
=
aInitData
-
>
mResizable
;
DWORD
style
=
WindowStyle
(
)
;
DWORD
extendedStyle
=
WindowExStyle
(
)
;
bool
isPIPWindow
=
aInitData
&
&
aInitData
-
>
mPIPWindow
;
if
(
isPIPWindow
&
&
!
IsWin8OrLater
(
)
&
&
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
HW_COMPOSITING
)
&
&
WidgetTypeSupportsAcceleration
(
)
)
{
extendedStyle
|
=
WS_EX_COMPOSITED
;
}
if
(
mWindowType
=
=
eWindowType_popup
)
{
if
(
!
aParent
)
{
parent
=
nullptr
;
}
if
(
!
IsWin8OrLater
(
)
&
&
HasBogusPopupsDropShadowOnMultiMonitor
(
)
&
&
ShouldUseOffMainThreadCompositing
(
)
)
{
extendedStyle
|
=
WS_EX_COMPOSITED
;
}
}
else
if
(
mWindowType
=
=
eWindowType_invisible
)
{
style
&
=
~
0x40000000
;
}
else
{
if
(
aInitData
-
>
mClipChildren
)
{
style
|
=
WS_CLIPCHILDREN
;
}
else
{
style
&
=
~
WS_CLIPCHILDREN
;
}
if
(
aInitData
-
>
mClipSiblings
)
{
style
|
=
WS_CLIPSIBLINGS
;
}
}
const
wchar_t
*
className
=
ChooseWindowClass
(
mWindowType
mForMenupopupFrame
)
;
static
bool
sFirstTopLevelWindowCreated
=
false
;
if
(
aInitData
-
>
mWindowType
=
=
eWindowType_toplevel
&
&
!
aParent
&
&
!
sFirstTopLevelWindowCreated
)
{
sFirstTopLevelWindowCreated
=
true
;
mWnd
=
ConsumePreXULSkeletonUIHandle
(
)
;
auto
skeletonUIError
=
GetPreXULSkeletonUIErrorReason
(
)
;
if
(
skeletonUIError
)
{
nsAutoString
errorString
(
GetPreXULSkeletonUIErrorString
(
skeletonUIError
.
value
(
)
)
)
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
STARTUP_SKELETON_UI_DISABLED_REASON
errorString
)
;
}
if
(
mWnd
)
{
MOZ_ASSERT
(
style
=
=
kPreXULSkeletonUIWindowStyle
"
The
skeleton
UI
window
style
should
match
the
expected
"
"
style
for
the
first
window
created
"
)
;
MOZ_ASSERT
(
extendedStyle
=
=
kPreXULSkeletonUIWindowStyleEx
"
The
skeleton
UI
window
extended
style
should
match
the
"
"
expected
extended
style
for
the
first
window
created
"
)
;
MOZ_ASSERT
(
:
:
GetWindowThreadProcessId
(
mWnd
nullptr
)
=
=
:
:
GetCurrentThreadId
(
)
"
The
skeleton
UI
window
should
be
created
on
the
same
thread
as
"
"
other
windows
"
)
;
mIsShowingPreXULSkeletonUI
=
true
;
mIsVisible
=
true
;
mIsCloaked
=
mozilla
:
:
IsCloaked
(
mWnd
)
;
mFrameState
-
>
ConsumePreXULSkeletonState
(
WasPreXULSkeletonUIMaximized
(
)
)
;
LayoutDeviceIntMargin
margins
(
0
2
2
2
)
;
SetNonClientMargins
(
margins
)
;
:
:
SetWindowLongPtrW
(
mWnd
GWLP_WNDPROC
reinterpret_cast
<
LONG_PTR
>
(
WinUtils
:
:
NonClientDpiScalingDefWindowProcW
)
)
;
:
:
SetClassLongPtrW
(
mWnd
GCLP_WNDPROC
reinterpret_cast
<
LONG_PTR
>
(
WinUtils
:
:
NonClientDpiScalingDefWindowProcW
)
)
;
}
}
if
(
!
mWnd
)
{
mWnd
=
:
:
CreateWindowExW
(
extendedStyle
className
L
"
"
style
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
GetHeight
(
aRect
.
Height
(
)
)
parent
nullptr
nsToolkit
:
:
mDllInstance
nullptr
)
;
}
if
(
!
mWnd
)
{
NS_WARNING
(
"
nsWindow
CreateWindowEx
failed
.
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
sWinCloakEventHook
)
{
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Info
(
"
Registering
cloaking
event
hook
"
)
)
;
struct
StdcallLambda
{
static
void
CALLBACK
OnCloakUncloakHook
(
HWINEVENTHOOK
hWinEventHook
DWORD
event
HWND
hwnd
LONG
idObject
LONG
idChild
DWORD
idEventThread
DWORD
dwmsEventTime
)
{
const
bool
isCloaked
=
event
=
=
EVENT_OBJECT_CLOAKED
?
true
:
false
;
nsWindow
:
:
OnCloakEvent
(
hwnd
isCloaked
)
;
}
}
;
const
HWINEVENTHOOK
hook
=
:
:
SetWinEventHook
(
EVENT_OBJECT_CLOAKED
EVENT_OBJECT_UNCLOAKED
HMODULE
(
nullptr
)
&
StdcallLambda
:
:
OnCloakUncloakHook
:
:
GetCurrentProcessId
(
)
:
:
GetCurrentThreadId
(
)
WINEVENT_OUTOFCONTEXT
)
;
sWinCloakEventHook
=
Some
(
hook
)
;
if
(
!
hook
)
{
const
DWORD
err
=
:
:
GetLastError
(
)
;
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Error
(
"
Failed
to
register
cloaking
event
hook
!
GLE
=
%
lu
(
0x
%
lX
)
"
err
err
)
)
;
}
}
if
(
aInitData
-
>
mIsPrivate
)
{
if
(
NimbusFeatures
:
:
GetBool
(
"
majorRelease2022
"
_ns
"
feltPrivacyWindowSeparation
"
_ns
true
)
&
&
!
Preferences
:
:
GetBool
(
"
browser
.
privatebrowsing
.
autostart
"
false
)
)
{
RefPtr
<
IPropertyStore
>
pPropStore
;
if
(
!
FAILED
(
SHGetPropertyStoreForWindow
(
mWnd
IID_IPropertyStore
getter_AddRefs
(
pPropStore
)
)
)
)
{
PROPVARIANT
pv
;
nsAutoString
aumid
;
Unused
<
<
NS_WARN_IF
(
!
mozilla
:
:
widget
:
:
WinTaskbar
:
:
GenerateAppUserModelID
(
aumid
true
)
)
;
if
(
!
FAILED
(
InitPropVariantFromString
(
aumid
.
get
(
)
&
pv
)
)
)
{
if
(
!
FAILED
(
pPropStore
-
>
SetValue
(
PKEY_AppUserModel_ID
pv
)
)
)
{
pPropStore
-
>
Commit
(
)
;
}
PropVariantClear
(
&
pv
)
;
}
}
HICON
icon
=
:
:
LoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
MAKEINTRESOURCEW
(
IDI_PBMODE
)
)
;
SetBigIcon
(
icon
)
;
SetSmallIcon
(
icon
)
;
}
}
mDeviceNotifyHandle
=
InputDeviceUtils
:
:
RegisterNotification
(
mWnd
)
;
mDefaultScale
=
-
1
.
0
;
if
(
mIsRTL
)
{
DWORD
dwAttribute
=
TRUE
;
DwmSetWindowAttribute
(
mWnd
DWMWA_NONCLIENT_RTL_LAYOUT
&
dwAttribute
sizeof
dwAttribute
)
;
}
UpdateDarkModeToolbar
(
)
;
if
(
mOpeningAnimationSuppressed
)
{
SuppressAnimation
(
true
)
;
}
if
(
mAlwaysOnTop
)
{
:
:
SetWindowPos
(
mWnd
HWND_TOPMOST
0
0
0
0
SWP_NOMOVE
|
SWP_NOSIZE
|
SWP_NOACTIVATE
)
;
}
if
(
mWindowType
!
=
eWindowType_invisible
&
&
MouseScrollHandler
:
:
Device
:
:
IsFakeScrollableWindowNeeded
(
)
)
{
HWND
scrollContainerWnd
=
:
:
CreateWindowW
(
className
L
"
FAKETRACKPOINTSCROLLCONTAINER
"
WS_CHILD
|
WS_VISIBLE
0
0
0
0
mWnd
nullptr
nsToolkit
:
:
mDllInstance
nullptr
)
;
HWND
scrollableWnd
=
:
:
CreateWindowW
(
className
L
"
FAKETRACKPOINTSCROLLABLE
"
WS_CHILD
|
WS_VISIBLE
|
WS_VSCROLL
|
WS_TABSTOP
|
0x30
0
0
0
0
scrollContainerWnd
nullptr
nsToolkit
:
:
mDllInstance
nullptr
)
;
:
:
SetWindowLongPtrW
(
scrollableWnd
GWLP_ID
eFakeTrackPointScrollableID
)
;
WNDPROC
oldWndProc
=
(
WNDPROC
)
:
:
SetWindowLongPtrW
(
scrollableWnd
GWLP_WNDPROC
(
LONG_PTR
)
nsWindow
:
:
WindowProc
)
;
:
:
SetWindowLongPtrW
(
scrollableWnd
GWLP_USERDATA
(
LONG_PTR
)
oldWndProc
)
;
}
if
(
!
AssociateWithNativeWindow
(
)
)
{
return
NS_ERROR_FAILURE
;
}
DebugOnly
<
BOOL
>
wtsRegistered
=
:
:
WTSRegisterSessionNotification
(
mWnd
NOTIFY_FOR_THIS_SESSION
)
;
NS_ASSERTION
(
wtsRegistered
"
WTSRegisterSessionNotification
failed
!
\
n
"
)
;
mDefaultIMC
.
Init
(
this
)
;
IMEHandler
:
:
InitInputContext
(
this
mInputContext
)
;
if
(
ShouldCacheTitleBarInfo
(
mWindowType
mBorderStyle
)
)
{
nsUXThemeData
:
:
UpdateTitlebarInfo
(
mWnd
)
;
}
static
bool
a11yPrimed
=
false
;
if
(
!
a11yPrimed
&
&
mWindowType
=
=
eWindowType_toplevel
)
{
a11yPrimed
=
true
;
if
(
Preferences
:
:
GetInt
(
"
accessibility
.
force_disabled
"
0
)
=
=
-
1
)
{
:
:
PostMessage
(
mWnd
MOZ_WM_STARTA11Y
0
0
)
;
}
}
RecreateDirectManipulationIfNeeded
(
)
;
return
NS_OK
;
}
void
nsWindow
:
:
LocalesChanged
(
)
{
bool
isRTL
=
intl
:
:
LocaleService
:
:
GetInstance
(
)
-
>
IsAppLocaleRTL
(
)
;
if
(
mIsRTL
!
=
isRTL
)
{
DWORD
dwAttribute
=
isRTL
;
DwmSetWindowAttribute
(
mWnd
DWMWA_NONCLIENT_RTL_LAYOUT
&
dwAttribute
sizeof
dwAttribute
)
;
mIsRTL
=
isRTL
;
}
}
void
nsWindow
:
:
Destroy
(
)
{
if
(
mOnDestroyCalled
)
return
;
mDestroyCalled
=
true
;
if
(
mPickerDisplayCount
)
return
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
DestroyDirectManipulation
(
)
;
DestroyLayerManager
(
)
;
InputDeviceUtils
:
:
UnregisterNotification
(
mDeviceNotifyHandle
)
;
mDeviceNotifyHandle
=
nullptr
;
VERIFY
(
:
:
DestroyWindow
(
mWnd
)
)
;
if
(
false
=
=
mOnDestroyCalled
)
{
MSGResult
msgResult
;
mWindowHook
.
Notify
(
mWnd
WM_DESTROY
0
0
msgResult
)
;
OnDestroy
(
)
;
}
}
const
wchar_t
*
nsWindow
:
:
RegisterWindowClass
(
const
wchar_t
*
aClassName
UINT
aExtraStyle
LPWSTR
aIconID
)
{
WNDCLASSW
wc
;
if
(
:
:
GetClassInfoW
(
nsToolkit
:
:
mDllInstance
aClassName
&
wc
)
)
{
return
aClassName
;
}
wc
.
style
=
CS_DBLCLKS
|
aExtraStyle
;
wc
.
lpfnWndProc
=
WinUtils
:
:
NonClientDpiScalingDefWindowProcW
;
wc
.
cbClsExtra
=
0
;
wc
.
cbWndExtra
=
0
;
wc
.
hInstance
=
nsToolkit
:
:
mDllInstance
;
wc
.
hIcon
=
aIconID
?
:
:
LoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
aIconID
)
:
nullptr
;
wc
.
hCursor
=
nullptr
;
wc
.
hbrBackground
=
nullptr
;
wc
.
lpszMenuName
=
nullptr
;
wc
.
lpszClassName
=
aClassName
;
if
(
!
:
:
RegisterClassW
(
&
wc
)
)
{
wc
.
style
=
CS_DBLCLKS
;
:
:
RegisterClassW
(
&
wc
)
;
}
return
aClassName
;
}
static
LPWSTR
const
gStockApplicationIcon
=
MAKEINTRESOURCEW
(
32512
)
;
const
wchar_t
*
nsWindow
:
:
ChooseWindowClass
(
nsWindowType
aWindowType
bool
aForMenupopupFrame
)
{
MOZ_ASSERT_IF
(
aForMenupopupFrame
aWindowType
=
=
eWindowType_popup
)
;
switch
(
aWindowType
)
{
case
eWindowType_invisible
:
return
RegisterWindowClass
(
kClassNameHidden
0
gStockApplicationIcon
)
;
case
eWindowType_dialog
:
return
RegisterWindowClass
(
kClassNameDialog
0
0
)
;
case
eWindowType_popup
:
if
(
aForMenupopupFrame
)
{
return
RegisterWindowClass
(
kClassNameDropShadow
CS_DROPSHADOW
gStockApplicationIcon
)
;
}
[
[
fallthrough
]
]
;
default
:
return
RegisterWindowClass
(
GetMainWindowClass
(
)
0
gStockApplicationIcon
)
;
}
}
DWORD
nsWindow
:
:
WindowStyle
(
)
{
DWORD
style
;
switch
(
mWindowType
)
{
case
eWindowType_child
:
style
=
WS_OVERLAPPED
;
break
;
case
eWindowType_dialog
:
style
=
WS_OVERLAPPED
|
WS_BORDER
|
WS_DLGFRAME
|
WS_SYSMENU
|
DS_3DLOOK
|
DS_MODALFRAME
|
WS_CLIPCHILDREN
;
if
(
mBorderStyle
!
=
eBorderStyle_default
)
style
|
=
WS_THICKFRAME
|
WS_MINIMIZEBOX
|
WS_MAXIMIZEBOX
;
break
;
case
eWindowType_popup
:
style
=
WS_POPUP
;
if
(
!
HasGlass
(
)
)
{
style
|
=
WS_OVERLAPPED
;
}
break
;
default
:
NS_ERROR
(
"
unknown
border
style
"
)
;
[
[
fallthrough
]
]
;
case
eWindowType_toplevel
:
case
eWindowType_invisible
:
style
=
WS_OVERLAPPED
|
WS_BORDER
|
WS_DLGFRAME
|
WS_SYSMENU
|
WS_THICKFRAME
|
WS_MINIMIZEBOX
|
WS_MAXIMIZEBOX
|
WS_CLIPCHILDREN
;
break
;
}
if
(
mBorderStyle
!
=
eBorderStyle_default
&
&
mBorderStyle
!
=
eBorderStyle_all
)
{
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
eBorderStyle_border
)
)
style
&
=
~
WS_BORDER
;
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
eBorderStyle_title
)
)
{
style
&
=
~
WS_DLGFRAME
;
style
|
=
WS_POPUP
;
style
&
=
~
WS_CHILD
;
}
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
eBorderStyle_close
)
)
style
&
=
~
0
;
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
(
eBorderStyle_menu
|
eBorderStyle_close
)
)
)
style
&
=
~
WS_SYSMENU
;
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
eBorderStyle_resizeh
)
)
style
&
=
~
WS_THICKFRAME
;
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
eBorderStyle_minimize
)
)
style
&
=
~
WS_MINIMIZEBOX
;
if
(
mBorderStyle
=
=
eBorderStyle_none
|
|
!
(
mBorderStyle
&
eBorderStyle_maximize
)
)
style
&
=
~
WS_MAXIMIZEBOX
;
if
(
IsPopupWithTitleBar
(
)
)
{
style
|
=
WS_CAPTION
;
if
(
mBorderStyle
&
eBorderStyle_close
)
{
style
|
=
WS_SYSMENU
;
}
}
}
if
(
mIsChildWindow
)
{
style
|
=
WS_CLIPCHILDREN
;
if
(
!
(
style
&
WS_POPUP
)
)
{
style
|
=
WS_CHILD
;
}
}
VERIFY_WINDOW_STYLE
(
style
)
;
return
style
;
}
DWORD
nsWindow
:
:
WindowExStyle
(
)
{
switch
(
mWindowType
)
{
case
eWindowType_child
:
return
0
;
case
eWindowType_dialog
:
return
WS_EX_WINDOWEDGE
|
WS_EX_DLGMODALFRAME
;
case
eWindowType_popup
:
{
DWORD
extendedStyle
=
WS_EX_TOOLWINDOW
;
if
(
mPopupLevel
=
=
ePopupLevelTop
)
extendedStyle
|
=
WS_EX_TOPMOST
;
return
extendedStyle
;
}
default
:
NS_ERROR
(
"
unknown
border
style
"
)
;
[
[
fallthrough
]
]
;
case
eWindowType_toplevel
:
case
eWindowType_invisible
:
return
WS_EX_WINDOWEDGE
;
}
}
bool
nsWindow
:
:
AssociateWithNativeWindow
(
)
{
if
(
!
mWnd
|
|
!
IsWindow
(
mWnd
)
)
{
NS_ERROR
(
"
Invalid
window
handle
"
)
;
return
false
;
}
WinUtils
:
:
SetNSWindowPtr
(
mWnd
this
)
;
:
:
SetLastError
(
ERROR_SUCCESS
)
;
const
auto
prevWndProc
=
reinterpret_cast
<
WNDPROC
>
(
:
:
SetWindowLongPtrW
(
mWnd
GWLP_WNDPROC
reinterpret_cast
<
LONG_PTR
>
(
nsWindow
:
:
WindowProc
)
)
)
;
if
(
!
prevWndProc
&
&
GetLastError
(
)
!
=
ERROR_SUCCESS
)
{
NS_ERROR
(
"
Failure
in
SetWindowLongPtrW
"
)
;
WinUtils
:
:
SetNSWindowPtr
(
mWnd
nullptr
)
;
return
false
;
}
mPrevWndProc
.
emplace
(
prevWndProc
)
;
return
true
;
}
void
nsWindow
:
:
DissociateFromNativeWindow
(
)
{
if
(
!
mWnd
|
|
!
IsWindow
(
mWnd
)
|
|
mPrevWndProc
.
isNothing
(
)
)
{
return
;
}
DebugOnly
<
WNDPROC
>
wndProcBeforeDissociate
=
reinterpret_cast
<
WNDPROC
>
(
:
:
SetWindowLongPtrW
(
mWnd
GWLP_WNDPROC
reinterpret_cast
<
LONG_PTR
>
(
*
mPrevWndProc
)
)
)
;
NS_ASSERTION
(
wndProcBeforeDissociate
=
=
nsWindow
:
:
WindowProc
"
Unstacked
an
unexpected
native
window
procedure
"
)
;
WinUtils
:
:
SetNSWindowPtr
(
mWnd
nullptr
)
;
mPrevWndProc
.
reset
(
)
;
}
void
nsWindow
:
:
SetParent
(
nsIWidget
*
aNewParent
)
{
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
nsIWidget
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
parent
-
>
RemoveChild
(
this
)
;
}
mParent
=
aNewParent
;
if
(
aNewParent
)
{
ReparentNativeWidget
(
aNewParent
)
;
aNewParent
-
>
AddChild
(
this
)
;
return
;
}
if
(
mWnd
)
{
VERIFY
(
:
:
SetParent
(
mWnd
nullptr
)
)
;
RecreateDirectManipulationIfNeeded
(
)
;
}
}
void
nsWindow
:
:
ReparentNativeWidget
(
nsIWidget
*
aNewParent
)
{
MOZ_ASSERT
(
aNewParent
"
null
widget
"
)
;
mParent
=
aNewParent
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
return
;
}
HWND
newParent
=
(
HWND
)
aNewParent
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
NS_ASSERTION
(
newParent
"
Parent
widget
has
a
null
native
window
handle
"
)
;
if
(
newParent
&
&
mWnd
)
{
:
:
SetParent
(
mWnd
newParent
)
;
RecreateDirectManipulationIfNeeded
(
)
;
}
}
nsIWidget
*
nsWindow
:
:
GetParent
(
void
)
{
if
(
mIsTopWidgetWindow
)
{
return
nullptr
;
}
if
(
mInDtor
|
|
mOnDestroyCalled
)
{
return
nullptr
;
}
return
mParent
;
}
static
int32_t
RoundDown
(
double
aDouble
)
{
return
aDouble
>
0
?
static_cast
<
int32_t
>
(
floor
(
aDouble
)
)
:
static_cast
<
int32_t
>
(
ceil
(
aDouble
)
)
;
}
float
nsWindow
:
:
GetDPI
(
)
{
float
dpi
=
96
.
0f
;
nsCOMPtr
<
nsIScreen
>
screen
=
GetWidgetScreen
(
)
;
if
(
screen
)
{
screen
-
>
GetDpi
(
&
dpi
)
;
}
return
dpi
;
}
double
nsWindow
:
:
GetDefaultScaleInternal
(
)
{
if
(
mDefaultScale
<
=
0
.
0
)
{
mDefaultScale
=
WinUtils
:
:
LogToPhysFactor
(
mWnd
)
;
}
return
mDefaultScale
;
}
int32_t
nsWindow
:
:
LogToPhys
(
double
aValue
)
{
return
WinUtils
:
:
LogToPhys
(
:
:
MonitorFromWindow
(
mWnd
MONITOR_DEFAULTTOPRIMARY
)
aValue
)
;
}
nsWindow
*
nsWindow
:
:
GetParentWindow
(
bool
aIncludeOwner
)
{
return
static_cast
<
nsWindow
*
>
(
GetParentWindowBase
(
aIncludeOwner
)
)
;
}
nsWindow
*
nsWindow
:
:
GetParentWindowBase
(
bool
aIncludeOwner
)
{
if
(
mIsTopWidgetWindow
)
{
return
nullptr
;
}
if
(
mInDtor
|
|
mOnDestroyCalled
)
return
nullptr
;
nsWindow
*
widget
=
nullptr
;
if
(
mWnd
)
{
HWND
parent
=
nullptr
;
if
(
aIncludeOwner
)
parent
=
:
:
GetParent
(
mWnd
)
;
else
parent
=
:
:
GetAncestor
(
mWnd
GA_PARENT
)
;
if
(
parent
)
{
widget
=
WinUtils
:
:
GetNSWindowPtr
(
parent
)
;
if
(
widget
)
{
if
(
widget
-
>
mInDtor
)
{
widget
=
nullptr
;
}
}
}
}
return
widget
;
}
void
nsWindow
:
:
Show
(
bool
bState
)
{
if
(
bState
&
&
mIsShowingPreXULSkeletonUI
)
{
mIsShowingPreXULSkeletonUI
=
false
;
:
:
SendMessageW
(
mWnd
WM_CHANGEUISTATE
MAKEWPARAM
(
UIS_SET
UISF_HIDEFOCUS
|
UISF_HIDEACCEL
)
0
)
;
#
if
defined
(
ACCESSIBILITY
)
if
(
:
:
GetFocus
(
)
=
=
mWnd
&
&
!
GetAccService
(
)
)
{
:
:
NotifyWinEvent
(
EVENT_OBJECT_FOCUS
mWnd
OBJID_CLIENT
CHILDID_SELF
)
;
}
#
endif
}
if
(
mForMenupopupFrame
)
{
MOZ_ASSERT
(
ChooseWindowClass
(
mWindowType
mForMenupopupFrame
)
=
=
kClassNameDropShadow
)
;
const
bool
shouldUseDropShadow
=
[
&
]
{
if
(
mTransparencyMode
=
=
eTransparencyTransparent
)
{
return
false
;
}
if
(
HasBogusPopupsDropShadowOnMultiMonitor
(
)
&
&
WinUtils
:
:
GetMonitorCount
(
)
>
1
&
&
!
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
{
return
false
;
}
return
true
;
}
(
)
;
static
bool
sShadowEnabled
=
true
;
if
(
sShadowEnabled
!
=
shouldUseDropShadow
)
{
:
:
SetClassLongA
(
mWnd
GCL_STYLE
shouldUseDropShadow
?
CS_DROPSHADOW
:
0
)
;
sShadowEnabled
=
shouldUseDropShadow
;
}
LONG_PTR
exStyle
=
:
:
GetWindowLongPtrW
(
mWnd
GWL_EXSTYLE
)
;
if
(
exStyle
&
WS_EX_LAYERED
)
{
:
:
SetWindowLongPtrW
(
mWnd
GWL_EXSTYLE
exStyle
&
~
WS_EX_COMPOSITED
)
;
}
}
bool
syncInvalidate
=
false
;
bool
wasVisible
=
mIsVisible
;
mIsVisible
=
bState
;
if
(
mIsVisible
)
mOldStyle
|
=
WS_VISIBLE
;
else
mOldStyle
&
=
~
WS_VISIBLE
;
if
(
mWnd
)
{
if
(
bState
)
{
if
(
!
wasVisible
&
&
mWindowType
=
=
eWindowType_toplevel
)
{
syncInvalidate
=
true
;
SetCursor
(
Cursor
{
eCursor_standard
}
)
;
switch
(
mFrameState
-
>
GetSizeMode
(
)
)
{
case
nsSizeMode_Fullscreen
:
:
:
ShowWindow
(
mWnd
SW_SHOW
)
;
break
;
case
nsSizeMode_Maximized
:
:
:
ShowWindow
(
mWnd
SW_SHOWMAXIMIZED
)
;
break
;
case
nsSizeMode_Minimized
:
:
:
ShowWindow
(
mWnd
SW_SHOWMINIMIZED
)
;
break
;
default
:
if
(
CanTakeFocus
(
)
&
&
!
mAlwaysOnTop
)
{
:
:
ShowWindow
(
mWnd
SW_SHOWNORMAL
)
;
}
else
{
:
:
ShowWindow
(
mWnd
SW_SHOWNOACTIVATE
)
;
if
(
!
sIsRestoringSession
)
{
Unused
<
<
GetAttention
(
2
)
;
}
}
break
;
}
}
else
{
DWORD
flags
=
SWP_NOSIZE
|
SWP_NOMOVE
|
SWP_SHOWWINDOW
;
if
(
wasVisible
)
flags
|
=
SWP_NOZORDER
;
if
(
mAlwaysOnTop
)
flags
|
=
SWP_NOACTIVATE
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
flags
|
=
SWP_NOACTIVATE
;
HWND
owner
=
:
:
GetWindow
(
mWnd
GW_OWNER
)
;
if
(
owner
)
{
if
(
PopupLevel
(
)
!
=
ePopupLevelTop
)
{
:
:
SetWindowPos
(
mWnd
owner
0
0
0
0
flags
)
;
:
:
SetWindowPos
(
owner
mWnd
0
0
0
0
SWP_NOMOVE
|
SWP_NOSIZE
|
SWP_NOACTIVATE
)
;
}
else
{
:
:
SetWindowPos
(
mWnd
HWND_TOP
0
0
0
0
flags
)
;
}
}
else
{
:
:
SetWindowPos
(
mWnd
HWND_TOPMOST
0
0
0
0
flags
)
;
}
}
else
{
if
(
mWindowType
=
=
eWindowType_dialog
&
&
!
CanTakeFocus
(
)
)
flags
|
=
SWP_NOACTIVATE
;
:
:
SetWindowPos
(
mWnd
HWND_TOP
0
0
0
0
flags
)
;
}
}
if
(
!
wasVisible
&
&
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
)
{
:
:
SendMessageW
(
mWnd
WM_CHANGEUISTATE
MAKEWPARAM
(
UIS_SET
UISF_HIDEFOCUS
|
UISF_HIDEACCEL
)
0
)
;
}
}
else
{
if
(
wasVisible
&
&
mTransparencyMode
=
=
eTransparencyTransparent
)
{
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
ClearTransparentWindow
(
)
;
}
}
if
(
mWindowType
!
=
eWindowType_dialog
)
{
:
:
ShowWindow
(
mWnd
SW_HIDE
)
;
}
else
{
:
:
SetWindowPos
(
mWnd
0
0
0
0
0
SWP_HIDEWINDOW
|
SWP_NOSIZE
|
SWP_NOMOVE
|
SWP_NOZORDER
|
SWP_NOACTIVATE
)
;
}
}
}
if
(
!
wasVisible
&
&
bState
)
{
Invalidate
(
)
;
if
(
syncInvalidate
&
&
!
mInDtor
&
&
!
mOnDestroyCalled
)
{
:
:
UpdateWindow
(
mWnd
)
;
}
}
if
(
mOpeningAnimationSuppressed
)
{
SuppressAnimation
(
false
)
;
}
}
bool
nsWindow
:
:
IsVisible
(
)
const
{
return
mIsVisible
;
}
void
nsWindow
:
:
ClearThemeRegion
(
)
{
if
(
!
HasGlass
(
)
&
&
(
mWindowType
=
=
eWindowType_popup
&
&
!
IsPopupWithTitleBar
(
)
&
&
(
mPopupType
=
=
ePopupTypeTooltip
|
|
mPopupType
=
=
ePopupTypePanel
)
)
)
{
SetWindowRgn
(
mWnd
nullptr
false
)
;
}
}
void
nsWindow
:
:
RegisterTouchWindow
(
)
{
mTouchWindow
=
true
;
:
:
RegisterTouchWindow
(
mWnd
TWF_WANTPALM
)
;
:
:
EnumChildWindows
(
mWnd
nsWindow
:
:
RegisterTouchForDescendants
0
)
;
}
BOOL
CALLBACK
nsWindow
:
:
RegisterTouchForDescendants
(
HWND
aWnd
LPARAM
aMsg
)
{
nsWindow
*
win
=
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
if
(
win
)
{
:
:
RegisterTouchWindow
(
aWnd
TWF_WANTPALM
)
;
}
return
TRUE
;
}
void
nsWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
if
(
aShouldLock
)
{
mAspectRatio
=
(
float
)
mBounds
.
Width
(
)
/
(
float
)
mBounds
.
Height
(
)
;
}
else
{
mAspectRatio
=
0
.
0
;
}
}
void
nsWindow
:
:
SetInputRegion
(
const
InputRegion
&
aInputRegion
)
{
mInputRegion
=
aInputRegion
;
if
(
!
mWnd
)
{
return
;
}
const
bool
transparent
=
aInputRegion
.
mFullyTransparent
;
LONG_PTR
oldStyle
=
:
:
GetWindowLongPtrW
(
mWnd
GWL_EXSTYLE
)
;
LONG_PTR
newStyle
=
transparent
?
(
oldStyle
|
WS_EX_TRANSPARENT
)
:
(
oldStyle
&
~
WS_EX_TRANSPARENT
)
;
:
:
SetWindowLongPtrW
(
mWnd
GWL_EXSTYLE
newStyle
)
;
}
void
nsWindow
:
:
SetSizeConstraints
(
const
SizeConstraints
&
aConstraints
)
{
SizeConstraints
c
=
aConstraints
;
if
(
mWindowType
!
=
eWindowType_popup
&
&
mResizable
)
{
c
.
mMinSize
.
width
=
std
:
:
max
(
int32_t
(
:
:
GetSystemMetrics
(
SM_CXMINTRACK
)
)
c
.
mMinSize
.
width
)
;
c
.
mMinSize
.
height
=
std
:
:
max
(
int32_t
(
:
:
GetSystemMetrics
(
SM_CYMINTRACK
)
)
c
.
mMinSize
.
height
)
;
}
if
(
mMaxTextureSize
>
0
)
{
c
.
mMaxSize
.
width
=
std
:
:
min
(
c
.
mMaxSize
.
width
mMaxTextureSize
)
;
c
.
mMaxSize
.
height
=
std
:
:
min
(
c
.
mMaxSize
.
height
mMaxTextureSize
)
;
}
mSizeConstraintsScale
=
GetDefaultScale
(
)
.
scale
;
nsBaseWidget
:
:
SetSizeConstraints
(
c
)
;
}
const
SizeConstraints
nsWindow
:
:
GetSizeConstraints
(
)
{
double
scale
=
GetDefaultScale
(
)
.
scale
;
if
(
mSizeConstraintsScale
=
=
scale
|
|
mSizeConstraintsScale
=
=
0
.
0
)
{
return
mSizeConstraints
;
}
scale
/
=
mSizeConstraintsScale
;
SizeConstraints
c
=
mSizeConstraints
;
if
(
c
.
mMinSize
.
width
!
=
NS_MAXSIZE
)
{
c
.
mMinSize
.
width
=
NSToIntRound
(
c
.
mMinSize
.
width
*
scale
)
;
}
if
(
c
.
mMinSize
.
height
!
=
NS_MAXSIZE
)
{
c
.
mMinSize
.
height
=
NSToIntRound
(
c
.
mMinSize
.
height
*
scale
)
;
}
if
(
c
.
mMaxSize
.
width
!
=
NS_MAXSIZE
)
{
c
.
mMaxSize
.
width
=
NSToIntRound
(
c
.
mMaxSize
.
width
*
scale
)
;
}
if
(
c
.
mMaxSize
.
height
!
=
NS_MAXSIZE
)
{
c
.
mMaxSize
.
height
=
NSToIntRound
(
c
.
mMaxSize
.
height
*
scale
)
;
}
return
c
;
}
void
nsWindow
:
:
Move
(
double
aX
double
aY
)
{
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
{
SetSizeMode
(
nsSizeMode_Normal
)
;
}
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
int32_t
x
=
NSToIntRound
(
aX
*
scale
)
;
int32_t
y
=
NSToIntRound
(
aY
*
scale
)
;
if
(
mWindowType
!
=
eWindowType_popup
&
&
mBounds
.
IsEqualXY
(
x
y
)
)
{
return
;
}
mBounds
.
MoveTo
(
x
y
)
;
if
(
mWnd
)
{
#
ifdef
DEBUG
if
(
mIsTopWidgetWindow
)
{
HDC
dc
=
:
:
GetDC
(
mWnd
)
;
if
(
dc
)
{
if
(
:
:
GetDeviceCaps
(
dc
TECHNOLOGY
)
=
=
DT_RASDISPLAY
)
{
RECT
workArea
;
:
:
SystemParametersInfo
(
SPI_GETWORKAREA
0
&
workArea
0
)
;
if
(
x
<
0
|
|
x
>
=
workArea
.
right
|
|
y
<
0
|
|
y
>
=
workArea
.
bottom
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
window
moved
to
offscreen
position
\
n
"
)
)
;
}
}
:
:
ReleaseDC
(
mWnd
dc
)
;
}
}
#
endif
if
(
mIsShowingPreXULSkeletonUI
&
&
WasPreXULSkeletonUIMaximized
(
)
)
{
WINDOWPLACEMENT
pl
=
{
sizeof
(
WINDOWPLACEMENT
)
}
;
VERIFY
(
:
:
GetWindowPlacement
(
mWnd
&
pl
)
)
;
HMONITOR
monitor
=
:
:
MonitorFromWindow
(
mWnd
MONITOR_DEFAULTTONULL
)
;
if
(
NS_WARN_IF
(
!
monitor
)
)
{
return
;
}
MONITORINFO
mi
=
{
sizeof
(
MONITORINFO
)
}
;
VERIFY
(
:
:
GetMonitorInfo
(
monitor
&
mi
)
)
;
int32_t
deltaX
=
x
+
mi
.
rcWork
.
left
-
mi
.
rcMonitor
.
left
-
pl
.
rcNormalPosition
.
left
;
int32_t
deltaY
=
y
+
mi
.
rcWork
.
top
-
mi
.
rcMonitor
.
top
-
pl
.
rcNormalPosition
.
top
;
pl
.
rcNormalPosition
.
left
+
=
deltaX
;
pl
.
rcNormalPosition
.
right
+
=
deltaX
;
pl
.
rcNormalPosition
.
top
+
=
deltaY
;
pl
.
rcNormalPosition
.
bottom
+
=
deltaY
;
VERIFY
(
:
:
SetWindowPlacement
(
mWnd
&
pl
)
)
;
}
else
{
ClearThemeRegion
(
)
;
UINT
flags
=
SWP_NOZORDER
|
SWP_NOACTIVATE
|
SWP_NOSIZE
;
double
oldScale
=
mDefaultScale
;
mResizeState
=
IN_SIZEMOVE
;
VERIFY
(
:
:
SetWindowPos
(
mWnd
nullptr
x
y
0
0
flags
)
)
;
mResizeState
=
NOT_RESIZING
;
if
(
WinUtils
:
:
LogToPhysFactor
(
mWnd
)
!
=
oldScale
)
{
ChangedDPI
(
)
;
}
}
ResizeDirectManipulationViewport
(
)
;
}
}
void
nsWindow
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
int32_t
width
=
NSToIntRound
(
aWidth
*
scale
)
;
int32_t
height
=
NSToIntRound
(
aHeight
*
scale
)
;
NS_ASSERTION
(
(
width
>
=
0
)
"
Negative
width
passed
to
nsWindow
:
:
Resize
"
)
;
NS_ASSERTION
(
(
height
>
=
0
)
"
Negative
height
passed
to
nsWindow
:
:
Resize
"
)
;
if
(
width
<
0
|
|
height
<
0
)
{
gfxCriticalNoteOnce
<
<
"
Negative
passed
to
Resize
(
"
<
<
width
<
<
"
"
<
<
height
<
<
"
)
repaint
:
"
<
<
aRepaint
;
}
ConstrainSize
(
&
width
&
height
)
;
if
(
mBounds
.
IsEqualSize
(
width
height
)
)
{
if
(
aRepaint
)
{
Invalidate
(
)
;
}
return
;
}
bool
wasLocking
=
mAspectRatio
!
=
0
.
0
;
mBounds
.
SizeTo
(
width
height
)
;
if
(
wasLocking
)
{
LockAspectRatio
(
true
)
;
}
if
(
mWnd
)
{
if
(
mIsShowingPreXULSkeletonUI
&
&
WasPreXULSkeletonUIMaximized
(
)
)
{
WINDOWPLACEMENT
pl
=
{
sizeof
(
WINDOWPLACEMENT
)
}
;
VERIFY
(
:
:
GetWindowPlacement
(
mWnd
&
pl
)
)
;
pl
.
rcNormalPosition
.
right
=
pl
.
rcNormalPosition
.
left
+
width
;
pl
.
rcNormalPosition
.
bottom
=
pl
.
rcNormalPosition
.
top
+
GetHeight
(
height
)
;
mResizeState
=
RESIZING
;
VERIFY
(
:
:
SetWindowPlacement
(
mWnd
&
pl
)
)
;
mResizeState
=
NOT_RESIZING
;
}
else
{
UINT
flags
=
SWP_NOZORDER
|
SWP_NOACTIVATE
|
SWP_NOMOVE
;
if
(
!
aRepaint
)
{
flags
|
=
SWP_NOREDRAW
;
}
ClearThemeRegion
(
)
;
double
oldScale
=
mDefaultScale
;
mResizeState
=
RESIZING
;
VERIFY
(
:
:
SetWindowPos
(
mWnd
nullptr
0
0
width
GetHeight
(
height
)
flags
)
)
;
mResizeState
=
NOT_RESIZING
;
if
(
WinUtils
:
:
LogToPhysFactor
(
mWnd
)
!
=
oldScale
)
{
ChangedDPI
(
)
;
}
}
ResizeDirectManipulationViewport
(
)
;
}
if
(
aRepaint
)
Invalidate
(
)
;
}
void
nsWindow
:
:
Resize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
)
{
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
int32_t
x
=
NSToIntRound
(
aX
*
scale
)
;
int32_t
y
=
NSToIntRound
(
aY
*
scale
)
;
int32_t
width
=
NSToIntRound
(
aWidth
*
scale
)
;
int32_t
height
=
NSToIntRound
(
aHeight
*
scale
)
;
NS_ASSERTION
(
(
width
>
=
0
)
"
Negative
width
passed
to
nsWindow
:
:
Resize
"
)
;
NS_ASSERTION
(
(
height
>
=
0
)
"
Negative
height
passed
to
nsWindow
:
:
Resize
"
)
;
if
(
width
<
0
|
|
height
<
0
)
{
gfxCriticalNoteOnce
<
<
"
Negative
passed
to
Resize
(
"
<
<
x
<
<
"
"
<
<
y
<
<
"
"
<
<
width
<
<
"
"
<
<
height
<
<
"
)
repaint
:
"
<
<
aRepaint
;
}
ConstrainSize
(
&
width
&
height
)
;
if
(
mBounds
.
IsEqualRect
(
x
y
width
height
)
)
{
if
(
aRepaint
)
{
Invalidate
(
)
;
}
return
;
}
mBounds
.
SetRect
(
x
y
width
height
)
;
if
(
mWnd
)
{
if
(
mIsShowingPreXULSkeletonUI
&
&
WasPreXULSkeletonUIMaximized
(
)
)
{
WINDOWPLACEMENT
pl
=
{
sizeof
(
WINDOWPLACEMENT
)
}
;
VERIFY
(
:
:
GetWindowPlacement
(
mWnd
&
pl
)
)
;
HMONITOR
monitor
=
:
:
MonitorFromWindow
(
mWnd
MONITOR_DEFAULTTONULL
)
;
if
(
NS_WARN_IF
(
!
monitor
)
)
{
return
;
}
MONITORINFO
mi
=
{
sizeof
(
MONITORINFO
)
}
;
VERIFY
(
:
:
GetMonitorInfo
(
monitor
&
mi
)
)
;
int32_t
deltaX
=
x
+
mi
.
rcWork
.
left
-
mi
.
rcMonitor
.
left
-
pl
.
rcNormalPosition
.
left
;
int32_t
deltaY
=
y
+
mi
.
rcWork
.
top
-
mi
.
rcMonitor
.
top
-
pl
.
rcNormalPosition
.
top
;
pl
.
rcNormalPosition
.
left
+
=
deltaX
;
pl
.
rcNormalPosition
.
right
=
pl
.
rcNormalPosition
.
left
+
width
;
pl
.
rcNormalPosition
.
top
+
=
deltaY
;
pl
.
rcNormalPosition
.
bottom
=
pl
.
rcNormalPosition
.
top
+
GetHeight
(
height
)
;
VERIFY
(
:
:
SetWindowPlacement
(
mWnd
&
pl
)
)
;
}
else
{
UINT
flags
=
SWP_NOZORDER
|
SWP_NOACTIVATE
;
if
(
!
aRepaint
)
{
flags
|
=
SWP_NOREDRAW
;
}
ClearThemeRegion
(
)
;
double
oldScale
=
mDefaultScale
;
mResizeState
=
RESIZING
;
VERIFY
(
:
:
SetWindowPos
(
mWnd
nullptr
x
y
width
GetHeight
(
height
)
flags
)
)
;
mResizeState
=
NOT_RESIZING
;
if
(
WinUtils
:
:
LogToPhysFactor
(
mWnd
)
!
=
oldScale
)
{
ChangedDPI
(
)
;
}
if
(
mTransitionWnd
)
{
:
:
SetWindowPos
(
mTransitionWnd
HWND_TOPMOST
0
0
0
0
SWP_NOMOVE
|
SWP_NOSIZE
|
SWP_NOACTIVATE
)
;
}
}
ResizeDirectManipulationViewport
(
)
;
}
if
(
aRepaint
)
Invalidate
(
)
;
}
mozilla
:
:
Maybe
<
bool
>
nsWindow
:
:
IsResizingNativeWidget
(
)
{
if
(
mResizeState
=
=
RESIZING
)
{
return
Some
(
true
)
;
}
return
Some
(
false
)
;
}
nsresult
nsWindow
:
:
BeginResizeDrag
(
WidgetGUIEvent
*
aEvent
int32_t
aHorizontal
int32_t
aVertical
)
{
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
if
(
aEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
!
=
MouseButton
:
:
ePrimary
)
{
return
NS_ERROR_INVALID_ARG
;
}
WPARAM
syscommand
;
if
(
aVertical
<
0
)
{
if
(
aHorizontal
<
0
)
{
syscommand
=
SC_SIZE
|
WMSZ_TOPLEFT
;
}
else
if
(
aHorizontal
=
=
0
)
{
syscommand
=
SC_SIZE
|
WMSZ_TOP
;
}
else
{
syscommand
=
SC_SIZE
|
WMSZ_TOPRIGHT
;
}
}
else
if
(
aVertical
=
=
0
)
{
if
(
aHorizontal
<
0
)
{
syscommand
=
SC_SIZE
|
WMSZ_LEFT
;
}
else
if
(
aHorizontal
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
else
{
syscommand
=
SC_SIZE
|
WMSZ_RIGHT
;
}
}
else
{
if
(
aHorizontal
<
0
)
{
syscommand
=
SC_SIZE
|
WMSZ_BOTTOMLEFT
;
}
else
if
(
aHorizontal
=
=
0
)
{
syscommand
=
SC_SIZE
|
WMSZ_BOTTOM
;
}
else
{
syscommand
=
SC_SIZE
|
WMSZ_BOTTOMRIGHT
;
}
}
CaptureMouse
(
false
)
;
HWND
toplevelWnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
true
)
;
:
:
PostMessage
(
toplevelWnd
WM_SYSCOMMAND
syscommand
POINTTOPOINTS
(
aEvent
-
>
mRefPoint
)
)
;
return
NS_OK
;
}
void
nsWindow
:
:
PlaceBehind
(
nsTopLevelWidgetZPlacement
aPlacement
nsIWidget
*
aWidget
bool
aActivate
)
{
HWND
behind
=
HWND_TOP
;
if
(
aPlacement
=
=
eZPlacementBottom
)
behind
=
HWND_BOTTOM
;
else
if
(
aPlacement
=
=
eZPlacementBelow
&
&
aWidget
)
behind
=
(
HWND
)
aWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
UINT
flags
=
SWP_NOMOVE
|
SWP_NOREPOSITION
|
SWP_NOSIZE
;
if
(
!
aActivate
)
flags
|
=
SWP_NOACTIVATE
;
if
(
!
CanTakeFocus
(
)
&
&
behind
=
=
HWND_TOP
)
{
HWND
wndAfter
=
:
:
GetForegroundWindow
(
)
;
if
(
!
wndAfter
)
behind
=
HWND_BOTTOM
;
else
if
(
!
(
GetWindowLongPtrW
(
wndAfter
GWL_EXSTYLE
)
&
WS_EX_TOPMOST
)
)
behind
=
wndAfter
;
flags
|
=
SWP_NOACTIVATE
;
}
:
:
SetWindowPos
(
mWnd
behind
0
0
0
0
flags
)
;
}
static
UINT
GetCurrentShowCmd
(
HWND
aWnd
)
{
WINDOWPLACEMENT
pl
;
pl
.
length
=
sizeof
(
pl
)
;
:
:
GetWindowPlacement
(
aWnd
&
pl
)
;
return
pl
.
showCmd
;
}
void
nsWindow
:
:
SetSizeMode
(
nsSizeMode
aMode
)
{
if
(
mIsShowingPreXULSkeletonUI
&
&
WasPreXULSkeletonUIMaximized
(
)
)
{
return
;
}
mFrameState
-
>
EnsureSizeMode
(
aMode
)
;
}
nsSizeMode
nsWindow
:
:
SizeMode
(
)
{
return
mFrameState
-
>
GetSizeMode
(
)
;
}
void
DoGetWorkspaceID
(
HWND
aWnd
nsAString
*
aWorkspaceID
)
{
RefPtr
<
IVirtualDesktopManager
>
desktopManager
=
gVirtualDesktopManager
;
if
(
!
desktopManager
|
|
!
aWnd
)
{
return
;
}
GUID
desktop
;
HRESULT
hr
=
desktopManager
-
>
GetWindowDesktopId
(
aWnd
&
desktop
)
;
if
(
FAILED
(
hr
)
)
{
return
;
}
RPC_WSTR
workspaceIDStr
=
nullptr
;
if
(
UuidToStringW
(
&
desktop
&
workspaceIDStr
)
=
=
RPC_S_OK
)
{
aWorkspaceID
-
>
Assign
(
(
wchar_t
*
)
workspaceIDStr
)
;
RpcStringFreeW
(
&
workspaceIDStr
)
;
}
}
void
nsWindow
:
:
GetWorkspaceID
(
nsAString
&
workspaceID
)
{
auto
desktop
=
mDesktopId
.
Lock
(
)
;
if
(
desktop
-
>
mID
.
IsEmpty
(
)
)
{
DoGetWorkspaceID
(
mWnd
&
desktop
-
>
mID
)
;
desktop
-
>
mUpdateIsQueued
=
false
;
}
else
{
AsyncUpdateWorkspaceID
(
*
desktop
)
;
}
workspaceID
=
desktop
-
>
mID
;
}
void
nsWindow
:
:
AsyncUpdateWorkspaceID
(
Desktop
&
aDesktop
)
{
struct
UpdateWorkspaceIdTask
:
public
Task
{
explicit
UpdateWorkspaceIdTask
(
nsWindow
*
aSelf
)
:
Task
(
false
EventQueuePriority
:
:
Normal
)
mSelf
(
aSelf
)
{
}
bool
Run
(
)
override
{
auto
desktop
=
mSelf
-
>
mDesktopId
.
Lock
(
)
;
if
(
desktop
-
>
mUpdateIsQueued
)
{
DoGetWorkspaceID
(
mSelf
-
>
mWnd
&
desktop
-
>
mID
)
;
desktop
-
>
mUpdateIsQueued
=
false
;
}
return
true
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
bool
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
UpdateWorkspaceIdTask
"
)
;
return
true
;
}
#
endif
RefPtr
<
nsWindow
>
mSelf
;
}
;
if
(
aDesktop
.
mUpdateIsQueued
)
{
return
;
}
aDesktop
.
mUpdateIsQueued
=
true
;
TaskController
:
:
Get
(
)
-
>
AddTask
(
MakeAndAddRef
<
UpdateWorkspaceIdTask
>
(
this
)
)
;
}
void
nsWindow
:
:
MoveToWorkspace
(
const
nsAString
&
workspaceID
)
{
RefPtr
<
IVirtualDesktopManager
>
desktopManager
=
gVirtualDesktopManager
;
if
(
!
desktopManager
)
{
return
;
}
GUID
desktop
;
const
nsString
flat
=
PromiseFlatString
(
workspaceID
)
;
RPC_WSTR
workspaceIDStr
=
reinterpret_cast
<
RPC_WSTR
>
(
(
wchar_t
*
)
flat
.
get
(
)
)
;
if
(
UuidFromStringW
(
workspaceIDStr
&
desktop
)
=
=
RPC_S_OK
)
{
if
(
SUCCEEDED
(
desktopManager
-
>
MoveWindowToDesktop
(
mWnd
desktop
)
)
)
{
auto
desktop
=
mDesktopId
.
Lock
(
)
;
desktop
-
>
mID
=
workspaceID
;
}
}
}
void
nsWindow
:
:
SuppressAnimation
(
bool
aSuppress
)
{
DWORD
dwAttribute
=
aSuppress
?
TRUE
:
FALSE
;
DwmSetWindowAttribute
(
mWnd
DWMWA_TRANSITIONS_FORCEDISABLED
&
dwAttribute
sizeof
dwAttribute
)
;
}
void
nsWindow
:
:
ConstrainPosition
(
bool
aAllowSlop
int32_t
*
aX
int32_t
*
aY
)
{
if
(
!
mIsTopWidgetWindow
)
return
;
double
dpiScale
=
GetDesktopToDeviceScale
(
)
.
scale
;
int32_t
logWidth
=
std
:
:
max
<
int32_t
>
(
NSToIntRound
(
mBounds
.
Width
(
)
/
dpiScale
)
1
)
;
int32_t
logHeight
=
std
:
:
max
<
int32_t
>
(
NSToIntRound
(
mBounds
.
Height
(
)
/
dpiScale
)
1
)
;
RECT
screenRect
;
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
sScreenManagerContractID
)
;
if
(
!
screenmgr
)
{
return
;
}
nsCOMPtr
<
nsIScreen
>
screen
;
int32_t
left
top
width
height
;
screenmgr
-
>
ScreenForRect
(
*
aX
*
aY
logWidth
logHeight
getter_AddRefs
(
screen
)
)
;
if
(
mFrameState
-
>
GetSizeMode
(
)
!
=
nsSizeMode_Fullscreen
)
{
nsresult
rv
=
screen
-
>
GetAvailRectDisplayPix
(
&
left
&
top
&
width
&
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
else
{
nsresult
rv
=
screen
-
>
GetRectDisplayPix
(
&
left
&
top
&
width
&
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
screenRect
.
left
=
left
;
screenRect
.
right
=
left
+
width
;
screenRect
.
top
=
top
;
screenRect
.
bottom
=
top
+
height
;
if
(
aAllowSlop
)
{
if
(
*
aX
<
screenRect
.
left
-
logWidth
+
kWindowPositionSlop
)
*
aX
=
screenRect
.
left
-
logWidth
+
kWindowPositionSlop
;
else
if
(
*
aX
>
=
screenRect
.
right
-
kWindowPositionSlop
)
*
aX
=
screenRect
.
right
-
kWindowPositionSlop
;
if
(
*
aY
<
screenRect
.
top
-
logHeight
+
kWindowPositionSlop
)
*
aY
=
screenRect
.
top
-
logHeight
+
kWindowPositionSlop
;
else
if
(
*
aY
>
=
screenRect
.
bottom
-
kWindowPositionSlop
)
*
aY
=
screenRect
.
bottom
-
kWindowPositionSlop
;
}
else
{
if
(
*
aX
<
screenRect
.
left
)
*
aX
=
screenRect
.
left
;
else
if
(
*
aX
>
=
screenRect
.
right
-
logWidth
)
*
aX
=
screenRect
.
right
-
logWidth
;
if
(
*
aY
<
screenRect
.
top
)
*
aY
=
screenRect
.
top
;
else
if
(
*
aY
>
=
screenRect
.
bottom
-
logHeight
)
*
aY
=
screenRect
.
bottom
-
logHeight
;
}
}
void
nsWindow
:
:
Enable
(
bool
bState
)
{
if
(
mWnd
)
{
:
:
EnableWindow
(
mWnd
bState
)
;
}
}
bool
nsWindow
:
:
IsEnabled
(
)
const
{
return
!
mWnd
|
|
(
:
:
IsWindowEnabled
(
mWnd
)
&
&
:
:
IsWindowEnabled
(
:
:
GetAncestor
(
mWnd
GA_ROOT
)
)
)
;
}
void
nsWindow
:
:
SetFocus
(
Raise
aRaise
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
{
if
(
mWnd
)
{
#
ifdef
WINSTATE_DEBUG_OUTPUT
if
(
mWnd
=
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
)
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
SetFocus
:
[
top
]
raise
=
%
d
\
n
"
aRaise
=
=
Raise
:
:
Yes
)
)
;
}
else
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
SetFocus
:
[
child
]
raise
=
%
d
\
n
"
aRaise
=
=
Raise
:
:
Yes
)
)
;
}
#
endif
HWND
toplevelWnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
)
;
if
(
aRaise
=
=
Raise
:
:
Yes
&
&
:
:
IsIconic
(
toplevelWnd
)
)
{
:
:
ShowWindow
(
toplevelWnd
SW_RESTORE
)
;
}
:
:
SetFocus
(
mWnd
)
;
}
}
LayoutDeviceIntRect
nsWindow
:
:
GetBounds
(
)
{
if
(
!
mWnd
)
{
return
mBounds
;
}
RECT
r
;
VERIFY
(
:
:
GetWindowRect
(
mWnd
&
r
)
)
;
LayoutDeviceIntRect
rect
;
rect
.
SizeTo
(
r
.
right
-
r
.
left
r
.
bottom
-
r
.
top
)
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
rect
.
MoveTo
(
r
.
left
r
.
top
)
;
return
rect
;
}
HWND
parent
=
:
:
GetParent
(
mWnd
)
;
if
(
parent
)
{
RECT
pr
;
VERIFY
(
:
:
GetWindowRect
(
parent
&
pr
)
)
;
r
.
left
-
=
pr
.
left
;
r
.
top
-
=
pr
.
top
;
nsWindow
*
pWidget
=
static_cast
<
nsWindow
*
>
(
GetParent
(
)
)
;
if
(
pWidget
&
&
pWidget
-
>
IsTopLevelWidget
(
)
)
{
LayoutDeviceIntPoint
clientOffset
=
pWidget
-
>
GetClientOffset
(
)
;
r
.
left
-
=
clientOffset
.
x
;
r
.
top
-
=
clientOffset
.
y
;
}
}
rect
.
MoveTo
(
r
.
left
r
.
top
)
;
if
(
mCompositorSession
&
&
!
wr
:
:
WindowSizeSanityCheck
(
rect
.
width
rect
.
height
)
)
{
gfxCriticalNoteOnce
<
<
"
Invalid
size
"
<
<
rect
<
<
"
size
mode
"
<
<
mFrameState
-
>
GetSizeMode
(
)
;
}
return
rect
;
}
LayoutDeviceIntRect
nsWindow
:
:
GetClientBounds
(
)
{
if
(
!
mWnd
)
{
return
LayoutDeviceIntRect
(
0
0
0
0
)
;
}
RECT
r
;
if
(
!
:
:
GetClientRect
(
mWnd
&
r
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
to
be
called
"
)
;
gfxCriticalNoteOnce
<
<
"
GetClientRect
failed
"
<
<
:
:
GetLastError
(
)
;
return
mBounds
;
}
LayoutDeviceIntRect
bounds
=
GetBounds
(
)
;
LayoutDeviceIntRect
rect
;
rect
.
MoveTo
(
bounds
.
TopLeft
(
)
+
GetClientOffset
(
)
)
;
rect
.
SizeTo
(
r
.
right
-
r
.
left
r
.
bottom
-
r
.
top
)
;
return
rect
;
}
LayoutDeviceIntRect
nsWindow
:
:
GetScreenBounds
(
)
{
if
(
!
mWnd
)
{
return
mBounds
;
}
RECT
r
;
VERIFY
(
:
:
GetWindowRect
(
mWnd
&
r
)
)
;
return
LayoutDeviceIntRect
(
r
.
left
r
.
top
r
.
right
-
r
.
left
r
.
bottom
-
r
.
top
)
;
}
nsresult
nsWindow
:
:
GetRestoredBounds
(
LayoutDeviceIntRect
&
aRect
)
{
if
(
SizeMode
(
)
=
=
nsSizeMode_Normal
)
{
aRect
=
GetScreenBounds
(
)
;
return
NS_OK
;
}
if
(
!
mWnd
)
{
return
NS_ERROR_FAILURE
;
}
WINDOWPLACEMENT
pl
=
{
sizeof
(
WINDOWPLACEMENT
)
}
;
VERIFY
(
:
:
GetWindowPlacement
(
mWnd
&
pl
)
)
;
const
RECT
&
r
=
pl
.
rcNormalPosition
;
HMONITOR
monitor
=
:
:
MonitorFromWindow
(
mWnd
MONITOR_DEFAULTTONULL
)
;
if
(
!
monitor
)
{
return
NS_ERROR_FAILURE
;
}
MONITORINFO
mi
=
{
sizeof
(
MONITORINFO
)
}
;
VERIFY
(
:
:
GetMonitorInfo
(
monitor
&
mi
)
)
;
aRect
.
SetRect
(
r
.
left
r
.
top
r
.
right
-
r
.
left
r
.
bottom
-
r
.
top
)
;
aRect
.
MoveBy
(
mi
.
rcWork
.
left
-
mi
.
rcMonitor
.
left
mi
.
rcWork
.
top
-
mi
.
rcMonitor
.
top
)
;
return
NS_OK
;
}
LayoutDeviceIntPoint
nsWindow
:
:
GetClientOffset
(
)
{
if
(
!
mWnd
)
{
return
LayoutDeviceIntPoint
(
0
0
)
;
}
RECT
r1
;
GetWindowRect
(
mWnd
&
r1
)
;
LayoutDeviceIntPoint
pt
=
WidgetToScreenOffset
(
)
;
return
LayoutDeviceIntPoint
(
pt
.
x
-
r1
.
left
pt
.
y
-
r1
.
top
)
;
}
void
nsWindow
:
:
SetDrawsInTitlebar
(
bool
aState
)
{
nsWindow
*
window
=
GetTopLevelWindow
(
true
)
;
if
(
window
&
&
window
!
=
this
)
{
return
window
-
>
SetDrawsInTitlebar
(
aState
)
;
}
if
(
aState
)
{
LayoutDeviceIntMargin
margins
(
0
-
1
-
1
-
1
)
;
SetNonClientMargins
(
margins
)
;
}
else
{
LayoutDeviceIntMargin
margins
(
-
1
-
1
-
1
-
1
)
;
SetNonClientMargins
(
margins
)
;
}
}
void
nsWindow
:
:
ResetLayout
(
)
{
SetWindowPos
(
mWnd
0
0
0
0
0
SWP_FRAMECHANGED
|
SWP_NOACTIVATE
|
SWP_NOMOVE
|
SWP_NOOWNERZORDER
|
SWP_NOSIZE
|
SWP_NOZORDER
)
;
if
(
!
mIsVisible
)
{
return
;
}
RECT
clientRc
=
{
0
}
;
GetClientRect
(
mWnd
&
clientRc
)
;
OnResize
(
WinUtils
:
:
ToIntRect
(
clientRc
)
.
Size
(
)
)
;
Invalidate
(
)
;
}
static
const
wchar_t
kManageWindowInfoProperty
[
]
=
L
"
ManageWindowInfoProperty
"
;
typedef
BOOL
(
WINAPI
*
GetWindowInfoPtr
)
(
HWND
hwnd
PWINDOWINFO
pwi
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
GetWindowInfoPtr
>
sGetWindowInfoPtrStub
;
BOOL
WINAPI
GetWindowInfoHook
(
HWND
hWnd
PWINDOWINFO
pwi
)
{
if
(
!
sGetWindowInfoPtrStub
)
{
NS_ASSERTION
(
FALSE
"
Something
is
horribly
wrong
in
GetWindowInfoHook
!
"
)
;
return
FALSE
;
}
int
windowStatus
=
reinterpret_cast
<
LONG_PTR
>
(
GetPropW
(
hWnd
kManageWindowInfoProperty
)
)
;
if
(
!
windowStatus
)
return
sGetWindowInfoPtrStub
(
hWnd
pwi
)
;
BOOL
result
=
sGetWindowInfoPtrStub
(
hWnd
pwi
)
;
if
(
result
&
&
pwi
)
pwi
-
>
dwWindowStatus
=
(
windowStatus
=
=
1
?
0
:
WS_ACTIVECAPTION
)
;
return
result
;
}
void
nsWindow
:
:
UpdateGetWindowInfoCaptionStatus
(
bool
aActiveCaption
)
{
if
(
!
mWnd
)
return
;
sUser32Intercept
.
Init
(
"
user32
.
dll
"
)
;
sGetWindowInfoPtrStub
.
Set
(
sUser32Intercept
"
GetWindowInfo
"
&
GetWindowInfoHook
)
;
if
(
!
sGetWindowInfoPtrStub
)
{
return
;
}
SetPropW
(
mWnd
kManageWindowInfoProperty
reinterpret_cast
<
HANDLE
>
(
static_cast
<
INT_PTR
>
(
aActiveCaption
)
+
1
)
)
;
}
#
define
DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1
19
#
define
DWMWA_USE_IMMERSIVE_DARK_MODE
20
void
nsWindow
:
:
UpdateDarkModeToolbar
(
)
{
if
(
!
IsWin10OrLater
(
)
)
{
return
;
}
LookAndFeel
:
:
EnsureColorSchemesInitialized
(
)
;
BOOL
dark
=
LookAndFeel
:
:
ColorSchemeForChrome
(
)
=
=
ColorScheme
:
:
Dark
;
DwmSetWindowAttribute
(
mWnd
DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1
&
dark
sizeof
dark
)
;
DwmSetWindowAttribute
(
mWnd
DWMWA_USE_IMMERSIVE_DARK_MODE
&
dark
sizeof
dark
)
;
}
bool
nsWindow
:
:
UpdateNonClientMargins
(
int32_t
aSizeMode
bool
aReflowWindow
)
{
if
(
!
mCustomNonClient
)
{
return
false
;
}
if
(
aSizeMode
=
=
-
1
)
{
aSizeMode
=
mFrameState
-
>
GetSizeMode
(
)
;
}
bool
hasCaption
=
(
mBorderStyle
&
(
eBorderStyle_all
|
eBorderStyle_title
|
eBorderStyle_menu
|
eBorderStyle_default
)
)
;
float
dpi
=
GetDPI
(
)
;
mCaptionHeight
=
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CYFRAME
dpi
)
+
(
hasCaption
?
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CYCAPTION
dpi
)
+
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
dpi
)
:
0
)
;
if
(
!
mUseResizeMarginOverrides
)
{
mHorResizeMargin
=
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CXFRAME
dpi
)
+
(
hasCaption
?
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
dpi
)
:
0
)
;
mVertResizeMargin
=
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CYFRAME
dpi
)
+
(
hasCaption
?
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
dpi
)
:
0
)
;
}
if
(
aSizeMode
=
=
nsSizeMode_Minimized
)
{
mNonClientOffset
.
top
=
0
;
mNonClientOffset
.
left
=
0
;
mNonClientOffset
.
right
=
0
;
mNonClientOffset
.
bottom
=
0
;
}
else
if
(
aSizeMode
=
=
nsSizeMode_Fullscreen
)
{
mNonClientOffset
.
top
=
mCaptionHeight
;
mNonClientOffset
.
bottom
=
mVertResizeMargin
;
mNonClientOffset
.
left
=
mHorResizeMargin
;
mNonClientOffset
.
right
=
mHorResizeMargin
;
}
else
if
(
aSizeMode
=
=
nsSizeMode_Maximized
)
{
int
verticalResize
=
0
;
if
(
IsWin10OrLater
(
)
)
{
verticalResize
=
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CYFRAME
dpi
)
+
(
hasCaption
?
WinUtils
:
:
GetSystemMetricsForDpi
(
SM_CXPADDEDBORDER
dpi
)
:
0
)
;
}
mNonClientOffset
.
top
=
mCaptionHeight
-
verticalResize
;
mNonClientOffset
.
bottom
=
0
;
mNonClientOffset
.
left
=
0
;
mNonClientOffset
.
right
=
0
;
APPBARDATA
appBarData
;
appBarData
.
cbSize
=
sizeof
(
appBarData
)
;
UINT
taskbarState
=
SHAppBarMessage
(
ABM_GETSTATE
&
appBarData
)
;
if
(
ABS_AUTOHIDE
&
taskbarState
)
{
UINT
edge
=
-
1
;
appBarData
.
hWnd
=
FindWindow
(
L
"
Shell_TrayWnd
"
nullptr
)
;
if
(
appBarData
.
hWnd
)
{
HMONITOR
taskbarMonitor
=
:
:
MonitorFromWindow
(
appBarData
.
hWnd
MONITOR_DEFAULTTOPRIMARY
)
;
HMONITOR
windowMonitor
=
:
:
MonitorFromWindow
(
mWnd
MONITOR_DEFAULTTONEAREST
)
;
if
(
taskbarMonitor
=
=
windowMonitor
)
{
SHAppBarMessage
(
ABM_GETTASKBARPOS
&
appBarData
)
;
edge
=
appBarData
.
uEdge
;
}
}
if
(
ABE_LEFT
=
=
edge
)
{
mNonClientOffset
.
left
-
=
1
;
}
else
if
(
ABE_RIGHT
=
=
edge
)
{
mNonClientOffset
.
right
-
=
1
;
}
else
if
(
ABE_BOTTOM
=
=
edge
|
|
ABE_TOP
=
=
edge
)
{
mNonClientOffset
.
bottom
-
=
1
;
}
}
}
else
{
bool
glass
=
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
;
if
(
mNonClientMargins
.
top
>
0
&
&
glass
)
{
mNonClientOffset
.
top
=
std
:
:
min
(
mCaptionHeight
mNonClientMargins
.
top
)
;
}
else
if
(
mNonClientMargins
.
top
=
=
0
)
{
mNonClientOffset
.
top
=
mCaptionHeight
;
}
else
{
mNonClientOffset
.
top
=
0
;
}
if
(
mNonClientMargins
.
bottom
>
0
&
&
glass
)
{
mNonClientOffset
.
bottom
=
std
:
:
min
(
mVertResizeMargin
mNonClientMargins
.
bottom
)
;
}
else
if
(
mNonClientMargins
.
bottom
=
=
0
)
{
mNonClientOffset
.
bottom
=
mVertResizeMargin
;
}
else
{
mNonClientOffset
.
bottom
=
0
;
}
if
(
mNonClientMargins
.
left
>
0
&
&
glass
)
{
mNonClientOffset
.
left
=
std
:
:
min
(
mHorResizeMargin
mNonClientMargins
.
left
)
;
}
else
if
(
mNonClientMargins
.
left
=
=
0
)
{
mNonClientOffset
.
left
=
mHorResizeMargin
;
}
else
{
mNonClientOffset
.
left
=
0
;
}
if
(
mNonClientMargins
.
right
>
0
&
&
glass
)
{
mNonClientOffset
.
right
=
std
:
:
min
(
mHorResizeMargin
mNonClientMargins
.
right
)
;
}
else
if
(
mNonClientMargins
.
right
=
=
0
)
{
mNonClientOffset
.
right
=
mHorResizeMargin
;
}
else
{
mNonClientOffset
.
right
=
0
;
}
}
if
(
aReflowWindow
)
{
ResetLayout
(
)
;
}
return
true
;
}
nsresult
nsWindow
:
:
SetNonClientMargins
(
LayoutDeviceIntMargin
&
margins
)
{
if
(
!
mIsTopWidgetWindow
|
|
mBorderStyle
=
=
eBorderStyle_none
)
return
NS_ERROR_INVALID_ARG
;
if
(
mHideChrome
)
{
mFutureMarginsOnceChromeShows
=
margins
;
mFutureMarginsToUse
=
true
;
return
NS_OK
;
}
mFutureMarginsToUse
=
false
;
if
(
margins
.
top
=
=
-
1
&
&
margins
.
left
=
=
-
1
&
&
margins
.
right
=
=
-
1
&
&
margins
.
bottom
=
=
-
1
)
{
mCustomNonClient
=
false
;
mNonClientMargins
=
margins
;
ResetLayout
(
)
;
int
windowStatus
=
reinterpret_cast
<
LONG_PTR
>
(
GetPropW
(
mWnd
kManageWindowInfoProperty
)
)
;
if
(
windowStatus
)
{
:
:
SendMessageW
(
mWnd
WM_NCACTIVATE
1
!
=
windowStatus
0
)
;
}
return
NS_OK
;
}
if
(
margins
.
top
<
-
1
|
|
margins
.
bottom
<
-
1
|
|
margins
.
left
<
-
1
|
|
margins
.
right
<
-
1
)
return
NS_ERROR_INVALID_ARG
;
mNonClientMargins
=
margins
;
mCustomNonClient
=
true
;
if
(
!
UpdateNonClientMargins
(
)
)
{
NS_WARNING
(
"
UpdateNonClientMargins
failed
!
"
)
;
return
NS_OK
;
}
return
NS_OK
;
}
void
nsWindow
:
:
SetResizeMargin
(
mozilla
:
:
LayoutDeviceIntCoord
aResizeMargin
)
{
mUseResizeMarginOverrides
=
true
;
mHorResizeMargin
=
aResizeMargin
;
mVertResizeMargin
=
aResizeMargin
;
UpdateNonClientMargins
(
)
;
}
void
nsWindow
:
:
InvalidateNonClientRegion
(
)
{
RECT
rect
;
GetWindowRect
(
mWnd
&
rect
)
;
MapWindowPoints
(
nullptr
mWnd
(
LPPOINT
)
&
rect
2
)
;
HRGN
winRgn
=
CreateRectRgnIndirect
(
&
rect
)
;
GetWindowRect
(
mWnd
&
rect
)
;
rect
.
top
+
=
mCaptionHeight
;
rect
.
right
-
=
mHorResizeMargin
;
rect
.
bottom
-
=
mVertResizeMargin
;
rect
.
left
+
=
mHorResizeMargin
;
MapWindowPoints
(
nullptr
mWnd
(
LPPOINT
)
&
rect
2
)
;
HRGN
clientRgn
=
CreateRectRgnIndirect
(
&
rect
)
;
CombineRgn
(
winRgn
winRgn
clientRgn
RGN_DIFF
)
;
DeleteObject
(
clientRgn
)
;
RedrawWindow
(
mWnd
nullptr
winRgn
RDW_FRAME
|
RDW_INVALIDATE
)
;
DeleteObject
(
winRgn
)
;
}
HRGN
nsWindow
:
:
ExcludeNonClientFromPaintRegion
(
HRGN
aRegion
)
{
RECT
rect
;
HRGN
rgn
=
nullptr
;
if
(
aRegion
=
=
(
HRGN
)
1
)
{
GetWindowRect
(
mWnd
&
rect
)
;
rgn
=
CreateRectRgnIndirect
(
&
rect
)
;
}
else
{
rgn
=
aRegion
;
}
GetClientRect
(
mWnd
&
rect
)
;
MapWindowPoints
(
mWnd
nullptr
(
LPPOINT
)
&
rect
2
)
;
HRGN
nonClientRgn
=
CreateRectRgnIndirect
(
&
rect
)
;
CombineRgn
(
rgn
rgn
nonClientRgn
RGN_DIFF
)
;
DeleteObject
(
nonClientRgn
)
;
return
rgn
;
}
void
nsWindow
:
:
SetBackgroundColor
(
const
nscolor
&
aColor
)
{
if
(
mBrush
)
:
:
DeleteObject
(
mBrush
)
;
mBrush
=
:
:
CreateSolidBrush
(
NSRGB_2_COLOREF
(
aColor
)
)
;
if
(
mWnd
!
=
nullptr
)
{
:
:
SetClassLongPtrW
(
mWnd
GCLP_HBRBACKGROUND
(
LONG_PTR
)
mBrush
)
;
}
}
static
HCURSOR
CursorFor
(
nsCursor
aCursor
)
{
switch
(
aCursor
)
{
case
eCursor_select
:
return
:
:
LoadCursor
(
nullptr
IDC_IBEAM
)
;
case
eCursor_wait
:
return
:
:
LoadCursor
(
nullptr
IDC_WAIT
)
;
case
eCursor_hyperlink
:
return
:
:
LoadCursor
(
nullptr
IDC_HAND
)
;
case
eCursor_standard
:
case
eCursor_context_menu
:
return
:
:
LoadCursor
(
nullptr
IDC_ARROW
)
;
case
eCursor_n_resize
:
case
eCursor_s_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZENS
)
;
case
eCursor_w_resize
:
case
eCursor_e_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZEWE
)
;
case
eCursor_nw_resize
:
case
eCursor_se_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZENWSE
)
;
case
eCursor_ne_resize
:
case
eCursor_sw_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZENESW
)
;
case
eCursor_crosshair
:
return
:
:
LoadCursor
(
nullptr
IDC_CROSS
)
;
case
eCursor_move
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZEALL
)
;
case
eCursor_help
:
return
:
:
LoadCursor
(
nullptr
IDC_HELP
)
;
case
eCursor_copy
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_COPY
)
)
;
case
eCursor_alias
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_ALIAS
)
)
;
case
eCursor_cell
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_CELL
)
)
;
case
eCursor_grab
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_GRAB
)
)
;
case
eCursor_grabbing
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_GRABBING
)
)
;
case
eCursor_spinning
:
return
:
:
LoadCursor
(
nullptr
IDC_APPSTARTING
)
;
case
eCursor_zoom_in
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_ZOOMIN
)
)
;
case
eCursor_zoom_out
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_ZOOMOUT
)
)
;
case
eCursor_not_allowed
:
case
eCursor_no_drop
:
return
:
:
LoadCursor
(
nullptr
IDC_NO
)
;
case
eCursor_col_resize
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_COLRESIZE
)
)
;
case
eCursor_row_resize
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_ROWRESIZE
)
)
;
case
eCursor_vertical_text
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_VERTICALTEXT
)
)
;
case
eCursor_all_scroll
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZEALL
)
;
case
eCursor_nesw_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZENESW
)
;
case
eCursor_nwse_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZENWSE
)
;
case
eCursor_ns_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZENS
)
;
case
eCursor_ew_resize
:
return
:
:
LoadCursor
(
nullptr
IDC_SIZEWE
)
;
case
eCursor_none
:
return
:
:
LoadCursor
(
nsToolkit
:
:
mDllInstance
MAKEINTRESOURCE
(
IDC_NONE
)
)
;
default
:
NS_ERROR
(
"
Invalid
cursor
type
"
)
;
return
nullptr
;
}
}
static
HCURSOR
CursorForImage
(
const
nsIWidget
:
:
Cursor
&
aCursor
CSSToLayoutDeviceScale
aScale
)
{
if
(
!
aCursor
.
IsCustom
(
)
)
{
return
nullptr
;
}
nsIntSize
size
=
nsIWidget
:
:
CustomCursorSize
(
aCursor
)
;
if
(
size
.
width
>
128
|
|
size
.
height
>
128
)
{
return
nullptr
;
}
LayoutDeviceIntSize
layoutSize
=
RoundedToInt
(
CSSIntSize
(
size
.
width
size
.
height
)
*
aScale
)
;
LayoutDeviceIntPoint
hotspot
=
RoundedToInt
(
CSSIntPoint
(
aCursor
.
mHotspotX
aCursor
.
mHotspotY
)
*
aScale
)
;
HCURSOR
cursor
;
nsresult
rv
=
nsWindowGfx
:
:
CreateIcon
(
aCursor
.
mContainer
true
hotspot
layoutSize
&
cursor
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
cursor
;
}
void
nsWindow
:
:
SetCursor
(
const
Cursor
&
aCursor
)
{
static
HCURSOR
sCurrentHCursor
=
nullptr
;
static
bool
sCurrentHCursorIsCustom
=
false
;
mCursor
=
aCursor
;
if
(
sCurrentCursor
=
=
aCursor
&
&
sCurrentHCursor
&
&
!
mUpdateCursor
)
{
:
:
SetCursor
(
sCurrentHCursor
)
;
return
;
}
mUpdateCursor
=
false
;
if
(
sCurrentHCursorIsCustom
)
{
:
:
DestroyIcon
(
sCurrentHCursor
)
;
}
sCurrentHCursor
=
nullptr
;
sCurrentHCursorIsCustom
=
false
;
sCurrentCursor
=
aCursor
;
HCURSOR
cursor
=
CursorForImage
(
aCursor
GetDefaultScale
(
)
)
;
bool
custom
=
false
;
if
(
cursor
)
{
custom
=
true
;
}
else
{
cursor
=
CursorFor
(
aCursor
.
mDefaultCursor
)
;
}
if
(
!
cursor
)
{
return
;
}
sCurrentHCursor
=
cursor
;
sCurrentHCursorIsCustom
=
custom
;
:
:
SetCursor
(
cursor
)
;
}
nsTransparencyMode
nsWindow
:
:
GetTransparencyMode
(
)
{
return
GetTopLevelWindow
(
true
)
-
>
GetWindowTranslucencyInner
(
)
;
}
void
nsWindow
:
:
SetTransparencyMode
(
nsTransparencyMode
aMode
)
{
nsWindow
*
window
=
GetTopLevelWindow
(
true
)
;
MOZ_ASSERT
(
window
)
;
if
(
!
window
|
|
window
-
>
DestroyCalled
(
)
)
{
return
;
}
if
(
nsWindowType
:
:
eWindowType_toplevel
=
=
window
-
>
mWindowType
&
&
mTransparencyMode
!
=
aMode
&
&
!
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
{
NS_WARNING
(
"
Cannot
set
transparency
mode
on
top
-
level
windows
.
"
)
;
return
;
}
window
-
>
SetWindowTranslucencyInner
(
aMode
)
;
}
void
nsWindow
:
:
UpdateOpaqueRegion
(
const
LayoutDeviceIntRegion
&
aOpaqueRegion
)
{
if
(
!
HasGlass
(
)
|
|
GetParent
(
)
)
return
;
MARGINS
margins
=
{
-
1
-
1
-
1
-
1
}
;
if
(
!
aOpaqueRegion
.
IsEmpty
(
)
)
{
LayoutDeviceIntRect
clientBounds
=
GetClientBounds
(
)
;
LayoutDeviceIntRect
largest
=
aOpaqueRegion
.
GetLargestRectangle
(
)
;
margins
.
cxLeftWidth
=
largest
.
X
(
)
;
margins
.
cxRightWidth
=
clientBounds
.
Width
(
)
-
largest
.
XMost
(
)
;
margins
.
cyBottomHeight
=
clientBounds
.
Height
(
)
-
largest
.
YMost
(
)
;
if
(
mCustomNonClient
)
{
largest
.
MoveToY
(
std
:
:
max
<
uint32_t
>
(
largest
.
Y
(
)
nsUXThemeData
:
:
GetCommandButtonBoxMetrics
(
)
.
cy
)
)
;
}
margins
.
cyTopHeight
=
largest
.
Y
(
)
;
}
if
(
memcmp
(
&
mGlassMargins
&
margins
sizeof
mGlassMargins
)
)
{
mGlassMargins
=
margins
;
UpdateGlass
(
)
;
}
}
void
nsWindow
:
:
UpdateWindowDraggingRegion
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
if
(
mDraggableRegion
!
=
aRegion
)
{
mDraggableRegion
=
aRegion
;
}
}
void
nsWindow
:
:
UpdateGlass
(
)
{
MARGINS
margins
=
mGlassMargins
;
DWMNCRENDERINGPOLICY
policy
=
DWMNCRP_USEWINDOWSTYLE
;
switch
(
mTransparencyMode
)
{
case
eTransparencyBorderlessGlass
:
if
(
margins
.
cxLeftWidth
>
=
0
)
{
margins
.
cxLeftWidth
+
=
kGlassMarginAdjustment
;
margins
.
cyTopHeight
+
=
kGlassMarginAdjustment
;
margins
.
cxRightWidth
+
=
kGlassMarginAdjustment
;
margins
.
cyBottomHeight
+
=
kGlassMarginAdjustment
;
}
[
[
fallthrough
]
]
;
case
eTransparencyGlass
:
policy
=
DWMNCRP_ENABLED
;
break
;
default
:
break
;
}
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
glass
margins
:
left
:
%
d
top
:
%
d
right
:
%
d
bottom
:
%
d
\
n
"
margins
.
cxLeftWidth
margins
.
cyTopHeight
margins
.
cxRightWidth
margins
.
cyBottomHeight
)
)
;
if
(
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
{
DwmExtendFrameIntoClientArea
(
mWnd
&
margins
)
;
DwmSetWindowAttribute
(
mWnd
DWMWA_NCRENDERING_POLICY
&
policy
sizeof
policy
)
;
}
}
void
nsWindow
:
:
HideWindowChrome
(
bool
aShouldHide
)
{
HWND
hwnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
true
)
;
if
(
!
WinUtils
:
:
GetNSWindowPtr
(
hwnd
)
)
{
NS_WARNING
(
"
Trying
to
hide
window
decorations
in
an
embedded
context
"
)
;
return
;
}
if
(
mHideChrome
=
=
aShouldHide
)
return
;
DWORD_PTR
style
exStyle
;
mHideChrome
=
aShouldHide
;
if
(
aShouldHide
)
{
DWORD_PTR
tempStyle
=
:
:
GetWindowLongPtrW
(
hwnd
GWL_STYLE
)
;
DWORD_PTR
tempExStyle
=
:
:
GetWindowLongPtrW
(
hwnd
GWL_EXSTYLE
)
;
style
=
tempStyle
&
~
(
WS_CAPTION
|
WS_THICKFRAME
)
;
exStyle
=
tempExStyle
&
~
(
WS_EX_DLGMODALFRAME
|
WS_EX_WINDOWEDGE
|
WS_EX_CLIENTEDGE
|
WS_EX_STATICEDGE
)
;
mOldStyle
=
tempStyle
;
mOldExStyle
=
tempExStyle
;
}
else
{
if
(
!
mOldStyle
|
|
!
mOldExStyle
)
{
mOldStyle
=
:
:
GetWindowLongPtrW
(
hwnd
GWL_STYLE
)
;
mOldExStyle
=
:
:
GetWindowLongPtrW
(
hwnd
GWL_EXSTYLE
)
;
}
style
=
mOldStyle
;
exStyle
=
mOldExStyle
;
if
(
mFutureMarginsToUse
)
{
SetNonClientMargins
(
mFutureMarginsOnceChromeShows
)
;
}
}
VERIFY_WINDOW_STYLE
(
style
)
;
:
:
SetWindowLongPtrW
(
hwnd
GWL_STYLE
style
)
;
:
:
SetWindowLongPtrW
(
hwnd
GWL_EXSTYLE
exStyle
)
;
}
void
nsWindow
:
:
Invalidate
(
bool
aEraseBackground
bool
aUpdateNCArea
bool
aIncludeChildren
)
{
if
(
!
mWnd
)
{
return
;
}
#
ifdef
WIDGET_DEBUG_OUTPUT
debug_DumpInvalidate
(
stdout
this
nullptr
"
noname
"
(
int32_t
)
mWnd
)
;
#
endif
DWORD
flags
=
RDW_INVALIDATE
;
if
(
aEraseBackground
)
{
flags
|
=
RDW_ERASE
;
}
if
(
aUpdateNCArea
)
{
flags
|
=
RDW_FRAME
;
}
if
(
aIncludeChildren
)
{
flags
|
=
RDW_ALLCHILDREN
;
}
VERIFY
(
:
:
RedrawWindow
(
mWnd
nullptr
nullptr
flags
)
)
;
}
void
nsWindow
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
if
(
mWnd
)
{
#
ifdef
WIDGET_DEBUG_OUTPUT
debug_DumpInvalidate
(
stdout
this
&
aRect
"
noname
"
(
int32_t
)
mWnd
)
;
#
endif
RECT
rect
;
rect
.
left
=
aRect
.
X
(
)
;
rect
.
top
=
aRect
.
Y
(
)
;
rect
.
right
=
aRect
.
XMost
(
)
;
rect
.
bottom
=
aRect
.
YMost
(
)
;
VERIFY
(
:
:
InvalidateRect
(
mWnd
&
rect
FALSE
)
)
;
}
}
static
LRESULT
CALLBACK
FullscreenTransitionWindowProc
(
HWND
hWnd
UINT
uMsg
WPARAM
wParam
LPARAM
lParam
)
{
switch
(
uMsg
)
{
case
WM_FULLSCREEN_TRANSITION_BEFORE
:
case
WM_FULLSCREEN_TRANSITION_AFTER
:
{
DWORD
duration
=
(
DWORD
)
lParam
;
DWORD
flags
=
AW_BLEND
;
if
(
uMsg
=
=
WM_FULLSCREEN_TRANSITION_AFTER
)
{
flags
|
=
AW_HIDE
;
}
:
:
AnimateWindow
(
hWnd
duration
flags
)
;
NS_DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
(
(
nsIRunnable
*
)
wParam
)
)
;
break
;
}
case
WM_DESTROY
:
:
:
PostQuitMessage
(
0
)
;
break
;
default
:
return
:
:
DefWindowProcW
(
hWnd
uMsg
wParam
lParam
)
;
}
return
0
;
}
struct
FullscreenTransitionInitData
{
nsIntRect
mBounds
;
HANDLE
mSemaphore
;
HANDLE
mThread
;
HWND
mWnd
;
FullscreenTransitionInitData
(
)
:
mSemaphore
(
nullptr
)
mThread
(
nullptr
)
mWnd
(
nullptr
)
{
}
~
FullscreenTransitionInitData
(
)
{
if
(
mSemaphore
)
{
:
:
CloseHandle
(
mSemaphore
)
;
}
if
(
mThread
)
{
:
:
CloseHandle
(
mThread
)
;
}
}
}
;
static
DWORD
WINAPI
FullscreenTransitionThreadProc
(
LPVOID
lpParam
)
{
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
WNDCLASSW
wc
=
{
}
;
wc
.
lpfnWndProc
=
:
:
FullscreenTransitionWindowProc
;
wc
.
hInstance
=
nsToolkit
:
:
mDllInstance
;
wc
.
hbrBackground
=
:
:
CreateSolidBrush
(
RGB
(
0
0
0
)
)
;
wc
.
lpszClassName
=
kClassNameTransition
;
:
:
RegisterClassW
(
&
wc
)
;
sInitialized
=
true
;
}
auto
data
=
static_cast
<
FullscreenTransitionInitData
*
>
(
lpParam
)
;
HWND
wnd
=
:
:
CreateWindowW
(
kClassNameTransition
L
"
"
0
0
0
0
0
nullptr
nullptr
nsToolkit
:
:
mDllInstance
nullptr
)
;
if
(
!
wnd
)
{
:
:
ReleaseSemaphore
(
data
-
>
mSemaphore
1
nullptr
)
;
return
0
;
}
:
:
ShowCursor
(
false
)
;
:
:
SetWindowLongW
(
wnd
GWL_STYLE
0
)
;
:
:
SetWindowLongW
(
wnd
GWL_EXSTYLE
WS_EX_LAYERED
|
WS_EX_TRANSPARENT
|
WS_EX_TOOLWINDOW
|
WS_EX_NOACTIVATE
)
;
:
:
SetWindowPos
(
wnd
HWND_TOPMOST
data
-
>
mBounds
.
X
(
)
data
-
>
mBounds
.
Y
(
)
data
-
>
mBounds
.
Width
(
)
data
-
>
mBounds
.
Height
(
)
0
)
;
data
-
>
mWnd
=
wnd
;
:
:
ReleaseSemaphore
(
data
-
>
mSemaphore
1
nullptr
)
;
data
=
nullptr
;
MSG
msg
;
while
(
:
:
GetMessageW
(
&
msg
nullptr
0
0
)
)
{
:
:
TranslateMessage
(
&
msg
)
;
:
:
DispatchMessage
(
&
msg
)
;
}
:
:
ShowCursor
(
true
)
;
:
:
DestroyWindow
(
wnd
)
;
return
0
;
}
class
FullscreenTransitionData
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
FullscreenTransitionData
(
HWND
aWnd
)
:
mWnd
(
aWnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
FullscreenTransitionData
"
"
should
be
constructed
in
the
main
thread
"
)
;
}
const
HWND
mWnd
;
private
:
~
FullscreenTransitionData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
FullscreenTransitionData
"
"
should
be
deconstructed
in
the
main
thread
"
)
;
:
:
PostMessageW
(
mWnd
WM_DESTROY
0
0
)
;
}
}
;
NS_IMPL_ISUPPORTS0
(
FullscreenTransitionData
)
bool
nsWindow
:
:
PrepareForFullscreenTransition
(
nsISupports
*
*
aData
)
{
if
(
!
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
{
return
false
;
}
FullscreenTransitionInitData
initData
;
nsCOMPtr
<
nsIScreen
>
screen
=
GetWidgetScreen
(
)
;
int32_t
x
y
width
height
;
screen
-
>
GetRectDisplayPix
(
&
x
&
y
&
width
&
height
)
;
MOZ_ASSERT
(
BoundsUseDesktopPixels
(
)
"
Should
only
be
called
on
top
-
level
window
"
)
;
double
scale
=
GetDesktopToDeviceScale
(
)
.
scale
;
initData
.
mBounds
.
SetRect
(
NSToIntRound
(
x
*
scale
)
NSToIntRound
(
y
*
scale
)
NSToIntRound
(
width
*
scale
)
NSToIntRound
(
height
*
scale
)
)
;
initData
.
mSemaphore
=
:
:
CreateSemaphore
(
nullptr
0
1
nullptr
)
;
if
(
initData
.
mSemaphore
)
{
initData
.
mThread
=
:
:
CreateThread
(
nullptr
0
FullscreenTransitionThreadProc
&
initData
0
nullptr
)
;
if
(
initData
.
mThread
)
{
:
:
WaitForSingleObject
(
initData
.
mSemaphore
INFINITE
)
;
}
}
if
(
!
initData
.
mWnd
)
{
return
false
;
}
mTransitionWnd
=
initData
.
mWnd
;
auto
data
=
new
FullscreenTransitionData
(
initData
.
mWnd
)
;
*
aData
=
data
;
NS_ADDREF
(
data
)
;
return
true
;
}
void
nsWindow
:
:
PerformFullscreenTransition
(
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsISupports
*
aData
nsIRunnable
*
aCallback
)
{
auto
data
=
static_cast
<
FullscreenTransitionData
*
>
(
aData
)
;
nsCOMPtr
<
nsIRunnable
>
callback
=
aCallback
;
UINT
msg
=
aStage
=
=
eBeforeFullscreenToggle
?
WM_FULLSCREEN_TRANSITION_BEFORE
:
WM_FULLSCREEN_TRANSITION_AFTER
;
WPARAM
wparam
=
(
WPARAM
)
callback
.
forget
(
)
.
take
(
)
;
:
:
PostMessage
(
data
-
>
mWnd
msg
wparam
(
LPARAM
)
aDuration
)
;
}
void
nsWindow
:
:
CleanupFullscreenTransition
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
CleanupFullscreenTransition
"
"
should
only
run
on
the
main
thread
"
)
;
mTransitionWnd
=
nullptr
;
}
void
nsWindow
:
:
OnFullscreenWillChange
(
bool
aFullScreen
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
FullscreenWillChange
(
aFullScreen
)
;
}
}
void
nsWindow
:
:
OnFullscreenChanged
(
bool
aFullScreen
)
{
UpdateNonClientMargins
(
mFrameState
-
>
GetSizeMode
(
)
!
aFullScreen
)
;
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
aFullScreen
)
;
if
(
mIsVisible
&
&
!
aFullScreen
&
&
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Normal
)
{
DispatchFocusToTopLevelWindow
(
true
)
;
}
OnSizeModeChange
(
mFrameState
-
>
GetSizeMode
(
)
)
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
FullscreenChanged
(
aFullScreen
)
;
}
TaskbarConcealer
:
:
OnFullscreenChanged
(
this
aFullScreen
)
;
}
nsresult
nsWindow
:
:
MakeFullScreen
(
bool
aFullScreen
)
{
mFrameState
-
>
EnsureFullscreenMode
(
aFullScreen
)
;
return
NS_OK
;
}
void
*
nsWindow
:
:
GetNativeData
(
uint32_t
aDataType
)
{
switch
(
aDataType
)
{
case
NS_NATIVE_TMP_WINDOW
:
return
(
void
*
)
:
:
CreateWindowExW
(
mIsRTL
?
WS_EX_LAYOUTRTL
:
0
ChooseWindowClass
(
mWindowType
false
)
L
"
"
WS_CHILD
CW_USEDEFAULT
CW_USEDEFAULT
CW_USEDEFAULT
CW_USEDEFAULT
mWnd
nullptr
nsToolkit
:
:
mDllInstance
nullptr
)
;
case
NS_NATIVE_WIDGET
:
case
NS_NATIVE_WINDOW
:
case
NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID
:
return
(
void
*
)
mWnd
;
case
NS_NATIVE_GRAPHIC
:
MOZ_ASSERT_UNREACHABLE
(
"
Not
supported
on
Windows
:
"
)
;
return
nullptr
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
{
void
*
pseudoIMEContext
=
GetPseudoIMEContext
(
)
;
if
(
pseudoIMEContext
)
{
return
pseudoIMEContext
;
}
[
[
fallthrough
]
]
;
}
case
NS_NATIVE_TSF_THREAD_MGR
:
case
NS_NATIVE_TSF_CATEGORY_MGR
:
case
NS_NATIVE_TSF_DISPLAY_ATTR_MGR
:
return
IMEHandler
:
:
GetNativeData
(
this
aDataType
)
;
default
:
break
;
}
return
nullptr
;
}
void
nsWindow
:
:
SetNativeData
(
uint32_t
aDataType
uintptr_t
aVal
)
{
NS_ERROR
(
"
SetNativeData
called
with
unsupported
data
type
.
"
)
;
}
void
nsWindow
:
:
FreeNativeData
(
void
*
data
uint32_t
aDataType
)
{
switch
(
aDataType
)
{
case
NS_NATIVE_GRAPHIC
:
case
NS_NATIVE_WIDGET
:
case
NS_NATIVE_WINDOW
:
break
;
default
:
break
;
}
}
nsresult
nsWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
const
nsString
&
strTitle
=
PromiseFlatString
(
aTitle
)
;
AutoRestore
<
bool
>
sendingText
(
mSendingSetText
)
;
mSendingSetText
=
true
;
:
:
SendMessageW
(
mWnd
WM_SETTEXT
(
WPARAM
)
0
(
LPARAM
)
(
LPCWSTR
)
strTitle
.
get
(
)
)
;
return
NS_OK
;
}
void
nsWindow
:
:
SetBigIcon
(
HICON
aIcon
)
{
HICON
icon
=
(
HICON
)
:
:
SendMessageW
(
mWnd
WM_SETICON
(
WPARAM
)
ICON_BIG
(
LPARAM
)
aIcon
)
;
if
(
icon
)
{
:
:
DestroyIcon
(
icon
)
;
}
mIconBig
=
aIcon
;
}
void
nsWindow
:
:
SetSmallIcon
(
HICON
aIcon
)
{
HICON
icon
=
(
HICON
)
:
:
SendMessageW
(
mWnd
WM_SETICON
(
WPARAM
)
ICON_SMALL
(
LPARAM
)
aIcon
)
;
if
(
icon
)
{
:
:
DestroyIcon
(
icon
)
;
}
mIconSmall
=
aIcon
;
}
void
nsWindow
:
:
SetIcon
(
const
nsAString
&
aIconSpec
)
{
nsCOMPtr
<
nsIFile
>
iconFile
;
ResolveIconName
(
aIconSpec
u
"
.
ico
"
_ns
getter_AddRefs
(
iconFile
)
)
;
if
(
!
iconFile
)
return
;
nsAutoString
iconPath
;
iconFile
-
>
GetPath
(
iconPath
)
;
:
:
SetLastError
(
0
)
;
HICON
bigIcon
=
(
HICON
)
:
:
LoadImageW
(
nullptr
(
LPCWSTR
)
iconPath
.
get
(
)
IMAGE_ICON
:
:
GetSystemMetrics
(
SM_CXICON
)
:
:
GetSystemMetrics
(
SM_CYICON
)
LR_LOADFROMFILE
)
;
HICON
smallIcon
=
(
HICON
)
:
:
LoadImageW
(
nullptr
(
LPCWSTR
)
iconPath
.
get
(
)
IMAGE_ICON
:
:
GetSystemMetrics
(
SM_CXSMICON
)
:
:
GetSystemMetrics
(
SM_CYSMICON
)
LR_LOADFROMFILE
)
;
if
(
bigIcon
)
{
SetBigIcon
(
bigIcon
)
;
}
#
ifdef
DEBUG_SetIcon
else
{
NS_LossyConvertUTF16toASCII
cPath
(
iconPath
)
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
\
nIcon
load
error
;
icon
=
%
s
rc
=
0x
%
08X
\
n
\
n
"
cPath
.
get
(
)
:
:
GetLastError
(
)
)
)
;
}
#
endif
if
(
smallIcon
)
{
SetSmallIcon
(
smallIcon
)
;
}
#
ifdef
DEBUG_SetIcon
else
{
NS_LossyConvertUTF16toASCII
cPath
(
iconPath
)
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
\
nSmall
icon
load
error
;
icon
=
%
s
rc
=
0x
%
08X
\
n
\
n
"
cPath
.
get
(
)
:
:
GetLastError
(
)
)
)
;
}
#
endif
}
void
nsWindow
:
:
SetBigIconNoData
(
)
{
HICON
bigIcon
=
:
:
LoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
gStockApplicationIcon
)
;
SetBigIcon
(
bigIcon
)
;
}
void
nsWindow
:
:
SetSmallIconNoData
(
)
{
HICON
smallIcon
=
:
:
LoadIconW
(
:
:
GetModuleHandleW
(
nullptr
)
gStockApplicationIcon
)
;
SetSmallIcon
(
smallIcon
)
;
}
LayoutDeviceIntPoint
nsWindow
:
:
WidgetToScreenOffset
(
)
{
POINT
point
;
point
.
x
=
0
;
point
.
y
=
0
;
:
:
ClientToScreen
(
mWnd
&
point
)
;
return
LayoutDeviceIntPoint
(
point
.
x
point
.
y
)
;
}
LayoutDeviceIntSize
nsWindow
:
:
ClientToWindowSize
(
const
LayoutDeviceIntSize
&
aClientSize
)
{
if
(
mWindowType
=
=
eWindowType_popup
&
&
!
IsPopupWithTitleBar
(
)
)
return
aClientSize
;
RECT
r
;
r
.
left
=
200
;
r
.
top
=
200
;
r
.
right
=
200
+
aClientSize
.
width
;
r
.
bottom
=
200
+
aClientSize
.
height
;
:
:
AdjustWindowRectEx
(
&
r
WindowStyle
(
)
false
WindowExStyle
(
)
)
;
return
LayoutDeviceIntSize
(
r
.
right
-
r
.
left
r
.
bottom
-
r
.
top
)
;
}
void
nsWindow
:
:
EnableDragDrop
(
bool
aEnable
)
{
if
(
!
mWnd
)
{
return
;
}
if
(
aEnable
)
{
if
(
!
mNativeDragTarget
)
{
mNativeDragTarget
=
new
nsNativeDragTarget
(
this
)
;
mNativeDragTarget
-
>
AddRef
(
)
;
if
(
SUCCEEDED
(
:
:
CoLockObjectExternal
(
(
LPUNKNOWN
)
mNativeDragTarget
TRUE
FALSE
)
)
)
{
:
:
RegisterDragDrop
(
mWnd
(
LPDROPTARGET
)
mNativeDragTarget
)
;
}
}
}
else
{
if
(
mWnd
&
&
mNativeDragTarget
)
{
:
:
RevokeDragDrop
(
mWnd
)
;
:
:
CoLockObjectExternal
(
(
LPUNKNOWN
)
mNativeDragTarget
FALSE
TRUE
)
;
mNativeDragTarget
-
>
DragCancel
(
)
;
NS_RELEASE
(
mNativeDragTarget
)
;
}
}
}
void
nsWindow
:
:
CaptureMouse
(
bool
aCapture
)
{
TRACKMOUSEEVENT
mTrack
;
mTrack
.
cbSize
=
sizeof
(
TRACKMOUSEEVENT
)
;
mTrack
.
dwHoverTime
=
0
;
mTrack
.
hwndTrack
=
mWnd
;
if
(
aCapture
)
{
mTrack
.
dwFlags
=
TME_CANCEL
|
TME_LEAVE
;
:
:
SetCapture
(
mWnd
)
;
}
else
{
mTrack
.
dwFlags
=
TME_LEAVE
;
:
:
ReleaseCapture
(
)
;
}
sIsInMouseCapture
=
aCapture
;
TrackMouseEvent
(
&
mTrack
)
;
}
void
nsWindow
:
:
CaptureRollupEvents
(
nsIRollupListener
*
aListener
bool
aDoCapture
)
{
if
(
aDoCapture
)
{
gRollupListener
=
aListener
;
if
(
!
sMsgFilterHook
&
&
!
sCallProcHook
&
&
!
sCallMouseHook
)
{
RegisterSpecialDropdownHooks
(
)
;
}
sProcessHook
=
true
;
}
else
{
gRollupListener
=
nullptr
;
sProcessHook
=
false
;
UnregisterSpecialDropdownHooks
(
)
;
}
}
nsresult
nsWindow
:
:
GetAttention
(
int32_t
aCycleCount
)
{
if
(
!
mWnd
)
return
NS_ERROR_NOT_INITIALIZED
;
HWND
flashWnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
false
false
)
;
HWND
fgWnd
=
:
:
GetForegroundWindow
(
)
;
if
(
aCycleCount
=
=
0
|
|
flashWnd
=
=
fgWnd
|
|
flashWnd
=
=
WinUtils
:
:
GetTopLevelHWND
(
fgWnd
false
false
)
)
{
return
NS_OK
;
}
DWORD
defaultCycleCount
=
0
;
:
:
SystemParametersInfo
(
SPI_GETFOREGROUNDFLASHCOUNT
0
&
defaultCycleCount
0
)
;
FLASHWINFO
flashInfo
=
{
sizeof
(
FLASHWINFO
)
flashWnd
FLASHW_ALL
aCycleCount
>
0
?
aCycleCount
:
defaultCycleCount
0
}
;
:
:
FlashWindowEx
(
&
flashInfo
)
;
return
NS_OK
;
}
void
nsWindow
:
:
StopFlashing
(
)
{
HWND
flashWnd
=
mWnd
;
while
(
HWND
ownerWnd
=
:
:
GetWindow
(
flashWnd
GW_OWNER
)
)
{
flashWnd
=
ownerWnd
;
}
FLASHWINFO
flashInfo
=
{
sizeof
(
FLASHWINFO
)
flashWnd
FLASHW_STOP
0
0
}
;
:
:
FlashWindowEx
(
&
flashInfo
)
;
}
bool
nsWindow
:
:
HasPendingInputEvent
(
)
{
if
(
HIWORD
(
GetQueueStatus
(
QS_INPUT
)
)
)
return
true
;
GUITHREADINFO
guiInfo
;
guiInfo
.
cbSize
=
sizeof
(
GUITHREADINFO
)
;
if
(
!
GetGUIThreadInfo
(
GetCurrentThreadId
(
)
&
guiInfo
)
)
return
false
;
return
GUI_INMOVESIZE
=
=
(
guiInfo
.
flags
&
GUI_INMOVESIZE
)
;
}
WindowRenderer
*
nsWindow
:
:
GetWindowRenderer
(
)
{
if
(
mWindowRenderer
)
{
return
mWindowRenderer
;
}
if
(
!
mLocalesChangedObserver
)
{
mLocalesChangedObserver
=
new
LocalesChangedObserver
(
this
)
;
}
if
(
!
mWindowRenderer
&
&
ShouldUseOffMainThreadCompositing
(
)
)
{
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
UpdateRenderMode
(
)
;
CreateCompositor
(
)
;
}
if
(
!
mWindowRenderer
)
{
MOZ_ASSERT
(
!
mCompositorSession
&
&
!
mCompositorBridgeChild
)
;
MOZ_ASSERT
(
!
mCompositorWidgetDelegate
)
;
WinCompositorWidgetInitData
initData
(
reinterpret_cast
<
uintptr_t
>
(
mWnd
)
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
nsIWidget
*
>
(
this
)
)
mTransparencyMode
mFrameState
-
>
GetSizeMode
(
)
)
;
CompositorOptions
options
(
false
false
)
;
mBasicLayersSurface
=
new
InProcessWinCompositorWidget
(
initData
options
this
)
;
mCompositorWidgetDelegate
=
mBasicLayersSurface
;
mWindowRenderer
=
CreateFallbackRenderer
(
)
;
}
NS_ASSERTION
(
mWindowRenderer
"
Couldn
'
t
provide
a
valid
window
renderer
.
"
)
;
if
(
mWindowRenderer
)
{
KnowsCompositor
*
knowsCompositor
=
mWindowRenderer
-
>
AsKnowsCompositor
(
)
;
if
(
knowsCompositor
)
{
SizeConstraints
c
=
mSizeConstraints
;
mMaxTextureSize
=
knowsCompositor
-
>
GetMaxTextureSize
(
)
;
c
.
mMaxSize
.
width
=
std
:
:
min
(
c
.
mMaxSize
.
width
mMaxTextureSize
)
;
c
.
mMaxSize
.
height
=
std
:
:
min
(
c
.
mMaxSize
.
height
mMaxTextureSize
)
;
nsBaseWidget
:
:
SetSizeConstraints
(
c
)
;
}
}
return
mWindowRenderer
;
}
void
nsWindow
:
:
SetCompositorWidgetDelegate
(
CompositorWidgetDelegate
*
delegate
)
{
if
(
delegate
)
{
mCompositorWidgetDelegate
=
delegate
-
>
AsPlatformSpecificDelegate
(
)
;
MOZ_ASSERT
(
mCompositorWidgetDelegate
"
nsWindow
:
:
SetCompositorWidgetDelegate
called
with
a
"
"
non
-
PlatformCompositorWidgetDelegate
"
)
;
}
else
{
mCompositorWidgetDelegate
=
nullptr
;
}
}
nsresult
nsWindow
:
:
OnDefaultButtonLoaded
(
const
LayoutDeviceIntRect
&
aButtonRect
)
{
if
(
aButtonRect
.
IsEmpty
(
)
)
return
NS_OK
;
HWND
activeWnd
=
:
:
GetActiveWindow
(
)
;
if
(
activeWnd
!
=
:
:
GetForegroundWindow
(
)
|
|
WinUtils
:
:
GetTopLevelHWND
(
mWnd
true
)
!
=
WinUtils
:
:
GetTopLevelHWND
(
activeWnd
true
)
)
{
return
NS_OK
;
}
bool
isAlwaysSnapCursor
=
Preferences
:
:
GetBool
(
"
ui
.
cursor_snapping
.
always_enabled
"
false
)
;
if
(
!
isAlwaysSnapCursor
)
{
BOOL
snapDefaultButton
;
if
(
!
:
:
SystemParametersInfo
(
SPI_GETSNAPTODEFBUTTON
0
&
snapDefaultButton
0
)
|
|
!
snapDefaultButton
)
return
NS_OK
;
}
LayoutDeviceIntRect
widgetRect
=
GetScreenBounds
(
)
;
LayoutDeviceIntRect
buttonRect
(
aButtonRect
+
widgetRect
.
TopLeft
(
)
)
;
LayoutDeviceIntPoint
centerOfButton
(
buttonRect
.
X
(
)
+
buttonRect
.
Width
(
)
/
2
buttonRect
.
Y
(
)
+
buttonRect
.
Height
(
)
/
2
)
;
if
(
!
widgetRect
.
Contains
(
centerOfButton
)
)
{
return
NS_OK
;
}
if
(
!
:
:
SetCursorPos
(
centerOfButton
.
x
centerOfButton
.
y
)
)
{
NS_ERROR
(
"
SetCursorPos
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
nsWindow
:
:
UpdateThemeGeometries
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
RefPtr
<
WebRenderLayerManager
>
layerManager
=
GetWindowRenderer
(
)
?
GetWindowRenderer
(
)
-
>
AsWebRender
(
)
:
nullptr
;
if
(
!
layerManager
)
{
return
;
}
if
(
!
HasGlass
(
)
|
|
!
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
{
return
;
}
mWindowButtonsRect
=
Nothing
(
)
;
if
(
!
IsWin10OrLater
(
)
)
{
for
(
size_t
i
=
0
;
i
<
aThemeGeometries
.
Length
(
)
;
i
+
+
)
{
if
(
aThemeGeometries
[
i
]
.
mType
=
=
nsNativeThemeWin
:
:
eThemeGeometryTypeWindowButtons
)
{
LayoutDeviceIntRect
bounds
=
aThemeGeometries
[
i
]
.
mRect
;
bounds
.
SetWidth
(
bounds
.
Width
(
)
+
1
)
;
if
(
!
mWindowButtonsRect
)
{
mWindowButtonsRect
=
Some
(
bounds
)
;
}
}
}
}
}
void
nsWindow
:
:
AddWindowOverlayWebRenderCommands
(
layers
:
:
WebRenderBridgeChild
*
aWrBridge
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
{
if
(
mWindowButtonsRect
)
{
wr
:
:
LayoutRect
rect
=
wr
:
:
ToLayoutRect
(
*
mWindowButtonsRect
)
;
aBuilder
.
PushClearRect
(
rect
)
;
}
}
uint32_t
nsWindow
:
:
GetMaxTouchPoints
(
)
const
{
return
WinUtils
:
:
GetMaxTouchPoints
(
)
;
}
void
nsWindow
:
:
SetWindowClass
(
const
nsAString
&
xulWinType
)
{
mIsEarlyBlankWindow
=
xulWinType
.
EqualsLiteral
(
"
navigator
:
blank
"
)
;
}
void
nsWindow
:
:
InitEvent
(
WidgetGUIEvent
&
event
LayoutDeviceIntPoint
*
aPoint
)
{
if
(
nullptr
=
=
aPoint
)
{
if
(
mWnd
!
=
nullptr
)
{
DWORD
pos
=
:
:
GetMessagePos
(
)
;
POINT
cpos
;
cpos
.
x
=
GET_X_LPARAM
(
pos
)
;
cpos
.
y
=
GET_Y_LPARAM
(
pos
)
;
:
:
ScreenToClient
(
mWnd
&
cpos
)
;
event
.
mRefPoint
=
LayoutDeviceIntPoint
(
cpos
.
x
cpos
.
y
)
;
}
else
{
event
.
mRefPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
}
}
else
{
event
.
mRefPoint
=
*
aPoint
;
}
event
.
AssignEventTime
(
CurrentMessageWidgetEventTime
(
)
)
;
}
WidgetEventTime
nsWindow
:
:
CurrentMessageWidgetEventTime
(
)
const
{
LONG
messageTime
=
:
:
GetMessageTime
(
)
;
return
WidgetEventTime
(
messageTime
GetMessageTimeStamp
(
messageTime
)
)
;
}
nsresult
nsWindow
:
:
DispatchEvent
(
WidgetGUIEvent
*
event
nsEventStatus
&
aStatus
)
{
#
ifdef
WIDGET_DEBUG_OUTPUT
debug_DumpEvent
(
stdout
event
-
>
mWidget
event
"
something
"
(
int32_t
)
mWnd
)
;
#
endif
aStatus
=
nsEventStatus_eIgnore
;
if
(
mAttachedWidgetListener
)
{
aStatus
=
mAttachedWidgetListener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
}
else
if
(
mWidgetListener
)
{
aStatus
=
mWidgetListener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
}
if
(
mOnDestroyCalled
)
aStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
bool
nsWindow
:
:
DispatchStandardEvent
(
EventMessage
aMsg
)
{
WidgetGUIEvent
event
(
true
aMsg
this
)
;
InitEvent
(
event
)
;
bool
result
=
DispatchWindowEvent
(
event
)
;
return
result
;
}
bool
nsWindow
:
:
DispatchKeyboardEvent
(
WidgetKeyboardEvent
*
event
)
{
nsEventStatus
status
=
DispatchInputEvent
(
event
)
.
mContentStatus
;
return
ConvertStatus
(
status
)
;
}
bool
nsWindow
:
:
DispatchContentCommandEvent
(
WidgetContentCommandEvent
*
aEvent
)
{
nsEventStatus
status
;
DispatchEvent
(
aEvent
status
)
;
return
ConvertStatus
(
status
)
;
}
bool
nsWindow
:
:
DispatchWheelEvent
(
WidgetWheelEvent
*
aEvent
)
{
nsEventStatus
status
=
DispatchInputEvent
(
aEvent
-
>
AsInputEvent
(
)
)
.
mContentStatus
;
return
ConvertStatus
(
status
)
;
}
BOOL
CALLBACK
nsWindow
:
:
DispatchStarvedPaints
(
HWND
aWnd
LPARAM
aMsg
)
{
LONG_PTR
proc
=
:
:
GetWindowLongPtrW
(
aWnd
GWLP_WNDPROC
)
;
if
(
proc
=
=
(
LONG_PTR
)
&
nsWindow
:
:
WindowProc
)
{
if
(
GetUpdateRect
(
aWnd
nullptr
FALSE
)
)
VERIFY
(
:
:
UpdateWindow
(
aWnd
)
)
;
}
return
TRUE
;
}
void
nsWindow
:
:
DispatchPendingEvents
(
)
{
if
(
mPainting
)
{
NS_WARNING
(
"
We
were
asked
to
dispatch
pending
events
during
painting
"
"
denying
since
that
'
s
unsafe
.
"
)
;
return
;
}
static
int
recursionBlocker
=
0
;
if
(
recursionBlocker
+
+
=
=
0
)
{
NS_ProcessPendingEvents
(
nullptr
PR_MillisecondsToInterval
(
100
)
)
;
-
-
recursionBlocker
;
}
if
(
:
:
GetQueueStatus
(
QS_PAINT
)
&
&
(
(
TimeStamp
:
:
Now
(
)
-
mLastPaintEndTime
)
.
ToMilliseconds
(
)
>
=
50
)
)
{
HWND
topWnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
)
;
nsWindow
:
:
DispatchStarvedPaints
(
topWnd
0
)
;
:
:
EnumChildWindows
(
topWnd
nsWindow
:
:
DispatchStarvedPaints
0
)
;
}
}
void
nsWindow
:
:
DispatchCustomEvent
(
const
nsString
&
eventName
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
if
(
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
)
{
win
-
>
DispatchCustomEvent
(
eventName
ChromeOnlyDispatch
:
:
eYes
)
;
}
}
}
bool
nsWindow
:
:
TouchEventShouldStartDrag
(
EventMessage
aEventMessage
LayoutDeviceIntPoint
aEventPoint
)
{
if
(
aEventMessage
=
=
eMouseDoubleClick
)
{
return
true
;
}
if
(
aEventMessage
=
=
eMouseDown
)
{
WidgetMouseEvent
hittest
(
true
eMouseHitTest
this
WidgetMouseEvent
:
:
eReal
)
;
hittest
.
mRefPoint
=
aEventPoint
;
hittest
.
mIgnoreRootScrollFrame
=
true
;
hittest
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
DispatchInputEvent
(
&
hittest
)
;
if
(
EventTarget
*
target
=
hittest
.
GetDOMEventTarget
(
)
)
{
if
(
nsIContent
*
content
=
nsIContent
:
:
FromEventTarget
(
target
)
)
{
for
(
Element
*
element
=
content
-
>
GetAsElementOrParentElement
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
nsAutoString
startDrag
;
element
-
>
GetAttribute
(
u
"
touchdownstartsdrag
"
_ns
startDrag
)
;
if
(
!
startDrag
.
IsEmpty
(
)
)
{
return
true
;
}
}
}
}
}
return
false
;
}
bool
nsWindow
:
:
DispatchMouseEvent
(
EventMessage
aEventMessage
WPARAM
wParam
LPARAM
lParam
bool
aIsContextMenuKey
int16_t
aButton
uint16_t
aInputSource
WinPointerInfo
*
aPointerInfo
bool
aIgnoreAPZ
)
{
ContextMenuPreventer
contextMenuPreventer
(
this
)
;
bool
result
=
false
;
UserActivity
(
)
;
if
(
!
mWidgetListener
)
{
return
result
;
}
LayoutDeviceIntPoint
eventPoint
(
GET_X_LPARAM
(
lParam
)
GET_Y_LPARAM
(
lParam
)
)
;
LayoutDeviceIntPoint
mpScreen
=
eventPoint
+
WidgetToScreenOffset
(
)
;
if
(
aEventMessage
=
=
eMouseMove
)
{
if
(
(
sLastMouseMovePoint
.
x
=
=
mpScreen
.
x
)
&
&
(
sLastMouseMovePoint
.
y
=
=
mpScreen
.
y
)
)
{
return
result
;
}
sLastMouseMovePoint
.
x
=
mpScreen
.
x
;
sLastMouseMovePoint
.
y
=
mpScreen
.
y
;
}
if
(
!
aIgnoreAPZ
&
&
WinUtils
:
:
GetIsMouseFromTouch
(
aEventMessage
)
)
{
if
(
mTouchWindow
)
{
MOZ_ASSERT
(
mAPZC
)
;
if
(
TouchEventShouldStartDrag
(
aEventMessage
eventPoint
)
)
{
aEventMessage
=
eMouseTouchDrag
;
}
else
{
return
result
;
}
}
}
uint32_t
pointerId
=
aPointerInfo
?
aPointerInfo
-
>
pointerId
:
MOUSE_POINTERID
(
)
;
if
(
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
=
=
aInputSource
&
&
nsWindowType
:
:
eWindowType_toplevel
=
=
mWindowType
&
&
InkCollector
:
:
sInkCollector
)
{
InkCollector
:
:
sInkCollector
-
>
SetTarget
(
mWnd
)
;
InkCollector
:
:
sInkCollector
-
>
SetPointerId
(
pointerId
)
;
}
switch
(
aEventMessage
)
{
case
eMouseDown
:
CaptureMouse
(
true
)
;
break
;
case
eMouseUp
:
case
eMouseMove
:
case
eMouseExitFromWidget
:
if
(
!
(
wParam
&
(
MK_LBUTTON
|
MK_MBUTTON
|
MK_RBUTTON
)
)
&
&
sIsInMouseCapture
)
CaptureMouse
(
false
)
;
break
;
default
:
break
;
}
WidgetMouseEvent
event
(
true
aEventMessage
this
WidgetMouseEvent
:
:
eReal
aIsContextMenuKey
?
WidgetMouseEvent
:
:
eContextMenuKey
:
WidgetMouseEvent
:
:
eNormal
)
;
if
(
aEventMessage
=
=
eContextMenu
&
&
aIsContextMenuKey
)
{
LayoutDeviceIntPoint
zero
(
0
0
)
;
InitEvent
(
event
&
zero
)
;
}
else
{
InitEvent
(
event
&
eventPoint
)
;
}
ModifierKeyState
modifierKeyState
;
modifierKeyState
.
InitInputEvent
(
event
)
;
if
(
aEventMessage
=
=
eContextMenu
&
&
aIsContextMenuKey
&
&
event
.
IsShift
(
)
&
&
NativeKey
:
:
LastKeyOrCharMSG
(
)
.
message
=
=
WM_SYSKEYDOWN
&
&
NativeKey
:
:
LastKeyOrCharMSG
(
)
.
wParam
=
=
VK_F10
)
{
event
.
mModifiers
&
=
~
MODIFIER_SHIFT
;
}
event
.
mButton
=
aButton
;
event
.
mInputSource
=
aInputSource
;
if
(
aPointerInfo
)
{
event
.
AssignPointerHelperData
(
*
aPointerInfo
)
;
event
.
mPressure
=
aPointerInfo
-
>
mPressure
;
event
.
mButtons
=
aPointerInfo
-
>
mButtons
;
}
else
{
event
.
convertToPointer
=
true
;
event
.
pointerId
=
pointerId
;
}
static
POINT
sLastMousePoint
=
{
0
}
;
static
LONG
sLastMouseDownTime
=
0L
;
static
LONG
sLastClickCount
=
0L
;
static
BYTE
sLastMouseButton
=
0
;
bool
insideMovementThreshold
=
(
DeprecatedAbs
(
sLastMousePoint
.
x
-
eventPoint
.
x
)
<
(
short
)
:
:
GetSystemMetrics
(
SM_CXDOUBLECLK
)
)
&
&
(
DeprecatedAbs
(
sLastMousePoint
.
y
-
eventPoint
.
y
)
<
(
short
)
:
:
GetSystemMetrics
(
SM_CYDOUBLECLK
)
)
;
BYTE
eventButton
;
switch
(
aButton
)
{
case
MouseButton
:
:
ePrimary
:
eventButton
=
VK_LBUTTON
;
break
;
case
MouseButton
:
:
eMiddle
:
eventButton
=
VK_MBUTTON
;
break
;
case
MouseButton
:
:
eSecondary
:
eventButton
=
VK_RBUTTON
;
break
;
default
:
eventButton
=
0
;
break
;
}
LONG
curMsgTime
=
:
:
GetMessageTime
(
)
;
switch
(
aEventMessage
)
{
case
eMouseDoubleClick
:
event
.
mMessage
=
eMouseDown
;
event
.
mButton
=
aButton
;
sLastClickCount
=
2
;
sLastMouseDownTime
=
curMsgTime
;
break
;
case
eMouseUp
:
sLastMousePoint
.
x
=
eventPoint
.
x
;
sLastMousePoint
.
y
=
eventPoint
.
y
;
sLastMouseButton
=
eventButton
;
break
;
case
eMouseDown
:
if
(
(
(
curMsgTime
-
sLastMouseDownTime
)
<
(
LONG
)
:
:
GetDoubleClickTime
(
)
)
&
&
insideMovementThreshold
&
&
eventButton
=
=
sLastMouseButton
)
{
sLastClickCount
+
+
;
}
else
{
sLastClickCount
=
1
;
}
sLastMouseDownTime
=
curMsgTime
;
break
;
case
eMouseMove
:
if
(
!
insideMovementThreshold
)
{
sLastClickCount
=
0
;
}
break
;
case
eMouseExitFromWidget
:
event
.
mExitFrom
=
Some
(
IsTopLevelMouseExit
(
mWnd
)
?
WidgetMouseEvent
:
:
ePlatformTopLevel
:
WidgetMouseEvent
:
:
ePlatformChild
)
;
break
;
default
:
break
;
}
event
.
mClickCount
=
sLastClickCount
;
#
ifdef
NS_DEBUG_XX
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
Msg
Time
:
%
d
Click
Count
:
%
d
\
n
"
curMsgTime
event
.
mClickCount
)
)
;
#
endif
if
(
mWidgetListener
)
{
if
(
aEventMessage
=
=
eMouseMove
)
{
LayoutDeviceIntRect
rect
=
GetBounds
(
)
;
rect
.
MoveTo
(
0
0
)
;
if
(
rect
.
Contains
(
event
.
mRefPoint
)
)
{
if
(
sCurrentWindow
=
=
nullptr
|
|
sCurrentWindow
!
=
this
)
{
if
(
(
nullptr
!
=
sCurrentWindow
)
&
&
(
!
sCurrentWindow
-
>
mInDtor
)
)
{
LPARAM
pos
=
sCurrentWindow
-
>
lParamToClient
(
lParamToScreen
(
lParam
)
)
;
sCurrentWindow
-
>
DispatchMouseEvent
(
eMouseExitFromWidget
wParam
pos
false
MouseButton
:
:
ePrimary
aInputSource
aPointerInfo
)
;
}
sCurrentWindow
=
this
;
if
(
!
mInDtor
)
{
LPARAM
pos
=
sCurrentWindow
-
>
lParamToClient
(
lParamToScreen
(
lParam
)
)
;
sCurrentWindow
-
>
DispatchMouseEvent
(
eMouseEnterIntoWidget
wParam
pos
false
MouseButton
:
:
ePrimary
aInputSource
aPointerInfo
)
;
}
}
}
}
else
if
(
aEventMessage
=
=
eMouseExitFromWidget
)
{
if
(
sCurrentWindow
=
=
this
)
{
sCurrentWindow
=
nullptr
;
}
}
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
DispatchInputEvent
(
&
event
)
;
contextMenuPreventer
.
Update
(
event
eventStatus
)
;
return
ConvertStatus
(
eventStatus
.
mContentStatus
)
;
}
return
result
;
}
HWND
nsWindow
:
:
GetTopLevelForFocus
(
HWND
aCurWnd
)
{
HWND
toplevelWnd
=
nullptr
;
while
(
aCurWnd
)
{
toplevelWnd
=
aCurWnd
;
nsWindow
*
win
=
WinUtils
:
:
GetNSWindowPtr
(
aCurWnd
)
;
if
(
win
)
{
if
(
win
-
>
mWindowType
=
=
eWindowType_toplevel
|
|
win
-
>
mWindowType
=
=
eWindowType_dialog
)
{
break
;
}
}
aCurWnd
=
:
:
GetParent
(
aCurWnd
)
;
}
return
toplevelWnd
;
}
void
nsWindow
:
:
DispatchFocusToTopLevelWindow
(
bool
aIsActivate
)
{
if
(
aIsActivate
)
{
sJustGotActivate
=
false
;
}
sJustGotDeactivate
=
false
;
mLastKillFocusWindow
=
nullptr
;
HWND
toplevelWnd
=
GetTopLevelForFocus
(
mWnd
)
;
if
(
toplevelWnd
)
{
nsWindow
*
win
=
WinUtils
:
:
GetNSWindowPtr
(
toplevelWnd
)
;
if
(
win
&
&
win
-
>
mWidgetListener
)
{
if
(
aIsActivate
)
{
win
-
>
mWidgetListener
-
>
WindowActivated
(
)
;
}
else
{
win
-
>
mWidgetListener
-
>
WindowDeactivated
(
)
;
}
}
}
}
HWND
nsWindow
:
:
WindowAtMouse
(
)
{
DWORD
pos
=
:
:
GetMessagePos
(
)
;
POINT
mp
;
mp
.
x
=
GET_X_LPARAM
(
pos
)
;
mp
.
y
=
GET_Y_LPARAM
(
pos
)
;
return
:
:
WindowFromPoint
(
mp
)
;
}
bool
nsWindow
:
:
IsTopLevelMouseExit
(
HWND
aWnd
)
{
HWND
mouseWnd
=
WindowAtMouse
(
)
;
HWND
mouseTopLevel
=
WinUtils
:
:
GetTopLevelHWND
(
mouseWnd
)
;
if
(
mouseWnd
=
=
mouseTopLevel
)
return
true
;
return
WinUtils
:
:
GetTopLevelHWND
(
aWnd
)
!
=
mouseTopLevel
;
}
bool
nsWindow
:
:
IsAsyncResponseEvent
(
UINT
aMsg
LRESULT
&
aResult
)
{
switch
(
aMsg
)
{
case
WM_SETFOCUS
:
case
WM_KILLFOCUS
:
case
WM_ENABLE
:
case
WM_WINDOWPOSCHANGING
:
case
WM_WINDOWPOSCHANGED
:
case
WM_PARENTNOTIFY
:
case
WM_ACTIVATEAPP
:
case
WM_NCACTIVATE
:
case
WM_ACTIVATE
:
case
WM_CHILDACTIVATE
:
case
WM_IME_SETCONTEXT
:
case
WM_IME_NOTIFY
:
case
WM_SHOWWINDOW
:
case
WM_CANCELMODE
:
case
WM_MOUSEACTIVATE
:
case
WM_CONTEXTMENU
:
aResult
=
0
;
return
true
;
case
WM_SETTINGCHANGE
:
case
WM_SETCURSOR
:
return
false
;
}
#
ifdef
DEBUG
char
szBuf
[
200
]
;
sprintf
(
szBuf
"
An
unhandled
ISMEX_SEND
message
was
received
during
spin
loop
!
(
%
X
)
"
aMsg
)
;
NS_WARNING
(
szBuf
)
;
#
endif
return
false
;
}
void
nsWindow
:
:
IPCWindowProcHandler
(
UINT
&
msg
WPARAM
&
wParam
LPARAM
&
lParam
)
{
MOZ_ASSERT_IF
(
msg
!
=
WM_GETOBJECT
!
mozilla
:
:
ipc
:
:
MessageChannel
:
:
IsPumpingMessages
(
)
|
|
mozilla
:
:
ipc
:
:
SuppressedNeuteringRegion
:
:
IsNeuteringSuppressed
(
)
)
;
if
(
mozilla
:
:
ipc
:
:
MessageChannel
:
:
IsSpinLoopActive
(
)
&
&
(
InSendMessageEx
(
nullptr
)
&
(
ISMEX_REPLIED
|
ISMEX_SEND
)
)
=
=
ISMEX_SEND
)
{
LRESULT
res
;
if
(
IsAsyncResponseEvent
(
msg
res
)
)
{
ReplyMessage
(
res
)
;
}
return
;
}
DWORD
dwResult
=
0
;
bool
handled
=
false
;
switch
(
msg
)
{
case
WM_ACTIVATE
:
if
(
lParam
!
=
0
&
&
LOWORD
(
wParam
)
=
=
WA_ACTIVE
&
&
IsWindow
(
(
HWND
)
lParam
)
)
{
if
(
(
InSendMessageEx
(
nullptr
)
&
(
ISMEX_REPLIED
|
ISMEX_SEND
)
)
=
=
ISMEX_SEND
)
{
wchar_t
szClass
[
10
]
;
HWND
focusWnd
=
(
HWND
)
lParam
;
if
(
IsWindowVisible
(
focusWnd
)
&
&
GetClassNameW
(
focusWnd
szClass
sizeof
(
szClass
)
/
sizeof
(
char16_t
)
)
&
&
!
wcscmp
(
szClass
L
"
Edit
"
)
&
&
!
WinUtils
:
:
IsOurProcessWindow
(
focusWnd
)
)
{
break
;
}
}
handled
=
true
;
}
break
;
case
WM_SETFOCUS
:
case
WM_KILLFOCUS
:
case
WM_SYSCOMMAND
:
case
WM_CONTEXTMENU
:
case
WM_IME_SETCONTEXT
:
handled
=
true
;
break
;
}
if
(
handled
&
&
(
InSendMessageEx
(
nullptr
)
&
(
ISMEX_REPLIED
|
ISMEX_SEND
)
)
=
=
ISMEX_SEND
)
{
ReplyMessage
(
dwResult
)
;
}
}
static
bool
DisplaySystemMenu
(
HWND
hWnd
nsSizeMode
sizeMode
bool
isRtl
int32_t
x
int32_t
y
)
{
HMENU
hMenu
=
GetSystemMenu
(
hWnd
FALSE
)
;
if
(
hMenu
)
{
MENUITEMINFO
mii
;
mii
.
cbSize
=
sizeof
(
MENUITEMINFO
)
;
mii
.
fMask
=
MIIM_STATE
;
mii
.
fType
=
0
;
mii
.
fState
=
MF_ENABLED
;
SetMenuItemInfo
(
hMenu
SC_RESTORE
FALSE
&
mii
)
;
SetMenuItemInfo
(
hMenu
SC_SIZE
FALSE
&
mii
)
;
SetMenuItemInfo
(
hMenu
SC_MOVE
FALSE
&
mii
)
;
SetMenuItemInfo
(
hMenu
SC_MAXIMIZE
FALSE
&
mii
)
;
SetMenuItemInfo
(
hMenu
SC_MINIMIZE
FALSE
&
mii
)
;
mii
.
fState
=
MF_GRAYED
;
switch
(
sizeMode
)
{
case
nsSizeMode_Fullscreen
:
case
nsSizeMode_Maximized
:
SetMenuItemInfo
(
hMenu
SC_SIZE
FALSE
&
mii
)
;
SetMenuItemInfo
(
hMenu
SC_MOVE
FALSE
&
mii
)
;
SetMenuItemInfo
(
hMenu
SC_MAXIMIZE
FALSE
&
mii
)
;
break
;
case
nsSizeMode_Minimized
:
SetMenuItemInfo
(
hMenu
SC_MINIMIZE
FALSE
&
mii
)
;
break
;
case
nsSizeMode_Normal
:
SetMenuItemInfo
(
hMenu
SC_RESTORE
FALSE
&
mii
)
;
break
;
case
nsSizeMode_Invalid
:
NS_ASSERTION
(
false
"
Did
the
argument
come
from
invalid
IPC
?
"
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhnalded
nsSizeMode
value
detected
"
)
;
break
;
}
LPARAM
cmd
=
TrackPopupMenu
(
hMenu
(
TPM_LEFTBUTTON
|
TPM_RIGHTBUTTON
|
TPM_RETURNCMD
|
TPM_TOPALIGN
|
(
isRtl
?
TPM_RIGHTALIGN
:
TPM_LEFTALIGN
)
)
x
y
0
hWnd
nullptr
)
;
if
(
cmd
)
{
PostMessage
(
hWnd
WM_SYSCOMMAND
cmd
0
)
;
return
true
;
}
}
return
false
;
}
LRESULT
CALLBACK
nsWindow
:
:
WindowProc
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
mozilla
:
:
ipc
:
:
CancelCPOWs
(
)
;
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
return
mozilla
:
:
CallWindowProcCrashProtected
(
WindowProcInternal
hWnd
msg
wParam
lParam
)
;
}
namespace
geckoprofiler
:
:
markers
{
struct
WindowProcMarker
{
static
constexpr
Span
<
const
char
>
MarkerTypeName
(
)
{
return
MakeStringSpan
(
"
WindowProc
"
)
;
}
static
void
StreamJSONMarkerData
(
baseprofiler
:
:
SpliceableJSONWriter
&
aWriter
UINT
aMsg
WPARAM
aWParam
LPARAM
aLParam
)
{
aWriter
.
IntProperty
(
"
uMsg
"
aMsg
)
;
const
char
*
name
;
if
(
aMsg
<
WM_USER
)
{
const
auto
eventMsgInfo
=
mozilla
:
:
widget
:
:
gAllEvents
.
find
(
aMsg
)
;
if
(
eventMsgInfo
!
=
mozilla
:
:
widget
:
:
gAllEvents
.
end
(
)
)
{
name
=
eventMsgInfo
-
>
second
.
mStr
;
}
else
{
name
=
"
ui
message
"
;
}
}
else
if
(
aMsg
>
=
WM_USER
&
&
aMsg
<
WM_APP
)
{
name
=
"
WM_USER
message
"
;
}
else
if
(
aMsg
>
=
WM_APP
&
&
aMsg
<
0xC000
)
{
name
=
"
WM_APP
message
"
;
}
else
if
(
aMsg
>
=
0xC000
&
&
aMsg
<
0x10000
)
{
name
=
"
registered
windows
message
"
;
}
else
{
name
=
"
system
message
"
;
}
aWriter
.
StringProperty
(
"
name
"
MakeStringSpan
(
name
)
)
;
if
(
aWParam
)
{
aWriter
.
IntProperty
(
"
wParam
"
aWParam
)
;
}
if
(
aLParam
)
{
aWriter
.
IntProperty
(
"
lParam
"
aLParam
)
;
}
}
static
MarkerSchema
MarkerTypeDisplay
(
)
{
using
MS
=
MarkerSchema
;
MS
schema
{
MS
:
:
Location
:
:
MarkerChart
MS
:
:
Location
:
:
MarkerTable
}
;
schema
.
AddKeyFormat
(
"
uMsg
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
SetChartLabel
(
"
{
marker
.
data
.
name
}
(
{
marker
.
data
.
uMsg
}
)
"
)
;
schema
.
SetTableLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
name
}
(
{
marker
.
data
.
uMsg
}
)
"
)
;
schema
.
SetTooltipLabel
(
"
{
marker
.
name
}
-
{
marker
.
data
.
name
}
"
)
;
schema
.
AddKeyFormat
(
"
wParam
"
MS
:
:
Format
:
:
Integer
)
;
schema
.
AddKeyFormat
(
"
lParam
"
MS
:
:
Format
:
:
Integer
)
;
return
schema
;
}
}
;
}
class
MOZ_RAII
AutoProfilerMessageMarker
{
public
:
explicit
AutoProfilerMessageMarker
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
:
mMsg
(
msg
)
mWParam
(
wParam
)
mLParam
(
lParam
)
{
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
mOptions
.
emplace
(
MarkerOptions
(
MarkerTiming
:
:
IntervalStart
(
)
)
)
;
nsWindow
*
win
=
WinUtils
:
:
GetNSWindowPtr
(
hWnd
)
;
if
(
win
)
{
nsIWidgetListener
*
wl
=
win
-
>
GetWidgetListener
(
)
;
if
(
wl
)
{
PresShell
*
presShell
=
wl
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
if
(
doc
)
{
mOptions
-
>
Set
(
MarkerInnerWindowId
(
doc
-
>
InnerWindowID
(
)
)
)
;
}
}
}
}
}
}
~
AutoProfilerMessageMarker
(
)
{
if
(
!
profiler_thread_is_being_profiled_for_markers
(
)
)
{
return
;
}
if
(
mOptions
)
{
mOptions
-
>
TimingRef
(
)
.
SetIntervalEnd
(
)
;
}
else
{
mOptions
.
emplace
(
MarkerOptions
(
MarkerTiming
:
:
IntervalEnd
(
)
)
)
;
}
profiler_add_marker
(
"
WindowProc
"
:
:
mozilla
:
:
baseprofiler
:
:
category
:
:
OTHER
std
:
:
move
(
*
mOptions
)
geckoprofiler
:
:
markers
:
:
WindowProcMarker
{
}
mMsg
mWParam
mLParam
)
;
}
protected
:
Maybe
<
MarkerOptions
>
mOptions
;
UINT
mMsg
;
WPARAM
mWParam
;
LPARAM
mLParam
;
}
;
LRESULT
CALLBACK
nsWindow
:
:
WindowProcInternal
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
{
AutoProfilerMessageMarker
marker
(
hWnd
msg
wParam
lParam
)
;
if
(
:
:
GetWindowLongPtrW
(
hWnd
GWLP_ID
)
=
=
eFakeTrackPointScrollableID
)
{
if
(
msg
=
=
WM_HSCROLL
)
{
hWnd
=
:
:
GetParent
(
:
:
GetParent
(
hWnd
)
)
;
}
else
{
WNDPROC
prevWindowProc
=
(
WNDPROC
)
:
:
GetWindowLongPtr
(
hWnd
GWLP_USERDATA
)
;
return
:
:
CallWindowProcW
(
prevWindowProc
hWnd
msg
wParam
lParam
)
;
}
}
if
(
msg
=
=
MOZ_WM_TRACE
)
{
mozilla
:
:
SignalTracerThread
(
)
;
return
0
;
}
nsWindow
*
targetWindow
=
WinUtils
:
:
GetNSWindowPtr
(
hWnd
)
;
NS_ASSERTION
(
targetWindow
"
nsWindow
*
is
null
!
"
)
;
if
(
!
targetWindow
)
return
:
:
DefWindowProcW
(
hWnd
msg
wParam
lParam
)
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
;
if
(
!
targetWindow
-
>
mInDtor
)
kungFuDeathGrip
=
targetWindow
;
targetWindow
-
>
IPCWindowProcHandler
(
msg
wParam
lParam
)
;
nsAutoRollup
autoRollup
;
LRESULT
popupHandlingResult
;
if
(
DealWithPopups
(
hWnd
msg
wParam
lParam
&
popupHandlingResult
)
)
return
popupHandlingResult
;
LRESULT
retValue
;
if
(
targetWindow
-
>
ProcessMessage
(
msg
wParam
lParam
&
retValue
)
)
{
return
retValue
;
}
LRESULT
res
=
:
:
CallWindowProcW
(
targetWindow
-
>
GetPrevWindowProc
(
)
hWnd
msg
wParam
lParam
)
;
return
res
;
}
const
char16_t
*
GetQuitType
(
)
{
if
(
Preferences
:
:
GetBool
(
PREF_WIN_REGISTER_APPLICATION_RESTART
false
)
)
{
DWORD
cchCmdLine
=
0
;
HRESULT
rc
=
:
:
GetApplicationRestartSettings
(
:
:
GetCurrentProcess
(
)
nullptr
&
cchCmdLine
nullptr
)
;
if
(
rc
=
=
S_OK
)
{
return
u
"
os
-
restart
"
;
}
}
return
nullptr
;
}
bool
nsWindow
:
:
ExternalHandlerProcessMessage
(
UINT
aMessage
WPARAM
&
aWParam
LPARAM
&
aLParam
MSGResult
&
aResult
)
{
if
(
mWindowHook
.
Notify
(
mWnd
aMessage
aWParam
aLParam
aResult
)
)
{
return
true
;
}
if
(
IMEHandler
:
:
ProcessMessage
(
this
aMessage
aWParam
aLParam
aResult
)
)
{
return
true
;
}
if
(
MouseScrollHandler
:
:
ProcessMessage
(
this
aMessage
aWParam
aLParam
aResult
)
)
{
return
true
;
}
return
false
;
}
bool
nsWindow
:
:
ProcessMessage
(
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
LRESULT
*
aRetValue
)
{
bool
result
=
ProcessMessageInternal
(
msg
wParam
lParam
aRetValue
)
;
PrintEvent
(
msg
wParam
lParam
*
aRetValue
result
SHOW_REPEAT_EVENTS
SHOW_MOUSEMOVE_EVENTS
)
;
return
result
;
}
bool
nsWindow
:
:
ProcessMessageInternal
(
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
LRESULT
*
aRetValue
)
{
MSGResult
msgResult
(
aRetValue
)
;
if
(
ExternalHandlerProcessMessage
(
msg
wParam
lParam
msgResult
)
)
{
return
(
msgResult
.
mConsumed
|
|
!
mWnd
)
;
}
bool
result
=
false
;
*
aRetValue
=
0
;
LRESULT
dwmHitResult
;
if
(
mCustomNonClient
&
&
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
&
&
!
(
IsWin10OrLater
(
)
&
&
HasGlass
(
)
)
&
&
DwmDefWindowProc
(
mWnd
msg
wParam
lParam
&
dwmHitResult
)
)
{
*
aRetValue
=
dwmHitResult
;
return
true
;
}
static
const
bool
sSwitchKeyboardLayout
=
Preferences
:
:
GetBool
(
"
intl
.
keyboard
.
per_window_layout
"
false
)
;
static
Maybe
<
bool
>
sCanQuit
;
switch
(
msg
)
{
case
WM_QUERYENDSESSION
:
if
(
sCanQuit
.
isNothing
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
nsCOMPtr
<
nsISupportsPRBool
>
cancelQuitWrapper
=
do_CreateInstance
(
NS_SUPPORTS_PRBOOL_CONTRACTID
)
;
cancelQuitWrapper
-
>
SetData
(
false
)
;
const
char16_t
*
quitType
=
GetQuitType
(
)
;
obsServ
-
>
NotifyObservers
(
cancelQuitWrapper
"
quit
-
application
-
requested
"
quitType
)
;
bool
shouldCancelQuit
;
cancelQuitWrapper
-
>
GetData
(
&
shouldCancelQuit
)
;
sCanQuit
.
emplace
(
!
shouldCancelQuit
)
;
}
*
aRetValue
=
*
sCanQuit
;
result
=
true
;
break
;
case
MOZ_WM_STARTA11Y
:
#
if
defined
(
ACCESSIBILITY
)
Unused
<
<
GetAccessible
(
)
;
result
=
true
;
#
else
result
=
false
;
#
endif
break
;
case
WM_ENDSESSION
:
case
MOZ_WM_APP_QUIT
:
if
(
msg
=
=
MOZ_WM_APP_QUIT
|
|
(
wParam
&
&
sCanQuit
.
valueOr
(
false
)
)
)
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
const
char16_t
*
syncShutdown
=
u
"
syncShutdown
"
;
const
char16_t
*
quitType
=
GetQuitType
(
)
;
AppShutdown
:
:
Init
(
AppShutdownMode
:
:
Normal
0
)
;
obsServ
-
>
NotifyObservers
(
nullptr
"
quit
-
application
-
granted
"
syncShutdown
)
;
obsServ
-
>
NotifyObservers
(
nullptr
"
quit
-
application
-
forced
"
nullptr
)
;
AppShutdown
:
:
OnShutdownConfirmed
(
)
;
AppShutdown
:
:
AdvanceShutdownPhase
(
ShutdownPhase
:
:
AppShutdownConfirmed
quitType
)
;
AppShutdown
:
:
AdvanceShutdownPhase
(
ShutdownPhase
:
:
AppShutdownNetTeardown
nullptr
)
;
AppShutdown
:
:
AdvanceShutdownPhase
(
ShutdownPhase
:
:
AppShutdownTeardown
nullptr
)
;
AppShutdown
:
:
AdvanceShutdownPhase
(
ShutdownPhase
:
:
AppShutdown
nullptr
)
;
AppShutdown
:
:
AdvanceShutdownPhase
(
ShutdownPhase
:
:
AppShutdownQM
nullptr
)
;
AppShutdown
:
:
AdvanceShutdownPhase
(
ShutdownPhase
:
:
AppShutdownTelemetry
nullptr
)
;
AppShutdown
:
:
DoImmediateExit
(
)
;
}
sCanQuit
.
reset
(
)
;
result
=
true
;
break
;
case
WM_SYSCOLORCHANGE
:
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
Style
)
;
break
;
case
WM_THEMECHANGED
:
{
UpdateNonClientMargins
(
)
;
nsUXThemeData
:
:
UpdateNativeThemeInfo
(
)
;
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
StyleAndLayout
)
;
UpdateDarkModeToolbar
(
)
;
Invalidate
(
true
true
true
)
;
}
break
;
case
WM_WTSSESSION_CHANGE
:
{
switch
(
wParam
)
{
case
WTS_CONSOLE_CONNECT
:
case
WTS_REMOTE_CONNECT
:
case
WTS_SESSION_UNLOCK
:
Invalidate
(
true
true
true
)
;
break
;
default
:
break
;
}
}
break
;
case
WM_FONTCHANGE
:
{
if
(
mWindowType
!
=
eWindowType_invisible
)
{
break
;
}
nsresult
rv
;
bool
didChange
=
false
;
nsCOMPtr
<
nsIFontEnumerator
>
fontEnum
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
fontenumerator
;
1
"
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
fontEnum
-
>
UpdateFontList
(
&
didChange
)
;
if
(
didChange
)
{
gfxPlatform
:
:
ForceGlobalReflow
(
gfxPlatform
:
:
NeedsReframe
:
:
Yes
)
;
}
}
}
break
;
case
WM_SETTINGCHANGE
:
{
if
(
wParam
=
=
SPI_SETCLIENTAREAANIMATION
|
|
wParam
=
=
SPI_SETKEYBOARDDELAY
)
{
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
MediaQueriesOnly
)
;
break
;
}
if
(
wParam
=
=
SPI_SETFONTSMOOTHING
|
|
wParam
=
=
SPI_SETFONTSMOOTHINGTYPE
)
{
gfxDWriteFont
:
:
UpdateSystemTextVars
(
)
;
break
;
}
if
(
wParam
=
=
SPI_SETWORKAREA
)
{
ScreenHelperWin
:
:
RefreshScreens
(
)
;
break
;
}
if
(
auto
lParamString
=
reinterpret_cast
<
const
wchar_t
*
>
(
lParam
)
)
{
if
(
!
wcscmp
(
lParamString
L
"
ImmersiveColorSet
"
)
)
{
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
Style
)
;
break
;
}
if
(
mWindowType
=
=
eWindowType_invisible
)
{
if
(
!
wcscmp
(
lParamString
L
"
UserInteractionMode
"
)
|
|
!
wcscmp
(
lParamString
L
"
ConvertibleSlateMode
"
)
|
|
!
wcscmp
(
lParamString
L
"
SystemDockMode
"
)
)
{
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
MediaQueriesOnly
)
;
WindowsUIUtils
:
:
UpdateInTabletMode
(
)
;
}
}
}
GetMouseVanishSystemPref
(
true
)
;
}
break
;
case
WM_DEVICECHANGE
:
{
if
(
wParam
=
=
DBT_DEVICEARRIVAL
|
|
wParam
=
=
DBT_DEVICEREMOVECOMPLETE
)
{
DEV_BROADCAST_HDR
*
hdr
=
reinterpret_cast
<
DEV_BROADCAST_HDR
*
>
(
lParam
)
;
if
(
hdr
-
>
dbch_devicetype
=
=
DBT_DEVTYP_DEVICEINTERFACE
)
{
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
MediaQueriesOnly
)
;
}
}
}
break
;
case
WM_NCCALCSIZE
:
{
if
(
mCustomNonClient
)
{
RECT
*
clientRect
=
wParam
?
&
(
reinterpret_cast
<
NCCALCSIZE_PARAMS
*
>
(
lParam
)
)
-
>
rgrc
[
0
]
:
(
reinterpret_cast
<
RECT
*
>
(
lParam
)
)
;
clientRect
-
>
top
+
=
mCaptionHeight
-
mNonClientOffset
.
top
;
clientRect
-
>
left
+
=
mHorResizeMargin
-
mNonClientOffset
.
left
;
clientRect
-
>
right
-
=
mHorResizeMargin
-
mNonClientOffset
.
right
;
clientRect
-
>
bottom
-
=
mVertResizeMargin
-
mNonClientOffset
.
bottom
;
clientRect
-
>
right
=
std
:
:
max
(
clientRect
-
>
right
clientRect
-
>
left
+
1
)
;
clientRect
-
>
bottom
=
std
:
:
max
(
clientRect
-
>
bottom
clientRect
-
>
top
+
1
)
;
result
=
true
;
*
aRetValue
=
0
;
}
break
;
}
case
WM_NCHITTEST
:
{
if
(
mInputRegion
.
mFullyTransparent
)
{
*
aRetValue
=
HTTRANSPARENT
;
result
=
true
;
break
;
}
if
(
mInputRegion
.
mMargin
)
{
const
LayoutDeviceIntPoint
screenPoint
(
GET_X_LPARAM
(
lParam
)
GET_Y_LPARAM
(
lParam
)
)
;
LayoutDeviceIntRect
screenRect
=
GetScreenBounds
(
)
;
screenRect
.
Deflate
(
mInputRegion
.
mMargin
)
;
if
(
!
screenRect
.
Contains
(
screenPoint
)
)
{
*
aRetValue
=
HTTRANSPARENT
;
result
=
true
;
break
;
}
}
if
(
!
mCustomNonClient
)
{
break
;
}
*
aRetValue
=
ClientMarginHitTestPoint
(
GET_X_LPARAM
(
lParam
)
GET_Y_LPARAM
(
lParam
)
)
;
result
=
true
;
break
;
}
case
WM_SETTEXT
:
if
(
(
mSendingSetText
&
&
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
|
|
!
mCustomNonClient
|
|
mNonClientMargins
.
top
=
=
-
1
)
break
;
{
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
EnterPresentLock
(
)
;
}
DWORD
style
=
GetWindowLong
(
mWnd
GWL_STYLE
)
;
SetWindowLong
(
mWnd
GWL_STYLE
style
&
~
WS_VISIBLE
)
;
*
aRetValue
=
CallWindowProcW
(
GetPrevWindowProc
(
)
mWnd
msg
wParam
lParam
)
;
SetWindowLong
(
mWnd
GWL_STYLE
style
)
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
LeavePresentLock
(
)
;
}
return
true
;
}
case
WM_NCACTIVATE
:
{
UpdateGetWindowInfoCaptionStatus
(
FALSE
!
=
wParam
)
;
if
(
!
mCustomNonClient
)
{
break
;
}
if
(
wParam
=
=
TRUE
&
&
!
gfxEnv
:
:
MOZ_DISABLE_FORCE_PRESENT
(
)
&
&
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
nsWindow
:
:
ForcePresent
"
this
&
nsWindow
:
:
ForcePresent
)
)
;
}
if
(
mFrameState
-
>
GetSizeMode
(
)
!
=
nsSizeMode_Fullscreen
&
&
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
break
;
if
(
wParam
=
=
TRUE
)
{
*
aRetValue
=
FALSE
;
result
=
true
;
InvalidateNonClientRegion
(
)
;
break
;
}
else
{
*
aRetValue
=
TRUE
;
result
=
true
;
InvalidateNonClientRegion
(
)
;
break
;
}
}
case
WM_NCPAINT
:
{
gfxDWriteFont
:
:
UpdateSystemTextVars
(
)
;
if
(
!
mCustomNonClient
)
break
;
if
(
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
)
break
;
HRGN
paintRgn
=
ExcludeNonClientFromPaintRegion
(
(
HRGN
)
wParam
)
;
LRESULT
res
=
CallWindowProcW
(
GetPrevWindowProc
(
)
mWnd
msg
(
WPARAM
)
paintRgn
lParam
)
;
if
(
paintRgn
!
=
(
HRGN
)
wParam
)
DeleteObject
(
paintRgn
)
;
*
aRetValue
=
res
;
result
=
true
;
}
break
;
case
WM_POWERBROADCAST
:
switch
(
wParam
)
{
case
PBT_APMSUSPEND
:
PostSleepWakeNotification
(
true
)
;
break
;
case
PBT_APMRESUMEAUTOMATIC
:
case
PBT_APMRESUMECRITICAL
:
case
PBT_APMRESUMESUSPEND
:
PostSleepWakeNotification
(
false
)
;
break
;
}
break
;
case
WM_CLOSE
:
if
(
mWidgetListener
)
mWidgetListener
-
>
RequestWindowClose
(
this
)
;
result
=
true
;
break
;
case
WM_DESTROY
:
DestroyLayerManager
(
)
;
OnDestroy
(
)
;
result
=
true
;
break
;
case
WM_PAINT
:
*
aRetValue
=
(
int
)
OnPaint
(
nullptr
0
)
;
result
=
true
;
break
;
case
WM_PRINTCLIENT
:
result
=
OnPaint
(
(
HDC
)
wParam
0
)
;
break
;
case
WM_HOTKEY
:
result
=
OnHotKey
(
wParam
lParam
)
;
break
;
case
WM_SYSCHAR
:
case
WM_CHAR
:
{
MSG
nativeMsg
=
WinUtils
:
:
InitMSG
(
msg
wParam
lParam
mWnd
)
;
result
=
ProcessCharMessage
(
nativeMsg
nullptr
)
;
DispatchPendingEvents
(
)
;
}
break
;
case
WM_SYSKEYUP
:
case
WM_KEYUP
:
{
MSG
nativeMsg
=
WinUtils
:
:
InitMSG
(
msg
wParam
lParam
mWnd
)
;
nativeMsg
.
time
=
:
:
GetMessageTime
(
)
;
result
=
ProcessKeyUpMessage
(
nativeMsg
nullptr
)
;
DispatchPendingEvents
(
)
;
}
break
;
case
WM_SYSKEYDOWN
:
case
WM_KEYDOWN
:
{
if
(
IsMouseVanishKey
(
wParam
)
)
{
MaybeHideCursor
(
true
)
;
}
MSG
nativeMsg
=
WinUtils
:
:
InitMSG
(
msg
wParam
lParam
mWnd
)
;
result
=
ProcessKeyDownMessage
(
nativeMsg
nullptr
)
;
DispatchPendingEvents
(
)
;
}
break
;
case
WM_ERASEBKGND
:
if
(
!
AutoErase
(
(
HDC
)
wParam
)
)
{
*
aRetValue
=
1
;
result
=
true
;
}
break
;
case
WM_MOUSEMOVE
:
{
MaybeHideCursor
(
false
)
;
LPARAM
lParamScreen
=
lParamToScreen
(
lParam
)
;
mSimulatedClientArea
=
IsSimulatedClientArea
(
GET_X_LPARAM
(
lParamScreen
)
GET_Y_LPARAM
(
lParamScreen
)
)
;
if
(
!
mMousePresent
&
&
!
sIsInMouseCapture
)
{
TRACKMOUSEEVENT
mTrack
;
mTrack
.
cbSize
=
sizeof
(
TRACKMOUSEEVENT
)
;
mTrack
.
dwFlags
=
TME_LEAVE
;
mTrack
.
dwHoverTime
=
0
;
mTrack
.
hwndTrack
=
mWnd
;
TrackMouseEvent
(
&
mTrack
)
;
}
mMousePresent
=
true
;
POINT
mp
;
mp
.
x
=
GET_X_LPARAM
(
lParamScreen
)
;
mp
.
y
=
GET_Y_LPARAM
(
lParamScreen
)
;
bool
userMovedMouse
=
false
;
if
(
(
sLastMouseMovePoint
.
x
!
=
mp
.
x
)
|
|
(
sLastMouseMovePoint
.
y
!
=
mp
.
y
)
)
{
userMovedMouse
=
true
;
}
result
=
DispatchMouseEvent
(
eMouseMove
wParam
lParam
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
mPointerEvents
.
GetCachedPointerInfo
(
msg
wParam
)
)
;
if
(
userMovedMouse
)
{
DispatchPendingEvents
(
)
;
}
}
break
;
case
WM_NCMOUSEMOVE
:
{
MaybeHideCursor
(
false
)
;
LPARAM
lParamClient
=
lParamToClient
(
lParam
)
;
if
(
IsSimulatedClientArea
(
GET_X_LPARAM
(
lParam
)
GET_Y_LPARAM
(
lParam
)
)
)
{
if
(
!
sIsInMouseCapture
)
{
TRACKMOUSEEVENT
mTrack
;
mTrack
.
cbSize
=
sizeof
(
TRACKMOUSEEVENT
)
;
mTrack
.
dwFlags
=
TME_LEAVE
|
TME_NONCLIENT
;
mTrack
.
dwHoverTime
=
0
;
mTrack
.
hwndTrack
=
mWnd
;
TrackMouseEvent
(
&
mTrack
)
;
}
SendMessage
(
mWnd
WM_MOUSEMOVE
0
lParamClient
)
;
}
else
{
mSimulatedClientArea
=
false
;
}
if
(
mMousePresent
&
&
!
sIsInMouseCapture
&
&
!
mSimulatedClientArea
)
{
SendMessage
(
mWnd
WM_MOUSELEAVE
0
0
)
;
}
}
break
;
case
WM_LBUTTONDOWN
:
{
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDown
wParam
lParam
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
mPointerEvents
.
GetCachedPointerInfo
(
msg
wParam
)
)
;
DispatchPendingEvents
(
)
;
}
break
;
case
WM_LBUTTONUP
:
{
result
=
DispatchMouseEvent
(
eMouseUp
wParam
lParam
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
mPointerEvents
.
GetCachedPointerInfo
(
msg
wParam
)
)
;
DispatchPendingEvents
(
)
;
}
break
;
case
WM_NCMOUSELEAVE
:
{
mSimulatedClientArea
=
false
;
if
(
EventIsInsideWindow
(
this
)
)
{
TRACKMOUSEEVENT
mTrack
;
mTrack
.
cbSize
=
sizeof
(
TRACKMOUSEEVENT
)
;
mTrack
.
dwFlags
=
TME_LEAVE
;
mTrack
.
dwHoverTime
=
0
;
mTrack
.
hwndTrack
=
mWnd
;
TrackMouseEvent
(
&
mTrack
)
;
break
;
}
[
[
fallthrough
]
]
;
}
case
WM_MOUSELEAVE
:
{
if
(
!
mMousePresent
)
break
;
if
(
mSimulatedClientArea
)
break
;
mMousePresent
=
false
;
if
(
mTransitionWnd
&
&
WindowAtMouse
(
)
=
=
mTransitionWnd
)
{
sLastMouseMovePoint
=
{
0
}
;
}
WPARAM
mouseState
=
(
GetKeyState
(
VK_LBUTTON
)
?
MK_LBUTTON
:
0
)
|
(
GetKeyState
(
VK_MBUTTON
)
?
MK_MBUTTON
:
0
)
|
(
GetKeyState
(
VK_RBUTTON
)
?
MK_RBUTTON
:
0
)
;
LPARAM
pos
=
lParamToClient
(
:
:
GetMessagePos
(
)
)
;
DispatchMouseEvent
(
eMouseExitFromWidget
mouseState
pos
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
)
;
}
break
;
case
MOZ_WM_PEN_LEAVES_HOVER_OF_DIGITIZER
:
{
LPARAM
pos
=
lParamToClient
(
:
:
GetMessagePos
(
)
)
;
MOZ_ASSERT
(
InkCollector
:
:
sInkCollector
)
;
uint16_t
pointerId
=
InkCollector
:
:
sInkCollector
-
>
GetPointerId
(
)
;
if
(
pointerId
!
=
0
)
{
WinPointerInfo
pointerInfo
;
pointerInfo
.
pointerId
=
pointerId
;
DispatchMouseEvent
(
eMouseExitFromWidget
wParam
pos
false
MouseButton
:
:
ePrimary
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
&
pointerInfo
)
;
InkCollector
:
:
sInkCollector
-
>
ClearTarget
(
)
;
InkCollector
:
:
sInkCollector
-
>
ClearPointerId
(
)
;
}
}
break
;
case
WM_CONTEXTMENU
:
{
if
(
mTouchWindow
&
&
MOUSE_INPUT_SOURCE
(
)
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
MOZ_ASSERT
(
mAPZC
)
;
result
=
true
;
break
;
}
if
(
MOUSE_INPUT_SOURCE
(
)
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
&
&
mNeedsToPreventContextMenu
)
{
result
=
true
;
break
;
}
LPARAM
pos
;
bool
contextMenukey
=
false
;
if
(
lParam
=
=
-
1
)
{
contextMenukey
=
true
;
pos
=
lParamToClient
(
GetMessagePos
(
)
)
;
}
else
{
pos
=
lParamToClient
(
lParam
)
;
}
result
=
DispatchMouseEvent
(
eContextMenu
wParam
pos
contextMenukey
contextMenukey
?
MouseButton
:
:
ePrimary
:
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
)
;
if
(
lParam
!
=
-
1
&
&
!
result
&
&
mCustomNonClient
&
&
mDraggableRegion
.
Contains
(
GET_X_LPARAM
(
pos
)
GET_Y_LPARAM
(
pos
)
)
)
{
DisplaySystemMenu
(
mWnd
mFrameState
-
>
GetSizeMode
(
)
mIsRTL
GET_X_LPARAM
(
lParam
)
GET_Y_LPARAM
(
lParam
)
)
;
result
=
true
;
}
}
break
;
case
WM_POINTERLEAVE
:
case
WM_POINTERDOWN
:
case
WM_POINTERUP
:
case
WM_POINTERUPDATE
:
MaybeHideCursor
(
false
)
;
result
=
OnPointerEvents
(
msg
wParam
lParam
)
;
if
(
result
)
{
DispatchPendingEvents
(
)
;
}
break
;
case
DM_POINTERHITTEST
:
if
(
mDmOwner
)
{
UINT
contactId
=
GET_POINTERID_WPARAM
(
wParam
)
;
POINTER_INPUT_TYPE
pointerType
;
if
(
mPointerEvents
.
GetPointerType
(
contactId
&
pointerType
)
&
&
pointerType
=
=
PT_TOUCHPAD
)
{
mDmOwner
-
>
SetContact
(
contactId
)
;
}
}
break
;
case
WM_LBUTTONDBLCLK
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDoubleClick
wParam
lParam
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_MBUTTONDOWN
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDown
wParam
lParam
false
MouseButton
:
:
eMiddle
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_MBUTTONUP
:
result
=
DispatchMouseEvent
(
eMouseUp
wParam
lParam
false
MouseButton
:
:
eMiddle
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_MBUTTONDBLCLK
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDoubleClick
wParam
lParam
false
MouseButton
:
:
eMiddle
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCMBUTTONDOWN
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDown
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
eMiddle
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCMBUTTONUP
:
result
=
DispatchMouseEvent
(
eMouseUp
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
eMiddle
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCMBUTTONDBLCLK
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDoubleClick
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
eMiddle
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_RBUTTONDOWN
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDown
wParam
lParam
false
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
mPointerEvents
.
GetCachedPointerInfo
(
msg
wParam
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_RBUTTONUP
:
result
=
DispatchMouseEvent
(
eMouseUp
wParam
lParam
false
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
mPointerEvents
.
GetCachedPointerInfo
(
msg
wParam
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_RBUTTONDBLCLK
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDoubleClick
wParam
lParam
false
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCRBUTTONDOWN
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDown
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCRBUTTONUP
:
result
=
DispatchMouseEvent
(
eMouseUp
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCRBUTTONDBLCLK
:
MaybeHideCursor
(
false
)
;
result
=
DispatchMouseEvent
(
eMouseDoubleClick
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
eSecondary
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_XBUTTONDOWN
:
case
WM_XBUTTONUP
:
case
WM_NCXBUTTONDOWN
:
case
WM_NCXBUTTONUP
:
MaybeHideCursor
(
false
)
;
*
aRetValue
=
TRUE
;
switch
(
GET_XBUTTON_WPARAM
(
wParam
)
)
{
case
XBUTTON1
:
result
=
!
Preferences
:
:
GetBool
(
"
mousebutton
.
4th
.
enabled
"
true
)
;
break
;
case
XBUTTON2
:
result
=
!
Preferences
:
:
GetBool
(
"
mousebutton
.
5th
.
enabled
"
true
)
;
break
;
default
:
break
;
}
break
;
case
WM_SIZING
:
{
if
(
mAspectRatio
>
0
)
{
LPRECT
rect
=
(
LPRECT
)
lParam
;
int32_t
newWidth
newHeight
;
if
(
wParam
=
=
WMSZ_LEFT
|
|
wParam
=
=
WMSZ_RIGHT
|
|
wParam
=
=
WMSZ_TOPLEFT
|
|
wParam
=
=
WMSZ_BOTTOMLEFT
)
{
newWidth
=
rect
-
>
right
-
rect
-
>
left
;
newHeight
=
newWidth
/
mAspectRatio
;
if
(
newHeight
<
mSizeConstraints
.
mMinSize
.
height
)
{
newHeight
=
mSizeConstraints
.
mMinSize
.
height
;
newWidth
=
newHeight
*
mAspectRatio
;
}
else
if
(
newHeight
>
mSizeConstraints
.
mMaxSize
.
height
)
{
newHeight
=
mSizeConstraints
.
mMaxSize
.
height
;
newWidth
=
newHeight
*
mAspectRatio
;
}
}
else
{
newHeight
=
rect
-
>
bottom
-
rect
-
>
top
;
newWidth
=
newHeight
*
mAspectRatio
;
if
(
newWidth
<
mSizeConstraints
.
mMinSize
.
width
)
{
newWidth
=
mSizeConstraints
.
mMinSize
.
width
;
newHeight
=
newWidth
/
mAspectRatio
;
}
else
if
(
newWidth
>
mSizeConstraints
.
mMaxSize
.
width
)
{
newWidth
=
mSizeConstraints
.
mMaxSize
.
width
;
newHeight
=
newWidth
/
mAspectRatio
;
}
}
switch
(
wParam
)
{
case
WMSZ_RIGHT
:
case
WMSZ_BOTTOM
:
rect
-
>
right
=
newWidth
+
rect
-
>
left
;
rect
-
>
bottom
=
rect
-
>
top
+
newHeight
;
break
;
case
WMSZ_TOP
:
rect
-
>
right
=
newWidth
+
rect
-
>
left
;
rect
-
>
top
=
rect
-
>
bottom
-
newHeight
;
break
;
case
WMSZ_LEFT
:
case
WMSZ_TOPLEFT
:
rect
-
>
left
=
rect
-
>
right
-
newWidth
;
rect
-
>
top
=
rect
-
>
bottom
-
newHeight
;
break
;
case
WMSZ_TOPRIGHT
:
rect
-
>
right
=
rect
-
>
left
+
newWidth
;
rect
-
>
top
=
rect
-
>
bottom
-
newHeight
;
break
;
case
WMSZ_BOTTOMLEFT
:
rect
-
>
left
=
rect
-
>
right
-
newWidth
;
rect
-
>
bottom
=
rect
-
>
top
+
newHeight
;
break
;
case
WMSZ_BOTTOMRIGHT
:
rect
-
>
right
=
rect
-
>
left
+
newWidth
;
rect
-
>
bottom
=
rect
-
>
top
+
newHeight
;
break
;
}
}
if
(
mResizeState
=
=
IN_SIZEMOVE
)
{
mResizeState
=
RESIZING
;
NotifyLiveResizeStarted
(
)
;
}
break
;
}
case
WM_MOVING
:
FinishLiveResizing
(
MOVING
)
;
if
(
WinUtils
:
:
IsPerMonitorDPIAware
(
)
)
{
if
(
WinUtils
:
:
LogToPhysFactor
(
mWnd
)
!
=
mDefaultScale
)
{
ChangedDPI
(
)
;
ResetLayout
(
)
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
UIResolutionChanged
(
)
;
}
}
}
break
;
case
WM_ENTERSIZEMOVE
:
{
if
(
mResizeState
=
=
NOT_RESIZING
)
{
mResizeState
=
IN_SIZEMOVE
;
}
break
;
}
case
WM_EXITSIZEMOVE
:
{
FinishLiveResizing
(
NOT_RESIZING
)
;
if
(
!
sIsInMouseCapture
)
{
NotifySizeMoveDone
(
)
;
}
break
;
}
case
WM_DISPLAYCHANGE
:
{
ScreenHelperWin
:
:
RefreshScreens
(
)
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
UIResolutionChanged
(
)
;
}
break
;
}
case
WM_NCLBUTTONDBLCLK
:
DispatchMouseEvent
(
eMouseDoubleClick
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
)
;
result
=
DispatchMouseEvent
(
eMouseUp
0
lParamToClient
(
lParam
)
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
)
;
DispatchPendingEvents
(
)
;
break
;
case
WM_NCLBUTTONDOWN
:
{
if
(
ClientMarginHitTestPoint
(
GET_X_LPARAM
(
lParam
)
GET_Y_LPARAM
(
lParam
)
)
=
=
HTCAPTION
)
{
DispatchCustomEvent
(
u
"
draggableregionleftmousedown
"
_ns
)
;
}
if
(
IsWindowButton
(
wParam
)
&
&
mCustomNonClient
&
&
!
mWindowButtonsRect
)
{
DispatchMouseEvent
(
eMouseDown
wParamFromGlobalMouseState
(
)
lParamToClient
(
lParam
)
false
MouseButton
:
:
ePrimary
MOUSE_INPUT_SOURCE
(
)
nullptr
true
)
;
DispatchPendingEvents
(
)
;
result
=
true
;
}
break
;
}
case
WM_APPCOMMAND
:
{
MSG
nativeMsg
=
WinUtils
:
:
InitMSG
(
msg
wParam
lParam
mWnd
)
;
result
=
HandleAppCommandMsg
(
nativeMsg
aRetValue
)
;
break
;
}
case
WM_ACTIVATE
:
{
int32_t
fActive
=
LOWORD
(
wParam
)
;
if
(
!
fActive
)
{
MaybeHideCursor
(
false
)
;
}
if
(
mWidgetListener
)
{
if
(
WA_INACTIVE
=
=
fActive
)
{
if
(
HIWORD
(
wParam
)
|
|
(
mLastKillFocusWindow
&
&
(
GetTopLevelForFocus
(
mLastKillFocusWindow
)
=
=
mWnd
)
)
)
{
DispatchFocusToTopLevelWindow
(
false
)
;
}
else
{
sJustGotDeactivate
=
true
;
}
if
(
mIsTopWidgetWindow
)
{
mLastKeyboardLayout
=
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLayout
(
)
;
}
}
else
{
StopFlashing
(
)
;
sJustGotActivate
=
true
;
WidgetMouseEvent
event
(
true
eMouseActivate
this
WidgetMouseEvent
:
:
eReal
)
;
InitEvent
(
event
)
;
ModifierKeyState
modifierKeyState
;
modifierKeyState
.
InitInputEvent
(
event
)
;
DispatchInputEvent
(
&
event
)
;
if
(
sSwitchKeyboardLayout
&
&
mLastKeyboardLayout
)
ActivateKeyboardLayout
(
mLastKeyboardLayout
0
)
;
}
}
}
break
;
case
WM_MOUSEACTIVATE
:
if
(
IsPopup
(
)
&
&
IsOwnerForegroundWindow
(
)
)
{
*
aRetValue
=
MA_NOACTIVATE
;
result
=
true
;
}
break
;
case
WM_WINDOWPOSCHANGING
:
{
LPWINDOWPOS
info
=
(
LPWINDOWPOS
)
lParam
;
OnWindowPosChanging
(
info
)
;
result
=
true
;
}
break
;
case
WM_GETMINMAXINFO
:
{
MINMAXINFO
*
mmi
=
(
MINMAXINFO
*
)
lParam
;
mmi
-
>
ptMinTrackSize
.
x
=
std
:
:
min
(
(
int32_t
)
mmi
-
>
ptMaxTrackSize
.
x
std
:
:
max
(
(
int32_t
)
mmi
-
>
ptMinTrackSize
.
x
mSizeConstraints
.
mMinSize
.
width
)
)
;
mmi
-
>
ptMinTrackSize
.
y
=
std
:
:
min
(
(
int32_t
)
mmi
-
>
ptMaxTrackSize
.
y
std
:
:
max
(
(
int32_t
)
mmi
-
>
ptMinTrackSize
.
y
mSizeConstraints
.
mMinSize
.
height
)
)
;
mmi
-
>
ptMaxTrackSize
.
x
=
std
:
:
min
(
(
int32_t
)
mmi
-
>
ptMaxTrackSize
.
x
mSizeConstraints
.
mMaxSize
.
width
)
;
mmi
-
>
ptMaxTrackSize
.
y
=
std
:
:
min
(
(
int32_t
)
mmi
-
>
ptMaxTrackSize
.
y
mSizeConstraints
.
mMaxSize
.
height
)
;
}
break
;
case
WM_SETFOCUS
:
if
(
!
WinUtils
:
:
IsOurProcessWindow
(
HWND
(
wParam
)
)
)
{
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
}
if
(
sJustGotActivate
)
{
DispatchFocusToTopLevelWindow
(
true
)
;
}
TaskbarConcealer
:
:
OnFocusAcquired
(
this
)
;
break
;
case
WM_KILLFOCUS
:
if
(
sJustGotDeactivate
)
{
DispatchFocusToTopLevelWindow
(
false
)
;
}
else
{
mLastKillFocusWindow
=
mWnd
;
}
break
;
case
WM_WINDOWPOSCHANGED
:
{
WINDOWPOS
*
wp
=
(
LPWINDOWPOS
)
lParam
;
OnWindowPosChanged
(
wp
)
;
TaskbarConcealer
:
:
OnWindowPosChanged
(
this
)
;
result
=
true
;
}
break
;
case
WM_INPUTLANGCHANGEREQUEST
:
*
aRetValue
=
TRUE
;
result
=
false
;
break
;
case
WM_INPUTLANGCHANGE
:
KeyboardLayout
:
:
GetInstance
(
)
-
>
OnLayoutChange
(
reinterpret_cast
<
HKL
>
(
lParam
)
)
;
nsBidiKeyboard
:
:
OnLayoutChange
(
)
;
result
=
false
;
break
;
case
WM_DESTROYCLIPBOARD
:
{
nsIClipboard
*
clipboard
;
nsresult
rv
=
CallGetService
(
kCClipboardCID
&
clipboard
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
clipboard
-
>
EmptyClipboard
(
nsIClipboard
:
:
kGlobalClipboard
)
;
NS_RELEASE
(
clipboard
)
;
}
}
break
;
#
ifdef
ACCESSIBILITY
case
WM_GETOBJECT
:
{
*
aRetValue
=
0
;
int32_t
objId
=
static_cast
<
DWORD
>
(
lParam
)
;
if
(
objId
=
=
OBJID_CLIENT
)
{
RefPtr
<
IAccessible
>
root
(
a11y
:
:
LazyInstantiator
:
:
GetRootAccessible
(
mWnd
)
)
;
if
(
root
)
{
*
aRetValue
=
LresultFromObject
(
IID_IAccessible
wParam
root
)
;
a11y
:
:
LazyInstantiator
:
:
EnableBlindAggregation
(
mWnd
)
;
result
=
true
;
}
}
}
break
;
#
endif
case
WM_SYSCOMMAND
:
{
WPARAM
filteredWParam
=
(
wParam
&
0xFFF0
)
;
if
(
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Fullscreen
&
&
filteredWParam
=
=
SC_RESTORE
&
&
GetCurrentShowCmd
(
mWnd
)
!
=
SW_SHOWMINIMIZED
)
{
mFrameState
-
>
EnsureFullscreenMode
(
false
)
;
result
=
true
;
}
if
(
filteredWParam
=
=
SC_KEYMENU
&
&
lParam
=
=
VK_SPACE
&
&
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Fullscreen
)
{
DisplaySystemMenu
(
mWnd
mFrameState
-
>
GetSizeMode
(
)
mIsRTL
MOZ_SYSCONTEXT_X_POS
MOZ_SYSCONTEXT_Y_POS
)
;
result
=
true
;
}
}
break
;
case
WM_DWMCOMPOSITIONCHANGED
:
if
(
XRE_IsParentProcess
(
)
)
{
BOOL
dwmEnabled
=
FALSE
;
if
(
FAILED
(
:
:
DwmIsCompositionEnabled
(
&
dwmEnabled
)
)
|
|
!
dwmEnabled
)
{
gfxVars
:
:
SetDwmCompositionEnabled
(
false
)
;
}
else
{
gfxVars
:
:
SetDwmCompositionEnabled
(
true
)
;
}
}
UpdateNonClientMargins
(
)
;
BroadcastMsg
(
mWnd
WM_DWMCOMPOSITIONCHANGED
)
;
NotifyThemeChanged
(
widget
:
:
ThemeChangeKind
:
:
StyleAndLayout
)
;
UpdateGlass
(
)
;
Invalidate
(
true
true
true
)
;
break
;
case
WM_DPICHANGED
:
{
LPRECT
rect
=
(
LPRECT
)
lParam
;
OnDPIChanged
(
rect
-
>
left
rect
-
>
top
rect
-
>
right
-
rect
-
>
left
rect
-
>
bottom
-
rect
-
>
top
)
;
break
;
}
case
WM_UPDATEUISTATE
:
{
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
{
int32_t
action
=
LOWORD
(
wParam
)
;
if
(
action
=
=
UIS_SET
|
|
action
=
=
UIS_CLEAR
)
{
int32_t
flags
=
HIWORD
(
wParam
)
;
UIStateChangeType
showFocusRings
=
UIStateChangeType_NoChange
;
if
(
flags
&
UISF_HIDEFOCUS
)
{
showFocusRings
=
(
action
=
=
UIS_SET
)
?
UIStateChangeType_Clear
:
UIStateChangeType_Set
;
}
NotifyUIStateChanged
(
showFocusRings
)
;
}
}
break
;
}
case
WM_TABLET_QUERYSYSTEMGESTURESTATUS
:
result
=
true
;
*
aRetValue
=
TABLET_ROTATE_GESTURE_ENABLE
;
break
;
case
WM_TOUCH
:
result
=
OnTouch
(
wParam
lParam
)
;
if
(
result
)
{
*
aRetValue
=
0
;
}
break
;
case
WM_GESTURE
:
result
=
OnGesture
(
wParam
lParam
)
;
break
;
case
WM_GESTURENOTIFY
:
{
if
(
mWindowType
!
=
eWindowType_invisible
)
{
GESTURENOTIFYSTRUCT
*
gestureinfo
=
(
GESTURENOTIFYSTRUCT
*
)
lParam
;
nsPointWin
touchPoint
;
touchPoint
=
gestureinfo
-
>
ptsLocation
;
touchPoint
.
ScreenToClient
(
mWnd
)
;
WidgetGestureNotifyEvent
gestureNotifyEvent
(
true
eGestureNotify
this
)
;
gestureNotifyEvent
.
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromUnknownPoint
(
touchPoint
)
;
nsEventStatus
status
;
DispatchEvent
(
&
gestureNotifyEvent
status
)
;
mDisplayPanFeedback
=
gestureNotifyEvent
.
mDisplayPanFeedback
;
if
(
!
mTouchWindow
)
mGesture
.
SetWinGestureSupport
(
mWnd
gestureNotifyEvent
.
mPanDirection
)
;
}
result
=
false
;
}
break
;
case
WM_CLEAR
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandDelete
this
)
;
DispatchWindowEvent
(
command
)
;
result
=
true
;
}
break
;
case
WM_CUT
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandCut
this
)
;
DispatchWindowEvent
(
command
)
;
result
=
true
;
}
break
;
case
WM_COPY
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandCopy
this
)
;
DispatchWindowEvent
(
command
)
;
result
=
true
;
}
break
;
case
WM_PASTE
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandPaste
this
)
;
DispatchWindowEvent
(
command
)
;
result
=
true
;
}
break
;
case
EM_UNDO
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandUndo
this
)
;
DispatchWindowEvent
(
command
)
;
*
aRetValue
=
(
LRESULT
)
(
command
.
mSucceeded
&
&
command
.
mIsEnabled
)
;
result
=
true
;
}
break
;
case
EM_REDO
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandRedo
this
)
;
DispatchWindowEvent
(
command
)
;
*
aRetValue
=
(
LRESULT
)
(
command
.
mSucceeded
&
&
command
.
mIsEnabled
)
;
result
=
true
;
}
break
;
case
EM_CANPASTE
:
{
if
(
wParam
=
=
0
|
|
wParam
=
=
CF_TEXT
|
|
wParam
=
=
CF_UNICODETEXT
)
{
WidgetContentCommandEvent
command
(
true
eContentCommandPaste
this
true
)
;
DispatchWindowEvent
(
command
)
;
*
aRetValue
=
(
LRESULT
)
(
command
.
mSucceeded
&
&
command
.
mIsEnabled
)
;
result
=
true
;
}
}
break
;
case
EM_CANUNDO
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandUndo
this
true
)
;
DispatchWindowEvent
(
command
)
;
*
aRetValue
=
(
LRESULT
)
(
command
.
mSucceeded
&
&
command
.
mIsEnabled
)
;
result
=
true
;
}
break
;
case
EM_CANREDO
:
{
WidgetContentCommandEvent
command
(
true
eContentCommandRedo
this
true
)
;
DispatchWindowEvent
(
command
)
;
*
aRetValue
=
(
LRESULT
)
(
command
.
mSucceeded
&
&
command
.
mIsEnabled
)
;
result
=
true
;
}
break
;
case
MOZ_WM_SKEWFIX
:
{
TimeStamp
skewStamp
;
if
(
CurrentWindowsTimeGetter
:
:
GetAndClearBackwardsSkewStamp
(
wParam
&
skewStamp
)
)
{
TimeConverter
(
)
.
CompensateForBackwardsSkew
(
:
:
GetMessageTime
(
)
skewStamp
)
;
}
}
break
;
default
:
{
if
(
msg
=
=
nsAppShell
:
:
GetTaskbarButtonCreatedMessage
(
)
)
{
SetHasTaskbarIconBeenCreated
(
)
;
}
}
break
;
}
if
(
mWnd
)
{
return
result
;
}
else
{
return
true
;
}
}
void
nsWindow
:
:
FinishLiveResizing
(
ResizeState
aNewState
)
{
if
(
mResizeState
=
=
RESIZING
)
{
NotifyLiveResizeStopped
(
)
;
}
mResizeState
=
aNewState
;
ForcePresent
(
)
;
}
BOOL
CALLBACK
nsWindow
:
:
BroadcastMsgToChildren
(
HWND
aWnd
LPARAM
aMsg
)
{
WNDPROC
winProc
=
(
WNDPROC
)
:
:
GetWindowLongPtrW
(
aWnd
GWLP_WNDPROC
)
;
if
(
winProc
=
=
&
nsWindow
:
:
WindowProc
)
{
:
:
CallWindowProcW
(
winProc
aWnd
aMsg
0
0
)
;
}
return
TRUE
;
}
BOOL
CALLBACK
nsWindow
:
:
BroadcastMsg
(
HWND
aTopWindow
LPARAM
aMsg
)
{
:
:
EnumChildWindows
(
aTopWindow
nsWindow
:
:
BroadcastMsgToChildren
aMsg
)
;
return
TRUE
;
}
int32_t
nsWindow
:
:
ClientMarginHitTestPoint
(
int32_t
aX
int32_t
aY
)
{
const
nsSizeMode
sizeMode
=
mFrameState
-
>
GetSizeMode
(
)
;
if
(
sizeMode
=
=
nsSizeMode_Minimized
|
|
sizeMode
=
=
nsSizeMode_Fullscreen
)
{
return
HTCLIENT
;
}
const
LayoutDeviceIntRect
winRect
=
GetScreenBounds
(
)
;
const
LayoutDeviceIntPoint
point
(
aX
aY
)
;
int32_t
testResult
=
HTCLIENT
;
const
bool
isResizable
=
sizeMode
!
=
nsSizeMode_Maximized
&
&
(
mBorderStyle
&
(
eBorderStyle_all
|
eBorderStyle_resizeh
|
eBorderStyle_default
)
)
;
const
LayoutDeviceIntMargin
nonClientSizeMargin
(
std
:
:
max
(
mCaptionHeight
-
mNonClientOffset
.
top
kResizableBorderMinSize
)
std
:
:
max
(
mHorResizeMargin
-
mNonClientOffset
.
right
kResizableBorderMinSize
)
std
:
:
max
(
mVertResizeMargin
-
mNonClientOffset
.
bottom
kResizableBorderMinSize
)
std
:
:
max
(
mHorResizeMargin
-
mNonClientOffset
.
left
kResizableBorderMinSize
)
)
;
LayoutDeviceIntRect
clientRect
=
winRect
;
clientRect
.
Deflate
(
nonClientSizeMargin
)
;
const
bool
allowContentOverride
=
sizeMode
=
=
nsSizeMode_Maximized
|
|
clientRect
.
Contains
(
point
)
;
LayoutDeviceIntMargin
borderSize
=
nonClientSizeMargin
;
borderSize
.
EnsureAtLeast
(
LayoutDeviceIntMargin
(
mVertResizeMargin
mHorResizeMargin
mVertResizeMargin
mHorResizeMargin
)
)
;
bool
top
=
false
;
bool
bottom
=
false
;
bool
left
=
false
;
bool
right
=
false
;
if
(
point
.
y
>
=
winRect
.
y
&
&
point
.
y
<
winRect
.
y
+
borderSize
.
top
)
{
top
=
true
;
}
else
if
(
point
.
y
<
=
winRect
.
YMost
(
)
&
&
point
.
y
>
winRect
.
YMost
(
)
-
borderSize
.
bottom
)
{
bottom
=
true
;
}
int
multiplier
=
(
top
|
|
bottom
)
?
2
:
1
;
if
(
point
.
x
>
=
winRect
.
x
&
&
point
.
x
<
winRect
.
x
+
(
multiplier
*
borderSize
.
left
)
)
{
left
=
true
;
}
else
if
(
point
.
x
<
=
winRect
.
XMost
(
)
&
&
point
.
x
>
winRect
.
XMost
(
)
-
(
multiplier
*
borderSize
.
right
)
)
{
right
=
true
;
}
bool
inResizeRegion
=
false
;
if
(
isResizable
)
{
if
(
top
)
{
testResult
=
HTTOP
;
if
(
left
)
{
testResult
=
HTTOPLEFT
;
}
else
if
(
right
)
{
testResult
=
HTTOPRIGHT
;
}
}
else
if
(
bottom
)
{
testResult
=
HTBOTTOM
;
if
(
left
)
{
testResult
=
HTBOTTOMLEFT
;
}
else
if
(
right
)
{
testResult
=
HTBOTTOMRIGHT
;
}
}
else
{
if
(
left
)
{
testResult
=
HTLEFT
;
}
if
(
right
)
{
testResult
=
HTRIGHT
;
}
}
inResizeRegion
=
(
testResult
!
=
HTCLIENT
)
;
}
else
{
if
(
top
)
{
testResult
=
HTCAPTION
;
}
else
if
(
bottom
|
|
left
|
|
right
)
{
testResult
=
HTBORDER
;
}
}
if
(
!
sIsInMouseCapture
&
&
allowContentOverride
)
{
{
POINT
pt
=
{
aX
aY
}
;
:
:
ScreenToClient
(
mWnd
&
pt
)
;
if
(
pt
.
x
=
=
mCachedHitTestPoint
.
x
&
&
pt
.
y
=
=
mCachedHitTestPoint
.
y
&
&
TimeStamp
:
:
Now
(
)
-
mCachedHitTestTime
<
TimeDuration
:
:
FromMilliseconds
(
HITTEST_CACHE_LIFETIME_MS
)
)
{
return
mCachedHitTestResult
;
}
mCachedHitTestPoint
=
{
pt
.
x
pt
.
y
}
;
mCachedHitTestTime
=
TimeStamp
:
:
Now
(
)
;
}
auto
pt
=
mCachedHitTestPoint
;
if
(
mWindowBtnRect
[
WindowButtonType
:
:
Minimize
]
.
Contains
(
pt
)
)
{
testResult
=
HTMINBUTTON
;
}
else
if
(
mWindowBtnRect
[
WindowButtonType
:
:
Maximize
]
.
Contains
(
pt
)
)
{
testResult
=
HTMAXBUTTON
;
}
else
if
(
mWindowBtnRect
[
WindowButtonType
:
:
Close
]
.
Contains
(
pt
)
)
{
testResult
=
HTCLOSE
;
}
else
if
(
!
inResizeRegion
)
{
if
(
mDraggableRegion
.
Contains
(
pt
)
)
{
testResult
=
HTCAPTION
;
}
else
{
testResult
=
HTCLIENT
;
}
}
mCachedHitTestResult
=
testResult
;
}
return
testResult
;
}
bool
nsWindow
:
:
IsSimulatedClientArea
(
int32_t
screenX
int32_t
screenY
)
{
int32_t
testResult
=
ClientMarginHitTestPoint
(
screenX
screenY
)
;
return
testResult
=
=
HTCAPTION
|
|
IsWindowButton
(
testResult
)
;
}
bool
nsWindow
:
:
IsWindowButton
(
int32_t
hitTestResult
)
{
return
hitTestResult
=
=
HTMINBUTTON
|
|
hitTestResult
=
=
HTMAXBUTTON
|
|
hitTestResult
=
=
HTCLOSE
;
}
TimeStamp
nsWindow
:
:
GetMessageTimeStamp
(
LONG
aEventTime
)
const
{
CurrentWindowsTimeGetter
getCurrentTime
(
mWnd
)
;
return
TimeConverter
(
)
.
GetTimeStampFromSystemTime
(
aEventTime
getCurrentTime
)
;
}
void
nsWindow
:
:
PostSleepWakeNotification
(
const
bool
aIsSleepMode
)
{
static
bool
sWasSleepMode
=
false
;
if
(
aIsSleepMode
=
=
sWasSleepMode
)
return
;
sWasSleepMode
=
aIsSleepMode
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
nullptr
aIsSleepMode
?
NS_WIDGET_SLEEP_OBSERVER_TOPIC
:
NS_WIDGET_WAKE_OBSERVER_TOPIC
nullptr
)
;
}
LRESULT
nsWindow
:
:
ProcessCharMessage
(
const
MSG
&
aMsg
bool
*
aEventDispatched
)
{
if
(
IMEHandler
:
:
IsComposingOn
(
this
)
)
{
IMEHandler
:
:
NotifyIME
(
this
REQUEST_TO_COMMIT_COMPOSITION
)
;
}
ModifierKeyState
modKeyState
;
NativeKey
nativeKey
(
this
aMsg
modKeyState
)
;
return
static_cast
<
LRESULT
>
(
nativeKey
.
HandleCharMessage
(
aEventDispatched
)
)
;
}
LRESULT
nsWindow
:
:
ProcessKeyUpMessage
(
const
MSG
&
aMsg
bool
*
aEventDispatched
)
{
ModifierKeyState
modKeyState
;
NativeKey
nativeKey
(
this
aMsg
modKeyState
)
;
bool
result
=
nativeKey
.
HandleKeyUpMessage
(
aEventDispatched
)
;
if
(
aMsg
.
wParam
=
=
VK_F10
)
{
return
true
;
}
return
result
;
}
LRESULT
nsWindow
:
:
ProcessKeyDownMessage
(
const
MSG
&
aMsg
bool
*
aEventDispatched
)
{
RedirectedKeyDownMessageManager
:
:
AutoFlusher
redirectedMsgFlusher
(
this
aMsg
)
;
ModifierKeyState
modKeyState
;
NativeKey
nativeKey
(
this
aMsg
modKeyState
)
;
LRESULT
result
=
static_cast
<
LRESULT
>
(
nativeKey
.
HandleKeyDownMessage
(
aEventDispatched
)
)
;
redirectedMsgFlusher
.
Cancel
(
)
;
if
(
aMsg
.
wParam
=
=
VK_MENU
|
|
(
aMsg
.
wParam
=
=
VK_F10
&
&
!
modKeyState
.
IsShift
(
)
)
)
{
bool
hasNativeMenu
=
false
;
HWND
hWnd
=
mWnd
;
while
(
hWnd
)
{
if
(
:
:
GetMenu
(
hWnd
)
)
{
hasNativeMenu
=
true
;
break
;
}
hWnd
=
:
:
GetParent
(
hWnd
)
;
}
result
=
!
hasNativeMenu
;
}
return
result
;
}
nsresult
nsWindow
:
:
SynthesizeNativeKeyEvent
(
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
keyevent
"
)
;
KeyboardLayout
*
keyboardLayout
=
KeyboardLayout
:
:
GetInstance
(
)
;
return
keyboardLayout
-
>
SynthesizeNativeKeyEvent
(
this
aNativeKeyboardLayout
aNativeKeyCode
aModifierFlags
aCharacters
aUnmodifiedCharacters
)
;
}
nsresult
nsWindow
:
:
SynthesizeNativeMouseEvent
(
LayoutDeviceIntPoint
aPoint
NativeMouseMessage
aNativeMessage
MouseButton
aButton
nsIWidget
:
:
Modifiers
aModifierFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mouseevent
"
)
;
INPUT
input
;
memset
(
&
input
0
sizeof
(
input
)
)
;
switch
(
aNativeMessage
)
{
case
NativeMouseMessage
:
:
Move
:
input
.
mi
.
dwFlags
=
MOUSEEVENTF_MOVE
;
sLastMouseMovePoint
=
{
0
}
;
break
;
case
NativeMouseMessage
:
:
ButtonDown
:
case
NativeMouseMessage
:
:
ButtonUp
:
{
const
bool
isDown
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
;
switch
(
aButton
)
{
case
MouseButton
:
:
ePrimary
:
input
.
mi
.
dwFlags
=
isDown
?
MOUSEEVENTF_LEFTDOWN
:
MOUSEEVENTF_LEFTUP
;
break
;
case
MouseButton
:
:
eMiddle
:
input
.
mi
.
dwFlags
=
isDown
?
MOUSEEVENTF_MIDDLEDOWN
:
MOUSEEVENTF_MIDDLEUP
;
break
;
case
MouseButton
:
:
eSecondary
:
input
.
mi
.
dwFlags
=
isDown
?
MOUSEEVENTF_RIGHTDOWN
:
MOUSEEVENTF_RIGHTUP
;
break
;
case
MouseButton
:
:
eX1
:
input
.
mi
.
dwFlags
=
isDown
?
MOUSEEVENTF_XDOWN
:
MOUSEEVENTF_XUP
;
input
.
mi
.
mouseData
=
XBUTTON1
;
break
;
case
MouseButton
:
:
eX2
:
input
.
mi
.
dwFlags
=
isDown
?
MOUSEEVENTF_XDOWN
:
MOUSEEVENTF_XUP
;
input
.
mi
.
mouseData
=
XBUTTON2
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
break
;
}
case
NativeMouseMessage
:
:
EnterWindow
:
case
NativeMouseMessage
:
:
LeaveWindow
:
MOZ_ASSERT_UNREACHABLE
(
"
Non
supported
mouse
event
on
Windows
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
input
.
type
=
INPUT_MOUSE
;
:
:
SetCursorPos
(
aPoint
.
x
aPoint
.
y
)
;
:
:
SendInput
(
1
&
input
sizeof
(
INPUT
)
)
;
return
NS_OK
;
}
nsresult
nsWindow
:
:
SynthesizeNativeMouseScrollEvent
(
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
double
aDeltaX
double
aDeltaY
double
aDeltaZ
uint32_t
aModifierFlags
uint32_t
aAdditionalFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mousescrollevent
"
)
;
return
MouseScrollHandler
:
:
SynthesizeNativeMouseScrollEvent
(
this
aPoint
aNativeMessage
(
aNativeMessage
=
=
WM_MOUSEWHEEL
|
|
aNativeMessage
=
=
WM_VSCROLL
)
?
static_cast
<
int32_t
>
(
aDeltaY
)
:
static_cast
<
int32_t
>
(
aDeltaX
)
aModifierFlags
aAdditionalFlags
)
;
}
nsresult
nsWindow
:
:
SynthesizeNativeTouchpadPan
(
TouchpadGesturePhase
aEventPhase
LayoutDeviceIntPoint
aPoint
double
aDeltaX
double
aDeltaY
int32_t
aModifierFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
touchpadpanevent
"
)
;
DirectManipulationOwner
:
:
SynthesizeNativeTouchpadPan
(
this
aEventPhase
aPoint
aDeltaX
aDeltaY
aModifierFlags
)
;
return
NS_OK
;
}
static
void
MaybeLogSizeMode
(
nsSizeMode
aMode
)
{
#
ifdef
WINSTATE_DEBUG_OUTPUT
switch
(
aMode
)
{
case
nsSizeMode_Normal
:
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
SizeMode
:
nsSizeMode_Normal
\
n
"
)
)
;
break
;
case
nsSizeMode_Minimized
:
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
SizeMode
:
nsSizeMode_Minimized
\
n
"
)
)
;
break
;
case
nsSizeMode_Maximized
:
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
SizeMode
:
nsSizeMode_Maximized
\
n
"
)
)
;
break
;
default
:
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
SizeMode
:
?
?
?
?
?
?
\
n
"
)
)
;
break
;
}
#
endif
}
static
void
MaybeLogPosChanged
(
HWND
aWnd
WINDOWPOS
*
wp
)
{
#
ifdef
WINSTATE_DEBUG_OUTPUT
if
(
aWnd
=
=
WinUtils
:
:
GetTopLevelHWND
(
aWnd
)
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
OnWindowPosChanged
:
[
top
]
"
)
)
;
}
else
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
OnWindowPosChanged
:
[
child
]
"
)
)
;
}
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
WINDOWPOS
flags
:
"
)
)
;
if
(
wp
-
>
flags
&
SWP_FRAMECHANGED
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
SWP_FRAMECHANGED
"
)
)
;
}
if
(
wp
-
>
flags
&
SWP_SHOWWINDOW
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
SWP_SHOWWINDOW
"
)
)
;
}
if
(
wp
-
>
flags
&
SWP_NOSIZE
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
SWP_NOSIZE
"
)
)
;
}
if
(
wp
-
>
flags
&
SWP_HIDEWINDOW
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
SWP_HIDEWINDOW
"
)
)
;
}
if
(
wp
-
>
flags
&
SWP_NOZORDER
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
SWP_NOZORDER
"
)
)
;
}
if
(
wp
-
>
flags
&
SWP_NOACTIVATE
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
SWP_NOACTIVATE
"
)
)
;
}
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
\
n
"
)
)
;
#
endif
}
void
nsWindow
:
:
OnWindowPosChanged
(
WINDOWPOS
*
wp
)
{
if
(
wp
=
=
nullptr
)
return
;
MaybeLogPosChanged
(
mWnd
wp
)
;
if
(
wp
-
>
flags
&
SWP_FRAMECHANGED
)
{
if
(
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Minimized
&
&
(
wp
-
>
flags
&
SWP_NOACTIVATE
)
)
{
return
;
}
mFrameState
-
>
OnFrameChanged
(
)
;
if
(
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Minimized
)
{
return
;
}
}
if
(
!
(
wp
-
>
flags
&
SWP_NOACTIVATE
)
&
&
NeedsToTrackWindowOcclusionState
(
)
)
{
WinWindowOcclusionTracker
:
:
Get
(
)
-
>
OnWindowVisibilityChanged
(
this
mFrameState
-
>
GetSizeMode
(
)
!
=
nsSizeMode_Minimized
)
;
}
if
(
!
(
wp
-
>
flags
&
SWP_NOMOVE
)
)
{
mBounds
.
MoveTo
(
wp
-
>
x
wp
-
>
y
)
;
NotifyWindowMoved
(
wp
-
>
x
wp
-
>
y
)
;
}
if
(
!
(
wp
-
>
flags
&
SWP_NOSIZE
)
)
{
RECT
r
;
int32_t
newWidth
newHeight
;
:
:
GetWindowRect
(
mWnd
&
r
)
;
newWidth
=
r
.
right
-
r
.
left
;
newHeight
=
r
.
bottom
-
r
.
top
;
if
(
newWidth
>
mLastSize
.
width
)
{
RECT
drect
;
drect
.
left
=
wp
-
>
x
+
mLastSize
.
width
;
drect
.
top
=
wp
-
>
y
;
drect
.
right
=
drect
.
left
+
(
newWidth
-
mLastSize
.
width
)
;
drect
.
bottom
=
drect
.
top
+
newHeight
;
:
:
RedrawWindow
(
mWnd
&
drect
nullptr
RDW_INVALIDATE
|
RDW_NOERASE
|
RDW_NOINTERNALPAINT
|
RDW_ERASENOW
|
RDW_ALLCHILDREN
)
;
}
if
(
newHeight
>
mLastSize
.
height
)
{
RECT
drect
;
drect
.
left
=
wp
-
>
x
;
drect
.
top
=
wp
-
>
y
+
mLastSize
.
height
;
drect
.
right
=
drect
.
left
+
newWidth
;
drect
.
bottom
=
drect
.
top
+
(
newHeight
-
mLastSize
.
height
)
;
:
:
RedrawWindow
(
mWnd
&
drect
nullptr
RDW_INVALIDATE
|
RDW_NOERASE
|
RDW_NOINTERNALPAINT
|
RDW_ERASENOW
|
RDW_ALLCHILDREN
)
;
}
mBounds
.
SizeTo
(
newWidth
newHeight
)
;
mLastSize
.
width
=
newWidth
;
mLastSize
.
height
=
newHeight
;
#
ifdef
WINSTATE_DEBUG_OUTPUT
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
Resize
window
:
%
d
x
%
d
x
%
d
x
%
d
\
n
"
wp
-
>
x
wp
-
>
y
newWidth
newHeight
)
)
;
#
endif
if
(
mAspectRatio
>
0
)
{
float
newAspectRatio
=
(
float
)
newWidth
/
newHeight
;
if
(
mResizeState
=
=
NOT_RESIZING
&
&
mAspectRatio
!
=
newAspectRatio
)
{
nsCOMPtr
<
nsIWidget
>
self
(
this
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
EnforceAspectRatio
"
[
self
this
newWidth
]
(
)
-
>
void
{
if
(
mWnd
)
{
Resize
(
newWidth
newWidth
/
mAspectRatio
true
)
;
}
}
)
)
;
}
}
if
(
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Maximized
)
{
if
(
UpdateNonClientMargins
(
nsSizeMode_Maximized
true
)
)
{
return
;
}
}
}
if
(
!
(
wp
-
>
flags
&
SWP_NOSIZE
)
|
|
(
(
wp
-
>
flags
&
SWP_FRAMECHANGED
)
&
&
!
IsPopup
(
)
)
)
{
RECT
r
;
LayoutDeviceIntSize
clientSize
;
if
(
:
:
GetClientRect
(
mWnd
&
r
)
)
{
clientSize
=
WinUtils
:
:
ToIntRect
(
r
)
.
Size
(
)
;
}
else
{
clientSize
=
mBounds
.
Size
(
)
;
}
OnResize
(
clientSize
)
;
}
}
void
nsWindow
:
:
OnWindowPosChanging
(
LPWINDOWPOS
&
info
)
{
if
(
info
-
>
flags
&
SWP_FRAMECHANGED
&
&
!
(
info
-
>
flags
&
SWP_NOSIZE
)
)
{
mFrameState
-
>
OnFrameChanging
(
)
;
}
if
(
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Fullscreen
&
&
!
(
info
-
>
flags
&
SWP_NOMOVE
)
&
&
!
(
info
-
>
flags
&
SWP_NOSIZE
)
)
{
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
sScreenManagerContractID
)
;
if
(
screenmgr
)
{
LayoutDeviceIntRect
bounds
(
info
-
>
x
info
-
>
y
info
-
>
cx
info
-
>
cy
)
;
DesktopIntRect
deskBounds
=
RoundedToInt
(
bounds
/
GetDesktopToDeviceScale
(
)
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
screenmgr
-
>
ScreenForRect
(
deskBounds
.
X
(
)
deskBounds
.
Y
(
)
deskBounds
.
Width
(
)
deskBounds
.
Height
(
)
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
x
y
width
height
;
screen
-
>
GetRect
(
&
x
&
y
&
width
&
height
)
;
info
-
>
x
=
x
;
info
-
>
y
=
y
;
info
-
>
cx
=
width
;
info
-
>
cy
=
height
;
}
}
}
if
(
!
(
info
-
>
flags
&
SWP_NOZORDER
)
)
{
HWND
hwndAfter
=
info
-
>
hwndInsertAfter
;
nsWindow
*
aboveWindow
=
0
;
nsWindowZ
placement
;
if
(
hwndAfter
=
=
HWND_BOTTOM
)
placement
=
nsWindowZBottom
;
else
if
(
hwndAfter
=
=
HWND_TOP
|
|
hwndAfter
=
=
HWND_TOPMOST
|
|
hwndAfter
=
=
HWND_NOTOPMOST
)
placement
=
nsWindowZTop
;
else
{
placement
=
nsWindowZRelative
;
aboveWindow
=
WinUtils
:
:
GetNSWindowPtr
(
hwndAfter
)
;
}
if
(
mWidgetListener
)
{
nsCOMPtr
<
nsIWidget
>
actualBelow
=
nullptr
;
if
(
mWidgetListener
-
>
ZLevelChanged
(
false
&
placement
aboveWindow
getter_AddRefs
(
actualBelow
)
)
)
{
if
(
placement
=
=
nsWindowZBottom
)
info
-
>
hwndInsertAfter
=
HWND_BOTTOM
;
else
if
(
placement
=
=
nsWindowZTop
)
info
-
>
hwndInsertAfter
=
HWND_TOP
;
else
{
info
-
>
hwndInsertAfter
=
(
HWND
)
actualBelow
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
}
}
}
}
if
(
mWindowType
=
=
eWindowType_invisible
)
info
-
>
flags
&
=
~
SWP_SHOWWINDOW
;
static
bool
sDWMUnhidesPopups
=
IsWin10Sep2018UpdateOrLater
(
)
;
if
(
sDWMUnhidesPopups
&
&
(
info
-
>
flags
&
SWP_SHOWWINDOW
)
&
&
mWindowType
=
=
eWindowType_popup
&
&
mWidgetListener
&
&
mWidgetListener
-
>
ShouldNotBeVisible
(
)
)
{
info
-
>
flags
&
=
~
SWP_SHOWWINDOW
;
}
}
void
nsWindow
:
:
UserActivity
(
)
{
if
(
!
mIdleService
)
{
mIdleService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
)
;
}
if
(
mIdleService
)
{
mIdleService
-
>
ResetIdleTimeOut
(
0
)
;
}
}
static
bool
TouchDeviceNeedsPanGestureConversion
(
HANDLE
aSource
)
{
std
:
:
string
deviceName
;
UINT
dataSize
=
0
;
GetRawInputDeviceInfoA
(
aSource
RIDI_DEVICENAME
nullptr
&
dataSize
)
;
if
(
!
dataSize
|
|
dataSize
>
0x10000
)
{
return
false
;
}
deviceName
.
resize
(
dataSize
)
;
UINT
result
=
GetRawInputDeviceInfoA
(
aSource
RIDI_DEVICENAME
&
deviceName
[
0
]
&
dataSize
)
;
if
(
result
=
=
UINT_MAX
)
{
return
false
;
}
std
:
:
string
expectedDeviceName
=
"
\
\
\
\
?
\
\
VIRTUAL_DIGITIZER
"
;
if
(
deviceName
.
substr
(
0
expectedDeviceName
.
length
(
)
)
!
=
expectedDeviceName
)
{
return
false
;
}
RID_DEVICE_INFO
deviceInfo
;
deviceInfo
.
cbSize
=
sizeof
(
deviceInfo
)
;
dataSize
=
sizeof
(
deviceInfo
)
;
result
=
GetRawInputDeviceInfoA
(
aSource
RIDI_DEVICEINFO
&
deviceInfo
&
dataSize
)
;
if
(
result
=
=
UINT_MAX
)
{
return
false
;
}
return
deviceInfo
.
dwType
=
=
RIM_TYPEHID
&
&
deviceInfo
.
hid
.
dwVendorId
=
=
0
&
&
deviceInfo
.
hid
.
dwProductId
=
=
0
&
&
deviceInfo
.
hid
.
dwVersionNumber
=
=
1
&
&
deviceInfo
.
hid
.
usUsagePage
=
=
13
&
&
deviceInfo
.
hid
.
usUsage
=
=
4
;
}
static
bool
TouchDeviceNeedsPanGestureConversion
(
PTOUCHINPUT
aOSEvent
uint32_t
aTouchCount
)
{
if
(
!
StaticPrefs
:
:
apz_windows_check_for_pan_gesture_conversion
(
)
)
{
return
false
;
}
if
(
aTouchCount
=
=
0
)
{
return
false
;
}
HANDLE
source
=
aOSEvent
[
0
]
.
hSource
;
static
std
:
:
map
<
HANDLE
bool
>
sResultCache
;
auto
[
iter
inserted
]
=
sResultCache
.
emplace
(
source
false
)
;
if
(
inserted
)
{
iter
-
>
second
=
TouchDeviceNeedsPanGestureConversion
(
source
)
;
}
return
iter
-
>
second
;
}
Maybe
<
PanGestureInput
>
nsWindow
:
:
ConvertTouchToPanGesture
(
const
MultiTouchInput
&
aTouchInput
PTOUCHINPUT
aOSEvent
)
{
bool
shouldConvert
=
TouchDeviceNeedsPanGestureConversion
(
aOSEvent
aTouchInput
.
mTouches
.
Length
(
)
)
;
if
(
!
shouldConvert
)
{
return
Nothing
(
)
;
}
if
(
aTouchInput
.
mTouches
.
Length
(
)
!
=
2
)
{
return
Nothing
(
)
;
}
PanGestureInput
:
:
PanGestureType
eventType
=
PanGestureInput
:
:
PANGESTURE_PAN
;
if
(
aTouchInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_START
)
{
eventType
=
PanGestureInput
:
:
PANGESTURE_START
;
}
else
if
(
aTouchInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_END
)
{
eventType
=
PanGestureInput
:
:
PANGESTURE_END
;
}
else
if
(
aTouchInput
.
mType
=
=
MultiTouchInput
:
:
MULTITOUCH_CANCEL
)
{
eventType
=
PanGestureInput
:
:
PANGESTURE_CANCELLED
;
}
ScreenPoint
focusPoint
=
(
aTouchInput
.
mTouches
[
0
]
.
mScreenPoint
+
aTouchInput
.
mTouches
[
1
]
.
mScreenPoint
)
/
2
;
ScreenPoint
displacement
=
(
eventType
=
=
PanGestureInput
:
:
PANGESTURE_START
)
?
ScreenPoint
(
0
0
)
:
(
focusPoint
-
mLastPanGestureFocus
)
;
mLastPanGestureFocus
=
focusPoint
;
PanGestureInput
result
(
eventType
aTouchInput
.
mTime
aTouchInput
.
mTimeStamp
focusPoint
-
displacement
aTouchInput
.
modifiers
)
;
result
.
mSimulateMomentum
=
true
;
return
Some
(
result
)
;
}
void
nsWindow
:
:
DispatchTouchOrPanGestureInput
(
MultiTouchInput
&
aTouchInput
PTOUCHINPUT
aOSEvent
)
{
if
(
Maybe
<
PanGestureInput
>
panInput
=
ConvertTouchToPanGesture
(
aTouchInput
aOSEvent
)
)
{
DispatchPanGestureInput
(
*
panInput
)
;
return
;
}
DispatchTouchInput
(
aTouchInput
)
;
}
bool
nsWindow
:
:
OnTouch
(
WPARAM
wParam
LPARAM
lParam
)
{
uint32_t
cInputs
=
LOWORD
(
wParam
)
;
PTOUCHINPUT
pInputs
=
new
TOUCHINPUT
[
cInputs
]
;
if
(
GetTouchInputInfo
(
(
HTOUCHINPUT
)
lParam
cInputs
pInputs
sizeof
(
TOUCHINPUT
)
)
)
{
MultiTouchInput
touchInput
touchEndInput
;
for
(
uint32_t
i
=
0
;
i
<
cInputs
;
i
+
+
)
{
bool
addToEvent
=
false
addToEndEvent
=
false
;
if
(
pInputs
[
i
]
.
dwFlags
&
(
TOUCHEVENTF_DOWN
|
TOUCHEVENTF_MOVE
)
)
{
if
(
touchInput
.
mTimeStamp
.
IsNull
(
)
)
{
touchInput
.
mType
=
MultiTouchInput
:
:
MULTITOUCH_MOVE
;
touchInput
.
mTime
=
:
:
GetMessageTime
(
)
;
touchInput
.
mTimeStamp
=
GetMessageTimeStamp
(
touchInput
.
mTime
)
;
ModifierKeyState
modifierKeyState
;
touchInput
.
modifiers
=
modifierKeyState
.
GetModifiers
(
)
;
}
if
(
pInputs
[
i
]
.
dwFlags
&
TOUCHEVENTF_DOWN
)
{
touchInput
.
mType
=
MultiTouchInput
:
:
MULTITOUCH_START
;
}
addToEvent
=
true
;
}
if
(
pInputs
[
i
]
.
dwFlags
&
TOUCHEVENTF_UP
)
{
if
(
touchEndInput
.
mTimeStamp
.
IsNull
(
)
)
{
touchEndInput
.
mType
=
MultiTouchInput
:
:
MULTITOUCH_END
;
touchEndInput
.
mTime
=
:
:
GetMessageTime
(
)
;
touchEndInput
.
mTimeStamp
=
GetMessageTimeStamp
(
touchEndInput
.
mTime
)
;
ModifierKeyState
modifierKeyState
;
touchEndInput
.
modifiers
=
modifierKeyState
.
GetModifiers
(
)
;
}
addToEndEvent
=
true
;
}
if
(
!
addToEvent
&
&
!
addToEndEvent
)
{
continue
;
}
nsPointWin
touchPoint
;
touchPoint
.
x
=
TOUCH_COORD_TO_PIXEL
(
pInputs
[
i
]
.
x
)
;
touchPoint
.
y
=
TOUCH_COORD_TO_PIXEL
(
pInputs
[
i
]
.
y
)
;
touchPoint
.
ScreenToClient
(
mWnd
)
;
SingleTouchData
touchData
(
pInputs
[
i
]
.
dwID
ScreenIntPoint
:
:
FromUnknownPoint
(
touchPoint
)
(
pInputs
[
i
]
.
dwMask
&
TOUCHINPUTMASKF_CONTACTAREA
)
&
&
!
(
pInputs
[
i
]
.
dwFlags
&
TOUCHEVENTF_PEN
)
?
ScreenSize
(
TOUCH_COORD_TO_PIXEL
(
pInputs
[
i
]
.
cxContact
)
/
2
TOUCH_COORD_TO_PIXEL
(
pInputs
[
i
]
.
cyContact
)
/
2
)
:
ScreenSize
(
1
1
)
0
.
0f
0
.
0f
)
;
if
(
addToEvent
)
{
touchInput
.
mTouches
.
AppendElement
(
touchData
)
;
}
if
(
addToEndEvent
)
{
touchEndInput
.
mTouches
.
AppendElement
(
touchData
)
;
}
}
if
(
!
touchInput
.
mTimeStamp
.
IsNull
(
)
)
{
DispatchTouchOrPanGestureInput
(
touchInput
pInputs
)
;
}
if
(
!
touchEndInput
.
mTimeStamp
.
IsNull
(
)
)
{
DispatchTouchOrPanGestureInput
(
touchEndInput
pInputs
)
;
}
}
delete
[
]
pInputs
;
CloseTouchInputHandle
(
(
HTOUCHINPUT
)
lParam
)
;
return
true
;
}
bool
nsWindow
:
:
OnGesture
(
WPARAM
wParam
LPARAM
lParam
)
{
if
(
mGesture
.
IsPanEvent
(
lParam
)
)
{
if
(
!
mGesture
.
ProcessPanMessage
(
mWnd
wParam
lParam
)
)
return
false
;
nsEventStatus
status
;
WidgetWheelEvent
wheelEvent
(
true
eWheel
this
)
;
ModifierKeyState
modifierKeyState
;
modifierKeyState
.
InitInputEvent
(
wheelEvent
)
;
wheelEvent
.
mButton
=
0
;
wheelEvent
.
mTime
=
:
:
GetMessageTime
(
)
;
wheelEvent
.
mTimeStamp
=
GetMessageTimeStamp
(
wheelEvent
.
mTime
)
;
wheelEvent
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
bool
endFeedback
=
true
;
if
(
mGesture
.
PanDeltaToPixelScroll
(
wheelEvent
)
)
{
DispatchEvent
(
&
wheelEvent
status
)
;
}
if
(
mDisplayPanFeedback
)
{
mGesture
.
UpdatePanFeedbackX
(
mWnd
DeprecatedAbs
(
RoundDown
(
wheelEvent
.
mOverflowDeltaX
)
)
endFeedback
)
;
mGesture
.
UpdatePanFeedbackY
(
mWnd
DeprecatedAbs
(
RoundDown
(
wheelEvent
.
mOverflowDeltaY
)
)
endFeedback
)
;
mGesture
.
PanFeedbackFinalize
(
mWnd
endFeedback
)
;
}
CloseGestureInfoHandle
(
(
HGESTUREINFO
)
lParam
)
;
return
true
;
}
WidgetSimpleGestureEvent
event
(
true
eVoidEvent
this
)
;
if
(
!
mGesture
.
ProcessGestureMessage
(
mWnd
wParam
lParam
event
)
)
{
return
false
;
}
ModifierKeyState
modifierKeyState
;
modifierKeyState
.
InitInputEvent
(
event
)
;
event
.
mButton
=
0
;
event
.
mTime
=
:
:
GetMessageTime
(
)
;
event
.
mTimeStamp
=
GetMessageTimeStamp
(
event
.
mTime
)
;
event
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
nsEventStatus
status
;
DispatchEvent
(
&
event
status
)
;
if
(
status
=
=
nsEventStatus_eIgnore
)
{
return
false
;
}
CloseGestureInfoHandle
(
(
HGESTUREINFO
)
lParam
)
;
return
true
;
}
void
nsWindow
:
:
OnDestroy
(
)
{
mOnDestroyCalled
=
true
;
if
(
!
mParent
)
{
TaskbarConcealer
:
:
OnWindowDestroyed
(
mWnd
)
;
}
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
if
(
!
mInDtor
)
NotifyWindowDestroyed
(
)
;
mWidgetListener
=
nullptr
;
mAttachedWidgetListener
=
nullptr
;
DestroyDirectManipulation
(
)
;
if
(
mWnd
=
=
mLastKillFocusWindow
)
{
mLastKillFocusWindow
=
nullptr
;
}
:
:
WTSUnRegisterSessionNotification
(
mWnd
)
;
DissociateFromNativeWindow
(
)
;
if
(
sCurrentWindow
=
=
this
)
sCurrentWindow
=
nullptr
;
nsBaseWidget
:
:
Destroy
(
)
;
nsBaseWidget
:
:
OnDestroy
(
)
;
mParent
=
nullptr
;
EnableDragDrop
(
false
)
;
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
nsCOMPtr
<
nsIWidget
>
rollupWidget
;
if
(
rollupListener
)
{
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
}
if
(
this
=
=
rollupWidget
)
{
if
(
rollupListener
)
rollupListener
-
>
Rollup
(
0
false
nullptr
nullptr
)
;
CaptureRollupEvents
(
nullptr
false
)
;
}
IMEHandler
:
:
OnDestroyWindow
(
this
)
;
if
(
mBrush
)
{
VERIFY
(
:
:
DeleteObject
(
mBrush
)
)
;
mBrush
=
nullptr
;
}
if
(
mCursor
.
IsCustom
(
)
)
{
SetCursor
(
Cursor
{
eCursor_standard
}
)
;
}
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
OnDestroyWindow
(
)
;
}
mBasicLayersSurface
=
nullptr
;
mGesture
.
PanFeedbackFinalize
(
mWnd
true
)
;
mWnd
=
nullptr
;
}
bool
nsWindow
:
:
OnResize
(
const
LayoutDeviceIntSize
&
aSize
)
{
if
(
mCompositorWidgetDelegate
&
&
!
mCompositorWidgetDelegate
-
>
OnWindowResize
(
aSize
)
)
{
return
false
;
}
bool
result
=
false
;
if
(
mWidgetListener
)
{
result
=
mWidgetListener
-
>
WindowResized
(
this
aSize
.
width
aSize
.
height
)
;
}
if
(
mAttachedWidgetListener
)
{
return
mAttachedWidgetListener
-
>
WindowResized
(
this
aSize
.
width
aSize
.
height
)
;
}
return
result
;
}
void
nsWindow
:
:
OnSizeModeChange
(
nsSizeMode
aSizeMode
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
nsWindow
:
:
OnSizeModeChange
(
)
aSizeMode
%
d
"
aSizeMode
)
)
;
if
(
NeedsToTrackWindowOcclusionState
(
)
)
{
WinWindowOcclusionTracker
:
:
Get
(
)
-
>
OnWindowVisibilityChanged
(
this
aSizeMode
!
=
nsSizeMode_Minimized
)
;
wr
:
:
DebugFlags
flags
{
0
}
;
flags
.
bits
=
gfx
:
:
gfxVars
:
:
WebRenderDebugFlags
(
)
;
bool
debugEnabled
=
bool
(
flags
&
wr
:
:
DebugFlags
:
:
WINDOW_VISIBILITY_DBG
)
;
if
(
debugEnabled
&
&
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
NotifyVisibilityUpdated
(
aSizeMode
mIsFullyOccluded
)
;
}
}
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
OnWindowModeChange
(
aSizeMode
)
;
}
if
(
mWidgetListener
)
{
mWidgetListener
-
>
SizeModeChanged
(
aSizeMode
)
;
}
}
bool
nsWindow
:
:
OnHotKey
(
WPARAM
wParam
LPARAM
lParam
)
{
return
true
;
}
bool
nsWindow
:
:
AutoErase
(
HDC
dc
)
{
return
false
;
}
bool
nsWindow
:
:
IsPopup
(
)
{
return
mWindowType
=
=
eWindowType_popup
;
}
bool
nsWindow
:
:
ShouldUseOffMainThreadCompositing
(
)
{
if
(
mWindowType
=
=
eWindowType_popup
&
&
mPopupType
=
=
ePopupTypeTooltip
)
{
return
false
;
}
if
(
mWindowType
=
=
eWindowType_popup
&
&
!
mIsChildWindow
)
{
MOZ_ASSERT
(
!
mParent
)
;
return
false
;
}
return
nsBaseWidget
:
:
ShouldUseOffMainThreadCompositing
(
)
;
}
void
nsWindow
:
:
WindowUsesOMTC
(
)
{
ULONG_PTR
style
=
:
:
GetClassLongPtr
(
mWnd
GCL_STYLE
)
;
if
(
!
style
)
{
NS_WARNING
(
"
Could
not
get
window
class
style
"
)
;
return
;
}
style
|
=
CS_HREDRAW
|
CS_VREDRAW
;
DebugOnly
<
ULONG_PTR
>
result
=
:
:
SetClassLongPtr
(
mWnd
GCL_STYLE
style
)
;
NS_WARNING_ASSERTION
(
result
"
Could
not
reset
window
class
style
"
)
;
}
bool
nsWindow
:
:
HasBogusPopupsDropShadowOnMultiMonitor
(
)
{
static
const
bool
sHasBogusPopupsDropShadowOnMultiMonitor
=
[
]
{
if
(
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
IsDirect2DBackend
(
)
)
{
return
true
;
}
if
(
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
HW_COMPOSITING
)
&
&
!
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
OPENGL_COMPOSITING
)
)
{
nsCOMPtr
<
nsIGfxInfo
>
gfxInfo
=
components
:
:
GfxInfo
:
:
Service
(
)
;
if
(
gfxInfo
)
{
int32_t
status
;
nsCString
discardFailureId
;
if
(
NS_SUCCEEDED
(
gfxInfo
-
>
GetFeatureStatus
(
nsIGfxInfo
:
:
FEATURE_DIRECT3D_9_LAYERS
discardFailureId
&
status
)
)
)
{
if
(
status
=
=
nsIGfxInfo
:
:
FEATURE_STATUS_OK
|
|
gfxConfig
:
:
IsForcedOnByUser
(
gfx
:
:
Feature
:
:
HW_COMPOSITING
)
)
{
return
true
;
}
}
}
}
return
false
;
}
(
)
;
return
sHasBogusPopupsDropShadowOnMultiMonitor
;
}
void
nsWindow
:
:
OnDPIChanged
(
int32_t
x
int32_t
y
int32_t
width
int32_t
height
)
{
if
(
mWindowType
=
=
eWindowType_popup
)
{
return
;
}
if
(
StaticPrefs
:
:
layout_css_devPixelsPerPx
(
)
>
0
.
0
)
{
return
;
}
mDefaultScale
=
-
1
.
0
;
if
(
mResizeState
!
=
RESIZING
&
&
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Normal
)
{
nsCOMPtr
<
nsIScreenManager
>
sm
=
do_GetService
(
sScreenManagerContractID
)
;
if
(
sm
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
sm
-
>
ScreenForRect
(
x
y
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
availLeft
availTop
availWidth
availHeight
;
screen
-
>
GetAvailRect
(
&
availLeft
&
availTop
&
availWidth
&
availHeight
)
;
if
(
mResizeState
!
=
MOVING
)
{
x
=
std
:
:
max
(
x
availLeft
)
;
y
=
std
:
:
max
(
y
availTop
)
;
}
width
=
std
:
:
min
(
width
availWidth
)
;
height
=
std
:
:
min
(
height
availHeight
)
;
}
}
Resize
(
x
y
width
height
true
)
;
}
UpdateNonClientMargins
(
)
;
ChangedDPI
(
)
;
ResetLayout
(
)
;
}
void
nsWindow
:
:
OnCloakEvent
(
HWND
aWnd
bool
aCloaked
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsWin8OrLater
(
)
)
;
const
char
*
const
kEventName
=
aCloaked
?
"
CLOAKED
"
:
"
UNCLOAKED
"
;
nsWindow
*
pWin
=
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
if
(
!
pWin
)
{
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Debug
(
"
Received
%
s
event
for
HWND
%
p
(
not
an
nsWindow
)
"
kEventName
aWnd
)
)
;
return
;
}
const
char
*
const
kWasCloakedStr
=
pWin
-
>
mIsCloaked
?
"
cloaked
"
:
"
uncloaked
"
;
if
(
mozilla
:
:
IsCloaked
(
aWnd
)
=
=
pWin
-
>
mIsCloaked
)
{
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Debug
(
"
Received
redundant
%
s
event
for
%
s
HWND
%
p
;
discarding
"
kEventName
kWasCloakedStr
aWnd
)
)
;
return
;
}
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Info
(
"
Received
%
s
event
for
%
s
HWND
%
p
"
kEventName
kWasCloakedStr
aWnd
)
)
;
struct
Item
{
nsWindow
*
win
;
bool
nowCloaked
;
}
;
nsTArray
<
Item
>
changedWindows
;
mozilla
:
:
EnumerateThreadWindows
(
[
&
]
(
HWND
hwnd
)
{
nsWindow
*
pWin
=
WinUtils
:
:
GetNSWindowPtr
(
hwnd
)
;
if
(
!
pWin
)
{
return
;
}
const
bool
isCloaked
=
mozilla
:
:
IsCloaked
(
hwnd
)
;
if
(
isCloaked
!
=
pWin
-
>
mIsCloaked
)
{
changedWindows
.
AppendElement
(
Item
{
pWin
isCloaked
}
)
;
}
}
)
;
if
(
changedWindows
.
IsEmpty
(
)
)
{
return
;
}
for
(
const
Item
&
item
:
changedWindows
)
{
item
.
win
-
>
OnCloakChanged
(
item
.
nowCloaked
)
;
}
nsWindow
:
:
TaskbarConcealer
:
:
OnCloakChanged
(
)
;
}
void
nsWindow
:
:
OnCloakChanged
(
bool
aCloaked
)
{
MOZ_LOG
(
sCloakingLog
LogLevel
:
:
Info
(
"
Calling
OnCloakChanged
(
)
:
HWND
%
p
aCloaked
%
s
"
mWnd
aCloaked
?
"
true
"
:
"
false
"
)
)
;
mIsCloaked
=
aCloaked
;
}
void
nsWindow
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
InputContext
newInputContext
=
aContext
;
IMEHandler
:
:
SetInputContext
(
this
newInputContext
aAction
)
;
mInputContext
=
newInputContext
;
}
InputContext
nsWindow
:
:
GetInputContext
(
)
{
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
CLOSED
;
if
(
WinUtils
:
:
IsIMEEnabled
(
mInputContext
)
&
&
IMEHandler
:
:
GetOpenState
(
this
)
)
{
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
OPEN
;
}
else
{
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
CLOSED
;
}
return
mInputContext
;
}
TextEventDispatcherListener
*
nsWindow
:
:
GetNativeTextEventDispatcherListener
(
)
{
return
IMEHandler
:
:
GetNativeTextEventDispatcherListener
(
)
;
}
#
ifdef
ACCESSIBILITY
#
ifdef
DEBUG
#
define
NS_LOG_WMGETOBJECT
(
aWnd
aHwnd
aAcc
)
\
if
(
a11y
:
:
logging
:
:
IsEnabled
(
a11y
:
:
logging
:
:
ePlatforms
)
)
{
\
printf
(
\
"
Get
the
window
:
\
n
{
\
n
HWND
:
%
p
parent
HWND
:
%
p
wndobj
:
"
\
"
%
p
\
n
"
\
aHwnd
:
:
GetParent
(
aHwnd
)
aWnd
)
;
\
printf
(
"
acc
:
%
p
"
aAcc
)
;
\
if
(
aAcc
)
{
\
nsAutoString
name
;
\
aAcc
-
>
Name
(
name
)
;
\
printf
(
"
accname
:
%
s
"
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
)
;
\
}
\
printf
(
"
\
n
}
\
n
"
)
;
\
}
#
else
#
define
NS_LOG_WMGETOBJECT
(
aWnd
aHwnd
aAcc
)
#
endif
a11y
:
:
LocalAccessible
*
nsWindow
:
:
GetAccessible
(
)
{
if
(
a11y
:
:
PlatformDisabledState
(
)
=
=
a11y
:
:
ePlatformIsDisabled
)
return
nullptr
;
if
(
mInDtor
|
|
mOnDestroyCalled
|
|
mWindowType
=
=
eWindowType_invisible
)
{
return
nullptr
;
}
nsView
*
view
=
nsView
:
:
GetViewFor
(
this
)
;
if
(
view
)
{
nsIFrame
*
frame
=
view
-
>
GetFrame
(
)
;
if
(
frame
&
&
nsLayoutUtils
:
:
IsPopup
(
frame
)
)
{
nsAccessibilityService
*
accService
=
GetOrCreateAccService
(
)
;
if
(
accService
)
{
a11y
:
:
DocAccessible
*
docAcc
=
GetAccService
(
)
-
>
GetDocAccessible
(
frame
-
>
PresShell
(
)
)
;
if
(
docAcc
)
{
NS_LOG_WMGETOBJECT
(
this
mWnd
docAcc
-
>
GetAccessibleOrDescendant
(
frame
-
>
GetContent
(
)
)
)
;
return
docAcc
-
>
GetAccessibleOrDescendant
(
frame
-
>
GetContent
(
)
)
;
}
}
}
}
NS_LOG_WMGETOBJECT
(
this
mWnd
GetRootAccessible
(
)
)
;
return
GetRootAccessible
(
)
;
}
#
endif
void
nsWindow
:
:
SetWindowTranslucencyInner
(
nsTransparencyMode
aMode
)
{
if
(
aMode
=
=
mTransparencyMode
)
return
;
HWND
hWnd
=
WinUtils
:
:
GetTopLevelHWND
(
mWnd
true
)
;
nsWindow
*
parent
=
WinUtils
:
:
GetNSWindowPtr
(
hWnd
)
;
if
(
!
parent
)
{
NS_WARNING
(
"
Trying
to
use
transparent
chrome
in
an
embedded
context
"
)
;
return
;
}
if
(
parent
!
=
this
)
{
NS_WARNING
(
"
Setting
SetWindowTranslucencyInner
on
a
parent
this
is
not
us
!
"
)
;
}
if
(
aMode
=
=
eTransparencyTransparent
)
{
HideWindowChrome
(
true
)
;
}
else
if
(
mHideChrome
&
&
mTransparencyMode
=
=
eTransparencyTransparent
)
{
HideWindowChrome
(
false
)
;
}
LONG_PTR
style
=
:
:
GetWindowLongPtrW
(
hWnd
GWL_STYLE
)
exStyle
=
:
:
GetWindowLongPtr
(
hWnd
GWL_EXSTYLE
)
;
if
(
parent
-
>
mIsVisible
)
{
style
|
=
WS_VISIBLE
;
if
(
parent
-
>
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Maximized
)
{
style
|
=
WS_MAXIMIZE
;
}
else
if
(
parent
-
>
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Minimized
)
{
style
|
=
WS_MINIMIZE
;
}
}
if
(
aMode
=
=
eTransparencyTransparent
)
exStyle
|
=
WS_EX_LAYERED
;
else
exStyle
&
=
~
WS_EX_LAYERED
;
VERIFY_WINDOW_STYLE
(
style
)
;
:
:
SetWindowLongPtrW
(
hWnd
GWL_STYLE
style
)
;
:
:
SetWindowLongPtrW
(
hWnd
GWL_EXSTYLE
exStyle
)
;
if
(
HasGlass
(
)
)
memset
(
&
mGlassMargins
0
sizeof
mGlassMargins
)
;
mTransparencyMode
=
aMode
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
UpdateTransparency
(
aMode
)
;
}
UpdateGlass
(
)
;
if
(
HasGlass
(
)
&
&
GetWindowRenderer
(
)
-
>
AsKnowsCompositor
(
)
&
&
GetWindowRenderer
(
)
-
>
AsKnowsCompositor
(
)
-
>
GetUseCompositorWnd
(
)
)
{
HDC
hdc
;
RECT
rect
;
hdc
=
:
:
GetWindowDC
(
mWnd
)
;
:
:
GetWindowRect
(
mWnd
&
rect
)
;
:
:
MapWindowPoints
(
nullptr
mWnd
(
LPPOINT
)
&
rect
2
)
;
:
:
FillRect
(
hdc
&
rect
reinterpret_cast
<
HBRUSH
>
(
GetStockObject
(
BLACK_BRUSH
)
)
)
;
ReleaseDC
(
mWnd
hdc
)
;
}
if
(
HasGlass
(
)
&
&
!
gfxVars
:
:
UseWebRender
(
)
&
&
gfxVars
:
:
UseDoubleBufferingWithCompositor
(
)
)
{
gfxVars
:
:
SetUseDoubleBufferingWithCompositor
(
false
)
;
GPUProcessManager
:
:
Get
(
)
-
>
ResetCompositors
(
)
;
}
}
void
nsWindow
:
:
ScheduleHookTimer
(
HWND
aWnd
UINT
aMsgId
)
{
if
(
sHookTimerId
=
=
0
)
{
sRollupMsgId
=
aMsgId
;
sRollupMsgWnd
=
aWnd
;
sHookTimerId
=
:
:
SetTimer
(
nullptr
0
0
(
TIMERPROC
)
HookTimerForPopups
)
;
NS_ASSERTION
(
sHookTimerId
"
Timer
couldn
'
t
be
created
.
"
)
;
}
}
#
ifdef
POPUP_ROLLUP_DEBUG_OUTPUT
int
gLastMsgCode
=
0
;
extern
MSGFEventMsgInfo
gMSGFEvents
[
]
;
#
endif
LRESULT
CALLBACK
nsWindow
:
:
MozSpecialMsgFilter
(
int
code
WPARAM
wParam
LPARAM
lParam
)
{
#
ifdef
POPUP_ROLLUP_DEBUG_OUTPUT
if
(
sProcessHook
)
{
MSG
*
pMsg
=
(
MSG
*
)
lParam
;
int
inx
=
0
;
while
(
gMSGFEvents
[
inx
]
.
mId
!
=
code
&
&
gMSGFEvents
[
inx
]
.
mStr
!
=
nullptr
)
{
inx
+
+
;
}
if
(
code
!
=
gLastMsgCode
)
{
if
(
gMSGFEvents
[
inx
]
.
mId
=
=
code
)
{
#
ifdef
DEBUG
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
MozSpecialMessageProc
-
code
:
0x
%
X
-
%
s
hw
:
%
p
\
n
"
code
gMSGFEvents
[
inx
]
.
mStr
pMsg
-
>
hwnd
)
)
;
#
endif
}
else
{
#
ifdef
DEBUG
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
MozSpecialMessageProc
-
code
:
0x
%
X
-
%
d
hw
:
%
p
\
n
"
code
gMSGFEvents
[
inx
]
.
mId
pMsg
-
>
hwnd
)
)
;
#
endif
}
gLastMsgCode
=
code
;
}
PrintEvent
(
pMsg
-
>
message
FALSE
FALSE
)
;
}
#
endif
if
(
sProcessHook
&
&
code
=
=
MSGF_MENU
)
{
MSG
*
pMsg
=
(
MSG
*
)
lParam
;
ScheduleHookTimer
(
pMsg
-
>
hwnd
pMsg
-
>
message
)
;
}
return
:
:
CallNextHookEx
(
sMsgFilterHook
code
wParam
lParam
)
;
}
LRESULT
CALLBACK
nsWindow
:
:
MozSpecialMouseProc
(
int
code
WPARAM
wParam
LPARAM
lParam
)
{
if
(
sProcessHook
)
{
switch
(
WinUtils
:
:
GetNativeMessage
(
wParam
)
)
{
case
WM_LBUTTONDOWN
:
case
WM_RBUTTONDOWN
:
case
WM_MBUTTONDOWN
:
case
WM_MOUSEWHEEL
:
case
WM_MOUSEHWHEEL
:
{
MOUSEHOOKSTRUCT
*
ms
=
(
MOUSEHOOKSTRUCT
*
)
lParam
;
nsIWidget
*
mozWin
=
WinUtils
:
:
GetNSWindowPtr
(
ms
-
>
hwnd
)
;
if
(
!
mozWin
)
{
ScheduleHookTimer
(
ms
-
>
hwnd
(
UINT
)
wParam
)
;
}
break
;
}
}
}
return
:
:
CallNextHookEx
(
sCallMouseHook
code
wParam
lParam
)
;
}
LRESULT
CALLBACK
nsWindow
:
:
MozSpecialWndProc
(
int
code
WPARAM
wParam
LPARAM
lParam
)
{
#
ifdef
POPUP_ROLLUP_DEBUG_OUTPUT
if
(
sProcessHook
)
{
CWPSTRUCT
*
cwpt
=
(
CWPSTRUCT
*
)
lParam
;
PrintEvent
(
cwpt
-
>
message
FALSE
FALSE
)
;
}
#
endif
if
(
sProcessHook
)
{
CWPSTRUCT
*
cwpt
=
(
CWPSTRUCT
*
)
lParam
;
if
(
cwpt
-
>
message
=
=
WM_MOVING
|
|
cwpt
-
>
message
=
=
WM_SIZING
|
|
cwpt
-
>
message
=
=
WM_GETMINMAXINFO
)
{
ScheduleHookTimer
(
cwpt
-
>
hwnd
(
UINT
)
cwpt
-
>
message
)
;
}
}
return
:
:
CallNextHookEx
(
sCallProcHook
code
wParam
lParam
)
;
}
void
nsWindow
:
:
RegisterSpecialDropdownHooks
(
)
{
NS_ASSERTION
(
!
sMsgFilterHook
"
sMsgFilterHook
must
be
NULL
!
"
)
;
NS_ASSERTION
(
!
sCallProcHook
"
sCallProcHook
must
be
NULL
!
"
)
;
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
Installing
Msg
Hooks
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
;
if
(
!
sMsgFilterHook
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
Hooking
sMsgFilterHook
!
\
n
"
)
;
sMsgFilterHook
=
SetWindowsHookEx
(
WH_MSGFILTER
MozSpecialMsgFilter
nullptr
GetCurrentThreadId
(
)
)
;
#
ifdef
POPUP_ROLLUP_DEBUG_OUTPUT
if
(
!
sMsgFilterHook
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
*
*
SetWindowsHookEx
is
NOT
installed
for
WH_MSGFILTER
!
\
n
"
)
)
;
}
#
endif
}
if
(
!
sCallProcHook
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
Hooking
sCallProcHook
!
\
n
"
)
;
sCallProcHook
=
SetWindowsHookEx
(
WH_CALLWNDPROC
MozSpecialWndProc
nullptr
GetCurrentThreadId
(
)
)
;
#
ifdef
POPUP_ROLLUP_DEBUG_OUTPUT
if
(
!
sCallProcHook
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
*
*
SetWindowsHookEx
is
NOT
installed
for
WH_CALLWNDPROC
!
\
n
"
)
)
;
}
#
endif
}
if
(
!
sCallMouseHook
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
Hooking
sCallMouseHook
!
\
n
"
)
;
sCallMouseHook
=
SetWindowsHookEx
(
WH_MOUSE
MozSpecialMouseProc
nullptr
GetCurrentThreadId
(
)
)
;
#
ifdef
POPUP_ROLLUP_DEBUG_OUTPUT
if
(
!
sCallMouseHook
)
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
*
*
*
*
*
SetWindowsHookEx
is
NOT
installed
for
WH_MOUSE
!
\
n
"
)
)
;
}
#
endif
}
}
void
nsWindow
:
:
UnregisterSpecialDropdownHooks
(
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
De
-
installing
Msg
Hooks
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
;
if
(
sCallProcHook
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
Unhooking
sCallProcHook
!
\
n
"
)
;
if
(
!
:
:
UnhookWindowsHookEx
(
sCallProcHook
)
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
UnhookWindowsHookEx
failed
for
sCallProcHook
!
\
n
"
)
;
}
sCallProcHook
=
nullptr
;
}
if
(
sMsgFilterHook
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
Unhooking
sMsgFilterHook
!
\
n
"
)
;
if
(
!
:
:
UnhookWindowsHookEx
(
sMsgFilterHook
)
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
UnhookWindowsHookEx
failed
for
sMsgFilterHook
!
\
n
"
)
;
}
sMsgFilterHook
=
nullptr
;
}
if
(
sCallMouseHook
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
Unhooking
sCallMouseHook
!
\
n
"
)
;
if
(
!
:
:
UnhookWindowsHookEx
(
sCallMouseHook
)
)
{
DISPLAY_NMM_PRT
(
"
*
*
*
*
*
UnhookWindowsHookEx
failed
for
sCallMouseHook
!
\
n
"
)
;
}
sCallMouseHook
=
nullptr
;
}
}
VOID
CALLBACK
nsWindow
:
:
HookTimerForPopups
(
HWND
hwnd
UINT
uMsg
UINT
idEvent
DWORD
dwTime
)
{
if
(
sHookTimerId
!
=
0
)
{
DebugOnly
<
BOOL
>
status
=
:
:
KillTimer
(
nullptr
sHookTimerId
)
;
NS_ASSERTION
(
status
"
Hook
Timer
was
not
killed
.
"
)
;
sHookTimerId
=
0
;
}
if
(
sRollupMsgId
!
=
0
)
{
LRESULT
popupHandlingResult
;
nsAutoRollup
autoRollup
;
DealWithPopups
(
sRollupMsgWnd
sRollupMsgId
0
0
&
popupHandlingResult
)
;
sRollupMsgId
=
0
;
sRollupMsgWnd
=
nullptr
;
}
}
static
bool
IsDifferentThreadWindow
(
HWND
aWnd
)
{
return
:
:
GetCurrentThreadId
(
)
!
=
:
:
GetWindowThreadProcessId
(
aWnd
nullptr
)
;
}
bool
nsWindow
:
:
EventIsInsideWindow
(
nsWindow
*
aWindow
Maybe
<
POINT
>
aEventPoint
)
{
RECT
r
;
:
:
GetWindowRect
(
aWindow
-
>
mWnd
&
r
)
;
POINT
mp
;
if
(
aEventPoint
)
{
mp
=
*
aEventPoint
;
}
else
{
DWORD
pos
=
:
:
GetMessagePos
(
)
;
mp
.
x
=
GET_X_LPARAM
(
pos
)
;
mp
.
y
=
GET_Y_LPARAM
(
pos
)
;
}
auto
margin
=
aWindow
-
>
mInputRegion
.
mMargin
;
if
(
margin
>
0
)
{
r
.
top
+
=
margin
;
r
.
bottom
-
=
margin
;
r
.
left
+
=
margin
;
r
.
right
-
=
margin
;
}
return
static_cast
<
bool
>
(
:
:
PtInRect
(
&
r
mp
)
)
;
}
bool
nsWindow
:
:
GetPopupsToRollup
(
nsIRollupListener
*
aRollupListener
uint32_t
*
aPopupsToRollup
Maybe
<
POINT
>
aEventPoint
)
{
*
aPopupsToRollup
=
UINT32_MAX
;
AutoTArray
<
nsIWidget
*
5
>
widgetChain
;
uint32_t
sameTypeCount
=
aRollupListener
-
>
GetSubmenuWidgetChain
(
&
widgetChain
)
;
for
(
uint32_t
i
=
0
;
i
<
widgetChain
.
Length
(
)
;
+
+
i
)
{
nsIWidget
*
widget
=
widgetChain
[
i
]
;
if
(
EventIsInsideWindow
(
static_cast
<
nsWindow
*
>
(
widget
)
aEventPoint
)
)
{
if
(
i
<
sameTypeCount
)
{
return
false
;
}
*
aPopupsToRollup
=
sameTypeCount
;
break
;
}
}
return
true
;
}
bool
nsWindow
:
:
NeedsToHandleNCActivateDelayed
(
HWND
aWnd
)
{
nsWindow
*
window
=
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
return
window
&
&
!
window
-
>
IsPopup
(
)
;
}
static
bool
IsTouchSupportEnabled
(
HWND
aWnd
)
{
nsWindow
*
topWindow
=
WinUtils
:
:
GetNSWindowPtr
(
WinUtils
:
:
GetTopLevelHWND
(
aWnd
true
)
)
;
return
topWindow
?
topWindow
-
>
IsTouchWindow
(
)
:
false
;
}
static
Maybe
<
POINT
>
GetSingleTouch
(
WPARAM
wParam
LPARAM
lParam
)
{
Maybe
<
POINT
>
ret
;
uint32_t
cInputs
=
LOWORD
(
wParam
)
;
if
(
cInputs
!
=
1
)
{
return
ret
;
}
TOUCHINPUT
input
;
if
(
GetTouchInputInfo
(
(
HTOUCHINPUT
)
lParam
cInputs
&
input
sizeof
(
TOUCHINPUT
)
)
)
{
ret
.
emplace
(
)
;
ret
-
>
x
=
TOUCH_COORD_TO_PIXEL
(
input
.
x
)
;
ret
-
>
y
=
TOUCH_COORD_TO_PIXEL
(
input
.
y
)
;
}
return
ret
;
}
bool
nsWindow
:
:
DealWithPopups
(
HWND
aWnd
UINT
aMessage
WPARAM
aWParam
LPARAM
aLParam
LRESULT
*
aResult
)
{
NS_ASSERTION
(
aResult
"
Bad
outResult
"
)
;
*
aResult
=
MA_NOACTIVATE
;
if
(
!
:
:
IsWindowVisible
(
aWnd
)
)
{
return
false
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
NS_ENSURE_TRUE
(
rollupListener
false
)
;
nsCOMPtr
<
nsIWidget
>
popup
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
!
popup
)
{
return
false
;
}
static
bool
sSendingNCACTIVATE
=
false
;
static
bool
sPendingNCACTIVATE
=
false
;
uint32_t
popupsToRollup
=
UINT32_MAX
;
bool
consumeRollupEvent
=
false
;
Maybe
<
POINT
>
touchPoint
;
nsWindow
*
popupWindow
=
static_cast
<
nsWindow
*
>
(
popup
.
get
(
)
)
;
UINT
nativeMessage
=
WinUtils
:
:
GetNativeMessage
(
aMessage
)
;
switch
(
nativeMessage
)
{
case
WM_TOUCH
:
if
(
!
IsTouchSupportEnabled
(
aWnd
)
)
{
return
false
;
}
touchPoint
=
GetSingleTouch
(
aWParam
aLParam
)
;
if
(
!
touchPoint
)
{
return
false
;
}
[
[
fallthrough
]
]
;
case
WM_LBUTTONDOWN
:
case
WM_RBUTTONDOWN
:
case
WM_MBUTTONDOWN
:
case
WM_NCLBUTTONDOWN
:
case
WM_NCRBUTTONDOWN
:
case
WM_NCMBUTTONDOWN
:
if
(
nativeMessage
!
=
WM_TOUCH
&
&
IsTouchSupportEnabled
(
aWnd
)
&
&
MOUSE_INPUT_SOURCE
(
)
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
return
false
;
}
if
(
!
EventIsInsideWindow
(
popupWindow
touchPoint
)
&
&
GetPopupsToRollup
(
rollupListener
&
popupsToRollup
touchPoint
)
)
{
break
;
}
return
false
;
case
WM_POINTERDOWN
:
{
WinPointerEvents
pointerEvents
;
if
(
!
pointerEvents
.
ShouldRollupOnPointerEvent
(
nativeMessage
aWParam
)
)
{
return
false
;
}
POINT
pt
;
pt
.
x
=
GET_X_LPARAM
(
aLParam
)
;
pt
.
y
=
GET_Y_LPARAM
(
aLParam
)
;
if
(
!
GetPopupsToRollup
(
rollupListener
&
popupsToRollup
Some
(
pt
)
)
)
{
return
false
;
}
if
(
EventIsInsideWindow
(
popupWindow
Some
(
pt
)
)
)
{
return
false
;
}
}
break
;
case
MOZ_WM_DMANIP
:
{
POINT
pt
;
:
:
GetCursorPos
(
&
pt
)
;
if
(
!
GetPopupsToRollup
(
rollupListener
&
popupsToRollup
Some
(
pt
)
)
)
{
return
false
;
}
if
(
EventIsInsideWindow
(
popupWindow
Some
(
pt
)
)
)
{
return
false
;
}
}
break
;
case
WM_MOUSEWHEEL
:
case
WM_MOUSEHWHEEL
:
if
(
!
EventIsInsideWindow
(
popupWindow
)
)
{
consumeRollupEvent
=
rollupListener
-
>
ShouldConsumeOnMouseWheelEvent
(
)
;
*
aResult
=
MA_ACTIVATE
;
if
(
rollupListener
-
>
ShouldRollupOnMouseWheelEvent
(
)
&
&
GetPopupsToRollup
(
rollupListener
&
popupsToRollup
)
)
{
break
;
}
}
return
consumeRollupEvent
;
case
WM_ACTIVATEAPP
:
break
;
case
WM_ACTIVATE
:
if
(
LOWORD
(
aWParam
)
=
=
WA_ACTIVE
&
&
aLParam
)
{
nsWindow
*
window
=
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
if
(
window
&
&
window
-
>
IsPopup
(
)
)
{
sJustGotDeactivate
=
false
;
:
:
PostMessageW
(
aWnd
MOZ_WM_REACTIVATE
aWParam
aLParam
)
;
return
true
;
}
nsWindow
*
prevWindow
=
WinUtils
:
:
GetNSWindowPtr
(
reinterpret_cast
<
HWND
>
(
aLParam
)
)
;
if
(
prevWindow
&
&
prevWindow
-
>
IsPopup
(
)
)
{
return
true
;
}
}
else
if
(
LOWORD
(
aWParam
)
=
=
WA_INACTIVE
)
{
nsWindow
*
activeWindow
=
WinUtils
:
:
GetNSWindowPtr
(
reinterpret_cast
<
HWND
>
(
aLParam
)
)
;
if
(
sPendingNCACTIVATE
&
&
NeedsToHandleNCActivateDelayed
(
aWnd
)
)
{
if
(
!
activeWindow
|
|
!
activeWindow
-
>
IsPopup
(
)
)
{
sSendingNCACTIVATE
=
true
;
:
:
SendMessageW
(
aWnd
WM_NCACTIVATE
false
0
)
;
sSendingNCACTIVATE
=
false
;
}
sPendingNCACTIVATE
=
false
;
}
if
(
activeWindow
)
{
if
(
activeWindow
-
>
IsPopup
(
)
)
{
return
true
;
}
nsWindow
*
deactiveWindow
=
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
if
(
deactiveWindow
&
&
deactiveWindow
-
>
IsPopup
(
)
)
{
return
true
;
}
}
}
else
if
(
LOWORD
(
aWParam
)
=
=
WA_CLICKACTIVE
)
{
nsWindow
*
window
=
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
if
(
(
window
&
&
window
-
>
IsPopup
(
)
)
|
|
!
GetPopupsToRollup
(
rollupListener
&
popupsToRollup
)
)
{
return
false
;
}
}
break
;
case
MOZ_WM_REACTIVATE
:
if
(
:
:
IsWindow
(
reinterpret_cast
<
HWND
>
(
aLParam
)
)
)
{
:
:
SetForegroundWindow
(
reinterpret_cast
<
HWND
>
(
aLParam
)
)
;
}
return
true
;
case
WM_NCACTIVATE
:
if
(
!
aWParam
&
&
!
sSendingNCACTIVATE
&
&
NeedsToHandleNCActivateDelayed
(
aWnd
)
)
{
:
:
DefWindowProcW
(
aWnd
aMessage
TRUE
aLParam
)
;
*
aResult
=
TRUE
;
sPendingNCACTIVATE
=
true
;
return
true
;
}
return
false
;
case
WM_MOUSEACTIVATE
:
if
(
!
EventIsInsideWindow
(
popupWindow
)
&
&
GetPopupsToRollup
(
rollupListener
&
popupsToRollup
)
)
{
if
(
HIWORD
(
aLParam
)
=
=
WM_MOUSEMOVE
&
&
!
rollupListener
-
>
ShouldRollupOnMouseActivate
(
)
)
{
return
true
;
}
return
false
;
}
return
true
;
case
WM_SHOWWINDOW
:
if
(
aLParam
=
=
SW_PARENTCLOSING
)
{
break
;
}
return
false
;
case
WM_KILLFOCUS
:
if
(
IsDifferentThreadWindow
(
reinterpret_cast
<
HWND
>
(
aWParam
)
)
)
{
break
;
}
return
false
;
case
WM_MOVING
:
case
WM_MENUSELECT
:
break
;
default
:
return
false
;
}
NS_ASSERTION
(
!
nsAutoRollup
:
:
GetLastRollup
(
)
"
last
rollup
is
null
"
)
;
if
(
nativeMessage
=
=
WM_TOUCH
|
|
nativeMessage
=
=
WM_LBUTTONDOWN
|
|
nativeMessage
=
=
WM_POINTERDOWN
)
{
LayoutDeviceIntPoint
pos
;
if
(
nativeMessage
=
=
WM_TOUCH
)
{
pos
.
x
=
touchPoint
-
>
x
;
pos
.
y
=
touchPoint
-
>
y
;
}
else
{
POINT
pt
;
pt
.
x
=
GET_X_LPARAM
(
aLParam
)
;
pt
.
y
=
GET_Y_LPARAM
(
aLParam
)
;
if
(
nativeMessage
=
=
WM_LBUTTONDOWN
)
{
:
:
ClientToScreen
(
aWnd
&
pt
)
;
}
pos
=
LayoutDeviceIntPoint
(
pt
.
x
pt
.
y
)
;
}
nsIContent
*
lastRollup
;
consumeRollupEvent
=
rollupListener
-
>
Rollup
(
popupsToRollup
true
&
pos
&
lastRollup
)
;
nsAutoRollup
:
:
SetLastRollup
(
lastRollup
)
;
}
else
{
consumeRollupEvent
=
rollupListener
-
>
Rollup
(
popupsToRollup
true
nullptr
nullptr
)
;
}
sProcessHook
=
false
;
sRollupMsgId
=
0
;
sRollupMsgWnd
=
nullptr
;
if
(
consumeRollupEvent
&
&
nativeMessage
!
=
WM_RBUTTONDOWN
)
{
*
aResult
=
MA_ACTIVATE
;
return
true
;
}
return
false
;
}
nsWindow
*
nsWindow
:
:
GetTopLevelWindow
(
bool
aStopOnDialogOrPopup
)
{
nsWindow
*
curWindow
=
this
;
while
(
true
)
{
if
(
aStopOnDialogOrPopup
)
{
switch
(
curWindow
-
>
mWindowType
)
{
case
eWindowType_dialog
:
case
eWindowType_popup
:
return
curWindow
;
default
:
break
;
}
}
nsWindow
*
parentWindow
=
curWindow
-
>
GetParentWindow
(
true
)
;
if
(
!
parentWindow
)
return
curWindow
;
curWindow
=
parentWindow
;
}
}
static
BOOL
CALLBACK
EnumVisibleWindowsProc
(
HWND
hwnd
LPARAM
lParam
)
{
DWORD
pid
;
:
:
GetWindowThreadProcessId
(
hwnd
&
pid
)
;
if
(
pid
=
=
:
:
GetCurrentProcessId
(
)
&
&
:
:
IsWindowVisible
(
hwnd
)
)
{
nsWindow
*
window
=
WinUtils
:
:
GetNSWindowPtr
(
hwnd
)
;
if
(
!
window
|
|
!
window
-
>
IsPopup
(
)
)
{
bool
*
windowsVisible
=
reinterpret_cast
<
bool
*
>
(
lParam
)
;
*
windowsVisible
=
true
;
return
FALSE
;
}
}
return
TRUE
;
}
bool
nsWindow
:
:
CanTakeFocus
(
)
{
HWND
fgWnd
=
:
:
GetForegroundWindow
(
)
;
if
(
!
fgWnd
)
{
return
true
;
}
DWORD
pid
;
:
:
GetWindowThreadProcessId
(
fgWnd
&
pid
)
;
if
(
pid
=
=
:
:
GetCurrentProcessId
(
)
)
{
return
true
;
}
bool
windowsVisible
=
false
;
:
:
EnumWindows
(
EnumVisibleWindowsProc
reinterpret_cast
<
LPARAM
>
(
&
windowsVisible
)
)
;
if
(
!
windowsVisible
)
{
return
true
;
}
return
false
;
}
const
wchar_t
*
nsWindow
:
:
GetMainWindowClass
(
)
{
static
const
wchar_t
*
sMainWindowClass
=
nullptr
;
if
(
!
sMainWindowClass
)
{
nsAutoString
className
;
Preferences
:
:
GetString
(
"
ui
.
window_class_override
"
className
)
;
if
(
!
className
.
IsEmpty
(
)
)
{
sMainWindowClass
=
wcsdup
(
className
.
get
(
)
)
;
}
else
{
sMainWindowClass
=
kClassNameGeneral
;
}
}
return
sMainWindowClass
;
}
LPARAM
nsWindow
:
:
lParamToScreen
(
LPARAM
lParam
)
{
POINT
pt
;
pt
.
x
=
GET_X_LPARAM
(
lParam
)
;
pt
.
y
=
GET_Y_LPARAM
(
lParam
)
;
:
:
ClientToScreen
(
mWnd
&
pt
)
;
return
MAKELPARAM
(
pt
.
x
pt
.
y
)
;
}
LPARAM
nsWindow
:
:
lParamToClient
(
LPARAM
lParam
)
{
POINT
pt
;
pt
.
x
=
GET_X_LPARAM
(
lParam
)
;
pt
.
y
=
GET_Y_LPARAM
(
lParam
)
;
:
:
ScreenToClient
(
mWnd
&
pt
)
;
return
MAKELPARAM
(
pt
.
x
pt
.
y
)
;
}
WPARAM
nsWindow
:
:
wParamFromGlobalMouseState
(
)
{
WPARAM
result
=
0
;
if
(
!
!
:
:
GetKeyState
(
VK_CONTROL
)
)
{
result
|
=
MK_CONTROL
;
}
if
(
!
!
:
:
GetKeyState
(
VK_SHIFT
)
)
{
result
|
=
MK_SHIFT
;
}
if
(
!
!
:
:
GetKeyState
(
VK_LBUTTON
)
)
{
result
|
=
MK_LBUTTON
;
}
if
(
!
!
:
:
GetKeyState
(
VK_MBUTTON
)
)
{
result
|
=
MK_MBUTTON
;
}
if
(
!
!
:
:
GetKeyState
(
VK_RBUTTON
)
)
{
result
|
=
MK_RBUTTON
;
}
if
(
!
!
:
:
GetKeyState
(
VK_XBUTTON1
)
)
{
result
|
=
MK_XBUTTON1
;
}
if
(
!
!
:
:
GetKeyState
(
VK_XBUTTON2
)
)
{
result
|
=
MK_XBUTTON2
;
}
return
result
;
}
void
nsWindow
:
:
PickerOpen
(
)
{
mPickerDisplayCount
+
+
;
}
void
nsWindow
:
:
PickerClosed
(
)
{
NS_ASSERTION
(
mPickerDisplayCount
>
0
"
mPickerDisplayCount
out
of
sync
!
"
)
;
if
(
!
mPickerDisplayCount
)
return
;
mPickerDisplayCount
-
-
;
if
(
!
mPickerDisplayCount
&
&
mDestroyCalled
)
{
Destroy
(
)
;
}
}
bool
nsWindow
:
:
WidgetTypeSupportsAcceleration
(
)
{
return
mTransparencyMode
!
=
eTransparencyTransparent
&
&
!
(
IsPopup
(
)
&
&
DeviceManagerDx
:
:
Get
(
)
-
>
IsWARP
(
)
)
;
}
bool
nsWindow
:
:
DispatchTouchEventFromWMPointer
(
UINT
msg
LPARAM
aLParam
const
WinPointerInfo
&
aPointerInfo
mozilla
:
:
MouseButton
aButton
)
{
MultiTouchInput
:
:
MultiTouchType
touchType
;
switch
(
msg
)
{
case
WM_POINTERDOWN
:
touchType
=
MultiTouchInput
:
:
MULTITOUCH_START
;
break
;
case
WM_POINTERUPDATE
:
if
(
aPointerInfo
.
mPressure
=
=
0
)
{
return
false
;
}
touchType
=
MultiTouchInput
:
:
MULTITOUCH_MOVE
;
break
;
case
WM_POINTERUP
:
touchType
=
MultiTouchInput
:
:
MULTITOUCH_END
;
break
;
default
:
return
false
;
}
nsPointWin
touchPoint
;
touchPoint
.
x
=
GET_X_LPARAM
(
aLParam
)
;
touchPoint
.
y
=
GET_Y_LPARAM
(
aLParam
)
;
touchPoint
.
ScreenToClient
(
mWnd
)
;
SingleTouchData
touchData
(
static_cast
<
int32_t
>
(
aPointerInfo
.
pointerId
)
ScreenIntPoint
:
:
FromUnknownPoint
(
touchPoint
)
ScreenSize
(
1
1
)
0
.
0f
aPointerInfo
.
mPressure
)
;
touchData
.
mTiltX
=
aPointerInfo
.
tiltX
;
touchData
.
mTiltY
=
aPointerInfo
.
tiltY
;
touchData
.
mTwist
=
aPointerInfo
.
twist
;
MultiTouchInput
touchInput
;
touchInput
.
mType
=
touchType
;
touchInput
.
mTime
=
:
:
GetMessageTime
(
)
;
touchInput
.
mTimeStamp
=
GetMessageTimeStamp
(
static_cast
<
long
>
(
touchInput
.
mTime
)
)
;
touchInput
.
mTouches
.
AppendElement
(
touchData
)
;
touchInput
.
mButton
=
aButton
;
touchInput
.
mButtons
=
aPointerInfo
.
mButtons
;
ModifierKeyState
modifierKeyState
;
touchInput
.
modifiers
=
modifierKeyState
.
GetModifiers
(
)
;
DispatchTouchInput
(
touchInput
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
)
;
return
true
;
}
static
MouseButton
PenFlagsToMouseButton
(
PEN_FLAGS
aPenFlags
)
{
if
(
aPenFlags
&
PEN_FLAG_BARREL
)
{
return
MouseButton
:
:
eSecondary
;
}
if
(
aPenFlags
&
PEN_FLAG_ERASER
)
{
return
MouseButton
:
:
eEraser
;
}
return
MouseButton
:
:
ePrimary
;
}
bool
nsWindow
:
:
OnPointerEvents
(
UINT
msg
WPARAM
aWParam
LPARAM
aLParam
)
{
if
(
!
mAPZC
)
{
return
false
;
}
if
(
!
mPointerEvents
.
ShouldHandleWinPointerMessages
(
msg
aWParam
)
)
{
return
false
;
}
if
(
!
mPointerEvents
.
ShouldFirePointerEventByWinPointerMessages
(
)
)
{
mPointerEvents
.
ConvertAndCachePointerInfo
(
msg
aWParam
)
;
return
false
;
}
uint32_t
pointerId
=
mPointerEvents
.
GetPointerId
(
aWParam
)
;
POINTER_PEN_INFO
penInfo
{
}
;
if
(
!
mPointerEvents
.
GetPointerPenInfo
(
pointerId
&
penInfo
)
)
{
return
false
;
}
static
POINT
sLastPointerDownPoint
=
{
0
}
;
static
mozilla
:
:
MouseButton
sLastPenDownButton
=
MouseButton
:
:
ePrimary
;
static
bool
sPointerDown
=
false
;
EventMessage
message
;
mozilla
:
:
MouseButton
button
=
MouseButton
:
:
ePrimary
;
switch
(
msg
)
{
case
WM_POINTERDOWN
:
{
LayoutDeviceIntPoint
eventPoint
(
GET_X_LPARAM
(
aLParam
)
GET_Y_LPARAM
(
aLParam
)
)
;
sLastPointerDownPoint
.
x
=
eventPoint
.
x
;
sLastPointerDownPoint
.
y
=
eventPoint
.
y
;
message
=
eMouseDown
;
button
=
PenFlagsToMouseButton
(
penInfo
.
penFlags
)
;
sLastPenDownButton
=
button
;
sPointerDown
=
true
;
}
break
;
case
WM_POINTERUP
:
message
=
eMouseUp
;
MOZ_ASSERT
(
sPointerDown
"
receive
WM_POINTERUP
w
/
o
WM_POINTERDOWN
"
)
;
button
=
sPointerDown
?
sLastPenDownButton
:
MouseButton
:
:
ePrimary
;
sPointerDown
=
false
;
break
;
case
WM_POINTERUPDATE
:
message
=
eMouseMove
;
if
(
sPointerDown
)
{
LayoutDeviceIntPoint
eventPoint
(
GET_X_LPARAM
(
aLParam
)
GET_Y_LPARAM
(
aLParam
)
)
;
int32_t
movementX
=
sLastPointerDownPoint
.
x
>
eventPoint
.
x
?
sLastPointerDownPoint
.
x
-
eventPoint
.
x
:
eventPoint
.
x
-
sLastPointerDownPoint
.
x
;
int32_t
movementY
=
sLastPointerDownPoint
.
y
>
eventPoint
.
y
?
sLastPointerDownPoint
.
y
-
eventPoint
.
y
:
eventPoint
.
y
-
sLastPointerDownPoint
.
y
;
bool
insideMovementThreshold
=
movementX
<
(
int32_t
)
:
:
GetSystemMetrics
(
SM_CXDRAG
)
&
&
movementY
<
(
int32_t
)
:
:
GetSystemMetrics
(
SM_CYDRAG
)
;
if
(
insideMovementThreshold
)
{
return
false
;
}
button
=
sLastPenDownButton
;
}
break
;
case
WM_POINTERLEAVE
:
message
=
eMouseExitFromWidget
;
break
;
default
:
return
false
;
}
float
pressure
=
penInfo
.
pressure
?
(
float
)
penInfo
.
pressure
/
1024
:
0
;
int16_t
buttons
=
sPointerDown
?
nsContentUtils
:
:
GetButtonsFlagForButton
(
button
)
:
MouseButtonsFlag
:
:
eNoButtons
;
WinPointerInfo
pointerInfo
(
pointerId
penInfo
.
tiltX
penInfo
.
tiltY
pressure
buttons
)
;
pointerInfo
.
twist
=
penInfo
.
rotation
;
if
(
button
!
=
MouseButton
:
:
eSecondary
&
&
StaticPrefs
:
:
dom_w3c_pointer_events_scroll_by_pen_enabled
(
)
&
&
DispatchTouchEventFromWMPointer
(
msg
aLParam
pointerInfo
button
)
)
{
return
true
;
}
LPARAM
newLParam
=
lParamToClient
(
aLParam
)
;
DispatchMouseEvent
(
message
aWParam
newLParam
false
button
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
&
pointerInfo
)
;
if
(
button
=
=
MouseButton
:
:
eSecondary
&
&
message
=
=
eMouseUp
)
{
DispatchMouseEvent
(
eContextMenu
aWParam
newLParam
false
button
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
&
pointerInfo
)
;
}
return
true
;
}
void
nsWindow
:
:
GetCompositorWidgetInitData
(
mozilla
:
:
widget
:
:
CompositorWidgetInitData
*
aInitData
)
{
*
aInitData
=
WinCompositorWidgetInitData
(
reinterpret_cast
<
uintptr_t
>
(
mWnd
)
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
nsIWidget
*
>
(
this
)
)
mTransparencyMode
mFrameState
-
>
GetSizeMode
(
)
)
;
}
bool
nsWindow
:
:
SynchronouslyRepaintOnResize
(
)
{
return
!
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DwmCompositionEnabled
(
)
;
}
void
nsWindow
:
:
MaybeDispatchInitialFocusEvent
(
)
{
if
(
mIsShowingPreXULSkeletonUI
&
&
:
:
GetActiveWindow
(
)
=
=
mWnd
)
{
DispatchFocusToTopLevelWindow
(
true
)
;
}
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateTopLevelWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsWindow
(
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateChildWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsWindow
(
true
)
;
return
window
.
forget
(
)
;
}
bool
nsWindow
:
:
InitTouchInjection
(
)
{
if
(
!
sTouchInjectInitialized
)
{
HMODULE
hMod
=
LoadLibraryW
(
kUser32LibName
)
;
if
(
!
hMod
)
{
return
false
;
}
InitializeTouchInjectionPtr
func
=
(
InitializeTouchInjectionPtr
)
GetProcAddress
(
hMod
"
InitializeTouchInjection
"
)
;
if
(
!
func
)
{
WinUtils
:
:
Log
(
"
InitializeTouchInjection
not
available
.
"
)
;
return
false
;
}
if
(
!
func
(
TOUCH_INJECT_MAX_POINTS
TOUCH_FEEDBACK_DEFAULT
)
)
{
WinUtils
:
:
Log
(
"
InitializeTouchInjection
failure
.
GetLastError
=
%
d
"
GetLastError
(
)
)
;
return
false
;
}
sInjectTouchFuncPtr
=
(
InjectTouchInputPtr
)
GetProcAddress
(
hMod
"
InjectTouchInput
"
)
;
if
(
!
sInjectTouchFuncPtr
)
{
WinUtils
:
:
Log
(
"
InjectTouchInput
not
available
.
"
)
;
return
false
;
}
sTouchInjectInitialized
=
true
;
}
return
true
;
}
bool
nsWindow
:
:
InjectTouchPoint
(
uint32_t
aId
LayoutDeviceIntPoint
&
aPoint
POINTER_FLAGS
aFlags
uint32_t
aPressure
uint32_t
aOrientation
)
{
if
(
aId
>
TOUCH_INJECT_MAX_POINTS
)
{
WinUtils
:
:
Log
(
"
Pointer
ID
exceeds
maximum
.
See
TOUCH_INJECT_MAX_POINTS
.
"
)
;
return
false
;
}
POINTER_TOUCH_INFO
info
{
}
;
info
.
touchFlags
=
TOUCH_FLAG_NONE
;
info
.
touchMask
=
TOUCH_MASK_CONTACTAREA
|
TOUCH_MASK_ORIENTATION
|
TOUCH_MASK_PRESSURE
;
info
.
pressure
=
aPressure
;
info
.
orientation
=
aOrientation
;
info
.
pointerInfo
.
pointerFlags
=
aFlags
;
info
.
pointerInfo
.
pointerType
=
PT_TOUCH
;
info
.
pointerInfo
.
pointerId
=
aId
;
info
.
pointerInfo
.
ptPixelLocation
.
x
=
aPoint
.
x
;
info
.
pointerInfo
.
ptPixelLocation
.
y
=
aPoint
.
y
;
info
.
rcContact
.
top
=
info
.
pointerInfo
.
ptPixelLocation
.
y
-
2
;
info
.
rcContact
.
bottom
=
info
.
pointerInfo
.
ptPixelLocation
.
y
+
2
;
info
.
rcContact
.
left
=
info
.
pointerInfo
.
ptPixelLocation
.
x
-
2
;
info
.
rcContact
.
right
=
info
.
pointerInfo
.
ptPixelLocation
.
x
+
2
;
for
(
int
i
=
0
;
i
<
3
;
i
+
+
)
{
if
(
sInjectTouchFuncPtr
(
1
&
info
)
)
{
break
;
}
DWORD
error
=
GetLastError
(
)
;
if
(
error
=
=
ERROR_NOT_READY
&
&
i
<
2
)
{
:
:
Sleep
(
i
)
;
continue
;
}
WinUtils
:
:
Log
(
"
InjectTouchInput
failure
.
GetLastError
=
%
d
"
error
)
;
return
false
;
}
return
true
;
}
void
nsWindow
:
:
ChangedDPI
(
)
{
if
(
mWidgetListener
)
{
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
}
}
static
Result
<
POINTER_FLAGS
nsresult
>
PointerStateToFlag
(
nsWindow
:
:
TouchPointerState
aPointerState
bool
isUpdate
)
{
bool
hover
=
aPointerState
&
nsWindow
:
:
TOUCH_HOVER
;
bool
contact
=
aPointerState
&
nsWindow
:
:
TOUCH_CONTACT
;
bool
remove
=
aPointerState
&
nsWindow
:
:
TOUCH_REMOVE
;
bool
cancel
=
aPointerState
&
nsWindow
:
:
TOUCH_CANCEL
;
POINTER_FLAGS
flags
;
if
(
isUpdate
)
{
flags
=
POINTER_FLAG_UPDATE
;
if
(
hover
)
{
flags
|
=
POINTER_FLAG_INRANGE
;
}
else
if
(
contact
)
{
flags
|
=
POINTER_FLAG_INCONTACT
|
POINTER_FLAG_INRANGE
;
}
else
if
(
remove
)
{
flags
=
POINTER_FLAG_UP
;
}
if
(
cancel
)
{
flags
|
=
POINTER_FLAG_CANCELED
;
}
}
else
{
if
(
remove
|
|
cancel
)
{
return
Err
(
NS_ERROR_INVALID_ARG
)
;
}
flags
=
POINTER_FLAG_INRANGE
;
if
(
contact
)
{
flags
|
=
POINTER_FLAG_INCONTACT
|
POINTER_FLAG_DOWN
;
}
}
return
flags
;
}
nsresult
nsWindow
:
:
SynthesizeNativeTouchPoint
(
uint32_t
aPointerId
nsIWidget
:
:
TouchPointerState
aPointerState
LayoutDeviceIntPoint
aPoint
double
aPointerPressure
uint32_t
aPointerOrientation
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
touchpoint
"
)
;
if
(
StaticPrefs
:
:
apz_test_fails_with_native_injection
(
)
|
|
!
InitTouchInjection
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aPointerState
=
=
TOUCH_HOVER
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mSynthesizedTouchInput
)
{
mSynthesizedTouchInput
=
MakeUnique
<
MultiTouchInput
>
(
)
;
}
WidgetEventTime
time
=
CurrentMessageWidgetEventTime
(
)
;
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
MultiTouchInput
inputToDispatch
=
UpdateSynthesizedTouchState
(
mSynthesizedTouchInput
.
get
(
)
time
.
mTime
time
.
mTimeStamp
aPointerId
aPointerState
pointInWindow
aPointerPressure
aPointerOrientation
)
;
DispatchTouchInput
(
inputToDispatch
)
;
return
NS_OK
;
}
uint32_t
pressure
=
(
uint32_t
)
ceil
(
aPointerPressure
*
1024
)
;
return
mActivePointers
.
WithEntryHandle
(
aPointerId
[
&
]
(
auto
&
&
entry
)
{
POINTER_FLAGS
flags
;
auto
result
=
PointerStateToFlag
(
aPointerState
!
!
entry
)
;
if
(
result
.
isOk
(
)
)
{
flags
=
result
.
unwrap
(
)
;
}
else
{
return
result
.
unwrapErr
(
)
;
}
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
PointerInfo
>
(
aPointerId
aPoint
PointerInfo
:
:
PointerType
:
:
TOUCH
)
)
;
}
else
{
if
(
entry
.
Data
(
)
-
>
mType
!
=
PointerInfo
:
:
PointerType
:
:
TOUCH
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aPointerState
&
TOUCH_REMOVE
)
{
entry
.
Remove
(
)
;
}
}
return
!
InjectTouchPoint
(
aPointerId
aPoint
flags
pressure
aPointerOrientation
)
?
NS_ERROR_UNEXPECTED
:
NS_OK
;
}
)
;
}
nsresult
nsWindow
:
:
ClearNativeTouchSequence
(
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
cleartouch
"
)
;
if
(
!
sTouchInjectInitialized
)
{
return
NS_OK
;
}
for
(
auto
iter
=
mActivePointers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
*
info
=
iter
.
UserData
(
)
;
if
(
info
-
>
mType
!
=
PointerInfo
:
:
PointerType
:
:
TOUCH
)
{
continue
;
}
InjectTouchPoint
(
info
-
>
mPointerId
info
-
>
mPosition
POINTER_FLAG_CANCELED
)
;
iter
.
Remove
(
)
;
}
nsBaseWidget
:
:
ClearNativeTouchSequence
(
nullptr
)
;
return
NS_OK
;
}
#
if
!
defined
(
NTDDI_WIN10_RS5
)
|
|
(
NTDDI_VERSION
<
NTDDI_WIN10_RS5
)
static
CreateSyntheticPointerDevicePtr
CreateSyntheticPointerDevice
;
static
DestroySyntheticPointerDevicePtr
DestroySyntheticPointerDevice
;
static
InjectSyntheticPointerInputPtr
InjectSyntheticPointerInput
;
#
endif
static
HSYNTHETICPOINTERDEVICE
sSyntheticPenDevice
;
static
bool
InitPenInjection
(
)
{
if
(
sSyntheticPenDevice
)
{
return
true
;
}
#
if
!
defined
(
NTDDI_WIN10_RS5
)
|
|
(
NTDDI_VERSION
<
NTDDI_WIN10_RS5
)
HMODULE
hMod
=
LoadLibraryW
(
kUser32LibName
)
;
if
(
!
hMod
)
{
return
false
;
}
CreateSyntheticPointerDevice
=
(
CreateSyntheticPointerDevicePtr
)
GetProcAddress
(
hMod
"
CreateSyntheticPointerDevice
"
)
;
if
(
!
CreateSyntheticPointerDevice
)
{
WinUtils
:
:
Log
(
"
CreateSyntheticPointerDevice
not
available
.
"
)
;
return
false
;
}
DestroySyntheticPointerDevice
=
(
DestroySyntheticPointerDevicePtr
)
GetProcAddress
(
hMod
"
DestroySyntheticPointerDevice
"
)
;
if
(
!
DestroySyntheticPointerDevice
)
{
WinUtils
:
:
Log
(
"
DestroySyntheticPointerDevice
not
available
.
"
)
;
return
false
;
}
InjectSyntheticPointerInput
=
(
InjectSyntheticPointerInputPtr
)
GetProcAddress
(
hMod
"
InjectSyntheticPointerInput
"
)
;
if
(
!
InjectSyntheticPointerInput
)
{
WinUtils
:
:
Log
(
"
InjectSyntheticPointerInput
not
available
.
"
)
;
return
false
;
}
#
endif
sSyntheticPenDevice
=
CreateSyntheticPointerDevice
(
PT_PEN
1
POINTER_FEEDBACK_DEFAULT
)
;
return
!
!
sSyntheticPenDevice
;
}
nsresult
nsWindow
:
:
SynthesizeNativePenInput
(
uint32_t
aPointerId
nsIWidget
:
:
TouchPointerState
aPointerState
LayoutDeviceIntPoint
aPoint
double
aPressure
uint32_t
aRotation
int32_t
aTiltX
int32_t
aTiltY
int32_t
aButton
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
peninput
"
)
;
if
(
!
InitPenInjection
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
uint32_t
pressure
=
(
uint32_t
)
ceil
(
aPressure
*
1024
)
;
return
mActivePointers
.
WithEntryHandle
(
aPointerId
[
&
]
(
auto
&
&
entry
)
{
POINTER_FLAGS
flags
;
auto
result
=
PointerStateToFlag
(
aPointerState
!
!
entry
)
;
if
(
result
.
isOk
(
)
)
{
flags
=
result
.
unwrap
(
)
;
}
else
{
return
result
.
unwrapErr
(
)
;
}
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
PointerInfo
>
(
aPointerId
aPoint
PointerInfo
:
:
PointerType
:
:
PEN
)
)
;
}
else
{
if
(
entry
.
Data
(
)
-
>
mType
!
=
PointerInfo
:
:
PointerType
:
:
PEN
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aPointerState
&
TOUCH_REMOVE
)
{
entry
.
Remove
(
)
;
}
}
POINTER_TYPE_INFO
info
{
}
;
info
.
type
=
PT_PEN
;
info
.
penInfo
.
pointerInfo
.
pointerType
=
PT_PEN
;
info
.
penInfo
.
pointerInfo
.
pointerFlags
=
flags
;
info
.
penInfo
.
pointerInfo
.
pointerId
=
aPointerId
;
info
.
penInfo
.
pointerInfo
.
ptPixelLocation
.
x
=
aPoint
.
x
;
info
.
penInfo
.
pointerInfo
.
ptPixelLocation
.
y
=
aPoint
.
y
;
info
.
penInfo
.
penFlags
=
PEN_FLAG_NONE
;
if
(
aButton
=
=
2
)
{
info
.
penInfo
.
penFlags
|
=
PEN_FLAG_BARREL
;
}
info
.
penInfo
.
penMask
=
PEN_MASK_PRESSURE
|
PEN_MASK_ROTATION
|
PEN_MASK_TILT_X
|
PEN_MASK_TILT_Y
;
info
.
penInfo
.
pressure
=
pressure
;
info
.
penInfo
.
rotation
=
aRotation
;
info
.
penInfo
.
tiltX
=
aTiltX
;
info
.
penInfo
.
tiltY
=
aTiltY
;
return
InjectSyntheticPointerInput
(
sSyntheticPenDevice
&
info
1
)
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
)
;
}
;
bool
nsWindow
:
:
HandleAppCommandMsg
(
const
MSG
&
aAppCommandMsg
LRESULT
*
aRetValue
)
{
ModifierKeyState
modKeyState
;
NativeKey
nativeKey
(
this
aAppCommandMsg
modKeyState
)
;
bool
consumed
=
nativeKey
.
HandleAppCommandMessage
(
)
;
*
aRetValue
=
consumed
?
1
:
0
;
return
consumed
;
}
#
ifdef
DEBUG
nsresult
nsWindow
:
:
SetHiDPIMode
(
bool
aHiDPI
)
{
return
WinUtils
:
:
SetHiDPIMode
(
aHiDPI
)
;
}
nsresult
nsWindow
:
:
RestoreHiDPIMode
(
)
{
return
WinUtils
:
:
RestoreHiDPIMode
(
)
;
}
#
endif
static
nsSizeMode
GetSizeModeForWindowFrame
(
HWND
aWnd
bool
aFullscreenMode
)
{
WINDOWPLACEMENT
pl
;
pl
.
length
=
sizeof
(
pl
)
;
:
:
GetWindowPlacement
(
aWnd
&
pl
)
;
if
(
pl
.
showCmd
=
=
SW_SHOWMINIMIZED
)
{
return
nsSizeMode_Minimized
;
}
else
if
(
aFullscreenMode
)
{
return
nsSizeMode_Fullscreen
;
}
else
if
(
pl
.
showCmd
=
=
SW_SHOWMAXIMIZED
)
{
return
nsSizeMode_Maximized
;
}
else
{
return
nsSizeMode_Normal
;
}
}
static
void
ShowWindowWithMode
(
HWND
aWnd
nsSizeMode
aMode
)
{
switch
(
aMode
)
{
case
nsSizeMode_Fullscreen
:
:
:
ShowWindow
(
aWnd
SW_SHOW
)
;
break
;
case
nsSizeMode_Maximized
:
:
:
ShowWindow
(
aWnd
SW_MAXIMIZE
)
;
break
;
case
nsSizeMode_Minimized
:
:
:
ShowWindow
(
aWnd
SW_MINIMIZE
)
;
break
;
default
:
if
(
GetCurrentShowCmd
(
aWnd
)
!
=
SW_SHOWNORMAL
)
{
:
:
ShowWindow
(
aWnd
SW_RESTORE
)
;
}
}
}
nsWindow
:
:
FrameState
:
:
FrameState
(
nsWindow
*
aWindow
)
:
mWindow
(
aWindow
)
{
}
nsSizeMode
nsWindow
:
:
FrameState
:
:
GetSizeMode
(
)
const
{
return
mSizeMode
;
}
void
nsWindow
:
:
FrameState
:
:
CheckInvariant
(
)
const
{
MOZ_ASSERT
(
mSizeMode
>
=
0
&
&
mSizeMode
<
nsSizeMode_Invalid
)
;
MOZ_ASSERT
(
mLastSizeMode
>
=
0
&
&
mLastSizeMode
<
nsSizeMode_Invalid
)
;
MOZ_ASSERT
(
mOldSizeMode
>
=
0
&
&
mOldSizeMode
<
nsSizeMode_Invalid
)
;
MOZ_ASSERT
(
mWindow
)
;
MOZ_ASSERT_IF
(
mSizeMode
=
=
nsSizeMode_Fullscreen
mFullscreenMode
)
;
MOZ_ASSERT_IF
(
!
mFullscreenMode
mSizeMode
!
=
nsSizeMode_Fullscreen
)
;
MOZ_ASSERT
(
mOldSizeMode
!
=
nsSizeMode_Fullscreen
)
;
}
void
nsWindow
:
:
FrameState
:
:
ConsumePreXULSkeletonState
(
bool
aWasMaximized
)
{
mSizeMode
=
aWasMaximized
?
nsSizeMode_Maximized
:
nsSizeMode_Normal
;
}
void
nsWindow
:
:
FrameState
:
:
EnsureSizeMode
(
nsSizeMode
aMode
)
{
if
(
mSizeMode
=
=
aMode
)
{
return
;
}
if
(
aMode
=
=
nsSizeMode_Fullscreen
)
{
EnsureFullscreenMode
(
true
)
;
}
else
if
(
(
mSizeMode
=
=
nsSizeMode_Fullscreen
)
&
&
(
aMode
=
=
nsSizeMode_Normal
)
)
{
EnsureFullscreenMode
(
false
)
;
}
else
{
SetSizeModeInternal
(
aMode
)
;
}
}
void
nsWindow
:
:
FrameState
:
:
EnsureFullscreenMode
(
bool
aFullScreen
)
{
if
(
mFullscreenMode
=
=
aFullScreen
)
{
return
;
}
mWindow
-
>
OnFullscreenWillChange
(
aFullScreen
)
;
mFullscreenMode
=
aFullScreen
;
if
(
aFullScreen
)
{
mOldSizeMode
=
mSizeMode
;
SetSizeModeInternal
(
nsSizeMode_Fullscreen
)
;
}
else
{
SetSizeModeInternal
(
mOldSizeMode
)
;
}
mWindow
-
>
OnFullscreenChanged
(
aFullScreen
)
;
}
void
nsWindow
:
:
FrameState
:
:
OnFrameChanging
(
)
{
if
(
mSizeMode
=
=
nsSizeMode_Fullscreen
)
{
return
;
}
WINDOWPLACEMENT
pl
;
pl
.
length
=
sizeof
(
pl
)
;
:
:
GetWindowPlacement
(
mWindow
-
>
mWnd
&
pl
)
;
const
nsSizeMode
newSizeMode
=
GetSizeModeForWindowFrame
(
mWindow
-
>
mWnd
mFullscreenMode
)
;
mWindow
-
>
OnSizeModeChange
(
newSizeMode
)
;
mWindow
-
>
UpdateNonClientMargins
(
newSizeMode
false
)
;
}
void
nsWindow
:
:
FrameState
:
:
OnFrameChanged
(
)
{
if
(
mSizeMode
=
=
nsSizeMode_Fullscreen
)
{
return
;
}
const
nsSizeMode
previousSizeMode
=
mSizeMode
;
mSizeMode
=
GetSizeModeForWindowFrame
(
mWindow
-
>
mWnd
mFullscreenMode
)
;
MaybeLogSizeMode
(
mSizeMode
)
;
if
(
mSizeMode
!
=
previousSizeMode
)
{
mWindow
-
>
OnSizeModeChange
(
mSizeMode
)
;
}
if
(
mLastSizeMode
!
=
mSizeMode
)
{
if
(
mSizeMode
=
=
nsSizeMode_Normal
)
{
mWindow
-
>
DispatchFocusToTopLevelWindow
(
true
)
;
}
mLastSizeMode
=
mSizeMode
;
}
}
void
nsWindow
:
:
FrameState
:
:
SetSizeModeInternal
(
nsSizeMode
aMode
)
{
if
(
mSizeMode
=
=
aMode
)
{
return
;
}
mLastSizeMode
=
mSizeMode
;
mSizeMode
=
aMode
;
if
(
mWindow
-
>
mIsVisible
)
{
ShowWindowWithMode
(
mWindow
-
>
mWnd
aMode
)
;
}
if
(
mWindow
-
>
mIsVisible
&
&
(
aMode
=
=
nsSizeMode_Maximized
|
|
aMode
=
=
nsSizeMode_Fullscreen
)
)
{
mWindow
-
>
DispatchFocusToTopLevelWindow
(
true
)
;
}
}
void
nsWindow
:
:
ContextMenuPreventer
:
:
Update
(
const
WidgetMouseEvent
&
aEvent
const
nsIWidget
:
:
ContentAndAPZEventStatus
&
aEventStatus
)
{
mNeedsToPreventContextMenu
=
aEvent
.
mMessage
=
=
eMouseUp
&
&
aEvent
.
mButton
=
=
MouseButton
:
:
eSecondary
&
&
aEvent
.
mInputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
&
&
aEventStatus
.
mApzStatus
=
=
nsEventStatus_eConsumeNoDefault
;
}
