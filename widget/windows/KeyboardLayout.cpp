#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
widget
/
WinRegistry
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIUserIdleServiceInternal
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWindowDbg
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
npapi
.
h
"
#
include
<
windows
.
h
>
#
include
<
winnls
.
h
>
#
include
<
winuser
.
h
>
#
include
<
algorithm
>
#
ifndef
WINABLEAPI
#
include
<
winable
.
h
>
#
endif
mozilla
:
:
LazyLogModule
gKeyLog
(
"
KeyboardHandler
"
)
;
namespace
mozilla
{
namespace
widget
{
static
const
char
*
const
kVirtualKeyName
[
]
=
{
"
NULL
"
"
VK_LBUTTON
"
"
VK_RBUTTON
"
"
VK_CANCEL
"
"
VK_MBUTTON
"
"
VK_XBUTTON1
"
"
VK_XBUTTON2
"
"
0x07
"
"
VK_BACK
"
"
VK_TAB
"
"
0x0A
"
"
0x0B
"
"
VK_CLEAR
"
"
VK_RETURN
"
"
0x0E
"
"
0x0F
"
"
VK_SHIFT
"
"
VK_CONTROL
"
"
VK_MENU
"
"
VK_PAUSE
"
"
VK_CAPITAL
"
"
VK_KANA
VK_HANGUL
"
"
0x16
"
"
VK_JUNJA
"
"
VK_FINAL
"
"
VK_HANJA
VK_KANJI
"
"
0x1A
"
"
VK_ESCAPE
"
"
VK_CONVERT
"
"
VK_NONCONVERT
"
"
VK_ACCEPT
"
"
VK_MODECHANGE
"
"
VK_SPACE
"
"
VK_PRIOR
"
"
VK_NEXT
"
"
VK_END
"
"
VK_HOME
"
"
VK_LEFT
"
"
VK_UP
"
"
VK_RIGHT
"
"
VK_DOWN
"
"
VK_SELECT
"
"
VK_PRINT
"
"
VK_EXECUTE
"
"
VK_SNAPSHOT
"
"
VK_INSERT
"
"
VK_DELETE
"
"
VK_HELP
"
"
VK_0
"
"
VK_1
"
"
VK_2
"
"
VK_3
"
"
VK_4
"
"
VK_5
"
"
VK_6
"
"
VK_7
"
"
VK_8
"
"
VK_9
"
"
0x3A
"
"
0x3B
"
"
0x3C
"
"
0x3D
"
"
0x3E
"
"
0x3F
"
"
0x40
"
"
VK_A
"
"
VK_B
"
"
VK_C
"
"
VK_D
"
"
VK_E
"
"
VK_F
"
"
VK_G
"
"
VK_H
"
"
VK_I
"
"
VK_J
"
"
VK_K
"
"
VK_L
"
"
VK_M
"
"
VK_N
"
"
VK_O
"
"
VK_P
"
"
VK_Q
"
"
VK_R
"
"
VK_S
"
"
VK_T
"
"
VK_U
"
"
VK_V
"
"
VK_W
"
"
VK_X
"
"
VK_Y
"
"
VK_Z
"
"
VK_LWIN
"
"
VK_RWIN
"
"
VK_APPS
"
"
0x5E
"
"
VK_SLEEP
"
"
VK_NUMPAD0
"
"
VK_NUMPAD1
"
"
VK_NUMPAD2
"
"
VK_NUMPAD3
"
"
VK_NUMPAD4
"
"
VK_NUMPAD5
"
"
VK_NUMPAD6
"
"
VK_NUMPAD7
"
"
VK_NUMPAD8
"
"
VK_NUMPAD9
"
"
VK_MULTIPLY
"
"
VK_ADD
"
"
VK_SEPARATOR
"
"
VK_SUBTRACT
"
"
VK_DECIMAL
"
"
VK_DIVIDE
"
"
VK_F1
"
"
VK_F2
"
"
VK_F3
"
"
VK_F4
"
"
VK_F5
"
"
VK_F6
"
"
VK_F7
"
"
VK_F8
"
"
VK_F9
"
"
VK_F10
"
"
VK_F11
"
"
VK_F12
"
"
VK_F13
"
"
VK_F14
"
"
VK_F15
"
"
VK_F16
"
"
VK_F17
"
"
VK_F18
"
"
VK_F19
"
"
VK_F20
"
"
VK_F21
"
"
VK_F22
"
"
VK_F23
"
"
VK_F24
"
"
0x88
"
"
0x89
"
"
0x8A
"
"
0x8B
"
"
0x8C
"
"
0x8D
"
"
0x8E
"
"
0x8F
"
"
VK_NUMLOCK
"
"
VK_SCROLL
"
"
VK_OEM_NEC_EQUAL
VK_OEM_FJ_JISHO
"
"
VK_OEM_FJ_MASSHOU
"
"
VK_OEM_FJ_TOUROKU
"
"
VK_OEM_FJ_LOYA
"
"
VK_OEM_FJ_ROYA
"
"
0x97
"
"
0x98
"
"
0x99
"
"
0x9A
"
"
0x9B
"
"
0x9C
"
"
0x9D
"
"
0x9E
"
"
0x9F
"
"
VK_LSHIFT
"
"
VK_RSHIFT
"
"
VK_LCONTROL
"
"
VK_RCONTROL
"
"
VK_LMENU
"
"
VK_RMENU
"
"
VK_BROWSER_BACK
"
"
VK_BROWSER_FORWARD
"
"
VK_BROWSER_REFRESH
"
"
VK_BROWSER_STOP
"
"
VK_BROWSER_SEARCH
"
"
VK_BROWSER_FAVORITES
"
"
VK_BROWSER_HOME
"
"
VK_VOLUME_MUTE
"
"
VK_VOLUME_DOWN
"
"
VK_VOLUME_UP
"
"
VK_MEDIA_NEXT_TRACK
"
"
VK_MEDIA_PREV_TRACK
"
"
VK_MEDIA_STOP
"
"
VK_MEDIA_PLAY_PAUSE
"
"
VK_LAUNCH_MAIL
"
"
VK_LAUNCH_MEDIA_SELECT
"
"
VK_LAUNCH_APP1
"
"
VK_LAUNCH_APP2
"
"
0xB8
"
"
0xB9
"
"
VK_OEM_1
"
"
VK_OEM_PLUS
"
"
VK_OEM_COMMA
"
"
VK_OEM_MINUS
"
"
VK_OEM_PERIOD
"
"
VK_OEM_2
"
"
VK_OEM_3
"
"
VK_ABNT_C1
"
"
VK_ABNT_C2
"
"
0xC3
"
"
0xC4
"
"
0xC5
"
"
0xC6
"
"
0xC7
"
"
0xC8
"
"
0xC9
"
"
0xCA
"
"
0xCB
"
"
0xCC
"
"
0xCD
"
"
0xCE
"
"
0xCF
"
"
0xD0
"
"
0xD1
"
"
0xD2
"
"
0xD3
"
"
0xD4
"
"
0xD5
"
"
0xD6
"
"
0xD7
"
"
0xD8
"
"
0xD9
"
"
0xDA
"
"
VK_OEM_4
"
"
VK_OEM_5
"
"
VK_OEM_6
"
"
VK_OEM_7
"
"
VK_OEM_8
"
"
0xE0
"
"
VK_OEM_AX
"
"
VK_OEM_102
"
"
VK_ICO_HELP
"
"
VK_ICO_00
"
"
VK_PROCESSKEY
"
"
VK_ICO_CLEAR
"
"
VK_PACKET
"
"
0xE8
"
"
VK_OEM_RESET
"
"
VK_OEM_JUMP
"
"
VK_OEM_PA1
"
"
VK_OEM_PA2
"
"
VK_OEM_PA3
"
"
VK_OEM_WSCTRL
"
"
VK_OEM_CUSEL
"
"
VK_OEM_ATTN
"
"
VK_OEM_FINISH
"
"
VK_OEM_COPY
"
"
VK_OEM_AUTO
"
"
VK_OEM_ENLW
"
"
VK_OEM_BACKTAB
"
"
VK_ATTN
"
"
VK_CRSEL
"
"
VK_EXSEL
"
"
VK_EREOF
"
"
VK_PLAY
"
"
VK_ZOOM
"
"
VK_NONAME
"
"
VK_PA1
"
"
VK_OEM_CLEAR
"
"
0xFF
"
}
;
static_assert
(
sizeof
(
kVirtualKeyName
)
/
sizeof
(
const
char
*
)
=
=
0x100
"
The
virtual
key
name
must
be
defined
just
256
keys
"
)
;
static
const
nsCString
GetCharacterCodeName
(
WPARAM
aCharCode
)
{
switch
(
aCharCode
)
{
case
0x0000
:
return
"
NULL
(
0x0000
)
"
_ns
;
case
0x0008
:
return
"
BACKSPACE
(
0x0008
)
"
_ns
;
case
0x0009
:
return
"
CHARACTER
TABULATION
(
0x0009
)
"
_ns
;
case
0x000A
:
return
"
LINE
FEED
(
0x000A
)
"
_ns
;
case
0x000B
:
return
"
LINE
TABULATION
(
0x000B
)
"
_ns
;
case
0x000C
:
return
"
FORM
FEED
(
0x000C
)
"
_ns
;
case
0x000D
:
return
"
CARRIAGE
RETURN
(
0x000D
)
"
_ns
;
case
0x0018
:
return
"
CANCEL
(
0x0018
)
"
_ns
;
case
0x001B
:
return
"
ESCAPE
(
0x001B
)
"
_ns
;
case
0x0020
:
return
"
SPACE
(
0x0020
)
"
_ns
;
case
0x007F
:
return
"
DELETE
(
0x007F
)
"
_ns
;
case
0x00A0
:
return
"
NO
-
BREAK
SPACE
(
0x00A0
)
"
_ns
;
case
0x00AD
:
return
"
SOFT
HYPHEN
(
0x00AD
)
"
_ns
;
case
0x2000
:
return
"
EN
QUAD
(
0x2000
)
"
_ns
;
case
0x2001
:
return
"
EM
QUAD
(
0x2001
)
"
_ns
;
case
0x2002
:
return
"
EN
SPACE
(
0x2002
)
"
_ns
;
case
0x2003
:
return
"
EM
SPACE
(
0x2003
)
"
_ns
;
case
0x2004
:
return
"
THREE
-
PER
-
EM
SPACE
(
0x2004
)
"
_ns
;
case
0x2005
:
return
"
FOUR
-
PER
-
EM
SPACE
(
0x2005
)
"
_ns
;
case
0x2006
:
return
"
SIX
-
PER
-
EM
SPACE
(
0x2006
)
"
_ns
;
case
0x2007
:
return
"
FIGURE
SPACE
(
0x2007
)
"
_ns
;
case
0x2008
:
return
"
PUNCTUATION
SPACE
(
0x2008
)
"
_ns
;
case
0x2009
:
return
"
THIN
SPACE
(
0x2009
)
"
_ns
;
case
0x200A
:
return
"
HAIR
SPACE
(
0x200A
)
"
_ns
;
case
0x200B
:
return
"
ZERO
WIDTH
SPACE
(
0x200B
)
"
_ns
;
case
0x200C
:
return
"
ZERO
WIDTH
NON
-
JOINER
(
0x200C
)
"
_ns
;
case
0x200D
:
return
"
ZERO
WIDTH
JOINER
(
0x200D
)
"
_ns
;
case
0x200E
:
return
"
LEFT
-
TO
-
RIGHT
MARK
(
0x200E
)
"
_ns
;
case
0x200F
:
return
"
RIGHT
-
TO
-
LEFT
MARK
(
0x200F
)
"
_ns
;
case
0x2029
:
return
"
PARAGRAPH
SEPARATOR
(
0x2029
)
"
_ns
;
case
0x202A
:
return
"
LEFT
-
TO
-
RIGHT
EMBEDDING
(
0x202A
)
"
_ns
;
case
0x202B
:
return
"
RIGHT
-
TO
-
LEFT
EMBEDDING
(
0x202B
)
"
_ns
;
case
0x202D
:
return
"
LEFT
-
TO
-
RIGHT
OVERRIDE
(
0x202D
)
"
_ns
;
case
0x202E
:
return
"
RIGHT
-
TO
-
LEFT
OVERRIDE
(
0x202E
)
"
_ns
;
case
0x202F
:
return
"
NARROW
NO
-
BREAK
SPACE
(
0x202F
)
"
_ns
;
case
0x205F
:
return
"
MEDIUM
MATHEMATICAL
SPACE
(
0x205F
)
"
_ns
;
case
0x2060
:
return
"
WORD
JOINER
(
0x2060
)
"
_ns
;
case
0x2066
:
return
"
LEFT
-
TO
-
RIGHT
ISOLATE
(
0x2066
)
"
_ns
;
case
0x2067
:
return
"
RIGHT
-
TO
-
LEFT
ISOLATE
(
0x2067
)
"
_ns
;
case
0x3000
:
return
"
IDEOGRAPHIC
SPACE
(
0x3000
)
"
_ns
;
case
0xFEFF
:
return
"
ZERO
WIDTH
NO
-
BREAK
SPACE
(
0xFEFF
)
"
_ns
;
default
:
{
if
(
aCharCode
<
'
'
|
|
(
aCharCode
>
=
0x80
&
&
aCharCode
<
0xA0
)
)
{
return
nsPrintfCString
(
"
control
(
0x
%
04zX
)
"
aCharCode
)
;
}
if
(
NS_IS_HIGH_SURROGATE
(
aCharCode
)
)
{
return
nsPrintfCString
(
"
high
surrogate
(
0x
%
04zX
)
"
aCharCode
)
;
}
if
(
NS_IS_LOW_SURROGATE
(
aCharCode
)
)
{
return
nsPrintfCString
(
"
low
surrogate
(
0x
%
04zX
)
"
aCharCode
)
;
}
return
IS_IN_BMP
(
aCharCode
)
?
nsPrintfCString
(
"
'
%
s
'
(
0x
%
04zX
)
"
NS_ConvertUTF16toUTF8
(
nsAutoString
(
aCharCode
)
)
.
get
(
)
aCharCode
)
:
nsPrintfCString
(
"
'
%
s
'
(
0x
%
08zX
)
"
NS_ConvertUTF16toUTF8
(
nsAutoString
(
aCharCode
)
)
.
get
(
)
aCharCode
)
;
}
}
}
static
const
nsCString
GetKeyLocationName
(
uint32_t
aLocation
)
{
switch
(
aLocation
)
{
case
eKeyLocationLeft
:
return
"
KEY_LOCATION_LEFT
"
_ns
;
case
eKeyLocationRight
:
return
"
KEY_LOCATION_RIGHT
"
_ns
;
case
eKeyLocationStandard
:
return
"
KEY_LOCATION_STANDARD
"
_ns
;
case
eKeyLocationNumpad
:
return
"
KEY_LOCATION_NUMPAD
"
_ns
;
default
:
return
nsPrintfCString
(
"
Unknown
(
0x
%
04X
)
"
aLocation
)
;
}
}
static
const
nsCString
GetCharacterCodeNames
(
const
char16_t
*
aChars
uint32_t
aLength
)
{
if
(
!
aLength
)
{
return
"
"
_ns
;
}
nsCString
result
;
result
.
AssignLiteral
(
"
\
"
"
)
;
StringJoinAppend
(
result
"
"
_ns
Span
{
aChars
aLength
}
[
]
(
nsACString
&
dest
const
char16_t
charValue
)
{
dest
.
Append
(
GetCharacterCodeName
(
charValue
)
)
;
}
)
;
result
.
AppendLiteral
(
"
\
"
"
)
;
return
result
;
}
static
const
nsCString
GetCharacterCodeNames
(
const
UniCharsAndModifiers
&
aUniCharsAndModifiers
)
{
if
(
aUniCharsAndModifiers
.
IsEmpty
(
)
)
{
return
"
"
_ns
;
}
nsCString
result
;
result
.
AssignLiteral
(
"
\
"
"
)
;
StringJoinAppend
(
result
"
"
_ns
Span
{
aUniCharsAndModifiers
.
ToString
(
)
}
[
]
(
nsACString
&
dest
const
char16_t
charValue
)
{
dest
.
Append
(
GetCharacterCodeName
(
charValue
)
)
;
}
)
;
result
.
AppendLiteral
(
"
\
"
"
)
;
return
result
;
}
class
MOZ_STACK_CLASS
GetShiftStateName
final
:
public
nsAutoCString
{
public
:
explicit
GetShiftStateName
(
VirtualKey
:
:
ShiftState
aShiftState
)
{
if
(
!
aShiftState
)
{
AssignLiteral
(
"
none
"
)
;
return
;
}
if
(
aShiftState
&
VirtualKey
:
:
STATE_SHIFT
)
{
AssignLiteral
(
"
Shift
"
)
;
aShiftState
&
=
~
VirtualKey
:
:
STATE_SHIFT
;
}
if
(
aShiftState
&
VirtualKey
:
:
STATE_CONTROL
)
{
MaybeAppendSeparator
(
)
;
AssignLiteral
(
"
Ctrl
"
)
;
aShiftState
&
=
~
VirtualKey
:
:
STATE_CONTROL
;
}
if
(
aShiftState
&
VirtualKey
:
:
STATE_ALT
)
{
MaybeAppendSeparator
(
)
;
AssignLiteral
(
"
Alt
"
)
;
aShiftState
&
=
~
VirtualKey
:
:
STATE_ALT
;
}
if
(
aShiftState
&
VirtualKey
:
:
STATE_CAPSLOCK
)
{
MaybeAppendSeparator
(
)
;
AssignLiteral
(
"
CapsLock
"
)
;
aShiftState
&
=
~
VirtualKey
:
:
STATE_CAPSLOCK
;
}
MOZ_ASSERT
(
!
aShiftState
)
;
}
private
:
void
MaybeAppendSeparator
(
)
{
if
(
!
IsEmpty
(
)
)
{
AppendLiteral
(
"
|
"
)
;
}
}
}
;
static
const
nsCString
GetMessageName
(
UINT
aMessage
)
{
switch
(
aMessage
)
{
case
WM_NULL
:
return
"
WM_NULL
"
_ns
;
case
WM_KEYDOWN
:
return
"
WM_KEYDOWN
"
_ns
;
case
WM_KEYUP
:
return
"
WM_KEYUP
"
_ns
;
case
WM_SYSKEYDOWN
:
return
"
WM_SYSKEYDOWN
"
_ns
;
case
WM_SYSKEYUP
:
return
"
WM_SYSKEYUP
"
_ns
;
case
WM_CHAR
:
return
"
WM_CHAR
"
_ns
;
case
WM_UNICHAR
:
return
"
WM_UNICHAR
"
_ns
;
case
WM_SYSCHAR
:
return
"
WM_SYSCHAR
"
_ns
;
case
WM_DEADCHAR
:
return
"
WM_DEADCHAR
"
_ns
;
case
WM_SYSDEADCHAR
:
return
"
WM_SYSDEADCHAR
"
_ns
;
case
WM_APPCOMMAND
:
return
"
WM_APPCOMMAND
"
_ns
;
case
WM_QUIT
:
return
"
WM_QUIT
"
_ns
;
default
:
return
nsPrintfCString
(
"
Unknown
Message
(
0x
%
04X
)
"
aMessage
)
;
}
}
static
const
nsCString
GetVirtualKeyCodeName
(
WPARAM
aVK
)
{
if
(
aVK
>
=
std
:
:
size
(
kVirtualKeyName
)
)
{
return
nsPrintfCString
(
"
Invalid
(
0x
%
08zX
)
"
aVK
)
;
}
return
nsCString
(
kVirtualKeyName
[
aVK
]
)
;
}
static
const
nsCString
GetAppCommandName
(
WPARAM
aCommand
)
{
switch
(
aCommand
)
{
case
APPCOMMAND_BASS_BOOST
:
return
"
APPCOMMAND_BASS_BOOST
"
_ns
;
case
APPCOMMAND_BASS_DOWN
:
return
"
APPCOMMAND_BASS_DOWN
"
_ns
;
case
APPCOMMAND_BASS_UP
:
return
"
APPCOMMAND_BASS_UP
"
_ns
;
case
APPCOMMAND_BROWSER_BACKWARD
:
return
"
APPCOMMAND_BROWSER_BACKWARD
"
_ns
;
case
APPCOMMAND_BROWSER_FAVORITES
:
return
"
APPCOMMAND_BROWSER_FAVORITES
"
_ns
;
case
APPCOMMAND_BROWSER_FORWARD
:
return
"
APPCOMMAND_BROWSER_FORWARD
"
_ns
;
case
APPCOMMAND_BROWSER_HOME
:
return
"
APPCOMMAND_BROWSER_HOME
"
_ns
;
case
APPCOMMAND_BROWSER_REFRESH
:
return
"
APPCOMMAND_BROWSER_REFRESH
"
_ns
;
case
APPCOMMAND_BROWSER_SEARCH
:
return
"
APPCOMMAND_BROWSER_SEARCH
"
_ns
;
case
APPCOMMAND_BROWSER_STOP
:
return
"
APPCOMMAND_BROWSER_STOP
"
_ns
;
case
APPCOMMAND_CLOSE
:
return
"
APPCOMMAND_CLOSE
"
_ns
;
case
APPCOMMAND_COPY
:
return
"
APPCOMMAND_COPY
"
_ns
;
case
APPCOMMAND_CORRECTION_LIST
:
return
"
APPCOMMAND_CORRECTION_LIST
"
_ns
;
case
APPCOMMAND_CUT
:
return
"
APPCOMMAND_CUT
"
_ns
;
case
APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE
:
return
"
APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE
"
_ns
;
case
APPCOMMAND_FIND
:
return
"
APPCOMMAND_FIND
"
_ns
;
case
APPCOMMAND_FORWARD_MAIL
:
return
"
APPCOMMAND_FORWARD_MAIL
"
_ns
;
case
APPCOMMAND_HELP
:
return
"
APPCOMMAND_HELP
"
_ns
;
case
APPCOMMAND_LAUNCH_APP1
:
return
"
APPCOMMAND_LAUNCH_APP1
"
_ns
;
case
APPCOMMAND_LAUNCH_APP2
:
return
"
APPCOMMAND_LAUNCH_APP2
"
_ns
;
case
APPCOMMAND_LAUNCH_MAIL
:
return
"
APPCOMMAND_LAUNCH_MAIL
"
_ns
;
case
APPCOMMAND_LAUNCH_MEDIA_SELECT
:
return
"
APPCOMMAND_LAUNCH_MEDIA_SELECT
"
_ns
;
case
APPCOMMAND_MEDIA_CHANNEL_DOWN
:
return
"
APPCOMMAND_MEDIA_CHANNEL_DOWN
"
_ns
;
case
APPCOMMAND_MEDIA_CHANNEL_UP
:
return
"
APPCOMMAND_MEDIA_CHANNEL_UP
"
_ns
;
case
APPCOMMAND_MEDIA_FAST_FORWARD
:
return
"
APPCOMMAND_MEDIA_FAST_FORWARD
"
_ns
;
case
APPCOMMAND_MEDIA_NEXTTRACK
:
return
"
APPCOMMAND_MEDIA_NEXTTRACK
"
_ns
;
case
APPCOMMAND_MEDIA_PAUSE
:
return
"
APPCOMMAND_MEDIA_PAUSE
"
_ns
;
case
APPCOMMAND_MEDIA_PLAY
:
return
"
APPCOMMAND_MEDIA_PLAY
"
_ns
;
case
APPCOMMAND_MEDIA_PLAY_PAUSE
:
return
"
APPCOMMAND_MEDIA_PLAY_PAUSE
"
_ns
;
case
APPCOMMAND_MEDIA_PREVIOUSTRACK
:
return
"
APPCOMMAND_MEDIA_PREVIOUSTRACK
"
_ns
;
case
APPCOMMAND_MEDIA_RECORD
:
return
"
APPCOMMAND_MEDIA_RECORD
"
_ns
;
case
APPCOMMAND_MEDIA_REWIND
:
return
"
APPCOMMAND_MEDIA_REWIND
"
_ns
;
case
APPCOMMAND_MEDIA_STOP
:
return
"
APPCOMMAND_MEDIA_STOP
"
_ns
;
case
APPCOMMAND_MIC_ON_OFF_TOGGLE
:
return
"
APPCOMMAND_MIC_ON_OFF_TOGGLE
"
_ns
;
case
APPCOMMAND_MICROPHONE_VOLUME_DOWN
:
return
"
APPCOMMAND_MICROPHONE_VOLUME_DOWN
"
_ns
;
case
APPCOMMAND_MICROPHONE_VOLUME_MUTE
:
return
"
APPCOMMAND_MICROPHONE_VOLUME_MUTE
"
_ns
;
case
APPCOMMAND_MICROPHONE_VOLUME_UP
:
return
"
APPCOMMAND_MICROPHONE_VOLUME_UP
"
_ns
;
case
APPCOMMAND_NEW
:
return
"
APPCOMMAND_NEW
"
_ns
;
case
APPCOMMAND_OPEN
:
return
"
APPCOMMAND_OPEN
"
_ns
;
case
APPCOMMAND_PASTE
:
return
"
APPCOMMAND_PASTE
"
_ns
;
case
APPCOMMAND_PRINT
:
return
"
APPCOMMAND_PRINT
"
_ns
;
case
APPCOMMAND_REDO
:
return
"
APPCOMMAND_REDO
"
_ns
;
case
APPCOMMAND_REPLY_TO_MAIL
:
return
"
APPCOMMAND_REPLY_TO_MAIL
"
_ns
;
case
APPCOMMAND_SAVE
:
return
"
APPCOMMAND_SAVE
"
_ns
;
case
APPCOMMAND_SEND_MAIL
:
return
"
APPCOMMAND_SEND_MAIL
"
_ns
;
case
APPCOMMAND_SPELL_CHECK
:
return
"
APPCOMMAND_SPELL_CHECK
"
_ns
;
case
APPCOMMAND_TREBLE_DOWN
:
return
"
APPCOMMAND_TREBLE_DOWN
"
_ns
;
case
APPCOMMAND_TREBLE_UP
:
return
"
APPCOMMAND_TREBLE_UP
"
_ns
;
case
APPCOMMAND_UNDO
:
return
"
APPCOMMAND_UNDO
"
_ns
;
case
APPCOMMAND_VOLUME_DOWN
:
return
"
APPCOMMAND_VOLUME_DOWN
"
_ns
;
case
APPCOMMAND_VOLUME_MUTE
:
return
"
APPCOMMAND_VOLUME_MUTE
"
_ns
;
case
APPCOMMAND_VOLUME_UP
:
return
"
APPCOMMAND_VOLUME_UP
"
_ns
;
default
:
return
nsPrintfCString
(
"
Unknown
app
command
(
0x
%
08zX
)
"
aCommand
)
;
}
}
static
const
nsCString
GetAppCommandDeviceName
(
LPARAM
aDevice
)
{
switch
(
aDevice
)
{
case
FAPPCOMMAND_KEY
:
return
"
FAPPCOMMAND_KEY
"
_ns
;
case
FAPPCOMMAND_MOUSE
:
return
"
FAPPCOMMAND_MOUSE
"
_ns
;
case
FAPPCOMMAND_OEM
:
return
"
FAPPCOMMAND_OEM
"
_ns
;
default
:
return
nsPrintfCString
(
"
Unknown
app
command
device
(
0x
%
04
"
PRIXLPTR
"
)
"
aDevice
)
;
}
}
;
class
MOZ_STACK_CLASS
GetAppCommandKeysName
final
:
public
nsAutoCString
{
public
:
explicit
GetAppCommandKeysName
(
WPARAM
aKeys
)
{
if
(
aKeys
&
MK_CONTROL
)
{
AppendLiteral
(
"
MK_CONTROL
"
)
;
aKeys
&
=
~
MK_CONTROL
;
}
if
(
aKeys
&
MK_LBUTTON
)
{
MaybeAppendSeparator
(
)
;
AppendLiteral
(
"
MK_LBUTTON
"
)
;
aKeys
&
=
~
MK_LBUTTON
;
}
if
(
aKeys
&
MK_MBUTTON
)
{
MaybeAppendSeparator
(
)
;
AppendLiteral
(
"
MK_MBUTTON
"
)
;
aKeys
&
=
~
MK_MBUTTON
;
}
if
(
aKeys
&
MK_RBUTTON
)
{
MaybeAppendSeparator
(
)
;
AppendLiteral
(
"
MK_RBUTTON
"
)
;
aKeys
&
=
~
MK_RBUTTON
;
}
if
(
aKeys
&
MK_SHIFT
)
{
MaybeAppendSeparator
(
)
;
AppendLiteral
(
"
MK_SHIFT
"
)
;
aKeys
&
=
~
MK_SHIFT
;
}
if
(
aKeys
&
MK_XBUTTON1
)
{
MaybeAppendSeparator
(
)
;
AppendLiteral
(
"
MK_XBUTTON1
"
)
;
aKeys
&
=
~
MK_XBUTTON1
;
}
if
(
aKeys
&
MK_XBUTTON2
)
{
MaybeAppendSeparator
(
)
;
AppendLiteral
(
"
MK_XBUTTON2
"
)
;
aKeys
&
=
~
MK_XBUTTON2
;
}
if
(
aKeys
)
{
MaybeAppendSeparator
(
)
;
AppendPrintf
(
"
Unknown
Flags
(
0x
%
04zX
)
"
aKeys
)
;
}
if
(
IsEmpty
(
)
)
{
AssignLiteral
(
"
none
(
0x0000
)
"
)
;
}
}
private
:
void
MaybeAppendSeparator
(
)
{
if
(
!
IsEmpty
(
)
)
{
AppendLiteral
(
"
|
"
)
;
}
}
}
;
static
const
nsCString
ToString
(
const
MSG
&
aMSG
)
{
nsCString
result
;
result
.
AssignLiteral
(
"
{
message
=
"
)
;
result
.
Append
(
GetMessageName
(
aMSG
.
message
)
.
get
(
)
)
;
result
.
AppendLiteral
(
"
"
)
;
switch
(
aMSG
.
message
)
{
case
WM_KEYDOWN
:
case
WM_KEYUP
:
case
WM_SYSKEYDOWN
:
case
WM_SYSKEYUP
:
result
.
AppendPrintf
(
"
virtual
keycode
=
%
s
repeat
count
=
%
"
PRIdLPTR
"
"
"
scancode
=
0x
%
02X
extended
key
=
%
s
"
"
context
code
=
%
s
previous
key
state
=
%
s
"
"
transition
state
=
%
s
"
GetVirtualKeyCodeName
(
aMSG
.
wParam
)
.
get
(
)
aMSG
.
lParam
&
0xFFFF
WinUtils
:
:
GetScanCode
(
aMSG
.
lParam
)
GetBoolName
(
WinUtils
:
:
IsExtendedScanCode
(
aMSG
.
lParam
)
)
GetBoolName
(
(
aMSG
.
lParam
&
(
1
<
<
29
)
)
!
=
0
)
GetBoolName
(
(
aMSG
.
lParam
&
(
1
<
<
30
)
)
!
=
0
)
GetBoolName
(
(
aMSG
.
lParam
&
(
1
<
<
31
)
)
!
=
0
)
)
;
break
;
case
WM_CHAR
:
case
WM_DEADCHAR
:
case
WM_SYSCHAR
:
case
WM_SYSDEADCHAR
:
result
.
AppendPrintf
(
"
character
code
=
%
s
repeat
count
=
%
"
PRIdLPTR
"
"
"
scancode
=
0x
%
02X
extended
key
=
%
s
"
"
context
code
=
%
s
previous
key
state
=
%
s
"
"
transition
state
=
%
s
"
GetCharacterCodeName
(
aMSG
.
wParam
)
.
get
(
)
aMSG
.
lParam
&
0xFFFF
WinUtils
:
:
GetScanCode
(
aMSG
.
lParam
)
GetBoolName
(
WinUtils
:
:
IsExtendedScanCode
(
aMSG
.
lParam
)
)
GetBoolName
(
(
aMSG
.
lParam
&
(
1
<
<
29
)
)
!
=
0
)
GetBoolName
(
(
aMSG
.
lParam
&
(
1
<
<
30
)
)
!
=
0
)
GetBoolName
(
(
aMSG
.
lParam
&
(
1
<
<
31
)
)
!
=
0
)
)
;
break
;
case
WM_APPCOMMAND
:
result
.
AppendPrintf
(
"
window
handle
=
0x
%
zx
app
command
=
%
s
device
=
%
s
dwKeys
=
%
s
"
aMSG
.
wParam
GetAppCommandName
(
GET_APPCOMMAND_LPARAM
(
aMSG
.
lParam
)
)
.
get
(
)
GetAppCommandDeviceName
(
GET_DEVICE_LPARAM
(
aMSG
.
lParam
)
)
.
get
(
)
GetAppCommandKeysName
(
GET_KEYSTATE_LPARAM
(
aMSG
.
lParam
)
)
.
get
(
)
)
;
break
;
default
:
result
.
AppendPrintf
(
"
wParam
=
%
zu
lParam
=
%
"
PRIdLPTR
aMSG
.
wParam
aMSG
.
lParam
)
;
break
;
}
result
.
AppendPrintf
(
"
hwnd
=
0x
%
p
"
aMSG
.
hwnd
)
;
return
result
;
}
static
const
nsCString
ToString
(
const
UniCharsAndModifiers
&
aUniCharsAndModifiers
)
{
if
(
aUniCharsAndModifiers
.
IsEmpty
(
)
)
{
return
"
{
}
"
_ns
;
}
nsCString
result
;
result
.
AssignLiteral
(
"
{
"
)
;
result
.
Append
(
GetCharacterCodeName
(
aUniCharsAndModifiers
.
CharAt
(
0
)
)
)
;
for
(
size_t
i
=
1
;
i
<
aUniCharsAndModifiers
.
Length
(
)
;
+
+
i
)
{
if
(
aUniCharsAndModifiers
.
ModifiersAt
(
i
-
1
)
!
=
aUniCharsAndModifiers
.
ModifiersAt
(
i
)
)
{
result
.
AppendLiteral
(
"
[
"
)
;
result
.
Append
(
GetModifiersName
(
aUniCharsAndModifiers
.
ModifiersAt
(
0
)
)
)
;
result
.
AppendLiteral
(
"
]
"
)
;
}
result
.
AppendLiteral
(
"
"
)
;
result
.
Append
(
GetCharacterCodeName
(
aUniCharsAndModifiers
.
CharAt
(
i
)
)
)
;
}
result
.
AppendLiteral
(
"
[
"
)
;
uint32_t
lastIndex
=
aUniCharsAndModifiers
.
Length
(
)
-
1
;
result
.
Append
(
GetModifiersName
(
aUniCharsAndModifiers
.
ModifiersAt
(
lastIndex
)
)
)
;
result
.
AppendLiteral
(
"
]
}
"
)
;
return
result
;
}
const
nsCString
ToString
(
const
ModifierKeyState
&
aModifierKeyState
)
{
nsCString
result
;
result
.
AssignLiteral
(
"
{
"
)
;
result
.
Append
(
GetModifiersName
(
aModifierKeyState
.
GetModifiers
(
)
)
.
get
(
)
)
;
result
.
AppendLiteral
(
"
}
"
)
;
return
result
;
}
static
uint32_t
sUniqueKeyEventId
=
0
;
ModifierKeyState
:
:
ModifierKeyState
(
)
{
Update
(
)
;
}
ModifierKeyState
:
:
ModifierKeyState
(
Modifiers
aModifiers
)
:
mModifiers
(
aModifiers
)
{
MOZ_ASSERT
(
!
(
mModifiers
&
MODIFIER_ALTGRAPH
)
|
|
(
!
IsControl
(
)
&
&
!
IsAlt
(
)
)
"
Neither
MODIFIER_CONTROL
nor
MODIFIER_ALT
should
be
set
"
"
if
MODIFIER_ALTGRAPH
is
set
"
)
;
}
void
ModifierKeyState
:
:
Update
(
)
{
mModifiers
=
0
;
if
(
IS_VK_DOWN
(
VK_SHIFT
)
)
{
mModifiers
|
=
MODIFIER_SHIFT
;
}
if
(
IS_VK_DOWN
(
VK_RMENU
)
&
&
KeyboardLayout
:
:
GetInstance
(
)
-
>
HasAltGr
(
)
)
{
mModifiers
|
=
MODIFIER_ALTGRAPH
;
}
else
{
if
(
IS_VK_DOWN
(
VK_CONTROL
)
)
{
mModifiers
|
=
MODIFIER_CONTROL
;
}
if
(
IS_VK_DOWN
(
VK_MENU
)
)
{
mModifiers
|
=
MODIFIER_ALT
;
}
}
if
(
IS_VK_DOWN
(
VK_LWIN
)
|
|
IS_VK_DOWN
(
VK_RWIN
)
)
{
mModifiers
|
=
MODIFIER_META
;
}
if
(
:
:
GetKeyState
(
VK_CAPITAL
)
&
1
)
{
mModifiers
|
=
MODIFIER_CAPSLOCK
;
}
if
(
:
:
GetKeyState
(
VK_NUMLOCK
)
&
1
)
{
mModifiers
|
=
MODIFIER_NUMLOCK
;
}
if
(
:
:
GetKeyState
(
VK_SCROLL
)
&
1
)
{
mModifiers
|
=
MODIFIER_SCROLLLOCK
;
}
}
void
ModifierKeyState
:
:
Unset
(
Modifiers
aRemovingModifiers
)
{
mModifiers
&
=
~
aRemovingModifiers
;
}
void
ModifierKeyState
:
:
Set
(
Modifiers
aAddingModifiers
)
{
mModifiers
|
=
aAddingModifiers
;
MOZ_ASSERT
(
!
(
mModifiers
&
MODIFIER_ALTGRAPH
)
|
|
(
!
IsControl
(
)
&
&
!
IsAlt
(
)
)
"
Neither
MODIFIER_CONTROL
nor
MODIFIER_ALT
should
be
set
"
"
if
MODIFIER_ALTGRAPH
is
set
"
)
;
}
void
ModifierKeyState
:
:
InitInputEvent
(
WidgetInputEvent
&
aInputEvent
)
const
{
aInputEvent
.
mModifiers
=
mModifiers
;
switch
(
aInputEvent
.
mClass
)
{
case
eMouseEventClass
:
case
ePointerEventClass
:
case
eMouseScrollEventClass
:
case
eWheelEventClass
:
case
eDragEventClass
:
case
eSimpleGestureEventClass
:
InitMouseEvent
(
aInputEvent
)
;
break
;
default
:
break
;
}
}
void
ModifierKeyState
:
:
InitMouseEvent
(
WidgetInputEvent
&
aMouseEvent
)
const
{
NS_ASSERTION
(
aMouseEvent
.
mClass
=
=
eMouseEventClass
|
|
aMouseEvent
.
mClass
=
=
ePointerEventClass
|
|
aMouseEvent
.
mClass
=
=
eWheelEventClass
|
|
aMouseEvent
.
mClass
=
=
eDragEventClass
|
|
aMouseEvent
.
mClass
=
=
eSimpleGestureEventClass
"
called
with
non
-
mouse
event
"
)
;
WidgetMouseEventBase
&
mouseEvent
=
*
aMouseEvent
.
AsMouseEventBase
(
)
;
mouseEvent
.
mButtons
=
0
;
if
(
:
:
GetKeyState
(
VK_LBUTTON
)
<
0
)
{
mouseEvent
.
mButtons
|
=
MouseButtonsFlag
:
:
ePrimaryFlag
;
}
if
(
:
:
GetKeyState
(
VK_RBUTTON
)
<
0
)
{
mouseEvent
.
mButtons
|
=
MouseButtonsFlag
:
:
eSecondaryFlag
;
}
if
(
:
:
GetKeyState
(
VK_MBUTTON
)
<
0
)
{
mouseEvent
.
mButtons
|
=
MouseButtonsFlag
:
:
eMiddleFlag
;
}
if
(
:
:
GetKeyState
(
VK_XBUTTON1
)
<
0
)
{
mouseEvent
.
mButtons
|
=
MouseButtonsFlag
:
:
e4thFlag
;
}
if
(
:
:
GetKeyState
(
VK_XBUTTON2
)
<
0
)
{
mouseEvent
.
mButtons
|
=
MouseButtonsFlag
:
:
e5thFlag
;
}
}
bool
ModifierKeyState
:
:
IsShift
(
)
const
{
return
(
mModifiers
&
MODIFIER_SHIFT
)
!
=
0
;
}
bool
ModifierKeyState
:
:
IsControl
(
)
const
{
return
(
mModifiers
&
MODIFIER_CONTROL
)
!
=
0
;
}
bool
ModifierKeyState
:
:
IsAlt
(
)
const
{
return
(
mModifiers
&
MODIFIER_ALT
)
!
=
0
;
}
bool
ModifierKeyState
:
:
IsWin
(
)
const
{
return
(
mModifiers
&
MODIFIER_META
)
!
=
0
;
}
bool
ModifierKeyState
:
:
MaybeMatchShortcutKey
(
)
const
{
if
(
IsWin
(
)
)
{
return
true
;
}
if
(
IsControl
(
)
^
IsAlt
(
)
)
{
return
true
;
}
return
false
;
}
bool
ModifierKeyState
:
:
IsCapsLocked
(
)
const
{
return
(
mModifiers
&
MODIFIER_CAPSLOCK
)
!
=
0
;
}
bool
ModifierKeyState
:
:
IsNumLocked
(
)
const
{
return
(
mModifiers
&
MODIFIER_NUMLOCK
)
!
=
0
;
}
bool
ModifierKeyState
:
:
IsScrollLocked
(
)
const
{
return
(
mModifiers
&
MODIFIER_SCROLLLOCK
)
!
=
0
;
}
void
UniCharsAndModifiers
:
:
Append
(
char16_t
aUniChar
Modifiers
aModifiers
)
{
mChars
.
Append
(
aUniChar
)
;
mModifiers
.
AppendElement
(
aModifiers
)
;
}
void
UniCharsAndModifiers
:
:
FillModifiers
(
Modifiers
aModifiers
)
{
for
(
size_t
i
=
0
;
i
<
Length
(
)
;
i
+
+
)
{
mModifiers
[
i
]
=
aModifiers
;
}
}
void
UniCharsAndModifiers
:
:
OverwriteModifiersIfBeginsWith
(
const
UniCharsAndModifiers
&
aOther
)
{
if
(
!
BeginsWith
(
aOther
)
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
aOther
.
Length
(
)
;
+
+
i
)
{
mModifiers
[
i
]
=
aOther
.
mModifiers
[
i
]
;
}
}
bool
UniCharsAndModifiers
:
:
UniCharsEqual
(
const
UniCharsAndModifiers
&
aOther
)
const
{
return
mChars
.
Equals
(
aOther
.
mChars
)
;
}
bool
UniCharsAndModifiers
:
:
UniCharsCaseInsensitiveEqual
(
const
UniCharsAndModifiers
&
aOther
)
const
{
return
mChars
.
Equals
(
aOther
.
mChars
nsCaseInsensitiveStringComparator
)
;
}
bool
UniCharsAndModifiers
:
:
BeginsWith
(
const
UniCharsAndModifiers
&
aOther
)
const
{
return
StringBeginsWith
(
mChars
aOther
.
mChars
)
;
}
UniCharsAndModifiers
&
UniCharsAndModifiers
:
:
operator
+
=
(
const
UniCharsAndModifiers
&
aOther
)
{
mChars
.
Append
(
aOther
.
mChars
)
;
mModifiers
.
AppendElements
(
aOther
.
mModifiers
)
;
return
*
this
;
}
UniCharsAndModifiers
UniCharsAndModifiers
:
:
operator
+
(
const
UniCharsAndModifiers
&
aOther
)
const
{
UniCharsAndModifiers
result
(
*
this
)
;
result
+
=
aOther
;
return
result
;
}
VirtualKey
:
:
ShiftState
VirtualKey
:
:
ModifiersToShiftState
(
Modifiers
aModifiers
)
{
ShiftState
state
=
0
;
if
(
aModifiers
&
MODIFIER_SHIFT
)
{
state
|
=
STATE_SHIFT
;
}
if
(
aModifiers
&
MODIFIER_ALTGRAPH
)
{
state
|
=
STATE_ALTGRAPH
;
}
else
{
if
(
aModifiers
&
MODIFIER_CONTROL
)
{
state
|
=
STATE_CONTROL
;
}
if
(
aModifiers
&
MODIFIER_ALT
)
{
state
|
=
STATE_ALT
;
}
}
if
(
aModifiers
&
MODIFIER_CAPSLOCK
)
{
state
|
=
STATE_CAPSLOCK
;
}
return
state
;
}
Modifiers
VirtualKey
:
:
ShiftStateToModifiers
(
ShiftState
aShiftState
)
{
Modifiers
modifiers
=
0
;
if
(
aShiftState
&
STATE_SHIFT
)
{
modifiers
|
=
MODIFIER_SHIFT
;
}
if
(
aShiftState
&
STATE_ALTGRAPH
)
{
modifiers
|
=
MODIFIER_ALTGRAPH
;
}
else
{
if
(
aShiftState
&
STATE_CONTROL
)
{
modifiers
|
=
MODIFIER_CONTROL
;
}
if
(
aShiftState
&
STATE_ALT
)
{
modifiers
|
=
MODIFIER_ALT
;
}
}
if
(
aShiftState
&
STATE_CAPSLOCK
)
{
modifiers
|
=
MODIFIER_CAPSLOCK
;
}
return
modifiers
;
}
const
DeadKeyTable
*
VirtualKey
:
:
MatchingDeadKeyTable
(
const
DeadKeyEntry
*
aDeadKeyArray
uint32_t
aEntries
)
const
{
if
(
!
mIsDeadKey
)
{
return
nullptr
;
}
for
(
ShiftState
shiftState
=
0
;
shiftState
<
16
;
shiftState
+
+
)
{
if
(
!
IsDeadKey
(
shiftState
)
)
{
continue
;
}
const
DeadKeyTable
*
dkt
=
mShiftStates
[
shiftState
]
.
DeadKey
.
Table
;
if
(
dkt
&
&
dkt
-
>
IsEqual
(
aDeadKeyArray
aEntries
)
)
{
return
dkt
;
}
}
return
nullptr
;
}
void
VirtualKey
:
:
SetNormalChars
(
ShiftState
aShiftState
const
char16_t
*
aChars
uint32_t
aNumOfChars
)
{
MOZ_ASSERT
(
aShiftState
=
=
ToShiftStateIndex
(
aShiftState
)
)
;
SetDeadKey
(
aShiftState
false
)
;
for
(
uint32_t
index
=
0
;
index
<
aNumOfChars
;
index
+
+
)
{
mShiftStates
[
aShiftState
]
.
Normal
.
Chars
[
index
]
=
(
aChars
[
index
]
>
=
0x20
)
?
aChars
[
index
]
:
0
;
}
uint32_t
len
=
std
:
:
size
(
mShiftStates
[
aShiftState
]
.
Normal
.
Chars
)
;
for
(
uint32_t
index
=
aNumOfChars
;
index
<
len
;
index
+
+
)
{
mShiftStates
[
aShiftState
]
.
Normal
.
Chars
[
index
]
=
0
;
}
}
void
VirtualKey
:
:
SetDeadChar
(
ShiftState
aShiftState
char16_t
aDeadChar
)
{
MOZ_ASSERT
(
aShiftState
=
=
ToShiftStateIndex
(
aShiftState
)
)
;
SetDeadKey
(
aShiftState
true
)
;
mShiftStates
[
aShiftState
]
.
DeadKey
.
DeadChar
=
aDeadChar
;
mShiftStates
[
aShiftState
]
.
DeadKey
.
Table
=
nullptr
;
}
UniCharsAndModifiers
VirtualKey
:
:
GetUniChars
(
ShiftState
aShiftState
)
const
{
UniCharsAndModifiers
result
=
GetNativeUniChars
(
aShiftState
)
;
const
uint8_t
kShiftStateIndex
=
ToShiftStateIndex
(
aShiftState
)
;
if
(
!
(
kShiftStateIndex
&
STATE_CONTROL_ALT
)
)
{
return
result
;
}
if
(
result
.
IsEmpty
(
)
)
{
result
=
GetNativeUniChars
(
kShiftStateIndex
&
~
STATE_CONTROL_ALT
)
;
result
.
FillModifiers
(
ShiftStateToModifiers
(
aShiftState
)
)
;
return
result
;
}
if
(
IsAltGrIndex
(
kShiftStateIndex
)
)
{
Modifiers
finalModifiers
=
ShiftStateToModifiers
(
aShiftState
)
;
finalModifiers
&
=
~
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
finalModifiers
|
=
MODIFIER_ALTGRAPH
;
result
.
FillModifiers
(
finalModifiers
)
;
return
result
;
}
UniCharsAndModifiers
unmodifiedReslt
=
GetNativeUniChars
(
kShiftStateIndex
&
~
STATE_CONTROL_ALT
)
;
if
(
!
result
.
UniCharsEqual
(
unmodifiedReslt
)
)
{
Modifiers
finalModifiers
=
ShiftStateToModifiers
(
aShiftState
)
;
finalModifiers
&
=
~
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
result
.
FillModifiers
(
finalModifiers
)
;
}
return
result
;
}
UniCharsAndModifiers
VirtualKey
:
:
GetNativeUniChars
(
ShiftState
aShiftState
)
const
{
const
uint8_t
kShiftStateIndex
=
ToShiftStateIndex
(
aShiftState
)
;
UniCharsAndModifiers
result
;
Modifiers
modifiers
=
ShiftStateToModifiers
(
aShiftState
)
;
if
(
IsDeadKey
(
aShiftState
)
)
{
result
.
Append
(
mShiftStates
[
kShiftStateIndex
]
.
DeadKey
.
DeadChar
modifiers
)
;
return
result
;
}
uint32_t
len
=
std
:
:
size
(
mShiftStates
[
kShiftStateIndex
]
.
Normal
.
Chars
)
;
for
(
uint32_t
i
=
0
;
i
<
len
&
&
mShiftStates
[
kShiftStateIndex
]
.
Normal
.
Chars
[
i
]
;
i
+
+
)
{
result
.
Append
(
mShiftStates
[
kShiftStateIndex
]
.
Normal
.
Chars
[
i
]
modifiers
)
;
}
return
result
;
}
void
VirtualKey
:
:
FillKbdState
(
PBYTE
aKbdState
const
ShiftState
aShiftState
)
{
if
(
aShiftState
&
STATE_SHIFT
)
{
aKbdState
[
VK_SHIFT
]
|
=
0x80
;
}
else
{
aKbdState
[
VK_SHIFT
]
&
=
~
0x80
;
aKbdState
[
VK_LSHIFT
]
&
=
~
0x80
;
aKbdState
[
VK_RSHIFT
]
&
=
~
0x80
;
}
if
(
aShiftState
&
STATE_ALTGRAPH
)
{
aKbdState
[
VK_CONTROL
]
|
=
0x80
;
aKbdState
[
VK_LCONTROL
]
|
=
0x80
;
aKbdState
[
VK_RCONTROL
]
&
=
~
0x80
;
aKbdState
[
VK_MENU
]
|
=
0x80
;
aKbdState
[
VK_LMENU
]
&
=
~
0x80
;
aKbdState
[
VK_RMENU
]
|
=
0x80
;
}
else
{
if
(
aShiftState
&
STATE_CONTROL
)
{
aKbdState
[
VK_CONTROL
]
|
=
0x80
;
}
else
{
aKbdState
[
VK_CONTROL
]
&
=
~
0x80
;
aKbdState
[
VK_LCONTROL
]
&
=
~
0x80
;
aKbdState
[
VK_RCONTROL
]
&
=
~
0x80
;
}
if
(
aShiftState
&
STATE_ALT
)
{
aKbdState
[
VK_MENU
]
|
=
0x80
;
}
else
{
aKbdState
[
VK_MENU
]
&
=
~
0x80
;
aKbdState
[
VK_LMENU
]
&
=
~
0x80
;
aKbdState
[
VK_RMENU
]
&
=
~
0x80
;
}
}
if
(
aShiftState
&
STATE_CAPSLOCK
)
{
aKbdState
[
VK_CAPITAL
]
|
=
0x01
;
}
else
{
aKbdState
[
VK_CAPITAL
]
&
=
~
0x01
;
}
}
uint8_t
NativeKey
:
:
sDispatchedKeyOfAppCommand
=
0
;
NativeKey
*
NativeKey
:
:
sLatestInstance
=
nullptr
;
const
MSG
NativeKey
:
:
sEmptyMSG
=
{
}
;
MSG
NativeKey
:
:
sLastKeyOrCharMSG
=
{
}
;
MSG
NativeKey
:
:
sLastKeyMSG
=
{
}
;
char16_t
NativeKey
:
:
sPendingHighSurrogate
=
0
;
NativeKey
:
:
NativeKey
(
nsWindow
*
aWidget
const
MSG
&
aMessage
const
ModifierKeyState
&
aModKeyState
HKL
aOverrideKeyboardLayout
nsTArray
<
FakeCharMsg
>
*
aFakeCharMsgs
)
:
mLastInstance
(
sLatestInstance
)
mRemovingMsg
(
sEmptyMSG
)
mReceivedMsg
(
sEmptyMSG
)
mWidget
(
aWidget
)
mDispatcher
(
aWidget
-
>
GetTextEventDispatcher
(
)
)
mMsg
(
aMessage
)
mFocusedWndBeforeDispatch
(
:
:
GetFocus
(
)
)
mDOMKeyCode
(
0
)
mKeyNameIndex
(
KEY_NAME_INDEX_Unidentified
)
mCodeNameIndex
(
CODE_NAME_INDEX_UNKNOWN
)
mModKeyState
(
aModKeyState
)
mVirtualKeyCode
(
0
)
mOriginalVirtualKeyCode
(
0
)
mShiftedLatinChar
(
0
)
mUnshiftedLatinChar
(
0
)
mScanCode
(
0
)
mIsExtended
(
false
)
mIsRepeat
(
false
)
mIsDeadKey
(
false
)
mIsPrintableKey
(
false
)
mIsSkippableInRemoteProcess
(
false
)
mCharMessageHasGone
(
false
)
mCanIgnoreModifierStateAtKeyPress
(
true
)
mFakeCharMsgs
(
aFakeCharMsgs
&
&
aFakeCharMsgs
-
>
Length
(
)
?
aFakeCharMsgs
:
nullptr
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
NativeKey
(
aWidget
=
0x
%
p
{
GetWindowHandle
(
)
=
0x
%
p
}
"
"
aMessage
=
%
s
aModKeyState
=
%
s
)
sLatestInstance
=
0x
%
p
"
this
aWidget
aWidget
-
>
GetWindowHandle
(
)
ToString
(
aMessage
)
.
get
(
)
ToString
(
aModKeyState
)
.
get
(
)
sLatestInstance
)
)
;
MOZ_ASSERT
(
aWidget
)
;
MOZ_ASSERT
(
mDispatcher
)
;
sLatestInstance
=
this
;
KeyboardLayout
*
keyboardLayout
=
KeyboardLayout
:
:
GetInstance
(
)
;
mKeyboardLayout
=
KeyboardLayout
:
:
GetLayout
(
)
;
if
(
aOverrideKeyboardLayout
&
&
mKeyboardLayout
!
=
aOverrideKeyboardLayout
)
{
keyboardLayout
-
>
OverrideLayout
(
aOverrideKeyboardLayout
)
;
mKeyboardLayout
=
keyboardLayout
-
>
GetLoadedLayout
(
)
;
MOZ_ASSERT
(
mKeyboardLayout
=
=
aOverrideKeyboardLayout
)
;
mIsOverridingKeyboardLayout
=
true
;
}
else
{
mIsOverridingKeyboardLayout
=
false
;
sLastKeyOrCharMSG
=
aMessage
;
}
if
(
mMsg
.
message
=
=
WM_APPCOMMAND
)
{
InitWithAppCommand
(
)
;
}
else
{
InitWithKeyOrChar
(
)
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
NativeKey
(
)
mKeyboardLayout
=
0x
%
p
"
"
mFocusedWndBeforeDispatch
=
0x
%
p
mDOMKeyCode
=
%
s
"
"
mKeyNameIndex
=
%
s
mCodeNameIndex
=
%
s
mModKeyState
=
%
s
"
"
mVirtualKeyCode
=
%
s
mOriginalVirtualKeyCode
=
%
s
"
"
mCommittedCharsAndModifiers
=
%
s
mInputtingStringAndModifiers
=
%
s
"
"
mShiftedString
=
%
s
mUnshiftedString
=
%
s
mShiftedLatinChar
=
%
s
"
"
mUnshiftedLatinChar
=
%
s
mScanCode
=
0x
%
04X
mIsExtended
=
%
s
"
"
mIsRepeat
=
%
s
mIsDeadKey
=
%
s
mIsPrintableKey
=
%
s
"
"
mIsSkippableInRemoteProcess
=
%
s
mCharMessageHasGone
=
%
s
"
"
mIsOverridingKeyboardLayout
=
%
s
"
this
mKeyboardLayout
mFocusedWndBeforeDispatch
GetDOMKeyCodeName
(
mDOMKeyCode
)
.
get
(
)
ToString
(
mKeyNameIndex
)
.
get
(
)
ToString
(
mCodeNameIndex
)
.
get
(
)
ToString
(
mModKeyState
)
.
get
(
)
GetVirtualKeyCodeName
(
mVirtualKeyCode
)
.
get
(
)
GetVirtualKeyCodeName
(
mOriginalVirtualKeyCode
)
.
get
(
)
ToString
(
mCommittedCharsAndModifiers
)
.
get
(
)
ToString
(
mInputtingStringAndModifiers
)
.
get
(
)
ToString
(
mShiftedString
)
.
get
(
)
ToString
(
mUnshiftedString
)
.
get
(
)
GetCharacterCodeName
(
mShiftedLatinChar
)
.
get
(
)
GetCharacterCodeName
(
mUnshiftedLatinChar
)
.
get
(
)
mScanCode
GetBoolName
(
mIsExtended
)
GetBoolName
(
mIsRepeat
)
GetBoolName
(
mIsDeadKey
)
GetBoolName
(
mIsPrintableKey
)
GetBoolName
(
mIsSkippableInRemoteProcess
)
GetBoolName
(
mCharMessageHasGone
)
GetBoolName
(
mIsOverridingKeyboardLayout
)
)
)
;
}
void
NativeKey
:
:
InitIsSkippableForKeyOrChar
(
const
MSG
&
aLastKeyMSG
)
{
mIsSkippableInRemoteProcess
=
false
;
if
(
!
mIsRepeat
)
{
return
;
}
if
(
mCodeNameIndex
=
=
CODE_NAME_INDEX_UNKNOWN
)
{
return
;
}
if
(
mOriginalVirtualKeyCode
=
=
VK_PACKET
)
{
return
;
}
switch
(
mMsg
.
message
)
{
case
WM_KEYDOWN
:
case
WM_SYSKEYDOWN
:
case
WM_CHAR
:
case
WM_SYSCHAR
:
case
WM_DEADCHAR
:
case
WM_SYSDEADCHAR
:
switch
(
aLastKeyMSG
.
message
)
{
case
WM_KEYDOWN
:
case
WM_SYSKEYDOWN
:
if
(
aLastKeyMSG
.
wParam
=
=
VK_PACKET
)
{
return
;
}
mIsSkippableInRemoteProcess
=
mScanCode
=
=
WinUtils
:
:
GetScanCode
(
aLastKeyMSG
.
lParam
)
&
&
mIsExtended
=
=
WinUtils
:
:
IsExtendedScanCode
(
aLastKeyMSG
.
lParam
)
;
return
;
default
:
return
;
}
case
WM_APPCOMMAND
:
MOZ_ASSERT_UNREACHABLE
(
"
WM_APPCOMMAND
should
be
handled
in
"
"
InitWithAppCommand
(
)
"
)
;
return
;
default
:
return
;
}
}
void
NativeKey
:
:
InitWithKeyOrChar
(
)
{
MSG
lastKeyMSG
=
sLastKeyMSG
;
char16_t
pendingHighSurrogate
=
sPendingHighSurrogate
;
mScanCode
=
WinUtils
:
:
GetScanCode
(
mMsg
.
lParam
)
;
mIsExtended
=
WinUtils
:
:
IsExtendedScanCode
(
mMsg
.
lParam
)
;
switch
(
mMsg
.
message
)
{
case
WM_KEYDOWN
:
case
WM_SYSKEYDOWN
:
sPendingHighSurrogate
=
0
;
[
[
fallthrough
]
]
;
case
WM_KEYUP
:
case
WM_SYSKEYUP
:
{
sLastKeyMSG
=
mMsg
;
mOriginalVirtualKeyCode
=
static_cast
<
uint8_t
>
(
mMsg
.
wParam
)
;
if
(
!
mScanCode
&
&
mOriginalVirtualKeyCode
!
=
VK_PACKET
)
{
uint16_t
scanCodeEx
=
ComputeScanCodeExFromVirtualKeyCode
(
mMsg
.
wParam
)
;
if
(
scanCodeEx
)
{
mScanCode
=
static_cast
<
uint8_t
>
(
scanCodeEx
&
0xFF
)
;
uint8_t
extended
=
static_cast
<
uint8_t
>
(
(
scanCodeEx
&
0xFF00
)
>
>
8
)
;
mIsExtended
=
(
extended
=
=
0xE0
)
|
|
(
extended
=
=
0xE1
)
;
}
}
bool
isLeftRightDistinguishedKey
=
false
;
switch
(
mOriginalVirtualKeyCode
)
{
case
VK_SHIFT
:
case
VK_CONTROL
:
case
VK_MENU
:
isLeftRightDistinguishedKey
=
true
;
break
;
case
VK_LSHIFT
:
case
VK_RSHIFT
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
;
mOriginalVirtualKeyCode
=
VK_SHIFT
;
isLeftRightDistinguishedKey
=
true
;
break
;
case
VK_LCONTROL
:
case
VK_RCONTROL
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
;
mOriginalVirtualKeyCode
=
VK_CONTROL
;
isLeftRightDistinguishedKey
=
true
;
break
;
case
VK_LMENU
:
case
VK_RMENU
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
;
mOriginalVirtualKeyCode
=
VK_MENU
;
isLeftRightDistinguishedKey
=
true
;
break
;
}
if
(
mVirtualKeyCode
)
{
break
;
}
if
(
!
isLeftRightDistinguishedKey
)
{
break
;
}
NS_ASSERTION
(
!
mVirtualKeyCode
"
mVirtualKeyCode
has
been
computed
already
"
)
;
mVirtualKeyCode
=
ComputeVirtualKeyCodeFromScanCodeEx
(
)
;
switch
(
mOriginalVirtualKeyCode
)
{
case
VK_CONTROL
:
if
(
mVirtualKeyCode
!
=
VK_LCONTROL
&
&
mVirtualKeyCode
!
=
VK_RCONTROL
)
{
mVirtualKeyCode
=
mIsExtended
?
VK_RCONTROL
:
VK_LCONTROL
;
}
break
;
case
VK_MENU
:
if
(
mVirtualKeyCode
!
=
VK_LMENU
&
&
mVirtualKeyCode
!
=
VK_RMENU
)
{
mVirtualKeyCode
=
mIsExtended
?
VK_RMENU
:
VK_LMENU
;
}
break
;
case
VK_SHIFT
:
if
(
mVirtualKeyCode
!
=
VK_LSHIFT
&
&
mVirtualKeyCode
!
=
VK_RSHIFT
)
{
mVirtualKeyCode
=
VK_LSHIFT
;
}
break
;
default
:
MOZ_CRASH
(
"
Unsupported
mOriginalVirtualKeyCode
"
)
;
}
break
;
}
case
WM_CHAR
:
case
WM_UNICHAR
:
case
WM_SYSCHAR
:
sPendingHighSurrogate
=
0
;
if
(
IsAnotherInstanceRemovingCharMessage
(
)
)
{
MOZ_ASSERT
(
IsEmptyMSG
(
mLastInstance
-
>
mReceivedMsg
)
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
InitWithKeyOrChar
(
)
WARNING
detecting
another
"
"
instance
is
trying
to
remove
a
char
message
so
this
instance
"
"
should
do
nothing
mLastInstance
=
0x
%
p
mRemovingMsg
=
%
s
"
"
mReceivedMsg
=
%
s
"
this
mLastInstance
ToString
(
mLastInstance
-
>
mRemovingMsg
)
.
get
(
)
ToString
(
mLastInstance
-
>
mReceivedMsg
)
.
get
(
)
)
)
;
mLastInstance
-
>
mReceivedMsg
=
mMsg
;
return
;
}
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
ComputeVirtualKeyCodeFromScanCodeEx
(
)
;
NS_ASSERTION
(
mVirtualKeyCode
"
Failed
to
compute
virtual
keycode
"
)
;
break
;
default
:
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Unsupported
message
:
0x
%
04X
"
mMsg
.
message
)
;
break
;
}
}
if
(
!
mVirtualKeyCode
)
{
mVirtualKeyCode
=
mOriginalVirtualKeyCode
;
}
KeyboardLayout
*
keyboardLayout
=
KeyboardLayout
:
:
GetInstance
(
)
;
mDOMKeyCode
=
keyboardLayout
-
>
ConvertNativeKeyCodeToDOMKeyCode
(
mVirtualKeyCode
)
;
mKeyNameIndex
=
IsFollowedByPrintableCharMessage
(
)
?
KEY_NAME_INDEX_USE_STRING
:
keyboardLayout
-
>
ConvertNativeKeyCodeToKeyNameIndex
(
mVirtualKeyCode
)
;
mCodeNameIndex
=
KeyboardLayout
:
:
ConvertScanCodeToCodeNameIndex
(
GetScanCodeWithExtendedFlag
(
)
)
;
if
(
(
mMsg
.
message
=
=
WM_KEYDOWN
|
|
mMsg
.
message
=
=
WM_SYSKEYDOWN
)
&
&
!
IsReservedBySystem
(
)
)
{
MSG
charMsg
;
while
(
GetFollowingCharMessage
(
charMsg
)
)
{
if
(
charMsg
.
message
=
=
WM_NULL
)
{
continue
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
InitWithKeyOrChar
(
)
removed
char
message
%
s
"
this
ToString
(
charMsg
)
.
get
(
)
)
)
;
NS_WARNING_ASSERTION
(
charMsg
.
hwnd
=
=
mMsg
.
hwnd
"
The
retrieved
char
message
was
targeted
to
differnet
window
"
)
;
mFollowingCharMsgs
.
AppendElement
(
charMsg
)
;
}
if
(
mFollowingCharMsgs
.
Length
(
)
=
=
1
)
{
if
(
IS_HIGH_SURROGATE
(
mFollowingCharMsgs
[
0
]
.
wParam
)
)
{
if
(
pendingHighSurrogate
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
InitWithKeyOrChar
(
)
there
is
pending
"
"
high
surrogate
input
but
received
another
high
surrogate
"
"
input
.
The
previous
one
is
discarded
"
this
)
)
;
}
sPendingHighSurrogate
=
mFollowingCharMsgs
[
0
]
.
wParam
;
mFollowingCharMsgs
.
Clear
(
)
;
}
else
if
(
IS_LOW_SURROGATE
(
mFollowingCharMsgs
[
0
]
.
wParam
)
)
{
if
(
pendingHighSurrogate
)
{
MSG
charMsg
=
mFollowingCharMsgs
[
0
]
;
mFollowingCharMsgs
[
0
]
.
wParam
=
pendingHighSurrogate
;
mFollowingCharMsgs
.
AppendElement
(
std
:
:
move
(
charMsg
)
)
;
}
else
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
InitWithKeyOrChar
(
)
there
is
no
pending
high
"
"
surrogate
input
but
received
lone
low
surrogate
input
"
this
)
)
;
}
}
else
if
(
MOZ_UNLIKELY
(
pendingHighSurrogate
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
InitWithKeyOrChar
(
)
there
is
pending
"
"
high
surrogate
input
but
received
non
-
surrogate
input
.
"
"
The
high
surrogate
input
is
discarded
"
this
)
)
;
}
}
else
if
(
MOZ_UNLIKELY
(
pendingHighSurrogate
&
&
!
mFollowingCharMsgs
.
IsEmpty
(
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
InitWithKeyOrChar
(
)
there
is
pending
"
"
high
surrogate
input
but
received
2
or
more
character
input
.
"
"
The
high
surrogate
input
is
discarded
"
this
)
)
;
}
}
keyboardLayout
-
>
InitNativeKey
(
*
this
)
;
if
(
MaybeEmulatingAltGraph
(
)
&
&
(
mCommittedCharsAndModifiers
.
IsProducingCharsWithAltGr
(
)
|
|
mKeyNameIndex
=
=
KEY_NAME_INDEX_Dead
)
)
{
mModKeyState
.
Unset
(
MODIFIER_CONTROL
|
MODIFIER_ALT
)
;
mModKeyState
.
Set
(
MODIFIER_ALTGRAPH
)
;
}
mIsDeadKey
=
(
IsFollowedByDeadCharMessage
(
)
|
|
keyboardLayout
-
>
IsDeadKey
(
mOriginalVirtualKeyCode
mModKeyState
)
)
;
mIsPrintableKey
=
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
|
|
KeyboardLayout
:
:
IsPrintableCharKey
(
mOriginalVirtualKeyCode
)
;
mIsRepeat
=
(
mMsg
.
lParam
&
(
1
<
<
30
)
)
!
=
0
;
InitIsSkippableForKeyOrChar
(
lastKeyMSG
)
;
if
(
IsKeyDownMessage
(
)
)
{
if
(
!
IsFollowedByPrintableCharMessage
(
)
)
{
ComputeInputtingStringWithKeyboardLayout
(
)
;
}
RemoveFollowingOddCharMessages
(
)
;
}
}
void
NativeKey
:
:
InitCommittedCharsAndModifiersWithFollowingCharMessages
(
)
{
mCommittedCharsAndModifiers
.
Clear
(
)
;
Modifiers
modifiers
=
mModKeyState
.
GetModifiers
(
)
;
if
(
IsFollowedByPrintableCharMessage
(
)
)
{
modifiers
&
=
~
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
if
(
MaybeEmulatingAltGraph
(
)
)
{
modifiers
|
=
MODIFIER_ALTGRAPH
;
}
}
for
(
size_t
i
=
0
;
i
<
mFollowingCharMsgs
.
Length
(
)
;
+
+
i
)
{
if
(
!
IsPrintableCharOrSysCharMessage
(
mFollowingCharMsgs
[
i
]
)
)
{
continue
;
}
char16_t
ch
=
static_cast
<
char16_t
>
(
mFollowingCharMsgs
[
i
]
.
wParam
)
;
mCommittedCharsAndModifiers
.
Append
(
ch
modifiers
)
;
}
}
NativeKey
:
:
~
NativeKey
(
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
~
NativeKey
(
)
destroyed
"
this
)
)
;
if
(
mIsOverridingKeyboardLayout
)
{
KeyboardLayout
*
keyboardLayout
=
KeyboardLayout
:
:
GetInstance
(
)
;
keyboardLayout
-
>
RestoreLayout
(
)
;
}
sLatestInstance
=
mLastInstance
;
}
void
NativeKey
:
:
InitWithAppCommand
(
)
{
if
(
GET_DEVICE_LPARAM
(
mMsg
.
lParam
)
!
=
FAPPCOMMAND_KEY
)
{
return
;
}
uint32_t
appCommand
=
GET_APPCOMMAND_LPARAM
(
mMsg
.
lParam
)
;
switch
(
GET_APPCOMMAND_LPARAM
(
mMsg
.
lParam
)
)
{
#
undef
NS_APPCOMMAND_TO_DOM_KEY_NAME_INDEX
#
define
NS_APPCOMMAND_TO_DOM_KEY_NAME_INDEX
(
aAppCommand
aKeyNameIndex
)
\
case
aAppCommand
:
\
mKeyNameIndex
=
aKeyNameIndex
;
\
break
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_APPCOMMAND_TO_DOM_KEY_NAME_INDEX
default
:
mKeyNameIndex
=
KEY_NAME_INDEX_Unidentified
;
}
switch
(
appCommand
)
{
case
APPCOMMAND_BROWSER_BACKWARD
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_BACK
;
break
;
case
APPCOMMAND_BROWSER_FORWARD
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_FORWARD
;
break
;
case
APPCOMMAND_BROWSER_REFRESH
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_REFRESH
;
break
;
case
APPCOMMAND_BROWSER_STOP
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_STOP
;
break
;
case
APPCOMMAND_BROWSER_SEARCH
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_SEARCH
;
break
;
case
APPCOMMAND_BROWSER_FAVORITES
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_FAVORITES
;
break
;
case
APPCOMMAND_BROWSER_HOME
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_BROWSER_HOME
;
break
;
case
APPCOMMAND_VOLUME_MUTE
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_VOLUME_MUTE
;
break
;
case
APPCOMMAND_VOLUME_DOWN
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_VOLUME_DOWN
;
break
;
case
APPCOMMAND_VOLUME_UP
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_VOLUME_UP
;
break
;
case
APPCOMMAND_MEDIA_NEXTTRACK
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_MEDIA_NEXT_TRACK
;
break
;
case
APPCOMMAND_MEDIA_PREVIOUSTRACK
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_MEDIA_PREV_TRACK
;
break
;
case
APPCOMMAND_MEDIA_STOP
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_MEDIA_STOP
;
break
;
case
APPCOMMAND_MEDIA_PLAY_PAUSE
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_MEDIA_PLAY_PAUSE
;
break
;
case
APPCOMMAND_LAUNCH_MAIL
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_LAUNCH_MAIL
;
break
;
case
APPCOMMAND_LAUNCH_MEDIA_SELECT
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_LAUNCH_MEDIA_SELECT
;
break
;
case
APPCOMMAND_LAUNCH_APP1
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_LAUNCH_APP1
;
break
;
case
APPCOMMAND_LAUNCH_APP2
:
mVirtualKeyCode
=
mOriginalVirtualKeyCode
=
VK_LAUNCH_APP2
;
break
;
default
:
return
;
}
uint16_t
scanCodeEx
=
ComputeScanCodeExFromVirtualKeyCode
(
mVirtualKeyCode
)
;
mScanCode
=
static_cast
<
uint8_t
>
(
scanCodeEx
&
0xFF
)
;
uint8_t
extended
=
static_cast
<
uint8_t
>
(
(
scanCodeEx
&
0xFF00
)
>
>
8
)
;
mIsExtended
=
(
extended
=
=
0xE0
)
|
|
(
extended
=
=
0xE1
)
;
mDOMKeyCode
=
KeyboardLayout
:
:
GetInstance
(
)
-
>
ConvertNativeKeyCodeToDOMKeyCode
(
mOriginalVirtualKeyCode
)
;
mCodeNameIndex
=
KeyboardLayout
:
:
ConvertScanCodeToCodeNameIndex
(
GetScanCodeWithExtendedFlag
(
)
)
;
if
(
mVirtualKeyCode
)
{
BYTE
kbdState
[
256
]
;
memset
(
kbdState
0
sizeof
(
kbdState
)
)
;
:
:
GetKeyboardState
(
kbdState
)
;
mIsSkippableInRemoteProcess
=
mIsRepeat
=
!
!
kbdState
[
mVirtualKeyCode
]
;
}
}
bool
NativeKey
:
:
MaybeEmulatingAltGraph
(
)
const
{
return
IsControl
(
)
&
&
IsAlt
(
)
&
&
KeyboardLayout
:
:
GetInstance
(
)
-
>
HasAltGr
(
)
;
}
bool
NativeKey
:
:
IsControlChar
(
char16_t
aChar
)
{
static
const
char16_t
U_SPACE
=
0x20
;
static
const
char16_t
U_DELETE
=
0x7F
;
return
aChar
<
U_SPACE
|
|
aChar
=
=
U_DELETE
;
}
bool
NativeKey
:
:
IsFollowedByDeadCharMessage
(
)
const
{
if
(
mFollowingCharMsgs
.
IsEmpty
(
)
)
{
return
false
;
}
return
IsDeadCharMessage
(
mFollowingCharMsgs
[
0
]
)
;
}
bool
NativeKey
:
:
IsFollowedByPrintableCharMessage
(
)
const
{
for
(
size_t
i
=
0
;
i
<
mFollowingCharMsgs
.
Length
(
)
;
+
+
i
)
{
if
(
IsPrintableCharMessage
(
mFollowingCharMsgs
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
bool
NativeKey
:
:
IsFollowedByPrintableCharOrSysCharMessage
(
)
const
{
for
(
size_t
i
=
0
;
i
<
mFollowingCharMsgs
.
Length
(
)
;
+
+
i
)
{
if
(
IsPrintableCharOrSysCharMessage
(
mFollowingCharMsgs
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
bool
NativeKey
:
:
IsReservedBySystem
(
)
const
{
if
(
mModKeyState
.
IsAlt
(
)
&
&
!
mModKeyState
.
IsControl
(
)
&
&
mVirtualKeyCode
=
=
VK_SPACE
)
{
return
true
;
}
return
false
;
}
bool
NativeKey
:
:
IsIMEDoingKakuteiUndo
(
)
const
{
MSG
startCompositionMsg
compositionMsg
charMsg
;
return
WinUtils
:
:
PeekMessage
(
&
startCompositionMsg
mMsg
.
hwnd
WM_IME_STARTCOMPOSITION
WM_IME_STARTCOMPOSITION
PM_NOREMOVE
|
PM_NOYIELD
)
&
&
WinUtils
:
:
PeekMessage
(
&
compositionMsg
mMsg
.
hwnd
WM_IME_COMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
|
PM_NOYIELD
)
&
&
WinUtils
:
:
PeekMessage
(
&
charMsg
mMsg
.
hwnd
WM_CHAR
WM_CHAR
PM_NOREMOVE
|
PM_NOYIELD
)
&
&
startCompositionMsg
.
wParam
=
=
0x0
&
&
startCompositionMsg
.
lParam
=
=
0x0
&
&
compositionMsg
.
wParam
=
=
0x0
&
&
compositionMsg
.
lParam
=
=
0x1BF
&
&
charMsg
.
wParam
=
=
VK_BACK
&
&
charMsg
.
lParam
=
=
0x1
&
&
startCompositionMsg
.
time
<
=
compositionMsg
.
time
&
&
compositionMsg
.
time
<
=
charMsg
.
time
;
}
void
NativeKey
:
:
RemoveFollowingOddCharMessages
(
)
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
)
;
if
(
mFakeCharMsgs
)
{
return
;
}
if
(
!
mFollowingCharMsgs
.
IsEmpty
(
)
)
{
return
;
}
if
(
mOriginalVirtualKeyCode
!
=
VK_BACK
)
{
return
;
}
if
(
!
IsIMEDoingKakuteiUndo
(
)
)
{
return
;
}
MSG
msg
;
while
(
WinUtils
:
:
PeekMessage
(
&
msg
mMsg
.
hwnd
WM_CHAR
WM_CHAR
PM_REMOVE
|
PM_NOYIELD
)
)
{
if
(
msg
.
message
!
=
WM_CHAR
)
{
MOZ_RELEASE_ASSERT
(
msg
.
message
=
=
WM_NULL
"
Unexpected
message
was
removed
"
)
;
continue
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
RemoveFollowingOddCharMessages
(
)
removed
odd
char
"
"
message
%
s
"
this
ToString
(
msg
)
.
get
(
)
)
)
;
mRemovedOddCharMsgs
.
AppendElement
(
msg
)
;
}
}
UINT
NativeKey
:
:
GetScanCodeWithExtendedFlag
(
)
const
{
if
(
!
mIsExtended
)
{
return
mScanCode
;
}
return
(
0xE000
|
mScanCode
)
;
}
uint32_t
NativeKey
:
:
GetKeyLocation
(
)
const
{
switch
(
mVirtualKeyCode
)
{
case
VK_LSHIFT
:
case
VK_LCONTROL
:
case
VK_LMENU
:
case
VK_LWIN
:
return
eKeyLocationLeft
;
case
VK_RSHIFT
:
case
VK_RCONTROL
:
case
VK_RMENU
:
case
VK_RWIN
:
return
eKeyLocationRight
;
case
VK_RETURN
:
return
!
mIsExtended
?
eKeyLocationStandard
:
eKeyLocationNumpad
;
case
VK_INSERT
:
case
VK_DELETE
:
case
VK_END
:
case
VK_DOWN
:
case
VK_NEXT
:
case
VK_LEFT
:
case
VK_CLEAR
:
case
VK_RIGHT
:
case
VK_HOME
:
case
VK_UP
:
case
VK_PRIOR
:
return
mIsExtended
?
eKeyLocationStandard
:
eKeyLocationNumpad
;
case
VK_NUMPAD0
:
case
VK_NUMPAD1
:
case
VK_NUMPAD2
:
case
VK_NUMPAD3
:
case
VK_NUMPAD4
:
case
VK_NUMPAD5
:
case
VK_NUMPAD6
:
case
VK_NUMPAD7
:
case
VK_NUMPAD8
:
case
VK_NUMPAD9
:
case
VK_DECIMAL
:
case
VK_DIVIDE
:
case
VK_MULTIPLY
:
case
VK_SUBTRACT
:
case
VK_ADD
:
case
VK_ABNT_C2
:
return
eKeyLocationNumpad
;
case
VK_SHIFT
:
case
VK_CONTROL
:
case
VK_MENU
:
NS_WARNING
(
"
Failed
to
decide
the
key
location
?
"
)
;
[
[
fallthrough
]
]
;
default
:
return
eKeyLocationStandard
;
}
}
uint8_t
NativeKey
:
:
ComputeVirtualKeyCodeFromScanCode
(
)
const
{
return
static_cast
<
uint8_t
>
(
:
:
MapVirtualKeyEx
(
mScanCode
MAPVK_VSC_TO_VK
mKeyboardLayout
)
)
;
}
uint8_t
NativeKey
:
:
ComputeVirtualKeyCodeFromScanCodeEx
(
)
const
{
return
static_cast
<
uint8_t
>
(
:
:
MapVirtualKeyEx
(
GetScanCodeWithExtendedFlag
(
)
MAPVK_VSC_TO_VK_EX
mKeyboardLayout
)
)
;
}
uint16_t
NativeKey
:
:
ComputeScanCodeExFromVirtualKeyCode
(
UINT
aVirtualKeyCode
)
const
{
return
static_cast
<
uint16_t
>
(
:
:
MapVirtualKeyEx
(
aVirtualKeyCode
MAPVK_VK_TO_VSC_EX
mKeyboardLayout
)
)
;
}
char16_t
NativeKey
:
:
ComputeUnicharFromScanCode
(
)
const
{
return
static_cast
<
char16_t
>
(
:
:
MapVirtualKeyEx
(
ComputeVirtualKeyCodeFromScanCode
(
)
MAPVK_VK_TO_CHAR
mKeyboardLayout
)
)
;
}
nsEventStatus
NativeKey
:
:
InitKeyEvent
(
WidgetKeyboardEvent
&
aKeyEvent
)
const
{
return
InitKeyEvent
(
aKeyEvent
mModKeyState
)
;
}
nsEventStatus
NativeKey
:
:
InitKeyEvent
(
WidgetKeyboardEvent
&
aKeyEvent
const
ModifierKeyState
&
aModKeyState
)
const
{
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_CRASH
(
"
NativeKey
tries
to
dispatch
a
key
event
on
destroyed
widget
"
)
;
}
LayoutDeviceIntPoint
point
(
0
0
)
;
mWidget
-
>
InitEvent
(
aKeyEvent
&
point
)
;
switch
(
aKeyEvent
.
mMessage
)
{
case
eKeyDown
:
if
(
mCharMessageHasGone
|
|
(
IsSysKeyDownMessage
(
)
&
&
mIsPrintableKey
&
&
mFollowingCharMsgs
.
IsEmpty
(
)
)
)
{
aKeyEvent
.
PreventDefaultBeforeDispatch
(
CrossProcessForwarding
:
:
eAllow
)
;
}
aKeyEvent
.
mKeyCode
=
mDOMKeyCode
;
sUniqueKeyEventId
+
+
;
aKeyEvent
.
mUniqueId
=
sUniqueKeyEventId
;
break
;
case
eKeyUp
:
aKeyEvent
.
mKeyCode
=
mDOMKeyCode
;
if
(
mOriginalVirtualKeyCode
=
=
VK_MENU
&
&
mMsg
.
message
!
=
WM_SYSKEYUP
)
{
aKeyEvent
.
PreventDefaultBeforeDispatch
(
CrossProcessForwarding
:
:
eAllow
)
;
}
break
;
case
eKeyPress
:
MOZ_ASSERT
(
!
mCharMessageHasGone
"
If
following
char
message
was
consumed
by
somebody
"
"
keydown
event
should
be
consumed
above
"
)
;
aKeyEvent
.
mUniqueId
=
sUniqueKeyEventId
;
break
;
default
:
MOZ_CRASH
(
"
Invalid
event
message
"
)
;
}
aKeyEvent
.
mIsRepeat
=
mIsRepeat
;
aKeyEvent
.
mMaybeSkippableInRemoteProcess
=
mIsSkippableInRemoteProcess
;
aKeyEvent
.
mKeyNameIndex
=
mKeyNameIndex
;
if
(
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
)
{
aKeyEvent
.
mKeyValue
=
mCommittedCharsAndModifiers
.
ToString
(
)
;
}
aKeyEvent
.
mCodeNameIndex
=
mCodeNameIndex
;
MOZ_ASSERT
(
mCodeNameIndex
!
=
CODE_NAME_INDEX_USE_STRING
)
;
aKeyEvent
.
mLocation
=
GetKeyLocation
(
)
;
aModKeyState
.
InitInputEvent
(
aKeyEvent
)
;
KeyboardLayout
:
:
NotifyIdleServiceOfUserActivity
(
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
InitKeyEvent
(
)
initialized
aKeyEvent
=
{
"
"
mMessage
=
%
s
mKeyNameIndex
=
%
s
mKeyValue
=
\
"
%
s
\
"
mCodeNameIndex
=
%
s
"
"
mKeyCode
=
%
s
mLocation
=
%
s
mModifiers
=
%
s
DefaultPrevented
(
)
=
%
s
}
"
this
ToChar
(
aKeyEvent
.
mMessage
)
ToString
(
aKeyEvent
.
mKeyNameIndex
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aKeyEvent
.
mKeyValue
)
.
get
(
)
ToString
(
aKeyEvent
.
mCodeNameIndex
)
.
get
(
)
GetDOMKeyCodeName
(
aKeyEvent
.
mKeyCode
)
.
get
(
)
GetKeyLocationName
(
aKeyEvent
.
mLocation
)
.
get
(
)
GetModifiersName
(
aKeyEvent
.
mModifiers
)
.
get
(
)
GetBoolName
(
aKeyEvent
.
DefaultPrevented
(
)
)
)
)
;
return
aKeyEvent
.
DefaultPrevented
(
)
?
nsEventStatus_eConsumeNoDefault
:
nsEventStatus_eIgnore
;
}
bool
NativeKey
:
:
DispatchCommandEvent
(
uint32_t
aEventCommand
)
const
{
RefPtr
<
nsAtom
>
command
;
switch
(
aEventCommand
)
{
case
APPCOMMAND_BROWSER_BACKWARD
:
command
=
nsGkAtoms
:
:
Back
;
break
;
case
APPCOMMAND_BROWSER_FORWARD
:
command
=
nsGkAtoms
:
:
Forward
;
break
;
case
APPCOMMAND_BROWSER_REFRESH
:
command
=
nsGkAtoms
:
:
Reload
;
break
;
case
APPCOMMAND_BROWSER_STOP
:
command
=
nsGkAtoms
:
:
Stop
;
break
;
case
APPCOMMAND_BROWSER_SEARCH
:
command
=
nsGkAtoms
:
:
Search
;
break
;
case
APPCOMMAND_BROWSER_FAVORITES
:
command
=
nsGkAtoms
:
:
Bookmarks
;
break
;
case
APPCOMMAND_BROWSER_HOME
:
command
=
nsGkAtoms
:
:
Home
;
break
;
case
APPCOMMAND_CLOSE
:
command
=
nsGkAtoms
:
:
Close
;
break
;
case
APPCOMMAND_FIND
:
command
=
nsGkAtoms
:
:
Find
;
break
;
case
APPCOMMAND_HELP
:
command
=
nsGkAtoms
:
:
Help
;
break
;
case
APPCOMMAND_NEW
:
command
=
nsGkAtoms
:
:
New
;
break
;
case
APPCOMMAND_OPEN
:
command
=
nsGkAtoms
:
:
Open
;
break
;
case
APPCOMMAND_PRINT
:
command
=
nsGkAtoms
:
:
Print
;
break
;
case
APPCOMMAND_SAVE
:
command
=
nsGkAtoms
:
:
Save
;
break
;
case
APPCOMMAND_FORWARD_MAIL
:
command
=
nsGkAtoms
:
:
ForwardMail
;
break
;
case
APPCOMMAND_REPLY_TO_MAIL
:
command
=
nsGkAtoms
:
:
ReplyToMail
;
break
;
case
APPCOMMAND_SEND_MAIL
:
command
=
nsGkAtoms
:
:
SendMail
;
break
;
case
APPCOMMAND_MEDIA_NEXTTRACK
:
command
=
nsGkAtoms
:
:
NextTrack
;
break
;
case
APPCOMMAND_MEDIA_PREVIOUSTRACK
:
command
=
nsGkAtoms
:
:
PreviousTrack
;
break
;
case
APPCOMMAND_MEDIA_STOP
:
command
=
nsGkAtoms
:
:
MediaStop
;
break
;
case
APPCOMMAND_MEDIA_PLAY_PAUSE
:
command
=
nsGkAtoms
:
:
PlayPause
;
break
;
default
:
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchCommandEvent
(
)
doesn
'
t
dispatch
command
"
"
event
"
this
)
)
;
return
false
;
}
WidgetCommandEvent
appCommandEvent
(
true
command
mWidget
)
;
mWidget
-
>
InitEvent
(
appCommandEvent
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchCommandEvent
(
)
dispatching
"
"
%
s
app
command
event
.
.
.
"
this
nsAtomCString
(
command
)
.
get
(
)
)
)
;
bool
ok
=
mWidget
-
>
DispatchWindowEvent
(
appCommandEvent
)
|
|
mWidget
-
>
Destroyed
(
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchCommandEvent
(
)
dispatched
app
command
event
"
"
result
=
%
s
mWidget
-
>
Destroyed
(
)
=
%
s
"
this
GetBoolName
(
ok
)
GetBoolName
(
mWidget
-
>
Destroyed
(
)
)
)
)
;
return
ok
;
}
bool
NativeKey
:
:
HandleAppCommandMessage
(
)
const
{
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
WARNING
not
handled
"
"
due
to
"
"
destroyed
the
widget
"
this
)
)
;
return
false
;
}
bool
dispatchKeyEvent
=
(
GET_DEVICE_LPARAM
(
mMsg
.
lParam
)
=
=
FAPPCOMMAND_KEY
)
;
if
(
dispatchKeyEvent
)
{
dispatchKeyEvent
=
WinUtils
:
:
IsOurProcessWindow
(
reinterpret_cast
<
HWND
>
(
mMsg
.
wParam
)
)
;
}
bool
consumed
=
false
;
if
(
dispatchKeyEvent
)
{
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
FAILED
due
to
"
"
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
initializing
keydown
"
"
event
.
.
.
"
this
)
)
;
WidgetKeyboardEvent
keydownEvent
(
true
eKeyDown
mWidget
)
;
nsEventStatus
status
=
InitKeyEvent
(
keydownEvent
mModKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
tries
to
dispatch
"
"
keydown
event
.
.
.
"
this
)
)
;
if
(
!
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyDown
keydownEvent
status
const_cast
<
NativeKey
*
>
(
this
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
keydown
event
isn
'
t
"
"
dispatched
"
this
)
)
;
return
true
;
}
consumed
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
keydown
event
was
"
"
dispatched
consumed
=
%
s
"
this
GetBoolName
(
consumed
)
)
)
;
sDispatchedKeyOfAppCommand
=
mVirtualKeyCode
;
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
keydown
event
caused
"
"
destroying
the
widget
"
this
)
)
;
return
true
;
}
}
if
(
!
consumed
)
{
uint32_t
appCommand
=
GET_APPCOMMAND_LPARAM
(
mMsg
.
lParam
)
;
EventMessage
contentCommandMessage
=
eVoidEvent
;
switch
(
appCommand
)
{
case
APPCOMMAND_BROWSER_BACKWARD
:
case
APPCOMMAND_BROWSER_FORWARD
:
case
APPCOMMAND_BROWSER_REFRESH
:
case
APPCOMMAND_BROWSER_STOP
:
case
APPCOMMAND_BROWSER_SEARCH
:
case
APPCOMMAND_BROWSER_FAVORITES
:
case
APPCOMMAND_BROWSER_HOME
:
case
APPCOMMAND_CLOSE
:
case
APPCOMMAND_FIND
:
case
APPCOMMAND_HELP
:
case
APPCOMMAND_NEW
:
case
APPCOMMAND_OPEN
:
case
APPCOMMAND_PRINT
:
case
APPCOMMAND_SAVE
:
case
APPCOMMAND_FORWARD_MAIL
:
case
APPCOMMAND_REPLY_TO_MAIL
:
case
APPCOMMAND_SEND_MAIL
:
case
APPCOMMAND_MEDIA_NEXTTRACK
:
case
APPCOMMAND_MEDIA_PREVIOUSTRACK
:
case
APPCOMMAND_MEDIA_STOP
:
case
APPCOMMAND_MEDIA_PLAY_PAUSE
:
consumed
=
DispatchCommandEvent
(
appCommand
)
;
break
;
case
APPCOMMAND_COPY
:
contentCommandMessage
=
eContentCommandCopy
;
break
;
case
APPCOMMAND_CUT
:
contentCommandMessage
=
eContentCommandCut
;
break
;
case
APPCOMMAND_PASTE
:
contentCommandMessage
=
eContentCommandPaste
;
break
;
case
APPCOMMAND_REDO
:
contentCommandMessage
=
eContentCommandRedo
;
break
;
case
APPCOMMAND_UNDO
:
contentCommandMessage
=
eContentCommandUndo
;
break
;
}
if
(
contentCommandMessage
)
{
MOZ_ASSERT
(
!
mWidget
-
>
Destroyed
(
)
)
;
WidgetContentCommandEvent
contentCommandEvent
(
true
contentCommandMessage
mWidget
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
dispatching
%
s
event
.
.
.
"
this
ToChar
(
contentCommandMessage
)
)
)
;
mWidget
-
>
DispatchWindowEvent
(
contentCommandEvent
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
dispatched
%
s
event
"
this
ToChar
(
contentCommandMessage
)
)
)
;
consumed
=
true
;
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
%
s
event
caused
"
"
destroying
the
widget
"
this
ToChar
(
contentCommandMessage
)
)
)
;
return
true
;
}
}
else
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
doesn
'
t
dispatch
"
"
content
"
"
command
event
"
this
)
)
;
}
}
if
(
dispatchKeyEvent
&
&
!
mVirtualKeyCode
)
{
MOZ_ASSERT
(
!
mWidget
-
>
Destroyed
(
)
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
FAILED
due
to
"
"
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
initializing
keyup
"
"
event
.
.
.
"
this
)
)
;
WidgetKeyboardEvent
keyupEvent
(
true
eKeyUp
mWidget
)
;
nsEventStatus
status
=
InitKeyEvent
(
keyupEvent
mModKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
dispatching
keyup
"
"
event
.
.
.
"
this
)
)
;
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyUp
keyupEvent
status
const_cast
<
NativeKey
*
>
(
this
)
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
dispatched
keyup
event
"
this
)
)
;
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleAppCommandMessage
(
)
keyup
event
caused
"
"
destroying
the
widget
"
this
)
)
;
return
true
;
}
}
return
consumed
;
}
bool
NativeKey
:
:
HandleKeyDownMessage
(
bool
*
aEventDispatched
)
const
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
false
;
}
if
(
sDispatchedKeyOfAppCommand
&
&
sDispatchedKeyOfAppCommand
=
=
mOriginalVirtualKeyCode
)
{
sDispatchedKeyOfAppCommand
=
0
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
doesn
'
t
dispatch
keydown
"
"
event
due
to
already
dispatched
from
HandleAppCommandMessage
(
)
"
this
)
)
;
if
(
RedirectedKeyDownMessageManager
:
:
IsRedirectedMessage
(
mMsg
)
)
{
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
}
return
true
;
}
if
(
IsReservedBySystem
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
doesn
'
t
dispatch
keydown
"
"
event
because
the
key
combination
is
reserved
by
the
system
"
this
)
)
;
if
(
RedirectedKeyDownMessageManager
:
:
IsRedirectedMessage
(
mMsg
)
)
{
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
}
return
false
;
}
if
(
sPendingHighSurrogate
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
doesn
'
t
dispatch
keydown
"
"
event
because
the
key
introduced
only
a
high
surrotate
so
we
"
"
should
wait
the
following
low
surrogate
input
"
this
)
)
;
if
(
RedirectedKeyDownMessageManager
:
:
IsRedirectedMessage
(
mMsg
)
)
{
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
}
return
false
;
}
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
WARNING
not
handled
due
to
"
"
destroyed
the
widget
"
this
)
)
;
if
(
RedirectedKeyDownMessageManager
:
:
IsRedirectedMessage
(
mMsg
)
)
{
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
}
return
false
;
}
bool
defaultPrevented
=
false
;
if
(
mFakeCharMsgs
|
|
!
RedirectedKeyDownMessageManager
:
:
IsRedirectedMessage
(
mMsg
)
)
{
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
FAILED
due
to
"
"
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
bool
isIMEEnabled
=
WinUtils
:
:
IsIMEEnabled
(
mWidget
-
>
GetInputContext
(
)
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
initializing
keydown
"
"
event
.
.
.
"
this
)
)
;
WidgetKeyboardEvent
keydownEvent
(
true
eKeyDown
mWidget
)
;
nsEventStatus
status
=
InitKeyEvent
(
keydownEvent
mModKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
dispatching
keydown
event
.
.
.
"
this
)
)
;
bool
dispatched
=
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyDown
keydownEvent
status
const_cast
<
NativeKey
*
>
(
this
)
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
dispatched
;
}
if
(
!
dispatched
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
doesn
'
t
dispatch
keypress
"
"
event
(
s
)
because
keydown
event
isn
'
t
dispatched
actually
"
this
)
)
;
return
false
;
}
defaultPrevented
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
if
(
mWidget
-
>
Destroyed
(
)
|
|
IsFocusedWindowChanged
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
keydown
event
caused
"
"
destroying
the
widget
"
this
)
)
;
return
true
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
dispatched
keydown
event
"
"
dispatched
=
%
s
defaultPrevented
=
%
s
"
this
GetBoolName
(
dispatched
)
GetBoolName
(
defaultPrevented
)
)
)
;
HWND
focusedWnd
=
:
:
GetFocus
(
)
;
if
(
!
defaultPrevented
&
&
!
mFakeCharMsgs
&
&
focusedWnd
&
&
!
isIMEEnabled
&
&
WinUtils
:
:
IsIMEEnabled
(
mWidget
-
>
GetInputContext
(
)
)
)
{
RedirectedKeyDownMessageManager
:
:
RemoveNextCharMessage
(
focusedWnd
)
;
INPUT
keyinput
;
keyinput
.
type
=
INPUT_KEYBOARD
;
keyinput
.
ki
.
wVk
=
mOriginalVirtualKeyCode
;
keyinput
.
ki
.
wScan
=
mScanCode
;
keyinput
.
ki
.
dwFlags
=
KEYEVENTF_SCANCODE
;
if
(
mIsExtended
)
{
keyinput
.
ki
.
dwFlags
|
=
KEYEVENTF_EXTENDEDKEY
;
}
keyinput
.
ki
.
time
=
0
;
keyinput
.
ki
.
dwExtraInfo
=
0
;
RedirectedKeyDownMessageManager
:
:
WillRedirect
(
mMsg
defaultPrevented
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
redirecting
%
s
.
.
.
"
this
ToString
(
mMsg
)
.
get
(
)
)
)
;
:
:
SendInput
(
1
&
keyinput
sizeof
(
keyinput
)
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
redirected
%
s
"
this
ToString
(
mMsg
)
.
get
(
)
)
)
;
return
true
;
}
}
else
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
received
a
redirected
%
s
"
this
ToString
(
mMsg
)
.
get
(
)
)
)
;
defaultPrevented
=
RedirectedKeyDownMessageManager
:
:
DefaultPrevented
(
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
true
;
}
}
RedirectedKeyDownMessageManager
:
:
Forget
(
)
;
MOZ_ASSERT
(
!
mWidget
-
>
Destroyed
(
)
)
;
if
(
mOriginalVirtualKeyCode
=
=
VK_PROCESSKEY
&
&
!
IsFollowedByPrintableCharOrSysCharMessage
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
not
dispatching
keypress
"
"
event
because
the
key
was
already
handled
by
IME
"
"
defaultPrevented
=
%
s
"
this
GetBoolName
(
defaultPrevented
)
)
)
;
return
defaultPrevented
;
}
if
(
defaultPrevented
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
not
dispatching
keypress
"
"
event
because
preceding
keydown
event
was
consumed
"
this
)
)
;
return
true
;
}
MOZ_ASSERT
(
!
mCharMessageHasGone
"
If
following
char
message
was
consumed
by
somebody
"
"
keydown
event
should
have
been
consumed
before
dispatch
"
)
;
if
(
IsFollowedByPrintableCharOrSysCharMessage
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
tries
to
be
dispatching
"
"
keypress
events
with
retrieved
char
messages
.
.
.
"
this
)
)
;
return
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
;
}
if
(
NeedsToHandleWithoutFollowingCharMessages
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
tries
to
be
dispatching
"
"
keypress
events
.
.
.
"
this
)
)
;
return
DispatchKeyPressEventsWithoutCharMessage
(
)
;
}
if
(
mVirtualKeyCode
=
=
VK_PACKET
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
not
dispatching
keypress
"
"
event
"
"
because
the
key
is
VK_PACKET
and
there
are
no
char
messages
"
this
)
)
;
return
false
;
}
if
(
!
mModKeyState
.
IsControl
(
)
&
&
!
mModKeyState
.
IsAlt
(
)
&
&
!
mModKeyState
.
IsWin
(
)
&
&
mIsPrintableKey
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
not
dispatching
keypress
"
"
event
"
"
because
the
key
event
is
simple
printable
key
'
s
event
but
not
"
"
followed
"
"
by
char
messages
"
this
)
)
;
return
false
;
}
if
(
mIsDeadKey
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
not
dispatching
keypress
"
"
event
"
"
because
the
key
is
a
dead
key
and
not
followed
by
char
messages
"
this
)
)
;
return
false
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyDownMessage
(
)
tries
to
be
dispatching
"
"
keypress
events
due
to
no
following
char
messages
.
.
.
"
this
)
)
;
return
DispatchKeyPressEventsWithoutCharMessage
(
)
;
}
bool
NativeKey
:
:
HandleCharMessage
(
bool
*
aEventDispatched
)
const
{
MOZ_ASSERT
(
IsCharOrSysCharMessage
(
mMsg
)
)
;
return
HandleCharMessage
(
mMsg
aEventDispatched
)
;
}
bool
NativeKey
:
:
HandleCharMessage
(
const
MSG
&
aCharMsg
bool
*
aEventDispatched
)
const
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
|
|
IsCharOrSysCharMessage
(
mMsg
)
)
;
MOZ_ASSERT
(
IsCharOrSysCharMessage
(
aCharMsg
.
message
)
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
false
;
}
if
(
(
IsCharOrSysCharMessage
(
mMsg
)
|
|
IsEnterKeyPressCharMessage
(
mMsg
)
)
&
&
IsAnotherInstanceRemovingCharMessage
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
WARNING
does
nothing
because
"
"
the
message
should
be
handled
in
another
instance
removing
this
"
"
message
"
this
)
)
;
return
true
;
}
if
(
IsReservedBySystem
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
doesn
'
t
dispatch
keypress
"
"
event
because
the
key
combination
is
reserved
by
the
system
"
this
)
)
;
return
false
;
}
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
WARNING
not
handled
due
to
"
"
destroyed
the
widget
"
this
)
)
;
return
false
;
}
if
(
IsControlCharMessage
(
aCharMsg
)
&
&
!
IsEnterKeyPressCharMessage
(
aCharMsg
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
doesn
'
t
dispatch
keypress
"
"
event
because
received
a
control
character
input
without
WM_KEYDOWN
"
this
)
)
;
return
false
;
}
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
mWidget
)
;
if
(
IsEnterKeyPressCharMessage
(
aCharMsg
)
)
{
keypressEvent
.
mKeyCode
=
NS_VK_RETURN
;
}
else
{
keypressEvent
.
mCharCode
=
static_cast
<
uint32_t
>
(
aCharMsg
.
wParam
)
;
}
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
FAILED
due
to
"
"
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
initializing
keypress
"
"
event
.
.
.
"
this
)
)
;
ModifierKeyState
modKeyState
(
mModKeyState
)
;
if
(
modKeyState
.
IsControl
(
)
&
&
modKeyState
.
IsAlt
(
)
&
&
IsPrintableCharMessage
(
aCharMsg
)
)
{
modKeyState
.
Unset
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
}
nsEventStatus
status
=
InitKeyEvent
(
keypressEvent
modKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
dispatching
keypress
event
.
.
.
"
this
)
)
;
bool
dispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
const_cast
<
NativeKey
*
>
(
this
)
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
dispatched
;
}
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
keypress
event
caused
"
"
destroying
the
widget
"
this
)
)
;
return
true
;
}
bool
consumed
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleCharMessage
(
)
dispatched
keypress
event
"
"
dispatched
=
%
s
consumed
=
%
s
"
this
GetBoolName
(
dispatched
)
GetBoolName
(
consumed
)
)
)
;
return
consumed
;
}
bool
NativeKey
:
:
HandleKeyUpMessage
(
bool
*
aEventDispatched
)
const
{
MOZ_ASSERT
(
IsKeyUpMessage
(
)
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
false
;
}
if
(
IsReservedBySystem
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
doesn
'
t
dispatch
keyup
"
"
event
because
the
key
combination
is
reserved
by
the
system
"
this
)
)
;
return
false
;
}
if
(
sPendingHighSurrogate
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
doesn
'
t
dispatch
keyup
"
"
event
because
the
key
introduced
only
a
high
surrotate
so
we
"
"
should
wait
the
following
low
surrogate
input
"
this
)
)
;
return
false
;
}
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
WARNING
not
handled
due
to
"
"
destroyed
the
widget
"
this
)
)
;
return
false
;
}
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
FAILED
due
to
"
"
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
initializing
keyup
event
.
.
.
"
this
)
)
;
WidgetKeyboardEvent
keyupEvent
(
true
eKeyUp
mWidget
)
;
nsEventStatus
status
=
InitKeyEvent
(
keyupEvent
mModKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
dispatching
keyup
event
.
.
.
"
this
)
)
;
bool
dispatched
=
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyUp
keyupEvent
status
const_cast
<
NativeKey
*
>
(
this
)
)
;
if
(
aEventDispatched
)
{
*
aEventDispatched
=
dispatched
;
}
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
keyup
event
caused
"
"
destroying
the
widget
"
this
)
)
;
return
true
;
}
bool
consumed
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
HandleKeyUpMessage
(
)
dispatched
keyup
event
"
"
dispatched
=
%
s
consumed
=
%
s
"
this
GetBoolName
(
dispatched
)
GetBoolName
(
consumed
)
)
)
;
return
consumed
;
}
bool
NativeKey
:
:
NeedsToHandleWithoutFollowingCharMessages
(
)
const
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
)
;
if
(
IsReservedBySystem
(
)
)
{
return
true
;
}
if
(
mVirtualKeyCode
=
=
VK_PACKET
)
{
return
false
;
}
if
(
mFollowingCharMsgs
.
Length
(
)
=
=
1
&
&
IsControlCharMessage
(
mFollowingCharMsgs
[
0
]
)
)
{
return
true
;
}
if
(
IsFollowedByPrintableCharOrSysCharMessage
(
)
)
{
return
false
;
}
if
(
!
mModKeyState
.
IsControl
(
)
&
&
!
mModKeyState
.
IsAlt
(
)
&
&
!
mModKeyState
.
IsWin
(
)
)
{
return
false
;
}
if
(
mIsDeadKey
&
&
mCommittedCharsAndModifiers
.
IsEmpty
(
)
)
{
return
false
;
}
return
mIsPrintableKey
;
}
static
nsCString
GetResultOfInSendMessageEx
(
)
{
DWORD
ret
=
:
:
InSendMessageEx
(
nullptr
)
;
if
(
!
ret
)
{
return
"
ISMEX_NOSEND
"
_ns
;
}
nsCString
result
;
if
(
ret
&
ISMEX_CALLBACK
)
{
result
=
"
ISMEX_CALLBACK
"
;
}
if
(
ret
&
ISMEX_NOTIFY
)
{
if
(
!
result
.
IsEmpty
(
)
)
{
result
+
=
"
|
"
;
}
result
+
=
"
ISMEX_NOTIFY
"
;
}
if
(
ret
&
ISMEX_REPLIED
)
{
if
(
!
result
.
IsEmpty
(
)
)
{
result
+
=
"
|
"
;
}
result
+
=
"
ISMEX_REPLIED
"
;
}
if
(
ret
&
ISMEX_SEND
)
{
if
(
!
result
.
IsEmpty
(
)
)
{
result
+
=
"
|
"
;
}
result
+
=
"
ISMEX_SEND
"
;
}
return
result
;
}
bool
NativeKey
:
:
MayBeSameCharMessage
(
const
MSG
&
aCharMsg1
const
MSG
&
aCharMsg2
)
const
{
static
const
LPARAM
kScanCodeMask
=
0x00FF0000
;
return
aCharMsg1
.
message
=
=
aCharMsg2
.
message
&
&
aCharMsg1
.
wParam
=
=
aCharMsg2
.
wParam
&
&
(
aCharMsg1
.
lParam
&
~
kScanCodeMask
)
=
=
(
aCharMsg2
.
lParam
&
~
kScanCodeMask
)
;
}
bool
NativeKey
:
:
IsSamePhysicalKeyMessage
(
const
MSG
&
aKeyOrCharMsg1
const
MSG
&
aKeyOrCharMsg2
)
const
{
if
(
NS_WARN_IF
(
aKeyOrCharMsg1
.
message
<
WM_KEYFIRST
)
|
|
NS_WARN_IF
(
aKeyOrCharMsg1
.
message
>
WM_KEYLAST
)
|
|
NS_WARN_IF
(
aKeyOrCharMsg2
.
message
<
WM_KEYFIRST
)
|
|
NS_WARN_IF
(
aKeyOrCharMsg2
.
message
>
WM_KEYLAST
)
)
{
return
false
;
}
return
WinUtils
:
:
GetScanCode
(
aKeyOrCharMsg1
.
lParam
)
=
=
WinUtils
:
:
GetScanCode
(
aKeyOrCharMsg2
.
lParam
)
&
&
WinUtils
:
:
IsExtendedScanCode
(
aKeyOrCharMsg1
.
lParam
)
=
=
WinUtils
:
:
IsExtendedScanCode
(
aKeyOrCharMsg2
.
lParam
)
;
}
bool
NativeKey
:
:
GetFollowingCharMessage
(
MSG
&
aCharMsg
)
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
)
;
aCharMsg
.
message
=
WM_NULL
;
if
(
mFakeCharMsgs
)
{
for
(
size_t
i
=
0
;
i
<
mFakeCharMsgs
-
>
Length
(
)
;
i
+
+
)
{
FakeCharMsg
&
fakeCharMsg
=
mFakeCharMsgs
-
>
ElementAt
(
i
)
;
if
(
fakeCharMsg
.
mConsumed
)
{
continue
;
}
MSG
charMsg
=
fakeCharMsg
.
GetCharMsg
(
mMsg
.
hwnd
)
;
fakeCharMsg
.
mConsumed
=
true
;
if
(
!
IsCharMessage
(
charMsg
)
)
{
return
false
;
}
aCharMsg
=
charMsg
;
return
true
;
}
return
false
;
}
MSG
nextKeyMsg
;
if
(
!
WinUtils
:
:
PeekMessage
(
&
nextKeyMsg
mMsg
.
hwnd
WM_KEYFIRST
WM_KEYLAST
PM_NOREMOVE
|
PM_NOYIELD
)
|
|
!
IsCharMessage
(
nextKeyMsg
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
there
are
no
char
"
"
messages
"
this
)
)
;
return
false
;
}
const
MSG
kFoundCharMsg
=
nextKeyMsg
;
AutoRestore
<
MSG
>
saveLastRemovingMsg
(
mRemovingMsg
)
;
mRemovingMsg
=
nextKeyMsg
;
mReceivedMsg
=
sEmptyMSG
;
AutoRestore
<
MSG
>
ensureToClearRecivedMsg
(
mReceivedMsg
)
;
for
(
uint32_t
i
=
0
;
i
<
50
;
i
+
+
)
{
MSG
removedMsg
nextKeyMsgInAllWindows
;
bool
doCrash
=
false
;
if
(
!
WinUtils
:
:
PeekMessage
(
&
removedMsg
mMsg
.
hwnd
nextKeyMsg
.
message
nextKeyMsg
.
message
PM_REMOVE
|
PM_NOYIELD
)
)
{
doCrash
=
true
;
if
(
!
IsEmptyMSG
(
mReceivedMsg
)
)
{
if
(
mReceivedMsg
.
hwnd
!
=
nextKeyMsg
.
hwnd
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
received
a
"
"
char
message
during
removing
it
from
the
queue
but
it
'
s
for
"
"
different
window
mReceivedMsg
=
%
s
nextKeyMsg
=
%
s
"
"
kFoundCharMsg
=
%
s
"
this
ToString
(
mReceivedMsg
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
aCharMsg
.
message
=
WM_NULL
;
return
true
;
}
if
(
mReceivedMsg
.
message
!
=
nextKeyMsg
.
message
|
|
mReceivedMsg
.
wParam
!
=
nextKeyMsg
.
wParam
|
|
mReceivedMsg
.
lParam
!
=
nextKeyMsg
.
lParam
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
received
a
"
"
char
message
during
removing
it
from
the
queue
but
it
'
s
"
"
differnt
from
what
trying
to
remove
from
the
queue
"
"
aCharMsg
=
%
s
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
mReceivedMsg
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
}
else
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
succeeded
to
"
"
retrieve
next
char
message
via
another
instance
aCharMsg
=
%
s
"
"
kFoundCharMsg
=
%
s
"
this
ToString
(
mReceivedMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
}
aCharMsg
=
mReceivedMsg
;
return
true
;
}
if
(
!
WinUtils
:
:
PeekMessage
(
&
nextKeyMsgInAllWindows
0
WM_KEYFIRST
WM_KEYLAST
PM_NOREMOVE
|
PM_NOYIELD
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
but
it
'
s
already
gone
from
all
message
"
"
queues
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
return
true
;
}
if
(
nextKeyMsgInAllWindows
.
hwnd
!
=
mMsg
.
hwnd
)
{
aCharMsg
=
nextKeyMsgInAllWindows
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
but
found
in
another
message
queue
"
"
nextKeyMsgInAllWindows
=
%
s
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsgInAllWindows
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
return
true
;
}
if
(
!
IsCharMessage
(
nextKeyMsgInAllWindows
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
and
next
key
message
becomes
non
-
char
"
"
message
nextKeyMsgInAllWindows
=
%
s
nextKeyMsg
=
%
s
"
"
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsgInAllWindows
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
mCharMessageHasGone
)
;
mFollowingCharMsgs
.
Clear
(
)
;
mCharMessageHasGone
=
true
;
return
false
;
}
if
(
!
IsSamePhysicalKeyMessage
(
nextKeyMsgInAllWindows
kFoundCharMsg
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
and
next
key
message
becomes
differnt
"
"
key
'
s
char
message
nextKeyMsgInAllWindows
=
%
s
nextKeyMsg
=
%
s
"
"
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsgInAllWindows
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
mCharMessageHasGone
)
;
mFollowingCharMsgs
.
Clear
(
)
;
mCharMessageHasGone
=
true
;
return
false
;
}
if
(
nextKeyMsgInAllWindows
.
message
!
=
nextKeyMsg
.
message
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
due
to
message
change
let
'
s
retry
to
"
"
remove
the
message
with
newly
found
char
message
"
"
nextKeyMsgInAllWindows
=
%
s
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsgInAllWindows
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
nextKeyMsg
=
nextKeyMsgInAllWindows
;
continue
;
}
if
(
WinUtils
:
:
GetMessage
(
&
removedMsg
mMsg
.
hwnd
nextKeyMsg
.
message
nextKeyMsg
.
message
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
but
succeeded
with
GetMessage
(
)
"
"
removedMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
removedMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
doCrash
=
false
;
}
else
if
(
i
>
0
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
but
removed
%
d
WM_NULL
messages
"
this
i
)
)
;
MOZ_ASSERT
(
!
mCharMessageHasGone
)
;
mFollowingCharMsgs
.
Clear
(
)
;
mCharMessageHasGone
=
true
;
return
false
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
FAILED
lost
target
"
"
message
to
remove
nextKeyMsg
=
%
s
"
this
ToString
(
nextKeyMsg
)
.
get
(
)
)
)
;
}
if
(
doCrash
)
{
nsPrintfCString
info
(
"
\
nPeekMessage
(
)
failed
to
remove
char
message
!
"
"
\
nActive
keyboard
layout
=
0x
%
p
(
%
s
)
"
"
\
nHandling
message
:
%
s
InSendMessageEx
(
)
=
%
s
"
"
\
nFound
message
:
%
s
"
"
\
nWM_NULL
has
been
removed
:
%
d
"
"
\
nNext
key
message
in
all
windows
:
%
s
"
"
time
=
%
ld
"
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLoadedLayout
(
)
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLoadedLayoutName
(
)
.
get
(
)
ToString
(
mMsg
)
.
get
(
)
GetResultOfInSendMessageEx
(
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
i
ToString
(
nextKeyMsgInAllWindows
)
.
get
(
)
nextKeyMsgInAllWindows
.
time
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
info
)
;
MSG
nextMsg
;
if
(
WinUtils
:
:
PeekMessage
(
&
nextMsg
0
0
0
PM_NOREMOVE
|
PM_NOYIELD
)
)
{
nsPrintfCString
info
(
"
\
nNext
message
in
all
windows
:
%
s
time
=
%
ld
"
ToString
(
nextMsg
)
.
get
(
)
nextMsg
.
time
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
info
)
;
}
else
{
CrashReporter
:
:
AppendAppNotesToCrashReport
(
"
\
nThere
is
no
message
in
any
window
"
_ns
)
;
}
MOZ_CRASH
(
"
We
lost
the
following
char
message
"
)
;
}
if
(
removedMsg
.
message
=
=
WM_NULL
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
instead
removed
WM_NULL
message
"
"
removedMsg
=
%
s
"
this
ToString
(
removedMsg
)
.
get
(
)
)
)
;
MSG
newNextKeyMsg
;
if
(
!
WinUtils
:
:
PeekMessage
(
&
newNextKeyMsg
mMsg
.
hwnd
WM_KEYFIRST
WM_KEYLAST
PM_NOREMOVE
|
PM_NOYIELD
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
because
it
'
s
gone
during
removing
it
from
"
"
the
queue
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
mCharMessageHasGone
)
;
mFollowingCharMsgs
.
Clear
(
)
;
mCharMessageHasGone
=
true
;
return
false
;
}
if
(
!
IsCharMessage
(
newNextKeyMsg
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
failed
to
"
"
remove
a
char
message
because
it
'
s
gone
during
removing
it
from
"
"
the
queue
nextKeyMsg
=
%
s
newNextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
newNextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
mCharMessageHasGone
)
;
mFollowingCharMsgs
.
Clear
(
)
;
mCharMessageHasGone
=
true
;
return
false
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
there
is
the
message
"
"
which
is
being
tried
to
be
removed
from
the
queue
trying
again
.
.
.
"
this
)
)
;
continue
;
}
if
(
removedMsg
.
message
!
=
WM_DEADCHAR
&
&
removedMsg
.
message
=
=
nextKeyMsg
.
message
&
&
!
removedMsg
.
wParam
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
succeeded
to
"
"
remove
a
char
message
but
the
removed
message
'
s
wParam
is
0
"
"
removedMsg
=
%
s
"
this
ToString
(
removedMsg
)
.
get
(
)
)
)
;
return
false
;
}
if
(
MayBeSameCharMessage
(
removedMsg
nextKeyMsg
)
)
{
aCharMsg
=
removedMsg
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
succeeded
to
retrieve
"
"
next
char
message
aCharMsg
=
%
s
"
this
ToString
(
aCharMsg
)
.
get
(
)
)
)
;
return
true
;
}
if
(
IsCharMessage
(
removedMsg
)
&
&
IsSamePhysicalKeyMessage
(
removedMsg
nextKeyMsg
)
)
{
aCharMsg
=
removedMsg
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
succeeded
to
"
"
remove
a
char
message
but
the
removed
message
was
changed
from
"
"
the
found
message
except
their
scancode
aCharMsg
=
%
s
"
"
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
aCharMsg
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
return
true
;
}
if
(
IsCharMessage
(
removedMsg
)
&
&
!
nextKeyMsg
.
wParam
&
&
WinUtils
:
:
GetScanCode
(
nextKeyMsg
.
lParam
)
=
=
0xFF
)
{
aCharMsg
=
removedMsg
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
succeeded
to
"
"
remove
a
char
message
but
the
removed
message
was
changed
from
"
"
the
found
message
but
the
found
message
was
odd
so
ignoring
the
"
"
odd
found
message
and
respecting
the
removed
message
aCharMsg
=
%
s
"
"
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
aCharMsg
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
return
true
;
}
const
auto
nextKeyMsgAfter
=
[
&
]
(
)
-
>
Maybe
<
MSG
>
{
MSG
nextKeyMsgAfter
;
if
(
WinUtils
:
:
PeekMessage
(
&
nextKeyMsgAfter
mMsg
.
hwnd
WM_KEYFIRST
WM_KEYLAST
PM_NOREMOVE
|
PM_NOYIELD
)
)
{
return
Some
(
nextKeyMsgAfter
)
;
}
return
Nothing
(
)
;
}
(
)
;
if
(
IsDeadCharMessage
(
removedMsg
.
message
)
&
&
!
removedMsg
.
wParam
&
&
!
WinUtils
:
:
GetScanCode
(
removedMsg
.
lParam
)
&
&
nextKeyMsgAfter
.
isSome
(
)
&
&
MayBeSameCharMessage
(
nextKeyMsgAfter
.
ref
(
)
nextKeyMsg
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
WARNING
succeeded
to
"
"
remove
a
dead
char
message
but
the
removed
message
'
s
wParam
is
0
"
"
and
the
found
message
still
in
the
queue
nextKeyMsg
=
%
s
but
"
"
removedMsg
=
%
s
"
this
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
removedMsg
)
.
get
(
)
)
)
;
return
false
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
FAILED
removed
message
"
"
is
really
different
from
what
we
have
already
found
removedMsg
=
%
s
"
"
nextKeyMsg
=
%
s
kFoundCharMsg
=
%
s
"
this
ToString
(
removedMsg
)
.
get
(
)
ToString
(
nextKeyMsg
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
)
;
nsPrintfCString
info
(
"
\
nPeekMessage
(
)
removed
unexpcted
char
message
!
"
"
\
nActive
keyboard
layout
=
0x
%
p
(
%
s
)
"
"
\
nHandling
message
:
%
s
InSendMessageEx
(
)
=
%
s
"
"
\
nFound
message
:
%
s
"
"
\
nRemoved
message
:
%
s
"
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLoadedLayout
(
)
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLoadedLayoutName
(
)
.
get
(
)
ToString
(
mMsg
)
.
get
(
)
GetResultOfInSendMessageEx
(
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
ToString
(
removedMsg
)
.
get
(
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
info
)
;
if
(
nextKeyMsgAfter
.
isSome
(
)
)
{
nsPrintfCString
info
(
"
\
nNext
key
message
after
unexpected
char
message
"
"
removed
:
%
s
"
ToString
(
nextKeyMsgAfter
.
ref
(
)
)
.
get
(
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
info
)
;
}
else
{
CrashReporter
:
:
AppendAppNotesToCrashReport
(
nsLiteralCString
(
"
\
nThere
is
no
key
message
after
unexpected
char
"
"
message
removed
"
)
)
;
}
if
(
WinUtils
:
:
PeekMessage
(
&
nextKeyMsgInAllWindows
0
WM_KEYFIRST
WM_KEYLAST
PM_NOREMOVE
|
PM_NOYIELD
)
)
{
nsPrintfCString
info
(
"
\
nNext
key
message
in
all
windows
:
%
s
.
"
ToString
(
nextKeyMsgInAllWindows
)
.
get
(
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
info
)
;
}
else
{
CrashReporter
:
:
AppendAppNotesToCrashReport
(
"
\
nThere
is
no
key
message
in
any
windows
.
"
_ns
)
;
}
MOZ_CRASH
(
"
PeekMessage
(
)
removed
unexpected
message
"
)
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
GetFollowingCharMessage
(
)
FAILED
removed
messages
"
"
are
all
WM_NULL
nextKeyMsg
=
%
s
"
this
ToString
(
nextKeyMsg
)
.
get
(
)
)
)
;
nsPrintfCString
info
(
"
\
nWe
lost
following
char
message
!
"
"
\
nActive
keyboard
layout
=
0x
%
p
(
%
s
)
"
"
\
nHandling
message
:
%
s
InSendMessageEx
(
)
=
%
s
\
n
"
"
Found
message
:
%
s
removed
a
lot
of
WM_NULL
"
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLoadedLayout
(
)
KeyboardLayout
:
:
GetInstance
(
)
-
>
GetLoadedLayoutName
(
)
.
get
(
)
ToString
(
mMsg
)
.
get
(
)
GetResultOfInSendMessageEx
(
)
.
get
(
)
ToString
(
kFoundCharMsg
)
.
get
(
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
info
)
;
MOZ_CRASH
(
"
We
lost
the
following
char
message
"
)
;
return
false
;
}
void
NativeKey
:
:
ComputeInputtingStringWithKeyboardLayout
(
)
{
KeyboardLayout
*
keyboardLayout
=
KeyboardLayout
:
:
GetInstance
(
)
;
if
(
KeyboardLayout
:
:
IsPrintableCharKey
(
mVirtualKeyCode
)
|
|
mCharMessageHasGone
)
{
mInputtingStringAndModifiers
=
mCommittedCharsAndModifiers
;
}
else
{
mInputtingStringAndModifiers
.
Clear
(
)
;
}
mShiftedString
.
Clear
(
)
;
mUnshiftedString
.
Clear
(
)
;
mShiftedLatinChar
=
mUnshiftedLatinChar
=
0
;
if
(
!
mModKeyState
.
IsControl
(
)
&
&
!
mModKeyState
.
IsAlt
(
)
)
{
return
;
}
if
(
MaybeTypingUnicodeScalarValue
(
)
)
{
if
(
!
mCommittedCharsAndModifiers
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
mMsg
.
message
=
=
WM_SYSKEYDOWN
)
;
char16_t
num
=
mCommittedCharsAndModifiers
.
CharAt
(
0
)
;
MOZ_ASSERT
(
num
>
=
'
0
'
&
&
num
<
=
'
9
'
)
;
mUnshiftedString
.
Append
(
num
MODIFIER_NONE
)
;
return
;
}
MOZ_ASSERT
(
!
KeyboardLayout
:
:
IsPrintableCharKey
(
mVirtualKeyCode
)
)
;
return
;
}
ModifierKeyState
capsLockState
(
mModKeyState
.
GetModifiers
(
)
&
MODIFIER_CAPSLOCK
)
;
mUnshiftedString
=
keyboardLayout
-
>
GetUniCharsAndModifiers
(
mVirtualKeyCode
capsLockState
)
;
capsLockState
.
Set
(
MODIFIER_SHIFT
)
;
mShiftedString
=
keyboardLayout
-
>
GetUniCharsAndModifiers
(
mVirtualKeyCode
capsLockState
)
;
capsLockState
.
Unset
(
MODIFIER_SHIFT
)
;
WidgetUtils
:
:
GetLatinCharCodeForKeyCode
(
mDOMKeyCode
capsLockState
.
GetModifiers
(
)
&
mUnshiftedLatinChar
&
mShiftedLatinChar
)
;
if
(
mShiftedLatinChar
)
{
if
(
mUnshiftedLatinChar
=
=
mUnshiftedString
.
CharAt
(
0
)
&
&
mShiftedLatinChar
=
=
mShiftedString
.
CharAt
(
0
)
)
{
mShiftedLatinChar
=
mUnshiftedLatinChar
=
0
;
}
}
else
if
(
mUnshiftedLatinChar
)
{
if
(
mUnshiftedLatinChar
=
=
mUnshiftedString
.
CharAt
(
0
)
|
|
mUnshiftedLatinChar
=
=
mShiftedString
.
CharAt
(
0
)
)
{
mUnshiftedLatinChar
=
0
;
}
}
if
(
!
mModKeyState
.
IsControl
(
)
)
{
return
;
}
uint32_t
ch
=
mModKeyState
.
IsShift
(
)
?
mShiftedLatinChar
:
mUnshiftedLatinChar
;
if
(
!
ch
)
{
return
;
}
if
(
mInputtingStringAndModifiers
.
IsEmpty
(
)
|
|
mInputtingStringAndModifiers
.
UniCharsCaseInsensitiveEqual
(
mModKeyState
.
IsShift
(
)
?
mShiftedString
:
mUnshiftedString
)
)
{
mInputtingStringAndModifiers
.
Clear
(
)
;
mInputtingStringAndModifiers
.
Append
(
ch
mModKeyState
.
GetModifiers
(
)
)
;
}
}
bool
NativeKey
:
:
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
const
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
)
;
MOZ_ASSERT
(
IsFollowedByPrintableCharOrSysCharMessage
(
)
)
;
MOZ_ASSERT
(
!
mWidget
-
>
Destroyed
(
)
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
mWidget
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
"
"
initializing
keypress
event
.
.
.
"
this
)
)
;
ModifierKeyState
modKeyState
(
mModKeyState
)
;
if
(
mCanIgnoreModifierStateAtKeyPress
&
&
IsFollowedByPrintableCharMessage
(
)
)
{
modKeyState
.
Unset
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
}
bool
needsCallback
=
mFollowingCharMsgs
.
Length
(
)
>
1
;
nsEventStatus
status
=
InitKeyEvent
(
keypressEvent
modKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
"
"
dispatching
keypress
event
(
s
)
.
.
.
"
this
)
)
;
bool
dispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
const_cast
<
NativeKey
*
>
(
this
)
needsCallback
)
;
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
"
"
keypress
event
(
s
)
caused
destroying
the
widget
"
this
)
)
;
return
true
;
}
bool
consumed
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithRetrievedCharMessages
(
)
"
"
dispatched
keypress
event
(
s
)
dispatched
=
%
s
consumed
=
%
s
"
this
GetBoolName
(
dispatched
)
GetBoolName
(
consumed
)
)
)
;
return
consumed
;
}
bool
NativeKey
:
:
DispatchKeyPressEventsWithoutCharMessage
(
)
const
{
MOZ_ASSERT
(
IsKeyDownMessage
(
)
)
;
MOZ_ASSERT
(
!
mIsDeadKey
|
|
!
mCommittedCharsAndModifiers
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mWidget
-
>
Destroyed
(
)
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithoutCharMessage
(
)
"
"
FAILED
due
"
"
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
true
;
}
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
mWidget
)
;
if
(
mInputtingStringAndModifiers
.
IsEmpty
(
)
&
&
mShiftedString
.
IsEmpty
(
)
&
&
mUnshiftedString
.
IsEmpty
(
)
)
{
keypressEvent
.
mKeyCode
=
mDOMKeyCode
;
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Debug
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithoutCharMessage
(
)
"
"
initializing
"
"
keypress
event
.
.
.
"
this
)
)
;
nsEventStatus
status
=
InitKeyEvent
(
keypressEvent
mModKeyState
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithoutCharMessage
(
)
"
"
dispatching
"
"
keypress
event
(
s
)
.
.
.
"
this
)
)
;
bool
dispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
const_cast
<
NativeKey
*
>
(
this
)
)
;
if
(
mWidget
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithoutCharMessage
(
)
"
"
keypress
event
(
s
)
caused
destroying
the
widget
"
this
)
)
;
return
true
;
}
bool
consumed
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
DispatchKeyPressEventsWithoutCharMessage
(
)
dispatched
"
"
keypress
event
(
s
)
dispatched
=
%
s
consumed
=
%
s
"
this
GetBoolName
(
dispatched
)
GetBoolName
(
consumed
)
)
)
;
return
consumed
;
}
void
NativeKey
:
:
WillDispatchKeyboardEvent
(
WidgetKeyboardEvent
&
aKeyboardEvent
uint32_t
aIndex
)
{
if
(
aKeyboardEvent
.
mMessage
=
=
eKeyPress
&
&
IsFollowedByPrintableCharOrSysCharMessage
(
)
)
{
MOZ_RELEASE_ASSERT
(
aIndex
<
mCommittedCharsAndModifiers
.
Length
(
)
)
;
uint32_t
foundPrintableCharMessages
=
0
;
for
(
size_t
i
=
0
;
i
<
mFollowingCharMsgs
.
Length
(
)
;
+
+
i
)
{
if
(
!
IsPrintableCharOrSysCharMessage
(
mFollowingCharMsgs
[
i
]
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Warning
(
"
%
p
NativeKey
:
:
WillDispatchKeyboardEvent
(
)
WARNING
"
"
ignoring
%
zuth
message
due
to
non
-
printable
char
message
%
s
"
this
i
+
1
ToString
(
mFollowingCharMsgs
[
i
]
)
.
get
(
)
)
)
;
continue
;
}
if
(
foundPrintableCharMessages
+
+
=
=
aIndex
)
{
break
;
}
}
if
(
mCanIgnoreModifierStateAtKeyPress
)
{
ModifierKeyState
modKeyState
(
mModKeyState
)
;
modKeyState
.
Unset
(
MODIFIER_SHIFT
|
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_ALTGRAPH
|
MODIFIER_CAPSLOCK
)
;
modKeyState
.
Set
(
mCommittedCharsAndModifiers
.
ModifiersAt
(
aIndex
)
)
;
modKeyState
.
InitInputEvent
(
aKeyboardEvent
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
WillDispatchKeyboardEvent
(
)
"
"
setting
%
uth
modifier
state
to
%
s
"
this
aIndex
+
1
ToString
(
modKeyState
)
.
get
(
)
)
)
;
}
}
size_t
longestLength
=
std
:
:
max
(
mInputtingStringAndModifiers
.
Length
(
)
std
:
:
max
(
mShiftedString
.
Length
(
)
mUnshiftedString
.
Length
(
)
)
)
;
size_t
skipUniChars
=
longestLength
-
mInputtingStringAndModifiers
.
Length
(
)
;
size_t
skipShiftedChars
=
longestLength
-
mShiftedString
.
Length
(
)
;
size_t
skipUnshiftedChars
=
longestLength
-
mUnshiftedString
.
Length
(
)
;
if
(
aIndex
>
=
longestLength
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
WillDispatchKeyboardEvent
(
)
does
nothing
for
%
uth
"
"
%
s
event
"
this
aIndex
+
1
ToChar
(
aKeyboardEvent
.
mMessage
)
)
)
;
return
;
}
bool
isLastIndex
=
aKeyboardEvent
.
mMessage
!
=
eKeyPress
|
|
mCommittedCharsAndModifiers
.
IsEmpty
(
)
|
|
mCommittedCharsAndModifiers
.
Length
(
)
-
1
=
=
aIndex
;
nsTArray
<
AlternativeCharCode
>
&
altArray
=
aKeyboardEvent
.
mAlternativeCharCodes
;
if
(
aKeyboardEvent
.
mMessage
=
=
eKeyPress
&
&
skipUniChars
<
=
aIndex
)
{
if
(
aIndex
-
skipUniChars
<
mInputtingStringAndModifiers
.
Length
(
)
)
{
ModifierKeyState
modKeyState
(
mModKeyState
)
;
modKeyState
.
Unset
(
MODIFIER_SHIFT
|
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_ALTGRAPH
|
MODIFIER_CAPSLOCK
)
;
modKeyState
.
Set
(
mInputtingStringAndModifiers
.
ModifiersAt
(
aIndex
-
skipUniChars
)
)
;
modKeyState
.
InitInputEvent
(
aKeyboardEvent
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
WillDispatchKeyboardEvent
(
)
"
"
setting
%
uth
modifier
state
to
%
s
"
this
aIndex
+
1
ToString
(
modKeyState
)
.
get
(
)
)
)
;
}
uint16_t
uniChar
=
mInputtingStringAndModifiers
.
CharAt
(
aIndex
-
skipUniChars
)
;
aKeyboardEvent
.
SetCharCode
(
uniChar
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
%
p
NativeKey
:
:
WillDispatchKeyboardEvent
(
)
"
"
setting
%
uth
charCode
to
%
s
"
this
aIndex
+
1
GetCharacterCodeName
(
uniChar
)
.
get
(
)
)
)
;
}
size_t
count
;
if
(
aKeyboardEvent
.
mMessage
=
=
eKeyPress
)
{
count
=
1
;
if
(
isLastIndex
)
{
count
=
longestLength
-
aIndex
;
}
}
else
{
count
=
longestLength
;
}
for
(
size_t
i
=
0
;
i
<
count
;
+
+
i
)
{
uint16_t
shiftedChar
=
0
unshiftedChar
=
0
;
if
(
skipShiftedChars
<
=
aIndex
+
i
)
{
shiftedChar
=
mShiftedString
.
CharAt
(
aIndex
+
i
-
skipShiftedChars
)
;
}
if
(
skipUnshiftedChars
<
=
aIndex
+
i
)
{
unshiftedChar
=
mUnshiftedString
.
CharAt
(
aIndex
+
i
-
skipUnshiftedChars
)
;
}
if
(
shiftedChar
|
|
unshiftedChar
)
{
AlternativeCharCode
chars
(
unshiftedChar
shiftedChar
)
;
altArray
.
AppendElement
(
chars
)
;
}
if
(
!
isLastIndex
)
{
continue
;
}
if
(
mUnshiftedLatinChar
|
|
mShiftedLatinChar
)
{
AlternativeCharCode
chars
(
mUnshiftedLatinChar
mShiftedLatinChar
)
;
altArray
.
AppendElement
(
chars
)
;
}
char16_t
charForOEMKeyCode
=
0
;
switch
(
mVirtualKeyCode
)
{
case
VK_OEM_PLUS
:
charForOEMKeyCode
=
'
+
'
;
break
;
case
VK_OEM_COMMA
:
charForOEMKeyCode
=
'
'
;
break
;
case
VK_OEM_MINUS
:
charForOEMKeyCode
=
'
-
'
;
break
;
case
VK_OEM_PERIOD
:
charForOEMKeyCode
=
'
.
'
;
break
;
}
if
(
charForOEMKeyCode
&
&
charForOEMKeyCode
!
=
mUnshiftedString
.
CharAt
(
0
)
&
&
charForOEMKeyCode
!
=
mShiftedString
.
CharAt
(
0
)
&
&
charForOEMKeyCode
!
=
mUnshiftedLatinChar
&
&
charForOEMKeyCode
!
=
mShiftedLatinChar
)
{
AlternativeCharCode
OEMChars
(
charForOEMKeyCode
charForOEMKeyCode
)
;
altArray
.
AppendElement
(
OEMChars
)
;
}
}
}
KeyboardLayout
*
KeyboardLayout
:
:
sInstance
=
nullptr
;
StaticRefPtr
<
nsIUserIdleServiceInternal
>
KeyboardLayout
:
:
sIdleService
;
KeyboardLayout
*
KeyboardLayout
:
:
GetInstance
(
)
{
if
(
!
sInstance
)
{
sInstance
=
new
KeyboardLayout
(
)
;
}
return
sInstance
;
}
void
KeyboardLayout
:
:
Shutdown
(
)
{
delete
sInstance
;
sInstance
=
nullptr
;
sIdleService
=
nullptr
;
}
void
KeyboardLayout
:
:
NotifyIdleServiceOfUserActivity
(
)
{
if
(
!
sIdleService
)
{
sIdleService
=
nsCOMPtr
<
nsIUserIdleServiceInternal
>
(
do_GetService
(
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
)
)
.
forget
(
)
;
if
(
NS_WARN_IF
(
!
sIdleService
)
)
{
return
;
}
}
sIdleService
-
>
ResetIdleTimeOut
(
0
)
;
}
KeyboardLayout
:
:
KeyboardLayout
(
)
{
mDeadKeyTableListHead
=
nullptr
;
mActiveDeadKeys
.
SetCapacity
(
4
)
;
mDeadKeyShiftStates
.
SetCapacity
(
4
)
;
if
(
StaticPrefs
:
:
ui_key_layout_load_when_first_needed
(
)
)
{
OnLayoutChange
(
:
:
GetKeyboardLayout
(
0
)
)
;
}
}
KeyboardLayout
:
:
~
KeyboardLayout
(
)
{
ReleaseDeadKeyTables
(
)
;
}
bool
KeyboardLayout
:
:
IsPrintableCharKey
(
uint8_t
aVirtualKey
)
{
return
GetKeyIndex
(
aVirtualKey
)
>
=
0
;
}
WORD
KeyboardLayout
:
:
ComputeScanCodeForVirtualKeyCode
(
uint8_t
aVirtualKeyCode
)
const
{
return
static_cast
<
WORD
>
(
:
:
MapVirtualKeyEx
(
aVirtualKeyCode
MAPVK_VK_TO_VSC
KeyboardLayout
:
:
GetLayout
(
)
)
)
;
}
bool
KeyboardLayout
:
:
IsDeadKey
(
uint8_t
aVirtualKey
const
ModifierKeyState
&
aModKeyState
)
const
{
int32_t
virtualKeyIndex
=
GetKeyIndex
(
aVirtualKey
)
;
if
(
virtualKeyIndex
<
0
)
{
return
false
;
}
return
mVirtualKeys
[
virtualKeyIndex
]
.
IsDeadKey
(
VirtualKey
:
:
ModifiersToShiftState
(
aModKeyState
.
GetModifiers
(
)
)
)
;
}
bool
KeyboardLayout
:
:
IsSysKey
(
uint8_t
aVirtualKey
const
ModifierKeyState
&
aModKeyState
)
const
{
if
(
!
aModKeyState
.
IsAlt
(
)
|
|
aModKeyState
.
IsControl
(
)
)
{
return
false
;
}
int32_t
virtualKeyIndex
=
GetKeyIndex
(
aVirtualKey
)
;
if
(
virtualKeyIndex
<
0
)
{
return
true
;
}
UniCharsAndModifiers
inputCharsAndModifiers
=
GetUniCharsAndModifiers
(
aVirtualKey
aModKeyState
)
;
if
(
inputCharsAndModifiers
.
IsEmpty
(
)
)
{
return
true
;
}
return
!
!
(
inputCharsAndModifiers
.
ModifiersAt
(
0
)
&
MODIFIER_ALT
)
;
}
void
KeyboardLayout
:
:
InitNativeKey
(
NativeKey
&
aNativeKey
)
{
if
(
mIsPendingToRestoreKeyboardLayout
)
{
LoadLayout
(
:
:
GetKeyboardLayout
(
0
)
)
;
}
if
(
aNativeKey
.
mMsg
.
message
=
=
WM_CHAR
)
{
char16_t
ch
=
static_cast
<
char16_t
>
(
aNativeKey
.
mMsg
.
wParam
)
;
if
(
!
NativeKey
:
:
IsControlChar
(
ch
)
)
{
aNativeKey
.
mKeyNameIndex
=
KEY_NAME_INDEX_USE_STRING
;
Modifiers
modifiers
=
aNativeKey
.
GetModifiers
(
)
&
~
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
aNativeKey
.
mCommittedCharsAndModifiers
.
Append
(
ch
modifiers
)
;
return
;
}
}
if
(
aNativeKey
.
MaybeTypingUnicodeScalarValue
(
)
&
&
KeyboardLayout
:
:
IsPrintableCharKey
(
aNativeKey
.
mVirtualKeyCode
)
)
{
char16_t
num
=
'
0
'
;
if
(
aNativeKey
.
mVirtualKeyCode
>
=
VK_NUMPAD0
&
&
aNativeKey
.
mVirtualKeyCode
<
=
VK_NUMPAD9
)
{
num
=
'
0
'
+
aNativeKey
.
mVirtualKeyCode
-
VK_NUMPAD0
;
}
else
{
switch
(
aNativeKey
.
mScanCode
)
{
case
0x0052
:
num
=
'
0
'
;
break
;
case
0x004F
:
num
=
'
1
'
;
break
;
case
0x0050
:
num
=
'
2
'
;
break
;
case
0x0051
:
num
=
'
3
'
;
break
;
case
0x004B
:
num
=
'
4
'
;
break
;
case
0x004C
:
num
=
'
5
'
;
break
;
case
0x004D
:
num
=
'
6
'
;
break
;
case
0x0047
:
num
=
'
7
'
;
break
;
case
0x0048
:
num
=
'
8
'
;
break
;
case
0x0049
:
num
=
'
9
'
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
IsTypingUnicodeScalarValue
(
)
must
have
returned
true
for
wrong
"
"
scancode
"
)
;
break
;
}
}
aNativeKey
.
mCommittedCharsAndModifiers
.
Append
(
num
aNativeKey
.
GetModifiers
(
)
)
;
aNativeKey
.
mKeyNameIndex
=
KEY_NAME_INDEX_USE_STRING
;
return
;
}
if
(
aNativeKey
.
IsFollowedByPrintableCharOrSysCharMessage
(
)
|
|
aNativeKey
.
mCharMessageHasGone
)
{
MOZ_ASSERT
(
!
aNativeKey
.
IsCharMessage
(
aNativeKey
.
mMsg
)
)
;
if
(
aNativeKey
.
IsFollowedByPrintableCharOrSysCharMessage
(
)
)
{
aNativeKey
.
InitCommittedCharsAndModifiersWithFollowingCharMessages
(
)
;
MOZ_ASSERT
(
!
aNativeKey
.
mCommittedCharsAndModifiers
.
IsEmpty
(
)
)
;
if
(
IsPrintableCharKey
(
aNativeKey
.
mOriginalVirtualKeyCode
)
&
&
(
aNativeKey
.
IsControl
(
)
^
aNativeKey
.
IsAlt
(
)
)
)
{
ModifierKeyState
state
=
aNativeKey
.
ModifierKeyStateRef
(
)
;
state
.
Unset
(
MODIFIER_ALT
|
MODIFIER_CONTROL
)
;
UniCharsAndModifiers
charsWithoutModifier
=
GetUniCharsAndModifiers
(
aNativeKey
.
GenericVirtualKeyCode
(
)
state
)
;
aNativeKey
.
mCanIgnoreModifierStateAtKeyPress
=
!
charsWithoutModifier
.
UniCharsEqual
(
aNativeKey
.
mCommittedCharsAndModifiers
)
;
}
}
else
{
aNativeKey
.
mCommittedCharsAndModifiers
.
Clear
(
)
;
}
aNativeKey
.
mKeyNameIndex
=
KEY_NAME_INDEX_USE_STRING
;
if
(
!
IsInDeadKeySequence
(
)
)
{
return
;
}
UniCharsAndModifiers
deadChars
=
GetDeadUniCharsAndModifiers
(
)
;
aNativeKey
.
mCommittedCharsAndModifiers
.
OverwriteModifiersIfBeginsWith
(
deadChars
)
;
DeactivateDeadKeyState
(
)
;
return
;
}
if
(
MaybeInitNativeKeyAsDeadKey
(
aNativeKey
)
)
{
return
;
}
if
(
!
IsPrintableCharKey
(
aNativeKey
.
mOriginalVirtualKeyCode
)
)
{
return
;
}
MOZ_ASSERT
(
aNativeKey
.
mOriginalVirtualKeyCode
!
=
VK_PACKET
"
At
handling
VK_PACKET
we
shouldn
'
t
refer
keyboard
layout
"
)
;
MOZ_ASSERT
(
aNativeKey
.
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
"
Printable
key
'
s
key
name
index
must
be
KEY_NAME_INDEX_USE_STRING
"
)
;
if
(
MaybeInitNativeKeyWithCompositeChar
(
aNativeKey
)
)
{
return
;
}
UniCharsAndModifiers
baseChars
=
GetUniCharsAndModifiers
(
aNativeKey
)
;
if
(
!
IsInDeadKeySequence
(
)
)
{
aNativeKey
.
mCommittedCharsAndModifiers
=
baseChars
;
return
;
}
UniCharsAndModifiers
deadChars
=
GetDeadUniCharsAndModifiers
(
)
;
aNativeKey
.
mCommittedCharsAndModifiers
=
deadChars
+
baseChars
;
if
(
aNativeKey
.
IsKeyDownMessage
(
)
)
{
DeactivateDeadKeyState
(
)
;
}
}
bool
KeyboardLayout
:
:
MaybeInitNativeKeyAsDeadKey
(
NativeKey
&
aNativeKey
)
{
if
(
!
IsInDeadKeySequence
(
)
&
&
!
IsDeadKey
(
aNativeKey
)
)
{
return
false
;
}
const
bool
isDeadKeyDownEvent
=
aNativeKey
.
IsKeyDownMessage
(
)
&
&
aNativeKey
.
IsFollowedByDeadCharMessage
(
)
;
const
bool
isDeadKeyUpEvent
=
!
aNativeKey
.
IsKeyDownMessage
(
)
&
&
mActiveDeadKeys
.
Contains
(
aNativeKey
.
GenericVirtualKeyCode
(
)
)
;
if
(
isDeadKeyDownEvent
|
|
isDeadKeyUpEvent
)
{
ActivateDeadKeyState
(
aNativeKey
)
;
aNativeKey
.
mCommittedCharsAndModifiers
.
Clear
(
)
;
aNativeKey
.
mKeyNameIndex
=
KEY_NAME_INDEX_Dead
;
return
true
;
}
if
(
!
IsInDeadKeySequence
(
)
)
{
aNativeKey
.
mCommittedCharsAndModifiers
=
GetUniCharsAndModifiers
(
aNativeKey
)
;
return
true
;
}
if
(
!
IsDeadKey
(
aNativeKey
)
)
{
return
false
;
}
if
(
MaybeInitNativeKeyWithCompositeChar
(
aNativeKey
)
)
{
return
true
;
}
UniCharsAndModifiers
prevDeadChars
=
GetDeadUniCharsAndModifiers
(
)
;
UniCharsAndModifiers
newChars
=
GetUniCharsAndModifiers
(
aNativeKey
)
;
aNativeKey
.
mCommittedCharsAndModifiers
=
prevDeadChars
+
newChars
;
if
(
aNativeKey
.
IsKeyDownMessage
(
)
)
{
DeactivateDeadKeyState
(
)
;
}
return
true
;
}
bool
KeyboardLayout
:
:
MaybeInitNativeKeyWithCompositeChar
(
NativeKey
&
aNativeKey
)
{
if
(
!
IsInDeadKeySequence
(
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
IsPrintableCharKey
(
aNativeKey
.
mOriginalVirtualKeyCode
)
)
)
{
return
false
;
}
UniCharsAndModifiers
baseChars
=
GetUniCharsAndModifiers
(
aNativeKey
)
;
if
(
baseChars
.
IsEmpty
(
)
|
|
!
baseChars
.
CharAt
(
0
)
)
{
return
false
;
}
char16_t
compositeChar
=
GetCompositeChar
(
baseChars
.
CharAt
(
0
)
)
;
if
(
!
compositeChar
)
{
return
false
;
}
aNativeKey
.
mCommittedCharsAndModifiers
.
Append
(
compositeChar
baseChars
.
ModifiersAt
(
0
)
)
;
if
(
aNativeKey
.
IsKeyDownMessage
(
)
)
{
DeactivateDeadKeyState
(
)
;
}
return
true
;
}
UniCharsAndModifiers
KeyboardLayout
:
:
GetUniCharsAndModifiers
(
uint8_t
aVirtualKey
VirtualKey
:
:
ShiftState
aShiftState
)
const
{
UniCharsAndModifiers
result
;
int32_t
key
=
GetKeyIndex
(
aVirtualKey
)
;
if
(
key
<
0
)
{
return
result
;
}
return
mVirtualKeys
[
key
]
.
GetUniChars
(
aShiftState
)
;
}
UniCharsAndModifiers
KeyboardLayout
:
:
GetDeadUniCharsAndModifiers
(
)
const
{
MOZ_RELEASE_ASSERT
(
mActiveDeadKeys
.
Length
(
)
=
=
mDeadKeyShiftStates
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
mActiveDeadKeys
.
IsEmpty
(
)
)
)
{
return
UniCharsAndModifiers
(
)
;
}
UniCharsAndModifiers
result
;
for
(
size_t
i
=
0
;
i
<
mActiveDeadKeys
.
Length
(
)
;
+
+
i
)
{
result
+
=
GetUniCharsAndModifiers
(
mActiveDeadKeys
[
i
]
mDeadKeyShiftStates
[
i
]
)
;
}
return
result
;
}
char16_t
KeyboardLayout
:
:
GetCompositeChar
(
char16_t
aBaseChar
)
const
{
if
(
NS_WARN_IF
(
mActiveDeadKeys
.
IsEmpty
(
)
)
)
{
return
0
;
}
if
(
mActiveDeadKeys
.
Length
(
)
>
1
)
{
return
0
;
}
int32_t
key
=
GetKeyIndex
(
mActiveDeadKeys
[
0
]
)
;
if
(
key
<
0
)
{
return
0
;
}
return
mVirtualKeys
[
key
]
.
GetCompositeChar
(
mDeadKeyShiftStates
[
0
]
aBaseChar
)
;
}
static
bool
IsValidKeyboardLayoutsChild
(
const
nsAString
&
aChildName
)
{
if
(
aChildName
.
Length
(
)
!
=
8
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aChildName
.
Length
(
)
;
i
+
+
)
{
if
(
(
aChildName
[
i
]
>
=
'
0
'
&
&
aChildName
[
i
]
<
=
'
9
'
)
|
|
(
aChildName
[
i
]
>
=
'
a
'
&
&
aChildName
[
i
]
<
=
'
f
'
)
|
|
(
aChildName
[
i
]
>
=
'
A
'
&
&
aChildName
[
i
]
<
=
'
F
'
)
)
{
continue
;
}
return
false
;
}
return
true
;
}
nsCString
KeyboardLayout
:
:
GetLayoutName
(
HKL
aLayout
)
{
constexpr
auto
kKeyboardLayouts
=
u
"
SYSTEM
\
\
CurrentControlSet
\
\
Control
\
\
Keyboard
Layouts
\
\
"
_ns
;
uint16_t
language
=
reinterpret_cast
<
uintptr_t
>
(
aLayout
)
&
0xFFFF
;
uint16_t
layout
=
(
reinterpret_cast
<
uintptr_t
>
(
aLayout
)
>
>
16
)
&
0xFFFF
;
if
(
layout
<
0xA000
|
|
(
layout
&
0xF000
)
=
=
0xE000
)
{
nsAutoString
key
(
kKeyboardLayouts
)
;
key
.
AppendPrintf
(
"
%
08
"
PRIXPTR
layout
<
0xA000
?
layout
:
reinterpret_cast
<
uintptr_t
>
(
aLayout
)
)
;
wchar_t
buf
[
256
]
;
if
(
NS_WARN_IF
(
!
WinRegistry
:
:
GetString
(
HKEY_LOCAL_MACHINE
key
u
"
Layout
Text
"
_ns
buf
WinRegistry
:
:
kLegacyWinUtilsStringFlags
)
)
)
{
return
"
No
name
or
too
long
name
"
_ns
;
}
return
NS_ConvertUTF16toUTF8
(
buf
)
;
}
if
(
NS_WARN_IF
(
(
layout
&
0xF000
)
!
=
0xF000
)
)
{
nsCString
result
;
result
.
AppendPrintf
(
"
Odd
HKL
:
0x
%
08
"
PRIXPTR
reinterpret_cast
<
uintptr_t
>
(
aLayout
)
)
;
return
result
;
}
WinRegistry
:
:
Key
regKey
(
HKEY_LOCAL_MACHINE
kKeyboardLayouts
WinRegistry
:
:
KeyMode
:
:
Read
)
;
if
(
NS_WARN_IF
(
!
regKey
)
)
{
return
"
"
_ns
;
}
uint32_t
childCount
=
regKey
.
GetChildCount
(
)
;
if
(
NS_WARN_IF
(
!
childCount
)
)
{
return
"
"
_ns
;
}
for
(
uint32_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
nsAutoString
childName
;
if
(
NS_WARN_IF
(
!
regKey
.
GetChildName
(
i
childName
)
)
|
|
!
IsValidKeyboardLayoutsChild
(
childName
)
)
{
continue
;
}
nsresult
rv
=
NS_OK
;
uint32_t
childNum
=
static_cast
<
uint32_t
>
(
childName
.
ToInteger64
(
&
rv
16
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
if
(
childNum
<
=
0xFFFF
)
{
continue
;
}
if
(
(
childNum
&
0xFFFF
)
!
=
language
&
&
(
childNum
&
0xF0000000
)
!
=
0xA0000000
)
{
continue
;
}
nsAutoString
key
(
kKeyboardLayouts
)
;
key
+
=
childName
;
WinRegistry
:
:
Key
regKey
(
HKEY_LOCAL_MACHINE
key
WinRegistry
:
:
KeyMode
:
:
QueryValue
)
;
if
(
NS_WARN_IF
(
!
regKey
)
)
{
continue
;
}
wchar_t
buf
[
256
]
;
if
(
NS_WARN_IF
(
!
regKey
.
GetValueAsString
(
u
"
Layout
Id
"
_ns
buf
WinRegistry
:
:
kLegacyWinUtilsStringFlags
)
)
)
{
continue
;
}
uint16_t
layoutId
=
wcstol
(
buf
nullptr
16
)
;
if
(
layoutId
!
=
(
layout
&
0x0FFF
)
)
{
continue
;
}
if
(
NS_WARN_IF
(
!
regKey
.
GetValueAsString
(
u
"
Layout
Text
"
_ns
buf
WinRegistry
:
:
kLegacyWinUtilsStringFlags
)
)
)
{
continue
;
}
return
NS_ConvertUTF16toUTF8
(
buf
)
;
}
return
"
"
_ns
;
}
void
KeyboardLayout
:
:
LoadLayout
(
HKL
aLayout
)
{
mIsPendingToRestoreKeyboardLayout
=
false
;
if
(
mKeyboardLayout
=
=
aLayout
)
{
return
;
}
mKeyboardLayout
=
aLayout
;
mHasAltGr
=
false
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
KeyboardLayout
:
:
LoadLayout
(
aLayout
=
0x
%
p
(
%
s
)
)
"
aLayout
GetLayoutName
(
aLayout
)
.
get
(
)
)
)
;
BYTE
kbdState
[
256
]
;
memset
(
kbdState
0
sizeof
(
kbdState
)
)
;
BYTE
originalKbdState
[
256
]
;
uint16_t
shiftStatesWithDeadKeys
=
0
;
uint16_t
shiftStatesWithBaseChars
=
0
;
mActiveDeadKeys
.
Clear
(
)
;
mDeadKeyShiftStates
.
Clear
(
)
;
ReleaseDeadKeyTables
(
)
;
:
:
GetKeyboardState
(
originalKbdState
)
;
for
(
VirtualKey
:
:
ShiftState
shiftState
=
0
;
shiftState
<
16
;
shiftState
+
+
)
{
VirtualKey
:
:
FillKbdState
(
kbdState
shiftState
)
;
bool
isAltGr
=
VirtualKey
:
:
IsAltGrIndex
(
shiftState
)
;
for
(
uint32_t
virtualKey
=
0
;
virtualKey
<
256
;
virtualKey
+
+
)
{
int32_t
vki
=
GetKeyIndex
(
virtualKey
)
;
if
(
vki
<
0
)
{
continue
;
}
NS_ASSERTION
(
uint32_t
(
vki
)
<
std
:
:
size
(
mVirtualKeys
)
"
invalid
index
"
)
;
char16_t
uniChars
[
5
]
;
int32_t
ret
=
:
:
ToUnicodeEx
(
virtualKey
0
kbdState
(
LPWSTR
)
uniChars
std
:
:
size
(
uniChars
)
0
mKeyboardLayout
)
;
if
(
ret
<
0
)
{
shiftStatesWithDeadKeys
|
=
(
1
<
<
shiftState
)
;
char16_t
deadChar
[
2
]
;
ret
=
:
:
ToUnicodeEx
(
virtualKey
0
kbdState
(
LPWSTR
)
deadChar
std
:
:
size
(
deadChar
)
0
mKeyboardLayout
)
;
NS_ASSERTION
(
ret
=
=
2
"
Expecting
twice
repeated
dead
-
key
character
"
)
;
mVirtualKeys
[
vki
]
.
SetDeadChar
(
shiftState
deadChar
[
0
]
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Verbose
(
"
%
s
(
%
d
)
:
DeadChar
(
%
s
%
s
)
(
ret
=
%
d
)
"
kVirtualKeyName
[
virtualKey
]
vki
GetShiftStateName
(
shiftState
)
.
get
(
)
GetCharacterCodeNames
(
deadChar
1
)
.
get
(
)
ret
)
)
;
}
else
{
if
(
ret
=
=
1
)
{
shiftStatesWithBaseChars
|
=
(
1
<
<
shiftState
)
;
}
mVirtualKeys
[
vki
]
.
SetNormalChars
(
shiftState
uniChars
ret
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Verbose
(
"
%
s
(
%
d
)
:
NormalChar
(
%
s
%
s
)
(
ret
=
%
d
)
"
kVirtualKeyName
[
virtualKey
]
vki
GetShiftStateName
(
shiftState
)
.
get
(
)
GetCharacterCodeNames
(
uniChars
ret
)
.
get
(
)
ret
)
)
;
}
if
(
!
mHasAltGr
&
&
ret
>
0
&
&
isAltGr
&
&
mVirtualKeys
[
vki
]
.
IsChangedByAltGr
(
shiftState
)
)
{
mHasAltGr
=
true
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
Found
a
key
(
%
s
)
changed
by
AltGr
:
%
s
-
>
%
s
(
%
s
)
(
ret
=
%
d
)
"
kVirtualKeyName
[
virtualKey
]
GetCharacterCodeNames
(
mVirtualKeys
[
vki
]
.
GetNativeUniChars
(
shiftState
-
VirtualKey
:
:
ShiftStateIndex
:
:
eAltGr
)
)
.
get
(
)
GetCharacterCodeNames
(
mVirtualKeys
[
vki
]
.
GetNativeUniChars
(
shiftState
)
)
.
get
(
)
GetShiftStateName
(
shiftState
)
.
get
(
)
ret
)
)
;
}
}
}
for
(
VirtualKey
:
:
ShiftState
shiftState
=
0
;
shiftState
<
16
;
shiftState
+
+
)
{
if
(
!
(
shiftStatesWithDeadKeys
&
(
1
<
<
shiftState
)
)
)
{
continue
;
}
VirtualKey
:
:
FillKbdState
(
kbdState
shiftState
)
;
for
(
uint32_t
virtualKey
=
0
;
virtualKey
<
256
;
virtualKey
+
+
)
{
int32_t
vki
=
GetKeyIndex
(
virtualKey
)
;
if
(
vki
>
=
0
&
&
mVirtualKeys
[
vki
]
.
IsDeadKey
(
shiftState
)
)
{
AutoTArray
<
DeadKeyEntry
256
>
deadKeyArray
;
uint32_t
n
=
GetDeadKeyCombinations
(
virtualKey
kbdState
shiftStatesWithBaseChars
deadKeyArray
)
;
const
DeadKeyTable
*
dkt
=
mVirtualKeys
[
vki
]
.
MatchingDeadKeyTable
(
deadKeyArray
.
Elements
(
)
n
)
;
if
(
!
dkt
)
{
dkt
=
AddDeadKeyTable
(
deadKeyArray
.
Elements
(
)
n
)
;
}
mVirtualKeys
[
vki
]
.
AttachDeadKeyTable
(
shiftState
dkt
)
;
}
}
}
:
:
SetKeyboardState
(
originalKbdState
)
;
if
(
MOZ_LOG_TEST
(
gKeyLog
LogLevel
:
:
Verbose
)
)
{
static
const
UINT
kExtendedScanCode
[
]
=
{
0x0000
0xE000
}
;
static
const
UINT
kMapType
=
MAPVK_VSC_TO_VK_EX
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Verbose
(
"
Logging
virtual
keycode
values
for
scancode
(
0x
%
p
)
.
.
.
"
mKeyboardLayout
)
)
;
for
(
uint32_t
i
=
0
;
i
<
std
:
:
size
(
kExtendedScanCode
)
;
i
+
+
)
{
for
(
uint32_t
j
=
1
;
j
<
=
0xFF
;
j
+
+
)
{
UINT
scanCode
=
kExtendedScanCode
[
i
]
+
j
;
UINT
virtualKeyCode
=
:
:
MapVirtualKeyEx
(
scanCode
kMapType
mKeyboardLayout
)
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Verbose
(
"
0x
%
04X
%
s
"
scanCode
kVirtualKeyName
[
virtualKeyCode
]
)
)
;
}
}
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Info
(
"
AltGr
key
is
%
s
in
%
s
"
mHasAltGr
?
"
found
"
:
"
not
found
"
GetLayoutName
(
aLayout
)
.
get
(
)
)
)
;
}
inline
int32_t
KeyboardLayout
:
:
GetKeyIndex
(
uint8_t
aVirtualKey
)
{
static
const
int8_t
xlat
[
256
]
=
{
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
0
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
1
2
3
4
5
6
7
8
9
10
-
1
-
1
-
1
-
1
-
1
-
1
-
1
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
-
1
-
1
-
1
-
1
-
1
37
38
39
40
41
42
43
44
45
46
47
48
-
1
49
50
51
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
52
53
54
55
56
57
58
59
60
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
61
62
63
64
65
-
1
66
67
68
69
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
-
1
}
;
return
xlat
[
aVirtualKey
]
;
}
const
DeadKeyTable
*
KeyboardLayout
:
:
AddDeadKeyTable
(
const
DeadKeyEntry
*
aDeadKeyArray
uint32_t
aEntries
)
{
DeadKeyTableListEntry
*
next
=
mDeadKeyTableListHead
;
const
size_t
bytes
=
offsetof
(
DeadKeyTableListEntry
data
)
+
DeadKeyTable
:
:
SizeInBytes
(
aEntries
)
;
uint8_t
*
p
=
new
uint8_t
[
bytes
]
;
mDeadKeyTableListHead
=
reinterpret_cast
<
DeadKeyTableListEntry
*
>
(
p
)
;
mDeadKeyTableListHead
-
>
next
=
next
;
DeadKeyTable
*
dkt
=
reinterpret_cast
<
DeadKeyTable
*
>
(
mDeadKeyTableListHead
-
>
data
)
;
dkt
-
>
Init
(
aDeadKeyArray
aEntries
)
;
return
dkt
;
}
void
KeyboardLayout
:
:
ReleaseDeadKeyTables
(
)
{
while
(
mDeadKeyTableListHead
)
{
uint8_t
*
p
=
reinterpret_cast
<
uint8_t
*
>
(
mDeadKeyTableListHead
)
;
mDeadKeyTableListHead
=
mDeadKeyTableListHead
-
>
next
;
delete
[
]
p
;
}
}
bool
KeyboardLayout
:
:
EnsureDeadKeyActive
(
bool
aIsActive
uint8_t
aDeadKey
const
PBYTE
aDeadKeyKbdState
)
{
int32_t
ret
;
do
{
char16_t
dummyChars
[
5
]
;
ret
=
:
:
ToUnicodeEx
(
aDeadKey
0
(
PBYTE
)
aDeadKeyKbdState
(
LPWSTR
)
dummyChars
std
:
:
size
(
dummyChars
)
0
mKeyboardLayout
)
;
}
while
(
(
ret
<
0
)
!
=
aIsActive
)
;
return
(
ret
<
0
)
;
}
void
KeyboardLayout
:
:
ActivateDeadKeyState
(
const
NativeKey
&
aNativeKey
)
{
if
(
!
aNativeKey
.
IsKeyDownMessage
(
)
)
{
return
;
}
mActiveDeadKeys
.
AppendElement
(
aNativeKey
.
mOriginalVirtualKeyCode
)
;
mDeadKeyShiftStates
.
AppendElement
(
aNativeKey
.
GetShiftState
(
)
)
;
}
void
KeyboardLayout
:
:
DeactivateDeadKeyState
(
)
{
if
(
mActiveDeadKeys
.
IsEmpty
(
)
)
{
return
;
}
BYTE
kbdState
[
256
]
;
memset
(
kbdState
0
sizeof
(
kbdState
)
)
;
VirtualKey
:
:
FillKbdState
(
kbdState
mDeadKeyShiftStates
.
LastElement
(
)
)
;
EnsureDeadKeyActive
(
false
mActiveDeadKeys
.
LastElement
(
)
kbdState
)
;
mActiveDeadKeys
.
Clear
(
)
;
mDeadKeyShiftStates
.
Clear
(
)
;
}
bool
KeyboardLayout
:
:
AddDeadKeyEntry
(
char16_t
aBaseChar
char16_t
aCompositeChar
nsTArray
<
DeadKeyEntry
>
&
aDeadKeyArray
)
{
auto
dke
=
DeadKeyEntry
(
aBaseChar
aCompositeChar
)
;
for
(
uint32_t
index
=
0
;
index
<
aDeadKeyArray
.
Length
(
)
;
index
+
+
)
{
if
(
aDeadKeyArray
[
index
]
=
=
dke
)
{
return
false
;
}
}
aDeadKeyArray
.
AppendElement
(
dke
)
;
return
true
;
}
uint32_t
KeyboardLayout
:
:
GetDeadKeyCombinations
(
uint8_t
aDeadKey
const
PBYTE
aDeadKeyKbdState
uint16_t
aShiftStatesWithBaseChars
nsTArray
<
DeadKeyEntry
>
&
aDeadKeyArray
)
{
bool
deadKeyActive
=
false
;
uint32_t
entries
=
0
;
BYTE
kbdState
[
256
]
;
memset
(
kbdState
0
sizeof
(
kbdState
)
)
;
for
(
uint32_t
shiftState
=
0
;
shiftState
<
16
;
shiftState
+
+
)
{
if
(
!
(
aShiftStatesWithBaseChars
&
(
1
<
<
shiftState
)
)
)
{
continue
;
}
VirtualKey
:
:
FillKbdState
(
kbdState
shiftState
)
;
for
(
uint32_t
virtualKey
=
0
;
virtualKey
<
256
;
virtualKey
+
+
)
{
int32_t
vki
=
GetKeyIndex
(
virtualKey
)
;
if
(
vki
>
=
0
&
&
mVirtualKeys
[
vki
]
.
GetNativeUniChars
(
shiftState
)
.
Length
(
)
=
=
1
)
{
if
(
!
deadKeyActive
)
{
deadKeyActive
=
EnsureDeadKeyActive
(
true
aDeadKey
aDeadKeyKbdState
)
;
}
char16_t
compositeChars
[
5
]
;
int32_t
ret
=
:
:
ToUnicodeEx
(
virtualKey
0
kbdState
(
LPWSTR
)
compositeChars
std
:
:
size
(
compositeChars
)
0
mKeyboardLayout
)
;
switch
(
ret
)
{
case
0
:
break
;
case
1
:
{
char16_t
baseChars
[
5
]
;
ret
=
:
:
ToUnicodeEx
(
virtualKey
0
kbdState
(
LPWSTR
)
baseChars
std
:
:
size
(
baseChars
)
0
mKeyboardLayout
)
;
if
(
entries
<
aDeadKeyArray
.
Capacity
(
)
)
{
switch
(
ret
)
{
case
1
:
if
(
AddDeadKeyEntry
(
baseChars
[
0
]
compositeChars
[
0
]
aDeadKeyArray
)
)
{
entries
+
+
;
}
deadKeyActive
=
false
;
break
;
case
-
1
:
{
deadKeyActive
=
EnsureDeadKeyActive
(
false
aDeadKey
aDeadKeyKbdState
)
;
if
(
NS_WARN_IF
(
deadKeyActive
)
)
{
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Error
(
"
failed
to
deactivating
the
dead
-
key
state
.
.
.
"
)
)
;
break
;
}
for
(
int32_t
i
=
0
;
i
<
5
;
+
+
i
)
{
ret
=
:
:
ToUnicodeEx
(
virtualKey
0
kbdState
(
LPWSTR
)
baseChars
std
:
:
size
(
baseChars
)
0
mKeyboardLayout
)
;
if
(
ret
>
=
0
)
{
break
;
}
}
if
(
ret
>
0
&
&
AddDeadKeyEntry
(
baseChars
[
0
]
compositeChars
[
0
]
aDeadKeyArray
)
)
{
entries
+
+
;
}
EnsureDeadKeyActive
(
false
virtualKey
kbdState
)
;
break
;
}
default
:
NS_WARNING
(
"
File
a
bug
for
this
dead
-
key
handling
!
"
)
;
deadKeyActive
=
false
;
break
;
}
}
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Verbose
(
"
%
s
-
>
%
s
(
%
d
)
:
DeadKeyEntry
(
%
s
%
s
)
(
ret
=
%
d
)
"
kVirtualKeyName
[
aDeadKey
]
kVirtualKeyName
[
virtualKey
]
vki
GetCharacterCodeNames
(
compositeChars
1
)
.
get
(
)
ret
<
=
0
?
"
'
'
"
:
GetCharacterCodeNames
(
baseChars
std
:
:
min
(
ret
5
)
)
.
get
(
)
ret
)
)
;
break
;
}
default
:
deadKeyActive
=
false
;
MOZ_LOG
(
gKeyLog
LogLevel
:
:
Verbose
(
"
%
s
-
>
%
s
(
%
d
)
:
Unsupport
dead
key
type
(
%
s
)
(
ret
=
%
d
)
"
kVirtualKeyName
[
aDeadKey
]
kVirtualKeyName
[
virtualKey
]
vki
ret
<
=
0
?
"
'
'
"
:
GetCharacterCodeNames
(
compositeChars
std
:
:
min
(
ret
5
)
)
.
get
(
)
ret
)
)
;
break
;
}
}
}
}
if
(
deadKeyActive
)
{
deadKeyActive
=
EnsureDeadKeyActive
(
false
aDeadKey
aDeadKeyKbdState
)
;
}
aDeadKeyArray
.
Sort
(
)
;
return
entries
;
}
uint32_t
KeyboardLayout
:
:
ConvertNativeKeyCodeToDOMKeyCode
(
UINT
aNativeKeyCode
)
const
{
if
(
(
aNativeKeyCode
>
=
0x30
&
&
aNativeKeyCode
<
=
0x39
)
|
|
(
aNativeKeyCode
>
=
0x41
&
&
aNativeKeyCode
<
=
0x5A
)
|
|
(
aNativeKeyCode
>
=
0x60
&
&
aNativeKeyCode
<
=
0x87
)
)
{
return
static_cast
<
uint32_t
>
(
aNativeKeyCode
)
;
}
switch
(
aNativeKeyCode
)
{
case
VK_CANCEL
:
case
VK_BACK
:
case
VK_TAB
:
case
VK_CLEAR
:
case
VK_RETURN
:
case
VK_SHIFT
:
case
VK_CONTROL
:
case
VK_MENU
:
case
VK_PAUSE
:
case
VK_CAPITAL
:
case
VK_KANA
:
case
VK_JUNJA
:
case
VK_FINAL
:
case
VK_HANJA
:
case
VK_ESCAPE
:
case
VK_CONVERT
:
case
VK_NONCONVERT
:
case
VK_ACCEPT
:
case
VK_MODECHANGE
:
case
VK_SPACE
:
case
VK_PRIOR
:
case
VK_NEXT
:
case
VK_END
:
case
VK_HOME
:
case
VK_LEFT
:
case
VK_UP
:
case
VK_RIGHT
:
case
VK_DOWN
:
case
VK_SELECT
:
case
VK_PRINT
:
case
VK_EXECUTE
:
case
VK_SNAPSHOT
:
case
VK_INSERT
:
case
VK_DELETE
:
case
VK_APPS
:
case
VK_SLEEP
:
case
VK_NUMLOCK
:
case
VK_SCROLL
:
case
VK_ATTN
:
case
VK_CRSEL
:
case
VK_EXSEL
:
case
VK_EREOF
:
case
VK_PLAY
:
case
VK_ZOOM
:
case
VK_PA1
:
return
uint32_t
(
aNativeKeyCode
)
;
case
VK_HELP
:
return
NS_VK_HELP
;
case
VK_LWIN
:
case
VK_RWIN
:
return
NS_VK_WIN
;
case
VK_VOLUME_MUTE
:
return
NS_VK_VOLUME_MUTE
;
case
VK_VOLUME_DOWN
:
return
NS_VK_VOLUME_DOWN
;
case
VK_VOLUME_UP
:
return
NS_VK_VOLUME_UP
;
case
VK_LSHIFT
:
case
VK_RSHIFT
:
return
NS_VK_SHIFT
;
case
VK_LCONTROL
:
case
VK_RCONTROL
:
return
NS_VK_CONTROL
;
case
VK_LMENU
:
case
VK_RMENU
:
return
NS_VK_ALT
;
case
VK_BROWSER_BACK
:
case
VK_BROWSER_FORWARD
:
case
VK_BROWSER_REFRESH
:
case
VK_BROWSER_STOP
:
case
VK_BROWSER_SEARCH
:
case
VK_BROWSER_FAVORITES
:
case
VK_BROWSER_HOME
:
case
VK_MEDIA_NEXT_TRACK
:
case
VK_MEDIA_PREV_TRACK
:
case
VK_MEDIA_STOP
:
case
VK_MEDIA_PLAY_PAUSE
:
case
VK_LAUNCH_MAIL
:
case
VK_LAUNCH_MEDIA_SELECT
:
case
VK_LAUNCH_APP1
:
case
VK_LAUNCH_APP2
:
return
0
;
case
VK_OEM_FJ_JISHO
:
case
VK_OEM_FJ_MASSHOU
:
case
VK_OEM_FJ_TOUROKU
:
case
VK_OEM_FJ_LOYA
:
case
VK_OEM_FJ_ROYA
:
case
VK_ICO_HELP
:
case
VK_ICO_00
:
case
VK_ICO_CLEAR
:
case
VK_OEM_RESET
:
case
VK_OEM_JUMP
:
case
VK_OEM_PA1
:
case
VK_OEM_PA2
:
case
VK_OEM_PA3
:
case
VK_OEM_WSCTRL
:
case
VK_OEM_CUSEL
:
case
VK_OEM_ATTN
:
case
VK_OEM_FINISH
:
case
VK_OEM_COPY
:
case
VK_OEM_AUTO
:
case
VK_OEM_ENLW
:
case
VK_OEM_BACKTAB
:
case
VK_OEM_CLEAR
:
return
uint32_t
(
aNativeKeyCode
)
;
case
0xE1
:
return
0
;
case
VK_OEM_1
:
case
VK_OEM_PLUS
:
case
VK_OEM_COMMA
:
case
VK_OEM_MINUS
:
case
VK_OEM_PERIOD
:
case
VK_OEM_2
:
case
VK_OEM_3
:
case
VK_OEM_4
:
case
VK_OEM_5
:
case
VK_OEM_6
:
case
VK_OEM_7
:
case
VK_OEM_8
:
case
VK_OEM_102
:
case
VK_ABNT_C1
:
{
NS_ASSERTION
(
IsPrintableCharKey
(
aNativeKeyCode
)
"
The
key
must
be
printable
"
)
;
ModifierKeyState
modKeyState
(
0
)
;
UniCharsAndModifiers
uniChars
=
GetUniCharsAndModifiers
(
aNativeKeyCode
modKeyState
)
;
if
(
uniChars
.
Length
(
)
!
=
1
|
|
uniChars
.
CharAt
(
0
)
<
'
'
|
|
uniChars
.
CharAt
(
0
)
>
0x7F
)
{
modKeyState
.
Set
(
MODIFIER_SHIFT
)
;
uniChars
=
GetUniCharsAndModifiers
(
aNativeKeyCode
modKeyState
)
;
if
(
uniChars
.
Length
(
)
!
=
1
|
|
uniChars
.
CharAt
(
0
)
<
'
'
|
|
uniChars
.
CharAt
(
0
)
>
0x7F
)
{
CodeNameIndex
code
;
switch
(
aNativeKeyCode
)
{
case
VK_OEM_1
:
code
=
CODE_NAME_INDEX_Semicolon
;
break
;
case
VK_OEM_PLUS
:
code
=
CODE_NAME_INDEX_Equal
;
break
;
case
VK_OEM_COMMA
:
code
=
CODE_NAME_INDEX_Comma
;
break
;
case
VK_OEM_MINUS
:
code
=
CODE_NAME_INDEX_Minus
;
break
;
case
VK_OEM_PERIOD
:
code
=
CODE_NAME_INDEX_Period
;
break
;
case
VK_OEM_2
:
code
=
CODE_NAME_INDEX_Slash
;
break
;
case
VK_OEM_3
:
code
=
CODE_NAME_INDEX_Backquote
;
break
;
case
VK_OEM_4
:
code
=
CODE_NAME_INDEX_BracketLeft
;
break
;
case
VK_OEM_5
:
code
=
CODE_NAME_INDEX_Backslash
;
break
;
case
VK_OEM_6
:
code
=
CODE_NAME_INDEX_BracketRight
;
break
;
case
VK_OEM_7
:
code
=
CODE_NAME_INDEX_Quote
;
break
;
case
VK_OEM_8
:
code
=
CODE_NAME_INDEX_Backquote
;
break
;
case
VK_OEM_102
:
code
=
CODE_NAME_INDEX_IntlBackslash
;
break
;
case
VK_ABNT_C1
:
code
=
CODE_NAME_INDEX_IntlBackslash
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Handle
all
OEM
keycode
values
"
)
;
return
0
;
}
return
WidgetKeyboardEvent
:
:
GetFallbackKeyCodeOfPunctuationKey
(
code
)
;
}
}
return
WidgetUtils
:
:
ComputeKeyCodeFromChar
(
uniChars
.
CharAt
(
0
)
)
;
}
case
VK_ABNT_C2
:
return
NS_VK_SEPARATOR
;
case
VK_PROCESSKEY
:
return
NS_VK_PROCESSKEY
;
case
VK_PACKET
:
return
0
;
case
0xFF
:
NS_WARNING
(
"
The
key
is
failed
to
be
converted
to
a
virtual
keycode
"
)
;
return
0
;
}
#
ifdef
DEBUG
nsPrintfCString
warning
(
"
Unknown
virtual
keycode
(
0x
%
08X
)
please
check
the
"
"
latest
MSDN
document
there
may
be
some
new
"
"
keycodes
we
'
ve
never
known
.
"
aNativeKeyCode
)
;
NS_WARNING
(
warning
.
get
(
)
)
;
#
endif
return
0
;
}
KeyNameIndex
KeyboardLayout
:
:
ConvertNativeKeyCodeToKeyNameIndex
(
uint8_t
aVirtualKey
)
const
{
if
(
IsPrintableCharKey
(
aVirtualKey
)
|
|
aVirtualKey
=
=
VK_PACKET
)
{
return
KEY_NAME_INDEX_USE_STRING
;
}
if
(
aVirtualKey
=
=
VK_RMENU
&
&
HasAltGr
(
)
)
{
return
KEY_NAME_INDEX_AltGraph
;
}
switch
(
aVirtualKey
)
{
#
undef
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
#
define
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
(
aNativeKey
aKeyNameIndex
)
\
case
aNativeKey
:
\
return
aKeyNameIndex
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
default
:
break
;
}
HKL
layout
=
KeyboardLayout
:
:
GetLayout
(
)
;
WORD
langID
=
LOWORD
(
static_cast
<
HKL
>
(
layout
)
)
;
WORD
primaryLangID
=
PRIMARYLANGID
(
langID
)
;
if
(
primaryLangID
=
=
LANG_JAPANESE
)
{
switch
(
aVirtualKey
)
{
#
undef
NS_JAPANESE_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
#
define
NS_JAPANESE_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
(
aNativeKey
\
aKeyNameIndex
)
\
case
aNativeKey
:
\
return
aKeyNameIndex
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_JAPANESE_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
default
:
break
;
}
}
else
if
(
primaryLangID
=
=
LANG_KOREAN
)
{
switch
(
aVirtualKey
)
{
#
undef
NS_KOREAN_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
#
define
NS_KOREAN_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
(
aNativeKey
aKeyNameIndex
)
\
case
aNativeKey
:
\
return
aKeyNameIndex
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_KOREAN_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
default
:
return
KEY_NAME_INDEX_Unidentified
;
}
}
switch
(
aVirtualKey
)
{
#
undef
NS_OTHER_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
#
define
NS_OTHER_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
(
aNativeKey
aKeyNameIndex
)
\
case
aNativeKey
:
\
return
aKeyNameIndex
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_OTHER_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
default
:
return
KEY_NAME_INDEX_Unidentified
;
}
}
CodeNameIndex
KeyboardLayout
:
:
ConvertScanCodeToCodeNameIndex
(
UINT
aScanCode
)
{
switch
(
aScanCode
)
{
#
define
NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
(
aNativeKey
aCodeNameIndex
)
\
case
aNativeKey
:
\
return
aCodeNameIndex
;
#
include
"
NativeKeyToDOMCodeName
.
h
"
#
undef
NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
default
:
return
CODE_NAME_INDEX_UNKNOWN
;
}
}
nsresult
KeyboardLayout
:
:
SynthesizeNativeKeyEvent
(
nsWindow
*
aWidget
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
)
{
UINT
keyboardLayoutListCount
=
:
:
GetKeyboardLayoutList
(
0
nullptr
)
;
NS_ASSERTION
(
keyboardLayoutListCount
>
0
"
One
keyboard
layout
must
be
installed
at
least
"
)
;
HKL
keyboardLayoutListBuff
[
50
]
;
HKL
*
keyboardLayoutList
=
keyboardLayoutListCount
<
50
?
keyboardLayoutListBuff
:
new
HKL
[
keyboardLayoutListCount
]
;
keyboardLayoutListCount
=
:
:
GetKeyboardLayoutList
(
keyboardLayoutListCount
keyboardLayoutList
)
;
NS_ASSERTION
(
keyboardLayoutListCount
>
0
"
Failed
to
get
all
keyboard
layouts
installed
on
the
system
"
)
;
nsPrintfCString
layoutName
(
"
%
08x
"
aNativeKeyboardLayout
)
;
HKL
loadedLayout
=
LoadKeyboardLayoutA
(
layoutName
.
get
(
)
KLF_NOTELLSHELL
)
;
if
(
loadedLayout
=
=
nullptr
)
{
if
(
keyboardLayoutListBuff
!
=
keyboardLayoutList
)
{
delete
[
]
keyboardLayoutList
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
BYTE
originalKbdState
[
256
]
;
:
:
GetKeyboardState
(
originalKbdState
)
;
BYTE
kbdState
[
256
]
;
memset
(
kbdState
0
sizeof
(
kbdState
)
)
;
:
:
SetKeyboardState
(
kbdState
)
;
OverrideLayout
(
loadedLayout
)
;
bool
isAltGrKeyPress
=
false
;
if
(
aModifierFlags
&
nsIWidget
:
:
ALTGRAPH
)
{
if
(
!
HasAltGr
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
aModifierFlags
&
=
~
(
nsIWidget
:
:
CTRL_L
|
nsIWidget
:
:
ALT_R
)
;
}
uint8_t
argumentKeySpecific
=
0
;
switch
(
aNativeKeyCode
&
0xFF
)
{
case
VK_SHIFT
:
aModifierFlags
&
=
~
(
nsIWidget
:
:
SHIFT_L
|
nsIWidget
:
:
SHIFT_R
)
;
argumentKeySpecific
=
VK_LSHIFT
;
break
;
case
VK_LSHIFT
:
aModifierFlags
&
=
~
nsIWidget
:
:
SHIFT_L
;
argumentKeySpecific
=
aNativeKeyCode
&
0xFF
;
aNativeKeyCode
=
(
aNativeKeyCode
&
0xFFFF0000
)
|
VK_SHIFT
;
break
;
case
VK_RSHIFT
:
aModifierFlags
&
=
~
nsIWidget
:
:
SHIFT_R
;
argumentKeySpecific
=
aNativeKeyCode
&
0xFF
;
aNativeKeyCode
=
(
aNativeKeyCode
&
0xFFFF0000
)
|
VK_SHIFT
;
break
;
case
VK_CONTROL
:
aModifierFlags
&
=
~
(
nsIWidget
:
:
CTRL_L
|
nsIWidget
:
:
CTRL_R
)
;
argumentKeySpecific
=
VK_LCONTROL
;
break
;
case
VK_LCONTROL
:
aModifierFlags
&
=
~
nsIWidget
:
:
CTRL_L
;
argumentKeySpecific
=
aNativeKeyCode
&
0xFF
;
aNativeKeyCode
=
(
aNativeKeyCode
&
0xFFFF0000
)
|
VK_CONTROL
;
break
;
case
VK_RCONTROL
:
aModifierFlags
&
=
~
nsIWidget
:
:
CTRL_R
;
argumentKeySpecific
=
aNativeKeyCode
&
0xFF
;
aNativeKeyCode
=
(
aNativeKeyCode
&
0xFFFF0000
)
|
VK_CONTROL
;
break
;
case
VK_MENU
:
aModifierFlags
&
=
~
(
nsIWidget
:
:
ALT_L
|
nsIWidget
:
:
ALT_R
)
;
argumentKeySpecific
=
VK_LMENU
;
break
;
case
VK_LMENU
:
aModifierFlags
&
=
~
nsIWidget
:
:
ALT_L
;
argumentKeySpecific
=
aNativeKeyCode
&
0xFF
;
aNativeKeyCode
=
(
aNativeKeyCode
&
0xFFFF0000
)
|
VK_MENU
;
break
;
case
VK_RMENU
:
aModifierFlags
&
=
~
(
nsIWidget
:
:
ALT_R
|
nsIWidget
:
:
ALTGRAPH
)
;
argumentKeySpecific
=
aNativeKeyCode
&
0xFF
;
aNativeKeyCode
=
(
aNativeKeyCode
&
0xFFFF0000
)
|
VK_MENU
;
if
(
HasAltGr
(
)
)
{
isAltGrKeyPress
=
true
;
aModifierFlags
&
=
~
nsIWidget
:
:
CTRL_L
;
aModifierFlags
|
=
nsIWidget
:
:
ALTGRAPH
;
}
break
;
case
VK_CAPITAL
:
aModifierFlags
&
=
~
nsIWidget
:
:
CAPS_LOCK
;
argumentKeySpecific
=
VK_CAPITAL
;
break
;
case
VK_NUMLOCK
:
aModifierFlags
&
=
~
nsIWidget
:
:
NUM_LOCK
;
argumentKeySpecific
=
VK_NUMLOCK
;
break
;
}
AutoTArray
<
KeyPair
10
>
keySequence
;
WinUtils
:
:
SetupKeyModifiersSequence
(
&
keySequence
aModifierFlags
WM_KEYDOWN
)
;
if
(
!
isAltGrKeyPress
)
{
keySequence
.
AppendElement
(
KeyPair
(
aNativeKeyCode
argumentKeySpecific
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
keySequence
.
Length
(
)
;
+
+
i
)
{
uint8_t
key
=
keySequence
[
i
]
.
mGeneral
;
uint8_t
keySpecific
=
keySequence
[
i
]
.
mSpecific
;
uint16_t
scanCode
=
keySequence
[
i
]
.
mScanCode
;
kbdState
[
key
]
=
0x81
;
if
(
keySpecific
)
{
kbdState
[
keySpecific
]
=
0x81
;
}
:
:
SetKeyboardState
(
kbdState
)
;
ModifierKeyState
modKeyState
;
if
(
!
scanCode
)
{
scanCode
=
ComputeScanCodeForVirtualKeyCode
(
keySpecific
?
keySpecific
:
key
)
;
}
LPARAM
lParam
=
static_cast
<
LPARAM
>
(
scanCode
<
<
16
)
;
if
(
(
scanCode
&
0xFF00
)
=
=
0xE000
)
{
lParam
|
=
0x1000000
;
}
bool
makeSysKeyMsg
=
!
(
aModifierFlags
&
nsIWidget
:
:
ALTGRAPH
)
&
&
IsSysKey
(
key
modKeyState
)
;
MSG
keyDownMsg
=
WinUtils
:
:
InitMSG
(
makeSysKeyMsg
?
WM_SYSKEYDOWN
:
WM_KEYDOWN
key
lParam
aWidget
-
>
GetWindowHandle
(
)
)
;
if
(
i
=
=
keySequence
.
Length
(
)
-
1
)
{
bool
makeDeadCharMsg
=
(
IsDeadKey
(
key
modKeyState
)
&
&
aCharacters
.
IsEmpty
(
)
)
;
nsAutoString
chars
(
aCharacters
)
;
if
(
makeDeadCharMsg
)
{
UniCharsAndModifiers
deadChars
=
GetUniCharsAndModifiers
(
key
modKeyState
)
;
chars
=
deadChars
.
ToString
(
)
;
NS_ASSERTION
(
chars
.
Length
(
)
=
=
1
"
Dead
char
must
be
only
one
character
"
)
;
}
if
(
chars
.
IsEmpty
(
)
)
{
NativeKey
nativeKey
(
aWidget
keyDownMsg
modKeyState
)
;
nativeKey
.
HandleKeyDownMessage
(
)
;
}
else
{
AutoTArray
<
NativeKey
:
:
FakeCharMsg
10
>
fakeCharMsgs
;
for
(
uint32_t
j
=
0
;
j
<
chars
.
Length
(
)
;
j
+
+
)
{
NativeKey
:
:
FakeCharMsg
*
fakeCharMsg
=
fakeCharMsgs
.
AppendElement
(
)
;
fakeCharMsg
-
>
mCharCode
=
chars
.
CharAt
(
j
)
;
fakeCharMsg
-
>
mScanCode
=
scanCode
;
fakeCharMsg
-
>
mIsSysKey
=
makeSysKeyMsg
;
fakeCharMsg
-
>
mIsDeadKey
=
makeDeadCharMsg
;
}
NativeKey
nativeKey
(
aWidget
keyDownMsg
modKeyState
0
&
fakeCharMsgs
)
;
bool
dispatched
;
nativeKey
.
HandleKeyDownMessage
(
&
dispatched
)
;
for
(
uint32_t
j
=
1
;
j
<
fakeCharMsgs
.
Length
(
)
;
j
+
+
)
{
if
(
fakeCharMsgs
[
j
]
.
mConsumed
)
{
continue
;
}
MSG
charMsg
=
fakeCharMsgs
[
j
]
.
GetCharMsg
(
aWidget
-
>
GetWindowHandle
(
)
)
;
NativeKey
nativeKey
(
aWidget
charMsg
modKeyState
)
;
nativeKey
.
HandleCharMessage
(
charMsg
)
;
}
}
}
else
{
NativeKey
nativeKey
(
aWidget
keyDownMsg
modKeyState
)
;
nativeKey
.
HandleKeyDownMessage
(
)
;
}
}
keySequence
.
Clear
(
)
;
if
(
!
isAltGrKeyPress
)
{
keySequence
.
AppendElement
(
KeyPair
(
aNativeKeyCode
argumentKeySpecific
)
)
;
}
WinUtils
:
:
SetupKeyModifiersSequence
(
&
keySequence
aModifierFlags
WM_KEYUP
)
;
for
(
uint32_t
i
=
0
;
i
<
keySequence
.
Length
(
)
;
+
+
i
)
{
uint8_t
key
=
keySequence
[
i
]
.
mGeneral
;
uint8_t
keySpecific
=
keySequence
[
i
]
.
mSpecific
;
uint16_t
scanCode
=
keySequence
[
i
]
.
mScanCode
;
kbdState
[
key
]
=
0
;
if
(
keySpecific
)
{
kbdState
[
keySpecific
]
=
0
;
}
:
:
SetKeyboardState
(
kbdState
)
;
ModifierKeyState
modKeyState
;
if
(
!
scanCode
)
{
scanCode
=
ComputeScanCodeForVirtualKeyCode
(
keySpecific
?
keySpecific
:
key
)
;
}
LPARAM
lParam
=
static_cast
<
LPARAM
>
(
scanCode
<
<
16
)
;
if
(
(
scanCode
&
0xFF00
)
=
=
0xE000
)
{
lParam
|
=
0x1000000
;
}
bool
makeSysKeyMsg
=
IsSysKey
(
key
modKeyState
)
&
&
key
!
=
VK_MENU
;
MSG
keyUpMsg
=
WinUtils
:
:
InitMSG
(
makeSysKeyMsg
?
WM_SYSKEYUP
:
WM_KEYUP
key
lParam
aWidget
-
>
GetWindowHandle
(
)
)
;
NativeKey
nativeKey
(
aWidget
keyUpMsg
modKeyState
)
;
nativeKey
.
HandleKeyUpMessage
(
)
;
}
:
:
SetKeyboardState
(
originalKbdState
)
;
RestoreLayout
(
)
;
for
(
uint32_t
i
=
0
;
i
<
keyboardLayoutListCount
;
i
+
+
)
{
if
(
keyboardLayoutList
[
i
]
=
=
loadedLayout
)
{
loadedLayout
=
0
;
break
;
}
}
if
(
keyboardLayoutListBuff
!
=
keyboardLayoutList
)
{
delete
[
]
keyboardLayoutList
;
}
if
(
loadedLayout
)
{
:
:
UnloadKeyboardLayout
(
loadedLayout
)
;
}
return
NS_OK
;
}
char16_t
DeadKeyTable
:
:
GetCompositeChar
(
char16_t
aBaseChar
)
const
{
for
(
uint32_t
index
=
0
;
index
<
mEntries
;
index
+
+
)
{
if
(
mTable
[
index
]
.
BaseChar
=
=
aBaseChar
)
{
return
mTable
[
index
]
.
CompositeChar
;
}
if
(
mTable
[
index
]
.
BaseChar
>
aBaseChar
)
{
break
;
}
}
return
0
;
}
MSG
RedirectedKeyDownMessageManager
:
:
sRedirectedKeyDownMsg
;
bool
RedirectedKeyDownMessageManager
:
:
sDefaultPreventedOfRedirectedMsg
=
false
;
bool
RedirectedKeyDownMessageManager
:
:
IsRedirectedMessage
(
const
MSG
&
aMsg
)
{
return
(
aMsg
.
message
=
=
WM_KEYDOWN
|
|
aMsg
.
message
=
=
WM_SYSKEYDOWN
)
&
&
(
sRedirectedKeyDownMsg
.
message
=
=
aMsg
.
message
&
&
WinUtils
:
:
GetScanCode
(
sRedirectedKeyDownMsg
.
lParam
)
=
=
WinUtils
:
:
GetScanCode
(
aMsg
.
lParam
)
)
;
}
void
RedirectedKeyDownMessageManager
:
:
RemoveNextCharMessage
(
HWND
aWnd
)
{
MSG
msg
;
if
(
WinUtils
:
:
PeekMessage
(
&
msg
aWnd
WM_KEYFIRST
WM_KEYLAST
PM_NOREMOVE
|
PM_NOYIELD
)
&
&
(
msg
.
message
=
=
WM_CHAR
|
|
msg
.
message
=
=
WM_SYSCHAR
)
)
{
WinUtils
:
:
PeekMessage
(
&
msg
aWnd
msg
.
message
msg
.
message
PM_REMOVE
|
PM_NOYIELD
)
;
}
}
}
}
