#
ifndef
mozilla_widget_WinRegistry_h__
#
define
mozilla_widget_WinRegistry_h__
#
include
<
windows
.
h
>
#
include
<
functional
>
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Span
.
h
"
class
nsISerialEventTarget
;
namespace
mozilla
:
:
widget
:
:
WinRegistry
{
static
constexpr
size_t
kMaxKeyNameLen
=
255
;
static
constexpr
size_t
kMaxValueNameLen
=
16383
;
enum
class
KeyMode
:
uint32_t
{
AllAccess
=
KEY_ALL_ACCESS
QueryValue
=
KEY_QUERY_VALUE
CreateLink
=
KEY_CREATE_LINK
CreateSubKey
=
KEY_CREATE_SUB_KEY
EnumerateSubkeys
=
KEY_ENUMERATE_SUB_KEYS
Execute
=
KEY_EXECUTE
Notify
=
KEY_NOTIFY
Read
=
KEY_READ
SetValue
=
KEY_SET_VALUE
Write
=
KEY_WRITE
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
KeyMode
)
;
enum
class
StringFlags
:
uint32_t
{
Sz
=
1
<
<
0
ExpandSz
=
1
<
<
1
LegacyMultiSz
=
1
<
<
2
ExpandEnvironment
=
1
<
<
3
Default
=
Sz
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
StringFlags
)
;
static
constexpr
auto
kLegacyWinUtilsStringFlags
=
StringFlags
:
:
Sz
|
StringFlags
:
:
ExpandSz
;
enum
class
ValueType
:
uint32_t
{
Binary
=
REG_BINARY
Dword
=
REG_DWORD
ExpandSz
=
REG_EXPAND_SZ
Link
=
REG_LINK
MultiSz
=
REG_MULTI_SZ
None
=
REG_NONE
Qword
=
REG_QWORD
Sz
=
REG_SZ
}
;
class
Key
{
public
:
enum
CreateFlag
{
Create
}
;
Key
(
)
=
default
;
Key
(
const
Key
&
)
=
delete
;
Key
(
Key
&
&
aOther
)
{
std
:
:
swap
(
mKey
aOther
.
mKey
)
;
}
Key
&
operator
=
(
const
Key
&
)
=
delete
;
Key
&
operator
=
(
Key
&
&
aOther
)
{
std
:
:
swap
(
mKey
aOther
.
mKey
)
;
return
*
this
;
}
Key
(
HKEY
aParent
const
nsString
&
aPath
KeyMode
aMode
CreateFlag
)
;
Key
(
HKEY
aParent
const
nsString
&
aPath
KeyMode
aMode
)
;
Key
(
const
Key
&
aParent
const
nsString
&
aPath
KeyMode
aMode
CreateFlag
)
:
Key
(
aParent
.
mKey
aPath
aMode
Create
)
{
}
Key
(
const
Key
&
aParent
const
nsString
&
aPath
KeyMode
aMode
)
:
Key
(
aParent
.
mKey
aPath
aMode
)
{
}
~
Key
(
)
{
if
(
mKey
)
{
:
:
RegCloseKey
(
mKey
)
;
}
}
explicit
operator
bool
(
)
const
{
return
!
!
mKey
;
}
uint32_t
GetChildCount
(
)
const
;
[
[
nodiscard
]
]
bool
GetChildName
(
uint32_t
aIndex
nsAString
&
aResult
)
const
;
[
[
nodiscard
]
]
bool
RemoveChildKey
(
const
nsString
&
aName
)
const
;
uint32_t
GetValueCount
(
)
const
;
[
[
nodiscard
]
]
bool
GetValueName
(
uint32_t
aIndex
nsAString
&
aResult
)
const
;
ValueType
GetValueType
(
const
nsString
&
aName
)
const
;
bool
RemoveValue
(
const
nsString
&
aName
)
const
;
Maybe
<
uint32_t
>
GetValueAsDword
(
const
nsString
&
aName
)
const
;
bool
WriteValueAsDword
(
const
nsString
&
aName
uint32_t
aValue
)
;
Maybe
<
uint64_t
>
GetValueAsQword
(
const
nsString
&
aName
)
const
;
[
[
nodiscard
]
]
bool
WriteValueAsQword
(
const
nsString
&
aName
uint64_t
aValue
)
;
[
[
nodiscard
]
]
bool
GetValueAsBinary
(
const
nsString
&
aName
nsTArray
<
uint8_t
>
&
)
const
;
Maybe
<
nsTArray
<
uint8_t
>
>
GetValueAsBinary
(
const
nsString
&
aName
)
const
;
[
[
nodiscard
]
]
bool
WriteValueAsBinary
(
const
nsString
&
aName
Span
<
const
uint8_t
>
aValue
)
;
[
[
nodiscard
]
]
bool
GetValueAsString
(
const
nsString
&
aName
nsString
&
aResult
StringFlags
=
StringFlags
:
:
Default
)
const
;
Maybe
<
nsString
>
GetValueAsString
(
const
nsString
&
aName
StringFlags
=
StringFlags
:
:
Default
)
const
;
[
[
nodiscard
]
]
Maybe
<
uint32_t
>
GetValueAsString
(
const
nsString
&
aName
Span
<
char16_t
>
StringFlags
=
StringFlags
:
:
Default
)
const
;
[
[
nodiscard
]
]
Maybe
<
uint32_t
>
GetValueAsString
(
const
nsString
&
aName
Span
<
wchar_t
>
aBuffer
StringFlags
aFlags
=
StringFlags
:
:
Default
)
const
{
return
GetValueAsString
(
aName
Span
<
char16_t
>
(
(
char16_t
*
)
aBuffer
.
data
(
)
aBuffer
.
Length
(
)
)
aFlags
)
;
}
[
[
nodiscard
]
]
bool
WriteValueAsString
(
const
nsString
&
aName
const
nsString
&
aValue
)
{
MOZ_ASSERT
(
mKey
)
;
return
SUCCEEDED
(
RegSetValueExW
(
mKey
aName
.
get
(
)
0
REG_SZ
(
const
BYTE
*
)
aValue
.
get
(
)
(
aValue
.
Length
(
)
+
1
)
*
sizeof
(
char16_t
)
)
)
;
}
HKEY
RawKey
(
)
const
{
return
mKey
;
}
private
:
HKEY
mKey
=
nullptr
;
}
;
inline
bool
HasKey
(
HKEY
aRootKey
const
nsString
&
aKeyName
)
{
return
!
!
Key
(
aRootKey
aKeyName
KeyMode
:
:
Read
)
;
}
[
[
nodiscard
]
]
inline
bool
GetString
(
HKEY
aRootKey
const
nsString
&
aKeyName
const
nsString
&
aValueName
Span
<
char16_t
>
aBuffer
StringFlags
aFlags
=
StringFlags
:
:
Default
)
{
Key
k
(
aRootKey
aKeyName
KeyMode
:
:
QueryValue
)
;
return
k
&
&
k
.
GetValueAsString
(
aValueName
aBuffer
aFlags
)
;
}
[
[
nodiscard
]
]
inline
bool
GetString
(
HKEY
aRootKey
const
nsString
&
aKeyName
const
nsString
&
aValueName
Span
<
wchar_t
>
aBuffer
StringFlags
aFlags
=
StringFlags
:
:
Default
)
{
return
GetString
(
aRootKey
aKeyName
aValueName
Span
<
char16_t
>
(
(
char16_t
*
)
aBuffer
.
data
(
)
aBuffer
.
Length
(
)
)
aFlags
)
;
}
[
[
nodiscard
]
]
inline
bool
GetString
(
HKEY
aRootKey
const
nsString
&
aKeyName
const
nsString
&
aValueName
nsString
&
aBuffer
StringFlags
aFlags
=
StringFlags
:
:
Default
)
{
Key
k
(
aRootKey
aKeyName
KeyMode
:
:
QueryValue
)
;
return
k
&
&
k
.
GetValueAsString
(
aValueName
aBuffer
aFlags
)
;
}
inline
Maybe
<
nsString
>
GetString
(
HKEY
aRootKey
const
nsString
&
aKeyName
const
nsString
&
aValueName
StringFlags
aFlags
=
StringFlags
:
:
Default
)
{
Key
k
(
aRootKey
aKeyName
KeyMode
:
:
QueryValue
)
;
if
(
!
k
)
{
return
Nothing
(
)
;
}
return
k
.
GetValueAsString
(
aValueName
aFlags
)
;
}
class
KeyWatcher
final
{
public
:
using
Callback
=
std
:
:
function
<
void
(
)
>
;
KeyWatcher
(
const
KeyWatcher
&
)
=
delete
;
const
Key
&
GetKey
(
)
const
{
return
mKey
;
}
KeyWatcher
(
Key
&
&
aKey
nsISerialEventTarget
*
aTargetSerialEventTarget
Callback
&
&
aCallback
)
;
~
KeyWatcher
(
)
;
private
:
static
void
CALLBACK
WatchCallback
(
void
*
aContext
BOOLEAN
)
;
bool
Register
(
)
;
Key
mKey
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
Callback
mCallback
;
HANDLE
mEvent
=
nullptr
;
HANDLE
mWaitObject
=
nullptr
;
}
;
}
#
endif
