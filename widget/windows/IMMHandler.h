#
ifndef
IMMHandler_h_
#
define
IMMHandler_h_
#
include
"
nscore
.
h
"
#
include
<
windows
.
h
>
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
WritingModes
.
h
"
#
include
"
npapi
.
h
"
class
nsWindow
;
class
nsWindowBase
;
namespace
mozilla
{
namespace
widget
{
struct
MSGResult
;
class
IMEContext
final
{
public
:
IMEContext
(
)
:
mWnd
(
nullptr
)
mIMC
(
nullptr
)
{
}
explicit
IMEContext
(
HWND
aWnd
)
;
explicit
IMEContext
(
nsWindowBase
*
aWindowBase
)
;
~
IMEContext
(
)
{
Clear
(
)
;
}
HIMC
get
(
)
const
{
return
mIMC
;
}
void
Init
(
HWND
aWnd
)
;
void
Init
(
nsWindowBase
*
aWindowBase
)
;
void
Clear
(
)
;
bool
IsValid
(
)
const
{
return
!
!
mIMC
;
}
void
SetOpenState
(
bool
aOpen
)
const
{
if
(
!
mIMC
)
{
return
;
}
:
:
ImmSetOpenStatus
(
mIMC
aOpen
)
;
}
bool
GetOpenState
(
)
const
{
if
(
!
mIMC
)
{
return
false
;
}
return
(
:
:
ImmGetOpenStatus
(
mIMC
)
!
=
FALSE
)
;
}
bool
AssociateDefaultContext
(
)
{
if
(
mIMC
)
{
return
false
;
}
if
(
!
:
:
ImmAssociateContextEx
(
mWnd
nullptr
IACE_DEFAULT
)
)
{
return
false
;
}
mIMC
=
:
:
ImmGetContext
(
mWnd
)
;
return
(
mIMC
!
=
nullptr
)
;
}
bool
Disassociate
(
)
{
if
(
!
mIMC
)
{
return
false
;
}
if
(
!
:
:
ImmAssociateContextEx
(
mWnd
nullptr
0
)
)
{
return
false
;
}
:
:
ImmReleaseContext
(
mWnd
mIMC
)
;
mIMC
=
nullptr
;
return
true
;
}
protected
:
IMEContext
(
const
IMEContext
&
aOther
)
{
MOZ_CRASH
(
"
Don
'
t
copy
IMEContext
"
)
;
}
HWND
mWnd
;
HIMC
mIMC
;
}
;
class
IMMHandler
final
{
public
:
static
void
Initialize
(
)
;
static
void
Terminate
(
)
;
static
bool
ProcessMessage
(
nsWindow
*
aWindow
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
MSGResult
&
aResult
)
;
static
bool
IsComposing
(
)
{
return
IsComposingOnOurEditor
(
)
;
}
static
bool
IsComposingOn
(
nsWindow
*
aWindow
)
{
return
IsComposing
(
)
&
&
IsComposingWindow
(
aWindow
)
;
}
#
ifdef
DEBUG
static
bool
IsIMEAvailable
(
)
{
return
!
!
:
:
ImmIsIME
(
:
:
GetKeyboardLayout
(
0
)
)
;
}
#
endif
static
void
CommitComposition
(
nsWindow
*
aWindow
bool
aForce
=
false
)
;
static
void
CancelComposition
(
nsWindow
*
aWindow
bool
aForce
=
false
)
;
static
void
OnFocusChange
(
bool
aFocus
nsWindow
*
aWindow
)
;
static
void
OnUpdateComposition
(
nsWindow
*
aWindow
)
;
static
void
OnSelectionChange
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
bool
aIsIMMActive
)
;
static
IMENotificationRequests
GetIMENotificationRequests
(
)
;
static
nsresult
OnMouseButtonEvent
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
)
;
static
void
SetCandidateWindow
(
nsWindow
*
aWindow
CANDIDATEFORM
*
aForm
)
;
static
void
DefaultProcOfPluginEvent
(
nsWindow
*
aWindow
const
NPEvent
*
aEvent
)
;
#
define
DECL_IS_IME_ACTIVE
(
aReadableName
)
\
static
bool
Is
#
#
aReadableName
#
#
Active
(
)
;
DECL_IS_IME_ACTIVE
(
ATOK2006
)
DECL_IS_IME_ACTIVE
(
ATOK2007
)
DECL_IS_IME_ACTIVE
(
ATOK2008
)
DECL_IS_IME_ACTIVE
(
ATOK2009
)
DECL_IS_IME_ACTIVE
(
ATOK2010
)
DECL_IS_IME_ACTIVE
(
GoogleJapaneseInput
)
DECL_IS_IME_ACTIVE
(
Japanist2003
)
#
undef
DECL_IS_IME_ACTIVE
static
bool
IsActiveIMEInBlockList
(
)
;
protected
:
static
void
EnsureHandlerInstance
(
)
;
static
bool
IsComposingOnOurEditor
(
)
;
static
bool
IsComposingOnPlugin
(
)
;
static
bool
IsComposingWindow
(
nsWindow
*
aWindow
)
;
static
bool
ShouldDrawCompositionStringOurselves
(
)
;
static
bool
IsVerticalWritingSupported
(
)
;
static
void
InitKeyboardLayout
(
nsWindow
*
aWindow
HKL
aKeyboardLayout
)
;
static
UINT
GetKeyboardCodePage
(
)
;
static
bool
IsTopLevelWindowOfComposition
(
nsWindow
*
aWindow
)
;
static
bool
ProcessInputLangChangeMessage
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
static
bool
ProcessMessageForPlugin
(
nsWindow
*
aWindow
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
bool
&
aRet
MSGResult
&
aResult
)
;
IMMHandler
(
)
;
~
IMMHandler
(
)
;
static
bool
OnKeyDownEvent
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
bool
OnIMEStartComposition
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
;
void
OnIMEStartCompositionOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
)
;
bool
OnIMEComposition
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
void
OnIMECompositionOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
)
;
bool
OnIMEEndComposition
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
;
void
OnIMEEndCompositionOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
)
;
bool
OnIMERequest
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
bool
OnIMECharOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
bool
OnChar
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
bool
OnCharOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
void
OnInputLangChange
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
static
bool
OnIMEChar
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
static
bool
OnIMESetContext
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
static
bool
OnIMESetContextOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
static
bool
OnIMECompositionFull
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
;
static
bool
OnIMENotify
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
static
bool
OnIMESelect
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
;
void
HandleStartComposition
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
;
bool
HandleComposition
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
LPARAM
lParam
)
;
void
HandleEndComposition
(
nsWindow
*
aWindow
const
nsAString
*
aCommitString
=
nullptr
)
;
bool
HandleReconvert
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
;
bool
HandleQueryCharPosition
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
;
bool
HandleDocumentFeed
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
;
bool
CommitCompositionOnPreviousWindow
(
nsWindow
*
aWindow
)
;
void
ResolveIMECaretPos
(
nsIWidget
*
aReferenceWidget
mozilla
:
:
LayoutDeviceIntRect
&
aCursorRect
nsIWidget
*
aNewOriginWidget
mozilla
:
:
LayoutDeviceIntRect
&
aOutRect
)
;
bool
ConvertToANSIString
(
const
nsString
&
aStr
UINT
aCodePage
nsACString
&
aANSIStr
)
;
bool
SetIMERelatedWindowsPos
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
;
void
SetIMERelatedWindowsPosOnPlugin
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
;
bool
GetCharacterRectOfSelectedTextAt
(
nsWindow
*
aWindow
uint32_t
aOffset
mozilla
:
:
LayoutDeviceIntRect
&
aCharRect
mozilla
:
:
WritingMode
*
aWritingMode
=
nullptr
)
;
bool
GetCaretRect
(
nsWindow
*
aWindow
mozilla
:
:
LayoutDeviceIntRect
&
aCaretRect
mozilla
:
:
WritingMode
*
aWritingMode
=
nullptr
)
;
void
GetCompositionString
(
const
IMEContext
&
aContext
DWORD
aIndex
nsAString
&
aCompositionString
)
const
;
void
AdjustCompositionFont
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
const
mozilla
:
:
WritingMode
&
aWritingMode
bool
aForceUpdate
=
false
)
;
static
void
MaybeAdjustCompositionFont
(
nsWindow
*
aWindow
const
mozilla
:
:
WritingMode
&
aWritingMode
bool
aForceUpdate
=
false
)
;
bool
GetTargetClauseRange
(
uint32_t
*
aOffset
uint32_t
*
aLength
=
nullptr
)
;
static
void
DispatchEvent
(
nsWindow
*
aWindow
WidgetGUIEvent
&
aEvent
)
;
void
DispatchCompositionChangeEvent
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
;
nsresult
EnsureClauseArray
(
int32_t
aCount
)
;
nsresult
EnsureAttributeArray
(
int32_t
aCount
)
;
nsTArray
<
MSG
>
mPassedIMEChar
;
bool
IsIMECharRecordsEmpty
(
)
{
return
mPassedIMEChar
.
IsEmpty
(
)
;
}
void
ResetIMECharRecords
(
)
{
mPassedIMEChar
.
Clear
(
)
;
}
void
DequeueIMECharRecords
(
WPARAM
&
wParam
LPARAM
&
lParam
)
{
MSG
msg
=
mPassedIMEChar
.
ElementAt
(
0
)
;
wParam
=
msg
.
wParam
;
lParam
=
msg
.
lParam
;
mPassedIMEChar
.
RemoveElementAt
(
0
)
;
}
void
EnqueueIMECharRecords
(
WPARAM
wParam
LPARAM
lParam
)
{
MSG
msg
;
msg
.
wParam
=
wParam
;
msg
.
lParam
=
lParam
;
mPassedIMEChar
.
AppendElement
(
msg
)
;
}
TextEventDispatcher
*
GetTextEventDispatcherFor
(
nsWindow
*
aWindow
)
;
nsWindow
*
mComposingWindow
;
RefPtr
<
TextEventDispatcher
>
mDispatcher
;
nsString
mCompositionString
;
nsTArray
<
uint32_t
>
mClauseArray
;
nsTArray
<
uint8_t
>
mAttributeArray
;
int32_t
mCursorPosition
;
uint32_t
mCompositionStart
;
struct
Selection
{
nsString
mString
;
uint32_t
mOffset
;
mozilla
:
:
WritingMode
mWritingMode
;
bool
mIsValid
;
Selection
(
)
:
mOffset
(
UINT32_MAX
)
mIsValid
(
false
)
{
}
void
Clear
(
)
{
mOffset
=
UINT32_MAX
;
mIsValid
=
false
;
}
uint32_t
Length
(
)
const
{
return
mString
.
Length
(
)
;
}
bool
Collapsed
(
)
const
{
return
!
Length
(
)
;
}
bool
IsValid
(
)
const
;
bool
Update
(
const
IMENotification
&
aIMENotification
)
;
bool
Init
(
nsWindow
*
aWindow
)
;
bool
EnsureValidSelection
(
nsWindow
*
aWindow
)
;
private
:
Selection
(
const
Selection
&
aOther
)
=
delete
;
void
operator
=
(
const
Selection
&
aOther
)
=
delete
;
}
;
Selection
mSelection
;
Selection
&
GetSelection
(
)
{
if
(
sHasFocus
)
{
return
mSelection
;
}
static
Selection
sTempSelection
;
sTempSelection
.
Clear
(
)
;
return
sTempSelection
;
}
bool
mIsComposing
;
bool
mIsComposingOnPlugin
;
static
mozilla
:
:
WritingMode
sWritingModeOfCompositionFont
;
static
nsString
sIMEName
;
static
UINT
sCodePage
;
static
DWORD
sIMEProperty
;
static
DWORD
sIMEUIProperty
;
static
bool
sAssumeVerticalWritingModeNotSupported
;
static
bool
sHasFocus
;
}
;
}
}
#
endif
