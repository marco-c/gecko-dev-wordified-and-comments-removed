#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
nsWindowGfx
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
<
windows
.
h
>
#
include
<
shellapi
.
h
>
#
include
"
gfxEnv
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
gfxWindowsSurface
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
gfxDWriteFonts
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsGfxCIID
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
WinWindowOcclusionTracker
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
WindowRenderer
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
InProcessWinCompositorWidget
.
h
"
#
include
"
nsUXThemeData
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
:
:
plugins
;
extern
mozilla
:
:
LazyLogModule
gWindowsLog
;
struct
IconMetrics
{
int32_t
xMetric
;
int32_t
yMetric
;
int32_t
defaultSize
;
}
;
static
IconMetrics
sIconMetrics
[
]
=
{
{
SM_CXSMICON
SM_CYSMICON
16
}
{
SM_CXICON
SM_CYICON
32
}
}
;
LayoutDeviceIntRegion
nsWindow
:
:
GetRegionToPaint
(
const
PAINTSTRUCT
&
ps
HDC
aDC
)
const
{
LayoutDeviceIntRegion
fullRegion
(
WinUtils
:
:
ToIntRect
(
ps
.
rcPaint
)
)
;
HRGN
paintRgn
=
:
:
CreateRectRgn
(
0
0
0
0
)
;
if
(
paintRgn
)
{
if
(
GetRandomRgn
(
aDC
paintRgn
SYSRGN
)
=
=
1
)
{
POINT
pt
=
{
0
0
}
;
:
:
MapWindowPoints
(
nullptr
mWnd
&
pt
1
)
;
:
:
OffsetRgn
(
paintRgn
pt
.
x
pt
.
y
)
;
fullRegion
.
AndWith
(
WinUtils
:
:
ConvertHRGNToRegion
(
paintRgn
)
)
;
}
:
:
DeleteObject
(
paintRgn
)
;
}
return
fullRegion
;
}
nsIWidgetListener
*
nsWindow
:
:
GetPaintListener
(
)
{
if
(
mDestroyCalled
)
return
nullptr
;
return
mAttachedWidgetListener
?
mAttachedWidgetListener
:
mWidgetListener
;
}
void
nsWindow
:
:
ForcePresent
(
)
{
if
(
mResizeState
!
=
RESIZING
)
{
if
(
CompositorBridgeChild
*
remoteRenderer
=
GetRemoteRenderer
(
)
)
{
remoteRenderer
-
>
SendForcePresent
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
}
}
}
bool
nsWindow
:
:
OnPaint
(
uint32_t
aNestingLevel
)
{
gfx
:
:
DeviceResetReason
resetReason
=
gfx
:
:
DeviceResetReason
:
:
OK
;
if
(
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
DidRenderingDeviceReset
(
&
resetReason
)
)
{
gfxCriticalNote
<
<
"
(
nsWindow
)
Detected
device
reset
:
"
<
<
(
int
)
resetReason
;
gfxWindowsPlatform
:
:
GetPlatform
(
)
-
>
UpdateRenderMode
(
)
;
GPUProcessManager
:
:
GPUProcessManager
:
:
NotifyDeviceReset
(
resetReason
gfx
:
:
DeviceResetDetectPlace
:
:
WIDGET
)
;
gfxCriticalNote
<
<
"
(
nsWindow
)
Finished
device
reset
.
"
;
return
false
;
}
PAINTSTRUCT
ps
;
if
(
mIsEarlyBlankWindow
)
{
:
:
BeginPaint
(
mWnd
&
ps
)
;
:
:
EndPaint
(
mWnd
&
ps
)
;
return
true
;
}
WindowRenderer
*
renderer
=
GetWindowRenderer
(
)
;
KnowsCompositor
*
knowsCompositor
=
renderer
-
>
AsKnowsCompositor
(
)
;
WebRenderLayerManager
*
layerManager
=
renderer
-
>
AsWebRender
(
)
;
const
bool
didResize
=
!
mBounds
.
IsEqualEdges
(
mLastPaintBounds
)
;
if
(
didResize
&
&
knowsCompositor
&
&
layerManager
)
{
layerManager
-
>
ScheduleComposite
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
}
mLastPaintBounds
=
mBounds
;
RefPtr
<
nsWindow
>
strongThis
(
this
)
;
if
(
nsIWidgetListener
*
listener
=
GetPaintListener
(
)
)
{
listener
-
>
WillPaintWindow
(
this
)
;
}
const
bool
usingMemoryDC
=
renderer
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_NONE
&
&
mTransparencyMode
=
=
TransparencyMode
:
:
Transparent
;
HDC
hDC
=
nullptr
;
const
LayoutDeviceIntRect
winRect
=
[
&
]
{
RECT
r
;
:
:
GetWindowRect
(
mWnd
&
r
)
;
:
:
MapWindowPoints
(
nullptr
mWnd
(
LPPOINT
)
&
r
2
)
;
return
WinUtils
:
:
ToIntRect
(
r
)
;
}
(
)
;
LayoutDeviceIntRegion
region
;
LayoutDeviceIntRegion
translucentRegion
;
if
(
usingMemoryDC
)
{
:
:
BeginPaint
(
mWnd
&
ps
)
;
:
:
EndPaint
(
mWnd
&
ps
)
;
hDC
=
mBasicLayersSurface
-
>
GetTransparentDC
(
)
;
region
=
translucentRegion
=
LayoutDeviceIntRegion
{
winRect
}
;
}
else
{
hDC
=
:
:
BeginPaint
(
mWnd
&
ps
)
;
region
=
GetRegionToPaint
(
ps
hDC
)
;
if
(
mTransparencyMode
=
=
TransparencyMode
:
:
Transparent
)
{
translucentRegion
=
LayoutDeviceIntRegion
{
winRect
}
;
translucentRegion
.
SubOut
(
mOpaqueRegion
)
;
region
.
OrWith
(
translucentRegion
)
;
}
}
if
(
!
usingMemoryDC
&
&
(
mNeedsNCAreaClear
|
|
didResize
)
)
{
auto
black
=
reinterpret_cast
<
HBRUSH
>
(
:
:
GetStockObject
(
BLACK_BRUSH
)
)
;
nsAutoRegion
regionToClear
(
ComputeNonClientHRGN
(
)
)
;
if
(
mTransparencyMode
=
=
TransparencyMode
:
:
Transparent
&
&
!
translucentRegion
.
IsEmpty
(
)
)
{
nsAutoRegion
translucent
(
WinUtils
:
:
RegionToHRGN
(
translucentRegion
)
)
;
:
:
CombineRgn
(
regionToClear
regionToClear
translucent
RGN_OR
)
;
}
:
:
FillRgn
(
hDC
regionToClear
black
)
;
}
mNeedsNCAreaClear
=
false
;
bool
didPaint
=
false
;
auto
endPaint
=
MakeScopeExit
(
[
&
]
{
if
(
!
usingMemoryDC
)
{
:
:
EndPaint
(
mWnd
&
ps
)
;
}
if
(
didPaint
)
{
mLastPaintEndTime
=
TimeStamp
:
:
Now
(
)
;
if
(
nsIWidgetListener
*
listener
=
GetPaintListener
(
)
)
{
listener
-
>
DidPaintWindow
(
)
;
}
if
(
aNestingLevel
=
=
0
&
&
:
:
GetUpdateRect
(
mWnd
nullptr
false
)
)
{
OnPaint
(
1
)
;
}
}
}
)
;
if
(
region
.
IsEmpty
(
)
|
|
!
GetPaintListener
(
)
)
{
return
false
;
}
if
(
knowsCompositor
&
&
layerManager
)
{
layerManager
-
>
SendInvalidRegion
(
region
.
ToUnknownRegion
(
)
)
;
layerManager
-
>
ScheduleComposite
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
}
#
ifdef
WIDGET_DEBUG_OUTPUT
debug_DumpPaintEvent
(
stdout
this
region
.
ToUnknownRegion
(
)
"
noname
"
(
int32_t
)
mWnd
)
;
#
endif
bool
result
=
true
;
switch
(
renderer
-
>
GetBackendType
(
)
)
{
case
LayersBackend
:
:
LAYERS_NONE
:
{
RefPtr
<
gfxASurface
>
targetSurface
;
if
(
TransparencyMode
:
:
Transparent
=
=
mTransparencyMode
)
{
MutexAutoLock
lock
(
mBasicLayersSurface
-
>
GetTransparentSurfaceLock
(
)
)
;
targetSurface
=
mBasicLayersSurface
-
>
EnsureTransparentSurface
(
)
;
}
RefPtr
<
gfxWindowsSurface
>
targetSurfaceWin
;
if
(
!
targetSurface
)
{
uint32_t
flags
=
(
mTransparencyMode
=
=
TransparencyMode
:
:
Opaque
)
?
0
:
gfxWindowsSurface
:
:
FLAG_IS_TRANSPARENT
;
targetSurfaceWin
=
new
gfxWindowsSurface
(
hDC
flags
)
;
targetSurface
=
targetSurfaceWin
;
}
RECT
paintRect
;
:
:
GetClientRect
(
mWnd
&
paintRect
)
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
CreateDrawTargetForSurface
(
targetSurface
IntSize
(
paintRect
.
right
-
paintRect
.
left
paintRect
.
bottom
-
paintRect
.
top
)
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
gfxWarning
(
)
<
<
"
nsWindow
:
:
OnPaint
failed
in
CreateDrawTargetForSurface
"
;
return
false
;
}
BufferMode
doubleBuffering
=
mozilla
:
:
layers
:
:
BufferMode
:
:
BUFFER_NONE
;
switch
(
mTransparencyMode
)
{
case
TransparencyMode
:
:
Transparent
:
dt
-
>
ClearRect
(
Rect
(
dt
-
>
GetRect
(
)
)
)
;
break
;
default
:
doubleBuffering
=
mozilla
:
:
layers
:
:
BufferMode
:
:
BUFFERED
;
break
;
}
gfxContext
thebesContext
(
dt
)
;
{
AutoLayerManagerSetup
setupLayerManager
(
this
&
thebesContext
doubleBuffering
)
;
if
(
nsIWidgetListener
*
listener
=
GetPaintListener
(
)
)
{
result
=
listener
-
>
PaintWindow
(
this
region
)
;
}
}
if
(
TransparencyMode
:
:
Transparent
=
=
mTransparencyMode
)
{
mBasicLayersSurface
-
>
RedrawTransparentWindow
(
)
;
}
}
break
;
case
LayersBackend
:
:
LAYERS_WR
:
{
if
(
nsIWidgetListener
*
listener
=
GetPaintListener
(
)
)
{
result
=
listener
-
>
PaintWindow
(
this
region
)
;
}
if
(
!
gfxEnv
:
:
MOZ_DISABLE_FORCE_PRESENT
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
nsWindow
:
:
ForcePresent
"
this
&
nsWindow
:
:
ForcePresent
)
;
NS_DispatchToMainThread
(
event
)
;
}
}
break
;
default
:
NS_ERROR
(
"
Unknown
layers
backend
used
!
"
)
;
break
;
}
didPaint
=
true
;
return
result
;
}
bool
nsWindow
:
:
NeedsToTrackWindowOcclusionState
(
)
{
if
(
!
WinWindowOcclusionTracker
:
:
Get
(
)
)
{
return
false
;
}
if
(
mCompositorSession
&
&
mWindowType
=
=
WindowType
:
:
TopLevel
)
{
return
true
;
}
return
false
;
}
void
nsWindow
:
:
NotifyOcclusionState
(
mozilla
:
:
widget
:
:
OcclusionState
aState
)
{
MOZ_ASSERT
(
NeedsToTrackWindowOcclusionState
(
)
)
;
bool
isFullyOccluded
=
aState
=
=
mozilla
:
:
widget
:
:
OcclusionState
:
:
OCCLUDED
;
if
(
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Minimized
)
{
isFullyOccluded
=
false
;
}
if
(
mIsFullyOccluded
=
=
isFullyOccluded
)
{
return
;
}
mIsFullyOccluded
=
isFullyOccluded
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Info
(
"
nsWindow
:
:
NotifyOcclusionState
(
)
mIsFullyOccluded
%
d
"
"
mFrameState
-
>
GetSizeMode
(
)
%
d
"
mIsFullyOccluded
mFrameState
-
>
GetSizeMode
(
)
)
)
;
wr
:
:
DebugFlags
flags
{
0
}
;
flags
.
_0
=
gfx
:
:
gfxVars
:
:
WebRenderDebugFlags
(
)
;
bool
debugEnabled
=
bool
(
flags
&
wr
:
:
DebugFlags
:
:
WINDOW_VISIBILITY_DBG
)
;
if
(
debugEnabled
&
&
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
NotifyVisibilityUpdated
(
mIsFullyOccluded
)
;
}
if
(
mWidgetListener
)
{
mWidgetListener
-
>
OcclusionStateChanged
(
mIsFullyOccluded
)
;
}
}
void
nsWindow
:
:
MaybeEnableWindowOcclusion
(
bool
aEnable
)
{
if
(
!
mCompositorSession
)
{
return
;
}
bool
enabled
=
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
WINDOW_OCCLUSION
)
;
if
(
aEnable
)
{
if
(
enabled
&
&
NeedsToTrackWindowOcclusionState
(
)
)
{
WinWindowOcclusionTracker
:
:
Get
(
)
-
>
Enable
(
this
mWnd
)
;
wr
:
:
DebugFlags
flags
{
0
}
;
flags
.
_0
=
gfx
:
:
gfxVars
:
:
WebRenderDebugFlags
(
)
;
bool
debugEnabled
=
bool
(
flags
&
wr
:
:
DebugFlags
:
:
WINDOW_VISIBILITY_DBG
)
;
if
(
debugEnabled
&
&
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
NotifyVisibilityUpdated
(
mIsFullyOccluded
)
;
}
}
return
;
}
MOZ_ASSERT
(
!
aEnable
)
;
if
(
!
NeedsToTrackWindowOcclusionState
(
)
)
{
return
;
}
WinWindowOcclusionTracker
:
:
Get
(
)
-
>
Disable
(
this
mWnd
)
;
NotifyOcclusionState
(
OcclusionState
:
:
VISIBLE
)
;
wr
:
:
DebugFlags
flags
{
0
}
;
flags
.
_0
=
gfx
:
:
gfxVars
:
:
WebRenderDebugFlags
(
)
;
bool
debugEnabled
=
bool
(
flags
&
wr
:
:
DebugFlags
:
:
WINDOW_VISIBILITY_DBG
)
;
if
(
debugEnabled
&
&
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
NotifyVisibilityUpdated
(
mIsFullyOccluded
)
;
}
}
void
nsWindow
:
:
CreateCompositor
(
)
{
nsBaseWidget
:
:
CreateCompositor
(
)
;
MaybeEnableWindowOcclusion
(
true
)
;
if
(
mRequestFxrOutputPending
)
{
GetRemoteRenderer
(
)
-
>
SendRequestFxrOutput
(
)
;
}
}
void
nsWindow
:
:
DestroyCompositor
(
)
{
MaybeEnableWindowOcclusion
(
false
)
;
nsBaseWidget
:
:
DestroyCompositor
(
)
;
}
void
nsWindow
:
:
RequestFxrOutput
(
)
{
if
(
GetRemoteRenderer
(
)
!
=
nullptr
)
{
MOZ_CRASH
(
"
RequestFxrOutput
should
happen
before
Compositor
is
created
.
"
)
;
}
else
{
mRequestFxrOutputPending
=
true
;
}
}
LayoutDeviceIntSize
nsWindowGfx
:
:
GetIconMetrics
(
IconSizeType
aSizeType
)
{
int32_t
width
=
:
:
GetSystemMetrics
(
sIconMetrics
[
aSizeType
]
.
xMetric
)
;
int32_t
height
=
:
:
GetSystemMetrics
(
sIconMetrics
[
aSizeType
]
.
yMetric
)
;
if
(
width
=
=
0
|
|
height
=
=
0
)
{
width
=
height
=
sIconMetrics
[
aSizeType
]
.
defaultSize
;
}
return
LayoutDeviceIntSize
(
width
height
)
;
}
nsresult
nsWindowGfx
:
:
CreateIcon
(
imgIContainer
*
aContainer
bool
aIsCursor
LayoutDeviceIntPoint
aHotspot
LayoutDeviceIntSize
aScaledSize
HICON
*
aIcon
)
{
MOZ_ASSERT
(
aHotspot
.
x
>
=
0
&
&
aHotspot
.
y
>
=
0
)
;
MOZ_ASSERT
(
(
aScaledSize
.
width
>
0
&
&
aScaledSize
.
height
>
0
)
|
|
(
aScaledSize
.
width
=
=
0
&
&
aScaledSize
.
height
=
=
0
)
)
;
RefPtr
<
SourceSurface
>
surface
=
aContainer
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
NS_ENSURE_TRUE
(
surface
NS_ERROR_NOT_AVAILABLE
)
;
IntSize
frameSize
=
surface
-
>
GetSize
(
)
;
if
(
frameSize
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
IntSize
iconSize
(
aScaledSize
.
width
aScaledSize
.
height
)
;
if
(
iconSize
=
=
IntSize
(
0
0
)
)
{
iconSize
=
frameSize
;
}
RefPtr
<
DataSourceSurface
>
dataSurface
;
bool
mappedOK
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
iconSize
!
=
frameSize
)
{
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
iconSize
SurfaceFormat
:
:
B8G8R8A8
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
mappedOK
=
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ_WRITE
&
map
)
;
NS_ENSURE_TRUE
(
mappedOK
NS_ERROR_FAILURE
)
;
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
map
.
mData
dataSurface
-
>
GetSize
(
)
map
.
mStride
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
{
gfxWarning
(
)
<
<
"
nsWindowGfx
:
:
CreatesIcon
failed
in
CreateDrawTargetForData
"
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
dt
-
>
DrawSurface
(
surface
Rect
(
0
0
iconSize
.
width
iconSize
.
height
)
Rect
(
0
0
frameSize
.
width
frameSize
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
else
if
(
surface
-
>
GetFormat
(
)
!
=
SurfaceFormat
:
:
B8G8R8A8
)
{
dataSurface
=
gfxUtils
:
:
CopySurfaceToDataSourceSurfaceWithFormat
(
surface
SurfaceFormat
:
:
B8G8R8A8
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
mappedOK
=
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
;
}
else
{
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
mappedOK
=
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
;
}
NS_ENSURE_TRUE
(
dataSurface
&
&
mappedOK
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
dataSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
)
;
uint8_t
*
data
=
nullptr
;
UniquePtr
<
uint8_t
[
]
>
autoDeleteArray
;
if
(
map
.
mStride
=
=
BytesPerPixel
(
dataSurface
-
>
GetFormat
(
)
)
*
iconSize
.
width
)
{
data
=
map
.
mData
;
}
else
{
dataSurface
-
>
Unmap
(
)
;
map
.
mData
=
nullptr
;
autoDeleteArray
=
SurfaceToPackedBGRA
(
dataSurface
)
;
data
=
autoDeleteArray
.
get
(
)
;
NS_ENSURE_TRUE
(
data
NS_ERROR_FAILURE
)
;
}
HBITMAP
bmp
=
DataToBitmap
(
data
iconSize
.
width
-
iconSize
.
height
32
)
;
uint8_t
*
a1data
=
Data32BitTo1Bit
(
data
iconSize
.
width
iconSize
.
height
)
;
if
(
map
.
mData
)
{
dataSurface
-
>
Unmap
(
)
;
}
if
(
!
a1data
)
{
return
NS_ERROR_FAILURE
;
}
HBITMAP
mbmp
=
DataToBitmap
(
a1data
iconSize
.
width
-
iconSize
.
height
1
)
;
free
(
a1data
)
;
ICONINFO
info
=
{
0
}
;
info
.
fIcon
=
!
aIsCursor
;
info
.
xHotspot
=
aHotspot
.
x
;
info
.
yHotspot
=
aHotspot
.
y
;
info
.
hbmMask
=
mbmp
;
info
.
hbmColor
=
bmp
;
HCURSOR
icon
=
:
:
CreateIconIndirect
(
&
info
)
;
:
:
DeleteObject
(
mbmp
)
;
:
:
DeleteObject
(
bmp
)
;
if
(
!
icon
)
return
NS_ERROR_FAILURE
;
*
aIcon
=
icon
;
return
NS_OK
;
}
uint8_t
*
nsWindowGfx
:
:
Data32BitTo1Bit
(
uint8_t
*
aImageData
uint32_t
aWidth
uint32_t
aHeight
)
{
uint32_t
outBpr
=
(
(
aWidth
+
31
)
/
8
)
&
~
3
;
uint8_t
*
outData
=
(
uint8_t
*
)
calloc
(
outBpr
aHeight
)
;
if
(
!
outData
)
return
nullptr
;
int32_t
*
imageRow
=
(
int32_t
*
)
aImageData
;
for
(
uint32_t
curRow
=
0
;
curRow
<
aHeight
;
curRow
+
+
)
{
uint8_t
*
outRow
=
outData
+
curRow
*
outBpr
;
uint8_t
mask
=
0x80
;
for
(
uint32_t
curCol
=
0
;
curCol
<
aWidth
;
curCol
+
+
)
{
if
(
*
imageRow
+
+
<
0
)
*
outRow
|
=
mask
;
mask
>
>
=
1
;
if
(
!
mask
)
{
outRow
+
+
;
mask
=
0x80
;
}
}
}
return
outData
;
}
HBITMAP
nsWindowGfx
:
:
DataToBitmap
(
uint8_t
*
aImageData
uint32_t
aWidth
uint32_t
aHeight
uint32_t
aDepth
)
{
HDC
dc
=
:
:
GetDC
(
nullptr
)
;
if
(
aDepth
=
=
32
)
{
BITMAPV4HEADER
head
=
{
0
}
;
head
.
bV4Size
=
sizeof
(
head
)
;
head
.
bV4Width
=
aWidth
;
head
.
bV4Height
=
aHeight
;
head
.
bV4Planes
=
1
;
head
.
bV4BitCount
=
aDepth
;
head
.
bV4V4Compression
=
BI_BITFIELDS
;
head
.
bV4SizeImage
=
0
;
head
.
bV4XPelsPerMeter
=
0
;
head
.
bV4YPelsPerMeter
=
0
;
head
.
bV4ClrUsed
=
0
;
head
.
bV4ClrImportant
=
0
;
head
.
bV4RedMask
=
0x00FF0000
;
head
.
bV4GreenMask
=
0x0000FF00
;
head
.
bV4BlueMask
=
0x000000FF
;
head
.
bV4AlphaMask
=
0xFF000000
;
HBITMAP
bmp
=
:
:
CreateDIBitmap
(
dc
reinterpret_cast
<
CONST
BITMAPINFOHEADER
*
>
(
&
head
)
CBM_INIT
aImageData
reinterpret_cast
<
CONST
BITMAPINFO
*
>
(
&
head
)
DIB_RGB_COLORS
)
;
:
:
ReleaseDC
(
nullptr
dc
)
;
return
bmp
;
}
char
reserved_space
[
sizeof
(
BITMAPINFOHEADER
)
+
sizeof
(
RGBQUAD
)
*
2
]
;
BITMAPINFOHEADER
&
head
=
*
(
BITMAPINFOHEADER
*
)
reserved_space
;
head
.
biSize
=
sizeof
(
BITMAPINFOHEADER
)
;
head
.
biWidth
=
aWidth
;
head
.
biHeight
=
aHeight
;
head
.
biPlanes
=
1
;
head
.
biBitCount
=
(
WORD
)
aDepth
;
head
.
biCompression
=
BI_RGB
;
head
.
biSizeImage
=
0
;
head
.
biXPelsPerMeter
=
0
;
head
.
biYPelsPerMeter
=
0
;
head
.
biClrUsed
=
0
;
head
.
biClrImportant
=
0
;
BITMAPINFO
&
bi
=
*
(
BITMAPINFO
*
)
reserved_space
;
if
(
aDepth
=
=
1
)
{
RGBQUAD
black
=
{
0
0
0
0
}
;
RGBQUAD
white
=
{
255
255
255
0
}
;
bi
.
bmiColors
[
0
]
=
white
;
bi
.
bmiColors
[
1
]
=
black
;
}
HBITMAP
bmp
=
:
:
CreateDIBitmap
(
dc
&
head
CBM_INIT
aImageData
&
bi
DIB_RGB_COLORS
)
;
:
:
ReleaseDC
(
nullptr
dc
)
;
return
bmp
;
}
