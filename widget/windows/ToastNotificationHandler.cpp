#
include
"
ToastNotificationHandler
.
h
"
#
include
<
windows
.
foundation
.
h
>
#
include
"
gfxUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
json
/
json
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
ifdef
MOZ_BACKGROUNDTASKS
#
include
"
mozilla
/
BackgroundTasks
.
h
"
#
endif
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
JSONStringWriteFuncs
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Tokenizer
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
mozilla
/
intl
/
Localization
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryServiceUtils
.
h
"
#
include
"
nsIDUtils
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIToolkitProfile
.
h
"
#
include
"
nsIToolkitProfileService
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsXREDirProvider
.
h
"
#
include
"
ToastNotificationHeaderOnlyUtils
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
ToastNotification
.
h
"
namespace
mozilla
{
namespace
widget
{
extern
LazyLogModule
sWASLog
;
using
namespace
ABI
:
:
Windows
:
:
Data
:
:
Xml
:
:
Dom
;
using
namespace
ABI
:
:
Windows
:
:
Foundation
;
using
namespace
ABI
:
:
Windows
:
:
UI
:
:
Notifications
;
using
namespace
Microsoft
:
:
WRL
;
using
namespace
Microsoft
:
:
WRL
:
:
Wrappers
;
using
namespace
toastnotification
;
using
WinToastNotification
=
ABI
:
:
Windows
:
:
UI
:
:
Notifications
:
:
ToastNotification
;
using
ToastActivationHandler
=
ITypedEventHandler
<
WinToastNotification
*
IInspectable
*
>
;
using
ToastDismissedHandler
=
ITypedEventHandler
<
WinToastNotification
*
ToastDismissedEventArgs
*
>
;
using
ToastFailedHandler
=
ITypedEventHandler
<
WinToastNotification
*
ToastFailedEventArgs
*
>
;
using
IVectorView_ToastNotification
=
Collections
:
:
IVectorView
<
WinToastNotification
*
>
;
NS_IMPL_ISUPPORTS
(
ToastNotificationHandler
nsIAlertNotificationImageListener
)
static
bool
SetNodeValueString
(
const
nsString
&
aString
IXmlNode
*
node
IXmlDocument
*
xml
)
{
ComPtr
<
IXmlText
>
inputText
;
HRESULT
hr
;
hr
=
xml
-
>
CreateTextNode
(
HStringReference
(
aString
.
get
(
)
)
.
Get
(
)
&
inputText
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
ComPtr
<
IXmlNode
>
inputTextNode
;
hr
=
inputText
.
As
(
&
inputTextNode
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
ComPtr
<
IXmlNode
>
appendedChild
;
hr
=
node
-
>
AppendChild
(
inputTextNode
.
Get
(
)
&
appendedChild
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
return
true
;
}
static
bool
SetAttribute
(
ComPtr
<
IXmlElement
>
&
element
const
HStringReference
&
name
const
nsAString
&
value
)
{
HString
valueStr
;
valueStr
.
Set
(
PromiseFlatString
(
value
)
.
get
(
)
)
;
HRESULT
hr
=
element
-
>
SetAttribute
(
name
.
Get
(
)
valueStr
.
Get
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
return
true
;
}
static
bool
AddActionNode
(
ComPtr
<
IXmlDocument
>
&
toastXml
ComPtr
<
IXmlNode
>
&
actionsNode
const
nsAString
&
actionTitle
const
nsAString
&
launchArg
const
nsAString
&
actionArgs
const
nsAString
&
actionPlacement
=
u
"
"
_ns
const
nsAString
&
activationType
=
u
"
"
_ns
)
{
ComPtr
<
IXmlElement
>
action
;
HRESULT
hr
=
toastXml
-
>
CreateElement
(
HStringReference
(
L
"
action
"
)
.
Get
(
)
&
action
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
bool
success
=
SetAttribute
(
action
HStringReference
(
L
"
content
"
)
actionTitle
)
;
NS_ENSURE_TRUE
(
success
false
)
;
nsAutoString
args
=
launchArg
+
u
"
\
n
"
_ns
+
nsDependentString
(
kLaunchArgAction
)
+
u
"
\
n
"
_ns
+
actionArgs
;
success
=
SetAttribute
(
action
HStringReference
(
L
"
arguments
"
)
args
)
;
NS_ENSURE_TRUE
(
success
false
)
;
if
(
!
actionPlacement
.
IsEmpty
(
)
)
{
success
=
SetAttribute
(
action
HStringReference
(
L
"
placement
"
)
actionPlacement
)
;
NS_ENSURE_TRUE
(
success
false
)
;
}
if
(
!
activationType
.
IsEmpty
(
)
)
{
success
=
SetAttribute
(
action
HStringReference
(
L
"
activationType
"
)
activationType
)
;
NS_ENSURE_TRUE
(
success
false
)
;
success
=
SetAttribute
(
action
HStringReference
(
L
"
arguments
"
)
actionArgs
)
;
NS_ENSURE_TRUE
(
success
false
)
;
}
ComPtr
<
IXmlNode
>
actionNode
;
hr
=
action
.
As
(
&
actionNode
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
ComPtr
<
IXmlNode
>
appendedChild
;
hr
=
actionsNode
-
>
AppendChild
(
actionNode
.
Get
(
)
&
appendedChild
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
return
true
;
}
nsresult
ToastNotificationHandler
:
:
GetWindowsTag
(
nsAString
&
aWindowsTag
)
{
aWindowsTag
.
Assign
(
mWindowsTag
)
;
return
NS_OK
;
}
nsresult
ToastNotificationHandler
:
:
SetWindowsTag
(
const
nsAString
&
aWindowsTag
)
{
mWindowsTag
.
Assign
(
aWindowsTag
)
;
return
NS_OK
;
}
Result
<
nsString
nsresult
>
ToastNotificationHandler
:
:
GetLaunchArgument
(
)
{
nsString
launchArg
;
if
(
!
Preferences
:
:
GetBool
(
"
alerts
.
useSystemBackend
.
windows
.
notificationserver
.
enabled
"
false
)
)
{
launchArg
+
=
u
"
invalid
key
\
ninvalid
value
"
_ns
;
return
launchArg
;
}
launchArg
+
=
nsDependentString
(
kLaunchArgProgram
)
+
u
"
\
n
"
_ns
MOZ_APP_NAME
;
nsCOMPtr
<
nsIFile
>
profDir
;
bool
wantCurrentProfile
=
true
;
#
ifdef
MOZ_BACKGROUNDTASKS
if
(
BackgroundTasks
:
:
IsBackgroundTaskMode
(
)
)
{
wantCurrentProfile
=
false
;
nsCOMPtr
<
nsIToolkitProfileService
>
profileSvc
=
do_GetService
(
NS_PROFILESERVICE_CONTRACTID
)
;
if
(
profileSvc
)
{
nsCOMPtr
<
nsIToolkitProfile
>
defaultProfile
;
nsresult
rv
=
profileSvc
-
>
GetDefaultProfile
(
getter_AddRefs
(
defaultProfile
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
defaultProfile
)
{
MOZ_TRY
(
defaultProfile
-
>
GetRootDir
(
getter_AddRefs
(
profDir
)
)
)
;
}
}
}
#
endif
if
(
wantCurrentProfile
)
{
MOZ_TRY
(
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
profDir
)
)
)
;
}
if
(
profDir
)
{
nsAutoString
profilePath
;
MOZ_TRY
(
profDir
-
>
GetPath
(
profilePath
)
)
;
launchArg
+
=
u
"
\
n
"
_ns
+
nsDependentString
(
kLaunchArgProfile
)
+
u
"
\
n
"
_ns
+
profilePath
;
}
launchArg
+
=
u
"
\
n
"
_ns
+
nsDependentString
(
kLaunchArgTag
)
+
u
"
\
n
"
_ns
+
mWindowsTag
;
if
(
Preferences
:
:
GetBool
(
"
alerts
.
useSystemBackend
.
windows
.
notificationserver
.
verbose
"
false
)
)
{
launchArg
+
=
u
"
\
n
"
_ns
+
nsDependentString
(
kLaunchArgLogging
)
+
u
"
\
nverbose
"
_ns
;
}
return
launchArg
;
}
static
ComPtr
<
IToastNotificationManagerStatics
>
GetToastNotificationManagerStatics
(
)
{
ComPtr
<
IToastNotificationManagerStatics
>
toastNotificationManagerStatics
;
HRESULT
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_UI_Notifications_ToastNotificationManager
)
.
Get
(
)
&
toastNotificationManagerStatics
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
return
toastNotificationManagerStatics
;
}
ToastNotificationHandler
:
:
~
ToastNotificationHandler
(
)
{
if
(
mImageRequest
)
{
mImageRequest
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mImageRequest
=
nullptr
;
}
if
(
mHasImage
&
&
mImageFile
)
{
DebugOnly
<
nsresult
>
rv
=
mImageFile
-
>
Remove
(
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Cannot
remove
temporary
image
file
"
)
;
}
UnregisterHandler
(
)
;
}
void
ToastNotificationHandler
:
:
UnregisterHandler
(
)
{
if
(
mNotification
)
{
mNotification
-
>
remove_Dismissed
(
mDismissedToken
)
;
mNotification
-
>
remove_Activated
(
mActivatedToken
)
;
mNotification
-
>
remove_Failed
(
mFailedToken
)
;
}
mNotification
=
nullptr
;
mNotifier
=
nullptr
;
SendFinished
(
)
;
}
nsresult
ToastNotificationHandler
:
:
InitAlertAsync
(
)
{
MOZ_TRY
(
mAlertNotification
-
>
GetId
(
mWindowsTag
)
)
;
#
ifdef
MOZ_BACKGROUNDTASKS
nsAutoString
imageUrl
;
if
(
BackgroundTasks
:
:
IsBackgroundTaskMode
(
)
&
&
NS_SUCCEEDED
(
mAlertNotification
-
>
GetImageURL
(
imageUrl
)
)
&
&
!
imageUrl
.
IsEmpty
(
)
)
{
Unused
<
<
NS_WARN_IF
(
!
gfxPlatform
:
:
GetPlatform
(
)
)
;
}
#
endif
return
mAlertNotification
-
>
LoadImage
(
0
this
nullptr
getter_AddRefs
(
mImageRequest
)
)
;
}
nsString
ToastNotificationHandler
:
:
ActionArgsJSONString
(
const
nsString
&
aAction
const
nsString
&
aOpaqueRelaunchData
=
u
"
"
_ns
)
{
nsAutoCString
actionArgsData
;
JSONStringRefWriteFunc
js
(
actionArgsData
)
;
JSONWriter
w
(
js
JSONWriter
:
:
SingleLineStyle
)
;
w
.
Start
(
)
;
w
.
StringProperty
(
"
action
"
NS_ConvertUTF16toUTF8
(
aAction
)
)
;
if
(
mIsSystemPrincipal
)
{
if
(
!
aOpaqueRelaunchData
.
IsEmpty
(
)
)
{
w
.
StringProperty
(
"
opaqueRelaunchData
"
NS_ConvertUTF16toUTF8
(
aOpaqueRelaunchData
)
)
;
}
if
(
!
mName
.
IsEmpty
(
)
)
{
w
.
StringProperty
(
"
privilegedName
"
NS_ConvertUTF16toUTF8
(
mName
)
)
;
}
}
else
{
nsAutoCString
origin
;
nsresult
rv
=
mAlertNotification
-
>
GetOrigin
(
origin
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
origin
.
IsVoid
(
)
)
{
w
.
StringProperty
(
"
origin
"
origin
)
;
}
}
w
.
End
(
)
;
return
NS_ConvertUTF8toUTF16
(
actionArgsData
)
;
}
ComPtr
<
IXmlDocument
>
ToastNotificationHandler
:
:
CreateToastXmlDocument
(
)
{
ComPtr
<
IToastNotificationManagerStatics
>
toastNotificationManagerStatics
=
GetToastNotificationManagerStatics
(
)
;
NS_ENSURE_TRUE
(
toastNotificationManagerStatics
nullptr
)
;
ToastTemplateType
toastTemplate
;
if
(
mHostPort
.
IsEmpty
(
)
)
{
toastTemplate
=
mHasImage
?
ToastTemplateType
:
:
ToastTemplateType_ToastImageAndText03
:
ToastTemplateType
:
:
ToastTemplateType_ToastText03
;
}
else
{
toastTemplate
=
mHasImage
?
ToastTemplateType
:
:
ToastTemplateType_ToastImageAndText04
:
ToastTemplateType
:
:
ToastTemplateType_ToastText04
;
}
ComPtr
<
IXmlDocument
>
toastXml
;
toastNotificationManagerStatics
-
>
GetTemplateContent
(
toastTemplate
&
toastXml
)
;
if
(
!
toastXml
)
{
return
nullptr
;
}
nsresult
ns
;
HRESULT
hr
;
bool
success
;
if
(
mHasImage
)
{
ComPtr
<
IXmlNodeList
>
toastImageElements
;
hr
=
toastXml
-
>
GetElementsByTagName
(
HStringReference
(
L
"
image
"
)
.
Get
(
)
&
toastImageElements
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlNode
>
imageNode
;
hr
=
toastImageElements
-
>
Item
(
0
&
imageNode
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlElement
>
image
;
hr
=
imageNode
.
As
(
&
image
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
success
=
SetAttribute
(
image
HStringReference
(
L
"
src
"
)
mImageUri
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
switch
(
mImagePlacement
)
{
case
ImagePlacement
:
:
eHero
:
success
=
SetAttribute
(
image
HStringReference
(
L
"
placement
"
)
u
"
hero
"
_ns
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
break
;
case
ImagePlacement
:
:
eIcon
:
success
=
SetAttribute
(
image
HStringReference
(
L
"
placement
"
)
u
"
appLogoOverride
"
_ns
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
break
;
case
ImagePlacement
:
:
eInline
:
break
;
}
}
ComPtr
<
IXmlNodeList
>
toastTextElements
;
hr
=
toastXml
-
>
GetElementsByTagName
(
HStringReference
(
L
"
text
"
)
.
Get
(
)
&
toastTextElements
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlNode
>
titleTextNodeRoot
;
hr
=
toastTextElements
-
>
Item
(
0
&
titleTextNodeRoot
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlNode
>
msgTextNodeRoot
;
hr
=
toastTextElements
-
>
Item
(
1
&
msgTextNodeRoot
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
success
=
SetNodeValueString
(
mTitle
titleTextNodeRoot
.
Get
(
)
toastXml
.
Get
(
)
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
success
=
SetNodeValueString
(
mMsg
msgTextNodeRoot
.
Get
(
)
toastXml
.
Get
(
)
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
ComPtr
<
IXmlNodeList
>
toastElements
;
hr
=
toastXml
-
>
GetElementsByTagName
(
HStringReference
(
L
"
toast
"
)
.
Get
(
)
&
toastElements
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlNode
>
toastNodeRoot
;
hr
=
toastElements
-
>
Item
(
0
&
toastNodeRoot
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlElement
>
toastElement
;
hr
=
toastNodeRoot
.
As
(
&
toastElement
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
if
(
mRequireInteraction
)
{
success
=
SetAttribute
(
toastElement
HStringReference
(
L
"
scenario
"
)
u
"
reminder
"
_ns
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
}
auto
maybeLaunchArg
=
GetLaunchArgument
(
)
;
NS_ENSURE_TRUE
(
maybeLaunchArg
.
isOk
(
)
nullptr
)
;
nsString
launchArg
=
maybeLaunchArg
.
unwrap
(
)
;
nsString
launchArgWithoutAction
=
launchArg
;
if
(
!
mIsSystemPrincipal
)
{
NS_WARNING_ASSERTION
(
mOpaqueRelaunchData
.
IsEmpty
(
)
"
unprivileged
/
content
alert
"
"
should
have
trivial
mOpaqueRelaunchData
"
)
;
}
launchArg
+
=
u
"
\
n
"
_ns
+
nsDependentString
(
kLaunchArgAction
)
+
u
"
\
n
"
_ns
+
ActionArgsJSONString
(
u
"
"
_ns
mOpaqueRelaunchData
)
;
success
=
SetAttribute
(
toastElement
HStringReference
(
L
"
launch
"
)
launchArg
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
MOZ_LOG
(
sWASLog
LogLevel
:
:
Debug
(
"
launchArg
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
launchArg
)
.
get
(
)
)
)
;
if
(
mIsSystemPrincipal
)
{
ComPtr
<
IXmlNodeList
>
bindingElements
;
hr
=
toastXml
-
>
GetElementsByTagName
(
HStringReference
(
L
"
binding
"
)
.
Get
(
)
&
bindingElements
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlNode
>
bindingNodeRoot
;
hr
=
bindingElements
-
>
Item
(
0
&
bindingNodeRoot
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlElement
>
bindingElement
;
hr
=
bindingNodeRoot
.
As
(
&
bindingElement
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
success
=
SetAttribute
(
bindingElement
HStringReference
(
L
"
template
"
)
u
"
ToastGeneric
"
_ns
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
}
ComPtr
<
IXmlElement
>
actions
;
hr
=
toastXml
-
>
CreateElement
(
HStringReference
(
L
"
actions
"
)
.
Get
(
)
&
actions
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IXmlNode
>
actionsNode
;
hr
=
actions
.
As
(
&
actionsNode
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
nsCOMPtr
<
nsIStringBundleService
>
sbs
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
)
;
NS_ENSURE_TRUE
(
sbs
nullptr
)
;
nsCOMPtr
<
nsIStringBundle
>
bundle
;
sbs
-
>
CreateBundle
(
"
chrome
:
/
/
alerts
/
locale
/
alert
.
properties
"
getter_AddRefs
(
bundle
)
)
;
NS_ENSURE_TRUE
(
bundle
nullptr
)
;
if
(
!
mHostPort
.
IsEmpty
(
)
)
{
AutoTArray
<
nsString
1
>
formatStrings
=
{
mHostPort
}
;
ComPtr
<
IXmlNode
>
urlTextNodeRoot
;
hr
=
toastTextElements
-
>
Item
(
2
&
urlTextNodeRoot
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
nsAutoString
urlReference
;
bundle
-
>
FormatStringFromName
(
"
source
.
label
"
formatStrings
urlReference
)
;
success
=
SetNodeValueString
(
urlReference
urlTextNodeRoot
.
Get
(
)
toastXml
.
Get
(
)
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
if
(
IsWin10AnniversaryUpdateOrLater
(
)
)
{
ComPtr
<
IXmlElement
>
placementText
;
hr
=
urlTextNodeRoot
.
As
(
&
placementText
)
;
if
(
SUCCEEDED
(
hr
)
)
{
SetAttribute
(
placementText
HStringReference
(
L
"
placement
"
)
u
"
attribution
"
_ns
)
;
}
}
nsAutoString
disableButtonTitle
;
ns
=
bundle
-
>
FormatStringFromName
(
"
webActions
.
disableForOrigin
.
label
"
formatStrings
disableButtonTitle
)
;
NS_ENSURE_SUCCESS
(
ns
nullptr
)
;
AddActionNode
(
toastXml
actionsNode
disableButtonTitle
launchArgWithoutAction
ActionArgsJSONString
(
kAlertActionDisable
)
u
"
contextmenu
"
_ns
)
;
}
bool
wantSettings
=
true
;
#
ifdef
MOZ_BACKGROUNDTASKS
if
(
BackgroundTasks
:
:
IsBackgroundTaskMode
(
)
)
{
wantSettings
=
false
;
}
#
endif
if
(
MOZ_LIKELY
(
wantSettings
)
)
{
nsAutoString
settingsButtonTitle
;
bundle
-
>
GetStringFromName
(
"
webActions
.
settings
.
label
"
settingsButtonTitle
)
;
success
=
AddActionNode
(
toastXml
actionsNode
settingsButtonTitle
launchArgWithoutAction
ActionArgsJSONString
(
kAlertActionSettings
)
u
"
contextmenu
"
_ns
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
}
for
(
const
auto
&
action
:
mActions
)
{
nsString
title
;
ns
=
action
-
>
GetTitle
(
title
)
;
NS_ENSURE_SUCCESS
(
ns
nullptr
)
;
if
(
!
EnsureUTF16Validity
(
title
)
)
{
MOZ_LOG
(
sWASLog
LogLevel
:
:
Warning
(
"
Notification
text
was
invalid
UTF16
unpaired
surrogates
have
"
"
been
replaced
.
"
)
)
;
}
nsString
actionString
;
ns
=
action
-
>
GetAction
(
actionString
)
;
NS_ENSURE_SUCCESS
(
ns
nullptr
)
;
if
(
!
EnsureUTF16Validity
(
actionString
)
)
{
MOZ_LOG
(
sWASLog
LogLevel
:
:
Warning
(
"
Notification
text
was
invalid
UTF16
unpaired
surrogates
have
"
"
been
replaced
.
"
)
)
;
}
nsString
opaqueRelaunchData
;
ns
=
action
-
>
GetOpaqueRelaunchData
(
opaqueRelaunchData
)
;
NS_ENSURE_SUCCESS
(
ns
nullptr
)
;
MOZ_LOG
(
sWASLog
LogLevel
:
:
Debug
(
"
launchArgWithoutAction
for
'
%
s
'
:
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
actionString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
launchArgWithoutAction
)
.
get
(
)
)
)
;
bool
activationType
(
false
)
;
ns
=
action
-
>
GetWindowsSystemActivationType
(
&
activationType
)
;
NS_ENSURE_SUCCESS
(
ns
nullptr
)
;
nsString
activationTypeString
(
(
mIsSystemPrincipal
&
&
activationType
)
?
u
"
system
"
_ns
:
u
"
"
_ns
)
;
nsString
actionArgs
;
if
(
mIsSystemPrincipal
&
&
activationType
)
{
actionArgs
=
actionString
;
NS_WARNING_ASSERTION
(
opaqueRelaunchData
.
IsEmpty
(
)
"
action
with
windowsSystemActivationType
=
true
"
"
should
have
trivial
opaqueRelaunchData
"
)
;
}
else
{
actionArgs
=
ActionArgsJSONString
(
actionString
opaqueRelaunchData
)
;
}
success
=
AddActionNode
(
toastXml
actionsNode
title
launchArgWithoutAction
actionArgs
u
"
"
_ns
activationTypeString
)
;
NS_ENSURE_TRUE
(
success
nullptr
)
;
}
if
(
mRequireInteraction
&
&
!
mActions
.
Length
(
)
)
{
nsTArray
<
nsCString
>
resIds
=
{
"
toolkit
/
global
/
alert
.
ftl
"
_ns
}
;
RefPtr
<
intl
:
:
Localization
>
l10n
=
intl
:
:
Localization
:
:
Create
(
resIds
true
)
;
IgnoredErrorResult
rv
;
nsAutoCString
closeTitle
;
l10n
-
>
FormatValueSync
(
"
notification
-
default
-
dismiss
"
_ns
{
}
closeTitle
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
nullptr
)
;
NS_ENSURE_TRUE
(
AddActionNode
(
toastXml
actionsNode
NS_ConvertUTF8toUTF16
(
closeTitle
)
u
"
"
_ns
u
"
dismiss
"
_ns
u
"
"
_ns
u
"
system
"
_ns
)
nullptr
)
;
}
ComPtr
<
IXmlNode
>
appendedChild
;
hr
=
toastNodeRoot
-
>
AppendChild
(
actionsNode
.
Get
(
)
&
appendedChild
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
if
(
mIsSilent
)
{
ComPtr
<
IXmlNode
>
audioNode
;
ComPtr
<
IXmlElement
>
audio
;
hr
=
toastXml
-
>
CreateElement
(
HStringReference
(
L
"
audio
"
)
.
Get
(
)
&
audio
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
SetAttribute
(
audio
HStringReference
(
L
"
silent
"
)
u
"
true
"
_ns
)
;
hr
=
audio
.
As
(
&
audioNode
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
hr
=
toastNodeRoot
-
>
AppendChild
(
audioNode
.
Get
(
)
&
appendedChild
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
}
return
toastXml
;
}
nsresult
ToastNotificationHandler
:
:
CreateToastXmlString
(
const
nsAString
&
aImageURL
nsAString
&
aString
)
{
HRESULT
hr
;
if
(
!
aImageURL
.
IsEmpty
(
)
)
{
mHasImage
=
true
;
mImageUri
.
Assign
(
aImageURL
)
;
}
ComPtr
<
IXmlDocument
>
toastXml
=
CreateToastXmlDocument
(
)
;
if
(
!
toastXml
)
{
return
NS_ERROR_FAILURE
;
}
ComPtr
<
IXmlNodeSerializer
>
ser
;
hr
=
toastXml
.
As
(
&
ser
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
NS_ERROR_FAILURE
)
;
HString
data
;
hr
=
ser
-
>
GetXml
(
data
.
GetAddressOf
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
NS_ERROR_FAILURE
)
;
uint32_t
len
=
0
;
const
wchar_t
*
rawData
=
data
.
GetRawBuffer
(
&
len
)
;
NS_ENSURE_TRUE
(
rawData
NS_ERROR_FAILURE
)
;
aString
.
Assign
(
rawData
len
)
;
return
NS_OK
;
}
bool
ToastNotificationHandler
:
:
ShowAlert
(
)
{
if
(
!
mBackend
-
>
IsActiveHandler
(
mName
this
)
)
{
return
false
;
}
ComPtr
<
IXmlDocument
>
toastXml
=
CreateToastXmlDocument
(
)
;
if
(
!
toastXml
)
{
return
false
;
}
return
CreateWindowsNotificationFromXml
(
toastXml
)
;
}
bool
ToastNotificationHandler
:
:
IsPrivate
(
)
{
return
mInPrivateBrowsing
;
}
void
ToastNotificationHandler
:
:
HideAlert
(
)
{
if
(
mNotifier
&
&
mNotification
)
{
mNotifier
-
>
Hide
(
mNotification
.
Get
(
)
)
;
}
}
bool
ToastNotificationHandler
:
:
CreateWindowsNotificationFromXml
(
ComPtr
<
IXmlDocument
>
&
aXml
)
{
ComPtr
<
IToastNotificationFactory
>
factory
;
HRESULT
hr
;
hr
=
GetActivationFactory
(
HStringReference
(
RuntimeClass_Windows_UI_Notifications_ToastNotification
)
.
Get
(
)
&
factory
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
factory
-
>
CreateToastNotification
(
aXml
.
Get
(
)
&
mNotification
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
RefPtr
<
ToastNotificationHandler
>
self
=
this
;
hr
=
mNotification
-
>
add_Activated
(
Callback
<
ToastActivationHandler
>
(
[
self
]
(
IToastNotification
*
aNotification
IInspectable
*
aInspectable
)
{
return
self
-
>
OnActivate
(
ComPtr
<
IToastNotification
>
(
aNotification
)
ComPtr
<
IInspectable
>
(
aInspectable
)
)
;
}
)
.
Get
(
)
&
mActivatedToken
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
mNotification
-
>
add_Dismissed
(
Callback
<
ToastDismissedHandler
>
(
[
self
]
(
IToastNotification
*
aNotification
IToastDismissedEventArgs
*
aArgs
)
{
return
self
-
>
OnDismiss
(
ComPtr
<
IToastNotification
>
(
aNotification
)
ComPtr
<
IToastDismissedEventArgs
>
(
aArgs
)
)
;
}
)
.
Get
(
)
&
mDismissedToken
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
mNotification
-
>
add_Failed
(
Callback
<
ToastFailedHandler
>
(
[
self
]
(
IToastNotification
*
aNotification
IToastFailedEventArgs
*
aArgs
)
{
return
self
-
>
OnFail
(
ComPtr
<
IToastNotification
>
(
aNotification
)
ComPtr
<
IToastFailedEventArgs
>
(
aArgs
)
)
;
}
)
.
Get
(
)
&
mFailedToken
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
ComPtr
<
IToastNotification2
>
notification2
;
hr
=
mNotification
.
As
(
&
notification2
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
HString
hTag
;
hr
=
hTag
.
Set
(
mWindowsTag
.
get
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
notification2
-
>
put_Tag
(
hTag
.
Get
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
ComPtr
<
IToastNotificationManagerStatics
>
toastNotificationManagerStatics
=
GetToastNotificationManagerStatics
(
)
;
NS_ENSURE_TRUE
(
toastNotificationManagerStatics
false
)
;
HString
aumid
;
hr
=
aumid
.
Set
(
mAumid
.
get
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
toastNotificationManagerStatics
-
>
CreateToastNotifierWithId
(
aumid
.
Get
(
)
&
mNotifier
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
hr
=
mNotifier
-
>
Show
(
mNotification
.
Get
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
false
)
;
if
(
mAlertListener
)
{
mAlertListener
-
>
Observe
(
nullptr
"
alertshow
"
mCookie
.
get
(
)
)
;
}
return
true
;
}
void
ToastNotificationHandler
:
:
SendFinished
(
)
{
if
(
!
mSentFinished
&
&
mAlertListener
)
{
mAlertListener
-
>
Observe
(
nullptr
"
alertfinished
"
mCookie
.
get
(
)
)
;
}
mSentFinished
=
true
;
}
HRESULT
ToastNotificationHandler
:
:
OnActivate
(
const
ComPtr
<
IToastNotification
>
&
notification
const
ComPtr
<
IInspectable
>
&
inspectable
)
{
MOZ_LOG
(
sWASLog
LogLevel
:
:
Info
(
"
OnActivate
"
)
)
;
if
(
mAlertListener
)
{
nsAutoString
argumentsString
;
nsAutoString
actionString
;
if
(
inspectable
)
{
ComPtr
<
IToastActivatedEventArgs
>
eventArgs
;
HRESULT
hr
=
inspectable
.
As
(
&
eventArgs
)
;
if
(
SUCCEEDED
(
hr
)
)
{
HString
arguments
;
hr
=
eventArgs
-
>
get_Arguments
(
arguments
.
GetAddressOf
(
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
uint32_t
len
=
0
;
const
char16_t
*
buffer
=
(
char16_t
*
)
arguments
.
GetRawBuffer
(
&
len
)
;
if
(
buffer
)
{
MOZ_LOG
(
sWASLog
LogLevel
:
:
Info
(
"
OnActivate
:
arguments
:
%
s
"
NS_ConvertUTF16toUTF8
(
buffer
)
.
get
(
)
)
)
;
argumentsString
.
Assign
(
buffer
)
;
Tokenizer16
parse
(
buffer
)
;
nsDependentSubstring
token
;
while
(
parse
.
ReadUntil
(
Tokenizer16
:
:
Token
:
:
NewLine
(
)
token
)
)
{
if
(
token
=
=
nsDependentString
(
kLaunchArgAction
)
)
{
Unused
<
<
parse
.
ReadUntil
(
Tokenizer16
:
:
Token
:
:
EndOfFile
(
)
actionString
)
;
}
else
{
parse
.
SkipUntil
(
Tokenizer16
:
:
Token
:
:
NewLine
(
)
)
;
}
Tokenizer16
:
:
Token
unused
;
Unused
<
<
parse
.
Next
(
unused
)
;
}
}
}
}
}
if
(
argumentsString
.
EqualsLiteral
(
"
dismiss
"
)
)
{
SendFinished
(
)
;
}
else
if
(
actionString
=
=
kAlertActionSettings
)
{
mAlertListener
-
>
Observe
(
nullptr
"
alertsettingscallback
"
mCookie
.
get
(
)
)
;
}
else
if
(
actionString
=
=
kAlertActionDisable
)
{
mAlertListener
-
>
Observe
(
nullptr
"
alertdisablecallback
"
mCookie
.
get
(
)
)
;
}
else
if
(
mClickable
)
{
nsCOMPtr
<
nsIWindowMediator
>
winMediator
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
winMediator
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
navWin
;
winMediator
-
>
GetMostRecentBrowserWindow
(
getter_AddRefs
(
navWin
)
)
;
if
(
navWin
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
WidgetUtils
:
:
DOMWindowToWidget
(
nsPIDOMWindowOuter
:
:
From
(
navWin
)
)
;
if
(
widget
)
{
SetForegroundWindow
(
static_cast
<
HWND
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
)
;
}
}
}
Json
:
:
Value
jsonData
;
Json
:
:
Reader
jsonReader
;
Maybe
<
nsString
>
actionValue
;
nsCOMPtr
<
nsIAlertAction
>
alertAction
;
if
(
jsonReader
.
parse
(
NS_ConvertUTF16toUTF8
(
actionString
)
.
get
(
)
jsonData
false
)
)
{
char
actionKey
[
]
=
"
action
"
;
if
(
jsonData
.
isMember
(
actionKey
)
&
&
jsonData
[
actionKey
]
.
isString
(
)
)
{
actionValue
.
emplace
(
NS_ConvertUTF8toUTF16
(
jsonData
[
actionKey
]
.
asCString
(
)
)
)
;
}
}
if
(
actionValue
)
{
mAlertNotification
-
>
GetAction
(
*
actionValue
getter_AddRefs
(
alertAction
)
)
;
}
mAlertListener
-
>
Observe
(
alertAction
"
alertclickcallback
"
mCookie
.
get
(
)
)
;
}
}
mBackend
-
>
RemoveHandler
(
mName
this
)
;
return
S_OK
;
}
ComPtr
<
IToastNotification
>
ToastNotificationHandler
:
:
FindNotificationByTag
(
const
nsAString
&
aWindowsTag
const
nsAString
&
aAumid
)
{
HRESULT
hr
=
S_OK
;
HString
current_id
;
current_id
.
Set
(
PromiseFlatString
(
aWindowsTag
)
.
get
(
)
)
;
ComPtr
<
IToastNotificationManagerStatics
>
manager
=
GetToastNotificationManagerStatics
(
)
;
NS_ENSURE_TRUE
(
manager
nullptr
)
;
ComPtr
<
IToastNotificationManagerStatics2
>
manager2
;
hr
=
manager
.
As
(
&
manager2
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IToastNotificationHistory
>
history
;
hr
=
manager2
-
>
get_History
(
&
history
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IToastNotificationHistory2
>
history2
;
hr
=
history
.
As
(
&
history2
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
ComPtr
<
IVectorView_ToastNotification
>
toasts
;
hr
=
history2
-
>
GetHistoryWithId
(
HStringReference
(
PromiseFlatString
(
aAumid
)
.
get
(
)
)
.
Get
(
)
&
toasts
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
unsigned
int
hist_size
;
hr
=
toasts
-
>
get_Size
(
&
hist_size
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
for
(
unsigned
int
i
=
0
;
i
<
hist_size
;
i
+
+
)
{
ComPtr
<
IToastNotification
>
hist_toast
;
hr
=
toasts
-
>
GetAt
(
i
&
hist_toast
)
;
if
(
NS_WARN_IF
(
FAILED
(
hr
)
)
)
{
continue
;
}
ComPtr
<
IToastNotification2
>
hist_toast2
;
hr
=
hist_toast
.
As
(
&
hist_toast2
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
HString
history_id
;
hr
=
hist_toast2
-
>
get_Tag
(
history_id
.
GetAddressOf
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
if
(
current_id
=
=
history_id
)
{
return
hist_toast
;
}
}
return
nullptr
;
}
HRESULT
ToastNotificationHandler
:
:
OnDismiss
(
const
ComPtr
<
IToastNotification
>
&
notification
const
ComPtr
<
IToastDismissedEventArgs
>
&
aArgs
)
{
ComPtr
<
IToastNotification2
>
notification2
;
HRESULT
hr
=
notification
.
As
(
&
notification2
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
E_FAIL
)
;
HString
tagHString
;
hr
=
notification2
-
>
get_Tag
(
tagHString
.
GetAddressOf
(
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
E_FAIL
)
;
unsigned
int
len
;
const
wchar_t
*
tagPtr
=
tagHString
.
GetRawBuffer
(
&
len
)
;
nsAutoString
tag
(
tagPtr
len
)
;
if
(
FindNotificationByTag
(
tag
mAumid
)
)
{
return
S_OK
;
}
SendFinished
(
)
;
mBackend
-
>
RemoveHandler
(
mName
this
)
;
return
S_OK
;
}
HRESULT
ToastNotificationHandler
:
:
OnFail
(
const
ComPtr
<
IToastNotification
>
&
notification
const
ComPtr
<
IToastFailedEventArgs
>
&
aArgs
)
{
HRESULT
err
;
aArgs
-
>
get_ErrorCode
(
&
err
)
;
MOZ_LOG
(
sWASLog
LogLevel
:
:
Error
(
"
Error
creating
notification
error
:
%
ld
"
err
)
)
;
SendFinished
(
)
;
mBackend
-
>
RemoveHandler
(
mName
this
)
;
return
S_OK
;
}
nsresult
ToastNotificationHandler
:
:
TryShowAlert
(
)
{
if
(
NS_WARN_IF
(
!
ShowAlert
(
)
)
)
{
mBackend
-
>
RemoveHandler
(
mName
this
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ToastNotificationHandler
:
:
OnImageMissing
(
nsISupports
*
)
{
return
TryShowAlert
(
)
;
}
NS_IMETHODIMP
ToastNotificationHandler
:
:
OnImageReady
(
nsISupports
*
imgIRequest
*
aRequest
)
{
nsresult
rv
=
AsyncSaveImage
(
aRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
TryShowAlert
(
)
;
}
return
rv
;
}
nsresult
ToastNotificationHandler
:
:
AsyncSaveImage
(
imgIRequest
*
aRequest
)
{
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
mImageFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mImageFile
-
>
Append
(
u
"
notificationimages
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mImageFile
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0500
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_FILE_ALREADY_EXISTS
)
{
return
rv
;
}
nsID
uuid
;
rv
=
nsID
:
:
GenerateUUIDInPlace
(
uuid
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NSID_TrimBracketsASCII
uuidStr
(
uuid
)
;
uuidStr
.
AppendLiteral
(
"
.
png
"
)
;
mImageFile
-
>
AppendNative
(
uuidStr
)
;
nsCOMPtr
<
imgIContainer
>
imgContainer
;
rv
=
aRequest
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsMainThreadPtrHandle
<
ToastNotificationHandler
>
self
(
new
nsMainThreadPtrHolder
<
ToastNotificationHandler
>
(
"
ToastNotificationHandler
"
this
)
)
;
nsCOMPtr
<
nsIFile
>
imageFile
(
mImageFile
)
;
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
surface
=
imgContainer
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
ToastNotificationHandler
:
:
AsyncWriteImage
"
[
self
imageFile
surface
]
(
)
-
>
void
{
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
surface
)
{
FILE
*
file
=
nullptr
;
rv
=
imageFile
-
>
OpenANSIFileDesc
(
"
wb
"
&
file
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
gfxUtils
:
:
EncodeSourceSurface
(
surface
ImageType
:
:
PNG
u
"
"
_ns
gfxUtils
:
:
eBinaryEncode
file
)
;
fclose
(
file
)
;
}
}
nsCOMPtr
<
nsIRunnable
>
cbRunnable
=
NS_NewRunnableFunction
(
"
ToastNotificationHandler
:
:
AsyncWriteImageCb
"
[
self
rv
]
(
)
-
>
void
{
auto
handler
=
const_cast
<
ToastNotificationHandler
*
>
(
self
.
get
(
)
)
;
handler
-
>
OnWriteImageFinished
(
rv
)
;
}
)
;
NS_DispatchToMainThread
(
cbRunnable
)
;
}
)
;
return
mBackend
-
>
BackgroundDispatch
(
r
)
;
}
void
ToastNotificationHandler
:
:
OnWriteImageFinished
(
nsresult
rv
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
OnWriteImageSuccess
(
)
;
}
TryShowAlert
(
)
;
}
nsresult
ToastNotificationHandler
:
:
OnWriteImageSuccess
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
fileURI
;
rv
=
NS_NewFileURI
(
getter_AddRefs
(
fileURI
)
mImageFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
uriStr
;
rv
=
fileURI
-
>
GetSpec
(
uriStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AppendUTF8toUTF16
(
uriStr
mImageUri
)
;
mHasImage
=
true
;
return
NS_OK
;
}
}
}
