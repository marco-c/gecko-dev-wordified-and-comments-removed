#
include
<
queue
>
#
include
<
windows
.
h
>
#
include
<
winuser
.
h
>
#
include
<
wtsapi32
.
h
>
#
include
"
WinWindowOcclusionTracker
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
platform_thread
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsBaseWidget
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
transport
/
runnable_utils
.
h
"
#
include
"
WinUtils
.
h
"
#
ifndef
EVENT_OBJECT_CLOAKED
#
define
EVENT_OBJECT_CLOAKED
0x8017
#
define
EVENT_OBJECT_UNCLOAKED
0x8018
#
endif
namespace
mozilla
:
:
widget
{
LazyLogModule
gWinOcclusionTrackerLog
(
"
WinOcclusionTracker
"
)
;
#
define
LOG
(
type
.
.
.
)
MOZ_LOG
(
gWinOcclusionTrackerLog
type
(
__VA_ARGS__
)
)
LazyLogModule
gWinOcclusionCalculatorLog
(
"
WinOcclusionCalculator
"
)
;
#
define
CALC_LOG
(
type
.
.
.
)
\
MOZ_LOG
(
gWinOcclusionCalculatorLog
type
(
__VA_ARGS__
)
)
const
int
kOcclusionUpdateRunnableDelayMs
=
16
;
class
OcclusionUpdateRunnable
:
public
CancelableRunnable
{
public
:
explicit
OcclusionUpdateRunnable
(
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
*
aOcclusionCalculator
)
:
CancelableRunnable
(
"
OcclusionUpdateRunnable
"
)
mOcclusionCalculator
(
aOcclusionCalculator
)
{
mTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mIsCanceled
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
WinWindowOcclusionTracker
:
:
IsInWinWindowOcclusionThread
(
)
)
;
uint32_t
latencyMs
=
round
(
(
TimeStamp
:
:
Now
(
)
-
mTimeStamp
)
.
ToMilliseconds
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Debug
"
ComputeNativeWindowOcclusionStatus
(
)
latencyMs
%
u
"
latencyMs
)
;
mOcclusionCalculator
-
>
ComputeNativeWindowOcclusionStatus
(
)
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mIsCanceled
=
true
;
mOcclusionCalculator
=
nullptr
;
return
NS_OK
;
}
private
:
bool
mIsCanceled
=
false
;
RefPtr
<
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
>
mOcclusionCalculator
;
TimeStamp
mTimeStamp
;
}
;
class
SerializedTaskDispatcher
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SerializedTaskDispatcher
)
public
:
SerializedTaskDispatcher
(
)
;
void
Destroy
(
)
;
void
PostTaskToMain
(
already_AddRefed
<
nsIRunnable
>
aTask
)
;
void
PostTaskToCalculator
(
already_AddRefed
<
nsIRunnable
>
aTask
)
;
void
PostDelayedTaskToCalculator
(
already_AddRefed
<
Runnable
>
aTask
int
aDelayMs
)
;
bool
IsOnCurrentThread
(
)
;
private
:
friend
class
DelayedTaskRunnable
;
~
SerializedTaskDispatcher
(
)
;
struct
Data
{
std
:
:
queue
<
std
:
:
pair
<
RefPtr
<
nsIRunnable
>
RefPtr
<
nsISerialEventTarget
>
>
>
mTasks
;
bool
mDestroyed
=
false
;
RefPtr
<
Runnable
>
mCurrentRunnable
;
}
;
void
PostTasksIfNecessary
(
nsISerialEventTarget
*
aEventTarget
const
DataMutex
<
Data
>
:
:
AutoLock
&
aProofOfLock
)
;
void
HandleDelayedTask
(
already_AddRefed
<
nsIRunnable
>
aTask
)
;
void
HandleTasks
(
)
;
RefPtr
<
nsISerialEventTarget
>
mCurrentEventTarget
=
nullptr
;
DataMutex
<
Data
>
mData
;
}
;
class
DelayedTaskRunnable
:
public
Runnable
{
public
:
DelayedTaskRunnable
(
SerializedTaskDispatcher
*
aSerializedTaskDispatcher
already_AddRefed
<
Runnable
>
aTask
)
:
Runnable
(
"
DelayedTaskRunnable
"
)
mSerializedTaskDispatcher
(
aSerializedTaskDispatcher
)
mTask
(
aTask
)
{
}
NS_IMETHOD
Run
(
)
override
{
mSerializedTaskDispatcher
-
>
HandleDelayedTask
(
mTask
.
forget
(
)
)
;
return
NS_OK
;
}
private
:
RefPtr
<
SerializedTaskDispatcher
>
mSerializedTaskDispatcher
;
RefPtr
<
Runnable
>
mTask
;
}
;
SerializedTaskDispatcher
:
:
SerializedTaskDispatcher
(
)
:
mData
(
"
SerializedTaskDispatcher
:
:
mData
"
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
SerializedTaskDispatcher
:
:
SerializedTaskDispatcher
(
)
this
%
p
"
this
)
;
}
SerializedTaskDispatcher
:
:
~
SerializedTaskDispatcher
(
)
{
#
ifdef
DEBUG
auto
data
=
mData
.
Lock
(
)
;
MOZ_ASSERT
(
data
-
>
mDestroyed
)
;
MOZ_ASSERT
(
data
-
>
mTasks
.
empty
(
)
)
;
#
endif
}
void
SerializedTaskDispatcher
:
:
Destroy
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
SerializedTaskDispatcher
:
:
Destroy
(
)
this
%
p
"
this
)
;
auto
data
=
mData
.
Lock
(
)
;
if
(
data
-
>
mDestroyed
)
{
return
;
}
data
-
>
mDestroyed
=
true
;
std
:
:
queue
<
std
:
:
pair
<
RefPtr
<
nsIRunnable
>
RefPtr
<
nsISerialEventTarget
>
>
>
empty
;
std
:
:
swap
(
data
-
>
mTasks
empty
)
;
}
void
SerializedTaskDispatcher
:
:
PostTaskToMain
(
already_AddRefed
<
nsIRunnable
>
aTask
)
{
RefPtr
<
nsIRunnable
>
task
=
aTask
;
auto
data
=
mData
.
Lock
(
)
;
if
(
data
-
>
mDestroyed
)
{
return
;
}
nsISerialEventTarget
*
eventTarget
=
GetMainThreadSerialEventTarget
(
)
;
data
-
>
mTasks
.
push
(
{
std
:
:
move
(
task
)
eventTarget
}
)
;
MOZ_ASSERT_IF
(
!
data
-
>
mCurrentRunnable
data
-
>
mTasks
.
size
(
)
=
=
1
)
;
PostTasksIfNecessary
(
eventTarget
data
)
;
}
void
SerializedTaskDispatcher
:
:
PostTaskToCalculator
(
already_AddRefed
<
nsIRunnable
>
aTask
)
{
RefPtr
<
nsIRunnable
>
task
=
aTask
;
auto
data
=
mData
.
Lock
(
)
;
if
(
data
-
>
mDestroyed
)
{
return
;
}
nsISerialEventTarget
*
eventTarget
=
WinWindowOcclusionTracker
:
:
OcclusionCalculatorLoop
(
)
-
>
SerialEventTarget
(
)
;
data
-
>
mTasks
.
push
(
{
std
:
:
move
(
task
)
eventTarget
}
)
;
MOZ_ASSERT_IF
(
!
data
-
>
mCurrentRunnable
data
-
>
mTasks
.
size
(
)
=
=
1
)
;
PostTasksIfNecessary
(
eventTarget
data
)
;
}
void
SerializedTaskDispatcher
:
:
PostDelayedTaskToCalculator
(
already_AddRefed
<
Runnable
>
aTask
int
aDelayMs
)
{
CALC_LOG
(
LogLevel
:
:
Debug
"
SerializedTaskDispatcher
:
:
PostDelayedTaskToCalculator
(
)
"
)
;
RefPtr
<
DelayedTaskRunnable
>
runnable
=
new
DelayedTaskRunnable
(
this
std
:
:
move
(
aTask
)
)
;
MessageLoop
*
targetLoop
=
WinWindowOcclusionTracker
:
:
OcclusionCalculatorLoop
(
)
;
targetLoop
-
>
PostDelayedTask
(
runnable
.
forget
(
)
aDelayMs
)
;
}
bool
SerializedTaskDispatcher
:
:
IsOnCurrentThread
(
)
{
return
!
!
mCurrentEventTarget
;
}
void
SerializedTaskDispatcher
:
:
PostTasksIfNecessary
(
nsISerialEventTarget
*
aEventTarget
const
DataMutex
<
Data
>
:
:
AutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
!
aProofOfLock
-
>
mTasks
.
empty
(
)
)
;
if
(
aProofOfLock
-
>
mCurrentRunnable
)
{
return
;
}
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
SerializedTaskDispatcher
>
(
this
)
&
SerializedTaskDispatcher
:
:
HandleTasks
)
;
aProofOfLock
-
>
mCurrentRunnable
=
runnable
;
aEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
void
SerializedTaskDispatcher
:
:
HandleDelayedTask
(
already_AddRefed
<
nsIRunnable
>
aTask
)
{
MOZ_ASSERT
(
WinWindowOcclusionTracker
:
:
IsInWinWindowOcclusionThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Debug
"
SerializedTaskDispatcher
:
:
HandleDelayedTask
(
)
"
)
;
RefPtr
<
nsIRunnable
>
task
=
aTask
;
auto
data
=
mData
.
Lock
(
)
;
if
(
data
-
>
mDestroyed
)
{
return
;
}
nsISerialEventTarget
*
eventTarget
=
WinWindowOcclusionTracker
:
:
OcclusionCalculatorLoop
(
)
-
>
SerialEventTarget
(
)
;
data
-
>
mTasks
.
push
(
{
std
:
:
move
(
task
)
eventTarget
}
)
;
MOZ_ASSERT_IF
(
!
data
-
>
mCurrentRunnable
data
-
>
mTasks
.
size
(
)
=
=
1
)
;
PostTasksIfNecessary
(
eventTarget
data
)
;
}
void
SerializedTaskDispatcher
:
:
HandleTasks
(
)
{
RefPtr
<
nsIRunnable
>
frontTask
;
{
auto
data
=
mData
.
Lock
(
)
;
if
(
data
-
>
mDestroyed
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
data
-
>
mCurrentRunnable
)
;
MOZ_RELEASE_ASSERT
(
!
data
-
>
mTasks
.
empty
(
)
)
;
frontTask
=
data
-
>
mTasks
.
front
(
)
.
first
;
MOZ_RELEASE_ASSERT
(
!
mCurrentEventTarget
)
;
mCurrentEventTarget
=
data
-
>
mTasks
.
front
(
)
.
second
;
}
while
(
frontTask
)
{
if
(
NS_IsMainThread
(
)
)
{
LOG
(
LogLevel
:
:
Debug
"
SerializedTaskDispatcher
:
:
HandleTasks
(
)
"
)
;
}
else
{
CALC_LOG
(
LogLevel
:
:
Debug
"
SerializedTaskDispatcher
:
:
HandleTasks
(
)
"
)
;
}
MOZ_ASSERT_IF
(
NS_IsMainThread
(
)
mCurrentEventTarget
=
=
GetMainThreadSerialEventTarget
(
)
)
;
MOZ_ASSERT_IF
(
!
NS_IsMainThread
(
)
mCurrentEventTarget
=
=
MessageLoop
:
:
current
(
)
-
>
SerialEventTarget
(
)
)
;
frontTask
-
>
Run
(
)
;
{
auto
data
=
mData
.
Lock
(
)
;
if
(
data
-
>
mDestroyed
)
{
return
;
}
frontTask
=
nullptr
;
data
-
>
mTasks
.
pop
(
)
;
if
(
!
data
-
>
mTasks
.
empty
(
)
&
&
data
-
>
mTasks
.
front
(
)
.
second
=
=
mCurrentEventTarget
)
{
frontTask
=
data
-
>
mTasks
.
front
(
)
.
first
;
}
}
}
MOZ_ASSERT
(
!
frontTask
)
;
{
auto
data
=
mData
.
Lock
(
)
;
data
-
>
mCurrentRunnable
=
nullptr
;
mCurrentEventTarget
=
nullptr
;
if
(
data
-
>
mDestroyed
|
|
data
-
>
mTasks
.
empty
(
)
)
{
return
;
}
PostTasksIfNecessary
(
data
-
>
mTasks
.
front
(
)
.
second
data
)
;
}
}
StaticRefPtr
<
WinWindowOcclusionTracker
>
WinWindowOcclusionTracker
:
:
sTracker
;
WinWindowOcclusionTracker
*
WinWindowOcclusionTracker
:
:
Get
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sTracker
|
|
sTracker
-
>
mHasAttemptedShutdown
)
{
return
nullptr
;
}
return
sTracker
;
}
void
WinWindowOcclusionTracker
:
:
Ensure
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
Ensure
(
)
"
)
;
base
:
:
Thread
:
:
Options
options
;
options
.
message_loop_type
=
MessageLoop
:
:
TYPE_UI
;
if
(
sTracker
)
{
sTracker
-
>
mThread
-
>
Stop
(
)
;
if
(
sTracker
-
>
mThread
-
>
StartWithOptions
(
options
)
)
{
sTracker
-
>
mHasAttemptedShutdown
=
false
;
return
;
}
sTracker
=
nullptr
;
}
UniquePtr
<
base
:
:
Thread
>
thread
=
MakeUnique
<
base
:
:
Thread
>
(
"
WinWindowOcclusionCalc
"
)
;
if
(
!
thread
-
>
StartWithOptions
(
options
)
)
{
return
;
}
sTracker
=
new
WinWindowOcclusionTracker
(
std
:
:
move
(
thread
)
)
;
WindowOcclusionCalculator
:
:
CreateInstance
(
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
Initialize
)
;
sTracker
-
>
mSerializedTaskDispatcher
-
>
PostTaskToCalculator
(
runnable
.
forget
(
)
)
;
}
void
WinWindowOcclusionTracker
:
:
ShutDown
(
)
{
if
(
!
sTracker
)
{
return
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
ShutDown
(
)
"
)
;
sTracker
-
>
mHasAttemptedShutdown
=
true
;
sTracker
-
>
Destroy
(
)
;
CVStatus
status
;
{
MonitorAutoLock
lock
(
sTracker
-
>
mMonitor
)
;
static
const
TimeDuration
TIMEOUT
=
TimeDuration
:
:
FromSeconds
(
2
.
0
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
Shutdown
)
;
OcclusionCalculatorLoop
(
)
-
>
PostTask
(
runnable
.
forget
(
)
)
;
TimeStamp
timeStart
=
TimeStamp
:
:
NowLoRes
(
)
;
do
{
status
=
sTracker
-
>
mMonitor
.
Wait
(
TIMEOUT
)
;
}
while
(
(
status
=
=
CVStatus
:
:
Timeout
)
&
&
(
(
TimeStamp
:
:
NowLoRes
(
)
-
timeStart
)
<
TIMEOUT
)
)
;
}
if
(
status
=
=
CVStatus
:
:
NoTimeout
)
{
WindowOcclusionCalculator
:
:
ClearInstance
(
)
;
sTracker
=
nullptr
;
}
}
void
WinWindowOcclusionTracker
:
:
Destroy
(
)
{
if
(
mDisplayStatusObserver
)
{
mDisplayStatusObserver
-
>
Destroy
(
)
;
mDisplayStatusObserver
=
nullptr
;
}
if
(
mSessionChangeObserver
)
{
mSessionChangeObserver
-
>
Destroy
(
)
;
mSessionChangeObserver
=
nullptr
;
}
if
(
mSerializedTaskDispatcher
)
{
mSerializedTaskDispatcher
-
>
Destroy
(
)
;
}
}
MessageLoop
*
WinWindowOcclusionTracker
:
:
OcclusionCalculatorLoop
(
)
{
return
sTracker
?
sTracker
-
>
mThread
-
>
message_loop
(
)
:
nullptr
;
}
bool
WinWindowOcclusionTracker
:
:
IsInWinWindowOcclusionThread
(
)
{
return
sTracker
&
&
sTracker
-
>
mThread
-
>
thread_id
(
)
=
=
PlatformThread
:
:
CurrentId
(
)
;
}
void
WinWindowOcclusionTracker
:
:
EnsureDisplayStatusObserver
(
)
{
if
(
mDisplayStatusObserver
)
{
return
;
}
mDisplayStatusObserver
=
DisplayStatusObserver
:
:
Create
(
this
)
;
}
void
WinWindowOcclusionTracker
:
:
EnsureSessionChangeObserver
(
)
{
if
(
mSessionChangeObserver
)
{
return
;
}
mSessionChangeObserver
=
SessionChangeObserver
:
:
Create
(
this
)
;
}
void
WinWindowOcclusionTracker
:
:
Enable
(
nsBaseWidget
*
aWindow
HWND
aHwnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
Enable
(
)
aWindow
%
p
aHwnd
%
p
"
aWindow
aHwnd
)
;
auto
it
=
mHwndRootWindowMap
.
find
(
aHwnd
)
;
if
(
it
!
=
mHwndRootWindowMap
.
end
(
)
)
{
return
;
}
nsWeakPtr
weak
=
do_GetWeakReference
(
aWindow
)
;
mHwndRootWindowMap
.
emplace
(
aHwnd
weak
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
EnableOcclusionTrackingForWindow
aHwnd
)
;
mSerializedTaskDispatcher
-
>
PostTaskToCalculator
(
runnable
.
forget
(
)
)
;
}
void
WinWindowOcclusionTracker
:
:
Disable
(
nsBaseWidget
*
aWindow
HWND
aHwnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
Disable
(
)
aWindow
%
p
aHwnd
%
p
"
aWindow
aHwnd
)
;
auto
it
=
mHwndRootWindowMap
.
find
(
aHwnd
)
;
if
(
it
=
=
mHwndRootWindowMap
.
end
(
)
)
{
return
;
}
mHwndRootWindowMap
.
erase
(
it
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
DisableOcclusionTrackingForWindow
aHwnd
)
;
mSerializedTaskDispatcher
-
>
PostTaskToCalculator
(
runnable
.
forget
(
)
)
;
}
void
WinWindowOcclusionTracker
:
:
OnWindowVisibilityChanged
(
nsBaseWidget
*
aWindow
bool
aVisible
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
OnWindowVisibilityChanged
(
)
aWindow
%
p
"
"
aVisible
%
d
"
aWindow
aVisible
)
;
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
HandleVisibilityChanged
aVisible
)
;
mSerializedTaskDispatcher
-
>
PostTaskToCalculator
(
runnable
.
forget
(
)
)
;
}
WinWindowOcclusionTracker
:
:
WinWindowOcclusionTracker
(
UniquePtr
<
base
:
:
Thread
>
aThread
)
:
mThread
(
std
:
:
move
(
aThread
)
)
mMonitor
(
"
WinWindowOcclusionTracker
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
WinWindowOcclusionTracker
(
)
"
)
;
if
(
StaticPrefs
:
:
widget_windows_window_occlusion_tracking_display_state_enabled
(
)
)
{
mDisplayStatusObserver
=
DisplayStatusObserver
:
:
Create
(
this
)
;
}
if
(
StaticPrefs
:
:
widget_windows_window_occlusion_tracking_session_lock_enabled
(
)
)
{
mSessionChangeObserver
=
SessionChangeObserver
:
:
Create
(
this
)
;
}
mSerializedTaskDispatcher
=
new
SerializedTaskDispatcher
(
)
;
}
WinWindowOcclusionTracker
:
:
~
WinWindowOcclusionTracker
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
~
WinWindowOcclusionTracker
(
)
"
)
;
}
bool
WinWindowOcclusionTracker
:
:
IsWindowVisibleAndFullyOpaque
(
HWND
aHwnd
LayoutDeviceIntRect
*
aWindowRect
)
{
if
(
!
:
:
IsWindow
(
aHwnd
)
|
|
!
:
:
IsWindowVisible
(
aHwnd
)
)
{
return
false
;
}
if
(
:
:
IsIconic
(
aHwnd
)
)
{
return
false
;
}
LONG
exStyles
=
:
:
GetWindowLong
(
aHwnd
GWL_EXSTYLE
)
;
if
(
exStyles
&
WS_EX_TRANSPARENT
)
{
return
false
;
}
if
(
exStyles
&
WS_EX_TOOLWINDOW
)
{
nsAutoString
className
;
if
(
WinUtils
:
:
GetClassName
(
aHwnd
className
)
)
{
if
(
!
className
.
Equals
(
L
"
Shell_TrayWnd
"
)
)
{
return
false
;
}
}
}
if
(
exStyles
&
WS_EX_LAYERED
)
{
BYTE
alpha
;
DWORD
flags
;
if
(
!
:
:
GetLayeredWindowAttributes
(
aHwnd
nullptr
&
alpha
&
flags
)
)
{
return
false
;
}
if
(
flags
&
LWA_ALPHA
&
&
alpha
<
255
)
{
return
false
;
}
if
(
flags
&
LWA_COLORKEY
)
{
return
false
;
}
}
HRGN
region
=
:
:
CreateRectRgn
(
0
0
0
0
)
;
int
result
=
GetWindowRgn
(
aHwnd
region
)
;
:
:
DeleteObject
(
region
)
;
if
(
result
=
=
COMPLEXREGION
)
{
return
false
;
}
DWORD
reason
;
if
(
SUCCEEDED
(
:
:
DwmGetWindowAttribute
(
aHwnd
DWMWA_CLOAKED
&
reason
sizeof
(
reason
)
)
)
&
&
reason
!
=
0
)
{
return
false
;
}
RECT
winRect
;
if
(
!
:
:
GetWindowRect
(
aHwnd
&
winRect
)
)
{
return
false
;
}
if
(
:
:
IsRectEmpty
(
&
winRect
)
)
{
return
false
;
}
if
(
:
:
GetWindowLong
(
aHwnd
GWL_STYLE
)
&
WS_POPUP
)
{
nsAutoString
className
;
if
(
WinUtils
:
:
GetClassName
(
aHwnd
className
)
)
{
if
(
!
className
.
Equals
(
L
"
Shell_TrayWnd
"
)
)
{
return
false
;
}
}
}
*
aWindowRect
=
LayoutDeviceIntRect
(
winRect
.
left
winRect
.
top
winRect
.
right
-
winRect
.
left
winRect
.
bottom
-
winRect
.
top
)
;
WINDOWPLACEMENT
windowPlacement
=
{
0
}
;
windowPlacement
.
length
=
sizeof
(
WINDOWPLACEMENT
)
;
:
:
GetWindowPlacement
(
aHwnd
&
windowPlacement
)
;
if
(
windowPlacement
.
showCmd
=
=
SW_MAXIMIZE
)
{
HMONITOR
hmon
=
:
:
MonitorFromWindow
(
aHwnd
MONITOR_DEFAULTTONEAREST
)
;
if
(
hmon
)
{
MONITORINFO
mi
;
mi
.
cbSize
=
sizeof
(
mi
)
;
if
(
GetMonitorInfo
(
hmon
&
mi
)
)
{
LayoutDeviceIntRect
workArea
(
mi
.
rcWork
.
left
mi
.
rcWork
.
top
mi
.
rcWork
.
right
-
mi
.
rcWork
.
left
mi
.
rcWork
.
bottom
-
mi
.
rcWork
.
top
)
;
aWindowRect
-
>
width
=
std
:
:
min
(
workArea
.
width
aWindowRect
-
>
width
)
;
if
(
aWindowRect
-
>
x
<
workArea
.
x
)
{
aWindowRect
-
>
x
=
workArea
.
x
;
}
else
{
aWindowRect
-
>
x
=
std
:
:
min
(
workArea
.
x
+
workArea
.
width
aWindowRect
-
>
x
+
aWindowRect
-
>
width
)
-
aWindowRect
-
>
width
;
}
aWindowRect
-
>
height
=
std
:
:
min
(
workArea
.
height
aWindowRect
-
>
height
)
;
if
(
aWindowRect
-
>
y
<
workArea
.
y
)
{
aWindowRect
-
>
y
=
workArea
.
y
;
}
else
{
aWindowRect
-
>
y
=
std
:
:
min
(
workArea
.
y
+
workArea
.
height
aWindowRect
-
>
y
+
aWindowRect
-
>
height
)
-
aWindowRect
-
>
height
;
}
}
}
}
return
true
;
}
void
WinWindowOcclusionTracker
:
:
CallUpdateOcclusionState
(
std
:
:
unordered_map
<
HWND
OcclusionState
>
*
aMap
bool
aShowAllWindows
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
*
tracker
=
WinWindowOcclusionTracker
:
:
Get
(
)
;
if
(
!
tracker
)
{
return
;
}
tracker
-
>
UpdateOcclusionState
(
aMap
aShowAllWindows
)
;
}
void
WinWindowOcclusionTracker
:
:
UpdateOcclusionState
(
std
:
:
unordered_map
<
HWND
OcclusionState
>
*
aMap
bool
aShowAllWindows
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mSerializedTaskDispatcher
-
>
IsOnCurrentThread
(
)
)
;
LOG
(
LogLevel
:
:
Debug
"
WinWindowOcclusionTracker
:
:
UpdateOcclusionState
(
)
aShowAllWindows
%
d
"
aShowAllWindows
)
;
mNumVisibleRootWindows
=
0
;
for
(
auto
&
[
hwnd
state
]
:
*
aMap
)
{
auto
it
=
mHwndRootWindowMap
.
find
(
hwnd
)
;
if
(
it
=
=
mHwndRootWindowMap
.
end
(
)
)
{
continue
;
}
auto
occlState
=
state
;
if
(
mScreenLocked
|
|
!
mDisplayOn
)
{
occlState
=
OcclusionState
:
:
OCCLUDED
;
}
else
if
(
aShowAllWindows
)
{
occlState
=
OcclusionState
:
:
VISIBLE
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
do_QueryReferent
(
it
-
>
second
)
;
if
(
!
widget
)
{
continue
;
}
auto
*
baseWidget
=
static_cast
<
nsBaseWidget
*
>
(
widget
.
get
(
)
)
;
baseWidget
-
>
NotifyOcclusionState
(
occlState
)
;
if
(
baseWidget
-
>
SizeMode
(
)
!
=
nsSizeMode_Minimized
)
{
mNumVisibleRootWindows
+
+
;
}
}
}
void
WinWindowOcclusionTracker
:
:
OnSessionChange
(
WPARAM
aStatusCode
Maybe
<
bool
>
aIsCurrentSession
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aIsCurrentSession
.
isNothing
(
)
|
|
!
*
aIsCurrentSession
)
{
return
;
}
if
(
aStatusCode
=
=
WTS_SESSION_UNLOCK
)
{
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
OnSessionChange
(
)
WTS_SESSION_UNLOCK
"
)
;
mScreenLocked
=
false
;
}
else
if
(
aStatusCode
=
=
WTS_SESSION_LOCK
)
{
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
OnSessionChange
(
)
WTS_SESSION_LOCK
"
)
;
mScreenLocked
=
true
;
MarkNonIconicWindowsOccluded
(
)
;
}
}
void
WinWindowOcclusionTracker
:
:
OnDisplayStateChanged
(
bool
aDisplayOn
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
OnDisplayStateChanged
(
)
aDisplayOn
%
d
"
aDisplayOn
)
;
if
(
mDisplayOn
=
=
aDisplayOn
)
{
return
;
}
mDisplayOn
=
aDisplayOn
;
if
(
aDisplayOn
)
{
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
HandleVisibilityChanged
true
)
;
mSerializedTaskDispatcher
-
>
PostTaskToCalculator
(
runnable
.
forget
(
)
)
;
}
else
{
MarkNonIconicWindowsOccluded
(
)
;
}
}
void
WinWindowOcclusionTracker
:
:
MarkNonIconicWindowsOccluded
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WinWindowOcclusionTracker
:
:
MarkNonIconicWindowsOccluded
(
)
"
)
;
for
(
auto
&
[
hwnd
weak
]
:
mHwndRootWindowMap
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
do_QueryReferent
(
weak
)
;
if
(
!
widget
)
{
continue
;
}
auto
*
baseWidget
=
static_cast
<
nsBaseWidget
*
>
(
widget
.
get
(
)
)
;
auto
state
=
(
baseWidget
-
>
SizeMode
(
)
=
=
nsSizeMode_Minimized
)
?
OcclusionState
:
:
HIDDEN
:
OcclusionState
:
:
OCCLUDED
;
baseWidget
-
>
NotifyOcclusionState
(
state
)
;
}
}
void
WinWindowOcclusionTracker
:
:
TriggerCalculation
(
)
{
RefPtr
<
Runnable
>
runnable
=
WrapRunnable
(
RefPtr
<
WindowOcclusionCalculator
>
(
WindowOcclusionCalculator
:
:
GetInstance
(
)
)
&
WindowOcclusionCalculator
:
:
HandleTriggerCalculation
)
;
mSerializedTaskDispatcher
-
>
PostTaskToCalculator
(
runnable
.
forget
(
)
)
;
}
BOOL
WinWindowOcclusionTracker
:
:
DumpOccludingWindowsCallback
(
HWND
aHWnd
LPARAM
aLParam
)
{
HWND
hwnd
=
reinterpret_cast
<
HWND
>
(
aLParam
)
;
LayoutDeviceIntRect
windowRect
;
bool
windowIsOccluding
=
IsWindowVisibleAndFullyOpaque
(
aHWnd
&
windowRect
)
;
if
(
windowIsOccluding
)
{
nsAutoString
className
;
if
(
WinUtils
:
:
GetClassName
(
aHWnd
className
)
)
{
const
auto
name
=
NS_ConvertUTF16toUTF8
(
className
)
;
printf_stderr
(
"
DumpOccludingWindowsCallback
(
)
aHWnd
%
p
className
%
s
windowRect
(
%
d
"
"
%
d
%
d
%
d
)
\
n
"
aHWnd
name
.
get
(
)
windowRect
.
x
windowRect
.
y
windowRect
.
width
windowRect
.
height
)
;
}
}
if
(
aHWnd
=
=
hwnd
)
{
return
false
;
}
return
true
;
}
void
WinWindowOcclusionTracker
:
:
DumpOccludingWindows
(
HWND
aHWnd
)
{
printf_stderr
(
"
DumpOccludingWindows
(
)
until
aHWnd
%
p
visible
%
d
iconic
%
d
\
n
"
aHWnd
:
:
IsWindowVisible
(
aHWnd
)
:
:
IsIconic
(
aHWnd
)
)
;
:
:
EnumWindows
(
&
DumpOccludingWindowsCallback
reinterpret_cast
<
LPARAM
>
(
aHWnd
)
)
;
}
StaticRefPtr
<
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
>
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
sCalculator
;
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
WindowOcclusionCalculator
(
)
:
mMonitor
(
WinWindowOcclusionTracker
:
:
Get
(
)
-
>
mMonitor
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
LogLevel
:
:
Info
"
WindowOcclusionCalculator
(
)
"
)
;
mSerializedTaskDispatcher
=
WinWindowOcclusionTracker
:
:
Get
(
)
-
>
GetSerializedTaskDispatcher
(
)
;
}
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
~
WindowOcclusionCalculator
(
)
{
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
CreateInstance
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sCalculator
=
new
WindowOcclusionCalculator
(
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ClearInstance
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sCalculator
=
nullptr
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
Initialize
(
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
MOZ_ASSERT
(
!
mVirtualDesktopManager
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
Initialize
(
)
"
)
;
#
ifndef
__MINGW32__
RefPtr
<
IVirtualDesktopManager
>
desktopManager
;
HRESULT
hr
=
:
:
CoCreateInstance
(
CLSID_VirtualDesktopManager
NULL
CLSCTX_INPROC_SERVER
__uuidof
(
IVirtualDesktopManager
)
getter_AddRefs
(
desktopManager
)
)
;
if
(
FAILED
(
hr
)
)
{
return
;
}
mVirtualDesktopManager
=
desktopManager
;
#
endif
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
Shutdown
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
Shutdown
(
)
"
)
;
UnregisterEventHooks
(
)
;
if
(
mOcclusionUpdateRunnable
)
{
mOcclusionUpdateRunnable
-
>
Cancel
(
)
;
mOcclusionUpdateRunnable
=
nullptr
;
}
mVirtualDesktopManager
=
nullptr
;
mMonitor
.
NotifyAll
(
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
EnableOcclusionTrackingForWindow
(
HWND
aHwnd
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
MOZ_ASSERT
(
mSerializedTaskDispatcher
-
>
IsOnCurrentThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
EnableOcclusionTrackingForWindow
(
)
aHwnd
%
p
"
aHwnd
)
;
MOZ_RELEASE_ASSERT
(
mRootWindowHwndsOcclusionState
.
find
(
aHwnd
)
=
=
mRootWindowHwndsOcclusionState
.
end
(
)
)
;
mRootWindowHwndsOcclusionState
[
aHwnd
]
=
OcclusionState
:
:
UNKNOWN
;
if
(
mGlobalEventHooks
.
empty
(
)
)
{
RegisterEventHooks
(
)
;
}
ScheduleOcclusionCalculationIfNeeded
(
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
DisableOcclusionTrackingForWindow
(
HWND
aHwnd
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
MOZ_ASSERT
(
mSerializedTaskDispatcher
-
>
IsOnCurrentThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
DisableOcclusionTrackingForWindow
(
)
aHwnd
%
p
"
aHwnd
)
;
MOZ_RELEASE_ASSERT
(
mRootWindowHwndsOcclusionState
.
find
(
aHwnd
)
!
=
mRootWindowHwndsOcclusionState
.
end
(
)
)
;
mRootWindowHwndsOcclusionState
.
erase
(
aHwnd
)
;
if
(
mMovingWindow
=
=
aHwnd
)
{
mMovingWindow
=
0
;
}
if
(
mRootWindowHwndsOcclusionState
.
empty
(
)
)
{
UnregisterEventHooks
(
)
;
if
(
mOcclusionUpdateRunnable
)
{
mOcclusionUpdateRunnable
-
>
Cancel
(
)
;
mOcclusionUpdateRunnable
=
nullptr
;
}
}
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
HandleVisibilityChanged
(
bool
aVisible
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
HandleVisibilityChange
(
)
aVisible
%
d
"
aVisible
)
;
if
(
aVisible
)
{
MaybeRegisterEventHooks
(
)
;
ScheduleOcclusionCalculationIfNeeded
(
)
;
}
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
HandleTriggerCalculation
(
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
HandleTriggerCalculation
(
)
"
)
;
MaybeRegisterEventHooks
(
)
;
ScheduleOcclusionCalculationIfNeeded
(
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
MaybeRegisterEventHooks
(
)
{
if
(
mGlobalEventHooks
.
empty
(
)
)
{
RegisterEventHooks
(
)
;
}
}
void
CALLBACK
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
EventHookCallback
(
HWINEVENTHOOK
aWinEventHook
DWORD
aEvent
HWND
aHwnd
LONG
aIdObject
LONG
aIdChild
DWORD
aEventThread
DWORD
aMsEventTime
)
{
if
(
sCalculator
)
{
sCalculator
-
>
ProcessEventHookCallback
(
aWinEventHook
aEvent
aHwnd
aIdObject
aIdChild
)
;
}
}
BOOL
CALLBACK
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ComputeNativeWindowOcclusionStatusCallback
(
HWND
aHwnd
LPARAM
aLParam
)
{
if
(
sCalculator
)
{
return
sCalculator
-
>
ProcessComputeNativeWindowOcclusionStatusCallback
(
aHwnd
reinterpret_cast
<
std
:
:
unordered_set
<
DWORD
>
*
>
(
aLParam
)
)
;
}
return
FALSE
;
}
BOOL
CALLBACK
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
UpdateVisibleWindowProcessIdsCallback
(
HWND
aHwnd
LPARAM
aLParam
)
{
if
(
sCalculator
)
{
sCalculator
-
>
ProcessUpdateVisibleWindowProcessIdsCallback
(
aHwnd
)
;
return
TRUE
;
}
return
FALSE
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
UpdateVisibleWindowProcessIds
(
)
{
mPidsForLocationChangeHook
.
clear
(
)
;
:
:
EnumWindows
(
&
UpdateVisibleWindowProcessIdsCallback
0
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ComputeNativeWindowOcclusionStatus
(
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
MOZ_ASSERT
(
mSerializedTaskDispatcher
-
>
IsOnCurrentThread
(
)
)
;
if
(
mOcclusionUpdateRunnable
)
{
mOcclusionUpdateRunnable
=
nullptr
;
}
if
(
mRootWindowHwndsOcclusionState
.
empty
(
)
)
{
return
;
}
bool
shouldUnregisterEventHooks
=
true
;
int
screenLeft
=
:
:
GetSystemMetrics
(
SM_XVIRTUALSCREEN
)
;
int
screenTop
=
:
:
GetSystemMetrics
(
SM_YVIRTUALSCREEN
)
;
int
screenWidth
=
:
:
GetSystemMetrics
(
SM_CXVIRTUALSCREEN
)
;
int
screenHeight
=
:
:
GetSystemMetrics
(
SM_CYVIRTUALSCREEN
)
;
LayoutDeviceIntRegion
screenRegion
=
LayoutDeviceIntRect
(
screenLeft
screenTop
screenWidth
screenHeight
)
;
mNumRootWindowsWithUnknownOcclusionState
=
0
;
CALC_LOG
(
LogLevel
:
:
Debug
"
ComputeNativeWindowOcclusionStatus
(
)
screen
(
%
d
%
d
%
d
%
d
)
"
screenLeft
screenTop
screenWidth
screenHeight
)
;
for
(
auto
&
[
hwnd
state
]
:
mRootWindowHwndsOcclusionState
)
{
if
(
:
:
IsIconic
(
hwnd
)
)
{
state
=
OcclusionState
:
:
HIDDEN
;
}
else
if
(
IsWindowOnCurrentVirtualDesktop
(
hwnd
)
=
=
Some
(
false
)
)
{
state
=
OcclusionState
:
:
OCCLUDED
;
shouldUnregisterEventHooks
=
false
;
}
else
{
state
=
OcclusionState
:
:
UNKNOWN
;
shouldUnregisterEventHooks
=
false
;
mNumRootWindowsWithUnknownOcclusionState
+
+
;
}
}
if
(
shouldUnregisterEventHooks
)
{
UnregisterEventHooks
(
)
;
}
else
{
std
:
:
unordered_set
<
DWORD
>
currentPidsWithVisibleWindows
;
mUnoccludedDesktopRegion
=
screenRegion
;
EnumWindows
(
&
ComputeNativeWindowOcclusionStatusCallback
reinterpret_cast
<
LPARAM
>
(
&
currentPidsWithVisibleWindows
)
)
;
std
:
:
unordered_set
<
DWORD
>
pidsToRemove
;
for
(
auto
locChangePid
:
mPidsForLocationChangeHook
)
{
if
(
currentPidsWithVisibleWindows
.
find
(
locChangePid
)
=
=
currentPidsWithVisibleWindows
.
end
(
)
)
{
UnhookWinEvent
(
mProcessEventHooks
[
locChangePid
]
)
;
mProcessEventHooks
.
erase
(
locChangePid
)
;
pidsToRemove
.
insert
(
locChangePid
)
;
}
}
if
(
!
pidsToRemove
.
empty
(
)
)
{
for
(
auto
it
=
mPidsForLocationChangeHook
.
begin
(
)
;
it
!
=
mPidsForLocationChangeHook
.
end
(
)
;
)
{
if
(
pidsToRemove
.
find
(
*
it
)
!
=
pidsToRemove
.
end
(
)
)
{
it
=
mPidsForLocationChangeHook
.
erase
(
it
)
;
}
else
{
+
+
it
;
}
}
}
}
std
:
:
unordered_map
<
HWND
OcclusionState
>
*
map
=
&
mRootWindowHwndsOcclusionState
;
bool
showAllWindows
=
mShowingThumbnails
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
CallUpdateOcclusionState
"
[
map
showAllWindows
]
(
)
{
WinWindowOcclusionTracker
:
:
CallUpdateOcclusionState
(
map
showAllWindows
)
;
}
)
;
mSerializedTaskDispatcher
-
>
PostTaskToMain
(
runnable
.
forget
(
)
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ScheduleOcclusionCalculationIfNeeded
(
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
if
(
mOcclusionUpdateRunnable
)
{
return
;
}
CALC_LOG
(
LogLevel
:
:
Debug
"
ScheduleOcclusionCalculationIfNeeded
(
)
"
)
;
RefPtr
<
CancelableRunnable
>
task
=
new
OcclusionUpdateRunnable
(
this
)
;
mOcclusionUpdateRunnable
=
task
;
mSerializedTaskDispatcher
-
>
PostDelayedTaskToCalculator
(
task
.
forget
(
)
kOcclusionUpdateRunnableDelayMs
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
RegisterGlobalEventHook
(
DWORD
aEventMin
DWORD
aEventMax
)
{
HWINEVENTHOOK
eventHook
=
:
:
SetWinEventHook
(
aEventMin
aEventMax
nullptr
&
EventHookCallback
0
0
WINEVENT_OUTOFCONTEXT
)
;
mGlobalEventHooks
.
push_back
(
eventHook
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
RegisterEventHookForProcess
(
DWORD
aPid
)
{
mPidsForLocationChangeHook
.
insert
(
aPid
)
;
mProcessEventHooks
[
aPid
]
=
SetWinEventHook
(
EVENT_OBJECT_LOCATIONCHANGE
EVENT_OBJECT_LOCATIONCHANGE
nullptr
&
EventHookCallback
aPid
0
WINEVENT_OUTOFCONTEXT
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
RegisterEventHooks
(
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
MOZ_RELEASE_ASSERT
(
mGlobalEventHooks
.
empty
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
RegisterEventHooks
(
)
"
)
;
RegisterGlobalEventHook
(
EVENT_SYSTEM_CAPTUREEND
EVENT_SYSTEM_CAPTUREEND
)
;
RegisterGlobalEventHook
(
EVENT_SYSTEM_MOVESIZESTART
EVENT_SYSTEM_MOVESIZEEND
)
;
RegisterGlobalEventHook
(
EVENT_SYSTEM_MINIMIZESTART
EVENT_SYSTEM_MINIMIZEEND
)
;
RegisterGlobalEventHook
(
EVENT_SYSTEM_FOREGROUND
EVENT_SYSTEM_FOREGROUND
)
;
RegisterGlobalEventHook
(
EVENT_OBJECT_SHOW
EVENT_OBJECT_HIDE
)
;
RegisterGlobalEventHook
(
EVENT_OBJECT_STATECHANGE
EVENT_OBJECT_STATECHANGE
)
;
RegisterGlobalEventHook
(
EVENT_OBJECT_CLOAKED
EVENT_OBJECT_UNCLOAKED
)
;
UpdateVisibleWindowProcessIds
(
)
;
for
(
DWORD
pid
:
mPidsForLocationChangeHook
)
{
RegisterEventHookForProcess
(
pid
)
;
}
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
UnregisterEventHooks
(
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
CALC_LOG
(
LogLevel
:
:
Info
"
UnregisterEventHooks
(
)
"
)
;
for
(
const
auto
eventHook
:
mGlobalEventHooks
)
{
:
:
UnhookWinEvent
(
eventHook
)
;
}
mGlobalEventHooks
.
clear
(
)
;
for
(
const
auto
&
[
pid
eventHook
]
:
mProcessEventHooks
)
{
:
:
UnhookWinEvent
(
eventHook
)
;
}
mProcessEventHooks
.
clear
(
)
;
mPidsForLocationChangeHook
.
clear
(
)
;
}
bool
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ProcessComputeNativeWindowOcclusionStatusCallback
(
HWND
aHwnd
std
:
:
unordered_set
<
DWORD
>
*
aCurrentPidsWithVisibleWindows
)
{
LayoutDeviceIntRegion
currUnoccludedDestkop
=
mUnoccludedDesktopRegion
;
LayoutDeviceIntRect
windowRect
;
bool
windowIsOccluding
=
WindowCanOccludeOtherWindowsOnCurrentVirtualDesktop
(
aHwnd
&
windowRect
)
;
if
(
windowIsOccluding
)
{
DWORD
pid
;
:
:
GetWindowThreadProcessId
(
aHwnd
&
pid
)
;
aCurrentPidsWithVisibleWindows
-
>
insert
(
pid
)
;
auto
it
=
mProcessEventHooks
.
find
(
pid
)
;
if
(
it
=
=
mProcessEventHooks
.
end
(
)
)
{
RegisterEventHookForProcess
(
pid
)
;
}
if
(
mNumRootWindowsWithUnknownOcclusionState
=
=
0
)
{
return
true
;
}
mUnoccludedDesktopRegion
.
SubOut
(
windowRect
)
;
}
else
if
(
mNumRootWindowsWithUnknownOcclusionState
=
=
0
)
{
return
true
;
}
if
(
aHwnd
=
=
mMovingWindow
)
{
return
true
;
}
auto
it
=
mRootWindowHwndsOcclusionState
.
find
(
aHwnd
)
;
if
(
it
=
=
mRootWindowHwndsOcclusionState
.
end
(
)
|
|
it
-
>
second
!
=
OcclusionState
:
:
UNKNOWN
)
{
return
true
;
}
CALC_LOG
(
LogLevel
:
:
Debug
"
ProcessComputeNativeWindowOcclusionStatusCallback
(
)
windowRect
(
%
d
"
"
%
d
%
d
%
d
)
IsOccluding
%
d
"
windowRect
.
x
windowRect
.
y
windowRect
.
width
windowRect
.
height
windowIsOccluding
)
;
if
(
!
windowIsOccluding
)
{
RECT
rect
;
if
(
:
:
GetWindowRect
(
aHwnd
&
rect
)
!
=
0
)
{
LayoutDeviceIntRect
windowRect
(
rect
.
left
rect
.
top
rect
.
right
-
rect
.
left
rect
.
bottom
-
rect
.
top
)
;
currUnoccludedDestkop
.
SubOut
(
windowRect
)
;
}
}
it
-
>
second
=
(
mUnoccludedDesktopRegion
=
=
currUnoccludedDestkop
)
?
OcclusionState
:
:
OCCLUDED
:
OcclusionState
:
:
VISIBLE
;
mNumRootWindowsWithUnknownOcclusionState
-
-
;
return
true
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ProcessEventHookCallback
(
HWINEVENTHOOK
aWinEventHook
DWORD
aEvent
HWND
aHwnd
LONG
aIdObject
LONG
aIdChild
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
if
(
!
aHwnd
)
{
return
;
}
if
(
aIdObject
!
=
OBJID_WINDOW
)
{
return
;
}
CALC_LOG
(
LogLevel
:
:
Debug
"
WindowOcclusionCalculator
:
:
ProcessEventHookCallback
(
)
aEvent
0x
%
lx
"
aEvent
)
;
bool
calculateOcclusion
=
true
;
if
(
:
:
GetWindowLong
(
aHwnd
GWL_STYLE
)
&
WS_POPUP
)
{
nsAutoString
className
;
if
(
WinUtils
:
:
GetClassName
(
aHwnd
className
)
)
{
calculateOcclusion
=
className
.
Equals
(
L
"
Shell_TrayWnd
"
)
;
}
}
if
(
aEvent
=
=
EVENT_OBJECT_SHOW
)
{
if
(
mShowingThumbnails
)
{
return
;
}
nsAutoString
className
;
if
(
WinUtils
:
:
GetClassName
(
aHwnd
className
)
)
{
const
auto
name
=
NS_ConvertUTF16toUTF8
(
className
)
;
CALC_LOG
(
LogLevel
:
:
Debug
"
ProcessEventHookCallback
(
)
EVENT_OBJECT_SHOW
%
s
"
name
.
get
(
)
)
;
if
(
name
.
Equals
(
"
MultitaskingViewFrame
"
)
|
|
name
.
Equals
(
"
TaskListThumbnailWnd
"
)
)
{
CALC_LOG
(
LogLevel
:
:
Info
"
ProcessEventHookCallback
(
)
mShowingThumbnails
=
true
"
)
;
mShowingThumbnails
=
true
;
std
:
:
unordered_map
<
HWND
OcclusionState
>
*
map
=
&
mRootWindowHwndsOcclusionState
;
bool
showAllWindows
=
mShowingThumbnails
;
RefPtr
<
Runnable
>
runnable
=
NS_NewRunnableFunction
(
"
CallUpdateOcclusionState
"
[
map
showAllWindows
]
(
)
{
WinWindowOcclusionTracker
:
:
CallUpdateOcclusionState
(
map
showAllWindows
)
;
}
)
;
mSerializedTaskDispatcher
-
>
PostTaskToMain
(
runnable
.
forget
(
)
)
;
}
}
return
;
}
else
if
(
aEvent
=
=
EVENT_OBJECT_HIDE
)
{
if
(
!
mShowingThumbnails
)
{
return
;
}
nsAutoString
className
;
WinUtils
:
:
GetClassName
(
aHwnd
className
)
;
const
auto
name
=
NS_ConvertUTF16toUTF8
(
className
)
;
CALC_LOG
(
LogLevel
:
:
Debug
"
ProcessEventHookCallback
(
)
EVENT_OBJECT_HIDE
%
s
"
name
.
get
(
)
)
;
if
(
name
.
Equals
(
"
MultitaskingViewFrame
"
)
|
|
name
.
Equals
(
"
TaskListThumbnailWnd
"
)
)
{
CALC_LOG
(
LogLevel
:
:
Info
"
ProcessEventHookCallback
(
)
mShowingThumbnails
=
false
"
)
;
mShowingThumbnails
=
false
;
calculateOcclusion
=
true
;
}
else
{
return
;
}
}
else
if
(
aEvent
=
=
EVENT_SYSTEM_MOVESIZESTART
)
{
mMovingWindow
=
aHwnd
;
}
else
if
(
aEvent
=
=
EVENT_SYSTEM_MOVESIZEEND
)
{
mMovingWindow
=
0
;
}
else
if
(
mMovingWindow
!
=
0
)
{
if
(
aEvent
=
=
EVENT_OBJECT_LOCATIONCHANGE
|
|
aEvent
=
=
EVENT_OBJECT_STATECHANGE
)
{
if
(
mRootWindowHwndsOcclusionState
.
find
(
aHwnd
)
=
=
mRootWindowHwndsOcclusionState
.
end
(
)
)
{
return
;
}
}
else
{
mMovingWindow
=
0
;
}
}
if
(
!
calculateOcclusion
)
{
return
;
}
ScheduleOcclusionCalculationIfNeeded
(
)
;
}
void
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
ProcessUpdateVisibleWindowProcessIdsCallback
(
HWND
aHwnd
)
{
MOZ_ASSERT
(
IsInWinWindowOcclusionThread
(
)
)
;
LayoutDeviceIntRect
windowRect
;
if
(
WindowCanOccludeOtherWindowsOnCurrentVirtualDesktop
(
aHwnd
&
windowRect
)
)
{
DWORD
pid
;
:
:
GetWindowThreadProcessId
(
aHwnd
&
pid
)
;
mPidsForLocationChangeHook
.
insert
(
pid
)
;
}
}
bool
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
WindowCanOccludeOtherWindowsOnCurrentVirtualDesktop
(
HWND
aHwnd
LayoutDeviceIntRect
*
aWindowRect
)
{
return
IsWindowVisibleAndFullyOpaque
(
aHwnd
aWindowRect
)
&
&
(
IsWindowOnCurrentVirtualDesktop
(
aHwnd
)
=
=
Some
(
true
)
)
;
}
Maybe
<
bool
>
WinWindowOcclusionTracker
:
:
WindowOcclusionCalculator
:
:
IsWindowOnCurrentVirtualDesktop
(
HWND
aHwnd
)
{
if
(
!
mVirtualDesktopManager
)
{
return
Some
(
true
)
;
}
BOOL
onCurrentDesktop
;
HRESULT
hr
=
mVirtualDesktopManager
-
>
IsWindowOnCurrentVirtualDesktop
(
aHwnd
&
onCurrentDesktop
)
;
if
(
FAILED
(
hr
)
)
{
return
Nothing
(
)
;
}
if
(
onCurrentDesktop
)
{
return
Some
(
true
)
;
}
GUID
workspaceGuid
;
hr
=
mVirtualDesktopManager
-
>
GetWindowDesktopId
(
aHwnd
&
workspaceGuid
)
;
if
(
FAILED
(
hr
)
)
{
return
Nothing
(
)
;
}
if
(
workspaceGuid
=
=
GUID_NULL
)
{
return
Some
(
true
)
;
}
return
Some
(
false
)
;
}
#
undef
LOG
#
undef
CALC_LOG
}
