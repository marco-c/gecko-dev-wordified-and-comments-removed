#
include
"
mozilla
/
Logging
.
h
"
#
include
"
IMMHandler
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsWindowDefs
.
h
"
#
include
"
WinIMEHandler
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
ifndef
IME_PROP_ACCEPT_WIDE_VKEY
#
define
IME_PROP_ACCEPT_WIDE_VKEY
0x20
#
endif
#
define
RWM_MOUSE
TEXT
(
"
MSIMEMouseOperation
"
)
#
define
IMEMOUSE_NONE
0x00
/
/
no
mouse
button
was
pushed
#
define
IMEMOUSE_LDOWN
0x01
#
define
IMEMOUSE_RDOWN
0x02
#
define
IMEMOUSE_MDOWN
0x04
#
define
IMEMOUSE_WUP
0x10
/
/
wheel
up
#
define
IMEMOUSE_WDOWN
0x20
/
/
wheel
down
extern
mozilla
:
:
LazyLogModule
gIMELog
;
static
const
char
*
GetBoolName
(
bool
aBool
)
{
return
aBool
?
"
true
"
:
"
false
"
;
}
static
void
HandleSeparator
(
nsACString
&
aDesc
)
{
if
(
!
aDesc
.
IsEmpty
(
)
)
{
aDesc
.
AppendLiteral
(
"
|
"
)
;
}
}
class
GetIMEGeneralPropertyName
:
public
nsAutoCString
{
public
:
explicit
GetIMEGeneralPropertyName
(
DWORD
aFlags
)
{
if
(
!
aFlags
)
{
AppendLiteral
(
"
no
flags
"
)
;
return
;
}
if
(
aFlags
&
IME_PROP_AT_CARET
)
{
AppendLiteral
(
"
IME_PROP_AT_CARET
"
)
;
}
if
(
aFlags
&
IME_PROP_SPECIAL_UI
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_SPECIAL_UI
"
)
;
}
if
(
aFlags
&
IME_PROP_CANDLIST_START_FROM_1
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_CANDLIST_START_FROM_1
"
)
;
}
if
(
aFlags
&
IME_PROP_UNICODE
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_UNICODE
"
)
;
}
if
(
aFlags
&
IME_PROP_COMPLETE_ON_UNSELECT
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_COMPLETE_ON_UNSELECT
"
)
;
}
if
(
aFlags
&
IME_PROP_ACCEPT_WIDE_VKEY
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_ACCEPT_WIDE_VKEY
"
)
;
}
}
virtual
~
GetIMEGeneralPropertyName
(
)
{
}
}
;
class
GetIMEUIPropertyName
:
public
nsAutoCString
{
public
:
explicit
GetIMEUIPropertyName
(
DWORD
aFlags
)
{
if
(
!
aFlags
)
{
AppendLiteral
(
"
no
flags
"
)
;
return
;
}
if
(
aFlags
&
UI_CAP_2700
)
{
AppendLiteral
(
"
UI_CAP_2700
"
)
;
}
if
(
aFlags
&
UI_CAP_ROT90
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
UI_CAP_ROT90
"
)
;
}
if
(
aFlags
&
UI_CAP_ROTANY
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
UI_CAP_ROTANY
"
)
;
}
}
virtual
~
GetIMEUIPropertyName
(
)
{
}
}
;
class
GetReconvertStringLog
:
public
nsAutoCString
{
public
:
explicit
GetReconvertStringLog
(
RECONVERTSTRING
*
aReconv
)
{
AssignLiteral
(
"
{
dwSize
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwSize
)
)
;
AppendLiteral
(
"
dwVersion
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwVersion
)
)
;
AppendLiteral
(
"
dwStrLen
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwStrLen
)
)
;
AppendLiteral
(
"
dwStrOffset
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwStrOffset
)
)
;
AppendLiteral
(
"
dwCompStrLen
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwCompStrLen
)
)
;
AppendLiteral
(
"
dwCompStrOffset
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwCompStrOffset
)
)
;
AppendLiteral
(
"
dwTargetStrLen
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwTargetStrLen
)
)
;
AppendLiteral
(
"
dwTargetStrOffset
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwTargetStrOffset
)
)
;
AppendLiteral
(
"
result
str
=
\
"
"
)
;
if
(
aReconv
-
>
dwStrLen
)
{
char16_t
*
strStart
=
reinterpret_cast
<
char16_t
*
>
(
reinterpret_cast
<
char
*
>
(
aReconv
)
+
aReconv
-
>
dwStrOffset
)
;
nsDependentString
str
(
strStart
aReconv
-
>
dwStrLen
)
;
Append
(
NS_ConvertUTF16toUTF8
(
str
)
)
;
}
AppendLiteral
(
"
\
"
}
"
)
;
}
virtual
~
GetReconvertStringLog
(
)
{
}
}
;
namespace
mozilla
{
namespace
widget
{
static
IMMHandler
*
gIMMHandler
=
nullptr
;
IMEContext
:
:
IMEContext
(
HWND
aWnd
)
:
mWnd
(
aWnd
)
mIMC
(
:
:
ImmGetContext
(
aWnd
)
)
{
}
IMEContext
:
:
IMEContext
(
nsWindow
*
aWindowBase
)
:
mWnd
(
aWindowBase
-
>
GetWindowHandle
(
)
)
mIMC
(
:
:
ImmGetContext
(
aWindowBase
-
>
GetWindowHandle
(
)
)
)
{
}
void
IMEContext
:
:
Init
(
HWND
aWnd
)
{
Clear
(
)
;
mWnd
=
aWnd
;
mIMC
=
:
:
ImmGetContext
(
mWnd
)
;
}
void
IMEContext
:
:
Init
(
nsWindow
*
aWindowBase
)
{
Init
(
aWindowBase
-
>
GetWindowHandle
(
)
)
;
}
void
IMEContext
:
:
Clear
(
)
{
if
(
mWnd
&
&
mIMC
)
{
:
:
ImmReleaseContext
(
mWnd
mIMC
)
;
}
mWnd
=
nullptr
;
mIMC
=
nullptr
;
}
static
UINT
sWM_MSIME_MOUSE
=
0
;
WritingMode
IMMHandler
:
:
sWritingModeOfCompositionFont
;
nsString
IMMHandler
:
:
sIMEName
;
UINT
IMMHandler
:
:
sCodePage
=
0
;
DWORD
IMMHandler
:
:
sIMEProperty
=
0
;
DWORD
IMMHandler
:
:
sIMEUIProperty
=
0
;
bool
IMMHandler
:
:
sAssumeVerticalWritingModeNotSupported
=
false
;
bool
IMMHandler
:
:
sHasFocus
=
false
;
#
define
IMPL_IS_IME_ACTIVE
(
aReadableName
aActualName
)
\
bool
IMMHandler
:
:
Is
#
#
aReadableName
#
#
Active
(
)
{
\
return
sIMEName
.
Equals
(
aActualName
)
;
\
}
IMPL_IS_IME_ACTIVE
(
ATOK2006
u
"
ATOK
2006
"
)
IMPL_IS_IME_ACTIVE
(
ATOK2007
u
"
ATOK
2007
"
)
IMPL_IS_IME_ACTIVE
(
ATOK2008
u
"
ATOK
2008
"
)
IMPL_IS_IME_ACTIVE
(
ATOK2009
u
"
ATOK
2009
"
)
IMPL_IS_IME_ACTIVE
(
ATOK2010
u
"
ATOK
2010
"
)
IMPL_IS_IME_ACTIVE
(
GoogleJapaneseInput
u
"
Google
\
x65E5
\
x672C
\
x8A9E
\
x5165
\
x529B
"
u
"
IMM32
\
x30E2
\
x30B8
\
x30E5
\
x30FC
\
x30EB
"
)
IMPL_IS_IME_ACTIVE
(
Japanist2003
u
"
Japanist
2003
"
)
#
undef
IMPL_IS_IME_ACTIVE
bool
IMMHandler
:
:
IsActiveIMEInBlockList
(
)
{
if
(
sIMEName
.
IsEmpty
(
)
)
{
return
false
;
}
#
ifdef
_WIN64
if
(
IsWin8OrLater
(
)
&
&
(
IsATOK2006Active
(
)
|
|
IsATOK2007Active
(
)
|
|
IsATOK2008Active
(
)
|
|
IsATOK2009Active
(
)
|
|
IsATOK2010Active
(
)
)
)
{
return
true
;
}
#
endif
return
false
;
}
void
IMMHandler
:
:
EnsureHandlerInstance
(
)
{
if
(
!
gIMMHandler
)
{
gIMMHandler
=
new
IMMHandler
(
)
;
}
}
void
IMMHandler
:
:
Initialize
(
)
{
if
(
!
sWM_MSIME_MOUSE
)
{
sWM_MSIME_MOUSE
=
:
:
RegisterWindowMessage
(
RWM_MOUSE
)
;
}
sAssumeVerticalWritingModeNotSupported
=
Preferences
:
:
GetBool
(
"
intl
.
imm
.
vertical_writing
.
always_assume_not_supported
"
false
)
;
InitKeyboardLayout
(
nullptr
:
:
GetKeyboardLayout
(
0
)
)
;
}
void
IMMHandler
:
:
Terminate
(
)
{
if
(
!
gIMMHandler
)
return
;
delete
gIMMHandler
;
gIMMHandler
=
nullptr
;
}
bool
IMMHandler
:
:
IsComposingOnOurEditor
(
)
{
return
gIMMHandler
&
&
gIMMHandler
-
>
mIsComposing
;
}
bool
IMMHandler
:
:
IsComposingWindow
(
nsWindow
*
aWindow
)
{
return
gIMMHandler
&
&
gIMMHandler
-
>
mComposingWindow
=
=
aWindow
;
}
bool
IMMHandler
:
:
IsTopLevelWindowOfComposition
(
nsWindow
*
aWindow
)
{
if
(
!
gIMMHandler
|
|
!
gIMMHandler
-
>
mComposingWindow
)
{
return
false
;
}
HWND
wnd
=
gIMMHandler
-
>
mComposingWindow
-
>
GetWindowHandle
(
)
;
return
WinUtils
:
:
GetTopLevelHWND
(
wnd
true
)
=
=
aWindow
-
>
GetWindowHandle
(
)
;
}
bool
IMMHandler
:
:
ShouldDrawCompositionStringOurselves
(
)
{
return
!
(
sIMEProperty
&
IME_PROP_SPECIAL_UI
)
&
&
(
sIMEProperty
&
IME_PROP_AT_CARET
)
;
}
bool
IMMHandler
:
:
IsVerticalWritingSupported
(
)
{
if
(
sAssumeVerticalWritingModeNotSupported
)
{
return
false
;
}
if
(
IsGoogleJapaneseInputActive
(
)
)
{
return
false
;
}
return
!
!
(
sIMEUIProperty
&
(
UI_CAP_2700
|
UI_CAP_ROT90
|
UI_CAP_ROTANY
)
)
;
}
void
IMMHandler
:
:
InitKeyboardLayout
(
nsWindow
*
aWindow
HKL
aKeyboardLayout
)
{
UINT
IMENameLength
=
:
:
ImmGetDescriptionW
(
aKeyboardLayout
nullptr
0
)
;
if
(
IMENameLength
)
{
sIMEName
.
SetLength
(
+
+
IMENameLength
)
;
IMENameLength
=
:
:
ImmGetDescriptionW
(
aKeyboardLayout
sIMEName
.
get
(
)
IMENameLength
)
;
sIMEName
.
SetLength
(
IMENameLength
)
;
}
else
{
sIMEName
.
Truncate
(
)
;
}
WORD
langID
=
LOWORD
(
aKeyboardLayout
)
;
:
:
GetLocaleInfoW
(
MAKELCID
(
langID
SORT_DEFAULT
)
LOCALE_IDEFAULTANSICODEPAGE
|
LOCALE_RETURN_NUMBER
(
PWSTR
)
&
sCodePage
sizeof
(
sCodePage
)
/
sizeof
(
WCHAR
)
)
;
sIMEProperty
=
:
:
ImmGetProperty
(
aKeyboardLayout
IGP_PROPERTY
)
;
sIMEUIProperty
=
:
:
ImmGetProperty
(
aKeyboardLayout
IGP_UI
)
;
if
(
sCodePage
=
=
932
&
&
sIMEName
.
IsEmpty
(
)
)
{
Preferences
:
:
GetString
(
"
intl
.
imm
.
japanese
.
assume_active_tip_name_as
"
sIMEName
)
;
}
if
(
aWindow
)
{
MaybeAdjustCompositionFont
(
aWindow
sWritingModeOfCompositionFont
true
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
InitKeyboardLayout
aKeyboardLayout
=
%
p
(
\
"
%
s
\
"
)
"
"
sCodePage
=
%
u
sIMEProperty
=
%
s
sIMEUIProperty
=
%
s
"
aKeyboardLayout
NS_ConvertUTF16toUTF8
(
sIMEName
)
.
get
(
)
sCodePage
GetIMEGeneralPropertyName
(
sIMEProperty
)
.
get
(
)
GetIMEUIPropertyName
(
sIMEUIProperty
)
.
get
(
)
)
)
;
}
UINT
IMMHandler
:
:
GetKeyboardCodePage
(
)
{
return
sCodePage
;
}
IMENotificationRequests
IMMHandler
:
:
GetIMENotificationRequests
(
)
{
return
IMENotificationRequests
(
IMENotificationRequests
:
:
NOTIFY_POSITION_CHANGE
|
IMENotificationRequests
:
:
NOTIFY_MOUSE_BUTTON_EVENT_ON_CHAR
)
;
}
#
define
IS_COMPOSING_LPARAM
(
lParam
)
\
(
(
lParam
)
&
(
GCS_COMPSTR
|
GCS_COMPATTR
|
GCS_COMPCLAUSE
|
GCS_CURSORPOS
)
)
#
define
IS_COMMITTING_LPARAM
(
lParam
)
(
(
lParam
)
&
GCS_RESULTSTR
)
#
define
NO_IME_CARET
-
1
IMMHandler
:
:
IMMHandler
(
)
:
mComposingWindow
(
nullptr
)
mCursorPosition
(
NO_IME_CARET
)
mCompositionStart
(
0
)
mIsComposing
(
false
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
IMMHandler
:
:
IMMHandler
is
created
"
)
)
;
}
IMMHandler
:
:
~
IMMHandler
(
)
{
if
(
mIsComposing
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
~
IMMHandler
ERROR
the
instance
is
still
composing
"
)
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
IMMHandler
:
:
IMMHandler
is
destroyed
"
)
)
;
}
nsresult
IMMHandler
:
:
EnsureClauseArray
(
int32_t
aCount
)
{
NS_ENSURE_ARG_MIN
(
aCount
0
)
;
mClauseArray
.
SetCapacity
(
aCount
+
32
)
;
return
NS_OK
;
}
nsresult
IMMHandler
:
:
EnsureAttributeArray
(
int32_t
aCount
)
{
NS_ENSURE_ARG_MIN
(
aCount
0
)
;
mAttributeArray
.
SetCapacity
(
aCount
+
64
)
;
return
NS_OK
;
}
void
IMMHandler
:
:
CommitComposition
(
nsWindow
*
aWindow
bool
aForce
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CommitComposition
aForce
=
%
s
aWindow
=
%
p
hWnd
=
%
p
"
"
mComposingWindow
=
%
p
%
s
"
GetBoolName
(
aForce
)
aWindow
aWindow
-
>
GetWindowHandle
(
)
gIMMHandler
?
gIMMHandler
-
>
mComposingWindow
:
nullptr
gIMMHandler
&
&
gIMMHandler
-
>
mComposingWindow
?
IsComposingOnOurEditor
(
)
?
"
(
composing
on
editor
)
"
:
"
(
composing
on
plug
-
in
)
"
:
"
"
)
)
;
if
(
!
aForce
&
&
!
IsComposingWindow
(
aWindow
)
)
{
return
;
}
IMEContext
context
(
aWindow
)
;
bool
associated
=
context
.
AssociateDefaultContext
(
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CommitComposition
associated
=
%
s
"
GetBoolName
(
associated
)
)
)
;
if
(
context
.
IsValid
(
)
)
{
:
:
ImmNotifyIME
(
context
.
get
(
)
NI_COMPOSITIONSTR
CPS_COMPLETE
0
)
;
:
:
ImmNotifyIME
(
context
.
get
(
)
NI_COMPOSITIONSTR
CPS_CANCEL
0
)
;
}
if
(
associated
)
{
context
.
Disassociate
(
)
;
}
}
void
IMMHandler
:
:
CancelComposition
(
nsWindow
*
aWindow
bool
aForce
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CancelComposition
aForce
=
%
s
aWindow
=
%
p
hWnd
=
%
p
"
"
mComposingWindow
=
%
p
%
s
"
GetBoolName
(
aForce
)
aWindow
aWindow
-
>
GetWindowHandle
(
)
gIMMHandler
?
gIMMHandler
-
>
mComposingWindow
:
nullptr
gIMMHandler
&
&
gIMMHandler
-
>
mComposingWindow
?
IsComposingOnOurEditor
(
)
?
"
(
composing
on
editor
)
"
:
"
(
composing
on
plug
-
in
)
"
:
"
"
)
)
;
if
(
!
aForce
&
&
!
IsComposingWindow
(
aWindow
)
)
{
return
;
}
IMEContext
context
(
aWindow
)
;
bool
associated
=
context
.
AssociateDefaultContext
(
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CancelComposition
associated
=
%
s
"
GetBoolName
(
associated
)
)
)
;
if
(
context
.
IsValid
(
)
)
{
:
:
ImmNotifyIME
(
context
.
get
(
)
NI_COMPOSITIONSTR
CPS_CANCEL
0
)
;
}
if
(
associated
)
{
context
.
Disassociate
(
)
;
}
}
void
IMMHandler
:
:
OnFocusChange
(
bool
aFocus
nsWindow
*
aWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnFocusChange
(
aFocus
=
%
s
aWindow
=
%
p
)
sHasFocus
=
%
s
"
"
IsComposingWindow
(
aWindow
)
=
%
s
aWindow
-
>
Destroyed
(
)
=
%
s
"
GetBoolName
(
aFocus
)
aWindow
GetBoolName
(
sHasFocus
)
GetBoolName
(
IsComposingWindow
(
aWindow
)
)
GetBoolName
(
aWindow
-
>
Destroyed
(
)
)
)
)
;
if
(
!
aFocus
)
{
IMEHandler
:
:
MaybeDestroyNativeCaret
(
)
;
if
(
IsComposingWindow
(
aWindow
)
&
&
aWindow
-
>
Destroyed
(
)
)
{
CancelComposition
(
aWindow
)
;
}
}
if
(
gIMMHandler
)
{
gIMMHandler
-
>
mContentSelection
.
reset
(
)
;
}
sHasFocus
=
aFocus
;
}
void
IMMHandler
:
:
OnUpdateComposition
(
nsWindow
*
aWindow
)
{
if
(
!
gIMMHandler
)
{
return
;
}
IMEContext
context
(
aWindow
)
;
gIMMHandler
-
>
SetIMERelatedWindowsPos
(
aWindow
context
)
;
}
void
IMMHandler
:
:
OnSelectionChange
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
bool
aIsIMMActive
)
{
if
(
!
aIMENotification
.
mSelectionChangeData
.
mCausedByComposition
&
&
aIsIMMActive
)
{
MaybeAdjustCompositionFont
(
aWindow
aIMENotification
.
mSelectionChangeData
.
GetWritingMode
(
)
)
;
}
if
(
gIMMHandler
)
{
gIMMHandler
-
>
mContentSelection
=
Some
(
ContentSelection
(
aIMENotification
.
mSelectionChangeData
)
)
;
}
}
void
IMMHandler
:
:
MaybeAdjustCompositionFont
(
nsWindow
*
aWindow
const
WritingMode
&
aWritingMode
bool
aForceUpdate
)
{
switch
(
sCodePage
)
{
case
932
:
case
936
:
case
949
:
case
950
:
EnsureHandlerInstance
(
)
;
break
;
default
:
if
(
!
gIMMHandler
)
{
return
;
}
}
IMEContext
context
(
aWindow
)
;
gIMMHandler
-
>
AdjustCompositionFont
(
aWindow
context
aWritingMode
aForceUpdate
)
;
}
bool
IMMHandler
:
:
ProcessInputLangChangeMessage
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
aResult
.
mResult
=
0
;
aResult
.
mConsumed
=
false
;
if
(
gIMMHandler
)
{
gIMMHandler
-
>
OnInputLangChange
(
aWindow
wParam
lParam
aResult
)
;
}
InitKeyboardLayout
(
aWindow
reinterpret_cast
<
HKL
>
(
lParam
)
)
;
Terminate
(
)
;
return
false
;
}
bool
IMMHandler
:
:
ProcessMessage
(
nsWindow
*
aWindow
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
MSGResult
&
aResult
)
{
aResult
.
mResult
=
0
;
switch
(
msg
)
{
case
WM_INPUTLANGCHANGE
:
return
ProcessInputLangChangeMessage
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_STARTCOMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEStartComposition
(
aWindow
aResult
)
;
case
WM_IME_COMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEComposition
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_ENDCOMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEEndComposition
(
aWindow
aResult
)
;
case
WM_IME_CHAR
:
return
OnIMEChar
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_NOTIFY
:
return
OnIMENotify
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_REQUEST
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMERequest
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_SELECT
:
return
OnIMESelect
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_SETCONTEXT
:
return
OnIMESetContext
(
aWindow
wParam
lParam
aResult
)
;
case
WM_KEYDOWN
:
return
OnKeyDownEvent
(
aWindow
wParam
lParam
aResult
)
;
case
WM_CHAR
:
if
(
!
gIMMHandler
)
{
return
false
;
}
return
gIMMHandler
-
>
OnChar
(
aWindow
wParam
lParam
aResult
)
;
default
:
return
false
;
}
;
}
void
IMMHandler
:
:
OnInputLangChange
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnInputLangChange
hWnd
=
%
p
wParam
=
%
08zx
"
"
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aWindow
-
>
NotifyIME
(
REQUEST_TO_COMMIT_COMPOSITION
)
;
NS_ASSERTION
(
!
mIsComposing
"
ResetInputState
failed
"
)
;
if
(
mIsComposing
)
{
HandleEndComposition
(
aWindow
)
;
}
aResult
.
mConsumed
=
false
;
}
bool
IMMHandler
:
:
OnIMEStartComposition
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMEStartComposition
hWnd
=
%
p
mIsComposing
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
GetBoolName
(
mIsComposing
)
)
)
;
aResult
.
mConsumed
=
ShouldDrawCompositionStringOurselves
(
)
;
if
(
mIsComposing
)
{
NS_WARNING
(
"
Composition
has
been
already
started
"
)
;
return
true
;
}
IMEContext
context
(
aWindow
)
;
HandleStartComposition
(
aWindow
context
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEComposition
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMEComposition
hWnd
=
%
p
lParam
=
%
08
"
PRIxLPTR
"
mIsComposing
=
%
s
"
"
GCS_RESULTSTR
=
%
s
GCS_COMPSTR
=
%
s
GCS_COMPATTR
=
%
s
GCS_COMPCLAUSE
=
%
s
"
"
GCS_CURSORPOS
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
lParam
GetBoolName
(
mIsComposing
)
GetBoolName
(
lParam
&
GCS_RESULTSTR
)
GetBoolName
(
lParam
&
GCS_COMPSTR
)
GetBoolName
(
lParam
&
GCS_COMPATTR
)
GetBoolName
(
lParam
&
GCS_COMPCLAUSE
)
GetBoolName
(
lParam
&
GCS_CURSORPOS
)
)
)
;
IMEContext
context
(
aWindow
)
;
aResult
.
mConsumed
=
HandleComposition
(
aWindow
context
lParam
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEEndComposition
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMEEndComposition
hWnd
=
%
p
mIsComposing
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
GetBoolName
(
mIsComposing
)
)
)
;
aResult
.
mConsumed
=
ShouldDrawCompositionStringOurselves
(
)
;
if
(
!
mIsComposing
)
{
return
true
;
}
MSG
compositionMsg
;
if
(
WinUtils
:
:
PeekMessage
(
&
compositionMsg
aWindow
-
>
GetWindowHandle
(
)
WM_IME_STARTCOMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
)
&
&
compositionMsg
.
message
=
=
WM_IME_COMPOSITION
&
&
IS_COMMITTING_LPARAM
(
compositionMsg
.
lParam
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMEEndComposition
WM_IME_ENDCOMPOSITION
is
"
"
followed
by
WM_IME_COMPOSITION
ignoring
the
message
.
.
.
"
)
)
;
return
true
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMEEndComposition
mCompositionString
=
\
"
%
s
\
"
%
s
"
NS_ConvertUTF16toUTF8
(
mCompositionString
)
.
get
(
)
mCompositionString
.
IsEmpty
(
)
?
"
"
:
"
but
canceling
it
.
.
.
"
)
)
;
HandleEndComposition
(
aWindow
&
EmptyString
(
)
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEChar
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMEChar
hWnd
=
%
p
char
=
%
08zx
"
aWindow
-
>
GetWindowHandle
(
)
wParam
)
)
;
aResult
.
mConsumed
=
true
;
return
true
;
}
bool
IMMHandler
:
:
OnIMECompositionFull
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMECompositionFull
hWnd
=
%
p
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
false
;
return
true
;
}
bool
IMMHandler
:
:
OnIMENotify
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
switch
(
wParam
)
{
case
IMN_CHANGECANDIDATE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_CHANGECANDIDATE
"
"
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_CLOSECANDIDATE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_CLOSECANDIDATE
"
"
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_CLOSESTATUSWINDOW
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_CLOSESTATUSWINDOW
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_GUIDELINE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_GUIDELINE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_OPENCANDIDATE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_OPENCANDIDATE
"
"
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_OPENSTATUSWINDOW
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_OPENSTATUSWINDOW
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETCANDIDATEPOS
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETCANDIDATEPOS
"
"
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_SETCOMPOSITIONFONT
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETCOMPOSITIONFONT
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETCOMPOSITIONWINDOW
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETCOMPOSITIONWINDOW
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETCONVERSIONMODE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETCONVERSIONMODE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETOPENSTATUS
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETOPENSTATUS
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETSENTENCEMODE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETSENTENCEMODE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETSTATUSWINDOWPOS
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_SETSTATUSWINDOWPOS
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_PRIVATE
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMENotify
hWnd
=
%
p
IMN_PRIVATE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
}
aResult
.
mConsumed
=
false
;
return
true
;
}
bool
IMMHandler
:
:
OnIMERequest
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
switch
(
wParam
)
{
case
IMR_RECONVERTSTRING
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMERequest
hWnd
=
%
p
IMR_RECONVERTSTRING
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
HandleReconvert
(
aWindow
lParam
&
aResult
.
mResult
)
;
return
true
;
case
IMR_QUERYCHARPOSITION
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMERequest
hWnd
=
%
p
IMR_QUERYCHARPOSITION
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
HandleQueryCharPosition
(
aWindow
lParam
&
aResult
.
mResult
)
;
return
true
;
case
IMR_DOCUMENTFEED
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMERequest
hWnd
=
%
p
IMR_DOCUMENTFEED
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
HandleDocumentFeed
(
aWindow
lParam
&
aResult
.
mResult
)
;
return
true
;
default
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMERequest
hWnd
=
%
p
wParam
=
%
08zx
"
aWindow
-
>
GetWindowHandle
(
)
wParam
)
)
;
aResult
.
mConsumed
=
false
;
return
true
;
}
}
bool
IMMHandler
:
:
OnIMESelect
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMESelect
hWnd
=
%
p
wParam
=
%
08zx
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aResult
.
mConsumed
=
false
;
return
true
;
}
bool
IMMHandler
:
:
OnIMESetContext
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMESetContext
hWnd
=
%
p
%
s
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
wParam
?
"
Active
"
:
"
Deactive
"
lParam
)
)
;
aResult
.
mConsumed
=
false
;
if
(
IsTopLevelWindowOfComposition
(
aWindow
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMESetContext
hWnd
=
%
p
is
top
level
window
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
return
true
;
}
bool
cancelComposition
=
false
;
if
(
wParam
&
&
gIMMHandler
)
{
cancelComposition
=
gIMMHandler
-
>
CommitCompositionOnPreviousWindow
(
aWindow
)
;
}
if
(
wParam
&
&
(
lParam
&
ISC_SHOWUICOMPOSITIONWINDOW
)
&
&
ShouldDrawCompositionStringOurselves
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnIMESetContext
ISC_SHOWUICOMPOSITIONWINDOW
is
"
"
removed
"
)
)
;
lParam
&
=
~
ISC_SHOWUICOMPOSITIONWINDOW
;
}
aResult
.
mResult
=
:
:
DefWindowProc
(
aWindow
-
>
GetWindowHandle
(
)
WM_IME_SETCONTEXT
wParam
lParam
)
;
if
(
cancelComposition
)
{
CancelComposition
(
aWindow
true
)
;
}
aResult
.
mConsumed
=
true
;
return
true
;
}
bool
IMMHandler
:
:
OnChar
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
aResult
.
mConsumed
=
false
;
if
(
IsIMECharRecordsEmpty
(
)
)
{
return
aResult
.
mConsumed
;
}
WPARAM
recWParam
;
LPARAM
recLParam
;
DequeueIMECharRecords
(
recWParam
recLParam
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnChar
aWindow
=
%
p
wParam
=
%
08zx
lParam
=
%
08
"
PRIxLPTR
"
"
"
recorded
:
wParam
=
%
08zx
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
recWParam
recLParam
)
)
;
if
(
recWParam
!
=
wParam
|
|
recLParam
!
=
lParam
)
{
ResetIMECharRecords
(
)
;
return
aResult
.
mConsumed
;
}
aResult
.
mConsumed
=
true
;
return
aResult
.
mConsumed
;
}
TextEventDispatcher
*
IMMHandler
:
:
GetTextEventDispatcherFor
(
nsWindow
*
aWindow
)
{
return
aWindow
=
=
mComposingWindow
&
&
mDispatcher
?
mDispatcher
.
get
(
)
:
aWindow
-
>
GetTextEventDispatcher
(
)
;
}
void
IMMHandler
:
:
HandleStartComposition
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
MOZ_ASSERT
(
!
mIsComposing
"
HandleStartComposition
is
called
but
mIsComposing
is
TRUE
"
)
;
const
Maybe
<
ContentSelection
>
&
contentSelection
=
GetContentSelectionWithQueryIfNothing
(
aWindow
)
;
if
(
contentSelection
.
isNothing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleStartComposition
FAILED
due
to
"
"
Selection
:
:
GetContentSelectionWithQueryIfNothing
(
)
failure
"
)
)
;
return
;
}
if
(
!
contentSelection
-
>
HasRange
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleStartComposition
FAILED
due
to
"
"
there
is
no
selection
"
)
)
;
return
;
}
AdjustCompositionFont
(
aWindow
aContext
contentSelection
-
>
WritingModeRef
(
)
)
;
mCompositionStart
=
contentSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
;
mCursorPosition
=
NO_IME_CARET
;
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcherFor
(
aWindow
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleStartComposition
FAILED
due
to
"
"
TextEventDispatcher
:
:
BeginNativeInputTransaction
(
)
failure
"
)
)
;
return
;
}
WidgetEventTime
eventTime
=
aWindow
-
>
CurrentMessageWidgetEventTime
(
)
;
nsEventStatus
status
;
rv
=
dispatcher
-
>
StartComposition
(
status
&
eventTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleStartComposition
FAILED
due
to
"
"
TextEventDispatcher
:
:
StartComposition
(
)
failure
"
)
)
;
return
;
}
mIsComposing
=
true
;
mComposingWindow
=
aWindow
;
mDispatcher
=
dispatcher
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleStartComposition
START
composition
"
"
mCompositionStart
=
%
u
"
mCompositionStart
)
)
;
}
bool
IMMHandler
:
:
HandleComposition
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
LPARAM
lParam
)
{
if
(
!
mIsComposing
)
{
MSG
msg1
msg2
;
HWND
wnd
=
aWindow
-
>
GetWindowHandle
(
)
;
if
(
WinUtils
:
:
PeekMessage
(
&
msg1
wnd
WM_IME_STARTCOMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
)
&
&
msg1
.
message
=
=
WM_IME_STARTCOMPOSITION
&
&
WinUtils
:
:
PeekMessage
(
&
msg2
wnd
WM_IME_ENDCOMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
)
&
&
msg2
.
message
=
=
WM_IME_COMPOSITION
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
Ignores
due
to
find
a
"
"
WM_IME_STARTCOMPOSITION
"
)
)
;
return
ShouldDrawCompositionStringOurselves
(
)
;
}
}
bool
startCompositionMessageHasBeenSent
=
mIsComposing
;
if
(
IS_COMMITTING_LPARAM
(
lParam
)
)
{
if
(
!
mIsComposing
)
{
HandleStartComposition
(
aWindow
aContext
)
;
}
GetCompositionString
(
aContext
GCS_RESULTSTR
mCompositionString
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_RESULTSTR
"
)
)
;
HandleEndComposition
(
aWindow
&
mCompositionString
)
;
if
(
!
IS_COMPOSING_LPARAM
(
lParam
)
)
{
return
ShouldDrawCompositionStringOurselves
(
)
;
}
}
if
(
!
mIsComposing
)
{
HandleStartComposition
(
aWindow
aContext
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_COMPSTR
"
)
)
;
nsAutoString
previousCompositionString
(
mCompositionString
)
;
GetCompositionString
(
aContext
GCS_COMPSTR
mCompositionString
)
;
if
(
!
IS_COMPOSING_LPARAM
(
lParam
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
lParam
doesn
'
t
indicate
composing
"
"
mCompositionString
=
\
"
%
s
\
"
previousCompositionString
=
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
mCompositionString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
previousCompositionString
)
.
get
(
)
)
)
;
if
(
previousCompositionString
=
=
mCompositionString
)
{
return
ShouldDrawCompositionStringOurselves
(
)
;
}
if
(
mCompositionString
.
IsEmpty
(
)
)
{
mClauseArray
.
Clear
(
)
;
mAttributeArray
.
Clear
(
)
;
mCursorPosition
=
0
;
DispatchCompositionChangeEvent
(
aWindow
aContext
)
;
return
ShouldDrawCompositionStringOurselves
(
)
;
}
}
if
(
mCompositionString
.
IsEmpty
(
)
&
&
!
startCompositionMessageHasBeenSent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
Aborting
GCS_COMPSTR
"
)
)
;
HandleEndComposition
(
aWindow
)
;
return
IS_COMMITTING_LPARAM
(
lParam
)
;
}
long
clauseArrayLength
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPCLAUSE
nullptr
0
)
;
clauseArrayLength
/
=
sizeof
(
uint32_t
)
;
if
(
clauseArrayLength
>
0
)
{
nsresult
rv
=
EnsureClauseArray
(
clauseArrayLength
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
useA_API
=
!
(
sIMEProperty
&
IME_PROP_UNICODE
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_COMPCLAUSE
useA_API
=
%
s
"
useA_API
?
"
TRUE
"
:
"
FALSE
"
)
)
;
long
clauseArrayLength2
=
useA_API
?
:
:
ImmGetCompositionStringA
(
aContext
.
get
(
)
GCS_COMPCLAUSE
mClauseArray
.
Elements
(
)
mClauseArray
.
Capacity
(
)
*
sizeof
(
uint32_t
)
)
:
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPCLAUSE
mClauseArray
.
Elements
(
)
mClauseArray
.
Capacity
(
)
*
sizeof
(
uint32_t
)
)
;
clauseArrayLength2
/
=
sizeof
(
uint32_t
)
;
if
(
clauseArrayLength
!
=
clauseArrayLength2
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_COMPCLAUSE
"
"
clauseArrayLength
=
%
ld
but
clauseArrayLength2
=
%
ld
"
clauseArrayLength
clauseArrayLength2
)
)
;
if
(
clauseArrayLength
>
clauseArrayLength2
)
clauseArrayLength
=
clauseArrayLength2
;
}
if
(
useA_API
&
&
clauseArrayLength
>
0
)
{
nsAutoCString
compANSIStr
;
if
(
ConvertToANSIString
(
mCompositionString
GetKeyboardCodePage
(
)
compANSIStr
)
)
{
uint32_t
maxlen
=
compANSIStr
.
Length
(
)
;
mClauseArray
.
SetLength
(
clauseArrayLength
)
;
mClauseArray
[
0
]
=
0
;
for
(
int32_t
i
=
1
;
i
<
clauseArrayLength
;
i
+
+
)
{
uint32_t
len
=
std
:
:
min
(
mClauseArray
[
i
]
maxlen
)
;
mClauseArray
[
i
]
=
:
:
MultiByteToWideChar
(
GetKeyboardCodePage
(
)
MB_PRECOMPOSED
(
LPCSTR
)
compANSIStr
.
get
(
)
len
nullptr
0
)
;
}
}
}
}
mClauseArray
.
SetLength
(
std
:
:
max
<
long
>
(
0
clauseArrayLength
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_COMPCLAUSE
mClauseLength
=
%
zu
"
mClauseArray
.
Length
(
)
)
)
;
long
attrArrayLength
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPATTR
nullptr
0
)
;
attrArrayLength
/
=
sizeof
(
uint8_t
)
;
if
(
attrArrayLength
>
0
)
{
nsresult
rv
=
EnsureAttributeArray
(
attrArrayLength
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
attrArrayLength
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPATTR
mAttributeArray
.
Elements
(
)
mAttributeArray
.
Capacity
(
)
*
sizeof
(
uint8_t
)
)
;
}
mAttributeArray
.
SetLength
(
std
:
:
max
<
long
>
(
0
attrArrayLength
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_COMPATTR
mAttributeLength
=
%
zu
"
mAttributeArray
.
Length
(
)
)
)
;
if
(
lParam
&
GCS_CURSORPOS
)
{
mCursorPosition
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_CURSORPOS
nullptr
0
)
;
if
(
mCursorPosition
<
0
)
{
mCursorPosition
=
NO_IME_CARET
;
}
}
else
{
mCursorPosition
=
NO_IME_CARET
;
}
NS_ASSERTION
(
mCursorPosition
<
=
(
long
)
mCompositionString
.
Length
(
)
"
illegal
pos
"
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleComposition
GCS_CURSORPOS
mCursorPosition
=
%
d
"
mCursorPosition
)
)
;
DispatchCompositionChangeEvent
(
aWindow
aContext
)
;
return
ShouldDrawCompositionStringOurselves
(
)
;
}
void
IMMHandler
:
:
HandleEndComposition
(
nsWindow
*
aWindow
const
nsAString
*
aCommitString
)
{
MOZ_ASSERT
(
mIsComposing
"
HandleEndComposition
is
called
but
mIsComposing
is
FALSE
"
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleEndComposition
(
aWindow
=
0x
%
p
aCommitString
=
0x
%
p
"
"
(
\
"
%
s
\
"
)
)
"
aWindow
aCommitString
aCommitString
?
NS_ConvertUTF16toUTF8
(
*
aCommitString
)
.
get
(
)
:
"
"
)
)
;
IMEHandler
:
:
MaybeDestroyNativeCaret
(
)
;
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcherFor
(
aWindow
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleEndComposition
FAILED
due
to
"
"
TextEventDispatcher
:
:
BeginNativeInputTransaction
(
)
failure
"
)
)
;
return
;
}
WidgetEventTime
eventTime
=
aWindow
-
>
CurrentMessageWidgetEventTime
(
)
;
nsEventStatus
status
;
rv
=
dispatcher
-
>
CommitComposition
(
status
aCommitString
&
eventTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleStartComposition
FAILED
due
to
"
"
TextEventDispatcher
:
:
CommitComposition
(
)
failure
"
)
)
;
return
;
}
mIsComposing
=
false
;
mComposingWindow
=
nullptr
;
mDispatcher
=
nullptr
;
}
bool
IMMHandler
:
:
HandleReconvert
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
{
*
oResult
=
0
;
RECONVERTSTRING
*
pReconv
=
reinterpret_cast
<
RECONVERTSTRING
*
>
(
lParam
)
;
const
Maybe
<
ContentSelection
>
&
contentSelection
=
GetContentSelectionWithQueryIfNothing
(
aWindow
)
;
if
(
contentSelection
.
isNothing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleReconvert
FAILED
due
to
"
"
Selection
:
:
GetContentSelectionWithQueryIfNothing
(
)
failure
"
)
)
;
return
false
;
}
const
uint32_t
len
=
contentSelection
-
>
HasRange
(
)
?
contentSelection
-
>
OffsetAndDataRef
(
)
.
Length
(
)
:
0u
;
uint32_t
needSize
=
sizeof
(
RECONVERTSTRING
)
+
len
*
sizeof
(
WCHAR
)
;
if
(
!
pReconv
)
{
if
(
len
=
=
0
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleReconvert
There
are
not
selected
text
"
)
)
;
return
false
;
}
*
oResult
=
needSize
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleReconvert
succeeded
result
=
%
"
PRIdLPTR
*
oResult
)
)
;
return
true
;
}
if
(
pReconv
-
>
dwSize
<
needSize
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleReconvert
FAILED
pReconv
-
>
dwSize
=
%
ld
"
"
needSize
=
%
u
"
pReconv
-
>
dwSize
needSize
)
)
;
return
false
;
}
*
oResult
=
needSize
;
pReconv
-
>
dwVersion
=
0
;
pReconv
-
>
dwStrLen
=
len
;
pReconv
-
>
dwStrOffset
=
sizeof
(
RECONVERTSTRING
)
;
pReconv
-
>
dwCompStrLen
=
len
;
pReconv
-
>
dwCompStrOffset
=
0
;
pReconv
-
>
dwTargetStrLen
=
len
;
pReconv
-
>
dwTargetStrOffset
=
0
;
if
(
len
)
{
:
:
CopyMemory
(
reinterpret_cast
<
LPVOID
>
(
lParam
+
sizeof
(
RECONVERTSTRING
)
)
contentSelection
-
>
OffsetAndDataRef
(
)
.
DataRef
(
)
.
get
(
)
len
*
sizeof
(
WCHAR
)
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleReconvert
SUCCEEDED
pReconv
=
%
s
result
=
%
"
PRIdLPTR
GetReconvertStringLog
(
pReconv
)
.
get
(
)
*
oResult
)
)
;
return
true
;
}
bool
IMMHandler
:
:
HandleQueryCharPosition
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
{
uint32_t
len
=
mIsComposing
?
mCompositionString
.
Length
(
)
:
0
;
*
oResult
=
false
;
IMECHARPOSITION
*
pCharPosition
=
reinterpret_cast
<
IMECHARPOSITION
*
>
(
lParam
)
;
if
(
!
pCharPosition
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleQueryCharPosition
FAILED
due
to
"
"
pCharPosition
is
null
"
)
)
;
return
false
;
}
if
(
pCharPosition
-
>
dwSize
<
sizeof
(
IMECHARPOSITION
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleReconvert
FAILED
pCharPosition
-
>
dwSize
=
%
lu
"
"
sizeof
(
IMECHARPOSITION
)
=
%
zu
"
pCharPosition
-
>
dwSize
sizeof
(
IMECHARPOSITION
)
)
)
;
return
false
;
}
if
(
:
:
GetFocus
(
)
!
=
aWindow
-
>
GetWindowHandle
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleReconvert
FAILED
:
:
GetFocus
(
)
=
%
p
"
"
OurWindowHandle
=
%
p
"
:
:
GetFocus
(
)
aWindow
-
>
GetWindowHandle
(
)
)
)
;
return
false
;
}
if
(
pCharPosition
-
>
dwCharPos
>
len
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleQueryCharPosition
FAILED
"
"
pCharPosition
-
>
dwCharPos
=
%
ld
len
=
%
u
"
pCharPosition
-
>
dwCharPos
len
)
)
;
return
false
;
}
LayoutDeviceIntRect
r
;
bool
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
pCharPosition
-
>
dwCharPos
r
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
LayoutDeviceIntRect
screenRect
;
ResolveIMECaretPos
(
aWindow
-
>
GetTopLevelWindow
(
false
)
r
nullptr
screenRect
)
;
pCharPosition
-
>
pt
.
x
=
screenRect
.
X
(
)
;
pCharPosition
-
>
pt
.
y
=
screenRect
.
Y
(
)
;
pCharPosition
-
>
cLineHeight
=
r
.
Height
(
)
;
WidgetQueryContentEvent
queryEditorRectEvent
(
true
eQueryEditorRect
aWindow
)
;
aWindow
-
>
InitEvent
(
queryEditorRectEvent
)
;
DispatchEvent
(
aWindow
queryEditorRectEvent
)
;
if
(
NS_WARN_IF
(
queryEditorRectEvent
.
Failed
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleQueryCharPosition
eQueryEditorRect
failed
"
)
)
;
:
:
GetWindowRect
(
aWindow
-
>
GetWindowHandle
(
)
&
pCharPosition
-
>
rcDocument
)
;
}
else
{
LayoutDeviceIntRect
editorRectInWindow
=
queryEditorRectEvent
.
mReply
-
>
mRect
;
nsWindow
*
window
=
!
!
queryEditorRectEvent
.
mReply
-
>
mFocusedWidget
?
static_cast
<
nsWindow
*
>
(
queryEditorRectEvent
.
mReply
-
>
mFocusedWidget
)
:
aWindow
;
LayoutDeviceIntRect
editorRectInScreen
;
ResolveIMECaretPos
(
window
editorRectInWindow
nullptr
editorRectInScreen
)
;
:
:
SetRect
(
&
pCharPosition
-
>
rcDocument
editorRectInScreen
.
X
(
)
editorRectInScreen
.
Y
(
)
editorRectInScreen
.
XMost
(
)
editorRectInScreen
.
YMost
(
)
)
;
}
*
oResult
=
TRUE
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleQueryCharPosition
SUCCEEDED
pCharPosition
=
{
"
"
pt
=
{
x
=
%
ld
y
=
%
ld
}
cLineHeight
=
%
d
rcDocument
=
{
left
=
%
ld
top
=
%
ld
"
"
right
=
%
ld
bottom
=
%
ld
}
}
"
pCharPosition
-
>
pt
.
x
pCharPosition
-
>
pt
.
y
pCharPosition
-
>
cLineHeight
pCharPosition
-
>
rcDocument
.
left
pCharPosition
-
>
rcDocument
.
top
pCharPosition
-
>
rcDocument
.
right
pCharPosition
-
>
rcDocument
.
bottom
)
)
;
return
true
;
}
bool
IMMHandler
:
:
HandleDocumentFeed
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
{
*
oResult
=
0
;
RECONVERTSTRING
*
pReconv
=
reinterpret_cast
<
RECONVERTSTRING
*
>
(
lParam
)
;
LayoutDeviceIntPoint
point
(
0
0
)
;
bool
hasCompositionString
=
mIsComposing
&
&
ShouldDrawCompositionStringOurselves
(
)
;
int32_t
targetOffset
targetLength
;
if
(
!
hasCompositionString
)
{
const
Maybe
<
ContentSelection
>
&
contentSelection
=
GetContentSelectionWithQueryIfNothing
(
aWindow
)
;
if
(
contentSelection
.
isNothing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleDocumentFeed
FAILED
due
to
"
"
Selection
:
:
GetContentSelectionWithQueryIfNothing
(
)
failure
"
)
)
;
return
false
;
}
if
(
contentSelection
-
>
HasRange
(
)
)
{
targetOffset
=
static_cast
<
int32_t
>
(
contentSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
)
;
targetLength
=
static_cast
<
int32_t
>
(
contentSelection
-
>
OffsetAndDataRef
(
)
.
Length
(
)
)
;
}
else
{
targetOffset
=
0
;
targetLength
=
INT32_MAX
;
}
}
else
{
targetOffset
=
int32_t
(
mCompositionStart
)
;
targetLength
=
int32_t
(
mCompositionString
.
Length
(
)
)
;
}
if
(
targetOffset
<
0
|
|
targetLength
<
0
|
|
targetOffset
+
targetLength
<
0
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleDocumentFeed
FAILED
"
"
due
to
the
selection
is
out
of
range
"
)
)
;
return
false
;
}
WidgetQueryContentEvent
queryTextContentEvent
(
true
eQueryTextContent
aWindow
)
;
queryTextContentEvent
.
InitForQueryTextContent
(
0
UINT32_MAX
)
;
aWindow
-
>
InitEvent
(
queryTextContentEvent
&
point
)
;
DispatchEvent
(
aWindow
queryTextContentEvent
)
;
if
(
NS_WARN_IF
(
queryTextContentEvent
.
Failed
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleDocumentFeed
FAILED
"
"
due
to
eQueryTextContent
failure
"
)
)
;
return
false
;
}
nsAutoString
str
(
queryTextContentEvent
.
mReply
-
>
DataRef
(
)
)
;
if
(
targetOffset
>
static_cast
<
int32_t
>
(
str
.
Length
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleDocumentFeed
FAILED
"
"
due
to
the
caret
offset
is
invalid
"
)
)
;
return
false
;
}
int32_t
paragraphStart
=
str
.
RFind
(
"
\
n
"
false
targetOffset
-
1
)
+
1
;
int32_t
paragraphEnd
=
str
.
Find
(
"
\
r
"
false
targetOffset
+
targetLength
-
1
)
;
if
(
paragraphEnd
<
0
)
{
paragraphEnd
=
str
.
Length
(
)
;
}
nsDependentSubstring
paragraph
(
str
paragraphStart
paragraphEnd
-
paragraphStart
)
;
uint32_t
len
=
paragraph
.
Length
(
)
;
uint32_t
needSize
=
sizeof
(
RECONVERTSTRING
)
+
len
*
sizeof
(
WCHAR
)
;
if
(
!
pReconv
)
{
*
oResult
=
needSize
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleDocumentFeed
succeeded
result
=
%
"
PRIdLPTR
*
oResult
)
)
;
return
true
;
}
if
(
pReconv
-
>
dwSize
<
needSize
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleDocumentFeed
FAILED
"
"
pReconv
-
>
dwSize
=
%
ld
needSize
=
%
u
"
pReconv
-
>
dwSize
needSize
)
)
;
return
false
;
}
pReconv
-
>
dwVersion
=
0
;
pReconv
-
>
dwStrLen
=
len
;
pReconv
-
>
dwStrOffset
=
sizeof
(
RECONVERTSTRING
)
;
if
(
hasCompositionString
)
{
pReconv
-
>
dwCompStrLen
=
targetLength
;
pReconv
-
>
dwCompStrOffset
=
(
targetOffset
-
paragraphStart
)
*
sizeof
(
WCHAR
)
;
uint32_t
offset
length
;
if
(
!
GetTargetClauseRange
(
&
offset
&
length
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
HandleDocumentFeed
FAILED
"
"
due
to
IMMHandler
:
:
GetTargetClauseRange
(
)
failure
"
)
)
;
return
false
;
}
pReconv
-
>
dwTargetStrLen
=
length
;
pReconv
-
>
dwTargetStrOffset
=
(
offset
-
paragraphStart
)
*
sizeof
(
WCHAR
)
;
}
else
{
pReconv
-
>
dwTargetStrLen
=
targetLength
;
pReconv
-
>
dwTargetStrOffset
=
(
targetOffset
-
paragraphStart
)
*
sizeof
(
WCHAR
)
;
pReconv
-
>
dwCompStrLen
=
0
;
pReconv
-
>
dwCompStrOffset
=
pReconv
-
>
dwTargetStrOffset
;
}
*
oResult
=
needSize
;
:
:
CopyMemory
(
reinterpret_cast
<
LPVOID
>
(
lParam
+
sizeof
(
RECONVERTSTRING
)
)
paragraph
.
BeginReading
(
)
len
*
sizeof
(
WCHAR
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
HandleDocumentFeed
SUCCEEDED
pReconv
=
%
s
"
"
result
=
%
"
PRIdLPTR
GetReconvertStringLog
(
pReconv
)
.
get
(
)
*
oResult
)
)
;
return
true
;
}
bool
IMMHandler
:
:
CommitCompositionOnPreviousWindow
(
nsWindow
*
aWindow
)
{
if
(
!
mComposingWindow
|
|
mComposingWindow
=
=
aWindow
)
{
return
false
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CommitCompositionOnPreviousWindow
mIsComposing
=
%
s
"
GetBoolName
(
mIsComposing
)
)
)
;
if
(
mIsComposing
)
{
IMEContext
context
(
mComposingWindow
)
;
NS_ASSERTION
(
context
.
IsValid
(
)
"
IME
context
must
be
valid
"
)
;
HandleEndComposition
(
mComposingWindow
)
;
return
true
;
}
return
false
;
}
static
TextRangeType
PlatformToNSAttr
(
uint8_t
aAttr
)
{
switch
(
aAttr
)
{
case
ATTR_INPUT_ERROR
:
case
ATTR_INPUT
:
return
TextRangeType
:
:
eRawClause
;
case
ATTR_CONVERTED
:
return
TextRangeType
:
:
eConvertedClause
;
case
ATTR_TARGET_NOTCONVERTED
:
return
TextRangeType
:
:
eSelectedRawClause
;
case
ATTR_TARGET_CONVERTED
:
return
TextRangeType
:
:
eSelectedClause
;
default
:
NS_ASSERTION
(
false
"
unknown
attribute
"
)
;
return
TextRangeType
:
:
eCaret
;
}
}
void
IMMHandler
:
:
DispatchEvent
(
nsWindow
*
aWindow
WidgetGUIEvent
&
aEvent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
DispatchEvent
(
aWindow
=
0x
%
p
aEvent
=
{
mMessage
=
%
s
}
"
"
aWindow
-
>
Destroyed
(
)
=
%
s
"
aWindow
ToChar
(
aEvent
.
mMessage
)
GetBoolName
(
aWindow
-
>
Destroyed
(
)
)
)
)
;
if
(
aWindow
-
>
Destroyed
(
)
)
{
return
;
}
aWindow
-
>
DispatchWindowEvent
(
aEvent
)
;
}
void
IMMHandler
:
:
DispatchCompositionChangeEvent
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
NS_ASSERTION
(
mIsComposing
"
conflict
state
"
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
"
)
)
;
if
(
!
ShouldDrawCompositionStringOurselves
(
)
)
{
SetIMERelatedWindowsPos
(
aWindow
aContext
)
;
return
;
}
RefPtr
<
nsWindow
>
kungFuDeathGrip
(
aWindow
)
;
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcherFor
(
aWindow
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
TextEventDispatcher
:
:
BeginNativeInputTransaction
(
)
failure
"
)
)
;
return
;
}
if
(
mCompositionString
.
IsEmpty
(
)
)
{
}
else
if
(
mClauseArray
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
"
"
mClauseArray
.
Length
(
)
=
0
"
)
)
;
rv
=
dispatcher
-
>
SetPendingComposition
(
mCompositionString
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
TextEventDispatcher
:
:
SetPendingComposition
(
)
failure
"
)
)
;
return
;
}
}
else
{
rv
=
dispatcher
-
>
SetPendingCompositionString
(
mCompositionString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
TextEventDispatcher
:
:
SetPendingCompositionString
(
)
failure
"
)
)
;
return
;
}
uint32_t
lastOffset
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mClauseArray
.
Length
(
)
-
1
;
i
+
+
)
{
uint32_t
current
=
mClauseArray
[
i
+
1
]
;
if
(
current
>
mCompositionString
.
Length
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
"
"
mClauseArray
[
%
u
]
=
%
u
.
"
"
This
is
larger
than
mCompositionString
.
Length
(
)
=
%
zu
"
i
+
1
current
mCompositionString
.
Length
(
)
)
)
;
current
=
int32_t
(
mCompositionString
.
Length
(
)
)
;
}
uint32_t
length
=
current
-
lastOffset
;
if
(
NS_WARN_IF
(
lastOffset
>
=
mAttributeArray
.
Length
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
invalid
data
of
mClauseArray
or
mAttributeArray
"
)
)
;
return
;
}
TextRangeType
textRangeType
=
PlatformToNSAttr
(
mAttributeArray
[
lastOffset
]
)
;
rv
=
dispatcher
-
>
AppendClauseToPendingComposition
(
length
textRangeType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
TextEventDispatcher
:
:
AppendClauseToPendingComposition
(
)
"
"
failure
"
)
)
;
return
;
}
lastOffset
=
current
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
index
=
%
u
"
"
rangeType
=
%
s
range
length
=
%
u
"
i
ToChar
(
textRangeType
)
length
)
)
;
}
}
if
(
mCursorPosition
=
=
NO_IME_CARET
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
no
caret
"
)
)
;
}
else
{
uint32_t
cursor
=
static_cast
<
uint32_t
>
(
mCursorPosition
)
;
if
(
cursor
>
mCompositionString
.
Length
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CreateTextRangeArray
mCursorPosition
=
%
d
.
"
"
This
is
larger
than
mCompositionString
.
Length
(
)
=
%
zu
"
mCursorPosition
mCompositionString
.
Length
(
)
)
)
;
cursor
=
mCompositionString
.
Length
(
)
;
}
const
TextRangeArray
*
clauses
=
dispatcher
-
>
GetPendingCompositionClauses
(
)
;
const
TextRange
*
targetClause
=
clauses
?
clauses
-
>
GetTargetClause
(
)
:
nullptr
;
if
(
targetClause
&
&
cursor
>
=
targetClause
-
>
mStartOffset
&
&
cursor
<
=
targetClause
-
>
mEndOffset
)
{
mCursorPosition
=
NO_IME_CARET
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
CreateTextRangeArray
no
caret
due
to
it
'
s
in
"
"
the
target
clause
now
mCursorPosition
is
NO_IME_CARET
"
)
)
;
}
if
(
mCursorPosition
!
=
NO_IME_CARET
)
{
rv
=
dispatcher
-
>
SetCaretInPendingComposition
(
cursor
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
TextEventDispatcher
:
:
SetCaretInPendingComposition
(
)
failure
"
)
)
;
return
;
}
}
}
WidgetEventTime
eventTime
=
aWindow
-
>
CurrentMessageWidgetEventTime
(
)
;
nsEventStatus
status
;
rv
=
dispatcher
-
>
FlushPendingComposition
(
status
&
eventTime
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
DispatchCompositionChangeEvent
FAILED
due
to
"
"
TextEventDispatcher
:
:
FlushPendingComposition
(
)
failure
"
)
)
;
return
;
}
}
void
IMMHandler
:
:
GetCompositionString
(
const
IMEContext
&
aContext
DWORD
aIndex
nsAString
&
aCompositionString
)
const
{
aCompositionString
.
Truncate
(
)
;
long
lRtn
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
aIndex
nullptr
0
)
;
if
(
lRtn
<
0
|
|
!
aCompositionString
.
SetLength
(
(
lRtn
/
sizeof
(
WCHAR
)
)
+
1
mozilla
:
:
fallible
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
GetCompositionString
FAILED
due
to
OOM
"
)
)
;
return
;
}
lRtn
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
aIndex
(
LPVOID
)
aCompositionString
.
BeginWriting
(
)
lRtn
+
sizeof
(
WCHAR
)
)
;
aCompositionString
.
SetLength
(
lRtn
/
sizeof
(
WCHAR
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
GetCompositionString
succeeded
aCompositionString
=
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
aCompositionString
)
.
get
(
)
)
)
;
}
bool
IMMHandler
:
:
GetTargetClauseRange
(
uint32_t
*
aOffset
uint32_t
*
aLength
)
{
NS_ENSURE_TRUE
(
aOffset
false
)
;
NS_ENSURE_TRUE
(
mIsComposing
false
)
;
NS_ENSURE_TRUE
(
ShouldDrawCompositionStringOurselves
(
)
false
)
;
bool
found
=
false
;
*
aOffset
=
mCompositionStart
;
for
(
uint32_t
i
=
0
;
i
<
mAttributeArray
.
Length
(
)
;
i
+
+
)
{
if
(
mAttributeArray
[
i
]
=
=
ATTR_TARGET_NOTCONVERTED
|
|
mAttributeArray
[
i
]
=
=
ATTR_TARGET_CONVERTED
)
{
*
aOffset
=
mCompositionStart
+
i
;
found
=
true
;
break
;
}
}
if
(
!
aLength
)
{
return
true
;
}
if
(
!
found
)
{
*
aLength
=
mCompositionString
.
Length
(
)
;
return
true
;
}
uint32_t
offsetInComposition
=
*
aOffset
-
mCompositionStart
;
*
aLength
=
mCompositionString
.
Length
(
)
-
offsetInComposition
;
for
(
uint32_t
i
=
offsetInComposition
;
i
<
mAttributeArray
.
Length
(
)
;
i
+
+
)
{
if
(
mAttributeArray
[
i
]
!
=
ATTR_TARGET_NOTCONVERTED
&
&
mAttributeArray
[
i
]
!
=
ATTR_TARGET_CONVERTED
)
{
*
aLength
=
i
-
offsetInComposition
;
break
;
}
}
return
true
;
}
bool
IMMHandler
:
:
ConvertToANSIString
(
const
nsString
&
aStr
UINT
aCodePage
nsACString
&
aANSIStr
)
{
int
len
=
:
:
WideCharToMultiByte
(
aCodePage
0
(
LPCWSTR
)
aStr
.
get
(
)
aStr
.
Length
(
)
nullptr
0
nullptr
nullptr
)
;
NS_ENSURE_TRUE
(
len
>
=
0
false
)
;
if
(
!
aANSIStr
.
SetLength
(
len
mozilla
:
:
fallible
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
ConvertToANSIString
FAILED
due
to
OOM
"
)
)
;
return
false
;
}
:
:
WideCharToMultiByte
(
aCodePage
0
(
LPCWSTR
)
aStr
.
get
(
)
aStr
.
Length
(
)
(
LPSTR
)
aANSIStr
.
BeginWriting
(
)
len
nullptr
nullptr
)
;
return
true
;
}
bool
IMMHandler
:
:
GetCharacterRectOfSelectedTextAt
(
nsWindow
*
aWindow
uint32_t
aOffset
LayoutDeviceIntRect
&
aCharRect
WritingMode
*
aWritingMode
)
{
LayoutDeviceIntPoint
point
(
0
0
)
;
const
Maybe
<
ContentSelection
>
&
contentSelection
=
GetContentSelectionWithQueryIfNothing
(
aWindow
)
;
if
(
contentSelection
.
isNothing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
GetCharacterRectOfSelectedTextAt
FAILED
due
to
"
"
Selection
:
:
GetContentSelectionWithQueryIfNothing
(
)
failure
"
)
)
;
return
false
;
}
if
(
!
contentSelection
-
>
HasRange
(
)
&
&
!
mIsComposing
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
IMMHandler
:
:
GetCharacterRectOfSelectedTextAt
FAILED
due
to
"
"
there
is
neither
a
selection
range
nor
composition
string
"
)
)
;
return
false
;
}
const
uint32_t
targetLength
=
mIsComposing
?
mCompositionString
.
Length
(
)
:
contentSelection
-
>
OffsetAndDataRef
(
)
.
Length
(
)
;
if
(
NS_WARN_IF
(
aOffset
>
targetLength
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
GetCharacterRectOfSelectedTextAt
FAILED
due
to
"
"
aOffset
is
too
large
(
aOffset
=
%
u
targetLength
=
%
u
mIsComposing
=
%
s
)
"
aOffset
targetLength
GetBoolName
(
mIsComposing
)
)
)
;
return
false
;
}
uint32_t
caretOffset
=
UINT32_MAX
;
if
(
contentSelection
.
isNothing
(
)
|
|
contentSelection
-
>
OffsetAndDataRef
(
)
.
IsDataEmpty
(
)
)
{
if
(
mIsComposing
)
{
if
(
mCursorPosition
!
=
NO_IME_CARET
)
{
MOZ_ASSERT
(
mCursorPosition
>
=
0
)
;
caretOffset
=
mCursorPosition
;
}
else
if
(
!
ShouldDrawCompositionStringOurselves
(
)
|
|
mCompositionString
.
IsEmpty
(
)
)
{
caretOffset
=
0
;
}
}
else
{
caretOffset
=
0
;
}
}
if
(
aOffset
!
=
caretOffset
)
{
WidgetQueryContentEvent
queryTextRectEvent
(
true
eQueryTextRect
aWindow
)
;
WidgetQueryContentEvent
:
:
Options
options
;
options
.
mRelativeToInsertionPoint
=
true
;
queryTextRectEvent
.
InitForQueryTextRect
(
aOffset
1
options
)
;
aWindow
-
>
InitEvent
(
queryTextRectEvent
&
point
)
;
DispatchEvent
(
aWindow
queryTextRectEvent
)
;
if
(
queryTextRectEvent
.
Succeeded
(
)
)
{
aCharRect
=
queryTextRectEvent
.
mReply
-
>
mRect
;
if
(
aWritingMode
)
{
*
aWritingMode
=
queryTextRectEvent
.
mReply
-
>
WritingModeRef
(
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
IMMHandler
:
:
GetCharacterRectOfSelectedTextAt
Succeeded
"
"
aOffset
=
%
u
aCharRect
=
{
x
:
%
d
y
:
%
d
width
:
%
d
height
:
%
d
}
"
"
queryTextRectEvent
=
{
mReply
=
%
s
}
"
aOffset
aCharRect
.
X
(
)
aCharRect
.
Y
(
)
aCharRect
.
Width
(
)
aCharRect
.
Height
(
)
ToString
(
queryTextRectEvent
.
mReply
)
.
c_str
(
)
)
)
;
return
true
;
}
}
return
GetCaretRect
(
aWindow
aCharRect
aWritingMode
)
;
}
bool
IMMHandler
:
:
GetCaretRect
(
nsWindow
*
aWindow
LayoutDeviceIntRect
&
aCaretRect
WritingMode
*
aWritingMode
)
{
LayoutDeviceIntPoint
point
(
0
0
)
;
WidgetQueryContentEvent
queryCaretRectEvent
(
true
eQueryCaretRect
aWindow
)
;
WidgetQueryContentEvent
:
:
Options
options
;
options
.
mRelativeToInsertionPoint
=
true
;
queryCaretRectEvent
.
InitForQueryCaretRect
(
0
options
)
;
aWindow
-
>
InitEvent
(
queryCaretRectEvent
&
point
)
;
DispatchEvent
(
aWindow
queryCaretRectEvent
)
;
if
(
queryCaretRectEvent
.
Failed
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
GetCaretRect
FAILED
due
to
eQueryCaretRect
failure
"
)
)
;
return
false
;
}
aCaretRect
=
queryCaretRectEvent
.
mReply
-
>
mRect
;
if
(
aWritingMode
)
{
*
aWritingMode
=
queryCaretRectEvent
.
mReply
-
>
WritingModeRef
(
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
GetCaretRect
SUCCEEDED
"
"
aCaretRect
=
{
x
:
%
d
y
:
%
d
width
:
%
d
height
:
%
d
}
"
"
queryCaretRectEvent
=
{
mReply
=
%
s
}
"
aCaretRect
.
X
(
)
aCaretRect
.
Y
(
)
aCaretRect
.
Width
(
)
aCaretRect
.
Height
(
)
ToString
(
queryCaretRectEvent
.
mReply
)
.
c_str
(
)
)
)
;
return
true
;
}
bool
IMMHandler
:
:
SetIMERelatedWindowsPos
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
WritingMode
writingMode
;
LayoutDeviceIntRect
firstSelectedCharRectRelativeToWindow
;
bool
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
0
firstSelectedCharRectRelativeToWindow
&
writingMode
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
nsWindow
*
toplevelWindow
=
aWindow
-
>
GetTopLevelWindow
(
false
)
;
LayoutDeviceIntRect
firstSelectedCharRect
;
ResolveIMECaretPos
(
toplevelWindow
firstSelectedCharRectRelativeToWindow
aWindow
firstSelectedCharRect
)
;
if
(
!
IMEHandler
:
:
IsA11yHandlingNativeCaret
(
)
)
{
LayoutDeviceIntRect
caretRect
(
firstSelectedCharRect
)
caretRectRelativeToWindow
;
if
(
GetCaretRect
(
aWindow
caretRectRelativeToWindow
)
)
{
ResolveIMECaretPos
(
toplevelWindow
caretRectRelativeToWindow
aWindow
caretRect
)
;
}
else
{
NS_WARNING
(
"
failed
to
get
caret
rect
"
)
;
caretRect
.
SetWidth
(
1
)
;
}
IMEHandler
:
:
CreateNativeCaret
(
aWindow
caretRect
)
;
}
if
(
ShouldDrawCompositionStringOurselves
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
SetIMERelatedWindowsPos
Set
candidate
window
"
)
)
;
LayoutDeviceIntRect
firstTargetCharRect
lastTargetCharRect
;
if
(
mIsComposing
&
&
!
mCompositionString
.
IsEmpty
(
)
)
{
uint32_t
offset
length
;
if
(
!
GetTargetClauseRange
(
&
offset
&
length
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
SetIMERelatedWindowsPos
FAILED
due
to
"
"
GetTargetClauseRange
(
)
failure
"
)
)
;
return
false
;
}
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
offset
-
mCompositionStart
firstTargetCharRect
&
writingMode
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
if
(
length
)
{
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
offset
+
length
-
1
-
mCompositionStart
lastTargetCharRect
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
}
else
{
lastTargetCharRect
=
firstTargetCharRect
;
}
}
else
{
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
0
firstTargetCharRect
&
writingMode
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
lastTargetCharRect
=
firstTargetCharRect
;
}
ResolveIMECaretPos
(
toplevelWindow
firstTargetCharRect
aWindow
firstTargetCharRect
)
;
ResolveIMECaretPos
(
toplevelWindow
lastTargetCharRect
aWindow
lastTargetCharRect
)
;
LayoutDeviceIntRect
targetClauseRect
;
targetClauseRect
.
UnionRect
(
firstTargetCharRect
lastTargetCharRect
)
;
CANDIDATEFORM
candForm
;
candForm
.
dwIndex
=
0
;
if
(
!
writingMode
.
IsVertical
(
)
|
|
IsVerticalWritingSupported
(
)
)
{
candForm
.
dwStyle
=
CFS_EXCLUDE
;
candForm
.
rcArea
.
left
=
targetClauseRect
.
X
(
)
;
candForm
.
rcArea
.
right
=
targetClauseRect
.
XMost
(
)
;
candForm
.
rcArea
.
top
=
targetClauseRect
.
Y
(
)
;
candForm
.
rcArea
.
bottom
=
targetClauseRect
.
YMost
(
)
;
if
(
!
writingMode
.
IsVertical
(
)
)
{
candForm
.
ptCurrentPos
.
x
=
firstTargetCharRect
.
X
(
)
;
candForm
.
ptCurrentPos
.
y
=
firstTargetCharRect
.
Y
(
)
;
}
else
if
(
writingMode
.
IsVerticalRL
(
)
)
{
candForm
.
ptCurrentPos
.
x
=
targetClauseRect
.
X
(
)
;
candForm
.
ptCurrentPos
.
y
=
targetClauseRect
.
Y
(
)
;
}
else
{
MOZ_ASSERT
(
writingMode
.
IsVerticalLR
(
)
"
Did
we
miss
some
causes
?
"
)
;
candForm
.
ptCurrentPos
.
x
=
targetClauseRect
.
XMost
(
)
;
candForm
.
ptCurrentPos
.
y
=
targetClauseRect
.
Y
(
)
;
}
}
else
{
candForm
.
dwStyle
=
CFS_CANDIDATEPOS
;
candForm
.
ptCurrentPos
.
x
=
targetClauseRect
.
X
(
)
;
candForm
.
ptCurrentPos
.
y
=
targetClauseRect
.
YMost
(
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
SetIMERelatedWindowsPos
Calling
"
"
ImmSetCandidateWindow
(
)
.
.
.
ptCurrentPos
=
{
x
=
%
ld
y
=
%
ld
}
"
"
rcArea
=
{
left
=
%
ld
top
=
%
ld
right
=
%
ld
bottom
=
%
ld
}
"
"
writingMode
=
%
s
"
candForm
.
ptCurrentPos
.
x
candForm
.
ptCurrentPos
.
y
candForm
.
rcArea
.
left
candForm
.
rcArea
.
top
candForm
.
rcArea
.
right
candForm
.
rcArea
.
bottom
ToString
(
writingMode
)
.
c_str
(
)
)
)
;
:
:
ImmSetCandidateWindow
(
aContext
.
get
(
)
&
candForm
)
;
}
else
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
SetIMERelatedWindowsPos
Set
composition
window
"
)
)
;
COMPOSITIONFORM
compForm
;
compForm
.
dwStyle
=
CFS_POINT
;
compForm
.
ptCurrentPos
.
x
=
!
writingMode
.
IsVerticalLR
(
)
?
firstSelectedCharRect
.
X
(
)
:
firstSelectedCharRect
.
XMost
(
)
;
compForm
.
ptCurrentPos
.
y
=
firstSelectedCharRect
.
Y
(
)
;
:
:
ImmSetCompositionWindow
(
aContext
.
get
(
)
&
compForm
)
;
}
return
true
;
}
void
IMMHandler
:
:
ResolveIMECaretPos
(
nsIWidget
*
aReferenceWidget
LayoutDeviceIntRect
&
aCursorRect
nsIWidget
*
aNewOriginWidget
LayoutDeviceIntRect
&
aOutRect
)
{
aOutRect
=
aCursorRect
;
if
(
aReferenceWidget
=
=
aNewOriginWidget
)
return
;
if
(
aReferenceWidget
)
aOutRect
.
MoveBy
(
aReferenceWidget
-
>
WidgetToScreenOffset
(
)
)
;
if
(
aNewOriginWidget
)
aOutRect
.
MoveBy
(
-
aNewOriginWidget
-
>
WidgetToScreenOffset
(
)
)
;
}
static
void
SetHorizontalFontToLogFont
(
const
nsAString
&
aFontFace
LOGFONTW
&
aLogFont
)
{
aLogFont
.
lfEscapement
=
aLogFont
.
lfOrientation
=
0
;
if
(
NS_WARN_IF
(
aFontFace
.
Length
(
)
>
LF_FACESIZE
-
1
)
)
{
memcpy
(
aLogFont
.
lfFaceName
L
"
System
"
sizeof
(
L
"
System
"
)
)
;
return
;
}
memcpy
(
aLogFont
.
lfFaceName
aFontFace
.
BeginReading
(
)
aFontFace
.
Length
(
)
*
sizeof
(
wchar_t
)
)
;
aLogFont
.
lfFaceName
[
aFontFace
.
Length
(
)
]
=
0
;
}
static
void
SetVerticalFontToLogFont
(
const
nsAString
&
aFontFace
LOGFONTW
&
aLogFont
)
{
aLogFont
.
lfEscapement
=
aLogFont
.
lfOrientation
=
2700
;
if
(
NS_WARN_IF
(
aFontFace
.
Length
(
)
>
LF_FACESIZE
-
2
)
)
{
memcpy
(
aLogFont
.
lfFaceName
L
"
System
"
sizeof
(
L
"
System
"
)
)
;
return
;
}
aLogFont
.
lfFaceName
[
0
]
=
'
'
;
memcpy
(
&
aLogFont
.
lfFaceName
[
1
]
aFontFace
.
BeginReading
(
)
aFontFace
.
Length
(
)
*
sizeof
(
wchar_t
)
)
;
aLogFont
.
lfFaceName
[
aFontFace
.
Length
(
)
+
1
]
=
0
;
}
void
IMMHandler
:
:
AdjustCompositionFont
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
const
WritingMode
&
aWritingMode
bool
aForceUpdate
)
{
static
bool
sCompositionFontsInitialized
=
false
;
static
nsString
sCompositionFont
;
static
bool
sCompositionFontPrefDone
=
false
;
if
(
!
sCompositionFontPrefDone
)
{
sCompositionFontPrefDone
=
true
;
Preferences
:
:
GetString
(
"
intl
.
imm
.
composition_font
"
sCompositionFont
)
;
}
bool
setCompositionFontForcibly
=
aForceUpdate
|
|
(
!
sCompositionFontsInitialized
&
&
!
sCompositionFont
.
IsEmpty
(
)
)
;
static
WritingMode
sCurrentWritingMode
;
static
nsString
sCurrentIMEName
;
if
(
!
setCompositionFontForcibly
&
&
sWritingModeOfCompositionFont
=
=
aWritingMode
&
&
sCurrentIMEName
=
=
sIMEName
)
{
return
;
}
if
(
!
sCompositionFontsInitialized
)
{
sCompositionFontsInitialized
=
true
;
if
(
sCompositionFont
.
IsEmpty
(
)
|
|
sCompositionFont
.
Length
(
)
>
LF_FACESIZE
-
1
|
|
sCompositionFont
[
0
]
=
=
'
'
)
{
LOGFONTW
defaultLogFont
;
if
(
NS_WARN_IF
(
!
:
:
ImmGetCompositionFont
(
aContext
.
get
(
)
&
defaultLogFont
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
AdjustCompositionFont
:
:
ImmGetCompositionFont
(
)
"
"
failed
"
)
)
;
sCompositionFont
.
AssignLiteral
(
"
System
"
)
;
}
else
{
sCompositionFont
.
Assign
(
defaultLogFont
.
lfFaceName
)
;
}
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
AdjustCompositionFont
sCompositionFont
=
\
"
%
s
\
"
is
"
"
initialized
"
NS_ConvertUTF16toUTF8
(
sCompositionFont
)
.
get
(
)
)
)
;
}
static
nsString
sCompositionFontForJapanist2003
;
if
(
IsJapanist2003Active
(
)
&
&
sCompositionFontForJapanist2003
.
IsEmpty
(
)
)
{
const
char
*
kCompositionFontForJapanist2003
=
"
intl
.
imm
.
composition_font
.
japanist_2003
"
;
Preferences
:
:
GetString
(
kCompositionFontForJapanist2003
sCompositionFontForJapanist2003
)
;
if
(
sCompositionFontForJapanist2003
.
IsEmpty
(
)
|
|
sCompositionFontForJapanist2003
.
Length
(
)
>
LF_FACESIZE
-
2
|
|
sCompositionFontForJapanist2003
[
0
]
=
=
'
'
)
{
sCompositionFontForJapanist2003
.
AssignLiteral
(
"
MS
PGothic
"
)
;
}
}
sWritingModeOfCompositionFont
=
aWritingMode
;
sCurrentIMEName
=
sIMEName
;
LOGFONTW
logFont
;
memset
(
&
logFont
0
sizeof
(
logFont
)
)
;
if
(
!
:
:
ImmGetCompositionFont
(
aContext
.
get
(
)
&
logFont
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
AdjustCompositionFont
:
:
ImmGetCompositionFont
(
)
"
"
failed
"
)
)
;
logFont
.
lfFaceName
[
0
]
=
0
;
}
logFont
.
lfWidth
=
0
;
logFont
.
lfWeight
=
FW_DONTCARE
;
logFont
.
lfOutPrecision
=
OUT_DEFAULT_PRECIS
;
logFont
.
lfClipPrecision
=
CLIP_DEFAULT_PRECIS
;
logFont
.
lfPitchAndFamily
=
DEFAULT_PITCH
;
if
(
aWritingMode
.
IsVertical
(
)
&
&
IsVerticalWritingSupported
(
)
)
{
SetVerticalFontToLogFont
(
IsJapanist2003Active
(
)
?
sCompositionFontForJapanist2003
:
sCompositionFont
logFont
)
;
}
else
{
SetHorizontalFontToLogFont
(
IsJapanist2003Active
(
)
?
sCompositionFontForJapanist2003
:
sCompositionFont
logFont
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
IMMHandler
:
:
AdjustCompositionFont
calling
"
"
:
:
ImmSetCompositionFont
(
\
"
%
s
\
"
)
"
NS_ConvertUTF16toUTF8
(
nsDependentString
(
logFont
.
lfFaceName
)
)
.
get
(
)
)
)
;
:
:
ImmSetCompositionFontW
(
aContext
.
get
(
)
&
logFont
)
;
}
nsresult
IMMHandler
:
:
OnMouseButtonEvent
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
)
{
if
(
!
gIMMHandler
)
{
return
NS_OK
;
}
if
(
!
sWM_MSIME_MOUSE
|
|
!
IsComposingOnOurEditor
(
)
|
|
!
ShouldDrawCompositionStringOurselves
(
)
)
{
return
NS_OK
;
}
if
(
aIMENotification
.
mMouseButtonEventData
.
mEventMessage
!
=
eMouseDown
)
{
return
NS_OK
;
}
uint32_t
compositionStart
=
gIMMHandler
-
>
mCompositionStart
;
uint32_t
compositionEnd
=
compositionStart
+
gIMMHandler
-
>
mCompositionString
.
Length
(
)
;
if
(
aIMENotification
.
mMouseButtonEventData
.
mOffset
<
compositionStart
|
|
aIMENotification
.
mMouseButtonEventData
.
mOffset
>
=
compositionEnd
)
{
return
NS_OK
;
}
BYTE
button
;
switch
(
aIMENotification
.
mMouseButtonEventData
.
mButton
)
{
case
MouseButton
:
:
ePrimary
:
button
=
IMEMOUSE_LDOWN
;
break
;
case
MouseButton
:
:
eMiddle
:
button
=
IMEMOUSE_MDOWN
;
break
;
case
MouseButton
:
:
eSecondary
:
button
=
IMEMOUSE_RDOWN
;
break
;
default
:
return
NS_OK
;
}
LayoutDeviceIntPoint
cursorPos
=
aIMENotification
.
mMouseButtonEventData
.
mCursorPos
;
LayoutDeviceIntRect
charRect
=
aIMENotification
.
mMouseButtonEventData
.
mCharRect
;
int32_t
cursorXInChar
=
cursorPos
.
x
-
charRect
.
X
(
)
;
int
positioning
=
1
;
if
(
charRect
.
Width
(
)
>
0
)
{
positioning
=
cursorXInChar
*
4
/
charRect
.
Width
(
)
;
positioning
=
(
positioning
+
2
)
%
4
;
}
int
offset
=
aIMENotification
.
mMouseButtonEventData
.
mOffset
-
compositionStart
;
if
(
positioning
<
2
)
{
offset
+
+
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnMouseButtonEvent
x
y
=
%
d
%
d
offset
=
%
d
"
"
positioning
=
%
d
"
cursorPos
.
x
cursorPos
.
y
offset
positioning
)
)
;
HWND
imeWnd
=
:
:
ImmGetDefaultIMEWnd
(
aWindow
-
>
GetWindowHandle
(
)
)
;
IMEContext
context
(
aWindow
)
;
if
(
:
:
SendMessageW
(
imeWnd
sWM_MSIME_MOUSE
MAKELONG
(
MAKEWORD
(
button
positioning
)
offset
)
(
LPARAM
)
context
.
get
(
)
)
=
=
1
)
{
return
NS_SUCCESS_EVENT_CONSUMED
;
}
return
NS_OK
;
}
bool
IMMHandler
:
:
OnKeyDownEvent
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
OnKeyDownEvent
hWnd
=
%
p
wParam
=
%
08zx
lParam
=
%
08
"
PRIxLPTR
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aResult
.
mConsumed
=
false
;
switch
(
wParam
)
{
case
VK_TAB
:
case
VK_PRIOR
:
case
VK_NEXT
:
case
VK_END
:
case
VK_HOME
:
case
VK_LEFT
:
case
VK_UP
:
case
VK_RIGHT
:
case
VK_DOWN
:
case
VK_RETURN
:
if
(
IsComposingOnOurEditor
(
)
)
{
CancelComposition
(
aWindow
false
)
;
}
return
false
;
default
:
return
false
;
}
}
Maybe
<
ContentSelection
>
IMMHandler
:
:
QueryContentSelection
(
nsWindow
*
aWindow
)
{
WidgetQueryContentEvent
querySelectedTextEvent
(
true
eQuerySelectedText
aWindow
)
;
LayoutDeviceIntPoint
point
(
0
0
)
;
aWindow
-
>
InitEvent
(
querySelectedTextEvent
&
point
)
;
DispatchEvent
(
aWindow
querySelectedTextEvent
)
;
if
(
NS_WARN_IF
(
querySelectedTextEvent
.
Failed
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
Selection
:
:
Init
FAILED
due
to
eQuerySelectedText
"
"
failure
"
)
)
;
return
Nothing
(
)
;
}
if
(
aWindow
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
Selection
:
:
Init
FAILED
due
to
the
widget
destroyed
"
)
)
;
return
Nothing
(
)
;
}
ContentSelection
contentSelection
(
querySelectedTextEvent
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
IMMHandler
:
:
Selection
:
:
Init
querySelectedTextEvent
=
{
mReply
=
%
s
}
"
ToString
(
querySelectedTextEvent
.
mReply
)
.
c_str
(
)
)
)
;
if
(
contentSelection
.
HasRange
(
)
&
&
!
contentSelection
.
OffsetAndDataRef
(
)
.
IsValid
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
IMMHandler
:
:
Selection
:
:
Init
FAILED
due
to
invalid
range
"
)
)
;
return
Nothing
(
)
;
}
return
Some
(
contentSelection
)
;
}
}
}
