#
include
"
mozilla
/
Logging
.
h
"
#
include
"
IMMHandler
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsWindowDefs
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
ifndef
IME_PROP_ACCEPT_WIDE_VKEY
#
define
IME_PROP_ACCEPT_WIDE_VKEY
0x20
#
endif
#
define
RWM_MOUSE
TEXT
(
"
MSIMEMouseOperation
"
)
#
define
IMEMOUSE_NONE
0x00
/
/
no
mouse
button
was
pushed
#
define
IMEMOUSE_LDOWN
0x01
#
define
IMEMOUSE_RDOWN
0x02
#
define
IMEMOUSE_MDOWN
0x04
#
define
IMEMOUSE_WUP
0x10
/
/
wheel
up
#
define
IMEMOUSE_WDOWN
0x20
/
/
wheel
down
static
const
char
*
GetBoolName
(
bool
aBool
)
{
return
aBool
?
"
true
"
:
"
false
"
;
}
static
void
HandleSeparator
(
nsACString
&
aDesc
)
{
if
(
!
aDesc
.
IsEmpty
(
)
)
{
aDesc
.
AppendLiteral
(
"
|
"
)
;
}
}
class
GetIMEGeneralPropertyName
:
public
nsAutoCString
{
public
:
GetIMEGeneralPropertyName
(
DWORD
aFlags
)
{
if
(
!
aFlags
)
{
AppendLiteral
(
"
no
flags
"
)
;
return
;
}
if
(
aFlags
&
IME_PROP_AT_CARET
)
{
AppendLiteral
(
"
IME_PROP_AT_CARET
"
)
;
}
if
(
aFlags
&
IME_PROP_SPECIAL_UI
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_SPECIAL_UI
"
)
;
}
if
(
aFlags
&
IME_PROP_CANDLIST_START_FROM_1
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_CANDLIST_START_FROM_1
"
)
;
}
if
(
aFlags
&
IME_PROP_UNICODE
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_UNICODE
"
)
;
}
if
(
aFlags
&
IME_PROP_COMPLETE_ON_UNSELECT
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_COMPLETE_ON_UNSELECT
"
)
;
}
if
(
aFlags
&
IME_PROP_ACCEPT_WIDE_VKEY
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
IME_PROP_ACCEPT_WIDE_VKEY
"
)
;
}
}
virtual
~
GetIMEGeneralPropertyName
(
)
{
}
}
;
class
GetIMEUIPropertyName
:
public
nsAutoCString
{
public
:
GetIMEUIPropertyName
(
DWORD
aFlags
)
{
if
(
!
aFlags
)
{
AppendLiteral
(
"
no
flags
"
)
;
return
;
}
if
(
aFlags
&
UI_CAP_2700
)
{
AppendLiteral
(
"
UI_CAP_2700
"
)
;
}
if
(
aFlags
&
UI_CAP_ROT90
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
UI_CAP_ROT90
"
)
;
}
if
(
aFlags
&
UI_CAP_ROTANY
)
{
HandleSeparator
(
*
this
)
;
AppendLiteral
(
"
UI_CAP_ROTANY
"
)
;
}
}
virtual
~
GetIMEUIPropertyName
(
)
{
}
}
;
class
GetWritingModeName
:
public
nsAutoCString
{
public
:
GetWritingModeName
(
const
WritingMode
&
aWritingMode
)
{
if
(
!
aWritingMode
.
IsVertical
(
)
)
{
Assign
(
"
Horizontal
"
)
;
return
;
}
if
(
aWritingMode
.
IsVerticalLR
(
)
)
{
Assign
(
"
Vertical
(
LR
)
"
)
;
return
;
}
Assign
(
"
Vertical
(
RL
)
"
)
;
}
virtual
~
GetWritingModeName
(
)
{
}
}
;
class
GetReconvertStringLog
:
public
nsAutoCString
{
public
:
GetReconvertStringLog
(
RECONVERTSTRING
*
aReconv
)
{
AssignLiteral
(
"
{
dwSize
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwSize
)
)
;
AppendLiteral
(
"
dwVersion
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwVersion
)
)
;
AppendLiteral
(
"
dwStrLen
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwStrLen
)
)
;
AppendLiteral
(
"
dwStrOffset
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwStrOffset
)
)
;
AppendLiteral
(
"
dwCompStrLen
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwCompStrLen
)
)
;
AppendLiteral
(
"
dwCompStrOffset
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwCompStrOffset
)
)
;
AppendLiteral
(
"
dwTargetStrLen
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwTargetStrLen
)
)
;
AppendLiteral
(
"
dwTargetStrOffset
=
"
)
;
AppendInt
(
static_cast
<
uint32_t
>
(
aReconv
-
>
dwTargetStrOffset
)
)
;
AppendLiteral
(
"
result
str
=
\
"
"
)
;
if
(
aReconv
-
>
dwStrLen
)
{
char16_t
*
strStart
=
reinterpret_cast
<
char16_t
*
>
(
reinterpret_cast
<
char
*
>
(
aReconv
)
+
aReconv
-
>
dwStrOffset
)
;
nsDependentString
str
(
strStart
aReconv
-
>
dwStrLen
)
;
Append
(
NS_ConvertUTF16toUTF8
(
str
)
)
;
}
AppendLiteral
(
"
\
"
}
"
)
;
}
virtual
~
GetReconvertStringLog
(
)
{
}
}
;
namespace
mozilla
{
namespace
widget
{
static
IMMHandler
*
gIMMHandler
=
nullptr
;
PRLogModuleInfo
*
gIMMLog
=
nullptr
;
IMEContext
:
:
IMEContext
(
HWND
aWnd
)
:
mWnd
(
aWnd
)
mIMC
(
:
:
ImmGetContext
(
aWnd
)
)
{
}
IMEContext
:
:
IMEContext
(
nsWindow
*
aWindow
)
:
mWnd
(
aWindow
-
>
GetWindowHandle
(
)
)
mIMC
(
:
:
ImmGetContext
(
aWindow
-
>
GetWindowHandle
(
)
)
)
{
}
static
UINT
sWM_MSIME_MOUSE
=
0
;
WritingMode
IMMHandler
:
:
sWritingModeOfCompositionFont
;
nsString
IMMHandler
:
:
sIMEName
;
UINT
IMMHandler
:
:
sCodePage
=
0
;
DWORD
IMMHandler
:
:
sIMEProperty
=
0
;
DWORD
IMMHandler
:
:
sIMEUIProperty
=
0
;
bool
IMMHandler
:
:
sAssumeVerticalWritingModeNotSupported
=
false
;
bool
IMMHandler
:
:
sHasFocus
=
false
;
void
IMMHandler
:
:
EnsureHandlerInstance
(
)
{
if
(
!
gIMMHandler
)
{
gIMMHandler
=
new
IMMHandler
(
)
;
}
}
void
IMMHandler
:
:
Initialize
(
)
{
if
(
!
gIMMLog
)
{
gIMMLog
=
PR_NewLogModule
(
"
nsIMM32HandlerWidgets
"
)
;
}
if
(
!
sWM_MSIME_MOUSE
)
{
sWM_MSIME_MOUSE
=
:
:
RegisterWindowMessage
(
RWM_MOUSE
)
;
}
sAssumeVerticalWritingModeNotSupported
=
Preferences
:
:
GetBool
(
"
intl
.
imm
.
vertical_writing
.
always_assume_not_supported
"
false
)
;
InitKeyboardLayout
(
nullptr
:
:
GetKeyboardLayout
(
0
)
)
;
}
void
IMMHandler
:
:
Terminate
(
)
{
if
(
!
gIMMHandler
)
return
;
delete
gIMMHandler
;
gIMMHandler
=
nullptr
;
}
bool
IMMHandler
:
:
IsComposingOnOurEditor
(
)
{
return
gIMMHandler
&
&
gIMMHandler
-
>
mIsComposing
;
}
bool
IMMHandler
:
:
IsComposingOnPlugin
(
)
{
return
gIMMHandler
&
&
gIMMHandler
-
>
mIsComposingOnPlugin
;
}
bool
IMMHandler
:
:
IsComposingWindow
(
nsWindow
*
aWindow
)
{
return
gIMMHandler
&
&
gIMMHandler
-
>
mComposingWindow
=
=
aWindow
;
}
bool
IMMHandler
:
:
IsTopLevelWindowOfComposition
(
nsWindow
*
aWindow
)
{
if
(
!
gIMMHandler
|
|
!
gIMMHandler
-
>
mComposingWindow
)
{
return
false
;
}
HWND
wnd
=
gIMMHandler
-
>
mComposingWindow
-
>
GetWindowHandle
(
)
;
return
WinUtils
:
:
GetTopLevelHWND
(
wnd
true
)
=
=
aWindow
-
>
GetWindowHandle
(
)
;
}
bool
IMMHandler
:
:
IsJapanist2003Active
(
)
{
return
sIMEName
.
EqualsLiteral
(
"
Japanist
2003
"
)
;
}
bool
IMMHandler
:
:
IsGoogleJapaneseInputActive
(
)
{
return
sIMEName
.
Equals
(
L
"
Google
\
x65E5
\
x672C
\
x8A9E
\
x5165
\
x529B
"
L
"
IMM32
\
x30E2
\
x30B8
\
x30E5
\
x30FC
\
x30EB
"
)
;
}
bool
IMMHandler
:
:
ShouldDrawCompositionStringOurselves
(
)
{
return
!
(
sIMEProperty
&
IME_PROP_SPECIAL_UI
)
&
&
(
sIMEProperty
&
IME_PROP_AT_CARET
)
;
}
bool
IMMHandler
:
:
IsVerticalWritingSupported
(
)
{
if
(
sAssumeVerticalWritingModeNotSupported
)
{
return
false
;
}
if
(
IsGoogleJapaneseInputActive
(
)
)
{
return
false
;
}
return
!
!
(
sIMEUIProperty
&
(
UI_CAP_2700
|
UI_CAP_ROT90
|
UI_CAP_ROTANY
)
)
;
}
void
IMMHandler
:
:
InitKeyboardLayout
(
nsWindow
*
aWindow
HKL
aKeyboardLayout
)
{
UINT
IMENameLength
=
:
:
ImmGetDescriptionW
(
aKeyboardLayout
nullptr
0
)
;
if
(
IMENameLength
)
{
sIMEName
.
SetLength
(
+
+
IMENameLength
)
;
IMENameLength
=
:
:
ImmGetDescriptionW
(
aKeyboardLayout
wwc
(
sIMEName
.
BeginWriting
(
)
)
IMENameLength
)
;
sIMEName
.
SetLength
(
IMENameLength
)
;
}
else
{
sIMEName
.
Truncate
(
)
;
}
WORD
langID
=
LOWORD
(
aKeyboardLayout
)
;
:
:
GetLocaleInfoW
(
MAKELCID
(
langID
SORT_DEFAULT
)
LOCALE_IDEFAULTANSICODEPAGE
|
LOCALE_RETURN_NUMBER
(
PWSTR
)
&
sCodePage
sizeof
(
sCodePage
)
/
sizeof
(
WCHAR
)
)
;
sIMEProperty
=
:
:
ImmGetProperty
(
aKeyboardLayout
IGP_PROPERTY
)
;
sIMEUIProperty
=
:
:
ImmGetProperty
(
aKeyboardLayout
IGP_UI
)
;
if
(
sCodePage
=
=
932
&
&
sIMEName
.
IsEmpty
(
)
)
{
sIMEName
=
Preferences
:
:
GetString
(
"
intl
.
imm
.
japanese
.
assume_active_tip_name_as
"
)
;
}
if
(
aWindow
)
{
MaybeAdjustCompositionFont
(
aWindow
sWritingModeOfCompositionFont
true
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
InitKeyboardLayout
aKeyboardLayout
=
%
08x
(
\
"
%
s
\
"
)
sCodePage
=
%
lu
"
"
sIMEProperty
=
%
s
sIMEUIProperty
=
%
s
"
aKeyboardLayout
NS_ConvertUTF16toUTF8
(
sIMEName
)
.
get
(
)
sCodePage
GetIMEGeneralPropertyName
(
sIMEProperty
)
.
get
(
)
GetIMEUIPropertyName
(
sIMEUIProperty
)
.
get
(
)
)
)
;
}
UINT
IMMHandler
:
:
GetKeyboardCodePage
(
)
{
return
sCodePage
;
}
nsIMEUpdatePreference
IMMHandler
:
:
GetIMEUpdatePreference
(
)
{
return
nsIMEUpdatePreference
(
nsIMEUpdatePreference
:
:
NOTIFY_POSITION_CHANGE
|
nsIMEUpdatePreference
:
:
NOTIFY_SELECTION_CHANGE
|
nsIMEUpdatePreference
:
:
NOTIFY_MOUSE_BUTTON_EVENT_ON_CHAR
)
;
}
#
define
IS_COMPOSING_LPARAM
(
lParam
)
\
(
(
lParam
)
&
(
GCS_COMPSTR
|
GCS_COMPATTR
|
GCS_COMPCLAUSE
|
GCS_CURSORPOS
)
)
#
define
IS_COMMITTING_LPARAM
(
lParam
)
(
(
lParam
)
&
GCS_RESULTSTR
)
#
define
NO_IME_CARET
-
1
IMMHandler
:
:
IMMHandler
(
)
:
mComposingWindow
(
nullptr
)
mCursorPosition
(
NO_IME_CARET
)
mCompositionStart
(
0
)
mIsComposing
(
false
)
mIsComposingOnPlugin
(
false
)
mNativeCaretIsCreated
(
false
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Debug
(
"
IMM
:
IMMHandler
is
created
"
)
)
;
}
IMMHandler
:
:
~
IMMHandler
(
)
{
if
(
mIsComposing
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
~
IMMHandler
ERROR
the
instance
is
still
composing
"
)
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Debug
(
"
IMM
:
IMMHandler
is
destroyed
"
)
)
;
}
nsresult
IMMHandler
:
:
EnsureClauseArray
(
int32_t
aCount
)
{
NS_ENSURE_ARG_MIN
(
aCount
0
)
;
mClauseArray
.
SetCapacity
(
aCount
+
32
)
;
return
NS_OK
;
}
nsresult
IMMHandler
:
:
EnsureAttributeArray
(
int32_t
aCount
)
{
NS_ENSURE_ARG_MIN
(
aCount
0
)
;
mAttributeArray
.
SetCapacity
(
aCount
+
64
)
;
return
NS_OK
;
}
void
IMMHandler
:
:
CommitComposition
(
nsWindow
*
aWindow
bool
aForce
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CommitComposition
aForce
=
%
s
aWindow
=
%
p
hWnd
=
%
08x
"
"
mComposingWindow
=
%
p
%
s
"
GetBoolName
(
aForce
)
aWindow
aWindow
-
>
GetWindowHandle
(
)
gIMMHandler
?
gIMMHandler
-
>
mComposingWindow
:
nullptr
gIMMHandler
&
&
gIMMHandler
-
>
mComposingWindow
?
IsComposingOnOurEditor
(
)
?
"
(
composing
on
editor
)
"
:
"
(
composing
on
plug
-
in
)
"
:
"
"
)
)
;
if
(
!
aForce
&
&
!
IsComposingWindow
(
aWindow
)
)
{
return
;
}
IMEContext
context
(
aWindow
)
;
bool
associated
=
context
.
AssociateDefaultContext
(
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CommitComposition
associated
=
%
s
"
GetBoolName
(
associated
)
)
)
;
if
(
context
.
IsValid
(
)
)
{
:
:
ImmNotifyIME
(
context
.
get
(
)
NI_COMPOSITIONSTR
CPS_COMPLETE
0
)
;
:
:
ImmNotifyIME
(
context
.
get
(
)
NI_COMPOSITIONSTR
CPS_CANCEL
0
)
;
}
if
(
associated
)
{
context
.
Disassociate
(
)
;
}
}
void
IMMHandler
:
:
CancelComposition
(
nsWindow
*
aWindow
bool
aForce
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CancelComposition
aForce
=
%
s
aWindow
=
%
p
hWnd
=
%
08x
"
"
mComposingWindow
=
%
p
%
s
"
GetBoolName
(
aForce
)
aWindow
aWindow
-
>
GetWindowHandle
(
)
gIMMHandler
?
gIMMHandler
-
>
mComposingWindow
:
nullptr
gIMMHandler
&
&
gIMMHandler
-
>
mComposingWindow
?
IsComposingOnOurEditor
(
)
?
"
(
composing
on
editor
)
"
:
"
(
composing
on
plug
-
in
)
"
:
"
"
)
)
;
if
(
!
aForce
&
&
!
IsComposingWindow
(
aWindow
)
)
{
return
;
}
IMEContext
context
(
aWindow
)
;
bool
associated
=
context
.
AssociateDefaultContext
(
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CancelComposition
associated
=
%
s
"
GetBoolName
(
associated
)
)
)
;
if
(
context
.
IsValid
(
)
)
{
:
:
ImmNotifyIME
(
context
.
get
(
)
NI_COMPOSITIONSTR
CPS_CANCEL
0
)
;
}
if
(
associated
)
{
context
.
Disassociate
(
)
;
}
}
void
IMMHandler
:
:
OnFocusChange
(
bool
aFocus
nsWindow
*
aWindow
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnFocusChange
(
aFocus
=
%
s
aWindow
=
%
p
)
sHasFocus
=
%
s
"
GetBoolName
(
aFocus
)
aWindow
GetBoolName
(
sHasFocus
)
)
)
;
if
(
gIMMHandler
)
{
gIMMHandler
-
>
mSelection
.
Clear
(
)
;
}
sHasFocus
=
aFocus
;
}
void
IMMHandler
:
:
OnUpdateComposition
(
nsWindow
*
aWindow
)
{
if
(
!
gIMMHandler
)
{
return
;
}
if
(
aWindow
-
>
PluginHasFocus
(
)
)
{
return
;
}
IMEContext
context
(
aWindow
)
;
gIMMHandler
-
>
SetIMERelatedWindowsPos
(
aWindow
context
)
;
}
void
IMMHandler
:
:
OnSelectionChange
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
bool
aIsIMMActive
)
{
if
(
!
aIMENotification
.
mSelectionChangeData
.
mCausedByComposition
&
&
aIsIMMActive
)
{
MaybeAdjustCompositionFont
(
aWindow
aIMENotification
.
mSelectionChangeData
.
GetWritingMode
(
)
)
;
}
if
(
gIMMHandler
)
{
gIMMHandler
-
>
mSelection
.
Update
(
aIMENotification
)
;
}
}
void
IMMHandler
:
:
MaybeAdjustCompositionFont
(
nsWindow
*
aWindow
const
WritingMode
&
aWritingMode
bool
aForceUpdate
)
{
switch
(
sCodePage
)
{
case
932
:
case
936
:
case
949
:
case
950
:
EnsureHandlerInstance
(
)
;
break
;
default
:
if
(
!
gIMMHandler
)
{
return
;
}
}
IMEContext
context
(
aWindow
)
;
gIMMHandler
-
>
AdjustCompositionFont
(
context
aWritingMode
aForceUpdate
)
;
}
bool
IMMHandler
:
:
ProcessInputLangChangeMessage
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
aResult
.
mResult
=
0
;
aResult
.
mConsumed
=
false
;
if
(
gIMMHandler
)
{
gIMMHandler
-
>
OnInputLangChange
(
aWindow
wParam
lParam
aResult
)
;
}
InitKeyboardLayout
(
aWindow
reinterpret_cast
<
HKL
>
(
lParam
)
)
;
Terminate
(
)
;
return
false
;
}
bool
IMMHandler
:
:
ProcessMessage
(
nsWindow
*
aWindow
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
MSGResult
&
aResult
)
{
if
(
aWindow
-
>
PluginHasFocus
(
)
|
|
IsComposingOnPlugin
(
)
)
{
return
ProcessMessageForPlugin
(
aWindow
msg
wParam
lParam
aResult
)
;
}
aResult
.
mResult
=
0
;
switch
(
msg
)
{
case
WM_INPUTLANGCHANGE
:
return
ProcessInputLangChangeMessage
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_STARTCOMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEStartComposition
(
aWindow
aResult
)
;
case
WM_IME_COMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEComposition
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_ENDCOMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEEndComposition
(
aWindow
aResult
)
;
case
WM_IME_CHAR
:
return
OnIMEChar
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_NOTIFY
:
return
OnIMENotify
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_REQUEST
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMERequest
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_SELECT
:
return
OnIMESelect
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_SETCONTEXT
:
return
OnIMESetContext
(
aWindow
wParam
lParam
aResult
)
;
case
WM_KEYDOWN
:
return
OnKeyDownEvent
(
aWindow
wParam
lParam
aResult
)
;
case
WM_CHAR
:
if
(
!
gIMMHandler
)
{
return
false
;
}
return
gIMMHandler
-
>
OnChar
(
aWindow
wParam
lParam
aResult
)
;
default
:
return
false
;
}
;
}
bool
IMMHandler
:
:
ProcessMessageForPlugin
(
nsWindow
*
aWindow
UINT
msg
WPARAM
&
wParam
LPARAM
&
lParam
MSGResult
&
aResult
)
{
aResult
.
mResult
=
0
;
aResult
.
mConsumed
=
false
;
switch
(
msg
)
{
case
WM_INPUTLANGCHANGEREQUEST
:
case
WM_INPUTLANGCHANGE
:
aWindow
-
>
DispatchPluginEvent
(
msg
wParam
lParam
false
)
;
return
ProcessInputLangChangeMessage
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_COMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMECompositionOnPlugin
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_STARTCOMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEStartCompositionOnPlugin
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_ENDCOMPOSITION
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMEEndCompositionOnPlugin
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_CHAR
:
EnsureHandlerInstance
(
)
;
return
gIMMHandler
-
>
OnIMECharOnPlugin
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_SETCONTEXT
:
return
OnIMESetContextOnPlugin
(
aWindow
wParam
lParam
aResult
)
;
case
WM_CHAR
:
if
(
!
gIMMHandler
)
{
return
false
;
}
return
gIMMHandler
-
>
OnCharOnPlugin
(
aWindow
wParam
lParam
aResult
)
;
case
WM_IME_COMPOSITIONFULL
:
case
WM_IME_CONTROL
:
case
WM_IME_KEYDOWN
:
case
WM_IME_KEYUP
:
case
WM_IME_REQUEST
:
case
WM_IME_SELECT
:
aResult
.
mConsumed
=
aWindow
-
>
DispatchPluginEvent
(
msg
wParam
lParam
false
)
;
return
true
;
}
return
false
;
}
void
IMMHandler
:
:
OnInputLangChange
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnInputLangChange
hWnd
=
%
08x
wParam
=
%
08x
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aWindow
-
>
NotifyIME
(
REQUEST_TO_COMMIT_COMPOSITION
)
;
NS_ASSERTION
(
!
mIsComposing
"
ResetInputState
failed
"
)
;
if
(
mIsComposing
)
{
HandleEndComposition
(
aWindow
)
;
}
aResult
.
mConsumed
=
false
;
}
bool
IMMHandler
:
:
OnIMEStartComposition
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEStartComposition
hWnd
=
%
08x
mIsComposing
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
GetBoolName
(
mIsComposing
)
)
)
;
aResult
.
mConsumed
=
ShouldDrawCompositionStringOurselves
(
)
;
if
(
mIsComposing
)
{
NS_WARNING
(
"
Composition
has
been
already
started
"
)
;
return
true
;
}
IMEContext
context
(
aWindow
)
;
HandleStartComposition
(
aWindow
context
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEComposition
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEComposition
hWnd
=
%
08x
lParam
=
%
08x
mIsComposing
=
%
s
"
"
GCS_RESULTSTR
=
%
s
GCS_COMPSTR
=
%
s
GCS_COMPATTR
=
%
s
GCS_COMPCLAUSE
=
%
s
"
"
GCS_CURSORPOS
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
lParam
GetBoolName
(
mIsComposing
)
GetBoolName
(
lParam
&
GCS_RESULTSTR
)
GetBoolName
(
lParam
&
GCS_COMPSTR
)
GetBoolName
(
lParam
&
GCS_COMPATTR
)
GetBoolName
(
lParam
&
GCS_COMPCLAUSE
)
GetBoolName
(
lParam
&
GCS_CURSORPOS
)
)
)
;
MOZ_ASSERT
(
!
aWindow
-
>
PluginHasFocus
(
)
"
OnIMEComposition
should
not
be
called
when
a
plug
-
in
has
focus
"
)
;
IMEContext
context
(
aWindow
)
;
aResult
.
mConsumed
=
HandleComposition
(
aWindow
context
lParam
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEEndComposition
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEEndComposition
hWnd
=
%
08x
mIsComposing
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
GetBoolName
(
mIsComposing
)
)
)
;
aResult
.
mConsumed
=
ShouldDrawCompositionStringOurselves
(
)
;
if
(
!
mIsComposing
)
{
return
true
;
}
MSG
compositionMsg
;
if
(
WinUtils
:
:
PeekMessage
(
&
compositionMsg
aWindow
-
>
GetWindowHandle
(
)
WM_IME_STARTCOMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
)
&
&
compositionMsg
.
message
=
=
WM_IME_COMPOSITION
&
&
IS_COMMITTING_LPARAM
(
compositionMsg
.
lParam
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEEndComposition
WM_IME_ENDCOMPOSITION
is
followed
by
"
"
WM_IME_COMPOSITION
ignoring
the
message
.
.
.
"
)
)
;
return
true
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEEndComposition
mCompositionString
=
\
"
%
s
\
"
%
s
"
NS_ConvertUTF16toUTF8
(
mCompositionString
)
.
get
(
)
mCompositionString
.
IsEmpty
(
)
?
"
"
:
"
but
canceling
it
.
.
.
"
)
)
;
HandleEndComposition
(
aWindow
&
EmptyString
(
)
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEChar
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEChar
hWnd
=
%
08x
char
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
)
)
;
aResult
.
mConsumed
=
true
;
return
true
;
}
bool
IMMHandler
:
:
OnIMECompositionFull
(
nsWindow
*
aWindow
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMECompositionFull
hWnd
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
false
;
return
true
;
}
bool
IMMHandler
:
:
OnIMENotify
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
switch
(
wParam
)
{
case
IMN_CHANGECANDIDATE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_CHANGECANDIDATE
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_CLOSECANDIDATE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_CLOSECANDIDATE
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_CLOSESTATUSWINDOW
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_CLOSESTATUSWINDOW
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_GUIDELINE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_GUIDELINE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_OPENCANDIDATE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_OPENCANDIDATE
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_OPENSTATUSWINDOW
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_OPENSTATUSWINDOW
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETCANDIDATEPOS
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETCANDIDATEPOS
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
lParam
)
)
;
break
;
case
IMN_SETCOMPOSITIONFONT
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETCOMPOSITIONFONT
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETCOMPOSITIONWINDOW
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETCOMPOSITIONWINDOW
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETCONVERSIONMODE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETCONVERSIONMODE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETOPENSTATUS
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETOPENSTATUS
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETSENTENCEMODE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETSENTENCEMODE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_SETSTATUSWINDOWPOS
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_SETSTATUSWINDOWPOS
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
case
IMN_PRIVATE
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMENotify
hWnd
=
%
08x
IMN_PRIVATE
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
break
;
}
aResult
.
mConsumed
=
false
;
return
true
;
}
bool
IMMHandler
:
:
OnIMERequest
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
switch
(
wParam
)
{
case
IMR_RECONVERTSTRING
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMERequest
hWnd
=
%
08x
IMR_RECONVERTSTRING
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
HandleReconvert
(
aWindow
lParam
&
aResult
.
mResult
)
;
return
true
;
case
IMR_QUERYCHARPOSITION
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMERequest
hWnd
=
%
08x
IMR_QUERYCHARPOSITION
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
HandleQueryCharPosition
(
aWindow
lParam
&
aResult
.
mResult
)
;
return
true
;
case
IMR_DOCUMENTFEED
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMERequest
hWnd
=
%
08x
IMR_DOCUMENTFEED
"
aWindow
-
>
GetWindowHandle
(
)
)
)
;
aResult
.
mConsumed
=
HandleDocumentFeed
(
aWindow
lParam
&
aResult
.
mResult
)
;
return
true
;
default
:
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMERequest
hWnd
=
%
08x
wParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
)
)
;
aResult
.
mConsumed
=
false
;
return
true
;
}
}
bool
IMMHandler
:
:
OnIMESelect
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMESelect
hWnd
=
%
08x
wParam
=
%
08x
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aResult
.
mConsumed
=
false
;
return
true
;
}
bool
IMMHandler
:
:
OnIMESetContext
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMESetContext
hWnd
=
%
08x
%
s
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
?
"
Active
"
:
"
Deactive
"
lParam
)
)
;
aResult
.
mConsumed
=
false
;
if
(
IsTopLevelWindowOfComposition
(
aWindow
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMESetContext
hWnd
=
%
08x
is
top
level
window
"
)
)
;
return
true
;
}
bool
cancelComposition
=
false
;
if
(
wParam
&
&
gIMMHandler
)
{
cancelComposition
=
gIMMHandler
-
>
CommitCompositionOnPreviousWindow
(
aWindow
)
;
}
if
(
wParam
&
&
(
lParam
&
ISC_SHOWUICOMPOSITIONWINDOW
)
&
&
ShouldDrawCompositionStringOurselves
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMESetContext
ISC_SHOWUICOMPOSITIONWINDOW
is
removed
"
)
)
;
lParam
&
=
~
ISC_SHOWUICOMPOSITIONWINDOW
;
}
aResult
.
mResult
=
:
:
DefWindowProc
(
aWindow
-
>
GetWindowHandle
(
)
WM_IME_SETCONTEXT
wParam
lParam
)
;
if
(
cancelComposition
)
{
CancelComposition
(
aWindow
true
)
;
}
aResult
.
mConsumed
=
true
;
return
true
;
}
bool
IMMHandler
:
:
OnChar
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
aResult
.
mConsumed
=
false
;
if
(
IsIMECharRecordsEmpty
(
)
)
{
return
aResult
.
mConsumed
;
}
WPARAM
recWParam
;
LPARAM
recLParam
;
DequeueIMECharRecords
(
recWParam
recLParam
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnChar
aWindow
=
%
p
wParam
=
%
08x
lParam
=
%
08x
"
"
recorded
:
wParam
=
%
08x
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
recWParam
recLParam
)
)
;
if
(
recWParam
!
=
wParam
|
|
recLParam
!
=
lParam
)
{
ResetIMECharRecords
(
)
;
return
aResult
.
mConsumed
;
}
aResult
.
mConsumed
=
true
;
return
aResult
.
mConsumed
;
}
bool
IMMHandler
:
:
OnIMEStartCompositionOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEStartCompositionOnPlugin
hWnd
=
%
08x
mIsComposingOnPlugin
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
GetBoolName
(
mIsComposingOnPlugin
)
)
)
;
mIsComposingOnPlugin
=
true
;
mComposingWindow
=
aWindow
;
IMEContext
context
(
aWindow
)
;
SetIMERelatedWindowsPosOnPlugin
(
aWindow
context
)
;
AdjustCompositionFont
(
context
WritingMode
(
)
)
;
aResult
.
mConsumed
=
aWindow
-
>
DispatchPluginEvent
(
WM_IME_STARTCOMPOSITION
wParam
lParam
false
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMECompositionOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMECompositionOnPlugin
hWnd
=
%
08x
lParam
=
%
08x
"
"
mIsComposingOnPlugin
=
%
s
GCS_RESULTSTR
=
%
s
GCS_COMPSTR
=
%
s
"
"
GCS_COMPATTR
=
%
s
GCS_COMPCLAUSE
=
%
s
GCS_CURSORPOS
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
lParam
GetBoolName
(
mIsComposingOnPlugin
)
GetBoolName
(
lParam
&
GCS_RESULTSTR
)
GetBoolName
(
lParam
&
GCS_COMPSTR
)
GetBoolName
(
lParam
&
GCS_COMPATTR
)
GetBoolName
(
lParam
&
GCS_COMPCLAUSE
)
GetBoolName
(
lParam
&
GCS_CURSORPOS
)
)
)
;
if
(
IS_COMMITTING_LPARAM
(
lParam
)
)
{
mIsComposingOnPlugin
=
false
;
mComposingWindow
=
nullptr
;
}
if
(
IS_COMPOSING_LPARAM
(
lParam
)
)
{
mIsComposingOnPlugin
=
true
;
mComposingWindow
=
aWindow
;
IMEContext
context
(
aWindow
)
;
SetIMERelatedWindowsPosOnPlugin
(
aWindow
context
)
;
}
aResult
.
mConsumed
=
aWindow
-
>
DispatchPluginEvent
(
WM_IME_COMPOSITION
wParam
lParam
true
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMEEndCompositionOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMEEndCompositionOnPlugin
hWnd
=
%
08x
mIsComposingOnPlugin
=
%
s
"
aWindow
-
>
GetWindowHandle
(
)
GetBoolName
(
mIsComposingOnPlugin
)
)
)
;
mIsComposingOnPlugin
=
false
;
mComposingWindow
=
nullptr
;
if
(
mNativeCaretIsCreated
)
{
:
:
DestroyCaret
(
)
;
mNativeCaretIsCreated
=
false
;
}
aResult
.
mConsumed
=
aWindow
-
>
DispatchPluginEvent
(
WM_IME_ENDCOMPOSITION
wParam
lParam
false
)
;
return
true
;
}
bool
IMMHandler
:
:
OnIMECharOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMECharOnPlugin
hWnd
=
%
08x
char
=
%
08x
scancode
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aResult
.
mConsumed
=
aWindow
-
>
DispatchPluginEvent
(
WM_IME_CHAR
wParam
lParam
true
)
;
if
(
!
aResult
.
mConsumed
)
{
EnsureHandlerInstance
(
)
;
EnqueueIMECharRecords
(
wParam
lParam
)
;
}
return
true
;
}
bool
IMMHandler
:
:
OnIMESetContextOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnIMESetContextOnPlugin
hWnd
=
%
08x
%
s
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
?
"
Active
"
:
"
Deactive
"
lParam
)
)
;
if
(
wParam
&
&
gIMMHandler
&
&
!
IsTopLevelWindowOfComposition
(
aWindow
)
)
{
if
(
gIMMHandler
-
>
CommitCompositionOnPreviousWindow
(
aWindow
)
)
{
CancelComposition
(
aWindow
)
;
}
}
aWindow
-
>
DispatchPluginEvent
(
WM_IME_SETCONTEXT
wParam
lParam
false
)
;
aResult
.
mResult
=
:
:
DefWindowProc
(
aWindow
-
>
GetWindowHandle
(
)
WM_IME_SETCONTEXT
wParam
lParam
)
;
aResult
.
mConsumed
=
true
;
return
true
;
}
bool
IMMHandler
:
:
OnCharOnPlugin
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
aResult
.
mConsumed
=
false
;
if
(
IsIMECharRecordsEmpty
(
)
)
{
return
false
;
}
WPARAM
recWParam
;
LPARAM
recLParam
;
DequeueIMECharRecords
(
recWParam
recLParam
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnCharOnPlugin
aWindow
=
%
p
wParam
=
%
08x
lParam
=
%
08x
"
"
recorded
:
wParam
=
%
08x
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
recWParam
recLParam
)
)
;
if
(
recWParam
!
=
wParam
|
|
recLParam
!
=
lParam
)
{
ResetIMECharRecords
(
)
;
}
return
false
;
}
void
IMMHandler
:
:
HandleStartComposition
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
NS_PRECONDITION
(
!
mIsComposing
"
HandleStartComposition
is
called
but
mIsComposing
is
TRUE
"
)
;
NS_PRECONDITION
(
!
aWindow
-
>
PluginHasFocus
(
)
"
HandleStartComposition
should
not
be
called
when
a
plug
-
in
has
focus
"
)
;
Selection
&
selection
=
GetSelection
(
)
;
if
(
!
selection
.
EnsureValidSelection
(
aWindow
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleStartComposition
FAILED
due
to
"
"
Selection
:
:
EnsureValidSelection
(
)
failure
"
)
)
;
return
;
}
AdjustCompositionFont
(
aContext
selection
.
mWritingMode
)
;
mCompositionStart
=
selection
.
mOffset
;
mCursorPosition
=
NO_IME_CARET
;
WidgetCompositionEvent
event
(
true
NS_COMPOSITION_START
aWindow
)
;
nsIntPoint
point
(
0
0
)
;
aWindow
-
>
InitEvent
(
event
&
point
)
;
aWindow
-
>
DispatchWindowEvent
(
&
event
)
;
mIsComposing
=
true
;
mComposingWindow
=
aWindow
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleStartComposition
START
composition
mCompositionStart
=
%
ld
"
mCompositionStart
)
)
;
}
bool
IMMHandler
:
:
HandleComposition
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
LPARAM
lParam
)
{
NS_PRECONDITION
(
!
aWindow
-
>
PluginHasFocus
(
)
"
HandleComposition
should
not
be
called
when
a
plug
-
in
has
focus
"
)
;
if
(
!
mIsComposing
)
{
MSG
msg1
msg2
;
HWND
wnd
=
aWindow
-
>
GetWindowHandle
(
)
;
if
(
WinUtils
:
:
PeekMessage
(
&
msg1
wnd
WM_IME_STARTCOMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
)
&
&
msg1
.
message
=
=
WM_IME_STARTCOMPOSITION
&
&
WinUtils
:
:
PeekMessage
(
&
msg2
wnd
WM_IME_ENDCOMPOSITION
WM_IME_COMPOSITION
PM_NOREMOVE
)
&
&
msg2
.
message
=
=
WM_IME_COMPOSITION
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
Ignores
due
to
find
a
"
"
WM_IME_STARTCOMPOSITION
"
)
)
;
return
ShouldDrawCompositionStringOurselves
(
)
;
}
}
bool
startCompositionMessageHasBeenSent
=
mIsComposing
;
if
(
IS_COMMITTING_LPARAM
(
lParam
)
)
{
if
(
!
mIsComposing
)
{
HandleStartComposition
(
aWindow
aContext
)
;
}
GetCompositionString
(
aContext
GCS_RESULTSTR
mCompositionString
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_RESULTSTR
"
)
)
;
HandleEndComposition
(
aWindow
&
mCompositionString
)
;
if
(
!
IS_COMPOSING_LPARAM
(
lParam
)
)
{
return
ShouldDrawCompositionStringOurselves
(
)
;
}
}
if
(
!
mIsComposing
)
{
HandleStartComposition
(
aWindow
aContext
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_COMPSTR
"
)
)
;
nsAutoString
previousCompositionString
(
mCompositionString
)
;
GetCompositionString
(
aContext
GCS_COMPSTR
mCompositionString
)
;
if
(
!
IS_COMPOSING_LPARAM
(
lParam
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
lParam
doesn
'
t
indicate
composing
"
"
mCompositionString
=
\
"
%
s
\
"
previousCompositionString
=
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
mCompositionString
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
previousCompositionString
)
.
get
(
)
)
)
;
if
(
previousCompositionString
=
=
mCompositionString
)
{
return
ShouldDrawCompositionStringOurselves
(
)
;
}
if
(
mCompositionString
.
IsEmpty
(
)
)
{
mClauseArray
.
Clear
(
)
;
mAttributeArray
.
Clear
(
)
;
mCursorPosition
=
0
;
DispatchCompositionChangeEvent
(
aWindow
aContext
)
;
return
ShouldDrawCompositionStringOurselves
(
)
;
}
}
if
(
mCompositionString
.
IsEmpty
(
)
&
&
!
startCompositionMessageHasBeenSent
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
Aborting
GCS_COMPSTR
"
)
)
;
HandleEndComposition
(
aWindow
)
;
return
IS_COMMITTING_LPARAM
(
lParam
)
;
}
long
clauseArrayLength
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPCLAUSE
nullptr
0
)
;
clauseArrayLength
/
=
sizeof
(
uint32_t
)
;
if
(
clauseArrayLength
>
0
)
{
nsresult
rv
=
EnsureClauseArray
(
clauseArrayLength
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
useA_API
=
!
(
sIMEProperty
&
IME_PROP_UNICODE
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_COMPCLAUSE
useA_API
=
%
s
"
useA_API
?
"
TRUE
"
:
"
FALSE
"
)
)
;
long
clauseArrayLength2
=
useA_API
?
:
:
ImmGetCompositionStringA
(
aContext
.
get
(
)
GCS_COMPCLAUSE
mClauseArray
.
Elements
(
)
mClauseArray
.
Capacity
(
)
*
sizeof
(
uint32_t
)
)
:
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPCLAUSE
mClauseArray
.
Elements
(
)
mClauseArray
.
Capacity
(
)
*
sizeof
(
uint32_t
)
)
;
clauseArrayLength2
/
=
sizeof
(
uint32_t
)
;
if
(
clauseArrayLength
!
=
clauseArrayLength2
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_COMPCLAUSE
clauseArrayLength
=
%
ld
but
"
"
clauseArrayLength2
=
%
ld
"
clauseArrayLength
clauseArrayLength2
)
)
;
if
(
clauseArrayLength
>
clauseArrayLength2
)
clauseArrayLength
=
clauseArrayLength2
;
}
if
(
useA_API
)
{
nsAutoCString
compANSIStr
;
if
(
ConvertToANSIString
(
mCompositionString
GetKeyboardCodePage
(
)
compANSIStr
)
)
{
uint32_t
maxlen
=
compANSIStr
.
Length
(
)
;
mClauseArray
[
0
]
=
0
;
for
(
int32_t
i
=
1
;
i
<
clauseArrayLength
;
i
+
+
)
{
uint32_t
len
=
std
:
:
min
(
mClauseArray
[
i
]
maxlen
)
;
mClauseArray
[
i
]
=
:
:
MultiByteToWideChar
(
GetKeyboardCodePage
(
)
MB_PRECOMPOSED
(
LPCSTR
)
compANSIStr
.
get
(
)
len
nullptr
0
)
;
}
}
}
}
mClauseArray
.
SetLength
(
std
:
:
max
<
long
>
(
0
clauseArrayLength
)
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_COMPCLAUSE
mClauseLength
=
%
ld
"
mClauseArray
.
Length
(
)
)
)
;
long
attrArrayLength
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPATTR
nullptr
0
)
;
attrArrayLength
/
=
sizeof
(
uint8_t
)
;
if
(
attrArrayLength
>
0
)
{
nsresult
rv
=
EnsureAttributeArray
(
attrArrayLength
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
attrArrayLength
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_COMPATTR
mAttributeArray
.
Elements
(
)
mAttributeArray
.
Capacity
(
)
*
sizeof
(
uint8_t
)
)
;
}
mAttributeArray
.
SetLength
(
std
:
:
max
<
long
>
(
0
attrArrayLength
)
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_COMPATTR
mAttributeLength
=
%
ld
"
mAttributeArray
.
Length
(
)
)
)
;
if
(
lParam
&
GCS_CURSORPOS
)
{
mCursorPosition
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
GCS_CURSORPOS
nullptr
0
)
;
if
(
mCursorPosition
<
0
)
{
mCursorPosition
=
NO_IME_CARET
;
}
}
else
{
mCursorPosition
=
NO_IME_CARET
;
}
NS_ASSERTION
(
mCursorPosition
<
=
(
long
)
mCompositionString
.
Length
(
)
"
illegal
pos
"
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleComposition
GCS_CURSORPOS
mCursorPosition
=
%
d
"
mCursorPosition
)
)
;
DispatchCompositionChangeEvent
(
aWindow
aContext
)
;
return
ShouldDrawCompositionStringOurselves
(
)
;
}
void
IMMHandler
:
:
HandleEndComposition
(
nsWindow
*
aWindow
const
nsAString
*
aCommitString
)
{
MOZ_ASSERT
(
mIsComposing
"
HandleEndComposition
is
called
but
mIsComposing
is
FALSE
"
)
;
MOZ_ASSERT
(
!
aWindow
-
>
PluginHasFocus
(
)
"
HandleComposition
should
not
be
called
when
a
plug
-
in
has
focus
"
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleEndComposition
(
aWindow
=
0x
%
p
aCommitString
=
0x
%
p
(
\
"
%
s
\
"
)
)
"
aWindow
aCommitString
aCommitString
?
NS_ConvertUTF16toUTF8
(
*
aCommitString
)
.
get
(
)
:
"
"
)
)
;
if
(
mNativeCaretIsCreated
)
{
:
:
DestroyCaret
(
)
;
mNativeCaretIsCreated
=
false
;
}
uint32_t
message
=
aCommitString
?
NS_COMPOSITION_COMMIT
:
NS_COMPOSITION_COMMIT_AS_IS
;
WidgetCompositionEvent
compositionCommitEvent
(
true
message
aWindow
)
;
nsIntPoint
point
(
0
0
)
;
aWindow
-
>
InitEvent
(
compositionCommitEvent
&
point
)
;
if
(
aCommitString
)
{
compositionCommitEvent
.
mData
=
*
aCommitString
;
}
aWindow
-
>
DispatchWindowEvent
(
&
compositionCommitEvent
)
;
mIsComposing
=
false
;
mComposingWindow
=
nullptr
;
}
bool
IMMHandler
:
:
HandleReconvert
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
{
*
oResult
=
0
;
RECONVERTSTRING
*
pReconv
=
reinterpret_cast
<
RECONVERTSTRING
*
>
(
lParam
)
;
Selection
&
selection
=
GetSelection
(
)
;
if
(
!
selection
.
EnsureValidSelection
(
aWindow
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleReconvert
FAILED
due
to
"
"
Selection
:
:
EnsureValidSelection
(
)
failure
"
)
)
;
return
false
;
}
uint32_t
len
=
selection
.
Length
(
)
;
uint32_t
needSize
=
sizeof
(
RECONVERTSTRING
)
+
len
*
sizeof
(
WCHAR
)
;
if
(
!
pReconv
)
{
if
(
len
=
=
0
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleReconvert
There
are
not
selected
text
"
)
)
;
return
false
;
}
*
oResult
=
needSize
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleReconvert
succeeded
result
=
%
ld
"
*
oResult
)
)
;
return
true
;
}
if
(
pReconv
-
>
dwSize
<
needSize
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleReconvert
FAILED
pReconv
-
>
dwSize
=
%
ld
needSize
=
%
ld
"
pReconv
-
>
dwSize
needSize
)
)
;
return
false
;
}
*
oResult
=
needSize
;
pReconv
-
>
dwVersion
=
0
;
pReconv
-
>
dwStrLen
=
len
;
pReconv
-
>
dwStrOffset
=
sizeof
(
RECONVERTSTRING
)
;
pReconv
-
>
dwCompStrLen
=
len
;
pReconv
-
>
dwCompStrOffset
=
0
;
pReconv
-
>
dwTargetStrLen
=
len
;
pReconv
-
>
dwTargetStrOffset
=
0
;
:
:
CopyMemory
(
reinterpret_cast
<
LPVOID
>
(
lParam
+
sizeof
(
RECONVERTSTRING
)
)
selection
.
mString
.
get
(
)
len
*
sizeof
(
WCHAR
)
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleReconvert
SUCCEEDED
pReconv
=
%
s
result
=
%
ld
"
GetReconvertStringLog
(
pReconv
)
.
get
(
)
*
oResult
)
)
;
return
true
;
}
bool
IMMHandler
:
:
HandleQueryCharPosition
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
{
uint32_t
len
=
mIsComposing
?
mCompositionString
.
Length
(
)
:
0
;
*
oResult
=
false
;
IMECHARPOSITION
*
pCharPosition
=
reinterpret_cast
<
IMECHARPOSITION
*
>
(
lParam
)
;
if
(
!
pCharPosition
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleQueryCharPosition
FAILED
due
to
pCharPosition
is
null
"
)
)
;
return
false
;
}
if
(
pCharPosition
-
>
dwSize
<
sizeof
(
IMECHARPOSITION
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleReconvert
FAILED
pCharPosition
-
>
dwSize
=
%
ld
"
"
sizeof
(
IMECHARPOSITION
)
=
%
ld
"
pCharPosition
-
>
dwSize
sizeof
(
IMECHARPOSITION
)
)
)
;
return
false
;
}
if
(
:
:
GetFocus
(
)
!
=
aWindow
-
>
GetWindowHandle
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleReconvert
FAILED
:
:
GetFocus
(
)
=
%
08x
OurWindowHandle
=
%
08x
"
:
:
GetFocus
(
)
aWindow
-
>
GetWindowHandle
(
)
)
)
;
return
false
;
}
if
(
pCharPosition
-
>
dwCharPos
>
len
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleQueryCharPosition
FAILED
pCharPosition
-
>
dwCharPos
=
%
ld
"
"
len
=
%
ld
"
pCharPosition
-
>
dwCharPos
len
)
)
;
return
false
;
}
nsIntRect
r
;
bool
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
pCharPosition
-
>
dwCharPos
r
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
nsIntRect
screenRect
;
ResolveIMECaretPos
(
aWindow
-
>
GetTopLevelWindow
(
false
)
r
nullptr
screenRect
)
;
pCharPosition
-
>
pt
.
x
=
screenRect
.
x
;
pCharPosition
-
>
pt
.
y
=
screenRect
.
y
;
pCharPosition
-
>
cLineHeight
=
r
.
height
;
WidgetQueryContentEvent
editorRect
(
true
NS_QUERY_EDITOR_RECT
aWindow
)
;
aWindow
-
>
InitEvent
(
editorRect
)
;
aWindow
-
>
DispatchWindowEvent
(
&
editorRect
)
;
if
(
NS_WARN_IF
(
!
editorRect
.
mSucceeded
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleQueryCharPosition
NS_QUERY_EDITOR_RECT
failed
"
)
)
;
:
:
GetWindowRect
(
aWindow
-
>
GetWindowHandle
(
)
&
pCharPosition
-
>
rcDocument
)
;
}
else
{
nsIntRect
editorRectInWindow
=
LayoutDevicePixel
:
:
ToUntyped
(
editorRect
.
mReply
.
mRect
)
;
nsWindow
*
window
=
editorRect
.
mReply
.
mFocusedWidget
?
static_cast
<
nsWindow
*
>
(
editorRect
.
mReply
.
mFocusedWidget
)
:
aWindow
;
nsIntRect
editorRectInScreen
;
ResolveIMECaretPos
(
window
editorRectInWindow
nullptr
editorRectInScreen
)
;
:
:
SetRect
(
&
pCharPosition
-
>
rcDocument
editorRectInScreen
.
x
editorRectInScreen
.
y
editorRectInScreen
.
XMost
(
)
editorRectInScreen
.
YMost
(
)
)
;
}
*
oResult
=
TRUE
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleQueryCharPosition
SUCCEEDED
pCharPosition
=
{
pt
=
{
x
=
%
d
"
"
y
=
%
d
}
cLineHeight
=
%
d
rcDocument
=
{
left
=
%
d
top
=
%
d
right
=
%
d
"
"
bottom
=
%
d
}
}
"
pCharPosition
-
>
pt
.
x
pCharPosition
-
>
pt
.
y
pCharPosition
-
>
cLineHeight
pCharPosition
-
>
rcDocument
.
left
pCharPosition
-
>
rcDocument
.
top
pCharPosition
-
>
rcDocument
.
right
pCharPosition
-
>
rcDocument
.
bottom
)
)
;
return
true
;
}
bool
IMMHandler
:
:
HandleDocumentFeed
(
nsWindow
*
aWindow
LPARAM
lParam
LRESULT
*
oResult
)
{
*
oResult
=
0
;
RECONVERTSTRING
*
pReconv
=
reinterpret_cast
<
RECONVERTSTRING
*
>
(
lParam
)
;
nsIntPoint
point
(
0
0
)
;
bool
hasCompositionString
=
mIsComposing
&
&
ShouldDrawCompositionStringOurselves
(
)
;
int32_t
targetOffset
targetLength
;
if
(
!
hasCompositionString
)
{
Selection
&
selection
=
GetSelection
(
)
;
if
(
!
selection
.
EnsureValidSelection
(
aWindow
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleDocumentFeed
FAILED
due
to
"
"
Selection
:
:
EnsureValidSelection
(
)
failure
"
)
)
;
return
false
;
}
targetOffset
=
int32_t
(
selection
.
mOffset
)
;
targetLength
=
int32_t
(
selection
.
Length
(
)
)
;
}
else
{
targetOffset
=
int32_t
(
mCompositionStart
)
;
targetLength
=
int32_t
(
mCompositionString
.
Length
(
)
)
;
}
if
(
targetOffset
<
0
|
|
targetLength
<
0
|
|
targetOffset
+
targetLength
<
0
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleDocumentFeed
FAILED
due
to
the
selection
is
out
of
"
"
range
"
)
)
;
return
false
;
}
WidgetQueryContentEvent
textContent
(
true
NS_QUERY_TEXT_CONTENT
aWindow
)
;
textContent
.
InitForQueryTextContent
(
0
UINT32_MAX
)
;
aWindow
-
>
InitEvent
(
textContent
&
point
)
;
aWindow
-
>
DispatchWindowEvent
(
&
textContent
)
;
if
(
!
textContent
.
mSucceeded
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleDocumentFeed
FAILED
due
to
NS_QUERY_TEXT_CONTENT
"
"
failure
"
)
)
;
return
false
;
}
nsAutoString
str
(
textContent
.
mReply
.
mString
)
;
if
(
targetOffset
>
int32_t
(
str
.
Length
(
)
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleDocumentFeed
FAILED
due
to
the
caret
offset
is
invalid
"
)
)
;
return
false
;
}
int32_t
paragraphStart
=
str
.
RFind
(
"
"
false
targetOffset
-
1
)
+
1
;
int32_t
paragraphEnd
=
str
.
Find
(
"
\
r
"
false
targetOffset
+
targetLength
-
1
)
;
if
(
paragraphEnd
<
0
)
{
paragraphEnd
=
str
.
Length
(
)
;
}
nsDependentSubstring
paragraph
(
str
paragraphStart
paragraphEnd
-
paragraphStart
)
;
uint32_t
len
=
paragraph
.
Length
(
)
;
uint32_t
needSize
=
sizeof
(
RECONVERTSTRING
)
+
len
*
sizeof
(
WCHAR
)
;
if
(
!
pReconv
)
{
*
oResult
=
needSize
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleDocumentFeed
succeeded
result
=
%
ld
"
*
oResult
)
)
;
return
true
;
}
if
(
pReconv
-
>
dwSize
<
needSize
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleDocumentFeed
FAILED
pReconv
-
>
dwSize
=
%
ld
needSize
=
%
ld
"
pReconv
-
>
dwSize
needSize
)
)
;
return
false
;
}
pReconv
-
>
dwVersion
=
0
;
pReconv
-
>
dwStrLen
=
len
;
pReconv
-
>
dwStrOffset
=
sizeof
(
RECONVERTSTRING
)
;
if
(
hasCompositionString
)
{
pReconv
-
>
dwCompStrLen
=
targetLength
;
pReconv
-
>
dwCompStrOffset
=
(
targetOffset
-
paragraphStart
)
*
sizeof
(
WCHAR
)
;
uint32_t
offset
length
;
if
(
!
GetTargetClauseRange
(
&
offset
&
length
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
HandleDocumentFeed
FAILED
due
to
GetTargetClauseRange
(
)
"
"
failure
"
)
)
;
return
false
;
}
pReconv
-
>
dwTargetStrLen
=
length
;
pReconv
-
>
dwTargetStrOffset
=
(
offset
-
paragraphStart
)
*
sizeof
(
WCHAR
)
;
}
else
{
pReconv
-
>
dwTargetStrLen
=
targetLength
;
pReconv
-
>
dwTargetStrOffset
=
(
targetOffset
-
paragraphStart
)
*
sizeof
(
WCHAR
)
;
pReconv
-
>
dwCompStrLen
=
0
;
pReconv
-
>
dwCompStrOffset
=
pReconv
-
>
dwTargetStrOffset
;
}
*
oResult
=
needSize
;
:
:
CopyMemory
(
reinterpret_cast
<
LPVOID
>
(
lParam
+
sizeof
(
RECONVERTSTRING
)
)
paragraph
.
BeginReading
(
)
len
*
sizeof
(
WCHAR
)
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
HandleDocumentFeed
SUCCEEDED
pReconv
=
%
s
result
=
%
ld
"
GetReconvertStringLog
(
pReconv
)
.
get
(
)
*
oResult
)
)
;
return
true
;
}
bool
IMMHandler
:
:
CommitCompositionOnPreviousWindow
(
nsWindow
*
aWindow
)
{
if
(
!
mComposingWindow
|
|
mComposingWindow
=
=
aWindow
)
{
return
false
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CommitCompositionOnPreviousWindow
mIsComposing
=
%
s
"
"
mIsComposingOnPlugin
=
%
s
"
GetBoolName
(
mIsComposing
)
GetBoolName
(
mIsComposingOnPlugin
)
)
)
;
if
(
mIsComposing
)
{
IMEContext
context
(
mComposingWindow
)
;
NS_ASSERTION
(
context
.
IsValid
(
)
"
IME
context
must
be
valid
"
)
;
HandleEndComposition
(
mComposingWindow
)
;
return
true
;
}
return
mIsComposingOnPlugin
;
}
static
uint32_t
PlatformToNSAttr
(
uint8_t
aAttr
)
{
switch
(
aAttr
)
{
case
ATTR_INPUT_ERROR
:
case
ATTR_INPUT
:
return
NS_TEXTRANGE_RAWINPUT
;
case
ATTR_CONVERTED
:
return
NS_TEXTRANGE_CONVERTEDTEXT
;
case
ATTR_TARGET_NOTCONVERTED
:
return
NS_TEXTRANGE_SELECTEDRAWTEXT
;
case
ATTR_TARGET_CONVERTED
:
return
NS_TEXTRANGE_SELECTEDCONVERTEDTEXT
;
default
:
NS_ASSERTION
(
false
"
unknown
attribute
"
)
;
return
NS_TEXTRANGE_CARETPOSITION
;
}
}
static
const
char
*
GetRangeTypeName
(
uint32_t
aRangeType
)
{
switch
(
aRangeType
)
{
case
NS_TEXTRANGE_RAWINPUT
:
return
"
NS_TEXTRANGE_RAWINPUT
"
;
case
NS_TEXTRANGE_CONVERTEDTEXT
:
return
"
NS_TEXTRANGE_CONVERTEDTEXT
"
;
case
NS_TEXTRANGE_SELECTEDRAWTEXT
:
return
"
NS_TEXTRANGE_SELECTEDRAWTEXT
"
;
case
NS_TEXTRANGE_SELECTEDCONVERTEDTEXT
:
return
"
NS_TEXTRANGE_SELECTEDCONVERTEDTEXT
"
;
case
NS_TEXTRANGE_CARETPOSITION
:
return
"
NS_TEXTRANGE_CARETPOSITION
"
;
default
:
return
"
UNKNOWN
SELECTION
TYPE
!
!
"
;
}
}
void
IMMHandler
:
:
DispatchCompositionChangeEvent
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
NS_ASSERTION
(
mIsComposing
"
conflict
state
"
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
DispatchCompositionChangeEvent
"
)
)
;
if
(
!
ShouldDrawCompositionStringOurselves
(
)
)
{
SetIMERelatedWindowsPos
(
aWindow
aContext
)
;
return
;
}
nsRefPtr
<
nsWindow
>
kungFuDeathGrip
(
aWindow
)
;
nsIntPoint
point
(
0
0
)
;
WidgetCompositionEvent
event
(
true
NS_COMPOSITION_CHANGE
aWindow
)
;
aWindow
-
>
InitEvent
(
event
&
point
)
;
event
.
mRanges
=
CreateTextRangeArray
(
)
;
event
.
mData
=
mCompositionString
;
aWindow
-
>
DispatchWindowEvent
(
&
event
)
;
}
already_AddRefed
<
TextRangeArray
>
IMMHandler
:
:
CreateTextRangeArray
(
)
{
NS_ASSERTION
(
ShouldDrawCompositionStringOurselves
(
)
"
CreateTextRangeArray
is
called
when
we
don
'
t
need
to
fire
"
"
compositionchange
event
"
)
;
nsRefPtr
<
TextRangeArray
>
textRangeArray
=
new
TextRangeArray
(
)
;
TextRange
range
;
if
(
mCompositionString
.
IsEmpty
(
)
)
{
}
else
if
(
mClauseArray
.
Length
(
)
=
=
0
)
{
range
.
mStartOffset
=
0
;
range
.
mEndOffset
=
mCompositionString
.
Length
(
)
;
range
.
mRangeType
=
NS_TEXTRANGE_RAWINPUT
;
textRangeArray
-
>
AppendElement
(
range
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
mClauseLength
=
0
"
)
)
;
}
else
{
uint32_t
lastOffset
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mClauseArray
.
Length
(
)
-
1
;
i
+
+
)
{
uint32_t
current
=
mClauseArray
[
i
+
1
]
;
if
(
current
>
mCompositionString
.
Length
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
mClauseArray
[
%
ld
]
=
%
lu
.
"
"
This
is
larger
than
mCompositionString
.
Length
(
)
=
%
lu
"
i
+
1
current
mCompositionString
.
Length
(
)
)
)
;
current
=
int32_t
(
mCompositionString
.
Length
(
)
)
;
}
range
.
mRangeType
=
PlatformToNSAttr
(
mAttributeArray
[
lastOffset
]
)
;
range
.
mStartOffset
=
lastOffset
;
range
.
mEndOffset
=
current
;
textRangeArray
-
>
AppendElement
(
range
)
;
lastOffset
=
current
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
index
=
%
ld
rangeType
=
%
s
range
=
[
%
lu
-
%
lu
]
"
i
GetRangeTypeName
(
range
.
mRangeType
)
range
.
mStartOffset
range
.
mEndOffset
)
)
;
}
}
if
(
mCursorPosition
=
=
NO_IME_CARET
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
no
caret
"
)
)
;
return
textRangeArray
.
forget
(
)
;
}
uint32_t
cursor
=
static_cast
<
uint32_t
>
(
mCursorPosition
)
;
if
(
cursor
>
mCompositionString
.
Length
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
mCursorPosition
=
%
ld
.
"
"
This
is
larger
than
mCompositionString
.
Length
(
)
=
%
lu
"
mCursorPosition
mCompositionString
.
Length
(
)
)
)
;
cursor
=
mCompositionString
.
Length
(
)
;
}
const
TextRange
*
targetClause
=
textRangeArray
-
>
GetTargetClause
(
)
;
if
(
targetClause
&
&
cursor
>
=
targetClause
-
>
mStartOffset
&
&
cursor
<
=
targetClause
-
>
mEndOffset
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
no
caret
due
to
it
'
s
in
the
target
clause
"
)
)
;
return
textRangeArray
.
forget
(
)
;
}
range
.
mStartOffset
=
range
.
mEndOffset
=
cursor
;
range
.
mRangeType
=
NS_TEXTRANGE_CARETPOSITION
;
textRangeArray
-
>
AppendElement
(
range
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
CreateTextRangeArray
caret
position
=
%
ld
"
range
.
mStartOffset
)
)
;
return
textRangeArray
.
forget
(
)
;
}
void
IMMHandler
:
:
GetCompositionString
(
const
IMEContext
&
aContext
DWORD
aIndex
nsAString
&
aCompositionString
)
const
{
aCompositionString
.
Truncate
(
)
;
long
lRtn
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
aIndex
nullptr
0
)
;
if
(
lRtn
<
0
|
|
!
aCompositionString
.
SetLength
(
(
lRtn
/
sizeof
(
WCHAR
)
)
+
1
mozilla
:
:
fallible
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
GetCompositionString
FAILED
due
to
OOM
"
)
)
;
return
;
}
lRtn
=
:
:
ImmGetCompositionStringW
(
aContext
.
get
(
)
aIndex
(
LPVOID
)
aCompositionString
.
BeginWriting
(
)
lRtn
+
sizeof
(
WCHAR
)
)
;
aCompositionString
.
SetLength
(
lRtn
/
sizeof
(
WCHAR
)
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
GetCompositionString
succeeded
aCompositionString
=
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
aCompositionString
)
.
get
(
)
)
)
;
}
bool
IMMHandler
:
:
GetTargetClauseRange
(
uint32_t
*
aOffset
uint32_t
*
aLength
)
{
NS_ENSURE_TRUE
(
aOffset
false
)
;
NS_ENSURE_TRUE
(
mIsComposing
false
)
;
NS_ENSURE_TRUE
(
ShouldDrawCompositionStringOurselves
(
)
false
)
;
bool
found
=
false
;
*
aOffset
=
mCompositionStart
;
for
(
uint32_t
i
=
0
;
i
<
mAttributeArray
.
Length
(
)
;
i
+
+
)
{
if
(
mAttributeArray
[
i
]
=
=
ATTR_TARGET_NOTCONVERTED
|
|
mAttributeArray
[
i
]
=
=
ATTR_TARGET_CONVERTED
)
{
*
aOffset
=
mCompositionStart
+
i
;
found
=
true
;
break
;
}
}
if
(
!
aLength
)
{
return
true
;
}
if
(
!
found
)
{
*
aLength
=
mCompositionString
.
Length
(
)
;
return
true
;
}
uint32_t
offsetInComposition
=
*
aOffset
-
mCompositionStart
;
*
aLength
=
mCompositionString
.
Length
(
)
-
offsetInComposition
;
for
(
uint32_t
i
=
offsetInComposition
;
i
<
mAttributeArray
.
Length
(
)
;
i
+
+
)
{
if
(
mAttributeArray
[
i
]
!
=
ATTR_TARGET_NOTCONVERTED
&
&
mAttributeArray
[
i
]
!
=
ATTR_TARGET_CONVERTED
)
{
*
aLength
=
i
-
offsetInComposition
;
break
;
}
}
return
true
;
}
bool
IMMHandler
:
:
ConvertToANSIString
(
const
nsAFlatString
&
aStr
UINT
aCodePage
nsACString
&
aANSIStr
)
{
int
len
=
:
:
WideCharToMultiByte
(
aCodePage
0
(
LPCWSTR
)
aStr
.
get
(
)
aStr
.
Length
(
)
nullptr
0
nullptr
nullptr
)
;
NS_ENSURE_TRUE
(
len
>
=
0
false
)
;
if
(
!
aANSIStr
.
SetLength
(
len
mozilla
:
:
fallible
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
ConvertToANSIString
FAILED
due
to
OOM
"
)
)
;
return
false
;
}
:
:
WideCharToMultiByte
(
aCodePage
0
(
LPCWSTR
)
aStr
.
get
(
)
aStr
.
Length
(
)
(
LPSTR
)
aANSIStr
.
BeginWriting
(
)
len
nullptr
nullptr
)
;
return
true
;
}
bool
IMMHandler
:
:
GetCharacterRectOfSelectedTextAt
(
nsWindow
*
aWindow
uint32_t
aOffset
nsIntRect
&
aCharRect
WritingMode
*
aWritingMode
)
{
nsIntPoint
point
(
0
0
)
;
Selection
&
selection
=
GetSelection
(
)
;
if
(
!
selection
.
EnsureValidSelection
(
aWindow
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
GetCharacterRectOfSelectedTextAt
FAILED
due
to
"
"
Selection
:
:
EnsureValidSelection
(
)
failure
"
)
)
;
return
false
;
}
uint32_t
baseOffset
=
mIsComposing
?
mCompositionStart
:
selection
.
mOffset
;
CheckedInt
<
uint32_t
>
checkingOffset
=
CheckedInt
<
uint32_t
>
(
baseOffset
)
+
aOffset
;
if
(
NS_WARN_IF
(
!
checkingOffset
.
isValid
(
)
)
|
|
checkingOffset
.
value
(
)
=
=
UINT32_MAX
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
GetCharacterRectOfSelectedTextAt
FAILED
due
to
"
"
aOffset
is
too
large
(
aOffset
=
%
u
baseOffset
=
%
u
mIsComposing
=
%
s
)
"
aOffset
baseOffset
GetBoolName
(
mIsComposing
)
)
)
;
return
false
;
}
uint32_t
targetLength
=
mIsComposing
?
mCompositionString
.
Length
(
)
:
selection
.
Length
(
)
;
if
(
NS_WARN_IF
(
aOffset
>
targetLength
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
GetCharacterRectOfSelectedTextAt
FAILED
due
to
"
"
aOffset
is
too
large
(
aOffset
=
%
u
targetLength
=
%
u
mIsComposing
=
%
s
)
"
aOffset
targetLength
GetBoolName
(
mIsComposing
)
)
)
;
return
false
;
}
uint32_t
offset
=
checkingOffset
.
value
(
)
;
uint32_t
caretOffset
=
UINT32_MAX
;
if
(
selection
.
Collapsed
(
)
)
{
if
(
mIsComposing
)
{
if
(
mCursorPosition
!
=
NO_IME_CARET
)
{
MOZ_ASSERT
(
mCursorPosition
>
=
0
)
;
caretOffset
=
mCompositionStart
+
mCursorPosition
;
}
else
if
(
!
ShouldDrawCompositionStringOurselves
(
)
|
|
mCompositionString
.
IsEmpty
(
)
)
{
caretOffset
=
mCompositionStart
;
}
}
else
{
caretOffset
=
selection
.
mOffset
;
}
}
if
(
offset
!
=
caretOffset
)
{
WidgetQueryContentEvent
charRect
(
true
NS_QUERY_TEXT_RECT
aWindow
)
;
charRect
.
InitForQueryTextRect
(
offset
1
)
;
aWindow
-
>
InitEvent
(
charRect
&
point
)
;
aWindow
-
>
DispatchWindowEvent
(
&
charRect
)
;
if
(
charRect
.
mSucceeded
)
{
aCharRect
=
LayoutDevicePixel
:
:
ToUntyped
(
charRect
.
mReply
.
mRect
)
;
if
(
aWritingMode
)
{
*
aWritingMode
=
charRect
.
GetWritingMode
(
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Debug
(
"
IMM
:
GetCharacterRectOfSelectedTextAt
Succeeded
aOffset
=
%
u
"
"
aCharRect
=
{
x
:
%
ld
y
:
%
ld
width
:
%
ld
height
:
%
ld
}
"
"
charRect
.
GetWritingMode
(
)
=
%
s
"
aOffset
aCharRect
.
x
aCharRect
.
y
aCharRect
.
width
aCharRect
.
height
GetWritingModeName
(
charRect
.
GetWritingMode
(
)
)
.
get
(
)
)
)
;
return
true
;
}
}
return
GetCaretRect
(
aWindow
aCharRect
aWritingMode
)
;
}
bool
IMMHandler
:
:
GetCaretRect
(
nsWindow
*
aWindow
nsIntRect
&
aCaretRect
WritingMode
*
aWritingMode
)
{
nsIntPoint
point
(
0
0
)
;
Selection
&
selection
=
GetSelection
(
)
;
if
(
!
selection
.
EnsureValidSelection
(
aWindow
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
GetCaretRect
FAILED
due
to
"
"
Selection
:
:
EnsureValidSelection
(
)
failure
"
)
)
;
return
false
;
}
WidgetQueryContentEvent
caretRect
(
true
NS_QUERY_CARET_RECT
aWindow
)
;
caretRect
.
InitForQueryCaretRect
(
selection
.
mOffset
)
;
aWindow
-
>
InitEvent
(
caretRect
&
point
)
;
aWindow
-
>
DispatchWindowEvent
(
&
caretRect
)
;
if
(
!
caretRect
.
mSucceeded
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
GetCaretRect
FAILED
due
to
NS_QUERY_CARET_RECT
failure
"
)
)
;
return
false
;
}
aCaretRect
=
LayoutDevicePixel
:
:
ToUntyped
(
caretRect
.
mReply
.
mRect
)
;
if
(
aWritingMode
)
{
*
aWritingMode
=
caretRect
.
GetWritingMode
(
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
GetCaretRect
SUCCEEDED
"
"
aCaretRect
=
{
x
:
%
ld
y
:
%
ld
width
:
%
ld
height
:
%
ld
}
"
"
caretRect
.
GetWritingMode
(
)
=
%
s
"
aCaretRect
.
x
aCaretRect
.
y
aCaretRect
.
width
aCaretRect
.
height
GetWritingModeName
(
caretRect
.
GetWritingMode
(
)
)
.
get
(
)
)
)
;
return
true
;
}
bool
IMMHandler
:
:
SetIMERelatedWindowsPos
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
nsIntRect
r
;
WritingMode
writingMode
;
bool
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
0
r
&
writingMode
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
nsWindow
*
toplevelWindow
=
aWindow
-
>
GetTopLevelWindow
(
false
)
;
nsIntRect
firstSelectedCharRect
;
ResolveIMECaretPos
(
toplevelWindow
r
aWindow
firstSelectedCharRect
)
;
nsIntRect
caretRect
(
firstSelectedCharRect
)
;
if
(
GetCaretRect
(
aWindow
r
)
)
{
ResolveIMECaretPos
(
toplevelWindow
r
aWindow
caretRect
)
;
}
else
{
NS_WARNING
(
"
failed
to
get
caret
rect
"
)
;
caretRect
.
width
=
1
;
}
if
(
!
mNativeCaretIsCreated
)
{
mNativeCaretIsCreated
=
:
:
CreateCaret
(
aWindow
-
>
GetWindowHandle
(
)
nullptr
caretRect
.
width
caretRect
.
height
)
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
SetIMERelatedWindowsPos
mNativeCaretIsCreated
=
%
s
"
"
width
=
%
ld
height
=
%
ld
"
GetBoolName
(
mNativeCaretIsCreated
)
caretRect
.
width
caretRect
.
height
)
)
;
}
:
:
SetCaretPos
(
caretRect
.
x
caretRect
.
y
)
;
if
(
ShouldDrawCompositionStringOurselves
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
SetIMERelatedWindowsPos
Set
candidate
window
"
)
)
;
nsIntRect
firstTargetCharRect
lastTargetCharRect
;
if
(
mIsComposing
&
&
!
mCompositionString
.
IsEmpty
(
)
)
{
uint32_t
offset
length
;
if
(
!
GetTargetClauseRange
(
&
offset
&
length
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
SetIMERelatedWindowsPos
FAILED
due
to
"
"
GetTargetClauseRange
(
)
failure
"
)
)
;
return
false
;
}
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
offset
-
mCompositionStart
firstTargetCharRect
&
writingMode
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
if
(
length
)
{
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
offset
+
length
-
1
-
mCompositionStart
lastTargetCharRect
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
}
else
{
lastTargetCharRect
=
firstTargetCharRect
;
}
}
else
{
ret
=
GetCharacterRectOfSelectedTextAt
(
aWindow
0
firstTargetCharRect
&
writingMode
)
;
NS_ENSURE_TRUE
(
ret
false
)
;
lastTargetCharRect
=
firstTargetCharRect
;
}
ResolveIMECaretPos
(
toplevelWindow
firstTargetCharRect
aWindow
firstTargetCharRect
)
;
ResolveIMECaretPos
(
toplevelWindow
lastTargetCharRect
aWindow
lastTargetCharRect
)
;
nsIntRect
targetClauseRect
;
targetClauseRect
.
UnionRect
(
firstTargetCharRect
lastTargetCharRect
)
;
CANDIDATEFORM
candForm
;
candForm
.
dwIndex
=
0
;
if
(
!
writingMode
.
IsVertical
(
)
|
|
IsVerticalWritingSupported
(
)
)
{
candForm
.
dwStyle
=
CFS_EXCLUDE
;
candForm
.
rcArea
.
left
=
targetClauseRect
.
x
;
candForm
.
rcArea
.
right
=
targetClauseRect
.
XMost
(
)
;
candForm
.
rcArea
.
top
=
targetClauseRect
.
y
;
candForm
.
rcArea
.
bottom
=
targetClauseRect
.
YMost
(
)
;
if
(
!
writingMode
.
IsVertical
(
)
)
{
candForm
.
ptCurrentPos
.
x
=
firstTargetCharRect
.
x
;
candForm
.
ptCurrentPos
.
y
=
firstTargetCharRect
.
y
;
}
else
if
(
writingMode
.
IsVerticalRL
(
)
)
{
candForm
.
ptCurrentPos
.
x
=
targetClauseRect
.
x
;
candForm
.
ptCurrentPos
.
y
=
targetClauseRect
.
y
;
}
else
{
MOZ_ASSERT
(
writingMode
.
IsVerticalLR
(
)
"
Did
we
miss
some
causes
?
"
)
;
candForm
.
ptCurrentPos
.
x
=
targetClauseRect
.
XMost
(
)
;
candForm
.
ptCurrentPos
.
y
=
targetClauseRect
.
y
;
}
}
else
{
candForm
.
dwStyle
=
CFS_CANDIDATEPOS
;
candForm
.
ptCurrentPos
.
x
=
targetClauseRect
.
x
;
candForm
.
ptCurrentPos
.
y
=
targetClauseRect
.
YMost
(
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
SetIMERelatedWindowsPos
Calling
ImmSetCandidateWindow
(
)
.
.
.
"
"
ptCurrentPos
=
{
x
=
%
d
y
=
%
d
}
"
"
rcArea
=
{
left
=
%
d
top
=
%
d
right
=
%
d
bottom
=
%
d
}
"
"
writingMode
=
%
s
"
candForm
.
ptCurrentPos
.
x
candForm
.
ptCurrentPos
.
y
candForm
.
rcArea
.
left
candForm
.
rcArea
.
top
candForm
.
rcArea
.
right
candForm
.
rcArea
.
bottom
GetWritingModeName
(
writingMode
)
.
get
(
)
)
)
;
:
:
ImmSetCandidateWindow
(
aContext
.
get
(
)
&
candForm
)
;
}
else
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
SetIMERelatedWindowsPos
Set
composition
window
"
)
)
;
COMPOSITIONFORM
compForm
;
compForm
.
dwStyle
=
CFS_POINT
;
compForm
.
ptCurrentPos
.
x
=
!
writingMode
.
IsVerticalLR
(
)
?
firstSelectedCharRect
.
x
:
firstSelectedCharRect
.
XMost
(
)
;
compForm
.
ptCurrentPos
.
y
=
firstSelectedCharRect
.
y
;
:
:
ImmSetCompositionWindow
(
aContext
.
get
(
)
&
compForm
)
;
}
return
true
;
}
void
IMMHandler
:
:
SetIMERelatedWindowsPosOnPlugin
(
nsWindow
*
aWindow
const
IMEContext
&
aContext
)
{
WidgetQueryContentEvent
editorRectEvent
(
true
NS_QUERY_EDITOR_RECT
aWindow
)
;
aWindow
-
>
InitEvent
(
editorRectEvent
)
;
aWindow
-
>
DispatchWindowEvent
(
&
editorRectEvent
)
;
if
(
!
editorRectEvent
.
mSucceeded
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
SetIMERelatedWindowsPosOnPlugin
"
"
FAILED
due
to
NS_QUERY_EDITOR_RECT
failure
"
)
)
;
return
;
}
nsWindow
*
toplevelWindow
=
aWindow
-
>
GetTopLevelWindow
(
false
)
;
LayoutDeviceIntRect
pluginRectInScreen
=
editorRectEvent
.
mReply
.
mRect
+
toplevelWindow
-
>
WidgetToScreenOffset
(
)
;
nsIntRect
winRectInScreen
;
aWindow
-
>
GetClientBounds
(
winRectInScreen
)
;
winRectInScreen
.
width
-
-
;
winRectInScreen
.
height
-
-
;
nsIntRect
clippedPluginRect
;
clippedPluginRect
.
x
=
std
:
:
min
(
std
:
:
max
(
pluginRectInScreen
.
x
winRectInScreen
.
x
)
winRectInScreen
.
XMost
(
)
)
;
clippedPluginRect
.
y
=
std
:
:
min
(
std
:
:
max
(
pluginRectInScreen
.
y
winRectInScreen
.
y
)
winRectInScreen
.
YMost
(
)
)
;
int32_t
xMost
=
std
:
:
min
(
pluginRectInScreen
.
XMost
(
)
winRectInScreen
.
XMost
(
)
)
;
int32_t
yMost
=
std
:
:
min
(
pluginRectInScreen
.
YMost
(
)
winRectInScreen
.
YMost
(
)
)
;
clippedPluginRect
.
width
=
std
:
:
max
(
0
xMost
-
clippedPluginRect
.
x
)
;
clippedPluginRect
.
height
=
std
:
:
max
(
0
yMost
-
clippedPluginRect
.
y
)
;
clippedPluginRect
-
=
aWindow
-
>
WidgetToScreenOffsetUntyped
(
)
;
if
(
mNativeCaretIsCreated
)
{
:
:
DestroyCaret
(
)
;
}
mNativeCaretIsCreated
=
:
:
CreateCaret
(
aWindow
-
>
GetWindowHandle
(
)
nullptr
clippedPluginRect
.
width
clippedPluginRect
.
height
)
;
:
:
SetCaretPos
(
clippedPluginRect
.
x
clippedPluginRect
.
y
)
;
COMPOSITIONFORM
compForm
;
compForm
.
dwStyle
=
CFS_POINT
;
compForm
.
ptCurrentPos
.
x
=
clippedPluginRect
.
BottomLeft
(
)
.
x
;
compForm
.
ptCurrentPos
.
y
=
clippedPluginRect
.
BottomLeft
(
)
.
y
;
if
(
!
:
:
ImmSetCompositionWindow
(
aContext
.
get
(
)
&
compForm
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
SetIMERelatedWindowsPosOnPlugin
"
"
FAILED
due
to
:
:
ImmSetCompositionWindow
(
)
failure
"
)
)
;
return
;
}
}
void
IMMHandler
:
:
ResolveIMECaretPos
(
nsIWidget
*
aReferenceWidget
nsIntRect
&
aCursorRect
nsIWidget
*
aNewOriginWidget
nsIntRect
&
aOutRect
)
{
aOutRect
=
aCursorRect
;
if
(
aReferenceWidget
=
=
aNewOriginWidget
)
return
;
if
(
aReferenceWidget
)
aOutRect
.
MoveBy
(
aReferenceWidget
-
>
WidgetToScreenOffsetUntyped
(
)
)
;
if
(
aNewOriginWidget
)
aOutRect
.
MoveBy
(
-
aNewOriginWidget
-
>
WidgetToScreenOffsetUntyped
(
)
)
;
}
static
void
SetHorizontalFontToLogFont
(
const
nsAString
&
aFontFace
LOGFONTW
&
aLogFont
)
{
aLogFont
.
lfEscapement
=
aLogFont
.
lfOrientation
=
0
;
if
(
NS_WARN_IF
(
aFontFace
.
Length
(
)
>
LF_FACESIZE
-
1
)
)
{
memcpy
(
aLogFont
.
lfFaceName
L
"
System
"
sizeof
(
L
"
System
"
)
)
;
return
;
}
memcpy
(
aLogFont
.
lfFaceName
aFontFace
.
BeginReading
(
)
aFontFace
.
Length
(
)
*
sizeof
(
wchar_t
)
)
;
aLogFont
.
lfFaceName
[
aFontFace
.
Length
(
)
]
=
0
;
}
static
void
SetVerticalFontToLogFont
(
const
nsAString
&
aFontFace
LOGFONTW
&
aLogFont
)
{
aLogFont
.
lfEscapement
=
aLogFont
.
lfOrientation
=
2700
;
if
(
NS_WARN_IF
(
aFontFace
.
Length
(
)
>
LF_FACESIZE
-
2
)
)
{
memcpy
(
aLogFont
.
lfFaceName
L
"
System
"
sizeof
(
L
"
System
"
)
)
;
return
;
}
aLogFont
.
lfFaceName
[
0
]
=
'
'
;
memcpy
(
&
aLogFont
.
lfFaceName
[
1
]
aFontFace
.
BeginReading
(
)
aFontFace
.
Length
(
)
*
sizeof
(
wchar_t
)
)
;
aLogFont
.
lfFaceName
[
aFontFace
.
Length
(
)
+
1
]
=
0
;
}
void
IMMHandler
:
:
AdjustCompositionFont
(
const
IMEContext
&
aContext
const
WritingMode
&
aWritingMode
bool
aForceUpdate
)
{
static
bool
sCompositionFontsInitialized
=
false
;
static
nsString
sCompositionFont
=
Preferences
:
:
GetString
(
"
intl
.
imm
.
composition_font
"
)
;
bool
setCompositionFontForcibly
=
aForceUpdate
|
|
(
!
sCompositionFontsInitialized
&
&
!
sCompositionFont
.
IsEmpty
(
)
)
;
static
WritingMode
sCurrentWritingMode
;
static
nsString
sCurrentIMEName
;
if
(
!
setCompositionFontForcibly
&
&
sWritingModeOfCompositionFont
=
=
aWritingMode
&
&
sCurrentIMEName
=
=
sIMEName
)
{
return
;
}
if
(
!
sCompositionFontsInitialized
)
{
sCompositionFontsInitialized
=
true
;
if
(
sCompositionFont
.
IsEmpty
(
)
|
|
sCompositionFont
.
Length
(
)
>
LF_FACESIZE
-
1
|
|
sCompositionFont
[
0
]
=
=
'
'
)
{
LOGFONTW
defaultLogFont
;
if
(
NS_WARN_IF
(
!
:
:
ImmGetCompositionFont
(
aContext
.
get
(
)
&
defaultLogFont
)
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
AdjustCompositionFont
:
:
ImmGetCompositionFont
(
)
failed
"
)
)
;
sCompositionFont
.
AssignLiteral
(
"
System
"
)
;
}
else
{
sCompositionFont
.
Assign
(
defaultLogFont
.
lfFaceName
)
;
}
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
AdjustCompositionFont
sCompositionFont
=
\
"
%
s
\
"
is
initialized
"
NS_ConvertUTF16toUTF8
(
sCompositionFont
)
.
get
(
)
)
)
;
}
static
nsString
sCompositionFontForJapanist2003
;
if
(
IsJapanist2003Active
(
)
&
&
sCompositionFontForJapanist2003
.
IsEmpty
(
)
)
{
const
char
*
kCompositionFontForJapanist2003
=
"
intl
.
imm
.
composition_font
.
japanist_2003
"
;
sCompositionFontForJapanist2003
=
Preferences
:
:
GetString
(
kCompositionFontForJapanist2003
)
;
if
(
sCompositionFontForJapanist2003
.
IsEmpty
(
)
|
|
sCompositionFontForJapanist2003
.
Length
(
)
>
LF_FACESIZE
-
2
|
|
sCompositionFontForJapanist2003
[
0
]
=
=
'
'
)
{
sCompositionFontForJapanist2003
.
AssignLiteral
(
"
MS
PGothic
"
)
;
}
}
sWritingModeOfCompositionFont
=
aWritingMode
;
sCurrentIMEName
=
sIMEName
;
LOGFONTW
logFont
;
memset
(
&
logFont
0
sizeof
(
logFont
)
)
;
if
(
!
:
:
ImmGetCompositionFont
(
aContext
.
get
(
)
&
logFont
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
AdjustCompositionFont
:
:
ImmGetCompositionFont
(
)
failed
"
)
)
;
logFont
.
lfFaceName
[
0
]
=
0
;
}
logFont
.
lfWidth
=
0
;
logFont
.
lfWeight
=
FW_DONTCARE
;
logFont
.
lfOutPrecision
=
OUT_DEFAULT_PRECIS
;
logFont
.
lfClipPrecision
=
CLIP_DEFAULT_PRECIS
;
logFont
.
lfPitchAndFamily
=
DEFAULT_PITCH
;
if
(
!
mIsComposingOnPlugin
&
&
aWritingMode
.
IsVertical
(
)
&
&
IsVerticalWritingSupported
(
)
)
{
SetVerticalFontToLogFont
(
IsJapanist2003Active
(
)
?
sCompositionFontForJapanist2003
:
sCompositionFont
logFont
)
;
}
else
{
SetHorizontalFontToLogFont
(
IsJapanist2003Active
(
)
?
sCompositionFontForJapanist2003
:
sCompositionFont
logFont
)
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Warning
(
"
IMM
:
AdjustCompositionFont
calling
:
:
ImmSetCompositionFont
(
\
"
%
s
\
"
)
"
NS_ConvertUTF16toUTF8
(
nsDependentString
(
logFont
.
lfFaceName
)
)
.
get
(
)
)
)
;
:
:
ImmSetCompositionFontW
(
aContext
.
get
(
)
&
logFont
)
;
}
nsresult
IMMHandler
:
:
OnMouseButtonEvent
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
)
{
if
(
!
gIMMHandler
)
{
return
NS_OK
;
}
if
(
!
sWM_MSIME_MOUSE
|
|
!
IsComposingOnOurEditor
(
)
|
|
!
ShouldDrawCompositionStringOurselves
(
)
)
{
return
NS_OK
;
}
if
(
aIMENotification
.
mMouseButtonEventData
.
mEventMessage
!
=
NS_MOUSE_BUTTON_DOWN
)
{
return
NS_OK
;
}
uint32_t
compositionStart
=
gIMMHandler
-
>
mCompositionStart
;
uint32_t
compositionEnd
=
compositionStart
+
gIMMHandler
-
>
mCompositionString
.
Length
(
)
;
if
(
aIMENotification
.
mMouseButtonEventData
.
mOffset
<
compositionStart
|
|
aIMENotification
.
mMouseButtonEventData
.
mOffset
>
=
compositionEnd
)
{
return
NS_OK
;
}
BYTE
button
;
switch
(
aIMENotification
.
mMouseButtonEventData
.
mButton
)
{
case
WidgetMouseEventBase
:
:
eLeftButton
:
button
=
IMEMOUSE_LDOWN
;
break
;
case
WidgetMouseEventBase
:
:
eMiddleButton
:
button
=
IMEMOUSE_MDOWN
;
break
;
case
WidgetMouseEventBase
:
:
eRightButton
:
button
=
IMEMOUSE_RDOWN
;
break
;
default
:
return
NS_OK
;
}
nsIntPoint
cursorPos
=
aIMENotification
.
mMouseButtonEventData
.
mCursorPos
.
AsIntPoint
(
)
;
nsIntRect
charRect
=
aIMENotification
.
mMouseButtonEventData
.
mCharRect
.
AsIntRect
(
)
;
int32_t
cursorXInChar
=
cursorPos
.
x
-
charRect
.
x
;
int
positioning
=
1
;
if
(
charRect
.
width
>
0
)
{
positioning
=
cursorXInChar
*
4
/
charRect
.
width
;
positioning
=
(
positioning
+
2
)
%
4
;
}
int
offset
=
aIMENotification
.
mMouseButtonEventData
.
mOffset
-
compositionStart
;
if
(
positioning
<
2
)
{
offset
+
+
;
}
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnMouseButtonEvent
x
y
=
%
ld
%
ld
offset
=
%
ld
positioning
=
%
ld
"
cursorPos
.
x
cursorPos
.
y
offset
positioning
)
)
;
HWND
imeWnd
=
:
:
ImmGetDefaultIMEWnd
(
aWindow
-
>
GetWindowHandle
(
)
)
;
IMEContext
context
(
aWindow
)
;
if
(
:
:
SendMessageW
(
imeWnd
sWM_MSIME_MOUSE
MAKELONG
(
MAKEWORD
(
button
positioning
)
offset
)
(
LPARAM
)
context
.
get
(
)
)
=
=
1
)
{
return
NS_SUCCESS_EVENT_CONSUMED
;
}
return
NS_OK
;
}
bool
IMMHandler
:
:
OnKeyDownEvent
(
nsWindow
*
aWindow
WPARAM
wParam
LPARAM
lParam
MSGResult
&
aResult
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
OnKeyDownEvent
hWnd
=
%
08x
wParam
=
%
08x
lParam
=
%
08x
"
aWindow
-
>
GetWindowHandle
(
)
wParam
lParam
)
)
;
aResult
.
mConsumed
=
false
;
switch
(
wParam
)
{
case
VK_TAB
:
case
VK_PRIOR
:
case
VK_NEXT
:
case
VK_END
:
case
VK_HOME
:
case
VK_LEFT
:
case
VK_UP
:
case
VK_RIGHT
:
case
VK_DOWN
:
if
(
IsComposingOnOurEditor
(
)
)
{
CancelComposition
(
aWindow
false
)
;
}
return
false
;
default
:
return
false
;
}
}
bool
IMMHandler
:
:
Selection
:
:
IsValid
(
)
const
{
if
(
!
mIsValid
|
|
NS_WARN_IF
(
mOffset
=
=
UINT32_MAX
)
)
{
return
false
;
}
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
mOffset
)
+
Length
(
)
;
return
endOffset
.
isValid
(
)
;
}
bool
IMMHandler
:
:
Selection
:
:
Update
(
const
IMENotification
&
aIMENotification
)
{
mOffset
=
aIMENotification
.
mSelectionChangeData
.
mOffset
;
mString
=
aIMENotification
.
mSelectionChangeData
.
String
(
)
;
mWritingMode
=
aIMENotification
.
mSelectionChangeData
.
GetWritingMode
(
)
;
mIsValid
=
true
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
Selection
:
:
Update
aIMENotification
=
{
mSelectionChangeData
=
{
"
"
mOffset
=
%
u
mLength
=
%
u
GetWritingMode
(
)
=
%
s
}
}
"
mOffset
mString
.
Length
(
)
GetWritingModeName
(
mWritingMode
)
.
get
(
)
)
)
;
if
(
!
IsValid
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
Selection
:
:
Update
FAILED
due
to
invalid
range
"
)
)
;
Clear
(
)
;
return
false
;
}
return
true
;
}
bool
IMMHandler
:
:
Selection
:
:
Init
(
nsWindow
*
aWindow
)
{
Clear
(
)
;
WidgetQueryContentEvent
selection
(
true
NS_QUERY_SELECTED_TEXT
aWindow
)
;
nsIntPoint
point
(
0
0
)
;
aWindow
-
>
InitEvent
(
selection
&
point
)
;
aWindow
-
>
DispatchWindowEvent
(
&
selection
)
;
if
(
NS_WARN_IF
(
!
selection
.
mSucceeded
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
Selection
:
:
Init
FAILED
due
to
NS_QUERY_SELECTED_TEXT
"
"
failure
"
)
)
;
return
false
;
}
if
(
aWindow
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
Selection
:
:
Init
FAILED
due
to
the
widget
destroyed
"
)
)
;
return
false
;
}
mOffset
=
selection
.
mReply
.
mOffset
;
mString
=
selection
.
mReply
.
mString
;
mWritingMode
=
selection
.
GetWritingMode
(
)
;
mIsValid
=
true
;
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Info
(
"
IMM
:
Selection
:
:
Init
selection
=
{
mReply
=
{
mOffset
=
%
u
"
"
mString
.
Length
(
)
=
%
u
mWritingMode
=
%
s
}
}
"
mOffset
mString
.
Length
(
)
GetWritingModeName
(
mWritingMode
)
.
get
(
)
)
)
;
if
(
!
IsValid
(
)
)
{
MOZ_LOG
(
gIMMLog
LogLevel
:
:
Error
(
"
IMM
:
Selection
:
:
Init
FAILED
due
to
invalid
range
"
)
)
;
Clear
(
)
;
return
false
;
}
return
true
;
}
bool
IMMHandler
:
:
Selection
:
:
EnsureValidSelection
(
nsWindow
*
aWindow
)
{
if
(
IsValid
(
)
)
{
return
true
;
}
return
Init
(
aWindow
)
;
}
}
}
