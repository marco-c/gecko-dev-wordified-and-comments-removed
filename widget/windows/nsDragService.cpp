#
include
<
ole2
.
h
>
#
include
<
oleidl
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
shellapi
.
h
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsDragService
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsDataObj
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsNativeDragTarget
.
h
"
#
include
"
nsNativeDragSource
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsDataObjCollection
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
widget
;
nsDragService
:
:
nsDragService
(
)
:
mDataObject
(
nullptr
)
mSentLocalDropEvent
(
false
)
{
}
nsDragService
:
:
~
nsDragService
(
)
{
NS_IF_RELEASE
(
mDataObject
)
;
}
bool
nsDragService
:
:
CreateDragImage
(
nsINode
*
aDOMNode
const
Maybe
<
CSSIntRegion
>
&
aRegion
SHDRAGIMAGE
*
psdi
)
{
if
(
!
psdi
)
return
false
;
memset
(
psdi
0
sizeof
(
SHDRAGIMAGE
)
)
;
if
(
!
aDOMNode
)
return
false
;
LayoutDeviceIntRect
dragRect
;
RefPtr
<
SourceSurface
>
surface
;
nsPresContext
*
pc
;
DrawDrag
(
aDOMNode
aRegion
mScreenPosition
&
dragRect
&
surface
&
pc
)
;
if
(
!
surface
)
return
false
;
uint32_t
bmWidth
=
dragRect
.
Width
(
)
bmHeight
=
dragRect
.
Height
(
)
;
if
(
bmWidth
=
=
0
|
|
bmHeight
=
=
0
)
return
false
;
psdi
-
>
crColorKey
=
CLR_NONE
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
IntSize
(
bmWidth
bmHeight
)
SurfaceFormat
:
:
B8G8R8A8
)
;
NS_ENSURE_TRUE
(
dataSurface
false
)
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ_WRITE
&
map
)
)
{
return
false
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
map
.
mData
dataSurface
-
>
GetSize
(
)
map
.
mStride
dataSurface
-
>
GetFormat
(
)
)
;
if
(
!
dt
)
{
dataSurface
-
>
Unmap
(
)
;
return
false
;
}
dt
-
>
DrawSurface
(
surface
Rect
(
0
0
dataSurface
-
>
GetSize
(
)
.
width
dataSurface
-
>
GetSize
(
)
.
height
)
Rect
(
0
0
surface
-
>
GetSize
(
)
.
width
surface
-
>
GetSize
(
)
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
dt
-
>
Flush
(
)
;
BITMAPV5HEADER
bmih
;
memset
(
(
void
*
)
&
bmih
0
sizeof
(
BITMAPV5HEADER
)
)
;
bmih
.
bV5Size
=
sizeof
(
BITMAPV5HEADER
)
;
bmih
.
bV5Width
=
bmWidth
;
bmih
.
bV5Height
=
-
(
int32_t
)
bmHeight
;
bmih
.
bV5Planes
=
1
;
bmih
.
bV5BitCount
=
32
;
bmih
.
bV5Compression
=
BI_BITFIELDS
;
bmih
.
bV5RedMask
=
0x00FF0000
;
bmih
.
bV5GreenMask
=
0x0000FF00
;
bmih
.
bV5BlueMask
=
0x000000FF
;
bmih
.
bV5AlphaMask
=
0xFF000000
;
HDC
hdcSrc
=
CreateCompatibleDC
(
nullptr
)
;
void
*
lpBits
=
nullptr
;
if
(
hdcSrc
)
{
psdi
-
>
hbmpDragImage
=
:
:
CreateDIBSection
(
hdcSrc
(
BITMAPINFO
*
)
&
bmih
DIB_RGB_COLORS
(
void
*
*
)
&
lpBits
nullptr
0
)
;
if
(
psdi
-
>
hbmpDragImage
&
&
lpBits
)
{
CopySurfaceDataToPackedArray
(
map
.
mData
static_cast
<
uint8_t
*
>
(
lpBits
)
dataSurface
-
>
GetSize
(
)
map
.
mStride
BytesPerPixel
(
dataSurface
-
>
GetFormat
(
)
)
)
;
}
psdi
-
>
sizeDragImage
.
cx
=
bmWidth
;
psdi
-
>
sizeDragImage
.
cy
=
bmHeight
;
LayoutDeviceIntPoint
screenPoint
=
ConvertToUnscaledDevPixels
(
pc
mScreenPosition
)
;
psdi
-
>
ptOffset
.
x
=
screenPoint
.
x
-
dragRect
.
X
(
)
;
psdi
-
>
ptOffset
.
y
=
screenPoint
.
y
-
dragRect
.
Y
(
)
;
DeleteDC
(
hdcSrc
)
;
}
dataSurface
-
>
Unmap
(
)
;
return
psdi
-
>
hbmpDragImage
!
=
nullptr
;
}
nsresult
nsDragService
:
:
InvokeDragSessionImpl
(
nsIArray
*
anArrayTransferables
const
Maybe
<
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
{
nsIURI
*
uri
=
nullptr
;
nsCOMPtr
<
nsIDocument
>
doc
(
mSourceDocument
)
;
if
(
doc
)
{
uri
=
doc
-
>
GetDocumentURI
(
)
;
}
uint32_t
numItemsToDrag
=
0
;
nsresult
rv
=
anArrayTransferables
-
>
GetLength
(
&
numItemsToDrag
)
;
if
(
!
numItemsToDrag
)
return
NS_ERROR_FAILURE
;
RefPtr
<
IDataObject
>
itemToDrag
;
if
(
numItemsToDrag
>
1
)
{
nsDataObjCollection
*
dataObjCollection
=
new
nsDataObjCollection
(
)
;
if
(
!
dataObjCollection
)
return
NS_ERROR_OUT_OF_MEMORY
;
itemToDrag
=
dataObjCollection
;
for
(
uint32_t
i
=
0
;
i
<
numItemsToDrag
;
+
+
i
)
{
nsCOMPtr
<
nsITransferable
>
trans
=
do_QueryElementAt
(
anArrayTransferables
i
)
;
if
(
trans
)
{
RefPtr
<
IDataObject
>
dataObj
;
rv
=
nsClipboard
:
:
CreateNativeDataObject
(
trans
getter_AddRefs
(
dataObj
)
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsClipboard
:
:
SetupNativeDataObject
(
trans
dataObjCollection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
dataObjCollection
-
>
AddDataObject
(
dataObj
)
;
}
}
}
else
{
nsCOMPtr
<
nsITransferable
>
trans
=
do_QueryElementAt
(
anArrayTransferables
0
)
;
if
(
trans
)
{
rv
=
nsClipboard
:
:
CreateNativeDataObject
(
trans
getter_AddRefs
(
itemToDrag
)
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
IDragSourceHelper
*
pdsh
;
if
(
SUCCEEDED
(
CoCreateInstance
(
CLSID_DragDropHelper
nullptr
CLSCTX_INPROC_SERVER
IID_IDragSourceHelper
(
void
*
*
)
&
pdsh
)
)
)
{
SHDRAGIMAGE
sdi
;
if
(
CreateDragImage
(
mSourceNode
aRegion
&
sdi
)
)
{
if
(
FAILED
(
pdsh
-
>
InitializeFromBitmap
(
&
sdi
itemToDrag
)
)
)
DeleteObject
(
sdi
.
hbmpDragImage
)
;
}
pdsh
-
>
Release
(
)
;
}
return
StartInvokingDragSession
(
itemToDrag
aActionType
)
;
}
static
bool
LayoutDevicePointToCSSPoint
(
const
LayoutDevicePoint
&
aDevPos
CSSPoint
&
aCSSPos
)
{
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
!
screenMgr
)
{
return
false
;
}
nsCOMPtr
<
nsIScreen
>
screen
;
screenMgr
-
>
ScreenForRect
(
NSToIntRound
(
aDevPos
.
x
)
NSToIntRound
(
aDevPos
.
y
)
1
1
getter_AddRefs
(
screen
)
)
;
if
(
!
screen
)
{
return
false
;
}
int32_t
w
h
;
LayoutDeviceIntPoint
screenOriginDev
;
screen
-
>
GetRect
(
&
screenOriginDev
.
x
&
screenOriginDev
.
y
&
w
&
h
)
;
double
scale
;
screen
-
>
GetDefaultCSSScaleFactor
(
&
scale
)
;
LayoutDeviceToCSSScale
devToCSSScale
=
CSSToLayoutDeviceScale
(
scale
)
.
Inverse
(
)
;
CSSIntPoint
screenOriginCSS
;
screen
-
>
GetRectDisplayPix
(
&
screenOriginCSS
.
x
&
screenOriginCSS
.
y
&
w
&
h
)
;
aCSSPos
=
(
aDevPos
-
screenOriginDev
)
*
devToCSSScale
+
screenOriginCSS
;
return
true
;
}
NS_IMETHODIMP
nsDragService
:
:
StartInvokingDragSession
(
IDataObject
*
aDataObj
uint32_t
aActionType
)
{
RefPtr
<
nsNativeDragSource
>
nativeDragSrc
=
new
nsNativeDragSource
(
mDataTransfer
)
;
DWORD
winDropRes
;
DWORD
effects
=
DROPEFFECT_SCROLL
;
if
(
aActionType
&
DRAGDROP_ACTION_COPY
)
{
effects
|
=
DROPEFFECT_COPY
;
}
if
(
aActionType
&
DRAGDROP_ACTION_MOVE
)
{
effects
|
=
DROPEFFECT_MOVE
;
}
if
(
aActionType
&
DRAGDROP_ACTION_LINK
)
{
effects
|
=
DROPEFFECT_LINK
;
}
mDragAction
=
aActionType
;
mSentLocalDropEvent
=
false
;
StartDragSession
(
)
;
OpenDragPopup
(
)
;
RefPtr
<
IAsyncOperation
>
pAsyncOp
;
if
(
SUCCEEDED
(
aDataObj
-
>
QueryInterface
(
IID_IAsyncOperation
getter_AddRefs
(
pAsyncOp
)
)
)
)
{
pAsyncOp
-
>
SetAsyncMode
(
VARIANT_TRUE
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
When
did
our
data
object
stop
being
async
"
)
;
}
HRESULT
res
=
:
:
DoDragDrop
(
aDataObj
nativeDragSrc
effects
&
winDropRes
)
;
if
(
!
mSentLocalDropEvent
)
{
uint32_t
dropResult
;
if
(
winDropRes
&
DROPEFFECT_COPY
)
dropResult
=
DRAGDROP_ACTION_COPY
;
else
if
(
winDropRes
&
DROPEFFECT_LINK
)
dropResult
=
DRAGDROP_ACTION_LINK
;
else
if
(
winDropRes
&
DROPEFFECT_MOVE
)
dropResult
=
DRAGDROP_ACTION_MOVE
;
else
dropResult
=
DRAGDROP_ACTION_NONE
;
if
(
mDataTransfer
)
{
if
(
res
=
=
DRAGDROP_S_DROP
)
mDataTransfer
-
>
SetDropEffectInt
(
dropResult
)
;
else
mDataTransfer
-
>
SetDropEffectInt
(
DRAGDROP_ACTION_NONE
)
;
}
}
mUserCancelled
=
nativeDragSrc
-
>
UserCancelled
(
)
;
DWORD
pos
=
:
:
GetMessagePos
(
)
;
CSSPoint
cssPos
;
if
(
!
LayoutDevicePointToCSSPoint
(
LayoutDevicePoint
(
GET_X_LPARAM
(
pos
)
GET_Y_LPARAM
(
pos
)
)
cssPos
)
)
{
POINT
pt
=
{
GET_X_LPARAM
(
pos
)
GET_Y_LPARAM
(
pos
)
}
;
HMONITOR
monitor
=
:
:
MonitorFromPoint
(
pt
MONITOR_DEFAULTTOPRIMARY
)
;
double
dpiScale
=
widget
:
:
WinUtils
:
:
LogToPhysFactor
(
monitor
)
;
cssPos
.
x
=
GET_X_LPARAM
(
pos
)
/
dpiScale
;
cssPos
.
y
=
GET_Y_LPARAM
(
pos
)
/
dpiScale
;
}
SetDragEndPoint
(
LayoutDeviceIntPoint
(
NSToIntRound
(
cssPos
.
x
)
NSToIntRound
(
cssPos
.
y
)
)
)
;
ModifierKeyState
modifierKeyState
;
EndDragSession
(
true
modifierKeyState
.
GetModifiers
(
)
)
;
mDoingDrag
=
false
;
return
DRAGDROP_S_DROP
=
=
res
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsDataObjCollection
*
nsDragService
:
:
GetDataObjCollection
(
IDataObject
*
aDataObj
)
{
nsDataObjCollection
*
dataObjCol
=
nullptr
;
if
(
aDataObj
)
{
nsIDataObjCollection
*
dataObj
;
if
(
aDataObj
-
>
QueryInterface
(
IID_IDataObjCollection
(
void
*
*
)
&
dataObj
)
=
=
S_OK
)
{
dataObjCol
=
static_cast
<
nsDataObjCollection
*
>
(
aDataObj
)
;
dataObj
-
>
Release
(
)
;
}
}
return
dataObjCol
;
}
NS_IMETHODIMP
nsDragService
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
if
(
!
mDataObject
)
{
*
aNumItems
=
0
;
return
NS_OK
;
}
if
(
IsCollectionObject
(
mDataObject
)
)
{
nsDataObjCollection
*
dataObjCol
=
GetDataObjCollection
(
mDataObject
)
;
if
(
dataObjCol
)
{
*
aNumItems
=
dataObjCol
-
>
GetNumDataObjects
(
)
;
}
else
{
*
aNumItems
=
0
;
}
}
else
{
FORMATETC
fe2
;
SET_FORMATETC
(
fe2
CF_HDROP
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe2
)
=
=
S_OK
)
{
STGMEDIUM
stm
;
if
(
mDataObject
-
>
GetData
(
&
fe2
&
stm
)
=
=
S_OK
)
{
HDROP
hdrop
=
(
HDROP
)
GlobalLock
(
stm
.
hGlobal
)
;
*
aNumItems
=
:
:
DragQueryFileW
(
hdrop
0xFFFFFFFF
nullptr
0
)
;
:
:
GlobalUnlock
(
stm
.
hGlobal
)
;
:
:
ReleaseStgMedium
(
&
stm
)
;
if
(
*
aNumItems
=
=
0
)
*
aNumItems
=
1
;
}
else
*
aNumItems
=
1
;
}
else
*
aNumItems
=
1
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
anItem
)
{
if
(
!
mDataObject
)
return
NS_ERROR_FAILURE
;
nsresult
dataFound
=
NS_ERROR_FAILURE
;
if
(
IsCollectionObject
(
mDataObject
)
)
{
nsDataObjCollection
*
dataObjCol
=
GetDataObjCollection
(
mDataObject
)
;
uint32_t
cnt
=
dataObjCol
-
>
GetNumDataObjects
(
)
;
if
(
anItem
<
cnt
)
{
IDataObject
*
dataObj
=
dataObjCol
-
>
GetDataObjectAt
(
anItem
)
;
dataFound
=
nsClipboard
:
:
GetDataFromDataObject
(
dataObj
0
nullptr
aTransferable
)
;
}
else
NS_WARNING
(
"
Index
out
of
range
!
"
)
;
}
else
{
if
(
anItem
=
=
0
)
{
dataFound
=
nsClipboard
:
:
GetDataFromDataObject
(
mDataObject
anItem
nullptr
aTransferable
)
;
}
else
{
FORMATETC
fe2
;
SET_FORMATETC
(
fe2
CF_HDROP
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe2
)
=
=
S_OK
)
dataFound
=
nsClipboard
:
:
GetDataFromDataObject
(
mDataObject
anItem
nullptr
aTransferable
)
;
else
NS_WARNING
(
"
Reqesting
non
-
zero
index
but
clipboard
data
is
not
a
"
"
collection
!
"
)
;
}
}
return
dataFound
;
}
NS_IMETHODIMP
nsDragService
:
:
SetIDataObject
(
IDataObject
*
aDataObj
)
{
NS_IF_RELEASE
(
mDataObject
)
;
mDataObject
=
aDataObj
;
NS_IF_ADDREF
(
mDataObject
)
;
return
NS_OK
;
}
void
nsDragService
:
:
SetDroppedLocal
(
)
{
mSentLocalDropEvent
=
true
;
return
;
}
NS_IMETHODIMP
nsDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
if
(
!
aDataFlavor
|
|
!
mDataObject
|
|
!
_retval
)
return
NS_ERROR_FAILURE
;
#
ifdef
DEBUG
if
(
strcmp
(
aDataFlavor
kTextMime
)
=
=
0
)
NS_WARNING
(
"
DO
NOT
USE
THE
text
/
plain
DATA
FLAVOR
ANY
MORE
.
USE
text
/
unicode
"
"
INSTEAD
"
)
;
#
endif
*
_retval
=
false
;
FORMATETC
fe
;
UINT
format
=
0
;
if
(
IsCollectionObject
(
mDataObject
)
)
{
format
=
nsClipboard
:
:
GetFormat
(
aDataFlavor
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
nsDataObjCollection
*
dataObjCol
=
GetDataObjCollection
(
mDataObject
)
;
if
(
dataObjCol
)
{
uint32_t
cnt
=
dataObjCol
-
>
GetNumDataObjects
(
)
;
for
(
uint32_t
i
=
0
;
i
<
cnt
;
+
+
i
)
{
IDataObject
*
dataObj
=
dataObjCol
-
>
GetDataObjectAt
(
i
)
;
if
(
S_OK
=
=
dataObj
-
>
QueryGetData
(
&
fe
)
)
*
_retval
=
true
;
}
}
}
else
{
format
=
nsClipboard
:
:
GetFormat
(
aDataFlavor
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
*
_retval
=
true
;
else
{
if
(
strcmp
(
aDataFlavor
kUnicodeMime
)
=
=
0
)
{
format
=
nsClipboard
:
:
GetFormat
(
kTextMime
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
*
_retval
=
true
;
}
else
if
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
)
{
format
=
nsClipboard
:
:
GetFormat
(
kFileMime
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
*
_retval
=
true
;
}
}
}
return
NS_OK
;
}
bool
nsDragService
:
:
IsCollectionObject
(
IDataObject
*
inDataObj
)
{
bool
isCollection
=
false
;
static
UINT
sFormat
=
0
;
static
FORMATETC
sFE
;
if
(
!
sFormat
)
{
sFormat
=
nsClipboard
:
:
GetFormat
(
MULTI_MIME
)
;
SET_FORMATETC
(
sFE
sFormat
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
}
if
(
inDataObj
-
>
QueryGetData
(
&
sFE
)
=
=
S_OK
)
isCollection
=
true
;
return
isCollection
;
}
NS_IMETHODIMP
nsDragService
:
:
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
if
(
:
:
GetCapture
(
)
)
{
:
:
ReleaseCapture
(
)
;
}
nsBaseDragService
:
:
EndDragSession
(
aDoneDrag
aKeyModifiers
)
;
NS_IF_RELEASE
(
mDataObject
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
UpdateDragImage
(
nsINode
*
aImage
int32_t
aImageX
int32_t
aImageY
)
{
if
(
!
mDataObject
)
{
return
NS_OK
;
}
nsBaseDragService
:
:
UpdateDragImage
(
aImage
aImageX
aImageY
)
;
IDragSourceHelper
*
pdsh
;
if
(
SUCCEEDED
(
CoCreateInstance
(
CLSID_DragDropHelper
nullptr
CLSCTX_INPROC_SERVER
IID_IDragSourceHelper
(
void
*
*
)
&
pdsh
)
)
)
{
SHDRAGIMAGE
sdi
;
if
(
CreateDragImage
(
mSourceNode
Nothing
(
)
&
sdi
)
)
{
nsNativeDragTarget
:
:
DragImageChanged
(
)
;
if
(
FAILED
(
pdsh
-
>
InitializeFromBitmap
(
&
sdi
mDataObject
)
)
)
DeleteObject
(
sdi
.
hbmpDragImage
)
;
}
pdsh
-
>
Release
(
)
;
}
return
NS_OK
;
}
