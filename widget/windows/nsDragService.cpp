#
include
<
ole2
.
h
>
#
include
<
oleidl
.
h
>
#
include
<
shlobj
.
h
>
#
include
<
shlwapi
.
h
>
#
include
<
shellapi
.
h
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsDragService
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsDataObj
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsNativeDragTarget
.
h
"
#
include
"
nsNativeDragSource
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsDataObjCollection
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
widget
;
nsDragSession
:
:
~
nsDragSession
(
)
{
NS_IF_RELEASE
(
mDataObject
)
;
}
already_AddRefed
<
nsIDragSession
>
nsDragService
:
:
CreateDragSession
(
)
{
RefPtr
<
nsIDragSession
>
session
=
new
nsDragSession
(
)
;
return
session
.
forget
(
)
;
}
bool
nsDragSession
:
:
CreateDragImage
(
nsINode
*
aDOMNode
const
Maybe
<
CSSIntRegion
>
&
aRegion
SHDRAGIMAGE
*
psdi
)
{
if
(
!
psdi
)
return
false
;
memset
(
psdi
0
sizeof
(
SHDRAGIMAGE
)
)
;
if
(
!
aDOMNode
)
return
false
;
LayoutDeviceIntRect
dragRect
;
RefPtr
<
SourceSurface
>
surface
;
nsPresContext
*
pc
;
DrawDrag
(
aDOMNode
aRegion
mScreenPosition
&
dragRect
&
surface
&
pc
)
;
if
(
!
surface
)
return
false
;
uint32_t
bmWidth
=
dragRect
.
Width
(
)
bmHeight
=
dragRect
.
Height
(
)
;
if
(
bmWidth
=
=
0
|
|
bmHeight
=
=
0
)
return
false
;
psdi
-
>
crColorKey
=
CLR_NONE
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
IntSize
(
bmWidth
bmHeight
)
SurfaceFormat
:
:
B8G8R8A8
)
;
NS_ENSURE_TRUE
(
dataSurface
false
)
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ_WRITE
&
map
)
)
{
return
false
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
map
.
mData
dataSurface
-
>
GetSize
(
)
map
.
mStride
dataSurface
-
>
GetFormat
(
)
)
;
if
(
!
dt
)
{
dataSurface
-
>
Unmap
(
)
;
return
false
;
}
dt
-
>
DrawSurface
(
surface
Rect
(
0
0
dataSurface
-
>
GetSize
(
)
.
width
dataSurface
-
>
GetSize
(
)
.
height
)
Rect
(
0
0
surface
-
>
GetSize
(
)
.
width
surface
-
>
GetSize
(
)
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
dt
-
>
Flush
(
)
;
BITMAPV5HEADER
bmih
;
memset
(
(
void
*
)
&
bmih
0
sizeof
(
BITMAPV5HEADER
)
)
;
bmih
.
bV5Size
=
sizeof
(
BITMAPV5HEADER
)
;
bmih
.
bV5Width
=
bmWidth
;
bmih
.
bV5Height
=
-
(
int32_t
)
bmHeight
;
bmih
.
bV5Planes
=
1
;
bmih
.
bV5BitCount
=
32
;
bmih
.
bV5Compression
=
BI_BITFIELDS
;
bmih
.
bV5RedMask
=
0x00FF0000
;
bmih
.
bV5GreenMask
=
0x0000FF00
;
bmih
.
bV5BlueMask
=
0x000000FF
;
bmih
.
bV5AlphaMask
=
0xFF000000
;
HDC
hdcSrc
=
CreateCompatibleDC
(
nullptr
)
;
void
*
lpBits
=
nullptr
;
if
(
hdcSrc
)
{
psdi
-
>
hbmpDragImage
=
:
:
CreateDIBSection
(
hdcSrc
(
BITMAPINFO
*
)
&
bmih
DIB_RGB_COLORS
(
void
*
*
)
&
lpBits
nullptr
0
)
;
if
(
psdi
-
>
hbmpDragImage
&
&
lpBits
)
{
CopySurfaceDataToPackedArray
(
map
.
mData
static_cast
<
uint8_t
*
>
(
lpBits
)
dataSurface
-
>
GetSize
(
)
map
.
mStride
BytesPerPixel
(
dataSurface
-
>
GetFormat
(
)
)
)
;
}
psdi
-
>
sizeDragImage
.
cx
=
bmWidth
;
psdi
-
>
sizeDragImage
.
cy
=
bmHeight
;
const
auto
screenPoint
=
LayoutDeviceIntPoint
:
:
Round
(
mScreenPosition
*
pc
-
>
CSSToDevPixelScale
(
)
)
;
psdi
-
>
ptOffset
.
x
=
screenPoint
.
x
-
dragRect
.
X
(
)
;
psdi
-
>
ptOffset
.
y
=
screenPoint
.
y
-
dragRect
.
Y
(
)
;
DeleteDC
(
hdcSrc
)
;
}
dataSurface
-
>
Unmap
(
)
;
return
psdi
-
>
hbmpDragImage
!
=
nullptr
;
}
nsresult
nsDragSession
:
:
InvokeDragSessionImpl
(
nsIWidget
*
aWidget
nsIArray
*
anArrayTransferables
const
Maybe
<
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
{
nsIURI
*
uri
=
nullptr
;
RefPtr
<
dom
:
:
Document
>
doc
(
mSourceDocument
)
;
if
(
doc
)
{
uri
=
doc
-
>
GetDocumentURI
(
)
;
}
uint32_t
numItemsToDrag
=
0
;
nsresult
rv
=
anArrayTransferables
-
>
GetLength
(
&
numItemsToDrag
)
;
if
(
!
numItemsToDrag
)
return
NS_ERROR_FAILURE
;
RefPtr
<
IDataObject
>
itemToDrag
;
if
(
numItemsToDrag
>
1
)
{
nsDataObjCollection
*
dataObjCollection
=
new
nsDataObjCollection
(
)
;
if
(
!
dataObjCollection
)
return
NS_ERROR_OUT_OF_MEMORY
;
itemToDrag
=
dataObjCollection
;
for
(
uint32_t
i
=
0
;
i
<
numItemsToDrag
;
+
+
i
)
{
nsCOMPtr
<
nsITransferable
>
trans
=
do_QueryElementAt
(
anArrayTransferables
i
)
;
if
(
trans
)
{
RefPtr
<
IDataObject
>
dataObj
;
rv
=
nsClipboard
:
:
CreateNativeDataObject
(
trans
getter_AddRefs
(
dataObj
)
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsClipboard
:
:
SetupNativeDataObject
(
trans
dataObjCollection
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
dataObjCollection
-
>
AddDataObject
(
dataObj
)
;
}
}
}
else
{
nsCOMPtr
<
nsITransferable
>
trans
=
do_QueryElementAt
(
anArrayTransferables
0
)
;
if
(
trans
)
{
rv
=
nsClipboard
:
:
CreateNativeDataObject
(
trans
getter_AddRefs
(
itemToDrag
)
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
IDragSourceHelper
*
pdsh
;
if
(
SUCCEEDED
(
CoCreateInstance
(
CLSID_DragDropHelper
nullptr
CLSCTX_INPROC_SERVER
IID_IDragSourceHelper
(
void
*
*
)
&
pdsh
)
)
)
{
SHDRAGIMAGE
sdi
;
if
(
CreateDragImage
(
mSourceNode
aRegion
&
sdi
)
)
{
if
(
FAILED
(
pdsh
-
>
InitializeFromBitmap
(
&
sdi
itemToDrag
)
)
)
DeleteObject
(
sdi
.
hbmpDragImage
)
;
}
pdsh
-
>
Release
(
)
;
}
return
StartInvokingDragSession
(
aWidget
itemToDrag
aActionType
)
;
}
static
HWND
GetSourceWindow
(
dom
:
:
Document
*
aSourceDocument
)
{
if
(
!
aSourceDocument
)
{
return
nullptr
;
}
auto
*
pc
=
aSourceDocument
-
>
GetPresContext
(
)
;
if
(
!
pc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
pc
-
>
GetRootWidget
(
)
;
if
(
!
widget
)
{
return
nullptr
;
}
return
(
HWND
)
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
}
nsresult
nsDragSession
:
:
StartInvokingDragSession
(
nsIWidget
*
aWidget
IDataObject
*
aDataObj
uint32_t
aActionType
)
{
RefPtr
<
nsNativeDragSource
>
nativeDragSrc
=
new
nsNativeDragSource
(
mDataTransfer
)
;
DWORD
winDropRes
;
DWORD
effects
=
DROPEFFECT_SCROLL
;
if
(
aActionType
&
nsIDragService
:
:
DRAGDROP_ACTION_COPY
)
{
effects
|
=
DROPEFFECT_COPY
;
}
if
(
aActionType
&
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
)
{
effects
|
=
DROPEFFECT_MOVE
;
}
if
(
aActionType
&
nsIDragService
:
:
DRAGDROP_ACTION_LINK
)
{
effects
|
=
DROPEFFECT_LINK
;
}
mDragAction
=
aActionType
;
mSentLocalDropEvent
=
false
;
OpenDragPopup
(
)
;
RefPtr
<
IDataObjectAsyncCapability
>
pAsyncOp
;
if
(
SUCCEEDED
(
aDataObj
-
>
QueryInterface
(
IID_IDataObjectAsyncCapability
getter_AddRefs
(
pAsyncOp
)
)
)
)
{
pAsyncOp
-
>
SetAsyncMode
(
VARIANT_TRUE
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
When
did
our
data
object
stop
being
async
"
)
;
}
HRESULT
res
=
:
:
DoDragDrop
(
aDataObj
nativeDragSrc
effects
&
winDropRes
)
;
if
(
!
mSentLocalDropEvent
)
{
uint32_t
dropResult
;
if
(
winDropRes
&
DROPEFFECT_COPY
)
dropResult
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
else
if
(
winDropRes
&
DROPEFFECT_LINK
)
dropResult
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
else
if
(
winDropRes
&
DROPEFFECT_MOVE
)
dropResult
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
else
dropResult
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
if
(
mDataTransfer
)
{
if
(
!
mozilla
:
:
StaticPrefs
:
:
widget_windows_allow_external_tab_drag
(
)
)
{
if
(
mDataTransfer
-
>
HasType
(
u
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
_ns
)
)
{
dropResult
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
}
}
if
(
res
=
=
DRAGDROP_S_DROP
)
mDataTransfer
-
>
SetDropEffectInt
(
dropResult
)
;
else
mDataTransfer
-
>
SetDropEffectInt
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
;
}
}
mUserCancelled
=
nativeDragSrc
-
>
UserCancelled
(
)
;
DWORD
pos
=
:
:
GetMessagePos
(
)
;
POINT
cpos
;
cpos
.
x
=
GET_X_LPARAM
(
pos
)
;
cpos
.
y
=
GET_Y_LPARAM
(
pos
)
;
if
(
auto
wnd
=
GetSourceWindow
(
mSourceDocument
)
)
{
:
:
ScreenToClient
(
wnd
&
cpos
)
;
}
SetDragEndPoint
(
LayoutDeviceIntPoint
(
cpos
.
x
cpos
.
y
)
)
;
ModifierKeyState
modifierKeyState
;
EndDragSession
(
true
modifierKeyState
.
GetModifiers
(
)
)
;
mDoingDrag
=
false
;
return
DRAGDROP_S_DROP
=
=
res
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsDataObjCollection
*
nsDragSession
:
:
GetDataObjCollection
(
IDataObject
*
aDataObj
)
{
nsDataObjCollection
*
dataObjCol
=
nullptr
;
if
(
aDataObj
)
{
nsIDataObjCollection
*
dataObj
;
if
(
aDataObj
-
>
QueryInterface
(
IID_IDataObjCollection
(
void
*
*
)
&
dataObj
)
=
=
S_OK
)
{
dataObjCol
=
static_cast
<
nsDataObjCollection
*
>
(
aDataObj
)
;
dataObj
-
>
Release
(
)
;
}
}
return
dataObjCol
;
}
NS_IMETHODIMP
nsDragSession
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
if
(
!
mDataObject
)
{
*
aNumItems
=
0
;
return
NS_OK
;
}
if
(
IsCollectionObject
(
mDataObject
)
)
{
nsDataObjCollection
*
dataObjCol
=
GetDataObjCollection
(
mDataObject
)
;
*
aNumItems
=
dataObjCol
?
dataObjCol
-
>
GetNumDataObjects
(
)
:
0
;
return
NS_OK
;
}
FORMATETC
fe2
;
SET_FORMATETC
(
fe2
CF_HDROP
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
if
(
SUCCEEDED
(
mDataObject
-
>
QueryGetData
(
&
fe2
)
)
)
{
STGMEDIUM
stm
;
if
(
FAILED
(
mDataObject
-
>
GetData
(
&
fe2
&
stm
)
)
)
{
*
aNumItems
=
1
;
return
NS_OK
;
}
HDROP
hdrop
=
static_cast
<
HDROP
>
(
GlobalLock
(
stm
.
hGlobal
)
)
;
MOZ_ASSERT
(
hdrop
!
=
NULL
)
;
*
aNumItems
=
:
:
DragQueryFileW
(
hdrop
0xFFFFFFFF
nullptr
0
)
;
:
:
GlobalUnlock
(
stm
.
hGlobal
)
;
:
:
ReleaseStgMedium
(
&
stm
)
;
if
(
*
aNumItems
=
=
0
)
{
*
aNumItems
=
1
;
}
return
NS_OK
;
}
SET_FORMATETC
(
fe2
nsClipboard
:
:
GetClipboardFileDescriptorFormatW
(
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
STGMEDIUM
stm
;
if
(
SUCCEEDED
(
mDataObject
-
>
GetData
(
&
fe2
&
stm
)
)
)
{
LPFILEGROUPDESCRIPTOR
pDesc
=
static_cast
<
LPFILEGROUPDESCRIPTOR
>
(
GlobalLock
(
stm
.
hGlobal
)
)
;
if
(
pDesc
)
{
*
aNumItems
=
pDesc
-
>
cItems
;
}
GlobalUnlock
(
stm
.
hGlobal
)
;
ReleaseStgMedium
(
&
stm
)
;
return
NS_OK
;
}
*
aNumItems
=
1
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragSession
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
anItem
)
{
if
(
!
mDataObject
)
return
NS_ERROR_FAILURE
;
nsresult
dataFound
=
NS_ERROR_FAILURE
;
if
(
IsCollectionObject
(
mDataObject
)
)
{
nsDataObjCollection
*
dataObjCol
=
GetDataObjCollection
(
mDataObject
)
;
uint32_t
cnt
=
dataObjCol
-
>
GetNumDataObjects
(
)
;
if
(
anItem
<
cnt
)
{
IDataObject
*
dataObj
=
dataObjCol
-
>
GetDataObjectAt
(
anItem
)
;
dataFound
=
nsClipboard
:
:
GetDataFromDataObject
(
dataObj
0
nullptr
aTransferable
)
;
}
else
NS_WARNING
(
"
Index
out
of
range
!
"
)
;
}
else
{
if
(
anItem
=
=
0
)
{
dataFound
=
nsClipboard
:
:
GetDataFromDataObject
(
mDataObject
anItem
nullptr
aTransferable
)
;
}
else
{
FORMATETC
fe2
;
FORMATETC
fe3
;
SET_FORMATETC
(
fe2
CF_HDROP
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
SET_FORMATETC
(
fe3
nsClipboard
:
:
GetClipboardFileDescriptorFormatW
(
)
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
if
(
SUCCEEDED
(
mDataObject
-
>
QueryGetData
(
&
fe2
)
)
|
|
SUCCEEDED
(
mDataObject
-
>
QueryGetData
(
&
fe3
)
)
)
dataFound
=
nsClipboard
:
:
GetDataFromDataObject
(
mDataObject
anItem
nullptr
aTransferable
)
;
else
NS_WARNING
(
"
Reqesting
non
-
zero
index
but
clipboard
data
is
not
a
"
"
collection
!
"
)
;
}
}
return
dataFound
;
}
void
nsDragSession
:
:
SetIDataObject
(
IDataObject
*
aDataObj
)
{
NS_IF_RELEASE
(
mDataObject
)
;
mDataObject
=
aDataObj
;
NS_IF_ADDREF
(
mDataObject
)
;
if
(
MOZ_DRAGSERVICE_LOG_ENABLED
(
)
)
{
MOZ_DRAGSERVICE_LOG
(
"
nsDragSession
:
:
SetIDataObject
(
%
p
)
"
mDataObject
)
;
IEnumFORMATETC
*
pEnum
=
nullptr
;
if
(
mDataObject
&
&
S_OK
=
=
mDataObject
-
>
EnumFormatEtc
(
DATADIR_GET
&
pEnum
)
)
{
MOZ_DRAGSERVICE_LOG
(
"
formats
in
DataObject
:
"
)
;
FORMATETC
fEtc
;
while
(
S_OK
=
=
pEnum
-
>
Next
(
1
&
fEtc
nullptr
)
)
{
nsAutoString
format
;
WinUtils
:
:
GetClipboardFormatAsString
(
fEtc
.
cfFormat
format
)
;
MOZ_DRAGSERVICE_LOG
(
"
FORMAT
%
s
"
NS_ConvertUTF16toUTF8
(
format
)
.
get
(
)
)
;
}
pEnum
-
>
Release
(
)
;
}
}
}
void
nsDragSession
:
:
SetDroppedLocal
(
)
{
mSentLocalDropEvent
=
true
;
return
;
}
NS_IMETHODIMP
nsDragSession
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
if
(
!
aDataFlavor
|
|
!
mDataObject
|
|
!
_retval
)
{
MOZ_DRAGSERVICE_LOG
(
"
%
s
:
error
"
__PRETTY_FUNCTION__
)
;
return
NS_ERROR_FAILURE
;
}
*
_retval
=
false
;
auto
logging
=
MakeScopeExit
(
[
&
]
{
MOZ_DRAGSERVICE_LOG
(
"
IsDataFlavorSupported
:
%
s
is
%
s
found
"
aDataFlavor
*
_retval
?
"
"
:
"
not
"
)
;
}
)
;
FORMATETC
fe
;
UINT
format
=
0
;
if
(
IsCollectionObject
(
mDataObject
)
)
{
format
=
nsClipboard
:
:
GetFormat
(
aDataFlavor
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
nsDataObjCollection
*
dataObjCol
=
GetDataObjCollection
(
mDataObject
)
;
if
(
dataObjCol
)
{
uint32_t
cnt
=
dataObjCol
-
>
GetNumDataObjects
(
)
;
for
(
uint32_t
i
=
0
;
i
<
cnt
;
+
+
i
)
{
IDataObject
*
dataObj
=
dataObjCol
-
>
GetDataObjectAt
(
i
)
;
if
(
S_OK
=
=
dataObj
-
>
QueryGetData
(
&
fe
)
)
{
*
_retval
=
true
;
}
}
}
return
NS_OK
;
}
format
=
nsClipboard
:
:
GetFormat
(
aDataFlavor
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
{
*
_retval
=
true
;
return
NS_OK
;
}
if
(
strcmp
(
aDataFlavor
kTextMime
)
=
=
0
)
{
SET_FORMATETC
(
fe
CF_TEXT
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
{
*
_retval
=
true
;
}
return
NS_OK
;
}
if
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
)
{
format
=
nsClipboard
:
:
GetFormat
(
kFileMime
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
|
TYMED_FILE
|
TYMED_GDI
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
{
*
_retval
=
true
;
}
return
NS_OK
;
}
if
(
format
=
=
CF_HDROP
)
{
format
=
nsClipboard
:
:
GetFormat
(
kURLMime
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
{
return
NS_OK
;
}
format
=
nsClipboard
:
:
GetClipboardFileDescriptorFormatW
(
)
;
SET_FORMATETC
(
fe
format
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
if
(
mDataObject
-
>
QueryGetData
(
&
fe
)
=
=
S_OK
)
{
*
_retval
=
true
;
}
return
NS_OK
;
}
return
NS_OK
;
}
bool
nsDragSession
:
:
IsCollectionObject
(
IDataObject
*
inDataObj
)
{
bool
isCollection
=
false
;
static
UINT
sFormat
=
0
;
static
FORMATETC
sFE
;
if
(
!
sFormat
)
{
sFormat
=
nsClipboard
:
:
GetFormat
(
MULTI_MIME
)
;
SET_FORMATETC
(
sFE
sFormat
0
DVASPECT_CONTENT
-
1
TYMED_HGLOBAL
)
;
}
if
(
inDataObj
-
>
QueryGetData
(
&
sFE
)
=
=
S_OK
)
isCollection
=
true
;
return
isCollection
;
}
nsresult
nsDragSession
:
:
EndDragSessionImpl
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
if
(
:
:
GetCapture
(
)
)
{
:
:
ReleaseCapture
(
)
;
}
nsBaseDragSession
:
:
EndDragSessionImpl
(
aDoneDrag
aKeyModifiers
)
;
NS_IF_RELEASE
(
mDataObject
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragSession
:
:
UpdateDragImage
(
nsINode
*
aImage
int32_t
aImageX
int32_t
aImageY
)
{
if
(
!
mDataObject
)
{
return
NS_OK
;
}
nsBaseDragSession
:
:
UpdateDragImage
(
aImage
aImageX
aImageY
)
;
IDragSourceHelper
*
pdsh
;
if
(
SUCCEEDED
(
CoCreateInstance
(
CLSID_DragDropHelper
nullptr
CLSCTX_INPROC_SERVER
IID_IDragSourceHelper
(
void
*
*
)
&
pdsh
)
)
)
{
SHDRAGIMAGE
sdi
;
if
(
CreateDragImage
(
mSourceNode
Nothing
(
)
&
sdi
)
)
{
nsNativeDragTarget
:
:
DragImageChanged
(
)
;
if
(
FAILED
(
pdsh
-
>
InitializeFromBitmap
(
&
sdi
mDataObject
)
)
)
DeleteObject
(
sdi
.
hbmpDragImage
)
;
}
pdsh
-
>
Release
(
)
;
}
return
NS_OK
;
}
