#
include
"
nsWindowTaskbarConcealer
.
h
"
#
include
"
nsIWinTaskbar
.
h
"
#
define
NS_TASKBAR_CONTRACTID
"
mozilla
.
org
/
windows
-
taskbar
;
1
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
WinUtils
.
h
"
using
namespace
mozilla
;
struct
TaskbarConcealerImpl
{
void
MarkAsHidingTaskbar
(
HWND
aWnd
bool
aMark
)
;
enum
class
MarkingMethod
:
uint32_t
{
NonRudeHwnd
=
1
PrepareFullScreen
=
2
}
;
static
MarkingMethod
GetMarkingMethod
(
)
{
uint32_t
const
val
=
StaticPrefs
:
:
widget_windows_fullscreen_marking_method
(
)
;
if
(
val
>
=
1
&
&
val
<
=
3
)
return
MarkingMethod
(
val
)
;
return
MarkingMethod
:
:
NonRudeHwnd
;
}
private
:
nsCOMPtr
<
nsIWinTaskbar
>
mTaskbarInfo
;
MarkingMethod
const
mMarkingMethod
=
GetMarkingMethod
(
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
TaskbarConcealerImpl
:
:
MarkingMethod
)
;
static
mozilla
:
:
LazyLogModule
sTaskbarConcealerLog
(
"
TaskbarConcealer
"
)
;
MOZ_RUNINIT
nsTHashMap
<
HWND
HMONITOR
>
nsWindow
:
:
TaskbarConcealer
:
:
sKnownWindows
;
Maybe
<
nsWindow
:
:
TaskbarConcealer
:
:
WindowState
>
nsWindow
:
:
TaskbarConcealer
:
:
GetWindowState
(
HWND
aWnd
)
{
if
(
!
:
:
IsWindowVisible
(
aWnd
)
)
{
return
Nothing
(
)
;
}
if
(
:
:
IsIconic
(
aWnd
)
)
{
return
Nothing
(
)
;
}
nsWindow
*
pWin
=
widget
:
:
WinUtils
:
:
GetNSWindowPtr
(
aWnd
)
;
if
(
!
pWin
)
{
return
Nothing
(
)
;
}
if
(
pWin
-
>
mWindowType
!
=
WindowType
:
:
TopLevel
)
{
return
Nothing
(
)
;
}
if
(
pWin
-
>
mIsCloaked
)
{
return
Nothing
(
)
;
}
return
Some
(
WindowState
{
:
:
MonitorFromWindow
(
aWnd
MONITOR_DEFAULTTONULL
)
pWin
-
>
mFrameState
-
>
GetSizeMode
(
)
=
=
nsSizeMode_Fullscreen
}
)
;
}
void
nsWindow
:
:
TaskbarConcealer
:
:
UpdateAllState
(
HWND
destroyedHwnd
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
TaskbarConcealer
can
only
be
used
from
the
main
thread
!
"
)
;
if
(
MOZ_LOG_TEST
(
sTaskbarConcealerLog
LogLevel
:
:
Info
)
)
{
static
size_t
sLogCounter
=
0
;
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
Calling
UpdateAllState
(
)
for
the
%
zuth
time
"
sLogCounter
+
+
)
)
;
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
Last
known
state
:
"
)
)
;
if
(
sKnownWindows
.
IsEmpty
(
)
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
none
(
no
windows
known
)
"
)
)
;
}
else
{
for
(
const
auto
&
entry
:
sKnownWindows
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
window
%
p
was
on
monitor
%
p
"
entry
.
GetKey
(
)
entry
.
GetData
(
)
)
)
;
}
}
}
struct
Item
{
HWND
hwnd
;
HMONITOR
monitor
;
bool
isGkFullscreen
;
}
;
const
nsTArray
<
Item
>
windows
=
[
&
]
{
nsTArray
<
Item
>
windows
;
mozilla
:
:
EnumerateThreadWindows
(
[
&
]
(
HWND
hwnd
)
{
if
(
hwnd
=
=
destroyedHwnd
)
{
return
;
}
const
auto
maybeState
=
GetWindowState
(
hwnd
)
;
if
(
!
maybeState
)
{
return
;
}
const
WindowState
&
state
=
*
maybeState
;
windows
.
AppendElement
(
Item
{
.
hwnd
=
hwnd
.
monitor
=
state
.
monitor
.
isGkFullscreen
=
state
.
isGkFullscreen
}
)
;
}
)
;
return
windows
;
}
(
)
;
const
nsTHashSet
<
HMONITOR
>
relevantMonitors
=
[
&
]
(
)
{
nsTHashSet
<
HMONITOR
>
relevantMonitors
;
for
(
const
Item
&
item
:
windows
)
{
relevantMonitors
.
Insert
(
item
.
monitor
)
;
}
return
relevantMonitors
;
}
(
)
;
sKnownWindows
.
Clear
(
)
;
for
(
const
Item
&
item
:
windows
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Debug
(
"
Found
relevant
window
%
p
on
monitor
%
p
"
item
.
hwnd
item
.
monitor
)
)
;
sKnownWindows
.
InsertOrUpdate
(
item
.
hwnd
item
.
monitor
)
;
}
const
auto
FindUppermostWindowOn
=
[
&
windows
]
(
HMONITOR
aMonitor
)
-
>
HWND
{
for
(
const
Item
&
item
:
windows
)
{
if
(
item
.
monitor
=
=
aMonitor
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
on
monitor
%
p
uppermost
relevant
HWND
is
%
p
"
aMonitor
item
.
hwnd
)
)
;
return
item
.
hwnd
;
}
}
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Warning
(
"
on
monitor
%
p
no
relevant
windows
were
found
"
aMonitor
)
)
;
return
nullptr
;
}
;
TaskbarConcealerImpl
impl
;
for
(
HMONITOR
monitor
:
relevantMonitors
)
{
const
HWND
topmost
=
FindUppermostWindowOn
(
monitor
)
;
for
(
const
Item
&
item
:
windows
)
{
if
(
item
.
monitor
!
=
monitor
)
continue
;
impl
.
MarkAsHidingTaskbar
(
item
.
hwnd
item
.
isGkFullscreen
&
&
item
.
hwnd
=
=
topmost
)
;
}
}
}
void
TaskbarConcealerImpl
:
:
MarkAsHidingTaskbar
(
HWND
aWnd
bool
aMark
)
{
const
char
*
const
sMark
=
aMark
?
"
true
"
:
"
false
"
;
bool
const
useNonRudeHWND
=
!
!
(
mMarkingMethod
&
MarkingMethod
:
:
NonRudeHwnd
)
;
bool
const
usePrepareFullScreen
=
!
!
(
mMarkingMethod
&
MarkingMethod
:
:
PrepareFullScreen
)
;
MOZ_ASSERT
(
useNonRudeHWND
|
|
usePrepareFullScreen
)
;
if
(
useNonRudeHWND
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
Setting
%
p
[
L
\
"
NonRudeHWND
\
"
]
to
%
s
"
aWnd
sMark
)
)
;
:
:
SetPropW
(
aWnd
L
"
NonRudeHWND
"
(
HANDLE
)
uintptr_t
(
aMark
?
FALSE
:
TRUE
)
)
;
}
else
{
:
:
RemovePropW
(
aWnd
L
"
NonRudeHWND
"
)
;
}
if
(
usePrepareFullScreen
)
{
if
(
!
mTaskbarInfo
)
{
mTaskbarInfo
=
do_GetService
(
NS_TASKBAR_CONTRACTID
)
;
if
(
!
mTaskbarInfo
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Warning
(
"
could
not
acquire
IWinTaskbar
(
aWnd
%
p
aMark
%
s
)
"
aWnd
sMark
)
)
;
return
;
}
}
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
Calling
PrepareFullScreen
(
%
p
%
s
)
"
aWnd
sMark
)
)
;
const
nsresult
hr
=
mTaskbarInfo
-
>
PrepareFullScreen
(
aWnd
aMark
)
;
if
(
FAILED
(
hr
)
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Error
(
"
Call
to
PrepareFullScreen
(
%
p
%
s
)
failed
with
nsresult
%
x
"
aWnd
sMark
uint32_t
(
hr
)
)
)
;
}
}
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnWindowDestroyed
(
HWND
aWnd
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnWindowDestroyed
(
)
for
HWND
%
p
"
aWnd
)
)
;
UpdateAllState
(
aWnd
)
;
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnFocusAcquired
(
nsWindow
*
aWin
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnFocusAcquired
(
)
for
HWND
%
p
on
HMONITOR
%
p
"
aWin
-
>
mWnd
:
:
MonitorFromWindow
(
aWin
-
>
mWnd
MONITOR_DEFAULTTONULL
)
)
)
;
UpdateAllState
(
)
;
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnWindowMaximized
(
nsWindow
*
aWin
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnWindowMaximized
(
)
for
HWND
%
p
on
HMONITOR
%
p
"
aWin
-
>
mWnd
:
:
MonitorFromWindow
(
aWin
-
>
mWnd
MONITOR_DEFAULTTONULL
)
)
)
;
if
(
MOZ_LIKELY
(
TaskbarConcealerImpl
:
:
GetMarkingMethod
(
)
!
=
TaskbarConcealerImpl
:
:
MarkingMethod
:
:
PrepareFullScreen
)
)
{
return
;
}
if
(
!
aWin
-
>
mCustomNonClient
)
{
return
;
}
(
TaskbarConcealerImpl
{
}
)
.
MarkAsHidingTaskbar
(
aWin
-
>
mWnd
false
)
;
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnFullscreenChanged
(
nsWindow
*
aWin
bool
enteredFullscreen
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnFullscreenChanged
(
)
for
HWND
%
p
on
HMONITOR
%
p
"
aWin
-
>
mWnd
:
:
MonitorFromWindow
(
aWin
-
>
mWnd
MONITOR_DEFAULTTONULL
)
)
)
;
UpdateAllState
(
)
;
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnWindowPosChanged
(
nsWindow
*
aWin
)
{
const
HWND
myHwnd
=
aWin
-
>
mWnd
;
const
HMONITOR
oldMonitor
=
sKnownWindows
.
Get
(
myHwnd
)
;
const
HMONITOR
newMonitor
=
GetWindowState
(
myHwnd
)
.
map
(
[
]
(
auto
state
)
{
return
state
.
monitor
;
}
)
.
valueOr
(
nullptr
)
;
if
(
oldMonitor
=
=
newMonitor
)
{
return
;
}
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnWindowPosChanged
(
)
for
HWND
%
p
(
HMONITOR
%
p
-
>
%
p
)
"
myHwnd
oldMonitor
newMonitor
)
)
;
UpdateAllState
(
)
;
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnAsyncStateUpdateRequest
(
HWND
hwnd
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnAsyncStateUpdateRequest
(
)
"
)
)
;
static
UINT
const
shellHookMsg
=
:
:
RegisterWindowMessageW
(
L
"
SHELLHOOK
"
)
;
if
(
shellHookMsg
!
=
0
)
{
DWORD
info
=
BSM_APPLICATIONS
;
:
:
BroadcastSystemMessage
(
BSF_POSTMESSAGE
|
BSF_IGNORECURRENTTASK
&
info
shellHookMsg
HSHELL_WINDOWACTIVATED
(
LPARAM
)
hwnd
)
;
}
}
void
nsWindow
:
:
TaskbarConcealer
:
:
OnCloakChanged
(
)
{
MOZ_LOG
(
sTaskbarConcealerLog
LogLevel
:
:
Info
(
"
=
=
>
OnCloakChanged
(
)
"
)
)
;
UpdateAllState
(
)
;
}
