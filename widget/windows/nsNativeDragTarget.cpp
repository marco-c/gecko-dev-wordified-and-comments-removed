#
include
<
stdio
.
h
>
#
include
"
nsIDragService
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsNativeDragTarget
.
h
"
#
include
"
nsDragService
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
KeyboardLayout
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
widget
/
WidgetLogging
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
#
define
LOGD
DRAGSERVICE_LOGD
#
define
LOGI
DRAGSERVICE_LOGI
#
define
LOGE
DRAGSERVICE_LOGE
static
POINTL
gDragLastPoint
;
bool
nsNativeDragTarget
:
:
gDragImageChanged
=
false
;
nsNativeDragTarget
:
:
nsNativeDragTarget
(
nsIWidget
*
aWidget
)
:
m_cRef
(
0
)
mEffectsAllowed
(
DROPEFFECT_MOVE
|
DROPEFFECT_COPY
|
DROPEFFECT_LINK
)
mEffectsPreferred
(
DROPEFFECT_NONE
)
mTookOwnRef
(
false
)
mWidget
(
aWidget
)
mDropTargetHelper
(
nullptr
)
{
LOGD
(
"
[
%
p
]
%
s
"
this
__FUNCTION__
)
;
mHWnd
=
(
HWND
)
mWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
mDragService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
}
nsNativeDragTarget
:
:
~
nsNativeDragTarget
(
)
{
LOGD
(
"
[
%
p
]
%
s
"
this
__FUNCTION__
)
;
if
(
mDropTargetHelper
)
{
mDropTargetHelper
-
>
Release
(
)
;
mDropTargetHelper
=
nullptr
;
}
}
STDMETHODIMP
nsNativeDragTarget
:
:
QueryInterface
(
REFIID
riid
void
*
*
ppv
)
{
*
ppv
=
nullptr
;
if
(
IID_IUnknown
=
=
riid
|
|
IID_IDropTarget
=
=
riid
)
*
ppv
=
this
;
if
(
nullptr
!
=
*
ppv
)
{
(
(
LPUNKNOWN
)
*
ppv
)
-
>
AddRef
(
)
;
return
S_OK
;
}
return
E_NOINTERFACE
;
}
STDMETHODIMP_
(
ULONG
)
nsNativeDragTarget
:
:
AddRef
(
void
)
{
+
+
m_cRef
;
NS_LOG_ADDREF
(
this
m_cRef
"
nsNativeDragTarget
"
sizeof
(
*
this
)
)
;
return
m_cRef
;
}
STDMETHODIMP_
(
ULONG
)
nsNativeDragTarget
:
:
Release
(
void
)
{
-
-
m_cRef
;
NS_LOG_RELEASE
(
this
m_cRef
"
nsNativeDragTarget
"
)
;
if
(
0
!
=
m_cRef
)
return
m_cRef
;
delete
this
;
return
0
;
}
void
nsNativeDragTarget
:
:
GetGeckoDragAction
(
DWORD
grfKeyState
LPDWORD
pdwEffect
uint32_t
*
aGeckoAction
)
{
if
(
!
mWidget
-
>
IsEnabled
(
)
)
{
LOGD
(
"
[
%
p
]
%
s
|
window
was
not
enabled
"
this
__FUNCTION__
)
;
*
pdwEffect
=
DROPEFFECT_NONE
;
*
aGeckoAction
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
return
;
}
DWORD
desiredEffect
=
DROPEFFECT_NONE
;
if
(
(
grfKeyState
&
MK_CONTROL
)
&
&
(
grfKeyState
&
MK_SHIFT
)
)
{
desiredEffect
=
DROPEFFECT_LINK
;
}
else
if
(
grfKeyState
&
MK_SHIFT
)
{
desiredEffect
=
DROPEFFECT_MOVE
;
}
else
if
(
grfKeyState
&
MK_CONTROL
)
{
desiredEffect
=
DROPEFFECT_COPY
;
}
if
(
!
(
desiredEffect
&
=
mEffectsAllowed
)
)
{
desiredEffect
=
mEffectsPreferred
&
mEffectsAllowed
;
if
(
!
desiredEffect
)
{
desiredEffect
=
mEffectsAllowed
;
}
}
if
(
desiredEffect
&
DROPEFFECT_MOVE
)
{
*
pdwEffect
=
DROPEFFECT_MOVE
;
*
aGeckoAction
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
}
else
if
(
desiredEffect
&
DROPEFFECT_COPY
)
{
*
pdwEffect
=
DROPEFFECT_COPY
;
*
aGeckoAction
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
}
else
if
(
desiredEffect
&
DROPEFFECT_LINK
)
{
*
pdwEffect
=
DROPEFFECT_LINK
;
*
aGeckoAction
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
}
else
{
*
pdwEffect
=
DROPEFFECT_NONE
;
*
aGeckoAction
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
}
LOGD
(
"
[
%
p
]
%
s
|
grfKeyState
:
%
lu
|
desiredEffect
:
%
lu
|
mEffectsAllowed
:
%
lu
"
"
|
mEffectsPreferred
:
%
lu
|
*
pdwEffect
:
%
lu
|
*
aGeckoAction
:
%
u
"
this
__FUNCTION__
grfKeyState
desiredEffect
mEffectsAllowed
mEffectsPreferred
*
pdwEffect
*
aGeckoAction
)
;
}
inline
bool
IsKeyDown
(
char
key
)
{
return
GetKeyState
(
key
)
<
0
;
}
void
nsNativeDragTarget
:
:
DispatchDragDropEvent
(
EventMessage
aEventMessage
const
POINTL
&
aPT
)
{
WidgetDragEvent
event
(
true
aEventMessage
mWidget
)
;
nsWindow
*
win
=
static_cast
<
nsWindow
*
>
(
mWidget
)
;
win
-
>
InitEvent
(
event
)
;
POINT
cpos
;
cpos
.
x
=
aPT
.
x
;
cpos
.
y
=
aPT
.
y
;
if
(
mHWnd
!
=
nullptr
)
{
:
:
ScreenToClient
(
mHWnd
&
cpos
)
;
}
else
{
cpos
=
{
0
0
}
;
}
event
.
mRefPoint
=
LayoutDeviceIntPoint
(
cpos
.
x
cpos
.
y
)
;
ModifierKeyState
modifierKeyState
;
modifierKeyState
.
InitInputEvent
(
event
)
;
nsDragSession
*
currSession
=
static_cast
<
nsDragSession
*
>
(
mDragService
-
>
GetCurrentSession
(
mWidget
)
)
;
if
(
currSession
)
{
event
.
mInputSource
=
currSession
-
>
GetInputSource
(
)
;
}
else
{
event
.
mInputSource
=
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
;
}
LOGI
(
"
[
%
p
]
%
s
|
Dispatching
%
s
event
at
client
pos
(
%
ld
%
ld
)
"
this
__FUNCTION__
NS_ConvertUTF16toUTF8
(
dom
:
:
Event
:
:
GetEventName
(
aEventMessage
)
)
.
get
(
)
cpos
.
x
cpos
.
y
)
;
mWidget
-
>
DispatchInputEvent
(
&
event
)
;
}
void
nsNativeDragTarget
:
:
ProcessDrag
(
EventMessage
aEventMessage
DWORD
grfKeyState
POINTL
ptl
DWORD
*
pdwEffect
)
{
uint32_t
geckoAction
;
GetGeckoDragAction
(
grfKeyState
pdwEffect
&
geckoAction
)
;
RefPtr
<
nsDragSession
>
currSession
=
static_cast
<
nsDragSession
*
>
(
mDragService
-
>
GetCurrentSession
(
mWidget
)
)
;
if
(
!
currSession
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
active
drag
session
"
this
__FUNCTION__
)
;
return
;
}
currSession
-
>
SetDragAction
(
geckoAction
)
;
DispatchDragDropEvent
(
aEventMessage
ptl
)
;
currSession
-
>
GetDragAction
(
&
geckoAction
)
;
int32_t
childDragAction
=
currSession
-
>
TakeChildProcessDragAction
(
)
;
if
(
childDragAction
!
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
{
geckoAction
=
childDragAction
;
}
if
(
nsIDragService
:
:
DRAGDROP_ACTION_LINK
&
geckoAction
)
{
*
pdwEffect
=
DROPEFFECT_LINK
;
}
else
if
(
nsIDragService
:
:
DRAGDROP_ACTION_COPY
&
geckoAction
)
{
*
pdwEffect
=
DROPEFFECT_COPY
;
}
else
if
(
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
&
geckoAction
)
{
*
pdwEffect
=
DROPEFFECT_MOVE
;
}
else
{
*
pdwEffect
=
DROPEFFECT_NONE
;
}
if
(
aEventMessage
!
=
eDrop
)
{
bool
canDrop
;
currSession
-
>
GetCanDrop
(
&
canDrop
)
;
if
(
!
canDrop
)
{
*
pdwEffect
=
DROPEFFECT_NONE
;
}
}
LOGD
(
"
[
%
p
]
%
s
|
grfKeyState
:
%
lu
|
mEffectsAllowed
:
%
lu
|
"
"
mEffectsPreferred
:
%
lu
|
*
pdwEffect
:
%
lu
|
post
dispatch
geckoAction
:
"
"
%
u
"
this
__FUNCTION__
grfKeyState
mEffectsAllowed
mEffectsPreferred
*
pdwEffect
geckoAction
)
;
currSession
-
>
SetCanDrop
(
false
)
;
}
STDMETHODIMP
nsNativeDragTarget
:
:
DragEnter
(
LPDATAOBJECT
pIDataSource
DWORD
grfKeyState
POINTL
ptl
DWORD
*
pdwEffect
)
{
if
(
!
mDragService
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
drag
service
"
this
__FUNCTION__
)
;
return
E_FAIL
;
}
mEffectsAllowed
=
*
pdwEffect
;
AddLinkSupportIfCanBeGenerated
(
pIDataSource
)
;
if
(
GetDropTargetHelper
(
)
)
{
GetDropTargetHelper
(
)
-
>
DragLeave
(
)
;
POINT
pt
=
{
ptl
.
x
ptl
.
y
}
;
GetDropTargetHelper
(
)
-
>
DragEnter
(
mHWnd
pIDataSource
&
pt
*
pdwEffect
)
;
}
NS_ASSERTION
(
!
mTookOwnRef
"
own
ref
already
taken
!
"
)
;
this
-
>
AddRef
(
)
;
mTookOwnRef
=
true
;
RefPtr
<
nsDragSession
>
session
=
static_cast
<
nsDragSession
*
>
(
mDragService
-
>
StartDragSession
(
mWidget
)
)
;
MOZ_ASSERT
(
session
)
;
void
*
tempOutData
=
nullptr
;
uint32_t
tempDataLen
=
0
;
nsresult
loadResult
=
nsClipboard
:
:
GetNativeDataOffClipboard
(
pIDataSource
0
:
:
RegisterClipboardFormat
(
CFSTR_PREFERREDDROPEFFECT
)
nullptr
&
tempOutData
&
tempDataLen
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
tempOutData
)
{
mEffectsPreferred
=
*
(
(
DWORD
*
)
tempOutData
)
;
free
(
tempOutData
)
;
}
else
{
mEffectsPreferred
=
DROPEFFECT_NONE
;
}
LOGD
(
"
[
%
p
]
%
s
|
grfKeyState
:
%
lu
|
ptl
:
(
%
ld
%
ld
)
|
mEffectsAllowed
:
%
lu
"
"
|
mEffectsPreferred
:
%
lu
"
this
__FUNCTION__
grfKeyState
ptl
.
x
ptl
.
y
mEffectsAllowed
mEffectsPreferred
)
;
session
-
>
SetIDataObject
(
pIDataSource
)
;
ProcessDrag
(
eDragEnter
grfKeyState
ptl
pdwEffect
)
;
return
S_OK
;
}
void
nsNativeDragTarget
:
:
AddLinkSupportIfCanBeGenerated
(
LPDATAOBJECT
aIDataSource
)
{
if
(
!
(
mEffectsAllowed
&
DROPEFFECT_LINK
)
&
&
aIDataSource
)
{
if
(
S_OK
=
=
:
:
OleQueryLinkFromData
(
aIDataSource
)
)
{
mEffectsAllowed
|
=
DROPEFFECT_LINK
;
}
}
}
STDMETHODIMP
nsNativeDragTarget
:
:
DragOver
(
DWORD
grfKeyState
POINTL
ptl
LPDWORD
pdwEffect
)
{
if
(
!
mDragService
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
drag
service
"
this
__FUNCTION__
)
;
return
E_FAIL
;
}
bool
dragImageChanged
=
gDragImageChanged
;
gDragImageChanged
=
false
;
mEffectsAllowed
=
(
*
pdwEffect
)
|
(
mEffectsAllowed
&
DROPEFFECT_LINK
)
;
RefPtr
<
nsDragSession
>
currentDragSession
=
static_cast
<
nsDragSession
*
>
(
mDragService
-
>
GetCurrentSession
(
mWidget
)
)
;
if
(
!
currentDragSession
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
drag
session
"
this
__FUNCTION__
)
;
return
S_OK
;
}
this
-
>
AddRef
(
)
;
if
(
GetDropTargetHelper
(
)
)
{
if
(
dragImageChanged
)
{
GetDropTargetHelper
(
)
-
>
DragLeave
(
)
;
POINT
pt
=
{
ptl
.
x
ptl
.
y
}
;
GetDropTargetHelper
(
)
-
>
DragEnter
(
mHWnd
currentDragSession
-
>
GetDataObject
(
)
&
pt
*
pdwEffect
)
;
}
POINT
pt
=
{
ptl
.
x
ptl
.
y
}
;
GetDropTargetHelper
(
)
-
>
DragOver
(
&
pt
*
pdwEffect
)
;
}
LOGD
(
"
[
%
p
]
%
s
|
grfKeyState
:
%
lu
|
ptl
:
(
%
ld
%
ld
)
|
*
pdwEffect
:
%
lu
|
"
"
mEffectsAllowed
:
%
lu
|
dragImageChanged
:
%
s
"
this
__FUNCTION__
grfKeyState
ptl
.
x
ptl
.
y
*
pdwEffect
mEffectsAllowed
GetBoolName
(
dragImageChanged
)
)
;
LOGI
(
"
[
%
p
]
%
s
|
Firing
'
drag
'
event
at
drag
source
if
available
"
this
__FUNCTION__
)
;
ModifierKeyState
modifierKeyState
;
currentDragSession
-
>
FireDragEventAtSource
(
eDrag
modifierKeyState
.
GetModifiers
(
)
)
;
LOGI
(
"
[
%
p
]
%
s
|
Firing
'
dragover
'
event
at
drag
target
"
this
__FUNCTION__
)
;
ProcessDrag
(
eDragOver
grfKeyState
ptl
pdwEffect
)
;
this
-
>
Release
(
)
;
return
S_OK
;
}
STDMETHODIMP
nsNativeDragTarget
:
:
DragLeave
(
)
{
if
(
!
mDragService
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
drag
service
"
this
__FUNCTION__
)
;
return
E_FAIL
;
}
if
(
GetDropTargetHelper
(
)
)
{
GetDropTargetHelper
(
)
-
>
DragLeave
(
)
;
}
LOGI
(
"
[
%
p
]
%
s
|
dispatching
dragexit
event
"
this
__FUNCTION__
)
;
DispatchDragDropEvent
(
eDragExit
gDragLastPoint
)
;
nsCOMPtr
<
nsIDragSession
>
currentDragSession
=
mDragService
-
>
GetCurrentSession
(
mWidget
)
;
if
(
currentDragSession
)
{
nsCOMPtr
<
nsINode
>
sourceNode
;
currentDragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
LOGI
(
"
[
%
p
]
%
s
|
ending
drag
session
with
external
(
non
-
Gecko
)
source
"
this
__FUNCTION__
)
;
ModifierKeyState
modifierKeyState
;
currentDragSession
-
>
EndDragSession
(
false
modifierKeyState
.
GetModifiers
(
)
)
;
}
}
NS_ASSERTION
(
mTookOwnRef
"
want
to
release
own
ref
but
not
taken
!
"
)
;
if
(
mTookOwnRef
)
{
this
-
>
Release
(
)
;
mTookOwnRef
=
false
;
}
return
S_OK
;
}
void
nsNativeDragTarget
:
:
DragCancel
(
)
{
LOGD
(
"
[
%
p
]
%
s
"
this
__FUNCTION__
)
;
if
(
mTookOwnRef
)
{
if
(
GetDropTargetHelper
(
)
)
{
GetDropTargetHelper
(
)
-
>
DragLeave
(
)
;
}
if
(
mDragService
)
{
ModifierKeyState
modifierKeyState
;
RefPtr
<
nsIDragSession
>
session
=
mDragService
-
>
GetCurrentSession
(
mWidget
)
;
if
(
session
)
{
LOGI
(
"
[
%
p
]
%
s
|
modifier
-
keys
:
%
u
|
ending
canceled
drag
session
"
this
__FUNCTION__
modifierKeyState
.
GetModifiers
(
)
)
;
session
-
>
EndDragSession
(
false
modifierKeyState
.
GetModifiers
(
)
)
;
}
}
this
-
>
Release
(
)
;
mTookOwnRef
=
false
;
}
}
STDMETHODIMP
nsNativeDragTarget
:
:
Drop
(
LPDATAOBJECT
pData
DWORD
grfKeyState
POINTL
aPT
LPDWORD
pdwEffect
)
{
if
(
!
mDragService
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
drag
service
"
this
__FUNCTION__
)
;
return
E_FAIL
;
}
mEffectsAllowed
=
*
pdwEffect
;
AddLinkSupportIfCanBeGenerated
(
pData
)
;
if
(
GetDropTargetHelper
(
)
)
{
POINT
pt
=
{
aPT
.
x
aPT
.
y
}
;
GetDropTargetHelper
(
)
-
>
Drop
(
pData
&
pt
*
pdwEffect
)
;
}
RefPtr
<
nsDragSession
>
currentDragSession
=
static_cast
<
nsDragSession
*
>
(
mDragService
-
>
GetCurrentSession
(
mWidget
)
)
;
if
(
!
currentDragSession
)
{
LOGD
(
"
[
%
p
]
%
s
|
No
drag
session
"
this
__FUNCTION__
)
;
return
S_OK
;
}
currentDragSession
-
>
SetIDataObject
(
pData
)
;
RefPtr
<
nsNativeDragTarget
>
kungFuDeathGrip
=
this
;
LOGI
(
"
[
%
p
]
%
s
|
grfKeyState
:
%
lu
|
aPT
:
(
%
ld
%
ld
)
|
*
pdwEffect
:
%
lu
|
"
"
dispatching
drop
event
"
this
__FUNCTION__
grfKeyState
aPT
.
x
aPT
.
y
*
pdwEffect
)
;
ProcessDrag
(
eDrop
grfKeyState
aPT
pdwEffect
)
;
currentDragSession
=
static_cast
<
nsDragSession
*
>
(
mDragService
-
>
GetCurrentSession
(
mWidget
)
)
;
if
(
!
currentDragSession
)
{
LOGD
(
"
[
%
p
]
%
s
|
Drag
session
was
canceled
during
drop
event
"
this
__FUNCTION__
)
;
return
S_OK
;
}
currentDragSession
-
>
SetDroppedLocal
(
)
;
DWORD
pos
=
:
:
GetMessagePos
(
)
;
POINT
cpos
;
cpos
.
x
=
GET_X_LPARAM
(
pos
)
;
cpos
.
y
=
GET_Y_LPARAM
(
pos
)
;
currentDragSession
-
>
SetDragEndPoint
(
cpos
.
x
cpos
.
y
)
;
ModifierKeyState
modifierKeyState
;
LOGI
(
"
[
%
p
]
%
s
|
position
:
(
%
lu
%
lu
)
|
modifier
-
keys
:
%
u
|
ending
completed
"
"
drag
session
"
this
__FUNCTION__
cpos
.
x
cpos
.
y
modifierKeyState
.
GetModifiers
(
)
)
;
currentDragSession
-
>
EndDragSession
(
true
modifierKeyState
.
GetModifiers
(
)
)
;
NS_ASSERTION
(
mTookOwnRef
"
want
to
release
own
ref
but
not
taken
!
"
)
;
if
(
mTookOwnRef
)
{
this
-
>
Release
(
)
;
mTookOwnRef
=
false
;
}
return
S_OK
;
}
IDropTargetHelper
*
nsNativeDragTarget
:
:
GetDropTargetHelper
(
)
{
if
(
!
mDropTargetHelper
)
{
CoCreateInstance
(
CLSID_DragDropHelper
nullptr
CLSCTX_INPROC_SERVER
IID_IDropTargetHelper
(
LPVOID
*
)
&
mDropTargetHelper
)
;
}
return
mDropTargetHelper
;
}
