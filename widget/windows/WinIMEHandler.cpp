#
include
"
WinIMEHandler
.
h
"
#
include
"
IMMHandler
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsWindowDefs
.
h
"
#
include
"
WinTextEventDispatcherListener
.
h
"
#
include
"
TSFTextStore
.
h
"
#
include
"
OSKInputPaneManager
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
nsIWindowsRegKey
.
h
"
#
include
"
nsIWindowsUIUtils
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
shellapi
.
h
"
#
include
"
shlobj
.
h
"
#
include
"
powrprof
.
h
"
#
include
"
setupapi
.
h
"
#
include
"
cfgmgr32
.
h
"
#
include
"
FxRWindowManager
.
h
"
#
include
"
VRShMem
.
h
"
#
include
"
moz_external_vr
.
h
"
const
char
*
kOskPathPrefName
=
"
ui
.
osk
.
on_screen_keyboard_path
"
;
const
char
*
kOskEnabled
=
"
ui
.
osk
.
enabled
"
;
const
char
*
kOskDetectPhysicalKeyboard
=
"
ui
.
osk
.
detect_physical_keyboard
"
;
const
char
*
kOskRequireWin10
=
"
ui
.
osk
.
require_win10
"
;
const
char
*
kOskDebugReason
=
"
ui
.
osk
.
debug
.
keyboardDisplayReason
"
;
namespace
mozilla
{
namespace
widget
{
nsWindow
*
IMEHandler
:
:
sFocusedWindow
=
nullptr
;
InputContextAction
:
:
Cause
IMEHandler
:
:
sLastContextActionCause
=
InputContextAction
:
:
CAUSE_UNKNOWN
;
bool
IMEHandler
:
:
sMaybeEditable
=
false
;
bool
IMEHandler
:
:
sForceDisableCurrentIMM_IME
=
false
;
bool
IMEHandler
:
:
sPluginHasFocus
=
false
;
bool
IMEHandler
:
:
sNativeCaretIsCreated
=
false
;
bool
IMEHandler
:
:
sHasNativeCaretBeenRequested
=
false
;
bool
IMEHandler
:
:
sIsInTSFMode
=
false
;
bool
IMEHandler
:
:
sIsIMMEnabled
=
true
;
bool
IMEHandler
:
:
sAssociateIMCOnlyWhenIMM_IMEActive
=
false
;
decltype
(
SetInputScopes
)
*
IMEHandler
:
:
sSetInputScopes
=
nullptr
;
static
POWER_PLATFORM_ROLE
sPowerPlatformRole
=
PlatformRoleUnspecified
;
static
bool
sDeterminedPowerPlatformRole
=
false
;
void
IMEHandler
:
:
Initialize
(
)
{
TSFTextStore
:
:
Initialize
(
)
;
sIsInTSFMode
=
TSFTextStore
:
:
IsInTSFMode
(
)
;
sIsIMMEnabled
=
!
sIsInTSFMode
|
|
Preferences
:
:
GetBool
(
"
intl
.
tsf
.
support_imm
"
true
)
;
sAssociateIMCOnlyWhenIMM_IMEActive
=
sIsIMMEnabled
&
&
Preferences
:
:
GetBool
(
"
intl
.
tsf
.
associate_imc_only_when_imm_ime_is_active
"
false
)
;
if
(
!
sIsInTSFMode
)
{
HMODULE
module
=
nullptr
;
if
(
GetModuleHandleExW
(
GET_MODULE_HANDLE_EX_FLAG_PIN
L
"
msctf
.
dll
"
&
module
)
)
{
sSetInputScopes
=
reinterpret_cast
<
decltype
(
SetInputScopes
)
*
>
(
GetProcAddress
(
module
"
SetInputScopes
"
)
)
;
}
}
IMMHandler
:
:
Initialize
(
)
;
sForceDisableCurrentIMM_IME
=
IMMHandler
:
:
IsActiveIMEInBlockList
(
)
;
}
void
IMEHandler
:
:
Terminate
(
)
{
if
(
sIsInTSFMode
)
{
TSFTextStore
:
:
Terminate
(
)
;
sIsInTSFMode
=
false
;
}
IMMHandler
:
:
Terminate
(
)
;
WinTextEventDispatcherListener
:
:
Shutdown
(
)
;
}
void
*
IMEHandler
:
:
GetNativeData
(
nsWindow
*
aWindow
uint32_t
aDataType
)
{
if
(
aDataType
=
=
NS_RAW_NATIVE_IME_CONTEXT
)
{
if
(
IsTSFAvailable
(
)
)
{
return
TSFTextStore
:
:
GetThreadManager
(
)
;
}
IMEContext
context
(
aWindow
)
;
if
(
context
.
IsValid
(
)
)
{
return
context
.
get
(
)
;
}
const
IMEContext
&
defaultIMC
=
aWindow
-
>
DefaultIMC
(
)
;
if
(
defaultIMC
.
IsValid
(
)
)
{
return
defaultIMC
.
get
(
)
;
}
return
aWindow
;
}
void
*
result
=
TSFTextStore
:
:
GetNativeData
(
aDataType
)
;
if
(
!
result
|
|
!
(
*
(
static_cast
<
void
*
*
>
(
result
)
)
)
)
{
return
nullptr
;
}
sIsInTSFMode
=
true
;
return
result
;
}
bool
IMEHandler
:
:
ProcessRawKeyMessage
(
const
MSG
&
aMsg
)
{
if
(
IsTSFAvailable
(
)
)
{
return
TSFTextStore
:
:
ProcessRawKeyMessage
(
aMsg
)
;
}
return
false
;
}
bool
IMEHandler
:
:
ProcessMessage
(
nsWindow
*
aWindow
UINT
aMessage
WPARAM
&
aWParam
LPARAM
&
aLParam
MSGResult
&
aResult
)
{
if
(
!
sHasNativeCaretBeenRequested
&
&
aMessage
=
=
WM_GETOBJECT
&
&
static_cast
<
DWORD
>
(
aLParam
)
=
=
OBJID_CARET
)
{
sHasNativeCaretBeenRequested
=
true
;
MaybeCreateNativeCaret
(
aWindow
)
;
}
if
(
IsTSFAvailable
(
)
)
{
TSFTextStore
:
:
ProcessMessage
(
aWindow
aMessage
aWParam
aLParam
aResult
)
;
if
(
aResult
.
mConsumed
)
{
return
true
;
}
if
(
!
sIsIMMEnabled
)
{
return
false
;
}
if
(
!
IsIMMActive
(
)
)
{
return
false
;
}
}
bool
keepGoing
=
IMMHandler
:
:
ProcessMessage
(
aWindow
aMessage
aWParam
aLParam
aResult
)
;
if
(
aMessage
=
=
WM_INPUTLANGCHANGE
)
{
bool
disableIME
=
IMMHandler
:
:
IsActiveIMEInBlockList
(
)
;
if
(
disableIME
!
=
sForceDisableCurrentIMM_IME
)
{
bool
enable
=
!
disableIME
&
&
WinUtils
:
:
IsIMEEnabled
(
aWindow
-
>
InputContextRef
(
)
)
;
AssociateIMEContext
(
aWindow
enable
)
;
sForceDisableCurrentIMM_IME
=
disableIME
;
}
}
return
keepGoing
;
}
bool
IMEHandler
:
:
IsA11yHandlingNativeCaret
(
)
{
#
ifndef
ACCESSIBILITY
return
false
;
#
else
return
GetAccService
(
)
!
=
nullptr
;
#
endif
}
bool
IMEHandler
:
:
IsIMMActive
(
)
{
return
TSFTextStore
:
:
IsIMM_IMEActive
(
)
;
}
bool
IMEHandler
:
:
IsComposing
(
)
{
if
(
IsTSFAvailable
(
)
)
{
return
TSFTextStore
:
:
IsComposing
(
)
|
|
IMMHandler
:
:
IsComposing
(
)
;
}
return
IMMHandler
:
:
IsComposing
(
)
;
}
bool
IMEHandler
:
:
IsComposingOn
(
nsWindow
*
aWindow
)
{
if
(
IsTSFAvailable
(
)
)
{
return
TSFTextStore
:
:
IsComposingOn
(
aWindow
)
|
|
IMMHandler
:
:
IsComposingOn
(
aWindow
)
;
}
return
IMMHandler
:
:
IsComposingOn
(
aWindow
)
;
}
nsresult
IMEHandler
:
:
NotifyIME
(
nsWindow
*
aWindow
const
IMENotification
&
aIMENotification
)
{
if
(
IsTSFAvailable
(
)
)
{
switch
(
aIMENotification
.
mMessage
)
{
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
{
nsresult
rv
=
TSFTextStore
:
:
OnSelectionChange
(
aIMENotification
)
;
bool
isIMMActive
=
IsIMMActive
(
)
;
if
(
isIMMActive
)
{
IMMHandler
:
:
OnUpdateComposition
(
aWindow
)
;
}
IMMHandler
:
:
OnSelectionChange
(
aWindow
aIMENotification
isIMMActive
)
;
return
rv
;
}
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
if
(
IsIMMActive
(
)
)
{
IMMHandler
:
:
OnUpdateComposition
(
aWindow
)
;
}
else
{
TSFTextStore
:
:
OnUpdateComposition
(
)
;
}
return
NS_OK
;
case
NOTIFY_IME_OF_TEXT_CHANGE
:
return
TSFTextStore
:
:
OnTextChange
(
aIMENotification
)
;
case
NOTIFY_IME_OF_FOCUS
:
{
sFocusedWindow
=
aWindow
;
IMMHandler
:
:
OnFocusChange
(
true
aWindow
)
;
nsresult
rv
=
TSFTextStore
:
:
OnFocusChange
(
true
aWindow
aWindow
-
>
GetInputContext
(
)
)
;
MaybeCreateNativeCaret
(
aWindow
)
;
IMEHandler
:
:
MaybeShowOnScreenKeyboard
(
aWindow
aWindow
-
>
GetInputContext
(
)
)
;
return
rv
;
}
case
NOTIFY_IME_OF_BLUR
:
sFocusedWindow
=
nullptr
;
IMEHandler
:
:
MaybeDismissOnScreenKeyboard
(
aWindow
)
;
IMMHandler
:
:
OnFocusChange
(
false
aWindow
)
;
return
TSFTextStore
:
:
OnFocusChange
(
false
aWindow
aWindow
-
>
GetInputContext
(
)
)
;
case
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
:
if
(
IsIMMActive
(
)
)
{
return
IMMHandler
:
:
OnMouseButtonEvent
(
aWindow
aIMENotification
)
;
}
return
TSFTextStore
:
:
OnMouseButtonEvent
(
aIMENotification
)
;
case
REQUEST_TO_COMMIT_COMPOSITION
:
if
(
TSFTextStore
:
:
IsComposingOn
(
aWindow
)
)
{
TSFTextStore
:
:
CommitComposition
(
false
)
;
}
else
if
(
IsIMMActive
(
)
)
{
IMMHandler
:
:
CommitComposition
(
aWindow
)
;
}
return
NS_OK
;
case
REQUEST_TO_CANCEL_COMPOSITION
:
if
(
TSFTextStore
:
:
IsComposingOn
(
aWindow
)
)
{
TSFTextStore
:
:
CommitComposition
(
true
)
;
}
else
if
(
IsIMMActive
(
)
)
{
IMMHandler
:
:
CancelComposition
(
aWindow
)
;
}
return
NS_OK
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
return
TSFTextStore
:
:
OnLayoutChange
(
)
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
switch
(
aIMENotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
IMMHandler
:
:
CommitComposition
(
aWindow
)
;
return
NS_OK
;
case
REQUEST_TO_CANCEL_COMPOSITION
:
IMMHandler
:
:
CancelComposition
(
aWindow
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
IMMHandler
:
:
OnUpdateComposition
(
aWindow
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
IMMHandler
:
:
OnSelectionChange
(
aWindow
aIMENotification
true
)
;
MaybeCreateNativeCaret
(
aWindow
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
:
return
IMMHandler
:
:
OnMouseButtonEvent
(
aWindow
aIMENotification
)
;
case
NOTIFY_IME_OF_FOCUS
:
sFocusedWindow
=
aWindow
;
IMMHandler
:
:
OnFocusChange
(
true
aWindow
)
;
IMEHandler
:
:
MaybeShowOnScreenKeyboard
(
aWindow
aWindow
-
>
GetInputContext
(
)
)
;
MaybeCreateNativeCaret
(
aWindow
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_BLUR
:
sFocusedWindow
=
nullptr
;
IMEHandler
:
:
MaybeDismissOnScreenKeyboard
(
aWindow
)
;
IMMHandler
:
:
OnFocusChange
(
false
aWindow
)
;
if
(
TSFTextStore
:
:
ThinksHavingFocus
(
)
)
{
return
TSFTextStore
:
:
OnFocusChange
(
false
aWindow
aWindow
-
>
GetInputContext
(
)
)
;
}
return
NS_OK
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
IMENotificationRequests
IMEHandler
:
:
GetIMENotificationRequests
(
)
{
if
(
sPluginHasFocus
)
{
return
IMENotificationRequests
(
)
;
}
if
(
IsTSFAvailable
(
)
)
{
if
(
!
sIsIMMEnabled
)
{
return
TSFTextStore
:
:
GetIMENotificationRequests
(
)
;
}
return
IMMHandler
:
:
GetIMENotificationRequests
(
)
|
TSFTextStore
:
:
GetIMENotificationRequests
(
)
;
}
return
IMMHandler
:
:
GetIMENotificationRequests
(
)
;
}
TextEventDispatcherListener
*
IMEHandler
:
:
GetNativeTextEventDispatcherListener
(
)
{
return
WinTextEventDispatcherListener
:
:
GetInstance
(
)
;
}
bool
IMEHandler
:
:
GetOpenState
(
nsWindow
*
aWindow
)
{
if
(
IsTSFAvailable
(
)
&
&
!
IsIMMActive
(
)
)
{
return
TSFTextStore
:
:
GetIMEOpenState
(
)
;
}
IMEContext
context
(
aWindow
)
;
return
context
.
GetOpenState
(
)
;
}
void
IMEHandler
:
:
OnDestroyWindow
(
nsWindow
*
aWindow
)
{
if
(
sFocusedWindow
=
=
aWindow
)
{
MOZ_ASSERT
(
aWindow
-
>
GetInputContext
(
)
.
IsOriginContentProcess
(
)
"
input
context
of
focused
widget
should
'
ve
been
set
by
a
remote
"
"
process
"
"
if
IME
focus
isn
'
t
cleared
before
destroying
the
widget
"
)
;
NotifyIME
(
aWindow
IMENotification
(
NOTIFY_IME_OF_BLUR
)
)
;
}
if
(
!
sIsInTSFMode
)
{
SetInputScopeForIMM32
(
aWindow
u
"
"
_ns
u
"
"
_ns
false
)
;
}
AssociateIMEContext
(
aWindow
true
)
;
}
bool
IMEHandler
:
:
NeedsToAssociateIMC
(
)
{
return
!
sForceDisableCurrentIMM_IME
&
&
(
!
sAssociateIMCOnlyWhenIMM_IMEActive
|
|
!
IsIMMActive
(
)
)
;
}
void
IMEHandler
:
:
SetInputContext
(
nsWindow
*
aWindow
InputContext
&
aInputContext
const
InputContextAction
&
aAction
)
{
sLastContextActionCause
=
aAction
.
mCause
;
NotifyIME
(
aWindow
IMENotification
(
REQUEST_TO_COMMIT_COMPOSITION
)
)
;
const
InputContext
&
oldInputContext
=
aWindow
-
>
GetInputContext
(
)
;
sPluginHasFocus
=
(
aInputContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
;
if
(
sPluginHasFocus
)
{
aWindow
-
>
DispatchPluginSettingEvents
(
)
;
}
if
(
aInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
none
"
)
)
{
IMEHandler
:
:
MaybeDismissOnScreenKeyboard
(
aWindow
Sync
:
:
Yes
)
;
}
else
if
(
aAction
.
UserMightRequestOpenVKB
(
)
)
{
IMEHandler
:
:
MaybeShowOnScreenKeyboard
(
aWindow
aInputContext
)
;
}
bool
enable
=
WinUtils
:
:
IsIMEEnabled
(
aInputContext
)
;
bool
adjustOpenState
=
(
enable
&
&
aInputContext
.
mIMEState
.
mOpen
!
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
)
;
bool
open
=
(
adjustOpenState
&
&
aInputContext
.
mIMEState
.
mOpen
=
=
IMEState
:
:
OPEN
)
;
if
(
sIsInTSFMode
)
{
TSFTextStore
:
:
SetInputContext
(
aWindow
aInputContext
aAction
)
;
if
(
IsTSFAvailable
(
)
)
{
if
(
sIsIMMEnabled
)
{
AssociateIMEContext
(
aWindow
enable
&
&
NeedsToAssociateIMC
(
)
)
;
}
else
if
(
oldInputContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
{
AssociateIMEContext
(
aWindow
false
)
;
}
if
(
adjustOpenState
)
{
TSFTextStore
:
:
SetIMEOpenState
(
open
)
;
}
return
;
}
}
else
{
SetInputScopeForIMM32
(
aWindow
aInputContext
.
mHTMLInputType
aInputContext
.
mHTMLInputInputmode
aInputContext
.
mInPrivateBrowsing
)
;
}
AssociateIMEContext
(
aWindow
enable
)
;
IMEContext
context
(
aWindow
)
;
if
(
adjustOpenState
)
{
context
.
SetOpenState
(
open
)
;
}
}
void
IMEHandler
:
:
AssociateIMEContext
(
nsWindowBase
*
aWindowBase
bool
aEnable
)
{
IMEContext
context
(
aWindowBase
)
;
if
(
aEnable
)
{
context
.
AssociateDefaultContext
(
)
;
return
;
}
if
(
aWindowBase
-
>
Destroyed
(
)
)
{
return
;
}
context
.
Disassociate
(
)
;
}
void
IMEHandler
:
:
InitInputContext
(
nsWindow
*
aWindow
InputContext
&
aInputContext
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
aWindow
-
>
GetWindowHandle
(
)
"
IMEHandler
:
:
SetInputContext
(
)
requires
non
-
nullptr
HWND
"
)
;
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
sInitialized
=
true
;
Initialize
(
)
;
}
aInputContext
.
mIMEState
.
mEnabled
=
IMEState
:
:
ENABLED
;
if
(
sIsInTSFMode
)
{
TSFTextStore
:
:
SetInputContext
(
aWindow
aInputContext
InputContextAction
(
InputContextAction
:
:
CAUSE_UNKNOWN
InputContextAction
:
:
WIDGET_CREATED
)
)
;
if
(
!
sIsIMMEnabled
)
{
AssociateIMEContext
(
aWindow
false
)
;
}
return
;
}
#
ifdef
DEBUG
IMEContext
context
(
aWindow
)
;
MOZ_ASSERT
(
context
.
IsValid
(
)
|
|
!
CurrentKeyboardLayoutHasIME
(
)
)
;
#
endif
}
#
ifdef
DEBUG
bool
IMEHandler
:
:
CurrentKeyboardLayoutHasIME
(
)
{
if
(
sIsInTSFMode
)
{
return
TSFTextStore
:
:
CurrentKeyboardLayoutHasIME
(
)
;
}
return
IMMHandler
:
:
IsIMEAvailable
(
)
;
}
#
endif
void
IMEHandler
:
:
OnKeyboardLayoutChanged
(
)
{
if
(
!
sIsIMMEnabled
|
|
!
IsTSFAvailable
(
)
)
{
return
;
}
if
(
!
sAssociateIMCOnlyWhenIMM_IMEActive
)
{
return
;
}
nsWindowBase
*
windowBase
=
TSFTextStore
:
:
GetEnabledWindowBase
(
)
;
if
(
!
windowBase
)
{
return
;
}
InputContext
inputContext
=
windowBase
-
>
GetInputContext
(
)
;
if
(
!
WinUtils
:
:
IsIMEEnabled
(
inputContext
)
)
{
return
;
}
AssociateIMEContext
(
windowBase
NeedsToAssociateIMC
(
)
)
;
}
void
IMEHandler
:
:
SetInputScopeForIMM32
(
nsWindow
*
aWindow
const
nsAString
&
aHTMLInputType
const
nsAString
&
aHTMLInputInputmode
bool
aInPrivateBrowsing
)
{
if
(
sIsInTSFMode
|
|
!
sSetInputScopes
|
|
aWindow
-
>
Destroyed
(
)
)
{
return
;
}
AutoTArray
<
InputScope
3
>
scopes
;
AppendInputScopeFromType
(
aHTMLInputType
scopes
)
;
AppendInputScopeFromInputmode
(
aHTMLInputInputmode
scopes
)
;
if
(
aInPrivateBrowsing
)
{
scopes
.
AppendElement
(
IS_PRIVATE
)
;
}
if
(
scopes
.
IsEmpty
(
)
)
{
scopes
.
AppendElement
(
IS_DEFAULT
)
;
}
sSetInputScopes
(
aWindow
-
>
GetWindowHandle
(
)
scopes
.
Elements
(
)
scopes
.
Length
(
)
nullptr
0
nullptr
nullptr
)
;
}
void
IMEHandler
:
:
AppendInputScopeFromInputmode
(
const
nsAString
&
aInputmode
nsTArray
<
InputScope
>
&
aScopes
)
{
if
(
aInputmode
.
EqualsLiteral
(
"
mozAwesomebar
"
)
)
{
if
(
TSFTextStore
:
:
ShouldSetInputScopeOfURLBarToDefault
(
)
)
{
return
;
}
if
(
!
aScopes
.
Contains
(
IS_URL
)
)
{
aScopes
.
AppendElement
(
IS_URL
)
;
}
return
;
}
if
(
aInputmode
.
EqualsLiteral
(
"
url
"
)
)
{
if
(
!
aScopes
.
Contains
(
IS_SEARCH
)
)
{
aScopes
.
AppendElement
(
IS_URL
)
;
}
return
;
}
if
(
aInputmode
.
EqualsLiteral
(
"
email
"
)
)
{
if
(
!
aScopes
.
Contains
(
IS_EMAIL_SMTPEMAILADDRESS
)
)
{
aScopes
.
AppendElement
(
IS_EMAIL_SMTPEMAILADDRESS
)
;
}
return
;
}
if
(
aInputmode
.
EqualsLiteral
(
"
tel
"
)
)
{
if
(
!
aScopes
.
Contains
(
IS_TELEPHONE_FULLTELEPHONENUMBER
)
)
{
aScopes
.
AppendElement
(
IS_TELEPHONE_FULLTELEPHONENUMBER
)
;
}
if
(
!
aScopes
.
Contains
(
IS_TELEPHONE_LOCALNUMBER
)
)
{
aScopes
.
AppendElement
(
IS_TELEPHONE_LOCALNUMBER
)
;
}
return
;
}
if
(
aInputmode
.
EqualsLiteral
(
"
numeric
"
)
)
{
if
(
!
aScopes
.
Contains
(
IS_DIGITS
)
)
{
aScopes
.
AppendElement
(
IS_DIGITS
)
;
}
return
;
}
if
(
aInputmode
.
EqualsLiteral
(
"
decimal
"
)
)
{
if
(
!
aScopes
.
Contains
(
IS_NUMBER
)
)
{
aScopes
.
AppendElement
(
IS_NUMBER
)
;
}
return
;
}
if
(
aInputmode
.
EqualsLiteral
(
"
search
"
)
)
{
if
(
!
aScopes
.
Contains
(
IS_SEARCH
)
)
{
aScopes
.
AppendElement
(
IS_SEARCH
)
;
}
return
;
}
}
void
IMEHandler
:
:
AppendInputScopeFromType
(
const
nsAString
&
aHTMLInputType
nsTArray
<
InputScope
>
&
aScopes
)
{
if
(
aHTMLInputType
.
EqualsLiteral
(
"
url
"
)
)
{
aScopes
.
AppendElement
(
IS_URL
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
search
"
)
)
{
aScopes
.
AppendElement
(
IS_SEARCH
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
email
"
)
)
{
aScopes
.
AppendElement
(
IS_EMAIL_SMTPEMAILADDRESS
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
password
"
)
)
{
aScopes
.
AppendElement
(
IS_PASSWORD
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
datetime
"
)
|
|
aHTMLInputType
.
EqualsLiteral
(
"
datetime
-
local
"
)
)
{
aScopes
.
AppendElement
(
IS_DATE_FULLDATE
)
;
aScopes
.
AppendElement
(
IS_TIME_FULLTIME
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
date
"
)
|
|
aHTMLInputType
.
EqualsLiteral
(
"
month
"
)
|
|
aHTMLInputType
.
EqualsLiteral
(
"
week
"
)
)
{
aScopes
.
AppendElement
(
IS_DATE_FULLDATE
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
time
"
)
)
{
aScopes
.
AppendElement
(
IS_TIME_FULLTIME
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
tel
"
)
)
{
aScopes
.
AppendElement
(
IS_TELEPHONE_FULLTELEPHONENUMBER
)
;
aScopes
.
AppendElement
(
IS_TELEPHONE_LOCALNUMBER
)
;
return
;
}
if
(
aHTMLInputType
.
EqualsLiteral
(
"
number
"
)
)
{
aScopes
.
AppendElement
(
IS_NUMBER
)
;
return
;
}
}
void
IMEHandler
:
:
MaybeShowOnScreenKeyboard
(
nsWindow
*
aWindow
const
InputContext
&
aInputContext
)
{
if
(
aInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
none
"
)
)
{
return
;
}
#
ifdef
NIGHTLY_BUILD
if
(
FxRWindowManager
:
:
GetInstance
(
)
-
>
IsFxRWindow
(
sFocusedWindow
)
)
{
mozilla
:
:
gfx
:
:
VRShMem
shmem
(
nullptr
true
)
;
shmem
.
SendIMEState
(
FxRWindowManager
:
:
GetInstance
(
)
-
>
GetWindowID
(
)
mozilla
:
:
gfx
:
:
VRFxEventState
:
:
FOCUS
)
;
return
;
}
#
endif
if
(
sPluginHasFocus
|
|
!
IsWin8OrLater
(
)
|
|
!
Preferences
:
:
GetBool
(
kOskEnabled
true
)
|
|
GetOnScreenKeyboardWindow
(
)
|
|
!
IMEHandler
:
:
NeedOnScreenKeyboard
(
)
)
{
return
;
}
if
(
IsWin10OrLater
(
)
)
{
if
(
!
IsInTabletMode
(
)
&
&
!
AutoInvokeOnScreenKeyboardInDesktopMode
(
)
)
{
return
;
}
}
else
if
(
Preferences
:
:
GetBool
(
kOskRequireWin10
true
)
)
{
return
;
}
IMEHandler
:
:
ShowOnScreenKeyboard
(
aWindow
)
;
}
void
IMEHandler
:
:
MaybeDismissOnScreenKeyboard
(
nsWindow
*
aWindow
Sync
aSync
)
{
#
ifdef
NIGHTLY_BUILD
if
(
FxRWindowManager
:
:
GetInstance
(
)
-
>
IsFxRWindow
(
aWindow
)
)
{
mozilla
:
:
gfx
:
:
VRShMem
shmem
(
nullptr
true
)
;
shmem
.
SendIMEState
(
FxRWindowManager
:
:
GetInstance
(
)
-
>
GetWindowID
(
)
mozilla
:
:
gfx
:
:
VRFxEventState
:
:
BLUR
)
;
}
#
endif
if
(
sPluginHasFocus
|
|
!
IsWin8OrLater
(
)
)
{
return
;
}
if
(
aSync
=
=
Sync
:
:
Yes
)
{
DismissOnScreenKeyboard
(
aWindow
)
;
return
;
}
RefPtr
<
nsWindow
>
window
(
aWindow
)
;
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
IMEHandler
:
:
MaybeDismissOnScreenKeyboard
"
[
window
]
(
)
{
if
(
window
-
>
Destroyed
(
)
)
{
return
;
}
if
(
!
sFocusedWindow
)
{
DismissOnScreenKeyboard
(
window
)
;
}
}
)
EventQueuePriority
:
:
Idle
)
;
}
bool
IMEHandler
:
:
WStringStartsWithCaseInsensitive
(
const
std
:
:
wstring
&
aHaystack
const
std
:
:
wstring
&
aNeedle
)
{
std
:
:
wstring
lowerCaseHaystack
(
aHaystack
)
;
std
:
:
wstring
lowerCaseNeedle
(
aNeedle
)
;
std
:
:
transform
(
lowerCaseHaystack
.
begin
(
)
lowerCaseHaystack
.
end
(
)
lowerCaseHaystack
.
begin
(
)
:
:
tolower
)
;
std
:
:
transform
(
lowerCaseNeedle
.
begin
(
)
lowerCaseNeedle
.
end
(
)
lowerCaseNeedle
.
begin
(
)
:
:
tolower
)
;
return
wcsstr
(
lowerCaseHaystack
.
c_str
(
)
lowerCaseNeedle
.
c_str
(
)
)
=
=
lowerCaseHaystack
.
c_str
(
)
;
}
bool
IMEHandler
:
:
NeedOnScreenKeyboard
(
)
{
if
(
!
IsWin8OrLater
(
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
Requires
Win8
+
.
"
)
;
return
false
;
}
if
(
!
Preferences
:
:
GetBool
(
kOskDetectPhysicalKeyboard
true
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
Detection
disabled
.
"
)
;
return
true
;
}
if
(
!
InputContextAction
:
:
IsHandlingUserInput
(
sLastContextActionCause
)
)
{
return
false
;
}
if
(
(
:
:
GetSystemMetrics
(
SM_DIGITIZER
)
&
NID_INTEGRATED_TOUCH
)
!
=
NID_INTEGRATED_TOUCH
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
Touch
screen
not
found
.
"
)
;
return
false
;
}
if
(
:
:
GetSystemMetrics
(
SM_SYSTEMDOCKED
)
!
=
0
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
System
docked
.
"
)
;
return
false
;
}
if
(
!
sDeterminedPowerPlatformRole
)
{
sDeterminedPowerPlatformRole
=
true
;
sPowerPlatformRole
=
WinUtils
:
:
GetPowerPlatformRole
(
)
;
}
if
(
(
sPowerPlatformRole
=
=
PlatformRoleMobile
|
|
sPowerPlatformRole
=
=
PlatformRoleSlate
)
&
&
:
:
GetSystemMetrics
(
SM_CONVERTIBLESLATEMODE
)
=
=
0
&
&
sLastContextActionCause
=
=
InputContextAction
:
:
CAUSE_TOUCH
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
Mobile
/
Slate
Platform
role
in
slate
mode
with
touch
event
.
"
)
;
return
true
;
}
return
!
IMEHandler
:
:
IsKeyboardPresentOnSlate
(
)
;
}
bool
IMEHandler
:
:
IsKeyboardPresentOnSlate
(
)
{
const
GUID
KEYBOARD_CLASS_GUID
=
{
0x4D36E96B
0xE325
0x11CE
{
0xBF
0xC1
0x08
0x00
0x2B
0xE1
0x03
0x18
}
}
;
HDEVINFO
device_info
=
:
:
SetupDiGetClassDevs
(
&
KEYBOARD_CLASS_GUID
nullptr
nullptr
DIGCF_PRESENT
)
;
if
(
device_info
=
=
INVALID_HANDLE_VALUE
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
No
keyboard
info
.
"
)
;
return
false
;
}
for
(
DWORD
i
=
0
;
;
+
+
i
)
{
SP_DEVINFO_DATA
device_info_data
=
{
0
}
;
device_info_data
.
cbSize
=
sizeof
(
device_info_data
)
;
if
(
!
:
:
SetupDiEnumDeviceInfo
(
device_info
i
&
device_info_data
)
)
{
break
;
}
wchar_t
device_id
[
MAX_DEVICE_ID_LEN
]
;
CONFIGRET
status
=
:
:
CM_Get_Device_ID
(
device_info_data
.
DevInst
device_id
MAX_DEVICE_ID_LEN
0
)
;
if
(
status
=
=
CR_SUCCESS
)
{
static
const
std
:
:
wstring
BT_HID_DEVICE
=
L
"
HID
\
\
{
00001124
"
;
static
const
std
:
:
wstring
BT_HOGP_DEVICE
=
L
"
HID
\
\
{
00001812
"
;
if
(
IMEHandler
:
:
WStringStartsWithCaseInsensitive
(
device_id
L
"
ACPI
"
)
|
|
IMEHandler
:
:
WStringStartsWithCaseInsensitive
(
device_id
L
"
HID
\
\
VID
"
)
|
|
IMEHandler
:
:
WStringStartsWithCaseInsensitive
(
device_id
BT_HID_DEVICE
)
|
|
IMEHandler
:
:
WStringStartsWithCaseInsensitive
(
device_id
BT_HOGP_DEVICE
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
Keyboard
presence
confirmed
.
"
)
;
return
true
;
}
}
}
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IKPOS
:
Lack
of
keyboard
confirmed
.
"
)
;
return
false
;
}
bool
IMEHandler
:
:
IsInTabletMode
(
)
{
nsCOMPtr
<
nsIWindowsUIUtils
>
uiUtils
(
do_GetService
(
"
mozilla
.
org
/
windows
-
ui
-
utils
;
1
"
)
)
;
if
(
NS_WARN_IF
(
!
uiUtils
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IITM
:
nsIWindowsUIUtils
not
available
.
"
)
;
return
false
;
}
bool
isInTabletMode
=
false
;
uiUtils
-
>
GetInTabletMode
(
&
isInTabletMode
)
;
if
(
isInTabletMode
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IITM
:
GetInTabletMode
=
true
.
"
)
;
}
else
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
IITM
:
GetInTabletMode
=
false
.
"
)
;
}
return
isInTabletMode
;
}
static
bool
ReadEnableDesktopModeAutoInvoke
(
uint32_t
aRoot
nsIWindowsRegKey
*
aRegKey
uint32_t
&
aValue
)
{
nsresult
rv
;
rv
=
aRegKey
-
>
Open
(
aRoot
u
"
SOFTWARE
\
\
Microsoft
\
\
TabletTip
\
\
1
.
7
"
_ns
nsIWindowsRegKey
:
:
ACCESS_QUERY_VALUE
)
;
if
(
NS_FAILED
(
rv
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
AIOSKIDM
:
failed
opening
regkey
.
"
)
;
return
false
;
}
rv
=
aRegKey
-
>
ReadIntValue
(
u
"
EnableDesktopModeAutoInvoke
"
_ns
&
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
AIOSKIDM
:
failed
reading
value
of
regkey
.
"
)
;
return
false
;
}
return
true
;
}
bool
IMEHandler
:
:
AutoInvokeOnScreenKeyboardInDesktopMode
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIWindowsRegKey
>
regKey
(
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
&
rv
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
AIOSKIDM
:
"
L
"
nsIWindowsRegKey
not
available
"
)
;
return
false
;
}
uint32_t
value
;
if
(
!
ReadEnableDesktopModeAutoInvoke
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
regKey
value
)
&
&
!
ReadEnableDesktopModeAutoInvoke
(
nsIWindowsRegKey
:
:
ROOT_KEY_LOCAL_MACHINE
regKey
value
)
)
{
return
false
;
}
if
(
!
!
value
)
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
AIOSKIDM
:
regkey
value
=
true
.
"
)
;
}
else
{
Preferences
:
:
SetString
(
kOskDebugReason
L
"
AIOSKIDM
:
regkey
value
=
false
.
"
)
;
}
return
!
!
value
;
}
void
IMEHandler
:
:
ShowOnScreenKeyboard
(
nsWindow
*
aWindow
)
{
if
(
IsWin10AnniversaryUpdateOrLater
(
)
)
{
OSKInputPaneManager
:
:
ShowOnScreenKeyboard
(
aWindow
-
>
GetWindowHandle
(
)
)
;
return
;
}
nsAutoString
cachedPath
;
nsresult
result
=
Preferences
:
:
GetString
(
kOskPathPrefName
cachedPath
)
;
if
(
NS_FAILED
(
result
)
|
|
cachedPath
.
IsEmpty
(
)
)
{
wchar_t
path
[
MAX_PATH
]
;
const
wchar_t
kRegKeyName
[
]
=
L
"
Software
\
\
Classes
\
\
CLSID
\
\
"
L
"
{
054AAE20
-
4BEA
-
4347
-
8A35
-
64A533254A9D
}
\
\
LocalServer32
"
;
if
(
!
WinUtils
:
:
GetRegistryKey
(
HKEY_LOCAL_MACHINE
kRegKeyName
nullptr
path
sizeof
path
)
)
{
return
;
}
std
:
:
wstring
wstrpath
(
path
)
;
size_t
commonProgramFilesOffset
=
wstrpath
.
find
(
L
"
%
CommonProgramFiles
%
"
)
;
if
(
commonProgramFilesOffset
!
=
std
:
:
wstring
:
:
npos
)
{
std
:
:
wstring
commonProgramFilesPath
;
std
:
:
vector
<
wchar_t
>
commonProgramFilesPathW6432
;
DWORD
bufferSize
=
:
:
GetEnvironmentVariableW
(
L
"
CommonProgramW6432
"
nullptr
0
)
;
if
(
bufferSize
)
{
commonProgramFilesPathW6432
.
resize
(
bufferSize
)
;
:
:
GetEnvironmentVariableW
(
L
"
CommonProgramW6432
"
commonProgramFilesPathW6432
.
data
(
)
bufferSize
)
;
commonProgramFilesPath
=
std
:
:
wstring
(
commonProgramFilesPathW6432
.
data
(
)
)
;
}
else
{
PWSTR
path
=
nullptr
;
HRESULT
hres
=
SHGetKnownFolderPath
(
FOLDERID_ProgramFilesCommon
0
nullptr
&
path
)
;
if
(
FAILED
(
hres
)
|
|
!
path
)
{
return
;
}
commonProgramFilesPath
=
static_cast
<
const
wchar_t
*
>
(
nsDependentString
(
path
)
.
get
(
)
)
;
:
:
CoTaskMemFree
(
path
)
;
}
wstrpath
.
replace
(
commonProgramFilesOffset
wcslen
(
L
"
%
CommonProgramFiles
%
"
)
commonProgramFilesPath
)
;
}
cachedPath
.
Assign
(
wstrpath
.
data
(
)
)
;
Preferences
:
:
SetString
(
kOskPathPrefName
cachedPath
)
;
}
const
char16_t
*
cachedPathPtr
;
cachedPath
.
GetData
(
&
cachedPathPtr
)
;
ShellExecuteW
(
nullptr
L
"
"
char16ptr_t
(
cachedPathPtr
)
nullptr
nullptr
SW_SHOW
)
;
}
void
IMEHandler
:
:
DismissOnScreenKeyboard
(
nsWindow
*
aWindow
)
{
if
(
IsWin10AnniversaryUpdateOrLater
(
)
)
{
OSKInputPaneManager
:
:
DismissOnScreenKeyboard
(
aWindow
-
>
GetWindowHandle
(
)
)
;
return
;
}
HWND
osk
=
GetOnScreenKeyboardWindow
(
)
;
if
(
osk
)
{
:
:
PostMessage
(
osk
WM_SYSCOMMAND
SC_CLOSE
0
)
;
}
}
HWND
IMEHandler
:
:
GetOnScreenKeyboardWindow
(
)
{
const
wchar_t
kOSKClassName
[
]
=
L
"
IPTip_Main_Window
"
;
HWND
osk
=
:
:
FindWindowW
(
kOSKClassName
nullptr
)
;
if
(
:
:
IsWindow
(
osk
)
&
&
:
:
IsWindowEnabled
(
osk
)
&
&
:
:
IsWindowVisible
(
osk
)
)
{
return
osk
;
}
return
nullptr
;
}
void
IMEHandler
:
:
SetCandidateWindow
(
nsWindow
*
aWindow
CANDIDATEFORM
*
aForm
)
{
if
(
!
sPluginHasFocus
)
{
return
;
}
IMMHandler
:
:
SetCandidateWindow
(
aWindow
aForm
)
;
}
void
IMEHandler
:
:
DefaultProcOfPluginEvent
(
nsWindow
*
aWindow
const
NPEvent
*
aPluginEvent
)
{
if
(
!
sPluginHasFocus
)
{
return
;
}
IMMHandler
:
:
DefaultProcOfPluginEvent
(
aWindow
aPluginEvent
)
;
}
bool
IMEHandler
:
:
MaybeCreateNativeCaret
(
nsWindow
*
aWindow
)
{
MOZ_ASSERT
(
aWindow
)
;
if
(
IsA11yHandlingNativeCaret
(
)
)
{
return
false
;
}
if
(
!
sHasNativeCaretBeenRequested
)
{
:
:
NotifyWinEvent
(
EVENT_OBJECT_LOCATIONCHANGE
aWindow
-
>
GetWindowHandle
(
)
OBJID_CARET
OBJID_CLIENT
)
;
return
false
;
}
MaybeDestroyNativeCaret
(
)
;
if
(
!
aWindow
-
>
GetInputContext
(
)
.
mIMEState
.
IsEditable
(
)
)
{
return
false
;
}
WidgetQueryContentEvent
queryCaretRectEvent
(
true
eQueryCaretRect
aWindow
)
;
aWindow
-
>
InitEvent
(
queryCaretRectEvent
)
;
WidgetQueryContentEvent
:
:
Options
options
;
options
.
mRelativeToInsertionPoint
=
true
;
queryCaretRectEvent
.
InitForQueryCaretRect
(
0
options
)
;
aWindow
-
>
DispatchWindowEvent
(
&
queryCaretRectEvent
)
;
if
(
NS_WARN_IF
(
queryCaretRectEvent
.
Failed
(
)
)
)
{
return
false
;
}
return
CreateNativeCaret
(
aWindow
queryCaretRectEvent
.
mReply
-
>
mRect
)
;
}
bool
IMEHandler
:
:
CreateNativeCaret
(
nsWindow
*
aWindow
const
LayoutDeviceIntRect
&
aCaretRect
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
!
IsA11yHandlingNativeCaret
(
)
)
;
sNativeCaretIsCreated
=
:
:
CreateCaret
(
aWindow
-
>
GetWindowHandle
(
)
nullptr
aCaretRect
.
Width
(
)
aCaretRect
.
Height
(
)
)
;
if
(
!
sNativeCaretIsCreated
)
{
return
false
;
}
nsWindow
*
toplevelWindow
=
aWindow
-
>
GetTopLevelWindow
(
false
)
;
if
(
NS_WARN_IF
(
!
toplevelWindow
)
)
{
MaybeDestroyNativeCaret
(
)
;
return
false
;
}
LayoutDeviceIntPoint
caretPosition
(
aCaretRect
.
TopLeft
(
)
)
;
if
(
toplevelWindow
!
=
aWindow
)
{
caretPosition
+
=
toplevelWindow
-
>
WidgetToScreenOffset
(
)
;
caretPosition
-
=
aWindow
-
>
WidgetToScreenOffset
(
)
;
}
:
:
SetCaretPos
(
caretPosition
.
x
caretPosition
.
y
)
;
return
true
;
}
void
IMEHandler
:
:
MaybeDestroyNativeCaret
(
)
{
if
(
!
sNativeCaretIsCreated
)
{
return
;
}
:
:
DestroyCaret
(
)
;
sNativeCaretIsCreated
=
false
;
}
}
}
