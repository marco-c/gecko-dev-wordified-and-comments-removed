#
ifndef
TSFTextStore_h_
#
define
TSFTextStore_h_
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWindowBase
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
WritingModes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
<
msctf
.
h
>
#
include
<
textstor
.
h
>
#
ifdef
INPUTSCOPE_INIT_GUID
#
include
<
initguid
.
h
>
#
endif
#
ifdef
TEXTATTRS_INIT_GUID
#
include
<
tsattrs
.
h
>
#
endif
#
include
<
inputscope
.
h
>
#
define
IS_SEARCH
static_cast
<
InputScope
>
(
50
)
struct
ITfThreadMgr
;
struct
ITfDocumentMgr
;
struct
ITfDisplayAttributeMgr
;
struct
ITfCategoryMgr
;
class
nsWindow
;
namespace
mozilla
{
namespace
widget
{
class
TSFStaticSink
;
struct
MSGResult
;
class
TSFTextStore
final
:
public
ITextStoreACP
public
ITfContextOwnerCompositionSink
public
ITfMouseTrackerACP
{
friend
class
TSFStaticSink
;
private
:
typedef
IMENotification
:
:
SelectionChangeDataBase
SelectionChangeDataBase
;
typedef
IMENotification
:
:
SelectionChangeData
SelectionChangeData
;
typedef
IMENotification
:
:
TextChangeDataBase
TextChangeDataBase
;
typedef
IMENotification
:
:
TextChangeData
TextChangeData
;
public
:
STDMETHODIMP
QueryInterface
(
REFIID
void
*
*
)
;
NS_INLINE_DECL_IUNKNOWN_REFCOUNTING
(
TSFTextStore
)
public
:
STDMETHODIMP
AdviseSink
(
REFIID
IUnknown
*
DWORD
)
;
STDMETHODIMP
UnadviseSink
(
IUnknown
*
)
;
STDMETHODIMP
RequestLock
(
DWORD
HRESULT
*
)
;
STDMETHODIMP
GetStatus
(
TS_STATUS
*
)
;
STDMETHODIMP
QueryInsert
(
LONG
LONG
ULONG
LONG
*
LONG
*
)
;
STDMETHODIMP
GetSelection
(
ULONG
ULONG
TS_SELECTION_ACP
*
ULONG
*
)
;
STDMETHODIMP
SetSelection
(
ULONG
const
TS_SELECTION_ACP
*
)
;
STDMETHODIMP
GetText
(
LONG
LONG
WCHAR
*
ULONG
ULONG
*
TS_RUNINFO
*
ULONG
ULONG
*
LONG
*
)
;
STDMETHODIMP
SetText
(
DWORD
LONG
LONG
const
WCHAR
*
ULONG
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
GetFormattedText
(
LONG
LONG
IDataObject
*
*
)
;
STDMETHODIMP
GetEmbedded
(
LONG
REFGUID
REFIID
IUnknown
*
*
)
;
STDMETHODIMP
QueryInsertEmbedded
(
const
GUID
*
const
FORMATETC
*
BOOL
*
)
;
STDMETHODIMP
InsertEmbedded
(
DWORD
LONG
LONG
IDataObject
*
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
RequestSupportedAttrs
(
DWORD
ULONG
const
TS_ATTRID
*
)
;
STDMETHODIMP
RequestAttrsAtPosition
(
LONG
ULONG
const
TS_ATTRID
*
DWORD
)
;
STDMETHODIMP
RequestAttrsTransitioningAtPosition
(
LONG
ULONG
const
TS_ATTRID
*
DWORD
)
;
STDMETHODIMP
FindNextAttrTransition
(
LONG
LONG
ULONG
const
TS_ATTRID
*
DWORD
LONG
*
BOOL
*
LONG
*
)
;
STDMETHODIMP
RetrieveRequestedAttrs
(
ULONG
TS_ATTRVAL
*
ULONG
*
)
;
STDMETHODIMP
GetEndACP
(
LONG
*
)
;
STDMETHODIMP
GetActiveView
(
TsViewCookie
*
)
;
STDMETHODIMP
GetACPFromPoint
(
TsViewCookie
const
POINT
*
DWORD
LONG
*
)
;
STDMETHODIMP
GetTextExt
(
TsViewCookie
LONG
LONG
RECT
*
BOOL
*
)
;
STDMETHODIMP
GetScreenExt
(
TsViewCookie
RECT
*
)
;
STDMETHODIMP
GetWnd
(
TsViewCookie
HWND
*
)
;
STDMETHODIMP
InsertTextAtSelection
(
DWORD
const
WCHAR
*
ULONG
LONG
*
LONG
*
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
InsertEmbeddedAtSelection
(
DWORD
IDataObject
*
LONG
*
LONG
*
TS_TEXTCHANGE
*
)
;
public
:
STDMETHODIMP
OnStartComposition
(
ITfCompositionView
*
BOOL
*
)
;
STDMETHODIMP
OnUpdateComposition
(
ITfCompositionView
*
ITfRange
*
)
;
STDMETHODIMP
OnEndComposition
(
ITfCompositionView
*
)
;
public
:
STDMETHODIMP
AdviseMouseSink
(
ITfRangeACP
*
ITfMouseSink
*
DWORD
*
)
;
STDMETHODIMP
UnadviseMouseSink
(
DWORD
)
;
public
:
static
void
Initialize
(
void
)
;
static
void
Terminate
(
void
)
;
static
bool
ProcessRawKeyMessage
(
const
MSG
&
aMsg
)
;
static
void
ProcessMessage
(
nsWindowBase
*
aWindow
UINT
aMessage
WPARAM
&
aWParam
LPARAM
&
aLParam
MSGResult
&
aResult
)
;
static
void
SetIMEOpenState
(
bool
)
;
static
bool
GetIMEOpenState
(
void
)
;
static
void
CommitComposition
(
bool
aDiscard
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
!
sEnabledTextStore
)
{
return
;
}
RefPtr
<
TSFTextStore
>
textStore
(
sEnabledTextStore
)
;
textStore
-
>
CommitCompositionInternal
(
aDiscard
)
;
}
static
void
SetInputContext
(
nsWindowBase
*
aWidget
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
;
static
nsresult
OnFocusChange
(
bool
aGotFocus
nsWindowBase
*
aFocusedWidget
const
InputContext
&
aContext
)
;
static
nsresult
OnTextChange
(
const
IMENotification
&
aIMENotification
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
!
sEnabledTextStore
)
{
return
NS_OK
;
}
RefPtr
<
TSFTextStore
>
textStore
(
sEnabledTextStore
)
;
return
textStore
-
>
OnTextChangeInternal
(
aIMENotification
)
;
}
static
nsresult
OnSelectionChange
(
const
IMENotification
&
aIMENotification
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
!
sEnabledTextStore
)
{
return
NS_OK
;
}
RefPtr
<
TSFTextStore
>
textStore
(
sEnabledTextStore
)
;
return
textStore
-
>
OnSelectionChangeInternal
(
aIMENotification
)
;
}
static
nsresult
OnLayoutChange
(
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
!
sEnabledTextStore
)
{
return
NS_OK
;
}
RefPtr
<
TSFTextStore
>
textStore
(
sEnabledTextStore
)
;
return
textStore
-
>
OnLayoutChangeInternal
(
)
;
}
static
nsresult
OnUpdateComposition
(
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
!
sEnabledTextStore
)
{
return
NS_OK
;
}
RefPtr
<
TSFTextStore
>
textStore
(
sEnabledTextStore
)
;
return
textStore
-
>
OnUpdateCompositionInternal
(
)
;
}
static
nsresult
OnMouseButtonEvent
(
const
IMENotification
&
aIMENotification
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
!
sEnabledTextStore
)
{
return
NS_OK
;
}
RefPtr
<
TSFTextStore
>
textStore
(
sEnabledTextStore
)
;
return
textStore
-
>
OnMouseButtonEventInternal
(
aIMENotification
)
;
}
static
IMENotificationRequests
GetIMENotificationRequests
(
)
;
static
void
*
GetNativeData
(
uint32_t
aDataType
)
{
switch
(
aDataType
)
{
case
NS_NATIVE_TSF_THREAD_MGR
:
Initialize
(
)
;
return
static_cast
<
void
*
>
(
&
sThreadMgr
)
;
case
NS_NATIVE_TSF_CATEGORY_MGR
:
return
static_cast
<
void
*
>
(
&
sCategoryMgr
)
;
case
NS_NATIVE_TSF_DISPLAY_ATTR_MGR
:
return
static_cast
<
void
*
>
(
&
sDisplayAttrMgr
)
;
default
:
return
nullptr
;
}
}
static
void
*
GetThreadManager
(
)
{
return
static_cast
<
void
*
>
(
sThreadMgr
)
;
}
static
bool
ThinksHavingFocus
(
)
{
return
(
sEnabledTextStore
&
&
sEnabledTextStore
-
>
mContext
)
;
}
static
bool
IsInTSFMode
(
)
{
return
sThreadMgr
!
=
nullptr
;
}
static
bool
IsComposing
(
)
{
return
(
sEnabledTextStore
&
&
sEnabledTextStore
-
>
mComposition
.
IsComposing
(
)
)
;
}
static
bool
IsComposingOn
(
nsWindowBase
*
aWidget
)
{
return
(
IsComposing
(
)
&
&
sEnabledTextStore
-
>
mWidget
=
=
aWidget
)
;
}
static
nsWindowBase
*
GetEnabledWindowBase
(
)
{
return
sEnabledTextStore
?
sEnabledTextStore
-
>
mWidget
.
get
(
)
:
nullptr
;
}
static
bool
IsIMM_IMEActive
(
)
;
static
bool
IsMSJapaneseIMEActive
(
)
;
static
bool
IsGoogleJapaneseInputActive
(
)
;
static
bool
ShouldSetInputScopeOfURLBarToDefault
(
)
;
static
bool
DoNotReturnErrorFromGetSelection
(
)
;
#
ifdef
DEBUG
static
bool
CurrentKeyboardLayoutHasIME
(
)
;
#
endif
protected
:
TSFTextStore
(
)
;
~
TSFTextStore
(
)
;
static
bool
CreateAndSetFocus
(
nsWindowBase
*
aFocusedWidget
const
InputContext
&
aContext
)
;
static
void
EnsureToDestroyAndReleaseEnabledTextStoreIf
(
RefPtr
<
TSFTextStore
>
&
aTextStore
)
;
static
void
MarkContextAsKeyboardDisabled
(
ITfContext
*
aContext
)
;
static
void
MarkContextAsEmpty
(
ITfContext
*
aContext
)
;
bool
Init
(
nsWindowBase
*
aWidget
const
InputContext
&
aContext
)
;
void
Destroy
(
)
;
void
ReleaseTSFObjects
(
)
;
bool
IsReadLock
(
DWORD
aLock
)
const
{
return
(
TS_LF_READ
=
=
(
aLock
&
TS_LF_READ
)
)
;
}
bool
IsReadWriteLock
(
DWORD
aLock
)
const
{
return
(
TS_LF_READWRITE
=
=
(
aLock
&
TS_LF_READWRITE
)
)
;
}
bool
IsReadLocked
(
)
const
{
return
IsReadLock
(
mLock
)
;
}
bool
IsReadWriteLocked
(
)
const
{
return
IsReadWriteLock
(
mLock
)
;
}
void
DidLockGranted
(
)
;
bool
GetScreenExtInternal
(
RECT
&
aScreenExt
)
;
HRESULT
SetSelectionInternal
(
const
TS_SELECTION_ACP
*
bool
aDispatchCompositionChangeEvent
=
false
)
;
bool
InsertTextAtSelectionInternal
(
const
nsAString
&
aInsertStr
TS_TEXTCHANGE
*
aTextChange
)
;
void
CommitCompositionInternal
(
bool
)
;
HRESULT
GetDisplayAttribute
(
ITfProperty
*
aProperty
ITfRange
*
aRange
TF_DISPLAYATTRIBUTE
*
aResult
)
;
HRESULT
RestartCompositionIfNecessary
(
ITfRange
*
pRangeNew
=
nullptr
)
;
HRESULT
RestartComposition
(
ITfCompositionView
*
aCompositionView
ITfRange
*
aNewRange
)
;
HRESULT
RecordCompositionStartAction
(
ITfCompositionView
*
aCompositionView
ITfRange
*
aRange
bool
aPreserveSelection
)
;
HRESULT
RecordCompositionStartAction
(
ITfCompositionView
*
aComposition
LONG
aStart
LONG
aLength
bool
aPreserveSelection
)
;
HRESULT
RecordCompositionUpdateAction
(
)
;
HRESULT
RecordCompositionEndAction
(
)
;
void
DispatchEvent
(
WidgetGUIEvent
&
aEvent
)
;
void
OnLayoutInformationAvaliable
(
)
;
void
FlushPendingActions
(
)
;
void
MaybeFlushPendingNotifications
(
)
;
nsresult
OnTextChangeInternal
(
const
IMENotification
&
aIMENotification
)
;
nsresult
OnSelectionChangeInternal
(
const
IMENotification
&
aIMENotification
)
;
nsresult
OnMouseButtonEventInternal
(
const
IMENotification
&
aIMENotification
)
;
nsresult
OnLayoutChangeInternal
(
)
;
nsresult
OnUpdateCompositionInternal
(
)
;
SelectionChangeData
mPendingSelectionChangeData
;
TextChangeData
mPendingTextChangeData
;
void
NotifyTSFOfTextChange
(
)
;
void
NotifyTSFOfSelectionChange
(
)
;
bool
NotifyTSFOfLayoutChange
(
)
;
void
NotifyTSFOfLayoutChangeAgain
(
)
;
HRESULT
HandleRequestAttrs
(
DWORD
aFlags
ULONG
aFilterCount
const
TS_ATTRID
*
aFilterAttrs
)
;
void
SetInputScope
(
const
nsString
&
aHTMLInputType
const
nsString
&
aHTMLInputInputmode
)
;
void
CreateNativeCaret
(
)
;
void
MaybeDestroyNativeCaret
(
)
;
RefPtr
<
nsWindowBase
>
mWidget
;
RefPtr
<
TextEventDispatcher
>
mDispatcher
;
RefPtr
<
ITfDocumentMgr
>
mDocumentMgr
;
DWORD
mEditCookie
;
RefPtr
<
ITfContext
>
mContext
;
RefPtr
<
ITextStoreACPSink
>
mSink
;
DWORD
mSinkMask
;
DWORD
mLock
;
DWORD
mLockQueued
;
uint32_t
mHandlingKeyMessage
;
void
OnStartToHandleKeyMessage
(
)
{
if
(
!
mDestroyed
&
&
sHandlingKeyMsg
&
&
!
sIsKeyboardEventDispatched
)
{
MaybeDispatchKeyboardEventAsProcessedByIME
(
)
;
}
+
+
mHandlingKeyMessage
;
}
void
OnEndHandlingKeyMessage
(
bool
aIsProcessedByTSF
)
{
if
(
!
mDestroyed
&
&
sHandlingKeyMsg
&
&
aIsProcessedByTSF
&
&
!
sIsKeyboardEventDispatched
)
{
MaybeDispatchKeyboardEventAsProcessedByIME
(
)
;
}
MOZ_ASSERT
(
mHandlingKeyMessage
)
;
if
(
-
-
mHandlingKeyMessage
)
{
return
;
}
if
(
mDestroyed
)
{
ReleaseTSFObjects
(
)
;
}
}
void
MaybeDispatchKeyboardEventAsProcessedByIME
(
)
;
void
DispatchKeyboardEventAsProcessedByIME
(
const
MSG
&
aMsg
)
;
class
Composition
final
{
public
:
RefPtr
<
ITfCompositionView
>
mView
;
nsString
mString
;
LONG
mStart
;
bool
IsComposing
(
)
const
{
return
(
mView
!
=
nullptr
)
;
}
LONG
EndOffset
(
)
const
{
return
mStart
+
static_cast
<
LONG
>
(
mString
.
Length
(
)
)
;
}
void
Start
(
ITfCompositionView
*
aCompositionView
LONG
aCompositionStartOffset
const
nsAString
&
aCompositionString
)
;
void
End
(
)
;
}
;
Composition
mComposition
;
bool
IsHandlingComposition
(
)
const
{
return
mDispatcher
&
&
mDispatcher
-
>
IsHandlingComposition
(
)
;
}
class
Selection
{
public
:
Selection
(
)
:
mDirty
(
true
)
{
}
bool
IsDirty
(
)
const
{
return
mDirty
;
}
;
void
MarkDirty
(
)
{
mDirty
=
true
;
}
TS_SELECTION_ACP
&
ACP
(
)
{
MOZ_ASSERT
(
!
mDirty
)
;
return
mACP
;
}
void
SetSelection
(
const
TS_SELECTION_ACP
&
aSelection
)
{
mDirty
=
false
;
mACP
=
aSelection
;
if
(
mACP
.
style
.
ase
!
=
TS_AE_START
)
{
mACP
.
style
.
ase
=
TS_AE_END
;
}
mACP
.
style
.
fInterimChar
=
FALSE
;
}
bool
SetSelection
(
uint32_t
aStart
uint32_t
aLength
bool
aReversed
WritingMode
aWritingMode
)
{
bool
changed
=
mDirty
|
|
mACP
.
acpStart
!
=
static_cast
<
LONG
>
(
aStart
)
|
|
mACP
.
acpEnd
!
=
static_cast
<
LONG
>
(
aStart
+
aLength
)
;
mDirty
=
false
;
mACP
.
acpStart
=
static_cast
<
LONG
>
(
aStart
)
;
mACP
.
acpEnd
=
static_cast
<
LONG
>
(
aStart
+
aLength
)
;
mACP
.
style
.
ase
=
aReversed
?
TS_AE_START
:
TS_AE_END
;
mACP
.
style
.
fInterimChar
=
FALSE
;
mWritingMode
=
aWritingMode
;
return
changed
;
}
bool
IsCollapsed
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
return
(
mACP
.
acpStart
=
=
mACP
.
acpEnd
)
;
}
void
CollapseAt
(
uint32_t
aOffset
)
{
mDirty
=
false
;
mACP
.
acpStart
=
mACP
.
acpEnd
=
static_cast
<
LONG
>
(
aOffset
)
;
mACP
.
style
.
ase
=
TS_AE_END
;
mACP
.
style
.
fInterimChar
=
FALSE
;
}
LONG
MinOffset
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
LONG
min
=
std
:
:
min
(
mACP
.
acpStart
mACP
.
acpEnd
)
;
MOZ_ASSERT
(
min
>
=
0
)
;
return
min
;
}
LONG
MaxOffset
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
LONG
max
=
std
:
:
max
(
mACP
.
acpStart
mACP
.
acpEnd
)
;
MOZ_ASSERT
(
max
>
=
0
)
;
return
max
;
}
LONG
StartOffset
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
MOZ_ASSERT
(
mACP
.
acpStart
>
=
0
)
;
return
mACP
.
acpStart
;
}
LONG
EndOffset
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
MOZ_ASSERT
(
mACP
.
acpEnd
>
=
0
)
;
return
mACP
.
acpEnd
;
}
LONG
Length
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
MOZ_ASSERT
(
mACP
.
acpEnd
>
=
mACP
.
acpStart
)
;
return
std
:
:
abs
(
mACP
.
acpEnd
-
mACP
.
acpStart
)
;
}
bool
IsReversed
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
return
(
mACP
.
style
.
ase
=
=
TS_AE_START
)
;
}
TsActiveSelEnd
ActiveSelEnd
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
return
mACP
.
style
.
ase
;
}
bool
IsInterimChar
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
return
(
mACP
.
style
.
fInterimChar
!
=
FALSE
)
;
}
WritingMode
GetWritingMode
(
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
return
mWritingMode
;
}
bool
EqualsExceptDirection
(
const
TS_SELECTION_ACP
&
aACP
)
const
{
if
(
mACP
.
style
.
ase
=
=
aACP
.
style
.
ase
)
{
return
mACP
.
acpStart
=
=
aACP
.
acpStart
&
&
mACP
.
acpEnd
=
=
aACP
.
acpEnd
;
}
return
mACP
.
acpStart
=
=
aACP
.
acpEnd
&
&
mACP
.
acpEnd
=
=
aACP
.
acpStart
;
}
bool
EqualsExceptDirection
(
const
SelectionChangeDataBase
&
aChangedSelection
)
const
{
MOZ_ASSERT
(
!
mDirty
)
;
MOZ_ASSERT
(
aChangedSelection
.
IsValid
(
)
)
;
return
aChangedSelection
.
Length
(
)
=
=
static_cast
<
uint32_t
>
(
Length
(
)
)
&
&
aChangedSelection
.
mOffset
=
=
static_cast
<
uint32_t
>
(
StartOffset
(
)
)
;
}
private
:
TS_SELECTION_ACP
mACP
;
WritingMode
mWritingMode
;
bool
mDirty
;
}
;
Selection
mSelectionForTSF
;
Selection
&
SelectionForTSFRef
(
)
;
class
MOZ_STACK_CLASS
AutoSetTemporarySelection
final
{
public
:
explicit
AutoSetTemporarySelection
(
Selection
&
aSelection
)
:
mSelection
(
aSelection
)
{
mDirty
=
mSelection
.
IsDirty
(
)
;
if
(
mDirty
)
{
mSelection
.
CollapseAt
(
0
)
;
}
}
~
AutoSetTemporarySelection
(
)
{
if
(
mDirty
)
{
mSelection
.
MarkDirty
(
)
;
}
}
private
:
Selection
&
mSelection
;
bool
mDirty
;
}
;
struct
PendingAction
final
{
enum
class
Type
:
uint8_t
{
eCompositionStart
eCompositionUpdate
eCompositionEnd
eSetSelection
eKeyboardEvent
}
;
Type
mType
;
LONG
mSelectionStart
;
LONG
mSelectionLength
;
nsString
mData
;
RefPtr
<
TextRangeArray
>
mRanges
;
const
MSG
*
mKeyMsg
;
bool
mSelectionReversed
;
bool
mIncomplete
;
bool
mAdjustSelection
;
}
;
nsTArray
<
PendingAction
>
mPendingActions
;
PendingAction
*
LastOrNewPendingCompositionUpdate
(
)
{
if
(
!
mPendingActions
.
IsEmpty
(
)
)
{
PendingAction
&
lastAction
=
mPendingActions
.
LastElement
(
)
;
if
(
lastAction
.
mType
=
=
PendingAction
:
:
Type
:
:
eCompositionUpdate
)
{
return
&
lastAction
;
}
}
PendingAction
*
newAction
=
mPendingActions
.
AppendElement
(
)
;
newAction
-
>
mType
=
PendingAction
:
:
Type
:
:
eCompositionUpdate
;
newAction
-
>
mRanges
=
new
TextRangeArray
(
)
;
newAction
-
>
mIncomplete
=
true
;
return
newAction
;
}
bool
IsLastPendingActionCompositionEndAt
(
LONG
aStart
LONG
aLength
)
const
{
if
(
mPendingActions
.
IsEmpty
(
)
)
{
return
false
;
}
const
PendingAction
&
pendingLastAction
=
mPendingActions
.
LastElement
(
)
;
return
pendingLastAction
.
mType
=
=
PendingAction
:
:
Type
:
:
eCompositionEnd
&
&
pendingLastAction
.
mSelectionStart
=
=
aStart
&
&
pendingLastAction
.
mData
.
Length
(
)
=
=
static_cast
<
ULONG
>
(
aLength
)
;
}
bool
IsPendingCompositionUpdateIncomplete
(
)
const
{
if
(
mPendingActions
.
IsEmpty
(
)
)
{
return
false
;
}
const
PendingAction
&
lastAction
=
mPendingActions
.
LastElement
(
)
;
return
lastAction
.
mType
=
=
PendingAction
:
:
Type
:
:
eCompositionUpdate
&
&
lastAction
.
mIncomplete
;
}
void
CompleteLastActionIfStillIncomplete
(
)
{
if
(
!
IsPendingCompositionUpdateIncomplete
(
)
)
{
return
;
}
RecordCompositionUpdateAction
(
)
;
}
void
RemoveLastCompositionUpdateActions
(
)
{
while
(
!
mPendingActions
.
IsEmpty
(
)
)
{
const
PendingAction
&
lastAction
=
mPendingActions
.
LastElement
(
)
;
if
(
lastAction
.
mType
!
=
PendingAction
:
:
Type
:
:
eCompositionUpdate
)
{
break
;
}
mPendingActions
.
RemoveLastElement
(
)
;
}
}
class
MOZ_STACK_CLASS
AutoPendingActionAndContentFlusher
final
{
public
:
explicit
AutoPendingActionAndContentFlusher
(
TSFTextStore
*
aTextStore
)
:
mTextStore
(
aTextStore
)
{
MOZ_ASSERT
(
!
mTextStore
-
>
mIsRecordingActionsWithoutLock
)
;
if
(
!
mTextStore
-
>
IsReadWriteLocked
(
)
)
{
mTextStore
-
>
mIsRecordingActionsWithoutLock
=
true
;
}
}
~
AutoPendingActionAndContentFlusher
(
)
{
if
(
!
mTextStore
-
>
mIsRecordingActionsWithoutLock
)
{
return
;
}
mTextStore
-
>
FlushPendingActions
(
)
;
mTextStore
-
>
mIsRecordingActionsWithoutLock
=
false
;
}
private
:
AutoPendingActionAndContentFlusher
(
)
{
}
RefPtr
<
TSFTextStore
>
mTextStore
;
}
;
class
Content
final
{
public
:
Content
(
TSFTextStore
:
:
Composition
&
aComposition
TSFTextStore
:
:
Selection
&
aSelection
)
:
mComposition
(
aComposition
)
mSelection
(
aSelection
)
{
Clear
(
)
;
}
void
Clear
(
)
{
mText
.
Truncate
(
)
;
mLastCompositionString
.
Truncate
(
)
;
mLastCompositionStart
=
-
1
;
mInitialized
=
false
;
}
bool
IsInitialized
(
)
const
{
return
mInitialized
;
}
void
Init
(
const
nsAString
&
aText
)
{
mText
=
aText
;
if
(
mComposition
.
IsComposing
(
)
)
{
mLastCompositionString
=
mComposition
.
mString
;
mLastCompositionStart
=
mComposition
.
mStart
;
}
else
{
mLastCompositionString
.
Truncate
(
)
;
mLastCompositionStart
=
-
1
;
}
mMinTextModifiedOffset
=
NOT_MODIFIED
;
mLatestCompositionStartOffset
=
mLatestCompositionEndOffset
=
LONG_MAX
;
mInitialized
=
true
;
}
void
OnLayoutChanged
(
)
{
mMinTextModifiedOffset
=
NOT_MODIFIED
;
}
void
OnCompositionEventsHandled
(
)
{
if
(
!
mInitialized
)
{
return
;
}
if
(
mComposition
.
IsComposing
(
)
)
{
mLastCompositionString
=
mComposition
.
mString
;
mLastCompositionStart
=
mComposition
.
mStart
;
}
else
{
mLastCompositionString
.
Truncate
(
)
;
mLastCompositionStart
=
-
1
;
}
}
const
nsDependentSubstring
GetSelectedText
(
)
const
;
const
nsDependentSubstring
GetSubstring
(
uint32_t
aStart
uint32_t
aLength
)
const
;
void
ReplaceSelectedTextWith
(
const
nsAString
&
aString
)
;
void
ReplaceTextWith
(
LONG
aStart
LONG
aLength
const
nsAString
&
aString
)
;
void
StartComposition
(
ITfCompositionView
*
aCompositionView
const
PendingAction
&
aCompStart
bool
aPreserveSelection
)
;
void
RestoreCommittedComposition
(
ITfCompositionView
*
aCompositionView
const
PendingAction
&
aCanceledCompositionEnd
)
;
void
EndComposition
(
const
PendingAction
&
aCompEnd
)
;
const
nsString
&
Text
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
return
mText
;
}
const
nsString
&
LastCompositionString
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
return
mLastCompositionString
;
}
LONG
LastCompositionStringEndOffset
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
MOZ_ASSERT
(
WasLastComposition
(
)
)
;
return
mLastCompositionStart
+
mLastCompositionString
.
Length
(
)
;
}
bool
WasLastComposition
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
return
mLastCompositionStart
>
=
0
;
}
uint32_t
MinTextModifiedOffset
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
return
mMinTextModifiedOffset
;
}
LONG
LatestCompositionStartOffset
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
MOZ_ASSERT
(
HasOrHadComposition
(
)
)
;
return
mLatestCompositionStartOffset
;
}
LONG
LatestCompositionEndOffset
(
)
const
{
MOZ_ASSERT
(
mInitialized
)
;
MOZ_ASSERT
(
HasOrHadComposition
(
)
)
;
return
mLatestCompositionEndOffset
;
}
bool
IsLayoutChangedAt
(
uint32_t
aOffset
)
const
{
return
IsLayoutChanged
(
)
&
&
(
mMinTextModifiedOffset
<
=
aOffset
)
;
}
bool
IsLayoutChanged
(
)
const
{
return
mInitialized
&
&
(
mMinTextModifiedOffset
!
=
NOT_MODIFIED
)
;
}
uint32_t
MinOffsetOfLayoutChanged
(
)
const
{
return
mInitialized
?
mMinTextModifiedOffset
:
NOT_MODIFIED
;
}
bool
HasOrHadComposition
(
)
const
{
return
mInitialized
&
&
mLatestCompositionStartOffset
!
=
LONG_MAX
&
&
mLatestCompositionEndOffset
!
=
LONG_MAX
;
}
TSFTextStore
:
:
Composition
&
Composition
(
)
{
return
mComposition
;
}
TSFTextStore
:
:
Selection
&
Selection
(
)
{
return
mSelection
;
}
private
:
nsString
mText
;
nsString
mLastCompositionString
;
TSFTextStore
:
:
Composition
&
mComposition
;
TSFTextStore
:
:
Selection
&
mSelection
;
LONG
mLastCompositionStart
;
LONG
mLatestCompositionStartOffset
;
LONG
mLatestCompositionEndOffset
;
enum
:
uint32_t
{
NOT_MODIFIED
=
UINT32_MAX
}
;
uint32_t
mMinTextModifiedOffset
;
bool
mInitialized
;
}
;
Content
mContentForTSF
;
Content
&
ContentForTSFRef
(
)
;
bool
CanAccessActualContentDirectly
(
)
const
;
bool
GetCurrentText
(
nsAString
&
aTextContent
)
;
class
MouseTracker
final
{
public
:
static
const
DWORD
kInvalidCookie
=
static_cast
<
DWORD
>
(
-
1
)
;
MouseTracker
(
)
;
HRESULT
Init
(
TSFTextStore
*
aTextStore
)
;
HRESULT
AdviseSink
(
TSFTextStore
*
aTextStore
ITfRangeACP
*
aTextRange
ITfMouseSink
*
aMouseSink
)
;
void
UnadviseSink
(
)
;
bool
IsUsing
(
)
const
{
return
mSink
!
=
nullptr
;
}
bool
InRange
(
uint32_t
aOffset
)
const
{
if
(
NS_WARN_IF
(
mStart
<
0
)
|
|
NS_WARN_IF
(
mLength
<
=
0
)
)
{
return
false
;
}
return
aOffset
>
=
static_cast
<
uint32_t
>
(
mStart
)
&
&
aOffset
<
static_cast
<
uint32_t
>
(
mStart
+
mLength
)
;
}
DWORD
Cookie
(
)
const
{
return
mCookie
;
}
bool
OnMouseButtonEvent
(
ULONG
aEdge
ULONG
aQuadrant
DWORD
aButtonStatus
)
;
LONG
RangeStart
(
)
const
{
return
mStart
;
}
private
:
RefPtr
<
ITfMouseSink
>
mSink
;
LONG
mStart
;
LONG
mLength
;
DWORD
mCookie
;
}
;
nsTArray
<
MouseTracker
>
mMouseTrackers
;
nsTArray
<
InputScope
>
mInputScopes
;
enum
{
eNotSupported
=
-
1
eInputScope
=
0
eTextVerticalWriting
eTextOrientation
NUM_OF_SUPPORTED_ATTRS
}
;
bool
mRequestedAttrs
[
NUM_OF_SUPPORTED_ATTRS
]
;
int32_t
GetRequestedAttrIndex
(
const
TS_ATTRID
&
aAttrID
)
;
TS_ATTRID
GetAttrID
(
int32_t
aIndex
)
;
bool
mRequestedAttrValues
;
bool
mIsRecordingActionsWithoutLock
;
bool
mHasReturnedNoLayoutError
;
bool
mWaitingQueryLayout
;
bool
mPendingDestroy
;
bool
mDeferClearingContentForTSF
;
bool
mNativeCaretIsCreated
;
bool
mDeferNotifyingTSF
;
bool
mDeferCommittingComposition
;
bool
mDeferCancellingComposition
;
bool
mDestroyed
;
bool
mBeingDestroyed
;
static
StaticRefPtr
<
ITfThreadMgr
>
sThreadMgr
;
static
already_AddRefed
<
ITfThreadMgr
>
GetThreadMgr
(
)
;
static
StaticRefPtr
<
ITfMessagePump
>
sMessagePump
;
public
:
static
already_AddRefed
<
ITfMessagePump
>
GetMessagePump
(
)
;
private
:
static
StaticRefPtr
<
ITfKeystrokeMgr
>
sKeystrokeMgr
;
static
StaticRefPtr
<
ITfDisplayAttributeMgr
>
sDisplayAttrMgr
;
static
already_AddRefed
<
ITfDisplayAttributeMgr
>
GetDisplayAttributeMgr
(
)
;
static
StaticRefPtr
<
ITfCategoryMgr
>
sCategoryMgr
;
static
already_AddRefed
<
ITfCategoryMgr
>
GetCategoryMgr
(
)
;
static
StaticRefPtr
<
ITfCompartment
>
sCompartmentForOpenClose
;
static
already_AddRefed
<
ITfCompartment
>
GetCompartmentForOpenClose
(
)
;
static
StaticRefPtr
<
TSFTextStore
>
sEnabledTextStore
;
static
StaticRefPtr
<
ITfDocumentMgr
>
sDisabledDocumentMgr
;
static
StaticRefPtr
<
ITfContext
>
sDisabledContext
;
static
StaticRefPtr
<
ITfInputProcessorProfiles
>
sInputProcessorProfiles
;
static
already_AddRefed
<
ITfInputProcessorProfiles
>
GetInputProcessorProfiles
(
)
;
static
const
MSG
*
sHandlingKeyMsg
;
static
DWORD
sClientId
;
static
bool
sIsKeyboardEventDispatched
;
}
;
}
}
#
endif
