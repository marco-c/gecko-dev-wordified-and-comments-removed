#
ifndef
TSFTextStore_h
#
define
TSFTextStore_h
#
include
"
nsIWidget
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
TSFTextStoreBase
.
h
"
#
include
"
TSFUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
WritingModes
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
widget
/
IMEData
.
h
"
#
include
<
msctf
.
h
>
#
include
<
textstor
.
h
>
struct
ITfThreadMgr
;
struct
ITfDocumentMgr
;
struct
ITfDisplayAttributeMgr
;
struct
ITfCategoryMgr
;
class
nsWindow
;
namespace
mozilla
:
:
widget
{
class
TSFStaticSink
;
struct
MSGResult
;
class
TSFTextStore
final
:
public
TSFTextStoreBase
public
ITfContextOwnerCompositionSink
public
ITfMouseTrackerACP
{
friend
class
TSFStaticSink
;
public
:
STDMETHODIMP
QueryInterface
(
REFIID
void
*
*
)
;
NS_INLINE_DECL_IUNKNOWN_ADDREF_RELEASE
(
TSFTextStore
)
;
public
:
STDMETHODIMP
RequestLock
(
DWORD
HRESULT
*
)
;
STDMETHODIMP
QueryInsert
(
LONG
LONG
ULONG
LONG
*
LONG
*
)
;
STDMETHODIMP
GetSelection
(
ULONG
ULONG
TS_SELECTION_ACP
*
ULONG
*
)
;
STDMETHODIMP
SetSelection
(
ULONG
const
TS_SELECTION_ACP
*
)
;
STDMETHODIMP
GetText
(
LONG
LONG
WCHAR
*
ULONG
ULONG
*
TS_RUNINFO
*
ULONG
ULONG
*
LONG
*
)
;
STDMETHODIMP
SetText
(
DWORD
LONG
LONG
const
WCHAR
*
ULONG
TS_TEXTCHANGE
*
)
;
STDMETHODIMP
RequestSupportedAttrs
(
DWORD
ULONG
const
TS_ATTRID
*
)
;
STDMETHODIMP
RequestAttrsAtPosition
(
LONG
ULONG
const
TS_ATTRID
*
DWORD
)
;
STDMETHODIMP
RetrieveRequestedAttrs
(
ULONG
TS_ATTRVAL
*
ULONG
*
)
;
STDMETHODIMP
GetEndACP
(
LONG
*
)
;
STDMETHODIMP
GetACPFromPoint
(
TsViewCookie
const
POINT
*
DWORD
LONG
*
)
;
STDMETHODIMP
GetTextExt
(
TsViewCookie
LONG
LONG
RECT
*
BOOL
*
)
;
STDMETHODIMP
InsertTextAtSelection
(
DWORD
const
WCHAR
*
ULONG
LONG
*
LONG
*
TS_TEXTCHANGE
*
)
;
public
:
STDMETHODIMP
OnStartComposition
(
ITfCompositionView
*
BOOL
*
)
;
STDMETHODIMP
OnUpdateComposition
(
ITfCompositionView
*
ITfRange
*
)
;
STDMETHODIMP
OnEndComposition
(
ITfCompositionView
*
)
;
public
:
STDMETHODIMP
AdviseMouseSink
(
ITfRangeACP
*
ITfMouseSink
*
DWORD
*
)
;
STDMETHODIMP
UnadviseMouseSink
(
DWORD
)
;
public
:
static
bool
ProcessRawKeyMessage
(
const
MSG
&
aMsg
)
;
static
void
ProcessMessage
(
nsWindow
*
aWindow
UINT
aMessage
WPARAM
&
aWParam
LPARAM
&
aLParam
MSGResult
&
aResult
)
;
static
void
SetIMEOpenState
(
bool
)
;
static
bool
GetIMEOpenState
(
void
)
;
static
void
CommitComposition
(
bool
aDiscard
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
const
RefPtr
<
TSFTextStore
>
textStore
=
TSFUtils
:
:
GetActiveTextStore
(
)
)
{
textStore
-
>
CommitCompositionInternal
(
aDiscard
)
;
}
}
static
void
SetInputContext
(
nsWindow
*
aWidget
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
;
static
nsresult
OnTextChange
(
const
IMENotification
&
aIMENotification
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
const
RefPtr
<
TSFTextStore
>
textStore
=
TSFUtils
:
:
GetActiveTextStore
(
)
)
{
return
textStore
-
>
OnTextChangeInternal
(
aIMENotification
)
;
}
return
NS_OK
;
}
static
nsresult
OnSelectionChange
(
const
IMENotification
&
aIMENotification
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
const
RefPtr
<
TSFTextStore
>
textStore
=
TSFUtils
:
:
GetActiveTextStore
(
)
)
{
return
textStore
-
>
OnSelectionChangeInternal
(
aIMENotification
)
;
}
return
NS_OK
;
}
static
nsresult
OnLayoutChange
(
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
const
RefPtr
<
TSFTextStore
>
textStore
=
TSFUtils
:
:
GetActiveTextStore
(
)
)
{
return
textStore
-
>
OnLayoutChangeInternal
(
)
;
}
return
NS_OK
;
}
static
nsresult
OnUpdateComposition
(
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
const
RefPtr
<
TSFTextStore
>
textStore
=
TSFUtils
:
:
GetActiveTextStore
(
)
)
{
return
textStore
-
>
OnUpdateCompositionInternal
(
)
;
}
return
NS_OK
;
}
static
nsresult
OnMouseButtonEvent
(
const
IMENotification
&
aIMENotification
)
{
NS_ASSERTION
(
IsInTSFMode
(
)
"
Not
in
TSF
mode
shouldn
'
t
be
called
"
)
;
if
(
const
RefPtr
<
TSFTextStore
>
textStore
=
TSFUtils
:
:
GetActiveTextStore
(
)
)
{
return
textStore
-
>
OnMouseButtonEventInternal
(
aIMENotification
)
;
}
return
NS_OK
;
}
static
IMENotificationRequests
GetIMENotificationRequests
(
)
;
static
bool
IsInTSFMode
(
)
{
return
TSFUtils
:
:
GetThreadMgr
(
)
!
=
nullptr
;
}
static
bool
IsComposing
(
)
{
return
TSFUtils
:
:
GetActiveTextStore
(
)
&
&
TSFUtils
:
:
GetActiveTextStore
(
)
-
>
mComposition
.
isSome
(
)
;
}
static
bool
IsComposingOn
(
nsWindow
*
aWidget
)
{
return
IsComposing
(
)
&
&
TSFUtils
:
:
GetActiveTextStore
(
)
-
>
mWidget
=
=
aWidget
;
}
static
nsWindow
*
GetEnabledWindow
(
)
{
return
TSFUtils
:
:
GetActiveTextStore
(
)
?
TSFUtils
:
:
GetActiveTextStore
(
)
-
>
mWidget
.
get
(
)
:
nullptr
;
}
static
bool
IsIMM_IMEActive
(
)
;
static
bool
IsMSJapaneseIMEActive
(
)
;
static
bool
IsGoogleJapaneseInputActive
(
)
;
static
bool
IsATOKActive
(
)
;
#
ifdef
DEBUG
static
bool
CurrentKeyboardLayoutHasIME
(
)
;
#
endif
void
Destroy
(
)
final
;
[
[
nodiscard
]
]
static
Result
<
RefPtr
<
TSFTextStore
>
nsresult
>
CreateAndSetFocus
(
nsWindow
*
aFocusedWindow
const
InputContext
&
aContext
)
;
protected
:
TSFTextStore
(
)
;
~
TSFTextStore
(
)
;
bool
Init
(
nsWindow
*
aWidget
const
InputContext
&
aContext
)
;
void
ReleaseTSFObjects
(
)
;
void
DidLockGranted
(
)
final
;
HRESULT
SetSelectionInternal
(
const
TS_SELECTION_ACP
*
bool
aDispatchCompositionChangeEvent
=
false
)
;
bool
InsertTextAtSelectionInternal
(
const
nsAString
&
aInsertStr
TS_TEXTCHANGE
*
aTextChange
)
;
void
CommitCompositionInternal
(
bool
)
;
HRESULT
GetDisplayAttribute
(
ITfProperty
*
aAttrProperty
ITfRange
*
aRange
TF_DISPLAYATTRIBUTE
*
aResult
)
;
HRESULT
RestartCompositionIfNecessary
(
ITfRange
*
pRangeNew
=
nullptr
)
;
class
Composition
;
HRESULT
RestartComposition
(
Composition
&
aCurrentComposition
ITfCompositionView
*
aCompositionView
ITfRange
*
aNewRange
)
;
HRESULT
RecordCompositionStartAction
(
ITfCompositionView
*
aCompositionView
ITfRange
*
aRange
bool
aPreserveSelection
)
;
HRESULT
RecordCompositionStartAction
(
ITfCompositionView
*
aCompositionView
LONG
aStart
LONG
aLength
bool
aPreserveSelection
)
;
HRESULT
RecordCompositionUpdateAction
(
)
;
HRESULT
RecordCompositionEndAction
(
)
;
void
OnLayoutInformationAvailable
(
)
;
void
FlushPendingActions
(
)
;
void
MaybeFlushPendingNotifications
(
)
;
nsresult
OnTextChangeInternal
(
const
IMENotification
&
aIMENotification
)
;
nsresult
OnSelectionChangeInternal
(
const
IMENotification
&
aIMENotification
)
;
nsresult
OnMouseButtonEventInternal
(
const
IMENotification
&
aIMENotification
)
;
nsresult
OnLayoutChangeInternal
(
)
;
nsresult
OnUpdateCompositionInternal
(
)
;
Maybe
<
SelectionChangeData
>
mPendingSelectionChangeData
;
TextChangeData
mPendingTextChangeData
;
void
NotifyTSFOfTextChange
(
)
;
void
NotifyTSFOfSelectionChange
(
)
;
bool
NotifyTSFOfLayoutChange
(
)
;
void
NotifyTSFOfLayoutChangeAgain
(
)
;
HRESULT
HandleRequestAttrs
(
DWORD
aFlags
ULONG
aFilterCount
const
TS_ATTRID
*
aFilterAttrs
)
;
void
CreateNativeCaret
(
)
;
void
MaybeDestroyNativeCaret
(
)
;
bool
MaybeHackNoErrorLayoutBugs
(
LONG
&
aACPStart
LONG
&
aACPEnd
)
;
uint32_t
mHandlingKeyMessage
=
0
;
void
OnStartToHandleKeyMessage
(
)
{
if
(
!
mDestroyed
&
&
sHandlingKeyMsg
&
&
!
sIsKeyboardEventDispatched
)
{
MaybeDispatchKeyboardEventAsProcessedByIME
(
)
;
}
+
+
mHandlingKeyMessage
;
}
void
OnEndHandlingKeyMessage
(
bool
aIsProcessedByTSF
)
{
if
(
!
mDestroyed
&
&
sHandlingKeyMsg
&
&
aIsProcessedByTSF
&
&
!
sIsKeyboardEventDispatched
)
{
MaybeDispatchKeyboardEventAsProcessedByIME
(
)
;
}
MOZ_ASSERT
(
mHandlingKeyMessage
)
;
if
(
-
-
mHandlingKeyMessage
)
{
return
;
}
if
(
mDestroyed
)
{
ReleaseTSFObjects
(
)
;
}
}
void
MaybeDispatchKeyboardEventAsProcessedByIME
(
)
;
void
DispatchKeyboardEventAsProcessedByIME
(
const
MSG
&
aMsg
)
;
class
Composition
final
:
public
OffsetAndData
<
LONG
>
{
public
:
explicit
Composition
(
ITfCompositionView
*
aCompositionView
LONG
aCompositionStartOffset
const
nsAString
&
aCompositionString
)
:
OffsetAndData
<
LONG
>
(
aCompositionStartOffset
aCompositionString
)
mView
(
aCompositionView
)
{
}
ITfCompositionView
*
GetView
(
)
const
{
return
mView
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Composition
&
aComposition
)
{
aStream
<
<
"
{
mView
=
0x
"
<
<
aComposition
.
mView
.
get
(
)
<
<
"
OffsetAndData
<
LONG
>
=
"
<
<
static_cast
<
const
OffsetAndData
<
LONG
>
&
>
(
aComposition
)
<
<
"
}
"
;
return
aStream
;
}
private
:
RefPtr
<
ITfCompositionView
>
const
mView
;
}
;
Maybe
<
Composition
>
mComposition
;
class
Selection
{
public
:
static
TS_SELECTION_ACP
EmptyACP
(
)
{
return
TS_SELECTION_ACP
{
.
acpStart
=
0
.
acpEnd
=
0
.
style
=
{
.
ase
=
TS_AE_NONE
.
fInterimChar
=
FALSE
}
}
;
}
bool
HasRange
(
)
const
{
return
mACP
.
isSome
(
)
;
}
const
TS_SELECTION_ACP
&
ACPRef
(
)
const
{
return
mACP
.
ref
(
)
;
}
explicit
Selection
(
const
TS_SELECTION_ACP
&
aSelection
)
{
SetSelection
(
aSelection
)
;
}
explicit
Selection
(
uint32_t
aOffsetToCollapse
)
{
Collapse
(
aOffsetToCollapse
)
;
}
explicit
Selection
(
const
SelectionChangeDataBase
&
aSelectionChangeData
)
{
SetSelection
(
aSelectionChangeData
)
;
}
explicit
Selection
(
const
WidgetQueryContentEvent
&
aQuerySelectionEvent
)
{
SetSelection
(
aQuerySelectionEvent
)
;
}
Selection
(
uint32_t
aStart
uint32_t
aLength
bool
aReversed
const
WritingMode
&
aWritingMode
)
{
SetSelection
(
aStart
aLength
aReversed
aWritingMode
)
;
}
void
SetSelection
(
const
TS_SELECTION_ACP
&
aSelection
)
{
mACP
=
Some
(
aSelection
)
;
if
(
mACP
-
>
style
.
ase
!
=
TS_AE_START
)
{
mACP
-
>
style
.
ase
=
TS_AE_END
;
}
mACP
-
>
style
.
fInterimChar
=
FALSE
;
}
bool
SetSelection
(
const
SelectionChangeDataBase
&
aSelectionChangeData
)
{
MOZ_ASSERT
(
aSelectionChangeData
.
IsInitialized
(
)
)
;
if
(
!
aSelectionChangeData
.
HasRange
(
)
)
{
if
(
mACP
.
isNothing
(
)
)
{
return
false
;
}
mACP
.
reset
(
)
;
return
true
;
}
return
SetSelection
(
aSelectionChangeData
.
mOffset
aSelectionChangeData
.
Length
(
)
aSelectionChangeData
.
mReversed
aSelectionChangeData
.
GetWritingMode
(
)
)
;
}
bool
SetSelection
(
const
WidgetQueryContentEvent
&
aQuerySelectionEvent
)
{
MOZ_ASSERT
(
aQuerySelectionEvent
.
mMessage
=
=
eQuerySelectedText
)
;
MOZ_ASSERT
(
aQuerySelectionEvent
.
Succeeded
(
)
)
;
if
(
aQuerySelectionEvent
.
DidNotFindSelection
(
)
)
{
if
(
mACP
.
isNothing
(
)
)
{
return
false
;
}
mACP
.
reset
(
)
;
return
true
;
}
return
SetSelection
(
aQuerySelectionEvent
.
mReply
-
>
StartOffset
(
)
aQuerySelectionEvent
.
mReply
-
>
DataLength
(
)
aQuerySelectionEvent
.
mReply
-
>
mReversed
aQuerySelectionEvent
.
mReply
-
>
WritingModeRef
(
)
)
;
}
bool
SetSelection
(
uint32_t
aStart
uint32_t
aLength
bool
aReversed
const
WritingMode
&
aWritingMode
)
{
const
bool
changed
=
mACP
.
isNothing
(
)
|
|
mACP
-
>
acpStart
!
=
static_cast
<
LONG
>
(
aStart
)
|
|
mACP
-
>
acpEnd
!
=
static_cast
<
LONG
>
(
aStart
+
aLength
)
;
mACP
=
Some
(
TS_SELECTION_ACP
{
.
acpStart
=
static_cast
<
LONG
>
(
aStart
)
.
acpEnd
=
static_cast
<
LONG
>
(
aStart
+
aLength
)
.
style
=
{
.
ase
=
aReversed
?
TS_AE_START
:
TS_AE_END
.
fInterimChar
=
FALSE
}
}
)
;
mWritingMode
=
aWritingMode
;
return
changed
;
}
bool
Collapsed
(
)
const
{
return
mACP
.
isNothing
(
)
|
|
mACP
-
>
acpStart
=
=
mACP
-
>
acpEnd
;
}
void
Collapse
(
uint32_t
aOffset
)
{
mACP
=
Some
(
TS_SELECTION_ACP
{
.
acpStart
=
static_cast
<
LONG
>
(
aOffset
)
.
acpEnd
=
static_cast
<
LONG
>
(
aOffset
)
.
style
=
{
.
ase
=
TS_AE_END
.
fInterimChar
=
FALSE
}
}
)
;
}
LONG
MinOffset
(
)
const
{
MOZ_ASSERT
(
mACP
.
isSome
(
)
)
;
LONG
min
=
std
:
:
min
(
mACP
-
>
acpStart
mACP
-
>
acpEnd
)
;
MOZ_ASSERT
(
min
>
=
0
)
;
return
min
;
}
LONG
MaxOffset
(
)
const
{
MOZ_ASSERT
(
mACP
.
isSome
(
)
)
;
LONG
max
=
std
:
:
max
(
mACP
-
>
acpStart
mACP
-
>
acpEnd
)
;
MOZ_ASSERT
(
max
>
=
0
)
;
return
max
;
}
LONG
StartOffset
(
)
const
{
MOZ_ASSERT
(
mACP
.
isSome
(
)
)
;
MOZ_ASSERT
(
mACP
-
>
acpStart
>
=
0
)
;
return
mACP
-
>
acpStart
;
}
LONG
EndOffset
(
)
const
{
MOZ_ASSERT
(
mACP
.
isSome
(
)
)
;
MOZ_ASSERT
(
mACP
-
>
acpEnd
>
=
0
)
;
return
mACP
-
>
acpEnd
;
}
LONG
Length
(
)
const
{
MOZ_ASSERT_IF
(
mACP
.
isSome
(
)
mACP
-
>
acpEnd
>
=
mACP
-
>
acpStart
)
;
return
mACP
.
isSome
(
)
?
std
:
:
abs
(
mACP
-
>
acpEnd
-
mACP
-
>
acpStart
)
:
0
;
}
bool
IsReversed
(
)
const
{
return
mACP
.
isSome
(
)
&
&
mACP
-
>
style
.
ase
=
=
TS_AE_START
;
}
TsActiveSelEnd
ActiveSelEnd
(
)
const
{
return
mACP
.
isSome
(
)
?
mACP
-
>
style
.
ase
:
TS_AE_NONE
;
}
bool
IsInterimChar
(
)
const
{
return
mACP
.
isSome
(
)
&
&
mACP
-
>
style
.
fInterimChar
!
=
FALSE
;
}
const
WritingMode
&
WritingModeRef
(
)
const
{
return
mWritingMode
;
}
bool
EqualsExceptDirection
(
const
TS_SELECTION_ACP
&
aACP
)
const
{
if
(
mACP
.
isNothing
(
)
)
{
return
false
;
}
if
(
mACP
-
>
style
.
ase
=
=
aACP
.
style
.
ase
)
{
return
mACP
-
>
acpStart
=
=
aACP
.
acpStart
&
&
mACP
-
>
acpEnd
=
=
aACP
.
acpEnd
;
}
return
mACP
-
>
acpStart
=
=
aACP
.
acpEnd
&
&
mACP
-
>
acpEnd
=
=
aACP
.
acpStart
;
}
bool
EqualsExceptDirection
(
const
SelectionChangeDataBase
&
aChangedSelection
)
const
{
MOZ_ASSERT
(
aChangedSelection
.
IsInitialized
(
)
)
;
if
(
mACP
.
isNothing
(
)
)
{
return
aChangedSelection
.
HasRange
(
)
;
}
return
aChangedSelection
.
Length
(
)
=
=
static_cast
<
uint32_t
>
(
Length
(
)
)
&
&
aChangedSelection
.
mOffset
=
=
static_cast
<
uint32_t
>
(
StartOffset
(
)
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Selection
&
aSelection
)
{
aStream
<
<
"
{
mACP
=
"
<
<
ToString
(
aSelection
.
mACP
)
.
c_str
(
)
<
<
"
mWritingMode
=
"
<
<
ToString
(
aSelection
.
mWritingMode
)
.
c_str
(
)
<
<
"
Collapsed
(
)
=
"
<
<
(
aSelection
.
Collapsed
(
)
?
"
true
"
:
"
false
"
)
<
<
"
Length
=
"
<
<
aSelection
.
Length
(
)
<
<
"
}
"
;
return
aStream
;
}
private
:
Maybe
<
TS_SELECTION_ACP
>
mACP
;
WritingMode
mWritingMode
;
}
;
Maybe
<
Selection
>
mSelectionForTSF
;
Maybe
<
Selection
>
&
SelectionForTSF
(
)
;
struct
PendingAction
final
{
enum
class
Type
:
uint8_t
{
CompositionStart
CompositionUpdate
CompositionEnd
SetSelection
KeyboardEvent
}
;
Type
mType
;
LONG
mSelectionStart
;
LONG
mSelectionLength
;
nsString
mData
;
RefPtr
<
TextRangeArray
>
mRanges
;
MSG
mKeyMsg
;
bool
mSelectionReversed
;
bool
mIncomplete
;
bool
mAdjustSelection
;
}
;
nsTArray
<
PendingAction
>
mPendingActions
;
PendingAction
*
LastOrNewPendingCompositionUpdate
(
)
{
if
(
!
mPendingActions
.
IsEmpty
(
)
)
{
PendingAction
&
lastAction
=
mPendingActions
.
LastElement
(
)
;
if
(
lastAction
.
mType
=
=
PendingAction
:
:
Type
:
:
CompositionUpdate
)
{
return
&
lastAction
;
}
}
PendingAction
*
newAction
=
mPendingActions
.
AppendElement
(
)
;
newAction
-
>
mType
=
PendingAction
:
:
Type
:
:
CompositionUpdate
;
newAction
-
>
mRanges
=
new
TextRangeArray
(
)
;
newAction
-
>
mIncomplete
=
true
;
return
newAction
;
}
bool
IsLastPendingActionCompositionEndAt
(
LONG
aStart
LONG
aLength
)
const
{
if
(
mPendingActions
.
IsEmpty
(
)
)
{
return
false
;
}
const
PendingAction
&
pendingLastAction
=
mPendingActions
.
LastElement
(
)
;
return
pendingLastAction
.
mType
=
=
PendingAction
:
:
Type
:
:
CompositionEnd
&
&
pendingLastAction
.
mSelectionStart
=
=
aStart
&
&
pendingLastAction
.
mData
.
Length
(
)
=
=
static_cast
<
ULONG
>
(
aLength
)
;
}
bool
IsPendingCompositionUpdateIncomplete
(
)
const
{
if
(
mPendingActions
.
IsEmpty
(
)
)
{
return
false
;
}
const
PendingAction
&
lastAction
=
mPendingActions
.
LastElement
(
)
;
return
lastAction
.
mType
=
=
PendingAction
:
:
Type
:
:
CompositionUpdate
&
&
lastAction
.
mIncomplete
;
}
void
CompleteLastActionIfStillIncomplete
(
)
{
if
(
!
IsPendingCompositionUpdateIncomplete
(
)
)
{
return
;
}
RecordCompositionUpdateAction
(
)
;
}
void
RemoveLastCompositionUpdateActions
(
)
{
while
(
!
mPendingActions
.
IsEmpty
(
)
)
{
const
PendingAction
&
lastAction
=
mPendingActions
.
LastElement
(
)
;
if
(
lastAction
.
mType
!
=
PendingAction
:
:
Type
:
:
CompositionUpdate
)
{
break
;
}
mPendingActions
.
RemoveLastElement
(
)
;
}
}
class
MOZ_STACK_CLASS
AutoPendingActionAndContentFlusher
final
{
public
:
explicit
AutoPendingActionAndContentFlusher
(
TSFTextStore
*
aTextStore
)
:
mTextStore
(
aTextStore
)
{
MOZ_ASSERT
(
!
mTextStore
-
>
mIsRecordingActionsWithoutLock
)
;
if
(
!
mTextStore
-
>
IsReadWriteLocked
(
)
)
{
mTextStore
-
>
mIsRecordingActionsWithoutLock
=
true
;
}
}
~
AutoPendingActionAndContentFlusher
(
)
{
if
(
!
mTextStore
-
>
mIsRecordingActionsWithoutLock
)
{
return
;
}
mTextStore
-
>
FlushPendingActions
(
)
;
mTextStore
-
>
mIsRecordingActionsWithoutLock
=
false
;
}
private
:
AutoPendingActionAndContentFlusher
(
)
{
}
RefPtr
<
TSFTextStore
>
mTextStore
;
}
;
class
Content
final
{
public
:
Content
(
TSFTextStore
&
aTSFTextStore
const
nsAString
&
aText
)
:
mText
(
aText
)
mLastComposition
(
aTSFTextStore
.
mComposition
)
mComposition
(
aTSFTextStore
.
mComposition
)
mSelection
(
aTSFTextStore
.
mSelectionForTSF
)
{
}
void
OnLayoutChanged
(
)
{
mMinModifiedOffset
.
reset
(
)
;
}
void
OnCompositionEventsHandled
(
)
{
mLastComposition
=
mComposition
;
}
const
nsDependentSubstring
GetSelectedText
(
)
const
;
const
nsDependentSubstring
GetSubstring
(
uint32_t
aStart
uint32_t
aLength
)
const
;
void
ReplaceSelectedTextWith
(
const
nsAString
&
aString
)
;
void
ReplaceTextWith
(
LONG
aStart
LONG
aLength
const
nsAString
&
aReplaceString
)
;
void
StartComposition
(
ITfCompositionView
*
aCompositionView
const
PendingAction
&
aCompStart
bool
aPreserveSelection
)
;
void
RestoreCommittedComposition
(
ITfCompositionView
*
aCompositionView
const
PendingAction
&
aCanceledCompositionEnd
)
;
void
EndComposition
(
const
PendingAction
&
aCompEnd
)
;
const
nsString
&
TextRef
(
)
const
{
return
mText
;
}
const
Maybe
<
OffsetAndData
<
LONG
>
>
&
LastComposition
(
)
const
{
return
mLastComposition
;
}
const
Maybe
<
uint32_t
>
&
MinModifiedOffset
(
)
const
{
return
mMinModifiedOffset
;
}
const
Maybe
<
StartAndEndOffsets
<
LONG
>
>
&
LatestCompositionRange
(
)
const
{
return
mLatestCompositionRange
;
}
bool
IsLayoutChangedAt
(
uint32_t
aOffset
)
const
{
return
IsLayoutChanged
(
)
&
&
(
mMinModifiedOffset
.
value
(
)
<
=
aOffset
)
;
}
bool
IsLayoutChanged
(
)
const
{
return
mMinModifiedOffset
.
isSome
(
)
;
}
bool
HasOrHadComposition
(
)
const
{
return
mLatestCompositionRange
.
isSome
(
)
;
}
Maybe
<
TSFTextStore
:
:
Composition
>
&
Composition
(
)
{
return
mComposition
;
}
Maybe
<
TSFTextStore
:
:
Selection
>
&
Selection
(
)
{
return
mSelection
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Content
&
aContent
)
{
aStream
<
<
"
{
mText
=
"
<
<
PrintStringDetail
(
aContent
.
mText
PrintStringDetail
:
:
kMaxLengthForEditor
)
.
get
(
)
<
<
"
mLastComposition
=
"
<
<
aContent
.
mLastComposition
<
<
"
mLatestCompositionRange
=
"
<
<
aContent
.
mLatestCompositionRange
<
<
"
mMinModifiedOffset
=
"
<
<
aContent
.
mMinModifiedOffset
<
<
"
}
"
;
return
aStream
;
}
private
:
nsString
mText
;
Maybe
<
OffsetAndData
<
LONG
>
>
mLastComposition
;
Maybe
<
TSFTextStore
:
:
Composition
>
&
mComposition
;
Maybe
<
TSFTextStore
:
:
Selection
>
&
mSelection
;
Maybe
<
StartAndEndOffsets
<
LONG
>
>
mLatestCompositionRange
;
Maybe
<
uint32_t
>
mMinModifiedOffset
;
}
;
Maybe
<
Content
>
mContentForTSF
;
Maybe
<
Content
>
&
ContentForTSF
(
)
;
class
MOZ_STACK_CLASS
AutoNotifyingTSFBatch
final
{
public
:
explicit
AutoNotifyingTSFBatch
(
TSFTextStore
&
aTextStore
)
:
mTextStore
(
aTextStore
)
mOldValue
(
aTextStore
.
mDeferNotifyingTSF
)
{
mTextStore
.
mDeferNotifyingTSF
=
true
;
}
~
AutoNotifyingTSFBatch
(
)
{
mTextStore
.
mDeferNotifyingTSF
=
mOldValue
;
mTextStore
.
MaybeFlushPendingNotifications
(
)
;
}
private
:
TSFTextStore
&
mTextStore
;
bool
mOldValue
;
}
;
bool
CanAccessActualContentDirectly
(
)
const
;
enum
class
AllowToFlushLayoutIfNoCache
{
No
Yes
}
;
bool
GetCurrentText
(
nsAString
&
aTextContent
AllowToFlushLayoutIfNoCache
aAllowToFlushLayoutIfNoCache
)
;
class
MouseTracker
final
{
public
:
static
const
DWORD
kInvalidCookie
=
static_cast
<
DWORD
>
(
-
1
)
;
MouseTracker
(
)
;
HRESULT
Init
(
TSFTextStore
*
aTextStore
)
;
HRESULT
AdviseSink
(
TSFTextStore
*
aTextStore
ITfRangeACP
*
aTextRange
ITfMouseSink
*
aMouseSink
)
;
void
UnadviseSink
(
)
;
bool
IsUsing
(
)
const
{
return
mSink
!
=
nullptr
;
}
DWORD
Cookie
(
)
const
{
return
mCookie
;
}
bool
OnMouseButtonEvent
(
ULONG
aEdge
ULONG
aQuadrant
DWORD
aButtonStatus
)
;
Maybe
<
StartAndEndOffsets
<
LONG
>
>
Range
(
)
const
{
return
mRange
;
}
private
:
RefPtr
<
ITfMouseSink
>
mSink
;
Maybe
<
StartAndEndOffsets
<
LONG
>
>
mRange
;
DWORD
mCookie
;
}
;
nsTArray
<
MouseTracker
>
mMouseTrackers
;
bool
mRequestedAttrs
[
TSFUtils
:
:
NUM_OF_SUPPORTED_ATTRS
]
=
{
false
}
;
bool
mRequestedAttrValues
=
false
;
bool
mIsRecordingActionsWithoutLock
=
false
;
bool
mHasReturnedNoLayoutError
=
false
;
bool
mPendingToCreateNativeCaret
=
false
;
bool
mDeferClearingContentForTSF
=
false
;
bool
mDeferCommittingComposition
=
false
;
bool
mDeferCancellingComposition
=
false
;
bool
mIsInitializingContentForTSF
=
false
;
bool
mIsInitializingSelectionForTSF
=
false
;
private
:
static
const
MSG
*
sHandlingKeyMsg
;
static
bool
sIsKeyboardEventDispatched
;
}
;
}
#
endif
