#
include
"
nsNativeThemeWin
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RelativeLuminanceUtils
.
h
"
#
include
"
mozilla
/
WindowsVersion
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
<
malloc
.
h
>
#
include
"
nsWindow
.
h
"
#
include
"
nsIComboboxControlFrame
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
WinUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
gfxWindowsSurface
.
h
"
#
include
"
gfxWindowsNativeDrawing
.
h
"
#
include
"
nsUXThemeData
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
extern
mozilla
:
:
LazyLogModule
gWindowsLog
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsNativeThemeWin
nsNativeTheme
nsITheme
)
nsNativeThemeWin
:
:
nsNativeThemeWin
(
)
:
mProgressDeterminateTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mProgressIndeterminateTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mBorderCacheValid
(
)
mMinimumWidgetSizeCacheValid
(
)
mGutterSizeCacheValid
(
false
)
{
}
nsNativeThemeWin
:
:
~
nsNativeThemeWin
(
)
{
nsUXThemeData
:
:
Invalidate
(
)
;
}
static
int32_t
GetTopLevelWindowActiveState
(
nsIFrame
*
aFrame
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
mozilla
:
:
widget
:
:
themeconst
:
:
FS_INACTIVE
;
}
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
mozilla
:
:
widget
:
:
themeconst
:
:
FS_ACTIVE
;
}
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
)
;
nsWindowBase
*
window
=
static_cast
<
nsWindowBase
*
>
(
widget
)
;
if
(
!
window
)
return
mozilla
:
:
widget
:
:
themeconst
:
:
FS_INACTIVE
;
if
(
widget
&
&
!
window
-
>
IsTopLevelWidget
(
)
&
&
!
(
window
=
window
-
>
GetParentWindowBase
(
false
)
)
)
return
mozilla
:
:
widget
:
:
themeconst
:
:
FS_INACTIVE
;
if
(
window
-
>
GetWindowHandle
(
)
=
=
:
:
GetActiveWindow
(
)
)
return
mozilla
:
:
widget
:
:
themeconst
:
:
FS_ACTIVE
;
return
mozilla
:
:
widget
:
:
themeconst
:
:
FS_INACTIVE
;
}
static
int32_t
GetWindowFrameButtonState
(
nsIFrame
*
aFrame
EventStates
eventState
)
{
if
(
GetTopLevelWindowActiveState
(
aFrame
)
=
=
mozilla
:
:
widget
:
:
themeconst
:
:
FS_INACTIVE
)
{
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
return
mozilla
:
:
widget
:
:
themeconst
:
:
BS_HOT
;
return
mozilla
:
:
widget
:
:
themeconst
:
:
BS_INACTIVE
;
}
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
{
if
(
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
return
mozilla
:
:
widget
:
:
themeconst
:
:
BS_PUSHED
;
return
mozilla
:
:
widget
:
:
themeconst
:
:
BS_HOT
;
}
return
mozilla
:
:
widget
:
:
themeconst
:
:
BS_NORMAL
;
}
static
int32_t
GetClassicWindowFrameButtonState
(
EventStates
eventState
)
{
if
(
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
&
&
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
return
DFCS_BUTTONPUSH
|
DFCS_PUSHED
;
return
DFCS_BUTTONPUSH
;
}
static
bool
IsTopLevelMenu
(
nsIFrame
*
aFrame
)
{
bool
isTopLevel
(
false
)
;
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
menuFrame
)
{
isTopLevel
=
menuFrame
-
>
IsOnMenuBar
(
)
;
}
return
isTopLevel
;
}
static
MARGINS
GetCheckboxMargins
(
HANDLE
theme
HDC
hdc
)
{
MARGINS
checkboxContent
=
{
0
}
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECK
MCB_NORMAL
TMT_CONTENTMARGINS
nullptr
&
checkboxContent
)
;
return
checkboxContent
;
}
static
SIZE
GetCheckboxBGSize
(
HANDLE
theme
HDC
hdc
)
{
SIZE
checkboxSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPCHECK
MC_CHECKMARKNORMAL
nullptr
TS_TRUE
&
checkboxSize
)
;
MARGINS
checkboxMargins
=
GetCheckboxMargins
(
theme
hdc
)
;
int
leftMargin
=
checkboxMargins
.
cxLeftWidth
;
int
rightMargin
=
checkboxMargins
.
cxRightWidth
;
int
topMargin
=
checkboxMargins
.
cyTopHeight
;
int
bottomMargin
=
checkboxMargins
.
cyBottomHeight
;
int
width
=
leftMargin
+
checkboxSize
.
cx
+
rightMargin
;
int
height
=
topMargin
+
checkboxSize
.
cy
+
bottomMargin
;
SIZE
ret
;
ret
.
cx
=
width
;
ret
.
cy
=
height
;
return
ret
;
}
static
SIZE
GetCheckboxBGBounds
(
HANDLE
theme
HDC
hdc
)
{
MARGINS
checkboxBGSizing
=
{
0
}
;
MARGINS
checkboxBGContent
=
{
0
}
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
MCB_NORMAL
TMT_SIZINGMARGINS
nullptr
&
checkboxBGSizing
)
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
MCB_NORMAL
TMT_CONTENTMARGINS
nullptr
&
checkboxBGContent
)
;
#
define
posdx
(
d
)
(
(
d
)
>
0
?
d
:
0
)
int
dx
=
posdx
(
checkboxBGContent
.
cxRightWidth
-
checkboxBGSizing
.
cxRightWidth
)
+
posdx
(
checkboxBGContent
.
cxLeftWidth
-
checkboxBGSizing
.
cxLeftWidth
)
;
int
dy
=
posdx
(
checkboxBGContent
.
cyTopHeight
-
checkboxBGSizing
.
cyTopHeight
)
+
posdx
(
checkboxBGContent
.
cyBottomHeight
-
checkboxBGSizing
.
cyBottomHeight
)
;
#
undef
posdx
SIZE
ret
(
GetCheckboxBGSize
(
theme
hdc
)
)
;
ret
.
cx
+
=
dx
;
ret
.
cy
+
=
dy
;
return
ret
;
}
static
SIZE
GetGutterSize
(
HANDLE
theme
HDC
hdc
)
{
SIZE
gutterSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPGUTTER
0
nullptr
TS_TRUE
&
gutterSize
)
;
SIZE
checkboxBGSize
(
GetCheckboxBGBounds
(
theme
hdc
)
)
;
SIZE
itemSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPITEM
MPI_NORMAL
nullptr
TS_TRUE
&
itemSize
)
;
double
scaleFactor
=
WinUtils
:
:
SystemScaleFactor
(
)
;
int
iconDevicePixels
=
NSToIntRound
(
16
*
scaleFactor
)
;
SIZE
iconSize
=
{
iconDevicePixels
iconDevicePixels
}
;
MARGINS
margins
=
{
0
}
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
MCB_NORMAL
TMT_CONTENTMARGINS
nullptr
&
margins
)
;
iconSize
.
cx
+
=
margins
.
cxLeftWidth
+
margins
.
cxRightWidth
;
iconSize
.
cy
+
=
margins
.
cyTopHeight
+
margins
.
cyBottomHeight
;
int
width
=
std
:
:
max
(
itemSize
.
cx
std
:
:
max
(
iconSize
.
cx
checkboxBGSize
.
cx
)
+
gutterSize
.
cx
)
;
int
height
=
std
:
:
max
(
itemSize
.
cy
std
:
:
max
(
iconSize
.
cy
checkboxBGSize
.
cy
)
)
;
SIZE
ret
;
ret
.
cx
=
width
;
ret
.
cy
=
height
;
return
ret
;
}
SIZE
nsNativeThemeWin
:
:
GetCachedGutterSize
(
HANDLE
theme
)
{
if
(
mGutterSizeCacheValid
)
{
return
mGutterSizeCache
;
}
mGutterSizeCache
=
GetGutterSize
(
theme
nullptr
)
;
mGutterSizeCacheValid
=
true
;
return
mGutterSizeCache
;
}
static
HRESULT
DrawThemeBGRTLAware
(
HANDLE
aTheme
HDC
aHdc
int
aPart
int
aState
const
RECT
*
aWidgetRect
const
RECT
*
aClipRect
bool
aIsRtl
)
{
NS_ASSERTION
(
aTheme
"
Bad
theme
handle
.
"
)
;
NS_ASSERTION
(
aHdc
"
Bad
hdc
.
"
)
;
NS_ASSERTION
(
aWidgetRect
"
Bad
rect
.
"
)
;
NS_ASSERTION
(
aClipRect
"
Bad
clip
rect
.
"
)
;
if
(
!
aIsRtl
)
{
return
DrawThemeBackground
(
aTheme
aHdc
aPart
aState
aWidgetRect
aClipRect
)
;
}
HGDIOBJ
hObj
=
GetCurrentObject
(
aHdc
OBJ_BITMAP
)
;
BITMAP
bitmap
;
POINT
vpOrg
;
if
(
hObj
&
&
GetObject
(
hObj
sizeof
(
bitmap
)
&
bitmap
)
&
&
GetViewportOrgEx
(
aHdc
&
vpOrg
)
)
{
RECT
newWRect
(
*
aWidgetRect
)
;
newWRect
.
left
=
bitmap
.
bmWidth
-
(
aWidgetRect
-
>
right
+
2
*
vpOrg
.
x
)
;
newWRect
.
right
=
bitmap
.
bmWidth
-
(
aWidgetRect
-
>
left
+
2
*
vpOrg
.
x
)
;
RECT
newCRect
;
RECT
*
newCRectPtr
=
nullptr
;
if
(
aClipRect
)
{
newCRect
.
top
=
aClipRect
-
>
top
;
newCRect
.
bottom
=
aClipRect
-
>
bottom
;
newCRect
.
left
=
bitmap
.
bmWidth
-
(
aClipRect
-
>
right
+
2
*
vpOrg
.
x
)
;
newCRect
.
right
=
bitmap
.
bmWidth
-
(
aClipRect
-
>
left
+
2
*
vpOrg
.
x
)
;
newCRectPtr
=
&
newCRect
;
}
SetLayout
(
aHdc
LAYOUT_RTL
)
;
HRESULT
hr
=
DrawThemeBackground
(
aTheme
aHdc
aPart
aState
&
newWRect
newCRectPtr
)
;
SetLayout
(
aHdc
0
)
;
if
(
SUCCEEDED
(
hr
)
)
{
return
hr
;
}
}
return
DrawThemeBackground
(
aTheme
aHdc
aPart
aState
aWidgetRect
aClipRect
)
;
}
enum
CaptionDesktopTheme
{
CAPTION_CLASSIC
=
0
CAPTION_BASIC
}
;
enum
CaptionButton
{
CAPTIONBUTTON_MINIMIZE
=
0
CAPTIONBUTTON_RESTORE
CAPTIONBUTTON_CLOSE
}
;
struct
CaptionButtonPadding
{
RECT
hotPadding
[
3
]
;
}
;
static
CaptionButtonPadding
buttonData
[
3
]
=
{
{
{
{
1
2
0
1
}
{
0
2
1
1
}
{
1
2
2
1
}
}
}
{
{
{
1
2
0
2
}
{
0
2
1
2
}
{
1
2
2
2
}
}
}
{
{
{
0
2
0
2
}
{
0
2
1
2
}
{
1
2
2
2
}
}
}
}
;
static
void
AddPaddingRect
(
LayoutDeviceIntSize
*
aSize
CaptionButton
button
)
{
if
(
!
aSize
)
return
;
RECT
offset
;
if
(
!
IsAppThemed
(
)
)
offset
=
buttonData
[
CAPTION_CLASSIC
]
.
hotPadding
[
button
]
;
else
offset
=
buttonData
[
CAPTION_BASIC
]
.
hotPadding
[
button
]
;
aSize
-
>
width
+
=
offset
.
left
+
offset
.
right
;
aSize
-
>
height
+
=
offset
.
top
+
offset
.
bottom
;
}
static
void
OffsetBackgroundRect
(
RECT
&
rect
CaptionButton
button
)
{
RECT
offset
;
if
(
!
IsAppThemed
(
)
)
offset
=
buttonData
[
CAPTION_CLASSIC
]
.
hotPadding
[
button
]
;
else
offset
=
buttonData
[
CAPTION_BASIC
]
.
hotPadding
[
button
]
;
rect
.
left
+
=
offset
.
left
;
rect
.
top
+
=
offset
.
top
;
rect
.
right
-
=
offset
.
right
;
rect
.
bottom
-
=
offset
.
bottom
;
}
static
const
double
kProgressDeterminateTimeSpan
=
3
.
0
;
static
const
double
kProgressIndeterminateTimeSpan
=
5
.
0
;
static
const
int32_t
kProgressHorizontalOverlaySize
=
120
;
static
const
int32_t
kProgressVerticalOverlaySize
=
45
;
static
const
int32_t
kProgressVerticalIndeterminateOverlaySize
=
60
;
static
const
int32_t
kProgressClassicOverlaySize
=
40
;
static
int32_t
GetProgressOverlayStyle
(
bool
aIsVertical
)
{
return
aIsVertical
?
PP_MOVEOVERLAYVERT
:
PP_MOVEOVERLAY
;
}
static
int32_t
GetProgressOverlaySize
(
bool
aIsVertical
bool
aIsIndeterminate
)
{
if
(
aIsVertical
)
{
return
aIsIndeterminate
?
kProgressVerticalIndeterminateOverlaySize
:
kProgressVerticalOverlaySize
;
}
return
kProgressHorizontalOverlaySize
;
}
static
bool
IsProgressMeterFilled
(
nsIFrame
*
aFrame
)
{
NS_ENSURE_TRUE
(
aFrame
false
)
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
NS_ENSURE_TRUE
(
parentFrame
false
)
;
return
nsNativeTheme
:
:
GetProgressValue
(
parentFrame
)
=
=
nsNativeTheme
:
:
GetProgressMaxValue
(
parentFrame
)
;
}
RECT
nsNativeThemeWin
:
:
CalculateProgressOverlayRect
(
nsIFrame
*
aFrame
RECT
*
aWidgetRect
bool
aIsVertical
bool
aIsIndeterminate
bool
aIsClassic
)
{
NS_ASSERTION
(
aFrame
"
bad
frame
pointer
"
)
;
NS_ASSERTION
(
aWidgetRect
"
bad
rect
pointer
"
)
;
int32_t
frameSize
=
aIsVertical
?
aWidgetRect
-
>
bottom
-
aWidgetRect
-
>
top
:
aWidgetRect
-
>
right
-
aWidgetRect
-
>
left
;
double
span
=
aIsIndeterminate
?
kProgressIndeterminateTimeSpan
:
kProgressDeterminateTimeSpan
;
TimeDuration
period
;
if
(
!
aIsIndeterminate
)
{
if
(
TimeStamp
:
:
Now
(
)
>
(
mProgressDeterminateTimeStamp
+
TimeDuration
:
:
FromSeconds
(
span
)
)
)
{
mProgressDeterminateTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
period
=
TimeStamp
:
:
Now
(
)
-
mProgressDeterminateTimeStamp
;
}
else
{
if
(
TimeStamp
:
:
Now
(
)
>
(
mProgressIndeterminateTimeStamp
+
TimeDuration
:
:
FromSeconds
(
span
)
)
)
{
mProgressIndeterminateTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
period
=
TimeStamp
:
:
Now
(
)
-
mProgressIndeterminateTimeStamp
;
}
double
percent
=
period
/
TimeDuration
:
:
FromSeconds
(
span
)
;
if
(
!
aIsVertical
&
&
IsFrameRTL
(
aFrame
)
)
percent
=
1
-
percent
;
RECT
overlayRect
=
*
aWidgetRect
;
int32_t
overlaySize
;
if
(
!
aIsClassic
)
{
overlaySize
=
GetProgressOverlaySize
(
aIsVertical
aIsIndeterminate
)
;
}
else
{
overlaySize
=
kProgressClassicOverlaySize
;
}
int
trackWidth
=
frameSize
>
overlaySize
?
frameSize
:
overlaySize
;
if
(
!
aIsVertical
)
{
int
xPos
=
aWidgetRect
-
>
left
-
trackWidth
;
xPos
+
=
(
int
)
ceil
(
(
(
double
)
(
trackWidth
*
2
)
*
percent
)
)
;
overlayRect
.
left
=
xPos
;
overlayRect
.
right
=
xPos
+
overlaySize
;
}
else
{
int
yPos
=
aWidgetRect
-
>
bottom
+
trackWidth
;
yPos
-
=
(
int
)
ceil
(
(
(
double
)
(
trackWidth
*
2
)
*
percent
)
)
;
overlayRect
.
bottom
=
yPos
;
overlayRect
.
top
=
yPos
-
overlaySize
;
}
return
overlayRect
;
}
void
nsNativeThemeWin
:
:
DrawThemedProgressMeter
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
HANDLE
aTheme
HDC
aHdc
int
aPart
int
aState
RECT
*
aWidgetRect
RECT
*
aClipRect
)
{
if
(
!
aFrame
|
|
!
aTheme
|
|
!
aHdc
)
return
;
NS_ASSERTION
(
aWidgetRect
"
bad
rect
pointer
"
)
;
NS_ASSERTION
(
aClipRect
"
bad
clip
rect
pointer
"
)
;
RECT
adjWidgetRect
adjClipRect
;
adjWidgetRect
=
*
aWidgetRect
;
adjClipRect
=
*
aClipRect
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
{
NS_WARNING
(
"
No
parent
frame
for
progress
rendering
.
Can
'
t
paint
.
"
)
;
return
;
}
EventStates
eventStates
=
GetContentState
(
parentFrame
aWidgetType
)
;
bool
vertical
=
IsVerticalProgress
(
parentFrame
)
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgresschunkVertical
;
bool
indeterminate
=
IsIndeterminateProgress
(
parentFrame
eventStates
)
;
bool
animate
=
indeterminate
;
DrawThemeBackground
(
aTheme
aHdc
aPart
aState
&
adjWidgetRect
&
adjClipRect
)
;
if
(
!
IsProgressMeterFilled
(
aFrame
)
)
{
animate
=
true
;
}
if
(
animate
)
{
int32_t
overlayPart
=
GetProgressOverlayStyle
(
vertical
)
;
RECT
overlayRect
=
CalculateProgressOverlayRect
(
aFrame
&
adjWidgetRect
vertical
indeterminate
false
)
;
DrawThemeBackground
(
aTheme
aHdc
overlayPart
aState
&
overlayRect
&
adjClipRect
)
;
if
(
!
QueueAnimatedContentForRefresh
(
aFrame
-
>
GetContent
(
)
60
)
)
{
NS_WARNING
(
"
unable
to
animate
progress
widget
!
"
)
;
}
}
}
LayoutDeviceIntMargin
nsNativeThemeWin
:
:
GetCachedWidgetBorder
(
HTHEME
aTheme
nsUXThemeClass
aThemeClass
WidgetType
aWidgetType
int32_t
aPart
int32_t
aState
)
{
int32_t
cacheIndex
=
aThemeClass
*
THEME_PART_DISTINCT_VALUE_COUNT
+
aPart
;
int32_t
cacheBitIndex
=
cacheIndex
/
8
;
uint8_t
cacheBit
=
1u
<
<
(
cacheIndex
%
8
)
;
if
(
mBorderCacheValid
[
cacheBitIndex
]
&
cacheBit
)
{
return
mBorderCache
[
cacheIndex
]
;
}
RECT
outerRect
;
outerRect
.
top
=
outerRect
.
left
=
100
;
outerRect
.
right
=
outerRect
.
bottom
=
200
;
RECT
contentRect
(
outerRect
)
;
HRESULT
res
=
GetThemeBackgroundContentRect
(
aTheme
nullptr
aPart
aState
&
outerRect
&
contentRect
)
;
if
(
FAILED
(
res
)
)
{
return
LayoutDeviceIntMargin
(
)
;
}
LayoutDeviceIntMargin
result
;
result
.
top
=
contentRect
.
top
-
outerRect
.
top
;
result
.
bottom
=
outerRect
.
bottom
-
contentRect
.
bottom
;
result
.
left
=
contentRect
.
left
-
outerRect
.
left
;
result
.
right
=
outerRect
.
right
-
contentRect
.
right
;
mBorderCacheValid
[
cacheBitIndex
]
|
=
cacheBit
;
mBorderCache
[
cacheIndex
]
=
result
;
return
result
;
}
nsresult
nsNativeThemeWin
:
:
GetCachedMinimumWidgetSize
(
nsIFrame
*
aFrame
HANDLE
aTheme
nsUXThemeClass
aThemeClass
WidgetType
aWidgetType
int32_t
aPart
int32_t
aState
THEMESIZE
aSizeReq
mozilla
:
:
LayoutDeviceIntSize
*
aResult
)
{
int32_t
cachePart
=
aPart
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
Button
&
&
aSizeReq
=
=
TS_MIN
)
{
cachePart
=
BP_Count
;
}
MOZ_ASSERT
(
aPart
<
THEME_PART_DISTINCT_VALUE_COUNT
)
;
int32_t
cacheIndex
=
aThemeClass
*
THEME_PART_DISTINCT_VALUE_COUNT
+
cachePart
;
int32_t
cacheBitIndex
=
cacheIndex
/
8
;
uint8_t
cacheBit
=
1u
<
<
(
cacheIndex
%
8
)
;
if
(
mMinimumWidgetSizeCacheValid
[
cacheBitIndex
]
&
cacheBit
)
{
*
aResult
=
mMinimumWidgetSizeCache
[
cacheIndex
]
;
return
NS_OK
;
}
HDC
hdc
=
:
:
GetDC
(
NULL
)
;
if
(
!
hdc
)
{
return
NS_ERROR_FAILURE
;
}
SIZE
sz
;
GetThemePartSize
(
aTheme
hdc
aPart
aState
nullptr
aSizeReq
&
sz
)
;
aResult
-
>
width
=
sz
.
cx
;
aResult
-
>
height
=
sz
.
cy
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
aResult
-
>
width
+
+
;
aResult
-
>
height
=
aResult
-
>
height
/
2
+
1
;
break
;
case
StyleAppearance
:
:
Menuseparator
:
{
SIZE
gutterSize
(
GetGutterSize
(
aTheme
hdc
)
)
;
aResult
-
>
width
+
=
gutterSize
.
cx
;
break
;
}
case
StyleAppearance
:
:
Menuarrow
:
{
aResult
-
>
width
*
=
2
;
break
;
}
}
:
:
ReleaseDC
(
nullptr
hdc
)
;
mMinimumWidgetSizeCacheValid
[
cacheBitIndex
]
|
=
cacheBit
;
mMinimumWidgetSizeCache
[
cacheIndex
]
=
*
aResult
;
return
NS_OK
;
}
mozilla
:
:
Maybe
<
nsUXThemeClass
>
nsNativeThemeWin
:
:
GetThemeClass
(
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Groupbox
:
return
Some
(
eUXButton
)
;
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
FocusOutline
:
return
Some
(
eUXEdit
)
;
case
StyleAppearance
:
:
Tooltip
:
return
Some
(
eUXTooltip
)
;
case
StyleAppearance
:
:
Toolbox
:
return
Some
(
eUXRebar
)
;
case
StyleAppearance
:
:
MozWinMediaToolbox
:
return
Some
(
eUXMediaRebar
)
;
case
StyleAppearance
:
:
MozWinCommunicationsToolbox
:
return
Some
(
eUXCommunicationsRebar
)
;
case
StyleAppearance
:
:
MozWinBrowsertabbarToolbox
:
return
Some
(
eUXBrowserTabBarRebar
)
;
case
StyleAppearance
:
:
Toolbar
:
case
StyleAppearance
:
:
Toolbarbutton
:
case
StyleAppearance
:
:
Separator
:
return
Some
(
eUXToolbar
)
;
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
return
Some
(
eUXProgress
)
;
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Tabpanels
:
return
Some
(
eUXTab
)
;
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
Scrollcorner
:
return
Some
(
eUXScrollbar
)
;
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
ScaleHorizontal
:
case
StyleAppearance
:
:
ScaleVertical
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
case
StyleAppearance
:
:
ScalethumbVertical
:
return
Some
(
eUXTrackbar
)
;
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
return
Some
(
eUXSpin
)
;
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Resizer
:
return
Some
(
eUXStatus
)
;
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
return
Some
(
eUXCombobox
)
;
case
StyleAppearance
:
:
Treeheadercell
:
case
StyleAppearance
:
:
Treeheadersortarrow
:
return
Some
(
eUXHeader
)
;
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Listitem
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Treetwistyopen
:
case
StyleAppearance
:
:
Treeitem
:
return
Some
(
eUXListview
)
;
case
StyleAppearance
:
:
Menubar
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
case
StyleAppearance
:
:
Menuseparator
:
case
StyleAppearance
:
:
Menuarrow
:
case
StyleAppearance
:
:
Menuimage
:
case
StyleAppearance
:
:
Menuitemtext
:
return
Some
(
eUXMenu
)
;
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
case
StyleAppearance
:
:
MozWindowFrameLeft
:
case
StyleAppearance
:
:
MozWindowFrameRight
:
case
StyleAppearance
:
:
MozWindowFrameBottom
:
case
StyleAppearance
:
:
MozWindowButtonClose
:
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowButtonBoxMaximized
:
case
StyleAppearance
:
:
MozWinGlass
:
case
StyleAppearance
:
:
MozWinBorderlessGlass
:
return
Some
(
eUXWindowFrame
)
;
}
return
Nothing
(
)
;
}
HANDLE
nsNativeThemeWin
:
:
GetTheme
(
WidgetType
aWidgetType
)
{
mozilla
:
:
Maybe
<
nsUXThemeClass
>
themeClass
=
GetThemeClass
(
aWidgetType
)
;
if
(
themeClass
.
isNothing
(
)
)
{
return
nullptr
;
}
return
nsUXThemeData
:
:
GetTheme
(
themeClass
.
value
(
)
)
;
}
int32_t
nsNativeThemeWin
:
:
StandardGetState
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
bool
wantFocused
)
{
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
eventState
.
HasAllStates
(
NS_EVENT_STATE_HOVER
|
NS_EVENT_STATE_ACTIVE
)
)
return
TS_ACTIVE
;
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
return
TS_HOVER
;
if
(
wantFocused
&
&
eventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
return
TS_FOCUSED
;
return
TS_NORMAL
;
}
bool
nsNativeThemeWin
:
:
IsMenuActive
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
-
>
IsXULElement
(
)
&
&
content
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
richlistitem
)
)
return
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
selected
)
;
return
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
menuactive
)
;
}
nsresult
nsNativeThemeWin
:
:
GetThemePartAndState
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
int32_t
&
aPart
int32_t
&
aState
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Button
:
{
aPart
=
BP_BUTTON
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TS_DISABLED
;
return
NS_OK
;
}
else
if
(
IsOpenButton
(
aFrame
)
|
|
IsCheckedButton
(
aFrame
)
)
{
aState
=
TS_ACTIVE
;
return
NS_OK
;
}
aState
=
StandardGetState
(
aFrame
aWidgetType
true
)
;
if
(
aState
=
=
TS_NORMAL
&
&
IsDefaultButton
(
aFrame
)
)
aState
=
TS_FOCUSED
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
{
bool
isCheckbox
=
(
aWidgetType
=
=
StyleAppearance
:
:
Checkbox
)
;
aPart
=
isCheckbox
?
BP_CHECKBOX
:
BP_RADIO
;
enum
InputState
{
UNCHECKED
=
0
CHECKED
INDETERMINATE
}
;
InputState
inputState
=
UNCHECKED
;
bool
isXULCheckboxRadio
=
false
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
}
else
{
if
(
GetCheckedOrSelected
(
aFrame
!
isCheckbox
)
)
{
inputState
=
CHECKED
;
}
if
(
isCheckbox
&
&
GetIndeterminate
(
aFrame
)
)
{
inputState
=
INDETERMINATE
;
}
EventStates
eventState
=
GetContentState
(
isXULCheckboxRadio
?
aFrame
-
>
GetParent
(
)
:
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TS_DISABLED
;
}
else
{
aState
=
StandardGetState
(
aFrame
aWidgetType
false
)
;
}
}
aState
+
=
inputState
*
4
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Groupbox
:
{
aPart
=
BP_GROUPBOX
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
{
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
aPart
=
TFP_EDITBORDER_NOSCROLL
;
if
(
!
aFrame
)
{
aState
=
TFS_EDITBORDER_NORMAL
;
}
else
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TFS_EDITBORDER_DISABLED
;
}
else
if
(
IsReadOnly
(
aFrame
)
)
{
aState
=
TFS_EDITBORDER_NORMAL
;
}
else
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsXULElement
(
)
&
&
IsFocused
(
aFrame
)
)
aState
=
TFS_EDITBORDER_FOCUSED
;
else
if
(
eventState
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_ACTIVE
|
NS_EVENT_STATE_FOCUS
)
)
aState
=
TFS_EDITBORDER_FOCUSED
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
aState
=
TFS_EDITBORDER_HOVER
;
else
aState
=
TFS_EDITBORDER_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
FocusOutline
:
{
aPart
=
TFP_TEXTFIELD
;
aState
=
TS_FOCUSED
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Tooltip
:
{
aPart
=
TTP_STANDARD
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
{
bool
vertical
=
IsVerticalProgress
(
aFrame
)
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgressbarVertical
;
aPart
=
vertical
?
PP_BARVERT
:
PP_BAR
;
aState
=
PBBS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
ProgresschunkVertical
|
|
IsVerticalProgress
(
parentFrame
)
)
{
aPart
=
PP_FILLVERT
;
}
else
{
aPart
=
PP_FILL
;
}
aState
=
PBBVS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Toolbarbutton
:
{
aPart
=
BP_BUTTON
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TS_DISABLED
;
return
NS_OK
;
}
if
(
IsOpenButton
(
aFrame
)
)
{
aState
=
TS_ACTIVE
;
return
NS_OK
;
}
if
(
eventState
.
HasAllStates
(
NS_EVENT_STATE_HOVER
|
NS_EVENT_STATE_ACTIVE
)
)
aState
=
TS_ACTIVE
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
{
if
(
IsCheckedButton
(
aFrame
)
)
aState
=
TB_HOVER_CHECKED
;
else
aState
=
TS_HOVER
;
}
else
{
if
(
IsCheckedButton
(
aFrame
)
)
aState
=
TB_CHECKED
;
else
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Separator
:
{
aPart
=
TP_SEPARATOR
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
{
aPart
=
SP_BUTTON
;
aState
=
(
int
(
aWidgetType
)
-
int
(
StyleAppearance
:
:
ScrollbarbuttonUp
)
)
*
4
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
!
aFrame
)
aState
+
=
TS_NORMAL
;
else
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
+
=
TS_DISABLED
;
else
{
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
EventStates
parentState
=
GetContentState
(
parent
parent
-
>
StyleDisplay
(
)
-
>
mAppearance
)
;
if
(
eventState
.
HasAllStates
(
NS_EVENT_STATE_HOVER
|
NS_EVENT_STATE_ACTIVE
)
)
aState
+
=
TS_ACTIVE
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
aState
+
=
TS_HOVER
;
else
if
(
parentState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
aState
=
(
int
(
aWidgetType
)
-
int
(
StyleAppearance
:
:
ScrollbarbuttonUp
)
)
+
SP_BUTTON_IMPLICIT_HOVER_BASE
;
else
aState
+
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
ScrollbarVertical
:
{
aPart
=
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarHorizontal
)
?
SP_TRACKSTARTHOR
:
SP_TRACKSTARTVERT
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
{
aPart
=
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarthumbHorizontal
)
?
SP_THUMBHOR
:
SP_THUMBVERT
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
!
aFrame
)
aState
=
TS_NORMAL
;
else
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
=
TS_DISABLED
;
else
{
if
(
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
aState
=
TS_ACTIVE
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
aState
=
TS_HOVER
;
else
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
ScaleHorizontal
:
case
StyleAppearance
:
:
ScaleVertical
:
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScaleHorizontal
|
|
(
aWidgetType
=
=
StyleAppearance
:
:
Range
&
&
IsRangeHorizontal
(
aFrame
)
)
)
{
aPart
=
TKP_TRACK
;
aState
=
TRS_NORMAL
;
}
else
{
aPart
=
TKP_TRACKVERT
;
aState
=
TRVS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
case
StyleAppearance
:
:
ScalethumbVertical
:
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
RangeThumb
)
{
if
(
IsRangeHorizontal
(
aFrame
)
)
{
aPart
=
TKP_THUMBBOTTOM
;
}
else
{
aPart
=
IsFrameRTL
(
aFrame
)
?
TKP_THUMBLEFT
:
TKP_THUMBRIGHT
;
}
}
else
{
aPart
=
(
aWidgetType
=
=
StyleAppearance
:
:
ScalethumbHorizontal
)
?
TKP_THUMB
:
TKP_THUMBVERT
;
}
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
!
aFrame
)
aState
=
TS_NORMAL
;
else
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TKP_DISABLED
;
}
else
{
if
(
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
aState
=
TS_ACTIVE
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
aState
=
TKP_FOCUSED
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
aState
=
TS_HOVER
;
else
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
{
aPart
=
(
aWidgetType
=
=
StyleAppearance
:
:
SpinnerUpbutton
)
?
SPNP_UP
:
SPNP_DOWN
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
!
aFrame
)
aState
=
TS_NORMAL
;
else
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
=
TS_DISABLED
;
else
aState
=
StandardGetState
(
aFrame
aWidgetType
false
)
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Toolbox
:
case
StyleAppearance
:
:
MozWinMediaToolbox
:
case
StyleAppearance
:
:
MozWinCommunicationsToolbox
:
case
StyleAppearance
:
:
MozWinBrowsertabbarToolbox
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
Scrollcorner
:
{
aState
=
0
;
aPart
=
RP_BACKGROUND
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Toolbar
:
{
aPart
=
-
1
;
aState
=
0
;
if
(
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
GetFirstChild
(
)
=
=
content
)
{
aState
=
1
;
}
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Resizer
:
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Statusbarpanel
:
aPart
=
1
;
break
;
case
StyleAppearance
:
:
Resizerpanel
:
aPart
=
2
;
break
;
case
StyleAppearance
:
:
Resizer
:
aPart
=
3
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Oops
we
'
re
missing
a
case
"
)
;
aPart
=
1
;
}
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Listbox
:
{
aPart
=
TREEVIEW_BODY
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Tabpanels
:
{
aPart
=
TABP_PANELS
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Tabpanel
:
{
aPart
=
TABP_PANEL
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Tab
:
{
aPart
=
TABP_TAB
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TS_DISABLED
;
return
NS_OK
;
}
if
(
IsSelectedTab
(
aFrame
)
)
{
aPart
=
TABP_TAB_SELECTED
;
aState
=
TS_ACTIVE
;
}
else
aState
=
StandardGetState
(
aFrame
aWidgetType
true
)
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Treeheadersortarrow
:
{
aPart
=
4
;
aState
=
1
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Treeheadercell
:
{
aPart
=
1
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
aState
=
StandardGetState
(
aFrame
aWidgetType
true
)
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Menulist
:
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
bool
isHTML
=
content
&
&
content
-
>
IsHTMLElement
(
)
;
bool
isChrome
=
aFrame
-
>
GetContent
(
)
-
>
IsInChromeDocument
(
)
;
bool
useDropBorder
=
isHTML
|
|
(
isChrome
&
&
IsMenuListEditable
(
aFrame
)
)
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
useDropBorder
)
aPart
=
CBP_DROPBORDER
;
else
aPart
=
CBP_DROPFRAME
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TS_DISABLED
;
}
else
if
(
IsReadOnly
(
aFrame
)
)
{
aState
=
TS_NORMAL
;
}
else
if
(
IsOpenButton
(
aFrame
)
)
{
aState
=
TS_ACTIVE
;
}
else
{
if
(
useDropBorder
&
&
(
eventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
|
|
IsFocused
(
aFrame
)
)
)
aState
=
TS_ACTIVE
;
else
if
(
eventState
.
HasAllStates
(
NS_EVENT_STATE_HOVER
|
NS_EVENT_STATE_ACTIVE
)
)
aState
=
TS_ACTIVE
;
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
aState
=
TS_HOVER
;
else
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
MenulistButton
:
{
bool
isHTML
=
IsHTMLContent
(
aFrame
)
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
bool
isMenulist
=
!
isHTML
&
&
parentFrame
-
>
IsMenuFrame
(
)
;
bool
isOpen
=
false
;
if
(
isHTML
|
|
isMenulist
)
aFrame
=
parentFrame
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
aPart
=
CBP_DROPMARKER_VISTA
;
if
(
isHTML
&
&
IsWidgetStyled
(
aFrame
-
>
PresContext
(
)
aFrame
StyleAppearance
:
:
Menulist
)
)
aPart
=
CBP_DROPMARKER
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
=
TS_DISABLED
;
return
NS_OK
;
}
if
(
isHTML
)
{
nsIComboboxControlFrame
*
ccf
=
do_QueryFrame
(
aFrame
)
;
isOpen
=
(
ccf
&
&
ccf
-
>
IsDroppedDownOrHasParentPopup
(
)
)
;
}
else
isOpen
=
IsOpenButton
(
aFrame
)
;
bool
isChrome
=
aFrame
-
>
GetContent
(
)
-
>
IsInChromeDocument
(
)
;
if
(
isHTML
|
|
(
isChrome
&
&
IsMenuListEditable
(
aFrame
)
)
)
{
if
(
isOpen
)
{
aState
=
TS_HOVER
;
return
NS_OK
;
}
}
else
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
aState
=
TS_NORMAL
;
if
(
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
{
if
(
isOpen
&
&
(
isHTML
|
|
isMenulist
)
)
{
return
NS_OK
;
}
aState
=
TS_ACTIVE
;
}
else
if
(
eventState
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
{
if
(
isOpen
)
{
return
NS_OK
;
}
aState
=
TS_HOVER
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Menupopup
:
{
aPart
=
MENU_POPUPBACKGROUND
;
aState
=
MB_ACTIVE
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
{
bool
isTopLevel
=
false
;
bool
isOpen
=
false
;
bool
isHover
=
false
;
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
aFrame
)
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
isTopLevel
=
IsTopLevelMenu
(
aFrame
)
;
if
(
menuFrame
)
isOpen
=
menuFrame
-
>
IsOpen
(
)
;
isHover
=
IsMenuActive
(
aFrame
aWidgetType
)
;
if
(
isTopLevel
)
{
aPart
=
MENU_BARITEM
;
if
(
isOpen
)
aState
=
MBI_PUSHED
;
else
if
(
isHover
)
aState
=
MBI_HOT
;
else
aState
=
MBI_NORMAL
;
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
+
=
3
;
}
else
{
aPart
=
MENU_POPUPITEM
;
if
(
isHover
)
aState
=
MPI_HOT
;
else
aState
=
MPI_NORMAL
;
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
+
=
2
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Menuseparator
:
aPart
=
MENU_POPUPSEPARATOR
;
aState
=
0
;
return
NS_OK
;
case
StyleAppearance
:
:
Menuarrow
:
{
aPart
=
MENU_POPUPSUBMENU
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
aState
=
IsDisabled
(
aFrame
eventState
)
?
MSM_DISABLED
:
MSM_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
{
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
aPart
=
MENU_POPUPCHECK
;
aState
=
MC_CHECKMARKNORMAL
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menuradio
)
aState
+
=
2
;
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
+
=
1
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Menuitemtext
:
case
StyleAppearance
:
:
Menuimage
:
aPart
=
-
1
;
aState
=
0
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowTitlebar
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_CAPTION
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_MAXCAPTION
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowFrameLeft
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_FRAMELEFT
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowFrameRight
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_FRAMERIGHT
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowFrameBottom
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_FRAMEBOTTOM
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonClose
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_CLOSEBUTTON
;
aState
=
GetWindowFrameButtonState
(
aFrame
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_MINBUTTON
;
aState
=
GetWindowFrameButtonState
(
aFrame
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_MAXBUTTON
;
aState
=
GetWindowFrameButtonState
(
aFrame
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonRestore
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_RESTOREBUTTON
;
aState
=
GetWindowFrameButtonState
(
aFrame
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowButtonBoxMaximized
:
case
StyleAppearance
:
:
MozWinGlass
:
case
StyleAppearance
:
:
MozWinBorderlessGlass
:
aPart
=
-
1
;
aState
=
0
;
return
NS_OK
;
}
aPart
=
0
;
aState
=
0
;
return
NS_ERROR_FAILURE
;
}
static
bool
AssumeThemePartAndStateAreTransparent
(
int32_t
aPart
int32_t
aState
)
{
if
(
!
(
IsWin8Point1OrLater
(
)
&
&
nsUXThemeData
:
:
IsHighContrastOn
(
)
)
&
&
aPart
=
=
MENU_POPUPITEM
&
&
aState
=
=
MBI_NORMAL
)
{
return
true
;
}
return
false
;
}
static
inline
double
GetThemeDpiScaleFactor
(
nsIFrame
*
aFrame
)
{
if
(
WinUtils
:
:
IsPerMonitorDPIAware
(
)
|
|
nsIWidget
:
:
DefaultScaleOverride
(
)
>
0
.
0
)
{
nsIWidget
*
rootWidget
=
aFrame
-
>
PresContext
(
)
-
>
GetRootWidget
(
)
;
if
(
rootWidget
)
{
double
systemScale
=
WinUtils
:
:
SystemScaleFactor
(
)
;
return
rootWidget
-
>
GetDefaultScale
(
)
.
scale
/
systemScale
;
}
}
return
1
.
0
;
}
NS_IMETHODIMP
nsNativeThemeWin
:
:
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
)
{
if
(
IsWidgetScrollbarPart
(
aWidgetType
)
)
{
ComputedStyle
*
style
=
nsLayoutUtils
:
:
StyleForScrollbar
(
aFrame
)
;
if
(
style
-
>
StyleUserInterface
(
)
-
>
HasCustomScrollbars
(
)
)
{
return
DrawCustomScrollbarPart
(
aContext
aFrame
style
aWidgetType
aRect
aDirtyRect
)
;
}
}
HANDLE
theme
=
GetTheme
(
aWidgetType
)
;
if
(
!
theme
)
return
ClassicDrawWidgetBackground
(
aContext
aFrame
aWidgetType
aRect
aDirtyRect
)
;
if
(
nsUXThemeData
:
:
CheckForCompositor
(
)
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
case
StyleAppearance
:
:
MozWindowFrameLeft
:
case
StyleAppearance
:
:
MozWindowFrameRight
:
case
StyleAppearance
:
:
MozWindowFrameBottom
:
return
NS_OK
;
break
;
case
StyleAppearance
:
:
MozWindowButtonClose
:
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
return
NS_OK
;
break
;
case
StyleAppearance
:
:
MozWinGlass
:
case
StyleAppearance
:
:
MozWinBorderlessGlass
:
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowButtonBoxMaximized
:
return
NS_OK
;
break
;
}
}
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aWidgetType
part
state
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
AssumeThemePartAndStateAreTransparent
(
part
state
)
)
{
return
NS_OK
;
}
RefPtr
<
gfxContext
>
ctx
=
aContext
;
gfxContextMatrixAutoSaveRestore
save
(
ctx
)
;
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
ctx
-
>
SetMatrix
(
ctx
-
>
CurrentMatrix
(
)
.
PreScale
(
themeScale
themeScale
)
)
;
}
gfxFloat
p2a
=
gfxFloat
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RECT
widgetRect
;
RECT
clipRect
;
gfxRect
tr
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
dr
(
aDirtyRect
.
X
(
)
aDirtyRect
.
Y
(
)
aDirtyRect
.
Width
(
)
aDirtyRect
.
Height
(
)
)
;
tr
.
Scale
(
1
.
0
/
(
p2a
*
themeScale
)
)
;
dr
.
Scale
(
1
.
0
/
(
p2a
*
themeScale
)
)
;
gfxWindowsNativeDrawing
nativeDrawing
(
ctx
dr
GetWidgetNativeDrawingFlags
(
aWidgetType
)
)
;
RENDER_AGAIN
:
HDC
hdc
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
!
hdc
)
return
NS_ERROR_FAILURE
;
nativeDrawing
.
TransformToNativeRect
(
tr
widgetRect
)
;
nativeDrawing
.
TransformToNativeRect
(
dr
clipRect
)
;
#
if
0
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
stderr
"
xform
:
%
f
%
f
%
f
%
f
[
%
f
%
f
]
\
n
"
m
.
_11
m
.
_21
m
.
_12
m
.
_22
m
.
_31
m
.
_32
)
)
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
stderr
"
tr
:
[
%
d
%
d
%
d
%
d
]
\
ndr
:
[
%
d
%
d
%
d
%
d
]
\
noff
:
[
%
f
%
f
]
\
n
"
tr
.
x
tr
.
y
tr
.
width
tr
.
height
dr
.
x
dr
.
y
dr
.
width
dr
.
height
offset
.
x
offset
.
y
)
)
;
}
#
endif
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebar
)
{
widgetRect
.
left
-
=
GetSystemMetrics
(
SM_CXFRAME
)
;
widgetRect
.
right
+
=
GetSystemMetrics
(
SM_CXFRAME
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebarMaximized
)
{
widgetRect
.
top
+
=
GetSystemMetrics
(
SM_CYFRAME
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Tab
)
{
bool
isLeft
=
IsLeftToSelectedTab
(
aFrame
)
;
bool
isRight
=
!
isLeft
&
&
IsRightToSelectedTab
(
aFrame
)
;
if
(
isLeft
|
|
isRight
)
{
int32_t
edgeSize
=
2
;
if
(
isLeft
)
widgetRect
.
right
+
=
edgeSize
;
else
widgetRect
.
left
-
=
edgeSize
;
}
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMinimize
)
{
OffsetBackgroundRect
(
widgetRect
CAPTIONBUTTON_MINIMIZE
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMaximize
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonRestore
)
{
OffsetBackgroundRect
(
widgetRect
CAPTIONBUTTON_RESTORE
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonClose
)
{
OffsetBackgroundRect
(
widgetRect
CAPTIONBUTTON_CLOSE
)
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
Range
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScaleHorizontal
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScaleVertical
)
{
RECT
contentRect
;
GetThemeBackgroundContentRect
(
theme
hdc
part
state
&
widgetRect
&
contentRect
)
;
SIZE
siz
;
GetThemePartSize
(
theme
hdc
part
state
&
widgetRect
TS_TRUE
&
siz
)
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScaleHorizontal
|
|
(
aWidgetType
=
=
StyleAppearance
:
:
Range
&
&
IsRangeHorizontal
(
aFrame
)
)
)
{
contentRect
.
top
+
=
(
contentRect
.
bottom
-
contentRect
.
top
-
siz
.
cy
)
/
2
;
contentRect
.
bottom
=
contentRect
.
top
+
siz
.
cy
;
}
else
{
if
(
!
IsFrameRTL
(
aFrame
)
)
{
contentRect
.
left
+
=
(
contentRect
.
right
-
contentRect
.
left
-
siz
.
cx
)
/
2
;
contentRect
.
right
=
contentRect
.
left
+
siz
.
cx
;
}
else
{
contentRect
.
right
-
=
(
contentRect
.
right
-
contentRect
.
left
-
siz
.
cx
)
/
2
;
contentRect
.
left
=
contentRect
.
right
-
siz
.
cx
;
}
}
DrawThemeBackground
(
theme
hdc
part
state
&
contentRect
&
clipRect
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menucheckbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menuradio
)
{
bool
isChecked
=
false
;
isChecked
=
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
checked
)
;
if
(
isChecked
)
{
int
bgState
=
MCB_NORMAL
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
bgState
+
=
1
;
SIZE
checkboxBGSize
(
GetCheckboxBGSize
(
theme
hdc
)
)
;
RECT
checkBGRect
=
widgetRect
;
if
(
IsFrameRTL
(
aFrame
)
)
{
checkBGRect
.
left
=
checkBGRect
.
right
-
checkboxBGSize
.
cx
;
}
else
{
checkBGRect
.
right
=
checkBGRect
.
left
+
checkboxBGSize
.
cx
;
}
checkBGRect
.
top
+
=
(
checkBGRect
.
bottom
-
checkBGRect
.
top
)
/
2
-
checkboxBGSize
.
cy
/
2
;
checkBGRect
.
bottom
=
checkBGRect
.
top
+
checkboxBGSize
.
cy
;
DrawThemeBackground
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
bgState
&
checkBGRect
&
clipRect
)
;
MARGINS
checkMargins
=
GetCheckboxMargins
(
theme
hdc
)
;
RECT
checkRect
=
checkBGRect
;
checkRect
.
left
+
=
checkMargins
.
cxLeftWidth
;
checkRect
.
right
-
=
checkMargins
.
cxRightWidth
;
checkRect
.
top
+
=
checkMargins
.
cyTopHeight
;
checkRect
.
bottom
-
=
checkMargins
.
cyBottomHeight
;
DrawThemeBackground
(
theme
hdc
MENU_POPUPCHECK
state
&
checkRect
&
clipRect
)
;
}
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menupopup
)
{
DrawThemeBackground
(
theme
hdc
MENU_POPUPBORDERS
0
&
widgetRect
&
clipRect
)
;
SIZE
borderSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPBORDERS
0
nullptr
TS_TRUE
&
borderSize
)
;
RECT
bgRect
=
widgetRect
;
bgRect
.
top
+
=
borderSize
.
cy
;
bgRect
.
bottom
-
=
borderSize
.
cy
;
bgRect
.
left
+
=
borderSize
.
cx
;
bgRect
.
right
-
=
borderSize
.
cx
;
DrawThemeBackground
(
theme
hdc
MENU_POPUPBACKGROUND
0
&
bgRect
&
clipRect
)
;
SIZE
gutterSize
(
GetGutterSize
(
theme
hdc
)
)
;
RECT
gutterRect
;
gutterRect
.
top
=
bgRect
.
top
;
gutterRect
.
bottom
=
bgRect
.
bottom
;
if
(
IsFrameRTL
(
aFrame
)
)
{
gutterRect
.
right
=
bgRect
.
right
;
gutterRect
.
left
=
gutterRect
.
right
-
gutterSize
.
cx
;
}
else
{
gutterRect
.
left
=
bgRect
.
left
;
gutterRect
.
right
=
gutterRect
.
left
+
gutterSize
.
cx
;
}
DrawThemeBGRTLAware
(
theme
hdc
MENU_POPUPGUTTER
0
&
gutterRect
&
clipRect
IsFrameRTL
(
aFrame
)
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menuseparator
)
{
SIZE
gutterSize
(
GetGutterSize
(
theme
hdc
)
)
;
RECT
sepRect
=
widgetRect
;
if
(
IsFrameRTL
(
aFrame
)
)
sepRect
.
right
-
=
gutterSize
.
cx
;
else
sepRect
.
left
+
=
gutterSize
.
cx
;
DrawThemeBackground
(
theme
hdc
MENU_POPUPSEPARATOR
0
&
sepRect
&
clipRect
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menuarrow
)
{
SIZE
glyphSize
;
GetThemePartSize
(
theme
hdc
part
state
nullptr
TS_TRUE
&
glyphSize
)
;
int32_t
widgetHeight
=
widgetRect
.
bottom
-
widgetRect
.
top
;
RECT
renderRect
=
widgetRect
;
renderRect
.
top
+
=
(
(
widgetHeight
-
glyphSize
.
cy
)
/
2
)
;
renderRect
.
bottom
=
renderRect
.
top
+
glyphSize
.
cy
;
if
(
!
IsFrameRTL
(
aFrame
)
)
{
renderRect
.
right
=
widgetRect
.
right
-
glyphSize
.
cx
;
renderRect
.
left
=
renderRect
.
right
-
glyphSize
.
cx
;
}
else
{
renderRect
.
left
=
glyphSize
.
cx
;
renderRect
.
right
=
renderRect
.
left
+
glyphSize
.
cx
;
}
DrawThemeBGRTLAware
(
theme
hdc
part
state
&
renderRect
&
clipRect
IsFrameRTL
(
aFrame
)
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Resizer
|
|
aWidgetType
=
=
StyleAppearance
:
:
MenulistButton
)
{
DrawThemeBGRTLAware
(
theme
hdc
part
state
&
widgetRect
&
clipRect
IsFrameRTL
(
aFrame
)
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
NumberInput
|
|
aWidgetType
=
=
StyleAppearance
:
:
Textfield
|
|
aWidgetType
=
=
StyleAppearance
:
:
TextfieldMultiline
)
{
DrawThemeBackground
(
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
if
(
state
=
=
TFS_EDITBORDER_DISABLED
)
{
InflateRect
(
&
widgetRect
-
1
-
1
)
;
:
:
FillRect
(
hdc
&
widgetRect
reinterpret_cast
<
HBRUSH
>
(
COLOR_BTNFACE
+
1
)
)
;
}
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Progressbar
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgressbarVertical
)
{
COLORREF
color
;
color
=
GetPixel
(
hdc
widgetRect
.
left
widgetRect
.
top
)
;
DrawThemeBackground
(
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
SetPixel
(
hdc
widgetRect
.
left
widgetRect
.
top
color
)
;
SetPixel
(
hdc
widgetRect
.
right
-
1
widgetRect
.
top
color
)
;
SetPixel
(
hdc
widgetRect
.
right
-
1
widgetRect
.
bottom
-
1
color
)
;
SetPixel
(
hdc
widgetRect
.
left
widgetRect
.
bottom
-
1
color
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Progresschunk
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgresschunkVertical
)
{
DrawThemedProgressMeter
(
aFrame
aWidgetType
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
FocusOutline
)
{
LayoutDeviceIntMargin
border
=
GetWidgetBorder
(
aFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
aFrame
aWidgetType
)
;
widgetRect
.
left
-
=
border
.
left
;
widgetRect
.
right
+
=
border
.
right
;
widgetRect
.
top
-
=
border
.
top
;
widgetRect
.
bottom
+
=
border
.
bottom
;
DTBGOPTS
opts
=
{
sizeof
(
DTBGOPTS
)
DTBG_OMITCONTENT
|
DTBG_CLIPRECT
clipRect
}
;
DrawThemeBackgroundEx
(
theme
hdc
part
state
&
widgetRect
&
opts
)
;
}
else
if
(
part
>
=
0
)
{
DrawThemeBackground
(
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
Range
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScaleHorizontal
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScaleVertical
)
{
EventStates
contentState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
contentState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
{
POINT
vpOrg
;
HPEN
hPen
=
nullptr
;
uint8_t
id
=
SaveDC
(
hdc
)
;
:
:
SelectClipRgn
(
hdc
nullptr
)
;
:
:
GetViewportOrgEx
(
hdc
&
vpOrg
)
;
:
:
SetBrushOrgEx
(
hdc
vpOrg
.
x
+
widgetRect
.
left
vpOrg
.
y
+
widgetRect
.
top
nullptr
)
;
:
:
SetTextColor
(
hdc
0
)
;
:
:
DrawFocusRect
(
hdc
&
widgetRect
)
;
:
:
RestoreDC
(
hdc
id
)
;
if
(
hPen
)
{
:
:
DeleteObject
(
hPen
)
;
}
}
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Toolbar
&
&
state
=
=
0
)
{
theme
=
GetTheme
(
StyleAppearance
:
:
Toolbox
)
;
if
(
!
theme
)
return
NS_ERROR_FAILURE
;
widgetRect
.
bottom
=
widgetRect
.
top
+
TB_SEPARATOR_HEIGHT
;
DrawThemeEdge
(
theme
hdc
RP_BAND
0
&
widgetRect
EDGE_ETCHED
BF_TOP
nullptr
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarthumbHorizontal
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarthumbVertical
)
{
SIZE
gripSize
;
MARGINS
thumbMgns
;
int
gripPart
=
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarthumbHorizontal
)
?
SP_GRIPPERHOR
:
SP_GRIPPERVERT
;
if
(
GetThemePartSize
(
theme
hdc
gripPart
state
nullptr
TS_TRUE
&
gripSize
)
=
=
S_OK
&
&
GetThemeMargins
(
theme
hdc
part
state
TMT_CONTENTMARGINS
nullptr
&
thumbMgns
)
=
=
S_OK
&
&
gripSize
.
cx
+
thumbMgns
.
cxLeftWidth
+
thumbMgns
.
cxRightWidth
<
=
widgetRect
.
right
-
widgetRect
.
left
&
&
gripSize
.
cy
+
thumbMgns
.
cyTopHeight
+
thumbMgns
.
cyBottomHeight
<
=
widgetRect
.
bottom
-
widgetRect
.
top
)
{
DrawThemeBackground
(
theme
hdc
gripPart
state
&
widgetRect
&
clipRect
)
;
}
}
nativeDrawing
.
EndNativeDrawing
(
)
;
if
(
nativeDrawing
.
ShouldRenderAgain
(
)
)
goto
RENDER_AGAIN
;
nativeDrawing
.
PaintToContext
(
)
;
return
NS_OK
;
}
static
nscolor
GetScrollbarFaceColorForAuto
(
ComputedStyle
*
aStyle
)
{
DWORD
sysColor
=
:
:
GetSysColor
(
COLOR_SCROLLBAR
)
;
return
NS_RGB
(
GetRValue
(
sysColor
)
GetGValue
(
sysColor
)
GetBValue
(
sysColor
)
)
;
}
static
nscolor
GetScrollbarTrackColorForAuto
(
ComputedStyle
*
aStyle
)
{
return
aStyle
-
>
StyleBackground
(
)
-
>
BackgroundColor
(
aStyle
)
;
}
nscolor
nsNativeThemeWin
:
:
GetWidgetAutoColor
(
ComputedStyle
*
aStyle
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
return
GetScrollbarTrackColorForAuto
(
aStyle
)
;
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
return
GetScrollbarFaceColorForAuto
(
aStyle
)
;
default
:
return
nsITheme
:
:
GetWidgetAutoColor
(
aStyle
aWidgetType
)
;
}
}
static
void
ScaleForFrameDPI
(
LayoutDeviceIntMargin
*
aMargin
nsIFrame
*
aFrame
)
{
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
aMargin
-
>
top
=
NSToIntRound
(
aMargin
-
>
top
*
themeScale
)
;
aMargin
-
>
left
=
NSToIntRound
(
aMargin
-
>
left
*
themeScale
)
;
aMargin
-
>
bottom
=
NSToIntRound
(
aMargin
-
>
bottom
*
themeScale
)
;
aMargin
-
>
right
=
NSToIntRound
(
aMargin
-
>
right
*
themeScale
)
;
}
}
static
void
ScaleForFrameDPI
(
nsIntMargin
*
aMargin
nsIFrame
*
aFrame
)
{
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
aMargin
-
>
top
=
NSToIntRound
(
aMargin
-
>
top
*
themeScale
)
;
aMargin
-
>
left
=
NSToIntRound
(
aMargin
-
>
left
*
themeScale
)
;
aMargin
-
>
bottom
=
NSToIntRound
(
aMargin
-
>
bottom
*
themeScale
)
;
aMargin
-
>
right
=
NSToIntRound
(
aMargin
-
>
right
*
themeScale
)
;
}
}
static
void
ScaleForFrameDPI
(
LayoutDeviceIntSize
*
aSize
nsIFrame
*
aFrame
)
{
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
aSize
-
>
width
=
NSToIntRound
(
aSize
-
>
width
*
themeScale
)
;
aSize
-
>
height
=
NSToIntRound
(
aSize
-
>
height
*
themeScale
)
;
}
}
LayoutDeviceIntMargin
nsNativeThemeWin
:
:
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
LayoutDeviceIntMargin
result
;
mozilla
:
:
Maybe
<
nsUXThemeClass
>
themeClass
=
GetThemeClass
(
aWidgetType
)
;
HTHEME
theme
=
NULL
;
if
(
!
themeClass
.
isNothing
(
)
)
{
theme
=
nsUXThemeData
:
:
GetTheme
(
themeClass
.
value
(
)
)
;
}
if
(
!
theme
)
{
result
=
ClassicGetWidgetBorder
(
aContext
aFrame
aWidgetType
)
;
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
if
(
!
WidgetIsContainer
(
aWidgetType
)
|
|
aWidgetType
=
=
StyleAppearance
:
:
Toolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinMediaToolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinCommunicationsToolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinBrowsertabbarToolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
Statusbar
|
|
aWidgetType
=
=
StyleAppearance
:
:
Resizer
|
|
aWidgetType
=
=
StyleAppearance
:
:
Tabpanel
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarHorizontal
|
|
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarVertical
|
|
aWidgetType
=
=
StyleAppearance
:
:
Scrollcorner
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menuitem
|
|
aWidgetType
=
=
StyleAppearance
:
:
Checkmenuitem
|
|
aWidgetType
=
=
StyleAppearance
:
:
Radiomenuitem
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menupopup
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menuimage
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menuitemtext
|
|
aWidgetType
=
=
StyleAppearance
:
:
Separator
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebar
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebarMaximized
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinGlass
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinBorderlessGlass
)
return
result
;
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aWidgetType
part
state
)
;
if
(
NS_FAILED
(
rv
)
)
return
result
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
Toolbar
)
{
if
(
state
=
=
0
)
result
.
top
=
TB_SEPARATOR_HEIGHT
;
return
result
;
}
result
=
GetCachedWidgetBorder
(
theme
themeClass
.
value
(
)
aWidgetType
part
state
)
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
Tab
)
{
if
(
IsLeftToSelectedTab
(
aFrame
)
)
result
.
right
=
0
;
else
if
(
IsRightToSelectedTab
(
aFrame
)
)
result
.
left
=
0
;
}
if
(
aFrame
&
&
(
aWidgetType
=
=
StyleAppearance
:
:
NumberInput
|
|
aWidgetType
=
=
StyleAppearance
:
:
Textfield
|
|
aWidgetType
=
=
StyleAppearance
:
:
TextfieldMultiline
)
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
)
)
{
result
.
top
+
+
;
result
.
left
+
+
;
result
.
bottom
+
+
;
result
.
right
+
+
;
}
}
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
bool
nsNativeThemeWin
:
:
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
LayoutDeviceIntMargin
*
aResult
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
aResult
-
>
SizeTo
(
0
0
0
0
)
;
return
true
;
}
bool
ok
=
true
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonBox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonBoxMaximized
)
{
aResult
-
>
SizeTo
(
0
0
0
0
)
;
if
(
nsUXThemeData
:
:
CheckForCompositor
(
)
)
return
true
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonBox
)
{
aResult
-
>
top
=
GetSystemMetrics
(
SM_CXFRAME
)
;
}
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebar
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebarMaximized
)
{
aResult
-
>
SizeTo
(
0
0
0
0
)
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebarMaximized
)
aResult
-
>
top
=
GetSystemMetrics
(
SM_CXFRAME
)
+
GetSystemMetrics
(
SM_CXPADDEDBORDER
)
;
return
ok
;
}
HANDLE
theme
=
GetTheme
(
aWidgetType
)
;
if
(
!
theme
)
{
ok
=
ClassicGetWidgetPadding
(
aContext
aFrame
aWidgetType
aResult
)
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menupopup
)
{
SIZE
popupSize
;
GetThemePartSize
(
theme
nullptr
MENU_POPUPBORDERS
0
nullptr
TS_TRUE
&
popupSize
)
;
aResult
-
>
top
=
aResult
-
>
bottom
=
popupSize
.
cy
;
aResult
-
>
left
=
aResult
-
>
right
=
popupSize
.
cx
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
NumberInput
|
|
aWidgetType
=
=
StyleAppearance
:
:
Textfield
|
|
aWidgetType
=
=
StyleAppearance
:
:
TextfieldMultiline
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menulist
)
{
if
(
aFrame
-
>
PresContext
(
)
-
>
HasAuthorSpecifiedRules
(
aFrame
NS_AUTHOR_SPECIFIED_PADDING
)
)
return
false
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
NumberInput
|
|
aWidgetType
=
=
StyleAppearance
:
:
Textfield
|
|
aWidgetType
=
=
StyleAppearance
:
:
TextfieldMultiline
)
{
aResult
-
>
top
=
aResult
-
>
bottom
=
2
;
aResult
-
>
left
=
aResult
-
>
right
=
2
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
else
if
(
IsHTMLContent
(
aFrame
)
&
&
aWidgetType
=
=
StyleAppearance
:
:
Menulist
)
{
aResult
-
>
top
=
aResult
-
>
bottom
=
1
;
aResult
-
>
left
=
aResult
-
>
right
=
1
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
int32_t
right
left
top
bottom
;
right
=
left
=
top
=
bottom
=
0
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Menuimage
:
right
=
8
;
left
=
3
;
break
;
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
right
=
8
;
left
=
0
;
break
;
case
StyleAppearance
:
:
Menuitemtext
:
{
SIZE
size
(
GetGutterSize
(
theme
nullptr
)
)
;
left
=
size
.
cx
+
2
;
}
break
;
case
StyleAppearance
:
:
Menuseparator
:
{
SIZE
size
(
GetGutterSize
(
theme
nullptr
)
)
;
left
=
size
.
cx
+
5
;
top
=
10
;
bottom
=
7
;
}
break
;
default
:
return
false
;
}
if
(
IsFrameRTL
(
aFrame
)
)
{
aResult
-
>
right
=
left
;
aResult
-
>
left
=
right
;
}
else
{
aResult
-
>
right
=
right
;
aResult
-
>
left
=
left
;
}
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
bool
nsNativeThemeWin
:
:
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
nsRect
*
aOverflowRect
)
{
#
if
0
if
(
aWidgetType
=
=
StyleAppearance
:
:
MenulistButton
&
&
IsHTMLContent
(
aFrame
)
&
&
!
IsWidgetStyled
(
aFrame
-
>
GetParent
(
)
-
>
PresContext
(
)
aFrame
-
>
GetParent
(
)
StyleAppearance
:
:
Menulist
)
)
{
int32_t
p2a
=
aContext
-
>
AppUnitsPerDevPixel
(
)
;
nsMargin
m
(
p2a
p2a
p2a
0
)
;
aOverflowRect
-
>
Inflate
(
m
)
;
return
true
;
}
#
endif
if
(
aWidgetType
=
=
StyleAppearance
:
:
FocusOutline
)
{
LayoutDeviceIntMargin
border
=
GetWidgetBorder
(
aContext
aFrame
aWidgetType
)
;
int32_t
p2a
=
aContext
-
>
AppUnitsPerDevPixel
(
)
;
nsMargin
m
(
NSIntPixelsToAppUnits
(
border
.
top
p2a
)
NSIntPixelsToAppUnits
(
border
.
right
p2a
)
NSIntPixelsToAppUnits
(
border
.
bottom
p2a
)
NSIntPixelsToAppUnits
(
border
.
left
p2a
)
)
;
aOverflowRect
-
>
Inflate
(
m
)
;
return
true
;
}
return
false
;
}
NS_IMETHODIMP
nsNativeThemeWin
:
:
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
LayoutDeviceIntSize
*
aResult
bool
*
aIsOverridable
)
{
aResult
-
>
width
=
aResult
-
>
height
=
0
;
*
aIsOverridable
=
true
;
nsresult
rv
=
NS_OK
;
mozilla
:
:
Maybe
<
nsUXThemeClass
>
themeClass
=
GetThemeClass
(
aWidgetType
)
;
HTHEME
theme
=
NULL
;
if
(
!
themeClass
.
isNothing
(
)
)
{
theme
=
nsUXThemeData
:
:
GetTheme
(
themeClass
.
value
(
)
)
;
}
if
(
!
theme
)
{
rv
=
ClassicGetMinimumWidgetSize
(
aFrame
aWidgetType
aResult
aIsOverridable
)
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Toolbox
:
case
StyleAppearance
:
:
MozWinMediaToolbox
:
case
StyleAppearance
:
:
MozWinCommunicationsToolbox
:
case
StyleAppearance
:
:
MozWinBrowsertabbarToolbox
:
case
StyleAppearance
:
:
Toolbar
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Menuitemtext
:
case
StyleAppearance
:
:
MozWinGlass
:
case
StyleAppearance
:
:
MozWinBorderlessGlass
:
return
NS_OK
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menuitem
&
&
IsTopLevelMenu
(
aFrame
)
)
return
NS_OK
;
THEMESIZE
sizeReq
=
TS_TRUE
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
MenulistButton
:
{
rv
=
ClassicGetMinimumWidgetSize
(
aFrame
aWidgetType
aResult
aIsOverridable
)
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
if
(
!
IsTopLevelMenu
(
aFrame
)
)
{
SIZE
gutterSize
(
GetCachedGutterSize
(
theme
)
)
;
aResult
-
>
width
=
gutterSize
.
cx
;
aResult
-
>
height
=
gutterSize
.
cy
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
break
;
case
StyleAppearance
:
:
Menuimage
:
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
{
SIZE
boxSize
(
GetCachedGutterSize
(
theme
)
)
;
aResult
-
>
width
=
boxSize
.
cx
+
2
;
aResult
-
>
height
=
boxSize
.
cy
;
*
aIsOverridable
=
false
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
case
StyleAppearance
:
:
Menuitemtext
:
return
NS_OK
;
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
sizeReq
=
TS_MIN
;
break
;
case
StyleAppearance
:
:
Resizer
:
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
case
StyleAppearance
:
:
ScalethumbVertical
:
{
*
aIsOverridable
=
false
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScalethumbHorizontal
|
|
(
aWidgetType
=
=
StyleAppearance
:
:
RangeThumb
&
&
IsRangeHorizontal
(
aFrame
)
)
)
{
aResult
-
>
width
=
12
;
aResult
-
>
height
=
20
;
}
else
{
aResult
-
>
width
=
20
;
aResult
-
>
height
=
12
;
}
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
Scrollcorner
:
{
if
(
nsLookAndFeel
:
:
GetInt
(
nsLookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
)
{
aResult
-
>
SizeTo
(
:
:
GetSystemMetrics
(
SM_CXHSCROLL
)
:
:
GetSystemMetrics
(
SM_CYVSCROLL
)
)
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
break
;
}
case
StyleAppearance
:
:
Separator
:
aResult
-
>
width
=
6
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
case
StyleAppearance
:
:
Button
:
if
(
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
)
)
{
sizeReq
=
TS_MIN
;
}
break
;
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
aResult
-
>
width
=
nsUXThemeData
:
:
GetCommandButtonMetrics
(
CMDBUTTONIDX_RESTORE
)
.
cx
;
aResult
-
>
height
=
nsUXThemeData
:
:
GetCommandButtonMetrics
(
CMDBUTTONIDX_RESTORE
)
.
cy
;
AddPaddingRect
(
aResult
CAPTIONBUTTON_RESTORE
)
;
*
aIsOverridable
=
false
;
return
rv
;
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
aResult
-
>
width
=
nsUXThemeData
:
:
GetCommandButtonMetrics
(
CMDBUTTONIDX_MINIMIZE
)
.
cx
;
aResult
-
>
height
=
nsUXThemeData
:
:
GetCommandButtonMetrics
(
CMDBUTTONIDX_MINIMIZE
)
.
cy
;
AddPaddingRect
(
aResult
CAPTIONBUTTON_MINIMIZE
)
;
*
aIsOverridable
=
false
;
return
rv
;
case
StyleAppearance
:
:
MozWindowButtonClose
:
aResult
-
>
width
=
nsUXThemeData
:
:
GetCommandButtonMetrics
(
CMDBUTTONIDX_CLOSE
)
.
cx
;
aResult
-
>
height
=
nsUXThemeData
:
:
GetCommandButtonMetrics
(
CMDBUTTONIDX_CLOSE
)
.
cy
;
AddPaddingRect
(
aResult
CAPTIONBUTTON_CLOSE
)
;
*
aIsOverridable
=
false
;
return
rv
;
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
aResult
-
>
height
=
GetSystemMetrics
(
SM_CYCAPTION
)
;
aResult
-
>
height
+
=
GetSystemMetrics
(
SM_CYFRAME
)
;
aResult
-
>
height
+
=
GetSystemMetrics
(
SM_CXPADDEDBORDER
)
;
if
(
IsWin10OrLater
(
)
)
{
ScaleForFrameDPI
(
aResult
aFrame
)
;
}
*
aIsOverridable
=
false
;
return
rv
;
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowButtonBoxMaximized
:
if
(
nsUXThemeData
:
:
CheckForCompositor
(
)
)
{
aResult
-
>
width
=
nsUXThemeData
:
:
GetCommandButtonBoxMetrics
(
)
.
cx
;
aResult
-
>
height
=
nsUXThemeData
:
:
GetCommandButtonBoxMetrics
(
)
.
cy
-
GetSystemMetrics
(
SM_CYFRAME
)
-
GetSystemMetrics
(
SM_CXPADDEDBORDER
)
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonBoxMaximized
)
{
aResult
-
>
width
+
=
1
;
aResult
-
>
height
-
=
2
;
}
*
aIsOverridable
=
false
;
return
rv
;
}
break
;
case
StyleAppearance
:
:
MozWindowFrameLeft
:
case
StyleAppearance
:
:
MozWindowFrameRight
:
case
StyleAppearance
:
:
MozWindowFrameBottom
:
aResult
-
>
width
=
GetSystemMetrics
(
SM_CXFRAME
)
;
aResult
-
>
height
=
GetSystemMetrics
(
SM_CYFRAME
)
;
*
aIsOverridable
=
false
;
return
rv
;
}
int32_t
part
state
;
rv
=
GetThemePartAndState
(
aFrame
aWidgetType
part
state
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
GetCachedMinimumWidgetSize
(
aFrame
theme
themeClass
.
value
(
)
aWidgetType
part
state
sizeReq
aResult
)
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
rv
;
}
NS_IMETHODIMP
nsNativeThemeWin
:
:
WidgetStateChanged
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
nsAtom
*
aAttribute
bool
*
aShouldRepaint
const
nsAttrValue
*
aOldValue
)
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
Toolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinMediaToolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinCommunicationsToolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinBrowsertabbarToolbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
Toolbar
|
|
aWidgetType
=
=
StyleAppearance
:
:
Statusbar
|
|
aWidgetType
=
=
StyleAppearance
:
:
Statusbarpanel
|
|
aWidgetType
=
=
StyleAppearance
:
:
Resizerpanel
|
|
aWidgetType
=
=
StyleAppearance
:
:
Progresschunk
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgresschunkVertical
|
|
aWidgetType
=
=
StyleAppearance
:
:
Progressbar
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgressbarVertical
|
|
aWidgetType
=
=
StyleAppearance
:
:
Tooltip
|
|
aWidgetType
=
=
StyleAppearance
:
:
Tabpanels
|
|
aWidgetType
=
=
StyleAppearance
:
:
Tabpanel
|
|
aWidgetType
=
=
StyleAppearance
:
:
Separator
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinGlass
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWinBorderlessGlass
)
{
*
aShouldRepaint
=
false
;
return
NS_OK
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebar
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebarMaximized
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowFrameLeft
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowFrameRight
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowFrameBottom
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonClose
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMinimize
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMaximize
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonRestore
)
{
*
aShouldRepaint
=
true
;
return
NS_OK
;
}
if
(
(
aWidgetType
=
=
StyleAppearance
:
:
Menulist
|
|
aWidgetType
=
=
StyleAppearance
:
:
MenulistButton
)
&
&
IsHTMLContent
(
aFrame
)
)
{
*
aShouldRepaint
=
true
;
return
NS_OK
;
}
if
(
!
aAttribute
)
{
*
aShouldRepaint
=
true
;
}
else
{
*
aShouldRepaint
=
false
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
|
|
aAttribute
=
=
nsGkAtoms
:
:
checked
|
|
aAttribute
=
=
nsGkAtoms
:
:
selected
|
|
aAttribute
=
=
nsGkAtoms
:
:
visuallyselected
|
|
aAttribute
=
=
nsGkAtoms
:
:
readonly
|
|
aAttribute
=
=
nsGkAtoms
:
:
open
|
|
aAttribute
=
=
nsGkAtoms
:
:
menuactive
|
|
aAttribute
=
=
nsGkAtoms
:
:
focused
)
*
aShouldRepaint
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNativeThemeWin
:
:
ThemeChanged
(
)
{
nsUXThemeData
:
:
Invalidate
(
)
;
memset
(
mBorderCacheValid
0
sizeof
(
mBorderCacheValid
)
)
;
memset
(
mMinimumWidgetSizeCacheValid
0
sizeof
(
mMinimumWidgetSizeCacheValid
)
)
;
mGutterSizeCacheValid
=
false
;
return
NS_OK
;
}
bool
nsNativeThemeWin
:
:
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
FocusOutline
)
{
return
true
;
}
HANDLE
theme
=
nullptr
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
CheckboxContainer
)
theme
=
GetTheme
(
StyleAppearance
:
:
Checkbox
)
;
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
RadioContainer
)
theme
=
GetTheme
(
StyleAppearance
:
:
Radio
)
;
else
theme
=
GetTheme
(
aWidgetType
)
;
if
(
theme
&
&
aWidgetType
=
=
StyleAppearance
:
:
Resizer
)
return
true
;
if
(
(
theme
)
|
|
(
!
theme
&
&
ClassicThemeSupportsWidget
(
aFrame
aWidgetType
)
)
)
return
(
!
IsWidgetStyled
(
aPresContext
aFrame
aWidgetType
)
)
;
return
false
;
}
bool
nsNativeThemeWin
:
:
WidgetIsContainer
(
WidgetType
aWidgetType
)
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
MenulistButton
|
|
aWidgetType
=
=
StyleAppearance
:
:
Radio
|
|
aWidgetType
=
=
StyleAppearance
:
:
Checkbox
)
return
false
;
return
true
;
}
bool
nsNativeThemeWin
:
:
ThemeDrawsFocusForWidget
(
WidgetType
aWidgetType
)
{
return
false
;
}
bool
nsNativeThemeWin
:
:
ThemeNeedsComboboxDropmarker
(
)
{
return
true
;
}
bool
nsNativeThemeWin
:
:
WidgetAppearanceDependsOnWindowFocus
(
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
case
StyleAppearance
:
:
MozWindowFrameLeft
:
case
StyleAppearance
:
:
MozWindowFrameRight
:
case
StyleAppearance
:
:
MozWindowFrameBottom
:
case
StyleAppearance
:
:
MozWindowButtonClose
:
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
return
true
;
default
:
return
false
;
}
}
nsITheme
:
:
ThemeGeometryType
nsNativeThemeWin
:
:
ThemeGeometryTypeForWidget
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowButtonBoxMaximized
:
return
eThemeGeometryTypeWindowButtons
;
default
:
return
eThemeGeometryTypeUnknown
;
}
}
nsITheme
:
:
Transparency
nsNativeThemeWin
:
:
GetWidgetTransparency
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
Scrollcorner
:
case
StyleAppearance
:
:
Statusbar
:
return
eOpaque
;
case
StyleAppearance
:
:
MozWinGlass
:
case
StyleAppearance
:
:
MozWinBorderlessGlass
:
case
StyleAppearance
:
:
ScaleHorizontal
:
case
StyleAppearance
:
:
ScaleVertical
:
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
case
StyleAppearance
:
:
Range
:
return
eTransparent
;
}
HANDLE
theme
=
GetTheme
(
aWidgetType
)
;
if
(
!
theme
)
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menupopup
|
|
aWidgetType
=
=
StyleAppearance
:
:
Tooltip
)
{
return
eOpaque
;
}
return
eUnknownTransparency
;
}
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aWidgetType
part
state
)
;
NS_ENSURE_SUCCESS
(
rv
eUnknownTransparency
)
;
if
(
part
<
=
0
)
{
return
eUnknownTransparency
;
}
if
(
IsThemeBackgroundPartiallyTransparent
(
theme
part
state
)
)
return
eTransparent
;
return
eOpaque
;
}
bool
nsNativeThemeWin
:
:
ClassicThemeSupportsWidget
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Resizer
:
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
return
!
parentFrame
|
|
!
parentFrame
-
>
IsScrollFrame
(
)
;
}
case
StyleAppearance
:
:
Menubar
:
case
StyleAppearance
:
:
Menupopup
:
if
(
!
nsUXThemeData
:
:
sFlatMenus
)
return
false
;
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
ScrollbarNonDisappearing
:
case
StyleAppearance
:
:
Scrollcorner
:
case
StyleAppearance
:
:
ScaleHorizontal
:
case
StyleAppearance
:
:
ScaleVertical
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
case
StyleAppearance
:
:
ScalethumbVertical
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
MenulistTextfield
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
case
StyleAppearance
:
:
Menuarrow
:
case
StyleAppearance
:
:
Menuseparator
:
case
StyleAppearance
:
:
Menuitemtext
:
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
case
StyleAppearance
:
:
MozWindowFrameLeft
:
case
StyleAppearance
:
:
MozWindowFrameRight
:
case
StyleAppearance
:
:
MozWindowFrameBottom
:
case
StyleAppearance
:
:
MozWindowButtonClose
:
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowButtonBoxMaximized
:
return
true
;
}
return
false
;
}
LayoutDeviceIntMargin
nsNativeThemeWin
:
:
ClassicGetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
)
{
LayoutDeviceIntMargin
result
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
Button
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
2
;
break
;
case
StyleAppearance
:
:
Statusbar
:
result
.
bottom
=
result
.
left
=
result
.
right
=
0
;
result
.
top
=
2
;
break
;
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistTextfield
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
FocusOutline
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
2
;
break
;
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
{
result
.
top
=
1
;
result
.
left
=
1
;
result
.
bottom
=
1
;
result
.
right
=
aFrame
-
>
GetNextSibling
(
)
?
3
:
1
;
break
;
}
case
StyleAppearance
:
:
Tooltip
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
1
;
break
;
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
1
;
break
;
case
StyleAppearance
:
:
Menubar
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
0
;
break
;
case
StyleAppearance
:
:
Menupopup
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
3
;
break
;
default
:
result
.
top
=
result
.
bottom
=
result
.
left
=
result
.
right
=
0
;
break
;
}
return
result
;
}
bool
nsNativeThemeWin
:
:
ClassicGetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
LayoutDeviceIntMargin
*
aResult
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
{
int32_t
part
state
;
bool
focused
;
if
(
NS_FAILED
(
ClassicGetThemePartAndState
(
aFrame
aWidgetType
part
state
focused
)
)
)
return
false
;
if
(
part
=
=
1
)
{
if
(
nsUXThemeData
:
:
sFlatMenus
|
|
!
(
state
&
DFCS_PUSHED
)
)
{
(
*
aResult
)
.
top
=
(
*
aResult
)
.
bottom
=
(
*
aResult
)
.
left
=
(
*
aResult
)
.
right
=
2
;
}
else
{
(
*
aResult
)
.
top
=
(
*
aResult
)
.
left
=
3
;
(
*
aResult
)
.
bottom
=
(
*
aResult
)
.
right
=
1
;
}
}
else
{
(
*
aResult
)
.
top
=
0
;
(
*
aResult
)
.
bottom
=
(
*
aResult
)
.
left
=
(
*
aResult
)
.
right
=
2
;
}
return
true
;
}
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
(
*
aResult
)
.
top
=
(
*
aResult
)
.
left
=
(
*
aResult
)
.
bottom
=
(
*
aResult
)
.
right
=
1
;
return
true
;
default
:
return
false
;
}
}
nsresult
nsNativeThemeWin
:
:
ClassicGetMinimumWidgetSize
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
LayoutDeviceIntSize
*
aResult
bool
*
aIsOverridable
)
{
(
*
aResult
)
.
width
=
(
*
aResult
)
.
height
=
0
;
*
aIsOverridable
=
true
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Checkbox
:
(
*
aResult
)
.
width
=
(
*
aResult
)
.
height
=
13
;
break
;
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
case
StyleAppearance
:
:
Menuarrow
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXMENUCHECK
)
;
(
*
aResult
)
.
height
=
:
:
GetSystemMetrics
(
SM_CYMENUCHECK
)
;
break
;
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXVSCROLL
)
;
(
*
aResult
)
.
height
=
8
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXVSCROLL
)
;
(
*
aResult
)
.
height
=
:
:
GetSystemMetrics
(
SM_CYVSCROLL
)
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXHSCROLL
)
;
(
*
aResult
)
.
height
=
:
:
GetSystemMetrics
(
SM_CYHSCROLL
)
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScrollbarVertical
:
break
;
case
StyleAppearance
:
:
ScrollbarNonDisappearing
:
{
aResult
-
>
SizeTo
(
:
:
GetSystemMetrics
(
SM_CXHSCROLL
)
:
:
GetSystemMetrics
(
SM_CYVSCROLL
)
)
;
break
;
}
case
StyleAppearance
:
:
RangeThumb
:
{
if
(
IsRangeHorizontal
(
aFrame
)
)
{
(
*
aResult
)
.
width
=
12
;
(
*
aResult
)
.
height
=
20
;
}
else
{
(
*
aResult
)
.
width
=
20
;
(
*
aResult
)
.
height
=
12
;
}
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
ScalethumbHorizontal
:
(
*
aResult
)
.
width
=
12
;
(
*
aResult
)
.
height
=
20
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScalethumbVertical
:
(
*
aResult
)
.
width
=
20
;
(
*
aResult
)
.
height
=
12
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
MenulistButton
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXVSCROLL
)
;
break
;
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
MenulistTextfield
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Tabpanels
:
break
;
case
StyleAppearance
:
:
Resizer
:
{
NONCLIENTMETRICS
nc
;
nc
.
cbSize
=
sizeof
(
nc
)
;
if
(
SystemParametersInfo
(
SPI_GETNONCLIENTMETRICS
sizeof
(
nc
)
&
nc
0
)
)
(
*
aResult
)
.
width
=
(
*
aResult
)
.
height
=
abs
(
nc
.
lfStatusFont
.
lfHeight
)
+
4
;
else
(
*
aResult
)
.
width
=
(
*
aResult
)
.
height
=
15
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXVSCROLL
)
;
(
*
aResult
)
.
height
=
:
:
GetSystemMetrics
(
SM_CYVTHUMB
)
;
if
(
!
GetTheme
(
aWidgetType
)
)
(
*
aResult
)
.
height
>
>
=
1
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXHTHUMB
)
;
(
*
aResult
)
.
height
=
:
:
GetSystemMetrics
(
SM_CYHSCROLL
)
;
if
(
!
GetTheme
(
aWidgetType
)
)
(
*
aResult
)
.
width
>
>
=
1
;
*
aIsOverridable
=
false
;
break
;
case
StyleAppearance
:
:
ScrollbarHorizontal
:
(
*
aResult
)
.
width
=
:
:
GetSystemMetrics
(
SM_CXHTHUMB
)
<
<
1
;
break
;
}
case
StyleAppearance
:
:
Menuseparator
:
{
aResult
-
>
width
=
0
;
aResult
-
>
height
=
10
;
break
;
}
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
case
StyleAppearance
:
:
MozWindowTitlebar
:
aResult
-
>
height
=
GetSystemMetrics
(
SM_CYCAPTION
)
;
aResult
-
>
height
+
=
GetSystemMetrics
(
SM_CYFRAME
)
;
aResult
-
>
width
=
0
;
break
;
case
StyleAppearance
:
:
MozWindowFrameLeft
:
case
StyleAppearance
:
:
MozWindowFrameRight
:
aResult
-
>
width
=
GetSystemMetrics
(
SM_CXFRAME
)
;
aResult
-
>
height
=
0
;
break
;
case
StyleAppearance
:
:
MozWindowFrameBottom
:
aResult
-
>
height
=
GetSystemMetrics
(
SM_CYFRAME
)
;
aResult
-
>
width
=
0
;
break
;
case
StyleAppearance
:
:
MozWindowButtonClose
:
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
aResult
-
>
width
=
GetSystemMetrics
(
SM_CXSIZE
)
;
aResult
-
>
height
=
GetSystemMetrics
(
SM_CYSIZE
)
;
aResult
-
>
width
-
=
2
;
aResult
-
>
height
-
=
4
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMinimize
)
{
AddPaddingRect
(
aResult
CAPTIONBUTTON_MINIMIZE
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMaximize
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonRestore
)
{
AddPaddingRect
(
aResult
CAPTIONBUTTON_RESTORE
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonClose
)
{
AddPaddingRect
(
aResult
CAPTIONBUTTON_CLOSE
)
;
}
break
;
default
:
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
nsNativeThemeWin
:
:
ClassicGetThemePartAndState
(
nsIFrame
*
aFrame
WidgetType
aWidgetType
int32_t
&
aPart
int32_t
&
aState
bool
&
aFocused
)
{
aFocused
=
false
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Button
:
{
EventStates
contentState
;
aPart
=
DFC_BUTTON
;
aState
=
DFCS_BUTTONPUSH
;
aFocused
=
false
;
contentState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
contentState
)
)
aState
|
=
DFCS_INACTIVE
;
else
if
(
IsOpenButton
(
aFrame
)
)
aState
|
=
DFCS_PUSHED
;
else
if
(
IsCheckedButton
(
aFrame
)
)
aState
|
=
DFCS_CHECKED
;
else
{
if
(
contentState
.
HasAllStates
(
NS_EVENT_STATE_ACTIVE
|
NS_EVENT_STATE_HOVER
)
)
{
aState
|
=
DFCS_PUSHED
;
const
nsStyleUserInterface
*
uiData
=
aFrame
-
>
StyleUserInterface
(
)
;
if
(
uiData
-
>
mUserFocus
=
=
StyleUserFocus
:
:
Normal
)
{
if
(
!
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
)
)
aState
|
=
DFCS_FLAT
;
aFocused
=
true
;
}
}
if
(
contentState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
|
|
(
aState
=
=
DFCS_BUTTONPUSH
&
&
IsDefaultButton
(
aFrame
)
)
)
{
aFocused
=
true
;
}
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
{
EventStates
contentState
;
aFocused
=
false
;
aPart
=
DFC_BUTTON
;
aState
=
0
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
bool
isCheckbox
=
(
aWidgetType
=
=
StyleAppearance
:
:
Checkbox
)
;
bool
isChecked
=
GetCheckedOrSelected
(
aFrame
!
isCheckbox
)
;
bool
isIndeterminate
=
isCheckbox
&
&
GetIndeterminate
(
aFrame
)
;
if
(
isCheckbox
)
{
if
(
isIndeterminate
)
{
aState
=
DFCS_BUTTON3STATE
|
DFCS_CHECKED
;
}
else
{
aState
=
DFCS_BUTTONCHECK
;
}
}
else
{
aState
=
DFCS_BUTTONRADIO
;
}
if
(
isChecked
)
{
aState
|
=
DFCS_CHECKED
;
}
contentState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
!
content
-
>
IsXULElement
(
)
&
&
contentState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
{
aFocused
=
true
;
}
if
(
IsDisabled
(
aFrame
contentState
)
)
{
aState
|
=
DFCS_INACTIVE
;
}
else
if
(
contentState
.
HasAllStates
(
NS_EVENT_STATE_ACTIVE
|
NS_EVENT_STATE_HOVER
)
)
{
aState
|
=
DFCS_PUSHED
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
{
bool
isTopLevel
=
false
;
bool
isOpen
=
false
;
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
aFrame
)
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
aPart
=
0
;
aState
=
0
;
if
(
menuFrame
)
{
isTopLevel
=
menuFrame
-
>
IsOnMenuBar
(
)
;
isOpen
=
menuFrame
-
>
IsOpen
(
)
;
}
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
|
=
DFCS_INACTIVE
;
if
(
isTopLevel
)
{
aPart
=
1
;
if
(
isOpen
)
aState
|
=
DFCS_PUSHED
;
}
if
(
IsMenuActive
(
aFrame
aWidgetType
)
)
aState
|
=
DFCS_HOT
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
case
StyleAppearance
:
:
Menuarrow
:
{
aState
=
0
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
aState
|
=
DFCS_INACTIVE
;
if
(
IsMenuActive
(
aFrame
aWidgetType
)
)
aState
|
=
DFCS_HOT
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menucheckbox
|
|
aWidgetType
=
=
StyleAppearance
:
:
Menuradio
)
{
if
(
IsCheckedButton
(
aFrame
)
)
aState
|
=
DFCS_CHECKED
;
}
else
if
(
IsFrameRTL
(
aFrame
)
)
{
aState
|
=
DFCS_RTL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
FocusOutline
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistTextfield
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
Scrollcorner
:
case
StyleAppearance
:
:
ScaleHorizontal
:
case
StyleAppearance
:
:
ScaleVertical
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
case
StyleAppearance
:
:
ScalethumbVertical
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Menubar
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Groupbox
:
return
NS_OK
;
case
StyleAppearance
:
:
MenulistButton
:
{
aPart
=
DFC_SCROLL
;
aState
=
DFCS_SCROLLCOMBOBOX
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
bool
isHTML
=
IsHTMLContent
(
aFrame
)
;
bool
isMenulist
=
!
isHTML
&
&
parentFrame
-
>
IsMenuFrame
(
)
;
bool
isOpen
=
false
;
if
(
isHTML
|
|
isMenulist
)
aFrame
=
parentFrame
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
aState
|
=
DFCS_INACTIVE
;
return
NS_OK
;
}
if
(
isHTML
)
{
nsIComboboxControlFrame
*
ccf
=
do_QueryFrame
(
aFrame
)
;
isOpen
=
(
ccf
&
&
ccf
-
>
IsDroppedDownOrHasParentPopup
(
)
)
;
}
else
isOpen
=
IsOpenButton
(
aFrame
)
;
if
(
isOpen
&
&
(
isHTML
|
|
isMenulist
)
)
return
NS_OK
;
if
(
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
)
aState
|
=
DFCS_PUSHED
|
DFCS_FLAT
;
return
NS_OK
;
}
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
{
EventStates
contentState
=
GetContentState
(
aFrame
aWidgetType
)
;
aPart
=
DFC_SCROLL
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
aState
=
DFCS_SCROLLUP
;
break
;
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
aState
=
DFCS_SCROLLDOWN
;
break
;
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
aState
=
DFCS_SCROLLLEFT
;
break
;
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
aState
=
DFCS_SCROLLRIGHT
;
break
;
}
if
(
IsDisabled
(
aFrame
contentState
)
)
aState
|
=
DFCS_INACTIVE
;
else
{
if
(
contentState
.
HasAllStates
(
NS_EVENT_STATE_HOVER
|
NS_EVENT_STATE_ACTIVE
)
)
aState
|
=
DFCS_PUSHED
|
DFCS_FLAT
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
{
EventStates
contentState
=
GetContentState
(
aFrame
aWidgetType
)
;
aPart
=
DFC_SCROLL
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
SpinnerUpbutton
:
aState
=
DFCS_SCROLLUP
;
break
;
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
aState
=
DFCS_SCROLLDOWN
;
break
;
}
if
(
IsDisabled
(
aFrame
contentState
)
)
aState
|
=
DFCS_INACTIVE
;
else
{
if
(
contentState
.
HasAllStates
(
NS_EVENT_STATE_HOVER
|
NS_EVENT_STATE_ACTIVE
)
)
aState
|
=
DFCS_PUSHED
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Resizer
:
aPart
=
DFC_SCROLL
;
aState
=
(
IsFrameRTL
(
aFrame
)
)
?
DFCS_SCROLLSIZEGRIPRIGHT
:
DFCS_SCROLLSIZEGRIP
;
return
NS_OK
;
case
StyleAppearance
:
:
Menuseparator
:
aPart
=
0
;
aState
=
0
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowTitlebar
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_CAPTION
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_MAXCAPTION
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowFrameLeft
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_FRAMELEFT
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowFrameRight
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_FRAMERIGHT
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowFrameBottom
:
aPart
=
mozilla
:
:
widget
:
:
themeconst
:
:
WP_FRAMEBOTTOM
;
aState
=
GetTopLevelWindowActiveState
(
aFrame
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonClose
:
aPart
=
DFC_CAPTION
;
aState
=
DFCS_CAPTIONCLOSE
|
GetClassicWindowFrameButtonState
(
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
aPart
=
DFC_CAPTION
;
aState
=
DFCS_CAPTIONMIN
|
GetClassicWindowFrameButtonState
(
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
aPart
=
DFC_CAPTION
;
aState
=
DFCS_CAPTIONMAX
|
GetClassicWindowFrameButtonState
(
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
case
StyleAppearance
:
:
MozWindowButtonRestore
:
aPart
=
DFC_CAPTION
;
aState
=
DFCS_CAPTIONRESTORE
|
GetClassicWindowFrameButtonState
(
GetContentState
(
aFrame
aWidgetType
)
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
static
void
DrawTab
(
HDC
hdc
const
RECT
&
R
int32_t
aPosition
bool
aSelected
bool
aDrawLeft
bool
aDrawRight
)
{
int32_t
leftFlag
topFlag
rightFlag
lightFlag
shadeFlag
;
RECT
topRect
sideRect
bottomRect
lightRect
shadeRect
;
int32_t
selectedOffset
lOffset
rOffset
;
selectedOffset
=
aSelected
?
1
:
0
;
lOffset
=
aDrawLeft
?
2
:
0
;
rOffset
=
aDrawRight
?
2
:
0
;
switch
(
aPosition
)
{
case
BF_LEFT
:
leftFlag
=
BF_TOP
;
topFlag
=
BF_LEFT
;
rightFlag
=
BF_BOTTOM
;
lightFlag
=
BF_DIAGONAL_ENDTOPRIGHT
;
shadeFlag
=
BF_DIAGONAL_ENDBOTTOMRIGHT
;
:
:
SetRect
(
&
topRect
R
.
left
R
.
top
+
lOffset
R
.
right
R
.
bottom
-
rOffset
)
;
:
:
SetRect
(
&
sideRect
R
.
left
+
2
R
.
top
R
.
right
-
2
+
selectedOffset
R
.
bottom
)
;
:
:
SetRect
(
&
bottomRect
R
.
right
-
2
R
.
top
R
.
right
R
.
bottom
)
;
:
:
SetRect
(
&
lightRect
R
.
left
R
.
top
R
.
left
+
3
R
.
top
+
3
)
;
:
:
SetRect
(
&
shadeRect
R
.
left
+
1
R
.
bottom
-
2
R
.
left
+
2
R
.
bottom
-
1
)
;
break
;
case
BF_TOP
:
leftFlag
=
BF_LEFT
;
topFlag
=
BF_TOP
;
rightFlag
=
BF_RIGHT
;
lightFlag
=
BF_DIAGONAL_ENDTOPRIGHT
;
shadeFlag
=
BF_DIAGONAL_ENDBOTTOMRIGHT
;
:
:
SetRect
(
&
topRect
R
.
left
+
lOffset
R
.
top
R
.
right
-
rOffset
R
.
bottom
)
;
:
:
SetRect
(
&
sideRect
R
.
left
R
.
top
+
2
R
.
right
R
.
bottom
-
1
+
selectedOffset
)
;
:
:
SetRect
(
&
bottomRect
R
.
left
R
.
bottom
-
1
R
.
right
R
.
bottom
)
;
:
:
SetRect
(
&
lightRect
R
.
left
R
.
top
R
.
left
+
3
R
.
top
+
3
)
;
:
:
SetRect
(
&
shadeRect
R
.
right
-
2
R
.
top
+
1
R
.
right
-
1
R
.
top
+
2
)
;
break
;
case
BF_RIGHT
:
leftFlag
=
BF_TOP
;
topFlag
=
BF_RIGHT
;
rightFlag
=
BF_BOTTOM
;
lightFlag
=
BF_DIAGONAL_ENDTOPLEFT
;
shadeFlag
=
BF_DIAGONAL_ENDBOTTOMLEFT
;
:
:
SetRect
(
&
topRect
R
.
left
R
.
top
+
lOffset
R
.
right
R
.
bottom
-
rOffset
)
;
:
:
SetRect
(
&
sideRect
R
.
left
+
2
-
selectedOffset
R
.
top
R
.
right
-
2
R
.
bottom
)
;
:
:
SetRect
(
&
bottomRect
R
.
left
R
.
top
R
.
left
+
2
R
.
bottom
)
;
:
:
SetRect
(
&
lightRect
R
.
right
-
3
R
.
top
R
.
right
-
1
R
.
top
+
2
)
;
:
:
SetRect
(
&
shadeRect
R
.
right
-
2
R
.
bottom
-
3
R
.
right
R
.
bottom
-
1
)
;
break
;
case
BF_BOTTOM
:
leftFlag
=
BF_LEFT
;
topFlag
=
BF_BOTTOM
;
rightFlag
=
BF_RIGHT
;
lightFlag
=
BF_DIAGONAL_ENDTOPLEFT
;
shadeFlag
=
BF_DIAGONAL_ENDBOTTOMLEFT
;
:
:
SetRect
(
&
topRect
R
.
left
+
lOffset
R
.
top
R
.
right
-
rOffset
R
.
bottom
)
;
:
:
SetRect
(
&
sideRect
R
.
left
R
.
top
+
2
-
selectedOffset
R
.
right
R
.
bottom
-
2
)
;
:
:
SetRect
(
&
bottomRect
R
.
left
R
.
top
R
.
right
R
.
top
+
2
)
;
:
:
SetRect
(
&
lightRect
R
.
left
R
.
bottom
-
3
R
.
left
+
2
R
.
bottom
-
1
)
;
:
:
SetRect
(
&
shadeRect
R
.
right
-
2
R
.
bottom
-
3
R
.
right
R
.
bottom
-
1
)
;
break
;
default
:
MOZ_CRASH
(
)
;
}
:
:
FillRect
(
hdc
&
R
(
HBRUSH
)
(
COLOR_3DFACE
+
1
)
)
;
:
:
DrawEdge
(
hdc
&
topRect
EDGE_RAISED
BF_SOFT
|
topFlag
)
;
if
(
!
aSelected
)
:
:
DrawEdge
(
hdc
&
bottomRect
EDGE_RAISED
BF_SOFT
|
topFlag
)
;
if
(
!
aDrawLeft
)
leftFlag
=
0
;
if
(
!
aDrawRight
)
rightFlag
=
0
;
:
:
DrawEdge
(
hdc
&
sideRect
EDGE_RAISED
BF_SOFT
|
leftFlag
|
rightFlag
)
;
if
(
aDrawLeft
)
:
:
DrawEdge
(
hdc
&
lightRect
EDGE_RAISED
BF_SOFT
|
lightFlag
)
;
if
(
aDrawRight
)
:
:
DrawEdge
(
hdc
&
shadeRect
EDGE_RAISED
BF_SOFT
|
shadeFlag
)
;
}
static
void
DrawMenuImage
(
HDC
hdc
const
RECT
&
rc
int32_t
aComponent
uint32_t
aColor
)
{
HDC
hMemoryDC
=
:
:
CreateCompatibleDC
(
hdc
)
;
if
(
hMemoryDC
)
{
int
checkW
=
:
:
GetSystemMetrics
(
SM_CXMENUCHECK
)
;
int
checkH
=
:
:
GetSystemMetrics
(
SM_CYMENUCHECK
)
;
HBITMAP
hMonoBitmap
=
:
:
CreateBitmap
(
checkW
checkH
1
1
nullptr
)
;
if
(
hMonoBitmap
)
{
HBITMAP
hPrevBitmap
=
(
HBITMAP
)
:
:
SelectObject
(
hMemoryDC
hMonoBitmap
)
;
if
(
hPrevBitmap
)
{
RECT
imgRect
=
{
0
0
checkW
checkH
}
;
POINT
imgPos
=
{
rc
.
left
+
(
rc
.
right
-
rc
.
left
-
checkW
)
/
2
rc
.
top
+
(
rc
.
bottom
-
rc
.
top
-
checkH
)
/
2
}
;
if
(
aComponent
=
=
DFCS_MENUCHECK
|
|
aComponent
=
=
DFCS_MENUBULLET
)
imgPos
.
y
+
+
;
:
:
DrawFrameControl
(
hMemoryDC
&
imgRect
DFC_MENU
aComponent
)
;
COLORREF
oldTextCol
=
:
:
SetTextColor
(
hdc
0x00000000
)
;
COLORREF
oldBackCol
=
:
:
SetBkColor
(
hdc
0x00FFFFFF
)
;
:
:
BitBlt
(
hdc
imgPos
.
x
imgPos
.
y
checkW
checkH
hMemoryDC
0
0
SRCAND
)
;
:
:
SetTextColor
(
hdc
:
:
GetSysColor
(
aColor
)
)
;
:
:
SetBkColor
(
hdc
0x00000000
)
;
:
:
BitBlt
(
hdc
imgPos
.
x
imgPos
.
y
checkW
checkH
hMemoryDC
0
0
SRCPAINT
)
;
:
:
SetTextColor
(
hdc
oldTextCol
)
;
:
:
SetBkColor
(
hdc
oldBackCol
)
;
:
:
SelectObject
(
hMemoryDC
hPrevBitmap
)
;
}
:
:
DeleteObject
(
hMonoBitmap
)
;
}
:
:
DeleteDC
(
hMemoryDC
)
;
}
}
void
nsNativeThemeWin
:
:
DrawCheckedRect
(
HDC
hdc
const
RECT
&
rc
int32_t
fore
int32_t
back
HBRUSH
defaultBack
)
{
static
WORD
patBits
[
8
]
=
{
0xaa
0x55
0xaa
0x55
0xaa
0x55
0xaa
0x55
}
;
HBITMAP
patBmp
=
:
:
CreateBitmap
(
8
8
1
1
patBits
)
;
if
(
patBmp
)
{
HBRUSH
brush
=
(
HBRUSH
)
:
:
CreatePatternBrush
(
patBmp
)
;
if
(
brush
)
{
COLORREF
oldForeColor
=
:
:
SetTextColor
(
hdc
:
:
GetSysColor
(
fore
)
)
;
COLORREF
oldBackColor
=
:
:
SetBkColor
(
hdc
:
:
GetSysColor
(
back
)
)
;
POINT
vpOrg
;
:
:
UnrealizeObject
(
brush
)
;
:
:
GetViewportOrgEx
(
hdc
&
vpOrg
)
;
:
:
SetBrushOrgEx
(
hdc
vpOrg
.
x
+
rc
.
left
vpOrg
.
y
+
rc
.
top
nullptr
)
;
HBRUSH
oldBrush
=
(
HBRUSH
)
:
:
SelectObject
(
hdc
brush
)
;
:
:
FillRect
(
hdc
&
rc
brush
)
;
:
:
SetTextColor
(
hdc
oldForeColor
)
;
:
:
SetBkColor
(
hdc
oldBackColor
)
;
:
:
SelectObject
(
hdc
oldBrush
)
;
:
:
DeleteObject
(
brush
)
;
}
else
:
:
FillRect
(
hdc
&
rc
defaultBack
)
;
:
:
DeleteObject
(
patBmp
)
;
}
}
nsresult
nsNativeThemeWin
:
:
ClassicDrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
WidgetType
aWidgetType
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
)
{
int32_t
part
state
;
bool
focused
;
nsresult
rv
;
rv
=
ClassicGetThemePartAndState
(
aFrame
aWidgetType
part
state
focused
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
AssumeThemePartAndStateAreTransparent
(
part
state
)
)
{
return
NS_OK
;
}
gfxFloat
p2a
=
gfxFloat
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RECT
widgetRect
;
gfxRect
tr
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
dr
(
aDirtyRect
.
X
(
)
aDirtyRect
.
Y
(
)
aDirtyRect
.
Width
(
)
aDirtyRect
.
Height
(
)
)
;
tr
.
Scale
(
1
.
0
/
p2a
)
;
dr
.
Scale
(
1
.
0
/
p2a
)
;
RefPtr
<
gfxContext
>
ctx
=
aContext
;
gfxWindowsNativeDrawing
nativeDrawing
(
ctx
dr
GetWidgetNativeDrawingFlags
(
aWidgetType
)
)
;
RENDER_AGAIN
:
HDC
hdc
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
!
hdc
)
return
NS_ERROR_FAILURE
;
nativeDrawing
.
TransformToNativeRect
(
tr
widgetRect
)
;
rv
=
NS_OK
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Button
:
{
if
(
focused
)
{
HBRUSH
brush
;
brush
=
:
:
GetSysColorBrush
(
COLOR_3DDKSHADOW
)
;
if
(
brush
)
:
:
FrameRect
(
hdc
&
widgetRect
brush
)
;
InflateRect
(
&
widgetRect
-
1
-
1
)
;
}
}
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
Resizer
:
{
int32_t
oldTA
;
oldTA
=
:
:
SetTextAlign
(
hdc
TA_TOP
|
TA_LEFT
|
TA_NOUPDATECP
)
;
:
:
DrawFrameControl
(
hdc
&
widgetRect
part
state
)
;
:
:
SetTextAlign
(
hdc
oldTA
)
;
break
;
}
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistTextfield
:
{
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_SUNKEN
BF_RECT
|
BF_ADJUST
)
;
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
if
(
IsDisabled
(
aFrame
eventState
)
|
|
(
aFrame
-
>
GetContent
(
)
-
>
IsXULElement
(
)
&
&
IsReadOnly
(
aFrame
)
)
)
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_BTNFACE
+
1
)
)
;
else
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_WINDOW
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
Treeview
:
{
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_SUNKEN
BF_RECT
|
BF_ADJUST
)
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_WINDOW
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
Tooltip
:
:
:
FrameRect
(
hdc
&
widgetRect
:
:
GetSysColorBrush
(
COLOR_WINDOWFRAME
)
)
;
InflateRect
(
&
widgetRect
-
1
-
1
)
;
:
:
FillRect
(
hdc
&
widgetRect
:
:
GetSysColorBrush
(
COLOR_INFOBK
)
)
;
break
;
case
StyleAppearance
:
:
Groupbox
:
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_ETCHED
BF_RECT
|
BF_ADJUST
)
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_BTNFACE
+
1
)
)
;
break
;
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
:
:
DrawEdge
(
hdc
&
widgetRect
BDR_SUNKENOUTER
BF_RECT
|
BF_MIDDLE
)
;
InflateRect
(
&
widgetRect
-
1
-
1
)
;
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Resizerpanel
:
{
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_BTNFACE
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
Statusbarpanel
:
{
if
(
aFrame
-
>
GetNextSibling
(
)
)
widgetRect
.
right
-
=
2
;
:
:
DrawEdge
(
hdc
&
widgetRect
BDR_SUNKENOUTER
BF_RECT
|
BF_MIDDLE
)
;
break
;
}
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_RECT
|
BF_MIDDLE
)
;
break
;
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
ScalethumbVertical
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
{
EventStates
eventState
=
GetContentState
(
aFrame
aWidgetType
)
;
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_RECT
|
BF_SOFT
|
BF_MIDDLE
|
BF_ADJUST
)
;
if
(
IsDisabled
(
aFrame
eventState
)
)
{
DrawCheckedRect
(
hdc
widgetRect
COLOR_3DFACE
COLOR_3DHILIGHT
(
HBRUSH
)
COLOR_3DHILIGHT
)
;
}
break
;
}
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
{
DWORD
color3D
colorScrollbar
colorWindow
;
color3D
=
:
:
GetSysColor
(
COLOR_3DFACE
)
;
colorWindow
=
:
:
GetSysColor
(
COLOR_WINDOW
)
;
colorScrollbar
=
:
:
GetSysColor
(
COLOR_SCROLLBAR
)
;
if
(
(
color3D
!
=
colorScrollbar
)
&
&
(
colorWindow
!
=
colorScrollbar
)
)
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_SCROLLBAR
+
1
)
)
;
else
{
DrawCheckedRect
(
hdc
widgetRect
COLOR_3DHILIGHT
COLOR_3DFACE
(
HBRUSH
)
COLOR_SCROLLBAR
+
1
)
;
}
break
;
}
case
StyleAppearance
:
:
Scrollcorner
:
{
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_SCROLLBAR
+
1
)
)
;
}
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
ScaleVertical
:
case
StyleAppearance
:
:
ScaleHorizontal
:
{
const
int32_t
trackWidth
=
4
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScaleHorizontal
|
|
(
aWidgetType
=
=
StyleAppearance
:
:
Range
&
&
IsRangeHorizontal
(
aFrame
)
)
)
{
widgetRect
.
top
+
=
(
widgetRect
.
bottom
-
widgetRect
.
top
-
trackWidth
)
/
2
;
widgetRect
.
bottom
=
widgetRect
.
top
+
trackWidth
;
}
else
{
if
(
!
IsFrameRTL
(
aFrame
)
)
{
widgetRect
.
left
+
=
(
widgetRect
.
right
-
widgetRect
.
left
-
trackWidth
)
/
2
;
widgetRect
.
right
=
widgetRect
.
left
+
trackWidth
;
}
else
{
widgetRect
.
right
-
=
(
widgetRect
.
right
-
widgetRect
.
left
-
trackWidth
)
/
2
;
widgetRect
.
left
=
widgetRect
.
right
-
trackWidth
;
}
}
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_SUNKEN
BF_RECT
|
BF_ADJUST
)
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
GetStockObject
(
GRAY_BRUSH
)
)
;
break
;
}
case
StyleAppearance
:
:
ProgresschunkVertical
:
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_HIGHLIGHT
+
1
)
)
;
break
;
case
StyleAppearance
:
:
Progresschunk
:
{
nsIFrame
*
stateFrame
=
aFrame
-
>
GetParent
(
)
;
EventStates
eventStates
=
GetContentState
(
stateFrame
aWidgetType
)
;
bool
indeterminate
=
IsIndeterminateProgress
(
stateFrame
eventStates
)
;
bool
vertical
=
IsVerticalProgress
(
stateFrame
)
|
|
aWidgetType
=
=
StyleAppearance
:
:
ProgresschunkVertical
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
indeterminate
|
|
!
content
)
{
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_HIGHLIGHT
+
1
)
)
;
break
;
}
RECT
overlayRect
=
CalculateProgressOverlayRect
(
aFrame
&
widgetRect
vertical
indeterminate
true
)
;
:
:
FillRect
(
hdc
&
overlayRect
(
HBRUSH
)
(
COLOR_HIGHLIGHT
+
1
)
)
;
if
(
!
QueueAnimatedContentForRefresh
(
aFrame
-
>
GetContent
(
)
30
)
)
{
NS_WARNING
(
"
unable
to
animate
progress
widget
!
"
)
;
}
break
;
}
case
StyleAppearance
:
:
Tab
:
{
DrawTab
(
hdc
widgetRect
IsBottomTab
(
aFrame
)
?
BF_BOTTOM
:
BF_TOP
IsSelectedTab
(
aFrame
)
!
IsRightToSelectedTab
(
aFrame
)
!
IsLeftToSelectedTab
(
aFrame
)
)
;
break
;
}
case
StyleAppearance
:
:
Tabpanels
:
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_SOFT
|
BF_MIDDLE
|
BF_LEFT
|
BF_RIGHT
|
BF_BOTTOM
)
;
break
;
case
StyleAppearance
:
:
Menubar
:
break
;
case
StyleAppearance
:
:
Menupopup
:
NS_ASSERTION
(
nsUXThemeData
:
:
sFlatMenus
"
Classic
menus
are
styled
entirely
through
CSS
"
)
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_MENU
+
1
)
)
;
:
:
FrameRect
(
hdc
&
widgetRect
:
:
GetSysColorBrush
(
COLOR_BTNSHADOW
)
)
;
break
;
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
if
(
nsUXThemeData
:
:
sFlatMenus
)
{
if
(
(
state
&
(
DFCS_HOT
|
DFCS_PUSHED
)
)
!
=
0
)
{
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_MENUHILIGHT
+
1
)
)
;
:
:
FrameRect
(
hdc
&
widgetRect
:
:
GetSysColorBrush
(
COLOR_HIGHLIGHT
)
)
;
}
}
else
{
if
(
part
=
=
1
)
{
if
(
(
state
&
DFCS_INACTIVE
)
=
=
0
)
{
if
(
(
state
&
DFCS_PUSHED
)
!
=
0
)
{
:
:
DrawEdge
(
hdc
&
widgetRect
BDR_SUNKENOUTER
BF_RECT
)
;
}
else
if
(
(
state
&
DFCS_HOT
)
!
=
0
)
{
:
:
DrawEdge
(
hdc
&
widgetRect
BDR_RAISEDINNER
BF_RECT
)
;
}
}
}
else
{
if
(
(
state
&
(
DFCS_HOT
|
DFCS_PUSHED
)
)
!
=
0
)
{
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_HIGHLIGHT
+
1
)
)
;
}
}
}
break
;
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
if
(
!
(
state
&
DFCS_CHECKED
)
)
break
;
case
StyleAppearance
:
:
Menuarrow
:
{
uint32_t
color
=
COLOR_MENUTEXT
;
if
(
(
state
&
DFCS_INACTIVE
)
)
color
=
COLOR_GRAYTEXT
;
else
if
(
(
state
&
DFCS_HOT
)
)
color
=
COLOR_HIGHLIGHTTEXT
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menucheckbox
)
DrawMenuImage
(
hdc
widgetRect
DFCS_MENUCHECK
color
)
;
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menuradio
)
DrawMenuImage
(
hdc
widgetRect
DFCS_MENUBULLET
color
)
;
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
Menuarrow
)
DrawMenuImage
(
hdc
widgetRect
(
state
&
DFCS_RTL
)
?
DFCS_MENUARROWRIGHT
:
DFCS_MENUARROW
color
)
;
break
;
}
case
StyleAppearance
:
:
Menuseparator
:
{
widgetRect
.
left
+
+
;
widgetRect
.
right
-
-
;
widgetRect
.
top
+
=
4
;
widgetRect
.
bottom
=
widgetRect
.
top
+
1
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_3DSHADOW
+
1
)
)
;
widgetRect
.
top
+
+
;
widgetRect
.
bottom
+
+
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_3DHILIGHT
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozWindowTitlebarMaximized
:
{
RECT
rect
=
widgetRect
;
int32_t
offset
=
GetSystemMetrics
(
SM_CXFRAME
)
;
FillRect
(
hdc
&
rect
(
HBRUSH
)
(
COLOR_3DFACE
+
1
)
)
;
rect
.
top
+
=
offset
;
BOOL
bFlag
=
TRUE
;
SystemParametersInfo
(
SPI_GETGRADIENTCAPTIONS
0
&
bFlag
0
)
;
if
(
!
bFlag
)
{
if
(
state
=
=
mozilla
:
:
widget
:
:
themeconst
:
:
FS_ACTIVE
)
FillRect
(
hdc
&
rect
(
HBRUSH
)
(
COLOR_ACTIVECAPTION
+
1
)
)
;
else
FillRect
(
hdc
&
rect
(
HBRUSH
)
(
COLOR_INACTIVECAPTION
+
1
)
)
;
}
else
{
DWORD
startColor
endColor
;
if
(
state
=
=
mozilla
:
:
widget
:
:
themeconst
:
:
FS_ACTIVE
)
{
startColor
=
GetSysColor
(
COLOR_ACTIVECAPTION
)
;
endColor
=
GetSysColor
(
COLOR_GRADIENTACTIVECAPTION
)
;
}
else
{
startColor
=
GetSysColor
(
COLOR_INACTIVECAPTION
)
;
endColor
=
GetSysColor
(
COLOR_GRADIENTINACTIVECAPTION
)
;
}
TRIVERTEX
vertex
[
2
]
;
vertex
[
0
]
.
x
=
rect
.
left
;
vertex
[
0
]
.
y
=
rect
.
top
;
vertex
[
0
]
.
Red
=
GetRValue
(
startColor
)
<
<
8
;
vertex
[
0
]
.
Green
=
GetGValue
(
startColor
)
<
<
8
;
vertex
[
0
]
.
Blue
=
GetBValue
(
startColor
)
<
<
8
;
vertex
[
0
]
.
Alpha
=
0
;
vertex
[
1
]
.
x
=
rect
.
right
;
vertex
[
1
]
.
y
=
rect
.
bottom
;
vertex
[
1
]
.
Red
=
GetRValue
(
endColor
)
<
<
8
;
vertex
[
1
]
.
Green
=
GetGValue
(
endColor
)
<
<
8
;
vertex
[
1
]
.
Blue
=
GetBValue
(
endColor
)
<
<
8
;
vertex
[
1
]
.
Alpha
=
0
;
GRADIENT_RECT
gRect
;
gRect
.
UpperLeft
=
0
;
gRect
.
LowerRight
=
1
;
GradientFill
(
hdc
vertex
2
&
gRect
1
GRADIENT_FILL_RECT_H
)
;
}
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowTitlebar
)
{
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_TOP
)
;
}
break
;
}
case
StyleAppearance
:
:
MozWindowFrameLeft
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_LEFT
)
;
break
;
case
StyleAppearance
:
:
MozWindowFrameRight
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_RIGHT
)
;
break
;
case
StyleAppearance
:
:
MozWindowFrameBottom
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_BOTTOM
)
;
break
;
case
StyleAppearance
:
:
MozWindowButtonClose
:
case
StyleAppearance
:
:
MozWindowButtonMinimize
:
case
StyleAppearance
:
:
MozWindowButtonMaximize
:
case
StyleAppearance
:
:
MozWindowButtonRestore
:
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMinimize
)
{
OffsetBackgroundRect
(
widgetRect
CAPTIONBUTTON_MINIMIZE
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonMaximize
|
|
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonRestore
)
{
OffsetBackgroundRect
(
widgetRect
CAPTIONBUTTON_RESTORE
)
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
MozWindowButtonClose
)
{
OffsetBackgroundRect
(
widgetRect
CAPTIONBUTTON_CLOSE
)
;
}
int32_t
oldTA
=
SetTextAlign
(
hdc
TA_TOP
|
TA_LEFT
|
TA_NOUPDATECP
)
;
DrawFrameControl
(
hdc
&
widgetRect
part
state
)
;
SetTextAlign
(
hdc
oldTA
)
;
break
;
}
default
:
rv
=
NS_ERROR_FAILURE
;
break
;
}
nativeDrawing
.
EndNativeDrawing
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
nativeDrawing
.
ShouldRenderAgain
(
)
)
goto
RENDER_AGAIN
;
nativeDrawing
.
PaintToContext
(
)
;
return
rv
;
}
uint32_t
nsNativeThemeWin
:
:
GetWidgetNativeDrawingFlags
(
WidgetType
aWidgetType
)
{
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
FocusOutline
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
TextfieldMultiline
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistTextfield
:
return
gfxWindowsNativeDrawing
:
:
CANNOT_DRAW_TO_COLOR_ALPHA
|
gfxWindowsNativeDrawing
:
:
CAN_AXIS_ALIGNED_SCALE
|
gfxWindowsNativeDrawing
:
:
CANNOT_COMPLEX_TRANSFORM
;
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarVertical
:
case
StyleAppearance
:
:
ScrollbarHorizontal
:
case
StyleAppearance
:
:
Scrollcorner
:
case
StyleAppearance
:
:
ScaleHorizontal
:
case
StyleAppearance
:
:
ScaleVertical
:
case
StyleAppearance
:
:
ScalethumbHorizontal
:
case
StyleAppearance
:
:
ScalethumbVertical
:
case
StyleAppearance
:
:
InnerSpinButton
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Resizer
:
case
StyleAppearance
:
:
Progressbar
:
case
StyleAppearance
:
:
ProgressbarVertical
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgresschunkVertical
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Menubar
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Menuitem
:
break
;
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Radiomenuitem
:
case
StyleAppearance
:
:
Menucheckbox
:
case
StyleAppearance
:
:
Menuradio
:
case
StyleAppearance
:
:
Menuarrow
:
return
gfxWindowsNativeDrawing
:
:
CANNOT_DRAW_TO_COLOR_ALPHA
|
gfxWindowsNativeDrawing
:
:
CANNOT_AXIS_ALIGNED_SCALE
|
gfxWindowsNativeDrawing
:
:
CANNOT_COMPLEX_TRANSFORM
;
}
return
gfxWindowsNativeDrawing
:
:
CANNOT_DRAW_TO_COLOR_ALPHA
|
gfxWindowsNativeDrawing
:
:
CANNOT_AXIS_ALIGNED_SCALE
|
gfxWindowsNativeDrawing
:
:
CANNOT_COMPLEX_TRANSFORM
;
}
static
COLORREF
ToColorRef
(
nscolor
aColor
)
{
return
RGB
(
NS_GET_R
(
aColor
)
NS_GET_G
(
aColor
)
NS_GET_B
(
aColor
)
)
;
}
static
nscolor
GetScrollbarArrowColor
(
nscolor
aTrackColor
)
{
float
luminance
=
RelativeLuminanceUtils
:
:
Compute
(
aTrackColor
)
;
if
(
luminance
>
=
0
.
72
)
{
const
float
GRAY96_LUMINANCE
=
0
.
117f
;
return
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
GRAY96_LUMINANCE
)
;
}
if
(
luminance
>
=
0
.
18
)
{
return
NS_RGB
(
0
0
0
)
;
}
return
NS_RGB
(
255
255
255
)
;
}
nsresult
nsNativeThemeWin
:
:
DrawCustomScrollbarPart
(
gfxContext
*
aContext
nsIFrame
*
aFrame
ComputedStyle
*
aStyle
WidgetType
aWidgetType
const
nsRect
&
aRect
const
nsRect
&
aClipRect
)
{
MOZ_ASSERT
(
!
aStyle
-
>
StyleUserInterface
(
)
-
>
mScrollbarFaceColor
.
IsAuto
(
)
|
|
!
aStyle
-
>
StyleUserInterface
(
)
-
>
mScrollbarTrackColor
.
IsAuto
(
)
)
;
gfxRect
tr
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
dr
(
aClipRect
.
X
(
)
aClipRect
.
Y
(
)
aClipRect
.
Width
(
)
aClipRect
.
Height
(
)
)
;
nscolor
trackColor
=
GetScrollbarTrackColor
(
aStyle
&
GetScrollbarTrackColorForAuto
)
;
HBRUSH
dcBrush
=
(
HBRUSH
)
GetStockObject
(
DC_BRUSH
)
;
gfxFloat
p2a
=
gfxFloat
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
tr
.
Scale
(
1
.
0
/
p2a
)
;
dr
.
Scale
(
1
.
0
/
p2a
)
;
RefPtr
<
gfxContext
>
ctx
=
aContext
;
uint32_t
flags
=
GetWidgetNativeDrawingFlags
(
aWidgetType
)
;
gfxWindowsNativeDrawing
nativeDrawing
(
ctx
dr
flags
)
;
do
{
HDC
hdc
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
!
hdc
)
{
return
NS_ERROR_FAILURE
;
}
RECT
widgetRect
;
nativeDrawing
.
TransformToNativeRect
(
tr
widgetRect
)
;
:
:
SetDCBrushColor
(
hdc
ToColorRef
(
trackColor
)
)
;
:
:
SelectObject
(
hdc
dcBrush
)
;
:
:
FillRect
(
hdc
&
widgetRect
dcBrush
)
;
switch
(
aWidgetType
)
{
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
{
gfxRect
tr2
=
tr
;
gfxFloat
dev2css
=
round
(
AppUnitsPerCSSPixel
(
)
/
p2a
)
;
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarthumbVertical
)
{
tr2
.
Deflate
(
dev2css
0
)
;
}
else
{
tr2
.
Deflate
(
0
dev2css
)
;
}
nativeDrawing
.
TransformToNativeRect
(
tr2
widgetRect
)
;
nscolor
faceColor
=
GetScrollbarFaceColor
(
aStyle
&
GetScrollbarFaceColorForAuto
)
;
:
:
SetDCBrushColor
(
hdc
ToColorRef
(
faceColor
)
)
;
:
:
FillRect
(
hdc
&
widgetRect
dcBrush
)
;
break
;
}
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
{
const
LONG
kSize
=
17
;
const
POINT
kPath
[
]
=
{
{
5
9
}
{
8
6
}
{
11
9
}
{
11
11
}
{
8
8
}
{
5
11
}
}
;
const
size_t
kCount
=
ArrayLength
(
kPath
)
;
LONG
width
=
widgetRect
.
right
-
widgetRect
.
left
;
LONG
height
=
widgetRect
.
bottom
-
widgetRect
.
top
;
LONG
size
=
std
:
:
min
(
width
height
)
;
LONG
left
=
(
width
-
size
)
/
2
+
widgetRect
.
left
;
LONG
top
=
(
height
-
size
)
/
2
+
widgetRect
.
top
;
float
unit
=
float
(
size
)
/
kSize
;
POINT
path
[
kCount
]
;
for
(
size_t
i
=
0
;
i
<
kCount
;
i
+
+
)
{
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarbuttonUp
)
{
path
[
i
]
=
kPath
[
i
]
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarbuttonDown
)
{
path
[
i
]
.
x
=
kPath
[
i
]
.
x
;
path
[
i
]
.
y
=
kSize
-
kPath
[
i
]
.
y
;
}
else
if
(
aWidgetType
=
=
StyleAppearance
:
:
ScrollbarbuttonLeft
)
{
path
[
i
]
.
x
=
kPath
[
i
]
.
y
;
path
[
i
]
.
y
=
kPath
[
i
]
.
x
;
}
else
{
path
[
i
]
.
x
=
kSize
-
kPath
[
i
]
.
y
;
path
[
i
]
.
y
=
kPath
[
i
]
.
x
;
}
path
[
i
]
.
x
=
left
+
(
LONG
)
round
(
unit
*
path
[
i
]
.
x
)
;
path
[
i
]
.
y
=
top
+
(
LONG
)
round
(
unit
*
path
[
i
]
.
y
)
;
}
COLORREF
arrowColor
=
ToColorRef
(
GetScrollbarArrowColor
(
trackColor
)
)
;
:
:
SetDCPenColor
(
hdc
arrowColor
)
;
:
:
SetDCBrushColor
(
hdc
arrowColor
)
;
:
:
SelectObject
(
hdc
GetStockObject
(
DC_PEN
)
)
;
:
:
Polygon
(
hdc
path
kCount
)
;
break
;
}
default
:
break
;
}
nativeDrawing
.
EndNativeDrawing
(
)
;
}
while
(
nativeDrawing
.
ShouldRenderAgain
(
)
)
;
nativeDrawing
.
PaintToContext
(
)
;
return
NS_OK
;
}
extern
bool
gDisableNativeTheme
;
nsresult
NS_NewNativeTheme
(
nsISupports
*
aOuter
REFNSIID
aIID
void
*
*
aResult
)
{
if
(
gDisableNativeTheme
)
return
NS_ERROR_NO_INTERFACE
;
if
(
aOuter
)
return
NS_ERROR_NO_AGGREGATION
;
nsNativeThemeWin
*
theme
=
new
nsNativeThemeWin
(
)
;
if
(
!
theme
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
theme
-
>
QueryInterface
(
aIID
aResult
)
;
}
