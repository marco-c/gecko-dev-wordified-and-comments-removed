#
include
"
nsNativeThemeWin
.
h
"
#
include
<
algorithm
>
#
include
<
malloc
.
h
>
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxWindowsNativeDrawing
.
h
"
#
include
"
gfxWindowsPlatform
.
h
"
#
include
"
gfxWindowsSurface
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RelativeLuminanceUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
dom
/
XULButtonElement
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
Theme
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsUXThemeConstants
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
WinUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
widget
;
using
ElementState
=
dom
:
:
ElementState
;
extern
mozilla
:
:
LazyLogModule
gWindowsLog
;
namespace
mozilla
:
:
widget
{
nsNativeThemeWin
:
:
nsNativeThemeWin
(
)
:
Theme
(
ScrollbarStyle
(
)
)
mProgressDeterminateTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mProgressIndeterminateTimeStamp
(
TimeStamp
:
:
Now
(
)
)
mBorderCacheValid
(
)
mMinimumWidgetSizeCacheValid
(
)
mGutterSizeCacheValid
(
false
)
{
}
bool
nsNativeThemeWin
:
:
IsWidgetAlwaysNonNative
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
return
Theme
:
:
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
|
|
aAppearance
=
=
StyleAppearance
:
:
Checkbox
|
|
aAppearance
=
=
StyleAppearance
:
:
Radio
|
|
aAppearance
=
=
StyleAppearance
:
:
MozMenulistArrowButton
;
}
auto
nsNativeThemeWin
:
:
IsWidgetNonNative
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
-
>
NonNative
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
NonNative
:
:
Always
;
}
if
(
Theme
:
:
ThemeSupportsWidget
(
aFrame
-
>
PresContext
(
)
aFrame
aAppearance
)
&
&
LookAndFeel
:
:
ColorSchemeForFrame
(
aFrame
)
=
=
LookAndFeel
:
:
ColorScheme
:
:
Dark
)
{
return
NonNative
:
:
BecauseColorMismatch
;
}
return
NonNative
:
:
No
;
}
static
MARGINS
GetCheckboxMargins
(
HANDLE
theme
HDC
hdc
)
{
MARGINS
checkboxContent
=
{
0
}
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECK
MCB_NORMAL
TMT_CONTENTMARGINS
nullptr
&
checkboxContent
)
;
return
checkboxContent
;
}
static
SIZE
GetCheckboxBGSize
(
HANDLE
theme
HDC
hdc
)
{
SIZE
checkboxSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPCHECK
MC_CHECKMARKNORMAL
nullptr
TS_TRUE
&
checkboxSize
)
;
MARGINS
checkboxMargins
=
GetCheckboxMargins
(
theme
hdc
)
;
int
leftMargin
=
checkboxMargins
.
cxLeftWidth
;
int
rightMargin
=
checkboxMargins
.
cxRightWidth
;
int
topMargin
=
checkboxMargins
.
cyTopHeight
;
int
bottomMargin
=
checkboxMargins
.
cyBottomHeight
;
int
width
=
leftMargin
+
checkboxSize
.
cx
+
rightMargin
;
int
height
=
topMargin
+
checkboxSize
.
cy
+
bottomMargin
;
SIZE
ret
;
ret
.
cx
=
width
;
ret
.
cy
=
height
;
return
ret
;
}
static
SIZE
GetCheckboxBGBounds
(
HANDLE
theme
HDC
hdc
)
{
MARGINS
checkboxBGSizing
=
{
0
}
;
MARGINS
checkboxBGContent
=
{
0
}
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
MCB_NORMAL
TMT_SIZINGMARGINS
nullptr
&
checkboxBGSizing
)
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
MCB_NORMAL
TMT_CONTENTMARGINS
nullptr
&
checkboxBGContent
)
;
#
define
posdx
(
d
)
(
(
d
)
>
0
?
d
:
0
)
int
dx
=
posdx
(
checkboxBGContent
.
cxRightWidth
-
checkboxBGSizing
.
cxRightWidth
)
+
posdx
(
checkboxBGContent
.
cxLeftWidth
-
checkboxBGSizing
.
cxLeftWidth
)
;
int
dy
=
posdx
(
checkboxBGContent
.
cyTopHeight
-
checkboxBGSizing
.
cyTopHeight
)
+
posdx
(
checkboxBGContent
.
cyBottomHeight
-
checkboxBGSizing
.
cyBottomHeight
)
;
#
undef
posdx
SIZE
ret
(
GetCheckboxBGSize
(
theme
hdc
)
)
;
ret
.
cx
+
=
dx
;
ret
.
cy
+
=
dy
;
return
ret
;
}
static
SIZE
GetGutterSize
(
HANDLE
theme
HDC
hdc
)
{
SIZE
gutterSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPGUTTER
0
nullptr
TS_TRUE
&
gutterSize
)
;
SIZE
checkboxBGSize
(
GetCheckboxBGBounds
(
theme
hdc
)
)
;
SIZE
itemSize
;
GetThemePartSize
(
theme
hdc
MENU_POPUPITEM
MPI_NORMAL
nullptr
TS_TRUE
&
itemSize
)
;
double
scaleFactor
=
WinUtils
:
:
SystemScaleFactor
(
)
;
int
iconDevicePixels
=
NSToIntRound
(
16
*
scaleFactor
)
;
SIZE
iconSize
=
{
iconDevicePixels
iconDevicePixels
}
;
MARGINS
margins
=
{
0
}
;
GetThemeMargins
(
theme
hdc
MENU_POPUPCHECKBACKGROUND
MCB_NORMAL
TMT_CONTENTMARGINS
nullptr
&
margins
)
;
iconSize
.
cx
+
=
margins
.
cxLeftWidth
+
margins
.
cxRightWidth
;
iconSize
.
cy
+
=
margins
.
cyTopHeight
+
margins
.
cyBottomHeight
;
int
width
=
std
:
:
max
(
itemSize
.
cx
std
:
:
max
(
iconSize
.
cx
checkboxBGSize
.
cx
)
+
gutterSize
.
cx
)
;
int
height
=
std
:
:
max
(
itemSize
.
cy
std
:
:
max
(
iconSize
.
cy
checkboxBGSize
.
cy
)
)
;
SIZE
ret
;
ret
.
cx
=
width
;
ret
.
cy
=
height
;
return
ret
;
}
SIZE
nsNativeThemeWin
:
:
GetCachedGutterSize
(
HANDLE
theme
)
{
if
(
mGutterSizeCacheValid
)
{
return
mGutterSizeCache
;
}
mGutterSizeCache
=
GetGutterSize
(
theme
nullptr
)
;
mGutterSizeCacheValid
=
true
;
return
mGutterSizeCache
;
}
static
const
double
kProgressDeterminateTimeSpan
=
3
.
0
;
static
const
double
kProgressIndeterminateTimeSpan
=
5
.
0
;
static
const
int32_t
kProgressHorizontalOverlaySize
=
120
;
static
const
int32_t
kProgressVerticalOverlaySize
=
45
;
static
const
int32_t
kProgressVerticalIndeterminateOverlaySize
=
60
;
static
const
int32_t
kProgressClassicOverlaySize
=
40
;
static
int32_t
GetProgressOverlayStyle
(
bool
aIsVertical
)
{
return
aIsVertical
?
PP_MOVEOVERLAYVERT
:
PP_MOVEOVERLAY
;
}
static
int32_t
GetProgressOverlaySize
(
bool
aIsVertical
bool
aIsIndeterminate
)
{
if
(
aIsVertical
)
{
return
aIsIndeterminate
?
kProgressVerticalIndeterminateOverlaySize
:
kProgressVerticalOverlaySize
;
}
return
kProgressHorizontalOverlaySize
;
}
static
bool
IsProgressMeterFilled
(
nsIFrame
*
aFrame
)
{
NS_ENSURE_TRUE
(
aFrame
false
)
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
NS_ENSURE_TRUE
(
parentFrame
false
)
;
return
nsNativeTheme
:
:
GetProgressValue
(
parentFrame
)
=
=
nsNativeTheme
:
:
GetProgressMaxValue
(
parentFrame
)
;
}
RECT
nsNativeThemeWin
:
:
CalculateProgressOverlayRect
(
nsIFrame
*
aFrame
RECT
*
aWidgetRect
bool
aIsVertical
bool
aIsIndeterminate
bool
aIsClassic
)
{
NS_ASSERTION
(
aFrame
"
bad
frame
pointer
"
)
;
NS_ASSERTION
(
aWidgetRect
"
bad
rect
pointer
"
)
;
int32_t
frameSize
=
aIsVertical
?
aWidgetRect
-
>
bottom
-
aWidgetRect
-
>
top
:
aWidgetRect
-
>
right
-
aWidgetRect
-
>
left
;
double
span
=
aIsIndeterminate
?
kProgressIndeterminateTimeSpan
:
kProgressDeterminateTimeSpan
;
TimeDuration
period
;
if
(
!
aIsIndeterminate
)
{
if
(
TimeStamp
:
:
Now
(
)
>
(
mProgressDeterminateTimeStamp
+
TimeDuration
:
:
FromSeconds
(
span
)
)
)
{
mProgressDeterminateTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
period
=
TimeStamp
:
:
Now
(
)
-
mProgressDeterminateTimeStamp
;
}
else
{
if
(
TimeStamp
:
:
Now
(
)
>
(
mProgressIndeterminateTimeStamp
+
TimeDuration
:
:
FromSeconds
(
span
)
)
)
{
mProgressIndeterminateTimeStamp
=
TimeStamp
:
:
Now
(
)
;
}
period
=
TimeStamp
:
:
Now
(
)
-
mProgressIndeterminateTimeStamp
;
}
double
percent
=
period
/
TimeDuration
:
:
FromSeconds
(
span
)
;
if
(
!
aIsVertical
&
&
IsFrameRTL
(
aFrame
)
)
percent
=
1
-
percent
;
RECT
overlayRect
=
*
aWidgetRect
;
int32_t
overlaySize
;
if
(
!
aIsClassic
)
{
overlaySize
=
GetProgressOverlaySize
(
aIsVertical
aIsIndeterminate
)
;
}
else
{
overlaySize
=
kProgressClassicOverlaySize
;
}
int
trackWidth
=
frameSize
>
overlaySize
?
frameSize
:
overlaySize
;
if
(
!
aIsVertical
)
{
int
xPos
=
aWidgetRect
-
>
left
-
trackWidth
;
xPos
+
=
(
int
)
ceil
(
(
(
double
)
(
trackWidth
*
2
)
*
percent
)
)
;
overlayRect
.
left
=
xPos
;
overlayRect
.
right
=
xPos
+
overlaySize
;
}
else
{
int
yPos
=
aWidgetRect
-
>
bottom
+
trackWidth
;
yPos
-
=
(
int
)
ceil
(
(
(
double
)
(
trackWidth
*
2
)
*
percent
)
)
;
overlayRect
.
bottom
=
yPos
;
overlayRect
.
top
=
yPos
-
overlaySize
;
}
return
overlayRect
;
}
void
nsNativeThemeWin
:
:
DrawThemedProgressMeter
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
HANDLE
aTheme
HDC
aHdc
int
aPart
int
aState
RECT
*
aWidgetRect
RECT
*
aClipRect
)
{
if
(
!
aFrame
|
|
!
aTheme
|
|
!
aHdc
)
return
;
NS_ASSERTION
(
aWidgetRect
"
bad
rect
pointer
"
)
;
NS_ASSERTION
(
aClipRect
"
bad
clip
rect
pointer
"
)
;
RECT
adjWidgetRect
adjClipRect
;
adjWidgetRect
=
*
aWidgetRect
;
adjClipRect
=
*
aClipRect
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
{
NS_WARNING
(
"
No
parent
frame
for
progress
rendering
.
Can
'
t
paint
.
"
)
;
return
;
}
ElementState
elementState
=
GetContentState
(
parentFrame
aAppearance
)
;
bool
vertical
=
IsVerticalProgress
(
parentFrame
)
;
bool
indeterminate
=
elementState
.
HasState
(
ElementState
:
:
INDETERMINATE
)
;
bool
animate
=
indeterminate
;
DrawThemeBackground
(
aTheme
aHdc
aPart
aState
&
adjWidgetRect
&
adjClipRect
)
;
if
(
!
IsProgressMeterFilled
(
aFrame
)
)
{
animate
=
true
;
}
if
(
animate
)
{
int32_t
overlayPart
=
GetProgressOverlayStyle
(
vertical
)
;
RECT
overlayRect
=
CalculateProgressOverlayRect
(
aFrame
&
adjWidgetRect
vertical
indeterminate
false
)
;
DrawThemeBackground
(
aTheme
aHdc
overlayPart
aState
&
overlayRect
&
adjClipRect
)
;
if
(
!
QueueAnimatedContentForRefresh
(
aFrame
-
>
GetContent
(
)
60
)
)
{
NS_WARNING
(
"
unable
to
animate
progress
widget
!
"
)
;
}
}
}
LayoutDeviceIntMargin
nsNativeThemeWin
:
:
GetCachedWidgetBorder
(
HTHEME
aTheme
UXThemeClass
aThemeClass
StyleAppearance
aAppearance
int32_t
aPart
int32_t
aState
)
{
int32_t
cacheIndex
=
int32_t
(
aThemeClass
)
*
THEME_PART_DISTINCT_VALUE_COUNT
+
aPart
;
int32_t
cacheBitIndex
=
cacheIndex
/
8
;
uint8_t
cacheBit
=
1u
<
<
(
cacheIndex
%
8
)
;
if
(
mBorderCacheValid
[
cacheBitIndex
]
&
cacheBit
)
{
return
mBorderCache
[
cacheIndex
]
;
}
RECT
outerRect
;
outerRect
.
top
=
outerRect
.
left
=
100
;
outerRect
.
right
=
outerRect
.
bottom
=
200
;
RECT
contentRect
(
outerRect
)
;
HRESULT
res
=
GetThemeBackgroundContentRect
(
aTheme
nullptr
aPart
aState
&
outerRect
&
contentRect
)
;
if
(
FAILED
(
res
)
)
{
return
LayoutDeviceIntMargin
(
)
;
}
LayoutDeviceIntMargin
result
;
result
.
top
=
contentRect
.
top
-
outerRect
.
top
;
result
.
bottom
=
outerRect
.
bottom
-
contentRect
.
bottom
;
result
.
left
=
contentRect
.
left
-
outerRect
.
left
;
result
.
right
=
outerRect
.
right
-
contentRect
.
right
;
mBorderCacheValid
[
cacheBitIndex
]
|
=
cacheBit
;
mBorderCache
[
cacheIndex
]
=
result
;
return
result
;
}
nsresult
nsNativeThemeWin
:
:
GetCachedMinimumWidgetSize
(
nsIFrame
*
aFrame
HANDLE
aTheme
UXThemeClass
aThemeClass
StyleAppearance
aAppearance
int32_t
aPart
int32_t
aState
int32_t
aSizeReq
mozilla
:
:
LayoutDeviceIntSize
*
aResult
)
{
int32_t
cachePart
=
aPart
;
if
(
aAppearance
=
=
StyleAppearance
:
:
Button
&
&
aSizeReq
=
=
TS_MIN
)
{
cachePart
=
BP_Count
;
}
MOZ_ASSERT
(
aPart
<
THEME_PART_DISTINCT_VALUE_COUNT
)
;
int32_t
cacheIndex
=
int32_t
(
aThemeClass
)
*
THEME_PART_DISTINCT_VALUE_COUNT
+
cachePart
;
int32_t
cacheBitIndex
=
cacheIndex
/
8
;
uint8_t
cacheBit
=
1u
<
<
(
cacheIndex
%
8
)
;
if
(
mMinimumWidgetSizeCacheValid
[
cacheBitIndex
]
&
cacheBit
)
{
*
aResult
=
mMinimumWidgetSizeCache
[
cacheIndex
]
;
return
NS_OK
;
}
HDC
hdc
=
:
:
GetDC
(
NULL
)
;
if
(
!
hdc
)
{
return
NS_ERROR_FAILURE
;
}
SIZE
sz
;
GetThemePartSize
(
aTheme
hdc
aPart
aState
nullptr
THEMESIZE
(
aSizeReq
)
&
sz
)
;
aResult
-
>
width
=
sz
.
cx
;
aResult
-
>
height
=
sz
.
cy
;
:
:
ReleaseDC
(
nullptr
hdc
)
;
mMinimumWidgetSizeCacheValid
[
cacheBitIndex
]
|
=
cacheBit
;
mMinimumWidgetSizeCache
[
cacheIndex
]
=
*
aResult
;
return
NS_OK
;
}
mozilla
:
:
Maybe
<
UXThemeClass
>
nsNativeThemeWin
:
:
GetThemeClass
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
return
Some
(
UXThemeClass
:
:
Button
)
;
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
return
Some
(
UXThemeClass
:
:
Edit
)
;
case
StyleAppearance
:
:
Toolbarbutton
:
case
StyleAppearance
:
:
Separator
:
return
Some
(
UXThemeClass
:
:
Toolbar
)
;
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Progresschunk
:
return
Some
(
UXThemeClass
:
:
Progress
)
;
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
return
Some
(
UXThemeClass
:
:
Trackbar
)
;
case
StyleAppearance
:
:
Menulist
:
return
Some
(
UXThemeClass
:
:
Combobox
)
;
case
StyleAppearance
:
:
Listbox
:
return
Some
(
UXThemeClass
:
:
Listview
)
;
default
:
return
Nothing
(
)
;
}
}
HANDLE
nsNativeThemeWin
:
:
GetTheme
(
StyleAppearance
aAppearance
)
{
mozilla
:
:
Maybe
<
UXThemeClass
>
themeClass
=
GetThemeClass
(
aAppearance
)
;
if
(
themeClass
.
isNothing
(
)
)
{
return
nullptr
;
}
return
nsLookAndFeel
:
:
GetTheme
(
themeClass
.
value
(
)
)
;
}
int32_t
nsNativeThemeWin
:
:
StandardGetState
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
bool
wantFocused
)
{
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
elementState
.
HasAllStates
(
ElementState
:
:
HOVER
|
ElementState
:
:
ACTIVE
)
)
{
return
TS_ACTIVE
;
}
if
(
elementState
.
HasState
(
ElementState
:
:
HOVER
)
)
{
return
TS_HOVER
;
}
if
(
wantFocused
)
{
if
(
elementState
.
HasState
(
ElementState
:
:
FOCUSRING
)
)
{
return
TS_FOCUSED
;
}
if
(
aAppearance
=
=
StyleAppearance
:
:
Button
&
&
elementState
.
HasState
(
ElementState
:
:
FOCUS
)
)
{
return
TS_FOCUSED
;
}
}
return
TS_NORMAL
;
}
bool
nsNativeThemeWin
:
:
IsMenuActive
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
-
>
IsXULElement
(
)
&
&
content
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
richlistitem
)
)
return
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
selected
)
;
return
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
menuactive
)
;
}
nsresult
nsNativeThemeWin
:
:
GetThemePartAndState
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
int32_t
&
aPart
int32_t
&
aState
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
aPart
=
BP_BUTTON
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
aState
=
TS_DISABLED
;
return
NS_OK
;
}
if
(
IsOpenButton
(
aFrame
)
|
|
IsCheckedButton
(
aFrame
)
)
{
aState
=
TS_ACTIVE
;
return
NS_OK
;
}
aState
=
StandardGetState
(
aFrame
aAppearance
true
)
;
if
(
aState
=
=
TS_NORMAL
&
&
IsDefaultButton
(
aFrame
)
)
aState
=
TS_FOCUSED
;
return
NS_OK
;
}
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
{
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
aPart
=
TFP_EDITBORDER_NOSCROLL
;
if
(
!
aFrame
)
{
aState
=
TFS_EDITBORDER_NORMAL
;
}
else
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
aState
=
TFS_EDITBORDER_DISABLED
;
}
else
if
(
IsReadOnly
(
aFrame
)
)
{
aState
=
TFS_EDITBORDER_NORMAL
;
}
else
if
(
elementState
.
HasAtLeastOneOfStates
(
ElementState
:
:
ACTIVE
|
ElementState
:
:
FOCUSRING
)
)
{
aState
=
TFS_EDITBORDER_FOCUSED
;
}
else
if
(
elementState
.
HasState
(
ElementState
:
:
HOVER
)
)
{
aState
=
TFS_EDITBORDER_HOVER
;
}
else
{
aState
=
TFS_EDITBORDER_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
ProgressBar
:
{
bool
vertical
=
IsVerticalProgress
(
aFrame
)
;
aPart
=
vertical
?
PP_BARVERT
:
PP_BAR
;
aState
=
PBBS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Progresschunk
:
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
IsVerticalProgress
(
parentFrame
)
)
{
aPart
=
PP_FILLVERT
;
}
else
{
aPart
=
PP_FILL
;
}
aState
=
PBBVS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Toolbarbutton
:
{
aPart
=
BP_BUTTON
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
return
NS_OK
;
}
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
aState
=
TS_DISABLED
;
return
NS_OK
;
}
if
(
IsOpenButton
(
aFrame
)
)
{
aState
=
TS_ACTIVE
;
return
NS_OK
;
}
if
(
elementState
.
HasAllStates
(
ElementState
:
:
HOVER
|
ElementState
:
:
ACTIVE
)
)
aState
=
TS_ACTIVE
;
else
if
(
elementState
.
HasState
(
ElementState
:
:
HOVER
)
)
{
if
(
IsCheckedButton
(
aFrame
)
)
aState
=
TB_HOVER_CHECKED
;
else
aState
=
TS_HOVER
;
}
else
{
if
(
IsCheckedButton
(
aFrame
)
)
aState
=
TB_CHECKED
;
else
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Separator
:
{
aPart
=
TP_SEPARATOR
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Range
:
{
if
(
IsRangeHorizontal
(
aFrame
)
)
{
aPart
=
TKP_TRACK
;
aState
=
TRS_NORMAL
;
}
else
{
aPart
=
TKP_TRACKVERT
;
aState
=
TRVS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
RangeThumb
:
{
if
(
IsRangeHorizontal
(
aFrame
)
)
{
aPart
=
TKP_THUMBBOTTOM
;
}
else
{
aPart
=
IsFrameRTL
(
aFrame
)
?
TKP_THUMBLEFT
:
TKP_THUMBRIGHT
;
}
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
!
aFrame
)
{
aState
=
TS_NORMAL
;
}
else
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
aState
=
TKP_DISABLED
;
}
else
{
if
(
elementState
.
HasState
(
ElementState
:
:
ACTIVE
)
)
aState
=
TS_ACTIVE
;
else
if
(
elementState
.
HasState
(
ElementState
:
:
FOCUSRING
)
)
aState
=
TKP_FOCUSED
;
else
if
(
elementState
.
HasState
(
ElementState
:
:
HOVER
)
)
aState
=
TS_HOVER
;
else
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Listbox
:
{
aPart
=
TREEVIEW_BODY
;
aState
=
TS_NORMAL
;
return
NS_OK
;
}
case
StyleAppearance
:
:
Menulist
:
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
bool
useDropBorder
=
content
&
&
content
-
>
IsHTMLElement
(
)
;
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
useDropBorder
)
aPart
=
CBP_DROPBORDER
;
else
aPart
=
CBP_DROPFRAME
;
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
aState
=
TS_DISABLED
;
}
else
if
(
IsReadOnly
(
aFrame
)
)
{
aState
=
TS_NORMAL
;
}
else
if
(
IsOpenButton
(
aFrame
)
)
{
aState
=
TS_ACTIVE
;
}
else
if
(
useDropBorder
&
&
elementState
.
HasState
(
ElementState
:
:
FOCUSRING
)
)
{
aState
=
TS_ACTIVE
;
}
else
if
(
elementState
.
HasAllStates
(
ElementState
:
:
HOVER
|
ElementState
:
:
ACTIVE
)
)
{
aState
=
TS_ACTIVE
;
}
else
if
(
elementState
.
HasState
(
ElementState
:
:
HOVER
)
)
{
aState
=
TS_HOVER
;
}
else
{
aState
=
TS_NORMAL
;
}
return
NS_OK
;
}
default
:
aPart
=
0
;
aState
=
0
;
return
NS_ERROR_FAILURE
;
}
}
static
inline
double
GetThemeDpiScaleFactor
(
nsPresContext
*
aPresContext
)
{
if
(
WinUtils
:
:
IsPerMonitorDPIAware
(
)
|
|
StaticPrefs
:
:
layout_css_devPixelsPerPx
(
)
>
0
.
0
)
{
nsCOMPtr
<
nsIWidget
>
rootWidget
=
aPresContext
-
>
GetRootWidget
(
)
;
if
(
rootWidget
)
{
double
systemScale
=
WinUtils
:
:
SystemScaleFactor
(
)
;
return
rootWidget
-
>
GetDefaultScale
(
)
.
scale
/
systemScale
;
}
}
return
1
.
0
;
}
static
inline
double
GetThemeDpiScaleFactor
(
nsIFrame
*
aFrame
)
{
return
GetThemeDpiScaleFactor
(
aFrame
-
>
PresContext
(
)
)
;
}
void
nsNativeThemeWin
:
:
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
DrawOverflow
aDrawOverflow
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
DrawWidgetBackground
(
aContext
aFrame
aAppearance
aRect
aDirtyRect
aDrawOverflow
)
;
}
HANDLE
theme
=
GetTheme
(
aAppearance
)
;
if
(
!
theme
)
{
ClassicDrawWidgetBackground
(
aContext
aFrame
aAppearance
aRect
aDirtyRect
)
;
return
;
}
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aAppearance
part
state
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
gfxContextMatrixAutoSaveRestore
save
(
aContext
)
;
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
aContext
-
>
SetMatrix
(
aContext
-
>
CurrentMatrix
(
)
.
PreScale
(
themeScale
themeScale
)
)
;
}
gfxFloat
p2a
=
gfxFloat
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RECT
widgetRect
;
RECT
clipRect
;
gfxRect
tr
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
dr
(
aDirtyRect
.
X
(
)
aDirtyRect
.
Y
(
)
aDirtyRect
.
Width
(
)
aDirtyRect
.
Height
(
)
)
;
tr
.
Scale
(
1
.
0
/
(
p2a
*
themeScale
)
)
;
dr
.
Scale
(
1
.
0
/
(
p2a
*
themeScale
)
)
;
gfxWindowsNativeDrawing
nativeDrawing
(
aContext
dr
GetWidgetNativeDrawingFlags
(
aAppearance
)
)
;
RENDER_AGAIN
:
HDC
hdc
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
!
hdc
)
{
return
;
}
nativeDrawing
.
TransformToNativeRect
(
tr
widgetRect
)
;
nativeDrawing
.
TransformToNativeRect
(
dr
clipRect
)
;
#
if
0
{
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
stderr
"
xform
:
%
f
%
f
%
f
%
f
[
%
f
%
f
]
\
n
"
m
.
_11
m
.
_21
m
.
_12
m
.
_22
m
.
_31
m
.
_32
)
)
;
MOZ_LOG
(
gWindowsLog
LogLevel
:
:
Error
(
stderr
"
tr
:
[
%
d
%
d
%
d
%
d
]
\
ndr
:
[
%
d
%
d
%
d
%
d
]
\
noff
:
[
%
f
%
f
]
\
n
"
tr
.
x
tr
.
y
tr
.
width
tr
.
height
dr
.
x
dr
.
y
dr
.
width
dr
.
height
offset
.
x
offset
.
y
)
)
;
}
#
endif
if
(
aAppearance
=
=
StyleAppearance
:
:
Range
)
{
RECT
contentRect
;
GetThemeBackgroundContentRect
(
theme
hdc
part
state
&
widgetRect
&
contentRect
)
;
SIZE
siz
;
GetThemePartSize
(
theme
hdc
part
state
&
widgetRect
TS_TRUE
&
siz
)
;
if
(
IsRangeHorizontal
(
aFrame
)
)
{
contentRect
.
top
+
=
(
contentRect
.
bottom
-
contentRect
.
top
-
siz
.
cy
)
/
2
;
contentRect
.
bottom
=
contentRect
.
top
+
siz
.
cy
;
}
else
{
if
(
!
IsFrameRTL
(
aFrame
)
)
{
contentRect
.
left
+
=
(
contentRect
.
right
-
contentRect
.
left
-
siz
.
cx
)
/
2
;
contentRect
.
right
=
contentRect
.
left
+
siz
.
cx
;
}
else
{
contentRect
.
right
-
=
(
contentRect
.
right
-
contentRect
.
left
-
siz
.
cx
)
/
2
;
contentRect
.
left
=
contentRect
.
right
-
siz
.
cx
;
}
}
DrawThemeBackground
(
theme
hdc
part
state
&
contentRect
&
clipRect
)
;
}
else
if
(
aAppearance
=
=
StyleAppearance
:
:
NumberInput
|
|
aAppearance
=
=
StyleAppearance
:
:
PasswordInput
|
|
aAppearance
=
=
StyleAppearance
:
:
Textfield
|
|
aAppearance
=
=
StyleAppearance
:
:
Textarea
)
{
DrawThemeBackground
(
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
if
(
state
=
=
TFS_EDITBORDER_DISABLED
)
{
InflateRect
(
&
widgetRect
-
1
-
1
)
;
:
:
FillRect
(
hdc
&
widgetRect
reinterpret_cast
<
HBRUSH
>
(
COLOR_BTNFACE
+
1
)
)
;
}
}
else
if
(
aAppearance
=
=
StyleAppearance
:
:
ProgressBar
)
{
COLORREF
color
;
color
=
GetPixel
(
hdc
widgetRect
.
left
widgetRect
.
top
)
;
DrawThemeBackground
(
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
SetPixel
(
hdc
widgetRect
.
left
widgetRect
.
top
color
)
;
SetPixel
(
hdc
widgetRect
.
right
-
1
widgetRect
.
top
color
)
;
SetPixel
(
hdc
widgetRect
.
right
-
1
widgetRect
.
bottom
-
1
color
)
;
SetPixel
(
hdc
widgetRect
.
left
widgetRect
.
bottom
-
1
color
)
;
}
else
if
(
aAppearance
=
=
StyleAppearance
:
:
Progresschunk
)
{
DrawThemedProgressMeter
(
aFrame
aAppearance
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
}
else
if
(
part
>
=
0
)
{
DrawThemeBackground
(
theme
hdc
part
state
&
widgetRect
&
clipRect
)
;
}
if
(
aAppearance
=
=
StyleAppearance
:
:
Range
)
{
ElementState
contentState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
contentState
.
HasState
(
ElementState
:
:
FOCUSRING
)
)
{
POINT
vpOrg
;
HPEN
hPen
=
nullptr
;
uint8_t
id
=
SaveDC
(
hdc
)
;
:
:
SelectClipRgn
(
hdc
nullptr
)
;
:
:
GetViewportOrgEx
(
hdc
&
vpOrg
)
;
:
:
SetBrushOrgEx
(
hdc
vpOrg
.
x
+
widgetRect
.
left
vpOrg
.
y
+
widgetRect
.
top
nullptr
)
;
:
:
SetTextColor
(
hdc
0
)
;
:
:
DrawFocusRect
(
hdc
&
widgetRect
)
;
:
:
RestoreDC
(
hdc
id
)
;
if
(
hPen
)
{
:
:
DeleteObject
(
hPen
)
;
}
}
}
nativeDrawing
.
EndNativeDrawing
(
)
;
if
(
nativeDrawing
.
ShouldRenderAgain
(
)
)
goto
RENDER_AGAIN
;
nativeDrawing
.
PaintToContext
(
)
;
}
bool
nsNativeThemeWin
:
:
CreateWebRenderCommandsForWidget
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
layers
:
:
StackingContextHelper
&
aSc
layers
:
:
RenderRootStateManager
*
aManager
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
CreateWebRenderCommandsForWidget
(
aBuilder
aResources
aSc
aManager
aFrame
aAppearance
aRect
)
;
}
return
false
;
}
static
void
ScaleForFrameDPI
(
LayoutDeviceIntMargin
*
aMargin
nsIFrame
*
aFrame
)
{
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
aMargin
-
>
top
=
NSToIntRound
(
aMargin
-
>
top
*
themeScale
)
;
aMargin
-
>
left
=
NSToIntRound
(
aMargin
-
>
left
*
themeScale
)
;
aMargin
-
>
bottom
=
NSToIntRound
(
aMargin
-
>
bottom
*
themeScale
)
;
aMargin
-
>
right
=
NSToIntRound
(
aMargin
-
>
right
*
themeScale
)
;
}
}
static
void
ScaleForFrameDPI
(
LayoutDeviceIntSize
*
aSize
nsIFrame
*
aFrame
)
{
double
themeScale
=
GetThemeDpiScaleFactor
(
aFrame
)
;
if
(
themeScale
!
=
1
.
0
)
{
aSize
-
>
width
=
NSToIntRound
(
aSize
-
>
width
*
themeScale
)
;
aSize
-
>
height
=
NSToIntRound
(
aSize
-
>
height
*
themeScale
)
;
}
}
LayoutDeviceIntMargin
nsNativeThemeWin
:
:
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetWidgetBorder
(
aContext
aFrame
aAppearance
)
;
}
LayoutDeviceIntMargin
result
;
mozilla
:
:
Maybe
<
UXThemeClass
>
themeClass
=
GetThemeClass
(
aAppearance
)
;
HTHEME
theme
=
nullptr
;
if
(
themeClass
.
isSome
(
)
)
{
theme
=
nsLookAndFeel
:
:
GetTheme
(
themeClass
.
value
(
)
)
;
}
if
(
!
theme
)
{
result
=
ClassicGetWidgetBorder
(
aContext
aFrame
aAppearance
)
;
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
if
(
!
WidgetIsContainer
(
aAppearance
)
)
{
return
result
;
}
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aAppearance
part
state
)
;
if
(
NS_FAILED
(
rv
)
)
return
result
;
result
=
GetCachedWidgetBorder
(
theme
themeClass
.
value
(
)
aAppearance
part
state
)
;
if
(
aFrame
&
&
(
aAppearance
=
=
StyleAppearance
:
:
NumberInput
|
|
aAppearance
=
=
StyleAppearance
:
:
PasswordInput
|
|
aAppearance
=
=
StyleAppearance
:
:
Textfield
|
|
aAppearance
=
=
StyleAppearance
:
:
Textarea
)
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
)
)
{
result
.
top
.
value
+
+
;
result
.
left
.
value
+
+
;
result
.
bottom
.
value
+
+
;
result
.
right
.
value
+
+
;
}
}
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
bool
nsNativeThemeWin
:
:
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetWidgetPadding
(
aContext
aFrame
aAppearance
aResult
)
;
}
bool
ok
=
true
;
HANDLE
theme
=
GetTheme
(
aAppearance
)
;
if
(
!
theme
)
{
ok
=
ClassicGetWidgetPadding
(
aContext
aFrame
aAppearance
aResult
)
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
if
(
aAppearance
=
=
StyleAppearance
:
:
NumberInput
|
|
aAppearance
=
=
StyleAppearance
:
:
PasswordInput
|
|
aAppearance
=
=
StyleAppearance
:
:
Textfield
|
|
aAppearance
=
=
StyleAppearance
:
:
Textarea
)
{
aResult
-
>
top
=
aResult
-
>
bottom
=
2
;
aResult
-
>
left
=
aResult
-
>
right
=
2
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
else
if
(
IsHTMLContent
(
aFrame
)
&
&
aAppearance
=
=
StyleAppearance
:
:
Menulist
)
{
aResult
-
>
top
=
aResult
-
>
bottom
=
1
;
aResult
-
>
left
=
aResult
-
>
right
=
1
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
int32_t
right
left
top
bottom
;
right
=
left
=
top
=
bottom
=
0
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
if
(
aFrame
-
>
GetContent
(
)
-
>
IsXULElement
(
)
)
{
top
=
2
;
bottom
=
3
;
}
left
=
right
=
5
;
break
;
default
:
return
false
;
}
if
(
IsFrameRTL
(
aFrame
)
)
{
aResult
-
>
right
=
left
;
aResult
-
>
left
=
right
;
}
else
{
aResult
-
>
right
=
right
;
aResult
-
>
left
=
left
;
}
aResult
-
>
top
=
top
;
aResult
-
>
bottom
=
bottom
;
ScaleForFrameDPI
(
aResult
aFrame
)
;
return
ok
;
}
bool
nsNativeThemeWin
:
:
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
GetWidgetOverflow
(
aContext
aFrame
aAppearance
aOverflowRect
)
;
}
return
false
;
}
LayoutDeviceIntSize
nsNativeThemeWin
:
:
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetMinimumWidgetSize
(
aPresContext
aFrame
aAppearance
)
;
}
mozilla
:
:
Maybe
<
UXThemeClass
>
themeClass
=
GetThemeClass
(
aAppearance
)
;
HTHEME
theme
=
NULL
;
if
(
!
themeClass
.
isNothing
(
)
)
{
theme
=
nsLookAndFeel
:
:
GetTheme
(
themeClass
.
value
(
)
)
;
}
if
(
!
theme
)
{
auto
result
=
ClassicGetMinimumWidgetSize
(
aFrame
aAppearance
)
;
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
Listbox
:
return
{
}
;
default
:
break
;
}
THEMESIZE
sizeReq
=
TS_TRUE
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
ProgressBar
:
sizeReq
=
TS_MIN
;
break
;
case
StyleAppearance
:
:
RangeThumb
:
{
LayoutDeviceIntSize
result
(
12
20
)
;
if
(
!
IsRangeHorizontal
(
aFrame
)
)
{
std
:
:
swap
(
result
.
width
result
.
height
)
;
}
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
case
StyleAppearance
:
:
Separator
:
{
LayoutDeviceIntSize
result
(
6
0
)
;
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
case
StyleAppearance
:
:
Button
:
if
(
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
)
)
{
sizeReq
=
TS_MIN
;
}
break
;
default
:
break
;
}
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aAppearance
part
state
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
{
}
;
}
LayoutDeviceIntSize
result
;
rv
=
GetCachedMinimumWidgetSize
(
aFrame
theme
themeClass
.
value
(
)
aAppearance
part
state
sizeReq
&
result
)
;
ScaleForFrameDPI
(
&
result
aFrame
)
;
return
result
;
}
bool
nsNativeThemeWin
:
:
WidgetAttributeChangeRequiresRepaint
(
StyleAppearance
aAppearance
nsAtom
*
aAttribute
)
{
if
(
aAppearance
=
=
StyleAppearance
:
:
Progresschunk
|
|
aAppearance
=
=
StyleAppearance
:
:
ProgressBar
|
|
aAppearance
=
=
StyleAppearance
:
:
Separator
)
{
return
false
;
}
return
Theme
:
:
WidgetAttributeChangeRequiresRepaint
(
aAppearance
aAttribute
)
;
}
void
nsNativeThemeWin
:
:
ThemeChanged
(
)
{
memset
(
mBorderCacheValid
0
sizeof
(
mBorderCacheValid
)
)
;
memset
(
mMinimumWidgetSizeCacheValid
0
sizeof
(
mMinimumWidgetSizeCacheValid
)
)
;
mGutterSizeCacheValid
=
false
;
}
bool
nsNativeThemeWin
:
:
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
ThemeSupportsWidget
(
aPresContext
aFrame
aAppearance
)
;
}
HANDLE
theme
=
GetTheme
(
aAppearance
)
;
if
(
theme
|
|
ClassicThemeSupportsWidget
(
aFrame
aAppearance
)
)
return
!
IsWidgetStyled
(
aPresContext
aFrame
aAppearance
)
;
return
false
;
}
bool
nsNativeThemeWin
:
:
ThemeDrawsFocusForWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
ThemeDrawsFocusForWidget
(
aFrame
aAppearance
)
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
return
true
;
default
:
return
false
;
}
}
nsITheme
:
:
Transparency
nsNativeThemeWin
:
:
GetWidgetTransparency
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
GetWidgetTransparency
(
aFrame
aAppearance
)
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
Range
:
return
eTransparent
;
default
:
break
;
}
HANDLE
theme
=
GetTheme
(
aAppearance
)
;
if
(
!
theme
)
{
return
eUnknownTransparency
;
}
int32_t
part
state
;
nsresult
rv
=
GetThemePartAndState
(
aFrame
aAppearance
part
state
)
;
NS_ENSURE_SUCCESS
(
rv
eUnknownTransparency
)
;
if
(
part
<
=
0
)
{
return
eUnknownTransparency
;
}
if
(
IsThemeBackgroundPartiallyTransparent
(
theme
part
state
)
)
return
eTransparent
;
return
eOpaque
;
}
bool
nsNativeThemeWin
:
:
ClassicThemeSupportsWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Progresschunk
:
return
true
;
default
:
return
false
;
}
}
LayoutDeviceIntMargin
nsNativeThemeWin
:
:
ClassicGetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
LayoutDeviceIntMargin
result
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
2
;
break
;
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
2
;
break
;
case
StyleAppearance
:
:
ProgressBar
:
result
.
top
=
result
.
left
=
result
.
bottom
=
result
.
right
=
1
;
break
;
default
:
result
.
top
=
result
.
bottom
=
result
.
left
=
result
.
right
=
0
;
break
;
}
return
result
;
}
bool
nsNativeThemeWin
:
:
ClassicGetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
ProgressBar
:
(
*
aResult
)
.
top
=
(
*
aResult
)
.
left
=
(
*
aResult
)
.
bottom
=
(
*
aResult
)
.
right
=
1
;
return
true
;
default
:
return
false
;
}
}
LayoutDeviceIntSize
nsNativeThemeWin
:
:
ClassicGetMinimumWidgetSize
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
LayoutDeviceIntSize
result
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
RangeThumb
:
{
if
(
IsRangeHorizontal
(
aFrame
)
)
{
result
.
width
=
12
;
result
.
height
=
20
;
}
else
{
result
.
width
=
20
;
result
.
height
=
12
;
}
break
;
}
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgressBar
:
break
;
default
:
break
;
}
return
result
;
}
nsresult
nsNativeThemeWin
:
:
ClassicGetThemePartAndState
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
int32_t
&
aPart
int32_t
&
aState
bool
&
aFocused
)
{
aFocused
=
false
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
aPart
=
DFC_BUTTON
;
aState
=
DFCS_BUTTONPUSH
;
aFocused
=
false
;
ElementState
contentState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
contentState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
aState
|
=
DFCS_INACTIVE
;
}
else
if
(
IsOpenButton
(
aFrame
)
)
{
aState
|
=
DFCS_PUSHED
;
}
else
if
(
IsCheckedButton
(
aFrame
)
)
{
aState
|
=
DFCS_CHECKED
;
}
else
{
if
(
contentState
.
HasAllStates
(
ElementState
:
:
ACTIVE
|
ElementState
:
:
HOVER
)
)
{
aState
|
=
DFCS_PUSHED
;
if
(
aFrame
-
>
StyleUI
(
)
-
>
UserFocus
(
)
=
=
StyleUserFocus
:
:
Normal
)
{
if
(
!
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
)
)
aState
|
=
DFCS_FLAT
;
aFocused
=
true
;
}
}
if
(
contentState
.
HasState
(
ElementState
:
:
FOCUS
)
|
|
(
aState
=
=
DFCS_BUTTONPUSH
&
&
IsDefaultButton
(
aFrame
)
)
)
{
aFocused
=
true
;
}
}
return
NS_OK
;
}
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
RangeThumb
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgressBar
:
return
NS_OK
;
default
:
return
NS_ERROR_FAILURE
;
}
}
void
nsNativeThemeWin
:
:
DrawCheckedRect
(
HDC
hdc
const
RECT
&
rc
int32_t
fore
int32_t
back
HBRUSH
defaultBack
)
{
static
WORD
patBits
[
8
]
=
{
0xaa
0x55
0xaa
0x55
0xaa
0x55
0xaa
0x55
}
;
HBITMAP
patBmp
=
:
:
CreateBitmap
(
8
8
1
1
patBits
)
;
if
(
patBmp
)
{
HBRUSH
brush
=
(
HBRUSH
)
:
:
CreatePatternBrush
(
patBmp
)
;
if
(
brush
)
{
COLORREF
oldForeColor
=
:
:
SetTextColor
(
hdc
:
:
GetSysColor
(
fore
)
)
;
COLORREF
oldBackColor
=
:
:
SetBkColor
(
hdc
:
:
GetSysColor
(
back
)
)
;
POINT
vpOrg
;
:
:
UnrealizeObject
(
brush
)
;
:
:
GetViewportOrgEx
(
hdc
&
vpOrg
)
;
:
:
SetBrushOrgEx
(
hdc
vpOrg
.
x
+
rc
.
left
vpOrg
.
y
+
rc
.
top
nullptr
)
;
HBRUSH
oldBrush
=
(
HBRUSH
)
:
:
SelectObject
(
hdc
brush
)
;
:
:
FillRect
(
hdc
&
rc
brush
)
;
:
:
SetTextColor
(
hdc
oldForeColor
)
;
:
:
SetBkColor
(
hdc
oldBackColor
)
;
:
:
SelectObject
(
hdc
oldBrush
)
;
:
:
DeleteObject
(
brush
)
;
}
else
:
:
FillRect
(
hdc
&
rc
defaultBack
)
;
:
:
DeleteObject
(
patBmp
)
;
}
}
nsresult
nsNativeThemeWin
:
:
ClassicDrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
)
{
int32_t
part
state
;
bool
focused
;
nsresult
rv
;
MOZ_TRY
(
ClassicGetThemePartAndState
(
aFrame
aAppearance
part
state
focused
)
)
;
gfxFloat
p2a
=
gfxFloat
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RECT
widgetRect
;
gfxRect
tr
(
aRect
.
X
(
)
aRect
.
Y
(
)
aRect
.
Width
(
)
aRect
.
Height
(
)
)
dr
(
aDirtyRect
.
X
(
)
aDirtyRect
.
Y
(
)
aDirtyRect
.
Width
(
)
aDirtyRect
.
Height
(
)
)
;
tr
.
Scale
(
1
.
0
/
p2a
)
;
dr
.
Scale
(
1
.
0
/
p2a
)
;
gfxWindowsNativeDrawing
nativeDrawing
(
aContext
dr
GetWidgetNativeDrawingFlags
(
aAppearance
)
)
;
RENDER_AGAIN
:
HDC
hdc
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
!
hdc
)
return
NS_ERROR_FAILURE
;
nativeDrawing
.
TransformToNativeRect
(
tr
widgetRect
)
;
rv
=
NS_OK
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
if
(
focused
)
{
if
(
HBRUSH
brush
=
:
:
GetSysColorBrush
(
COLOR_3DDKSHADOW
)
)
{
:
:
FrameRect
(
hdc
&
widgetRect
brush
)
;
}
InflateRect
(
&
widgetRect
-
1
-
1
)
;
}
int32_t
oldTA
=
:
:
SetTextAlign
(
hdc
TA_TOP
|
TA_LEFT
|
TA_NOUPDATECP
)
;
:
:
DrawFrameControl
(
hdc
&
widgetRect
part
state
)
;
:
:
SetTextAlign
(
hdc
oldTA
)
;
break
;
}
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Menulist
:
{
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_SUNKEN
BF_RECT
|
BF_ADJUST
)
;
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
|
|
(
aFrame
-
>
GetContent
(
)
-
>
IsXULElement
(
)
&
&
IsReadOnly
(
aFrame
)
)
)
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_BTNFACE
+
1
)
)
;
else
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_WINDOW
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
ProgressBar
:
:
:
DrawEdge
(
hdc
&
widgetRect
BDR_SUNKENOUTER
BF_RECT
|
BF_MIDDLE
)
;
InflateRect
(
&
widgetRect
-
1
-
1
)
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_BTNFACE
+
1
)
)
;
break
;
case
StyleAppearance
:
:
RangeThumb
:
{
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_RAISED
BF_RECT
|
BF_SOFT
|
BF_MIDDLE
|
BF_ADJUST
)
;
if
(
elementState
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
DrawCheckedRect
(
hdc
widgetRect
COLOR_3DFACE
COLOR_3DHILIGHT
(
HBRUSH
)
COLOR_3DHILIGHT
)
;
}
break
;
}
case
StyleAppearance
:
:
Range
:
{
const
int32_t
trackWidth
=
4
;
if
(
IsRangeHorizontal
(
aFrame
)
)
{
widgetRect
.
top
+
=
(
widgetRect
.
bottom
-
widgetRect
.
top
-
trackWidth
)
/
2
;
widgetRect
.
bottom
=
widgetRect
.
top
+
trackWidth
;
}
else
{
if
(
!
IsFrameRTL
(
aFrame
)
)
{
widgetRect
.
left
+
=
(
widgetRect
.
right
-
widgetRect
.
left
-
trackWidth
)
/
2
;
widgetRect
.
right
=
widgetRect
.
left
+
trackWidth
;
}
else
{
widgetRect
.
right
-
=
(
widgetRect
.
right
-
widgetRect
.
left
-
trackWidth
)
/
2
;
widgetRect
.
left
=
widgetRect
.
right
-
trackWidth
;
}
}
:
:
DrawEdge
(
hdc
&
widgetRect
EDGE_SUNKEN
BF_RECT
|
BF_ADJUST
)
;
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
GetStockObject
(
GRAY_BRUSH
)
)
;
break
;
}
case
StyleAppearance
:
:
Progresschunk
:
{
nsIFrame
*
stateFrame
=
aFrame
-
>
GetParent
(
)
;
ElementState
elementState
=
GetContentState
(
stateFrame
aAppearance
)
;
const
bool
indeterminate
=
elementState
.
HasState
(
ElementState
:
:
INDETERMINATE
)
;
bool
vertical
=
IsVerticalProgress
(
stateFrame
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
indeterminate
|
|
!
content
)
{
:
:
FillRect
(
hdc
&
widgetRect
(
HBRUSH
)
(
COLOR_HIGHLIGHT
+
1
)
)
;
break
;
}
RECT
overlayRect
=
CalculateProgressOverlayRect
(
aFrame
&
widgetRect
vertical
indeterminate
true
)
;
:
:
FillRect
(
hdc
&
overlayRect
(
HBRUSH
)
(
COLOR_HIGHLIGHT
+
1
)
)
;
if
(
!
QueueAnimatedContentForRefresh
(
aFrame
-
>
GetContent
(
)
30
)
)
{
NS_WARNING
(
"
unable
to
animate
progress
widget
!
"
)
;
}
break
;
}
default
:
rv
=
NS_ERROR_FAILURE
;
break
;
}
nativeDrawing
.
EndNativeDrawing
(
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
nativeDrawing
.
ShouldRenderAgain
(
)
)
goto
RENDER_AGAIN
;
nativeDrawing
.
PaintToContext
(
)
;
return
rv
;
}
uint32_t
nsNativeThemeWin
:
:
GetWidgetNativeDrawingFlags
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Menulist
:
return
gfxWindowsNativeDrawing
:
:
CANNOT_DRAW_TO_COLOR_ALPHA
|
gfxWindowsNativeDrawing
:
:
CAN_AXIS_ALIGNED_SCALE
|
gfxWindowsNativeDrawing
:
:
CANNOT_COMPLEX_TRANSFORM
;
default
:
return
gfxWindowsNativeDrawing
:
:
CANNOT_DRAW_TO_COLOR_ALPHA
|
gfxWindowsNativeDrawing
:
:
CANNOT_AXIS_ALIGNED_SCALE
|
gfxWindowsNativeDrawing
:
:
CANNOT_COMPLEX_TRANSFORM
;
}
}
}
already_AddRefed
<
Theme
>
do_CreateNativeThemeDoNotUseDirectly
(
)
{
return
do_AddRef
(
new
nsNativeThemeWin
(
)
)
;
}
