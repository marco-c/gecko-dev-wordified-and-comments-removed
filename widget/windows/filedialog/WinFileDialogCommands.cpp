#
include
"
mozilla
/
widget
/
filedialog
/
WinFileDialogCommands
.
h
"
#
include
<
type_traits
>
#
include
<
shobjidl
.
h
>
#
include
<
shtypes
.
h
>
#
include
<
winerror
.
h
>
#
include
"
WinUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
mozilla
/
ipc
/
LaunchError
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
ipc
/
UtilityProcessManager
.
h
"
#
include
"
mozilla
/
mscom
/
ApartmentRegion
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
widget
:
:
filedialog
{
const
char
*
Error
:
:
KindName
(
Error
:
:
Kind
kind
)
{
switch
(
kind
)
{
case
LocalError
:
return
"
LocalError
"
;
case
RemoteError
:
return
"
RemoteError
"
;
case
IPCError
:
return
"
IPCError
"
;
default
:
MOZ_ASSERT
(
false
)
;
return
"
<
bad
value
>
"
;
}
}
constexpr
Error
:
:
Location
:
:
Location
(
mozilla
:
:
ipc
:
:
LaunchError
const
&
err
)
:
text
(
err
.
FunctionName
(
)
)
value
(
0x867
'
5309
)
{
}
Error
Error
:
:
From
(
const
mozilla
:
:
ipc
:
:
LaunchError
&
err
)
{
return
Error
{
.
kind
=
Kind
:
:
LocalError
.
where
=
Location
(
err
)
.
why
=
static_cast
<
uint32_t
>
(
err
.
ErrorCode
(
)
)
}
;
}
struct
Applicator
{
IFileDialog
*
dialog
=
nullptr
;
HRESULT
Visit
(
Command
const
&
c
)
{
switch
(
c
.
type
(
)
)
{
default
:
case
Command
:
:
T__None
:
return
E_INVALIDARG
;
case
Command
:
:
TSetOptions
:
return
Apply
(
c
.
get_SetOptions
(
)
)
;
case
Command
:
:
TSetTitle
:
return
Apply
(
c
.
get_SetTitle
(
)
)
;
case
Command
:
:
TSetOkButtonLabel
:
return
Apply
(
c
.
get_SetOkButtonLabel
(
)
)
;
case
Command
:
:
TSetFolder
:
return
Apply
(
c
.
get_SetFolder
(
)
)
;
case
Command
:
:
TSetFileName
:
return
Apply
(
c
.
get_SetFileName
(
)
)
;
case
Command
:
:
TSetDefaultExtension
:
return
Apply
(
c
.
get_SetDefaultExtension
(
)
)
;
case
Command
:
:
TSetFileTypes
:
return
Apply
(
c
.
get_SetFileTypes
(
)
)
;
case
Command
:
:
TSetFileTypeIndex
:
return
Apply
(
c
.
get_SetFileTypeIndex
(
)
)
;
}
}
HRESULT
Apply
(
SetOptions
const
&
c
)
{
return
dialog
-
>
SetOptions
(
c
.
options
(
)
)
;
}
HRESULT
Apply
(
SetTitle
const
&
c
)
{
return
dialog
-
>
SetTitle
(
c
.
title
(
)
.
get
(
)
)
;
}
HRESULT
Apply
(
SetOkButtonLabel
const
&
c
)
{
return
dialog
-
>
SetOkButtonLabel
(
c
.
label
(
)
.
get
(
)
)
;
}
HRESULT
Apply
(
SetFolder
const
&
c
)
{
RefPtr
<
IShellItem
>
folder
;
if
(
SUCCEEDED
(
SHCreateItemFromParsingName
(
c
.
path
(
)
.
get
(
)
nullptr
IID_IShellItem
getter_AddRefs
(
folder
)
)
)
)
{
return
dialog
-
>
SetFolder
(
folder
)
;
}
return
S_OK
;
}
HRESULT
Apply
(
SetFileName
const
&
c
)
{
return
dialog
-
>
SetFileName
(
c
.
filename
(
)
.
get
(
)
)
;
}
HRESULT
Apply
(
SetDefaultExtension
const
&
c
)
{
return
dialog
-
>
SetDefaultExtension
(
c
.
extension
(
)
.
get
(
)
)
;
}
HRESULT
Apply
(
SetFileTypes
const
&
c
)
{
std
:
:
vector
<
COMDLG_FILTERSPEC
>
vec
;
for
(
auto
const
&
filter
:
c
.
filterList
(
)
)
{
vec
.
push_back
(
{
.
pszName
=
filter
.
name
(
)
.
get
(
)
.
pszSpec
=
filter
.
spec
(
)
.
get
(
)
}
)
;
}
return
dialog
-
>
SetFileTypes
(
vec
.
size
(
)
vec
.
data
(
)
)
;
}
HRESULT
Apply
(
SetFileTypeIndex
const
&
c
)
{
return
dialog
-
>
SetFileTypeIndex
(
c
.
index
(
)
)
;
}
}
;
namespace
{
static
HRESULT
GetShellItemPath
(
IShellItem
*
aItem
nsString
&
aResultString
)
{
NS_ENSURE_TRUE
(
aItem
E_INVALIDARG
)
;
mozilla
:
:
UniquePtr
<
wchar_t
CoTaskMemFreeDeleter
>
str
;
HRESULT
const
hr
=
aItem
-
>
GetDisplayName
(
SIGDN_FILESYSPATH
getter_Transfers
(
str
)
)
;
if
(
SUCCEEDED
(
hr
)
)
{
aResultString
.
Assign
(
str
.
get
(
)
)
;
}
return
hr
;
}
}
#
define
MOZ_ENSURE_HRESULT_OK
(
where
call_
)
\
do
{
\
HRESULT
const
_tmp_hr_
=
(
call_
)
;
\
if
(
FAILED
(
_tmp_hr_
)
)
{
\
return
mozilla
:
:
Err
(
MOZ_FD_LOCAL_ERROR
(
where
_tmp_hr_
)
)
;
\
}
\
}
while
(
0
)
mozilla
:
:
Result
<
RefPtr
<
IFileDialog
>
Error
>
MakeFileDialog
(
FileDialogType
type
)
{
RefPtr
<
IFileDialog
>
dialog
;
CLSID
const
clsid
=
type
=
=
FileDialogType
:
:
Open
?
CLSID_FileOpenDialog
:
CLSID_FileSaveDialog
;
HRESULT
const
hr
=
CoCreateInstance
(
clsid
nullptr
CLSCTX_INPROC_SERVER
IID_IFileDialog
getter_AddRefs
(
dialog
)
)
;
MOZ_ENSURE_HRESULT_OK
(
"
MakeFileDialog
"
hr
)
;
return
std
:
:
move
(
dialog
)
;
}
mozilla
:
:
Result
<
Ok
Error
>
ApplyCommands
(
:
:
IFileDialog
*
dialog
nsTArray
<
Command
>
const
&
commands
)
{
Applicator
applicator
{
.
dialog
=
dialog
}
;
for
(
auto
const
&
cmd
:
commands
)
{
HRESULT
const
hr
=
applicator
.
Visit
(
cmd
)
;
MOZ_ENSURE_HRESULT_OK
(
"
ApplyCommands
"
hr
)
;
}
return
Ok
{
}
;
}
mozilla
:
:
Result
<
Results
Error
>
GetFileResults
(
:
:
IFileDialog
*
dialog
)
{
FILEOPENDIALOGOPTIONS
fos
;
MOZ_ENSURE_HRESULT_OK
(
"
IFileDialog
:
:
GetOptions
"
dialog
-
>
GetOptions
(
&
fos
)
)
;
using
widget
:
:
WinUtils
;
UINT
index
;
MOZ_ENSURE_HRESULT_OK
(
"
IFileDialog
:
:
GetFileTypeIndex
"
dialog
-
>
GetFileTypeIndex
(
&
index
)
)
;
if
(
(
fos
&
FOS_ALLOWMULTISELECT
)
=
=
0
)
{
RefPtr
<
IShellItem
>
item
;
MOZ_ENSURE_HRESULT_OK
(
"
IFileDialog
:
:
GetResult
"
dialog
-
>
GetResult
(
getter_AddRefs
(
item
)
)
)
;
if
(
!
item
)
{
return
Err
(
MOZ_FD_LOCAL_ERROR
(
"
IFileDialog
:
:
GetResult
:
item
"
E_POINTER
)
)
;
}
nsAutoString
path
;
MOZ_ENSURE_HRESULT_OK
(
"
GetFileResults
:
GetShellItemPath
(
1
)
"
GetShellItemPath
(
item
path
)
)
;
return
Results
(
{
path
}
index
)
;
}
RefPtr
<
IFileOpenDialog
>
openDlg
;
dialog
-
>
QueryInterface
(
IID_IFileOpenDialog
getter_AddRefs
(
openDlg
)
)
;
if
(
!
openDlg
)
{
MOZ_ASSERT
(
false
"
a
file
-
save
dialog
was
given
FOS_ALLOWMULTISELECT
?
"
)
;
return
Err
(
MOZ_FD_LOCAL_ERROR
(
"
Save
+
FOS_ALLOWMULTISELECT
"
E_UNEXPECTED
)
)
;
}
RefPtr
<
IShellItemArray
>
items
;
MOZ_ENSURE_HRESULT_OK
(
"
IFileOpenDialog
:
:
GetResults
"
openDlg
-
>
GetResults
(
getter_AddRefs
(
items
)
)
)
;
if
(
!
items
)
{
return
Err
(
MOZ_FD_LOCAL_ERROR
(
"
IFileOpenDialog
:
:
GetResults
:
items
"
E_POINTER
)
)
;
}
nsTArray
<
nsString
>
paths
;
DWORD
count
=
0
;
MOZ_ENSURE_HRESULT_OK
(
"
IShellItemArray
:
:
GetCount
"
items
-
>
GetCount
(
&
count
)
)
;
for
(
DWORD
idx
=
0
;
idx
<
count
;
idx
+
+
)
{
RefPtr
<
IShellItem
>
item
;
MOZ_ENSURE_HRESULT_OK
(
"
IShellItemArray
:
:
GetItemAt
"
items
-
>
GetItemAt
(
idx
getter_AddRefs
(
item
)
)
)
;
nsAutoString
str
;
MOZ_ENSURE_HRESULT_OK
(
"
GetFileResults
:
GetShellItemPath
(
2
)
"
GetShellItemPath
(
item
str
)
)
;
paths
.
EmplaceBack
(
str
)
;
}
return
Results
(
std
:
:
move
(
paths
)
std
:
:
move
(
index
)
)
;
}
mozilla
:
:
Result
<
nsString
Error
>
GetFolderResults
(
:
:
IFileDialog
*
dialog
)
{
RefPtr
<
IShellItem
>
item
;
MOZ_ENSURE_HRESULT_OK
(
"
IFileDialog
:
:
GetResult
"
dialog
-
>
GetResult
(
getter_AddRefs
(
item
)
)
)
;
if
(
!
item
)
{
MOZ_ASSERT
(
false
"
unexpected
lack
of
item
:
was
Show
'
s
return
value
checked
?
"
)
;
return
Err
(
MOZ_FD_LOCAL_ERROR
(
"
IFileDialog
:
:
GetResult
:
item
"
E_POINTER
)
)
;
}
RefPtr
<
IShellLibrary
>
shellLib
;
RefPtr
<
IShellItem
>
folderPath
;
MOZ_ENSURE_HRESULT_OK
(
"
CoCreateInstance
(
CLSID_ShellLibrary
)
"
CoCreateInstance
(
CLSID_ShellLibrary
nullptr
CLSCTX_INPROC_SERVER
IID_IShellLibrary
getter_AddRefs
(
shellLib
)
)
)
;
if
(
shellLib
&
&
SUCCEEDED
(
shellLib
-
>
LoadLibraryFromItem
(
item
STGM_READ
)
)
&
&
SUCCEEDED
(
shellLib
-
>
GetDefaultSaveFolder
(
DSFT_DETECT
IID_IShellItem
getter_AddRefs
(
folderPath
)
)
)
)
{
item
.
swap
(
folderPath
)
;
}
nsAutoString
str
;
MOZ_ENSURE_HRESULT_OK
(
"
GetShellItemPath
"
GetShellItemPath
(
item
str
)
)
;
return
str
;
}
#
undef
MOZ_ENSURE_HRESULT_OK
namespace
detail
{
void
LogProcessingError
(
LogModule
*
aModule
ipc
:
:
IProtocol
*
aCaller
ipc
:
:
HasResultCodes
:
:
Result
aCode
const
char
*
aReason
)
{
LogLevel
const
level
=
[
&
]
(
)
{
switch
(
aCode
)
{
case
ipc
:
:
HasResultCodes
:
:
MsgProcessed
:
return
LogLevel
:
:
Verbose
;
case
ipc
:
:
HasResultCodes
:
:
MsgDropped
:
return
LogLevel
:
:
Verbose
;
default
:
return
LogLevel
:
:
Error
;
}
}
(
)
;
nsCString
reason
(
aReason
)
;
if
(
reason
.
Last
(
)
=
=
'
\
n
'
)
{
reason
.
Truncate
(
reason
.
Length
(
)
-
1
)
;
}
if
(
MOZ_LOG_TEST
(
aModule
level
)
)
{
const
char
*
const
side
=
[
&
]
(
)
{
switch
(
aCaller
-
>
GetSide
(
)
)
{
case
ipc
:
:
ParentSide
:
return
"
parent
"
;
case
ipc
:
:
ChildSide
:
return
"
child
"
;
case
ipc
:
:
UnknownSide
:
return
"
unknown
side
"
;
default
:
return
"
<
illegal
value
>
"
;
}
}
(
)
;
const
char
*
const
errorStr
=
[
&
]
(
)
{
switch
(
aCode
)
{
case
ipc
:
:
HasResultCodes
:
:
MsgProcessed
:
return
"
Processed
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgDropped
:
return
"
Dropped
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgNotKnown
:
return
"
NotKnown
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgNotAllowed
:
return
"
NotAllowed
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgPayloadError
:
return
"
PayloadError
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgProcessingError
:
return
"
ProcessingError
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgRouteError
:
return
"
RouteError
"
;
case
ipc
:
:
HasResultCodes
:
:
MsgValueError
:
return
"
ValueError
"
;
default
:
return
"
<
illegal
error
type
>
"
;
}
}
(
)
;
MOZ_LOG
(
aModule
level
(
"
%
s
[
%
s
]
:
IPC
error
(
%
s
)
:
%
s
"
aCaller
-
>
GetProtocolName
(
)
side
errorStr
reason
.
get
(
)
)
)
;
}
if
(
level
=
=
LogLevel
:
:
Error
)
{
if
(
aCaller
-
>
GetSide
(
)
=
=
ipc
:
:
ParentSide
)
{
ipc
:
:
UtilityProcessManager
:
:
GetSingleton
(
)
-
>
CleanShutdown
(
ipc
:
:
SandboxingKind
:
:
WINDOWS_FILE_DIALOG
)
;
}
else
{
CrashReporter
:
:
AutoRecordAnnotation
(
CrashReporter
:
:
Annotation
:
:
ipc_channel_error
reason
)
;
MOZ_CRASH
(
"
IPC
error
"
)
;
}
}
}
template
<
typename
Res
typename
Action
size_t
N
>
RefPtr
<
Promise
<
Res
>
>
SpawnFileDialogThread
(
const
char
(
&
where
)
[
N
]
Action
action
)
{
{
using
ActionRetT
=
std
:
:
invoke_result_t
<
Action
>
;
using
Info
=
detail
:
:
DestructureResult
<
ActionRetT
>
;
MOZ_ASSERT_SAME_TYPE
(
typename
Info
:
:
ErrorT
Error
"
supplied
Action
must
return
Result
<
T
filedialog
:
:
Err
>
"
)
;
}
RefPtr
<
nsIThread
>
thread
;
{
nsresult
rv
=
NS_NewNamedThread
(
"
File
Dialog
"
getter_AddRefs
(
thread
)
nullptr
{
.
isUiThread
=
true
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Promise
<
Res
>
:
:
CreateAndReject
(
MOZ_FD_LOCAL_ERROR
(
"
NS_NewNamedThread
"
(
HRESULT
)
rv
)
where
)
;
}
}
auto
close_thread_
=
MakeScopeExit
(
[
&
]
(
)
{
auto
const
res
=
thread
-
>
AsyncShutdown
(
)
;
static_assert
(
std
:
:
is_same_v
<
uint32_t
std
:
:
underlying_type_t
<
decltype
(
res
)
>
>
)
;
if
(
NS_FAILED
(
res
)
)
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Warning
(
"
thread
-
>
AsyncShutdown
(
)
failed
:
res
=
0x
%
08
"
PRIX32
static_cast
<
uint32_t
>
(
res
)
)
)
;
}
}
)
;
RefPtr
promise
=
MakeRefPtr
<
typename
Promise
<
Res
>
:
:
Private
>
(
where
)
;
auto
const
dispatch
=
[
&
]
(
auto
closure
)
{
return
thread
-
>
DispatchToQueue
(
NS_NewRunnableFunction
(
where
std
:
:
move
(
closure
)
)
mozilla
:
:
EventQueuePriority
:
:
Normal
)
;
}
;
dispatch
(
[
thread
promise
where
action
=
std
:
:
move
(
action
)
]
(
)
{
mozilla
:
:
mscom
:
:
STARegion
staRegion
;
if
(
!
staRegion
)
{
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Error
(
"
COM
init
failed
on
file
dialog
thread
:
hr
=
%
08lx
"
staRegion
.
GetHResult
(
)
)
)
;
APTTYPE
at
;
APTTYPEQUALIFIER
atq
;
HRESULT
const
hr
=
:
:
CoGetApartmentType
(
&
at
&
atq
)
;
MOZ_LOG
(
sLogFileDialog
LogLevel
:
:
Error
(
"
current
COM
apartment
state
:
hr
=
%
08lX
APTTYPE
=
"
"
%
08X
APTTYPEQUALIFIER
=
%
08X
"
hr
at
atq
)
)
;
if
(
!
XRE_IsParentProcess
(
)
)
{
std
:
:
tuple
volatile
info
{
staRegion
.
GetHResult
(
)
hr
at
atq
}
;
MOZ_CRASH
(
"
Could
not
initialize
COM
STA
in
utility
process
"
)
;
}
}
Result
<
Res
Error
>
val
=
action
(
)
;
if
(
val
.
isErr
(
)
)
{
promise
-
>
Reject
(
val
.
unwrapErr
(
)
where
)
;
}
else
{
promise
-
>
Resolve
(
val
.
unwrap
(
)
where
)
;
}
}
)
;
return
promise
;
}
template
<
typename
F
typename
.
.
.
Args
>
using
inner_result_of
=
typename
detail
:
:
DestructureResult
<
std
:
:
invoke_result_t
<
F
Args
.
.
.
>
>
:
:
OkT
;
template
<
typename
ExtractorF
typename
RetT
=
inner_result_of
<
ExtractorF
IFileDialog
*
>
>
auto
SpawnPickerT
(
HWND
parent
FileDialogType
type
ExtractorF
&
&
extractor
nsTArray
<
Command
>
commands
)
-
>
RefPtr
<
Promise
<
Maybe
<
RetT
>
>
>
{
using
ActionRetT
=
Result
<
Maybe
<
RetT
>
Error
>
;
return
detail
:
:
SpawnFileDialogThread
<
Maybe
<
RetT
>
>
(
__PRETTY_FUNCTION__
[
=
commands
=
std
:
:
move
(
commands
)
]
(
)
-
>
ActionRetT
{
WinUtils
:
:
AutoSystemDpiAware
dpiAwareness
;
RefPtr
<
IFileDialog
>
dialog
;
MOZ_TRY_VAR
(
dialog
MakeFileDialog
(
type
)
)
;
MOZ_TRY
(
ApplyCommands
(
dialog
commands
)
)
;
if
(
HRESULT
const
rv
=
dialog
-
>
Show
(
parent
)
;
FAILED
(
rv
)
)
{
if
(
rv
=
=
HRESULT_FROM_WIN32
(
ERROR_CANCELLED
)
)
{
return
ActionRetT
{
Nothing
(
)
}
;
}
return
mozilla
:
:
Err
(
MOZ_FD_LOCAL_ERROR
(
"
IFileDialog
:
:
Show
"
rv
)
)
;
}
RetT
res
;
MOZ_TRY_VAR
(
res
extractor
(
dialog
.
get
(
)
)
)
;
return
Some
(
res
)
;
}
)
;
}
}
RefPtr
<
Promise
<
Maybe
<
Results
>
>
>
SpawnFilePicker
(
HWND
parent
FileDialogType
type
nsTArray
<
Command
>
commands
)
{
return
detail
:
:
SpawnPickerT
(
parent
type
GetFileResults
std
:
:
move
(
commands
)
)
;
}
RefPtr
<
Promise
<
Maybe
<
nsString
>
>
>
SpawnFolderPicker
(
HWND
parent
nsTArray
<
Command
>
commands
)
{
return
detail
:
:
SpawnPickerT
(
parent
FileDialogType
:
:
Open
GetFolderResults
std
:
:
move
(
commands
)
)
;
}
}
