#
ifndef
widget_windows_WinWindowOcclusionTracker_h
#
define
widget_windows_WinWindowOcclusionTracker_h
#
include
<
windef
.
h
>
#
include
<
unordered_map
>
#
include
<
unordered_set
>
#
include
<
vector
>
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
widget
/
WindowOcclusionState
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsBaseWidget
;
struct
IVirtualDesktopManager
;
class
WinWindowOcclusionTrackerTest
;
class
WinWindowOcclusionTrackerInteractiveTest
;
namespace
base
{
class
Thread
;
}
namespace
mozilla
{
namespace
widget
{
class
OcclusionUpdateRunnable
;
class
SerializedTaskDispatcher
;
class
UpdateOcclusionStateRunnable
;
class
WinWindowOcclusionTracker
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WinWindowOcclusionTracker
)
static
WinWindowOcclusionTracker
*
Get
(
)
;
static
void
Ensure
(
)
;
static
void
ShutDown
(
)
;
static
MessageLoop
*
OcclusionCalculatorLoop
(
)
;
static
bool
IsInWinWindowOcclusionThread
(
)
;
void
Enable
(
nsBaseWidget
*
aWindow
HWND
aHwnd
)
;
void
Disable
(
nsBaseWidget
*
aWindow
HWND
aHwnd
)
;
void
OnWindowVisibilityChanged
(
nsBaseWidget
*
aWindow
bool
aVisible
)
;
SerializedTaskDispatcher
*
GetSerializedTaskDispatcher
(
)
{
return
mSerializedTaskDispatcher
;
}
void
TriggerCalculation
(
)
;
void
DumpOccludingWindows
(
HWND
aHWnd
)
;
private
:
friend
class
:
:
WinWindowOcclusionTrackerTest
;
friend
class
:
:
WinWindowOcclusionTrackerInteractiveTest
;
explicit
WinWindowOcclusionTracker
(
UniquePtr
<
base
:
:
Thread
>
aThread
)
;
virtual
~
WinWindowOcclusionTracker
(
)
;
class
WindowOcclusionCalculator
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
WindowOcclusionCalculator
)
public
:
static
void
CreateInstance
(
)
;
static
void
ClearInstance
(
)
;
static
WindowOcclusionCalculator
*
GetInstance
(
)
{
return
sCalculator
;
}
void
Initialize
(
)
;
void
Shutdown
(
)
;
void
EnableOcclusionTrackingForWindow
(
HWND
hwnd
)
;
void
DisableOcclusionTrackingForWindow
(
HWND
hwnd
)
;
void
HandleVisibilityChanged
(
bool
aVisible
)
;
void
HandleTriggerCalculation
(
)
;
private
:
WindowOcclusionCalculator
(
)
;
~
WindowOcclusionCalculator
(
)
;
void
MaybeRegisterEventHooks
(
)
;
static
void
CALLBACK
EventHookCallback
(
HWINEVENTHOOK
aWinEventHook
DWORD
aEvent
HWND
aHwnd
LONG
aIdObject
LONG
aIdChild
DWORD
aEventThread
DWORD
aMsEventTime
)
;
static
BOOL
CALLBACK
ComputeNativeWindowOcclusionStatusCallback
(
HWND
hwnd
LPARAM
lParam
)
;
static
BOOL
CALLBACK
UpdateVisibleWindowProcessIdsCallback
(
HWND
aHwnd
LPARAM
aLParam
)
;
void
UpdateVisibleWindowProcessIds
(
)
;
void
ComputeNativeWindowOcclusionStatus
(
)
;
void
ScheduleOcclusionCalculationIfNeeded
(
)
;
void
RegisterGlobalEventHook
(
DWORD
aEventMin
DWORD
aEventMax
)
;
void
RegisterEventHookForProcess
(
DWORD
aPid
)
;
void
RegisterEventHooks
(
)
;
void
UnregisterEventHooks
(
)
;
bool
ProcessComputeNativeWindowOcclusionStatusCallback
(
HWND
aHwnd
std
:
:
unordered_set
<
DWORD
>
*
aCurrentPidsWithVisibleWindows
)
;
void
ProcessEventHookCallback
(
HWINEVENTHOOK
aWinEventHook
DWORD
aEvent
HWND
aHwnd
LONG
aIdObject
LONG
aIdChild
)
;
void
ProcessUpdateVisibleWindowProcessIdsCallback
(
HWND
aHwnd
)
;
bool
WindowCanOccludeOtherWindowsOnCurrentVirtualDesktop
(
HWND
aHwnd
LayoutDeviceIntRect
*
aWindowRect
)
;
Maybe
<
bool
>
IsWindowOnCurrentVirtualDesktop
(
HWND
aHwnd
)
;
static
StaticRefPtr
<
WindowOcclusionCalculator
>
sCalculator
;
std
:
:
unordered_map
<
HWND
OcclusionState
>
mRootWindowHwndsOcclusionState
;
std
:
:
vector
<
HWINEVENTHOOK
>
mGlobalEventHooks
;
std
:
:
unordered_map
<
DWORD
HWINEVENTHOOK
>
mProcessEventHooks
;
std
:
:
unordered_set
<
DWORD
>
mPidsForLocationChangeHook
;
RefPtr
<
CancelableRunnable
>
mOcclusionUpdateRunnable
;
LayoutDeviceIntRegion
mUnoccludedDesktopRegion
;
int
mNumRootWindowsWithUnknownOcclusionState
;
bool
mShowingThumbnails
=
false
;
HWND
mMovingWindow
=
0
;
RefPtr
<
IVirtualDesktopManager
>
mVirtualDesktopManager
;
RefPtr
<
SerializedTaskDispatcher
>
mSerializedTaskDispatcher
;
Monitor
&
mMonitor
;
friend
class
OcclusionUpdateRunnable
;
}
;
static
BOOL
CALLBACK
DumpOccludingWindowsCallback
(
HWND
aHWnd
LPARAM
aLParam
)
;
static
bool
IsWindowVisibleAndFullyOpaque
(
HWND
aHwnd
LayoutDeviceIntRect
*
aWindowRect
)
;
void
Destroy
(
)
;
static
void
CallUpdateOcclusionState
(
std
:
:
unordered_map
<
HWND
OcclusionState
>
*
aMap
bool
aShowAllWindows
)
;
void
UpdateOcclusionState
(
std
:
:
unordered_map
<
HWND
OcclusionState
>
*
aMap
bool
aShowAllWindows
)
;
public
:
void
OnSessionChange
(
WPARAM
aStatusCode
Maybe
<
bool
>
aIsCurrentSession
)
;
void
OnDisplayStateChanged
(
bool
aDisplayOn
)
;
private
:
void
MarkNonIconicWindowsOccluded
(
)
;
static
StaticRefPtr
<
WinWindowOcclusionTracker
>
sTracker
;
UniquePtr
<
base
:
:
Thread
>
mThread
;
Monitor
mMonitor
;
bool
mHasAttemptedShutdown
=
false
;
std
:
:
unordered_map
<
HWND
nsWeakPtr
>
mHwndRootWindowMap
;
int
mNumVisibleRootWindows
=
0
;
bool
mScreenLocked
=
false
;
bool
mDisplayOn
=
true
;
RefPtr
<
SerializedTaskDispatcher
>
mSerializedTaskDispatcher
;
friend
class
OcclusionUpdateRunnable
;
friend
class
UpdateOcclusionStateRunnable
;
}
;
}
}
#
endif
