#
ifndef
mozilla_widget_WinUtils_h__
#
define
mozilla_widget_WinUtils_h__
#
include
"
nscore
.
h
"
#
include
<
windows
.
h
>
#
include
<
shobjidl
.
h
>
#
include
<
uxtheme
.
h
>
#
include
<
dwmapi
.
h
>
#
undef
GetMessage
#
undef
CreateEvent
#
undef
GetClassName
#
undef
GetBinaryType
#
undef
RemoveDirectory
#
include
"
nsString
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
ifdef
MOZ_PLACES
#
include
"
nsIFaviconService
.
h
"
#
endif
#
include
"
nsIDownloader
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
define
NS_INLINE_DECL_IUNKNOWN_REFCOUNTING
(
_class
)
\
public
:
\
STDMETHODIMP_
(
ULONG
)
AddRef
(
)
\
{
\
MOZ_ASSERT_TYPE_OK_FOR_REFCOUNTING
(
_class
)
\
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
\
NS_ASSERT_OWNINGTHREAD
(
_class
)
;
\
+
+
mRefCnt
;
\
NS_LOG_ADDREF
(
this
mRefCnt
#
_class
sizeof
(
*
this
)
)
;
\
return
static_cast
<
ULONG
>
(
mRefCnt
.
get
(
)
)
;
\
}
\
STDMETHODIMP_
(
ULONG
)
Release
(
)
\
{
\
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
\
"
Release
called
on
object
that
has
already
been
released
!
"
)
;
\
NS_ASSERT_OWNINGTHREAD
(
_class
)
;
\
-
-
mRefCnt
;
\
NS_LOG_RELEASE
(
this
mRefCnt
#
_class
)
;
\
if
(
mRefCnt
=
=
0
)
{
\
NS_ASSERT_OWNINGTHREAD
(
_class
)
;
\
mRefCnt
=
1
;
/
*
stabilize
*
/
\
delete
this
;
\
return
0
;
\
}
\
return
static_cast
<
ULONG
>
(
mRefCnt
.
get
(
)
)
;
\
}
\
protected
:
\
nsAutoRefCnt
mRefCnt
;
\
NS_DECL_OWNINGTHREAD
\
public
:
class
nsWindow
;
class
nsWindowBase
;
struct
KeyPair
;
#
if
!
defined
(
DPI_AWARENESS_CONTEXT_DECLARED
)
&
&
!
defined
(
DPI_AWARENESS_CONTEXT_UNAWARE
)
DECLARE_HANDLE
(
DPI_AWARENESS_CONTEXT
)
;
typedef
enum
DPI_AWARENESS
{
DPI_AWARENESS_INVALID
=
-
1
DPI_AWARENESS_UNAWARE
=
0
DPI_AWARENESS_SYSTEM_AWARE
=
1
DPI_AWARENESS_PER_MONITOR_AWARE
=
2
}
DPI_AWARENESS
;
#
define
DPI_AWARENESS_CONTEXT_UNAWARE
(
(
DPI_AWARENESS_CONTEXT
)
-
1
)
#
define
DPI_AWARENESS_CONTEXT_SYSTEM_AWARE
(
(
DPI_AWARENESS_CONTEXT
)
-
2
)
#
define
DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE
(
(
DPI_AWARENESS_CONTEXT
)
-
3
)
#
define
DPI_AWARENESS_CONTEXT_DECLARED
#
endif
#
if
WINVER
<
0x0605
WINUSERAPI
DPI_AWARENESS_CONTEXT
WINAPI
GetThreadDpiAwarenessContext
(
)
;
WINUSERAPI
BOOL
WINAPI
AreDpiAwarenessContextsEqual
(
DPI_AWARENESS_CONTEXT
DPI_AWARENESS_CONTEXT
)
;
#
endif
typedef
DPI_AWARENESS_CONTEXT
(
WINAPI
*
SetThreadDpiAwarenessContextProc
)
(
DPI_AWARENESS_CONTEXT
)
;
typedef
BOOL
(
WINAPI
*
EnableNonClientDpiScalingProc
)
(
HWND
)
;
namespace
mozilla
{
#
if
defined
(
ACCESSIBILITY
)
namespace
a11y
{
class
Accessible
;
}
#
endif
namespace
widget
{
typedef
struct
{
const
char
*
mStr
;
UINT
mId
;
}
EventMsgInfo
;
extern
EventMsgInfo
gAllEvents
[
]
;
#
ifndef
QS_RAWINPUT
#
define
QS_RAWINPUT
0x0400
#
endif
#
ifndef
QS_TOUCH
#
define
QS_TOUCH
0x0800
#
define
QS_POINTER
0x1000
#
endif
#
define
MOZ_QS_ALLEVENT
(
QS_KEY
|
QS_MOUSEMOVE
|
QS_MOUSEBUTTON
|
\
QS_POSTMESSAGE
|
QS_TIMER
|
QS_PAINT
|
\
QS_SENDMESSAGE
|
QS_HOTKEY
|
\
QS_ALLPOSTMESSAGE
|
QS_RAWINPUT
|
\
QS_TOUCH
|
QS_POINTER
)
#
define
LogFunction
(
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
__FUNCTION__
)
#
define
LogThread
(
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
%
s
:
IsMainThread
:
%
d
ThreadId
:
%
X
"
__FUNCTION__
NS_IsMainThread
(
)
GetCurrentThreadId
(
)
)
#
define
LogThis
(
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
[
%
X
]
%
s
"
this
__FUNCTION__
)
#
define
LogException
(
e
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
%
s
Exception
:
%
s
"
__FUNCTION__
e
-
>
ToString
(
)
-
>
Data
(
)
)
#
define
LogHRESULT
(
hr
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
%
s
hr
=
%
X
"
__FUNCTION__
hr
)
#
ifdef
MOZ_PLACES
class
myDownloadObserver
final
:
public
nsIDownloadObserver
{
~
myDownloadObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIDOWNLOADOBSERVER
}
;
#
endif
class
WinUtils
{
static
SetThreadDpiAwarenessContextProc
sSetThreadDpiAwarenessContext
;
static
EnableNonClientDpiScalingProc
sEnableNonClientDpiScaling
;
public
:
class
AutoSystemDpiAware
{
public
:
AutoSystemDpiAware
(
)
{
if
(
sSetThreadDpiAwarenessContext
)
{
mPrevContext
=
sSetThreadDpiAwarenessContext
(
DPI_AWARENESS_CONTEXT_SYSTEM_AWARE
)
;
}
}
~
AutoSystemDpiAware
(
)
{
if
(
sSetThreadDpiAwarenessContext
)
{
sSetThreadDpiAwarenessContext
(
mPrevContext
)
;
}
}
private
:
DPI_AWARENESS_CONTEXT
mPrevContext
;
}
;
static
LRESULT
WINAPI
NonClientDpiScalingDefWindowProcW
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
;
static
double
SystemScaleFactor
(
)
;
static
bool
IsPerMonitorDPIAware
(
)
;
static
float
MonitorDPI
(
HMONITOR
aMonitor
)
;
static
float
SystemDPI
(
)
;
static
double
LogToPhysFactor
(
HMONITOR
aMonitor
)
;
static
double
LogToPhysFactor
(
HWND
aWnd
)
{
HWND
ancestor
=
:
:
GetAncestor
(
aWnd
GA_ROOTOWNER
)
;
return
LogToPhysFactor
(
:
:
MonitorFromWindow
(
ancestor
?
ancestor
:
aWnd
MONITOR_DEFAULTTOPRIMARY
)
)
;
}
static
double
LogToPhysFactor
(
HDC
aDC
)
{
return
LogToPhysFactor
(
:
:
WindowFromDC
(
aDC
)
)
;
}
static
int32_t
LogToPhys
(
HMONITOR
aMonitor
double
aValue
)
;
static
HMONITOR
GetPrimaryMonitor
(
)
;
static
HMONITOR
MonitorFromRect
(
const
gfx
:
:
Rect
&
rect
)
;
static
void
Log
(
const
char
*
fmt
.
.
.
)
;
static
void
LogW
(
const
wchar_t
*
fmt
.
.
.
)
;
static
bool
PeekMessage
(
LPMSG
aMsg
HWND
aWnd
UINT
aFirstMessage
UINT
aLastMessage
UINT
aOption
)
;
static
bool
GetMessage
(
LPMSG
aMsg
HWND
aWnd
UINT
aFirstMessage
UINT
aLastMessage
)
;
static
void
WaitForMessage
(
DWORD
aTimeoutMs
=
INFINITE
)
;
static
bool
GetRegistryKey
(
HKEY
aRoot
char16ptr_t
aKeyName
char16ptr_t
aValueName
wchar_t
*
aBuffer
DWORD
aBufferLength
)
;
static
bool
HasRegistryKey
(
HKEY
aRoot
char16ptr_t
aKeyName
)
;
static
HWND
GetTopLevelHWND
(
HWND
aWnd
bool
aStopIfNotChild
=
false
bool
aStopIfNotPopup
=
true
)
;
static
bool
SetNSWindowBasePtr
(
HWND
aWnd
nsWindowBase
*
aWidget
)
;
static
nsWindowBase
*
GetNSWindowBasePtr
(
HWND
aWnd
)
;
static
nsWindow
*
GetNSWindowPtr
(
HWND
aWnd
)
;
static
int32_t
GetMonitorCount
(
)
;
static
bool
IsOurProcessWindow
(
HWND
aWnd
)
;
static
HWND
FindOurProcessWindow
(
HWND
aWnd
)
;
static
HWND
FindOurWindowAtPoint
(
const
POINT
&
aPointInScreen
)
;
static
MSG
InitMSG
(
UINT
aMessage
WPARAM
wParam
LPARAM
lParam
HWND
aWnd
)
;
static
WORD
GetScanCode
(
LPARAM
aLParam
)
{
return
(
aLParam
>
>
16
)
&
0xFF
;
}
static
bool
IsExtendedScanCode
(
LPARAM
aLParam
)
{
return
(
aLParam
&
0x1000000
)
!
=
0
;
}
static
UINT
GetInternalMessage
(
UINT
aNativeMessage
)
;
static
UINT
GetNativeMessage
(
UINT
aInternalMessage
)
;
static
uint16_t
GetMouseInputSource
(
)
;
static
uint16_t
GetMousePointerID
(
)
;
static
bool
GetIsMouseFromTouch
(
EventMessage
aEventType
)
;
static
bool
GetShellItemPath
(
IShellItem
*
aItem
nsString
&
aResultString
)
;
static
LayoutDeviceIntRegion
ConvertHRGNToRegion
(
HRGN
aRgn
)
;
static
LayoutDeviceIntRect
ToIntRect
(
const
RECT
&
aRect
)
;
static
void
InvalidatePluginAsWorkaround
(
nsIWidget
*
aWidget
const
LayoutDeviceIntRect
&
aRect
)
;
static
bool
IsIMEEnabled
(
const
InputContext
&
aInputContext
)
;
static
bool
IsIMEEnabled
(
IMEState
:
:
Enabled
aIMEState
)
;
static
void
SetupKeyModifiersSequence
(
nsTArray
<
KeyPair
>
*
aArray
uint32_t
aModifiers
UINT
aMessage
)
;
static
uint32_t
IsTouchDeviceSupportPresent
(
)
;
static
uint32_t
GetMaxTouchPoints
(
)
;
static
bool
ResolveJunctionPointsAndSymLinks
(
std
:
:
wstring
&
aPath
)
;
static
bool
ResolveJunctionPointsAndSymLinks
(
nsIFile
*
aPath
)
;
static
bool
RunningFromANetworkDrive
(
)
;
static
void
Initialize
(
)
;
static
bool
SanitizePath
(
const
wchar_t
*
aInputPath
nsAString
&
aOutput
)
;
static
bool
GetAppInitDLLs
(
nsAString
&
aOutput
)
;
#
ifdef
ACCESSIBILITY
static
a11y
:
:
Accessible
*
GetRootAccessibleForHWND
(
HWND
aHwnd
)
;
#
endif
private
:
static
void
GetWhitelistedPaths
(
nsTArray
<
mozilla
:
:
Pair
<
nsString
nsDependentString
>
>
&
aOutput
)
;
}
;
#
ifdef
MOZ_PLACES
class
AsyncFaviconDataReady
final
:
public
nsIFaviconDataCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIFAVICONDATACALLBACK
AsyncFaviconDataReady
(
nsIURI
*
aNewURI
nsCOMPtr
<
nsIThread
>
&
aIOThread
const
bool
aURLShortcut
)
;
nsresult
OnFaviconDataNotAvailable
(
void
)
;
private
:
~
AsyncFaviconDataReady
(
)
{
}
nsCOMPtr
<
nsIURI
>
mNewURI
;
nsCOMPtr
<
nsIThread
>
mIOThread
;
const
bool
mURLShortcut
;
}
;
#
endif
class
AsyncEncodeAndWriteIcon
:
public
nsIRunnable
{
public
:
const
bool
mURLShortcut
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
AsyncEncodeAndWriteIcon
(
const
nsAString
&
aIconPath
UniquePtr
<
uint8_t
[
]
>
aData
uint32_t
aStride
uint32_t
aWidth
uint32_t
aHeight
const
bool
aURLShortcut
)
;
private
:
virtual
~
AsyncEncodeAndWriteIcon
(
)
;
nsAutoString
mIconPath
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
uint32_t
mStride
;
uint32_t
mWidth
;
uint32_t
mHeight
;
}
;
class
AsyncDeleteAllFaviconsFromDisk
:
public
nsIRunnable
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
explicit
AsyncDeleteAllFaviconsFromDisk
(
bool
aIgnoreRecent
=
false
)
;
private
:
virtual
~
AsyncDeleteAllFaviconsFromDisk
(
)
;
int32_t
mIcoNoDeleteSeconds
;
bool
mIgnoreRecent
;
nsCOMPtr
<
nsIFile
>
mJumpListCacheDir
;
}
;
class
FaviconHelper
{
public
:
static
const
char
kJumpListCacheDir
[
]
;
static
const
char
kShortcutCacheDir
[
]
;
static
nsresult
ObtainCachedIconFile
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsString
&
aICOFilePath
nsCOMPtr
<
nsIThread
>
&
aIOThread
bool
aURLShortcut
)
;
static
nsresult
HashURI
(
nsCOMPtr
<
nsICryptoHash
>
&
aCryptoHash
nsIURI
*
aUri
nsACString
&
aUriHash
)
;
static
nsresult
GetOutputIconPath
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsCOMPtr
<
nsIFile
>
&
aICOFile
bool
aURLShortcut
)
;
static
nsresult
CacheIconFileFromFaviconURIAsync
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsCOMPtr
<
nsIFile
>
aICOFile
nsCOMPtr
<
nsIThread
>
&
aIOThread
bool
aURLShortcut
)
;
static
int32_t
GetICOCacheSecondsTimeout
(
)
;
}
;
}
}
#
endif
