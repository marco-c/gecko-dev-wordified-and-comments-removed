#
ifndef
mozilla_widget_WinUtils_h__
#
define
mozilla_widget_WinUtils_h__
#
include
"
nscore
.
h
"
#
include
<
windows
.
h
>
#
include
<
shobjidl
.
h
>
#
include
<
uxtheme
.
h
>
#
include
<
dwmapi
.
h
>
#
include
<
unordered_map
>
#
include
<
utility
>
#
undef
GetMessage
#
undef
CreateEvent
#
undef
GetClassName
#
undef
GetBinaryType
#
undef
RemoveDirectory
#
include
"
nsString
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
ifdef
MOZ_PLACES
#
include
"
nsIFaviconService
.
h
"
#
endif
#
include
"
nsIDownloader
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsWindowsHelpers
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
LazyIdleThread
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WindowsDpiAwareness
.
h
"
#
include
"
mozilla
/
WindowsProcessMitigations
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
define
NS_INLINE_DECL_IUNKNOWN_REFCOUNTING
(
_class
)
\
public
:
\
STDMETHODIMP_
(
ULONG
)
AddRef
(
)
{
\
MOZ_ASSERT_TYPE_OK_FOR_REFCOUNTING
(
_class
)
\
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
=
0
"
illegal
refcnt
"
)
;
\
NS_ASSERT_OWNINGTHREAD
(
_class
)
;
\
+
+
mRefCnt
;
\
NS_LOG_ADDREF
(
this
mRefCnt
#
_class
sizeof
(
*
this
)
)
;
\
return
static_cast
<
ULONG
>
(
mRefCnt
.
get
(
)
)
;
\
}
\
STDMETHODIMP_
(
ULONG
)
Release
(
)
{
\
MOZ_ASSERT
(
int32_t
(
mRefCnt
)
>
0
\
"
Release
called
on
object
that
has
already
been
released
!
"
)
;
\
NS_ASSERT_OWNINGTHREAD
(
_class
)
;
\
-
-
mRefCnt
;
\
NS_LOG_RELEASE
(
this
mRefCnt
#
_class
)
;
\
if
(
mRefCnt
=
=
0
)
{
\
NS_ASSERT_OWNINGTHREAD
(
_class
)
;
\
mRefCnt
=
1
;
/
*
stabilize
*
/
\
delete
this
;
\
return
0
;
\
}
\
return
static_cast
<
ULONG
>
(
mRefCnt
.
get
(
)
)
;
\
}
\
\
protected
:
\
nsAutoRefCnt
mRefCnt
;
\
NS_DECL_OWNINGTHREAD
\
public
:
class
nsWindow
;
struct
KeyPair
;
namespace
mozilla
{
enum
class
PointerCapabilities
:
uint8_t
;
#
if
defined
(
ACCESSIBILITY
)
namespace
a11y
{
class
LocalAccessible
;
}
#
endif
template
<
typename
F
>
void
EnumerateThreadWindows
(
F
&
&
f
)
{
class
Impl
{
public
:
F
f
;
explicit
Impl
(
F
&
&
f
)
:
f
(
std
:
:
forward
<
F
>
(
f
)
)
{
}
void
invoke
(
)
{
WNDENUMPROC
proc
=
&
Impl
:
:
Callback
;
:
:
EnumThreadWindows
(
:
:
GetCurrentThreadId
(
)
proc
reinterpret_cast
<
LPARAM
>
(
&
f
)
)
;
}
private
:
static
BOOL
CALLBACK
Callback
(
HWND
hwnd
LPARAM
lp
)
{
(
*
reinterpret_cast
<
F
*
>
(
lp
)
)
(
hwnd
)
;
return
TRUE
;
}
}
;
Impl
(
std
:
:
forward
<
F
>
(
f
)
)
.
invoke
(
)
;
}
namespace
widget
{
#
ifndef
QS_RAWINPUT
#
define
QS_RAWINPUT
0x0400
#
endif
#
ifndef
QS_TOUCH
#
define
QS_TOUCH
0x0800
#
define
QS_POINTER
0x1000
#
endif
#
define
MOZ_QS_ALLEVENT
\
(
QS_KEY
|
QS_MOUSEMOVE
|
QS_MOUSEBUTTON
|
QS_POSTMESSAGE
|
QS_TIMER
|
\
QS_PAINT
|
QS_SENDMESSAGE
|
QS_HOTKEY
|
QS_ALLPOSTMESSAGE
|
QS_RAWINPUT
|
\
QS_TOUCH
|
QS_POINTER
)
#
define
LogFunction
(
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
__FUNCTION__
)
#
define
LogThread
(
)
\
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
%
s
:
IsMainThread
:
%
d
ThreadId
:
%
X
"
\
__FUNCTION__
NS_IsMainThread
(
)
\
GetCurrentThreadId
(
)
)
#
define
LogThis
(
)
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
[
%
X
]
%
s
"
this
__FUNCTION__
)
#
define
LogException
(
e
)
\
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
%
s
Exception
:
%
s
"
__FUNCTION__
\
e
-
>
ToString
(
)
-
>
Data
(
)
)
#
define
LogHRESULT
(
hr
)
\
mozilla
:
:
widget
:
:
WinUtils
:
:
Log
(
"
%
s
hr
=
%
X
"
__FUNCTION__
hr
)
#
ifdef
MOZ_PLACES
class
myDownloadObserver
final
:
public
nsIDownloadObserver
{
~
myDownloadObserver
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIDOWNLOADOBSERVER
}
;
#
endif
class
WinUtils
{
static
SetThreadDpiAwarenessContextProc
sSetThreadDpiAwarenessContext
;
static
EnableNonClientDpiScalingProc
sEnableNonClientDpiScaling
;
static
GetSystemMetricsForDpiProc
sGetSystemMetricsForDpi
;
static
bool
sHasPackageIdentity
;
public
:
class
AutoSystemDpiAware
{
public
:
AutoSystemDpiAware
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsWin32kLockedDown
(
)
)
;
if
(
sSetThreadDpiAwarenessContext
)
{
mPrevContext
=
sSetThreadDpiAwarenessContext
(
DPI_AWARENESS_CONTEXT_SYSTEM_AWARE
)
;
}
}
~
AutoSystemDpiAware
(
)
{
if
(
sSetThreadDpiAwarenessContext
)
{
sSetThreadDpiAwarenessContext
(
mPrevContext
)
;
}
}
private
:
DPI_AWARENESS_CONTEXT
mPrevContext
;
}
;
static
LRESULT
WINAPI
NonClientDpiScalingDefWindowProcW
(
HWND
hWnd
UINT
msg
WPARAM
wParam
LPARAM
lParam
)
;
static
double
SystemScaleFactor
(
)
;
static
bool
IsPerMonitorDPIAware
(
)
;
static
float
MonitorDPI
(
HMONITOR
aMonitor
)
;
static
float
SystemDPI
(
)
;
static
double
LogToPhysFactor
(
HMONITOR
aMonitor
)
;
static
double
LogToPhysFactor
(
HWND
aWnd
)
;
static
double
LogToPhysFactor
(
HDC
aDC
)
{
return
LogToPhysFactor
(
:
:
WindowFromDC
(
aDC
)
)
;
}
static
int32_t
LogToPhys
(
HMONITOR
aMonitor
double
aValue
)
;
static
HMONITOR
GetPrimaryMonitor
(
)
;
static
HMONITOR
MonitorFromRect
(
const
gfx
:
:
Rect
&
rect
)
;
static
bool
HasSystemMetricsForDpi
(
)
;
static
int
GetSystemMetricsForDpi
(
int
nIndex
UINT
dpi
)
;
static
const
char
*
WinEventToEventName
(
UINT
msg
)
;
static
gfx
:
:
MarginDouble
GetUnwriteableMarginsForDeviceInInches
(
HDC
aHdc
)
;
static
bool
HasPackageIdentity
(
)
{
return
sHasPackageIdentity
;
}
static
nsString
GetPackageFamilyName
(
)
;
static
void
Log
(
const
char
*
fmt
.
.
.
)
;
static
void
LogW
(
const
wchar_t
*
fmt
.
.
.
)
;
static
bool
PeekMessage
(
LPMSG
aMsg
HWND
aWnd
UINT
aFirstMessage
UINT
aLastMessage
UINT
aOption
)
;
static
bool
GetMessage
(
LPMSG
aMsg
HWND
aWnd
UINT
aFirstMessage
UINT
aLastMessage
)
;
static
void
WaitForMessage
(
DWORD
aTimeoutMs
=
INFINITE
)
;
static
HWND
GetTopLevelHWND
(
HWND
aWnd
bool
aStopIfNotChild
=
false
bool
aStopIfNotPopup
=
true
)
;
static
void
SetNSWindowPtr
(
HWND
aWnd
nsWindow
*
aWindow
)
;
static
nsWindow
*
GetNSWindowPtr
(
HWND
aWnd
)
;
static
bool
IsOurProcessWindow
(
HWND
aWnd
)
;
static
HWND
FindOurProcessWindow
(
HWND
aWnd
)
;
static
HWND
FindOurWindowAtPoint
(
const
POINT
&
aPointInScreen
)
;
static
MSG
InitMSG
(
UINT
aMessage
WPARAM
wParam
LPARAM
lParam
HWND
aWnd
)
;
static
WORD
GetScanCode
(
LPARAM
aLParam
)
{
return
(
aLParam
>
>
16
)
&
0xFF
;
}
static
bool
IsExtendedScanCode
(
LPARAM
aLParam
)
{
return
(
aLParam
&
0x1000000
)
!
=
0
;
}
static
UINT
GetInternalMessage
(
UINT
aNativeMessage
)
;
static
UINT
GetNativeMessage
(
UINT
aInternalMessage
)
;
static
uint16_t
GetMouseInputSource
(
)
;
static
uint16_t
GetMousePointerID
(
)
;
static
bool
GetIsMouseFromTouch
(
EventMessage
aEventType
)
;
static
LayoutDeviceIntRegion
ConvertHRGNToRegion
(
HRGN
aRgn
)
;
static
nsAutoRegion
RegionToHRGN
(
const
LayoutDeviceIntRegion
&
)
;
static
LayoutDeviceIntRect
ToIntRect
(
const
RECT
&
aRect
)
;
static
RECT
ToWinRect
(
const
LayoutDeviceIntRect
&
aRect
)
;
static
bool
IsIMEEnabled
(
const
InputContext
&
aInputContext
)
;
static
bool
IsIMEEnabled
(
IMEEnabled
aIMEState
)
;
static
void
SetupKeyModifiersSequence
(
nsTArray
<
KeyPair
>
*
aArray
uint32_t
aModifiers
UINT
aMessage
)
;
static
uint32_t
IsTouchDeviceSupportPresent
(
)
;
static
uint32_t
GetMaxTouchPoints
(
)
;
static
POWER_PLATFORM_ROLE
GetPowerPlatformRole
(
)
;
static
PointerCapabilities
GetPrimaryPointerCapabilities
(
)
;
static
PointerCapabilities
GetAllPointerCapabilities
(
)
;
static
void
GetPointerExplanation
(
nsAString
*
aExplanation
)
;
static
bool
ResolveJunctionPointsAndSymLinks
(
std
:
:
wstring
&
aPath
)
;
static
bool
ResolveJunctionPointsAndSymLinks
(
nsIFile
*
aPath
)
;
static
bool
RunningFromANetworkDrive
(
)
;
static
void
Initialize
(
)
;
static
nsresult
WriteBitmap
(
nsIFile
*
aFile
mozilla
:
:
gfx
:
:
SourceSurface
*
surface
)
;
static
nsresult
WriteBitmap
(
nsIFile
*
aFile
imgIContainer
*
aImage
)
;
static
bool
CanonicalizePath
(
nsAString
&
aPath
)
;
static
bool
MakeLongPath
(
nsAString
&
aPath
)
;
static
bool
UnexpandEnvVars
(
nsAString
&
aPath
)
;
static
bool
GetAppInitDLLs
(
nsAString
&
aOutput
)
;
enum
class
PathTransformFlags
:
uint32_t
{
Canonicalize
=
1
Lengthen
=
2
UnexpandEnvVars
=
4
RequireFilePath
=
8
Default
=
7
}
;
static
bool
PreparePathForTelemetry
(
nsAString
&
aPath
PathTransformFlags
aFlags
=
PathTransformFlags
:
:
Default
)
;
static
const
size_t
kMaxWhitelistedItems
=
3
;
using
WhitelistVec
=
Vector
<
std
:
:
pair
<
nsString
nsDependentString
>
kMaxWhitelistedItems
>
;
static
const
WhitelistVec
&
GetWhitelistedPaths
(
)
;
static
bool
GetClassName
(
HWND
aHwnd
nsAString
&
aName
)
;
static
void
EnableWindowOcclusion
(
const
bool
aEnable
)
;
static
bool
GetTimezoneName
(
wchar_t
*
aBuffer
)
;
#
ifdef
DEBUG
static
nsresult
SetHiDPIMode
(
bool
aHiDPI
)
;
static
nsresult
RestoreHiDPIMode
(
)
;
#
endif
static
bool
GetAutoRotationState
(
AR_STATE
*
aRotationState
)
;
static
void
GetClipboardFormatAsString
(
UINT
aFormat
nsAString
&
aOutput
)
;
private
:
static
WhitelistVec
BuildWhitelist
(
)
;
public
:
#
ifdef
ACCESSIBILITY
static
a11y
:
:
LocalAccessible
*
GetRootAccessibleForHWND
(
HWND
aHwnd
)
;
#
endif
}
;
typedef
MozPromise
<
nsString
nsresult
true
>
ObtainCachedIconFileAsyncPromise
;
#
ifdef
MOZ_PLACES
class
AsyncFaviconDataReady
final
:
public
nsIFaviconDataCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIFAVICONDATACALLBACK
AsyncFaviconDataReady
(
nsIURI
*
aNewURI
RefPtr
<
nsISerialEventTarget
>
aIOThread
const
bool
aURLShortcut
already_AddRefed
<
nsIRunnable
>
aRunnable
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
aPromiseHolder
=
nullptr
)
;
nsresult
OnFaviconDataNotAvailable
(
void
)
;
private
:
~
AsyncFaviconDataReady
(
)
{
if
(
mPromiseHolder
)
{
mPromiseHolder
-
>
RejectIfExists
(
NS_ERROR_FAILURE
__func__
)
;
}
}
nsCOMPtr
<
nsIURI
>
mNewURI
;
RefPtr
<
nsISerialEventTarget
>
mIOThread
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
mPromiseHolder
;
const
bool
mURLShortcut
;
}
;
#
endif
class
AsyncEncodeAndWriteIcon
:
public
nsIRunnable
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
AsyncEncodeAndWriteIcon
(
const
nsAString
&
aIconPath
UniquePtr
<
uint8_t
[
]
>
aData
uint32_t
aStride
uint32_t
aWidth
uint32_t
aHeight
already_AddRefed
<
nsIRunnable
>
aRunnable
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
aPromiseHolder
=
nullptr
)
;
private
:
virtual
~
AsyncEncodeAndWriteIcon
(
)
;
nsAutoString
mIconPath
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
mPromiseHolder
;
uint32_t
mStride
;
uint32_t
mWidth
;
uint32_t
mHeight
;
}
;
class
AsyncDeleteAllFaviconsFromDisk
:
public
nsIRunnable
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
explicit
AsyncDeleteAllFaviconsFromDisk
(
bool
aIgnoreRecent
=
false
)
;
private
:
virtual
~
AsyncDeleteAllFaviconsFromDisk
(
)
;
int32_t
mIcoNoDeleteSeconds
;
bool
mIgnoreRecent
;
nsCOMPtr
<
nsIFile
>
mJumpListCacheDir
;
}
;
class
FaviconHelper
{
public
:
enum
class
IconCacheDir
:
uint8_t
{
JumpListCacheDir
=
1
ShortcutCacheDir
=
2
}
;
static
const
char
kJumpListCacheDir
[
]
;
static
const
char
kShortcutCacheDir
[
]
;
static
nsresult
ObtainCachedIconFile
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsString
&
aICOFilePath
RefPtr
<
LazyIdleThread
>
&
aIOThread
bool
aURLShortcut
already_AddRefed
<
nsIRunnable
>
aRunnable
=
nullptr
)
;
static
RefPtr
<
ObtainCachedIconFileAsyncPromise
>
ObtainCachedIconFileAsync
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
RefPtr
<
LazyIdleThread
>
&
aIOThread
IconCacheDir
aCacheDir
)
;
static
nsresult
GetOutputIconPath
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsCOMPtr
<
nsIFile
>
&
aICOFile
bool
aURLShortcut
)
;
static
nsresult
CacheIconFileFromFaviconURIAsync
(
nsCOMPtr
<
nsIURI
>
aFaviconPageURI
nsCOMPtr
<
nsIFile
>
aICOFile
RefPtr
<
nsISerialEventTarget
>
aIOThread
bool
aURLShortcut
already_AddRefed
<
nsIRunnable
>
aRunnable
UniquePtr
<
MozPromiseHolder
<
ObtainCachedIconFileAsyncPromise
>
>
aPromiseHolder
)
;
static
int32_t
GetICOCacheSecondsTimeout
(
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
WinUtils
:
:
PathTransformFlags
)
;
class
ScopedRtlShimWindow
{
public
:
explicit
ScopedRtlShimWindow
(
nsIWidget
*
aParent
)
;
~
ScopedRtlShimWindow
(
)
;
ScopedRtlShimWindow
(
const
ScopedRtlShimWindow
&
)
=
delete
;
ScopedRtlShimWindow
(
ScopedRtlShimWindow
&
&
that
)
noexcept
:
mWnd
(
that
.
mWnd
)
{
that
.
mWnd
=
nullptr
;
}
;
HWND
get
(
)
const
{
return
mWnd
;
}
private
:
HWND
mWnd
;
}
;
}
}
#
endif
