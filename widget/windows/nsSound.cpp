#
include
"
nscore
.
h
"
#
include
"
plstr
.
h
"
#
include
<
stdio
.
h
>
#
include
"
nsString
.
h
"
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
"
HeadlessSound
.
h
"
#
include
"
nsSound
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prtime
.
h
"
#
include
"
nsNativeCharsetUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
gfxPlatform
.
h
"
using
mozilla
:
:
LogLevel
;
static
mozilla
:
:
LazyLogModule
gWin32SoundLog
(
"
nsSound
"
)
;
class
nsSoundPlayer
:
public
mozilla
:
:
Runnable
{
public
:
explicit
nsSoundPlayer
(
const
nsAString
&
aSoundName
)
:
mozilla
:
:
Runnable
(
"
nsSoundPlayer
"
)
mSoundName
(
aSoundName
)
mSoundData
(
nullptr
)
{
}
nsSoundPlayer
(
const
uint8_t
*
aData
size_t
aSize
)
:
mozilla
:
:
Runnable
(
"
nsSoundPlayer
"
)
mSoundName
(
EmptyString
(
)
)
{
MOZ_ASSERT
(
aSize
>
0
"
Size
should
not
be
zero
"
)
;
MOZ_ASSERT
(
aData
"
Data
shoud
not
be
null
"
)
;
mSoundData
=
new
uint8_t
[
aSize
]
;
memcpy
(
mSoundData
aData
aSize
)
;
}
NS_DECL_NSIRUNNABLE
protected
:
~
nsSoundPlayer
(
)
;
nsString
mSoundName
;
uint8_t
*
mSoundData
;
}
;
NS_IMETHODIMP
nsSoundPlayer
:
:
Run
(
)
{
MOZ_ASSERT
(
!
mSoundName
.
IsEmpty
(
)
|
|
mSoundData
"
Sound
name
or
sound
data
should
be
specified
"
)
;
DWORD
flags
=
SND_NODEFAULT
|
SND_ASYNC
;
if
(
mSoundData
)
{
flags
|
=
SND_MEMORY
;
:
:
PlaySoundW
(
reinterpret_cast
<
LPCWSTR
>
(
mSoundData
)
nullptr
flags
)
;
}
else
{
flags
|
=
SND_ALIAS
;
:
:
PlaySoundW
(
mSoundName
.
get
(
)
nullptr
flags
)
;
}
return
NS_OK
;
}
nsSoundPlayer
:
:
~
nsSoundPlayer
(
)
{
delete
[
]
mSoundData
;
}
mozilla
:
:
StaticRefPtr
<
nsISound
>
nsSound
:
:
sInstance
;
already_AddRefed
<
nsISound
>
nsSound
:
:
GetInstance
(
)
{
if
(
!
sInstance
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
sInstance
=
new
mozilla
:
:
widget
:
:
HeadlessSound
(
)
;
}
else
{
RefPtr
<
nsSound
>
sound
=
new
nsSound
(
)
;
nsresult
rv
=
sound
-
>
CreatePlayerThread
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
sInstance
=
sound
.
forget
(
)
;
}
ClearOnShutdown
(
&
sInstance
)
;
}
RefPtr
<
nsISound
>
service
=
sInstance
;
return
service
.
forget
(
)
;
}
#
ifndef
SND_PURGE
#
define
SND_PURGE
0
#
endif
NS_IMPL_ISUPPORTS
(
nsSound
nsISound
nsIStreamLoaderObserver
)
nsSound
:
:
nsSound
(
)
:
mInited
(
false
)
{
}
nsSound
:
:
~
nsSound
(
)
{
}
void
nsSound
:
:
PurgeLastSound
(
)
{
if
(
mPlayerThread
)
{
mPlayerThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
nsSound
:
:
PurgeLastSound
"
[
]
(
)
{
:
:
PlaySound
(
nullptr
nullptr
SND_PURGE
)
;
}
)
NS_DISPATCH_NORMAL
)
;
}
}
NS_IMETHODIMP
nsSound
:
:
Beep
(
)
{
:
:
MessageBeep
(
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSound
:
:
OnStreamComplete
(
nsIStreamLoader
*
aLoader
nsISupports
*
context
nsresult
aStatus
uint32_t
dataLen
const
uint8_t
*
data
)
{
MOZ_ASSERT
(
mPlayerThread
"
player
thread
should
not
be
null
"
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
#
ifdef
DEBUG
if
(
aLoader
)
{
nsCOMPtr
<
nsIRequest
>
request
;
nsCOMPtr
<
nsIChannel
>
channel
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
request
)
)
;
if
(
request
)
channel
=
do_QueryInterface
(
request
)
;
if
(
channel
)
{
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
nsAutoCString
uriSpec
;
uri
-
>
GetSpec
(
uriSpec
)
;
MOZ_LOG
(
gWin32SoundLog
LogLevel
:
:
Info
(
"
Failed
to
load
%
s
\
n
"
uriSpec
.
get
(
)
)
)
;
}
}
}
#
endif
return
aStatus
;
}
PurgeLastSound
(
)
;
if
(
data
&
&
dataLen
>
0
)
{
RefPtr
<
nsSoundPlayer
>
player
=
new
nsSoundPlayer
(
data
dataLen
)
;
MOZ_ASSERT
(
player
"
Could
not
create
player
"
)
;
nsresult
rv
=
mPlayerThread
-
>
Dispatch
(
player
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSound
:
:
Play
(
nsIURL
*
aURL
)
{
nsresult
rv
;
#
ifdef
DEBUG_SOUND
char
*
url
;
aURL
-
>
GetSpec
(
&
url
)
;
MOZ_LOG
(
gWin32SoundLog
LogLevel
:
:
Info
(
"
%
s
\
n
"
url
)
)
;
#
endif
nsCOMPtr
<
nsIStreamLoader
>
loader
;
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
loader
)
aURL
this
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
return
rv
;
}
nsresult
nsSound
:
:
CreatePlayerThread
(
)
{
if
(
mPlayerThread
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
NS_NewNamedThread
(
"
PlayEventSound
"
getter_AddRefs
(
mPlayerThread
)
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
observerService
)
{
return
NS_ERROR_FAILURE
;
}
observerService
-
>
AddObserver
(
this
"
xpcom
-
shutdown
-
threads
"
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSound
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
"
xpcom
-
shutdown
-
threads
"
)
)
{
PurgeLastSound
(
)
;
if
(
mPlayerThread
)
{
mPlayerThread
-
>
Shutdown
(
)
;
mPlayerThread
=
nullptr
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsSound
:
:
Init
(
)
{
if
(
mInited
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mPlayerThread
"
player
thread
should
not
be
null
"
)
;
mPlayerThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
nsSound
:
:
Init
"
[
]
(
)
{
:
:
PlaySound
(
nullptr
nullptr
SND_PURGE
)
;
}
)
NS_DISPATCH_NORMAL
)
;
mInited
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSound
:
:
PlayEventSound
(
uint32_t
aEventId
)
{
MOZ_ASSERT
(
mPlayerThread
"
player
thread
should
not
be
null
"
)
;
PurgeLastSound
(
)
;
const
wchar_t
*
sound
=
nullptr
;
switch
(
aEventId
)
{
case
EVENT_NEW_MAIL_RECEIVED
:
sound
=
L
"
MailBeep
"
;
break
;
case
EVENT_ALERT_DIALOG_OPEN
:
sound
=
L
"
SystemExclamation
"
;
break
;
case
EVENT_CONFIRM_DIALOG_OPEN
:
sound
=
L
"
SystemQuestion
"
;
break
;
case
EVENT_MENU_EXECUTE
:
sound
=
L
"
MenuCommand
"
;
break
;
case
EVENT_MENU_POPUP
:
sound
=
L
"
MenuPopup
"
;
break
;
case
EVENT_EDITOR_MAX_LEN
:
sound
=
L
"
.
Default
"
;
break
;
default
:
return
NS_OK
;
}
NS_ASSERTION
(
sound
"
sound
is
null
"
)
;
nsCOMPtr
<
nsIRunnable
>
player
=
new
nsSoundPlayer
(
nsDependentString
(
sound
)
)
;
MOZ_ASSERT
(
player
"
Could
not
create
player
"
)
;
nsresult
rv
=
mPlayerThread
-
>
Dispatch
(
player
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
