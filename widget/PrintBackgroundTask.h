#
ifndef
mozilla_PrintBackgroundTask_h_
#
define
mozilla_PrintBackgroundTask_h_
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
<
utility
>
#
include
<
tuple
>
namespace
mozilla
{
template
<
typename
T
typename
Result
>
void
ResolveOrReject
(
dom
:
:
Promise
&
aPromise
T
&
Result
&
aResult
)
{
aPromise
.
MaybeResolve
(
std
:
:
forward
<
Result
>
(
aResult
)
)
;
}
template
<
typename
T
typename
Result
typename
.
.
.
Args
>
using
PrintBackgroundTask
=
Result
(
T
:
:
*
)
(
Args
.
.
.
)
const
;
template
<
typename
T
typename
Result
typename
.
.
.
Args
>
void
SpawnPrintBackgroundTask
(
T
&
aReceiver
dom
:
:
Promise
&
aPromise
const
nsCString
&
aTelemetryKey
PrintBackgroundTask
<
T
Result
Args
.
.
.
>
aBackgroundTask
Args
.
.
.
aArgs
)
{
auto
promiseHolder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
dom
:
:
Promise
>
>
(
"
nsPrinterBase
:
:
SpawnBackgroundTaskPromise
"
&
aPromise
)
;
auto
holder
=
MakeRefPtr
<
nsMainThreadPtrHolder
<
T
>
>
(
"
nsPrinterBase
:
:
SpawnBackgroundTaskPrinter
"
&
aReceiver
false
)
;
NS_DispatchBackgroundTask
(
NS_NewRunnableFunction
(
"
SpawnPrintBackgroundTask
"
[
holder
=
std
:
:
move
(
holder
)
promiseHolder
=
std
:
:
move
(
promiseHolder
)
aTelemetryKey
startRoundTrip
=
TimeStamp
:
:
Now
(
)
backgroundTask
=
aBackgroundTask
aArgs
=
std
:
:
make_tuple
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
]
{
auto
start
=
TimeStamp
:
:
Now
(
)
;
Result
result
=
std
:
:
apply
(
[
&
]
(
auto
&
&
.
.
.
args
)
{
return
(
holder
-
>
get
(
)
-
>
*
backgroundTask
)
(
args
.
.
.
)
;
}
std
:
:
move
(
aArgs
)
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PRINT_BACKGROUND_TASK_TIME_MS
aTelemetryKey
start
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
SpawnPrintBackgroundTaskResolution
"
[
holder
=
std
:
:
move
(
holder
)
promiseHolder
=
std
:
:
move
(
promiseHolder
)
telemetryKey
=
std
:
:
move
(
aTelemetryKey
)
startRoundTrip
result
=
std
:
:
move
(
result
)
]
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PRINT_BACKGROUND_TASK_ROUND_TRIP_TIME_MS
telemetryKey
startRoundTrip
)
;
ResolveOrReject
(
*
promiseHolder
-
>
get
(
)
*
holder
-
>
get
(
)
result
)
;
}
)
)
;
}
)
NS_DISPATCH_EVENT_MAY_BLOCK
)
;
}
template
<
typename
T
typename
Result
typename
.
.
.
Args
>
nsresult
PrintBackgroundTaskPromise
(
T
&
aReceiver
JSContext
*
aCx
dom
:
:
Promise
*
*
aResultPromise
const
nsCString
&
aTelemetryKey
PrintBackgroundTask
<
T
Result
Args
.
.
.
>
aTask
Args
.
.
.
aArgs
)
{
ErrorResult
rv
;
RefPtr
<
dom
:
:
Promise
>
promise
=
dom
:
:
Promise
:
:
Create
(
xpc
:
:
CurrentNativeGlobal
(
aCx
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
SpawnPrintBackgroundTask
(
aReceiver
*
promise
aTelemetryKey
aTask
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
promise
.
forget
(
aResultPromise
)
;
return
NS_OK
;
}
template
<
typename
T
typename
Result
typename
.
.
.
Args
>
nsresult
AsyncPromiseAttributeGetter
(
T
&
aReceiver
RefPtr
<
dom
:
:
Promise
>
&
aPromiseSlot
JSContext
*
aCx
dom
:
:
Promise
*
*
aResultPromise
const
nsCString
&
aTelemetryKey
PrintBackgroundTask
<
T
Result
Args
.
.
.
>
aTask
Args
.
.
.
aArgs
)
{
if
(
RefPtr
<
dom
:
:
Promise
>
existing
=
aPromiseSlot
)
{
existing
.
forget
(
aResultPromise
)
;
return
NS_OK
;
}
nsresult
rv
=
PrintBackgroundTaskPromise
(
aReceiver
aCx
aResultPromise
aTelemetryKey
aTask
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aPromiseSlot
=
*
aResultPromise
;
return
NS_OK
;
}
}
#
endif
