#
ifndef
mozilla_EventForwards_h__
#
define
mozilla_EventForwards_h__
#
include
<
stdint
.
h
>
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
ifdef
DEBUG
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
endif
class
nsCommandParams
;
enum
nsEventStatus
{
nsEventStatus_eIgnore
nsEventStatus_eConsumeNoDefault
nsEventStatus_eConsumeDoDefault
nsEventStatus_eSentinel
}
;
namespace
mozilla
{
enum
class
CanBubble
{
eYes
eNo
}
;
enum
class
Cancelable
{
eYes
eNo
}
;
enum
class
ChromeOnlyDispatch
{
eYes
eNo
}
;
enum
class
Trusted
{
eYes
eNo
}
;
enum
class
Composed
{
eYes
eNo
eDefault
}
;
enum
class
SystemGroupOnly
{
eYes
eNo
}
;
typedef
uint16_t
EventMessageType
;
enum
EventMessage
:
EventMessageType
{
#
define
NS_EVENT_MESSAGE
(
aMessage
)
aMessage
#
define
NS_EVENT_MESSAGE_FIRST_LAST
(
aMessage
aFirst
aLast
)
\
aMessage
#
#
First
=
aFirst
aMessage
#
#
Last
=
aLast
#
include
"
mozilla
/
EventMessageList
.
h
"
#
undef
NS_EVENT_MESSAGE
#
undef
NS_EVENT_MESSAGE_FIRST_LAST
eEventMessage_MaxValue
}
;
const
char
*
ToChar
(
EventMessage
aEventMessage
)
;
[
[
nodiscard
]
]
bool
IsPointerEventMessage
(
EventMessage
aMessage
)
;
[
[
nodiscard
]
]
bool
IsPointerEventMessageOriginallyMouseEventMessage
(
EventMessage
aMessage
)
;
[
[
nodiscard
]
]
bool
IsForbiddenDispatchingToNonElementContent
(
EventMessage
aMessage
)
;
typedef
uint8_t
EventClassIDType
;
enum
EventClassID
:
EventClassIDType
{
#
define
NS_ROOT_EVENT_CLASS
(
aPrefix
aName
)
eBasic
#
#
aName
#
#
Class
#
define
NS_EVENT_CLASS
(
aPrefix
aName
)
e
#
#
aName
#
#
Class
#
include
"
mozilla
/
EventClassList
.
h
"
#
undef
NS_EVENT_CLASS
#
undef
NS_ROOT_EVENT_CLASS
}
;
const
char
*
ToChar
(
EventClassID
aEventClassID
)
;
typedef
uint16_t
Modifiers
;
#
define
NS_DEFINE_KEYNAME
(
aCPPName
aDOMKeyName
)
KEY_NAME_INDEX_
#
#
aCPPName
typedef
uint16_t
KeyNameIndexType
;
enum
KeyNameIndex
:
KeyNameIndexType
{
#
include
"
mozilla
/
KeyNameList
.
h
"
KEY_NAME_INDEX_USE_STRING
}
;
#
undef
NS_DEFINE_KEYNAME
const
nsCString
ToString
(
KeyNameIndex
aKeyNameIndex
)
;
#
define
NS_DEFINE_PHYSICAL_KEY_CODE_NAME
(
aCPPName
aDOMCodeName
)
\
CODE_NAME_INDEX_
#
#
aCPPName
typedef
uint8_t
CodeNameIndexType
;
enum
CodeNameIndex
:
CodeNameIndexType
{
#
include
"
mozilla
/
PhysicalKeyCodeNameList
.
h
"
CODE_NAME_INDEX_USE_STRING
}
;
#
undef
NS_DEFINE_PHYSICAL_KEY_CODE_NAME
const
nsCString
ToString
(
CodeNameIndex
aCodeNameIndex
)
;
#
define
NS_DEFINE_INPUTTYPE
(
aCPPName
aDOMName
)
e
#
#
aCPPName
using
EditorInputTypeType
=
uint8_t
;
enum
class
EditorInputType
:
EditorInputTypeType
{
#
include
"
mozilla
/
InputTypeList
.
h
"
eUnknown
}
;
#
undef
NS_DEFINE_INPUTTYPE
#
define
NS_DEFINE_INPUTTYPE
(
aCPPName
aDOMName
)
\
case
EditorInputType
:
:
e
#
#
aCPPName
:
\
return
aStream
<
<
(
"
EditorInputType
:
:
e
"
#
aCPPName
)
;
inline
const
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
EditorInputType
&
aInputType
)
{
switch
(
aInputType
)
{
#
include
"
mozilla
/
InputTypeList
.
h
"
case
EditorInputType
:
:
eUnknown
:
return
aStream
<
<
"
EditorInputType
:
:
eUnknown
"
;
}
return
aStream
<
<
"
<
Invalid
EditorInputType
>
"
;
}
#
undef
NS_DEFINE_INPUTTYPE
inline
bool
ExposesClipboardDataOrDataTransfer
(
EditorInputType
aInputType
)
{
switch
(
aInputType
)
{
case
EditorInputType
:
:
eInsertFromPaste
:
case
EditorInputType
:
:
eInsertFromPasteAsQuotation
:
return
true
;
default
:
return
false
;
}
}
inline
bool
IsDataAvailableOnTextEditor
(
EditorInputType
aInputType
)
{
switch
(
aInputType
)
{
case
EditorInputType
:
:
eInsertText
:
case
EditorInputType
:
:
eInsertCompositionText
:
case
EditorInputType
:
:
eInsertFromComposition
:
case
EditorInputType
:
:
eInsertFromPaste
:
case
EditorInputType
:
:
eInsertFromPasteAsQuotation
:
case
EditorInputType
:
:
eInsertTranspose
:
case
EditorInputType
:
:
eInsertFromDrop
:
case
EditorInputType
:
:
eInsertReplacementText
:
case
EditorInputType
:
:
eInsertFromYank
:
case
EditorInputType
:
:
eFormatSetBlockTextDirection
:
case
EditorInputType
:
:
eFormatSetInlineTextDirection
:
return
true
;
default
:
return
false
;
}
}
inline
bool
IsDataAvailableOnHTMLEditor
(
EditorInputType
aInputType
)
{
switch
(
aInputType
)
{
case
EditorInputType
:
:
eInsertText
:
case
EditorInputType
:
:
eInsertCompositionText
:
case
EditorInputType
:
:
eInsertFromComposition
:
case
EditorInputType
:
:
eFormatSetBlockTextDirection
:
case
EditorInputType
:
:
eFormatSetInlineTextDirection
:
case
EditorInputType
:
:
eInsertLink
:
case
EditorInputType
:
:
eFormatBackColor
:
case
EditorInputType
:
:
eFormatFontColor
:
case
EditorInputType
:
:
eFormatFontName
:
return
true
;
default
:
return
false
;
}
}
inline
bool
IsDataTransferAvailableOnHTMLEditor
(
EditorInputType
aInputType
)
{
switch
(
aInputType
)
{
case
EditorInputType
:
:
eInsertFromPaste
:
case
EditorInputType
:
:
eInsertFromPasteAsQuotation
:
case
EditorInputType
:
:
eInsertFromDrop
:
case
EditorInputType
:
:
eInsertTranspose
:
case
EditorInputType
:
:
eInsertReplacementText
:
case
EditorInputType
:
:
eInsertFromYank
:
return
true
;
default
:
return
false
;
}
}
inline
bool
MayHaveTargetRangesOnHTMLEditor
(
EditorInputType
aInputType
)
{
switch
(
aInputType
)
{
case
EditorInputType
:
:
eHistoryRedo
:
case
EditorInputType
:
:
eHistoryUndo
:
case
EditorInputType
:
:
eFormatSetBlockTextDirection
:
return
false
;
default
:
return
true
;
}
}
inline
bool
IsCancelableBeforeInputEvent
(
EditorInputType
aInputType
)
{
switch
(
aInputType
)
{
case
EditorInputType
:
:
eInsertText
:
return
true
;
case
EditorInputType
:
:
eInsertReplacementText
:
return
true
;
case
EditorInputType
:
:
eInsertLineBreak
:
return
true
;
case
EditorInputType
:
:
eInsertParagraph
:
return
true
;
case
EditorInputType
:
:
eInsertOrderedList
:
return
true
;
case
EditorInputType
:
:
eInsertUnorderedList
:
return
true
;
case
EditorInputType
:
:
eInsertHorizontalRule
:
return
true
;
case
EditorInputType
:
:
eInsertFromYank
:
return
true
;
case
EditorInputType
:
:
eInsertFromDrop
:
return
true
;
case
EditorInputType
:
:
eInsertFromPaste
:
return
true
;
case
EditorInputType
:
:
eInsertFromPasteAsQuotation
:
return
true
;
case
EditorInputType
:
:
eInsertTranspose
:
return
true
;
case
EditorInputType
:
:
eInsertCompositionText
:
return
false
;
case
EditorInputType
:
:
eInsertFromComposition
:
MOZ_ASSERT
(
!
StaticPrefs
:
:
dom_input_events_conform_to_level_1
(
)
)
;
return
true
;
case
EditorInputType
:
:
eInsertLink
:
return
true
;
case
EditorInputType
:
:
eDeleteCompositionText
:
MOZ_ASSERT
(
!
StaticPrefs
:
:
dom_input_events_conform_to_level_1
(
)
)
;
return
false
;
case
EditorInputType
:
:
eDeleteWordBackward
:
return
true
;
case
EditorInputType
:
:
eDeleteWordForward
:
return
true
;
case
EditorInputType
:
:
eDeleteSoftLineBackward
:
return
true
;
case
EditorInputType
:
:
eDeleteSoftLineForward
:
return
true
;
case
EditorInputType
:
:
eDeleteEntireSoftLine
:
return
true
;
case
EditorInputType
:
:
eDeleteHardLineBackward
:
return
true
;
case
EditorInputType
:
:
eDeleteHardLineForward
:
return
true
;
case
EditorInputType
:
:
eDeleteByDrag
:
return
true
;
case
EditorInputType
:
:
eDeleteByCut
:
return
true
;
case
EditorInputType
:
:
eDeleteContent
:
return
true
;
case
EditorInputType
:
:
eDeleteContentBackward
:
return
true
;
case
EditorInputType
:
:
eDeleteContentForward
:
return
true
;
case
EditorInputType
:
:
eHistoryUndo
:
return
true
;
case
EditorInputType
:
:
eHistoryRedo
:
return
true
;
case
EditorInputType
:
:
eFormatBold
:
return
true
;
case
EditorInputType
:
:
eFormatItalic
:
return
true
;
case
EditorInputType
:
:
eFormatUnderline
:
return
true
;
case
EditorInputType
:
:
eFormatStrikeThrough
:
return
true
;
case
EditorInputType
:
:
eFormatSuperscript
:
return
true
;
case
EditorInputType
:
:
eFormatSubscript
:
return
true
;
case
EditorInputType
:
:
eFormatJustifyFull
:
return
true
;
case
EditorInputType
:
:
eFormatJustifyCenter
:
return
true
;
case
EditorInputType
:
:
eFormatJustifyRight
:
return
true
;
case
EditorInputType
:
:
eFormatJustifyLeft
:
return
true
;
case
EditorInputType
:
:
eFormatIndent
:
return
true
;
case
EditorInputType
:
:
eFormatOutdent
:
return
true
;
case
EditorInputType
:
:
eFormatRemove
:
return
true
;
case
EditorInputType
:
:
eFormatSetBlockTextDirection
:
return
true
;
case
EditorInputType
:
:
eFormatSetInlineTextDirection
:
return
true
;
case
EditorInputType
:
:
eFormatBackColor
:
return
true
;
case
EditorInputType
:
:
eFormatFontColor
:
return
true
;
case
EditorInputType
:
:
eFormatFontName
:
return
true
;
case
EditorInputType
:
:
eUnknown
:
return
false
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
The
new
input
type
is
not
handled
"
)
;
return
false
;
}
}
#
define
NS_DEFINE_COMMAND
(
aName
aCommandStr
)
aName
#
define
NS_DEFINE_COMMAND_WITH_PARAM
(
aName
aCommandStr
aParam
)
aName
#
define
NS_DEFINE_COMMAND_NO_EXEC_COMMAND
(
aName
)
aName
typedef
uint8_t
CommandInt
;
enum
class
Command
:
CommandInt
{
DoNothing
#
include
"
mozilla
/
CommandList
.
h
"
}
;
#
undef
NS_DEFINE_COMMAND
#
undef
NS_DEFINE_COMMAND_WITH_PARAM
#
undef
NS_DEFINE_COMMAND_NO_EXEC_COMMAND
const
char
*
ToChar
(
Command
aCommand
)
;
Command
GetInternalCommand
(
const
char
*
aCommandName
const
nsCommandParams
*
aCommandParams
=
nullptr
)
;
}
namespace
mozilla
{
template
<
class
T
>
class
OwningNonNull
;
namespace
dom
{
class
StaticRange
;
}
#
define
NS_EVENT_CLASS
(
aPrefix
aName
)
class
aPrefix
#
#
aName
;
#
define
NS_ROOT_EVENT_CLASS
(
aPrefix
aName
)
NS_EVENT_CLASS
(
aPrefix
aName
)
#
include
"
mozilla
/
EventClassList
.
h
"
#
undef
NS_EVENT_CLASS
#
undef
NS_ROOT_EVENT_CLASS
struct
BaseEventFlags
;
struct
EventFlags
;
class
WidgetEventTime
;
enum
class
AccessKeyType
;
struct
AlternativeCharCode
;
struct
ShortcutKeyCandidate
;
typedef
nsTArray
<
ShortcutKeyCandidate
>
ShortcutKeyCandidateArray
;
typedef
AutoTArray
<
ShortcutKeyCandidate
10
>
AutoShortcutKeyCandidateArray
;
typedef
uint8_t
RawTextRangeType
;
enum
class
TextRangeType
:
RawTextRangeType
;
struct
TextRangeStyle
;
struct
TextRange
;
class
EditCommands
;
class
TextRangeArray
;
typedef
nsTArray
<
OwningNonNull
<
dom
:
:
StaticRange
>
>
OwningNonNullStaticRangeArray
;
struct
FontRange
;
enum
MouseButton
:
int16_t
{
eNotPressed
=
-
1
ePrimary
=
0
eMiddle
=
1
eSecondary
=
2
eX1
=
3
eX2
=
4
eEraser
=
5
}
;
enum
MouseButtonsFlag
{
eNoButtons
=
0x00
ePrimaryFlag
=
0x01
eSecondaryFlag
=
0x02
eMiddleFlag
=
0x04
e4thFlag
=
0x08
e5thFlag
=
0x10
eEraserFlag
=
0x20
}
;
inline
MouseButtonsFlag
MouseButtonsFlagToChange
(
MouseButton
aMouseButton
)
{
switch
(
aMouseButton
)
{
case
MouseButton
:
:
ePrimary
:
return
MouseButtonsFlag
:
:
ePrimaryFlag
;
case
MouseButton
:
:
eMiddle
:
return
MouseButtonsFlag
:
:
eMiddleFlag
;
case
MouseButton
:
:
eSecondary
:
return
MouseButtonsFlag
:
:
eSecondaryFlag
;
case
MouseButton
:
:
eX1
:
return
MouseButtonsFlag
:
:
e4thFlag
;
case
MouseButton
:
:
eX2
:
return
MouseButtonsFlag
:
:
e5thFlag
;
case
MouseButton
:
:
eEraser
:
return
MouseButtonsFlag
:
:
eEraserFlag
;
default
:
return
MouseButtonsFlag
:
:
eNoButtons
;
}
}
enum
class
TextRangeType
:
RawTextRangeType
;
template
<
typename
IntType
>
class
StartAndEndOffsets
;
template
<
typename
IntType
>
class
OffsetAndData
;
}
#
endif
