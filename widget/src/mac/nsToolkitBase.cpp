#
include
<
ctype
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
stdio
.
h
>
#
include
<
mach
/
mach_port
.
h
>
#
include
<
mach
/
mach_interface
.
h
>
#
include
<
mach
/
mach_init
.
h
>
#
include
<
IOKit
/
pwr_mgt
/
IOPMLib
.
h
>
#
include
<
IOKit
/
IOMessage
.
h
>
#
include
<
CoreFoundation
/
CoreFoundation
.
h
>
#
include
<
Carbon
/
Carbon
.
h
>
#
include
"
nsToolkitBase
.
h
"
#
include
"
nsWidgetAtoms
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIPrefBranch2
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIPrefService
.
h
"
#
include
"
nsIObserver
.
h
"
static
io_connect_t
gRootPort
=
MACH_PORT_NULL
;
static
const
char
kQuartzRenderingPref
[
]
=
"
browser
.
quartz
.
enable
"
;
static
const
char
kAllFontSizesPref
[
]
=
"
browser
.
quartz
.
enable
.
all_font_sizes
"
;
static
PRUintn
gToolkitTLSIndex
=
0
;
nsToolkitBase
:
:
nsToolkitBase
(
)
:
mInited
(
false
)
mSleepWakeNotificationRLS
(
nsnull
)
{
}
nsToolkitBase
:
:
~
nsToolkitBase
(
)
{
RemoveSleepWakeNotifcations
(
)
;
PR_SetThreadPrivate
(
gToolkitTLSIndex
nsnull
)
;
}
NS_IMPL_THREADSAFE_ISUPPORTS2
(
nsToolkitBase
nsIToolkit
nsIObserver
)
;
NS_IMETHODIMP
nsToolkitBase
:
:
Init
(
PRThread
*
aThread
)
{
nsresult
rv
=
InitEventQueue
(
aThread
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsWidgetAtoms
:
:
RegisterAtoms
(
)
;
mInited
=
true
;
RegisterForSleepWakeNotifcations
(
)
;
SetupQuartzRendering
(
)
;
nsCOMPtr
<
nsIPrefBranch2
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
prefs
)
{
prefs
-
>
AddObserver
(
kQuartzRenderingPref
this
PR_FALSE
)
;
prefs
-
>
AddObserver
(
kAllFontSizesPref
this
PR_FALSE
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsToolkitBase
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
PRUnichar
*
aData
)
{
SetupQuartzRendering
(
)
;
return
NS_OK
;
}
void
nsToolkitBase
:
:
SetupQuartzRendering
(
)
{
enum
{
kQDDontChangeFlags
=
0xFFFFFFFF
kQDUseDefaultTextRendering
=
0
kQDUseTrueTypeScalerGlyphs
=
(
1
<
<
0
)
kQDUseCGTextRendering
=
(
1
<
<
1
)
kQDUseCGTextMetrics
=
(
1
<
<
2
)
}
;
const
int
kFlagsWeUse
=
kQDUseCGTextRendering
|
kQDUseCGTextMetrics
;
nsCOMPtr
<
nsIPrefBranch
>
prefs
=
do_GetService
(
NS_PREFSERVICE_CONTRACTID
)
;
if
(
!
prefs
)
return
;
PRBool
enableQuartz
=
PR_TRUE
;
nsresult
rv
=
prefs
-
>
GetBoolPref
(
kQuartzRenderingPref
&
enableQuartz
)
;
UInt32
oldFlags
=
QDSwapTextFlags
(
kQDDontChangeFlags
)
;
if
(
NS_FAILED
(
rv
)
|
|
enableQuartz
)
{
QDSwapTextFlags
(
oldFlags
|
kFlagsWeUse
)
;
PRBool
antiAliasAllFontSizes
=
PR_FALSE
;
rv
=
prefs
-
>
GetBoolPref
(
kAllFontSizesPref
&
antiAliasAllFontSizes
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
antiAliasAllFontSizes
)
SetOutlinePreferred
(
true
)
;
}
else
QDSwapTextFlags
(
oldFlags
&
!
kFlagsWeUse
)
;
}
static
void
ToolkitSleepWakeCallback
(
void
*
refCon
io_service_t
service
natural_t
messageType
void
*
messageArgument
)
{
switch
(
messageType
)
{
case
kIOMessageSystemWillSleep
:
nsToolkitBase
:
:
PostSleepWakeNotification
(
"
sleep_notification
"
)
;
:
:
IOAllowPowerChange
(
gRootPort
(
long
)
messageArgument
)
;
break
;
case
kIOMessageCanSystemSleep
:
:
:
IOAllowPowerChange
(
gRootPort
(
long
)
messageArgument
)
;
break
;
case
kIOMessageSystemHasPoweredOn
:
nsToolkitBase
:
:
PostSleepWakeNotification
(
"
wake_notification
"
)
;
break
;
}
}
void
nsToolkitBase
:
:
PostSleepWakeNotification
(
const
char
*
aNotification
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
do_GetService
(
"
mozilla
.
org
/
observer
-
service
;
1
"
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nsnull
aNotification
nsnull
)
;
}
}
nsresult
nsToolkitBase
:
:
RegisterForSleepWakeNotifcations
(
)
{
IONotificationPortRef
notifyPortRef
;
NS_ASSERTION
(
!
mSleepWakeNotificationRLS
"
Already
registered
for
sleep
/
wake
"
)
;
gRootPort
=
:
:
IORegisterForSystemPower
(
0
&
notifyPortRef
ToolkitSleepWakeCallback
&
mPowerNotifier
)
;
if
(
gRootPort
=
=
MACH_PORT_NULL
)
{
NS_ASSERTION
(
0
"
IORegisterForSystemPower
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
mSleepWakeNotificationRLS
=
:
:
IONotificationPortGetRunLoopSource
(
notifyPortRef
)
;
:
:
CFRunLoopAddSource
(
:
:
CFRunLoopGetCurrent
(
)
mSleepWakeNotificationRLS
kCFRunLoopDefaultMode
)
;
return
NS_OK
;
}
void
nsToolkitBase
:
:
RemoveSleepWakeNotifcations
(
)
{
if
(
mSleepWakeNotificationRLS
)
{
:
:
IODeregisterForSystemPower
(
&
mPowerNotifier
)
;
:
:
CFRunLoopRemoveSource
(
:
:
CFRunLoopGetCurrent
(
)
mSleepWakeNotificationRLS
kCFRunLoopDefaultMode
)
;
mSleepWakeNotificationRLS
=
nsnull
;
}
}
#
pragma
mark
-
NS_METHOD
NS_GetCurrentToolkit
(
nsIToolkit
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
nsnull
;
if
(
gToolkitTLSIndex
=
=
0
)
{
PRStatus
status
=
PR_NewThreadPrivateIndex
(
&
gToolkitTLSIndex
NULL
)
;
if
(
PR_FAILURE
=
=
status
)
return
NS_ERROR_FAILURE
;
}
nsToolkitBase
*
toolkit
=
(
nsToolkitBase
*
)
PR_GetThreadPrivate
(
gToolkitTLSIndex
)
;
if
(
!
toolkit
)
{
toolkit
=
NS_CreateToolkitInstance
(
)
;
if
(
!
toolkit
)
return
NS_ERROR_OUT_OF_MEMORY
;
NS_ADDREF
(
toolkit
)
;
toolkit
-
>
Init
(
PR_GetCurrentThread
(
)
)
;
PR_SetThreadPrivate
(
gToolkitTLSIndex
(
void
*
)
toolkit
)
;
}
else
{
NS_ADDREF
(
toolkit
)
;
}
*
aResult
=
toolkit
;
return
NS_OK
;
}
