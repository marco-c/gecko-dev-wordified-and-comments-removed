#
include
<
Gestalt
.
h
>
#
include
"
nsDragService
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsMimeMapper
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
nsIRegion
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
nsLinebreakConverter
.
h
"
#
include
"
nsIMacUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIView
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsIWidget
.
h
"
#
ifndef
MOZ_WIDGET_COCOA
#
include
"
nsCarbonHelpers
.
h
"
#
endif
#
include
"
nsNetUtil
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
ifndef
MOZ_CAIRO_GFX
#
include
"
nsIImageMac
.
h
"
#
endif
#
include
"
nsIImage
.
h
"
#
include
"
nsMacNativeUnicodeConverter
.
h
"
#
include
"
nsICharsetConverterManager
.
h
"
#
include
"
nsStylClipboardUtils
.
h
"
static
nsIFrame
*
GetPrimaryFrameFor
(
nsIContent
*
aContent
)
{
nsIFrame
*
result
=
nsnull
;
nsIDocument
*
doc
=
aContent
-
>
GetCurrentDoc
(
)
;
if
(
doc
)
{
nsIPresShell
*
presShell
=
doc
-
>
GetPrimaryShell
(
)
;
if
(
presShell
)
{
result
=
presShell
-
>
GetPrimaryFrameFor
(
aContent
)
;
}
}
return
result
;
}
static
const
PRUint32
kPrivateFlavorMask
=
0xffff0000
;
static
const
PRUint32
kPrivateFlavorTag
=
'
MZ
.
.
'
&
kPrivateFlavorMask
;
static
void
SetPortToKnownGoodPort
(
)
{
WindowPtr
firstWindow
=
GetWindowList
(
)
;
if
(
firstWindow
)
:
:
SetGWorld
(
:
:
GetWindowPort
(
firstWindow
)
:
:
GetMainDevice
(
)
)
;
}
NS_IMPL_ADDREF_INHERITED
(
nsDragService
nsBaseDragService
)
NS_IMPL_RELEASE_INHERITED
(
nsDragService
nsBaseDragService
)
NS_IMPL_QUERY_INTERFACE3
(
nsDragService
nsIDragService
nsIDragSession
nsIDragSessionMac
)
nsDragService
:
:
nsDragService
(
)
:
mDragSendDataUPP
(
nsnull
)
mDragRef
(
0
)
mDataItems
(
nsnull
)
mImageDraggingSupported
(
PR_FALSE
)
{
#
if
USE_TRANSLUCENT_DRAGS
long
response
;
OSErr
err
=
Gestalt
(
gestaltDragMgrAttr
&
response
)
;
if
(
err
=
=
noErr
&
&
(
response
&
(
1L
<
<
gestaltDragMgrHasImageSupport
)
)
)
{
mImageDraggingSupported
=
PR_TRUE
;
}
#
endif
mDragSendDataUPP
=
NewDragSendDataUPP
(
DragSendDataProc
)
;
}
nsDragService
:
:
~
nsDragService
(
)
{
if
(
mDragSendDataUPP
)
:
:
DisposeDragSendDataUPP
(
mDragSendDataUPP
)
;
}
PRBool
nsDragService
:
:
ComputeGlobalRectFromFrame
(
nsIDOMNode
*
aDOMNode
Rect
&
outScreenRect
)
{
NS_ASSERTION
(
aDOMNode
"
Oopps
no
DOM
node
"
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aDOMNode
)
;
#
if
USE_TRANSLUCENT_DRAGGING
&
&
defined
(
MOZ_XUL
)
if
(
!
content
|
|
!
content
-
>
IsNodeOfType
(
nsINode
:
:
eXUL
)
)
{
nsCOMPtr
<
nsIDOMNode
>
parent
;
aDOMNode
-
>
GetParentNode
(
getter_AddRefs
(
parent
)
)
;
if
(
parent
)
{
nsAutoString
localName
;
parent
-
>
GetLocalName
(
localName
)
;
if
(
!
localName
.
EqualsLiteral
(
"
A
"
)
)
return
PR_FALSE
;
}
else
return
FALSE
;
}
#
endif
outScreenRect
.
left
=
outScreenRect
.
right
=
outScreenRect
.
top
=
outScreenRect
.
bottom
=
0
;
if
(
!
content
)
return
PR_FALSE
;
nsIFrame
*
frame
=
:
:
GetPrimaryFrameFor
(
content
)
;
if
(
!
frame
)
return
PR_FALSE
;
nsRect
rect
=
frame
-
>
GetRect
(
)
;
nsIView
*
containingView
=
nsnull
;
nsPoint
viewOffset
(
0
0
)
;
frame
-
>
GetOffsetFromView
(
viewOffset
&
containingView
)
;
NS_ASSERTION
(
containingView
"
No
containing
view
!
"
)
;
if
(
!
containingView
)
return
PR_FALSE
;
nsPoint
widgetOffset
;
nsIWidget
*
aWidget
=
containingView
-
>
GetNearestWidget
(
&
widgetOffset
)
;
float
t2p
=
frame
-
>
GetPresContext
(
)
-
>
TwipsToPixels
(
)
;
nsRect
screenOffset
;
screenOffset
.
MoveBy
(
NSTwipsToIntPixels
(
widgetOffset
.
x
+
viewOffset
.
x
t2p
)
NSTwipsToIntPixels
(
widgetOffset
.
y
+
viewOffset
.
y
t2p
)
)
;
aWidget
-
>
WidgetToScreen
(
screenOffset
screenOffset
)
;
outScreenRect
.
left
=
screenOffset
.
x
;
outScreenRect
.
top
=
screenOffset
.
y
;
outScreenRect
.
right
=
outScreenRect
.
left
+
NSTwipsToIntPixels
(
rect
.
width
t2p
)
;
outScreenRect
.
bottom
=
outScreenRect
.
top
+
NSTwipsToIntPixels
(
rect
.
height
t2p
)
;
return
PR_TRUE
;
}
NS_IMETHODIMP
nsDragService
:
:
InvokeDragSession
(
nsIDOMNode
*
aDOMNode
nsISupportsArray
*
aTransferableArray
nsIScriptableRegion
*
aDragRgn
PRUint32
aActionType
)
{
#
ifdef
MOZ_WIDGET_COCOA
SetPortToKnownGoodPort
(
)
;
GrafPtr
port
;
GDHandle
handle
;
:
:
GetGWorld
(
&
port
&
handle
)
;
if
(
!
IsValidPort
(
port
)
)
return
NS_ERROR_FAILURE
;
#
endif
:
:
InitCursor
(
)
;
nsBaseDragService
:
:
InvokeDragSession
(
aDOMNode
aTransferableArray
aDragRgn
aActionType
)
;
DragReference
theDragRef
;
OSErr
result
=
:
:
NewDrag
(
&
theDragRef
)
;
if
(
result
!
=
noErr
)
return
NS_ERROR_FAILURE
;
mDragRef
=
theDragRef
;
#
if
DEBUG_DD
printf
(
"
*
*
*
*
created
drag
ref
%
ld
\
n
"
theDragRef
)
;
#
endif
Rect
frameRect
=
{
0
0
0
0
}
;
RgnHandle
theDragRgn
=
:
:
NewRgn
(
)
;
:
:
RectRgn
(
theDragRgn
&
frameRect
)
;
if
(
mImageDraggingSupported
)
{
Point
imgOffsetPt
;
imgOffsetPt
.
v
=
imgOffsetPt
.
h
=
0
;
PRBool
canUseRect
=
BuildDragRegion
(
aDragRgn
aDOMNode
theDragRgn
)
;
if
(
canUseRect
)
{
:
:
SetDragImage
(
theDragRef
nsnull
theDragRgn
imgOffsetPt
kDragDarkerTranslucency
)
;
}
}
else
BuildDragRegion
(
aDragRgn
aDOMNode
theDragRgn
)
;
mDataItems
=
aTransferableArray
;
RegisterDragItemsAndFlavors
(
aTransferableArray
theDragRgn
)
;
EventRecord
theEvent
;
theEvent
.
what
=
mouseDown
;
theEvent
.
message
=
0L
;
theEvent
.
when
=
TickCount
(
)
;
theEvent
.
modifiers
=
0L
;
if
(
mScreenX
=
=
-
1
|
|
mScreenY
=
=
-
1
)
{
Rect
dragRect
;
:
:
GetRegionBounds
(
theDragRgn
&
dragRect
)
;
theEvent
.
where
.
v
=
dragRect
.
top
+
(
(
dragRect
.
bottom
-
dragRect
.
top
)
/
2
)
;
theEvent
.
where
.
h
=
dragRect
.
left
+
(
(
dragRect
.
right
-
dragRect
.
left
)
/
2
)
;
}
else
{
theEvent
.
where
.
v
=
mScreenY
;
theEvent
.
where
.
h
=
mScreenX
;
}
:
:
SetDragSendProc
(
theDragRef
mDragSendDataUPP
this
)
;
StartDragSession
(
)
;
:
:
TrackDrag
(
theDragRef
&
theEvent
theDragRgn
)
;
EndDragSession
(
PR_TRUE
)
;
:
:
DisposeRgn
(
theDragRgn
)
;
result
=
:
:
DisposeDrag
(
theDragRef
)
;
#
if
DEBUG_DD
printf
(
"
*
*
*
*
disposing
drag
ref
%
ld
\
n
"
theDragRef
)
;
#
endif
NS_ASSERTION
(
result
=
=
noErr
"
Error
disposing
drag
"
)
;
mDragRef
=
0L
;
mDataItems
=
nsnull
;
return
NS_OK
;
}
PRBool
nsDragService
:
:
BuildDragRegion
(
nsIScriptableRegion
*
inRegion
nsIDOMNode
*
inNode
RgnHandle
ioDragRgn
)
{
PRBool
retVal
=
PR_TRUE
;
nsCOMPtr
<
nsIRegion
>
geckoRegion
;
if
(
inRegion
)
inRegion
-
>
GetRegion
(
getter_AddRefs
(
geckoRegion
)
)
;
#
ifdef
MOZ_WIDGET_COCOA
SetPortToKnownGoodPort
(
)
;
GrafPtr
port
;
GDHandle
handle
;
:
:
GetGWorld
(
&
port
&
handle
)
;
if
(
!
IsValidPort
(
port
)
)
return
NS_ERROR_FAILURE
;
#
endif
if
(
geckoRegion
)
{
RgnHandle
dragRegion
=
nsnull
;
geckoRegion
-
>
GetNativeRegion
(
(
void
*
&
)
dragRegion
)
;
if
(
dragRegion
&
&
ioDragRgn
)
{
:
:
CopyRgn
(
dragRegion
ioDragRgn
)
;
:
:
InsetRgn
(
ioDragRgn
1
1
)
;
:
:
DiffRgn
(
dragRegion
ioDragRgn
ioDragRgn
)
;
Point
offsetFromLocalToGlobal
=
{
0
0
}
;
:
:
LocalToGlobal
(
&
offsetFromLocalToGlobal
)
;
:
:
OffsetRgn
(
ioDragRgn
offsetFromLocalToGlobal
.
h
offsetFromLocalToGlobal
.
v
)
;
}
}
else
{
PRBool
useRectFromFrame
=
PR_FALSE
;
Point
currMouse
;
:
:
GetMouse
(
&
currMouse
)
;
Rect
frameRect
=
{
currMouse
.
v
currMouse
.
h
currMouse
.
v
+
25
currMouse
.
h
+
100
}
;
if
(
inNode
)
useRectFromFrame
=
ComputeGlobalRectFromFrame
(
inNode
frameRect
)
;
else
NS_WARNING
(
"
Can
'
t
find
anything
to
get
a
drag
rect
from
.
I
'
m
dyin
'
out
here
!
"
)
;
if
(
ioDragRgn
)
{
RgnHandle
frameRgn
=
:
:
NewRgn
(
)
;
if
(
frameRgn
)
{
:
:
RectRgn
(
frameRgn
&
frameRect
)
;
:
:
CopyRgn
(
frameRgn
ioDragRgn
)
;
:
:
InsetRgn
(
ioDragRgn
1
1
)
;
:
:
DiffRgn
(
frameRgn
ioDragRgn
ioDragRgn
)
;
:
:
DisposeRgn
(
frameRgn
)
;
}
}
retVal
=
useRectFromFrame
;
}
return
retVal
;
}
void
nsDragService
:
:
RegisterDragItemsAndFlavors
(
nsISupportsArray
*
inArray
RgnHandle
inDragRgn
)
{
const
FlavorFlags
flags
=
0
;
Rect
dragRgnBounds
=
{
0
0
0
0
}
;
if
(
inDragRgn
)
GetRegionBounds
(
inDragRgn
&
dragRgnBounds
)
;
PRUint32
numDragItems
=
0
;
inArray
-
>
Count
(
&
numDragItems
)
;
for
(
PRUint32
itemIndex
=
0
;
itemIndex
<
numDragItems
;
+
+
itemIndex
)
{
nsMimeMapperMac
theMapper
;
nsCOMPtr
<
nsISupports
>
genericItem
;
inArray
-
>
GetElementAt
(
itemIndex
getter_AddRefs
(
genericItem
)
)
;
nsCOMPtr
<
nsITransferable
>
currItem
(
do_QueryInterface
(
genericItem
)
)
;
if
(
currItem
)
{
nsCOMPtr
<
nsISupportsArray
>
flavorList
;
if
(
NS_SUCCEEDED
(
currItem
-
>
FlavorsTransferableCanExport
(
getter_AddRefs
(
flavorList
)
)
)
)
{
PRUint32
numFlavors
;
flavorList
-
>
Count
(
&
numFlavors
)
;
for
(
PRUint32
flavorIndex
=
0
;
flavorIndex
<
numFlavors
;
+
+
flavorIndex
)
{
nsCOMPtr
<
nsISupports
>
genericWrapper
;
flavorList
-
>
GetElementAt
(
flavorIndex
getter_AddRefs
(
genericWrapper
)
)
;
nsCOMPtr
<
nsISupportsCString
>
currentFlavor
(
do_QueryInterface
(
genericWrapper
)
)
;
if
(
currentFlavor
)
{
nsCAutoString
flavorStr
;
currentFlavor
-
>
GetData
(
flavorStr
)
;
FlavorType
macOSFlavor
=
theMapper
.
MapMimeTypeToMacOSType
(
flavorStr
.
get
(
)
)
;
if
(
macOSFlavor
=
=
kDragFlavorTypePromiseHFS
)
{
PromiseHFSFlavor
promiseData
;
promiseData
.
fileType
=
0
;
promiseData
.
fileCreator
=
0
;
promiseData
.
fdFlags
=
0
;
promiseData
.
promisedFlavor
=
kDragPromisedFlavor
;
:
:
AddDragItemFlavor
(
mDragRef
itemIndex
kDragFlavorTypePromiseHFS
&
promiseData
sizeof
(
promiseData
)
flavorNotSaved
)
;
:
:
AddDragItemFlavor
(
mDragRef
itemIndex
kDragPromisedFlavor
NULL
0
flavorNotSaved
)
;
}
else
:
:
AddDragItemFlavor
(
mDragRef
itemIndex
macOSFlavor
NULL
0
flags
)
;
if
(
strcmp
(
flavorStr
.
get
(
)
kUnicodeMime
)
=
=
0
)
{
theMapper
.
MapMimeTypeToMacOSType
(
kTextMime
)
;
:
:
AddDragItemFlavor
(
mDragRef
itemIndex
'
TEXT
'
NULL
0
flags
)
;
:
:
AddDragItemFlavor
(
mDragRef
itemIndex
'
styl
'
NULL
0
flags
)
;
}
}
}
}
}
short
mappingLen
;
char
*
mapping
=
theMapper
.
ExportMapping
(
&
mappingLen
)
;
if
(
mapping
&
&
mappingLen
)
{
:
:
AddDragItemFlavor
(
mDragRef
itemIndex
nsMimeMapperMac
:
:
MappingFlavor
(
)
mapping
mappingLen
flags
)
;
nsMemory
:
:
Free
(
mapping
)
;
:
:
SetDragItemBounds
(
mDragRef
itemIndex
&
dragRgnBounds
)
;
}
}
}
NS_IMETHODIMP
nsDragService
:
:
GetData
(
nsITransferable
*
aTransferable
PRUint32
aItemIndex
)
{
nsresult
errCode
=
NS_ERROR_FAILURE
;
if
(
!
aTransferable
)
return
NS_ERROR_INVALID_ARG
;
nsCOMPtr
<
nsISupportsArray
>
flavorList
;
errCode
=
aTransferable
-
>
FlavorsTransferableCanImport
(
getter_AddRefs
(
flavorList
)
)
;
if
(
NS_FAILED
(
errCode
)
)
return
errCode
;
ItemReference
itemRef
;
:
:
GetDragItemReferenceNumber
(
mDragRef
aItemIndex
+
1
&
itemRef
)
;
char
*
mappings
=
LookupMimeMappingsForItem
(
mDragRef
itemRef
)
;
nsMimeMapperMac
theMapper
(
mappings
)
;
nsMemory
:
:
Free
(
mappings
)
;
PRUint32
cnt
;
flavorList
-
>
Count
(
&
cnt
)
;
for
(
PRUint32
i
=
0
;
i
<
cnt
;
+
+
i
)
{
nsCOMPtr
<
nsISupports
>
genericWrapper
;
flavorList
-
>
GetElementAt
(
i
getter_AddRefs
(
genericWrapper
)
)
;
nsCOMPtr
<
nsISupportsCString
>
currentFlavor
(
do_QueryInterface
(
genericWrapper
)
)
;
if
(
currentFlavor
)
{
nsCAutoString
flavorStr
;
currentFlavor
-
>
GetData
(
flavorStr
)
;
FlavorType
macOSFlavor
=
theMapper
.
MapMimeTypeToMacOSType
(
flavorStr
.
get
(
)
PR_FALSE
)
;
#
if
DEBUG_DD
printf
(
"
looking
for
data
in
type
%
s
mac
flavor
%
ld
\
n
"
flavorStr
.
get
(
)
macOSFlavor
)
;
#
endif
FlavorFlags
unused
;
PRBool
dataFound
=
PR_FALSE
;
void
*
dataBuff
=
nsnull
;
PRUint32
dataSize
=
0
;
if
(
macOSFlavor
&
&
:
:
GetFlavorFlags
(
mDragRef
itemRef
macOSFlavor
&
unused
)
=
=
noErr
)
{
nsresult
loadResult
=
ExtractDataFromOS
(
mDragRef
itemRef
macOSFlavor
&
dataBuff
&
dataSize
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
dataBuff
)
dataFound
=
PR_TRUE
;
}
else
{
if
(
strcmp
(
flavorStr
.
get
(
)
kUnicodeMime
)
=
=
0
)
{
if
(
:
:
GetFlavorFlags
(
mDragRef
itemRef
'
TEXT
'
&
unused
)
=
=
noErr
)
{
nsresult
loadResult
=
ExtractDataFromOS
(
mDragRef
itemRef
'
styl
'
&
dataBuff
&
dataSize
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
dataBuff
&
&
(
dataSize
>
=
(
sizeof
(
ScrpSTElement
)
+
2
)
)
)
{
StScrpRec
*
scrpRecP
=
(
StScrpRec
*
)
dataBuff
;
ScrpSTElement
*
styl
=
scrpRecP
-
>
scrpStyleTab
;
ScriptCode
script
=
styl
?
:
:
FontToScript
(
styl
-
>
scrpFont
)
:
smCurrentScript
;
nsMemory
:
:
Free
(
dataBuff
)
;
loadResult
=
ExtractDataFromOS
(
mDragRef
itemRef
'
TEXT
'
&
dataBuff
&
dataSize
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
dataBuff
)
{
PRUnichar
*
convertedText
=
nsnull
;
PRInt32
convertedTextLen
=
0
;
errCode
=
nsMacNativeUnicodeConverter
:
:
ConvertScripttoUnicode
(
script
(
const
char
*
)
dataBuff
dataSize
&
convertedText
&
convertedTextLen
)
;
if
(
NS_SUCCEEDED
(
errCode
)
&
&
convertedText
)
{
nsMemory
:
:
Free
(
dataBuff
)
;
dataBuff
=
convertedText
;
dataSize
=
convertedTextLen
*
sizeof
(
PRUnichar
)
;
dataFound
=
PR_TRUE
;
}
}
}
if
(
!
dataFound
)
{
loadResult
=
ExtractDataFromOS
(
mDragRef
itemRef
'
TEXT
'
&
dataBuff
&
dataSize
)
;
if
(
NS_SUCCEEDED
(
loadResult
)
&
&
dataBuff
)
{
const
char
*
castedText
=
NS_REINTERPRET_CAST
(
char
*
dataBuff
)
;
PRUnichar
*
convertedText
=
nsnull
;
PRInt32
convertedTextLen
=
0
;
nsPrimitiveHelpers
:
:
ConvertPlatformPlainTextToUnicode
(
castedText
dataSize
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
nsMemory
:
:
Free
(
dataBuff
)
;
dataBuff
=
convertedText
;
dataSize
=
convertedTextLen
*
2
;
dataFound
=
PR_TRUE
;
}
}
}
}
}
}
if
(
dataFound
)
{
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
if
(
strcmp
(
flavorStr
.
get
(
)
kFileMime
)
=
=
0
)
{
HFSFlavor
*
fileData
=
NS_REINTERPRET_CAST
(
HFSFlavor
*
dataBuff
)
;
NS_ASSERTION
(
sizeof
(
HFSFlavor
)
=
=
dataSize
"
Ooops
we
really
don
'
t
have
a
HFSFlavor
"
)
;
nsCOMPtr
<
nsILocalFileMac
>
file
;
if
(
NS_SUCCEEDED
(
NS_NewLocalFileWithFSSpec
(
&
fileData
-
>
fileSpec
PR_TRUE
getter_AddRefs
(
file
)
)
)
)
genericDataWrapper
=
do_QueryInterface
(
file
)
;
}
else
if
(
(
strcmp
(
flavorStr
.
get
(
)
kURLDataMime
)
=
=
0
)
|
|
(
strcmp
(
flavorStr
.
get
(
)
kURLDescriptionMime
)
=
=
0
)
)
{
const
char
*
castedText
=
NS_REINTERPRET_CAST
(
char
*
dataBuff
)
;
PRUnichar
*
convertedText
=
nsnull
;
PRInt32
convertedTextLen
=
0
;
nsPrimitiveHelpers
:
:
ConvertPlatformPlainTextToUnicode
(
castedText
dataSize
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
nsMemory
:
:
Free
(
dataBuff
)
;
dataBuff
=
convertedText
;
dataSize
=
convertedTextLen
*
2
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
flavorStr
.
get
(
)
(
void
*
)
dataBuff
dataSize
getter_AddRefs
(
genericDataWrapper
)
)
;
}
}
else
{
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
flavorStr
.
get
(
)
&
dataBuff
NS_REINTERPRET_CAST
(
int
*
&
dataSize
)
)
;
unsigned
char
*
dataPtr
=
(
unsigned
char
*
)
dataBuff
;
if
(
(
macOSFlavor
=
=
'
utxt
'
)
&
&
(
dataSize
>
2
)
&
&
(
(
dataPtr
[
0
]
=
=
0xFE
&
&
dataPtr
[
1
]
=
=
0xFF
)
|
|
(
dataPtr
[
0
]
=
=
0xFF
&
&
dataPtr
[
1
]
=
=
0xFE
)
)
)
{
dataSize
-
=
sizeof
(
PRUnichar
)
;
dataPtr
+
=
sizeof
(
PRUnichar
)
;
}
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
flavorStr
.
get
(
)
(
void
*
)
dataPtr
dataSize
getter_AddRefs
(
genericDataWrapper
)
)
;
}
errCode
=
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
genericDataWrapper
dataSize
)
;
#
ifdef
NS_DEBUG
if
(
errCode
!
=
NS_OK
)
printf
(
"
nsDragService
:
:
Error
setting
data
into
transferable
\
n
"
)
;
#
endif
nsMemory
:
:
Free
(
dataBuff
)
;
errCode
=
NS_OK
;
break
;
}
}
}
return
errCode
;
}
NS_IMETHODIMP
nsDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
PRBool
*
_retval
)
{
if
(
!
_retval
)
return
NS_ERROR_INVALID_ARG
;
#
ifdef
NS_DEBUG
if
(
strcmp
(
aDataFlavor
kTextMime
)
=
=
0
)
NS_WARNING
(
"
DO
NOT
USE
THE
text
/
plain
DATA
FLAVOR
ANY
MORE
.
USE
text
/
unicode
INSTEAD
"
)
;
#
endif
*
_retval
=
PR_FALSE
;
unsigned
short
numDragItems
=
0
;
:
:
CountDragItems
(
mDragRef
&
numDragItems
)
;
for
(
int
i
=
1
;
i
<
=
numDragItems
;
+
+
i
)
{
ItemReference
currItem
;
OSErr
res
=
:
:
GetDragItemReferenceNumber
(
mDragRef
i
&
currItem
)
;
if
(
res
!
=
noErr
)
return
NS_ERROR_FAILURE
;
char
*
mappings
=
LookupMimeMappingsForItem
(
mDragRef
currItem
)
;
nsMimeMapperMac
theMapper
(
mappings
)
;
FlavorType
macFlavor
=
theMapper
.
MapMimeTypeToMacOSType
(
aDataFlavor
PR_FALSE
)
;
nsMemory
:
:
Free
(
mappings
)
;
FlavorFlags
ignored
;
if
(
:
:
GetFlavorFlags
(
mDragRef
currItem
macFlavor
&
ignored
)
=
=
noErr
)
*
_retval
=
PR_TRUE
;
else
{
if
(
strcmp
(
aDataFlavor
kUnicodeMime
)
=
=
0
)
{
if
(
:
:
GetFlavorFlags
(
mDragRef
currItem
'
TEXT
'
&
ignored
)
=
=
noErr
)
*
_retval
=
PR_TRUE
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetNumDropItems
(
PRUint32
*
aNumItems
)
{
unsigned
short
numDragItems
=
0
;
OSErr
result
=
:
:
CountDragItems
(
mDragRef
&
numDragItems
)
;
*
aNumItems
=
numDragItems
;
return
(
result
=
=
noErr
?
NS_OK
:
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsDragService
:
:
SetDragReference
(
DragReference
aDragRef
)
{
mDragRef
=
aDragRef
;
return
NS_OK
;
}
pascal
OSErr
nsDragService
:
:
DragSendDataProc
(
FlavorType
inFlavor
void
*
inRefCon
ItemReference
inItemRef
DragReference
inDragRef
)
{
OSErr
retVal
=
noErr
;
nsDragService
*
dragService
=
NS_STATIC_CAST
(
nsDragService
*
inRefCon
)
;
NS_ASSERTION
(
dragService
"
Refcon
not
set
correctly
for
DragSendDataProc
"
)
;
if
(
dragService
)
{
void
*
data
=
nsnull
;
PRUint32
dataSize
=
0
;
retVal
=
dragService
-
>
GetDataForFlavor
(
dragService
-
>
mDataItems
inDragRef
inItemRef
inFlavor
&
data
&
dataSize
)
;
if
(
retVal
=
=
noErr
)
{
if
(
(
inFlavor
&
kPrivateFlavorMask
)
=
=
kPrivateFlavorTag
)
{
nsCOMPtr
<
nsIMacUtils
>
macUtils
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
)
;
PRBool
isTranslated
;
if
(
macUtils
&
&
NS_SUCCEEDED
(
macUtils
-
>
GetIsTranslated
(
&
isTranslated
)
)
&
&
isTranslated
)
{
char
*
swappedData
=
(
char
*
)
nsMemory
:
:
Alloc
(
dataSize
)
;
if
(
!
swappedData
)
{
nsMemory
:
:
Free
(
data
)
;
return
notEnoughMemoryErr
;
}
else
{
swab
(
data
swappedData
dataSize
)
;
nsMemory
:
:
Free
(
data
)
;
data
=
swappedData
;
}
}
}
retVal
=
:
:
SetDragItemFlavorData
(
inDragRef
inItemRef
inFlavor
data
dataSize
0
)
;
NS_ASSERTION
(
retVal
=
=
noErr
"
SDIFD
failed
in
DragSendDataProc
"
)
;
}
if
(
data
)
nsMemory
:
:
Free
(
data
)
;
}
return
retVal
;
}
OSErr
nsDragService
:
:
GetDataForFlavor
(
nsISupportsArray
*
inDragItems
DragReference
inDragRef
unsigned
int
inItemIndex
FlavorType
inFlavor
void
*
*
outData
unsigned
int
*
outDataSize
)
{
if
(
!
inDragItems
|
|
!
inDragRef
)
return
paramErr
;
*
outData
=
nsnull
;
*
outDataSize
=
0
;
OSErr
retVal
=
noErr
;
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
genericItem
;
inDragItems
-
>
GetElementAt
(
inItemIndex
getter_AddRefs
(
genericItem
)
)
;
nsCOMPtr
<
nsITransferable
>
item
(
do_QueryInterface
(
genericItem
)
)
;
if
(
!
item
)
return
cantGetFlavorErr
;
char
*
mappings
=
LookupMimeMappingsForItem
(
inDragRef
inItemIndex
)
;
nsMimeMapperMac
theMapper
(
mappings
)
;
nsCAutoString
mimeFlavor
;
theMapper
.
MapMacOSTypeToMimeType
(
inFlavor
mimeFlavor
)
;
nsMemory
:
:
Free
(
mappings
)
;
PRBool
needToDoConversionToPlainText
=
PR_FALSE
;
const
char
*
actualFlavor
=
mimeFlavor
.
get
(
)
;
if
(
strcmp
(
mimeFlavor
.
get
(
)
kTextMime
)
=
=
0
|
|
inFlavor
=
=
'
styl
'
)
{
actualFlavor
=
kUnicodeMime
;
needToDoConversionToPlainText
=
PR_TRUE
;
}
else
if
(
strcmp
(
actualFlavor
kURLDataMime
)
=
=
0
)
{
needToDoConversionToPlainText
=
PR_TRUE
;
}
else
if
(
strcmp
(
actualFlavor
kURLDescriptionMime
)
=
=
0
)
{
needToDoConversionToPlainText
=
PR_TRUE
;
}
else
if
(
strcmp
(
actualFlavor
kFilePromiseMime
)
=
=
0
)
{
nsCOMPtr
<
nsILocalFile
>
dropDirectory
;
OSErr
err
=
GetHFSPromiseDropDirectory
(
inDragRef
inItemIndex
inFlavor
getter_AddRefs
(
dropDirectory
)
)
;
if
(
err
!
=
noErr
)
return
err
;
nsCOMPtr
<
nsISupports
>
localFileISupports
=
do_QueryInterface
(
dropDirectory
)
;
item
-
>
SetTransferData
(
kFilePromiseDirectoryMime
localFileISupports
sizeof
(
nsILocalFile
*
)
)
;
nsCOMPtr
<
nsISupports
>
fileDataPrimitive
;
PRUint32
dataSize
=
0
;
rv
=
item
-
>
GetTransferData
(
kFilePromiseMime
getter_AddRefs
(
fileDataPrimitive
)
&
dataSize
)
;
if
(
NS_FAILED
(
rv
)
)
return
cantGetFlavorErr
;
nsCOMPtr
<
nsILocalFile
>
resultFile
=
do_QueryInterface
(
fileDataPrimitive
)
;
if
(
resultFile
)
return
SetDropFileInDrag
(
inDragRef
inItemIndex
inFlavor
resultFile
)
;
return
cantGetFlavorErr
;
}
else
if
(
strcmp
(
actualFlavor
kNativeImageMime
)
=
=
0
)
{
PRUint32
dataSize
=
0
;
nsCOMPtr
<
nsISupports
>
transferSupports
;
rv
=
item
-
>
GetTransferData
(
actualFlavor
getter_AddRefs
(
transferSupports
)
&
dataSize
)
;
if
(
NS_FAILED
(
rv
)
)
return
cantGetFlavorErr
;
nsCOMPtr
<
nsISupportsInterfacePointer
>
ptrPrimitive
(
do_QueryInterface
(
transferSupports
)
)
;
if
(
!
ptrPrimitive
)
return
cantGetFlavorErr
;
nsCOMPtr
<
nsISupports
>
primitiveData
;
ptrPrimitive
-
>
GetData
(
getter_AddRefs
(
primitiveData
)
)
;
#
ifndef
MOZ_CAIRO_GFX
nsCOMPtr
<
nsIImageMac
>
image
=
do_QueryInterface
(
primitiveData
)
;
if
(
!
image
)
return
cantGetFlavorErr
;
PicHandle
picture
=
nsnull
;
image
-
>
ConvertToPICT
(
&
picture
)
;
if
(
!
picture
)
return
cantGetFlavorErr
;
PRInt32
pictSize
=
:
:
GetHandleSize
(
(
Handle
)
picture
)
;
char
*
pictData
=
nsnull
;
if
(
pictSize
>
0
)
pictData
=
(
char
*
)
nsMemory
:
:
Alloc
(
pictSize
)
;
if
(
pictData
)
{
:
:
BlockMoveData
(
*
picture
pictData
pictSize
)
;
*
outData
=
(
void
*
)
pictData
;
*
outDataSize
=
pictSize
;
retVal
=
noErr
;
}
else
retVal
=
cantGetFlavorErr
;
:
:
KillPicture
(
picture
)
;
#
else
retVal
=
cantGetFlavorErr
;
#
endif
return
retVal
;
}
nsCOMPtr
<
nsISupports
>
data
;
if
(
NS_SUCCEEDED
(
item
-
>
GetTransferData
(
actualFlavor
getter_AddRefs
(
data
)
outDataSize
)
)
)
{
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
actualFlavor
data
outData
*
outDataSize
)
;
PRUnichar
*
castedUnicode
=
NS_REINTERPRET_CAST
(
PRUnichar
*
*
outData
)
;
nsLinebreakConverter
:
:
ConvertUnicharLineBreaksInSitu
(
&
castedUnicode
nsLinebreakConverter
:
:
eLinebreakUnix
nsLinebreakConverter
:
:
eLinebreakMac
*
outDataSize
/
sizeof
(
PRUnichar
)
nsnull
)
;
if
(
needToDoConversionToPlainText
)
{
char
*
plainTextData
=
nsnull
;
PRInt32
plainTextLen
=
0
;
nsresult
rv
=
nsPrimitiveHelpers
:
:
ConvertUnicodeToPlatformPlainText
(
castedUnicode
*
outDataSize
/
2
&
plainTextData
&
plainTextLen
)
;
ScriptCodeRun
*
scriptCodeRuns
=
nsnull
;
PRInt32
scriptRunOutLen
;
if
(
rv
=
=
NS_ERROR_UENC_NOMAPPING
)
{
if
(
plainTextData
)
{
nsMemory
:
:
Free
(
plainTextData
)
;
plainTextData
=
nsnull
;
}
rv
=
nsMacNativeUnicodeConverter
:
:
ConvertUnicodetoScript
(
castedUnicode
*
outDataSize
/
sizeof
(
PRUnichar
)
&
plainTextData
&
plainTextLen
&
scriptCodeRuns
&
scriptRunOutLen
)
;
}
else
if
(
NS_SUCCEEDED
(
rv
)
)
{
scriptCodeRuns
=
NS_REINTERPRET_CAST
(
ScriptCodeRun
*
nsMemory
:
:
Alloc
(
sizeof
(
ScriptCodeRun
)
)
)
;
if
(
scriptCodeRuns
)
{
scriptCodeRuns
[
0
]
.
offset
=
0
;
scriptCodeRuns
[
0
]
.
script
=
(
ScriptCode
)
:
:
GetScriptManagerVariable
(
smSysScript
)
;
scriptRunOutLen
=
1
;
}
}
if
(
plainTextData
&
&
*
outData
)
{
nsMemory
:
:
Free
(
*
outData
)
;
*
outData
=
nsnull
;
*
outDataSize
=
0
;
if
(
inFlavor
!
=
'
styl
'
)
{
*
outData
=
plainTextData
;
*
outDataSize
=
plainTextLen
;
}
else
{
nsMemory
:
:
Free
(
plainTextData
)
;
char
*
stylData
;
PRInt32
stylLen
;
if
(
scriptCodeRuns
)
{
rv
=
CreateStylFromScriptRuns
(
scriptCodeRuns
scriptRunOutLen
&
stylData
&
stylLen
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
outData
=
stylData
;
*
outDataSize
=
stylLen
;
}
}
}
}
else
retVal
=
cantGetFlavorErr
;
if
(
scriptCodeRuns
)
nsMemory
:
:
Free
(
scriptCodeRuns
)
;
}
}
return
retVal
;
}
char
*
nsDragService
:
:
LookupMimeMappingsForItem
(
DragReference
inDragRef
ItemReference
inItemRef
)
{
char
*
mapperData
=
nsnull
;
PRUint32
mapperSize
=
0
;
ExtractDataFromOS
(
inDragRef
inItemRef
nsMimeMapperMac
:
:
MappingFlavor
(
)
(
void
*
*
)
&
mapperData
&
mapperSize
)
;
return
mapperData
;
#
if
0
OSErr
err
=
:
:
GetFlavorDataSize
(
inDragRef
itemRef
nsMimeMapperMac
:
:
MappingFlavor
(
)
&
mapperSize
)
;
if
(
!
err
&
&
mapperSize
>
0
)
{
mapperData
=
NS_REINTERPRET_CAST
(
char
*
nsMemory
:
:
Alloc
(
mapperSize
+
1
)
)
;
if
(
!
mapperData
)
return
nsnull
;
err
=
:
:
GetFlavorData
(
inDragRef
itemRef
nsMimeMapperMac
:
:
MappingFlavor
(
)
mapperData
&
mapperSize
0
)
;
if
(
err
)
{
#
ifdef
NS_DEBUG
printf
(
"
nsDragService
:
Error
getting
data
out
of
drag
manager
for
mime
mapper
#
%
ld
\
n
"
err
)
;
#
endif
return
nsnull
;
}
else
mapperData
[
mapperSize
]
=
'
\
0
'
;
}
return
mapperData
;
#
endif
}
nsresult
nsDragService
:
:
ExtractDataFromOS
(
DragReference
inDragRef
ItemReference
inItemRef
ResType
inFlavor
void
*
*
outBuffer
PRUint32
*
outBuffSize
)
{
if
(
!
outBuffer
|
|
!
outBuffSize
|
|
!
inFlavor
)
return
NS_ERROR_FAILURE
;
nsresult
retval
=
NS_OK
;
char
*
buff
=
nsnull
;
Size
buffSize
=
0
;
OSErr
err
=
:
:
GetFlavorDataSize
(
inDragRef
inItemRef
inFlavor
&
buffSize
)
;
if
(
!
err
&
&
buffSize
>
0
)
{
buff
=
NS_REINTERPRET_CAST
(
char
*
nsMemory
:
:
Alloc
(
buffSize
+
1
)
)
;
if
(
buff
)
{
err
=
:
:
GetFlavorData
(
inDragRef
inItemRef
inFlavor
buff
&
buffSize
0
)
;
if
(
err
=
=
noErr
)
{
if
(
(
inFlavor
&
kPrivateFlavorMask
)
=
=
kPrivateFlavorTag
)
{
nsCOMPtr
<
nsIMacUtils
>
macUtils
=
do_GetService
(
"
mozilla
.
org
/
xpcom
/
mac
-
utils
;
1
"
)
;
PRBool
isTranslated
;
if
(
macUtils
&
&
NS_SUCCEEDED
(
macUtils
-
>
GetIsTranslated
(
&
isTranslated
)
)
&
&
isTranslated
)
{
char
*
swappedData
=
(
char
*
)
nsMemory
:
:
Alloc
(
buffSize
)
;
if
(
!
swappedData
)
retval
=
NS_ERROR_OUT_OF_MEMORY
;
else
{
swab
(
buff
swappedData
buffSize
)
;
nsMemory
:
:
Free
(
buff
)
;
buff
=
swappedData
;
}
}
}
}
else
{
#
ifdef
NS_DEBUG
printf
(
"
nsDragService
:
Error
getting
data
out
of
drag
manager
#
%
d
\
n
"
err
)
;
#
endif
retval
=
NS_ERROR_FAILURE
;
}
}
else
retval
=
NS_ERROR_FAILURE
;
}
if
(
NS_FAILED
(
retval
)
)
{
if
(
buff
)
nsMemory
:
:
Free
(
buff
)
;
}
else
{
*
outBuffer
=
buff
;
*
outBuffSize
=
buffSize
;
}
return
retval
;
}
NS_IMETHODIMP
nsDragService
:
:
SetDragAction
(
PRUint32
anAction
)
{
const
PRInt32
kCopyCursorID
=
144
;
const
PRInt32
kLinkCursorID
=
145
;
if
(
anAction
=
=
mDragAction
)
return
NS_OK
;
CursHandle
newCursor
=
nsnull
;
if
(
anAction
=
=
DRAGDROP_ACTION_COPY
)
newCursor
=
:
:
GetCursor
(
kCopyCursorID
)
;
else
if
(
anAction
=
=
DRAGDROP_ACTION_LINK
)
newCursor
=
:
:
GetCursor
(
kLinkCursorID
)
;
if
(
newCursor
)
{
:
:
HLock
(
(
Handle
)
newCursor
)
;
:
:
SetCursor
(
*
newCursor
)
;
:
:
HUnlock
(
(
Handle
)
newCursor
)
;
}
else
:
:
InitCursor
(
)
;
return
nsBaseDragService
:
:
SetDragAction
(
anAction
)
;
}
#
pragma
mark
-
static
OSErr
GetDropDirectory
(
DragReference
dragRef
FSSpecPtr
fssOut
)
{
OSErr
err
;
AEDesc
dropLocAlias
=
{
typeNull
nil
}
;
err
=
:
:
GetDropLocation
(
dragRef
&
dropLocAlias
)
;
if
(
err
!
=
noErr
)
return
err
;
if
(
dropLocAlias
.
descriptorType
!
=
typeAlias
)
return
paramErr
;
AEDesc
dropLocFSS
=
{
typeNull
nil
}
;
if
(
(
err
=
:
:
AECoerceDesc
(
&
dropLocAlias
typeFSS
&
dropLocFSS
)
)
=
=
noErr
)
{
err
=
:
:
AEGetDescData
(
&
dropLocFSS
fssOut
sizeof
(
FSSpec
)
)
;
(
void
)
:
:
AEDisposeDesc
(
&
dropLocFSS
)
;
}
if
(
dropLocAlias
.
dataHandle
)
(
void
)
:
:
AEDisposeDesc
(
&
dropLocAlias
)
;
return
err
;
}
OSErr
nsDragService
:
:
GetHFSPromiseDropDirectory
(
DragReference
inDragRef
unsigned
int
inItemIndex
FlavorType
inFlavor
nsILocalFile
*
*
outDir
)
{
PromiseHFSFlavor
promiseData
;
Size
dataSize
=
sizeof
(
promiseData
)
;
OSErr
err
=
:
:
GetFlavorData
(
inDragRef
inItemIndex
kDragFlavorTypePromiseHFS
&
promiseData
&
dataSize
0
)
;
if
(
err
!
=
noErr
)
return
err
;
FSSpec
dropLocation
;
err
=
GetDropDirectory
(
inDragRef
&
dropLocation
)
;
if
(
err
!
=
noErr
)
return
err
;
nsCOMPtr
<
nsILocalFileMac
>
dropFolderSpec
;
nsresult
rv
=
NS_NewLocalFileWithFSSpec
(
&
dropLocation
PR_FALSE
getter_AddRefs
(
dropFolderSpec
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
fnfErr
;
CallQueryInterface
(
dropFolderSpec
outDir
)
;
return
noErr
;
}
OSErr
nsDragService
:
:
SetDropFileInDrag
(
DragReference
inDragRef
unsigned
int
inItemIndex
FlavorType
inFlavor
nsILocalFile
*
inFile
)
{
nsCOMPtr
<
nsILocalFileMac
>
targetFileMac
=
do_QueryInterface
(
inFile
)
;
if
(
!
targetFileMac
)
return
paramErr
;
FSSpec
targetFileSpec
;
nsresult
rv
=
targetFileMac
-
>
GetFSSpec
(
&
targetFileSpec
)
;
if
(
NS_FAILED
(
rv
)
)
return
paramErr
;
return
:
:
SetDragItemFlavorData
(
inDragRef
inItemIndex
inFlavor
&
targetFileSpec
sizeof
(
FSSpec
)
0
)
;
}
