#
include
"
nsMacEventHandler
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsMacWindow
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
prinrval
.
h
"
#
include
<
ToolUtils
.
h
>
#
include
<
TextServices
.
h
>
#
include
<
UnicodeConverter
.
h
>
#
include
"
nsCarbonHelpers
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIMenuRollup
.
h
"
#
include
"
nsGfxUtils
.
h
"
static
nsMacEventHandler
*
sLastActive
;
extern
nsIRollupListener
*
gRollupListener
;
extern
nsIWidget
*
gRollupWidget
;
#
ifndef
topLeft
#
define
topLeft
(
r
)
(
(
(
Point
*
)
&
(
r
)
)
[
0
]
)
#
endif
#
ifndef
botRight
#
define
botRight
(
r
)
(
(
(
Point
*
)
&
(
r
)
)
[
1
]
)
#
endif
static
void
ConvertKeyEventToContextMenuEvent
(
const
nsKeyEvent
*
inKeyEvent
nsMouseEvent
*
outCMEvent
)
;
static
inline
PRBool
IsContextMenuKey
(
const
nsKeyEvent
&
inKeyEvent
)
;
nsMacEventDispatchHandler
:
:
nsMacEventDispatchHandler
(
)
{
mActiveWidget
=
nsnull
;
mWidgetHit
=
nsnull
;
mWidgetPointed
=
nsnull
;
#
if
TRACK_MOUSE_LOC
mLastGlobalMouseLoc
.
h
=
mLastGlobalMouseLoc
.
v
=
0
;
#
endif
}
nsMacEventDispatchHandler
:
:
~
nsMacEventDispatchHandler
(
)
{
if
(
mActiveWidget
)
{
mActiveWidget
-
>
RemoveDeleteObserver
(
this
)
;
mActiveWidget
=
nsnull
;
}
if
(
mWidgetHit
)
{
mWidgetHit
-
>
RemoveDeleteObserver
(
this
)
;
mWidgetHit
=
nsnull
;
}
if
(
mWidgetPointed
)
{
mWidgetPointed
-
>
RemoveDeleteObserver
(
this
)
;
mWidgetPointed
=
nsnull
;
}
}
void
nsMacEventDispatchHandler
:
:
DispatchGuiEvent
(
nsWindow
*
aWidget
PRUint32
aEventType
)
{
NS_ASSERTION
(
aWidget
"
attempted
to
dispatch
gui
event
to
null
widget
"
)
;
if
(
!
aWidget
)
return
;
nsGUIEvent
guiEvent
(
PR_TRUE
aEventType
aWidget
)
;
guiEvent
.
time
=
PR_IntervalNow
(
)
;
aWidget
-
>
DispatchWindowEvent
(
guiEvent
)
;
}
void
nsMacEventDispatchHandler
:
:
DispatchSizeModeEvent
(
nsWindow
*
aWidget
nsSizeMode
aMode
)
{
NS_ASSERTION
(
aWidget
"
attempted
to
dispatch
gui
event
to
null
widget
"
)
;
if
(
!
aWidget
)
return
;
nsSizeModeEvent
event
(
PR_TRUE
NS_SIZEMODE
aWidget
)
;
event
.
time
=
PR_IntervalNow
(
)
;
event
.
mSizeMode
=
aMode
;
aWidget
-
>
DispatchWindowEvent
(
event
)
;
}
void
nsMacEventDispatchHandler
:
:
SetFocus
(
nsWindow
*
aFocusedWidget
)
{
if
(
aFocusedWidget
=
=
mActiveWidget
)
return
;
if
(
mActiveWidget
)
{
mActiveWidget
-
>
ResetInputState
(
)
;
mActiveWidget
-
>
RemoveDeleteObserver
(
this
)
;
DispatchGuiEvent
(
mActiveWidget
NS_LOSTFOCUS
)
;
}
mActiveWidget
=
aFocusedWidget
;
if
(
mActiveWidget
)
{
mActiveWidget
-
>
AddDeleteObserver
(
this
)
;
DispatchGuiEvent
(
mActiveWidget
NS_GOTFOCUS
)
;
}
}
void
nsMacEventDispatchHandler
:
:
SetActivated
(
nsWindow
*
aActivatedWidget
)
{
if
(
aActivatedWidget
=
=
mActiveWidget
)
{
return
;
}
if
(
aActivatedWidget
)
{
nsWindowType
wtype
;
aActivatedWidget
-
>
GetWindowType
(
wtype
)
;
if
(
eWindowType_popup
=
=
wtype
)
{
return
;
}
}
if
(
mActiveWidget
)
{
mActiveWidget
-
>
ResetInputState
(
)
;
mActiveWidget
-
>
RemoveDeleteObserver
(
this
)
;
DispatchGuiEvent
(
mActiveWidget
NS_LOSTFOCUS
)
;
}
mActiveWidget
=
aActivatedWidget
;
if
(
mActiveWidget
)
{
mActiveWidget
-
>
AddDeleteObserver
(
this
)
;
DispatchGuiEvent
(
mActiveWidget
NS_GOTFOCUS
)
;
DispatchGuiEvent
(
mActiveWidget
NS_ACTIVATE
)
;
}
}
void
nsMacEventDispatchHandler
:
:
SetDeactivated
(
nsWindow
*
aDeactivatedWidget
)
{
if
(
aDeactivatedWidget
)
{
nsWindowType
wtype
;
aDeactivatedWidget
-
>
GetWindowType
(
wtype
)
;
if
(
eWindowType_popup
=
=
wtype
)
{
return
;
}
}
if
(
mActiveWidget
)
{
nsCOMPtr
<
nsIWidget
>
curWin
=
do_QueryInterface
(
NS_STATIC_CAST
(
nsIWidget
*
mActiveWidget
)
)
;
for
(
;
;
)
{
nsIWidget
*
parent
=
curWin
-
>
GetParent
(
)
;
if
(
!
parent
)
break
;
curWin
=
parent
;
}
if
(
NS_STATIC_CAST
(
nsWindow
*
NS_STATIC_CAST
(
nsIWidget
*
curWin
)
)
=
=
aDeactivatedWidget
)
{
mActiveWidget
-
>
RemoveDeleteObserver
(
this
)
;
mActiveWidget
=
nsnull
;
}
}
DispatchGuiEvent
(
aDeactivatedWidget
NS_DEACTIVATE
)
;
}
void
nsMacEventDispatchHandler
:
:
SetWidgetHit
(
nsWindow
*
aWidgetHit
)
{
if
(
aWidgetHit
=
=
mWidgetHit
)
return
;
if
(
mWidgetHit
)
if
(
!
mWidgetHit
-
>
RemoveDeleteObserver
(
this
)
)
NS_WARNING
(
"
nsMacFocusHandler
wasn
'
t
in
the
WidgetHit
observer
list
"
)
;
mWidgetHit
=
aWidgetHit
;
if
(
mWidgetHit
)
mWidgetHit
-
>
AddDeleteObserver
(
this
)
;
}
void
nsMacEventDispatchHandler
:
:
SetWidgetPointed
(
nsWindow
*
aWidgetPointed
)
{
if
(
aWidgetPointed
=
=
mWidgetPointed
)
{
return
;
}
if
(
mWidgetPointed
)
if
(
!
mWidgetPointed
-
>
RemoveDeleteObserver
(
this
)
)
NS_WARNING
(
"
nsMacFocusHandler
wasn
'
t
in
the
WidgetPointed
observer
list
"
)
;
mWidgetPointed
=
aWidgetPointed
;
if
(
mWidgetPointed
)
mWidgetPointed
-
>
AddDeleteObserver
(
this
)
;
}
void
nsMacEventDispatchHandler
:
:
NotifyDelete
(
void
*
aDeletedObject
)
{
if
(
mActiveWidget
=
=
aDeletedObject
)
mActiveWidget
=
nsnull
;
if
(
mWidgetHit
=
=
aDeletedObject
)
mWidgetHit
=
nsnull
;
if
(
mWidgetPointed
=
=
aDeletedObject
)
mWidgetPointed
=
nsnull
;
}
#
if
TRACK_MOUSE_LOC
void
nsMacEventDispatchHandler
:
:
SetGlobalPoint
(
Point
inPoint
)
{
mLastGlobalMouseLoc
=
inPoint
;
}
#
endif
#
pragma
mark
-
nsMacEventHandler
:
:
nsMacEventHandler
(
nsMacWindow
*
aTopLevelWidget
nsMacEventDispatchHandler
*
aEventDispatchHandler
)
{
OSErr
err
;
InterfaceTypeList
supportedServices
;
mTopLevelWidget
=
aTopLevelWidget
;
mTSMDocument
=
nsnull
;
supportedServices
[
0
]
=
kUnicodeDocument
;
err
=
:
:
NewTSMDocument
(
1
supportedServices
&
mTSMDocument
(
long
)
this
)
;
NS_ASSERTION
(
err
=
=
noErr
"
nsMacEventHandler
:
:
nsMacEventHandler
:
NewTSMDocument
failed
.
"
)
;
#
ifdef
DEBUG_TSM
printf
(
"
nsMacEventHandler
:
:
nsMacEventHandler
:
created
TSMDocument
[
%
p
]
\
n
"
mTSMDocument
)
;
#
endif
if
(
mTSMDocument
)
:
:
UseInputWindow
(
mTSMDocument
FALSE
)
;
mIMEIsComposing
=
PR_FALSE
;
mIMECompositionStr
=
nsnull
;
mKeyIgnore
=
PR_FALSE
;
mKeyHandled
=
PR_FALSE
;
mLastModifierState
=
0
;
mMouseInWidgetHit
=
PR_FALSE
;
ClearLastMouseUp
(
)
;
if
(
aEventDispatchHandler
)
{
mEventDispatchHandler
=
aEventDispatchHandler
;
mOwnEventDispatchHandler
=
PR_FALSE
;
}
else
{
mEventDispatchHandler
=
new
nsMacEventDispatchHandler
(
)
;
mOwnEventDispatchHandler
=
PR_TRUE
;
}
}
nsMacEventHandler
:
:
~
nsMacEventHandler
(
)
{
if
(
mTSMDocument
)
(
void
)
:
:
DeleteTSMDocument
(
mTSMDocument
)
;
if
(
nsnull
!
=
mIMECompositionStr
)
{
delete
mIMECompositionStr
;
mIMECompositionStr
=
nsnull
;
}
if
(
mOwnEventDispatchHandler
)
delete
mEventDispatchHandler
;
if
(
sLastActive
=
=
this
)
{
sLastActive
=
nsnull
;
}
}
#
pragma
mark
-
PRBool
nsMacEventHandler
:
:
HandleOSEvent
(
EventRecord
&
aOSEvent
)
{
PRBool
retVal
=
PR_FALSE
;
switch
(
aOSEvent
.
what
)
{
case
mouseDown
:
retVal
=
HandleMouseDownEvent
(
aOSEvent
)
;
break
;
case
mouseUp
:
retVal
=
HandleMouseUpEvent
(
aOSEvent
)
;
break
;
case
osEvt
:
{
unsigned
char
eventType
=
(
(
aOSEvent
.
message
>
>
24
)
&
0x00ff
)
;
if
(
eventType
=
=
mouseMovedMessage
)
{
retVal
=
HandleMouseMoveEvent
(
aOSEvent
)
;
}
}
break
;
}
return
retVal
;
}
#
if
USE_MENUSELECT
PRBool
nsMacEventHandler
:
:
HandleMenuCommand
(
EventRecord
&
aOSEvent
long
aMenuResult
)
{
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
nsMenuEvent
menuEvent
(
PR_TRUE
NS_MENU_SELECTED
focusedWidget
)
;
menuEvent
.
refPoint
.
x
=
aOSEvent
.
where
.
h
;
menuEvent
.
refPoint
.
y
=
aOSEvent
.
where
.
v
;
menuEvent
.
time
=
PR_IntervalNow
(
)
;
menuEvent
.
nativeMsg
=
(
void
*
)
&
aOSEvent
;
menuEvent
.
mCommand
=
aMenuResult
;
PRBool
eventHandled
=
focusedWidget
-
>
DispatchWindowEvent
(
menuEvent
)
;
if
(
!
eventHandled
)
{
if
(
focusedWidget
=
=
mEventDispatchHandler
-
>
GetActive
(
)
)
{
nsCOMPtr
<
nsIWidget
>
parent
=
focusedWidget
-
>
GetParent
(
)
;
while
(
parent
)
{
menuEvent
.
widget
=
parent
;
eventHandled
=
(
static_cast
<
nsWindow
*
>
(
static_cast
<
nsIWidget
*
>
(
parent
)
)
)
-
>
DispatchWindowEvent
(
menuEvent
)
;
if
(
eventHandled
)
{
break
;
}
else
{
parent
=
parent
-
>
GetParent
(
)
;
}
}
}
}
return
eventHandled
;
}
#
endif
void
nsMacEventHandler
:
:
InitializeMouseEvent
(
nsMouseEvent
&
aMouseEvent
nsPoint
&
aPoint
PRInt16
aModifiers
PRUint32
aClickCount
)
{
aMouseEvent
.
refPoint
=
aPoint
;
aMouseEvent
.
time
=
PR_IntervalNow
(
)
;
aMouseEvent
.
isShift
=
(
(
aModifiers
&
shiftKey
)
!
=
0
)
;
aMouseEvent
.
isControl
=
(
(
aModifiers
&
controlKey
)
!
=
0
)
;
aMouseEvent
.
isAlt
=
(
(
aModifiers
&
optionKey
)
!
=
0
)
;
aMouseEvent
.
isMeta
=
(
(
aModifiers
&
cmdKey
)
!
=
0
)
;
aMouseEvent
.
clickCount
=
aClickCount
;
}
PRBool
nsMacEventHandler
:
:
DragEvent
(
unsigned
int
aMessage
Point
aMouseGlobal
UInt16
aKeyModifiers
)
{
Point
hitPointLocal
=
aMouseGlobal
;
WindowRef
wind
=
NS_STATIC_CAST
(
WindowRef
mTopLevelWidget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
nsGraphicsUtils
:
:
SafeSetPortWindowPort
(
wind
)
;
{
StOriginSetter
originSetter
(
wind
)
;
:
:
GlobalToLocal
(
&
hitPointLocal
)
;
}
nsPoint
widgetHitPoint
(
hitPointLocal
.
h
hitPointLocal
.
v
)
;
nsWindow
*
widgetHit
=
mTopLevelWidget
-
>
FindWidgetHit
(
hitPointLocal
)
;
if
(
widgetHit
)
{
nsRect
bounds
;
widgetHit
-
>
GetBounds
(
bounds
)
;
nsPoint
widgetOrigin
(
bounds
.
x
bounds
.
y
)
;
widgetHit
-
>
LocalToWindowCoordinate
(
widgetOrigin
)
;
widgetHitPoint
.
MoveBy
(
-
widgetOrigin
.
x
-
widgetOrigin
.
y
)
;
}
if
(
aMessage
=
=
NS_DRAGDROP_EXIT
)
{
widgetHit
=
nsnull
;
}
nsWindow
*
lastWidget
=
mEventDispatchHandler
-
>
GetWidgetPointed
(
)
;
if
(
lastWidget
!
=
widgetHit
)
{
if
(
aMessage
!
=
NS_DRAGDROP_ENTER
)
{
if
(
lastWidget
)
{
nsMouseEvent
exitEvent
(
PR_TRUE
NS_DRAGDROP_EXIT
lastWidget
nsMouseEvent
:
:
eReal
)
;
nsPoint
zero
(
0
0
)
;
InitializeMouseEvent
(
exitEvent
zero
aKeyModifiers
1
)
;
lastWidget
-
>
DispatchMouseEvent
(
exitEvent
)
;
}
if
(
aMessage
!
=
NS_DRAGDROP_EXIT
&
&
widgetHit
)
{
nsMouseEvent
enterEvent
(
PR_TRUE
NS_DRAGDROP_ENTER
widgetHit
nsMouseEvent
:
:
eReal
)
;
InitializeMouseEvent
(
enterEvent
widgetHitPoint
aKeyModifiers
1
)
;
widgetHit
-
>
DispatchMouseEvent
(
enterEvent
)
;
}
}
}
mEventDispatchHandler
-
>
SetWidgetPointed
(
widgetHit
)
;
if
(
!
widgetHit
)
{
return
PR_TRUE
;
}
nsMouseEvent
geckoEvent
(
PR_TRUE
aMessage
widgetHit
nsMouseEvent
:
:
eReal
)
;
InitializeMouseEvent
(
geckoEvent
widgetHitPoint
aKeyModifiers
1
)
;
widgetHit
-
>
DispatchMouseEvent
(
geckoEvent
)
;
return
PR_TRUE
;
}
#
pragma
mark
-
enum
{
kEscapeKeyCode
=
0x35
kCommandKeyCode
=
0x37
kShiftKeyCode
=
0x38
kCapsLockKeyCode
=
0x39
kControlKeyCode
=
0x3B
kOptionkeyCode
=
0x3A
kClearKeyCode
=
0x47
kF1KeyCode
=
0x7A
kF2KeyCode
=
0x78
kF3KeyCode
=
0x63
kF4KeyCode
=
0x76
kF5KeyCode
=
0x60
kF6KeyCode
=
0x61
kF7KeyCode
=
0x62
kF8KeyCode
=
0x64
kF9KeyCode
=
0x65
kF10KeyCode
=
0x6D
kF11KeyCode
=
0x67
kF12KeyCode
=
0x6F
kF13KeyCode
=
0x69
kF14KeyCode
=
0x6B
kF15KeyCode
=
0x71
kPrintScreenKeyCode
=
kF13KeyCode
kScrollLockKeyCode
=
kF14KeyCode
kPauseKeyCode
=
kF15KeyCode
kKeypad0KeyCode
=
0x52
kKeypad1KeyCode
=
0x53
kKeypad2KeyCode
=
0x54
kKeypad3KeyCode
=
0x55
kKeypad4KeyCode
=
0x56
kKeypad5KeyCode
=
0x57
kKeypad6KeyCode
=
0x58
kKeypad7KeyCode
=
0x59
kKeypad8KeyCode
=
0x5B
kKeypad9KeyCode
=
0x5C
kKeypadMultiplyKeyCode
=
0x43
kKeypadAddKeyCode
=
0x45
kKeypadSubtractKeyCode
=
0x4E
kKeypadDecimalKeyCode
=
0x41
kKeypadDivideKeyCode
=
0x4B
kKeypadEqualsKeyCode
=
0x51
kEnterKeyCode
=
0x4C
kReturnKeyCode
=
0x24
kPowerbookEnterKeyCode
=
0x34
kHelpKeyCode
=
0x72
kDeleteKeyCode
=
0x75
kTabKeyCode
=
0x30
kBackspaceKeyCode
=
0x33
kHomeKeyCode
=
0x73
kEndKeyCode
=
0x77
kPageUpKeyCode
=
0x74
kPageDownKeyCode
=
0x79
kLeftArrowKeyCode
=
0x7B
kRightArrowKeyCode
=
0x7C
kUpArrowKeyCode
=
0x7E
kDownArrowKeyCode
=
0x7D
}
;
static
PRUint32
ConvertMacToRaptorKeyCode
(
char
charCode
UInt32
keyCode
UInt32
eventModifiers
)
{
PRUint32
raptorKeyCode
=
0
;
switch
(
keyCode
)
{
case
kShiftKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_SHIFT
;
break
;
case
kCommandKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_META
;
break
;
case
kCapsLockKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_CAPS_LOCK
;
break
;
case
kControlKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_CONTROL
;
break
;
case
kOptionkeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_ALT
;
break
;
case
kF1KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F1
;
break
;
case
kF2KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F2
;
break
;
case
kF3KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F3
;
break
;
case
kF4KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F4
;
break
;
case
kF5KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F5
;
break
;
case
kF6KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F6
;
break
;
case
kF7KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F7
;
break
;
case
kF8KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F8
;
break
;
case
kF9KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F9
;
break
;
case
kF10KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F10
;
break
;
case
kF11KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F11
;
break
;
case
kF12KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_F12
;
break
;
case
kPauseKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_PAUSE
;
break
;
case
kScrollLockKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_SCROLL_LOCK
;
break
;
case
kPrintScreenKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_PRINTSCREEN
;
break
;
case
kKeypad0KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD0
;
break
;
case
kKeypad1KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD1
;
break
;
case
kKeypad2KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD2
;
break
;
case
kKeypad3KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD3
;
break
;
case
kKeypad4KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD4
;
break
;
case
kKeypad5KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD5
;
break
;
case
kKeypad6KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD6
;
break
;
case
kKeypad7KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD7
;
break
;
case
kKeypad8KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD8
;
break
;
case
kKeypad9KeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_NUMPAD9
;
break
;
case
kKeypadMultiplyKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_MULTIPLY
;
break
;
case
kKeypadAddKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_ADD
;
break
;
case
kKeypadSubtractKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_SUBTRACT
;
break
;
case
kKeypadDecimalKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_DECIMAL
;
break
;
case
kKeypadDivideKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_DIVIDE
;
break
;
case
kHelpKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_HELP
;
break
;
case
kDeleteKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_DELETE
;
break
;
case
kEscapeKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_ESCAPE
;
break
;
case
kClearKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_CLEAR
;
break
;
case
kBackspaceKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_BACK_SPACE
;
break
;
case
kTabKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_TAB
;
break
;
case
kHomeKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_HOME
;
break
;
case
kEndKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_END
;
break
;
case
kPageUpKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_PAGE_UP
;
break
;
case
kPageDownKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_PAGE_DOWN
;
break
;
case
kLeftArrowKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_LEFT
;
break
;
case
kRightArrowKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_RIGHT
;
break
;
case
kUpArrowKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_UP
;
break
;
case
kDownArrowKeyCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_DOWN
;
break
;
default
:
if
(
(
eventModifiers
&
controlKey
)
!
=
0
)
charCode
+
=
64
;
switch
(
charCode
)
{
case
kReturnCharCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_RETURN
;
break
;
case
kEnterCharCode
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_RETURN
;
break
;
case
'
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_SPACE
;
break
;
case
'
;
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_SEMICOLON
;
break
;
case
'
=
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_EQUALS
;
break
;
case
'
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_COMMA
;
break
;
case
'
.
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_PERIOD
;
break
;
case
'
/
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_SLASH
;
break
;
case
'
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_BACK_QUOTE
;
break
;
case
'
{
'
:
case
'
[
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_OPEN_BRACKET
;
break
;
case
'
\
\
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_BACK_SLASH
;
break
;
case
'
}
'
:
case
'
]
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_CLOSE_BRACKET
;
break
;
case
'
\
'
'
:
case
'
"
'
:
raptorKeyCode
=
nsIDOMKeyEvent
:
:
DOM_VK_QUOTE
;
break
;
default
:
if
(
charCode
>
=
'
0
'
&
&
charCode
<
=
'
9
'
)
{
raptorKeyCode
=
charCode
;
}
else
if
(
charCode
>
=
'
a
'
&
&
charCode
<
=
'
z
'
)
{
raptorKeyCode
=
toupper
(
charCode
)
;
}
else
if
(
charCode
>
=
'
A
'
&
&
charCode
<
=
'
Z
'
)
{
raptorKeyCode
=
charCode
;
}
break
;
}
}
return
raptorKeyCode
;
}
void
nsMacEventHandler
:
:
InitializeKeyEvent
(
nsKeyEvent
&
aKeyEvent
EventRecord
&
aOSEvent
nsWindow
*
aFocusedWidget
PRUint32
aMessage
PRBool
aConvertChar
)
{
aKeyEvent
.
time
=
PR_IntervalNow
(
)
;
aKeyEvent
.
widget
=
aFocusedWidget
;
aKeyEvent
.
nativeMsg
=
(
void
*
)
&
aOSEvent
;
aKeyEvent
.
isShift
=
(
(
aOSEvent
.
modifiers
&
shiftKey
)
!
=
0
)
;
aKeyEvent
.
isControl
=
(
(
aOSEvent
.
modifiers
&
controlKey
)
!
=
0
)
;
aKeyEvent
.
isAlt
=
(
(
aOSEvent
.
modifiers
&
optionKey
)
!
=
0
)
;
aKeyEvent
.
isMeta
=
(
(
aOSEvent
.
modifiers
&
cmdKey
)
!
=
0
)
;
if
(
aMessage
=
=
NS_KEY_PRESS
&
&
!
IsSpecialRaptorKey
(
(
aOSEvent
.
message
&
keyCodeMask
)
>
>
8
)
)
{
if
(
aKeyEvent
.
isControl
)
{
if
(
aConvertChar
)
{
aKeyEvent
.
charCode
=
(
aOSEvent
.
message
&
charCodeMask
)
;
if
(
aKeyEvent
.
charCode
<
=
26
)
{
if
(
aKeyEvent
.
isShift
)
aKeyEvent
.
charCode
+
=
'
A
'
-
1
;
else
aKeyEvent
.
charCode
+
=
'
a
'
-
1
;
}
}
aKeyEvent
.
keyCode
=
0
;
}
else
{
if
(
!
aKeyEvent
.
isMeta
)
{
aKeyEvent
.
isControl
=
aKeyEvent
.
isAlt
=
aKeyEvent
.
isMeta
=
0
;
}
aKeyEvent
.
keyCode
=
0
;
if
(
aConvertChar
)
{
aKeyEvent
.
charCode
=
ConvertKeyEventToUnicode
(
aOSEvent
)
;
if
(
aKeyEvent
.
isShift
&
&
aKeyEvent
.
charCode
<
=
'
z
'
&
&
aKeyEvent
.
charCode
>
=
'
a
'
)
{
aKeyEvent
.
charCode
-
=
32
;
}
NS_ASSERTION
(
0
!
=
aKeyEvent
.
charCode
"
nsMacEventHandler
:
:
InitializeKeyEvent
:
ConvertKeyEventToUnicode
returned
0
.
"
)
;
}
}
}
else
{
aKeyEvent
.
keyCode
=
ConvertMacToRaptorKeyCode
(
aOSEvent
.
message
&
charCodeMask
(
aOSEvent
.
message
&
keyCodeMask
)
>
>
8
aOSEvent
.
modifiers
)
;
aKeyEvent
.
charCode
=
0
;
}
if
(
aMessage
=
=
NS_KEY_PRESS
&
&
!
aKeyEvent
.
isMeta
&
&
aKeyEvent
.
keyCode
!
=
nsIDOMKeyEvent
:
:
DOM_VK_PAGE_UP
&
&
aKeyEvent
.
keyCode
!
=
nsIDOMKeyEvent
:
:
DOM_VK_PAGE_DOWN
)
{
:
:
ObscureCursor
(
)
;
}
}
PRBool
nsMacEventHandler
:
:
IsSpecialRaptorKey
(
UInt32
macKeyCode
)
{
PRBool
isSpecial
;
switch
(
macKeyCode
)
{
case
kEscapeKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kShiftKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kCommandKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kCapsLockKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kControlKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kOptionkeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kClearKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF1KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF2KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF3KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF4KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF5KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF6KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF7KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF8KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF9KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF10KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF11KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kF12KeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kPauseKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kScrollLockKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kPrintScreenKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kHelpKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kDeleteKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kTabKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kBackspaceKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kHomeKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kEndKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kPageUpKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kPageDownKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kLeftArrowKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kRightArrowKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kUpArrowKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kDownArrowKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kReturnKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kEnterKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
case
kPowerbookEnterKeyCode
:
isSpecial
=
PR_TRUE
;
break
;
default
:
isSpecial
=
PR_FALSE
;
break
;
}
return
isSpecial
;
}
#
define
UNICODE_BUFFER_SIZE_FOR_KEY
5
PRUint32
nsMacEventHandler
:
:
ConvertKeyEventToUnicode
(
EventRecord
&
aOSEvent
)
{
char
charResult
=
aOSEvent
.
message
&
charCodeMask
;
ScriptCode
textScript
=
(
ScriptCode
)
GetScriptManagerVariable
(
smKeyScript
)
;
TextEncoding
textEncodingFromScript
;
OSErr
err
=
:
:
UpgradeScriptInfoToTextEncoding
(
textScript
kTextLanguageDontCare
kTextRegionDontCare
nsnull
&
textEncodingFromScript
)
;
NS_ASSERTION
(
err
=
=
noErr
"
nsMacEventHandler
:
:
ConvertKeyEventToUnicode
:
UpgradeScriptInfoToTextEncoding
failed
.
"
)
;
if
(
err
!
=
noErr
)
return
0
;
TextToUnicodeInfo
textToUnicodeInfo
;
err
=
:
:
CreateTextToUnicodeInfoByEncoding
(
textEncodingFromScript
&
textToUnicodeInfo
)
;
NS_ASSERTION
(
err
=
=
noErr
"
nsMacEventHandler
:
:
ConvertKeyEventToUnicode
:
CreateUnicodeToTextInfoByEncoding
failed
.
"
)
;
if
(
err
!
=
noErr
)
return
0
;
ByteCount
result_size
source_read
;
PRUnichar
unicharResult
[
UNICODE_BUFFER_SIZE_FOR_KEY
]
;
err
=
:
:
ConvertFromTextToUnicode
(
textToUnicodeInfo
sizeof
(
char
)
&
charResult
kUnicodeLooseMappingsMask
0
NULL
NULL
NULL
sizeof
(
PRUnichar
)
*
UNICODE_BUFFER_SIZE_FOR_KEY
&
source_read
&
result_size
NS_REINTERPRET_CAST
(
PRUint16
*
unicharResult
)
)
;
:
:
DisposeTextToUnicodeInfo
(
&
textToUnicodeInfo
)
;
NS_ASSERTION
(
err
=
=
noErr
"
nsMacEventHandler
:
:
ConvertKeyEventToUnicode
:
ConverFromTextToUnicode
failed
.
"
)
;
NS_ASSERTION
(
result_size
=
=
2
"
nsMacEventHandler
:
:
ConvertKeyEventToUnicode
:
ConverFromTextToUnicode
failed
.
"
)
;
return
unicharResult
[
0
]
;
}
static
void
ConvertKeyEventToContextMenuEvent
(
const
nsKeyEvent
*
inKeyEvent
nsMouseEvent
*
outCMEvent
)
{
*
(
nsInputEvent
*
)
outCMEvent
=
*
(
nsInputEvent
*
)
inKeyEvent
;
outCMEvent
-
>
eventStructType
=
NS_MOUSE_EVENT
;
outCMEvent
-
>
message
=
NS_CONTEXTMENU
;
outCMEvent
-
>
context
=
nsMouseEvent
:
:
eContextMenuKey
;
outCMEvent
-
>
button
=
nsMouseEvent
:
:
eRightButton
;
outCMEvent
-
>
isShift
=
outCMEvent
-
>
isControl
=
outCMEvent
-
>
isAlt
=
outCMEvent
-
>
isMeta
=
PR_FALSE
;
outCMEvent
-
>
clickCount
=
0
;
outCMEvent
-
>
acceptActivation
=
PR_FALSE
;
}
static
inline
PRBool
IsContextMenuKey
(
const
nsKeyEvent
&
inKeyEvent
)
{
enum
{
kContextMenuKey
=
'
'
}
;
return
(
inKeyEvent
.
charCode
=
=
kContextMenuKey
&
&
inKeyEvent
.
isControl
&
&
!
inKeyEvent
.
isShift
&
&
!
inKeyEvent
.
isMeta
&
&
!
inKeyEvent
.
isAlt
)
;
}
PRBool
nsMacEventHandler
:
:
HandleUKeyEvent
(
const
PRUnichar
*
text
long
charCount
EventRecord
&
aOSEvent
)
{
ClearLastMouseUp
(
)
;
if
(
mKeyIgnore
)
return
PR_FALSE
;
PRBool
handled
=
PR_FALSE
;
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
if
(
!
IsSpecialRaptorKey
(
(
aOSEvent
.
message
&
keyCodeMask
)
>
>
8
)
)
{
PRInt32
i
;
for
(
i
=
0
;
i
<
charCount
;
i
+
+
)
{
nsKeyEvent
keyPressEvent
(
PR_TRUE
NS_KEY_PRESS
nsnull
)
;
InitializeKeyEvent
(
keyPressEvent
aOSEvent
focusedWidget
NS_KEY_PRESS
PR_FALSE
)
;
keyPressEvent
.
charCode
=
text
[
i
]
;
if
(
mKeyHandled
)
keyPressEvent
.
flags
|
=
NS_EVENT_FLAG_NO_DEFAULT
;
if
(
keyPressEvent
.
isControl
&
&
keyPressEvent
.
charCode
<
=
26
)
{
if
(
keyPressEvent
.
isShift
)
keyPressEvent
.
charCode
+
=
'
A
'
-
1
;
else
keyPressEvent
.
charCode
+
=
'
a
'
-
1
;
}
if
(
keyPressEvent
.
isShift
&
&
keyPressEvent
.
charCode
<
=
'
z
'
&
&
keyPressEvent
.
charCode
>
=
'
a
'
)
keyPressEvent
.
charCode
-
=
32
;
if
(
IsContextMenuKey
(
keyPressEvent
)
)
{
nsMouseEvent
contextMenuEvent
(
PR_TRUE
0
nsnull
nsMouseEvent
:
:
eReal
)
;
ConvertKeyEventToContextMenuEvent
(
&
keyPressEvent
&
contextMenuEvent
)
;
handled
|
=
focusedWidget
-
>
DispatchWindowEvent
(
contextMenuEvent
)
;
}
else
{
handled
|
=
focusedWidget
-
>
DispatchWindowEvent
(
keyPressEvent
)
;
}
}
}
else
{
nsKeyEvent
keyPressEvent
(
PR_TRUE
NS_KEY_PRESS
nsnull
)
;
InitializeKeyEvent
(
keyPressEvent
aOSEvent
focusedWidget
NS_KEY_PRESS
PR_FALSE
)
;
handled
=
focusedWidget
-
>
DispatchWindowEvent
(
keyPressEvent
)
;
}
return
handled
;
}
#
pragma
mark
-
void
nsMacEventHandler
:
:
HandleActivateEvent
(
EventRef
aEvent
)
{
ClearLastMouseUp
(
)
;
OSErr
err
;
PRUint32
eventKind
=
:
:
GetEventKind
(
aEvent
)
;
PRBool
isActive
=
(
eventKind
=
=
kEventWindowActivated
)
?
PR_TRUE
:
PR_FALSE
;
if
(
isActive
&
&
sLastActive
!
=
this
)
{
if
(
sLastActive
)
{
WindowRef
oldWindow
=
NS_STATIC_CAST
(
WindowRef
sLastActive
-
>
mTopLevelWidget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
:
:
ActivateWindow
(
oldWindow
PR_FALSE
)
;
}
sLastActive
=
this
;
if
(
mTSMDocument
)
{
:
:
UseInputWindow
(
mTSMDocument
FALSE
)
;
err
=
:
:
ActivateTSMDocument
(
mTSMDocument
)
;
}
#
ifdef
DEBUG_TSM
#
if
0
NS_ASSERTION
(
err
=
=
noErr
"
nsMacEventHandler
:
:
HandleActivateEvent
:
ActivateTSMDocument
failed
"
)
;
#
endif
printf
(
"
nsEventHandler
:
:
HandleActivateEvent
:
ActivateTSMDocument
[
%
p
]
%
s
return
%
d
\
n
"
mTSMDocument
(
err
=
=
noErr
)
?
"
"
:
"
ERROR
"
err
)
;
#
endif
PRBool
active
;
mTopLevelWidget
-
>
IsActive
(
&
active
)
;
nsWindow
*
focusedWidget
=
mTopLevelWidget
;
if
(
!
active
)
{
mEventDispatchHandler
-
>
SetActivated
(
focusedWidget
)
;
mTopLevelWidget
-
>
SetIsActive
(
PR_TRUE
)
;
}
else
if
(
!
mEventDispatchHandler
-
>
GetActive
(
)
)
{
NS_ASSERTION
(
0
"
We
think
we
'
re
active
but
there
is
no
active
widget
!
"
)
;
mEventDispatchHandler
-
>
SetActivated
(
focusedWidget
)
;
}
nsIMenuBar
*
menuBar
=
focusedWidget
-
>
GetMenuBar
(
)
;
if
(
menuBar
)
{
menuBar
-
>
Paint
(
)
;
}
else
{
}
EventRecord
eventRecord
;
:
:
ConvertEventRefToEventRecord
(
aEvent
&
eventRecord
)
;
HandleMouseMoveEvent
(
eventRecord
)
;
}
else
if
(
!
isActive
&
&
sLastActive
=
=
this
)
{
sLastActive
=
nsnull
;
if
(
nsnull
!
=
gRollupListener
&
&
(
nsnull
!
=
gRollupWidget
)
)
{
gRollupListener
-
>
Rollup
(
)
;
}
if
(
mTSMDocument
)
{
ResetInputState
(
)
;
:
:
UseInputWindow
(
mTSMDocument
FALSE
)
;
err
=
:
:
DeactivateTSMDocument
(
mTSMDocument
)
;
}
#
ifdef
DEBUG_TSM
NS_ASSERTION
(
(
noErr
=
=
err
)
|
|
(
tsmDocNotActiveErr
=
=
err
)
"
nsMacEventHandler
:
:
HandleActivateEvent
:
DeactivateTSMDocument
failed
"
)
;
printf
(
"
nsEventHandler
:
:
HandleActivateEvent
:
DeactivateTSMDocument
[
%
p
]
%
s
return
%
d
\
n
"
mTSMDocument
(
err
=
=
noErr
)
?
"
"
:
"
ERROR
"
err
)
;
#
endif
mEventDispatchHandler
-
>
SetDeactivated
(
mTopLevelWidget
)
;
mTopLevelWidget
-
>
SetIsActive
(
PR_FALSE
)
;
}
}
PRBool
nsMacEventHandler
:
:
ResizeEvent
(
WindowRef
inWindow
)
{
Rect
macRect
;
:
:
GetWindowPortBounds
(
inWindow
&
macRect
)
;
:
:
LocalToGlobal
(
&
topLeft
(
macRect
)
)
;
:
:
LocalToGlobal
(
&
botRight
(
macRect
)
)
;
mTopLevelWidget
-
>
Resize
(
macRect
.
right
-
macRect
.
left
macRect
.
bottom
-
macRect
.
top
PR_FALSE
PR_TRUE
)
;
if
(
nsnull
!
=
gRollupListener
&
&
(
nsnull
!
=
gRollupWidget
)
)
gRollupListener
-
>
Rollup
(
)
;
mTopLevelWidget
-
>
UserStateForResize
(
)
;
return
PR_TRUE
;
}
PRBool
nsMacEventHandler
:
:
Scroll
(
PRInt32
aDeltaY
PRInt32
aDeltaX
PRBool
aIsPixels
const
Point
&
aMouseLoc
nsWindow
*
aWindow
PRUint32
aModifiers
)
{
PRBool
resY
=
ScrollAxis
(
nsMouseScrollEvent
:
:
kIsVertical
aDeltaY
aIsPixels
aMouseLoc
aWindow
aModifiers
)
;
PRBool
resX
=
ScrollAxis
(
nsMouseScrollEvent
:
:
kIsHorizontal
aDeltaX
aIsPixels
aMouseLoc
aWindow
aModifiers
)
;
return
resY
|
|
resX
;
}
PRBool
nsMacEventHandler
:
:
ScrollAxis
(
nsMouseScrollEvent
:
:
nsMouseScrollFlags
aAxis
PRInt32
aDelta
PRBool
aIsPixels
const
Point
&
aMouseLoc
nsWindow
*
aWindow
PRUint32
aModifiers
)
{
WindowRef
windowRef
=
NS_STATIC_CAST
(
WindowRef
mTopLevelWidget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
nsWindowType
windowType
;
mTopLevelWidget
-
>
GetWindowType
(
windowType
)
;
if
(
!
:
:
IsWindowActive
(
windowRef
)
&
&
windowType
!
=
eWindowType_popup
)
return
PR_FALSE
;
nsIWidget
*
widgetToScroll
=
aWindow
-
>
FindWidgetHit
(
aMouseLoc
)
;
if
(
!
widgetToScroll
)
return
PR_FALSE
;
if
(
aDelta
=
=
0
)
{
return
PR_TRUE
;
}
if
(
gRollupListener
&
&
gRollupWidget
)
{
PRBool
rollup
=
PR_FALSE
;
gRollupListener
-
>
ShouldRollupOnMouseWheelEvent
(
&
rollup
)
;
if
(
rollup
)
{
nsCOMPtr
<
nsIWidget
>
widgetOrAncestor
=
widgetToScroll
;
do
{
if
(
widgetOrAncestor
=
=
gRollupWidget
)
{
rollup
=
PR_FALSE
;
break
;
}
}
while
(
widgetOrAncestor
=
widgetOrAncestor
-
>
GetParent
(
)
)
;
}
if
(
rollup
)
gRollupListener
-
>
Rollup
(
)
;
}
nsMouseScrollEvent
scrollEvent
(
PR_TRUE
NS_MOUSE_SCROLL
widgetToScroll
)
;
scrollEvent
.
delta
=
-
aDelta
;
scrollEvent
.
scrollFlags
=
aAxis
;
if
(
aIsPixels
)
scrollEvent
.
scrollFlags
|
=
nsMouseScrollEvent
:
:
kIsPixels
;
nsPoint
mouseLocRelativeToWidget
(
aMouseLoc
.
h
aMouseLoc
.
v
)
;
nsRect
bounds
;
widgetToScroll
-
>
GetBounds
(
bounds
)
;
nsPoint
widgetOrigin
(
bounds
.
x
bounds
.
y
)
;
widgetToScroll
-
>
ConvertToDeviceCoordinates
(
widgetOrigin
.
x
widgetOrigin
.
y
)
;
mouseLocRelativeToWidget
.
MoveBy
(
-
widgetOrigin
.
x
-
widgetOrigin
.
y
)
;
scrollEvent
.
refPoint
.
x
=
mouseLocRelativeToWidget
.
x
;
scrollEvent
.
refPoint
.
y
=
mouseLocRelativeToWidget
.
y
;
scrollEvent
.
time
=
PR_IntervalNow
(
)
;
scrollEvent
.
isShift
=
(
(
aModifiers
&
shiftKey
)
!
=
0
)
;
scrollEvent
.
isControl
=
(
(
aModifiers
&
controlKey
)
!
=
0
)
;
scrollEvent
.
isAlt
=
(
(
aModifiers
&
optionKey
)
!
=
0
)
;
scrollEvent
.
isMeta
=
(
(
aModifiers
&
cmdKey
)
!
=
0
)
;
nsEventStatus
status
;
widgetToScroll
-
>
DispatchEvent
(
&
scrollEvent
status
)
;
return
nsWindow
:
:
ConvertStatus
(
status
)
;
}
PRBool
nsMacEventHandler
:
:
HandleMouseDownEvent
(
EventRecord
&
aOSEvent
)
{
PRBool
retVal
=
PR_FALSE
;
WindowPtr
whichWindow
;
short
partCode
=
:
:
FindWindow
(
aOSEvent
.
where
&
whichWindow
)
;
PRBool
ignoreClickInContent
=
PR_FALSE
;
if
(
whichWindow
!
=
:
:
FrontWindow
(
)
)
{
if
(
gRollupListener
&
&
gRollupWidget
)
{
PRBool
rollup
=
PR_TRUE
;
nsCOMPtr
<
nsIMenuRollup
>
menuRollup
(
do_QueryInterface
(
gRollupListener
)
)
;
if
(
menuRollup
)
{
nsCOMPtr
<
nsISupportsArray
>
widgetChain
;
menuRollup
-
>
GetSubmenuWidgetChain
(
getter_AddRefs
(
widgetChain
)
)
;
if
(
widgetChain
)
{
PRUint32
count
=
0
;
widgetChain
-
>
Count
(
&
count
)
;
for
(
PRUint32
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISupports
>
genericWidget
;
widgetChain
-
>
GetElementAt
(
i
getter_AddRefs
(
genericWidget
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
(
do_QueryInterface
(
genericWidget
)
)
;
if
(
widget
)
{
if
(
NS_REINTERPRET_CAST
(
WindowPtr
widget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
=
=
whichWindow
)
rollup
=
PR_FALSE
;
}
}
}
}
if
(
rollup
)
{
gRollupListener
-
>
Rollup
(
)
;
ignoreClickInContent
=
PR_TRUE
;
}
}
}
switch
(
partCode
)
{
case
inDrag
:
{
Point
macPoint
;
Rect
portRect
;
:
:
GetWindowPortBounds
(
whichWindow
&
portRect
)
;
macPoint
=
topLeft
(
portRect
)
;
:
:
LocalToGlobal
(
&
macPoint
)
;
mTopLevelWidget
-
>
MoveToGlobalPoint
(
macPoint
.
h
macPoint
.
v
)
;
retVal
=
PR_TRUE
;
break
;
}
case
inGrow
:
{
ResizeEvent
(
whichWindow
)
;
retVal
=
PR_TRUE
;
break
;
}
case
inGoAway
:
{
ResetInputState
(
)
;
if
(
nsnull
!
=
gRollupListener
&
&
(
nsnull
!
=
gRollupWidget
)
)
{
gRollupListener
-
>
Rollup
(
)
;
}
mEventDispatchHandler
-
>
DispatchGuiEvent
(
mTopLevelWidget
NS_XUL_CLOSE
)
;
retVal
=
PR_TRUE
;
break
;
}
case
inContent
:
{
if
(
ignoreClickInContent
)
break
;
nsMouseEvent
mouseEvent
(
PR_TRUE
NS_MOUSE_BUTTON_DOWN
nsnull
nsMouseEvent
:
:
eReal
)
;
mouseEvent
.
button
=
nsMouseEvent
:
:
eLeftButton
;
if
(
aOSEvent
.
modifiers
&
controlKey
)
mouseEvent
.
button
=
nsMouseEvent
:
:
eRightButton
;
if
(
aOSEvent
.
message
=
=
kEventMouseButtonSecondary
)
mouseEvent
.
button
=
nsMouseEvent
:
:
eRightButton
;
if
(
aOSEvent
.
message
=
=
kEventMouseButtonTertiary
)
mouseEvent
.
button
=
nsMouseEvent
:
:
eMiddleButton
;
ConvertOSEventToMouseEvent
(
aOSEvent
mouseEvent
)
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
mouseEvent
.
widget
)
;
nsWindow
*
widgetHit
=
NS_STATIC_CAST
(
nsWindow
*
mouseEvent
.
widget
)
;
if
(
widgetHit
)
{
{
nsMouseEvent
mouseActivateEvent
(
PR_TRUE
NS_MOUSE_ACTIVATE
nsnull
nsMouseEvent
:
:
eReal
)
;
ConvertOSEventToMouseEvent
(
aOSEvent
mouseActivateEvent
)
;
widgetHit
-
>
DispatchMouseEvent
(
mouseActivateEvent
)
;
}
retVal
=
widgetHit
-
>
DispatchMouseEvent
(
mouseEvent
)
;
if
(
mouseEvent
.
button
=
=
nsMouseEvent
:
:
eRightButton
)
{
nsMouseEvent
contextMenuEvent
(
PR_TRUE
NS_CONTEXTMENU
nsnull
nsMouseEvent
:
:
eReal
)
;
ConvertOSEventToMouseEvent
(
aOSEvent
contextMenuEvent
)
;
contextMenuEvent
.
isControl
=
PR_FALSE
;
widgetHit
-
>
DispatchMouseEvent
(
contextMenuEvent
)
;
}
retVal
=
PR_TRUE
;
}
mEventDispatchHandler
-
>
SetWidgetHit
(
widgetHit
)
;
mMouseInWidgetHit
=
PR_TRUE
;
break
;
}
case
inZoomIn
:
case
inZoomOut
:
{
mEventDispatchHandler
-
>
DispatchSizeModeEvent
(
mTopLevelWidget
partCode
=
=
inZoomIn
?
nsSizeMode_Normal
:
nsSizeMode_Maximized
)
;
retVal
=
PR_TRUE
;
break
;
}
case
inToolbarButton
:
mEventDispatchHandler
-
>
DispatchGuiEvent
(
mTopLevelWidget
NS_OS_TOOLBAR
)
;
retVal
=
PR_TRUE
;
break
;
}
return
retVal
;
}
PRBool
nsMacEventHandler
:
:
HandleMouseUpEvent
(
EventRecord
&
aOSEvent
)
{
PRBool
retVal
=
PR_FALSE
;
nsMouseEvent
mouseEvent
(
PR_TRUE
NS_MOUSE_BUTTON_UP
nsnull
nsMouseEvent
:
:
eReal
)
;
mouseEvent
.
button
=
nsMouseEvent
:
:
eLeftButton
;
if
(
aOSEvent
.
message
=
=
kEventMouseButtonSecondary
)
mouseEvent
.
button
=
nsMouseEvent
:
:
eRightButton
;
if
(
aOSEvent
.
message
=
=
kEventMouseButtonTertiary
)
mouseEvent
.
button
=
nsMouseEvent
:
:
eMiddleButton
;
ConvertOSEventToMouseEvent
(
aOSEvent
mouseEvent
)
;
nsWindow
*
widgetReleased
=
(
nsWindow
*
)
mouseEvent
.
widget
;
nsWindow
*
widgetHit
=
mEventDispatchHandler
-
>
GetWidgetHit
(
)
;
if
(
widgetReleased
)
{
widgetReleased
-
>
DispatchMouseEvent
(
mouseEvent
)
;
retVal
=
PR_TRUE
;
}
if
(
widgetReleased
!
=
widgetHit
)
{
}
mEventDispatchHandler
-
>
SetWidgetHit
(
nsnull
)
;
return
retVal
;
}
PRBool
nsMacEventHandler
:
:
HandleMouseMoveEvent
(
EventRecord
&
aOSEvent
)
{
nsWindow
*
lastWidgetHit
=
mEventDispatchHandler
-
>
GetWidgetHit
(
)
;
nsWindow
*
lastWidgetPointed
=
mEventDispatchHandler
-
>
GetWidgetPointed
(
)
;
PRBool
retVal
=
PR_FALSE
;
WindowRef
wind
=
reinterpret_cast
<
WindowRef
>
(
mTopLevelWidget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
nsWindowType
windowType
;
mTopLevelWidget
-
>
GetWindowType
(
windowType
)
;
if
(
!
:
:
IsWindowActive
(
wind
)
&
&
windowType
!
=
eWindowType_popup
)
return
retVal
;
nsMouseEvent
mouseEvent
(
PR_TRUE
NS_MOUSE_MOVE
nsnull
nsMouseEvent
:
:
eReal
)
;
ConvertOSEventToMouseEvent
(
aOSEvent
mouseEvent
)
;
if
(
lastWidgetHit
)
{
Point
macPoint
=
aOSEvent
.
where
;
nsGraphicsUtils
:
:
SafeSetPortWindowPort
(
wind
)
;
{
StOriginSetter
originSetter
(
wind
)
;
:
:
GlobalToLocal
(
&
macPoint
)
;
}
PRBool
inWidgetHit
=
lastWidgetHit
-
>
PointInWidget
(
macPoint
)
;
if
(
mMouseInWidgetHit
!
=
inWidgetHit
)
{
mMouseInWidgetHit
=
inWidgetHit
;
mouseEvent
.
message
=
(
inWidgetHit
?
NS_MOUSE_ENTER
:
NS_MOUSE_EXIT
)
;
}
lastWidgetHit
-
>
DispatchMouseEvent
(
mouseEvent
)
;
retVal
=
PR_TRUE
;
}
else
{
nsWindow
*
widgetPointed
=
(
nsWindow
*
)
mouseEvent
.
widget
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
widgetPointed
)
;
if
(
widgetPointed
!
=
lastWidgetPointed
)
{
if
(
lastWidgetPointed
)
{
nsPoint
widgetHitPoint
=
mouseEvent
.
refPoint
;
Point
macPoint
=
aOSEvent
.
where
;
nsGraphicsUtils
:
:
SafeSetPortWindowPort
(
wind
)
;
{
StOriginSetter
originSetter
(
wind
)
;
:
:
GlobalToLocal
(
&
macPoint
)
;
}
nsPoint
lastWidgetHitPoint
(
macPoint
.
h
macPoint
.
v
)
;
nsRect
bounds
;
lastWidgetPointed
-
>
GetBounds
(
bounds
)
;
nsPoint
widgetOrigin
(
bounds
.
x
bounds
.
y
)
;
lastWidgetPointed
-
>
LocalToWindowCoordinate
(
widgetOrigin
)
;
lastWidgetHitPoint
.
MoveBy
(
-
widgetOrigin
.
x
-
widgetOrigin
.
y
)
;
mouseEvent
.
widget
=
lastWidgetPointed
;
mouseEvent
.
refPoint
=
lastWidgetHitPoint
;
mouseEvent
.
message
=
NS_MOUSE_EXIT
;
lastWidgetPointed
-
>
DispatchMouseEvent
(
mouseEvent
)
;
retVal
=
PR_TRUE
;
mouseEvent
.
refPoint
=
widgetHitPoint
;
}
mEventDispatchHandler
-
>
SetWidgetPointed
(
widgetPointed
)
;
#
if
TRACK_MOUSE_LOC
mEventDispatchHandler
-
>
SetGlobalPoint
(
aOSEvent
.
where
)
;
#
endif
if
(
widgetPointed
)
{
mouseEvent
.
widget
=
widgetPointed
;
mouseEvent
.
message
=
NS_MOUSE_ENTER
;
widgetPointed
-
>
DispatchMouseEvent
(
mouseEvent
)
;
retVal
=
PR_TRUE
;
}
}
else
{
if
(
widgetPointed
)
{
widgetPointed
-
>
DispatchMouseEvent
(
mouseEvent
)
;
retVal
=
PR_TRUE
;
}
}
}
return
retVal
;
}
#
pragma
mark
-
void
nsMacEventHandler
:
:
ConvertOSEventToMouseEvent
(
EventRecord
&
aOSEvent
nsMouseEvent
&
aMouseEvent
)
{
if
(
aMouseEvent
.
message
=
=
NS_MOUSE_BUTTON_UP
)
{
mLastMouseUpWhen
=
aOSEvent
.
when
;
mLastMouseUpWhere
=
aOSEvent
.
where
;
}
else
if
(
aMouseEvent
.
message
=
=
NS_MOUSE_BUTTON_DOWN
)
{
const
short
kDoubleClickMoveThreshold
=
5
;
if
(
(
(
aOSEvent
.
when
-
mLastMouseUpWhen
)
<
:
:
GetDblTime
(
)
)
&
&
(
(
(
abs
(
aOSEvent
.
where
.
h
-
mLastMouseUpWhere
.
h
)
<
kDoubleClickMoveThreshold
)
&
&
(
abs
(
aOSEvent
.
where
.
v
-
mLastMouseUpWhere
.
v
)
<
kDoubleClickMoveThreshold
)
)
)
)
{
mClickCount
+
+
;
}
else
{
mClickCount
=
1
;
}
}
nsWindowType
wtype
;
mTopLevelWidget
-
>
GetWindowType
(
wtype
)
;
PRBool
topLevelIsAPopup
=
(
wtype
=
=
eWindowType_popup
)
;
WindowRef
eventTargetWindow
=
reinterpret_cast
<
WindowRef
>
(
mTopLevelWidget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
WindowPtr
windowThatHasEvent
=
nsnull
;
ControlPartCode
partCode
=
:
:
FindWindow
(
aOSEvent
.
where
&
windowThatHasEvent
)
;
nsWindow
*
lastWidgetHit
=
mEventDispatchHandler
-
>
GetWidgetHit
(
)
;
nsWindow
*
widgetHit
=
nsnull
;
if
(
lastWidgetHit
)
{
WindowRef
lastWind
=
reinterpret_cast
<
WindowRef
>
(
lastWidgetHit
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
PRBool
eventInSameWindowAsLastEvent
=
(
windowThatHasEvent
=
=
lastWind
)
;
if
(
eventInSameWindowAsLastEvent
|
|
!
topLevelIsAPopup
)
{
if
(
:
:
StillDown
(
)
|
|
(
aMouseEvent
.
message
=
=
NS_MOUSE_BUTTON_UP
&
&
aMouseEvent
.
button
=
=
nsMouseEvent
:
:
eLeftButton
)
)
{
widgetHit
=
lastWidgetHit
;
eventTargetWindow
=
lastWind
;
}
else
{
mEventDispatchHandler
-
>
SetWidgetHit
(
nsnull
)
;
}
}
}
Point
hitPoint
=
aOSEvent
.
where
;
nsGraphicsUtils
:
:
SafeSetPortWindowPort
(
eventTargetWindow
)
;
{
StOriginSetter
originSetter
(
eventTargetWindow
)
;
:
:
GlobalToLocal
(
&
hitPoint
)
;
}
nsPoint
widgetHitPoint
(
hitPoint
.
h
hitPoint
.
v
)
;
if
(
partCode
!
=
inGrow
)
{
if
(
!
widgetHit
)
widgetHit
=
mTopLevelWidget
-
>
FindWidgetHit
(
hitPoint
)
;
if
(
widgetHit
)
{
nsRect
bounds
;
widgetHit
-
>
GetBounds
(
bounds
)
;
nsPoint
widgetOrigin
(
bounds
.
x
bounds
.
y
)
;
widgetHit
-
>
LocalToWindowCoordinate
(
widgetOrigin
)
;
widgetHitPoint
.
MoveBy
(
-
widgetOrigin
.
x
-
widgetOrigin
.
y
)
;
}
}
if
(
!
widgetHit
&
&
topLevelIsAPopup
&
&
(
hitPoint
.
h
<
0
|
|
hitPoint
.
v
<
0
)
)
widgetHit
=
mTopLevelWidget
;
InitializeMouseEvent
(
aMouseEvent
widgetHitPoint
aOSEvent
.
modifiers
mClickCount
)
;
aMouseEvent
.
widget
=
widgetHit
;
aMouseEvent
.
nativeMsg
=
(
void
*
)
&
aOSEvent
;
aMouseEvent
.
acceptActivation
=
PR_TRUE
;
if
(
aMouseEvent
.
message
=
=
NS_CONTEXTMENU
)
aMouseEvent
.
button
=
nsMouseEvent
:
:
eRightButton
;
}
long
nsMacEventHandler
:
:
HandlePositionToOffset
(
Point
aPoint
short
*
regionClass
)
{
*
regionClass
=
kTSMOutsideOfBody
;
return
0
;
}
nsresult
nsMacEventHandler
:
:
HandleOffsetToPosition
(
long
offset
Point
*
thePoint
)
{
thePoint
-
>
v
=
mIMEPos
.
y
;
thePoint
-
>
h
=
mIMEPos
.
x
;
WindowRef
wind
=
reinterpret_cast
<
WindowRef
>
(
mTopLevelWidget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
;
nsGraphicsUtils
:
:
SafeSetPortWindowPort
(
wind
)
;
Rect
savePortRect
;
:
:
GetWindowPortBounds
(
wind
&
savePortRect
)
;
:
:
LocalToGlobal
(
thePoint
)
;
return
PR_TRUE
;
}
nsresult
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
(
const
PRUnichar
*
text
long
charCount
long
fixedLength
TextRangeArray
*
textRangeList
)
{
#
ifdef
DEBUG_TSM
printf
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
;
printf
(
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
size
=
%
d
fixlen
=
%
d
\
n
"
charCount
fixedLength
)
;
#
endif
nsresult
res
=
NS_OK
;
long
committedLen
=
0
;
if
(
!
mIMEIsComposing
)
{
res
=
HandleStartComposition
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleStartComposition
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
}
NS_ASSERTION
(
mIMECompositionStr
"
do
not
have
mIMECompositionStr
"
)
;
if
(
nsnull
=
=
mIMECompositionStr
)
{
res
=
NS_ERROR_OUT_OF_MEMORY
;
goto
error
;
}
committedLen
=
(
fixedLength
=
=
-
1
)
?
charCount
:
fixedLength
;
if
(
0
!
=
committedLen
)
{
#
ifdef
DEBUG_TSM
printf
(
"
Have
commit
text
from
0
to
%
d
\
n
"
committedLen
)
;
#
endif
mIMECompositionStr
-
>
Assign
(
text
committedLen
)
;
#
ifdef
DEBUG_TSM
printf
(
"
1
.
2
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
#
endif
res
=
HandleTextEvent
(
0
nsnull
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleTextEvent
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
res
=
nsMacEventHandler
:
:
HandleEndComposition
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleEndComposition
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
}
if
(
(
-
1
!
=
fixedLength
)
&
&
(
charCount
!
=
fixedLength
)
)
{
#
ifdef
DEBUG_TSM
printf
(
"
Have
new
uncommitted
text
from
%
d
to
text_size
(
%
d
)
\
n
"
committedLen
charCount
)
;
#
endif
if
(
!
mIMEIsComposing
)
{
res
=
HandleStartComposition
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleStartComposition
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
}
TextRangeArray
rawTextRangeArray
;
TextRangeArray
*
rangeArray
;
if
(
textRangeList
&
&
textRangeList
-
>
fNumOfRanges
)
{
rangeArray
=
textRangeList
;
}
else
{
rangeArray
=
&
rawTextRangeArray
;
rawTextRangeArray
.
fNumOfRanges
=
1
;
rawTextRangeArray
.
fRange
[
0
]
.
fStart
=
committedLen
*
2
;
rawTextRangeArray
.
fRange
[
0
]
.
fEnd
=
charCount
*
2
;
rawTextRangeArray
.
fRange
[
0
]
.
fHiliteStyle
=
NS_TEXTRANGE_RAWINPUT
;
}
#
ifdef
DEBUG_TSM
printf
(
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
textRangeList
is
%
s
\
n
"
textRangeList
?
"
NOT
NULL
"
:
"
NULL
"
)
;
#
endif
nsTextRangeArray
xpTextRangeArray
=
new
nsTextRange
[
rangeArray
-
>
fNumOfRanges
]
;
NS_ASSERTION
(
xpTextRangeArray
!
=
NULL
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
xpTextRangeArray
memory
allocation
failed
.
"
)
;
if
(
xpTextRangeArray
=
=
NULL
)
{
res
=
NS_ERROR_OUT_OF_MEMORY
;
goto
error
;
}
PRInt32
i
;
for
(
i
=
0
;
i
<
rangeArray
-
>
fNumOfRanges
;
i
+
+
)
{
NS_ASSERTION
(
(
NS_TEXTRANGE_CARETPOSITION
=
=
rangeArray
-
>
fRange
[
i
]
.
fHiliteStyle
)
|
|
(
NS_TEXTRANGE_RAWINPUT
=
=
rangeArray
-
>
fRange
[
i
]
.
fHiliteStyle
)
|
|
(
NS_TEXTRANGE_SELECTEDRAWTEXT
=
=
rangeArray
-
>
fRange
[
i
]
.
fHiliteStyle
)
|
|
(
NS_TEXTRANGE_CONVERTEDTEXT
=
=
rangeArray
-
>
fRange
[
i
]
.
fHiliteStyle
)
|
|
(
NS_TEXTRANGE_SELECTEDCONVERTEDTEXT
=
=
rangeArray
-
>
fRange
[
i
]
.
fHiliteStyle
)
"
illegal
range
type
"
)
;
NS_ASSERTION
(
rangeArray
-
>
fRange
[
i
]
.
fStart
/
2
<
=
charCount
"
illegal
range
"
)
;
NS_ASSERTION
(
rangeArray
-
>
fRange
[
i
]
.
fEnd
/
2
<
=
charCount
"
illegal
range
"
)
;
#
ifdef
DEBUG_TSM
printf
(
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
textRangeList
[
%
d
]
=
(
%
d
%
d
)
text_size
=
%
d
\
n
"
i
rangeArray
-
>
fRange
[
i
]
.
fStart
/
2
rangeArray
-
>
fRange
[
i
]
.
fEnd
/
2
charCount
)
;
#
endif
xpTextRangeArray
[
i
]
.
mRangeType
=
rangeArray
-
>
fRange
[
i
]
.
fHiliteStyle
;
xpTextRangeArray
[
i
]
.
mStartOffset
=
rangeArray
-
>
fRange
[
i
]
.
fStart
/
2
;
xpTextRangeArray
[
i
]
.
mEndOffset
=
rangeArray
-
>
fRange
[
i
]
.
fEnd
/
2
;
#
ifdef
DEBUG_TSM
printf
(
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
textRangeList
[
%
d
]
=
>
type
=
%
d
(
%
d
%
d
)
\
n
"
i
xpTextRangeArray
[
i
]
.
mRangeType
xpTextRangeArray
[
i
]
.
mStartOffset
xpTextRangeArray
[
i
]
.
mEndOffset
)
;
#
endif
NS_ASSERTION
(
(
NS_TEXTRANGE_CARETPOSITION
!
=
xpTextRangeArray
[
i
]
.
mRangeType
)
|
|
(
xpTextRangeArray
[
i
]
.
mStartOffset
=
=
xpTextRangeArray
[
i
]
.
mEndOffset
)
"
start
!
=
end
in
CaretPosition
"
)
;
}
mIMECompositionStr
-
>
Assign
(
text
+
committedLen
charCount
-
committedLen
)
;
#
ifdef
DEBUG_TSM
printf
(
"
2
.
2
.
4
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
#
endif
res
=
HandleTextEvent
(
rangeArray
-
>
fNumOfRanges
xpTextRangeArray
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleTextEvent
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
delete
[
]
xpTextRangeArray
;
}
else
if
(
(
0
=
=
charCount
)
&
&
(
0
=
=
fixedLength
)
)
{
mIMECompositionStr
-
>
Truncate
(
)
;
#
ifdef
DEBUG_TSM
printf
(
"
3
.
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
=
\
n
"
)
;
#
endif
res
=
HandleTextEvent
(
0
nsnull
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleTextEvent
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
res
=
nsMacEventHandler
:
:
HandleEndComposition
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
nsMacEventHandler
:
:
UnicodeHandleUpdateInputArea
:
HandleEndComposition
failed
.
"
)
;
if
(
NS_FAILED
(
res
)
)
goto
error
;
}
error
:
return
res
;
}
nsresult
nsMacEventHandler
:
:
HandleUnicodeGetSelectedText
(
nsAString
&
outString
)
{
outString
.
Truncate
(
0
)
;
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
nsReconversionEvent
reconversionEvent
(
PR_TRUE
NS_RECONVERSION_QUERY
focusedWidget
)
;
reconversionEvent
.
time
=
PR_IntervalNow
(
)
;
nsresult
res
=
focusedWidget
-
>
DispatchWindowEvent
(
reconversionEvent
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
outString
.
Assign
(
reconversionEvent
.
theReply
.
mReconversionString
)
;
nsMemory
:
:
Free
(
reconversionEvent
.
theReply
.
mReconversionString
)
;
}
return
res
;
}
nsresult
nsMacEventHandler
:
:
HandleStartComposition
(
void
)
{
#
ifdef
DEBUG_TSM
printf
(
"
HandleStartComposition
\
n
"
)
;
#
endif
mIMEIsComposing
=
PR_TRUE
;
if
(
nsnull
=
=
mIMECompositionStr
)
mIMECompositionStr
=
new
nsAutoString
(
)
;
NS_ASSERTION
(
mIMECompositionStr
"
cannot
allocate
mIMECompositionStr
"
)
;
if
(
nsnull
=
=
mIMECompositionStr
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
nsCompositionEvent
compositionEvent
(
PR_TRUE
NS_COMPOSITION_START
focusedWidget
)
;
compositionEvent
.
time
=
PR_IntervalNow
(
)
;
nsresult
res
=
focusedWidget
-
>
DispatchWindowEvent
(
compositionEvent
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
mIMEPos
.
x
=
compositionEvent
.
theReply
.
mCursorPosition
.
x
;
mIMEPos
.
y
=
compositionEvent
.
theReply
.
mCursorPosition
.
y
+
compositionEvent
.
theReply
.
mCursorPosition
.
height
;
focusedWidget
-
>
LocalToWindowCoordinate
(
mIMEPos
)
;
#
ifdef
DEBUG_TSM
printf
(
"
HandleStartComposition
reply
(
%
d
%
d
)
\
n
"
mIMEPos
.
x
mIMEPos
.
y
)
;
#
endif
}
return
res
;
}
nsresult
nsMacEventHandler
:
:
HandleEndComposition
(
void
)
{
#
ifdef
DEBUG_TSM
printf
(
"
HandleEndComposition
\
n
"
)
;
#
endif
mIMEIsComposing
=
PR_FALSE
;
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
nsCompositionEvent
compositionEvent
(
PR_TRUE
NS_COMPOSITION_END
focusedWidget
)
;
compositionEvent
.
time
=
PR_IntervalNow
(
)
;
return
(
focusedWidget
-
>
DispatchWindowEvent
(
compositionEvent
)
)
;
}
nsresult
nsMacEventHandler
:
:
HandleTextEvent
(
PRUint32
textRangeCount
nsTextRangeArray
textRangeArray
)
{
#
ifdef
DEBUG_TSM
printf
(
"
HandleTextEvent
\
n
"
)
;
PRUint32
i
;
printf
(
"
text
event
\
n
[
"
)
;
const
PRUnichar
*
ubuf
=
mIMECompositionStr
-
>
get
(
)
;
for
(
i
=
0
;
'
\
0
'
!
=
*
ubuf
;
i
+
+
)
printf
(
"
U
+
%
04X
"
*
ubuf
+
+
)
;
printf
(
"
]
len
=
%
d
\
n
"
i
)
;
if
(
textRangeCount
>
0
)
{
for
(
i
=
0
;
i
<
textRangeCount
;
i
+
+
)
{
NS_ASSERTION
(
(
NS_TEXTRANGE_CARETPOSITION
!
=
textRangeArray
[
i
]
.
mRangeType
)
|
|
(
textRangeArray
[
i
]
.
mStartOffset
=
=
textRangeArray
[
i
]
.
mEndOffset
)
"
start
!
=
end
in
CaretPosition
"
)
;
NS_ASSERTION
(
(
NS_TEXTRANGE_CARETPOSITION
=
=
textRangeArray
[
i
]
.
mRangeType
)
|
|
(
NS_TEXTRANGE_RAWINPUT
=
=
textRangeArray
[
i
]
.
mRangeType
)
|
|
(
NS_TEXTRANGE_SELECTEDRAWTEXT
=
=
textRangeArray
[
i
]
.
mRangeType
)
|
|
(
NS_TEXTRANGE_CONVERTEDTEXT
=
=
textRangeArray
[
i
]
.
mRangeType
)
|
|
(
NS_TEXTRANGE_SELECTEDCONVERTEDTEXT
=
=
textRangeArray
[
i
]
.
mRangeType
)
"
illegal
range
type
"
)
;
static
char
*
name
[
6
]
=
{
"
Unknown
"
"
CaretPosition
"
"
RawInput
"
"
SelectedRawText
"
"
ConvertedText
"
"
SelectedConvertedText
"
}
;
printf
(
"
[
%
d
%
d
]
=
%
s
\
n
"
textRangeArray
[
i
]
.
mStartOffset
textRangeArray
[
i
]
.
mEndOffset
(
(
textRangeArray
[
i
]
.
mRangeType
<
=
NS_TEXTRANGE_SELECTEDCONVERTEDTEXT
)
?
name
[
textRangeArray
[
i
]
.
mRangeType
]
:
name
[
0
]
)
)
;
}
}
#
endif
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
nsTextEvent
textEvent
(
PR_TRUE
NS_TEXT_TEXT
focusedWidget
)
;
textEvent
.
time
=
PR_IntervalNow
(
)
;
textEvent
.
theText
=
mIMECompositionStr
-
>
get
(
)
;
textEvent
.
rangeCount
=
textRangeCount
;
textEvent
.
rangeArray
=
textRangeArray
;
nsresult
res
=
NS_OK
;
if
(
NS_SUCCEEDED
(
res
=
focusedWidget
-
>
DispatchWindowEvent
(
textEvent
)
)
)
{
mIMEPos
.
x
=
textEvent
.
theReply
.
mCursorPosition
.
x
;
mIMEPos
.
y
=
textEvent
.
theReply
.
mCursorPosition
.
y
+
textEvent
.
theReply
.
mCursorPosition
.
height
;
mTopLevelWidget
-
>
LocalToWindowCoordinate
(
mIMEPos
)
;
#
ifdef
DEBUG_TSM
printf
(
"
HandleTextEvent
reply
(
%
d
%
d
)
\
n
"
mIMEPos
.
x
mIMEPos
.
y
)
;
#
endif
}
return
res
;
}
nsresult
nsMacEventHandler
:
:
ResetInputState
(
)
{
OSErr
err
=
noErr
;
if
(
mTSMDocument
)
{
:
:
UseInputWindow
(
mTSMDocument
FALSE
)
;
err
=
:
:
FixTSMDocument
(
mTSMDocument
)
;
NS_ASSERTION
(
(
noErr
=
=
err
)
|
|
(
tsmDocNotActiveErr
=
=
err
)
|
|
(
tsmTSNotOpenErr
)
"
Cannot
FixTSMDocument
"
)
;
}
return
NS_OK
;
}
PRBool
nsMacEventHandler
:
:
HandleKeyUpDownEvent
(
EventHandlerCallRef
aHandlerCallRef
EventRef
aEvent
)
{
ClearLastMouseUp
(
)
;
PRUint32
eventKind
=
:
:
GetEventKind
(
aEvent
)
;
NS_ASSERTION
(
eventKind
=
=
kEventRawKeyDown
|
|
eventKind
=
=
kEventRawKeyUp
"
Unknown
event
kind
"
)
;
OSStatus
err
=
noErr
;
PRBool
sendToTSM
=
PR_FALSE
;
if
(
eventKind
=
=
kEventRawKeyDown
)
{
if
(
mTSMDocument
!
=
:
:
TSMGetActiveDocument
(
)
)
{
err
=
:
:
CallNextEventHandler
(
aHandlerCallRef
aEvent
)
;
if
(
err
=
=
noErr
)
{
return
PR_TRUE
;
}
}
else
{
sendToTSM
=
PR_TRUE
;
}
}
PRBool
handled
=
PR_FALSE
;
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
PRUint32
modifiers
=
0
;
err
=
:
:
GetEventParameter
(
aEvent
kEventParamKeyModifiers
typeUInt32
NULL
sizeof
(
modifiers
)
NULL
&
modifiers
)
;
NS_ASSERTION
(
err
=
=
noErr
"
Could
not
get
kEventParamKeyModifiers
"
)
;
PRUint32
keyCode
=
0
;
err
=
:
:
GetEventParameter
(
aEvent
kEventParamKeyCode
typeUInt32
NULL
sizeof
(
keyCode
)
NULL
&
keyCode
)
;
NS_ASSERTION
(
err
=
=
noErr
"
Could
not
get
kEventParamKeyCode
"
)
;
PRUint8
charCode
=
0
;
:
:
GetEventParameter
(
aEvent
kEventParamKeyMacCharCodes
typeChar
NULL
sizeof
(
charCode
)
NULL
&
charCode
)
;
EventRecord
eventRecord
;
:
:
ConvertEventRefToEventRecord
(
aEvent
&
eventRecord
)
;
PRUint32
message
=
(
eventKind
=
=
kEventRawKeyUp
?
NS_KEY_UP
:
NS_KEY_DOWN
)
;
nsKeyEvent
upDownEvent
(
PR_TRUE
message
nsnull
)
;
upDownEvent
.
time
=
PR_IntervalNow
(
)
;
upDownEvent
.
widget
=
focusedWidget
;
upDownEvent
.
nativeMsg
=
(
void
*
)
&
eventRecord
;
upDownEvent
.
isShift
=
(
(
modifiers
&
shiftKey
)
!
=
0
)
;
upDownEvent
.
isControl
=
(
(
modifiers
&
controlKey
)
!
=
0
)
;
upDownEvent
.
isAlt
=
(
(
modifiers
&
optionKey
)
!
=
0
)
;
upDownEvent
.
isMeta
=
(
(
modifiers
&
cmdKey
)
!
=
0
)
;
upDownEvent
.
keyCode
=
ConvertMacToRaptorKeyCode
(
charCode
keyCode
modifiers
)
;
upDownEvent
.
charCode
=
0
;
handled
=
focusedWidget
-
>
DispatchWindowEvent
(
upDownEvent
)
;
if
(
eventKind
=
=
kEventRawKeyUp
)
return
handled
;
nsWindow
*
checkFocusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
checkFocusedWidget
)
checkFocusedWidget
=
mTopLevelWidget
;
PRBool
lastIgnore
=
PR_FALSE
;
if
(
checkFocusedWidget
!
=
focusedWidget
)
{
lastIgnore
=
mKeyIgnore
;
mKeyIgnore
=
PR_TRUE
;
}
PRBool
lastHandled
=
PR_FALSE
;
if
(
handled
)
{
lastHandled
=
mKeyHandled
;
mKeyHandled
=
PR_TRUE
;
}
if
(
sendToTSM
)
{
:
:
CallNextEventHandler
(
aHandlerCallRef
aEvent
)
;
}
mKeyHandled
=
lastHandled
;
mKeyIgnore
=
lastIgnore
;
return
handled
;
}
PRBool
nsMacEventHandler
:
:
HandleKeyModifierEvent
(
EventHandlerCallRef
aHandlerCallRef
EventRef
aEvent
)
{
ClearLastMouseUp
(
)
;
PRBool
handled
=
PR_FALSE
;
nsWindow
*
focusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
focusedWidget
)
focusedWidget
=
mTopLevelWidget
;
PRUint32
modifiers
=
0
;
OSStatus
err
=
:
:
GetEventParameter
(
aEvent
kEventParamKeyModifiers
typeUInt32
NULL
sizeof
(
modifiers
)
NULL
&
modifiers
)
;
NS_ASSERTION
(
err
=
=
noErr
"
Could
not
get
kEventParamKeyModifiers
"
)
;
typedef
struct
{
PRUint32
modifierBit
;
PRUint32
keycode
;
}
ModifierToKeycode
;
const
ModifierToKeycode
kModifierToKeycodeTable
[
]
=
{
{
shiftKey
NS_VK_SHIFT
}
{
controlKey
NS_VK_CONTROL
}
{
optionKey
NS_VK_ALT
}
{
cmdKey
NS_VK_META
}
}
;
const
PRUint32
kModifierCount
=
sizeof
(
kModifierToKeycodeTable
)
/
sizeof
(
ModifierToKeycode
)
;
EventRecord
eventRecord
;
:
:
ConvertEventRefToEventRecord
(
aEvent
&
eventRecord
)
;
for
(
PRUint32
i
=
0
;
i
<
kModifierCount
;
i
+
+
)
{
PRUint32
modifierBit
=
kModifierToKeycodeTable
[
i
]
.
modifierBit
;
if
(
(
modifiers
&
modifierBit
)
!
=
(
mLastModifierState
&
modifierBit
)
)
{
PRUint32
message
=
(
(
modifiers
&
modifierBit
)
!
=
0
?
NS_KEY_DOWN
:
NS_KEY_UP
)
;
nsKeyEvent
upDownEvent
(
PR_TRUE
message
nsnull
)
;
upDownEvent
.
time
=
PR_IntervalNow
(
)
;
upDownEvent
.
widget
=
focusedWidget
;
upDownEvent
.
nativeMsg
=
(
void
*
)
&
eventRecord
;
upDownEvent
.
isShift
=
(
(
modifiers
&
shiftKey
)
!
=
0
)
;
upDownEvent
.
isControl
=
(
(
modifiers
&
controlKey
)
!
=
0
)
;
upDownEvent
.
isAlt
=
(
(
modifiers
&
optionKey
)
!
=
0
)
;
upDownEvent
.
isMeta
=
(
(
modifiers
&
cmdKey
)
!
=
0
)
;
upDownEvent
.
keyCode
=
kModifierToKeycodeTable
[
i
]
.
keycode
;
upDownEvent
.
charCode
=
0
;
handled
|
=
focusedWidget
-
>
DispatchWindowEvent
(
upDownEvent
)
;
nsWindow
*
checkFocusedWidget
=
mEventDispatchHandler
-
>
GetActive
(
)
;
if
(
!
checkFocusedWidget
)
checkFocusedWidget
=
mTopLevelWidget
;
if
(
checkFocusedWidget
!
=
focusedWidget
)
break
;
}
}
mLastModifierState
=
modifiers
;
return
handled
;
}
void
nsMacEventHandler
:
:
ClearLastMouseUp
(
)
{
mLastMouseUpWhere
.
h
=
0
;
mLastMouseUpWhere
.
v
=
0
;
mLastMouseUpWhen
=
0
;
mClickCount
=
0
;
}
