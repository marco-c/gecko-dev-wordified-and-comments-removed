#
include
"
nsHTMLFormatConverter
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsISupportsArray
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIDTD
.
h
"
#
include
"
nsParserCIID
.
h
"
#
include
"
nsIContentSink
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIHTMLToTextSink
.
h
"
static
NS_DEFINE_CID
(
kCParserCID
NS_PARSER_CID
)
;
nsHTMLFormatConverter
:
:
nsHTMLFormatConverter
(
)
{
}
nsHTMLFormatConverter
:
:
~
nsHTMLFormatConverter
(
)
{
}
NS_IMPL_ISUPPORTS1
(
nsHTMLFormatConverter
nsIFormatConverter
)
NS_IMETHODIMP
nsHTMLFormatConverter
:
:
GetInputDataFlavors
(
nsISupportsArray
*
*
_retval
)
{
if
(
!
_retval
)
return
NS_ERROR_INVALID_ARG
;
nsresult
rv
=
NS_NewISupportsArray
(
_retval
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
rv
=
AddFlavorToList
(
*
_retval
kHTMLMime
)
;
return
rv
;
}
NS_IMETHODIMP
nsHTMLFormatConverter
:
:
GetOutputDataFlavors
(
nsISupportsArray
*
*
_retval
)
{
if
(
!
_retval
)
return
NS_ERROR_INVALID_ARG
;
nsresult
rv
=
NS_NewISupportsArray
(
_retval
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
AddFlavorToList
(
*
_retval
kHTMLMime
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
if
NOT_NOW
rv
=
AddFlavorToList
(
*
_retval
kAOLMailMime
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
#
endif
rv
=
AddFlavorToList
(
*
_retval
kUnicodeMime
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
return
rv
;
}
nsresult
nsHTMLFormatConverter
:
:
AddFlavorToList
(
nsISupportsArray
*
inList
const
char
*
inFlavor
)
{
nsresult
rv
;
nsCOMPtr
<
nsISupportsCString
>
dataFlavor
=
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
&
rv
)
;
if
(
dataFlavor
)
{
dataFlavor
-
>
SetData
(
nsDependentCString
(
inFlavor
)
)
;
nsCOMPtr
<
nsISupports
>
genericFlavor
(
do_QueryInterface
(
dataFlavor
)
)
;
inList
-
>
AppendElement
(
genericFlavor
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsHTMLFormatConverter
:
:
CanConvert
(
const
char
*
aFromDataFlavor
const
char
*
aToDataFlavor
PRBool
*
_retval
)
{
if
(
!
_retval
)
return
NS_ERROR_INVALID_ARG
;
*
_retval
=
PR_FALSE
;
nsAutoString
fromFlavor
;
fromFlavor
.
AssignWithConversion
(
aFromDataFlavor
)
;
if
(
!
nsCRT
:
:
strcmp
(
aFromDataFlavor
kHTMLMime
)
)
{
if
(
!
nsCRT
:
:
strcmp
(
aToDataFlavor
kHTMLMime
)
)
*
_retval
=
PR_TRUE
;
else
if
(
!
nsCRT
:
:
strcmp
(
aToDataFlavor
kUnicodeMime
)
)
*
_retval
=
PR_TRUE
;
#
if
NOT_NOW
else
if
(
toFlavor
.
Equals
(
kAOLMailMime
)
)
*
_retval
=
PR_TRUE
;
#
endif
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHTMLFormatConverter
:
:
Convert
(
const
char
*
aFromDataFlavor
nsISupports
*
aFromData
PRUint32
aDataLen
const
char
*
aToDataFlavor
nsISupports
*
*
aToData
PRUint32
*
aDataToLen
)
{
if
(
!
aToData
|
|
!
aDataToLen
)
return
NS_ERROR_INVALID_ARG
;
nsresult
rv
=
NS_OK
;
*
aToData
=
nsnull
;
*
aDataToLen
=
0
;
if
(
!
nsCRT
:
:
strcmp
(
aFromDataFlavor
kHTMLMime
)
)
{
nsCAutoString
toFlavor
(
aToDataFlavor
)
;
nsCOMPtr
<
nsISupportsString
>
dataWrapper0
(
do_QueryInterface
(
aFromData
)
)
;
if
(
!
dataWrapper0
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoString
dataStr
;
dataWrapper0
-
>
GetData
(
dataStr
)
;
if
(
toFlavor
.
Equals
(
kHTMLMime
)
|
|
toFlavor
.
Equals
(
kUnicodeMime
)
)
{
nsresult
res
;
if
(
toFlavor
.
Equals
(
kHTMLMime
)
)
{
PRInt32
dataLen
=
dataStr
.
Length
(
)
*
2
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
toFlavor
.
get
(
)
(
void
*
)
dataStr
.
get
(
)
dataLen
aToData
)
;
if
(
*
aToData
)
*
aDataToLen
=
dataLen
;
}
else
{
nsAutoString
outStr
;
res
=
ConvertFromHTMLToUnicode
(
dataStr
outStr
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
PRInt32
dataLen
=
outStr
.
Length
(
)
*
2
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
toFlavor
.
get
(
)
(
void
*
)
outStr
.
get
(
)
dataLen
aToData
)
;
if
(
*
aToData
)
*
aDataToLen
=
dataLen
;
}
}
}
else
if
(
toFlavor
.
Equals
(
kAOLMailMime
)
)
{
nsAutoString
outStr
;
if
(
NS_SUCCEEDED
(
ConvertFromHTMLToAOLMail
(
dataStr
outStr
)
)
)
{
PRInt32
dataLen
=
outStr
.
Length
(
)
*
2
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
toFlavor
.
get
(
)
(
void
*
)
outStr
.
get
(
)
dataLen
aToData
)
;
if
(
*
aToData
)
*
aDataToLen
=
dataLen
;
}
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
}
else
rv
=
NS_ERROR_FAILURE
;
return
rv
;
}
NS_IMETHODIMP
nsHTMLFormatConverter
:
:
ConvertFromHTMLToUnicode
(
const
nsAutoString
&
aFromStr
nsAutoString
&
aToStr
)
{
aToStr
.
SetLength
(
0
)
;
nsresult
rv
;
nsCOMPtr
<
nsIParser
>
parser
=
do_CreateInstance
(
kCParserCID
&
rv
)
;
if
(
!
parser
)
return
rv
;
nsCOMPtr
<
nsIContentSink
>
sink
;
sink
=
do_CreateInstance
(
NS_PLAINTEXTSINK_CONTRACTID
)
;
NS_ENSURE_TRUE
(
sink
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIHTMLToTextSink
>
textSink
(
do_QueryInterface
(
sink
)
)
;
NS_ENSURE_TRUE
(
textSink
NS_ERROR_FAILURE
)
;
PRUint32
flags
=
nsIDocumentEncoder
:
:
OutputSelectionOnly
|
nsIDocumentEncoder
:
:
OutputAbsoluteLinks
|
nsIDocumentEncoder
:
:
OutputNoScriptContent
|
nsIDocumentEncoder
:
:
OutputNoFramesContent
;
textSink
-
>
Initialize
(
&
aToStr
flags
0
)
;
parser
-
>
SetContentSink
(
sink
)
;
parser
-
>
Parse
(
aFromStr
0
NS_LITERAL_CSTRING
(
"
text
/
html
"
)
PR_TRUE
eDTDMode_fragment
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHTMLFormatConverter
:
:
ConvertFromHTMLToAOLMail
(
const
nsAutoString
&
aFromStr
nsAutoString
&
aToStr
)
{
aToStr
.
AssignLiteral
(
"
<
HTML
>
"
)
;
aToStr
.
Append
(
aFromStr
)
;
aToStr
.
AppendLiteral
(
"
<
/
HTML
>
"
)
;
return
NS_OK
;
}
