#
import
<
UIKit
/
UIApplication
.
h
>
#
import
<
UIKit
/
UIScreen
.
h
>
#
import
<
UIKit
/
UIWindow
.
h
>
#
include
"
mozilla
/
Components
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
widget
/
ScreenManager
.
h
"
#
include
"
ScreenHelperUIKit
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
HeadlessScreenHelper
.
h
"
#
include
"
nsWindow
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
nsAppShell
*
nsAppShell
:
:
gAppShell
=
NULL
;
#
define
ALOG
(
args
.
.
.
)
\
fprintf
(
stderr
args
)
;
\
fprintf
(
stderr
"
\
n
"
)
interface
AppShellDelegate
:
NSObject
<
UIApplicationDelegate
>
{
}
property
(
strong
nonatomic
)
UIWindow
*
window
;
end
implementation
AppShellDelegate
-
(
BOOL
)
application
:
(
UIApplication
*
)
application
didFinishLaunchingWithOptions
:
(
NSDictionary
*
)
launchOptions
{
ALOG
(
"
[
AppShellDelegate
application
:
didFinishLaunchingWithOptions
:
]
"
)
;
return
YES
;
}
-
(
void
)
applicationWillTerminate
:
(
UIApplication
*
)
application
{
ALOG
(
"
[
AppShellDelegate
applicationWillTerminate
:
]
"
)
;
nsAppShell
:
:
gAppShell
-
>
WillTerminate
(
)
;
}
-
(
void
)
applicationDidBecomeActive
:
(
UIApplication
*
)
application
{
ALOG
(
"
[
AppShellDelegate
applicationDidBecomeActive
:
]
"
)
;
}
-
(
void
)
applicationWillResignActive
:
(
UIApplication
*
)
application
{
ALOG
(
"
[
AppShellDelegate
applicationWillResignActive
:
]
"
)
;
}
-
(
void
)
applicationDidReceiveMemoryWarning
:
(
UIApplication
*
)
application
{
ALOG
(
"
[
AppShellDelegate
applicationDidReceiveMemoryWarning
:
]
"
)
;
NS_NotifyOfMemoryPressure
(
MemoryPressureState
:
:
LowMemory
)
;
}
end
NS_IMETHODIMP
nsAppShell
:
:
ResumeNative
(
void
)
{
return
nsBaseAppShell
:
:
ResumeNative
(
)
;
}
nsAppShell
:
:
nsAppShell
(
)
:
mAutoreleasePool
(
NULL
)
mDelegate
(
NULL
)
mCFRunLoop
(
NULL
)
mCFRunLoopSource
(
NULL
)
mRunningEventLoop
(
false
)
mTerminated
(
false
)
mNotifiedWillTerminate
(
false
)
{
gAppShell
=
this
;
}
nsAppShell
:
:
~
nsAppShell
(
)
{
if
(
mAutoreleasePool
)
{
[
mAutoreleasePool
release
]
;
mAutoreleasePool
=
NULL
;
}
if
(
mCFRunLoop
)
{
if
(
mCFRunLoopSource
)
{
:
:
CFRunLoopRemoveSource
(
mCFRunLoop
mCFRunLoopSource
kCFRunLoopCommonModes
)
;
:
:
CFRelease
(
mCFRunLoopSource
)
;
}
:
:
CFRelease
(
mCFRunLoop
)
;
}
gAppShell
=
NULL
;
}
nsresult
nsAppShell
:
:
Init
(
)
{
mAutoreleasePool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
mCFRunLoop
=
[
[
NSRunLoop
currentRunLoop
]
getCFRunLoop
]
;
NS_ENSURE_STATE
(
mCFRunLoop
)
;
:
:
CFRetain
(
mCFRunLoop
)
;
CFRunLoopSourceContext
context
;
bzero
(
&
context
sizeof
(
context
)
)
;
context
.
info
=
this
;
context
.
perform
=
ProcessGeckoEvents
;
mCFRunLoopSource
=
:
:
CFRunLoopSourceCreate
(
kCFAllocatorDefault
0
&
context
)
;
NS_ENSURE_STATE
(
mCFRunLoopSource
)
;
:
:
CFRunLoopAddSource
(
mCFRunLoop
mCFRunLoopSource
kCFRunLoopCommonModes
)
;
hal
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
ScreenManager
&
screenManager
=
ScreenManager
:
:
GetSingleton
(
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
screenManager
.
SetHelper
(
mozilla
:
:
MakeUnique
<
HeadlessScreenHelper
>
(
)
)
;
}
else
{
screenManager
.
SetHelper
(
mozilla
:
:
MakeUnique
<
ScreenHelperUIKit
>
(
)
)
;
}
}
nsresult
rv
=
nsBaseAppShell
:
:
Init
(
)
;
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsServ
)
{
obsServ
-
>
AddObserver
(
this
"
profile
-
after
-
change
"
false
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsAppShell
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
bool
removeObserver
=
false
;
if
(
!
strcmp
(
aTopic
"
profile
-
after
-
change
"
)
)
{
nsCOMPtr
<
nsIAppStartup
>
appStartup
=
components
:
:
AppStartup
:
:
Service
(
)
;
if
(
appStartup
)
{
appStartup
-
>
EnterLastWindowClosingSurvivalArea
(
)
;
}
removeObserver
=
true
;
}
else
{
return
nsBaseAppShell
:
:
Observe
(
aSubject
aTopic
aData
)
;
}
if
(
removeObserver
)
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsServ
)
{
obsServ
-
>
RemoveObserver
(
this
aTopic
)
;
}
}
return
NS_OK
;
}
void
nsAppShell
:
:
ProcessGeckoEvents
(
void
*
aInfo
)
{
nsAppShell
*
self
=
static_cast
<
nsAppShell
*
>
(
aInfo
)
;
if
(
self
-
>
mRunningEventLoop
)
{
self
-
>
mRunningEventLoop
=
false
;
}
self
-
>
NativeEventCallback
(
)
;
self
-
>
Release
(
)
;
}
void
nsAppShell
:
:
WillTerminate
(
)
{
mNotifiedWillTerminate
=
true
;
if
(
mTerminated
)
return
;
mTerminated
=
true
;
NS_ProcessPendingEvents
(
NS_GetCurrentThread
(
)
)
;
nsBaseAppShell
:
:
Exit
(
)
;
}
void
nsAppShell
:
:
ScheduleNativeEventCallback
(
)
{
if
(
mTerminated
)
return
;
NS_ADDREF_THIS
(
)
;
:
:
CFRunLoopSourceSignal
(
mCFRunLoopSource
)
;
:
:
CFRunLoopWakeUp
(
mCFRunLoop
)
;
}
bool
nsAppShell
:
:
ProcessNextNativeEvent
(
bool
aMayWait
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mTerminated
)
return
false
;
bool
wasRunningEventLoop
=
mRunningEventLoop
;
mRunningEventLoop
=
aMayWait
;
NSString
*
currentMode
=
nil
;
NSDate
*
waitUntil
=
nil
;
if
(
aMayWait
)
waitUntil
=
[
NSDate
distantFuture
]
;
NSRunLoop
*
currentRunLoop
=
[
NSRunLoop
currentRunLoop
]
;
do
{
currentMode
=
[
currentRunLoop
currentMode
]
;
if
(
!
currentMode
)
currentMode
=
NSDefaultRunLoopMode
;
if
(
aMayWait
)
{
[
currentRunLoop
runMode
:
currentMode
beforeDate
:
waitUntil
]
;
}
else
{
[
currentRunLoop
acceptInputForMode
:
currentMode
beforeDate
:
waitUntil
]
;
}
}
while
(
mRunningEventLoop
)
;
mRunningEventLoop
=
wasRunningEventLoop
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
return
false
;
}
NS_IMETHODIMP
nsAppShell
:
:
Run
(
void
)
{
ALOG
(
"
nsAppShell
:
:
Run
"
)
;
nsresult
rv
=
NS_OK
;
if
(
XRE_UseNativeEventProcessing
(
)
)
{
char
argv
[
1
]
[
4
]
=
{
"
app
"
}
;
UIApplicationMain
(
1
(
char
*
*
)
argv
nil
"
AppShellDelegate
"
)
;
}
else
{
rv
=
nsBaseAppShell
:
:
Run
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsAppShell
:
:
Exit
(
void
)
{
if
(
mTerminated
)
return
NS_OK
;
mTerminated
=
true
;
return
nsBaseAppShell
:
:
Exit
(
)
;
}
