#
ifndef
mozilla_widget_IMEData_h_
#
define
mozilla_widget_IMEData_h_
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
Units
.
h
"
class
nsIWidget
;
namespace
mozilla
{
class
WritingMode
;
namespace
widget
{
struct
IMENotificationRequests
final
{
typedef
uint8_t
Notifications
;
enum
:
Notifications
{
NOTIFY_NOTHING
=
0
NOTIFY_TEXT_CHANGE
=
1
<
<
1
NOTIFY_POSITION_CHANGE
=
1
<
<
2
NOTIFY_MOUSE_BUTTON_EVENT_ON_CHAR
=
1
<
<
3
NOTIFY_DURING_DEACTIVE
=
1
<
<
7
NOTIFY_ALL
=
NOTIFY_TEXT_CHANGE
|
NOTIFY_POSITION_CHANGE
|
NOTIFY_MOUSE_BUTTON_EVENT_ON_CHAR
}
;
IMENotificationRequests
(
)
:
mWantUpdates
(
NOTIFY_NOTHING
)
{
}
explicit
IMENotificationRequests
(
Notifications
aWantUpdates
)
:
mWantUpdates
(
aWantUpdates
)
{
}
IMENotificationRequests
operator
|
(
const
IMENotificationRequests
&
aOther
)
const
{
return
IMENotificationRequests
(
aOther
.
mWantUpdates
|
mWantUpdates
)
;
}
IMENotificationRequests
&
operator
|
=
(
const
IMENotificationRequests
&
aOther
)
{
mWantUpdates
|
=
aOther
.
mWantUpdates
;
return
*
this
;
}
bool
operator
=
=
(
const
IMENotificationRequests
&
aOther
)
const
{
return
mWantUpdates
=
=
aOther
.
mWantUpdates
;
}
bool
WantTextChange
(
)
const
{
return
!
!
(
mWantUpdates
&
NOTIFY_TEXT_CHANGE
)
;
}
bool
WantPositionChanged
(
)
const
{
return
!
!
(
mWantUpdates
&
NOTIFY_POSITION_CHANGE
)
;
}
bool
WantChanges
(
)
const
{
return
WantTextChange
(
)
;
}
bool
WantMouseButtonEventOnChar
(
)
const
{
return
!
!
(
mWantUpdates
&
NOTIFY_MOUSE_BUTTON_EVENT_ON_CHAR
)
;
}
bool
WantDuringDeactive
(
)
const
{
return
!
!
(
mWantUpdates
&
NOTIFY_DURING_DEACTIVE
)
;
}
Notifications
mWantUpdates
;
}
;
struct
IMEState
final
{
enum
Enabled
{
DISABLED
ENABLED
PASSWORD
PLUGIN
UNKNOWN
}
;
Enabled
mEnabled
;
enum
Open
{
OPEN_STATE_NOT_SUPPORTED
DONT_CHANGE_OPEN_STATE
=
OPEN_STATE_NOT_SUPPORTED
OPEN
CLOSED
}
;
Open
mOpen
;
IMEState
(
)
:
mEnabled
(
ENABLED
)
mOpen
(
DONT_CHANGE_OPEN_STATE
)
{
}
explicit
IMEState
(
Enabled
aEnabled
Open
aOpen
=
DONT_CHANGE_OPEN_STATE
)
:
mEnabled
(
aEnabled
)
mOpen
(
aOpen
)
{
}
bool
IsEditable
(
)
const
{
return
mEnabled
=
=
ENABLED
|
|
mEnabled
=
=
PASSWORD
;
}
bool
MaybeEditable
(
)
const
{
return
IsEditable
(
)
|
|
mEnabled
=
=
PLUGIN
;
}
}
;
#
define
NS_ONLY_ONE_NATIVE_IME_CONTEXT
\
(
reinterpret_cast
<
void
*
>
(
static_cast
<
intptr_t
>
(
-
1
)
)
)
struct
NativeIMEContext
final
{
uintptr_t
mRawNativeIMEContext
;
uint64_t
mOriginProcessID
;
NativeIMEContext
(
)
:
mRawNativeIMEContext
(
0
)
mOriginProcessID
(
0
)
{
Init
(
nullptr
)
;
}
explicit
NativeIMEContext
(
nsIWidget
*
aWidget
)
:
mRawNativeIMEContext
(
0
)
mOriginProcessID
(
0
)
{
Init
(
aWidget
)
;
}
bool
IsValid
(
)
const
{
return
mRawNativeIMEContext
&
&
mOriginProcessID
!
=
static_cast
<
uintptr_t
>
(
-
1
)
;
}
void
Init
(
nsIWidget
*
aWidget
)
;
void
InitWithRawNativeIMEContext
(
const
void
*
aRawNativeIMEContext
)
{
InitWithRawNativeIMEContext
(
const_cast
<
void
*
>
(
aRawNativeIMEContext
)
)
;
}
void
InitWithRawNativeIMEContext
(
void
*
aRawNativeIMEContext
)
;
bool
operator
=
=
(
const
NativeIMEContext
&
aOther
)
const
{
return
mRawNativeIMEContext
=
=
aOther
.
mRawNativeIMEContext
&
&
mOriginProcessID
=
=
aOther
.
mOriginProcessID
;
}
bool
operator
!
=
(
const
NativeIMEContext
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
InputContext
final
{
InputContext
(
)
:
mOrigin
(
XRE_IsParentProcess
(
)
?
ORIGIN_MAIN
:
ORIGIN_CONTENT
)
mMayBeIMEUnaware
(
false
)
mHasHandledUserInput
(
false
)
mInPrivateBrowsing
(
false
)
{
}
void
ShutDown
(
)
{
mHTMLInputType
.
Truncate
(
)
;
mHTMLInputInputmode
.
Truncate
(
)
;
mActionHint
.
Truncate
(
)
;
}
bool
IsPasswordEditor
(
)
const
{
return
mHTMLInputType
.
LowerCaseEqualsLiteral
(
"
password
"
)
;
}
IMEState
mIMEState
;
nsString
mHTMLInputType
;
nsString
mHTMLInputInputmode
;
nsString
mActionHint
;
enum
Origin
{
ORIGIN_MAIN
ORIGIN_CONTENT
}
;
Origin
mOrigin
;
bool
mMayBeIMEUnaware
;
bool
mHasHandledUserInput
;
bool
mInPrivateBrowsing
;
bool
IsOriginMainProcess
(
)
const
{
return
mOrigin
=
=
ORIGIN_MAIN
;
}
bool
IsOriginContentProcess
(
)
const
{
return
mOrigin
=
=
ORIGIN_CONTENT
;
}
bool
IsOriginCurrentProcess
(
)
const
{
if
(
XRE_IsParentProcess
(
)
)
{
return
IsOriginMainProcess
(
)
;
}
return
IsOriginContentProcess
(
)
;
}
}
;
const
char
*
ToChar
(
InputContext
:
:
Origin
aOrigin
)
;
struct
InputContextAction
final
{
enum
Cause
{
CAUSE_UNKNOWN
CAUSE_UNKNOWN_CHROME
CAUSE_KEY
CAUSE_MOUSE
CAUSE_TOUCH
CAUSE_LONGPRESS
CAUSE_UNKNOWN_DURING_NON_KEYBOARD_INPUT
CAUSE_UNKNOWN_DURING_KEYBOARD_INPUT
}
;
Cause
mCause
;
enum
FocusChange
{
FOCUS_NOT_CHANGED
GOT_FOCUS
LOST_FOCUS
MENU_GOT_PSEUDO_FOCUS
MENU_LOST_PSEUDO_FOCUS
WIDGET_CREATED
}
;
FocusChange
mFocusChange
;
bool
ContentGotFocusByTrustedCause
(
)
const
{
return
(
mFocusChange
=
=
GOT_FOCUS
&
&
mCause
!
=
CAUSE_UNKNOWN
)
;
}
bool
UserMightRequestOpenVKB
(
)
const
{
if
(
mFocusChange
!
=
FOCUS_NOT_CHANGED
)
{
return
false
;
}
switch
(
mCause
)
{
case
CAUSE_MOUSE
:
case
CAUSE_TOUCH
:
case
CAUSE_UNKNOWN_DURING_NON_KEYBOARD_INPUT
:
return
true
;
default
:
return
false
;
}
}
static
bool
IsHandlingUserInput
(
Cause
aCause
)
{
switch
(
aCause
)
{
case
CAUSE_KEY
:
case
CAUSE_MOUSE
:
case
CAUSE_TOUCH
:
case
CAUSE_LONGPRESS
:
case
CAUSE_UNKNOWN_DURING_NON_KEYBOARD_INPUT
:
case
CAUSE_UNKNOWN_DURING_KEYBOARD_INPUT
:
return
true
;
default
:
return
false
;
}
}
bool
IsHandlingUserInput
(
)
const
{
return
IsHandlingUserInput
(
mCause
)
;
}
InputContextAction
(
)
:
mCause
(
CAUSE_UNKNOWN
)
mFocusChange
(
FOCUS_NOT_CHANGED
)
{
}
explicit
InputContextAction
(
Cause
aCause
FocusChange
aFocusChange
=
FOCUS_NOT_CHANGED
)
:
mCause
(
aCause
)
mFocusChange
(
aFocusChange
)
{
}
}
;
typedef
int8_t
IMEMessageType
;
enum
IMEMessage
:
IMEMessageType
{
NOTIFY_IME_OF_NOTHING
NOTIFY_IME_OF_FOCUS
NOTIFY_IME_OF_BLUR
NOTIFY_IME_OF_SELECTION_CHANGE
NOTIFY_IME_OF_TEXT_CHANGE
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
NOTIFY_IME_OF_POSITION_CHANGE
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
REQUEST_TO_COMMIT_COMPOSITION
REQUEST_TO_CANCEL_COMPOSITION
}
;
const
char
*
ToChar
(
IMEMessage
aIMEMessage
)
;
struct
IMENotification
final
{
IMENotification
(
)
:
mMessage
(
NOTIFY_IME_OF_NOTHING
)
mSelectionChangeData
(
)
{
}
IMENotification
(
const
IMENotification
&
aOther
)
:
mMessage
(
NOTIFY_IME_OF_NOTHING
)
{
Assign
(
aOther
)
;
}
~
IMENotification
(
)
{
Clear
(
)
;
}
MOZ_IMPLICIT
IMENotification
(
IMEMessage
aMessage
)
:
mMessage
(
aMessage
)
mSelectionChangeData
(
)
{
switch
(
aMessage
)
{
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
mSelectionChangeData
.
mString
=
new
nsString
(
)
;
mSelectionChangeData
.
Clear
(
)
;
break
;
case
NOTIFY_IME_OF_TEXT_CHANGE
:
mTextChangeData
.
Clear
(
)
;
break
;
case
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
:
mMouseButtonEventData
.
mEventMessage
=
eVoidEvent
;
mMouseButtonEventData
.
mOffset
=
UINT32_MAX
;
mMouseButtonEventData
.
mCursorPos
.
Set
(
nsIntPoint
(
0
0
)
)
;
mMouseButtonEventData
.
mCharRect
.
Set
(
nsIntRect
(
0
0
0
0
)
)
;
mMouseButtonEventData
.
mButton
=
-
1
;
mMouseButtonEventData
.
mButtons
=
0
;
mMouseButtonEventData
.
mModifiers
=
0
;
break
;
default
:
break
;
}
}
void
Assign
(
const
IMENotification
&
aOther
)
{
bool
changingMessage
=
mMessage
!
=
aOther
.
mMessage
;
if
(
changingMessage
)
{
Clear
(
)
;
mMessage
=
aOther
.
mMessage
;
}
switch
(
mMessage
)
{
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
if
(
changingMessage
)
{
mSelectionChangeData
.
mString
=
new
nsString
(
)
;
}
mSelectionChangeData
.
Assign
(
aOther
.
mSelectionChangeData
)
;
break
;
case
NOTIFY_IME_OF_TEXT_CHANGE
:
mTextChangeData
=
aOther
.
mTextChangeData
;
break
;
case
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
:
mMouseButtonEventData
=
aOther
.
mMouseButtonEventData
;
break
;
default
:
break
;
}
}
IMENotification
&
operator
=
(
const
IMENotification
&
aOther
)
{
Assign
(
aOther
)
;
return
*
this
;
}
void
Clear
(
)
{
if
(
mMessage
=
=
NOTIFY_IME_OF_SELECTION_CHANGE
)
{
MOZ_ASSERT
(
mSelectionChangeData
.
mString
)
;
delete
mSelectionChangeData
.
mString
;
mSelectionChangeData
.
mString
=
nullptr
;
}
mMessage
=
NOTIFY_IME_OF_NOTHING
;
}
bool
HasNotification
(
)
const
{
return
mMessage
!
=
NOTIFY_IME_OF_NOTHING
;
}
void
MergeWith
(
const
IMENotification
&
aNotification
)
{
switch
(
mMessage
)
{
case
NOTIFY_IME_OF_NOTHING
:
MOZ_ASSERT
(
aNotification
.
mMessage
!
=
NOTIFY_IME_OF_NOTHING
)
;
Assign
(
aNotification
)
;
break
;
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
MOZ_ASSERT
(
aNotification
.
mMessage
=
=
NOTIFY_IME_OF_SELECTION_CHANGE
)
;
mSelectionChangeData
.
Assign
(
aNotification
.
mSelectionChangeData
)
;
break
;
case
NOTIFY_IME_OF_TEXT_CHANGE
:
MOZ_ASSERT
(
aNotification
.
mMessage
=
=
NOTIFY_IME_OF_TEXT_CHANGE
)
;
mTextChangeData
+
=
aNotification
.
mTextChangeData
;
break
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
MOZ_ASSERT
(
aNotification
.
mMessage
=
=
mMessage
)
;
break
;
default
:
MOZ_CRASH
(
"
Merging
notification
isn
'
t
supported
"
)
;
break
;
}
}
IMEMessage
mMessage
;
struct
Point
{
int32_t
mX
;
int32_t
mY
;
void
Set
(
const
nsIntPoint
&
aPoint
)
{
mX
=
aPoint
.
x
;
mY
=
aPoint
.
y
;
}
nsIntPoint
AsIntPoint
(
)
const
{
return
nsIntPoint
(
mX
mY
)
;
}
}
;
struct
Rect
{
int32_t
mX
;
int32_t
mY
;
int32_t
mWidth
;
int32_t
mHeight
;
void
Set
(
const
nsIntRect
&
aRect
)
{
aRect
.
GetRect
(
&
mX
&
mY
&
mWidth
&
mHeight
)
;
}
nsIntRect
AsIntRect
(
)
const
{
return
nsIntRect
(
mX
mY
mWidth
mHeight
)
;
}
}
;
struct
SelectionChangeDataBase
{
uint32_t
mOffset
;
nsString
*
mString
;
uint8_t
mWritingMode
;
bool
mReversed
;
bool
mCausedByComposition
;
bool
mCausedBySelectionEvent
;
bool
mOccurredDuringComposition
;
void
SetWritingMode
(
const
WritingMode
&
aWritingMode
)
;
WritingMode
GetWritingMode
(
)
const
;
uint32_t
StartOffset
(
)
const
{
return
mOffset
+
(
mReversed
?
Length
(
)
:
0
)
;
}
uint32_t
EndOffset
(
)
const
{
return
mOffset
+
(
mReversed
?
0
:
Length
(
)
)
;
}
const
nsString
&
String
(
)
const
{
return
*
mString
;
}
uint32_t
Length
(
)
const
{
return
mString
-
>
Length
(
)
;
}
bool
IsInInt32Range
(
)
const
{
return
mOffset
+
Length
(
)
<
=
INT32_MAX
;
}
bool
IsCollapsed
(
)
const
{
return
mString
-
>
IsEmpty
(
)
;
}
void
ClearSelectionData
(
)
{
mOffset
=
UINT32_MAX
;
mString
-
>
Truncate
(
)
;
mWritingMode
=
0
;
mReversed
=
false
;
}
void
Clear
(
)
{
ClearSelectionData
(
)
;
mCausedByComposition
=
false
;
mCausedBySelectionEvent
=
false
;
mOccurredDuringComposition
=
false
;
}
bool
IsValid
(
)
const
{
return
mOffset
!
=
UINT32_MAX
;
}
void
Assign
(
const
SelectionChangeDataBase
&
aOther
)
{
mOffset
=
aOther
.
mOffset
;
*
mString
=
aOther
.
String
(
)
;
mWritingMode
=
aOther
.
mWritingMode
;
mReversed
=
aOther
.
mReversed
;
AssignReason
(
aOther
.
mCausedByComposition
aOther
.
mCausedBySelectionEvent
aOther
.
mOccurredDuringComposition
)
;
}
void
AssignReason
(
bool
aCausedByComposition
bool
aCausedBySelectionEvent
bool
aOccurredDuringComposition
)
{
mCausedByComposition
=
aCausedByComposition
;
mCausedBySelectionEvent
=
aCausedBySelectionEvent
;
mOccurredDuringComposition
=
aOccurredDuringComposition
;
}
}
;
struct
SelectionChangeData
final
:
public
SelectionChangeDataBase
{
SelectionChangeData
(
)
{
mString
=
&
mStringInstance
;
Clear
(
)
;
}
explicit
SelectionChangeData
(
const
SelectionChangeDataBase
&
aOther
)
{
mString
=
&
mStringInstance
;
Assign
(
aOther
)
;
}
SelectionChangeData
(
const
SelectionChangeData
&
aOther
)
{
mString
=
&
mStringInstance
;
Assign
(
aOther
)
;
}
SelectionChangeData
&
operator
=
(
const
SelectionChangeDataBase
&
aOther
)
{
mString
=
&
mStringInstance
;
Assign
(
aOther
)
;
return
*
this
;
}
SelectionChangeData
&
operator
=
(
const
SelectionChangeData
&
aOther
)
{
mString
=
&
mStringInstance
;
Assign
(
aOther
)
;
return
*
this
;
}
private
:
nsString
mStringInstance
;
}
;
struct
TextChangeDataBase
{
uint32_t
mStartOffset
;
uint32_t
mRemovedEndOffset
;
uint32_t
mAddedEndOffset
;
bool
mCausedOnlyByComposition
;
bool
mIncludingChangesDuringComposition
;
bool
mIncludingChangesWithoutComposition
;
uint32_t
OldLength
(
)
const
{
MOZ_ASSERT
(
IsValid
(
)
)
;
return
mRemovedEndOffset
-
mStartOffset
;
}
uint32_t
NewLength
(
)
const
{
MOZ_ASSERT
(
IsValid
(
)
)
;
return
mAddedEndOffset
-
mStartOffset
;
}
int64_t
Difference
(
)
const
{
return
mAddedEndOffset
-
mRemovedEndOffset
;
}
bool
IsInInt32Range
(
)
const
{
MOZ_ASSERT
(
IsValid
(
)
)
;
return
mStartOffset
<
=
INT32_MAX
&
&
mRemovedEndOffset
<
=
INT32_MAX
&
&
mAddedEndOffset
<
=
INT32_MAX
;
}
bool
IsValid
(
)
const
{
return
!
(
mStartOffset
=
=
UINT32_MAX
&
&
!
mRemovedEndOffset
&
&
!
mAddedEndOffset
)
;
}
void
Clear
(
)
{
mStartOffset
=
UINT32_MAX
;
mRemovedEndOffset
=
mAddedEndOffset
=
0
;
}
void
MergeWith
(
const
TextChangeDataBase
&
aOther
)
;
TextChangeDataBase
&
operator
+
=
(
const
TextChangeDataBase
&
aOther
)
{
MergeWith
(
aOther
)
;
return
*
this
;
}
#
ifdef
DEBUG
void
Test
(
)
;
#
endif
}
;
struct
TextChangeData
:
public
TextChangeDataBase
{
TextChangeData
(
)
{
Clear
(
)
;
}
TextChangeData
(
uint32_t
aStartOffset
uint32_t
aRemovedEndOffset
uint32_t
aAddedEndOffset
bool
aCausedByComposition
bool
aOccurredDuringComposition
)
{
MOZ_ASSERT
(
aRemovedEndOffset
>
=
aStartOffset
"
removed
end
offset
must
not
be
smaller
than
start
offset
"
)
;
MOZ_ASSERT
(
aAddedEndOffset
>
=
aStartOffset
"
added
end
offset
must
not
be
smaller
than
start
offset
"
)
;
mStartOffset
=
aStartOffset
;
mRemovedEndOffset
=
aRemovedEndOffset
;
mAddedEndOffset
=
aAddedEndOffset
;
mCausedOnlyByComposition
=
aCausedByComposition
;
mIncludingChangesDuringComposition
=
!
aCausedByComposition
&
&
aOccurredDuringComposition
;
mIncludingChangesWithoutComposition
=
!
aCausedByComposition
&
&
!
aOccurredDuringComposition
;
}
}
;
struct
MouseButtonEventData
{
EventMessage
mEventMessage
;
uint32_t
mOffset
;
Point
mCursorPos
;
Rect
mCharRect
;
int16_t
mButton
;
int16_t
mButtons
;
Modifiers
mModifiers
;
}
;
union
{
SelectionChangeDataBase
mSelectionChangeData
;
TextChangeDataBase
mTextChangeData
;
MouseButtonEventData
mMouseButtonEventData
;
}
;
void
SetData
(
const
SelectionChangeDataBase
&
aSelectionChangeData
)
{
MOZ_RELEASE_ASSERT
(
mMessage
=
=
NOTIFY_IME_OF_SELECTION_CHANGE
)
;
mSelectionChangeData
.
Assign
(
aSelectionChangeData
)
;
}
void
SetData
(
const
TextChangeDataBase
&
aTextChangeData
)
{
MOZ_RELEASE_ASSERT
(
mMessage
=
=
NOTIFY_IME_OF_TEXT_CHANGE
)
;
mTextChangeData
=
aTextChangeData
;
}
}
;
struct
CandidateWindowPosition
{
LayoutDeviceIntPoint
mPoint
;
LayoutDeviceIntRect
mRect
;
bool
mExcludeRect
;
}
;
}
}
#
endif
