#
include
<
android
/
log
.
h
>
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
poll
.
h
>
#
include
<
sys
/
sysinfo
.
h
>
#
include
"
GonkMemoryPressureMonitoring
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
FileUtils
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProcessPriorityManager
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsMemoryPressure
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
define
LOG
(
args
.
.
.
)
\
__android_log_print
(
ANDROID_LOG_INFO
"
GonkMemoryPressure
"
#
#
args
)
using
namespace
mozilla
;
namespace
{
class
MemoryPressureWatcher
final
:
public
nsIRunnable
public
nsIObserver
{
public
:
MemoryPressureWatcher
(
)
:
mMonitor
(
"
MemoryPressureWatcher
"
)
mLowMemTriggerKB
(
0
)
mPageSize
(
0
)
mShuttingDown
(
false
)
mTriggerFd
(
-
1
)
mShutdownPipeRead
(
-
1
)
mShutdownPipeWrite
(
-
1
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
nsresult
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_STATE
(
os
)
;
os
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
mPageSize
=
sysconf
(
_SC_PAGESIZE
)
;
ReadPrefs
(
)
;
nsresult
rv
=
OpenFiles
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetLowMemTrigger
(
mSoftLowMemTriggerKB
)
;
return
NS_OK
;
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
;
LOG
(
"
Observed
XPCOM
shutdown
.
"
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mShuttingDown
=
true
;
mMonitor
.
Notify
(
)
;
int
rv
;
do
{
uint32_t
dummy
=
0
;
rv
=
write
(
mShutdownPipeWrite
&
dummy
sizeof
(
dummy
)
)
;
}
while
(
rv
=
=
-
1
&
&
errno
=
=
EINTR
)
;
return
NS_OK
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
int
triggerResetTimeout
=
-
1
;
bool
memoryPressure
;
nsresult
rv
=
CheckForMemoryPressure
(
&
memoryPressure
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
true
)
{
struct
pollfd
pollfds
[
2
]
;
pollfds
[
0
]
.
fd
=
mTriggerFd
;
pollfds
[
0
]
.
events
=
POLLPRI
;
pollfds
[
1
]
.
fd
=
mShutdownPipeRead
;
pollfds
[
1
]
.
events
=
POLLIN
;
int
pollRv
=
MOZ_TEMP_FAILURE_RETRY
(
poll
(
pollfds
ArrayLength
(
pollfds
)
triggerResetTimeout
)
)
;
if
(
pollRv
=
=
0
)
{
triggerResetTimeout
=
AdjustTrigger
(
triggerResetTimeout
)
;
continue
;
}
if
(
pollfds
[
1
]
.
revents
)
{
LOG
(
"
shutting
down
(
1
)
"
)
;
return
NS_OK
;
}
if
(
!
(
pollfds
[
0
]
.
revents
&
POLLPRI
)
)
{
LOG
(
"
Unexpected
revents
value
after
poll
(
)
:
%
d
.
"
"
Shutting
down
GonkMemoryPressureMonitoring
.
"
pollfds
[
0
]
.
revents
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
DispatchMemoryPressure
(
MemPressure_New
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mLowMemTriggerKB
>
mHardLowMemTriggerKB
)
{
SetLowMemTrigger
(
mHardLowMemTriggerKB
)
;
}
do
{
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mShuttingDown
)
{
LOG
(
"
shutting
down
(
2
)
"
)
;
return
NS_OK
;
}
mMonitor
.
Wait
(
PR_MillisecondsToInterval
(
mPollMS
)
)
;
}
LOG
(
"
Checking
to
see
if
memory
pressure
is
over
.
"
)
;
rv
=
CheckForMemoryPressure
(
&
memoryPressure
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
memoryPressure
)
{
rv
=
DispatchMemoryPressure
(
MemPressure_Ongoing
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
continue
;
}
}
while
(
false
)
;
if
(
XRE_IsParentProcess
(
)
)
{
triggerResetTimeout
=
mPollMS
*
2
;
}
LOG
(
"
Memory
pressure
is
over
.
"
)
;
}
return
NS_OK
;
}
protected
:
~
MemoryPressureWatcher
(
)
{
}
private
:
void
ReadPrefs
(
)
{
Preferences
:
:
AddUintVarCache
(
&
mPollMS
"
gonk
.
systemMemoryPressureRecoveryPollMS
"
5000
)
;
Preferences
:
:
AddUintVarCache
(
&
mSoftLowMemTriggerKB
"
gonk
.
notifySoftLowMemUnderKB
"
43008
)
;
Preferences
:
:
AddUintVarCache
(
&
mHardLowMemTriggerKB
"
gonk
.
notifyHardLowMemUnderKB
"
14336
)
;
}
nsresult
OpenFiles
(
)
{
mTriggerFd
=
open
(
"
/
sys
/
kernel
/
mm
/
lowmemkiller
/
notify_trigger_active
"
O_RDONLY
|
O_CLOEXEC
)
;
NS_ENSURE_STATE
(
mTriggerFd
!
=
-
1
)
;
int
pipes
[
2
]
;
NS_ENSURE_STATE
(
!
pipe
(
pipes
)
)
;
mShutdownPipeRead
=
pipes
[
0
]
;
mShutdownPipeWrite
=
pipes
[
1
]
;
return
NS_OK
;
}
void
SetLowMemTrigger
(
uint32_t
aValue
)
{
if
(
XRE_IsParentProcess
(
)
)
{
nsPrintfCString
str
(
"
%
ld
"
(
aValue
*
1024
)
/
mPageSize
)
;
if
(
WriteSysFile
(
"
/
sys
/
module
/
lowmemorykiller
/
parameters
/
notify_trigger
"
str
.
get
(
)
)
)
{
mLowMemTriggerKB
=
aValue
;
}
}
}
nsresult
CheckForMemoryPressure
(
bool
*
aOut
)
{
*
aOut
=
false
;
lseek
(
mTriggerFd
0
SEEK_SET
)
;
char
buf
[
2
]
;
int
nread
=
MOZ_TEMP_FAILURE_RETRY
(
read
(
mTriggerFd
buf
sizeof
(
buf
)
)
)
;
NS_ENSURE_STATE
(
nread
=
=
2
)
;
*
aOut
=
(
buf
[
0
]
=
=
'
1
'
)
;
return
NS_OK
;
}
int
AdjustTrigger
(
int
timeout
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
-
1
;
}
struct
sysinfo
info
;
int
rv
=
sysinfo
(
&
info
)
;
if
(
rv
<
0
)
{
return
-
1
;
}
size_t
freeMemory
=
(
info
.
freeram
*
info
.
mem_unit
)
/
1024
;
if
(
freeMemory
>
mSoftLowMemTriggerKB
)
{
SetLowMemTrigger
(
mSoftLowMemTriggerKB
)
;
return
-
1
;
}
return
std
:
:
min
(
86400000
timeout
*
2
)
;
}
nsresult
DispatchMemoryPressure
(
MemoryPressureState
state
)
{
if
(
ProcessPriorityManager
:
:
AnyProcessHasHighPriority
(
)
)
{
return
NS_OK
;
}
return
NS_DispatchMemoryPressure
(
state
)
;
}
Monitor
mMonitor
;
uint32_t
mPollMS
;
uint32_t
mSoftLowMemTriggerKB
;
uint32_t
mHardLowMemTriggerKB
;
uint32_t
mLowMemTriggerKB
;
size_t
mPageSize
;
bool
mShuttingDown
;
ScopedClose
mTriggerFd
;
ScopedClose
mShutdownPipeRead
;
ScopedClose
mShutdownPipeWrite
;
}
;
NS_IMPL_ISUPPORTS
(
MemoryPressureWatcher
nsIRunnable
nsIObserver
)
;
}
namespace
mozilla
{
void
InitGonkMemoryPressureMonitoring
(
)
{
RefPtr
<
MemoryPressureWatcher
>
memoryPressureWatcher
=
new
MemoryPressureWatcher
(
)
;
NS_ENSURE_SUCCESS_VOID
(
memoryPressureWatcher
-
>
Init
(
)
)
;
nsCOMPtr
<
nsIThread
>
thread
;
NS_NewNamedThread
(
"
MemoryPressure
"
getter_AddRefs
(
thread
)
memoryPressureWatcher
)
;
}
}
