#
define
LOG_TAG
"
FakeSurfaceComposer
"
#
include
<
stdint
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
errno
.
h
>
#
include
<
cutils
/
atomic
.
h
>
#
include
<
cutils
/
log
.
h
>
#
include
<
cutils
/
properties
.
h
>
#
include
<
private
/
android_filesystem_config
.
h
>
#
include
<
gui
/
IDisplayEventConnection
.
h
>
#
include
<
gui
/
GraphicBufferAlloc
.
h
>
#
include
<
gui
/
Surface
.
h
>
#
include
<
ui
/
DisplayInfo
.
h
>
#
if
ANDROID_VERSION
>
=
21
#
include
<
ui
/
Rect
.
h
>
#
endif
#
include
"
.
.
/
libdisplay
/
GonkDisplay
.
h
"
#
include
"
.
.
/
nsScreenManagerGonk
.
h
"
#
include
"
FakeSurfaceComposer
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
namespace
android
{
void
FakeSurfaceComposer
:
:
instantiate
(
)
{
defaultServiceManager
(
)
-
>
addService
(
String16
(
"
SurfaceFlinger
"
)
new
FakeSurfaceComposer
(
)
)
;
}
FakeSurfaceComposer
:
:
FakeSurfaceComposer
(
)
:
BnSurfaceComposer
(
)
{
}
FakeSurfaceComposer
:
:
~
FakeSurfaceComposer
(
)
{
}
status_t
FakeSurfaceComposer
:
:
onTransact
(
uint32_t
code
const
Parcel
&
data
Parcel
*
reply
uint32_t
flags
)
{
switch
(
code
)
{
case
CREATE_CONNECTION
:
case
CREATE_DISPLAY
:
case
SET_TRANSACTION_STATE
:
case
CAPTURE_SCREEN
:
{
IPCThreadState
*
ipc
=
IPCThreadState
:
:
self
(
)
;
const
int
pid
=
ipc
-
>
getCallingPid
(
)
;
const
int
uid
=
ipc
-
>
getCallingUid
(
)
;
if
(
uid
!
=
AID_ROOT
)
{
ALOGE
(
"
Permission
Denial
:
"
"
can
'
t
access
SurfaceFlinger
pid
=
%
d
uid
=
%
d
"
pid
uid
)
;
return
PERMISSION_DENIED
;
}
break
;
}
}
return
BnSurfaceComposer
:
:
onTransact
(
code
data
reply
flags
)
;
}
sp
<
ISurfaceComposerClient
>
FakeSurfaceComposer
:
:
createConnection
(
)
{
return
nullptr
;
}
sp
<
IGraphicBufferAlloc
>
FakeSurfaceComposer
:
:
createGraphicBufferAlloc
(
)
{
sp
<
GraphicBufferAlloc
>
gba
(
new
GraphicBufferAlloc
(
)
)
;
return
gba
;
}
class
DestroyDisplayRunnable
:
public
nsRunnable
{
public
:
DestroyDisplayRunnable
(
FakeSurfaceComposer
*
aComposer
ssize_t
aIndex
)
:
mComposer
(
aComposer
)
mIndex
(
aIndex
)
{
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
Mutex
:
:
Autolock
_l
(
mComposer
-
>
mStateLock
)
;
RefPtr
<
nsScreenManagerGonk
>
screenManager
=
nsScreenManagerGonk
:
:
GetInstance
(
)
;
screenManager
-
>
RemoveScreen
(
GonkDisplay
:
:
DISPLAY_VIRTUAL
)
;
mComposer
-
>
mDisplays
.
removeItemsAt
(
mIndex
)
;
return
NS_OK
;
}
sp
<
FakeSurfaceComposer
>
mComposer
;
ssize_t
mIndex
;
}
;
sp
<
IBinder
>
FakeSurfaceComposer
:
:
createDisplay
(
const
String8
&
displayName
bool
secure
)
{
#
if
ANDROID_VERSION
>
=
19
class
DisplayToken
:
public
BBinder
{
sp
<
FakeSurfaceComposer
>
composer
;
virtual
~
DisplayToken
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
Mutex
:
:
Autolock
_l
(
composer
-
>
mStateLock
)
;
ssize_t
idx
=
composer
-
>
mDisplays
.
indexOfKey
(
this
)
;
if
(
idx
>
=
0
)
{
nsCOMPtr
<
nsIRunnable
>
task
(
new
DestroyDisplayRunnable
(
composer
.
get
(
)
idx
)
)
;
NS_DispatchToMainThread
(
task
)
;
}
}
public
:
DisplayToken
(
const
sp
<
FakeSurfaceComposer
>
&
composer
)
:
composer
(
composer
)
{
}
}
;
sp
<
BBinder
>
token
=
new
DisplayToken
(
this
)
;
Mutex
:
:
Autolock
_l
(
mStateLock
)
;
DisplayDeviceState
info
(
HWC_DISPLAY_VIRTUAL
)
;
info
.
displayName
=
displayName
;
info
.
displayId
=
GonkDisplay
:
:
DISPLAY_VIRTUAL
;
info
.
isSecure
=
secure
;
mDisplays
.
add
(
token
info
)
;
return
token
;
#
else
return
nullptr
;
#
endif
}
#
if
ANDROID_VERSION
>
=
19
void
FakeSurfaceComposer
:
:
destroyDisplay
(
const
sp
<
IBinder
>
&
display
)
{
Mutex
:
:
Autolock
_l
(
mStateLock
)
;
ssize_t
idx
=
mDisplays
.
indexOfKey
(
display
)
;
if
(
idx
<
0
)
{
ALOGW
(
"
destroyDisplay
:
invalid
display
token
"
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
task
(
new
DestroyDisplayRunnable
(
this
idx
)
)
;
NS_DispatchToMainThread
(
task
)
;
}
#
endif
sp
<
IBinder
>
FakeSurfaceComposer
:
:
getBuiltInDisplay
(
int32_t
id
)
{
if
(
uint32_t
(
id
)
!
=
HWC_DISPLAY_PRIMARY
)
{
return
NULL
;
}
if
(
!
mPrimaryDisplay
.
get
(
)
)
{
mPrimaryDisplay
=
new
BBinder
(
)
;
}
return
mPrimaryDisplay
;
}
void
FakeSurfaceComposer
:
:
setTransactionState
(
const
Vector
<
ComposerState
>
&
state
const
Vector
<
DisplayState
>
&
displays
uint32_t
flags
)
{
Mutex
:
:
Autolock
_l
(
mStateLock
)
;
size_t
count
=
displays
.
size
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
const
DisplayState
&
s
(
displays
[
i
]
)
;
setDisplayStateLocked
(
s
)
;
}
}
uint32_t
FakeSurfaceComposer
:
:
setDisplayStateLocked
(
const
DisplayState
&
s
)
{
ssize_t
dpyIdx
=
mDisplays
.
indexOfKey
(
s
.
token
)
;
if
(
dpyIdx
<
0
)
{
return
0
;
}
uint32_t
flags
=
0
;
DisplayDeviceState
&
disp
(
mDisplays
.
editValueAt
(
dpyIdx
)
)
;
if
(
!
disp
.
isValid
(
)
)
{
return
0
;
}
const
uint32_t
what
=
s
.
what
;
if
(
what
&
DisplayState
:
:
eSurfaceChanged
)
{
if
(
disp
.
surface
-
>
asBinder
(
)
!
=
s
.
surface
-
>
asBinder
(
)
)
{
disp
.
surface
=
s
.
surface
;
flags
|
=
eDisplayTransactionNeeded
;
}
}
if
(
what
&
DisplayState
:
:
eLayerStackChanged
)
{
if
(
disp
.
layerStack
!
=
s
.
layerStack
)
{
disp
.
layerStack
=
s
.
layerStack
;
flags
|
=
eDisplayTransactionNeeded
;
}
}
if
(
what
&
DisplayState
:
:
eDisplayProjectionChanged
)
{
if
(
disp
.
orientation
!
=
s
.
orientation
)
{
disp
.
orientation
=
s
.
orientation
;
flags
|
=
eDisplayTransactionNeeded
;
}
if
(
disp
.
frame
!
=
s
.
frame
)
{
disp
.
frame
=
s
.
frame
;
flags
|
=
eDisplayTransactionNeeded
;
}
if
(
disp
.
viewport
!
=
s
.
viewport
)
{
disp
.
viewport
=
s
.
viewport
;
flags
|
=
eDisplayTransactionNeeded
;
}
}
#
if
ANDROID_VERSION
>
=
21
if
(
what
&
DisplayState
:
:
eDisplaySizeChanged
)
{
if
(
disp
.
width
!
=
s
.
width
)
{
disp
.
width
=
s
.
width
;
flags
|
=
eDisplayTransactionNeeded
;
}
if
(
disp
.
height
!
=
s
.
height
)
{
disp
.
height
=
s
.
height
;
flags
|
=
eDisplayTransactionNeeded
;
}
}
#
endif
if
(
what
&
DisplayState
:
:
eSurfaceChanged
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
&
]
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
RefPtr
<
nsScreenManagerGonk
>
screenManager
=
nsScreenManagerGonk
:
:
GetInstance
(
)
;
screenManager
-
>
AddScreen
(
GonkDisplay
:
:
DISPLAY_VIRTUAL
disp
.
surface
.
get
(
)
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
NS_DISPATCH_SYNC
)
;
}
return
flags
;
}
void
FakeSurfaceComposer
:
:
bootFinished
(
)
{
}
bool
FakeSurfaceComposer
:
:
authenticateSurfaceTexture
(
const
sp
<
IGraphicBufferProducer
>
&
bufferProducer
)
const
{
return
false
;
}
sp
<
IDisplayEventConnection
>
FakeSurfaceComposer
:
:
createDisplayEventConnection
(
)
{
return
nullptr
;
}
class
Barrier
{
public
:
inline
Barrier
(
)
:
state
(
CLOSED
)
{
}
inline
~
Barrier
(
)
{
}
void
open
(
)
{
Mutex
:
:
Autolock
_l
(
lock
)
;
state
=
OPENED
;
cv
.
broadcast
(
)
;
}
void
close
(
)
{
Mutex
:
:
Autolock
_l
(
lock
)
;
state
=
CLOSED
;
}
void
wait
(
)
const
{
Mutex
:
:
Autolock
_l
(
lock
)
;
while
(
state
=
=
CLOSED
)
{
cv
.
wait
(
lock
)
;
}
}
private
:
enum
{
OPENED
CLOSED
}
;
mutable
Mutex
lock
;
mutable
Condition
cv
;
volatile
int
state
;
}
;
class
GraphicProducerWrapper
:
public
BBinder
public
MessageHandler
{
sp
<
IGraphicBufferProducer
>
impl
;
sp
<
Looper
>
looper
;
status_t
result
;
bool
exitPending
;
bool
exitRequested
;
mutable
Barrier
barrier
;
volatile
int32_t
memoryBarrier
;
uint32_t
code
;
Parcel
const
*
data
;
Parcel
*
reply
;
enum
{
MSG_API_CALL
MSG_EXIT
}
;
virtual
status_t
transact
(
uint32_t
code
const
Parcel
&
data
Parcel
*
reply
uint32_t
flags
)
{
this
-
>
code
=
code
;
this
-
>
data
=
&
data
;
this
-
>
reply
=
reply
;
android_atomic_acquire_store
(
0
&
memoryBarrier
)
;
if
(
exitPending
)
{
handleMessage
(
Message
(
MSG_API_CALL
)
)
;
}
else
{
barrier
.
close
(
)
;
looper
-
>
sendMessage
(
this
Message
(
MSG_API_CALL
)
)
;
barrier
.
wait
(
)
;
}
return
NO_ERROR
;
}
virtual
void
handleMessage
(
const
Message
&
message
)
{
android_atomic_release_load
(
&
memoryBarrier
)
;
if
(
message
.
what
=
=
MSG_API_CALL
)
{
impl
-
>
asBinder
(
)
-
>
transact
(
code
data
[
0
]
reply
)
;
barrier
.
open
(
)
;
}
else
if
(
message
.
what
=
=
MSG_EXIT
)
{
exitRequested
=
true
;
}
}
public
:
GraphicProducerWrapper
(
const
sp
<
IGraphicBufferProducer
>
&
impl
)
:
impl
(
impl
)
looper
(
new
Looper
(
true
)
)
result
(
NO_ERROR
)
exitPending
(
false
)
exitRequested
(
false
)
{
}
status_t
waitForResponse
(
)
{
do
{
looper
-
>
pollOnce
(
-
1
)
;
}
while
(
!
exitRequested
)
;
return
result
;
}
void
exit
(
status_t
result
)
{
this
-
>
result
=
result
;
exitPending
=
true
;
looper
-
>
sendMessage
(
this
Message
(
MSG_EXIT
)
)
;
}
}
;
status_t
FakeSurfaceComposer
:
:
captureScreen
(
const
sp
<
IBinder
>
&
display
const
sp
<
IGraphicBufferProducer
>
&
producer
#
if
ANDROID_VERSION
>
=
21
Rect
sourceCrop
#
endif
uint32_t
reqWidth
uint32_t
reqHeight
uint32_t
minLayerZ
uint32_t
maxLayerZ
#
if
ANDROID_VERSION
>
=
21
bool
useIdentityTransform
Rotation
rotation
#
elif
ANDROID_VERSION
<
19
bool
isCpuConsumer
#
endif
)
{
if
(
display
=
=
0
|
|
producer
=
=
0
)
{
return
BAD_VALUE
;
}
if
(
display
!
=
mPrimaryDisplay
)
{
return
BAD_VALUE
;
}
sp
<
GraphicProducerWrapper
>
wrapper
=
new
GraphicProducerWrapper
(
producer
)
;
sp
<
IGraphicBufferProducer
>
fakeProducer
=
IGraphicBufferProducer
:
:
asInterface
(
wrapper
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
&
]
(
)
{
captureScreenImp
(
fakeProducer
reqWidth
reqHeight
wrapper
.
get
(
)
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
)
;
status_t
result
=
wrapper
-
>
waitForResponse
(
)
;
return
result
;
}
class
RunnableCallTask
:
public
Task
{
public
:
explicit
RunnableCallTask
(
nsIRunnable
*
aRunnable
)
:
mRunnable
(
aRunnable
)
{
}
void
Run
(
)
override
{
mRunnable
-
>
Run
(
)
;
}
protected
:
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
}
;
void
FakeSurfaceComposer
:
:
captureScreenImp
(
const
sp
<
IGraphicBufferProducer
>
&
producer
uint32_t
reqWidth
uint32_t
reqHeight
const
sp
<
GraphicProducerWrapper
>
&
wrapper
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
wrapper
.
get
(
)
)
;
RefPtr
<
nsScreenGonk
>
screen
=
nsScreenManagerGonk
:
:
GetPrimaryScreen
(
)
;
nsIntRect
screenBounds
=
screen
-
>
GetNaturalBounds
(
)
.
ToUnknownRect
(
)
;
const
uint32_t
hw_w
=
screenBounds
.
width
;
const
uint32_t
hw_h
=
screenBounds
.
height
;
if
(
reqWidth
>
hw_w
|
|
reqHeight
>
hw_h
)
{
ALOGE
(
"
size
mismatch
(
%
d
%
d
)
>
(
%
d
%
d
)
"
reqWidth
reqHeight
hw_w
hw_h
)
;
static_cast
<
GraphicProducerWrapper
*
>
(
producer
-
>
asBinder
(
)
.
get
(
)
)
-
>
exit
(
BAD_VALUE
)
;
return
;
}
reqWidth
=
(
!
reqWidth
)
?
hw_w
:
reqWidth
;
reqHeight
=
(
!
reqHeight
)
?
hw_h
:
reqHeight
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
screen
reqWidth
reqHeight
producer
wrapper
]
(
)
{
sp
<
Surface
>
sur
=
new
Surface
(
producer
)
;
ANativeWindow
*
window
=
sur
.
get
(
)
;
RefPtr
<
nsScreenGonk
>
screenAlias
=
screen
;
if
(
native_window_api_connect
(
window
NATIVE_WINDOW_API_EGL
)
!
=
NO_ERROR
)
{
static_cast
<
GraphicProducerWrapper
*
>
(
producer
-
>
asBinder
(
)
.
get
(
)
)
-
>
exit
(
BAD_VALUE
)
;
NS_ReleaseOnMainThread
(
screenAlias
.
forget
(
)
)
;
return
;
}
uint32_t
usage
=
GRALLOC_USAGE_SW_READ_OFTEN
|
GRALLOC_USAGE_SW_WRITE_OFTEN
|
GRALLOC_USAGE_HW_RENDER
|
GRALLOC_USAGE_HW_TEXTURE
;
int
err
=
0
;
err
=
native_window_set_buffers_dimensions
(
window
reqWidth
reqHeight
)
;
err
|
=
native_window_set_scaling_mode
(
window
NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW
)
;
err
|
=
native_window_set_buffers_format
(
window
HAL_PIXEL_FORMAT_RGBA_8888
)
;
err
|
=
native_window_set_usage
(
window
usage
)
;
status_t
result
=
NO_ERROR
;
if
(
err
=
=
NO_ERROR
)
{
ANativeWindowBuffer
*
buffer
;
result
=
native_window_dequeue_buffer_and_wait
(
window
&
buffer
)
;
if
(
result
=
=
NO_ERROR
)
{
nsresult
rv
=
screen
-
>
MakeSnapshot
(
buffer
)
;
if
(
rv
!
=
NS_OK
)
{
result
=
INVALID_OPERATION
;
}
window
-
>
queueBuffer
(
window
buffer
-
1
)
;
}
}
else
{
result
=
BAD_VALUE
;
}
native_window_api_disconnect
(
window
NATIVE_WINDOW_API_EGL
)
;
static_cast
<
GraphicProducerWrapper
*
>
(
producer
-
>
asBinder
(
)
.
get
(
)
)
-
>
exit
(
result
)
;
NS_ReleaseOnMainThread
(
screenAlias
.
forget
(
)
)
;
}
)
;
mozilla
:
:
layers
:
:
CompositorBridgeParent
:
:
CompositorLoop
(
)
-
>
PostTask
(
FROM_HERE
new
RunnableCallTask
(
runnable
)
)
;
}
#
if
ANDROID_VERSION
>
=
21
void
FakeSurfaceComposer
:
:
setPowerMode
(
const
sp
<
IBinder
>
&
display
int
mode
)
{
}
status_t
FakeSurfaceComposer
:
:
getDisplayConfigs
(
const
sp
<
IBinder
>
&
display
Vector
<
DisplayInfo
>
*
configs
)
{
if
(
configs
=
=
NULL
)
{
return
BAD_VALUE
;
}
if
(
!
display
.
get
(
)
|
|
display
!
=
mPrimaryDisplay
)
{
return
NAME_NOT_FOUND
;
}
configs
-
>
clear
(
)
;
DisplayInfo
info
=
DisplayInfo
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
&
]
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
getPrimaryDisplayInfo
(
&
info
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
NS_DISPATCH_SYNC
)
;
configs
-
>
push_back
(
info
)
;
return
NO_ERROR
;
}
status_t
FakeSurfaceComposer
:
:
getDisplayStats
(
const
sp
<
IBinder
>
&
display
DisplayStatInfo
*
stats
)
{
return
INVALID_OPERATION
;
}
int
FakeSurfaceComposer
:
:
getActiveConfig
(
const
sp
<
IBinder
>
&
display
)
{
if
(
display
.
get
(
)
&
&
(
display
=
=
mPrimaryDisplay
)
)
{
return
0
;
}
return
INVALID_OPERATION
;
}
status_t
FakeSurfaceComposer
:
:
setActiveConfig
(
const
sp
<
IBinder
>
&
display
int
id
)
{
return
INVALID_OPERATION
;
}
status_t
FakeSurfaceComposer
:
:
clearAnimationFrameStats
(
)
{
return
INVALID_OPERATION
;
}
status_t
FakeSurfaceComposer
:
:
getAnimationFrameStats
(
FrameStats
*
outStats
)
const
{
return
INVALID_OPERATION
;
}
#
else
void
FakeSurfaceComposer
:
:
blank
(
const
sp
<
IBinder
>
&
display
)
{
}
void
FakeSurfaceComposer
:
:
unblank
(
const
sp
<
IBinder
>
&
display
)
{
}
status_t
FakeSurfaceComposer
:
:
getDisplayInfo
(
const
sp
<
IBinder
>
&
display
DisplayInfo
*
info
)
{
if
(
info
=
=
NULL
)
{
return
BAD_VALUE
;
}
if
(
!
display
.
get
(
)
|
|
display
!
=
mPrimaryDisplay
)
{
return
NAME_NOT_FOUND
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
&
]
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
getPrimaryDisplayInfo
(
info
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
NS_DISPATCH_SYNC
)
;
return
NO_ERROR
;
}
#
endif
#
define
VSYNC_EVENT_PHASE_OFFSET_NS
0
#
define
SF_VSYNC_EVENT_PHASE_OFFSET_NS
0
void
FakeSurfaceComposer
:
:
getPrimaryDisplayInfo
(
DisplayInfo
*
info
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Must
be
on
main
thread
.
"
)
;
class
Density
{
static
int
getDensityFromProperty
(
char
const
*
propName
)
{
char
property
[
PROPERTY_VALUE_MAX
]
;
int
density
=
0
;
if
(
property_get
(
propName
property
NULL
)
>
0
)
{
density
=
atoi
(
property
)
;
}
return
density
;
}
public
:
static
int
getEmuDensity
(
)
{
return
getDensityFromProperty
(
"
qemu
.
sf
.
lcd_density
"
)
;
}
static
int
getBuildDensity
(
)
{
return
getDensityFromProperty
(
"
ro
.
sf
.
lcd_density
"
)
;
}
}
;
RefPtr
<
nsScreenGonk
>
screen
=
nsScreenManagerGonk
:
:
GetPrimaryScreen
(
)
;
float
xdpi
=
screen
-
>
GetDpi
(
)
;
float
ydpi
=
screen
-
>
GetDpi
(
)
;
int
fps
=
60
;
nsIntRect
screenBounds
=
screen
-
>
GetNaturalBounds
(
)
.
ToUnknownRect
(
)
;
float
density
=
Density
:
:
getBuildDensity
(
)
/
160
.
0f
;
if
(
density
=
=
0
)
{
ALOGE
(
"
ro
.
sf
.
lcd_density
must
be
defined
as
a
build
property
"
)
;
density
=
xdpi
/
160
.
0f
;
}
info
-
>
density
=
density
;
info
-
>
orientation
=
screen
-
>
EffectiveScreenRotation
(
)
;
info
-
>
w
=
screenBounds
.
width
;
info
-
>
h
=
screenBounds
.
height
;
info
-
>
xdpi
=
xdpi
;
info
-
>
ydpi
=
ydpi
;
info
-
>
fps
=
fps
;
#
if
ANDROID_VERSION
>
=
21
info
-
>
appVsyncOffset
=
VSYNC_EVENT_PHASE_OFFSET_NS
;
info
-
>
presentationDeadline
=
(
1e9
/
fps
)
-
SF_VSYNC_EVENT_PHASE_OFFSET_NS
+
1000000
;
#
endif
info
-
>
secure
=
true
;
}
}
;
