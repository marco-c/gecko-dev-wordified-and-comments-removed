#
ifndef
nsDragService_h__
#
define
nsDragService_h__
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsBaseDragService
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
"
nsITimer
.
h
"
#
include
"
GUniquePtr
.
h
"
class
nsICookieJarSettings
;
class
nsWindow
;
namespace
mozilla
{
namespace
gfx
{
class
SourceSurface
;
}
}
class
DragData
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
DragData
)
DragData
(
void
*
aData
uint32_t
aDataLen
bool
aCopyData
)
{
UpdateData
(
aData
aDataLen
aCopyData
)
;
}
DragData
(
const
void
*
aData
uint32_t
aDataLen
)
{
UpdateData
(
const_cast
<
void
*
>
(
aData
)
aDataLen
true
)
;
}
explicit
DragData
(
gchar
*
*
aDragUris
)
:
mDragUris
(
aDragUris
)
{
}
bool
HasURIs
(
)
const
{
return
!
!
mDragUris
.
get
(
)
;
}
gchar
*
*
GetURIs
(
)
const
{
return
mDragUris
.
get
(
)
;
}
void
UpdateData
(
void
*
aData
uint32_t
aDataLen
bool
aCopyData
=
false
)
;
void
*
GetData
(
)
const
{
return
mDragData
;
}
uint32_t
GetDataLen
(
)
const
{
return
mDragDataLen
;
}
mozilla
:
:
Span
<
char
>
GetDataSpan
(
)
const
{
return
mozilla
:
:
Span
(
(
char
*
)
mDragData
mDragDataLen
)
;
}
private
:
void
ReleaseData
(
)
;
~
DragData
(
)
;
uint32_t
mDragDataLen
=
0
;
void
*
mDragData
=
nullptr
;
mozilla
:
:
GUniquePtr
<
gchar
*
>
mDragUris
;
}
;
class
nsDragService
final
:
public
nsBaseDragService
public
nsIObserver
{
public
:
nsDragService
(
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIOBSERVER
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InvokeDragSessionImpl
(
nsIArray
*
anArrayTransferables
const
mozilla
:
:
Maybe
<
mozilla
:
:
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
InvokeDragSession
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsICookieJarSettings
*
aCookieJarSettings
nsIArray
*
anArrayTransferables
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
)
override
;
NS_IMETHOD
StartDragSession
(
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
override
;
NS_IMETHOD
SetCanDrop
(
bool
aCanDrop
)
override
;
NS_IMETHOD
GetCanDrop
(
bool
*
aCanDrop
)
override
;
NS_IMETHOD
GetNumDropItems
(
uint32_t
*
aNumItems
)
override
;
NS_IMETHOD
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
override
;
NS_IMETHOD
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
override
;
NS_IMETHOD
UpdateDragEffect
(
)
override
;
static
already_AddRefed
<
nsDragService
>
GetInstance
(
)
;
void
TargetDataReceived
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aX
gint
aY
GtkSelectionData
*
aSelection_data
guint
aInfo
guint32
aTime
)
;
gboolean
ScheduleMotionEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
mozilla
:
:
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
;
void
ScheduleLeaveEvent
(
)
;
gboolean
ScheduleDropEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
mozilla
:
:
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
;
nsWindow
*
GetMostRecentDestWindow
(
)
{
return
mScheduledTask
=
=
eDragTaskNone
?
mTargetWindow
:
mPendingWindow
;
}
void
SourceEndDragSession
(
GdkDragContext
*
aContext
gint
aResult
)
;
void
SourceDataGet
(
GtkWidget
*
widget
GdkDragContext
*
context
GtkSelectionData
*
selection_data
guint32
aTime
)
;
bool
SourceDataGetText
(
nsITransferable
*
aItem
const
nsACString
&
aMIMEType
bool
aNeedToDoConversionToPlainText
GtkSelectionData
*
aSelectionData
)
;
void
SourceDataGetImage
(
nsITransferable
*
aItem
GtkSelectionData
*
aSelectionData
)
;
void
SourceDataGetXDND
(
nsITransferable
*
aItem
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
)
;
void
SourceDataGetUriList
(
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
uint32_t
aDragItems
)
;
bool
SourceDataAppendURLFileItem
(
nsACString
&
aURI
nsITransferable
*
aItem
)
;
bool
SourceDataAppendURLItem
(
nsITransferable
*
aItem
bool
aExternalDrop
nsACString
&
aURI
)
;
void
SourceBeginDrag
(
GdkDragContext
*
aContext
)
;
void
SetDragIcon
(
GdkDragContext
*
aContext
)
;
class
AutoEventLoop
{
RefPtr
<
nsDragService
>
mService
;
public
:
explicit
AutoEventLoop
(
RefPtr
<
nsDragService
>
aService
)
:
mService
(
std
:
:
move
(
aService
)
)
{
mService
-
>
mEventLoopDepth
+
+
;
}
~
AutoEventLoop
(
)
{
mService
-
>
mEventLoopDepth
-
-
;
}
}
;
int
GetLoopDepth
(
)
const
{
return
mEventLoopDepth
;
}
;
protected
:
virtual
~
nsDragService
(
)
;
private
:
enum
DragTask
{
eDragTaskNone
eDragTaskMotion
eDragTaskLeave
eDragTaskDrop
eDragTaskSourceEnd
}
;
DragTask
mScheduledTask
;
guint
mTaskSource
;
bool
mScheduledTaskIsRunning
;
RefPtr
<
nsWindow
>
mSourceWindow
;
RefPtr
<
nsWindow
>
mPendingWindow
;
mozilla
:
:
LayoutDeviceIntPoint
mPendingWindowPoint
;
RefPtr
<
GdkDragContext
>
mPendingDragContext
;
uintptr_t
mCachedDragContext
;
nsRefPtrHashtable
<
nsVoidPtrHashKey
DragData
>
mCachedDragData
;
guint
mPendingTime
;
RefPtr
<
nsWindow
>
mTargetWindow
;
mozilla
:
:
LayoutDeviceIntPoint
mTargetWindowPoint
;
RefPtr
<
GtkWidget
>
mTargetWidget
;
RefPtr
<
GdkDragContext
>
mTargetDragContext
;
RefPtr
<
GdkDragContext
>
mTargetDragContextForRemote
;
guint
mTargetTime
;
bool
mCanDrop
;
RefPtr
<
DragData
>
mDragData
;
bool
IsTargetContextList
(
void
)
;
void
GetDragData
(
GdkAtom
aRequestedFlavor
const
nsTArray
<
GdkAtom
>
&
aAvailableDragFlavors
bool
aResetDragData
=
true
)
;
void
TargetResetData
(
void
)
;
void
EnsureCachedDataValidForContext
(
GdkDragContext
*
aDragContext
)
;
GtkWidget
*
mHiddenWidget
;
nsCOMPtr
<
nsIArray
>
mSourceDataItems
;
GtkTargetList
*
GetSourceList
(
void
)
;
bool
SetAlphaPixmap
(
SourceSurface
*
aPixbuf
GdkDragContext
*
aContext
int32_t
aXOffset
int32_t
aYOffset
const
mozilla
:
:
LayoutDeviceIntRect
&
dragRect
)
;
gboolean
Schedule
(
DragTask
aTask
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
mozilla
:
:
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
;
MOZ_CAN_RUN_SCRIPT
static
gboolean
TaskDispatchCallback
(
gpointer
data
)
;
MOZ_CAN_RUN_SCRIPT
gboolean
RunScheduledTask
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DispatchMotionEvents
(
)
;
void
ReplyToDragMotion
(
GdkDragContext
*
aDragContext
guint
aTime
)
;
void
ReplyToDragMotion
(
)
;
void
UpdateDragAction
(
GdkDragContext
*
aDragContext
)
;
void
UpdateDragAction
(
)
;
#
ifdef
MOZ_LOGGING
const
char
*
GetDragServiceTaskName
(
nsDragService
:
:
DragTask
aTask
)
;
#
endif
void
GetAvailableDragFlavors
(
nsTArray
<
GdkAtom
>
&
aAvailableFlavors
)
;
gboolean
DispatchDropEvent
(
)
;
static
uint32_t
GetCurrentModifiers
(
)
;
nsresult
CreateTempFile
(
nsITransferable
*
aItem
nsACString
&
aURI
)
;
bool
RemoveTempFiles
(
)
;
static
gboolean
TaskRemoveTempFiles
(
gpointer
data
)
;
nsTArray
<
nsCString
>
mTempFileUrls
;
nsCOMArray
<
nsIFile
>
mTemporaryFiles
;
guint
mTempFileTimerID
;
int
mEventLoopDepth
;
public
:
static
GdkAtom
sTextMimeAtom
;
static
GdkAtom
sMozUrlTypeAtom
;
static
GdkAtom
sMimeListTypeAtom
;
static
GdkAtom
sTextUriListTypeAtom
;
static
GdkAtom
sTextPlainUTF8TypeAtom
;
static
GdkAtom
sXdndDirectSaveTypeAtom
;
static
GdkAtom
sTabDropTypeAtom
;
static
GdkAtom
sPortalFileAtom
;
static
GdkAtom
sPortalFileTransferAtom
;
}
;
#
endif
