#
ifndef
nsDragService_h__
#
define
nsDragService_h__
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsBaseDragService
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
"
nsITimer
.
h
"
#
include
"
GUniquePtr
.
h
"
class
nsICookieJarSettings
;
class
nsWindow
;
namespace
mozilla
{
namespace
gfx
{
class
SourceSurface
;
}
}
class
DragData
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
DragData
)
explicit
DragData
(
GdkAtom
aDataFlavor
const
void
*
aData
uint32_t
aDataLen
)
:
mDataFlavor
(
aDataFlavor
)
mDragDataLen
(
aDataLen
)
mDragData
(
moz_xmemdup
(
aData
aDataLen
)
)
{
if
(
IsURIFlavor
(
)
)
{
ConvertToMozURIList
(
)
;
}
}
explicit
DragData
(
GdkAtom
aDataFlavor
gchar
*
*
aDragUris
)
;
GdkAtom
GetFlavor
(
)
const
{
return
mDataFlavor
;
}
RefPtr
<
DragData
>
ConvertToMozURL
(
)
const
;
RefPtr
<
DragData
>
ConvertToFile
(
)
const
;
bool
Export
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
;
bool
IsImageFlavor
(
)
const
;
bool
IsFileFlavor
(
)
const
;
bool
IsTextFlavor
(
)
const
;
bool
IsURIFlavor
(
)
const
;
int
GetURIsNum
(
)
const
;
bool
IsDataValid
(
)
const
;
#
ifdef
MOZ_LOGGING
void
Print
(
)
const
;
#
endif
private
:
explicit
DragData
(
GdkAtom
aDataFlavor
)
:
mDataFlavor
(
aDataFlavor
)
{
}
~
DragData
(
)
=
default
;
void
ConvertToMozURIList
(
)
;
GdkAtom
mDataFlavor
=
nullptr
;
bool
mAsURIData
=
false
;
bool
mDragDataDOMEndings
=
false
;
uint32_t
mDragDataLen
=
0
;
mozilla
:
:
UniqueFreePtr
<
void
>
mDragData
;
mozilla
:
:
GUniquePtr
<
gchar
*
>
mDragUris
;
nsString
mData
;
nsTArray
<
nsString
>
mUris
;
}
;
class
nsDragSession
:
public
nsBaseDragSession
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIOBSERVER
NS_IMETHOD
SetCanDrop
(
bool
aCanDrop
)
override
;
NS_IMETHOD
GetCanDrop
(
bool
*
aCanDrop
)
override
;
NS_IMETHOD
GetNumDropItems
(
uint32_t
*
aNumItems
)
override
;
NS_IMETHOD
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
override
;
NS_IMETHOD
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
override
;
NS_IMETHOD
UpdateDragEffect
(
)
override
;
nsAutoCString
GetDebugTag
(
)
const
;
MOZ_CAN_RUN_SCRIPT
nsresult
EndDragSessionImpl
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
override
;
class
AutoEventLoop
{
RefPtr
<
nsDragSession
>
mSession
;
public
:
explicit
AutoEventLoop
(
RefPtr
<
nsDragSession
>
aSession
)
:
mSession
(
std
:
:
move
(
aSession
)
)
{
nsDragSession
:
:
sEventLoopDepth
+
+
;
}
~
AutoEventLoop
(
)
{
nsDragSession
:
:
sEventLoopDepth
-
-
;
}
}
;
static
int
GetLoopDepth
(
)
{
return
sEventLoopDepth
;
}
;
protected
:
enum
DragTask
{
eDragTaskNone
eDragTaskMotion
eDragTaskLeave
eDragTaskDrop
eDragTaskSourceEnd
}
;
void
ReplyToDragMotion
(
GdkDragContext
*
aDragContext
guint
aTime
)
;
void
ReplyToDragMotion
(
)
;
void
GetDragFlavors
(
nsTArray
<
nsCString
>
&
aFlavors
)
;
void
GetTargetDragData
(
GdkAtom
aFlavor
nsTArray
<
nsCString
>
&
aDropFlavors
bool
aResetTargetData
=
true
)
;
void
TargetResetData
(
void
)
;
bool
IsTargetContextList
(
void
)
;
void
EnsureCachedDataValidForContext
(
GdkDragContext
*
aDragContext
)
;
static
gboolean
TaskRemoveTempFiles
(
gpointer
data
)
;
bool
RemoveTempFiles
(
)
;
RefPtr
<
nsWindow
>
mSourceWindow
;
RefPtr
<
nsWindow
>
mTargetWindow
;
nsCOMPtr
<
nsIArray
>
mSourceDataItems
;
RefPtr
<
GtkWidget
>
mTargetWidget
;
RefPtr
<
GdkDragContext
>
mTargetDragContext
;
void
*
mTargetDragData
=
nullptr
;
uint32_t
mTargetDragDataLen
=
0
;
bool
mTargetDragDataReceived
=
false
;
RefPtr
<
GdkDragContext
>
mTargetDragContextForRemote
;
guint
mTargetTime
;
mozilla
:
:
GUniquePtr
<
gchar
*
>
mTargetDragUris
=
nullptr
;
nsTHashMap
<
nsCStringHashKey
mozilla
:
:
GUniquePtr
<
gchar
*
>
>
mCachedUris
;
nsTHashMap
<
nsCStringHashKey
nsTArray
<
uint8_t
>
>
mCachedData
;
DragTask
mScheduledTask
=
eDragTaskNone
;
bool
mScheduledTaskIsRunning
=
false
;
RefPtr
<
nsWindow
>
mPendingWindow
;
mozilla
:
:
LayoutDeviceIntPoint
mPendingWindowPoint
;
RefPtr
<
GdkDragContext
>
mPendingDragContext
;
guint
mPendingTime
;
guint
mTaskSource
=
0
;
nsCOMArray
<
nsIFile
>
mTemporaryFiles
;
guint
mTempFileTimerID
;
nsTArray
<
nsCString
>
mTempFileUrls
;
uintptr_t
mCachedDragContext
=
0
;
static
int
sEventLoopDepth
;
bool
mCanDrop
=
false
;
public
:
static
GdkAtom
sJPEGImageMimeAtom
;
static
GdkAtom
sJPGImageMimeAtom
;
static
GdkAtom
sPNGImageMimeAtom
;
static
GdkAtom
sGIFImageMimeAtom
;
static
GdkAtom
sCustomTypesMimeAtom
;
static
GdkAtom
sURLMimeAtom
;
static
GdkAtom
sRTFMimeAtom
;
static
GdkAtom
sTextMimeAtom
;
static
GdkAtom
sMozUrlTypeAtom
;
static
GdkAtom
sMimeListTypeAtom
;
static
GdkAtom
sTextUriListTypeAtom
;
static
GdkAtom
sTextPlainUTF8TypeAtom
;
static
GdkAtom
sXdndDirectSaveTypeAtom
;
static
GdkAtom
sTabDropTypeAtom
;
static
GdkAtom
sFileMimeAtom
;
static
GdkAtom
sPortalFileAtom
;
static
GdkAtom
sPortalFileTransferAtom
;
static
GdkAtom
sFilePromiseURLMimeAtom
;
static
GdkAtom
sFilePromiseMimeAtom
;
static
GdkAtom
sNativeImageMimeAtom
;
static
GdkAtom
sUTF8STRINGMimeAtom
;
static
GdkAtom
sSTRINGMimeAtom
;
nsDragSession
(
)
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
InvokeDragSessionImpl
(
nsIWidget
*
aWidget
nsIArray
*
anArrayTransferables
const
mozilla
:
:
Maybe
<
mozilla
:
:
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
InvokeDragSession
(
nsIWidget
*
aWidget
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIPolicyContainer
*
aPolicyContainer
nsICookieJarSettings
*
aCookieJarSettings
nsIArray
*
anArrayTransferables
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
)
override
;
void
TargetDataReceived
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aX
gint
aY
GtkSelectionData
*
aSelection_data
guint
aInfo
guint32
aTime
)
;
gboolean
ScheduleMotionEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
mozilla
:
:
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
;
void
ScheduleLeaveEvent
(
)
;
gboolean
ScheduleDropEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
mozilla
:
:
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
;
nsWindow
*
GetMostRecentDestWindow
(
)
{
return
mScheduledTask
=
=
eDragTaskNone
?
mTargetWindow
:
mPendingWindow
;
}
void
SourceEndDragSession
(
GdkDragContext
*
aContext
gint
aResult
)
;
void
SourceDataGet
(
GtkWidget
*
widget
GdkDragContext
*
context
GtkSelectionData
*
selection_data
guint32
aTime
)
;
bool
SourceDataGetText
(
nsITransferable
*
aItem
const
nsACString
&
aMIMEType
bool
aNeedToDoConversionToPlainText
GtkSelectionData
*
aSelectionData
)
;
bool
SourceDataGetImage
(
nsITransferable
*
aItem
GtkSelectionData
*
aSelectionData
)
;
bool
SourceDataGetXDND
(
nsITransferable
*
aItem
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
)
;
void
SourceDataGetUriList
(
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
uint32_t
aDragItems
)
;
bool
SourceDataAppendURLFileItem
(
nsACString
&
aURI
nsITransferable
*
aItem
)
;
bool
SourceDataAppendURLItem
(
nsITransferable
*
aItem
bool
aExternalDrop
nsACString
&
aURI
)
;
void
SourceBeginDrag
(
GdkDragContext
*
aContext
)
;
void
SetDragIcon
(
GdkDragContext
*
aContext
)
;
protected
:
virtual
~
nsDragSession
(
)
;
private
:
nsTHashMap
<
void
*
RefPtr
<
DragData
>
>
mCachedDragData
;
nsTArray
<
GdkAtom
>
mCachedDragFlavors
;
void
SetCachedDragContext
(
GdkDragContext
*
aDragContext
)
;
mozilla
:
:
LayoutDeviceIntPoint
mTargetWindowPoint
;
RefPtr
<
GdkDragContext
>
mWaitingForDragDataContext
;
bool
IsDragFlavorAvailable
(
GdkAtom
aRequestedFlavor
)
;
RefPtr
<
DragData
>
GetDragData
(
GdkAtom
aRequestedFlavor
)
;
GtkWidget
*
mHiddenWidget
;
GtkTargetList
*
GetSourceList
(
void
)
;
bool
SetAlphaPixmap
(
mozilla
:
:
gfx
:
:
SourceSurface
*
aPixbuf
GdkDragContext
*
aContext
int32_t
aXOffset
int32_t
aYOffset
const
mozilla
:
:
LayoutDeviceIntRect
&
dragRect
)
;
gboolean
Schedule
(
DragTask
aTask
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
mozilla
:
:
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
;
MOZ_CAN_RUN_SCRIPT
static
gboolean
TaskDispatchCallback
(
gpointer
data
)
;
MOZ_CAN_RUN_SCRIPT
gboolean
RunScheduledTask
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DispatchMotionEvents
(
)
;
void
UpdateDragAction
(
GdkDragContext
*
aDragContext
)
;
void
UpdateDragAction
(
)
;
#
ifdef
MOZ_LOGGING
const
char
*
GetDragServiceTaskName
(
DragTask
aTask
)
;
#
endif
gboolean
DispatchDropEvent
(
)
;
static
uint32_t
GetCurrentModifiers
(
)
;
nsresult
CreateTempFile
(
nsITransferable
*
aItem
nsACString
&
aURI
)
;
}
;
class
nsDragService
:
public
nsBaseDragService
{
public
:
static
already_AddRefed
<
nsDragService
>
GetInstance
(
)
;
nsIDragSession
*
StartDragSession
(
nsISupports
*
aWidgetProvider
)
override
;
protected
:
already_AddRefed
<
nsIDragSession
>
CreateDragSession
(
)
override
;
}
;
#
endif
