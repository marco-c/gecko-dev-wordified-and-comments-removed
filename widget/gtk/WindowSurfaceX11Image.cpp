#
include
"
WindowSurfaceX11Image
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
<
X11
/
extensions
/
shape
.
h
>
namespace
mozilla
{
namespace
widget
{
#
define
SHAPED_IMAGE_SURFACE_BPP
4
#
ifdef
IS_BIG_ENDIAN
#
define
SHAPED_IMAGE_SURFACE_ALPHA_INDEX
0
#
else
#
define
SHAPED_IMAGE_SURFACE_ALPHA_INDEX
3
#
endif
WindowSurfaceX11Image
:
:
WindowSurfaceX11Image
(
Display
*
aDisplay
Window
aWindow
Visual
*
aVisual
unsigned
int
aDepth
bool
aIsShaped
)
:
WindowSurfaceX11
(
aDisplay
aWindow
aVisual
aDepth
)
mTransparencyBitmap
(
nullptr
)
mTransparencyBitmapWidth
(
0
)
mTransparencyBitmapHeight
(
0
)
mIsShaped
(
aIsShaped
)
{
}
WindowSurfaceX11Image
:
:
~
WindowSurfaceX11Image
(
)
{
if
(
mTransparencyBitmap
)
{
delete
[
]
mTransparencyBitmap
;
Display
*
xDisplay
=
mWindowSurface
-
>
XDisplay
(
)
;
Window
xDrawable
=
mWindowSurface
-
>
XDrawable
(
)
;
XShapeCombineMask
(
xDisplay
xDrawable
ShapeBounding
0
0
X11None
ShapeSet
)
;
}
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
WindowSurfaceX11Image
:
:
Lock
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
gfx
:
:
IntRect
bounds
=
aRegion
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
gfx
:
:
IntSize
size
(
bounds
.
XMost
(
)
bounds
.
YMost
(
)
)
;
if
(
!
mWindowSurface
|
|
mWindowSurface
-
>
CairoStatus
(
)
|
|
!
(
size
<
=
mWindowSurface
-
>
GetSize
(
)
)
)
{
mWindowSurface
=
new
gfxXlibSurface
(
mDisplay
mWindow
mVisual
size
)
;
}
if
(
mWindowSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
if
(
!
mImageSurface
|
|
mImageSurface
-
>
CairoStatus
(
)
|
|
!
(
size
<
=
mImageSurface
-
>
GetSize
(
)
)
)
{
gfxImageFormat
format
=
SurfaceFormatToImageFormat
(
mFormat
)
;
if
(
format
=
=
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
{
format
=
mDepth
=
=
32
?
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8_UINT32
:
gfx
:
:
SurfaceFormat
:
:
X8R8G8B8_UINT32
;
}
if
(
mIsShaped
)
{
format
=
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
mImageSurface
=
new
gfxImageSurface
(
size
format
)
;
if
(
mImageSurface
-
>
CairoStatus
(
)
)
{
return
nullptr
;
}
}
gfxImageFormat
format
=
mImageSurface
-
>
Format
(
)
;
if
(
format
=
=
gfx
:
:
SurfaceFormat
:
:
X8R8G8B8_UINT32
)
{
gfx
:
:
BackendType
backend
=
gfxVars
:
:
ContentBackend
(
)
;
if
(
!
gfx
:
:
Factory
:
:
DoesBackendSupportDataDrawtarget
(
backend
)
)
{
#
ifdef
USE_SKIA
backend
=
gfx
:
:
BackendType
:
:
SKIA
;
#
else
backend
=
gfx
:
:
BackendType
:
:
CAIRO
;
#
endif
}
if
(
backend
!
=
gfx
:
:
BackendType
:
:
CAIRO
)
{
format
=
gfx
:
:
SurfaceFormat
:
:
A8R8G8B8_UINT32
;
}
}
return
gfxPlatform
:
:
CreateDrawTargetForData
(
mImageSurface
-
>
Data
(
)
mImageSurface
-
>
GetSize
(
)
mImageSurface
-
>
Stride
(
)
ImageFormatToSurfaceFormat
(
format
)
)
;
}
static
inline
int32_t
GetBitmapStride
(
int32_t
width
)
{
return
(
width
+
7
)
/
8
;
}
static
bool
ChangedMaskBits
(
gchar
*
aMaskBits
int32_t
aMaskWidth
int32_t
aMaskHeight
const
nsIntRect
&
aRect
uint8_t
*
aImageData
)
{
int32_t
stride
=
aMaskWidth
*
SHAPED_IMAGE_SURFACE_BPP
;
int32_t
x
y
xMax
=
aRect
.
XMost
(
)
yMax
=
aRect
.
YMost
(
)
;
int32_t
maskBytesPerRow
=
GetBitmapStride
(
aMaskWidth
)
;
for
(
y
=
aRect
.
y
;
y
<
yMax
;
y
+
+
)
{
gchar
*
maskBytes
=
aMaskBits
+
y
*
maskBytesPerRow
;
uint8_t
*
alphas
=
aImageData
;
for
(
x
=
aRect
.
x
;
x
<
xMax
;
x
+
+
)
{
bool
newBit
=
*
(
alphas
+
SHAPED_IMAGE_SURFACE_ALPHA_INDEX
)
>
0x7f
;
alphas
+
=
SHAPED_IMAGE_SURFACE_BPP
;
gchar
maskByte
=
maskBytes
[
x
>
>
3
]
;
bool
maskBit
=
(
maskByte
&
(
1
<
<
(
x
&
7
)
)
)
!
=
0
;
if
(
maskBit
!
=
newBit
)
{
return
true
;
}
}
aImageData
+
=
stride
;
}
return
false
;
}
static
void
UpdateMaskBits
(
gchar
*
aMaskBits
int32_t
aMaskWidth
int32_t
aMaskHeight
const
nsIntRect
&
aRect
uint8_t
*
aImageData
)
{
int32_t
stride
=
aMaskWidth
*
SHAPED_IMAGE_SURFACE_BPP
;
int32_t
x
y
xMax
=
aRect
.
XMost
(
)
yMax
=
aRect
.
YMost
(
)
;
int32_t
maskBytesPerRow
=
GetBitmapStride
(
aMaskWidth
)
;
for
(
y
=
aRect
.
y
;
y
<
yMax
;
y
+
+
)
{
gchar
*
maskBytes
=
aMaskBits
+
y
*
maskBytesPerRow
;
uint8_t
*
alphas
=
aImageData
;
for
(
x
=
aRect
.
x
;
x
<
xMax
;
x
+
+
)
{
bool
newBit
=
*
(
alphas
+
SHAPED_IMAGE_SURFACE_ALPHA_INDEX
)
>
0x7f
;
alphas
+
=
SHAPED_IMAGE_SURFACE_BPP
;
gchar
mask
=
1
<
<
(
x
&
7
)
;
gchar
maskByte
=
maskBytes
[
x
>
>
3
]
;
maskBytes
[
x
>
>
3
]
=
(
maskByte
&
~
mask
)
|
(
-
newBit
&
mask
)
;
}
aImageData
+
=
stride
;
}
}
void
WindowSurfaceX11Image
:
:
ResizeTransparencyBitmap
(
int
aWidth
int
aHeight
)
{
if
(
mTransparencyBitmapWidth
*
mTransparencyBitmapHeight
<
aWidth
*
aHeight
)
{
delete
[
]
mTransparencyBitmap
;
int32_t
byteSize
=
GetBitmapStride
(
aWidth
)
*
aHeight
;
mTransparencyBitmap
=
new
gchar
[
byteSize
]
;
}
mTransparencyBitmapWidth
=
aWidth
;
mTransparencyBitmapHeight
=
aHeight
;
}
void
WindowSurfaceX11Image
:
:
ApplyTransparencyBitmap
(
)
{
gfx
:
:
IntSize
size
=
mWindowSurface
-
>
GetSize
(
)
;
bool
maskChanged
=
true
;
if
(
!
mTransparencyBitmap
)
{
mTransparencyBitmapWidth
=
size
.
width
;
mTransparencyBitmapHeight
=
size
.
height
;
int32_t
byteSize
=
GetBitmapStride
(
mTransparencyBitmapWidth
)
*
mTransparencyBitmapHeight
;
mTransparencyBitmap
=
new
gchar
[
byteSize
]
;
}
else
{
bool
sizeChanged
=
(
size
.
width
!
=
mTransparencyBitmapWidth
|
|
size
.
height
!
=
mTransparencyBitmapHeight
)
;
if
(
sizeChanged
)
{
ResizeTransparencyBitmap
(
size
.
width
size
.
height
)
;
}
else
{
maskChanged
=
ChangedMaskBits
(
mTransparencyBitmap
mTransparencyBitmapWidth
mTransparencyBitmapHeight
nsIntRect
(
0
0
size
.
width
size
.
height
)
(
uint8_t
*
)
mImageSurface
-
>
Data
(
)
)
;
}
}
if
(
maskChanged
)
{
UpdateMaskBits
(
mTransparencyBitmap
mTransparencyBitmapWidth
mTransparencyBitmapHeight
nsIntRect
(
0
0
size
.
width
size
.
height
)
(
uint8_t
*
)
mImageSurface
-
>
Data
(
)
)
;
Display
*
xDisplay
=
mWindowSurface
-
>
XDisplay
(
)
;
Window
xDrawable
=
mWindowSurface
-
>
XDrawable
(
)
;
Pixmap
maskPixmap
=
XCreateBitmapFromData
(
xDisplay
xDrawable
mTransparencyBitmap
mTransparencyBitmapWidth
mTransparencyBitmapHeight
)
;
XShapeCombineMask
(
xDisplay
xDrawable
ShapeBounding
0
0
maskPixmap
ShapeSet
)
;
XFreePixmap
(
xDisplay
maskPixmap
)
;
}
}
void
WindowSurfaceX11Image
:
:
Commit
(
const
LayoutDeviceIntRegion
&
aInvalidRegion
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
gfx
:
:
Factory
:
:
CreateDrawTargetForCairoSurface
(
mWindowSurface
-
>
CairoSurface
(
)
mWindowSurface
-
>
GetSize
(
)
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
surf
=
gfx
:
:
Factory
:
:
CreateSourceSurfaceForCairoSurface
(
mImageSurface
-
>
CairoSurface
(
)
mImageSurface
-
>
GetSize
(
)
mImageSurface
-
>
Format
(
)
)
;
if
(
!
dt
|
|
!
surf
)
{
return
;
}
gfx
:
:
IntRect
bounds
=
aInvalidRegion
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
gfx
:
:
Rect
rect
(
bounds
)
;
if
(
rect
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
numRects
=
aInvalidRegion
.
GetNumRects
(
)
;
if
(
numRects
!
=
1
)
{
AutoTArray
<
IntRect
32
>
rects
;
rects
.
SetCapacity
(
numRects
)
;
for
(
auto
iter
=
aInvalidRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
rects
.
AppendElement
(
iter
.
Get
(
)
.
ToUnknownRect
(
)
)
;
}
dt
-
>
PushDeviceSpaceClipRects
(
rects
.
Elements
(
)
rects
.
Length
(
)
)
;
}
if
(
mIsShaped
)
{
ApplyTransparencyBitmap
(
)
;
}
dt
-
>
DrawSurface
(
surf
rect
rect
)
;
if
(
numRects
!
=
1
)
{
dt
-
>
PopClip
(
)
;
}
}
}
}
