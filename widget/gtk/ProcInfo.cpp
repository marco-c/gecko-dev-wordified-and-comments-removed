#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
#
include
"
nsAutoRef
.
h
"
#
include
"
nsLocalFile
.
h
"
#
include
"
nsMemoryReporterManager
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
<
unistd
.
h
>
#
include
<
dirent
.
h
>
#
define
NANOPERSEC
1000000000
.
template
<
>
class
nsAutoRefTraits
<
DIR
>
:
public
nsPointerRefTraits
<
DIR
>
{
public
:
static
void
Release
(
DIR
*
dirHandle
)
{
closedir
(
dirHandle
)
;
}
}
;
namespace
mozilla
{
class
StatReader
{
public
:
explicit
StatReader
(
const
base
:
:
ProcessId
aPid
)
:
mPid
(
aPid
)
mMaxIndex
(
53
)
mTicksPerSec
(
sysconf
(
_SC_CLK_TCK
)
)
{
mFilepath
.
AppendPrintf
(
"
/
proc
/
%
u
/
stat
"
mPid
)
;
}
nsresult
ParseProc
(
ProcInfo
&
aInfo
)
{
nsAutoString
fileContent
;
nsresult
rv
=
ReadFile
(
fileContent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
startPos
=
fileContent
.
RFindChar
(
'
(
'
)
;
if
(
startPos
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
endPos
=
fileContent
.
RFindChar
(
'
)
'
)
;
if
(
endPos
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
len
=
endPos
-
(
startPos
+
1
)
;
aInfo
.
filename
.
Assign
(
Substring
(
fileContent
startPos
+
1
len
)
)
;
nsWhitespaceTokenizer
tokenizer
(
Substring
(
fileContent
endPos
+
2
)
)
;
int32_t
index
=
2
;
while
(
tokenizer
.
hasMoreTokens
(
)
&
&
index
<
mMaxIndex
)
{
const
nsAString
&
token
=
tokenizer
.
nextToken
(
)
;
rv
=
UseToken
(
index
token
aInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
index
+
+
;
}
return
NS_OK
;
}
protected
:
nsresult
UseToken
(
int32_t
aIndex
const
nsAString
&
aToken
ProcInfo
&
aInfo
)
{
nsresult
rv
=
NS_OK
;
switch
(
aIndex
)
{
case
13
:
aInfo
.
cpuUser
=
GetCPUTime
(
aToken
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
break
;
case
14
:
aInfo
.
cpuKernel
=
GetCPUTime
(
aToken
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
break
;
case
23
:
uint64_t
pageCount
=
Get64Value
(
aToken
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint64_t
pageSize
=
sysconf
(
_SC_PAGESIZE
)
;
aInfo
.
residentSetSize
=
pageCount
*
pageSize
;
break
;
}
return
rv
;
}
uint64_t
Get64Value
(
const
nsAString
&
aToken
nsresult
*
aRv
)
{
nsresult
rv
=
NS_OK
;
uint64_t
out
=
0
;
if
(
sscanf
(
NS_ConvertUTF16toUTF8
(
aToken
)
.
get
(
)
"
%
"
PRIu64
&
out
)
=
=
0
)
{
rv
=
NS_ERROR_FAILURE
;
}
*
aRv
=
rv
;
return
out
;
}
uint64_t
GetCPUTime
(
const
nsAString
&
aToken
nsresult
*
aRv
)
{
nsresult
rv
;
uint64_t
value
=
Get64Value
(
aToken
&
rv
)
;
*
aRv
=
rv
;
if
(
NS_FAILED
(
rv
)
)
{
return
0
;
}
if
(
value
)
{
value
=
(
value
*
NANOPERSEC
)
/
mTicksPerSec
;
}
return
value
;
}
base
:
:
ProcessId
mPid
;
int32_t
mMaxIndex
;
nsCString
mFilepath
;
ProcInfo
mProcInfo
;
private
:
nsresult
ReadFile
(
nsAutoString
&
aFileContent
)
{
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
mFilepath
)
;
bool
exists
;
nsresult
rv
=
file
-
>
Exists
(
&
exists
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
exists
)
{
return
NS_ERROR_FAILURE
;
}
FILE
*
fstat
;
if
(
NS_FAILED
(
file
-
>
OpenANSIFileDesc
(
"
r
"
&
fstat
)
)
|
|
!
fstat
)
{
return
NS_ERROR_FAILURE
;
}
char
buffer
[
2048
]
;
char
*
end
;
char
*
start
=
fgets
(
buffer
2048
fstat
)
;
fclose
(
fstat
)
;
if
(
start
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
end
=
strchr
(
buffer
'
\
n
'
)
;
if
(
!
end
)
{
return
NS_ERROR_FAILURE
;
}
aFileContent
.
AssignASCII
(
buffer
size_t
(
end
-
start
)
)
;
return
NS_OK
;
}
int64_t
mTicksPerSec
;
}
;
class
ThreadInfoReader
final
:
public
StatReader
{
public
:
ThreadInfoReader
(
const
base
:
:
ProcessId
aPid
const
base
:
:
ProcessId
aTid
)
:
StatReader
(
aPid
)
mTid
(
aTid
)
{
mFilepath
.
Truncate
(
)
;
mFilepath
.
AppendPrintf
(
"
/
proc
/
%
u
/
task
/
%
u
/
stat
"
aPid
mTid
)
;
mMaxIndex
=
17
;
}
nsresult
ParseThread
(
ThreadInfo
&
aInfo
)
{
ProcInfo
info
;
nsresult
rv
=
StatReader
:
:
ParseProc
(
info
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aInfo
.
tid
=
mTid
;
aInfo
.
cpuKernel
=
info
.
cpuKernel
;
aInfo
.
cpuUser
=
info
.
cpuUser
;
aInfo
.
name
.
Assign
(
info
.
filename
)
;
return
NS_OK
;
}
private
:
base
:
:
ProcessId
mTid
;
}
;
RefPtr
<
ProcInfoPromise
>
GetProcInfo
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
{
auto
holder
=
MakeUnique
<
MozPromiseHolder
<
ProcInfoPromise
>
>
(
)
;
RefPtr
<
ProcInfoPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
stream
transport
service
"
)
;
holder
-
>
Reject
(
rv
__func__
)
;
return
promise
;
}
RefPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
holder
=
std
:
:
move
(
holder
)
requests
=
std
:
:
move
(
aRequests
)
]
(
)
{
HashMap
<
base
:
:
ProcessId
ProcInfo
>
gathered
;
if
(
!
gathered
.
reserve
(
requests
.
Length
(
)
)
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
for
(
const
auto
&
request
:
requests
)
{
StatReader
reader
(
request
.
pid
)
;
ProcInfo
info
;
nsresult
rv
=
reader
.
ParseProc
(
info
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
info
.
residentUniqueSize
=
nsMemoryReporterManager
:
:
ResidentUnique
(
request
.
pid
)
;
info
.
pid
=
request
.
pid
;
info
.
childId
=
request
.
childId
;
info
.
type
=
request
.
processType
;
info
.
origin
=
request
.
origin
;
info
.
windows
=
std
:
:
move
(
request
.
windowInfo
)
;
nsCString
taskPath
;
taskPath
.
AppendPrintf
(
"
/
proc
/
%
u
/
task
"
request
.
pid
)
;
nsAutoRef
<
DIR
>
dirHandle
(
opendir
(
taskPath
.
get
(
)
)
)
;
if
(
!
dirHandle
)
{
continue
;
}
dirent
*
entry
;
while
(
(
entry
=
readdir
(
dirHandle
)
)
!
=
nullptr
)
{
if
(
entry
-
>
d_name
[
0
]
=
=
'
.
'
)
{
continue
;
}
nsAutoCString
entryName
(
entry
-
>
d_name
)
;
int32_t
tid
=
entryName
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
ThreadInfoReader
reader
(
request
.
pid
tid
)
;
ThreadInfo
threadInfo
;
rv
=
reader
.
ParseThread
(
threadInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
info
.
threads
.
AppendElement
(
threadInfo
)
;
}
if
(
!
gathered
.
put
(
request
.
pid
std
:
:
move
(
info
)
)
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
}
holder
-
>
Resolve
(
std
:
:
move
(
gathered
)
__func__
)
;
}
)
;
rv
=
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
the
LoadDataRunnable
.
"
)
;
}
return
promise
;
}
}
