#
ifndef
__nsClipboard_h_
#
define
__nsClipboard_h_
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
GUniquePtr
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
ifdef
MOZ_LOGGING
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
Units
.
h
"
extern
mozilla
:
:
LazyLogModule
gClipboardLog
;
#
define
LOGCLIP
(
.
.
.
)
\
MOZ_LOG
(
gClipboardLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
LOGCLIP_ENABLED
(
)
\
MOZ_LOG_TEST
(
gClipboardLog
mozilla
:
:
LogLevel
:
:
Debug
)
#
else
#
define
LOGCLIP
(
.
.
.
)
#
define
LOGCLIP_ENABLED
(
)
false
#
endif
struct
ClipboardTargets
{
mozilla
:
:
GUniquePtr
<
GdkAtom
>
mTargets
;
uint32_t
mCount
=
0
;
mozilla
:
:
Span
<
GdkAtom
>
AsSpan
(
)
const
{
return
{
mTargets
.
get
(
)
mCount
}
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mTargets
)
;
}
}
;
struct
ClipboardData
{
mozilla
:
:
GUniquePtr
<
char
>
mData
;
uint32_t
mLength
=
0
;
void
SetData
(
mozilla
:
:
Span
<
const
uint8_t
>
)
;
void
SetText
(
mozilla
:
:
Span
<
const
char
>
)
;
void
SetTargets
(
ClipboardTargets
)
;
ClipboardTargets
ExtractTargets
(
)
;
mozilla
:
:
Span
<
char
>
AsSpan
(
)
const
{
return
{
mData
.
get
(
)
mLength
}
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mData
)
;
}
}
;
enum
class
ClipboardDataType
{
Data
Text
Targets
}
;
class
nsRetrievalContext
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
nsRetrievalContext
)
virtual
ClipboardData
GetClipboardData
(
const
char
*
aMimeType
int32_t
aWhichClipboard
)
=
0
;
virtual
mozilla
:
:
GUniquePtr
<
char
>
GetClipboardText
(
int32_t
aWhichClipboard
)
=
0
;
virtual
ClipboardTargets
GetTargets
(
int32_t
aWhichClipboard
)
=
0
;
virtual
bool
HasSelectionSupport
(
void
)
=
0
;
protected
:
virtual
~
nsRetrievalContext
(
)
=
default
;
}
;
class
nsClipboard
:
public
nsIClipboard
public
nsIObserver
{
public
:
nsClipboard
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSICLIPBOARD
nsresult
Init
(
void
)
;
void
SelectionGetEvent
(
GtkClipboard
*
aGtkClipboard
GtkSelectionData
*
aSelectionData
)
;
void
SelectionClearEvent
(
GtkClipboard
*
aGtkClipboard
)
;
private
:
virtual
~
nsClipboard
(
)
;
nsITransferable
*
GetTransferable
(
int32_t
aWhichClipboard
)
;
void
SetTransferableData
(
nsITransferable
*
aTransferable
nsCString
&
aFlavor
const
char
*
aClipboardData
uint32_t
aClipboardDataLength
)
;
void
ClearTransferable
(
int32_t
aWhichClipboard
)
;
bool
FilterImportedFlavors
(
int32_t
aWhichClipboard
nsTArray
<
nsCString
>
&
aFlavors
)
;
nsCOMPtr
<
nsIClipboardOwner
>
mSelectionOwner
;
nsCOMPtr
<
nsIClipboardOwner
>
mGlobalOwner
;
nsCOMPtr
<
nsITransferable
>
mSelectionTransferable
;
nsCOMPtr
<
nsITransferable
>
mGlobalTransferable
;
RefPtr
<
nsRetrievalContext
>
mContext
;
}
;
extern
const
int
kClipboardTimeout
;
extern
const
int
kClipboardFastIterationNum
;
GdkAtom
GetSelectionAtom
(
int32_t
aWhichClipboard
)
;
int
GetGeckoClipboardType
(
GtkClipboard
*
aGtkClipboard
)
;
#
endif
