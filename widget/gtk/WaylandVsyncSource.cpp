#
ifdef
MOZ_WAYLAND
#
include
"
WaylandVsyncSource
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
<
gdk
/
gdkwayland
.
h
>
using
namespace
mozilla
:
:
widget
;
namespace
mozilla
{
static
void
WaylandVsyncSourceCallbackHandler
(
void
*
data
struct
wl_callback
*
callback
uint32_t
time
)
{
WaylandVsyncSource
:
:
WaylandDisplay
*
context
=
(
WaylandVsyncSource
:
:
WaylandDisplay
*
)
data
;
wl_callback_destroy
(
callback
)
;
context
-
>
FrameCallback
(
)
;
}
static
const
struct
wl_callback_listener
WaylandVsyncSourceCallbackListener
=
{
WaylandVsyncSourceCallbackHandler
}
;
WaylandVsyncSource
:
:
WaylandDisplay
:
:
WaylandDisplay
(
MozContainer
*
container
)
:
mEnabledLock
(
"
WaylandVsyncEnabledLock
"
)
mVsyncEnabled
(
false
)
mMonitorEnabled
(
false
)
mCallback
(
nullptr
)
mContainer
(
container
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDisplay
=
WaylandDisplayGetWLDisplay
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
ClearFrameCallback
(
)
{
if
(
mCallback
)
{
wl_callback_destroy
(
mCallback
)
;
mCallback
=
nullptr
;
}
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
Refresh
(
)
{
if
(
!
mMonitorEnabled
|
|
!
mVsyncEnabled
|
|
mCallback
)
{
return
;
}
struct
wl_surface
*
surface
=
moz_container_wayland_surface_lock
(
mContainer
)
;
if
(
!
surface
)
{
RefPtr
<
WaylandVsyncSource
:
:
WaylandDisplay
>
self
(
this
)
;
moz_container_wayland_add_initial_draw_callback
(
mContainer
[
self
]
(
)
-
>
void
{
MutexAutoLock
lock
(
self
-
>
mEnabledLock
)
;
self
-
>
Refresh
(
)
;
}
)
;
return
;
}
moz_container_wayland_surface_unlock
(
mContainer
&
surface
)
;
SetupFrameCallback
(
)
;
TimeStamp
vsyncTimestamp
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
outputTimestamp
=
vsyncTimestamp
+
GetVsyncRate
(
)
;
NotifyVsync
(
vsyncTimestamp
outputTimestamp
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
EnableMonitor
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
mMonitorEnabled
)
{
return
;
}
mMonitorEnabled
=
true
;
Refresh
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
DisableMonitor
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
!
mMonitorEnabled
)
{
return
;
}
mMonitorEnabled
=
false
;
ClearFrameCallback
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
SetupFrameCallback
(
)
{
MOZ_ASSERT
(
mCallback
=
=
nullptr
)
;
struct
wl_surface
*
surface
=
moz_container_wayland_surface_lock
(
mContainer
)
;
if
(
!
surface
)
{
ClearFrameCallback
(
)
;
return
;
}
mCallback
=
wl_surface_frame
(
surface
)
;
wl_callback_add_listener
(
mCallback
&
WaylandVsyncSourceCallbackListener
this
)
;
wl_surface_commit
(
surface
)
;
wl_display_flush
(
mDisplay
)
;
moz_container_wayland_surface_unlock
(
mContainer
&
surface
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
FrameCallback
(
)
{
{
MutexAutoLock
lock
(
mEnabledLock
)
;
mCallback
=
nullptr
;
if
(
!
mVsyncEnabled
|
|
!
mMonitorEnabled
)
{
return
;
}
SetupFrameCallback
(
)
;
}
TimeStamp
vsyncTimestamp
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
outputTimestamp
=
vsyncTimestamp
+
GetVsyncRate
(
)
;
NotifyVsync
(
vsyncTimestamp
outputTimestamp
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
EnableVsync
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
mVsyncEnabled
)
{
return
;
}
mVsyncEnabled
=
true
;
Refresh
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
DisableVsync
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
mVsyncEnabled
=
false
;
ClearFrameCallback
(
)
;
}
bool
WaylandVsyncSource
:
:
WaylandDisplay
:
:
IsVsyncEnabled
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
return
mVsyncEnabled
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
DisableVsync
(
)
;
wl_display_roundtrip
(
mDisplay
)
;
}
}
#
endif
