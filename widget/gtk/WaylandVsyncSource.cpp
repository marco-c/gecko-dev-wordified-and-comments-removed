#
ifdef
MOZ_WAYLAND
#
include
"
WaylandVsyncSource
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
<
gdk
/
gdkwayland
.
h
>
using
namespace
mozilla
:
:
widget
;
namespace
mozilla
{
static
void
WaylandVsyncSourceCallbackHandler
(
void
*
data
struct
wl_callback
*
callback
uint32_t
time
)
{
WaylandVsyncSource
:
:
WaylandDisplay
*
context
=
(
WaylandVsyncSource
:
:
WaylandDisplay
*
)
data
;
wl_callback_destroy
(
callback
)
;
context
-
>
FrameCallback
(
time
)
;
}
static
const
struct
wl_callback_listener
WaylandVsyncSourceCallbackListener
=
{
WaylandVsyncSourceCallbackHandler
}
;
WaylandVsyncSource
:
:
WaylandDisplay
:
:
WaylandDisplay
(
MozContainer
*
container
)
:
mEnabledLock
(
"
WaylandVsyncEnabledLock
"
)
mIsShutdown
(
false
)
mVsyncEnabled
(
false
)
mMonitorEnabled
(
false
)
mCallback
(
nullptr
)
mContainer
(
container
)
mLastVsyncTimeStamp
(
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDisplay
=
WaylandDisplayGetWLDisplay
(
)
;
mVsyncRate
=
TimeDuration
:
:
FromMilliseconds
(
1000
.
0
/
60
.
0
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
ClearFrameCallback
(
)
{
if
(
mCallback
)
{
wl_callback_destroy
(
mCallback
)
;
mCallback
=
nullptr
;
}
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
Refresh
(
)
{
TimeStamp
outputTimestamp
;
{
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
!
mMonitorEnabled
|
|
!
mVsyncEnabled
|
|
mCallback
)
{
return
;
}
struct
wl_surface
*
surface
=
moz_container_wayland_surface_lock
(
mContainer
)
;
if
(
!
surface
)
{
RefPtr
<
WaylandVsyncSource
:
:
WaylandDisplay
>
self
(
this
)
;
moz_container_wayland_add_initial_draw_callback
(
mContainer
[
self
]
(
)
-
>
void
{
self
-
>
Refresh
(
)
;
}
)
;
return
;
}
moz_container_wayland_surface_unlock
(
mContainer
&
surface
)
;
SetupFrameCallback
(
)
;
mLastVsyncTimeStamp
=
TimeStamp
:
:
Now
(
)
;
outputTimestamp
=
mLastVsyncTimeStamp
+
GetVsyncRate
(
)
;
}
NotifyVsync
(
mLastVsyncTimeStamp
outputTimestamp
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
EnableMonitor
(
)
{
{
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
mMonitorEnabled
)
{
return
;
}
mMonitorEnabled
=
true
;
}
Refresh
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
DisableMonitor
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
!
mMonitorEnabled
)
{
return
;
}
mMonitorEnabled
=
false
;
ClearFrameCallback
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
SetupFrameCallback
(
)
{
MOZ_ASSERT
(
mCallback
=
=
nullptr
)
;
struct
wl_surface
*
surface
=
moz_container_wayland_surface_lock
(
mContainer
)
;
if
(
!
surface
)
{
ClearFrameCallback
(
)
;
return
;
}
mCallback
=
wl_surface_frame
(
surface
)
;
wl_callback_add_listener
(
mCallback
&
WaylandVsyncSourceCallbackListener
this
)
;
wl_surface_commit
(
surface
)
;
wl_display_flush
(
mDisplay
)
;
moz_container_wayland_surface_unlock
(
mContainer
&
surface
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
FrameCallback
(
uint32_t
timestampTime
)
{
TimeStamp
outputTimestamp
;
{
MutexAutoLock
lock
(
mEnabledLock
)
;
mCallback
=
nullptr
;
if
(
!
mVsyncEnabled
|
|
!
mMonitorEnabled
)
{
return
;
}
SetupFrameCallback
(
)
;
int64_t
tick
=
BaseTimeDurationPlatformUtils
:
:
TicksFromMilliseconds
(
timestampTime
)
;
TimeStamp
callbackTimeStamp
=
TimeStamp
:
:
FromSystemTime
(
tick
)
;
double
duration
=
(
TimeStamp
:
:
Now
(
)
-
callbackTimeStamp
)
.
ToMilliseconds
(
)
;
TimeStamp
vsyncTimestamp
;
if
(
duration
<
50
&
&
duration
>
-
50
)
{
vsyncTimestamp
=
callbackTimeStamp
;
}
else
{
vsyncTimestamp
=
TimeStamp
:
:
Now
(
)
;
}
CalculateVsyncRate
(
vsyncTimestamp
)
;
mLastVsyncTimeStamp
=
vsyncTimestamp
;
outputTimestamp
=
vsyncTimestamp
+
GetVsyncRate
(
)
;
}
NotifyVsync
(
mLastVsyncTimeStamp
outputTimestamp
)
;
}
TimeDuration
WaylandVsyncSource
:
:
WaylandDisplay
:
:
GetVsyncRate
(
)
{
return
mVsyncRate
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
CalculateVsyncRate
(
TimeStamp
vsyncTimestamp
)
{
double
duration
=
(
vsyncTimestamp
-
mLastVsyncTimeStamp
)
.
ToMilliseconds
(
)
;
double
curVsyncRate
=
mVsyncRate
.
ToMilliseconds
(
)
;
double
correction
;
if
(
duration
>
curVsyncRate
)
{
correction
=
fmin
(
curVsyncRate
(
duration
-
curVsyncRate
)
/
10
)
;
mVsyncRate
+
=
TimeDuration
:
:
FromMilliseconds
(
correction
)
;
}
else
{
correction
=
fmin
(
curVsyncRate
/
2
(
curVsyncRate
-
duration
)
/
10
)
;
mVsyncRate
-
=
TimeDuration
:
:
FromMilliseconds
(
correction
)
;
}
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
EnableVsync
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
{
MutexAutoLock
lock
(
mEnabledLock
)
;
if
(
mVsyncEnabled
|
|
mIsShutdown
)
{
return
;
}
mVsyncEnabled
=
true
;
}
Refresh
(
)
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
DisableVsync
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
mVsyncEnabled
=
false
;
ClearFrameCallback
(
)
;
}
bool
WaylandVsyncSource
:
:
WaylandDisplay
:
:
IsVsyncEnabled
(
)
{
MutexAutoLock
lock
(
mEnabledLock
)
;
return
mVsyncEnabled
;
}
void
WaylandVsyncSource
:
:
WaylandDisplay
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mEnabledLock
)
;
mIsShutdown
=
true
;
mVsyncEnabled
=
false
;
ClearFrameCallback
(
)
;
wl_display_roundtrip
(
mDisplay
)
;
}
}
#
endif
