#
include
"
nsNativeThemeGTK
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
gtk
/
gtk
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
GtkWidgets
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
BorrowedContext
.
h
"
#
include
"
mozilla
/
gfx
/
HelpersCairo
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
ifdef
MOZ_X11
#
ifdef
CAIRO_HAS_XLIB_SURFACE
#
include
"
cairo
-
xlib
.
h
"
#
endif
#
endif
#
include
<
dlfcn
.
h
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
widget
;
static
inline
CSSToLayoutDeviceScale
GetWidgetScaleFactor
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
aAppearance
=
=
StyleAppearance
:
:
MozWindowDecorations
)
{
return
CSSToLayoutDeviceScale
{
float
(
AppUnitsPerCSSPixel
(
)
)
/
float
(
aFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
)
}
;
}
return
aFrame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
;
}
nsNativeThemeGTK
:
:
nsNativeThemeGTK
(
)
:
Theme
(
ScrollbarStyle
(
)
)
{
}
nsNativeThemeGTK
:
:
~
nsNativeThemeGTK
(
)
{
GtkWidgets
:
:
Shutdown
(
)
;
}
static
Maybe
<
GtkWidgets
:
:
Type
>
AppearanceToWidgetType
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozWindowDecorations
:
return
Some
(
GtkWidgets
:
:
Type
:
:
WindowDecoration
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
widget
"
)
;
break
;
}
return
{
}
;
}
class
SystemCairoClipper
:
public
ClipExporter
{
public
:
explicit
SystemCairoClipper
(
cairo_t
*
aContext
gint
aScaleFactor
=
1
)
:
mContext
(
aContext
)
mScaleFactor
(
aScaleFactor
)
{
}
void
BeginClip
(
const
Matrix
&
aTransform
)
override
{
cairo_matrix_t
mat
;
GfxMatrixToCairoMatrix
(
aTransform
mat
)
;
mat
.
y0
=
mat
.
y0
/
mScaleFactor
;
mat
.
x0
=
mat
.
x0
/
mScaleFactor
;
cairo_set_matrix
(
mContext
&
mat
)
;
cairo_new_path
(
mContext
)
;
}
void
MoveTo
(
const
Point
&
aPoint
)
override
{
cairo_move_to
(
mContext
aPoint
.
x
/
mScaleFactor
aPoint
.
y
/
mScaleFactor
)
;
mBeginPoint
=
aPoint
;
mCurrentPoint
=
aPoint
;
}
void
LineTo
(
const
Point
&
aPoint
)
override
{
cairo_line_to
(
mContext
aPoint
.
x
/
mScaleFactor
aPoint
.
y
/
mScaleFactor
)
;
mCurrentPoint
=
aPoint
;
}
void
BezierTo
(
const
Point
&
aCP1
const
Point
&
aCP2
const
Point
&
aCP3
)
override
{
cairo_curve_to
(
mContext
aCP1
.
x
/
mScaleFactor
aCP1
.
y
/
mScaleFactor
aCP2
.
x
/
mScaleFactor
aCP2
.
y
/
mScaleFactor
aCP3
.
x
/
mScaleFactor
aCP3
.
y
/
mScaleFactor
)
;
mCurrentPoint
=
aCP3
;
}
void
QuadraticBezierTo
(
const
Point
&
aCP1
const
Point
&
aCP2
)
override
{
Point
CP0
=
CurrentPoint
(
)
;
Point
CP1
=
(
CP0
+
aCP1
*
2
.
0
)
/
3
.
0
;
Point
CP2
=
(
aCP2
+
aCP1
*
2
.
0
)
/
3
.
0
;
Point
CP3
=
aCP2
;
cairo_curve_to
(
mContext
CP1
.
x
/
mScaleFactor
CP1
.
y
/
mScaleFactor
CP2
.
x
/
mScaleFactor
CP2
.
y
/
mScaleFactor
CP3
.
x
/
mScaleFactor
CP3
.
y
/
mScaleFactor
)
;
mCurrentPoint
=
aCP2
;
}
void
Arc
(
const
Point
&
aOrigin
float
aRadius
float
aStartAngle
float
aEndAngle
bool
aAntiClockwise
)
override
{
ArcToBezier
(
this
aOrigin
Size
(
aRadius
aRadius
)
aStartAngle
aEndAngle
aAntiClockwise
)
;
}
void
Close
(
)
override
{
cairo_close_path
(
mContext
)
;
mCurrentPoint
=
mBeginPoint
;
}
void
EndClip
(
)
override
{
cairo_clip
(
mContext
)
;
}
private
:
cairo_t
*
mContext
;
gint
mScaleFactor
;
}
;
static
void
DrawThemeWithCairo
(
gfxContext
*
aContext
DrawTarget
*
aDrawTarget
const
GtkWidgets
:
:
DrawingParams
&
aParams
double
aScaleFactor
bool
aSnapped
const
Point
&
aDrawOrigin
const
nsIntSize
&
aDrawSize
nsITheme
:
:
Transparency
aTransparency
)
{
static
auto
sCairoSurfaceSetDeviceScalePtr
=
(
void
(
*
)
(
cairo_surface_t
*
double
double
)
)
dlsym
(
RTLD_DEFAULT
"
cairo_surface_set_device_scale
"
)
;
const
bool
useHiDPIWidgets
=
aScaleFactor
!
=
1
.
0
&
&
sCairoSurfaceSetDeviceScalePtr
;
Point
drawOffsetScaled
;
Point
drawOffsetOriginal
;
Matrix
transform
;
if
(
!
aSnapped
)
{
drawOffsetOriginal
=
aDrawOrigin
;
drawOffsetScaled
=
useHiDPIWidgets
?
drawOffsetOriginal
/
aScaleFactor
:
drawOffsetOriginal
;
transform
=
aDrawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
drawOffsetScaled
)
;
}
else
{
drawOffsetOriginal
=
aDrawOrigin
-
aContext
-
>
GetDeviceOffset
(
)
;
drawOffsetScaled
=
useHiDPIWidgets
?
drawOffsetOriginal
/
aScaleFactor
:
drawOffsetOriginal
;
transform
=
Matrix
:
:
Translation
(
drawOffsetScaled
)
;
}
if
(
!
useHiDPIWidgets
&
&
aScaleFactor
!
=
1
)
{
transform
.
PreScale
(
aScaleFactor
aScaleFactor
)
;
}
cairo_matrix_t
mat
;
GfxMatrixToCairoMatrix
(
transform
mat
)
;
Size
clipSize
(
(
aDrawSize
.
width
+
aScaleFactor
-
1
)
/
aScaleFactor
(
aDrawSize
.
height
+
aScaleFactor
-
1
)
/
aScaleFactor
)
;
#
if
defined
(
MOZ_X11
)
&
&
defined
(
CAIRO_HAS_XLIB_SURFACE
)
if
(
GdkIsX11Display
(
)
)
{
BorrowedXlibDrawable
borrow
(
aDrawTarget
)
;
if
(
Drawable
drawable
=
borrow
.
GetDrawable
(
)
)
{
nsIntSize
size
=
borrow
.
GetSize
(
)
;
cairo_surface_t
*
surf
=
cairo_xlib_surface_create
(
borrow
.
GetDisplay
(
)
drawable
borrow
.
GetVisual
(
)
size
.
width
size
.
height
)
;
if
(
!
NS_WARN_IF
(
!
surf
)
)
{
Point
offset
=
borrow
.
GetOffset
(
)
;
if
(
offset
!
=
Point
(
)
)
{
cairo_surface_set_device_offset
(
surf
offset
.
x
offset
.
y
)
;
}
cairo_t
*
cr
=
cairo_create
(
surf
)
;
if
(
!
NS_WARN_IF
(
!
cr
)
)
{
RefPtr
<
SystemCairoClipper
>
clipper
=
new
SystemCairoClipper
(
cr
)
;
aContext
-
>
ExportClip
(
*
clipper
)
;
cairo_set_matrix
(
cr
&
mat
)
;
cairo_new_path
(
cr
)
;
cairo_rectangle
(
cr
0
0
clipSize
.
width
clipSize
.
height
)
;
cairo_clip
(
cr
)
;
GtkWidgets
:
:
Draw
(
cr
&
aParams
)
;
cairo_destroy
(
cr
)
;
}
cairo_surface_destroy
(
surf
)
;
}
borrow
.
Finish
(
)
;
return
;
}
}
#
endif
uint8_t
*
data
;
nsIntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
IntPoint
origin
;
if
(
aDrawTarget
-
>
LockBits
(
&
data
&
size
&
stride
&
format
&
origin
)
)
{
cairo_surface_t
*
surf
=
cairo_image_surface_create_for_data
(
data
GfxFormatToCairoFormat
(
format
)
size
.
width
size
.
height
stride
)
;
if
(
!
NS_WARN_IF
(
!
surf
)
)
{
if
(
useHiDPIWidgets
)
{
sCairoSurfaceSetDeviceScalePtr
(
surf
aScaleFactor
aScaleFactor
)
;
}
if
(
origin
!
=
IntPoint
(
)
)
{
cairo_surface_set_device_offset
(
surf
-
origin
.
x
-
origin
.
y
)
;
}
cairo_t
*
cr
=
cairo_create
(
surf
)
;
if
(
!
NS_WARN_IF
(
!
cr
)
)
{
RefPtr
<
SystemCairoClipper
>
clipper
=
new
SystemCairoClipper
(
cr
useHiDPIWidgets
?
aScaleFactor
:
1
)
;
aContext
-
>
ExportClip
(
*
clipper
)
;
cairo_set_matrix
(
cr
&
mat
)
;
cairo_new_path
(
cr
)
;
cairo_rectangle
(
cr
0
0
clipSize
.
width
clipSize
.
height
)
;
cairo_clip
(
cr
)
;
GtkWidgets
:
:
Draw
(
cr
&
aParams
)
;
cairo_destroy
(
cr
)
;
}
cairo_surface_destroy
(
surf
)
;
}
aDrawTarget
-
>
ReleaseBits
(
data
)
;
}
else
{
format
=
aTransparency
!
=
nsITheme
:
:
eOpaque
?
SurfaceFormat
:
:
B8G8R8A8
:
aDrawTarget
-
>
GetFormat
(
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
aDrawSize
format
aTransparency
!
=
nsITheme
:
:
eOpaque
)
;
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
NS_WARN_IF
(
!
(
dataSurface
&
&
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
WRITE
&
map
)
)
)
)
{
cairo_surface_t
*
surf
=
cairo_image_surface_create_for_data
(
map
.
mData
GfxFormatToCairoFormat
(
format
)
aDrawSize
.
width
aDrawSize
.
height
map
.
mStride
)
;
cairo_t
*
cr
=
nullptr
;
if
(
!
NS_WARN_IF
(
!
surf
)
)
{
cr
=
cairo_create
(
surf
)
;
if
(
!
NS_WARN_IF
(
!
cr
)
)
{
if
(
aScaleFactor
!
=
1
)
{
if
(
useHiDPIWidgets
)
{
sCairoSurfaceSetDeviceScalePtr
(
surf
aScaleFactor
aScaleFactor
)
;
}
else
{
cairo_scale
(
cr
aScaleFactor
aScaleFactor
)
;
}
}
GtkWidgets
:
:
Draw
(
cr
&
aParams
)
;
}
}
dataSurface
-
>
Unmap
(
)
;
if
(
cr
)
{
aDrawTarget
-
>
DrawSurface
(
dataSurface
Rect
(
aSnapped
?
drawOffsetOriginal
-
aDrawTarget
-
>
GetTransform
(
)
.
GetTranslation
(
)
:
drawOffsetOriginal
Size
(
aDrawSize
)
)
Rect
(
0
0
aDrawSize
.
width
aDrawSize
.
height
)
)
;
cairo_destroy
(
cr
)
;
}
if
(
surf
)
{
cairo_surface_destroy
(
surf
)
;
}
}
}
}
void
nsNativeThemeGTK
:
:
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
DrawOverflow
aDrawOverflow
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
DrawWidgetBackground
(
aContext
aFrame
aAppearance
aRect
aDirtyRect
aDrawOverflow
)
;
}
auto
gtkType
=
AppearanceToWidgetType
(
aAppearance
)
;
if
(
!
gtkType
)
{
return
;
}
gfxContext
*
ctx
=
aContext
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
gfxRect
rect
=
presContext
-
>
AppUnitsToGfxUnits
(
aRect
)
;
gfxRect
dirtyRect
=
presContext
-
>
AppUnitsToGfxUnits
(
aDirtyRect
)
;
bool
snapped
=
ctx
-
>
UserToDevicePixelSnapped
(
rect
gfxContext
:
:
SnapOption
:
:
PrioritizeSize
)
;
if
(
snapped
)
{
dirtyRect
=
ctx
-
>
UserToDevice
(
dirtyRect
)
;
}
dirtyRect
.
MoveBy
(
-
rect
.
TopLeft
(
)
)
;
dirtyRect
.
RoundOut
(
)
;
LayoutDeviceIntRect
widgetRect
(
0
0
NS_lround
(
rect
.
Width
(
)
)
NS_lround
(
rect
.
Height
(
)
)
)
;
LayoutDeviceIntRect
drawingRect
(
int32_t
(
dirtyRect
.
X
(
)
)
int32_t
(
dirtyRect
.
Y
(
)
)
int32_t
(
dirtyRect
.
Width
(
)
)
int32_t
(
dirtyRect
.
Height
(
)
)
)
;
if
(
widgetRect
.
IsEmpty
(
)
|
|
!
drawingRect
.
IntersectRect
(
widgetRect
drawingRect
)
)
{
return
;
}
Transparency
transparency
=
GetWidgetTransparency
(
aFrame
aAppearance
)
;
auto
scaleFactor
=
GetWidgetScaleFactor
(
aFrame
aAppearance
)
;
LayoutDeviceIntRect
gdkDevRect
(
-
drawingRect
.
TopLeft
(
)
widgetRect
.
Size
(
)
)
;
auto
gdkCssRect
=
CSSIntRect
:
:
RoundIn
(
gdkDevRect
/
scaleFactor
)
;
GdkRectangle
gdk_rect
=
{
gdkCssRect
.
x
gdkCssRect
.
y
gdkCssRect
.
width
gdkCssRect
.
height
}
;
GtkWidgets
:
:
DrawingParams
params
{
.
widget
=
*
gtkType
.
rect
=
gdk_rect
.
state
=
GTK_STATE_FLAG_NORMAL
.
image_scale
=
gint
(
std
:
:
ceil
(
scaleFactor
.
scale
)
)
}
;
if
(
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
State
(
)
.
HasState
(
dom
:
:
DocumentState
:
:
WINDOW_INACTIVE
)
)
{
params
.
state
=
GtkStateFlags
(
gint
(
params
.
state
)
|
GTK_STATE_FLAG_BACKDROP
)
;
}
gfxPoint
origin
=
rect
.
TopLeft
(
)
+
drawingRect
.
TopLeft
(
)
.
ToUnknownPoint
(
)
;
DrawThemeWithCairo
(
ctx
aContext
-
>
GetDrawTarget
(
)
params
scaleFactor
.
scale
snapped
ToPoint
(
origin
)
drawingRect
.
Size
(
)
.
ToUnknownSize
(
)
transparency
)
;
}
bool
nsNativeThemeGTK
:
:
CreateWebRenderCommandsForWidget
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
CreateWebRenderCommandsForWidget
(
aBuilder
aResources
aSc
aManager
aFrame
aAppearance
aRect
)
;
}
if
(
aAppearance
=
=
StyleAppearance
:
:
MozWindowDecorations
&
&
GdkIsWaylandDisplay
(
)
)
{
return
true
;
}
return
false
;
}
LayoutDeviceIntMargin
nsNativeThemeGTK
:
:
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetWidgetBorder
(
aContext
aFrame
aAppearance
)
;
}
return
{
}
;
}
bool
nsNativeThemeGTK
:
:
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetWidgetPadding
(
aContext
aFrame
aAppearance
aResult
)
;
}
return
false
;
}
bool
nsNativeThemeGTK
:
:
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
GetWidgetOverflow
(
aContext
aFrame
aAppearance
aOverflowRect
)
;
}
return
false
;
}
auto
nsNativeThemeGTK
:
:
IsWidgetNonNative
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
-
>
NonNative
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
NonNative
:
:
Always
;
}
if
(
LookAndFeel
:
:
ColorSchemeForFrame
(
aFrame
)
=
=
PreferenceSheet
:
:
ColorSchemeForChrome
(
)
)
{
return
NonNative
:
:
No
;
}
if
(
!
Theme
:
:
ThemeSupportsWidget
(
aFrame
-
>
PresContext
(
)
aFrame
aAppearance
)
)
{
return
NonNative
:
:
No
;
}
return
NonNative
:
:
BecauseColorMismatch
;
}
bool
nsNativeThemeGTK
:
:
IsWidgetAlwaysNonNative
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
return
Theme
:
:
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
|
|
aAppearance
=
=
StyleAppearance
:
:
MozMenulistArrowButton
|
|
aAppearance
=
=
StyleAppearance
:
:
Textfield
|
|
aAppearance
=
=
StyleAppearance
:
:
NumberInput
|
|
aAppearance
=
=
StyleAppearance
:
:
PasswordInput
|
|
aAppearance
=
=
StyleAppearance
:
:
Textarea
|
|
aAppearance
=
=
StyleAppearance
:
:
Checkbox
|
|
aAppearance
=
=
StyleAppearance
:
:
Radio
|
|
aAppearance
=
=
StyleAppearance
:
:
Button
|
|
aAppearance
=
=
StyleAppearance
:
:
Listbox
|
|
aAppearance
=
=
StyleAppearance
:
:
Menulist
;
}
LayoutDeviceIntSize
nsNativeThemeGTK
:
:
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetMinimumWidgetSize
(
aPresContext
aFrame
aAppearance
)
;
}
return
{
}
;
}
bool
nsNativeThemeGTK
:
:
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
ThemeSupportsWidget
(
aPresContext
aFrame
aAppearance
)
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozWindowDecorations
:
return
!
IsWidgetStyled
(
aPresContext
aFrame
aAppearance
)
;
default
:
break
;
}
return
false
;
}
bool
nsNativeThemeGTK
:
:
ThemeDrawsFocusForWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
ThemeDrawsFocusForWidget
(
aFrame
aAppearance
)
;
}
return
false
;
}
nsITheme
:
:
Transparency
nsNativeThemeGTK
:
:
GetWidgetTransparency
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetNonNative
(
aFrame
aAppearance
)
!
=
NonNative
:
:
No
)
{
return
Theme
:
:
GetWidgetTransparency
(
aFrame
aAppearance
)
;
}
return
eUnknownTransparency
;
}
already_AddRefed
<
Theme
>
do_CreateNativeThemeDoNotUseDirectly
(
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
do_AddRef
(
new
Theme
(
Theme
:
:
ScrollbarStyle
(
)
)
)
;
}
return
do_AddRef
(
new
nsNativeThemeGTK
(
)
)
;
}
