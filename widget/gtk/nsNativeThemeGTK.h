#
ifndef
_GTK_NSNATIVETHEMEGTK_H_
#
define
_GTK_NSNATIVETHEMEGTK_H_
#
include
"
nsITheme
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
Theme
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
"
gtkdrawing
.
h
"
class
nsNativeThemeGTK
final
:
public
mozilla
:
:
widget
:
:
Theme
{
using
Theme
=
mozilla
:
:
widget
:
:
Theme
;
public
:
NS_IMETHOD
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
DrawOverflow
)
override
;
bool
CreateWebRenderCommandsForWidget
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsIFrame
*
StyleAppearance
const
nsRect
&
aRect
)
override
;
[
[
nodiscard
]
]
LayoutDeviceIntMargin
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
bool
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
override
;
bool
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
override
;
enum
class
NonNative
{
No
Always
BecauseColorMismatch
}
;
static
bool
IsWidgetAlwaysNonNative
(
nsIFrame
*
StyleAppearance
)
;
NonNative
IsWidgetNonNative
(
nsIFrame
*
StyleAppearance
)
;
mozilla
:
:
LayoutDeviceIntSize
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
NS_IMETHOD
WidgetStateChanged
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsAtom
*
aAttribute
bool
*
aShouldRepaint
const
nsAttrValue
*
aOldValue
)
override
;
NS_IMETHOD
ThemeChanged
(
)
override
;
NS_IMETHOD_
(
bool
)
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
NS_IMETHOD_
(
bool
)
WidgetIsContainer
(
StyleAppearance
aAppearance
)
override
;
bool
ThemeDrawsFocusForWidget
(
nsIFrame
*
StyleAppearance
)
override
;
bool
ThemeNeedsComboboxDropmarker
(
)
override
;
Transparency
GetWidgetTransparency
(
nsIFrame
*
StyleAppearance
)
override
;
nsNativeThemeGTK
(
)
;
protected
:
virtual
~
nsNativeThemeGTK
(
)
;
private
:
GtkTextDirection
GetTextDirection
(
nsIFrame
*
aFrame
)
;
gint
GetTabMarginPixels
(
nsIFrame
*
aFrame
)
;
bool
GetGtkWidgetAndState
(
StyleAppearance
aAppearance
nsIFrame
*
aFrame
WidgetNodeType
&
aGtkWidgetType
GtkWidgetState
*
aState
gint
*
aWidgetFlags
)
;
mozilla
:
:
CSSIntMargin
GetExtraSizeForWidget
(
nsIFrame
*
StyleAppearance
)
;
void
RefreshWidgetWindow
(
nsIFrame
*
aFrame
)
;
WidgetNodeType
NativeThemeToGtkTheme
(
StyleAppearance
aAppearance
nsIFrame
*
aFrame
)
;
uint8_t
mDisabledWidgetTypes
[
(
static_cast
<
size_t
>
(
mozilla
:
:
StyleAppearance
:
:
Count
)
+
7
)
/
8
]
;
uint8_t
mSafeWidgetStates
[
static_cast
<
size_t
>
(
mozilla
:
:
StyleAppearance
:
:
Count
)
*
4
]
;
static
const
char
*
sDisabledEngines
[
]
;
mozilla
:
:
CSSIntMargin
GetCachedWidgetBorder
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
GtkTextDirection
aDirection
)
;
uint8_t
mBorderCacheValid
[
(
MOZ_GTK_WIDGET_NODE_COUNT
+
7
)
/
8
]
;
mozilla
:
:
CSSIntMargin
mBorderCache
[
MOZ_GTK_WIDGET_NODE_COUNT
]
;
}
;
#
endif
