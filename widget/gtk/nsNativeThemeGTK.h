#
ifndef
_GTK_NSNATIVETHEMEGTK_H_
#
define
_GTK_NSNATIVETHEMEGTK_H_
#
include
"
nsITheme
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsNativeTheme
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsNativeBasicTheme
.
h
"
#
include
"
ScrollbarDrawingGTK
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
"
gtkdrawing
.
h
"
class
nsNativeThemeGTK
final
:
public
nsNativeBasicTheme
{
public
:
NS_IMETHOD
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
DrawOverflow
)
override
;
bool
CreateWebRenderCommandsForWidget
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsIFrame
*
StyleAppearance
const
nsRect
&
aRect
)
override
;
[
[
nodiscard
]
]
LayoutDeviceIntMargin
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
bool
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
override
;
bool
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
override
;
enum
class
NonNative
{
No
Always
BecauseColorMismatch
}
;
NonNative
IsWidgetNonNative
(
nsIFrame
*
StyleAppearance
)
;
NS_IMETHOD
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
mozilla
:
:
LayoutDeviceIntSize
*
aResult
bool
*
aIsOverridable
)
override
;
NS_IMETHOD
WidgetStateChanged
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsAtom
*
aAttribute
bool
*
aShouldRepaint
const
nsAttrValue
*
aOldValue
)
override
;
NS_IMETHOD
ThemeChanged
(
)
override
;
NS_IMETHOD_
(
bool
)
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
override
;
NS_IMETHOD_
(
bool
)
WidgetIsContainer
(
StyleAppearance
aAppearance
)
override
;
NS_IMETHOD_
(
bool
)
ThemeDrawsFocusForWidget
(
StyleAppearance
aAppearance
)
override
;
bool
ThemeNeedsComboboxDropmarker
(
)
override
;
Transparency
GetWidgetTransparency
(
nsIFrame
*
StyleAppearance
)
override
;
ScrollbarSizes
GetScrollbarSizes
(
nsPresContext
*
StyleScrollbarWidth
Overlay
)
override
;
explicit
nsNativeThemeGTK
(
mozilla
:
:
UniquePtr
<
ScrollbarDrawing
>
&
&
aScrollbarDrawingGTK
)
;
protected
:
virtual
~
nsNativeThemeGTK
(
)
;
private
:
GtkTextDirection
GetTextDirection
(
nsIFrame
*
aFrame
)
;
gint
GetTabMarginPixels
(
nsIFrame
*
aFrame
)
;
bool
GetGtkWidgetAndState
(
StyleAppearance
aAppearance
nsIFrame
*
aFrame
WidgetNodeType
&
aGtkWidgetType
GtkWidgetState
*
aState
gint
*
aWidgetFlags
)
;
bool
GetExtraSizeForWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsIntMargin
*
aExtra
)
;
bool
IsWidgetVisible
(
StyleAppearance
aAppearance
)
;
void
RefreshWidgetWindow
(
nsIFrame
*
aFrame
)
;
WidgetNodeType
NativeThemeToGtkTheme
(
StyleAppearance
aAppearance
nsIFrame
*
aFrame
)
;
uint8_t
mDisabledWidgetTypes
[
(
static_cast
<
size_t
>
(
mozilla
:
:
StyleAppearance
:
:
Count
)
+
7
)
/
8
]
;
uint8_t
mSafeWidgetStates
[
static_cast
<
size_t
>
(
mozilla
:
:
StyleAppearance
:
:
Count
)
*
4
]
;
static
const
char
*
sDisabledEngines
[
]
;
void
GetCachedWidgetBorder
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
GtkTextDirection
aDirection
LayoutDeviceIntMargin
*
aResult
)
;
uint8_t
mBorderCacheValid
[
(
MOZ_GTK_WIDGET_NODE_COUNT
+
7
)
/
8
]
;
LayoutDeviceIntMargin
mBorderCache
[
MOZ_GTK_WIDGET_NODE_COUNT
]
;
}
;
#
endif
