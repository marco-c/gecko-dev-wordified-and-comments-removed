#
include
"
ScreenHelperGTK
.
h
"
#
ifdef
MOZ_X11
#
include
<
gdk
/
gdkx
.
h
>
#
include
<
X11
/
Xlib
.
h
>
#
include
"
X11UndefineNone
.
h
"
#
endif
#
ifdef
MOZ_WAYLAND
#
include
<
gdk
/
gdkwayland
.
h
>
#
endif
#
include
<
dlfcn
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
"
gfxPlatformGtk
.
h
"
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
include
"
nsGtkUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsWindow
.
h
"
struct
wl_registry
;
#
ifdef
MOZ_WAYLAND
#
include
"
nsWaylandDisplay
.
h
"
#
endif
namespace
mozilla
:
:
widget
{
#
ifdef
MOZ_LOGGING
static
LazyLogModule
sScreenLog
(
"
WidgetScreen
"
)
;
#
define
LOG_SCREEN
(
.
.
.
)
MOZ_LOG
(
sScreenLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
else
#
define
LOG_SCREEN
(
.
.
.
)
#
endif
using
GdkMonitor
=
struct
_GdkMonitor
;
class
ScreenGetterGtk
final
{
public
:
ScreenGetterGtk
(
)
=
default
;
~
ScreenGetterGtk
(
)
;
void
Init
(
)
;
#
ifdef
MOZ_X11
Atom
NetWorkareaAtom
(
)
{
return
mNetWorkareaAtom
;
}
#
endif
void
RefreshScreens
(
)
;
private
:
GdkWindow
*
mRootWindow
=
nullptr
;
#
ifdef
MOZ_X11
Atom
mNetWorkareaAtom
=
0
;
#
endif
}
;
static
GdkMonitor
*
GdkDisplayGetMonitor
(
GdkDisplay
*
aDisplay
int
aMonitorNum
)
{
static
auto
s_gdk_display_get_monitor
=
(
GdkMonitor
*
(
*
)
(
GdkDisplay
*
int
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_display_get_monitor
"
)
;
if
(
!
s_gdk_display_get_monitor
)
{
return
nullptr
;
}
return
s_gdk_display_get_monitor
(
aDisplay
aMonitorNum
)
;
}
#
ifdef
MOZ_WAYLAND
struct
HDRMonitorInfo
{
int
mMonitorNum
=
0
;
bool
mIsHDR
=
false
;
bool
mIsDone
=
false
;
}
;
void
image_description_info_done
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
)
{
auto
*
info
=
static_cast
<
HDRMonitorInfo
*
>
(
data
)
;
info
-
>
mIsDone
=
true
;
LOG_SCREEN
(
"
Monitor
num
[
%
d
]
Done
"
info
-
>
mMonitorNum
)
;
}
void
image_description_info_icc_file
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
int32_t
icc
uint32_t
icc_size
)
{
}
void
image_description_info_primaries
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
int32_t
r_x
int32_t
r_y
int32_t
g_x
int32_t
g_y
int32_t
b_x
int32_t
b_y
int32_t
w_x
int32_t
w_y
)
{
}
void
image_description_info_primaries_named
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
primaries
)
{
}
void
image_description_info_tf_power
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
eexp
)
{
}
void
image_description_info_tf_named
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
tf
)
{
}
void
image_description_info_luminances
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
min_lum
uint32_t
max_lum
uint32_t
reference_lum
)
{
auto
*
info
=
static_cast
<
HDRMonitorInfo
*
>
(
data
)
;
LOG_SCREEN
(
"
Monitor
num
[
%
d
]
Luminance
min
%
d
max
%
d
reference
%
d
"
info
-
>
mMonitorNum
min_lum
max_lum
reference_lum
)
;
info
-
>
mIsHDR
=
max_lum
>
reference_lum
;
}
void
image_description_info_target_primaries
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
int32_t
r_x
int32_t
r_y
int32_t
g_x
int32_t
g_y
int32_t
b_x
int32_t
b_y
int32_t
w_x
int32_t
w_y
)
{
}
void
image_description_info_target_luminance
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
min_lum
uint32_t
max_lum
)
{
}
void
image_description_info_target_max_cll
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
max_cll
)
{
}
void
image_description_info_target_max_fall
(
void
*
data
struct
wp_image_description_info_v1
*
wp_image_description_info_v1
uint32_t
max_fall
)
{
}
static
const
struct
wp_image_description_info_v1_listener
image_description_info_listener
{
image_description_info_done
image_description_info_icc_file
image_description_info_primaries
image_description_info_primaries_named
image_description_info_tf_power
image_description_info_tf_named
image_description_info_luminances
image_description_info_target_primaries
image_description_info_target_luminance
image_description_info_target_max_cll
image_description_info_target_max_fall
}
;
static
bool
IsMonitorHDR
(
gint
aMonitorNum
)
{
if
(
!
WaylandDisplayGet
(
)
|
|
!
WaylandDisplayGet
(
)
-
>
GetColorManager
(
)
)
{
return
false
;
}
GdkMonitor
*
monitor
=
GdkDisplayGetMonitor
(
gdk_display_get_default
(
)
aMonitorNum
)
;
if
(
!
monitor
)
{
return
monitor
;
}
static
auto
s_gdk_wayland_monitor_get_wl_output
=
(
struct
wl_output
*
(
*
)
(
GdkMonitor
*
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_wayland_monitor_get_wl_output
"
)
;
if
(
!
s_gdk_wayland_monitor_get_wl_output
)
{
return
false
;
}
auto
wlOutput
=
s_gdk_wayland_monitor_get_wl_output
(
monitor
)
;
if
(
!
wlOutput
)
{
return
false
;
}
auto
output
=
wp_color_manager_v1_get_output
(
WaylandDisplayGet
(
)
-
>
GetColorManager
(
)
wlOutput
)
;
auto
description
=
wp_color_management_output_v1_get_image_description
(
output
)
;
auto
descriptionInfo
=
wp_image_description_v1_get_information
(
description
)
;
HDRMonitorInfo
monitorInfo
;
monitorInfo
.
mMonitorNum
=
aMonitorNum
;
wp_image_description_info_v1_add_listener
(
descriptionInfo
&
image_description_info_listener
&
monitorInfo
)
;
WaylandDisplayGet
(
)
-
>
RequestAsyncRoundtrip
(
)
;
WaylandDisplayGet
(
)
-
>
WaitForAsyncRoundtrips
(
)
;
wp_image_description_v1_destroy
(
description
)
;
wp_color_management_output_v1_destroy
(
output
)
;
MOZ_DIAGNOSTIC_ASSERT
(
monitorInfo
.
mIsDone
)
;
return
monitorInfo
.
mIsHDR
;
}
#
endif
RefPtr
<
Screen
>
ScreenHelperGTK
:
:
GetScreenForWindow
(
nsWindow
*
aWindow
)
{
LOG_SCREEN
(
"
GetScreenForWindow
(
)
[
%
p
]
"
aWindow
)
;
static
auto
s_gdk_display_get_monitor_at_window
=
(
GdkMonitor
*
(
*
)
(
GdkDisplay
*
GdkWindow
*
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_display_get_monitor_at_window
"
)
;
if
(
!
s_gdk_display_get_monitor_at_window
)
{
LOG_SCREEN
(
"
failed
missing
Gtk
helpers
"
)
;
return
nullptr
;
}
GdkWindow
*
gdkWindow
=
aWindow
-
>
GetToplevelGdkWindow
(
)
;
if
(
!
gdkWindow
)
{
LOG_SCREEN
(
"
failed
can
'
t
get
GdkWindow
"
)
;
return
nullptr
;
}
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
GdkMonitor
*
monitor
=
s_gdk_display_get_monitor_at_window
(
display
gdkWindow
)
;
if
(
!
monitor
)
{
LOG_SCREEN
(
"
failed
can
'
t
get
monitor
for
GdkWindow
"
)
;
return
nullptr
;
}
int
index
=
-
1
;
while
(
GdkMonitor
*
m
=
GdkDisplayGetMonitor
(
display
+
+
index
)
)
{
if
(
m
=
=
monitor
)
{
return
ScreenManager
:
:
GetSingleton
(
)
.
CurrentScreenList
(
)
.
SafeElementAt
(
index
)
;
}
}
LOG_SCREEN
(
"
Couldn
'
t
find
monitor
%
p
"
monitor
)
;
return
nullptr
;
}
static
StaticAutoPtr
<
ScreenGetterGtk
>
gScreenGetter
;
static
void
monitors_changed
(
GdkScreen
*
aScreen
gpointer
aClosure
)
{
LOG_SCREEN
(
"
Received
monitors
-
changed
event
"
)
;
auto
*
self
=
static_cast
<
ScreenGetterGtk
*
>
(
aClosure
)
;
self
-
>
RefreshScreens
(
)
;
}
static
void
screen_resolution_changed
(
GdkScreen
*
aScreen
GParamSpec
*
aPspec
ScreenGetterGtk
*
self
)
{
self
-
>
RefreshScreens
(
)
;
}
static
GdkFilterReturn
root_window_event_filter
(
GdkXEvent
*
aGdkXEvent
GdkEvent
*
aGdkEvent
gpointer
aClosure
)
{
#
ifdef
MOZ_X11
ScreenGetterGtk
*
self
=
static_cast
<
ScreenGetterGtk
*
>
(
aClosure
)
;
XEvent
*
xevent
=
static_cast
<
XEvent
*
>
(
aGdkXEvent
)
;
switch
(
xevent
-
>
type
)
{
case
PropertyNotify
:
{
XPropertyEvent
*
propertyEvent
=
&
xevent
-
>
xproperty
;
if
(
propertyEvent
-
>
atom
=
=
self
-
>
NetWorkareaAtom
(
)
)
{
LOG_SCREEN
(
"
Work
area
size
changed
"
)
;
self
-
>
RefreshScreens
(
)
;
}
}
break
;
default
:
break
;
}
#
endif
return
GDK_FILTER_CONTINUE
;
}
void
ScreenGetterGtk
:
:
Init
(
)
{
LOG_SCREEN
(
"
ScreenGetterGtk
created
"
)
;
GdkScreen
*
defaultScreen
=
gdk_screen_get_default
(
)
;
if
(
!
defaultScreen
)
{
MOZ_LOG
(
sScreenLog
LogLevel
:
:
Debug
(
"
defaultScreen
is
nullptr
running
headless
"
)
)
;
return
;
}
mRootWindow
=
gdk_get_default_root_window
(
)
;
MOZ_ASSERT
(
mRootWindow
)
;
g_object_ref
(
mRootWindow
)
;
gdk_window_set_events
(
mRootWindow
GdkEventMask
(
gdk_window_get_events
(
mRootWindow
)
|
GDK_PROPERTY_CHANGE_MASK
)
)
;
g_signal_connect
(
defaultScreen
"
monitors
-
changed
"
G_CALLBACK
(
monitors_changed
)
this
)
;
g_signal_connect_after
(
defaultScreen
"
notify
:
:
resolution
"
G_CALLBACK
(
screen_resolution_changed
)
this
)
;
#
ifdef
MOZ_X11
gdk_window_add_filter
(
mRootWindow
root_window_event_filter
this
)
;
if
(
GdkIsX11Display
(
)
)
{
mNetWorkareaAtom
=
XInternAtom
(
GDK_WINDOW_XDISPLAY
(
mRootWindow
)
"
_NET_WORKAREA
"
X11False
)
;
}
#
endif
RefreshScreens
(
)
;
}
ScreenGetterGtk
:
:
~
ScreenGetterGtk
(
)
{
if
(
mRootWindow
)
{
g_signal_handlers_disconnect_by_data
(
gdk_screen_get_default
(
)
this
)
;
gdk_window_remove_filter
(
mRootWindow
root_window_event_filter
this
)
;
g_object_unref
(
mRootWindow
)
;
mRootWindow
=
nullptr
;
}
}
static
uint32_t
GetGTKPixelDepth
(
)
{
GdkVisual
*
visual
=
gdk_screen_get_system_visual
(
gdk_screen_get_default
(
)
)
;
return
gdk_visual_get_depth
(
visual
)
;
}
static
already_AddRefed
<
Screen
>
MakeScreenGtk
(
GdkScreen
*
aScreen
gint
aMonitorNum
)
{
gint
gdkScaleFactor
=
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
aMonitorNum
)
;
gint
geometryScaleFactor
=
gdkScaleFactor
;
gint
refreshRate
=
[
&
]
{
static
auto
s_gdk_monitor_get_refresh_rate
=
(
int
(
*
)
(
GdkMonitor
*
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_monitor_get_refresh_rate
"
)
;
if
(
!
s_gdk_monitor_get_refresh_rate
)
{
return
0
;
}
GdkMonitor
*
monitor
=
GdkDisplayGetMonitor
(
gdk_display_get_default
(
)
aMonitorNum
)
;
if
(
!
monitor
)
{
return
0
;
}
return
NSToIntRound
(
s_gdk_monitor_get_refresh_rate
(
monitor
)
/
1000
.
0f
)
;
}
(
)
;
GdkRectangle
workarea
;
gdk_screen_get_monitor_workarea
(
aScreen
aMonitorNum
&
workarea
)
;
LayoutDeviceIntRect
availRect
(
workarea
.
x
*
geometryScaleFactor
workarea
.
y
*
geometryScaleFactor
workarea
.
width
*
geometryScaleFactor
workarea
.
height
*
geometryScaleFactor
)
;
LayoutDeviceIntRect
rect
;
DesktopToLayoutDeviceScale
contentsScale
(
1
.
0
)
;
if
(
GdkIsX11Display
(
)
)
{
GdkRectangle
monitor
;
gdk_screen_get_monitor_geometry
(
aScreen
aMonitorNum
&
monitor
)
;
rect
=
LayoutDeviceIntRect
(
monitor
.
x
*
geometryScaleFactor
monitor
.
y
*
geometryScaleFactor
monitor
.
width
*
geometryScaleFactor
monitor
.
height
*
geometryScaleFactor
)
;
}
else
{
availRect
.
MoveTo
(
0
0
)
;
rect
=
availRect
;
contentsScale
.
scale
=
gdkScaleFactor
;
}
uint32_t
pixelDepth
=
GetGTKPixelDepth
(
)
;
if
(
pixelDepth
=
=
32
)
{
pixelDepth
=
24
;
}
CSSToLayoutDeviceScale
defaultCssScale
(
gdkScaleFactor
)
;
float
dpi
=
96
.
0f
;
gint
heightMM
=
gdk_screen_get_monitor_height_mm
(
aScreen
aMonitorNum
)
;
if
(
heightMM
>
0
)
{
dpi
=
rect
.
height
/
(
heightMM
/
MM_PER_INCH_FLOAT
)
;
}
bool
isHDR
=
false
;
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
isHDR
=
IsMonitorHDR
(
aMonitorNum
)
;
}
#
endif
LOG_SCREEN
(
"
New
monitor
%
d
size
[
%
d
%
d
-
>
%
d
x
%
d
]
depth
%
d
scale
%
f
CssScale
%
f
"
"
DPI
%
f
refresh
%
d
HDR
%
d
]
"
aMonitorNum
rect
.
x
rect
.
y
rect
.
width
rect
.
height
pixelDepth
contentsScale
.
scale
defaultCssScale
.
scale
dpi
refreshRate
isHDR
)
;
return
MakeAndAddRef
<
Screen
>
(
rect
availRect
pixelDepth
pixelDepth
refreshRate
contentsScale
defaultCssScale
dpi
Screen
:
:
IsPseudoDisplay
:
:
No
Screen
:
:
IsHDR
(
isHDR
)
)
;
}
void
ScreenGetterGtk
:
:
RefreshScreens
(
)
{
LOG_SCREEN
(
"
ScreenGetterGtk
:
:
RefreshScreens
(
)
"
)
;
AutoTArray
<
RefPtr
<
Screen
>
4
>
screenList
;
GdkScreen
*
defaultScreen
=
gdk_screen_get_default
(
)
;
gint
numScreens
=
gdk_screen_get_n_monitors
(
defaultScreen
)
;
LOG_SCREEN
(
"
GDK
reports
%
d
screens
"
numScreens
)
;
for
(
gint
i
=
0
;
i
<
numScreens
;
i
+
+
)
{
screenList
.
AppendElement
(
MakeScreenGtk
(
defaultScreen
i
)
)
;
}
ScreenManager
:
:
Refresh
(
std
:
:
move
(
screenList
)
)
;
}
gint
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
gint
aMonitorNum
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
GdkScreen
*
screen
=
gdk_screen_get_default
(
)
;
return
aMonitorNum
<
gdk_screen_get_n_monitors
(
screen
)
?
gdk_screen_get_monitor_scale_factor
(
screen
aMonitorNum
)
:
1
;
}
ScreenHelperGTK
:
:
ScreenHelperGTK
(
)
{
gScreenGetter
=
new
ScreenGetterGtk
(
)
;
gScreenGetter
-
>
Init
(
)
;
}
int
ScreenHelperGTK
:
:
GetMonitorCount
(
)
{
return
gdk_screen_get_n_monitors
(
gdk_screen_get_default
(
)
)
;
}
ScreenHelperGTK
:
:
~
ScreenHelperGTK
(
)
{
gScreenGetter
=
nullptr
;
}
}
