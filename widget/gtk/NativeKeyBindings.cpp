#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
NativeKeyBindings
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsGtkKeyUtils
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
<
gdk
/
gdkkeysyms
.
h
>
#
include
<
gdk
/
gdk
.
h
>
namespace
mozilla
{
namespace
widget
{
static
nsTArray
<
CommandInt
>
*
gCurrentCommands
=
nullptr
;
static
bool
gHandled
=
false
;
inline
void
AddCommand
(
Command
aCommand
)
{
MOZ_ASSERT
(
gCurrentCommands
)
;
gCurrentCommands
-
>
AppendElement
(
static_cast
<
CommandInt
>
(
aCommand
)
)
;
}
static
void
copy_clipboard_cb
(
GtkWidget
*
w
gpointer
user_data
)
{
AddCommand
(
Command
:
:
Copy
)
;
g_signal_stop_emission_by_name
(
w
"
copy_clipboard
"
)
;
gHandled
=
true
;
}
static
void
cut_clipboard_cb
(
GtkWidget
*
w
gpointer
user_data
)
{
AddCommand
(
Command
:
:
Cut
)
;
g_signal_stop_emission_by_name
(
w
"
cut_clipboard
"
)
;
gHandled
=
true
;
}
static
const
Command
sDeleteCommands
[
]
[
2
]
=
{
{
Command
:
:
DeleteCharBackward
Command
:
:
DeleteCharForward
}
{
Command
:
:
DeleteWordBackward
Command
:
:
DeleteWordForward
}
{
Command
:
:
DeleteWordBackward
Command
:
:
DeleteWordForward
}
{
Command
:
:
DeleteToBeginningOfLine
Command
:
:
DeleteToEndOfLine
}
{
Command
:
:
DeleteToBeginningOfLine
Command
:
:
DeleteToEndOfLine
}
{
Command
:
:
DeleteToBeginningOfLine
Command
:
:
DeleteToEndOfLine
}
{
Command
:
:
DeleteToBeginningOfLine
Command
:
:
DeleteToEndOfLine
}
{
Command
:
:
DoNothing
Command
:
:
DoNothing
}
}
;
static
void
delete_from_cursor_cb
(
GtkWidget
*
w
GtkDeleteType
del_type
gint
count
gpointer
user_data
)
{
g_signal_stop_emission_by_name
(
w
"
delete_from_cursor
"
)
;
if
(
count
=
=
0
)
{
return
;
}
bool
forward
=
count
>
0
;
if
(
del_type
=
=
GTK_DELETE_PARAGRAPH_ENDS
&
&
forward
&
&
GTK_IS_ENTRY
(
w
)
&
&
!
gtk_check_version
(
3
14
1
)
&
&
gtk_check_version
(
3
17
9
)
)
{
GtkStyleContext
*
context
=
gtk_widget_get_style_context
(
w
)
;
GtkStateFlags
flags
=
gtk_widget_get_state_flags
(
w
)
;
GPtrArray
*
array
;
gtk_style_context_get
(
context
flags
"
gtk
-
key
-
bindings
"
&
array
nullptr
)
;
if
(
!
array
)
return
;
g_ptr_array_unref
(
array
)
;
}
gHandled
=
true
;
if
(
uint32_t
(
del_type
)
>
=
ArrayLength
(
sDeleteCommands
)
)
{
return
;
}
if
(
del_type
=
=
GTK_DELETE_WORDS
)
{
if
(
forward
)
{
AddCommand
(
Command
:
:
WordNext
)
;
AddCommand
(
Command
:
:
WordPrevious
)
;
}
else
{
AddCommand
(
Command
:
:
WordPrevious
)
;
AddCommand
(
Command
:
:
WordNext
)
;
}
}
else
if
(
del_type
=
=
GTK_DELETE_DISPLAY_LINES
|
|
del_type
=
=
GTK_DELETE_PARAGRAPHS
)
{
if
(
forward
)
{
AddCommand
(
Command
:
:
BeginLine
)
;
}
else
{
AddCommand
(
Command
:
:
EndLine
)
;
}
}
Command
command
=
sDeleteCommands
[
del_type
]
[
forward
]
;
if
(
command
=
=
Command
:
:
DoNothing
)
{
return
;
}
unsigned
int
absCount
=
Abs
(
count
)
;
for
(
unsigned
int
i
=
0
;
i
<
absCount
;
+
+
i
)
{
AddCommand
(
command
)
;
}
}
static
const
Command
sMoveCommands
[
]
[
2
]
[
2
]
=
{
{
{
Command
:
:
CharPrevious
Command
:
:
CharNext
}
{
Command
:
:
SelectCharPrevious
Command
:
:
SelectCharNext
}
}
{
{
Command
:
:
CharPrevious
Command
:
:
CharNext
}
{
Command
:
:
SelectCharPrevious
Command
:
:
SelectCharNext
}
}
{
{
Command
:
:
WordPrevious
Command
:
:
WordNext
}
{
Command
:
:
SelectWordPrevious
Command
:
:
SelectWordNext
}
}
{
{
Command
:
:
LinePrevious
Command
:
:
LineNext
}
{
Command
:
:
SelectLinePrevious
Command
:
:
SelectLineNext
}
}
{
{
Command
:
:
BeginLine
Command
:
:
EndLine
}
{
Command
:
:
SelectBeginLine
Command
:
:
SelectEndLine
}
}
{
{
Command
:
:
LinePrevious
Command
:
:
LineNext
}
{
Command
:
:
SelectLinePrevious
Command
:
:
SelectLineNext
}
}
{
{
Command
:
:
BeginLine
Command
:
:
EndLine
}
{
Command
:
:
SelectBeginLine
Command
:
:
SelectEndLine
}
}
{
{
Command
:
:
MovePageUp
Command
:
:
MovePageDown
}
{
Command
:
:
SelectPageUp
Command
:
:
SelectPageDown
}
}
{
{
Command
:
:
MoveTop
Command
:
:
MoveBottom
}
{
Command
:
:
SelectTop
Command
:
:
SelectBottom
}
}
{
{
Command
:
:
DoNothing
Command
:
:
DoNothing
}
{
Command
:
:
DoNothing
Command
:
:
DoNothing
}
}
}
;
static
void
move_cursor_cb
(
GtkWidget
*
w
GtkMovementStep
step
gint
count
gboolean
extend_selection
gpointer
user_data
)
{
g_signal_stop_emission_by_name
(
w
"
move_cursor
"
)
;
if
(
count
=
=
0
)
{
return
;
}
gHandled
=
true
;
bool
forward
=
count
>
0
;
if
(
uint32_t
(
step
)
>
=
ArrayLength
(
sMoveCommands
)
)
{
return
;
}
Command
command
=
sMoveCommands
[
step
]
[
extend_selection
]
[
forward
]
;
if
(
command
=
=
Command
:
:
DoNothing
)
{
return
;
}
unsigned
int
absCount
=
Abs
(
count
)
;
for
(
unsigned
int
i
=
0
;
i
<
absCount
;
+
+
i
)
{
AddCommand
(
command
)
;
}
}
static
void
paste_clipboard_cb
(
GtkWidget
*
w
gpointer
user_data
)
{
AddCommand
(
Command
:
:
Paste
)
;
g_signal_stop_emission_by_name
(
w
"
paste_clipboard
"
)
;
gHandled
=
true
;
}
static
void
select_all_cb
(
GtkWidget
*
w
gboolean
select
gpointer
user_data
)
{
AddCommand
(
Command
:
:
SelectAll
)
;
g_signal_stop_emission_by_name
(
w
"
select_all
"
)
;
gHandled
=
true
;
}
NativeKeyBindings
*
NativeKeyBindings
:
:
sInstanceForSingleLineEditor
=
nullptr
;
NativeKeyBindings
*
NativeKeyBindings
:
:
sInstanceForMultiLineEditor
=
nullptr
;
NativeKeyBindings
*
NativeKeyBindings
:
:
GetInstance
(
NativeKeyBindingsType
aType
)
{
switch
(
aType
)
{
case
nsIWidget
:
:
NativeKeyBindingsForSingleLineEditor
:
if
(
!
sInstanceForSingleLineEditor
)
{
sInstanceForSingleLineEditor
=
new
NativeKeyBindings
(
)
;
sInstanceForSingleLineEditor
-
>
Init
(
aType
)
;
}
return
sInstanceForSingleLineEditor
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
aType
is
invalid
or
not
yet
implemented
"
)
;
case
nsIWidget
:
:
NativeKeyBindingsForMultiLineEditor
:
case
nsIWidget
:
:
NativeKeyBindingsForRichTextEditor
:
if
(
!
sInstanceForMultiLineEditor
)
{
sInstanceForMultiLineEditor
=
new
NativeKeyBindings
(
)
;
sInstanceForMultiLineEditor
-
>
Init
(
aType
)
;
}
return
sInstanceForMultiLineEditor
;
}
}
void
NativeKeyBindings
:
:
Shutdown
(
)
{
delete
sInstanceForSingleLineEditor
;
sInstanceForSingleLineEditor
=
nullptr
;
delete
sInstanceForMultiLineEditor
;
sInstanceForMultiLineEditor
=
nullptr
;
}
void
NativeKeyBindings
:
:
Init
(
NativeKeyBindingsType
aType
)
{
switch
(
aType
)
{
case
nsIWidget
:
:
NativeKeyBindingsForSingleLineEditor
:
mNativeTarget
=
gtk_entry_new
(
)
;
break
;
default
:
mNativeTarget
=
gtk_text_view_new
(
)
;
if
(
gtk_major_version
>
2
|
|
(
gtk_major_version
=
=
2
&
&
(
gtk_minor_version
>
2
|
|
(
gtk_minor_version
=
=
2
&
&
gtk_micro_version
>
=
2
)
)
)
)
{
g_signal_connect
(
mNativeTarget
"
select_all
"
G_CALLBACK
(
select_all_cb
)
this
)
;
}
break
;
}
g_object_ref_sink
(
mNativeTarget
)
;
g_signal_connect
(
mNativeTarget
"
copy_clipboard
"
G_CALLBACK
(
copy_clipboard_cb
)
this
)
;
g_signal_connect
(
mNativeTarget
"
cut_clipboard
"
G_CALLBACK
(
cut_clipboard_cb
)
this
)
;
g_signal_connect
(
mNativeTarget
"
delete_from_cursor
"
G_CALLBACK
(
delete_from_cursor_cb
)
this
)
;
g_signal_connect
(
mNativeTarget
"
move_cursor
"
G_CALLBACK
(
move_cursor_cb
)
this
)
;
g_signal_connect
(
mNativeTarget
"
paste_clipboard
"
G_CALLBACK
(
paste_clipboard_cb
)
this
)
;
}
NativeKeyBindings
:
:
~
NativeKeyBindings
(
)
{
gtk_widget_destroy
(
mNativeTarget
)
;
g_object_unref
(
mNativeTarget
)
;
}
void
NativeKeyBindings
:
:
GetEditCommands
(
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
if
(
!
aEvent
.
mNativeKeyEvent
)
{
return
;
}
guint
keyval
;
if
(
aEvent
.
mCharCode
)
{
keyval
=
gdk_unicode_to_keyval
(
aEvent
.
mCharCode
)
;
}
else
{
keyval
=
static_cast
<
GdkEventKey
*
>
(
aEvent
.
mNativeKeyEvent
)
-
>
keyval
;
}
if
(
GetEditCommandsInternal
(
aEvent
aCommands
keyval
)
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
aEvent
.
mAlternativeCharCodes
.
Length
(
)
;
+
+
i
)
{
uint32_t
ch
=
aEvent
.
IsShift
(
)
?
aEvent
.
mAlternativeCharCodes
[
i
]
.
mShiftedCharCode
:
aEvent
.
mAlternativeCharCodes
[
i
]
.
mUnshiftedCharCode
;
if
(
ch
&
&
ch
!
=
aEvent
.
mCharCode
)
{
keyval
=
gdk_unicode_to_keyval
(
ch
)
;
if
(
GetEditCommandsInternal
(
aEvent
aCommands
keyval
)
)
{
return
;
}
}
}
}
bool
NativeKeyBindings
:
:
GetEditCommandsInternal
(
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
guint
aKeyval
)
{
guint
modifiers
=
static_cast
<
GdkEventKey
*
>
(
aEvent
.
mNativeKeyEvent
)
-
>
state
;
gCurrentCommands
=
&
aCommands
;
gHandled
=
false
;
gtk_bindings_activate
(
G_OBJECT
(
mNativeTarget
)
aKeyval
GdkModifierType
(
modifiers
)
)
;
gCurrentCommands
=
nullptr
;
MOZ_ASSERT
(
!
gHandled
|
|
!
aCommands
.
IsEmpty
(
)
)
;
return
gHandled
;
}
}
}
