#
include
"
nsDeviceContextSpecG
.
h
"
#
include
"
mozilla
/
gfx
/
PrintTargetPDF
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
include
"
plstr
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsCUPSShim
.
h
"
#
include
"
nsPrinterCUPS
.
h
"
#
include
"
nsPrintSettingsGTK
.
h
"
#
include
"
nsIFileStreams
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
unistd
.
h
>
#
include
<
sys
/
types
.
h
>
#
include
<
sys
/
stat
.
h
>
#
include
<
fcntl
.
h
>
#
include
"
nsIGIOService
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
gfx
:
:
IntSize
;
using
mozilla
:
:
gfx
:
:
PrintTarget
;
using
mozilla
:
:
gfx
:
:
PrintTargetPDF
;
nsDeviceContextSpecGTK
:
:
nsDeviceContextSpecGTK
(
)
:
mGtkPrintSettings
(
nullptr
)
mGtkPageSetup
(
nullptr
)
{
}
nsDeviceContextSpecGTK
:
:
~
nsDeviceContextSpecGTK
(
)
{
if
(
mGtkPageSetup
)
{
g_object_unref
(
mGtkPageSetup
)
;
}
if
(
mGtkPrintSettings
)
{
g_object_unref
(
mGtkPrintSettings
)
;
}
if
(
mSpoolFile
)
{
mSpoolFile
-
>
Remove
(
false
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsDeviceContextSpecGTK
nsIDeviceContextSpec
)
already_AddRefed
<
PrintTarget
>
nsDeviceContextSpecGTK
:
:
MakePrintTarget
(
)
{
double
width
height
;
mPrintSettings
-
>
GetEffectiveSheetSize
(
&
width
&
height
)
;
width
/
=
TWIPS_PER_POINT_FLOAT
;
height
/
=
TWIPS_PER_POINT_FLOAT
;
nsresult
rv
;
MOZ_ASSERT
(
!
mSpoolFile
)
;
gchar
*
buf
;
gint
fd
=
g_file_open_tmp
(
"
XXXXXX
.
tmp
"
&
buf
nullptr
)
;
if
(
-
1
=
=
fd
)
return
nullptr
;
close
(
fd
)
;
rv
=
NS_NewNativeLocalFile
(
nsDependentCString
(
buf
)
false
getter_AddRefs
(
mSpoolFile
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
unlink
(
buf
)
;
g_free
(
buf
)
;
return
nullptr
;
}
mSpoolName
=
buf
;
g_free
(
buf
)
;
mSpoolFile
-
>
SetPermissions
(
0600
)
;
nsCOMPtr
<
nsIFileOutputStream
>
stream
=
do_CreateInstance
(
"
mozilla
.
org
/
network
/
file
-
output
-
stream
;
1
"
)
;
rv
=
stream
-
>
Init
(
mSpoolFile
-
1
-
1
0
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
return
PrintTargetPDF
:
:
CreateOrNull
(
stream
IntSize
:
:
Ceil
(
width
height
)
)
;
}
#
define
DECLARE_KNOWN_MONOCHROME_SETTING
(
key_
value_
)
{
"
cups
-
"
key_
value_
}
struct
{
const
char
*
mKey
;
const
char
*
mValue
;
}
kKnownMonochromeSettings
[
]
=
{
CUPS_EACH_MONOCHROME_PRINTER_SETTING
(
DECLARE_KNOWN_MONOCHROME_SETTING
)
}
;
#
undef
DECLARE_KNOWN_MONOCHROME_SETTING
static
GtkPaperSize
*
GtkPaperSizeFromIpp
(
const
gchar
*
aIppName
gdouble
aWidth
gdouble
aHeight
)
{
static
auto
sPtr
=
(
GtkPaperSize
*
(
*
)
(
const
gchar
*
gdouble
gdouble
)
)
dlsym
(
RTLD_DEFAULT
"
gtk_paper_size_new_from_ipp
"
)
;
if
(
gtk_check_version
(
3
16
0
)
)
{
return
nullptr
;
}
return
sPtr
(
aIppName
aWidth
aHeight
)
;
}
static
bool
PaperSizeAlmostEquals
(
GtkPaperSize
*
aSize
GtkPaperSize
*
aOtherSize
)
{
const
double
kEpsilon
=
1
.
0
;
if
(
fabs
(
gtk_paper_size_get_height
(
aSize
GTK_UNIT_MM
)
-
gtk_paper_size_get_height
(
aOtherSize
GTK_UNIT_MM
)
)
>
kEpsilon
)
{
return
false
;
}
if
(
fabs
(
gtk_paper_size_get_width
(
aSize
GTK_UNIT_MM
)
-
gtk_paper_size_get_width
(
aOtherSize
GTK_UNIT_MM
)
)
>
kEpsilon
)
{
return
false
;
}
return
true
;
}
static
GtkPaperSize
*
GetStandardGtkPaperSize
(
GtkPaperSize
*
aGeckoPaperSize
)
{
const
gchar
*
geckoName
=
gtk_paper_size_get_name
(
aGeckoPaperSize
)
;
GtkPaperSize
*
size
=
GtkPaperSizeFromIpp
(
geckoName
gtk_paper_size_get_width
(
aGeckoPaperSize
GTK_UNIT_POINTS
)
gtk_paper_size_get_height
(
aGeckoPaperSize
GTK_UNIT_POINTS
)
)
;
if
(
size
&
&
!
gtk_paper_size_is_custom
(
size
)
)
{
return
size
;
}
if
(
size
)
{
gtk_paper_size_free
(
size
)
;
}
size
=
gtk_paper_size_new
(
geckoName
)
;
if
(
gtk_paper_size_is_equal
(
size
aGeckoPaperSize
)
)
{
return
size
;
}
if
(
PaperSizeAlmostEquals
(
aGeckoPaperSize
size
)
)
{
return
size
;
}
gtk_paper_size_free
(
size
)
;
return
nullptr
;
}
NS_IMETHODIMP
nsDeviceContextSpecGTK
:
:
Init
(
nsIWidget
*
aWidget
nsIPrintSettings
*
aPS
bool
aIsPrintPreview
)
{
mPrintSettings
=
do_QueryInterface
(
aPS
)
;
if
(
!
mPrintSettings
)
{
return
NS_ERROR_NO_INTERFACE
;
}
bool
toFile
;
aPS
-
>
GetPrintToFile
(
&
toFile
)
;
mToPrinter
=
!
toFile
&
&
!
aIsPrintPreview
;
mGtkPrintSettings
=
mPrintSettings
-
>
GetGtkPrintSettings
(
)
;
mGtkPageSetup
=
mPrintSettings
-
>
GetGtkPageSetup
(
)
;
GtkPaperSize
*
geckoPaperSize
=
gtk_page_setup_get_paper_size
(
mGtkPageSetup
)
;
GtkPaperSize
*
gtkPaperSize
=
GetStandardGtkPaperSize
(
geckoPaperSize
)
;
mGtkPageSetup
=
gtk_page_setup_copy
(
mGtkPageSetup
)
;
mGtkPrintSettings
=
gtk_print_settings_copy
(
mGtkPrintSettings
)
;
if
(
!
aPS
-
>
GetPrintInColor
(
)
&
&
StaticPrefs
:
:
print_cups_monochrome_enabled
(
)
)
{
for
(
const
auto
&
setting
:
kKnownMonochromeSettings
)
{
gtk_print_settings_set
(
mGtkPrintSettings
setting
.
mKey
setting
.
mValue
)
;
}
auto
applySetting
=
[
&
]
(
const
nsACString
&
aKey
const
nsACString
&
aVal
)
{
nsAutoCString
extra
;
extra
.
AppendASCII
(
"
cups
-
"
)
;
extra
.
Append
(
aKey
)
;
gtk_print_settings_set
(
mGtkPrintSettings
extra
.
get
(
)
nsAutoCString
(
aVal
)
.
get
(
)
)
;
}
;
nsPrinterCUPS
:
:
ForEachExtraMonochromeSetting
(
applySetting
)
;
}
GtkPaperSize
*
properPaperSize
=
gtkPaperSize
?
gtkPaperSize
:
geckoPaperSize
;
gtk_print_settings_set_paper_size
(
mGtkPrintSettings
properPaperSize
)
;
gtk_page_setup_set_paper_size_and_default_margins
(
mGtkPageSetup
properPaperSize
)
;
if
(
gtkPaperSize
)
{
gtk_paper_size_free
(
gtkPaperSize
)
;
}
return
NS_OK
;
}
static
void
print_callback
(
GtkPrintJob
*
aJob
gpointer
aData
const
GError
*
aError
)
{
g_object_unref
(
aJob
)
;
(
(
nsIFile
*
)
aData
)
-
>
Remove
(
false
)
;
}
gboolean
nsDeviceContextSpecGTK
:
:
PrinterEnumerator
(
GtkPrinter
*
aPrinter
gpointer
aData
)
{
nsDeviceContextSpecGTK
*
spec
=
(
nsDeviceContextSpecGTK
*
)
aData
;
nsString
printerName
;
nsresult
rv
=
spec
-
>
mPrintSettings
-
>
GetPrinterName
(
printerName
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
printerName
.
IsVoid
(
)
)
{
NS_ConvertUTF16toUTF8
requestedName
(
printerName
)
;
const
char
*
currentName
=
gtk_printer_get_name
(
aPrinter
)
;
if
(
requestedName
.
Equals
(
currentName
)
)
{
spec
-
>
mPrintSettings
-
>
SetGtkPrinter
(
aPrinter
)
;
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsDeviceContextSpecGTK
:
:
StartPrintJob
"
spec
&
nsDeviceContextSpecGTK
:
:
StartPrintJob
)
)
;
return
TRUE
;
}
}
return
FALSE
;
}
void
nsDeviceContextSpecGTK
:
:
StartPrintJob
(
)
{
if
(
widget
:
:
ShouldUsePortal
(
widget
:
:
PortalKind
:
:
Print
)
)
{
GError
*
error
=
nullptr
;
GDBusProxy
*
dbusProxy
=
g_dbus_proxy_new_for_bus_sync
(
G_BUS_TYPE_SESSION
G_DBUS_PROXY_FLAGS_NONE
nullptr
"
org
.
freedesktop
.
portal
.
Desktop
"
"
/
org
/
freedesktop
/
portal
/
desktop
"
"
org
.
freedesktop
.
portal
.
Print
"
nullptr
&
error
)
;
if
(
!
dbusProxy
)
{
NS_WARNING
(
nsPrintfCString
(
"
Unable
to
create
dbus
proxy
:
%
s
"
error
-
>
message
)
.
get
(
)
)
;
g_error_free
(
error
)
;
return
;
}
int
fd
=
open
(
mSpoolName
.
get
(
)
O_RDONLY
|
O_CLOEXEC
)
;
if
(
fd
=
=
-
1
)
{
NS_WARNING
(
"
Failed
to
open
spool
file
.
"
)
;
g_object_unref
(
dbusProxy
)
;
return
;
}
static
auto
s_g_unix_fd_list_new
=
reinterpret_cast
<
GUnixFDList
*
(
*
)
(
void
)
>
(
dlsym
(
RTLD_DEFAULT
"
g_unix_fd_list_new
"
)
)
;
NS_ASSERTION
(
s_g_unix_fd_list_new
"
Cannot
find
g_unix_fd_list_new
function
.
"
)
;
GUnixFDList
*
fd_list
=
s_g_unix_fd_list_new
(
)
;
static
auto
s_g_unix_fd_list_append
=
reinterpret_cast
<
gint
(
*
)
(
GUnixFDList
*
gint
GError
*
*
)
>
(
dlsym
(
RTLD_DEFAULT
"
g_unix_fd_list_append
"
)
)
;
int
idx
=
s_g_unix_fd_list_append
(
fd_list
fd
NULL
)
;
close
(
fd
)
;
GVariantBuilder
opt_builder
;
g_variant_builder_init
(
&
opt_builder
G_VARIANT_TYPE_VARDICT
)
;
g_dbus_proxy_call_with_unix_fd_list
(
dbusProxy
"
Print
"
g_variant_new
(
"
(
ssh
a
{
sv
}
)
"
"
"
"
Print
"
idx
g_variant_builder_end
(
&
opt_builder
)
)
G_DBUS_CALL_FLAGS_NONE
-
1
fd_list
NULL
NULL
nullptr
)
;
g_object_unref
(
fd_list
)
;
g_object_unref
(
dbusProxy
)
;
}
else
{
GtkPrintJob
*
job
=
gtk_print_job_new
(
mTitle
.
get
(
)
mPrintSettings
-
>
GetGtkPrinter
(
)
mGtkPrintSettings
mGtkPageSetup
)
;
if
(
!
gtk_print_job_set_source_file
(
job
mSpoolName
.
get
(
)
nullptr
)
)
return
;
gtk_print_job_send
(
job
print_callback
mSpoolFile
.
forget
(
)
.
take
(
)
[
]
(
gpointer
aData
)
{
auto
*
spoolFile
=
static_cast
<
nsIFile
*
>
(
aData
)
;
NS_RELEASE
(
spoolFile
)
;
}
)
;
}
}
void
nsDeviceContextSpecGTK
:
:
EnumeratePrinters
(
)
{
gtk_enumerate_printers
(
&
nsDeviceContextSpecGTK
:
:
PrinterEnumerator
this
nullptr
TRUE
)
;
}
NS_IMETHODIMP
nsDeviceContextSpecGTK
:
:
BeginDocument
(
const
nsAString
&
aTitle
const
nsAString
&
aPrintToFileName
int32_t
aStartPage
int32_t
aEndPage
)
{
if
(
gtk_check_version
(
3
18
2
)
!
=
nullptr
)
{
PrintTarget
:
:
AdjustPrintJobNameForIPP
(
aTitle
mTitle
)
;
}
else
{
CopyUTF16toUTF8
(
aTitle
mTitle
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDeviceContextSpecGTK
:
:
EndDocument
(
)
{
if
(
mToPrinter
)
{
if
(
mPrintSettings
-
>
GetGtkPrinter
(
)
)
{
StartPrintJob
(
)
;
}
else
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsDeviceContextSpecGTK
:
:
EnumeratePrinters
"
this
&
nsDeviceContextSpecGTK
:
:
EnumeratePrinters
)
)
;
}
}
else
{
nsString
targetPath
;
nsCOMPtr
<
nsIFile
>
destFile
;
mPrintSettings
-
>
GetToFileName
(
targetPath
)
;
nsresult
rv
=
NS_NewLocalFile
(
targetPath
false
getter_AddRefs
(
destFile
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
destLeafName
;
rv
=
destFile
-
>
GetLeafName
(
destLeafName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
destDir
;
rv
=
destFile
-
>
GetParent
(
getter_AddRefs
(
destDir
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mSpoolFile
-
>
MoveTo
(
destDir
destLeafName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSpoolFile
=
nullptr
;
mode_t
mask
=
umask
(
0
)
;
umask
(
mask
)
;
destFile
-
>
SetPermissions
(
0666
&
~
(
mask
)
)
;
if
(
widget
:
:
ShouldUsePortal
(
widget
:
:
PortalKind
:
:
Print
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
os
-
>
NotifyObservers
(
nullptr
"
print
-
to
-
file
-
finished
"
targetPath
.
get
(
)
)
;
}
}
return
NS_OK
;
}
