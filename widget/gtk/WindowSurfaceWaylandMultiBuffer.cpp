#
include
"
WindowSurfaceWaylandMultiBuffer
.
h
"
#
include
<
errno
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
MozContainer
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
undef
LOG
#
ifdef
MOZ_LOGGING
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
Units
.
h
"
extern
mozilla
:
:
LazyLogModule
gWidgetWaylandLog
;
#
define
LOGWAYLAND
(
args
)
\
MOZ_LOG
(
gWidgetWaylandLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
else
#
define
LOGWAYLAND
(
args
)
#
endif
namespace
mozilla
:
:
widget
{
using
gfx
:
:
DataSourceSurface
;
#
define
BACK_BUFFER_NUM
3
WindowSurfaceWaylandMB
:
:
WindowSurfaceWaylandMB
(
nsWindow
*
aWindow
)
:
mSurfaceLock
(
"
WindowSurfaceWayland
lock
"
)
mWindow
(
aWindow
)
mWaylandDisplay
(
WaylandDisplayGet
(
)
)
mWaylandBuffer
(
nullptr
)
{
}
RefPtr
<
WaylandShmBuffer
>
WindowSurfaceWaylandMB
:
:
ObtainBufferFromPool
(
const
LayoutDeviceIntSize
&
aSize
)
{
if
(
!
mAvailableBuffers
.
IsEmpty
(
)
)
{
RefPtr
<
WaylandShmBuffer
>
buffer
=
mAvailableBuffers
.
PopLastElement
(
)
;
mInUseBuffers
.
AppendElement
(
buffer
)
;
return
buffer
;
}
RefPtr
<
WaylandShmBuffer
>
buffer
=
WaylandShmBuffer
:
:
Create
(
GetWaylandDisplay
(
)
aSize
)
;
mInUseBuffers
.
AppendElement
(
buffer
)
;
buffer
-
>
SetBufferReleaseFunc
(
&
WindowSurfaceWaylandMB
:
:
BufferReleaseCallbackHandler
)
;
buffer
-
>
SetBufferReleaseData
(
this
)
;
return
buffer
;
}
void
WindowSurfaceWaylandMB
:
:
ReturnBufferToPool
(
const
RefPtr
<
WaylandShmBuffer
>
&
aBuffer
)
{
for
(
const
RefPtr
<
WaylandShmBuffer
>
&
buffer
:
mInUseBuffers
)
{
if
(
buffer
=
=
aBuffer
)
{
if
(
buffer
-
>
IsMatchingSize
(
mMozContainerSize
)
)
{
mAvailableBuffers
.
AppendElement
(
buffer
)
;
}
mInUseBuffers
.
RemoveElement
(
buffer
)
;
return
;
}
}
MOZ_RELEASE_ASSERT
(
false
"
Returned
buffer
not
in
use
"
)
;
}
void
WindowSurfaceWaylandMB
:
:
EnforcePoolSizeLimit
(
const
MutexAutoLock
&
aLock
)
{
while
(
mAvailableBuffers
.
Length
(
)
>
BACK_BUFFER_NUM
)
{
mAvailableBuffers
.
RemoveElementAt
(
0
)
;
}
NS_WARNING_ASSERTION
(
mInUseBuffers
.
Length
(
)
<
10
"
We
are
leaking
buffers
"
)
;
}
void
WindowSurfaceWaylandMB
:
:
PrepareBufferForFrame
(
const
MutexAutoLock
&
aLock
)
{
if
(
mWindow
-
>
WindowType
(
)
=
=
eWindowType_invisible
)
{
return
;
}
LayoutDeviceIntSize
newMozContainerSize
=
mWindow
-
>
GetMozContainerSize
(
)
;
if
(
mMozContainerSize
!
=
newMozContainerSize
)
{
mMozContainerSize
=
newMozContainerSize
;
mPreviousWaylandBuffer
=
nullptr
;
mPreviousInvalidRegion
.
SetEmpty
(
)
;
mAvailableBuffers
.
Clear
(
)
;
}
LOGWAYLAND
(
(
"
WindowSurfaceWaylandMB
:
:
PrepareBufferForFrame
[
%
p
]
MozContainer
"
"
size
[
%
d
x
%
d
]
\
n
"
(
void
*
)
this
mMozContainerSize
.
width
mMozContainerSize
.
height
)
)
;
MOZ_ASSERT
(
!
mWaylandBuffer
)
;
mWaylandBuffer
=
ObtainBufferFromPool
(
mMozContainerSize
)
;
}
already_AddRefed
<
DrawTarget
>
WindowSurfaceWaylandMB
:
:
Lock
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
MutexAutoLock
lock
(
mSurfaceLock
)
;
#
ifdef
MOZ_LOGGING
gfx
:
:
IntRect
lockRect
=
aRegion
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
LOGWAYLAND
(
(
"
WindowSurfaceWaylandMB
:
:
Lock
[
%
p
]
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
rects
%
d
"
"
MozContainer
size
[
%
d
x
%
d
]
\
n
"
(
void
*
)
this
lockRect
.
x
lockRect
.
y
lockRect
.
width
lockRect
.
height
aRegion
.
GetNumRects
(
)
mMozContainerSize
.
width
mMozContainerSize
.
height
)
)
;
#
endif
PrepareBufferForFrame
(
lock
)
;
if
(
!
mWaylandBuffer
)
{
return
nullptr
;
}
RefPtr
<
DrawTarget
>
dt
=
mWaylandBuffer
-
>
Lock
(
)
;
return
dt
.
forget
(
)
;
}
void
WindowSurfaceWaylandMB
:
:
HandlePartialUpdate
(
const
MutexAutoLock
&
aLock
const
LayoutDeviceIntRegion
&
aInvalidRegion
)
{
if
(
!
mPreviousWaylandBuffer
|
|
mPreviousWaylandBuffer
=
=
mWaylandBuffer
)
{
mPreviousWaylandBuffer
=
mWaylandBuffer
;
mPreviousInvalidRegion
=
aInvalidRegion
;
return
;
}
LayoutDeviceIntRegion
copyRegion
;
if
(
mWaylandBuffer
-
>
GetBufferAge
(
)
=
=
2
)
{
copyRegion
.
Sub
(
mPreviousInvalidRegion
aInvalidRegion
)
;
}
else
{
LayoutDeviceIntSize
size
=
mPreviousWaylandBuffer
-
>
GetSize
(
)
;
copyRegion
=
LayoutDeviceIntRegion
(
LayoutDeviceIntRect
(
0
0
size
.
width
size
.
height
)
)
;
copyRegion
.
SubOut
(
aInvalidRegion
)
;
}
if
(
!
copyRegion
.
IsEmpty
(
)
)
{
RefPtr
<
DataSourceSurface
>
dataSourceSurface
=
mozilla
:
:
gfx
:
:
CreateDataSourceSurfaceFromData
(
mPreviousWaylandBuffer
-
>
GetSize
(
)
.
ToUnknownSize
(
)
mPreviousWaylandBuffer
-
>
GetSurfaceFormat
(
)
(
const
uint8_t
*
)
mPreviousWaylandBuffer
-
>
GetShmPool
(
)
-
>
GetImageData
(
)
mPreviousWaylandBuffer
-
>
GetSize
(
)
.
width
*
BytesPerPixel
(
mPreviousWaylandBuffer
-
>
GetSurfaceFormat
(
)
)
)
;
RefPtr
<
DrawTarget
>
dt
=
mWaylandBuffer
-
>
Lock
(
)
;
for
(
auto
iter
=
copyRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
LayoutDeviceIntRect
r
=
iter
.
Get
(
)
;
dt
-
>
CopySurface
(
dataSourceSurface
r
.
ToUnknownRect
(
)
IntPoint
(
r
.
x
r
.
y
)
)
;
}
}
mPreviousWaylandBuffer
=
mWaylandBuffer
;
mPreviousInvalidRegion
=
aInvalidRegion
;
}
void
WindowSurfaceWaylandMB
:
:
Commit
(
const
LayoutDeviceIntRegion
&
aInvalidRegion
)
{
MutexAutoLock
lock
(
mSurfaceLock
)
;
#
ifdef
MOZ_LOGGING
gfx
:
:
IntRect
invalidRect
=
aInvalidRegion
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
LOGWAYLAND
(
(
"
WindowSurfaceWaylandMB
:
:
Commit
[
%
p
]
damage
rect
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
"
"
MozContainer
[
%
d
x
%
d
]
\
n
"
(
void
*
)
this
invalidRect
.
x
invalidRect
.
y
invalidRect
.
width
invalidRect
.
height
mMozContainerSize
.
width
mMozContainerSize
.
height
)
)
;
#
endif
if
(
!
mWaylandBuffer
)
{
LOGWAYLAND
(
(
"
WindowSurfaceWaylandMB
:
:
Commit
[
%
p
]
frame
skipped
:
no
buffer
\
n
"
(
void
*
)
this
)
)
;
IncrementBufferAge
(
)
;
return
;
}
MozContainer
*
container
=
mWindow
-
>
GetMozContainer
(
)
;
wl_surface
*
waylandSurface
=
moz_container_wayland_surface_lock
(
container
)
;
if
(
!
waylandSurface
)
{
LOGWAYLAND
(
(
"
WindowSurfaceWaylandMB
:
:
Commit
[
%
p
]
frame
skipped
:
can
'
t
lock
"
"
wl_surface
\
n
"
(
void
*
)
this
)
)
;
ReturnBufferToPool
(
mWaylandBuffer
)
;
mWaylandBuffer
=
nullptr
;
IncrementBufferAge
(
)
;
return
;
}
HandlePartialUpdate
(
lock
aInvalidRegion
)
;
for
(
auto
iter
=
aInvalidRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
LayoutDeviceIntRect
r
=
iter
.
Get
(
)
;
wl_surface_damage_buffer
(
waylandSurface
r
.
x
r
.
y
r
.
width
r
.
height
)
;
}
mWaylandBuffer
-
>
AttachAndCommit
(
waylandSurface
)
;
moz_container_wayland_surface_unlock
(
container
&
waylandSurface
)
;
mWaylandBuffer
-
>
ResetBufferAge
(
)
;
mWaylandBuffer
=
nullptr
;
EnforcePoolSizeLimit
(
lock
)
;
IncrementBufferAge
(
)
;
if
(
wl_display_flush
(
GetWaylandDisplay
(
)
-
>
GetDisplay
(
)
)
=
=
-
1
)
{
LOGWAYLAND
(
(
"
WindowSurfaceWaylandMB
:
:
Commit
[
%
p
]
flush
failed
\
n
"
(
void
*
)
this
)
)
;
}
}
void
WindowSurfaceWaylandMB
:
:
IncrementBufferAge
(
)
{
for
(
const
RefPtr
<
WaylandShmBuffer
>
&
buffer
:
mInUseBuffers
)
{
buffer
-
>
IncrementBufferAge
(
)
;
}
for
(
const
RefPtr
<
WaylandShmBuffer
>
&
buffer
:
mAvailableBuffers
)
{
buffer
-
>
IncrementBufferAge
(
)
;
}
}
void
WindowSurfaceWaylandMB
:
:
BufferReleaseCallbackHandler
(
wl_buffer
*
aBuffer
)
{
MutexAutoLock
lock
(
mSurfaceLock
)
;
for
(
const
RefPtr
<
WaylandShmBuffer
>
&
buffer
:
mInUseBuffers
)
{
if
(
buffer
-
>
GetWlBuffer
(
)
=
=
aBuffer
)
{
ReturnBufferToPool
(
buffer
)
;
break
;
}
}
}
void
WindowSurfaceWaylandMB
:
:
BufferReleaseCallbackHandler
(
void
*
aData
wl_buffer
*
aBuffer
)
{
auto
*
surface
=
reinterpret_cast
<
WindowSurfaceWaylandMB
*
>
(
aData
)
;
surface
-
>
BufferReleaseCallbackHandler
(
aBuffer
)
;
}
}
