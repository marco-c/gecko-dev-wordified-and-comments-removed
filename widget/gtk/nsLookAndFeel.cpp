#
include
<
stdlib
.
h
>
#
include
"
nsLookAndFeel
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
<
gdk
/
gdk
.
h
>
#
include
<
pango
/
pango
.
h
>
#
include
<
pango
/
pango
-
fontmap
.
h
>
#
include
<
fontconfig
/
fontconfig
.
h
>
#
include
"
gfxPlatformGtk
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
RelativeLuminanceUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
ScreenHelperGTK
.
h
"
#
include
"
gtkdrawing
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
<
cairo
-
gobject
.
h
>
#
include
"
WidgetStyleCache
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsCSSColorUtils
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
LookAndFeel
;
#
undef
LOG
#
ifdef
MOZ_LOGGING
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
Units
.
h
"
extern
mozilla
:
:
LazyLogModule
gWidgetLog
;
#
define
LOG
(
args
)
MOZ_LOG
(
gWidgetLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
else
#
define
LOG
(
args
)
#
endif
#
define
GDK_COLOR_TO_NS_RGB
(
c
)
\
(
(
nscolor
)
NS_RGB
(
c
.
red
>
>
8
c
.
green
>
>
8
c
.
blue
>
>
8
)
)
#
define
GDK_RGBA_TO_NS_RGBA
(
c
)
\
(
(
nscolor
)
NS_RGBA
(
(
int
)
(
(
c
)
.
red
*
255
)
(
int
)
(
(
c
)
.
green
*
255
)
\
(
int
)
(
(
c
)
.
blue
*
255
)
(
int
)
(
(
c
)
.
alpha
*
255
)
)
)
nsLookAndFeel
:
:
nsLookAndFeel
(
)
=
default
;
nsLookAndFeel
:
:
~
nsLookAndFeel
(
)
=
default
;
static
void
ApplyColorOver
(
const
GdkRGBA
&
aSource
GdkRGBA
*
aDest
)
{
gdouble
sourceCoef
=
aSource
.
alpha
;
gdouble
destCoef
=
aDest
-
>
alpha
*
(
1
.
0
-
sourceCoef
)
;
gdouble
resultAlpha
=
sourceCoef
+
destCoef
;
if
(
resultAlpha
!
=
0
.
0
)
{
destCoef
/
=
resultAlpha
;
sourceCoef
/
=
resultAlpha
;
aDest
-
>
red
=
sourceCoef
*
aSource
.
red
+
destCoef
*
aDest
-
>
red
;
aDest
-
>
green
=
sourceCoef
*
aSource
.
green
+
destCoef
*
aDest
-
>
green
;
aDest
-
>
blue
=
sourceCoef
*
aSource
.
blue
+
destCoef
*
aDest
-
>
blue
;
aDest
-
>
alpha
=
resultAlpha
;
}
}
static
void
GetLightAndDarkness
(
const
GdkRGBA
&
aColor
double
*
aLightness
double
*
aDarkness
)
{
double
sum
=
aColor
.
red
+
aColor
.
green
+
aColor
.
blue
;
*
aLightness
=
sum
*
aColor
.
alpha
;
*
aDarkness
=
(
3
.
0
-
sum
)
*
aColor
.
alpha
;
}
static
bool
GetGradientColors
(
const
GValue
*
aValue
GdkRGBA
*
aLightColor
GdkRGBA
*
aDarkColor
)
{
if
(
!
G_TYPE_CHECK_VALUE_TYPE
(
aValue
CAIRO_GOBJECT_TYPE_PATTERN
)
)
return
false
;
auto
pattern
=
static_cast
<
cairo_pattern_t
*
>
(
g_value_get_boxed
(
aValue
)
)
;
if
(
!
pattern
)
return
false
;
if
(
CAIRO_STATUS_SUCCESS
!
=
cairo_pattern_get_color_stop_rgba
(
pattern
0
nullptr
&
aDarkColor
-
>
red
&
aDarkColor
-
>
green
&
aDarkColor
-
>
blue
&
aDarkColor
-
>
alpha
)
)
return
false
;
double
maxLightness
maxDarkness
;
GetLightAndDarkness
(
*
aDarkColor
&
maxLightness
&
maxDarkness
)
;
*
aLightColor
=
*
aDarkColor
;
GdkRGBA
stop
;
for
(
int
index
=
1
;
CAIRO_STATUS_SUCCESS
=
=
cairo_pattern_get_color_stop_rgba
(
pattern
index
nullptr
&
stop
.
red
&
stop
.
green
&
stop
.
blue
&
stop
.
alpha
)
;
+
+
index
)
{
double
lightness
darkness
;
GetLightAndDarkness
(
stop
&
lightness
&
darkness
)
;
if
(
lightness
>
maxLightness
)
{
maxLightness
=
lightness
;
*
aLightColor
=
stop
;
}
if
(
darkness
>
maxDarkness
)
{
maxDarkness
=
darkness
;
*
aDarkColor
=
stop
;
}
}
return
true
;
}
static
bool
GetUnicoBorderGradientColors
(
GtkStyleContext
*
aContext
GdkRGBA
*
aLightColor
GdkRGBA
*
aDarkColor
)
{
const
char
*
propertyName
=
"
-
unico
-
border
-
gradient
"
;
if
(
!
gtk_style_properties_lookup_property
(
propertyName
nullptr
nullptr
)
)
return
false
;
GtkThemingEngine
*
engine
;
GtkStateFlags
state
=
gtk_style_context_get_state
(
aContext
)
;
gtk_style_context_get
(
aContext
state
"
engine
"
&
engine
nullptr
)
;
if
(
strcmp
(
g_type_name
(
G_TYPE_FROM_INSTANCE
(
engine
)
)
"
UnicoEngine
"
)
!
=
0
)
return
false
;
GValue
value
=
G_VALUE_INIT
;
gtk_style_context_get_property
(
aContext
propertyName
state
&
value
)
;
bool
result
=
GetGradientColors
(
&
value
aLightColor
aDarkColor
)
;
g_value_unset
(
&
value
)
;
return
result
;
}
static
bool
GetBorderColors
(
GtkStyleContext
*
aContext
GdkRGBA
*
aLightColor
GdkRGBA
*
aDarkColor
)
{
GtkStateFlags
state
=
gtk_style_context_get_state
(
aContext
)
;
GtkBorderStyle
borderStyle
;
gtk_style_context_get
(
aContext
state
GTK_STYLE_PROPERTY_BORDER_STYLE
&
borderStyle
nullptr
)
;
bool
visible
=
borderStyle
!
=
GTK_BORDER_STYLE_NONE
&
&
borderStyle
!
=
GTK_BORDER_STYLE_HIDDEN
;
if
(
visible
)
{
GtkBorder
border
;
gtk_style_context_get_border
(
aContext
state
&
border
)
;
visible
=
border
.
top
!
=
0
|
|
border
.
right
!
=
0
|
|
border
.
bottom
!
=
0
|
|
border
.
left
!
=
0
;
}
if
(
visible
&
&
GetUnicoBorderGradientColors
(
aContext
aLightColor
aDarkColor
)
)
return
true
;
gtk_style_context_get_border_color
(
aContext
state
aDarkColor
)
;
*
aLightColor
=
*
aDarkColor
;
return
visible
;
}
static
bool
GetBorderColors
(
GtkStyleContext
*
aContext
nscolor
*
aLightColor
nscolor
*
aDarkColor
)
{
GdkRGBA
lightColor
darkColor
;
bool
ret
=
GetBorderColors
(
aContext
&
lightColor
&
darkColor
)
;
*
aLightColor
=
GDK_RGBA_TO_NS_RGBA
(
lightColor
)
;
*
aDarkColor
=
GDK_RGBA_TO_NS_RGBA
(
darkColor
)
;
return
ret
;
}
nsresult
nsLookAndFeel
:
:
InitCellHighlightColors
(
)
{
int32_t
minLuminosityDifference
=
NS_SUFFICIENT_LUMINOSITY_DIFFERENCE
/
5
;
int32_t
backLuminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
mMozWindowBackground
mFieldBackground
)
;
if
(
backLuminosityDifference
>
=
minLuminosityDifference
)
{
mMozCellHighlightBackground
=
mMozWindowBackground
;
mMozCellHighlightText
=
mMozWindowText
;
return
NS_OK
;
}
uint16_t
hue
sat
luminance
;
uint8_t
alpha
;
mMozCellHighlightBackground
=
mFieldBackground
;
mMozCellHighlightText
=
mFieldText
;
NS_RGB2HSV
(
mMozCellHighlightBackground
hue
sat
luminance
alpha
)
;
uint16_t
step
=
30
;
if
(
luminance
<
=
step
)
{
luminance
+
=
step
;
}
else
if
(
luminance
>
=
255
-
step
)
{
luminance
-
=
step
;
}
else
{
uint16_t
textHue
textSat
textLuminance
;
uint8_t
textAlpha
;
NS_RGB2HSV
(
mMozCellHighlightText
textHue
textSat
textLuminance
textAlpha
)
;
if
(
textLuminance
<
luminance
)
{
luminance
+
=
step
;
}
else
{
luminance
-
=
step
;
}
}
NS_HSV2RGB
(
mMozCellHighlightBackground
hue
sat
luminance
alpha
)
;
return
NS_OK
;
}
void
nsLookAndFeel
:
:
NativeInit
(
)
{
EnsureInit
(
)
;
}
void
nsLookAndFeel
:
:
RefreshImpl
(
)
{
nsXPLookAndFeel
:
:
RefreshImpl
(
)
;
moz_gtk_refresh
(
)
;
mInitialized
=
false
;
}
LookAndFeelCache
nsLookAndFeel
:
:
GetCacheImpl
(
)
{
LookAndFeelCache
cache
=
nsXPLookAndFeel
:
:
GetCacheImpl
(
)
;
const
IntID
kIdsToCache
[
]
=
{
IntID
:
:
SystemUsesDarkTheme
IntID
:
:
PrefersReducedMotion
IntID
:
:
UseAccessibilityTheme
}
;
for
(
IntID
id
:
kIdsToCache
)
{
cache
.
mInts
.
AppendElement
(
LookAndFeelInt
{
.
id
=
id
.
value
=
GetInt
(
id
)
}
)
;
}
return
cache
;
}
void
nsLookAndFeel
:
:
SetCacheImpl
(
const
LookAndFeelCache
&
aCache
)
{
for
(
const
auto
&
entry
:
aCache
.
mInts
)
{
switch
(
entry
.
id
)
{
case
IntID
:
:
SystemUsesDarkTheme
:
mSystemUsesDarkTheme
=
entry
.
value
;
break
;
case
IntID
:
:
PrefersReducedMotion
:
mPrefersReducedMotion
=
entry
.
value
;
break
;
case
IntID
:
:
UseAccessibilityTheme
:
mHighContrast
=
entry
.
value
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Bogus
Int
ID
in
cache
"
)
;
break
;
}
}
}
nsresult
nsLookAndFeel
:
:
NativeGetColor
(
ColorID
aID
nscolor
&
aColor
)
{
EnsureInit
(
)
;
nsresult
res
=
NS_OK
;
switch
(
aID
)
{
case
ColorID
:
:
WindowBackground
:
case
ColorID
:
:
WidgetBackground
:
case
ColorID
:
:
TextBackground
:
case
ColorID
:
:
Activecaption
:
case
ColorID
:
:
Appworkspace
:
case
ColorID
:
:
Background
:
case
ColorID
:
:
Window
:
case
ColorID
:
:
Windowframe
:
case
ColorID
:
:
MozDialog
:
case
ColorID
:
:
MozCombobox
:
aColor
=
mMozWindowBackground
;
break
;
case
ColorID
:
:
WindowForeground
:
case
ColorID
:
:
WidgetForeground
:
case
ColorID
:
:
TextForeground
:
case
ColorID
:
:
Captiontext
:
case
ColorID
:
:
Windowtext
:
case
ColorID
:
:
MozDialogtext
:
aColor
=
mMozWindowText
;
break
;
case
ColorID
:
:
WidgetSelectBackground
:
case
ColorID
:
:
TextSelectBackground
:
case
ColorID
:
:
IMESelectedRawTextBackground
:
case
ColorID
:
:
IMESelectedConvertedTextBackground
:
case
ColorID
:
:
MozDragtargetzone
:
case
ColorID
:
:
MozHtmlCellhighlight
:
case
ColorID
:
:
Highlight
:
aColor
=
mTextSelectedBackground
;
break
;
case
ColorID
:
:
WidgetSelectForeground
:
case
ColorID
:
:
TextSelectForeground
:
case
ColorID
:
:
IMESelectedRawTextForeground
:
case
ColorID
:
:
IMESelectedConvertedTextForeground
:
case
ColorID
:
:
Highlighttext
:
case
ColorID
:
:
MozHtmlCellhighlighttext
:
aColor
=
mTextSelectedText
;
break
;
case
ColorID
:
:
MozCellhighlight
:
aColor
=
mMozCellHighlightBackground
;
break
;
case
ColorID
:
:
MozCellhighlighttext
:
aColor
=
mMozCellHighlightText
;
break
;
case
ColorID
:
:
Widget3DHighlight
:
aColor
=
NS_RGB
(
0xa0
0xa0
0xa0
)
;
break
;
case
ColorID
:
:
Widget3DShadow
:
aColor
=
NS_RGB
(
0x40
0x40
0x40
)
;
break
;
case
ColorID
:
:
IMERawInputBackground
:
case
ColorID
:
:
IMEConvertedTextBackground
:
aColor
=
NS_TRANSPARENT
;
break
;
case
ColorID
:
:
IMERawInputForeground
:
case
ColorID
:
:
IMEConvertedTextForeground
:
aColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
break
;
case
ColorID
:
:
IMERawInputUnderline
:
case
ColorID
:
:
IMEConvertedTextUnderline
:
aColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
break
;
case
ColorID
:
:
IMESelectedRawTextUnderline
:
case
ColorID
:
:
IMESelectedConvertedTextUnderline
:
aColor
=
NS_TRANSPARENT
;
break
;
case
ColorID
:
:
SpellCheckerUnderline
:
aColor
=
NS_RGB
(
0xff
0
0
)
;
break
;
case
ColorID
:
:
Activeborder
:
aColor
=
mMozWindowActiveBorder
;
break
;
case
ColorID
:
:
Inactiveborder
:
aColor
=
mMozWindowInactiveBorder
;
break
;
case
ColorID
:
:
Graytext
:
case
ColorID
:
:
Inactivecaptiontext
:
aColor
=
mMenuTextInactive
;
break
;
case
ColorID
:
:
Inactivecaption
:
aColor
=
mMozWindowInactiveCaption
;
break
;
case
ColorID
:
:
Infobackground
:
aColor
=
mInfoBackground
;
break
;
case
ColorID
:
:
Infotext
:
aColor
=
mInfoText
;
break
;
case
ColorID
:
:
Menu
:
aColor
=
mMenuBackground
;
break
;
case
ColorID
:
:
Menutext
:
aColor
=
mMenuText
;
break
;
case
ColorID
:
:
Scrollbar
:
aColor
=
mMozScrollbar
;
break
;
case
ColorID
:
:
Threedface
:
case
ColorID
:
:
Buttonface
:
aColor
=
mMozWindowBackground
;
break
;
case
ColorID
:
:
Buttontext
:
aColor
=
mButtonText
;
break
;
case
ColorID
:
:
Buttonhighlight
:
case
ColorID
:
:
Threedhighlight
:
aColor
=
mFrameOuterLightBorder
;
break
;
case
ColorID
:
:
Buttonshadow
:
case
ColorID
:
:
Threedshadow
:
aColor
=
mFrameInnerDarkBorder
;
break
;
case
ColorID
:
:
Threedlightshadow
:
aColor
=
NS_RGB
(
0xE0
0xE0
0xE0
)
;
break
;
case
ColorID
:
:
Threeddarkshadow
:
aColor
=
NS_RGB
(
0xDC
0xDC
0xDC
)
;
break
;
case
ColorID
:
:
MozEventreerow
:
case
ColorID
:
:
Field
:
aColor
=
mFieldBackground
;
break
;
case
ColorID
:
:
Fieldtext
:
aColor
=
mFieldText
;
break
;
case
ColorID
:
:
MozButtondefault
:
aColor
=
mButtonDefault
;
break
;
case
ColorID
:
:
MozButtonhoverface
:
aColor
=
mButtonHoverFace
;
break
;
case
ColorID
:
:
MozButtonhovertext
:
aColor
=
mButtonHoverText
;
break
;
case
ColorID
:
:
MozGtkButtonactivetext
:
aColor
=
mButtonActiveText
;
break
;
case
ColorID
:
:
MozMenuhover
:
aColor
=
mMenuHover
;
break
;
case
ColorID
:
:
MozMenuhovertext
:
aColor
=
mMenuHoverText
;
break
;
case
ColorID
:
:
MozOddtreerow
:
aColor
=
mOddCellBackground
;
break
;
case
ColorID
:
:
MozNativehyperlinktext
:
aColor
=
mNativeHyperLinkText
;
break
;
case
ColorID
:
:
MozComboboxtext
:
aColor
=
mComboBoxText
;
break
;
case
ColorID
:
:
MozMenubartext
:
aColor
=
mMenuBarText
;
break
;
case
ColorID
:
:
MozMenubarhovertext
:
aColor
=
mMenuBarHoverText
;
break
;
case
ColorID
:
:
MozGtkInfoBarText
:
aColor
=
mInfoBarText
;
break
;
case
ColorID
:
:
MozColheadertext
:
aColor
=
mMozColHeaderText
;
break
;
case
ColorID
:
:
MozColheaderhovertext
:
aColor
=
mMozColHeaderHoverText
;
break
;
default
:
aColor
=
0
;
res
=
NS_ERROR_FAILURE
;
break
;
}
return
res
;
}
static
int32_t
CheckWidgetStyle
(
GtkWidget
*
aWidget
const
char
*
aStyle
int32_t
aResult
)
{
gboolean
value
=
FALSE
;
gtk_widget_style_get
(
aWidget
aStyle
&
value
nullptr
)
;
return
value
?
aResult
:
0
;
}
static
int32_t
ConvertGTKStepperStyleToMozillaScrollArrowStyle
(
GtkWidget
*
aWidget
)
{
if
(
!
aWidget
)
return
mozilla
:
:
LookAndFeel
:
:
eScrollArrowStyle_Single
;
return
CheckWidgetStyle
(
aWidget
"
has
-
backward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_StartBackward
)
|
CheckWidgetStyle
(
aWidget
"
has
-
forward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_EndForward
)
|
CheckWidgetStyle
(
aWidget
"
has
-
secondary
-
backward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_EndBackward
)
|
CheckWidgetStyle
(
aWidget
"
has
-
secondary
-
forward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_StartForward
)
;
}
nsresult
nsLookAndFeel
:
:
GetIntImpl
(
IntID
aID
int32_t
&
aResult
)
{
nsresult
res
=
NS_OK
;
switch
(
aID
)
{
case
IntID
:
:
ScrollButtonLeftMouseButtonAction
:
aResult
=
0
;
return
NS_OK
;
case
IntID
:
:
ScrollButtonMiddleMouseButtonAction
:
aResult
=
1
;
return
NS_OK
;
case
IntID
:
:
ScrollButtonRightMouseButtonAction
:
aResult
=
2
;
return
NS_OK
;
default
:
break
;
}
res
=
nsXPLookAndFeel
:
:
GetIntImpl
(
aID
aResult
)
;
if
(
NS_SUCCEEDED
(
res
)
)
return
res
;
res
=
NS_OK
;
switch
(
aID
)
{
case
IntID
:
:
CaretBlinkTime
:
EnsureInit
(
)
;
aResult
=
mCaretBlinkTime
;
break
;
case
IntID
:
:
CaretWidth
:
aResult
=
1
;
break
;
case
IntID
:
:
ShowCaretDuringSelection
:
aResult
=
0
;
break
;
case
IntID
:
:
SelectTextfieldsOnKeyFocus
:
{
GtkWidget
*
entry
;
GtkSettings
*
settings
;
gboolean
select_on_focus
;
entry
=
gtk_entry_new
(
)
;
g_object_ref_sink
(
entry
)
;
settings
=
gtk_widget_get_settings
(
entry
)
;
g_object_get
(
settings
"
gtk
-
entry
-
select
-
on
-
focus
"
&
select_on_focus
nullptr
)
;
if
(
select_on_focus
)
aResult
=
1
;
else
aResult
=
0
;
gtk_widget_destroy
(
entry
)
;
g_object_unref
(
entry
)
;
}
break
;
case
IntID
:
:
ScrollToClick
:
{
GtkSettings
*
settings
;
gboolean
warps_slider
=
FALSE
;
settings
=
gtk_settings_get_default
(
)
;
if
(
g_object_class_find_property
(
G_OBJECT_GET_CLASS
(
settings
)
"
gtk
-
primary
-
button
-
warps
-
slider
"
)
)
{
g_object_get
(
settings
"
gtk
-
primary
-
button
-
warps
-
slider
"
&
warps_slider
nullptr
)
;
}
if
(
warps_slider
)
aResult
=
1
;
else
aResult
=
0
;
}
break
;
case
IntID
:
:
SubmenuDelay
:
{
GtkSettings
*
settings
;
gint
delay
;
settings
=
gtk_settings_get_default
(
)
;
g_object_get
(
settings
"
gtk
-
menu
-
popup
-
delay
"
&
delay
nullptr
)
;
aResult
=
(
int32_t
)
delay
;
break
;
}
case
IntID
:
:
TooltipDelay
:
{
aResult
=
500
;
break
;
}
case
IntID
:
:
MenusCanOverlapOSBar
:
aResult
=
1
;
break
;
case
IntID
:
:
SkipNavigatingDisabledMenuItem
:
aResult
=
1
;
break
;
case
IntID
:
:
DragThresholdX
:
case
IntID
:
:
DragThresholdY
:
{
GtkWidget
*
box
=
gtk_hbox_new
(
FALSE
5
)
;
gint
threshold
=
0
;
g_object_get
(
gtk_widget_get_settings
(
box
)
"
gtk
-
dnd
-
drag
-
threshold
"
&
threshold
nullptr
)
;
g_object_ref_sink
(
box
)
;
aResult
=
threshold
;
}
break
;
case
IntID
:
:
ScrollArrowStyle
:
{
GtkWidget
*
scrollbar
=
GetWidget
(
MOZ_GTK_SCROLLBAR_HORIZONTAL
)
;
aResult
=
ConvertGTKStepperStyleToMozillaScrollArrowStyle
(
scrollbar
)
;
break
;
}
case
IntID
:
:
ScrollSliderStyle
:
aResult
=
eScrollThumbStyle_Proportional
;
break
;
case
IntID
:
:
TreeOpenDelay
:
aResult
=
1000
;
break
;
case
IntID
:
:
TreeCloseDelay
:
aResult
=
1000
;
break
;
case
IntID
:
:
TreeLazyScrollDelay
:
aResult
=
150
;
break
;
case
IntID
:
:
TreeScrollDelay
:
aResult
=
100
;
break
;
case
IntID
:
:
TreeScrollLinesMax
:
aResult
=
3
;
break
;
case
IntID
:
:
DWMCompositor
:
case
IntID
:
:
WindowsClassic
:
case
IntID
:
:
WindowsDefaultTheme
:
case
IntID
:
:
WindowsThemeIdentifier
:
case
IntID
:
:
OperatingSystemVersionIdentifier
:
aResult
=
0
;
res
=
NS_ERROR_NOT_IMPLEMENTED
;
break
;
case
IntID
:
:
TouchEnabled
:
aResult
=
mozilla
:
:
widget
:
:
WidgetUtils
:
:
IsTouchDeviceSupportPresent
(
)
;
break
;
case
IntID
:
:
MacGraphiteTheme
:
aResult
=
0
;
res
=
NS_ERROR_NOT_IMPLEMENTED
;
break
;
case
IntID
:
:
AlertNotificationOrigin
:
aResult
=
NS_ALERT_TOP
;
break
;
case
IntID
:
:
IMERawInputUnderlineStyle
:
case
IntID
:
:
IMEConvertedTextUnderlineStyle
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
break
;
case
IntID
:
:
IMESelectedRawTextUnderlineStyle
:
case
IntID
:
:
IMESelectedConvertedTextUnderline
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
;
break
;
case
IntID
:
:
SpellCheckerUnderlineStyle
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
;
break
;
case
IntID
:
:
MenuBarDrag
:
EnsureInit
(
)
;
aResult
=
mMenuSupportsDrag
;
break
;
case
IntID
:
:
ScrollbarButtonAutoRepeatBehavior
:
aResult
=
1
;
break
;
case
IntID
:
:
SwipeAnimationEnabled
:
aResult
=
0
;
break
;
case
IntID
:
:
ContextMenuOffsetVertical
:
case
IntID
:
:
ContextMenuOffsetHorizontal
:
aResult
=
2
;
break
;
case
IntID
:
:
GTKCSDAvailable
:
EnsureInit
(
)
;
aResult
=
mCSDAvailable
;
break
;
case
IntID
:
:
GTKCSDHideTitlebarByDefault
:
EnsureInit
(
)
;
aResult
=
mCSDHideTitlebarByDefault
;
break
;
case
IntID
:
:
GTKCSDMaximizeButton
:
EnsureInit
(
)
;
aResult
=
mCSDMaximizeButton
;
break
;
case
IntID
:
:
GTKCSDMinimizeButton
:
EnsureInit
(
)
;
aResult
=
mCSDMinimizeButton
;
break
;
case
IntID
:
:
GTKCSDCloseButton
:
EnsureInit
(
)
;
aResult
=
mCSDCloseButton
;
break
;
case
IntID
:
:
GTKCSDTransparentBackground
:
{
GdkScreen
*
screen
=
gdk_screen_get_default
(
)
;
aResult
=
gdk_screen_is_composited
(
screen
)
?
(
nsWindow
:
:
GetSystemCSDSupportLevel
(
)
!
=
nsWindow
:
:
CSD_SUPPORT_NONE
)
:
false
;
break
;
}
case
IntID
:
:
GTKCSDReversedPlacement
:
EnsureInit
(
)
;
aResult
=
mCSDReversedPlacement
;
break
;
case
IntID
:
:
PrefersReducedMotion
:
{
aResult
=
mPrefersReducedMotion
;
break
;
}
case
IntID
:
:
SystemUsesDarkTheme
:
{
EnsureInit
(
)
;
aResult
=
mSystemUsesDarkTheme
;
break
;
}
case
IntID
:
:
GTKCSDMaximizeButtonPosition
:
aResult
=
mCSDMaximizeButtonPosition
;
break
;
case
IntID
:
:
GTKCSDMinimizeButtonPosition
:
aResult
=
mCSDMinimizeButtonPosition
;
break
;
case
IntID
:
:
GTKCSDCloseButtonPosition
:
aResult
=
mCSDCloseButtonPosition
;
break
;
case
IntID
:
:
UseAccessibilityTheme
:
{
EnsureInit
(
)
;
aResult
=
mHighContrast
;
break
;
}
default
:
aResult
=
0
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
nsresult
nsLookAndFeel
:
:
GetFloatImpl
(
FloatID
aID
float
&
aResult
)
{
nsresult
res
=
NS_OK
;
res
=
nsXPLookAndFeel
:
:
GetFloatImpl
(
aID
aResult
)
;
if
(
NS_SUCCEEDED
(
res
)
)
return
res
;
res
=
NS_OK
;
switch
(
aID
)
{
case
FloatID
:
:
IMEUnderlineRelativeSize
:
aResult
=
1
.
0f
;
break
;
case
FloatID
:
:
SpellCheckerUnderlineRelativeSize
:
aResult
=
1
.
0f
;
break
;
case
FloatID
:
:
CaretAspectRatio
:
EnsureInit
(
)
;
aResult
=
mCaretRatio
;
break
;
default
:
aResult
=
-
1
.
0
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
static
void
GetSystemFontInfo
(
GtkStyleContext
*
aStyle
nsString
*
aFontName
gfxFontStyle
*
aFontStyle
)
{
aFontStyle
-
>
style
=
FontSlantStyle
:
:
Normal
(
)
;
PangoFontDescription
*
desc
;
gtk_style_context_get
(
aStyle
gtk_style_context_get_state
(
aStyle
)
"
font
"
&
desc
nullptr
)
;
aFontStyle
-
>
systemFont
=
true
;
constexpr
auto
quote
=
u
"
\
"
"
_ns
;
NS_ConvertUTF8toUTF16
family
(
pango_font_description_get_family
(
desc
)
)
;
*
aFontName
=
quote
+
family
+
quote
;
aFontStyle
-
>
weight
=
FontWeight
(
pango_font_description_get_weight
(
desc
)
)
;
aFontStyle
-
>
stretch
=
FontStretch
:
:
Normal
(
)
;
float
size
=
float
(
pango_font_description_get_size
(
desc
)
)
/
PANGO_SCALE
;
if
(
!
pango_font_description_get_size_is_absolute
(
desc
)
)
{
size
*
=
float
(
gfxPlatformGtk
:
:
GetFontScaleDPI
(
)
)
/
POINTS_PER_INCH_FLOAT
;
}
aFontStyle
-
>
size
=
size
;
pango_font_description_free
(
desc
)
;
}
bool
nsLookAndFeel
:
:
GetFontImpl
(
FontID
aID
nsString
&
aFontName
gfxFontStyle
&
aFontStyle
)
{
switch
(
aID
)
{
case
FontID
:
:
Menu
:
case
FontID
:
:
PullDownMenu
:
aFontName
=
mMenuFontName
;
aFontStyle
=
mMenuFontStyle
;
break
;
case
FontID
:
:
Field
:
case
FontID
:
:
List
:
aFontName
=
mFieldFontName
;
aFontStyle
=
mFieldFontStyle
;
break
;
case
FontID
:
:
Button
:
aFontName
=
mButtonFontName
;
aFontStyle
=
mButtonFontStyle
;
break
;
case
FontID
:
:
Caption
:
case
FontID
:
:
Icon
:
case
FontID
:
:
MessageBox
:
case
FontID
:
:
SmallCaption
:
case
FontID
:
:
StatusBar
:
case
FontID
:
:
Window
:
case
FontID
:
:
Document
:
case
FontID
:
:
Workspace
:
case
FontID
:
:
Desktop
:
case
FontID
:
:
Info
:
case
FontID
:
:
Dialog
:
case
FontID
:
:
Tooltips
:
case
FontID
:
:
Widget
:
default
:
aFontName
=
mDefaultFontName
;
aFontStyle
=
mDefaultFontStyle
;
break
;
}
double
scaleFactor
=
StaticPrefs
:
:
layout_css_devPixelsPerPx
(
)
;
if
(
scaleFactor
>
0
)
{
aFontStyle
.
size
*
=
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
/
scaleFactor
;
}
else
{
aFontStyle
.
size
/
=
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
}
return
true
;
}
static
bool
HasGoodContrastVisibility
(
GdkRGBA
&
aColor1
GdkRGBA
&
aColor2
)
{
int32_t
luminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
GDK_RGBA_TO_NS_RGBA
(
aColor1
)
GDK_RGBA_TO_NS_RGBA
(
aColor2
)
)
;
if
(
luminosityDifference
<
NS_SUFFICIENT_LUMINOSITY_DIFFERENCE
)
{
return
false
;
}
double
colorDifference
=
std
:
:
abs
(
aColor1
.
red
-
aColor2
.
red
)
+
std
:
:
abs
(
aColor1
.
green
-
aColor2
.
green
)
+
std
:
:
abs
(
aColor1
.
blue
-
aColor2
.
blue
)
;
return
(
colorDifference
*
255
.
0
>
500
.
0
)
;
}
static
bool
IsGtkThemeCompatibleWithHTMLColors
(
)
{
GdkRGBA
white
=
{
1
.
0
1
.
0
1
.
0
}
;
GdkRGBA
black
=
{
0
.
0
0
.
0
0
.
0
}
;
GtkStyleContext
*
style
=
GetStyleContext
(
MOZ_GTK_WINDOW
)
;
GdkRGBA
textColor
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
textColor
)
;
if
(
!
HasGoodContrastVisibility
(
textColor
white
)
)
{
return
false
;
}
GdkRGBA
backgroundColor
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
backgroundColor
)
;
if
(
HasGoodContrastVisibility
(
backgroundColor
white
)
)
{
return
false
;
}
return
HasGoodContrastVisibility
(
backgroundColor
black
)
;
}
static
nsCString
GetGtkTheme
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCString
ret
;
GtkSettings
*
settings
=
gtk_settings_get_for_screen
(
gdk_screen_get_default
(
)
)
;
char
*
themeName
=
nullptr
;
g_object_get
(
settings
"
gtk
-
theme
-
name
"
&
themeName
nullptr
)
;
if
(
themeName
)
{
ret
.
Assign
(
themeName
)
;
g_free
(
themeName
)
;
}
return
ret
;
}
void
nsLookAndFeel
:
:
ConfigureContentGtkTheme
(
)
{
GtkSettings
*
settings
=
gtk_settings_get_for_screen
(
gdk_screen_get_default
(
)
)
;
nsAutoCString
themeOverride
;
mozilla
:
:
Preferences
:
:
GetCString
(
"
widget
.
content
.
gtk
-
theme
-
override
"
themeOverride
)
;
if
(
!
themeOverride
.
IsEmpty
(
)
)
{
g_object_set
(
settings
"
gtk
-
theme
-
name
"
themeOverride
.
get
(
)
nullptr
)
;
LOG
(
(
"
ConfigureContentGtkTheme
(
%
s
)
\
n
"
themeOverride
.
get
(
)
)
)
;
}
else
{
LOG
(
(
"
ConfigureContentGtkTheme
(
%
s
)
\
n
"
GetGtkTheme
(
)
.
get
(
)
)
)
;
}
if
(
!
themeOverride
.
IsEmpty
(
)
|
|
mHighContrast
|
|
StaticPrefs
:
:
widget_content_allow_gtk_dark_theme
(
)
)
{
return
;
}
const
gchar
*
dark_theme_setting
=
"
gtk
-
application
-
prefer
-
dark
-
theme
"
;
gboolean
darkThemeDefault
;
g_object_get
(
settings
dark_theme_setting
&
darkThemeDefault
nullptr
)
;
if
(
darkThemeDefault
)
{
LOG
(
(
"
disabling
gtk
-
application
-
prefer
-
dark
-
theme
\
n
"
)
)
;
g_object_set
(
settings
dark_theme_setting
FALSE
nullptr
)
;
}
if
(
!
IsGtkThemeCompatibleWithHTMLColors
(
)
)
{
LOG
(
(
"
Non
-
compatible
dark
theme
default
to
Adwaita
\
n
"
)
)
;
g_object_set
(
settings
"
gtk
-
theme
-
name
"
"
Adwaita
"
nullptr
)
;
}
}
void
nsLookAndFeel
:
:
EnsureInit
(
)
{
if
(
mInitialized
)
{
return
;
}
GdkScreen
*
screen
=
gdk_screen_get_default
(
)
;
if
(
MOZ_UNLIKELY
(
!
screen
)
)
{
NS_WARNING
(
"
EnsureInit
:
No
screen
"
)
;
return
;
}
GtkSettings
*
settings
=
gtk_settings_get_for_screen
(
screen
)
;
if
(
MOZ_UNLIKELY
(
!
settings
)
)
{
NS_WARNING
(
"
EnsureInit
:
No
settings
"
)
;
return
;
}
mInitialized
=
true
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
GtkStyleContext
*
style
;
if
(
XRE_IsContentProcess
(
)
)
{
LOG
(
(
"
nsLookAndFeel
:
:
EnsureInit
(
)
[
%
p
]
Content
process
\
n
"
(
void
*
)
this
)
)
;
ConfigureContentGtkTheme
(
)
;
}
else
{
GdkRGBA
bg
fg
;
style
=
GetStyleContext
(
MOZ_GTK_WINDOW
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
bg
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
fg
)
;
LOG
(
(
"
nsLookAndFeel
:
:
EnsureInit
(
)
[
%
p
]
Chrome
process
\
n
"
(
void
*
)
this
)
)
;
mSystemUsesDarkTheme
=
(
RelativeLuminanceUtils
:
:
Compute
(
GDK_RGBA_TO_NS_RGBA
(
bg
)
)
<
RelativeLuminanceUtils
:
:
Compute
(
GDK_RGBA_TO_NS_RGBA
(
fg
)
)
)
;
mHighContrast
=
StaticPrefs
:
:
widget_content_gtk_high_contrast_enabled
(
)
&
&
GetGtkTheme
(
)
.
Find
(
"
HighContrast
"
_ns
)
>
=
0
;
gboolean
enableAnimations
=
false
;
g_object_get
(
settings
"
gtk
-
enable
-
animations
"
&
enableAnimations
nullptr
)
;
mPrefersReducedMotion
=
!
enableAnimations
;
}
GtkWidget
*
labelWidget
=
gtk_label_new
(
"
M
"
)
;
g_object_ref_sink
(
labelWidget
)
;
GdkRGBA
color
;
style
=
GetStyleContext
(
MOZ_GTK_SCROLLBAR_TROUGH_VERTICAL
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozScrollbar
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_WINDOW
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozWindowBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozWindowText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_border_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozWindowActiveBorder
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_border_color
(
style
GTK_STATE_FLAG_INSENSITIVE
&
color
)
;
mMozWindowInactiveBorder
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_INSENSITIVE
&
color
)
;
mMozWindowInactiveCaption
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_WINDOW_CONTAINER
)
;
{
GtkStyleContext
*
labelStyle
=
CreateStyleForWidget
(
labelWidget
style
)
;
GetSystemFontInfo
(
labelStyle
&
mDefaultFontName
&
mDefaultFontStyle
)
;
g_object_unref
(
labelStyle
)
;
}
style
=
GetStyleContext
(
MOZ_GTK_TOOLTIP
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mInfoBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_TOOLTIP_BOX_LABEL
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mInfoText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_MENUITEM
)
;
{
GtkStyleContext
*
accelStyle
=
CreateStyleForWidget
(
gtk_accel_label_new
(
"
M
"
)
style
)
;
GetSystemFontInfo
(
accelStyle
&
mMenuFontName
&
mMenuFontStyle
)
;
gtk_style_context_get_color
(
accelStyle
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMenuText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
accelStyle
GTK_STATE_FLAG_INSENSITIVE
&
color
)
;
mMenuTextInactive
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
g_object_unref
(
accelStyle
)
;
}
style
=
GetStyleContext
(
MOZ_GTK_MENUPOPUP
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMenuBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_MENUITEM
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMenuHover
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMenuHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
GtkWidget
*
parent
=
gtk_fixed_new
(
)
;
GtkWidget
*
window
=
gtk_window_new
(
GTK_WINDOW_POPUP
)
;
GtkWidget
*
treeView
=
gtk_tree_view_new
(
)
;
GtkWidget
*
linkButton
=
gtk_link_button_new
(
"
http
:
/
/
example
.
com
/
"
)
;
GtkWidget
*
menuBar
=
gtk_menu_bar_new
(
)
;
GtkWidget
*
menuBarItem
=
gtk_menu_item_new
(
)
;
GtkWidget
*
entry
=
gtk_entry_new
(
)
;
GtkWidget
*
textView
=
gtk_text_view_new
(
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
treeView
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
linkButton
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
menuBar
)
;
gtk_menu_shell_append
(
GTK_MENU_SHELL
(
menuBar
)
menuBarItem
)
;
gtk_container_add
(
GTK_CONTAINER
(
window
)
parent
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
entry
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
textView
)
;
GdkRGBA
bgColor
;
style
=
GetStyleContext
(
MOZ_GTK_TEXT_VIEW
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
bgColor
)
;
style
=
GetStyleContext
(
MOZ_GTK_TEXT_VIEW_TEXT
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
ApplyColorOver
(
color
&
bgColor
)
;
mFieldBackground
=
GDK_RGBA_TO_NS_RGBA
(
bgColor
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mFieldText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
{
GtkStyleContext
*
selectionStyle
=
GetStyleContext
(
MOZ_GTK_TEXT_VIEW_TEXT_SELECTION
)
;
auto
GrabSelectionColors
=
[
&
]
(
GtkStyleContext
*
style
)
{
gtk_style_context_get_background_color
(
style
static_cast
<
GtkStateFlags
>
(
GTK_STATE_FLAG_FOCUSED
|
GTK_STATE_FLAG_SELECTED
)
&
color
)
;
mTextSelectedBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
static_cast
<
GtkStateFlags
>
(
GTK_STATE_FLAG_FOCUSED
|
GTK_STATE_FLAG_SELECTED
)
&
color
)
;
mTextSelectedText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
}
;
GrabSelectionColors
(
selectionStyle
)
;
if
(
mTextSelectedBackground
=
=
mTextSelectedText
)
{
GrabSelectionColors
(
style
)
;
}
}
style
=
GetStyleContext
(
MOZ_GTK_BUTTON
)
;
{
GtkStyleContext
*
labelStyle
=
CreateStyleForWidget
(
labelWidget
style
)
;
GetSystemFontInfo
(
labelStyle
&
mButtonFontName
&
mButtonFontStyle
)
;
g_object_unref
(
labelStyle
)
;
}
gtk_style_context_get_border_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mButtonDefault
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mButtonText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mButtonHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_ACTIVE
&
color
)
;
mButtonActiveText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mButtonHoverFace
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_COMBOBOX_ENTRY_TEXTAREA
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mComboBoxText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_MENUBARITEM
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMenuBarText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMenuBarHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_TREEVIEW
)
;
gtk_style_context_save
(
style
)
;
gtk_style_context_add_region
(
style
GTK_STYLE_REGION_ROW
GTK_REGION_ODD
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mOddCellBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_restore
(
style
)
;
style
=
GetStyleContext
(
MOZ_GTK_TREE_HEADER_CELL
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozColHeaderText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMozColHeaderHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
InitCellHighlightColors
(
)
;
style
=
GetStyleContext
(
MOZ_GTK_FRAME_BORDER
)
;
bool
themeUsesColors
=
GetBorderColors
(
style
&
mFrameOuterLightBorder
&
mFrameInnerDarkBorder
)
;
if
(
!
themeUsesColors
)
{
style
=
GetStyleContext
(
MOZ_GTK_FRAME
)
;
GetBorderColors
(
style
&
mFrameOuterLightBorder
&
mFrameInnerDarkBorder
)
;
}
GtkWidget
*
infoBar
=
gtk_info_bar_new
(
)
;
GtkWidget
*
infoBarContent
=
gtk_info_bar_get_content_area
(
GTK_INFO_BAR
(
infoBar
)
)
;
GtkWidget
*
infoBarLabel
=
gtk_label_new
(
nullptr
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
infoBar
)
;
gtk_container_add
(
GTK_CONTAINER
(
infoBarContent
)
infoBarLabel
)
;
style
=
gtk_widget_get_style_context
(
infoBarLabel
)
;
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_INFO
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mInfoBarText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gboolean
supports_menubar_drag
=
FALSE
;
GParamSpec
*
param_spec
=
gtk_widget_class_find_style_property
(
GTK_WIDGET_GET_CLASS
(
menuBar
)
"
window
-
dragging
"
)
;
if
(
param_spec
)
{
if
(
g_type_is_a
(
G_PARAM_SPEC_VALUE_TYPE
(
param_spec
)
G_TYPE_BOOLEAN
)
)
{
gtk_widget_style_get
(
menuBar
"
window
-
dragging
"
&
supports_menubar_drag
nullptr
)
;
}
}
mMenuSupportsDrag
=
supports_menubar_drag
;
style
=
gtk_widget_get_style_context
(
linkButton
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_LINK
&
color
)
;
mNativeHyperLinkText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
guint
value
;
g_object_get
(
entry
"
invisible
-
char
"
&
value
nullptr
)
;
mInvisibleCharacter
=
char16_t
(
value
)
;
gtk_widget_style_get
(
entry
"
cursor
-
aspect
-
ratio
"
&
mCaretRatio
nullptr
)
;
gint
blink_time
;
gboolean
blink
;
g_object_get
(
settings
"
gtk
-
cursor
-
blink
-
time
"
&
blink_time
"
gtk
-
cursor
-
blink
"
&
blink
nullptr
)
;
mCaretBlinkTime
=
blink
?
(
int32_t
)
blink_time
:
0
;
GetSystemFontInfo
(
gtk_widget_get_style_context
(
entry
)
&
mFieldFontName
&
mFieldFontStyle
)
;
gtk_widget_destroy
(
window
)
;
g_object_unref
(
labelWidget
)
;
mCSDAvailable
=
nsWindow
:
:
GetSystemCSDSupportLevel
(
)
!
=
nsWindow
:
:
CSD_SUPPORT_NONE
;
mCSDHideTitlebarByDefault
=
nsWindow
:
:
HideTitlebarByDefault
(
)
;
mCSDCloseButton
=
false
;
mCSDMinimizeButton
=
false
;
mCSDMaximizeButton
=
false
;
mCSDCloseButtonPosition
=
0
;
mCSDMinimizeButtonPosition
=
0
;
mCSDMaximizeButtonPosition
=
0
;
ButtonLayout
buttonLayout
[
TOOLBAR_BUTTONS
]
;
size_t
activeButtons
=
GetGtkHeaderBarButtonLayout
(
Span
(
buttonLayout
)
&
mCSDReversedPlacement
)
;
for
(
size_t
i
=
0
;
i
<
activeButtons
;
i
+
+
)
{
const
ButtonLayout
&
layout
=
buttonLayout
[
i
]
;
int32_t
*
pos
=
nullptr
;
switch
(
layout
.
mType
)
{
case
MOZ_GTK_HEADER_BAR_BUTTON_MINIMIZE
:
mCSDMinimizeButton
=
true
;
pos
=
&
mCSDMinimizeButtonPosition
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE
:
mCSDMaximizeButton
=
true
;
pos
=
&
mCSDMaximizeButtonPosition
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_CLOSE
:
mCSDCloseButton
=
true
;
pos
=
&
mCSDCloseButtonPosition
;
break
;
default
:
break
;
}
if
(
pos
)
{
*
pos
=
i
;
if
(
layout
.
mAtRight
)
{
*
pos
+
=
TOOLBAR_BUTTONS
;
}
}
}
RecordTelemetry
(
)
;
}
char16_t
nsLookAndFeel
:
:
GetPasswordCharacterImpl
(
)
{
EnsureInit
(
)
;
return
mInvisibleCharacter
;
}
bool
nsLookAndFeel
:
:
GetEchoPasswordImpl
(
)
{
return
false
;
}
