#
include
<
stdlib
.
h
>
#
include
"
nsLookAndFeel
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
<
gdk
/
gdk
.
h
>
#
include
<
pango
/
pango
.
h
>
#
include
<
pango
/
pango
-
fontmap
.
h
>
#
include
<
fontconfig
/
fontconfig
.
h
>
#
include
"
gfxPlatformGtk
.
h
"
#
include
"
mozilla
/
FontPropertyTypes
.
h
"
#
include
"
mozilla
/
RelativeLuminanceUtils
.
h
"
#
include
"
ScreenHelperGTK
.
h
"
#
include
"
gtkdrawing
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
<
cairo
-
gobject
.
h
>
#
include
"
WidgetStyleCache
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsCSSColorUtils
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
LookAndFeel
;
#
define
GDK_COLOR_TO_NS_RGB
(
c
)
\
(
(
nscolor
)
NS_RGB
(
c
.
red
>
>
8
c
.
green
>
>
8
c
.
blue
>
>
8
)
)
#
define
GDK_RGBA_TO_NS_RGBA
(
c
)
\
(
(
nscolor
)
NS_RGBA
(
(
int
)
(
(
c
)
.
red
*
255
)
(
int
)
(
(
c
)
.
green
*
255
)
\
(
int
)
(
(
c
)
.
blue
*
255
)
(
int
)
(
(
c
)
.
alpha
*
255
)
)
)
#
if
!
GTK_CHECK_VERSION
(
3
12
0
)
#
define
GTK_STATE_FLAG_LINK
(
static_cast
<
GtkStateFlags
>
(
1
<
<
9
)
)
#
endif
nsLookAndFeel
:
:
nsLookAndFeel
(
)
=
default
;
nsLookAndFeel
:
:
~
nsLookAndFeel
(
)
{
}
static
void
ApplyColorOver
(
const
GdkRGBA
&
aSource
GdkRGBA
*
aDest
)
{
gdouble
sourceCoef
=
aSource
.
alpha
;
gdouble
destCoef
=
aDest
-
>
alpha
*
(
1
.
0
-
sourceCoef
)
;
gdouble
resultAlpha
=
sourceCoef
+
destCoef
;
if
(
resultAlpha
!
=
0
.
0
)
{
destCoef
/
=
resultAlpha
;
sourceCoef
/
=
resultAlpha
;
aDest
-
>
red
=
sourceCoef
*
aSource
.
red
+
destCoef
*
aDest
-
>
red
;
aDest
-
>
green
=
sourceCoef
*
aSource
.
green
+
destCoef
*
aDest
-
>
green
;
aDest
-
>
blue
=
sourceCoef
*
aSource
.
blue
+
destCoef
*
aDest
-
>
blue
;
aDest
-
>
alpha
=
resultAlpha
;
}
}
static
void
GetLightAndDarkness
(
const
GdkRGBA
&
aColor
double
*
aLightness
double
*
aDarkness
)
{
double
sum
=
aColor
.
red
+
aColor
.
green
+
aColor
.
blue
;
*
aLightness
=
sum
*
aColor
.
alpha
;
*
aDarkness
=
(
3
.
0
-
sum
)
*
aColor
.
alpha
;
}
static
bool
GetGradientColors
(
const
GValue
*
aValue
GdkRGBA
*
aLightColor
GdkRGBA
*
aDarkColor
)
{
if
(
!
G_TYPE_CHECK_VALUE_TYPE
(
aValue
CAIRO_GOBJECT_TYPE_PATTERN
)
)
return
false
;
auto
pattern
=
static_cast
<
cairo_pattern_t
*
>
(
g_value_get_boxed
(
aValue
)
)
;
if
(
!
pattern
)
return
false
;
if
(
CAIRO_STATUS_SUCCESS
!
=
cairo_pattern_get_color_stop_rgba
(
pattern
0
nullptr
&
aDarkColor
-
>
red
&
aDarkColor
-
>
green
&
aDarkColor
-
>
blue
&
aDarkColor
-
>
alpha
)
)
return
false
;
double
maxLightness
maxDarkness
;
GetLightAndDarkness
(
*
aDarkColor
&
maxLightness
&
maxDarkness
)
;
*
aLightColor
=
*
aDarkColor
;
GdkRGBA
stop
;
for
(
int
index
=
1
;
CAIRO_STATUS_SUCCESS
=
=
cairo_pattern_get_color_stop_rgba
(
pattern
index
nullptr
&
stop
.
red
&
stop
.
green
&
stop
.
blue
&
stop
.
alpha
)
;
+
+
index
)
{
double
lightness
darkness
;
GetLightAndDarkness
(
stop
&
lightness
&
darkness
)
;
if
(
lightness
>
maxLightness
)
{
maxLightness
=
lightness
;
*
aLightColor
=
stop
;
}
if
(
darkness
>
maxDarkness
)
{
maxDarkness
=
darkness
;
*
aDarkColor
=
stop
;
}
}
return
true
;
}
static
bool
GetUnicoBorderGradientColors
(
GtkStyleContext
*
aContext
GdkRGBA
*
aLightColor
GdkRGBA
*
aDarkColor
)
{
const
char
*
propertyName
=
"
-
unico
-
border
-
gradient
"
;
if
(
!
gtk_style_properties_lookup_property
(
propertyName
nullptr
nullptr
)
)
return
false
;
GtkThemingEngine
*
engine
;
GtkStateFlags
state
=
gtk_style_context_get_state
(
aContext
)
;
gtk_style_context_get
(
aContext
state
"
engine
"
&
engine
nullptr
)
;
if
(
strcmp
(
g_type_name
(
G_TYPE_FROM_INSTANCE
(
engine
)
)
"
UnicoEngine
"
)
!
=
0
)
return
false
;
GValue
value
=
G_VALUE_INIT
;
gtk_style_context_get_property
(
aContext
propertyName
state
&
value
)
;
bool
result
=
GetGradientColors
(
&
value
aLightColor
aDarkColor
)
;
g_value_unset
(
&
value
)
;
return
result
;
}
static
bool
GetBorderColors
(
GtkStyleContext
*
aContext
GdkRGBA
*
aLightColor
GdkRGBA
*
aDarkColor
)
{
GtkStateFlags
state
=
gtk_style_context_get_state
(
aContext
)
;
GtkBorderStyle
borderStyle
;
gtk_style_context_get
(
aContext
state
GTK_STYLE_PROPERTY_BORDER_STYLE
&
borderStyle
nullptr
)
;
bool
visible
=
borderStyle
!
=
GTK_BORDER_STYLE_NONE
&
&
borderStyle
!
=
GTK_BORDER_STYLE_HIDDEN
;
if
(
visible
)
{
GtkBorder
border
;
gtk_style_context_get_border
(
aContext
state
&
border
)
;
visible
=
border
.
top
!
=
0
|
|
border
.
right
!
=
0
|
|
border
.
bottom
!
=
0
|
|
border
.
left
!
=
0
;
}
if
(
visible
&
&
GetUnicoBorderGradientColors
(
aContext
aLightColor
aDarkColor
)
)
return
true
;
gtk_style_context_get_border_color
(
aContext
state
aDarkColor
)
;
*
aLightColor
=
*
aDarkColor
;
return
visible
;
}
static
bool
GetBorderColors
(
GtkStyleContext
*
aContext
nscolor
*
aLightColor
nscolor
*
aDarkColor
)
{
GdkRGBA
lightColor
darkColor
;
bool
ret
=
GetBorderColors
(
aContext
&
lightColor
&
darkColor
)
;
*
aLightColor
=
GDK_RGBA_TO_NS_RGBA
(
lightColor
)
;
*
aDarkColor
=
GDK_RGBA_TO_NS_RGBA
(
darkColor
)
;
return
ret
;
}
nsresult
nsLookAndFeel
:
:
InitCellHighlightColors
(
)
{
int32_t
minLuminosityDifference
=
NS_SUFFICIENT_LUMINOSITY_DIFFERENCE
/
5
;
int32_t
backLuminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
mMozWindowBackground
mMozFieldBackground
)
;
if
(
backLuminosityDifference
>
=
minLuminosityDifference
)
{
mMozCellHighlightBackground
=
mMozWindowBackground
;
mMozCellHighlightText
=
mMozWindowText
;
return
NS_OK
;
}
uint16_t
hue
sat
luminance
;
uint8_t
alpha
;
mMozCellHighlightBackground
=
mMozFieldBackground
;
mMozCellHighlightText
=
mMozFieldText
;
NS_RGB2HSV
(
mMozCellHighlightBackground
hue
sat
luminance
alpha
)
;
uint16_t
step
=
30
;
if
(
luminance
<
=
step
)
{
luminance
+
=
step
;
}
else
if
(
luminance
>
=
255
-
step
)
{
luminance
-
=
step
;
}
else
{
uint16_t
textHue
textSat
textLuminance
;
uint8_t
textAlpha
;
NS_RGB2HSV
(
mMozCellHighlightText
textHue
textSat
textLuminance
textAlpha
)
;
if
(
textLuminance
<
luminance
)
{
luminance
+
=
step
;
}
else
{
luminance
-
=
step
;
}
}
NS_HSV2RGB
(
mMozCellHighlightBackground
hue
sat
luminance
alpha
)
;
return
NS_OK
;
}
void
nsLookAndFeel
:
:
NativeInit
(
)
{
EnsureInit
(
)
;
}
void
nsLookAndFeel
:
:
RefreshImpl
(
)
{
nsXPLookAndFeel
:
:
RefreshImpl
(
)
;
moz_gtk_refresh
(
)
;
mDefaultFontCached
=
false
;
mButtonFontCached
=
false
;
mFieldFontCached
=
false
;
mMenuFontCached
=
false
;
mInitialized
=
false
;
}
nsresult
nsLookAndFeel
:
:
NativeGetColor
(
ColorID
aID
nscolor
&
aColor
)
{
EnsureInit
(
)
;
nsresult
res
=
NS_OK
;
switch
(
aID
)
{
case
ColorID
:
:
WindowBackground
:
case
ColorID
:
:
WidgetBackground
:
case
ColorID
:
:
TextBackground
:
case
ColorID
:
:
Activecaption
:
case
ColorID
:
:
Appworkspace
:
case
ColorID
:
:
Background
:
case
ColorID
:
:
Window
:
case
ColorID
:
:
Windowframe
:
case
ColorID
:
:
MozDialog
:
case
ColorID
:
:
MozCombobox
:
aColor
=
mMozWindowBackground
;
break
;
case
ColorID
:
:
WindowForeground
:
case
ColorID
:
:
WidgetForeground
:
case
ColorID
:
:
TextForeground
:
case
ColorID
:
:
Captiontext
:
case
ColorID
:
:
Windowtext
:
case
ColorID
:
:
MozDialogtext
:
aColor
=
mMozWindowText
;
break
;
case
ColorID
:
:
WidgetSelectBackground
:
case
ColorID
:
:
TextSelectBackground
:
case
ColorID
:
:
IMESelectedRawTextBackground
:
case
ColorID
:
:
IMESelectedConvertedTextBackground
:
case
ColorID
:
:
MozDragtargetzone
:
case
ColorID
:
:
MozHtmlCellhighlight
:
case
ColorID
:
:
Highlight
:
aColor
=
mTextSelectedBackground
;
break
;
case
ColorID
:
:
WidgetSelectForeground
:
case
ColorID
:
:
TextSelectForeground
:
case
ColorID
:
:
IMESelectedRawTextForeground
:
case
ColorID
:
:
IMESelectedConvertedTextForeground
:
case
ColorID
:
:
Highlighttext
:
case
ColorID
:
:
MozHtmlCellhighlighttext
:
aColor
=
mTextSelectedText
;
break
;
case
ColorID
:
:
MozCellhighlight
:
aColor
=
mMozCellHighlightBackground
;
break
;
case
ColorID
:
:
MozCellhighlighttext
:
aColor
=
mMozCellHighlightText
;
break
;
case
ColorID
:
:
Widget3DHighlight
:
aColor
=
NS_RGB
(
0xa0
0xa0
0xa0
)
;
break
;
case
ColorID
:
:
Widget3DShadow
:
aColor
=
NS_RGB
(
0x40
0x40
0x40
)
;
break
;
case
ColorID
:
:
IMERawInputBackground
:
case
ColorID
:
:
IMEConvertedTextBackground
:
aColor
=
NS_TRANSPARENT
;
break
;
case
ColorID
:
:
IMERawInputForeground
:
case
ColorID
:
:
IMEConvertedTextForeground
:
aColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
break
;
case
ColorID
:
:
IMERawInputUnderline
:
case
ColorID
:
:
IMEConvertedTextUnderline
:
aColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
break
;
case
ColorID
:
:
IMESelectedRawTextUnderline
:
case
ColorID
:
:
IMESelectedConvertedTextUnderline
:
aColor
=
NS_TRANSPARENT
;
break
;
case
ColorID
:
:
SpellCheckerUnderline
:
aColor
=
NS_RGB
(
0xff
0
0
)
;
break
;
case
ColorID
:
:
Activeborder
:
aColor
=
mMozWindowActiveBorder
;
break
;
case
ColorID
:
:
Inactiveborder
:
aColor
=
mMozWindowInactiveBorder
;
break
;
case
ColorID
:
:
Graytext
:
case
ColorID
:
:
Inactivecaptiontext
:
aColor
=
mMenuTextInactive
;
break
;
case
ColorID
:
:
Inactivecaption
:
aColor
=
mMozWindowInactiveCaption
;
break
;
case
ColorID
:
:
Infobackground
:
aColor
=
mInfoBackground
;
break
;
case
ColorID
:
:
Infotext
:
aColor
=
mInfoText
;
break
;
case
ColorID
:
:
Menu
:
aColor
=
mMenuBackground
;
break
;
case
ColorID
:
:
Menutext
:
aColor
=
mMenuText
;
break
;
case
ColorID
:
:
Scrollbar
:
aColor
=
mMozScrollbar
;
break
;
case
ColorID
:
:
Threedlightshadow
:
case
ColorID
:
:
Threedface
:
case
ColorID
:
:
Buttonface
:
aColor
=
mMozWindowBackground
;
break
;
case
ColorID
:
:
Buttontext
:
aColor
=
mButtonText
;
break
;
case
ColorID
:
:
Buttonhighlight
:
case
ColorID
:
:
Threedhighlight
:
aColor
=
mFrameOuterLightBorder
;
break
;
case
ColorID
:
:
Buttonshadow
:
case
ColorID
:
:
Threedshadow
:
aColor
=
mFrameInnerDarkBorder
;
break
;
case
ColorID
:
:
Threeddarkshadow
:
aColor
=
NS_RGB
(
0x00
0x00
0x00
)
;
break
;
case
ColorID
:
:
MozEventreerow
:
case
ColorID
:
:
MozField
:
aColor
=
mMozFieldBackground
;
break
;
case
ColorID
:
:
MozFieldtext
:
aColor
=
mMozFieldText
;
break
;
case
ColorID
:
:
MozButtondefault
:
aColor
=
mButtonDefault
;
break
;
case
ColorID
:
:
MozButtonhoverface
:
aColor
=
mButtonHoverFace
;
break
;
case
ColorID
:
:
MozButtonhovertext
:
aColor
=
mButtonHoverText
;
break
;
case
ColorID
:
:
MozGtkButtonactivetext
:
aColor
=
mButtonActiveText
;
break
;
case
ColorID
:
:
MozMenuhover
:
aColor
=
mMenuHover
;
break
;
case
ColorID
:
:
MozMenuhovertext
:
aColor
=
mMenuHoverText
;
break
;
case
ColorID
:
:
MozOddtreerow
:
aColor
=
mOddCellBackground
;
break
;
case
ColorID
:
:
MozNativehyperlinktext
:
aColor
=
mNativeHyperLinkText
;
break
;
case
ColorID
:
:
MozComboboxtext
:
aColor
=
mComboBoxText
;
break
;
case
ColorID
:
:
MozMenubartext
:
aColor
=
mMenuBarText
;
break
;
case
ColorID
:
:
MozMenubarhovertext
:
aColor
=
mMenuBarHoverText
;
break
;
case
ColorID
:
:
MozGtkInfoBarText
:
aColor
=
mInfoBarText
;
break
;
default
:
aColor
=
0
;
res
=
NS_ERROR_FAILURE
;
break
;
}
return
res
;
}
static
int32_t
CheckWidgetStyle
(
GtkWidget
*
aWidget
const
char
*
aStyle
int32_t
aResult
)
{
gboolean
value
=
FALSE
;
gtk_widget_style_get
(
aWidget
aStyle
&
value
nullptr
)
;
return
value
?
aResult
:
0
;
}
static
int32_t
ConvertGTKStepperStyleToMozillaScrollArrowStyle
(
GtkWidget
*
aWidget
)
{
if
(
!
aWidget
)
return
mozilla
:
:
LookAndFeel
:
:
eScrollArrowStyle_Single
;
return
CheckWidgetStyle
(
aWidget
"
has
-
backward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_StartBackward
)
|
CheckWidgetStyle
(
aWidget
"
has
-
forward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_EndForward
)
|
CheckWidgetStyle
(
aWidget
"
has
-
secondary
-
backward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_EndBackward
)
|
CheckWidgetStyle
(
aWidget
"
has
-
secondary
-
forward
-
stepper
"
mozilla
:
:
LookAndFeel
:
:
eScrollArrow_StartForward
)
;
}
nsresult
nsLookAndFeel
:
:
GetIntImpl
(
IntID
aID
int32_t
&
aResult
)
{
nsresult
res
=
NS_OK
;
switch
(
aID
)
{
case
eIntID_ScrollButtonLeftMouseButtonAction
:
aResult
=
0
;
return
NS_OK
;
case
eIntID_ScrollButtonMiddleMouseButtonAction
:
aResult
=
1
;
return
NS_OK
;
case
eIntID_ScrollButtonRightMouseButtonAction
:
aResult
=
2
;
return
NS_OK
;
default
:
break
;
}
res
=
nsXPLookAndFeel
:
:
GetIntImpl
(
aID
aResult
)
;
if
(
NS_SUCCEEDED
(
res
)
)
return
res
;
res
=
NS_OK
;
switch
(
aID
)
{
case
eIntID_CaretBlinkTime
:
EnsureInit
(
)
;
aResult
=
mCaretBlinkTime
;
break
;
case
eIntID_CaretWidth
:
aResult
=
1
;
break
;
case
eIntID_ShowCaretDuringSelection
:
aResult
=
0
;
break
;
case
eIntID_SelectTextfieldsOnKeyFocus
:
{
GtkWidget
*
entry
;
GtkSettings
*
settings
;
gboolean
select_on_focus
;
entry
=
gtk_entry_new
(
)
;
g_object_ref_sink
(
entry
)
;
settings
=
gtk_widget_get_settings
(
entry
)
;
g_object_get
(
settings
"
gtk
-
entry
-
select
-
on
-
focus
"
&
select_on_focus
nullptr
)
;
if
(
select_on_focus
)
aResult
=
1
;
else
aResult
=
0
;
gtk_widget_destroy
(
entry
)
;
g_object_unref
(
entry
)
;
}
break
;
case
eIntID_ScrollToClick
:
{
GtkSettings
*
settings
;
gboolean
warps_slider
=
FALSE
;
settings
=
gtk_settings_get_default
(
)
;
if
(
g_object_class_find_property
(
G_OBJECT_GET_CLASS
(
settings
)
"
gtk
-
primary
-
button
-
warps
-
slider
"
)
)
{
g_object_get
(
settings
"
gtk
-
primary
-
button
-
warps
-
slider
"
&
warps_slider
nullptr
)
;
}
if
(
warps_slider
)
aResult
=
1
;
else
aResult
=
0
;
}
break
;
case
eIntID_SubmenuDelay
:
{
GtkSettings
*
settings
;
gint
delay
;
settings
=
gtk_settings_get_default
(
)
;
g_object_get
(
settings
"
gtk
-
menu
-
popup
-
delay
"
&
delay
nullptr
)
;
aResult
=
(
int32_t
)
delay
;
break
;
}
case
eIntID_TooltipDelay
:
{
aResult
=
500
;
break
;
}
case
eIntID_MenusCanOverlapOSBar
:
aResult
=
1
;
break
;
case
eIntID_SkipNavigatingDisabledMenuItem
:
aResult
=
1
;
break
;
case
eIntID_DragThresholdX
:
case
eIntID_DragThresholdY
:
{
GtkWidget
*
box
=
gtk_hbox_new
(
FALSE
5
)
;
gint
threshold
=
0
;
g_object_get
(
gtk_widget_get_settings
(
box
)
"
gtk
-
dnd
-
drag
-
threshold
"
&
threshold
nullptr
)
;
g_object_ref_sink
(
box
)
;
aResult
=
threshold
;
}
break
;
case
eIntID_ScrollArrowStyle
:
{
GtkWidget
*
scrollbar
=
GetWidget
(
MOZ_GTK_SCROLLBAR_HORIZONTAL
)
;
aResult
=
ConvertGTKStepperStyleToMozillaScrollArrowStyle
(
scrollbar
)
;
break
;
}
case
eIntID_ScrollSliderStyle
:
aResult
=
eScrollThumbStyle_Proportional
;
break
;
case
eIntID_TreeOpenDelay
:
aResult
=
1000
;
break
;
case
eIntID_TreeCloseDelay
:
aResult
=
1000
;
break
;
case
eIntID_TreeLazyScrollDelay
:
aResult
=
150
;
break
;
case
eIntID_TreeScrollDelay
:
aResult
=
100
;
break
;
case
eIntID_TreeScrollLinesMax
:
aResult
=
3
;
break
;
case
eIntID_DWMCompositor
:
case
eIntID_WindowsClassic
:
case
eIntID_WindowsDefaultTheme
:
case
eIntID_WindowsThemeIdentifier
:
case
eIntID_OperatingSystemVersionIdentifier
:
aResult
=
0
;
res
=
NS_ERROR_NOT_IMPLEMENTED
;
break
;
case
eIntID_TouchEnabled
:
aResult
=
mozilla
:
:
widget
:
:
WidgetUtils
:
:
IsTouchDeviceSupportPresent
(
)
;
break
;
case
eIntID_MacGraphiteTheme
:
aResult
=
0
;
res
=
NS_ERROR_NOT_IMPLEMENTED
;
break
;
case
eIntID_AlertNotificationOrigin
:
aResult
=
NS_ALERT_TOP
;
break
;
case
eIntID_IMERawInputUnderlineStyle
:
case
eIntID_IMEConvertedTextUnderlineStyle
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
break
;
case
eIntID_IMESelectedRawTextUnderlineStyle
:
case
eIntID_IMESelectedConvertedTextUnderline
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
;
break
;
case
eIntID_SpellCheckerUnderlineStyle
:
aResult
=
NS_STYLE_TEXT_DECORATION_STYLE_WAVY
;
break
;
case
eIntID_MenuBarDrag
:
EnsureInit
(
)
;
aResult
=
mMenuSupportsDrag
;
break
;
case
eIntID_ScrollbarButtonAutoRepeatBehavior
:
aResult
=
1
;
break
;
case
eIntID_SwipeAnimationEnabled
:
aResult
=
0
;
break
;
case
eIntID_ContextMenuOffsetVertical
:
case
eIntID_ContextMenuOffsetHorizontal
:
aResult
=
2
;
break
;
case
eIntID_GTKCSDAvailable
:
EnsureInit
(
)
;
aResult
=
mCSDAvailable
;
break
;
case
eIntID_GTKCSDHideTitlebarByDefault
:
EnsureInit
(
)
;
aResult
=
mCSDHideTitlebarByDefault
;
break
;
case
eIntID_GTKCSDMaximizeButton
:
EnsureInit
(
)
;
aResult
=
mCSDMaximizeButton
;
break
;
case
eIntID_GTKCSDMinimizeButton
:
EnsureInit
(
)
;
aResult
=
mCSDMinimizeButton
;
break
;
case
eIntID_GTKCSDCloseButton
:
EnsureInit
(
)
;
aResult
=
mCSDCloseButton
;
break
;
case
eIntID_GTKCSDTransparentBackground
:
{
GdkScreen
*
screen
=
gdk_screen_get_default
(
)
;
aResult
=
gdk_screen_is_composited
(
screen
)
?
(
nsWindow
:
:
GetSystemCSDSupportLevel
(
)
!
=
nsWindow
:
:
CSD_SUPPORT_NONE
)
:
false
;
break
;
}
case
eIntID_GTKCSDReversedPlacement
:
EnsureInit
(
)
;
aResult
=
mCSDReversedPlacement
;
break
;
case
eIntID_PrefersReducedMotion
:
{
GtkSettings
*
settings
;
gboolean
enableAnimations
;
settings
=
gtk_settings_get_default
(
)
;
g_object_get
(
settings
"
gtk
-
enable
-
animations
"
&
enableAnimations
nullptr
)
;
aResult
=
enableAnimations
?
0
:
1
;
break
;
}
case
eIntID_SystemUsesDarkTheme
:
{
nscolor
fg
bg
;
if
(
NS_SUCCEEDED
(
NativeGetColor
(
ColorID
:
:
Windowtext
fg
)
)
&
&
NS_SUCCEEDED
(
NativeGetColor
(
ColorID
:
:
Window
bg
)
)
)
{
aResult
=
(
RelativeLuminanceUtils
:
:
Compute
(
bg
)
<
RelativeLuminanceUtils
:
:
Compute
(
fg
)
)
?
1
:
0
;
break
;
}
MOZ_FALLTHROUGH
;
}
default
:
aResult
=
0
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
nsresult
nsLookAndFeel
:
:
GetFloatImpl
(
FloatID
aID
float
&
aResult
)
{
nsresult
res
=
NS_OK
;
res
=
nsXPLookAndFeel
:
:
GetFloatImpl
(
aID
aResult
)
;
if
(
NS_SUCCEEDED
(
res
)
)
return
res
;
res
=
NS_OK
;
switch
(
aID
)
{
case
eFloatID_IMEUnderlineRelativeSize
:
aResult
=
1
.
0f
;
break
;
case
eFloatID_SpellCheckerUnderlineRelativeSize
:
aResult
=
1
.
0f
;
break
;
case
eFloatID_CaretAspectRatio
:
EnsureInit
(
)
;
aResult
=
mCaretRatio
;
break
;
default
:
aResult
=
-
1
.
0
;
res
=
NS_ERROR_FAILURE
;
}
return
res
;
}
static
void
GetSystemFontInfo
(
GtkStyleContext
*
aStyle
nsString
*
aFontName
gfxFontStyle
*
aFontStyle
)
{
aFontStyle
-
>
style
=
FontSlantStyle
:
:
Normal
(
)
;
PangoFontDescription
*
desc
;
gtk_style_context_get
(
aStyle
gtk_style_context_get_state
(
aStyle
)
"
font
"
&
desc
nullptr
)
;
aFontStyle
-
>
systemFont
=
true
;
NS_NAMED_LITERAL_STRING
(
quote
"
\
"
"
)
;
NS_ConvertUTF8toUTF16
family
(
pango_font_description_get_family
(
desc
)
)
;
*
aFontName
=
quote
+
family
+
quote
;
aFontStyle
-
>
weight
=
FontWeight
(
pango_font_description_get_weight
(
desc
)
)
;
aFontStyle
-
>
stretch
=
FontStretch
:
:
Normal
(
)
;
float
size
=
float
(
pango_font_description_get_size
(
desc
)
)
/
PANGO_SCALE
;
if
(
!
pango_font_description_get_size_is_absolute
(
desc
)
)
{
size
*
=
float
(
gfxPlatformGtk
:
:
GetFontScaleDPI
(
)
)
/
POINTS_PER_INCH_FLOAT
;
}
aFontStyle
-
>
size
=
size
;
pango_font_description_free
(
desc
)
;
}
bool
nsLookAndFeel
:
:
GetFontImpl
(
FontID
aID
nsString
&
aFontName
gfxFontStyle
&
aFontStyle
)
{
switch
(
aID
)
{
case
eFont_Menu
:
case
eFont_PullDownMenu
:
aFontName
=
mMenuFontName
;
aFontStyle
=
mMenuFontStyle
;
break
;
case
eFont_Field
:
case
eFont_List
:
aFontName
=
mFieldFontName
;
aFontStyle
=
mFieldFontStyle
;
break
;
case
eFont_Button
:
aFontName
=
mButtonFontName
;
aFontStyle
=
mButtonFontStyle
;
break
;
case
eFont_Caption
:
case
eFont_Icon
:
case
eFont_MessageBox
:
case
eFont_SmallCaption
:
case
eFont_StatusBar
:
case
eFont_Window
:
case
eFont_Document
:
case
eFont_Workspace
:
case
eFont_Desktop
:
case
eFont_Info
:
case
eFont_Dialog
:
case
eFont_Tooltips
:
case
eFont_Widget
:
default
:
aFontName
=
mDefaultFontName
;
aFontStyle
=
mDefaultFontStyle
;
break
;
}
double
scaleFactor
=
nsIWidget
:
:
DefaultScaleOverride
(
)
;
if
(
scaleFactor
>
0
)
{
aFontStyle
.
size
*
=
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
/
scaleFactor
;
}
else
{
aFontStyle
.
size
/
=
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
}
return
true
;
}
void
nsLookAndFeel
:
:
EnsureInit
(
)
{
GdkColor
colorValue
;
GdkColor
*
colorValuePtr
;
if
(
mInitialized
)
return
;
mInitialized
=
true
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
GdkRGBA
color
;
GtkStyleContext
*
style
;
GtkSettings
*
settings
=
gtk_settings_get_for_screen
(
gdk_screen_get_default
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
settings
)
)
{
NS_WARNING
(
"
EnsureInit
:
No
settings
"
)
;
return
;
}
const
gchar
*
dark_setting
=
"
gtk
-
application
-
prefer
-
dark
-
theme
"
;
gboolean
darkThemeDefault
;
g_object_get
(
settings
dark_setting
&
darkThemeDefault
nullptr
)
;
if
(
darkThemeDefault
)
{
bool
allowDarkTheme
;
if
(
XRE_IsContentProcess
(
)
)
{
allowDarkTheme
=
mozilla
:
:
Preferences
:
:
GetBool
(
"
widget
.
content
.
allow
-
gtk
-
dark
-
theme
"
false
)
;
}
else
{
allowDarkTheme
=
(
PR_GetEnv
(
"
MOZ_ALLOW_GTK_DARK_THEME
"
)
!
=
nullptr
)
|
|
mozilla
:
:
Preferences
:
:
GetBool
(
"
widget
.
chrome
.
allow
-
gtk
-
dark
-
theme
"
false
)
;
}
if
(
!
allowDarkTheme
)
{
g_object_set
(
settings
dark_setting
FALSE
nullptr
)
;
}
}
if
(
XRE_IsContentProcess
(
)
)
{
nsAutoCString
contentThemeName
;
mozilla
:
:
Preferences
:
:
GetCString
(
"
widget
.
content
.
gtk
-
theme
-
override
"
contentThemeName
)
;
if
(
!
contentThemeName
.
IsEmpty
(
)
)
{
g_object_set
(
settings
"
gtk
-
theme
-
name
"
contentThemeName
.
get
(
)
nullptr
)
;
}
}
GtkWidget
*
labelWidget
=
gtk_label_new
(
"
M
"
)
;
g_object_ref_sink
(
labelWidget
)
;
style
=
GetStyleContext
(
MOZ_GTK_SCROLLBAR_TROUGH_VERTICAL
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozScrollbar
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_WINDOW
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozWindowBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozWindowText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_border_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozWindowActiveBorder
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_border_color
(
style
GTK_STATE_FLAG_INSENSITIVE
&
color
)
;
mMozWindowInactiveBorder
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_INSENSITIVE
&
color
)
;
mMozWindowInactiveCaption
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_WINDOW_CONTAINER
)
;
{
GtkStyleContext
*
labelStyle
=
CreateStyleForWidget
(
labelWidget
style
)
;
GetSystemFontInfo
(
labelStyle
&
mDefaultFontName
&
mDefaultFontStyle
)
;
g_object_unref
(
labelStyle
)
;
}
style
=
GetStyleContext
(
MOZ_GTK_TOOLTIP
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mInfoBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_TOOLTIP_BOX_LABEL
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mInfoText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_MENUITEM
)
;
{
GtkStyleContext
*
accelStyle
=
CreateStyleForWidget
(
gtk_accel_label_new
(
"
M
"
)
style
)
;
GetSystemFontInfo
(
accelStyle
&
mMenuFontName
&
mMenuFontStyle
)
;
gtk_style_context_get_color
(
accelStyle
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMenuText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
accelStyle
GTK_STATE_FLAG_INSENSITIVE
&
color
)
;
mMenuTextInactive
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
g_object_unref
(
accelStyle
)
;
}
style
=
GetStyleContext
(
MOZ_GTK_MENUPOPUP
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMenuBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_MENUITEM
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMenuHover
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMenuHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
GtkWidget
*
parent
=
gtk_fixed_new
(
)
;
GtkWidget
*
window
=
gtk_window_new
(
GTK_WINDOW_POPUP
)
;
GtkWidget
*
treeView
=
gtk_tree_view_new
(
)
;
GtkWidget
*
linkButton
=
gtk_link_button_new
(
"
http
:
/
/
example
.
com
/
"
)
;
GtkWidget
*
menuBar
=
gtk_menu_bar_new
(
)
;
GtkWidget
*
menuBarItem
=
gtk_menu_item_new
(
)
;
GtkWidget
*
entry
=
gtk_entry_new
(
)
;
GtkWidget
*
textView
=
gtk_text_view_new
(
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
treeView
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
linkButton
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
menuBar
)
;
gtk_menu_shell_append
(
GTK_MENU_SHELL
(
menuBar
)
menuBarItem
)
;
gtk_container_add
(
GTK_CONTAINER
(
window
)
parent
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
entry
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
textView
)
;
GdkRGBA
bgColor
;
style
=
GetStyleContext
(
MOZ_GTK_TEXT_VIEW
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
bgColor
)
;
style
=
GetStyleContext
(
MOZ_GTK_TEXT_VIEW_TEXT
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
ApplyColorOver
(
color
&
bgColor
)
;
mMozFieldBackground
=
GDK_RGBA_TO_NS_RGBA
(
bgColor
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMozFieldText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_background_color
(
style
static_cast
<
GtkStateFlags
>
(
GTK_STATE_FLAG_FOCUSED
|
GTK_STATE_FLAG_SELECTED
)
&
color
)
;
mTextSelectedBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
static_cast
<
GtkStateFlags
>
(
GTK_STATE_FLAG_FOCUSED
|
GTK_STATE_FLAG_SELECTED
)
&
color
)
;
mTextSelectedText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_BUTTON
)
;
{
GtkStyleContext
*
labelStyle
=
CreateStyleForWidget
(
labelWidget
style
)
;
GetSystemFontInfo
(
labelStyle
&
mButtonFontName
&
mButtonFontStyle
)
;
g_object_unref
(
labelStyle
)
;
}
gtk_style_context_get_border_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mButtonDefault
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mButtonText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mButtonHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_ACTIVE
&
color
)
;
mButtonActiveText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mButtonHoverFace
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_COMBOBOX_ENTRY_TEXTAREA
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mComboBoxText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_MENUBARITEM
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mMenuBarText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_PRELIGHT
&
color
)
;
mMenuBarHoverText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
style
=
GetStyleContext
(
MOZ_GTK_TREEVIEW
)
;
gtk_style_context_save
(
style
)
;
gtk_style_context_add_region
(
style
GTK_STYLE_REGION_ROW
GTK_REGION_ODD
)
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mOddCellBackground
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gtk_style_context_restore
(
style
)
;
InitCellHighlightColors
(
)
;
style
=
GetStyleContext
(
MOZ_GTK_FRAME_BORDER
)
;
bool
themeUsesColors
=
GetBorderColors
(
style
&
mFrameOuterLightBorder
&
mFrameInnerDarkBorder
)
;
if
(
!
themeUsesColors
)
{
style
=
GetStyleContext
(
MOZ_GTK_FRAME
)
;
GetBorderColors
(
style
&
mFrameOuterLightBorder
&
mFrameInnerDarkBorder
)
;
}
GtkWidget
*
infoBar
=
gtk_info_bar_new
(
)
;
GtkWidget
*
infoBarContent
=
gtk_info_bar_get_content_area
(
GTK_INFO_BAR
(
infoBar
)
)
;
GtkWidget
*
infoBarLabel
=
gtk_label_new
(
nullptr
)
;
gtk_container_add
(
GTK_CONTAINER
(
parent
)
infoBar
)
;
gtk_container_add
(
GTK_CONTAINER
(
infoBarContent
)
infoBarLabel
)
;
style
=
gtk_widget_get_style_context
(
infoBarLabel
)
;
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_INFO
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
mInfoBarText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
gboolean
supports_menubar_drag
=
FALSE
;
GParamSpec
*
param_spec
=
gtk_widget_class_find_style_property
(
GTK_WIDGET_GET_CLASS
(
menuBar
)
"
window
-
dragging
"
)
;
if
(
param_spec
)
{
if
(
g_type_is_a
(
G_PARAM_SPEC_VALUE_TYPE
(
param_spec
)
G_TYPE_BOOLEAN
)
)
{
gtk_widget_style_get
(
menuBar
"
window
-
dragging
"
&
supports_menubar_drag
nullptr
)
;
}
}
mMenuSupportsDrag
=
supports_menubar_drag
;
if
(
gtk_check_version
(
3
12
0
)
=
=
nullptr
)
{
style
=
gtk_widget_get_style_context
(
linkButton
)
;
gtk_style_context_get_color
(
style
GTK_STATE_FLAG_LINK
&
color
)
;
mNativeHyperLinkText
=
GDK_RGBA_TO_NS_RGBA
(
color
)
;
}
else
{
colorValuePtr
=
nullptr
;
gtk_widget_style_get
(
linkButton
"
link
-
color
"
&
colorValuePtr
nullptr
)
;
if
(
colorValuePtr
)
{
colorValue
=
*
colorValuePtr
;
mNativeHyperLinkText
=
GDK_COLOR_TO_NS_RGB
(
colorValue
)
;
gdk_color_free
(
colorValuePtr
)
;
}
else
{
mNativeHyperLinkText
=
NS_RGB
(
0x00
0x00
0xEE
)
;
}
}
guint
value
;
g_object_get
(
entry
"
invisible
-
char
"
&
value
nullptr
)
;
mInvisibleCharacter
=
char16_t
(
value
)
;
gtk_widget_style_get
(
entry
"
cursor
-
aspect
-
ratio
"
&
mCaretRatio
nullptr
)
;
gint
blink_time
;
gboolean
blink
;
g_object_get
(
settings
"
gtk
-
cursor
-
blink
-
time
"
&
blink_time
"
gtk
-
cursor
-
blink
"
&
blink
nullptr
)
;
mCaretBlinkTime
=
blink
?
(
int32_t
)
blink_time
:
0
;
GetSystemFontInfo
(
gtk_widget_get_style_context
(
entry
)
&
mFieldFontName
&
mFieldFontStyle
)
;
gtk_widget_destroy
(
window
)
;
g_object_unref
(
labelWidget
)
;
mCSDAvailable
=
nsWindow
:
:
GetSystemCSDSupportLevel
(
)
!
=
nsWindow
:
:
CSD_SUPPORT_NONE
;
mCSDHideTitlebarByDefault
=
nsWindow
:
:
HideTitlebarByDefault
(
)
;
mCSDCloseButton
=
false
;
mCSDMinimizeButton
=
false
;
mCSDMaximizeButton
=
false
;
WidgetNodeType
buttonLayout
[
TOOLBAR_BUTTONS
]
;
int
activeButtons
=
GetGtkHeaderBarButtonLayout
(
buttonLayout
TOOLBAR_BUTTONS
&
mCSDReversedPlacement
)
;
for
(
int
i
=
0
;
i
<
activeButtons
;
i
+
+
)
{
switch
(
buttonLayout
[
i
]
)
{
case
MOZ_GTK_HEADER_BAR_BUTTON_MINIMIZE
:
mCSDMinimizeButton
=
true
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE
:
mCSDMaximizeButton
=
true
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_CLOSE
:
mCSDCloseButton
=
true
;
break
;
default
:
break
;
}
}
}
char16_t
nsLookAndFeel
:
:
GetPasswordCharacterImpl
(
)
{
EnsureInit
(
)
;
return
mInvisibleCharacter
;
}
bool
nsLookAndFeel
:
:
GetEchoPasswordImpl
(
)
{
return
false
;
}
