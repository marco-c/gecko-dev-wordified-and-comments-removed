#
include
"
nsWindow
.
h
"
#
include
<
algorithm
>
#
include
<
dlfcn
.
h
>
#
include
<
gdk
/
gdkkeysyms
.
h
>
#
include
<
wchar
.
h
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxPlatformGtk
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GtkCompositorWidget
.
h
"
#
include
"
gtkdrawing
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
InputData
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
WheelEventBinding
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
HelpersCairo
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
KnowsCompositor
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
APZInputBridge
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
WidgetUtils
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
mozilla
/
X11Util
.
h
"
#
include
"
mozilla
/
XREAppData
.
h
"
#
include
"
NativeKeyBindings
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsDragService
.
h
"
#
include
"
nsGTKToolkit
.
h
"
#
include
"
nsGtkKeyUtils
.
h
"
#
include
"
nsGtkCursors
.
h
"
#
include
"
nsGfxCIID
.
h
"
#
include
"
nsGtkUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIGSettingsService
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsImageToPixbuf
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIUserIdleServiceInternal
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsShmImage
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsXPLookAndFeel
.
h
"
#
include
"
prlink
.
h
"
#
include
"
ScreenHelperGTK
.
h
"
#
include
"
SystemTimeConverter
.
h
"
#
include
"
WidgetUtilsGtk
.
h
"
#
include
"
mozilla
/
X11Util
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
LocalAccessible
.
h
"
#
include
"
mozilla
/
a11y
/
Platform
.
h
"
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
ifdef
MOZ_X11
#
include
<
gdk
/
gdkkeysyms
-
compat
.
h
>
#
include
<
X11
/
Xatom
.
h
>
#
include
<
X11
/
extensions
/
XShm
.
h
>
#
include
<
X11
/
extensions
/
shape
.
h
>
#
include
"
gfxXlibSurface
.
h
"
#
include
"
GLContextGLX
.
h
"
#
include
"
GLContextEGL
.
h
"
#
include
"
WindowSurfaceX11Image
.
h
"
#
include
"
WindowSurfaceX11SHM
.
h
"
#
endif
#
ifdef
MOZ_WAYLAND
#
include
"
nsIClipboard
.
h
"
#
include
"
nsView
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
mozilla
:
:
gl
:
:
GLContextEGL
;
using
mozilla
:
:
gl
:
:
GLContextGLX
;
#
define
MAX_RECTS_IN_REGION
100
#
if
!
GTK_CHECK_VERSION
(
3
18
0
)
struct
_GdkEventTouchpadPinch
{
GdkEventType
type
;
GdkWindow
*
window
;
gint8
send_event
;
gint8
phase
;
gint8
n_fingers
;
guint32
time
;
gdouble
x
;
gdouble
y
;
gdouble
dx
;
gdouble
dy
;
gdouble
angle_delta
;
gdouble
scale
;
gdouble
x_root
y_root
;
guint
state
;
}
;
typedef
enum
{
GDK_TOUCHPAD_GESTURE_PHASE_BEGIN
GDK_TOUCHPAD_GESTURE_PHASE_UPDATE
GDK_TOUCHPAD_GESTURE_PHASE_END
GDK_TOUCHPAD_GESTURE_PHASE_CANCEL
}
GdkTouchpadGesturePhase
;
GdkEventMask
GDK_TOUCHPAD_GESTURE_MASK
=
static_cast
<
GdkEventMask
>
(
1
<
<
24
)
;
GdkEventType
GDK_TOUCHPAD_PINCH
=
static_cast
<
GdkEventType
>
(
42
)
;
#
endif
const
gint
kEvents
=
GDK_TOUCHPAD_GESTURE_MASK
|
GDK_EXPOSURE_MASK
|
GDK_STRUCTURE_MASK
|
GDK_VISIBILITY_NOTIFY_MASK
|
GDK_ENTER_NOTIFY_MASK
|
GDK_LEAVE_NOTIFY_MASK
|
GDK_BUTTON_PRESS_MASK
|
GDK_BUTTON_RELEASE_MASK
|
GDK_SMOOTH_SCROLL_MASK
|
GDK_TOUCH_MASK
|
GDK_SCROLL_MASK
|
GDK_POINTER_MOTION_MASK
|
GDK_PROPERTY_CHANGE_MASK
;
#
if
!
GTK_CHECK_VERSION
(
3
22
0
)
typedef
enum
{
GDK_ANCHOR_FLIP_X
=
1
<
<
0
GDK_ANCHOR_FLIP_Y
=
1
<
<
1
GDK_ANCHOR_SLIDE_X
=
1
<
<
2
GDK_ANCHOR_SLIDE_Y
=
1
<
<
3
GDK_ANCHOR_RESIZE_X
=
1
<
<
4
GDK_ANCHOR_RESIZE_Y
=
1
<
<
5
GDK_ANCHOR_FLIP
=
GDK_ANCHOR_FLIP_X
|
GDK_ANCHOR_FLIP_Y
GDK_ANCHOR_SLIDE
=
GDK_ANCHOR_SLIDE_X
|
GDK_ANCHOR_SLIDE_Y
GDK_ANCHOR_RESIZE
=
GDK_ANCHOR_RESIZE_X
|
GDK_ANCHOR_RESIZE_Y
}
GdkAnchorHints
;
#
endif
static
bool
is_mouse_in_window
(
GdkWindow
*
aWindow
gdouble
aMouseX
gdouble
aMouseY
)
;
static
nsWindow
*
get_window_for_gtk_widget
(
GtkWidget
*
widget
)
;
static
nsWindow
*
get_window_for_gdk_window
(
GdkWindow
*
window
)
;
static
GtkWidget
*
get_gtk_widget_for_gdk_window
(
GdkWindow
*
window
)
;
static
GdkCursor
*
get_gtk_cursor
(
nsCursor
aCursor
)
;
static
GdkWindow
*
get_inner_gdk_window
(
GdkWindow
*
aWindow
gint
x
gint
y
gint
*
retx
gint
*
rety
)
;
static
int
is_parent_ungrab_enter
(
GdkEventCrossing
*
aEvent
)
;
static
int
is_parent_grab_leave
(
GdkEventCrossing
*
aEvent
)
;
static
gboolean
expose_event_cb
(
GtkWidget
*
widget
cairo_t
*
cr
)
;
static
gboolean
configure_event_cb
(
GtkWidget
*
widget
GdkEventConfigure
*
event
)
;
static
void
widget_map_cb
(
GtkWidget
*
widget
)
;
static
void
widget_unrealize_cb
(
GtkWidget
*
widget
)
;
static
void
size_allocate_cb
(
GtkWidget
*
widget
GtkAllocation
*
allocation
)
;
static
void
toplevel_window_size_allocate_cb
(
GtkWidget
*
widget
GtkAllocation
*
allocation
)
;
static
gboolean
delete_event_cb
(
GtkWidget
*
widget
GdkEventAny
*
event
)
;
static
gboolean
enter_notify_event_cb
(
GtkWidget
*
widget
GdkEventCrossing
*
event
)
;
static
gboolean
leave_notify_event_cb
(
GtkWidget
*
widget
GdkEventCrossing
*
event
)
;
static
gboolean
motion_notify_event_cb
(
GtkWidget
*
widget
GdkEventMotion
*
event
)
;
MOZ_CAN_RUN_SCRIPT
static
gboolean
button_press_event_cb
(
GtkWidget
*
widget
GdkEventButton
*
event
)
;
static
gboolean
button_release_event_cb
(
GtkWidget
*
widget
GdkEventButton
*
event
)
;
static
gboolean
focus_in_event_cb
(
GtkWidget
*
widget
GdkEventFocus
*
event
)
;
static
gboolean
focus_out_event_cb
(
GtkWidget
*
widget
GdkEventFocus
*
event
)
;
static
gboolean
key_press_event_cb
(
GtkWidget
*
widget
GdkEventKey
*
event
)
;
static
gboolean
key_release_event_cb
(
GtkWidget
*
widget
GdkEventKey
*
event
)
;
static
gboolean
property_notify_event_cb
(
GtkWidget
*
widget
GdkEventProperty
*
event
)
;
static
gboolean
scroll_event_cb
(
GtkWidget
*
widget
GdkEventScroll
*
event
)
;
static
void
hierarchy_changed_cb
(
GtkWidget
*
widget
GtkWidget
*
previous_toplevel
)
;
static
gboolean
window_state_event_cb
(
GtkWidget
*
widget
GdkEventWindowState
*
event
)
;
static
void
settings_xft_dpi_changed_cb
(
GtkSettings
*
settings
GParamSpec
*
pspec
nsWindow
*
data
)
;
static
void
check_resize_cb
(
GtkContainer
*
container
gpointer
user_data
)
;
static
void
screen_composited_changed_cb
(
GdkScreen
*
screen
gpointer
user_data
)
;
static
void
widget_composited_changed_cb
(
GtkWidget
*
widget
gpointer
user_data
)
;
static
void
scale_changed_cb
(
GtkWidget
*
widget
GParamSpec
*
aPSpec
gpointer
aPointer
)
;
static
gboolean
touch_event_cb
(
GtkWidget
*
aWidget
GdkEventTouch
*
aEvent
)
;
static
gboolean
generic_event_cb
(
GtkWidget
*
widget
GdkEvent
*
aEvent
)
;
static
nsWindow
*
GetFirstNSWindowForGDKWindow
(
GdkWindow
*
aGdkWindow
)
;
#
ifdef
__cplusplus
extern
"
C
"
{
#
endif
#
ifdef
MOZ_X11
static
GdkFilterReturn
popup_take_focus_filter
(
GdkXEvent
*
gdk_xevent
GdkEvent
*
event
gpointer
data
)
;
#
endif
#
ifdef
__cplusplus
}
#
endif
static
gboolean
drag_motion_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
guint
aTime
gpointer
aData
)
;
static
void
drag_leave_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
guint
aTime
gpointer
aData
)
;
static
gboolean
drag_drop_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
guint
aTime
gpointer
aData
)
;
static
void
drag_data_received_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
;
static
nsresult
initialize_prefs
(
void
)
;
static
guint32
sLastUserInputTime
=
GDK_CURRENT_TIME
;
static
guint32
sRetryGrabTime
;
static
SystemTimeConverter
<
guint32
>
&
TimeConverter
(
)
{
static
SystemTimeConverter
<
guint32
>
sTimeConverterSingleton
;
return
sTimeConverterSingleton
;
}
bool
nsWindow
:
:
sTransparentMainWindow
=
false
;
namespace
mozilla
{
class
CurrentX11TimeGetter
{
public
:
explicit
CurrentX11TimeGetter
(
GdkWindow
*
aWindow
)
:
mWindow
(
aWindow
)
mAsyncUpdateStart
(
)
{
}
guint32
GetCurrentTime
(
)
const
{
return
gdk_x11_get_server_time
(
mWindow
)
;
}
void
GetTimeAsyncForPossibleBackwardsSkew
(
const
TimeStamp
&
aNow
)
{
if
(
!
mAsyncUpdateStart
.
IsNull
(
)
)
{
return
;
}
mAsyncUpdateStart
=
aNow
;
Display
*
xDisplay
=
GDK_WINDOW_XDISPLAY
(
mWindow
)
;
Window
xWindow
=
GDK_WINDOW_XID
(
mWindow
)
;
unsigned
char
c
=
'
a
'
;
Atom
timeStampPropAtom
=
TimeStampPropAtom
(
)
;
XChangeProperty
(
xDisplay
xWindow
timeStampPropAtom
timeStampPropAtom
8
PropModeReplace
&
c
1
)
;
XFlush
(
xDisplay
)
;
}
gboolean
PropertyNotifyHandler
(
GtkWidget
*
aWidget
GdkEventProperty
*
aEvent
)
{
if
(
aEvent
-
>
atom
!
=
gdk_x11_xatom_to_atom
(
TimeStampPropAtom
(
)
)
)
{
return
FALSE
;
}
guint32
eventTime
=
aEvent
-
>
time
;
TimeStamp
lowerBound
=
mAsyncUpdateStart
;
TimeConverter
(
)
.
CompensateForBackwardsSkew
(
eventTime
lowerBound
)
;
mAsyncUpdateStart
=
TimeStamp
(
)
;
return
TRUE
;
}
private
:
static
Atom
TimeStampPropAtom
(
)
{
return
gdk_x11_get_xatom_by_name_for_display
(
gdk_display_get_default
(
)
"
GDK_TIMESTAMP_PROP
"
)
;
}
GdkWindow
*
mWindow
;
TimeStamp
mAsyncUpdateStart
;
}
;
}
static
NS_DEFINE_IID
(
kCDragServiceCID
NS_DRAGSERVICE_CID
)
;
static
nsWindow
*
gFocusWindow
=
nullptr
;
static
bool
gBlockActivateEvent
=
false
;
static
bool
gGlobalsInitialized
=
false
;
static
bool
gRaiseWindows
=
true
;
static
bool
gTransparentWindows
=
true
;
static
bool
gUseMoveToRect
=
true
;
static
bool
gUseAspectRatio
=
true
;
static
uint32_t
gLastTouchID
=
0
;
#
define
NS_WINDOW_TITLE_MAX_LENGTH
4095
#
define
kWindowPositionSlop
20
static
GdkCursor
*
gCursorCache
[
eCursorCount
]
;
static
guint
gButtonState
;
static
inline
int32_t
GetBitmapStride
(
int32_t
width
)
{
#
if
defined
(
MOZ_X11
)
return
(
width
+
7
)
/
8
;
#
else
return
cairo_format_stride_for_width
(
CAIRO_FORMAT_A1
width
)
;
#
endif
}
static
inline
bool
TimestampIsNewerThan
(
guint32
a
guint32
b
)
{
return
a
-
b
<
=
G_MAXUINT32
/
2
;
}
static
void
UpdateLastInputEventTime
(
void
*
aGdkEvent
)
{
nsCOMPtr
<
nsIUserIdleServiceInternal
>
idleService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
useridleservice
;
1
"
)
;
if
(
idleService
)
{
idleService
-
>
ResetIdleTimeOut
(
0
)
;
}
guint
timestamp
=
gdk_event_get_time
(
static_cast
<
GdkEvent
*
>
(
aGdkEvent
)
)
;
if
(
timestamp
=
=
GDK_CURRENT_TIME
)
return
;
sLastUserInputTime
=
timestamp
;
}
void
GetWindowOrigin
(
GdkWindow
*
aWindow
int
*
aX
int
*
aY
)
{
*
aX
=
0
;
*
aY
=
0
;
if
(
aWindow
)
{
gdk_window_get_origin
(
aWindow
aX
aY
)
;
}
#
if
0
*
aX
=
0
;
*
aY
=
0
;
if
(
!
aWindow
)
{
return
;
}
GdkWindow
*
current
=
aWindow
;
while
(
GdkWindow
*
parent
=
gdk_window_get_parent
(
current
)
)
{
if
(
parent
=
=
current
)
{
break
;
}
int
x
=
0
;
int
y
=
0
;
gdk_window_get_position
(
current
&
x
&
y
)
;
*
aX
+
=
x
;
*
aY
+
=
y
;
current
=
parent
;
}
#
endif
}
nsWindow
:
:
nsWindow
(
)
:
mIsDestroyed
(
false
)
mNeedsDispatchResized
(
false
)
mIsShown
(
false
)
mNeedsShow
(
false
)
mIsMapped
(
false
)
mEnabled
(
true
)
mCreated
(
false
)
mHandleTouchEvent
(
false
)
mIsDragPopup
(
false
)
mPopupHint
(
)
mWindowScaleFactorChanged
(
true
)
mWindowScaleFactor
(
1
)
mCompositedScreen
(
gdk_screen_is_composited
(
gdk_screen_get_default
(
)
)
)
mIsAccelerated
(
false
)
mShell
(
nullptr
)
mContainer
(
nullptr
)
mGdkWindow
(
nullptr
)
mWindowShouldStartDragging
(
false
)
mCompositorWidgetDelegate
(
nullptr
)
mCompositorState
(
COMPOSITOR_ENABLED
)
mCompositorPauseTimeoutID
(
0
)
mHasMappedToplevel
(
false
)
mRetryPointerGrab
(
false
)
mSizeState
(
nsSizeMode_Normal
)
mAspectRatio
(
0
.
0f
)
mAspectRatioSaved
(
0
.
0f
)
mLastScrollEventTime
(
GDK_CURRENT_TIME
)
mPendingConfigures
(
0
)
mGtkWindowDecoration
(
GTK_DECORATION_NONE
)
mDrawToContainer
(
false
)
mDrawInTitlebar
(
false
)
mTitlebarBackdropState
(
false
)
mIsPIPWindow
(
false
)
mIsWaylandPanelWindow
(
false
)
mIsChildWindow
(
false
)
mAlwaysOnTop
(
false
)
mNoAutoHide
(
false
)
mMouseTransparent
(
false
)
mIsTransparent
(
false
)
mTransparencyBitmap
(
nullptr
)
mTransparencyBitmapWidth
(
0
)
mTransparencyBitmapHeight
(
0
)
mTransparencyBitmapForTitlebar
(
false
)
mHasAlphaVisual
(
false
)
mLastMotionPressure
(
0
)
mLastSizeMode
(
nsSizeMode_Normal
)
mBoundsAreValid
(
true
)
mPopupTrackInHierarchy
(
false
)
mPopupTrackInHierarchyConfigured
(
false
)
mHiddenPopupPositioned
(
false
)
mPopupPosition
(
)
mPopupAnchored
(
false
)
mPopupContextMenu
(
false
)
mRelativePopupPosition
(
)
mRelativePopupOffset
(
)
mPopupMatchesLayout
(
false
)
mPopupChanged
(
false
)
mPopupTemporaryHidden
(
false
)
mPopupClosed
(
false
)
mPopupUseMoveToRect
(
false
)
mPopupLastAnchor
(
)
mPreferredPopupRect
(
)
mPreferredPopupRectFlushed
(
false
)
mWaitingForMoveToRectCallback
(
false
)
mNewBoundsAfterMoveToRect
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
#
ifdef
ACCESSIBILITY
mRootAccessible
(
nullptr
)
#
endif
#
ifdef
MOZ_WAYLAND
mNativePointerLockCenter
(
LayoutDeviceIntPoint
(
)
)
mLockedPointer
(
nullptr
)
mRelativePointer
(
nullptr
)
mXdgToken
(
nullptr
)
#
endif
{
mWindowType
=
eWindowType_child
;
mSizeConstraints
.
mMaxSize
=
GetSafeWindowSize
(
mSizeConstraints
.
mMaxSize
)
;
if
(
!
gGlobalsInitialized
)
{
gGlobalsInitialized
=
true
;
initialize_prefs
(
)
;
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
)
;
NS_ASSERTION
(
clipboard
"
Failed
to
init
clipboard
!
"
)
;
}
#
endif
}
}
nsWindow
:
:
~
nsWindow
(
)
{
LOG
(
"
nsWindow
:
:
~
nsWindow
(
)
"
)
;
delete
[
]
mTransparencyBitmap
;
mTransparencyBitmap
=
nullptr
;
Destroy
(
)
;
}
void
nsWindow
:
:
ReleaseGlobals
(
)
{
for
(
auto
&
cursor
:
gCursorCache
)
{
if
(
cursor
)
{
g_object_unref
(
cursor
)
;
cursor
=
nullptr
;
}
}
}
void
nsWindow
:
:
DispatchActivateEvent
(
void
)
{
NS_ASSERTION
(
mContainer
|
|
mIsDestroyed
"
DispatchActivateEvent
only
intended
for
container
windows
"
)
;
#
ifdef
ACCESSIBILITY
DispatchActivateEventAccessible
(
)
;
#
endif
if
(
mWidgetListener
)
mWidgetListener
-
>
WindowActivated
(
)
;
}
void
nsWindow
:
:
DispatchDeactivateEvent
(
void
)
{
if
(
mWidgetListener
)
mWidgetListener
-
>
WindowDeactivated
(
)
;
#
ifdef
ACCESSIBILITY
DispatchDeactivateEventAccessible
(
)
;
#
endif
}
void
nsWindow
:
:
DispatchResized
(
)
{
LOG
(
"
nsWindow
:
:
DispatchResized
(
)
size
[
%
d
%
d
]
"
(
int
)
(
mBounds
.
width
)
(
int
)
(
mBounds
.
height
)
)
;
mNeedsDispatchResized
=
false
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowResized
(
this
mBounds
.
width
mBounds
.
height
)
;
}
if
(
mAttachedWidgetListener
)
{
mAttachedWidgetListener
-
>
WindowResized
(
this
mBounds
.
width
mBounds
.
height
)
;
}
}
void
nsWindow
:
:
MaybeDispatchResized
(
)
{
if
(
mNeedsDispatchResized
&
&
!
mIsDestroyed
)
{
DispatchResized
(
)
;
}
}
nsIWidgetListener
*
nsWindow
:
:
GetListener
(
)
{
return
mAttachedWidgetListener
?
mAttachedWidgetListener
:
mWidgetListener
;
}
nsresult
nsWindow
:
:
DispatchEvent
(
WidgetGUIEvent
*
aEvent
nsEventStatus
&
aStatus
)
{
#
ifdef
DEBUG
debug_DumpEvent
(
stdout
aEvent
-
>
mWidget
aEvent
"
something
"
0
)
;
#
endif
aStatus
=
nsEventStatus_eIgnore
;
nsIWidgetListener
*
listener
=
GetListener
(
)
;
if
(
listener
)
{
aStatus
=
listener
-
>
HandleEvent
(
aEvent
mUseAttachedEvents
)
;
}
return
NS_OK
;
}
void
nsWindow
:
:
OnDestroy
(
void
)
{
if
(
mOnDestroyCalled
)
return
;
mOnDestroyCalled
=
true
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
=
this
;
nsBaseWidget
:
:
OnDestroy
(
)
;
nsBaseWidget
:
:
Destroy
(
)
;
mParent
=
nullptr
;
NotifyWindowDestroyed
(
)
;
}
bool
nsWindow
:
:
AreBoundsSane
(
)
{
return
mBounds
.
width
>
0
&
&
mBounds
.
height
>
0
;
}
void
nsWindow
:
:
DestroyChildWindows
(
)
{
LOG
(
"
nsWindow
:
:
DestroyChildWindows
(
)
"
)
;
if
(
!
mGdkWindow
)
{
return
;
}
while
(
GList
*
children
=
gdk_window_peek_children
(
mGdkWindow
)
)
{
GdkWindow
*
child
=
GDK_WINDOW
(
children
-
>
data
)
;
nsWindow
*
kid
=
get_window_for_gdk_window
(
child
)
;
if
(
kid
)
{
kid
-
>
Destroy
(
)
;
}
}
}
void
nsWindow
:
:
Destroy
(
)
{
if
(
mIsDestroyed
|
|
!
mCreated
)
return
;
LOG
(
"
nsWindow
:
:
Destroy
\
n
"
)
;
RevokeTransactionIdAllocator
(
)
;
DisableRenderingToWindow
(
)
;
mIsDestroyed
=
true
;
mCreated
=
false
;
if
(
mWindowRenderer
)
{
mWindowRenderer
-
>
Destroy
(
)
;
}
mWindowRenderer
=
nullptr
;
#
ifdef
MOZ_WAYLAND
if
(
mWaylandVsyncSource
)
{
mWaylandVsyncSource
-
>
Shutdown
(
)
;
mWaylandVsyncSource
=
nullptr
;
}
g_clear_pointer
(
&
mXdgToken
xdg_activation_token_v1_destroy
)
;
#
endif
if
(
mCompositorPauseTimeoutID
)
{
g_source_remove
(
mCompositorPauseTimeoutID
)
;
mCompositorPauseTimeoutID
=
0
;
}
DestroyCompositor
(
)
;
mSurfaceProvider
.
CleanupResources
(
)
;
g_signal_handlers_disconnect_by_data
(
gtk_settings_get_default
(
)
this
)
;
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
if
(
rollupListener
)
{
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
static_cast
<
nsIWidget
*
>
(
this
)
=
=
rollupWidget
)
{
rollupListener
-
>
Rollup
(
0
false
nullptr
nullptr
)
;
}
}
RefPtr
<
nsDragService
>
dragService
=
nsDragService
:
:
GetInstance
(
)
;
if
(
dragService
&
&
this
=
=
dragService
-
>
GetMostRecentDestWindow
(
)
)
{
dragService
-
>
ScheduleLeaveEvent
(
)
;
}
NativeShow
(
false
)
;
if
(
mIMContext
)
{
mIMContext
-
>
OnDestroyWindow
(
this
)
;
}
if
(
gFocusWindow
=
=
this
)
{
LOG
(
"
automatically
losing
focus
.
.
.
\
n
"
)
;
gFocusWindow
=
nullptr
;
}
gtk_widget_destroy
(
mShell
)
;
mShell
=
nullptr
;
mContainer
=
nullptr
;
MOZ_ASSERT
(
!
mGdkWindow
"
mGdkWindow
should
be
NULL
when
mContainer
is
destroyed
"
)
;
#
ifdef
ACCESSIBILITY
if
(
mRootAccessible
)
{
mRootAccessible
=
nullptr
;
}
#
endif
OnDestroy
(
)
;
}
nsIWidget
*
nsWindow
:
:
GetParent
(
void
)
{
return
mParent
;
}
float
nsWindow
:
:
GetDPI
(
)
{
float
dpi
=
96
.
0f
;
nsCOMPtr
<
nsIScreen
>
screen
=
GetWidgetScreen
(
)
;
if
(
screen
)
{
screen
-
>
GetDpi
(
&
dpi
)
;
}
return
dpi
;
}
double
nsWindow
:
:
GetDefaultScaleInternal
(
)
{
return
FractionalScaleFactor
(
)
*
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
}
DesktopToLayoutDeviceScale
nsWindow
:
:
GetDesktopToDeviceScale
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
return
DesktopToLayoutDeviceScale
(
GdkCeiledScaleFactor
(
)
)
;
}
#
endif
return
DesktopToLayoutDeviceScale
(
1
.
0
)
;
}
DesktopToLayoutDeviceScale
nsWindow
:
:
GetDesktopToDeviceScaleByScreen
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
nsView
*
view
=
nsView
:
:
GetViewFor
(
this
)
;
if
(
view
)
{
nsView
*
parentView
=
view
-
>
GetParent
(
)
;
if
(
parentView
)
{
nsIWidget
*
parentWidget
=
parentView
-
>
GetNearestWidget
(
nullptr
)
;
if
(
parentWidget
)
{
return
DesktopToLayoutDeviceScale
(
parentWidget
-
>
RoundsWidgetCoordinatesTo
(
)
)
;
}
NS_WARNING
(
"
Widget
has
no
parent
"
)
;
}
}
else
{
NS_WARNING
(
"
Cannot
find
widget
view
"
)
;
}
}
#
endif
return
nsBaseWidget
:
:
GetDesktopToDeviceScale
(
)
;
}
void
nsWindow
:
:
SetParent
(
nsIWidget
*
aNewParent
)
{
LOG
(
"
nsWindow
:
:
SetParent
(
)
new
parent
%
p
"
aNewParent
)
;
if
(
!
mIsChildWindow
)
{
NS_WARNING
(
"
Used
by
child
widgets
only
"
)
;
return
;
}
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
=
this
;
if
(
mParent
)
{
mParent
-
>
RemoveChild
(
this
)
;
}
mParent
=
aNewParent
;
if
(
!
mGdkWindow
|
|
mIsDestroyed
|
|
!
aNewParent
)
{
return
;
}
aNewParent
-
>
AddChild
(
this
)
;
auto
*
newParent
=
static_cast
<
nsWindow
*
>
(
aNewParent
)
;
if
(
newParent
-
>
mIsDestroyed
)
{
Destroy
(
)
;
return
;
}
GdkWindow
*
window
=
GetToplevelGdkWindow
(
)
;
GdkWindow
*
parentWindow
=
newParent
-
>
GetToplevelGdkWindow
(
)
;
LOG
(
"
child
GdkWindow
%
p
set
parent
GdkWindow
%
p
"
window
parentWindow
)
;
gdk_window_reparent
(
window
parentWindow
0
0
)
;
bool
parentHasMappedToplevel
=
newParent
&
&
newParent
-
>
mHasMappedToplevel
;
if
(
mHasMappedToplevel
!
=
parentHasMappedToplevel
)
{
SetHasMappedToplevel
(
parentHasMappedToplevel
)
;
}
}
bool
nsWindow
:
:
WidgetTypeSupportsAcceleration
(
)
{
if
(
mWindowType
=
=
eWindowType_invisible
)
{
return
false
;
}
if
(
IsSmallPopup
(
)
)
{
return
false
;
}
if
(
mWindowType
=
=
eWindowType_popup
)
{
return
HasRemoteContent
(
)
&
&
mCompositedScreen
;
}
return
true
;
}
void
nsWindow
:
:
ReparentNativeWidget
(
nsIWidget
*
aNewParent
)
{
MOZ_ASSERT
(
aNewParent
"
null
widget
"
)
;
MOZ_ASSERT
(
!
mIsDestroyed
"
"
)
;
MOZ_ASSERT
(
!
static_cast
<
nsWindow
*
>
(
aNewParent
)
-
>
mIsDestroyed
"
"
)
;
MOZ_ASSERT
(
!
mParent
"
nsWindow
:
:
ReparentNativeWidget
(
)
works
on
toplevel
windows
only
.
"
)
;
auto
*
newParent
=
static_cast
<
nsWindow
*
>
(
aNewParent
)
;
GtkWindow
*
newParentWidget
=
GTK_WINDOW
(
newParent
-
>
GetGtkWidget
(
)
)
;
LOG
(
"
nsWindow
:
:
ReparentNativeWidget
new
parent
%
p
\
n
"
newParent
)
;
gtk_window_set_transient_for
(
GTK_WINDOW
(
mShell
)
newParentWidget
)
;
}
void
nsWindow
:
:
SetModal
(
bool
aModal
)
{
LOG
(
"
nsWindow
:
:
SetModal
%
d
\
n
"
aModal
)
;
if
(
mIsDestroyed
)
return
;
gtk_window_set_modal
(
GTK_WINDOW
(
mShell
)
aModal
?
TRUE
:
FALSE
)
;
}
bool
nsWindow
:
:
IsVisible
(
)
const
{
return
mIsShown
;
}
void
nsWindow
:
:
RegisterTouchWindow
(
)
{
mHandleTouchEvent
=
true
;
mTouches
.
Clear
(
)
;
}
void
nsWindow
:
:
ConstrainPosition
(
bool
aAllowSlop
int32_t
*
aX
int32_t
*
aY
)
{
if
(
!
mShell
|
|
GdkIsWaylandDisplay
(
)
)
{
return
;
}
double
dpiScale
=
GetDefaultScale
(
)
.
scale
;
int32_t
logWidth
=
std
:
:
max
(
NSToIntRound
(
mBounds
.
width
/
dpiScale
)
1
)
;
int32_t
logHeight
=
std
:
:
max
(
NSToIntRound
(
mBounds
.
height
/
dpiScale
)
1
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenmgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenmgr
)
{
screenmgr
-
>
ScreenForRect
(
*
aX
*
aY
logWidth
logHeight
getter_AddRefs
(
screen
)
)
;
}
if
(
!
screen
)
return
;
nsIntRect
screenRect
;
if
(
mSizeMode
!
=
nsSizeMode_Fullscreen
)
{
screen
-
>
GetAvailRectDisplayPix
(
&
screenRect
.
x
&
screenRect
.
y
&
screenRect
.
width
&
screenRect
.
height
)
;
}
else
{
screen
-
>
GetRectDisplayPix
(
&
screenRect
.
x
&
screenRect
.
y
&
screenRect
.
width
&
screenRect
.
height
)
;
}
if
(
aAllowSlop
)
{
if
(
*
aX
<
screenRect
.
x
-
logWidth
+
kWindowPositionSlop
)
{
*
aX
=
screenRect
.
x
-
logWidth
+
kWindowPositionSlop
;
}
else
if
(
*
aX
>
=
screenRect
.
XMost
(
)
-
kWindowPositionSlop
)
{
*
aX
=
screenRect
.
XMost
(
)
-
kWindowPositionSlop
;
}
if
(
*
aY
<
screenRect
.
y
-
logHeight
+
kWindowPositionSlop
)
{
*
aY
=
screenRect
.
y
-
logHeight
+
kWindowPositionSlop
;
}
else
if
(
*
aY
>
=
screenRect
.
YMost
(
)
-
kWindowPositionSlop
)
{
*
aY
=
screenRect
.
YMost
(
)
-
kWindowPositionSlop
;
}
}
else
{
if
(
*
aX
<
screenRect
.
x
)
{
*
aX
=
screenRect
.
x
;
}
else
if
(
*
aX
>
=
screenRect
.
XMost
(
)
-
logWidth
)
{
*
aX
=
screenRect
.
XMost
(
)
-
logWidth
;
}
if
(
*
aY
<
screenRect
.
y
)
{
*
aY
=
screenRect
.
y
;
}
else
if
(
*
aY
>
=
screenRect
.
YMost
(
)
-
logHeight
)
{
*
aY
=
screenRect
.
YMost
(
)
-
logHeight
;
}
}
}
void
nsWindow
:
:
SetSizeConstraints
(
const
SizeConstraints
&
aConstraints
)
{
mSizeConstraints
.
mMinSize
=
GetSafeWindowSize
(
aConstraints
.
mMinSize
)
;
mSizeConstraints
.
mMaxSize
=
GetSafeWindowSize
(
aConstraints
.
mMaxSize
)
;
ApplySizeConstraints
(
)
;
}
void
nsWindow
:
:
AddCSDDecorationSize
(
int
*
aWidth
int
*
aHeight
)
{
if
(
mSizeState
=
=
nsSizeMode_Normal
&
&
mGtkWindowDecoration
=
=
GTK_DECORATION_CLIENT
&
&
mDrawInTitlebar
)
{
GtkBorder
decorationSize
=
GetCSDDecorationSize
(
IsPopup
(
)
)
;
*
aWidth
+
=
decorationSize
.
left
+
decorationSize
.
right
;
*
aHeight
+
=
decorationSize
.
top
+
decorationSize
.
bottom
;
}
}
#
ifdef
MOZ_WAYLAND
bool
nsWindow
:
:
GetCSDDecorationOffset
(
int
*
aDx
int
*
aDy
)
{
if
(
mSizeState
=
=
nsSizeMode_Normal
&
&
mGtkWindowDecoration
=
=
GTK_DECORATION_CLIENT
&
&
mDrawInTitlebar
)
{
GtkBorder
decorationSize
=
GetCSDDecorationSize
(
IsPopup
(
)
)
;
*
aDx
=
decorationSize
.
left
;
*
aDy
=
decorationSize
.
top
;
return
true
;
}
return
false
;
}
#
endif
void
nsWindow
:
:
ApplySizeConstraints
(
void
)
{
if
(
mShell
)
{
GdkGeometry
geometry
;
geometry
.
min_width
=
DevicePixelsToGdkCoordRoundUp
(
mSizeConstraints
.
mMinSize
.
width
)
;
geometry
.
min_height
=
DevicePixelsToGdkCoordRoundUp
(
mSizeConstraints
.
mMinSize
.
height
)
;
geometry
.
max_width
=
DevicePixelsToGdkCoordRoundDown
(
mSizeConstraints
.
mMaxSize
.
width
)
;
geometry
.
max_height
=
DevicePixelsToGdkCoordRoundDown
(
mSizeConstraints
.
mMaxSize
.
height
)
;
uint32_t
hints
=
0
;
if
(
mSizeConstraints
.
mMinSize
!
=
LayoutDeviceIntSize
(
0
0
)
)
{
if
(
GdkIsWaylandDisplay
(
)
)
{
gtk_widget_set_size_request
(
GTK_WIDGET
(
mContainer
)
geometry
.
min_width
geometry
.
min_height
)
;
}
AddCSDDecorationSize
(
&
geometry
.
min_width
&
geometry
.
min_height
)
;
hints
|
=
GDK_HINT_MIN_SIZE
;
}
if
(
mSizeConstraints
.
mMaxSize
!
=
LayoutDeviceIntSize
(
NS_MAXSIZE
NS_MAXSIZE
)
)
{
AddCSDDecorationSize
(
&
geometry
.
max_width
&
geometry
.
max_height
)
;
hints
|
=
GDK_HINT_MAX_SIZE
;
}
if
(
mAspectRatio
!
=
0
.
0f
)
{
geometry
.
min_aspect
=
mAspectRatio
;
geometry
.
max_aspect
=
mAspectRatio
;
hints
|
=
GDK_HINT_ASPECT
;
}
gtk_window_set_geometry_hints
(
GTK_WINDOW
(
mShell
)
nullptr
&
geometry
GdkWindowHints
(
hints
)
)
;
}
}
void
nsWindow
:
:
Show
(
bool
aState
)
{
if
(
aState
=
=
mIsShown
)
return
;
mIsShown
=
aState
;
LOG
(
"
nsWindow
:
:
Show
state
%
d
frame
%
s
\
n
"
aState
GetFrameTag
(
)
.
get
(
)
)
;
if
(
aState
)
{
SetHasMappedToplevel
(
mHasMappedToplevel
)
;
}
if
(
(
aState
&
&
!
AreBoundsSane
(
)
)
|
|
!
mCreated
)
{
LOG
(
"
\
tbounds
are
insane
or
window
hasn
'
t
been
created
yet
\
n
"
)
;
mNeedsShow
=
true
;
return
;
}
if
(
!
aState
)
mNeedsShow
=
false
;
#
ifdef
ACCESSIBILITY
if
(
aState
&
&
a11y
:
:
ShouldA11yBeEnabled
(
)
)
CreateRootAccessible
(
)
;
#
endif
NativeShow
(
aState
)
;
}
void
nsWindow
:
:
ResizeInt
(
int
aX
int
aY
int
aWidth
int
aHeight
bool
aMove
bool
aRepaint
)
{
LOG
(
"
nsWindow
:
:
ResizeInt
x
:
%
d
y
:
%
d
-
>
w
:
%
d
h
:
%
d
repaint
%
d
aMove
%
d
\
n
"
aX
aY
aWidth
aHeight
aRepaint
aMove
)
;
ConstrainSize
(
&
aWidth
&
aHeight
)
;
LOG
(
"
ConstrainSize
:
w
:
%
d
h
;
%
d
\
n
"
aWidth
aHeight
)
;
if
(
aMove
)
{
mBounds
.
x
=
aX
;
mBounds
.
y
=
aY
;
}
if
(
!
aMove
&
&
!
AreBoundsSane
(
)
&
&
IsWaylandPopup
(
)
)
{
aMove
=
true
;
}
if
(
mPreferredPopupRectFlushed
)
{
aMove
=
true
;
}
mBounds
.
SizeTo
(
aWidth
aHeight
)
;
mBoundsAreValid
=
true
;
if
(
mAspectRatio
!
=
0
.
0
)
{
LockAspectRatio
(
true
)
;
}
if
(
!
mCreated
)
{
return
;
}
NativeMoveResize
(
aMove
true
)
;
NotifyRollupGeometryChange
(
)
;
DispatchResized
(
)
;
}
void
nsWindow
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
LOG
(
"
nsWindow
:
:
Resize
%
f
%
f
\
n
"
aWidth
aHeight
)
;
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
int32_t
width
=
NSToIntRound
(
scale
*
aWidth
)
;
int32_t
height
=
NSToIntRound
(
scale
*
aHeight
)
;
ResizeInt
(
0
0
width
height
false
aRepaint
)
;
}
void
nsWindow
:
:
Resize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
)
{
LOG
(
"
nsWindow
:
:
Resize
[
%
f
%
f
]
-
>
[
%
f
x
%
f
]
repaint
%
d
\
n
"
aX
aY
aWidth
aHeight
aRepaint
)
;
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
int32_t
width
=
NSToIntRound
(
scale
*
aWidth
)
;
int32_t
height
=
NSToIntRound
(
scale
*
aHeight
)
;
int32_t
x
=
NSToIntRound
(
scale
*
aX
)
;
int32_t
y
=
NSToIntRound
(
scale
*
aY
)
;
ResizeInt
(
x
y
width
height
true
aRepaint
)
;
}
void
nsWindow
:
:
Enable
(
bool
aState
)
{
mEnabled
=
aState
;
}
bool
nsWindow
:
:
IsEnabled
(
)
const
{
return
mEnabled
;
}
void
nsWindow
:
:
Move
(
double
aX
double
aY
)
{
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
int32_t
x
=
NSToIntRound
(
aX
*
scale
)
;
int32_t
y
=
NSToIntRound
(
aY
*
scale
)
;
LOG
(
"
nsWindow
:
:
Move
to
%
d
%
d
\
n
"
x
y
)
;
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
{
SetSizeMode
(
nsSizeMode_Normal
)
;
}
LOG
(
"
bounds
%
d
%
d
\
n
"
mBounds
.
y
mBounds
.
y
)
;
if
(
x
=
=
mBounds
.
x
&
&
y
=
=
mBounds
.
y
&
&
mWindowType
!
=
eWindowType_popup
)
{
LOG
(
"
position
is
the
same
return
\
n
"
)
;
return
;
}
mBounds
.
x
=
x
;
mBounds
.
y
=
y
;
if
(
!
mCreated
)
{
LOG
(
"
is
not
created
return
.
\
n
"
)
;
return
;
}
if
(
IsWaylandPopup
(
)
)
{
int32_t
p2a
=
AppUnitsPerCSSPixel
(
)
/
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
if
(
mPreferredPopupRect
.
x
!
=
mBounds
.
x
*
p2a
&
&
mPreferredPopupRect
.
y
!
=
mBounds
.
y
*
p2a
)
{
NativeMoveResize
(
true
false
)
;
NotifyRollupGeometryChange
(
)
;
}
else
{
LOG
(
"
mBounds
same
as
mPreferredPopupRect
no
need
to
move
"
)
;
}
}
else
{
NativeMoveResize
(
true
false
)
;
NotifyRollupGeometryChange
(
)
;
}
}
bool
nsWindow
:
:
IsPopup
(
)
const
{
return
mWindowType
=
=
eWindowType_popup
;
}
bool
nsWindow
:
:
IsWaylandPopup
(
)
const
{
return
GdkIsWaylandDisplay
(
)
&
&
IsPopup
(
)
;
}
static
nsMenuPopupFrame
*
GetMenuPopupFrame
(
nsIFrame
*
aFrame
)
{
return
do_QueryFrame
(
aFrame
)
;
}
void
nsWindow
:
:
AppendPopupToHierarchyList
(
nsWindow
*
aToplevelWindow
)
{
mWaylandToplevel
=
aToplevelWindow
;
nsWindow
*
popup
=
aToplevelWindow
;
while
(
popup
&
&
popup
-
>
mWaylandPopupNext
)
{
popup
=
popup
-
>
mWaylandPopupNext
;
}
popup
-
>
mWaylandPopupNext
=
this
;
mWaylandPopupPrev
=
popup
;
mWaylandPopupNext
=
nullptr
;
mPopupChanged
=
true
;
mPopupClosed
=
false
;
}
void
nsWindow
:
:
RemovePopupFromHierarchyList
(
)
{
if
(
!
IsInPopupHierarchy
(
)
)
{
return
;
}
mWaylandPopupPrev
-
>
mWaylandPopupNext
=
mWaylandPopupNext
;
if
(
mWaylandPopupNext
)
{
mWaylandPopupNext
-
>
mWaylandPopupPrev
=
mWaylandPopupPrev
;
mWaylandPopupNext
-
>
mPopupChanged
=
true
;
}
mWaylandPopupNext
=
mWaylandPopupPrev
=
nullptr
;
}
void
nsWindow
:
:
HideWaylandWindow
(
)
{
LOG
(
"
nsWindow
:
:
HideWaylandWindow
:
[
%
p
]
\
n
"
this
)
;
PauseCompositorHiddenWindow
(
)
;
gtk_widget_hide
(
mShell
)
;
}
bool
nsWindow
:
:
WaylandPopupRemoveNegativePosition
(
int
*
aX
int
*
aY
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupRemoveNegativePosition
(
)
[
%
p
]
\
n
"
this
)
;
int
x
y
;
GdkWindow
*
window
=
gtk_widget_get_window
(
mShell
)
;
gdk_window_get_origin
(
window
&
x
&
y
)
;
if
(
x
>
=
0
|
|
y
>
=
0
)
{
LOG
(
"
coordinates
are
correct
"
)
;
return
false
;
}
LOG
(
"
wrong
coord
(
%
d
%
d
)
move
to
0
0
"
x
y
)
;
gdk_window_move
(
window
0
0
)
;
if
(
aX
)
{
*
aX
=
x
;
}
if
(
aY
)
{
*
aY
=
y
;
}
return
true
;
}
void
nsWindow
:
:
ShowWaylandWindow
(
)
{
LOG
(
"
nsWindow
:
:
ShowWaylandWindow
:
[
%
p
]
\
n
"
this
)
;
if
(
!
IsWaylandPopup
(
)
)
{
LOG
(
"
toplevel
show
it
now
"
)
;
gtk_widget_show
(
mShell
)
;
return
;
}
if
(
!
mPopupTrackInHierarchy
)
{
LOG
(
"
popup
is
not
tracked
in
popup
hierarchy
show
it
now
"
)
;
gtk_widget_show
(
mShell
)
;
return
;
}
if
(
mPopupUseMoveToRect
&
&
mWaitingForMoveToRectCallback
)
{
LOG
(
"
active
move
-
to
-
rect
callback
show
it
as
is
"
)
;
gtk_widget_show
(
mShell
)
;
return
;
}
if
(
gtk_widget_is_visible
(
mShell
)
)
{
LOG
(
"
is
already
visible
quit
"
)
;
return
;
}
int
x
y
;
bool
moved
=
WaylandPopupRemoveNegativePosition
(
&
x
&
y
)
;
gtk_widget_show
(
mShell
)
;
if
(
moved
)
{
LOG
(
"
move
back
to
(
%
d
%
d
)
and
show
"
x
y
)
;
gdk_window_move
(
gtk_widget_get_window
(
mShell
)
x
y
)
;
}
}
void
nsWindow
:
:
WaylandPopupMarkAsClosed
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupMarkAsClosed
:
[
%
p
]
\
n
"
this
)
;
mPopupClosed
=
true
;
if
(
mWaylandPopupNext
)
{
mWaylandPopupNext
-
>
mPopupChanged
=
true
;
}
}
nsWindow
*
nsWindow
:
:
WaylandPopupFindLast
(
nsWindow
*
aPopup
)
{
while
(
aPopup
&
&
aPopup
-
>
mWaylandPopupNext
)
{
aPopup
=
aPopup
-
>
mWaylandPopupNext
;
}
return
aPopup
;
}
void
nsWindow
:
:
HideWaylandPopupWindow
(
bool
aTemporaryHide
bool
aRemoveFromPopupList
)
{
LOG
(
"
nsWindow
:
:
HideWaylandPopupWindow
:
remove
from
list
%
d
\
n
"
aRemoveFromPopupList
)
;
if
(
aRemoveFromPopupList
)
{
RemovePopupFromHierarchyList
(
)
;
}
if
(
!
mPopupClosed
)
{
mPopupClosed
=
!
aTemporaryHide
;
}
bool
visible
=
gtk_widget_is_visible
(
mShell
)
;
LOG
(
"
gtk_widget_is_visible
(
)
=
%
d
\
n
"
visible
)
;
mPopupTemporaryHidden
=
aTemporaryHide
&
&
visible
;
if
(
visible
)
{
HideWaylandWindow
(
)
;
mWaitingForMoveToRectCallback
=
false
;
}
if
(
mPopupClosed
)
{
RevokeTransactionIdAllocator
(
)
;
}
}
void
nsWindow
:
:
HideWaylandToplevelWindow
(
)
{
LOG
(
"
nsWindow
:
:
HideWaylandToplevelWindow
:
[
%
p
]
\
n
"
this
)
;
if
(
mWaylandPopupNext
)
{
nsWindow
*
popup
=
WaylandPopupFindLast
(
mWaylandPopupNext
)
;
while
(
popup
-
>
mWaylandToplevel
!
=
nullptr
)
{
nsWindow
*
prev
=
popup
-
>
mWaylandPopupPrev
;
popup
-
>
HideWaylandPopupWindow
(
false
true
)
;
popup
=
prev
;
}
}
HideWaylandWindow
(
)
;
}
void
nsWindow
:
:
WaylandPopupRemoveClosedPopups
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupRemoveClosedPopups
:
[
%
p
]
\
n
"
this
)
;
nsWindow
*
popup
=
this
;
while
(
popup
)
{
nsWindow
*
next
=
popup
-
>
mWaylandPopupNext
;
if
(
popup
-
>
mPopupClosed
)
{
popup
-
>
HideWaylandPopupWindow
(
false
true
)
;
}
popup
=
next
;
}
}
void
nsWindow
:
:
WaylandPopupHideTooltips
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupHideTooltips
"
)
;
MOZ_ASSERT
(
mWaylandToplevel
=
=
nullptr
"
Should
be
called
on
toplevel
only
!
"
)
;
nsWindow
*
popup
=
mWaylandPopupNext
;
while
(
popup
&
&
popup
-
>
mWaylandPopupNext
)
{
if
(
popup
-
>
mPopupType
=
=
ePopupTypeTooltip
)
{
LOG
(
"
hidding
tooltip
[
%
p
]
"
popup
)
;
popup
-
>
WaylandPopupMarkAsClosed
(
)
;
}
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
void
nsWindow
:
:
CloseAllPopupsBeforeRemotePopup
(
)
{
LOG
(
"
nsWindow
:
:
CloseAllPopupsBeforeRemotePopup
"
)
;
MOZ_ASSERT
(
mWaylandToplevel
=
=
nullptr
"
Should
be
called
on
toplevel
only
!
"
)
;
if
(
!
mWaylandPopupNext
|
|
mWaylandPopupNext
-
>
mWaylandPopupNext
=
=
nullptr
)
{
return
;
}
nsWindow
*
remotePopup
=
mWaylandPopupNext
;
while
(
remotePopup
)
{
if
(
remotePopup
-
>
HasRemoteContent
(
)
|
|
remotePopup
-
>
IsWidgetOverflowWindow
(
)
)
{
LOG
(
"
remote
popup
[
%
p
]
"
remotePopup
)
;
break
;
}
remotePopup
=
remotePopup
-
>
mWaylandPopupNext
;
}
if
(
!
remotePopup
)
{
return
;
}
nsWindow
*
popup
=
mWaylandPopupNext
;
while
(
popup
&
&
popup
!
=
remotePopup
)
{
LOG
(
"
hidding
popup
[
%
p
]
"
popup
)
;
popup
-
>
WaylandPopupMarkAsClosed
(
)
;
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
static
void
GetLayoutPopupWidgetChain
(
nsTArray
<
nsIWidget
*
>
*
aLayoutWidgetHierarchy
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
pm
-
>
GetSubmenuWidgetChain
(
aLayoutWidgetHierarchy
)
;
aLayoutWidgetHierarchy
-
>
Reverse
(
)
;
}
bool
nsWindow
:
:
IsPopupInLayoutPopupChain
(
nsTArray
<
nsIWidget
*
>
*
aLayoutWidgetHierarchy
bool
aMustMatchParent
)
{
int
len
=
(
int
)
aLayoutWidgetHierarchy
-
>
Length
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
this
=
=
(
*
aLayoutWidgetHierarchy
)
[
i
]
)
{
if
(
!
aMustMatchParent
)
{
return
true
;
}
nsWindow
*
parentPopup
=
nullptr
;
if
(
mWaylandPopupPrev
!
=
mWaylandToplevel
)
{
parentPopup
=
mWaylandPopupPrev
;
while
(
parentPopup
!
=
mWaylandToplevel
&
&
parentPopup
-
>
mPopupClosed
)
{
parentPopup
=
parentPopup
-
>
mWaylandPopupPrev
;
}
}
if
(
i
=
=
0
)
{
return
parentPopup
=
=
nullptr
;
}
return
parentPopup
=
=
(
*
aLayoutWidgetHierarchy
)
[
i
-
1
]
;
}
}
return
false
;
}
void
nsWindow
:
:
WaylandPopupHierarchyHideByLayout
(
nsTArray
<
nsIWidget
*
>
*
aLayoutWidgetHierarchy
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupHierarchyHideByLayout
"
)
;
MOZ_ASSERT
(
mWaylandToplevel
=
=
nullptr
"
Should
be
called
on
toplevel
only
!
"
)
;
nsWindow
*
popup
=
mWaylandPopupNext
;
while
(
popup
)
{
if
(
!
popup
-
>
mPopupClosed
&
&
popup
-
>
mPopupType
!
=
ePopupTypeTooltip
)
{
if
(
!
popup
-
>
IsPopupInLayoutPopupChain
(
aLayoutWidgetHierarchy
false
)
)
{
LOG
(
"
hidding
popup
[
%
p
]
"
popup
)
;
popup
-
>
WaylandPopupMarkAsClosed
(
)
;
}
}
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
void
nsWindow
:
:
WaylandPopupHierarchyValidateByLayout
(
nsTArray
<
nsIWidget
*
>
*
aLayoutWidgetHierarchy
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupHierarchyValidateByLayout
"
)
;
nsWindow
*
popup
=
mWaylandPopupNext
;
while
(
popup
)
{
if
(
popup
-
>
mPopupType
=
=
ePopupTypeTooltip
)
{
popup
-
>
mPopupMatchesLayout
=
true
;
}
else
if
(
!
popup
-
>
mPopupClosed
)
{
popup
-
>
mPopupMatchesLayout
=
popup
-
>
IsPopupInLayoutPopupChain
(
aLayoutWidgetHierarchy
true
)
;
LOG
(
"
popup
[
%
p
]
parent
window
[
%
p
]
matches
layout
%
d
\
n
"
(
void
*
)
popup
(
void
*
)
popup
-
>
mWaylandPopupPrev
popup
-
>
mPopupMatchesLayout
)
;
}
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
void
nsWindow
:
:
WaylandPopupHierarchyHideTemporary
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupHierarchyHideTemporary
(
)
[
%
p
]
"
this
)
;
nsWindow
*
popup
=
WaylandPopupFindLast
(
this
)
;
while
(
popup
)
{
LOG
(
"
temporary
hidding
popup
[
%
p
]
"
popup
)
;
nsWindow
*
prev
=
popup
-
>
mWaylandPopupPrev
;
popup
-
>
HideWaylandPopupWindow
(
true
false
)
;
if
(
popup
=
=
this
)
{
break
;
}
popup
=
prev
;
}
}
void
nsWindow
:
:
WaylandPopupHierarchyShowTemporaryHidden
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupHierarchyShowTemporaryHidden
(
)
"
)
;
nsWindow
*
popup
=
this
;
while
(
popup
)
{
if
(
popup
-
>
mPopupTemporaryHidden
)
{
popup
-
>
mPopupTemporaryHidden
=
false
;
LOG
(
"
showing
temporary
hidden
popup
[
%
p
]
"
popup
)
;
popup
-
>
ShowWaylandWindow
(
)
;
}
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
void
nsWindow
:
:
WaylandPopupHierarchyCalculatePositions
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupHierarchyCalculatePositions
(
)
"
)
;
nsWindow
*
popup
=
mWaylandToplevel
-
>
mWaylandPopupNext
;
while
(
popup
)
{
LOG
(
"
popup
[
%
p
]
set
parent
window
[
%
p
]
"
(
void
*
)
popup
(
void
*
)
popup
-
>
mWaylandPopupPrev
)
;
gtk_window_set_transient_for
(
GTK_WINDOW
(
popup
-
>
mShell
)
GTK_WINDOW
(
popup
-
>
mWaylandPopupPrev
-
>
mShell
)
)
;
popup
=
popup
-
>
mWaylandPopupNext
;
}
popup
=
this
;
while
(
popup
)
{
LOG
(
"
popup
[
%
p
]
bounds
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
"
popup
(
int
)
(
popup
-
>
mBounds
.
x
/
FractionalScaleFactor
(
)
)
(
int
)
(
popup
-
>
mBounds
.
y
/
FractionalScaleFactor
(
)
)
(
int
)
(
popup
-
>
mBounds
.
width
/
FractionalScaleFactor
(
)
)
(
int
)
(
popup
-
>
mBounds
.
height
/
FractionalScaleFactor
(
)
)
)
;
#
ifdef
MOZ_LOGGING
if
(
LOG_ENABLED
(
)
)
{
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
popupFrame
)
{
auto
pos
=
popupFrame
-
>
GetPosition
(
)
;
auto
size
=
popupFrame
-
>
GetSize
(
)
;
int32_t
p2a
=
AppUnitsPerCSSPixel
(
)
/
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
LOG
(
"
popup
[
%
p
]
layout
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
"
popup
pos
.
x
/
p2a
pos
.
y
/
p2a
size
.
width
/
p2a
size
.
height
/
p2a
)
;
}
}
#
endif
if
(
popup
-
>
mPopupContextMenu
&
&
!
popup
-
>
mPopupAnchored
)
{
LOG
(
"
popup
[
%
p
]
is
first
context
menu
"
popup
)
;
static
int
menuOffsetX
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
ContextMenuOffsetHorizontal
)
;
static
int
menuOffsetY
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
ContextMenuOffsetVertical
)
;
popup
-
>
mRelativePopupPosition
=
popup
-
>
mPopupPosition
;
mRelativePopupOffset
.
x
=
menuOffsetX
;
mRelativePopupOffset
.
y
=
menuOffsetY
;
}
else
if
(
popup
-
>
mPopupAnchored
)
{
LOG
(
"
popup
[
%
p
]
is
anchored
"
popup
)
;
if
(
!
popup
-
>
mPopupMatchesLayout
)
{
NS_WARNING
(
"
Anchored
popup
does
not
match
layout
!
"
)
;
}
popup
-
>
mRelativePopupPosition
=
popup
-
>
mPopupPosition
;
}
else
if
(
popup
-
>
mWaylandPopupPrev
-
>
mWaylandToplevel
=
=
nullptr
)
{
LOG
(
"
popup
[
%
p
]
has
toplevel
as
parent
"
popup
)
;
popup
-
>
mRelativePopupPosition
=
popup
-
>
mPopupPosition
;
}
else
{
int
parentX
parentY
;
GetParentPosition
(
&
parentX
&
parentY
)
;
LOG
(
"
popup
[
%
p
]
uses
transformed
coordinates
\
n
"
popup
)
;
LOG
(
"
parent
position
[
%
d
%
d
]
\
n
"
parentX
parentY
)
;
LOG
(
"
popup
position
[
%
d
%
d
]
\
n
"
popup
-
>
mPopupPosition
.
x
popup
-
>
mPopupPosition
.
y
)
;
popup
-
>
mRelativePopupPosition
.
x
=
popup
-
>
mPopupPosition
.
x
-
parentX
;
popup
-
>
mRelativePopupPosition
.
y
=
popup
-
>
mPopupPosition
.
y
-
parentY
;
}
LOG
(
"
popup
[
%
p
]
transformed
popup
coordinates
from
[
%
d
%
d
]
to
[
%
d
%
d
]
"
popup
popup
-
>
mPopupPosition
.
x
popup
-
>
mPopupPosition
.
y
popup
-
>
mRelativePopupPosition
.
x
popup
-
>
mRelativePopupPosition
.
y
)
;
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
bool
nsWindow
:
:
WaylandPopupIsMenu
(
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
menuPopupFrame
)
{
return
mPopupType
=
=
ePopupTypeMenu
&
&
!
menuPopupFrame
-
>
IsMenuList
(
)
;
}
return
false
;
}
bool
nsWindow
:
:
WaylandPopupIsContextMenu
(
)
{
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
false
;
}
return
popupFrame
-
>
IsContextMenu
(
)
;
}
bool
nsWindow
:
:
WaylandPopupIsPermanent
(
)
{
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
false
;
}
return
popupFrame
-
>
IsNoAutoHide
(
)
;
}
bool
nsWindow
:
:
WaylandPopupIsAnchored
(
)
{
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
false
;
}
return
popupFrame
-
>
GetAnchor
(
)
!
=
nullptr
;
}
bool
nsWindow
:
:
IsWidgetOverflowWindow
(
)
{
if
(
this
-
>
GetFrame
(
)
&
&
this
-
>
GetFrame
(
)
-
>
GetContent
(
)
-
>
GetID
(
)
)
{
nsCString
nodeId
;
this
-
>
GetFrame
(
)
-
>
GetContent
(
)
-
>
GetID
(
)
-
>
ToUTF8String
(
nodeId
)
;
return
nodeId
.
Equals
(
"
widget
-
overflow
"
)
;
}
return
false
;
}
void
nsWindow
:
:
GetParentPosition
(
int
*
aX
int
*
aY
)
{
*
aX
=
*
aY
=
0
;
GtkWindow
*
parentGtkWindow
=
gtk_window_get_transient_for
(
GTK_WINDOW
(
mShell
)
)
;
if
(
!
parentGtkWindow
|
|
!
GTK_IS_WIDGET
(
parentGtkWindow
)
)
{
NS_WARNING
(
"
Popup
has
no
parent
!
"
)
;
return
;
}
GetWindowOrigin
(
gtk_widget_get_window
(
GTK_WIDGET
(
parentGtkWindow
)
)
aX
aY
)
;
}
#
ifdef
MOZ_LOGGING
void
nsWindow
:
:
LogPopupHierarchy
(
)
{
if
(
!
LOG_ENABLED
(
)
)
{
return
;
}
LOG
(
"
Widget
Popup
Hierarchy
:
\
n
"
)
;
if
(
!
mWaylandToplevel
-
>
mWaylandPopupNext
)
{
LOG
(
"
Empty
\
n
"
)
;
}
else
{
int
indent
=
4
;
nsWindow
*
popup
=
mWaylandToplevel
-
>
mWaylandPopupNext
;
while
(
popup
)
{
nsPrintfCString
indentString
(
"
%
*
s
"
indent
"
"
)
;
LOG
(
"
%
s
%
s
%
s
nsWindow
[
%
p
]
Menu
%
d
Permanent
%
d
ContextMenu
%
d
"
"
Anchored
%
d
Visible
%
d
\
n
"
indentString
.
get
(
)
popup
-
>
GetFrameTag
(
)
.
get
(
)
popup
-
>
GetPopupTypeName
(
)
.
get
(
)
popup
popup
-
>
WaylandPopupIsMenu
(
)
popup
-
>
WaylandPopupIsPermanent
(
)
popup
-
>
mPopupContextMenu
popup
-
>
mPopupAnchored
gtk_widget_is_visible
(
popup
-
>
mShell
)
)
;
indent
+
=
4
;
popup
=
popup
-
>
mWaylandPopupNext
;
}
}
LOG
(
"
Layout
Popup
Hierarchy
:
\
n
"
)
;
AutoTArray
<
nsIWidget
*
5
>
widgetChain
;
GetLayoutPopupWidgetChain
(
&
widgetChain
)
;
if
(
widgetChain
.
Length
(
)
=
=
0
)
{
LOG
(
"
Empty
\
n
"
)
;
}
else
{
for
(
unsigned
long
i
=
0
;
i
<
widgetChain
.
Length
(
)
;
i
+
+
)
{
nsWindow
*
window
=
static_cast
<
nsWindow
*
>
(
widgetChain
[
i
]
)
;
nsPrintfCString
indentString
(
"
%
*
s
"
(
int
)
(
i
+
1
)
*
4
"
"
)
;
if
(
window
)
{
LOG
(
"
%
s
%
s
%
s
nsWindow
[
%
p
]
Menu
%
d
Permanent
%
d
ContextMenu
%
d
"
"
Anchored
%
d
Visible
%
d
\
n
"
indentString
.
get
(
)
window
-
>
GetFrameTag
(
)
.
get
(
)
window
-
>
GetPopupTypeName
(
)
.
get
(
)
window
window
-
>
WaylandPopupIsMenu
(
)
window
-
>
WaylandPopupIsPermanent
(
)
window
-
>
mPopupContextMenu
window
-
>
mPopupAnchored
gtk_widget_is_visible
(
window
-
>
mShell
)
)
;
}
else
{
LOG
(
"
%
s
null
window
\
n
"
indentString
.
get
(
)
)
;
}
}
}
}
#
endif
nsWindow
*
nsWindow
:
:
WaylandPopupGetTopmostWindow
(
)
{
nsView
*
view
=
nsView
:
:
GetViewFor
(
this
)
;
if
(
view
)
{
nsView
*
parentView
=
view
-
>
GetParent
(
)
;
if
(
parentView
)
{
nsIWidget
*
parentWidget
=
parentView
-
>
GetNearestWidget
(
nullptr
)
;
if
(
parentWidget
)
{
nsWindow
*
parentnsWindow
=
static_cast
<
nsWindow
*
>
(
parentWidget
)
;
LOG
(
"
Topmost
window
:
%
p
[
nsWindow
]
\
n
"
parentnsWindow
)
;
return
parentnsWindow
;
}
}
}
return
nullptr
;
}
bool
nsWindow
:
:
WaylandPopupNeedsTrackInHierarchy
(
)
{
if
(
mIsDragPopup
)
{
return
false
;
}
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
false
;
}
bool
permanentStateMatches
=
mPopupTrackInHierarchy
=
=
!
WaylandPopupIsPermanent
(
)
;
if
(
mPopupTrackInHierarchyConfigured
&
&
permanentStateMatches
)
{
return
mPopupTrackInHierarchy
;
}
mPopupAnchored
=
WaylandPopupIsAnchored
(
)
;
mPopupContextMenu
=
WaylandPopupIsContextMenu
(
)
;
LOG
(
"
nsWindow
:
:
WaylandPopupNeedsTrackInHierarchy
tracked
%
d
anchored
%
d
\
n
"
mPopupTrackInHierarchy
mPopupAnchored
)
;
if
(
!
permanentStateMatches
&
&
mIsMapped
)
{
LOG
(
"
permanent
state
change
from
%
d
to
%
d
unmapping
"
mPopupTrackInHierarchy
!
WaylandPopupIsPermanent
(
)
)
;
gtk_widget_unmap
(
mShell
)
;
}
mPopupTrackInHierarchy
=
!
WaylandPopupIsPermanent
(
)
;
LOG
(
"
tracked
in
hierarchy
%
d
\
n
"
mPopupTrackInHierarchy
)
;
GdkWindowTypeHint
gtkTypeHint
;
switch
(
mPopupHint
)
{
case
ePopupTypeMenu
:
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_POPUP_MENU
;
LOG
(
"
popup
type
Menu
"
)
;
break
;
case
ePopupTypeTooltip
:
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_TOOLTIP
;
LOG
(
"
popup
type
Tooltip
"
)
;
break
;
default
:
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_UTILITY
;
LOG
(
"
popup
type
Utility
"
)
;
break
;
}
if
(
!
mPopupTrackInHierarchy
)
{
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_UTILITY
;
}
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
gtkTypeHint
)
;
mPopupTrackInHierarchyConfigured
=
true
;
return
mPopupTrackInHierarchy
;
}
bool
nsWindow
:
:
IsInPopupHierarchy
(
)
{
return
mPopupTrackInHierarchy
&
&
mWaylandToplevel
&
&
mWaylandPopupPrev
;
}
void
nsWindow
:
:
AddWindowToPopupHierarchy
(
)
{
LOG
(
"
nsWindow
:
:
AddWindowToPopupHierarchy
\
n
"
)
;
if
(
!
GetFrame
(
)
)
{
LOG
(
"
Window
without
frame
cannot
be
added
as
popup
!
\
n
"
)
;
return
;
}
if
(
!
IsInPopupHierarchy
(
)
)
{
mWaylandToplevel
=
WaylandPopupGetTopmostWindow
(
)
;
AppendPopupToHierarchyList
(
mWaylandToplevel
)
;
}
}
void
nsWindow
:
:
UpdateWaylandPopupHierarchy
(
)
{
LOG
(
"
nsWindow
:
:
UpdateWaylandPopupHierarchy
\
n
"
)
;
if
(
!
IsInPopupHierarchy
(
)
)
{
LOG
(
"
popup
isn
'
t
in
hierarchy
\
n
"
)
;
return
;
}
#
ifdef
MOZ_LOGGING
LogPopupHierarchy
(
)
;
auto
printPopupHierarchy
=
MakeScopeExit
(
[
&
]
{
LogPopupHierarchy
(
)
;
}
)
;
#
endif
mWaylandToplevel
-
>
WaylandPopupHideTooltips
(
)
;
mWaylandToplevel
-
>
CloseAllPopupsBeforeRemotePopup
(
)
;
AutoTArray
<
nsIWidget
*
5
>
layoutPopupWidgetChain
;
GetLayoutPopupWidgetChain
(
&
layoutPopupWidgetChain
)
;
mWaylandToplevel
-
>
WaylandPopupHierarchyHideByLayout
(
&
layoutPopupWidgetChain
)
;
mWaylandToplevel
-
>
WaylandPopupHierarchyValidateByLayout
(
&
layoutPopupWidgetChain
)
;
nsWindow
*
changedPopup
=
mWaylandToplevel
-
>
mWaylandPopupNext
;
while
(
changedPopup
)
{
if
(
changedPopup
-
>
mPopupChanged
)
{
break
;
}
if
(
changedPopup
-
>
mPopupClosed
)
{
break
;
}
changedPopup
=
changedPopup
-
>
mWaylandPopupNext
;
}
if
(
!
changedPopup
)
{
LOG
(
"
changed
Popup
is
null
quit
.
\
n
"
)
;
return
;
}
LOG
(
"
first
changed
popup
[
%
p
]
\
n
"
(
void
*
)
changedPopup
)
;
changedPopup
-
>
WaylandPopupHierarchyHideTemporary
(
)
;
nsWindow
*
parentOfchangedPopup
=
nullptr
;
if
(
changedPopup
-
>
mPopupClosed
)
{
parentOfchangedPopup
=
changedPopup
-
>
mWaylandPopupPrev
;
}
changedPopup
-
>
WaylandPopupRemoveClosedPopups
(
)
;
if
(
!
changedPopup
-
>
IsInPopupHierarchy
(
)
)
{
if
(
!
parentOfchangedPopup
|
|
!
parentOfchangedPopup
-
>
mWaylandPopupNext
)
{
LOG
(
"
last
popup
was
removed
quit
.
\
n
"
)
;
return
;
}
changedPopup
=
parentOfchangedPopup
-
>
mWaylandPopupNext
;
}
GetLayoutPopupWidgetChain
(
&
layoutPopupWidgetChain
)
;
mWaylandToplevel
-
>
WaylandPopupHierarchyValidateByLayout
(
&
layoutPopupWidgetChain
)
;
changedPopup
-
>
WaylandPopupHierarchyCalculatePositions
(
)
;
nsWindow
*
popup
=
changedPopup
;
while
(
popup
)
{
bool
useMoveToRect
=
gUseMoveToRect
&
&
popup
-
>
mPopupMatchesLayout
;
if
(
useMoveToRect
)
{
useMoveToRect
=
(
mPopupType
=
=
ePopupTypeTooltip
)
|
|
(
popup
-
>
mPopupAnchored
|
|
(
!
popup
-
>
mPopupAnchored
&
&
popup
-
>
mWaylandPopupPrev
-
>
mWaylandToplevel
=
=
nullptr
)
)
;
}
LOG
(
"
popup
[
%
p
]
matches
layout
[
%
d
]
anchored
[
%
d
]
first
popup
[
%
d
]
use
"
"
move
-
to
-
rect
%
d
\
n
"
popup
popup
-
>
mPopupMatchesLayout
popup
-
>
mPopupAnchored
popup
-
>
mWaylandPopupPrev
-
>
mWaylandToplevel
=
=
nullptr
useMoveToRect
)
;
popup
-
>
mPopupUseMoveToRect
=
useMoveToRect
;
popup
-
>
WaylandPopupMove
(
)
;
popup
-
>
mPopupChanged
=
false
;
popup
=
popup
-
>
mWaylandPopupNext
;
}
changedPopup
-
>
WaylandPopupHierarchyShowTemporaryHidden
(
)
;
}
static
void
NativeMoveResizeCallback
(
GdkWindow
*
window
const
GdkRectangle
*
flipped_rect
const
GdkRectangle
*
final_rect
gboolean
flipped_x
gboolean
flipped_y
void
*
aWindow
)
{
LOG_POPUP
(
"
[
%
p
]
NativeMoveResizeCallback
flipped_x
%
d
flipped_y
%
d
\
n
"
aWindow
flipped_x
flipped_y
)
;
LOG_POPUP
(
"
[
%
p
]
new
position
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
"
aWindow
final_rect
-
>
x
final_rect
-
>
y
final_rect
-
>
width
final_rect
-
>
height
)
;
nsWindow
*
wnd
=
get_window_for_gdk_window
(
window
)
;
wnd
-
>
NativeMoveResizeWaylandPopupCallback
(
final_rect
flipped_x
flipped_y
)
;
}
void
nsWindow
:
:
NativeMoveResizeWaylandPopupCallback
(
const
GdkRectangle
*
aFinalSize
bool
aFlippedX
bool
aFlippedY
)
{
mWaitingForMoveToRectCallback
=
false
;
bool
moved
=
mNewBoundsAfterMoveToRect
.
x
|
|
mNewBoundsAfterMoveToRect
.
y
;
bool
resized
=
mNewBoundsAfterMoveToRect
.
width
|
|
mNewBoundsAfterMoveToRect
.
height
;
if
(
moved
|
|
resized
)
{
LOG
(
"
Another
move
/
resize
called
during
waiting
for
callback
\
n
"
)
;
mPreferredPopupRect
=
nsRect
(
0
0
0
0
)
;
if
(
moved
)
{
mBounds
.
x
=
mNewBoundsAfterMoveToRect
.
x
;
mBounds
.
y
=
mNewBoundsAfterMoveToRect
.
y
;
}
if
(
resized
)
{
mBounds
.
width
=
mNewBoundsAfterMoveToRect
.
width
;
mBounds
.
height
=
mNewBoundsAfterMoveToRect
.
height
;
}
mNewBoundsAfterMoveToRect
=
LayoutDeviceIntRect
(
0
0
0
0
)
;
NativeMoveResize
(
moved
resized
)
;
return
;
}
LOG
(
"
orig
mBounds
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
\
n
"
mBounds
.
x
mBounds
.
y
mBounds
.
width
mBounds
.
height
)
;
LayoutDeviceIntRect
newBounds
(
0
0
0
0
)
;
int
parentX
parentY
;
GetParentPosition
(
&
parentX
&
parentY
)
;
newBounds
.
x
=
GdkCoordToDevicePixels
(
aFinalSize
-
>
x
+
parentX
)
;
newBounds
.
y
=
GdkCoordToDevicePixels
(
aFinalSize
-
>
y
+
parentY
)
;
double
scale
=
BoundsUseDesktopPixels
(
)
?
GetDesktopToDeviceScale
(
)
.
scale
:
1
.
0
;
newBounds
.
width
=
NSToIntRound
(
scale
*
aFinalSize
-
>
width
)
;
newBounds
.
height
=
NSToIntRound
(
scale
*
aFinalSize
-
>
height
)
;
LOG
(
"
new
mBounds
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
"
newBounds
.
x
newBounds
.
y
newBounds
.
width
newBounds
.
height
)
;
bool
needsPositionUpdate
=
(
newBounds
.
x
!
=
mBounds
.
x
|
|
newBounds
.
y
!
=
mBounds
.
y
)
;
bool
needsSizeUpdate
=
(
newBounds
.
width
!
=
mBounds
.
width
|
|
newBounds
.
height
!
=
mBounds
.
height
)
;
if
(
needsSizeUpdate
)
{
LOG
(
"
needSizeUpdate
\
n
"
)
;
int32_t
p2a
=
AppUnitsPerCSSPixel
(
)
/
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
mPreferredPopupRect
=
nsRect
(
NSIntPixelsToAppUnits
(
newBounds
.
x
p2a
)
NSIntPixelsToAppUnits
(
newBounds
.
y
p2a
)
NSIntPixelsToAppUnits
(
aFinalSize
-
>
width
p2a
)
NSIntPixelsToAppUnits
(
aFinalSize
-
>
height
p2a
)
)
;
mPreferredPopupRectFlushed
=
false
;
Resize
(
aFinalSize
-
>
width
aFinalSize
-
>
height
true
)
;
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
popupFrame
)
{
RefPtr
<
PresShell
>
presShell
=
popupFrame
-
>
PresShell
(
)
;
presShell
-
>
FrameNeedsReflow
(
popupFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
popupFrame
-
>
SetPopupPosition
(
nullptr
true
false
)
;
}
}
if
(
needsPositionUpdate
)
{
if
(
StaticPrefs
:
:
layout_css_devPixelsPerPx
(
)
>
0
|
|
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
!
=
1
)
{
bool
roundingError
=
(
abs
(
newBounds
.
x
-
mBounds
.
x
)
<
2
&
&
abs
(
newBounds
.
y
-
mBounds
.
y
)
<
2
)
;
if
(
roundingError
)
{
GdkPoint
topLeft
=
DevicePixelsToGdkPointRoundDown
(
mBounds
.
TopLeft
(
)
)
;
LOG
(
"
apply
rounding
error
workaround
move
to
%
d
%
d
"
topLeft
.
x
topLeft
.
y
)
;
gtk_window_move
(
GTK_WINDOW
(
mShell
)
topLeft
.
x
topLeft
.
y
)
;
return
;
}
}
LOG
(
"
needPositionUpdate
new
bounds
[
%
d
%
d
]
"
newBounds
.
x
newBounds
.
y
)
;
mBounds
.
x
=
newBounds
.
x
;
mBounds
.
y
=
newBounds
.
y
;
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
}
}
static
GdkGravity
PopupAlignmentToGdkGravity
(
int8_t
aAlignment
)
{
switch
(
aAlignment
)
{
case
POPUPALIGNMENT_NONE
:
return
GDK_GRAVITY_NORTH_WEST
;
case
POPUPALIGNMENT_TOPLEFT
:
return
GDK_GRAVITY_NORTH_WEST
;
case
POPUPALIGNMENT_TOPRIGHT
:
return
GDK_GRAVITY_NORTH_EAST
;
case
POPUPALIGNMENT_BOTTOMLEFT
:
return
GDK_GRAVITY_SOUTH_WEST
;
case
POPUPALIGNMENT_BOTTOMRIGHT
:
return
GDK_GRAVITY_SOUTH_EAST
;
case
POPUPALIGNMENT_LEFTCENTER
:
return
GDK_GRAVITY_WEST
;
case
POPUPALIGNMENT_RIGHTCENTER
:
return
GDK_GRAVITY_EAST
;
case
POPUPALIGNMENT_TOPCENTER
:
return
GDK_GRAVITY_NORTH
;
case
POPUPALIGNMENT_BOTTOMCENTER
:
return
GDK_GRAVITY_SOUTH
;
}
return
GDK_GRAVITY_STATIC
;
}
bool
nsWindow
:
:
IsPopupDirectionRTL
(
)
{
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
return
popupFrame
&
&
popupFrame
-
>
IsDirectionRTL
(
)
;
}
void
nsWindow
:
:
WaylandPopupSetDirectPosition
(
)
{
GdkPoint
position
=
DevicePixelsToGdkPointRoundDown
(
mBounds
.
TopLeft
(
)
)
;
GdkRectangle
size
=
DevicePixelsToGdkSizeRoundUp
(
mBounds
.
Size
(
)
)
;
LOG
(
"
nsWindow
:
:
WaylandPopupSetDirectPosition
%
d
%
d
-
>
%
d
x
%
d
\
n
"
position
.
x
position
.
y
size
.
width
size
.
height
)
;
mPopupPosition
=
position
;
if
(
mIsDragPopup
)
{
gtk_window_move
(
GTK_WINDOW
(
mShell
)
mPopupPosition
.
x
mPopupPosition
.
y
)
;
gtk_window_resize
(
GTK_WINDOW
(
mShell
)
size
.
width
size
.
height
)
;
gtk_widget_set_size_request
(
GTK_WIDGET
(
mShell
)
size
.
width
size
.
height
)
;
return
;
}
GtkWindow
*
parentGtkWindow
=
gtk_window_get_transient_for
(
GTK_WINDOW
(
mShell
)
)
;
nsWindow
*
window
=
get_window_for_gtk_widget
(
GTK_WIDGET
(
parentGtkWindow
)
)
;
GdkWindow
*
gdkWindow
=
gtk_widget_get_window
(
GTK_WIDGET
(
window
-
>
GetMozContainer
(
)
)
)
;
int
parentWidth
=
gdk_window_get_width
(
gdkWindow
)
;
int
popupWidth
=
size
.
width
;
int
x
;
gdk_window_get_position
(
gdkWindow
&
x
nullptr
)
;
if
(
popupWidth
>
parentWidth
)
{
mPopupPosition
.
x
=
-
(
parentWidth
-
popupWidth
)
/
2
+
x
;
}
else
{
if
(
IsPopupDirectionRTL
(
)
)
{
if
(
mPopupPosition
.
x
<
x
)
{
mPopupPosition
.
x
=
x
;
}
}
else
{
if
(
mPopupPosition
.
x
+
popupWidth
>
parentWidth
+
x
)
{
mPopupPosition
.
x
=
parentWidth
+
x
-
popupWidth
;
}
}
}
LOG
(
"
set
position
[
%
d
%
d
]
\
n
"
mPopupPosition
.
x
mPopupPosition
.
y
)
;
gtk_window_move
(
GTK_WINDOW
(
mShell
)
mPopupPosition
.
x
mPopupPosition
.
y
)
;
LOG
(
"
set
size
[
%
d
%
d
]
\
n
"
size
.
width
size
.
height
)
;
gtk_window_resize
(
GTK_WINDOW
(
mShell
)
size
.
width
size
.
height
)
;
if
(
mPopupPosition
.
x
!
=
position
.
x
)
{
mBounds
.
x
=
mPopupPosition
.
x
*
FractionalScaleFactor
(
)
;
mBounds
.
y
=
mPopupPosition
.
y
*
FractionalScaleFactor
(
)
;
LOG
(
"
setting
new
bounds
[
%
d
%
d
]
\
n
"
mBounds
.
x
mBounds
.
y
)
;
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
if
(
popupFrame
)
{
popupFrame
-
>
MoveTo
(
CSSIntPoint
(
mPopupPosition
.
x
mPopupPosition
.
y
)
true
)
;
}
}
}
bool
nsWindow
:
:
WaylandPopupFitsParentWindow
(
GdkRectangle
*
aSize
)
{
GtkWindow
*
parentGtkWindow
=
gtk_window_get_transient_for
(
GTK_WINDOW
(
mShell
)
)
;
nsWindow
*
parentWindow
=
get_window_for_gtk_widget
(
GTK_WIDGET
(
parentGtkWindow
)
)
;
if
(
parentWindow
-
>
IsPopup
(
)
)
{
return
false
;
}
GdkWindow
*
parentGdkWindow
=
gtk_widget_get_window
(
GTK_WIDGET
(
parentWindow
-
>
GetMozContainer
(
)
)
)
;
int
x
y
;
gdk_window_get_position
(
parentGdkWindow
&
x
&
y
)
;
int
parentWidth
=
gdk_window_get_width
(
parentGdkWindow
)
+
x
;
int
parentHeight
=
gdk_window_get_width
(
parentGdkWindow
)
+
y
;
int
popupWidth
=
aSize
-
>
width
;
int
popupHeight
=
aSize
-
>
height
;
int
scale
=
FractionalScaleFactor
(
)
;
int
popupX
=
mBounds
.
x
/
scale
;
int
popupY
=
mBounds
.
y
/
scale
;
return
popupX
+
popupWidth
<
=
parentWidth
&
&
popupY
+
popupHeight
<
=
parentHeight
;
}
void
nsWindow
:
:
NativeMoveResizeWaylandPopup
(
bool
aMove
bool
aResize
)
{
GdkPoint
position
=
DevicePixelsToGdkPointRoundDown
(
mBounds
.
TopLeft
(
)
)
;
GdkRectangle
size
=
DevicePixelsToGdkSizeRoundUp
(
mBounds
.
Size
(
)
)
;
LOG
(
"
nsWindow
:
:
NativeMoveResizeWaylandPopup
%
d
%
d
-
>
%
d
x
%
d
\
n
"
position
.
x
position
.
y
size
.
width
size
.
height
)
;
if
(
!
AreBoundsSane
(
)
)
{
LOG
(
"
Bounds
are
not
sane
(
width
:
%
d
height
:
%
d
)
\
n
"
mBounds
.
width
mBounds
.
height
)
;
return
;
}
if
(
mWaitingForMoveToRectCallback
)
{
LOG
(
"
waiting
for
move
to
rect
schedulling
"
)
;
if
(
aMove
)
{
mNewBoundsAfterMoveToRect
.
x
=
mBounds
.
x
;
mNewBoundsAfterMoveToRect
.
y
=
mBounds
.
y
;
}
if
(
aResize
)
{
mNewBoundsAfterMoveToRect
.
width
=
mBounds
.
width
;
mNewBoundsAfterMoveToRect
.
height
=
mBounds
.
height
;
}
return
;
}
else
{
mNewBoundsAfterMoveToRect
=
LayoutDeviceIntRect
(
0
0
0
0
)
;
}
if
(
!
WaylandPopupNeedsTrackInHierarchy
(
)
)
{
WaylandPopupSetDirectPosition
(
)
;
return
;
}
if
(
aResize
)
{
LOG
(
"
set
size
[
%
d
%
d
]
\
n
"
size
.
width
size
.
height
)
;
gtk_window_resize
(
GTK_WINDOW
(
mShell
)
size
.
width
size
.
height
)
;
}
if
(
!
aMove
&
&
WaylandPopupFitsParentWindow
(
&
size
)
)
{
LOG
(
"
fits
parent
window
size
just
resize
\
n
"
)
;
return
;
}
mPopupChanged
=
true
;
LOG
(
"
popup
position
changed
from
[
%
d
%
d
]
to
[
%
d
%
d
]
\
n
"
mPopupPosition
.
x
mPopupPosition
.
y
position
.
x
position
.
y
)
;
mPopupPosition
=
position
;
UpdateWaylandPopupHierarchy
(
)
;
}
struct
PopupSides
{
Maybe
<
Side
>
mVertical
;
Maybe
<
Side
>
mHorizontal
;
}
;
static
PopupSides
SidesForPopupAlignment
(
int8_t
aAlignment
)
{
switch
(
aAlignment
)
{
case
POPUPALIGNMENT_NONE
:
break
;
case
POPUPALIGNMENT_TOPLEFT
:
return
{
Some
(
eSideTop
)
Some
(
eSideLeft
)
}
;
case
POPUPALIGNMENT_TOPRIGHT
:
return
{
Some
(
eSideTop
)
Some
(
eSideRight
)
}
;
case
POPUPALIGNMENT_BOTTOMLEFT
:
return
{
Some
(
eSideBottom
)
Some
(
eSideLeft
)
}
;
case
POPUPALIGNMENT_BOTTOMRIGHT
:
return
{
Some
(
eSideBottom
)
Some
(
eSideRight
)
}
;
case
POPUPALIGNMENT_LEFTCENTER
:
return
{
Nothing
(
)
Some
(
eSideLeft
)
}
;
case
POPUPALIGNMENT_RIGHTCENTER
:
return
{
Nothing
(
)
Some
(
eSideRight
)
}
;
case
POPUPALIGNMENT_TOPCENTER
:
return
{
Some
(
eSideTop
)
Nothing
(
)
}
;
case
POPUPALIGNMENT_BOTTOMCENTER
:
return
{
Some
(
eSideBottom
)
Nothing
(
)
}
;
}
return
{
}
;
}
struct
ResolvedPopupMargin
{
nsMargin
mAnchorMargin
;
nsPoint
mPopupOffset
;
}
;
static
ResolvedPopupMargin
ResolveMargin
(
nsMenuPopupFrame
*
aFrame
int8_t
aPopupAlign
int8_t
aAnchorAlign
)
{
nsMargin
margin
;
nsPoint
offset
;
aFrame
-
>
StyleMargin
(
)
-
>
GetMargin
(
margin
)
;
auto
popupSides
=
SidesForPopupAlignment
(
aPopupAlign
)
;
auto
anchorSides
=
SidesForPopupAlignment
(
aAnchorAlign
)
;
if
(
popupSides
.
mHorizontal
=
=
anchorSides
.
mHorizontal
)
{
margin
.
left
=
-
margin
.
left
;
margin
.
right
=
-
margin
.
right
;
}
else
if
(
!
anchorSides
.
mHorizontal
)
{
auto
popupSide
=
*
popupSides
.
mHorizontal
;
offset
.
x
+
=
popupSide
=
=
eSideRight
?
-
margin
.
Side
(
popupSide
)
:
margin
.
Side
(
popupSide
)
;
margin
.
left
=
margin
.
right
=
0
;
}
if
(
popupSides
.
mVertical
=
=
anchorSides
.
mVertical
)
{
margin
.
top
=
-
margin
.
top
;
margin
.
bottom
=
-
margin
.
bottom
;
}
else
if
(
!
anchorSides
.
mVertical
)
{
auto
popupSide
=
*
popupSides
.
mVertical
;
offset
.
y
+
=
popupSide
=
=
eSideBottom
?
-
margin
.
Side
(
popupSide
)
:
margin
.
Side
(
popupSide
)
;
margin
.
top
=
margin
.
bottom
=
0
;
}
return
{
margin
offset
}
;
}
void
nsWindow
:
:
WaylandPopupMove
(
)
{
LOG
(
"
nsWindow
:
:
WaylandPopupMove
\
n
"
)
;
static
auto
sGdkWindowMoveToRect
=
(
void
(
*
)
(
GdkWindow
*
const
GdkRectangle
*
GdkGravity
GdkGravity
GdkAnchorHints
gint
gint
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_window_move_to_rect
"
)
;
GdkWindow
*
gdkWindow
=
gtk_widget_get_window
(
GTK_WIDGET
(
mShell
)
)
;
nsMenuPopupFrame
*
popupFrame
=
GetMenuPopupFrame
(
GetFrame
(
)
)
;
LOG
(
"
original
widget
popup
position
[
%
d
%
d
]
\
n
"
mPopupPosition
.
x
mPopupPosition
.
y
)
;
LOG
(
"
relative
widget
popup
position
[
%
d
%
d
]
\
n
"
mRelativePopupPosition
.
x
mRelativePopupPosition
.
y
)
;
LOG
(
"
relative
widget
popup
offset
[
%
d
%
d
]
\
n
"
mRelativePopupOffset
.
x
mRelativePopupOffset
.
y
)
;
if
(
mPopupUseMoveToRect
)
{
mPopupUseMoveToRect
=
sGdkWindowMoveToRect
&
&
gdkWindow
&
&
popupFrame
;
}
if
(
!
mPopupUseMoveToRect
)
{
if
(
mNeedsShow
&
&
mPopupType
!
=
ePopupTypeTooltip
)
{
LOG
(
"
use
gtk_window_move
(
%
d
%
d
)
for
hidden
widget
\
n
"
mPopupPosition
.
x
+
mRelativePopupOffset
.
x
mPopupPosition
.
y
+
mRelativePopupOffset
.
y
)
;
gtk_window_move
(
GTK_WINDOW
(
mShell
)
mPopupPosition
.
x
+
mRelativePopupOffset
.
x
mPopupPosition
.
y
+
mRelativePopupOffset
.
y
)
;
}
else
{
LOG
(
"
use
gtk_window_move
(
%
d
%
d
)
for
visible
widget
\
n
"
mRelativePopupPosition
.
x
+
mRelativePopupOffset
.
x
mRelativePopupPosition
.
y
+
mRelativePopupOffset
.
y
)
;
gtk_window_move
(
GTK_WINDOW
(
mShell
)
mRelativePopupPosition
.
x
+
mRelativePopupOffset
.
x
mRelativePopupPosition
.
y
+
mRelativePopupOffset
.
y
)
;
}
if
(
mRelativePopupOffset
.
x
|
|
mRelativePopupOffset
.
y
)
{
mBounds
.
x
=
(
mRelativePopupPosition
.
x
+
mRelativePopupOffset
.
x
)
*
FractionalScaleFactor
(
)
;
mBounds
.
y
=
(
mRelativePopupPosition
.
y
+
mRelativePopupOffset
.
y
)
*
FractionalScaleFactor
(
)
;
LOG
(
"
popup
is
moved
setting
new
bounds
starts
at
[
%
d
%
d
]
\
n
"
mBounds
.
x
mBounds
.
y
)
;
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
}
return
;
}
int32_t
p2a
;
double
devPixelsPerCSSPixel
=
StaticPrefs
:
:
layout_css_devPixelsPerPx
(
)
;
if
(
devPixelsPerCSSPixel
>
0
.
0
)
{
p2a
=
AppUnitsPerCSSPixel
(
)
/
devPixelsPerCSSPixel
*
GdkCeiledScaleFactor
(
)
;
}
else
{
p2a
=
AppUnitsPerCSSPixel
(
)
/
gfxPlatformGtk
:
:
GetFontScaleFactor
(
)
;
}
const
bool
isTopContextMenu
=
mPopupContextMenu
&
&
!
mPopupAnchored
;
int8_t
popupAlign
(
popupFrame
-
>
GetPopupAlignment
(
)
)
;
int8_t
anchorAlign
(
popupFrame
-
>
GetPopupAnchor
(
)
)
;
if
(
isTopContextMenu
)
{
anchorAlign
=
POPUPALIGNMENT_BOTTOMRIGHT
;
popupAlign
=
POPUPALIGNMENT_TOPLEFT
;
}
if
(
IsPopupDirectionRTL
(
)
)
{
popupAlign
=
-
popupAlign
;
anchorAlign
=
-
anchorAlign
;
}
LayoutDeviceIntRect
anchorRect
;
ResolvedPopupMargin
popupMargin
;
bool
hasAnchorRect
;
{
nsRect
anchorRectAppUnits
=
popupFrame
-
>
GetAnchorRect
(
)
;
hasAnchorRect
=
anchorRectAppUnits
.
width
!
=
0
;
if
(
hasAnchorRect
)
{
popupMargin
=
ResolveMargin
(
popupFrame
popupAlign
anchorAlign
)
;
LOG
(
"
layout
popup
CSS
anchor
(
%
d
%
d
)
%
s
margin
%
s
offset
%
s
\
n
"
popupAlign
anchorAlign
ToString
(
anchorRectAppUnits
)
.
c_str
(
)
ToString
(
popupMargin
.
mAnchorMargin
)
.
c_str
(
)
ToString
(
popupMargin
.
mPopupOffset
)
.
c_str
(
)
)
;
anchorRectAppUnits
.
Inflate
(
popupMargin
.
mAnchorMargin
)
;
LOG
(
"
after
margins
%
s
\
n
"
ToString
(
anchorRectAppUnits
)
.
c_str
(
)
)
;
if
(
anchorRect
.
width
<
0
)
{
auto
w
=
-
anchorRect
.
width
;
anchorRect
.
width
+
=
w
+
1
;
anchorRect
.
x
+
=
w
;
}
anchorRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
anchorRectAppUnits
p2a
)
;
LOG
(
"
final
%
s
\
n
"
ToString
(
anchorRect
)
.
c_str
(
)
)
;
}
}
FlipType
flipType
=
FlipType_Default
;
int8_t
position
=
-
1
;
GdkGravity
rectAnchor
=
PopupAlignmentToGdkGravity
(
anchorAlign
)
;
GdkGravity
menuAnchor
=
PopupAlignmentToGdkGravity
(
popupAlign
)
;
if
(
!
isTopContextMenu
)
{
flipType
=
popupFrame
-
>
GetFlipType
(
)
;
position
=
popupFrame
-
>
GetAlignmentPosition
(
)
;
}
if
(
mRelativePopupOffset
.
x
|
|
mRelativePopupOffset
.
y
)
{
MOZ_ASSERT
(
isTopContextMenu
)
;
anchorRect
.
SetRect
(
mRelativePopupPosition
.
x
-
mRelativePopupOffset
.
x
mRelativePopupPosition
.
y
-
mRelativePopupOffset
.
y
mRelativePopupOffset
.
x
*
2
mRelativePopupOffset
.
y
*
2
)
;
LOG
(
"
Set
anchor
rect
with
offset
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
"
anchorRect
.
x
anchorRect
.
y
anchorRect
.
width
anchorRect
.
height
)
;
}
else
if
(
!
hasAnchorRect
)
{
LOG
(
"
No
anchor
rect
given
use
position
for
anchor
[
%
d
%
d
]
"
mRelativePopupPosition
.
x
mRelativePopupPosition
.
y
)
;
anchorRect
.
SetRect
(
mRelativePopupPosition
.
x
mRelativePopupPosition
.
y
1
1
)
;
}
else
if
(
mWaylandPopupPrev
-
>
mWaylandToplevel
!
=
nullptr
)
{
int
parentX
parentY
;
GetParentPosition
(
&
parentX
&
parentY
)
;
LOG
(
"
subtract
parent
position
[
%
d
%
d
]
\
n
"
parentX
parentY
)
;
anchorRect
.
x
-
=
parentX
;
anchorRect
.
y
-
=
parentY
;
}
LOG
(
"
final
popup
rect
position
[
%
d
%
d
]
-
>
[
%
d
x
%
d
]
\
n
"
anchorRect
.
x
anchorRect
.
y
anchorRect
.
width
anchorRect
.
height
)
;
LOG
(
"
parentRect
gravity
:
%
d
anchor
gravity
:
%
d
\
n
"
rectAnchor
menuAnchor
)
;
GdkAnchorHints
hints
=
GdkAnchorHints
(
GDK_ANCHOR_FLIP
|
GDK_ANCHOR_SLIDE_X
|
GDK_ANCHOR_RESIZE
)
;
if
(
position
>
=
POPUPPOSITION_BEFORESTART
&
&
position
<
=
POPUPPOSITION_AFTEREND
)
{
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_SLIDE_X
)
;
}
if
(
position
>
=
POPUPPOSITION_STARTBEFORE
&
&
position
<
=
POPUPPOSITION_ENDAFTER
)
{
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_SLIDE_Y
)
;
}
if
(
rectAnchor
=
=
GDK_GRAVITY_CENTER
&
&
menuAnchor
=
=
GDK_GRAVITY_CENTER
)
{
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_SLIDE
)
;
}
else
{
switch
(
flipType
)
{
case
FlipType_Both
:
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_FLIP
)
;
break
;
case
FlipType_Slide
:
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_SLIDE
)
;
break
;
case
FlipType_Default
:
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_FLIP
)
;
break
;
default
:
break
;
}
}
if
(
!
WaylandPopupIsMenu
(
)
)
{
hints
=
GdkAnchorHints
(
hints
|
GDK_ANCHOR_SLIDE
)
;
}
if
(
!
g_signal_handler_find
(
gdkWindow
G_SIGNAL_MATCH_FUNC
0
0
nullptr
FuncToGpointer
(
NativeMoveResizeCallback
)
this
)
)
{
g_signal_connect
(
gdkWindow
"
moved
-
to
-
rect
"
G_CALLBACK
(
NativeMoveResizeCallback
)
this
)
;
}
GdkRectangle
rect
=
{
anchorRect
.
x
anchorRect
.
y
anchorRect
.
width
anchorRect
.
height
}
;
mWaitingForMoveToRectCallback
=
true
;
if
(
gtk_widget_is_visible
(
mShell
)
)
{
NS_WARNING
(
"
Positioning
visible
popup
under
Wayland
position
may
be
wrong
!
"
)
;
}
WaylandPopupRemoveNegativePosition
(
)
;
LOG
(
"
move
-
to
-
rect
call
"
)
;
mPopupLastAnchor
=
anchorRect
;
auto
offset
=
LayoutDevicePoint
:
:
FromAppUnitsToNearest
(
popupMargin
.
mPopupOffset
p2a
)
;
sGdkWindowMoveToRect
(
gdkWindow
&
rect
rectAnchor
menuAnchor
hints
offset
.
x
offset
.
y
)
;
}
void
nsWindow
:
:
SetZIndex
(
int32_t
aZIndex
)
{
nsIWidget
*
oldPrev
=
GetPrevSibling
(
)
;
nsBaseWidget
:
:
SetZIndex
(
aZIndex
)
;
if
(
GetPrevSibling
(
)
=
=
oldPrev
)
{
return
;
}
NS_ASSERTION
(
!
mContainer
"
Expected
Mozilla
child
widget
"
)
;
if
(
!
mGdkWindow
)
{
return
;
}
if
(
!
GetNextSibling
(
)
)
{
if
(
mGdkWindow
)
{
gdk_window_raise
(
mGdkWindow
)
;
}
}
else
{
for
(
nsWindow
*
w
=
this
;
w
;
w
=
static_cast
<
nsWindow
*
>
(
w
-
>
GetPrevSibling
(
)
)
)
{
if
(
w
-
>
mGdkWindow
)
{
gdk_window_lower
(
w
-
>
mGdkWindow
)
;
}
}
}
}
void
nsWindow
:
:
SetSizeMode
(
nsSizeMode
aMode
)
{
LOG
(
"
nsWindow
:
:
SetSizeMode
%
d
\
n
"
aMode
)
;
nsBaseWidget
:
:
SetSizeMode
(
aMode
)
;
if
(
!
mShell
|
|
mSizeState
=
=
mSizeMode
)
{
LOG
(
"
already
set
"
)
;
return
;
}
switch
(
aMode
)
{
case
nsSizeMode_Maximized
:
LOG
(
"
set
maximized
"
)
;
gtk_window_maximize
(
GTK_WINDOW
(
mShell
)
)
;
break
;
case
nsSizeMode_Minimized
:
LOG
(
"
set
minimized
"
)
;
gtk_window_iconify
(
GTK_WINDOW
(
mShell
)
)
;
break
;
case
nsSizeMode_Fullscreen
:
LOG
(
"
set
fullscreen
"
)
;
MakeFullScreen
(
true
)
;
break
;
default
:
LOG
(
"
set
normal
"
)
;
if
(
mSizeState
=
=
nsSizeMode_Minimized
)
{
gtk_window_deiconify
(
GTK_WINDOW
(
mShell
)
)
;
}
else
if
(
mSizeState
=
=
nsSizeMode_Maximized
)
{
gtk_window_unmaximize
(
GTK_WINDOW
(
mShell
)
)
;
}
break
;
}
mBoundsAreValid
=
false
;
mSizeState
=
mSizeMode
;
}
static
bool
GetWindowManagerName
(
GdkWindow
*
gdk_window
nsACString
&
wmName
)
{
if
(
!
GdkIsX11Display
(
)
)
{
return
false
;
}
Display
*
xdisplay
=
gdk_x11_get_default_xdisplay
(
)
;
GdkScreen
*
screen
=
gdk_window_get_screen
(
gdk_window
)
;
Window
root_win
=
GDK_WINDOW_XID
(
gdk_screen_get_root_window
(
screen
)
)
;
int
actual_format_return
;
Atom
actual_type_return
;
unsigned
long
nitems_return
;
unsigned
long
bytes_after_return
;
unsigned
char
*
prop_return
=
nullptr
;
auto
releaseXProperty
=
MakeScopeExit
(
[
&
]
{
if
(
prop_return
)
{
XFree
(
prop_return
)
;
}
}
)
;
Atom
property
=
XInternAtom
(
xdisplay
"
_NET_SUPPORTING_WM_CHECK
"
true
)
;
Atom
req_type
=
XInternAtom
(
xdisplay
"
WINDOW
"
true
)
;
if
(
!
property
|
|
!
req_type
)
{
return
false
;
}
int
result
=
XGetWindowProperty
(
xdisplay
root_win
property
0L
sizeof
(
Window
)
/
4
false
req_type
&
actual_type_return
&
actual_format_return
&
nitems_return
&
bytes_after_return
&
prop_return
)
;
if
(
result
!
=
Success
|
|
bytes_after_return
!
=
0
|
|
nitems_return
!
=
1
)
{
return
false
;
}
Window
wmWindow
=
reinterpret_cast
<
Window
*
>
(
prop_return
)
[
0
]
;
if
(
!
wmWindow
)
{
return
false
;
}
XFree
(
prop_return
)
;
prop_return
=
nullptr
;
property
=
XInternAtom
(
xdisplay
"
_NET_WM_NAME
"
true
)
;
req_type
=
XInternAtom
(
xdisplay
"
UTF8_STRING
"
true
)
;
if
(
!
property
|
|
!
req_type
)
{
return
false
;
}
{
ScopedXErrorHandler
handler
;
result
=
XGetWindowProperty
(
xdisplay
wmWindow
property
0L
INT32_MAX
false
req_type
&
actual_type_return
&
actual_format_return
&
nitems_return
&
bytes_after_return
&
prop_return
)
;
}
if
(
result
!
=
Success
|
|
bytes_after_return
!
=
0
)
{
return
false
;
}
wmName
=
reinterpret_cast
<
const
char
*
>
(
prop_return
)
;
return
true
;
}
#
define
kDesktopMutterSchema
"
org
.
gnome
.
mutter
"
#
define
kDesktopDynamicWorkspacesKey
"
dynamic
-
workspaces
"
static
bool
WorkspaceManagementDisabled
(
GdkWindow
*
gdk_window
)
{
if
(
Preferences
:
:
GetBool
(
"
widget
.
disable
-
workspace
-
management
"
false
)
)
{
return
true
;
}
if
(
Preferences
:
:
HasUserValue
(
"
widget
.
workspace
-
management
"
)
)
{
return
Preferences
:
:
GetBool
(
"
widget
.
workspace
-
management
"
)
;
}
static
const
char
*
currentDesktop
=
getenv
(
"
XDG_CURRENT_DESKTOP
"
)
;
if
(
currentDesktop
&
&
strstr
(
currentDesktop
"
GNOME
"
)
)
{
bool
usesDynamicWorkspaces
=
true
;
nsCOMPtr
<
nsIGSettingsService
>
gsettings
=
do_GetService
(
NS_GSETTINGSSERVICE_CONTRACTID
)
;
if
(
gsettings
)
{
nsCOMPtr
<
nsIGSettingsCollection
>
mutterSettings
;
gsettings
-
>
GetCollectionForSchema
(
nsLiteralCString
(
kDesktopMutterSchema
)
getter_AddRefs
(
mutterSettings
)
)
;
if
(
mutterSettings
)
{
if
(
NS_SUCCEEDED
(
mutterSettings
-
>
GetBoolean
(
nsLiteralCString
(
kDesktopDynamicWorkspacesKey
)
&
usesDynamicWorkspaces
)
)
)
{
}
}
}
return
usesDynamicWorkspaces
;
}
if
(
!
currentDesktop
)
{
nsAutoCString
wmName
;
if
(
GetWindowManagerName
(
gdk_window
wmName
)
)
{
if
(
wmName
.
EqualsLiteral
(
"
bspwm
"
)
)
{
return
true
;
}
if
(
wmName
.
EqualsLiteral
(
"
i3
"
)
)
{
return
true
;
}
}
}
return
false
;
}
void
nsWindow
:
:
GetWorkspaceID
(
nsAString
&
workspaceID
)
{
workspaceID
.
Truncate
(
)
;
if
(
!
GdkIsX11Display
(
)
|
|
!
mShell
)
{
return
;
}
LOG
(
"
nsWindow
:
:
GetWorkspaceID
(
)
\
n
"
)
;
GdkWindow
*
gdk_window
=
gtk_widget_get_window
(
mShell
)
;
if
(
!
gdk_window
)
{
LOG
(
"
missing
Gdk
window
quit
.
"
)
;
return
;
}
if
(
WorkspaceManagementDisabled
(
gdk_window
)
)
{
LOG
(
"
WorkspaceManagementDisabled
quit
.
"
)
;
return
;
}
GdkAtom
cardinal_atom
=
gdk_x11_xatom_to_atom
(
XA_CARDINAL
)
;
GdkAtom
type_returned
;
int
format_returned
;
int
length_returned
;
long
*
wm_desktop
;
if
(
!
gdk_property_get
(
gdk_window
gdk_atom_intern
(
"
_NET_WM_DESKTOP
"
FALSE
)
cardinal_atom
0
INT32_MAX
FALSE
&
type_returned
&
format_returned
&
length_returned
(
guchar
*
*
)
&
wm_desktop
)
)
{
LOG
(
"
gdk_property_get
(
)
failed
quit
.
"
)
;
return
;
}
LOG
(
"
got
workspace
ID
%
d
"
(
int32_t
)
wm_desktop
[
0
]
)
;
workspaceID
.
AppendInt
(
(
int32_t
)
wm_desktop
[
0
]
)
;
g_free
(
wm_desktop
)
;
}
void
nsWindow
:
:
MoveToWorkspace
(
const
nsAString
&
workspaceIDStr
)
{
nsresult
rv
=
NS_OK
;
int32_t
workspaceID
=
workspaceIDStr
.
ToInteger
(
&
rv
)
;
LOG
(
"
nsWindow
:
:
MoveToWorkspace
(
)
ID
%
d
"
workspaceID
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
workspaceID
|
|
!
GdkIsX11Display
(
)
|
|
!
mShell
)
{
LOG
(
"
MoveToWorkspace
disabled
quit
"
)
;
return
;
}
GdkWindow
*
gdk_window
=
gtk_widget_get_window
(
mShell
)
;
if
(
!
gdk_window
)
{
LOG
(
"
failed
to
get
GdkWindow
quit
.
"
)
;
return
;
}
XEvent
xevent
;
Display
*
xdisplay
=
gdk_x11_get_default_xdisplay
(
)
;
GdkScreen
*
screen
=
gdk_window_get_screen
(
gdk_window
)
;
Window
root_win
=
GDK_WINDOW_XID
(
gdk_screen_get_root_window
(
screen
)
)
;
GdkDisplay
*
display
=
gdk_window_get_display
(
gdk_window
)
;
Atom
type
=
gdk_x11_get_xatom_by_name_for_display
(
display
"
_NET_WM_DESKTOP
"
)
;
xevent
.
type
=
ClientMessage
;
xevent
.
xclient
.
type
=
ClientMessage
;
xevent
.
xclient
.
serial
=
0
;
xevent
.
xclient
.
send_event
=
TRUE
;
xevent
.
xclient
.
display
=
xdisplay
;
xevent
.
xclient
.
window
=
GDK_WINDOW_XID
(
gdk_window
)
;
xevent
.
xclient
.
message_type
=
type
;
xevent
.
xclient
.
format
=
32
;
xevent
.
xclient
.
data
.
l
[
0
]
=
workspaceID
;
xevent
.
xclient
.
data
.
l
[
1
]
=
X11CurrentTime
;
xevent
.
xclient
.
data
.
l
[
2
]
=
0
;
xevent
.
xclient
.
data
.
l
[
3
]
=
0
;
xevent
.
xclient
.
data
.
l
[
4
]
=
0
;
XSendEvent
(
xdisplay
root_win
FALSE
SubstructureNotifyMask
|
SubstructureRedirectMask
&
xevent
)
;
XFlush
(
xdisplay
)
;
LOG
(
"
moved
to
workspace
"
)
;
}
using
SetUserTimeFunc
=
void
(
*
)
(
GdkWindow
*
guint32
)
;
static
void
SetUserTimeAndStartupIDForActivatedWindow
(
GtkWidget
*
aWindow
)
{
nsGTKToolkit
*
GTKToolkit
=
nsGTKToolkit
:
:
GetToolkit
(
)
;
if
(
!
GTKToolkit
)
return
;
nsAutoCString
desktopStartupID
;
GTKToolkit
-
>
GetDesktopStartupID
(
&
desktopStartupID
)
;
if
(
desktopStartupID
.
IsEmpty
(
)
)
{
uint32_t
timestamp
=
GTKToolkit
-
>
GetFocusTimestamp
(
)
;
if
(
timestamp
)
{
gdk_window_focus
(
gtk_widget_get_window
(
aWindow
)
timestamp
)
;
GTKToolkit
-
>
SetFocusTimestamp
(
0
)
;
}
return
;
}
gtk_window_set_startup_id
(
GTK_WINDOW
(
aWindow
)
desktopStartupID
.
get
(
)
)
;
GTKToolkit
-
>
SetFocusTimestamp
(
0
)
;
GTKToolkit
-
>
SetDesktopStartupID
(
"
"
_ns
)
;
}
guint32
nsWindow
:
:
GetLastUserInputTime
(
)
{
GdkDisplay
*
gdkDisplay
=
gdk_display_get_default
(
)
;
guint32
timestamp
=
GdkIsX11Display
(
gdkDisplay
)
?
gdk_x11_display_get_user_time
(
gdkDisplay
)
:
gtk_get_current_event_time
(
)
;
if
(
sLastUserInputTime
!
=
GDK_CURRENT_TIME
&
&
TimestampIsNewerThan
(
sLastUserInputTime
timestamp
)
)
{
return
sLastUserInputTime
;
}
return
timestamp
;
}
#
ifdef
MOZ_WAYLAND
void
nsWindow
:
:
FocusWaylandWindow
(
const
char
*
aTokenID
)
{
auto
releaseToken
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
g_clear_pointer
(
&
mXdgToken
xdg_activation_token_v1_destroy
)
;
}
)
;
LOG
(
"
nsWindow
:
:
SetFocusWayland
"
)
;
if
(
IsDestroyed
(
)
)
{
LOG
(
"
already
destroyed
quit
.
"
)
;
return
;
}
wl_surface
*
surface
=
mGdkWindow
?
gdk_wayland_window_get_wl_surface
(
mGdkWindow
)
:
nullptr
;
if
(
!
surface
)
{
LOG
(
"
mGdkWindow
is
not
visible
quit
.
"
)
;
return
;
}
LOG
(
"
requesting
xdg
-
activation
surface
ID
%
d
"
wl_proxy_get_id
(
(
struct
wl_proxy
*
)
surface
)
)
;
xdg_activation_v1
*
xdg_activation
=
WaylandDisplayGet
(
)
-
>
GetXdgActivation
(
)
;
xdg_activation_v1_activate
(
xdg_activation
aTokenID
surface
)
;
}
static
void
token_done
(
gpointer
data
struct
xdg_activation_token_v1
*
provider
const
char
*
token
)
{
RefPtr
<
nsWindow
>
window
=
dont_AddRef
(
static_cast
<
nsWindow
*
>
(
data
)
)
;
window
-
>
FocusWaylandWindow
(
token
)
;
}
static
const
struct
xdg_activation_token_v1_listener
token_listener
=
{
token_done
}
;
void
nsWindow
:
:
RequestFocusWaylandWindow
(
RefPtr
<
nsWindow
>
aWindow
)
{
LOGW
(
"
nsWindow
:
:
RequestFocusWaylandWindow
(
%
p
)
gFocusWindow
%
p
"
(
void
*
)
aWindow
gFocusWindow
)
;
if
(
!
gFocusWindow
|
|
gFocusWindow
-
>
IsDestroyed
(
)
)
{
LOGW
(
"
missing
gFocusWindow
quit
.
"
)
;
return
;
}
RefPtr
<
nsWaylandDisplay
>
display
=
WaylandDisplayGet
(
)
;
xdg_activation_v1
*
xdg_activation
=
display
-
>
GetXdgActivation
(
)
;
if
(
!
xdg_activation
)
{
LOGW
(
"
xdg
-
activation
is
missing
quit
.
"
)
;
return
;
}
wl_surface
*
focusSurface
;
uint32_t
focusSerial
;
KeymapWrapper
:
:
GetFocusInfo
(
&
focusSurface
&
focusSerial
)
;
if
(
!
focusSurface
)
{
LOGW
(
"
We
'
re
missing
KeymapWrapper
focused
window
quit
.
"
)
;
return
;
}
GdkWindow
*
gdkWindow
=
gtk_widget_get_window
(
gFocusWindow
-
>
mShell
)
;
if
(
!
gdkWindow
)
{
LOGW
(
"
gFocusWindow
is
not
mapped
quit
.
"
)
;
return
;
}
wl_surface
*
surface
=
gdk_wayland_window_get_wl_surface
(
gdkWindow
)
;
if
(
focusSurface
!
=
surface
)
{
LOGW
(
"
focused
surface
%
p
and
gFocusWindow
surface
%
p
don
'
t
match
quit
.
"
focusSurface
surface
)
;
return
;
}
LOGW
(
"
requesting
xdg
-
activation
token
surface
%
p
ID
%
d
serial
%
d
seat
ID
"
"
%
d
"
focusSurface
focusSurface
?
wl_proxy_get_id
(
(
struct
wl_proxy
*
)
focusSurface
)
:
0
focusSerial
wl_proxy_get_id
(
(
struct
wl_proxy
*
)
KeymapWrapper
:
:
GetSeat
(
)
)
)
;
g_clear_pointer
(
&
aWindow
-
>
mXdgToken
xdg_activation_token_v1_destroy
)
;
aWindow
-
>
mXdgToken
=
xdg_activation_v1_get_activation_token
(
xdg_activation
)
;
xdg_activation_token_v1_add_listener
(
aWindow
-
>
mXdgToken
&
token_listener
do_AddRef
(
aWindow
)
.
take
(
)
)
;
xdg_activation_token_v1_set_serial
(
aWindow
-
>
mXdgToken
focusSerial
KeymapWrapper
:
:
GetSeat
(
)
)
;
xdg_activation_token_v1_set_surface
(
aWindow
-
>
mXdgToken
focusSurface
)
;
xdg_activation_token_v1_commit
(
aWindow
-
>
mXdgToken
)
;
}
#
endif
void
nsWindow
:
:
SetFocus
(
Raise
aRaise
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
{
LOG
(
"
nsWindow
:
:
SetFocus
Raise
%
d
\
n
"
aRaise
=
=
Raise
:
:
Yes
)
;
GtkWidget
*
toplevelWidget
=
gtk_widget_get_toplevel
(
GTK_WIDGET
(
mContainer
)
)
;
LOG
(
"
gFocusWindow
[
%
p
]
\
n
"
gFocusWindow
)
;
LOG
(
"
mContainer
[
%
p
]
\
n
"
GTK_WIDGET
(
mContainer
)
)
;
LOG
(
"
Toplevel
widget
[
%
p
]
\
n
"
toplevelWidget
)
;
if
(
gRaiseWindows
&
&
aRaise
=
=
Raise
:
:
Yes
&
&
toplevelWidget
&
&
!
gtk_widget_has_focus
(
toplevelWidget
)
)
{
if
(
gtk_widget_get_visible
(
mShell
)
)
{
gdk_window_show_unraised
(
gtk_widget_get_window
(
mShell
)
)
;
SetUrgencyHint
(
mShell
false
)
;
}
}
RefPtr
<
nsWindow
>
toplevelWindow
=
get_window_for_gtk_widget
(
toplevelWidget
)
;
if
(
!
toplevelWindow
)
{
LOG
(
"
missing
toplevel
nsWindow
quit
\
n
"
)
;
return
;
}
if
(
aRaise
=
=
Raise
:
:
Yes
)
{
if
(
gRaiseWindows
&
&
toplevelWindow
-
>
mIsShown
&
&
toplevelWindow
-
>
mShell
&
&
!
gtk_window_is_active
(
GTK_WINDOW
(
toplevelWindow
-
>
mShell
)
)
)
{
uint32_t
timestamp
=
GDK_CURRENT_TIME
;
nsGTKToolkit
*
GTKToolkit
=
nsGTKToolkit
:
:
GetToolkit
(
)
;
if
(
GTKToolkit
)
{
timestamp
=
GTKToolkit
-
>
GetFocusTimestamp
(
)
;
GTKToolkit
-
>
SetFocusTimestamp
(
0
)
;
}
if
(
!
timestamp
)
{
timestamp
=
GetLastUserInputTime
(
)
;
}
LOG
(
"
requesting
toplevel
activation
[
%
p
]
\
n
"
(
void
*
)
toplevelWindow
)
;
gtk_window_present_with_time
(
GTK_WINDOW
(
toplevelWindow
-
>
mShell
)
timestamp
)
;
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
RequestFocusWaylandWindow
(
toplevelWindow
)
;
}
#
endif
}
return
;
}
if
(
!
gtk_widget_is_focus
(
GTK_WIDGET
(
mContainer
)
)
)
{
gBlockActivateEvent
=
true
;
gtk_widget_grab_focus
(
GTK_WIDGET
(
mContainer
)
)
;
gBlockActivateEvent
=
false
;
}
if
(
gFocusWindow
=
=
this
)
{
LOG
(
"
already
have
focus
"
)
;
return
;
}
gFocusWindow
=
this
;
if
(
mIMContext
)
{
mIMContext
-
>
OnFocusWindow
(
this
)
;
}
LOG
(
"
widget
now
has
focus
in
SetFocus
(
)
"
)
;
}
LayoutDeviceIntRect
nsWindow
:
:
GetScreenBounds
(
)
{
LayoutDeviceIntRect
rect
;
if
(
mContainer
)
{
gint
x
y
;
gdk_window_get_root_origin
(
gtk_widget_get_window
(
GTK_WIDGET
(
mContainer
)
)
&
x
&
y
)
;
rect
.
MoveTo
(
GdkPointToDevicePixels
(
{
x
y
}
)
)
;
}
else
{
rect
.
MoveTo
(
WidgetToScreenOffset
(
)
)
;
}
rect
.
SizeTo
(
mBounds
.
Size
(
)
)
;
#
if
MOZ_LOGGING
gint
scale
=
GdkCeiledScaleFactor
(
)
;
LOG
(
"
GetScreenBounds
%
d
%
d
-
>
%
d
x
%
d
unscaled
%
d
%
d
-
>
%
d
x
%
d
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
rect
.
x
/
scale
rect
.
y
/
scale
rect
.
width
/
scale
rect
.
height
/
scale
)
;
#
endif
return
rect
;
}
LayoutDeviceIntSize
nsWindow
:
:
GetClientSize
(
)
{
return
LayoutDeviceIntSize
(
mBounds
.
width
mBounds
.
height
)
;
}
LayoutDeviceIntRect
nsWindow
:
:
GetClientBounds
(
)
{
LayoutDeviceIntRect
rect
=
GetBounds
(
)
;
rect
.
MoveBy
(
GetClientOffset
(
)
)
;
return
rect
;
}
void
nsWindow
:
:
UpdateClientOffsetFromFrameExtents
(
)
{
AUTO_PROFILER_LABEL
(
"
nsWindow
:
:
UpdateClientOffsetFromFrameExtents
"
OTHER
)
;
if
(
mGtkWindowDecoration
=
=
GTK_DECORATION_CLIENT
&
&
mDrawInTitlebar
)
{
return
;
}
if
(
!
mShell
|
|
gtk_window_get_window_type
(
GTK_WINDOW
(
mShell
)
)
=
=
GTK_WINDOW_POPUP
)
{
mClientOffset
=
nsIntPoint
(
0
0
)
;
return
;
}
GdkAtom
cardinal_atom
=
gdk_x11_xatom_to_atom
(
XA_CARDINAL
)
;
GdkAtom
type_returned
;
int
format_returned
;
int
length_returned
;
long
*
frame_extents
;
if
(
!
gdk_property_get
(
gtk_widget_get_window
(
mShell
)
gdk_atom_intern
(
"
_NET_FRAME_EXTENTS
"
FALSE
)
cardinal_atom
0
4
*
4
FALSE
&
type_returned
&
format_returned
&
length_returned
(
guchar
*
*
)
&
frame_extents
)
|
|
length_returned
/
sizeof
(
glong
)
!
=
4
)
{
mClientOffset
=
nsIntPoint
(
0
0
)
;
}
else
{
auto
left
=
int32_t
(
frame_extents
[
0
]
)
;
auto
top
=
int32_t
(
frame_extents
[
2
]
)
;
g_free
(
frame_extents
)
;
mClientOffset
=
nsIntPoint
(
left
top
)
;
}
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
LOG
(
"
nsWindow
:
:
UpdateClientOffsetFromFrameExtents
%
d
%
d
\
n
"
mClientOffset
.
x
mClientOffset
.
y
)
;
}
LayoutDeviceIntPoint
nsWindow
:
:
GetClientOffset
(
)
{
return
GdkIsX11Display
(
)
?
LayoutDeviceIntPoint
:
:
FromUnknownPoint
(
mClientOffset
)
:
LayoutDeviceIntPoint
(
0
0
)
;
}
gboolean
nsWindow
:
:
OnPropertyNotifyEvent
(
GtkWidget
*
aWidget
GdkEventProperty
*
aEvent
)
{
if
(
aEvent
-
>
atom
=
=
gdk_atom_intern
(
"
_NET_FRAME_EXTENTS
"
FALSE
)
)
{
UpdateClientOffsetFromFrameExtents
(
)
;
return
FALSE
;
}
if
(
!
mGdkWindow
)
{
return
FALSE
;
}
if
(
GetCurrentTimeGetter
(
)
-
>
PropertyNotifyHandler
(
aWidget
aEvent
)
)
{
return
TRUE
;
}
return
FALSE
;
}
static
GdkCursor
*
GetCursorForImage
(
const
nsIWidget
:
:
Cursor
&
aCursor
int32_t
aWidgetScaleFactor
)
{
if
(
!
aCursor
.
IsCustom
(
)
)
{
return
nullptr
;
}
nsIntSize
size
=
nsIWidget
:
:
CustomCursorSize
(
aCursor
)
;
int32_t
gtkScale
=
std
:
:
max
(
aWidgetScaleFactor
int32_t
(
std
:
:
ceil
(
std
:
:
max
(
aCursor
.
mResolution
.
mX
aCursor
.
mResolution
.
mY
)
)
)
)
;
if
(
size
.
width
>
128
|
|
size
.
height
>
128
)
{
return
nullptr
;
}
nsIntSize
rasterSize
=
size
*
gtkScale
;
GdkPixbuf
*
pixbuf
=
nsImageToPixbuf
:
:
ImageToPixbuf
(
aCursor
.
mContainer
Some
(
rasterSize
)
)
;
if
(
!
pixbuf
)
{
return
nullptr
;
}
if
(
!
gdk_pixbuf_get_has_alpha
(
pixbuf
)
)
{
GdkPixbuf
*
alphaBuf
=
gdk_pixbuf_add_alpha
(
pixbuf
FALSE
0
0
0
)
;
g_object_unref
(
pixbuf
)
;
pixbuf
=
alphaBuf
;
if
(
!
alphaBuf
)
{
return
nullptr
;
}
}
auto
CleanupPixBuf
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
g_object_unref
(
pixbuf
)
;
}
)
;
cairo_surface_t
*
surface
=
gdk_cairo_surface_create_from_pixbuf
(
pixbuf
gtkScale
nullptr
)
;
if
(
!
surface
)
{
return
nullptr
;
}
auto
CleanupSurface
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
cairo_surface_destroy
(
surface
)
;
}
)
;
return
gdk_cursor_new_from_surface
(
gdk_display_get_default
(
)
surface
aCursor
.
mHotspotX
aCursor
.
mHotspotY
)
;
}
void
nsWindow
:
:
SetCursor
(
const
Cursor
&
aCursor
)
{
if
(
!
mContainer
&
&
mGdkWindow
)
{
if
(
nsWindow
*
window
=
GetContainerWindow
(
)
)
{
window
-
>
SetCursor
(
aCursor
)
;
}
return
;
}
if
(
!
mUpdateCursor
&
&
mCursor
=
=
aCursor
)
{
return
;
}
mUpdateCursor
=
false
;
mCursor
=
aCursor
;
bool
fromImage
=
true
;
GdkCursor
*
newCursor
=
GetCursorForImage
(
aCursor
GdkCeiledScaleFactor
(
)
)
;
if
(
!
newCursor
)
{
fromImage
=
false
;
newCursor
=
get_gtk_cursor
(
aCursor
.
mDefaultCursor
)
;
}
auto
CleanupCursor
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
if
(
fromImage
)
{
g_object_unref
(
newCursor
)
;
}
}
)
;
if
(
!
newCursor
|
|
!
mContainer
)
{
return
;
}
gdk_window_set_cursor
(
gtk_widget_get_window
(
GTK_WIDGET
(
mContainer
)
)
newCursor
)
;
}
void
nsWindow
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
if
(
!
mGdkWindow
)
return
;
GdkRectangle
rect
=
DevicePixelsToGdkRectRoundOut
(
aRect
)
;
gdk_window_invalidate_rect
(
mGdkWindow
&
rect
FALSE
)
;
LOG
(
"
Invalidate
(
rect
)
:
%
d
%
d
%
d
%
d
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
}
void
*
nsWindow
:
:
GetNativeData
(
uint32_t
aDataType
)
{
switch
(
aDataType
)
{
case
NS_NATIVE_WINDOW
:
case
NS_NATIVE_WIDGET
:
{
return
mGdkWindow
;
}
case
NS_NATIVE_DISPLAY
:
{
#
ifdef
MOZ_X11
GdkDisplay
*
gdkDisplay
=
gdk_display_get_default
(
)
;
if
(
GdkIsX11Display
(
gdkDisplay
)
)
{
return
GDK_DISPLAY_XDISPLAY
(
gdkDisplay
)
;
}
#
endif
return
nullptr
;
}
case
NS_NATIVE_SHELLWIDGET
:
return
GetToplevelWidget
(
)
;
case
NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID
:
if
(
GdkIsX11Display
(
)
)
{
return
(
void
*
)
GDK_WINDOW_XID
(
gdk_window_get_toplevel
(
mGdkWindow
)
)
;
}
NS_WARNING
(
"
nsWindow
:
:
GetNativeData
(
)
:
NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID
is
not
"
"
handled
on
Wayland
!
"
)
;
return
nullptr
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
{
void
*
pseudoIMEContext
=
GetPseudoIMEContext
(
)
;
if
(
pseudoIMEContext
)
{
return
pseudoIMEContext
;
}
if
(
!
mIMContext
)
{
return
this
;
}
return
mIMContext
.
get
(
)
;
}
case
NS_NATIVE_OPENGL_CONTEXT
:
return
nullptr
;
case
NS_NATIVE_EGL_WINDOW
:
{
void
*
eglWindow
=
nullptr
;
if
(
GdkIsX11Display
(
)
)
{
eglWindow
=
mGdkWindow
?
(
void
*
)
GDK_WINDOW_XID
(
mGdkWindow
)
:
nullptr
;
}
#
ifdef
MOZ_WAYLAND
else
{
eglWindow
=
moz_container_wayland_get_egl_window
(
mContainer
FractionalScaleFactor
(
)
)
;
}
#
endif
LOG
(
"
Get
NS_NATIVE_EGL_WINDOW
window
%
p
"
eglWindow
)
;
return
eglWindow
;
}
default
:
NS_WARNING
(
"
nsWindow
:
:
GetNativeData
called
with
bad
value
"
)
;
return
nullptr
;
}
}
nsresult
nsWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
if
(
!
mShell
)
return
NS_OK
;
#
define
UTF8_FOLLOWBYTE
(
ch
)
(
(
(
ch
)
&
0xC0
)
=
=
0x80
)
NS_ConvertUTF16toUTF8
titleUTF8
(
aTitle
)
;
if
(
titleUTF8
.
Length
(
)
>
NS_WINDOW_TITLE_MAX_LENGTH
)
{
uint32_t
len
=
NS_WINDOW_TITLE_MAX_LENGTH
;
while
(
UTF8_FOLLOWBYTE
(
titleUTF8
[
len
]
)
)
-
-
len
;
titleUTF8
.
Truncate
(
len
)
;
}
gtk_window_set_title
(
GTK_WINDOW
(
mShell
)
(
const
char
*
)
titleUTF8
.
get
(
)
)
;
return
NS_OK
;
}
void
nsWindow
:
:
SetIcon
(
const
nsAString
&
aIconSpec
)
{
if
(
!
mShell
)
return
;
nsAutoCString
iconName
;
if
(
aIconSpec
.
EqualsLiteral
(
"
default
"
)
)
{
nsAutoString
brandName
;
WidgetUtils
:
:
GetBrandShortName
(
brandName
)
;
if
(
brandName
.
IsEmpty
(
)
)
{
brandName
.
AssignLiteral
(
u
"
Mozilla
"
)
;
}
AppendUTF16toUTF8
(
brandName
iconName
)
;
ToLowerCase
(
iconName
)
;
}
else
{
AppendUTF16toUTF8
(
aIconSpec
iconName
)
;
}
nsCOMPtr
<
nsIFile
>
iconFile
;
nsAutoCString
path
;
gint
*
iconSizes
=
gtk_icon_theme_get_icon_sizes
(
gtk_icon_theme_get_default
(
)
iconName
.
get
(
)
)
;
bool
foundIcon
=
(
iconSizes
[
0
]
!
=
0
)
;
g_free
(
iconSizes
)
;
if
(
!
foundIcon
)
{
const
char16_t
extensions
[
9
]
[
8
]
=
{
u
"
.
png
"
u
"
16
.
png
"
u
"
32
.
png
"
u
"
48
.
png
"
u
"
64
.
png
"
u
"
128
.
png
"
u
"
256
.
png
"
u
"
.
xpm
"
u
"
16
.
xpm
"
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
extensions
)
;
i
+
+
)
{
if
(
i
=
=
ArrayLength
(
extensions
)
-
2
&
&
foundIcon
)
break
;
ResolveIconName
(
aIconSpec
nsDependentString
(
extensions
[
i
]
)
getter_AddRefs
(
iconFile
)
)
;
if
(
iconFile
)
{
iconFile
-
>
GetNativePath
(
path
)
;
GdkPixbuf
*
icon
=
gdk_pixbuf_new_from_file
(
path
.
get
(
)
nullptr
)
;
if
(
icon
)
{
gtk_icon_theme_add_builtin_icon
(
iconName
.
get
(
)
gdk_pixbuf_get_height
(
icon
)
icon
)
;
g_object_unref
(
icon
)
;
foundIcon
=
true
;
}
}
}
}
if
(
foundIcon
)
{
gtk_window_set_icon_name
(
GTK_WINDOW
(
mShell
)
iconName
.
get
(
)
)
;
}
}
LayoutDeviceIntPoint
nsWindow
:
:
WidgetToScreenOffset
(
)
{
nsIntPoint
origin
(
0
0
)
;
if
(
mGdkWindow
)
{
GetWindowOrigin
(
mGdkWindow
&
origin
.
x
&
origin
.
y
)
;
}
return
GdkPointToDevicePixels
(
{
origin
.
x
origin
.
y
}
)
;
}
void
nsWindow
:
:
CaptureMouse
(
bool
aCapture
)
{
LOG
(
"
nsWindow
:
:
CaptureMouse
(
)
"
)
;
if
(
mIsDestroyed
)
{
return
;
}
if
(
aCapture
)
{
gtk_grab_add
(
GTK_WIDGET
(
mContainer
)
)
;
GrabPointer
(
GetLastUserInputTime
(
)
)
;
}
else
{
ReleaseGrabs
(
)
;
gtk_grab_remove
(
GTK_WIDGET
(
mContainer
)
)
;
}
}
void
nsWindow
:
:
CaptureRollupEvents
(
nsIRollupListener
*
aListener
bool
aDoCapture
)
{
LOG
(
"
CaptureRollupEvents
(
)
%
i
\
n
"
int
(
aDoCapture
)
)
;
if
(
mIsDestroyed
)
{
return
;
}
if
(
aDoCapture
)
{
gRollupListener
=
aListener
;
if
(
!
GdkIsWaylandDisplay
(
)
&
&
!
mIsDragPopup
&
&
!
nsWindow
:
:
DragInProgress
(
)
)
{
gtk_grab_add
(
GTK_WIDGET
(
mContainer
)
)
;
GrabPointer
(
GetLastUserInputTime
(
)
)
;
}
}
else
{
if
(
!
nsWindow
:
:
DragInProgress
(
)
)
{
ReleaseGrabs
(
)
;
}
LOG
(
"
remove
mContainer
grab
[
%
p
]
\
n
"
this
)
;
gtk_grab_remove
(
GTK_WIDGET
(
mContainer
)
)
;
gRollupListener
=
nullptr
;
}
}
nsresult
nsWindow
:
:
GetAttention
(
int32_t
aCycleCount
)
{
LOG
(
"
nsWindow
:
:
GetAttention
"
)
;
GtkWidget
*
top_window
=
GetToplevelWidget
(
)
;
GtkWidget
*
top_focused_window
=
gFocusWindow
?
gFocusWindow
-
>
GetToplevelWidget
(
)
:
nullptr
;
if
(
top_window
&
&
(
gtk_widget_get_visible
(
top_window
)
)
&
&
top_window
!
=
top_focused_window
)
{
SetUrgencyHint
(
top_window
true
)
;
}
return
NS_OK
;
}
bool
nsWindow
:
:
HasPendingInputEvent
(
)
{
bool
haveEvent
=
false
;
#
ifdef
MOZ_X11
XEvent
ev
;
if
(
GdkIsX11Display
(
)
)
{
Display
*
display
=
GDK_DISPLAY_XDISPLAY
(
gdk_display_get_default
(
)
)
;
haveEvent
=
XCheckMaskEvent
(
display
KeyPressMask
|
KeyReleaseMask
|
ButtonPressMask
|
ButtonReleaseMask
|
EnterWindowMask
|
LeaveWindowMask
|
PointerMotionMask
|
PointerMotionHintMask
|
Button1MotionMask
|
Button2MotionMask
|
Button3MotionMask
|
Button4MotionMask
|
Button5MotionMask
|
ButtonMotionMask
|
KeymapStateMask
|
VisibilityChangeMask
|
StructureNotifyMask
|
ResizeRedirectMask
|
SubstructureNotifyMask
|
SubstructureRedirectMask
|
FocusChangeMask
|
PropertyChangeMask
|
ColormapChangeMask
|
OwnerGrabButtonMask
&
ev
)
;
if
(
haveEvent
)
{
XPutBackEvent
(
display
&
ev
)
;
}
}
#
endif
return
haveEvent
;
}
#
ifdef
cairo_copy_clip_rectangle_list
#
error
"
Looks
like
we
'
re
including
Mozilla
'
s
cairo
instead
of
system
cairo
"
#
endif
static
bool
ExtractExposeRegion
(
LayoutDeviceIntRegion
&
aRegion
cairo_t
*
cr
)
{
cairo_rectangle_list_t
*
rects
=
cairo_copy_clip_rectangle_list
(
cr
)
;
if
(
rects
-
>
status
!
=
CAIRO_STATUS_SUCCESS
)
{
NS_WARNING
(
"
Failed
to
obtain
cairo
rectangle
list
.
"
)
;
return
false
;
}
for
(
int
i
=
0
;
i
<
rects
-
>
num_rectangles
;
i
+
+
)
{
const
cairo_rectangle_t
&
r
=
rects
-
>
rectangles
[
i
]
;
aRegion
.
Or
(
aRegion
LayoutDeviceIntRect
:
:
Truncate
(
(
float
)
r
.
x
(
float
)
r
.
y
(
float
)
r
.
width
(
float
)
r
.
height
)
)
;
}
cairo_rectangle_list_destroy
(
rects
)
;
return
true
;
}
#
ifdef
MOZ_WAYLAND
void
nsWindow
:
:
CreateCompositorVsyncDispatcher
(
)
{
if
(
!
mWaylandVsyncSource
)
{
nsBaseWidget
:
:
CreateCompositorVsyncDispatcher
(
)
;
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
if
(
!
mCompositorVsyncDispatcherLock
)
{
mCompositorVsyncDispatcherLock
=
MakeUnique
<
Mutex
>
(
"
mCompositorVsyncDispatcherLock
"
)
;
}
MutexAutoLock
lock
(
*
mCompositorVsyncDispatcherLock
)
;
if
(
!
mCompositorVsyncDispatcher
)
{
mCompositorVsyncDispatcher
=
new
CompositorVsyncDispatcher
(
mWaylandVsyncSource
)
;
}
}
}
#
endif
gboolean
nsWindow
:
:
OnExposeEvent
(
cairo_t
*
cr
)
{
MaybeDispatchResized
(
)
;
if
(
mIsDestroyed
)
{
return
FALSE
;
}
if
(
!
mGdkWindow
|
|
!
mHasMappedToplevel
)
{
return
FALSE
;
}
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
&
&
!
moz_container_wayland_can_draw
(
mContainer
)
)
{
return
FALSE
;
}
#
endif
nsIWidgetListener
*
listener
=
GetListener
(
)
;
if
(
!
listener
)
return
FALSE
;
LOG
(
"
received
expose
event
%
p
0x
%
lx
(
rects
follow
)
:
\
n
"
mGdkWindow
GdkIsX11Display
(
)
?
gdk_x11_window_get_xid
(
mGdkWindow
)
:
0
)
;
LayoutDeviceIntRegion
exposeRegion
;
if
(
!
ExtractExposeRegion
(
exposeRegion
cr
)
)
{
return
FALSE
;
}
gint
scale
=
GdkCeiledScaleFactor
(
)
;
LayoutDeviceIntRegion
region
=
exposeRegion
;
region
.
ScaleRoundOut
(
scale
scale
)
;
WindowRenderer
*
renderer
=
GetWindowRenderer
(
)
;
WebRenderLayerManager
*
layerManager
=
renderer
-
>
AsWebRender
(
)
;
KnowsCompositor
*
knowsCompositor
=
renderer
-
>
AsKnowsCompositor
(
)
;
if
(
knowsCompositor
&
&
layerManager
&
&
mCompositorSession
)
{
layerManager
-
>
SetNeedsComposite
(
true
)
;
layerManager
-
>
SendInvalidRegion
(
region
.
ToUnknownRegion
(
)
)
;
}
RefPtr
<
nsWindow
>
strongThis
(
this
)
;
{
listener
-
>
WillPaintWindow
(
this
)
;
if
(
!
mGdkWindow
)
return
TRUE
;
listener
=
GetListener
(
)
;
if
(
!
listener
)
return
FALSE
;
}
if
(
knowsCompositor
&
&
layerManager
&
&
layerManager
-
>
NeedsComposite
(
)
)
{
layerManager
-
>
ScheduleComposite
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
layerManager
-
>
SetNeedsComposite
(
false
)
;
}
region
.
And
(
region
LayoutDeviceIntRect
(
0
0
mBounds
.
width
mBounds
.
height
)
)
;
bool
shaped
=
false
;
if
(
eTransparencyTransparent
=
=
GetTransparencyMode
(
)
)
{
auto
*
window
=
static_cast
<
nsWindow
*
>
(
GetTopLevelWidget
(
)
)
;
if
(
mTransparencyBitmapForTitlebar
)
{
if
(
mSizeState
=
=
nsSizeMode_Normal
)
{
window
-
>
UpdateTitlebarTransparencyBitmap
(
)
;
}
else
{
window
-
>
ClearTransparencyBitmap
(
)
;
}
}
else
{
if
(
mHasAlphaVisual
)
{
window
-
>
ClearTransparencyBitmap
(
)
;
}
else
{
shaped
=
true
;
}
}
}
if
(
region
.
IsEmpty
(
)
)
{
return
TRUE
;
}
if
(
renderer
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
{
listener
-
>
PaintWindow
(
this
region
)
;
listener
=
GetListener
(
)
;
if
(
!
listener
)
return
TRUE
;
listener
-
>
DidPaintWindow
(
)
;
return
TRUE
;
}
BufferMode
layerBuffering
=
BufferMode
:
:
BUFFERED
;
RefPtr
<
DrawTarget
>
dt
=
StartRemoteDrawingInRegion
(
region
&
layerBuffering
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
return
FALSE
;
}
RefPtr
<
gfxContext
>
ctx
;
IntRect
boundsRect
=
region
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
IntPoint
offset
(
0
0
)
;
if
(
dt
-
>
GetSize
(
)
=
=
boundsRect
.
Size
(
)
)
{
offset
=
boundsRect
.
TopLeft
(
)
;
dt
-
>
SetTransform
(
Matrix
:
:
Translation
(
-
offset
)
)
;
}
#
ifdef
MOZ_X11
if
(
shaped
)
{
dt
-
>
PushClipRect
(
Rect
(
boundsRect
)
)
;
layerBuffering
=
BufferMode
:
:
BUFFER_NONE
;
RefPtr
<
DrawTarget
>
destDT
=
dt
-
>
CreateSimilarDrawTarget
(
boundsRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
destDT
|
|
!
destDT
-
>
IsValid
(
)
)
{
return
FALSE
;
}
destDT
-
>
SetTransform
(
Matrix
:
:
Translation
(
-
boundsRect
.
TopLeft
(
)
)
)
;
ctx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
destDT
)
;
}
else
{
gfxUtils
:
:
ClipToRegion
(
dt
region
.
ToUnknownRegion
(
)
)
;
ctx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
dt
)
;
}
MOZ_ASSERT
(
ctx
)
;
#
if
0
#
ifdef
DEBUG
if
(
0
&
&
WANT_PAINT_FLASHING
&
&
gtk_widget_get_window
(
aEvent
)
)
gdk_window_flash
(
mGdkWindow
1
100
aEvent
-
>
region
)
;
#
endif
#
endif
#
endif
bool
painted
=
false
;
{
if
(
renderer
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_NONE
)
{
if
(
GetTransparencyMode
(
)
=
=
eTransparencyTransparent
&
&
layerBuffering
=
=
BufferMode
:
:
BUFFER_NONE
&
&
mHasAlphaVisual
)
{
dt
-
>
ClearRect
(
Rect
(
boundsRect
)
)
;
}
AutoLayerManagerSetup
setupLayerManager
(
this
ctx
layerBuffering
)
;
painted
=
listener
-
>
PaintWindow
(
this
region
)
;
listener
=
GetListener
(
)
;
if
(
!
listener
)
return
TRUE
;
}
}
#
ifdef
MOZ_X11
if
(
shaped
)
{
if
(
MOZ_LIKELY
(
!
mIsDestroyed
)
)
{
if
(
painted
)
{
RefPtr
<
SourceSurface
>
surf
=
ctx
-
>
GetDrawTarget
(
)
-
>
Snapshot
(
)
;
UpdateAlpha
(
surf
boundsRect
)
;
dt
-
>
DrawSurface
(
surf
Rect
(
boundsRect
)
Rect
(
0
0
boundsRect
.
width
boundsRect
.
height
)
DrawSurfaceOptions
(
SamplingFilter
:
:
POINT
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
}
}
ctx
=
nullptr
;
dt
-
>
PopClip
(
)
;
#
endif
EndRemoteDrawingInRegion
(
dt
region
)
;
listener
-
>
DidPaintWindow
(
)
;
cairo_region_t
*
dirtyArea
=
gdk_window_get_update_area
(
mGdkWindow
)
;
if
(
dirtyArea
)
{
gdk_window_invalidate_region
(
mGdkWindow
dirtyArea
false
)
;
cairo_region_destroy
(
dirtyArea
)
;
gdk_window_process_updates
(
mGdkWindow
false
)
;
}
return
TRUE
;
}
void
nsWindow
:
:
UpdateAlpha
(
SourceSurface
*
aSourceSurface
nsIntRect
aBoundsRect
)
{
int32_t
stride
=
GetAlignedStride
<
4
>
(
aBoundsRect
.
width
BytesPerPixel
(
SurfaceFormat
:
:
A8
)
)
;
if
(
stride
=
=
0
)
{
return
;
}
int32_t
bufferSize
=
stride
*
aBoundsRect
.
height
;
auto
imageBuffer
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
bufferSize
)
;
{
RefPtr
<
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
CreateDrawTargetForData
(
imageBuffer
.
get
(
)
aBoundsRect
.
Size
(
)
stride
SurfaceFormat
:
:
A8
)
;
if
(
drawTarget
)
{
drawTarget
-
>
DrawSurface
(
aSourceSurface
Rect
(
0
0
aBoundsRect
.
width
aBoundsRect
.
height
)
Rect
(
0
0
aSourceSurface
-
>
GetSize
(
)
.
width
aSourceSurface
-
>
GetSize
(
)
.
height
)
DrawSurfaceOptions
(
SamplingFilter
:
:
POINT
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
}
UpdateTranslucentWindowAlphaInternal
(
aBoundsRect
imageBuffer
.
get
(
)
stride
)
;
}
gboolean
nsWindow
:
:
OnConfigureEvent
(
GtkWidget
*
aWidget
GdkEventConfigure
*
aEvent
)
{
LOG
(
"
configure
event
%
d
%
d
-
>
%
d
x
%
d
scale
%
d
\
n
"
aEvent
-
>
x
aEvent
-
>
y
aEvent
-
>
width
aEvent
-
>
height
mGdkWindow
?
gdk_window_get_scale_factor
(
mGdkWindow
)
:
-
1
)
;
if
(
mPendingConfigures
>
0
)
{
mPendingConfigures
-
-
;
}
if
(
mWindowType
=
=
eWindowType_toplevel
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mGdkWindow
"
Getting
configure
for
invisible
window
?
"
)
;
if
(
mWindowScaleFactor
!
=
gdk_window_get_scale_factor
(
mGdkWindow
)
)
{
LOG
(
"
scale
factor
changed
to
%
d
return
early
"
gdk_window_get_scale_factor
(
mGdkWindow
)
)
;
return
FALSE
;
}
}
LayoutDeviceIntRect
screenBounds
=
GetScreenBounds
(
)
;
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
{
if
(
mBounds
.
x
!
=
screenBounds
.
x
|
|
mBounds
.
y
!
=
screenBounds
.
y
)
{
CheckForRollup
(
0
0
false
true
)
;
}
}
NS_ASSERTION
(
GTK_IS_WINDOW
(
aWidget
)
"
Configure
event
on
widget
that
is
not
a
GtkWindow
"
)
;
if
(
gtk_window_get_window_type
(
GTK_WINDOW
(
aWidget
)
)
=
=
GTK_WINDOW_POPUP
)
{
GetWindowRenderer
(
)
-
>
FlushRendering
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
return
FALSE
;
}
mBounds
.
MoveTo
(
screenBounds
.
TopLeft
(
)
)
;
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
if
(
!
mBoundsAreValid
)
{
GtkAllocation
allocation
=
{
-
1
-
1
0
0
}
;
gtk_window_get_size
(
GTK_WINDOW
(
mShell
)
&
allocation
.
width
&
allocation
.
height
)
;
OnSizeAllocate
(
&
allocation
)
;
}
return
FALSE
;
}
void
nsWindow
:
:
OnMap
(
)
{
LOG
(
"
nsWindow
:
:
OnMap
"
)
;
mIsMapped
=
true
;
ConfigureGdkWindow
(
)
;
}
void
nsWindow
:
:
OnUnrealize
(
)
{
LOG
(
"
nsWindow
:
:
OnUnrealize
GdkWindow
%
p
"
mGdkWindow
)
;
mIsMapped
=
false
;
ReleaseGdkWindow
(
)
;
}
void
nsWindow
:
:
OnSizeAllocate
(
GtkAllocation
*
aAllocation
)
{
LOG
(
"
nsWindow
:
:
OnSizeAllocate
%
d
%
d
-
>
%
d
x
%
d
\
n
"
aAllocation
-
>
x
aAllocation
-
>
y
aAllocation
-
>
width
aAllocation
-
>
height
)
;
if
(
mGtkWindowDecoration
=
=
GTK_DECORATION_CLIENT
)
{
if
(
GdkIsWaylandDisplay
(
)
|
|
(
GdkIsX11Display
(
)
&
&
mDrawInTitlebar
)
)
{
UpdateClientOffsetFromCSDWindow
(
)
;
}
}
mBoundsAreValid
=
true
;
LayoutDeviceIntSize
size
=
GdkRectToDevicePixels
(
*
aAllocation
)
.
Size
(
)
;
if
(
mBounds
.
Size
(
)
=
=
size
)
{
LOG
(
"
Already
the
same
size
"
)
;
return
;
}
if
(
mGdkWindow
)
{
if
(
mBounds
.
width
<
size
.
width
)
{
GdkRectangle
rect
=
DevicePixelsToGdkRectRoundOut
(
LayoutDeviceIntRect
(
mBounds
.
width
0
size
.
width
-
mBounds
.
width
size
.
height
)
)
;
gdk_window_invalidate_rect
(
mGdkWindow
&
rect
FALSE
)
;
}
if
(
mBounds
.
height
<
size
.
height
)
{
GdkRectangle
rect
=
DevicePixelsToGdkRectRoundOut
(
LayoutDeviceIntRect
(
0
mBounds
.
height
size
.
width
size
.
height
-
mBounds
.
height
)
)
;
gdk_window_invalidate_rect
(
mGdkWindow
&
rect
FALSE
)
;
}
}
mBounds
.
SizeTo
(
size
)
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
NotifyClientSizeChanged
(
GetClientSize
(
)
)
;
}
mNeedsDispatchResized
=
true
;
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsWindow
:
:
MaybeDispatchResized
"
this
&
nsWindow
:
:
MaybeDispatchResized
)
)
;
}
void
nsWindow
:
:
OnDeleteEvent
(
)
{
if
(
mWidgetListener
)
mWidgetListener
-
>
RequestWindowClose
(
this
)
;
}
void
nsWindow
:
:
OnEnterNotifyEvent
(
GdkEventCrossing
*
aEvent
)
{
if
(
aEvent
-
>
subwindow
!
=
nullptr
)
return
;
DispatchMissedButtonReleases
(
aEvent
)
;
if
(
is_parent_ungrab_enter
(
aEvent
)
)
{
return
;
}
WidgetMouseEvent
event
(
true
eMouseEnterIntoWidget
this
WidgetMouseEvent
:
:
eReal
)
;
event
.
mRefPoint
=
GdkEventCoordsToDevicePixels
(
aEvent
-
>
x
aEvent
-
>
y
)
;
event
.
AssignEventTime
(
GetWidgetEventTime
(
aEvent
-
>
time
)
)
;
LOG
(
"
OnEnterNotify
"
)
;
DispatchInputEvent
(
&
event
)
;
}
static
bool
is_top_level_mouse_exit
(
GdkWindow
*
aWindow
GdkEventCrossing
*
aEvent
)
{
auto
x
=
gint
(
aEvent
-
>
x_root
)
;
auto
y
=
gint
(
aEvent
-
>
y_root
)
;
GdkDisplay
*
display
=
gdk_window_get_display
(
aWindow
)
;
GdkWindow
*
winAtPt
=
gdk_display_get_window_at_pointer
(
display
&
x
&
y
)
;
if
(
!
winAtPt
)
return
true
;
GdkWindow
*
topLevelAtPt
=
gdk_window_get_toplevel
(
winAtPt
)
;
GdkWindow
*
topLevelWidget
=
gdk_window_get_toplevel
(
aWindow
)
;
return
topLevelAtPt
!
=
topLevelWidget
;
}
void
nsWindow
:
:
OnLeaveNotifyEvent
(
GdkEventCrossing
*
aEvent
)
{
if
(
!
mGdkWindow
|
|
aEvent
-
>
subwindow
!
=
nullptr
)
{
return
;
}
WidgetMouseEvent
event
(
true
eMouseExitFromWidget
this
WidgetMouseEvent
:
:
eReal
)
;
event
.
mRefPoint
=
GdkEventCoordsToDevicePixels
(
aEvent
-
>
x
aEvent
-
>
y
)
;
event
.
AssignEventTime
(
GetWidgetEventTime
(
aEvent
-
>
time
)
)
;
event
.
mExitFrom
=
Some
(
is_top_level_mouse_exit
(
mGdkWindow
aEvent
)
?
WidgetMouseEvent
:
:
ePlatformTopLevel
:
WidgetMouseEvent
:
:
ePlatformChild
)
;
LOG
(
"
OnLeaveNotify
"
)
;
DispatchInputEvent
(
&
event
)
;
}
bool
nsWindow
:
:
CheckResizerEdge
(
LayoutDeviceIntPoint
aPoint
GdkWindowEdge
&
aOutEdge
)
{
if
(
!
mIsPIPWindow
)
{
return
false
;
}
if
(
mSizeState
!
=
nsSizeMode_Normal
)
{
return
false
;
}
#
define
RESIZER_SIZE
15
int
resizerSize
=
RESIZER_SIZE
*
GdkCeiledScaleFactor
(
)
;
int
topDist
=
aPoint
.
y
;
int
leftDist
=
aPoint
.
x
;
int
rightDist
=
mBounds
.
width
-
aPoint
.
x
;
int
bottomDist
=
mBounds
.
height
-
aPoint
.
y
;
if
(
leftDist
<
=
resizerSize
&
&
topDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_NORTH_WEST
;
}
else
if
(
rightDist
<
=
resizerSize
&
&
topDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_NORTH_EAST
;
}
else
if
(
leftDist
<
=
resizerSize
&
&
bottomDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_SOUTH_WEST
;
}
else
if
(
rightDist
<
=
resizerSize
&
&
bottomDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_SOUTH_EAST
;
}
else
if
(
topDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_NORTH
;
}
else
if
(
leftDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_WEST
;
}
else
if
(
rightDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_EAST
;
}
else
if
(
bottomDist
<
=
resizerSize
)
{
aOutEdge
=
GDK_WINDOW_EDGE_SOUTH
;
}
else
{
return
false
;
}
return
true
;
}
template
<
typename
Event
>
static
LayoutDeviceIntPoint
GetRefPoint
(
nsWindow
*
aWindow
Event
*
aEvent
)
{
if
(
aEvent
-
>
window
=
=
aWindow
-
>
GetGdkWindow
(
)
)
{
return
aWindow
-
>
GdkEventCoordsToDevicePixels
(
aEvent
-
>
x
aEvent
-
>
y
)
;
}
return
aWindow
-
>
GdkEventCoordsToDevicePixels
(
aEvent
-
>
x_root
aEvent
-
>
y_root
)
-
aWindow
-
>
WidgetToScreenOffset
(
)
;
}
void
nsWindow
:
:
OnMotionNotifyEvent
(
GdkEventMotion
*
aEvent
)
{
if
(
!
mGdkWindow
)
{
return
;
}
if
(
mWindowShouldStartDragging
)
{
mWindowShouldStartDragging
=
false
;
GdkWindow
*
gdk_window
=
gdk_window_get_toplevel
(
mGdkWindow
)
;
MOZ_ASSERT
(
gdk_window
"
gdk_window_get_toplevel
should
not
return
null
"
)
;
bool
canDrag
=
true
;
if
(
GdkIsX11Display
(
)
)
{
GdkScreen
*
screen
=
gdk_window_get_screen
(
gdk_window
)
;
GdkAtom
atom
=
gdk_atom_intern
(
"
_NET_WM_MOVERESIZE
"
FALSE
)
;
if
(
!
gdk_x11_screen_supports_net_wm_hint
(
screen
atom
)
)
{
canDrag
=
false
;
}
}
if
(
canDrag
)
{
gdk_window_begin_move_drag
(
gdk_window
1
aEvent
-
>
x_root
aEvent
-
>
y_root
aEvent
-
>
time
)
;
return
;
}
}
GdkWindowEdge
edge
;
if
(
CheckResizerEdge
(
GetRefPoint
(
this
aEvent
)
edge
)
)
{
nsCursor
cursor
=
eCursor_none
;
switch
(
edge
)
{
case
GDK_WINDOW_EDGE_NORTH
:
cursor
=
eCursor_n_resize
;
break
;
case
GDK_WINDOW_EDGE_NORTH_WEST
:
cursor
=
eCursor_nw_resize
;
break
;
case
GDK_WINDOW_EDGE_NORTH_EAST
:
cursor
=
eCursor_ne_resize
;
break
;
case
GDK_WINDOW_EDGE_WEST
:
cursor
=
eCursor_w_resize
;
break
;
case
GDK_WINDOW_EDGE_EAST
:
cursor
=
eCursor_e_resize
;
break
;
case
GDK_WINDOW_EDGE_SOUTH
:
cursor
=
eCursor_s_resize
;
break
;
case
GDK_WINDOW_EDGE_SOUTH_WEST
:
cursor
=
eCursor_sw_resize
;
break
;
case
GDK_WINDOW_EDGE_SOUTH_EAST
:
cursor
=
eCursor_se_resize
;
break
;
}
SetCursor
(
Cursor
{
cursor
}
)
;
return
;
}
WidgetMouseEvent
event
(
true
eMouseMove
this
WidgetMouseEvent
:
:
eReal
)
;
gdouble
pressure
=
0
;
gdk_event_get_axis
(
(
GdkEvent
*
)
aEvent
GDK_AXIS_PRESSURE
&
pressure
)
;
if
(
pressure
)
mLastMotionPressure
=
pressure
;
event
.
mPressure
=
mLastMotionPressure
;
event
.
mRefPoint
=
GetRefPoint
(
this
aEvent
)
;
event
.
AssignEventTime
(
GetWidgetEventTime
(
aEvent
-
>
time
)
)
;
KeymapWrapper
:
:
InitInputEvent
(
event
aEvent
-
>
state
)
;
DispatchInputEvent
(
&
event
)
;
}
void
nsWindow
:
:
DispatchMissedButtonReleases
(
GdkEventCrossing
*
aGdkEvent
)
{
guint
changed
=
aGdkEvent
-
>
state
^
gButtonState
;
guint
released
=
changed
&
gButtonState
;
gButtonState
=
aGdkEvent
-
>
state
;
for
(
guint
buttonMask
=
GDK_BUTTON1_MASK
;
buttonMask
<
=
GDK_BUTTON3_MASK
;
buttonMask
<
<
=
1
)
{
if
(
released
&
buttonMask
)
{
int16_t
buttonType
;
switch
(
buttonMask
)
{
case
GDK_BUTTON1_MASK
:
buttonType
=
MouseButton
:
:
ePrimary
;
break
;
case
GDK_BUTTON2_MASK
:
buttonType
=
MouseButton
:
:
eMiddle
;
break
;
default
:
NS_ASSERTION
(
buttonMask
=
=
GDK_BUTTON3_MASK
"
Unexpected
button
mask
"
)
;
buttonType
=
MouseButton
:
:
eSecondary
;
}
LOG
(
"
Synthesized
button
%
u
release
"
guint
(
buttonType
+
1
)
)
;
WidgetMouseEvent
synthEvent
(
true
eMouseUp
this
WidgetMouseEvent
:
:
eSynthesized
)
;
synthEvent
.
mButton
=
buttonType
;
DispatchInputEvent
(
&
synthEvent
)
;
}
}
}
void
nsWindow
:
:
InitButtonEvent
(
WidgetMouseEvent
&
aEvent
GdkEventButton
*
aGdkEvent
)
{
aEvent
.
mRefPoint
=
GetRefPoint
(
this
aGdkEvent
)
;
guint
modifierState
=
aGdkEvent
-
>
state
;
guint
buttonMask
=
0
;
switch
(
aGdkEvent
-
>
button
)
{
case
1
:
buttonMask
=
GDK_BUTTON1_MASK
;
break
;
case
2
:
buttonMask
=
GDK_BUTTON2_MASK
;
break
;
case
3
:
buttonMask
=
GDK_BUTTON3_MASK
;
break
;
}
if
(
aGdkEvent
-
>
type
=
=
GDK_BUTTON_RELEASE
)
{
modifierState
&
=
~
buttonMask
;
}
else
{
modifierState
|
=
buttonMask
;
}
KeymapWrapper
:
:
InitInputEvent
(
aEvent
modifierState
)
;
aEvent
.
AssignEventTime
(
GetWidgetEventTime
(
aGdkEvent
-
>
time
)
)
;
switch
(
aGdkEvent
-
>
type
)
{
case
GDK_2BUTTON_PRESS
:
aEvent
.
mClickCount
=
2
;
break
;
case
GDK_3BUTTON_PRESS
:
aEvent
.
mClickCount
=
3
;
break
;
default
:
aEvent
.
mClickCount
=
1
;
}
}
static
guint
ButtonMaskFromGDKButton
(
guint
button
)
{
return
GDK_BUTTON1_MASK
<
<
(
button
-
1
)
;
}
void
nsWindow
:
:
DispatchContextMenuEventFromMouseEvent
(
uint16_t
domButton
GdkEventButton
*
aEvent
)
{
if
(
domButton
=
=
MouseButton
:
:
eSecondary
&
&
MOZ_LIKELY
(
!
mIsDestroyed
)
)
{
WidgetMouseEvent
contextMenuEvent
(
true
eContextMenu
this
WidgetMouseEvent
:
:
eReal
)
;
InitButtonEvent
(
contextMenuEvent
aEvent
)
;
contextMenuEvent
.
mPressure
=
mLastMotionPressure
;
DispatchInputEvent
(
&
contextMenuEvent
)
;
}
}
void
nsWindow
:
:
OnButtonPressEvent
(
GdkEventButton
*
aEvent
)
{
LOG
(
"
Button
%
u
press
\
n
"
aEvent
-
>
button
)
;
GdkEvent
*
peekedEvent
=
gdk_event_peek
(
)
;
if
(
peekedEvent
)
{
GdkEventType
type
=
peekedEvent
-
>
any
.
type
;
gdk_event_free
(
peekedEvent
)
;
if
(
type
=
=
GDK_2BUTTON_PRESS
|
|
type
=
=
GDK_3BUTTON_PRESS
)
return
;
}
nsWindow
*
containerWindow
=
GetContainerWindow
(
)
;
if
(
!
gFocusWindow
&
&
containerWindow
)
{
containerWindow
-
>
DispatchActivateEvent
(
)
;
}
if
(
CheckForRollup
(
aEvent
-
>
x_root
aEvent
-
>
y_root
false
false
)
)
return
;
GdkWindowEdge
edge
;
if
(
CheckResizerEdge
(
GetRefPoint
(
this
aEvent
)
edge
)
)
{
gdk_window_begin_resize_drag
(
gtk_widget_get_window
(
mShell
)
edge
aEvent
-
>
button
aEvent
-
>
x_root
aEvent
-
>
y_root
aEvent
-
>
time
)
;
return
;
}
gdouble
pressure
=
0
;
gdk_event_get_axis
(
(
GdkEvent
*
)
aEvent
GDK_AXIS_PRESSURE
&
pressure
)
;
mLastMotionPressure
=
pressure
;
uint16_t
domButton
;
switch
(
aEvent
-
>
button
)
{
case
1
:
domButton
=
MouseButton
:
:
ePrimary
;
break
;
case
2
:
domButton
=
MouseButton
:
:
eMiddle
;
break
;
case
3
:
domButton
=
MouseButton
:
:
eSecondary
;
break
;
case
6
:
case
7
:
NS_WARNING
(
"
We
'
re
not
supporting
legacy
horizontal
scroll
event
"
)
;
return
;
case
8
:
if
(
!
Preferences
:
:
GetBool
(
"
mousebutton
.
4th
.
enabled
"
true
)
)
{
return
;
}
DispatchCommandEvent
(
nsGkAtoms
:
:
Back
)
;
return
;
case
9
:
if
(
!
Preferences
:
:
GetBool
(
"
mousebutton
.
5th
.
enabled
"
true
)
)
{
return
;
}
DispatchCommandEvent
(
nsGkAtoms
:
:
Forward
)
;
return
;
default
:
return
;
}
gButtonState
|
=
ButtonMaskFromGDKButton
(
aEvent
-
>
button
)
;
WidgetMouseEvent
event
(
true
eMouseDown
this
WidgetMouseEvent
:
:
eReal
)
;
event
.
mButton
=
domButton
;
InitButtonEvent
(
event
aEvent
)
;
event
.
mPressure
=
mLastMotionPressure
;
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
DispatchInputEvent
(
&
event
)
;
LayoutDeviceIntPoint
refPoint
=
GdkEventCoordsToDevicePixels
(
aEvent
-
>
x
aEvent
-
>
y
)
;
if
(
(
mIsWaylandPanelWindow
|
|
mDraggableRegion
.
Contains
(
refPoint
.
x
refPoint
.
y
)
)
&
&
domButton
=
=
MouseButton
:
:
ePrimary
&
&
eventStatus
.
mContentStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
mWindowShouldStartDragging
=
true
;
}
if
(
!
StaticPrefs
:
:
ui_context_menus_after_mouseup
(
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
DispatchContextMenuEventFromMouseEvent
(
domButton
aEvent
)
;
}
}
void
nsWindow
:
:
OnButtonReleaseEvent
(
GdkEventButton
*
aEvent
)
{
LOG
(
"
Button
%
u
release
\
n
"
aEvent
-
>
button
)
;
if
(
!
mGdkWindow
)
{
return
;
}
if
(
mWindowShouldStartDragging
)
{
mWindowShouldStartDragging
=
false
;
}
uint16_t
domButton
;
switch
(
aEvent
-
>
button
)
{
case
1
:
domButton
=
MouseButton
:
:
ePrimary
;
break
;
case
2
:
domButton
=
MouseButton
:
:
eMiddle
;
break
;
case
3
:
domButton
=
MouseButton
:
:
eSecondary
;
break
;
default
:
return
;
}
gButtonState
&
=
~
ButtonMaskFromGDKButton
(
aEvent
-
>
button
)
;
WidgetMouseEvent
event
(
true
eMouseUp
this
WidgetMouseEvent
:
:
eReal
)
;
event
.
mButton
=
domButton
;
InitButtonEvent
(
event
aEvent
)
;
gdouble
pressure
=
0
;
gdk_event_get_axis
(
(
GdkEvent
*
)
aEvent
GDK_AXIS_PRESSURE
&
pressure
)
;
event
.
mPressure
=
pressure
?
(
float
)
pressure
:
(
float
)
mLastMotionPressure
;
LayoutDeviceIntPoint
pos
=
event
.
mRefPoint
;
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
DispatchInputEvent
(
&
event
)
;
bool
defaultPrevented
=
(
eventStatus
.
mContentStatus
=
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
!
defaultPrevented
&
&
mDrawInTitlebar
&
&
event
.
mButton
=
=
MouseButton
:
:
ePrimary
&
&
event
.
mClickCount
=
=
2
&
&
mDraggableRegion
.
Contains
(
pos
.
x
pos
.
y
)
)
{
if
(
mSizeState
=
=
nsSizeMode_Maximized
)
{
SetSizeMode
(
nsSizeMode_Normal
)
;
}
else
{
SetSizeMode
(
nsSizeMode_Maximized
)
;
}
}
mLastMotionPressure
=
pressure
;
if
(
StaticPrefs
:
:
ui_context_menus_after_mouseup
(
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
DispatchContextMenuEventFromMouseEvent
(
domButton
aEvent
)
;
}
if
(
mIsPIPWindow
&
&
aEvent
-
>
button
=
=
3
)
{
static
auto
sGdkWindowShowWindowMenu
=
(
gboolean
(
*
)
(
GdkWindow
*
window
GdkEvent
*
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_window_show_window_menu
"
)
;
if
(
sGdkWindowShowWindowMenu
)
{
sGdkWindowShowWindowMenu
(
mGdkWindow
(
GdkEvent
*
)
aEvent
)
;
}
}
}
void
nsWindow
:
:
OnContainerFocusInEvent
(
GdkEventFocus
*
aEvent
)
{
LOG
(
"
OnContainerFocusInEvent
"
)
;
GtkWidget
*
top_window
=
GetToplevelWidget
(
)
;
if
(
top_window
&
&
(
gtk_widget_get_visible
(
top_window
)
)
)
{
SetUrgencyHint
(
top_window
false
)
;
}
if
(
gBlockActivateEvent
)
{
LOG
(
"
activated
notification
is
blocked
"
)
;
return
;
}
gFocusWindow
=
nullptr
;
DispatchActivateEvent
(
)
;
if
(
!
gFocusWindow
)
{
gFocusWindow
=
this
;
}
LOG
(
"
Events
sent
from
focus
in
event
"
)
;
}
void
nsWindow
:
:
OnContainerFocusOutEvent
(
GdkEventFocus
*
aEvent
)
{
LOG
(
"
OnContainerFocusOutEvent
"
)
;
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
kCDragServiceCID
)
;
nsCOMPtr
<
nsIDragSession
>
dragSession
;
dragService
-
>
GetCurrentSession
(
getter_AddRefs
(
dragSession
)
)
;
bool
shouldRollup
=
!
dragSession
;
if
(
!
shouldRollup
)
{
nsCOMPtr
<
nsINode
>
sourceNode
;
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
shouldRollup
=
(
sourceNode
=
=
nullptr
)
;
}
if
(
shouldRollup
)
{
CheckForRollup
(
0
0
false
true
)
;
}
}
if
(
gFocusWindow
)
{
RefPtr
<
nsWindow
>
kungFuDeathGrip
=
gFocusWindow
;
if
(
gFocusWindow
-
>
mIMContext
)
{
gFocusWindow
-
>
mIMContext
-
>
OnBlurWindow
(
gFocusWindow
)
;
}
gFocusWindow
=
nullptr
;
}
DispatchDeactivateEvent
(
)
;
if
(
IsChromeWindowTitlebar
(
)
)
{
UpdateMozWindowActive
(
)
;
}
LOG
(
"
Done
with
container
focus
out
"
)
;
}
bool
nsWindow
:
:
DispatchCommandEvent
(
nsAtom
*
aCommand
)
{
nsEventStatus
status
;
WidgetCommandEvent
appCommandEvent
(
true
aCommand
this
)
;
DispatchEvent
(
&
appCommandEvent
status
)
;
return
TRUE
;
}
bool
nsWindow
:
:
DispatchContentCommandEvent
(
EventMessage
aMsg
)
{
nsEventStatus
status
;
WidgetContentCommandEvent
event
(
true
aMsg
this
)
;
DispatchEvent
(
&
event
status
)
;
return
TRUE
;
}
WidgetEventTime
nsWindow
:
:
GetWidgetEventTime
(
guint32
aEventTime
)
{
return
WidgetEventTime
(
aEventTime
GetEventTimeStamp
(
aEventTime
)
)
;
}
TimeStamp
nsWindow
:
:
GetEventTimeStamp
(
guint32
aEventTime
)
{
if
(
MOZ_UNLIKELY
(
!
mGdkWindow
)
)
{
return
TimeStamp
:
:
Now
(
)
;
}
if
(
aEventTime
=
=
0
)
{
return
TimeStamp
:
:
Now
(
)
;
}
TimeStamp
eventTimeStamp
;
if
(
GdkIsWaylandDisplay
(
)
)
{
int64_t
timestampTime
=
g_get_monotonic_time
(
)
/
1000
;
guint32
refTimeTruncated
=
guint32
(
timestampTime
)
;
timestampTime
-
=
refTimeTruncated
-
aEventTime
;
int64_t
tick
=
BaseTimeDurationPlatformUtils
:
:
TicksFromMilliseconds
(
timestampTime
)
;
eventTimeStamp
=
TimeStamp
:
:
FromSystemTime
(
tick
)
;
}
else
{
CurrentX11TimeGetter
*
getCurrentTime
=
GetCurrentTimeGetter
(
)
;
MOZ_ASSERT
(
getCurrentTime
"
Null
current
time
getter
despite
having
a
window
"
)
;
eventTimeStamp
=
TimeConverter
(
)
.
GetTimeStampFromSystemTime
(
aEventTime
*
getCurrentTime
)
;
}
return
eventTimeStamp
;
}
mozilla
:
:
CurrentX11TimeGetter
*
nsWindow
:
:
GetCurrentTimeGetter
(
)
{
MOZ_ASSERT
(
mGdkWindow
"
Expected
mGdkWindow
to
be
set
"
)
;
if
(
MOZ_UNLIKELY
(
!
mCurrentTimeGetter
)
)
{
mCurrentTimeGetter
=
MakeUnique
<
CurrentX11TimeGetter
>
(
mGdkWindow
)
;
}
return
mCurrentTimeGetter
.
get
(
)
;
}
gboolean
nsWindow
:
:
OnKeyPressEvent
(
GdkEventKey
*
aEvent
)
{
LOG
(
"
OnKeyPressEvent
"
)
;
RefPtr
<
nsWindow
>
self
(
this
)
;
KeymapWrapper
:
:
HandleKeyPressEvent
(
self
aEvent
)
;
return
TRUE
;
}
gboolean
nsWindow
:
:
OnKeyReleaseEvent
(
GdkEventKey
*
aEvent
)
{
LOG
(
"
OnKeyReleaseEvent
"
)
;
RefPtr
<
nsWindow
>
self
(
this
)
;
if
(
NS_WARN_IF
(
!
KeymapWrapper
:
:
HandleKeyReleaseEvent
(
self
aEvent
)
)
)
{
return
FALSE
;
}
return
TRUE
;
}
void
nsWindow
:
:
OnScrollEvent
(
GdkEventScroll
*
aEvent
)
{
if
(
CheckForRollup
(
aEvent
-
>
x_root
aEvent
-
>
y_root
true
false
)
)
{
return
;
}
if
(
aEvent
-
>
direction
!
=
GDK_SCROLL_SMOOTH
&
&
mLastScrollEventTime
=
=
aEvent
-
>
time
)
{
LOG
(
"
[
%
d
]
duplicate
legacy
scroll
event
%
d
\
n
"
aEvent
-
>
time
aEvent
-
>
direction
)
;
return
;
}
WidgetWheelEvent
wheelEvent
(
true
eWheel
this
)
;
wheelEvent
.
mDeltaMode
=
dom
:
:
WheelEvent_Binding
:
:
DOM_DELTA_LINE
;
switch
(
aEvent
-
>
direction
)
{
case
GDK_SCROLL_SMOOTH
:
{
mLastScrollEventTime
=
aEvent
-
>
time
;
GdkDevice
*
device
=
gdk_event_get_source_device
(
(
GdkEvent
*
)
aEvent
)
;
GdkInputSource
source
=
gdk_device_get_source
(
device
)
;
if
(
source
=
=
GDK_SOURCE_TOUCHSCREEN
|
|
source
=
=
GDK_SOURCE_TOUCHPAD
)
{
if
(
StaticPrefs
:
:
apz_gtk_kinetic_scroll_enabled
(
)
&
&
gtk_check_version
(
3
20
0
)
=
=
nullptr
)
{
static
auto
sGdkEventIsScrollStopEvent
=
(
gboolean
(
*
)
(
const
GdkEvent
*
)
)
dlsym
(
RTLD_DEFAULT
"
gdk_event_is_scroll_stop_event
"
)
;
LOG
(
"
[
%
d
]
pan
smooth
event
dx
=
%
f
dy
=
%
f
inprogress
=
%
d
\
n
"
aEvent
-
>
time
aEvent
-
>
delta_x
aEvent
-
>
delta_y
mPanInProgress
)
;
PanGestureInput
:
:
PanGestureType
eventType
=
PanGestureInput
:
:
PANGESTURE_PAN
;
if
(
sGdkEventIsScrollStopEvent
(
(
GdkEvent
*
)
aEvent
)
)
{
eventType
=
PanGestureInput
:
:
PANGESTURE_END
;
mPanInProgress
=
false
;
}
else
if
(
!
mPanInProgress
)
{
eventType
=
PanGestureInput
:
:
PANGESTURE_START
;
mPanInProgress
=
true
;
}
LayoutDeviceIntPoint
touchPoint
=
GetRefPoint
(
this
aEvent
)
;
PanGestureInput
panEvent
(
eventType
aEvent
-
>
time
GetEventTimeStamp
(
aEvent
-
>
time
)
ScreenPoint
(
touchPoint
.
x
touchPoint
.
y
)
ScreenPoint
(
aEvent
-
>
delta_x
aEvent
-
>
delta_y
)
KeymapWrapper
:
:
ComputeKeyModifiers
(
aEvent
-
>
state
)
)
;
panEvent
.
mDeltaType
=
PanGestureInput
:
:
PANDELTA_PAGE
;
panEvent
.
mSimulateMomentum
=
true
;
DispatchPanGestureInput
(
panEvent
)
;
return
;
}
wheelEvent
.
mScrollType
=
WidgetWheelEvent
:
:
SCROLL_ASYNCHRONOUSELY
;
}
wheelEvent
.
mDeltaX
=
aEvent
-
>
delta_x
*
3
;
wheelEvent
.
mDeltaY
=
aEvent
-
>
delta_y
*
3
;
wheelEvent
.
mWheelTicksX
=
aEvent
-
>
delta_x
;
wheelEvent
.
mWheelTicksY
=
aEvent
-
>
delta_y
;
wheelEvent
.
mIsNoLineOrPageDelta
=
true
;
break
;
}
case
GDK_SCROLL_UP
:
wheelEvent
.
mDeltaY
=
wheelEvent
.
mLineOrPageDeltaY
=
-
3
;
wheelEvent
.
mWheelTicksY
=
-
1
;
break
;
case
GDK_SCROLL_DOWN
:
wheelEvent
.
mDeltaY
=
wheelEvent
.
mLineOrPageDeltaY
=
3
;
wheelEvent
.
mWheelTicksY
=
1
;
break
;
case
GDK_SCROLL_LEFT
:
wheelEvent
.
mDeltaX
=
wheelEvent
.
mLineOrPageDeltaX
=
-
1
;
wheelEvent
.
mWheelTicksX
=
-
1
;
break
;
case
GDK_SCROLL_RIGHT
:
wheelEvent
.
mDeltaX
=
wheelEvent
.
mLineOrPageDeltaX
=
1
;
wheelEvent
.
mWheelTicksX
=
1
;
break
;
}
wheelEvent
.
mRefPoint
=
GetRefPoint
(
this
aEvent
)
;
KeymapWrapper
:
:
InitInputEvent
(
wheelEvent
aEvent
-
>
state
)
;
wheelEvent
.
AssignEventTime
(
GetWidgetEventTime
(
aEvent
-
>
time
)
)
;
DispatchInputEvent
(
&
wheelEvent
)
;
}
void
nsWindow
:
:
OnWindowStateEvent
(
GtkWidget
*
aWidget
GdkEventWindowState
*
aEvent
)
{
LOG
(
"
nsWindow
:
:
OnWindowStateEvent
for
%
p
changed
0x
%
x
new_window_state
"
"
0x
%
x
\
n
"
aWidget
aEvent
-
>
changed_mask
aEvent
-
>
new_window_state
)
;
if
(
IS_MOZ_CONTAINER
(
aWidget
)
)
{
bool
mapped
=
!
(
aEvent
-
>
new_window_state
&
(
GDK_WINDOW_STATE_ICONIFIED
|
GDK_WINDOW_STATE_WITHDRAWN
)
)
;
if
(
mHasMappedToplevel
!
=
mapped
)
{
SetHasMappedToplevel
(
mapped
)
;
}
LOG
(
"
\
tquick
return
because
IS_MOZ_CONTAINER
(
aWidget
)
is
true
\
n
"
)
;
return
;
}
if
(
GdkIsX11Display
(
)
)
{
if
(
!
mIsShown
)
{
aEvent
-
>
changed_mask
=
static_cast
<
GdkWindowState
>
(
aEvent
-
>
changed_mask
&
~
GDK_WINDOW_STATE_MAXIMIZED
)
;
}
else
if
(
aEvent
-
>
changed_mask
&
GDK_WINDOW_STATE_WITHDRAWN
&
&
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_MAXIMIZED
)
{
aEvent
-
>
changed_mask
=
static_cast
<
GdkWindowState
>
(
aEvent
-
>
changed_mask
|
GDK_WINDOW_STATE_MAXIMIZED
)
;
}
}
if
(
IsChromeWindowTitlebar
(
)
&
&
(
aEvent
-
>
changed_mask
&
GDK_WINDOW_STATE_FOCUSED
)
)
{
mTitlebarBackdropState
=
!
(
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_FOCUSED
)
;
UpdateMozWindowActive
(
)
;
ForceTitlebarRedraw
(
)
;
}
bool
waylandWasIconified
=
(
GdkIsWaylandDisplay
(
)
&
&
aEvent
-
>
changed_mask
&
GDK_WINDOW_STATE_FOCUSED
&
&
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_FOCUSED
&
&
mSizeState
=
=
nsSizeMode_Minimized
)
;
if
(
!
waylandWasIconified
&
&
(
aEvent
-
>
changed_mask
&
(
GDK_WINDOW_STATE_ICONIFIED
|
GDK_WINDOW_STATE_MAXIMIZED
|
GDK_WINDOW_STATE_TILED
|
GDK_WINDOW_STATE_FULLSCREEN
)
)
=
=
0
)
{
LOG
(
"
\
tearly
return
because
no
interesting
bits
changed
\
n
"
)
;
return
;
}
if
(
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_ICONIFIED
)
{
LOG
(
"
\
tIconified
\
n
"
)
;
mSizeState
=
nsSizeMode_Minimized
;
#
ifdef
ACCESSIBILITY
DispatchMinimizeEventAccessible
(
)
;
#
endif
}
else
if
(
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_FULLSCREEN
)
{
LOG
(
"
\
tFullscreen
\
n
"
)
;
mSizeState
=
nsSizeMode_Fullscreen
;
}
else
if
(
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_MAXIMIZED
)
{
LOG
(
"
\
tMaximized
\
n
"
)
;
mSizeState
=
nsSizeMode_Maximized
;
#
ifdef
ACCESSIBILITY
DispatchMaximizeEventAccessible
(
)
;
#
endif
}
else
{
LOG
(
"
\
tNormal
\
n
"
)
;
mSizeState
=
nsSizeMode_Normal
;
#
ifdef
ACCESSIBILITY
DispatchRestoreEventAccessible
(
)
;
#
endif
}
if
(
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_TILED
)
{
LOG
(
"
\
tTiled
\
n
"
)
;
mIsTiled
=
true
;
}
else
{
LOG
(
"
\
tNot
tiled
\
n
"
)
;
mIsTiled
=
false
;
}
if
(
mWidgetListener
)
{
mWidgetListener
-
>
SizeModeChanged
(
mSizeState
)
;
if
(
aEvent
-
>
changed_mask
&
GDK_WINDOW_STATE_FULLSCREEN
)
{
mWidgetListener
-
>
FullscreenChanged
(
aEvent
-
>
new_window_state
&
GDK_WINDOW_STATE_FULLSCREEN
)
;
}
}
if
(
mDrawInTitlebar
&
&
mTransparencyBitmapForTitlebar
)
{
if
(
mSizeState
=
=
nsSizeMode_Normal
&
&
!
mIsTiled
)
{
UpdateTitlebarTransparencyBitmap
(
)
;
}
else
{
ClearTransparencyBitmap
(
)
;
}
}
}
void
nsWindow
:
:
OnDPIChanged
(
)
{
if
(
mWidgetListener
)
{
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
presShell
-
>
ThemeChanged
(
ThemeChangeKind
:
:
StyleAndLayout
)
;
}
mWidgetListener
-
>
UIResolutionChanged
(
)
;
}
}
void
nsWindow
:
:
OnCheckResize
(
)
{
mPendingConfigures
+
+
;
}
void
nsWindow
:
:
OnCompositedChanged
(
)
{
NotifyThemeChanged
(
ThemeChangeKind
:
:
MediaQueriesOnly
)
;
mCompositedScreen
=
gdk_screen_is_composited
(
gdk_screen_get_default
(
)
)
;
}
void
nsWindow
:
:
OnScaleChanged
(
)
{
if
(
!
mGdkWindow
)
{
mWindowScaleFactorChanged
=
true
;
return
;
}
if
(
gdk_window_get_scale_factor
(
mGdkWindow
)
=
=
mWindowScaleFactor
)
{
return
;
}
PauseCompositor
(
)
;
mWindowScaleFactorChanged
=
true
;
GtkAllocation
allocation
;
gtk_widget_get_allocation
(
GTK_WIDGET
(
mContainer
)
&
allocation
)
;
LayoutDeviceIntSize
size
=
GdkRectToDevicePixels
(
allocation
)
.
Size
(
)
;
mBoundsAreValid
=
true
;
mBounds
.
SizeTo
(
size
)
;
if
(
mWidgetListener
)
{
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
presShell
-
>
ThemeChanged
(
ThemeChangeKind
:
:
StyleAndLayout
)
;
}
}
DispatchResized
(
)
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
NotifyClientSizeChanged
(
GetClientSize
(
)
)
;
}
if
(
mCursor
.
IsCustom
(
)
)
{
mUpdateCursor
=
true
;
SetCursor
(
Cursor
{
mCursor
}
)
;
}
}
void
nsWindow
:
:
DispatchDragEvent
(
EventMessage
aMsg
const
LayoutDeviceIntPoint
&
aRefPoint
guint
aTime
)
{
WidgetDragEvent
event
(
true
aMsg
this
)
;
InitDragEvent
(
event
)
;
event
.
mRefPoint
=
aRefPoint
;
event
.
AssignEventTime
(
GetWidgetEventTime
(
aTime
)
)
;
DispatchInputEvent
(
&
event
)
;
}
void
nsWindow
:
:
OnDragDataReceivedEvent
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
GtkSelectionData
*
aSelectionData
guint
aInfo
guint
aTime
gpointer
aData
)
{
LOGDRAG
(
"
nsWindow
:
:
OnDragDataReceived
(
%
p
)
\
n
"
(
void
*
)
this
)
;
RefPtr
<
nsDragService
>
dragService
=
nsDragService
:
:
GetInstance
(
)
;
dragService
-
>
TargetDataReceived
(
aWidget
aDragContext
aX
aY
aSelectionData
aInfo
aTime
)
;
}
nsWindow
*
nsWindow
:
:
GetTransientForWindowIfPopup
(
)
{
if
(
mWindowType
!
=
eWindowType_popup
)
{
return
nullptr
;
}
GtkWindow
*
toplevel
=
gtk_window_get_transient_for
(
GTK_WINDOW
(
mShell
)
)
;
if
(
toplevel
)
{
return
get_window_for_gtk_widget
(
GTK_WIDGET
(
toplevel
)
)
;
}
return
nullptr
;
}
bool
nsWindow
:
:
IsHandlingTouchSequence
(
GdkEventSequence
*
aSequence
)
{
return
mHandleTouchEvent
&
&
mTouches
.
Contains
(
aSequence
)
;
}
gboolean
nsWindow
:
:
OnTouchpadPinchEvent
(
GdkEventTouchpadPinch
*
aEvent
)
{
if
(
StaticPrefs
:
:
apz_gtk_touchpad_pinch_enabled
(
)
)
{
if
(
aEvent
-
>
n_fingers
>
2
&
&
!
StaticPrefs
:
:
apz_gtk_touchpad_pinch_three_fingers_enabled
(
)
)
{
return
FALSE
;
}
PinchGestureInput
:
:
PinchGestureType
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_SCALE
;
ScreenCoord
CurrentSpan
;
ScreenCoord
PreviousSpan
;
switch
(
aEvent
-
>
phase
)
{
case
GDK_TOUCHPAD_GESTURE_PHASE_BEGIN
:
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_START
;
CurrentSpan
=
aEvent
-
>
scale
;
PreviousSpan
=
0
.
999
;
break
;
case
GDK_TOUCHPAD_GESTURE_PHASE_UPDATE
:
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_SCALE
;
if
(
aEvent
-
>
scale
=
=
mLastPinchEventSpan
)
{
return
FALSE
;
}
CurrentSpan
=
aEvent
-
>
scale
;
PreviousSpan
=
mLastPinchEventSpan
;
break
;
case
GDK_TOUCHPAD_GESTURE_PHASE_END
:
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_END
;
CurrentSpan
=
aEvent
-
>
scale
;
PreviousSpan
=
mLastPinchEventSpan
;
break
;
default
:
return
FALSE
;
}
LayoutDeviceIntPoint
touchpadPoint
=
GetRefPoint
(
this
aEvent
)
;
PinchGestureInput
event
(
pinchGestureType
PinchGestureInput
:
:
TRACKPAD
aEvent
-
>
time
GetEventTimeStamp
(
aEvent
-
>
time
)
ExternalPoint
(
0
0
)
ScreenPoint
(
touchpadPoint
.
x
touchpadPoint
.
y
)
100
.
0
*
(
(
aEvent
-
>
phase
=
=
GDK_TOUCHPAD_GESTURE_PHASE_END
)
?
ScreenCoord
(
1
.
f
)
:
CurrentSpan
)
100
.
0
*
(
(
aEvent
-
>
phase
=
=
GDK_TOUCHPAD_GESTURE_PHASE_END
)
?
ScreenCoord
(
1
.
f
)
:
PreviousSpan
)
KeymapWrapper
:
:
ComputeKeyModifiers
(
aEvent
-
>
state
)
)
;
if
(
!
event
.
SetLineOrPageDeltaY
(
this
)
)
{
return
FALSE
;
}
mLastPinchEventSpan
=
aEvent
-
>
scale
;
DispatchPinchGestureInput
(
event
)
;
}
return
TRUE
;
}
gboolean
nsWindow
:
:
OnTouchEvent
(
GdkEventTouch
*
aEvent
)
{
LOG
(
"
OnTouchEvent
:
x
=
%
f
y
=
%
f
type
=
%
d
\
n
"
aEvent
-
>
x
aEvent
-
>
y
aEvent
-
>
type
)
;
if
(
!
mHandleTouchEvent
)
{
nsWindow
*
targetWindow
=
GetTransientForWindowIfPopup
(
)
;
if
(
targetWindow
&
&
targetWindow
-
>
IsHandlingTouchSequence
(
aEvent
-
>
sequence
)
)
{
return
targetWindow
-
>
OnTouchEvent
(
aEvent
)
;
}
return
FALSE
;
}
EventMessage
msg
;
switch
(
aEvent
-
>
type
)
{
case
GDK_TOUCH_BEGIN
:
if
(
CheckForRollup
(
aEvent
-
>
x_root
aEvent
-
>
y_root
false
false
)
)
{
return
FALSE
;
}
msg
=
eTouchStart
;
break
;
case
GDK_TOUCH_UPDATE
:
msg
=
eTouchMove
;
if
(
mWindowShouldStartDragging
)
{
mWindowShouldStartDragging
=
false
;
GdkWindow
*
gdk_window
=
gdk_window_get_toplevel
(
mGdkWindow
)
;
MOZ_ASSERT
(
gdk_window
"
gdk_window_get_toplevel
should
not
return
null
"
)
;
LOG
(
"
start
window
dragging
window
\
n
"
)
;
gdk_window_begin_move_drag
(
gdk_window
1
aEvent
-
>
x_root
aEvent
-
>
y_root
aEvent
-
>
time
)
;
msg
=
eTouchCancel
;
}
break
;
case
GDK_TOUCH_END
:
msg
=
eTouchEnd
;
if
(
mWindowShouldStartDragging
)
{
LOG
(
"
end
of
window
dragging
window
\
n
"
)
;
mWindowShouldStartDragging
=
false
;
}
break
;
case
GDK_TOUCH_CANCEL
:
msg
=
eTouchCancel
;
break
;
default
:
return
FALSE
;
}
LayoutDeviceIntPoint
touchPoint
=
GetRefPoint
(
this
aEvent
)
;
int32_t
id
;
RefPtr
<
dom
:
:
Touch
>
touch
;
if
(
mTouches
.
Remove
(
aEvent
-
>
sequence
getter_AddRefs
(
touch
)
)
)
{
id
=
touch
-
>
mIdentifier
;
}
else
{
id
=
+
+
gLastTouchID
&
0x7FFFFFFF
;
}
touch
=
new
dom
:
:
Touch
(
id
touchPoint
LayoutDeviceIntPoint
(
1
1
)
0
.
0f
0
.
0f
)
;
WidgetTouchEvent
event
(
true
msg
this
)
;
KeymapWrapper
:
:
InitInputEvent
(
event
aEvent
-
>
state
)
;
event
.
mTime
=
aEvent
-
>
time
;
if
(
msg
=
=
eTouchStart
|
|
msg
=
=
eTouchMove
)
{
mTouches
.
InsertOrUpdate
(
aEvent
-
>
sequence
std
:
:
move
(
touch
)
)
;
for
(
const
auto
&
data
:
mTouches
.
Values
(
)
)
{
event
.
mTouches
.
AppendElement
(
new
dom
:
:
Touch
(
*
data
)
)
;
}
}
else
if
(
msg
=
=
eTouchEnd
|
|
msg
=
=
eTouchCancel
)
{
*
event
.
mTouches
.
AppendElement
(
)
=
std
:
:
move
(
touch
)
;
}
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
DispatchInputEvent
(
&
event
)
;
LayoutDeviceIntPoint
refPoint
=
GdkEventCoordsToDevicePixels
(
aEvent
-
>
x
aEvent
-
>
y
)
;
if
(
msg
=
=
eTouchStart
&
&
mDraggableRegion
.
Contains
(
refPoint
.
x
refPoint
.
y
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
mWindowShouldStartDragging
=
true
;
}
return
TRUE
;
}
bool
nsWindow
:
:
IsToplevelWindowTransparent
(
)
{
static
bool
transparencyConfigured
=
false
;
if
(
!
transparencyConfigured
)
{
if
(
gdk_screen_is_composited
(
gdk_screen_get_default
(
)
)
)
{
if
(
Preferences
:
:
HasUserValue
(
"
mozilla
.
widget
.
use
-
argb
-
visuals
"
)
)
{
sTransparentMainWindow
=
Preferences
:
:
GetBool
(
"
mozilla
.
widget
.
use
-
argb
-
visuals
"
)
;
}
else
{
sTransparentMainWindow
=
GetSystemGtkWindowDecoration
(
)
!
=
GTK_DECORATION_NONE
;
}
}
transparencyConfigured
=
true
;
}
return
sTransparentMainWindow
;
}
#
ifdef
MOZ_X11
bool
nsWindow
:
:
ConfigureX11GLVisual
(
)
{
auto
*
screen
=
gtk_widget_get_screen
(
mShell
)
;
int
visualId
=
0
;
bool
haveVisual
=
false
;
if
(
gfxVars
:
:
UseEGL
(
)
)
{
haveVisual
=
GLContextEGL
:
:
FindVisual
(
&
visualId
)
;
}
if
(
!
haveVisual
)
{
auto
*
display
=
GDK_DISPLAY_XDISPLAY
(
gtk_widget_get_display
(
mShell
)
)
;
int
screenNumber
=
GDK_SCREEN_XNUMBER
(
screen
)
;
haveVisual
=
GLContextGLX
:
:
FindVisual
(
display
screenNumber
&
visualId
)
;
}
GdkVisual
*
gdkVisual
=
nullptr
;
if
(
haveVisual
)
{
gdkVisual
=
gdk_x11_screen_lookup_visual
(
screen
visualId
)
;
}
if
(
!
gdkVisual
)
{
NS_WARNING
(
"
We
'
re
missing
X11
Visual
!
"
)
;
GdkScreen
*
screen
=
gtk_widget_get_screen
(
mShell
)
;
gdkVisual
=
gdk_screen_get_rgba_visual
(
screen
)
;
}
if
(
gdkVisual
)
{
gtk_widget_set_visual
(
mShell
gdkVisual
)
;
mHasAlphaVisual
=
true
;
return
true
;
}
return
false
;
}
#
endif
nsAutoCString
nsWindow
:
:
GetFrameTag
(
)
const
{
if
(
nsIFrame
*
frame
=
GetFrame
(
)
)
{
#
ifdef
DEBUG_FRAME_DUMP
return
frame
-
>
ListTag
(
)
;
#
else
nsAutoCString
buf
;
buf
.
AppendPrintf
(
"
Frame
(
%
p
)
"
frame
)
;
if
(
nsIContent
*
content
=
frame
-
>
GetContent
(
)
)
{
buf
.
Append
(
'
'
)
;
AppendUTF16toUTF8
(
content
-
>
NodeName
(
)
buf
)
;
}
return
buf
;
#
endif
}
return
nsAutoCString
(
"
(
no
frame
)
"
)
;
}
nsCString
nsWindow
:
:
GetPopupTypeName
(
)
{
switch
(
mPopupHint
)
{
case
ePopupTypeMenu
:
return
nsCString
(
"
Menu
"
)
;
case
ePopupTypeTooltip
:
return
nsCString
(
"
Tooltip
"
)
;
case
ePopupTypePanel
:
return
nsCString
(
"
Panel
/
Utility
"
)
;
default
:
return
nsCString
(
"
Unknown
"
)
;
}
}
static
void
GtkWidgetDisableUpdates
(
GtkWidget
*
aWidget
)
{
GdkWindow
*
window
=
gtk_widget_get_window
(
aWidget
)
;
gdk_window_set_events
(
window
(
GdkEventMask
)
(
gdk_window_get_events
(
window
)
&
(
~
GDK_EXPOSURE_MASK
)
)
)
;
GdkFrameClock
*
frame_clock
=
gdk_window_get_frame_clock
(
window
)
;
g_signal_handlers_disconnect_by_data
(
frame_clock
window
)
;
}
void
nsWindow
:
:
EnableRenderingToWindow
(
)
{
LOG
(
"
nsWindow
:
:
EnableRenderingToWindow
(
)
"
)
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
EnableRendering
(
GetX11Window
(
)
GetShapedState
(
)
)
;
}
if
(
GdkIsWaylandDisplay
(
)
)
{
#
ifdef
MOZ_WAYLAND
moz_container_wayland_add_initial_draw_callback
(
mContainer
[
self
=
RefPtr
{
this
}
this
]
(
)
-
>
void
{
LOG
(
"
moz_container_wayland
initial
create
"
"
ResumeCompositorHiddenWindow
(
)
"
)
;
self
-
>
ResumeCompositorHiddenWindow
(
)
;
self
-
>
WaylandStartVsync
(
)
;
}
)
;
#
endif
}
else
{
ResumeCompositorHiddenWindow
(
)
;
WaylandStartVsync
(
)
;
}
}
void
nsWindow
:
:
DisableRenderingToWindow
(
)
{
LOG
(
"
nsWindow
:
:
DisableRenderingToWindow
(
)
"
)
;
PauseCompositorHiddenWindow
(
)
;
WaylandStopVsync
(
)
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorWidgetDelegate
-
>
DisableRendering
(
)
;
}
}
Window
nsWindow
:
:
GetX11Window
(
)
{
return
GdkIsX11Display
(
)
?
gdk_x11_window_get_xid
(
mGdkWindow
)
:
X11None
;
}
void
nsWindow
:
:
EnsureGdkWindow
(
)
{
if
(
!
mGdkWindow
)
{
mGdkWindow
=
gtk_widget_get_window
(
mDrawToContainer
?
GTK_WIDGET
(
mContainer
)
:
mShell
)
;
g_object_set_data
(
G_OBJECT
(
mGdkWindow
)
"
nsWindow
"
this
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mGdkWindow
"
We
'
re
missing
GdkWindow
!
"
)
;
}
bool
nsWindow
:
:
GetShapedState
(
)
{
return
mIsTransparent
&
&
!
mHasAlphaVisual
&
&
!
mTransparencyBitmapForTitlebar
;
}
void
nsWindow
:
:
ConfigureGdkWindow
(
)
{
LOG
(
"
nsWindow
:
:
ConfigureGdkWindow
(
)
[
%
p
]
"
this
)
;
EnsureGdkWindow
(
)
;
#
ifdef
MOZ_X11
if
(
GdkIsX11Display
(
)
)
{
GdkVisual
*
gdkVisual
=
gdk_window_get_visual
(
mGdkWindow
)
;
Visual
*
visual
=
gdk_x11_visual_get_xvisual
(
gdkVisual
)
;
int
depth
=
gdk_visual_get_depth
(
gdkVisual
)
;
mSurfaceProvider
.
Initialize
(
GetX11Window
(
)
visual
depth
GetShapedState
(
)
)
;
SetCompositorHint
(
GTK_WIDGET_COMPOSIDED_ENABLED
)
;
XShmQueryExtension
(
DefaultXDisplay
(
)
)
;
}
#
endif
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
mSurfaceProvider
.
Initialize
(
this
)
;
}
#
endif
if
(
mIsDragPopup
)
{
if
(
GdkIsWaylandDisplay
(
)
)
{
if
(
GtkWidget
*
parent
=
gtk_widget_get_parent
(
mShell
)
)
{
GtkWidgetDisableUpdates
(
parent
)
;
}
GtkWidgetDisableUpdates
(
mShell
)
;
GtkWidgetDisableUpdates
(
GTK_WIDGET
(
mContainer
)
)
;
}
else
{
if
(
GtkWidget
*
parent
=
gtk_widget_get_parent
(
mShell
)
)
{
gtk_window_set_opacity
(
GTK_WINDOW
(
parent
)
0
.
0
)
;
}
}
}
if
(
mWindowType
=
=
eWindowType_popup
)
{
if
(
mNoAutoHide
)
{
gint
wmd
=
ConvertBorderStyles
(
mBorderStyle
)
;
if
(
wmd
!
=
-
1
)
{
gdk_window_set_decorations
(
mGdkWindow
(
GdkWMDecoration
)
wmd
)
;
}
}
SetWindowMouseTransparent
(
mMouseTransparent
)
;
}
RefreshWindowClass
(
)
;
if
(
mCompositorState
=
=
COMPOSITOR_PAUSED_INITIALLY
)
{
mCompositorState
=
COMPOSITOR_PAUSED_MISSING_WINDOW
;
}
EnableRenderingToWindow
(
)
;
if
(
mHasMappedToplevel
)
{
EnsureGrabs
(
)
;
}
LOG
(
"
finished
new
GdkWindow
%
p
XID
0x
%
lx
\
n
"
mGdkWindow
GdkIsX11Display
(
)
?
gdk_x11_window_get_xid
(
mGdkWindow
)
:
0
)
;
}
void
nsWindow
:
:
ReleaseGdkWindow
(
)
{
LOG
(
"
nsWindow
:
:
ReleaseGdkWindow
(
)
[
%
p
]
"
this
)
;
DestroyChildWindows
(
)
;
DisableRenderingToWindow
(
)
;
if
(
mGdkWindow
)
{
g_object_set_data
(
G_OBJECT
(
mGdkWindow
)
"
nsWindow
"
nullptr
)
;
mGdkWindow
=
nullptr
;
}
mSurfaceProvider
.
CleanupResources
(
)
;
}
nsresult
nsWindow
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
LOG
(
"
nsWindow
:
:
Create
\
n
"
)
;
nsIWidget
*
baseParent
=
aInitData
&
&
(
aInitData
-
>
mWindowType
=
=
eWindowType_dialog
|
|
aInitData
-
>
mWindowType
=
=
eWindowType_toplevel
|
|
aInitData
-
>
mWindowType
=
=
eWindowType_invisible
)
?
nullptr
:
aParent
;
#
ifdef
ACCESSIBILITY
a11y
:
:
PreInit
(
)
;
#
endif
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
KeymapWrapper
:
:
EnsureInstance
(
)
;
}
#
endif
nsGTKToolkit
:
:
GetToolkit
(
)
;
BaseCreate
(
baseParent
aInitData
)
;
mParent
=
aParent
;
mCreated
=
true
;
mBounds
=
aRect
;
LOG
(
"
mBounds
:
x
:
%
d
y
:
%
d
w
:
%
d
h
:
%
d
\
n
"
mBounds
.
x
mBounds
.
y
mBounds
.
width
mBounds
.
height
)
;
mPreferredPopupRectFlushed
=
false
;
ConstrainSize
(
&
mBounds
.
width
&
mBounds
.
height
)
;
GtkWidget
*
eventWidget
=
nullptr
;
bool
popupNeedsAlphaVisual
=
(
mWindowType
=
=
eWindowType_popup
&
&
(
aInitData
&
&
aInitData
-
>
mSupportTranslucency
)
)
;
GdkWindow
*
parentGdkWindow
=
nullptr
;
nsWindow
*
parentnsWindow
=
nullptr
;
if
(
aParent
)
{
parentnsWindow
=
static_cast
<
nsWindow
*
>
(
aParent
)
;
parentGdkWindow
=
parentnsWindow
-
>
mGdkWindow
;
}
else
if
(
aNativeParent
&
&
GDK_IS_WINDOW
(
aNativeParent
)
)
{
parentGdkWindow
=
GDK_WINDOW
(
aNativeParent
)
;
parentnsWindow
=
get_window_for_gdk_window
(
parentGdkWindow
)
;
if
(
!
parentnsWindow
)
{
return
NS_ERROR_FAILURE
;
}
}
if
(
mWindowType
=
=
eWindowType_child
)
{
mWindowType
=
eWindowType_popup
;
if
(
!
parentnsWindow
)
{
if
(
aNativeParent
&
&
GTK_IS_CONTAINER
(
aNativeParent
)
)
{
parentnsWindow
=
get_window_for_gtk_widget
(
GTK_WIDGET
(
aNativeParent
)
)
;
}
}
mIsChildWindow
=
true
;
LOG
(
"
child
widget
switch
to
popup
.
parent
nsWindow
%
p
"
parentnsWindow
)
;
}
if
(
mWindowType
=
=
eWindowType_popup
&
&
!
parentnsWindow
)
{
LOG
(
"
popup
window
without
parent
!
"
)
;
if
(
GdkIsWaylandDisplay
(
)
)
{
LOG
(
"
switch
to
toplevel
on
Wayland
.
"
)
;
mIsWaylandPanelWindow
=
true
;
mWindowType
=
eWindowType_toplevel
;
}
}
if
(
mWindowType
!
=
eWindowType_dialog
&
&
mWindowType
!
=
eWindowType_popup
&
&
mWindowType
!
=
eWindowType_toplevel
&
&
mWindowType
!
=
eWindowType_invisible
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
eWindowType
"
)
;
return
NS_ERROR_FAILURE
;
}
mAlwaysOnTop
=
aInitData
&
&
aInitData
-
>
mAlwaysOnTop
;
mIsPIPWindow
=
aInitData
&
&
aInitData
-
>
mPIPWindow
;
mNoAutoHide
=
aInitData
&
&
aInitData
-
>
mNoAutoHide
;
mMouseTransparent
=
aInitData
&
&
aInitData
-
>
mMouseTransparent
;
GtkWindowType
type
=
GTK_WINDOW_TOPLEVEL
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
MOZ_ASSERT
(
aInitData
)
;
type
=
GTK_WINDOW_POPUP
;
if
(
GdkIsX11Display
(
)
&
&
mNoAutoHide
)
{
type
=
GTK_WINDOW_TOPLEVEL
;
}
}
mShell
=
gtk_window_new
(
type
)
;
Unused
<
<
gfxPlatform
:
:
GetPlatform
(
)
;
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
{
mGtkWindowDecoration
=
GetSystemGtkWindowDecoration
(
)
;
}
bool
toplevelNeedsAlphaVisual
=
false
;
if
(
mWindowType
=
=
eWindowType_toplevel
&
&
!
mIsPIPWindow
)
{
toplevelNeedsAlphaVisual
=
IsToplevelWindowTransparent
(
)
;
}
bool
isGLVisualSet
=
false
;
mIsAccelerated
=
ComputeShouldAccelerate
(
)
;
#
ifdef
MOZ_X11
if
(
GdkIsX11Display
(
)
&
&
mIsAccelerated
)
{
isGLVisualSet
=
ConfigureX11GLVisual
(
)
;
}
#
endif
if
(
!
isGLVisualSet
&
&
(
popupNeedsAlphaVisual
|
|
toplevelNeedsAlphaVisual
)
)
{
if
(
mCompositedScreen
)
{
GdkVisual
*
visual
=
gdk_screen_get_rgba_visual
(
gtk_widget_get_screen
(
mShell
)
)
;
if
(
visual
)
{
gtk_widget_set_visual
(
mShell
visual
)
;
mHasAlphaVisual
=
true
;
}
}
}
mTransparencyBitmapForTitlebar
=
TitlebarUseShapeMask
(
)
;
if
(
mWindowType
=
=
eWindowType_toplevel
&
&
(
mHasAlphaVisual
|
|
mTransparencyBitmapForTitlebar
)
)
{
mIsTransparent
=
true
;
}
if
(
AreBoundsSane
(
)
)
{
GdkRectangle
size
=
DevicePixelsToGdkSizeRoundUp
(
mBounds
.
Size
(
)
)
;
LOG
(
"
nsWindow
:
:
Create
(
)
Initial
resize
to
%
d
x
%
d
\
n
"
size
.
width
size
.
height
)
;
gtk_window_resize
(
GTK_WINDOW
(
mShell
)
size
.
width
size
.
height
)
;
}
if
(
mWindowType
=
=
eWindowType_dialog
)
{
mGtkWindowRoleName
=
"
Dialog
"
;
SetDefaultIcon
(
)
;
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
GDK_WINDOW_TYPE_HINT_DIALOG
)
;
LOG
(
"
nsWindow
:
:
Create
(
)
:
dialog
"
)
;
if
(
parentnsWindow
)
{
gtk_window_set_transient_for
(
GTK_WINDOW
(
mShell
)
GTK_WINDOW
(
parentnsWindow
-
>
GetGtkWidget
(
)
)
)
;
LOG
(
"
set
parent
window
[
%
p
]
\
n
"
parentnsWindow
)
;
}
}
else
if
(
mWindowType
=
=
eWindowType_popup
)
{
MOZ_ASSERT
(
aInitData
)
;
mGtkWindowRoleName
=
"
Popup
"
;
mPopupHint
=
aInitData
-
>
mPopupHint
;
LOG
(
"
nsWindow
:
:
Create
(
)
Popup
"
)
;
if
(
mNoAutoHide
)
{
if
(
mBorderStyle
=
=
eBorderStyle_default
)
{
gtk_window_set_decorated
(
GTK_WINDOW
(
mShell
)
FALSE
)
;
}
else
{
bool
decorate
=
mBorderStyle
&
eBorderStyle_title
;
gtk_window_set_decorated
(
GTK_WINDOW
(
mShell
)
decorate
)
;
if
(
decorate
)
{
gtk_window_set_deletable
(
GTK_WINDOW
(
mShell
)
mBorderStyle
&
eBorderStyle_close
)
;
}
}
gtk_window_set_skip_taskbar_hint
(
GTK_WINDOW
(
mShell
)
TRUE
)
;
gtk_window_set_accept_focus
(
GTK_WINDOW
(
mShell
)
FALSE
)
;
#
ifdef
MOZ_X11
if
(
GdkIsX11Display
(
)
)
{
gtk_widget_realize
(
mShell
)
;
gdk_window_add_filter
(
gtk_widget_get_window
(
mShell
)
popup_take_focus_filter
nullptr
)
;
}
#
endif
}
if
(
aInitData
-
>
mIsDragPopup
)
{
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
GDK_WINDOW_TYPE_HINT_DND
)
;
mIsDragPopup
=
true
;
LOG
(
"
nsWindow
:
:
Create
(
)
Drag
popup
\
n
"
)
;
}
else
if
(
GdkIsX11Display
(
)
)
{
GdkWindowTypeHint
gtkTypeHint
;
switch
(
mPopupHint
)
{
case
ePopupTypeMenu
:
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_POPUP_MENU
;
break
;
case
ePopupTypeTooltip
:
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_TOOLTIP
;
break
;
default
:
gtkTypeHint
=
GDK_WINDOW_TYPE_HINT_UTILITY
;
break
;
}
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
gtkTypeHint
)
;
LOG
(
"
nsWindow
:
:
Create
(
)
popup
type
%
s
"
GetPopupTypeName
(
)
.
get
(
)
)
;
}
if
(
parentnsWindow
)
{
LOG
(
"
set
parent
window
[
%
p
]
%
s
"
parentnsWindow
parentnsWindow
-
>
mGtkWindowRoleName
.
get
(
)
)
;
GtkWindow
*
parentWidget
=
GTK_WINDOW
(
parentnsWindow
-
>
GetGtkWidget
(
)
)
;
gtk_window_set_transient_for
(
GTK_WINDOW
(
mShell
)
parentWidget
)
;
if
(
GdkIsWaylandDisplay
(
)
&
&
gtk_window_get_modal
(
parentWidget
)
)
{
gtk_window_set_modal
(
GTK_WINDOW
(
mShell
)
true
)
;
}
}
gtk_widget_realize
(
mShell
)
;
if
(
GdkIsX11Display
(
)
)
{
NativeMoveResize
(
true
false
)
;
}
}
else
{
mGtkWindowRoleName
=
"
Toplevel
"
;
SetDefaultIcon
(
)
;
LOG
(
"
nsWindow
:
:
Create
(
)
Toplevel
\
n
"
)
;
if
(
mIsPIPWindow
)
{
LOG
(
"
Is
PIP
Window
\
n
"
)
;
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
GDK_WINDOW_TYPE_HINT_UTILITY
)
;
}
GtkWindowGroup
*
group
=
gtk_window_group_new
(
)
;
gtk_window_group_add_window
(
group
GTK_WINDOW
(
mShell
)
)
;
g_object_unref
(
group
)
;
}
if
(
mAlwaysOnTop
)
{
gtk_window_set_keep_above
(
GTK_WINDOW
(
mShell
)
TRUE
)
;
}
GtkWidget
*
container
=
moz_container_new
(
)
;
mContainer
=
MOZ_CONTAINER
(
container
)
;
mCompositorState
=
COMPOSITOR_PAUSED_INITIALLY
;
gtk_widget_realize
(
mShell
)
;
GtkStyleContext
*
style
=
gtk_widget_get_style_context
(
mShell
)
;
mDrawToContainer
=
GdkIsWaylandDisplay
(
)
|
|
(
mGtkWindowDecoration
=
=
GTK_DECORATION_CLIENT
)
|
|
gtk_style_context_has_class
(
style
"
csd
"
)
;
eventWidget
=
mDrawToContainer
?
container
:
mShell
;
gtk_widget_set_app_paintable
(
eventWidget
gTransparentWindows
)
;
gtk_widget_add_events
(
eventWidget
kEvents
)
;
if
(
mDrawToContainer
)
{
gtk_widget_add_events
(
mShell
GDK_PROPERTY_CHANGE_MASK
)
;
gtk_widget_set_app_paintable
(
mShell
gTransparentWindows
)
;
}
if
(
mTransparencyBitmapForTitlebar
)
{
moz_container_force_default_visual
(
mContainer
)
;
}
gtk_widget_set_has_window
(
container
mDrawToContainer
)
;
gtk_container_add
(
GTK_CONTAINER
(
mShell
)
container
)
;
if
(
mAlwaysOnTop
)
{
gtk_window_set_focus_on_map
(
GTK_WINDOW
(
mShell
)
FALSE
)
;
}
gtk_widget_realize
(
container
)
;
gtk_widget_show
(
container
)
;
if
(
!
mAlwaysOnTop
)
{
gtk_widget_grab_focus
(
container
)
;
}
if
(
mIsWaylandPanelWindow
)
{
gtk_window_set_decorated
(
GTK_WINDOW
(
mShell
)
false
)
;
}
#
ifdef
MOZ_WAYLAND
if
(
mIsDragPopup
&
&
GdkIsWaylandDisplay
(
)
)
{
LOG
(
"
set
commit
to
parent
"
)
;
moz_container_wayland_set_commit_to_parent
(
mContainer
)
;
}
#
endif
if
(
mWindowType
=
=
eWindowType_popup
)
{
MOZ_ASSERT
(
aInitData
)
;
mUpdateCursor
=
true
;
SetCursor
(
Cursor
{
eCursor_standard
}
)
;
}
if
(
mIsChildWindow
&
&
parentnsWindow
)
{
GdkWindow
*
window
=
GetToplevelGdkWindow
(
)
;
GdkWindow
*
parentWindow
=
parentnsWindow
-
>
GetToplevelGdkWindow
(
)
;
LOG
(
"
child
GdkWindow
%
p
set
parent
GdkWindow
%
p
"
window
parentWindow
)
;
gdk_window_reparent
(
window
parentWindow
DevicePixelsToGdkCoordRoundDown
(
mBounds
.
x
)
DevicePixelsToGdkCoordRoundDown
(
mBounds
.
y
)
)
;
}
if
(
mDrawToContainer
)
{
g_object_set_data
(
G_OBJECT
(
gtk_widget_get_window
(
mShell
)
)
"
nsWindow
"
this
)
;
}
g_object_set_data
(
G_OBJECT
(
mContainer
)
"
nsWindow
"
this
)
;
g_object_set_data
(
G_OBJECT
(
mShell
)
"
nsWindow
"
this
)
;
g_signal_connect
(
mShell
"
configure_event
"
G_CALLBACK
(
configure_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
delete_event
"
G_CALLBACK
(
delete_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
window_state_event
"
G_CALLBACK
(
window_state_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
check
-
resize
"
G_CALLBACK
(
check_resize_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
composited
-
changed
"
G_CALLBACK
(
widget_composited_changed_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
property
-
notify
-
event
"
G_CALLBACK
(
property_notify_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
map
"
G_CALLBACK
(
widget_map_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
unrealize
"
G_CALLBACK
(
widget_unrealize_cb
)
nullptr
)
;
if
(
mWindowType
=
=
eWindowType_toplevel
)
{
g_signal_connect_after
(
mShell
"
size_allocate
"
G_CALLBACK
(
toplevel_window_size_allocate_cb
)
nullptr
)
;
}
GdkScreen
*
screen
=
gtk_widget_get_screen
(
mShell
)
;
if
(
!
g_signal_handler_find
(
screen
G_SIGNAL_MATCH_FUNC
0
0
nullptr
FuncToGpointer
(
screen_composited_changed_cb
)
nullptr
)
)
{
g_signal_connect
(
screen
"
composited
-
changed
"
G_CALLBACK
(
screen_composited_changed_cb
)
nullptr
)
;
}
gtk_drag_dest_set
(
(
GtkWidget
*
)
mShell
(
GtkDestDefaults
)
0
nullptr
0
(
GdkDragAction
)
0
)
;
g_signal_connect
(
mShell
"
drag_motion
"
G_CALLBACK
(
drag_motion_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
drag_leave
"
G_CALLBACK
(
drag_leave_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
drag_drop
"
G_CALLBACK
(
drag_drop_event_cb
)
nullptr
)
;
g_signal_connect
(
mShell
"
drag_data_received
"
G_CALLBACK
(
drag_data_received_event_cb
)
nullptr
)
;
GtkSettings
*
default_settings
=
gtk_settings_get_default
(
)
;
g_signal_connect_after
(
default_settings
"
notify
:
:
gtk
-
xft
-
dpi
"
G_CALLBACK
(
settings_xft_dpi_changed_cb
)
this
)
;
g_signal_connect_after
(
mContainer
"
size_allocate
"
G_CALLBACK
(
size_allocate_cb
)
nullptr
)
;
g_signal_connect
(
mContainer
"
hierarchy
-
changed
"
G_CALLBACK
(
hierarchy_changed_cb
)
nullptr
)
;
g_signal_connect
(
mContainer
"
notify
:
:
scale
-
factor
"
G_CALLBACK
(
scale_changed_cb
)
nullptr
)
;
hierarchy_changed_cb
(
GTK_WIDGET
(
mContainer
)
nullptr
)
;
g_signal_connect
(
G_OBJECT
(
mContainer
)
"
draw
"
G_CALLBACK
(
expose_event_cb
)
nullptr
)
;
g_signal_connect
(
mContainer
"
focus_in_event
"
G_CALLBACK
(
focus_in_event_cb
)
nullptr
)
;
g_signal_connect
(
mContainer
"
focus_out_event
"
G_CALLBACK
(
focus_out_event_cb
)
nullptr
)
;
g_signal_connect
(
mContainer
"
key_press_event
"
G_CALLBACK
(
key_press_event_cb
)
nullptr
)
;
g_signal_connect
(
mContainer
"
key_release_event
"
G_CALLBACK
(
key_release_event_cb
)
nullptr
)
;
#
ifdef
MOZ_X11
if
(
GdkIsX11Display
(
)
)
{
GtkWidget
*
widgets
[
]
=
{
GTK_WIDGET
(
mContainer
)
!
mDrawToContainer
?
mShell
:
nullptr
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
widgets
)
&
&
widgets
[
i
]
;
+
+
i
)
{
gtk_widget_set_double_buffered
(
widgets
[
i
]
FALSE
)
;
}
}
#
endif
if
(
mWindowType
!
=
eWindowType_popup
)
{
mIMContext
=
new
IMContextWrapper
(
this
)
;
}
g_signal_connect
(
eventWidget
"
enter
-
notify
-
event
"
G_CALLBACK
(
enter_notify_event_cb
)
nullptr
)
;
g_signal_connect
(
eventWidget
"
leave
-
notify
-
event
"
G_CALLBACK
(
leave_notify_event_cb
)
nullptr
)
;
g_signal_connect
(
eventWidget
"
motion
-
notify
-
event
"
G_CALLBACK
(
motion_notify_event_cb
)
nullptr
)
;
g_signal_connect
(
eventWidget
"
button
-
press
-
event
"
G_CALLBACK
(
button_press_event_cb
)
nullptr
)
;
g_signal_connect
(
eventWidget
"
button
-
release
-
event
"
G_CALLBACK
(
button_release_event_cb
)
nullptr
)
;
g_signal_connect
(
eventWidget
"
scroll
-
event
"
G_CALLBACK
(
scroll_event_cb
)
nullptr
)
;
if
(
gtk_check_version
(
3
18
0
)
=
=
nullptr
)
{
g_signal_connect
(
eventWidget
"
event
"
G_CALLBACK
(
generic_event_cb
)
nullptr
)
;
}
g_signal_connect
(
eventWidget
"
touch
-
event
"
G_CALLBACK
(
touch_event_cb
)
nullptr
)
;
LOG
(
"
nsWindow
type
%
d
%
s
\
n
"
mWindowType
mIsPIPWindow
?
"
PIP
window
"
:
"
"
)
;
LOG
(
"
\
tmShell
%
p
mContainer
%
p
mGdkWindow
%
p
XID
0x
%
lx
\
n
"
mShell
mContainer
mGdkWindow
(
GdkIsX11Display
(
)
&
&
mGdkWindow
)
?
gdk_x11_window_get_xid
(
mGdkWindow
)
:
0
)
;
if
(
mGtkWindowAppName
.
IsEmpty
(
)
)
{
mGtkWindowAppName
=
gAppData
-
>
name
;
}
return
NS_OK
;
}
void
nsWindow
:
:
RefreshWindowClass
(
void
)
{
GdkWindow
*
gdkWindow
=
gtk_widget_get_window
(
mShell
)
;
if
(
!
gdkWindow
)
{
return
;
}
if
(
!
mGtkWindowRoleName
.
IsEmpty
(
)
)
{
gdk_window_set_role
(
gdkWindow
mGtkWindowRoleName
.
get
(
)
)
;
}
#
ifdef
MOZ_X11
if
(
!
mGtkWindowAppName
.
IsEmpty
(
)
&
&
GdkIsX11Display
(
)
)
{
XClassHint
*
class_hint
=
XAllocClassHint
(
)
;
if
(
!
class_hint
)
{
return
;
}
const
char
*
res_class
=
gdk_get_program_class
(
)
;
if
(
!
res_class
)
return
;
class_hint
-
>
res_name
=
const_cast
<
char
*
>
(
mGtkWindowAppName
.
get
(
)
)
;
class_hint
-
>
res_class
=
const_cast
<
char
*
>
(
res_class
)
;
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
XSetClassHint
(
GDK_DISPLAY_XDISPLAY
(
display
)
gdk_x11_window_get_xid
(
gdkWindow
)
class_hint
)
;
XFree
(
class_hint
)
;
}
#
endif
}
void
nsWindow
:
:
SetWindowClass
(
const
nsAString
&
xulWinType
)
{
if
(
!
mShell
)
return
;
char
*
res_name
=
ToNewCString
(
xulWinType
mozilla
:
:
fallible
)
;
if
(
!
res_name
)
return
;
const
char
*
role
=
nullptr
;
for
(
char
*
c
=
res_name
;
*
c
;
c
+
+
)
{
if
(
'
:
'
=
=
*
c
)
{
*
c
=
0
;
role
=
c
+
1
;
}
else
if
(
!
isascii
(
*
c
)
|
|
(
!
isalnum
(
*
c
)
&
&
(
'
_
'
!
=
*
c
)
&
&
(
'
-
'
!
=
*
c
)
)
)
{
*
c
=
'
_
'
;
}
}
res_name
[
0
]
=
(
char
)
toupper
(
res_name
[
0
]
)
;
if
(
!
role
)
role
=
res_name
;
mGtkWindowAppName
=
res_name
;
mGtkWindowRoleName
=
role
;
free
(
res_name
)
;
RefreshWindowClass
(
)
;
}
nsAutoCString
nsWindow
:
:
GetDebugTag
(
)
const
{
nsAutoCString
tag
;
tag
.
AppendPrintf
(
"
[
%
p
]
"
this
)
;
return
tag
;
}
void
nsWindow
:
:
NativeMoveResize
(
bool
aMoved
bool
aResized
)
{
GdkRectangle
size
=
DevicePixelsToGdkSizeRoundUp
(
mBounds
.
Size
(
)
)
;
GdkPoint
topLeft
=
DevicePixelsToGdkPointRoundDown
(
mBounds
.
TopLeft
(
)
)
;
LOG
(
"
nsWindow
:
:
NativeMoveResize
move
%
d
resize
%
d
to
%
d
%
d
-
>
%
d
x
%
d
\
n
"
aMoved
aResized
topLeft
.
x
topLeft
.
y
size
.
width
size
.
height
)
;
if
(
aResized
&
&
!
AreBoundsSane
(
)
)
{
LOG
(
"
bounds
are
insane
hidding
the
window
"
)
;
if
(
!
mNeedsShow
&
&
mIsShown
)
{
mNeedsShow
=
true
;
NativeShow
(
false
)
;
}
if
(
aMoved
)
{
LOG
(
"
moving
to
%
d
x
%
d
"
topLeft
.
x
topLeft
.
y
)
;
gtk_window_move
(
GTK_WINDOW
(
mShell
)
topLeft
.
x
topLeft
.
y
)
;
}
return
;
}
if
(
aMoved
&
&
GdkIsX11Display
(
)
&
&
IsPopup
(
)
&
&
!
gtk_widget_get_visible
(
GTK_WIDGET
(
mShell
)
)
)
{
LOG
(
"
store
position
of
hidden
popup
window
"
)
;
mHiddenPopupPositioned
=
true
;
mPopupPosition
=
topLeft
;
}
if
(
IsWaylandPopup
(
)
)
{
NativeMoveResizeWaylandPopup
(
aMoved
aResized
)
;
}
else
{
if
(
aMoved
)
{
gtk_window_move
(
GTK_WINDOW
(
mShell
)
topLeft
.
x
topLeft
.
y
)
;
}
if
(
aResized
)
{
gtk_window_resize
(
GTK_WINDOW
(
mShell
)
size
.
width
size
.
height
)
;
if
(
mIsDragPopup
)
{
gtk_widget_set_size_request
(
GTK_WIDGET
(
mShell
)
size
.
width
size
.
height
)
;
}
}
}
if
(
mCompositorWidgetDelegate
&
&
aResized
)
{
mCompositorWidgetDelegate
-
>
NotifyClientSizeChanged
(
GetClientSize
(
)
)
;
}
if
(
mNeedsShow
&
&
mIsShown
&
&
aResized
)
{
NativeShow
(
true
)
;
}
}
void
nsWindow
:
:
ResumeCompositorHiddenWindow
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
"
nsWindow
:
:
ResumeCompositorHiddenWindow
\
n
"
)
;
if
(
mIsDestroyed
|
|
mCompositorState
=
=
COMPOSITOR_ENABLED
)
{
LOG
(
"
early
quit
\
n
"
)
;
return
;
}
if
(
CompositorBridgeChild
*
remoteRenderer
=
GetRemoteRenderer
(
)
)
{
LOG
(
"
resume
\
n
"
)
;
MOZ_ASSERT
(
mCompositorWidgetDelegate
)
;
if
(
mCompositorWidgetDelegate
)
{
mCompositorState
=
COMPOSITOR_ENABLED
;
remoteRenderer
-
>
SendResumeAsync
(
)
;
}
remoteRenderer
-
>
SendForcePresent
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
}
else
{
LOG
(
"
quit
failed
to
get
remote
renderer
.
\
n
"
)
;
}
}
void
nsWindow
:
:
PauseCompositorHiddenWindow
(
)
{
LOG
(
"
nsWindow
:
:
PauseCompositorHiddenWindow
"
)
;
if
(
mCompositorState
!
=
COMPOSITOR_ENABLED
)
{
LOG
(
"
quit
early
compositor
is
disabled
"
)
;
return
;
}
mCompositorState
=
COMPOSITOR_PAUSED_MISSING_WINDOW
;
CompositorBridgeChild
*
remoteRenderer
=
GetRemoteRenderer
(
)
;
if
(
!
remoteRenderer
|
|
!
mCompositorWidgetDelegate
)
{
LOG
(
"
deleted
layer
manager
"
)
;
DestroyLayerManager
(
)
;
return
;
}
LOG
(
"
paused
compositor
"
)
;
remoteRenderer
-
>
SendPause
(
)
;
}
static
int
WindowResumeCompositor
(
void
*
data
)
{
nsWindow
*
window
=
static_cast
<
nsWindow
*
>
(
data
)
;
window
-
>
ResumeCompositor
(
)
;
return
true
;
}
#
define
COMPOSITOR_PAUSE_TIMEOUT
(
1000
)
void
nsWindow
:
:
PauseCompositor
(
)
{
bool
pauseCompositor
=
(
mWindowType
=
=
eWindowType_toplevel
)
&
&
mCompositorState
=
=
COMPOSITOR_ENABLED
&
&
mCompositorWidgetDelegate
&
&
!
mIsDestroyed
;
if
(
!
pauseCompositor
)
{
return
;
}
LOG
(
"
nsWindow
:
:
PauseCompositor
(
)
"
)
;
if
(
mCompositorPauseTimeoutID
)
{
g_source_remove
(
mCompositorPauseTimeoutID
)
;
mCompositorPauseTimeoutID
=
0
;
}
CompositorBridgeChild
*
remoteRenderer
=
GetRemoteRenderer
(
)
;
if
(
remoteRenderer
)
{
remoteRenderer
-
>
SendPause
(
)
;
mCompositorState
=
COMPOSITOR_PAUSED_FLICKERING
;
mCompositorPauseTimeoutID
=
(
int
)
g_timeout_add
(
COMPOSITOR_PAUSE_TIMEOUT
&
WindowResumeCompositor
this
)
;
}
}
bool
nsWindow
:
:
IsWaitingForCompositorResume
(
)
{
return
mCompositorState
=
=
COMPOSITOR_PAUSED_FLICKERING
;
}
void
nsWindow
:
:
ResumeCompositor
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
LOG
(
"
nsWindow
:
:
ResumeCompositor
(
)
\
n
"
)
;
if
(
mIsDestroyed
|
|
!
IsWaitingForCompositorResume
(
)
)
{
LOG
(
"
early
quit
\
n
"
)
;
return
;
}
if
(
mCompositorPauseTimeoutID
)
{
g_source_remove
(
mCompositorPauseTimeoutID
)
;
mCompositorPauseTimeoutID
=
0
;
}
MOZ_RELEASE_ASSERT
(
mCompositorWidgetDelegate
)
;
CompositorBridgeChild
*
remoteRenderer
=
GetRemoteRenderer
(
)
;
if
(
remoteRenderer
)
{
mCompositorState
=
COMPOSITOR_ENABLED
;
remoteRenderer
-
>
SendResumeAsync
(
)
;
remoteRenderer
-
>
SendForcePresent
(
wr
:
:
RenderReasons
:
:
WIDGET
)
;
}
}
void
nsWindow
:
:
ResumeCompositorFromCompositorThread
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
nsWindow
:
:
ResumeCompositor
"
this
&
nsWindow
:
:
ResumeCompositor
)
;
NS_DispatchToMainThread
(
event
.
forget
(
)
)
;
}
void
nsWindow
:
:
WaylandStartVsync
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
!
GdkIsWaylandDisplay
(
)
|
|
!
StaticPrefs
:
:
widget_wayland_vsync_enabled_AtStartup
(
)
|
|
mWindowType
!
=
eWindowType_toplevel
)
{
return
;
}
LOG
(
"
nsWindow
:
:
WaylandStartVsync
(
)
"
)
;
if
(
!
mWaylandVsyncSource
)
{
mWaylandVsyncSource
=
new
WaylandVsyncSource
(
)
;
}
WaylandVsyncSource
:
:
WaylandDisplay
&
display
=
static_cast
<
WaylandVsyncSource
:
:
WaylandDisplay
&
>
(
mWaylandVsyncSource
-
>
GetGlobalDisplay
(
)
)
;
if
(
mCompositorWidgetDelegate
)
{
if
(
RefPtr
<
layers
:
:
NativeLayerRoot
>
nativeLayerRoot
=
mCompositorWidgetDelegate
-
>
AsGtkCompositorWidget
(
)
-
>
GetNativeLayerRoot
(
)
)
{
display
.
MaybeUpdateSource
(
nativeLayerRoot
-
>
AsNativeLayerRootWayland
(
)
)
;
}
else
{
display
.
MaybeUpdateSource
(
mContainer
)
;
}
}
display
.
EnableMonitor
(
)
;
#
endif
}
void
nsWindow
:
:
WaylandStopVsync
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
mWaylandVsyncSource
)
{
LOG
(
"
nsWindow
:
:
WaylandStopVsync
(
)
"
)
;
WaylandVsyncSource
:
:
WaylandDisplay
&
display
=
static_cast
<
WaylandVsyncSource
:
:
WaylandDisplay
&
>
(
mWaylandVsyncSource
-
>
GetGlobalDisplay
(
)
)
;
display
.
DisableMonitor
(
)
;
display
.
MaybeUpdateSource
(
nullptr
)
;
}
#
endif
}
void
nsWindow
:
:
NativeShow
(
bool
aAction
)
{
if
(
aAction
)
{
mNeedsShow
=
true
;
auto
removeShow
=
MakeScopeExit
(
[
&
]
{
mNeedsShow
=
false
;
}
)
;
LOG
(
"
nsWindow
:
:
NativeShow
show
\
n
"
)
;
if
(
IsWaylandPopup
(
)
)
{
mPopupClosed
=
false
;
if
(
WaylandPopupNeedsTrackInHierarchy
(
)
)
{
AddWindowToPopupHierarchy
(
)
;
UpdateWaylandPopupHierarchy
(
)
;
if
(
mPopupClosed
)
{
return
;
}
}
}
if
(
mWindowType
!
=
eWindowType_invisible
)
{
SetUserTimeAndStartupIDForActivatedWindow
(
mShell
)
;
}
if
(
GdkIsWaylandDisplay
(
)
)
{
ShowWaylandWindow
(
)
;
}
else
{
LOG
(
"
calling
gtk_widget_show
(
mShell
)
\
n
"
)
;
gtk_widget_show
(
mShell
)
;
}
if
(
mHiddenPopupPositioned
&
&
IsPopup
(
)
)
{
LOG
(
"
re
-
position
hidden
popup
window
"
)
;
gtk_window_move
(
GTK_WINDOW
(
mShell
)
mPopupPosition
.
x
mPopupPosition
.
y
)
;
mHiddenPopupPositioned
=
false
;
}
}
else
{
mPreferredPopupRect
=
nsRect
(
0
0
0
0
)
;
mPreferredPopupRectFlushed
=
false
;
LOG
(
"
nsWindow
:
:
NativeShow
hide
\
n
"
)
;
if
(
GdkIsWaylandDisplay
(
)
)
{
if
(
IsWaylandPopup
(
)
)
{
if
(
IsInPopupHierarchy
(
)
)
{
WaylandPopupMarkAsClosed
(
)
;
UpdateWaylandPopupHierarchy
(
)
;
}
else
{
HideWaylandPopupWindow
(
false
true
)
;
}
}
else
{
HideWaylandToplevelWindow
(
)
;
}
}
else
{
if
(
gtk_check_version
(
3
21
2
)
!
=
nullptr
&
&
mPendingConfigures
>
0
)
{
GtkAllocation
allocation
;
gtk_widget_get_allocation
(
GTK_WIDGET
(
mShell
)
&
allocation
)
;
GdkEventConfigure
event
;
PodZero
(
&
event
)
;
event
.
type
=
GDK_CONFIGURE
;
event
.
window
=
mGdkWindow
;
event
.
send_event
=
TRUE
;
event
.
x
=
allocation
.
x
;
event
.
y
=
allocation
.
y
;
event
.
width
=
allocation
.
width
;
event
.
height
=
allocation
.
height
;
auto
*
shellClass
=
GTK_WIDGET_GET_CLASS
(
mShell
)
;
for
(
unsigned
int
i
=
0
;
i
<
mPendingConfigures
;
i
+
+
)
{
Unused
<
<
shellClass
-
>
configure_event
(
mShell
&
event
)
;
}
mPendingConfigures
=
0
;
}
gtk_widget_hide
(
mShell
)
;
ClearTransparencyBitmap
(
)
;
}
}
}
void
nsWindow
:
:
SetHasMappedToplevel
(
bool
aState
)
{
LOG
(
"
nsWindow
:
:
SetHasMappedToplevel
(
)
state
%
d
"
aState
)
;
bool
oldState
=
mHasMappedToplevel
;
mHasMappedToplevel
=
aState
;
if
(
!
mIsShown
|
|
!
mGdkWindow
)
{
LOG
(
"
hidden
quit
.
\
n
"
)
;
return
;
}
if
(
aState
&
&
!
oldState
)
{
EnsureGrabs
(
)
;
}
}
LayoutDeviceIntSize
nsWindow
:
:
GetSafeWindowSize
(
LayoutDeviceIntSize
aSize
)
{
LayoutDeviceIntSize
result
=
aSize
;
int32_t
maxSize
=
32767
;
if
(
mWindowRenderer
&
&
mWindowRenderer
-
>
AsKnowsCompositor
(
)
)
{
maxSize
=
std
:
:
min
(
maxSize
mWindowRenderer
-
>
AsKnowsCompositor
(
)
-
>
GetMaxTextureSize
(
)
)
;
}
if
(
result
.
width
>
maxSize
)
{
result
.
width
=
maxSize
;
}
if
(
result
.
height
>
maxSize
)
{
result
.
height
=
maxSize
;
}
return
result
;
}
void
nsWindow
:
:
EnsureGrabs
(
void
)
{
if
(
mRetryPointerGrab
)
{
GrabPointer
(
sRetryGrabTime
)
;
}
}
void
nsWindow
:
:
CleanLayerManagerRecursive
(
void
)
{
if
(
mWindowRenderer
)
{
mWindowRenderer
-
>
Destroy
(
)
;
mWindowRenderer
=
nullptr
;
}
DestroyCompositor
(
)
;
}
void
nsWindow
:
:
SetTransparencyMode
(
nsTransparencyMode
aMode
)
{
bool
isTransparent
=
aMode
=
=
eTransparencyTransparent
;
if
(
mIsTransparent
=
=
isTransparent
)
{
return
;
}
if
(
mWindowType
!
=
eWindowType_popup
)
{
if
(
isTransparent
)
{
NS_WARNING
(
"
Transparent
mode
not
supported
on
non
-
popup
windows
.
"
)
;
}
return
;
}
if
(
!
isTransparent
)
{
ClearTransparencyBitmap
(
)
;
}
mIsTransparent
=
isTransparent
;
if
(
!
mHasAlphaVisual
)
{
CleanLayerManagerRecursive
(
)
;
}
}
nsTransparencyMode
nsWindow
:
:
GetTransparencyMode
(
)
{
return
mIsTransparent
?
eTransparencyTransparent
:
eTransparencyOpaque
;
}
void
nsWindow
:
:
SetWindowMouseTransparent
(
bool
aIsTransparent
)
{
mMouseTransparent
=
aIsTransparent
;
GdkWindow
*
window
=
mDrawToContainer
?
gtk_widget_get_window
(
mShell
)
:
mGdkWindow
;
if
(
!
window
)
{
return
;
}
LOG
(
"
nsWindow
:
:
SetWindowMouseTransparent
(
%
d
)
"
aIsTransparent
)
;
cairo_rectangle_int_t
emptyRect
=
{
0
0
0
0
}
;
cairo_region_t
*
region
=
aIsTransparent
?
cairo_region_create_rectangle
(
&
emptyRect
)
:
nullptr
;
gdk_window_input_shape_combine_region
(
window
region
0
0
)
;
if
(
region
)
{
cairo_region_destroy
(
region
)
;
}
if
(
GdkIsWaylandDisplay
(
)
)
{
gdk_window_invalidate_rect
(
window
nullptr
false
)
;
}
}
void
nsWindow
:
:
UpdateWindowDraggingRegion
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
if
(
mDraggableRegion
!
=
aRegion
)
{
mDraggableRegion
=
aRegion
;
}
}
LayoutDeviceIntCoord
nsWindow
:
:
GetTitlebarRadius
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
int32_t
cssCoord
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
TitlebarRadius
)
;
return
GdkCoordToDevicePixels
(
cssCoord
)
;
}
static
void
SubtractTitlebarCorners
(
cairo_region_t
*
aRegion
int
aX
int
aY
int
aWindowWidth
int
aTitlebarRadius
)
{
if
(
!
aTitlebarRadius
)
{
return
;
}
cairo_rectangle_int_t
rect
=
{
aX
aY
aTitlebarRadius
aTitlebarRadius
}
;
cairo_region_subtract_rectangle
(
aRegion
&
rect
)
;
rect
=
{
aX
+
aWindowWidth
-
aTitlebarRadius
aY
aTitlebarRadius
aTitlebarRadius
}
;
cairo_region_subtract_rectangle
(
aRegion
&
rect
)
;
}
void
nsWindow
:
:
UpdateTopLevelOpaqueRegion
(
void
)
{
if
(
!
mCompositedScreen
)
{
return
;
}
GdkWindow
*
window
=
mDrawToContainer
?
gtk_widget_get_window
(
mShell
)
:
mGdkWindow
;
if
(
!
window
)
{
return
;
}
MOZ_ASSERT
(
gdk_window_get_window_type
(
window
)
=
=
GDK_WINDOW_TOPLEVEL
)
;
int
x
=
0
;
int
y
=
0
;
if
(
mDrawToContainer
)
{
gdk_window_get_position
(
mGdkWindow
&
x
&
y
)
;
}
int
width
=
DevicePixelsToGdkCoordRoundDown
(
mBounds
.
width
)
;
int
height
=
DevicePixelsToGdkCoordRoundDown
(
mBounds
.
height
)
;
cairo_region_t
*
region
=
cairo_region_create
(
)
;
cairo_rectangle_int_t
rect
=
{
x
y
width
height
}
;
cairo_region_union_rectangle
(
region
&
rect
)
;
int
radius
=
DoDrawTilebarCorners
(
)
?
int
(
GetTitlebarRadius
(
)
)
:
0
;
SubtractTitlebarCorners
(
region
x
y
width
radius
)
;
gdk_window_set_opaque_region
(
window
region
)
;
cairo_region_destroy
(
region
)
;
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
moz_container_wayland_update_opaque_region
(
mContainer
radius
)
;
}
#
endif
}
bool
nsWindow
:
:
IsChromeWindowTitlebar
(
)
{
return
mDrawInTitlebar
&
&
!
mIsPIPWindow
&
&
mWindowType
=
=
eWindowType_toplevel
;
}
bool
nsWindow
:
:
DoDrawTilebarCorners
(
)
{
return
IsChromeWindowTitlebar
(
)
&
&
mSizeState
=
=
nsSizeMode_Normal
&
&
!
mIsTiled
;
}
void
nsWindow
:
:
ResizeTransparencyBitmap
(
)
{
if
(
!
mTransparencyBitmap
)
return
;
if
(
mBounds
.
width
=
=
mTransparencyBitmapWidth
&
&
mBounds
.
height
=
=
mTransparencyBitmapHeight
)
{
return
;
}
int32_t
newRowBytes
=
GetBitmapStride
(
mBounds
.
width
)
;
int32_t
newSize
=
newRowBytes
*
mBounds
.
height
;
auto
*
newBits
=
new
gchar
[
newSize
]
;
memset
(
newBits
0
newSize
)
;
int32_t
copyWidth
=
std
:
:
min
(
mBounds
.
width
mTransparencyBitmapWidth
)
;
int32_t
copyHeight
=
std
:
:
min
(
mBounds
.
height
mTransparencyBitmapHeight
)
;
int32_t
oldRowBytes
=
GetBitmapStride
(
mTransparencyBitmapWidth
)
;
int32_t
copyBytes
=
GetBitmapStride
(
copyWidth
)
;
int32_t
i
;
gchar
*
fromPtr
=
mTransparencyBitmap
;
gchar
*
toPtr
=
newBits
;
for
(
i
=
0
;
i
<
copyHeight
;
i
+
+
)
{
memcpy
(
toPtr
fromPtr
copyBytes
)
;
fromPtr
+
=
oldRowBytes
;
toPtr
+
=
newRowBytes
;
}
delete
[
]
mTransparencyBitmap
;
mTransparencyBitmap
=
newBits
;
mTransparencyBitmapWidth
=
mBounds
.
width
;
mTransparencyBitmapHeight
=
mBounds
.
height
;
}
static
bool
ChangedMaskBits
(
gchar
*
aMaskBits
int32_t
aMaskWidth
int32_t
aMaskHeight
const
nsIntRect
&
aRect
uint8_t
*
aAlphas
int32_t
aStride
)
{
int32_t
x
y
xMax
=
aRect
.
XMost
(
)
yMax
=
aRect
.
YMost
(
)
;
int32_t
maskBytesPerRow
=
GetBitmapStride
(
aMaskWidth
)
;
for
(
y
=
aRect
.
y
;
y
<
yMax
;
y
+
+
)
{
gchar
*
maskBytes
=
aMaskBits
+
y
*
maskBytesPerRow
;
uint8_t
*
alphas
=
aAlphas
;
for
(
x
=
aRect
.
x
;
x
<
xMax
;
x
+
+
)
{
bool
newBit
=
*
alphas
>
0x7f
;
alphas
+
+
;
gchar
maskByte
=
maskBytes
[
x
>
>
3
]
;
bool
maskBit
=
(
maskByte
&
(
1
<
<
(
x
&
7
)
)
)
!
=
0
;
if
(
maskBit
!
=
newBit
)
{
return
true
;
}
}
aAlphas
+
=
aStride
;
}
return
false
;
}
static
void
UpdateMaskBits
(
gchar
*
aMaskBits
int32_t
aMaskWidth
int32_t
aMaskHeight
const
nsIntRect
&
aRect
uint8_t
*
aAlphas
int32_t
aStride
)
{
int32_t
x
y
xMax
=
aRect
.
XMost
(
)
yMax
=
aRect
.
YMost
(
)
;
int32_t
maskBytesPerRow
=
GetBitmapStride
(
aMaskWidth
)
;
for
(
y
=
aRect
.
y
;
y
<
yMax
;
y
+
+
)
{
gchar
*
maskBytes
=
aMaskBits
+
y
*
maskBytesPerRow
;
uint8_t
*
alphas
=
aAlphas
;
for
(
x
=
aRect
.
x
;
x
<
xMax
;
x
+
+
)
{
bool
newBit
=
*
alphas
>
0x7f
;
alphas
+
+
;
gchar
mask
=
1
<
<
(
x
&
7
)
;
gchar
maskByte
=
maskBytes
[
x
>
>
3
]
;
maskBytes
[
x
>
>
3
]
=
(
maskByte
&
~
mask
)
|
(
-
newBit
&
mask
)
;
}
aAlphas
+
=
aStride
;
}
}
void
nsWindow
:
:
ApplyTransparencyBitmap
(
)
{
#
ifdef
MOZ_X11
Display
*
xDisplay
=
GDK_WINDOW_XDISPLAY
(
mGdkWindow
)
;
Window
xDrawable
=
GDK_WINDOW_XID
(
mGdkWindow
)
;
Pixmap
maskPixmap
=
XCreateBitmapFromData
(
xDisplay
xDrawable
mTransparencyBitmap
mTransparencyBitmapWidth
mTransparencyBitmapHeight
)
;
XShapeCombineMask
(
xDisplay
xDrawable
ShapeBounding
0
0
maskPixmap
ShapeSet
)
;
XFreePixmap
(
xDisplay
maskPixmap
)
;
#
else
cairo_surface_t
*
maskBitmap
;
maskBitmap
=
cairo_image_surface_create_for_data
(
(
unsigned
char
*
)
mTransparencyBitmap
CAIRO_FORMAT_A1
mTransparencyBitmapWidth
mTransparencyBitmapHeight
GetBitmapStride
(
mTransparencyBitmapWidth
)
)
;
if
(
!
maskBitmap
)
return
;
cairo_region_t
*
maskRegion
=
gdk_cairo_region_create_from_surface
(
maskBitmap
)
;
gtk_widget_shape_combine_region
(
mShell
maskRegion
)
;
cairo_region_destroy
(
maskRegion
)
;
cairo_surface_destroy
(
maskBitmap
)
;
#
endif
}
void
nsWindow
:
:
ClearTransparencyBitmap
(
)
{
if
(
!
mTransparencyBitmap
)
return
;
delete
[
]
mTransparencyBitmap
;
mTransparencyBitmap
=
nullptr
;
mTransparencyBitmapWidth
=
0
;
mTransparencyBitmapHeight
=
0
;
if
(
!
mShell
)
return
;
#
ifdef
MOZ_X11
if
(
MOZ_UNLIKELY
(
!
mGdkWindow
)
)
{
return
;
}
Display
*
xDisplay
=
GDK_WINDOW_XDISPLAY
(
mGdkWindow
)
;
Window
xWindow
=
gdk_x11_window_get_xid
(
mGdkWindow
)
;
XShapeCombineMask
(
xDisplay
xWindow
ShapeBounding
0
0
X11None
ShapeSet
)
;
#
endif
}
nsresult
nsWindow
:
:
UpdateTranslucentWindowAlphaInternal
(
const
nsIntRect
&
aRect
uint8_t
*
aAlphas
int32_t
aStride
)
{
NS_ASSERTION
(
mIsTransparent
"
Window
is
not
transparent
"
)
;
NS_ASSERTION
(
!
mTransparencyBitmapForTitlebar
"
Transparency
bitmap
is
already
used
for
titlebar
rendering
"
)
;
if
(
mTransparencyBitmap
=
=
nullptr
)
{
int32_t
size
=
GetBitmapStride
(
mBounds
.
width
)
*
mBounds
.
height
;
mTransparencyBitmap
=
new
gchar
[
size
]
;
memset
(
mTransparencyBitmap
255
size
)
;
mTransparencyBitmapWidth
=
mBounds
.
width
;
mTransparencyBitmapHeight
=
mBounds
.
height
;
}
else
{
ResizeTransparencyBitmap
(
)
;
}
nsIntRect
rect
;
rect
.
IntersectRect
(
aRect
nsIntRect
(
0
0
mBounds
.
width
mBounds
.
height
)
)
;
if
(
!
ChangedMaskBits
(
mTransparencyBitmap
mBounds
.
width
mBounds
.
height
rect
aAlphas
aStride
)
)
{
return
NS_OK
;
}
UpdateMaskBits
(
mTransparencyBitmap
mBounds
.
width
mBounds
.
height
rect
aAlphas
aStride
)
;
if
(
!
mNeedsShow
)
{
ApplyTransparencyBitmap
(
)
;
}
return
NS_OK
;
}
#
define
TITLEBAR_HEIGHT
10
LayoutDeviceIntRect
nsWindow
:
:
GetTitlebarRect
(
)
{
if
(
!
mGdkWindow
|
|
!
mDrawInTitlebar
)
{
return
LayoutDeviceIntRect
(
)
;
}
int
height
=
0
;
if
(
DoDrawTilebarCorners
(
)
)
{
height
=
GdkCeiledScaleFactor
(
)
*
TITLEBAR_HEIGHT
;
}
return
LayoutDeviceIntRect
(
0
0
mBounds
.
width
height
)
;
}
void
nsWindow
:
:
UpdateTitlebarTransparencyBitmap
(
)
{
NS_ASSERTION
(
mTransparencyBitmapForTitlebar
"
Transparency
bitmap
is
already
used
to
draw
window
shape
"
)
;
if
(
!
mGdkWindow
|
|
!
mDrawInTitlebar
|
|
(
mBounds
.
width
=
=
mTransparencyBitmapWidth
&
&
mBounds
.
height
=
=
mTransparencyBitmapHeight
)
)
{
return
;
}
bool
maskCreate
=
!
mTransparencyBitmap
|
|
mBounds
.
width
>
mTransparencyBitmapWidth
;
bool
maskUpdate
=
!
mTransparencyBitmap
|
|
mBounds
.
width
!
=
mTransparencyBitmapWidth
;
LayoutDeviceIntCoord
radius
=
GetTitlebarRadius
(
)
;
if
(
maskCreate
)
{
delete
[
]
mTransparencyBitmap
;
int32_t
size
=
GetBitmapStride
(
mBounds
.
width
)
*
radius
;
mTransparencyBitmap
=
new
gchar
[
size
]
;
mTransparencyBitmapWidth
=
mBounds
.
width
;
}
else
{
mTransparencyBitmapWidth
=
mBounds
.
width
;
}
mTransparencyBitmapHeight
=
mBounds
.
height
;
if
(
maskUpdate
)
{
cairo_surface_t
*
surface
=
cairo_image_surface_create
(
CAIRO_FORMAT_A8
mTransparencyBitmapWidth
radius
)
;
if
(
!
surface
)
return
;
cairo_t
*
cr
=
cairo_create
(
surface
)
;
GtkWidgetState
state
;
memset
(
(
void
*
)
&
state
0
sizeof
(
state
)
)
;
GdkRectangle
rect
=
{
0
0
mTransparencyBitmapWidth
radius
}
;
moz_gtk_widget_paint
(
MOZ_GTK_HEADER_BAR
cr
&
rect
&
state
0
GTK_TEXT_DIR_NONE
)
;
cairo_destroy
(
cr
)
;
cairo_surface_mark_dirty
(
surface
)
;
cairo_surface_flush
(
surface
)
;
UpdateMaskBits
(
mTransparencyBitmap
mTransparencyBitmapWidth
radius
nsIntRect
(
0
0
mTransparencyBitmapWidth
radius
)
cairo_image_surface_get_data
(
surface
)
cairo_format_stride_for_width
(
CAIRO_FORMAT_A8
mTransparencyBitmapWidth
)
)
;
cairo_surface_destroy
(
surface
)
;
}
if
(
!
mNeedsShow
)
{
Display
*
xDisplay
=
GDK_WINDOW_XDISPLAY
(
mGdkWindow
)
;
Window
xDrawable
=
GDK_WINDOW_XID
(
mGdkWindow
)
;
Pixmap
maskPixmap
=
XCreateBitmapFromData
(
xDisplay
xDrawable
mTransparencyBitmap
mTransparencyBitmapWidth
radius
)
;
XShapeCombineMask
(
xDisplay
xDrawable
ShapeBounding
0
0
maskPixmap
ShapeSet
)
;
if
(
mTransparencyBitmapHeight
>
radius
)
{
XRectangle
rect
=
{
0
0
(
unsigned
short
)
mTransparencyBitmapWidth
(
unsigned
short
)
(
mTransparencyBitmapHeight
-
radius
)
}
;
XShapeCombineRectangles
(
xDisplay
xDrawable
ShapeBounding
0
radius
&
rect
1
ShapeUnion
0
)
;
}
XFreePixmap
(
xDisplay
maskPixmap
)
;
}
}
void
nsWindow
:
:
GrabPointer
(
guint32
aTime
)
{
LOG
(
"
GrabPointer
time
=
0x
%
08x
retry
=
%
d
\
n
"
(
unsigned
int
)
aTime
mRetryPointerGrab
)
;
if
(
mIsDestroyed
|
|
GdkIsWaylandDisplay
(
)
)
{
return
;
}
mRetryPointerGrab
=
false
;
sRetryGrabTime
=
aTime
;
if
(
!
mHasMappedToplevel
|
|
!
mGdkWindow
)
{
LOG
(
"
quit
window
not
visible
mHasMappedToplevel
=
%
d
mGdkWindow
=
%
p
"
mHasMappedToplevel
mGdkWindow
)
;
mRetryPointerGrab
=
true
;
return
;
}
gint
retval
;
retval
=
gdk_pointer_grab
(
mGdkWindow
TRUE
(
GdkEventMask
)
(
GDK_BUTTON_PRESS_MASK
|
GDK_BUTTON_RELEASE_MASK
|
GDK_ENTER_NOTIFY_MASK
|
GDK_LEAVE_NOTIFY_MASK
|
GDK_POINTER_MOTION_MASK
|
GDK_TOUCH_MASK
)
(
GdkWindow
*
)
nullptr
nullptr
aTime
)
;
if
(
retval
=
=
GDK_GRAB_NOT_VIEWABLE
)
{
LOG
(
"
failed
:
window
not
viewable
;
will
retry
\
n
"
)
;
mRetryPointerGrab
=
true
;
}
else
if
(
retval
!
=
GDK_GRAB_SUCCESS
)
{
LOG
(
"
pointer
grab
failed
:
%
i
\
n
"
retval
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
nsWindow
:
:
CheckForRollupDuringGrab
"
this
&
nsWindow
:
:
CheckForRollupDuringGrab
)
;
NS_DispatchToCurrentThread
(
event
.
forget
(
)
)
;
}
}
void
nsWindow
:
:
ReleaseGrabs
(
void
)
{
LOG
(
"
ReleaseGrabs
\
n
"
)
;
mRetryPointerGrab
=
false
;
if
(
GdkIsWaylandDisplay
(
)
)
{
return
;
}
gdk_pointer_ungrab
(
GDK_CURRENT_TIME
)
;
}
GtkWidget
*
nsWindow
:
:
GetToplevelWidget
(
)
{
return
mShell
;
}
GdkWindow
*
nsWindow
:
:
GetToplevelGdkWindow
(
)
{
return
gtk_widget_get_window
(
mShell
)
;
}
nsWindow
*
nsWindow
:
:
GetContainerWindow
(
)
{
GtkWidget
*
owningWidget
=
GTK_WIDGET
(
mContainer
)
;
if
(
!
owningWidget
)
return
nullptr
;
nsWindow
*
window
=
get_window_for_gtk_widget
(
owningWidget
)
;
NS_ASSERTION
(
window
"
No
nsWindow
for
container
widget
"
)
;
return
window
;
}
void
nsWindow
:
:
SetUrgencyHint
(
GtkWidget
*
top_window
bool
state
)
{
LOG
(
"
nsWindow
:
:
SetUrgencyHint
widget
%
p
\
n
"
top_window
)
;
if
(
!
top_window
)
return
;
gdk_window_set_urgency_hint
(
gtk_widget_get_window
(
top_window
)
state
)
;
}
void
nsWindow
:
:
SetDefaultIcon
(
void
)
{
SetIcon
(
u
"
default
"
_ns
)
;
}
gint
nsWindow
:
:
ConvertBorderStyles
(
nsBorderStyle
aStyle
)
{
gint
w
=
0
;
if
(
aStyle
=
=
eBorderStyle_default
)
return
-
1
;
if
(
aStyle
&
eBorderStyle_all
)
w
|
=
GDK_DECOR_ALL
;
if
(
aStyle
&
eBorderStyle_border
)
w
|
=
GDK_DECOR_BORDER
;
if
(
aStyle
&
eBorderStyle_resizeh
)
w
|
=
GDK_DECOR_RESIZEH
;
if
(
aStyle
&
eBorderStyle_title
)
w
|
=
GDK_DECOR_TITLE
;
if
(
aStyle
&
eBorderStyle_menu
)
w
|
=
GDK_DECOR_MENU
;
if
(
aStyle
&
eBorderStyle_minimize
)
w
|
=
GDK_DECOR_MINIMIZE
;
if
(
aStyle
&
eBorderStyle_maximize
)
w
|
=
GDK_DECOR_MAXIMIZE
;
return
w
;
}
class
FullscreenTransitionWindow
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
FullscreenTransitionWindow
(
GtkWidget
*
aWidget
)
;
GtkWidget
*
mWindow
;
private
:
~
FullscreenTransitionWindow
(
)
;
}
;
NS_IMPL_ISUPPORTS0
(
FullscreenTransitionWindow
)
FullscreenTransitionWindow
:
:
FullscreenTransitionWindow
(
GtkWidget
*
aWidget
)
{
mWindow
=
gtk_window_new
(
GTK_WINDOW_POPUP
)
;
GtkWindow
*
gtkWin
=
GTK_WINDOW
(
mWindow
)
;
gtk_window_set_type_hint
(
gtkWin
GDK_WINDOW_TYPE_HINT_SPLASHSCREEN
)
;
gtk_window_set_transient_for
(
gtkWin
GTK_WINDOW
(
aWidget
)
)
;
gtk_window_set_decorated
(
gtkWin
false
)
;
GdkWindow
*
gdkWin
=
gtk_widget_get_window
(
aWidget
)
;
GdkScreen
*
screen
=
gtk_widget_get_screen
(
aWidget
)
;
gint
monitorNum
=
gdk_screen_get_monitor_at_window
(
screen
gdkWin
)
;
GdkRectangle
monitorRect
;
gdk_screen_get_monitor_geometry
(
screen
monitorNum
&
monitorRect
)
;
gtk_window_set_screen
(
gtkWin
screen
)
;
gtk_window_move
(
gtkWin
monitorRect
.
x
monitorRect
.
y
)
;
MOZ_ASSERT
(
monitorRect
.
width
>
0
&
&
monitorRect
.
height
>
0
"
Can
'
t
resize
window
smaller
than
1x1
.
"
)
;
gtk_window_resize
(
gtkWin
monitorRect
.
width
monitorRect
.
height
)
;
GdkColor
bgColor
;
bgColor
.
red
=
bgColor
.
green
=
bgColor
.
blue
=
0
;
gtk_widget_modify_bg
(
mWindow
GTK_STATE_NORMAL
&
bgColor
)
;
gtk_window_set_opacity
(
gtkWin
0
.
0
)
;
gtk_widget_show
(
mWindow
)
;
}
FullscreenTransitionWindow
:
:
~
FullscreenTransitionWindow
(
)
{
gtk_widget_destroy
(
mWindow
)
;
}
class
FullscreenTransitionData
{
public
:
FullscreenTransitionData
(
nsIWidget
:
:
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsIRunnable
*
aCallback
FullscreenTransitionWindow
*
aWindow
)
:
mStage
(
aStage
)
mStartTime
(
TimeStamp
:
:
Now
(
)
)
mDuration
(
TimeDuration
:
:
FromMilliseconds
(
aDuration
)
)
mCallback
(
aCallback
)
mWindow
(
aWindow
)
{
}
static
const
guint
sInterval
=
1000
/
30
;
static
gboolean
TimeoutCallback
(
gpointer
aData
)
;
private
:
nsIWidget
:
:
FullscreenTransitionStage
mStage
;
TimeStamp
mStartTime
;
TimeDuration
mDuration
;
nsCOMPtr
<
nsIRunnable
>
mCallback
;
RefPtr
<
FullscreenTransitionWindow
>
mWindow
;
}
;
gboolean
FullscreenTransitionData
:
:
TimeoutCallback
(
gpointer
aData
)
{
bool
finishing
=
false
;
auto
*
data
=
static_cast
<
FullscreenTransitionData
*
>
(
aData
)
;
gdouble
opacity
=
(
TimeStamp
:
:
Now
(
)
-
data
-
>
mStartTime
)
/
data
-
>
mDuration
;
if
(
opacity
>
=
1
.
0
)
{
opacity
=
1
.
0
;
finishing
=
true
;
}
if
(
data
-
>
mStage
=
=
nsIWidget
:
:
eAfterFullscreenToggle
)
{
opacity
=
1
.
0
-
opacity
;
}
gtk_window_set_opacity
(
GTK_WINDOW
(
data
-
>
mWindow
-
>
mWindow
)
opacity
)
;
if
(
!
finishing
)
{
return
TRUE
;
}
NS_DispatchToMainThread
(
data
-
>
mCallback
.
forget
(
)
)
;
delete
data
;
return
FALSE
;
}
bool
nsWindow
:
:
PrepareForFullscreenTransition
(
nsISupports
*
*
aData
)
{
if
(
!
mCompositedScreen
)
{
return
false
;
}
*
aData
=
do_AddRef
(
new
FullscreenTransitionWindow
(
mShell
)
)
.
take
(
)
;
return
true
;
}
void
nsWindow
:
:
PerformFullscreenTransition
(
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsISupports
*
aData
nsIRunnable
*
aCallback
)
{
auto
*
data
=
static_cast
<
FullscreenTransitionWindow
*
>
(
aData
)
;
auto
*
transitionData
=
new
FullscreenTransitionData
(
aStage
aDuration
aCallback
data
)
;
g_timeout_add_full
(
G_PRIORITY_HIGH
FullscreenTransitionData
:
:
sInterval
FullscreenTransitionData
:
:
TimeoutCallback
transitionData
nullptr
)
;
}
already_AddRefed
<
nsIScreen
>
nsWindow
:
:
GetWidgetScreen
(
)
{
if
(
GdkIsWaylandDisplay
(
)
)
{
RefPtr
<
nsIScreen
>
screen
=
ScreenHelperGTK
:
:
GetScreenForWindow
(
this
)
;
if
(
screen
)
{
return
screen
.
forget
(
)
;
}
}
nsCOMPtr
<
nsIScreenManager
>
screenManager
;
screenManager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
!
screenManager
)
{
return
nullptr
;
}
LayoutDeviceIntRect
bounds
=
mBounds
;
DesktopIntRect
deskBounds
=
RoundedToInt
(
bounds
/
GetDesktopToDeviceScale
(
)
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
screenManager
-
>
ScreenForRect
(
deskBounds
.
x
deskBounds
.
y
deskBounds
.
width
deskBounds
.
height
getter_AddRefs
(
screen
)
)
;
return
screen
.
forget
(
)
;
}
RefPtr
<
VsyncSource
>
nsWindow
:
:
GetVsyncSource
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
mWaylandVsyncSource
)
{
return
mWaylandVsyncSource
;
}
#
endif
return
nullptr
;
}
bool
nsWindow
:
:
SynchronouslyRepaintOnResize
(
)
{
if
(
GdkIsWaylandDisplay
(
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsFullscreenSupported
(
GtkWidget
*
aShell
)
{
#
ifdef
MOZ_X11
GdkScreen
*
screen
=
gtk_widget_get_screen
(
aShell
)
;
GdkAtom
atom
=
gdk_atom_intern
(
"
_NET_WM_STATE_FULLSCREEN
"
FALSE
)
;
return
gdk_x11_screen_supports_net_wm_hint
(
screen
atom
)
;
#
elif
return
true
;
#
endif
}
nsresult
nsWindow
:
:
MakeFullScreen
(
bool
aFullScreen
nsIScreen
*
aTargetScreen
)
{
LOG
(
"
nsWindow
:
:
MakeFullScreen
aFullScreen
%
d
\
n
"
aFullScreen
)
;
if
(
GdkIsX11Display
(
)
&
&
!
IsFullscreenSupported
(
mShell
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
bool
wasFullscreen
=
mSizeState
=
=
nsSizeMode_Fullscreen
;
if
(
aFullScreen
!
=
wasFullscreen
&
&
mWidgetListener
)
{
mWidgetListener
-
>
FullscreenWillChange
(
aFullScreen
)
;
}
if
(
aFullScreen
)
{
if
(
mSizeMode
!
=
nsSizeMode_Fullscreen
)
mLastSizeMode
=
mSizeMode
;
mSizeMode
=
nsSizeMode_Fullscreen
;
if
(
mIsPIPWindow
)
{
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
GDK_WINDOW_TYPE_HINT_NORMAL
)
;
if
(
gUseAspectRatio
)
{
mAspectRatioSaved
=
mAspectRatio
;
mAspectRatio
=
0
.
0f
;
ApplySizeConstraints
(
)
;
}
}
gtk_window_fullscreen
(
GTK_WINDOW
(
mShell
)
)
;
}
else
{
mSizeMode
=
mLastSizeMode
;
gtk_window_unfullscreen
(
GTK_WINDOW
(
mShell
)
)
;
if
(
mIsPIPWindow
)
{
gtk_window_set_type_hint
(
GTK_WINDOW
(
mShell
)
GDK_WINDOW_TYPE_HINT_UTILITY
)
;
if
(
gUseAspectRatio
)
{
mAspectRatio
=
mAspectRatioSaved
;
}
}
}
NS_ASSERTION
(
mLastSizeMode
!
=
nsSizeMode_Fullscreen
"
mLastSizeMode
should
never
be
fullscreen
"
)
;
return
NS_OK
;
}
void
nsWindow
:
:
SetWindowDecoration
(
nsBorderStyle
aStyle
)
{
LOG
(
"
nsWindow
:
:
SetWindowDecoration
(
)
Border
style
%
x
\
n
"
aStyle
)
;
GdkWindow
*
window
=
gtk_widget_get_window
(
mShell
)
;
bool
wasVisible
=
false
;
if
(
gdk_window_is_visible
(
window
)
)
{
gdk_window_hide
(
window
)
;
wasVisible
=
true
;
}
gint
wmd
=
ConvertBorderStyles
(
aStyle
)
;
if
(
wmd
!
=
-
1
)
gdk_window_set_decorations
(
window
(
GdkWMDecoration
)
wmd
)
;
if
(
wasVisible
)
gdk_window_show
(
window
)
;
#
ifdef
MOZ_X11
if
(
GdkIsX11Display
(
)
)
{
XSync
(
GDK_DISPLAY_XDISPLAY
(
gdk_display_get_default
(
)
)
X11False
)
;
}
else
#
endif
{
gdk_flush
(
)
;
}
}
void
nsWindow
:
:
HideWindowChrome
(
bool
aShouldHide
)
{
SetWindowDecoration
(
aShouldHide
?
eBorderStyle_none
:
mBorderStyle
)
;
}
bool
nsWindow
:
:
CheckForRollup
(
gdouble
aMouseX
gdouble
aMouseY
bool
aIsWheel
bool
aAlwaysRollup
)
{
nsIRollupListener
*
rollupListener
=
GetActiveRollupListener
(
)
;
nsCOMPtr
<
nsIWidget
>
rollupWidget
;
if
(
rollupListener
)
{
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
}
if
(
!
rollupWidget
)
{
nsBaseWidget
:
:
gRollupListener
=
nullptr
;
return
false
;
}
bool
retVal
=
false
;
auto
*
currentPopup
=
(
GdkWindow
*
)
rollupWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
aAlwaysRollup
|
|
!
is_mouse_in_window
(
currentPopup
aMouseX
aMouseY
)
)
{
bool
rollup
=
true
;
if
(
aIsWheel
)
{
rollup
=
rollupListener
-
>
ShouldRollupOnMouseWheelEvent
(
)
;
retVal
=
rollupListener
-
>
ShouldConsumeOnMouseWheelEvent
(
)
;
}
uint32_t
popupsToRollup
=
UINT32_MAX
;
if
(
!
aAlwaysRollup
)
{
AutoTArray
<
nsIWidget
*
5
>
widgetChain
;
uint32_t
sameTypeCount
=
rollupListener
-
>
GetSubmenuWidgetChain
(
&
widgetChain
)
;
for
(
unsigned
long
i
=
0
;
i
<
widgetChain
.
Length
(
)
;
+
+
i
)
{
nsIWidget
*
widget
=
widgetChain
[
i
]
;
auto
*
currWindow
=
(
GdkWindow
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
is_mouse_in_window
(
currWindow
aMouseX
aMouseY
)
)
{
if
(
i
<
sameTypeCount
)
{
rollup
=
false
;
}
else
{
popupsToRollup
=
sameTypeCount
;
}
break
;
}
}
}
bool
usePoint
=
!
aIsWheel
&
&
!
aAlwaysRollup
;
LayoutDeviceIntPoint
point
;
if
(
usePoint
)
{
point
=
GdkEventCoordsToDevicePixels
(
aMouseX
aMouseY
)
;
}
if
(
rollup
&
&
rollupListener
-
>
Rollup
(
popupsToRollup
true
usePoint
?
&
point
:
nullptr
nullptr
)
)
{
retVal
=
true
;
}
}
return
retVal
;
}
bool
nsWindow
:
:
DragInProgress
(
void
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
kCDragServiceCID
)
;
if
(
!
dragService
)
{
return
false
;
}
nsCOMPtr
<
nsIDragSession
>
currentDragSession
;
dragService
-
>
GetCurrentSession
(
getter_AddRefs
(
currentDragSession
)
)
;
return
currentDragSession
!
=
nullptr
;
}
MOZ_CAN_RUN_SCRIPT
static
void
WaylandDragWorkaround
(
GdkEventButton
*
aEvent
)
{
static
int
buttonPressCountWithDrag
=
0
;
if
(
aEvent
-
>
button
!
=
1
|
|
aEvent
-
>
type
!
=
GDK_BUTTON_PRESS
)
{
return
;
}
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
kCDragServiceCID
)
;
if
(
!
dragService
)
{
return
;
}
nsCOMPtr
<
nsIDragSession
>
currentDragSession
;
dragService
-
>
GetCurrentSession
(
getter_AddRefs
(
currentDragSession
)
)
;
if
(
currentDragSession
!
=
nullptr
)
{
buttonPressCountWithDrag
+
+
;
if
(
buttonPressCountWithDrag
>
1
)
{
NS_WARNING
(
"
Quit
unfinished
Wayland
Drag
and
Drop
operation
.
Buggy
Wayland
"
"
compositor
?
"
)
;
buttonPressCountWithDrag
=
0
;
dragService
-
>
EndDragSession
(
false
0
)
;
}
}
}
static
bool
is_mouse_in_window
(
GdkWindow
*
aWindow
gdouble
aMouseX
gdouble
aMouseY
)
{
GdkWindow
*
window
=
aWindow
;
if
(
!
window
)
{
return
false
;
}
gint
x
=
0
;
gint
y
=
0
;
gint
w
h
;
gint
offsetX
=
0
;
gint
offsetY
=
0
;
while
(
window
)
{
gint
tmpX
=
0
;
gint
tmpY
=
0
;
gdk_window_get_position
(
window
&
tmpX
&
tmpY
)
;
GtkWidget
*
widget
=
get_gtk_widget_for_gdk_window
(
window
)
;
if
(
GTK_IS_WINDOW
(
widget
)
)
{
x
=
tmpX
+
offsetX
;
y
=
tmpY
+
offsetY
;
break
;
}
offsetX
+
=
tmpX
;
offsetY
+
=
tmpY
;
window
=
gdk_window_get_parent
(
window
)
;
}
w
=
gdk_window_get_width
(
aWindow
)
;
h
=
gdk_window_get_height
(
aWindow
)
;
return
(
aMouseX
>
x
&
&
aMouseX
<
x
+
w
&
&
aMouseY
>
y
&
&
aMouseY
<
y
+
h
)
;
}
static
nsWindow
*
get_window_for_gtk_widget
(
GtkWidget
*
widget
)
{
gpointer
user_data
=
g_object_get_data
(
G_OBJECT
(
widget
)
"
nsWindow
"
)
;
return
static_cast
<
nsWindow
*
>
(
user_data
)
;
}
static
nsWindow
*
get_window_for_gdk_window
(
GdkWindow
*
window
)
{
gpointer
user_data
=
g_object_get_data
(
G_OBJECT
(
window
)
"
nsWindow
"
)
;
return
static_cast
<
nsWindow
*
>
(
user_data
)
;
}
static
GtkWidget
*
get_gtk_widget_for_gdk_window
(
GdkWindow
*
window
)
{
gpointer
user_data
=
nullptr
;
gdk_window_get_user_data
(
window
&
user_data
)
;
return
GTK_WIDGET
(
user_data
)
;
}
static
GdkCursor
*
get_gtk_cursor
(
nsCursor
aCursor
)
{
GdkCursor
*
gdkcursor
=
nullptr
;
uint8_t
newType
=
0xff
;
if
(
(
gdkcursor
=
gCursorCache
[
aCursor
]
)
)
{
return
gdkcursor
;
}
GdkDisplay
*
defaultDisplay
=
gdk_display_get_default
(
)
;
switch
(
aCursor
)
{
case
eCursor_standard
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_LEFT_PTR
)
;
break
;
case
eCursor_wait
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_WATCH
)
;
break
;
case
eCursor_select
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_XTERM
)
;
break
;
case
eCursor_hyperlink
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_HAND2
)
;
break
;
case
eCursor_n_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_TOP_SIDE
)
;
break
;
case
eCursor_s_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_BOTTOM_SIDE
)
;
break
;
case
eCursor_w_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_LEFT_SIDE
)
;
break
;
case
eCursor_e_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_RIGHT_SIDE
)
;
break
;
case
eCursor_nw_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_TOP_LEFT_CORNER
)
;
break
;
case
eCursor_se_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_BOTTOM_RIGHT_CORNER
)
;
break
;
case
eCursor_ne_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_TOP_RIGHT_CORNER
)
;
break
;
case
eCursor_sw_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_BOTTOM_LEFT_CORNER
)
;
break
;
case
eCursor_crosshair
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_CROSSHAIR
)
;
break
;
case
eCursor_move
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_FLEUR
)
;
break
;
case
eCursor_help
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_QUESTION_ARROW
)
;
break
;
case
eCursor_copy
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
copy
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_COPY
;
break
;
case
eCursor_alias
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
alias
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_ALIAS
;
break
;
case
eCursor_context_menu
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
context
-
menu
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_CONTEXT_MENU
;
break
;
case
eCursor_cell
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_PLUS
)
;
break
;
case
eCursor_grab
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
openhand
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_HAND_GRAB
;
break
;
case
eCursor_grabbing
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
closedhand
"
)
;
if
(
!
gdkcursor
)
{
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
grabbing
"
)
;
}
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_HAND_GRABBING
;
break
;
case
eCursor_spinning
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
progress
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_SPINNING
;
break
;
case
eCursor_zoom_in
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
zoom
-
in
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_ZOOM_IN
;
break
;
case
eCursor_zoom_out
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
zoom
-
out
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_ZOOM_OUT
;
break
;
case
eCursor_not_allowed
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
not
-
allowed
"
)
;
if
(
!
gdkcursor
)
{
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
crossed_circle
"
)
;
}
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_NOT_ALLOWED
;
break
;
case
eCursor_no_drop
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
no
-
drop
"
)
;
if
(
!
gdkcursor
)
{
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
forbidden
"
)
;
}
if
(
!
gdkcursor
)
{
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
circle
"
)
;
}
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_NOT_ALLOWED
;
break
;
case
eCursor_vertical_text
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
vertical
-
text
"
)
;
if
(
!
gdkcursor
)
{
newType
=
MOZ_CURSOR_VERTICAL_TEXT
;
}
break
;
case
eCursor_all_scroll
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_FLEUR
)
;
break
;
case
eCursor_nesw_resize
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
size_bdiag
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_NESW_RESIZE
;
break
;
case
eCursor_nwse_resize
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
size_fdiag
"
)
;
if
(
!
gdkcursor
)
newType
=
MOZ_CURSOR_NWSE_RESIZE
;
break
;
case
eCursor_ns_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_SB_V_DOUBLE_ARROW
)
;
break
;
case
eCursor_ew_resize
:
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_SB_H_DOUBLE_ARROW
)
;
break
;
case
eCursor_row_resize
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
split_v
"
)
;
if
(
!
gdkcursor
)
{
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_SB_V_DOUBLE_ARROW
)
;
}
break
;
case
eCursor_col_resize
:
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
"
split_h
"
)
;
if
(
!
gdkcursor
)
{
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_SB_H_DOUBLE_ARROW
)
;
}
break
;
case
eCursor_none
:
newType
=
MOZ_CURSOR_NONE
;
break
;
default
:
NS_ASSERTION
(
aCursor
"
Invalid
cursor
type
"
)
;
gdkcursor
=
gdk_cursor_new_for_display
(
defaultDisplay
GDK_LEFT_PTR
)
;
break
;
}
if
(
newType
!
=
0xFF
&
&
GtkCursors
[
newType
]
.
hash
)
{
gdkcursor
=
gdk_cursor_new_from_name
(
defaultDisplay
GtkCursors
[
newType
]
.
hash
)
;
}
if
(
newType
!
=
0xff
&
&
!
gdkcursor
)
{
GdkPixbuf
*
cursor_pixbuf
=
gdk_pixbuf_new
(
GDK_COLORSPACE_RGB
TRUE
8
32
32
)
;
if
(
!
cursor_pixbuf
)
return
nullptr
;
guchar
*
data
=
gdk_pixbuf_get_pixels
(
cursor_pixbuf
)
;
const
unsigned
char
*
bits
=
GtkCursors
[
newType
]
.
bits
;
const
unsigned
char
*
mask_bits
=
GtkCursors
[
newType
]
.
mask_bits
;
for
(
int
i
=
0
;
i
<
128
;
i
+
+
)
{
char
bit
=
(
char
)
*
bits
+
+
;
char
mask
=
(
char
)
*
mask_bits
+
+
;
for
(
int
j
=
0
;
j
<
8
;
j
+
+
)
{
unsigned
char
pix
=
~
(
(
(
bit
>
>
j
)
&
0x01
)
*
0xff
)
;
*
data
+
+
=
pix
;
*
data
+
+
=
pix
;
*
data
+
+
=
pix
;
*
data
+
+
=
(
(
(
mask
>
>
j
)
&
0x01
)
*
0xff
)
;
}
}
gdkcursor
=
gdk_cursor_new_from_pixbuf
(
gdk_display_get_default
(
)
cursor_pixbuf
GtkCursors
[
newType
]
.
hot_x
GtkCursors
[
newType
]
.
hot_y
)
;
g_object_unref
(
cursor_pixbuf
)
;
}
gCursorCache
[
aCursor
]
=
gdkcursor
;
return
gdkcursor
;
}
void
draw_window_of_widget
(
GtkWidget
*
widget
GdkWindow
*
aWindow
cairo_t
*
cr
)
{
if
(
gtk_cairo_should_draw_window
(
cr
aWindow
)
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
NS_WARNING
(
"
Cannot
get
nsWindow
from
GtkWidget
"
)
;
}
else
{
cairo_save
(
cr
)
;
gtk_cairo_transform_to_window
(
cr
widget
aWindow
)
;
window
-
>
OnExposeEvent
(
cr
)
;
cairo_restore
(
cr
)
;
}
}
}
gboolean
expose_event_cb
(
GtkWidget
*
widget
cairo_t
*
cr
)
{
draw_window_of_widget
(
widget
gtk_widget_get_window
(
widget
)
cr
)
;
g_object_ref
(
widget
)
;
g_idle_add
(
[
]
(
gpointer
data
)
-
>
gboolean
{
g_object_unref
(
data
)
;
return
G_SOURCE_REMOVE
;
}
widget
)
;
return
FALSE
;
}
static
gboolean
configure_event_cb
(
GtkWidget
*
widget
GdkEventConfigure
*
event
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
FALSE
;
}
return
window
-
>
OnConfigureEvent
(
widget
event
)
;
}
static
void
widget_map_cb
(
GtkWidget
*
widget
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
;
}
window
-
>
OnMap
(
)
;
}
static
void
widget_unrealize_cb
(
GtkWidget
*
widget
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
;
}
window
-
>
OnUnrealize
(
)
;
}
static
void
size_allocate_cb
(
GtkWidget
*
widget
GtkAllocation
*
allocation
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
;
}
window
-
>
OnSizeAllocate
(
allocation
)
;
}
static
void
toplevel_window_size_allocate_cb
(
GtkWidget
*
widget
GtkAllocation
*
allocation
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
;
}
window
-
>
UpdateTopLevelOpaqueRegion
(
)
;
}
static
gboolean
delete_event_cb
(
GtkWidget
*
widget
GdkEventAny
*
event
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
FALSE
;
}
window
-
>
OnDeleteEvent
(
)
;
return
TRUE
;
}
static
gboolean
enter_notify_event_cb
(
GtkWidget
*
widget
GdkEventCrossing
*
event
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gdk_window
(
event
-
>
window
)
;
if
(
!
window
)
{
return
TRUE
;
}
window
-
>
OnEnterNotifyEvent
(
event
)
;
return
TRUE
;
}
static
gboolean
leave_notify_event_cb
(
GtkWidget
*
widget
GdkEventCrossing
*
event
)
{
if
(
is_parent_grab_leave
(
event
)
)
{
return
TRUE
;
}
auto
x
=
gint
(
event
-
>
x_root
)
;
auto
y
=
gint
(
event
-
>
y_root
)
;
GdkDisplay
*
display
=
gtk_widget_get_display
(
widget
)
;
GdkWindow
*
winAtPt
=
gdk_display_get_window_at_pointer
(
display
&
x
&
y
)
;
if
(
winAtPt
=
=
event
-
>
window
)
{
return
TRUE
;
}
RefPtr
<
nsWindow
>
window
=
get_window_for_gdk_window
(
event
-
>
window
)
;
if
(
!
window
)
return
TRUE
;
window
-
>
OnLeaveNotifyEvent
(
event
)
;
return
TRUE
;
}
static
nsWindow
*
GetFirstNSWindowForGDKWindow
(
GdkWindow
*
aGdkWindow
)
{
nsWindow
*
window
;
while
(
!
(
window
=
get_window_for_gdk_window
(
aGdkWindow
)
)
)
{
aGdkWindow
=
gdk_window_get_parent
(
aGdkWindow
)
;
if
(
!
aGdkWindow
)
{
window
=
nullptr
;
break
;
}
}
return
window
;
}
static
gboolean
motion_notify_event_cb
(
GtkWidget
*
widget
GdkEventMotion
*
event
)
{
UpdateLastInputEventTime
(
event
)
;
nsWindow
*
window
=
GetFirstNSWindowForGDKWindow
(
event
-
>
window
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnMotionNotifyEvent
(
event
)
;
return
TRUE
;
}
static
gboolean
button_press_event_cb
(
GtkWidget
*
widget
GdkEventButton
*
event
)
{
UpdateLastInputEventTime
(
event
)
;
nsWindow
*
window
=
GetFirstNSWindowForGDKWindow
(
event
-
>
window
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnButtonPressEvent
(
event
)
;
if
(
GdkIsWaylandDisplay
(
)
)
{
WaylandDragWorkaround
(
event
)
;
}
return
TRUE
;
}
static
gboolean
button_release_event_cb
(
GtkWidget
*
widget
GdkEventButton
*
event
)
{
UpdateLastInputEventTime
(
event
)
;
nsWindow
*
window
=
GetFirstNSWindowForGDKWindow
(
event
-
>
window
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnButtonReleaseEvent
(
event
)
;
return
TRUE
;
}
static
gboolean
focus_in_event_cb
(
GtkWidget
*
widget
GdkEventFocus
*
event
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnContainerFocusInEvent
(
event
)
;
return
FALSE
;
}
static
gboolean
focus_out_event_cb
(
GtkWidget
*
widget
GdkEventFocus
*
event
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnContainerFocusOutEvent
(
event
)
;
return
FALSE
;
}
#
ifdef
MOZ_X11
static
GdkFilterReturn
popup_take_focus_filter
(
GdkXEvent
*
gdk_xevent
GdkEvent
*
event
gpointer
data
)
{
auto
*
xevent
=
static_cast
<
XEvent
*
>
(
gdk_xevent
)
;
if
(
xevent
-
>
type
!
=
ClientMessage
)
return
GDK_FILTER_CONTINUE
;
XClientMessageEvent
&
xclient
=
xevent
-
>
xclient
;
if
(
xclient
.
message_type
!
=
gdk_x11_get_xatom_by_name
(
"
WM_PROTOCOLS
"
)
)
{
return
GDK_FILTER_CONTINUE
;
}
Atom
atom
=
xclient
.
data
.
l
[
0
]
;
if
(
atom
!
=
gdk_x11_get_xatom_by_name
(
"
WM_TAKE_FOCUS
"
)
)
{
return
GDK_FILTER_CONTINUE
;
}
guint32
timestamp
=
xclient
.
data
.
l
[
1
]
;
GtkWidget
*
widget
=
get_gtk_widget_for_gdk_window
(
event
-
>
any
.
window
)
;
if
(
!
widget
)
return
GDK_FILTER_CONTINUE
;
GtkWindow
*
parent
=
gtk_window_get_transient_for
(
GTK_WINDOW
(
widget
)
)
;
if
(
!
parent
)
return
GDK_FILTER_CONTINUE
;
if
(
gtk_window_is_active
(
parent
)
)
{
return
GDK_FILTER_REMOVE
;
}
GdkWindow
*
parent_window
=
gtk_widget_get_window
(
GTK_WIDGET
(
parent
)
)
;
if
(
!
parent_window
)
return
GDK_FILTER_CONTINUE
;
gdk_window_show_unraised
(
parent_window
)
;
gdk_window_focus
(
parent_window
timestamp
)
;
return
GDK_FILTER_REMOVE
;
}
#
endif
static
gboolean
key_press_event_cb
(
GtkWidget
*
widget
GdkEventKey
*
event
)
{
LOGW
(
"
key_press_event_cb
\
n
"
)
;
UpdateLastInputEventTime
(
event
)
;
nsWindow
*
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
return
FALSE
;
RefPtr
<
nsWindow
>
focusWindow
=
gFocusWindow
?
gFocusWindow
:
window
;
#
ifdef
MOZ_X11
#
define
NS_GDKEVENT_MATCH_MASK
0x1FFF
/
/
GDK_SHIFT_MASK
.
.
GDK_BUTTON5_MASK
#
ifndef
KeyPress
#
define
KeyPress
2
#
endif
GdkDisplay
*
gdkDisplay
=
gtk_widget_get_display
(
widget
)
;
if
(
GdkIsX11Display
(
gdkDisplay
)
)
{
Display
*
dpy
=
GDK_DISPLAY_XDISPLAY
(
gdkDisplay
)
;
while
(
XPending
(
dpy
)
)
{
XEvent
next_event
;
XPeekEvent
(
dpy
&
next_event
)
;
GdkWindow
*
nextGdkWindow
=
gdk_x11_window_lookup_for_display
(
gdkDisplay
next_event
.
xany
.
window
)
;
if
(
nextGdkWindow
!
=
event
-
>
window
|
|
next_event
.
type
!
=
KeyPress
|
|
next_event
.
xkey
.
keycode
!
=
event
-
>
hardware_keycode
|
|
next_event
.
xkey
.
state
!
=
(
event
-
>
state
&
NS_GDKEVENT_MATCH_MASK
)
)
{
break
;
}
XNextEvent
(
dpy
&
next_event
)
;
event
-
>
time
=
next_event
.
xkey
.
time
;
}
}
#
endif
return
focusWindow
-
>
OnKeyPressEvent
(
event
)
;
}
static
gboolean
key_release_event_cb
(
GtkWidget
*
widget
GdkEventKey
*
event
)
{
LOGW
(
"
key_release_event_cb
\
n
"
)
;
UpdateLastInputEventTime
(
event
)
;
nsWindow
*
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
return
FALSE
;
RefPtr
<
nsWindow
>
focusWindow
=
gFocusWindow
?
gFocusWindow
:
window
;
return
focusWindow
-
>
OnKeyReleaseEvent
(
event
)
;
}
static
gboolean
property_notify_event_cb
(
GtkWidget
*
aWidget
GdkEventProperty
*
aEvent
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gdk_window
(
aEvent
-
>
window
)
;
if
(
!
window
)
return
FALSE
;
return
window
-
>
OnPropertyNotifyEvent
(
aWidget
aEvent
)
;
}
static
gboolean
scroll_event_cb
(
GtkWidget
*
widget
GdkEventScroll
*
event
)
{
nsWindow
*
window
=
GetFirstNSWindowForGDKWindow
(
event
-
>
window
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnScrollEvent
(
event
)
;
return
TRUE
;
}
static
void
hierarchy_changed_cb
(
GtkWidget
*
widget
GtkWidget
*
previous_toplevel
)
{
GtkWidget
*
toplevel
=
gtk_widget_get_toplevel
(
widget
)
;
GdkWindowState
old_window_state
=
GDK_WINDOW_STATE_WITHDRAWN
;
GdkEventWindowState
event
;
event
.
new_window_state
=
GDK_WINDOW_STATE_WITHDRAWN
;
if
(
GTK_IS_WINDOW
(
previous_toplevel
)
)
{
g_signal_handlers_disconnect_by_func
(
previous_toplevel
FuncToGpointer
(
window_state_event_cb
)
widget
)
;
GdkWindow
*
win
=
gtk_widget_get_window
(
previous_toplevel
)
;
if
(
win
)
{
old_window_state
=
gdk_window_get_state
(
win
)
;
}
}
if
(
GTK_IS_WINDOW
(
toplevel
)
)
{
g_signal_connect_swapped
(
toplevel
"
window
-
state
-
event
"
G_CALLBACK
(
window_state_event_cb
)
widget
)
;
GdkWindow
*
win
=
gtk_widget_get_window
(
toplevel
)
;
if
(
win
)
{
event
.
new_window_state
=
gdk_window_get_state
(
win
)
;
}
}
event
.
changed_mask
=
static_cast
<
GdkWindowState
>
(
old_window_state
^
event
.
new_window_state
)
;
if
(
event
.
changed_mask
)
{
event
.
type
=
GDK_WINDOW_STATE
;
event
.
window
=
nullptr
;
event
.
send_event
=
TRUE
;
window_state_event_cb
(
widget
&
event
)
;
}
}
static
gboolean
window_state_event_cb
(
GtkWidget
*
widget
GdkEventWindowState
*
event
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
return
FALSE
;
window
-
>
OnWindowStateEvent
(
widget
event
)
;
return
FALSE
;
}
static
void
settings_xft_dpi_changed_cb
(
GtkSettings
*
gtk_settings
GParamSpec
*
pspec
nsWindow
*
data
)
{
RefPtr
<
nsWindow
>
window
=
data
;
window
-
>
OnDPIChanged
(
)
;
window
-
>
DispatchResized
(
)
;
}
static
void
check_resize_cb
(
GtkContainer
*
container
gpointer
user_data
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
GTK_WIDGET
(
container
)
)
;
if
(
!
window
)
{
return
;
}
window
-
>
OnCheckResize
(
)
;
}
static
void
screen_composited_changed_cb
(
GdkScreen
*
screen
gpointer
user_data
)
{
if
(
GPUProcessManager
:
:
Get
(
)
)
{
GPUProcessManager
:
:
Get
(
)
-
>
ResetCompositors
(
)
;
}
}
static
void
widget_composited_changed_cb
(
GtkWidget
*
widget
gpointer
user_data
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
;
}
window
-
>
OnCompositedChanged
(
)
;
}
static
void
scale_changed_cb
(
GtkWidget
*
widget
GParamSpec
*
aPSpec
gpointer
aPointer
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
widget
)
;
if
(
!
window
)
{
return
;
}
window
-
>
OnScaleChanged
(
)
;
}
static
gboolean
touch_event_cb
(
GtkWidget
*
aWidget
GdkEventTouch
*
aEvent
)
{
UpdateLastInputEventTime
(
aEvent
)
;
nsWindow
*
window
=
GetFirstNSWindowForGDKWindow
(
aEvent
-
>
window
)
;
if
(
!
window
)
{
return
FALSE
;
}
return
window
-
>
OnTouchEvent
(
aEvent
)
;
}
static
gboolean
generic_event_cb
(
GtkWidget
*
widget
GdkEvent
*
aEvent
)
{
if
(
aEvent
-
>
type
!
=
GDK_TOUCHPAD_PINCH
)
{
return
FALSE
;
}
GdkEventTouchpadPinch
*
event
=
reinterpret_cast
<
GdkEventTouchpadPinch
*
>
(
aEvent
)
;
nsWindow
*
window
=
GetFirstNSWindowForGDKWindow
(
event
-
>
window
)
;
if
(
!
window
)
{
return
FALSE
;
}
return
window
-
>
OnTouchpadPinchEvent
(
event
)
;
}
void
nsWindow
:
:
InitDragEvent
(
WidgetDragEvent
&
aEvent
)
{
guint
modifierState
=
KeymapWrapper
:
:
GetCurrentModifierState
(
)
;
KeymapWrapper
:
:
InitInputEvent
(
aEvent
modifierState
)
;
}
gboolean
WindowDragMotionHandler
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
RefPtr
<
DataOffer
>
aDataOffer
gint
aX
gint
aY
guint
aTime
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
aWidget
)
;
if
(
!
window
)
{
return
FALSE
;
}
nscoord
retx
=
0
;
nscoord
rety
=
0
;
GdkWindow
*
innerWindow
=
get_inner_gdk_window
(
gtk_widget_get_window
(
aWidget
)
aX
aY
&
retx
&
rety
)
;
RefPtr
<
nsWindow
>
innerMostWindow
=
get_window_for_gdk_window
(
innerWindow
)
;
if
(
!
innerMostWindow
)
{
innerMostWindow
=
window
;
}
int
tx
=
0
ty
=
0
;
if
(
innerMostWindow
-
>
IsWaylandPopup
(
)
)
{
gdk_window_get_position
(
innerWindow
&
tx
&
ty
)
;
}
LayoutDeviceIntPoint
point
=
innerMostWindow
-
>
GdkPointToDevicePixels
(
{
retx
+
tx
rety
+
ty
}
)
;
LOGDRAG
(
"
WindowDragMotionHandler
nsWindow
%
p
coords
[
%
d
%
d
]
\
n
"
innerMostWindow
.
get
(
)
retx
rety
)
;
RefPtr
<
nsDragService
>
dragService
=
nsDragService
:
:
GetInstance
(
)
;
if
(
!
dragService
-
>
ScheduleMotionEvent
(
innerMostWindow
aDragContext
aDataOffer
point
aTime
)
)
{
return
FALSE
;
}
if
(
GdkIsWaylandDisplay
(
)
)
{
dragService
-
>
ReplyToDragMotion
(
)
;
}
return
TRUE
;
}
static
gboolean
drag_motion_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
guint
aTime
gpointer
aData
)
{
return
WindowDragMotionHandler
(
aWidget
aDragContext
nullptr
aX
aY
aTime
)
;
}
void
WindowDragLeaveHandler
(
GtkWidget
*
aWidget
)
{
LOGDRAG
(
"
WindowDragLeaveHandler
(
)
\
n
"
)
;
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
aWidget
)
;
if
(
!
window
)
{
LOGDRAG
(
"
Failed
-
can
'
t
find
nsWindow
!
\
n
"
)
;
return
;
}
RefPtr
<
nsDragService
>
dragService
=
nsDragService
:
:
GetInstance
(
)
;
nsWindow
*
mostRecentDragWindow
=
dragService
-
>
GetMostRecentDestWindow
(
)
;
if
(
!
mostRecentDragWindow
)
{
LOGDRAG
(
"
Failed
-
GetMostRecentDestWindow
(
)
!
\
n
"
)
;
return
;
}
if
(
aWidget
!
=
window
-
>
GetGtkWidget
(
)
)
{
LOGDRAG
(
"
Failed
-
GtkWidget
mismatch
!
\
n
"
)
;
return
;
}
LOGDRAG
(
"
WindowDragLeaveHandler
nsWindow
%
p
\
n
"
(
void
*
)
mostRecentDragWindow
)
;
dragService
-
>
ScheduleLeaveEvent
(
)
;
}
static
void
drag_leave_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
guint
aTime
gpointer
aData
)
{
WindowDragLeaveHandler
(
aWidget
)
;
}
gboolean
WindowDragDropHandler
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
RefPtr
<
DataOffer
>
aDataOffer
gint
aX
gint
aY
guint
aTime
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
aWidget
)
;
if
(
!
window
)
return
FALSE
;
nscoord
retx
=
0
;
nscoord
rety
=
0
;
GdkWindow
*
innerWindow
=
get_inner_gdk_window
(
gtk_widget_get_window
(
aWidget
)
aX
aY
&
retx
&
rety
)
;
RefPtr
<
nsWindow
>
innerMostWindow
=
get_window_for_gdk_window
(
innerWindow
)
;
if
(
!
innerMostWindow
)
{
innerMostWindow
=
window
;
}
int
tx
=
0
ty
=
0
;
if
(
innerMostWindow
-
>
IsWaylandPopup
(
)
)
{
gdk_window_get_position
(
innerWindow
&
tx
&
ty
)
;
}
LayoutDeviceIntPoint
point
=
window
-
>
GdkPointToDevicePixels
(
{
retx
+
tx
rety
+
ty
}
)
;
LOGDRAG
(
"
WindowDragDropHandler
nsWindow
%
p
coords
[
%
d
%
d
]
\
n
"
innerMostWindow
.
get
(
)
retx
rety
)
;
RefPtr
<
nsDragService
>
dragService
=
nsDragService
:
:
GetInstance
(
)
;
return
dragService
-
>
ScheduleDropEvent
(
innerMostWindow
aDragContext
aDataOffer
point
aTime
)
;
}
static
gboolean
drag_drop_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
guint
aTime
gpointer
aData
)
{
return
WindowDragDropHandler
(
aWidget
aDragContext
nullptr
aX
aY
aTime
)
;
}
static
void
drag_data_received_event_cb
(
GtkWidget
*
aWidget
GdkDragContext
*
aDragContext
gint
aX
gint
aY
GtkSelectionData
*
aSelectionData
guint
aInfo
guint
aTime
gpointer
aData
)
{
RefPtr
<
nsWindow
>
window
=
get_window_for_gtk_widget
(
aWidget
)
;
if
(
!
window
)
return
;
window
-
>
OnDragDataReceivedEvent
(
aWidget
aDragContext
aX
aY
aSelectionData
aInfo
aTime
aData
)
;
}
static
nsresult
initialize_prefs
(
void
)
{
gRaiseWindows
=
Preferences
:
:
GetBool
(
"
mozilla
.
widget
.
raise
-
on
-
setfocus
"
true
)
;
gTransparentWindows
=
Preferences
:
:
GetBool
(
"
widget
.
transparent
-
windows
"
true
)
;
gUseMoveToRect
=
Preferences
:
:
GetBool
(
"
widget
.
use
-
move
-
to
-
rect
"
true
)
;
if
(
Preferences
:
:
HasUserValue
(
"
widget
.
use
-
aspect
-
ratio
"
)
)
{
gUseAspectRatio
=
Preferences
:
:
GetBool
(
"
widget
.
use
-
aspect
-
ratio
"
true
)
;
}
else
{
static
const
char
*
currentDesktop
=
getenv
(
"
XDG_CURRENT_DESKTOP
"
)
;
gUseAspectRatio
=
currentDesktop
?
(
strstr
(
currentDesktop
"
GNOME
"
)
!
=
nullptr
)
:
false
;
}
return
NS_OK
;
}
static
GdkWindow
*
get_inner_gdk_window
(
GdkWindow
*
aWindow
gint
x
gint
y
gint
*
retx
gint
*
rety
)
{
gint
cx
cy
cw
ch
;
GList
*
children
=
gdk_window_peek_children
(
aWindow
)
;
for
(
GList
*
child
=
g_list_last
(
children
)
;
child
;
child
=
g_list_previous
(
child
)
)
{
auto
*
childWindow
=
(
GdkWindow
*
)
child
-
>
data
;
if
(
get_window_for_gdk_window
(
childWindow
)
)
{
gdk_window_get_geometry
(
childWindow
&
cx
&
cy
&
cw
&
ch
)
;
if
(
(
cx
<
x
)
&
&
(
x
<
(
cx
+
cw
)
)
&
&
(
cy
<
y
)
&
&
(
y
<
(
cy
+
ch
)
)
&
&
gdk_window_is_visible
(
childWindow
)
)
{
return
get_inner_gdk_window
(
childWindow
x
-
cx
y
-
cy
retx
rety
)
;
}
}
}
*
retx
=
x
;
*
rety
=
y
;
return
aWindow
;
}
static
int
is_parent_ungrab_enter
(
GdkEventCrossing
*
aEvent
)
{
return
(
GDK_CROSSING_UNGRAB
=
=
aEvent
-
>
mode
)
&
&
(
(
GDK_NOTIFY_ANCESTOR
=
=
aEvent
-
>
detail
)
|
|
(
GDK_NOTIFY_VIRTUAL
=
=
aEvent
-
>
detail
)
)
;
}
static
int
is_parent_grab_leave
(
GdkEventCrossing
*
aEvent
)
{
return
(
GDK_CROSSING_GRAB
=
=
aEvent
-
>
mode
)
&
&
(
(
GDK_NOTIFY_ANCESTOR
=
=
aEvent
-
>
detail
)
|
|
(
GDK_NOTIFY_VIRTUAL
=
=
aEvent
-
>
detail
)
)
;
}
#
ifdef
ACCESSIBILITY
void
nsWindow
:
:
CreateRootAccessible
(
)
{
if
(
!
mRootAccessible
)
{
LOG
(
"
nsWindow
:
:
Create
Toplevel
Accessibility
\
n
"
)
;
mRootAccessible
=
GetRootAccessible
(
)
;
}
}
void
nsWindow
:
:
DispatchEventToRootAccessible
(
uint32_t
aEventType
)
{
if
(
!
a11y
:
:
ShouldA11yBeEnabled
(
)
)
{
return
;
}
nsAccessibilityService
*
accService
=
GetOrCreateAccService
(
)
;
if
(
!
accService
)
{
return
;
}
a11y
:
:
LocalAccessible
*
acc
=
GetRootAccessible
(
)
;
if
(
acc
)
{
accService
-
>
FireAccessibleEvent
(
aEventType
acc
)
;
}
}
void
nsWindow
:
:
DispatchActivateEventAccessible
(
void
)
{
DispatchEventToRootAccessible
(
nsIAccessibleEvent
:
:
EVENT_WINDOW_ACTIVATE
)
;
}
void
nsWindow
:
:
DispatchDeactivateEventAccessible
(
void
)
{
DispatchEventToRootAccessible
(
nsIAccessibleEvent
:
:
EVENT_WINDOW_DEACTIVATE
)
;
}
void
nsWindow
:
:
DispatchMaximizeEventAccessible
(
void
)
{
DispatchEventToRootAccessible
(
nsIAccessibleEvent
:
:
EVENT_WINDOW_MAXIMIZE
)
;
}
void
nsWindow
:
:
DispatchMinimizeEventAccessible
(
void
)
{
DispatchEventToRootAccessible
(
nsIAccessibleEvent
:
:
EVENT_WINDOW_MINIMIZE
)
;
}
void
nsWindow
:
:
DispatchRestoreEventAccessible
(
void
)
{
DispatchEventToRootAccessible
(
nsIAccessibleEvent
:
:
EVENT_WINDOW_RESTORE
)
;
}
#
endif
void
nsWindow
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
if
(
!
mIMContext
)
{
return
;
}
mIMContext
-
>
SetInputContext
(
this
&
aContext
&
aAction
)
;
}
InputContext
nsWindow
:
:
GetInputContext
(
)
{
InputContext
context
;
if
(
!
mIMContext
)
{
context
.
mIMEState
.
mEnabled
=
IMEEnabled
:
:
Disabled
;
context
.
mIMEState
.
mOpen
=
IMEState
:
:
OPEN_STATE_NOT_SUPPORTED
;
}
else
{
context
=
mIMContext
-
>
GetInputContext
(
)
;
}
return
context
;
}
TextEventDispatcherListener
*
nsWindow
:
:
GetNativeTextEventDispatcherListener
(
)
{
if
(
NS_WARN_IF
(
!
mIMContext
)
)
{
return
nullptr
;
}
return
mIMContext
;
}
bool
nsWindow
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
if
(
NS_WARN_IF
(
!
nsIWidget
:
:
GetEditCommands
(
aType
aEvent
aCommands
)
)
)
{
return
false
;
}
Maybe
<
WritingMode
>
writingMode
;
if
(
aEvent
.
NeedsToRemapNavigationKey
(
)
)
{
if
(
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcher
(
)
)
{
writingMode
=
dispatcher
-
>
MaybeWritingModeAtSelection
(
)
;
}
}
NativeKeyBindings
*
keyBindings
=
NativeKeyBindings
:
:
GetInstance
(
aType
)
;
keyBindings
-
>
GetEditCommands
(
aEvent
writingMode
aCommands
)
;
return
true
;
}
already_AddRefed
<
DrawTarget
>
nsWindow
:
:
StartRemoteDrawingInRegion
(
const
LayoutDeviceIntRegion
&
aInvalidRegion
BufferMode
*
aBufferMode
)
{
return
mSurfaceProvider
.
StartRemoteDrawingInRegion
(
aInvalidRegion
aBufferMode
)
;
}
void
nsWindow
:
:
EndRemoteDrawingInRegion
(
DrawTarget
*
aDrawTarget
const
LayoutDeviceIntRegion
&
aInvalidRegion
)
{
mSurfaceProvider
.
EndRemoteDrawingInRegion
(
aDrawTarget
aInvalidRegion
)
;
}
bool
nsWindow
:
:
GetDragInfo
(
WidgetMouseEvent
*
aMouseEvent
GdkWindow
*
*
aWindow
gint
*
aButton
gint
*
aRootX
gint
*
aRootY
)
{
if
(
aMouseEvent
-
>
mButton
!
=
MouseButton
:
:
ePrimary
)
{
return
false
;
}
*
aButton
=
1
;
GdkWindow
*
gdk_window
=
mGdkWindow
;
if
(
!
gdk_window
)
{
return
false
;
}
#
ifdef
DEBUG
if
(
!
GDK_IS_WINDOW
(
gdk_window
)
)
{
MOZ_ASSERT
(
false
"
must
really
be
window
"
)
;
}
#
endif
gdk_window
=
gdk_window_get_toplevel
(
gdk_window
)
;
MOZ_ASSERT
(
gdk_window
"
gdk_window_get_toplevel
should
not
return
null
"
)
;
*
aWindow
=
gdk_window
;
if
(
!
aMouseEvent
-
>
mWidget
)
{
return
false
;
}
if
(
GdkIsX11Display
(
)
)
{
GdkScreen
*
screen
=
gdk_window_get_screen
(
gdk_window
)
;
GdkAtom
atom
=
gdk_atom_intern
(
"
_NET_WM_MOVERESIZE
"
FALSE
)
;
if
(
!
gdk_x11_screen_supports_net_wm_hint
(
screen
atom
)
)
{
static
unsigned
int
lastTimeStamp
=
0
;
if
(
lastTimeStamp
!
=
aMouseEvent
-
>
mTime
)
{
lastTimeStamp
=
aMouseEvent
-
>
mTime
;
}
else
{
return
false
;
}
}
}
LayoutDeviceIntPoint
offset
=
aMouseEvent
-
>
mWidget
-
>
WidgetToScreenOffset
(
)
;
*
aRootX
=
aMouseEvent
-
>
mRefPoint
.
x
+
offset
.
x
;
*
aRootY
=
aMouseEvent
-
>
mRefPoint
.
y
+
offset
.
y
;
return
true
;
}
nsresult
nsWindow
:
:
BeginResizeDrag
(
WidgetGUIEvent
*
aEvent
int32_t
aHorizontal
int32_t
aVertical
)
{
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
if
(
aEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
NS_ERROR_INVALID_ARG
;
}
GdkWindow
*
gdk_window
;
gint
button
screenX
screenY
;
if
(
!
GetDragInfo
(
aEvent
-
>
AsMouseEvent
(
)
&
gdk_window
&
button
&
screenX
&
screenY
)
)
{
return
NS_ERROR_FAILURE
;
}
GdkWindowEdge
window_edge
;
if
(
aVertical
<
0
)
{
if
(
aHorizontal
<
0
)
{
window_edge
=
GDK_WINDOW_EDGE_NORTH_WEST
;
}
else
if
(
aHorizontal
=
=
0
)
{
window_edge
=
GDK_WINDOW_EDGE_NORTH
;
}
else
{
window_edge
=
GDK_WINDOW_EDGE_NORTH_EAST
;
}
}
else
if
(
aVertical
=
=
0
)
{
if
(
aHorizontal
<
0
)
{
window_edge
=
GDK_WINDOW_EDGE_WEST
;
}
else
if
(
aHorizontal
=
=
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
else
{
window_edge
=
GDK_WINDOW_EDGE_EAST
;
}
}
else
{
if
(
aHorizontal
<
0
)
{
window_edge
=
GDK_WINDOW_EDGE_SOUTH_WEST
;
}
else
if
(
aHorizontal
=
=
0
)
{
window_edge
=
GDK_WINDOW_EDGE_SOUTH
;
}
else
{
window_edge
=
GDK_WINDOW_EDGE_SOUTH_EAST
;
}
}
gdk_window_begin_resize_drag
(
gdk_window
window_edge
button
screenX
screenY
aEvent
-
>
mTime
)
;
return
NS_OK
;
}
nsIWidget
:
:
WindowRenderer
*
nsWindow
:
:
GetWindowRenderer
(
)
{
if
(
mIsDestroyed
)
{
return
mWindowRenderer
;
}
return
nsBaseWidget
:
:
GetWindowRenderer
(
)
;
}
void
nsWindow
:
:
SetCompositorWidgetDelegate
(
CompositorWidgetDelegate
*
delegate
)
{
LOG
(
"
nsWindow
:
:
SetCompositorWidgetDelegate
%
p
\
n
"
delegate
)
;
if
(
mCompositorWidgetDelegate
&
&
mIsMapped
)
{
DisableRenderingToWindow
(
)
;
}
if
(
delegate
)
{
mCompositorWidgetDelegate
=
delegate
-
>
AsPlatformSpecificDelegate
(
)
;
MOZ_ASSERT
(
mCompositorWidgetDelegate
"
nsWindow
:
:
SetCompositorWidgetDelegate
called
with
a
"
"
non
-
PlatformCompositorWidgetDelegate
"
)
;
if
(
mIsMapped
)
{
EnableRenderingToWindow
(
)
;
}
}
else
{
mCompositorWidgetDelegate
=
nullptr
;
}
}
void
nsWindow
:
:
UpdateClientOffsetFromCSDWindow
(
)
{
int
x
=
0
y
=
0
;
if
(
mGdkWindow
)
{
gdk_window_get_position
(
mGdkWindow
&
x
&
y
)
;
}
x
=
GdkCoordToDevicePixels
(
x
)
;
y
=
GdkCoordToDevicePixels
(
y
)
;
if
(
mClientOffset
.
x
!
=
x
|
|
mClientOffset
.
y
!
=
y
)
{
mClientOffset
=
nsIntPoint
(
x
y
)
;
LOG
(
"
nsWindow
:
:
UpdateClientOffsetFromCSDWindow
%
d
%
d
\
n
"
mClientOffset
.
x
mClientOffset
.
y
)
;
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
}
}
nsresult
nsWindow
:
:
SetNonClientMargins
(
LayoutDeviceIntMargin
&
aMargins
)
{
SetDrawsInTitlebar
(
aMargins
.
top
=
=
0
)
;
return
NS_OK
;
}
void
nsWindow
:
:
SetDrawsInTitlebar
(
bool
aState
)
{
LOG
(
"
nsWindow
:
:
SetDrawsInTitlebar
(
)
State
%
d
mGtkWindowDecoration
%
d
\
n
"
aState
(
int
)
mGtkWindowDecoration
)
;
if
(
mIsPIPWindow
&
&
aState
=
=
mDrawInTitlebar
)
{
gtk_window_set_decorated
(
GTK_WINDOW
(
mShell
)
!
aState
)
;
LOG
(
"
set
decoration
for
PIP
%
d
"
aState
)
;
return
;
}
if
(
mGtkWindowDecoration
=
=
GTK_DECORATION_NONE
|
|
aState
=
=
mDrawInTitlebar
)
{
LOG
(
"
already
set
quit
"
)
;
return
;
}
if
(
mGtkWindowDecoration
=
=
GTK_DECORATION_SYSTEM
)
{
SetWindowDecoration
(
aState
?
eBorderStyle_border
:
mBorderStyle
)
;
}
else
if
(
mGtkWindowDecoration
=
=
GTK_DECORATION_CLIENT
)
{
LOG
(
"
Using
CSD
mode
\
n
"
)
;
bool
visible
=
!
mNeedsShow
&
&
mIsShown
;
if
(
visible
)
{
NativeShow
(
false
)
;
}
GtkWidget
*
tmpWindow
=
gtk_window_new
(
GTK_WINDOW_POPUP
)
;
gtk_widget_realize
(
tmpWindow
)
;
gtk_widget_reparent
(
GTK_WIDGET
(
mContainer
)
tmpWindow
)
;
gtk_widget_unrealize
(
GTK_WIDGET
(
mShell
)
)
;
if
(
aState
)
{
gtk_window_set_titlebar
(
GTK_WINDOW
(
mShell
)
gtk_fixed_new
(
)
)
;
}
else
{
gtk_window_set_titlebar
(
GTK_WINDOW
(
mShell
)
nullptr
)
;
}
GtkAllocation
allocation
=
{
0
0
0
0
}
;
gtk_widget_get_preferred_width
(
GTK_WIDGET
(
mShell
)
nullptr
&
allocation
.
width
)
;
gtk_widget_get_preferred_height
(
GTK_WIDGET
(
mShell
)
nullptr
&
allocation
.
height
)
;
gtk_widget_size_allocate
(
GTK_WIDGET
(
mShell
)
&
allocation
)
;
gtk_widget_realize
(
GTK_WIDGET
(
mShell
)
)
;
gtk_widget_reparent
(
GTK_WIDGET
(
mContainer
)
GTK_WIDGET
(
mShell
)
)
;
g_object_set_data
(
G_OBJECT
(
gtk_widget_get_window
(
mShell
)
)
"
nsWindow
"
this
)
;
if
(
AreBoundsSane
(
)
)
{
GdkRectangle
size
=
DevicePixelsToGdkSizeRoundUp
(
mBounds
.
Size
(
)
)
;
LOG
(
"
resize
to
%
d
x
%
d
\
n
"
size
.
width
size
.
height
)
;
gtk_window_resize
(
GTK_WINDOW
(
mShell
)
size
.
width
size
.
height
)
;
}
if
(
visible
)
{
mNeedsShow
=
true
;
NativeShow
(
true
)
;
}
gtk_widget_destroy
(
tmpWindow
)
;
}
mDrawInTitlebar
=
aState
;
if
(
mTransparencyBitmapForTitlebar
)
{
if
(
mDrawInTitlebar
&
&
mSizeState
=
=
nsSizeMode_Normal
&
&
!
mIsTiled
)
{
UpdateTitlebarTransparencyBitmap
(
)
;
}
else
{
ClearTransparencyBitmap
(
)
;
}
}
}
GtkWindow
*
nsWindow
:
:
GetCurrentTopmostWindow
(
)
{
GtkWindow
*
parentWindow
=
GTK_WINDOW
(
GetGtkWidget
(
)
)
;
GtkWindow
*
topmostParentWindow
=
nullptr
;
while
(
parentWindow
)
{
topmostParentWindow
=
parentWindow
;
parentWindow
=
gtk_window_get_transient_for
(
parentWindow
)
;
}
return
topmostParentWindow
;
}
gint
nsWindow
:
:
GdkCeiledScaleFactor
(
)
{
if
(
mWindowType
=
=
eWindowType_toplevel
&
&
!
mWindowScaleFactorChanged
)
{
return
mWindowScaleFactor
;
}
GdkWindow
*
scaledGdkWindow
=
nullptr
;
if
(
GdkIsWaylandDisplay
(
)
)
{
if
(
mWindowType
=
=
eWindowType_popup
|
|
mWindowType
=
=
eWindowType_dialog
)
{
GtkWindow
*
topmostParentWindow
=
GetCurrentTopmostWindow
(
)
;
if
(
topmostParentWindow
)
{
scaledGdkWindow
=
gtk_widget_get_window
(
GTK_WIDGET
(
topmostParentWindow
)
)
;
}
else
{
NS_WARNING
(
"
Popup
/
Dialog
has
no
parent
.
"
)
;
}
}
}
if
(
!
scaledGdkWindow
)
{
scaledGdkWindow
=
mGdkWindow
;
}
if
(
scaledGdkWindow
)
{
mWindowScaleFactor
=
gdk_window_get_scale_factor
(
scaledGdkWindow
)
;
mWindowScaleFactorChanged
=
false
;
}
else
{
mWindowScaleFactor
=
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
}
return
mWindowScaleFactor
;
}
bool
nsWindow
:
:
UseFractionalScale
(
)
{
#
ifdef
MOZ_WAYLAND
return
(
GdkIsWaylandDisplay
(
)
&
&
StaticPrefs
:
:
widget_wayland_fractional_buffer_scale_AtStartup
(
)
>
0
&
&
WaylandDisplayGet
(
)
-
>
GetViewporter
(
)
)
;
#
else
return
false
;
#
endif
}
double
nsWindow
:
:
FractionalScaleFactor
(
)
{
#
ifdef
MOZ_WAYLAND
if
(
UseFractionalScale
(
)
)
{
double
scale
=
StaticPrefs
:
:
widget_wayland_fractional_buffer_scale_AtStartup
(
)
;
scale
=
std
:
:
max
(
scale
0
.
5
)
;
scale
=
std
:
:
min
(
scale
8
.
0
)
;
return
scale
;
}
#
endif
return
GdkCeiledScaleFactor
(
)
;
}
gint
nsWindow
:
:
DevicePixelsToGdkCoordRoundUp
(
int
pixels
)
{
double
scale
=
FractionalScaleFactor
(
)
;
return
ceil
(
pixels
/
scale
)
;
}
gint
nsWindow
:
:
DevicePixelsToGdkCoordRoundDown
(
int
pixels
)
{
double
scale
=
FractionalScaleFactor
(
)
;
return
floor
(
pixels
/
scale
)
;
}
GdkPoint
nsWindow
:
:
DevicePixelsToGdkPointRoundDown
(
LayoutDeviceIntPoint
point
)
{
double
scale
=
FractionalScaleFactor
(
)
;
return
{
int
(
point
.
x
/
scale
)
int
(
point
.
y
/
scale
)
}
;
}
GdkRectangle
nsWindow
:
:
DevicePixelsToGdkRectRoundOut
(
LayoutDeviceIntRect
rect
)
{
double
scale
=
FractionalScaleFactor
(
)
;
int
x
=
floor
(
rect
.
x
/
scale
)
;
int
y
=
floor
(
rect
.
y
/
scale
)
;
int
right
=
ceil
(
(
rect
.
x
+
rect
.
width
)
/
scale
)
;
int
bottom
=
ceil
(
(
rect
.
y
+
rect
.
height
)
/
scale
)
;
return
{
x
y
right
-
x
bottom
-
y
}
;
}
GdkRectangle
nsWindow
:
:
DevicePixelsToGdkSizeRoundUp
(
LayoutDeviceIntSize
pixelSize
)
{
double
scale
=
FractionalScaleFactor
(
)
;
gint
width
=
ceil
(
pixelSize
.
width
/
scale
)
;
gint
height
=
ceil
(
pixelSize
.
height
/
scale
)
;
return
{
0
0
width
height
}
;
}
int
nsWindow
:
:
GdkCoordToDevicePixels
(
gint
coord
)
{
return
(
int
)
(
coord
*
FractionalScaleFactor
(
)
)
;
}
LayoutDeviceIntPoint
nsWindow
:
:
GdkEventCoordsToDevicePixels
(
gdouble
x
gdouble
y
)
{
double
scale
=
FractionalScaleFactor
(
)
;
return
LayoutDeviceIntPoint
:
:
Floor
(
(
float
)
(
x
*
scale
)
(
float
)
(
y
*
scale
)
)
;
}
LayoutDeviceIntPoint
nsWindow
:
:
GdkPointToDevicePixels
(
GdkPoint
point
)
{
double
scale
=
FractionalScaleFactor
(
)
;
return
LayoutDeviceIntPoint
:
:
Floor
(
(
float
)
(
point
.
x
*
scale
)
(
float
)
(
point
.
y
*
scale
)
)
;
}
LayoutDeviceIntRect
nsWindow
:
:
GdkRectToDevicePixels
(
GdkRectangle
rect
)
{
double
scale
=
FractionalScaleFactor
(
)
;
return
LayoutDeviceIntRect
:
:
RoundIn
(
(
float
)
(
rect
.
x
*
scale
)
(
float
)
(
rect
.
y
*
scale
)
(
float
)
(
rect
.
width
*
scale
)
(
float
)
(
rect
.
height
*
scale
)
)
;
}
nsresult
nsWindow
:
:
SynthesizeNativeMouseEvent
(
LayoutDeviceIntPoint
aPoint
NativeMouseMessage
aNativeMessage
MouseButton
aButton
nsIWidget
:
:
Modifiers
aModifierFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mouseevent
"
)
;
if
(
!
mGdkWindow
)
{
return
NS_OK
;
}
GdkDisplay
*
display
=
gdk_window_get_display
(
mGdkWindow
)
;
switch
(
aNativeMessage
)
{
case
NativeMouseMessage
:
:
ButtonDown
:
case
NativeMouseMessage
:
:
ButtonUp
:
{
GdkEvent
event
;
memset
(
&
event
0
sizeof
(
GdkEvent
)
)
;
event
.
type
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
GDK_BUTTON_PRESS
:
GDK_BUTTON_RELEASE
;
switch
(
aButton
)
{
case
MouseButton
:
:
ePrimary
:
case
MouseButton
:
:
eMiddle
:
case
MouseButton
:
:
eSecondary
:
case
MouseButton
:
:
eX1
:
case
MouseButton
:
:
eX2
:
event
.
button
.
button
=
aButton
+
1
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
event
.
button
.
state
=
KeymapWrapper
:
:
ConvertWidgetModifierToGdkState
(
aModifierFlags
)
;
event
.
button
.
window
=
mGdkWindow
;
event
.
button
.
time
=
GDK_CURRENT_TIME
;
GdkDeviceManager
*
device_manager
=
gdk_display_get_device_manager
(
display
)
;
event
.
button
.
device
=
gdk_device_manager_get_client_pointer
(
device_manager
)
;
event
.
button
.
x_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
x
)
;
event
.
button
.
y_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
y
)
;
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
event
.
button
.
x
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
x
)
;
event
.
button
.
y
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
y
)
;
gdk_event_put
(
&
event
)
;
return
NS_OK
;
}
case
NativeMouseMessage
:
:
Move
:
{
#
ifdef
MOZ_WAYLAND
if
(
GdkIsWaylandDisplay
(
)
)
{
return
NS_OK
;
}
#
endif
GdkScreen
*
screen
=
gdk_window_get_screen
(
mGdkWindow
)
;
GdkPoint
point
=
DevicePixelsToGdkPointRoundDown
(
aPoint
)
;
gdk_display_warp_pointer
(
display
screen
point
.
x
point
.
y
)
;
return
NS_OK
;
}
case
NativeMouseMessage
:
:
EnterWindow
:
case
NativeMouseMessage
:
:
LeaveWindow
:
MOZ_ASSERT_UNREACHABLE
(
"
Non
supported
mouse
event
on
Linux
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
return
NS_ERROR_UNEXPECTED
;
}
nsresult
nsWindow
:
:
SynthesizeNativeMouseScrollEvent
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
double
aDeltaX
double
aDeltaY
double
aDeltaZ
uint32_t
aModifierFlags
uint32_t
aAdditionalFlags
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
mousescrollevent
"
)
;
if
(
!
mGdkWindow
)
{
return
NS_OK
;
}
GdkEvent
event
;
memset
(
&
event
0
sizeof
(
GdkEvent
)
)
;
event
.
type
=
GDK_SCROLL
;
event
.
scroll
.
window
=
mGdkWindow
;
event
.
scroll
.
time
=
GDK_CURRENT_TIME
;
GdkDisplay
*
display
=
gdk_window_get_display
(
mGdkWindow
)
;
GdkDeviceManager
*
device_manager
=
gdk_display_get_device_manager
(
display
)
;
event
.
scroll
.
device
=
gdk_device_manager_get_client_pointer
(
device_manager
)
;
event
.
scroll
.
x_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
x
)
;
event
.
scroll
.
y_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
y
)
;
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
event
.
scroll
.
x
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
x
)
;
event
.
scroll
.
y
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
y
)
;
event
.
scroll
.
direction
=
GDK_SCROLL_SMOOTH
;
event
.
scroll
.
delta_x
=
-
aDeltaX
;
event
.
scroll
.
delta_y
=
-
aDeltaY
;
gdk_event_put
(
&
event
)
;
return
NS_OK
;
}
nsresult
nsWindow
:
:
SynthesizeNativeTouchPoint
(
uint32_t
aPointerId
TouchPointerState
aPointerState
LayoutDeviceIntPoint
aPoint
double
aPointerPressure
uint32_t
aPointerOrientation
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
touchpoint
"
)
;
if
(
!
mGdkWindow
)
{
return
NS_OK
;
}
GdkEvent
event
;
memset
(
&
event
0
sizeof
(
GdkEvent
)
)
;
static
std
:
:
map
<
uint32_t
GdkEventSequence
*
>
sKnownPointers
;
auto
result
=
sKnownPointers
.
find
(
aPointerId
)
;
switch
(
aPointerState
)
{
case
TOUCH_CONTACT
:
if
(
result
=
=
sKnownPointers
.
end
(
)
)
{
event
.
touch
.
sequence
=
(
GdkEventSequence
*
)
(
(
uintptr_t
)
aPointerId
)
;
sKnownPointers
[
aPointerId
]
=
event
.
touch
.
sequence
;
event
.
type
=
GDK_TOUCH_BEGIN
;
}
else
{
event
.
touch
.
sequence
=
result
-
>
second
;
event
.
type
=
GDK_TOUCH_UPDATE
;
}
break
;
case
TOUCH_REMOVE
:
event
.
type
=
GDK_TOUCH_END
;
if
(
result
=
=
sKnownPointers
.
end
(
)
)
{
NS_WARNING
(
"
Tried
to
synthesize
touch
-
end
for
unknown
pointer
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
event
.
touch
.
sequence
=
result
-
>
second
;
sKnownPointers
.
erase
(
result
)
;
break
;
case
TOUCH_CANCEL
:
event
.
type
=
GDK_TOUCH_CANCEL
;
if
(
result
=
=
sKnownPointers
.
end
(
)
)
{
NS_WARNING
(
"
Tried
to
synthesize
touch
-
cancel
for
unknown
pointer
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
event
.
touch
.
sequence
=
result
-
>
second
;
sKnownPointers
.
erase
(
result
)
;
break
;
case
TOUCH_HOVER
:
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
event
.
touch
.
window
=
mGdkWindow
;
event
.
touch
.
time
=
GDK_CURRENT_TIME
;
GdkDisplay
*
display
=
gdk_window_get_display
(
mGdkWindow
)
;
GdkDeviceManager
*
device_manager
=
gdk_display_get_device_manager
(
display
)
;
event
.
touch
.
device
=
gdk_device_manager_get_client_pointer
(
device_manager
)
;
event
.
touch
.
x_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
x
)
;
event
.
touch
.
y_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
y
)
;
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
event
.
touch
.
x
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
x
)
;
event
.
touch
.
y
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
y
)
;
gdk_event_put
(
&
event
)
;
return
NS_OK
;
}
nsresult
nsWindow
:
:
SynthesizeNativeTouchPadPinch
(
TouchpadGesturePhase
aEventPhase
float
aScale
LayoutDeviceIntPoint
aPoint
int32_t
aModifierFlags
)
{
if
(
!
mGdkWindow
)
{
return
NS_OK
;
}
GdkEvent
event
;
memset
(
&
event
0
sizeof
(
GdkEvent
)
)
;
GdkEventTouchpadPinch
*
touchpad_event
=
reinterpret_cast
<
GdkEventTouchpadPinch
*
>
(
&
event
)
;
touchpad_event
-
>
type
=
GDK_TOUCHPAD_PINCH
;
switch
(
aEventPhase
)
{
case
PHASE_BEGIN
:
touchpad_event
-
>
phase
=
GDK_TOUCHPAD_GESTURE_PHASE_BEGIN
;
break
;
case
PHASE_UPDATE
:
touchpad_event
-
>
phase
=
GDK_TOUCHPAD_GESTURE_PHASE_UPDATE
;
break
;
case
PHASE_END
:
touchpad_event
-
>
phase
=
GDK_TOUCHPAD_GESTURE_PHASE_END
;
break
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
touchpad_event
-
>
window
=
mGdkWindow
;
touchpad_event
-
>
time
=
GDK_CURRENT_TIME
;
touchpad_event
-
>
scale
=
aScale
;
touchpad_event
-
>
x_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
x
)
;
touchpad_event
-
>
y_root
=
DevicePixelsToGdkCoordRoundDown
(
aPoint
.
y
)
;
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
touchpad_event
-
>
x
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
x
)
;
touchpad_event
-
>
y
=
DevicePixelsToGdkCoordRoundDown
(
pointInWindow
.
y
)
;
touchpad_event
-
>
state
=
aModifierFlags
;
gdk_event_put
(
&
event
)
;
return
NS_OK
;
}
nsWindow
:
:
GtkWindowDecoration
nsWindow
:
:
GetSystemGtkWindowDecoration
(
)
{
static
GtkWindowDecoration
sGtkWindowDecoration
=
[
]
{
if
(
const
char
*
decorationOverride
=
getenv
(
"
MOZ_GTK_TITLEBAR_DECORATION
"
)
)
{
if
(
strcmp
(
decorationOverride
"
none
"
)
=
=
0
)
{
return
GTK_DECORATION_NONE
;
}
if
(
strcmp
(
decorationOverride
"
client
"
)
=
=
0
)
{
return
GTK_DECORATION_CLIENT
;
}
if
(
strcmp
(
decorationOverride
"
system
"
)
=
=
0
)
{
return
GTK_DECORATION_SYSTEM
;
}
}
if
(
GdkIsWaylandDisplay
(
)
)
{
return
GTK_DECORATION_CLIENT
;
}
const
char
*
csdOverride
=
getenv
(
"
GTK_CSD
"
)
;
if
(
csdOverride
&
&
*
csdOverride
=
=
'
1
'
)
{
return
GTK_DECORATION_CLIENT
;
}
const
char
*
currentDesktop
=
getenv
(
"
XDG_CURRENT_DESKTOP
"
)
;
if
(
!
currentDesktop
)
{
return
GTK_DECORATION_NONE
;
}
if
(
strstr
(
currentDesktop
"
pop
:
GNOME
"
)
|
|
strstr
(
currentDesktop
"
KDE
"
)
|
|
strstr
(
currentDesktop
"
Enlightenment
"
)
|
|
strstr
(
currentDesktop
"
LXDE
"
)
|
|
strstr
(
currentDesktop
"
openbox
"
)
|
|
strstr
(
currentDesktop
"
MATE
"
)
|
|
strstr
(
currentDesktop
"
X
-
Cinnamon
"
)
|
|
strstr
(
currentDesktop
"
Pantheon
"
)
|
|
strstr
(
currentDesktop
"
Deepin
"
)
)
{
return
GTK_DECORATION_CLIENT
;
}
if
(
strstr
(
currentDesktop
"
GNOME
"
)
|
|
strstr
(
currentDesktop
"
LXQt
"
)
|
|
strstr
(
currentDesktop
"
Unity
"
)
)
{
return
GTK_DECORATION_SYSTEM
;
}
if
(
strstr
(
currentDesktop
"
i3
"
)
)
{
return
GTK_DECORATION_NONE
;
}
return
GTK_DECORATION_CLIENT
;
}
(
)
;
return
sGtkWindowDecoration
;
}
bool
nsWindow
:
:
TitlebarUseShapeMask
(
)
{
static
int
useShapeMask
=
[
]
(
)
{
if
(
!
GdkIsX11Display
(
)
)
{
return
false
;
}
const
char
*
currentDesktop
=
getenv
(
"
XDG_CURRENT_DESKTOP
"
)
;
if
(
currentDesktop
)
{
if
(
strstr
(
currentDesktop
"
GNOME
"
)
!
=
nullptr
)
{
const
char
*
sessionType
=
getenv
(
"
XDG_SESSION_TYPE
"
)
;
if
(
sessionType
&
&
strstr
(
sessionType
"
x11
"
)
!
=
nullptr
)
{
return
false
;
}
}
}
return
Preferences
:
:
GetBool
(
"
widget
.
titlebar
-
x11
-
use
-
shape
-
mask
"
false
)
;
}
(
)
;
return
useShapeMask
;
}
int32_t
nsWindow
:
:
RoundsWidgetCoordinatesTo
(
)
{
return
GdkCeiledScaleFactor
(
)
;
}
void
nsWindow
:
:
GetCompositorWidgetInitData
(
mozilla
:
:
widget
:
:
CompositorWidgetInitData
*
aInitData
)
{
nsCString
displayName
;
LOG
(
"
nsWindow
:
:
GetCompositorWidgetInitData
"
)
;
EnsureGdkWindow
(
)
;
*
aInitData
=
mozilla
:
:
widget
:
:
GtkCompositorWidgetInitData
(
GetX11Window
(
)
displayName
GetShapedState
(
)
GdkIsX11Display
(
)
GetClientSize
(
)
)
;
#
ifdef
MOZ_X11
if
(
GdkIsX11Display
(
)
)
{
Display
*
display
=
DefaultXDisplay
(
)
;
XFlush
(
display
)
;
displayName
=
nsCString
(
XDisplayString
(
display
)
)
;
}
#
endif
}
#
ifdef
MOZ_X11
#
define
PROGRESS_HINT
"
_NET_WM_XAPP_PROGRESS
"
static
void
set_window_hint_cardinal
(
Window
xid
const
gchar
*
atom_name
gulong
cardinal
)
{
GdkDisplay
*
display
;
display
=
gdk_display_get_default
(
)
;
if
(
cardinal
>
0
)
{
XChangeProperty
(
GDK_DISPLAY_XDISPLAY
(
display
)
xid
gdk_x11_get_xatom_by_name_for_display
(
display
atom_name
)
XA_CARDINAL
32
PropModeReplace
(
guchar
*
)
&
cardinal
1
)
;
}
else
{
XDeleteProperty
(
GDK_DISPLAY_XDISPLAY
(
display
)
xid
gdk_x11_get_xatom_by_name_for_display
(
display
atom_name
)
)
;
}
}
#
endif
void
nsWindow
:
:
SetProgress
(
unsigned
long
progressPercent
)
{
#
ifdef
MOZ_X11
if
(
!
GdkIsX11Display
(
)
)
{
return
;
}
if
(
!
mShell
)
{
return
;
}
progressPercent
=
MIN
(
progressPercent
100
)
;
set_window_hint_cardinal
(
GDK_WINDOW_XID
(
gtk_widget_get_window
(
mShell
)
)
PROGRESS_HINT
progressPercent
)
;
#
endif
}
#
ifdef
MOZ_X11
void
nsWindow
:
:
SetCompositorHint
(
WindowComposeRequest
aState
)
{
if
(
!
GdkIsX11Display
(
)
)
{
return
;
}
gulong
value
=
aState
;
GdkAtom
cardinal_atom
=
gdk_x11_xatom_to_atom
(
XA_CARDINAL
)
;
gdk_property_change
(
gtk_widget_get_window
(
mShell
)
gdk_atom_intern
(
"
_NET_WM_BYPASS_COMPOSITOR
"
FALSE
)
cardinal_atom
32
GDK_PROP_MODE_REPLACE
(
guchar
*
)
&
value
1
)
;
}
#
endif
nsresult
nsWindow
:
:
SetSystemFont
(
const
nsCString
&
aFontName
)
{
GtkSettings
*
settings
=
gtk_settings_get_default
(
)
;
g_object_set
(
settings
"
gtk
-
font
-
name
"
aFontName
.
get
(
)
nullptr
)
;
return
NS_OK
;
}
nsresult
nsWindow
:
:
GetSystemFont
(
nsCString
&
aFontName
)
{
GtkSettings
*
settings
=
gtk_settings_get_default
(
)
;
gchar
*
fontName
=
nullptr
;
g_object_get
(
settings
"
gtk
-
font
-
name
"
&
fontName
nullptr
)
;
if
(
fontName
)
{
aFontName
.
Assign
(
fontName
)
;
g_free
(
fontName
)
;
}
return
NS_OK
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateTopLevelWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsWindow
(
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateChildWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsWindow
(
)
;
return
window
.
forget
(
)
;
}
#
ifdef
MOZ_WAYLAND
static
void
relative_pointer_handle_relative_motion
(
void
*
data
struct
zwp_relative_pointer_v1
*
pointer
uint32_t
time_hi
uint32_t
time_lo
wl_fixed_t
dx_w
wl_fixed_t
dy_w
wl_fixed_t
dx_unaccel_w
wl_fixed_t
dy_unaccel_w
)
{
RefPtr
<
nsWindow
>
window
(
reinterpret_cast
<
nsWindow
*
>
(
data
)
)
;
WidgetMouseEvent
event
(
true
eMouseMove
window
WidgetMouseEvent
:
:
eReal
)
;
event
.
mRefPoint
=
window
-
>
GetNativePointerLockCenter
(
)
;
event
.
mRefPoint
.
x
+
=
wl_fixed_to_int
(
dx_w
)
;
event
.
mRefPoint
.
y
+
=
wl_fixed_to_int
(
dy_w
)
;
event
.
AssignEventTime
(
window
-
>
GetWidgetEventTime
(
time_lo
)
)
;
window
-
>
DispatchInputEvent
(
&
event
)
;
}
static
const
struct
zwp_relative_pointer_v1_listener
relative_pointer_listener
=
{
relative_pointer_handle_relative_motion
}
;
void
nsWindow
:
:
SetNativePointerLockCenter
(
const
LayoutDeviceIntPoint
&
aLockCenter
)
{
mNativePointerLockCenter
=
aLockCenter
;
}
void
nsWindow
:
:
LockNativePointer
(
)
{
if
(
!
GdkIsWaylandDisplay
(
)
)
{
return
;
}
auto
waylandDisplay
=
WaylandDisplayGet
(
)
;
auto
*
pointerConstraints
=
waylandDisplay
-
>
GetPointerConstraints
(
)
;
if
(
!
pointerConstraints
)
{
return
;
}
auto
*
relativePointerMgr
=
waylandDisplay
-
>
GetRelativePointerManager
(
)
;
if
(
!
relativePointerMgr
)
{
return
;
}
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
GdkDeviceManager
*
manager
=
gdk_display_get_device_manager
(
display
)
;
MOZ_ASSERT
(
manager
)
;
GdkDevice
*
device
=
gdk_device_manager_get_client_pointer
(
manager
)
;
if
(
!
device
)
{
NS_WARNING
(
"
Could
not
find
Wayland
pointer
to
lock
"
)
;
return
;
}
wl_pointer
*
pointer
=
gdk_wayland_device_get_wl_pointer
(
device
)
;
MOZ_ASSERT
(
pointer
)
;
wl_surface
*
surface
=
gdk_wayland_window_get_wl_surface
(
gtk_widget_get_window
(
GetGtkWidget
(
)
)
)
;
if
(
!
surface
)
{
return
;
}
mLockedPointer
=
zwp_pointer_constraints_v1_lock_pointer
(
pointerConstraints
surface
pointer
nullptr
ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT
)
;
if
(
!
mLockedPointer
)
{
NS_WARNING
(
"
Could
not
lock
Wayland
pointer
"
)
;
return
;
}
mRelativePointer
=
zwp_relative_pointer_manager_v1_get_relative_pointer
(
relativePointerMgr
pointer
)
;
if
(
!
mRelativePointer
)
{
NS_WARNING
(
"
Could
not
create
relative
Wayland
pointer
"
)
;
zwp_locked_pointer_v1_destroy
(
mLockedPointer
)
;
mLockedPointer
=
nullptr
;
return
;
}
zwp_relative_pointer_v1_add_listener
(
mRelativePointer
&
relative_pointer_listener
this
)
;
}
void
nsWindow
:
:
UnlockNativePointer
(
)
{
if
(
!
GdkIsWaylandDisplay
(
)
)
{
return
;
}
if
(
mRelativePointer
)
{
zwp_relative_pointer_v1_destroy
(
mRelativePointer
)
;
mRelativePointer
=
nullptr
;
}
if
(
mLockedPointer
)
{
zwp_locked_pointer_v1_destroy
(
mLockedPointer
)
;
mLockedPointer
=
nullptr
;
}
}
#
endif
bool
nsWindow
:
:
GetTopLevelWindowActiveState
(
nsIFrame
*
aFrame
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
false
;
}
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
true
;
}
nsWindow
*
window
=
static_cast
<
nsWindow
*
>
(
aFrame
-
>
GetNearestWidget
(
)
)
;
if
(
!
window
)
{
return
false
;
}
return
!
window
-
>
mTitlebarBackdropState
;
}
static
nsIFrame
*
FindTitlebarFrame
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
StyleAppearance
appearance
=
childFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
;
if
(
appearance
=
=
StyleAppearance
:
:
MozWindowTitlebar
|
|
appearance
=
=
StyleAppearance
:
:
MozWindowTitlebarMaximized
)
{
return
childFrame
;
}
if
(
nsIFrame
*
foundFrame
=
FindTitlebarFrame
(
childFrame
)
)
{
return
foundFrame
;
}
}
return
nullptr
;
}
nsIFrame
*
nsWindow
:
:
GetFrame
(
)
const
{
nsView
*
view
=
nsView
:
:
GetViewFor
(
this
)
;
if
(
!
view
)
{
return
nullptr
;
}
return
view
-
>
GetFrame
(
)
;
}
void
nsWindow
:
:
UpdateMozWindowActive
(
)
{
if
(
mozilla
:
:
dom
:
:
Document
*
document
=
GetDocument
(
)
)
{
if
(
nsPIDOMWindowOuter
*
window
=
document
-
>
GetWindow
(
)
)
{
if
(
RefPtr
<
mozilla
:
:
dom
:
:
BrowsingContext
>
bc
=
window
-
>
GetBrowsingContext
(
)
)
{
bc
-
>
SetIsActiveBrowserWindow
(
!
mTitlebarBackdropState
)
;
}
}
}
}
void
nsWindow
:
:
ForceTitlebarRedraw
(
void
)
{
MOZ_ASSERT
(
mDrawInTitlebar
"
We
should
not
redraw
invisible
titlebar
.
"
)
;
if
(
!
mWidgetListener
|
|
!
mWidgetListener
-
>
GetPresShell
(
)
)
{
return
;
}
nsIFrame
*
frame
=
GetFrame
(
)
;
if
(
!
frame
)
{
return
;
}
frame
=
FindTitlebarFrame
(
frame
)
;
if
(
frame
)
{
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
content
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_RepaintFrame
)
;
}
}
}
void
nsWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
if
(
!
gUseAspectRatio
)
{
return
;
}
if
(
aShouldLock
)
{
int
decWidth
=
0
decHeight
=
0
;
AddCSDDecorationSize
(
&
decWidth
&
decHeight
)
;
float
width
=
(
float
)
DevicePixelsToGdkCoordRoundDown
(
mBounds
.
width
)
+
(
float
)
decWidth
;
float
height
=
(
float
)
DevicePixelsToGdkCoordRoundDown
(
mBounds
.
height
)
+
(
float
)
decHeight
;
mAspectRatio
=
width
/
height
;
LOG
(
"
nsWindow
:
:
LockAspectRatio
(
)
width
%
f
height
%
f
aspect
%
f
"
width
height
mAspectRatio
)
;
}
else
{
mAspectRatio
=
0
.
0
;
LOG
(
"
nsWindow
:
:
LockAspectRatio
(
)
removed
aspect
ratio
"
)
;
}
ApplySizeConstraints
(
)
;
}
nsWindow
*
nsWindow
:
:
GetFocusedWindow
(
)
{
return
gFocusWindow
;
}
#
ifdef
MOZ_WAYLAND
void
nsWindow
:
:
SetEGLNativeWindowSize
(
const
LayoutDeviceIntSize
&
aEGLWindowSize
)
{
if
(
!
mContainer
|
|
!
GdkIsWaylandDisplay
(
)
)
{
return
;
}
moz_container_wayland_egl_window_set_size
(
mContainer
aEGLWindowSize
.
width
aEGLWindowSize
.
height
)
;
moz_container_wayland_set_scale_factor
(
mContainer
)
;
}
#
endif
LayoutDeviceIntSize
nsWindow
:
:
GetMozContainerSize
(
)
{
LayoutDeviceIntSize
size
(
0
0
)
;
if
(
mContainer
)
{
GtkAllocation
allocation
;
gtk_widget_get_allocation
(
GTK_WIDGET
(
mContainer
)
&
allocation
)
;
double
scale
=
FractionalScaleFactor
(
)
;
size
.
width
=
round
(
allocation
.
width
*
scale
)
;
size
.
height
=
round
(
allocation
.
height
*
scale
)
;
}
return
size
;
}
