#
ifndef
_MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
#
define
_MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
#
include
<
prthread
.
h
>
#
include
"
gfxImageSurface
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
nsWaylandDisplay
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
WindowSurface
.
h
"
#
define
BACK_BUFFER_NUM
3
namespace
mozilla
{
namespace
widget
{
class
WindowSurfaceWayland
;
class
WaylandShmPool
{
public
:
WaylandShmPool
(
RefPtr
<
nsWaylandDisplay
>
aDisplay
int
aSize
)
;
~
WaylandShmPool
(
)
;
bool
Resize
(
int
aSize
)
;
wl_shm_pool
*
GetShmPool
(
)
{
return
mShmPool
;
}
;
void
*
GetImageData
(
)
{
return
mImageData
;
}
;
void
SetImageDataFromPool
(
class
WaylandShmPool
*
aSourcePool
int
aImageDataSize
)
;
private
:
wl_shm_pool
*
mShmPool
;
int
mShmPoolFd
;
int
mAllocatedSize
;
void
*
mImageData
;
}
;
class
WindowBackBuffer
{
public
:
virtual
already_AddRefed
<
gfx
:
:
DrawTarget
>
Lock
(
)
=
0
;
virtual
void
Unlock
(
)
=
0
;
virtual
bool
IsLocked
(
)
=
0
;
void
Attach
(
wl_surface
*
aSurface
)
;
virtual
void
Detach
(
wl_buffer
*
aBuffer
)
=
0
;
virtual
bool
IsAttached
(
)
=
0
;
virtual
void
Clear
(
)
=
0
;
virtual
bool
Resize
(
int
aWidth
int
aHeight
)
=
0
;
virtual
int
GetWidth
(
)
=
0
;
virtual
int
GetHeight
(
)
=
0
;
virtual
wl_buffer
*
GetWlBuffer
(
)
=
0
;
virtual
void
SetAttached
(
)
=
0
;
virtual
bool
SetImageDataFromBuffer
(
class
WindowBackBuffer
*
aSourceBuffer
)
=
0
;
bool
IsMatchingSize
(
int
aWidth
int
aHeight
)
{
return
aWidth
=
=
GetWidth
(
)
&
&
aHeight
=
=
GetHeight
(
)
;
}
bool
IsMatchingSize
(
class
WindowBackBuffer
*
aBuffer
)
{
return
aBuffer
-
>
IsMatchingSize
(
GetWidth
(
)
GetHeight
(
)
)
;
}
static
gfx
:
:
SurfaceFormat
GetSurfaceFormat
(
)
{
return
mFormat
;
}
RefPtr
<
nsWaylandDisplay
>
GetWaylandDisplay
(
)
;
WindowBackBuffer
(
WindowSurfaceWayland
*
aWindowSurfaceWayland
)
:
mWindowSurfaceWayland
(
aWindowSurfaceWayland
)
{
}
;
virtual
~
WindowBackBuffer
(
)
=
default
;
protected
:
WindowSurfaceWayland
*
mWindowSurfaceWayland
;
private
:
static
gfx
:
:
SurfaceFormat
mFormat
;
}
;
class
WindowBackBufferShm
:
public
WindowBackBuffer
{
public
:
WindowBackBufferShm
(
WindowSurfaceWayland
*
aWindowSurfaceWayland
int
aWidth
int
aHeight
)
;
~
WindowBackBufferShm
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
Lock
(
)
;
bool
IsLocked
(
)
{
return
mIsLocked
;
}
;
void
Unlock
(
)
{
mIsLocked
=
false
;
}
;
void
Detach
(
wl_buffer
*
aBuffer
)
;
bool
IsAttached
(
)
{
return
mAttached
;
}
void
SetAttached
(
)
{
mAttached
=
true
;
}
;
void
Clear
(
)
;
bool
Resize
(
int
aWidth
int
aHeight
)
;
bool
SetImageDataFromBuffer
(
class
WindowBackBuffer
*
aSourceBuffer
)
;
int
GetWidth
(
)
{
return
mWidth
;
}
;
int
GetHeight
(
)
{
return
mHeight
;
}
;
wl_buffer
*
GetWlBuffer
(
)
{
return
mWLBuffer
;
}
;
private
:
void
Create
(
int
aWidth
int
aHeight
)
;
void
ReleaseShmSurface
(
)
;
WaylandShmPool
mShmPool
;
wl_buffer
*
mWLBuffer
;
int
mWidth
;
int
mHeight
;
bool
mAttached
;
bool
mIsLocked
;
}
;
class
WindowImageSurface
{
public
:
static
void
Draw
(
gfx
:
:
SourceSurface
*
aSurface
gfx
:
:
DrawTarget
*
aDest
const
LayoutDeviceIntRegion
&
aRegion
)
;
void
Draw
(
gfx
:
:
DrawTarget
*
aDest
LayoutDeviceIntRegion
&
aWaylandBufferDamage
)
;
WindowImageSurface
(
gfxImageSurface
*
aImageSurface
const
LayoutDeviceIntRegion
&
aUpdateRegion
)
;
bool
OverlapsSurface
(
class
WindowImageSurface
&
aBottomSurface
)
;
const
LayoutDeviceIntRegion
*
GetUpdateRegion
(
)
{
return
&
mUpdateRegion
;
}
;
private
:
RefPtr
<
gfx
:
:
SourceSurface
>
mSurface
;
RefPtr
<
gfxImageSurface
>
mImageSurface
;
const
LayoutDeviceIntRegion
mUpdateRegion
;
}
;
class
WindowSurfaceWayland
:
public
WindowSurface
{
public
:
explicit
WindowSurfaceWayland
(
nsWindow
*
aWindow
)
;
~
WindowSurfaceWayland
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
Lock
(
const
LayoutDeviceIntRegion
&
aRegion
)
override
;
void
Commit
(
const
LayoutDeviceIntRegion
&
aInvalidRegion
)
final
;
void
FrameCallbackHandler
(
)
;
void
CommitWaylandBuffer
(
)
;
RefPtr
<
nsWaylandDisplay
>
GetWaylandDisplay
(
)
{
return
mWaylandDisplay
;
}
;
typedef
enum
{
CACHE_ALL
=
0
CACHE_MISSING
=
1
CACHE_NONE
=
2
}
RenderingCacheMode
;
private
:
WindowBackBuffer
*
GetWaylandBufferWithSwitch
(
)
;
WindowBackBuffer
*
GetWaylandBufferRecent
(
)
;
WindowBackBuffer
*
SetNewWaylandBuffer
(
)
;
WindowBackBuffer
*
CreateWaylandBuffer
(
int
aWidth
int
aHeight
)
;
WindowBackBuffer
*
WaylandBufferFindAvailable
(
int
aWidth
int
aHeight
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
LockWaylandBuffer
(
)
;
void
UnlockWaylandBuffer
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
LockImageSurface
(
const
gfx
:
:
IntSize
&
aLockSize
)
;
void
CacheImageSurface
(
const
LayoutDeviceIntRegion
&
aRegion
)
;
bool
CommitImageCacheToWaylandBuffer
(
)
;
void
DrawDelayedImageCommits
(
gfx
:
:
DrawTarget
*
aDrawTarget
LayoutDeviceIntRegion
&
aWaylandBufferDamage
)
;
nsWindow
*
mWindow
;
LayoutDeviceIntRect
mLockedScreenRect
;
LayoutDeviceIntRect
mWLBufferRect
;
RefPtr
<
nsWaylandDisplay
>
mWaylandDisplay
;
WindowBackBuffer
*
mWaylandBuffer
;
WindowBackBuffer
*
mShmBackupBuffer
[
BACK_BUFFER_NUM
]
;
bool
mWaylandFullscreenDamage
;
LayoutDeviceIntRegion
mWaylandBufferDamage
;
wl_callback
*
mFrameCallback
;
wl_surface
*
mLastCommittedSurface
;
RefPtr
<
gfxImageSurface
>
mImageSurface
;
AutoTArray
<
WindowImageSurface
30
>
mDelayedImageCommits
;
int64_t
mLastCommitTime
;
bool
mDrawToWaylandBufferDirectly
;
bool
mCanSwitchWaylandBuffer
;
bool
mBufferPendingCommit
;
bool
mBufferCommitAllowed
;
bool
mBufferNeedsClear
;
bool
mSmoothRendering
;
bool
mIsMainThread
;
}
;
}
}
#
endif
