#
ifndef
_MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
#
define
_MOZILLA_WIDGET_GTK_WINDOW_SURFACE_WAYLAND_H
#
include
<
prthread
.
h
>
#
include
"
mozilla
/
gfx
/
Types
.
h
"
namespace
mozilla
{
namespace
widget
{
class
nsWaylandDisplay
:
public
nsISupports
{
NS_DECL_THREADSAFE_ISUPPORTS
public
:
nsWaylandDisplay
(
wl_display
*
aDisplay
)
;
wl_shm
*
GetShm
(
)
;
void
SetShm
(
wl_shm
*
aShm
)
{
mShm
=
aShm
;
}
;
wl_display
*
GetDisplay
(
)
{
return
mDisplay
;
}
;
wl_event_queue
*
GetEventQueue
(
)
{
return
mEventQueue
;
}
;
gfx
:
:
SurfaceFormat
GetSurfaceFormat
(
)
{
return
mFormat
;
}
;
bool
DisplayLoop
(
)
;
bool
Matches
(
wl_display
*
aDisplay
)
;
private
:
virtual
~
nsWaylandDisplay
(
)
;
PRThread
*
mThreadId
;
gfx
:
:
SurfaceFormat
mFormat
;
wl_shm
*
mShm
;
wl_event_queue
*
mEventQueue
;
wl_display
*
mDisplay
;
}
;
class
WaylandShmPool
{
public
:
WaylandShmPool
(
nsWaylandDisplay
*
aDisplay
int
aSize
)
;
~
WaylandShmPool
(
)
;
bool
Resize
(
int
aSize
)
;
wl_shm_pool
*
GetShmPool
(
)
{
return
mShmPool
;
}
;
void
*
GetImageData
(
)
{
return
mImageData
;
}
;
void
SetImageDataFromPool
(
class
WaylandShmPool
*
aSourcePool
int
aImageDataSize
)
;
private
:
int
CreateTemporaryFile
(
int
aSize
)
;
wl_shm_pool
*
mShmPool
;
int
mShmPoolFd
;
int
mAllocatedSize
;
void
*
mImageData
;
}
;
class
WindowBackBuffer
{
public
:
WindowBackBuffer
(
nsWaylandDisplay
*
aDisplay
int
aWidth
int
aHeight
)
;
~
WindowBackBuffer
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
Lock
(
)
;
void
Attach
(
wl_surface
*
aSurface
)
;
void
Detach
(
)
;
bool
IsAttached
(
)
{
return
mAttached
;
}
bool
Resize
(
int
aWidth
int
aHeight
)
;
bool
SetImageDataFromBackBuffer
(
class
WindowBackBuffer
*
aSourceBuffer
)
;
bool
IsMatchingSize
(
int
aWidth
int
aHeight
)
{
return
aWidth
=
=
mWidth
&
&
aHeight
=
=
mHeight
;
}
bool
IsMatchingSize
(
class
WindowBackBuffer
*
aBuffer
)
{
return
aBuffer
-
>
mWidth
=
=
mWidth
&
&
aBuffer
-
>
mHeight
=
=
mHeight
;
}
private
:
void
Create
(
int
aWidth
int
aHeight
)
;
void
Release
(
)
;
WaylandShmPool
mShmPool
;
wl_buffer
*
mWaylandBuffer
;
int
mWidth
;
int
mHeight
;
bool
mAttached
;
nsWaylandDisplay
*
mWaylandDisplay
;
}
;
class
WindowSurfaceWayland
:
public
WindowSurface
{
public
:
WindowSurfaceWayland
(
nsWindow
*
aWindow
)
;
~
WindowSurfaceWayland
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
Lock
(
const
LayoutDeviceIntRegion
&
aRegion
)
override
;
void
Commit
(
const
LayoutDeviceIntRegion
&
aInvalidRegion
)
final
;
void
FrameCallbackHandler
(
)
;
private
:
WindowBackBuffer
*
GetFrontBufferToDraw
(
int
aWidth
int
aHeight
)
;
void
UpdateScaleFactor
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
LockFrontBuffer
(
int
aWidth
int
aHeight
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
LockImageSurface
(
const
gfx
:
:
IntSize
&
aLockSize
)
;
bool
CommitImageSurface
(
const
LayoutDeviceIntRegion
&
aRegion
)
;
nsWindow
*
mWindow
;
nsWaylandDisplay
*
mWaylandDisplay
;
WindowBackBuffer
*
mFrontBuffer
;
WindowBackBuffer
*
mBackBuffer
;
RefPtr
<
gfxImageSurface
>
mImageSurface
;
wl_callback
*
mFrameCallback
;
wl_surface
*
mFrameCallbackSurface
;
MessageLoop
*
mDisplayThreadMessageLoop
;
bool
mDirectWlBufferDraw
;
bool
mDelayedCommit
;
bool
mFullScreenDamage
;
bool
mIsMainThread
;
}
;
}
}
#
endif
