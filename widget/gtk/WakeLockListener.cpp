#
ifdef
MOZ_ENABLE_DBUS
#
include
"
WakeLockListener
.
h
"
#
include
<
dbus
/
dbus
.
h
>
#
include
<
dbus
/
dbus
-
glib
-
lowlevel
.
h
>
#
if
defined
(
MOZ_X11
)
#
include
"
gfxPlatformGtk
.
h
"
#
include
"
prlink
.
h
"
#
include
<
gdk
/
gdk
.
h
>
#
include
<
gdk
/
gdkx
.
h
>
#
endif
#
if
defined
(
MOZ_WAYLAND
)
#
include
"
mozilla
/
widget
/
nsWaylandDisplay
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
mozilla
/
dom
/
power
/
PowerManagerService
.
h
"
#
endif
#
define
FREEDESKTOP_SCREENSAVER_TARGET
"
org
.
freedesktop
.
ScreenSaver
"
#
define
FREEDESKTOP_SCREENSAVER_OBJECT
"
/
ScreenSaver
"
#
define
FREEDESKTOP_SCREENSAVER_INTERFACE
"
org
.
freedesktop
.
ScreenSaver
"
#
define
SESSION_MANAGER_TARGET
"
org
.
gnome
.
SessionManager
"
#
define
SESSION_MANAGER_OBJECT
"
/
org
/
gnome
/
SessionManager
"
#
define
SESSION_MANAGER_INTERFACE
"
org
.
gnome
.
SessionManager
"
#
define
DBUS_TIMEOUT
(
-
1
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
NS_IMPL_ISUPPORTS
(
WakeLockListener
nsIDOMMozWakeLockListener
)
StaticRefPtr
<
WakeLockListener
>
WakeLockListener
:
:
sSingleton
;
#
define
WAKE_LOCK_LOG
(
.
.
.
)
\
MOZ_LOG
(
gLinuxWakeLockLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
static
mozilla
:
:
LazyLogModule
gLinuxWakeLockLog
(
"
LinuxWakeLock
"
)
;
enum
DesktopEnvironment
{
FreeDesktop
GNOME
#
if
defined
(
MOZ_X11
)
XScreenSaver
#
endif
#
if
defined
(
MOZ_WAYLAND
)
WaylandIdleInhibit
#
endif
Unsupported
}
;
class
WakeLockTopic
{
public
:
WakeLockTopic
(
const
nsAString
&
aTopic
DBusConnection
*
aConnection
)
:
#
if
defined
(
MOZ_WAYLAND
)
mWaylandInhibitor
(
nullptr
)
#
endif
mTopic
(
NS_ConvertUTF16toUTF8
(
aTopic
)
)
mConnection
(
aConnection
)
mDesktopEnvironment
(
FreeDesktop
)
mInhibitRequest
(
0
)
mShouldInhibit
(
false
)
mWaitingForReply
(
false
)
{
}
nsresult
InhibitScreensaver
(
void
)
;
nsresult
UninhibitScreensaver
(
void
)
;
private
:
bool
SendInhibit
(
)
;
bool
SendUninhibit
(
)
;
bool
SendFreeDesktopInhibitMessage
(
)
;
bool
SendGNOMEInhibitMessage
(
)
;
bool
SendMessage
(
DBusMessage
*
aMessage
)
;
#
if
defined
(
MOZ_X11
)
static
bool
CheckXScreenSaverSupport
(
)
;
static
bool
InhibitXScreenSaver
(
bool
inhibit
)
;
#
endif
#
if
defined
(
MOZ_WAYLAND
)
zwp_idle_inhibitor_v1
*
mWaylandInhibitor
;
static
bool
CheckWaylandIdleInhibitSupport
(
)
;
bool
InhibitWaylandIdle
(
)
;
bool
UninhibitWaylandIdle
(
)
;
#
endif
static
void
ReceiveInhibitReply
(
DBusPendingCall
*
aPending
void
*
aUserData
)
;
void
InhibitFailed
(
)
;
void
InhibitSucceeded
(
uint32_t
aInhibitRequest
)
;
nsCString
mTopic
;
RefPtr
<
DBusConnection
>
mConnection
;
DesktopEnvironment
mDesktopEnvironment
;
uint32_t
mInhibitRequest
;
bool
mShouldInhibit
;
bool
mWaitingForReply
;
}
;
bool
WakeLockTopic
:
:
SendMessage
(
DBusMessage
*
aMessage
)
{
RefPtr
<
DBusPendingCall
>
reply
;
dbus_connection_send_with_reply
(
mConnection
aMessage
reply
.
StartAssignment
(
)
DBUS_TIMEOUT
)
;
if
(
!
reply
)
{
return
false
;
}
dbus_pending_call_set_notify
(
reply
&
ReceiveInhibitReply
this
NULL
)
;
return
true
;
}
bool
WakeLockTopic
:
:
SendFreeDesktopInhibitMessage
(
)
{
RefPtr
<
DBusMessage
>
message
=
already_AddRefed
<
DBusMessage
>
(
dbus_message_new_method_call
(
FREEDESKTOP_SCREENSAVER_TARGET
FREEDESKTOP_SCREENSAVER_OBJECT
FREEDESKTOP_SCREENSAVER_INTERFACE
"
Inhibit
"
)
)
;
if
(
!
message
)
{
return
false
;
}
const
char
*
app
=
g_get_prgname
(
)
;
const
char
*
topic
=
mTopic
.
get
(
)
;
dbus_message_append_args
(
message
DBUS_TYPE_STRING
&
app
DBUS_TYPE_STRING
&
topic
DBUS_TYPE_INVALID
)
;
return
SendMessage
(
message
)
;
}
bool
WakeLockTopic
:
:
SendGNOMEInhibitMessage
(
)
{
RefPtr
<
DBusMessage
>
message
=
already_AddRefed
<
DBusMessage
>
(
dbus_message_new_method_call
(
SESSION_MANAGER_TARGET
SESSION_MANAGER_OBJECT
SESSION_MANAGER_INTERFACE
"
Inhibit
"
)
)
;
if
(
!
message
)
{
return
false
;
}
static
const
uint32_t
xid
=
0
;
static
const
uint32_t
flags
=
(
1
<
<
3
)
;
const
char
*
app
=
g_get_prgname
(
)
;
const
char
*
topic
=
mTopic
.
get
(
)
;
dbus_message_append_args
(
message
DBUS_TYPE_STRING
&
app
DBUS_TYPE_UINT32
&
xid
DBUS_TYPE_STRING
&
topic
DBUS_TYPE_UINT32
&
flags
DBUS_TYPE_INVALID
)
;
return
SendMessage
(
message
)
;
}
#
if
defined
(
MOZ_X11
)
typedef
Bool
(
*
_XScreenSaverQueryExtension_fn
)
(
Display
*
dpy
int
*
event_base
int
*
error_base
)
;
typedef
Bool
(
*
_XScreenSaverQueryVersion_fn
)
(
Display
*
dpy
int
*
major
int
*
minor
)
;
typedef
void
(
*
_XScreenSaverSuspend_fn
)
(
Display
*
dpy
Bool
suspend
)
;
static
PRLibrary
*
sXssLib
=
nullptr
;
static
_XScreenSaverQueryExtension_fn
_XSSQueryExtension
=
nullptr
;
static
_XScreenSaverQueryVersion_fn
_XSSQueryVersion
=
nullptr
;
static
_XScreenSaverSuspend_fn
_XSSSuspend
=
nullptr
;
bool
WakeLockTopic
:
:
CheckXScreenSaverSupport
(
)
{
if
(
!
sXssLib
)
{
sXssLib
=
PR_LoadLibrary
(
"
libXss
.
so
.
1
"
)
;
if
(
!
sXssLib
)
{
return
false
;
}
}
_XSSQueryExtension
=
(
_XScreenSaverQueryExtension_fn
)
PR_FindFunctionSymbol
(
sXssLib
"
XScreenSaverQueryExtension
"
)
;
_XSSQueryVersion
=
(
_XScreenSaverQueryVersion_fn
)
PR_FindFunctionSymbol
(
sXssLib
"
XScreenSaverQueryVersion
"
)
;
_XSSSuspend
=
(
_XScreenSaverSuspend_fn
)
PR_FindFunctionSymbol
(
sXssLib
"
XScreenSaverSuspend
"
)
;
if
(
!
_XSSQueryExtension
|
|
!
_XSSQueryVersion
|
|
!
_XSSSuspend
)
{
return
false
;
}
GdkDisplay
*
gDisplay
=
gdk_display_get_default
(
)
;
if
(
!
gDisplay
|
|
!
GDK_IS_X11_DISPLAY
(
gDisplay
)
)
{
return
false
;
}
Display
*
display
=
GDK_DISPLAY_XDISPLAY
(
gDisplay
)
;
int
throwaway
;
if
(
!
_XSSQueryExtension
(
display
&
throwaway
&
throwaway
)
)
return
false
;
int
major
minor
;
if
(
!
_XSSQueryVersion
(
display
&
major
&
minor
)
)
return
false
;
if
(
major
!
=
1
)
return
false
;
if
(
minor
<
1
)
return
false
;
return
true
;
}
bool
WakeLockTopic
:
:
InhibitXScreenSaver
(
bool
inhibit
)
{
if
(
!
_XSSSuspend
)
{
return
false
;
}
GdkDisplay
*
gDisplay
=
gdk_display_get_default
(
)
;
if
(
!
gDisplay
|
|
!
GDK_IS_X11_DISPLAY
(
gDisplay
)
)
{
return
false
;
}
Display
*
display
=
GDK_DISPLAY_XDISPLAY
(
gDisplay
)
;
_XSSSuspend
(
display
inhibit
)
;
return
true
;
}
#
endif
#
if
defined
(
MOZ_WAYLAND
)
bool
WakeLockTopic
:
:
CheckWaylandIdleInhibitSupport
(
)
{
RefPtr
<
nsWaylandDisplay
>
waylandDisplay
=
WaylandDisplayGet
(
)
;
return
waylandDisplay
&
&
waylandDisplay
-
>
GetIdleInhibitManager
(
)
!
=
nullptr
;
}
bool
WakeLockTopic
:
:
InhibitWaylandIdle
(
)
{
RefPtr
<
nsWaylandDisplay
>
waylandDisplay
=
WaylandDisplayGet
(
)
;
if
(
!
waylandDisplay
)
{
return
false
;
}
nsWindow
*
focusedWindow
=
nsWindow
:
:
GetFocusedWindow
(
)
;
if
(
!
focusedWindow
)
{
return
false
;
}
UninhibitWaylandIdle
(
)
;
MozContainer
*
container
=
focusedWindow
-
>
GetMozContainer
(
)
;
wl_surface
*
waylandSurface
=
moz_container_wayland_surface_lock
(
container
)
;
if
(
waylandSurface
)
{
mWaylandInhibitor
=
zwp_idle_inhibit_manager_v1_create_inhibitor
(
waylandDisplay
-
>
GetIdleInhibitManager
(
)
waylandSurface
)
;
moz_container_wayland_surface_unlock
(
container
&
waylandSurface
)
;
}
return
true
;
}
bool
WakeLockTopic
:
:
UninhibitWaylandIdle
(
)
{
if
(
mWaylandInhibitor
=
=
nullptr
)
return
false
;
zwp_idle_inhibitor_v1_destroy
(
mWaylandInhibitor
)
;
mWaylandInhibitor
=
nullptr
;
return
true
;
}
#
endif
bool
WakeLockTopic
:
:
SendInhibit
(
)
{
bool
sendOk
=
false
;
switch
(
mDesktopEnvironment
)
{
case
FreeDesktop
:
sendOk
=
SendFreeDesktopInhibitMessage
(
)
;
break
;
case
GNOME
:
sendOk
=
SendGNOMEInhibitMessage
(
)
;
break
;
#
if
defined
(
MOZ_X11
)
case
XScreenSaver
:
return
InhibitXScreenSaver
(
true
)
;
#
endif
#
if
defined
(
MOZ_WAYLAND
)
case
WaylandIdleInhibit
:
return
InhibitWaylandIdle
(
)
;
#
endif
case
Unsupported
:
return
false
;
}
if
(
sendOk
)
{
mWaitingForReply
=
true
;
}
return
sendOk
;
}
bool
WakeLockTopic
:
:
SendUninhibit
(
)
{
RefPtr
<
DBusMessage
>
message
;
if
(
mDesktopEnvironment
=
=
FreeDesktop
)
{
message
=
already_AddRefed
<
DBusMessage
>
(
dbus_message_new_method_call
(
FREEDESKTOP_SCREENSAVER_TARGET
FREEDESKTOP_SCREENSAVER_OBJECT
FREEDESKTOP_SCREENSAVER_INTERFACE
"
UnInhibit
"
)
)
;
}
else
if
(
mDesktopEnvironment
=
=
GNOME
)
{
message
=
already_AddRefed
<
DBusMessage
>
(
dbus_message_new_method_call
(
SESSION_MANAGER_TARGET
SESSION_MANAGER_OBJECT
SESSION_MANAGER_INTERFACE
"
Uninhibit
"
)
)
;
}
#
if
defined
(
MOZ_X11
)
else
if
(
mDesktopEnvironment
=
=
XScreenSaver
)
{
return
InhibitXScreenSaver
(
false
)
;
}
#
endif
#
if
defined
(
MOZ_WAYLAND
)
else
if
(
mDesktopEnvironment
=
=
WaylandIdleInhibit
)
{
return
UninhibitWaylandIdle
(
)
;
}
#
endif
if
(
!
message
)
{
return
false
;
}
dbus_message_append_args
(
message
DBUS_TYPE_UINT32
&
mInhibitRequest
DBUS_TYPE_INVALID
)
;
dbus_connection_send
(
mConnection
message
nullptr
)
;
dbus_connection_flush
(
mConnection
)
;
mInhibitRequest
=
0
;
return
true
;
}
nsresult
WakeLockTopic
:
:
InhibitScreensaver
(
)
{
if
(
mShouldInhibit
)
{
return
NS_OK
;
}
mShouldInhibit
=
true
;
if
(
mWaitingForReply
)
{
return
NS_OK
;
}
return
SendInhibit
(
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
WakeLockTopic
:
:
UninhibitScreensaver
(
)
{
if
(
!
mShouldInhibit
)
{
return
NS_OK
;
}
mShouldInhibit
=
false
;
if
(
mWaitingForReply
)
{
return
NS_OK
;
}
return
SendUninhibit
(
)
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
WakeLockTopic
:
:
InhibitFailed
(
)
{
mWaitingForReply
=
false
;
if
(
mDesktopEnvironment
=
=
FreeDesktop
)
{
mDesktopEnvironment
=
GNOME
;
#
if
defined
(
MOZ_X11
)
}
else
if
(
mDesktopEnvironment
=
=
GNOME
&
&
CheckXScreenSaverSupport
(
)
)
{
mDesktopEnvironment
=
XScreenSaver
;
#
endif
#
if
defined
(
MOZ_WAYLAND
)
}
else
if
(
mDesktopEnvironment
=
=
GNOME
&
&
CheckWaylandIdleInhibitSupport
(
)
)
{
mDesktopEnvironment
=
WaylandIdleInhibit
;
#
endif
}
else
{
mDesktopEnvironment
=
Unsupported
;
mShouldInhibit
=
false
;
}
if
(
!
mShouldInhibit
)
{
return
;
}
SendInhibit
(
)
;
}
void
WakeLockTopic
:
:
InhibitSucceeded
(
uint32_t
aInhibitRequest
)
{
mWaitingForReply
=
false
;
mInhibitRequest
=
aInhibitRequest
;
if
(
!
mShouldInhibit
)
{
SendUninhibit
(
)
;
}
}
void
WakeLockTopic
:
:
ReceiveInhibitReply
(
DBusPendingCall
*
pending
void
*
user_data
)
{
if
(
!
WakeLockListener
:
:
GetSingleton
(
false
)
)
{
return
;
}
WakeLockTopic
*
self
=
static_cast
<
WakeLockTopic
*
>
(
user_data
)
;
RefPtr
<
DBusMessage
>
msg
=
already_AddRefed
<
DBusMessage
>
(
dbus_pending_call_steal_reply
(
pending
)
)
;
if
(
!
msg
)
{
return
;
}
if
(
dbus_message_get_type
(
msg
)
=
=
DBUS_MESSAGE_TYPE_METHOD_RETURN
)
{
uint32_t
inhibitRequest
;
if
(
dbus_message_get_args
(
msg
nullptr
DBUS_TYPE_UINT32
&
inhibitRequest
DBUS_TYPE_INVALID
)
)
{
self
-
>
InhibitSucceeded
(
inhibitRequest
)
;
}
}
else
{
self
-
>
InhibitFailed
(
)
;
}
}
WakeLockListener
:
:
WakeLockListener
(
)
:
mConnection
(
nullptr
)
{
}
WakeLockListener
*
WakeLockListener
:
:
GetSingleton
(
bool
aCreate
)
{
if
(
!
sSingleton
&
&
aCreate
)
{
sSingleton
=
new
WakeLockListener
(
)
;
}
return
sSingleton
;
}
void
WakeLockListener
:
:
Shutdown
(
)
{
sSingleton
=
nullptr
;
}
bool
WakeLockListener
:
:
EnsureDBusConnection
(
)
{
if
(
!
mConnection
)
{
mConnection
=
already_AddRefed
<
DBusConnection
>
(
dbus_bus_get
(
DBUS_BUS_SESSION
nullptr
)
)
;
if
(
mConnection
)
{
dbus_connection_set_exit_on_disconnect
(
mConnection
false
)
;
dbus_connection_setup_with_g_main
(
mConnection
nullptr
)
;
}
}
return
mConnection
!
=
nullptr
;
}
nsresult
WakeLockListener
:
:
Callback
(
const
nsAString
&
topic
const
nsAString
&
state
)
{
if
(
!
EnsureDBusConnection
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
topic
.
Equals
(
u
"
screen
"
_ns
)
&
&
!
topic
.
Equals
(
u
"
audio
-
playing
"
_ns
)
&
&
!
topic
.
Equals
(
u
"
video
-
playing
"
_ns
)
)
return
NS_OK
;
WakeLockTopic
*
const
topicLock
=
mTopics
.
GetOrInsertNew
(
topic
topic
mConnection
)
;
bool
shouldLock
=
state
.
EqualsLiteral
(
"
locked
-
foreground
"
)
;
WAKE_LOCK_LOG
(
"
topic
=
%
s
shouldLock
=
%
d
"
NS_ConvertUTF16toUTF8
(
topic
)
.
get
(
)
shouldLock
)
;
return
shouldLock
?
topicLock
-
>
InhibitScreensaver
(
)
:
topicLock
-
>
UninhibitScreensaver
(
)
;
}
#
endif
