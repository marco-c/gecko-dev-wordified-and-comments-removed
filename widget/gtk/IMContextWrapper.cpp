#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prtime
.
h
"
#
include
"
IMContextWrapper
.
h
"
#
include
"
nsGtkKeyUtils
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_intl
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
mozilla
:
:
LazyLogModule
gIMELog
(
"
IMEHandler
"
)
;
namespace
mozilla
{
namespace
widget
{
static
inline
const
char
*
ToChar
(
bool
aBool
)
{
return
aBool
?
"
true
"
:
"
false
"
;
}
static
const
char
*
GetEventType
(
GdkEventKey
*
aKeyEvent
)
{
switch
(
aKeyEvent
-
>
type
)
{
case
GDK_KEY_PRESS
:
return
"
GDK_KEY_PRESS
"
;
case
GDK_KEY_RELEASE
:
return
"
GDK_KEY_RELEASE
"
;
default
:
return
"
Unknown
"
;
}
}
class
GetEventStateName
:
public
nsAutoCString
{
public
:
explicit
GetEventStateName
(
guint
aState
IMContextWrapper
:
:
IMContextID
aIMContextID
=
IMContextWrapper
:
:
IMContextID
:
:
Unknown
)
{
if
(
aState
&
GDK_SHIFT_MASK
)
{
AppendModifier
(
"
shift
"
)
;
}
if
(
aState
&
GDK_CONTROL_MASK
)
{
AppendModifier
(
"
control
"
)
;
}
if
(
aState
&
GDK_MOD1_MASK
)
{
AppendModifier
(
"
mod1
"
)
;
}
if
(
aState
&
GDK_MOD2_MASK
)
{
AppendModifier
(
"
mod2
"
)
;
}
if
(
aState
&
GDK_MOD3_MASK
)
{
AppendModifier
(
"
mod3
"
)
;
}
if
(
aState
&
GDK_MOD4_MASK
)
{
AppendModifier
(
"
mod4
"
)
;
}
if
(
aState
&
GDK_MOD4_MASK
)
{
AppendModifier
(
"
mod5
"
)
;
}
if
(
aState
&
GDK_MOD4_MASK
)
{
AppendModifier
(
"
mod5
"
)
;
}
switch
(
aIMContextID
)
{
case
IMContextWrapper
:
:
IMContextID
:
:
IBus
:
static
const
guint
IBUS_HANDLED_MASK
=
1
<
<
24
;
static
const
guint
IBUS_IGNORED_MASK
=
1
<
<
25
;
if
(
aState
&
IBUS_HANDLED_MASK
)
{
AppendModifier
(
"
IBUS_HANDLED_MASK
"
)
;
}
if
(
aState
&
IBUS_IGNORED_MASK
)
{
AppendModifier
(
"
IBUS_IGNORED_MASK
"
)
;
}
break
;
case
IMContextWrapper
:
:
IMContextID
:
:
Fcitx
:
case
IMContextWrapper
:
:
IMContextID
:
:
Fcitx5
:
static
const
guint
FcitxKeyState_HandledMask
=
1
<
<
24
;
static
const
guint
FcitxKeyState_IgnoredMask
=
1
<
<
25
;
if
(
aState
&
FcitxKeyState_HandledMask
)
{
AppendModifier
(
"
FcitxKeyState_HandledMask
"
)
;
}
if
(
aState
&
FcitxKeyState_IgnoredMask
)
{
AppendModifier
(
"
FcitxKeyState_IgnoredMask
"
)
;
}
break
;
default
:
break
;
}
}
private
:
void
AppendModifier
(
const
char
*
aModifierName
)
{
if
(
!
IsEmpty
(
)
)
{
AppendLiteral
(
"
+
"
)
;
}
Append
(
aModifierName
)
;
}
}
;
class
GetTextRangeStyleText
final
:
public
nsAutoCString
{
public
:
explicit
GetTextRangeStyleText
(
const
TextRangeStyle
&
aStyle
)
{
if
(
!
aStyle
.
IsDefined
(
)
)
{
AssignLiteral
(
"
{
IsDefined
(
)
=
false
}
"
)
;
return
;
}
if
(
aStyle
.
IsLineStyleDefined
(
)
)
{
AppendLiteral
(
"
{
mLineStyle
=
"
)
;
AppendLineStyle
(
aStyle
.
mLineStyle
)
;
if
(
aStyle
.
IsUnderlineColorDefined
(
)
)
{
AppendLiteral
(
"
mUnderlineColor
=
"
)
;
AppendColor
(
aStyle
.
mUnderlineColor
)
;
}
else
{
AppendLiteral
(
"
IsUnderlineColorDefined
=
false
"
)
;
}
}
else
{
AppendLiteral
(
"
{
IsLineStyleDefined
(
)
=
false
"
)
;
}
if
(
aStyle
.
IsForegroundColorDefined
(
)
)
{
AppendLiteral
(
"
mForegroundColor
=
"
)
;
AppendColor
(
aStyle
.
mForegroundColor
)
;
}
else
{
AppendLiteral
(
"
IsForegroundColorDefined
(
)
=
false
"
)
;
}
if
(
aStyle
.
IsBackgroundColorDefined
(
)
)
{
AppendLiteral
(
"
mBackgroundColor
=
"
)
;
AppendColor
(
aStyle
.
mBackgroundColor
)
;
}
else
{
AppendLiteral
(
"
IsBackgroundColorDefined
(
)
=
false
"
)
;
}
AppendLiteral
(
"
}
"
)
;
}
void
AppendLineStyle
(
TextRangeStyle
:
:
LineStyle
aLineStyle
)
{
switch
(
aLineStyle
)
{
case
TextRangeStyle
:
:
LineStyle
:
:
None
:
AppendLiteral
(
"
LineStyle
:
:
None
"
)
;
break
;
case
TextRangeStyle
:
:
LineStyle
:
:
Solid
:
AppendLiteral
(
"
LineStyle
:
:
Solid
"
)
;
break
;
case
TextRangeStyle
:
:
LineStyle
:
:
Dotted
:
AppendLiteral
(
"
LineStyle
:
:
Dotted
"
)
;
break
;
case
TextRangeStyle
:
:
LineStyle
:
:
Dashed
:
AppendLiteral
(
"
LineStyle
:
:
Dashed
"
)
;
break
;
case
TextRangeStyle
:
:
LineStyle
:
:
Double
:
AppendLiteral
(
"
LineStyle
:
:
Double
"
)
;
break
;
case
TextRangeStyle
:
:
LineStyle
:
:
Wavy
:
AppendLiteral
(
"
LineStyle
:
:
Wavy
"
)
;
break
;
default
:
AppendPrintf
(
"
Invalid
(
0x
%
02X
)
"
static_cast
<
TextRangeStyle
:
:
LineStyleType
>
(
aLineStyle
)
)
;
break
;
}
}
void
AppendColor
(
nscolor
aColor
)
{
AppendPrintf
(
"
{
R
=
0x
%
02X
G
=
0x
%
02X
B
=
0x
%
02X
A
=
0x
%
02X
}
"
NS_GET_R
(
aColor
)
NS_GET_G
(
aColor
)
NS_GET_B
(
aColor
)
NS_GET_A
(
aColor
)
)
;
}
virtual
~
GetTextRangeStyleText
(
)
=
default
;
}
;
const
static
bool
kUseSimpleContextDefault
=
false
;
static
Maybe
<
nscolor
>
GetSystemColor
(
LookAndFeel
:
:
ColorID
aId
)
{
return
LookAndFeel
:
:
GetColor
(
aId
LookAndFeel
:
:
ColorScheme
:
:
Light
LookAndFeel
:
:
UseStandins
:
:
No
)
;
}
class
SelectionStyleProvider
final
{
public
:
static
SelectionStyleProvider
*
GetExistingInstance
(
)
{
return
sInstance
;
}
static
SelectionStyleProvider
*
GetInstance
(
)
{
if
(
sHasShutDown
)
{
return
nullptr
;
}
if
(
!
sInstance
)
{
sInstance
=
new
SelectionStyleProvider
(
)
;
}
return
sInstance
;
}
static
void
Shutdown
(
)
{
if
(
sInstance
)
{
g_object_unref
(
sInstance
-
>
mProvider
)
;
}
delete
sInstance
;
sInstance
=
nullptr
;
sHasShutDown
=
true
;
}
void
AttachTo
(
GdkWindow
*
aGDKWindow
)
{
GtkWidget
*
widget
=
nullptr
;
gdk_window_get_user_data
(
aGDKWindow
(
gpointer
*
)
&
widget
)
;
if
(
GTK_IS_WIDGET
(
widget
)
)
{
gtk_style_context_add_provider
(
gtk_widget_get_style_context
(
widget
)
GTK_STYLE_PROVIDER
(
mProvider
)
GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
)
;
}
}
void
OnThemeChanged
(
)
{
nsAutoCString
style
(
"
:
selected
{
"
)
;
if
(
auto
selectionForegroundColor
=
GetSystemColor
(
LookAndFeel
:
:
ColorID
:
:
Highlight
)
)
{
double
alpha
=
static_cast
<
double
>
(
NS_GET_A
(
*
selectionForegroundColor
)
)
/
0xFF
;
style
.
AppendPrintf
(
"
color
:
rgba
(
%
u
%
u
%
u
"
NS_GET_R
(
*
selectionForegroundColor
)
NS_GET_G
(
*
selectionForegroundColor
)
NS_GET_B
(
*
selectionForegroundColor
)
)
;
style
.
AppendFloat
(
alpha
)
;
style
.
AppendPrintf
(
"
)
;
"
)
;
}
if
(
auto
selectionBackgroundColor
=
GetSystemColor
(
LookAndFeel
:
:
ColorID
:
:
Highlighttext
)
)
{
double
alpha
=
static_cast
<
double
>
(
NS_GET_A
(
*
selectionBackgroundColor
)
)
/
0xFF
;
style
.
AppendPrintf
(
"
background
-
color
:
rgba
(
%
u
%
u
%
u
"
NS_GET_R
(
*
selectionBackgroundColor
)
NS_GET_G
(
*
selectionBackgroundColor
)
NS_GET_B
(
*
selectionBackgroundColor
)
)
;
style
.
AppendFloat
(
alpha
)
;
style
.
AppendPrintf
(
"
)
;
"
)
;
}
style
.
AppendLiteral
(
"
}
"
)
;
gtk_css_provider_load_from_data
(
mProvider
style
.
get
(
)
-
1
nullptr
)
;
}
private
:
static
SelectionStyleProvider
*
sInstance
;
static
bool
sHasShutDown
;
GtkCssProvider
*
const
mProvider
;
SelectionStyleProvider
(
)
:
mProvider
(
gtk_css_provider_new
(
)
)
{
OnThemeChanged
(
)
;
}
}
;
SelectionStyleProvider
*
SelectionStyleProvider
:
:
sInstance
=
nullptr
;
bool
SelectionStyleProvider
:
:
sHasShutDown
=
false
;
IMContextWrapper
*
IMContextWrapper
:
:
sLastFocusedContext
=
nullptr
;
guint16
IMContextWrapper
:
:
sWaitingSynthesizedKeyPressHardwareKeyCode
=
0
;
bool
IMContextWrapper
:
:
sUseSimpleContext
;
NS_IMPL_ISUPPORTS
(
IMContextWrapper
TextEventDispatcherListener
nsISupportsWeakReference
)
IMContextWrapper
:
:
IMContextWrapper
(
nsWindow
*
aOwnerWindow
)
:
mOwnerWindow
(
aOwnerWindow
)
mLastFocusedWindow
(
nullptr
)
mContext
(
nullptr
)
mSimpleContext
(
nullptr
)
mDummyContext
(
nullptr
)
mComposingContext
(
nullptr
)
mCompositionStart
(
UINT32_MAX
)
mProcessingKeyEvent
(
nullptr
)
mCompositionState
(
eCompositionState_NotComposing
)
mIMContextID
(
IMContextID
:
:
Unknown
)
mIsIMFocused
(
false
)
mFallbackToKeyEvent
(
false
)
mKeyboardEventWasDispatched
(
false
)
mKeyboardEventWasConsumed
(
false
)
mIsDeletingSurrounding
(
false
)
mLayoutChanged
(
false
)
mSetCursorPositionOnKeyEvent
(
true
)
mPendingResettingIMContext
(
false
)
mRetrieveSurroundingSignalReceived
(
false
)
mMaybeInDeadKeySequence
(
false
)
mIsIMInAsyncKeyHandlingMode
(
false
)
{
static
bool
sFirstInstance
=
true
;
if
(
sFirstInstance
)
{
sFirstInstance
=
false
;
sUseSimpleContext
=
Preferences
:
:
GetBool
(
"
intl
.
ime
.
use_simple_context_on_password_field
"
kUseSimpleContextDefault
)
;
}
Init
(
)
;
}
static
bool
IsIBusInSyncMode
(
)
{
const
char
*
env
=
PR_GetEnv
(
"
IBUS_ENABLE_SYNC_MODE
"
)
;
if
(
!
env
)
{
return
false
;
}
nsDependentCString
envStr
(
env
)
;
if
(
envStr
.
IsEmpty
(
)
|
|
envStr
.
EqualsLiteral
(
"
0
"
)
|
|
envStr
.
EqualsLiteral
(
"
false
"
)
|
|
envStr
.
EqualsLiteral
(
"
False
"
)
|
|
envStr
.
EqualsLiteral
(
"
FALSE
"
)
)
{
return
false
;
}
return
true
;
}
static
bool
GetFcitxBoolEnv
(
const
char
*
aEnv
)
{
const
char
*
env
=
PR_GetEnv
(
aEnv
)
;
if
(
!
env
)
{
return
false
;
}
nsDependentCString
envStr
(
env
)
;
if
(
envStr
.
IsEmpty
(
)
|
|
envStr
.
EqualsLiteral
(
"
0
"
)
|
|
envStr
.
EqualsLiteral
(
"
false
"
)
)
{
return
false
;
}
return
true
;
}
static
bool
IsFcitxInSyncMode
(
)
{
return
GetFcitxBoolEnv
(
"
IBUS_ENABLE_SYNC_MODE
"
)
|
|
GetFcitxBoolEnv
(
"
FCITX_ENABLE_SYNC_MODE
"
)
;
}
nsDependentCSubstring
IMContextWrapper
:
:
GetIMName
(
)
const
{
const
char
*
contextIDChar
=
gtk_im_multicontext_get_context_id
(
GTK_IM_MULTICONTEXT
(
mContext
)
)
;
if
(
!
contextIDChar
)
{
return
nsDependentCSubstring
(
)
;
}
nsDependentCSubstring
im
(
contextIDChar
strlen
(
contextIDChar
)
)
;
const
char
*
xmodifiersChar
=
PR_GetEnv
(
"
XMODIFIERS
"
)
;
if
(
!
xmodifiersChar
|
|
!
im
.
EqualsLiteral
(
"
xim
"
)
)
{
return
im
;
}
nsDependentCString
xmodifiers
(
xmodifiersChar
)
;
int32_t
atIMValueStart
=
xmodifiers
.
Find
(
"
im
=
"
)
+
4
;
if
(
atIMValueStart
<
4
|
|
xmodifiers
.
Length
(
)
<
=
static_cast
<
size_t
>
(
atIMValueStart
)
)
{
return
im
;
}
int32_t
atIMValueEnd
=
xmodifiers
.
Find
(
"
"
false
atIMValueStart
)
;
if
(
atIMValueEnd
>
atIMValueStart
)
{
return
nsDependentCSubstring
(
xmodifiersChar
+
atIMValueStart
atIMValueEnd
-
atIMValueStart
)
;
}
if
(
atIMValueEnd
=
=
kNotFound
)
{
return
nsDependentCSubstring
(
xmodifiersChar
+
atIMValueStart
strlen
(
xmodifiersChar
)
-
atIMValueStart
)
;
}
return
im
;
}
void
IMContextWrapper
:
:
Init
(
)
{
MozContainer
*
container
=
mOwnerWindow
-
>
GetMozContainer
(
)
;
MOZ_ASSERT
(
container
"
container
is
null
"
)
;
GdkWindow
*
gdkWindow
=
gtk_widget_get_window
(
GTK_WIDGET
(
container
)
)
;
SelectionStyleProvider
:
:
GetInstance
(
)
-
>
AttachTo
(
gdkWindow
)
;
mContext
=
gtk_im_multicontext_new
(
)
;
gtk_im_context_set_client_window
(
mContext
gdkWindow
)
;
g_signal_connect
(
mContext
"
preedit_changed
"
G_CALLBACK
(
IMContextWrapper
:
:
OnChangeCompositionCallback
)
this
)
;
g_signal_connect
(
mContext
"
retrieve_surrounding
"
G_CALLBACK
(
IMContextWrapper
:
:
OnRetrieveSurroundingCallback
)
this
)
;
g_signal_connect
(
mContext
"
delete_surrounding
"
G_CALLBACK
(
IMContextWrapper
:
:
OnDeleteSurroundingCallback
)
this
)
;
g_signal_connect
(
mContext
"
commit
"
G_CALLBACK
(
IMContextWrapper
:
:
OnCommitCompositionCallback
)
this
)
;
g_signal_connect
(
mContext
"
preedit_start
"
G_CALLBACK
(
IMContextWrapper
:
:
OnStartCompositionCallback
)
this
)
;
g_signal_connect
(
mContext
"
preedit_end
"
G_CALLBACK
(
IMContextWrapper
:
:
OnEndCompositionCallback
)
this
)
;
nsDependentCSubstring
im
=
GetIMName
(
)
;
if
(
im
.
EqualsLiteral
(
"
ibus
"
)
)
{
mIMContextID
=
IMContextID
:
:
IBus
;
mIsIMInAsyncKeyHandlingMode
=
!
IsIBusInSyncMode
(
)
;
mIsKeySnooped
=
false
;
}
else
if
(
im
.
EqualsLiteral
(
"
fcitx
"
)
)
{
mIMContextID
=
IMContextID
:
:
Fcitx
;
mIsIMInAsyncKeyHandlingMode
=
!
IsFcitxInSyncMode
(
)
;
mIsKeySnooped
=
false
;
}
else
if
(
im
.
EqualsLiteral
(
"
fcitx5
"
)
)
{
mIMContextID
=
IMContextID
:
:
Fcitx5
;
mIsIMInAsyncKeyHandlingMode
=
true
;
mIsKeySnooped
=
false
;
}
else
if
(
im
.
EqualsLiteral
(
"
uim
"
)
)
{
mIMContextID
=
IMContextID
:
:
Uim
;
mIsIMInAsyncKeyHandlingMode
=
false
;
mIsKeySnooped
=
Preferences
:
:
GetBool
(
"
intl
.
ime
.
hack
.
uim
.
using_key_snooper
"
true
)
;
}
else
if
(
im
.
EqualsLiteral
(
"
scim
"
)
)
{
mIMContextID
=
IMContextID
:
:
Scim
;
mIsIMInAsyncKeyHandlingMode
=
false
;
mIsKeySnooped
=
false
;
}
else
if
(
im
.
EqualsLiteral
(
"
iiim
"
)
)
{
mIMContextID
=
IMContextID
:
:
IIIMF
;
mIsIMInAsyncKeyHandlingMode
=
false
;
mIsKeySnooped
=
false
;
}
else
if
(
im
.
EqualsLiteral
(
"
wayland
"
)
)
{
mIMContextID
=
IMContextID
:
:
Wayland
;
mIsIMInAsyncKeyHandlingMode
=
false
;
mIsKeySnooped
=
true
;
}
else
{
mIMContextID
=
IMContextID
:
:
Unknown
;
mIsIMInAsyncKeyHandlingMode
=
false
;
mIsKeySnooped
=
false
;
}
if
(
sUseSimpleContext
)
{
mSimpleContext
=
gtk_im_context_simple_new
(
)
;
gtk_im_context_set_client_window
(
mSimpleContext
gdkWindow
)
;
g_signal_connect
(
mSimpleContext
"
preedit_changed
"
G_CALLBACK
(
&
IMContextWrapper
:
:
OnChangeCompositionCallback
)
this
)
;
g_signal_connect
(
mSimpleContext
"
retrieve_surrounding
"
G_CALLBACK
(
&
IMContextWrapper
:
:
OnRetrieveSurroundingCallback
)
this
)
;
g_signal_connect
(
mSimpleContext
"
delete_surrounding
"
G_CALLBACK
(
&
IMContextWrapper
:
:
OnDeleteSurroundingCallback
)
this
)
;
g_signal_connect
(
mSimpleContext
"
commit
"
G_CALLBACK
(
&
IMContextWrapper
:
:
OnCommitCompositionCallback
)
this
)
;
g_signal_connect
(
mSimpleContext
"
preedit_start
"
G_CALLBACK
(
IMContextWrapper
:
:
OnStartCompositionCallback
)
this
)
;
g_signal_connect
(
mSimpleContext
"
preedit_end
"
G_CALLBACK
(
IMContextWrapper
:
:
OnEndCompositionCallback
)
this
)
;
}
mDummyContext
=
gtk_im_multicontext_new
(
)
;
gtk_im_context_set_client_window
(
mDummyContext
gdkWindow
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
Init
(
)
mOwnerWindow
=
%
p
mContext
=
%
p
(
im
=
\
"
%
s
\
"
)
"
"
mIsIMInAsyncKeyHandlingMode
=
%
s
mIsKeySnooped
=
%
s
"
"
mSimpleContext
=
%
p
mDummyContext
=
%
p
"
"
gtk_im_multicontext_get_context_id
(
)
=
\
"
%
s
\
"
"
"
PR_GetEnv
(
\
"
XMODIFIERS
\
"
)
=
\
"
%
s
\
"
"
this
mOwnerWindow
mContext
nsAutoCString
(
im
)
.
get
(
)
ToChar
(
mIsIMInAsyncKeyHandlingMode
)
ToChar
(
mIsKeySnooped
)
mSimpleContext
mDummyContext
gtk_im_multicontext_get_context_id
(
GTK_IM_MULTICONTEXT
(
mContext
)
)
PR_GetEnv
(
"
XMODIFIERS
"
)
)
)
;
}
void
IMContextWrapper
:
:
Shutdown
(
)
{
SelectionStyleProvider
:
:
Shutdown
(
)
;
}
IMContextWrapper
:
:
~
IMContextWrapper
(
)
{
if
(
this
=
=
sLastFocusedContext
)
{
sLastFocusedContext
=
nullptr
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
~
IMContextWrapper
(
)
"
this
)
)
;
}
NS_IMETHODIMP
IMContextWrapper
:
:
NotifyIME
(
TextEventDispatcher
*
aTextEventDispatcher
const
IMENotification
&
aNotification
)
{
switch
(
aNotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
case
REQUEST_TO_CANCEL_COMPOSITION
:
{
nsWindow
*
window
=
static_cast
<
nsWindow
*
>
(
aTextEventDispatcher
-
>
GetWidget
(
)
)
;
return
EndIMEComposition
(
window
)
;
}
case
NOTIFY_IME_OF_FOCUS
:
OnFocusChangeInGecko
(
true
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_BLUR
:
OnFocusChangeInGecko
(
false
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
OnLayoutChange
(
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
OnUpdateComposition
(
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
{
nsWindow
*
window
=
static_cast
<
nsWindow
*
>
(
aTextEventDispatcher
-
>
GetWidget
(
)
)
;
OnSelectionChange
(
window
aNotification
)
;
return
NS_OK
;
}
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
NS_IMETHODIMP_
(
void
)
IMContextWrapper
:
:
OnRemovedFrom
(
TextEventDispatcher
*
aTextEventDispatcher
)
{
}
NS_IMETHODIMP_
(
void
)
IMContextWrapper
:
:
WillDispatchKeyboardEvent
(
TextEventDispatcher
*
aTextEventDispatcher
WidgetKeyboardEvent
&
aKeyboardEvent
uint32_t
aIndexOfKeypress
void
*
aData
)
{
KeymapWrapper
:
:
WillDispatchKeyboardEvent
(
aKeyboardEvent
static_cast
<
GdkEventKey
*
>
(
aData
)
)
;
}
TextEventDispatcher
*
IMContextWrapper
:
:
GetTextEventDispatcher
(
)
{
if
(
NS_WARN_IF
(
!
mLastFocusedWindow
)
)
{
return
nullptr
;
}
TextEventDispatcher
*
dispatcher
=
mLastFocusedWindow
-
>
GetTextEventDispatcher
(
)
;
MOZ_RELEASE_ASSERT
(
dispatcher
)
;
return
dispatcher
;
}
NS_IMETHODIMP_
(
IMENotificationRequests
)
IMContextWrapper
:
:
GetIMENotificationRequests
(
)
{
IMENotificationRequests
:
:
Notifications
notifications
=
IMENotificationRequests
:
:
NOTIFY_NOTHING
;
if
(
IsEnabled
(
)
)
{
notifications
|
=
IMENotificationRequests
:
:
NOTIFY_POSITION_CHANGE
;
}
return
IMENotificationRequests
(
notifications
)
;
}
void
IMContextWrapper
:
:
OnDestroyWindow
(
nsWindow
*
aWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnDestroyWindow
(
aWindow
=
0x
%
p
)
mLastFocusedWindow
=
0x
%
p
"
"
mOwnerWindow
=
0x
%
p
mLastFocusedModule
=
0x
%
p
"
this
aWindow
mLastFocusedWindow
mOwnerWindow
sLastFocusedContext
)
)
;
MOZ_ASSERT
(
aWindow
"
aWindow
must
not
be
null
"
)
;
if
(
mLastFocusedWindow
=
=
aWindow
)
{
EndIMEComposition
(
aWindow
)
;
if
(
mIsIMFocused
)
{
Blur
(
)
;
}
mLastFocusedWindow
=
nullptr
;
}
if
(
mOwnerWindow
!
=
aWindow
)
{
return
;
}
if
(
sLastFocusedContext
=
=
this
)
{
sLastFocusedContext
=
nullptr
;
}
if
(
mContext
)
{
PrepareToDestroyContext
(
mContext
)
;
gtk_im_context_set_client_window
(
mContext
nullptr
)
;
g_object_unref
(
mContext
)
;
mContext
=
nullptr
;
}
if
(
mSimpleContext
)
{
gtk_im_context_set_client_window
(
mSimpleContext
nullptr
)
;
g_object_unref
(
mSimpleContext
)
;
mSimpleContext
=
nullptr
;
}
if
(
mDummyContext
)
{
gtk_im_context_set_client_window
(
mDummyContext
nullptr
)
;
g_object_unref
(
mDummyContext
)
;
mDummyContext
=
nullptr
;
}
if
(
NS_WARN_IF
(
mComposingContext
)
)
{
g_object_unref
(
mComposingContext
)
;
mComposingContext
=
nullptr
;
}
mOwnerWindow
=
nullptr
;
mLastFocusedWindow
=
nullptr
;
mInputContext
.
mIMEState
.
mEnabled
=
IMEEnabled
:
:
Disabled
;
mPostingKeyEvents
.
Clear
(
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
OnDestroyWindow
(
)
succeeded
Completely
destroyed
"
this
)
)
;
}
void
IMContextWrapper
:
:
PrepareToDestroyContext
(
GtkIMContext
*
aContext
)
{
if
(
mIMContextID
=
=
IMContextID
:
:
IIIMF
)
{
static
gpointer
sGtkIIIMContextClass
=
nullptr
;
if
(
!
sGtkIIIMContextClass
)
{
GType
IIMContextType
=
g_type_from_name
(
"
GtkIMContextIIIM
"
)
;
if
(
IIMContextType
)
{
sGtkIIIMContextClass
=
g_type_class_ref
(
IIMContextType
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
PrepareToDestroyContext
(
)
added
to
reference
to
"
"
GtkIMContextIIIM
class
to
prevent
it
from
being
unloaded
"
this
)
)
;
}
else
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
PrepareToDestroyContext
(
)
FAILED
to
prevent
the
"
"
IIIM
module
from
being
uploaded
"
this
)
)
;
}
}
}
}
void
IMContextWrapper
:
:
OnFocusWindow
(
nsWindow
*
aWindow
)
{
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnFocusWindow
(
aWindow
=
0x
%
p
)
mLastFocusedWindow
=
0x
%
p
"
this
aWindow
mLastFocusedWindow
)
)
;
mLastFocusedWindow
=
aWindow
;
Focus
(
)
;
}
void
IMContextWrapper
:
:
OnBlurWindow
(
nsWindow
*
aWindow
)
{
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnBlurWindow
(
aWindow
=
0x
%
p
)
mLastFocusedWindow
=
0x
%
p
"
"
mIsIMFocused
=
%
s
"
this
aWindow
mLastFocusedWindow
ToChar
(
mIsIMFocused
)
)
)
;
if
(
!
mIsIMFocused
|
|
mLastFocusedWindow
!
=
aWindow
)
{
return
;
}
Blur
(
)
;
}
KeyHandlingState
IMContextWrapper
:
:
OnKeyEvent
(
nsWindow
*
aCaller
GdkEventKey
*
aEvent
bool
aKeyboardEventWasDispatched
)
{
MOZ_ASSERT
(
aEvent
"
aEvent
must
be
non
-
null
"
)
;
if
(
!
mInputContext
.
mIMEState
.
IsEditable
(
)
|
|
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
KeyHandlingState
:
:
eNotHandled
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
"
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
aCaller
=
0x
%
p
"
"
aEvent
(
0x
%
p
)
:
{
type
=
%
s
keyval
=
%
s
unicode
=
0x
%
X
state
=
%
s
"
"
time
=
%
u
hardware_keycode
=
%
u
group
=
%
u
}
"
"
aKeyboardEventWasDispatched
=
%
s
)
"
this
aCaller
aEvent
GetEventType
(
aEvent
)
gdk_keyval_name
(
aEvent
-
>
keyval
)
gdk_keyval_to_unicode
(
aEvent
-
>
keyval
)
GetEventStateName
(
aEvent
-
>
state
mIMContextID
)
.
get
(
)
aEvent
-
>
time
aEvent
-
>
hardware_keycode
aEvent
-
>
group
ToChar
(
aKeyboardEventWasDispatched
)
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
)
mMaybeInDeadKeySequence
=
%
s
"
"
mCompositionState
=
%
s
current
context
=
%
p
active
context
=
%
p
"
"
mIMContextID
=
%
s
mIsIMInAsyncKeyHandlingMode
=
%
s
"
this
ToChar
(
mMaybeInDeadKeySequence
)
GetCompositionStateName
(
)
GetCurrentContext
(
)
GetActiveContext
(
)
ToString
(
mIMContextID
)
.
c_str
(
)
ToChar
(
mIsIMInAsyncKeyHandlingMode
)
)
)
;
if
(
aCaller
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnKeyEvent
(
)
FAILED
the
caller
isn
'
t
focused
"
"
window
mLastFocusedWindow
=
0x
%
p
"
this
mLastFocusedWindow
)
)
;
return
KeyHandlingState
:
:
eNotHandled
;
}
GtkIMContext
*
currentContext
=
GetCurrentContext
(
)
;
if
(
MOZ_UNLIKELY
(
!
currentContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnKeyEvent
(
)
FAILED
there
are
no
context
"
this
)
)
;
return
KeyHandlingState
:
:
eNotHandled
;
}
if
(
mSetCursorPositionOnKeyEvent
)
{
SetCursorPosition
(
currentContext
)
;
mSetCursorPositionOnKeyEvent
=
false
;
}
bool
isDeadKey
=
KeymapWrapper
:
:
ComputeDOMKeyNameIndex
(
aEvent
)
=
=
KEY_NAME_INDEX_Dead
;
mMaybeInDeadKeySequence
|
=
isDeadKey
;
bool
probablyHandledAsynchronously
=
mIsIMInAsyncKeyHandlingMode
&
&
currentContext
=
=
mContext
;
bool
maybeHandledAsynchronously
=
false
;
bool
isHandlingAsyncEvent
=
false
;
bool
isUnexpectedAsyncEvent
=
false
;
if
(
probablyHandledAsynchronously
)
{
switch
(
mIMContextID
)
{
case
IMContextID
:
:
IBus
:
{
static
const
guint
IBUS_IGNORED_MASK
=
1
<
<
25
;
isHandlingAsyncEvent
=
!
!
(
aEvent
-
>
state
&
IBUS_IGNORED_MASK
)
;
if
(
!
isHandlingAsyncEvent
)
{
isHandlingAsyncEvent
=
mPostingKeyEvents
.
IndexOf
(
aEvent
)
!
=
GdkEventKeyQueue
:
:
NoIndex
(
)
;
if
(
isHandlingAsyncEvent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
)
aEvent
-
>
state
does
not
have
"
"
IBUS_IGNORED_MASK
but
"
"
same
event
in
the
queue
.
So
assuming
it
'
s
a
"
"
synthesized
event
"
this
)
)
;
}
}
if
(
isHandlingAsyncEvent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
)
aEvent
-
>
state
has
IBUS_IGNORED_MASK
"
"
or
aEvent
is
in
the
"
"
posting
event
queue
so
it
won
'
t
be
handled
"
"
asynchronously
anymore
.
Removing
"
"
the
posted
events
from
the
queue
"
this
)
)
;
probablyHandledAsynchronously
=
false
;
mPostingKeyEvents
.
RemoveEvent
(
aEvent
)
;
}
if
(
mMaybeInDeadKeySequence
&
&
aEvent
-
>
type
=
=
GDK_KEY_PRESS
)
{
probablyHandledAsynchronously
=
false
;
if
(
isHandlingAsyncEvent
)
{
isUnexpectedAsyncEvent
=
true
;
break
;
}
if
(
!
gdk_keyval_to_unicode
(
aEvent
-
>
keyval
)
&
&
!
aEvent
-
>
hardware_keycode
)
{
isUnexpectedAsyncEvent
=
true
;
break
;
}
break
;
}
if
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEEnabled
:
:
Password
)
{
probablyHandledAsynchronously
=
false
;
maybeHandledAsynchronously
=
!
isHandlingAsyncEvent
;
break
;
}
break
;
}
case
IMContextID
:
:
Fcitx
:
case
IMContextID
:
:
Fcitx5
:
{
static
const
guint
FcitxKeyState_IgnoredMask
=
1
<
<
25
;
isHandlingAsyncEvent
=
!
!
(
aEvent
-
>
state
&
FcitxKeyState_IgnoredMask
)
;
if
(
!
isHandlingAsyncEvent
)
{
isHandlingAsyncEvent
=
mPostingKeyEvents
.
IndexOf
(
aEvent
)
!
=
GdkEventKeyQueue
:
:
NoIndex
(
)
;
if
(
isHandlingAsyncEvent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
)
aEvent
-
>
state
does
not
have
"
"
FcitxKeyState_IgnoredMask
"
"
but
same
event
in
the
queue
.
So
assuming
it
'
s
a
"
"
synthesized
event
"
this
)
)
;
}
}
if
(
mMaybeInDeadKeySequence
&
&
aEvent
-
>
type
=
=
GDK_KEY_PRESS
)
{
probablyHandledAsynchronously
=
false
;
if
(
isHandlingAsyncEvent
)
{
isUnexpectedAsyncEvent
=
true
;
break
;
}
if
(
!
gdk_keyval_to_unicode
(
aEvent
-
>
keyval
)
&
&
!
aEvent
-
>
hardware_keycode
)
{
isUnexpectedAsyncEvent
=
true
;
break
;
}
}
if
(
isHandlingAsyncEvent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
)
aEvent
-
>
state
has
"
"
FcitxKeyState_IgnoredMask
or
aEvent
is
in
"
"
the
posting
event
queue
so
it
won
'
t
be
handled
"
"
asynchronously
anymore
.
"
"
Removing
the
posted
events
from
the
queue
"
this
)
)
;
probablyHandledAsynchronously
=
false
;
mPostingKeyEvents
.
RemoveEvent
(
aEvent
)
;
break
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
IME
may
handle
key
event
"
"
asyncrhonously
but
not
yet
confirmed
if
it
comes
agian
"
"
actually
"
)
;
}
}
if
(
!
isUnexpectedAsyncEvent
)
{
mKeyboardEventWasDispatched
=
aKeyboardEventWasDispatched
;
mKeyboardEventWasConsumed
=
false
;
}
else
{
mKeyboardEventWasDispatched
=
true
;
}
mFallbackToKeyEvent
=
false
;
mProcessingKeyEvent
=
aEvent
;
gboolean
isFiltered
=
gtk_im_context_filter_keypress
(
currentContext
aEvent
)
;
if
(
!
isHandlingAsyncEvent
&
&
maybeHandledAsynchronously
)
{
probablyHandledAsynchronously
|
=
isFiltered
&
&
!
mFallbackToKeyEvent
&
&
!
mKeyboardEventWasDispatched
;
}
if
(
aEvent
-
>
type
=
=
GDK_KEY_PRESS
)
{
if
(
isFiltered
&
&
probablyHandledAsynchronously
)
{
sWaitingSynthesizedKeyPressHardwareKeyCode
=
aEvent
-
>
hardware_keycode
;
}
else
{
sWaitingSynthesizedKeyPressHardwareKeyCode
=
0
;
}
}
bool
filterThisEvent
=
isFiltered
&
&
!
mFallbackToKeyEvent
;
if
(
IsComposingOnCurrentContext
(
)
&
&
!
isFiltered
&
&
aEvent
-
>
type
=
=
GDK_KEY_PRESS
&
&
mDispatchedCompositionString
.
IsEmpty
(
)
)
{
mProcessingKeyEvent
=
nullptr
;
DispatchCompositionCommitEvent
(
currentContext
&
EmptyString
(
)
)
;
mProcessingKeyEvent
=
aEvent
;
filterThisEvent
=
false
;
}
if
(
filterThisEvent
&
&
!
mKeyboardEventWasDispatched
)
{
if
(
!
probablyHandledAsynchronously
)
{
MaybeDispatchKeyEventAsProcessedByIME
(
eVoidEvent
)
;
}
else
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnKeyEvent
(
)
putting
aEvent
into
the
queue
.
.
.
"
this
)
)
;
mPostingKeyEvents
.
PutEvent
(
aEvent
)
;
}
}
mProcessingKeyEvent
=
nullptr
;
if
(
aEvent
-
>
type
=
=
GDK_KEY_PRESS
&
&
!
filterThisEvent
)
{
mMaybeInDeadKeySequence
=
false
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
OnKeyEvent
(
)
succeeded
filterThisEvent
=
%
s
"
"
(
isFiltered
=
%
s
mFallbackToKeyEvent
=
%
s
"
"
probablyHandledAsynchronously
=
%
s
maybeHandledAsynchronously
=
%
s
)
"
"
mPostingKeyEvents
.
Length
(
)
=
%
zu
mCompositionState
=
%
s
"
"
mMaybeInDeadKeySequence
=
%
s
mKeyboardEventWasDispatched
=
%
s
"
"
mKeyboardEventWasConsumed
=
%
s
"
this
ToChar
(
filterThisEvent
)
ToChar
(
isFiltered
)
ToChar
(
mFallbackToKeyEvent
)
ToChar
(
probablyHandledAsynchronously
)
ToChar
(
maybeHandledAsynchronously
)
mPostingKeyEvents
.
Length
(
)
GetCompositionStateName
(
)
ToChar
(
mMaybeInDeadKeySequence
)
ToChar
(
mKeyboardEventWasDispatched
)
ToChar
(
mKeyboardEventWasConsumed
)
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
<
\
n
\
n
"
)
)
;
if
(
filterThisEvent
)
{
return
KeyHandlingState
:
:
eHandled
;
}
if
(
aKeyboardEventWasDispatched
)
{
return
KeyHandlingState
:
:
eNotHandledButEventDispatched
;
}
if
(
!
mKeyboardEventWasDispatched
)
{
return
KeyHandlingState
:
:
eNotHandled
;
}
return
mKeyboardEventWasConsumed
?
KeyHandlingState
:
:
eNotHandledButEventConsumed
:
KeyHandlingState
:
:
eNotHandledButEventDispatched
;
}
void
IMContextWrapper
:
:
OnFocusChangeInGecko
(
bool
aFocus
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnFocusChangeInGecko
(
aFocus
=
%
s
)
"
"
mCompositionState
=
%
s
mIsIMFocused
=
%
s
"
this
ToChar
(
aFocus
)
GetCompositionStateName
(
)
ToChar
(
mIsIMFocused
)
)
)
;
mSelectedStringRemovedByComposition
.
Truncate
(
)
;
mSelection
.
reset
(
)
;
if
(
aFocus
&
&
EnsureToCacheSelection
(
)
)
{
SetCursorPosition
(
GetActiveContext
(
)
)
;
}
}
void
IMContextWrapper
:
:
ResetIME
(
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
ResetIME
(
)
mCompositionState
=
%
s
mIsIMFocused
=
%
s
"
this
GetCompositionStateName
(
)
ToChar
(
mIsIMFocused
)
)
)
;
GtkIMContext
*
activeContext
=
GetActiveContext
(
)
;
if
(
MOZ_UNLIKELY
(
!
activeContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
ResetIME
(
)
FAILED
there
are
no
context
"
this
)
)
;
return
;
}
RefPtr
<
IMContextWrapper
>
kungFuDeathGrip
(
this
)
;
RefPtr
<
nsWindow
>
lastFocusedWindow
(
mLastFocusedWindow
)
;
mPendingResettingIMContext
=
false
;
gtk_im_context_reset
(
activeContext
)
;
if
(
!
lastFocusedWindow
|
|
NS_WARN_IF
(
lastFocusedWindow
!
=
mLastFocusedWindow
)
|
|
lastFocusedWindow
-
>
Destroyed
(
)
)
{
return
;
}
nsAutoString
compositionString
;
GetCompositionString
(
activeContext
compositionString
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
ResetIME
(
)
called
gtk_im_context_reset
(
)
"
"
activeContext
=
0x
%
p
mCompositionState
=
%
s
compositionString
=
%
s
"
"
mIsIMFocused
=
%
s
"
this
activeContext
GetCompositionStateName
(
)
NS_ConvertUTF16toUTF8
(
compositionString
)
.
get
(
)
ToChar
(
mIsIMFocused
)
)
)
;
if
(
IsComposing
(
)
&
&
compositionString
.
IsEmpty
(
)
)
{
DispatchCompositionCommitEvent
(
activeContext
&
EmptyString
(
)
)
;
}
}
nsresult
IMContextWrapper
:
:
EndIMEComposition
(
nsWindow
*
aCaller
)
{
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
NS_OK
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
EndIMEComposition
(
aCaller
=
0x
%
p
)
"
"
mCompositionState
=
%
s
"
this
aCaller
GetCompositionStateName
(
)
)
)
;
if
(
aCaller
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
EndIMEComposition
(
)
FAILED
the
caller
isn
'
t
"
"
focused
window
mLastFocusedWindow
=
0x
%
p
"
this
mLastFocusedWindow
)
)
;
return
NS_OK
;
}
if
(
!
IsComposing
(
)
)
{
return
NS_OK
;
}
ResetIME
(
)
;
return
NS_OK
;
}
void
IMContextWrapper
:
:
OnLayoutChange
(
)
{
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
;
}
if
(
IsComposing
(
)
)
{
SetCursorPosition
(
GetActiveContext
(
)
)
;
}
else
{
mSetCursorPositionOnKeyEvent
=
true
;
}
mLayoutChanged
=
true
;
}
void
IMContextWrapper
:
:
OnUpdateComposition
(
)
{
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
;
}
if
(
!
IsComposing
(
)
)
{
mSelection
.
reset
(
)
;
EnsureToCacheSelection
(
)
;
mSetCursorPositionOnKeyEvent
=
true
;
}
if
(
!
mLayoutChanged
)
{
SetCursorPosition
(
GetActiveContext
(
)
)
;
}
}
void
IMContextWrapper
:
:
SetInputContext
(
nsWindow
*
aCaller
const
InputContext
*
aContext
const
InputContextAction
*
aAction
)
{
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
SetInputContext
(
aCaller
=
0x
%
p
aContext
=
{
mIMEState
=
{
"
"
mEnabled
=
%
s
}
mHTMLInputType
=
%
s
}
)
"
this
aCaller
ToString
(
aContext
-
>
mIMEState
.
mEnabled
)
.
c_str
(
)
NS_ConvertUTF16toUTF8
(
aContext
-
>
mHTMLInputType
)
.
get
(
)
)
)
;
if
(
aCaller
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetInputContext
(
)
FAILED
"
"
the
caller
isn
'
t
focused
window
mLastFocusedWindow
=
0x
%
p
"
this
mLastFocusedWindow
)
)
;
return
;
}
if
(
!
mContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetInputContext
(
)
FAILED
"
"
there
are
no
context
"
this
)
)
;
return
;
}
if
(
sLastFocusedContext
!
=
this
)
{
mInputContext
=
*
aContext
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
SetInputContext
(
)
succeeded
"
"
but
we
'
re
not
active
"
this
)
)
;
return
;
}
bool
changingEnabledState
=
aContext
-
>
IsInputAttributeChanged
(
mInputContext
)
;
if
(
changingEnabledState
&
&
mInputContext
.
mIMEState
.
IsEditable
(
)
)
{
EndIMEComposition
(
mLastFocusedWindow
)
;
Blur
(
)
;
}
mInputContext
=
*
aContext
;
if
(
changingEnabledState
)
{
if
(
mInputContext
.
mIMEState
.
IsEditable
(
)
)
{
GtkIMContext
*
currentContext
=
GetCurrentContext
(
)
;
if
(
currentContext
)
{
GtkInputPurpose
purpose
=
GTK_INPUT_PURPOSE_FREE_FORM
;
const
nsString
&
inputType
=
mInputContext
.
mHTMLInputType
;
if
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEEnabled
:
:
Password
)
{
purpose
=
GTK_INPUT_PURPOSE_PASSWORD
;
}
else
if
(
inputType
.
EqualsLiteral
(
"
email
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_EMAIL
;
}
else
if
(
inputType
.
EqualsLiteral
(
"
url
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_URL
;
}
else
if
(
inputType
.
EqualsLiteral
(
"
tel
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_PHONE
;
}
else
if
(
inputType
.
EqualsLiteral
(
"
number
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_NUMBER
;
}
else
if
(
mInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
decimal
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_NUMBER
;
}
else
if
(
mInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
email
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_EMAIL
;
}
else
if
(
mInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
numeric
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_DIGITS
;
}
else
if
(
mInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
tel
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_PHONE
;
}
else
if
(
mInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
url
"
)
)
{
purpose
=
GTK_INPUT_PURPOSE_URL
;
}
g_object_set
(
currentContext
"
input
-
purpose
"
purpose
nullptr
)
;
gint
hints
=
GTK_INPUT_HINT_NONE
;
if
(
mInputContext
.
mHTMLInputInputmode
.
EqualsLiteral
(
"
none
"
)
)
{
hints
|
=
GTK_INPUT_HINT_INHIBIT_OSK
;
}
if
(
mInputContext
.
mAutocapitalize
.
EqualsLiteral
(
"
characters
"
)
)
{
hints
|
=
GTK_INPUT_HINT_UPPERCASE_CHARS
;
}
else
if
(
mInputContext
.
mAutocapitalize
.
EqualsLiteral
(
"
sentences
"
)
)
{
hints
|
=
GTK_INPUT_HINT_UPPERCASE_SENTENCES
;
}
else
if
(
mInputContext
.
mAutocapitalize
.
EqualsLiteral
(
"
words
"
)
)
{
hints
|
=
GTK_INPUT_HINT_UPPERCASE_WORDS
;
}
g_object_set
(
currentContext
"
input
-
hints
"
hints
nullptr
)
;
}
}
Focus
(
)
;
}
}
InputContext
IMContextWrapper
:
:
GetInputContext
(
)
{
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
OPEN_STATE_NOT_SUPPORTED
;
return
mInputContext
;
}
GtkIMContext
*
IMContextWrapper
:
:
GetCurrentContext
(
)
const
{
if
(
IsEnabled
(
)
)
{
return
mContext
;
}
if
(
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEEnabled
:
:
Password
)
{
return
mSimpleContext
;
}
return
mDummyContext
;
}
bool
IMContextWrapper
:
:
IsValidContext
(
GtkIMContext
*
aContext
)
const
{
if
(
!
aContext
)
{
return
false
;
}
return
aContext
=
=
mContext
|
|
aContext
=
=
mSimpleContext
|
|
aContext
=
=
mDummyContext
;
}
bool
IMContextWrapper
:
:
IsEnabled
(
)
const
{
return
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEEnabled
:
:
Enabled
|
|
(
!
sUseSimpleContext
&
&
mInputContext
.
mIMEState
.
mEnabled
=
=
IMEEnabled
:
:
Password
)
;
}
void
IMContextWrapper
:
:
Focus
(
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
Focus
(
)
sLastFocusedContext
=
0x
%
p
"
this
sLastFocusedContext
)
)
;
if
(
mIsIMFocused
)
{
NS_ASSERTION
(
sLastFocusedContext
=
=
this
"
We
'
re
not
active
but
the
IM
was
focused
?
"
)
;
return
;
}
GtkIMContext
*
currentContext
=
GetCurrentContext
(
)
;
if
(
!
currentContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
Focus
(
)
FAILED
there
are
no
context
"
this
)
)
;
return
;
}
if
(
sLastFocusedContext
&
&
sLastFocusedContext
!
=
this
)
{
sLastFocusedContext
-
>
Blur
(
)
;
}
sLastFocusedContext
=
this
;
sWaitingSynthesizedKeyPressHardwareKeyCode
=
0
;
mPostingKeyEvents
.
Clear
(
)
;
gtk_im_context_focus_in
(
currentContext
)
;
mIsIMFocused
=
true
;
mSetCursorPositionOnKeyEvent
=
true
;
if
(
!
IsEnabled
(
)
)
{
Blur
(
)
;
}
}
void
IMContextWrapper
:
:
Blur
(
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
Blur
(
)
mIsIMFocused
=
%
s
"
this
ToChar
(
mIsIMFocused
)
)
)
;
if
(
!
mIsIMFocused
)
{
return
;
}
GtkIMContext
*
currentContext
=
GetCurrentContext
(
)
;
if
(
!
currentContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
Blur
(
)
FAILED
there
are
no
context
"
this
)
)
;
return
;
}
gtk_im_context_focus_out
(
currentContext
)
;
mIsIMFocused
=
false
;
}
void
IMContextWrapper
:
:
OnSelectionChange
(
nsWindow
*
aCaller
const
IMENotification
&
aIMENotification
)
{
const
bool
isSelectionRangeChanged
=
mSelection
.
isNothing
(
)
|
|
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
!
=
aIMENotification
.
mSelectionChangeData
.
mOffset
|
|
mSelection
-
>
OffsetAndDataRef
(
)
.
DataRef
(
)
!
=
*
aIMENotification
.
mSelectionChangeData
.
mString
;
mSelection
=
Some
(
Selection
(
aIMENotification
.
mSelectionChangeData
)
)
;
const
bool
retrievedSurroundingSignalReceived
=
mRetrieveSurroundingSignalReceived
;
mRetrieveSurroundingSignalReceived
=
false
;
if
(
MOZ_UNLIKELY
(
IsDestroyed
(
)
)
)
{
return
;
}
const
IMENotification
:
:
SelectionChangeDataBase
&
selectionChangeData
=
aIMENotification
.
mSelectionChangeData
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnSelectionChange
(
aCaller
=
0x
%
p
aIMENotification
=
{
"
"
mSelectionChangeData
=
%
s
}
)
"
"
mCompositionState
=
%
s
mIsDeletingSurrounding
=
%
s
"
"
mRetrieveSurroundingSignalReceived
=
%
s
isSelectionRangeChanged
=
%
s
"
this
aCaller
ToString
(
selectionChangeData
)
.
c_str
(
)
GetCompositionStateName
(
)
ToChar
(
mIsDeletingSurrounding
)
ToChar
(
retrievedSurroundingSignalReceived
)
ToChar
(
isSelectionRangeChanged
)
)
)
;
if
(
aCaller
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnSelectionChange
(
)
FAILED
"
"
the
caller
isn
'
t
focused
window
mLastFocusedWindow
=
0x
%
p
"
this
mLastFocusedWindow
)
)
;
return
;
}
if
(
!
IsComposing
(
)
)
{
mSetCursorPositionOnKeyEvent
=
true
;
}
if
(
mCompositionState
=
=
eCompositionState_CompositionStartDispatched
)
{
if
(
NS_WARN_IF
(
mSelection
.
isNothing
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnSelectionChange
(
)
FAILED
"
"
new
offset
is
too
large
cannot
keep
composing
"
this
)
)
;
}
else
if
(
mSelection
-
>
HasRange
(
)
)
{
mCompositionStart
=
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
OnSelectionChange
(
)
ignored
mCompositionStart
"
"
is
updated
to
%
u
the
selection
change
doesn
'
t
cause
"
"
resetting
IM
context
"
this
mCompositionStart
)
)
;
return
;
}
else
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
OnSelectionChange
(
)
ignored
because
of
no
selection
range
"
this
)
)
;
return
;
}
}
if
(
mIsDeletingSurrounding
)
{
return
;
}
bool
occurredBeforeComposition
=
IsComposing
(
)
&
&
!
selectionChangeData
.
mOccurredDuringComposition
&
&
!
selectionChangeData
.
mCausedByComposition
;
if
(
occurredBeforeComposition
)
{
mPendingResettingIMContext
=
true
;
}
if
(
!
selectionChangeData
.
mCausedByComposition
&
&
!
selectionChangeData
.
mCausedBySelectionEvent
&
&
isSelectionRangeChanged
&
&
!
occurredBeforeComposition
)
{
if
(
IsComposing
(
)
|
|
retrievedSurroundingSignalReceived
)
{
ResetIME
(
)
;
}
}
}
void
IMContextWrapper
:
:
OnThemeChanged
(
)
{
if
(
auto
*
provider
=
SelectionStyleProvider
:
:
GetExistingInstance
(
)
)
{
provider
-
>
OnThemeChanged
(
)
;
}
}
void
IMContextWrapper
:
:
OnStartCompositionCallback
(
GtkIMContext
*
aContext
IMContextWrapper
*
aModule
)
{
aModule
-
>
OnStartCompositionNative
(
aContext
)
;
}
void
IMContextWrapper
:
:
OnStartCompositionNative
(
GtkIMContext
*
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnStartCompositionNative
(
aContext
=
0x
%
p
)
"
"
current
context
=
0x
%
p
mComposingContext
=
0x
%
p
"
this
aContext
GetCurrentContext
(
)
mComposingContext
)
)
;
if
(
GetCurrentContext
(
)
!
=
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnStartCompositionNative
(
)
FAILED
"
"
given
context
doesn
'
t
match
"
this
)
)
;
return
;
}
if
(
mComposingContext
&
&
aContext
!
=
mComposingContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
OnStartCompositionNative
(
)
Warning
"
"
there
is
already
a
composing
context
but
starting
new
"
"
composition
with
different
context
"
this
)
)
;
}
if
(
!
DispatchCompositionStart
(
aContext
)
)
{
return
;
}
mCompositionTargetRange
.
mOffset
=
mCompositionStart
;
mCompositionTargetRange
.
mLength
=
0
;
}
void
IMContextWrapper
:
:
OnEndCompositionCallback
(
GtkIMContext
*
aContext
IMContextWrapper
*
aModule
)
{
aModule
-
>
OnEndCompositionNative
(
aContext
)
;
}
void
IMContextWrapper
:
:
OnEndCompositionNative
(
GtkIMContext
*
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnEndCompositionNative
(
aContext
=
0x
%
p
)
mComposingContext
=
0x
%
p
"
this
aContext
mComposingContext
)
)
;
if
(
!
IsValidContext
(
aContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnEndCompositionNative
(
)
FAILED
"
"
given
context
doesn
'
t
match
with
any
context
"
this
)
)
;
return
;
}
if
(
aContext
!
=
mComposingContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
OnEndCompositionNative
(
)
Warning
"
"
given
context
doesn
'
t
match
with
mComposingContext
"
this
)
)
;
return
;
}
g_object_unref
(
mComposingContext
)
;
mComposingContext
=
nullptr
;
if
(
IsComposing
(
)
)
{
if
(
!
DispatchCompositionCommitEvent
(
aContext
)
)
{
return
;
}
}
if
(
mPendingResettingIMContext
)
{
ResetIME
(
)
;
}
}
void
IMContextWrapper
:
:
OnChangeCompositionCallback
(
GtkIMContext
*
aContext
IMContextWrapper
*
aModule
)
{
aModule
-
>
OnChangeCompositionNative
(
aContext
)
;
}
void
IMContextWrapper
:
:
OnChangeCompositionNative
(
GtkIMContext
*
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnChangeCompositionNative
(
aContext
=
0x
%
p
)
"
"
mComposingContext
=
0x
%
p
"
this
aContext
mComposingContext
)
)
;
if
(
!
IsValidContext
(
aContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnChangeCompositionNative
(
)
FAILED
"
"
given
context
doesn
'
t
match
with
any
context
"
this
)
)
;
return
;
}
if
(
mComposingContext
&
&
aContext
!
=
mComposingContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
OnChangeCompositionNative
(
)
Warning
"
"
given
context
doesn
'
t
match
with
composing
context
"
this
)
)
;
}
nsAutoString
compositionString
;
GetCompositionString
(
aContext
compositionString
)
;
if
(
!
IsComposing
(
)
&
&
compositionString
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
OnChangeCompositionNative
(
)
Warning
does
nothing
"
"
because
has
not
started
composition
and
composing
string
is
"
"
empty
"
this
)
)
;
mDispatchedCompositionString
.
Truncate
(
)
;
return
;
}
DispatchCompositionChangeEvent
(
aContext
compositionString
)
;
}
gboolean
IMContextWrapper
:
:
OnRetrieveSurroundingCallback
(
GtkIMContext
*
aContext
IMContextWrapper
*
aModule
)
{
return
aModule
-
>
OnRetrieveSurroundingNative
(
aContext
)
;
}
gboolean
IMContextWrapper
:
:
OnRetrieveSurroundingNative
(
GtkIMContext
*
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnRetrieveSurroundingNative
(
aContext
=
0x
%
p
)
"
"
current
context
=
0x
%
p
"
this
aContext
GetCurrentContext
(
)
)
)
;
if
(
GetCurrentContext
(
)
!
=
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnRetrieveSurroundingNative
(
)
FAILED
"
"
given
context
doesn
'
t
match
"
this
)
)
;
return
FALSE
;
}
nsAutoString
uniStr
;
uint32_t
cursorPos
;
if
(
NS_FAILED
(
GetCurrentParagraph
(
uniStr
cursorPos
)
)
)
{
return
FALSE
;
}
uniStr
.
ReplaceChar
(
char16_t
(
0
)
char16_t
(
0xFFFD
)
)
;
NS_ConvertUTF16toUTF8
utf8Str
(
nsDependentSubstring
(
uniStr
0
cursorPos
)
)
;
uint32_t
cursorPosInUTF8
=
utf8Str
.
Length
(
)
;
AppendUTF16toUTF8
(
nsDependentSubstring
(
uniStr
cursorPos
)
utf8Str
)
;
gtk_im_context_set_surrounding
(
aContext
utf8Str
.
get
(
)
utf8Str
.
Length
(
)
cursorPosInUTF8
)
;
mRetrieveSurroundingSignalReceived
=
true
;
return
TRUE
;
}
gboolean
IMContextWrapper
:
:
OnDeleteSurroundingCallback
(
GtkIMContext
*
aContext
gint
aOffset
gint
aNChars
IMContextWrapper
*
aModule
)
{
return
aModule
-
>
OnDeleteSurroundingNative
(
aContext
aOffset
aNChars
)
;
}
gboolean
IMContextWrapper
:
:
OnDeleteSurroundingNative
(
GtkIMContext
*
aContext
gint
aOffset
gint
aNChars
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnDeleteSurroundingNative
(
aContext
=
0x
%
p
aOffset
=
%
d
"
"
aNChar
=
%
d
)
current
context
=
0x
%
p
"
this
aContext
aOffset
aNChars
GetCurrentContext
(
)
)
)
;
if
(
GetCurrentContext
(
)
!
=
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnDeleteSurroundingNative
(
)
FAILED
"
"
given
context
doesn
'
t
match
"
this
)
)
;
return
FALSE
;
}
AutoRestore
<
bool
>
saveDeletingSurrounding
(
mIsDeletingSurrounding
)
;
mIsDeletingSurrounding
=
true
;
if
(
NS_SUCCEEDED
(
DeleteText
(
aContext
aOffset
(
uint32_t
)
aNChars
)
)
)
{
return
TRUE
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnDeleteSurroundingNative
(
)
FAILED
"
"
cannot
delete
text
"
this
)
)
;
return
FALSE
;
}
void
IMContextWrapper
:
:
OnCommitCompositionCallback
(
GtkIMContext
*
aContext
const
gchar
*
aString
IMContextWrapper
*
aModule
)
{
aModule
-
>
OnCommitCompositionNative
(
aContext
aString
)
;
}
void
IMContextWrapper
:
:
OnCommitCompositionNative
(
GtkIMContext
*
aContext
const
gchar
*
aUTF8Char
)
{
const
gchar
emptyStr
=
0
;
const
gchar
*
commitString
=
aUTF8Char
?
aUTF8Char
:
&
emptyStr
;
NS_ConvertUTF8toUTF16
utf16CommitString
(
commitString
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnCommitCompositionNative
(
aContext
=
0x
%
p
)
"
"
current
context
=
0x
%
p
active
context
=
0x
%
p
commitString
=
\
"
%
s
\
"
"
"
mProcessingKeyEvent
=
0x
%
p
IsComposingOn
(
aContext
)
=
%
s
"
this
aContext
GetCurrentContext
(
)
GetActiveContext
(
)
commitString
mProcessingKeyEvent
ToChar
(
IsComposingOn
(
aContext
)
)
)
)
;
if
(
!
IsValidContext
(
aContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnCommitCompositionNative
(
)
FAILED
"
"
given
context
doesn
'
t
match
"
this
)
)
;
return
;
}
if
(
!
IsComposingOn
(
aContext
)
&
&
utf16CommitString
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
OnCommitCompositionNative
(
)
Warning
does
nothing
"
"
because
has
not
started
composition
and
commit
string
is
empty
"
this
)
)
;
return
;
}
if
(
!
IsComposingOn
(
aContext
)
&
&
mProcessingKeyEvent
&
&
mProcessingKeyEvent
-
>
type
=
=
GDK_KEY_PRESS
&
&
aContext
=
=
GetCurrentContext
(
)
)
{
char
keyval_utf8
[
8
]
;
gint
keyval_utf8_len
;
guint32
keyval_unicode
;
keyval_unicode
=
gdk_keyval_to_unicode
(
mProcessingKeyEvent
-
>
keyval
)
;
keyval_utf8_len
=
g_unichar_to_utf8
(
keyval_unicode
keyval_utf8
)
;
keyval_utf8
[
keyval_utf8_len
]
=
'
\
0
'
;
if
(
!
strcmp
(
commitString
keyval_utf8
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnCommitCompositionNative
(
)
"
"
we
'
ll
send
normal
key
event
"
this
)
)
;
mFallbackToKeyEvent
=
true
;
return
;
}
WidgetKeyboardEvent
keyDownEvent
(
true
eKeyDown
mLastFocusedWindow
)
;
KeymapWrapper
:
:
InitKeyEvent
(
keyDownEvent
mProcessingKeyEvent
false
)
;
if
(
mMaybeInDeadKeySequence
&
&
utf16CommitString
.
Length
(
)
=
=
1
&
&
keyDownEvent
.
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
)
{
mKeyboardEventWasDispatched
=
true
;
mMaybeInDeadKeySequence
=
false
;
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcher
(
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
OnCommitCompositionNative
(
)
FAILED
"
"
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
;
}
keyDownEvent
.
mKeyValue
=
utf16CommitString
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
bool
dispatched
=
dispatcher
-
>
DispatchKeyboardEvent
(
eKeyDown
keyDownEvent
status
mProcessingKeyEvent
)
;
if
(
!
dispatched
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
mKeyboardEventWasConsumed
=
true
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnCommitCompositionNative
(
)
"
"
doesn
'
t
dispatch
eKeyPress
event
because
the
preceding
"
"
eKeyDown
event
was
not
dispatched
or
was
consumed
"
this
)
)
;
return
;
}
if
(
mLastFocusedWindow
!
=
keyDownEvent
.
mWidget
|
|
mLastFocusedWindow
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
OnCommitCompositionNative
(
)
Warning
"
"
stop
dispatching
eKeyPress
event
because
the
preceding
"
"
eKeyDown
event
caused
changing
focused
widget
or
"
"
destroyed
"
this
)
)
;
return
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnCommitCompositionNative
(
)
"
"
dispatched
eKeyDown
event
for
the
committed
character
"
this
)
)
;
dispatcher
-
>
MaybeDispatchKeypressEvents
(
keyDownEvent
status
mProcessingKeyEvent
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
OnCommitCompositionNative
(
)
"
"
dispatched
eKeyPress
event
for
the
committed
character
"
this
)
)
;
return
;
}
}
NS_ConvertUTF8toUTF16
str
(
commitString
)
;
DispatchCompositionCommitEvent
(
aContext
&
str
)
;
}
void
IMContextWrapper
:
:
GetCompositionString
(
GtkIMContext
*
aContext
nsAString
&
aCompositionString
)
{
gchar
*
preedit_string
;
gint
cursor_pos
;
PangoAttrList
*
feedback_list
;
gtk_im_context_get_preedit_string
(
aContext
&
preedit_string
&
feedback_list
&
cursor_pos
)
;
if
(
preedit_string
&
&
*
preedit_string
)
{
CopyUTF8toUTF16
(
MakeStringSpan
(
preedit_string
)
aCompositionString
)
;
}
else
{
aCompositionString
.
Truncate
(
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
GetCompositionString
(
aContext
=
0x
%
p
)
"
"
aCompositionString
=
\
"
%
s
\
"
"
this
aContext
preedit_string
)
)
;
pango_attr_list_unref
(
feedback_list
)
;
g_free
(
preedit_string
)
;
}
bool
IMContextWrapper
:
:
MaybeDispatchKeyEventAsProcessedByIME
(
EventMessage
aFollowingEvent
)
{
if
(
!
mLastFocusedWindow
)
{
return
false
;
}
if
(
!
mIsKeySnooped
&
&
(
(
!
mProcessingKeyEvent
&
&
mPostingKeyEvents
.
IsEmpty
(
)
)
|
|
(
mProcessingKeyEvent
&
&
mKeyboardEventWasDispatched
)
)
)
{
return
true
;
}
GtkIMContext
*
oldCurrentContext
=
GetCurrentContext
(
)
;
GtkIMContext
*
oldComposingContext
=
mComposingContext
;
RefPtr
<
nsWindow
>
lastFocusedWindow
(
mLastFocusedWindow
)
;
if
(
mProcessingKeyEvent
|
|
!
mPostingKeyEvents
.
IsEmpty
(
)
)
{
if
(
mProcessingKeyEvent
)
{
mKeyboardEventWasDispatched
=
true
;
}
GdkEventKey
*
sourceEvent
=
mProcessingKeyEvent
?
mProcessingKeyEvent
:
mPostingKeyEvents
.
GetFirstEvent
(
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
"
"
aFollowingEvent
=
%
s
)
dispatch
%
s
%
s
"
"
event
:
{
type
=
%
s
keyval
=
%
s
unicode
=
0x
%
X
state
=
%
s
"
"
time
=
%
u
hardware_keycode
=
%
u
group
=
%
u
}
"
this
ToChar
(
aFollowingEvent
)
ToChar
(
sourceEvent
-
>
type
=
=
GDK_KEY_PRESS
?
eKeyDown
:
eKeyUp
)
mProcessingKeyEvent
?
"
processing
"
:
"
posted
"
GetEventType
(
sourceEvent
)
gdk_keyval_name
(
sourceEvent
-
>
keyval
)
gdk_keyval_to_unicode
(
sourceEvent
-
>
keyval
)
GetEventStateName
(
sourceEvent
-
>
state
mIMContextID
)
.
get
(
)
sourceEvent
-
>
time
sourceEvent
-
>
hardware_keycode
sourceEvent
-
>
group
)
)
;
KeymapWrapper
:
:
DispatchKeyDownOrKeyUpEvent
(
lastFocusedWindow
sourceEvent
!
mMaybeInDeadKeySequence
&
mKeyboardEventWasConsumed
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
)
keydown
or
keyup
"
"
event
is
dispatched
"
this
)
)
;
if
(
!
mProcessingKeyEvent
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
)
removing
first
"
"
event
from
the
queue
"
this
)
)
;
mPostingKeyEvents
.
RemoveEvent
(
sourceEvent
)
;
}
}
else
{
MOZ_ASSERT
(
mIsKeySnooped
)
;
MOZ_ASSERT
(
mIMContextID
=
=
IMContextID
:
:
Uim
|
|
mIMContextID
=
=
IMContextID
:
:
Wayland
)
;
bool
dispatchFakeKeyDown
=
false
;
switch
(
aFollowingEvent
)
{
case
eCompositionStart
:
case
eCompositionCommit
:
case
eCompositionCommitAsIs
:
case
eContentCommandInsertText
:
dispatchFakeKeyDown
=
true
;
break
;
case
eContentCommandDelete
:
dispatchFakeKeyDown
=
true
;
break
;
case
eCompositionChange
:
dispatchFakeKeyDown
=
!
mDispatchedCompositionString
.
IsEmpty
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Do
you
forget
to
handle
the
case
?
"
)
;
break
;
}
if
(
dispatchFakeKeyDown
)
{
WidgetKeyboardEvent
fakeKeyDownEvent
(
true
eKeyDown
lastFocusedWindow
)
;
fakeKeyDownEvent
.
mKeyCode
=
NS_VK_PROCESSKEY
;
fakeKeyDownEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Process
;
fakeKeyDownEvent
.
mCodeNameIndex
=
CODE_NAME_INDEX_UNKNOWN
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
"
"
aFollowingEvent
=
%
s
)
dispatch
fake
eKeyDown
event
"
this
ToChar
(
aFollowingEvent
)
)
)
;
KeymapWrapper
:
:
DispatchKeyDownOrKeyUpEvent
(
lastFocusedWindow
fakeKeyDownEvent
&
mKeyboardEventWasConsumed
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
)
"
"
fake
keydown
event
is
dispatched
"
this
)
)
;
}
}
if
(
lastFocusedWindow
-
>
IsDestroyed
(
)
|
|
lastFocusedWindow
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
)
Warning
the
"
"
focused
widget
was
destroyed
/
changed
by
a
key
event
"
this
)
)
;
return
false
;
}
if
(
GetCurrentContext
(
)
!
=
oldCurrentContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
MaybeDispatchKeyEventAsProcessedByIME
(
)
Warning
the
key
"
"
event
causes
changing
active
IM
context
"
this
)
)
;
if
(
mComposingContext
=
=
oldComposingContext
)
{
ResetIME
(
)
;
}
return
false
;
}
return
true
;
}
bool
IMContextWrapper
:
:
DispatchCompositionStart
(
GtkIMContext
*
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
DispatchCompositionStart
(
aContext
=
0x
%
p
)
"
this
aContext
)
)
;
if
(
IsComposing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionStart
(
)
FAILED
"
"
we
'
re
already
in
composition
"
this
)
)
;
return
true
;
}
if
(
!
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionStart
(
)
FAILED
"
"
there
are
no
focused
window
in
this
module
"
this
)
)
;
return
false
;
}
if
(
NS_WARN_IF
(
!
EnsureToCacheSelection
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionStart
(
)
FAILED
"
"
cannot
query
the
selection
offset
"
this
)
)
;
return
false
;
}
if
(
NS_WARN_IF
(
!
mSelection
-
>
HasRange
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionStart
(
)
FAILED
"
"
due
to
no
selection
"
this
)
)
;
return
false
;
}
mComposingContext
=
static_cast
<
GtkIMContext
*
>
(
g_object_ref
(
aContext
)
)
;
MOZ_ASSERT
(
mComposingContext
)
;
RefPtr
<
nsWindow
>
lastFocusedWindow
(
mLastFocusedWindow
)
;
mCompositionStart
=
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
;
mDispatchedCompositionString
.
Truncate
(
)
;
if
(
!
MaybeDispatchKeyEventAsProcessedByIME
(
eCompositionStart
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
DispatchCompositionStart
(
)
Warning
"
"
MaybeDispatchKeyEventAsProcessedByIME
(
)
returned
false
"
this
)
)
;
return
false
;
}
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcher
(
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionStart
(
)
FAILED
"
"
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
static
bool
sHasSetTelemetry
=
false
;
if
(
!
sHasSetTelemetry
)
{
sHasSetTelemetry
=
true
;
NS_ConvertUTF8toUTF16
im
(
GetIMName
(
)
)
;
if
(
im
.
Length
(
)
>
72
)
{
if
(
NS_IS_SURROGATE_PAIR
(
im
[
72
-
2
]
im
[
72
-
1
]
)
)
{
im
.
Truncate
(
72
-
2
)
;
}
else
{
im
.
Truncate
(
72
-
1
)
;
}
im
.
Append
(
char16_t
(
0x2026
)
)
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
WIDGET_IME_NAME_ON_LINUX
im
true
)
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
DispatchCompositionStart
(
)
dispatching
"
"
compositionstart
.
.
.
(
mCompositionStart
=
%
u
)
"
this
mCompositionStart
)
)
;
mCompositionState
=
eCompositionState_CompositionStartDispatched
;
nsEventStatus
status
;
dispatcher
-
>
StartComposition
(
status
)
;
if
(
lastFocusedWindow
-
>
IsDestroyed
(
)
|
|
lastFocusedWindow
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionStart
(
)
FAILED
the
focused
"
"
widget
was
destroyed
/
changed
by
compositionstart
event
"
this
)
)
;
return
false
;
}
return
true
;
}
bool
IMContextWrapper
:
:
DispatchCompositionChangeEvent
(
GtkIMContext
*
aContext
const
nsAString
&
aCompositionString
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
DispatchCompositionChangeEvent
(
aContext
=
0x
%
p
)
"
this
aContext
)
)
;
if
(
!
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
"
"
there
are
no
focused
window
in
this
module
"
this
)
)
;
return
false
;
}
if
(
!
IsComposing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
the
composition
"
"
wasn
'
t
started
force
starting
.
.
.
"
this
)
)
;
if
(
!
DispatchCompositionStart
(
aContext
)
)
{
return
false
;
}
}
else
if
(
!
MaybeDispatchKeyEventAsProcessedByIME
(
eCompositionChange
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
Warning
"
"
MaybeDispatchKeyEventAsProcessedByIME
(
)
returned
false
"
this
)
)
;
return
false
;
}
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcher
(
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
"
"
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
if
(
mCompositionState
=
=
eCompositionState_CompositionStartDispatched
)
{
if
(
NS_WARN_IF
(
!
EnsureToCacheSelection
(
&
mSelectedStringRemovedByComposition
)
)
)
{
}
else
if
(
mSelection
-
>
HasRange
(
)
)
{
mCompositionStart
=
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
;
}
else
{
}
}
RefPtr
<
TextRangeArray
>
rangeArray
=
CreateTextRangeArray
(
aContext
aCompositionString
)
;
rv
=
dispatcher
-
>
SetPendingComposition
(
aCompositionString
rangeArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
"
"
due
to
SetPendingComposition
(
)
failure
"
this
)
)
;
return
false
;
}
mCompositionState
=
eCompositionState_CompositionChangeEventDispatched
;
mDispatchedCompositionString
=
aCompositionString
;
mLayoutChanged
=
false
;
mCompositionTargetRange
.
mOffset
=
mCompositionStart
+
rangeArray
-
>
TargetClauseOffset
(
)
;
mCompositionTargetRange
.
mLength
=
rangeArray
-
>
TargetClauseLength
(
)
;
RefPtr
<
nsWindow
>
lastFocusedWindow
(
mLastFocusedWindow
)
;
nsEventStatus
status
;
rv
=
dispatcher
-
>
FlushPendingComposition
(
status
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
"
"
due
to
FlushPendingComposition
(
)
failure
"
this
)
)
;
return
false
;
}
if
(
lastFocusedWindow
-
>
IsDestroyed
(
)
|
|
lastFocusedWindow
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
the
"
"
focused
widget
was
destroyed
/
changed
by
"
"
compositionchange
event
"
this
)
)
;
return
false
;
}
return
true
;
}
bool
IMContextWrapper
:
:
DispatchCompositionCommitEvent
(
GtkIMContext
*
aContext
const
nsAString
*
aCommitString
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
DispatchCompositionCommitEvent
(
aContext
=
0x
%
p
"
"
aCommitString
=
0x
%
p
(
\
"
%
s
\
"
)
)
"
this
aContext
aCommitString
aCommitString
?
NS_ConvertUTF16toUTF8
(
*
aCommitString
)
.
get
(
)
:
"
"
)
)
;
if
(
!
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
FAILED
"
"
there
are
no
focused
window
in
this
module
"
this
)
)
;
return
false
;
}
RefPtr
<
nsWindow
>
lastFocusedWindow
(
mLastFocusedWindow
)
;
RefPtr
<
TextEventDispatcher
>
dispatcher
;
if
(
!
IsComposing
(
)
&
&
!
StaticPrefs
:
:
intl_ime_use_composition_events_for_insert_text
(
)
)
{
if
(
!
aCommitString
|
|
aCommitString
-
>
IsEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
FAILED
"
"
did
nothing
due
to
inserting
empty
string
without
composition
"
this
)
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
!
EnsureToCacheSelection
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
Warning
"
"
Failed
to
cache
selection
before
dispatching
"
"
eContentCommandInsertText
event
"
this
)
)
;
}
if
(
!
MaybeDispatchKeyEventAsProcessedByIME
(
eContentCommandInsertText
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
Warning
"
"
MaybeDispatchKeyEventAsProcessedByIME
(
)
returned
false
"
this
)
)
;
return
false
;
}
if
(
mSelection
.
isSome
(
)
)
{
mSelection
-
>
Collapse
(
(
mSelection
-
>
HasRange
(
)
?
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
:
mCompositionStart
)
+
aCommitString
-
>
Length
(
)
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
mSelection
=
%
s
"
this
ToString
(
mSelection
)
.
c_str
(
)
)
)
;
}
MOZ_ASSERT
(
!
dispatcher
)
;
}
else
{
if
(
!
IsComposing
(
)
)
{
if
(
!
aCommitString
|
|
aCommitString
-
>
IsEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
FAILED
"
"
there
is
no
composition
and
empty
commit
string
"
this
)
)
;
return
true
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
"
"
the
composition
wasn
'
t
started
force
starting
.
.
.
"
this
)
)
;
if
(
!
DispatchCompositionStart
(
aContext
)
)
{
return
false
;
}
}
else
if
(
!
MaybeDispatchKeyEventAsProcessedByIME
(
aCommitString
?
eCompositionCommit
:
eCompositionCommitAsIs
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
Warning
"
"
MaybeDispatchKeyEventAsProcessedByIME
(
)
returned
false
"
this
)
)
;
mCompositionState
=
eCompositionState_NotComposing
;
return
false
;
}
dispatcher
=
GetTextEventDispatcher
(
)
;
MOZ_ASSERT
(
dispatcher
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
FAILED
"
"
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
const
uint32_t
offsetToPutCaret
=
mCompositionStart
+
(
aCommitString
?
aCommitString
-
>
Length
(
)
:
mDispatchedCompositionString
.
Length
(
)
)
;
if
(
mSelection
.
isSome
(
)
)
{
mSelection
-
>
Collapse
(
offsetToPutCaret
)
;
}
else
{
mSelection
.
emplace
(
offsetToPutCaret
WritingMode
(
)
)
;
}
}
mCompositionState
=
eCompositionState_NotComposing
;
mMaybeInDeadKeySequence
=
false
;
mCompositionStart
=
UINT32_MAX
;
mCompositionTargetRange
.
Clear
(
)
;
mDispatchedCompositionString
.
Truncate
(
)
;
mSelectedStringRemovedByComposition
.
Truncate
(
)
;
if
(
!
dispatcher
)
{
MOZ_ASSERT
(
aCommitString
)
;
MOZ_ASSERT
(
!
aCommitString
-
>
IsEmpty
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetContentCommandEvent
insertTextEvent
(
true
eContentCommandInsertText
lastFocusedWindow
)
;
insertTextEvent
.
mString
.
emplace
(
*
aCommitString
)
;
lastFocusedWindow
-
>
DispatchEvent
(
&
insertTextEvent
status
)
;
if
(
!
insertTextEvent
.
mSucceeded
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
inserting
"
"
text
failed
"
this
)
)
;
return
false
;
}
}
else
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
dispatcher
-
>
CommitComposition
(
status
aCommitString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionChangeEvent
(
)
FAILED
"
"
due
to
CommitComposition
(
)
failure
"
this
)
)
;
return
false
;
}
}
if
(
lastFocusedWindow
-
>
IsDestroyed
(
)
|
|
lastFocusedWindow
!
=
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DispatchCompositionCommitEvent
(
)
FAILED
"
"
the
focused
widget
was
destroyed
/
changed
by
"
"
compositioncommit
event
"
this
)
)
;
return
false
;
}
return
true
;
}
already_AddRefed
<
TextRangeArray
>
IMContextWrapper
:
:
CreateTextRangeArray
(
GtkIMContext
*
aContext
const
nsAString
&
aCompositionString
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
CreateTextRangeArray
(
aContext
=
0x
%
p
"
"
aCompositionString
=
\
"
%
s
\
"
(
Length
(
)
=
%
zu
)
)
"
this
aContext
NS_ConvertUTF16toUTF8
(
aCompositionString
)
.
get
(
)
aCompositionString
.
Length
(
)
)
)
;
RefPtr
<
TextRangeArray
>
textRangeArray
=
new
TextRangeArray
(
)
;
gchar
*
preedit_string
;
gint
cursor_pos_in_chars
;
PangoAttrList
*
feedback_list
;
gtk_im_context_get_preedit_string
(
aContext
&
preedit_string
&
feedback_list
&
cursor_pos_in_chars
)
;
if
(
!
preedit_string
|
|
!
*
preedit_string
)
{
if
(
!
aCompositionString
.
IsEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
CreateTextRangeArray
(
)
FAILED
due
to
"
"
preedit_string
is
null
"
this
)
)
;
}
pango_attr_list_unref
(
feedback_list
)
;
g_free
(
preedit_string
)
;
return
textRangeArray
.
forget
(
)
;
}
uint32_t
caretOffsetInUTF16
=
aCompositionString
.
Length
(
)
;
if
(
NS_WARN_IF
(
cursor_pos_in_chars
<
0
)
)
{
}
else
if
(
cursor_pos_in_chars
=
=
0
)
{
caretOffsetInUTF16
=
0
;
}
else
{
gchar
*
charAfterCaret
=
g_utf8_offset_to_pointer
(
preedit_string
cursor_pos_in_chars
)
;
if
(
NS_WARN_IF
(
!
charAfterCaret
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
CreateTextRangeArray
(
)
failed
to
get
UTF
-
8
"
"
string
before
the
caret
(
cursor_pos_in_chars
=
%
d
)
"
this
cursor_pos_in_chars
)
)
;
}
else
{
glong
caretOffset
=
0
;
gunichar2
*
utf16StrBeforeCaret
=
g_utf8_to_utf16
(
preedit_string
charAfterCaret
-
preedit_string
nullptr
&
caretOffset
nullptr
)
;
if
(
NS_WARN_IF
(
!
utf16StrBeforeCaret
)
|
|
NS_WARN_IF
(
caretOffset
<
0
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
CreateTextRangeArray
(
)
WARNING
failed
to
"
"
convert
to
UTF
-
16
string
before
the
caret
"
"
(
cursor_pos_in_chars
=
%
d
caretOffset
=
%
ld
)
"
this
cursor_pos_in_chars
caretOffset
)
)
;
}
else
{
caretOffsetInUTF16
=
static_cast
<
uint32_t
>
(
caretOffset
)
;
uint32_t
compositionStringLength
=
aCompositionString
.
Length
(
)
;
if
(
NS_WARN_IF
(
caretOffsetInUTF16
>
compositionStringLength
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
CreateTextRangeArray
(
)
WARNING
"
"
caretOffsetInUTF16
=
%
u
is
larger
than
"
"
compositionStringLength
=
%
u
"
this
caretOffsetInUTF16
compositionStringLength
)
)
;
caretOffsetInUTF16
=
compositionStringLength
;
}
}
if
(
utf16StrBeforeCaret
)
{
g_free
(
utf16StrBeforeCaret
)
;
}
}
}
PangoAttrIterator
*
iter
;
iter
=
pango_attr_list_get_iterator
(
feedback_list
)
;
if
(
!
iter
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
CreateTextRangeArray
(
)
FAILED
iterator
couldn
'
t
"
"
be
allocated
"
this
)
)
;
pango_attr_list_unref
(
feedback_list
)
;
g_free
(
preedit_string
)
;
return
textRangeArray
.
forget
(
)
;
}
uint32_t
minOffsetOfClauses
=
aCompositionString
.
Length
(
)
;
uint32_t
maxOffsetOfClauses
=
0
;
do
{
TextRange
range
;
if
(
!
SetTextRange
(
iter
preedit_string
caretOffsetInUTF16
range
)
)
{
continue
;
}
MOZ_ASSERT
(
range
.
Length
(
)
)
;
minOffsetOfClauses
=
std
:
:
min
(
minOffsetOfClauses
range
.
mStartOffset
)
;
maxOffsetOfClauses
=
std
:
:
max
(
maxOffsetOfClauses
range
.
mEndOffset
)
;
textRangeArray
-
>
AppendElement
(
range
)
;
}
while
(
pango_attr_iterator_next
(
iter
)
)
;
if
(
minOffsetOfClauses
)
{
TextRange
dummyClause
;
dummyClause
.
mStartOffset
=
0
;
dummyClause
.
mEndOffset
=
minOffsetOfClauses
;
dummyClause
.
mRangeType
=
TextRangeType
:
:
eRawClause
;
textRangeArray
-
>
InsertElementAt
(
0
dummyClause
)
;
maxOffsetOfClauses
=
std
:
:
max
(
maxOffsetOfClauses
dummyClause
.
mEndOffset
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
CreateTextRangeArray
(
)
inserting
a
dummy
clause
"
"
at
the
beginning
of
the
composition
string
mStartOffset
=
%
u
"
"
mEndOffset
=
%
u
mRangeType
=
%
s
"
this
dummyClause
.
mStartOffset
dummyClause
.
mEndOffset
ToChar
(
dummyClause
.
mRangeType
)
)
)
;
}
if
(
!
textRangeArray
-
>
IsEmpty
(
)
&
&
maxOffsetOfClauses
<
aCompositionString
.
Length
(
)
)
{
TextRange
dummyClause
;
dummyClause
.
mStartOffset
=
maxOffsetOfClauses
;
dummyClause
.
mEndOffset
=
aCompositionString
.
Length
(
)
;
dummyClause
.
mRangeType
=
TextRangeType
:
:
eRawClause
;
textRangeArray
-
>
AppendElement
(
dummyClause
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
CreateTextRangeArray
(
)
inserting
a
dummy
clause
"
"
at
the
end
of
the
composition
string
mStartOffset
=
%
u
"
"
mEndOffset
=
%
u
mRangeType
=
%
s
"
this
dummyClause
.
mStartOffset
dummyClause
.
mEndOffset
ToChar
(
dummyClause
.
mRangeType
)
)
)
;
}
TextRange
range
;
range
.
mStartOffset
=
range
.
mEndOffset
=
caretOffsetInUTF16
;
range
.
mRangeType
=
TextRangeType
:
:
eCaret
;
textRangeArray
-
>
AppendElement
(
range
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
CreateTextRangeArray
(
)
mStartOffset
=
%
u
"
"
mEndOffset
=
%
u
mRangeType
=
%
s
"
this
range
.
mStartOffset
range
.
mEndOffset
ToChar
(
range
.
mRangeType
)
)
)
;
pango_attr_iterator_destroy
(
iter
)
;
pango_attr_list_unref
(
feedback_list
)
;
g_free
(
preedit_string
)
;
return
textRangeArray
.
forget
(
)
;
}
nscolor
IMContextWrapper
:
:
ToNscolor
(
PangoAttrColor
*
aPangoAttrColor
)
{
PangoColor
&
pangoColor
=
aPangoAttrColor
-
>
color
;
uint8_t
r
=
pangoColor
.
red
/
0x100
;
uint8_t
g
=
pangoColor
.
green
/
0x100
;
uint8_t
b
=
pangoColor
.
blue
/
0x100
;
return
NS_RGB
(
r
g
b
)
;
}
bool
IMContextWrapper
:
:
SetTextRange
(
PangoAttrIterator
*
aPangoAttrIter
const
gchar
*
aUTF8CompositionString
uint32_t
aUTF16CaretOffset
TextRange
&
aTextRange
)
const
{
gint
utf8ClauseStart
utf8ClauseEnd
;
pango_attr_iterator_range
(
aPangoAttrIter
&
utf8ClauseStart
&
utf8ClauseEnd
)
;
if
(
utf8ClauseStart
=
=
utf8ClauseEnd
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetTextRange
(
)
FAILED
due
to
collapsed
range
"
this
)
)
;
return
false
;
}
if
(
!
utf8ClauseStart
)
{
aTextRange
.
mStartOffset
=
0
;
}
else
{
glong
utf16PreviousClausesLength
;
gunichar2
*
utf16PreviousClausesString
=
g_utf8_to_utf16
(
aUTF8CompositionString
utf8ClauseStart
nullptr
&
utf16PreviousClausesLength
nullptr
)
;
if
(
NS_WARN_IF
(
!
utf16PreviousClausesString
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetTextRange
(
)
FAILED
due
to
g_utf8_to_utf16
(
)
"
"
failure
(
retrieving
previous
string
of
current
clause
)
"
this
)
)
;
return
false
;
}
aTextRange
.
mStartOffset
=
utf16PreviousClausesLength
;
g_free
(
utf16PreviousClausesString
)
;
}
glong
utf16CurrentClauseLength
;
gunichar2
*
utf16CurrentClauseString
=
g_utf8_to_utf16
(
aUTF8CompositionString
+
utf8ClauseStart
utf8ClauseEnd
-
utf8ClauseStart
nullptr
&
utf16CurrentClauseLength
nullptr
)
;
if
(
NS_WARN_IF
(
!
utf16CurrentClauseString
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetTextRange
(
)
FAILED
due
to
g_utf8_to_utf16
(
)
"
"
failure
(
retrieving
current
clause
)
"
this
)
)
;
return
false
;
}
if
(
!
utf16CurrentClauseLength
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
SetTextRange
(
)
FAILED
due
to
current
clause
length
"
"
is
0
"
this
)
)
;
return
false
;
}
aTextRange
.
mEndOffset
=
aTextRange
.
mStartOffset
+
utf16CurrentClauseLength
;
g_free
(
utf16CurrentClauseString
)
;
utf16CurrentClauseString
=
nullptr
;
TextRangeStyle
&
style
=
aTextRange
.
mRangeStyle
;
PangoAttrInt
*
attrUnderline
=
reinterpret_cast
<
PangoAttrInt
*
>
(
pango_attr_iterator_get
(
aPangoAttrIter
PANGO_ATTR_UNDERLINE
)
)
;
if
(
attrUnderline
)
{
switch
(
attrUnderline
-
>
value
)
{
case
PANGO_UNDERLINE_NONE
:
style
.
mLineStyle
=
TextRangeStyle
:
:
LineStyle
:
:
None
;
break
;
case
PANGO_UNDERLINE_DOUBLE
:
style
.
mLineStyle
=
TextRangeStyle
:
:
LineStyle
:
:
Double
;
break
;
case
PANGO_UNDERLINE_ERROR
:
style
.
mLineStyle
=
TextRangeStyle
:
:
LineStyle
:
:
Wavy
;
break
;
case
PANGO_UNDERLINE_SINGLE
:
case
PANGO_UNDERLINE_LOW
:
style
.
mLineStyle
=
TextRangeStyle
:
:
LineStyle
:
:
Solid
;
break
;
default
:
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
SetTextRange
(
)
retrieved
unknown
underline
"
"
style
:
%
d
"
this
attrUnderline
-
>
value
)
)
;
style
.
mLineStyle
=
TextRangeStyle
:
:
LineStyle
:
:
Solid
;
break
;
}
style
.
mDefinedStyles
|
=
TextRangeStyle
:
:
DEFINED_LINESTYLE
;
PangoAttrColor
*
attrUnderlineColor
=
reinterpret_cast
<
PangoAttrColor
*
>
(
pango_attr_iterator_get
(
aPangoAttrIter
PANGO_ATTR_UNDERLINE_COLOR
)
)
;
if
(
attrUnderlineColor
)
{
style
.
mUnderlineColor
=
ToNscolor
(
attrUnderlineColor
)
;
style
.
mDefinedStyles
|
=
TextRangeStyle
:
:
DEFINED_UNDERLINE_COLOR
;
}
}
else
{
style
.
mLineStyle
=
TextRangeStyle
:
:
LineStyle
:
:
None
;
style
.
mDefinedStyles
|
=
TextRangeStyle
:
:
DEFINED_LINESTYLE
;
}
PangoAttrColor
*
attrForeground
=
reinterpret_cast
<
PangoAttrColor
*
>
(
pango_attr_iterator_get
(
aPangoAttrIter
PANGO_ATTR_FOREGROUND
)
)
;
if
(
attrForeground
)
{
style
.
mForegroundColor
=
ToNscolor
(
attrForeground
)
;
style
.
mDefinedStyles
|
=
TextRangeStyle
:
:
DEFINED_FOREGROUND_COLOR
;
}
PangoAttrColor
*
attrBackground
=
reinterpret_cast
<
PangoAttrColor
*
>
(
pango_attr_iterator_get
(
aPangoAttrIter
PANGO_ATTR_BACKGROUND
)
)
;
if
(
attrBackground
)
{
style
.
mBackgroundColor
=
ToNscolor
(
attrBackground
)
;
style
.
mDefinedStyles
|
=
TextRangeStyle
:
:
DEFINED_BACKGROUND_COLOR
;
}
if
(
!
utf8ClauseStart
&
&
utf8ClauseEnd
=
=
static_cast
<
gint
>
(
strlen
(
aUTF8CompositionString
)
)
&
&
aTextRange
.
mEndOffset
=
=
aUTF16CaretOffset
)
{
aTextRange
.
mRangeType
=
TextRangeType
:
:
eRawClause
;
}
else
if
(
aTextRange
.
mStartOffset
<
=
aUTF16CaretOffset
&
&
aTextRange
.
mEndOffset
>
aUTF16CaretOffset
)
{
aTextRange
.
mRangeType
=
TextRangeType
:
:
eSelectedClause
;
}
else
{
aTextRange
.
mRangeType
=
TextRangeType
:
:
eConvertedClause
;
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
SetTextRange
(
)
succeeded
aTextRange
=
{
"
"
mStartOffset
=
%
u
mEndOffset
=
%
u
mRangeType
=
%
s
mRangeStyle
=
%
s
}
"
this
aTextRange
.
mStartOffset
aTextRange
.
mEndOffset
ToChar
(
aTextRange
.
mRangeType
)
GetTextRangeStyleText
(
aTextRange
.
mRangeStyle
)
.
get
(
)
)
)
;
return
true
;
}
void
IMContextWrapper
:
:
SetCursorPosition
(
GtkIMContext
*
aContext
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
SetCursorPosition
(
aContext
=
0x
%
p
)
"
"
mCompositionTargetRange
=
{
mOffset
=
%
u
mLength
=
%
u
}
mSelection
=
%
s
"
this
aContext
mCompositionTargetRange
.
mOffset
mCompositionTargetRange
.
mLength
ToString
(
mSelection
)
.
c_str
(
)
)
)
;
bool
useCaret
=
false
;
if
(
!
mCompositionTargetRange
.
IsValid
(
)
)
{
if
(
mSelection
.
isNothing
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetCursorPosition
(
)
FAILED
"
"
mCompositionTargetRange
and
mSelection
are
invalid
"
this
)
)
;
return
;
}
if
(
!
mSelection
-
>
HasRange
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
SetCursorPosition
(
)
FAILED
"
"
mCompositionTargetRange
is
invalid
and
there
is
no
selection
"
this
)
)
;
return
;
}
useCaret
=
true
;
}
if
(
!
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetCursorPosition
(
)
FAILED
due
to
no
focused
"
"
window
"
this
)
)
;
return
;
}
if
(
MOZ_UNLIKELY
(
!
aContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetCursorPosition
(
)
FAILED
due
to
no
context
"
this
)
)
;
return
;
}
WidgetQueryContentEvent
queryCaretOrTextRectEvent
(
true
useCaret
?
eQueryCaretRect
:
eQueryTextRect
mLastFocusedWindow
)
;
if
(
useCaret
)
{
queryCaretOrTextRectEvent
.
InitForQueryCaretRect
(
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
)
;
}
else
{
if
(
mSelection
-
>
WritingModeRef
(
)
.
IsVertical
(
)
)
{
uint32_t
length
=
mCompositionTargetRange
.
mLength
?
mCompositionTargetRange
.
mLength
:
1
;
queryCaretOrTextRectEvent
.
InitForQueryTextRect
(
mCompositionTargetRange
.
mOffset
length
)
;
}
else
{
queryCaretOrTextRectEvent
.
InitForQueryTextRect
(
mCompositionTargetRange
.
mOffset
1
)
;
}
}
InitEvent
(
queryCaretOrTextRectEvent
)
;
nsEventStatus
status
;
mLastFocusedWindow
-
>
DispatchEvent
(
&
queryCaretOrTextRectEvent
status
)
;
if
(
queryCaretOrTextRectEvent
.
Failed
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
SetCursorPosition
(
)
FAILED
%
s
was
failed
"
this
useCaret
?
"
eQueryCaretRect
"
:
"
eQueryTextRect
"
)
)
;
return
;
}
nsWindow
*
rootWindow
=
static_cast
<
nsWindow
*
>
(
mLastFocusedWindow
-
>
GetTopLevelWidget
(
)
)
;
LayoutDeviceIntPoint
root
=
rootWindow
-
>
WidgetToScreenOffset
(
)
;
LayoutDeviceIntPoint
owner
=
mOwnerWindow
-
>
WidgetToScreenOffset
(
)
;
LayoutDeviceIntRect
rect
=
queryCaretOrTextRectEvent
.
mReply
-
>
mRect
+
root
-
owner
;
rect
.
width
=
0
;
GdkRectangle
area
=
rootWindow
-
>
DevicePixelsToGdkRectRoundOut
(
rect
)
;
gtk_im_context_set_cursor_location
(
aContext
&
area
)
;
}
nsresult
IMContextWrapper
:
:
GetCurrentParagraph
(
nsAString
&
aText
uint32_t
&
aCursorPos
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
GetCurrentParagraph
(
)
mCompositionState
=
%
s
"
this
GetCompositionStateName
(
)
)
)
;
if
(
!
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
GetCurrentParagraph
(
)
FAILED
there
are
no
"
"
focused
window
in
this
module
"
this
)
)
;
return
NS_ERROR_NULL_POINTER
;
}
nsEventStatus
status
;
uint32_t
selOffset
=
mCompositionStart
;
uint32_t
selLength
=
mSelectedStringRemovedByComposition
.
Length
(
)
;
if
(
!
EditorHasCompositionString
(
)
)
{
if
(
NS_WARN_IF
(
!
EnsureToCacheSelection
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
GetCurrentParagraph
(
)
FAILED
due
to
no
"
"
valid
selection
information
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mSelection
.
isSome
(
)
&
&
mSelection
-
>
HasRange
(
)
)
{
selOffset
=
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
;
selLength
=
mSelection
-
>
OffsetAndDataRef
(
)
.
Length
(
)
;
}
else
{
selOffset
=
0u
;
selLength
=
INT32_MAX
;
}
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
GetCurrentParagraph
(
)
selOffset
=
%
u
selLength
=
%
u
"
this
selOffset
selLength
)
)
;
if
(
selOffset
>
INT32_MAX
|
|
selLength
>
INT32_MAX
|
|
selOffset
+
selLength
>
INT32_MAX
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
GetCurrentParagraph
(
)
FAILED
The
selection
is
"
"
out
of
range
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
WidgetQueryContentEvent
queryTextContentEvent
(
true
eQueryTextContent
mLastFocusedWindow
)
;
queryTextContentEvent
.
InitForQueryTextContent
(
0
UINT32_MAX
)
;
mLastFocusedWindow
-
>
DispatchEvent
(
&
queryTextContentEvent
status
)
;
if
(
NS_WARN_IF
(
queryTextContentEvent
.
Failed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
selOffset
+
selLength
>
queryTextContentEvent
.
mReply
-
>
DataLength
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
GetCurrentParagraph
(
)
FAILED
The
selection
is
"
"
invalid
queryTextContentEvent
=
{
mReply
=
%
s
}
"
this
ToString
(
queryTextContentEvent
.
mReply
)
.
c_str
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAutoString
textContent
(
queryTextContentEvent
.
mReply
-
>
DataRef
(
)
)
;
if
(
EditorHasCompositionString
(
)
&
&
mDispatchedCompositionString
!
=
mSelectedStringRemovedByComposition
)
{
textContent
.
Replace
(
mCompositionStart
mDispatchedCompositionString
.
Length
(
)
mSelectedStringRemovedByComposition
)
;
}
int32_t
parStart
=
(
selOffset
=
=
0
)
?
0
:
textContent
.
RFind
(
"
\
n
"
false
selOffset
-
1
-
1
)
+
1
;
int32_t
parEnd
=
textContent
.
Find
(
"
\
n
"
false
selOffset
+
selLength
-
1
)
;
if
(
parEnd
<
0
)
{
parEnd
=
textContent
.
Length
(
)
;
}
aText
=
nsDependentSubstring
(
textContent
parStart
parEnd
-
parStart
)
;
aCursorPos
=
selOffset
-
uint32_t
(
parStart
)
;
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
GetCurrentParagraph
(
)
succeeded
aText
=
%
s
"
"
aText
.
Length
(
)
=
%
zu
aCursorPos
=
%
u
"
this
NS_ConvertUTF16toUTF8
(
aText
)
.
get
(
)
aText
.
Length
(
)
aCursorPos
)
)
;
return
NS_OK
;
}
nsresult
IMContextWrapper
:
:
DeleteText
(
GtkIMContext
*
aContext
int32_t
aOffset
uint32_t
aNChars
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Info
(
"
0x
%
p
DeleteText
(
aContext
=
0x
%
p
aOffset
=
%
d
aNChars
=
%
u
)
"
"
mCompositionState
=
%
s
"
this
aContext
aOffset
aNChars
GetCompositionStateName
(
)
)
)
;
if
(
!
mLastFocusedWindow
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
there
are
no
focused
window
"
"
in
this
module
"
this
)
)
;
return
NS_ERROR_NULL_POINTER
;
}
if
(
!
aNChars
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
aNChars
must
not
be
zero
"
this
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
RefPtr
<
nsWindow
>
lastFocusedWindow
(
mLastFocusedWindow
)
;
nsEventStatus
status
;
uint32_t
selOffset
;
bool
wasComposing
=
IsComposing
(
)
;
bool
editorHadCompositionString
=
EditorHasCompositionString
(
)
;
if
(
wasComposing
)
{
selOffset
=
mCompositionStart
;
if
(
!
DispatchCompositionCommitEvent
(
aContext
&
mSelectedStringRemovedByComposition
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
quitting
from
DeletText
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
}
else
{
if
(
NS_WARN_IF
(
!
EnsureToCacheSelection
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
due
to
no
valid
selection
"
"
information
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mSelection
-
>
HasRange
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
DeleteText
(
)
does
nothing
due
to
no
selection
range
"
this
)
)
;
return
NS_OK
;
}
selOffset
=
mSelection
-
>
OffsetAndDataRef
(
)
.
StartOffset
(
)
;
}
WidgetQueryContentEvent
queryTextContentEvent
(
true
eQueryTextContent
mLastFocusedWindow
)
;
queryTextContentEvent
.
InitForQueryTextContent
(
0
UINT32_MAX
)
;
mLastFocusedWindow
-
>
DispatchEvent
(
&
queryTextContentEvent
status
)
;
if
(
NS_WARN_IF
(
queryTextContentEvent
.
Failed
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
queryTextContentEvent
.
mReply
-
>
IsDataEmpty
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
there
is
no
contents
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
NS_ConvertUTF16toUTF8
utf8Str
(
nsDependentSubstring
(
queryTextContentEvent
.
mReply
-
>
DataRef
(
)
0
selOffset
)
)
;
glong
offsetInUTF8Characters
=
g_utf8_strlen
(
utf8Str
.
get
(
)
utf8Str
.
Length
(
)
)
+
aOffset
;
if
(
offsetInUTF8Characters
<
0
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
aOffset
is
too
small
for
"
"
current
cursor
pos
(
computed
offset
:
%
ld
)
"
this
offsetInUTF8Characters
)
)
;
return
NS_ERROR_FAILURE
;
}
AppendUTF16toUTF8
(
nsDependentSubstring
(
queryTextContentEvent
.
mReply
-
>
DataRef
(
)
selOffset
)
utf8Str
)
;
glong
countOfCharactersInUTF8
=
g_utf8_strlen
(
utf8Str
.
get
(
)
utf8Str
.
Length
(
)
)
;
glong
endInUTF8Characters
=
offsetInUTF8Characters
+
aNChars
;
if
(
countOfCharactersInUTF8
<
endInUTF8Characters
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
aNChars
is
too
large
for
"
"
current
contents
(
content
length
:
%
ld
computed
end
offset
:
%
ld
)
"
this
countOfCharactersInUTF8
endInUTF8Characters
)
)
;
return
NS_ERROR_FAILURE
;
}
gchar
*
charAtOffset
=
g_utf8_offset_to_pointer
(
utf8Str
.
get
(
)
offsetInUTF8Characters
)
;
gchar
*
charAtEnd
=
g_utf8_offset_to_pointer
(
utf8Str
.
get
(
)
endInUTF8Characters
)
;
WidgetSelectionEvent
selectionEvent
(
true
eSetSelection
mLastFocusedWindow
)
;
nsDependentCSubstring
utf8StrBeforeOffset
(
utf8Str
0
charAtOffset
-
utf8Str
.
get
(
)
)
;
selectionEvent
.
mOffset
=
NS_ConvertUTF8toUTF16
(
utf8StrBeforeOffset
)
.
Length
(
)
;
nsDependentCSubstring
utf8DeletingStr
(
utf8Str
utf8StrBeforeOffset
.
Length
(
)
charAtEnd
-
charAtOffset
)
;
selectionEvent
.
mLength
=
NS_ConvertUTF8toUTF16
(
utf8DeletingStr
)
.
Length
(
)
;
selectionEvent
.
mReversed
=
false
;
selectionEvent
.
mExpandToClusterBoundary
=
false
;
lastFocusedWindow
-
>
DispatchEvent
(
&
selectionEvent
status
)
;
if
(
!
selectionEvent
.
mSucceeded
|
|
lastFocusedWindow
!
=
mLastFocusedWindow
|
|
lastFocusedWindow
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
setting
selection
caused
"
"
focus
change
or
window
destroyed
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
MaybeDispatchKeyEventAsProcessedByIME
(
eContentCommandDelete
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Warning
(
"
0x
%
p
DeleteText
(
)
Warning
"
"
MaybeDispatchKeyEventAsProcessedByIME
(
)
returned
false
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
WidgetContentCommandEvent
contentCommandEvent
(
true
eContentCommandDelete
mLastFocusedWindow
)
;
mLastFocusedWindow
-
>
DispatchEvent
(
&
contentCommandEvent
status
)
;
if
(
!
contentCommandEvent
.
mSucceeded
|
|
lastFocusedWindow
!
=
mLastFocusedWindow
|
|
lastFocusedWindow
-
>
Destroyed
(
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
deleting
the
selection
caused
"
"
focus
change
or
window
destroyed
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
wasComposing
)
{
return
NS_OK
;
}
if
(
!
DispatchCompositionStart
(
aContext
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
resterting
composition
start
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
editorHadCompositionString
)
{
return
NS_OK
;
}
nsAutoString
compositionString
;
GetCompositionString
(
aContext
compositionString
)
;
if
(
!
DispatchCompositionChangeEvent
(
aContext
compositionString
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
DeleteText
(
)
FAILED
restoring
composition
string
"
this
)
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
IMContextWrapper
:
:
InitEvent
(
WidgetGUIEvent
&
aEvent
)
{
aEvent
.
mTime
=
PR_Now
(
)
/
1000
;
}
bool
IMContextWrapper
:
:
EnsureToCacheSelection
(
nsAString
*
aSelectedString
)
{
if
(
aSelectedString
)
{
aSelectedString
-
>
Truncate
(
)
;
}
if
(
mSelection
.
isSome
(
)
)
{
if
(
mSelection
-
>
HasRange
(
)
&
&
aSelectedString
)
{
aSelectedString
-
>
Assign
(
mSelection
-
>
OffsetAndDataRef
(
)
.
DataRef
(
)
)
;
}
return
true
;
}
if
(
NS_WARN_IF
(
!
mLastFocusedWindow
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
EnsureToCacheSelection
(
)
FAILED
due
to
"
"
no
focused
window
"
this
)
)
;
return
false
;
}
nsEventStatus
status
;
WidgetQueryContentEvent
querySelectedTextEvent
(
true
eQuerySelectedText
mLastFocusedWindow
)
;
InitEvent
(
querySelectedTextEvent
)
;
mLastFocusedWindow
-
>
DispatchEvent
(
&
querySelectedTextEvent
status
)
;
if
(
NS_WARN_IF
(
querySelectedTextEvent
.
Failed
(
)
)
)
{
MOZ_LOG
(
gIMELog
LogLevel
:
:
Error
(
"
0x
%
p
EnsureToCacheSelection
(
)
FAILED
due
to
"
"
failure
of
query
selection
event
"
this
)
)
;
return
false
;
}
mSelection
=
Some
(
Selection
(
querySelectedTextEvent
)
)
;
if
(
mSelection
-
>
HasRange
(
)
)
{
if
(
!
mSelection
-
>
OffsetAndDataRef
(
)
.
IsDataEmpty
(
)
&
&
aSelectedString
)
{
aSelectedString
-
>
Assign
(
querySelectedTextEvent
.
mReply
-
>
DataRef
(
)
)
;
}
}
MOZ_LOG
(
gIMELog
LogLevel
:
:
Debug
(
"
0x
%
p
EnsureToCacheSelection
(
)
Succeeded
mSelection
=
%
s
"
this
ToString
(
mSelection
)
.
c_str
(
)
)
)
;
return
true
;
}
}
}
