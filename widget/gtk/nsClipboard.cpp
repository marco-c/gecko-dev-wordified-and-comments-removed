#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
nsClipboardX11
.
h
"
#
if
defined
(
MOZ_WAYLAND
)
#
include
"
nsClipboardWayland
.
h
"
#
endif
#
include
"
HeadlessClipboard
.
h
"
#
include
"
nsSupportsPrimitives
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsImageToPixbuf
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
<
gtk
/
gtk
.
h
>
#
include
<
gtk
/
gtkx
.
h
>
#
include
"
mozilla
/
Encoding
.
h
"
using
namespace
mozilla
;
const
int
kClipboardTimeout
=
500000
;
void
clipboard_get_cb
(
GtkClipboard
*
aGtkClipboard
GtkSelectionData
*
aSelectionData
guint
info
gpointer
user_data
)
;
void
clipboard_clear_cb
(
GtkClipboard
*
aGtkClipboard
gpointer
user_data
)
;
static
void
ConvertHTMLtoUCS2
(
const
char
*
data
int32_t
dataLength
char16_t
*
*
unicodeData
int32_t
&
outUnicodeLen
)
;
static
void
GetHTMLCharset
(
const
char
*
data
int32_t
dataLength
nsCString
&
str
)
;
GdkAtom
GetSelectionAtom
(
int32_t
aWhichClipboard
)
{
if
(
aWhichClipboard
=
=
nsIClipboard
:
:
kGlobalClipboard
)
return
GDK_SELECTION_CLIPBOARD
;
return
GDK_SELECTION_PRIMARY
;
}
nsClipboard
:
:
nsClipboard
(
)
{
}
nsClipboard
:
:
~
nsClipboard
(
)
{
if
(
mGlobalTransferable
)
{
gtk_clipboard_clear
(
gtk_clipboard_get
(
GDK_SELECTION_CLIPBOARD
)
)
;
}
if
(
mSelectionTransferable
)
{
gtk_clipboard_clear
(
gtk_clipboard_get
(
GDK_SELECTION_PRIMARY
)
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsClipboard
nsIClipboard
)
nsresult
nsClipboard
:
:
Init
(
void
)
{
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
if
(
!
display
|
|
GDK_IS_X11_DISPLAY
(
display
)
)
{
mContext
=
new
nsRetrievalContextX11
(
)
;
#
if
defined
(
MOZ_WAYLAND
)
}
else
{
mContext
=
new
nsRetrievalContextWayland
(
)
;
#
endif
}
NS_ASSERTION
(
mContext
"
Missing
nsRetrievalContext
for
nsClipboard
!
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
os
-
>
AddObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
}
return
NS_OK
;
}
nsresult
nsClipboard
:
:
Store
(
void
)
{
if
(
mGlobalTransferable
)
{
GtkClipboard
*
clipboard
=
gtk_clipboard_get
(
GDK_SELECTION_CLIPBOARD
)
;
gtk_clipboard_store
(
clipboard
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsClipboard
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
Store
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsClipboard
:
:
SetData
(
nsITransferable
*
aTransferable
nsIClipboardOwner
*
aOwner
int32_t
aWhichClipboard
)
{
if
(
(
aWhichClipboard
=
=
kGlobalClipboard
&
&
aTransferable
=
=
mGlobalTransferable
.
get
(
)
&
&
aOwner
=
=
mGlobalOwner
.
get
(
)
)
|
|
(
aWhichClipboard
=
=
kSelectionClipboard
&
&
aTransferable
=
=
mSelectionTransferable
.
get
(
)
&
&
aOwner
=
=
mSelectionOwner
.
get
(
)
)
)
{
return
NS_OK
;
}
EmptyClipboard
(
aWhichClipboard
)
;
GtkTargetList
*
list
=
gtk_target_list_new
(
nullptr
0
)
;
nsCOMPtr
<
nsIArray
>
flavors
;
nsresult
rv
=
aTransferable
-
>
FlavorsTransferableCanExport
(
getter_AddRefs
(
flavors
)
)
;
if
(
!
flavors
|
|
NS_FAILED
(
rv
)
)
return
NS_ERROR_FAILURE
;
bool
imagesAdded
=
false
;
uint32_t
count
;
flavors
-
>
GetLength
(
&
count
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
nsCOMPtr
<
nsISupportsCString
>
flavor
=
do_QueryElementAt
(
flavors
i
)
;
if
(
flavor
)
{
nsCString
flavorStr
;
flavor
-
>
ToString
(
getter_Copies
(
flavorStr
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
gtk_target_list_add
(
list
gdk_atom_intern
(
"
UTF8_STRING
"
FALSE
)
0
0
)
;
gtk_target_list_add
(
list
gdk_atom_intern
(
"
COMPOUND_TEXT
"
FALSE
)
0
0
)
;
gtk_target_list_add
(
list
gdk_atom_intern
(
"
TEXT
"
FALSE
)
0
0
)
;
gtk_target_list_add
(
list
GDK_SELECTION_TYPE_STRING
0
0
)
;
continue
;
}
if
(
flavorStr
.
EqualsLiteral
(
kNativeImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kPNGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kGIFImageMime
)
)
{
if
(
!
imagesAdded
)
{
gtk_target_list_add_image_targets
(
list
0
TRUE
)
;
imagesAdded
=
true
;
}
continue
;
}
GdkAtom
atom
=
gdk_atom_intern
(
flavorStr
.
get
(
)
FALSE
)
;
gtk_target_list_add
(
list
atom
0
0
)
;
}
}
GtkClipboard
*
gtkClipboard
=
gtk_clipboard_get
(
GetSelectionAtom
(
aWhichClipboard
)
)
;
gint
numTargets
;
GtkTargetEntry
*
gtkTargets
=
gtk_target_table_new_from_list
(
list
&
numTargets
)
;
if
(
gtkTargets
&
&
gtk_clipboard_set_with_data
(
gtkClipboard
gtkTargets
numTargets
clipboard_get_cb
clipboard_clear_cb
this
)
)
{
if
(
aWhichClipboard
=
=
kSelectionClipboard
)
{
mSelectionOwner
=
aOwner
;
mSelectionTransferable
=
aTransferable
;
}
else
{
mGlobalOwner
=
aOwner
;
mGlobalTransferable
=
aTransferable
;
gtk_clipboard_set_can_store
(
gtkClipboard
gtkTargets
numTargets
)
;
}
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
gtk_target_table_free
(
gtkTargets
numTargets
)
;
gtk_target_list_unref
(
list
)
;
return
rv
;
}
void
nsClipboard
:
:
SetTransferableData
(
nsITransferable
*
aTransferable
nsCString
&
aFlavor
const
char
*
aClipboardData
uint32_t
aClipboardDataLength
)
{
nsCOMPtr
<
nsISupports
>
wrapper
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
aFlavor
aClipboardData
aClipboardDataLength
getter_AddRefs
(
wrapper
)
)
;
aTransferable
-
>
SetTransferData
(
aFlavor
.
get
(
)
wrapper
aClipboardDataLength
)
;
}
NS_IMETHODIMP
nsClipboard
:
:
GetData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
)
{
if
(
!
aTransferable
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIArray
>
flavors
;
nsresult
rv
;
rv
=
aTransferable
-
>
FlavorsTransferableCanImport
(
getter_AddRefs
(
flavors
)
)
;
if
(
!
flavors
|
|
NS_FAILED
(
rv
)
)
return
NS_ERROR_FAILURE
;
uint32_t
count
;
flavors
-
>
GetLength
(
&
count
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
nsCOMPtr
<
nsISupportsCString
>
currentFlavor
;
currentFlavor
=
do_QueryElementAt
(
flavors
i
)
;
if
(
!
currentFlavor
)
continue
;
nsCString
flavorStr
;
currentFlavor
-
>
ToString
(
getter_Copies
(
flavorStr
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kPNGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kGIFImageMime
)
)
{
if
(
flavorStr
.
EqualsLiteral
(
kJPGImageMime
)
)
{
flavorStr
.
Assign
(
kJPEGImageMime
)
;
}
uint32_t
clipboardDataLength
;
const
char
*
clipboardData
=
mContext
-
>
GetClipboardData
(
flavorStr
.
get
(
)
aWhichClipboard
&
clipboardDataLength
)
;
if
(
!
clipboardData
)
continue
;
nsCOMPtr
<
nsIInputStream
>
byteStream
;
NS_NewByteInputStream
(
getter_AddRefs
(
byteStream
)
clipboardData
clipboardDataLength
NS_ASSIGNMENT_COPY
)
;
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
byteStream
sizeof
(
nsIInputStream
*
)
)
;
mContext
-
>
ReleaseClipboardData
(
clipboardData
)
;
return
NS_OK
;
}
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
const
char
*
clipboardData
=
mContext
-
>
GetClipboardText
(
aWhichClipboard
)
;
if
(
!
clipboardData
)
{
continue
;
}
NS_ConvertUTF8toUTF16
ucs2string
(
clipboardData
)
;
const
char
*
unicodeData
=
(
const
char
*
)
ToNewUnicode
(
ucs2string
)
;
uint32_t
unicodeDataLength
=
ucs2string
.
Length
(
)
*
2
;
SetTransferableData
(
aTransferable
flavorStr
unicodeData
unicodeDataLength
)
;
free
(
(
void
*
)
unicodeData
)
;
mContext
-
>
ReleaseClipboardData
(
clipboardData
)
;
return
NS_OK
;
}
uint32_t
clipboardDataLength
;
const
char
*
clipboardData
=
mContext
-
>
GetClipboardData
(
flavorStr
.
get
(
)
aWhichClipboard
&
clipboardDataLength
)
;
if
(
clipboardData
)
{
if
(
flavorStr
.
EqualsLiteral
(
kHTMLMime
)
)
{
char16_t
*
htmlBody
=
nullptr
;
int32_t
htmlBodyLen
=
0
;
ConvertHTMLtoUCS2
(
clipboardData
clipboardDataLength
&
htmlBody
htmlBodyLen
)
;
if
(
!
htmlBodyLen
)
{
mContext
-
>
ReleaseClipboardData
(
clipboardData
)
;
continue
;
}
SetTransferableData
(
aTransferable
flavorStr
(
const
char
*
)
htmlBody
htmlBodyLen
*
2
)
;
free
(
htmlBody
)
;
}
else
{
SetTransferableData
(
aTransferable
flavorStr
clipboardData
clipboardDataLength
)
;
}
mContext
-
>
ReleaseClipboardData
(
clipboardData
)
;
return
NS_OK
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsClipboard
:
:
EmptyClipboard
(
int32_t
aWhichClipboard
)
{
if
(
aWhichClipboard
=
=
kSelectionClipboard
)
{
if
(
mSelectionOwner
)
{
mSelectionOwner
-
>
LosingOwnership
(
mSelectionTransferable
)
;
mSelectionOwner
=
nullptr
;
}
mSelectionTransferable
=
nullptr
;
}
else
{
if
(
mGlobalOwner
)
{
mGlobalOwner
-
>
LosingOwnership
(
mGlobalTransferable
)
;
mGlobalOwner
=
nullptr
;
}
mGlobalTransferable
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsClipboard
:
:
HasDataMatchingFlavors
(
const
char
*
*
aFlavorList
uint32_t
aLength
int32_t
aWhichClipboard
bool
*
_retval
)
{
if
(
!
aFlavorList
|
|
!
_retval
)
return
NS_ERROR_NULL_POINTER
;
*
_retval
=
false
;
int
targetNums
;
GdkAtom
*
targets
=
mContext
-
>
GetTargets
(
aWhichClipboard
&
targetNums
)
;
if
(
!
targets
)
return
NS_OK
;
for
(
uint32_t
i
=
0
;
i
<
aLength
&
&
!
*
_retval
;
i
+
+
)
{
if
(
!
strcmp
(
aFlavorList
[
i
]
kUnicodeMime
)
&
&
gtk_targets_include_text
(
targets
targetNums
)
)
{
*
_retval
=
true
;
break
;
}
for
(
int32_t
j
=
0
;
j
<
targetNums
;
j
+
+
)
{
gchar
*
atom_name
=
gdk_atom_name
(
targets
[
j
]
)
;
if
(
!
atom_name
)
continue
;
if
(
!
strcmp
(
atom_name
aFlavorList
[
i
]
)
)
*
_retval
=
true
;
if
(
!
strcmp
(
aFlavorList
[
i
]
kJPGImageMime
)
&
&
!
strcmp
(
atom_name
kJPEGImageMime
)
)
{
*
_retval
=
true
;
}
g_free
(
atom_name
)
;
if
(
*
_retval
)
break
;
}
}
g_free
(
targets
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsClipboard
:
:
SupportsSelectionClipboard
(
bool
*
_retval
)
{
*
_retval
=
mContext
-
>
HasSelectionSupport
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsClipboard
:
:
SupportsFindClipboard
(
bool
*
_retval
)
{
*
_retval
=
false
;
return
NS_OK
;
}
nsITransferable
*
nsClipboard
:
:
GetTransferable
(
int32_t
aWhichClipboard
)
{
nsITransferable
*
retval
;
if
(
aWhichClipboard
=
=
kSelectionClipboard
)
retval
=
mSelectionTransferable
.
get
(
)
;
else
retval
=
mGlobalTransferable
.
get
(
)
;
return
retval
;
}
void
nsClipboard
:
:
SelectionGetEvent
(
GtkClipboard
*
aClipboard
GtkSelectionData
*
aSelectionData
)
{
int32_t
whichClipboard
;
GdkAtom
selection
=
gtk_selection_data_get_selection
(
aSelectionData
)
;
if
(
selection
=
=
GDK_SELECTION_PRIMARY
)
whichClipboard
=
kSelectionClipboard
;
else
if
(
selection
=
=
GDK_SELECTION_CLIPBOARD
)
whichClipboard
=
kGlobalClipboard
;
else
return
;
nsCOMPtr
<
nsITransferable
>
trans
=
GetTransferable
(
whichClipboard
)
;
if
(
!
trans
)
{
#
ifdef
DEBUG_CLIPBOARD
printf
(
"
nsClipboard
:
:
SelectionGetEvent
(
)
-
%
s
clipboard
is
empty
!
\
n
"
whichClipboard
=
=
kSelectionClipboard
?
"
Selection
"
:
"
Global
"
)
;
#
endif
return
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
item
;
uint32_t
len
;
GdkAtom
selectionTarget
=
gtk_selection_data_get_target
(
aSelectionData
)
;
if
(
selectionTarget
=
=
gdk_atom_intern
(
"
STRING
"
FALSE
)
|
|
selectionTarget
=
=
gdk_atom_intern
(
"
TEXT
"
FALSE
)
|
|
selectionTarget
=
=
gdk_atom_intern
(
"
COMPOUND_TEXT
"
FALSE
)
|
|
selectionTarget
=
=
gdk_atom_intern
(
"
UTF8_STRING
"
FALSE
)
)
{
rv
=
trans
-
>
GetTransferData
(
"
text
/
unicode
"
getter_AddRefs
(
item
)
&
len
)
;
if
(
!
item
|
|
NS_FAILED
(
rv
)
)
return
;
nsCOMPtr
<
nsISupportsString
>
wideString
;
wideString
=
do_QueryInterface
(
item
)
;
if
(
!
wideString
)
return
;
nsAutoString
ucs2string
;
wideString
-
>
GetData
(
ucs2string
)
;
char
*
utf8string
=
ToNewUTF8String
(
ucs2string
)
;
if
(
!
utf8string
)
return
;
gtk_selection_data_set_text
(
aSelectionData
utf8string
strlen
(
utf8string
)
)
;
free
(
utf8string
)
;
return
;
}
if
(
gtk_targets_include_image
(
&
selectionTarget
1
TRUE
)
)
{
static
const
char
*
const
imageMimeTypes
[
]
=
{
kNativeImageMime
kPNGImageMime
kJPEGImageMime
kJPGImageMime
kGIFImageMime
}
;
nsCOMPtr
<
nsISupports
>
imageItem
;
nsCOMPtr
<
nsISupportsInterfacePointer
>
ptrPrimitive
;
for
(
uint32_t
i
=
0
;
!
ptrPrimitive
&
&
i
<
ArrayLength
(
imageMimeTypes
)
;
i
+
+
)
{
rv
=
trans
-
>
GetTransferData
(
imageMimeTypes
[
i
]
getter_AddRefs
(
imageItem
)
&
len
)
;
ptrPrimitive
=
do_QueryInterface
(
imageItem
)
;
}
if
(
!
ptrPrimitive
)
return
;
nsCOMPtr
<
nsISupports
>
primitiveData
;
ptrPrimitive
-
>
GetData
(
getter_AddRefs
(
primitiveData
)
)
;
nsCOMPtr
<
imgIContainer
>
image
(
do_QueryInterface
(
primitiveData
)
)
;
if
(
!
image
)
return
;
GdkPixbuf
*
pixbuf
=
nsImageToPixbuf
:
:
ImageToPixbuf
(
image
)
;
if
(
!
pixbuf
)
return
;
gtk_selection_data_set_pixbuf
(
aSelectionData
pixbuf
)
;
g_object_unref
(
pixbuf
)
;
return
;
}
gchar
*
target_name
=
gdk_atom_name
(
selectionTarget
)
;
if
(
!
target_name
)
return
;
rv
=
trans
-
>
GetTransferData
(
target_name
getter_AddRefs
(
item
)
&
len
)
;
if
(
!
item
|
|
NS_FAILED
(
rv
)
)
{
g_free
(
target_name
)
;
return
;
}
void
*
primitive_data
=
nullptr
;
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
nsDependentCString
(
target_name
)
item
&
primitive_data
len
)
;
if
(
primitive_data
)
{
if
(
selectionTarget
=
=
gdk_atom_intern
(
kHTMLMime
FALSE
)
)
{
guchar
*
buffer
=
(
guchar
*
)
g_malloc
(
(
len
*
sizeof
(
guchar
)
)
+
sizeof
(
char16_t
)
)
;
if
(
!
buffer
)
return
;
char16_t
prefix
=
0xFEFF
;
memcpy
(
buffer
&
prefix
sizeof
(
prefix
)
)
;
memcpy
(
buffer
+
sizeof
(
prefix
)
primitive_data
len
)
;
g_free
(
(
guchar
*
)
primitive_data
)
;
primitive_data
=
(
guchar
*
)
buffer
;
len
+
=
sizeof
(
prefix
)
;
}
gtk_selection_data_set
(
aSelectionData
selectionTarget
8
(
const
guchar
*
)
primitive_data
len
)
;
g_free
(
primitive_data
)
;
}
g_free
(
target_name
)
;
}
void
nsClipboard
:
:
SelectionClearEvent
(
GtkClipboard
*
aGtkClipboard
)
{
int32_t
whichClipboard
;
if
(
aGtkClipboard
=
=
gtk_clipboard_get
(
GDK_SELECTION_PRIMARY
)
)
whichClipboard
=
kSelectionClipboard
;
else
if
(
aGtkClipboard
=
=
gtk_clipboard_get
(
GDK_SELECTION_CLIPBOARD
)
)
whichClipboard
=
kGlobalClipboard
;
else
return
;
EmptyClipboard
(
whichClipboard
)
;
}
void
clipboard_get_cb
(
GtkClipboard
*
aGtkClipboard
GtkSelectionData
*
aSelectionData
guint
info
gpointer
user_data
)
{
nsClipboard
*
aClipboard
=
static_cast
<
nsClipboard
*
>
(
user_data
)
;
aClipboard
-
>
SelectionGetEvent
(
aGtkClipboard
aSelectionData
)
;
}
void
clipboard_clear_cb
(
GtkClipboard
*
aGtkClipboard
gpointer
user_data
)
{
nsClipboard
*
aClipboard
=
static_cast
<
nsClipboard
*
>
(
user_data
)
;
aClipboard
-
>
SelectionClearEvent
(
aGtkClipboard
)
;
}
void
ConvertHTMLtoUCS2
(
const
char
*
data
int32_t
dataLength
char16_t
*
*
unicodeData
int32_t
&
outUnicodeLen
)
{
nsAutoCString
charset
;
GetHTMLCharset
(
data
dataLength
charset
)
;
if
(
charset
.
EqualsLiteral
(
"
UTF
-
16
"
)
)
{
outUnicodeLen
=
(
dataLength
/
2
)
-
1
;
*
unicodeData
=
reinterpret_cast
<
char16_t
*
>
(
moz_xmalloc
(
(
outUnicodeLen
+
sizeof
(
'
\
0
'
)
)
*
sizeof
(
char16_t
)
)
)
;
if
(
*
unicodeData
)
{
memcpy
(
*
unicodeData
data
+
sizeof
(
char16_t
)
outUnicodeLen
*
sizeof
(
char16_t
)
)
;
(
*
unicodeData
)
[
outUnicodeLen
]
=
'
\
0
'
;
}
}
else
if
(
charset
.
EqualsLiteral
(
"
UNKNOWN
"
)
)
{
outUnicodeLen
=
0
;
return
;
}
else
{
auto
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
charset
)
;
if
(
!
encoding
)
{
#
ifdef
DEBUG_CLIPBOARD
g_print
(
"
get
unicode
decoder
error
\
n
"
)
;
#
endif
outUnicodeLen
=
0
;
return
;
}
auto
decoder
=
encoding
-
>
NewDecoder
(
)
;
CheckedInt
<
size_t
>
needed
=
decoder
-
>
MaxUTF16BufferLength
(
dataLength
)
;
if
(
!
needed
.
isValid
(
)
|
|
needed
.
value
(
)
>
INT32_MAX
)
{
outUnicodeLen
=
0
;
return
;
}
outUnicodeLen
=
0
;
if
(
needed
.
value
(
)
)
{
*
unicodeData
=
reinterpret_cast
<
char16_t
*
>
(
moz_xmalloc
(
(
needed
.
value
(
)
+
1
)
*
sizeof
(
char16_t
)
)
)
;
if
(
*
unicodeData
)
{
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
Tie
(
result
read
written
hadErrors
)
=
decoder
-
>
DecodeToUTF16
(
AsBytes
(
MakeSpan
(
data
dataLength
)
)
MakeSpan
(
*
unicodeData
needed
.
value
(
)
)
true
)
;
MOZ_ASSERT
(
result
=
=
kInputEmpty
)
;
MOZ_ASSERT
(
read
=
=
size_t
(
dataLength
)
)
;
MOZ_ASSERT
(
written
<
=
needed
.
value
(
)
)
;
Unused
<
<
hadErrors
;
#
ifdef
DEBUG_CLIPBOARD
if
(
read
!
=
dataLength
)
printf
(
"
didn
'
t
consume
all
the
bytes
\
n
"
)
;
#
endif
outUnicodeLen
=
written
;
(
*
unicodeData
)
[
outUnicodeLen
]
=
'
\
0
'
;
}
}
}
}
void
GetHTMLCharset
(
const
char
*
data
int32_t
dataLength
nsCString
&
str
)
{
char16_t
*
beginChar
=
(
char16_t
*
)
data
;
if
(
(
beginChar
[
0
]
=
=
0xFFFE
)
|
|
(
beginChar
[
0
]
=
=
0xFEFF
)
)
{
str
.
AssignLiteral
(
"
UTF
-
16
"
)
;
return
;
}
const
nsDependentCString
htmlStr
(
data
dataLength
)
;
nsACString
:
:
const_iterator
start
end
;
htmlStr
.
BeginReading
(
start
)
;
htmlStr
.
EndReading
(
end
)
;
nsACString
:
:
const_iterator
valueStart
(
start
)
valueEnd
(
start
)
;
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_CSTRING
(
"
CONTENT
=
\
"
text
/
html
;
"
)
start
end
)
)
{
start
=
end
;
htmlStr
.
EndReading
(
end
)
;
if
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_CSTRING
(
"
charset
=
"
)
start
end
)
)
{
valueStart
=
end
;
start
=
end
;
htmlStr
.
EndReading
(
end
)
;
if
(
FindCharInReadable
(
'
"
'
start
end
)
)
valueEnd
=
start
;
}
}
if
(
valueStart
!
=
valueEnd
)
{
str
=
Substring
(
valueStart
valueEnd
)
;
ToUpperCase
(
str
)
;
#
ifdef
DEBUG_CLIPBOARD
printf
(
"
Charset
of
HTML
=
%
s
\
n
"
charsetUpperStr
.
get
(
)
)
;
#
endif
return
;
}
str
.
AssignLiteral
(
"
UNKNOWN
"
)
;
}
