#
include
"
nsDragService
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
prtime
.
h
"
#
include
"
prthread
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
include
"
GRefPtr
.
h
"
#
ifdef
MOZ_X11
#
include
"
gfxXlibSurface
.
h
"
#
endif
#
include
"
gfxContext
.
h
"
#
include
"
nsImageToPixbuf
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsGtkUtils
.
h
"
#
include
"
nsGtkKeyUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
ScreenHelperGTK
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsDirectoryService
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
#
define
NS_DND_TIMEOUT
1000000
#
define
NS_SYSTEMINFO_CONTRACTID
"
mozilla
.
org
/
system
-
info
;
1
"
#
define
DRAG_IMAGE_ALPHA_LEVEL
0
.
5
enum
{
MOZ_GTK_DRAG_RESULT_SUCCESS
MOZ_GTK_DRAG_RESULT_NO_TARGET
MOZ_GTK_DRAG_RESULT_USER_CANCELLED
MOZ_GTK_DRAG_RESULT_TIMEOUT_EXPIRED
MOZ_GTK_DRAG_RESULT_GRAB_BROKEN
MOZ_GTK_DRAG_RESULT_ERROR
}
;
#
ifdef
MOZ_LOGGING
extern
mozilla
:
:
LazyLogModule
gWidgetDragLog
;
#
define
LOGDRAGSERVICE
(
args
)
\
MOZ_LOG
(
gWidgetDragLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
else
#
define
LOGDRAGSERVICE
(
args
)
#
endif
static
guint
sMotionEventTimerID
;
static
GdkEvent
*
sMotionEvent
;
static
GtkWidget
*
sGrabWidget
;
static
const
char
gMimeListType
[
]
=
"
application
/
x
-
moz
-
internal
-
item
-
list
"
;
static
const
char
gMozUrlType
[
]
=
"
_NETSCAPE_URL
"
;
static
const
char
gTextUriListType
[
]
=
"
text
/
uri
-
list
"
;
static
const
char
gTextPlainUTF8Type
[
]
=
"
text
/
plain
;
charset
=
utf
-
8
"
;
static
const
char
gXdndDirectSaveType
[
]
=
"
XdndDirectSave0
"
;
static
const
char
gTabDropType
[
]
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
static
void
invisibleSourceDragBegin
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
;
static
void
invisibleSourceDragEnd
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
;
static
gboolean
invisibleSourceDragFailed
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aResult
gpointer
aData
)
;
static
void
invisibleSourceDragDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
;
nsDragService
:
:
nsDragService
(
)
:
mScheduledTask
(
eDragTaskNone
)
mTaskSource
(
0
)
mScheduledTaskIsRunning
(
false
)
mCachedDragContext
(
)
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obsServ
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
mHiddenWidget
=
gtk_offscreen_window_new
(
)
;
gtk_widget_realize
(
mHiddenWidget
)
;
g_signal_connect
(
mHiddenWidget
"
drag_begin
"
G_CALLBACK
(
invisibleSourceDragBegin
)
this
)
;
g_signal_connect
(
mHiddenWidget
"
drag_data_get
"
G_CALLBACK
(
invisibleSourceDragDataGet
)
this
)
;
g_signal_connect
(
mHiddenWidget
"
drag_end
"
G_CALLBACK
(
invisibleSourceDragEnd
)
this
)
;
guint
dragFailedID
=
g_signal_lookup
(
"
drag
-
failed
"
G_TYPE_FROM_INSTANCE
(
mHiddenWidget
)
)
;
if
(
dragFailedID
)
{
g_signal_connect_closure_by_id
(
mHiddenWidget
dragFailedID
0
g_cclosure_new
(
G_CALLBACK
(
invisibleSourceDragFailed
)
this
nullptr
)
FALSE
)
;
}
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
nsDragService
"
)
)
;
mCanDrop
=
widget
:
:
GdkIsWaylandDisplay
(
)
;
mTargetDragDataReceived
=
false
;
mTargetDragData
=
0
;
mTargetDragDataLen
=
0
;
mTempFileTimerID
=
0
;
}
nsDragService
:
:
~
nsDragService
(
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
~
nsDragService
"
)
)
;
if
(
mTaskSource
)
g_source_remove
(
mTaskSource
)
;
if
(
mTempFileTimerID
)
g_source_remove
(
mTempFileTimerID
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsDragService
nsBaseDragService
nsIObserver
)
mozilla
:
:
StaticRefPtr
<
nsDragService
>
sDragServiceInstance
;
already_AddRefed
<
nsDragService
>
nsDragService
:
:
GetInstance
(
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
nullptr
;
}
if
(
!
sDragServiceInstance
)
{
sDragServiceInstance
=
new
nsDragService
(
)
;
ClearOnShutdown
(
&
sDragServiceInstance
)
;
}
RefPtr
<
nsDragService
>
service
=
sDragServiceInstance
.
get
(
)
;
return
service
.
forget
(
)
;
}
NS_IMETHODIMP
nsDragService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
quit
-
application
"
)
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
Observe
(
\
"
quit
-
application
\
"
)
"
)
)
;
if
(
mHiddenWidget
)
{
gtk_widget_destroy
(
mHiddenWidget
)
;
mHiddenWidget
=
0
;
}
TargetResetData
(
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
topic
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
static
gboolean
DispatchMotionEventCopy
(
gpointer
aData
)
{
sMotionEventTimerID
=
0
;
GdkEvent
*
event
=
sMotionEvent
;
sMotionEvent
=
nullptr
;
if
(
gtk_widget_has_grab
(
sGrabWidget
)
)
{
gtk_propagate_event
(
sGrabWidget
event
)
;
}
gdk_event_free
(
event
)
;
return
FALSE
;
}
static
void
OnSourceGrabEventAfter
(
GtkWidget
*
widget
GdkEvent
*
event
gpointer
user_data
)
{
if
(
!
gtk_widget_has_grab
(
sGrabWidget
)
)
return
;
if
(
event
-
>
type
=
=
GDK_MOTION_NOTIFY
)
{
if
(
sMotionEvent
)
{
gdk_event_free
(
sMotionEvent
)
;
}
sMotionEvent
=
gdk_event_copy
(
event
)
;
nsDragService
*
dragService
=
static_cast
<
nsDragService
*
>
(
user_data
)
;
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
auto
p
=
LayoutDeviceIntPoint
:
:
Round
(
event
-
>
motion
.
x_root
*
scale
event
-
>
motion
.
y_root
*
scale
)
;
dragService
-
>
SetDragEndPoint
(
p
)
;
}
else
if
(
sMotionEvent
&
&
(
event
-
>
type
=
=
GDK_KEY_PRESS
|
|
event
-
>
type
=
=
GDK_KEY_RELEASE
)
)
{
sMotionEvent
-
>
motion
.
state
=
event
-
>
key
.
state
;
}
else
{
return
;
}
if
(
sMotionEventTimerID
)
{
g_source_remove
(
sMotionEventTimerID
)
;
}
sMotionEventTimerID
=
g_timeout_add_full
(
G_PRIORITY_DEFAULT_IDLE
350
DispatchMotionEventCopy
nullptr
nullptr
)
;
}
static
GtkWindow
*
GetGtkWindow
(
dom
:
:
Document
*
aDocument
)
{
if
(
!
aDocument
)
return
nullptr
;
PresShell
*
presShell
=
aDocument
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
RefPtr
<
nsViewManager
>
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
vm
-
>
GetRootWidget
(
)
;
if
(
!
widget
)
return
nullptr
;
GtkWidget
*
gtkWidget
=
static_cast
<
nsWindow
*
>
(
widget
.
get
(
)
)
-
>
GetGtkWidget
(
)
;
if
(
!
gtkWidget
)
return
nullptr
;
GtkWidget
*
toplevel
=
nullptr
;
toplevel
=
gtk_widget_get_toplevel
(
gtkWidget
)
;
if
(
!
GTK_IS_WINDOW
(
toplevel
)
)
return
nullptr
;
return
GTK_WINDOW
(
toplevel
)
;
}
NS_IMETHODIMP
nsDragService
:
:
InvokeDragSession
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsICookieJarSettings
*
aCookieJarSettings
nsIArray
*
aArrayTransferables
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_OTHER
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
InvokeDragSession
"
)
)
;
if
(
mSourceNode
)
return
NS_ERROR_NOT_AVAILABLE
;
return
nsBaseDragService
:
:
InvokeDragSession
(
aDOMNode
aPrincipal
aCsp
aCookieJarSettings
aArrayTransferables
aActionType
aContentPolicyType
)
;
}
nsresult
nsDragService
:
:
InvokeDragSessionImpl
(
nsIArray
*
aArrayTransferables
const
Maybe
<
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
{
if
(
!
aArrayTransferables
)
return
NS_ERROR_INVALID_ARG
;
mSourceDataItems
=
aArrayTransferables
;
GtkTargetList
*
sourceList
=
GetSourceList
(
)
;
if
(
!
sourceList
)
return
NS_OK
;
GdkDragAction
action
=
GDK_ACTION_DEFAULT
;
if
(
aActionType
&
DRAGDROP_ACTION_COPY
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_COPY
)
;
if
(
aActionType
&
DRAGDROP_ACTION_MOVE
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_MOVE
)
;
if
(
aActionType
&
DRAGDROP_ACTION_LINK
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_LINK
)
;
GdkEvent
event
;
memset
(
&
event
0
sizeof
(
GdkEvent
)
)
;
event
.
type
=
GDK_BUTTON_PRESS
;
event
.
button
.
window
=
gtk_widget_get_window
(
mHiddenWidget
)
;
event
.
button
.
time
=
nsWindow
:
:
GetLastUserInputTime
(
)
;
GtkWindowGroup
*
window_group
=
gtk_window_get_group
(
GetGtkWindow
(
mSourceDocument
)
)
;
gtk_window_group_add_window
(
window_group
GTK_WINDOW
(
mHiddenWidget
)
)
;
event
.
button
.
device
=
widget
:
:
GdkGetPointer
(
)
;
GdkDragContext
*
context
=
gtk_drag_begin_with_coordinates
(
mHiddenWidget
sourceList
action
1
&
event
-
1
-
1
)
;
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
InvokeDragSessionImpl
GdkDragContext
%
p
"
context
)
)
;
nsresult
rv
;
if
(
context
)
{
StartDragSession
(
)
;
sGrabWidget
=
gtk_window_group_get_current_grab
(
window_group
)
;
if
(
sGrabWidget
)
{
g_object_ref
(
sGrabWidget
)
;
g_signal_connect
(
sGrabWidget
"
event
-
after
"
G_CALLBACK
(
OnSourceGrabEventAfter
)
this
)
;
}
mEndDragPoint
=
LayoutDeviceIntPoint
(
-
1
-
1
)
;
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
gtk_target_list_unref
(
sourceList
)
;
return
rv
;
}
bool
nsDragService
:
:
SetAlphaPixmap
(
SourceSurface
*
aSurface
GdkDragContext
*
aContext
int32_t
aXOffset
int32_t
aYOffset
const
LayoutDeviceIntRect
&
dragRect
)
{
GdkScreen
*
screen
=
gtk_widget_get_screen
(
mHiddenWidget
)
;
if
(
!
gdk_screen_is_composited
(
screen
)
)
return
false
;
#
ifdef
cairo_image_surface_create
#
error
"
Looks
like
we
'
re
including
Mozilla
'
s
cairo
instead
of
system
cairo
"
#
endif
cairo_surface_t
*
surf
=
cairo_image_surface_create
(
CAIRO_FORMAT_ARGB32
dragRect
.
width
dragRect
.
height
)
;
if
(
!
surf
)
return
false
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
CreateDrawTargetForData
(
cairo_image_surface_get_data
(
surf
)
nsIntSize
(
dragRect
.
width
dragRect
.
height
)
cairo_image_surface_get_stride
(
surf
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
return
false
;
dt
-
>
ClearRect
(
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
)
;
dt
-
>
DrawSurface
(
aSurface
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
DRAG_IMAGE_ALPHA_LEVEL
CompositionOp
:
:
OP_SOURCE
)
)
;
cairo_surface_mark_dirty
(
surf
)
;
cairo_surface_set_device_offset
(
surf
-
aXOffset
-
aYOffset
)
;
static
auto
sCairoSurfaceSetDeviceScalePtr
=
(
void
(
*
)
(
cairo_surface_t
*
double
double
)
)
dlsym
(
RTLD_DEFAULT
"
cairo_surface_set_device_scale
"
)
;
if
(
sCairoSurfaceSetDeviceScalePtr
)
{
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
sCairoSurfaceSetDeviceScalePtr
(
surf
scale
scale
)
;
}
gtk_drag_set_icon_surface
(
aContext
surf
)
;
cairo_surface_destroy
(
surf
)
;
return
true
;
}
NS_IMETHODIMP
nsDragService
:
:
StartDragSession
(
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
StartDragSession
"
)
)
;
mTempFileUrl
.
Truncate
(
)
;
return
nsBaseDragService
:
:
StartDragSession
(
)
;
}
bool
nsDragService
:
:
RemoveTempFiles
(
)
{
int32_t
count
=
mTemporaryFiles
.
Count
(
)
;
for
(
int32_t
pos
=
0
;
pos
<
count
;
pos
+
+
)
{
mTemporaryFiles
[
pos
]
-
>
Remove
(
true
)
;
}
mTemporaryFiles
.
Clear
(
)
;
mTempFileTimerID
=
0
;
return
false
;
}
gboolean
nsDragService
:
:
TaskRemoveTempFiles
(
gpointer
data
)
{
RefPtr
<
nsDragService
>
dragService
=
static_cast
<
nsDragService
*
>
(
data
)
;
return
dragService
-
>
RemoveTempFiles
(
)
;
}
NS_IMETHODIMP
nsDragService
:
:
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
EndDragSession
(
%
p
)
%
d
"
mTargetDragContext
.
get
(
)
aDoneDrag
)
)
;
if
(
sGrabWidget
)
{
g_signal_handlers_disconnect_by_func
(
sGrabWidget
FuncToGpointer
(
OnSourceGrabEventAfter
)
this
)
;
g_object_unref
(
sGrabWidget
)
;
sGrabWidget
=
nullptr
;
if
(
sMotionEventTimerID
)
{
g_source_remove
(
sMotionEventTimerID
)
;
sMotionEventTimerID
=
0
;
}
if
(
sMotionEvent
)
{
gdk_event_free
(
sMotionEvent
)
;
sMotionEvent
=
nullptr
;
}
}
SetDragAction
(
DRAGDROP_ACTION_NONE
)
;
if
(
mTemporaryFiles
.
Count
(
)
>
0
&
&
!
mTempFileTimerID
)
{
LOGDRAGSERVICE
(
(
"
removing
temporary
files
"
)
)
;
mTempFileTimerID
=
g_timeout_add
(
NS_DND_TIMEOUT
TaskRemoveTempFiles
this
)
;
mTempFileUrl
.
Truncate
(
)
;
}
mTargetDragContextForRemote
=
nullptr
;
mTargetWindow
=
nullptr
;
mPendingWindow
=
nullptr
;
mCachedDragContext
=
0
;
return
nsBaseDragService
:
:
EndDragSession
(
aDoneDrag
aKeyModifiers
)
;
}
NS_IMETHODIMP
nsDragService
:
:
SetCanDrop
(
bool
aCanDrop
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
SetCanDrop
%
d
"
aCanDrop
)
)
;
mCanDrop
=
aCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetCanDrop
(
bool
*
aCanDrop
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
GetCanDrop
"
)
)
;
*
aCanDrop
=
mCanDrop
;
return
NS_OK
;
}
static
void
UTF16ToNewUTF8
(
const
char16_t
*
aUTF16
uint32_t
aUTF16Len
char
*
*
aUTF8
uint32_t
*
aUTF8Len
)
{
nsDependentSubstring
utf16
(
aUTF16
aUTF16Len
)
;
*
aUTF8
=
ToNewUTF8String
(
utf16
aUTF8Len
)
;
}
static
void
UTF8ToNewUTF16
(
const
char
*
aUTF8
uint32_t
aUTF8Len
char16_t
*
*
aUTF16
uint32_t
*
aUTF16Len
)
{
nsDependentCSubstring
utf8
(
aUTF8
aUTF8Len
)
;
*
aUTF16
=
UTF8ToNewUnicode
(
utf8
aUTF16Len
)
;
}
static
uint32_t
CountTextUriListItems
(
const
char
*
data
uint32_t
datalen
)
{
const
char
*
p
=
data
;
const
char
*
endPtr
=
p
+
datalen
;
uint32_t
count
=
0
;
while
(
p
<
endPtr
)
{
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
isspace
(
*
p
)
)
p
+
+
;
if
(
p
!
=
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
&
&
*
p
!
=
'
\
r
'
)
count
+
+
;
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
)
p
+
+
;
p
+
+
;
}
return
count
;
}
static
void
GetTextUriListItem
(
const
char
*
data
uint32_t
datalen
uint32_t
aItemIndex
char16_t
*
*
convertedText
uint32_t
*
convertedTextLen
)
{
const
char
*
p
=
data
;
const
char
*
endPtr
=
p
+
datalen
;
unsigned
int
count
=
0
;
*
convertedText
=
nullptr
;
while
(
p
<
endPtr
)
{
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
isspace
(
*
p
)
)
p
+
+
;
if
(
p
!
=
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
&
&
*
p
!
=
'
\
r
'
)
count
+
+
;
if
(
aItemIndex
+
1
=
=
count
)
{
const
char
*
q
=
p
;
while
(
q
<
endPtr
&
&
*
q
!
=
'
\
0
'
&
&
*
q
!
=
'
\
n
'
&
&
*
q
!
=
'
\
r
'
)
q
+
+
;
UTF8ToNewUTF16
(
p
q
-
p
convertedText
convertedTextLen
)
;
break
;
}
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
)
p
+
+
;
p
+
+
;
}
if
(
!
*
convertedText
)
{
UTF8ToNewUTF16
(
data
datalen
convertedText
convertedTextLen
)
;
}
}
NS_IMETHODIMP
nsDragService
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
GetNumDropItems
"
)
)
;
if
(
!
mTargetWidget
)
{
LOGDRAGSERVICE
(
(
"
*
*
*
warning
:
GetNumDropItems
\
called
without
a
valid
target
widget
!
\
n
"
)
)
;
*
aNumItems
=
0
;
return
NS_OK
;
}
bool
isList
=
IsTargetContextList
(
)
;
if
(
isList
)
{
if
(
!
mSourceDataItems
)
{
*
aNumItems
=
0
;
return
NS_OK
;
}
mSourceDataItems
-
>
GetLength
(
aNumItems
)
;
}
else
{
GdkAtom
gdkFlavor
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
if
(
!
gdkFlavor
)
{
*
aNumItems
=
0
;
return
NS_OK
;
}
nsTArray
<
nsCString
>
dragFlavors
;
GetDragFlavors
(
dragFlavors
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
if
(
mTargetDragData
)
{
const
char
*
data
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
*
aNumItems
=
CountTextUriListItems
(
data
mTargetDragDataLen
)
;
}
else
*
aNumItems
=
1
;
}
LOGDRAGSERVICE
(
(
"
NumOfDropItems
%
d
"
*
aNumItems
)
)
;
return
NS_OK
;
}
void
nsDragService
:
:
GetDragFlavors
(
nsTArray
<
nsCString
>
&
aFlavors
)
{
for
(
GList
*
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
atom
)
)
;
if
(
!
name
)
{
continue
;
}
aFlavors
.
AppendElement
(
nsCString
(
name
.
get
(
)
)
)
;
}
}
NS_IMETHODIMP
nsDragService
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
GetData
(
)
index
%
d
"
aItemIndex
)
)
;
if
(
!
aTransferable
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mTargetWidget
)
{
LOGDRAGSERVICE
(
(
"
*
*
*
failed
:
GetData
\
called
without
a
valid
target
widget
!
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
aTransferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
failed
to
get
flavors
quit
.
"
)
)
;
return
rv
;
}
bool
isList
=
IsTargetContextList
(
)
;
if
(
isList
)
{
LOGDRAGSERVICE
(
(
"
Process
as
a
list
.
.
.
"
)
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
LOGDRAGSERVICE
(
(
"
[
%
d
]
flavor
is
%
s
\
n
"
i
flavorStr
.
get
(
)
)
)
;
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
mSourceDataItems
aItemIndex
)
;
if
(
!
item
)
continue
;
nsCOMPtr
<
nsISupports
>
data
;
LOGDRAGSERVICE
(
(
"
trying
to
get
transfer
data
for
%
s
\
n
"
flavorStr
.
get
(
)
)
)
;
rv
=
item
-
>
GetTransferData
(
flavorStr
.
get
(
)
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
failed
.
\
n
"
)
)
;
continue
;
}
rv
=
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
data
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
fail
to
set
transfer
data
into
transferable
!
\
n
"
)
)
;
continue
;
}
LOGDRAGSERVICE
(
(
"
succeeded
\
n
"
)
)
;
return
NS_OK
;
}
LOGDRAGSERVICE
(
(
"
failed
to
match
flavors
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsCString
>
dragFlavors
;
GetDragFlavors
(
dragFlavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
GdkAtom
gdkFlavor
=
gdk_atom_intern
(
flavorStr
.
get
(
)
FALSE
)
;
LOGDRAGSERVICE
(
(
"
we
'
re
getting
data
%
s
(
gdk
flavor
%
p
)
\
n
"
flavorStr
.
get
(
)
gdkFlavor
)
)
;
bool
dataFound
=
false
;
if
(
gdkFlavor
)
{
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
}
if
(
mTargetDragData
)
{
LOGDRAGSERVICE
(
(
"
dataFound
=
true
\
n
"
)
)
;
dataFound
=
true
;
}
else
{
LOGDRAGSERVICE
(
(
"
dataFound
=
false
try
conversions
\
n
"
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kFileMime
)
)
{
gdkFlavor
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
LOGDRAGSERVICE
(
(
"
conversion
%
s
=
>
%
s
"
kFileMime
kTextMime
)
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
if
(
!
mTargetDragData
)
{
LOGDRAGSERVICE
(
(
"
conversion
%
s
=
>
%
s
"
kFileMime
gTextUriListType
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
}
if
(
mTargetDragData
)
{
const
char
*
text
=
static_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
GetTextUriListItem
(
text
mTargetDragDataLen
aItemIndex
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
nsCOMPtr
<
nsIURI
>
fileURI
;
rv
=
ioService
-
>
NewURI
(
NS_ConvertUTF16toUTF8
(
convertedText
)
nullptr
nullptr
getter_AddRefs
(
fileURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
fileURI
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
file
;
rv
=
fileURL
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
set
as
file
%
s
"
NS_ConvertUTF16toUTF8
(
convertedText
)
.
get
(
)
)
)
;
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
file
)
;
g_free
(
convertedText
)
;
return
NS_OK
;
}
}
}
g_free
(
convertedText
)
;
}
continue
;
}
}
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
LOGDRAGSERVICE
(
(
"
conversion
%
s
=
>
%
s
"
kUnicodeMime
gTextPlainUTF8Type
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gTextPlainUTF8Type
FALSE
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
if
(
mTargetDragData
)
{
const
char
*
castedText
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
NS_ConvertUTF8toUTF16
ucs2string
(
castedText
mTargetDragDataLen
)
;
convertedText
=
ToNewUnicode
(
ucs2string
mozilla
:
:
fallible
)
;
if
(
convertedText
)
{
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
ucs2string
.
Length
(
)
*
2
;
dataFound
=
true
;
}
}
else
{
LOGDRAGSERVICE
(
(
"
conversion
%
s
=
>
%
s
"
kUnicodeMime
kTextMime
)
)
;
gdkFlavor
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
if
(
mTargetDragData
)
{
const
char
*
castedText
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
UTF8ToNewUTF16
(
castedText
mTargetDragDataLen
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
convertedTextLen
*
2
;
dataFound
=
true
;
}
}
}
}
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
LOGDRAGSERVICE
(
(
"
conversion
%
s
=
>
%
s
"
kURLMime
gTextUriListType
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
if
(
mTargetDragData
)
{
const
char
*
data
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
GetTextUriListItem
(
data
mTargetDragDataLen
aItemIndex
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
convertedTextLen
*
2
;
dataFound
=
true
;
}
}
if
(
!
dataFound
)
{
LOGDRAGSERVICE
(
(
"
conversion
%
s
=
>
%
s
"
kURLMime
gMozUrlType
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gMozUrlType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
dragFlavors
)
;
if
(
mTargetDragData
)
{
const
char
*
castedText
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
UTF8ToNewUTF16
(
castedText
mTargetDragDataLen
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
convertedTextLen
*
2
;
dataFound
=
true
;
}
}
}
}
}
if
(
dataFound
)
{
LOGDRAGSERVICE
(
(
"
actual
data
found
%
s
\
n
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
gdkFlavor
)
)
.
get
(
)
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kJPGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kPNGImageMime
)
|
|
flavorStr
.
EqualsLiteral
(
kGIFImageMime
)
)
{
LOGDRAGSERVICE
(
(
"
saving
as
image
%
s
\
n
"
flavorStr
.
get
(
)
)
)
;
nsCOMPtr
<
nsIInputStream
>
byteStream
;
NS_NewByteInputStream
(
getter_AddRefs
(
byteStream
)
Span
(
(
char
*
)
mTargetDragData
mTargetDragDataLen
)
NS_ASSIGNMENT_COPY
)
;
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
byteStream
)
;
continue
;
}
if
(
!
flavorStr
.
EqualsLiteral
(
kCustomTypesMime
)
)
{
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
flavorStr
&
mTargetDragData
reinterpret_cast
<
int
*
>
(
&
mTargetDragDataLen
)
)
;
}
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
flavorStr
mTargetDragData
mTargetDragDataLen
getter_AddRefs
(
genericDataWrapper
)
)
;
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
genericDataWrapper
)
;
break
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
IsDataFlavorSupported
(
%
p
)
%
s
"
mTargetDragContext
.
get
(
)
aDataFlavor
)
)
;
if
(
!
_retval
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
_retval
=
false
;
if
(
!
mTargetWidget
)
{
LOGDRAGSERVICE
(
(
"
*
*
*
warning
:
IsDataFlavorSupported
\
called
without
a
valid
target
widget
!
\
n
"
)
)
;
return
NS_OK
;
}
bool
isList
=
IsTargetContextList
(
)
;
if
(
isList
)
{
LOGDRAGSERVICE
(
(
"
It
'
s
a
list
"
)
)
;
uint32_t
numDragItems
=
0
;
if
(
!
mSourceDataItems
)
{
LOGDRAGSERVICE
(
(
"
quit
"
)
)
;
return
NS_OK
;
}
mSourceDataItems
-
>
GetLength
(
&
numDragItems
)
;
LOGDRAGSERVICE
(
(
"
drag
items
%
d
"
numDragItems
)
)
;
for
(
uint32_t
itemIndex
=
0
;
itemIndex
<
numDragItems
;
+
+
itemIndex
)
{
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
itemIndex
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
LOGDRAGSERVICE
(
(
"
checking
%
s
against
%
s
\
n
"
flavors
[
i
]
.
get
(
)
aDataFlavor
)
)
;
if
(
flavors
[
i
]
.
Equals
(
aDataFlavor
)
)
{
LOGDRAGSERVICE
(
(
"
found
.
\
n
"
)
)
;
*
_retval
=
true
;
}
}
}
}
return
NS_OK
;
}
GList
*
tmp
=
nullptr
;
if
(
mTargetDragContext
)
{
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
}
for
(
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
atom
)
)
;
if
(
!
name
)
{
continue
;
}
if
(
strcmp
(
name
.
get
(
)
aDataFlavor
)
=
=
0
)
{
*
_retval
=
true
;
}
else
if
(
strcmp
(
name
.
get
(
)
gTextUriListType
)
=
=
0
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
|
|
strcmp
(
aDataFlavor
kFileMime
)
=
=
0
)
)
{
*
_retval
=
true
;
}
else
if
(
strcmp
(
name
.
get
(
)
gMozUrlType
)
=
=
0
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
)
)
{
*
_retval
=
true
;
}
else
if
(
strcmp
(
name
.
get
(
)
kTextMime
)
=
=
0
&
&
(
(
strcmp
(
aDataFlavor
kUnicodeMime
)
=
=
0
)
|
|
(
strcmp
(
aDataFlavor
kFileMime
)
=
=
0
)
)
)
{
*
_retval
=
true
;
}
if
(
*
_retval
)
{
LOGDRAGSERVICE
(
(
"
supported
with
converting
%
s
=
>
%
s
"
name
.
get
(
)
aDataFlavor
)
)
;
}
}
if
(
!
*
_retval
)
{
LOGDRAGSERVICE
(
(
"
%
s
is
not
supported
"
aDataFlavor
)
)
;
}
return
NS_OK
;
}
void
nsDragService
:
:
ReplyToDragMotion
(
GdkDragContext
*
aDragContext
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
ReplyToDragMotion
(
%
p
)
can
drop
%
d
"
aDragContext
mCanDrop
)
)
;
GdkDragAction
action
=
(
GdkDragAction
)
0
;
if
(
mCanDrop
)
{
switch
(
mDragAction
)
{
case
DRAGDROP_ACTION_COPY
:
action
=
GDK_ACTION_COPY
;
break
;
case
DRAGDROP_ACTION_LINK
:
action
=
GDK_ACTION_LINK
;
break
;
case
DRAGDROP_ACTION_NONE
:
action
=
(
GdkDragAction
)
0
;
break
;
default
:
action
=
GDK_ACTION_MOVE
;
break
;
}
}
LOGDRAGSERVICE
(
(
"
gdk_drag_status
(
)
action
%
d
"
action
)
)
;
gdk_drag_status
(
aDragContext
action
mTargetTime
)
;
}
void
nsDragService
:
:
EnsureCachedDataValidForContext
(
GdkDragContext
*
aDragContext
)
{
if
(
mCachedDragContext
!
=
(
uintptr_t
)
aDragContext
)
{
mCachedData
.
Clear
(
)
;
mCachedDragContext
=
(
uintptr_t
)
aDragContext
;
}
}
void
nsDragService
:
:
TargetDataReceived
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aX
gint
aY
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
TargetDataReceived
(
%
p
)
"
aContext
)
)
;
TargetResetData
(
)
;
EnsureCachedDataValidForContext
(
aContext
)
;
mTargetDragDataReceived
=
true
;
gint
len
=
gtk_selection_data_get_length
(
aSelectionData
)
;
const
guchar
*
data
=
gtk_selection_data_get_data
(
aSelectionData
)
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
target
)
)
;
nsDependentCString
flavor
(
name
.
get
(
)
)
;
LOGDRAGSERVICE
(
(
"
got
data
MIME
%
s
"
flavor
.
get
(
)
)
)
;
if
(
len
>
0
&
&
data
)
{
mTargetDragDataLen
=
len
;
mTargetDragData
=
g_malloc
(
mTargetDragDataLen
)
;
memcpy
(
mTargetDragData
data
mTargetDragDataLen
)
;
LOGDRAGSERVICE
(
(
"
got
data
len
=
%
d
"
mTargetDragDataLen
)
)
;
nsTArray
<
uint8_t
>
copy
;
if
(
!
copy
.
SetLength
(
len
fallible
)
)
{
return
;
}
memcpy
(
copy
.
Elements
(
)
data
len
)
;
mCachedData
.
InsertOrUpdate
(
flavor
std
:
:
move
(
copy
)
)
;
}
else
{
LOGDRAGSERVICE
(
(
"
Failed
to
get
data
.
selection
data
len
was
%
d
\
n
"
mTargetDragDataLen
)
)
;
mCachedData
.
InsertOrUpdate
(
flavor
nsTArray
<
uint8_t
>
(
)
)
;
}
}
bool
nsDragService
:
:
IsTargetContextList
(
void
)
{
bool
retval
=
false
;
if
(
mTargetDragContext
&
&
gtk_drag_get_source_widget
(
mTargetDragContext
)
=
=
nullptr
)
{
return
retval
;
}
GList
*
tmp
=
nullptr
;
if
(
mTargetDragContext
)
{
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
}
for
(
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
atom
)
)
;
if
(
name
&
&
!
strcmp
(
name
.
get
(
)
gMimeListType
)
)
{
return
true
;
}
}
return
retval
;
}
void
nsDragService
:
:
GetTargetDragData
(
GdkAtom
aFlavor
nsTArray
<
nsCString
>
&
aDropFlavors
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
GetTargetDragData
(
%
p
)
'
%
s
'
\
n
"
mTargetDragContext
.
get
(
)
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
aFlavor
)
)
.
get
(
)
)
)
;
TargetResetData
(
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
aFlavor
)
)
;
nsDependentCString
flavor
(
name
.
get
(
)
)
;
if
(
!
aDropFlavors
.
Contains
(
flavor
)
)
{
LOGDRAGSERVICE
(
(
"
%
s
is
missing
"
flavor
.
get
(
)
)
)
;
return
;
}
if
(
mTargetDragContext
)
{
EnsureCachedDataValidForContext
(
mTargetDragContext
)
;
if
(
auto
cached
=
mCachedData
.
Lookup
(
flavor
)
)
{
mTargetDragDataLen
=
cached
-
>
Length
(
)
;
LOGDRAGSERVICE
(
(
"
using
cached
data
for
%
s
length
is
%
d
"
flavor
.
get
(
)
mTargetDragDataLen
)
)
;
if
(
mTargetDragDataLen
)
{
mTargetDragData
=
g_malloc
(
mTargetDragDataLen
)
;
memcpy
(
mTargetDragData
cached
-
>
Elements
(
)
mTargetDragDataLen
)
;
}
mTargetDragDataReceived
=
true
;
LOGDRAGSERVICE
(
(
"
%
s
found
in
cache
"
flavor
.
get
(
)
)
)
;
return
;
}
gtk_drag_get_data
(
mTargetWidget
mTargetDragContext
aFlavor
mTargetTime
)
;
LOGDRAGSERVICE
(
(
"
about
to
start
inner
iteration
.
"
)
)
;
gtk_main_iteration
(
)
;
PRTime
entryTime
=
PR_Now
(
)
;
while
(
!
mTargetDragDataReceived
&
&
mDoingDrag
)
{
LOGDRAGSERVICE
(
(
"
doing
iteration
.
.
.
\
n
"
)
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
10
)
)
;
if
(
PR_Now
(
)
-
entryTime
>
NS_DND_TIMEOUT
)
{
LOGDRAGSERVICE
(
(
"
failed
to
get
D
&
D
data
in
time
!
\
n
"
)
)
;
break
;
}
gtk_main_iteration
(
)
;
}
}
#
ifdef
MOZ_LOGGING
if
(
mTargetDragDataLen
&
&
mTargetDragData
)
{
LOGDRAGSERVICE
(
(
"
%
s
got
from
system
"
flavor
.
get
(
)
)
)
;
}
else
{
LOGDRAGSERVICE
(
(
"
%
s
failed
to
get
from
system
"
flavor
.
get
(
)
)
)
;
}
#
endif
}
void
nsDragService
:
:
TargetResetData
(
void
)
{
mTargetDragDataReceived
=
false
;
g_free
(
mTargetDragData
)
;
mTargetDragData
=
0
;
mTargetDragDataLen
=
0
;
}
static
void
TargetArrayAddTarget
(
nsTArray
<
GtkTargetEntry
*
>
&
aTargetArray
const
char
*
aTarget
)
{
GtkTargetEntry
*
target
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
target
-
>
target
=
g_strdup
(
aTarget
)
;
target
-
>
flags
=
0
;
aTargetArray
.
AppendElement
(
target
)
;
LOGDRAGSERVICE
(
(
"
adding
target
%
s
\
n
"
aTarget
)
)
;
}
GtkTargetList
*
nsDragService
:
:
GetSourceList
(
void
)
{
if
(
!
mSourceDataItems
)
return
nullptr
;
nsTArray
<
GtkTargetEntry
*
>
targetArray
;
GtkTargetEntry
*
targets
;
GtkTargetList
*
targetList
=
0
;
uint32_t
targetCount
=
0
;
unsigned
int
numDragItems
=
0
;
mSourceDataItems
-
>
GetLength
(
&
numDragItems
)
;
if
(
numDragItems
>
1
)
{
TargetArrayAddTarget
(
targetArray
gMimeListType
)
;
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
if
(
flavors
[
i
]
.
EqualsLiteral
(
kURLMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextUriListType
)
;
break
;
}
}
}
}
else
if
(
numDragItems
=
=
1
)
{
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
TargetArrayAddTarget
(
targetArray
flavorStr
.
get
(
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kFileMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextUriListType
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextPlainUTF8Type
)
;
TargetArrayAddTarget
(
targetArray
kTextMime
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
TargetArrayAddTarget
(
targetArray
gMozUrlType
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kFilePromiseURLMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextUriListType
)
;
}
else
if
(
widget
:
:
GdkIsX11Display
(
)
&
&
flavorStr
.
EqualsLiteral
(
kFilePromiseMime
)
)
{
TargetArrayAddTarget
(
targetArray
gXdndDirectSaveType
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kNativeImageMime
)
)
{
TargetArrayAddTarget
(
targetArray
kPNGImageMime
)
;
TargetArrayAddTarget
(
targetArray
kJPEGImageMime
)
;
TargetArrayAddTarget
(
targetArray
kJPGImageMime
)
;
TargetArrayAddTarget
(
targetArray
kGIFImageMime
)
;
}
}
}
}
targetCount
=
targetArray
.
Length
(
)
;
if
(
targetCount
)
{
targets
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
*
targetCount
)
;
uint32_t
targetIndex
;
for
(
targetIndex
=
0
;
targetIndex
<
targetCount
;
+
+
targetIndex
)
{
GtkTargetEntry
*
disEntry
=
targetArray
.
ElementAt
(
targetIndex
)
;
targets
[
targetIndex
]
.
target
=
disEntry
-
>
target
;
targets
[
targetIndex
]
.
flags
=
disEntry
-
>
flags
;
targets
[
targetIndex
]
.
info
=
0
;
}
targetList
=
gtk_target_list_new
(
targets
targetCount
)
;
for
(
uint32_t
cleanIndex
=
0
;
cleanIndex
<
targetCount
;
+
+
cleanIndex
)
{
GtkTargetEntry
*
thisTarget
=
targetArray
.
ElementAt
(
cleanIndex
)
;
g_free
(
thisTarget
-
>
target
)
;
g_free
(
thisTarget
)
;
}
g_free
(
targets
)
;
}
else
{
targetList
=
gtk_target_list_new
(
nullptr
0
)
;
}
return
targetList
;
}
void
nsDragService
:
:
SourceEndDragSession
(
GdkDragContext
*
aContext
gint
aResult
)
{
LOGDRAGSERVICE
(
(
"
SourceEndDragSession
(
%
p
)
result
%
d
\
n
"
aContext
aResult
)
)
;
mSourceDataItems
=
nullptr
;
GdkAtom
property
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
gdk_property_delete
(
gdk_drag_context_get_source_window
(
aContext
)
property
)
;
if
(
!
mDoingDrag
|
|
mScheduledTask
=
=
eDragTaskSourceEnd
)
return
;
if
(
mEndDragPoint
.
x
<
0
)
{
gint
x
y
;
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
GdkScreen
*
screen
=
gdk_display_get_default_screen
(
display
)
;
GtkWindow
*
window
=
GetGtkWindow
(
mSourceDocument
)
;
GdkWindow
*
gdkWindow
=
window
?
gtk_widget_get_window
(
GTK_WIDGET
(
window
)
)
:
gdk_screen_get_root_window
(
screen
)
;
gdk_window_get_device_position
(
gdkWindow
widget
:
:
GdkGetPointer
(
)
&
x
&
y
nullptr
)
;
gint
scale
=
gdk_window_get_scale_factor
(
gdkWindow
)
;
SetDragEndPoint
(
LayoutDeviceIntPoint
(
x
*
scale
y
*
scale
)
)
;
LOGDRAGSERVICE
(
(
"
guess
drag
end
point
%
d
%
d
\
n
"
x
*
scale
y
*
scale
)
)
;
}
uint32_t
dropEffect
;
if
(
aResult
=
=
MOZ_GTK_DRAG_RESULT_SUCCESS
)
{
GdkDragAction
action
=
gdk_drag_context_get_dest_window
(
aContext
)
?
gdk_drag_context_get_actions
(
aContext
)
:
(
GdkDragAction
)
0
;
if
(
!
action
)
dropEffect
=
DRAGDROP_ACTION_NONE
;
else
if
(
action
&
GDK_ACTION_COPY
)
dropEffect
=
DRAGDROP_ACTION_COPY
;
else
if
(
action
&
GDK_ACTION_LINK
)
dropEffect
=
DRAGDROP_ACTION_LINK
;
else
if
(
action
&
GDK_ACTION_MOVE
)
dropEffect
=
DRAGDROP_ACTION_MOVE
;
else
dropEffect
=
DRAGDROP_ACTION_COPY
;
}
else
{
dropEffect
=
DRAGDROP_ACTION_NONE
;
if
(
aResult
!
=
MOZ_GTK_DRAG_RESULT_NO_TARGET
)
{
LOGDRAGSERVICE
(
(
"
drop
is
user
chancelled
\
n
"
)
)
;
mUserCancelled
=
true
;
}
}
if
(
mDataTransfer
)
{
mDataTransfer
-
>
SetDropEffectInt
(
dropEffect
)
;
}
Schedule
(
eDragTaskSourceEnd
nullptr
nullptr
LayoutDeviceIntPoint
(
)
0
)
;
}
static
void
CreateURIList
(
nsIArray
*
aItems
nsACString
&
aURIList
)
{
uint32_t
length
=
0
;
aItems
-
>
GetLength
(
&
length
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
aItems
i
)
;
if
(
!
item
)
{
continue
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
item
-
>
GetTransferData
(
kURLMime
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsISupportsString
>
string
=
do_QueryInterface
(
data
)
;
nsAutoString
text
;
if
(
string
)
{
string
-
>
GetData
(
text
)
;
}
int32_t
separatorPos
=
text
.
FindChar
(
u
'
\
n
'
)
;
if
(
separatorPos
>
=
0
)
{
text
.
Truncate
(
separatorPos
)
;
}
AppendUTF16toUTF8
(
text
aURIList
)
;
aURIList
.
AppendLiteral
(
"
\
r
\
n
"
)
;
continue
;
}
rv
=
item
-
>
GetTransferData
(
kFileMime
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
data
)
)
{
nsCOMPtr
<
nsIURI
>
fileURI
;
NS_NewFileURI
(
getter_AddRefs
(
fileURI
)
file
)
;
if
(
fileURI
)
{
nsAutoCString
spec
;
fileURI
-
>
GetSpec
(
spec
)
;
aURIList
.
Append
(
spec
)
;
aURIList
.
AppendLiteral
(
"
\
r
\
n
"
)
;
}
}
}
}
}
static
nsresult
GetDownloadDetails
(
nsITransferable
*
aTransferable
nsIURI
*
*
aSourceURI
nsAString
&
aFilename
)
{
*
aSourceURI
=
nullptr
;
MOZ_ASSERT
(
aTransferable
!
=
nullptr
"
aTransferable
must
not
be
null
"
)
;
nsCOMPtr
<
nsISupports
>
urlPrimitive
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseURLMime
getter_AddRefs
(
urlPrimitive
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupportsString
>
srcUrlPrimitive
=
do_QueryInterface
(
urlPrimitive
)
;
if
(
!
srcUrlPrimitive
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
srcUri
;
srcUrlPrimitive
-
>
GetData
(
srcUri
)
;
if
(
srcUri
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
sourceURI
;
NS_NewURI
(
getter_AddRefs
(
sourceURI
)
srcUri
)
;
nsAutoString
srcFileName
;
nsCOMPtr
<
nsISupports
>
fileNamePrimitive
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
fileNamePrimitive
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupportsString
>
srcFileNamePrimitive
=
do_QueryInterface
(
fileNamePrimitive
)
;
if
(
srcFileNamePrimitive
)
{
srcFileNamePrimitive
-
>
GetData
(
srcFileName
)
;
}
else
{
nsCOMPtr
<
nsIURL
>
sourceURL
=
do_QueryInterface
(
sourceURI
)
;
if
(
!
sourceURL
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
urlFileName
;
sourceURL
-
>
GetFileName
(
urlFileName
)
;
NS_UnescapeURL
(
urlFileName
)
;
CopyUTF8toUTF16
(
urlFileName
srcFileName
)
;
}
if
(
srcFileName
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
sourceURI
.
swap
(
*
aSourceURI
)
;
aFilename
=
srcFileName
;
return
NS_OK
;
}
nsresult
nsDragService
:
:
CreateTempFile
(
nsITransferable
*
aItem
GtkSelectionData
*
aSelectionData
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
CreateTempFile
(
)
"
)
)
;
nsCOMPtr
<
nsIFile
>
tmpDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
get
temp
directory
\
n
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsAutoString
wideFileName
;
nsCOMPtr
<
nsIURI
>
sourceURI
;
rv
=
GetDownloadDetails
(
aItem
getter_AddRefs
(
sourceURI
)
wideFileName
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
extract
file
name
and
source
uri
from
download
url
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aItem
-
>
GetRequestingPrincipal
(
)
;
nsContentPolicyType
contentPolicyType
=
aItem
-
>
GetContentPolicyType
(
)
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
aItem
-
>
GetCookieJarSettings
(
)
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
sourceURI
principal
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
contentPolicyType
cookieJarSettings
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
create
new
channel
for
source
uri
"
)
)
;
return
rv
;
}
rv
=
channel
-
>
Open
(
getter_AddRefs
(
inputStream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
open
channel
for
source
uri
"
)
)
;
return
rv
;
}
tmpDir
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
"
dnd_file
"
)
)
;
rv
=
tmpDir
-
>
CreateUnique
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
create
tmp
dir
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
tempFile
;
tmpDir
-
>
Clone
(
getter_AddRefs
(
tempFile
)
)
;
mTemporaryFiles
.
AppendObject
(
tempFile
)
;
if
(
mTempFileTimerID
)
{
g_source_remove
(
mTempFileTimerID
)
;
mTempFileTimerID
=
0
;
}
tmpDir
-
>
Append
(
wideFileName
)
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
tmpDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
open
output
stream
for
temporary
file
"
)
)
;
return
rv
;
}
char
buffer
[
8192
]
;
uint32_t
readCount
=
0
;
uint32_t
writeCount
=
0
;
while
(
1
)
{
rv
=
inputStream
-
>
Read
(
buffer
sizeof
(
buffer
)
&
readCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
read
data
from
source
uri
"
)
)
;
return
rv
;
}
if
(
readCount
=
=
0
)
break
;
rv
=
outputStream
-
>
Write
(
buffer
readCount
&
writeCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
write
data
to
temporary
file
"
)
)
;
return
rv
;
}
}
inputStream
-
>
Close
(
)
;
rv
=
outputStream
-
>
Close
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
write
data
to
temporary
file
"
)
)
;
return
rv
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewFileURI
(
getter_AddRefs
(
uri
)
tmpDir
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIURL
>
fileURL
(
do_QueryInterface
(
uri
)
)
;
if
(
fileURL
)
{
nsAutoCString
urltext
;
rv
=
fileURL
-
>
GetSpec
(
urltext
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
storing
tmp
file
as
%
s
"
urltext
.
get
(
)
)
)
;
mTempFileUrl
=
urltext
;
return
NS_OK
;
}
}
}
return
NS_ERROR_FAILURE
;
}
void
nsDragService
:
:
SourceDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint32
aTime
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
SourceDataGet
(
%
p
)
"
aContext
)
)
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
GUniquePtr
<
gchar
>
typeName
(
gdk_atom_name
(
target
)
)
;
if
(
!
typeName
)
{
LOGDRAGSERVICE
(
(
"
failed
to
get
atom
name
.
\
n
"
)
)
;
return
;
}
LOGDRAGSERVICE
(
(
"
Type
is
%
s
\
n
"
typeName
.
get
(
)
)
)
;
if
(
!
mSourceDataItems
)
{
LOGDRAGSERVICE
(
(
"
Failed
to
get
our
data
items
\
n
"
)
)
;
return
;
}
nsCOMPtr
<
nsITransferable
>
item
;
item
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
!
item
)
{
return
;
}
#
ifdef
MOZ_LOGGING
PRUint32
dragItems
;
mSourceDataItems
-
>
GetLength
(
&
dragItems
)
;
LOGDRAGSERVICE
(
(
"
source
data
items
%
d
"
dragItems
)
)
;
#
endif
bool
needToDoConversionToPlainText
=
false
;
bool
needToDoConversionToImage
=
false
;
nsDependentCString
mimeFlavor
(
typeName
.
get
(
)
)
;
const
char
*
actualFlavor
=
nullptr
;
if
(
mimeFlavor
.
EqualsLiteral
(
kTextMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
gTextPlainUTF8Type
)
)
{
actualFlavor
=
kUnicodeMime
;
needToDoConversionToPlainText
=
true
;
LOGDRAGSERVICE
(
(
"
convert
%
s
=
>
%
s
"
typeName
.
get
(
)
actualFlavor
)
)
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gMozUrlType
)
)
{
actualFlavor
=
kURLMime
;
needToDoConversionToPlainText
=
true
;
LOGDRAGSERVICE
(
(
"
convert
%
s
=
>
%
s
"
typeName
.
get
(
)
actualFlavor
)
)
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gTextUriListType
)
)
{
actualFlavor
=
gTextUriListType
;
needToDoConversionToPlainText
=
true
;
LOGDRAGSERVICE
(
(
"
convert
%
s
=
>
%
s
"
typeName
.
get
(
)
actualFlavor
)
)
;
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
data
;
rv
=
item
-
>
GetTransferData
(
kFilePromiseURLMime
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
mTempFileUrl
.
IsEmpty
(
)
)
{
rv
=
CreateTempFile
(
item
aSelectionData
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOGDRAGSERVICE
(
(
"
save
tmp
file
%
s
"
mTempFileUrl
.
get
(
)
)
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
mTempFileUrl
.
get
(
)
mTempFileUrl
.
Length
(
)
)
;
return
;
}
}
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gXdndDirectSaveType
)
)
{
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
E
"
1
)
;
GdkAtom
property
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
GdkAtom
type
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
guchar
*
data
;
gint
length
;
if
(
!
gdk_property_get
(
gdk_drag_context_get_source_window
(
aContext
)
property
type
0
INT32_MAX
FALSE
nullptr
nullptr
&
length
&
data
)
)
{
return
;
}
data
=
(
guchar
*
)
g_realloc
(
data
length
+
1
)
;
if
(
!
data
)
return
;
data
[
length
]
=
'
\
0
'
;
gchar
*
hostname
;
char
*
gfullpath
=
g_filename_from_uri
(
(
const
gchar
*
)
data
&
hostname
nullptr
)
;
g_free
(
data
)
;
if
(
!
gfullpath
)
return
;
nsCString
fullpath
(
gfullpath
)
;
g_free
(
gfullpath
)
;
LOGDRAGSERVICE
(
(
"
XdndDirectSave
filepath
is
%
s
\
n
"
fullpath
.
get
(
)
)
)
;
if
(
hostname
)
{
nsCOMPtr
<
nsIPropertyBag2
>
infoService
=
do_GetService
(
NS_SYSTEMINFO_CONTRACTID
)
;
if
(
!
infoService
)
return
;
nsAutoCString
host
;
if
(
NS_SUCCEEDED
(
infoService
-
>
GetPropertyAsACString
(
u
"
host
"
_ns
host
)
)
)
{
if
(
!
host
.
Equals
(
hostname
)
)
{
LOGDRAGSERVICE
(
(
"
ignored
drag
because
of
different
host
.
\
n
"
)
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
F
"
1
)
;
g_free
(
hostname
)
;
return
;
}
}
g_free
(
hostname
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_FAILED
(
NS_NewNativeLocalFile
(
fullpath
false
getter_AddRefs
(
file
)
)
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
directory
;
file
-
>
GetParent
(
getter_AddRefs
(
directory
)
)
;
item
-
>
SetTransferData
(
kFilePromiseDirectoryMime
directory
)
;
nsCOMPtr
<
nsISupportsString
>
filenamePrimitive
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
)
;
if
(
!
filenamePrimitive
)
return
;
nsAutoString
leafName
;
file
-
>
GetLeafName
(
leafName
)
;
filenamePrimitive
-
>
SetData
(
leafName
)
;
item
-
>
SetTransferData
(
kFilePromiseDestFilename
filenamePrimitive
)
;
actualFlavor
=
kFilePromiseMime
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
kPNGImageMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
kJPGImageMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
kGIFImageMime
)
)
{
actualFlavor
=
kNativeImageMime
;
needToDoConversionToImage
=
true
;
LOGDRAGSERVICE
(
(
"
convert
%
s
=
>
%
s
"
typeName
.
get
(
)
actualFlavor
)
)
;
}
else
{
actualFlavor
=
typeName
.
get
(
)
;
LOGDRAGSERVICE
(
(
"
use
%
s
"
typeName
.
get
(
)
)
)
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
data
;
rv
=
item
-
>
GetTransferData
(
actualFlavor
getter_AddRefs
(
data
)
)
;
if
(
strcmp
(
actualFlavor
kFilePromiseMime
)
=
=
0
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
S
"
1
)
;
}
return
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
needToDoConversionToImage
)
{
LOGDRAGSERVICE
(
(
"
posting
image
\
n
"
)
)
;
nsCOMPtr
<
imgIContainer
>
image
=
do_QueryInterface
(
data
)
;
if
(
!
image
)
{
LOGDRAGSERVICE
(
(
"
do_QueryInterface
failed
\
n
"
)
)
;
return
;
}
RefPtr
<
GdkPixbuf
>
pixbuf
=
nsImageToPixbuf
:
:
ImageToPixbuf
(
image
)
;
if
(
!
pixbuf
)
{
LOGDRAGSERVICE
(
(
"
ImageToPixbuf
failed
\
n
"
)
)
;
return
;
}
gtk_selection_data_set_pixbuf
(
aSelectionData
pixbuf
)
;
LOGDRAGSERVICE
(
(
"
image
data
set
\
n
"
)
)
;
}
else
{
void
*
tmpData
=
nullptr
;
uint32_t
tmpDataLen
=
0
;
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
nsDependentCString
(
actualFlavor
)
data
&
tmpData
&
tmpDataLen
)
;
if
(
needToDoConversionToPlainText
)
{
char
*
plainTextData
=
nullptr
;
char16_t
*
castedUnicode
=
reinterpret_cast
<
char16_t
*
>
(
tmpData
)
;
uint32_t
plainTextLen
=
0
;
UTF16ToNewUTF8
(
castedUnicode
tmpDataLen
/
2
&
plainTextData
&
plainTextLen
)
;
if
(
tmpData
)
{
free
(
tmpData
)
;
tmpData
=
plainTextData
;
tmpDataLen
=
plainTextLen
;
}
}
if
(
tmpData
)
{
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
tmpData
tmpDataLen
)
;
free
(
tmpData
)
;
}
}
}
else
{
if
(
mimeFlavor
.
EqualsLiteral
(
gTextUriListType
)
)
{
LOGDRAGSERVICE
(
(
"
fall
back
to
%
s
\
n
"
typeName
.
get
(
)
)
)
;
nsAutoCString
list
;
CreateURIList
(
mSourceDataItems
list
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
list
.
get
(
)
list
.
Length
(
)
)
;
return
;
}
}
}
void
nsDragService
:
:
SourceBeginDrag
(
GdkDragContext
*
aContext
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
SourceBeginDrag
(
%
p
)
\
n
"
aContext
)
)
;
nsCOMPtr
<
nsITransferable
>
transferable
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
!
transferable
)
return
;
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
transferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
if
(
flavors
[
i
]
.
EqualsLiteral
(
kFilePromiseDestFilename
)
)
{
nsCOMPtr
<
nsISupports
>
data
;
rv
=
transferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsISupportsString
>
fileName
=
do_QueryInterface
(
data
)
;
if
(
!
fileName
)
{
return
;
}
nsAutoString
fileNameStr
;
fileName
-
>
GetData
(
fileNameStr
)
;
nsCString
fileNameCStr
;
CopyUTF16toUTF8
(
fileNameStr
fileNameCStr
)
;
GdkAtom
property
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
GdkAtom
type
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
gdk_property_change
(
gdk_drag_context_get_source_window
(
aContext
)
property
type
8
GDK_PROP_MODE_REPLACE
(
const
guchar
*
)
fileNameCStr
.
get
(
)
fileNameCStr
.
Length
(
)
)
;
}
}
}
void
nsDragService
:
:
SetDragIcon
(
GdkDragContext
*
aContext
)
{
if
(
!
mHasImage
&
&
!
mSelection
)
return
;
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
SetDragIcon
(
%
p
)
"
aContext
)
)
;
LayoutDeviceIntRect
dragRect
;
nsPresContext
*
pc
;
RefPtr
<
SourceSurface
>
surface
;
DrawDrag
(
mSourceNode
mRegion
mScreenPosition
&
dragRect
&
surface
&
pc
)
;
if
(
!
pc
)
return
;
LayoutDeviceIntPoint
screenPoint
=
ConvertToUnscaledDevPixels
(
pc
mScreenPosition
)
;
int32_t
offsetX
=
screenPoint
.
x
-
dragRect
.
x
;
int32_t
offsetY
=
screenPoint
.
y
-
dragRect
.
y
;
bool
gtk_drag_set_icon_widget_is_working
=
gtk_check_version
(
3
19
4
)
!
=
nullptr
|
|
gtk_check_version
(
3
24
0
)
=
=
nullptr
;
if
(
mDragPopup
&
&
gtk_drag_set_icon_widget_is_working
)
{
GtkWidget
*
gtkWidget
=
nullptr
;
nsIFrame
*
frame
=
mDragPopup
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
frame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
gtkWidget
=
(
GtkWidget
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_SHELLWIDGET
)
;
if
(
gtkWidget
)
{
if
(
GtkWidget
*
parent
=
gtk_widget_get_parent
(
gtkWidget
)
)
{
gtk_container_remove
(
GTK_CONTAINER
(
parent
)
gtkWidget
)
;
}
LOGDRAGSERVICE
(
(
"
set
drag
popup
[
%
p
]
"
widget
.
get
(
)
)
)
;
OpenDragPopup
(
)
;
gtk_drag_set_icon_widget
(
aContext
gtkWidget
offsetX
offsetY
)
;
return
;
}
}
}
}
if
(
surface
)
{
if
(
!
SetAlphaPixmap
(
surface
aContext
offsetX
offsetY
dragRect
)
)
{
RefPtr
<
GdkPixbuf
>
dragPixbuf
=
nsImageToPixbuf
:
:
SourceSurfaceToPixbuf
(
surface
dragRect
.
width
dragRect
.
height
)
;
if
(
dragPixbuf
)
{
LOGDRAGSERVICE
(
(
"
set
drag
pixbuf
"
)
)
;
gtk_drag_set_icon_pixbuf
(
aContext
dragPixbuf
offsetX
offsetY
)
;
}
}
}
}
static
void
invisibleSourceDragBegin
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
{
LOGDRAGSERVICE
(
(
"
invisibleSourceDragBegin
(
%
p
)
"
aContext
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceBeginDrag
(
aContext
)
;
dragService
-
>
SetDragIcon
(
aContext
)
;
}
static
void
invisibleSourceDragDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
{
LOGDRAGSERVICE
(
(
"
invisibleSourceDragDataGet
(
%
p
)
"
aContext
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceDataGet
(
aWidget
aContext
aSelectionData
aTime
)
;
}
static
gboolean
invisibleSourceDragFailed
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aResult
gpointer
aData
)
{
#
ifdef
MOZ_WAYLAND
if
(
widget
:
:
GdkIsWaylandDisplay
(
)
&
&
aResult
=
=
MOZ_GTK_DRAG_RESULT_ERROR
)
{
for
(
GList
*
tmp
=
gdk_drag_context_list_targets
(
aContext
)
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
atom
)
)
;
if
(
name
&
&
!
strcmp
(
name
.
get
(
)
gTabDropType
)
)
{
aResult
=
MOZ_GTK_DRAG_RESULT_NO_TARGET
;
LOGDRAGSERVICE
(
(
"
invisibleSourceDragFailed
(
%
p
)
:
Wayland
tab
drop
\
n
"
aContext
)
)
;
break
;
}
}
}
#
endif
LOGDRAGSERVICE
(
(
"
invisibleSourceDragFailed
(
%
p
)
%
i
"
aContext
aResult
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceEndDragSession
(
aContext
aResult
)
;
return
FALSE
;
}
static
void
invisibleSourceDragEnd
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
{
LOGDRAGSERVICE
(
(
"
invisibleSourceDragEnd
(
%
p
)
"
aContext
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceEndDragSession
(
aContext
MOZ_GTK_DRAG_RESULT_SUCCESS
)
;
}
gboolean
nsDragService
:
:
ScheduleMotionEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
aDragContext
&
&
mScheduledTask
=
=
eDragTaskMotion
)
{
NS_WARNING
(
"
Drag
Motion
message
received
before
previous
reply
was
sent
"
)
;
}
return
Schedule
(
eDragTaskMotion
aWindow
aDragContext
aWindowPoint
aTime
)
;
}
void
nsDragService
:
:
ScheduleLeaveEvent
(
)
{
if
(
!
Schedule
(
eDragTaskLeave
nullptr
nullptr
LayoutDeviceIntPoint
(
)
0
)
)
{
NS_WARNING
(
"
Drag
leave
after
drop
"
)
;
}
}
gboolean
nsDragService
:
:
ScheduleDropEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
!
Schedule
(
eDragTaskDrop
aWindow
aDragContext
aWindowPoint
aTime
)
)
{
NS_WARNING
(
"
Additional
drag
drop
ignored
"
)
;
return
FALSE
;
}
SetDragEndPoint
(
aWindowPoint
)
;
return
TRUE
;
}
#
ifdef
MOZ_LOGGING
const
char
*
nsDragService
:
:
GetDragServiceTaskName
(
DragTask
aTask
)
{
static
const
char
*
taskNames
[
]
=
{
"
eDragTaskNone
"
"
eDragTaskMotion
"
"
eDragTaskLeave
"
"
eDragTaskDrop
"
"
eDragTaskSourceEnd
"
}
;
MOZ_ASSERT
(
size_t
(
aTask
)
<
ArrayLength
(
taskNames
)
)
;
return
taskNames
[
aTask
]
;
}
#
endif
gboolean
nsDragService
:
:
Schedule
(
DragTask
aTask
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
Schedule
(
%
p
)
task
%
s
window
%
p
\
n
"
aDragContext
GetDragServiceTaskName
(
aTask
)
aWindow
)
)
;
if
(
mScheduledTask
=
=
eDragTaskSourceEnd
|
|
(
mScheduledTask
=
=
eDragTaskDrop
&
&
aTask
!
=
eDragTaskSourceEnd
)
)
{
LOGDRAGSERVICE
(
(
"
task
does
not
fit
recent
task
%
s
quit
!
\
n
"
GetDragServiceTaskName
(
mScheduledTask
)
)
)
;
return
FALSE
;
}
mScheduledTask
=
aTask
;
mPendingWindow
=
aWindow
;
mPendingDragContext
=
aDragContext
;
mPendingWindowPoint
=
aWindowPoint
;
mPendingTime
=
aTime
;
if
(
!
mTaskSource
)
{
mTaskSource
=
g_timeout_add_full
(
G_PRIORITY_HIGH
0
TaskDispatchCallback
this
nullptr
)
;
}
return
TRUE
;
}
gboolean
nsDragService
:
:
TaskDispatchCallback
(
gpointer
data
)
{
RefPtr
<
nsDragService
>
dragService
=
static_cast
<
nsDragService
*
>
(
data
)
;
return
dragService
-
>
RunScheduledTask
(
)
;
}
gboolean
nsDragService
:
:
RunScheduledTask
(
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
RunScheduledTask
(
)
task
%
s
mTargetWindow
%
p
"
"
mPendingWindow
%
p
\
n
"
GetDragServiceTaskName
(
mScheduledTask
)
mTargetWindow
.
get
(
)
mPendingWindow
.
get
(
)
)
)
;
if
(
mScheduledTaskIsRunning
)
{
LOGDRAGSERVICE
(
(
"
sheduled
task
is
already
running
quit
.
"
)
)
;
return
FALSE
;
}
AutoRestore
<
bool
>
guard
(
mScheduledTaskIsRunning
)
;
mScheduledTaskIsRunning
=
true
;
if
(
mTargetWindow
&
&
mTargetWindow
!
=
mPendingWindow
)
{
LOGDRAGSERVICE
(
(
"
dispatch
eDragExit
(
%
p
)
\
n
"
mTargetWindow
.
get
(
)
)
)
;
mTargetWindow
-
>
DispatchDragEvent
(
eDragExit
mTargetWindowPoint
0
)
;
if
(
!
mSourceNode
)
{
EndDragSession
(
false
GetCurrentModifiers
(
)
)
;
}
}
bool
positionHasChanged
=
mPendingWindow
!
=
mTargetWindow
|
|
mPendingWindowPoint
!
=
mTargetWindowPoint
;
DragTask
task
=
mScheduledTask
;
mScheduledTask
=
eDragTaskNone
;
mTargetWindow
=
std
:
:
move
(
mPendingWindow
)
;
mTargetWindowPoint
=
mPendingWindowPoint
;
if
(
task
=
=
eDragTaskLeave
|
|
task
=
=
eDragTaskSourceEnd
)
{
LOGDRAGSERVICE
(
(
"
quit
selected
task
%
s
\
n
"
GetDragServiceTaskName
(
task
)
)
)
;
if
(
task
=
=
eDragTaskSourceEnd
)
{
EndDragSession
(
true
GetCurrentModifiers
(
)
)
;
}
mTaskSource
=
0
;
return
FALSE
;
}
StartDragSession
(
)
;
mTargetWidget
=
mTargetWindow
?
mTargetWindow
-
>
GetGtkWidget
(
)
:
nullptr
;
LOGDRAGSERVICE
(
(
"
start
drag
session
mTargetWindow
%
p
mTargetWidget
%
p
\
n
"
mTargetWindow
.
get
(
)
mTargetWidget
.
get
(
)
)
)
;
LOGDRAGSERVICE
(
(
"
mPendingDragContext
%
p
=
>
mTargetDragContext
%
p
\
n
"
mPendingDragContext
.
get
(
)
mTargetDragContext
.
get
(
)
)
)
;
mTargetDragContext
=
std
:
:
move
(
mPendingDragContext
)
;
mTargetTime
=
mPendingTime
;
if
(
task
=
=
eDragTaskMotion
|
|
positionHasChanged
)
{
LOGDRAGSERVICE
(
(
"
process
motion
event
\
n
"
)
)
;
UpdateDragAction
(
)
;
TakeDragEventDispatchedToChildProcess
(
)
;
DispatchMotionEvents
(
)
;
if
(
task
=
=
eDragTaskMotion
)
{
if
(
TakeDragEventDispatchedToChildProcess
(
)
)
{
mTargetDragContextForRemote
=
mTargetDragContext
;
}
else
{
ReplyToDragMotion
(
)
;
}
}
}
if
(
task
=
=
eDragTaskDrop
)
{
LOGDRAGSERVICE
(
(
"
process
drop
task
\
n
"
)
)
;
gboolean
success
=
DispatchDropEvent
(
)
;
if
(
mTargetDragContext
)
{
LOGDRAGSERVICE
(
(
"
drag
finished
\
n
"
)
)
;
gtk_drag_finish
(
mTargetDragContext
success
FALSE
mTargetTime
)
;
}
EndDragSession
(
true
GetCurrentModifiers
(
)
)
;
}
LOGDRAGSERVICE
(
(
"
clear
mTargetWindow
mTargetWidget
and
other
data
\
n
"
)
)
;
mTargetWidget
=
nullptr
;
mTargetDragContext
=
nullptr
;
if
(
mScheduledTask
!
=
eDragTaskNone
)
return
TRUE
;
LOGDRAGSERVICE
(
(
"
remove
task
source
\
n
"
)
)
;
mTaskSource
=
0
;
return
FALSE
;
}
void
nsDragService
:
:
UpdateDragAction
(
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
UpdateDragAction
(
%
p
)
\
n
"
mTargetDragContext
.
get
(
)
)
)
;
int
action
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
GdkDragAction
gdkAction
=
GDK_ACTION_DEFAULT
;
if
(
mTargetDragContext
)
{
gdkAction
=
gdk_drag_context_get_actions
(
mTargetDragContext
)
;
}
if
(
gdkAction
&
GDK_ACTION_DEFAULT
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
if
(
gdkAction
&
GDK_ACTION_MOVE
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
else
if
(
gdkAction
&
GDK_ACTION_LINK
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
else
if
(
gdkAction
&
GDK_ACTION_COPY
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
SetDragAction
(
action
)
;
}
NS_IMETHODIMP
nsDragService
:
:
UpdateDragEffect
(
)
{
LOGDRAGSERVICE
(
(
"
nsDragService
:
:
UpdateDragEffect
(
)
from
e10s
child
process
\
n
"
)
)
;
if
(
mTargetDragContextForRemote
)
{
ReplyToDragMotion
(
mTargetDragContextForRemote
)
;
mTargetDragContextForRemote
=
nullptr
;
}
return
NS_OK
;
}
void
nsDragService
:
:
ReplyToDragMotion
(
)
{
if
(
mTargetDragContext
)
{
ReplyToDragMotion
(
mTargetDragContext
)
;
}
}
void
nsDragService
:
:
DispatchMotionEvents
(
)
{
FireDragEventAtSource
(
eDrag
GetCurrentModifiers
(
)
)
;
if
(
mTargetWindow
)
{
mTargetWindow
-
>
DispatchDragEvent
(
eDragOver
mTargetWindowPoint
mTargetTime
)
;
}
}
gboolean
nsDragService
:
:
DispatchDropEvent
(
)
{
if
(
!
mTargetWindow
|
|
mTargetWindow
-
>
IsDestroyed
(
)
)
{
return
FALSE
;
}
EventMessage
msg
=
mCanDrop
?
eDrop
:
eDragExit
;
mTargetWindow
-
>
DispatchDragEvent
(
msg
mTargetWindowPoint
mTargetTime
)
;
return
mCanDrop
;
}
uint32_t
nsDragService
:
:
GetCurrentModifiers
(
)
{
return
mozilla
:
:
widget
:
:
KeymapWrapper
:
:
ComputeCurrentKeyModifiers
(
)
;
}
#
undef
LOGDRAGSERVICE
