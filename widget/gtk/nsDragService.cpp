#
include
"
nsDragService
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
prtime
.
h
"
#
include
"
prthread
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
include
"
GRefPtr
.
h
"
#
include
"
nsAppShell
.
h
"
#
ifdef
MOZ_X11
#
include
"
gfxXlibSurface
.
h
"
#
endif
#
include
"
gfxContext
.
h
"
#
include
"
nsImageToPixbuf
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsGtkUtils
.
h
"
#
include
"
nsGtkKeyUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
ScreenHelperGTK
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsDirectoryService
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
#
define
NS_DND_TIMEOUT
(
5
*
1000000
)
#
define
NS_DND_TMP_CLEANUP_TIMEOUT
(
1000
*
60
*
5
)
#
define
NS_SYSTEMINFO_CONTRACTID
"
mozilla
.
org
/
system
-
info
;
1
"
#
define
DRAG_IMAGE_ALPHA_LEVEL
0
.
5
#
ifdef
MOZ_LOGGING
extern
mozilla
:
:
LazyLogModule
gWidgetDragLog
;
#
define
LOGDRAGSERVICE
(
str
.
.
.
)
\
MOZ_LOG
(
gWidgetDragLog
mozilla
:
:
LogLevel
:
:
Debug
\
(
"
[
D
%
d
]
%
*
s
"
str
GetLoopDepth
(
)
\
GetLoopDepth
(
)
>
1
?
GetLoopDepth
(
)
*
2
:
0
"
"
#
#
__VA_ARGS__
)
)
#
define
LOGDRAGSERVICESTATIC
(
str
.
.
.
)
\
MOZ_LOG
(
gWidgetDragLog
mozilla
:
:
LogLevel
:
:
Debug
(
str
#
#
__VA_ARGS__
)
)
#
else
#
define
LOGDRAGSERVICE
(
.
.
.
)
#
endif
class
MOZ_STACK_CLASS
AutoSuspendNativeEvents
{
public
:
AutoSuspendNativeEvents
(
)
{
mAppShell
=
do_GetService
(
NS_APPSHELL_CID
)
;
mAppShell
-
>
SuspendNative
(
)
;
}
~
AutoSuspendNativeEvents
(
)
{
mAppShell
-
>
ResumeNative
(
)
;
}
private
:
nsCOMPtr
<
nsIAppShell
>
mAppShell
;
}
;
static
guint
sMotionEventTimerID
;
static
GdkEvent
*
sMotionEvent
;
static
GUniquePtr
<
GdkEvent
>
TakeMotionEvent
(
)
{
GUniquePtr
<
GdkEvent
>
event
(
sMotionEvent
)
;
sMotionEvent
=
nullptr
;
return
event
;
}
static
void
SetMotionEvent
(
GUniquePtr
<
GdkEvent
>
aEvent
)
{
TakeMotionEvent
(
)
;
sMotionEvent
=
aEvent
.
release
(
)
;
}
static
GtkWidget
*
sGrabWidget
;
static
constexpr
nsLiteralString
kDisallowedExportedSchemes
[
]
=
{
u
"
about
"
_ns
u
"
blob
"
_ns
u
"
cached
-
favicon
"
_ns
u
"
chrome
"
_ns
u
"
imap
"
_ns
u
"
javascript
"
_ns
u
"
mailbox
"
_ns
u
"
news
"
_ns
u
"
page
-
icon
"
_ns
u
"
resource
"
_ns
u
"
view
-
source
"
_ns
u
"
moz
-
extension
"
_ns
u
"
moz
-
page
-
thumb
"
_ns
}
;
static
const
char
gMozUrlType
[
]
=
"
_NETSCAPE_URL
"
;
static
const
char
gMimeListType
[
]
=
"
application
/
x
-
moz
-
internal
-
item
-
list
"
;
static
const
char
gTextUriListType
[
]
=
"
text
/
uri
-
list
"
;
static
const
char
gTextPlainUTF8Type
[
]
=
"
text
/
plain
;
charset
=
utf
-
8
"
;
static
const
char
gXdndDirectSaveType
[
]
=
"
XdndDirectSave0
"
;
static
const
char
gTabDropType
[
]
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
static
const
char
gPortalFile
[
]
=
"
application
/
vnd
.
portal
.
files
"
;
static
const
char
gPortalFileTransfer
[
]
=
"
application
/
vnd
.
portal
.
filetransfer
"
;
GdkAtom
nsDragService
:
:
sJPEGImageMimeAtom
;
GdkAtom
nsDragService
:
:
sJPGImageMimeAtom
;
GdkAtom
nsDragService
:
:
sPNGImageMimeAtom
;
GdkAtom
nsDragService
:
:
sGIFImageMimeAtom
;
GdkAtom
nsDragService
:
:
sCustomTypesMimeAtom
;
GdkAtom
nsDragService
:
:
sURLMimeAtom
;
GdkAtom
nsDragService
:
:
sRTFMimeAtom
;
GdkAtom
nsDragService
:
:
sTextMimeAtom
;
GdkAtom
nsDragService
:
:
sMozUrlTypeAtom
;
GdkAtom
nsDragService
:
:
sMimeListTypeAtom
;
GdkAtom
nsDragService
:
:
sTextUriListTypeAtom
;
GdkAtom
nsDragService
:
:
sTextPlainUTF8TypeAtom
;
GdkAtom
nsDragService
:
:
sXdndDirectSaveTypeAtom
;
GdkAtom
nsDragService
:
:
sTabDropTypeAtom
;
GdkAtom
nsDragService
:
:
sFileMimeAtom
;
GdkAtom
nsDragService
:
:
sPortalFileAtom
;
GdkAtom
nsDragService
:
:
sPortalFileTransferAtom
;
static
const
char
kGtkDragResults
[
]
[
100
]
{
"
GTK_DRAG_RESULT_SUCCESS
"
"
GTK_DRAG_RESULT_NO_TARGET
"
"
GTK_DRAG_RESULT_USER_CANCELLED
"
"
GTK_DRAG_RESULT_TIMEOUT_EXPIRED
"
"
GTK_DRAG_RESULT_GRAB_BROKEN
"
"
GTK_DRAG_RESULT_ERROR
"
}
;
static
void
invisibleSourceDragBegin
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
;
static
void
invisibleSourceDragEnd
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
;
static
gboolean
invisibleSourceDragFailed
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aResult
gpointer
aData
)
;
static
void
invisibleSourceDragDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
;
static
void
UTF16ToNewUTF8
(
const
char16_t
*
aUTF16
uint32_t
aUTF16Len
char
*
*
aUTF8
uint32_t
*
aUTF8Len
)
{
nsDependentSubstring
utf16
(
aUTF16
aUTF16Len
)
;
*
aUTF8
=
ToNewUTF8String
(
utf16
aUTF8Len
)
;
}
static
nsString
UTF8ToNewString
(
const
char
*
aUTF8
uint32_t
aUTF8Len
=
0
)
{
nsDependentCSubstring
utf8
(
aUTF8
aUTF8Len
?
aUTF8Len
:
strlen
(
aUTF8
)
)
;
nsString
ret
;
uint32_t
convertedTextLen
=
0
;
char16_t
*
convertedText
=
UTF8ToNewUnicode
(
utf8
&
convertedTextLen
)
;
if
(
!
convertedText
)
{
return
ret
;
}
convertedTextLen
*
=
2
;
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
false
(
void
*
*
)
&
convertedText
(
int32_t
*
)
&
convertedTextLen
)
;
ret
.
Adopt
(
convertedText
convertedTextLen
/
2
)
;
return
ret
;
}
static
bool
GetFileFromUri
(
const
nsCString
&
aUri
nsCOMPtr
<
nsIFile
>
&
aFile
)
{
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
nsCOMPtr
<
nsIURI
>
fileURI
;
if
(
NS_SUCCEEDED
(
ioService
-
>
NewURI
(
aUri
nullptr
nullptr
getter_AddRefs
(
fileURI
)
)
)
)
{
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
fileURI
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
NS_SUCCEEDED
(
fileURL
-
>
GetFile
(
getter_AddRefs
(
aFile
)
)
)
)
{
return
true
;
}
}
}
LOGDRAG
(
"
GetFileFromUri
(
)
failed
"
)
;
return
false
;
}
bool
DragData
:
:
IsImageFlavor
(
)
const
{
return
mDataFlavor
=
=
nsDragService
:
:
sJPEGImageMimeAtom
|
|
mDataFlavor
=
=
nsDragService
:
:
sJPGImageMimeAtom
|
|
mDataFlavor
=
=
nsDragService
:
:
sPNGImageMimeAtom
|
|
mDataFlavor
=
=
nsDragService
:
:
sGIFImageMimeAtom
;
}
bool
DragData
:
:
IsFileFlavor
(
)
const
{
return
mDataFlavor
=
=
nsDragService
:
:
sFileMimeAtom
|
|
mDataFlavor
=
=
nsDragService
:
:
sPortalFileAtom
|
|
mDataFlavor
=
=
nsDragService
:
:
sPortalFileTransferAtom
;
}
bool
DragData
:
:
IsTextFlavor
(
)
const
{
return
mDataFlavor
=
=
nsDragService
:
:
sTextMimeAtom
|
|
mDataFlavor
=
=
nsDragService
:
:
sTextPlainUTF8TypeAtom
;
}
bool
DragData
:
:
IsURIFlavor
(
)
const
{
return
mDataFlavor
=
=
nsDragService
:
:
sURLMimeAtom
;
}
int
DragData
:
:
GetURIsNum
(
)
const
{
int
urlNum
=
1
;
if
(
mDragUris
)
{
urlNum
=
g_strv_length
(
mDragUris
.
get
(
)
)
;
}
else
if
(
IsURIFlavor
(
)
)
{
urlNum
=
mUris
.
Length
(
)
;
}
LOGDRAG
(
"
DragData
:
:
GetURIsNum
(
)
%
d
"
urlNum
)
;
return
urlNum
;
}
bool
DragData
:
:
Export
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
{
GUniquePtr
<
gchar
>
flavorName
(
gdk_atom_name
(
mDataFlavor
)
)
;
LOGDRAG
(
"
DragData
:
:
Export
(
)
MIME
%
s
index
%
d
"
flavorName
.
get
(
)
aItemIndex
)
;
if
(
IsFileFlavor
(
)
)
{
MOZ_ASSERT
(
mDragUris
.
get
(
)
)
;
char
*
*
list
=
mDragUris
.
get
(
)
;
if
(
aItemIndex
>
=
g_strv_length
(
list
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
DragData
:
:
Export
(
)
:
Index
%
d
is
overflow
file
list
len
%
d
"
aItemIndex
g_strv_length
(
list
)
)
.
get
(
)
)
;
return
false
;
}
bool
fileExists
=
false
;
nsCOMPtr
<
nsIFile
>
file
;
if
(
GetFileFromUri
(
nsDependentCString
(
list
[
aItemIndex
]
)
file
)
)
{
file
-
>
Exists
(
&
fileExists
)
;
}
if
(
!
fileExists
)
{
LOGDRAG
(
"
uri
%
s
not
reachable
/
not
found
\
n
"
list
[
aItemIndex
]
)
;
return
false
;
}
LOGDRAG
(
"
export
file
%
s
(
flavor
:
%
s
)
as
%
s
"
list
[
aItemIndex
]
flavorName
.
get
(
)
kFileMime
)
;
aTransferable
-
>
SetTransferData
(
kFileMime
file
)
;
return
true
;
}
if
(
IsURIFlavor
(
)
)
{
MOZ_ASSERT
(
mAsURIData
)
;
if
(
aItemIndex
>
=
mUris
.
Length
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
DragData
:
:
Export
(
)
:
Index
%
d
is
overflow
uri
list
len
%
d
"
aItemIndex
(
int
)
mUris
.
Length
(
)
)
.
get
(
)
)
;
return
false
;
}
LOGDRAG
(
"
%
d
URI
:
\
n
%
s
"
(
int
)
aItemIndex
NS_ConvertUTF16toUTF8
(
mUris
[
aItemIndex
]
)
.
get
(
)
)
;
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
nsAutoCString
(
kURLMime
)
mUris
[
aItemIndex
]
.
get
(
)
mUris
[
aItemIndex
]
.
Length
(
)
*
2
getter_AddRefs
(
genericDataWrapper
)
)
;
return
NS_SUCCEEDED
(
aTransferable
-
>
SetTransferData
(
kURLMime
genericDataWrapper
)
)
;
}
if
(
IsImageFlavor
(
)
)
{
LOGDRAG
(
"
export
image
%
s
"
flavorName
.
get
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
byteStream
;
NS_NewByteInputStream
(
getter_AddRefs
(
byteStream
)
mozilla
:
:
Span
(
(
char
*
)
mDragData
.
get
(
)
mDragDataLen
)
NS_ASSIGNMENT_COPY
)
;
return
NS_SUCCEEDED
(
aTransferable
-
>
SetTransferData
(
flavorName
.
get
(
)
byteStream
)
)
;
}
if
(
IsTextFlavor
(
)
)
{
LOGDRAG
(
"
export
text
%
s
"
kTextMime
)
;
if
(
mData
.
IsEmpty
(
)
&
&
mDragDataLen
)
{
mData
=
UTF8ToNewString
(
static_cast
<
const
char
*
>
(
mDragData
.
get
(
)
)
mDragDataLen
)
;
}
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
nsAutoCString
(
kTextMime
)
mData
.
get
(
)
mData
.
Length
(
)
*
2
getter_AddRefs
(
genericDataWrapper
)
)
;
return
NS_SUCCEEDED
(
aTransferable
-
>
SetTransferData
(
kTextMime
genericDataWrapper
)
)
;
}
if
(
!
mDragDataDOMEndings
&
&
mDataFlavor
!
=
nsDragService
:
:
sCustomTypesMimeAtom
)
{
mDragDataDOMEndings
=
true
;
void
*
tmpData
=
mDragData
.
release
(
)
;
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
mDataFlavor
=
=
nsDragService
:
:
sRTFMimeAtom
&
tmpData
(
int32_t
*
)
&
mDragDataLen
)
;
mDragData
.
reset
(
tmpData
)
;
}
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
nsDependentCString
(
flavorName
.
get
(
)
)
mDragData
.
get
(
)
mDragDataLen
getter_AddRefs
(
genericDataWrapper
)
)
;
return
NS_SUCCEEDED
(
aTransferable
-
>
SetTransferData
(
flavorName
.
get
(
)
genericDataWrapper
)
)
;
}
RefPtr
<
DragData
>
DragData
:
:
ConvertToMozURL
(
)
const
{
if
(
mDataFlavor
=
=
nsDragService
:
:
sTextUriListTypeAtom
)
{
MOZ_ASSERT
(
mAsURIData
&
&
mDragUris
)
;
LOGDRAG
(
"
ConvertToMozURL
(
)
:
text
/
uri
-
list
=
>
text
/
x
-
moz
-
url
"
)
;
RefPtr
<
DragData
>
data
=
new
DragData
(
nsDragService
:
:
sURLMimeAtom
)
;
data
-
>
mAsURIData
=
true
;
int
len
=
g_strv_length
(
mDragUris
.
get
(
)
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
data
-
>
mUris
.
AppendElement
(
UTF8ToNewString
(
mDragUris
.
get
(
)
[
i
]
)
)
;
}
return
data
;
}
if
(
mDataFlavor
=
=
nsDragService
:
:
sMozUrlTypeAtom
)
{
MOZ_ASSERT
(
mDragData
)
;
LOGDRAG
(
"
ConvertToMozURL
(
)
:
_NETSCAPE_URL
=
>
text
/
x
-
moz
-
url
"
)
;
RefPtr
<
DragData
>
data
=
new
DragData
(
nsDragService
:
:
sURLMimeAtom
)
;
data
-
>
mAsURIData
=
true
;
data
-
>
mUris
.
AppendElement
(
UTF8ToNewString
(
(
const
char
*
)
mDragData
.
get
(
)
mDragDataLen
)
)
;
return
data
;
}
LOGDRAG
(
"
ConvertToMozURL
(
)
:
failed
wrong
MIME
%
s
to
convert
!
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
mDataFlavor
)
)
.
get
(
)
)
;
return
nullptr
;
}
RefPtr
<
DragData
>
DragData
:
:
ConvertToFile
(
)
const
{
if
(
mDataFlavor
!
=
nsDragService
:
:
sTextUriListTypeAtom
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mAsURIData
&
&
mDragUris
)
;
return
new
DragData
(
nsDragService
:
:
sFileMimeAtom
g_strdupv
(
mDragUris
.
get
(
)
)
)
;
}
static
int
CopyURI
(
const
nsAString
&
aSourceURL
nsAString
&
aTargetURL
int
aOffset
bool
aRequestNewLine
)
{
int32_t
uriEnd
=
aSourceURL
.
FindChar
(
u
'
\
n
'
aOffset
)
;
if
(
uriEnd
=
=
aOffset
)
{
return
aOffset
+
1
;
}
if
(
uriEnd
<
0
)
{
if
(
aRequestNewLine
)
{
return
uriEnd
;
}
uriEnd
=
aSourceURL
.
Length
(
)
;
}
int32_t
newOffset
=
uriEnd
+
1
;
if
(
aSourceURL
[
uriEnd
-
1
]
=
=
u
'
\
r
'
)
{
uriEnd
-
-
;
}
nsDependentSubstring
url
(
aSourceURL
aOffset
uriEnd
-
aOffset
)
;
if
(
aRequestNewLine
)
{
url
.
AppendLiteral
(
"
\
n
"
)
;
}
aTargetURL
.
Append
(
url
)
;
return
newOffset
;
}
void
DragData
:
:
ConvertToMozURIList
(
)
{
if
(
mDataFlavor
!
=
nsDragService
:
:
sURLMimeAtom
)
{
return
;
}
mAsURIData
=
true
;
const
nsDependentSubstring
uris
(
(
char16_t
*
)
mDragData
.
get
(
)
mDragDataLen
/
2
)
;
int32_t
uriBegin
=
0
;
do
{
nsAutoString
uri
;
if
(
(
uriBegin
=
CopyURI
(
uris
uri
uriBegin
true
)
)
<
0
)
{
break
;
}
if
(
(
uriBegin
=
CopyURI
(
uris
uri
uriBegin
false
)
)
<
0
)
{
break
;
}
mUris
.
AppendElement
(
uri
)
;
}
while
(
uriBegin
<
(
int32_t
)
uris
.
Length
(
)
)
;
mDragData
=
nullptr
;
mDragDataLen
=
0
;
}
DragData
:
:
DragData
(
GdkAtom
aDataFlavor
gchar
*
*
aDragUris
)
:
mDataFlavor
(
aDataFlavor
)
mAsURIData
(
true
)
mDragUris
(
aDragUris
)
{
}
#
ifdef
MOZ_LOGGING
void
DragData
:
:
Print
(
)
const
{
if
(
mDragData
)
{
if
(
IsTextFlavor
(
)
)
{
nsCString
text
(
(
char
*
)
mDragData
.
get
(
)
mDragDataLen
)
;
LOGDRAG
(
"
DragData
(
)
plain
data
MIME
:
%
s
:
%
s
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
mDataFlavor
)
)
.
get
(
)
(
char
*
)
text
.
get
(
)
)
;
}
if
(
IsURIFlavor
(
)
)
{
nsString
text
(
(
char16_t
*
)
mDragData
.
get
(
)
mDragDataLen
/
2
)
;
LOGDRAG
(
"
DragData
(
)
plain
data
MIME
:
%
s
:
%
s
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
mDataFlavor
)
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
text
)
.
get
(
)
)
;
}
}
else
if
(
mDragUris
)
{
LOGDRAG
(
"
DragData
(
)
URI
MIME
%
s
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
mDataFlavor
)
)
.
get
(
)
)
;
if
(
MOZ_LOG_TEST
(
gWidgetDragLog
mozilla
:
:
LogLevel
:
:
Debug
)
)
{
int
i
=
0
;
for
(
gchar
*
*
uri
=
mDragUris
.
get
(
)
;
uri
&
&
*
uri
;
uri
+
+
i
+
+
)
{
LOGDRAG
(
"
%
d
URI
%
s
"
i
*
uri
)
;
}
}
}
else
if
(
mUris
.
Length
(
)
)
{
LOGDRAG
(
"
DragData
(
)
URI
MIME
:
%
s
len
%
d
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
mDataFlavor
)
)
.
get
(
)
(
int
)
mUris
.
Length
(
)
)
;
for
(
size_t
i
=
0
;
i
<
mUris
.
Length
(
)
;
i
+
+
)
{
LOGDRAG
(
"
%
d
URI
:
\
n
%
s
"
(
int
)
i
NS_ConvertUTF16toUTF8
(
mUris
[
i
]
)
.
get
(
)
)
;
}
}
else
{
LOGDRAG
(
"
DragData
(
)
MIME
%
s
is
missing
data
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
mDataFlavor
)
)
.
get
(
)
)
;
}
}
#
endif
nsDragService
:
:
nsDragService
(
)
:
mScheduledTask
(
eDragTaskNone
)
mTaskSource
(
0
)
mScheduledTaskIsRunning
(
false
)
mCachedDragContext
(
)
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obsServ
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
mHiddenWidget
=
gtk_offscreen_window_new
(
)
;
gtk_widget_realize
(
mHiddenWidget
)
;
g_signal_connect
(
mHiddenWidget
"
drag_begin
"
G_CALLBACK
(
invisibleSourceDragBegin
)
this
)
;
g_signal_connect
(
mHiddenWidget
"
drag_data_get
"
G_CALLBACK
(
invisibleSourceDragDataGet
)
this
)
;
g_signal_connect
(
mHiddenWidget
"
drag_end
"
G_CALLBACK
(
invisibleSourceDragEnd
)
this
)
;
guint
dragFailedID
=
g_signal_lookup
(
"
drag
-
failed
"
G_TYPE_FROM_INSTANCE
(
mHiddenWidget
)
)
;
if
(
dragFailedID
)
{
g_signal_connect_closure_by_id
(
mHiddenWidget
dragFailedID
0
g_cclosure_new
(
G_CALLBACK
(
invisibleSourceDragFailed
)
this
nullptr
)
FALSE
)
;
}
mCanDrop
=
false
;
mTempFileTimerID
=
0
;
mEventLoopDepth
=
0
;
static
std
:
:
once_flag
onceFlag
;
std
:
:
call_once
(
onceFlag
[
]
{
sJPEGImageMimeAtom
=
gdk_atom_intern
(
kJPEGImageMime
FALSE
)
;
sJPGImageMimeAtom
=
gdk_atom_intern
(
kJPGImageMime
FALSE
)
;
sPNGImageMimeAtom
=
gdk_atom_intern
(
kPNGImageMime
FALSE
)
;
sGIFImageMimeAtom
=
gdk_atom_intern
(
kGIFImageMime
FALSE
)
;
sCustomTypesMimeAtom
=
gdk_atom_intern
(
kCustomTypesMime
FALSE
)
;
sURLMimeAtom
=
gdk_atom_intern
(
kURLMime
FALSE
)
;
sRTFMimeAtom
=
gdk_atom_intern
(
kRTFMime
FALSE
)
;
sTextMimeAtom
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
sMozUrlTypeAtom
=
gdk_atom_intern
(
gMozUrlType
FALSE
)
;
sMimeListTypeAtom
=
gdk_atom_intern
(
gMimeListType
FALSE
)
;
sTextUriListTypeAtom
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
sTextPlainUTF8TypeAtom
=
gdk_atom_intern
(
gTextPlainUTF8Type
FALSE
)
;
sXdndDirectSaveTypeAtom
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
sTabDropTypeAtom
=
gdk_atom_intern
(
gTabDropType
FALSE
)
;
sFileMimeAtom
=
gdk_atom_intern
(
kFileMime
FALSE
)
;
sPortalFileAtom
=
gdk_atom_intern
(
gPortalFile
FALSE
)
;
sPortalFileTransferAtom
=
gdk_atom_intern
(
gPortalFileTransfer
FALSE
)
;
}
)
;
LOGDRAGSERVICE
(
"
nsDragService
:
:
nsDragService
"
)
;
}
nsDragService
:
:
~
nsDragService
(
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
~
nsDragService
"
)
;
if
(
mTaskSource
)
g_source_remove
(
mTaskSource
)
;
if
(
mTempFileTimerID
)
{
g_source_remove
(
mTempFileTimerID
)
;
RemoveTempFiles
(
)
;
}
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsDragService
nsBaseDragService
nsIObserver
)
mozilla
:
:
StaticRefPtr
<
nsDragService
>
sDragServiceInstance
;
already_AddRefed
<
nsDragService
>
nsDragService
:
:
GetInstance
(
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
nullptr
;
}
if
(
!
sDragServiceInstance
)
{
sDragServiceInstance
=
new
nsDragService
(
)
;
ClearOnShutdown
(
&
sDragServiceInstance
)
;
}
RefPtr
<
nsDragService
>
service
=
sDragServiceInstance
.
get
(
)
;
return
service
.
forget
(
)
;
}
NS_IMETHODIMP
nsDragService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
quit
-
application
"
)
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
Observe
(
\
"
quit
-
application
\
"
)
"
)
;
if
(
mHiddenWidget
)
{
gtk_widget_destroy
(
mHiddenWidget
)
;
mHiddenWidget
=
0
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
topic
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
static
gboolean
DispatchMotionEventCopy
(
gpointer
aData
)
{
sMotionEventTimerID
=
0
;
GUniquePtr
<
GdkEvent
>
event
=
TakeMotionEvent
(
)
;
if
(
gtk_widget_has_grab
(
sGrabWidget
)
)
{
gtk_propagate_event
(
sGrabWidget
event
.
get
(
)
)
;
}
return
FALSE
;
}
static
void
OnSourceGrabEventAfter
(
GtkWidget
*
widget
GdkEvent
*
event
gpointer
user_data
)
{
if
(
!
gtk_widget_has_grab
(
sGrabWidget
)
)
return
;
if
(
event
-
>
type
=
=
GDK_MOTION_NOTIFY
)
{
SetMotionEvent
(
GUniquePtr
<
GdkEvent
>
(
gdk_event_copy
(
event
)
)
)
;
nsDragService
*
dragService
=
static_cast
<
nsDragService
*
>
(
user_data
)
;
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
auto
p
=
LayoutDeviceIntPoint
:
:
Round
(
event
-
>
motion
.
x_root
*
scale
event
-
>
motion
.
y_root
*
scale
)
;
dragService
-
>
SetDragEndPoint
(
p
)
;
}
else
if
(
sMotionEvent
&
&
(
event
-
>
type
=
=
GDK_KEY_PRESS
|
|
event
-
>
type
=
=
GDK_KEY_RELEASE
)
)
{
sMotionEvent
-
>
motion
.
state
=
event
-
>
key
.
state
;
}
else
{
return
;
}
if
(
sMotionEventTimerID
)
{
g_source_remove
(
sMotionEventTimerID
)
;
}
sMotionEventTimerID
=
g_timeout_add_full
(
G_PRIORITY_DEFAULT_IDLE
350
DispatchMotionEventCopy
nullptr
nullptr
)
;
}
static
GtkWindow
*
GetGtkWindow
(
dom
:
:
Document
*
aDocument
)
{
if
(
!
aDocument
)
return
nullptr
;
PresShell
*
presShell
=
aDocument
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
RefPtr
<
nsViewManager
>
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
=
vm
-
>
GetRootWidget
(
)
;
if
(
!
widget
)
return
nullptr
;
GtkWidget
*
gtkWidget
=
static_cast
<
nsWindow
*
>
(
widget
.
get
(
)
)
-
>
GetGtkWidget
(
)
;
if
(
!
gtkWidget
)
return
nullptr
;
GtkWidget
*
toplevel
=
nullptr
;
toplevel
=
gtk_widget_get_toplevel
(
gtkWidget
)
;
if
(
!
GTK_IS_WINDOW
(
toplevel
)
)
return
nullptr
;
return
GTK_WINDOW
(
toplevel
)
;
}
NS_IMETHODIMP
nsDragService
:
:
InvokeDragSession
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsICookieJarSettings
*
aCookieJarSettings
nsIArray
*
aArrayTransferables
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_OTHER
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
InvokeDragSession
"
)
;
if
(
mSourceNode
)
return
NS_ERROR_NOT_AVAILABLE
;
return
nsBaseDragService
:
:
InvokeDragSession
(
aDOMNode
aPrincipal
aCsp
aCookieJarSettings
aArrayTransferables
aActionType
aContentPolicyType
)
;
}
nsresult
nsDragService
:
:
InvokeDragSessionImpl
(
nsIArray
*
aArrayTransferables
const
Maybe
<
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
{
if
(
!
aArrayTransferables
)
return
NS_ERROR_INVALID_ARG
;
mSourceDataItems
=
aArrayTransferables
;
LOGDRAGSERVICE
(
"
nsDragService
:
:
InvokeDragSessionImpl
"
)
;
GdkDevice
*
device
=
widget
:
:
GdkGetPointer
(
)
;
GdkWindow
*
originGdkWindow
=
nullptr
;
if
(
widget
:
:
GdkIsWaylandDisplay
(
)
|
|
widget
:
:
IsXWaylandProtocol
(
)
)
{
originGdkWindow
=
gdk_device_get_window_at_position
(
device
nullptr
nullptr
)
;
if
(
!
originGdkWindow
)
{
NS_WARNING
(
"
nsDragService
:
:
InvokeDragSessionImpl
(
)
:
Missing
origin
GdkWindow
!
"
)
;
return
NS_ERROR_FAILURE
;
}
}
GtkTargetList
*
sourceList
=
GetSourceList
(
)
;
if
(
!
sourceList
)
return
NS_OK
;
GdkDragAction
action
=
GDK_ACTION_DEFAULT
;
if
(
aActionType
&
DRAGDROP_ACTION_COPY
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_COPY
)
;
if
(
aActionType
&
DRAGDROP_ACTION_MOVE
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_MOVE
)
;
if
(
aActionType
&
DRAGDROP_ACTION_LINK
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_LINK
)
;
GdkEvent
*
existingEvent
=
widget
:
:
GetLastMousePressEvent
(
)
;
GdkEvent
fakeEvent
;
if
(
!
existingEvent
)
{
memset
(
&
fakeEvent
0
sizeof
(
GdkEvent
)
)
;
fakeEvent
.
type
=
GDK_BUTTON_PRESS
;
fakeEvent
.
button
.
window
=
gtk_widget_get_window
(
mHiddenWidget
)
;
fakeEvent
.
button
.
time
=
nsWindow
:
:
GetLastUserInputTime
(
)
;
fakeEvent
.
button
.
device
=
device
;
}
GtkWindowGroup
*
window_group
=
gtk_window_get_group
(
GetGtkWindow
(
mSourceDocument
)
)
;
gtk_window_group_add_window
(
window_group
GTK_WINDOW
(
mHiddenWidget
)
)
;
GdkDragContext
*
context
=
gtk_drag_begin_with_coordinates
(
mHiddenWidget
sourceList
action
1
existingEvent
?
existingEvent
:
&
fakeEvent
-
1
-
1
)
;
if
(
originGdkWindow
)
{
mSourceWindow
=
nsWindow
:
:
GetWindow
(
originGdkWindow
)
;
if
(
mSourceWindow
)
{
mSourceWindow
-
>
SetDragSource
(
context
)
;
}
}
LOGDRAGSERVICE
(
"
GdkDragContext
[
%
p
]
nsWindow
[
%
p
]
"
context
mSourceWindow
.
get
(
)
)
;
nsresult
rv
;
if
(
context
)
{
StartDragSession
(
)
;
sGrabWidget
=
gtk_window_group_get_current_grab
(
window_group
)
;
if
(
sGrabWidget
)
{
g_object_ref
(
sGrabWidget
)
;
g_signal_connect
(
sGrabWidget
"
event
-
after
"
G_CALLBACK
(
OnSourceGrabEventAfter
)
this
)
;
}
mEndDragPoint
=
LayoutDeviceIntPoint
(
-
1
-
1
)
;
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
gtk_target_list_unref
(
sourceList
)
;
return
rv
;
}
bool
nsDragService
:
:
SetAlphaPixmap
(
SourceSurface
*
aSurface
GdkDragContext
*
aContext
int32_t
aXOffset
int32_t
aYOffset
const
LayoutDeviceIntRect
&
dragRect
)
{
GdkScreen
*
screen
=
gtk_widget_get_screen
(
mHiddenWidget
)
;
if
(
!
gdk_screen_is_composited
(
screen
)
)
{
return
false
;
}
#
ifdef
cairo_image_surface_create
#
error
"
Looks
like
we
'
re
including
Mozilla
'
s
cairo
instead
of
system
cairo
"
#
endif
cairo_surface_t
*
surf
=
cairo_image_surface_create
(
CAIRO_FORMAT_ARGB32
dragRect
.
width
dragRect
.
height
)
;
if
(
!
surf
)
return
false
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
CreateDrawTargetForData
(
cairo_image_surface_get_data
(
surf
)
nsIntSize
(
dragRect
.
width
dragRect
.
height
)
cairo_image_surface_get_stride
(
surf
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
return
false
;
dt
-
>
ClearRect
(
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
)
;
dt
-
>
DrawSurface
(
aSurface
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
DRAG_IMAGE_ALPHA_LEVEL
CompositionOp
:
:
OP_SOURCE
)
)
;
cairo_surface_mark_dirty
(
surf
)
;
cairo_surface_set_device_offset
(
surf
-
aXOffset
-
aYOffset
)
;
static
auto
sCairoSurfaceSetDeviceScalePtr
=
(
void
(
*
)
(
cairo_surface_t
*
double
double
)
)
dlsym
(
RTLD_DEFAULT
"
cairo_surface_set_device_scale
"
)
;
if
(
sCairoSurfaceSetDeviceScalePtr
)
{
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
sCairoSurfaceSetDeviceScalePtr
(
surf
scale
scale
)
;
}
gtk_drag_set_icon_surface
(
aContext
surf
)
;
cairo_surface_destroy
(
surf
)
;
return
true
;
}
NS_IMETHODIMP
nsDragService
:
:
StartDragSession
(
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
StartDragSession
"
)
;
mTempFileUrls
.
Clear
(
)
;
return
nsBaseDragService
:
:
StartDragSession
(
)
;
}
bool
nsDragService
:
:
RemoveTempFiles
(
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
RemoveTempFiles
"
)
;
auto
files
=
std
:
:
move
(
mTemporaryFiles
)
;
for
(
nsIFile
*
file
:
files
)
{
#
ifdef
MOZ_LOGGING
if
(
MOZ_LOG_TEST
(
gWidgetDragLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
path
;
if
(
NS_SUCCEEDED
(
file
-
>
GetNativePath
(
path
)
)
)
{
LOGDRAGSERVICE
(
"
removing
%
s
"
path
.
get
(
)
)
;
}
}
#
endif
file
-
>
Remove
(
true
)
;
}
MOZ_ASSERT
(
mTemporaryFiles
.
IsEmpty
(
)
)
;
mTempFileTimerID
=
0
;
return
false
;
}
gboolean
nsDragService
:
:
TaskRemoveTempFiles
(
gpointer
data
)
{
RefPtr
<
nsDragService
>
dragService
=
static_cast
<
nsDragService
*
>
(
data
)
;
return
dragService
-
>
RemoveTempFiles
(
)
;
}
NS_IMETHODIMP
nsDragService
:
:
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
EndDragSession
(
%
p
)
%
d
"
mTargetDragContext
.
get
(
)
aDoneDrag
)
;
if
(
sGrabWidget
)
{
g_signal_handlers_disconnect_by_func
(
sGrabWidget
FuncToGpointer
(
OnSourceGrabEventAfter
)
this
)
;
g_object_unref
(
sGrabWidget
)
;
sGrabWidget
=
nullptr
;
if
(
sMotionEventTimerID
)
{
g_source_remove
(
sMotionEventTimerID
)
;
sMotionEventTimerID
=
0
;
}
if
(
sMotionEvent
)
{
TakeMotionEvent
(
)
;
}
}
SetDragAction
(
DRAGDROP_ACTION_NONE
)
;
if
(
mTemporaryFiles
.
Count
(
)
>
0
&
&
!
mTempFileTimerID
)
{
LOGDRAGSERVICE
(
"
queue
removing
of
temporary
files
"
)
;
mTempFileTimerID
=
g_timeout_add
(
NS_DND_TMP_CLEANUP_TIMEOUT
TaskRemoveTempFiles
this
)
;
mTempFileUrls
.
Clear
(
)
;
}
if
(
mSourceWindow
)
{
mSourceWindow
-
>
SetDragSource
(
nullptr
)
;
mSourceWindow
=
nullptr
;
}
mTargetDragContextForRemote
=
nullptr
;
mTargetWindow
=
nullptr
;
mPendingWindow
=
nullptr
;
mPendingDragContext
=
nullptr
;
mPendingWindowPoint
=
{
}
;
mScheduledTask
=
eDragTaskNone
;
if
(
mTaskSource
)
{
g_source_remove
(
mTaskSource
)
;
mTaskSource
=
0
;
}
mPendingTime
=
0
;
mCachedDragContext
=
0
;
return
nsBaseDragService
:
:
EndDragSession
(
aDoneDrag
aKeyModifiers
)
;
}
NS_IMETHODIMP
nsDragService
:
:
SetCanDrop
(
bool
aCanDrop
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SetCanDrop
%
d
"
aCanDrop
)
;
mCanDrop
=
aCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetCanDrop
(
bool
*
aCanDrop
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
GetCanDrop
"
)
;
*
aCanDrop
=
mCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
GetNumDropItems
"
)
;
if
(
!
mTargetWidget
)
{
LOGDRAGSERVICE
(
"
*
*
*
warning
:
GetNumDropItems
\
called
without
a
valid
target
widget
!
\
n
"
)
;
*
aNumItems
=
0
;
return
NS_OK
;
}
if
(
IsTargetContextList
(
)
)
{
if
(
!
mSourceDataItems
)
{
*
aNumItems
=
0
;
return
NS_OK
;
}
mSourceDataItems
-
>
GetLength
(
aNumItems
)
;
LOGDRAGSERVICE
(
"
GetNumDropItems
(
)
:
TargetContextList
items
%
d
"
*
aNumItems
)
;
return
NS_OK
;
}
const
GdkAtom
fileListFlavors
[
]
=
{
sURLMimeAtom
sTextUriListTypeAtom
sPortalFileAtom
sPortalFileTransferAtom
}
;
for
(
auto
fileFlavour
:
fileListFlavors
)
{
RefPtr
<
DragData
>
data
=
GetDragData
(
fileFlavour
)
;
if
(
data
)
{
*
aNumItems
=
data
-
>
GetURIsNum
(
)
;
LOGDRAGSERVICE
(
"
GetNumDropItems
(
)
:
Found
MIME
%
s
items
%
d
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
fileFlavour
)
)
.
get
(
)
*
aNumItems
)
;
return
NS_OK
;
}
}
*
aNumItems
=
1
;
LOGDRAGSERVICE
(
"
GetNumDropItems
(
)
:
no
list
available
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
GetData
(
)
index
%
d
"
aItemIndex
)
;
if
(
!
aTransferable
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
mTargetWidget
)
{
LOGDRAGSERVICE
(
"
*
*
*
failed
:
GetData
called
without
a
valid
target
widget
!
\
n
"
)
;
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
aTransferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
failed
to
get
flavors
quit
.
"
)
;
return
rv
;
}
if
(
IsTargetContextList
(
)
)
{
LOGDRAGSERVICE
(
"
Process
as
a
list
.
.
.
"
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
LOGDRAGSERVICE
(
"
[
%
d
]
flavor
is
%
s
\
n
"
i
flavorStr
.
get
(
)
)
;
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
mSourceDataItems
aItemIndex
)
;
if
(
!
item
)
continue
;
nsCOMPtr
<
nsISupports
>
data
;
LOGDRAGSERVICE
(
"
trying
to
get
transfer
data
for
%
s
\
n
"
flavorStr
.
get
(
)
)
;
rv
=
item
-
>
GetTransferData
(
flavorStr
.
get
(
)
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
failed
.
\
n
"
)
;
continue
;
}
rv
=
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
data
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
fail
to
set
transfer
data
into
transferable
!
\
n
"
)
;
continue
;
}
LOGDRAGSERVICE
(
"
succeeded
\
n
"
)
;
return
NS_OK
;
}
LOGDRAGSERVICE
(
"
failed
to
match
flavors
\
n
"
)
;
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
GdkAtom
requestedFlavor
=
gdk_atom_intern
(
flavorStr
.
get
(
)
FALSE
)
;
if
(
!
requestedFlavor
)
{
continue
;
}
LOGDRAGSERVICE
(
"
we
'
re
getting
data
%
s
\
n
"
flavorStr
.
get
(
)
)
;
RefPtr
<
DragData
>
dragData
;
if
(
requestedFlavor
=
=
sTextMimeAtom
)
{
dragData
=
GetDragData
(
sTextPlainUTF8TypeAtom
)
;
}
if
(
!
dragData
)
{
dragData
=
GetDragData
(
requestedFlavor
)
;
}
if
(
!
dragData
&
&
requestedFlavor
=
=
sFileMimeAtom
)
{
dragData
=
GetDragData
(
sPortalFileAtom
)
;
if
(
!
dragData
)
{
dragData
=
GetDragData
(
sPortalFileTransferAtom
)
;
}
if
(
!
dragData
)
{
LOGDRAGSERVICE
(
"
file
not
found
proceed
with
conversion
%
s
=
>
%
s
flavor
\
n
"
gTextUriListType
kFileMime
)
;
dragData
=
GetDragData
(
sTextUriListTypeAtom
)
;
if
(
dragData
)
{
dragData
=
dragData
-
>
ConvertToFile
(
)
;
if
(
dragData
)
{
mCachedDragData
.
InsertOrUpdate
(
dragData
-
>
GetFlavor
(
)
dragData
)
;
}
}
}
}
if
(
!
dragData
&
&
requestedFlavor
=
=
sURLMimeAtom
)
{
LOGDRAGSERVICE
(
"
conversion
%
s
=
>
%
s
"
gTextUriListType
kURLMime
)
;
dragData
=
GetDragData
(
sTextUriListTypeAtom
)
;
if
(
dragData
)
{
dragData
=
dragData
-
>
ConvertToMozURL
(
)
;
mCachedDragData
.
InsertOrUpdate
(
dragData
-
>
GetFlavor
(
)
dragData
)
;
}
if
(
!
dragData
)
{
LOGDRAGSERVICE
(
"
conversion
%
s
=
>
%
s
"
gMozUrlType
kURLMime
)
;
dragData
=
GetDragData
(
sMozUrlTypeAtom
)
;
if
(
dragData
)
{
dragData
=
dragData
-
>
ConvertToMozURL
(
)
;
if
(
dragData
)
{
mCachedDragData
.
InsertOrUpdate
(
dragData
-
>
GetFlavor
(
)
dragData
)
;
}
}
}
}
if
(
dragData
&
&
dragData
-
>
Export
(
aTransferable
aItemIndex
)
)
{
if
(
dragData
-
>
IsImageFlavor
(
)
)
{
continue
;
}
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
IsDataFlavorSupported
(
%
p
)
%
s
"
mTargetDragContext
.
get
(
)
aDataFlavor
)
;
if
(
!
_retval
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
_retval
=
false
;
if
(
!
mTargetWidget
)
{
LOGDRAGSERVICE
(
"
*
*
*
warning
:
IsDataFlavorSupported
called
without
a
valid
target
"
"
widget
!
\
n
"
)
;
return
NS_OK
;
}
if
(
IsTargetContextList
(
)
)
{
LOGDRAGSERVICE
(
"
It
'
s
a
list
"
)
;
uint32_t
numDragItems
=
0
;
if
(
!
mSourceDataItems
)
{
LOGDRAGSERVICE
(
"
quit
"
)
;
return
NS_OK
;
}
mSourceDataItems
-
>
GetLength
(
&
numDragItems
)
;
LOGDRAGSERVICE
(
"
drag
items
%
d
"
numDragItems
)
;
for
(
uint32_t
itemIndex
=
0
;
itemIndex
<
numDragItems
;
+
+
itemIndex
)
{
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
itemIndex
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
LOGDRAGSERVICE
(
"
checking
%
s
against
%
s
\
n
"
flavors
[
i
]
.
get
(
)
aDataFlavor
)
;
if
(
flavors
[
i
]
.
Equals
(
aDataFlavor
)
)
{
LOGDRAGSERVICE
(
"
found
.
\
n
"
)
;
*
_retval
=
true
;
}
}
}
}
return
NS_OK
;
}
GList
*
tmp
=
nullptr
;
if
(
mTargetDragContext
)
{
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
}
for
(
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
atom
)
)
;
if
(
!
name
)
{
continue
;
}
if
(
strcmp
(
name
.
get
(
)
aDataFlavor
)
=
=
0
)
{
*
_retval
=
true
;
}
else
if
(
strcmp
(
name
.
get
(
)
gTextUriListType
)
=
=
0
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
|
|
strcmp
(
aDataFlavor
kFileMime
)
=
=
0
)
)
{
*
_retval
=
true
;
}
else
if
(
strcmp
(
name
.
get
(
)
gMozUrlType
)
=
=
0
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
)
)
{
*
_retval
=
true
;
}
else
if
(
(
strcmp
(
name
.
get
(
)
gPortalFile
)
=
=
0
|
|
strcmp
(
name
.
get
(
)
gPortalFileTransfer
)
=
=
0
)
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
|
|
strcmp
(
aDataFlavor
kFileMime
)
=
=
0
)
)
{
*
_retval
=
true
;
}
if
(
*
_retval
)
{
LOGDRAGSERVICE
(
"
supported
with
converting
%
s
=
>
%
s
"
name
.
get
(
)
aDataFlavor
)
;
}
}
if
(
!
*
_retval
)
{
LOGDRAGSERVICE
(
"
%
s
is
not
supported
"
aDataFlavor
)
;
}
return
NS_OK
;
}
void
nsDragService
:
:
ReplyToDragMotion
(
GdkDragContext
*
aDragContext
guint
aTime
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
ReplyToDragMotion
(
%
p
)
can
drop
%
d
"
aDragContext
mCanDrop
)
;
GdkDragAction
action
=
(
GdkDragAction
)
0
;
if
(
mCanDrop
)
{
switch
(
mDragAction
)
{
case
DRAGDROP_ACTION_COPY
:
LOGDRAGSERVICE
(
"
set
explicit
action
copy
"
)
;
action
=
GDK_ACTION_COPY
;
break
;
case
DRAGDROP_ACTION_LINK
:
LOGDRAGSERVICE
(
"
set
explicit
action
link
"
)
;
action
=
GDK_ACTION_LINK
;
break
;
case
DRAGDROP_ACTION_NONE
:
LOGDRAGSERVICE
(
"
set
explicit
action
none
"
)
;
action
=
(
GdkDragAction
)
0
;
break
;
default
:
LOGDRAGSERVICE
(
"
set
explicit
action
move
"
)
;
action
=
GDK_ACTION_MOVE
;
break
;
}
}
else
{
LOGDRAGSERVICE
(
"
mCanDrop
is
false
disable
drop
"
)
;
}
if
(
widget
:
:
GdkIsWaylandDisplay
(
)
&
&
action
=
=
GDK_ACTION_COPY
)
{
LOGDRAGSERVICE
(
"
Wayland
:
switch
copy
to
move
"
)
;
action
=
GDK_ACTION_MOVE
;
}
LOGDRAGSERVICE
(
"
gdk_drag_status
(
)
action
%
d
"
action
)
;
gdk_drag_status
(
aDragContext
action
aTime
)
;
}
void
nsDragService
:
:
SetCachedDragContext
(
GdkDragContext
*
aDragContext
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SetCachedDragContext
(
)
:
[
drag
%
p
/
cached
%
p
]
"
aDragContext
(
void
*
)
mCachedDragContext
)
;
uintptr_t
recentDragContext
=
reinterpret_cast
<
uintptr_t
>
(
aDragContext
)
;
if
(
recentDragContext
&
&
recentDragContext
!
=
mCachedDragContext
)
{
LOGDRAGSERVICE
(
"
cache
clear
new
context
%
p
"
(
void
*
)
recentDragContext
)
;
mCachedDragContext
=
recentDragContext
;
mCachedDragData
.
Clear
(
)
;
mCachedDragFlavors
.
Clear
(
)
;
}
}
bool
nsDragService
:
:
IsTargetContextList
(
void
)
{
bool
retval
=
false
;
if
(
mTargetDragContext
&
&
gtk_drag_get_source_widget
(
mTargetDragContext
)
=
=
nullptr
)
{
return
retval
;
}
GList
*
tmp
=
nullptr
;
if
(
mTargetDragContext
)
{
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
}
for
(
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
GUniquePtr
<
gchar
>
name
(
gdk_atom_name
(
atom
)
)
;
if
(
name
&
&
!
strcmp
(
name
.
get
(
)
gMimeListType
)
)
{
return
true
;
}
}
return
retval
;
}
bool
nsDragService
:
:
IsDragFlavorAvailable
(
GdkAtom
aRequestedFlavor
)
{
if
(
mCachedDragFlavors
.
IsEmpty
(
)
)
{
for
(
GList
*
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
tmp
;
tmp
=
tmp
-
>
next
)
{
mCachedDragFlavors
.
AppendElement
(
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
)
;
LOGDRAGSERVICE
(
"
drag
context
available
flavor
%
s
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
)
)
.
get
(
)
)
;
}
}
return
mCachedDragFlavors
.
Contains
(
aRequestedFlavor
)
;
}
RefPtr
<
DragData
>
nsDragService
:
:
GetDragData
(
GdkAtom
aRequestedFlavor
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
GetDragData
(
%
p
)
requested
'
%
s
'
\
n
"
mTargetDragContext
.
get
(
)
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
aRequestedFlavor
)
)
.
get
(
)
)
;
if
(
!
IsDragFlavorAvailable
(
aRequestedFlavor
)
)
{
LOGDRAGSERVICE
(
"
%
s
is
missing
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
aRequestedFlavor
)
)
.
get
(
)
)
;
return
nullptr
;
}
if
(
!
mTargetDragContext
)
{
LOGDRAGSERVICE
(
"
failed
missing
mTargetDragContext
"
)
;
return
nullptr
;
}
RefPtr
<
DragData
>
data
=
mCachedDragData
.
Get
(
GDK_ATOM_TO_POINTER
(
aRequestedFlavor
)
)
;
if
(
data
)
{
LOGDRAGSERVICE
(
"
%
s
found
in
cache
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
aRequestedFlavor
)
)
.
get
(
)
)
;
return
data
;
}
mWaitingForDragDataRequests
+
+
;
gtk_drag_get_data
(
mTargetWidget
mTargetDragContext
aRequestedFlavor
mTargetTime
)
;
LOGDRAGSERVICE
(
"
about
to
start
inner
iteration
mWaitingForDragDataRequests
%
d
"
mWaitingForDragDataRequests
)
;
gtk_main_iteration
(
)
;
PRTime
entryTime
=
PR_Now
(
)
;
while
(
mWaitingForDragDataRequests
&
&
mDoingDrag
)
{
LOGDRAGSERVICE
(
"
doing
iteration
mWaitingForDragDataRequests
%
d
.
.
.
"
mWaitingForDragDataRequests
)
;
PR_Sleep
(
PR_MillisecondsToInterval
(
10
)
)
;
if
(
PR_Now
(
)
-
entryTime
>
NS_DND_TIMEOUT
)
{
LOGDRAGSERVICE
(
"
failed
to
get
D
&
D
data
in
time
!
\
n
"
)
;
break
;
}
gtk_main_iteration
(
)
;
}
if
(
mWaitingForDragDataRequests
)
{
LOGDRAGSERVICE
(
"
failed
to
get
all
data
mWaitingForDragDataRequests
%
d
"
mWaitingForDragDataRequests
)
;
}
data
=
mCachedDragData
.
Get
(
GDK_ATOM_TO_POINTER
(
aRequestedFlavor
)
)
;
if
(
data
)
{
LOGDRAGSERVICE
(
"
%
s
received
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
aRequestedFlavor
)
)
.
get
(
)
)
;
return
data
;
}
LOGDRAGSERVICE
(
"
%
s
failed
to
get
from
system
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
aRequestedFlavor
)
)
.
get
(
)
)
;
return
nullptr
;
}
void
nsDragService
:
:
TargetDataReceived
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aX
gint
aY
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
)
{
MOZ_ASSERT
(
mWaitingForDragDataRequests
)
;
mWaitingForDragDataRequests
-
-
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
LOGDRAGSERVICE
(
"
nsDragService
:
:
TargetDataReceived
(
%
p
)
MIME
%
s
"
"
mWaitingForDragDataRequests
%
d
"
aContext
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
target
)
)
.
get
(
)
mWaitingForDragDataRequests
)
;
auto
cacheClear
=
MakeScopeExit
(
[
&
]
{
LOGDRAGSERVICE
(
"
failed
to
get
data
MIME
%
s
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
target
)
)
.
get
(
)
)
;
mCachedDragData
.
Remove
(
target
)
;
}
)
;
RefPtr
<
DragData
>
dragData
;
if
(
gtk_targets_include_uri
(
&
target
1
)
)
{
if
(
target
=
=
sPortalFileAtom
|
|
target
=
=
sPortalFileTransferAtom
)
{
const
guchar
*
data
=
gtk_selection_data_get_data
(
aSelectionData
)
;
if
(
!
data
|
|
data
[
0
]
=
=
'
\
0
'
)
{
LOGDRAGSERVICE
(
"
TargetDataReceived
(
)
failed
"
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
sourceURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
sourceURI
)
(
const
gchar
*
)
data
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
TargetDataReceived
(
)
:
got
valid
uri
for
MIME
%
s
-
this
is
bug
"
"
in
GTK
-
expected
numeric
value
for
portal
got
%
s
\
n
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
target
)
)
.
get
(
)
data
)
;
return
;
}
}
dragData
=
new
DragData
(
target
gtk_selection_data_get_uris
(
aSelectionData
)
)
;
LOGDRAGSERVICE
(
"
TargetDataReceived
(
)
:
URI
data
MIME
%
s
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
target
)
)
.
get
(
)
)
;
}
else
{
const
guchar
*
data
=
gtk_selection_data_get_data
(
aSelectionData
)
;
gint
len
=
gtk_selection_data_get_length
(
aSelectionData
)
;
if
(
len
<
0
&
&
!
data
)
{
LOGDRAGSERVICE
(
"
TargetDataReceived
(
)
failed
"
)
;
return
;
}
dragData
=
new
DragData
(
target
data
len
)
;
LOGDRAGSERVICE
(
"
TargetDataReceived
(
)
:
plain
data
MIME
%
s
len
=
%
d
"
GUniquePtr
<
gchar
>
(
gdk_atom_name
(
target
)
)
.
get
(
)
len
)
;
}
#
if
MOZ_LOGGING
dragData
-
>
Print
(
)
;
#
endif
cacheClear
.
release
(
)
;
mCachedDragData
.
InsertOrUpdate
(
target
dragData
)
;
}
static
void
TargetArrayAddTarget
(
nsTArray
<
GtkTargetEntry
*
>
&
aTargetArray
const
char
*
aTarget
)
{
GtkTargetEntry
*
target
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
target
-
>
target
=
g_strdup
(
aTarget
)
;
target
-
>
flags
=
0
;
aTargetArray
.
AppendElement
(
target
)
;
LOGDRAGSERVICESTATIC
(
"
adding
target
%
s
\
n
"
aTarget
)
;
}
static
bool
CanExportAsURLTarget
(
const
char16_t
*
aURLData
uint32_t
aURLLen
)
{
for
(
const
nsLiteralString
&
disallowed
:
kDisallowedExportedSchemes
)
{
auto
len
=
disallowed
.
AsString
(
)
.
Length
(
)
;
if
(
len
<
aURLLen
)
{
if
(
!
memcmp
(
disallowed
.
get
(
)
aURLData
len
*
2
)
)
{
LOGDRAGSERVICESTATIC
(
"
rejected
URL
scheme
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
disallowed
)
.
get
(
)
)
;
return
false
;
}
}
}
return
true
;
}
GtkTargetList
*
nsDragService
:
:
GetSourceList
(
void
)
{
if
(
!
mSourceDataItems
)
{
return
nullptr
;
}
nsTArray
<
GtkTargetEntry
*
>
targetArray
;
GtkTargetEntry
*
targets
;
GtkTargetList
*
targetList
=
0
;
uint32_t
targetCount
=
0
;
unsigned
int
numDragItems
=
0
;
mSourceDataItems
-
>
GetLength
(
&
numDragItems
)
;
LOGDRAGSERVICE
(
"
numDragItems
=
%
d
"
numDragItems
)
;
if
(
numDragItems
>
1
)
{
TargetArrayAddTarget
(
targetArray
gMimeListType
)
;
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
if
(
flavors
[
i
]
.
EqualsLiteral
(
kURLMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextUriListType
)
;
break
;
}
}
}
}
else
if
(
numDragItems
=
=
1
)
{
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
TargetArrayAddTarget
(
targetArray
flavorStr
.
get
(
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kFileMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextUriListType
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kTextMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextPlainUTF8Type
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
nsCOMPtr
<
nsISupports
>
data
;
if
(
NS_SUCCEEDED
(
currItem
-
>
GetTransferData
(
flavorStr
.
get
(
)
getter_AddRefs
(
data
)
)
)
)
{
void
*
tmpData
=
nullptr
;
uint32_t
tmpDataLen
=
0
;
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
nsDependentCString
(
flavorStr
.
get
(
)
)
data
&
tmpData
&
tmpDataLen
)
;
if
(
tmpData
)
{
if
(
CanExportAsURLTarget
(
reinterpret_cast
<
char16_t
*
>
(
tmpData
)
tmpDataLen
/
2
)
)
{
TargetArrayAddTarget
(
targetArray
gMozUrlType
)
;
}
free
(
tmpData
)
;
}
}
}
else
if
(
flavorStr
.
EqualsLiteral
(
kFilePromiseURLMime
)
)
{
TargetArrayAddTarget
(
targetArray
gTextUriListType
)
;
}
else
if
(
widget
:
:
GdkIsX11Display
(
)
&
&
!
widget
:
:
IsXWaylandProtocol
(
)
&
&
flavorStr
.
EqualsLiteral
(
kFilePromiseMime
)
)
{
TargetArrayAddTarget
(
targetArray
gXdndDirectSaveType
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kNativeImageMime
)
)
{
TargetArrayAddTarget
(
targetArray
kPNGImageMime
)
;
TargetArrayAddTarget
(
targetArray
kJPEGImageMime
)
;
TargetArrayAddTarget
(
targetArray
kJPGImageMime
)
;
TargetArrayAddTarget
(
targetArray
kGIFImageMime
)
;
}
}
}
}
targetCount
=
targetArray
.
Length
(
)
;
if
(
targetCount
)
{
targets
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
*
targetCount
)
;
uint32_t
targetIndex
;
for
(
targetIndex
=
0
;
targetIndex
<
targetCount
;
+
+
targetIndex
)
{
GtkTargetEntry
*
disEntry
=
targetArray
.
ElementAt
(
targetIndex
)
;
targets
[
targetIndex
]
.
target
=
disEntry
-
>
target
;
targets
[
targetIndex
]
.
flags
=
disEntry
-
>
flags
;
targets
[
targetIndex
]
.
info
=
0
;
}
targetList
=
gtk_target_list_new
(
targets
targetCount
)
;
for
(
uint32_t
cleanIndex
=
0
;
cleanIndex
<
targetCount
;
+
+
cleanIndex
)
{
GtkTargetEntry
*
thisTarget
=
targetArray
.
ElementAt
(
cleanIndex
)
;
g_free
(
thisTarget
-
>
target
)
;
g_free
(
thisTarget
)
;
}
g_free
(
targets
)
;
}
else
{
targetList
=
gtk_target_list_new
(
nullptr
0
)
;
}
return
targetList
;
}
void
nsDragService
:
:
SourceEndDragSession
(
GdkDragContext
*
aContext
gint
aResult
)
{
LOGDRAGSERVICE
(
"
SourceEndDragSession
(
%
p
)
result
%
s
\
n
"
aContext
kGtkDragResults
[
aResult
]
)
;
mSourceDataItems
=
nullptr
;
GdkAtom
property
=
sXdndDirectSaveTypeAtom
;
gdk_property_delete
(
gdk_drag_context_get_source_window
(
aContext
)
property
)
;
if
(
!
mDoingDrag
|
|
mScheduledTask
=
=
eDragTaskSourceEnd
)
return
;
if
(
mEndDragPoint
.
x
<
0
)
{
gint
x
y
;
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
GdkScreen
*
screen
=
gdk_display_get_default_screen
(
display
)
;
GtkWindow
*
window
=
GetGtkWindow
(
mSourceDocument
)
;
GdkWindow
*
gdkWindow
=
window
?
gtk_widget_get_window
(
GTK_WIDGET
(
window
)
)
:
gdk_screen_get_root_window
(
screen
)
;
if
(
!
gdkWindow
)
{
return
;
}
gdk_window_get_device_position
(
gdkWindow
gdk_drag_context_get_device
(
aContext
)
&
x
&
y
nullptr
)
;
gint
scale
=
gdk_window_get_scale_factor
(
gdkWindow
)
;
SetDragEndPoint
(
LayoutDeviceIntPoint
(
x
*
scale
y
*
scale
)
)
;
LOGDRAGSERVICE
(
"
guess
drag
end
point
%
d
%
d
\
n
"
x
*
scale
y
*
scale
)
;
}
uint32_t
dropEffect
;
if
(
aResult
=
=
GTK_DRAG_RESULT_SUCCESS
)
{
LOGDRAGSERVICE
(
"
drop
is
accepted
"
)
;
GdkDragAction
action
=
gdk_drag_context_get_dest_window
(
aContext
)
?
gdk_drag_context_get_actions
(
aContext
)
:
(
GdkDragAction
)
0
;
if
(
!
action
)
{
LOGDRAGSERVICE
(
"
drop
action
is
none
"
)
;
dropEffect
=
DRAGDROP_ACTION_NONE
;
}
else
if
(
action
&
GDK_ACTION_COPY
)
{
LOGDRAGSERVICE
(
"
drop
action
is
copy
"
)
;
dropEffect
=
DRAGDROP_ACTION_COPY
;
}
else
if
(
action
&
GDK_ACTION_LINK
)
{
LOGDRAGSERVICE
(
"
drop
action
is
link
"
)
;
dropEffect
=
DRAGDROP_ACTION_LINK
;
}
else
if
(
action
&
GDK_ACTION_MOVE
)
{
LOGDRAGSERVICE
(
"
drop
action
is
move
"
)
;
dropEffect
=
DRAGDROP_ACTION_MOVE
;
}
else
{
LOGDRAGSERVICE
(
"
drop
action
is
copy
"
)
;
dropEffect
=
DRAGDROP_ACTION_COPY
;
}
}
else
{
LOGDRAGSERVICE
(
"
drop
action
is
none
"
)
;
dropEffect
=
DRAGDROP_ACTION_NONE
;
if
(
aResult
!
=
GTK_DRAG_RESULT_NO_TARGET
)
{
LOGDRAGSERVICE
(
"
drop
is
user
chancelled
\
n
"
)
;
mUserCancelled
=
true
;
}
}
if
(
mDataTransfer
)
{
mDataTransfer
-
>
SetDropEffectInt
(
dropEffect
)
;
}
Schedule
(
eDragTaskSourceEnd
nullptr
nullptr
LayoutDeviceIntPoint
(
)
0
)
;
}
static
nsresult
GetDownloadDetails
(
nsITransferable
*
aTransferable
nsIURI
*
*
aSourceURI
nsAString
&
aFilename
)
{
*
aSourceURI
=
nullptr
;
MOZ_ASSERT
(
aTransferable
!
=
nullptr
"
aTransferable
must
not
be
null
"
)
;
nsCOMPtr
<
nsISupports
>
urlPrimitive
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseURLMime
getter_AddRefs
(
urlPrimitive
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupportsString
>
srcUrlPrimitive
=
do_QueryInterface
(
urlPrimitive
)
;
if
(
!
srcUrlPrimitive
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
srcUri
;
srcUrlPrimitive
-
>
GetData
(
srcUri
)
;
if
(
srcUri
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
sourceURI
;
NS_NewURI
(
getter_AddRefs
(
sourceURI
)
srcUri
)
;
nsAutoString
srcFileName
;
nsCOMPtr
<
nsISupports
>
fileNamePrimitive
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
fileNamePrimitive
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupportsString
>
srcFileNamePrimitive
=
do_QueryInterface
(
fileNamePrimitive
)
;
if
(
srcFileNamePrimitive
)
{
srcFileNamePrimitive
-
>
GetData
(
srcFileName
)
;
}
else
{
nsCOMPtr
<
nsIURL
>
sourceURL
=
do_QueryInterface
(
sourceURI
)
;
if
(
!
sourceURL
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
urlFileName
;
sourceURL
-
>
GetFileName
(
urlFileName
)
;
NS_UnescapeURL
(
urlFileName
)
;
CopyUTF8toUTF16
(
urlFileName
srcFileName
)
;
}
if
(
srcFileName
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
sourceURI
.
swap
(
*
aSourceURI
)
;
aFilename
=
srcFileName
;
return
NS_OK
;
}
nsresult
nsDragService
:
:
CreateTempFile
(
nsITransferable
*
aItem
nsACString
&
aURI
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
CreateTempFile
(
)
"
)
;
nsCOMPtr
<
nsIFile
>
tmpDir
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_OS_TEMP_DIR
getter_AddRefs
(
tmpDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
get
temp
directory
\
n
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIInputStream
>
inputStream
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsAutoString
wideFileName
;
nsCOMPtr
<
nsIURI
>
sourceURI
;
rv
=
GetDownloadDetails
(
aItem
getter_AddRefs
(
sourceURI
)
wideFileName
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
extract
file
name
and
source
uri
from
download
url
"
)
;
return
rv
;
}
nsAutoCString
fileName
;
CopyUTF16toUTF8
(
wideFileName
fileName
)
;
auto
fileLen
=
fileName
.
Length
(
)
;
for
(
const
auto
&
url
:
mTempFileUrls
)
{
auto
URLLen
=
url
.
Length
(
)
;
if
(
URLLen
>
fileLen
&
&
fileName
.
Equals
(
nsDependentCString
(
url
URLLen
-
fileLen
)
)
)
{
aURI
=
url
;
LOGDRAGSERVICE
(
"
recycle
file
%
s
"
PromiseFlatCString
(
aURI
)
.
get
(
)
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aItem
-
>
GetDataPrincipal
(
)
;
nsContentPolicyType
contentPolicyType
=
aItem
-
>
GetContentPolicyType
(
)
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
aItem
-
>
GetCookieJarSettings
(
)
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
sourceURI
principal
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
contentPolicyType
cookieJarSettings
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
create
new
channel
for
source
uri
"
)
;
return
rv
;
}
rv
=
channel
-
>
Open
(
getter_AddRefs
(
inputStream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
open
channel
for
source
uri
"
)
;
return
rv
;
}
tmpDir
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
"
dnd_file
"
)
)
;
rv
=
tmpDir
-
>
CreateUnique
(
nsIFile
:
:
DIRECTORY_TYPE
0700
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
create
tmp
dir
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIFile
>
tempFile
;
tmpDir
-
>
Clone
(
getter_AddRefs
(
tempFile
)
)
;
mTemporaryFiles
.
AppendObject
(
tempFile
)
;
if
(
mTempFileTimerID
)
{
g_source_remove
(
mTempFileTimerID
)
;
mTempFileTimerID
=
0
;
}
tmpDir
-
>
Append
(
wideFileName
)
;
nsCOMPtr
<
nsIOutputStream
>
outputStream
;
rv
=
NS_NewLocalFileOutputStream
(
getter_AddRefs
(
outputStream
)
tmpDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
open
output
stream
for
temporary
file
"
)
;
return
rv
;
}
char
buffer
[
8192
]
;
uint32_t
readCount
=
0
;
uint32_t
writeCount
=
0
;
while
(
1
)
{
rv
=
inputStream
-
>
Read
(
buffer
sizeof
(
buffer
)
&
readCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
read
data
from
source
uri
"
)
;
return
rv
;
}
if
(
readCount
=
=
0
)
break
;
rv
=
outputStream
-
>
Write
(
buffer
readCount
&
writeCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
write
data
to
temporary
file
"
)
;
return
rv
;
}
}
inputStream
-
>
Close
(
)
;
rv
=
outputStream
-
>
Close
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
write
data
to
temporary
file
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewFileURI
(
getter_AddRefs
(
uri
)
tmpDir
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
get
file
URI
"
)
;
return
rv
;
}
nsCOMPtr
<
nsIURL
>
fileURL
(
do_QueryInterface
(
uri
)
)
;
if
(
!
fileURL
)
{
LOGDRAGSERVICE
(
"
Failed
to
query
file
interface
"
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
fileURL
-
>
GetSpec
(
aURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
Failed
to
get
filepath
"
)
;
return
rv
;
}
mTempFileUrls
.
AppendElement
(
)
-
>
Assign
(
aURI
)
;
LOGDRAGSERVICE
(
"
storing
tmp
file
as
%
s
"
PromiseFlatCString
(
aURI
)
.
get
(
)
)
;
return
NS_OK
;
}
bool
nsDragService
:
:
SourceDataAppendURLFileItem
(
nsACString
&
aURI
nsITransferable
*
aItem
)
{
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
aItem
-
>
GetTransferData
(
kFileMime
getter_AddRefs
(
data
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
data
)
)
{
nsCOMPtr
<
nsIURI
>
fileURI
;
NS_NewFileURI
(
getter_AddRefs
(
fileURI
)
file
)
;
if
(
fileURI
)
{
fileURI
-
>
GetSpec
(
aURI
)
;
return
true
;
}
}
return
false
;
}
bool
nsDragService
:
:
SourceDataAppendURLItem
(
nsITransferable
*
aItem
bool
aExternalDrop
nsACString
&
aURI
)
{
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
aItem
-
>
GetTransferData
(
kURLMime
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
SourceDataAppendURLFileItem
(
aURI
aItem
)
;
}
nsCOMPtr
<
nsISupportsString
>
string
=
do_QueryInterface
(
data
)
;
if
(
!
string
)
{
return
false
;
}
nsAutoString
text
;
string
-
>
GetData
(
text
)
;
if
(
!
aExternalDrop
|
|
CanExportAsURLTarget
(
text
.
get
(
)
text
.
Length
(
)
)
)
{
AppendUTF16toUTF8
(
text
aURI
)
;
return
true
;
}
if
(
SourceDataAppendURLFileItem
(
aURI
aItem
)
)
{
return
true
;
}
nsCOMPtr
<
nsISupports
>
promiseData
;
rv
=
aItem
-
>
GetTransferData
(
kFilePromiseURLMime
getter_AddRefs
(
promiseData
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
NS_SUCCEEDED
(
CreateTempFile
(
aItem
aURI
)
)
;
}
void
nsDragService
:
:
SourceDataGetUriList
(
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
uint32_t
aDragItems
)
{
const
bool
isExternalDrop
=
widget
:
:
GdkIsX11Display
(
)
?
!
nsWindow
:
:
GetWindow
(
gdk_drag_context_get_dest_window
(
aContext
)
)
:
!
gdk_drag_context_get_dest_window
(
aContext
)
;
LOGDRAGSERVICE
(
"
nsDragService
:
:
SourceDataGetUriLists
(
)
len
%
d
external
%
d
"
aDragItems
isExternalDrop
)
;
AutoSuspendNativeEvents
suspend
;
nsAutoCString
uriList
;
for
(
uint32_t
i
=
0
;
i
<
aDragItems
;
i
+
+
)
{
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
mSourceDataItems
i
)
;
if
(
!
item
)
{
continue
;
}
nsAutoCString
uri
;
if
(
!
SourceDataAppendURLItem
(
item
isExternalDrop
uri
)
)
{
continue
;
}
int32_t
separatorPos
=
uri
.
FindChar
(
u
'
\
n
'
)
;
if
(
separatorPos
>
=
0
)
{
uri
.
Truncate
(
separatorPos
)
;
}
uriList
.
Append
(
uri
)
;
uriList
.
AppendLiteral
(
"
\
r
\
n
"
)
;
}
LOGDRAGSERVICE
(
"
URI
list
\
n
%
s
"
uriList
.
get
(
)
)
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
uriList
.
get
(
)
uriList
.
Length
(
)
)
;
}
void
nsDragService
:
:
SourceDataGetImage
(
nsITransferable
*
aItem
GtkSelectionData
*
aSelectionData
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SourceDataGetImage
(
)
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
data
;
rv
=
aItem
-
>
GetTransferData
(
kNativeImageMime
getter_AddRefs
(
data
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
LOGDRAGSERVICE
(
"
posting
image
\
n
"
)
;
nsCOMPtr
<
imgIContainer
>
image
=
do_QueryInterface
(
data
)
;
if
(
!
image
)
{
LOGDRAGSERVICE
(
"
do_QueryInterface
failed
\
n
"
)
;
return
;
}
RefPtr
<
GdkPixbuf
>
pixbuf
=
nsImageToPixbuf
:
:
ImageToPixbuf
(
image
)
;
if
(
!
pixbuf
)
{
LOGDRAGSERVICE
(
"
ImageToPixbuf
failed
\
n
"
)
;
return
;
}
gtk_selection_data_set_pixbuf
(
aSelectionData
pixbuf
)
;
LOGDRAGSERVICE
(
"
image
data
set
\
n
"
)
;
return
;
}
void
nsDragService
:
:
SourceDataGetXDND
(
nsITransferable
*
aItem
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SourceDataGetXDND
"
)
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
E
"
1
)
;
GdkWindow
*
srcWindow
=
gdk_drag_context_get_source_window
(
aContext
)
;
if
(
!
srcWindow
)
{
LOGDRAGSERVICE
(
"
failed
to
get
source
GdkWindow
!
"
)
;
return
;
}
nsAutoCString
data
;
{
GUniquePtr
<
guchar
>
gdata
;
gint
length
=
0
;
if
(
!
gdk_property_get
(
srcWindow
sXdndDirectSaveTypeAtom
sTextMimeAtom
0
INT32_MAX
FALSE
nullptr
nullptr
&
length
getter_Transfers
(
gdata
)
)
)
{
LOGDRAGSERVICE
(
"
failed
to
get
gXdndDirectSaveType
GdkWindow
property
.
"
)
;
return
;
}
data
.
Assign
(
nsDependentCSubstring
(
(
const
char
*
)
gdata
.
get
(
)
length
)
)
;
}
GUniquePtr
<
char
>
hostname
;
GUniquePtr
<
char
>
fullpath
(
g_filename_from_uri
(
data
.
get
(
)
getter_Transfers
(
hostname
)
nullptr
)
)
;
if
(
!
fullpath
)
{
LOGDRAGSERVICE
(
"
failed
to
get
file
from
uri
.
"
)
;
return
;
}
if
(
hostname
)
{
nsCOMPtr
<
nsIPropertyBag2
>
infoService
=
do_GetService
(
NS_SYSTEMINFO_CONTRACTID
)
;
if
(
!
infoService
)
{
return
;
}
nsAutoCString
host
;
if
(
NS_SUCCEEDED
(
infoService
-
>
GetPropertyAsACString
(
u
"
host
"
_ns
host
)
)
)
{
if
(
!
host
.
Equals
(
hostname
.
get
(
)
)
)
{
LOGDRAGSERVICE
(
"
ignored
drag
because
of
different
host
.
"
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
F
"
1
)
;
return
;
}
}
}
LOGDRAGSERVICE
(
"
XdndDirectSave
filepath
is
%
s
"
fullpath
.
get
(
)
)
;
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_FAILED
(
NS_NewNativeLocalFile
(
nsDependentCString
(
fullpath
.
get
(
)
)
false
getter_AddRefs
(
file
)
)
)
)
{
LOGDRAGSERVICE
(
"
failed
to
get
local
file
"
)
;
return
;
}
nsCOMPtr
<
nsIFile
>
directory
;
file
-
>
GetParent
(
getter_AddRefs
(
directory
)
)
;
aItem
-
>
SetTransferData
(
kFilePromiseDirectoryMime
directory
)
;
nsCOMPtr
<
nsISupportsString
>
filenamePrimitive
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
)
;
if
(
!
filenamePrimitive
)
{
return
;
}
nsAutoString
leafName
;
file
-
>
GetLeafName
(
leafName
)
;
filenamePrimitive
-
>
SetData
(
leafName
)
;
aItem
-
>
SetTransferData
(
kFilePromiseDestFilename
filenamePrimitive
)
;
nsCOMPtr
<
nsISupports
>
promiseData
;
nsresult
rv
=
aItem
-
>
GetTransferData
(
kFilePromiseMime
getter_AddRefs
(
promiseData
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
S
"
1
)
;
return
;
}
bool
nsDragService
:
:
SourceDataGetText
(
nsITransferable
*
aItem
const
nsACString
&
aMIMEType
bool
aNeedToDoConversionToPlainText
GtkSelectionData
*
aSelectionData
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SourceDataGetPlain
(
)
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
data
;
rv
=
aItem
-
>
GetTransferData
(
PromiseFlatCString
(
aMIMEType
)
.
get
(
)
getter_AddRefs
(
data
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
void
*
tmpData
=
nullptr
;
uint32_t
tmpDataLen
=
0
;
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
aMIMEType
data
&
tmpData
&
tmpDataLen
)
;
if
(
aNeedToDoConversionToPlainText
)
{
char
*
plainTextData
=
nullptr
;
char16_t
*
castedUnicode
=
reinterpret_cast
<
char16_t
*
>
(
tmpData
)
;
uint32_t
plainTextLen
=
0
;
UTF16ToNewUTF8
(
castedUnicode
tmpDataLen
/
2
&
plainTextData
&
plainTextLen
)
;
if
(
tmpData
)
{
free
(
tmpData
)
;
tmpData
=
plainTextData
;
tmpDataLen
=
plainTextLen
;
}
}
if
(
tmpData
)
{
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
tmpData
tmpDataLen
)
;
free
(
tmpData
)
;
}
return
true
;
}
void
nsDragService
:
:
SourceDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint32
aTime
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SourceDataGet
(
%
p
)
"
aContext
)
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
GUniquePtr
<
gchar
>
requestedTypeName
(
gdk_atom_name
(
target
)
)
;
if
(
!
requestedTypeName
)
{
LOGDRAGSERVICE
(
"
failed
to
get
atom
name
.
\
n
"
)
;
return
;
}
LOGDRAGSERVICE
(
"
Gtk
asks
us
for
%
s
data
type
\
n
"
requestedTypeName
.
get
(
)
)
;
if
(
!
mSourceDataItems
)
{
LOGDRAGSERVICE
(
"
Failed
to
get
our
data
items
\
n
"
)
;
return
;
}
uint32_t
dragItems
;
mSourceDataItems
-
>
GetLength
(
&
dragItems
)
;
LOGDRAGSERVICE
(
"
source
data
items
%
d
"
dragItems
)
;
nsDependentCString
mimeFlavor
(
requestedTypeName
.
get
(
)
)
;
if
(
mimeFlavor
.
EqualsLiteral
(
gTextUriListType
)
)
{
SourceDataGetUriList
(
aContext
aSelectionData
dragItems
)
;
return
;
}
#
ifdef
MOZ_LOGGING
if
(
dragItems
>
1
)
{
LOGDRAGSERVICE
(
"
There
are
%
d
data
items
but
we
'
re
asked
for
%
s
MIME
type
.
Only
"
"
first
data
element
can
be
transfered
!
"
dragItems
mimeFlavor
.
get
(
)
)
;
}
#
endif
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
!
item
)
{
LOGDRAGSERVICE
(
"
Failed
to
get
SourceDataItems
!
"
)
;
return
;
}
if
(
mimeFlavor
.
EqualsLiteral
(
kTextMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
gTextPlainUTF8Type
)
)
{
SourceDataGetText
(
item
nsDependentCString
(
kTextMime
)
true
aSelectionData
)
;
return
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gXdndDirectSaveType
)
)
{
SourceDataGetXDND
(
item
aContext
aSelectionData
)
;
return
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
kPNGImageMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
kJPGImageMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
kGIFImageMime
)
)
{
SourceDataGetImage
(
item
aSelectionData
)
;
return
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gMozUrlType
)
)
{
if
(
SourceDataGetText
(
item
nsDependentCString
(
kURLMime
)
true
aSelectionData
)
)
{
return
;
}
}
SourceDataGetText
(
item
mimeFlavor
false
aSelectionData
)
;
}
void
nsDragService
:
:
SourceBeginDrag
(
GdkDragContext
*
aContext
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
SourceBeginDrag
(
%
p
)
\
n
"
aContext
)
;
nsCOMPtr
<
nsITransferable
>
transferable
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
!
transferable
)
return
;
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
transferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
if
(
flavors
[
i
]
.
EqualsLiteral
(
kFilePromiseDestFilename
)
)
{
nsCOMPtr
<
nsISupports
>
data
;
rv
=
transferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOGDRAGSERVICE
(
"
transferable
doesn
'
t
contain
'
%
s
"
kFilePromiseDestFilename
)
;
return
;
}
nsCOMPtr
<
nsISupportsString
>
fileName
=
do_QueryInterface
(
data
)
;
if
(
!
fileName
)
{
LOGDRAGSERVICE
(
"
failed
to
get
file
name
"
)
;
return
;
}
nsAutoString
fileNameStr
;
fileName
-
>
GetData
(
fileNameStr
)
;
nsCString
fileNameCStr
;
CopyUTF16toUTF8
(
fileNameStr
fileNameCStr
)
;
gdk_property_change
(
gdk_drag_context_get_source_window
(
aContext
)
sXdndDirectSaveTypeAtom
sTextMimeAtom
8
GDK_PROP_MODE_REPLACE
(
const
guchar
*
)
fileNameCStr
.
get
(
)
fileNameCStr
.
Length
(
)
)
;
break
;
}
}
}
void
nsDragService
:
:
SetDragIcon
(
GdkDragContext
*
aContext
)
{
if
(
!
mHasImage
&
&
!
mSelection
)
return
;
LOGDRAGSERVICE
(
"
nsDragService
:
:
SetDragIcon
(
%
p
)
"
aContext
)
;
LayoutDeviceIntRect
dragRect
;
nsPresContext
*
pc
;
RefPtr
<
SourceSurface
>
surface
;
DrawDrag
(
mSourceNode
mRegion
mScreenPosition
&
dragRect
&
surface
&
pc
)
;
if
(
!
pc
)
{
LOGDRAGSERVICE
(
"
PresContext
is
missing
!
"
)
;
return
;
}
const
auto
screenPoint
=
LayoutDeviceIntPoint
:
:
Round
(
mScreenPosition
*
pc
-
>
CSSToDevPixelScale
(
)
)
;
int32_t
offsetX
=
screenPoint
.
x
-
dragRect
.
x
;
int32_t
offsetY
=
screenPoint
.
y
-
dragRect
.
y
;
bool
gtk_drag_set_icon_widget_is_working
=
gtk_check_version
(
3
19
4
)
!
=
nullptr
|
|
gtk_check_version
(
3
24
0
)
=
=
nullptr
;
if
(
mDragPopup
&
&
gtk_drag_set_icon_widget_is_working
)
{
GtkWidget
*
gtkWidget
=
nullptr
;
nsIFrame
*
frame
=
mDragPopup
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
frame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
gtkWidget
=
(
GtkWidget
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_SHELLWIDGET
)
;
if
(
gtkWidget
)
{
if
(
GtkWidget
*
parent
=
gtk_widget_get_parent
(
gtkWidget
)
)
{
gtk_container_remove
(
GTK_CONTAINER
(
parent
)
gtkWidget
)
;
}
LOGDRAGSERVICE
(
"
set
drag
popup
[
%
p
]
"
widget
.
get
(
)
)
;
OpenDragPopup
(
)
;
gtk_drag_set_icon_widget
(
aContext
gtkWidget
offsetX
offsetY
)
;
return
;
}
else
{
LOGDRAGSERVICE
(
"
NS_NATIVE_SHELLWIDGET
is
missing
!
"
)
;
}
}
else
{
LOGDRAGSERVICE
(
"
NearestWidget
is
missing
!
"
)
;
}
}
else
{
LOGDRAGSERVICE
(
"
PrimaryFrame
is
missing
!
"
)
;
}
}
if
(
surface
)
{
LOGDRAGSERVICE
(
"
We
have
a
surface
"
)
;
if
(
!
SetAlphaPixmap
(
surface
aContext
offsetX
offsetY
dragRect
)
)
{
RefPtr
<
GdkPixbuf
>
dragPixbuf
=
nsImageToPixbuf
:
:
SourceSurfaceToPixbuf
(
surface
dragRect
.
width
dragRect
.
height
)
;
if
(
dragPixbuf
)
{
LOGDRAGSERVICE
(
"
set
drag
pixbuf
"
)
;
gtk_drag_set_icon_pixbuf
(
aContext
dragPixbuf
offsetX
offsetY
)
;
}
else
{
LOGDRAGSERVICE
(
"
SourceSurfaceToPixbuf
failed
!
"
)
;
}
}
}
else
{
LOGDRAGSERVICE
(
"
Surface
is
missing
!
"
)
;
}
}
static
void
invisibleSourceDragBegin
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
{
LOGDRAGSERVICESTATIC
(
"
invisibleSourceDragBegin
(
%
p
)
"
aContext
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceBeginDrag
(
aContext
)
;
dragService
-
>
SetDragIcon
(
aContext
)
;
}
static
void
invisibleSourceDragDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
{
LOGDRAGSERVICESTATIC
(
"
invisibleSourceDragDataGet
(
%
p
)
"
aContext
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceDataGet
(
aWidget
aContext
aSelectionData
aTime
)
;
}
static
gboolean
invisibleSourceDragFailed
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aResult
gpointer
aData
)
{
#
ifdef
MOZ_WAYLAND
if
(
widget
:
:
GdkIsWaylandDisplay
(
)
&
&
aResult
=
=
GTK_DRAG_RESULT_ERROR
)
{
for
(
GList
*
tmp
=
gdk_drag_context_list_targets
(
aContext
)
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
if
(
atom
=
=
nsDragService
:
:
sTabDropTypeAtom
)
{
aResult
=
GTK_DRAG_RESULT_NO_TARGET
;
LOGDRAGSERVICESTATIC
(
"
invisibleSourceDragFailed
(
%
p
)
:
Wayland
tab
drop
"
aContext
)
;
break
;
}
}
}
#
endif
LOGDRAGSERVICESTATIC
(
"
invisibleSourceDragFailed
(
%
p
)
%
s
"
aContext
kGtkDragResults
[
aResult
]
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceEndDragSession
(
aContext
aResult
)
;
return
FALSE
;
}
static
void
invisibleSourceDragEnd
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
{
LOGDRAGSERVICESTATIC
(
"
invisibleSourceDragEnd
(
%
p
)
"
aContext
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceEndDragSession
(
aContext
GTK_DRAG_RESULT_SUCCESS
)
;
}
gboolean
nsDragService
:
:
ScheduleMotionEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
aDragContext
&
&
mScheduledTask
=
=
eDragTaskMotion
)
{
NS_WARNING
(
"
Drag
Motion
message
received
before
previous
reply
was
sent
"
)
;
}
return
Schedule
(
eDragTaskMotion
aWindow
aDragContext
aWindowPoint
aTime
)
;
}
void
nsDragService
:
:
ScheduleLeaveEvent
(
)
{
if
(
!
Schedule
(
eDragTaskLeave
nullptr
nullptr
LayoutDeviceIntPoint
(
)
0
)
)
{
NS_WARNING
(
"
Drag
leave
after
drop
"
)
;
}
}
gboolean
nsDragService
:
:
ScheduleDropEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
!
Schedule
(
eDragTaskDrop
aWindow
aDragContext
aWindowPoint
aTime
)
)
{
NS_WARNING
(
"
Additional
drag
drop
ignored
"
)
;
return
FALSE
;
}
SetDragEndPoint
(
aWindowPoint
)
;
return
TRUE
;
}
#
ifdef
MOZ_LOGGING
const
char
*
nsDragService
:
:
GetDragServiceTaskName
(
DragTask
aTask
)
{
static
const
char
*
taskNames
[
]
=
{
"
eDragTaskNone
"
"
eDragTaskMotion
"
"
eDragTaskLeave
"
"
eDragTaskDrop
"
"
eDragTaskSourceEnd
"
}
;
MOZ_ASSERT
(
size_t
(
aTask
)
<
ArrayLength
(
taskNames
)
)
;
return
taskNames
[
aTask
]
;
}
#
endif
gboolean
nsDragService
:
:
Schedule
(
DragTask
aTask
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
Schedule
(
%
p
)
task
%
s
window
%
p
\
n
"
aDragContext
GetDragServiceTaskName
(
aTask
)
aWindow
)
;
if
(
mScheduledTask
=
=
eDragTaskSourceEnd
|
|
(
mScheduledTask
=
=
eDragTaskDrop
&
&
aTask
!
=
eDragTaskSourceEnd
)
)
{
LOGDRAGSERVICE
(
"
task
does
not
fit
recent
task
%
s
quit
!
\
n
"
GetDragServiceTaskName
(
mScheduledTask
)
)
;
return
FALSE
;
}
mScheduledTask
=
aTask
;
mPendingWindow
=
aWindow
;
mPendingDragContext
=
aDragContext
;
mPendingWindowPoint
=
aWindowPoint
;
mPendingTime
=
aTime
;
if
(
!
mTaskSource
)
{
mTaskSource
=
g_timeout_add_full
(
G_PRIORITY_HIGH
0
TaskDispatchCallback
this
nullptr
)
;
}
if
(
widget
:
:
GdkIsWaylandDisplay
(
)
&
&
mScheduledTask
=
=
eDragTaskMotion
)
{
UpdateDragAction
(
aDragContext
)
;
ReplyToDragMotion
(
aDragContext
aTime
)
;
}
return
TRUE
;
}
gboolean
nsDragService
:
:
TaskDispatchCallback
(
gpointer
data
)
{
RefPtr
<
nsDragService
>
dragService
=
static_cast
<
nsDragService
*
>
(
data
)
;
AutoEventLoop
loop
(
dragService
)
;
return
dragService
-
>
RunScheduledTask
(
)
;
}
gboolean
nsDragService
:
:
RunScheduledTask
(
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
RunScheduledTask
(
)
task
%
s
mTargetWindow
%
p
"
"
mPendingWindow
%
p
\
n
"
GetDragServiceTaskName
(
mScheduledTask
)
mTargetWindow
.
get
(
)
mPendingWindow
.
get
(
)
)
;
if
(
mScheduledTaskIsRunning
)
{
LOGDRAGSERVICE
(
"
sheduled
task
is
already
running
quit
.
"
)
;
return
FALSE
;
}
AutoRestore
<
bool
>
guard
(
mScheduledTaskIsRunning
)
;
mScheduledTaskIsRunning
=
true
;
if
(
mTargetWindow
&
&
mTargetWindow
!
=
mPendingWindow
)
{
LOGDRAGSERVICE
(
"
dispatch
eDragExit
(
%
p
)
\
n
"
mTargetWindow
.
get
(
)
)
;
mTargetWindow
-
>
DispatchDragEvent
(
eDragExit
mTargetWindowPoint
0
)
;
if
(
!
mSourceNode
)
{
EndDragSession
(
false
GetCurrentModifiers
(
)
)
;
}
}
bool
positionHasChanged
=
mPendingWindow
!
=
mTargetWindow
|
|
mPendingWindowPoint
!
=
mTargetWindowPoint
;
DragTask
task
=
mScheduledTask
;
mScheduledTask
=
eDragTaskNone
;
mTargetWindow
=
std
:
:
move
(
mPendingWindow
)
;
mTargetWindowPoint
=
mPendingWindowPoint
;
if
(
task
=
=
eDragTaskLeave
|
|
task
=
=
eDragTaskSourceEnd
)
{
LOGDRAGSERVICE
(
"
quit
selected
task
%
s
\
n
"
GetDragServiceTaskName
(
task
)
)
;
if
(
task
=
=
eDragTaskSourceEnd
)
{
EndDragSession
(
true
GetCurrentModifiers
(
)
)
;
}
mTaskSource
=
0
;
mPendingDragContext
=
nullptr
;
return
FALSE
;
}
StartDragSession
(
)
;
mTargetWidget
=
mTargetWindow
?
mTargetWindow
-
>
GetGtkWidget
(
)
:
nullptr
;
LOGDRAGSERVICE
(
"
start
drag
session
mTargetWindow
%
p
mTargetWidget
%
p
\
n
"
mTargetWindow
.
get
(
)
mTargetWidget
.
get
(
)
)
;
LOGDRAGSERVICE
(
"
mPendingDragContext
%
p
=
>
mTargetDragContext
%
p
\
n
"
mPendingDragContext
.
get
(
)
mTargetDragContext
.
get
(
)
)
;
mTargetDragContext
=
std
:
:
move
(
mPendingDragContext
)
;
mTargetTime
=
mPendingTime
;
SetCachedDragContext
(
mTargetDragContext
)
;
if
(
task
=
=
eDragTaskMotion
|
|
positionHasChanged
)
{
LOGDRAGSERVICE
(
"
process
motion
event
\
n
"
)
;
UpdateDragAction
(
)
;
TakeDragEventDispatchedToChildProcess
(
)
;
DispatchMotionEvents
(
)
;
if
(
task
=
=
eDragTaskMotion
)
{
if
(
TakeDragEventDispatchedToChildProcess
(
)
)
{
mTargetDragContextForRemote
=
mTargetDragContext
;
}
else
{
ReplyToDragMotion
(
)
;
}
}
}
if
(
task
=
=
eDragTaskDrop
)
{
LOGDRAGSERVICE
(
"
process
drop
task
\
n
"
)
;
gboolean
success
=
DispatchDropEvent
(
)
;
if
(
mTargetDragContext
)
{
LOGDRAGSERVICE
(
"
drag
finished
\
n
"
)
;
gtk_drag_finish
(
mTargetDragContext
success
FALSE
mTargetTime
)
;
}
EndDragSession
(
true
GetCurrentModifiers
(
)
)
;
}
LOGDRAGSERVICE
(
"
clear
mTargetWindow
mTargetWidget
and
other
data
\
n
"
)
;
mTargetWidget
=
nullptr
;
mTargetDragContext
=
nullptr
;
if
(
mScheduledTask
!
=
eDragTaskNone
)
return
TRUE
;
LOGDRAGSERVICE
(
"
remove
task
source
\
n
"
)
;
mTaskSource
=
0
;
return
FALSE
;
}
void
nsDragService
:
:
UpdateDragAction
(
GdkDragContext
*
aDragContext
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
UpdateDragAction
(
%
p
)
"
aDragContext
)
;
int
action
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
GdkDragAction
gdkAction
=
GDK_ACTION_DEFAULT
;
if
(
aDragContext
)
{
gdkAction
=
gdk_drag_context_get_actions
(
aDragContext
)
;
LOGDRAGSERVICE
(
"
gdk_drag_context_get_actions
(
)
returns
0x
%
X
"
gdkAction
)
;
if
(
widget
:
:
GdkIsWaylandDisplay
(
)
)
{
GdkDragAction
gdkActionSelected
=
gdk_drag_context_get_selected_action
(
aDragContext
)
;
LOGDRAGSERVICE
(
"
gdk_drag_context_get_selected_action
(
)
returns
0x
%
X
"
gdkActionSelected
)
;
if
(
gdkActionSelected
)
{
gdkAction
=
gdkActionSelected
;
}
}
}
if
(
gdkAction
&
GDK_ACTION_DEFAULT
)
{
LOGDRAGSERVICE
(
"
set
default
move
"
)
;
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
}
if
(
gdkAction
&
GDK_ACTION_MOVE
)
{
LOGDRAGSERVICE
(
"
set
explicit
move
"
)
;
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
}
else
if
(
gdkAction
&
GDK_ACTION_LINK
)
{
LOGDRAGSERVICE
(
"
set
explicit
link
"
)
;
action
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
}
else
if
(
gdkAction
&
GDK_ACTION_COPY
)
{
LOGDRAGSERVICE
(
"
set
explicit
copy
"
)
;
action
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
}
SetDragAction
(
action
)
;
}
void
nsDragService
:
:
UpdateDragAction
(
)
{
UpdateDragAction
(
mTargetDragContext
)
;
}
NS_IMETHODIMP
nsDragService
:
:
UpdateDragEffect
(
)
{
LOGDRAGSERVICE
(
"
nsDragService
:
:
UpdateDragEffect
(
)
from
e10s
child
process
"
)
;
if
(
mTargetDragContextForRemote
)
{
ReplyToDragMotion
(
mTargetDragContextForRemote
mTargetTime
)
;
mTargetDragContextForRemote
=
nullptr
;
}
return
NS_OK
;
}
void
nsDragService
:
:
ReplyToDragMotion
(
)
{
if
(
mTargetDragContext
)
{
ReplyToDragMotion
(
mTargetDragContext
mTargetTime
)
;
}
}
void
nsDragService
:
:
DispatchMotionEvents
(
)
{
FireDragEventAtSource
(
eDrag
GetCurrentModifiers
(
)
)
;
if
(
mTargetWindow
)
{
mTargetWindow
-
>
DispatchDragEvent
(
eDragOver
mTargetWindowPoint
mTargetTime
)
;
}
}
gboolean
nsDragService
:
:
DispatchDropEvent
(
)
{
if
(
!
mTargetWindow
|
|
mTargetWindow
-
>
IsDestroyed
(
)
)
{
return
FALSE
;
}
EventMessage
msg
=
mCanDrop
?
eDrop
:
eDragExit
;
mTargetWindow
-
>
DispatchDragEvent
(
msg
mTargetWindowPoint
mTargetTime
)
;
return
mCanDrop
;
}
uint32_t
nsDragService
:
:
GetCurrentModifiers
(
)
{
return
mozilla
:
:
widget
:
:
KeymapWrapper
:
:
ComputeCurrentKeyModifiers
(
)
;
}
#
undef
LOGDRAGSERVICE
