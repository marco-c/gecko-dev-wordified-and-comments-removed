#
include
"
nsDragService
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsWindow
.
h
"
#
include
"
nsSystemInfo
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIFileURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
prtime
.
h
"
#
include
"
prthread
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
<
gdk
/
gdkx
.
h
>
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
GRefPtr
.
h
"
#
include
"
gfxXlibSurface
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsImageToPixbuf
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsGtkUtils
.
h
"
#
include
"
nsGtkKeyUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
ScreenHelperGTK
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
ifdef
MOZ_WAYLAND
#
include
"
nsClipboardWayland
.
h
"
#
include
"
gfxPlatformGtk
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
#
define
NS_SYSTEMINFO_CONTRACTID
"
mozilla
.
org
/
system
-
info
;
1
"
#
define
DRAG_IMAGE_ALPHA_LEVEL
0
.
5
enum
{
MOZ_GTK_DRAG_RESULT_SUCCESS
MOZ_GTK_DRAG_RESULT_NO_TARGET
MOZ_GTK_DRAG_RESULT_USER_CANCELLED
MOZ_GTK_DRAG_RESULT_TIMEOUT_EXPIRED
MOZ_GTK_DRAG_RESULT_GRAB_BROKEN
MOZ_GTK_DRAG_RESULT_ERROR
}
;
static
LazyLogModule
sDragLm
(
"
nsDragService
"
)
;
static
guint
sMotionEventTimerID
;
static
GdkEvent
*
sMotionEvent
;
static
GtkWidget
*
sGrabWidget
;
static
const
char
gMimeListType
[
]
=
"
application
/
x
-
moz
-
internal
-
item
-
list
"
;
static
const
char
gMozUrlType
[
]
=
"
_NETSCAPE_URL
"
;
static
const
char
gTextUriListType
[
]
=
"
text
/
uri
-
list
"
;
static
const
char
gTextPlainUTF8Type
[
]
=
"
text
/
plain
;
charset
=
utf
-
8
"
;
static
const
char
gXdndDirectSaveType
[
]
=
"
XdndDirectSave0
"
;
static
const
char
gTabDropType
[
]
=
"
application
/
x
-
moz
-
tabbrowser
-
tab
"
;
static
void
invisibleSourceDragBegin
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
;
static
void
invisibleSourceDragEnd
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
;
static
gboolean
invisibleSourceDragFailed
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aResult
gpointer
aData
)
;
static
void
invisibleSourceDragDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
;
nsDragService
:
:
nsDragService
(
)
:
mScheduledTask
(
eDragTaskNone
)
mTaskSource
(
0
)
#
ifdef
MOZ_WAYLAND
mPendingWaylandDragContext
(
nullptr
)
mTargetWaylandDragContext
(
nullptr
)
#
endif
{
nsCOMPtr
<
nsIObserverService
>
obsServ
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obsServ
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
mHiddenWidget
=
gtk_offscreen_window_new
(
)
;
gtk_widget_realize
(
mHiddenWidget
)
;
g_signal_connect
(
mHiddenWidget
"
drag_begin
"
G_CALLBACK
(
invisibleSourceDragBegin
)
this
)
;
g_signal_connect
(
mHiddenWidget
"
drag_data_get
"
G_CALLBACK
(
invisibleSourceDragDataGet
)
this
)
;
g_signal_connect
(
mHiddenWidget
"
drag_end
"
G_CALLBACK
(
invisibleSourceDragEnd
)
this
)
;
guint
dragFailedID
=
g_signal_lookup
(
"
drag
-
failed
"
G_TYPE_FROM_INSTANCE
(
mHiddenWidget
)
)
;
if
(
dragFailedID
)
{
g_signal_connect_closure_by_id
(
mHiddenWidget
dragFailedID
0
g_cclosure_new
(
G_CALLBACK
(
invisibleSourceDragFailed
)
this
nullptr
)
FALSE
)
;
}
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
nsDragService
"
)
)
;
mCanDrop
=
false
;
mTargetDragDataReceived
=
false
;
mTargetDragData
=
0
;
mTargetDragDataLen
=
0
;
}
nsDragService
:
:
~
nsDragService
(
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
~
nsDragService
"
)
)
;
if
(
mTaskSource
)
g_source_remove
(
mTaskSource
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsDragService
nsBaseDragService
nsIObserver
)
mozilla
:
:
StaticRefPtr
<
nsDragService
>
sDragServiceInstance
;
already_AddRefed
<
nsDragService
>
nsDragService
:
:
GetInstance
(
)
{
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
nullptr
;
}
if
(
!
sDragServiceInstance
)
{
sDragServiceInstance
=
new
nsDragService
(
)
;
ClearOnShutdown
(
&
sDragServiceInstance
)
;
}
RefPtr
<
nsDragService
>
service
=
sDragServiceInstance
.
get
(
)
;
return
service
.
forget
(
)
;
}
NS_IMETHODIMP
nsDragService
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
quit
-
application
"
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
Observe
(
\
"
quit
-
application
\
"
)
"
)
)
;
if
(
mHiddenWidget
)
{
gtk_widget_destroy
(
mHiddenWidget
)
;
mHiddenWidget
=
0
;
}
TargetResetData
(
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
topic
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
static
gboolean
DispatchMotionEventCopy
(
gpointer
aData
)
{
sMotionEventTimerID
=
0
;
GdkEvent
*
event
=
sMotionEvent
;
sMotionEvent
=
nullptr
;
if
(
gtk_widget_has_grab
(
sGrabWidget
)
)
{
gtk_propagate_event
(
sGrabWidget
event
)
;
}
gdk_event_free
(
event
)
;
return
FALSE
;
}
static
void
OnSourceGrabEventAfter
(
GtkWidget
*
widget
GdkEvent
*
event
gpointer
user_data
)
{
if
(
!
gtk_widget_has_grab
(
sGrabWidget
)
)
return
;
if
(
event
-
>
type
=
=
GDK_MOTION_NOTIFY
)
{
if
(
sMotionEvent
)
{
gdk_event_free
(
sMotionEvent
)
;
}
sMotionEvent
=
gdk_event_copy
(
event
)
;
nsDragService
*
dragService
=
static_cast
<
nsDragService
*
>
(
user_data
)
;
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
auto
p
=
LayoutDeviceIntPoint
:
:
Round
(
event
-
>
motion
.
x_root
*
scale
event
-
>
motion
.
y_root
*
scale
)
;
dragService
-
>
SetDragEndPoint
(
p
)
;
}
else
if
(
sMotionEvent
&
&
(
event
-
>
type
=
=
GDK_KEY_PRESS
|
|
event
-
>
type
=
=
GDK_KEY_RELEASE
)
)
{
sMotionEvent
-
>
motion
.
state
=
event
-
>
key
.
state
;
}
else
{
return
;
}
if
(
sMotionEventTimerID
)
{
g_source_remove
(
sMotionEventTimerID
)
;
}
sMotionEventTimerID
=
g_timeout_add_full
(
G_PRIORITY_DEFAULT_IDLE
350
DispatchMotionEventCopy
nullptr
nullptr
)
;
}
static
GtkWindow
*
GetGtkWindow
(
dom
:
:
Document
*
aDocument
)
{
if
(
!
aDocument
)
return
nullptr
;
PresShell
*
presShell
=
aDocument
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
RefPtr
<
nsViewManager
>
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
!
widget
)
return
nullptr
;
GtkWidget
*
gtkWidget
=
static_cast
<
nsWindow
*
>
(
widget
.
get
(
)
)
-
>
GetMozContainerWidget
(
)
;
if
(
!
gtkWidget
)
return
nullptr
;
GtkWidget
*
toplevel
=
nullptr
;
toplevel
=
gtk_widget_get_toplevel
(
gtkWidget
)
;
if
(
!
GTK_IS_WINDOW
(
toplevel
)
)
return
nullptr
;
return
GTK_WINDOW
(
toplevel
)
;
}
NS_IMETHODIMP
nsDragService
:
:
InvokeDragSession
(
nsINode
*
aDOMNode
nsIPrincipal
*
aPrincipal
nsIContentSecurityPolicy
*
aCsp
nsIArray
*
aArrayTransferables
uint32_t
aActionType
nsContentPolicyType
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_OTHER
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
InvokeDragSession
"
)
)
;
if
(
mSourceNode
)
return
NS_ERROR_NOT_AVAILABLE
;
return
nsBaseDragService
:
:
InvokeDragSession
(
aDOMNode
aPrincipal
aCsp
aArrayTransferables
aActionType
aContentPolicyType
)
;
}
nsresult
nsDragService
:
:
InvokeDragSessionImpl
(
nsIArray
*
aArrayTransferables
const
Maybe
<
CSSIntRegion
>
&
aRegion
uint32_t
aActionType
)
{
if
(
!
aArrayTransferables
)
return
NS_ERROR_INVALID_ARG
;
mSourceDataItems
=
aArrayTransferables
;
GtkTargetList
*
sourceList
=
GetSourceList
(
)
;
if
(
!
sourceList
)
return
NS_OK
;
GdkDragAction
action
=
GDK_ACTION_DEFAULT
;
if
(
aActionType
&
DRAGDROP_ACTION_COPY
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_COPY
)
;
if
(
aActionType
&
DRAGDROP_ACTION_MOVE
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_MOVE
)
;
if
(
aActionType
&
DRAGDROP_ACTION_LINK
)
action
=
(
GdkDragAction
)
(
action
|
GDK_ACTION_LINK
)
;
GdkEvent
event
;
memset
(
&
event
0
sizeof
(
GdkEvent
)
)
;
event
.
type
=
GDK_BUTTON_PRESS
;
event
.
button
.
window
=
gtk_widget_get_window
(
mHiddenWidget
)
;
event
.
button
.
time
=
nsWindow
:
:
GetLastUserInputTime
(
)
;
GtkWindowGroup
*
window_group
=
gtk_window_get_group
(
GetGtkWindow
(
mSourceDocument
)
)
;
gtk_window_group_add_window
(
window_group
GTK_WINDOW
(
mHiddenWidget
)
)
;
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
GdkDeviceManager
*
device_manager
=
gdk_display_get_device_manager
(
display
)
;
event
.
button
.
device
=
gdk_device_manager_get_client_pointer
(
device_manager
)
;
GdkDragContext
*
context
=
gtk_drag_begin
(
mHiddenWidget
sourceList
action
1
&
event
)
;
nsresult
rv
;
if
(
context
)
{
StartDragSession
(
)
;
sGrabWidget
=
gtk_window_group_get_current_grab
(
window_group
)
;
if
(
sGrabWidget
)
{
g_object_ref
(
sGrabWidget
)
;
g_signal_connect
(
sGrabWidget
"
event
-
after
"
G_CALLBACK
(
OnSourceGrabEventAfter
)
this
)
;
}
mEndDragPoint
=
LayoutDeviceIntPoint
(
-
1
-
1
)
;
rv
=
NS_OK
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
gtk_target_list_unref
(
sourceList
)
;
return
rv
;
}
bool
nsDragService
:
:
SetAlphaPixmap
(
SourceSurface
*
aSurface
GdkDragContext
*
aContext
int32_t
aXOffset
int32_t
aYOffset
const
LayoutDeviceIntRect
&
dragRect
)
{
GdkScreen
*
screen
=
gtk_widget_get_screen
(
mHiddenWidget
)
;
if
(
!
gdk_screen_is_composited
(
screen
)
)
return
false
;
#
ifdef
cairo_image_surface_create
#
error
"
Looks
like
we
'
re
including
Mozilla
'
s
cairo
instead
of
system
cairo
"
#
endif
cairo_surface_t
*
surf
=
cairo_image_surface_create
(
CAIRO_FORMAT_ARGB32
dragRect
.
width
dragRect
.
height
)
;
if
(
!
surf
)
return
false
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
CreateDrawTargetForData
(
cairo_image_surface_get_data
(
surf
)
nsIntSize
(
dragRect
.
width
dragRect
.
height
)
cairo_image_surface_get_stride
(
surf
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
return
false
;
dt
-
>
ClearRect
(
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
)
;
dt
-
>
DrawSurface
(
aSurface
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
Rect
(
0
0
dragRect
.
width
dragRect
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
DRAG_IMAGE_ALPHA_LEVEL
CompositionOp
:
:
OP_SOURCE
)
)
;
cairo_surface_mark_dirty
(
surf
)
;
cairo_surface_set_device_offset
(
surf
-
aXOffset
-
aYOffset
)
;
static
auto
sCairoSurfaceSetDeviceScalePtr
=
(
void
(
*
)
(
cairo_surface_t
*
double
double
)
)
dlsym
(
RTLD_DEFAULT
"
cairo_surface_set_device_scale
"
)
;
if
(
sCairoSurfaceSetDeviceScalePtr
)
{
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
sCairoSurfaceSetDeviceScalePtr
(
surf
scale
scale
)
;
}
gtk_drag_set_icon_surface
(
aContext
surf
)
;
cairo_surface_destroy
(
surf
)
;
return
true
;
}
NS_IMETHODIMP
nsDragService
:
:
StartDragSession
(
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
StartDragSession
"
)
)
;
return
nsBaseDragService
:
:
StartDragSession
(
)
;
}
NS_IMETHODIMP
nsDragService
:
:
EndDragSession
(
bool
aDoneDrag
uint32_t
aKeyModifiers
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
EndDragSession
%
d
"
aDoneDrag
)
)
;
if
(
sGrabWidget
)
{
g_signal_handlers_disconnect_by_func
(
sGrabWidget
FuncToGpointer
(
OnSourceGrabEventAfter
)
this
)
;
g_object_unref
(
sGrabWidget
)
;
sGrabWidget
=
nullptr
;
if
(
sMotionEventTimerID
)
{
g_source_remove
(
sMotionEventTimerID
)
;
sMotionEventTimerID
=
0
;
}
if
(
sMotionEvent
)
{
gdk_event_free
(
sMotionEvent
)
;
sMotionEvent
=
nullptr
;
}
}
SetDragAction
(
DRAGDROP_ACTION_NONE
)
;
mTargetDragContextForRemote
=
nullptr
;
#
ifdef
MOZ_WAYLAND
mTargetWaylandDragContextForRemote
=
nullptr
;
#
endif
return
nsBaseDragService
:
:
EndDragSession
(
aDoneDrag
aKeyModifiers
)
;
}
NS_IMETHODIMP
nsDragService
:
:
SetCanDrop
(
bool
aCanDrop
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
SetCanDrop
%
d
"
aCanDrop
)
)
;
mCanDrop
=
aCanDrop
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetCanDrop
(
bool
*
aCanDrop
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
GetCanDrop
"
)
)
;
*
aCanDrop
=
mCanDrop
;
return
NS_OK
;
}
static
void
UTF16ToNewUTF8
(
const
char16_t
*
aUTF16
uint32_t
aUTF16Len
char
*
*
aUTF8
uint32_t
*
aUTF8Len
)
{
nsDependentSubstring
utf16
(
aUTF16
aUTF16Len
)
;
*
aUTF8
=
ToNewUTF8String
(
utf16
aUTF8Len
)
;
}
static
void
UTF8ToNewUTF16
(
const
char
*
aUTF8
uint32_t
aUTF8Len
char16_t
*
*
aUTF16
uint32_t
*
aUTF16Len
)
{
nsDependentCSubstring
utf8
(
aUTF8
aUTF8Len
)
;
*
aUTF16
=
UTF8ToNewUnicode
(
utf8
aUTF16Len
)
;
}
static
uint32_t
CountTextUriListItems
(
const
char
*
data
uint32_t
datalen
)
{
const
char
*
p
=
data
;
const
char
*
endPtr
=
p
+
datalen
;
uint32_t
count
=
0
;
while
(
p
<
endPtr
)
{
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
isspace
(
*
p
)
)
p
+
+
;
if
(
p
!
=
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
&
&
*
p
!
=
'
\
r
'
)
count
+
+
;
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
)
p
+
+
;
p
+
+
;
}
return
count
;
}
static
void
GetTextUriListItem
(
const
char
*
data
uint32_t
datalen
uint32_t
aItemIndex
char16_t
*
*
convertedText
uint32_t
*
convertedTextLen
)
{
const
char
*
p
=
data
;
const
char
*
endPtr
=
p
+
datalen
;
unsigned
int
count
=
0
;
*
convertedText
=
nullptr
;
while
(
p
<
endPtr
)
{
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
isspace
(
*
p
)
)
p
+
+
;
if
(
p
!
=
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
&
&
*
p
!
=
'
\
r
'
)
count
+
+
;
if
(
aItemIndex
+
1
=
=
count
)
{
const
char
*
q
=
p
;
while
(
q
<
endPtr
&
&
*
q
!
=
'
\
0
'
&
&
*
q
!
=
'
\
n
'
&
&
*
q
!
=
'
\
r
'
)
q
+
+
;
UTF8ToNewUTF16
(
p
q
-
p
convertedText
convertedTextLen
)
;
break
;
}
while
(
p
<
endPtr
&
&
*
p
!
=
'
\
0
'
&
&
*
p
!
=
'
\
n
'
)
p
+
+
;
p
+
+
;
}
if
(
!
*
convertedText
)
{
UTF8ToNewUTF16
(
data
datalen
convertedText
convertedTextLen
)
;
}
}
NS_IMETHODIMP
nsDragService
:
:
GetNumDropItems
(
uint32_t
*
aNumItems
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
GetNumDropItems
"
)
)
;
if
(
!
mTargetWidget
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
*
*
*
warning
:
GetNumDropItems
\
called
without
a
valid
target
widget
!
\
n
"
)
)
;
*
aNumItems
=
0
;
return
NS_OK
;
}
bool
isList
=
IsTargetContextList
(
)
;
if
(
isList
)
mSourceDataItems
-
>
GetLength
(
aNumItems
)
;
else
{
GdkAtom
gdkFlavor
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
if
(
mTargetDragData
)
{
const
char
*
data
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
*
aNumItems
=
CountTextUriListItems
(
data
mTargetDragDataLen
)
;
}
else
*
aNumItems
=
1
;
}
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
%
d
items
"
*
aNumItems
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
GetData
(
nsITransferable
*
aTransferable
uint32_t
aItemIndex
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
GetData
%
d
"
aItemIndex
)
)
;
if
(
!
aTransferable
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mTargetWidget
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
*
*
*
warning
:
GetData
\
called
without
a
valid
target
widget
!
\
n
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
aTransferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
bool
isList
=
IsTargetContextList
(
)
;
if
(
isList
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
it
'
s
a
list
.
.
.
"
)
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
flavor
is
%
s
\
n
"
flavorStr
.
get
(
)
)
)
;
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
mSourceDataItems
aItemIndex
)
;
if
(
!
item
)
continue
;
nsCOMPtr
<
nsISupports
>
data
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
trying
to
get
transfer
data
for
%
s
\
n
"
flavorStr
.
get
(
)
)
)
;
rv
=
item
-
>
GetTransferData
(
flavorStr
.
get
(
)
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
failed
.
\
n
"
)
)
;
continue
;
}
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
succeeded
.
\
n
"
)
)
;
rv
=
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
data
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
fail
to
set
transfer
data
into
transferable
!
\
n
"
)
)
;
continue
;
}
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
GdkAtom
gdkFlavor
=
gdk_atom_intern
(
flavorStr
.
get
(
)
FALSE
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
looking
for
data
in
type
%
s
gdk
flavor
%
p
\
n
"
flavorStr
.
get
(
)
gdkFlavor
)
)
;
bool
dataFound
=
false
;
if
(
gdkFlavor
)
{
GetTargetDragData
(
gdkFlavor
)
;
}
if
(
mTargetDragData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
dataFound
=
true
\
n
"
)
)
;
dataFound
=
true
;
}
else
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
dataFound
=
false
\
n
"
)
)
;
if
(
flavorStr
.
EqualsLiteral
(
kFileMime
)
)
{
gdkFlavor
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
if
(
!
mTargetDragData
)
{
gdkFlavor
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
}
if
(
mTargetDragData
)
{
const
char
*
text
=
static_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
GetTextUriListItem
(
text
mTargetDragDataLen
aItemIndex
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
&
rv
)
;
nsCOMPtr
<
nsIURI
>
fileURI
;
rv
=
ioService
-
>
NewURI
(
NS_ConvertUTF16toUTF8
(
convertedText
)
nullptr
nullptr
getter_AddRefs
(
fileURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFileURL
>
fileURL
=
do_QueryInterface
(
fileURI
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsIFile
>
file
;
rv
=
fileURL
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
file
)
;
g_free
(
convertedText
)
;
return
NS_OK
;
}
}
}
g_free
(
convertedText
)
;
}
continue
;
}
}
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
we
were
looking
for
text
/
unicode
.
.
.
\
trying
with
text
/
plain
;
charset
=
utf
-
8
\
n
"
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gTextPlainUTF8Type
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
if
(
mTargetDragData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Got
textplain
data
\
n
"
)
)
;
const
char
*
castedText
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
NS_ConvertUTF8toUTF16
ucs2string
(
castedText
mTargetDragDataLen
)
;
convertedText
=
ToNewUnicode
(
ucs2string
mozilla
:
:
fallible
)
;
if
(
convertedText
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
successfully
converted
plain
text
\
to
unicode
.
\
n
"
)
)
;
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
ucs2string
.
Length
(
)
*
2
;
dataFound
=
true
;
}
}
else
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
we
were
looking
for
text
/
unicode
.
.
.
\
trying
again
with
text
/
plain
\
n
"
)
)
;
gdkFlavor
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
if
(
mTargetDragData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Got
textplain
data
\
n
"
)
)
;
const
char
*
castedText
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
UTF8ToNewUTF16
(
castedText
mTargetDragDataLen
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
successfully
converted
plain
text
\
to
unicode
.
\
n
"
)
)
;
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
convertedTextLen
*
2
;
dataFound
=
true
;
}
}
}
}
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
we
were
looking
for
text
/
x
-
moz
-
url
.
.
.
\
trying
again
with
text
/
uri
-
list
\
n
"
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gTextUriListType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
if
(
mTargetDragData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Got
text
/
uri
-
list
data
\
n
"
)
)
;
const
char
*
data
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
GetTextUriListItem
(
data
mTargetDragDataLen
aItemIndex
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
successfully
converted
\
_NETSCAPE_URL
to
unicode
.
\
n
"
)
)
;
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
convertedTextLen
*
2
;
dataFound
=
true
;
}
}
else
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
failed
to
get
text
/
uri
-
list
data
\
n
"
)
)
;
}
if
(
!
dataFound
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
we
were
looking
for
text
/
x
-
moz
-
url
.
.
.
\
trying
again
with
_NETSCAP_URL
\
n
"
)
)
;
gdkFlavor
=
gdk_atom_intern
(
gMozUrlType
FALSE
)
;
GetTargetDragData
(
gdkFlavor
)
;
if
(
mTargetDragData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Got
_NETSCAPE_URL
data
\
n
"
)
)
;
const
char
*
castedText
=
reinterpret_cast
<
char
*
>
(
mTargetDragData
)
;
char16_t
*
convertedText
=
nullptr
;
uint32_t
convertedTextLen
=
0
;
UTF8ToNewUTF16
(
castedText
mTargetDragDataLen
&
convertedText
&
convertedTextLen
)
;
if
(
convertedText
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
successfully
converted
_NETSCAPE_URL
\
to
unicode
.
\
n
"
)
)
;
g_free
(
mTargetDragData
)
;
mTargetDragData
=
convertedText
;
mTargetDragDataLen
=
convertedTextLen
*
2
;
dataFound
=
true
;
}
}
else
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
failed
to
get
_NETSCAPE_URL
data
\
n
"
)
)
;
}
}
}
}
if
(
dataFound
)
{
if
(
!
flavorStr
.
EqualsLiteral
(
kCustomTypesMime
)
)
{
nsLinebreakHelpers
:
:
ConvertPlatformToDOMLinebreaks
(
flavorStr
&
mTargetDragData
reinterpret_cast
<
int
*
>
(
&
mTargetDragDataLen
)
)
;
}
nsCOMPtr
<
nsISupports
>
genericDataWrapper
;
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
flavorStr
mTargetDragData
mTargetDragDataLen
getter_AddRefs
(
genericDataWrapper
)
)
;
aTransferable
-
>
SetTransferData
(
flavorStr
.
get
(
)
genericDataWrapper
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
dataFound
and
converted
!
\
n
"
)
)
;
break
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDragService
:
:
IsDataFlavorSupported
(
const
char
*
aDataFlavor
bool
*
_retval
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
IsDataFlavorSupported
%
s
"
aDataFlavor
)
)
;
if
(
!
_retval
)
return
NS_ERROR_INVALID_ARG
;
*
_retval
=
false
;
if
(
!
mTargetWidget
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
*
*
*
warning
:
IsDataFlavorSupported
\
called
without
a
valid
target
widget
!
\
n
"
)
)
;
return
NS_OK
;
}
bool
isList
=
IsTargetContextList
(
)
;
if
(
isList
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
It
'
s
a
list
.
.
"
)
)
;
uint32_t
numDragItems
=
0
;
if
(
!
mSourceDataItems
)
return
NS_OK
;
mSourceDataItems
-
>
GetLength
(
&
numDragItems
)
;
for
(
uint32_t
itemIndex
=
0
;
itemIndex
<
numDragItems
;
+
+
itemIndex
)
{
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
itemIndex
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
checking
%
s
against
%
s
\
n
"
flavors
[
i
]
.
get
(
)
aDataFlavor
)
)
;
if
(
flavors
[
i
]
.
Equals
(
aDataFlavor
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
boioioioiooioioioing
!
\
n
"
)
)
;
*
_retval
=
true
;
}
}
}
}
return
NS_OK
;
}
GList
*
tmp
=
nullptr
;
if
(
mTargetDragContext
)
{
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
}
#
ifdef
MOZ_WAYLAND
else
if
(
mTargetWaylandDragContext
)
{
tmp
=
mTargetWaylandDragContext
-
>
GetTargets
(
)
;
}
GList
*
tmp_head
=
tmp
;
#
endif
for
(
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
gchar
*
name
=
nullptr
;
name
=
gdk_atom_name
(
atom
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
checking
%
s
against
%
s
\
n
"
name
aDataFlavor
)
)
;
if
(
name
&
&
(
strcmp
(
name
aDataFlavor
)
=
=
0
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
good
!
\
n
"
)
)
;
*
_retval
=
true
;
}
if
(
!
*
_retval
&
&
name
&
&
(
strcmp
(
name
gTextUriListType
)
=
=
0
)
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
|
|
strcmp
(
aDataFlavor
kFileMime
)
=
=
0
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
good
!
(
it
'
s
text
/
uri
-
list
and
\
we
'
re
checking
against
text
/
x
-
moz
-
url
)
\
n
"
)
)
;
*
_retval
=
true
;
}
if
(
!
*
_retval
&
&
name
&
&
(
strcmp
(
name
gMozUrlType
)
=
=
0
)
&
&
(
strcmp
(
aDataFlavor
kURLMime
)
=
=
0
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
good
!
(
it
'
s
_NETSCAPE_URL
and
\
we
'
re
checking
against
text
/
x
-
moz
-
url
)
\
n
"
)
)
;
*
_retval
=
true
;
}
if
(
!
*
_retval
&
&
name
&
&
(
strcmp
(
name
kTextMime
)
=
=
0
)
&
&
(
(
strcmp
(
aDataFlavor
kUnicodeMime
)
=
=
0
)
|
|
(
strcmp
(
aDataFlavor
kFileMime
)
=
=
0
)
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
good
!
(
it
'
s
text
plain
and
we
'
re
checking
\
against
text
/
unicode
or
application
/
x
-
moz
-
file
)
\
n
"
)
)
;
*
_retval
=
true
;
}
g_free
(
name
)
;
}
#
ifdef
MOZ_WAYLAND
if
(
!
mTargetDragContext
&
&
tmp_head
)
{
g_list_free
(
tmp_head
)
;
}
#
endif
return
NS_OK
;
}
void
nsDragService
:
:
ReplyToDragMotion
(
GdkDragContext
*
aDragContext
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
ReplyToDragMotion
%
d
"
mCanDrop
)
)
;
GdkDragAction
action
=
(
GdkDragAction
)
0
;
if
(
mCanDrop
)
{
switch
(
mDragAction
)
{
case
DRAGDROP_ACTION_COPY
:
action
=
GDK_ACTION_COPY
;
break
;
case
DRAGDROP_ACTION_LINK
:
action
=
GDK_ACTION_LINK
;
break
;
case
DRAGDROP_ACTION_NONE
:
action
=
(
GdkDragAction
)
0
;
break
;
default
:
action
=
GDK_ACTION_MOVE
;
break
;
}
}
gdk_drag_status
(
aDragContext
action
mTargetTime
)
;
}
#
ifdef
MOZ_WAYLAND
void
nsDragService
:
:
ReplyToDragMotion
(
nsWaylandDragContext
*
aDragContext
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
ReplyToDragMotion
%
d
"
mCanDrop
)
)
;
GdkDragAction
action
=
(
GdkDragAction
)
0
;
if
(
mCanDrop
)
{
switch
(
mDragAction
)
{
case
DRAGDROP_ACTION_COPY
:
action
=
GDK_ACTION_COPY
;
break
;
case
DRAGDROP_ACTION_LINK
:
action
=
GDK_ACTION_LINK
;
break
;
case
DRAGDROP_ACTION_NONE
:
action
=
(
GdkDragAction
)
0
;
break
;
default
:
action
=
GDK_ACTION_MOVE
;
break
;
}
}
aDragContext
-
>
SetDragStatus
(
action
)
;
}
#
endif
void
nsDragService
:
:
TargetDataReceived
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aX
gint
aY
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
TargetDataReceived
"
)
)
;
TargetResetData
(
)
;
mTargetDragDataReceived
=
true
;
gint
len
=
gtk_selection_data_get_length
(
aSelectionData
)
;
const
guchar
*
data
=
gtk_selection_data_get_data
(
aSelectionData
)
;
if
(
len
>
0
&
&
data
)
{
mTargetDragDataLen
=
len
;
mTargetDragData
=
g_malloc
(
mTargetDragDataLen
)
;
memcpy
(
mTargetDragData
data
mTargetDragDataLen
)
;
}
else
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Failed
to
get
data
.
selection
data
len
was
%
d
\
n
"
mTargetDragDataLen
)
)
;
}
}
bool
nsDragService
:
:
IsTargetContextList
(
void
)
{
bool
retval
=
false
;
if
(
mTargetDragContext
&
&
gtk_drag_get_source_widget
(
mTargetDragContext
)
=
=
nullptr
)
{
return
retval
;
}
GList
*
tmp
=
nullptr
;
if
(
mTargetDragContext
)
{
tmp
=
gdk_drag_context_list_targets
(
mTargetDragContext
)
;
}
#
ifdef
MOZ_WAYLAND
GList
*
tmp_head
=
nullptr
;
if
(
mTargetWaylandDragContext
)
{
tmp_head
=
tmp
=
mTargetWaylandDragContext
-
>
GetTargets
(
)
;
}
#
endif
for
(
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
gchar
*
name
=
nullptr
;
name
=
gdk_atom_name
(
atom
)
;
if
(
name
&
&
strcmp
(
name
gMimeListType
)
=
=
0
)
retval
=
true
;
g_free
(
name
)
;
if
(
retval
)
break
;
}
#
ifdef
MOZ_WAYLAND
if
(
mTargetWaylandDragContext
&
&
tmp_head
)
{
g_list_free
(
tmp_head
)
;
}
#
endif
return
retval
;
}
#
define
NS_DND_TIMEOUT
500000
void
nsDragService
:
:
GetTargetDragData
(
GdkAtom
aFlavor
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
getting
data
flavor
%
p
\
n
"
aFlavor
)
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
mLastWidget
is
%
p
and
mLastContext
is
%
p
\
n
"
mTargetWidget
.
get
(
)
mTargetDragContext
.
get
(
)
)
)
;
TargetResetData
(
)
;
if
(
mTargetDragContext
)
{
gtk_drag_get_data
(
mTargetWidget
mTargetDragContext
aFlavor
mTargetTime
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
about
to
start
inner
iteration
.
"
)
)
;
PRTime
entryTime
=
PR_Now
(
)
;
while
(
!
mTargetDragDataReceived
&
&
mDoingDrag
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
doing
iteration
.
.
.
\
n
"
)
)
;
PR_Sleep
(
20
*
PR_TicksPerSecond
(
)
/
1000
)
;
if
(
PR_Now
(
)
-
entryTime
>
NS_DND_TIMEOUT
)
break
;
gtk_main_iteration
(
)
;
}
}
#
ifdef
MOZ_WAYLAND
else
{
mTargetDragData
=
mTargetWaylandDragContext
-
>
GetData
(
gdk_atom_name
(
aFlavor
)
&
mTargetDragDataLen
)
;
mTargetDragDataReceived
=
true
;
}
#
endif
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
finished
inner
iteration
\
n
"
)
)
;
}
void
nsDragService
:
:
TargetResetData
(
void
)
{
mTargetDragDataReceived
=
false
;
g_free
(
mTargetDragData
)
;
mTargetDragData
=
0
;
mTargetDragDataLen
=
0
;
}
GtkTargetList
*
nsDragService
:
:
GetSourceList
(
void
)
{
if
(
!
mSourceDataItems
)
return
nullptr
;
nsTArray
<
GtkTargetEntry
*
>
targetArray
;
GtkTargetEntry
*
targets
;
GtkTargetList
*
targetList
=
0
;
uint32_t
targetCount
=
0
;
unsigned
int
numDragItems
=
0
;
mSourceDataItems
-
>
GetLength
(
&
numDragItems
)
;
if
(
numDragItems
>
1
)
{
GtkTargetEntry
*
listTarget
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
listTarget
-
>
target
=
g_strdup
(
gMimeListType
)
;
listTarget
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
listTarget
-
>
target
)
)
;
targetArray
.
AppendElement
(
listTarget
)
;
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
if
(
flavors
[
i
]
.
EqualsLiteral
(
kURLMime
)
)
{
listTarget
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
listTarget
-
>
target
=
g_strdup
(
gTextUriListType
)
;
listTarget
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
listTarget
-
>
target
)
)
;
targetArray
.
AppendElement
(
listTarget
)
;
}
}
}
}
else
if
(
numDragItems
=
=
1
)
{
nsCOMPtr
<
nsITransferable
>
currItem
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
currItem
)
{
nsTArray
<
nsCString
>
flavors
;
currItem
-
>
FlavorsTransferableCanExport
(
flavors
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
nsCString
&
flavorStr
=
flavors
[
i
]
;
GtkTargetEntry
*
target
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
target
-
>
target
=
g_strdup
(
flavorStr
.
get
(
)
)
;
target
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
adding
target
%
s
\
n
"
target
-
>
target
)
)
;
targetArray
.
AppendElement
(
target
)
;
if
(
flavorStr
.
EqualsLiteral
(
kFileMime
)
)
{
GtkTargetEntry
*
urilistTarget
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
urilistTarget
-
>
target
=
g_strdup
(
gTextUriListType
)
;
urilistTarget
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
urilistTarget
-
>
target
)
)
;
targetArray
.
AppendElement
(
urilistTarget
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kUnicodeMime
)
)
{
GtkTargetEntry
*
plainUTF8Target
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
plainUTF8Target
-
>
target
=
g_strdup
(
gTextPlainUTF8Type
)
;
plainUTF8Target
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
plainUTF8Target
-
>
target
)
)
;
targetArray
.
AppendElement
(
plainUTF8Target
)
;
GtkTargetEntry
*
plainTarget
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
plainTarget
-
>
target
=
g_strdup
(
kTextMime
)
;
plainTarget
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
plainTarget
-
>
target
)
)
;
targetArray
.
AppendElement
(
plainTarget
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kURLMime
)
)
{
GtkTargetEntry
*
urlTarget
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
urlTarget
-
>
target
=
g_strdup
(
gMozUrlType
)
;
urlTarget
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
urlTarget
-
>
target
)
)
;
targetArray
.
AppendElement
(
urlTarget
)
;
}
else
if
(
flavorStr
.
EqualsLiteral
(
kFilePromiseMime
)
)
{
GtkTargetEntry
*
directsaveTarget
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
)
;
directsaveTarget
-
>
target
=
g_strdup
(
gXdndDirectSaveType
)
;
directsaveTarget
-
>
flags
=
0
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
automatically
adding
target
%
s
\
n
"
directsaveTarget
-
>
target
)
)
;
targetArray
.
AppendElement
(
directsaveTarget
)
;
}
}
}
}
targetCount
=
targetArray
.
Length
(
)
;
if
(
targetCount
)
{
targets
=
(
GtkTargetEntry
*
)
g_malloc
(
sizeof
(
GtkTargetEntry
)
*
targetCount
)
;
uint32_t
targetIndex
;
for
(
targetIndex
=
0
;
targetIndex
<
targetCount
;
+
+
targetIndex
)
{
GtkTargetEntry
*
disEntry
=
targetArray
.
ElementAt
(
targetIndex
)
;
targets
[
targetIndex
]
.
target
=
disEntry
-
>
target
;
targets
[
targetIndex
]
.
flags
=
disEntry
-
>
flags
;
targets
[
targetIndex
]
.
info
=
0
;
}
targetList
=
gtk_target_list_new
(
targets
targetCount
)
;
for
(
uint32_t
cleanIndex
=
0
;
cleanIndex
<
targetCount
;
+
+
cleanIndex
)
{
GtkTargetEntry
*
thisTarget
=
targetArray
.
ElementAt
(
cleanIndex
)
;
g_free
(
thisTarget
-
>
target
)
;
g_free
(
thisTarget
)
;
}
g_free
(
targets
)
;
}
else
{
targetList
=
gtk_target_list_new
(
nullptr
0
)
;
}
return
targetList
;
}
void
nsDragService
:
:
SourceEndDragSession
(
GdkDragContext
*
aContext
gint
aResult
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
SourceEndDragSession
result
%
d
\
n
"
aResult
)
)
;
mSourceDataItems
=
nullptr
;
GdkAtom
property
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
gdk_property_delete
(
gdk_drag_context_get_source_window
(
aContext
)
property
)
;
if
(
!
mDoingDrag
|
|
mScheduledTask
=
=
eDragTaskSourceEnd
)
return
;
if
(
mEndDragPoint
.
x
<
0
)
{
gint
x
y
;
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
if
(
display
)
{
gint
scale
=
mozilla
:
:
widget
:
:
ScreenHelperGTK
:
:
GetGTKMonitorScaleFactor
(
)
;
gdk_display_get_pointer
(
display
nullptr
&
x
&
y
nullptr
)
;
SetDragEndPoint
(
LayoutDeviceIntPoint
(
x
*
scale
y
*
scale
)
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
guess
drag
end
point
%
d
%
d
\
n
"
x
*
scale
y
*
scale
)
)
;
}
}
uint32_t
dropEffect
;
if
(
aResult
=
=
MOZ_GTK_DRAG_RESULT_SUCCESS
)
{
GdkDragAction
action
=
gdk_drag_context_get_dest_window
(
aContext
)
?
gdk_drag_context_get_actions
(
aContext
)
:
(
GdkDragAction
)
0
;
if
(
!
action
)
dropEffect
=
DRAGDROP_ACTION_NONE
;
else
if
(
action
&
GDK_ACTION_COPY
)
dropEffect
=
DRAGDROP_ACTION_COPY
;
else
if
(
action
&
GDK_ACTION_LINK
)
dropEffect
=
DRAGDROP_ACTION_LINK
;
else
if
(
action
&
GDK_ACTION_MOVE
)
dropEffect
=
DRAGDROP_ACTION_MOVE
;
else
dropEffect
=
DRAGDROP_ACTION_COPY
;
}
else
{
dropEffect
=
DRAGDROP_ACTION_NONE
;
bool
isWaylandTabDrop
=
false
;
#
ifdef
MOZ_WAYLAND
if
(
gfxPlatformGtk
:
:
GetPlatform
(
)
-
>
IsWaylandDisplay
(
)
&
&
aResult
=
=
MOZ_GTK_DRAG_RESULT_ERROR
)
{
for
(
GList
*
tmp
=
gdk_drag_context_list_targets
(
aContext
)
;
tmp
;
tmp
=
tmp
-
>
next
)
{
GdkAtom
atom
=
GDK_POINTER_TO_ATOM
(
tmp
-
>
data
)
;
gchar
*
name
=
gdk_atom_name
(
atom
)
;
if
(
name
&
&
(
strcmp
(
name
gTabDropType
)
=
=
0
)
)
{
isWaylandTabDrop
=
true
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
is
wayland
tab
drop
\
n
"
)
)
;
break
;
}
}
}
#
endif
if
(
aResult
!
=
MOZ_GTK_DRAG_RESULT_NO_TARGET
&
&
!
isWaylandTabDrop
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
drop
is
user
chancelled
\
n
"
)
)
;
mUserCancelled
=
true
;
}
}
if
(
mDataTransfer
)
{
mDataTransfer
-
>
SetDropEffectInt
(
dropEffect
)
;
}
Schedule
(
eDragTaskSourceEnd
nullptr
nullptr
nullptr
LayoutDeviceIntPoint
(
)
0
)
;
}
static
void
CreateURIList
(
nsIArray
*
aItems
nsACString
&
aURIList
)
{
uint32_t
length
=
0
;
aItems
-
>
GetLength
(
&
length
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
aItems
i
)
;
if
(
!
item
)
{
continue
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
item
-
>
GetTransferData
(
kURLMime
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsCOMPtr
<
nsISupportsString
>
string
=
do_QueryInterface
(
data
)
;
nsAutoString
text
;
if
(
string
)
{
string
-
>
GetData
(
text
)
;
}
int32_t
separatorPos
=
text
.
FindChar
(
u
'
\
n
'
)
;
if
(
separatorPos
>
=
0
)
{
text
.
Truncate
(
separatorPos
)
;
}
AppendUTF16toUTF8
(
text
aURIList
)
;
aURIList
.
AppendLiteral
(
"
\
r
\
n
"
)
;
continue
;
}
rv
=
item
-
>
GetTransferData
(
kFileMime
getter_AddRefs
(
data
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
data
)
)
{
nsCOMPtr
<
nsIURI
>
fileURI
;
NS_NewFileURI
(
getter_AddRefs
(
fileURI
)
file
)
;
if
(
fileURI
)
{
nsAutoCString
spec
;
fileURI
-
>
GetSpec
(
spec
)
;
aURIList
.
Append
(
spec
)
;
aURIList
.
AppendLiteral
(
"
\
r
\
n
"
)
;
}
}
}
}
}
void
nsDragService
:
:
SourceDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint32
aTime
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
:
SourceDataGet
"
)
)
;
GdkAtom
target
=
gtk_selection_data_get_target
(
aSelectionData
)
;
gchar
*
typeName
=
gdk_atom_name
(
target
)
;
if
(
!
typeName
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
failed
to
get
atom
name
.
\
n
"
)
)
;
return
;
}
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Type
is
%
s
\
n
"
typeName
)
)
;
auto
freeTypeName
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
g_free
(
typeName
)
;
}
)
;
if
(
!
mSourceDataItems
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
Failed
to
get
our
data
items
\
n
"
)
)
;
return
;
}
nsDependentCSubstring
mimeFlavor
(
typeName
strlen
(
typeName
)
)
;
nsCOMPtr
<
nsITransferable
>
item
;
item
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
item
)
{
bool
needToDoConversionToPlainText
=
false
;
const
char
*
actualFlavor
;
if
(
mimeFlavor
.
EqualsLiteral
(
kTextMime
)
|
|
mimeFlavor
.
EqualsLiteral
(
gTextPlainUTF8Type
)
)
{
actualFlavor
=
kUnicodeMime
;
needToDoConversionToPlainText
=
true
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gMozUrlType
)
)
{
actualFlavor
=
kURLMime
;
needToDoConversionToPlainText
=
true
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gTextUriListType
)
)
{
actualFlavor
=
gTextUriListType
;
needToDoConversionToPlainText
=
true
;
}
else
if
(
mimeFlavor
.
EqualsLiteral
(
gXdndDirectSaveType
)
)
{
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
E
"
1
)
;
GdkAtom
property
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
GdkAtom
type
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
guchar
*
data
;
gint
length
;
if
(
!
gdk_property_get
(
gdk_drag_context_get_source_window
(
aContext
)
property
type
0
INT32_MAX
FALSE
nullptr
nullptr
&
length
&
data
)
)
{
return
;
}
data
=
(
guchar
*
)
g_realloc
(
data
length
+
1
)
;
if
(
!
data
)
return
;
data
[
length
]
=
'
\
0
'
;
gchar
*
hostname
;
char
*
gfullpath
=
g_filename_from_uri
(
(
const
gchar
*
)
data
&
hostname
nullptr
)
;
g_free
(
data
)
;
if
(
!
gfullpath
)
return
;
nsCString
fullpath
(
gfullpath
)
;
g_free
(
gfullpath
)
;
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
XdndDirectSave
filepath
is
%
s
\
n
"
fullpath
.
get
(
)
)
)
;
if
(
hostname
)
{
nsCOMPtr
<
nsIPropertyBag2
>
infoService
=
do_GetService
(
NS_SYSTEMINFO_CONTRACTID
)
;
if
(
!
infoService
)
return
;
nsAutoCString
host
;
if
(
NS_SUCCEEDED
(
infoService
-
>
GetPropertyAsACString
(
u
"
host
"
_ns
host
)
)
)
{
if
(
!
host
.
Equals
(
hostname
)
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
ignored
drag
because
of
different
host
.
\
n
"
)
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
F
"
1
)
;
g_free
(
hostname
)
;
return
;
}
}
g_free
(
hostname
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
if
(
NS_FAILED
(
NS_NewNativeLocalFile
(
fullpath
false
getter_AddRefs
(
file
)
)
)
)
{
return
;
}
nsCOMPtr
<
nsIFile
>
directory
;
file
-
>
GetParent
(
getter_AddRefs
(
directory
)
)
;
item
-
>
SetTransferData
(
kFilePromiseDirectoryMime
directory
)
;
nsCOMPtr
<
nsISupportsString
>
filenamePrimitive
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
)
;
if
(
!
filenamePrimitive
)
return
;
nsAutoString
leafName
;
file
-
>
GetLeafName
(
leafName
)
;
filenamePrimitive
-
>
SetData
(
leafName
)
;
item
-
>
SetTransferData
(
kFilePromiseDestFilename
filenamePrimitive
)
;
actualFlavor
=
kFilePromiseMime
;
}
else
{
actualFlavor
=
typeName
;
}
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
data
;
rv
=
item
-
>
GetTransferData
(
actualFlavor
getter_AddRefs
(
data
)
)
;
if
(
strcmp
(
actualFlavor
kFilePromiseMime
)
=
=
0
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
"
S
"
1
)
;
}
return
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
void
*
tmpData
=
nullptr
;
uint32_t
tmpDataLen
=
0
;
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
nsDependentCString
(
actualFlavor
)
data
&
tmpData
&
tmpDataLen
)
;
if
(
needToDoConversionToPlainText
)
{
char
*
plainTextData
=
nullptr
;
char16_t
*
castedUnicode
=
reinterpret_cast
<
char16_t
*
>
(
tmpData
)
;
uint32_t
plainTextLen
=
0
;
UTF16ToNewUTF8
(
castedUnicode
tmpDataLen
/
2
&
plainTextData
&
plainTextLen
)
;
if
(
tmpData
)
{
free
(
tmpData
)
;
tmpData
=
plainTextData
;
tmpDataLen
=
plainTextLen
;
}
}
if
(
tmpData
)
{
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
tmpData
tmpDataLen
)
;
free
(
tmpData
)
;
}
}
else
{
if
(
mimeFlavor
.
EqualsLiteral
(
gTextUriListType
)
)
{
nsAutoCString
list
;
CreateURIList
(
mSourceDataItems
list
)
;
gtk_selection_data_set
(
aSelectionData
target
8
(
guchar
*
)
list
.
get
(
)
list
.
Length
(
)
)
;
return
;
}
}
}
}
void
nsDragService
:
:
SourceBeginDrag
(
GdkDragContext
*
aContext
)
{
nsCOMPtr
<
nsITransferable
>
transferable
=
do_QueryElementAt
(
mSourceDataItems
0
)
;
if
(
!
transferable
)
return
;
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
transferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
NS_ENSURE_SUCCESS
(
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
flavors
.
Length
(
)
;
+
+
i
)
{
if
(
flavors
[
i
]
.
EqualsLiteral
(
kFilePromiseDestFilename
)
)
{
nsCOMPtr
<
nsISupports
>
data
;
rv
=
transferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsISupportsString
>
fileName
=
do_QueryInterface
(
data
)
;
if
(
!
fileName
)
{
return
;
}
nsAutoString
fileNameStr
;
fileName
-
>
GetData
(
fileNameStr
)
;
nsCString
fileNameCStr
;
CopyUTF16toUTF8
(
fileNameStr
fileNameCStr
)
;
GdkAtom
property
=
gdk_atom_intern
(
gXdndDirectSaveType
FALSE
)
;
GdkAtom
type
=
gdk_atom_intern
(
kTextMime
FALSE
)
;
gdk_property_change
(
gdk_drag_context_get_source_window
(
aContext
)
property
type
8
GDK_PROP_MODE_REPLACE
(
const
guchar
*
)
fileNameCStr
.
get
(
)
fileNameCStr
.
Length
(
)
)
;
}
}
}
void
nsDragService
:
:
SetDragIcon
(
GdkDragContext
*
aContext
)
{
if
(
!
mHasImage
&
&
!
mSelection
)
return
;
LayoutDeviceIntRect
dragRect
;
nsPresContext
*
pc
;
RefPtr
<
SourceSurface
>
surface
;
DrawDrag
(
mSourceNode
mRegion
mScreenPosition
&
dragRect
&
surface
&
pc
)
;
if
(
!
pc
)
return
;
LayoutDeviceIntPoint
screenPoint
=
ConvertToUnscaledDevPixels
(
pc
mScreenPosition
)
;
int32_t
offsetX
=
screenPoint
.
x
-
dragRect
.
x
;
int32_t
offsetY
=
screenPoint
.
y
-
dragRect
.
y
;
if
(
mDragPopup
&
&
gtk_check_version
(
3
19
4
)
)
{
GtkWidget
*
gtkWidget
=
nullptr
;
nsIFrame
*
frame
=
mDragPopup
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
frame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
gtkWidget
=
(
GtkWidget
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_SHELLWIDGET
)
;
if
(
gtkWidget
)
{
OpenDragPopup
(
)
;
gtk_drag_set_icon_widget
(
aContext
gtkWidget
offsetX
offsetY
)
;
}
}
}
}
else
if
(
surface
)
{
if
(
!
SetAlphaPixmap
(
surface
aContext
offsetX
offsetY
dragRect
)
)
{
GdkPixbuf
*
dragPixbuf
=
nsImageToPixbuf
:
:
SourceSurfaceToPixbuf
(
surface
dragRect
.
width
dragRect
.
height
)
;
if
(
dragPixbuf
)
{
gtk_drag_set_icon_pixbuf
(
aContext
dragPixbuf
offsetX
offsetY
)
;
g_object_unref
(
dragPixbuf
)
;
}
}
}
}
static
void
invisibleSourceDragBegin
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
invisibleSourceDragBegin
"
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceBeginDrag
(
aContext
)
;
dragService
-
>
SetDragIcon
(
aContext
)
;
}
static
void
invisibleSourceDragDataGet
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
GtkSelectionData
*
aSelectionData
guint
aInfo
guint32
aTime
gpointer
aData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
invisibleSourceDragDataGet
"
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceDataGet
(
aWidget
aContext
aSelectionData
aTime
)
;
}
static
gboolean
invisibleSourceDragFailed
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gint
aResult
gpointer
aData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
invisibleSourceDragFailed
%
i
"
aResult
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceEndDragSession
(
aContext
aResult
)
;
return
FALSE
;
}
static
void
invisibleSourceDragEnd
(
GtkWidget
*
aWidget
GdkDragContext
*
aContext
gpointer
aData
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
invisibleSourceDragEnd
"
)
)
;
nsDragService
*
dragService
=
(
nsDragService
*
)
aData
;
dragService
-
>
SourceEndDragSession
(
aContext
MOZ_GTK_DRAG_RESULT_SUCCESS
)
;
}
gboolean
nsDragService
:
:
ScheduleMotionEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
nsWaylandDragContext
*
aWaylandDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
aDragContext
&
&
mScheduledTask
=
=
eDragTaskMotion
)
{
NS_WARNING
(
"
Drag
Motion
message
received
before
previous
reply
was
sent
"
)
;
}
return
Schedule
(
eDragTaskMotion
aWindow
aDragContext
aWaylandDragContext
aWindowPoint
aTime
)
;
}
void
nsDragService
:
:
ScheduleLeaveEvent
(
)
{
if
(
!
Schedule
(
eDragTaskLeave
nullptr
nullptr
nullptr
LayoutDeviceIntPoint
(
)
0
)
)
{
NS_WARNING
(
"
Drag
leave
after
drop
"
)
;
}
}
gboolean
nsDragService
:
:
ScheduleDropEvent
(
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
nsWaylandDragContext
*
aWaylandDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
!
Schedule
(
eDragTaskDrop
aWindow
aDragContext
aWaylandDragContext
aWindowPoint
aTime
)
)
{
NS_WARNING
(
"
Additional
drag
drop
ignored
"
)
;
return
FALSE
;
}
SetDragEndPoint
(
aWindowPoint
+
aWindow
-
>
WidgetToScreenOffset
(
)
)
;
return
TRUE
;
}
gboolean
nsDragService
:
:
Schedule
(
DragTask
aTask
nsWindow
*
aWindow
GdkDragContext
*
aDragContext
nsWaylandDragContext
*
aWaylandDragContext
LayoutDeviceIntPoint
aWindowPoint
guint
aTime
)
{
if
(
mScheduledTask
=
=
eDragTaskSourceEnd
|
|
(
mScheduledTask
=
=
eDragTaskDrop
&
&
aTask
!
=
eDragTaskSourceEnd
)
)
return
FALSE
;
mScheduledTask
=
aTask
;
mPendingWindow
=
aWindow
;
mPendingDragContext
=
aDragContext
;
#
ifdef
MOZ_WAYLAND
mPendingWaylandDragContext
=
aWaylandDragContext
;
#
endif
mPendingWindowPoint
=
aWindowPoint
;
mPendingTime
=
aTime
;
if
(
!
mTaskSource
)
{
mTaskSource
=
g_idle_add_full
(
G_PRIORITY_HIGH
TaskDispatchCallback
this
nullptr
)
;
}
return
TRUE
;
}
gboolean
nsDragService
:
:
TaskDispatchCallback
(
gpointer
data
)
{
RefPtr
<
nsDragService
>
dragService
=
static_cast
<
nsDragService
*
>
(
data
)
;
return
dragService
-
>
RunScheduledTask
(
)
;
}
gboolean
nsDragService
:
:
RunScheduledTask
(
)
{
if
(
mTargetWindow
&
&
mTargetWindow
!
=
mPendingWindow
)
{
MOZ_LOG
(
sDragLm
LogLevel
:
:
Debug
(
"
nsDragService
:
dispatch
drag
leave
(
%
p
)
\
n
"
mTargetWindow
.
get
(
)
)
)
;
mTargetWindow
-
>
DispatchDragEvent
(
eDragExit
mTargetWindowPoint
0
)
;
if
(
!
mSourceNode
)
{
EndDragSession
(
false
GetCurrentModifiers
(
)
)
;
}
}
bool
positionHasChanged
=
mPendingWindow
!
=
mTargetWindow
|
|
mPendingWindowPoint
!
=
mTargetWindowPoint
;
DragTask
task
=
mScheduledTask
;
mScheduledTask
=
eDragTaskNone
;
mTargetWindow
=
std
:
:
move
(
mPendingWindow
)
;
mTargetWindowPoint
=
mPendingWindowPoint
;
if
(
task
=
=
eDragTaskLeave
|
|
task
=
=
eDragTaskSourceEnd
)
{
if
(
task
=
=
eDragTaskSourceEnd
)
{
EndDragSession
(
true
GetCurrentModifiers
(
)
)
;
}
mTaskSource
=
0
;
return
FALSE
;
}
StartDragSession
(
)
;
mTargetWidget
=
mTargetWindow
-
>
GetMozContainerWidget
(
)
;
mTargetDragContext
=
std
:
:
move
(
mPendingDragContext
)
;
#
ifdef
MOZ_WAYLAND
mTargetWaylandDragContext
=
std
:
:
move
(
mPendingWaylandDragContext
)
;
#
endif
mTargetTime
=
mPendingTime
;
if
(
task
=
=
eDragTaskMotion
|
|
positionHasChanged
)
{
UpdateDragAction
(
)
;
TakeDragEventDispatchedToChildProcess
(
)
;
DispatchMotionEvents
(
)
;
if
(
task
=
=
eDragTaskMotion
)
{
if
(
TakeDragEventDispatchedToChildProcess
(
)
)
{
mTargetDragContextForRemote
=
mTargetDragContext
;
#
ifdef
MOZ_WAYLAND
mTargetWaylandDragContextForRemote
=
mTargetWaylandDragContext
;
#
endif
}
else
{
if
(
mTargetDragContext
)
{
ReplyToDragMotion
(
mTargetDragContext
)
;
}
#
ifdef
MOZ_WAYLAND
else
if
(
mTargetWaylandDragContext
)
{
ReplyToDragMotion
(
mTargetWaylandDragContext
)
;
}
#
endif
}
}
}
if
(
task
=
=
eDragTaskDrop
)
{
gboolean
success
=
DispatchDropEvent
(
)
;
if
(
mTargetDragContext
)
{
gtk_drag_finish
(
mTargetDragContext
success
FALSE
mTargetTime
)
;
}
mTargetWindow
=
nullptr
;
EndDragSession
(
true
GetCurrentModifiers
(
)
)
;
}
mTargetWidget
=
nullptr
;
mTargetDragContext
=
nullptr
;
#
ifdef
MOZ_WAYLAND
mTargetWaylandDragContext
=
nullptr
;
#
endif
if
(
mScheduledTask
!
=
eDragTaskNone
)
return
TRUE
;
mTaskSource
=
0
;
return
FALSE
;
}
void
nsDragService
:
:
UpdateDragAction
(
)
{
int
action
=
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
GdkDragAction
gdkAction
=
GDK_ACTION_DEFAULT
;
if
(
mTargetDragContext
)
{
gdkAction
=
gdk_drag_context_get_actions
(
mTargetDragContext
)
;
}
#
ifdef
MOZ_WAYLAND
else
if
(
mTargetWaylandDragContext
)
{
gdkAction
=
mTargetWaylandDragContext
-
>
GetAvailableDragActions
(
)
;
}
#
endif
if
(
gdkAction
&
GDK_ACTION_DEFAULT
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
if
(
gdkAction
&
GDK_ACTION_MOVE
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
else
if
(
gdkAction
&
GDK_ACTION_LINK
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
else
if
(
gdkAction
&
GDK_ACTION_COPY
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
SetDragAction
(
action
)
;
}
NS_IMETHODIMP
nsDragService
:
:
UpdateDragEffect
(
)
{
if
(
mTargetDragContextForRemote
)
{
ReplyToDragMotion
(
mTargetDragContextForRemote
)
;
mTargetDragContextForRemote
=
nullptr
;
}
#
ifdef
MOZ_WAYLAND
else
if
(
mTargetWaylandDragContextForRemote
)
{
ReplyToDragMotion
(
mTargetWaylandDragContextForRemote
)
;
mTargetWaylandDragContextForRemote
=
nullptr
;
}
#
endif
return
NS_OK
;
}
void
nsDragService
:
:
DispatchMotionEvents
(
)
{
mCanDrop
=
false
;
FireDragEventAtSource
(
eDrag
GetCurrentModifiers
(
)
)
;
mTargetWindow
-
>
DispatchDragEvent
(
eDragOver
mTargetWindowPoint
mTargetTime
)
;
}
gboolean
nsDragService
:
:
DispatchDropEvent
(
)
{
if
(
mTargetWindow
-
>
IsDestroyed
(
)
)
return
FALSE
;
EventMessage
msg
=
mCanDrop
?
eDrop
:
eDragExit
;
mTargetWindow
-
>
DispatchDragEvent
(
msg
mTargetWindowPoint
mTargetTime
)
;
return
mCanDrop
;
}
uint32_t
nsDragService
:
:
GetCurrentModifiers
(
)
{
return
mozilla
:
:
widget
:
:
KeymapWrapper
:
:
ComputeCurrentKeyModifiers
(
)
;
}
