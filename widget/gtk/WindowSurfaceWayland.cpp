#
include
"
WindowSurfaceWayland
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozcontainer
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
<
gdk
/
gdkwayland
.
h
>
#
include
<
sys
/
mman
.
h
>
#
include
<
assert
.
h
>
#
include
<
fcntl
.
h
>
#
include
<
errno
.
h
>
namespace
mozilla
{
namespace
widget
{
#
define
BUFFER_BPP
4
static
nsCOMArray
<
nsWaylandDisplay
>
gWaylandDisplays
;
static
StaticMutex
gWaylandDisplaysMutex
;
static
nsWaylandDisplay
*
WaylandDisplayGet
(
wl_display
*
aDisplay
)
;
static
void
WaylandDisplayRelease
(
wl_display
*
aDisplay
)
;
static
void
WaylandDisplayLoop
(
wl_display
*
aDisplay
)
;
#
define
EVENT_LOOP_DELAY
(
1000
/
60
)
static
nsWaylandDisplay
*
WaylandDisplayGetLocked
(
wl_display
*
aDisplay
const
StaticMutexAutoLock
&
)
{
nsWaylandDisplay
*
waylandDisplay
=
nullptr
;
int
len
=
gWaylandDisplays
.
Count
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
gWaylandDisplays
[
i
]
-
>
Matches
(
aDisplay
)
)
{
waylandDisplay
=
gWaylandDisplays
[
i
]
;
break
;
}
}
if
(
!
waylandDisplay
)
{
waylandDisplay
=
new
nsWaylandDisplay
(
aDisplay
)
;
gWaylandDisplays
.
AppendObject
(
waylandDisplay
)
;
}
NS_ADDREF
(
waylandDisplay
)
;
return
waylandDisplay
;
}
static
nsWaylandDisplay
*
WaylandDisplayGet
(
wl_display
*
aDisplay
)
{
StaticMutexAutoLock
lock
(
gWaylandDisplaysMutex
)
;
return
WaylandDisplayGetLocked
(
aDisplay
lock
)
;
}
static
bool
WaylandDisplayReleaseLocked
(
wl_display
*
aDisplay
const
StaticMutexAutoLock
&
)
{
int
len
=
gWaylandDisplays
.
Count
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
gWaylandDisplays
[
i
]
-
>
Matches
(
aDisplay
)
)
{
int
rc
=
gWaylandDisplays
[
i
]
-
>
Release
(
)
;
if
(
rc
=
=
1
)
{
gWaylandDisplays
.
RemoveObjectAt
(
i
)
;
}
return
true
;
}
}
MOZ_ASSERT
(
false
"
Missing
nsWaylandDisplay
for
this
thread
!
"
)
;
return
false
;
}
static
void
WaylandDisplayRelease
(
wl_display
*
aDisplay
)
{
StaticMutexAutoLock
lock
(
gWaylandDisplaysMutex
)
;
WaylandDisplayReleaseLocked
(
aDisplay
lock
)
;
}
static
void
WaylandDisplayLoopLocked
(
wl_display
*
aDisplay
const
StaticMutexAutoLock
&
)
{
int
len
=
gWaylandDisplays
.
Count
(
)
;
for
(
int
i
=
0
;
i
<
len
;
i
+
+
)
{
if
(
gWaylandDisplays
[
i
]
-
>
Matches
(
aDisplay
)
)
{
if
(
gWaylandDisplays
[
i
]
-
>
DisplayLoop
(
)
)
{
MessageLoop
:
:
current
(
)
-
>
PostDelayedTask
(
NewRunnableFunction
(
&
WaylandDisplayLoop
aDisplay
)
EVENT_LOOP_DELAY
)
;
}
break
;
}
}
}
static
void
WaylandDisplayLoop
(
wl_display
*
aDisplay
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
StaticMutexAutoLock
lock
(
gWaylandDisplaysMutex
)
;
WaylandDisplayLoopLocked
(
aDisplay
lock
)
;
}
static
void
global_registry_handler
(
void
*
data
wl_registry
*
registry
uint32_t
id
const
char
*
interface
uint32_t
version
)
{
if
(
strcmp
(
interface
"
wl_shm
"
)
=
=
0
)
{
auto
interface
=
reinterpret_cast
<
nsWaylandDisplay
*
>
(
data
)
;
auto
shm
=
static_cast
<
wl_shm
*
>
(
wl_registry_bind
(
registry
id
&
wl_shm_interface
1
)
)
;
wl_proxy_set_queue
(
(
struct
wl_proxy
*
)
shm
interface
-
>
GetEventQueue
(
)
)
;
interface
-
>
SetShm
(
shm
)
;
}
}
static
void
global_registry_remover
(
void
*
data
wl_registry
*
registry
uint32_t
id
)
{
}
static
const
struct
wl_registry_listener
registry_listener
=
{
global_registry_handler
global_registry_remover
}
;
wl_shm
*
nsWaylandDisplay
:
:
GetShm
(
)
{
MOZ_ASSERT
(
mThreadId
=
=
PR_GetCurrentThread
(
)
)
;
if
(
!
mShm
)
{
wl_registry
*
registry
=
wl_display_get_registry
(
mDisplay
)
;
wl_registry_add_listener
(
registry
&
registry_listener
this
)
;
wl_proxy_set_queue
(
(
struct
wl_proxy
*
)
registry
mEventQueue
)
;
wl_display_roundtrip_queue
(
mDisplay
mEventQueue
)
;
MOZ_RELEASE_ASSERT
(
mShm
"
Wayland
registry
query
failed
!
"
)
;
}
return
(
mShm
)
;
}
bool
nsWaylandDisplay
:
:
DisplayLoop
(
)
{
wl_display_dispatch_queue_pending
(
mDisplay
mEventQueue
)
;
return
true
;
}
bool
nsWaylandDisplay
:
:
Matches
(
wl_display
*
aDisplay
)
{
return
mThreadId
=
=
PR_GetCurrentThread
(
)
&
&
aDisplay
=
=
mDisplay
;
}
NS_IMPL_ISUPPORTS
(
nsWaylandDisplay
nsISupports
)
;
nsWaylandDisplay
:
:
nsWaylandDisplay
(
wl_display
*
aDisplay
)
:
mThreadId
(
PR_GetCurrentThread
(
)
)
mFormat
(
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
mShm
(
nullptr
)
mDisplay
(
aDisplay
)
{
if
(
NS_IsMainThread
(
)
)
{
mEventQueue
=
nullptr
;
}
else
{
mEventQueue
=
wl_display_create_queue
(
mDisplay
)
;
MessageLoop
:
:
current
(
)
-
>
PostTask
(
NewRunnableFunction
(
&
WaylandDisplayLoop
mDisplay
)
)
;
}
}
nsWaylandDisplay
:
:
~
nsWaylandDisplay
(
)
{
MOZ_ASSERT
(
mThreadId
=
=
PR_GetCurrentThread
(
)
)
;
mDisplay
=
nullptr
;
if
(
mEventQueue
)
{
wl_event_queue_destroy
(
mEventQueue
)
;
mEventQueue
=
nullptr
;
}
}
int
WaylandShmPool
:
:
CreateTemporaryFile
(
int
aSize
)
{
const
char
*
tmppath
=
getenv
(
"
XDG_RUNTIME_DIR
"
)
;
MOZ_RELEASE_ASSERT
(
tmppath
"
Missing
XDG_RUNTIME_DIR
env
variable
.
"
)
;
nsPrintfCString
tmpname
(
"
%
s
/
mozilla
-
shared
-
XXXXXX
"
tmppath
)
;
char
*
filename
;
int
fd
=
-
1
;
int
ret
=
0
;
if
(
tmpname
.
GetMutableData
(
&
filename
)
)
{
fd
=
mkstemp
(
filename
)
;
if
(
fd
>
=
0
)
{
int
flags
=
fcntl
(
fd
F_GETFD
)
;
if
(
flags
>
=
0
)
{
fcntl
(
fd
F_SETFD
flags
|
FD_CLOEXEC
)
;
}
}
}
if
(
fd
>
=
0
)
{
unlink
(
tmpname
.
get
(
)
)
;
}
else
{
printf_stderr
(
"
Unable
to
create
mapping
file
%
s
\
n
"
filename
)
;
MOZ_CRASH
(
)
;
}
#
ifdef
HAVE_POSIX_FALLOCATE
do
{
ret
=
posix_fallocate
(
fd
0
aSize
)
;
}
while
(
ret
=
=
EINTR
)
;
if
(
ret
!
=
0
)
{
close
(
fd
)
;
}
#
else
do
{
ret
=
ftruncate
(
fd
aSize
)
;
}
while
(
ret
<
0
&
&
errno
=
=
EINTR
)
;
if
(
ret
<
0
)
{
close
(
fd
)
;
}
#
endif
MOZ_RELEASE_ASSERT
(
ret
=
=
0
"
Mapping
file
allocation
failed
.
"
)
;
return
fd
;
}
WaylandShmPool
:
:
WaylandShmPool
(
nsWaylandDisplay
*
aWaylandDisplay
int
aSize
)
:
mAllocatedSize
(
aSize
)
{
mShmPoolFd
=
CreateTemporaryFile
(
mAllocatedSize
)
;
mImageData
=
mmap
(
nullptr
mAllocatedSize
PROT_READ
|
PROT_WRITE
MAP_SHARED
mShmPoolFd
0
)
;
MOZ_RELEASE_ASSERT
(
mImageData
!
=
MAP_FAILED
"
Unable
to
map
drawing
surface
!
"
)
;
mShmPool
=
wl_shm_create_pool
(
aWaylandDisplay
-
>
GetShm
(
)
mShmPoolFd
mAllocatedSize
)
;
wl_proxy_set_queue
(
(
struct
wl_proxy
*
)
mShmPool
aWaylandDisplay
-
>
GetEventQueue
(
)
)
;
}
bool
WaylandShmPool
:
:
Resize
(
int
aSize
)
{
if
(
aSize
<
=
mAllocatedSize
)
return
true
;
if
(
ftruncate
(
mShmPoolFd
aSize
)
<
0
)
return
false
;
#
ifdef
HAVE_POSIX_FALLOCATE
do
{
errno
=
posix_fallocate
(
mShmPoolFd
0
aSize
)
;
}
while
(
errno
=
=
EINTR
)
;
if
(
errno
!
=
0
)
return
false
;
#
endif
wl_shm_pool_resize
(
mShmPool
aSize
)
;
munmap
(
mImageData
mAllocatedSize
)
;
mImageData
=
mmap
(
nullptr
aSize
PROT_READ
|
PROT_WRITE
MAP_SHARED
mShmPoolFd
0
)
;
if
(
mImageData
=
=
MAP_FAILED
)
return
false
;
mAllocatedSize
=
aSize
;
return
true
;
}
void
WaylandShmPool
:
:
SetImageDataFromPool
(
class
WaylandShmPool
*
aSourcePool
int
aImageDataSize
)
{
MOZ_ASSERT
(
mAllocatedSize
<
=
aImageDataSize
"
WaylandShmPool
overflows
!
"
)
;
memcpy
(
mImageData
aSourcePool
-
>
GetImageData
(
)
aImageDataSize
)
;
}
WaylandShmPool
:
:
~
WaylandShmPool
(
)
{
munmap
(
mImageData
mAllocatedSize
)
;
wl_shm_pool_destroy
(
mShmPool
)
;
close
(
mShmPoolFd
)
;
}
static
void
buffer_release
(
void
*
data
wl_buffer
*
buffer
)
{
auto
surface
=
reinterpret_cast
<
WindowBackBuffer
*
>
(
data
)
;
surface
-
>
Detach
(
)
;
}
static
const
struct
wl_buffer_listener
buffer_listener
=
{
buffer_release
}
;
void
WindowBackBuffer
:
:
Create
(
int
aWidth
int
aHeight
)
{
MOZ_ASSERT
(
!
IsAttached
(
)
"
We
can
'
t
resize
attached
buffers
.
"
)
;
int
newBufferSize
=
aWidth
*
aHeight
*
BUFFER_BPP
;
mShmPool
.
Resize
(
newBufferSize
)
;
mWaylandBuffer
=
wl_shm_pool_create_buffer
(
mShmPool
.
GetShmPool
(
)
0
aWidth
aHeight
aWidth
*
BUFFER_BPP
WL_SHM_FORMAT_ARGB8888
)
;
wl_proxy_set_queue
(
(
struct
wl_proxy
*
)
mWaylandBuffer
mWaylandDisplay
-
>
GetEventQueue
(
)
)
;
wl_buffer_add_listener
(
mWaylandBuffer
&
buffer_listener
this
)
;
mWidth
=
aWidth
;
mHeight
=
aHeight
;
}
void
WindowBackBuffer
:
:
Release
(
)
{
wl_buffer_destroy
(
mWaylandBuffer
)
;
mWidth
=
mHeight
=
0
;
}
WindowBackBuffer
:
:
WindowBackBuffer
(
nsWaylandDisplay
*
aWaylandDisplay
int
aWidth
int
aHeight
)
:
mShmPool
(
aWaylandDisplay
aWidth
*
aHeight
*
BUFFER_BPP
)
mWaylandBuffer
(
nullptr
)
mWidth
(
aWidth
)
mHeight
(
aHeight
)
mAttached
(
false
)
mWaylandDisplay
(
aWaylandDisplay
)
{
Create
(
aWidth
aHeight
)
;
}
WindowBackBuffer
:
:
~
WindowBackBuffer
(
)
{
Release
(
)
;
}
bool
WindowBackBuffer
:
:
Resize
(
int
aWidth
int
aHeight
)
{
if
(
aWidth
=
=
mWidth
&
&
aHeight
=
=
mHeight
)
return
true
;
Release
(
)
;
Create
(
aWidth
aHeight
)
;
return
(
mWaylandBuffer
!
=
nullptr
)
;
}
void
WindowBackBuffer
:
:
Attach
(
wl_surface
*
aSurface
)
{
wl_surface_attach
(
aSurface
mWaylandBuffer
0
0
)
;
wl_surface_commit
(
aSurface
)
;
wl_display_flush
(
mWaylandDisplay
-
>
GetDisplay
(
)
)
;
mAttached
=
true
;
}
void
WindowBackBuffer
:
:
Detach
(
)
{
mAttached
=
false
;
}
bool
WindowBackBuffer
:
:
SetImageDataFromBackBuffer
(
class
WindowBackBuffer
*
aSourceBuffer
)
{
if
(
!
MatchSize
(
aSourceBuffer
)
)
{
Resize
(
aSourceBuffer
-
>
mWidth
aSourceBuffer
-
>
mHeight
)
;
}
mShmPool
.
SetImageDataFromPool
(
aSourceBuffer
-
>
mShmPool
aSourceBuffer
-
>
mWidth
*
aSourceBuffer
-
>
mHeight
*
BUFFER_BPP
)
;
return
true
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
WindowBackBuffer
:
:
Lock
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
gfx
:
:
IntRect
bounds
=
aRegion
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
gfx
:
:
IntSize
lockSize
(
bounds
.
XMost
(
)
bounds
.
YMost
(
)
)
;
return
gfxPlatform
:
:
CreateDrawTargetForData
(
static_cast
<
unsigned
char
*
>
(
mShmPool
.
GetImageData
(
)
)
lockSize
BUFFER_BPP
*
mWidth
mWaylandDisplay
-
>
GetSurfaceFormat
(
)
)
;
}
}
}
