#
include
<
dlfcn
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
"
WidgetStyleCache
.
h
"
#
include
"
gtkdrawing
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsString
.
h
"
#
define
STATE_FLAG_DIR_LTR
(
1U
<
<
7
)
#
define
STATE_FLAG_DIR_RTL
(
1U
<
<
8
)
static_assert
(
GTK_STATE_FLAG_DIR_LTR
=
=
STATE_FLAG_DIR_LTR
&
&
GTK_STATE_FLAG_DIR_RTL
=
=
STATE_FLAG_DIR_RTL
"
incorrect
direction
state
flags
"
)
;
enum
class
CSDStyle
{
Unknown
Solid
Normal
}
;
static
bool
gHeaderBarShouldDrawContainer
=
false
;
static
bool
gMaximizedHeaderBarShouldDrawContainer
=
false
;
static
CSDStyle
gCSDStyle
=
CSDStyle
:
:
Unknown
;
static
GtkWidget
*
sWidgetStorage
[
MOZ_GTK_WIDGET_NODE_COUNT
]
;
static
GtkStyleContext
*
sStyleStorage
[
MOZ_GTK_WIDGET_NODE_COUNT
]
;
static
GtkStyleContext
*
GetWidgetRootStyle
(
WidgetNodeType
aNodeType
)
;
static
GtkStyleContext
*
GetCssNodeStyleInternal
(
WidgetNodeType
aNodeType
)
;
static
GtkWidget
*
CreateWindowWidget
(
)
{
GtkWidget
*
widget
=
gtk_window_new
(
GTK_WINDOW_POPUP
)
;
MOZ_RELEASE_ASSERT
(
widget
"
We
'
re
missing
GtkWindow
widget
!
"
)
;
gtk_widget_set_name
(
widget
"
MozillaGtkWidget
"
)
;
return
widget
;
}
static
GtkWidget
*
CreateWindowContainerWidget
(
)
{
GtkWidget
*
widget
=
gtk_fixed_new
(
)
;
gtk_container_add
(
GTK_CONTAINER
(
GetWidget
(
MOZ_GTK_WINDOW
)
)
widget
)
;
return
widget
;
}
static
void
AddToWindowContainer
(
GtkWidget
*
widget
)
{
gtk_container_add
(
GTK_CONTAINER
(
GetWidget
(
MOZ_GTK_WINDOW_CONTAINER
)
)
widget
)
;
}
static
GtkWidget
*
CreateScrollbarWidget
(
WidgetNodeType
aAppearance
GtkOrientation
aOrientation
)
{
GtkWidget
*
widget
=
gtk_scrollbar_new
(
aOrientation
nullptr
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateMenuPopupWidget
(
)
{
GtkWidget
*
widget
=
gtk_menu_new
(
)
;
GtkStyleContext
*
style
=
gtk_widget_get_style_context
(
widget
)
;
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_POPUP
)
;
gtk_menu_attach_to_widget
(
GTK_MENU
(
widget
)
GetWidget
(
MOZ_GTK_WINDOW
)
nullptr
)
;
return
widget
;
}
static
GtkWidget
*
CreateMenuBarWidget
(
)
{
GtkWidget
*
widget
=
gtk_menu_bar_new
(
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateTooltipWidget
(
)
{
MOZ_ASSERT
(
gtk_check_version
(
3
20
0
)
!
=
nullptr
"
CreateTooltipWidget
should
be
used
for
Gtk
<
3
.
20
only
.
"
)
;
GtkWidget
*
widget
=
CreateWindowWidget
(
)
;
GtkStyleContext
*
style
=
gtk_widget_get_style_context
(
widget
)
;
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_TOOLTIP
)
;
return
widget
;
}
static
GtkWidget
*
CreateExpanderWidget
(
)
{
GtkWidget
*
widget
=
gtk_expander_new
(
"
M
"
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateFrameWidget
(
)
{
GtkWidget
*
widget
=
gtk_frame_new
(
nullptr
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateButtonWidget
(
)
{
GtkWidget
*
widget
=
gtk_button_new_with_label
(
"
M
"
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateScrolledWindowWidget
(
)
{
GtkWidget
*
widget
=
gtk_scrolled_window_new
(
nullptr
nullptr
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateTreeViewWidget
(
)
{
GtkWidget
*
widget
=
gtk_tree_view_new
(
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateTreeHeaderCellWidget
(
)
{
GtkTreeViewColumn
*
firstTreeViewColumn
;
GtkTreeViewColumn
*
middleTreeViewColumn
;
GtkTreeViewColumn
*
lastTreeViewColumn
;
GtkWidget
*
treeView
=
GetWidget
(
MOZ_GTK_TREEVIEW
)
;
firstTreeViewColumn
=
gtk_tree_view_column_new
(
)
;
gtk_tree_view_column_set_title
(
firstTreeViewColumn
"
M
"
)
;
gtk_tree_view_append_column
(
GTK_TREE_VIEW
(
treeView
)
firstTreeViewColumn
)
;
middleTreeViewColumn
=
gtk_tree_view_column_new
(
)
;
gtk_tree_view_column_set_title
(
middleTreeViewColumn
"
M
"
)
;
gtk_tree_view_append_column
(
GTK_TREE_VIEW
(
treeView
)
middleTreeViewColumn
)
;
lastTreeViewColumn
=
gtk_tree_view_column_new
(
)
;
gtk_tree_view_column_set_title
(
lastTreeViewColumn
"
M
"
)
;
gtk_tree_view_append_column
(
GTK_TREE_VIEW
(
treeView
)
lastTreeViewColumn
)
;
return
gtk_tree_view_column_get_button
(
middleTreeViewColumn
)
;
}
static
GtkWidget
*
CreateHPanedWidget
(
)
{
GtkWidget
*
widget
=
gtk_paned_new
(
GTK_ORIENTATION_HORIZONTAL
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateVPanedWidget
(
)
{
GtkWidget
*
widget
=
gtk_paned_new
(
GTK_ORIENTATION_VERTICAL
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
GtkWidget
*
CreateNotebookWidget
(
)
{
GtkWidget
*
widget
=
gtk_notebook_new
(
)
;
AddToWindowContainer
(
widget
)
;
return
widget
;
}
static
bool
HasBackground
(
GtkStyleContext
*
aStyle
)
{
GdkRGBA
gdkColor
;
gtk_style_context_get_background_color
(
aStyle
GTK_STATE_FLAG_NORMAL
&
gdkColor
)
;
if
(
gdkColor
.
alpha
!
=
0
.
0
)
{
return
true
;
}
GValue
value
=
G_VALUE_INIT
;
gtk_style_context_get_property
(
aStyle
"
background
-
image
"
GTK_STATE_FLAG_NORMAL
&
value
)
;
auto
cleanup
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
g_value_unset
(
&
value
)
;
}
)
;
return
g_value_get_boxed
(
&
value
)
;
}
static
void
CreateHeaderBarWidget
(
WidgetNodeType
aAppearance
)
{
GtkWidget
*
window
=
gtk_window_new
(
GTK_WINDOW_TOPLEVEL
)
;
GtkStyleContext
*
windowStyle
=
gtk_widget_get_style_context
(
window
)
;
gtk_style_context_add_class
(
windowStyle
IsSolidCSDStyleUsed
(
)
?
"
solid
-
csd
"
:
"
csd
"
)
;
GtkWidget
*
fixed
=
gtk_fixed_new
(
)
;
GtkStyleContext
*
fixedStyle
=
gtk_widget_get_style_context
(
fixed
)
;
gtk_style_context_add_class
(
fixedStyle
"
titlebar
"
)
;
GtkWidget
*
headerBar
=
gtk_header_bar_new
(
)
;
g_object_set
(
headerBar
"
title
"
"
Title
"
"
has
-
subtitle
"
FALSE
"
show
-
close
-
button
"
TRUE
NULL
)
;
GtkStyleContext
*
headerBarStyle
=
gtk_widget_get_style_context
(
headerBar
)
;
gtk_style_context_add_class
(
headerBarStyle
GTK_STYLE_CLASS_TITLEBAR
)
;
gtk_style_context_add_class
(
headerBarStyle
"
default
-
decoration
"
)
;
sWidgetStorage
[
aAppearance
]
=
headerBar
;
if
(
aAppearance
=
=
MOZ_GTK_HEADER_BAR_MAXIMIZED
)
{
MOZ_ASSERT
(
!
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW_MAXIMIZED
]
"
Window
widget
is
already
created
!
"
)
;
MOZ_ASSERT
(
!
sWidgetStorage
[
MOZ_GTK_HEADERBAR_FIXED_MAXIMIZED
]
"
Fixed
widget
is
already
created
!
"
)
;
gtk_style_context_add_class
(
windowStyle
"
maximized
"
)
;
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW_MAXIMIZED
]
=
window
;
sWidgetStorage
[
MOZ_GTK_HEADERBAR_FIXED_MAXIMIZED
]
=
fixed
;
}
else
{
MOZ_ASSERT
(
!
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW
]
"
Window
widget
is
already
created
!
"
)
;
MOZ_ASSERT
(
!
sWidgetStorage
[
MOZ_GTK_HEADERBAR_FIXED
]
"
Fixed
widget
is
already
created
!
"
)
;
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW
]
=
window
;
sWidgetStorage
[
MOZ_GTK_HEADERBAR_FIXED
]
=
fixed
;
}
gtk_container_add
(
GTK_CONTAINER
(
window
)
fixed
)
;
gtk_container_add
(
GTK_CONTAINER
(
fixed
)
headerBar
)
;
gtk_style_context_invalidate
(
headerBarStyle
)
;
gtk_style_context_invalidate
(
fixedStyle
)
;
gtk_widget_show_all
(
headerBar
)
;
bool
&
shouldDrawContainer
=
aAppearance
=
=
MOZ_GTK_HEADER_BAR
?
gHeaderBarShouldDrawContainer
:
gMaximizedHeaderBarShouldDrawContainer
;
shouldDrawContainer
=
[
&
]
{
const
bool
headerBarHasBackground
=
HasBackground
(
headerBarStyle
)
;
if
(
headerBarHasBackground
&
&
GetBorderRadius
(
headerBarStyle
)
)
{
return
false
;
}
if
(
HasBackground
(
fixedStyle
)
&
&
(
GetBorderRadius
(
fixedStyle
)
|
|
!
headerBarHasBackground
)
)
{
return
true
;
}
return
false
;
}
(
)
;
}
#
define
ICON_SCALE_VARIANTS
2
static
void
LoadWidgetIconPixbuf
(
GtkWidget
*
aWidgetIcon
)
{
GtkStyleContext
*
style
=
gtk_widget_get_style_context
(
aWidgetIcon
)
;
const
gchar
*
iconName
;
GtkIconSize
gtkIconSize
;
gtk_image_get_icon_name
(
GTK_IMAGE
(
aWidgetIcon
)
&
iconName
&
gtkIconSize
)
;
gint
iconWidth
iconHeight
;
gtk_icon_size_lookup
(
gtkIconSize
&
iconWidth
&
iconHeight
)
;
for
(
int
scale
=
1
;
scale
<
ICON_SCALE_VARIANTS
+
1
;
scale
+
+
)
{
GtkIconInfo
*
gtkIconInfo
=
gtk_icon_theme_lookup_icon_for_scale
(
gtk_icon_theme_get_default
(
)
iconName
iconWidth
scale
(
GtkIconLookupFlags
)
0
)
;
if
(
!
gtkIconInfo
)
{
return
;
}
gboolean
unused
;
GdkPixbuf
*
iconPixbuf
=
gtk_icon_info_load_symbolic_for_context
(
gtkIconInfo
style
&
unused
nullptr
)
;
g_object_unref
(
G_OBJECT
(
gtkIconInfo
)
)
;
cairo_surface_t
*
iconSurface
=
gdk_cairo_surface_create_from_pixbuf
(
iconPixbuf
scale
nullptr
)
;
g_object_unref
(
iconPixbuf
)
;
nsPrintfCString
surfaceName
(
"
MozillaIconSurface
%
d
"
scale
)
;
g_object_set_data_full
(
G_OBJECT
(
aWidgetIcon
)
surfaceName
.
get
(
)
iconSurface
(
GDestroyNotify
)
cairo_surface_destroy
)
;
}
}
cairo_surface_t
*
GetWidgetIconSurface
(
GtkWidget
*
aWidgetIcon
int
aScale
)
{
if
(
aScale
>
ICON_SCALE_VARIANTS
)
{
aScale
=
ICON_SCALE_VARIANTS
;
}
nsPrintfCString
surfaceName
(
"
MozillaIconSurface
%
d
"
aScale
)
;
return
(
cairo_surface_t
*
)
g_object_get_data
(
G_OBJECT
(
aWidgetIcon
)
surfaceName
.
get
(
)
)
;
}
static
void
CreateHeaderBarButton
(
GtkWidget
*
aParentWidget
WidgetNodeType
aAppearance
)
{
GtkWidget
*
widget
=
gtk_button_new
(
)
;
if
(
GTK_IS_BOX
(
aParentWidget
)
)
{
gtk_box_pack_start
(
GTK_BOX
(
aParentWidget
)
widget
FALSE
FALSE
0
)
;
}
else
{
gtk_container_add
(
GTK_CONTAINER
(
aParentWidget
)
widget
)
;
}
NS_ASSERTION
(
!
sWidgetStorage
[
aAppearance
]
"
Titlebar
button
is
already
created
!
"
)
;
sWidgetStorage
[
aAppearance
]
=
widget
;
gtk_widget_show
(
widget
)
;
GtkStyleContext
*
style
=
gtk_widget_get_style_context
(
widget
)
;
gtk_style_context_add_class
(
style
"
titlebutton
"
)
;
GtkWidget
*
image
=
nullptr
;
switch
(
aAppearance
)
{
case
MOZ_GTK_HEADER_BAR_BUTTON_CLOSE
:
gtk_style_context_add_class
(
style
"
close
"
)
;
image
=
gtk_image_new_from_icon_name
(
"
window
-
close
-
symbolic
"
GTK_ICON_SIZE_MENU
)
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_MINIMIZE
:
gtk_style_context_add_class
(
style
"
minimize
"
)
;
image
=
gtk_image_new_from_icon_name
(
"
window
-
minimize
-
symbolic
"
GTK_ICON_SIZE_MENU
)
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE
:
gtk_style_context_add_class
(
style
"
maximize
"
)
;
image
=
gtk_image_new_from_icon_name
(
"
window
-
maximize
-
symbolic
"
GTK_ICON_SIZE_MENU
)
;
break
;
case
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE_RESTORE
:
gtk_style_context_add_class
(
style
"
maximize
"
)
;
image
=
gtk_image_new_from_icon_name
(
"
window
-
restore
-
symbolic
"
GTK_ICON_SIZE_MENU
)
;
break
;
default
:
break
;
}
gtk_widget_set_valign
(
widget
GTK_ALIGN_CENTER
)
;
g_object_set
(
image
"
use
-
fallback
"
TRUE
NULL
)
;
gtk_container_add
(
GTK_CONTAINER
(
widget
)
image
)
;
style
=
gtk_widget_get_style_context
(
image
)
;
gtk_style_context_invalidate
(
style
)
;
LoadWidgetIconPixbuf
(
image
)
;
}
static
bool
IsToolbarButtonEnabled
(
ButtonLayout
*
aButtonLayout
size_t
aButtonNums
WidgetNodeType
aAppearance
)
{
for
(
size_t
i
=
0
;
i
<
aButtonNums
;
i
+
+
)
{
if
(
aButtonLayout
[
i
]
.
mType
=
=
aAppearance
)
{
return
true
;
}
}
return
false
;
}
bool
IsSolidCSDStyleUsed
(
)
{
if
(
gCSDStyle
=
=
CSDStyle
:
:
Unknown
)
{
bool
solid
;
{
GtkWidget
*
window
=
gtk_window_new
(
GTK_WINDOW_TOPLEVEL
)
;
gtk_window_set_titlebar
(
GTK_WINDOW
(
window
)
gtk_header_bar_new
(
)
)
;
gtk_widget_realize
(
window
)
;
GtkStyleContext
*
windowStyle
=
gtk_widget_get_style_context
(
window
)
;
solid
=
gtk_style_context_has_class
(
windowStyle
"
solid
-
csd
"
)
;
gtk_widget_destroy
(
window
)
;
}
gCSDStyle
=
solid
?
CSDStyle
:
:
Solid
:
CSDStyle
:
:
Normal
;
}
return
gCSDStyle
=
=
CSDStyle
:
:
Solid
;
}
static
void
CreateHeaderBarButtons
(
)
{
GtkWidget
*
headerBar
=
sWidgetStorage
[
MOZ_GTK_HEADER_BAR
]
;
MOZ_ASSERT
(
headerBar
"
We
'
re
missing
header
bar
widget
!
"
)
;
GtkWidget
*
buttonBox
=
gtk_box_new
(
GTK_ORIENTATION_HORIZONTAL
0
)
;
gtk_container_add
(
GTK_CONTAINER
(
headerBar
)
buttonBox
)
;
gtk_style_context_add_class
(
gtk_widget_get_style_context
(
buttonBox
)
GTK_STYLE_CLASS_LEFT
)
;
ButtonLayout
buttonLayout
[
TOOLBAR_BUTTONS
]
;
size_t
activeButtons
=
GetGtkHeaderBarButtonLayout
(
mozilla
:
:
Span
(
buttonLayout
)
nullptr
)
;
if
(
IsToolbarButtonEnabled
(
buttonLayout
activeButtons
MOZ_GTK_HEADER_BAR_BUTTON_MINIMIZE
)
)
{
CreateHeaderBarButton
(
buttonBox
MOZ_GTK_HEADER_BAR_BUTTON_MINIMIZE
)
;
}
if
(
IsToolbarButtonEnabled
(
buttonLayout
activeButtons
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE
)
)
{
CreateHeaderBarButton
(
buttonBox
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE
)
;
CreateHeaderBarButton
(
GetWidget
(
MOZ_GTK_HEADER_BAR_MAXIMIZED
)
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE_RESTORE
)
;
}
if
(
IsToolbarButtonEnabled
(
buttonLayout
activeButtons
MOZ_GTK_HEADER_BAR_BUTTON_CLOSE
)
)
{
CreateHeaderBarButton
(
buttonBox
MOZ_GTK_HEADER_BAR_BUTTON_CLOSE
)
;
}
}
static
void
CreateHeaderBar
(
)
{
CreateHeaderBarWidget
(
MOZ_GTK_HEADER_BAR
)
;
CreateHeaderBarWidget
(
MOZ_GTK_HEADER_BAR_MAXIMIZED
)
;
CreateHeaderBarButtons
(
)
;
}
static
GtkWidget
*
CreateWidget
(
WidgetNodeType
aAppearance
)
{
switch
(
aAppearance
)
{
case
MOZ_GTK_WINDOW
:
return
CreateWindowWidget
(
)
;
case
MOZ_GTK_WINDOW_CONTAINER
:
return
CreateWindowContainerWidget
(
)
;
case
MOZ_GTK_SCROLLBAR_VERTICAL
:
return
CreateScrollbarWidget
(
aAppearance
GTK_ORIENTATION_VERTICAL
)
;
case
MOZ_GTK_MENUPOPUP
:
return
CreateMenuPopupWidget
(
)
;
case
MOZ_GTK_MENUBAR
:
return
CreateMenuBarWidget
(
)
;
case
MOZ_GTK_EXPANDER
:
return
CreateExpanderWidget
(
)
;
case
MOZ_GTK_FRAME
:
return
CreateFrameWidget
(
)
;
case
MOZ_GTK_BUTTON
:
return
CreateButtonWidget
(
)
;
case
MOZ_GTK_SCROLLED_WINDOW
:
return
CreateScrolledWindowWidget
(
)
;
case
MOZ_GTK_TREEVIEW
:
return
CreateTreeViewWidget
(
)
;
case
MOZ_GTK_TREE_HEADER_CELL
:
return
CreateTreeHeaderCellWidget
(
)
;
case
MOZ_GTK_SPLITTER_HORIZONTAL
:
return
CreateHPanedWidget
(
)
;
case
MOZ_GTK_SPLITTER_VERTICAL
:
return
CreateVPanedWidget
(
)
;
case
MOZ_GTK_NOTEBOOK
:
return
CreateNotebookWidget
(
)
;
case
MOZ_GTK_HEADERBAR_WINDOW
:
case
MOZ_GTK_HEADERBAR_WINDOW_MAXIMIZED
:
case
MOZ_GTK_HEADERBAR_FIXED
:
case
MOZ_GTK_HEADERBAR_FIXED_MAXIMIZED
:
case
MOZ_GTK_HEADER_BAR
:
case
MOZ_GTK_HEADER_BAR_MAXIMIZED
:
case
MOZ_GTK_HEADER_BAR_BUTTON_CLOSE
:
case
MOZ_GTK_HEADER_BAR_BUTTON_MINIMIZE
:
case
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE
:
case
MOZ_GTK_HEADER_BAR_BUTTON_MAXIMIZE_RESTORE
:
CreateHeaderBar
(
)
;
return
sWidgetStorage
[
aAppearance
]
;
default
:
return
nullptr
;
}
}
GtkWidget
*
GetWidget
(
WidgetNodeType
aAppearance
)
{
GtkWidget
*
widget
=
sWidgetStorage
[
aAppearance
]
;
if
(
!
widget
)
{
widget
=
CreateWidget
(
aAppearance
)
;
if
(
!
widget
)
{
return
nullptr
;
}
GtkStyleContext
*
style
=
gtk_widget_get_style_context
(
widget
)
;
gtk_style_context_invalidate
(
style
)
;
sWidgetStorage
[
aAppearance
]
=
widget
;
}
return
widget
;
}
static
void
AddStyleClassesFromStyle
(
GtkStyleContext
*
aDest
GtkStyleContext
*
aSrc
)
{
GList
*
classes
=
gtk_style_context_list_classes
(
aSrc
)
;
for
(
GList
*
link
=
classes
;
link
;
link
=
link
-
>
next
)
{
gtk_style_context_add_class
(
aDest
static_cast
<
gchar
*
>
(
link
-
>
data
)
)
;
}
g_list_free
(
classes
)
;
}
GtkStyleContext
*
CreateStyleForWidget
(
GtkWidget
*
aWidget
GtkStyleContext
*
aParentStyle
)
{
static
auto
sGtkWidgetClassGetCSSName
=
reinterpret_cast
<
const
char
*
(
*
)
(
GtkWidgetClass
*
)
>
(
dlsym
(
RTLD_DEFAULT
"
gtk_widget_class_get_css_name
"
)
)
;
GtkWidgetClass
*
widgetClass
=
GTK_WIDGET_GET_CLASS
(
aWidget
)
;
const
gchar
*
name
=
sGtkWidgetClassGetCSSName
?
sGtkWidgetClassGetCSSName
(
widgetClass
)
:
nullptr
;
GtkStyleContext
*
context
=
CreateCSSNode
(
name
aParentStyle
G_TYPE_FROM_CLASS
(
widgetClass
)
)
;
GtkStyleContext
*
widgetStyle
=
gtk_widget_get_style_context
(
aWidget
)
;
AddStyleClassesFromStyle
(
context
widgetStyle
)
;
g_object_ref_sink
(
aWidget
)
;
g_object_unref
(
aWidget
)
;
return
context
;
}
static
GtkStyleContext
*
CreateStyleForWidget
(
GtkWidget
*
aWidget
WidgetNodeType
aParentType
)
{
return
CreateStyleForWidget
(
aWidget
GetWidgetRootStyle
(
aParentType
)
)
;
}
GtkStyleContext
*
CreateCSSNode
(
const
char
*
aName
GtkStyleContext
*
aParentStyle
GType
aType
)
{
static
auto
sGtkWidgetPathIterSetObjectName
=
reinterpret_cast
<
void
(
*
)
(
GtkWidgetPath
*
gint
const
char
*
)
>
(
dlsym
(
RTLD_DEFAULT
"
gtk_widget_path_iter_set_object_name
"
)
)
;
GtkWidgetPath
*
path
;
if
(
aParentStyle
)
{
path
=
gtk_widget_path_copy
(
gtk_style_context_get_path
(
aParentStyle
)
)
;
GList
*
classes
=
gtk_style_context_list_classes
(
aParentStyle
)
;
for
(
GList
*
link
=
classes
;
link
;
link
=
link
-
>
next
)
{
gtk_widget_path_iter_add_class
(
path
-
1
static_cast
<
gchar
*
>
(
link
-
>
data
)
)
;
}
g_list_free
(
classes
)
;
}
else
{
path
=
gtk_widget_path_new
(
)
;
}
gtk_widget_path_append_type
(
path
aType
)
;
if
(
sGtkWidgetPathIterSetObjectName
)
{
(
*
sGtkWidgetPathIterSetObjectName
)
(
path
-
1
aName
)
;
}
GtkStyleContext
*
context
=
gtk_style_context_new
(
)
;
gtk_style_context_set_path
(
context
path
)
;
gtk_style_context_set_parent
(
context
aParentStyle
)
;
gtk_widget_path_unref
(
path
)
;
if
(
GTK_MAJOR_VERSION
=
=
3
&
&
gtk_get_minor_version
(
)
<
6
)
{
GdkRGBA
unused
;
gtk_style_context_get_color
(
context
GTK_STATE_FLAG_NORMAL
&
unused
)
;
}
return
context
;
}
static
GtkStyleContext
*
GetWidgetRootStyle
(
WidgetNodeType
aNodeType
)
{
GtkStyleContext
*
style
=
sStyleStorage
[
aNodeType
]
;
if
(
style
)
return
style
;
switch
(
aNodeType
)
{
case
MOZ_GTK_MENUITEM
:
style
=
CreateStyleForWidget
(
gtk_menu_item_new
(
)
MOZ_GTK_MENUPOPUP
)
;
break
;
case
MOZ_GTK_MENUBARITEM
:
style
=
CreateStyleForWidget
(
gtk_menu_item_new
(
)
MOZ_GTK_MENUBAR
)
;
break
;
case
MOZ_GTK_TEXT_VIEW
:
style
=
CreateStyleForWidget
(
gtk_text_view_new
(
)
MOZ_GTK_SCROLLED_WINDOW
)
;
break
;
case
MOZ_GTK_TOOLTIP
:
if
(
gtk_check_version
(
3
20
0
)
!
=
nullptr
)
{
GtkWidget
*
tooltipWindow
=
CreateTooltipWidget
(
)
;
style
=
CreateStyleForWidget
(
tooltipWindow
nullptr
)
;
gtk_widget_destroy
(
tooltipWindow
)
;
}
else
{
style
=
CreateCSSNode
(
"
tooltip
"
nullptr
GTK_TYPE_TOOLTIP
)
;
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_BACKGROUND
)
;
}
break
;
case
MOZ_GTK_TOOLTIP_BOX
:
style
=
CreateStyleForWidget
(
gtk_box_new
(
GTK_ORIENTATION_HORIZONTAL
0
)
MOZ_GTK_TOOLTIP
)
;
break
;
case
MOZ_GTK_TOOLTIP_BOX_LABEL
:
style
=
CreateStyleForWidget
(
gtk_label_new
(
nullptr
)
MOZ_GTK_TOOLTIP_BOX
)
;
break
;
default
:
GtkWidget
*
widget
=
GetWidget
(
aNodeType
)
;
MOZ_ASSERT
(
widget
)
;
return
gtk_widget_get_style_context
(
widget
)
;
}
MOZ_ASSERT
(
style
)
;
sStyleStorage
[
aNodeType
]
=
style
;
return
style
;
}
static
GtkStyleContext
*
CreateChildCSSNode
(
const
char
*
aName
WidgetNodeType
aParentNodeType
)
{
return
CreateCSSNode
(
aName
GetCssNodeStyleInternal
(
aParentNodeType
)
)
;
}
static
GtkStyleContext
*
CreateSubStyleWithClass
(
WidgetNodeType
aAppearance
const
gchar
*
aStyleClass
)
{
static
auto
sGtkWidgetPathIterGetObjectName
=
reinterpret_cast
<
const
char
*
(
*
)
(
const
GtkWidgetPath
*
gint
)
>
(
dlsym
(
RTLD_DEFAULT
"
gtk_widget_path_iter_get_object_name
"
)
)
;
GtkStyleContext
*
parentStyle
=
GetWidgetRootStyle
(
aAppearance
)
;
const
GtkWidgetPath
*
parentPath
=
gtk_style_context_get_path
(
parentStyle
)
;
const
gchar
*
name
=
sGtkWidgetPathIterGetObjectName
?
sGtkWidgetPathIterGetObjectName
(
parentPath
-
1
)
:
nullptr
;
GType
objectType
=
gtk_widget_path_get_object_type
(
parentPath
)
;
GtkStyleContext
*
style
=
CreateCSSNode
(
name
parentStyle
objectType
)
;
AddStyleClassesFromStyle
(
style
parentStyle
)
;
gtk_style_context_add_class
(
style
aStyleClass
)
;
return
style
;
}
static
GtkStyleContext
*
GetCssNodeStyleInternal
(
WidgetNodeType
aNodeType
)
{
GtkStyleContext
*
style
=
sStyleStorage
[
aNodeType
]
;
if
(
style
)
return
style
;
switch
(
aNodeType
)
{
case
MOZ_GTK_SCROLLBAR_CONTENTS_VERTICAL
:
style
=
CreateChildCSSNode
(
"
contents
"
MOZ_GTK_SCROLLBAR_VERTICAL
)
;
break
;
case
MOZ_GTK_SCROLLBAR_TROUGH_VERTICAL
:
style
=
CreateChildCSSNode
(
GTK_STYLE_CLASS_TROUGH
MOZ_GTK_SCROLLBAR_CONTENTS_VERTICAL
)
;
break
;
case
MOZ_GTK_SCROLLBAR_THUMB_VERTICAL
:
style
=
CreateChildCSSNode
(
GTK_STYLE_CLASS_SLIDER
MOZ_GTK_SCROLLBAR_TROUGH_VERTICAL
)
;
break
;
case
MOZ_GTK_SCROLLED_WINDOW
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_SCROLLED_WINDOW
GTK_STYLE_CLASS_FRAME
)
;
break
;
case
MOZ_GTK_TEXT_VIEW_TEXT_SELECTION
:
style
=
CreateChildCSSNode
(
"
selection
"
MOZ_GTK_TEXT_VIEW_TEXT
)
;
break
;
case
MOZ_GTK_TEXT_VIEW_TEXT
:
case
MOZ_GTK_RESIZER
:
style
=
CreateChildCSSNode
(
"
text
"
MOZ_GTK_TEXT_VIEW
)
;
if
(
aNodeType
=
=
MOZ_GTK_RESIZER
)
{
GdkRGBA
color
;
gtk_style_context_get_background_color
(
style
GTK_STATE_FLAG_NORMAL
&
color
)
;
if
(
color
.
alpha
=
=
0
.
0
)
{
g_object_unref
(
style
)
;
style
=
CreateStyleForWidget
(
gtk_text_view_new
(
)
MOZ_GTK_SCROLLED_WINDOW
)
;
}
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_GRIP
)
;
}
break
;
case
MOZ_GTK_FRAME_BORDER
:
style
=
CreateChildCSSNode
(
"
border
"
MOZ_GTK_FRAME
)
;
break
;
case
MOZ_GTK_TREEVIEW_VIEW
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_TREEVIEW
GTK_STYLE_CLASS_VIEW
)
;
break
;
case
MOZ_GTK_SPLITTER_SEPARATOR_HORIZONTAL
:
style
=
CreateChildCSSNode
(
"
separator
"
MOZ_GTK_SPLITTER_HORIZONTAL
)
;
break
;
case
MOZ_GTK_SPLITTER_SEPARATOR_VERTICAL
:
style
=
CreateChildCSSNode
(
"
separator
"
MOZ_GTK_SPLITTER_VERTICAL
)
;
break
;
case
MOZ_GTK_TAB_TOP
:
{
style
=
CreateSubStyleWithClass
(
MOZ_GTK_NOTEBOOK
GTK_STYLE_CLASS_TOP
)
;
gtk_style_context_add_region
(
style
GTK_STYLE_REGION_TAB
static_cast
<
GtkRegionFlags
>
(
0
)
)
;
break
;
}
case
MOZ_GTK_TAB_BOTTOM
:
{
style
=
CreateSubStyleWithClass
(
MOZ_GTK_NOTEBOOK
GTK_STYLE_CLASS_BOTTOM
)
;
gtk_style_context_add_region
(
style
GTK_STYLE_REGION_TAB
static_cast
<
GtkRegionFlags
>
(
0
)
)
;
break
;
}
case
MOZ_GTK_NOTEBOOK
:
case
MOZ_GTK_NOTEBOOK_HEADER
:
case
MOZ_GTK_TABPANELS
:
{
GtkWidget
*
widget
=
GetWidget
(
MOZ_GTK_NOTEBOOK
)
;
return
gtk_widget_get_style_context
(
widget
)
;
}
case
MOZ_GTK_WINDOW_DECORATION
:
{
GtkStyleContext
*
parentStyle
=
CreateSubStyleWithClass
(
MOZ_GTK_WINDOW
"
csd
"
)
;
style
=
CreateCSSNode
(
"
decoration
"
parentStyle
)
;
g_object_unref
(
parentStyle
)
;
break
;
}
case
MOZ_GTK_WINDOW_DECORATION_SOLID
:
{
GtkStyleContext
*
parentStyle
=
CreateSubStyleWithClass
(
MOZ_GTK_WINDOW
"
solid
-
csd
"
)
;
style
=
CreateCSSNode
(
"
decoration
"
parentStyle
)
;
g_object_unref
(
parentStyle
)
;
break
;
}
default
:
return
GetWidgetRootStyle
(
aNodeType
)
;
}
MOZ_ASSERT
(
style
"
missing
style
context
for
node
type
"
)
;
sStyleStorage
[
aNodeType
]
=
style
;
return
style
;
}
static
GtkStyleContext
*
GetWidgetStyleInternal
(
WidgetNodeType
aNodeType
)
{
GtkStyleContext
*
style
=
sStyleStorage
[
aNodeType
]
;
if
(
style
)
return
style
;
switch
(
aNodeType
)
{
case
MOZ_GTK_SCROLLBAR_TROUGH_VERTICAL
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_SCROLLBAR_VERTICAL
GTK_STYLE_CLASS_TROUGH
)
;
break
;
case
MOZ_GTK_SCROLLBAR_THUMB_VERTICAL
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_SCROLLBAR_VERTICAL
GTK_STYLE_CLASS_SLIDER
)
;
break
;
case
MOZ_GTK_SCROLLED_WINDOW
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_SCROLLED_WINDOW
GTK_STYLE_CLASS_FRAME
)
;
break
;
case
MOZ_GTK_TEXT_VIEW_TEXT
:
case
MOZ_GTK_RESIZER
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_TEXT_VIEW
GTK_STYLE_CLASS_VIEW
)
;
if
(
aNodeType
=
=
MOZ_GTK_RESIZER
)
{
gtk_style_context_add_class
(
style
GTK_STYLE_CLASS_GRIP
)
;
}
break
;
case
MOZ_GTK_FRAME_BORDER
:
return
GetWidgetRootStyle
(
MOZ_GTK_FRAME
)
;
case
MOZ_GTK_TREEVIEW_VIEW
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_TREEVIEW
GTK_STYLE_CLASS_VIEW
)
;
break
;
case
MOZ_GTK_SPLITTER_SEPARATOR_HORIZONTAL
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_SPLITTER_HORIZONTAL
GTK_STYLE_CLASS_PANE_SEPARATOR
)
;
break
;
case
MOZ_GTK_SPLITTER_SEPARATOR_VERTICAL
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_SPLITTER_VERTICAL
GTK_STYLE_CLASS_PANE_SEPARATOR
)
;
break
;
case
MOZ_GTK_TAB_TOP
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_NOTEBOOK
GTK_STYLE_CLASS_TOP
)
;
gtk_style_context_add_region
(
style
GTK_STYLE_REGION_TAB
static_cast
<
GtkRegionFlags
>
(
0
)
)
;
break
;
case
MOZ_GTK_TAB_BOTTOM
:
style
=
CreateSubStyleWithClass
(
MOZ_GTK_NOTEBOOK
GTK_STYLE_CLASS_BOTTOM
)
;
gtk_style_context_add_region
(
style
GTK_STYLE_REGION_TAB
static_cast
<
GtkRegionFlags
>
(
0
)
)
;
break
;
case
MOZ_GTK_NOTEBOOK
:
case
MOZ_GTK_NOTEBOOK_HEADER
:
case
MOZ_GTK_TABPANELS
:
{
GtkWidget
*
widget
=
GetWidget
(
MOZ_GTK_NOTEBOOK
)
;
return
gtk_widget_get_style_context
(
widget
)
;
}
default
:
return
GetWidgetRootStyle
(
aNodeType
)
;
}
MOZ_ASSERT
(
style
)
;
sStyleStorage
[
aNodeType
]
=
style
;
return
style
;
}
void
ResetWidgetCache
(
)
{
for
(
int
i
=
0
;
i
<
MOZ_GTK_WIDGET_NODE_COUNT
;
i
+
+
)
{
if
(
sStyleStorage
[
i
]
)
g_object_unref
(
sStyleStorage
[
i
]
)
;
}
mozilla
:
:
PodArrayZero
(
sStyleStorage
)
;
gCSDStyle
=
CSDStyle
:
:
Unknown
;
if
(
sWidgetStorage
[
MOZ_GTK_WINDOW
]
)
{
gtk_widget_destroy
(
sWidgetStorage
[
MOZ_GTK_WINDOW
]
)
;
}
if
(
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW
]
)
{
gtk_widget_destroy
(
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW
]
)
;
}
if
(
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW_MAXIMIZED
]
)
{
gtk_widget_destroy
(
sWidgetStorage
[
MOZ_GTK_HEADERBAR_WINDOW_MAXIMIZED
]
)
;
}
mozilla
:
:
PodArrayZero
(
sWidgetStorage
)
;
}
GtkStyleContext
*
GetStyleContext
(
WidgetNodeType
aNodeType
int
aScale
GtkTextDirection
aDirection
GtkStateFlags
aStateFlags
)
{
GtkStyleContext
*
style
;
if
(
gtk_check_version
(
3
20
0
)
!
=
nullptr
)
{
style
=
GetWidgetStyleInternal
(
aNodeType
)
;
}
else
{
style
=
GetCssNodeStyleInternal
(
aNodeType
)
;
StyleContextSetScale
(
style
aScale
)
;
}
bool
stateChanged
=
false
;
bool
stateHasDirection
=
gtk_get_minor_version
(
)
>
=
8
;
GtkStateFlags
oldState
=
gtk_style_context_get_state
(
style
)
;
MOZ_ASSERT
(
!
(
aStateFlags
&
(
STATE_FLAG_DIR_LTR
|
STATE_FLAG_DIR_RTL
)
)
)
;
unsigned
newState
=
aStateFlags
;
if
(
stateHasDirection
)
{
switch
(
aDirection
)
{
case
GTK_TEXT_DIR_LTR
:
newState
|
=
STATE_FLAG_DIR_LTR
;
break
;
case
GTK_TEXT_DIR_RTL
:
newState
|
=
STATE_FLAG_DIR_RTL
;
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Bad
GtkTextDirection
"
)
;
case
GTK_TEXT_DIR_NONE
:
newState
|
=
oldState
&
(
STATE_FLAG_DIR_LTR
|
STATE_FLAG_DIR_RTL
)
;
}
}
else
if
(
aDirection
!
=
GTK_TEXT_DIR_NONE
)
{
GtkTextDirection
oldDirection
=
gtk_style_context_get_direction
(
style
)
;
if
(
aDirection
!
=
oldDirection
)
{
gtk_style_context_set_direction
(
style
aDirection
)
;
stateChanged
=
true
;
}
}
if
(
oldState
!
=
newState
)
{
gtk_style_context_set_state
(
style
static_cast
<
GtkStateFlags
>
(
newState
)
)
;
stateChanged
=
true
;
}
if
(
stateChanged
&
&
sWidgetStorage
[
aNodeType
]
)
{
gtk_style_context_invalidate
(
style
)
;
}
return
style
;
}
GtkStyleContext
*
CreateStyleContextWithStates
(
WidgetNodeType
aNodeType
int
aScale
GtkTextDirection
aDirection
GtkStateFlags
aStateFlags
)
{
GtkStyleContext
*
style
=
GetStyleContext
(
aNodeType
aScale
aDirection
aStateFlags
)
;
GtkWidgetPath
*
path
=
gtk_widget_path_copy
(
gtk_style_context_get_path
(
style
)
)
;
static
auto
sGtkWidgetPathIterGetState
=
(
GtkStateFlags
(
*
)
(
const
GtkWidgetPath
*
gint
)
)
dlsym
(
RTLD_DEFAULT
"
gtk_widget_path_iter_get_state
"
)
;
static
auto
sGtkWidgetPathIterSetState
=
(
void
(
*
)
(
GtkWidgetPath
*
gint
GtkStateFlags
)
)
dlsym
(
RTLD_DEFAULT
"
gtk_widget_path_iter_set_state
"
)
;
int
pathLength
=
gtk_widget_path_length
(
path
)
;
for
(
int
i
=
0
;
i
<
pathLength
;
i
+
+
)
{
unsigned
state
=
aStateFlags
|
sGtkWidgetPathIterGetState
(
path
i
)
;
sGtkWidgetPathIterSetState
(
path
i
GtkStateFlags
(
state
)
)
;
}
style
=
gtk_style_context_new
(
)
;
gtk_style_context_set_path
(
style
path
)
;
gtk_widget_path_unref
(
path
)
;
return
style
;
}
void
StyleContextSetScale
(
GtkStyleContext
*
style
gint
aScaleFactor
)
{
static
auto
sGtkStyleContextSetScalePtr
=
(
void
(
*
)
(
GtkStyleContext
*
gint
)
)
dlsym
(
RTLD_DEFAULT
"
gtk_style_context_set_scale
"
)
;
if
(
sGtkStyleContextSetScalePtr
&
&
style
)
{
sGtkStyleContextSetScalePtr
(
style
aScaleFactor
)
;
}
}
bool
HeaderBarShouldDrawContainer
(
WidgetNodeType
aNodeType
)
{
MOZ_ASSERT
(
aNodeType
=
=
MOZ_GTK_HEADER_BAR
|
|
aNodeType
=
=
MOZ_GTK_HEADER_BAR_MAXIMIZED
)
;
mozilla
:
:
Unused
<
<
GetWidget
(
aNodeType
)
;
return
aNodeType
=
=
MOZ_GTK_HEADER_BAR
?
gHeaderBarShouldDrawContainer
:
gMaximizedHeaderBarShouldDrawContainer
;
}
gint
GetBorderRadius
(
GtkStyleContext
*
aStyle
)
{
GValue
value
=
G_VALUE_INIT
;
gtk_style_context_get_property
(
aStyle
"
border
-
radius
"
GTK_STATE_FLAG_NORMAL
&
value
)
;
gint
result
=
0
;
auto
type
=
G_VALUE_TYPE
(
&
value
)
;
if
(
type
=
=
G_TYPE_INT
)
{
result
=
g_value_get_int
(
&
value
)
;
}
else
{
NS_WARNING
(
nsPrintfCString
(
"
Unknown
value
type
%
lu
for
border
-
radius
"
type
)
.
get
(
)
)
;
}
g_value_unset
(
&
value
)
;
return
result
;
}
