#
ifndef
nsPrinterCUPS_h___
#
define
nsPrinterCUPS_h___
#
include
"
nsPrinterBase
.
h
"
#
include
"
nsPrintSettingsImpl
.
h
"
#
include
"
nsCUPSShim
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
FunctionRef
.
h
"
#
include
"
mozilla
/
RecursiveMutex
.
h
"
class
nsPrinterCUPS
final
:
public
nsPrinterBase
{
public
:
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
;
NS_IMETHOD
GetSystemName
(
nsAString
&
aName
)
override
;
bool
SupportsDuplex
(
)
const
final
;
bool
SupportsColor
(
)
const
final
;
bool
SupportsMonochrome
(
)
const
final
;
bool
SupportsCollation
(
)
const
final
;
PrinterInfo
CreatePrinterInfo
(
)
const
final
;
MarginDouble
GetMarginsForPaper
(
nsString
aPaperId
)
const
final
{
MOZ_ASSERT_UNREACHABLE
(
"
The
CUPS
API
requires
us
to
always
get
the
margin
when
fetching
the
"
"
paper
list
so
there
should
be
no
need
to
query
it
separately
"
)
;
return
{
}
;
}
nsPrinterCUPS
(
)
=
delete
;
nsPrinterCUPS
(
const
mozilla
:
:
CommonPaperInfoArray
*
aArray
const
nsCUPSShim
&
aShim
nsString
aDisplayName
cups_dest_t
*
aPrinter
)
:
nsPrinterBase
(
aArray
)
mShim
(
aShim
)
mDisplayName
(
std
:
:
move
(
aDisplayName
)
)
mPrinter
(
aPrinter
)
mPrinterInfoMutex
(
"
nsPrinterCUPS
:
:
mPrinterInfoMutex
"
)
{
}
static
void
ForEachExtraMonochromeSetting
(
mozilla
:
:
FunctionRef
<
void
(
const
nsACString
&
const
nsACString
&
)
>
)
;
inline
const
char
*
FindCUPSOption
(
const
char
*
name
)
const
{
return
mShim
.
cupsGetOption
(
name
mPrinter
-
>
num_options
mPrinter
-
>
options
)
;
}
private
:
struct
CUPSPrinterInfo
{
cups_dinfo_t
*
mPrinterInfo
=
nullptr
;
uint64_t
mCUPSMajor
=
0
;
uint64_t
mCUPSMinor
=
0
;
uint64_t
mCUPSPatch
=
0
;
bool
mTriedInitWithDefault
=
false
;
bool
mTriedInitWithConnection
=
false
;
CUPSPrinterInfo
(
)
=
default
;
CUPSPrinterInfo
(
const
CUPSPrinterInfo
&
)
=
delete
;
CUPSPrinterInfo
(
CUPSPrinterInfo
&
&
)
=
delete
;
}
;
using
PrinterInfoMutex
=
mozilla
:
:
DataMutexBase
<
CUPSPrinterInfo
mozilla
:
:
RecursiveMutex
>
;
using
PrinterInfoLock
=
PrinterInfoMutex
:
:
AutoLock
;
~
nsPrinterCUPS
(
)
;
const
char
*
LocalizeMediaName
(
http_t
&
aConnection
cups_size_t
&
aMedia
)
const
;
void
GetPrinterName
(
nsAString
&
aName
)
const
;
bool
Supports
(
const
char
*
aOption
const
char
*
aValue
)
const
;
bool
IsCUPSVersionAtLeast
(
uint64_t
aCUPSMajor
uint64_t
aCUPSMinor
uint64_t
aCUPSPatch
)
const
;
class
Connection
{
public
:
http_t
*
GetConnection
(
cups_dest_t
*
aDest
)
;
inline
explicit
Connection
(
const
nsCUPSShim
&
aShim
)
:
mShim
(
aShim
)
{
}
Connection
(
)
=
delete
;
~
Connection
(
)
;
protected
:
const
nsCUPSShim
&
mShim
;
http_t
*
mConnection
=
CUPS_HTTP_DEFAULT
;
bool
mWasInited
=
false
;
}
;
PrintSettingsInitializer
DefaultSettings
(
Connection
&
aConnection
)
const
;
nsTArray
<
mozilla
:
:
PaperInfo
>
PaperList
(
Connection
&
aConnection
)
const
;
PrinterInfoLock
TryEnsurePrinterInfo
(
http_t
*
const
aConnection
=
CUPS_HTTP_DEFAULT
)
const
;
const
nsCUPSShim
&
mShim
;
nsString
mDisplayName
;
cups_dest_t
*
mPrinter
;
mutable
PrinterInfoMutex
mPrinterInfoMutex
;
}
;
#
define
CUPS_EACH_MONOCHROME_PRINTER_SETTING
(
macro_
)
\
macro_
(
"
ColorModel
"
"
Gray
"
)
/
*
Generic
*
/
\
macro_
(
"
BRMonoColor
"
"
Mono
"
)
/
*
Brother
*
/
\
macro_
(
"
BRPrintQuality
"
"
Black
"
)
/
*
Brother
*
/
\
macro_
(
"
CNIJGrayScale
"
"
1
"
)
/
*
Canon
*
/
\
macro_
(
"
INK
"
"
MONO
"
)
/
*
Epson
*
/
\
macro_
(
"
HPColorMode
"
"
GrayscalePrint
"
)
/
*
HP
*
/
\
macro_
(
"
ColorMode
"
"
Mono
"
)
/
*
Samsung
*
/
\
macro_
(
"
PrintoutMode
"
"
Normal
.
Gray
"
)
/
*
Foomatic
*
/
\
macro_
(
"
ProcessColorModel
"
"
Mono
"
)
/
*
Samsung
*
/
\
macro_
(
"
ARCMode
"
"
CMBW
"
)
/
*
Sharp
*
/
\
macro_
(
"
XRXColor
"
"
BW
"
)
/
*
Xerox
*
/
\
macro_
(
"
XROutputColor
"
"
PrintAsGrayscale
"
)
/
*
Xerox
bug
1676191
#
c32
*
/
\
macro_
(
"
SelectColor
"
"
Grayscale
"
)
/
*
Konica
Minolta
*
/
\
macro_
(
"
OKControl
"
"
Gray
"
)
/
*
Oki
*
/
\
macro_
(
"
BLW
"
"
TrueM
"
)
/
*
Lexmark
*
/
\
macro_
(
"
EPRendering
"
"
None
"
)
/
*
Epson
*
/
#
endif
