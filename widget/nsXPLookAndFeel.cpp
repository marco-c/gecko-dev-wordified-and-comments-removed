#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsXPLookAndFeel
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
HeadlessLookAndFeel
.
h
"
#
include
"
RemoteLookAndFeel
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
Theme
.
h
"
#
include
"
SurfaceCacheUtils
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_editor
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
PreferenceSheet
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
widget
/
WidgetMessageUtils
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
RelativeLuminanceUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryScalarEnums
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
qcms
.
h
"
#
include
<
bitset
>
using
namespace
mozilla
;
using
IntID
=
mozilla
:
:
LookAndFeel
:
:
IntID
;
using
FloatID
=
mozilla
:
:
LookAndFeel
:
:
FloatID
;
using
ColorID
=
mozilla
:
:
LookAndFeel
:
:
ColorID
;
using
FontID
=
mozilla
:
:
LookAndFeel
:
:
FontID
;
template
<
typename
Index
typename
Value
Index
kEnd
>
class
EnumeratedCache
{
mozilla
:
:
EnumeratedArray
<
Index
Value
size_t
(
kEnd
)
>
mEntries
;
std
:
:
bitset
<
size_t
(
kEnd
)
>
mValidity
;
public
:
constexpr
EnumeratedCache
(
)
=
default
;
bool
IsValid
(
Index
aIndex
)
const
{
return
mValidity
[
size_t
(
aIndex
)
]
;
}
const
Value
*
Get
(
Index
aIndex
)
const
{
return
IsValid
(
aIndex
)
?
&
mEntries
[
aIndex
]
:
nullptr
;
}
void
Insert
(
Index
aIndex
Value
aValue
)
{
mValidity
[
size_t
(
aIndex
)
]
=
true
;
mEntries
[
aIndex
]
=
aValue
;
}
void
Remove
(
Index
aIndex
)
{
mValidity
[
size_t
(
aIndex
)
]
=
false
;
mEntries
[
aIndex
]
=
Value
(
)
;
}
void
Clear
(
)
{
mValidity
.
reset
(
)
;
for
(
auto
&
entry
:
mEntries
)
{
entry
=
Value
(
)
;
}
}
}
;
using
ColorCache
=
EnumeratedCache
<
ColorID
Maybe
<
nscolor
>
ColorID
:
:
End
>
;
struct
ColorCaches
{
using
UseStandins
=
LookAndFeel
:
:
UseStandins
;
ColorCache
mCaches
[
2
]
[
2
]
;
constexpr
ColorCaches
(
)
=
default
;
ColorCache
&
Get
(
ColorScheme
aScheme
UseStandins
aUseStandins
)
{
return
mCaches
[
aScheme
=
=
ColorScheme
:
:
Dark
]
[
aUseStandins
=
=
UseStandins
:
:
Yes
]
;
}
void
Clear
(
)
{
for
(
auto
&
c
:
mCaches
)
{
for
(
auto
&
cache
:
c
)
{
cache
.
Clear
(
)
;
}
}
}
}
;
static
ColorCaches
sColorCaches
;
static
EnumeratedCache
<
FloatID
Maybe
<
float
>
FloatID
:
:
End
>
sFloatCache
;
static
EnumeratedCache
<
IntID
Maybe
<
int32_t
>
IntID
:
:
End
>
sIntCache
;
static
EnumeratedCache
<
FontID
widget
:
:
LookAndFeelFont
FontID
:
:
End
>
sFontCache
;
static
const
char
sIntPrefs
[
]
[
45
]
=
{
"
ui
.
caretBlinkTime
"
"
ui
.
caretBlinkCount
"
"
ui
.
caretWidth
"
"
ui
.
selectTextfieldsOnKeyFocus
"
"
ui
.
submenuDelay
"
"
ui
.
menusCanOverlapOSBar
"
"
ui
.
useOverlayScrollbars
"
"
ui
.
allowOverlayScrollbarsOverlap
"
"
ui
.
skipNavigatingDisabledMenuItem
"
"
ui
.
dragThresholdX
"
"
ui
.
dragThresholdY
"
"
ui
.
useAccessibilityTheme
"
"
ui
.
scrollArrowStyle
"
"
ui
.
scrollButtonLeftMouseButtonAction
"
"
ui
.
scrollButtonMiddleMouseButtonAction
"
"
ui
.
scrollButtonRightMouseButtonAction
"
"
ui
.
treeOpenDelay
"
"
ui
.
treeCloseDelay
"
"
ui
.
treeLazyScrollDelay
"
"
ui
.
treeScrollDelay
"
"
ui
.
treeScrollLinesMax
"
"
ui
.
chosenMenuItemsShouldBlink
"
"
ui
.
windowsAccentColorInTitlebar
"
"
ui
.
macBigSurTheme
"
"
ui
.
macRTL
"
"
ui
.
macTitlebarHeight
"
"
ui
.
alertNotificationOrigin
"
"
ui
.
scrollToClick
"
"
ui
.
IMERawInputUnderlineStyle
"
"
ui
.
IMESelectedRawTextUnderlineStyle
"
"
ui
.
IMEConvertedTextUnderlineStyle
"
"
ui
.
IMESelectedConvertedTextUnderlineStyle
"
"
ui
.
SpellCheckerUnderlineStyle
"
"
ui
.
menuBarDrag
"
"
ui
.
scrollbarButtonAutoRepeatBehavior
"
"
ui
.
swipeAnimationEnabled
"
"
ui
.
scrollbarDisplayOnMouseMove
"
"
ui
.
scrollbarFadeBeginDelay
"
"
ui
.
scrollbarFadeDuration
"
"
ui
.
contextMenuOffsetVertical
"
"
ui
.
contextMenuOffsetHorizontal
"
"
ui
.
tooltipOffsetVertical
"
"
ui
.
GtkCSDAvailable
"
"
ui
.
GtkCSDMinimizeButton
"
"
ui
.
GtkCSDMaximizeButton
"
"
ui
.
GtkCSDCloseButton
"
"
ui
.
GtkCSDMinimizeButtonPosition
"
"
ui
.
GtkCSDMaximizeButtonPosition
"
"
ui
.
GtkCSDCloseButtonPosition
"
"
ui
.
GtkCSDReversedPlacement
"
"
ui
.
systemUsesDarkTheme
"
"
ui
.
prefersReducedMotion
"
"
ui
.
prefersReducedTransparency
"
"
ui
.
invertedColors
"
"
ui
.
primaryPointerCapabilities
"
"
ui
.
allPointerCapabilities
"
"
ui
.
systemScrollbarSize
"
"
ui
.
touchDeviceSupportPresent
"
"
ui
.
titlebarRadius
"
"
ui
.
titlebarButtonSpacing
"
"
ui
.
dynamicRange
"
"
ui
.
panelAnimations
"
"
ui
.
hideCursorWhileTyping
"
"
ui
.
gtkThemeFamily
"
"
ui
.
fullKeyboardAccess
"
}
;
static_assert
(
ArrayLength
(
sIntPrefs
)
=
=
size_t
(
LookAndFeel
:
:
IntID
:
:
End
)
"
Should
have
a
pref
for
each
int
value
"
)
;
static
const
char
sFloatPrefs
[
]
[
37
]
=
{
"
ui
.
IMEUnderlineRelativeSize
"
"
ui
.
SpellCheckerUnderlineRelativeSize
"
"
ui
.
caretAspectRatio
"
"
ui
.
textScaleFactor
"
"
ui
.
cursorScale
"
}
;
static_assert
(
ArrayLength
(
sFloatPrefs
)
=
=
size_t
(
LookAndFeel
:
:
FloatID
:
:
End
)
"
Should
have
a
pref
for
each
float
value
"
)
;
static
const
char
sColorPrefs
[
]
[
41
]
=
{
"
ui
.
activeborder
"
"
ui
.
activecaption
"
"
ui
.
appworkspace
"
"
ui
.
background
"
"
ui
.
buttonface
"
"
ui
.
buttonhighlight
"
"
ui
.
buttonshadow
"
"
ui
.
buttontext
"
"
ui
.
buttonborder
"
"
ui
.
captiontext
"
"
ui
.
-
moz
-
field
"
"
ui
.
-
moz
-
disabledfield
"
"
ui
.
-
moz
-
fieldtext
"
"
ui
.
mark
"
"
ui
.
marktext
"
"
ui
.
-
moz
-
comboboxtext
"
"
ui
.
-
moz
-
combobox
"
"
ui
.
graytext
"
"
ui
.
highlight
"
"
ui
.
highlighttext
"
"
ui
.
inactiveborder
"
"
ui
.
inactivecaption
"
"
ui
.
inactivecaptiontext
"
"
ui
.
infobackground
"
"
ui
.
infotext
"
"
ui
.
menu
"
"
ui
.
menutext
"
"
ui
.
scrollbar
"
"
ui
.
threeddarkshadow
"
"
ui
.
threedface
"
"
ui
.
threedhighlight
"
"
ui
.
threedlightshadow
"
"
ui
.
threedshadow
"
"
ui
.
window
"
"
ui
.
windowframe
"
"
ui
.
windowtext
"
"
ui
.
-
moz
-
default
-
color
"
"
ui
.
-
moz
-
default
-
background
-
color
"
"
ui
.
-
moz
-
dialog
"
"
ui
.
-
moz
-
dialogtext
"
"
ui
.
-
moz
-
cellhighlight
"
"
ui
.
-
moz_cellhighlighttext
"
"
ui
.
selecteditem
"
"
ui
.
selecteditemtext
"
"
ui
.
-
moz
-
buttonhoverface
"
"
ui
.
-
moz_buttonhovertext
"
"
ui
.
-
moz_menuhover
"
"
ui
.
-
moz_menuhoverdisabled
"
"
ui
.
-
moz_menuhovertext
"
"
ui
.
-
moz_menubarhovertext
"
"
ui
.
-
moz_eventreerow
"
"
ui
.
-
moz_oddtreerow
"
"
ui
.
-
moz
-
buttonactivetext
"
"
ui
.
-
moz
-
buttonactiveface
"
"
ui
.
-
moz
-
buttondisabledface
"
"
ui
.
-
moz
-
headerbar
"
"
ui
.
-
moz
-
headerbartext
"
"
ui
.
-
moz
-
headerbarinactive
"
"
ui
.
-
moz
-
headerbarinactivetext
"
"
ui
.
-
moz
-
mac
-
defaultbuttontext
"
"
ui
.
-
moz
-
mac
-
focusring
"
"
ui
.
-
moz_mac_disabledtoolbartext
"
"
ui
.
-
moz
-
sidebar
"
"
ui
.
-
moz
-
sidebartext
"
"
ui
.
-
moz
-
sidebarborder
"
"
ui
.
accentcolor
"
"
ui
.
accentcolortext
"
"
ui
.
-
moz
-
autofill
-
background
"
"
ui
.
-
moz
-
nativehyperlinktext
"
"
ui
.
-
moz
-
nativevisitedhyperlinktext
"
"
ui
.
-
moz
-
hyperlinktext
"
"
ui
.
-
moz
-
activehyperlinktext
"
"
ui
.
-
moz
-
visitedhyperlinktext
"
"
ui
.
-
moz
-
colheader
"
"
ui
.
-
moz
-
colheadertext
"
"
ui
.
-
moz
-
colheaderhover
"
"
ui
.
-
moz
-
colheaderhovertext
"
"
ui
.
-
moz
-
colheaderactive
"
"
ui
.
-
moz
-
colheaderactivetext
"
"
ui
.
textSelectDisabledBackground
"
"
ui
.
textSelectAttentionBackground
"
"
ui
.
textSelectAttentionForeground
"
"
ui
.
textHighlightBackground
"
"
ui
.
textHighlightForeground
"
"
ui
.
targetTextBackground
"
"
ui
.
targetTextForeground
"
"
ui
.
IMERawInputBackground
"
"
ui
.
IMERawInputForeground
"
"
ui
.
IMERawInputUnderline
"
"
ui
.
IMESelectedRawTextBackground
"
"
ui
.
IMESelectedRawTextForeground
"
"
ui
.
IMESelectedRawTextUnderline
"
"
ui
.
IMEConvertedTextBackground
"
"
ui
.
IMEConvertedTextForeground
"
"
ui
.
IMEConvertedTextUnderline
"
"
ui
.
IMESelectedConvertedTextBackground
"
"
ui
.
IMESelectedConvertedTextForeground
"
"
ui
.
IMESelectedConvertedTextUnderline
"
"
ui
.
SpellCheckerUnderline
"
"
ui
.
themedScrollbar
"
"
ui
.
themedScrollbarInactive
"
"
ui
.
themedScrollbarThumb
"
"
ui
.
themedScrollbarThumbHover
"
"
ui
.
themedScrollbarThumbActive
"
"
ui
.
themedScrollbarThumbInactive
"
}
;
static_assert
(
ArrayLength
(
sColorPrefs
)
=
=
size_t
(
LookAndFeel
:
:
ColorID
:
:
End
)
"
Should
have
a
pref
for
each
color
value
"
)
;
static
const
char
sFontPrefs
[
]
[
41
]
=
{
"
ui
.
font
.
caption
"
"
ui
.
font
.
icon
"
"
ui
.
font
.
menu
"
"
ui
.
font
.
message
-
box
"
"
ui
.
font
.
small
-
caption
"
"
ui
.
font
.
status
-
bar
"
"
ui
.
font
.
-
moz
-
pull
-
down
-
menu
"
"
ui
.
font
.
-
moz
-
button
"
"
ui
.
font
.
-
moz
-
list
"
"
ui
.
font
.
-
moz
-
field
"
}
;
static_assert
(
ArrayLength
(
sFontPrefs
)
=
=
size_t
(
LookAndFeel
:
:
FontID
:
:
End
)
"
Should
have
a
pref
for
each
font
value
"
)
;
const
char
*
nsXPLookAndFeel
:
:
GetColorPrefName
(
ColorID
aId
)
{
return
sColorPrefs
[
size_t
(
aId
)
]
;
}
bool
nsXPLookAndFeel
:
:
sInitialized
=
false
;
nsXPLookAndFeel
*
nsXPLookAndFeel
:
:
sInstance
=
nullptr
;
bool
nsXPLookAndFeel
:
:
sShutdown
=
false
;
auto
LookAndFeel
:
:
SystemZoomSettings
(
)
-
>
ZoomSettings
{
ZoomSettings
settings
;
switch
(
StaticPrefs
:
:
browser_display_os_zoom_behavior
(
)
)
{
case
0
:
default
:
break
;
case
1
:
settings
.
mFullZoom
=
GetTextScaleFactor
(
)
;
break
;
case
2
:
settings
.
mTextZoom
=
GetTextScaleFactor
(
)
;
break
;
}
return
settings
;
}
nsXPLookAndFeel
*
nsXPLookAndFeel
:
:
GetInstance
(
)
{
if
(
sInstance
)
{
return
sInstance
;
}
NS_ENSURE_TRUE
(
!
sShutdown
nullptr
)
;
FullLookAndFeel
*
lnf
=
nullptr
;
if
(
auto
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
)
{
lnf
=
&
cc
-
>
BorrowLookAndFeelData
(
)
;
}
if
(
lnf
)
{
sInstance
=
new
widget
:
:
RemoteLookAndFeel
(
std
:
:
move
(
*
lnf
)
)
;
}
else
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
sInstance
=
new
widget
:
:
HeadlessLookAndFeel
(
)
;
}
else
{
sInstance
=
new
nsLookAndFeel
(
)
;
}
if
(
lnf
)
{
*
lnf
=
{
}
;
}
widget
:
:
Theme
:
:
Init
(
)
;
return
sInstance
;
}
void
nsXPLookAndFeel
:
:
Shutdown
(
)
{
if
(
sShutdown
)
{
return
;
}
sShutdown
=
true
;
delete
sInstance
;
sInstance
=
nullptr
;
sFontCache
.
Clear
(
)
;
widget
:
:
Theme
:
:
Shutdown
(
)
;
}
static
void
IntPrefChanged
(
const
nsACString
&
aPref
)
{
auto
changeKind
=
aPref
.
EqualsLiteral
(
"
ui
.
systemUsesDarkTheme
"
)
?
widget
:
:
ThemeChangeKind
:
:
Style
:
widget
:
:
ThemeChangeKind
:
:
MediaQueriesOnly
;
LookAndFeel
:
:
NotifyChangedAllWindows
(
changeKind
)
;
}
static
void
FloatPrefChanged
(
const
nsACString
&
aPref
)
{
auto
changeKind
=
aPref
.
EqualsLiteral
(
"
ui
.
textScaleFactor
"
)
?
widget
:
:
ThemeChangeKind
:
:
StyleAndLayout
:
widget
:
:
ThemeChangeKind
:
:
MediaQueriesOnly
;
LookAndFeel
:
:
NotifyChangedAllWindows
(
changeKind
)
;
}
static
void
ColorPrefChanged
(
)
{
LookAndFeel
:
:
NotifyChangedAllWindows
(
widget
:
:
ThemeChangeKind
:
:
Style
)
;
}
static
void
FontPrefChanged
(
)
{
LookAndFeel
:
:
NotifyChangedAllWindows
(
widget
:
:
ThemeChangeKind
:
:
Style
)
;
}
void
nsXPLookAndFeel
:
:
OnPrefChanged
(
const
char
*
aPref
void
*
aClosure
)
{
nsDependentCString
prefName
(
aPref
)
;
for
(
const
char
*
pref
:
sIntPrefs
)
{
if
(
prefName
.
Equals
(
pref
)
)
{
IntPrefChanged
(
prefName
)
;
return
;
}
}
for
(
const
char
*
pref
:
sFloatPrefs
)
{
if
(
prefName
.
Equals
(
pref
)
)
{
FloatPrefChanged
(
prefName
)
;
return
;
}
}
for
(
const
char
*
pref
:
sColorPrefs
)
{
if
(
StringBeginsWith
(
prefName
nsDependentCString
(
pref
)
)
)
{
ColorPrefChanged
(
)
;
return
;
}
}
for
(
const
char
*
pref
:
sFontPrefs
)
{
if
(
StringBeginsWith
(
prefName
nsDependentCString
(
pref
)
)
)
{
FontPrefChanged
(
)
;
return
;
}
}
}
static
constexpr
struct
{
nsLiteralCString
mName
;
widget
:
:
ThemeChangeKind
mChangeKind
=
widget
:
:
ThemeChangeKind
:
:
MediaQueriesOnly
;
}
kMediaQueryPrefs
[
]
=
{
{
"
widget
.
non
-
native
-
theme
.
use
-
theme
-
accent
"
_ns
widget
:
:
ThemeChangeKind
:
:
Style
}
{
"
widget
.
windows
.
uwp
-
system
-
colors
.
enabled
"
_ns
widget
:
:
ThemeChangeKind
:
:
Style
}
{
"
widget
.
windows
.
uwp
-
system
-
colors
.
highlight
-
accent
"
_ns
widget
:
:
ThemeChangeKind
:
:
Style
}
{
"
layout
.
css
.
prefers
-
color
-
scheme
.
content
-
override
"
_ns
widget
:
:
ThemeChangeKind
:
:
Style
}
{
"
widget
.
gtk
.
overlay
-
scrollbars
.
enabled
"
_ns
widget
:
:
ThemeChangeKind
:
:
StyleAndLayout
}
{
"
browser
.
display
.
os
-
zoom
-
behavior
"
_ns
widget
:
:
ThemeChangeKind
:
:
StyleAndLayout
}
{
"
widget
.
gtk
.
libadwaita
-
colors
.
enabled
"
_ns
widget
:
:
ThemeChangeKind
:
:
Style
}
{
"
browser
.
theme
.
toolbar
-
theme
"
_ns
widget
:
:
ThemeChangeKind
:
:
AllBits
}
{
"
browser
.
theme
.
content
-
theme
"
_ns
}
}
;
void
nsXPLookAndFeel
:
:
Init
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
sInitialized
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
nsLayoutUtils
:
:
RecomputeSmoothScrollDefault
(
)
;
}
Preferences
:
:
RegisterPrefixCallback
(
OnPrefChanged
"
ui
.
"
)
;
for
(
const
auto
&
pref
:
kMediaQueryPrefs
)
{
Preferences
:
:
RegisterCallback
(
[
]
(
const
char
*
void
*
aChangeKind
)
{
auto
changeKind
=
widget
:
:
ThemeChangeKind
(
reinterpret_cast
<
uintptr_t
>
(
aChangeKind
)
)
;
LookAndFeel
:
:
NotifyChangedAllWindows
(
changeKind
)
;
}
pref
.
mName
reinterpret_cast
<
void
*
>
(
uintptr_t
(
pref
.
mChangeKind
)
)
)
;
}
}
nsXPLookAndFeel
:
:
~
nsXPLookAndFeel
(
)
{
NS_ASSERTION
(
sInstance
=
=
this
"
This
destroying
instance
isn
'
t
the
singleton
instance
"
)
;
sInstance
=
nullptr
;
}
static
bool
IsSpecialColor
(
LookAndFeel
:
:
ColorID
aID
nscolor
aColor
)
{
using
ColorID
=
LookAndFeel
:
:
ColorID
;
if
(
aColor
=
=
NS_SAME_AS_FOREGROUND_COLOR
)
{
return
true
;
}
switch
(
aID
)
{
case
ColorID
:
:
IMESelectedRawTextBackground
:
case
ColorID
:
:
IMESelectedConvertedTextBackground
:
case
ColorID
:
:
IMERawInputBackground
:
case
ColorID
:
:
IMEConvertedTextBackground
:
case
ColorID
:
:
IMESelectedRawTextForeground
:
case
ColorID
:
:
IMESelectedConvertedTextForeground
:
case
ColorID
:
:
IMERawInputForeground
:
case
ColorID
:
:
IMEConvertedTextForeground
:
case
ColorID
:
:
IMERawInputUnderline
:
case
ColorID
:
:
IMEConvertedTextUnderline
:
case
ColorID
:
:
IMESelectedRawTextUnderline
:
case
ColorID
:
:
IMESelectedConvertedTextUnderline
:
case
ColorID
:
:
SpellCheckerUnderline
:
return
NS_IS_SELECTION_SPECIAL_COLOR
(
aColor
)
;
default
:
break
;
}
return
false
;
}
nscolor
nsXPLookAndFeel
:
:
GetStandinForNativeColor
(
ColorID
aID
ColorScheme
aScheme
)
{
if
(
aScheme
=
=
ColorScheme
:
:
Dark
)
{
if
(
auto
color
=
GenericDarkColor
(
aID
)
)
{
return
*
color
;
}
}
#
define
COLOR
(
name_
r
g
b
)
\
case
ColorID
:
:
name_
:
\
return
NS_RGB
(
r
g
b
)
;
#
define
COLORA
(
name_
r
g
b
a
)
\
case
ColorID
:
:
name_
:
\
return
NS_RGBA
(
r
g
b
a
)
;
switch
(
aID
)
{
case
ColorID
:
:
IMESelectedRawTextBackground
:
case
ColorID
:
:
IMESelectedConvertedTextBackground
:
case
ColorID
:
:
IMERawInputBackground
:
case
ColorID
:
:
IMEConvertedTextBackground
:
return
NS_TRANSPARENT
;
case
ColorID
:
:
IMESelectedRawTextForeground
:
case
ColorID
:
:
IMESelectedConvertedTextForeground
:
case
ColorID
:
:
IMERawInputForeground
:
case
ColorID
:
:
IMEConvertedTextForeground
:
return
NS_SAME_AS_FOREGROUND_COLOR
;
case
ColorID
:
:
IMERawInputUnderline
:
case
ColorID
:
:
IMEConvertedTextUnderline
:
return
NS_40PERCENT_FOREGROUND_COLOR
;
case
ColorID
:
:
Accentcolor
:
return
widget
:
:
sDefaultAccent
.
ToABGR
(
)
;
case
ColorID
:
:
Accentcolortext
:
return
widget
:
:
sDefaultAccentText
.
ToABGR
(
)
;
COLOR
(
SpellCheckerUnderline
0xff
0x00
0x00
)
COLOR
(
TextSelectDisabledBackground
0xAA
0xAA
0xAA
)
COLOR
(
Activeborder
0xE3
0xE3
0xE3
)
COLOR
(
Inactiveborder
0xE3
0xE3
0xE3
)
COLOR
(
Activecaption
0xFF
0xFF
0xFF
)
COLOR
(
Inactivecaption
0xFF
0xFF
0xFF
)
COLOR
(
Captiontext
0x00
0x00
0x00
)
COLOR
(
Inactivecaptiontext
0x6D
0x6D
0x6D
)
COLOR
(
Appworkspace
0xFF
0xFF
0xFF
)
COLOR
(
Background
0xFF
0xFF
0xFF
)
COLOR
(
Buttonhighlight
0xE9
0xE9
0xED
)
COLOR
(
Buttonshadow
0xE9
0xE9
0xED
)
COLOR
(
Buttonface
0xE9
0xE9
0xED
)
COLORA
(
MozButtondisabledface
0xE9
0xE9
0xED
128
)
COLOR
(
MozCombobox
0xE9
0xE9
0xED
)
COLOR
(
Buttontext
0x00
0x00
0x00
)
COLOR
(
MozComboboxtext
0x00
0x00
0x00
)
COLOR
(
Graytext
0x6D
0x6D
0x6D
)
COLOR
(
Highlight
0x33
0x99
0xFF
)
COLOR
(
Highlighttext
0xFF
0xFF
0xFF
)
COLOR
(
Infobackground
0xFF
0xFF
0xFF
)
COLOR
(
Infotext
0x00
0x00
0x00
)
COLOR
(
Menu
0xFF
0xFF
0xFF
)
COLOR
(
Menutext
0x00
0x00
0x00
)
COLOR
(
Scrollbar
0xFF
0xFF
0xFF
)
COLOR
(
Threeddarkshadow
0xE3
0xE3
0xE3
)
COLOR
(
Threedface
0xE9
0xE9
0xED
)
COLOR
(
Threedhighlight
0xE3
0xE3
0xE3
)
COLOR
(
Threedlightshadow
0xE3
0xE3
0xE3
)
COLOR
(
Threedshadow
0xE3
0xE3
0xE3
)
COLOR
(
Buttonborder
0xE3
0xE3
0xE3
)
COLOR
(
Mark
0xFF
0xFF
0x00
)
COLOR
(
Marktext
0x00
0x00
0x00
)
COLOR
(
Window
0xFF
0xFF
0xFF
)
COLOR
(
Windowframe
0xE3
0xE3
0xE3
)
COLOR
(
Windowtext
0x00
0x00
0x00
)
COLOR
(
Field
0xFF
0xFF
0xFF
)
COLORA
(
MozDisabledfield
0xFF
0xFF
0xFF
128
)
COLOR
(
Fieldtext
0x00
0x00
0x00
)
COLOR
(
MozDialog
0xF0
0xF0
0xF0
)
COLOR
(
MozDialogtext
0x00
0x00
0x00
)
COLOR
(
MozColheadertext
0x00
0x00
0x00
)
COLOR
(
MozColheaderhovertext
0x00
0x00
0x00
)
COLOR
(
MozCellhighlight
0xF0
0xF0
0xF0
)
COLOR
(
MozCellhighlighttext
0x00
0x00
0x00
)
COLOR
(
Selecteditem
0x33
0x99
0xFF
)
COLOR
(
Selecteditemtext
0xFF
0xFF
0xFF
)
COLOR
(
MozButtonhoverface
0xd0
0xd0
0xd7
)
COLOR
(
MozButtonhovertext
0x00
0x00
0x00
)
COLOR
(
MozButtonactiveface
0xb1
0xb1
0xb9
)
COLOR
(
MozButtonactivetext
0x00
0x00
0x00
)
COLOR
(
MozMenuhover
0x33
0x99
0xFF
)
COLOR
(
MozMenuhovertext
0x00
0x00
0x00
)
COLOR
(
MozMenubarhovertext
0x00
0x00
0x00
)
COLOR
(
MozMenuhoverdisabled
0xF0
0xF0
0xF0
)
COLOR
(
MozEventreerow
0xFF
0xFF
0xFF
)
COLOR
(
MozOddtreerow
0xFF
0xFF
0xFF
)
COLOR
(
MozMacFocusring
0x60
0x9D
0xD7
)
COLOR
(
MozMacDisabledtoolbartext
0x3F
0x3F
0x3F
)
COLOR
(
MozNativehyperlinktext
0x00
0x66
0xCC
)
COLOR
(
MozNativevisitedhyperlinktext
0x55
0x1A
0x8B
)
COLOR
(
MozAutofillBackground
0xff
0xfc
0xc8
)
COLOR
(
TargetTextBackground
0xff
0xeb
0xcd
)
COLOR
(
TargetTextForeground
0x00
0x00
0x00
)
default
:
break
;
}
return
NS_RGB
(
0xFF
0xFF
0xFF
)
;
}
#
undef
COLOR
#
undef
COLORA
Maybe
<
nscolor
>
nsXPLookAndFeel
:
:
GenericDarkColor
(
ColorID
aID
)
{
nscolor
color
=
NS_RGB
(
0
0
0
)
;
static
constexpr
nscolor
kWindowBackground
=
NS_RGB
(
28
27
34
)
;
static
constexpr
nscolor
kWindowText
=
NS_RGB
(
251
251
254
)
;
switch
(
aID
)
{
case
ColorID
:
:
Window
:
case
ColorID
:
:
Background
:
case
ColorID
:
:
Appworkspace
:
case
ColorID
:
:
Scrollbar
:
case
ColorID
:
:
Infobackground
:
color
=
kWindowBackground
;
break
;
case
ColorID
:
:
Menu
:
color
=
NS_RGB
(
0x2b
0x2a
0x33
)
;
break
;
case
ColorID
:
:
MozMenuhovertext
:
case
ColorID
:
:
MozMenubarhovertext
:
case
ColorID
:
:
Menutext
:
color
=
NS_RGB
(
0xfb
0xfb
0xfe
)
;
break
;
case
ColorID
:
:
MozMenuhover
:
color
=
NS_RGB
(
0x52
0x52
0x5e
)
;
break
;
case
ColorID
:
:
MozMenuhoverdisabled
:
color
=
NS_RGB
(
0x3a
0x39
0x44
)
;
break
;
case
ColorID
:
:
MozEventreerow
:
case
ColorID
:
:
MozOddtreerow
:
case
ColorID
:
:
MozDialog
:
color
=
NS_RGB
(
35
34
43
)
;
break
;
case
ColorID
:
:
Windowtext
:
case
ColorID
:
:
MozDialogtext
:
case
ColorID
:
:
MozSidebartext
:
case
ColorID
:
:
Fieldtext
:
case
ColorID
:
:
Infotext
:
case
ColorID
:
:
Buttontext
:
case
ColorID
:
:
MozComboboxtext
:
case
ColorID
:
:
MozButtonhovertext
:
case
ColorID
:
:
MozButtonactivetext
:
case
ColorID
:
:
MozHeaderbartext
:
case
ColorID
:
:
MozHeaderbarinactivetext
:
case
ColorID
:
:
Captiontext
:
case
ColorID
:
:
Inactivecaptiontext
:
case
ColorID
:
:
MozColheadertext
:
case
ColorID
:
:
MozColheaderhovertext
:
case
ColorID
:
:
MozColheaderactivetext
:
color
=
kWindowText
;
break
;
case
ColorID
:
:
Buttonshadow
:
case
ColorID
:
:
Threedshadow
:
case
ColorID
:
:
MozSidebarborder
:
case
ColorID
:
:
Threedlightshadow
:
case
ColorID
:
:
Threedhighlight
:
case
ColorID
:
:
Windowframe
:
case
ColorID
:
:
Buttonborder
:
case
ColorID
:
:
Graytext
:
color
=
NS_ComposeColors
(
kWindowBackground
NS_RGBA
(
251
251
254
102
)
)
;
break
;
case
ColorID
:
:
MozCellhighlight
:
case
ColorID
:
:
Selecteditem
:
color
=
NS_RGB
(
0
221
255
)
;
break
;
case
ColorID
:
:
MozSidebar
:
case
ColorID
:
:
Field
:
case
ColorID
:
:
Buttonface
:
case
ColorID
:
:
Buttonhighlight
:
case
ColorID
:
:
MozColheader
:
case
ColorID
:
:
Threedface
:
case
ColorID
:
:
MozCombobox
:
case
ColorID
:
:
MozCellhighlighttext
:
case
ColorID
:
:
Selecteditemtext
:
color
=
NS_RGB
(
43
42
51
)
;
break
;
case
ColorID
:
:
Threeddarkshadow
:
case
ColorID
:
:
MozDisabledfield
:
case
ColorID
:
:
MozButtondisabledface
:
color
=
NS_ComposeColors
(
kWindowBackground
NS_RGBA
(
43
42
51
102
)
)
;
break
;
case
ColorID
:
:
MozButtonhoverface
:
case
ColorID
:
:
MozColheaderhover
:
color
=
NS_RGB
(
82
82
94
)
;
break
;
case
ColorID
:
:
MozButtonactiveface
:
case
ColorID
:
:
MozColheaderactive
:
color
=
NS_RGB
(
91
91
102
)
;
break
;
case
ColorID
:
:
Highlight
:
color
=
NS_RGBA
(
0
221
255
78
)
;
break
;
case
ColorID
:
:
Highlighttext
:
color
=
NS_SAME_AS_FOREGROUND_COLOR
;
break
;
case
ColorID
:
:
MozNativehyperlinktext
:
color
=
NS_RGB
(
0x8c
0x8c
0xff
)
;
break
;
case
ColorID
:
:
MozNativevisitedhyperlinktext
:
color
=
NS_RGB
(
0xff
0xad
0xff
)
;
break
;
case
ColorID
:
:
SpellCheckerUnderline
:
color
=
NS_RGB
(
0xff
0x66
0x66
)
;
break
;
case
ColorID
:
:
Activeborder
:
case
ColorID
:
:
Inactiveborder
:
color
=
NS_RGB
(
57
57
57
)
;
break
;
case
ColorID
:
:
MozHeaderbar
:
case
ColorID
:
:
MozHeaderbarinactive
:
case
ColorID
:
:
Activecaption
:
case
ColorID
:
:
Inactivecaption
:
color
=
NS_RGB
(
28
27
34
)
;
break
;
case
ColorID
:
:
MozAutofillBackground
:
color
=
NS_RGB
(
0x72
0x6c
0x00
)
;
break
;
default
:
return
Nothing
(
)
;
}
return
Some
(
color
)
;
}
#
ifdef
DEBUG_SYSTEM_COLOR_USE
static
nsresult
SystemColorUseDebuggingColor
(
LookAndFeel
:
:
ColorID
aID
nscolor
&
aResult
)
{
using
ColorID
=
LookAndFeel
:
:
ColorID
;
switch
(
aID
)
{
case
ColorID
:
:
Activecaption
:
case
ColorID
:
:
Captiontext
:
aResult
=
NS_RGB
(
0xff
0x00
0x00
)
;
break
;
case
ColorID
:
:
Highlight
:
case
ColorID
:
:
Highlighttext
:
aResult
=
NS_RGB
(
0xff
0xff
0x00
)
;
break
;
case
ColorID
:
:
Inactivecaption
:
case
ColorID
:
:
Inactivecaptiontext
:
aResult
=
NS_RGB
(
0x66
0x66
0x00
)
;
break
;
case
ColorID
:
:
Infobackground
:
case
ColorID
:
:
Infotext
:
aResult
=
NS_RGB
(
0x00
0xff
0x00
)
;
break
;
case
ColorID
:
:
Menu
:
case
ColorID
:
:
Menutext
:
aResult
=
NS_RGB
(
0x00
0xff
0xff
)
;
break
;
case
ColorID
:
:
Threedface
:
case
ColorID
:
:
Buttonface
:
case
ColorID
:
:
Buttontext
:
aResult
=
NS_RGB
(
0x00
0x66
0x66
)
;
break
;
case
ColorID
:
:
Window
:
case
ColorID
:
:
Windowtext
:
aResult
=
NS_RGB
(
0x00
0x00
0xff
)
;
break
;
case
ColorID
:
:
Field
:
case
ColorID
:
:
Fieldtext
:
aResult
=
NS_RGB
(
0xff
0x00
0xff
)
;
break
;
case
ColorID
:
:
MozDialog
:
case
ColorID
:
:
MozDialogtext
:
aResult
=
NS_RGB
(
0x66
0x00
0x66
)
;
break
;
default
:
return
NS_ERROR_NOT_AVAILABLE
;
}
return
NS_OK
;
}
#
endif
static
nsresult
GetPrefColor
(
const
char
*
aPref
nscolor
&
aResult
)
{
nsAutoCString
colorStr
;
MOZ_TRY
(
Preferences
:
:
GetCString
(
aPref
colorStr
)
)
;
if
(
!
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
colorStr
&
aResult
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
nsresult
GetColorFromPref
(
LookAndFeel
:
:
ColorID
aID
ColorScheme
aScheme
nscolor
&
aResult
)
{
const
char
*
prefName
=
sColorPrefs
[
size_t
(
aID
)
]
;
if
(
aScheme
=
=
ColorScheme
:
:
Dark
)
{
nsAutoCString
darkPrefName
(
prefName
)
;
darkPrefName
.
Append
(
"
.
dark
"
)
;
if
(
NS_SUCCEEDED
(
GetPrefColor
(
darkPrefName
.
get
(
)
aResult
)
)
)
{
return
NS_OK
;
}
}
return
GetPrefColor
(
prefName
aResult
)
;
}
nsresult
nsXPLookAndFeel
:
:
GetColorValue
(
ColorID
aID
ColorScheme
aScheme
UseStandins
aUseStandins
nscolor
&
aResult
)
{
if
(
!
sInitialized
)
{
Init
(
)
;
}
#
ifdef
DEBUG_SYSTEM_COLOR_USE
if
(
NS_SUCCEEDED
(
SystemColorUseDebuggingColor
(
aID
aResult
)
)
)
{
return
NS_OK
;
}
#
endif
auto
&
cache
=
sColorCaches
.
Get
(
aScheme
aUseStandins
)
;
if
(
const
auto
*
cached
=
cache
.
Get
(
aID
)
)
{
if
(
cached
-
>
isNothing
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aResult
=
cached
-
>
value
(
)
;
return
NS_OK
;
}
auto
result
=
GetUncachedColor
(
aID
aScheme
aUseStandins
)
;
cache
.
Insert
(
aID
result
)
;
if
(
!
result
)
{
return
NS_ERROR_FAILURE
;
}
aResult
=
*
result
;
return
NS_OK
;
}
Maybe
<
nscolor
>
nsXPLookAndFeel
:
:
GetUncachedColor
(
ColorID
aID
ColorScheme
aScheme
UseStandins
aUseStandins
)
{
if
(
aUseStandins
=
=
UseStandins
:
:
Yes
)
{
return
Some
(
GetStandinForNativeColor
(
aID
aScheme
)
)
;
}
nscolor
r
;
if
(
NS_SUCCEEDED
(
GetColorFromPref
(
aID
aScheme
r
)
)
)
{
return
Some
(
r
)
;
}
if
(
NS_SUCCEEDED
(
NativeGetColor
(
aID
aScheme
r
)
)
)
{
if
(
gfxPlatform
:
:
GetCMSMode
(
)
=
=
CMSMode
:
:
All
&
&
!
IsSpecialColor
(
aID
r
)
)
{
qcms_transform
*
transform
=
gfxPlatform
:
:
GetCMSInverseRGBTransform
(
)
;
if
(
transform
)
{
uint8_t
color
[
4
]
;
color
[
0
]
=
NS_GET_R
(
r
)
;
color
[
1
]
=
NS_GET_G
(
r
)
;
color
[
2
]
=
NS_GET_B
(
r
)
;
color
[
3
]
=
NS_GET_A
(
r
)
;
qcms_transform_data
(
transform
color
color
1
)
;
r
=
NS_RGBA
(
color
[
0
]
color
[
1
]
color
[
2
]
color
[
3
]
)
;
}
}
return
Some
(
r
)
;
}
return
Nothing
(
)
;
}
nsresult
nsXPLookAndFeel
:
:
GetIntValue
(
IntID
aID
int32_t
&
aResult
)
{
if
(
!
sInitialized
)
{
Init
(
)
;
}
if
(
const
auto
*
cached
=
sIntCache
.
Get
(
aID
)
)
{
if
(
cached
-
>
isNothing
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aResult
=
cached
-
>
value
(
)
;
return
NS_OK
;
}
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetInt
(
sIntPrefs
[
size_t
(
aID
)
]
&
aResult
)
)
)
{
sIntCache
.
Insert
(
aID
Some
(
aResult
)
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
NativeGetInt
(
aID
aResult
)
)
)
{
sIntCache
.
Insert
(
aID
Nothing
(
)
)
;
return
NS_ERROR_FAILURE
;
}
sIntCache
.
Insert
(
aID
Some
(
aResult
)
)
;
return
NS_OK
;
}
nsresult
nsXPLookAndFeel
:
:
GetFloatValue
(
FloatID
aID
float
&
aResult
)
{
if
(
!
sInitialized
)
{
Init
(
)
;
}
if
(
const
auto
*
cached
=
sFloatCache
.
Get
(
aID
)
)
{
if
(
cached
-
>
isNothing
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aResult
=
cached
-
>
value
(
)
;
return
NS_OK
;
}
int32_t
pref
=
0
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetInt
(
sFloatPrefs
[
size_t
(
aID
)
]
&
pref
)
)
)
{
aResult
=
float
(
pref
)
/
100
.
0f
;
sFloatCache
.
Insert
(
aID
Some
(
aResult
)
)
;
return
NS_OK
;
}
if
(
NS_FAILED
(
NativeGetFloat
(
aID
aResult
)
)
)
{
sFloatCache
.
Insert
(
aID
Nothing
(
)
)
;
return
NS_ERROR_FAILURE
;
}
sFloatCache
.
Insert
(
aID
Some
(
aResult
)
)
;
return
NS_OK
;
}
bool
nsXPLookAndFeel
:
:
LookAndFeelFontToStyle
(
const
LookAndFeelFont
&
aFont
nsString
&
aName
gfxFontStyle
&
aStyle
)
{
if
(
!
aFont
.
haveFont
(
)
)
{
return
false
;
}
aName
=
aFont
.
name
(
)
;
aStyle
=
gfxFontStyle
(
)
;
aStyle
.
size
=
aFont
.
size
(
)
;
aStyle
.
weight
=
FontWeight
:
:
FromInt
(
aFont
.
weight
(
)
)
;
aStyle
.
style
=
aFont
.
italic
(
)
?
FontSlantStyle
:
:
ITALIC
:
FontSlantStyle
:
:
NORMAL
;
aStyle
.
systemFont
=
true
;
return
true
;
}
widget
:
:
LookAndFeelFont
nsXPLookAndFeel
:
:
StyleToLookAndFeelFont
(
const
nsAString
&
aName
const
gfxFontStyle
&
aStyle
)
{
LookAndFeelFont
font
;
font
.
haveFont
(
)
=
true
;
font
.
name
(
)
=
aName
;
font
.
size
(
)
=
aStyle
.
size
;
font
.
weight
(
)
=
aStyle
.
weight
.
ToFloat
(
)
;
font
.
italic
(
)
=
aStyle
.
style
.
IsItalic
(
)
;
MOZ_ASSERT
(
aStyle
.
style
.
IsNormal
(
)
|
|
aStyle
.
style
.
IsItalic
(
)
"
Cannot
handle
oblique
font
style
"
)
;
#
ifdef
DEBUG
{
gfxFontStyle
candidate
=
aStyle
;
gfxFontStyle
defaults
{
}
;
candidate
.
size
=
defaults
.
size
;
candidate
.
weight
=
defaults
.
weight
;
candidate
.
style
=
defaults
.
style
;
MOZ_ASSERT
(
candidate
.
Equals
(
defaults
)
"
Some
font
style
properties
not
supported
"
)
;
}
#
endif
return
font
;
}
bool
nsXPLookAndFeel
:
:
GetFontValue
(
FontID
aID
nsString
&
aName
gfxFontStyle
&
aStyle
)
{
if
(
const
LookAndFeelFont
*
cached
=
sFontCache
.
Get
(
aID
)
)
{
return
LookAndFeelFontToStyle
(
*
cached
aName
aStyle
)
;
}
LookAndFeelFont
font
;
auto
GetFontsFromPrefs
=
[
&
]
(
)
-
>
bool
{
nsDependentCString
pref
(
sFontPrefs
[
size_t
(
aID
)
]
)
;
if
(
NS_FAILED
(
Preferences
:
:
GetString
(
pref
.
get
(
)
aName
)
)
)
{
return
false
;
}
font
.
haveFont
(
)
=
true
;
font
.
name
(
)
=
aName
;
font
.
size
(
)
=
Preferences
:
:
GetFloat
(
nsAutoCString
(
pref
+
"
.
size
"
_ns
)
.
get
(
)
)
;
if
(
font
.
size
(
)
<
1
.
0f
)
{
font
.
size
(
)
=
StyleFONT_MEDIUM_PX
;
}
font
.
weight
(
)
=
Preferences
:
:
GetFloat
(
nsAutoCString
(
pref
+
"
.
weight
"
_ns
)
.
get
(
)
FontWeight
:
:
NORMAL
.
ToFloat
(
)
)
;
font
.
italic
(
)
=
Preferences
:
:
GetBool
(
nsAutoCString
(
pref
+
"
.
italic
"
_ns
)
.
get
(
)
)
;
return
true
;
}
;
if
(
GetFontsFromPrefs
(
)
)
{
LookAndFeelFontToStyle
(
font
aName
aStyle
)
;
}
else
if
(
NativeGetFont
(
aID
aName
aStyle
)
)
{
font
=
StyleToLookAndFeelFont
(
aName
aStyle
)
;
}
else
{
MOZ_ASSERT
(
!
font
.
haveFont
(
)
)
;
}
bool
success
=
font
.
haveFont
(
)
;
sFontCache
.
Insert
(
aID
std
:
:
move
(
font
)
)
;
return
success
;
}
void
nsXPLookAndFeel
:
:
RefreshImpl
(
)
{
sColorCaches
.
Clear
(
)
;
sFontCache
.
Clear
(
)
;
sFloatCache
.
Clear
(
)
;
sIntCache
.
Clear
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
nsLayoutUtils
:
:
RecomputeSmoothScrollDefault
(
)
;
widget
:
:
RemoteLookAndFeel
:
:
ClearCachedData
(
)
;
}
}
static
bool
sRecordedLookAndFeelTelemetry
=
false
;
void
nsXPLookAndFeel
:
:
RecordTelemetry
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
return
;
}
if
(
sRecordedLookAndFeelTelemetry
)
{
return
;
}
sRecordedLookAndFeelTelemetry
=
true
;
int32_t
i
;
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
WIDGET_DARK_MODE
NS_SUCCEEDED
(
GetIntValue
(
IntID
:
:
SystemUsesDarkTheme
i
)
)
&
&
i
!
=
0
)
;
RecordLookAndFeelSpecificTelemetry
(
)
;
}
namespace
mozilla
{
bool
LookAndFeel
:
:
sGlobalThemeChanged
;
static
widget
:
:
ThemeChangeKind
sGlobalThemeChangeKind
{
0
}
;
void
LookAndFeel
:
:
NotifyChangedAllWindows
(
widget
:
:
ThemeChangeKind
aKind
)
{
sGlobalThemeChanged
=
true
;
sGlobalThemeChangeKind
|
=
aKind
;
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
const
char16_t
kind
[
]
=
{
char16_t
(
aKind
)
0
}
;
obs
-
>
NotifyObservers
(
nullptr
"
internal
-
look
-
and
-
feel
-
changed
"
kind
)
;
}
}
void
LookAndFeel
:
:
DoHandleGlobalThemeChange
(
)
{
MOZ_ASSERT
(
sGlobalThemeChanged
)
;
sGlobalThemeChanged
=
false
;
auto
kind
=
std
:
:
exchange
(
sGlobalThemeChangeKind
widget
:
:
ThemeChangeKind
(
0
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
if
(
nsCOMPtr
<
nsITheme
>
theme
=
do_GetNativeThemeDoNotUseDirectly
(
)
)
{
theme
-
>
ThemeChanged
(
)
;
}
}
if
(
nsCOMPtr
<
nsITheme
>
theme
=
do_GetBasicNativeThemeDoNotUseDirectly
(
)
)
{
theme
-
>
ThemeChanged
(
)
;
}
LookAndFeel
:
:
Refresh
(
)
;
PreferenceSheet
:
:
Refresh
(
)
;
image
:
:
SurfaceCacheUtils
:
:
DiscardAll
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
dom
:
:
ContentParent
:
:
BroadcastThemeUpdate
(
kind
)
;
}
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
HandleGlobalThemeChange
"
[
]
{
if
(
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
)
{
obs
-
>
NotifyObservers
(
nullptr
"
look
-
and
-
feel
-
changed
"
nullptr
)
;
}
}
)
)
;
}
#
define
BIT_FOR
(
_c
)
(
1ull
<
<
size_t
(
ColorID
:
:
_c
)
)
static
constexpr
std
:
:
bitset
<
size_t
(
ColorID
:
:
End
)
>
sNonNativeThemeStandinColors
{
BIT_FOR
(
Buttonface
)
|
BIT_FOR
(
Buttontext
)
|
BIT_FOR
(
MozButtonhoverface
)
|
BIT_FOR
(
MozButtonhovertext
)
|
BIT_FOR
(
MozButtonactiveface
)
|
BIT_FOR
(
MozButtonactivetext
)
|
BIT_FOR
(
MozButtondisabledface
)
|
BIT_FOR
(
Buttonborder
)
|
BIT_FOR
(
MozCombobox
)
|
BIT_FOR
(
MozComboboxtext
)
|
BIT_FOR
(
Threedlightshadow
)
|
BIT_FOR
(
Threeddarkshadow
)
|
BIT_FOR
(
Threedface
)
|
BIT_FOR
(
Field
)
|
BIT_FOR
(
Fieldtext
)
|
BIT_FOR
(
MozDisabledfield
)
|
BIT_FOR
(
Graytext
)
|
BIT_FOR
(
Buttonhighlight
)
|
BIT_FOR
(
Buttonshadow
)
|
BIT_FOR
(
Threedface
)
|
BIT_FOR
(
Activeborder
)
|
BIT_FOR
(
Inactiveborder
)
|
BIT_FOR
(
Threeddarkshadow
)
|
BIT_FOR
(
Threedhighlight
)
|
BIT_FOR
(
Threedshadow
)
|
BIT_FOR
(
Windowframe
)
|
BIT_FOR
(
Inactivecaptiontext
)
|
BIT_FOR
(
Appworkspace
)
|
BIT_FOR
(
Background
)
|
BIT_FOR
(
Inactivecaption
)
|
BIT_FOR
(
Infobackground
)
|
BIT_FOR
(
Menu
)
|
BIT_FOR
(
Scrollbar
)
|
BIT_FOR
(
Activecaption
)
|
BIT_FOR
(
Captiontext
)
|
BIT_FOR
(
Infotext
)
|
BIT_FOR
(
Menutext
)
|
BIT_FOR
(
Window
)
|
BIT_FOR
(
Windowtext
)
}
;
#
undef
BIT_FOR
static
bool
ShouldUseStandinsForNativeColorForNonNativeTheme
(
const
dom
:
:
Document
&
aDoc
LookAndFeel
:
:
ColorID
aColor
const
PreferenceSheet
:
:
Prefs
&
aPrefs
)
{
const
bool
shouldUseStandinsForColor
=
[
&
]
{
if
(
sNonNativeThemeStandinColors
[
size_t
(
aColor
)
]
)
{
return
true
;
}
return
!
StaticPrefs
:
:
widget_non_native_theme_use_theme_accent
(
)
&
&
(
aColor
=
=
LookAndFeel
:
:
ColorID
:
:
Accentcolor
|
|
aColor
=
=
LookAndFeel
:
:
ColorID
:
:
Accentcolortext
)
;
}
(
)
;
return
shouldUseStandinsForColor
&
&
aDoc
.
ShouldAvoidNativeTheme
(
)
&
&
!
aPrefs
.
NonNativeThemeShouldBeHighContrast
(
)
;
}
bool
LookAndFeel
:
:
IsDarkColor
(
nscolor
aColor
)
{
constexpr
float
kThreshold
=
0
.
179129
;
return
NS_GET_A
(
aColor
)
>
127
&
&
RelativeLuminanceUtils
:
:
Compute
(
aColor
)
<
kThreshold
;
}
ColorScheme
LookAndFeel
:
:
ColorSchemeForStyle
(
const
dom
:
:
Document
&
aDoc
const
StyleColorSchemeFlags
&
aFlags
ColorSchemeMode
aMode
)
{
const
auto
&
prefs
=
PreferenceSheet
:
:
PrefsFor
(
aDoc
)
;
StyleColorSchemeFlags
style
(
aFlags
)
;
if
(
!
style
)
{
style
.
_0
=
aDoc
.
GetColorSchemeBits
(
)
;
}
const
bool
supportsDark
=
bool
(
style
&
StyleColorSchemeFlags
:
:
DARK
)
;
const
bool
supportsLight
=
bool
(
style
&
StyleColorSchemeFlags
:
:
LIGHT
)
;
if
(
supportsLight
&
&
supportsDark
)
{
return
aDoc
.
PreferredColorScheme
(
)
;
}
if
(
supportsDark
|
|
supportsLight
)
{
return
supportsDark
?
ColorScheme
:
:
Dark
:
ColorScheme
:
:
Light
;
}
if
(
aMode
=
=
ColorSchemeMode
:
:
Preferred
|
|
aDoc
.
ChromeRulesEnabled
(
)
|
|
!
prefs
.
mUseDocumentColors
)
{
return
aDoc
.
PreferredColorScheme
(
)
;
}
return
ColorScheme
:
:
Light
;
}
LookAndFeel
:
:
ColorScheme
LookAndFeel
:
:
ColorSchemeForFrame
(
const
nsIFrame
*
aFrame
ColorSchemeMode
aMode
)
{
return
ColorSchemeForStyle
(
*
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
aFrame
-
>
StyleUI
(
)
-
>
mColorScheme
.
bits
aMode
)
;
}
Maybe
<
nscolor
>
LookAndFeel
:
:
GetColor
(
ColorID
aId
ColorScheme
aScheme
UseStandins
aUseStandins
)
{
nscolor
result
;
nsresult
rv
=
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetColorValue
(
aId
aScheme
aUseStandins
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Nothing
(
)
;
}
return
Some
(
result
)
;
}
static
bool
ColorIsCSSAccessible
(
LookAndFeel
:
:
ColorID
aId
)
{
using
ColorID
=
LookAndFeel
:
:
ColorID
;
switch
(
aId
)
{
case
ColorID
:
:
TextSelectDisabledBackground
:
case
ColorID
:
:
TextSelectAttentionBackground
:
case
ColorID
:
:
TextSelectAttentionForeground
:
case
ColorID
:
:
TextHighlightBackground
:
case
ColorID
:
:
TextHighlightForeground
:
case
ColorID
:
:
ThemedScrollbar
:
case
ColorID
:
:
ThemedScrollbarInactive
:
case
ColorID
:
:
ThemedScrollbarThumb
:
case
ColorID
:
:
ThemedScrollbarThumbActive
:
case
ColorID
:
:
ThemedScrollbarThumbInactive
:
case
ColorID
:
:
ThemedScrollbarThumbHover
:
case
ColorID
:
:
IMERawInputBackground
:
case
ColorID
:
:
IMERawInputForeground
:
case
ColorID
:
:
IMERawInputUnderline
:
case
ColorID
:
:
IMESelectedRawTextBackground
:
case
ColorID
:
:
IMESelectedRawTextForeground
:
case
ColorID
:
:
IMESelectedRawTextUnderline
:
case
ColorID
:
:
IMEConvertedTextBackground
:
case
ColorID
:
:
IMEConvertedTextForeground
:
case
ColorID
:
:
IMEConvertedTextUnderline
:
case
ColorID
:
:
IMESelectedConvertedTextBackground
:
case
ColorID
:
:
IMESelectedConvertedTextForeground
:
case
ColorID
:
:
IMESelectedConvertedTextUnderline
:
case
ColorID
:
:
SpellCheckerUnderline
:
return
false
;
default
:
break
;
}
return
true
;
}
LookAndFeel
:
:
UseStandins
LookAndFeel
:
:
ShouldUseStandins
(
const
dom
:
:
Document
&
aDoc
ColorID
aId
)
{
const
auto
&
prefs
=
PreferenceSheet
:
:
PrefsFor
(
aDoc
)
;
if
(
ShouldUseStandinsForNativeColorForNonNativeTheme
(
aDoc
aId
prefs
)
)
{
return
UseStandins
:
:
Yes
;
}
if
(
prefs
.
mUseStandins
&
&
ColorIsCSSAccessible
(
aId
)
)
{
return
UseStandins
:
:
Yes
;
}
return
UseStandins
:
:
No
;
}
Maybe
<
nscolor
>
LookAndFeel
:
:
GetColor
(
ColorID
aId
const
nsIFrame
*
aFrame
)
{
const
auto
*
doc
=
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
;
return
GetColor
(
aId
ColorSchemeForFrame
(
aFrame
)
ShouldUseStandins
(
*
doc
aId
)
)
;
}
nsresult
LookAndFeel
:
:
GetInt
(
IntID
aID
int32_t
*
aResult
)
{
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetIntValue
(
aID
*
aResult
)
;
}
nsresult
LookAndFeel
:
:
GetFloat
(
FloatID
aID
float
*
aResult
)
{
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetFloatValue
(
aID
*
aResult
)
;
}
bool
LookAndFeel
:
:
GetFont
(
FontID
aID
nsString
&
aName
gfxFontStyle
&
aStyle
)
{
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetFontValue
(
aID
aName
aStyle
)
;
}
char16_t
LookAndFeel
:
:
GetPasswordCharacter
(
)
{
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetPasswordCharacterImpl
(
)
;
}
bool
LookAndFeel
:
:
GetEchoPassword
(
)
{
if
(
StaticPrefs
:
:
editor_password_mask_delay
(
)
>
=
0
)
{
return
StaticPrefs
:
:
editor_password_mask_delay
(
)
>
0
;
}
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetEchoPasswordImpl
(
)
;
}
uint32_t
LookAndFeel
:
:
GetPasswordMaskDelay
(
)
{
int32_t
delay
=
StaticPrefs
:
:
editor_password_mask_delay
(
)
;
if
(
delay
<
0
)
{
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetPasswordMaskDelayImpl
(
)
;
}
return
delay
;
}
bool
LookAndFeel
:
:
DrawInTitlebar
(
)
{
switch
(
StaticPrefs
:
:
browser_tabs_inTitlebar
(
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
break
;
}
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetDefaultDrawInTitlebar
(
)
;
}
LookAndFeel
:
:
TitlebarAction
LookAndFeel
:
:
GetTitlebarAction
(
TitlebarEvent
aEvent
)
{
return
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetTitlebarAction
(
aEvent
)
;
}
void
LookAndFeel
:
:
GetThemeInfo
(
nsACString
&
aOut
)
{
nsLookAndFeel
:
:
GetInstance
(
)
-
>
GetThemeInfo
(
aOut
)
;
}
uint32_t
LookAndFeel
:
:
GetMenuAccessKey
(
)
{
return
StaticPrefs
:
:
ui_key_menuAccessKey
(
)
;
}
Modifiers
LookAndFeel
:
:
GetMenuAccessKeyModifiers
(
)
{
switch
(
GetMenuAccessKey
(
)
)
{
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_SHIFT
:
return
MODIFIER_SHIFT
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_CONTROL
:
return
MODIFIER_CONTROL
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_ALT
:
return
MODIFIER_ALT
;
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_META
:
case
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_WIN
:
return
MODIFIER_META
;
default
:
return
0
;
}
}
void
LookAndFeel
:
:
Refresh
(
)
{
nsLookAndFeel
:
:
GetInstance
(
)
-
>
RefreshImpl
(
)
;
widget
:
:
Theme
:
:
LookAndFeelChanged
(
)
;
}
void
LookAndFeel
:
:
NativeInit
(
)
{
nsLookAndFeel
:
:
GetInstance
(
)
-
>
NativeInit
(
)
;
}
void
LookAndFeel
:
:
SetData
(
widget
:
:
FullLookAndFeel
&
&
aTables
)
{
nsLookAndFeel
:
:
GetInstance
(
)
-
>
SetDataImpl
(
std
:
:
move
(
aTables
)
)
;
}
}
