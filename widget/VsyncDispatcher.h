#
ifndef
mozilla_widget_VsyncDispatcher_h
#
define
mozilla_widget_VsyncDispatcher_h
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
VsyncSource
.
h
"
namespace
mozilla
{
class
VsyncObserver
{
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
public
:
virtual
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
=
0
;
protected
:
VsyncObserver
(
)
=
default
;
virtual
~
VsyncObserver
(
)
=
default
;
}
;
class
CompositorVsyncDispatcher
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CompositorVsyncDispatcher
)
public
:
CompositorVsyncDispatcher
(
)
;
explicit
CompositorVsyncDispatcher
(
RefPtr
<
gfx
:
:
VsyncSource
>
aVsyncSource
)
;
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
;
void
MoveToSource
(
const
RefPtr
<
gfx
:
:
VsyncSource
>
&
aVsyncSource
)
;
void
SetCompositorVsyncObserver
(
VsyncObserver
*
aVsyncObserver
)
;
void
Shutdown
(
)
;
private
:
virtual
~
CompositorVsyncDispatcher
(
)
;
void
ObserveVsync
(
bool
aEnable
)
;
RefPtr
<
gfx
:
:
VsyncSource
>
mVsyncSource
;
Mutex
mCompositorObserverLock
MOZ_UNANNOTATED
;
RefPtr
<
VsyncObserver
>
mCompositorVsyncObserver
;
bool
mDidShutdown
;
}
;
class
VsyncDispatcher
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VsyncDispatcher
)
public
:
explicit
VsyncDispatcher
(
gfx
:
:
VsyncSource
*
aVsyncSource
)
;
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
;
void
MoveToSource
(
gfx
:
:
VsyncSource
*
aVsyncSource
)
;
void
AddVsyncObserver
(
VsyncObserver
*
aVsyncObserver
)
;
void
RemoveVsyncObserver
(
VsyncObserver
*
aVsyncObserver
)
;
private
:
virtual
~
VsyncDispatcher
(
)
;
void
UpdateVsyncStatus
(
)
;
bool
NeedsVsync
(
)
;
gfx
:
:
VsyncSource
*
mVsyncSource
;
DataMutex
<
nsTArray
<
RefPtr
<
VsyncObserver
>
>
>
mVsyncObservers
;
}
;
}
#
endif
