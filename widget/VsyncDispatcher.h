#
ifndef
mozilla_widget_VsyncDispatcher_h
#
define
mozilla_widget_VsyncDispatcher_h
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
VsyncSource
.
h
"
namespace
mozilla
{
class
VsyncObserver
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VsyncObserver
)
public
:
virtual
bool
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
=
0
;
protected
:
VsyncObserver
(
)
{
}
virtual
~
VsyncObserver
(
)
{
}
}
;
class
CompositorVsyncDispatcher
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CompositorVsyncDispatcher
)
public
:
CompositorVsyncDispatcher
(
)
;
explicit
CompositorVsyncDispatcher
(
RefPtr
<
gfx
:
:
VsyncSource
>
aVsyncSource
)
;
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
;
void
SetCompositorVsyncObserver
(
VsyncObserver
*
aVsyncObserver
)
;
void
Shutdown
(
)
;
private
:
virtual
~
CompositorVsyncDispatcher
(
)
;
void
ObserveVsync
(
bool
aEnable
)
;
RefPtr
<
gfx
:
:
VsyncSource
>
mVsyncSource
;
Mutex
mCompositorObserverLock
;
RefPtr
<
VsyncObserver
>
mCompositorVsyncObserver
;
bool
mDidShutdown
;
}
;
class
RefreshTimerVsyncDispatcher
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
RefreshTimerVsyncDispatcher
)
public
:
explicit
RefreshTimerVsyncDispatcher
(
gfx
:
:
VsyncSource
:
:
Display
*
aDisplay
)
;
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
;
void
MoveToDisplay
(
gfx
:
:
VsyncSource
:
:
Display
*
aDisplay
)
;
void
SetParentRefreshTimer
(
VsyncObserver
*
aVsyncObserver
)
;
void
AddChildRefreshTimer
(
VsyncObserver
*
aVsyncObserver
)
;
void
RemoveChildRefreshTimer
(
VsyncObserver
*
aVsyncObserver
)
;
private
:
virtual
~
RefreshTimerVsyncDispatcher
(
)
;
void
UpdateVsyncStatus
(
)
;
bool
NeedsVsync
(
)
;
gfx
:
:
VsyncSource
:
:
Display
*
mDisplay
;
Mutex
mDisplayLock
;
Mutex
mRefreshTimersLock
;
RefPtr
<
VsyncObserver
>
mParentRefreshTimer
;
nsTArray
<
RefPtr
<
VsyncObserver
>
>
mChildRefreshTimers
;
}
;
}
#
endif
