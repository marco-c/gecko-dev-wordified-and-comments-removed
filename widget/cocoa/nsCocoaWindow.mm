#
include
"
nsCocoaWindow
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsCursorManager
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
GLContextCGL
.
h
"
#
include
"
MacThemeGeometryType
.
h
"
#
include
"
NativeMenuSupport
.
h
"
#
include
"
WindowRenderer
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
SwipeTracker
.
h
"
#
include
"
mozilla
/
layers
/
APZInputBridge
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
NativeLayerCA
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
layers
/
SurfacePool
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
dom
/
SimpleGestureEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
WheelEventBinding
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
NativeKeyBindings
.
h
"
#
include
"
ScreenHelperCocoa
.
h
"
#
include
"
TextInputHandler
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsWindowMap
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDragService
.
h
"
#
include
"
nsNativeThemeColors
.
h
"
#
include
"
nsNativeThemeCocoa
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
VibrancyManager
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
qcms
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_general
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
widget
/
Screen
.
h
"
#
include
<
algorithm
>
#
undef
DEBUG_UPDATE
#
undef
INVALIDATE_DEBUGGING
/
/
flash
areas
as
they
are
invalidated
namespace
mozilla
{
namespace
layers
{
class
LayerManager
;
}
}
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
;
BOOL
sTouchBarIsInitialized
=
NO
;
extern
NSMenu
*
sApplicationMenu
;
extern
BOOL
gSomeMenuBarPainted
;
static
uint32_t
sModalWindowCount
=
0
;
LazyLogModule
sCocoaLog
(
"
nsCocoaWidgets
"
)
;
extern
"
C
"
{
typedef
NSInteger
CGSConnection
;
typedef
NSUInteger
CGSSpaceID
;
typedef
NSInteger
CGSWindow
;
typedef
enum
{
kCGSSpaceIncludesCurrent
=
1
<
<
0
kCGSSpaceIncludesOthers
=
1
<
<
1
kCGSSpaceIncludesUser
=
1
<
<
2
kCGSAllSpacesMask
=
kCGSSpaceIncludesCurrent
|
kCGSSpaceIncludesOthers
|
kCGSSpaceIncludesUser
}
CGSSpaceMask
;
static
NSString
*
const
CGSSpaceIDKey
=
"
ManagedSpaceID
"
;
static
NSString
*
const
CGSSpacesKey
=
"
Spaces
"
;
extern
CGSConnection
_CGSDefaultConnection
(
void
)
;
extern
CGError
CGSSetWindowTransform
(
CGSConnection
cid
CGSWindow
wid
CGAffineTransform
transform
)
;
CG_EXTERN
void
CGContextResetCTM
(
CGContextRef
)
;
CG_EXTERN
void
CGContextSetCTM
(
CGContextRef
CGAffineTransform
)
;
CG_EXTERN
void
CGContextResetClip
(
CGContextRef
)
;
typedef
CFTypeRef
CGSRegionObj
;
CGError
CGSNewRegionWithRect
(
const
CGRect
*
rect
CGSRegionObj
*
outRegion
)
;
CGError
CGSNewRegionWithRectList
(
const
CGRect
*
rects
int
rectCount
CGSRegionObj
*
outRegion
)
;
}
static
void
RollUpPopups
(
nsIRollupListener
:
:
AllowAnimations
aAllowAnimations
=
nsIRollupListener
:
:
AllowAnimations
:
:
Yes
)
{
if
(
RefPtr
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
RollupTooltips
(
)
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
if
(
!
rollupListener
)
{
return
;
}
if
(
rollupListener
-
>
RollupNativeMenu
(
)
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
!
rollupWidget
)
{
return
;
}
nsIRollupListener
:
:
RollupOptions
options
{
0
nsIRollupListener
:
:
FlushViews
:
:
Yes
nullptr
aAllowAnimations
}
;
rollupListener
-
>
Rollup
(
options
)
;
}
extern
nsIArray
*
gDraggedTransferables
;
ChildView
*
ChildViewMouseTracker
:
:
sLastMouseEventView
=
nil
;
NSEvent
*
ChildViewMouseTracker
:
:
sLastMouseMoveEvent
=
nil
;
NSWindow
*
ChildViewMouseTracker
:
:
sWindowUnderMouse
=
nil
;
MOZ_RUNINIT
NSPoint
ChildViewMouseTracker
:
:
sLastScrollEventScreenLocation
=
NSZeroPoint
;
#
ifdef
INVALIDATE_DEBUGGING
static
void
blinkRect
(
Rect
*
r
)
;
static
void
blinkRgn
(
RgnHandle
rgn
)
;
#
endif
bool
gUserCancelledDrag
=
false
;
uint32_t
nsCocoaWindow
:
:
sLastInputEventCount
=
0
;
static
bool
sIsTabletPointerActivated
=
false
;
static
uint32_t
sUniqueKeyEventId
=
0
;
interface
PixelHostingView
:
NSView
{
}
end
interface
ChildView
(
Private
)
-
(
id
)
initWithFrame
:
(
NSRect
)
inFrame
geckoChild
:
(
nsCocoaWindow
*
)
inChild
;
-
(
void
)
convertCocoaMouseWheelEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetWheelEvent
*
)
outWheelEvent
;
-
(
void
)
convertCocoaMouseEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetInputEvent
*
)
outGeckoEvent
;
-
(
void
)
convertCocoaTabletPointerEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetMouseEvent
*
)
outGeckoEvent
;
-
(
NSMenu
*
)
contextMenu
;
-
(
void
)
markLayerForDisplay
;
-
(
CALayer
*
)
rootCALayer
;
-
(
void
)
updateRootCALayer
;
#
ifdef
ACCESSIBILITY
-
(
id
<
mozAccessible
>
)
accessible
;
#
endif
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinates
:
(
NSPoint
)
aPoint
;
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinatesRoundDown
:
(
NSPoint
)
aPoint
;
-
(
BOOL
)
inactiveWindowAcceptsMouseEvent
:
(
NSEvent
*
)
aEvent
;
-
(
void
)
updateWindowDraggableState
;
-
(
bool
)
beginOrEndGestureForEventPhase
:
(
NSEvent
*
)
aEvent
;
end
#
pragma
mark
-
static
inline
void
FlipCocoaScreenCoordinate
(
NSPoint
&
inPoint
)
{
inPoint
.
y
=
nsCocoaUtils
:
:
FlippedScreenY
(
inPoint
.
y
)
;
}
void
nsCocoaWindow
:
:
TearDownView
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mChildView
)
return
;
NSWindow
*
win
=
[
mChildView
window
]
;
NSResponder
*
responder
=
[
win
firstResponder
]
;
if
(
responder
&
&
[
responder
isKindOfClass
:
[
NSView
class
]
]
&
&
[
(
NSView
*
)
responder
isDescendantOf
:
mChildView
]
)
{
[
win
makeFirstResponder
:
[
mChildView
superview
]
]
;
}
if
(
[
mChildView
isEqual
:
[
win
contentView
]
]
)
{
[
mChildView
release
]
;
}
else
{
[
mChildView
performSelectorOnMainThread
:
selector
(
delayedTearDown
)
withObject
:
nil
waitUntilDone
:
false
]
;
}
mChildView
=
nil
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
if
0
static
void
PrintViewHierarchy
(
NSView
*
view
)
{
while
(
view
)
{
NSLog
(
"
view
is
%
x
frame
%
"
view
NSStringFromRect
(
[
view
frame
]
)
)
;
view
=
[
view
superview
]
;
}
}
#
endif
static
void
ManipulateViewWithoutNeedingDisplay
(
NSView
*
aView
void
(
^
aCallback
)
(
)
)
{
BaseWindow
*
win
=
nil
;
if
(
[
[
aView
window
]
isKindOfClass
:
[
BaseWindow
class
]
]
)
{
win
=
(
BaseWindow
*
)
[
aView
window
]
;
}
[
win
disableSetNeedsDisplay
]
;
aCallback
(
)
;
[
win
enableSetNeedsDisplay
]
;
}
void
nsCocoaWindow
:
:
SetCursor
(
const
Cursor
&
aCursor
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
[
mChildView
isDragInProgress
]
)
{
return
;
}
nsBaseWidget
:
:
SetCursor
(
aCursor
)
;
bool
forceUpdate
=
mUpdateCursor
;
mUpdateCursor
=
false
;
if
(
mCustomCursorAllowed
&
&
NS_SUCCEEDED
(
[
[
nsCursorManager
sharedInstance
]
setCustomCursor
:
aCursor
widgetScaleFactor
:
BackingScaleFactor
(
)
forceUpdate
:
forceUpdate
]
)
)
{
return
;
}
[
[
nsCursorManager
sharedInstance
]
setNonCustomCursor
:
aCursor
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SuspendAsyncCATransactions
(
)
{
if
(
mUnsuspendAsyncCATransactionsRunnable
)
{
mUnsuspendAsyncCATransactionsRunnable
-
>
Cancel
(
)
;
mUnsuspendAsyncCATransactionsRunnable
=
nullptr
;
}
[
mChildView
markLayerForDisplay
]
;
if
(
mCompositorBridgeChild
)
{
mCompositorBridgeChild
-
>
SetForceSyncFlushRendering
(
true
)
;
}
mNativeLayerRoot
-
>
SuspendOffMainThreadCommits
(
)
;
}
void
nsCocoaWindow
:
:
MaybeScheduleUnsuspendAsyncCATransactions
(
)
{
if
(
mNativeLayerRoot
-
>
AreOffMainThreadCommitsSuspended
(
)
&
&
!
mUnsuspendAsyncCATransactionsRunnable
)
{
mUnsuspendAsyncCATransactionsRunnable
=
NewCancelableRunnableMethod
(
"
nsCocoaWindow
:
:
MaybeScheduleUnsuspendAsyncCATransactions
"
this
&
nsCocoaWindow
:
:
UnsuspendAsyncCATransactions
)
;
NS_DispatchToMainThread
(
mUnsuspendAsyncCATransactionsRunnable
)
;
}
}
void
nsCocoaWindow
:
:
UnsuspendAsyncCATransactions
(
)
{
mUnsuspendAsyncCATransactionsRunnable
=
nullptr
;
if
(
mNativeLayerRoot
-
>
UnsuspendOffMainThreadCommits
(
)
)
{
[
mChildView
markLayerForDisplay
]
;
}
if
(
mCompositorBridgeChild
)
{
mCompositorBridgeChild
-
>
SetForceSyncFlushRendering
(
false
)
;
}
}
nsresult
nsCocoaWindow
:
:
SynthesizeNativeKeyEvent
(
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
nsISynthesizedEventCallback
*
aCallback
)
{
AutoSynthesizedEventCallbackNotifier
notifier
(
aCallback
)
;
return
mTextInputHandler
-
>
SynthesizeNativeKeyEvent
(
aNativeKeyboardLayout
aNativeKeyCode
aModifierFlags
aCharacters
aUnmodifiedCharacters
)
;
}
nsresult
nsCocoaWindow
:
:
SynthesizeNativeMouseEvent
(
LayoutDeviceIntPoint
aPoint
NativeMouseMessage
aNativeMessage
MouseButton
aButton
nsIWidget
:
:
Modifiers
aModifierFlags
nsISynthesizedEventCallback
*
aCallback
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoSynthesizedEventCallbackNotifier
notifier
(
aCallback
)
;
NSPoint
pt
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
aPoint
BackingScaleFactor
(
)
)
;
CGWarpMouseCursorPosition
(
NSPointToCGPoint
(
pt
)
)
;
CGAssociateMouseAndMouseCursorPosition
(
true
)
;
NSPoint
screenPoint
=
NSMakePoint
(
pt
.
x
nsCocoaUtils
:
:
FlippedScreenY
(
pt
.
y
)
)
;
NSPoint
windowPoint
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
[
mChildView
window
]
screenPoint
)
;
NSEventModifierFlags
modifierFlags
=
nsCocoaUtils
:
:
ConvertWidgetModifiersToMacModifierFlags
(
aModifierFlags
)
;
if
(
aButton
=
=
MouseButton
:
:
eX1
|
|
aButton
=
=
MouseButton
:
:
eX2
)
{
return
NS_ERROR_INVALID_ARG
;
}
NSEventType
nativeEventType
;
switch
(
aNativeMessage
)
{
case
NativeMouseMessage
:
:
ButtonDown
:
case
NativeMouseMessage
:
:
ButtonUp
:
{
switch
(
aButton
)
{
case
MouseButton
:
:
ePrimary
:
nativeEventType
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
NSEventTypeLeftMouseDown
:
NSEventTypeLeftMouseUp
;
break
;
case
MouseButton
:
:
eMiddle
:
nativeEventType
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
NSEventTypeOtherMouseDown
:
NSEventTypeOtherMouseUp
;
break
;
case
MouseButton
:
:
eSecondary
:
nativeEventType
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
NSEventTypeRightMouseDown
:
NSEventTypeRightMouseUp
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
break
;
}
case
NativeMouseMessage
:
:
Move
:
nativeEventType
=
NSEventTypeMouseMoved
;
break
;
case
NativeMouseMessage
:
:
EnterWindow
:
nativeEventType
=
NSEventTypeMouseEntered
;
break
;
case
NativeMouseMessage
:
:
LeaveWindow
:
nativeEventType
=
NSEventTypeMouseExited
;
break
;
}
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
nativeEventType
location
:
windowPoint
modifierFlags
:
modifierFlags
timestamp
:
[
[
NSProcessInfo
processInfo
]
systemUptime
]
windowNumber
:
[
[
mChildView
window
]
windowNumber
]
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0
]
;
if
(
!
event
)
return
NS_ERROR_FAILURE
;
if
(
[
[
mChildView
window
]
isKindOfClass
:
[
BaseWindow
class
]
]
)
{
BaseWindow
*
window
=
(
BaseWindow
*
)
[
mChildView
window
]
;
if
(
nativeEventType
=
=
NSEventTypeMouseEntered
)
{
[
window
mouseEntered
:
event
]
;
return
NS_OK
;
}
if
(
nativeEventType
=
=
NSEventTypeMouseExited
)
{
[
window
mouseExited
:
event
]
;
return
NS_OK
;
}
if
(
nativeEventType
=
=
NSEventTypeMouseMoved
)
{
[
window
mouseMoved
:
event
]
;
return
NS_OK
;
}
}
[
NSApp
sendEvent
:
event
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
SynthesizeNativeMouseScrollEvent
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
double
aDeltaX
double
aDeltaY
double
aDeltaZ
uint32_t
aModifierFlags
uint32_t
aAdditionalFlags
nsISynthesizedEventCallback
*
aCallback
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoSynthesizedEventCallbackNotifier
notifier
(
aCallback
)
;
NSPoint
pt
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
aPoint
BackingScaleFactor
(
)
)
;
CGWarpMouseCursorPosition
(
NSPointToCGPoint
(
pt
)
)
;
CGAssociateMouseAndMouseCursorPosition
(
true
)
;
CGScrollEventUnit
units
=
(
aAdditionalFlags
&
nsIDOMWindowUtils
:
:
MOUSESCROLL_SCROLL_LINES
)
?
kCGScrollEventUnitLine
:
kCGScrollEventUnitPixel
;
CGEventRef
cgEvent
=
CGEventCreateScrollWheelEvent
(
NULL
units
3
(
int32_t
)
aDeltaY
(
int32_t
)
aDeltaX
(
int32_t
)
aDeltaZ
)
;
if
(
!
cgEvent
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNativeMessage
)
{
CGEventSetIntegerValueField
(
cgEvent
kCGScrollWheelEventScrollPhase
aNativeMessage
)
;
}
CGPoint
location
=
CGEventGetLocation
(
cgEvent
)
;
location
.
y
+
=
NSMinY
(
[
[
mChildView
window
]
frame
]
)
;
location
.
x
-
=
NSMinX
(
[
[
mChildView
window
]
frame
]
)
;
CGEventSetLocation
(
cgEvent
location
)
;
uint64_t
kNanosPerSec
=
1000000000L
;
CGEventSetTimestamp
(
cgEvent
[
[
NSProcessInfo
processInfo
]
systemUptime
]
*
kNanosPerSec
)
;
NSEvent
*
event
=
[
NSEvent
eventWithCGEvent
:
cgEvent
]
;
[
event
setValue
:
[
mChildView
window
]
forKey
:
"
_window
"
]
;
[
mChildView
scrollWheel
:
event
]
;
CFRelease
(
cgEvent
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
SynthesizeNativeTouchPoint
(
uint32_t
aPointerId
TouchPointerState
aPointerState
mozilla
:
:
LayoutDeviceIntPoint
aPoint
double
aPointerPressure
uint32_t
aPointerOrientation
nsISynthesizedEventCallback
*
aCallback
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoSynthesizedEventCallbackNotifier
notifier
(
aCallback
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aPointerState
=
=
TOUCH_HOVER
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mSynthesizedTouchInput
)
{
mSynthesizedTouchInput
=
MakeUnique
<
MultiTouchInput
>
(
)
;
}
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
MultiTouchInput
inputToDispatch
=
UpdateSynthesizedTouchState
(
mSynthesizedTouchInput
.
get
(
)
TimeStamp
:
:
Now
(
)
aPointerId
aPointerState
pointInWindow
aPointerPressure
aPointerOrientation
)
;
DispatchTouchInput
(
inputToDispatch
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
SynthesizeNativeTouchpadDoubleTap
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aModifierFlags
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
DispatchDoubleTapGesture
(
TimeStamp
:
:
Now
(
)
aPoint
-
WidgetToScreenOffset
(
)
static_cast
<
Modifiers
>
(
aModifierFlags
)
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
bool
nsCocoaWindow
:
:
SendEventToNativeMenuSystem
(
NSEvent
*
aEvent
)
{
bool
handled
=
false
;
if
(
nsMenuBarX
*
mb
=
GetMenuBar
(
)
)
{
handled
=
mb
-
>
PerformKeyEquivalent
(
aEvent
)
;
}
if
(
!
handled
&
&
sApplicationMenu
)
{
handled
=
[
sApplicationMenu
performKeyEquivalent
:
aEvent
]
;
}
return
handled
;
}
void
nsCocoaWindow
:
:
PostHandleKeyEvent
(
mozilla
:
:
WidgetKeyboardEvent
*
aEvent
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSMutableDictionary
*
nativeKeyEventsMap
=
[
ChildView
sNativeKeyEventsMap
]
;
NSEvent
*
cocoaEvent
=
[
nativeKeyEventsMap
objectForKey
:
(
aEvent
-
>
mUniqueId
)
]
;
if
(
!
cocoaEvent
)
{
return
;
}
if
(
StaticPrefs
:
:
browser_fullscreen_exit_on_escape
(
)
&
&
[
cocoaEvent
keyCode
]
=
=
kVK_Escape
&
&
[
[
mChildView
window
]
styleMask
]
&
NSWindowStyleMaskFullScreen
)
{
[
[
mChildView
window
]
toggleFullScreen
:
nil
]
;
}
if
(
SendEventToNativeMenuSystem
(
cocoaEvent
)
)
{
aEvent
-
>
PreventDefault
(
)
;
}
[
nativeKeyEventsMap
removeObjectForKey
:
(
aEvent
-
>
mUniqueId
)
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
ActivateNativeMenuItemAt
(
const
nsAString
&
indexString
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsMenuUtilsX
:
:
CheckNativeMenuConsistency
(
[
NSApp
mainMenu
]
)
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
indexString
.
BeginReading
(
)
)
length
:
indexString
.
Length
(
)
]
;
NSMenuItem
*
item
=
nsMenuUtilsX
:
:
NativeMenuItemWithLocation
(
[
NSApp
mainMenu
]
locationString
true
)
;
if
(
item
&
&
!
[
item
hasSubmenu
]
)
{
NSMenu
*
parent
=
[
item
menu
]
;
if
(
parent
)
{
mozilla
:
:
AutoRestore
<
bool
>
autoRestore
(
nsMenuUtilsX
:
:
gIsSynchronouslyActivatingNativeMenuItemDuringTest
)
;
nsMenuUtilsX
:
:
gIsSynchronouslyActivatingNativeMenuItemDuringTest
=
true
;
[
parent
performActionForItemAtIndex
:
[
parent
indexOfItem
:
item
]
]
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
ForceUpdateNativeMenuAt
(
const
nsAString
&
indexString
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
nsMenuBarX
*
mb
=
GetMenuBar
(
)
)
{
if
(
indexString
.
IsEmpty
(
)
)
mb
-
>
ForceNativeMenuReload
(
)
;
else
mb
-
>
ForceUpdateNativeMenuAt
(
indexString
)
;
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
#
pragma
mark
-
#
ifdef
INVALIDATE_DEBUGGING
static
Boolean
KeyDown
(
const
UInt8
theKey
)
{
KeyMap
map
;
GetKeys
(
map
)
;
return
(
(
*
(
(
UInt8
*
)
map
+
(
theKey
>
>
3
)
)
>
>
(
theKey
&
7
)
)
&
1
)
!
=
0
;
}
static
Boolean
caps_lock
(
)
{
return
KeyDown
(
0x39
)
;
}
static
void
blinkRect
(
Rect
*
r
)
{
StRegionFromPool
oldClip
;
if
(
oldClip
!
=
NULL
)
:
:
GetClip
(
oldClip
)
;
:
:
ClipRect
(
r
)
;
:
:
InvertRect
(
r
)
;
UInt32
end
=
:
:
TickCount
(
)
+
5
;
while
(
:
:
TickCount
(
)
<
end
)
;
:
:
InvertRect
(
r
)
;
if
(
oldClip
!
=
NULL
)
:
:
SetClip
(
oldClip
)
;
}
static
void
blinkRgn
(
RgnHandle
rgn
)
{
StRegionFromPool
oldClip
;
if
(
oldClip
!
=
NULL
)
:
:
GetClip
(
oldClip
)
;
:
:
SetClip
(
rgn
)
;
:
:
InvertRgn
(
rgn
)
;
UInt32
end
=
:
:
TickCount
(
)
+
5
;
while
(
:
:
TickCount
(
)
<
end
)
;
:
:
InvertRgn
(
rgn
)
;
if
(
oldClip
!
=
NULL
)
:
:
SetClip
(
oldClip
)
;
}
#
endif
void
nsCocoaWindow
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mChildView
|
|
!
mWindow
.
isVisibleOrBeingShown
)
{
return
;
}
NS_ASSERTION
(
GetWindowRenderer
(
)
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_WR
"
Shouldn
'
t
need
to
invalidate
with
accelerated
OMTC
layers
!
"
)
;
EnsureContentLayerForMainThreadPainting
(
)
;
mContentLayerInvalidRegion
.
OrWith
(
aRect
.
Intersect
(
LayoutDeviceIntRect
(
LayoutDeviceIntPoint
(
)
GetClientBounds
(
)
.
Size
(
)
)
)
)
;
[
mChildView
markLayerForDisplay
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
void
nsCocoaWindow
:
:
WillPaintWindow
(
)
{
if
(
nsIWidgetListener
*
listener
=
GetPaintListener
(
)
)
{
listener
-
>
WillPaintWindow
(
this
)
;
}
}
bool
nsCocoaWindow
:
:
PaintWindow
(
LayoutDeviceIntRegion
aRegion
)
{
nsIWidgetListener
*
listener
=
GetPaintListener
(
)
;
if
(
!
listener
)
{
return
false
;
}
bool
returnValue
=
listener
-
>
PaintWindow
(
this
aRegion
)
;
listener
=
GetPaintListener
(
)
;
if
(
listener
)
{
listener
-
>
DidPaintWindow
(
)
;
}
return
returnValue
;
}
bool
nsCocoaWindow
:
:
PaintWindowInDrawTarget
(
gfx
:
:
DrawTarget
*
aDT
const
LayoutDeviceIntRegion
&
aRegion
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
if
(
!
aDT
|
|
!
aDT
-
>
IsValid
(
)
)
{
return
false
;
}
gfxContext
targetContext
(
aDT
)
;
targetContext
.
NewPath
(
)
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
LayoutDeviceIntRect
&
r
=
iter
.
Get
(
)
;
targetContext
.
Rectangle
(
gfxRect
(
r
.
x
r
.
y
r
.
width
r
.
height
)
)
;
aDT
-
>
ClearRect
(
gfx
:
:
Rect
(
r
.
ToUnknownRect
(
)
)
)
;
}
targetContext
.
Clip
(
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
mChildView
)
;
if
(
GetWindowRenderer
(
)
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_NONE
)
{
nsBaseWidget
:
:
AutoLayerManagerSetup
setupLayerManager
(
this
&
targetContext
)
;
return
PaintWindow
(
aRegion
)
;
}
return
false
;
}
void
nsCocoaWindow
:
:
EnsureContentLayerForMainThreadPainting
(
)
{
auto
size
=
GetClientBounds
(
)
.
Size
(
)
;
if
(
mContentLayer
&
&
mContentLayer
-
>
GetSize
(
)
!
=
size
.
ToUnknownSize
(
)
)
{
mNativeLayerRoot
-
>
RemoveLayer
(
mContentLayer
)
;
mContentLayer
=
nullptr
;
}
if
(
!
mContentLayer
)
{
mPoolHandle
=
SurfacePool
:
:
Create
(
0
)
-
>
GetHandleForGL
(
nullptr
)
;
RefPtr
<
NativeLayer
>
contentLayer
=
mNativeLayerRoot
-
>
CreateLayer
(
size
.
ToUnknownSize
(
)
false
mPoolHandle
)
;
mNativeLayerRoot
-
>
AppendLayer
(
contentLayer
)
;
mContentLayer
=
contentLayer
-
>
AsNativeLayerCA
(
)
;
mContentLayer
-
>
SetSurfaceIsFlipped
(
false
)
;
mContentLayerInvalidRegion
=
LayoutDeviceIntRect
(
LayoutDeviceIntPoint
(
)
size
)
;
}
}
void
nsCocoaWindow
:
:
PaintWindowInContentLayer
(
)
{
EnsureContentLayerForMainThreadPainting
(
)
;
mPoolHandle
-
>
OnBeginFrame
(
)
;
RefPtr
<
DrawTarget
>
dt
=
mContentLayer
-
>
NextSurfaceAsDrawTarget
(
gfx
:
:
IntRect
(
{
}
mContentLayer
-
>
GetSize
(
)
)
mContentLayerInvalidRegion
.
ToUnknownRegion
(
)
gfx
:
:
BackendType
:
:
SKIA
)
;
if
(
!
dt
)
{
return
;
}
PaintWindowInDrawTarget
(
dt
mContentLayerInvalidRegion
dt
-
>
GetSize
(
)
)
;
mContentLayer
-
>
NotifySurfaceReady
(
)
;
mContentLayerInvalidRegion
.
SetEmpty
(
)
;
mPoolHandle
-
>
OnEndFrame
(
)
;
}
void
nsCocoaWindow
:
:
HandleMainThreadCATransaction
(
)
{
AUTO_PROFILER_TRACING_MARKER
(
"
Paint
"
"
HandleMainThreadCATransaction
"
GRAPHICS
)
;
WillPaintWindow
(
)
;
if
(
GetWindowRenderer
(
)
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_NONE
)
{
PaintWindowInContentLayer
(
)
;
}
else
{
PaintWindow
(
LayoutDeviceIntRegion
(
GetClientBounds
(
)
)
)
;
}
{
MutexAutoLock
lock
(
mCompositingLock
)
;
mNativeLayerRoot
-
>
CommitToScreen
(
)
;
}
MaybeScheduleUnsuspendAsyncCATransactions
(
)
;
}
bool
nsCocoaWindow
:
:
DoHasPendingInputEvent
(
)
{
return
sLastInputEventCount
!
=
GetCurrentInputEventCount
(
)
;
}
uint32_t
nsCocoaWindow
:
:
GetCurrentInputEventCount
(
)
{
static
const
CGEventType
eventTypes
[
]
=
{
kCGEventLeftMouseDown
kCGEventLeftMouseUp
kCGEventRightMouseDown
kCGEventRightMouseUp
kCGEventMouseMoved
kCGEventLeftMouseDragged
kCGEventRightMouseDragged
kCGEventKeyDown
kCGEventKeyUp
kCGEventScrollWheel
kCGEventTabletPointer
kCGEventOtherMouseDown
kCGEventOtherMouseUp
kCGEventOtherMouseDragged
}
;
uint32_t
eventCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
std
:
:
size
(
eventTypes
)
;
+
+
i
)
{
eventCount
+
=
CGEventSourceCounterForEventType
(
kCGEventSourceStateCombinedSessionState
eventTypes
[
i
]
)
;
}
return
eventCount
;
}
void
nsCocoaWindow
:
:
UpdateCurrentInputEventCount
(
)
{
sLastInputEventCount
=
GetCurrentInputEventCount
(
)
;
}
#
pragma
mark
-
void
nsCocoaWindow
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
NS_ENSURE_TRUE_VOID
(
mTextInputHandler
)
;
if
(
mTextInputHandler
-
>
IsFocused
(
)
)
{
if
(
aContext
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
}
mInputContext
=
aContext
;
switch
(
aContext
.
mIMEState
.
mEnabled
)
{
case
IMEEnabled
:
:
Enabled
:
mTextInputHandler
-
>
SetASCIICapableOnly
(
false
)
;
mTextInputHandler
-
>
EnableIME
(
true
)
;
if
(
mInputContext
.
mIMEState
.
mOpen
!
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
)
{
mTextInputHandler
-
>
SetIMEOpenState
(
mInputContext
.
mIMEState
.
mOpen
=
=
IMEState
:
:
OPEN
)
;
}
mTextInputHandler
-
>
EnableTextSubstitution
(
aContext
.
mAutocorrect
)
;
break
;
case
IMEEnabled
:
:
Disabled
:
mTextInputHandler
-
>
SetASCIICapableOnly
(
false
)
;
mTextInputHandler
-
>
EnableIME
(
false
)
;
mTextInputHandler
-
>
EnableTextSubstitution
(
false
)
;
break
;
case
IMEEnabled
:
:
Password
:
mTextInputHandler
-
>
SetASCIICapableOnly
(
true
)
;
mTextInputHandler
-
>
EnableIME
(
false
)
;
mTextInputHandler
-
>
EnableTextSubstitution
(
aContext
.
mAutocorrect
)
;
break
;
default
:
NS_ERROR
(
"
not
implemented
!
"
)
;
}
}
InputContext
nsCocoaWindow
:
:
GetInputContext
(
)
{
switch
(
mInputContext
.
mIMEState
.
mEnabled
)
{
case
IMEEnabled
:
:
Enabled
:
if
(
mTextInputHandler
)
{
mInputContext
.
mIMEState
.
mOpen
=
mTextInputHandler
-
>
IsIMEOpened
(
)
?
IMEState
:
:
OPEN
:
IMEState
:
:
CLOSED
;
break
;
}
[
[
fallthrough
]
]
;
default
:
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
CLOSED
;
break
;
}
return
mInputContext
;
}
TextEventDispatcherListener
*
nsCocoaWindow
:
:
GetNativeTextEventDispatcherListener
(
)
{
if
(
NS_WARN_IF
(
!
mTextInputHandler
)
)
{
return
nullptr
;
}
return
mTextInputHandler
;
}
nsresult
nsCocoaWindow
:
:
AttachNativeKeyEvent
(
mozilla
:
:
WidgetKeyboardEvent
&
aEvent
)
{
NS_ENSURE_TRUE
(
mTextInputHandler
NS_ERROR_NOT_AVAILABLE
)
;
return
mTextInputHandler
-
>
AttachNativeKeyEvent
(
aEvent
)
;
}
NSView
<
mozView
>
*
nsCocoaWindow
:
:
GetEditorView
(
)
{
NSView
<
mozView
>
*
editorView
=
mChildView
;
WidgetQueryContentEvent
queryContentState
(
true
eQueryContentState
this
)
;
queryContentState
.
mNeedsToFlushLayout
=
false
;
DispatchWindowEvent
(
queryContentState
)
;
if
(
queryContentState
.
Succeeded
(
)
&
&
queryContentState
.
mReply
-
>
mFocusedWidget
)
{
NSView
<
mozView
>
*
view
=
static_cast
<
NSView
<
mozView
>
*
>
(
queryContentState
.
mReply
-
>
mFocusedWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
if
(
view
)
editorView
=
view
;
}
return
editorView
;
}
#
pragma
mark
-
bool
nsCocoaWindow
:
:
PreRender
(
WidgetRenderingContext
*
aContext
)
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
mCompositingLock
.
Lock
(
)
;
if
(
aContext
-
>
mGL
&
&
gfxPlatform
:
:
CanMigrateMacGPUs
(
)
)
{
GLContextCGL
:
:
Cast
(
aContext
-
>
mGL
)
-
>
MigrateToActiveGPU
(
)
;
}
return
true
;
}
void
nsCocoaWindow
:
:
PostRender
(
WidgetRenderingContext
*
aContext
)
MOZ_NO_THREAD_SAFETY_ANALYSIS
{
mCompositingLock
.
Unlock
(
)
;
}
RefPtr
<
layers
:
:
NativeLayerRoot
>
nsCocoaWindow
:
:
GetNativeLayerRoot
(
)
{
return
mNativeLayerRoot
;
}
static
LayoutDeviceIntRect
FindFirstRectOfType
(
const
nsTArray
<
nsIWidget
:
:
ThemeGeometry
>
&
aThemeGeometries
nsITheme
:
:
ThemeGeometryType
aThemeGeometryType
)
{
for
(
uint32_t
i
=
0
;
i
<
aThemeGeometries
.
Length
(
)
;
+
+
i
)
{
const
nsIWidget
:
:
ThemeGeometry
&
g
=
aThemeGeometries
[
i
]
;
if
(
g
.
mType
=
=
aThemeGeometryType
)
{
return
g
.
mRect
;
}
}
return
LayoutDeviceIntRect
(
)
;
}
void
nsCocoaWindow
:
:
UpdateThemeGeometries
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
if
(
!
mChildView
.
window
)
{
return
;
}
UpdateVibrancy
(
aThemeGeometries
)
;
if
(
!
[
mChildView
.
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
return
;
}
ToolbarWindow
*
win
=
(
ToolbarWindow
*
)
[
mChildView
window
]
;
LayoutDeviceIntRect
windowButtonRect
=
FindFirstRectOfType
(
aThemeGeometries
eThemeGeometryTypeWindowButtons
)
;
[
win
placeWindowButtons
:
[
mChildView
convertRect
:
DevPixelsToCocoaPoints
(
windowButtonRect
)
toView
:
nil
]
]
;
}
static
Maybe
<
VibrancyType
>
ThemeGeometryTypeToVibrancyType
(
nsITheme
:
:
ThemeGeometryType
aThemeGeometryType
)
{
switch
(
aThemeGeometryType
)
{
case
eThemeGeometryTypeSidebar
:
return
Some
(
VibrancyType
:
:
Sidebar
)
;
case
eThemeGeometryTypeTitlebar
:
return
Some
(
VibrancyType
:
:
Titlebar
)
;
default
:
return
Nothing
(
)
;
}
}
static
EnumeratedArray
<
VibrancyType
LayoutDeviceIntRegion
>
GatherVibrantRegions
(
Span
<
const
nsIWidget
:
:
ThemeGeometry
>
aThemeGeometries
)
{
EnumeratedArray
<
VibrancyType
LayoutDeviceIntRegion
>
regions
;
for
(
const
auto
&
geometry
:
aThemeGeometries
)
{
auto
vibrancyType
=
ThemeGeometryTypeToVibrancyType
(
geometry
.
mType
)
;
if
(
!
vibrancyType
)
{
continue
;
}
regions
[
*
vibrancyType
]
.
OrWith
(
geometry
.
mRect
)
;
}
return
regions
;
}
static
void
MakeRegionsNonOverlapping
(
Span
<
LayoutDeviceIntRegion
>
aRegions
)
{
LayoutDeviceIntRegion
unionOfAll
;
for
(
auto
&
region
:
aRegions
)
{
region
.
SubOut
(
unionOfAll
)
;
unionOfAll
.
OrWith
(
region
)
;
}
}
void
nsCocoaWindow
:
:
UpdateVibrancy
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
auto
regions
=
GatherVibrantRegions
(
aThemeGeometries
)
;
MakeRegionsNonOverlapping
(
regions
)
;
auto
&
vm
=
EnsureVibrancyManager
(
)
;
bool
changed
=
false
;
size_t
i
=
0
;
for
(
const
auto
&
region
:
regions
)
{
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
(
i
+
+
)
region
)
;
}
if
(
changed
)
{
SuspendAsyncCATransactions
(
)
;
}
}
mozilla
:
:
VibrancyManager
&
nsCocoaWindow
:
:
EnsureVibrancyManager
(
)
{
MOZ_ASSERT
(
mChildView
"
Only
call
this
once
we
have
a
view
!
"
)
;
if
(
!
mVibrancyManager
)
{
mVibrancyManager
=
MakeUnique
<
VibrancyManager
>
(
*
this
mChildView
.
vibrancyViewsContainer
)
;
}
return
*
mVibrancyManager
;
}
interface
NonDraggableView
:
NSView
end
implementation
NonDraggableView
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
NO
;
}
-
(
NSView
*
)
hitTest
:
(
NSPoint
)
aPoint
{
return
nil
;
}
-
(
NSRect
)
_opaqueRectForWindowMoveWhenInTitlebar
{
return
self
.
bounds
;
}
end
void
nsCocoaWindow
:
:
UpdateWindowDraggingRegion
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
LayoutDeviceIntRegion
nonDraggable
;
nonDraggable
.
Sub
(
LayoutDeviceIntRect
(
0
0
mBounds
.
width
mBounds
.
height
)
aRegion
)
;
__block
bool
changed
=
false
;
ManipulateViewWithoutNeedingDisplay
(
mChildView
^
(
)
{
changed
=
mNonDraggableRegion
.
UpdateRegion
(
nonDraggable
*
this
mChildView
.
nonDraggableViewsContainer
^
(
)
{
return
[
[
NonDraggableView
alloc
]
initWithFrame
:
NSZeroRect
]
;
}
)
;
}
)
;
if
(
changed
)
{
[
[
mChildView
window
]
setMovableByWindowBackground
:
NO
]
;
[
[
mChildView
window
]
setMovableByWindowBackground
:
YES
]
;
}
}
nsEventStatus
nsCocoaWindow
:
:
DispatchAPZInputEvent
(
InputData
&
aEvent
)
{
APZEventResult
result
;
if
(
mAPZC
)
{
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aEvent
)
;
}
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
result
.
GetStatus
(
)
;
}
if
(
aEvent
.
mInputType
=
=
PINCHGESTURE_INPUT
)
{
PinchGestureInput
&
pinchEvent
=
aEvent
.
AsPinchGestureInput
(
)
;
WidgetWheelEvent
wheelEvent
=
pinchEvent
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
wheelEvent
result
)
;
}
else
if
(
aEvent
.
mInputType
=
=
TAPGESTURE_INPUT
)
{
TapGestureInput
&
tapEvent
=
aEvent
.
AsTapGestureInput
(
)
;
WidgetSimpleGestureEvent
gestureEvent
=
tapEvent
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
gestureEvent
result
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
)
;
}
return
result
.
GetStatus
(
)
;
}
void
nsCocoaWindow
:
:
DispatchAPZWheelInputEvent
(
InputData
&
aEvent
)
{
if
(
mSwipeTracker
&
&
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
)
{
nsEventStatus
status
=
mSwipeTracker
-
>
ProcessEvent
(
aEvent
.
AsPanGestureInput
(
)
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
}
WidgetWheelEvent
event
(
true
eWheel
this
)
;
if
(
mAPZC
)
{
APZEventResult
result
;
switch
(
aEvent
.
mInputType
)
{
case
PANGESTURE_INPUT
:
{
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aEvent
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
event
=
MayStartSwipeForAPZ
(
aEvent
.
AsPanGestureInput
(
)
result
)
;
break
;
}
case
SCROLLWHEEL_INPUT
:
{
event
=
aEvent
.
AsScrollWheelInput
(
)
.
ToWidgetEvent
(
this
)
;
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
event
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
break
;
}
;
default
:
MOZ_CRASH
(
"
unsupported
event
type
"
)
;
return
;
}
if
(
event
.
mMessage
=
=
eWheel
&
&
(
event
.
mDeltaX
!
=
0
|
|
event
.
mDeltaY
!
=
0
)
)
{
ProcessUntransformedAPZEvent
(
&
event
result
)
;
}
return
;
}
nsEventStatus
status
;
switch
(
aEvent
.
mInputType
)
{
case
PANGESTURE_INPUT
:
{
if
(
MayStartSwipeForNonAPZ
(
aEvent
.
AsPanGestureInput
(
)
)
)
{
return
;
}
event
=
aEvent
.
AsPanGestureInput
(
)
.
ToWidgetEvent
(
this
)
;
break
;
}
case
SCROLLWHEEL_INPUT
:
{
event
=
aEvent
.
AsScrollWheelInput
(
)
.
ToWidgetEvent
(
this
)
;
break
;
}
default
:
MOZ_CRASH
(
"
unexpected
event
type
"
)
;
return
;
}
if
(
event
.
mMessage
=
=
eWheel
&
&
(
event
.
mDeltaX
!
=
0
|
|
event
.
mDeltaY
!
=
0
)
)
{
DispatchEvent
(
&
event
status
)
;
}
}
void
nsCocoaWindow
:
:
DispatchDoubleTapGesture
(
TimeStamp
aEventTimeStamp
LayoutDeviceIntPoint
aScreenPosition
mozilla
:
:
Modifiers
aModifiers
)
{
if
(
StaticPrefs
:
:
apz_mac_enable_double_tap_zoom_touchpad_gesture
(
)
)
{
TapGestureInput
event
{
TapGestureInput
:
:
TAPGESTURE_DOUBLE
aEventTimeStamp
ViewAs
<
ScreenPixel
>
(
aScreenPosition
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
aModifiers
}
;
DispatchAPZInputEvent
(
event
)
;
}
else
{
WidgetSimpleGestureEvent
geckoEvent
(
true
eTapGesture
this
)
;
geckoEvent
.
mRefPoint
=
aScreenPosition
;
geckoEvent
.
mModifiers
=
aModifiers
;
geckoEvent
.
mTimeStamp
=
aEventTimeStamp
;
geckoEvent
.
mClickCount
=
1
;
DispatchWindowEvent
(
geckoEvent
)
;
}
}
void
nsCocoaWindow
:
:
LookUpDictionary
(
const
nsAString
&
aText
const
nsTArray
<
mozilla
:
:
FontRange
>
&
aFontRangeArray
const
bool
aIsVertical
const
LayoutDeviceIntPoint
&
aPoint
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSMutableAttributedString
*
attrStr
=
nsCocoaUtils
:
:
GetNSMutableAttributedString
(
aText
aFontRangeArray
aIsVertical
BackingScaleFactor
(
)
)
;
NSPoint
pt
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
aPoint
BackingScaleFactor
(
)
)
;
NSDictionary
*
attributes
=
[
attrStr
attributesAtIndex
:
0
effectiveRange
:
nil
]
;
NSFont
*
font
=
[
attributes
objectForKey
:
NSFontAttributeName
]
;
if
(
font
)
{
if
(
aIsVertical
)
{
pt
.
x
-
=
[
font
descender
]
;
}
else
{
pt
.
y
+
=
[
font
ascender
]
;
}
}
[
mChildView
showDefinitionForAttributedString
:
attrStr
atPoint
:
pt
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
ifdef
ACCESSIBILITY
already_AddRefed
<
a11y
:
:
LocalAccessible
>
nsCocoaWindow
:
:
GetDocumentAccessible
(
)
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
nullptr
;
if
(
mAccessible
&
&
mAccessible
-
>
IsAlive
(
)
)
{
RefPtr
<
a11y
:
:
LocalAccessible
>
ret
;
CallQueryReferent
(
mAccessible
.
get
(
)
static_cast
<
a11y
:
:
LocalAccessible
*
*
>
(
getter_AddRefs
(
ret
)
)
)
;
return
ret
.
forget
(
)
;
}
RefPtr
<
a11y
:
:
LocalAccessible
>
acc
=
GetRootAccessible
(
)
;
mAccessible
=
do_GetWeakReference
(
acc
.
get
(
)
)
;
return
acc
.
forget
(
)
;
}
#
endif
class
WidgetsReleaserRunnable
final
:
public
mozilla
:
:
Runnable
{
public
:
explicit
WidgetsReleaserRunnable
(
nsTArray
<
nsCOMPtr
<
nsIWidget
>
>
&
&
aWidgetArray
)
:
mozilla
:
:
Runnable
(
"
WidgetsReleaserRunnable
"
)
mWidgetArray
(
std
:
:
move
(
aWidgetArray
)
)
{
}
private
:
nsTArray
<
nsCOMPtr
<
nsIWidget
>
>
mWidgetArray
;
}
;
#
pragma
mark
-
interface
ViewRegionContainerView
:
NSView
{
}
end
implementation
ViewRegionContainerView
-
(
NSView
*
)
hitTest
:
(
NSPoint
)
aPoint
{
return
nil
;
}
-
(
BOOL
)
isFlipped
{
return
[
[
self
superview
]
isFlipped
]
;
}
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
[
[
self
superview
]
mouseDownCanMoveWindow
]
;
}
end
implementation
ChildView
NSPasteboard
*
globalDragPboard
=
nil
;
NSView
*
gLastDragView
=
nil
;
NSEvent
*
gLastDragMouseDownEvent
=
nil
;
+
(
void
)
initialize
{
static
BOOL
initialized
=
NO
;
if
(
!
initialized
)
{
NSArray
*
types
=
[
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
;
[
NSApp
registerServicesMenuSendTypes
:
types
returnTypes
:
types
]
;
initialized
=
YES
;
}
}
+
(
void
)
registerViewForDraggedTypes
:
(
NSView
*
)
aView
{
[
aView
registerForDraggedTypes
:
[
NSArray
arrayWithObjects
:
[
UTIHelper
stringFromPboardType
:
NSFilenamesPboardType
]
[
UTIHelper
stringFromPboardType
:
kMozFileUrlsPboardType
]
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kPasteboardTypeFileURLPromise
]
[
UTIHelper
stringFromPboardType
:
kMozWildcardPboardType
]
[
UTIHelper
stringFromPboardType
:
kPublicUrlPboardType
]
[
UTIHelper
stringFromPboardType
:
kPublicUrlNamePboardType
]
[
UTIHelper
stringFromPboardType
:
kUrlsWithTitlesPboardType
]
nil
]
]
;
}
-
(
id
)
initWithFrame
:
(
NSRect
)
inFrame
geckoChild
:
(
nsCocoaWindow
*
)
inChild
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
(
self
=
[
super
initWithFrame
:
inFrame
]
)
)
{
mGeckoChild
=
inChild
;
mBlockedLastMouseDown
=
NO
;
mExpectingWheelStop
=
NO
;
mLastMouseDownEvent
=
nil
;
mLastKeyDownEvent
=
nil
;
mClickThroughMouseDownEvent
=
nil
;
mDragService
=
nullptr
;
mGestureState
=
eGestureState_None
;
mCumulativeRotation
=
0
.
0
;
mIsUpdatingLayer
=
NO
;
[
self
setFocusRingType
:
NSFocusRingTypeNone
]
;
#
ifdef
__LP64__
mCancelSwipeAnimation
=
nil
;
#
endif
auto
bounds
=
self
.
bounds
;
mNonDraggableViewsContainer
=
[
[
ViewRegionContainerView
alloc
]
initWithFrame
:
bounds
]
;
mVibrancyViewsContainer
=
[
[
ViewRegionContainerView
alloc
]
initWithFrame
:
bounds
]
;
mNonDraggableViewsContainer
.
autoresizingMask
=
mVibrancyViewsContainer
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewHeightSizable
;
[
self
addSubview
:
mNonDraggableViewsContainer
]
;
[
self
addSubview
:
mVibrancyViewsContainer
]
;
mPixelHostingView
=
[
[
PixelHostingView
alloc
]
initWithFrame
:
bounds
]
;
mPixelHostingView
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewHeightSizable
;
[
self
addSubview
:
mPixelHostingView
]
;
mRootCALayer
=
[
[
CALayer
layer
]
retain
]
;
mRootCALayer
.
position
=
NSZeroPoint
;
mRootCALayer
.
bounds
=
NSZeroRect
;
mRootCALayer
.
anchorPoint
=
NSZeroPoint
;
mRootCALayer
.
contentsGravity
=
kCAGravityTopLeft
;
[
mPixelHostingView
.
layer
addSublayer
:
mRootCALayer
]
;
mLastPressureStage
=
0
;
}
[
ChildView
registerViewForDraggedTypes
:
self
]
;
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
NSTextInputContext
*
)
inputContext
{
if
(
!
mGeckoChild
)
{
return
nil
;
}
return
[
super
inputContext
]
;
}
-
(
void
)
installTextInputHandler
:
(
TextInputHandler
*
)
aHandler
{
mTextInputHandler
=
aHandler
;
}
-
(
void
)
uninstallTextInputHandler
{
mTextInputHandler
=
nullptr
;
}
-
(
NSView
*
)
vibrancyViewsContainer
{
return
mVibrancyViewsContainer
;
}
-
(
NSView
*
)
nonDraggableViewsContainer
{
return
mNonDraggableViewsContainer
;
}
-
(
NSView
*
)
pixelHostingView
{
return
mPixelHostingView
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
mLastMouseDownEvent
release
]
;
[
mLastKeyDownEvent
release
]
;
[
mClickThroughMouseDownEvent
release
]
;
ChildViewMouseTracker
:
:
OnDestroyView
(
self
)
;
[
mVibrancyViewsContainer
removeFromSuperview
]
;
[
mVibrancyViewsContainer
release
]
;
[
mNonDraggableViewsContainer
removeFromSuperview
]
;
[
mNonDraggableViewsContainer
release
]
;
[
mPixelHostingView
removeFromSuperview
]
;
[
mPixelHostingView
release
]
;
[
mRootCALayer
release
]
;
if
(
gLastDragView
=
=
self
)
{
gLastDragView
=
nil
;
}
[
super
dealloc
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
widgetDestroyed
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
OnDestroyWidget
(
mGeckoChild
)
;
mTextInputHandler
=
nullptr
;
}
mGeckoChild
=
nullptr
;
NS_IF_RELEASE
(
mDragService
)
;
}
-
(
nsIWidget
*
)
widget
{
return
static_cast
<
nsIWidget
*
>
(
mGeckoChild
)
;
}
-
(
NSString
*
)
description
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
[
NSString
stringWithFormat
:
"
ChildView
%
p
gecko
child
%
p
frame
%
"
self
mGeckoChild
NSStringFromRect
(
[
self
frame
]
)
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
BOOL
)
isFlipped
{
return
YES
;
}
-
(
BOOL
)
acceptsFirstResponder
{
return
YES
;
}
-
(
BOOL
)
acceptsFirstMouse
:
(
NSEvent
*
)
aEvent
{
if
(
!
[
[
self
window
]
isKindOfClass
:
[
PopupWindow
class
]
]
)
{
mClickThroughMouseDownEvent
=
[
aEvent
retain
]
;
}
return
YES
;
}
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
YES
;
}
-
(
void
)
viewDidChangeBackingProperties
{
[
super
viewDidChangeBackingProperties
]
;
if
(
mGeckoChild
)
{
mGeckoChild
-
>
BackingScaleFactorChanged
(
)
;
}
}
-
(
void
)
showContextMenuForSelection
:
(
id
)
sender
{
if
(
!
mGeckoChild
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
WidgetPointerEvent
geckoEvent
(
true
eContextMenu
mGeckoChild
WidgetMouseEvent
:
:
eContextMenuKey
)
;
geckoEvent
.
mRefPoint
=
{
}
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
-
(
void
)
viewWillStartLiveResize
{
nsCocoaWindow
*
windowWidget
=
mGeckoChild
;
if
(
windowWidget
)
{
windowWidget
-
>
NotifyLiveResizeStarted
(
)
;
}
}
-
(
void
)
viewDidEndLiveResize
{
nsCocoaWindow
*
windowWidget
=
mGeckoChild
;
if
(
windowWidget
)
{
windowWidget
-
>
NotifyLiveResizeStopped
(
)
;
}
}
-
(
void
)
markLayerForDisplay
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mIsUpdatingLayer
)
{
[
mPixelHostingView
.
layer
setNeedsDisplay
]
;
}
}
-
(
void
)
ensureNextCompositeIsAtomicWithMainThreadPaint
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mGeckoChild
)
{
mGeckoChild
-
>
SuspendAsyncCATransactions
(
)
;
}
}
-
(
void
)
updateRootCALayer
{
if
(
NS_IsMainThread
(
)
&
&
mGeckoChild
)
{
MOZ_RELEASE_ASSERT
(
!
mIsUpdatingLayer
"
Re
-
entrant
layer
display
?
"
)
;
mIsUpdatingLayer
=
YES
;
mGeckoChild
-
>
HandleMainThreadCATransaction
(
)
;
mIsUpdatingLayer
=
NO
;
}
}
-
(
CALayer
*
)
rootCALayer
{
return
mRootCALayer
;
}
-
(
void
)
maybeInitContextMenuTracking
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mozilla
:
:
widget
:
:
NativeMenuSupport
:
:
ShouldUseNativeContextMenus
(
)
)
{
return
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
NS_ENSURE_TRUE_VOID
(
rollupListener
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
rollupListener
-
>
GetRollupWidget
(
)
;
NS_ENSURE_TRUE_VOID
(
widget
)
;
NSWindow
*
popupWindow
=
(
NSWindow
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
!
popupWindow
|
|
!
[
popupWindow
isKindOfClass
:
[
PopupWindow
class
]
]
)
return
;
[
[
NSDistributedNotificationCenter
defaultCenter
]
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
beginMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
[
(
PopupWindow
*
)
popupWindow
setIsContextMenu
:
YES
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
maybeRollup
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
BOOL
consumeEvent
=
NO
;
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
NS_ENSURE_TRUE
(
rollupListener
false
)
;
BOOL
isWheelTypeEvent
=
[
theEvent
type
]
=
=
NSEventTypeScrollWheel
|
|
[
theEvent
type
]
=
=
NSEventTypeMagnify
|
|
[
theEvent
type
]
=
=
NSEventTypeSmartMagnify
;
if
(
!
isWheelTypeEvent
&
&
rollupListener
-
>
RollupNativeMenu
(
)
)
{
return
NO
;
}
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
!
rollupWidget
)
{
return
consumeEvent
;
}
NSWindow
*
currentPopup
=
static_cast
<
NSWindow
*
>
(
rollupWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
if
(
nsCocoaUtils
:
:
IsEventOverWindow
(
theEvent
currentPopup
)
)
{
return
consumeEvent
;
}
if
(
isWheelTypeEvent
)
{
consumeEvent
=
rollupListener
-
>
ShouldConsumeOnMouseWheelEvent
(
)
;
if
(
!
rollupListener
-
>
ShouldRollupOnMouseWheelEvent
(
)
)
{
return
consumeEvent
;
}
}
uint32_t
popupsToRollup
=
UINT32_MAX
;
AutoTArray
<
nsIWidget
*
5
>
widgetChain
;
uint32_t
sameTypeCount
=
rollupListener
-
>
GetSubmenuWidgetChain
(
&
widgetChain
)
;
for
(
uint32_t
i
=
0
;
i
<
widgetChain
.
Length
(
)
;
i
+
+
)
{
nsIWidget
*
widget
=
widgetChain
[
i
]
;
NSWindow
*
currWindow
=
(
NSWindow
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
nsCocoaUtils
:
:
IsEventOverWindow
(
theEvent
currWindow
)
)
{
if
(
i
<
sameTypeCount
)
{
return
consumeEvent
;
}
popupsToRollup
=
sameTypeCount
;
break
;
}
}
LayoutDeviceIntPoint
devPoint
;
nsIRollupListener
:
:
RollupOptions
rollupOptions
{
popupsToRollup
nsIRollupListener
:
:
FlushViews
:
:
Yes
}
;
if
(
[
theEvent
type
]
=
=
NSEventTypeLeftMouseDown
)
{
NSPoint
point
=
[
NSEvent
mouseLocation
]
;
FlipCocoaScreenCoordinate
(
point
)
;
devPoint
=
mGeckoChild
-
>
CocoaPointsToDevPixels
(
point
)
;
rollupOptions
.
mPoint
=
&
devPoint
;
}
consumeEvent
=
(
BOOL
)
rollupListener
-
>
Rollup
(
rollupOptions
)
;
return
consumeEvent
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
void
)
swipeWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
float
deltaX
=
[
anEvent
deltaX
]
;
float
deltaY
=
[
anEvent
deltaY
]
;
WidgetSimpleGestureEvent
geckoEvent
(
true
eSwipeGesture
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
if
(
deltaX
>
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_LEFT
;
else
if
(
deltaX
<
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_RIGHT
;
if
(
deltaY
>
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_UP
;
else
if
(
deltaY
<
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_DOWN
;
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
magnifyWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
[
self
maybeRollup
:
anEvent
]
)
{
return
;
}
if
(
!
mGeckoChild
)
{
return
;
}
if
(
mGestureState
=
=
eGestureState_RotateGesture
&
&
[
anEvent
phase
]
!
=
NSEventPhaseBegan
)
{
return
;
}
mGestureState
=
eGestureState_MagnifyGesture
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
anEvent
[
self
window
]
)
;
ScreenPoint
position
=
ViewAs
<
ScreenPixel
>
(
[
self
convertWindowCoordinatesRoundDown
:
locationInWindow
]
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
ExternalPoint
screenOffset
=
ViewAs
<
ExternalPixel
>
(
mGeckoChild
-
>
WidgetToScreenOffset
(
)
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
TimeStamp
eventTimeStamp
=
nsCocoaUtils
:
:
GetEventTimeStamp
(
[
anEvent
timestamp
]
)
;
NSEventPhase
eventPhase
=
[
anEvent
phase
]
;
PinchGestureInput
:
:
PinchGestureType
pinchGestureType
;
switch
(
eventPhase
)
{
case
NSEventPhaseBegan
:
{
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_START
;
break
;
}
case
NSEventPhaseChanged
:
{
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_SCALE
;
break
;
}
case
NSEventPhaseEnded
:
{
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_END
;
mGestureState
=
eGestureState_None
;
break
;
}
default
:
{
NS_WARNING
(
"
Unexpected
phase
for
pinch
gesture
event
.
"
)
;
return
;
}
}
PinchGestureInput
event
{
pinchGestureType
PinchGestureInput
:
:
TRACKPAD
eventTimeStamp
screenOffset
position
100
.
0
100
.
0
*
(
1
.
0
-
[
anEvent
magnification
]
)
nsCocoaUtils
:
:
ModifiersForEvent
(
anEvent
)
}
;
mGeckoChild
-
>
DispatchAPZInputEvent
(
event
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
smartMagnifyWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
|
|
[
self
beginOrEndGestureForEventPhase
:
anEvent
]
)
{
return
;
}
if
(
[
self
maybeRollup
:
anEvent
]
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
StaticPrefs
:
:
apz_mac_enable_double_tap_zoom_touchpad_gesture
(
)
)
{
TimeStamp
eventTimeStamp
=
nsCocoaUtils
:
:
GetEventTimeStamp
(
[
anEvent
timestamp
]
)
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
anEvent
[
self
window
]
)
;
LayoutDevicePoint
position
=
[
self
convertWindowCoordinatesRoundDown
:
locationInWindow
]
;
mGeckoChild
-
>
DispatchDoubleTapGesture
(
eventTimeStamp
RoundedToInt
(
position
)
nsCocoaUtils
:
:
ModifiersForEvent
(
anEvent
)
)
;
}
else
{
WidgetSimpleGestureEvent
geckoEvent
(
true
eTapGesture
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mClickCount
=
1
;
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
}
mGestureState
=
eGestureState_None
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rotateWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
|
|
[
self
beginOrEndGestureForEventPhase
:
anEvent
]
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
float
rotation
=
[
anEvent
rotation
]
;
EventMessage
msg
;
switch
(
mGestureState
)
{
case
eGestureState_StartGesture
:
msg
=
eRotateGestureStart
;
mGestureState
=
eGestureState_RotateGesture
;
break
;
case
eGestureState_RotateGesture
:
msg
=
eRotateGestureUpdate
;
break
;
case
eGestureState_None
:
case
eGestureState_MagnifyGesture
:
default
:
return
;
}
WidgetSimpleGestureEvent
geckoEvent
(
true
msg
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mDelta
=
-
rotation
;
if
(
rotation
>
0
.
0
)
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_COUNTERCLOCKWISE
;
}
else
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_CLOCKWISE
;
}
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
mCumulativeRotation
+
=
rotation
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
bool
)
beginOrEndGestureForEventPhase
:
(
NSEvent
*
)
aEvent
{
if
(
!
aEvent
)
{
return
false
;
}
if
(
aEvent
.
phase
=
=
NSEventPhaseBegan
)
{
[
self
beginGestureWithEvent
:
aEvent
]
;
return
true
;
}
if
(
aEvent
.
phase
=
=
NSEventPhaseEnded
|
|
aEvent
.
phase
=
=
NSEventPhaseCancelled
)
{
[
self
endGestureWithEvent
:
aEvent
]
;
return
true
;
}
return
false
;
}
-
(
void
)
beginGestureWithEvent
:
(
NSEvent
*
)
aEvent
{
if
(
!
aEvent
)
{
return
;
}
mGestureState
=
eGestureState_StartGesture
;
mCumulativeRotation
=
0
.
0
;
}
-
(
void
)
endGestureWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
)
{
mGestureState
=
eGestureState_None
;
mCumulativeRotation
=
0
.
0
;
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
switch
(
mGestureState
)
{
case
eGestureState_RotateGesture
:
{
WidgetSimpleGestureEvent
geckoEvent
(
true
eRotateGesture
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mDelta
=
-
mCumulativeRotation
;
if
(
mCumulativeRotation
>
0
.
0
)
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_COUNTERCLOCKWISE
;
}
else
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_CLOCKWISE
;
}
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
}
break
;
case
eGestureState_MagnifyGesture
:
case
eGestureState_None
:
case
eGestureState_StartGesture
:
default
:
break
;
}
mGestureState
=
eGestureState_None
;
mCumulativeRotation
=
0
.
0
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
shouldDelayWindowOrderingForEvent
:
(
NSEvent
*
)
aEvent
{
if
(
!
[
[
self
window
]
isKindOfClass
:
[
PopupWindow
class
]
]
)
return
NO
;
return
!
[
[
self
window
]
parentWindow
]
;
}
-
(
void
)
mouseDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mPerformedDrag
=
NO
;
if
(
[
self
shouldDelayWindowOrderingForEvent
:
theEvent
]
)
{
[
NSApp
preventWindowOrdering
]
;
}
if
(
mLastMouseDownEvent
=
=
theEvent
)
{
[
mLastMouseDownEvent
release
]
;
mLastMouseDownEvent
=
nil
;
return
;
}
else
{
[
mLastMouseDownEvent
release
]
;
mLastMouseDownEvent
=
[
theEvent
retain
]
;
}
[
gLastDragMouseDownEvent
release
]
;
gLastDragMouseDownEvent
=
[
theEvent
retain
]
;
gLastDragView
=
self
;
BOOL
isClickThrough
=
(
theEvent
=
=
mClickThroughMouseDownEvent
)
;
[
mClickThroughMouseDownEvent
release
]
;
mClickThroughMouseDownEvent
=
nil
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
[
self
maybeRollup
:
theEvent
]
|
|
!
ChildViewMouseTracker
:
:
WindowAcceptsEvent
(
[
self
window
]
theEvent
self
isClickThrough
)
)
{
mBlockedLastMouseDown
=
YES
;
return
;
}
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseDown
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
NSInteger
clickCount
=
[
theEvent
clickCount
]
;
if
(
mBlockedLastMouseDown
&
&
clickCount
>
1
)
{
clickCount
-
-
;
}
geckoEvent
.
mClickCount
=
clickCount
;
if
(
!
StaticPrefs
:
:
dom_event_treat_ctrl_click_as_right_click_disabled
(
)
&
&
geckoEvent
.
IsControl
(
)
)
{
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
}
else
{
geckoEvent
.
mButton
=
MouseButton
:
:
ePrimary
;
geckoEvent
.
mClickEventPrevented
=
geckoEvent
.
IsControl
(
)
;
}
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
mBlockedLastMouseDown
=
NO
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
mouseUp
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
gLastDragView
=
nil
;
if
(
!
mGeckoChild
|
|
mBlockedLastMouseDown
|
|
mPerformedDrag
)
{
return
;
}
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
WidgetMouseEvent
geckoEvent
(
true
eMouseUp
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
if
(
!
StaticPrefs
:
:
dom_event_treat_ctrl_click_as_right_click_disabled
(
)
&
&
(
[
theEvent
modifierFlags
]
&
NSEventModifierFlagControl
)
)
{
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
}
else
{
geckoEvent
.
mButton
=
MouseButton
:
:
ePrimary
;
}
LayoutDeviceIntPoint
pos
=
geckoEvent
.
mRefPoint
;
bool
defaultPrevented
=
(
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
.
mContentStatus
=
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
!
mGeckoChild
)
{
return
;
}
if
(
!
defaultPrevented
&
&
[
theEvent
clickCount
]
=
=
2
&
&
!
mGeckoChild
-
>
GetNonDraggableRegion
(
)
.
Contains
(
pos
.
x
pos
.
y
)
)
{
if
(
nsCocoaUtils
:
:
ShouldZoomOnTitlebarDoubleClick
(
)
)
{
[
[
self
window
]
performZoom
:
nil
]
;
}
else
if
(
nsCocoaUtils
:
:
ShouldMinimizeOnTitlebarDoubleClick
(
)
)
{
[
[
self
window
]
performMiniaturize
:
nil
]
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
sendMouseEnterOrExitEvent
:
(
NSEvent
*
)
aEvent
enter
:
(
BOOL
)
aEnter
exitFrom
:
(
WidgetMouseEvent
:
:
ExitFrom
)
aExitFrom
{
if
(
!
mGeckoChild
)
return
;
NSPoint
windowEventLocation
=
nsCocoaUtils
:
:
EventLocationForWindow
(
aEvent
[
self
window
]
)
;
NSPoint
localEventLocation
=
[
self
convertPoint
:
windowEventLocation
fromView
:
nil
]
;
EventMessage
msg
=
aEnter
?
eMouseEnterIntoWidget
:
eMouseExitFromWidget
;
WidgetMouseEvent
event
(
true
msg
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
aEvent
toGeckoEvent
:
&
event
]
;
event
.
mRefPoint
=
mGeckoChild
-
>
CocoaPointsToDevPixels
(
localEventLocation
)
;
if
(
event
.
mMessage
=
=
eMouseExitFromWidget
)
{
event
.
mExitFrom
=
Some
(
aExitFrom
)
;
}
nsEventStatus
status
;
mGeckoChild
-
>
DispatchEvent
(
&
event
status
)
;
}
-
(
void
)
handleMouseMoved
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
mouseDragged
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rightMouseDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mPerformedDrag
=
NO
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
[
self
maybeRollup
:
theEvent
]
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseDown
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
geckoEvent
.
mClickCount
=
[
theEvent
clickCount
]
;
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
;
if
(
!
StaticPrefs
:
:
ui_context_menus_after_mouseup
(
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
[
super
rightMouseDown
:
theEvent
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rightMouseUp
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseUp
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
geckoEvent
.
mClickCount
=
[
theEvent
clickCount
]
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
;
if
(
StaticPrefs
:
:
ui_context_menus_after_mouseup
(
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
NSEvent
*
dupeEvent
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
theEvent
.
locationInWindow
modifierFlags
:
theEvent
.
modifierFlags
timestamp
:
theEvent
.
timestamp
windowNumber
:
theEvent
.
windowNumber
context
:
nil
eventNumber
:
theEvent
.
eventNumber
clickCount
:
theEvent
.
clickCount
pressure
:
theEvent
.
pressure
]
;
[
super
rightMouseDown
:
dupeEvent
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rightMouseDragged
:
(
NSEvent
*
)
theEvent
{
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
static
bool
ShouldDispatchBackForwardCommandForMouseButton
(
int16_t
aButton
)
{
return
(
aButton
=
=
MouseButton
:
:
eX1
&
&
Preferences
:
:
GetBool
(
"
mousebutton
.
4th
.
enabled
"
true
)
)
|
|
(
aButton
=
=
MouseButton
:
:
eX2
&
&
Preferences
:
:
GetBool
(
"
mousebutton
.
5th
.
enabled
"
true
)
)
;
}
-
(
void
)
otherMouseDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mPerformedDrag
=
NO
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
[
self
maybeRollup
:
theEvent
]
|
|
!
ChildViewMouseTracker
:
:
WindowAcceptsEvent
(
[
self
window
]
theEvent
self
)
)
return
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
int16_t
button
=
nsCocoaUtils
:
:
ButtonForEvent
(
theEvent
)
;
if
(
ShouldDispatchBackForwardCommandForMouseButton
(
button
)
)
{
WidgetCommandEvent
appCommandEvent
(
true
(
button
=
=
MouseButton
:
:
eX2
)
?
nsGkAtoms
:
:
Forward
:
nsGkAtoms
:
:
Back
mGeckoChild
)
;
mGeckoChild
-
>
DispatchWindowEvent
(
appCommandEvent
)
;
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseDown
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
button
;
geckoEvent
.
mClickCount
=
[
theEvent
clickCount
]
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
otherMouseUp
:
(
NSEvent
*
)
theEvent
{
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
int16_t
button
=
nsCocoaUtils
:
:
ButtonForEvent
(
theEvent
)
;
if
(
ShouldDispatchBackForwardCommandForMouseButton
(
button
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseUp
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
button
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
-
(
void
)
otherMouseDragged
:
(
NSEvent
*
)
theEvent
{
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
int16_t
button
=
nsCocoaUtils
:
:
ButtonForEvent
(
theEvent
)
;
geckoEvent
.
mButton
=
button
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
-
(
void
)
sendWheelStartOrStop
:
(
EventMessage
)
msg
forEvent
:
(
NSEvent
*
)
theEvent
{
WidgetWheelEvent
wheelEvent
(
true
msg
mGeckoChild
)
;
[
self
convertCocoaMouseWheelEvent
:
theEvent
toGeckoEvent
:
&
wheelEvent
]
;
mExpectingWheelStop
=
(
msg
=
=
eWheelOperationStart
)
;
mGeckoChild
-
>
DispatchInputEvent
(
wheelEvent
.
AsInputEvent
(
)
)
;
}
-
(
void
)
sendWheelCondition
:
(
BOOL
)
condition
first
:
(
EventMessage
)
first
second
:
(
EventMessage
)
second
forEvent
:
(
NSEvent
*
)
theEvent
{
if
(
mExpectingWheelStop
=
=
condition
)
{
[
self
sendWheelStartOrStop
:
first
forEvent
:
theEvent
]
;
}
[
self
sendWheelStartOrStop
:
second
forEvent
:
theEvent
]
;
}
static
int32_t
RoundUp
(
double
aDouble
)
{
return
aDouble
<
0
?
static_cast
<
int32_t
>
(
floor
(
aDouble
)
)
:
static_cast
<
int32_t
>
(
ceil
(
aDouble
)
)
;
}
static
gfx
:
:
IntPoint
GetIntegerDeltaForEvent
(
NSEvent
*
aEvent
)
{
if
(
[
aEvent
hasPreciseScrollingDeltas
]
)
{
return
PanGestureInput
:
:
GetIntegerDeltaForEvent
(
[
aEvent
phase
]
=
=
NSEventPhaseBegan
[
aEvent
deltaX
]
[
aEvent
deltaY
]
)
;
}
return
gfx
:
:
IntPoint
(
RoundUp
(
[
aEvent
deltaX
]
)
RoundUp
(
[
aEvent
deltaY
]
)
)
;
}
-
(
void
)
scrollWheel
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
ChildViewMouseTracker
:
:
MouseScrolled
(
theEvent
)
;
if
(
[
self
maybeRollup
:
theEvent
]
)
{
return
;
}
if
(
!
mGeckoChild
)
{
return
;
}
NSEventPhase
phase
=
[
theEvent
phase
]
;
if
(
phase
&
NSEventPhaseMayBegin
)
{
[
self
sendWheelCondition
:
YES
first
:
eWheelOperationEnd
second
:
eWheelOperationStart
forEvent
:
theEvent
]
;
}
else
if
(
phase
&
(
NSEventPhaseEnded
|
NSEventPhaseCancelled
)
)
{
[
self
sendWheelCondition
:
NO
first
:
eWheelOperationStart
second
:
eWheelOperationEnd
forEvent
:
theEvent
]
;
}
if
(
!
mGeckoChild
)
{
return
;
}
RefPtr
<
nsCocoaWindow
>
geckoChildDeathGrip
(
mGeckoChild
)
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
theEvent
[
self
window
]
)
;
ScreenPoint
position
=
ViewAs
<
ScreenPixel
>
(
[
self
convertWindowCoordinatesRoundDown
:
locationInWindow
]
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
bool
usePreciseDeltas
=
[
theEvent
hasPreciseScrollingDeltas
]
&
&
Preferences
:
:
GetBool
(
"
mousewheel
.
enable_pixel_scrolling
"
true
)
;
bool
hasPhaseInformation
=
nsCocoaUtils
:
:
EventHasPhaseInformation
(
theEvent
)
;
gfx
:
:
IntPoint
lineOrPageDelta
=
-
GetIntegerDeltaForEvent
(
theEvent
)
;
Modifiers
modifiers
=
nsCocoaUtils
:
:
ModifiersForEvent
(
theEvent
)
;
TimeStamp
eventTimeStamp
=
nsCocoaUtils
:
:
GetEventTimeStamp
(
[
theEvent
timestamp
]
)
;
ScreenPoint
preciseDelta
;
if
(
usePreciseDeltas
)
{
CGFloat
pixelDeltaX
=
[
theEvent
scrollingDeltaX
]
;
CGFloat
pixelDeltaY
=
[
theEvent
scrollingDeltaY
]
;
double
scale
=
geckoChildDeathGrip
-
>
BackingScaleFactor
(
)
;
preciseDelta
=
ScreenPoint
(
-
pixelDeltaX
*
scale
-
pixelDeltaY
*
scale
)
;
}
if
(
usePreciseDeltas
&
&
hasPhaseInformation
)
{
PanGestureInput
panEvent
=
nsCocoaUtils
:
:
CreatePanGestureEvent
(
theEvent
eventTimeStamp
position
preciseDelta
lineOrPageDelta
modifiers
)
;
geckoChildDeathGrip
-
>
DispatchAPZWheelInputEvent
(
panEvent
)
;
}
else
if
(
usePreciseDeltas
)
{
ScrollWheelInput
wheelEvent
(
eventTimeStamp
modifiers
ScrollWheelInput
:
:
SCROLLMODE_INSTANT
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
position
preciseDelta
.
x
preciseDelta
.
y
false
WheelDeltaAdjustmentStrategy
:
:
eNone
)
;
wheelEvent
.
mLineOrPageDeltaX
=
lineOrPageDelta
.
x
;
wheelEvent
.
mLineOrPageDeltaY
=
lineOrPageDelta
.
y
;
wheelEvent
.
mIsMomentum
=
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
theEvent
)
;
geckoChildDeathGrip
-
>
DispatchAPZWheelInputEvent
(
wheelEvent
)
;
}
else
{
ScrollWheelInput
:
:
ScrollMode
scrollMode
=
ScrollWheelInput
:
:
SCROLLMODE_INSTANT
;
if
(
nsLayoutUtils
:
:
IsSmoothScrollingEnabled
(
)
&
&
StaticPrefs
:
:
general_smoothScroll_mouseWheel
(
)
)
{
scrollMode
=
ScrollWheelInput
:
:
SCROLLMODE_SMOOTH
;
}
ScrollWheelInput
wheelEvent
(
eventTimeStamp
modifiers
scrollMode
ScrollWheelInput
:
:
SCROLLDELTA_LINE
position
lineOrPageDelta
.
x
lineOrPageDelta
.
y
false
WheelDeltaAdjustmentStrategy
:
:
eNone
)
;
wheelEvent
.
mLineOrPageDeltaX
=
lineOrPageDelta
.
x
;
wheelEvent
.
mLineOrPageDeltaY
=
lineOrPageDelta
.
y
;
geckoChildDeathGrip
-
>
DispatchAPZWheelInputEvent
(
wheelEvent
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
NSMenu
*
)
menuForEvent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mGeckoChild
)
return
nil
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
[
self
maybeRollup
:
theEvent
]
;
if
(
!
mGeckoChild
)
return
nil
;
if
(
[
theEvent
type
]
=
=
NSEventTypeLeftMouseDown
)
{
[
self
mouseDown
:
theEvent
]
;
if
(
!
mGeckoChild
)
return
nil
;
}
WidgetPointerEvent
geckoEvent
(
true
eContextMenu
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
if
(
StaticPrefs
:
:
dom_event_treat_ctrl_click_as_right_click_disabled
(
)
&
&
[
theEvent
type
]
=
=
NSEventTypeLeftMouseDown
)
{
geckoEvent
.
mContextMenuTrigger
=
WidgetMouseEvent
:
:
eControlClick
;
geckoEvent
.
mButton
=
MouseButton
:
:
ePrimary
;
}
else
{
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
}
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
nil
;
[
self
maybeInitContextMenuTracking
]
;
return
nil
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
willOpenMenu
:
(
NSMenu
*
)
aMenu
withEvent
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
NativeMenuOpened
(
)
;
}
-
(
void
)
didCloseMenu
:
(
NSMenu
*
)
aMenu
withEvent
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
NativeMenuClosed
(
)
;
}
-
(
void
)
convertCocoaMouseWheelEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetWheelEvent
*
)
outWheelEvent
{
[
self
convertCocoaMouseEvent
:
aMouseEvent
toGeckoEvent
:
outWheelEvent
]
;
bool
usePreciseDeltas
=
[
aMouseEvent
hasPreciseScrollingDeltas
]
&
&
Preferences
:
:
GetBool
(
"
mousewheel
.
enable_pixel_scrolling
"
true
)
;
outWheelEvent
-
>
mDeltaMode
=
usePreciseDeltas
?
dom
:
:
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
:
dom
:
:
WheelEvent_Binding
:
:
DOM_DELTA_LINE
;
outWheelEvent
-
>
mIsMomentum
=
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
aMouseEvent
)
;
}
-
(
void
)
convertCocoaMouseEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetInputEvent
*
)
outGeckoEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ASSERTION
(
outGeckoEvent
"
convertCocoaMouseEvent
:
toGeckoEvent
:
requires
non
-
null
aoutGeckoEvent
"
)
;
if
(
!
outGeckoEvent
)
return
;
nsCocoaUtils
:
:
InitInputEvent
(
*
outGeckoEvent
aMouseEvent
)
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
aMouseEvent
[
self
window
]
)
;
outGeckoEvent
-
>
mRefPoint
=
[
self
convertWindowCoordinates
:
locationInWindow
]
;
WidgetMouseEventBase
*
mouseEvent
=
outGeckoEvent
-
>
AsMouseEventBase
(
)
;
mouseEvent
-
>
mButtons
=
0
;
NSUInteger
mouseButtons
=
[
NSEvent
pressedMouseButtons
]
;
if
(
mouseButtons
&
0x01
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
ePrimaryFlag
;
}
if
(
mouseButtons
&
0x02
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
eSecondaryFlag
;
}
if
(
mouseButtons
&
0x04
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
eMiddleFlag
;
}
if
(
mouseButtons
&
0x08
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
e4thFlag
;
}
if
(
mouseButtons
&
0x10
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
e5thFlag
;
}
switch
(
[
aMouseEvent
type
]
)
{
case
NSEventTypeLeftMouseDown
:
case
NSEventTypeLeftMouseUp
:
case
NSEventTypeLeftMouseDragged
:
case
NSEventTypeRightMouseDown
:
case
NSEventTypeRightMouseUp
:
case
NSEventTypeRightMouseDragged
:
case
NSEventTypeOtherMouseDown
:
case
NSEventTypeOtherMouseUp
:
case
NSEventTypeOtherMouseDragged
:
case
NSEventTypeMouseMoved
:
if
(
[
aMouseEvent
subtype
]
=
=
NSEventSubtypeTabletPoint
)
{
[
self
convertCocoaTabletPointerEvent
:
aMouseEvent
toGeckoEvent
:
mouseEvent
-
>
AsMouseEvent
(
)
]
;
}
break
;
default
:
break
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
convertCocoaTabletPointerEvent
:
(
NSEvent
*
)
aPointerEvent
toGeckoEvent
:
(
WidgetMouseEvent
*
)
aOutGeckoEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
if
(
!
aOutGeckoEvent
|
|
!
sIsTabletPointerActivated
)
{
return
;
}
if
(
[
aPointerEvent
type
]
!
=
NSEventTypeMouseMoved
)
{
aOutGeckoEvent
-
>
mPressure
=
[
aPointerEvent
pressure
]
;
MOZ_ASSERT
(
aOutGeckoEvent
-
>
mPressure
>
=
0
.
0
&
&
aOutGeckoEvent
-
>
mPressure
<
=
1
.
0
)
;
}
aOutGeckoEvent
-
>
mInputSource
=
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
;
aOutGeckoEvent
-
>
tiltX
=
(
int32_t
)
lround
(
[
aPointerEvent
tilt
]
.
x
*
90
)
;
aOutGeckoEvent
-
>
tiltY
=
(
int32_t
)
lround
(
[
aPointerEvent
tilt
]
.
y
*
90
)
;
aOutGeckoEvent
-
>
tangentialPressure
=
[
aPointerEvent
tangentialPressure
]
;
int32_t
twist
=
(
int32_t
)
fmod
(
[
aPointerEvent
rotation
]
360
)
;
aOutGeckoEvent
-
>
twist
=
twist
>
=
0
?
twist
:
twist
+
360
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
tabletProximity
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
sIsTabletPointerActivated
=
[
theEvent
isEnteringProximity
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
}
#
pragma
mark
-
-
(
NSRange
)
markedRange
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
NSMakeRange
(
NSNotFound
0
)
)
;
return
mTextInputHandler
-
>
MarkedRange
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSMakeRange
(
0
0
)
)
;
}
-
(
NSRange
)
selectedRange
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
NSMakeRange
(
NSNotFound
0
)
)
;
return
mTextInputHandler
-
>
SelectedRange
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSMakeRange
(
0
0
)
)
;
}
-
(
BOOL
)
drawsVerticallyForCharacterAtIndex
:
(
NSUInteger
)
charIndex
{
NS_ENSURE_TRUE
(
mTextInputHandler
NO
)
;
if
(
charIndex
=
=
NSNotFound
)
{
return
NO
;
}
return
mTextInputHandler
-
>
DrawsVerticallyForCharacterAtIndex
(
charIndex
)
;
}
-
(
NSUInteger
)
characterIndexForPoint
:
(
NSPoint
)
thePoint
{
NS_ENSURE_TRUE
(
mTextInputHandler
0
)
;
return
mTextInputHandler
-
>
CharacterIndexForPoint
(
thePoint
)
;
}
-
(
NSArray
*
)
validAttributesForMarkedText
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
[
NSArray
array
]
)
;
return
mTextInputHandler
-
>
GetValidAttributesForMarkedText
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
insertText
:
(
id
)
aString
replacementRange
:
(
NSRange
)
replacementRange
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE_VOID
(
mGeckoChild
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
NSString
*
str
;
if
(
[
aString
isKindOfClass
:
[
NSAttributedString
class
]
]
)
{
str
=
[
aString
string
]
;
}
else
{
str
=
aString
;
}
mTextInputHandler
-
>
InsertText
(
str
&
replacementRange
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
doCommandBySelector
:
(
SEL
)
aSelector
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
|
|
!
mTextInputHandler
)
{
return
;
}
const
char
*
sel
=
reinterpret_cast
<
const
char
*
>
(
aSelector
)
;
if
(
!
mTextInputHandler
-
>
DoCommandBySelector
(
sel
)
)
{
[
super
doCommandBySelector
:
aSelector
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
unmarkText
{
NS_ENSURE_TRUE_VOID
(
mTextInputHandler
)
;
mTextInputHandler
-
>
CommitIMEComposition
(
)
;
}
-
(
BOOL
)
hasMarkedText
{
NS_ENSURE_TRUE
(
mTextInputHandler
NO
)
;
return
mTextInputHandler
-
>
HasMarkedText
(
)
;
}
-
(
void
)
setMarkedText
:
(
id
)
aString
selectedRange
:
(
NSRange
)
selectedRange
replacementRange
:
(
NSRange
)
replacementRange
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE_VOID
(
mTextInputHandler
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
NSAttributedString
*
attrStr
;
if
(
[
aString
isKindOfClass
:
[
NSAttributedString
class
]
]
)
{
attrStr
=
static_cast
<
NSAttributedString
*
>
(
aString
)
;
}
else
{
attrStr
=
[
[
[
NSAttributedString
alloc
]
initWithString
:
aString
]
autorelease
]
;
}
mTextInputHandler
-
>
SetMarkedText
(
attrStr
selectedRange
&
replacementRange
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
NSAttributedString
*
)
attributedSubstringForProposedRange
:
(
NSRange
)
aRange
actualRange
:
(
NSRangePointer
)
actualRange
{
NS_ENSURE_TRUE
(
mTextInputHandler
nil
)
;
return
mTextInputHandler
-
>
GetAttributedSubstringFromRange
(
aRange
actualRange
)
;
}
-
(
NSRect
)
firstRectForCharacterRange
:
(
NSRange
)
aRange
actualRange
:
(
NSRangePointer
)
actualRange
{
NS_ENSURE_TRUE
(
mTextInputHandler
NSMakeRect
(
0
.
0
0
.
0
0
.
0
0
.
0
)
)
;
return
mTextInputHandler
-
>
FirstRectForCharacterRange
(
aRange
actualRange
)
;
}
-
(
void
)
quickLookWithEvent
:
(
NSEvent
*
)
event
{
WidgetContentCommandEvent
contentCommandEvent
(
true
eContentCommandLookUpDictionary
mGeckoChild
)
;
NSPoint
point
=
[
self
convertPoint
:
[
event
locationInWindow
]
fromView
:
nil
]
;
contentCommandEvent
.
mRefPoint
=
mGeckoChild
-
>
CocoaPointsToDevPixels
(
point
)
;
mGeckoChild
-
>
DispatchWindowEvent
(
contentCommandEvent
)
;
}
-
(
NSInteger
)
windowLevel
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
[
[
self
window
]
level
]
)
;
return
mTextInputHandler
-
>
GetWindowLevel
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSNormalWindowLevel
)
;
}
#
pragma
mark
-
-
(
BOOL
)
_wantsKeyDownForEvent
:
(
NSEvent
*
)
event
{
return
YES
;
}
-
(
NSEvent
*
)
lastKeyDownEvent
{
return
mLastKeyDownEvent
;
}
-
(
void
)
keyDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
mLastKeyDownEvent
release
]
;
mLastKeyDownEvent
=
[
theEvent
retain
]
;
NSWindow
*
viewWindow
=
[
self
window
]
;
if
(
viewWindow
&
&
[
viewWindow
isKeyWindow
]
)
{
[
viewWindow
orderWindow
:
NSWindowAbove
relativeTo
:
0
]
;
}
#
if
!
defined
(
RELEASE_OR_BETA
)
|
|
defined
(
DEBUG
)
if
(
!
Preferences
:
:
GetBool
(
"
intl
.
allow
-
insecure
-
text
-
input
"
false
)
&
&
mGeckoChild
&
&
mTextInputHandler
&
&
mTextInputHandler
-
>
IsFocused
(
)
)
{
NSWindow
*
window
=
[
self
window
]
;
NSString
*
info
=
[
NSString
stringWithFormat
:
"
\
nview
[
%
]
window
[
%
]
window
is
key
%
i
is
"
"
fullscreen
%
i
app
is
active
%
i
"
self
window
[
window
isKeyWindow
]
(
[
window
styleMask
]
&
NSWindowStyleMaskFullScreen
)
!
=
0
[
NSApp
isActive
]
]
;
nsAutoCString
additionalInfo
(
[
info
UTF8String
]
)
;
if
(
mGeckoChild
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
&
&
!
TextInputHandler
:
:
IsSecureEventInputEnabled
(
)
)
{
#
define
CRASH_MESSAGE
\
"
A
password
editor
has
focus
but
not
in
secure
input
mode
"
CrashReporter
:
:
AppendAppNotesToCrashReport
(
"
\
nBug
893973
:
"
_ns
+
nsLiteralCString
(
CRASH_MESSAGE
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
additionalInfo
)
;
MOZ_CRASH
(
CRASH_MESSAGE
)
;
#
undef
CRASH_MESSAGE
}
else
if
(
!
mGeckoChild
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
&
&
TextInputHandler
:
:
IsSecureEventInputEnabled
(
)
)
{
#
define
CRASH_MESSAGE
\
"
A
non
-
password
editor
has
focus
but
in
secure
input
mode
"
CrashReporter
:
:
AppendAppNotesToCrashReport
(
"
\
nBug
893973
:
"
_ns
+
nsLiteralCString
(
CRASH_MESSAGE
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
additionalInfo
)
;
MOZ_CRASH
(
CRASH_MESSAGE
)
;
#
undef
CRASH_MESSAGE
}
}
#
endif
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
mGeckoChild
)
{
if
(
mTextInputHandler
)
{
sUniqueKeyEventId
+
+
;
NSMutableDictionary
*
nativeKeyEventsMap
=
[
ChildView
sNativeKeyEventsMap
]
;
[
nativeKeyEventsMap
setObject
:
theEvent
forKey
:
(
sUniqueKeyEventId
)
]
;
[
nativeKeyEventsMap
removeObjectForKey
:
(
sUniqueKeyEventId
-
10
)
]
;
mTextInputHandler
-
>
HandleKeyDownEvent
(
theEvent
sUniqueKeyEventId
)
;
}
else
{
mGeckoChild
-
>
SendEventToNativeMenuSystem
(
theEvent
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
keyUp
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE
(
mGeckoChild
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mTextInputHandler
-
>
HandleKeyUpEvent
(
theEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
insertNewline
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertParagraph
)
;
}
}
-
(
void
)
insertLineBreak
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertLineBreak
)
;
}
}
-
(
void
)
deleteBackward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteCharBackward
)
;
}
}
-
(
void
)
deleteBackwardByDecomposingPreviousCharacter
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteCharBackward
)
;
}
}
-
(
void
)
deleteWordBackward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteWordBackward
)
;
}
}
-
(
void
)
deleteToBeginningOfBackward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteToBeginningOfLine
)
;
}
}
-
(
void
)
deleteForward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteCharForward
)
;
}
}
-
(
void
)
deleteWordForward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteWordForward
)
;
}
}
-
(
void
)
insertTab
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertTab
)
;
}
}
-
(
void
)
insertBacktab
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertBacktab
)
;
}
}
-
(
void
)
moveRight
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
CharNext
)
;
}
}
-
(
void
)
moveRightAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectCharNext
)
;
}
}
-
(
void
)
moveWordRight
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
WordNext
)
;
}
}
-
(
void
)
moveWordRightAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectWordNext
)
;
}
}
-
(
void
)
moveToRightEndOfLine
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
EndLine
)
;
}
}
-
(
void
)
moveToRightEndOfLineAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectEndLine
)
;
}
}
-
(
void
)
moveLeft
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
CharPrevious
)
;
}
}
-
(
void
)
moveLeftAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectCharPrevious
)
;
}
}
-
(
void
)
moveWordLeft
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
WordPrevious
)
;
}
}
-
(
void
)
moveWordLeftAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectWordPrevious
)
;
}
}
-
(
void
)
moveToLeftEndOfLine
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
BeginLine
)
;
}
}
-
(
void
)
moveToLeftEndOfLineAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectBeginLine
)
;
}
}
-
(
void
)
moveUp
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
LinePrevious
)
;
}
}
-
(
void
)
moveUpAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectLinePrevious
)
;
}
}
-
(
void
)
moveToBeginningOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
MoveTop
)
;
}
}
-
(
void
)
moveToBeginningOfDocumentAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectTop
)
;
}
}
-
(
void
)
moveDown
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
LineNext
)
;
}
}
-
(
void
)
moveDownAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectLineNext
)
;
}
}
-
(
void
)
moveToEndOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
MoveBottom
)
;
}
}
-
(
void
)
moveToEndOfDocumentAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectBottom
)
;
}
}
-
(
void
)
scrollPageUp
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollPageUp
)
;
}
}
-
(
void
)
pageUpAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectPageUp
)
;
}
}
-
(
void
)
scrollPageDown
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollPageDown
)
;
}
}
-
(
void
)
pageDownAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectPageDown
)
;
}
}
-
(
void
)
scrollToEndOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollBottom
)
;
}
}
-
(
void
)
scrollToBeginningOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollTop
)
;
}
}
-
(
void
)
complete
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
Complete
)
;
}
}
-
(
void
)
flagsChanged
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE
(
mGeckoChild
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mTextInputHandler
-
>
HandleFlagsChanged
(
theEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
isFirstResponder
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSResponder
*
resp
=
[
[
self
window
]
firstResponder
]
;
return
(
resp
=
=
(
NSResponder
*
)
self
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
isDragInProgress
{
if
(
!
mDragService
)
return
NO
;
nsCOMPtr
<
nsIDragSession
>
dragSession
=
mDragService
-
>
GetCurrentSession
(
mGeckoChild
)
;
return
dragSession
!
=
nullptr
;
}
-
(
BOOL
)
inactiveWindowAcceptsMouseEvent
:
(
NSEvent
*
)
aEvent
{
if
(
!
mGeckoChild
)
return
YES
;
WidgetMouseEvent
geckoEvent
(
true
eMouseActivate
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
aEvent
toGeckoEvent
:
&
geckoEvent
]
;
return
(
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
.
mContentStatus
!
=
nsEventStatus_eConsumeNoDefault
)
;
}
-
(
BOOL
)
becomeFirstResponder
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
[
super
becomeFirstResponder
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
YES
)
;
}
-
(
void
)
viewsWindowDidBecomeKey
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
BOOL
isMozWindow
=
[
[
self
window
]
respondsToSelector
:
selector
(
setSuppressMakeKeyFront
:
)
]
;
if
(
isMozWindow
)
[
[
self
window
]
setSuppressMakeKeyFront
:
YES
]
;
nsIWidgetListener
*
listener
=
mGeckoChild
-
>
GetWidgetListener
(
)
;
if
(
listener
)
listener
-
>
WindowActivated
(
)
;
if
(
isMozWindow
)
[
[
self
window
]
setSuppressMakeKeyFront
:
NO
]
;
if
(
mGeckoChild
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
viewsWindowDidResignKey
{
if
(
!
mGeckoChild
)
return
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
nsIWidgetListener
*
listener
=
mGeckoChild
-
>
GetWidgetListener
(
)
;
if
(
listener
)
listener
-
>
WindowDeactivated
(
)
;
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
-
(
void
)
delayedTearDown
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
self
removeFromSuperview
]
;
[
self
release
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
#
define
kDragServiceContractID
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
-
(
NSDragOperation
)
dragOperationFromDragAction
:
(
int32_t
)
aDragAction
{
if
(
nsIDragService
:
:
DRAGDROP_ACTION_LINK
&
aDragAction
)
return
NSDragOperationLink
;
if
(
nsIDragService
:
:
DRAGDROP_ACTION_COPY
&
aDragAction
)
return
NSDragOperationCopy
;
if
(
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
&
aDragAction
)
return
NSDragOperationGeneric
;
return
NSDragOperationNone
;
}
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinates
:
(
NSPoint
)
aPoint
{
if
(
!
mGeckoChild
)
{
return
LayoutDeviceIntPoint
(
0
0
)
;
}
NSPoint
localPoint
=
[
self
convertPoint
:
aPoint
fromView
:
nil
]
;
return
mGeckoChild
-
>
CocoaPointsToDevPixels
(
localPoint
)
;
}
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinatesRoundDown
:
(
NSPoint
)
aPoint
{
if
(
!
mGeckoChild
)
{
return
LayoutDeviceIntPoint
(
0
0
)
;
}
NSPoint
localPoint
=
[
self
convertPoint
:
aPoint
fromView
:
nil
]
;
return
mGeckoChild
-
>
CocoaPointsToDevPixelsRoundDown
(
localPoint
)
;
}
-
(
NSDragOperation
)
doDragAction
:
(
EventMessage
)
aMessage
sender
:
(
id
)
aSender
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mGeckoChild
)
return
NSDragOperationNone
;
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
doDragAction
:
entered
\
n
"
)
)
;
if
(
!
mDragService
)
{
CallGetService
(
kDragServiceContractID
&
mDragService
)
;
NS_ASSERTION
(
mDragService
"
Couldn
'
t
get
a
drag
service
-
big
problem
!
"
)
;
if
(
!
mDragService
)
return
NSDragOperationNone
;
}
nsCOMPtr
<
nsIDragSession
>
dragSession
;
if
(
aMessage
=
=
eDragEnter
)
{
nsIWidget
*
widget
=
mGeckoChild
;
dragSession
=
mDragService
-
>
StartDragSession
(
widget
)
;
}
else
{
dragSession
=
mDragService
-
>
GetCurrentSession
(
mGeckoChild
)
;
}
if
(
dragSession
)
{
if
(
aMessage
=
=
eDragOver
)
{
dragSession
-
>
FireDragEventAtSource
(
eDrag
nsCocoaUtils
:
:
ModifiersForEvent
(
[
NSApp
currentEvent
]
)
)
;
dragSession
-
>
SetCanDrop
(
false
)
;
}
else
if
(
aMessage
=
=
eDrop
)
{
bool
canDrop
=
false
;
if
(
!
NS_SUCCEEDED
(
dragSession
-
>
GetCanDrop
(
&
canDrop
)
)
|
|
!
canDrop
)
{
[
self
doDragAction
:
eDragExit
sender
:
aSender
]
;
nsCOMPtr
<
nsINode
>
sourceNode
;
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
dragSession
-
>
EndDragSession
(
false
nsCocoaUtils
:
:
ModifiersForEvent
(
[
NSApp
currentEvent
]
)
)
;
}
return
NSDragOperationNone
;
}
}
unsigned
int
modifierFlags
=
[
[
NSApp
currentEvent
]
modifierFlags
]
;
uint32_t
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
if
(
modifierFlags
&
NSEventModifierFlagOption
)
{
if
(
modifierFlags
&
NSEventModifierFlagCommand
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
else
action
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
}
dragSession
-
>
SetDragAction
(
action
)
;
}
WidgetDragEvent
geckoEvent
(
true
aMessage
mGeckoChild
)
;
nsCocoaUtils
:
:
InitInputEvent
(
geckoEvent
[
NSApp
currentEvent
]
)
;
NSPoint
draggingLoc
=
[
aSender
draggingLocation
]
;
geckoEvent
.
mRefPoint
=
[
self
convertWindowCoordinates
:
draggingLoc
]
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
NSDragOperationNone
;
if
(
dragSession
)
{
switch
(
aMessage
)
{
case
eDragEnter
:
case
eDragOver
:
{
uint32_t
dragAction
;
dragSession
-
>
GetDragAction
(
&
dragAction
)
;
nsDragSession
*
ds
=
static_cast
<
nsDragSession
*
>
(
dragSession
.
get
(
)
)
;
int32_t
childDragAction
=
ds
-
>
TakeChildProcessDragAction
(
)
;
if
(
childDragAction
!
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
{
dragAction
=
childDragAction
;
}
return
[
self
dragOperationFromDragAction
:
dragAction
]
;
}
case
eDragExit
:
case
eDrop
:
{
nsCOMPtr
<
nsINode
>
sourceNode
;
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
dragSession
-
>
EndDragSession
(
false
nsCocoaUtils
:
:
ModifiersForEvent
(
[
NSApp
currentEvent
]
)
)
;
}
break
;
}
default
:
break
;
}
}
return
NSDragOperationGeneric
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSDragOperationNone
)
;
}
-
(
NSDragOperation
)
draggingEntered
:
(
id
<
NSDraggingInfo
>
)
sender
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
draggingEntered
:
entered
\
n
"
)
)
;
[
globalDragPboard
release
]
;
globalDragPboard
=
[
[
sender
draggingPasteboard
]
retain
]
;
return
[
self
doDragAction
:
eDragEnter
sender
:
sender
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSDragOperationNone
)
;
}
-
(
NSDragOperation
)
draggingUpdated
:
(
id
<
NSDraggingInfo
>
)
sender
{
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
draggingUpdated
:
entered
\
n
"
)
)
;
return
[
self
doDragAction
:
eDragOver
sender
:
sender
]
;
}
-
(
void
)
draggingExited
:
(
id
<
NSDraggingInfo
>
)
sender
{
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
draggingExited
:
entered
\
n
"
)
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
[
self
doDragAction
:
eDragExit
sender
:
sender
]
;
NS_IF_RELEASE
(
mDragService
)
;
}
-
(
BOOL
)
performDragOperation
:
(
id
<
NSDraggingInfo
>
)
sender
{
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
BOOL
handled
=
[
self
doDragAction
:
eDrop
sender
:
sender
]
!
=
NSDragOperationNone
;
NS_IF_RELEASE
(
mDragService
)
;
return
handled
;
}
-
(
NSDragOperation
)
draggingSession
:
(
NSDraggingSession
*
)
session
sourceOperationMaskForDraggingContext
:
(
NSDraggingContext
)
context
{
return
UINT_MAX
;
}
-
(
BOOL
)
ignoreModifierKeysForDraggingSession
:
(
NSDraggingSession
*
)
session
{
return
YES
;
}
-
(
void
)
draggingSession
:
(
NSDraggingSession
*
)
aSession
endedAtPoint
:
(
NSPoint
)
aPoint
operation
:
(
NSDragOperation
)
aOperation
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
#
ifdef
NIGHTLY_BUILD
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
endif
gDraggedTransferables
=
nullptr
;
NSEvent
*
currentEvent
=
[
NSApp
currentEvent
]
;
gUserCancelledDrag
=
(
[
currentEvent
type
]
=
=
NSEventTypeKeyDown
&
&
[
currentEvent
keyCode
]
=
=
kVK_Escape
)
;
if
(
!
mDragService
)
{
CallGetService
(
kDragServiceContractID
&
mDragService
)
;
NS_ASSERTION
(
mDragService
"
Couldn
'
t
get
a
drag
service
-
big
problem
!
"
)
;
}
nsCOMPtr
<
nsIDragSession
>
session
=
mDragService
-
>
GetCurrentSession
(
mGeckoChild
)
;
if
(
session
)
{
NSPoint
pnt
=
[
NSEvent
mouseLocation
]
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
[
self
window
]
pnt
)
;
FlipCocoaScreenCoordinate
(
pnt
)
;
LayoutDeviceIntPoint
pt
=
[
self
convertWindowCoordinates
:
locationInWindow
]
;
session
-
>
SetDragEndPoint
(
pt
.
x
pt
.
y
)
;
if
(
aOperation
=
=
NSDragOperationNone
)
{
if
(
RefPtr
dataTransfer
=
session
-
>
GetDataTransfer
(
)
)
{
dataTransfer
-
>
SetDropEffectInt
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
;
}
}
session
-
>
EndDragSession
(
true
nsCocoaUtils
:
:
ModifiersForEvent
(
currentEvent
)
)
;
}
session
=
nullptr
;
NS_IF_RELEASE
(
mDragService
)
;
[
globalDragPboard
release
]
;
globalDragPboard
=
nil
;
[
gLastDragMouseDownEvent
release
]
;
gLastDragMouseDownEvent
=
nil
;
mPerformedDrag
=
YES
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
draggingSession
:
(
NSDraggingSession
*
)
aSession
movedToPoint
:
(
NSPoint
)
aPoint
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsCOMPtr
<
nsIDragService
>
dragService
=
mDragService
;
if
(
!
dragService
)
{
dragService
=
do_GetService
(
kDragServiceContractID
)
;
}
if
(
dragService
)
{
RefPtr
<
nsIDragSession
>
dragSession
;
nsIWidget
*
widget
=
mGeckoChild
;
dragService
-
>
GetCurrentSession
(
widget
getter_AddRefs
(
dragSession
)
)
;
if
(
dragSession
)
{
MOZ_ASSERT
(
aSession
=
=
static_cast
<
nsDragSession
*
>
(
dragSession
.
get
(
)
)
-
>
GetNSDraggingSession
(
)
)
;
dragSession
-
>
DragMoved
(
aPoint
.
x
aPoint
.
y
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
draggingSession
:
(
NSDraggingSession
*
)
aSession
willBeginAtPoint
:
(
NSPoint
)
aPoint
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
globalDragPboard
release
]
;
globalDragPboard
=
[
[
aSession
draggingPasteboard
]
retain
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
CFTypeRefPtr
<
CFURLRef
>
GetPasteLocation
(
NSPasteboard
*
aPasteboard
)
{
PasteboardRef
pboardRef
=
nullptr
;
PasteboardCreate
(
(
CFStringRef
)
[
aPasteboard
name
]
&
pboardRef
)
;
if
(
!
pboardRef
)
{
return
nullptr
;
}
auto
pasteBoard
=
CFTypeRefPtr
<
PasteboardRef
>
:
:
WrapUnderCreateRule
(
pboardRef
)
;
PasteboardSynchronize
(
pasteBoard
.
get
(
)
)
;
CFURLRef
urlRef
=
nullptr
;
PasteboardCopyPasteLocation
(
pasteBoard
.
get
(
)
&
urlRef
)
;
return
CFTypeRefPtr
<
CFURLRef
>
:
:
WrapUnderCreateRule
(
urlRef
)
;
}
-
(
void
)
pasteboard
:
(
NSPasteboard
*
)
aPasteboard
item
:
(
NSPasteboardItem
*
)
aItem
provideDataForType
:
(
NSString
*
)
aType
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
#
ifdef
NIGHTLY_BUILD
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
endif
if
(
!
gDraggedTransferables
)
{
return
;
}
uint32_t
count
=
0
;
gDraggedTransferables
-
>
GetLength
(
&
count
)
;
for
(
uint32_t
j
=
0
;
j
<
count
;
j
+
+
)
{
nsCOMPtr
<
nsITransferable
>
currentTransferable
=
do_QueryElementAt
(
gDraggedTransferables
j
)
;
if
(
!
currentTransferable
)
{
return
;
}
NSDictionary
*
pasteboardOutputDict
=
nsClipboard
:
:
PasteboardDictFromTransferable
(
currentTransferable
)
;
if
(
!
pasteboardOutputDict
)
{
return
;
}
unsigned
int
typeCount
=
[
pasteboardOutputDict
count
]
;
NSMutableArray
*
types
=
[
NSMutableArray
arrayWithCapacity
:
typeCount
+
1
]
;
[
types
addObjectsFromArray
:
[
pasteboardOutputDict
allKeys
]
]
;
[
types
addObject
:
[
UTIHelper
stringFromPboardType
:
kMozWildcardPboardType
]
]
;
for
(
unsigned
int
k
=
0
;
k
<
typeCount
;
k
+
+
)
{
NSString
*
curType
=
[
types
objectAtIndex
:
k
]
;
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlPboardType
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlNamePboardType
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kUTTypeFileURL
]
]
)
{
[
aPasteboard
setString
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kUrlsWithTitlesPboardType
]
]
)
{
[
aPasteboard
setPropertyList
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
)
{
[
aPasteboard
setString
:
(
nsClipboard
:
:
WrapHtmlForSystemPasteboard
(
[
pasteboardOutputDict
valueForKey
:
curType
]
)
)
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeTIFF
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kMozCustomTypesPboardType
]
]
)
{
[
aPasteboard
setData
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kMozFileUrlsPboardType
]
]
)
{
[
aPasteboard
writeObjects
:
[
pasteboardOutputDict
valueForKey
:
curType
]
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kPasteboardTypeFileURLPromise
]
]
)
{
CFTypeRefPtr
<
CFURLRef
>
url
=
GetPasteLocation
(
aPasteboard
)
;
if
(
!
url
)
{
continue
;
}
nsCOMPtr
<
nsILocalFileMac
>
macLocalFile
;
if
(
NS_FAILED
(
NS_NewLocalFileWithCFURL
(
url
.
get
(
)
getter_AddRefs
(
macLocalFile
)
)
)
)
{
NS_ERROR
(
"
failed
NS_NewLocalFileWithCFURL
"
)
;
continue
;
}
if
(
!
gDraggedTransferables
)
{
continue
;
}
uint32_t
transferableCount
;
nsresult
rv
=
gDraggedTransferables
-
>
GetLength
(
&
transferableCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
for
(
uint32_t
i
=
0
;
i
<
transferableCount
;
i
+
+
)
{
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
gDraggedTransferables
i
)
;
if
(
!
item
)
{
NS_ERROR
(
"
no
transferable
"
)
;
continue
;
}
item
-
>
SetTransferData
(
kFilePromiseDirectoryMime
macLocalFile
)
;
nsCOMPtr
<
nsISupports
>
fileDataPrimitive
;
Unused
<
<
item
-
>
GetTransferData
(
kFilePromiseMime
getter_AddRefs
(
fileDataPrimitive
)
)
;
}
[
aPasteboard
setPropertyList
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
-
(
id
)
validRequestorForSendType
:
(
NSString
*
)
sendType
returnType
:
(
NSString
*
)
returnType
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
NS_IsMainThread
(
)
)
{
return
[
super
validRequestorForSendType
:
sendType
returnType
:
returnType
]
;
}
id
result
=
nil
;
NSString
*
stringType
=
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
;
NSString
*
htmlType
=
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
;
if
(
(
!
sendType
|
|
[
sendType
isEqualToString
:
stringType
]
|
|
[
sendType
isEqualToString
:
htmlType
]
)
&
&
(
!
returnType
|
|
[
returnType
isEqualToString
:
stringType
]
|
|
[
returnType
isEqualToString
:
htmlType
]
)
)
{
if
(
mGeckoChild
)
{
result
=
self
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
sendType
)
{
if
(
!
nsClipboard
:
:
sSelectionCache
)
{
result
=
nil
;
}
}
if
(
mGeckoChild
&
&
returnType
)
{
WidgetContentCommandEvent
command
(
true
eContentCommandPasteTransferable
mGeckoChild
true
)
;
mGeckoChild
-
>
DispatchWindowEvent
(
command
)
;
if
(
!
mGeckoChild
|
|
!
command
.
mSucceeded
|
|
!
command
.
mIsEnabled
)
result
=
nil
;
}
}
}
if
(
!
result
)
result
=
[
super
validRequestorForSendType
:
sendType
returnType
:
returnType
]
;
return
result
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
BOOL
)
writeSelectionToPasteboard
:
(
NSPasteboard
*
)
pboard
types
:
(
NSArray
*
)
types
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
!
[
types
containsObject
:
[
UTIHelper
stringFromPboardType
:
NSStringPboardType
]
]
&
&
!
[
types
containsObject
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
]
&
&
!
[
types
containsObject
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
)
{
return
NO
;
}
if
(
!
mGeckoChild
)
return
NO
;
NSDictionary
*
pasteboardOutputDict
=
nullptr
;
pasteboardOutputDict
=
nsClipboard
:
:
PasteboardDictFromTransferable
(
nsClipboard
:
:
sSelectionCache
)
;
if
(
!
pasteboardOutputDict
)
return
NO
;
unsigned
int
typeCount
=
[
pasteboardOutputDict
count
]
;
NSMutableArray
*
declaredTypes
=
[
NSMutableArray
arrayWithCapacity
:
typeCount
]
;
[
declaredTypes
addObjectsFromArray
:
[
pasteboardOutputDict
allKeys
]
]
;
[
pboard
declareTypes
:
declaredTypes
owner
:
nil
]
;
for
(
unsigned
int
i
=
0
;
i
<
typeCount
;
i
+
+
)
{
NSString
*
currentKey
=
[
declaredTypes
objectAtIndex
:
i
]
;
id
currentValue
=
[
pasteboardOutputDict
valueForKey
:
currentKey
]
;
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
]
|
|
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlPboardType
]
]
|
|
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlNamePboardType
]
]
)
{
[
pboard
setString
:
currentValue
forType
:
currentKey
]
;
}
else
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
)
{
[
pboard
setString
:
(
nsClipboard
:
:
WrapHtmlForSystemPasteboard
(
currentValue
)
)
forType
:
currentKey
]
;
}
else
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeTIFF
]
]
)
{
[
pboard
setData
:
currentValue
forType
:
currentKey
]
;
}
else
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kPasteboardTypeFileURLPromise
]
]
|
|
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kUrlsWithTitlesPboardType
]
]
)
{
[
pboard
setPropertyList
:
currentValue
forType
:
currentKey
]
;
}
}
return
YES
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
readSelectionFromPasteboard
:
(
NSPasteboard
*
)
pboard
{
nsresult
rv
;
nsCOMPtr
<
nsITransferable
>
trans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
trans
-
>
Init
(
nullptr
)
;
trans
-
>
AddDataFlavor
(
kTextMime
)
;
trans
-
>
AddDataFlavor
(
kHTMLMime
)
;
rv
=
nsClipboard
:
:
TransferableFromPasteboard
(
trans
pboard
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
NS_ENSURE_TRUE
(
mGeckoChild
false
)
;
WidgetContentCommandEvent
command
(
true
eContentCommandPasteTransferable
mGeckoChild
)
;
command
.
mTransferable
=
trans
;
mGeckoChild
-
>
DispatchWindowEvent
(
command
)
;
return
command
.
mSucceeded
&
&
command
.
mIsEnabled
;
}
-
(
void
)
pressureChangeWithEvent
:
(
NSEvent
*
)
event
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
NSInteger
stage
=
[
event
stage
]
;
if
(
mLastPressureStage
=
=
1
&
&
stage
=
=
2
)
{
NSUserDefaults
*
userDefaults
=
[
NSUserDefaults
standardUserDefaults
]
;
if
(
[
userDefaults
integerForKey
:
"
com
.
apple
.
trackpad
.
forceClick
"
]
=
=
1
)
{
[
self
quickLookWithEvent
:
event
]
;
}
}
mLastPressureStage
=
stage
;
NS_OBJC_END_TRY_IGNORE_BLOCK
}
nsresult
nsCocoaWindow
:
:
GetSelectionAsPlaintext
(
nsAString
&
aResult
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
nsClipboard
:
:
sSelectionCache
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
return
NS_OK
;
}
NSDictionary
*
pasteboardOutputDict
=
nullptr
;
pasteboardOutputDict
=
nsClipboard
:
:
PasteboardDictFromTransferable
(
nsClipboard
:
:
sSelectionCache
)
;
if
(
NS_WARN_IF
(
!
pasteboardOutputDict
)
)
{
return
NS_ERROR_FAILURE
;
}
unsigned
int
typeCount
=
[
pasteboardOutputDict
count
]
;
NSMutableArray
*
declaredTypes
=
[
NSMutableArray
arrayWithCapacity
:
typeCount
]
;
[
declaredTypes
addObjectsFromArray
:
[
pasteboardOutputDict
allKeys
]
]
;
NSString
*
currentKey
=
[
declaredTypes
objectAtIndex
:
0
]
;
NSString
*
currentValue
=
[
pasteboardOutputDict
valueForKey
:
currentKey
]
;
const
char
*
textSelection
=
[
currentValue
UTF8String
]
;
aResult
=
NS_ConvertUTF8toUTF16
(
textSelection
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
#
ifdef
DEBUG
nsresult
nsCocoaWindow
:
:
SetHiDPIMode
(
bool
aHiDPI
)
{
nsCocoaUtils
:
:
InvalidateHiDPIState
(
)
;
Preferences
:
:
SetInt
(
"
gfx
.
hidpi
.
enabled
"
aHiDPI
?
1
:
0
)
;
BackingScaleFactorChanged
(
)
;
return
NS_OK
;
}
nsresult
nsCocoaWindow
:
:
RestoreHiDPIMode
(
)
{
nsCocoaUtils
:
:
InvalidateHiDPIState
(
)
;
Preferences
:
:
ClearUser
(
"
gfx
.
hidpi
.
enabled
"
)
;
BackingScaleFactorChanged
(
)
;
return
NS_OK
;
}
#
endif
#
pragma
mark
-
#
ifdef
ACCESSIBILITY
-
(
id
<
mozAccessible
>
)
accessible
{
if
(
!
mGeckoChild
)
return
nil
;
id
<
mozAccessible
>
nativeAccessible
=
nil
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
RefPtr
<
nsCocoaWindow
>
geckoChild
(
mGeckoChild
)
;
RefPtr
<
a11y
:
:
LocalAccessible
>
accessible
=
geckoChild
-
>
GetDocumentAccessible
(
)
;
if
(
!
accessible
)
return
nil
;
accessible
-
>
GetNativeInterface
(
(
void
*
*
)
&
nativeAccessible
)
;
#
ifdef
DEBUG_hakan
NSAssert
(
!
[
nativeAccessible
isExpired
]
"
native
acc
is
expired
!
!
!
"
)
;
#
endif
return
nativeAccessible
;
}
-
(
BOOL
)
hasRepresentedView
{
return
YES
;
}
-
(
id
)
representedView
{
return
self
;
}
-
(
BOOL
)
isRoot
{
return
[
[
self
accessible
]
isRoot
]
;
}
#
pragma
mark
-
-
(
BOOL
)
isAccessibilityElement
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
isAccessibilityElement
]
;
return
[
[
self
accessible
]
isAccessibilityElement
]
;
}
-
(
id
)
accessibilityHitTest
:
(
NSPoint
)
point
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityHitTest
:
point
]
;
return
[
[
self
accessible
]
accessibilityHitTest
:
point
]
;
}
-
(
id
)
accessibilityFocusedUIElement
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityFocusedUIElement
]
;
return
[
[
self
accessible
]
accessibilityFocusedUIElement
]
;
}
-
(
NSArray
*
)
accessibilityActionNames
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityActionNames
]
;
return
[
[
self
accessible
]
accessibilityActionNames
]
;
}
-
(
NSString
*
)
accessibilityActionDescription
:
(
NSString
*
)
action
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityActionDescription
:
action
]
;
return
[
[
self
accessible
]
accessibilityActionDescription
:
action
]
;
}
-
(
void
)
accessibilityPerformAction
:
(
NSString
*
)
action
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityPerformAction
:
action
]
;
return
[
[
self
accessible
]
accessibilityPerformAction
:
action
]
;
}
-
(
NSArray
*
)
accessibilityAttributeNames
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityAttributeNames
]
;
return
[
[
self
accessible
]
accessibilityAttributeNames
]
;
}
-
(
BOOL
)
accessibilityIsAttributeSettable
:
(
NSString
*
)
attribute
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityIsAttributeSettable
:
attribute
]
;
return
[
[
self
accessible
]
accessibilityIsAttributeSettable
:
attribute
]
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityAttributeValue
:
attribute
]
;
id
<
mozAccessible
>
accessible
=
[
self
accessible
]
;
if
(
[
attribute
isEqualToString
:
NSAccessibilityParentAttribute
]
&
&
[
accessible
isRoot
]
)
{
id
parentAccessible
=
[
super
accessibilityAttributeValue
:
attribute
]
;
return
parentAccessible
;
}
return
[
accessible
accessibilityAttributeValue
:
attribute
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
#
endif
+
(
uint32_t
)
sUniqueKeyEventId
{
return
sUniqueKeyEventId
;
}
+
(
NSMutableDictionary
*
)
sNativeKeyEventsMap
{
MOZ_RUNINIT
static
NSMutableDictionary
*
sNativeKeyEventsMap
=
[
[
NSMutableDictionary
alloc
]
init
]
;
return
sNativeKeyEventsMap
;
}
end
implementation
PixelHostingView
-
(
id
)
initWithFrame
:
(
NSRect
)
aRect
{
self
=
[
super
initWithFrame
:
aRect
]
;
self
.
wantsLayer
=
YES
;
self
.
layerContentsRedrawPolicy
=
NSViewLayerContentsRedrawDuringViewResize
;
return
self
;
}
-
(
BOOL
)
isFlipped
{
return
YES
;
}
-
(
NSView
*
)
hitTest
:
(
NSPoint
)
aPoint
{
return
nil
;
}
-
(
void
)
drawRect
:
(
NSRect
)
aRect
{
NS_WARNING
(
"
Unexpected
call
to
drawRect
:
This
view
returns
YES
from
"
"
wantsUpdateLayer
so
"
"
drawRect
should
not
be
called
.
"
)
;
}
-
(
BOOL
)
wantsUpdateLayer
{
return
YES
;
}
-
(
void
)
updateLayer
{
[
(
ChildView
*
)
[
self
superview
]
updateRootCALayer
]
;
}
-
(
BOOL
)
wantsBestResolutionOpenGLSurface
{
return
nsCocoaUtils
:
:
HiDPIEnabled
(
)
?
YES
:
NO
;
}
end
#
pragma
mark
-
void
ChildViewMouseTracker
:
:
OnDestroyView
(
ChildView
*
aView
)
{
if
(
sLastMouseEventView
=
=
aView
)
{
sLastMouseEventView
=
nil
;
[
sLastMouseMoveEvent
release
]
;
sLastMouseMoveEvent
=
nil
;
}
}
void
ChildViewMouseTracker
:
:
OnDestroyWindow
(
NSWindow
*
aWindow
)
{
if
(
sWindowUnderMouse
=
=
aWindow
)
{
sWindowUnderMouse
=
nil
;
}
}
void
ChildViewMouseTracker
:
:
MouseEnteredWindow
(
NSEvent
*
aEvent
)
{
NSWindow
*
window
=
aEvent
.
window
;
if
(
!
window
.
ignoresMouseEvents
)
{
sWindowUnderMouse
=
window
;
ReEvaluateMouseEnterState
(
aEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
MouseExitedWindow
(
NSEvent
*
aEvent
)
{
if
(
sWindowUnderMouse
=
=
aEvent
.
window
)
{
sWindowUnderMouse
=
nil
;
[
sLastMouseMoveEvent
release
]
;
sLastMouseMoveEvent
=
nil
;
ReEvaluateMouseEnterState
(
aEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
NativeMenuOpened
(
)
{
sWindowUnderMouse
=
nil
;
ReEvaluateMouseEnterState
(
nil
)
;
}
void
ChildViewMouseTracker
:
:
NativeMenuClosed
(
)
{
if
(
sLastMouseMoveEvent
)
{
sWindowUnderMouse
=
sLastMouseMoveEvent
.
window
;
ReEvaluateMouseEnterState
(
sLastMouseMoveEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
NSEvent
*
aEvent
ChildView
*
aOldView
)
{
ChildView
*
oldView
=
aOldView
?
aOldView
:
sLastMouseEventView
;
sLastMouseEventView
=
ViewForEvent
(
aEvent
)
;
if
(
sLastMouseEventView
!
=
oldView
)
{
WidgetMouseEvent
:
:
ExitFrom
exitFrom
=
[
sLastMouseEventView
window
]
=
=
[
oldView
window
]
?
WidgetMouseEvent
:
:
ePlatformChild
:
WidgetMouseEvent
:
:
ePlatformTopLevel
;
[
oldView
sendMouseEnterOrExitEvent
:
aEvent
enter
:
NO
exitFrom
:
exitFrom
]
;
if
(
exitFrom
=
=
WidgetMouseEvent
:
:
ePlatformTopLevel
)
{
[
[
nsCursorManager
sharedInstance
]
setNonCustomCursor
:
nsIWidget
:
:
Cursor
{
eCursor_standard
}
]
;
}
[
sLastMouseEventView
sendMouseEnterOrExitEvent
:
aEvent
enter
:
YES
exitFrom
:
exitFrom
]
;
}
}
void
ChildViewMouseTracker
:
:
ResendLastMouseMoveEvent
(
)
{
if
(
sLastMouseMoveEvent
)
{
MouseMoved
(
sLastMouseMoveEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
MouseMoved
(
NSEvent
*
aEvent
)
{
MouseEnteredWindow
(
aEvent
)
;
[
sLastMouseEventView
handleMouseMoved
:
aEvent
]
;
if
(
sLastMouseMoveEvent
!
=
aEvent
)
{
[
sLastMouseMoveEvent
release
]
;
sLastMouseMoveEvent
=
[
aEvent
retain
]
;
}
}
void
ChildViewMouseTracker
:
:
MouseScrolled
(
NSEvent
*
aEvent
)
{
if
(
!
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
aEvent
)
)
{
sLastScrollEventScreenLocation
=
nsCocoaUtils
:
:
ScreenLocationForEvent
(
aEvent
)
;
}
}
ChildView
*
ChildViewMouseTracker
:
:
ViewForEvent
(
NSEvent
*
aEvent
)
{
NSWindow
*
window
=
sWindowUnderMouse
;
if
(
!
window
)
return
nil
;
NSPoint
windowEventLocation
=
nsCocoaUtils
:
:
EventLocationForWindow
(
aEvent
window
)
;
NSView
*
view
=
[
[
[
window
contentView
]
superview
]
hitTest
:
windowEventLocation
]
;
if
(
!
[
view
isKindOfClass
:
[
ChildView
class
]
]
)
return
nil
;
ChildView
*
childView
=
(
ChildView
*
)
view
;
if
(
!
[
childView
widget
]
)
return
nil
;
return
WindowAcceptsEvent
(
window
aEvent
childView
)
?
childView
:
nil
;
}
BOOL
ChildViewMouseTracker
:
:
WindowAcceptsEvent
(
NSWindow
*
aWindow
NSEvent
*
aEvent
ChildView
*
aView
BOOL
aIsClickThrough
)
{
if
(
!
aWindow
|
|
[
aEvent
type
]
=
=
NSEventTypeRightMouseDown
)
return
YES
;
id
delegate
=
[
aWindow
delegate
]
;
if
(
!
delegate
|
|
!
[
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
return
YES
;
nsIWidget
*
windowWidget
=
[
(
WindowDelegate
*
)
delegate
geckoWidget
]
;
if
(
!
windowWidget
)
return
YES
;
NSWindow
*
topLevelWindow
=
nil
;
switch
(
windowWidget
-
>
GetWindowType
(
)
)
{
case
WindowType
:
:
Popup
:
return
WindowAcceptsEvent
(
[
aWindow
parentWindow
]
aEvent
aView
aIsClickThrough
)
;
case
WindowType
:
:
TopLevel
:
case
WindowType
:
:
Dialog
:
if
(
aWindow
.
attachedSheet
)
{
return
NO
;
}
topLevelWindow
=
aWindow
;
break
;
default
:
return
YES
;
}
if
(
!
topLevelWindow
|
|
(
[
topLevelWindow
isMainWindow
]
&
&
!
aIsClickThrough
)
|
|
[
aEvent
type
]
=
=
NSEventTypeOtherMouseDown
|
|
(
(
[
aEvent
modifierFlags
]
&
NSEventModifierFlagCommand
)
!
=
0
&
&
[
aEvent
type
]
!
=
NSEventTypeMouseMoved
)
)
return
YES
;
return
[
aView
inactiveWindowAcceptsMouseEvent
:
aEvent
]
;
}
nsCocoaWindow
:
:
nsCocoaWindow
(
)
:
mWindow
(
nil
)
mClosedRetainedWindow
(
nil
)
mDelegate
(
nil
)
mChildView
(
nil
)
mBackingScaleFactor
(
0
.
0
)
mFullscreenTransitionAnimation
(
nil
)
mShadowStyle
(
WindowShadow
:
:
None
)
mAnimationType
(
nsIWidget
:
:
eGenericWindowAnimation
)
mWindowMadeHere
(
false
)
mSizeMode
(
nsSizeMode_Normal
)
mInFullScreenMode
(
false
)
mInNativeFullScreenMode
(
false
)
mIgnoreOcclusionCount
(
0
)
mHasStartedNativeFullscreen
(
false
)
mWindowAnimationBehavior
(
NSWindowAnimationBehaviorDefault
)
{
NSWindow
.
allowsAutomaticWindowTabbing
=
NO
;
}
void
nsCocoaWindow
:
:
DestroyNativeWindow
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
MOZ_ASSERT
(
mWindowMadeHere
"
We
shouldn
'
t
be
trying
to
destroy
a
window
we
didn
'
t
create
.
"
)
;
EndOurNativeTransition
(
)
;
Show
(
false
)
;
[
mWindow
removeTrackingArea
]
;
[
mWindow
releaseJSObjects
]
;
mWindow
.
delegate
=
nil
;
[
mClosedRetainedWindow
autorelease
]
;
mClosedRetainedWindow
=
[
mWindow
retain
]
;
MOZ_ASSERT
(
mWindow
.
releasedWhenClosed
)
;
[
mWindow
close
]
;
mWindow
=
nil
;
[
mDelegate
autorelease
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsCocoaWindow
:
:
~
nsCocoaWindow
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RemoveAllChildren
(
)
;
if
(
mWindow
&
&
mWindowMadeHere
)
{
CancelAllTransitions
(
)
;
DestroyNativeWindow
(
)
;
}
[
mClosedRetainedWindow
release
]
;
if
(
mContentLayer
)
{
mNativeLayerRoot
-
>
RemoveLayer
(
mContentLayer
)
;
}
DestroyCompositor
(
)
;
[
mChildView
widgetDestroyed
]
;
ClearParent
(
)
;
TearDownView
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
NSScreen
*
FindTargetScreenForRect
(
const
DesktopIntRect
&
aRect
)
{
NSScreen
*
targetScreen
=
[
NSScreen
mainScreen
]
;
NSEnumerator
*
screenEnum
=
[
[
NSScreen
screens
]
objectEnumerator
]
;
int
largestIntersectArea
=
0
;
while
(
NSScreen
*
screen
=
[
screenEnum
nextObject
]
)
{
DesktopIntRect
screenRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
[
screen
visibleFrame
]
)
;
screenRect
=
screenRect
.
Intersect
(
aRect
)
;
int
area
=
screenRect
.
width
*
screenRect
.
height
;
if
(
area
>
largestIntersectArea
)
{
largestIntersectArea
=
area
;
targetScreen
=
screen
;
}
}
return
targetScreen
;
}
DesktopToLayoutDeviceScale
ParentBackingScaleFactor
(
nsIWidget
*
aParent
)
{
if
(
aParent
)
{
return
aParent
-
>
GetDesktopToDeviceScale
(
)
;
}
return
DesktopToLayoutDeviceScale
(
1
.
0
)
;
}
static
DesktopRect
GetWidgetScreenRectForChildren
(
nsIWidget
*
aWidget
)
{
mozilla
:
:
DesktopToLayoutDeviceScale
scale
=
aWidget
-
>
GetDesktopToDeviceScale
(
)
;
return
aWidget
-
>
GetClientBounds
(
)
/
scale
;
}
nsresult
nsCocoaWindow
:
:
Create
(
nsIWidget
*
aParent
const
DesktopIntRect
&
aRect
widget
:
:
InitData
*
aInitData
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsAutoreleasePool
localPool
;
mWindowType
=
WindowType
:
:
TopLevel
;
mBorderStyle
=
BorderStyle
:
:
Default
;
nsToolkit
:
:
GetToolkit
(
)
;
Inherited
:
:
BaseCreate
(
aParent
aInitData
)
;
mAlwaysOnTop
=
aInitData
-
>
mAlwaysOnTop
;
mIsAlert
=
aInitData
-
>
mIsAlert
;
DesktopIntPoint
parentOrigin
;
if
(
aParent
)
{
DesktopRect
parentDesktopRect
=
GetWidgetScreenRectForChildren
(
aParent
)
;
parentOrigin
=
gfx
:
:
RoundedToInt
(
parentDesktopRect
.
TopLeft
(
)
)
;
}
DesktopIntRect
widgetRect
=
aRect
+
parentOrigin
;
nsresult
rv
=
CreateNativeWindow
(
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
widgetRect
)
mBorderStyle
false
aInitData
-
>
mIsPrivate
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsAnimationSuppressed
=
aInitData
-
>
mIsAnimationSuppressed
;
NSView
*
contentView
=
mWindow
.
contentView
;
mChildView
=
[
[
ChildView
alloc
]
initWithFrame
:
mWindow
.
childViewFrameRectForCurrentBounds
geckoChild
:
this
]
;
mChildView
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewHeightSizable
;
[
contentView
addSubview
:
mChildView
]
;
mNativeLayerRoot
=
NativeLayerRootCA
:
:
CreateForCALayer
(
mChildView
.
rootCALayer
)
;
mNativeLayerRoot
-
>
SetBackingScale
(
BackingScaleFactor
(
)
)
;
[
WindowDataMap
.
sharedWindowDataMap
ensureDataForWindow
:
mWindow
]
;
NS_ASSERTION
(
!
mTextInputHandler
"
mTextInputHandler
has
already
existed
"
)
;
mTextInputHandler
=
new
TextInputHandler
(
this
mChildView
)
;
[
mWindow
makeFirstResponder
:
mChildView
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
Create
(
nsIWidget
*
aParent
const
LayoutDeviceIntRect
&
aRect
widget
:
:
InitData
*
aInitData
)
{
DesktopIntRect
desktopRect
=
RoundedToInt
(
aRect
/
ParentBackingScaleFactor
(
aParent
)
)
;
return
Create
(
aParent
desktopRect
aInitData
)
;
}
static
unsigned
int
WindowMaskForBorderStyle
(
BorderStyle
aBorderStyle
)
{
bool
allOrDefault
=
(
aBorderStyle
=
=
BorderStyle
:
:
All
|
|
aBorderStyle
=
=
BorderStyle
:
:
Default
)
;
if
(
!
allOrDefault
&
&
!
(
aBorderStyle
&
BorderStyle
:
:
Title
)
)
{
if
(
aBorderStyle
&
BorderStyle
:
:
Minimize
)
{
return
NSWindowStyleMaskBorderless
|
NSWindowStyleMaskMiniaturizable
;
}
return
NSWindowStyleMaskBorderless
;
}
unsigned
int
mask
=
NSWindowStyleMaskTitled
;
if
(
allOrDefault
|
|
aBorderStyle
&
BorderStyle
:
:
Close
)
{
mask
|
=
NSWindowStyleMaskClosable
;
}
if
(
allOrDefault
|
|
aBorderStyle
&
BorderStyle
:
:
Minimize
)
{
mask
|
=
NSWindowStyleMaskMiniaturizable
;
}
if
(
allOrDefault
|
|
aBorderStyle
&
BorderStyle
:
:
ResizeH
)
{
mask
|
=
NSWindowStyleMaskResizable
;
}
return
mask
;
}
nsresult
nsCocoaWindow
:
:
CreateNativeWindow
(
const
NSRect
&
aRect
BorderStyle
aBorderStyle
bool
aRectIsFrameRect
bool
aIsPrivateBrowsing
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
unsigned
int
features
=
NSWindowStyleMaskBorderless
;
switch
(
mWindowType
)
{
case
WindowType
:
:
Invisible
:
break
;
case
WindowType
:
:
Popup
:
if
(
aBorderStyle
!
=
BorderStyle
:
:
Default
&
&
mBorderStyle
&
BorderStyle
:
:
Title
)
{
features
|
=
NSWindowStyleMaskTitled
;
if
(
aBorderStyle
&
BorderStyle
:
:
Close
)
{
features
|
=
NSWindowStyleMaskClosable
;
}
}
break
;
case
WindowType
:
:
TopLevel
:
case
WindowType
:
:
Dialog
:
features
=
WindowMaskForBorderStyle
(
aBorderStyle
)
;
break
;
default
:
NS_ERROR
(
"
Unhandled
window
type
!
"
)
;
return
NS_ERROR_FAILURE
;
}
NSRect
contentRect
;
if
(
aRectIsFrameRect
)
{
contentRect
=
[
NSWindow
contentRectForFrameRect
:
aRect
styleMask
:
features
]
;
}
else
{
NSRect
newWindowFrame
=
[
NSWindow
frameRectForContentRect
:
aRect
styleMask
:
features
]
;
contentRect
=
aRect
;
contentRect
.
origin
.
y
-
=
(
newWindowFrame
.
size
.
height
-
aRect
.
size
.
height
)
;
if
(
mWindowType
!
=
WindowType
:
:
Popup
)
{
contentRect
.
origin
.
y
-
=
NSApp
.
mainMenu
.
menuBarHeight
;
}
}
Class
windowClass
=
[
BaseWindow
class
]
;
if
(
(
mWindowType
=
=
WindowType
:
:
TopLevel
|
|
mWindowType
=
=
WindowType
:
:
Dialog
)
&
&
(
features
&
NSWindowStyleMaskTitled
)
)
{
windowClass
=
[
ToolbarWindow
class
]
;
}
else
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
windowClass
=
[
PopupWindow
class
]
;
}
else
if
(
features
=
=
NSWindowStyleMaskBorderless
)
{
windowClass
=
[
BorderlessWindow
class
]
;
}
mWindow
=
[
[
windowClass
alloc
]
initWithContentRect
:
contentRect
styleMask
:
features
backing
:
NSBackingStoreBuffered
defer
:
YES
]
;
mWindow
.
restorable
=
!
aIsPrivateBrowsing
;
if
(
aIsPrivateBrowsing
)
{
[
mWindow
disableSnapshotRestoration
]
;
}
mDelegate
=
[
[
WindowDelegate
alloc
]
initWithGeckoWindow
:
this
]
;
mWindow
.
delegate
=
mDelegate
;
NSRect
wantedFrame
=
[
mWindow
frameRectForChildViewRect
:
contentRect
]
;
if
(
!
NSEqualRects
(
mWindow
.
frame
wantedFrame
)
)
{
[
mWindow
setFrame
:
wantedFrame
display
:
NO
]
;
}
UpdateBounds
(
)
;
if
(
mWindowType
=
=
WindowType
:
:
Invisible
)
{
mWindow
.
level
=
kCGDesktopWindowLevelKey
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
SetPopupWindowLevel
(
)
;
mWindow
.
backgroundColor
=
NSColor
.
clearColor
;
mWindow
.
opaque
=
NO
;
mWindow
.
collectionBehavior
=
mWindow
.
collectionBehavior
|
NSWindowCollectionBehaviorMoveToActiveSpace
;
}
else
{
mWindow
.
opaque
=
YES
;
}
if
(
mAlwaysOnTop
|
|
mIsAlert
)
{
mWindow
.
level
=
NSFloatingWindowLevel
;
mWindow
.
collectionBehavior
=
mWindow
.
collectionBehavior
|
NSWindowCollectionBehaviorCanJoinAllSpaces
;
}
mWindow
.
contentMinSize
=
NSMakeSize
(
60
60
)
;
[
mWindow
disableCursorRects
]
;
mWindow
.
contentView
.
wantsLayer
=
YES
;
[
mWindow
createTrackingArea
]
;
mWindow
.
movableByWindowBackground
=
NO
;
[
WindowDataMap
.
sharedWindowDataMap
ensureDataForWindow
:
mWindow
]
;
mWindowMadeHere
=
true
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsCocoaWindow
:
:
Destroy
(
)
{
if
(
mOnDestroyCalled
)
{
return
;
}
mOnDestroyCalled
=
true
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
if
(
mModal
)
{
SetModal
(
false
)
;
}
Show
(
false
)
;
{
MutexAutoLock
lock
(
mCompositingLock
)
;
[
mChildView
widgetDestroyed
]
;
}
TearDownView
(
)
;
if
(
mFullscreenTransitionAnimation
)
{
[
mFullscreenTransitionAnimation
stopAnimation
]
;
ReleaseFullscreenTransitionAnimation
(
)
;
}
if
(
mInFullScreenMode
&
&
!
mInNativeFullScreenMode
)
{
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
false
)
;
}
if
(
mWindow
&
&
mWindowMadeHere
)
{
CancelAllTransitions
(
)
;
DestroyNativeWindow
(
)
;
}
nsBaseWidget
:
:
OnDestroy
(
)
;
nsBaseWidget
:
:
Destroy
(
)
;
}
void
*
nsCocoaWindow
:
:
GetNativeData
(
uint32_t
aDataType
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
void
*
retVal
=
nullptr
;
switch
(
aDataType
)
{
case
NS_NATIVE_WIDGET
:
retVal
=
mChildView
;
break
;
case
NS_NATIVE_WINDOW
:
retVal
=
mWindow
;
break
;
case
NS_NATIVE_GRAPHIC
:
NS_ERROR
(
"
Requesting
NS_NATIVE_GRAPHIC
on
a
top
-
level
window
!
"
)
;
break
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
retVal
=
GetPseudoIMEContext
(
)
;
if
(
retVal
)
{
break
;
}
retVal
=
[
mChildView
inputContext
]
;
if
(
NS_WARN_IF
(
!
retVal
)
)
{
retVal
=
this
;
}
break
;
case
NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID
:
{
retVal
=
(
void
*
)
mWindow
.
windowNumber
;
break
;
}
}
return
retVal
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nullptr
)
;
}
bool
nsCocoaWindow
:
:
IsVisible
(
)
const
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
mWindow
&
&
mWindow
.
isVisibleOrBeingShown
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
void
nsCocoaWindow
:
:
SetModal
(
bool
aModal
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mModal
=
=
aModal
)
{
return
;
}
nsAutoreleasePool
localPool
;
mModal
=
aModal
;
if
(
aModal
)
{
sModalWindowCount
+
+
;
}
else
{
MOZ_ASSERT
(
sModalWindowCount
)
;
sModalWindowCount
-
-
;
}
for
(
auto
*
ancestorWidget
=
mParent
;
ancestorWidget
;
ancestorWidget
=
ancestorWidget
-
>
GetParent
(
)
)
{
auto
*
ancestor
=
static_cast
<
nsCocoaWindow
*
>
(
ancestorWidget
)
;
const
bool
changed
=
aModal
?
ancestor
-
>
mNumModalDescendants
+
+
=
=
0
:
-
-
ancestor
-
>
mNumModalDescendants
=
=
0
;
NS_ASSERTION
(
ancestor
-
>
mNumModalDescendants
>
=
0
"
Widget
hierarchy
changed
while
modal
!
"
)
;
if
(
!
changed
|
|
ancestor
-
>
mWindowType
=
=
WindowType
:
:
Invisible
)
{
continue
;
}
NSWindow
*
win
=
ancestor
-
>
GetCocoaWindow
(
)
;
[
[
win
standardWindowButton
:
NSWindowCloseButton
]
setEnabled
:
!
aModal
]
;
[
[
win
standardWindowButton
:
NSWindowMiniaturizeButton
]
setEnabled
:
!
aModal
]
;
[
[
win
standardWindowButton
:
NSWindowZoomButton
]
setEnabled
:
!
aModal
]
;
}
if
(
aModal
)
{
mWindow
.
level
=
NSModalPanelWindowLevel
;
}
else
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
SetPopupWindowLevel
(
)
;
}
else
{
mWindow
.
level
=
NSNormalWindowLevel
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
IsRunningAppModal
(
)
{
return
[
NSApp
_isRunningAppModal
]
;
}
void
nsCocoaWindow
:
:
Show
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
if
(
aState
=
=
mWindow
.
isVisibleOrBeingShown
)
{
return
;
}
[
mWindow
setBeingShown
:
aState
]
;
if
(
aState
&
&
!
mWasShown
)
{
mWasShown
=
true
;
}
NSWindow
*
nativeParentWindow
=
mParent
?
(
NSWindow
*
)
mParent
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
:
nil
;
if
(
aState
&
&
!
mBounds
.
IsEmpty
(
)
)
{
if
(
NSApp
.
activationPolicy
!
=
NSApplicationActivationPolicyRegular
)
{
NSApp
.
activationPolicy
=
NSApplicationActivationPolicyRegular
;
PR_SetEnv
(
"
MOZ_APP_NO_DOCK
=
"
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
&
&
nativeParentWindow
)
{
if
(
!
nativeParentWindow
.
isVisible
|
|
nativeParentWindow
.
isMiniaturized
)
{
return
;
}
}
bool
savedValueForSupportsNativeFullscreen
=
GetSupportsNativeFullscreen
(
)
;
if
(
!
mInFullScreenMode
&
&
(
(
mWindowType
=
=
WindowType
:
:
Popup
)
|
|
mAlwaysOnTop
|
|
mIsAlert
)
)
{
SetSupportsNativeFullscreen
(
false
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
[
mWindow
contentView
]
setNeedsDisplay
:
YES
]
;
if
(
!
nativeParentWindow
|
|
mPopupLevel
!
=
PopupLevel
:
:
Parent
)
{
[
mWindow
orderFront
:
nil
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
if
(
[
mWindow
isKindOfClass
:
[
PopupWindow
class
]
]
&
&
[
(
PopupWindow
*
)
mWindow
isContextMenu
]
)
{
[
NSDistributedNotificationCenter
.
defaultCenter
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
beginMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
}
if
(
nativeParentWindow
&
&
mPopupLevel
=
=
PopupLevel
:
:
Parent
)
{
[
nativeParentWindow
addChildWindow
:
mWindow
ordered
:
NSWindowAbove
]
;
}
}
else
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindowType
=
=
WindowType
:
:
TopLevel
&
&
[
mWindow
respondsToSelector
:
selector
(
setAnimationBehavior
:
)
]
)
{
NSWindowAnimationBehavior
behavior
;
if
(
mIsAnimationSuppressed
)
{
behavior
=
NSWindowAnimationBehaviorNone
;
}
else
{
switch
(
mAnimationType
)
{
case
nsIWidget
:
:
eDocumentWindowAnimation
:
behavior
=
NSWindowAnimationBehaviorDocumentWindow
;
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
unexpected
mAnimationType
value
"
)
;
case
nsIWidget
:
:
eGenericWindowAnimation
:
behavior
=
NSWindowAnimationBehaviorDefault
;
break
;
}
}
[
mWindow
setAnimationBehavior
:
behavior
]
;
mWindowAnimationBehavior
=
behavior
;
}
if
(
mAlwaysOnTop
|
|
mIsAlert
)
{
[
mWindow
orderFront
:
nil
]
;
}
else
{
[
mWindow
makeKeyAndOrderFront
:
nil
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
SetSupportsNativeFullscreen
(
savedValueForSupportsNativeFullscreen
)
;
if
(
mDeferredWorkspaceID
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
MoveVisibleWindowToWorkspace
(
mDeferredWorkspaceID
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
mDeferredWorkspaceID
=
0
;
}
}
else
{
if
(
mWindowType
=
=
WindowType
:
:
TopLevel
|
|
mWindowType
=
=
WindowType
:
:
Dialog
)
{
RollUpPopups
(
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
&
&
nativeParentWindow
)
{
[
nativeParentWindow
removeChildWindow
:
mWindow
]
;
}
[
mWindow
orderOut
:
nil
]
;
if
(
[
mWindow
isKindOfClass
:
[
PopupWindow
class
]
]
&
&
[
(
PopupWindow
*
)
mWindow
isContextMenu
]
)
{
[
NSDistributedNotificationCenter
.
defaultCenter
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
endMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
}
}
[
mWindow
setBeingShown
:
NO
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
NeedsRecreateToReshow
(
)
{
return
mWindowType
=
=
WindowType
:
:
Popup
&
&
mWasShown
&
&
NSScreen
.
screens
.
count
>
1
;
}
bool
nsCocoaWindow
:
:
ShouldUseOffMainThreadCompositing
(
)
{
if
(
HasRemoteContent
(
)
)
{
return
true
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
return
false
;
}
return
nsBaseWidget
:
:
ShouldUseOffMainThreadCompositing
(
)
;
}
TransparencyMode
nsCocoaWindow
:
:
GetTransparencyMode
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
mWindow
.
isOpaque
?
TransparencyMode
:
:
Opaque
:
TransparencyMode
:
:
Transparent
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
TransparencyMode
:
:
Opaque
)
;
}
void
nsCocoaWindow
:
:
SetTransparencyMode
(
TransparencyMode
aMode
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
BOOL
isTransparent
=
aMode
=
=
TransparencyMode
:
:
Transparent
;
BOOL
currentTransparency
=
!
mWindow
.
isOpaque
;
if
(
isTransparent
=
=
currentTransparency
)
{
return
;
}
mWindow
.
opaque
=
!
isTransparent
;
mWindow
.
backgroundColor
=
isTransparent
?
NSColor
.
clearColor
:
NSColor
.
whiteColor
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
Enable
(
bool
aState
)
{
}
bool
nsCocoaWindow
:
:
IsEnabled
(
)
const
{
return
true
;
}
void
nsCocoaWindow
:
:
ConstrainPosition
(
DesktopIntPoint
&
aPoint
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
|
|
!
[
mWindow
screen
]
)
{
return
;
}
DesktopIntRect
screenRect
;
int32_t
width
height
;
NSRect
frame
=
mWindow
.
frame
;
width
=
std
:
:
max
<
int32_t
>
(
frame
.
size
.
width
1
)
;
height
=
std
:
:
max
<
int32_t
>
(
frame
.
size
.
height
1
)
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenMgr
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
screenMgr
-
>
ScreenForRect
(
aPoint
.
x
aPoint
.
y
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
screenRect
=
screen
-
>
GetRectDisplayPix
(
)
;
}
}
aPoint
=
ConstrainPositionToBounds
(
aPoint
{
width
height
}
screenRect
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSizeConstraints
(
const
SizeConstraints
&
aConstraints
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSRect
rect
=
(
mWindowType
=
=
WindowType
:
:
Popup
)
?
NSZeroRect
:
NSMakeRect
(
0
.
0
0
.
0
32
32
)
;
rect
=
[
mWindow
frameRectForChildViewRect
:
rect
]
;
SizeConstraints
c
=
aConstraints
;
if
(
c
.
mScale
.
scale
=
=
MOZ_WIDGET_INVALID_SCALE
)
{
c
.
mScale
.
scale
=
BackingScaleFactor
(
)
;
}
c
.
mMinSize
.
width
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
rect
.
size
.
width
c
.
mScale
.
scale
)
c
.
mMinSize
.
width
)
;
c
.
mMinSize
.
height
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
rect
.
size
.
height
c
.
mScale
.
scale
)
c
.
mMinSize
.
height
)
;
NSSize
minSize
=
{
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMinSize
.
width
c
.
mScale
.
scale
)
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMinSize
.
height
c
.
mScale
.
scale
)
}
;
mWindow
.
minSize
=
minSize
;
c
.
mMaxSize
.
width
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
c
.
mMaxSize
.
width
c
.
mScale
.
scale
)
c
.
mMaxSize
.
width
)
;
c
.
mMaxSize
.
height
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
c
.
mMaxSize
.
height
c
.
mScale
.
scale
)
c
.
mMaxSize
.
height
)
;
NSSize
maxSize
=
{
c
.
mMaxSize
.
width
=
=
NS_MAXSIZE
?
FLT_MAX
:
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMaxSize
.
width
c
.
mScale
.
scale
)
c
.
mMaxSize
.
height
=
=
NS_MAXSIZE
?
FLT_MAX
:
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMaxSize
.
height
c
.
mScale
.
scale
)
}
;
mWindow
.
maxSize
=
maxSize
;
nsBaseWidget
:
:
SetSizeConstraints
(
c
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
Move
(
double
aX
double
aY
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
NSPoint
coord
=
{
static_cast
<
float
>
(
aX
)
static_cast
<
float
>
(
nsCocoaUtils
:
:
FlippedScreenY
(
NSToIntRound
(
aY
)
)
)
}
;
NSRect
frame
=
mWindow
.
frame
;
if
(
frame
.
origin
.
x
!
=
coord
.
x
|
|
frame
.
origin
.
y
+
frame
.
size
.
height
!
=
coord
.
y
)
{
[
mWindow
setFrameTopLeftPoint
:
coord
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSizeMode
(
nsSizeMode
aMode
)
{
if
(
aMode
=
=
nsSizeMode_Normal
)
{
QueueTransition
(
TransitionType
:
:
Windowed
)
;
}
else
if
(
aMode
=
=
nsSizeMode_Minimized
)
{
QueueTransition
(
TransitionType
:
:
Miniaturize
)
;
}
else
if
(
aMode
=
=
nsSizeMode_Maximized
)
{
QueueTransition
(
TransitionType
:
:
Zoom
)
;
}
else
if
(
aMode
=
=
nsSizeMode_Fullscreen
)
{
MakeFullScreen
(
true
)
;
}
}
typedef
CGSSpaceID
(
*
CGSGetActiveSpaceFunc
)
(
CGSConnection
cid
)
;
static
CGSGetActiveSpaceFunc
GetCGSGetActiveSpaceFunc
(
)
{
static
CGSGetActiveSpaceFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSGetActiveSpaceFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSGetActiveSpace
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
CFArrayRef
(
*
CGSCopyManagedDisplaySpacesFunc
)
(
CGSConnection
cid
)
;
static
CGSCopyManagedDisplaySpacesFunc
GetCGSCopyManagedDisplaySpacesFunc
(
)
{
static
CGSCopyManagedDisplaySpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSCopyManagedDisplaySpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSCopyManagedDisplaySpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
CFArrayRef
(
*
CGSCopySpacesForWindowsFunc
)
(
CGSConnection
cid
CGSSpaceMask
mask
CFArrayRef
windowIDs
)
;
static
CGSCopySpacesForWindowsFunc
GetCGSCopySpacesForWindowsFunc
(
)
{
static
CGSCopySpacesForWindowsFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSCopySpacesForWindowsFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSCopySpacesForWindows
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
void
(
*
CGSAddWindowsToSpacesFunc
)
(
CGSConnection
cid
CFArrayRef
windowIDs
CFArrayRef
spaceIDs
)
;
static
CGSAddWindowsToSpacesFunc
GetCGSAddWindowsToSpacesFunc
(
)
{
static
CGSAddWindowsToSpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSAddWindowsToSpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSAddWindowsToSpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
void
(
*
CGSRemoveWindowsFromSpacesFunc
)
(
CGSConnection
cid
CFArrayRef
windowIDs
CFArrayRef
spaceIDs
)
;
static
CGSRemoveWindowsFromSpacesFunc
GetCGSRemoveWindowsFromSpacesFunc
(
)
{
static
CGSRemoveWindowsFromSpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSRemoveWindowsFromSpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSRemoveWindowsFromSpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
void
nsCocoaWindow
:
:
GetWorkspaceID
(
nsAString
&
workspaceID
)
{
workspaceID
.
Truncate
(
)
;
int32_t
sid
=
GetWorkspaceID
(
)
;
if
(
sid
!
=
0
)
{
workspaceID
.
AppendInt
(
sid
)
;
}
}
int32_t
nsCocoaWindow
:
:
GetWorkspaceID
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
CGSSpaceID
sid
=
0
;
CGSCopySpacesForWindowsFunc
CopySpacesForWindows
=
GetCGSCopySpacesForWindowsFunc
(
)
;
if
(
!
CopySpacesForWindows
)
{
return
sid
;
}
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
NSArray
<
NSNumber
*
>
*
spaceIDs
=
CFBridgingRelease
(
CopySpacesForWindows
(
cid
kCGSAllSpacesMask
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
)
)
;
if
(
[
spaceIDs
count
]
)
{
sid
=
[
spaceIDs
[
0
]
integerValue
]
;
}
else
{
CGSGetActiveSpaceFunc
GetActiveSpace
=
GetCGSGetActiveSpaceFunc
(
)
;
if
(
GetActiveSpace
)
{
sid
=
GetActiveSpace
(
cid
)
;
}
}
return
sid
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
MoveToWorkspace
(
const
nsAString
&
workspaceIDStr
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsresult
rv
=
NS_OK
;
int32_t
workspaceID
=
workspaceIDStr
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
mWindow
.
isVisible
)
{
MoveVisibleWindowToWorkspace
(
workspaceID
)
;
}
else
{
mDeferredWorkspaceID
=
workspaceID
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
MoveVisibleWindowToWorkspace
(
int32_t
workspaceID
)
{
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
int32_t
currentSpace
=
GetWorkspaceID
(
)
;
if
(
!
workspaceID
|
|
workspaceID
=
=
currentSpace
)
{
return
;
}
CGSCopyManagedDisplaySpacesFunc
CopyManagedDisplaySpaces
=
GetCGSCopyManagedDisplaySpacesFunc
(
)
;
CGSAddWindowsToSpacesFunc
AddWindowsToSpaces
=
GetCGSAddWindowsToSpacesFunc
(
)
;
CGSRemoveWindowsFromSpacesFunc
RemoveWindowsFromSpaces
=
GetCGSRemoveWindowsFromSpacesFunc
(
)
;
if
(
!
CopyManagedDisplaySpaces
|
|
!
AddWindowsToSpaces
|
|
!
RemoveWindowsFromSpaces
)
{
return
;
}
NSArray
*
displaySpacesInfo
=
CFBridgingRelease
(
CopyManagedDisplaySpaces
(
cid
)
)
;
BOOL
found
=
false
;
for
(
NSDictionary
<
NSString
*
id
>
*
spacesInfo
in
displaySpacesInfo
)
{
NSArray
<
NSNumber
*
>
*
sids
=
[
spacesInfo
[
CGSSpacesKey
]
valueForKey
:
CGSSpaceIDKey
]
;
for
(
NSNumber
*
sid
in
sids
)
{
if
(
(
int
)
[
sid
integerValue
]
=
=
workspaceID
)
{
found
=
true
;
break
;
}
}
if
(
found
)
{
break
;
}
}
if
(
!
found
)
{
return
;
}
AddWindowsToSpaces
(
cid
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
(
__bridge
CFArrayRef
)
[
(
workspaceID
)
]
)
;
RemoveWindowsFromSpaces
(
cid
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
(
__bridge
CFArrayRef
)
[
(
currentSpace
)
]
)
;
}
void
nsCocoaWindow
:
:
SuppressAnimation
(
bool
aSuppress
)
{
if
(
[
mWindow
respondsToSelector
:
selector
(
setAnimationBehavior
:
)
]
)
{
mWindow
.
isAnimationSuppressed
=
aSuppress
;
mWindow
.
animationBehavior
=
aSuppress
?
NSWindowAnimationBehaviorNone
:
mWindowAnimationBehavior
;
}
}
void
nsCocoaWindow
:
:
HideWindowChrome
(
bool
aShouldHide
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
|
|
!
mWindowMadeHere
|
|
(
mWindowType
!
=
WindowType
:
:
TopLevel
&
&
mWindowType
!
=
WindowType
:
:
Dialog
)
)
{
return
;
}
const
BOOL
isVisible
=
mWindow
.
isVisible
;
NSArray
*
childWindows
=
[
mWindow
childWindows
]
;
NSEnumerator
*
enumerator
=
[
childWindows
objectEnumerator
]
;
NSWindow
*
child
=
nil
;
while
(
(
child
=
[
enumerator
nextObject
]
)
)
{
[
mWindow
removeChildWindow
:
child
]
;
}
NSArray
<
NSView
*
>
*
contentViewContents
=
[
mWindow
contentViewContents
]
;
for
(
NSView
*
view
in
contentViewContents
)
{
[
view
removeFromSuperviewWithoutNeedingDisplay
]
;
}
NSMutableDictionary
*
state
=
[
mWindow
exportState
]
;
NSRect
frameRect
=
mWindow
.
frame
;
BOOL
restorable
=
mWindow
.
restorable
;
DestroyNativeWindow
(
)
;
nsresult
rv
=
CreateNativeWindow
(
frameRect
aShouldHide
?
BorderStyle
:
:
None
:
mBorderStyle
true
restorable
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
[
mWindow
importState
:
state
]
;
for
(
NSView
*
view
in
contentViewContents
)
{
[
[
mWindow
contentView
]
addSubview
:
view
]
;
}
enumerator
=
[
childWindows
objectEnumerator
]
;
while
(
(
child
=
[
enumerator
nextObject
]
)
)
{
[
mWindow
addChildWindow
:
child
ordered
:
NSWindowAbove
]
;
}
if
(
isVisible
)
{
bool
wasAnimationSuppressed
=
mIsAnimationSuppressed
;
mIsAnimationSuppressed
=
true
;
Show
(
true
)
;
mIsAnimationSuppressed
=
wasAnimationSuppressed
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
class
FullscreenTransitionData
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
FullscreenTransitionData
(
NSWindow
*
aWindow
)
:
mTransitionWindow
(
aWindow
)
{
}
NSWindow
*
mTransitionWindow
;
private
:
virtual
~
FullscreenTransitionData
(
)
{
[
mTransitionWindow
close
]
;
}
}
;
NS_IMPL_ISUPPORTS0
(
FullscreenTransitionData
)
interface
FullscreenTransitionDelegate
:
NSObject
<
NSAnimationDelegate
>
{
public
nsCocoaWindow
*
mWindow
;
nsIRunnable
*
mCallback
;
}
end
implementation
FullscreenTransitionDelegate
-
(
void
)
cleanupAndDispatch
:
(
NSAnimation
*
)
animation
{
[
animation
setDelegate
:
nil
]
;
[
self
autorelease
]
;
NS_DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
(
mCallback
)
)
;
}
-
(
void
)
animationDidEnd
:
(
NSAnimation
*
)
animation
{
MOZ_ASSERT
(
animation
=
=
mWindow
-
>
FullscreenTransitionAnimation
(
)
"
Should
be
handling
the
only
animation
on
the
window
"
)
;
mWindow
-
>
ReleaseFullscreenTransitionAnimation
(
)
;
[
self
cleanupAndDispatch
:
animation
]
;
}
-
(
void
)
animationDidStop
:
(
NSAnimation
*
)
animation
{
[
self
cleanupAndDispatch
:
animation
]
;
}
end
static
bool
AlwaysUsesNativeFullScreen
(
)
{
return
Preferences
:
:
GetBool
(
"
full
-
screen
-
api
.
macos
-
native
-
full
-
screen
"
false
)
;
}
bool
nsCocoaWindow
:
:
PrepareForFullscreenTransition
(
nsISupports
*
*
aData
)
{
if
(
AlwaysUsesNativeFullScreen
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mIgnoreOcclusionCount
>
=
0
)
;
mIgnoreOcclusionCount
+
+
;
nsCOMPtr
<
nsIScreen
>
widgetScreen
=
GetWidgetScreen
(
)
;
NSScreen
*
cocoaScreen
=
ScreenHelperCocoa
:
:
CocoaScreenForScreen
(
widgetScreen
)
;
NSWindow
*
win
=
[
[
NSWindow
alloc
]
initWithContentRect
:
cocoaScreen
.
frame
styleMask
:
NSWindowStyleMaskBorderless
backing
:
NSBackingStoreBuffered
defer
:
YES
]
;
[
win
setBackgroundColor
:
[
NSColor
blackColor
]
]
;
[
win
setAlphaValue
:
0
]
;
[
win
setIgnoresMouseEvents
:
YES
]
;
[
win
setLevel
:
NSScreenSaverWindowLevel
]
;
[
win
makeKeyAndOrderFront
:
nil
]
;
auto
data
=
new
FullscreenTransitionData
(
win
)
;
*
aData
=
data
;
NS_ADDREF
(
data
)
;
return
true
;
}
void
nsCocoaWindow
:
:
CleanupFullscreenTransition
(
)
{
MOZ_ASSERT
(
mIgnoreOcclusionCount
>
0
)
;
mIgnoreOcclusionCount
-
-
;
}
void
nsCocoaWindow
:
:
PerformFullscreenTransition
(
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsISupports
*
aData
nsIRunnable
*
aCallback
)
{
auto
data
=
static_cast
<
FullscreenTransitionData
*
>
(
aData
)
;
FullscreenTransitionDelegate
*
delegate
=
[
[
FullscreenTransitionDelegate
alloc
]
init
]
;
delegate
-
>
mWindow
=
this
;
delegate
-
>
mCallback
=
nsCOMPtr
<
nsIRunnable
>
(
aCallback
)
.
forget
(
)
.
take
(
)
;
if
(
mFullscreenTransitionAnimation
)
{
[
mFullscreenTransitionAnimation
stopAnimation
]
;
ReleaseFullscreenTransitionAnimation
(
)
;
}
NSDictionary
*
dict
=
{
NSViewAnimationTargetKey
:
data
-
>
mTransitionWindow
NSViewAnimationEffectKey
:
aStage
=
=
eBeforeFullscreenToggle
?
NSViewAnimationFadeInEffect
:
NSViewAnimationFadeOutEffect
}
;
mFullscreenTransitionAnimation
=
[
[
NSViewAnimation
alloc
]
initWithViewAnimations
:
[
dict
]
]
;
[
mFullscreenTransitionAnimation
setDelegate
:
delegate
]
;
[
mFullscreenTransitionAnimation
setDuration
:
aDuration
/
1000
.
0
]
;
[
mFullscreenTransitionAnimation
startAnimation
]
;
}
void
nsCocoaWindow
:
:
CocoaWindowWillEnterFullscreen
(
bool
aFullscreen
)
{
MOZ_ASSERT
(
mUpdateFullscreenOnResize
.
isNothing
(
)
)
;
mHasStartedNativeFullscreen
=
true
;
mUpdateFullscreenOnResize
=
Some
(
aFullscreen
?
TransitionType
:
:
Fullscreen
:
TransitionType
:
:
Windowed
)
;
}
void
nsCocoaWindow
:
:
CocoaWindowDidEnterFullscreen
(
bool
aFullscreen
)
{
EndOurNativeTransition
(
)
;
mHasStartedNativeFullscreen
=
false
;
DispatchOcclusionEvent
(
)
;
bool
receivedExpectedFullscreen
=
false
;
if
(
mUpdateFullscreenOnResize
.
isSome
(
)
)
{
bool
expectingFullscreen
=
(
*
mUpdateFullscreenOnResize
=
=
TransitionType
:
:
Fullscreen
)
;
receivedExpectedFullscreen
=
(
expectingFullscreen
=
=
aFullscreen
)
;
}
else
{
receivedExpectedFullscreen
=
(
mInFullScreenMode
=
=
aFullscreen
)
;
}
TransitionType
transition
=
aFullscreen
?
TransitionType
:
:
Fullscreen
:
TransitionType
:
:
Windowed
;
if
(
receivedExpectedFullscreen
)
{
HandleUpdateFullscreenOnResize
(
)
;
}
else
{
UpdateFullscreenState
(
aFullscreen
true
)
;
if
(
mTransitionCurrent
.
isSome
(
)
)
{
mTransitionCurrent
=
Some
(
transition
)
;
}
}
FinishCurrentTransitionIfMatching
(
transition
)
;
}
void
nsCocoaWindow
:
:
UpdateFullscreenState
(
bool
aFullScreen
bool
aNativeMode
)
{
bool
wasInFullscreen
=
mInFullScreenMode
;
mInFullScreenMode
=
aFullScreen
;
if
(
aNativeMode
|
|
mInNativeFullScreenMode
)
{
mInNativeFullScreenMode
=
aFullScreen
;
}
if
(
aFullScreen
=
=
wasInFullscreen
)
{
return
;
}
[
mWindow
updateChildViewFrameRect
]
;
DispatchSizeModeEvent
(
)
;
if
(
mNativeLayerRoot
)
{
mNativeLayerRoot
-
>
SetWindowIsFullscreen
(
aFullScreen
)
;
}
}
nsresult
nsCocoaWindow
:
:
MakeFullScreen
(
bool
aFullScreen
)
{
return
DoMakeFullScreen
(
aFullScreen
AlwaysUsesNativeFullScreen
(
)
)
;
}
nsresult
nsCocoaWindow
:
:
MakeFullScreenWithNativeTransition
(
bool
aFullScreen
)
{
return
DoMakeFullScreen
(
aFullScreen
true
)
;
}
nsresult
nsCocoaWindow
:
:
DoMakeFullScreen
(
bool
aFullScreen
bool
aUseSystemTransition
)
{
if
(
!
mWindow
)
{
return
NS_OK
;
}
TransitionType
transition
=
TransitionType
:
:
Windowed
;
if
(
aFullScreen
)
{
transition
=
(
aUseSystemTransition
&
&
(
mWindow
.
collectionBehavior
&
NSWindowCollectionBehaviorFullScreenPrimary
)
)
?
TransitionType
:
:
Fullscreen
:
TransitionType
:
:
EmulatedFullscreen
;
}
QueueTransition
(
transition
)
;
return
NS_OK
;
}
void
nsCocoaWindow
:
:
QueueTransition
(
const
TransitionType
&
aTransition
)
{
mTransitionsPending
.
push
(
aTransition
)
;
ProcessTransitions
(
)
;
}
void
nsCocoaWindow
:
:
ProcessTransitions
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
if
(
mInProcessTransitions
)
{
return
;
}
mInProcessTransitions
=
true
;
if
(
mProcessTransitionsPending
)
{
mProcessTransitionsPending
-
>
Cancel
(
)
;
mProcessTransitionsPending
=
nullptr
;
}
while
(
!
mTransitionsPending
.
empty
(
)
&
&
!
IsInTransition
(
)
)
{
TransitionType
nextTransition
=
mTransitionsPending
.
front
(
)
;
switch
(
nextTransition
)
{
case
TransitionType
:
:
Fullscreen
:
case
TransitionType
:
:
EmulatedFullscreen
:
case
TransitionType
:
:
Windowed
:
case
TransitionType
:
:
Zoom
:
if
(
mWindow
.
miniaturized
)
{
mTransitionCurrent
=
Some
(
TransitionType
:
:
Deminiaturize
)
;
mIsTransitionCurrentAdded
=
true
;
}
break
;
case
TransitionType
:
:
Miniaturize
:
if
(
mInFullScreenMode
)
{
mTransitionCurrent
=
Some
(
TransitionType
:
:
Windowed
)
;
mIsTransitionCurrentAdded
=
true
;
}
break
;
default
:
break
;
}
if
(
mTransitionCurrent
.
isNothing
(
)
)
{
mTransitionCurrent
=
Some
(
nextTransition
)
;
mTransitionsPending
.
pop
(
)
;
}
switch
(
*
mTransitionCurrent
)
{
case
TransitionType
:
:
Fullscreen
:
{
if
(
!
mInFullScreenMode
)
{
NSRunLoop
*
localRunLoop
=
[
NSRunLoop
currentRunLoop
]
;
while
(
mWindow
&
&
!
CanStartNativeTransition
(
)
&
&
[
localRunLoop
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
)
{
}
[
mWindow
toggleFullScreen
:
nil
]
;
continue
;
}
break
;
}
case
TransitionType
:
:
EmulatedFullscreen
:
{
if
(
!
mInFullScreenMode
)
{
mSuppressSizeModeEvents
=
true
;
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
true
)
;
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
true
)
;
mSuppressSizeModeEvents
=
false
;
UpdateFullscreenState
(
true
false
)
;
}
break
;
}
case
TransitionType
:
:
Windowed
:
{
if
(
mInFullScreenMode
)
{
if
(
mInNativeFullScreenMode
)
{
NSRunLoop
*
localRunLoop
=
[
NSRunLoop
currentRunLoop
]
;
while
(
mWindow
&
&
!
CanStartNativeTransition
(
)
&
&
[
localRunLoop
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
)
{
}
[
mWindow
toggleFullScreen
:
nil
]
;
continue
;
}
else
{
mSuppressSizeModeEvents
=
true
;
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
false
)
;
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
false
)
;
mSuppressSizeModeEvents
=
false
;
UpdateFullscreenState
(
false
false
)
;
}
}
else
if
(
mWindow
.
zoomed
)
{
[
mWindow
zoom
:
nil
]
;
if
(
mWindow
.
zoomed
)
{
NSRect
maximumFrame
=
mWindow
.
frame
;
const
CGFloat
INSET_OUT_OF_ZOOM
=
20
.
0f
;
[
mWindow
setFrame
:
NSInsetRect
(
maximumFrame
INSET_OUT_OF_ZOOM
INSET_OUT_OF_ZOOM
)
display
:
YES
]
;
MOZ_ASSERT
(
!
mWindow
.
zoomed
"
We
should
be
able
to
unzoom
by
shrinking
the
frame
a
bit
.
"
)
;
}
}
break
;
}
case
TransitionType
:
:
Miniaturize
:
if
(
!
mWindow
.
miniaturized
)
{
[
mWindow
miniaturize
:
nil
]
;
continue
;
}
break
;
case
TransitionType
:
:
Deminiaturize
:
if
(
mWindow
.
miniaturized
)
{
[
mWindow
deminiaturize
:
nil
]
;
continue
;
}
break
;
case
TransitionType
:
:
Zoom
:
if
(
!
mWindow
.
zoomed
)
{
[
mWindow
zoom
:
nil
]
;
}
break
;
default
:
break
;
}
mTransitionCurrent
.
reset
(
)
;
mIsTransitionCurrentAdded
=
false
;
}
mInProcessTransitions
=
false
;
if
(
!
IsInTransition
(
)
)
{
DispatchSizeModeEvent
(
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
CancelAllTransitions
(
)
{
mTransitionCurrent
.
reset
(
)
;
mIsTransitionCurrentAdded
=
false
;
if
(
mProcessTransitionsPending
)
{
mProcessTransitionsPending
-
>
Cancel
(
)
;
mProcessTransitionsPending
=
nullptr
;
}
std
:
:
queue
<
TransitionType
>
(
)
.
swap
(
mTransitionsPending
)
;
}
void
nsCocoaWindow
:
:
FinishCurrentTransitionIfMatching
(
const
TransitionType
&
aTransition
)
{
DispatchSizeModeEvent
(
)
;
if
(
mTransitionCurrent
.
isSome
(
)
&
&
(
*
mTransitionCurrent
=
=
aTransition
)
)
{
mTransitionCurrent
.
reset
(
)
;
mIsTransitionCurrentAdded
=
false
;
if
(
!
mTransitionsPending
.
empty
(
)
&
&
!
mProcessTransitionsPending
)
{
mProcessTransitionsPending
=
NS_NewCancelableRunnableFunction
(
"
ProcessTransitionsPending
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
ProcessTransitions
(
)
;
}
)
;
NS_DispatchToCurrentThread
(
mProcessTransitionsPending
)
;
}
}
}
bool
nsCocoaWindow
:
:
HandleUpdateFullscreenOnResize
(
)
{
if
(
mUpdateFullscreenOnResize
.
isNothing
(
)
)
{
return
false
;
}
bool
toFullscreen
=
(
*
mUpdateFullscreenOnResize
=
=
TransitionType
:
:
Fullscreen
)
;
mUpdateFullscreenOnResize
.
reset
(
)
;
UpdateFullscreenState
(
toFullscreen
true
)
;
return
true
;
}
nsCocoaWindow
*
nsCocoaWindow
:
:
sWindowInNativeTransition
(
nullptr
)
;
bool
nsCocoaWindow
:
:
CanStartNativeTransition
(
)
{
if
(
sWindowInNativeTransition
=
=
nullptr
)
{
sWindowInNativeTransition
=
this
;
return
true
;
}
return
false
;
}
void
nsCocoaWindow
:
:
EndOurNativeTransition
(
)
{
if
(
sWindowInNativeTransition
=
=
this
)
{
sWindowInNativeTransition
=
nullptr
;
}
}
void
nsCocoaWindow
:
:
DoResize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
bool
aConstrainToCurrentScreen
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
|
|
mInResize
)
{
return
;
}
auto
relockAspectRatio
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
mAspectRatioLocked
)
{
LockAspectRatio
(
true
)
;
}
}
)
;
AutoRestore
<
bool
>
reentrantResizeGuard
(
mInResize
)
;
mInResize
=
true
;
CGFloat
scale
=
mSizeConstraints
.
mScale
.
scale
;
if
(
scale
=
=
MOZ_WIDGET_INVALID_SCALE
)
{
scale
=
BackingScaleFactor
(
)
;
}
int32_t
width
=
NSToIntRound
(
aWidth
*
scale
)
;
int32_t
height
=
NSToIntRound
(
aHeight
*
scale
)
;
width
=
std
:
:
max
(
mSizeConstraints
.
mMinSize
.
width
std
:
:
min
(
mSizeConstraints
.
mMaxSize
.
width
width
)
)
;
height
=
std
:
:
max
(
mSizeConstraints
.
mMinSize
.
height
std
:
:
min
(
mSizeConstraints
.
mMaxSize
.
height
height
)
)
;
DesktopIntRect
newBounds
(
NSToIntRound
(
aX
)
NSToIntRound
(
aY
)
NSToIntRound
(
width
/
scale
)
NSToIntRound
(
height
/
scale
)
)
;
NSRect
newFrame
=
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
newBounds
)
;
NSRect
frame
=
mWindow
.
frame
;
BOOL
isMoving
=
newFrame
.
origin
.
x
!
=
frame
.
origin
.
x
|
|
newFrame
.
origin
.
y
!
=
frame
.
origin
.
y
;
BOOL
isResizing
=
newFrame
.
size
.
width
!
=
frame
.
size
.
width
|
|
newFrame
.
size
.
height
!
=
frame
.
size
.
height
;
if
(
!
isMoving
&
&
!
isResizing
)
{
return
;
}
[
mWindow
setFrame
:
newFrame
display
:
YES
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
Resize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
)
{
DoResize
(
aX
aY
aWidth
aHeight
aRepaint
false
)
;
}
void
nsCocoaWindow
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
double
invScale
=
1
.
0
/
BackingScaleFactor
(
)
;
DoResize
(
mBounds
.
x
*
invScale
mBounds
.
y
*
invScale
aWidth
aHeight
aRepaint
true
)
;
}
NSRect
nsCocoaWindow
:
:
GetClientCocoaRect
(
)
{
if
(
!
mWindow
)
{
return
NSZeroRect
;
}
return
[
mWindow
childViewRectForFrameRect
:
mWindow
.
frame
]
;
}
LayoutDeviceIntRect
nsCocoaWindow
:
:
GetClientBounds
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
CGFloat
scaleFactor
=
BackingScaleFactor
(
)
;
return
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
GetClientCocoaRect
(
)
scaleFactor
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
;
}
void
nsCocoaWindow
:
:
UpdateBounds
(
)
{
NSRect
frame
=
mWindow
?
mWindow
.
frame
:
NSZeroRect
;
mBounds
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
frame
BackingScaleFactor
(
)
)
;
}
LayoutDeviceIntRect
nsCocoaWindow
:
:
GetScreenBounds
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
#
ifdef
DEBUG
LayoutDeviceIntRect
r
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
mWindow
.
frame
BackingScaleFactor
(
)
)
;
NS_ASSERTION
(
mWindow
&
&
mBounds
=
=
r
"
mBounds
out
of
sync
!
"
)
;
#
endif
return
mBounds
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
;
}
double
nsCocoaWindow
:
:
GetDefaultScaleInternal
(
)
{
return
BackingScaleFactor
(
)
;
}
static
CGFloat
GetBackingScaleFactor
(
NSWindow
*
aWindow
)
{
NSRect
frame
=
aWindow
.
frame
;
if
(
frame
.
size
.
width
>
0
&
&
frame
.
size
.
height
>
0
)
{
return
nsCocoaUtils
:
:
GetBackingScaleFactor
(
aWindow
)
;
}
if
(
frame
.
size
.
width
=
=
0
)
{
frame
.
size
.
width
=
1
;
}
if
(
frame
.
size
.
height
=
=
0
)
{
frame
.
size
.
height
=
1
;
}
NSScreen
*
screen
=
FindTargetScreenForRect
(
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
frame
)
)
;
return
nsCocoaUtils
:
:
GetBackingScaleFactor
(
screen
)
;
}
CGFloat
nsCocoaWindow
:
:
BackingScaleFactor
(
)
const
{
if
(
mBackingScaleFactor
>
0
.
0
)
{
return
mBackingScaleFactor
;
}
if
(
!
mWindow
)
{
return
1
.
0
;
}
mBackingScaleFactor
=
GetBackingScaleFactor
(
mWindow
)
;
return
mBackingScaleFactor
;
}
void
nsCocoaWindow
:
:
BackingScaleFactorChanged
(
)
{
CGFloat
newScale
=
GetBackingScaleFactor
(
mWindow
)
;
if
(
BackingScaleFactor
(
)
=
=
newScale
)
{
return
;
}
SuspendAsyncCATransactions
(
)
;
mBackingScaleFactor
=
newScale
;
if
(
mNativeLayerRoot
)
{
mNativeLayerRoot
-
>
SetBackingScale
(
newScale
)
;
}
NotifyAPZOfDPIChange
(
)
;
if
(
mWidgetListener
)
{
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
}
}
int32_t
nsCocoaWindow
:
:
RoundsWidgetCoordinatesTo
(
)
{
if
(
BackingScaleFactor
(
)
=
=
2
.
0
)
{
return
2
;
}
return
1
;
}
nsresult
nsCocoaWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mWindow
)
{
return
NS_OK
;
}
const
nsString
&
strTitle
=
PromiseFlatString
(
aTitle
)
;
const
unichar
*
uniTitle
=
reinterpret_cast
<
const
unichar
*
>
(
strTitle
.
get
(
)
)
;
NSString
*
title
=
[
NSString
stringWithCharacters
:
uniTitle
length
:
strTitle
.
Length
(
)
]
;
if
(
mWindow
.
drawsContentsIntoWindowFrame
&
&
!
mWindow
.
wantsTitleDrawn
)
{
[
mWindow
disableSetNeedsDisplay
]
;
[
mWindow
setTitle
:
title
]
;
[
mWindow
enableSetNeedsDisplay
]
;
}
else
{
[
mWindow
setTitle
:
title
]
;
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
bool
nsCocoaWindow
:
:
DragEvent
(
unsigned
int
aMessage
mozilla
:
:
gfx
:
:
Point
aMouseGlobal
UInt16
aKeyModifiers
)
{
return
false
;
}
nsresult
nsCocoaWindow
:
:
DispatchEvent
(
WidgetGUIEvent
*
event
nsEventStatus
&
aStatus
)
{
RefPtr
kungFuDeathGrip
{
this
}
;
aStatus
=
nsEventStatus_eIgnore
;
if
(
event
-
>
mFlags
.
mIsSynthesizedForTests
)
{
if
(
WidgetKeyboardEvent
*
keyEvent
=
event
-
>
AsKeyboardEvent
(
)
)
{
nsresult
rv
=
mTextInputHandler
-
>
AttachNativeKeyEvent
(
*
keyEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
mAttachedWidgetListener
)
{
aStatus
=
mAttachedWidgetListener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
}
else
if
(
mWidgetListener
)
{
aStatus
=
mWidgetListener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
}
return
NS_OK
;
}
static
nsSizeMode
GetWindowSizeMode
(
NSWindow
*
aWindow
bool
aFullScreen
)
{
if
(
aFullScreen
)
{
return
nsSizeMode_Fullscreen
;
}
if
(
aWindow
.
isMiniaturized
)
{
return
nsSizeMode_Minimized
;
}
if
(
(
aWindow
.
styleMask
&
NSWindowStyleMaskResizable
)
&
&
aWindow
.
isZoomed
)
{
return
nsSizeMode_Maximized
;
}
return
nsSizeMode_Normal
;
}
void
nsCocoaWindow
:
:
ReportMoveEvent
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mInReportMoveEvent
)
{
return
;
}
mInReportMoveEvent
=
true
;
UpdateBounds
(
)
;
if
(
mWindow
&
&
(
mSizeMode
=
=
nsSizeMode_Maximized
)
^
mWindow
.
isZoomed
)
{
DispatchSizeModeEvent
(
)
;
}
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
mInReportMoveEvent
=
false
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
DispatchSizeModeEvent
(
)
{
if
(
!
mWindow
)
{
return
;
}
if
(
mSuppressSizeModeEvents
|
|
mIsTransitionCurrentAdded
)
{
return
;
}
nsSizeMode
newMode
=
GetWindowSizeMode
(
mWindow
mInFullScreenMode
)
;
if
(
mSizeMode
=
=
newMode
)
{
return
;
}
mSizeMode
=
newMode
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
SizeModeChanged
(
newMode
)
;
}
}
void
nsCocoaWindow
:
:
DispatchOcclusionEvent
(
)
{
if
(
!
mWindow
)
{
return
;
}
bool
newOcclusionState
=
!
(
mHasStartedNativeFullscreen
|
|
(
[
mWindow
occlusionState
]
&
NSWindowOcclusionStateVisible
)
)
;
if
(
mIsFullyOccluded
=
=
newOcclusionState
)
{
return
;
}
MOZ_ASSERT
(
mIgnoreOcclusionCount
>
=
0
)
;
if
(
newOcclusionState
&
&
mIgnoreOcclusionCount
>
0
)
{
return
;
}
mIsFullyOccluded
=
newOcclusionState
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
OcclusionStateChanged
(
mIsFullyOccluded
)
;
}
}
void
nsCocoaWindow
:
:
ReportSizeEvent
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
UpdateBounds
(
)
;
LayoutDeviceIntRect
innerBounds
=
GetClientBounds
(
)
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowResized
(
this
innerBounds
.
width
innerBounds
.
height
)
;
}
if
(
mAttachedWidgetListener
)
{
mAttachedWidgetListener
-
>
WindowResized
(
this
innerBounds
.
width
innerBounds
.
height
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetMenuBar
(
RefPtr
<
nsMenuBarX
>
&
&
aMenuBar
)
{
if
(
!
mWindow
)
{
mMenuBar
=
nullptr
;
return
;
}
mMenuBar
=
std
:
:
move
(
aMenuBar
)
;
if
(
mMenuBar
&
&
(
(
!
gSomeMenuBarPainted
&
&
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
=
=
mMenuBar
)
|
|
mWindow
.
isMainWindow
)
)
{
mMenuBar
-
>
PaintAsyncIfNeeded
(
)
;
}
}
void
nsCocoaWindow
:
:
SetFocus
(
Raise
aRaise
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
{
if
(
!
mWindow
)
return
;
if
(
aRaise
=
=
Raise
:
:
Yes
&
&
(
mWindow
.
isVisible
|
|
mWindow
.
isMiniaturized
)
)
{
if
(
mWindow
.
isMiniaturized
)
{
[
mWindow
deminiaturize
:
nil
]
;
}
[
mWindow
makeKeyAndOrderFront
:
nil
]
;
}
}
LayoutDeviceIntPoint
nsCocoaWindow
:
:
WidgetToScreenOffset
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
GetClientCocoaRect
(
)
BackingScaleFactor
(
)
)
.
TopLeft
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntPoint
nsCocoaWindow
:
:
GetClientOffset
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
LayoutDeviceIntRect
clientRect
=
GetClientBounds
(
)
;
return
clientRect
.
TopLeft
(
)
-
mBounds
.
TopLeft
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntMargin
nsCocoaWindow
:
:
NormalSizeModeClientToWindowMargin
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mWindow
|
|
mWindow
.
drawsContentsIntoWindowFrame
|
|
mWindowType
=
=
WindowType
:
:
Popup
)
{
return
{
}
;
}
NSRect
clientNSRect
=
mWindow
.
contentLayoutRect
;
NSRect
frameNSRect
=
[
mWindow
frameRectForChildViewRect
:
clientNSRect
]
;
CGFloat
backingScale
=
BackingScaleFactor
(
)
;
const
auto
clientRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
clientNSRect
backingScale
)
;
const
auto
frameRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
frameNSRect
backingScale
)
;
return
frameRect
-
clientRect
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
{
}
)
;
}
nsMenuBarX
*
nsCocoaWindow
:
:
GetMenuBar
(
)
{
return
mMenuBar
;
}
void
nsCocoaWindow
:
:
CaptureRollupEvents
(
bool
aDoCapture
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
aDoCapture
)
{
if
(
!
NSApp
.
isActive
)
{
nsToolkit
:
:
GetToolkit
(
)
-
>
MonitorAllProcessMouseEvents
(
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
SetPopupWindowLevel
(
)
;
}
}
else
{
nsToolkit
:
:
GetToolkit
(
)
-
>
StopMonitoringAllProcessMouseEvents
(
)
;
if
(
mWindow
&
&
mWindowType
=
=
WindowType
:
:
Popup
)
{
mWindow
.
level
=
NSModalPanelWindowLevel
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
GetAttention
(
int32_t
aCycleCount
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
[
NSApp
requestUserAttention
:
NSInformationalRequest
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
bool
nsCocoaWindow
:
:
HasPendingInputEvent
(
)
{
return
DoHasPendingInputEvent
(
)
;
}
void
nsCocoaWindow
:
:
SetWindowShadowStyle
(
WindowShadow
aStyle
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mShadowStyle
=
=
aStyle
)
{
return
;
}
mShadowStyle
=
aStyle
;
if
(
!
mWindow
|
|
mWindowType
!
=
WindowType
:
:
Popup
)
{
return
;
}
mWindow
.
shadowStyle
=
mShadowStyle
;
[
mWindow
setEffectViewWrapperForStyle
:
mShadowStyle
]
;
[
mWindow
setHasShadow
:
aStyle
!
=
WindowShadow
:
:
None
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowOpacity
(
float
aOpacity
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
[
mWindow
setAlphaValue
:
(
CGFloat
)
aOpacity
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetColorScheme
(
const
Maybe
<
ColorScheme
>
&
aScheme
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
NSAppearance
*
appearance
=
aScheme
?
NSAppearanceForColorScheme
(
*
aScheme
)
:
nil
;
if
(
mWindow
.
appearance
!
=
appearance
)
{
mWindow
.
appearance
=
appearance
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
inline
CGAffineTransform
GfxMatrixToCGAffineTransform
(
const
gfx
:
:
Matrix
&
m
)
{
CGAffineTransform
t
;
t
.
a
=
m
.
_11
;
t
.
b
=
m
.
_12
;
t
.
c
=
m
.
_21
;
t
.
d
=
m
.
_22
;
t
.
tx
=
m
.
_31
;
t
.
ty
=
m
.
_32
;
return
t
;
}
void
nsCocoaWindow
:
:
SetWindowTransform
(
const
gfx
:
:
Matrix
&
aTransform
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
if
(
!
mWindow
.
isVisible
|
|
NSIsEmptyRect
(
mWindow
.
frame
)
)
{
return
;
}
if
(
StaticPrefs
:
:
widget_window_transforms_disabled
(
)
)
{
return
;
}
gfx
:
:
Matrix
transform
=
aTransform
;
if
(
!
transform
.
Invert
(
)
)
{
transform
=
gfx
:
:
Matrix
(
)
;
}
bool
isIdentity
=
transform
.
IsIdentity
(
)
;
if
(
isIdentity
&
&
mWindowTransformIsIdentity
)
{
return
;
}
transform
.
PreTranslate
(
-
mBounds
.
x
-
mBounds
.
y
)
;
if
(
!
transform
.
HasNonTranslation
(
)
&
&
transform
.
HasNonIntegerTranslation
(
)
)
{
auto
snappedTranslation
=
gfx
:
:
IntPoint
:
:
Round
(
transform
.
GetTranslation
(
)
)
;
transform
=
gfx
:
:
Matrix
:
:
Translation
(
snappedTranslation
.
x
snappedTranslation
.
y
)
;
}
CGFloat
backingScale
=
BackingScaleFactor
(
)
;
transform
.
PreScale
(
backingScale
backingScale
)
;
transform
.
PostScale
(
1
/
backingScale
1
/
backingScale
)
;
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
CGSSetWindowTransform
(
cid
[
mWindow
windowNumber
]
GfxMatrixToCGAffineTransform
(
transform
)
)
;
mWindowTransformIsIdentity
=
isIdentity
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetInputRegion
(
const
InputRegion
&
aInputRegion
)
{
MOZ_ASSERT
(
mWindowType
=
=
WindowType
:
:
Popup
"
This
should
only
be
called
on
popup
windows
.
"
)
;
if
(
aInputRegion
.
mFullyTransparent
)
{
[
mWindow
setIgnoresMouseEvents
:
YES
]
;
}
else
{
[
mWindow
setIgnoresMouseEvents
:
NO
]
;
}
}
void
nsCocoaWindow
:
:
SetShowsToolbarButton
(
bool
aShow
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindow
)
[
mWindow
setShowsToolbarButton
:
aShow
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
GetSupportsNativeFullscreen
(
)
{
return
mWindow
.
collectionBehavior
&
NSWindowCollectionBehaviorFullScreenPrimary
;
}
void
nsCocoaWindow
:
:
SetSupportsNativeFullscreen
(
bool
aSupportsNativeFullscreen
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindow
)
{
NSWindowCollectionBehavior
newBehavior
=
[
mWindow
collectionBehavior
]
;
if
(
aSupportsNativeFullscreen
)
{
newBehavior
|
=
NSWindowCollectionBehaviorFullScreenPrimary
;
}
else
{
newBehavior
&
=
~
NSWindowCollectionBehaviorFullScreenPrimary
;
}
[
mWindow
setCollectionBehavior
:
newBehavior
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowAnimationType
(
nsIWidget
:
:
WindowAnimationType
aType
)
{
mAnimationType
=
aType
;
}
void
nsCocoaWindow
:
:
SetDrawsTitle
(
bool
aDrawTitle
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mWindow
.
wantsTitleDrawn
=
aDrawTitle
|
|
!
mWindow
.
drawsContentsIntoWindowFrame
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetCustomTitlebar
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindow
)
{
[
mWindow
setDrawsContentsIntoWindowFrame
:
aState
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
aShouldLock
)
{
[
mWindow
setContentAspectRatio
:
mWindow
.
frame
.
size
]
;
mAspectRatioLocked
=
true
;
}
else
{
[
mWindow
setResizeIncrements
:
NSMakeSize
(
1
.
0
1
.
0
)
]
;
mAspectRatioLocked
=
false
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetPopupWindowLevel
(
)
{
if
(
!
mWindow
)
{
return
;
}
mWindow
.
level
=
NSPopUpMenuWindowLevel
;
mWindow
.
hidesOnDeactivate
=
NO
;
}
bool
nsCocoaWindow
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
if
(
NS_WARN_IF
(
!
nsIWidget
:
:
GetEditCommands
(
aType
aEvent
aCommands
)
)
)
{
return
false
;
}
Maybe
<
WritingMode
>
writingMode
;
if
(
aEvent
.
NeedsToRemapNavigationKey
(
)
)
{
if
(
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcher
(
)
)
{
writingMode
=
dispatcher
-
>
MaybeQueryWritingModeAtSelection
(
)
;
}
}
NativeKeyBindings
*
keyBindings
=
NativeKeyBindings
:
:
GetInstance
(
aType
)
;
keyBindings
-
>
GetEditCommands
(
aEvent
writingMode
aCommands
)
;
return
true
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateTopLevelWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsCocoaWindow
(
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateChildWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsCocoaWindow
(
)
;
return
window
.
forget
(
)
;
}
implementation
WindowDelegate
+
(
void
)
paintMenubarForWindow
:
(
NSWindow
*
)
aWindow
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
NSApp
.
active
)
{
return
;
}
id
windowDelegate
=
[
aWindow
delegate
]
;
if
(
[
windowDelegate
class
]
!
=
[
self
class
]
)
return
;
nsCocoaWindow
*
geckoWidget
=
[
windowDelegate
geckoWidget
]
;
NS_ASSERTION
(
geckoWidget
"
Window
delegate
not
returning
a
gecko
widget
!
"
)
;
if
(
nsMenuBarX
*
geckoMenuBar
=
geckoWidget
-
>
GetMenuBar
(
)
)
{
geckoMenuBar
-
>
PaintAsyncIfNeeded
(
)
;
}
else
{
if
(
!
sApplicationMenu
)
{
return
;
}
NSMenu
*
mainMenu
=
NSApp
.
mainMenu
;
NS_ASSERTION
(
mainMenu
.
numberOfItems
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
GeckoNSMenu
*
newMenuBar
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
"
MainMenuBar
"
]
;
NSMenuItem
*
firstMenuItem
=
[
[
mainMenu
itemAtIndex
:
0
]
retain
]
;
[
mainMenu
removeItemAtIndex
:
0
]
;
[
newMenuBar
insertItem
:
firstMenuItem
atIndex
:
0
]
;
[
firstMenuItem
release
]
;
NSApp
.
mainMenu
=
newMenuBar
;
[
newMenuBar
release
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
id
)
initWithGeckoWindow
:
(
nsCocoaWindow
*
)
geckoWind
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
[
super
init
]
;
mGeckoWindow
=
geckoWind
;
mToplevelActiveState
=
false
;
mHasEverBeenZoomed
=
false
;
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
NSSize
)
windowWillResize
:
(
NSWindow
*
)
sender
toSize
:
(
NSSize
)
proposedFrameSize
{
RollUpPopups
(
)
;
return
proposedFrameSize
;
}
-
(
NSRect
)
windowWillUseStandardFrame
:
(
NSWindow
*
)
window
defaultFrame
:
(
NSRect
)
newFrame
{
return
window
.
screen
.
frame
;
}
void
nsCocoaWindow
:
:
CocoaSendToplevelActivateEvents
(
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowActivated
(
)
;
}
}
void
nsCocoaWindow
:
:
CocoaSendToplevelDeactivateEvents
(
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowDeactivated
(
)
;
}
}
void
nsCocoaWindow
:
:
CocoaWindowDidResize
(
)
{
UpdateBounds
(
)
;
if
(
HandleUpdateFullscreenOnResize
(
)
)
{
ReportSizeEvent
(
)
;
return
;
}
DispatchSizeModeEvent
(
)
;
ReportSizeEvent
(
)
;
}
-
(
void
)
windowDidResize
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
return
;
mGeckoWindow
-
>
CocoaWindowDidResize
(
)
;
}
-
(
void
)
windowDidChangeScreen
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
return
;
mGeckoWindow
-
>
BackingScaleFactorChanged
(
)
;
mGeckoWindow
-
>
ReportMoveEvent
(
)
;
}
-
(
void
)
windowWillEnterFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowWillEnterFullscreen
(
true
)
;
}
-
(
void
)
windowDidEnterFullScreen
:
(
NSNotification
*
)
notification
{
NSWindow
*
window
=
notification
.
object
;
NSView
*
frameView
=
window
.
contentView
.
superview
;
NSView
*
titlebarView
=
nil
;
NSView
*
titlebarContainerView
=
nil
;
if
(
[
frameView
respondsToSelector
:
selector
(
titlebarView
)
]
)
{
titlebarView
=
[
frameView
titlebarView
]
;
}
if
(
[
frameView
respondsToSelector
:
selector
(
titlebarContainerView
)
]
)
{
titlebarContainerView
=
[
frameView
titlebarContainerView
]
;
}
if
(
[
titlebarView
respondsToSelector
:
selector
(
setTransparent
:
)
]
)
{
[
titlebarView
setTransparent
:
NO
]
;
}
if
(
[
titlebarContainerView
respondsToSelector
:
selector
(
setTransparent
:
)
]
)
{
[
titlebarContainerView
setTransparent
:
NO
]
;
}
if
(
available
(
macOS
11
.
0
*
)
)
{
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
window
.
titlebarSeparatorStyle
=
NSTitlebarSeparatorStyleNone
;
}
}
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowDidEnterFullscreen
(
true
)
;
}
-
(
void
)
windowWillExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowWillEnterFullscreen
(
false
)
;
}
-
(
void
)
windowDidExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowDidEnterFullscreen
(
false
)
;
}
-
(
void
)
windowDidFailToEnterFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
MOZ_ASSERT
(
(
mGeckoWindow
-
>
GetCocoaWindow
(
)
.
styleMask
&
NSWindowStyleMaskFullScreen
)
=
=
0
)
;
MOZ_ASSERT
(
mGeckoWindow
-
>
SizeMode
(
)
=
=
nsSizeMode_Fullscreen
)
;
mGeckoWindow
-
>
CocoaWindowDidEnterFullscreen
(
false
)
;
}
-
(
void
)
windowDidFailToExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowDidEnterFullscreen
(
true
)
;
}
-
(
void
)
windowDidBecomeMain
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
NSApp
.
_isRunningAppModal
)
{
return
;
}
NSWindow
*
window
=
aNotification
.
object
;
if
(
window
)
{
[
WindowDelegate
paintMenubarForWindow
:
window
]
;
}
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
[
(
ToolbarWindow
*
)
window
windowMainStateChanged
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowDidResignMain
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
[
NSApp
_isRunningAppModal
]
)
return
;
RefPtr
<
nsMenuBarX
>
hiddenWindowMenuBar
=
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
;
if
(
hiddenWindowMenuBar
)
{
bool
isTerminating
=
false
;
nsCOMPtr
<
nsIAppStartup
>
appStartup
(
components
:
:
AppStartup
:
:
Service
(
)
)
;
if
(
appStartup
)
{
appStartup
-
>
GetAttemptingQuit
(
&
isTerminating
)
;
}
if
(
!
isTerminating
)
{
hiddenWindowMenuBar
-
>
PaintAsyncIfNeeded
(
)
;
}
}
NSWindow
*
window
=
[
aNotification
object
]
;
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
[
(
ToolbarWindow
*
)
window
windowMainStateChanged
]
;
}
}
-
(
void
)
windowDidBecomeKey
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
!
mGeckoWindow
)
{
return
;
}
if
(
mGeckoWindow
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowDidResignKey
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
nsIRollupListener
:
:
AllowAnimations
:
:
No
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowWillMove
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowDidMove
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
mGeckoWindow
-
>
ReportMoveEvent
(
)
;
}
-
(
BOOL
)
windowShouldClose
:
(
id
)
sender
{
nsIWidgetListener
*
listener
=
mGeckoWindow
?
mGeckoWindow
-
>
GetWidgetListener
(
)
:
nullptr
;
if
(
listener
)
listener
-
>
RequestWindowClose
(
mGeckoWindow
)
;
return
NO
;
}
-
(
void
)
windowWillClose
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowWillMiniaturize
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowDidMiniaturize
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
FinishCurrentTransitionIfMatching
(
nsCocoaWindow
:
:
TransitionType
:
:
Miniaturize
)
;
}
-
(
void
)
windowDidDeminiaturize
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
FinishCurrentTransitionIfMatching
(
nsCocoaWindow
:
:
TransitionType
:
:
Deminiaturize
)
;
}
-
(
BOOL
)
windowShouldZoom
:
(
NSWindow
*
)
window
toFrame
:
(
NSRect
)
proposedFrame
{
if
(
!
mHasEverBeenZoomed
&
&
window
.
isZoomed
)
{
return
NO
;
}
mHasEverBeenZoomed
=
YES
;
return
YES
;
}
-
(
void
)
windowDidChangeBackingProperties
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mGeckoWindow
-
>
BackingScaleFactorChanged
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowDidChangeOcclusionState
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
{
mGeckoWindow
-
>
DispatchOcclusionEvent
(
)
;
}
}
-
(
nsCocoaWindow
*
)
geckoWidget
{
return
mGeckoWindow
;
}
-
(
bool
)
toplevelActiveState
{
return
mToplevelActiveState
;
}
-
(
void
)
sendToplevelActivateEvents
{
if
(
!
mToplevelActiveState
&
&
mGeckoWindow
)
{
mGeckoWindow
-
>
CocoaSendToplevelActivateEvents
(
)
;
mToplevelActiveState
=
true
;
}
}
-
(
void
)
sendToplevelDeactivateEvents
{
if
(
mToplevelActiveState
&
&
mGeckoWindow
)
{
mGeckoWindow
-
>
CocoaSendToplevelDeactivateEvents
(
)
;
mToplevelActiveState
=
false
;
}
}
end
interface
NSView
(
FrameViewMethodSwizzling
)
-
(
NSPoint
)
FrameView__closeButtonOrigin
;
-
(
CGFloat
)
FrameView__titlebarHeight
;
end
implementation
NSView
(
FrameViewMethodSwizzling
)
-
(
NSPoint
)
FrameView__closeButtonOrigin
{
if
(
!
[
self
.
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
return
self
.
FrameView__closeButtonOrigin
;
}
auto
*
win
=
static_cast
<
ToolbarWindow
*
>
(
self
.
window
)
;
if
(
win
.
drawsContentsIntoWindowFrame
&
&
!
win
.
wantsTitleDrawn
&
&
!
(
win
.
styleMask
&
NSWindowStyleMaskFullScreen
)
&
&
(
win
.
styleMask
&
NSWindowStyleMaskTitled
)
)
{
const
NSRect
buttonsRect
=
win
.
windowButtonsRect
;
if
(
NSIsEmptyRect
(
buttonsRect
)
)
{
return
NSMakePoint
(
buttonsRect
.
origin
.
x
win
.
frame
.
size
.
height
)
;
}
if
(
win
.
windowTitlebarLayoutDirection
=
=
NSUserInterfaceLayoutDirectionRightToLeft
)
{
return
NSMakePoint
(
buttonsRect
.
origin
.
x
+
40
.
0f
buttonsRect
.
origin
.
y
)
;
}
return
buttonsRect
.
origin
;
}
return
self
.
FrameView__closeButtonOrigin
;
}
-
(
CGFloat
)
FrameView__titlebarHeight
{
CGFloat
height
=
[
self
FrameView__titlebarHeight
]
;
if
(
[
self
.
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
auto
*
win
=
static_cast
<
ToolbarWindow
*
>
(
self
.
window
)
;
CGFloat
frameHeight
=
self
.
frame
.
size
.
height
;
CGFloat
windowButtonY
=
frameHeight
;
if
(
!
NSIsEmptyRect
(
win
.
windowButtonsRect
)
&
&
win
.
drawsContentsIntoWindowFrame
&
&
!
(
win
.
styleMask
&
NSWindowStyleMaskFullScreen
)
&
&
(
win
.
styleMask
&
NSWindowStyleMaskTitled
)
)
{
windowButtonY
=
win
.
windowButtonsRect
.
origin
.
y
;
}
height
=
std
:
:
max
(
height
frameHeight
-
windowButtonY
)
;
}
return
height
;
}
end
static
NSMutableSet
*
gSwizzledFrameViewClasses
=
nil
;
interface
NSWindow
(
PrivateSetNeedsDisplayInRectMethod
)
-
(
void
)
_setNeedsDisplayInRect
:
(
NSRect
)
aRect
;
end
interface
BaseWindow
(
Private
)
-
(
void
)
cursorUpdated
:
(
NSEvent
*
)
aEvent
;
-
(
void
)
reflowTitlebarElements
;
end
implementation
BaseWindow
+
(
Class
)
frameViewClassForStyleMask
:
(
NSUInteger
)
styleMask
{
Class
frameViewClass
=
[
super
frameViewClassForStyleMask
:
styleMask
]
;
if
(
!
gSwizzledFrameViewClasses
)
{
gSwizzledFrameViewClasses
=
[
[
NSMutableSet
setWithCapacity
:
3
]
retain
]
;
if
(
!
gSwizzledFrameViewClasses
)
{
return
frameViewClass
;
}
}
MOZ_RUNINIT
static
IMP
our_closeButtonOrigin
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__closeButtonOrigin
)
)
;
MOZ_RUNINIT
static
IMP
our_titlebarHeight
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__titlebarHeight
)
)
;
if
(
!
[
gSwizzledFrameViewClasses
containsObject
:
frameViewClass
]
)
{
IMP
_closeButtonOrigin
=
class_getMethodImplementation
(
frameViewClass
selector
(
_closeButtonOrigin
)
)
;
if
(
_closeButtonOrigin
&
&
_closeButtonOrigin
!
=
our_closeButtonOrigin
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_closeButtonOrigin
)
selector
(
FrameView__closeButtonOrigin
)
)
;
}
IMP
_titlebarHeight
=
class_getMethodImplementation
(
frameViewClass
selector
(
_titlebarHeight
)
)
;
if
(
_titlebarHeight
&
&
_titlebarHeight
!
=
our_titlebarHeight
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_titlebarHeight
)
selector
(
FrameView__titlebarHeight
)
)
;
}
[
gSwizzledFrameViewClasses
addObject
:
frameViewClass
]
;
}
return
frameViewClass
;
}
-
(
id
)
initWithContentRect
:
(
NSRect
)
aContentRect
styleMask
:
(
NSUInteger
)
aStyle
backing
:
(
NSBackingStoreType
)
aBufferingType
defer
:
(
BOOL
)
aFlag
{
mDrawsIntoWindowFrame
=
NO
;
[
super
initWithContentRect
:
aContentRect
styleMask
:
aStyle
backing
:
aBufferingType
defer
:
aFlag
]
;
mState
=
nil
;
mDisabledNeedsDisplay
=
NO
;
mTrackingArea
=
nil
;
mViewWithTrackingArea
=
nil
;
mDirtyRect
=
NSZeroRect
;
mBeingShown
=
NO
;
mDrawTitle
=
NO
;
mTouchBar
=
nil
;
mIsAnimationSuppressed
=
NO
;
return
self
;
}
static
NSImage
*
GetMenuMaskImage
(
)
{
const
CGFloat
radius
=
6
.
0f
;
const
NSSize
maskSize
=
{
radius
*
3
.
0f
radius
*
3
.
0f
}
;
NSImage
*
maskImage
=
[
NSImage
imageWithSize
:
maskSize
flipped
:
FALSE
drawingHandler
:
^
BOOL
(
NSRect
dstRect
)
{
NSBezierPath
*
path
=
[
NSBezierPath
bezierPathWithRoundedRect
:
dstRect
xRadius
:
radius
yRadius
:
radius
]
;
[
NSColor
.
blackColor
set
]
;
[
path
fill
]
;
return
YES
;
}
]
;
maskImage
.
capInsets
=
NSEdgeInsetsMake
(
radius
radius
radius
radius
)
;
return
maskImage
;
}
-
(
void
)
setEffectViewWrapperForStyle
:
(
WindowShadow
)
aStyle
{
NSView
*
wrapper
=
[
&
]
(
)
-
>
NSView
*
{
if
(
aStyle
=
=
WindowShadow
:
:
Menu
|
|
aStyle
=
=
WindowShadow
:
:
Tooltip
)
{
const
bool
isMenu
=
aStyle
=
=
WindowShadow
:
:
Menu
;
auto
*
effectView
=
[
[
NSVisualEffectView
alloc
]
initWithFrame
:
self
.
contentView
.
frame
]
;
effectView
.
material
=
isMenu
?
NSVisualEffectMaterialMenu
:
NSVisualEffectMaterialToolTip
;
effectView
.
state
=
NSVisualEffectStateActive
;
effectView
.
blendingMode
=
NSVisualEffectBlendingModeBehindWindow
;
if
(
isMenu
)
{
effectView
.
maskImage
=
GetMenuMaskImage
(
)
;
}
return
effectView
;
}
return
[
[
NSView
alloc
]
initWithFrame
:
self
.
contentView
.
frame
]
;
}
(
)
;
wrapper
.
wantsLayer
=
YES
;
NSView
*
childView
=
[
self
.
mainChildView
retain
]
;
[
childView
removeFromSuperview
]
;
[
wrapper
addSubview
:
childView
]
;
[
childView
release
]
;
super
.
contentView
=
wrapper
;
[
wrapper
release
]
;
}
-
(
NSTouchBar
*
)
makeTouchBar
{
mTouchBar
=
[
[
nsTouchBar
alloc
]
init
]
;
if
(
mTouchBar
)
{
sTouchBarIsInitialized
=
YES
;
}
return
mTouchBar
;
}
-
(
void
)
setBeingShown
:
(
BOOL
)
aValue
{
mBeingShown
=
aValue
;
}
-
(
BOOL
)
isBeingShown
{
return
mBeingShown
;
}
-
(
BOOL
)
isVisibleOrBeingShown
{
return
[
super
isVisible
]
|
|
mBeingShown
;
}
-
(
void
)
setIsAnimationSuppressed
:
(
BOOL
)
aValue
{
mIsAnimationSuppressed
=
aValue
;
}
-
(
BOOL
)
isAnimationSuppressed
{
return
mIsAnimationSuppressed
;
}
-
(
void
)
disableSetNeedsDisplay
{
mDisabledNeedsDisplay
=
YES
;
}
-
(
void
)
enableSetNeedsDisplay
{
mDisabledNeedsDisplay
=
NO
;
}
-
(
void
)
dealloc
{
[
mTouchBar
release
]
;
ChildViewMouseTracker
:
:
OnDestroyWindow
(
self
)
;
[
super
dealloc
]
;
}
static
const
NSString
*
kStateTitleKey
=
"
title
"
;
static
const
NSString
*
kStateDrawsContentsIntoWindowFrameKey
=
"
drawsContentsIntoWindowFrame
"
;
static
const
NSString
*
kStateShowsToolbarButton
=
"
showsToolbarButton
"
;
static
const
NSString
*
kStateCollectionBehavior
=
"
collectionBehavior
"
;
static
const
NSString
*
kStateWantsTitleDrawn
=
"
wantsTitleDrawn
"
;
-
(
void
)
importState
:
(
NSDictionary
*
)
aState
{
if
(
NSString
*
title
=
[
aState
objectForKey
:
kStateTitleKey
]
)
{
[
self
setTitle
:
title
]
;
}
[
self
setDrawsContentsIntoWindowFrame
:
[
[
aState
objectForKey
:
kStateDrawsContentsIntoWindowFrameKey
]
boolValue
]
]
;
[
self
setShowsToolbarButton
:
[
[
aState
objectForKey
:
kStateShowsToolbarButton
]
boolValue
]
]
;
[
self
setCollectionBehavior
:
[
[
aState
objectForKey
:
kStateCollectionBehavior
]
unsignedIntValue
]
]
;
[
self
setWantsTitleDrawn
:
[
[
aState
objectForKey
:
kStateWantsTitleDrawn
]
boolValue
]
]
;
}
-
(
NSMutableDictionary
*
)
exportState
{
NSMutableDictionary
*
state
=
[
NSMutableDictionary
dictionaryWithCapacity
:
10
]
;
if
(
NSString
*
title
=
self
.
title
)
{
[
state
setObject
:
title
forKey
:
kStateTitleKey
]
;
}
[
state
setObject
:
[
NSNumber
numberWithBool
:
self
.
drawsContentsIntoWindowFrame
]
forKey
:
kStateDrawsContentsIntoWindowFrameKey
]
;
[
state
setObject
:
[
NSNumber
numberWithBool
:
self
.
showsToolbarButton
]
forKey
:
kStateShowsToolbarButton
]
;
[
state
setObject
:
[
NSNumber
numberWithUnsignedInt
:
self
.
collectionBehavior
]
forKey
:
kStateCollectionBehavior
]
;
[
state
setObject
:
[
NSNumber
numberWithBool
:
self
.
wantsTitleDrawn
]
forKey
:
kStateWantsTitleDrawn
]
;
return
state
;
}
-
(
void
)
setDrawsContentsIntoWindowFrame
:
(
BOOL
)
aState
{
bool
changed
=
aState
!
=
mDrawsIntoWindowFrame
;
mDrawsIntoWindowFrame
=
aState
;
if
(
changed
)
{
[
self
reflowTitlebarElements
]
;
}
}
-
(
BOOL
)
drawsContentsIntoWindowFrame
{
return
mDrawsIntoWindowFrame
;
}
-
(
NSRect
)
childViewRectForFrameRect
:
(
NSRect
)
aFrameRect
{
if
(
mDrawsIntoWindowFrame
)
{
return
aFrameRect
;
}
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSWindowStyleMaskFullSizeContentView
;
return
[
NSWindow
contentRectForFrameRect
:
aFrameRect
styleMask
:
styleMask
]
;
}
-
(
NSRect
)
childViewFrameRectForCurrentBounds
{
auto
frame
=
self
.
frame
;
NSRect
r
=
[
self
childViewRectForFrameRect
:
frame
]
;
r
.
origin
.
x
-
=
frame
.
origin
.
x
;
r
.
origin
.
y
-
=
frame
.
origin
.
y
;
return
r
;
}
-
(
void
)
updateChildViewFrameRect
{
self
.
mainChildView
.
frame
=
self
.
childViewFrameRectForCurrentBounds
;
}
-
(
NSRect
)
frameRectForChildViewRect
:
(
NSRect
)
aChildViewRect
{
if
(
mDrawsIntoWindowFrame
)
{
return
aChildViewRect
;
}
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSWindowStyleMaskFullSizeContentView
;
return
[
NSWindow
frameRectForContentRect
:
aChildViewRect
styleMask
:
styleMask
]
;
}
-
(
NSTimeInterval
)
animationResizeTime
:
(
NSRect
)
newFrame
{
if
(
mIsAnimationSuppressed
)
{
return
0
.
0
;
}
return
[
super
animationResizeTime
:
newFrame
]
;
}
-
(
void
)
setWantsTitleDrawn
:
(
BOOL
)
aDrawTitle
{
mDrawTitle
=
aDrawTitle
;
[
self
setTitleVisibility
:
mDrawTitle
?
NSWindowTitleVisible
:
NSWindowTitleHidden
]
;
}
-
(
BOOL
)
wantsTitleDrawn
{
return
mDrawTitle
;
}
-
(
NSView
*
)
trackingAreaView
{
NSView
*
contentView
=
self
.
contentView
;
return
contentView
.
superview
?
contentView
.
superview
:
contentView
;
}
-
(
NSArray
<
NSView
*
>
*
)
contentViewContents
{
return
[
[
self
.
contentView
.
subviews
copy
]
autorelease
]
;
}
-
(
ChildView
*
)
mainChildView
{
NSView
*
contentView
=
self
.
contentView
;
NSView
*
lastView
=
contentView
.
subviews
.
lastObject
;
if
(
[
lastView
isKindOfClass
:
[
ChildView
class
]
]
)
{
return
(
ChildView
*
)
lastView
;
}
return
nil
;
}
-
(
void
)
removeTrackingArea
{
[
mViewWithTrackingArea
removeTrackingArea
:
mTrackingArea
]
;
[
mTrackingArea
release
]
;
mTrackingArea
=
nil
;
[
mViewWithTrackingArea
release
]
;
mViewWithTrackingArea
=
nil
;
}
-
(
void
)
createTrackingArea
{
mViewWithTrackingArea
=
[
self
.
trackingAreaView
retain
]
;
const
NSTrackingAreaOptions
options
=
NSTrackingMouseEnteredAndExited
|
NSTrackingMouseMoved
|
NSTrackingActiveAlways
|
NSTrackingInVisibleRect
;
mTrackingArea
=
[
[
NSTrackingArea
alloc
]
initWithRect
:
[
mViewWithTrackingArea
bounds
]
options
:
options
owner
:
self
userInfo
:
nil
]
;
[
mViewWithTrackingArea
addTrackingArea
:
mTrackingArea
]
;
}
-
(
void
)
mouseEntered
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseEnteredWindow
(
aEvent
)
;
}
-
(
void
)
mouseExited
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseExitedWindow
(
aEvent
)
;
}
-
(
void
)
mouseMoved
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseMoved
(
aEvent
)
;
}
-
(
void
)
cursorUpdated
:
(
NSEvent
*
)
aEvent
{
}
-
(
void
)
_setNeedsDisplayInRect
:
(
NSRect
)
aRect
{
if
(
!
mDisabledNeedsDisplay
)
{
[
super
_setNeedsDisplayInRect
:
aRect
]
;
mDirtyRect
=
NSUnionRect
(
mDirtyRect
aRect
)
;
}
}
-
(
NSRect
)
getAndResetNativeDirtyRect
{
NSRect
dirtyRect
=
mDirtyRect
;
mDirtyRect
=
NSZeroRect
;
return
dirtyRect
;
}
-
(
void
)
reflowTitlebarElements
{
NSView
*
frameView
=
self
.
contentView
.
superview
;
if
(
[
frameView
respondsToSelector
:
selector
(
_tileTitlebarAndRedisplay
:
)
]
)
{
[
frameView
_tileTitlebarAndRedisplay
:
NO
]
;
}
}
-
(
BOOL
)
respondsToSelector
:
(
SEL
)
aSelector
{
if
(
aSelector
=
=
selector
(
cancelOperation
:
)
)
{
return
NO
;
}
return
[
super
respondsToSelector
:
aSelector
]
;
}
-
(
void
)
doCommandBySelector
:
(
SEL
)
aSelector
{
[
self
tryToPerform
:
aSelector
with
:
nil
]
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
id
retval
=
[
super
accessibilityAttributeValue
:
attribute
]
;
if
(
[
retval
isKindOfClass
:
[
NSArray
class
]
]
&
&
[
attribute
isEqualToString
:
"
AXChildren
"
]
)
{
NSMutableArray
*
holder
=
[
NSMutableArray
arrayWithCapacity
:
10
]
;
[
holder
addObjectsFromArray
:
(
NSArray
*
)
retval
]
;
NSUInteger
count
=
[
holder
count
]
;
for
(
NSInteger
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
id
item
=
[
holder
objectAtIndex
:
i
]
;
if
(
!
[
item
isKindOfClass
:
[
NSButtonCell
class
]
]
&
&
!
[
item
respondsToSelector
:
selector
(
hasRepresentedView
)
]
)
{
[
holder
removeObjectAtIndex
:
i
]
;
}
}
retval
=
[
NSArray
arrayWithArray
:
holder
]
;
}
return
retval
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
releaseJSObjects
{
[
mTouchBar
releaseJSObjects
]
;
}
end
interface
MOZTitlebarAccessoryView
:
NSView
end
implementation
MOZTitlebarAccessoryView
:
NSView
-
(
void
)
viewWillMoveToWindow
:
(
NSWindow
*
)
aWindow
{
if
(
aWindow
)
{
if
(
available
(
macOS
11
.
0
*
)
)
{
aWindow
.
titlebarSeparatorStyle
=
[
aWindow
isKindOfClass
:
[
ToolbarWindow
class
]
]
?
NSTitlebarSeparatorStyleAutomatic
:
NSTitlebarSeparatorStyleNone
;
}
}
}
end
implementation
FullscreenTitlebarTracker
-
(
FullscreenTitlebarTracker
*
)
init
{
[
super
init
]
;
self
.
hidden
=
YES
;
return
self
;
}
-
(
void
)
loadView
{
self
.
view
=
[
[
[
MOZTitlebarAccessoryView
alloc
]
initWithFrame
:
NSZeroRect
]
autorelease
]
;
}
end
static
bool
MaybeDropEventForModalWindow
(
NSEvent
*
aEvent
id
aDelegate
)
{
if
(
!
sModalWindowCount
)
{
return
false
;
}
NSEventType
type
=
[
aEvent
type
]
;
switch
(
type
)
{
case
NSEventTypeScrollWheel
:
case
NSEventTypeLeftMouseDown
:
case
NSEventTypeLeftMouseUp
:
case
NSEventTypeRightMouseDown
:
case
NSEventTypeRightMouseUp
:
case
NSEventTypeOtherMouseDown
:
case
NSEventTypeOtherMouseUp
:
case
NSEventTypeMouseMoved
:
case
NSEventTypeLeftMouseDragged
:
case
NSEventTypeRightMouseDragged
:
case
NSEventTypeOtherMouseDragged
:
break
;
default
:
return
false
;
}
if
(
aDelegate
&
&
[
aDelegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
if
(
nsCocoaWindow
*
widget
=
[
(
WindowDelegate
*
)
aDelegate
geckoWidget
]
)
{
if
(
!
widget
-
>
IsModal
(
)
|
|
widget
-
>
HasModalDescendants
(
)
)
{
return
true
;
}
}
}
return
false
;
}
implementation
ToolbarWindow
-
(
id
)
initWithContentRect
:
(
NSRect
)
aChildViewRect
styleMask
:
(
NSUInteger
)
aStyle
backing
:
(
NSBackingStoreType
)
aBufferingType
defer
:
(
BOOL
)
aFlag
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSRect
frameRect
=
[
NSWindow
frameRectForContentRect
:
aChildViewRect
styleMask
:
aStyle
]
;
aStyle
|
=
NSWindowStyleMaskFullSizeContentView
;
NSRect
contentRect
=
frameRect
;
if
(
(
self
=
[
super
initWithContentRect
:
contentRect
styleMask
:
aStyle
backing
:
aBufferingType
defer
:
aFlag
]
)
)
{
mWindowButtonsRect
=
NSZeroRect
;
mFullscreenTitlebarTracker
=
[
[
FullscreenTitlebarTracker
alloc
]
init
]
;
[
mFullscreenTitlebarTracker
addObserver
:
self
forKeyPath
:
"
revealAmount
"
options
:
NSKeyValueObservingOptionNew
context
:
nil
]
;
[
(
NSWindow
*
)
self
addTitlebarAccessoryViewController
:
mFullscreenTitlebarTracker
]
;
}
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
observeValueForKeyPath
:
(
NSString
*
)
keyPath
ofObject
:
(
id
)
object
change
:
(
NSDictionary
<
NSKeyValueChangeKey
id
>
*
)
change
context
:
(
void
*
)
context
{
if
(
[
keyPath
isEqualToString
:
"
revealAmount
"
]
)
{
[
[
self
mainChildView
]
ensureNextCompositeIsAtomicWithMainThreadPaint
]
;
NSNumber
*
revealAmount
=
(
change
[
NSKeyValueChangeNewKey
]
)
;
[
self
updateTitlebarShownAmount
:
[
revealAmount
doubleValue
]
]
;
}
else
{
[
super
observeValueForKeyPath
:
keyPath
ofObject
:
object
change
:
change
context
:
context
]
;
}
}
static
bool
ScreenHasNotch
(
nsCocoaWindow
*
aGeckoWindow
)
{
if
(
available
(
macOS
12
.
0
*
)
)
{
nsCOMPtr
<
nsIScreen
>
widgetScreen
=
aGeckoWindow
-
>
GetWidgetScreen
(
)
;
NSScreen
*
cocoaScreen
=
ScreenHelperCocoa
:
:
CocoaScreenForScreen
(
widgetScreen
)
;
return
cocoaScreen
.
safeAreaInsets
.
top
!
=
0
.
0f
;
}
return
false
;
}
static
bool
ShouldShiftByMenubarHeightInFullscreen
(
nsCocoaWindow
*
aWindow
)
{
switch
(
StaticPrefs
:
:
widget_macos_shift_by_menubar_on_fullscreen
(
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
break
;
}
return
!
ScreenHasNotch
(
aWindow
)
&
&
!
[
NSUserDefaults
.
standardUserDefaults
integerForKey
:
"
AppleMenuBarVisibleInFullscreen
"
]
;
}
-
(
void
)
updateTitlebarShownAmount
:
(
CGFloat
)
aShownAmount
{
if
(
!
(
self
.
styleMask
&
NSWindowStyleMaskFullScreen
)
)
{
return
;
}
CGFloat
menuBarHeight
=
NSApp
.
mainMenu
.
menuBarHeight
;
if
(
menuBarHeight
>
0
.
0f
)
{
mMenuBarHeight
=
menuBarHeight
;
}
if
(
[
[
self
delegate
]
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
WindowDelegate
*
windowDelegate
=
(
WindowDelegate
*
)
[
self
delegate
]
;
nsCocoaWindow
*
geckoWindow
=
[
windowDelegate
geckoWidget
]
;
if
(
!
geckoWindow
)
{
return
;
}
if
(
nsIWidgetListener
*
listener
=
geckoWindow
-
>
GetWidgetListener
(
)
)
{
CGFloat
shiftByPixels
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
MacTitlebarHeight
)
*
aShownAmount
;
if
(
ShouldShiftByMenubarHeightInFullscreen
(
geckoWindow
)
)
{
shiftByPixels
+
=
mMenuBarHeight
*
aShownAmount
;
}
listener
-
>
MacFullscreenMenubarOverlapChanged
(
DesktopCoord
(
shiftByPixels
)
)
;
}
}
}
-
(
void
)
dealloc
{
[
mFullscreenTitlebarTracker
removeObserver
:
self
forKeyPath
:
"
revealAmount
"
]
;
[
mFullscreenTitlebarTracker
removeFromParentViewController
]
;
[
mFullscreenTitlebarTracker
release
]
;
[
super
dealloc
]
;
}
-
(
NSArray
<
NSView
*
>
*
)
contentViewContents
{
return
[
[
self
.
contentView
.
subviews
copy
]
autorelease
]
;
}
-
(
void
)
windowMainStateChanged
{
[
[
self
mainChildView
]
ensureNextCompositeIsAtomicWithMainThreadPaint
]
;
}
-
(
void
)
setDrawsContentsIntoWindowFrame
:
(
BOOL
)
aState
{
BOOL
stateChanged
=
self
.
drawsContentsIntoWindowFrame
!
=
aState
;
[
super
setDrawsContentsIntoWindowFrame
:
aState
]
;
if
(
stateChanged
&
&
[
self
.
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
self
.
titlebarAppearsTransparent
=
self
.
drawsContentsIntoWindowFrame
;
[
self
updateChildViewFrameRect
]
;
auto
*
windowDelegate
=
static_cast
<
WindowDelegate
*
>
(
self
.
delegate
)
;
if
(
nsCocoaWindow
*
geckoWindow
=
windowDelegate
.
geckoWidget
)
{
geckoWindow
-
>
ReportSizeEvent
(
)
;
}
ChildViewMouseTracker
:
:
ResendLastMouseMoveEvent
(
)
;
}
}
-
(
void
)
placeWindowButtons
:
(
NSRect
)
aRect
{
if
(
!
NSEqualRects
(
mWindowButtonsRect
aRect
)
)
{
mWindowButtonsRect
=
aRect
;
[
self
reflowTitlebarElements
]
;
}
}
-
(
NSRect
)
windowButtonsRect
{
return
mWindowButtonsRect
;
}
-
(
BOOL
)
_hasToolbar
{
return
YES
;
}
-
(
void
)
_toolbarPillButtonClicked
:
(
id
)
sender
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
)
;
if
(
[
self
.
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
auto
*
windowDelegate
=
static_cast
<
WindowDelegate
*
>
(
self
.
delegate
)
;
nsCocoaWindow
*
geckoWindow
=
windowDelegate
.
geckoWidget
;
if
(
!
geckoWindow
)
{
return
;
}
if
(
nsIWidgetListener
*
listener
=
geckoWindow
-
>
GetWidgetListener
(
)
)
{
listener
-
>
OSToolbarButtonPressed
(
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSWindow
*
nativeWindow
=
[
self
retain
]
;
BOOL
retval
=
[
super
performKeyEquivalent
:
theEvent
]
;
[
nativeWindow
release
]
;
return
retval
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
if
(
MaybeDropEventForModalWindow
(
anEvent
self
.
delegate
)
)
{
return
;
}
[
super
sendEvent
:
anEvent
]
;
}
end
implementation
PopupWindow
-
(
id
)
initWithContentRect
:
(
NSRect
)
contentRect
styleMask
:
(
NSUInteger
)
styleMask
backing
:
(
NSBackingStoreType
)
bufferingType
defer
:
(
BOOL
)
deferCreation
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
mIsContextMenu
=
false
;
return
[
super
initWithContentRect
:
contentRect
styleMask
:
styleMask
backing
:
bufferingType
defer
:
deferCreation
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
CGFloat
)
_backdropBleedAmount
{
return
0
.
0
;
}
static
const
NSUInteger
kWindowShadowOptionsNoShadow
=
0
;
static
const
NSUInteger
kWindowShadowOptionsMenu
=
2
;
static
const
NSUInteger
kWindowShadowOptionsTooltip
=
4
;
-
(
NSDictionary
*
)
shadowParameters
{
NSDictionary
*
parent
=
[
super
shadowParameters
]
;
if
(
self
.
shadowStyle
!
=
WindowShadow
:
:
Panel
)
{
return
parent
;
}
NSMutableDictionary
*
copy
=
[
parent
mutableCopy
]
;
for
(
auto
*
key
:
{
"
com
.
apple
.
WindowShadowRimDensityActive
"
"
com
.
apple
.
WindowShadowRimDensityInactive
"
}
)
{
if
(
[
parent
objectForKey
:
key
]
!
=
nil
)
{
[
copy
setValue
:
(
0
)
forKey
:
key
]
;
}
}
return
copy
;
}
-
(
NSUInteger
)
shadowOptions
{
if
(
!
self
.
hasShadow
)
{
return
kWindowShadowOptionsNoShadow
;
}
switch
(
self
.
shadowStyle
)
{
case
WindowShadow
:
:
None
:
return
kWindowShadowOptionsNoShadow
;
case
WindowShadow
:
:
Menu
:
case
WindowShadow
:
:
Panel
:
return
kWindowShadowOptionsMenu
;
case
WindowShadow
:
:
Tooltip
:
return
kWindowShadowOptionsTooltip
;
}
}
-
(
BOOL
)
isContextMenu
{
return
mIsContextMenu
;
}
-
(
void
)
setIsContextMenu
:
(
BOOL
)
flag
{
mIsContextMenu
=
flag
;
}
-
(
BOOL
)
canBecomeMainWindow
{
return
NO
;
}
end
implementation
BorderlessWindow
-
(
BOOL
)
canBecomeKeyWindow
{
return
YES
;
}
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
if
(
MaybeDropEventForModalWindow
(
anEvent
self
.
delegate
)
)
{
return
;
}
[
super
sendEvent
:
anEvent
]
;
}
-
(
BOOL
)
canBecomeMainWindow
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
self
.
isVisible
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSWindow
*
nativeWindow
=
[
self
retain
]
;
BOOL
retval
=
[
super
performKeyEquivalent
:
theEvent
]
;
[
nativeWindow
release
]
;
return
retval
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
end
