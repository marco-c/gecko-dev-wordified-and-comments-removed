#
include
"
nsCocoaWindow
.
h
"
#
include
"
NativeKeyBindings
.
h
"
#
include
"
ScreenHelperCocoa
.
h
"
#
include
"
TextInputHandler
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsWindowMap
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsNativeThemeColors
.
h
"
#
include
"
nsNativeThemeCocoa
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
VibrancyManager
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
qcms
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
widget
/
Screen
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
layers
{
class
LayerManager
;
}
}
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
;
BOOL
sTouchBarIsInitialized
=
NO
;
extern
NSMenu
*
sApplicationMenu
;
extern
BOOL
gSomeMenuBarPainted
;
static
uint32_t
sModalWindowCount
=
0
;
extern
"
C
"
{
typedef
NSInteger
CGSConnection
;
typedef
NSUInteger
CGSSpaceID
;
typedef
NSInteger
CGSWindow
;
typedef
enum
{
kCGSSpaceIncludesCurrent
=
1
<
<
0
kCGSSpaceIncludesOthers
=
1
<
<
1
kCGSSpaceIncludesUser
=
1
<
<
2
kCGSAllSpacesMask
=
kCGSSpaceIncludesCurrent
|
kCGSSpaceIncludesOthers
|
kCGSSpaceIncludesUser
}
CGSSpaceMask
;
static
NSString
*
const
CGSSpaceIDKey
=
"
ManagedSpaceID
"
;
static
NSString
*
const
CGSSpacesKey
=
"
Spaces
"
;
extern
CGSConnection
_CGSDefaultConnection
(
void
)
;
extern
CGError
CGSSetWindowTransform
(
CGSConnection
cid
CGSWindow
wid
CGAffineTransform
transform
)
;
}
#
define
NS_APPSHELLSERVICE_CONTRACTID
"
mozilla
.
org
/
appshell
/
appShellService
;
1
"
static
void
RollUpPopups
(
nsIRollupListener
:
:
AllowAnimations
aAllowAnimations
=
nsIRollupListener
:
:
AllowAnimations
:
:
Yes
)
{
if
(
RefPtr
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
RollupTooltips
(
)
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
if
(
!
rollupListener
)
{
return
;
}
if
(
rollupListener
-
>
RollupNativeMenu
(
)
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
!
rollupWidget
)
{
return
;
}
nsIRollupListener
:
:
RollupOptions
options
{
0
nsIRollupListener
:
:
FlushViews
:
:
Yes
nullptr
aAllowAnimations
}
;
rollupListener
-
>
Rollup
(
options
)
;
}
nsCocoaWindow
:
:
nsCocoaWindow
(
)
:
mParent
(
nullptr
)
mAncestorLink
(
nullptr
)
mWindow
(
nil
)
mDelegate
(
nil
)
mPopupContentView
(
nil
)
mFullscreenTransitionAnimation
(
nil
)
mShadowStyle
(
WindowShadow
:
:
None
)
mBackingScaleFactor
(
0
.
0
)
mAnimationType
(
nsIWidget
:
:
eGenericWindowAnimation
)
mWindowMadeHere
(
false
)
mSizeMode
(
nsSizeMode_Normal
)
mInFullScreenMode
(
false
)
mInNativeFullScreenMode
(
false
)
mIgnoreOcclusionCount
(
0
)
mHasStartedNativeFullscreen
(
false
)
mWindowAnimationBehavior
(
NSWindowAnimationBehaviorDefault
)
{
NSWindow
.
allowsAutomaticWindowTabbing
=
NO
;
}
void
nsCocoaWindow
:
:
DestroyNativeWindow
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
MOZ_ASSERT
(
mWindowMadeHere
"
We
shouldn
'
t
be
trying
to
destroy
a
window
we
didn
'
t
create
.
"
)
;
EndOurNativeTransition
(
)
;
Show
(
false
)
;
[
mWindow
releaseJSObjects
]
;
mWindow
.
delegate
=
nil
;
[
mWindow
close
]
;
mWindow
=
nil
;
[
mDelegate
autorelease
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsCocoaWindow
:
:
~
nsCocoaWindow
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
for
(
nsIWidget
*
kid
=
mLastChild
;
kid
;
)
{
WindowType
kidType
=
kid
-
>
GetWindowType
(
)
;
if
(
kidType
=
=
WindowType
:
:
Child
)
{
nsChildView
*
childView
=
static_cast
<
nsChildView
*
>
(
kid
)
;
kid
=
kid
-
>
GetPrevSibling
(
)
;
childView
-
>
ResetParent
(
)
;
}
else
{
nsCocoaWindow
*
childWindow
=
static_cast
<
nsCocoaWindow
*
>
(
kid
)
;
childWindow
-
>
mParent
=
nullptr
;
childWindow
-
>
mAncestorLink
=
mAncestorLink
;
kid
=
kid
-
>
GetPrevSibling
(
)
;
}
}
if
(
mWindow
&
&
mWindowMadeHere
)
{
CancelAllTransitions
(
)
;
DestroyNativeWindow
(
)
;
}
NS_IF_RELEASE
(
mPopupContentView
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
NSScreen
*
FindTargetScreenForRect
(
const
DesktopIntRect
&
aRect
)
{
NSScreen
*
targetScreen
=
[
NSScreen
mainScreen
]
;
NSEnumerator
*
screenEnum
=
[
[
NSScreen
screens
]
objectEnumerator
]
;
int
largestIntersectArea
=
0
;
while
(
NSScreen
*
screen
=
[
screenEnum
nextObject
]
)
{
DesktopIntRect
screenRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
[
screen
visibleFrame
]
)
;
screenRect
=
screenRect
.
Intersect
(
aRect
)
;
int
area
=
screenRect
.
width
*
screenRect
.
height
;
if
(
area
>
largestIntersectArea
)
{
largestIntersectArea
=
area
;
targetScreen
=
screen
;
}
}
return
targetScreen
;
}
DesktopToLayoutDeviceScale
ParentBackingScaleFactor
(
nsIWidget
*
aParent
NSView
*
aParentView
)
{
if
(
aParent
)
{
return
aParent
-
>
GetDesktopToDeviceScale
(
)
;
}
NSWindow
*
parentWindow
=
[
aParentView
window
]
;
if
(
parentWindow
)
{
return
DesktopToLayoutDeviceScale
(
parentWindow
.
backingScaleFactor
)
;
}
return
DesktopToLayoutDeviceScale
(
1
.
0
)
;
}
static
DesktopRect
GetWidgetScreenRectForChildren
(
nsIWidget
*
aWidget
NSView
*
aView
)
{
if
(
aWidget
)
{
mozilla
:
:
DesktopToLayoutDeviceScale
scale
=
aWidget
-
>
GetDesktopToDeviceScale
(
)
;
if
(
aWidget
-
>
GetWindowType
(
)
=
=
WindowType
:
:
Child
)
{
return
aWidget
-
>
GetScreenBounds
(
)
/
scale
;
}
return
aWidget
-
>
GetClientBounds
(
)
/
scale
;
}
MOZ_RELEASE_ASSERT
(
aView
)
;
NSRect
rectInWindowCoordinatesOBL
=
[
aView
convertRect
:
[
aView
bounds
]
toView
:
nil
]
;
NSRect
rectInScreenCoordinatesOBL
=
[
[
aView
window
]
convertRectToScreen
:
rectInWindowCoordinatesOBL
]
;
return
DesktopRect
(
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
rectInScreenCoordinatesOBL
)
)
;
}
nsresult
nsCocoaWindow
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
DesktopIntRect
&
aRect
widget
:
:
InitData
*
aInitData
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsAutoreleasePool
localPool
;
mWindowType
=
WindowType
:
:
TopLevel
;
mBorderStyle
=
BorderStyle
:
:
Default
;
nsToolkit
:
:
GetToolkit
(
)
;
Inherited
:
:
BaseCreate
(
aParent
aInitData
)
;
mParent
=
aParent
;
mAncestorLink
=
aParent
;
mAlwaysOnTop
=
aInitData
-
>
mAlwaysOnTop
;
mIsAlert
=
aInitData
-
>
mIsAlert
;
DesktopIntPoint
parentOrigin
;
if
(
aParent
|
|
aNativeParent
)
{
DesktopRect
parentDesktopRect
=
GetWidgetScreenRectForChildren
(
aParent
(
NSView
*
)
aNativeParent
)
;
parentOrigin
=
gfx
:
:
RoundedToInt
(
parentDesktopRect
.
TopLeft
(
)
)
;
}
DesktopIntRect
widgetRect
=
aRect
+
parentOrigin
;
nsresult
rv
=
CreateNativeWindow
(
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
widgetRect
)
mBorderStyle
false
aInitData
-
>
mIsPrivate
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
LayoutDeviceIntRect
devRect
=
RoundedToInt
(
aRect
*
GetDesktopToDeviceScale
(
)
)
;
return
CreatePopupContentView
(
devRect
aInitData
)
;
}
mIsAnimationSuppressed
=
aInitData
-
>
mIsAnimationSuppressed
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
widget
:
:
InitData
*
aInitData
)
{
DesktopIntRect
desktopRect
=
RoundedToInt
(
aRect
/
ParentBackingScaleFactor
(
aParent
(
NSView
*
)
aNativeParent
)
)
;
return
Create
(
aParent
aNativeParent
desktopRect
aInitData
)
;
}
static
unsigned
int
WindowMaskForBorderStyle
(
BorderStyle
aBorderStyle
)
{
bool
allOrDefault
=
(
aBorderStyle
=
=
BorderStyle
:
:
All
|
|
aBorderStyle
=
=
BorderStyle
:
:
Default
)
;
if
(
!
allOrDefault
&
&
!
(
aBorderStyle
&
BorderStyle
:
:
Title
)
)
{
if
(
aBorderStyle
&
BorderStyle
:
:
Minimize
)
{
return
NSWindowStyleMaskBorderless
|
NSWindowStyleMaskMiniaturizable
;
}
return
NSWindowStyleMaskBorderless
;
}
unsigned
int
mask
=
NSWindowStyleMaskTitled
;
if
(
allOrDefault
|
|
aBorderStyle
&
BorderStyle
:
:
Close
)
{
mask
|
=
NSWindowStyleMaskClosable
;
}
if
(
allOrDefault
|
|
aBorderStyle
&
BorderStyle
:
:
Minimize
)
{
mask
|
=
NSWindowStyleMaskMiniaturizable
;
}
if
(
allOrDefault
|
|
aBorderStyle
&
BorderStyle
:
:
ResizeH
)
{
mask
|
=
NSWindowStyleMaskResizable
;
}
return
mask
;
}
nsresult
nsCocoaWindow
:
:
CreateNativeWindow
(
const
NSRect
&
aRect
BorderStyle
aBorderStyle
bool
aRectIsFrameRect
bool
aIsPrivateBrowsing
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
unsigned
int
features
=
NSWindowStyleMaskBorderless
;
switch
(
mWindowType
)
{
case
WindowType
:
:
Invisible
:
case
WindowType
:
:
Child
:
break
;
case
WindowType
:
:
Popup
:
if
(
aBorderStyle
!
=
BorderStyle
:
:
Default
&
&
mBorderStyle
&
BorderStyle
:
:
Title
)
{
features
|
=
NSWindowStyleMaskTitled
;
if
(
aBorderStyle
&
BorderStyle
:
:
Close
)
{
features
|
=
NSWindowStyleMaskClosable
;
}
}
break
;
case
WindowType
:
:
TopLevel
:
case
WindowType
:
:
Dialog
:
features
=
WindowMaskForBorderStyle
(
aBorderStyle
)
;
break
;
default
:
NS_ERROR
(
"
Unhandled
window
type
!
"
)
;
return
NS_ERROR_FAILURE
;
}
NSRect
contentRect
;
if
(
aRectIsFrameRect
)
{
contentRect
=
[
NSWindow
contentRectForFrameRect
:
aRect
styleMask
:
features
]
;
}
else
{
NSRect
newWindowFrame
=
[
NSWindow
frameRectForContentRect
:
aRect
styleMask
:
features
]
;
contentRect
=
aRect
;
contentRect
.
origin
.
y
-
=
(
newWindowFrame
.
size
.
height
-
aRect
.
size
.
height
)
;
if
(
mWindowType
!
=
WindowType
:
:
Popup
)
{
contentRect
.
origin
.
y
-
=
NSApp
.
mainMenu
.
menuBarHeight
;
}
}
Class
windowClass
=
[
BaseWindow
class
]
;
if
(
(
mWindowType
=
=
WindowType
:
:
TopLevel
|
|
mWindowType
=
=
WindowType
:
:
Dialog
)
&
&
(
features
&
NSWindowStyleMaskTitled
)
)
{
windowClass
=
[
ToolbarWindow
class
]
;
}
else
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
windowClass
=
[
PopupWindow
class
]
;
}
else
if
(
features
=
=
NSWindowStyleMaskBorderless
)
{
windowClass
=
[
BorderlessWindow
class
]
;
}
mWindow
=
[
[
windowClass
alloc
]
initWithContentRect
:
contentRect
styleMask
:
features
backing
:
NSBackingStoreBuffered
defer
:
YES
]
;
mWindow
.
restorable
=
!
aIsPrivateBrowsing
;
if
(
aIsPrivateBrowsing
)
{
[
mWindow
disableSnapshotRestoration
]
;
}
mDelegate
=
[
[
WindowDelegate
alloc
]
initWithGeckoWindow
:
this
]
;
mWindow
.
delegate
=
mDelegate
;
NSRect
wantedFrame
=
[
mWindow
frameRectForChildViewRect
:
contentRect
]
;
if
(
!
NSEqualRects
(
mWindow
.
frame
wantedFrame
)
)
{
[
mWindow
setFrame
:
wantedFrame
display
:
NO
]
;
}
UpdateBounds
(
)
;
if
(
mWindowType
=
=
WindowType
:
:
Invisible
)
{
mWindow
.
level
=
kCGDesktopWindowLevelKey
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
SetPopupWindowLevel
(
)
;
mWindow
.
backgroundColor
=
NSColor
.
clearColor
;
mWindow
.
opaque
=
NO
;
mWindow
.
collectionBehavior
=
mWindow
.
collectionBehavior
|
NSWindowCollectionBehaviorMoveToActiveSpace
;
}
else
{
mWindow
.
opaque
=
YES
;
}
if
(
mAlwaysOnTop
|
|
mIsAlert
)
{
mWindow
.
level
=
NSFloatingWindowLevel
;
mWindow
.
collectionBehavior
=
mWindow
.
collectionBehavior
|
NSWindowCollectionBehaviorCanJoinAllSpaces
;
}
mWindow
.
contentMinSize
=
NSMakeSize
(
60
60
)
;
[
mWindow
disableCursorRects
]
;
mWindow
.
contentView
.
wantsLayer
=
YES
;
mWindow
.
movableByWindowBackground
=
NO
;
[
WindowDataMap
.
sharedWindowDataMap
ensureDataForWindow
:
mWindow
]
;
mWindowMadeHere
=
true
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaWindow
:
:
CreatePopupContentView
(
const
LayoutDeviceIntRect
&
aRect
widget
:
:
InitData
*
aInitData
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
mPopupContentView
=
new
nsChildView
(
)
;
if
(
!
mPopupContentView
)
return
NS_ERROR_FAILURE
;
NS_ADDREF
(
mPopupContentView
)
;
nsIWidget
*
thisAsWidget
=
static_cast
<
nsIWidget
*
>
(
this
)
;
nsresult
rv
=
mPopupContentView
-
>
Create
(
thisAsWidget
nullptr
aRect
aInitData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NSView
*
contentView
=
mWindow
.
contentView
;
auto
*
childView
=
static_cast
<
ChildView
*
>
(
mPopupContentView
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
childView
.
frame
=
contentView
.
bounds
;
childView
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewHeightSizable
;
[
contentView
addSubview
:
childView
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsCocoaWindow
:
:
Destroy
(
)
{
if
(
mOnDestroyCalled
)
{
return
;
}
mOnDestroyCalled
=
true
;
if
(
mModal
)
{
SetModal
(
false
)
;
}
Show
(
false
)
;
if
(
mPopupContentView
)
mPopupContentView
-
>
Destroy
(
)
;
if
(
mFullscreenTransitionAnimation
)
{
[
mFullscreenTransitionAnimation
stopAnimation
]
;
ReleaseFullscreenTransitionAnimation
(
)
;
}
nsBaseWidget
:
:
Destroy
(
)
;
if
(
mParent
)
{
mParent
-
>
RemoveChild
(
this
)
;
}
nsBaseWidget
:
:
OnDestroy
(
)
;
if
(
mInFullScreenMode
&
&
!
mInNativeFullScreenMode
)
{
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
false
)
;
}
if
(
mWindow
&
&
mWindowMadeHere
)
{
CancelAllTransitions
(
)
;
DestroyNativeWindow
(
)
;
}
}
void
*
nsCocoaWindow
:
:
GetNativeData
(
uint32_t
aDataType
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
void
*
retVal
=
nullptr
;
switch
(
aDataType
)
{
case
NS_NATIVE_WIDGET
:
retVal
=
mWindow
.
contentView
;
break
;
case
NS_NATIVE_WINDOW
:
retVal
=
mWindow
;
break
;
case
NS_NATIVE_GRAPHIC
:
NS_ERROR
(
"
Requesting
NS_NATIVE_GRAPHIC
on
a
top
-
level
window
!
"
)
;
break
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
{
retVal
=
GetPseudoIMEContext
(
)
;
if
(
retVal
)
{
break
;
}
NSView
*
view
=
mWindow
?
mWindow
.
contentView
:
nil
;
if
(
view
)
{
retVal
=
view
.
inputContext
;
}
if
(
NS_WARN_IF
(
!
retVal
)
)
{
retVal
=
this
;
}
break
;
}
}
return
retVal
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nullptr
)
;
}
bool
nsCocoaWindow
:
:
IsVisible
(
)
const
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
mWindow
&
&
mWindow
.
isVisibleOrBeingShown
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
void
nsCocoaWindow
:
:
SetModal
(
bool
aModal
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mModal
=
=
aModal
)
{
return
;
}
nsAutoreleasePool
localPool
;
mModal
=
aModal
;
if
(
aModal
)
{
sModalWindowCount
+
+
;
}
else
{
MOZ_ASSERT
(
sModalWindowCount
)
;
sModalWindowCount
-
-
;
}
for
(
auto
*
ancestor
=
static_cast
<
nsCocoaWindow
*
>
(
mAncestorLink
)
;
ancestor
;
ancestor
=
static_cast
<
nsCocoaWindow
*
>
(
ancestor
-
>
mParent
)
)
{
const
bool
changed
=
aModal
?
ancestor
-
>
mNumModalDescendants
+
+
=
=
0
:
-
-
ancestor
-
>
mNumModalDescendants
=
=
0
;
NS_ASSERTION
(
ancestor
-
>
mNumModalDescendants
>
=
0
"
Widget
hierarchy
changed
while
modal
!
"
)
;
if
(
!
changed
|
|
ancestor
-
>
mWindowType
=
=
WindowType
:
:
Invisible
)
{
continue
;
}
NSWindow
*
win
=
ancestor
-
>
GetCocoaWindow
(
)
;
[
[
win
standardWindowButton
:
NSWindowCloseButton
]
setEnabled
:
!
aModal
]
;
[
[
win
standardWindowButton
:
NSWindowMiniaturizeButton
]
setEnabled
:
!
aModal
]
;
[
[
win
standardWindowButton
:
NSWindowZoomButton
]
setEnabled
:
!
aModal
]
;
}
if
(
aModal
)
{
mWindow
.
level
=
NSModalPanelWindowLevel
;
}
else
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
SetPopupWindowLevel
(
)
;
}
else
{
mWindow
.
level
=
NSNormalWindowLevel
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
IsRunningAppModal
(
)
{
return
[
NSApp
_isRunningAppModal
]
;
}
void
nsCocoaWindow
:
:
Show
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
if
(
aState
=
=
mWindow
.
isVisibleOrBeingShown
)
{
return
;
}
[
mWindow
setBeingShown
:
aState
]
;
if
(
aState
&
&
!
mWasShown
)
{
mWasShown
=
true
;
}
NSWindow
*
nativeParentWindow
=
mParent
?
(
NSWindow
*
)
mParent
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
:
nil
;
if
(
aState
&
&
!
mBounds
.
IsEmpty
(
)
)
{
if
(
NSApp
.
activationPolicy
!
=
NSApplicationActivationPolicyRegular
)
{
NSApp
.
activationPolicy
=
NSApplicationActivationPolicyRegular
;
PR_SetEnv
(
"
MOZ_APP_NO_DOCK
=
"
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
&
&
nativeParentWindow
)
{
if
(
!
nativeParentWindow
.
isVisible
|
|
nativeParentWindow
.
isMiniaturized
)
{
return
;
}
}
if
(
mPopupContentView
)
{
mPopupContentView
-
>
Show
(
true
)
;
}
bool
savedValueForSupportsNativeFullscreen
=
GetSupportsNativeFullscreen
(
)
;
if
(
!
mInFullScreenMode
&
&
(
(
mWindowType
=
=
WindowType
:
:
Popup
)
|
|
mAlwaysOnTop
|
|
mIsAlert
)
)
{
SetSupportsNativeFullscreen
(
false
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
[
mWindow
contentView
]
setNeedsDisplay
:
YES
]
;
if
(
!
nativeParentWindow
|
|
mPopupLevel
!
=
PopupLevel
:
:
Parent
)
{
[
mWindow
orderFront
:
nil
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
SendSetZLevelEvent
(
)
;
if
(
[
mWindow
isKindOfClass
:
[
PopupWindow
class
]
]
&
&
[
(
PopupWindow
*
)
mWindow
isContextMenu
]
)
{
[
NSDistributedNotificationCenter
.
defaultCenter
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
beginMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
}
if
(
nativeParentWindow
&
&
mPopupLevel
=
=
PopupLevel
:
:
Parent
)
{
[
nativeParentWindow
addChildWindow
:
mWindow
ordered
:
NSWindowAbove
]
;
}
}
else
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindowType
=
=
WindowType
:
:
TopLevel
&
&
[
mWindow
respondsToSelector
:
selector
(
setAnimationBehavior
:
)
]
)
{
NSWindowAnimationBehavior
behavior
;
if
(
mIsAnimationSuppressed
)
{
behavior
=
NSWindowAnimationBehaviorNone
;
}
else
{
switch
(
mAnimationType
)
{
case
nsIWidget
:
:
eDocumentWindowAnimation
:
behavior
=
NSWindowAnimationBehaviorDocumentWindow
;
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
unexpected
mAnimationType
value
"
)
;
case
nsIWidget
:
:
eGenericWindowAnimation
:
behavior
=
NSWindowAnimationBehaviorDefault
;
break
;
}
}
[
mWindow
setAnimationBehavior
:
behavior
]
;
mWindowAnimationBehavior
=
behavior
;
}
if
(
mAlwaysOnTop
|
|
mIsAlert
)
{
[
mWindow
orderFront
:
nil
]
;
}
else
{
[
mWindow
makeKeyAndOrderFront
:
nil
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
SendSetZLevelEvent
(
)
;
}
SetSupportsNativeFullscreen
(
savedValueForSupportsNativeFullscreen
)
;
}
else
{
if
(
mWindowType
=
=
WindowType
:
:
TopLevel
|
|
mWindowType
=
=
WindowType
:
:
Dialog
)
{
RollUpPopups
(
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
&
&
nativeParentWindow
)
{
[
nativeParentWindow
removeChildWindow
:
mWindow
]
;
}
[
mWindow
orderOut
:
nil
]
;
if
(
[
mWindow
isKindOfClass
:
[
PopupWindow
class
]
]
&
&
[
(
PopupWindow
*
)
mWindow
isContextMenu
]
)
{
[
NSDistributedNotificationCenter
.
defaultCenter
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
endMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
}
}
[
mWindow
setBeingShown
:
NO
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
NeedsRecreateToReshow
(
)
{
return
mWindowType
=
=
WindowType
:
:
Popup
&
&
mWasShown
&
&
NSScreen
.
screens
.
count
>
1
;
}
WindowRenderer
*
nsCocoaWindow
:
:
GetWindowRenderer
(
)
{
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
GetWindowRenderer
(
)
;
}
return
nullptr
;
}
TransparencyMode
nsCocoaWindow
:
:
GetTransparencyMode
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
mWindow
.
isOpaque
?
TransparencyMode
:
:
Opaque
:
TransparencyMode
:
:
Transparent
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
TransparencyMode
:
:
Opaque
)
;
}
void
nsCocoaWindow
:
:
SetTransparencyMode
(
TransparencyMode
aMode
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
BOOL
isTransparent
=
aMode
=
=
TransparencyMode
:
:
Transparent
;
BOOL
currentTransparency
=
!
mWindow
.
isOpaque
;
if
(
isTransparent
=
=
currentTransparency
)
{
return
;
}
mWindow
.
opaque
=
!
isTransparent
;
mWindow
.
backgroundColor
=
isTransparent
?
NSColor
.
clearColor
:
NSColor
.
whiteColor
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
Enable
(
bool
aState
)
{
}
bool
nsCocoaWindow
:
:
IsEnabled
(
)
const
{
return
true
;
}
void
nsCocoaWindow
:
:
ConstrainPosition
(
DesktopIntPoint
&
aPoint
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
|
|
!
[
mWindow
screen
]
)
{
return
;
}
nsIntRect
screenBounds
;
int32_t
width
height
;
NSRect
frame
=
mWindow
.
frame
;
width
=
std
:
:
max
<
int32_t
>
(
frame
.
size
.
width
1
)
;
height
=
std
:
:
max
<
int32_t
>
(
frame
.
size
.
height
1
)
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenMgr
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
screenMgr
-
>
ScreenForRect
(
aPoint
.
x
aPoint
.
y
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
screen
-
>
GetRectDisplayPix
(
&
(
screenBounds
.
x
)
&
(
screenBounds
.
y
)
&
(
screenBounds
.
width
)
&
(
screenBounds
.
height
)
)
;
}
}
if
(
aPoint
.
x
<
screenBounds
.
x
)
{
aPoint
.
x
=
screenBounds
.
x
;
}
else
if
(
aPoint
.
x
>
=
screenBounds
.
x
+
screenBounds
.
width
-
width
)
{
aPoint
.
x
=
screenBounds
.
x
+
screenBounds
.
width
-
width
;
}
if
(
aPoint
.
y
<
screenBounds
.
y
)
{
aPoint
.
y
=
screenBounds
.
y
;
}
else
if
(
aPoint
.
y
>
=
screenBounds
.
y
+
screenBounds
.
height
-
height
)
{
aPoint
.
y
=
screenBounds
.
y
+
screenBounds
.
height
-
height
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSizeConstraints
(
const
SizeConstraints
&
aConstraints
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSRect
rect
=
(
mWindowType
=
=
WindowType
:
:
Popup
)
?
NSZeroRect
:
NSMakeRect
(
0
.
0
0
.
0
32
32
)
;
rect
=
[
mWindow
frameRectForChildViewRect
:
rect
]
;
SizeConstraints
c
=
aConstraints
;
if
(
c
.
mScale
.
scale
=
=
MOZ_WIDGET_INVALID_SCALE
)
{
c
.
mScale
.
scale
=
BackingScaleFactor
(
)
;
}
c
.
mMinSize
.
width
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
rect
.
size
.
width
c
.
mScale
.
scale
)
c
.
mMinSize
.
width
)
;
c
.
mMinSize
.
height
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
rect
.
size
.
height
c
.
mScale
.
scale
)
c
.
mMinSize
.
height
)
;
NSSize
minSize
=
{
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMinSize
.
width
c
.
mScale
.
scale
)
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMinSize
.
height
c
.
mScale
.
scale
)
}
;
mWindow
.
minSize
=
minSize
;
c
.
mMaxSize
.
width
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
c
.
mMaxSize
.
width
c
.
mScale
.
scale
)
c
.
mMaxSize
.
width
)
;
c
.
mMaxSize
.
height
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
c
.
mMaxSize
.
height
c
.
mScale
.
scale
)
c
.
mMaxSize
.
height
)
;
NSSize
maxSize
=
{
c
.
mMaxSize
.
width
=
=
NS_MAXSIZE
?
FLT_MAX
:
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMaxSize
.
width
c
.
mScale
.
scale
)
c
.
mMaxSize
.
height
=
=
NS_MAXSIZE
?
FLT_MAX
:
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMaxSize
.
height
c
.
mScale
.
scale
)
}
;
mWindow
.
maxSize
=
maxSize
;
nsBaseWidget
:
:
SetSizeConstraints
(
c
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
Move
(
double
aX
double
aY
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
NSPoint
coord
=
{
static_cast
<
float
>
(
aX
)
static_cast
<
float
>
(
nsCocoaUtils
:
:
FlippedScreenY
(
NSToIntRound
(
aY
)
)
)
}
;
NSRect
frame
=
mWindow
.
frame
;
if
(
frame
.
origin
.
x
!
=
coord
.
x
|
|
frame
.
origin
.
y
+
frame
.
size
.
height
!
=
coord
.
y
)
{
[
mWindow
setFrameTopLeftPoint
:
coord
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSizeMode
(
nsSizeMode
aMode
)
{
if
(
aMode
=
=
nsSizeMode_Normal
)
{
QueueTransition
(
TransitionType
:
:
Windowed
)
;
}
else
if
(
aMode
=
=
nsSizeMode_Minimized
)
{
QueueTransition
(
TransitionType
:
:
Miniaturize
)
;
}
else
if
(
aMode
=
=
nsSizeMode_Maximized
)
{
QueueTransition
(
TransitionType
:
:
Zoom
)
;
}
else
if
(
aMode
=
=
nsSizeMode_Fullscreen
)
{
MakeFullScreen
(
true
)
;
}
}
typedef
CGSSpaceID
(
*
CGSGetActiveSpaceFunc
)
(
CGSConnection
cid
)
;
static
CGSGetActiveSpaceFunc
GetCGSGetActiveSpaceFunc
(
)
{
static
CGSGetActiveSpaceFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSGetActiveSpaceFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSGetActiveSpace
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
CFArrayRef
(
*
CGSCopyManagedDisplaySpacesFunc
)
(
CGSConnection
cid
)
;
static
CGSCopyManagedDisplaySpacesFunc
GetCGSCopyManagedDisplaySpacesFunc
(
)
{
static
CGSCopyManagedDisplaySpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSCopyManagedDisplaySpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSCopyManagedDisplaySpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
CFArrayRef
(
*
CGSCopySpacesForWindowsFunc
)
(
CGSConnection
cid
CGSSpaceMask
mask
CFArrayRef
windowIDs
)
;
static
CGSCopySpacesForWindowsFunc
GetCGSCopySpacesForWindowsFunc
(
)
{
static
CGSCopySpacesForWindowsFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSCopySpacesForWindowsFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSCopySpacesForWindows
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
void
(
*
CGSAddWindowsToSpacesFunc
)
(
CGSConnection
cid
CFArrayRef
windowIDs
CFArrayRef
spaceIDs
)
;
static
CGSAddWindowsToSpacesFunc
GetCGSAddWindowsToSpacesFunc
(
)
{
static
CGSAddWindowsToSpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSAddWindowsToSpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSAddWindowsToSpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
void
(
*
CGSRemoveWindowsFromSpacesFunc
)
(
CGSConnection
cid
CFArrayRef
windowIDs
CFArrayRef
spaceIDs
)
;
static
CGSRemoveWindowsFromSpacesFunc
GetCGSRemoveWindowsFromSpacesFunc
(
)
{
static
CGSRemoveWindowsFromSpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSRemoveWindowsFromSpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSRemoveWindowsFromSpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
void
nsCocoaWindow
:
:
GetWorkspaceID
(
nsAString
&
workspaceID
)
{
workspaceID
.
Truncate
(
)
;
int32_t
sid
=
GetWorkspaceID
(
)
;
if
(
sid
!
=
0
)
{
workspaceID
.
AppendInt
(
sid
)
;
}
}
int32_t
nsCocoaWindow
:
:
GetWorkspaceID
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
CGSSpaceID
sid
=
0
;
CGSCopySpacesForWindowsFunc
CopySpacesForWindows
=
GetCGSCopySpacesForWindowsFunc
(
)
;
if
(
!
CopySpacesForWindows
)
{
return
sid
;
}
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
NSArray
<
NSNumber
*
>
*
spaceIDs
=
CFBridgingRelease
(
CopySpacesForWindows
(
cid
kCGSAllSpacesMask
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
)
)
;
if
(
[
spaceIDs
count
]
)
{
sid
=
[
spaceIDs
[
0
]
integerValue
]
;
}
else
{
CGSGetActiveSpaceFunc
GetActiveSpace
=
GetCGSGetActiveSpaceFunc
(
)
;
if
(
GetActiveSpace
)
{
sid
=
GetActiveSpace
(
cid
)
;
}
}
return
sid
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
MoveToWorkspace
(
const
nsAString
&
workspaceIDStr
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
[
NSScreen
screensHaveSeparateSpaces
]
&
&
[
[
NSScreen
screens
]
count
]
>
1
)
{
return
;
}
nsresult
rv
=
NS_OK
;
int32_t
workspaceID
=
workspaceIDStr
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
int32_t
currentSpace
=
GetWorkspaceID
(
)
;
if
(
!
workspaceID
|
|
workspaceID
=
=
currentSpace
)
{
return
;
}
CGSCopyManagedDisplaySpacesFunc
CopyManagedDisplaySpaces
=
GetCGSCopyManagedDisplaySpacesFunc
(
)
;
CGSAddWindowsToSpacesFunc
AddWindowsToSpaces
=
GetCGSAddWindowsToSpacesFunc
(
)
;
CGSRemoveWindowsFromSpacesFunc
RemoveWindowsFromSpaces
=
GetCGSRemoveWindowsFromSpacesFunc
(
)
;
if
(
!
CopyManagedDisplaySpaces
|
|
!
AddWindowsToSpaces
|
|
!
RemoveWindowsFromSpaces
)
{
return
;
}
NSArray
*
displaySpacesInfo
=
CFBridgingRelease
(
CopyManagedDisplaySpaces
(
cid
)
)
;
BOOL
found
=
false
;
for
(
NSDictionary
<
NSString
*
id
>
*
spacesInfo
in
displaySpacesInfo
)
{
NSArray
<
NSNumber
*
>
*
sids
=
[
spacesInfo
[
CGSSpacesKey
]
valueForKey
:
CGSSpaceIDKey
]
;
for
(
NSNumber
*
sid
in
sids
)
{
if
(
(
int
)
[
sid
integerValue
]
=
=
workspaceID
)
{
found
=
true
;
break
;
}
}
if
(
found
)
{
break
;
}
}
if
(
!
found
)
{
return
;
}
AddWindowsToSpaces
(
cid
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
(
__bridge
CFArrayRef
)
[
(
workspaceID
)
]
)
;
RemoveWindowsFromSpaces
(
cid
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
(
__bridge
CFArrayRef
)
[
(
currentSpace
)
]
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SuppressAnimation
(
bool
aSuppress
)
{
if
(
[
mWindow
respondsToSelector
:
selector
(
setAnimationBehavior
:
)
]
)
{
mWindow
.
isAnimationSuppressed
=
aSuppress
;
mWindow
.
animationBehavior
=
aSuppress
?
NSWindowAnimationBehaviorNone
:
mWindowAnimationBehavior
;
}
}
void
nsCocoaWindow
:
:
HideWindowChrome
(
bool
aShouldHide
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
|
|
!
mWindowMadeHere
|
|
(
mWindowType
!
=
WindowType
:
:
TopLevel
&
&
mWindowType
!
=
WindowType
:
:
Dialog
)
)
{
return
;
}
const
BOOL
isVisible
=
mWindow
.
isVisible
;
NSArray
*
childWindows
=
[
mWindow
childWindows
]
;
NSEnumerator
*
enumerator
=
[
childWindows
objectEnumerator
]
;
NSWindow
*
child
=
nil
;
while
(
(
child
=
[
enumerator
nextObject
]
)
)
{
[
mWindow
removeChildWindow
:
child
]
;
}
NSArray
<
NSView
*
>
*
contentViewContents
=
[
mWindow
contentViewContents
]
;
for
(
NSView
*
view
in
contentViewContents
)
{
[
view
removeFromSuperviewWithoutNeedingDisplay
]
;
}
NSMutableDictionary
*
state
=
[
mWindow
exportState
]
;
NSRect
frameRect
=
mWindow
.
frame
;
DestroyNativeWindow
(
)
;
nsresult
rv
=
CreateNativeWindow
(
frameRect
aShouldHide
?
BorderStyle
:
:
None
:
mBorderStyle
true
mWindow
.
restorable
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
[
mWindow
importState
:
state
]
;
for
(
NSView
*
view
in
contentViewContents
)
{
[
[
mWindow
contentView
]
addSubview
:
view
]
;
}
enumerator
=
[
childWindows
objectEnumerator
]
;
while
(
(
child
=
[
enumerator
nextObject
]
)
)
{
[
mWindow
addChildWindow
:
child
ordered
:
NSWindowAbove
]
;
}
if
(
isVisible
)
{
bool
wasAnimationSuppressed
=
mIsAnimationSuppressed
;
mIsAnimationSuppressed
=
true
;
Show
(
true
)
;
mIsAnimationSuppressed
=
wasAnimationSuppressed
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
class
FullscreenTransitionData
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
FullscreenTransitionData
(
NSWindow
*
aWindow
)
:
mTransitionWindow
(
aWindow
)
{
}
NSWindow
*
mTransitionWindow
;
private
:
virtual
~
FullscreenTransitionData
(
)
{
[
mTransitionWindow
close
]
;
}
}
;
NS_IMPL_ISUPPORTS0
(
FullscreenTransitionData
)
interface
FullscreenTransitionDelegate
:
NSObject
<
NSAnimationDelegate
>
{
public
nsCocoaWindow
*
mWindow
;
nsIRunnable
*
mCallback
;
}
end
implementation
FullscreenTransitionDelegate
-
(
void
)
cleanupAndDispatch
:
(
NSAnimation
*
)
animation
{
[
animation
setDelegate
:
nil
]
;
[
self
autorelease
]
;
NS_DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
(
mCallback
)
)
;
}
-
(
void
)
animationDidEnd
:
(
NSAnimation
*
)
animation
{
MOZ_ASSERT
(
animation
=
=
mWindow
-
>
FullscreenTransitionAnimation
(
)
"
Should
be
handling
the
only
animation
on
the
window
"
)
;
mWindow
-
>
ReleaseFullscreenTransitionAnimation
(
)
;
[
self
cleanupAndDispatch
:
animation
]
;
}
-
(
void
)
animationDidStop
:
(
NSAnimation
*
)
animation
{
[
self
cleanupAndDispatch
:
animation
]
;
}
end
static
bool
AlwaysUsesNativeFullScreen
(
)
{
return
Preferences
:
:
GetBool
(
"
full
-
screen
-
api
.
macos
-
native
-
full
-
screen
"
false
)
;
}
bool
nsCocoaWindow
:
:
PrepareForFullscreenTransition
(
nsISupports
*
*
aData
)
{
if
(
AlwaysUsesNativeFullScreen
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mIgnoreOcclusionCount
>
=
0
)
;
mIgnoreOcclusionCount
+
+
;
nsCOMPtr
<
nsIScreen
>
widgetScreen
=
GetWidgetScreen
(
)
;
NSScreen
*
cocoaScreen
=
ScreenHelperCocoa
:
:
CocoaScreenForScreen
(
widgetScreen
)
;
NSWindow
*
win
=
[
[
NSWindow
alloc
]
initWithContentRect
:
cocoaScreen
.
frame
styleMask
:
NSWindowStyleMaskBorderless
backing
:
NSBackingStoreBuffered
defer
:
YES
]
;
[
win
setBackgroundColor
:
[
NSColor
blackColor
]
]
;
[
win
setAlphaValue
:
0
]
;
[
win
setIgnoresMouseEvents
:
YES
]
;
[
win
setLevel
:
NSScreenSaverWindowLevel
]
;
[
win
makeKeyAndOrderFront
:
nil
]
;
auto
data
=
new
FullscreenTransitionData
(
win
)
;
*
aData
=
data
;
NS_ADDREF
(
data
)
;
return
true
;
}
void
nsCocoaWindow
:
:
CleanupFullscreenTransition
(
)
{
MOZ_ASSERT
(
mIgnoreOcclusionCount
>
0
)
;
mIgnoreOcclusionCount
-
-
;
}
void
nsCocoaWindow
:
:
PerformFullscreenTransition
(
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsISupports
*
aData
nsIRunnable
*
aCallback
)
{
auto
data
=
static_cast
<
FullscreenTransitionData
*
>
(
aData
)
;
FullscreenTransitionDelegate
*
delegate
=
[
[
FullscreenTransitionDelegate
alloc
]
init
]
;
delegate
-
>
mWindow
=
this
;
delegate
-
>
mCallback
=
nsCOMPtr
<
nsIRunnable
>
(
aCallback
)
.
forget
(
)
.
take
(
)
;
if
(
mFullscreenTransitionAnimation
)
{
[
mFullscreenTransitionAnimation
stopAnimation
]
;
ReleaseFullscreenTransitionAnimation
(
)
;
}
NSDictionary
*
dict
=
{
NSViewAnimationTargetKey
:
data
-
>
mTransitionWindow
NSViewAnimationEffectKey
:
aStage
=
=
eBeforeFullscreenToggle
?
NSViewAnimationFadeInEffect
:
NSViewAnimationFadeOutEffect
}
;
mFullscreenTransitionAnimation
=
[
[
NSViewAnimation
alloc
]
initWithViewAnimations
:
[
dict
]
]
;
[
mFullscreenTransitionAnimation
setDelegate
:
delegate
]
;
[
mFullscreenTransitionAnimation
setDuration
:
aDuration
/
1000
.
0
]
;
[
mFullscreenTransitionAnimation
startAnimation
]
;
}
void
nsCocoaWindow
:
:
CocoaWindowWillEnterFullscreen
(
bool
aFullscreen
)
{
MOZ_ASSERT
(
mUpdateFullscreenOnResize
.
isNothing
(
)
)
;
mHasStartedNativeFullscreen
=
true
;
mUpdateFullscreenOnResize
=
Some
(
aFullscreen
?
TransitionType
:
:
Fullscreen
:
TransitionType
:
:
Windowed
)
;
}
void
nsCocoaWindow
:
:
CocoaWindowDidEnterFullscreen
(
bool
aFullscreen
)
{
EndOurNativeTransition
(
)
;
mHasStartedNativeFullscreen
=
false
;
DispatchOcclusionEvent
(
)
;
bool
receivedExpectedFullscreen
=
false
;
if
(
mUpdateFullscreenOnResize
.
isSome
(
)
)
{
bool
expectingFullscreen
=
(
*
mUpdateFullscreenOnResize
=
=
TransitionType
:
:
Fullscreen
)
;
receivedExpectedFullscreen
=
(
expectingFullscreen
=
=
aFullscreen
)
;
}
else
{
receivedExpectedFullscreen
=
(
mInFullScreenMode
=
=
aFullscreen
)
;
}
TransitionType
transition
=
aFullscreen
?
TransitionType
:
:
Fullscreen
:
TransitionType
:
:
Windowed
;
if
(
receivedExpectedFullscreen
)
{
HandleUpdateFullscreenOnResize
(
)
;
}
else
{
UpdateFullscreenState
(
aFullscreen
true
)
;
if
(
mTransitionCurrent
.
isSome
(
)
)
{
mTransitionCurrent
=
Some
(
transition
)
;
}
}
FinishCurrentTransitionIfMatching
(
transition
)
;
}
void
nsCocoaWindow
:
:
UpdateFullscreenState
(
bool
aFullScreen
bool
aNativeMode
)
{
bool
wasInFullscreen
=
mInFullScreenMode
;
mInFullScreenMode
=
aFullScreen
;
if
(
aNativeMode
|
|
mInNativeFullScreenMode
)
{
mInNativeFullScreenMode
=
aFullScreen
;
}
if
(
aFullScreen
=
=
wasInFullscreen
)
{
return
;
}
DispatchSizeModeEvent
(
)
;
nsChildView
*
mainChildView
=
static_cast
<
nsChildView
*
>
(
[
[
mWindow
mainChildView
]
widget
]
)
;
if
(
mainChildView
)
{
mainChildView
-
>
UpdateFullscreen
(
aFullScreen
)
;
}
}
nsresult
nsCocoaWindow
:
:
MakeFullScreen
(
bool
aFullScreen
)
{
return
DoMakeFullScreen
(
aFullScreen
AlwaysUsesNativeFullScreen
(
)
)
;
}
nsresult
nsCocoaWindow
:
:
MakeFullScreenWithNativeTransition
(
bool
aFullScreen
)
{
return
DoMakeFullScreen
(
aFullScreen
true
)
;
}
nsresult
nsCocoaWindow
:
:
DoMakeFullScreen
(
bool
aFullScreen
bool
aUseSystemTransition
)
{
if
(
!
mWindow
)
{
return
NS_OK
;
}
TransitionType
transition
=
TransitionType
:
:
Windowed
;
if
(
aFullScreen
)
{
transition
=
(
aUseSystemTransition
&
&
(
mWindow
.
collectionBehavior
&
NSWindowCollectionBehaviorFullScreenPrimary
)
)
?
TransitionType
:
:
Fullscreen
:
TransitionType
:
:
EmulatedFullscreen
;
}
QueueTransition
(
transition
)
;
return
NS_OK
;
}
void
nsCocoaWindow
:
:
QueueTransition
(
const
TransitionType
&
aTransition
)
{
mTransitionsPending
.
push
(
aTransition
)
;
ProcessTransitions
(
)
;
}
void
nsCocoaWindow
:
:
ProcessTransitions
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
if
(
mInProcessTransitions
)
{
return
;
}
mInProcessTransitions
=
true
;
if
(
mProcessTransitionsPending
)
{
mProcessTransitionsPending
-
>
Cancel
(
)
;
mProcessTransitionsPending
=
nullptr
;
}
while
(
!
mTransitionsPending
.
empty
(
)
&
&
!
IsInTransition
(
)
)
{
TransitionType
nextTransition
=
mTransitionsPending
.
front
(
)
;
switch
(
nextTransition
)
{
case
TransitionType
:
:
Fullscreen
:
case
TransitionType
:
:
EmulatedFullscreen
:
case
TransitionType
:
:
Windowed
:
case
TransitionType
:
:
Zoom
:
if
(
mWindow
.
miniaturized
)
{
mTransitionCurrent
=
Some
(
TransitionType
:
:
Deminiaturize
)
;
mIsTransitionCurrentAdded
=
true
;
}
break
;
case
TransitionType
:
:
Miniaturize
:
if
(
mInFullScreenMode
)
{
mTransitionCurrent
=
Some
(
TransitionType
:
:
Windowed
)
;
mIsTransitionCurrentAdded
=
true
;
}
break
;
default
:
break
;
}
if
(
mTransitionCurrent
.
isNothing
(
)
)
{
mTransitionCurrent
=
Some
(
nextTransition
)
;
mTransitionsPending
.
pop
(
)
;
}
switch
(
*
mTransitionCurrent
)
{
case
TransitionType
:
:
Fullscreen
:
{
if
(
!
mInFullScreenMode
)
{
NSRunLoop
*
localRunLoop
=
[
NSRunLoop
currentRunLoop
]
;
while
(
mWindow
&
&
!
CanStartNativeTransition
(
)
&
&
[
localRunLoop
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
)
{
}
[
mWindow
toggleFullScreen
:
nil
]
;
continue
;
}
break
;
}
case
TransitionType
:
:
EmulatedFullscreen
:
{
if
(
!
mInFullScreenMode
)
{
NSDisableScreenUpdates
(
)
;
mSuppressSizeModeEvents
=
true
;
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
true
)
;
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
true
)
;
mSuppressSizeModeEvents
=
false
;
NSEnableScreenUpdates
(
)
;
UpdateFullscreenState
(
true
false
)
;
}
break
;
}
case
TransitionType
:
:
Windowed
:
{
if
(
mInFullScreenMode
)
{
if
(
mInNativeFullScreenMode
)
{
NSRunLoop
*
localRunLoop
=
[
NSRunLoop
currentRunLoop
]
;
while
(
mWindow
&
&
!
CanStartNativeTransition
(
)
&
&
[
localRunLoop
runMode
:
NSDefaultRunLoopMode
beforeDate
:
[
NSDate
distantFuture
]
]
)
{
}
[
mWindow
toggleFullScreen
:
nil
]
;
continue
;
}
else
{
NSDisableScreenUpdates
(
)
;
mSuppressSizeModeEvents
=
true
;
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
false
)
;
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
false
)
;
mSuppressSizeModeEvents
=
false
;
NSEnableScreenUpdates
(
)
;
UpdateFullscreenState
(
false
false
)
;
}
}
else
if
(
mWindow
.
zoomed
)
{
[
mWindow
zoom
:
nil
]
;
if
(
mWindow
.
zoomed
)
{
NSRect
maximumFrame
=
mWindow
.
frame
;
const
CGFloat
INSET_OUT_OF_ZOOM
=
20
.
0f
;
[
mWindow
setFrame
:
NSInsetRect
(
maximumFrame
INSET_OUT_OF_ZOOM
INSET_OUT_OF_ZOOM
)
display
:
YES
]
;
MOZ_ASSERT
(
!
mWindow
.
zoomed
"
We
should
be
able
to
unzoom
by
shrinking
the
frame
a
bit
.
"
)
;
}
}
break
;
}
case
TransitionType
:
:
Miniaturize
:
if
(
!
mWindow
.
miniaturized
)
{
[
mWindow
miniaturize
:
nil
]
;
continue
;
}
break
;
case
TransitionType
:
:
Deminiaturize
:
if
(
mWindow
.
miniaturized
)
{
[
mWindow
deminiaturize
:
nil
]
;
continue
;
}
break
;
case
TransitionType
:
:
Zoom
:
if
(
!
mWindow
.
zoomed
)
{
[
mWindow
zoom
:
nil
]
;
}
break
;
default
:
break
;
}
mTransitionCurrent
.
reset
(
)
;
mIsTransitionCurrentAdded
=
false
;
}
mInProcessTransitions
=
false
;
if
(
!
IsInTransition
(
)
)
{
DispatchSizeModeEvent
(
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
CancelAllTransitions
(
)
{
mTransitionCurrent
.
reset
(
)
;
mIsTransitionCurrentAdded
=
false
;
if
(
mProcessTransitionsPending
)
{
mProcessTransitionsPending
-
>
Cancel
(
)
;
mProcessTransitionsPending
=
nullptr
;
}
std
:
:
queue
<
TransitionType
>
(
)
.
swap
(
mTransitionsPending
)
;
}
void
nsCocoaWindow
:
:
FinishCurrentTransitionIfMatching
(
const
TransitionType
&
aTransition
)
{
DispatchSizeModeEvent
(
)
;
if
(
mTransitionCurrent
.
isSome
(
)
&
&
(
*
mTransitionCurrent
=
=
aTransition
)
)
{
mTransitionCurrent
.
reset
(
)
;
mIsTransitionCurrentAdded
=
false
;
if
(
!
mTransitionsPending
.
empty
(
)
&
&
!
mProcessTransitionsPending
)
{
mProcessTransitionsPending
=
NS_NewCancelableRunnableFunction
(
"
ProcessTransitionsPending
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
ProcessTransitions
(
)
;
}
)
;
NS_DispatchToCurrentThread
(
mProcessTransitionsPending
)
;
}
}
}
bool
nsCocoaWindow
:
:
HandleUpdateFullscreenOnResize
(
)
{
if
(
mUpdateFullscreenOnResize
.
isNothing
(
)
)
{
return
false
;
}
bool
toFullscreen
=
(
*
mUpdateFullscreenOnResize
=
=
TransitionType
:
:
Fullscreen
)
;
mUpdateFullscreenOnResize
.
reset
(
)
;
UpdateFullscreenState
(
toFullscreen
true
)
;
return
true
;
}
nsCocoaWindow
*
nsCocoaWindow
:
:
sWindowInNativeTransition
(
nullptr
)
;
bool
nsCocoaWindow
:
:
CanStartNativeTransition
(
)
{
if
(
sWindowInNativeTransition
=
=
nullptr
)
{
sWindowInNativeTransition
=
this
;
return
true
;
}
return
false
;
}
void
nsCocoaWindow
:
:
EndOurNativeTransition
(
)
{
if
(
sWindowInNativeTransition
=
=
this
)
{
sWindowInNativeTransition
=
nullptr
;
}
}
void
nsCocoaWindow
:
:
DoResize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
bool
aConstrainToCurrentScreen
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
|
|
mInResize
)
{
return
;
}
auto
relockAspectRatio
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
mAspectRatioLocked
)
{
LockAspectRatio
(
true
)
;
}
}
)
;
AutoRestore
<
bool
>
reentrantResizeGuard
(
mInResize
)
;
mInResize
=
true
;
CGFloat
scale
=
mSizeConstraints
.
mScale
.
scale
;
if
(
scale
=
=
MOZ_WIDGET_INVALID_SCALE
)
{
scale
=
BackingScaleFactor
(
)
;
}
int32_t
width
=
NSToIntRound
(
aWidth
*
scale
)
;
int32_t
height
=
NSToIntRound
(
aHeight
*
scale
)
;
width
=
std
:
:
max
(
mSizeConstraints
.
mMinSize
.
width
std
:
:
min
(
mSizeConstraints
.
mMaxSize
.
width
width
)
)
;
height
=
std
:
:
max
(
mSizeConstraints
.
mMinSize
.
height
std
:
:
min
(
mSizeConstraints
.
mMaxSize
.
height
height
)
)
;
DesktopIntRect
newBounds
(
NSToIntRound
(
aX
)
NSToIntRound
(
aY
)
NSToIntRound
(
width
/
scale
)
NSToIntRound
(
height
/
scale
)
)
;
NSRect
newFrame
=
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
newBounds
)
;
NSRect
frame
=
mWindow
.
frame
;
BOOL
isMoving
=
newFrame
.
origin
.
x
!
=
frame
.
origin
.
x
|
|
newFrame
.
origin
.
y
!
=
frame
.
origin
.
y
;
BOOL
isResizing
=
newFrame
.
size
.
width
!
=
frame
.
size
.
width
|
|
newFrame
.
size
.
height
!
=
frame
.
size
.
height
;
if
(
!
isMoving
&
&
!
isResizing
)
{
return
;
}
[
mWindow
setFrame
:
newFrame
display
:
YES
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
Resize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
)
{
DoResize
(
aX
aY
aWidth
aHeight
aRepaint
false
)
;
}
void
nsCocoaWindow
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
double
invScale
=
1
.
0
/
BackingScaleFactor
(
)
;
DoResize
(
mBounds
.
x
*
invScale
mBounds
.
y
*
invScale
aWidth
aHeight
aRepaint
true
)
;
}
NSRect
nsCocoaWindow
:
:
GetClientCocoaRect
(
)
{
if
(
!
mWindow
)
{
return
NSZeroRect
;
}
return
[
mWindow
childViewRectForFrameRect
:
mWindow
.
frame
]
;
}
LayoutDeviceIntRect
nsCocoaWindow
:
:
GetClientBounds
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
CGFloat
scaleFactor
=
BackingScaleFactor
(
)
;
return
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
GetClientCocoaRect
(
)
scaleFactor
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
;
}
void
nsCocoaWindow
:
:
UpdateBounds
(
)
{
NSRect
frame
=
NSZeroRect
;
if
(
mWindow
)
{
frame
=
mWindow
.
frame
;
}
mBounds
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
frame
BackingScaleFactor
(
)
)
;
if
(
mPopupContentView
)
{
mPopupContentView
-
>
UpdateBoundsFromView
(
)
;
}
}
LayoutDeviceIntRect
nsCocoaWindow
:
:
GetScreenBounds
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
#
ifdef
DEBUG
LayoutDeviceIntRect
r
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
mWindow
.
frame
BackingScaleFactor
(
)
)
;
NS_ASSERTION
(
mWindow
&
&
mBounds
=
=
r
"
mBounds
out
of
sync
!
"
)
;
#
endif
return
mBounds
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
;
}
double
nsCocoaWindow
:
:
GetDefaultScaleInternal
(
)
{
return
BackingScaleFactor
(
)
;
}
static
CGFloat
GetBackingScaleFactor
(
NSWindow
*
aWindow
)
{
NSRect
frame
=
aWindow
.
frame
;
if
(
frame
.
size
.
width
>
0
&
&
frame
.
size
.
height
>
0
)
{
return
nsCocoaUtils
:
:
GetBackingScaleFactor
(
aWindow
)
;
}
if
(
frame
.
size
.
width
=
=
0
)
{
frame
.
size
.
width
=
1
;
}
if
(
frame
.
size
.
height
=
=
0
)
{
frame
.
size
.
height
=
1
;
}
NSScreen
*
screen
=
FindTargetScreenForRect
(
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
frame
)
)
;
return
nsCocoaUtils
:
:
GetBackingScaleFactor
(
screen
)
;
}
CGFloat
nsCocoaWindow
:
:
BackingScaleFactor
(
)
{
if
(
mBackingScaleFactor
>
0
.
0
)
{
return
mBackingScaleFactor
;
}
if
(
!
mWindow
)
{
return
1
.
0
;
}
mBackingScaleFactor
=
GetBackingScaleFactor
(
mWindow
)
;
return
mBackingScaleFactor
;
}
void
nsCocoaWindow
:
:
BackingScaleFactorChanged
(
)
{
CGFloat
newScale
=
GetBackingScaleFactor
(
mWindow
)
;
if
(
mBackingScaleFactor
=
=
newScale
)
{
return
;
}
mBackingScaleFactor
=
newScale
;
NotifyAPZOfDPIChange
(
)
;
if
(
!
mWidgetListener
|
|
mWidgetListener
-
>
GetAppWindow
(
)
)
{
return
;
}
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
}
int32_t
nsCocoaWindow
:
:
RoundsWidgetCoordinatesTo
(
)
{
if
(
BackingScaleFactor
(
)
=
=
2
.
0
)
{
return
2
;
}
return
1
;
}
void
nsCocoaWindow
:
:
SetCursor
(
const
Cursor
&
aCursor
)
{
if
(
mPopupContentView
)
{
mPopupContentView
-
>
SetCursor
(
aCursor
)
;
}
}
nsresult
nsCocoaWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mWindow
)
{
return
NS_OK
;
}
const
nsString
&
strTitle
=
PromiseFlatString
(
aTitle
)
;
const
unichar
*
uniTitle
=
reinterpret_cast
<
const
unichar
*
>
(
strTitle
.
get
(
)
)
;
NSString
*
title
=
[
NSString
stringWithCharacters
:
uniTitle
length
:
strTitle
.
Length
(
)
]
;
if
(
mWindow
.
drawsContentsIntoWindowFrame
&
&
!
mWindow
.
wantsTitleDrawn
)
{
[
mWindow
disableSetNeedsDisplay
]
;
[
mWindow
setTitle
:
title
]
;
[
mWindow
enableSetNeedsDisplay
]
;
}
else
{
[
mWindow
setTitle
:
title
]
;
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsCocoaWindow
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
if
(
mPopupContentView
)
{
mPopupContentView
-
>
Invalidate
(
aRect
)
;
}
}
bool
nsCocoaWindow
:
:
DragEvent
(
unsigned
int
aMessage
mozilla
:
:
gfx
:
:
Point
aMouseGlobal
UInt16
aKeyModifiers
)
{
return
false
;
}
void
nsCocoaWindow
:
:
SendSetZLevelEvent
(
)
{
if
(
mWidgetListener
)
{
nsWindowZ
placement
=
nsWindowZTop
;
nsCOMPtr
<
nsIWidget
>
actualBelow
;
mWidgetListener
-
>
ZLevelChanged
(
true
&
placement
nullptr
getter_AddRefs
(
actualBelow
)
)
;
}
}
nsresult
nsCocoaWindow
:
:
DispatchEvent
(
WidgetGUIEvent
*
event
nsEventStatus
&
aStatus
)
{
aStatus
=
nsEventStatus_eIgnore
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
event
-
>
mWidget
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
if
(
mWidgetListener
)
{
aStatus
=
mWidgetListener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
}
return
NS_OK
;
}
static
nsSizeMode
GetWindowSizeMode
(
NSWindow
*
aWindow
bool
aFullScreen
)
{
if
(
aFullScreen
)
{
return
nsSizeMode_Fullscreen
;
}
if
(
aWindow
.
isMiniaturized
)
{
return
nsSizeMode_Minimized
;
}
if
(
(
aWindow
.
styleMask
&
NSWindowStyleMaskResizable
)
&
&
aWindow
.
isZoomed
)
{
return
nsSizeMode_Maximized
;
}
return
nsSizeMode_Normal
;
}
void
nsCocoaWindow
:
:
ReportMoveEvent
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mInReportMoveEvent
)
{
return
;
}
mInReportMoveEvent
=
true
;
UpdateBounds
(
)
;
if
(
mWindow
&
&
(
mSizeMode
=
=
nsSizeMode_Maximized
)
^
mWindow
.
isZoomed
)
{
DispatchSizeModeEvent
(
)
;
}
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
mInReportMoveEvent
=
false
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
DispatchSizeModeEvent
(
)
{
if
(
!
mWindow
)
{
return
;
}
if
(
mSuppressSizeModeEvents
|
|
mIsTransitionCurrentAdded
)
{
return
;
}
nsSizeMode
newMode
=
GetWindowSizeMode
(
mWindow
mInFullScreenMode
)
;
if
(
mSizeMode
=
=
newMode
)
{
return
;
}
mSizeMode
=
newMode
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
SizeModeChanged
(
newMode
)
;
}
}
void
nsCocoaWindow
:
:
DispatchOcclusionEvent
(
)
{
if
(
!
mWindow
)
{
return
;
}
bool
newOcclusionState
=
!
(
mHasStartedNativeFullscreen
|
|
(
[
mWindow
occlusionState
]
&
NSWindowOcclusionStateVisible
)
)
;
if
(
mIsFullyOccluded
=
=
newOcclusionState
)
{
return
;
}
MOZ_ASSERT
(
mIgnoreOcclusionCount
>
=
0
)
;
if
(
newOcclusionState
&
&
mIgnoreOcclusionCount
>
0
)
{
return
;
}
mIsFullyOccluded
=
newOcclusionState
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
OcclusionStateChanged
(
mIsFullyOccluded
)
;
}
}
void
nsCocoaWindow
:
:
ReportSizeEvent
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
UpdateBounds
(
)
;
if
(
mWidgetListener
)
{
LayoutDeviceIntRect
innerBounds
=
GetClientBounds
(
)
;
mWidgetListener
-
>
WindowResized
(
this
innerBounds
.
width
innerBounds
.
height
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetMenuBar
(
RefPtr
<
nsMenuBarX
>
&
&
aMenuBar
)
{
if
(
!
mWindow
)
{
mMenuBar
=
nullptr
;
return
;
}
mMenuBar
=
std
:
:
move
(
aMenuBar
)
;
if
(
mMenuBar
&
&
(
(
!
gSomeMenuBarPainted
&
&
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
=
=
mMenuBar
)
|
|
mWindow
.
isMainWindow
)
)
{
mMenuBar
-
>
Paint
(
)
;
}
}
void
nsCocoaWindow
:
:
SetFocus
(
Raise
aRaise
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
{
if
(
!
mWindow
)
return
;
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
SetFocus
(
aRaise
aCallerType
)
;
}
if
(
aRaise
=
=
Raise
:
:
Yes
&
&
(
mWindow
.
isVisible
|
|
mWindow
.
isMiniaturized
)
)
{
if
(
mWindow
.
isMiniaturized
)
{
[
mWindow
deminiaturize
:
nil
]
;
}
[
mWindow
makeKeyAndOrderFront
:
nil
]
;
SendSetZLevelEvent
(
)
;
}
}
LayoutDeviceIntPoint
nsCocoaWindow
:
:
WidgetToScreenOffset
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
GetClientCocoaRect
(
)
BackingScaleFactor
(
)
)
.
TopLeft
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntPoint
nsCocoaWindow
:
:
GetClientOffset
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
LayoutDeviceIntRect
clientRect
=
GetClientBounds
(
)
;
return
clientRect
.
TopLeft
(
)
-
mBounds
.
TopLeft
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntMargin
nsCocoaWindow
:
:
ClientToWindowMargin
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mWindow
|
|
mWindow
.
drawsContentsIntoWindowFrame
|
|
mWindowType
=
=
WindowType
:
:
Popup
)
{
return
{
}
;
}
NSRect
clientNSRect
=
mWindow
.
contentLayoutRect
;
NSRect
frameNSRect
=
[
mWindow
frameRectForChildViewRect
:
clientNSRect
]
;
CGFloat
backingScale
=
BackingScaleFactor
(
)
;
const
auto
clientRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
clientNSRect
backingScale
)
;
const
auto
frameRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
frameNSRect
backingScale
)
;
return
frameRect
-
clientRect
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
{
}
)
;
}
nsMenuBarX
*
nsCocoaWindow
:
:
GetMenuBar
(
)
{
return
mMenuBar
;
}
void
nsCocoaWindow
:
:
CaptureRollupEvents
(
bool
aDoCapture
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
aDoCapture
)
{
if
(
!
NSApp
.
isActive
)
{
nsToolkit
:
:
GetToolkit
(
)
-
>
MonitorAllProcessMouseEvents
(
)
;
}
if
(
mWindowType
=
=
WindowType
:
:
Popup
)
{
SetPopupWindowLevel
(
)
;
}
}
else
{
nsToolkit
:
:
GetToolkit
(
)
-
>
StopMonitoringAllProcessMouseEvents
(
)
;
if
(
mWindow
&
&
mWindowType
=
=
WindowType
:
:
Popup
)
{
mWindow
.
level
=
NSModalPanelWindowLevel
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
GetAttention
(
int32_t
aCycleCount
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
[
NSApp
requestUserAttention
:
NSInformationalRequest
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
bool
nsCocoaWindow
:
:
HasPendingInputEvent
(
)
{
return
nsChildView
:
:
DoHasPendingInputEvent
(
)
;
}
void
nsCocoaWindow
:
:
SetWindowShadowStyle
(
WindowShadow
aStyle
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mShadowStyle
=
=
aStyle
)
{
return
;
}
mShadowStyle
=
aStyle
;
if
(
!
mWindow
|
|
mWindowType
!
=
WindowType
:
:
Popup
)
{
return
;
}
mWindow
.
shadowStyle
=
mShadowStyle
;
[
mWindow
setEffectViewWrapperForStyle
:
mShadowStyle
]
;
[
mWindow
setHasShadow
:
aStyle
!
=
WindowShadow
:
:
None
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowOpacity
(
float
aOpacity
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
[
mWindow
setAlphaValue
:
(
CGFloat
)
aOpacity
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetColorScheme
(
const
Maybe
<
ColorScheme
>
&
aScheme
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
NSAppearance
*
appearance
=
aScheme
?
NSAppearanceForColorScheme
(
*
aScheme
)
:
nil
;
if
(
mWindow
.
appearance
!
=
appearance
)
{
mWindow
.
appearance
=
appearance
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
inline
CGAffineTransform
GfxMatrixToCGAffineTransform
(
const
gfx
:
:
Matrix
&
m
)
{
CGAffineTransform
t
;
t
.
a
=
m
.
_11
;
t
.
b
=
m
.
_12
;
t
.
c
=
m
.
_21
;
t
.
d
=
m
.
_22
;
t
.
tx
=
m
.
_31
;
t
.
ty
=
m
.
_32
;
return
t
;
}
void
nsCocoaWindow
:
:
SetWindowTransform
(
const
gfx
:
:
Matrix
&
aTransform
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
if
(
!
mWindow
.
isVisible
|
|
NSIsEmptyRect
(
mWindow
.
frame
)
)
{
return
;
}
if
(
StaticPrefs
:
:
widget_window_transforms_disabled
(
)
)
{
return
;
}
gfx
:
:
Matrix
transform
=
aTransform
;
if
(
!
transform
.
Invert
(
)
)
{
transform
=
gfx
:
:
Matrix
(
)
;
}
bool
isIdentity
=
transform
.
IsIdentity
(
)
;
if
(
isIdentity
&
&
mWindowTransformIsIdentity
)
{
return
;
}
transform
.
PreTranslate
(
-
mBounds
.
x
-
mBounds
.
y
)
;
if
(
!
transform
.
HasNonTranslation
(
)
&
&
transform
.
HasNonIntegerTranslation
(
)
)
{
auto
snappedTranslation
=
gfx
:
:
IntPoint
:
:
Round
(
transform
.
GetTranslation
(
)
)
;
transform
=
gfx
:
:
Matrix
:
:
Translation
(
snappedTranslation
.
x
snappedTranslation
.
y
)
;
}
CGFloat
backingScale
=
BackingScaleFactor
(
)
;
transform
.
PreScale
(
backingScale
backingScale
)
;
transform
.
PostScale
(
1
/
backingScale
1
/
backingScale
)
;
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
CGSSetWindowTransform
(
cid
[
mWindow
windowNumber
]
GfxMatrixToCGAffineTransform
(
transform
)
)
;
mWindowTransformIsIdentity
=
isIdentity
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetInputRegion
(
const
InputRegion
&
aInputRegion
)
{
MOZ_ASSERT
(
mWindowType
=
=
WindowType
:
:
Popup
"
This
should
only
be
called
on
popup
windows
.
"
)
;
if
(
aInputRegion
.
mFullyTransparent
)
{
[
mWindow
setIgnoresMouseEvents
:
YES
]
;
}
else
{
[
mWindow
setIgnoresMouseEvents
:
NO
]
;
}
}
void
nsCocoaWindow
:
:
SetShowsToolbarButton
(
bool
aShow
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindow
)
[
mWindow
setShowsToolbarButton
:
aShow
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
GetSupportsNativeFullscreen
(
)
{
return
mWindow
.
collectionBehavior
&
NSWindowCollectionBehaviorFullScreenPrimary
;
}
void
nsCocoaWindow
:
:
SetSupportsNativeFullscreen
(
bool
aSupportsNativeFullscreen
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindow
)
{
NSWindowCollectionBehavior
newBehavior
=
[
mWindow
collectionBehavior
]
;
if
(
aSupportsNativeFullscreen
)
{
newBehavior
|
=
NSWindowCollectionBehaviorFullScreenPrimary
;
}
else
{
newBehavior
&
=
~
NSWindowCollectionBehaviorFullScreenPrimary
;
}
[
mWindow
setCollectionBehavior
:
newBehavior
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowAnimationType
(
nsIWidget
:
:
WindowAnimationType
aType
)
{
mAnimationType
=
aType
;
}
void
nsCocoaWindow
:
:
SetDrawsTitle
(
bool
aDrawTitle
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mWindow
.
wantsTitleDrawn
=
aDrawTitle
|
|
!
mWindow
.
drawsContentsIntoWindowFrame
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
SetNonClientMargins
(
const
LayoutDeviceIntMargin
&
margins
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
SetDrawsInTitlebar
(
margins
.
top
=
=
0
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsCocoaWindow
:
:
SetDrawsInTitlebar
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mWindow
)
{
[
mWindow
setDrawsContentsIntoWindowFrame
:
aState
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
SynthesizeNativeMouseEvent
(
LayoutDeviceIntPoint
aPoint
NativeMouseMessage
aNativeMessage
MouseButton
aButton
nsIWidget
:
:
Modifiers
aModifierFlags
nsIObserver
*
aObserver
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoObserverNotifier
notifier
(
aObserver
"
mouseevent
"
)
;
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
SynthesizeNativeMouseEvent
(
aPoint
aNativeMessage
aButton
aModifierFlags
nullptr
)
;
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
SynthesizeNativeMouseScrollEvent
(
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
double
aDeltaX
double
aDeltaY
double
aDeltaZ
uint32_t
aModifierFlags
uint32_t
aAdditionalFlags
nsIObserver
*
aObserver
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoObserverNotifier
notifier
(
aObserver
"
mousescrollevent
"
)
;
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
SynthesizeNativeMouseScrollEvent
(
aPoint
aNativeMessage
aDeltaX
aDeltaY
aDeltaZ
aModifierFlags
aAdditionalFlags
nullptr
)
;
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsCocoaWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
aShouldLock
)
{
[
mWindow
setContentAspectRatio
:
mWindow
.
frame
.
size
]
;
mAspectRatioLocked
=
true
;
}
else
{
[
mWindow
setResizeIncrements
:
NSMakeSize
(
1
.
0
1
.
0
)
]
;
mAspectRatioLocked
=
false
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
UpdateThemeGeometries
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
UpdateThemeGeometries
(
aThemeGeometries
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaWindow
:
:
SetPopupWindowLevel
(
)
{
if
(
!
mWindow
)
{
return
;
}
mWindow
.
level
=
NSPopUpMenuWindowLevel
;
mWindow
.
hidesOnDeactivate
=
NO
;
}
void
nsCocoaWindow
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mInputContext
=
aContext
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsCocoaWindow
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
if
(
NS_WARN_IF
(
!
nsIWidget
:
:
GetEditCommands
(
aType
aEvent
aCommands
)
)
)
{
return
false
;
}
NativeKeyBindings
*
keyBindings
=
NativeKeyBindings
:
:
GetInstance
(
aType
)
;
keyBindings
-
>
GetEditCommands
(
aEvent
Nothing
(
)
aCommands
)
;
return
true
;
}
void
nsCocoaWindow
:
:
PauseOrResumeCompositor
(
bool
aPause
)
{
if
(
auto
*
mainChildView
=
static_cast
<
nsIWidget
*
>
(
mWindow
.
mainChildView
.
widget
)
)
{
mainChildView
-
>
PauseOrResumeCompositor
(
aPause
)
;
}
}
bool
nsCocoaWindow
:
:
AsyncPanZoomEnabled
(
)
const
{
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
AsyncPanZoomEnabled
(
)
;
}
return
nsBaseWidget
:
:
AsyncPanZoomEnabled
(
)
;
}
bool
nsCocoaWindow
:
:
StartAsyncAutoscroll
(
const
ScreenPoint
&
aAnchorLocation
const
ScrollableLayerGuid
&
aGuid
)
{
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
StartAsyncAutoscroll
(
aAnchorLocation
aGuid
)
;
}
return
nsBaseWidget
:
:
StartAsyncAutoscroll
(
aAnchorLocation
aGuid
)
;
}
void
nsCocoaWindow
:
:
StopAsyncAutoscroll
(
const
ScrollableLayerGuid
&
aGuid
)
{
if
(
mPopupContentView
)
{
mPopupContentView
-
>
StopAsyncAutoscroll
(
aGuid
)
;
return
;
}
nsBaseWidget
:
:
StopAsyncAutoscroll
(
aGuid
)
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateTopLevelWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsCocoaWindow
(
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateChildWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsChildView
(
)
;
return
window
.
forget
(
)
;
}
implementation
WindowDelegate
+
(
void
)
paintMenubarForWindow
:
(
NSWindow
*
)
aWindow
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
id
windowDelegate
=
[
aWindow
delegate
]
;
if
(
[
windowDelegate
class
]
!
=
[
self
class
]
)
return
;
nsCocoaWindow
*
geckoWidget
=
[
windowDelegate
geckoWidget
]
;
NS_ASSERTION
(
geckoWidget
"
Window
delegate
not
returning
a
gecko
widget
!
"
)
;
if
(
nsMenuBarX
*
geckoMenuBar
=
geckoWidget
-
>
GetMenuBar
(
)
)
{
geckoMenuBar
-
>
Paint
(
)
;
}
else
{
if
(
!
sApplicationMenu
)
{
return
;
}
NSMenu
*
mainMenu
=
NSApp
.
mainMenu
;
NS_ASSERTION
(
mainMenu
.
numberOfItems
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
GeckoNSMenu
*
newMenuBar
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
"
MainMenuBar
"
]
;
NSMenuItem
*
firstMenuItem
=
[
[
mainMenu
itemAtIndex
:
0
]
retain
]
;
[
mainMenu
removeItemAtIndex
:
0
]
;
[
newMenuBar
insertItem
:
firstMenuItem
atIndex
:
0
]
;
[
firstMenuItem
release
]
;
NSApp
.
mainMenu
=
newMenuBar
;
[
newMenuBar
release
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
id
)
initWithGeckoWindow
:
(
nsCocoaWindow
*
)
geckoWind
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
[
super
init
]
;
mGeckoWindow
=
geckoWind
;
mToplevelActiveState
=
false
;
mHasEverBeenZoomed
=
false
;
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
NSSize
)
windowWillResize
:
(
NSWindow
*
)
sender
toSize
:
(
NSSize
)
proposedFrameSize
{
RollUpPopups
(
)
;
return
proposedFrameSize
;
}
-
(
NSRect
)
windowWillUseStandardFrame
:
(
NSWindow
*
)
window
defaultFrame
:
(
NSRect
)
newFrame
{
return
window
.
screen
.
frame
;
}
void
nsCocoaWindow
:
:
CocoaSendToplevelActivateEvents
(
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowActivated
(
)
;
}
}
void
nsCocoaWindow
:
:
CocoaSendToplevelDeactivateEvents
(
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowDeactivated
(
)
;
}
}
void
nsCocoaWindow
:
:
CocoaWindowDidResize
(
)
{
UpdateBounds
(
)
;
if
(
HandleUpdateFullscreenOnResize
(
)
)
{
ReportSizeEvent
(
)
;
return
;
}
DispatchSizeModeEvent
(
)
;
ReportSizeEvent
(
)
;
}
-
(
void
)
windowDidResize
:
(
NSNotification
*
)
aNotification
{
BaseWindow
*
window
=
[
aNotification
object
]
;
[
window
updateTrackingArea
]
;
if
(
!
mGeckoWindow
)
return
;
mGeckoWindow
-
>
CocoaWindowDidResize
(
)
;
}
-
(
void
)
windowDidChangeScreen
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
return
;
NSWindow
*
window
=
(
NSWindow
*
)
[
aNotification
object
]
;
if
(
[
window
respondsToSelector
:
selector
(
backingScaleFactor
)
]
)
{
if
(
GetBackingScaleFactor
(
window
)
!
=
mGeckoWindow
-
>
BackingScaleFactor
(
)
)
{
mGeckoWindow
-
>
BackingScaleFactorChanged
(
)
;
}
}
mGeckoWindow
-
>
ReportMoveEvent
(
)
;
}
-
(
void
)
windowWillEnterFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowWillEnterFullscreen
(
true
)
;
}
-
(
void
)
windowDidEnterFullScreen
:
(
NSNotification
*
)
notification
{
NSWindow
*
window
=
notification
.
object
;
NSView
*
frameView
=
window
.
contentView
.
superview
;
NSView
*
titlebarView
=
nil
;
NSView
*
titlebarContainerView
=
nil
;
if
(
[
frameView
respondsToSelector
:
selector
(
titlebarView
)
]
)
{
titlebarView
=
[
frameView
titlebarView
]
;
}
if
(
[
frameView
respondsToSelector
:
selector
(
titlebarContainerView
)
]
)
{
titlebarContainerView
=
[
frameView
titlebarContainerView
]
;
}
if
(
[
titlebarView
respondsToSelector
:
selector
(
setTransparent
:
)
]
)
{
[
titlebarView
setTransparent
:
NO
]
;
}
if
(
[
titlebarContainerView
respondsToSelector
:
selector
(
setTransparent
:
)
]
)
{
[
titlebarContainerView
setTransparent
:
NO
]
;
}
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowDidEnterFullscreen
(
true
)
;
}
-
(
void
)
windowWillExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowWillEnterFullscreen
(
false
)
;
}
-
(
void
)
windowDidExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
CocoaWindowDidEnterFullscreen
(
false
)
;
}
-
(
void
)
windowDidBecomeMain
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
NSApp
.
_isRunningAppModal
)
{
return
;
}
NSWindow
*
window
=
aNotification
.
object
;
if
(
window
)
{
[
WindowDelegate
paintMenubarForWindow
:
window
]
;
}
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
[
(
ToolbarWindow
*
)
window
windowMainStateChanged
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowDidResignMain
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
[
NSApp
_isRunningAppModal
]
)
return
;
RefPtr
<
nsMenuBarX
>
hiddenWindowMenuBar
=
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
;
if
(
hiddenWindowMenuBar
)
{
hiddenWindowMenuBar
-
>
Paint
(
)
;
}
NSWindow
*
window
=
[
aNotification
object
]
;
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
[
(
ToolbarWindow
*
)
window
windowMainStateChanged
]
;
}
}
-
(
void
)
windowDidBecomeKey
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
NSWindow
*
window
=
[
aNotification
object
]
;
auto
*
mainChildView
=
static_cast
<
nsChildView
*
>
(
[
[
(
BaseWindow
*
)
window
mainChildView
]
widget
]
)
;
if
(
mainChildView
)
{
if
(
mainChildView
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowDidResignKey
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
nsIRollupListener
:
:
AllowAnimations
:
:
No
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowWillMove
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowDidMove
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
mGeckoWindow
-
>
ReportMoveEvent
(
)
;
}
-
(
BOOL
)
windowShouldClose
:
(
id
)
sender
{
nsIWidgetListener
*
listener
=
mGeckoWindow
?
mGeckoWindow
-
>
GetWidgetListener
(
)
:
nullptr
;
if
(
listener
)
listener
-
>
RequestWindowClose
(
mGeckoWindow
)
;
return
NO
;
}
-
(
void
)
windowWillClose
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowWillMiniaturize
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowDidMiniaturize
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
FinishCurrentTransitionIfMatching
(
nsCocoaWindow
:
:
TransitionType
:
:
Miniaturize
)
;
}
-
(
void
)
windowDidDeminiaturize
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
FinishCurrentTransitionIfMatching
(
nsCocoaWindow
:
:
TransitionType
:
:
Deminiaturize
)
;
}
-
(
BOOL
)
windowShouldZoom
:
(
NSWindow
*
)
window
toFrame
:
(
NSRect
)
proposedFrame
{
if
(
!
mHasEverBeenZoomed
&
&
window
.
isZoomed
)
{
return
NO
;
}
mHasEverBeenZoomed
=
YES
;
return
YES
;
}
-
(
void
)
windowDidChangeBackingProperties
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSWindow
*
window
=
(
NSWindow
*
)
[
aNotification
object
]
;
if
(
[
window
respondsToSelector
:
selector
(
backingScaleFactor
)
]
)
{
CGFloat
oldFactor
=
[
[
[
aNotification
userInfo
]
objectForKey
:
"
NSBackingPropertyOldScaleFactorKey
"
]
doubleValue
]
;
if
(
window
.
backingScaleFactor
!
=
oldFactor
)
{
mGeckoWindow
-
>
BackingScaleFactorChanged
(
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
windowDidChangeOcclusionState
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
{
mGeckoWindow
-
>
DispatchOcclusionEvent
(
)
;
}
}
-
(
nsCocoaWindow
*
)
geckoWidget
{
return
mGeckoWindow
;
}
-
(
bool
)
toplevelActiveState
{
return
mToplevelActiveState
;
}
-
(
void
)
sendToplevelActivateEvents
{
if
(
!
mToplevelActiveState
&
&
mGeckoWindow
)
{
mGeckoWindow
-
>
CocoaSendToplevelActivateEvents
(
)
;
mToplevelActiveState
=
true
;
}
}
-
(
void
)
sendToplevelDeactivateEvents
{
if
(
mToplevelActiveState
&
&
mGeckoWindow
)
{
mGeckoWindow
-
>
CocoaSendToplevelDeactivateEvents
(
)
;
mToplevelActiveState
=
false
;
}
}
end
interface
NSView
(
FrameViewMethodSwizzling
)
-
(
NSPoint
)
FrameView__closeButtonOrigin
;
-
(
CGFloat
)
FrameView__titlebarHeight
;
end
implementation
NSView
(
FrameViewMethodSwizzling
)
-
(
NSPoint
)
FrameView__closeButtonOrigin
{
if
(
!
[
self
.
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
return
self
.
FrameView__closeButtonOrigin
;
}
auto
*
win
=
static_cast
<
ToolbarWindow
*
>
(
self
.
window
)
;
if
(
win
.
drawsContentsIntoWindowFrame
&
&
!
win
.
wantsTitleDrawn
&
&
!
(
win
.
styleMask
&
NSWindowStyleMaskFullScreen
)
&
&
(
win
.
styleMask
&
NSWindowStyleMaskTitled
)
)
{
const
NSRect
buttonsRect
=
win
.
windowButtonsRect
;
if
(
NSIsEmptyRect
(
buttonsRect
)
)
{
return
NSMakePoint
(
buttonsRect
.
origin
.
x
win
.
frame
.
size
.
height
)
;
}
if
(
win
.
windowTitlebarLayoutDirection
=
=
NSUserInterfaceLayoutDirectionRightToLeft
)
{
return
NSMakePoint
(
buttonsRect
.
origin
.
x
+
40
.
0f
buttonsRect
.
origin
.
y
)
;
}
return
buttonsRect
.
origin
;
}
return
self
.
FrameView__closeButtonOrigin
;
}
-
(
CGFloat
)
FrameView__titlebarHeight
{
CGFloat
height
=
[
self
FrameView__titlebarHeight
]
;
if
(
[
self
.
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
auto
*
win
=
static_cast
<
ToolbarWindow
*
>
(
self
.
window
)
;
CGFloat
frameHeight
=
self
.
frame
.
size
.
height
;
CGFloat
windowButtonY
=
frameHeight
;
if
(
!
NSIsEmptyRect
(
win
.
windowButtonsRect
)
&
&
win
.
drawsContentsIntoWindowFrame
&
&
!
(
win
.
styleMask
&
NSWindowStyleMaskFullScreen
)
&
&
(
win
.
styleMask
&
NSWindowStyleMaskTitled
)
)
{
windowButtonY
=
win
.
windowButtonsRect
.
origin
.
y
;
}
height
=
std
:
:
max
(
height
frameHeight
-
windowButtonY
)
;
}
return
height
;
}
end
static
NSMutableSet
*
gSwizzledFrameViewClasses
=
nil
;
interface
NSWindow
(
PrivateSetNeedsDisplayInRectMethod
)
-
(
void
)
_setNeedsDisplayInRect
:
(
NSRect
)
aRect
;
end
interface
BaseWindow
(
Private
)
-
(
void
)
removeTrackingArea
;
-
(
void
)
cursorUpdated
:
(
NSEvent
*
)
aEvent
;
-
(
void
)
reflowTitlebarElements
;
end
implementation
BaseWindow
+
(
Class
)
frameViewClassForStyleMask
:
(
NSUInteger
)
styleMask
{
Class
frameViewClass
=
[
super
frameViewClassForStyleMask
:
styleMask
]
;
if
(
!
gSwizzledFrameViewClasses
)
{
gSwizzledFrameViewClasses
=
[
[
NSMutableSet
setWithCapacity
:
3
]
retain
]
;
if
(
!
gSwizzledFrameViewClasses
)
{
return
frameViewClass
;
}
}
static
IMP
our_closeButtonOrigin
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__closeButtonOrigin
)
)
;
static
IMP
our_titlebarHeight
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__titlebarHeight
)
)
;
if
(
!
[
gSwizzledFrameViewClasses
containsObject
:
frameViewClass
]
)
{
IMP
_closeButtonOrigin
=
class_getMethodImplementation
(
frameViewClass
selector
(
_closeButtonOrigin
)
)
;
if
(
_closeButtonOrigin
&
&
_closeButtonOrigin
!
=
our_closeButtonOrigin
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_closeButtonOrigin
)
selector
(
FrameView__closeButtonOrigin
)
)
;
}
IMP
_titlebarHeight
=
class_getMethodImplementation
(
frameViewClass
selector
(
_titlebarHeight
)
)
;
if
(
_titlebarHeight
&
&
_titlebarHeight
!
=
our_titlebarHeight
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_titlebarHeight
)
selector
(
FrameView__titlebarHeight
)
)
;
}
[
gSwizzledFrameViewClasses
addObject
:
frameViewClass
]
;
}
return
frameViewClass
;
}
-
(
id
)
initWithContentRect
:
(
NSRect
)
aContentRect
styleMask
:
(
NSUInteger
)
aStyle
backing
:
(
NSBackingStoreType
)
aBufferingType
defer
:
(
BOOL
)
aFlag
{
mDrawsIntoWindowFrame
=
NO
;
[
super
initWithContentRect
:
aContentRect
styleMask
:
aStyle
backing
:
aBufferingType
defer
:
aFlag
]
;
mState
=
nil
;
mDisabledNeedsDisplay
=
NO
;
mTrackingArea
=
nil
;
mDirtyRect
=
NSZeroRect
;
mBeingShown
=
NO
;
mDrawTitle
=
NO
;
mTouchBar
=
nil
;
mIsAnimationSuppressed
=
NO
;
[
self
updateTrackingArea
]
;
return
self
;
}
static
NSImage
*
GetMenuMaskImage
(
)
{
const
CGFloat
radius
=
6
.
0f
;
const
NSSize
maskSize
=
{
radius
*
3
.
0f
radius
*
3
.
0f
}
;
NSImage
*
maskImage
=
[
NSImage
imageWithSize
:
maskSize
flipped
:
FALSE
drawingHandler
:
^
BOOL
(
NSRect
dstRect
)
{
NSBezierPath
*
path
=
[
NSBezierPath
bezierPathWithRoundedRect
:
dstRect
xRadius
:
radius
yRadius
:
radius
]
;
[
NSColor
.
blackColor
set
]
;
[
path
fill
]
;
return
YES
;
}
]
;
maskImage
.
capInsets
=
NSEdgeInsetsMake
(
radius
radius
radius
radius
)
;
return
maskImage
;
}
-
(
void
)
setEffectViewWrapperForStyle
:
(
WindowShadow
)
aStyle
{
NSView
*
wrapper
=
[
&
]
(
)
-
>
NSView
*
{
if
(
aStyle
=
=
WindowShadow
:
:
Menu
|
|
aStyle
=
=
WindowShadow
:
:
Tooltip
)
{
const
bool
isMenu
=
aStyle
=
=
WindowShadow
:
:
Menu
;
auto
*
effectView
=
[
[
NSVisualEffectView
alloc
]
initWithFrame
:
self
.
contentView
.
frame
]
;
effectView
.
material
=
isMenu
?
NSVisualEffectMaterialMenu
:
NSVisualEffectMaterialToolTip
;
effectView
.
state
=
NSVisualEffectStateActive
;
effectView
.
blendingMode
=
NSVisualEffectBlendingModeBehindWindow
;
if
(
isMenu
)
{
effectView
.
maskImage
=
GetMenuMaskImage
(
)
;
}
return
effectView
;
}
return
[
[
NSView
alloc
]
initWithFrame
:
self
.
contentView
.
frame
]
;
}
(
)
;
wrapper
.
wantsLayer
=
YES
;
NSView
*
childView
=
[
self
.
mainChildView
retain
]
;
[
childView
removeFromSuperview
]
;
[
wrapper
addSubview
:
childView
]
;
[
childView
release
]
;
super
.
contentView
=
wrapper
;
[
wrapper
release
]
;
}
-
(
NSTouchBar
*
)
makeTouchBar
{
mTouchBar
=
[
[
nsTouchBar
alloc
]
init
]
;
if
(
mTouchBar
)
{
sTouchBarIsInitialized
=
YES
;
}
return
mTouchBar
;
}
-
(
void
)
setBeingShown
:
(
BOOL
)
aValue
{
mBeingShown
=
aValue
;
}
-
(
BOOL
)
isBeingShown
{
return
mBeingShown
;
}
-
(
BOOL
)
isVisibleOrBeingShown
{
return
[
super
isVisible
]
|
|
mBeingShown
;
}
-
(
void
)
setIsAnimationSuppressed
:
(
BOOL
)
aValue
{
mIsAnimationSuppressed
=
aValue
;
}
-
(
BOOL
)
isAnimationSuppressed
{
return
mIsAnimationSuppressed
;
}
-
(
void
)
disableSetNeedsDisplay
{
mDisabledNeedsDisplay
=
YES
;
}
-
(
void
)
enableSetNeedsDisplay
{
mDisabledNeedsDisplay
=
NO
;
}
-
(
void
)
dealloc
{
[
mTouchBar
release
]
;
[
self
removeTrackingArea
]
;
ChildViewMouseTracker
:
:
OnDestroyWindow
(
self
)
;
[
super
dealloc
]
;
}
static
const
NSString
*
kStateTitleKey
=
"
title
"
;
static
const
NSString
*
kStateDrawsContentsIntoWindowFrameKey
=
"
drawsContentsIntoWindowFrame
"
;
static
const
NSString
*
kStateShowsToolbarButton
=
"
showsToolbarButton
"
;
static
const
NSString
*
kStateCollectionBehavior
=
"
collectionBehavior
"
;
static
const
NSString
*
kStateWantsTitleDrawn
=
"
wantsTitleDrawn
"
;
-
(
void
)
importState
:
(
NSDictionary
*
)
aState
{
if
(
NSString
*
title
=
[
aState
objectForKey
:
kStateTitleKey
]
)
{
[
self
setTitle
:
title
]
;
}
[
self
setDrawsContentsIntoWindowFrame
:
[
[
aState
objectForKey
:
kStateDrawsContentsIntoWindowFrameKey
]
boolValue
]
]
;
[
self
setShowsToolbarButton
:
[
[
aState
objectForKey
:
kStateShowsToolbarButton
]
boolValue
]
]
;
[
self
setCollectionBehavior
:
[
[
aState
objectForKey
:
kStateCollectionBehavior
]
unsignedIntValue
]
]
;
[
self
setWantsTitleDrawn
:
[
[
aState
objectForKey
:
kStateWantsTitleDrawn
]
boolValue
]
]
;
}
-
(
NSMutableDictionary
*
)
exportState
{
NSMutableDictionary
*
state
=
[
NSMutableDictionary
dictionaryWithCapacity
:
10
]
;
if
(
NSString
*
title
=
self
.
title
)
{
[
state
setObject
:
title
forKey
:
kStateTitleKey
]
;
}
[
state
setObject
:
[
NSNumber
numberWithBool
:
self
.
drawsContentsIntoWindowFrame
]
forKey
:
kStateDrawsContentsIntoWindowFrameKey
]
;
[
state
setObject
:
[
NSNumber
numberWithBool
:
self
.
showsToolbarButton
]
forKey
:
kStateShowsToolbarButton
]
;
[
state
setObject
:
[
NSNumber
numberWithUnsignedInt
:
self
.
collectionBehavior
]
forKey
:
kStateCollectionBehavior
]
;
[
state
setObject
:
[
NSNumber
numberWithBool
:
self
.
wantsTitleDrawn
]
forKey
:
kStateWantsTitleDrawn
]
;
return
state
;
}
-
(
void
)
setDrawsContentsIntoWindowFrame
:
(
BOOL
)
aState
{
bool
changed
=
aState
!
=
mDrawsIntoWindowFrame
;
mDrawsIntoWindowFrame
=
aState
;
if
(
changed
)
{
[
self
reflowTitlebarElements
]
;
}
}
-
(
BOOL
)
drawsContentsIntoWindowFrame
{
return
mDrawsIntoWindowFrame
;
}
-
(
NSRect
)
childViewRectForFrameRect
:
(
NSRect
)
aFrameRect
{
if
(
mDrawsIntoWindowFrame
)
{
return
aFrameRect
;
}
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSWindowStyleMaskFullSizeContentView
;
return
[
NSWindow
contentRectForFrameRect
:
aFrameRect
styleMask
:
styleMask
]
;
}
-
(
NSRect
)
frameRectForChildViewRect
:
(
NSRect
)
aChildViewRect
{
if
(
mDrawsIntoWindowFrame
)
{
return
aChildViewRect
;
}
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSWindowStyleMaskFullSizeContentView
;
return
[
NSWindow
frameRectForContentRect
:
aChildViewRect
styleMask
:
styleMask
]
;
}
-
(
NSTimeInterval
)
animationResizeTime
:
(
NSRect
)
newFrame
{
if
(
mIsAnimationSuppressed
)
{
return
0
.
0
;
}
return
[
super
animationResizeTime
:
newFrame
]
;
}
-
(
void
)
setWantsTitleDrawn
:
(
BOOL
)
aDrawTitle
{
mDrawTitle
=
aDrawTitle
;
[
self
setTitleVisibility
:
mDrawTitle
?
NSWindowTitleVisible
:
NSWindowTitleHidden
]
;
}
-
(
BOOL
)
wantsTitleDrawn
{
return
mDrawTitle
;
}
-
(
NSView
*
)
trackingAreaView
{
NSView
*
contentView
=
self
.
contentView
;
return
contentView
.
superview
?
contentView
.
superview
:
contentView
;
}
-
(
NSArray
<
NSView
*
>
*
)
contentViewContents
{
return
[
[
self
.
contentView
.
subviews
copy
]
autorelease
]
;
}
-
(
ChildView
*
)
mainChildView
{
NSView
*
contentView
=
self
.
contentView
;
NSView
*
lastView
=
contentView
.
subviews
.
lastObject
;
if
(
[
lastView
isKindOfClass
:
[
ChildView
class
]
]
)
{
return
(
ChildView
*
)
lastView
;
}
return
nil
;
}
-
(
void
)
removeTrackingArea
{
if
(
mTrackingArea
)
{
[
self
.
trackingAreaView
removeTrackingArea
:
mTrackingArea
]
;
[
mTrackingArea
release
]
;
mTrackingArea
=
nil
;
}
}
-
(
void
)
updateTrackingArea
{
[
self
removeTrackingArea
]
;
NSView
*
view
=
self
.
trackingAreaView
;
const
NSTrackingAreaOptions
options
=
NSTrackingMouseEnteredAndExited
|
NSTrackingMouseMoved
|
NSTrackingActiveAlways
;
mTrackingArea
=
[
[
NSTrackingArea
alloc
]
initWithRect
:
[
view
bounds
]
options
:
options
owner
:
self
userInfo
:
nil
]
;
[
view
addTrackingArea
:
mTrackingArea
]
;
}
-
(
void
)
mouseEntered
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseEnteredWindow
(
aEvent
)
;
}
-
(
void
)
mouseExited
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseExitedWindow
(
aEvent
)
;
}
-
(
void
)
mouseMoved
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseMoved
(
aEvent
)
;
}
-
(
void
)
cursorUpdated
:
(
NSEvent
*
)
aEvent
{
}
-
(
void
)
_setNeedsDisplayInRect
:
(
NSRect
)
aRect
{
if
(
!
mDisabledNeedsDisplay
)
{
[
super
_setNeedsDisplayInRect
:
aRect
]
;
mDirtyRect
=
NSUnionRect
(
mDirtyRect
aRect
)
;
}
}
-
(
NSRect
)
getAndResetNativeDirtyRect
{
NSRect
dirtyRect
=
mDirtyRect
;
mDirtyRect
=
NSZeroRect
;
return
dirtyRect
;
}
-
(
void
)
reflowTitlebarElements
{
NSView
*
frameView
=
self
.
contentView
.
superview
;
if
(
[
frameView
respondsToSelector
:
selector
(
_tileTitlebarAndRedisplay
:
)
]
)
{
[
frameView
_tileTitlebarAndRedisplay
:
NO
]
;
}
}
-
(
BOOL
)
respondsToSelector
:
(
SEL
)
aSelector
{
if
(
aSelector
=
=
selector
(
cancelOperation
:
)
)
{
return
NO
;
}
return
[
super
respondsToSelector
:
aSelector
]
;
}
-
(
void
)
doCommandBySelector
:
(
SEL
)
aSelector
{
[
self
tryToPerform
:
aSelector
with
:
nil
]
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
id
retval
=
[
super
accessibilityAttributeValue
:
attribute
]
;
if
(
[
retval
isKindOfClass
:
[
NSArray
class
]
]
&
&
[
attribute
isEqualToString
:
"
AXChildren
"
]
)
{
NSMutableArray
*
holder
=
[
NSMutableArray
arrayWithCapacity
:
10
]
;
[
holder
addObjectsFromArray
:
(
NSArray
*
)
retval
]
;
NSUInteger
count
=
[
holder
count
]
;
for
(
NSInteger
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
id
item
=
[
holder
objectAtIndex
:
i
]
;
if
(
!
[
item
isKindOfClass
:
[
NSButtonCell
class
]
]
&
&
!
[
item
respondsToSelector
:
selector
(
hasRepresentedView
)
]
)
{
[
holder
removeObjectAtIndex
:
i
]
;
}
}
retval
=
[
NSArray
arrayWithArray
:
holder
]
;
}
return
retval
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
releaseJSObjects
{
[
mTouchBar
releaseJSObjects
]
;
}
end
interface
MOZTitlebarAccessoryView
:
NSView
end
implementation
MOZTitlebarAccessoryView
:
NSView
-
(
void
)
viewWillMoveToWindow
:
(
NSWindow
*
)
aWindow
{
if
(
aWindow
)
{
if
(
available
(
macOS
11
.
0
*
)
)
{
aWindow
.
titlebarSeparatorStyle
=
NSTitlebarSeparatorStyleNone
;
}
}
}
end
implementation
FullscreenTitlebarTracker
-
(
FullscreenTitlebarTracker
*
)
init
{
[
super
init
]
;
self
.
hidden
=
YES
;
return
self
;
}
-
(
void
)
loadView
{
self
.
view
=
[
[
[
MOZTitlebarAccessoryView
alloc
]
initWithFrame
:
NSZeroRect
]
autorelease
]
;
}
end
static
bool
MaybeDropEventForModalWindow
(
NSEvent
*
aEvent
id
aDelegate
)
{
if
(
!
sModalWindowCount
)
{
return
false
;
}
NSEventType
type
=
[
aEvent
type
]
;
switch
(
type
)
{
case
NSEventTypeScrollWheel
:
case
NSEventTypeLeftMouseDown
:
case
NSEventTypeLeftMouseUp
:
case
NSEventTypeRightMouseDown
:
case
NSEventTypeRightMouseUp
:
case
NSEventTypeOtherMouseDown
:
case
NSEventTypeOtherMouseUp
:
case
NSEventTypeMouseMoved
:
case
NSEventTypeLeftMouseDragged
:
case
NSEventTypeRightMouseDragged
:
case
NSEventTypeOtherMouseDragged
:
break
;
default
:
return
false
;
}
if
(
aDelegate
&
&
[
aDelegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
if
(
nsCocoaWindow
*
widget
=
[
(
WindowDelegate
*
)
aDelegate
geckoWidget
]
)
{
if
(
!
widget
-
>
IsModal
(
)
|
|
widget
-
>
HasModalDescendants
(
)
)
{
return
true
;
}
}
}
return
false
;
}
implementation
ToolbarWindow
-
(
id
)
initWithContentRect
:
(
NSRect
)
aChildViewRect
styleMask
:
(
NSUInteger
)
aStyle
backing
:
(
NSBackingStoreType
)
aBufferingType
defer
:
(
BOOL
)
aFlag
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSRect
frameRect
=
[
NSWindow
frameRectForContentRect
:
aChildViewRect
styleMask
:
aStyle
]
;
aStyle
|
=
NSWindowStyleMaskFullSizeContentView
;
NSRect
contentRect
=
frameRect
;
if
(
(
self
=
[
super
initWithContentRect
:
contentRect
styleMask
:
aStyle
backing
:
aBufferingType
defer
:
aFlag
]
)
)
{
mWindowButtonsRect
=
NSZeroRect
;
self
.
titlebarAppearsTransparent
=
YES
;
if
(
available
(
macOS
11
.
0
*
)
)
{
self
.
titlebarSeparatorStyle
=
NSTitlebarSeparatorStyleNone
;
}
mFullscreenTitlebarTracker
=
[
[
FullscreenTitlebarTracker
alloc
]
init
]
;
[
mFullscreenTitlebarTracker
addObserver
:
self
forKeyPath
:
"
revealAmount
"
options
:
NSKeyValueObservingOptionNew
context
:
nil
]
;
[
(
NSWindow
*
)
self
addTitlebarAccessoryViewController
:
mFullscreenTitlebarTracker
]
;
}
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
observeValueForKeyPath
:
(
NSString
*
)
keyPath
ofObject
:
(
id
)
object
change
:
(
NSDictionary
<
NSKeyValueChangeKey
id
>
*
)
change
context
:
(
void
*
)
context
{
if
(
[
keyPath
isEqualToString
:
"
revealAmount
"
]
)
{
[
[
self
mainChildView
]
ensureNextCompositeIsAtomicWithMainThreadPaint
]
;
NSNumber
*
revealAmount
=
(
change
[
NSKeyValueChangeNewKey
]
)
;
[
self
updateTitlebarShownAmount
:
[
revealAmount
doubleValue
]
]
;
}
else
{
[
super
observeValueForKeyPath
:
keyPath
ofObject
:
object
change
:
change
context
:
context
]
;
}
}
static
bool
ScreenHasNotch
(
nsCocoaWindow
*
aGeckoWindow
)
{
if
(
available
(
macOS
12
.
0
*
)
)
{
nsCOMPtr
<
nsIScreen
>
widgetScreen
=
aGeckoWindow
-
>
GetWidgetScreen
(
)
;
NSScreen
*
cocoaScreen
=
ScreenHelperCocoa
:
:
CocoaScreenForScreen
(
widgetScreen
)
;
return
cocoaScreen
.
safeAreaInsets
.
top
!
=
0
.
0f
;
}
return
false
;
}
static
bool
ShouldShiftByMenubarHeightInFullscreen
(
nsCocoaWindow
*
aWindow
)
{
switch
(
StaticPrefs
:
:
widget_macos_shift_by_menubar_on_fullscreen
(
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
break
;
}
return
!
ScreenHasNotch
(
aWindow
)
;
}
-
(
void
)
updateTitlebarShownAmount
:
(
CGFloat
)
aShownAmount
{
if
(
!
(
self
.
styleMask
&
NSWindowStyleMaskFullScreen
)
)
{
return
;
}
CGFloat
menuBarHeight
=
NSApp
.
mainMenu
.
menuBarHeight
;
if
(
menuBarHeight
>
0
.
0f
)
{
mMenuBarHeight
=
menuBarHeight
;
}
if
(
[
[
self
delegate
]
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
WindowDelegate
*
windowDelegate
=
(
WindowDelegate
*
)
[
self
delegate
]
;
nsCocoaWindow
*
geckoWindow
=
[
windowDelegate
geckoWidget
]
;
if
(
!
geckoWindow
)
{
return
;
}
if
(
nsIWidgetListener
*
listener
=
geckoWindow
-
>
GetWidgetListener
(
)
)
{
CGFloat
shiftByPixels
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
MacTitlebarHeight
)
*
aShownAmount
;
if
(
ShouldShiftByMenubarHeightInFullscreen
(
geckoWindow
)
)
{
shiftByPixels
+
=
mMenuBarHeight
*
aShownAmount
;
}
listener
-
>
MacFullscreenMenubarOverlapChanged
(
DesktopCoord
(
shiftByPixels
)
)
;
}
}
}
-
(
void
)
dealloc
{
[
mFullscreenTitlebarTracker
removeObserver
:
self
forKeyPath
:
"
revealAmount
"
]
;
[
mFullscreenTitlebarTracker
removeFromParentViewController
]
;
[
mFullscreenTitlebarTracker
release
]
;
[
super
dealloc
]
;
}
-
(
NSArray
<
NSView
*
>
*
)
contentViewContents
{
return
[
[
self
.
contentView
.
subviews
copy
]
autorelease
]
;
}
-
(
void
)
windowMainStateChanged
{
[
[
self
mainChildView
]
ensureNextCompositeIsAtomicWithMainThreadPaint
]
;
}
-
(
void
)
setDrawsContentsIntoWindowFrame
:
(
BOOL
)
aState
{
BOOL
stateChanged
=
self
.
drawsContentsIntoWindowFrame
!
=
aState
;
[
super
setDrawsContentsIntoWindowFrame
:
aState
]
;
if
(
stateChanged
&
&
[
self
.
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
auto
*
windowDelegate
=
static_cast
<
WindowDelegate
*
>
(
self
.
delegate
)
;
if
(
nsCocoaWindow
*
geckoWindow
=
windowDelegate
.
geckoWidget
)
{
geckoWindow
-
>
ReportSizeEvent
(
)
;
}
ChildViewMouseTracker
:
:
ResendLastMouseMoveEvent
(
)
;
}
}
-
(
void
)
placeWindowButtons
:
(
NSRect
)
aRect
{
if
(
!
NSEqualRects
(
mWindowButtonsRect
aRect
)
)
{
mWindowButtonsRect
=
aRect
;
[
self
reflowTitlebarElements
]
;
}
}
-
(
NSRect
)
windowButtonsRect
{
return
mWindowButtonsRect
;
}
-
(
BOOL
)
_hasToolbar
{
return
YES
;
}
-
(
void
)
_toolbarPillButtonClicked
:
(
id
)
sender
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
RollUpPopups
(
)
;
if
(
[
self
.
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
auto
*
windowDelegate
=
static_cast
<
WindowDelegate
*
>
(
self
.
delegate
)
;
nsCocoaWindow
*
geckoWindow
=
windowDelegate
.
geckoWidget
;
if
(
!
geckoWindow
)
{
return
;
}
if
(
nsIWidgetListener
*
listener
=
geckoWindow
-
>
GetWidgetListener
(
)
)
{
listener
-
>
OSToolbarButtonPressed
(
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSWindow
*
nativeWindow
=
[
self
retain
]
;
BOOL
retval
=
[
super
performKeyEquivalent
:
theEvent
]
;
[
nativeWindow
release
]
;
return
retval
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
if
(
MaybeDropEventForModalWindow
(
anEvent
self
.
delegate
)
)
{
return
;
}
[
super
sendEvent
:
anEvent
]
;
}
end
implementation
PopupWindow
-
(
id
)
initWithContentRect
:
(
NSRect
)
contentRect
styleMask
:
(
NSUInteger
)
styleMask
backing
:
(
NSBackingStoreType
)
bufferingType
defer
:
(
BOOL
)
deferCreation
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
mIsContextMenu
=
false
;
return
[
super
initWithContentRect
:
contentRect
styleMask
:
styleMask
backing
:
bufferingType
defer
:
deferCreation
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
CGFloat
)
_backdropBleedAmount
{
return
0
.
0
;
}
static
const
NSUInteger
kWindowShadowOptionsNoShadow
=
0
;
static
const
NSUInteger
kWindowShadowOptionsMenu
=
2
;
static
const
NSUInteger
kWindowShadowOptionsTooltip
=
4
;
-
(
NSDictionary
*
)
shadowParameters
{
NSDictionary
*
parent
=
[
super
shadowParameters
]
;
if
(
self
.
shadowStyle
!
=
WindowShadow
:
:
Panel
)
{
return
parent
;
}
NSMutableDictionary
*
copy
=
[
parent
mutableCopy
]
;
for
(
auto
*
key
:
{
"
com
.
apple
.
WindowShadowRimDensityActive
"
"
com
.
apple
.
WindowShadowRimDensityInactive
"
}
)
{
if
(
[
parent
objectForKey
:
key
]
!
=
nil
)
{
[
copy
setValue
:
(
0
)
forKey
:
key
]
;
}
}
return
copy
;
}
-
(
NSUInteger
)
shadowOptions
{
if
(
!
self
.
hasShadow
)
{
return
kWindowShadowOptionsNoShadow
;
}
switch
(
self
.
shadowStyle
)
{
case
WindowShadow
:
:
None
:
return
kWindowShadowOptionsNoShadow
;
case
WindowShadow
:
:
Menu
:
case
WindowShadow
:
:
Panel
:
return
kWindowShadowOptionsMenu
;
case
WindowShadow
:
:
Tooltip
:
return
kWindowShadowOptionsTooltip
;
}
}
-
(
BOOL
)
isContextMenu
{
return
mIsContextMenu
;
}
-
(
void
)
setIsContextMenu
:
(
BOOL
)
flag
{
mIsContextMenu
=
flag
;
}
-
(
BOOL
)
canBecomeMainWindow
{
return
NO
;
}
end
implementation
BorderlessWindow
-
(
BOOL
)
canBecomeKeyWindow
{
return
YES
;
}
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
if
(
MaybeDropEventForModalWindow
(
anEvent
self
.
delegate
)
)
{
return
;
}
[
super
sendEvent
:
anEvent
]
;
}
-
(
BOOL
)
canBecomeMainWindow
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
self
.
isVisible
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSWindow
*
nativeWindow
=
[
self
retain
]
;
BOOL
retval
=
[
super
performKeyEquivalent
:
theEvent
]
;
[
nativeWindow
release
]
;
return
retval
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
end
