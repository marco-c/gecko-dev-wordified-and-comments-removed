#
include
"
nsCocoaWindow
.
h
"
#
include
"
NativeKeyBindings
.
h
"
#
include
"
ScreenHelperCocoa
.
h
"
#
include
"
TextInputHandler
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsWindowMap
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsTouchBarNativeAPIDefines
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsNativeThemeColors
.
h
"
#
include
"
nsNativeThemeCocoa
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
VibrancyManager
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
qcms
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
namespace
layers
{
class
LayerManager
;
}
}
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
;
int32_t
gXULModalLevel
=
0
;
nsCocoaWindowList
*
gGeckoAppModalWindowList
=
NULL
;
BOOL
sTouchBarIsInitialized
=
NO
;
extern
NSMenu
*
sApplicationMenu
;
extern
BOOL
gSomeMenuBarPainted
;
#
if
!
defined
(
MAC_OS_X_VERSION_10_9
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_9
enum
NSWindowOcclusionState
{
NSWindowOcclusionStateVisible
=
0x1
<
<
1
}
;
interface
NSWindow
(
OcclusionState
)
-
(
NSWindowOcclusionState
)
occlusionState
;
end
#
endif
#
if
!
defined
(
MAC_OS_X_VERSION_10_10
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_10
enum
NSWindowTitleVisibility
{
NSWindowTitleVisible
=
0
NSWindowTitleHidden
=
1
}
;
interface
NSWindow
(
TitleVisibility
)
-
(
void
)
setTitleVisibility
:
(
NSWindowTitleVisibility
)
visibility
;
-
(
void
)
setTitlebarAppearsTransparent
:
(
BOOL
)
isTitlebarTransparent
;
end
#
endif
#
if
!
defined
(
MAC_OS_X_VERSION_10_12
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_12
interface
NSWindow
(
AutomaticWindowTabbing
)
+
(
void
)
setAllowsAutomaticWindowTabbing
:
(
BOOL
)
allow
;
end
#
endif
extern
"
C
"
{
typedef
NSInteger
CGSConnection
;
typedef
NSUInteger
CGSSpaceID
;
typedef
NSInteger
CGSWindow
;
typedef
NSUInteger
CGSWindowFilterRef
;
typedef
enum
{
kCGSSpaceIncludesCurrent
=
1
<
<
0
kCGSSpaceIncludesOthers
=
1
<
<
1
kCGSSpaceIncludesUser
=
1
<
<
2
kCGSAllSpacesMask
=
kCGSSpaceIncludesCurrent
|
kCGSSpaceIncludesOthers
|
kCGSSpaceIncludesUser
}
CGSSpaceMask
;
static
NSString
*
const
CGSSpaceIDKey
=
"
ManagedSpaceID
"
;
static
NSString
*
const
CGSSpacesKey
=
"
Spaces
"
;
extern
CGSConnection
_CGSDefaultConnection
(
void
)
;
extern
CGError
CGSSetWindowShadowAndRimParameters
(
const
CGSConnection
cid
CGSWindow
wid
float
standardDeviation
float
density
int
offsetX
int
offsetY
unsigned
int
flags
)
;
extern
CGError
CGSSetWindowBackgroundBlurRadius
(
CGSConnection
cid
CGSWindow
wid
NSUInteger
blur
)
;
extern
CGError
CGSSetWindowTransform
(
CGSConnection
cid
CGSWindow
wid
CGAffineTransform
transform
)
;
}
#
define
NS_APPSHELLSERVICE_CONTRACTID
"
mozilla
.
org
/
appshell
/
appShellService
;
1
"
NS_IMPL_ISUPPORTS_INHERITED
(
nsCocoaWindow
Inherited
nsPIWidgetCocoa
)
static
void
RollUpPopups
(
)
{
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
NS_ENSURE_TRUE_VOID
(
rollupListener
)
;
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
!
rollupWidget
)
return
;
rollupListener
-
>
Rollup
(
0
true
nullptr
nullptr
)
;
}
nsCocoaWindow
:
:
nsCocoaWindow
(
)
:
mParent
(
nullptr
)
mAncestorLink
(
nullptr
)
mWindow
(
nil
)
mDelegate
(
nil
)
mSheetWindowParent
(
nil
)
mPopupContentView
(
nil
)
mFullscreenTransitionAnimation
(
nil
)
mShadowStyle
(
StyleWindowShadow
:
:
Default
)
mBackingScaleFactor
(
0
.
0
)
mAnimationType
(
nsIWidget
:
:
eGenericWindowAnimation
)
mWindowMadeHere
(
false
)
mSheetNeedsShow
(
false
)
mInFullScreenMode
(
false
)
mInFullScreenTransition
(
false
)
mModal
(
false
)
mFakeModal
(
false
)
mInNativeFullScreenMode
(
false
)
mIsAnimationSuppressed
(
false
)
mInReportMoveEvent
(
false
)
mInResize
(
false
)
mWindowTransformIsIdentity
(
true
)
mAlwaysOnTop
(
false
)
mAspectRatioLocked
(
false
)
mNumModalDescendents
(
0
)
mWindowAnimationBehavior
(
NSWindowAnimationBehaviorDefault
)
mWasShown
(
false
)
{
if
(
[
NSWindow
respondsToSelector
:
selector
(
setAllowsAutomaticWindowTabbing
:
)
]
)
{
[
NSWindow
setAllowsAutomaticWindowTabbing
:
NO
]
;
}
}
void
nsCocoaWindow
:
:
DestroyNativeWindow
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
return
;
[
mWindow
releaseJSObjects
]
;
[
mWindow
setDelegate
:
nil
]
;
[
mWindow
close
]
;
mWindow
=
nil
;
[
mDelegate
autorelease
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsCocoaWindow
:
:
~
nsCocoaWindow
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
for
(
nsIWidget
*
kid
=
mLastChild
;
kid
;
)
{
nsWindowType
kidType
=
kid
-
>
WindowType
(
)
;
if
(
kidType
=
=
eWindowType_child
)
{
nsChildView
*
childView
=
static_cast
<
nsChildView
*
>
(
kid
)
;
kid
=
kid
-
>
GetPrevSibling
(
)
;
childView
-
>
ResetParent
(
)
;
}
else
{
nsCocoaWindow
*
childWindow
=
static_cast
<
nsCocoaWindow
*
>
(
kid
)
;
childWindow
-
>
mParent
=
nullptr
;
childWindow
-
>
mAncestorLink
=
mAncestorLink
;
kid
=
kid
-
>
GetPrevSibling
(
)
;
}
}
if
(
mWindow
&
&
mWindowMadeHere
)
{
DestroyNativeWindow
(
)
;
}
NS_IF_RELEASE
(
mPopupContentView
)
;
if
(
mModal
)
{
NS_WARNING
(
"
Widget
destroyed
while
running
modal
!
"
)
;
-
-
gXULModalLevel
;
NS_ASSERTION
(
gXULModalLevel
>
=
0
"
Weirdness
setting
modality
!
"
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
NSScreen
*
FindTargetScreenForRect
(
const
DesktopIntRect
&
aRect
)
{
NSScreen
*
targetScreen
=
[
NSScreen
mainScreen
]
;
NSEnumerator
*
screenEnum
=
[
[
NSScreen
screens
]
objectEnumerator
]
;
int
largestIntersectArea
=
0
;
while
(
NSScreen
*
screen
=
[
screenEnum
nextObject
]
)
{
DesktopIntRect
screenRect
=
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
[
screen
visibleFrame
]
)
;
screenRect
=
screenRect
.
Intersect
(
aRect
)
;
int
area
=
screenRect
.
width
*
screenRect
.
height
;
if
(
area
>
largestIntersectArea
)
{
largestIntersectArea
=
area
;
targetScreen
=
screen
;
}
}
return
targetScreen
;
}
static
void
FitRectToVisibleAreaForScreen
(
DesktopIntRect
&
aRect
NSScreen
*
aScreen
)
{
if
(
!
aScreen
)
{
aScreen
=
FindTargetScreenForRect
(
aRect
)
;
}
DesktopIntRect
screenBounds
=
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
[
aScreen
visibleFrame
]
)
;
if
(
aRect
.
width
>
screenBounds
.
width
)
{
aRect
.
width
=
screenBounds
.
width
;
}
if
(
aRect
.
height
>
screenBounds
.
height
)
{
aRect
.
height
=
screenBounds
.
height
;
}
if
(
aRect
.
x
-
screenBounds
.
x
+
aRect
.
width
>
screenBounds
.
width
)
{
aRect
.
x
+
=
screenBounds
.
width
-
(
aRect
.
x
-
screenBounds
.
x
+
aRect
.
width
)
;
}
if
(
aRect
.
y
-
screenBounds
.
y
+
aRect
.
height
>
screenBounds
.
height
)
{
aRect
.
y
+
=
screenBounds
.
height
-
(
aRect
.
y
-
screenBounds
.
y
+
aRect
.
height
)
;
}
if
(
aRect
.
x
<
screenBounds
.
x
|
|
aRect
.
x
>
(
screenBounds
.
x
+
screenBounds
.
width
)
)
{
aRect
.
x
=
screenBounds
.
x
;
}
if
(
aRect
.
y
<
screenBounds
.
y
|
|
aRect
.
y
>
(
screenBounds
.
y
+
screenBounds
.
height
)
)
{
aRect
.
y
=
screenBounds
.
y
;
}
}
static
bool
UseNativePopupWindows
(
)
{
#
ifdef
MOZ_USE_NATIVE_POPUP_WINDOWS
return
true
;
#
else
return
false
;
#
endif
}
nsresult
nsCocoaWindow
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
DesktopIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
nsAutoreleasePool
localPool
;
DesktopIntRect
newBounds
=
aRect
;
FitRectToVisibleAreaForScreen
(
newBounds
nullptr
)
;
mWindowType
=
eWindowType_toplevel
;
mBorderStyle
=
eBorderStyle_default
;
nsToolkit
:
:
GetToolkit
(
)
;
Inherited
:
:
BaseCreate
(
aParent
aInitData
)
;
mParent
=
aParent
;
mAncestorLink
=
aParent
;
mAlwaysOnTop
=
aInitData
-
>
mAlwaysOnTop
;
if
(
(
mWindowType
=
=
eWindowType_popup
)
&
&
UseNativePopupWindows
(
)
)
return
NS_OK
;
nsresult
rv
=
CreateNativeWindow
(
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
newBounds
)
mBorderStyle
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
SetWindowMouseTransparent
(
aInitData
-
>
mMouseTransparent
)
;
LayoutDeviceIntRect
devRect
=
RoundedToInt
(
newBounds
*
GetDesktopToDeviceScale
(
)
)
;
return
CreatePopupContentView
(
devRect
aInitData
)
;
}
mIsAnimationSuppressed
=
aInitData
-
>
mIsAnimationSuppressed
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
nsresult
nsCocoaWindow
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
DesktopIntRect
desktopRect
=
RoundedToInt
(
aRect
/
GetDesktopToDeviceScale
(
)
)
;
return
Create
(
aParent
aNativeParent
desktopRect
aInitData
)
;
}
static
unsigned
int
WindowMaskForBorderStyle
(
nsBorderStyle
aBorderStyle
)
{
bool
allOrDefault
=
(
aBorderStyle
=
=
eBorderStyle_all
|
|
aBorderStyle
=
=
eBorderStyle_default
)
;
if
(
!
allOrDefault
&
&
!
(
aBorderStyle
&
eBorderStyle_title
)
)
return
NSBorderlessWindowMask
;
unsigned
int
mask
=
NSTitledWindowMask
;
if
(
allOrDefault
|
|
aBorderStyle
&
eBorderStyle_close
)
mask
|
=
NSClosableWindowMask
;
if
(
allOrDefault
|
|
aBorderStyle
&
eBorderStyle_minimize
)
mask
|
=
NSMiniaturizableWindowMask
;
if
(
allOrDefault
|
|
aBorderStyle
&
eBorderStyle_resizeh
)
mask
|
=
NSResizableWindowMask
;
return
mask
;
}
nsresult
nsCocoaWindow
:
:
CreateNativeWindow
(
const
NSRect
&
aRect
nsBorderStyle
aBorderStyle
bool
aRectIsFrameRect
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
unsigned
int
features
=
NSBorderlessWindowMask
;
switch
(
mWindowType
)
{
case
eWindowType_invisible
:
case
eWindowType_child
:
case
eWindowType_plugin
:
break
;
case
eWindowType_popup
:
if
(
aBorderStyle
!
=
eBorderStyle_default
&
&
mBorderStyle
&
eBorderStyle_title
)
{
features
|
=
NSTitledWindowMask
;
if
(
aBorderStyle
&
eBorderStyle_close
)
{
features
|
=
NSClosableWindowMask
;
}
}
break
;
case
eWindowType_toplevel
:
case
eWindowType_dialog
:
features
=
WindowMaskForBorderStyle
(
aBorderStyle
)
;
break
;
case
eWindowType_sheet
:
if
(
mParent
-
>
WindowType
(
)
!
=
eWindowType_invisible
&
&
aBorderStyle
&
eBorderStyle_resizeh
)
{
features
=
NSResizableWindowMask
;
}
else
{
features
=
NSMiniaturizableWindowMask
;
}
features
|
=
NSTitledWindowMask
;
break
;
default
:
NS_ERROR
(
"
Unhandled
window
type
!
"
)
;
return
NS_ERROR_FAILURE
;
}
NSRect
contentRect
;
if
(
aRectIsFrameRect
)
{
contentRect
=
[
NSWindow
contentRectForFrameRect
:
aRect
styleMask
:
features
]
;
}
else
{
NSRect
newWindowFrame
=
[
NSWindow
frameRectForContentRect
:
aRect
styleMask
:
features
]
;
contentRect
=
aRect
;
contentRect
.
origin
.
y
-
=
(
newWindowFrame
.
size
.
height
-
aRect
.
size
.
height
)
;
if
(
mWindowType
!
=
eWindowType_popup
)
contentRect
.
origin
.
y
-
=
[
[
NSApp
mainMenu
]
menuBarHeight
]
;
}
Class
windowClass
=
[
BaseWindow
class
]
;
if
(
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
&
&
(
features
&
NSTitledWindowMask
)
)
windowClass
=
[
ToolbarWindow
class
]
;
else
if
(
mWindowType
=
=
eWindowType_popup
)
windowClass
=
[
PopupWindow
class
]
;
else
if
(
features
=
=
NSBorderlessWindowMask
)
windowClass
=
[
BorderlessWindow
class
]
;
mWindow
=
[
[
windowClass
alloc
]
initWithContentRect
:
contentRect
styleMask
:
features
backing
:
NSBackingStoreBuffered
defer
:
YES
]
;
[
mWindow
setRestorable
:
NO
]
;
[
mWindow
disableSnapshotRestoration
]
;
mDelegate
=
[
[
WindowDelegate
alloc
]
initWithGeckoWindow
:
this
]
;
[
mWindow
setDelegate
:
mDelegate
]
;
NSRect
wantedFrame
=
[
mWindow
frameRectForChildViewRect
:
contentRect
]
;
if
(
!
NSEqualRects
(
[
mWindow
frame
]
wantedFrame
)
)
{
[
mWindow
setFrame
:
wantedFrame
display
:
NO
]
;
}
UpdateBounds
(
)
;
if
(
mWindowType
=
=
eWindowType_invisible
)
{
[
mWindow
setLevel
:
kCGDesktopWindowLevelKey
]
;
}
if
(
mWindowType
=
=
eWindowType_popup
)
{
SetPopupWindowLevel
(
)
;
[
mWindow
setBackgroundColor
:
[
NSColor
clearColor
]
]
;
[
mWindow
setOpaque
:
NO
]
;
if
(
!
mAlwaysOnTop
)
{
NSWindowCollectionBehavior
behavior
=
[
mWindow
collectionBehavior
]
;
behavior
|
=
NSWindowCollectionBehaviorMoveToActiveSpace
;
[
mWindow
setCollectionBehavior
:
behavior
]
;
}
}
else
{
[
mWindow
setOpaque
:
YES
]
;
}
NSWindowCollectionBehavior
newBehavior
=
[
mWindow
collectionBehavior
]
;
if
(
mAlwaysOnTop
)
{
[
mWindow
setLevel
:
NSFloatingWindowLevel
]
;
newBehavior
|
=
NSWindowCollectionBehaviorCanJoinAllSpaces
;
}
[
mWindow
setCollectionBehavior
:
newBehavior
]
;
[
mWindow
setContentMinSize
:
NSMakeSize
(
60
60
)
]
;
[
mWindow
disableCursorRects
]
;
[
[
mWindow
contentView
]
setWantsLayer
:
YES
]
;
[
mWindow
setMovableByWindowBackground
:
NO
]
;
[
[
WindowDataMap
sharedWindowDataMap
]
ensureDataForWindow
:
mWindow
]
;
mWindowMadeHere
=
true
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
nsresult
nsCocoaWindow
:
:
CreatePopupContentView
(
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
mPopupContentView
=
new
nsChildView
(
)
;
if
(
!
mPopupContentView
)
return
NS_ERROR_FAILURE
;
NS_ADDREF
(
mPopupContentView
)
;
nsIWidget
*
thisAsWidget
=
static_cast
<
nsIWidget
*
>
(
this
)
;
nsresult
rv
=
mPopupContentView
-
>
Create
(
thisAsWidget
nullptr
aRect
aInitData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
NSView
*
contentView
=
[
mWindow
contentView
]
;
ChildView
*
childView
=
(
ChildView
*
)
mPopupContentView
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
[
childView
setFrame
:
[
contentView
bounds
]
]
;
[
childView
setAutoresizingMask
:
NSViewWidthSizable
|
NSViewHeightSizable
]
;
[
contentView
addSubview
:
childView
]
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsCocoaWindow
:
:
Destroy
(
)
{
if
(
mOnDestroyCalled
)
return
;
mOnDestroyCalled
=
true
;
if
(
mFakeModal
)
{
SetFakeModal
(
false
)
;
}
Show
(
false
)
;
if
(
mPopupContentView
)
mPopupContentView
-
>
Destroy
(
)
;
if
(
mFullscreenTransitionAnimation
)
{
[
mFullscreenTransitionAnimation
stopAnimation
]
;
ReleaseFullscreenTransitionAnimation
(
)
;
}
nsBaseWidget
:
:
Destroy
(
)
;
if
(
mParent
)
{
mParent
-
>
RemoveChild
(
this
)
;
}
nsBaseWidget
:
:
OnDestroy
(
)
;
if
(
mInFullScreenMode
)
{
if
(
mInNativeFullScreenMode
)
{
DestroyNativeWindow
(
)
;
}
else
if
(
mWindow
)
{
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
false
)
;
}
}
}
nsIWidget
*
nsCocoaWindow
:
:
GetSheetWindowParent
(
void
)
{
if
(
mWindowType
!
=
eWindowType_sheet
)
return
nullptr
;
nsCocoaWindow
*
parent
=
static_cast
<
nsCocoaWindow
*
>
(
mParent
)
;
while
(
parent
&
&
(
parent
-
>
mWindowType
=
=
eWindowType_sheet
)
)
parent
=
static_cast
<
nsCocoaWindow
*
>
(
parent
-
>
mParent
)
;
return
parent
;
}
void
*
nsCocoaWindow
:
:
GetNativeData
(
uint32_t
aDataType
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL
;
void
*
retVal
=
nullptr
;
switch
(
aDataType
)
{
case
NS_NATIVE_WIDGET
:
case
NS_NATIVE_DISPLAY
:
retVal
=
[
mWindow
contentView
]
;
break
;
case
NS_NATIVE_WINDOW
:
retVal
=
mWindow
;
break
;
case
NS_NATIVE_GRAPHIC
:
NS_ERROR
(
"
Requesting
NS_NATIVE_GRAPHIC
on
a
top
-
level
window
!
"
)
;
break
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
{
retVal
=
GetPseudoIMEContext
(
)
;
if
(
retVal
)
{
break
;
}
NSView
*
view
=
mWindow
?
[
mWindow
contentView
]
:
nil
;
if
(
view
)
{
retVal
=
[
view
inputContext
]
;
}
if
(
NS_WARN_IF
(
!
retVal
)
)
{
retVal
=
this
;
}
break
;
}
}
return
retVal
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL
;
}
bool
nsCocoaWindow
:
:
IsVisible
(
)
const
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
return
(
mWindow
&
&
(
[
mWindow
isVisibleOrBeingShown
]
|
|
mSheetNeedsShow
)
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
void
nsCocoaWindow
:
:
SetModal
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
return
;
nsAutoreleasePool
localPool
;
mModal
=
aState
;
nsCocoaWindow
*
ancestor
=
static_cast
<
nsCocoaWindow
*
>
(
mAncestorLink
)
;
if
(
aState
)
{
+
+
gXULModalLevel
;
if
(
mWindowType
!
=
eWindowType_sheet
)
{
while
(
ancestor
)
{
if
(
ancestor
-
>
mNumModalDescendents
+
+
=
=
0
)
{
NSWindow
*
aWindow
=
ancestor
-
>
GetCocoaWindow
(
)
;
if
(
ancestor
-
>
mWindowType
!
=
eWindowType_invisible
)
{
[
[
aWindow
standardWindowButton
:
NSWindowCloseButton
]
setEnabled
:
NO
]
;
[
[
aWindow
standardWindowButton
:
NSWindowMiniaturizeButton
]
setEnabled
:
NO
]
;
[
[
aWindow
standardWindowButton
:
NSWindowZoomButton
]
setEnabled
:
NO
]
;
}
}
ancestor
=
static_cast
<
nsCocoaWindow
*
>
(
ancestor
-
>
mParent
)
;
}
[
mWindow
setLevel
:
NSModalPanelWindowLevel
]
;
nsCocoaWindowList
*
windowList
=
new
nsCocoaWindowList
;
if
(
windowList
)
{
windowList
-
>
window
=
this
;
windowList
-
>
prev
=
gGeckoAppModalWindowList
;
gGeckoAppModalWindowList
=
windowList
;
}
}
}
else
{
-
-
gXULModalLevel
;
NS_ASSERTION
(
gXULModalLevel
>
=
0
"
Mismatched
call
to
nsCocoaWindow
:
:
SetModal
(
false
)
!
"
)
;
if
(
mWindowType
!
=
eWindowType_sheet
)
{
while
(
ancestor
)
{
if
(
-
-
ancestor
-
>
mNumModalDescendents
=
=
0
)
{
NSWindow
*
aWindow
=
ancestor
-
>
GetCocoaWindow
(
)
;
if
(
ancestor
-
>
mWindowType
!
=
eWindowType_invisible
)
{
[
[
aWindow
standardWindowButton
:
NSWindowCloseButton
]
setEnabled
:
YES
]
;
[
[
aWindow
standardWindowButton
:
NSWindowMiniaturizeButton
]
setEnabled
:
YES
]
;
[
[
aWindow
standardWindowButton
:
NSWindowZoomButton
]
setEnabled
:
YES
]
;
}
}
NS_ASSERTION
(
ancestor
-
>
mNumModalDescendents
>
=
0
"
Widget
hierarchy
changed
while
modal
!
"
)
;
ancestor
=
static_cast
<
nsCocoaWindow
*
>
(
ancestor
-
>
mParent
)
;
}
if
(
gGeckoAppModalWindowList
)
{
NS_ASSERTION
(
gGeckoAppModalWindowList
-
>
window
=
=
this
"
Widget
hierarchy
changed
while
modal
!
"
)
;
nsCocoaWindowList
*
saved
=
gGeckoAppModalWindowList
;
gGeckoAppModalWindowList
=
gGeckoAppModalWindowList
-
>
prev
;
delete
saved
;
}
if
(
mWindowType
=
=
eWindowType_popup
)
SetPopupWindowLevel
(
)
;
else
[
mWindow
setLevel
:
NSNormalWindowLevel
]
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetFakeModal
(
bool
aState
)
{
mFakeModal
=
aState
;
SetModal
(
aState
)
;
}
bool
nsCocoaWindow
:
:
IsRunningAppModal
(
)
{
return
[
NSApp
_isRunningAppModal
]
;
}
void
nsCocoaWindow
:
:
Show
(
bool
bState
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
return
;
if
(
!
mSheetNeedsShow
&
&
!
bState
&
&
!
[
mWindow
isVisible
]
)
return
;
if
(
bState
&
&
[
mWindow
isBeingShown
]
)
return
;
[
mWindow
setBeingShown
:
bState
]
;
if
(
bState
&
&
!
mWasShown
)
{
mWasShown
=
true
;
}
nsIWidget
*
parentWidget
=
mParent
;
nsCOMPtr
<
nsPIWidgetCocoa
>
piParentWidget
(
do_QueryInterface
(
parentWidget
)
)
;
NSWindow
*
nativeParentWindow
=
(
parentWidget
)
?
(
NSWindow
*
)
parentWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
:
nil
;
if
(
bState
&
&
!
mBounds
.
IsEmpty
(
)
)
{
if
(
mWindowType
=
=
eWindowType_popup
&
&
nativeParentWindow
)
{
if
(
!
[
nativeParentWindow
isVisible
]
|
|
[
nativeParentWindow
isMiniaturized
]
)
{
return
;
}
}
if
(
mPopupContentView
)
{
mPopupContentView
-
>
Show
(
true
)
;
}
if
(
mWindowType
=
=
eWindowType_sheet
)
{
if
(
!
nativeParentWindow
|
|
!
piParentWidget
)
return
;
NSWindow
*
topNonSheetWindow
=
nativeParentWindow
;
bool
parentIsSheet
=
false
;
if
(
NS_SUCCEEDED
(
piParentWidget
-
>
GetIsSheet
(
&
parentIsSheet
)
)
&
&
parentIsSheet
)
{
piParentWidget
-
>
GetSheetWindowParent
(
&
topNonSheetWindow
)
;
[
NSApp
endSheet
:
nativeParentWindow
]
;
}
nsCOMPtr
<
nsIWidget
>
sheetShown
;
if
(
NS_SUCCEEDED
(
piParentWidget
-
>
GetChildSheet
(
true
getter_AddRefs
(
sheetShown
)
)
)
&
&
(
!
sheetShown
|
|
sheetShown
=
=
this
)
)
{
if
(
!
[
mWindow
isVisible
]
)
{
mSheetNeedsShow
=
false
;
mSheetWindowParent
=
topNonSheetWindow
;
NSWindow
*
contextInfo
=
parentIsSheet
?
nil
:
mSheetWindowParent
;
[
TopLevelWindowData
deactivateInWindow
:
mSheetWindowParent
]
;
[
NSApp
beginSheet
:
mWindow
modalForWindow
:
mSheetWindowParent
modalDelegate
:
mDelegate
didEndSelector
:
selector
(
didEndSheet
:
returnCode
:
contextInfo
:
)
contextInfo
:
contextInfo
]
;
[
TopLevelWindowData
activateInWindow
:
mWindow
]
;
SendSetZLevelEvent
(
)
;
}
}
else
{
mSheetNeedsShow
=
true
;
}
}
else
if
(
mWindowType
=
=
eWindowType_popup
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
[
mWindow
contentView
]
setNeedsDisplay
:
YES
]
;
[
mWindow
orderFront
:
nil
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
SendSetZLevelEvent
(
)
;
AdjustWindowShadow
(
)
;
SetWindowBackgroundBlur
(
)
;
if
(
[
mWindow
isKindOfClass
:
[
PopupWindow
class
]
]
&
&
[
(
PopupWindow
*
)
mWindow
isContextMenu
]
)
{
[
[
NSDistributedNotificationCenter
defaultCenter
]
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
beginMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
}
if
(
nativeParentWindow
&
&
mPopupLevel
=
=
ePopupLevelParent
)
[
nativeParentWindow
addChildWindow
:
mWindow
ordered
:
NSWindowAbove
]
;
}
else
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mWindowType
=
=
eWindowType_toplevel
&
&
[
mWindow
respondsToSelector
:
selector
(
setAnimationBehavior
:
)
]
)
{
NSWindowAnimationBehavior
behavior
;
if
(
mIsAnimationSuppressed
)
{
behavior
=
NSWindowAnimationBehaviorNone
;
}
else
{
switch
(
mAnimationType
)
{
case
nsIWidget
:
:
eDocumentWindowAnimation
:
behavior
=
NSWindowAnimationBehaviorDocumentWindow
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
mAnimationType
value
"
)
;
case
nsIWidget
:
:
eGenericWindowAnimation
:
behavior
=
NSWindowAnimationBehaviorDefault
;
break
;
}
}
[
mWindow
setAnimationBehavior
:
behavior
]
;
mWindowAnimationBehavior
=
behavior
;
}
if
(
mAlwaysOnTop
)
{
[
mWindow
orderFront
:
nil
]
;
}
else
{
[
mWindow
makeKeyAndOrderFront
:
nil
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
SendSetZLevelEvent
(
)
;
}
}
else
{
if
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
)
RollUpPopups
(
)
;
if
(
mWindowType
=
=
eWindowType_sheet
)
{
if
(
mSheetNeedsShow
)
{
mSheetNeedsShow
=
false
;
}
else
{
NSWindow
*
sheetParent
=
mSheetWindowParent
;
[
NSApp
endSheet
:
mWindow
]
;
[
TopLevelWindowData
deactivateInWindow
:
mWindow
]
;
nsCOMPtr
<
nsIWidget
>
siblingSheetToShow
;
bool
parentIsSheet
=
false
;
if
(
nativeParentWindow
&
&
piParentWidget
&
&
NS_SUCCEEDED
(
piParentWidget
-
>
GetChildSheet
(
false
getter_AddRefs
(
siblingSheetToShow
)
)
)
&
&
siblingSheetToShow
)
{
siblingSheetToShow
-
>
Show
(
true
)
;
}
else
if
(
nativeParentWindow
&
&
piParentWidget
&
&
NS_SUCCEEDED
(
piParentWidget
-
>
GetIsSheet
(
&
parentIsSheet
)
)
&
&
parentIsSheet
)
{
NSWindow
*
contextInfo
=
sheetParent
;
nsIWidget
*
grandparentWidget
=
nil
;
if
(
NS_SUCCEEDED
(
piParentWidget
-
>
GetRealParent
(
&
grandparentWidget
)
)
&
&
grandparentWidget
)
{
nsCOMPtr
<
nsPIWidgetCocoa
>
piGrandparentWidget
(
do_QueryInterface
(
grandparentWidget
)
)
;
bool
grandparentIsSheet
=
false
;
if
(
piGrandparentWidget
&
&
NS_SUCCEEDED
(
piGrandparentWidget
-
>
GetIsSheet
(
&
grandparentIsSheet
)
)
&
&
grandparentIsSheet
)
{
contextInfo
=
nil
;
}
}
[
NSApp
beginSheet
:
nativeParentWindow
modalForWindow
:
sheetParent
modalDelegate
:
[
nativeParentWindow
delegate
]
didEndSelector
:
selector
(
didEndSheet
:
returnCode
:
contextInfo
:
)
contextInfo
:
contextInfo
]
;
}
else
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
sheetParent
makeKeyAndOrderFront
:
nil
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
SendSetZLevelEvent
(
)
;
}
}
else
{
if
(
mWindowType
=
=
eWindowType_popup
&
&
nativeParentWindow
)
[
nativeParentWindow
removeChildWindow
:
mWindow
]
;
[
mWindow
orderOut
:
nil
]
;
if
(
[
mWindow
isKindOfClass
:
[
PopupWindow
class
]
]
&
&
[
(
PopupWindow
*
)
mWindow
isContextMenu
]
)
{
[
[
NSDistributedNotificationCenter
defaultCenter
]
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
endMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
}
}
}
[
mWindow
setBeingShown
:
NO
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
nsCocoaWindow
:
:
NeedsRecreateToReshow
(
)
{
return
(
mWindowType
=
=
eWindowType_popup
)
&
&
mWasShown
&
&
(
[
[
NSScreen
screens
]
count
]
>
1
)
;
}
struct
ShadowParams
{
float
standardDeviation
;
float
density
;
int
offsetX
;
int
offsetY
;
unsigned
int
flags
;
}
;
static
const
ShadowParams
kWindowShadowParametersPreYosemite
[
]
=
{
{
0
.
0f
0
.
0f
0
0
0
}
{
8
.
0f
0
.
5f
0
6
1
}
{
10
.
0f
0
.
44f
0
10
512
}
{
8
.
0f
0
.
5f
0
6
1
}
{
4
.
0f
0
.
6f
0
4
512
}
}
;
static
const
ShadowParams
kWindowShadowParametersPostYosemite
[
]
=
{
{
0
.
0f
0
.
0f
0
0
0
}
{
8
.
0f
0
.
5f
0
6
1
}
{
9
.
882353f
0
.
3f
0
4
0
}
{
3
.
294118f
0
.
2f
0
1
0
}
{
9
.
882353f
0
.
3f
0
4
0
}
}
;
void
nsCocoaWindow
:
:
AdjustWindowShadow
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
|
|
!
[
mWindow
isVisible
]
|
|
!
[
mWindow
hasShadow
]
|
|
[
mWindow
canBecomeKeyWindow
]
|
|
[
mWindow
windowNumber
]
=
=
-
1
)
return
;
const
ShadowParams
&
params
=
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
?
kWindowShadowParametersPostYosemite
[
uint8_t
(
mShadowStyle
)
]
:
kWindowShadowParametersPreYosemite
[
uint8_t
(
mShadowStyle
)
]
;
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
CGSSetWindowShadowAndRimParameters
(
cid
[
mWindow
windowNumber
]
params
.
standardDeviation
params
.
density
params
.
offsetX
params
.
offsetY
params
.
flags
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
const
NSUInteger
kWindowBackgroundBlurRadius
=
4
;
void
nsCocoaWindow
:
:
SetWindowBackgroundBlur
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
|
|
!
[
mWindow
isVisible
]
|
|
[
mWindow
windowNumber
]
=
=
-
1
)
return
;
if
(
mShadowStyle
!
=
StyleWindowShadow
:
:
Menu
&
&
mShadowStyle
!
=
StyleWindowShadow
:
:
Sheet
)
return
;
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
CGSSetWindowBackgroundBlurRadius
(
cid
[
mWindow
windowNumber
]
kWindowBackgroundBlurRadius
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
ConfigureChildren
(
const
nsTArray
<
Configuration
>
&
aConfigurations
)
{
if
(
mPopupContentView
)
{
mPopupContentView
-
>
ConfigureChildren
(
aConfigurations
)
;
}
return
NS_OK
;
}
LayerManager
*
nsCocoaWindow
:
:
GetLayerManager
(
PLayerTransactionChild
*
aShadowManager
LayersBackend
aBackendHint
LayerManagerPersistence
aPersistence
)
{
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
GetLayerManager
(
aShadowManager
aBackendHint
aPersistence
)
;
}
return
nullptr
;
}
nsTransparencyMode
nsCocoaWindow
:
:
GetTransparencyMode
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
return
(
!
mWindow
|
|
[
mWindow
isOpaque
]
)
?
eTransparencyOpaque
:
eTransparencyTransparent
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
eTransparencyOpaque
)
;
}
void
nsCocoaWindow
:
:
SetTransparencyMode
(
nsTransparencyMode
aMode
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
return
;
BOOL
isTransparent
=
aMode
=
=
eTransparencyTransparent
&
&
mWindowType
=
=
eWindowType_popup
;
BOOL
currentTransparency
=
!
[
mWindow
isOpaque
]
;
if
(
isTransparent
!
=
currentTransparency
)
{
[
mWindow
setOpaque
:
!
isTransparent
]
;
[
mWindow
setBackgroundColor
:
(
isTransparent
?
[
NSColor
clearColor
]
:
[
NSColor
whiteColor
]
)
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
Enable
(
bool
aState
)
{
}
bool
nsCocoaWindow
:
:
IsEnabled
(
)
const
{
return
true
;
}
#
define
kWindowPositionSlop
20
void
nsCocoaWindow
:
:
ConstrainPosition
(
bool
aAllowSlop
int32_t
*
aX
int32_t
*
aY
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
|
|
!
[
mWindow
screen
]
)
{
return
;
}
nsIntRect
screenBounds
;
int32_t
width
height
;
NSRect
frame
=
[
mWindow
frame
]
;
width
=
std
:
:
max
<
int32_t
>
(
frame
.
size
.
width
1
)
;
height
=
std
:
:
max
<
int32_t
>
(
frame
.
size
.
height
1
)
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenMgr
)
{
nsCOMPtr
<
nsIScreen
>
screen
;
screenMgr
-
>
ScreenForRect
(
*
aX
*
aY
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
screen
-
>
GetRectDisplayPix
(
&
(
screenBounds
.
x
)
&
(
screenBounds
.
y
)
&
(
screenBounds
.
width
)
&
(
screenBounds
.
height
)
)
;
}
}
if
(
aAllowSlop
)
{
if
(
*
aX
<
screenBounds
.
x
-
width
+
kWindowPositionSlop
)
{
*
aX
=
screenBounds
.
x
-
width
+
kWindowPositionSlop
;
}
else
if
(
*
aX
>
=
screenBounds
.
x
+
screenBounds
.
width
-
kWindowPositionSlop
)
{
*
aX
=
screenBounds
.
x
+
screenBounds
.
width
-
kWindowPositionSlop
;
}
if
(
*
aY
<
screenBounds
.
y
-
height
+
kWindowPositionSlop
)
{
*
aY
=
screenBounds
.
y
-
height
+
kWindowPositionSlop
;
}
else
if
(
*
aY
>
=
screenBounds
.
y
+
screenBounds
.
height
-
kWindowPositionSlop
)
{
*
aY
=
screenBounds
.
y
+
screenBounds
.
height
-
kWindowPositionSlop
;
}
}
else
{
if
(
*
aX
<
screenBounds
.
x
)
{
*
aX
=
screenBounds
.
x
;
}
else
if
(
*
aX
>
=
screenBounds
.
x
+
screenBounds
.
width
-
width
)
{
*
aX
=
screenBounds
.
x
+
screenBounds
.
width
-
width
;
}
if
(
*
aY
<
screenBounds
.
y
)
{
*
aY
=
screenBounds
.
y
;
}
else
if
(
*
aY
>
=
screenBounds
.
y
+
screenBounds
.
height
-
height
)
{
*
aY
=
screenBounds
.
y
+
screenBounds
.
height
-
height
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSizeConstraints
(
const
SizeConstraints
&
aConstraints
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSRect
rect
=
(
mWindowType
=
=
eWindowType_popup
)
?
NSZeroRect
:
NSMakeRect
(
0
.
0
0
.
0
32
32
)
;
rect
=
[
mWindow
frameRectForChildViewRect
:
rect
]
;
CGFloat
scaleFactor
=
BackingScaleFactor
(
)
;
SizeConstraints
c
=
aConstraints
;
c
.
mMinSize
.
width
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
rect
.
size
.
width
scaleFactor
)
c
.
mMinSize
.
width
)
;
c
.
mMinSize
.
height
=
std
:
:
max
(
nsCocoaUtils
:
:
CocoaPointsToDevPixels
(
rect
.
size
.
height
scaleFactor
)
c
.
mMinSize
.
height
)
;
NSSize
minSize
=
{
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMinSize
.
width
scaleFactor
)
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMinSize
.
height
scaleFactor
)
}
;
[
mWindow
setMinSize
:
minSize
]
;
NSSize
maxSize
=
{
c
.
mMaxSize
.
width
=
=
NS_MAXSIZE
?
FLT_MAX
:
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMaxSize
.
width
scaleFactor
)
c
.
mMaxSize
.
height
=
=
NS_MAXSIZE
?
FLT_MAX
:
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
c
.
mMaxSize
.
height
scaleFactor
)
}
;
[
mWindow
setMaxSize
:
maxSize
]
;
nsBaseWidget
:
:
SetSizeConstraints
(
c
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
Move
(
double
aX
double
aY
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
NSPoint
coord
=
{
static_cast
<
float
>
(
aX
)
static_cast
<
float
>
(
nsCocoaUtils
:
:
FlippedScreenY
(
NSToIntRound
(
aY
)
)
)
}
;
NSRect
frame
=
[
mWindow
frame
]
;
if
(
frame
.
origin
.
x
!
=
coord
.
x
|
|
frame
.
origin
.
y
+
frame
.
size
.
height
!
=
coord
.
y
)
{
[
mWindow
setFrameTopLeftPoint
:
coord
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSizeMode
(
nsSizeMode
aMode
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
return
;
nsSizeMode
previousMode
=
mSizeMode
;
if
(
aMode
=
=
nsSizeMode_Normal
)
{
if
(
[
mWindow
isMiniaturized
]
)
[
mWindow
deminiaturize
:
nil
]
;
else
if
(
previousMode
=
=
nsSizeMode_Maximized
&
&
[
mWindow
isZoomed
]
)
[
mWindow
zoom
:
nil
]
;
}
else
if
(
aMode
=
=
nsSizeMode_Minimized
)
{
if
(
!
[
mWindow
isMiniaturized
]
)
[
mWindow
miniaturize
:
nil
]
;
}
else
if
(
aMode
=
=
nsSizeMode_Maximized
)
{
if
(
[
mWindow
isMiniaturized
]
)
[
mWindow
deminiaturize
:
nil
]
;
if
(
!
[
mWindow
isZoomed
]
)
[
mWindow
zoom
:
nil
]
;
}
else
if
(
aMode
=
=
nsSizeMode_Fullscreen
)
{
if
(
!
mInFullScreenMode
)
MakeFullScreen
(
true
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
typedef
CGSSpaceID
(
*
CGSGetActiveSpaceFunc
)
(
CGSConnection
cid
)
;
static
CGSGetActiveSpaceFunc
GetCGSGetActiveSpaceFunc
(
)
{
static
CGSGetActiveSpaceFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSGetActiveSpaceFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSGetActiveSpace
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
CFArrayRef
(
*
CGSCopyManagedDisplaySpacesFunc
)
(
CGSConnection
cid
)
;
static
CGSCopyManagedDisplaySpacesFunc
GetCGSCopyManagedDisplaySpacesFunc
(
)
{
static
CGSCopyManagedDisplaySpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSCopyManagedDisplaySpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSCopyManagedDisplaySpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
CFArrayRef
(
*
CGSCopySpacesForWindowsFunc
)
(
CGSConnection
cid
CGSSpaceMask
mask
CFArrayRef
windowIDs
)
;
static
CGSCopySpacesForWindowsFunc
GetCGSCopySpacesForWindowsFunc
(
)
{
static
CGSCopySpacesForWindowsFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSCopySpacesForWindowsFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSCopySpacesForWindows
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
void
(
*
CGSAddWindowsToSpacesFunc
)
(
CGSConnection
cid
CFArrayRef
windowIDs
CFArrayRef
spaceIDs
)
;
static
CGSAddWindowsToSpacesFunc
GetCGSAddWindowsToSpacesFunc
(
)
{
static
CGSAddWindowsToSpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSAddWindowsToSpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSAddWindowsToSpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
typedef
void
(
*
CGSRemoveWindowsFromSpacesFunc
)
(
CGSConnection
cid
CFArrayRef
windowIDs
CFArrayRef
spaceIDs
)
;
static
CGSRemoveWindowsFromSpacesFunc
GetCGSRemoveWindowsFromSpacesFunc
(
)
{
static
CGSRemoveWindowsFromSpacesFunc
func
=
nullptr
;
static
bool
lookedUpFunc
=
false
;
if
(
!
lookedUpFunc
)
{
func
=
(
CGSRemoveWindowsFromSpacesFunc
)
dlsym
(
RTLD_DEFAULT
"
CGSRemoveWindowsFromSpaces
"
)
;
lookedUpFunc
=
true
;
}
return
func
;
}
void
nsCocoaWindow
:
:
GetWorkspaceID
(
nsAString
&
workspaceID
)
{
workspaceID
.
Truncate
(
)
;
int32_t
sid
=
GetWorkspaceID
(
)
;
if
(
sid
!
=
0
)
{
workspaceID
.
AppendInt
(
sid
)
;
}
}
int32_t
nsCocoaWindow
:
:
GetWorkspaceID
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
CGSSpaceID
sid
=
0
;
if
(
!
nsCocoaFeatures
:
:
OnElCapitanOrLater
(
)
)
{
return
sid
;
}
CGSCopySpacesForWindowsFunc
CopySpacesForWindows
=
GetCGSCopySpacesForWindowsFunc
(
)
;
if
(
!
CopySpacesForWindows
)
{
return
sid
;
}
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
NSArray
<
NSNumber
*
>
*
spaceIDs
=
CFBridgingRelease
(
CopySpacesForWindows
(
cid
kCGSAllSpacesMask
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
)
)
;
if
(
[
spaceIDs
count
]
)
{
sid
=
[
spaceIDs
[
0
]
integerValue
]
;
}
else
{
CGSGetActiveSpaceFunc
GetActiveSpace
=
GetCGSGetActiveSpaceFunc
(
)
;
if
(
GetActiveSpace
)
{
sid
=
GetActiveSpace
(
cid
)
;
}
}
return
sid
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
MoveToWorkspace
(
const
nsAString
&
workspaceIDStr
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
nsCocoaFeatures
:
:
OnElCapitanOrLater
(
)
)
{
return
;
}
if
(
[
NSScreen
screensHaveSeparateSpaces
]
&
&
[
[
NSScreen
screens
]
count
]
>
1
)
{
return
;
}
nsresult
rv
=
NS_OK
;
int32_t
workspaceID
=
workspaceIDStr
.
ToInteger
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
int32_t
currentSpace
=
GetWorkspaceID
(
)
;
if
(
!
workspaceID
|
|
workspaceID
=
=
currentSpace
)
{
return
;
}
CGSCopyManagedDisplaySpacesFunc
CopyManagedDisplaySpaces
=
GetCGSCopyManagedDisplaySpacesFunc
(
)
;
CGSAddWindowsToSpacesFunc
AddWindowsToSpaces
=
GetCGSAddWindowsToSpacesFunc
(
)
;
CGSRemoveWindowsFromSpacesFunc
RemoveWindowsFromSpaces
=
GetCGSRemoveWindowsFromSpacesFunc
(
)
;
if
(
!
CopyManagedDisplaySpaces
|
|
!
AddWindowsToSpaces
|
|
!
RemoveWindowsFromSpaces
)
{
return
;
}
NSArray
*
displaySpacesInfo
=
CFBridgingRelease
(
CopyManagedDisplaySpaces
(
cid
)
)
;
BOOL
found
=
false
;
for
(
NSDictionary
<
NSString
*
id
>
*
spacesInfo
in
displaySpacesInfo
)
{
NSArray
<
NSNumber
*
>
*
sids
=
[
spacesInfo
[
CGSSpacesKey
]
valueForKey
:
CGSSpaceIDKey
]
;
for
(
NSNumber
*
sid
in
sids
)
{
if
(
(
int
)
[
sid
integerValue
]
=
=
workspaceID
)
{
found
=
true
;
break
;
}
}
if
(
found
)
{
break
;
}
}
if
(
!
found
)
{
return
;
}
AddWindowsToSpaces
(
cid
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
(
__bridge
CFArrayRef
)
[
(
workspaceID
)
]
)
;
RemoveWindowsFromSpaces
(
cid
(
__bridge
CFArrayRef
)
[
(
[
mWindow
windowNumber
]
)
]
(
__bridge
CFArrayRef
)
[
(
currentSpace
)
]
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SuppressAnimation
(
bool
aSuppress
)
{
if
(
[
mWindow
respondsToSelector
:
selector
(
setAnimationBehavior
:
)
]
)
{
if
(
aSuppress
)
{
[
mWindow
setIsAnimationSuppressed
:
YES
]
;
[
mWindow
setAnimationBehavior
:
NSWindowAnimationBehaviorNone
]
;
}
else
{
[
mWindow
setIsAnimationSuppressed
:
NO
]
;
[
mWindow
setAnimationBehavior
:
mWindowAnimationBehavior
]
;
}
}
}
void
nsCocoaWindow
:
:
HideWindowChrome
(
bool
aShouldHide
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
|
|
!
mWindowMadeHere
|
|
(
mWindowType
!
=
eWindowType_toplevel
&
&
mWindowType
!
=
eWindowType_dialog
)
)
return
;
BOOL
isVisible
=
[
mWindow
isVisible
]
;
NSArray
*
childWindows
=
[
mWindow
childWindows
]
;
NSEnumerator
*
enumerator
=
[
childWindows
objectEnumerator
]
;
NSWindow
*
child
=
nil
;
while
(
(
child
=
[
enumerator
nextObject
]
)
)
{
[
mWindow
removeChildWindow
:
child
]
;
}
NSArray
<
NSView
*
>
*
contentViewContents
=
[
mWindow
contentViewContents
]
;
for
(
NSView
*
view
in
contentViewContents
)
{
[
view
removeFromSuperviewWithoutNeedingDisplay
]
;
}
NSMutableDictionary
*
state
=
[
mWindow
exportState
]
;
NSRect
frameRect
=
[
mWindow
frame
]
;
DestroyNativeWindow
(
)
;
nsresult
rv
=
CreateNativeWindow
(
frameRect
aShouldHide
?
eBorderStyle_none
:
mBorderStyle
true
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
[
mWindow
importState
:
state
]
;
for
(
NSView
*
view
in
contentViewContents
)
{
[
[
mWindow
contentView
]
addSubview
:
view
]
;
}
enumerator
=
[
childWindows
objectEnumerator
]
;
while
(
(
child
=
[
enumerator
nextObject
]
)
)
{
[
mWindow
addChildWindow
:
child
ordered
:
NSWindowAbove
]
;
}
if
(
isVisible
)
{
bool
wasAnimationSuppressed
=
mIsAnimationSuppressed
;
mIsAnimationSuppressed
=
true
;
Show
(
true
)
;
mIsAnimationSuppressed
=
wasAnimationSuppressed
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
class
FullscreenTransitionData
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
FullscreenTransitionData
(
NSWindow
*
aWindow
)
:
mTransitionWindow
(
aWindow
)
{
}
NSWindow
*
mTransitionWindow
;
private
:
virtual
~
FullscreenTransitionData
(
)
{
[
mTransitionWindow
close
]
;
}
}
;
NS_IMPL_ISUPPORTS0
(
FullscreenTransitionData
)
interface
FullscreenTransitionDelegate
:
NSObject
<
NSAnimationDelegate
>
{
public
nsCocoaWindow
*
mWindow
;
nsIRunnable
*
mCallback
;
}
end
implementation
FullscreenTransitionDelegate
-
(
void
)
cleanupAndDispatch
:
(
NSAnimation
*
)
animation
{
[
animation
setDelegate
:
nil
]
;
[
self
autorelease
]
;
NS_DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
(
mCallback
)
)
;
}
-
(
void
)
animationDidEnd
:
(
NSAnimation
*
)
animation
{
MOZ_ASSERT
(
animation
=
=
mWindow
-
>
FullscreenTransitionAnimation
(
)
"
Should
be
handling
the
only
animation
on
the
window
"
)
;
mWindow
-
>
ReleaseFullscreenTransitionAnimation
(
)
;
[
self
cleanupAndDispatch
:
animation
]
;
}
-
(
void
)
animationDidStop
:
(
NSAnimation
*
)
animation
{
[
self
cleanupAndDispatch
:
animation
]
;
}
end
static
bool
AlwaysUsesNativeFullScreen
(
)
{
return
Preferences
:
:
GetBool
(
"
full
-
screen
-
api
.
macos
-
native
-
full
-
screen
"
false
)
;
}
bool
nsCocoaWindow
:
:
PrepareForFullscreenTransition
(
nsISupports
*
*
aData
)
{
if
(
AlwaysUsesNativeFullScreen
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIScreen
>
widgetScreen
=
GetWidgetScreen
(
)
;
NSScreen
*
cocoaScreen
=
ScreenHelperCocoa
:
:
CocoaScreenForScreen
(
widgetScreen
)
;
NSWindow
*
win
=
[
[
NSWindow
alloc
]
initWithContentRect
:
[
cocoaScreen
frame
]
styleMask
:
NSBorderlessWindowMask
backing
:
NSBackingStoreBuffered
defer
:
YES
]
;
[
win
setBackgroundColor
:
[
NSColor
blackColor
]
]
;
[
win
setAlphaValue
:
0
]
;
[
win
setIgnoresMouseEvents
:
YES
]
;
[
win
setLevel
:
NSScreenSaverWindowLevel
]
;
[
win
makeKeyAndOrderFront
:
nil
]
;
auto
data
=
new
FullscreenTransitionData
(
win
)
;
*
aData
=
data
;
NS_ADDREF
(
data
)
;
return
true
;
}
void
nsCocoaWindow
:
:
PerformFullscreenTransition
(
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsISupports
*
aData
nsIRunnable
*
aCallback
)
{
auto
data
=
static_cast
<
FullscreenTransitionData
*
>
(
aData
)
;
FullscreenTransitionDelegate
*
delegate
=
[
[
FullscreenTransitionDelegate
alloc
]
init
]
;
delegate
-
>
mWindow
=
this
;
delegate
-
>
mCallback
=
nsCOMPtr
<
nsIRunnable
>
(
aCallback
)
.
forget
(
)
.
take
(
)
;
if
(
mFullscreenTransitionAnimation
)
{
[
mFullscreenTransitionAnimation
stopAnimation
]
;
ReleaseFullscreenTransitionAnimation
(
)
;
}
NSDictionary
*
dict
=
{
NSViewAnimationTargetKey
:
data
-
>
mTransitionWindow
NSViewAnimationEffectKey
:
aStage
=
=
eBeforeFullscreenToggle
?
NSViewAnimationFadeInEffect
:
NSViewAnimationFadeOutEffect
}
;
mFullscreenTransitionAnimation
=
[
[
NSViewAnimation
alloc
]
initWithViewAnimations
:
[
dict
]
]
;
[
mFullscreenTransitionAnimation
setDelegate
:
delegate
]
;
[
mFullscreenTransitionAnimation
setDuration
:
aDuration
/
1000
.
0
]
;
[
mFullscreenTransitionAnimation
startAnimation
]
;
}
void
nsCocoaWindow
:
:
WillEnterFullScreen
(
bool
aFullScreen
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
FullscreenWillChange
(
aFullScreen
)
;
}
UpdateFullscreenState
(
aFullScreen
true
)
;
}
void
nsCocoaWindow
:
:
EnteredFullScreen
(
bool
aFullScreen
bool
aNativeMode
)
{
mInFullScreenTransition
=
false
;
UpdateFullscreenState
(
aFullScreen
aNativeMode
)
;
}
void
nsCocoaWindow
:
:
UpdateFullscreenState
(
bool
aFullScreen
bool
aNativeMode
)
{
bool
wasInFullscreen
=
mInFullScreenMode
;
mInFullScreenMode
=
aFullScreen
;
if
(
aNativeMode
|
|
mInNativeFullScreenMode
)
{
mInNativeFullScreenMode
=
aFullScreen
;
}
DispatchSizeModeEvent
(
)
;
if
(
mWidgetListener
&
&
wasInFullscreen
!
=
aFullScreen
)
{
mWidgetListener
-
>
FullscreenChanged
(
aFullScreen
)
;
}
}
inline
bool
nsCocoaWindow
:
:
ShouldToggleNativeFullscreen
(
bool
aFullScreen
bool
aUseSystemTransition
)
{
NSWindowCollectionBehavior
colBehavior
=
[
mWindow
collectionBehavior
]
;
if
(
!
(
colBehavior
&
NSWindowCollectionBehaviorFullScreenPrimary
)
)
{
return
false
;
}
if
(
mInNativeFullScreenMode
)
{
return
true
;
}
if
(
!
aUseSystemTransition
)
{
return
false
;
}
return
aFullScreen
;
}
nsresult
nsCocoaWindow
:
:
MakeFullScreen
(
bool
aFullScreen
nsIScreen
*
aTargetScreen
)
{
return
DoMakeFullScreen
(
aFullScreen
AlwaysUsesNativeFullScreen
(
)
)
;
}
nsresult
nsCocoaWindow
:
:
MakeFullScreenWithNativeTransition
(
bool
aFullScreen
nsIScreen
*
aTargetScreen
)
{
return
DoMakeFullScreen
(
aFullScreen
true
)
;
}
nsresult
nsCocoaWindow
:
:
DoMakeFullScreen
(
bool
aFullScreen
bool
aUseSystemTransition
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
if
(
!
mWindow
)
{
return
NS_OK
;
}
if
(
mInFullScreenMode
=
=
aFullScreen
)
{
return
NS_OK
;
}
mInFullScreenTransition
=
true
;
if
(
ShouldToggleNativeFullscreen
(
aFullScreen
aUseSystemTransition
)
)
{
MOZ_ASSERT
(
mInNativeFullScreenMode
!
=
aFullScreen
"
We
shouldn
'
t
have
been
in
native
fullscreen
.
"
)
;
[
mWindow
toggleFullScreen
:
nil
]
;
}
else
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
FullscreenWillChange
(
aFullScreen
)
;
}
NSDisableScreenUpdates
(
)
;
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
aFullScreen
)
;
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
aFullScreen
)
;
NSEnableScreenUpdates
(
)
;
EnteredFullScreen
(
aFullScreen
false
)
;
}
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsCocoaWindow
:
:
DoResize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
bool
aConstrainToCurrentScreen
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
|
|
mInResize
)
{
return
;
}
auto
relockAspectRatio
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
mAspectRatioLocked
)
{
LockAspectRatio
(
true
)
;
}
}
)
;
AutoRestore
<
bool
>
reentrantResizeGuard
(
mInResize
)
;
mInResize
=
true
;
CGFloat
scale
=
BackingScaleFactor
(
)
;
int32_t
width
=
NSToIntRound
(
aWidth
*
scale
)
;
int32_t
height
=
NSToIntRound
(
aHeight
*
scale
)
;
ConstrainSize
(
&
width
&
height
)
;
DesktopIntRect
newBounds
(
NSToIntRound
(
aX
)
NSToIntRound
(
aY
)
NSToIntRound
(
width
/
scale
)
NSToIntRound
(
height
/
scale
)
)
;
FitRectToVisibleAreaForScreen
(
newBounds
aConstrainToCurrentScreen
?
[
mWindow
screen
]
:
nullptr
)
;
NSRect
newFrame
=
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
newBounds
)
;
NSRect
frame
=
[
mWindow
frame
]
;
BOOL
isMoving
=
newFrame
.
origin
.
x
!
=
frame
.
origin
.
x
|
|
newFrame
.
origin
.
y
!
=
frame
.
origin
.
y
;
BOOL
isResizing
=
newFrame
.
size
.
width
!
=
frame
.
size
.
width
|
|
newFrame
.
size
.
height
!
=
frame
.
size
.
height
;
if
(
!
isMoving
&
&
!
isResizing
)
{
return
;
}
[
mWindow
setFrame
:
newFrame
display
:
YES
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
Resize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
)
{
DoResize
(
aX
aY
aWidth
aHeight
aRepaint
false
)
;
}
void
nsCocoaWindow
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
double
invScale
=
1
.
0
/
BackingScaleFactor
(
)
;
DoResize
(
mBounds
.
x
*
invScale
mBounds
.
y
*
invScale
aWidth
aHeight
aRepaint
true
)
;
}
NSRect
nsCocoaWindow
:
:
GetClientCocoaRect
(
)
{
if
(
!
mWindow
)
{
return
NSZeroRect
;
}
return
[
mWindow
childViewRectForFrameRect
:
[
mWindow
frame
]
]
;
}
LayoutDeviceIntRect
nsCocoaWindow
:
:
GetClientBounds
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
CGFloat
scaleFactor
=
BackingScaleFactor
(
)
;
return
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
GetClientCocoaRect
(
)
scaleFactor
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
;
}
void
nsCocoaWindow
:
:
UpdateBounds
(
)
{
NSRect
frame
=
NSZeroRect
;
if
(
mWindow
)
{
frame
=
[
mWindow
frame
]
;
}
mBounds
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
frame
BackingScaleFactor
(
)
)
;
if
(
mPopupContentView
)
{
mPopupContentView
-
>
UpdateBoundsFromView
(
)
;
}
}
LayoutDeviceIntRect
nsCocoaWindow
:
:
GetScreenBounds
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
#
ifdef
DEBUG
LayoutDeviceIntRect
r
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
[
mWindow
frame
]
BackingScaleFactor
(
)
)
;
NS_ASSERTION
(
mWindow
&
&
mBounds
=
=
r
"
mBounds
out
of
sync
!
"
)
;
#
endif
return
mBounds
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
LayoutDeviceIntRect
(
0
0
0
0
)
)
;
}
double
nsCocoaWindow
:
:
GetDefaultScaleInternal
(
)
{
return
BackingScaleFactor
(
)
;
}
static
CGFloat
GetBackingScaleFactor
(
NSWindow
*
aWindow
)
{
NSRect
frame
=
[
aWindow
frame
]
;
if
(
frame
.
size
.
width
>
0
&
&
frame
.
size
.
height
>
0
)
{
return
nsCocoaUtils
:
:
GetBackingScaleFactor
(
aWindow
)
;
}
if
(
frame
.
size
.
width
=
=
0
)
{
frame
.
size
.
width
=
1
;
}
if
(
frame
.
size
.
height
=
=
0
)
{
frame
.
size
.
height
=
1
;
}
NSScreen
*
screen
=
FindTargetScreenForRect
(
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
frame
)
)
;
return
nsCocoaUtils
:
:
GetBackingScaleFactor
(
screen
)
;
}
CGFloat
nsCocoaWindow
:
:
BackingScaleFactor
(
)
{
if
(
mBackingScaleFactor
>
0
.
0
)
{
return
mBackingScaleFactor
;
}
if
(
!
mWindow
)
{
return
1
.
0
;
}
mBackingScaleFactor
=
GetBackingScaleFactor
(
mWindow
)
;
return
mBackingScaleFactor
;
}
void
nsCocoaWindow
:
:
BackingScaleFactorChanged
(
)
{
CGFloat
oldScale
=
mBackingScaleFactor
;
CGFloat
newScale
=
GetBackingScaleFactor
(
mWindow
)
;
if
(
mBackingScaleFactor
=
=
newScale
)
{
return
;
}
if
(
mBackingScaleFactor
>
0
.
0
)
{
double
scaleFactor
=
newScale
/
mBackingScaleFactor
;
mSizeConstraints
.
mMinSize
.
width
=
NSToIntRound
(
mSizeConstraints
.
mMinSize
.
width
*
scaleFactor
)
;
mSizeConstraints
.
mMinSize
.
height
=
NSToIntRound
(
mSizeConstraints
.
mMinSize
.
height
*
scaleFactor
)
;
if
(
mSizeConstraints
.
mMaxSize
.
width
<
NS_MAXSIZE
)
{
mSizeConstraints
.
mMaxSize
.
width
=
std
:
:
min
(
NS_MAXSIZE
NSToIntRound
(
mSizeConstraints
.
mMaxSize
.
width
*
scaleFactor
)
)
;
}
if
(
mSizeConstraints
.
mMaxSize
.
height
<
NS_MAXSIZE
)
{
mSizeConstraints
.
mMaxSize
.
height
=
std
:
:
min
(
NS_MAXSIZE
NSToIntRound
(
mSizeConstraints
.
mMaxSize
.
height
*
scaleFactor
)
)
;
}
}
mBackingScaleFactor
=
newScale
;
if
(
!
mWidgetListener
|
|
mWidgetListener
-
>
GetAppWindow
(
)
)
{
return
;
}
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
mWidgetListener
-
>
UIResolutionChanged
(
)
;
if
(
(
mWindowType
=
=
eWindowType_popup
)
&
&
(
mBackingScaleFactor
=
=
2
.
0
)
)
{
NSRect
frame
=
[
mWindow
frame
]
;
CGFloat
previousYOrigin
=
frame
.
origin
.
y
+
frame
.
size
.
height
;
frame
.
size
.
width
=
mBounds
.
Width
(
)
*
(
oldScale
/
newScale
)
;
frame
.
size
.
height
=
mBounds
.
Height
(
)
*
(
oldScale
/
newScale
)
;
frame
.
origin
.
y
=
previousYOrigin
-
frame
.
size
.
height
;
[
mWindow
setFrame
:
frame
display
:
NO
animate
:
NO
]
;
}
}
int32_t
nsCocoaWindow
:
:
RoundsWidgetCoordinatesTo
(
)
{
if
(
BackingScaleFactor
(
)
=
=
2
.
0
)
{
return
2
;
}
return
1
;
}
void
nsCocoaWindow
:
:
SetCursor
(
nsCursor
aDefaultCursor
imgIContainer
*
aCursorImage
uint32_t
aHotspotX
uint32_t
aHotspotY
)
{
if
(
mPopupContentView
)
mPopupContentView
-
>
SetCursor
(
aDefaultCursor
aCursorImage
aHotspotX
aHotspotY
)
;
}
nsresult
nsCocoaWindow
:
:
SetTitle
(
const
nsAString
&
aTitle
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
if
(
!
mWindow
)
{
return
NS_OK
;
}
const
nsString
&
strTitle
=
PromiseFlatString
(
aTitle
)
;
const
unichar
*
uniTitle
=
reinterpret_cast
<
const
unichar
*
>
(
strTitle
.
get
(
)
)
;
NSString
*
title
=
[
NSString
stringWithCharacters
:
uniTitle
length
:
strTitle
.
Length
(
)
]
;
if
(
[
mWindow
drawsContentsIntoWindowFrame
]
&
&
!
[
mWindow
wantsTitleDrawn
]
)
{
[
mWindow
disableSetNeedsDisplay
]
;
[
mWindow
setTitle
:
title
]
;
[
mWindow
enableSetNeedsDisplay
]
;
}
else
{
[
mWindow
setTitle
:
title
]
;
}
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsCocoaWindow
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
if
(
mPopupContentView
)
{
mPopupContentView
-
>
Invalidate
(
aRect
)
;
}
}
bool
nsCocoaWindow
:
:
DragEvent
(
unsigned
int
aMessage
mozilla
:
:
gfx
:
:
Point
aMouseGlobal
UInt16
aKeyModifiers
)
{
return
false
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
SendSetZLevelEvent
(
)
{
nsWindowZ
placement
=
nsWindowZTop
;
nsCOMPtr
<
nsIWidget
>
actualBelow
;
if
(
mWidgetListener
)
mWidgetListener
-
>
ZLevelChanged
(
true
&
placement
nullptr
getter_AddRefs
(
actualBelow
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
GetChildSheet
(
bool
aShown
nsIWidget
*
*
_retval
)
{
nsIWidget
*
child
=
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
WindowType
(
)
=
=
eWindowType_sheet
)
{
nsCocoaWindow
*
cocoaWindow
=
static_cast
<
nsCocoaWindow
*
>
(
child
)
;
if
(
cocoaWindow
-
>
mWindow
&
&
(
(
aShown
&
&
[
cocoaWindow
-
>
mWindow
isVisible
]
)
|
|
(
!
aShown
&
&
cocoaWindow
-
>
mSheetNeedsShow
)
)
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
cocoaWindow
;
widget
.
forget
(
_retval
)
;
return
NS_OK
;
}
}
child
=
child
-
>
GetNextSibling
(
)
;
}
*
_retval
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
GetRealParent
(
nsIWidget
*
*
parent
)
{
*
parent
=
mParent
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
GetIsSheet
(
bool
*
isSheet
)
{
mWindowType
=
=
eWindowType_sheet
?
*
isSheet
=
true
:
*
isSheet
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
GetSheetWindowParent
(
NSWindow
*
*
sheetWindowParent
)
{
*
sheetWindowParent
=
mSheetWindowParent
;
return
NS_OK
;
}
nsresult
nsCocoaWindow
:
:
DispatchEvent
(
WidgetGUIEvent
*
event
nsEventStatus
&
aStatus
)
{
aStatus
=
nsEventStatus_eIgnore
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
event
-
>
mWidget
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
if
(
mWidgetListener
)
aStatus
=
mWidgetListener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
return
NS_OK
;
}
static
nsSizeMode
GetWindowSizeMode
(
NSWindow
*
aWindow
bool
aFullScreen
)
{
if
(
aFullScreen
)
return
nsSizeMode_Fullscreen
;
if
(
[
aWindow
isMiniaturized
]
)
return
nsSizeMode_Minimized
;
if
(
(
[
aWindow
styleMask
]
&
NSResizableWindowMask
)
&
&
[
aWindow
isZoomed
]
)
return
nsSizeMode_Maximized
;
return
nsSizeMode_Normal
;
}
void
nsCocoaWindow
:
:
ReportMoveEvent
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mInReportMoveEvent
)
{
return
;
}
mInReportMoveEvent
=
true
;
UpdateBounds
(
)
;
if
(
mWindow
&
&
(
(
mSizeMode
=
=
nsSizeMode_Maximized
)
^
[
mWindow
isZoomed
]
)
)
{
DispatchSizeModeEvent
(
)
;
}
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
mInReportMoveEvent
=
false
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
DispatchSizeModeEvent
(
)
{
if
(
!
mWindow
)
{
return
;
}
nsSizeMode
newMode
=
GetWindowSizeMode
(
mWindow
mInFullScreenMode
)
;
if
(
mInFullScreenTransition
|
|
mSizeMode
=
=
newMode
)
{
return
;
}
mSizeMode
=
newMode
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
SizeModeChanged
(
newMode
)
;
}
}
void
nsCocoaWindow
:
:
DispatchOcclusionEvent
(
)
{
if
(
!
mWindow
)
{
return
;
}
bool
newOcclusionState
=
!
(
[
mWindow
occlusionState
]
&
NSWindowOcclusionStateVisible
)
;
if
(
mIsFullyOccluded
=
=
newOcclusionState
)
{
return
;
}
mIsFullyOccluded
=
newOcclusionState
;
if
(
mWidgetListener
)
{
mWidgetListener
-
>
OcclusionStateChanged
(
mIsFullyOccluded
)
;
}
if
(
mIsFullyOccluded
)
{
PauseCompositor
(
)
;
}
else
{
ResumeCompositor
(
)
;
}
}
void
nsCocoaWindow
:
:
ReportSizeEvent
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
UpdateBounds
(
)
;
if
(
mWidgetListener
)
{
LayoutDeviceIntRect
innerBounds
=
GetClientBounds
(
)
;
mWidgetListener
-
>
WindowResized
(
this
innerBounds
.
width
innerBounds
.
height
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
PauseCompositor
(
)
{
nsIWidget
*
mainChildView
=
static_cast
<
nsIWidget
*
>
(
[
[
mWindow
mainChildView
]
widget
]
)
;
if
(
!
mainChildView
)
{
return
;
}
CompositorBridgeChild
*
remoteRenderer
=
mainChildView
-
>
GetRemoteRenderer
(
)
;
if
(
!
remoteRenderer
)
{
return
;
}
remoteRenderer
-
>
SendPause
(
)
;
if
(
!
mWidgetListener
)
{
return
;
}
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
nsDocShell
*
docShell
=
presContext
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
docShell
-
>
SetIsActive
(
false
)
;
}
void
nsCocoaWindow
:
:
ResumeCompositor
(
)
{
nsIWidget
*
mainChildView
=
static_cast
<
nsIWidget
*
>
(
[
[
mWindow
mainChildView
]
widget
]
)
;
if
(
!
mainChildView
)
{
return
;
}
CompositorBridgeChild
*
remoteRenderer
=
mainChildView
-
>
GetRemoteRenderer
(
)
;
if
(
!
remoteRenderer
)
{
return
;
}
remoteRenderer
-
>
SendResume
(
)
;
if
(
!
mWidgetListener
)
{
return
;
}
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
nsDocShell
*
docShell
=
presContext
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
docShell
-
>
SetIsActive
(
true
)
;
}
void
nsCocoaWindow
:
:
SetMenuBar
(
nsMenuBarX
*
aMenuBar
)
{
if
(
mMenuBar
)
mMenuBar
-
>
SetParent
(
nullptr
)
;
if
(
!
mWindow
)
{
mMenuBar
=
nullptr
;
return
;
}
mMenuBar
=
aMenuBar
;
id
windowDelegate
=
[
mWindow
delegate
]
;
if
(
mMenuBar
&
&
(
(
!
gSomeMenuBarPainted
&
&
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
=
=
mMenuBar
)
|
|
(
windowDelegate
&
&
[
windowDelegate
toplevelActiveState
]
)
)
)
mMenuBar
-
>
Paint
(
)
;
}
void
nsCocoaWindow
:
:
SetFocus
(
Raise
aRaise
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
{
if
(
!
mWindow
)
return
;
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
SetFocus
(
aRaise
aCallerType
)
;
}
if
(
aRaise
=
=
Raise
:
:
Yes
&
&
(
[
mWindow
isVisible
]
|
|
[
mWindow
isMiniaturized
]
)
)
{
if
(
[
mWindow
isMiniaturized
]
)
{
[
mWindow
deminiaturize
:
nil
]
;
}
[
mWindow
makeKeyAndOrderFront
:
nil
]
;
SendSetZLevelEvent
(
)
;
}
}
LayoutDeviceIntPoint
nsCocoaWindow
:
:
WidgetToScreenOffset
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
return
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
GetClientCocoaRect
(
)
BackingScaleFactor
(
)
)
.
TopLeft
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntPoint
nsCocoaWindow
:
:
GetClientOffset
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
LayoutDeviceIntRect
clientRect
=
GetClientBounds
(
)
;
return
clientRect
.
TopLeft
(
)
-
mBounds
.
TopLeft
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntSize
nsCocoaWindow
:
:
ClientToWindowSize
(
const
LayoutDeviceIntSize
&
aClientSize
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
!
mWindow
)
return
LayoutDeviceIntSize
(
0
0
)
;
CGFloat
backingScale
=
BackingScaleFactor
(
)
;
LayoutDeviceIntRect
r
(
0
0
aClientSize
.
width
aClientSize
.
height
)
;
NSRect
rect
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
r
backingScale
)
;
NSUInteger
styleMask
=
[
mWindow
styleMask
]
;
styleMask
&
=
~
NSFullSizeContentViewWindowMask
;
NSRect
inflatedRect
=
[
NSWindow
frameRectForContentRect
:
rect
styleMask
:
styleMask
]
;
r
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
inflatedRect
backingScale
)
;
return
r
.
Size
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
LayoutDeviceIntSize
(
0
0
)
)
;
}
nsMenuBarX
*
nsCocoaWindow
:
:
GetMenuBar
(
)
{
return
mMenuBar
;
}
void
nsCocoaWindow
:
:
CaptureRollupEvents
(
nsIRollupListener
*
aListener
bool
aDoCapture
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
gRollupListener
=
nullptr
;
if
(
aDoCapture
)
{
if
(
!
[
NSApp
isActive
]
)
{
nsToolkit
:
:
GetToolkit
(
)
-
>
MonitorAllProcessMouseEvents
(
)
;
}
gRollupListener
=
aListener
;
if
(
mWindow
&
&
(
mWindowType
=
=
eWindowType_popup
)
)
SetPopupWindowLevel
(
)
;
}
else
{
nsToolkit
:
:
GetToolkit
(
)
-
>
StopMonitoringAllProcessMouseEvents
(
)
;
if
(
mWindow
&
&
(
mWindowType
=
=
eWindowType_popup
)
)
[
mWindow
setLevel
:
NSModalPanelWindowLevel
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
GetAttention
(
int32_t
aCycleCount
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
[
NSApp
requestUserAttention
:
NSInformationalRequest
]
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
bool
nsCocoaWindow
:
:
HasPendingInputEvent
(
)
{
return
nsChildView
:
:
DoHasPendingInputEvent
(
)
;
}
void
nsCocoaWindow
:
:
SetWindowShadowStyle
(
StyleWindowShadow
aStyle
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
return
;
mShadowStyle
=
aStyle
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
[
mWindow
setHasShadow
:
aStyle
!
=
StyleWindowShadow
:
:
None
]
;
}
[
mWindow
setUseMenuStyle
:
(
aStyle
=
=
StyleWindowShadow
:
:
Menu
)
]
;
AdjustWindowShadow
(
)
;
SetWindowBackgroundBlur
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowOpacity
(
float
aOpacity
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
[
mWindow
setAlphaValue
:
(
CGFloat
)
aOpacity
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
inline
CGAffineTransform
GfxMatrixToCGAffineTransform
(
const
gfx
:
:
Matrix
&
m
)
{
CGAffineTransform
t
;
t
.
a
=
m
.
_11
;
t
.
b
=
m
.
_12
;
t
.
c
=
m
.
_21
;
t
.
d
=
m
.
_22
;
t
.
tx
=
m
.
_31
;
t
.
ty
=
m
.
_32
;
return
t
;
}
void
nsCocoaWindow
:
:
SetWindowTransform
(
const
gfx
:
:
Matrix
&
aTransform
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mWindow
)
{
return
;
}
if
(
!
[
mWindow
isVisible
]
|
|
NSIsEmptyRect
(
[
mWindow
frame
]
)
)
{
return
;
}
if
(
StaticPrefs
:
:
widget_window_transforms_disabled
(
)
)
{
return
;
}
gfx
:
:
Matrix
transform
=
aTransform
;
if
(
!
transform
.
Invert
(
)
)
{
transform
=
gfx
:
:
Matrix
(
)
;
}
bool
isIdentity
=
transform
.
IsIdentity
(
)
;
if
(
isIdentity
&
&
mWindowTransformIsIdentity
)
{
return
;
}
transform
.
PreTranslate
(
-
mBounds
.
x
-
mBounds
.
y
)
;
if
(
!
transform
.
HasNonTranslation
(
)
&
&
transform
.
HasNonIntegerTranslation
(
)
)
{
auto
snappedTranslation
=
gfx
:
:
IntPoint
:
:
Round
(
transform
.
GetTranslation
(
)
)
;
transform
=
gfx
:
:
Matrix
:
:
Translation
(
snappedTranslation
.
x
snappedTranslation
.
y
)
;
}
CGFloat
backingScale
=
BackingScaleFactor
(
)
;
transform
.
PreScale
(
backingScale
backingScale
)
;
transform
.
PostScale
(
1
/
backingScale
1
/
backingScale
)
;
CGSConnection
cid
=
_CGSDefaultConnection
(
)
;
CGSSetWindowTransform
(
cid
[
mWindow
windowNumber
]
GfxMatrixToCGAffineTransform
(
transform
)
)
;
mWindowTransformIsIdentity
=
isIdentity
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowMouseTransparent
(
bool
aIsTransparent
)
{
MOZ_ASSERT
(
mWindowType
=
=
eWindowType_popup
"
This
should
only
be
called
on
popup
windows
.
"
)
;
if
(
aIsTransparent
)
{
[
mWindow
setIgnoresMouseEvents
:
YES
]
;
}
else
{
[
mWindow
setIgnoresMouseEvents
:
NO
]
;
}
}
void
nsCocoaWindow
:
:
SetShowsToolbarButton
(
bool
aShow
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mWindow
)
[
mWindow
setShowsToolbarButton
:
aShow
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetSupportsNativeFullscreen
(
bool
aSupportsNativeFullscreen
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mWindow
)
{
NSWindowCollectionBehavior
newBehavior
=
[
mWindow
collectionBehavior
]
;
if
(
aSupportsNativeFullscreen
)
{
newBehavior
|
=
NSWindowCollectionBehaviorFullScreenPrimary
;
}
else
{
newBehavior
&
=
~
NSWindowCollectionBehaviorFullScreenPrimary
;
}
[
mWindow
setCollectionBehavior
:
newBehavior
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetWindowAnimationType
(
nsIWidget
:
:
WindowAnimationType
aType
)
{
mAnimationType
=
aType
;
}
void
nsCocoaWindow
:
:
SetDrawsTitle
(
bool
aDrawTitle
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
[
mWindow
drawsContentsIntoWindowFrame
]
)
{
[
mWindow
setWantsTitleDrawn
:
YES
]
;
}
else
{
[
mWindow
setWantsTitleDrawn
:
aDrawTitle
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetUseBrightTitlebarForeground
(
bool
aBrightForeground
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
mWindow
setUseBrightTitlebarForeground
:
aBrightForeground
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsresult
nsCocoaWindow
:
:
SetNonClientMargins
(
LayoutDeviceIntMargin
&
margins
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
SetDrawsInTitlebar
(
margins
.
top
=
=
0
)
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsCocoaWindow
:
:
SetDrawsInTitlebar
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mWindow
)
[
mWindow
setDrawsContentsIntoWindowFrame
:
aState
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
NS_IMETHODIMP
nsCocoaWindow
:
:
SynthesizeNativeMouseEvent
(
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
uint32_t
aModifierFlags
nsIObserver
*
aObserver
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
AutoObserverNotifier
notifier
(
aObserver
"
mouseevent
"
)
;
if
(
mPopupContentView
)
return
mPopupContentView
-
>
SynthesizeNativeMouseEvent
(
aPoint
aNativeMessage
aModifierFlags
nullptr
)
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsCocoaWindow
:
:
LockAspectRatio
(
bool
aShouldLock
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
aShouldLock
)
{
[
mWindow
setContentAspectRatio
:
mWindow
.
frame
.
size
]
;
mAspectRatioLocked
=
true
;
}
else
{
[
mWindow
setResizeIncrements
:
NSMakeSize
(
1
.
0
1
.
0
)
]
;
mAspectRatioLocked
=
false
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
UpdateThemeGeometries
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mPopupContentView
)
{
return
mPopupContentView
-
>
UpdateThemeGeometries
(
aThemeGeometries
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsCocoaWindow
:
:
SetPopupWindowLevel
(
)
{
if
(
!
mWindow
)
return
;
if
(
mPopupLevel
=
=
ePopupLevelFloating
)
{
[
mWindow
setLevel
:
NSFloatingWindowLevel
]
;
[
mWindow
setHidesOnDeactivate
:
YES
]
;
}
else
{
[
mWindow
setLevel
:
NSPopUpMenuWindowLevel
]
;
[
mWindow
setHidesOnDeactivate
:
NO
]
;
}
}
void
nsCocoaWindow
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mInputContext
=
aContext
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
nsCocoaWindow
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
if
(
NS_WARN_IF
(
!
nsIWidget
:
:
GetEditCommands
(
aType
aEvent
aCommands
)
)
)
{
return
false
;
}
NativeKeyBindings
*
keyBindings
=
NativeKeyBindings
:
:
GetInstance
(
aType
)
;
keyBindings
-
>
GetEditCommands
(
aEvent
aCommands
)
;
return
true
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateTopLevelWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsCocoaWindow
(
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsIWidget
>
nsIWidget
:
:
CreateChildWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
window
=
new
nsChildView
(
)
;
return
window
.
forget
(
)
;
}
implementation
WindowDelegate
+
(
void
)
paintMenubarForWindow
:
(
NSWindow
*
)
aWindow
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
id
windowDelegate
=
[
aWindow
delegate
]
;
if
(
[
windowDelegate
class
]
!
=
[
self
class
]
)
return
;
nsCocoaWindow
*
geckoWidget
=
[
windowDelegate
geckoWidget
]
;
NS_ASSERTION
(
geckoWidget
"
Window
delegate
not
returning
a
gecko
widget
!
"
)
;
nsMenuBarX
*
geckoMenuBar
=
geckoWidget
-
>
GetMenuBar
(
)
;
if
(
geckoMenuBar
)
{
geckoMenuBar
-
>
Paint
(
)
;
}
else
{
if
(
!
sApplicationMenu
)
return
;
NSMenu
*
mainMenu
=
[
NSApp
mainMenu
]
;
NS_ASSERTION
(
[
mainMenu
numberOfItems
]
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
GeckoNSMenu
*
newMenuBar
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
"
MainMenuBar
"
]
;
NSMenuItem
*
firstMenuItem
=
[
[
mainMenu
itemAtIndex
:
0
]
retain
]
;
[
mainMenu
removeItemAtIndex
:
0
]
;
[
newMenuBar
insertItem
:
firstMenuItem
atIndex
:
0
]
;
[
firstMenuItem
release
]
;
[
NSApp
setMainMenu
:
newMenuBar
]
;
[
newMenuBar
release
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
id
)
initWithGeckoWindow
:
(
nsCocoaWindow
*
)
geckoWind
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
[
super
init
]
;
mGeckoWindow
=
geckoWind
;
mToplevelActiveState
=
false
;
mHasEverBeenZoomed
=
false
;
return
self
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
NSSize
)
windowWillResize
:
(
NSWindow
*
)
sender
toSize
:
(
NSSize
)
proposedFrameSize
{
RollUpPopups
(
)
;
return
proposedFrameSize
;
}
-
(
void
)
windowDidResize
:
(
NSNotification
*
)
aNotification
{
BaseWindow
*
window
=
[
aNotification
object
]
;
[
window
updateTrackingArea
]
;
if
(
!
mGeckoWindow
)
return
;
mGeckoWindow
-
>
DispatchSizeModeEvent
(
)
;
mGeckoWindow
-
>
ReportSizeEvent
(
)
;
}
-
(
void
)
windowDidChangeScreen
:
(
NSNotification
*
)
aNotification
{
if
(
!
mGeckoWindow
)
return
;
NSWindow
*
window
=
(
NSWindow
*
)
[
aNotification
object
]
;
if
(
[
window
respondsToSelector
:
selector
(
backingScaleFactor
)
]
)
{
if
(
GetBackingScaleFactor
(
window
)
!
=
mGeckoWindow
-
>
BackingScaleFactor
(
)
)
{
mGeckoWindow
-
>
BackingScaleFactorChanged
(
)
;
}
}
mGeckoWindow
-
>
ReportMoveEvent
(
)
;
}
-
(
NSArray
<
NSWindow
*
>
*
)
customWindowsToEnterFullScreenForWindow
:
(
NSWindow
*
)
window
{
return
AlwaysUsesNativeFullScreen
(
)
?
[
window
]
:
nil
;
}
-
(
void
)
window
:
(
NSWindow
*
)
window
startCustomAnimationToEnterFullScreenOnScreen
:
(
NSScreen
*
)
screen
withDuration
:
(
NSTimeInterval
)
duration
{
[
window
setFrame
:
[
screen
frame
]
display
:
YES
]
;
}
-
(
void
)
windowWillEnterFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
WillEnterFullScreen
(
true
)
;
}
-
(
void
)
windowDidEnterFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
EnteredFullScreen
(
true
)
;
NSWindow
*
window
=
(
NSWindow
*
)
[
notification
object
]
;
NSView
*
frameView
=
[
[
window
contentView
]
superview
]
;
NSView
*
titlebarView
=
nil
;
NSView
*
titlebarContainerView
=
nil
;
if
(
[
frameView
respondsToSelector
:
selector
(
titlebarView
)
]
)
{
titlebarView
=
[
frameView
titlebarView
]
;
}
if
(
[
frameView
respondsToSelector
:
selector
(
titlebarContainerView
)
]
)
{
titlebarContainerView
=
[
frameView
titlebarContainerView
]
;
}
if
(
[
titlebarView
respondsToSelector
:
selector
(
setTransparent
:
)
]
)
{
[
titlebarView
setTransparent
:
NO
]
;
}
if
(
[
titlebarContainerView
respondsToSelector
:
selector
(
setTransparent
:
)
]
)
{
[
titlebarContainerView
setTransparent
:
NO
]
;
}
}
-
(
void
)
windowWillExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
WillEnterFullScreen
(
false
)
;
}
-
(
void
)
windowDidExitFullScreen
:
(
NSNotification
*
)
notification
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
EnteredFullScreen
(
false
)
;
}
-
(
void
)
windowDidFailToEnterFullScreen
:
(
NSWindow
*
)
window
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
EnteredFullScreen
(
false
)
;
}
-
(
void
)
windowDidFailToExitFullScreen
:
(
NSWindow
*
)
window
{
if
(
!
mGeckoWindow
)
{
return
;
}
mGeckoWindow
-
>
EnteredFullScreen
(
true
)
;
}
-
(
void
)
windowDidBecomeMain
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
[
NSApp
_isRunningAppModal
]
)
return
;
NSWindow
*
window
=
[
aNotification
object
]
;
if
(
window
)
[
WindowDelegate
paintMenubarForWindow
:
window
]
;
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
[
(
ToolbarWindow
*
)
window
windowMainStateChanged
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
windowDidResignMain
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
if
(
[
NSApp
_isRunningAppModal
]
)
return
;
RefPtr
<
nsMenuBarX
>
hiddenWindowMenuBar
=
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
;
if
(
hiddenWindowMenuBar
)
{
hiddenWindowMenuBar
-
>
Paint
(
)
;
}
NSWindow
*
window
=
[
aNotification
object
]
;
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
[
(
ToolbarWindow
*
)
window
windowMainStateChanged
]
;
}
}
-
(
void
)
windowDidBecomeKey
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
NSWindow
*
window
=
[
aNotification
object
]
;
if
(
[
window
isSheet
]
)
[
WindowDelegate
paintMenubarForWindow
:
window
]
;
nsChildView
*
mainChildView
=
static_cast
<
nsChildView
*
>
(
[
[
(
BaseWindow
*
)
window
mainChildView
]
widget
]
)
;
if
(
mainChildView
)
{
if
(
mainChildView
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
windowDidResignKey
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
RollUpPopups
(
)
;
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
)
;
NSWindow
*
window
=
[
aNotification
object
]
;
if
(
[
window
isSheet
]
)
[
WindowDelegate
paintMenubarForWindow
:
[
NSApp
mainWindow
]
]
;
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
windowWillMove
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowDidMove
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
mGeckoWindow
-
>
ReportMoveEvent
(
)
;
}
-
(
BOOL
)
windowShouldClose
:
(
id
)
sender
{
nsIWidgetListener
*
listener
=
mGeckoWindow
?
mGeckoWindow
-
>
GetWidgetListener
(
)
:
nullptr
;
if
(
listener
)
listener
-
>
RequestWindowClose
(
mGeckoWindow
)
;
return
NO
;
}
-
(
void
)
windowWillClose
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowWillMiniaturize
:
(
NSNotification
*
)
aNotification
{
RollUpPopups
(
)
;
}
-
(
void
)
windowDidMiniaturize
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
mGeckoWindow
-
>
DispatchSizeModeEvent
(
)
;
}
-
(
void
)
windowDidDeminiaturize
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
mGeckoWindow
-
>
DispatchSizeModeEvent
(
)
;
}
-
(
BOOL
)
windowShouldZoom
:
(
NSWindow
*
)
window
toFrame
:
(
NSRect
)
proposedFrame
{
if
(
!
mHasEverBeenZoomed
&
&
[
window
isZoomed
]
)
return
NO
;
mHasEverBeenZoomed
=
YES
;
return
YES
;
}
-
(
NSRect
)
window
:
(
NSWindow
*
)
window
willPositionSheet
:
(
NSWindow
*
)
sheet
usingRect
:
(
NSRect
)
rect
{
if
(
[
window
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
rect
.
origin
.
y
=
[
(
ToolbarWindow
*
)
window
sheetAttachmentPosition
]
;
}
return
rect
;
}
-
(
void
)
didEndSheet
:
(
NSWindow
*
)
sheet
returnCode
:
(
int
)
returnCode
contextInfo
:
(
void
*
)
contextInfo
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
TopLevelWindowData
deactivateInWindow
:
sheet
]
;
[
sheet
orderOut
:
self
]
;
if
(
contextInfo
)
[
TopLevelWindowData
activateInWindow
:
(
NSWindow
*
)
contextInfo
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
windowDidChangeBackingProperties
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSWindow
*
window
=
(
NSWindow
*
)
[
aNotification
object
]
;
if
(
[
window
respondsToSelector
:
selector
(
backingScaleFactor
)
]
)
{
CGFloat
oldFactor
=
[
[
[
aNotification
userInfo
]
objectForKey
:
"
NSBackingPropertyOldScaleFactorKey
"
]
doubleValue
]
;
if
(
[
window
backingScaleFactor
]
!
=
oldFactor
)
{
mGeckoWindow
-
>
BackingScaleFactorChanged
(
)
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
windowDidChangeOcclusionState
:
(
NSNotification
*
)
aNotification
{
if
(
mGeckoWindow
)
{
mGeckoWindow
-
>
DispatchOcclusionEvent
(
)
;
}
}
-
(
nsCocoaWindow
*
)
geckoWidget
{
return
mGeckoWindow
;
}
-
(
bool
)
toplevelActiveState
{
return
mToplevelActiveState
;
}
-
(
void
)
sendToplevelActivateEvents
{
if
(
!
mToplevelActiveState
&
&
mGeckoWindow
)
{
nsIWidgetListener
*
listener
=
mGeckoWindow
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
WindowActivated
(
)
;
}
mToplevelActiveState
=
true
;
}
}
-
(
void
)
sendToplevelDeactivateEvents
{
if
(
mToplevelActiveState
&
&
mGeckoWindow
)
{
nsIWidgetListener
*
listener
=
mGeckoWindow
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
WindowDeactivated
(
)
;
}
mToplevelActiveState
=
false
;
}
}
end
interface
NSView
(
FrameViewMethodSwizzling
)
-
(
NSPoint
)
FrameView__closeButtonOrigin
;
-
(
NSPoint
)
FrameView__fullScreenButtonOrigin
;
-
(
CGFloat
)
FrameView__titlebarHeight
;
end
implementation
NSView
(
FrameViewMethodSwizzling
)
-
(
NSPoint
)
FrameView__closeButtonOrigin
{
NSPoint
defaultPosition
=
[
self
FrameView__closeButtonOrigin
]
;
if
(
[
[
self
window
]
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
return
[
(
ToolbarWindow
*
)
[
self
window
]
windowButtonsPositionWithDefaultPosition
:
defaultPosition
]
;
}
return
defaultPosition
;
}
-
(
NSPoint
)
FrameView__fullScreenButtonOrigin
{
NSPoint
defaultPosition
=
[
self
FrameView__fullScreenButtonOrigin
]
;
if
(
[
[
self
window
]
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
return
[
(
ToolbarWindow
*
)
[
self
window
]
fullScreenButtonPositionWithDefaultPosition
:
defaultPosition
]
;
}
return
defaultPosition
;
}
-
(
CGFloat
)
FrameView__titlebarHeight
{
CGFloat
height
=
[
self
FrameView__titlebarHeight
]
;
if
(
[
[
self
window
]
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
{
ToolbarWindow
*
win
=
(
ToolbarWindow
*
)
[
self
window
]
;
CGFloat
frameHeight
=
[
self
frame
]
.
size
.
height
;
NSPoint
pointAboveWindow
=
{
0
.
0
frameHeight
}
;
CGFloat
windowButtonY
=
[
win
windowButtonsPositionWithDefaultPosition
:
pointAboveWindow
]
.
y
;
CGFloat
fullScreenButtonY
=
[
win
fullScreenButtonPositionWithDefaultPosition
:
pointAboveWindow
]
.
y
;
CGFloat
maxDistanceFromWindowTopToButtonBottom
=
std
:
:
max
(
frameHeight
-
windowButtonY
frameHeight
-
fullScreenButtonY
)
;
height
=
std
:
:
max
(
height
maxDistanceFromWindowTopToButtonBottom
)
;
}
return
height
;
}
end
static
NSMutableSet
*
gSwizzledFrameViewClasses
=
nil
;
interface
NSWindow
(
PrivateSetNeedsDisplayInRectMethod
)
-
(
void
)
_setNeedsDisplayInRect
:
(
NSRect
)
aRect
;
end
interface
NSView
(
PrivateAddKnownSubviewMethod
)
-
(
void
)
_addKnownSubview
:
(
NSView
*
)
aView
positioned
:
(
NSWindowOrderingMode
)
place
relativeTo
:
(
NSView
*
)
otherView
;
end
#
if
!
defined
(
MAC_OS_X_VERSION_10_10
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_10
interface
NSImage
(
CapInsets
)
-
(
void
)
setCapInsets
:
(
NSEdgeInsets
)
capInsets
;
end
#
endif
#
if
!
defined
(
MAC_OS_X_VERSION_10_8
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_8
interface
NSImage
(
ImageCreationWithDrawingHandler
)
+
(
NSImage
*
)
imageWithSize
:
(
NSSize
)
size
flipped
:
(
BOOL
)
drawingHandlerShouldBeCalledWithFlippedContext
drawingHandler
:
(
BOOL
(
^
)
(
NSRect
dstRect
)
)
drawingHandler
;
end
#
endif
#
if
!
defined
(
MAC_OS_X_VERSION_10_12_2
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_12_2
interface
NSView
(
NSTouchBarProvider
)
-
(
NSTouchBar
*
)
makeTouchBar
;
end
#
endif
interface
NSView
(
NSVisualEffectViewSetMaskImage
)
-
(
void
)
setMaskImage
:
(
NSImage
*
)
image
;
end
interface
BaseWindow
(
Private
)
-
(
void
)
removeTrackingArea
;
-
(
void
)
cursorUpdated
:
(
NSEvent
*
)
aEvent
;
-
(
void
)
reflowTitlebarElements
;
end
implementation
BaseWindow
+
(
Class
)
frameViewClassForStyleMask
:
(
NSUInteger
)
styleMask
{
Class
frameViewClass
=
[
super
frameViewClassForStyleMask
:
styleMask
]
;
if
(
!
gSwizzledFrameViewClasses
)
{
gSwizzledFrameViewClasses
=
[
[
NSMutableSet
setWithCapacity
:
3
]
retain
]
;
if
(
!
gSwizzledFrameViewClasses
)
{
return
frameViewClass
;
}
}
static
IMP
our_closeButtonOrigin
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__closeButtonOrigin
)
)
;
static
IMP
our_fullScreenButtonOrigin
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__fullScreenButtonOrigin
)
)
;
static
IMP
our_titlebarHeight
=
class_getMethodImplementation
(
[
NSView
class
]
selector
(
FrameView__titlebarHeight
)
)
;
if
(
!
[
gSwizzledFrameViewClasses
containsObject
:
frameViewClass
]
)
{
IMP
_closeButtonOrigin
=
class_getMethodImplementation
(
frameViewClass
selector
(
_closeButtonOrigin
)
)
;
if
(
_closeButtonOrigin
&
&
_closeButtonOrigin
!
=
our_closeButtonOrigin
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_closeButtonOrigin
)
selector
(
FrameView__closeButtonOrigin
)
)
;
}
IMP
_fullScreenButtonOrigin
=
class_getMethodImplementation
(
frameViewClass
selector
(
_fullScreenButtonOrigin
)
)
;
if
(
_fullScreenButtonOrigin
&
&
_fullScreenButtonOrigin
!
=
our_fullScreenButtonOrigin
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_fullScreenButtonOrigin
)
selector
(
FrameView__fullScreenButtonOrigin
)
)
;
}
IMP
_titlebarHeight
=
class_getMethodImplementation
(
frameViewClass
selector
(
_titlebarHeight
)
)
;
if
(
_titlebarHeight
&
&
_titlebarHeight
!
=
our_titlebarHeight
)
{
nsToolkit
:
:
SwizzleMethods
(
frameViewClass
selector
(
_titlebarHeight
)
selector
(
FrameView__titlebarHeight
)
)
;
}
[
gSwizzledFrameViewClasses
addObject
:
frameViewClass
]
;
}
return
frameViewClass
;
}
-
(
id
)
initWithContentRect
:
(
NSRect
)
aContentRect
styleMask
:
(
NSUInteger
)
aStyle
backing
:
(
NSBackingStoreType
)
aBufferingType
defer
:
(
BOOL
)
aFlag
{
mDrawsIntoWindowFrame
=
NO
;
[
super
initWithContentRect
:
aContentRect
styleMask
:
aStyle
backing
:
aBufferingType
defer
:
aFlag
]
;
mState
=
nil
;
mDisabledNeedsDisplay
=
NO
;
mTrackingArea
=
nil
;
mDirtyRect
=
NSZeroRect
;
mBeingShown
=
NO
;
mDrawTitle
=
NO
;
mBrightTitlebarForeground
=
NO
;
mUseMenuStyle
=
NO
;
mTouchBar
=
nil
;
mIsAnimationSuppressed
=
NO
;
[
self
updateTrackingArea
]
;
return
self
;
}
static
NSImage
*
GetMenuMaskImage
(
)
{
CGFloat
radius
=
4
.
0f
;
NSEdgeInsets
insets
=
{
5
5
5
5
}
;
NSSize
maskSize
=
{
12
12
}
;
NSImage
*
maskImage
=
[
NSImage
imageWithSize
:
maskSize
flipped
:
YES
drawingHandler
:
^
BOOL
(
NSRect
dstRect
)
{
NSBezierPath
*
path
=
[
NSBezierPath
bezierPathWithRoundedRect
:
dstRect
xRadius
:
radius
yRadius
:
radius
]
;
[
[
NSColor
colorWithDeviceWhite
:
1
.
0
alpha
:
1
.
0
]
set
]
;
[
path
fill
]
;
return
YES
;
}
]
;
[
maskImage
setCapInsets
:
insets
]
;
return
maskImage
;
}
-
(
void
)
swapOutChildViewWrapper
:
(
NSView
*
)
aNewWrapper
{
[
aNewWrapper
setFrame
:
[
[
self
contentView
]
frame
]
]
;
NSView
*
childView
=
[
[
self
mainChildView
]
retain
]
;
[
childView
removeFromSuperview
]
;
[
aNewWrapper
addSubview
:
childView
]
;
[
childView
release
]
;
[
super
setContentView
:
aNewWrapper
]
;
}
-
(
void
)
setUseMenuStyle
:
(
BOOL
)
aValue
{
if
(
!
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
return
;
}
if
(
aValue
&
&
!
mUseMenuStyle
)
{
NSView
*
effectView
=
VibrancyManager
:
:
CreateEffectView
(
VibrancyType
:
:
MENU
YES
)
;
if
(
[
effectView
respondsToSelector
:
selector
(
setMaskImage
:
)
]
)
{
[
effectView
setMaskImage
:
GetMenuMaskImage
(
)
]
;
}
[
self
swapOutChildViewWrapper
:
effectView
]
;
[
effectView
release
]
;
}
else
if
(
mUseMenuStyle
&
&
!
aValue
)
{
NSView
*
wrapper
=
[
[
NSView
alloc
]
initWithFrame
:
NSZeroRect
]
;
[
wrapper
setWantsLayer
:
YES
]
;
[
self
swapOutChildViewWrapper
:
wrapper
]
;
[
wrapper
release
]
;
}
mUseMenuStyle
=
aValue
;
}
-
(
NSTouchBar
*
)
makeTouchBar
{
mTouchBar
=
[
[
nsTouchBar
alloc
]
init
]
;
if
(
mTouchBar
)
{
sTouchBarIsInitialized
=
YES
;
}
return
mTouchBar
;
}
-
(
void
)
setBeingShown
:
(
BOOL
)
aValue
{
mBeingShown
=
aValue
;
}
-
(
BOOL
)
isBeingShown
{
return
mBeingShown
;
}
-
(
BOOL
)
isVisibleOrBeingShown
{
return
[
super
isVisible
]
|
|
mBeingShown
;
}
-
(
void
)
setIsAnimationSuppressed
:
(
BOOL
)
aValue
{
mIsAnimationSuppressed
=
aValue
;
}
-
(
BOOL
)
isAnimationSuppressed
{
return
mIsAnimationSuppressed
;
}
-
(
void
)
disableSetNeedsDisplay
{
mDisabledNeedsDisplay
=
YES
;
}
-
(
void
)
enableSetNeedsDisplay
{
mDisabledNeedsDisplay
=
NO
;
}
-
(
void
)
dealloc
{
[
mTouchBar
release
]
;
[
self
removeTrackingArea
]
;
ChildViewMouseTracker
:
:
OnDestroyWindow
(
self
)
;
[
super
dealloc
]
;
}
static
const
NSString
*
kStateTitleKey
=
"
title
"
;
static
const
NSString
*
kStateDrawsContentsIntoWindowFrameKey
=
"
drawsContentsIntoWindowFrame
"
;
static
const
NSString
*
kStateShowsToolbarButton
=
"
showsToolbarButton
"
;
static
const
NSString
*
kStateCollectionBehavior
=
"
collectionBehavior
"
;
static
const
NSString
*
kStateWantsTitleDrawn
=
"
wantsTitleDrawn
"
;
-
(
void
)
importState
:
(
NSDictionary
*
)
aState
{
if
(
NSString
*
title
=
[
aState
objectForKey
:
kStateTitleKey
]
)
{
[
self
setTitle
:
title
]
;
}
[
self
setDrawsContentsIntoWindowFrame
:
[
[
aState
objectForKey
:
kStateDrawsContentsIntoWindowFrameKey
]
boolValue
]
]
;
[
self
setShowsToolbarButton
:
[
[
aState
objectForKey
:
kStateShowsToolbarButton
]
boolValue
]
]
;
[
self
setCollectionBehavior
:
[
[
aState
objectForKey
:
kStateCollectionBehavior
]
unsignedIntValue
]
]
;
[
self
setWantsTitleDrawn
:
[
[
aState
objectForKey
:
kStateWantsTitleDrawn
]
boolValue
]
]
;
}
-
(
NSMutableDictionary
*
)
exportState
{
NSMutableDictionary
*
state
=
[
NSMutableDictionary
dictionaryWithCapacity
:
10
]
;
if
(
NSString
*
title
=
[
self
title
]
)
{
[
state
setObject
:
title
forKey
:
kStateTitleKey
]
;
}
[
state
setObject
:
[
NSNumber
numberWithBool
:
[
self
drawsContentsIntoWindowFrame
]
]
forKey
:
kStateDrawsContentsIntoWindowFrameKey
]
;
[
state
setObject
:
[
NSNumber
numberWithBool
:
[
self
showsToolbarButton
]
]
forKey
:
kStateShowsToolbarButton
]
;
[
state
setObject
:
[
NSNumber
numberWithUnsignedInt
:
[
self
collectionBehavior
]
]
forKey
:
kStateCollectionBehavior
]
;
[
state
setObject
:
[
NSNumber
numberWithBool
:
[
self
wantsTitleDrawn
]
]
forKey
:
kStateWantsTitleDrawn
]
;
return
state
;
}
-
(
void
)
setDrawsContentsIntoWindowFrame
:
(
BOOL
)
aState
{
bool
changed
=
(
aState
!
=
mDrawsIntoWindowFrame
)
;
mDrawsIntoWindowFrame
=
aState
;
if
(
changed
)
{
[
self
reflowTitlebarElements
]
;
}
}
-
(
BOOL
)
drawsContentsIntoWindowFrame
{
return
mDrawsIntoWindowFrame
;
}
-
(
NSRect
)
childViewRectForFrameRect
:
(
NSRect
)
aFrameRect
{
if
(
mDrawsIntoWindowFrame
)
{
return
aFrameRect
;
}
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSFullSizeContentViewWindowMask
;
return
[
NSWindow
contentRectForFrameRect
:
aFrameRect
styleMask
:
styleMask
]
;
}
-
(
NSRect
)
frameRectForChildViewRect
:
(
NSRect
)
aChildViewRect
{
if
(
mDrawsIntoWindowFrame
)
{
return
aChildViewRect
;
}
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSFullSizeContentViewWindowMask
;
return
[
NSWindow
frameRectForContentRect
:
aChildViewRect
styleMask
:
styleMask
]
;
}
-
(
NSTimeInterval
)
animationResizeTime
:
(
NSRect
)
newFrame
{
if
(
mIsAnimationSuppressed
)
{
return
0
.
0
;
}
return
[
super
animationResizeTime
:
newFrame
]
;
}
-
(
void
)
setWantsTitleDrawn
:
(
BOOL
)
aDrawTitle
{
mDrawTitle
=
aDrawTitle
;
if
(
[
self
respondsToSelector
:
selector
(
setTitleVisibility
:
)
]
)
{
[
self
setTitleVisibility
:
mDrawTitle
?
NSWindowTitleVisible
:
NSWindowTitleHidden
]
;
}
}
-
(
BOOL
)
wantsTitleDrawn
{
return
mDrawTitle
;
}
-
(
void
)
setUseBrightTitlebarForeground
:
(
BOOL
)
aBrightForeground
{
mBrightTitlebarForeground
=
aBrightForeground
;
[
[
self
standardWindowButton
:
NSWindowFullScreenButton
]
setNeedsDisplay
:
YES
]
;
}
-
(
BOOL
)
useBrightTitlebarForeground
{
return
mBrightTitlebarForeground
;
}
-
(
NSView
*
)
trackingAreaView
{
NSView
*
contentView
=
[
self
contentView
]
;
return
[
contentView
superview
]
?
[
contentView
superview
]
:
contentView
;
}
-
(
NSArray
<
NSView
*
>
*
)
contentViewContents
{
return
[
[
[
[
self
contentView
]
subviews
]
copy
]
autorelease
]
;
}
-
(
ChildView
*
)
mainChildView
{
NSView
*
contentView
=
[
self
contentView
]
;
NSView
*
lastView
=
[
[
contentView
subviews
]
lastObject
]
;
if
(
[
lastView
isKindOfClass
:
[
ChildView
class
]
]
)
{
return
(
ChildView
*
)
lastView
;
}
return
nil
;
}
-
(
void
)
removeTrackingArea
{
if
(
mTrackingArea
)
{
[
[
self
trackingAreaView
]
removeTrackingArea
:
mTrackingArea
]
;
[
mTrackingArea
release
]
;
mTrackingArea
=
nil
;
}
}
-
(
void
)
updateTrackingArea
{
[
self
removeTrackingArea
]
;
NSView
*
view
=
[
self
trackingAreaView
]
;
const
NSTrackingAreaOptions
options
=
NSTrackingMouseEnteredAndExited
|
NSTrackingMouseMoved
|
NSTrackingActiveAlways
;
mTrackingArea
=
[
[
NSTrackingArea
alloc
]
initWithRect
:
[
view
bounds
]
options
:
options
owner
:
self
userInfo
:
nil
]
;
[
view
addTrackingArea
:
mTrackingArea
]
;
}
-
(
void
)
mouseEntered
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseEnteredWindow
(
aEvent
)
;
}
-
(
void
)
mouseExited
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseExitedWindow
(
aEvent
)
;
}
-
(
void
)
mouseMoved
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
MouseMoved
(
aEvent
)
;
}
-
(
void
)
cursorUpdated
:
(
NSEvent
*
)
aEvent
{
}
-
(
void
)
_setNeedsDisplayInRect
:
(
NSRect
)
aRect
{
if
(
!
mDisabledNeedsDisplay
)
{
[
super
_setNeedsDisplayInRect
:
aRect
]
;
mDirtyRect
=
NSUnionRect
(
mDirtyRect
aRect
)
;
}
}
-
(
NSRect
)
getAndResetNativeDirtyRect
{
NSRect
dirtyRect
=
mDirtyRect
;
mDirtyRect
=
NSZeroRect
;
return
dirtyRect
;
}
-
(
void
)
reflowTitlebarElements
{
NSView
*
frameView
=
[
[
self
contentView
]
superview
]
;
if
(
[
frameView
respondsToSelector
:
selector
(
_tileTitlebarAndRedisplay
:
)
]
)
{
[
frameView
_tileTitlebarAndRedisplay
:
NO
]
;
}
}
-
(
BOOL
)
respondsToSelector
:
(
SEL
)
aSelector
{
if
(
aSelector
=
=
selector
(
cancelOperation
:
)
)
{
return
NO
;
}
return
[
super
respondsToSelector
:
aSelector
]
;
}
-
(
void
)
doCommandBySelector
:
(
SEL
)
aSelector
{
[
self
tryToPerform
:
aSelector
with
:
nil
]
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
id
retval
=
[
super
accessibilityAttributeValue
:
attribute
]
;
if
(
[
retval
isKindOfClass
:
[
NSArray
class
]
]
&
&
[
attribute
isEqualToString
:
"
AXChildren
"
]
)
{
NSMutableArray
*
holder
=
[
NSMutableArray
arrayWithCapacity
:
10
]
;
[
holder
addObjectsFromArray
:
(
NSArray
*
)
retval
]
;
NSUInteger
count
=
[
holder
count
]
;
for
(
NSInteger
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
id
item
=
[
holder
objectAtIndex
:
i
]
;
if
(
!
[
item
isKindOfClass
:
[
NSButtonCell
class
]
]
&
&
!
[
item
respondsToSelector
:
selector
(
hasRepresentedView
)
]
)
{
[
holder
removeObjectAtIndex
:
i
]
;
}
}
retval
=
[
NSArray
arrayWithArray
:
holder
]
;
}
return
retval
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
releaseJSObjects
{
[
mTouchBar
releaseJSObjects
]
;
}
end
interface
NSView
(
NSThemeFrame
)
-
(
void
)
_drawTitleStringInClip
:
(
NSRect
)
aRect
;
-
(
void
)
_maskCorners
:
(
NSUInteger
)
aFlags
clipRect
:
(
NSRect
)
aRect
;
end
implementation
TitlebarGradientView
-
(
void
)
drawRect
:
(
NSRect
)
aRect
{
CGContextRef
ctx
=
(
CGContextRef
)
[
[
NSGraphicsContext
currentContext
]
graphicsPort
]
;
ToolbarWindow
*
window
=
(
ToolbarWindow
*
)
[
self
window
]
;
nsNativeThemeCocoa
:
:
DrawNativeTitlebar
(
ctx
NSRectToCGRect
(
[
self
bounds
]
)
[
window
unifiedToolbarHeight
]
[
window
isMainWindow
]
NO
)
;
}
-
(
BOOL
)
isOpaque
{
return
YES
;
}
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
YES
;
}
-
(
void
)
mouseUp
:
(
NSEvent
*
)
event
{
if
(
[
event
clickCount
]
=
=
2
)
{
if
(
nsCocoaUtils
:
:
ShouldZoomOnTitlebarDoubleClick
(
)
)
{
[
[
self
window
]
performZoom
:
nil
]
;
}
else
if
(
nsCocoaUtils
:
:
ShouldMinimizeOnTitlebarDoubleClick
(
)
)
{
[
[
self
window
]
performMiniaturize
:
nil
]
;
}
}
}
end
implementation
ToolbarWindow
-
(
id
)
initWithContentRect
:
(
NSRect
)
aChildViewRect
styleMask
:
(
NSUInteger
)
aStyle
backing
:
(
NSBackingStoreType
)
aBufferingType
defer
:
(
BOOL
)
aFlag
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
NSRect
frameRect
=
[
NSWindow
frameRectForContentRect
:
aChildViewRect
styleMask
:
aStyle
]
;
if
(
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
aStyle
|
=
NSFullSizeContentViewWindowMask
;
}
NSRect
contentRect
=
frameRect
;
if
(
(
self
=
[
super
initWithContentRect
:
contentRect
styleMask
:
aStyle
backing
:
aBufferingType
defer
:
aFlag
]
)
)
{
mTitlebarGradientView
=
nil
;
mUnifiedToolbarHeight
=
22
.
0f
;
mSheetAttachmentPosition
=
aChildViewRect
.
size
.
height
;
mWindowButtonsRect
=
NSZeroRect
;
mFullScreenButtonRect
=
NSZeroRect
;
if
(
[
self
respondsToSelector
:
selector
(
setTitlebarAppearsTransparent
:
)
]
)
{
[
self
setTitlebarAppearsTransparent
:
YES
]
;
}
[
self
updateTitlebarGradientViewPresence
]
;
}
return
self
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
dealloc
{
[
mTitlebarGradientView
release
]
;
[
super
dealloc
]
;
}
-
(
NSArray
<
NSView
*
>
*
)
contentViewContents
{
NSMutableArray
<
NSView
*
>
*
contents
=
[
[
[
self
contentView
]
subviews
]
mutableCopy
]
;
if
(
mTitlebarGradientView
)
{
[
contents
removeObject
:
mTitlebarGradientView
]
;
}
return
[
contents
autorelease
]
;
}
-
(
void
)
updateTitlebarGradientViewPresence
{
BOOL
needTitlebarView
=
!
[
self
drawsContentsIntoWindowFrame
]
;
if
(
needTitlebarView
&
&
!
mTitlebarGradientView
)
{
mTitlebarGradientView
=
[
[
TitlebarGradientView
alloc
]
initWithFrame
:
[
self
titlebarRect
]
]
;
mTitlebarGradientView
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewMinYMargin
;
[
self
.
contentView
addSubview
:
mTitlebarGradientView
positioned
:
NSWindowBelow
relativeTo
:
nil
]
;
}
else
if
(
!
needTitlebarView
&
&
mTitlebarGradientView
)
{
[
mTitlebarGradientView
removeFromSuperview
]
;
[
mTitlebarGradientView
release
]
;
mTitlebarGradientView
=
nil
;
}
}
-
(
NSRect
)
contentRectForFrameRect
:
(
NSRect
)
aRect
{
return
aRect
;
}
-
(
NSRect
)
contentRectForFrameRect
:
(
NSRect
)
aRect
styleMask
:
(
NSUInteger
)
aMask
{
return
aRect
;
}
-
(
NSRect
)
frameRectForContentRect
:
(
NSRect
)
aRect
{
return
aRect
;
}
-
(
NSRect
)
frameRectForContentRect
:
(
NSRect
)
aRect
styleMask
:
(
NSUInteger
)
aMask
{
return
aRect
;
}
-
(
void
)
setContentView
:
(
NSView
*
)
aView
{
[
super
setContentView
:
aView
]
;
if
(
!
(
[
self
styleMask
]
&
NSFullSizeContentViewWindowMask
)
)
{
NSView
*
frameView
=
[
aView
superview
]
;
[
aView
removeFromSuperview
]
;
if
(
[
frameView
respondsToSelector
:
selector
(
_addKnownSubview
:
positioned
:
relativeTo
:
)
]
)
{
[
frameView
_addKnownSubview
:
aView
positioned
:
NSWindowBelow
relativeTo
:
nil
]
;
}
else
{
[
frameView
addSubview
:
aView
positioned
:
NSWindowBelow
relativeTo
:
nil
]
;
}
}
}
-
(
void
)
windowMainStateChanged
{
[
self
setTitlebarNeedsDisplay
]
;
[
[
self
mainChildView
]
ensureNextCompositeIsAtomicWithMainThreadPaint
]
;
}
-
(
void
)
setTitlebarNeedsDisplay
{
[
mTitlebarGradientView
setNeedsDisplay
:
YES
]
;
}
-
(
NSRect
)
titlebarRect
{
CGFloat
titlebarHeight
=
[
self
titlebarHeight
]
;
return
NSMakeRect
(
0
[
self
frame
]
.
size
.
height
-
titlebarHeight
[
self
frame
]
.
size
.
width
titlebarHeight
)
;
}
-
(
CGFloat
)
unifiedToolbarHeight
{
return
mUnifiedToolbarHeight
;
}
-
(
CGFloat
)
titlebarHeight
{
NSRect
frameRect
=
[
self
frame
]
;
NSUInteger
styleMask
=
[
self
styleMask
]
;
styleMask
&
=
~
NSFullSizeContentViewWindowMask
;
NSRect
originalContentRect
=
[
NSWindow
contentRectForFrameRect
:
frameRect
styleMask
:
styleMask
]
;
return
NSMaxY
(
frameRect
)
-
NSMaxY
(
originalContentRect
)
;
}
-
(
void
)
setUnifiedToolbarHeight
:
(
CGFloat
)
aHeight
{
if
(
aHeight
=
=
mUnifiedToolbarHeight
)
return
;
mUnifiedToolbarHeight
=
aHeight
;
if
(
!
[
self
drawsContentsIntoWindowFrame
]
)
{
[
self
setTitlebarNeedsDisplay
]
;
}
}
-
(
void
)
setDrawsContentsIntoWindowFrame
:
(
BOOL
)
aState
{
BOOL
stateChanged
=
(
[
self
drawsContentsIntoWindowFrame
]
!
=
aState
)
;
[
super
setDrawsContentsIntoWindowFrame
:
aState
]
;
if
(
stateChanged
&
&
[
[
self
delegate
]
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
WindowDelegate
*
windowDelegate
=
(
WindowDelegate
*
)
[
self
delegate
]
;
nsCocoaWindow
*
geckoWindow
=
[
windowDelegate
geckoWidget
]
;
if
(
geckoWindow
)
{
geckoWindow
-
>
ReportSizeEvent
(
)
;
}
ChildViewMouseTracker
:
:
ResendLastMouseMoveEvent
(
)
;
}
[
self
updateTitlebarGradientViewPresence
]
;
}
-
(
void
)
setWantsTitleDrawn
:
(
BOOL
)
aDrawTitle
{
[
super
setWantsTitleDrawn
:
aDrawTitle
]
;
[
self
setTitlebarNeedsDisplay
]
;
}
-
(
void
)
setSheetAttachmentPosition
:
(
CGFloat
)
aY
{
mSheetAttachmentPosition
=
aY
;
}
-
(
CGFloat
)
sheetAttachmentPosition
{
return
mSheetAttachmentPosition
;
}
-
(
void
)
placeWindowButtons
:
(
NSRect
)
aRect
{
if
(
!
NSEqualRects
(
mWindowButtonsRect
aRect
)
)
{
mWindowButtonsRect
=
aRect
;
[
self
reflowTitlebarElements
]
;
}
}
-
(
NSPoint
)
windowButtonsPositionWithDefaultPosition
:
(
NSPoint
)
aDefaultPosition
{
NSInteger
styleMask
=
[
self
styleMask
]
;
if
(
[
self
drawsContentsIntoWindowFrame
]
&
&
!
(
styleMask
&
NSFullScreenWindowMask
)
&
&
(
styleMask
&
NSTitledWindowMask
)
)
{
if
(
NSIsEmptyRect
(
mWindowButtonsRect
)
)
{
return
NSMakePoint
(
0
[
self
frame
]
.
size
.
height
)
;
}
return
NSMakePoint
(
mWindowButtonsRect
.
origin
.
x
mWindowButtonsRect
.
origin
.
y
)
;
}
return
aDefaultPosition
;
}
-
(
void
)
placeFullScreenButton
:
(
NSRect
)
aRect
{
if
(
!
NSEqualRects
(
mFullScreenButtonRect
aRect
)
)
{
mFullScreenButtonRect
=
aRect
;
[
self
reflowTitlebarElements
]
;
}
}
-
(
NSPoint
)
fullScreenButtonPositionWithDefaultPosition
:
(
NSPoint
)
aDefaultPosition
{
if
(
[
self
drawsContentsIntoWindowFrame
]
&
&
!
NSIsEmptyRect
(
mFullScreenButtonRect
)
)
{
return
NSMakePoint
(
std
:
:
min
(
mFullScreenButtonRect
.
origin
.
x
aDefaultPosition
.
x
)
std
:
:
min
(
mFullScreenButtonRect
.
origin
.
y
aDefaultPosition
.
y
)
)
;
}
return
aDefaultPosition
;
}
-
(
BOOL
)
_hasToolbar
{
return
YES
;
}
-
(
void
)
_toolbarPillButtonClicked
:
(
id
)
sender
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
RollUpPopups
(
)
;
if
(
[
[
self
delegate
]
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
WindowDelegate
*
windowDelegate
=
(
WindowDelegate
*
)
[
self
delegate
]
;
nsCocoaWindow
*
geckoWindow
=
[
windowDelegate
geckoWidget
]
;
if
(
!
geckoWindow
)
return
;
nsIWidgetListener
*
listener
=
geckoWindow
-
>
GetWidgetListener
(
)
;
if
(
listener
)
listener
-
>
OSToolbarButtonPressed
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
NSWindow
*
nativeWindow
=
[
self
retain
]
;
BOOL
retval
=
[
super
performKeyEquivalent
:
theEvent
]
;
[
nativeWindow
release
]
;
return
retval
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NO
)
;
}
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
NSEventType
type
=
[
anEvent
type
]
;
switch
(
type
)
{
case
NSScrollWheel
:
case
NSLeftMouseDown
:
case
NSLeftMouseUp
:
case
NSRightMouseDown
:
case
NSRightMouseUp
:
case
NSOtherMouseDown
:
case
NSOtherMouseUp
:
case
NSMouseMoved
:
case
NSLeftMouseDragged
:
case
NSRightMouseDragged
:
case
NSOtherMouseDragged
:
{
id
delegate
=
[
self
delegate
]
;
if
(
delegate
&
&
[
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
nsCocoaWindow
*
widget
=
[
(
WindowDelegate
*
)
delegate
geckoWidget
]
;
if
(
widget
)
{
if
(
gGeckoAppModalWindowList
&
&
(
widget
!
=
gGeckoAppModalWindowList
-
>
window
)
)
return
;
if
(
widget
-
>
HasModalDescendents
(
)
)
return
;
}
}
break
;
}
default
:
break
;
}
[
super
sendEvent
:
anEvent
]
;
}
end
implementation
PopupWindow
-
(
id
)
initWithContentRect
:
(
NSRect
)
contentRect
styleMask
:
(
NSUInteger
)
styleMask
backing
:
(
NSBackingStoreType
)
bufferingType
defer
:
(
BOOL
)
deferCreation
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
mIsContextMenu
=
false
;
return
[
super
initWithContentRect
:
contentRect
styleMask
:
styleMask
backing
:
bufferingType
defer
:
deferCreation
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
CGFloat
)
_backdropBleedAmount
{
return
0
.
0
;
}
-
(
BOOL
)
isContextMenu
{
return
mIsContextMenu
;
}
-
(
void
)
setIsContextMenu
:
(
BOOL
)
flag
{
mIsContextMenu
=
flag
;
}
-
(
BOOL
)
canBecomeMainWindow
{
return
NO
;
}
end
implementation
BorderlessWindow
-
(
BOOL
)
canBecomeKeyWindow
{
return
YES
;
}
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
NSEventType
type
=
[
anEvent
type
]
;
switch
(
type
)
{
case
NSScrollWheel
:
case
NSLeftMouseDown
:
case
NSLeftMouseUp
:
case
NSRightMouseDown
:
case
NSRightMouseUp
:
case
NSOtherMouseDown
:
case
NSOtherMouseUp
:
case
NSMouseMoved
:
case
NSLeftMouseDragged
:
case
NSRightMouseDragged
:
case
NSOtherMouseDragged
:
{
id
delegate
=
[
self
delegate
]
;
if
(
delegate
&
&
[
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
nsCocoaWindow
*
widget
=
[
(
WindowDelegate
*
)
delegate
geckoWidget
]
;
if
(
widget
)
{
if
(
gGeckoAppModalWindowList
&
&
(
widget
!
=
gGeckoAppModalWindowList
-
>
window
)
)
return
;
if
(
widget
-
>
HasModalDescendents
(
)
)
return
;
}
}
break
;
}
default
:
break
;
}
[
super
sendEvent
:
anEvent
]
;
}
-
(
BOOL
)
canBecomeMainWindow
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
!
[
self
isVisible
]
)
return
NO
;
return
YES
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
NSWindow
*
nativeWindow
=
[
self
retain
]
;
BOOL
retval
=
[
super
performKeyEquivalent
:
theEvent
]
;
[
nativeWindow
release
]
;
return
retval
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NO
)
;
}
end
