#
include
"
nsTouchBarInputIcon
.
h
"
#
include
"
MOZIconHelper
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsObjCExceptions
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
widget
:
:
IconLoader
;
static
const
uint32_t
kIconSize
=
16
;
static
const
CGFloat
kHiDPIScalingFactor
=
2
.
0f
;
nsTouchBarInputIcon
:
:
nsTouchBarInputIcon
(
RefPtr
<
Document
>
aDocument
TouchBarInput
*
aInput
NSTouchBarItem
*
aItem
)
:
mDocument
(
aDocument
)
mSetIcon
(
false
)
mButton
(
nil
)
mShareScrubber
(
nil
)
mPopoverItem
(
nil
)
{
if
(
[
[
aInput
nativeIdentifier
]
isEqualToString
:
[
TouchBarInput
shareScrubberIdentifier
]
]
)
{
mShareScrubber
=
(
NSSharingServicePickerTouchBarItem
*
)
aItem
;
}
else
if
(
[
aInput
baseType
]
=
=
TouchBarInputBaseType
:
:
kPopover
)
{
mPopoverItem
=
(
NSPopoverTouchBarItem
*
)
aItem
;
}
else
if
(
[
aInput
baseType
]
=
=
TouchBarInputBaseType
:
:
kButton
|
|
[
aInput
baseType
]
=
=
TouchBarInputBaseType
:
:
kMainButton
)
{
mButton
=
(
NSButton
*
)
[
aItem
view
]
;
}
else
{
NS_ERROR
(
"
Incompatible
Touch
Bar
input
passed
to
nsTouchBarInputIcon
.
"
)
;
}
aInput
=
nil
;
MOZ_COUNT_CTOR
(
nsTouchBarInputIcon
)
;
}
nsTouchBarInputIcon
:
:
~
nsTouchBarInputIcon
(
)
{
Destroy
(
)
;
MOZ_COUNT_DTOR
(
nsTouchBarInputIcon
)
;
}
void
nsTouchBarInputIcon
:
:
Destroy
(
)
{
ReleaseJSObjects
(
)
;
if
(
mIconLoader
)
{
mIconLoader
-
>
Destroy
(
)
;
mIconLoader
=
nullptr
;
}
mButton
=
nil
;
mShareScrubber
=
nil
;
mPopoverItem
=
nil
;
}
nsresult
nsTouchBarInputIcon
:
:
SetupIcon
(
nsCOMPtr
<
nsIURI
>
aIconURI
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mDocument
)
{
return
NS_OK
;
}
if
(
!
(
mButton
|
|
mShareScrubber
|
|
mPopoverItem
)
)
{
NS_ERROR
(
"
No
Touch
Bar
input
provided
.
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mIconLoader
)
{
mIconLoader
=
new
IconLoader
(
this
)
;
}
if
(
!
mSetIcon
)
{
NSSize
iconSize
=
NSMakeSize
(
kIconSize
kIconSize
)
;
NSImage
*
placeholder
=
[
MOZIconHelper
placeholderIconWithSize
:
iconSize
]
;
[
mButton
setImage
:
placeholder
]
;
[
mShareScrubber
setButtonImage
:
placeholder
]
;
[
mPopoverItem
setCollapsedRepresentationImage
:
placeholder
]
;
}
nsresult
rv
=
mIconLoader
-
>
LoadIcon
(
aIconURI
mDocument
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
[
mButton
setImage
:
nil
]
;
[
mShareScrubber
setButtonImage
:
nil
]
;
[
mPopoverItem
setCollapsedRepresentationImage
:
nil
]
;
}
mSetIcon
=
true
;
return
rv
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsTouchBarInputIcon
:
:
ReleaseJSObjects
(
)
{
mDocument
=
nil
;
}
nsresult
nsTouchBarInputIcon
:
:
OnComplete
(
imgIContainer
*
aImage
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
NSImage
*
image
=
[
MOZIconHelper
iconImageFromImageContainer
:
aImage
withSize
:
NSMakeSize
(
kIconSize
kIconSize
)
computedStyle
:
nullptr
subrect
:
mImageRegionRect
scaleFactor
:
kHiDPIScalingFactor
]
;
[
mButton
setImage
:
image
]
;
[
mShareScrubber
setButtonImage
:
image
]
;
[
mPopoverItem
setCollapsedRepresentationImage
:
image
]
;
mIconLoader
-
>
Destroy
(
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
}
