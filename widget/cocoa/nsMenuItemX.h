#
ifndef
nsMenuItemX_h_
#
define
nsMenuItemX_h_
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsMenuGroupOwnerX
.
h
"
#
include
"
nsMenuItemIconX
.
h
"
#
include
"
nsChangeObserver
.
h
"
#
include
"
nsStringFwd
.
h
"
#
import
<
Cocoa
/
Cocoa
.
h
>
class
nsMenuItemIconX
;
class
nsMenuX
;
class
nsMenuParentX
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
}
enum
{
knsMenuItemNoModifier
=
0
knsMenuItemShiftModifier
=
(
1
<
<
0
)
knsMenuItemAltModifier
=
(
1
<
<
1
)
knsMenuItemControlModifier
=
(
1
<
<
2
)
knsMenuItemCommandModifier
=
(
1
<
<
3
)
}
;
enum
EMenuItemType
{
eRegularMenuItemType
=
0
eCheckboxMenuItemType
eRadioMenuItemType
eSeparatorMenuItemType
}
;
class
nsMenuItemX
final
:
public
nsChangeObserver
public
nsMenuItemIconX
:
:
Listener
{
public
:
nsMenuItemX
(
nsMenuX
*
aParent
const
nsString
&
aLabel
EMenuItemType
aItemType
nsMenuGroupOwnerX
*
aMenuGroupOwner
nsIContent
*
aNode
)
;
void
DetachFromGroupOwner
(
)
;
void
DetachFromParent
(
)
{
mMenuParent
=
nullptr
;
}
NS_INLINE_DECL_REFCOUNTING
(
nsMenuItemX
)
NS_DECL_CHANGEOBSERVER
void
IconUpdated
(
)
override
;
nsresult
SetChecked
(
bool
aIsChecked
)
;
EMenuItemType
GetMenuItemType
(
)
;
void
DoCommand
(
NSEventModifierFlags
aModifierFlags
)
;
nsresult
DispatchDOMEvent
(
const
nsString
&
eventName
bool
*
preventDefaultCalled
)
;
void
SetupIcon
(
)
;
nsIContent
*
Content
(
)
{
return
mContent
;
}
NSMenuItem
*
NativeNSMenuItem
(
)
{
return
mNativeMenuItem
;
}
void
Dump
(
uint32_t
aIndent
)
const
;
protected
:
virtual
~
nsMenuItemX
(
)
;
void
UncheckRadioSiblings
(
nsIContent
*
aCheckedElement
)
;
void
SetKeyEquiv
(
)
;
nsCOMPtr
<
nsIContent
>
mContent
;
EMenuItemType
mType
;
NSMenuItem
*
mNativeMenuItem
=
nil
;
nsMenuX
*
mMenuParent
=
nullptr
;
nsMenuGroupOwnerX
*
mMenuGroupOwner
=
nullptr
;
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
mCommandElement
;
mozilla
:
:
UniquePtr
<
nsMenuItemIconX
>
mIcon
;
bool
mIsChecked
=
false
;
}
;
#
endif
