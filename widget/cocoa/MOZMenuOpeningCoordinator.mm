#
include
"
MOZMenuOpeningCoordinator
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
SDKDeclarations
.
h
"
interface
MOZMenuOpeningInfo
:
NSObject
property
NSInteger
handle
;
property
(
retain
)
NSMenu
*
menu
;
property
NSPoint
position
;
property
(
retain
)
NSView
*
view
;
end
implementation
MOZMenuOpeningInfo
end
implementation
MOZMenuOpeningCoordinator
{
MOZMenuOpeningInfo
*
mPendingOpening
;
NSInteger
mLastHandle
;
BOOL
mRunMenuIsOnTheStack
;
}
+
(
instancetype
)
sharedInstance
{
static
MOZMenuOpeningCoordinator
*
sInstance
=
nil
;
if
(
!
sInstance
)
{
sInstance
=
[
[
MOZMenuOpeningCoordinator
alloc
]
init
]
;
}
return
sInstance
;
}
-
(
NSInteger
)
asynchronouslyOpenMenu
:
(
NSMenu
*
)
aMenu
atScreenPosition
:
(
NSPoint
)
aPosition
forView
:
(
NSView
*
)
aView
{
MOZ_RELEASE_ASSERT
(
!
mPendingOpening
"
A
menu
is
already
waiting
to
open
.
Before
opening
the
next
one
either
wait
"
"
for
this
one
to
open
or
cancel
the
request
.
"
)
;
NSInteger
handle
=
+
+
mLastHandle
;
MOZMenuOpeningInfo
*
info
=
[
[
MOZMenuOpeningInfo
alloc
]
init
]
;
info
.
handle
=
handle
;
info
.
menu
=
aMenu
;
info
.
position
=
aPosition
;
info
.
view
=
aView
;
mPendingOpening
=
[
info
retain
]
;
[
info
release
]
;
if
(
!
mRunMenuIsOnTheStack
)
{
[
self
performSelector
:
selector
(
_runMenu
)
withObject
:
nil
afterDelay
:
0
.
0
]
;
}
return
handle
;
}
-
(
void
)
_runMenu
{
MOZ_RELEASE_ASSERT
(
!
mRunMenuIsOnTheStack
)
;
mRunMenuIsOnTheStack
=
YES
;
while
(
mPendingOpening
)
{
MOZMenuOpeningInfo
*
info
=
[
mPendingOpening
retain
]
;
[
mPendingOpening
release
]
;
mPendingOpening
=
nil
;
try
{
[
self
_openMenu
:
info
.
menu
atScreenPosition
:
info
.
position
forView
:
info
.
view
]
;
}
catch
(
NSException
*
exception
)
{
nsObjCExceptionLog
(
exception
)
;
}
[
info
release
]
;
}
mRunMenuIsOnTheStack
=
NO
;
}
-
(
void
)
cancelAsynchronousOpening
:
(
NSInteger
)
aHandle
{
if
(
mPendingOpening
&
&
mPendingOpening
.
handle
=
=
aHandle
)
{
[
mPendingOpening
release
]
;
mPendingOpening
=
nil
;
}
}
-
(
void
)
_openMenu
:
(
NSMenu
*
)
aMenu
atScreenPosition
:
(
NSPoint
)
aPosition
forView
:
(
NSView
*
)
aView
{
if
(
available
(
macOS
10
.
14
*
)
)
{
#
if
!
defined
(
MAC_OS_VERSION_11_0
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_VERSION_11_0
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
#
else
if
(
available
(
macOS
11
.
0
*
)
)
{
#
endif
[
aMenu
setAppearance
:
NSApp
.
effectiveAppearance
]
;
}
}
if
(
aView
)
{
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
aView
.
window
aPosition
)
;
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
locationInWindow
modifierFlags
:
0
timestamp
:
NSProcessInfo
.
processInfo
.
systemUptime
windowNumber
:
aView
.
window
.
windowNumber
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0f
]
;
[
NSMenu
popUpContextMenu
:
aMenu
withEvent
:
event
forView
:
aView
]
;
}
else
{
[
aMenu
popUpMenuPositioningItem
:
nil
atLocation
:
aPosition
inView
:
nil
]
;
}
}
end
