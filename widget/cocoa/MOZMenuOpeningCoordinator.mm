#
include
"
MOZMenuOpeningCoordinator
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
static
BOOL
sNeedToUnwindForMenuClosing
=
NO
;
interface
MOZMenuOpeningInfo
:
NSObject
property
NSInteger
handle
;
property
(
retain
)
NSMenu
*
menu
;
property
NSPoint
position
;
property
(
retain
)
NSView
*
view
;
property
(
retain
)
NSAppearance
*
appearance
;
property
BOOL
isContextMenu
;
end
implementation
MOZMenuOpeningInfo
end
implementation
MOZMenuOpeningCoordinator
{
MOZMenuOpeningInfo
*
mPendingOpening
;
NSInteger
mLastHandle
;
BOOL
mRunMenuIsOnTheStack
;
}
+
(
instancetype
)
sharedInstance
{
static
MOZMenuOpeningCoordinator
*
sInstance
=
nil
;
if
(
!
sInstance
)
{
sInstance
=
[
[
MOZMenuOpeningCoordinator
alloc
]
init
]
;
mozilla
:
:
RunOnShutdown
(
[
&
]
(
)
{
[
sInstance
release
]
;
sInstance
=
nil
;
}
)
;
}
return
sInstance
;
}
-
(
void
)
dealloc
{
MOZ_RELEASE_ASSERT
(
!
mPendingOpening
"
should
be
empty
at
shutdown
"
)
;
[
super
dealloc
]
;
}
-
(
NSInteger
)
asynchronouslyOpenMenu
:
(
NSMenu
*
)
aMenu
atScreenPosition
:
(
NSPoint
)
aPosition
forView
:
(
NSView
*
)
aView
withAppearance
:
(
NSAppearance
*
)
aAppearance
asContextMenu
:
(
BOOL
)
aIsContextMenu
{
MOZ_RELEASE_ASSERT
(
!
mPendingOpening
"
A
menu
is
already
waiting
to
open
.
Before
opening
the
"
"
next
one
either
wait
"
"
for
this
one
to
open
or
cancel
the
request
.
"
)
;
NSInteger
handle
=
+
+
mLastHandle
;
MOZMenuOpeningInfo
*
info
=
[
[
MOZMenuOpeningInfo
alloc
]
init
]
;
info
.
handle
=
handle
;
info
.
menu
=
aMenu
;
info
.
position
=
aPosition
;
info
.
view
=
aView
;
info
.
appearance
=
aAppearance
;
info
.
isContextMenu
=
aIsContextMenu
;
mPendingOpening
=
[
info
retain
]
;
[
info
release
]
;
if
(
!
mRunMenuIsOnTheStack
)
{
[
self
performSelector
:
selector
(
_runMenu
)
withObject
:
nil
afterDelay
:
0
.
0
]
;
}
return
handle
;
}
-
(
void
)
_runMenu
{
MOZ_RELEASE_ASSERT
(
!
mRunMenuIsOnTheStack
)
;
mRunMenuIsOnTheStack
=
YES
;
while
(
mPendingOpening
)
{
MOZMenuOpeningInfo
*
info
=
[
mPendingOpening
retain
]
;
[
mPendingOpening
release
]
;
mPendingOpening
=
nil
;
try
{
[
self
_openMenu
:
info
.
menu
atScreenPosition
:
info
.
position
forView
:
info
.
view
withAppearance
:
info
.
appearance
asContextMenu
:
info
.
isContextMenu
]
;
}
catch
(
NSException
*
exception
)
{
nsObjCExceptionLog
(
exception
)
;
}
[
info
release
]
;
MOZMenuOpeningCoordinator
.
needToUnwindForMenuClosing
=
NO
;
}
mRunMenuIsOnTheStack
=
NO
;
}
-
(
void
)
cancelAsynchronousOpening
:
(
NSInteger
)
aHandle
{
if
(
mPendingOpening
&
&
mPendingOpening
.
handle
=
=
aHandle
)
{
[
NSObject
cancelPreviousPerformRequestsWithTarget
:
self
selector
:
selector
(
_runMenu
)
object
:
nil
]
;
[
mPendingOpening
release
]
;
mPendingOpening
=
nil
;
}
}
-
(
void
)
_openMenu
:
(
NSMenu
*
)
aMenu
atScreenPosition
:
(
NSPoint
)
aPosition
forView
:
(
NSView
*
)
aView
withAppearance
:
(
NSAppearance
*
)
aAppearance
asContextMenu
:
(
BOOL
)
aIsContextMenu
{
if
(
aAppearance
)
{
if
(
available
(
macOS
11
.
0
*
)
)
{
aMenu
.
appearance
=
aAppearance
;
}
}
if
(
aView
)
{
NSWindow
*
window
=
aView
.
window
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
window
aPosition
)
;
if
(
aIsContextMenu
)
{
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
locationInWindow
modifierFlags
:
0
timestamp
:
NSProcessInfo
.
processInfo
.
systemUptime
windowNumber
:
window
.
windowNumber
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0f
]
;
[
NSMenu
popUpContextMenu
:
aMenu
withEvent
:
event
forView
:
aView
]
;
}
else
{
NSPoint
locationInView
=
[
aView
convertPoint
:
locationInWindow
fromView
:
nil
]
;
[
aMenu
popUpMenuPositioningItem
:
nil
atLocation
:
locationInView
inView
:
aView
]
;
}
}
else
{
[
aMenu
popUpMenuPositioningItem
:
nil
atLocation
:
aPosition
inView
:
nil
]
;
}
}
+
(
void
)
setNeedToUnwindForMenuClosing
:
(
BOOL
)
aValue
{
sNeedToUnwindForMenuClosing
=
aValue
;
}
+
(
BOOL
)
needToUnwindForMenuClosing
{
return
sNeedToUnwindForMenuClosing
;
}
end
