#
include
"
MOZMenuOpeningCoordinator
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
SDKDeclarations
.
h
"
interface
MOZMenuOpeningInfo
:
NSObject
property
NSInteger
handle
;
property
(
retain
)
NSMenu
*
menu
;
property
NSPoint
position
;
property
(
retain
)
NSView
*
view
;
end
implementation
MOZMenuOpeningInfo
end
implementation
MOZMenuOpeningCoordinator
{
MOZMenuOpeningInfo
*
mPendingOpening
;
nsRefPtrDeque
<
mozilla
:
:
Runnable
>
mPendingAfterMenuCloseRunnables
;
NSInteger
mLastHandle
;
BOOL
mRunMenuIsOnTheStack
;
}
+
(
instancetype
)
sharedInstance
{
static
MOZMenuOpeningCoordinator
*
sInstance
=
nil
;
if
(
!
sInstance
)
{
sInstance
=
[
[
MOZMenuOpeningCoordinator
alloc
]
init
]
;
mozilla
:
:
RunOnShutdown
(
[
&
]
(
)
{
[
sInstance
release
]
;
sInstance
=
nil
;
}
)
;
}
return
sInstance
;
}
-
(
void
)
dealloc
{
MOZ_RELEASE_ASSERT
(
!
mPendingOpening
"
should
be
empty
at
shutdown
"
)
;
MOZ_RELEASE_ASSERT
(
mPendingAfterMenuCloseRunnables
.
GetSize
(
)
=
=
0
"
should
be
empty
at
shutdown
"
)
;
[
super
dealloc
]
;
}
-
(
NSInteger
)
asynchronouslyOpenMenu
:
(
NSMenu
*
)
aMenu
atScreenPosition
:
(
NSPoint
)
aPosition
forView
:
(
NSView
*
)
aView
{
MOZ_RELEASE_ASSERT
(
!
mPendingOpening
"
A
menu
is
already
waiting
to
open
.
Before
opening
the
next
one
either
wait
"
"
for
this
one
to
open
or
cancel
the
request
.
"
)
;
NSInteger
handle
=
+
+
mLastHandle
;
MOZMenuOpeningInfo
*
info
=
[
[
MOZMenuOpeningInfo
alloc
]
init
]
;
info
.
handle
=
handle
;
info
.
menu
=
aMenu
;
info
.
position
=
aPosition
;
info
.
view
=
aView
;
mPendingOpening
=
[
info
retain
]
;
[
info
release
]
;
if
(
!
mRunMenuIsOnTheStack
)
{
[
self
performSelector
:
selector
(
_runMenu
)
withObject
:
nil
afterDelay
:
0
.
0
]
;
}
return
handle
;
}
-
(
void
)
_runMenu
{
MOZ_RELEASE_ASSERT
(
!
mRunMenuIsOnTheStack
)
;
mRunMenuIsOnTheStack
=
YES
;
while
(
mPendingOpening
)
{
MOZMenuOpeningInfo
*
info
=
[
mPendingOpening
retain
]
;
[
mPendingOpening
release
]
;
mPendingOpening
=
nil
;
try
{
[
self
_openMenu
:
info
.
menu
atScreenPosition
:
info
.
position
forView
:
info
.
view
]
;
}
catch
(
NSException
*
exception
)
{
nsObjCExceptionLog
(
exception
)
;
}
[
info
release
]
;
while
(
mPendingAfterMenuCloseRunnables
.
GetSize
(
)
!
=
0
)
{
NS_DispatchToCurrentThread
(
mPendingAfterMenuCloseRunnables
.
PopFront
(
)
)
;
}
}
mRunMenuIsOnTheStack
=
NO
;
}
-
(
void
)
cancelAsynchronousOpening
:
(
NSInteger
)
aHandle
{
if
(
mPendingOpening
&
&
mPendingOpening
.
handle
=
=
aHandle
)
{
[
mPendingOpening
release
]
;
mPendingOpening
=
nil
;
}
}
-
(
void
)
runAfterMenuClosed
:
(
RefPtr
<
mozilla
:
:
Runnable
>
&
&
)
aRunnable
{
MOZ_RELEASE_ASSERT
(
aRunnable
)
;
if
(
mRunMenuIsOnTheStack
)
{
mPendingAfterMenuCloseRunnables
.
Push
(
aRunnable
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
aRunnable
.
forget
(
)
)
;
}
}
-
(
void
)
_openMenu
:
(
NSMenu
*
)
aMenu
atScreenPosition
:
(
NSPoint
)
aPosition
forView
:
(
NSView
*
)
aView
{
if
(
aView
)
{
NSWindow
*
window
=
aView
.
window
;
if
(
available
(
macOS
10
.
14
*
)
)
{
if
(
window
.
effectiveAppearance
!
=
NSApp
.
effectiveAppearance
)
{
#
if
!
defined
(
MAC_OS_VERSION_11_0
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_VERSION_11_0
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
#
else
if
(
available
(
macOS
11
.
0
*
)
)
{
#
endif
[
aMenu
setAppearance
:
NSApp
.
effectiveAppearance
]
;
}
else
if
(
mozilla
:
:
StaticPrefs
:
:
widget_macos_enable_pre_bigsur_workaround_for_dark_mode_context_menus
(
)
)
{
if
(
[
aMenu
.
delegate
isKindOfClass
:
[
MenuDelegate
class
]
]
)
{
MenuDelegate
*
delegate
=
(
MenuDelegate
*
)
aMenu
.
delegate
;
NSAppearance
*
oldAppearance
=
window
.
appearance
;
window
.
appearance
=
NSApp
.
effectiveAppearance
;
[
(
MenuDelegate
*
)
delegate
runBlockWhenOpen
:
^
(
)
{
window
.
appearance
=
oldAppearance
;
}
]
;
}
}
}
}
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
window
aPosition
)
;
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
locationInWindow
modifierFlags
:
0
timestamp
:
NSProcessInfo
.
processInfo
.
systemUptime
windowNumber
:
window
.
windowNumber
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0f
]
;
[
NSMenu
popUpContextMenu
:
aMenu
withEvent
:
event
forView
:
aView
]
;
}
else
{
[
aMenu
popUpMenuPositioningItem
:
nil
atLocation
:
aPosition
inView
:
nil
]
;
}
}
end
