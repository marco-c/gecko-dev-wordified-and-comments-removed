#
ifndef
RectTextureImage_h_
#
define
RectTextureImage_h_
#
include
"
mozilla
/
RefPtr
.
h
"
class
MacIOSurface
;
namespace
mozilla
{
namespace
gl
{
class
GLContext
;
}
namespace
widget
{
class
RectTextureImage
{
public
:
explicit
RectTextureImage
(
gl
:
:
GLContext
*
aGLContext
)
;
virtual
~
RectTextureImage
(
)
;
already_AddRefed
<
gfx
:
:
DrawTarget
>
BeginUpdate
(
const
LayoutDeviceIntSize
&
aNewSize
const
LayoutDeviceIntRegion
&
aDirtyRegion
=
LayoutDeviceIntRegion
(
)
)
;
void
EndUpdate
(
bool
aKeepSurface
=
false
)
;
void
UpdateIfNeeded
(
const
LayoutDeviceIntSize
&
aNewSize
const
LayoutDeviceIntRegion
&
aDirtyRegion
void
(
^
aCallback
)
(
gfx
:
:
DrawTarget
*
const
LayoutDeviceIntRegion
&
)
)
{
RefPtr
<
gfx
:
:
DrawTarget
>
drawTarget
=
BeginUpdate
(
aNewSize
aDirtyRegion
)
;
if
(
drawTarget
)
{
aCallback
(
drawTarget
GetUpdateRegion
(
)
)
;
EndUpdate
(
)
;
}
}
void
UpdateFromCGContext
(
const
LayoutDeviceIntSize
&
aNewSize
const
LayoutDeviceIntRegion
&
aDirtyRegion
CGContextRef
aCGContext
)
;
LayoutDeviceIntRegion
GetUpdateRegion
(
)
{
MOZ_ASSERT
(
mInUpdate
"
update
region
only
valid
during
update
"
)
;
return
mUpdateRegion
;
}
void
Draw
(
mozilla
:
:
layers
:
:
GLManager
*
aManager
const
LayoutDeviceIntPoint
&
aLocation
const
gfx
:
:
Matrix4x4
&
aTransform
=
gfx
:
:
Matrix4x4
(
)
)
;
static
LayoutDeviceIntSize
TextureSizeForSize
(
const
LayoutDeviceIntSize
&
aSize
)
;
protected
:
RefPtr
<
gfx
:
:
DrawTarget
>
mUpdateDrawTarget
;
UniquePtr
<
unsigned
char
[
]
>
mUpdateDrawTargetData
;
gl
:
:
GLContext
*
mGLContext
;
LayoutDeviceIntRegion
mUpdateRegion
;
LayoutDeviceIntSize
mUsedSize
;
LayoutDeviceIntSize
mBufferSize
;
LayoutDeviceIntSize
mTextureSize
;
GLuint
mTexture
;
bool
mInUpdate
;
}
;
}
}
#
endif
