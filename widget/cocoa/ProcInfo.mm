#
include
"
mozilla
/
ProcInfo
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
ipc
/
GeckoChildProcessHost
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
<
cstdio
>
#
include
<
cstring
>
#
include
<
unistd
.
h
>
#
include
<
libproc
.
h
>
#
include
<
sys
/
sysctl
.
h
>
#
include
<
mach
/
mach
.
h
>
namespace
mozilla
{
RefPtr
<
ProcInfoPromise
>
GetProcInfo
(
nsTArray
<
ProcInfoRequest
>
&
&
aRequests
)
{
auto
holder
=
MakeUnique
<
MozPromiseHolder
<
ProcInfoPromise
>
>
(
)
;
RefPtr
<
ProcInfoPromise
>
promise
=
holder
-
>
Ensure
(
__func__
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
get
stream
transport
service
"
)
;
holder
-
>
Reject
(
rv
__func__
)
;
return
promise
;
}
RefPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
holder
=
std
:
:
move
(
holder
)
requests
=
std
:
:
move
(
aRequests
)
]
(
)
{
HashMap
<
base
:
:
ProcessId
ProcInfo
>
gathered
;
if
(
!
gathered
.
reserve
(
requests
.
Length
(
)
)
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
for
(
const
auto
&
request
:
requests
)
{
ProcInfo
info
;
info
.
pid
=
request
.
pid
;
info
.
childId
=
request
.
childId
;
info
.
type
=
request
.
processType
;
info
.
origin
=
std
:
:
move
(
request
.
origin
)
;
struct
proc_bsdinfo
proc
;
if
(
(
unsigned
long
)
proc_pidinfo
(
request
.
pid
PROC_PIDTBSDINFO
0
&
proc
PROC_PIDTBSDINFO_SIZE
)
<
PROC_PIDTBSDINFO_SIZE
)
{
continue
;
}
struct
proc_taskinfo
pti
;
if
(
(
unsigned
long
)
proc_pidinfo
(
request
.
pid
PROC_PIDTASKINFO
0
&
pti
PROC_PIDTASKINFO_SIZE
)
<
PROC_PIDTASKINFO_SIZE
)
{
continue
;
}
info
.
filename
.
AssignASCII
(
proc
.
pbi_name
)
;
info
.
virtualMemorySize
=
pti
.
pti_virtual_size
;
info
.
residentSetSize
=
pti
.
pti_resident_size
;
info
.
cpuUser
=
pti
.
pti_total_user
;
info
.
cpuKernel
=
pti
.
pti_total_system
;
mach_port_t
selectedTask
;
if
(
request
.
childTask
=
=
MACH_PORT_NULL
)
{
selectedTask
=
mach_task_self
(
)
;
}
else
{
selectedTask
=
request
.
childTask
;
}
thread_act_port_array_t
threadList
;
mach_msg_type_number_t
threadCount
;
kern_return_t
kret
=
task_threads
(
selectedTask
&
threadList
&
threadCount
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
continue
;
}
auto
guardThreadCount
=
MakeScopeExit
(
[
&
]
{
if
(
threadList
=
=
nullptr
)
{
return
;
}
for
(
mach_msg_type_number_t
i
=
0
;
i
<
threadCount
;
i
+
+
)
{
mach_port_deallocate
(
mach_task_self
(
)
threadList
[
i
]
)
;
}
vm_deallocate
(
mach_task_self
(
)
(
vm_address_t
)
threadList
sizeof
(
thread_t
)
*
threadCount
)
;
}
)
;
mach_msg_type_number_t
count
;
for
(
mach_msg_type_number_t
i
=
0
;
i
<
threadCount
;
i
+
+
)
{
thread_extended_info_data_t
threadInfoData
;
count
=
THREAD_EXTENDED_INFO_COUNT
;
kret
=
thread_info
(
threadList
[
i
]
THREAD_EXTENDED_INFO
(
thread_info_t
)
&
threadInfoData
&
count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
continue
;
}
thread_identifier_info
identifierInfo
;
count
=
THREAD_IDENTIFIER_INFO_COUNT
;
kret
=
thread_info
(
threadList
[
i
]
THREAD_IDENTIFIER_INFO
(
thread_info_t
)
&
identifierInfo
&
count
)
;
if
(
kret
!
=
KERN_SUCCESS
)
{
continue
;
}
ThreadInfo
*
thread
=
info
.
threads
.
AppendElement
(
fallible
)
;
if
(
!
thread
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
thread
-
>
cpuUser
=
threadInfoData
.
pth_user_time
;
thread
-
>
cpuKernel
=
threadInfoData
.
pth_system_time
;
thread
-
>
name
.
AssignASCII
(
threadInfoData
.
pth_name
)
;
thread
-
>
tid
=
identifierInfo
.
thread_id
;
}
if
(
!
gathered
.
put
(
request
.
pid
std
:
:
move
(
info
)
)
)
{
holder
-
>
Reject
(
NS_ERROR_OUT_OF_MEMORY
__func__
)
;
return
;
}
}
holder
-
>
Resolve
(
std
:
:
move
(
gathered
)
__func__
)
;
}
)
;
rv
=
target
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
the
LoadDataRunnable
.
"
)
;
}
return
promise
;
}
}
