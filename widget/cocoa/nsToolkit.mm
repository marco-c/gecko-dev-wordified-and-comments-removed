#
include
"
nsToolkit
.
h
"
#
include
<
ctype
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
mach
/
mach_port
.
h
>
#
include
<
mach
/
mach_interface
.
h
>
#
include
<
mach
/
mach_init
.
h
>
extern
"
C
"
{
#
include
<
mach
-
o
/
getsect
.
h
>
}
#
include
<
unistd
.
h
>
#
include
<
dlfcn
.
h
>
#
import
<
Cocoa
/
Cocoa
.
h
>
#
import
<
IOKit
/
pwr_mgt
/
IOPMLib
.
h
>
#
import
<
IOKit
/
IOMessage
.
h
>
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
NativeMenuSupport
.
h
"
using
namespace
mozilla
;
static
io_connect_t
gRootPort
=
MACH_PORT_NULL
;
nsToolkit
*
nsToolkit
:
:
gToolkit
=
nullptr
;
nsToolkit
:
:
nsToolkit
(
)
:
mSleepWakeNotificationRLS
(
nullptr
)
mPowerNotifier
{
0
}
mAllProcessMouseMonitor
(
nil
)
{
MOZ_COUNT_CTOR
(
nsToolkit
)
;
RegisterForSleepWakeNotifications
(
)
;
}
nsToolkit
:
:
~
nsToolkit
(
)
{
MOZ_COUNT_DTOR
(
nsToolkit
)
;
RemoveSleepWakeNotifications
(
)
;
StopMonitoringAllProcessMouseEvents
(
)
;
}
void
nsToolkit
:
:
PostSleepWakeNotification
(
const
char
*
aNotification
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
observerService
-
>
NotifyObservers
(
nullptr
aNotification
nullptr
)
;
}
static
void
ToolkitSleepWakeCallback
(
void
*
refCon
io_service_t
service
natural_t
messageType
void
*
messageArgument
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
switch
(
messageType
)
{
case
kIOMessageSystemWillSleep
:
nsToolkit
:
:
PostSleepWakeNotification
(
NS_WIDGET_SLEEP_OBSERVER_TOPIC
)
;
:
:
IOAllowPowerChange
(
gRootPort
(
long
)
messageArgument
)
;
break
;
case
kIOMessageCanSystemSleep
:
:
:
IOAllowPowerChange
(
gRootPort
(
long
)
messageArgument
)
;
break
;
case
kIOMessageSystemHasPoweredOn
:
nsToolkit
:
:
PostSleepWakeNotification
(
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
;
break
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsresult
nsToolkit
:
:
RegisterForSleepWakeNotifications
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
IONotificationPortRef
notifyPortRef
;
NS_ASSERTION
(
!
mSleepWakeNotificationRLS
"
Already
registered
for
sleep
/
wake
"
)
;
gRootPort
=
:
:
IORegisterForSystemPower
(
0
&
notifyPortRef
ToolkitSleepWakeCallback
&
mPowerNotifier
)
;
if
(
gRootPort
=
=
MACH_PORT_NULL
)
{
NS_ERROR
(
"
IORegisterForSystemPower
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
mSleepWakeNotificationRLS
=
:
:
IONotificationPortGetRunLoopSource
(
notifyPortRef
)
;
:
:
CFRunLoopAddSource
(
:
:
CFRunLoopGetCurrent
(
)
mSleepWakeNotificationRLS
kCFRunLoopDefaultMode
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsToolkit
:
:
RemoveSleepWakeNotifications
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mSleepWakeNotificationRLS
)
{
:
:
IODeregisterForSystemPower
(
&
mPowerNotifier
)
;
:
:
CFRunLoopRemoveSource
(
:
:
CFRunLoopGetCurrent
(
)
mSleepWakeNotificationRLS
kCFRunLoopDefaultMode
)
;
mSleepWakeNotificationRLS
=
nullptr
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsToolkit
:
:
MonitorAllProcessMouseEvents
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mozilla
:
:
widget
:
:
NativeMenuSupport
:
:
ShouldUseNativeContextMenus
(
)
)
{
return
;
}
if
(
getenv
(
"
MOZ_NO_GLOBAL_MOUSE_MONITOR
"
)
)
return
;
if
(
mAllProcessMouseMonitor
=
=
nil
)
{
mAllProcessMouseMonitor
=
[
NSEvent
addGlobalMonitorForEventsMatchingMask
:
NSEventMaskLeftMouseDown
|
NSEventMaskLeftMouseDown
handler
:
^
(
NSEvent
*
evt
)
{
if
(
[
NSApp
isActive
]
)
{
return
;
}
nsIRollupListener
*
rollupListener
=
nsIWidget
:
:
GetActiveRollupListener
(
)
;
if
(
!
rollupListener
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
!
rollupWidget
)
{
return
;
}
NSWindow
*
ctxMenuWindow
=
(
NSWindow
*
)
rollupWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
!
ctxMenuWindow
)
{
return
;
}
NSPoint
screenLocation
=
[
NSEvent
mouseLocation
]
;
if
(
NSPointInRect
(
screenLocation
[
ctxMenuWindow
frame
]
)
)
{
return
;
}
rollupListener
-
>
Rollup
(
{
}
)
;
}
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsToolkit
:
:
StopMonitoringAllProcessMouseEvents
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mAllProcessMouseMonitor
!
=
nil
)
{
[
NSEvent
removeMonitor
:
mAllProcessMouseMonitor
]
;
mAllProcessMouseMonitor
=
nil
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsToolkit
*
nsToolkit
:
:
GetToolkit
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
gToolkit
)
{
gToolkit
=
new
nsToolkit
(
)
;
}
return
gToolkit
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nullptr
)
;
}
nsresult
nsToolkit
:
:
SwizzleMethods
(
Class
aClass
SEL
orgMethod
SEL
posedMethod
bool
classMethods
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
Method
original
=
nil
;
Method
posed
=
nil
;
if
(
classMethods
)
{
original
=
class_getClassMethod
(
aClass
orgMethod
)
;
posed
=
class_getClassMethod
(
aClass
posedMethod
)
;
}
else
{
original
=
class_getInstanceMethod
(
aClass
orgMethod
)
;
posed
=
class_getInstanceMethod
(
aClass
posedMethod
)
;
}
if
(
!
original
|
|
!
posed
)
return
NS_ERROR_FAILURE
;
method_exchangeImplementations
(
original
posed
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
