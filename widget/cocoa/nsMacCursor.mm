#
include
"
nsMacCursor
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsString
.
h
"
interface
nsMacCursor
(
PrivateMethods
)
-
(
int
)
getNextCursorFrame
;
-
(
int
)
numFrames
;
-
(
void
)
createTimer
;
-
(
void
)
destroyTimer
;
-
(
void
)
advanceAnimatedCursor
:
(
NSTimer
*
)
aTimer
;
-
(
void
)
setFrame
:
(
int
)
aFrameIndex
;
end
interface
nsCocoaCursor
:
nsMacCursor
{
private
NSArray
*
mFrames
;
NSCursor
*
mLastSetCocoaCursor
;
}
-
(
id
)
initWithFrames
:
(
NSArray
*
)
aCursorFrames
type
:
(
nsCursor
)
aType
;
-
(
id
)
initWithCursor
:
(
NSCursor
*
)
aCursor
type
:
(
nsCursor
)
aType
;
-
(
id
)
initWithImageNamed
:
(
NSString
*
)
aCursorImage
hotSpot
:
(
NSPoint
)
aPoint
type
:
(
nsCursor
)
aType
;
end
implementation
nsMacCursor
+
(
nsMacCursor
*
)
cursorWithCursor
:
(
NSCursor
*
)
aCursor
type
:
(
nsCursor
)
aType
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
[
[
nsCocoaCursor
alloc
]
initWithCursor
:
aCursor
type
:
aType
]
autorelease
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
+
(
nsMacCursor
*
)
cursorWithImageNamed
:
(
NSString
*
)
aCursorImage
hotSpot
:
(
NSPoint
)
aPoint
type
:
(
nsCursor
)
aType
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
[
[
nsCocoaCursor
alloc
]
initWithImageNamed
:
aCursorImage
hotSpot
:
aPoint
type
:
aType
]
autorelease
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
+
(
nsMacCursor
*
)
cursorWithFrames
:
(
NSArray
*
)
aCursorFrames
type
:
(
nsCursor
)
aType
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
[
[
nsCocoaCursor
alloc
]
initWithFrames
:
aCursorFrames
type
:
aType
]
autorelease
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
+
(
NSCursor
*
)
cocoaCursorWithImageNamed
:
(
NSString
*
)
imageName
hotSpot
:
(
NSPoint
)
aPoint
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
nsCOMPtr
<
nsIFile
>
resDir
;
nsAutoCString
resPath
;
NSString
*
pathToImage
*
pathToHiDpiImage
;
NSImage
*
cursorImage
*
hiDpiCursorImage
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
resDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
goto
INIT_FAILURE
;
resDir
-
>
AppendNative
(
"
res
"
_ns
)
;
resDir
-
>
AppendNative
(
"
cursors
"
_ns
)
;
rv
=
resDir
-
>
GetNativePath
(
resPath
)
;
if
(
NS_FAILED
(
rv
)
)
goto
INIT_FAILURE
;
pathToImage
=
[
NSString
stringWithUTF8String
:
(
const
char
*
)
resPath
.
get
(
)
]
;
if
(
!
pathToImage
)
goto
INIT_FAILURE
;
pathToImage
=
[
pathToImage
stringByAppendingPathComponent
:
imageName
]
;
pathToHiDpiImage
=
[
pathToImage
stringByAppendingString
:
"
2x
"
]
;
pathToImage
=
[
pathToImage
stringByAppendingPathExtension
:
"
png
"
]
;
pathToHiDpiImage
=
[
pathToHiDpiImage
stringByAppendingPathExtension
:
"
png
"
]
;
cursorImage
=
[
[
[
NSImage
alloc
]
initWithContentsOfFile
:
pathToImage
]
autorelease
]
;
if
(
!
cursorImage
)
goto
INIT_FAILURE
;
hiDpiCursorImage
=
[
[
[
NSImage
alloc
]
initWithContentsOfFile
:
pathToHiDpiImage
]
autorelease
]
;
if
(
hiDpiCursorImage
)
{
NSImageRep
*
imageRep
=
[
[
hiDpiCursorImage
representations
]
objectAtIndex
:
0
]
;
[
cursorImage
addRepresentation
:
imageRep
]
;
}
return
[
[
[
NSCursor
alloc
]
initWithImage
:
cursorImage
hotSpot
:
aPoint
]
autorelease
]
;
INIT_FAILURE
:
NS_WARNING
(
"
Problem
getting
path
to
cursor
image
file
!
"
)
;
[
self
release
]
;
return
nil
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
BOOL
)
isSet
{
return
NO
;
}
-
(
void
)
set
{
if
(
[
self
isAnimated
]
)
{
[
self
createTimer
]
;
}
if
(
!
mTimer
)
{
[
self
setFrame
:
0
]
;
}
}
-
(
void
)
unset
{
[
self
destroyTimer
]
;
}
-
(
BOOL
)
isAnimated
{
return
[
self
numFrames
]
>
1
;
}
-
(
int
)
numFrames
{
return
1
;
}
-
(
int
)
getNextCursorFrame
{
mFrameCounter
=
(
mFrameCounter
+
1
)
%
[
self
numFrames
]
;
return
mFrameCounter
;
}
-
(
void
)
createTimer
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mTimer
)
{
mTimer
=
[
[
NSTimer
scheduledTimerWithTimeInterval
:
0
.
25
target
:
self
selector
:
selector
(
advanceAnimatedCursor
:
)
userInfo
:
nil
repeats
:
YES
]
retain
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
destroyTimer
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mTimer
)
{
[
mTimer
invalidate
]
;
[
mTimer
release
]
;
mTimer
=
nil
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
advanceAnimatedCursor
:
(
NSTimer
*
)
aTimer
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
[
aTimer
isValid
]
)
{
[
self
setFrame
:
[
self
getNextCursorFrame
]
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
setFrame
:
(
int
)
aFrameIndex
{
}
-
(
nsCursor
)
type
{
return
mType
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
self
destroyTimer
]
;
[
super
dealloc
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
end
implementation
nsCocoaCursor
-
(
id
)
initWithFrames
:
(
NSArray
*
)
aCursorFrames
type
:
(
nsCursor
)
aType
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
self
=
[
super
init
]
;
NSEnumerator
*
it
=
[
aCursorFrames
objectEnumerator
]
;
NSObject
*
frame
=
nil
;
while
(
(
frame
=
[
it
nextObject
]
)
)
{
NS_ASSERTION
(
[
frame
isKindOfClass
:
[
NSCursor
class
]
]
"
Invalid
argument
:
All
frames
must
be
of
type
NSCursor
"
)
;
}
mFrames
=
[
aCursorFrames
retain
]
;
mFrameCounter
=
0
;
mType
=
aType
;
return
self
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
initWithCursor
:
(
NSCursor
*
)
aCursor
type
:
(
nsCursor
)
aType
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
NSArray
*
frame
=
[
NSArray
arrayWithObjects
:
aCursor
nil
]
;
return
[
self
initWithFrames
:
frame
type
:
aType
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
id
)
initWithImageNamed
:
(
NSString
*
)
aCursorImage
hotSpot
:
(
NSPoint
)
aPoint
type
:
(
nsCursor
)
aType
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
self
initWithCursor
:
[
nsMacCursor
cocoaCursorWithImageNamed
:
aCursorImage
hotSpot
:
aPoint
]
type
:
aType
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
BOOL
)
isSet
{
return
[
NSCursor
currentCursor
]
=
=
mLastSetCocoaCursor
;
}
-
(
void
)
setFrame
:
(
int
)
aFrameIndex
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSCursor
*
newCursor
=
[
mFrames
objectAtIndex
:
aFrameIndex
]
;
[
newCursor
set
]
;
mLastSetCocoaCursor
=
newCursor
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
int
)
numFrames
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
[
mFrames
count
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
0
)
;
}
-
(
NSString
*
)
description
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
return
[
mFrames
description
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
mFrames
release
]
;
[
super
dealloc
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
end
