#
import
<
AVFoundation
/
AVFoundation
.
h
>
#
include
<
cmath
>
#
include
"
AppleUtils
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaWindow
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIAppShellService
.
h
"
#
include
"
nsIOSPermissionRequest
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
StaticMutex
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
#
include
"
mozilla
/
SVGImageContext
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
using
mozilla
:
:
dom
:
:
Promise
;
using
mozilla
:
:
gfx
:
:
DataSourceSurface
;
using
mozilla
:
:
gfx
:
:
DrawTarget
;
using
mozilla
:
:
gfx
:
:
SamplingFilter
;
using
mozilla
:
:
gfx
:
:
IntPoint
;
using
mozilla
:
:
gfx
:
:
IntRect
;
using
mozilla
:
:
gfx
:
:
IntSize
;
using
mozilla
:
:
gfx
:
:
SurfaceFormat
;
using
mozilla
:
:
gfx
:
:
SourceSurface
;
using
mozilla
:
:
image
:
:
ImageRegion
;
LazyLogModule
gCocoaUtilsLog
(
"
nsCocoaUtils
"
)
;
#
undef
LOG
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
gCocoaUtilsLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
nsCocoaUtils
:
:
PromiseArray
nsCocoaUtils
:
:
sVideoCapturePromises
;
nsCocoaUtils
:
:
PromiseArray
nsCocoaUtils
:
:
sAudioCapturePromises
;
StaticMutex
nsCocoaUtils
:
:
sMediaCaptureMutex
;
static
float
MenuBarScreenHeight
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSArray
*
allScreens
=
[
NSScreen
screens
]
;
if
(
[
allScreens
count
]
)
{
return
[
[
allScreens
objectAtIndex
:
0
]
frame
]
.
size
.
height
;
}
return
0
.
0
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
0
.
0
)
;
}
float
nsCocoaUtils
:
:
FlippedScreenY
(
float
y
)
{
return
MenuBarScreenHeight
(
)
-
y
;
}
NSRect
nsCocoaUtils
:
:
GeckoRectToCocoaRect
(
const
DesktopIntRect
&
geckoRect
)
{
return
NSMakeRect
(
geckoRect
.
x
MenuBarScreenHeight
(
)
-
geckoRect
.
YMost
(
)
geckoRect
.
width
geckoRect
.
height
)
;
}
NSPoint
nsCocoaUtils
:
:
GeckoPointToCocoaPoint
(
const
mozilla
:
:
DesktopPoint
&
aPoint
)
{
return
NSMakePoint
(
aPoint
.
x
MenuBarScreenHeight
(
)
-
aPoint
.
y
)
;
}
NSRect
nsCocoaUtils
:
:
GeckoRectToCocoaRectDevPix
(
const
LayoutDeviceIntRect
&
aGeckoRect
CGFloat
aBackingScale
)
{
return
NSMakeRect
(
aGeckoRect
.
x
/
aBackingScale
MenuBarScreenHeight
(
)
-
aGeckoRect
.
YMost
(
)
/
aBackingScale
aGeckoRect
.
width
/
aBackingScale
aGeckoRect
.
height
/
aBackingScale
)
;
}
DesktopIntRect
nsCocoaUtils
:
:
CocoaRectToGeckoRect
(
const
NSRect
&
cocoaRect
)
{
DesktopIntRect
rect
;
rect
.
x
=
NSToIntRound
(
cocoaRect
.
origin
.
x
)
;
rect
.
y
=
NSToIntRound
(
FlippedScreenY
(
cocoaRect
.
origin
.
y
+
cocoaRect
.
size
.
height
)
)
;
rect
.
width
=
NSToIntRound
(
cocoaRect
.
origin
.
x
+
cocoaRect
.
size
.
width
)
-
rect
.
x
;
rect
.
height
=
NSToIntRound
(
FlippedScreenY
(
cocoaRect
.
origin
.
y
)
)
-
rect
.
y
;
return
rect
;
}
LayoutDeviceIntRect
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
const
NSRect
&
aCocoaRect
CGFloat
aBackingScale
)
{
LayoutDeviceIntRect
rect
;
rect
.
x
=
NSToIntRound
(
aCocoaRect
.
origin
.
x
*
aBackingScale
)
;
rect
.
y
=
NSToIntRound
(
FlippedScreenY
(
aCocoaRect
.
origin
.
y
+
aCocoaRect
.
size
.
height
)
*
aBackingScale
)
;
rect
.
width
=
NSToIntRound
(
(
aCocoaRect
.
origin
.
x
+
aCocoaRect
.
size
.
width
)
*
aBackingScale
)
-
rect
.
x
;
rect
.
height
=
NSToIntRound
(
FlippedScreenY
(
aCocoaRect
.
origin
.
y
)
*
aBackingScale
)
-
rect
.
y
;
return
rect
;
}
NSPoint
nsCocoaUtils
:
:
ScreenLocationForEvent
(
NSEvent
*
anEvent
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
anEvent
|
|
[
anEvent
type
]
=
=
NSEventTypeMouseMoved
)
return
[
NSEvent
mouseLocation
]
;
if
(
IsMomentumScrollEvent
(
anEvent
)
)
return
ChildViewMouseTracker
:
:
sLastScrollEventScreenLocation
;
return
nsCocoaUtils
:
:
ConvertPointToScreen
(
[
anEvent
window
]
[
anEvent
locationInWindow
]
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSMakePoint
(
0
.
0
0
.
0
)
)
;
}
BOOL
nsCocoaUtils
:
:
IsEventOverWindow
(
NSEvent
*
anEvent
NSWindow
*
aWindow
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
NSPointInRect
(
ScreenLocationForEvent
(
anEvent
)
[
aWindow
frame
]
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
NSPoint
nsCocoaUtils
:
:
EventLocationForWindow
(
NSEvent
*
anEvent
NSWindow
*
aWindow
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
nsCocoaUtils
:
:
ConvertPointFromScreen
(
aWindow
ScreenLocationForEvent
(
anEvent
)
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSMakePoint
(
0
.
0
0
.
0
)
)
;
}
BOOL
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
NSEvent
*
aEvent
)
{
return
[
aEvent
type
]
=
=
NSEventTypeScrollWheel
&
&
[
aEvent
momentumPhase
]
!
=
NSEventPhaseNone
;
}
BOOL
nsCocoaUtils
:
:
EventHasPhaseInformation
(
NSEvent
*
aEvent
)
{
return
[
aEvent
phase
]
!
=
NSEventPhaseNone
|
|
[
aEvent
momentumPhase
]
!
=
NSEventPhaseNone
;
}
void
nsCocoaUtils
:
:
HideOSChromeOnScreen
(
bool
aShouldHide
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
static
int
sHiddenCount
=
0
;
sHiddenCount
+
=
aShouldHide
?
1
:
-
1
;
NS_ASSERTION
(
sHiddenCount
>
=
0
"
Unbalanced
HideMenuAndDockForWindow
calls
"
)
;
NSApplicationPresentationOptions
options
=
sHiddenCount
<
=
0
?
NSApplicationPresentationDefault
:
NSApplicationPresentationHideDock
|
NSApplicationPresentationHideMenuBar
;
[
NSApp
setPresentationOptions
:
options
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
define
NS_APPSHELLSERVICE_CONTRACTID
"
mozilla
.
org
/
appshell
/
appShellService
;
1
"
nsIWidget
*
nsCocoaUtils
:
:
GetHiddenWindowWidget
(
)
{
nsCOMPtr
<
nsIAppShellService
>
appShell
(
do_GetService
(
NS_APPSHELLSERVICE_CONTRACTID
)
)
;
if
(
!
appShell
)
{
NS_WARNING
(
"
Couldn
'
t
get
AppShellService
in
order
to
get
hidden
window
ref
"
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIAppWindow
>
hiddenWindow
;
appShell
-
>
GetHiddenWindow
(
getter_AddRefs
(
hiddenWindow
)
)
;
if
(
!
hiddenWindow
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseHiddenWindow
;
baseHiddenWindow
=
do_GetInterface
(
hiddenWindow
)
;
if
(
!
baseHiddenWindow
)
{
NS_WARNING
(
"
Couldn
'
t
get
nsIBaseWindow
from
hidden
window
(
nsIAppWindow
)
"
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
hiddenWindowWidget
;
if
(
NS_FAILED
(
baseHiddenWindow
-
>
GetMainWidget
(
getter_AddRefs
(
hiddenWindowWidget
)
)
)
)
{
NS_WARNING
(
"
Couldn
'
t
get
nsIWidget
from
hidden
window
(
nsIBaseWindow
)
"
)
;
return
nullptr
;
}
return
hiddenWindowWidget
;
}
void
nsCocoaUtils
:
:
PrepareForNativeAppModalDialog
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsMenuBarX
*
hiddenWindowMenuBar
=
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
;
if
(
!
hiddenWindowMenuBar
)
return
;
hiddenWindowMenuBar
-
>
Paint
(
)
;
NSMenu
*
mainMenu
=
[
NSApp
mainMenu
]
;
NS_ASSERTION
(
[
mainMenu
numberOfItems
]
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
NSMenu
*
newMenuBar
=
[
[
NSMenu
alloc
]
initWithTitle
:
"
"
]
;
NSMenuItem
*
firstMenuItem
=
[
[
mainMenu
itemAtIndex
:
0
]
retain
]
;
[
mainMenu
removeItemAtIndex
:
0
]
;
[
newMenuBar
insertItem
:
firstMenuItem
atIndex
:
0
]
;
[
firstMenuItem
release
]
;
[
newMenuBar
addItem
:
nsMenuUtilsX
:
:
GetStandardEditMenuItem
(
)
]
;
[
NSApp
setMainMenu
:
newMenuBar
]
;
[
newMenuBar
release
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsCocoaUtils
:
:
CleanUpAfterNativeAppModalDialog
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsMenuBarX
*
hiddenWindowMenuBar
=
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
;
if
(
!
hiddenWindowMenuBar
)
return
;
NSWindow
*
mainWindow
=
[
NSApp
mainWindow
]
;
if
(
!
mainWindow
)
hiddenWindowMenuBar
-
>
Paint
(
)
;
else
[
WindowDelegate
paintMenubarForWindow
:
mainWindow
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
void
data_ss_release_callback
(
void
*
aDataSourceSurface
const
void
*
data
size_t
size
)
{
if
(
aDataSourceSurface
)
{
static_cast
<
DataSourceSurface
*
>
(
aDataSourceSurface
)
-
>
Unmap
(
)
;
static_cast
<
DataSourceSurface
*
>
(
aDataSourceSurface
)
-
>
Release
(
)
;
}
}
static
bool
ComputeIsEntirelyBlack
(
const
DataSourceSurface
:
:
MappedSurface
&
aMap
const
IntSize
&
aSize
)
{
for
(
int32_t
y
=
0
;
y
<
aSize
.
height
;
y
+
+
)
{
size_t
rowStart
=
y
*
aMap
.
mStride
;
for
(
int32_t
x
=
0
;
x
<
aSize
.
width
;
x
+
+
)
{
size_t
index
=
rowStart
+
x
*
4
;
if
(
aMap
.
mData
[
index
+
0
]
!
=
0
|
|
aMap
.
mData
[
index
+
1
]
!
=
0
|
|
aMap
.
mData
[
index
+
2
]
!
=
0
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
nsCocoaUtils
:
:
CreateCGImageFromSurface
(
SourceSurface
*
aSurface
CGImageRef
*
aResult
bool
*
aIsEntirelyBlack
)
{
RefPtr
<
DataSourceSurface
>
dataSurface
;
if
(
aSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
)
{
dataSurface
=
aSurface
-
>
GetDataSurface
(
)
;
}
else
{
dataSurface
=
gfxUtils
:
:
CopySurfaceToDataSourceSurfaceWithFormat
(
aSurface
SurfaceFormat
:
:
B8G8R8A8
)
;
}
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
int32_t
width
=
dataSurface
-
>
GetSize
(
)
.
width
;
int32_t
height
=
dataSurface
-
>
GetSize
(
)
.
height
;
if
(
height
<
1
|
|
width
<
1
)
{
return
NS_ERROR_FAILURE
;
}
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
dataSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aIsEntirelyBlack
)
{
*
aIsEntirelyBlack
=
ComputeIsEntirelyBlack
(
map
dataSurface
-
>
GetSize
(
)
)
;
}
CGDataProviderRef
dataProvider
=
:
:
CGDataProviderCreateWithData
(
dataSurface
.
forget
(
)
.
take
(
)
map
.
mData
map
.
mStride
*
height
data_ss_release_callback
)
;
CGColorSpaceRef
colorSpace
=
:
:
CGColorSpaceCreateWithName
(
kCGColorSpaceGenericRGB
)
;
*
aResult
=
:
:
CGImageCreate
(
width
height
8
32
map
.
mStride
colorSpace
kCGBitmapByteOrder32Host
|
kCGImageAlphaPremultipliedFirst
dataProvider
NULL
0
kCGRenderingIntentDefault
)
;
:
:
CGColorSpaceRelease
(
colorSpace
)
;
:
:
CGDataProviderRelease
(
dataProvider
)
;
return
*
aResult
?
NS_OK
:
NS_ERROR_FAILURE
;
}
nsresult
nsCocoaUtils
:
:
CreateNSImageFromCGImage
(
CGImageRef
aInputImage
NSImage
*
*
aResult
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
int32_t
width
=
:
:
CGImageGetWidth
(
aInputImage
)
;
int32_t
height
=
:
:
CGImageGetHeight
(
aInputImage
)
;
NSRect
imageRect
=
:
:
NSMakeRect
(
0
.
0
0
.
0
width
height
)
;
NSBitmapImageRep
*
offscreenRep
=
[
[
NSBitmapImageRep
alloc
]
initWithBitmapDataPlanes
:
NULL
pixelsWide
:
width
pixelsHigh
:
height
bitsPerSample
:
8
samplesPerPixel
:
4
hasAlpha
:
YES
isPlanar
:
NO
colorSpaceName
:
NSDeviceRGBColorSpace
bitmapFormat
:
NSAlphaFirstBitmapFormat
bytesPerRow
:
0
bitsPerPixel
:
0
]
;
NSGraphicsContext
*
context
=
[
NSGraphicsContext
graphicsContextWithBitmapImageRep
:
offscreenRep
]
;
[
NSGraphicsContext
saveGraphicsState
]
;
[
NSGraphicsContext
setCurrentContext
:
context
]
;
CGContextRef
imageContext
=
(
CGContextRef
)
[
[
NSGraphicsContext
currentContext
]
graphicsPort
]
;
:
:
CGContextDrawImage
(
imageContext
*
(
CGRect
*
)
&
imageRect
aInputImage
)
;
[
NSGraphicsContext
restoreGraphicsState
]
;
*
aResult
=
[
[
NSImage
alloc
]
initWithSize
:
NSMakeSize
(
width
height
)
]
;
[
*
aResult
addRepresentation
:
offscreenRep
]
;
[
offscreenRep
release
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsCocoaUtils
:
:
CreateNSImageFromImageContainer
(
imgIContainer
*
aImage
uint32_t
aWhichFrame
const
nsPresContext
*
aPresContext
const
ComputedStyle
*
aComputedStyle
NSImage
*
*
aResult
CGFloat
scaleFactor
bool
*
aIsEntirelyBlack
)
{
RefPtr
<
SourceSurface
>
surface
;
int32_t
width
=
0
height
=
0
;
aImage
-
>
GetWidth
(
&
width
)
;
aImage
-
>
GetHeight
(
&
height
)
;
if
(
aImage
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
IntSize
scaledSize
=
IntSize
:
:
Ceil
(
width
*
scaleFactor
height
*
scaleFactor
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
scaledSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
drawTarget
|
|
!
drawTarget
-
>
IsValid
(
)
)
{
NS_ERROR
(
"
Failed
to
create
valid
DrawTarget
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
gfxContext
>
context
=
gfxContext
:
:
CreateOrNull
(
drawTarget
)
;
MOZ_ASSERT
(
context
)
;
SVGImageContext
svgContext
;
if
(
aPresContext
&
&
aComputedStyle
)
{
SVGImageContext
:
:
MaybeStoreContextPaint
(
svgContext
*
aPresContext
*
aComputedStyle
aImage
)
;
}
mozilla
:
:
image
:
:
ImgDrawResult
res
=
aImage
-
>
Draw
(
context
scaledSize
ImageRegion
:
:
Create
(
scaledSize
)
aWhichFrame
SamplingFilter
:
:
POINT
svgContext
imgIContainer
:
:
FLAG_SYNC_DECODE
1
.
0
)
;
if
(
res
!
=
mozilla
:
:
image
:
:
ImgDrawResult
:
:
SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
surface
=
drawTarget
-
>
Snapshot
(
)
;
}
else
{
surface
=
aImage
-
>
GetFrame
(
aWhichFrame
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
)
;
}
NS_ENSURE_TRUE
(
surface
NS_ERROR_FAILURE
)
;
CGImageRef
imageRef
=
NULL
;
nsresult
rv
=
nsCocoaUtils
:
:
CreateCGImageFromSurface
(
surface
&
imageRef
aIsEntirelyBlack
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
imageRef
)
{
return
NS_ERROR_FAILURE
;
}
rv
=
nsCocoaUtils
:
:
CreateNSImageFromCGImage
(
imageRef
aResult
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
aResult
)
{
return
NS_ERROR_FAILURE
;
}
:
:
CGImageRelease
(
imageRef
)
;
NSSize
size
=
NSMakeSize
(
width
height
)
;
[
*
aResult
setSize
:
size
]
;
[
[
[
*
aResult
representations
]
objectAtIndex
:
0
]
setSize
:
size
]
;
return
NS_OK
;
}
nsresult
nsCocoaUtils
:
:
CreateDualRepresentationNSImageFromImageContainer
(
imgIContainer
*
aImage
uint32_t
aWhichFrame
const
nsPresContext
*
aPresContext
const
ComputedStyle
*
aComputedStyle
NSImage
*
*
aResult
bool
*
aIsEntirelyBlack
)
{
int32_t
width
=
0
height
=
0
;
aImage
-
>
GetWidth
(
&
width
)
;
aImage
-
>
GetHeight
(
&
height
)
;
NSSize
size
=
NSMakeSize
(
width
height
)
;
*
aResult
=
[
[
NSImage
alloc
]
init
]
;
[
*
aResult
setSize
:
size
]
;
NSImage
*
newRepresentation
=
nil
;
nsresult
rv
=
CreateNSImageFromImageContainer
(
aImage
aWhichFrame
aPresContext
aComputedStyle
&
newRepresentation
1
.
0f
aIsEntirelyBlack
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
newRepresentation
)
{
return
NS_ERROR_FAILURE
;
}
[
[
[
newRepresentation
representations
]
objectAtIndex
:
0
]
setSize
:
size
]
;
[
*
aResult
addRepresentation
:
[
[
newRepresentation
representations
]
objectAtIndex
:
0
]
]
;
[
newRepresentation
release
]
;
newRepresentation
=
nil
;
rv
=
CreateNSImageFromImageContainer
(
aImage
aWhichFrame
aPresContext
aComputedStyle
&
newRepresentation
2
.
0f
aIsEntirelyBlack
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
newRepresentation
)
{
return
NS_ERROR_FAILURE
;
}
[
[
[
newRepresentation
representations
]
objectAtIndex
:
0
]
setSize
:
size
]
;
[
*
aResult
addRepresentation
:
[
[
newRepresentation
representations
]
objectAtIndex
:
0
]
]
;
[
newRepresentation
release
]
;
return
NS_OK
;
}
void
nsCocoaUtils
:
:
GetStringForNSString
(
const
NSString
*
aSrc
nsAString
&
aDist
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
aSrc
)
{
aDist
.
Truncate
(
)
;
return
;
}
aDist
.
SetLength
(
[
aSrc
length
]
)
;
[
aSrc
getCharacters
:
reinterpret_cast
<
unichar
*
>
(
aDist
.
BeginWriting
(
)
)
range
:
NSMakeRange
(
0
[
aSrc
length
]
)
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
NSString
*
nsCocoaUtils
:
:
ToNSString
(
const
nsAString
&
aString
)
{
if
(
aString
.
IsEmpty
(
)
)
{
return
[
NSString
string
]
;
}
return
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aString
.
BeginReading
(
)
)
length
:
aString
.
Length
(
)
]
;
}
NSString
*
nsCocoaUtils
:
:
ToNSString
(
const
nsACString
&
aCString
)
{
if
(
aCString
.
IsEmpty
(
)
)
{
return
[
NSString
string
]
;
}
return
[
[
[
NSString
alloc
]
initWithBytes
:
aCString
.
BeginReading
(
)
length
:
aCString
.
Length
(
)
encoding
:
NSUTF8StringEncoding
]
autorelease
]
;
}
NSURL
*
nsCocoaUtils
:
:
ToNSURL
(
const
nsAString
&
aURLString
)
{
nsAutoCString
encodedURLString
;
nsresult
rv
=
NS_GetSpecWithNSURLEncoding
(
encodedURLString
NS_ConvertUTF16toUTF8
(
aURLString
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
NSString
*
encodedURLNSString
=
ToNSString
(
encodedURLString
)
;
if
(
!
encodedURLNSString
)
{
return
nullptr
;
}
return
[
NSURL
URLWithString
:
encodedURLNSString
]
;
}
void
nsCocoaUtils
:
:
GeckoRectToNSRect
(
const
nsIntRect
&
aGeckoRect
NSRect
&
aOutCocoaRect
)
{
aOutCocoaRect
.
origin
.
x
=
aGeckoRect
.
x
;
aOutCocoaRect
.
origin
.
y
=
aGeckoRect
.
y
;
aOutCocoaRect
.
size
.
width
=
aGeckoRect
.
width
;
aOutCocoaRect
.
size
.
height
=
aGeckoRect
.
height
;
}
void
nsCocoaUtils
:
:
NSRectToGeckoRect
(
const
NSRect
&
aCocoaRect
nsIntRect
&
aOutGeckoRect
)
{
aOutGeckoRect
.
x
=
NSToIntRound
(
aCocoaRect
.
origin
.
x
)
;
aOutGeckoRect
.
y
=
NSToIntRound
(
aCocoaRect
.
origin
.
y
)
;
aOutGeckoRect
.
width
=
NSToIntRound
(
aCocoaRect
.
origin
.
x
+
aCocoaRect
.
size
.
width
)
-
aOutGeckoRect
.
x
;
aOutGeckoRect
.
height
=
NSToIntRound
(
aCocoaRect
.
origin
.
y
+
aCocoaRect
.
size
.
height
)
-
aOutGeckoRect
.
y
;
}
NSEvent
*
nsCocoaUtils
:
:
MakeNewCocoaEventWithType
(
NSEventType
aEventType
NSEvent
*
aEvent
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSEvent
*
newEvent
=
[
NSEvent
keyEventWithType
:
aEventType
location
:
[
aEvent
locationInWindow
]
modifierFlags
:
[
aEvent
modifierFlags
]
timestamp
:
[
aEvent
timestamp
]
windowNumber
:
[
aEvent
windowNumber
]
context
:
nil
characters
:
[
aEvent
characters
]
charactersIgnoringModifiers
:
[
aEvent
charactersIgnoringModifiers
]
isARepeat
:
[
aEvent
isARepeat
]
keyCode
:
[
aEvent
keyCode
]
]
;
return
newEvent
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
NSEvent
*
nsCocoaUtils
:
:
MakeNewCococaEventFromWidgetEvent
(
const
WidgetKeyboardEvent
&
aKeyEvent
NSInteger
aWindowNumber
NSGraphicsContext
*
aContext
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSEventType
eventType
;
if
(
aKeyEvent
.
mMessage
=
=
eKeyUp
)
{
eventType
=
NSEventTypeKeyUp
;
}
else
{
eventType
=
NSEventTypeKeyDown
;
}
static
const
uint32_t
sModifierFlagMap
[
]
[
2
]
=
{
{
MODIFIER_SHIFT
NSEventModifierFlagShift
}
{
MODIFIER_CONTROL
NSEventModifierFlagControl
}
{
MODIFIER_ALT
NSEventModifierFlagOption
}
{
MODIFIER_ALTGRAPH
NSEventModifierFlagOption
}
{
MODIFIER_META
NSEventModifierFlagCommand
}
{
MODIFIER_CAPSLOCK
NSEventModifierFlagCapsLock
}
{
MODIFIER_NUMLOCK
NSEventModifierFlagNumericPad
}
}
;
NSUInteger
modifierFlags
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sModifierFlagMap
)
;
+
+
i
)
{
if
(
aKeyEvent
.
mModifiers
&
sModifierFlagMap
[
i
]
[
0
]
)
{
modifierFlags
|
=
sModifierFlagMap
[
i
]
[
1
]
;
}
}
NSString
*
characters
;
if
(
aKeyEvent
.
mCharCode
)
{
characters
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
&
(
aKeyEvent
.
mCharCode
)
)
length
:
1
]
;
}
else
{
uint32_t
cocoaCharCode
=
nsCocoaUtils
:
:
ConvertGeckoKeyCodeToMacCharCode
(
aKeyEvent
.
mKeyCode
)
;
characters
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
&
cocoaCharCode
)
length
:
1
]
;
}
return
[
NSEvent
keyEventWithType
:
eventType
location
:
NSMakePoint
(
0
0
)
modifierFlags
:
modifierFlags
timestamp
:
0
windowNumber
:
aWindowNumber
context
:
aContext
characters
:
characters
charactersIgnoringModifiers
:
characters
isARepeat
:
NO
keyCode
:
0
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
void
nsCocoaUtils
:
:
InitInputEvent
(
WidgetInputEvent
&
aInputEvent
NSEvent
*
aNativeEvent
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
aInputEvent
.
mModifiers
=
ModifiersForEvent
(
aNativeEvent
)
;
aInputEvent
.
mTime
=
PR_IntervalNow
(
)
;
aInputEvent
.
mTimeStamp
=
GetEventTimeStamp
(
[
aNativeEvent
timestamp
]
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
Modifiers
nsCocoaUtils
:
:
ModifiersForEvent
(
NSEvent
*
aNativeEvent
)
{
NSUInteger
modifiers
=
aNativeEvent
?
[
aNativeEvent
modifierFlags
]
:
[
NSEvent
modifierFlags
]
;
Modifiers
result
=
0
;
if
(
modifiers
&
NSEventModifierFlagShift
)
{
result
|
=
MODIFIER_SHIFT
;
}
if
(
modifiers
&
NSEventModifierFlagControl
)
{
result
|
=
MODIFIER_CONTROL
;
}
if
(
modifiers
&
NSEventModifierFlagOption
)
{
result
|
=
MODIFIER_ALT
;
result
|
=
MODIFIER_ALTGRAPH
;
}
if
(
modifiers
&
NSEventModifierFlagCommand
)
{
result
|
=
MODIFIER_META
;
}
if
(
modifiers
&
NSEventModifierFlagCapsLock
)
{
result
|
=
MODIFIER_CAPSLOCK
;
}
if
(
modifiers
&
NSEventModifierFlagNumericPad
)
{
result
|
=
MODIFIER_NUMLOCK
;
}
return
result
;
}
UInt32
nsCocoaUtils
:
:
ConvertToCarbonModifier
(
NSUInteger
aCocoaModifier
)
{
UInt32
carbonModifier
=
0
;
if
(
aCocoaModifier
&
NSEventModifierFlagCapsLock
)
{
carbonModifier
|
=
alphaLock
;
}
if
(
aCocoaModifier
&
NSEventModifierFlagControl
)
{
carbonModifier
|
=
controlKey
;
}
if
(
aCocoaModifier
&
NSEventModifierFlagOption
)
{
carbonModifier
|
=
optionKey
;
}
if
(
aCocoaModifier
&
NSEventModifierFlagShift
)
{
carbonModifier
|
=
shiftKey
;
}
if
(
aCocoaModifier
&
NSEventModifierFlagCommand
)
{
carbonModifier
|
=
cmdKey
;
}
if
(
aCocoaModifier
&
NSEventModifierFlagNumericPad
)
{
carbonModifier
|
=
kEventKeyModifierNumLockMask
;
}
if
(
aCocoaModifier
&
NSEventModifierFlagFunction
)
{
carbonModifier
|
=
kEventKeyModifierFnMask
;
}
return
carbonModifier
;
}
static
bool
sHiDPIEnabled
=
false
;
static
bool
sHiDPIPrefInitialized
=
false
;
bool
nsCocoaUtils
:
:
HiDPIEnabled
(
)
{
if
(
!
sHiDPIPrefInitialized
)
{
sHiDPIPrefInitialized
=
true
;
int
prefSetting
=
Preferences
:
:
GetInt
(
"
gfx
.
hidpi
.
enabled
"
1
)
;
if
(
prefSetting
<
=
0
)
{
return
false
;
}
int
scaleFactors
=
0
;
NSEnumerator
*
screenEnum
=
[
[
NSScreen
screens
]
objectEnumerator
]
;
while
(
NSScreen
*
screen
=
[
screenEnum
nextObject
]
)
{
NSDictionary
*
desc
=
[
screen
deviceDescription
]
;
if
(
[
desc
objectForKey
:
NSDeviceIsScreen
]
=
=
nil
)
{
continue
;
}
if
(
[
screen
backingScaleFactor
]
>
1
.
0
)
{
scaleFactors
|
=
2
;
}
else
{
scaleFactors
|
=
1
;
}
}
sHiDPIEnabled
=
(
scaleFactors
<
=
2
)
|
|
(
prefSetting
>
1
)
;
}
return
sHiDPIEnabled
;
}
void
nsCocoaUtils
:
:
InvalidateHiDPIState
(
)
{
sHiDPIPrefInitialized
=
false
;
}
void
nsCocoaUtils
:
:
GetCommandsFromKeyEvent
(
NSEvent
*
aEvent
nsTArray
<
KeyBindingsCommand
>
&
aCommands
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
MOZ_ASSERT
(
aEvent
)
;
static
NativeKeyBindingsRecorder
*
sNativeKeyBindingsRecorder
;
if
(
!
sNativeKeyBindingsRecorder
)
{
sNativeKeyBindingsRecorder
=
[
NativeKeyBindingsRecorder
new
]
;
}
[
sNativeKeyBindingsRecorder
startRecording
:
aCommands
]
;
[
sNativeKeyBindingsRecorder
interpretKeyEvents
:
[
NSArray
arrayWithObject
:
aEvent
]
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
implementation
NativeKeyBindingsRecorder
-
(
void
)
startRecording
:
(
nsTArray
<
KeyBindingsCommand
>
&
)
aCommands
{
mCommands
=
&
aCommands
;
mCommands
-
>
Clear
(
)
;
}
-
(
void
)
doCommandBySelector
:
(
SEL
)
aSelector
{
KeyBindingsCommand
command
=
{
aSelector
nil
}
;
mCommands
-
>
AppendElement
(
command
)
;
}
-
(
void
)
insertText
:
(
id
)
aString
{
KeyBindingsCommand
command
=
{
selector
(
insertText
:
)
aString
}
;
mCommands
-
>
AppendElement
(
command
)
;
}
end
struct
KeyConversionData
{
const
char
*
str
;
size_t
strLength
;
uint32_t
geckoKeyCode
;
uint32_t
charCode
;
}
;
static
const
KeyConversionData
gKeyConversions
[
]
=
{
#
define
KEYCODE_ENTRY
(
aStr
aCode
)
\
{
#
aStr
sizeof
(
#
aStr
)
-
1
NS_
#
#
aStr
aCode
}
#
define
KEYCODE_ENTRY2
(
aStr
aNSName
aCode
)
\
{
#
aStr
sizeof
(
#
aStr
)
-
1
NS_
#
#
aNSName
aCode
}
KEYCODE_ENTRY
(
VK_CANCEL
0x001B
)
KEYCODE_ENTRY
(
VK_DELETE
NSDeleteFunctionKey
)
KEYCODE_ENTRY
(
VK_BACK
NSBackspaceCharacter
)
KEYCODE_ENTRY2
(
VK_BACK_SPACE
VK_BACK
NSBackspaceCharacter
)
KEYCODE_ENTRY
(
VK_TAB
NSTabCharacter
)
KEYCODE_ENTRY
(
VK_CLEAR
NSClearLineFunctionKey
)
KEYCODE_ENTRY
(
VK_RETURN
NSEnterCharacter
)
KEYCODE_ENTRY
(
VK_SHIFT
0
)
KEYCODE_ENTRY
(
VK_CONTROL
0
)
KEYCODE_ENTRY
(
VK_ALT
0
)
KEYCODE_ENTRY
(
VK_PAUSE
NSPauseFunctionKey
)
KEYCODE_ENTRY
(
VK_CAPS_LOCK
0
)
KEYCODE_ENTRY
(
VK_ESCAPE
0
)
KEYCODE_ENTRY
(
VK_SPACE
'
'
)
KEYCODE_ENTRY
(
VK_PAGE_UP
NSPageUpFunctionKey
)
KEYCODE_ENTRY
(
VK_PAGE_DOWN
NSPageDownFunctionKey
)
KEYCODE_ENTRY
(
VK_END
NSEndFunctionKey
)
KEYCODE_ENTRY
(
VK_HOME
NSHomeFunctionKey
)
KEYCODE_ENTRY
(
VK_LEFT
NSLeftArrowFunctionKey
)
KEYCODE_ENTRY
(
VK_UP
NSUpArrowFunctionKey
)
KEYCODE_ENTRY
(
VK_RIGHT
NSRightArrowFunctionKey
)
KEYCODE_ENTRY
(
VK_DOWN
NSDownArrowFunctionKey
)
KEYCODE_ENTRY
(
VK_PRINTSCREEN
NSPrintScreenFunctionKey
)
KEYCODE_ENTRY
(
VK_INSERT
NSInsertFunctionKey
)
KEYCODE_ENTRY
(
VK_HELP
NSHelpFunctionKey
)
KEYCODE_ENTRY
(
VK_0
'
0
'
)
KEYCODE_ENTRY
(
VK_1
'
1
'
)
KEYCODE_ENTRY
(
VK_2
'
2
'
)
KEYCODE_ENTRY
(
VK_3
'
3
'
)
KEYCODE_ENTRY
(
VK_4
'
4
'
)
KEYCODE_ENTRY
(
VK_5
'
5
'
)
KEYCODE_ENTRY
(
VK_6
'
6
'
)
KEYCODE_ENTRY
(
VK_7
'
7
'
)
KEYCODE_ENTRY
(
VK_8
'
8
'
)
KEYCODE_ENTRY
(
VK_9
'
9
'
)
KEYCODE_ENTRY
(
VK_SEMICOLON
'
:
'
)
KEYCODE_ENTRY
(
VK_EQUALS
'
=
'
)
KEYCODE_ENTRY
(
VK_A
'
A
'
)
KEYCODE_ENTRY
(
VK_B
'
B
'
)
KEYCODE_ENTRY
(
VK_C
'
C
'
)
KEYCODE_ENTRY
(
VK_D
'
D
'
)
KEYCODE_ENTRY
(
VK_E
'
E
'
)
KEYCODE_ENTRY
(
VK_F
'
F
'
)
KEYCODE_ENTRY
(
VK_G
'
G
'
)
KEYCODE_ENTRY
(
VK_H
'
H
'
)
KEYCODE_ENTRY
(
VK_I
'
I
'
)
KEYCODE_ENTRY
(
VK_J
'
J
'
)
KEYCODE_ENTRY
(
VK_K
'
K
'
)
KEYCODE_ENTRY
(
VK_L
'
L
'
)
KEYCODE_ENTRY
(
VK_M
'
M
'
)
KEYCODE_ENTRY
(
VK_N
'
N
'
)
KEYCODE_ENTRY
(
VK_O
'
O
'
)
KEYCODE_ENTRY
(
VK_P
'
P
'
)
KEYCODE_ENTRY
(
VK_Q
'
Q
'
)
KEYCODE_ENTRY
(
VK_R
'
R
'
)
KEYCODE_ENTRY
(
VK_S
'
S
'
)
KEYCODE_ENTRY
(
VK_T
'
T
'
)
KEYCODE_ENTRY
(
VK_U
'
U
'
)
KEYCODE_ENTRY
(
VK_V
'
V
'
)
KEYCODE_ENTRY
(
VK_W
'
W
'
)
KEYCODE_ENTRY
(
VK_X
'
X
'
)
KEYCODE_ENTRY
(
VK_Y
'
Y
'
)
KEYCODE_ENTRY
(
VK_Z
'
Z
'
)
KEYCODE_ENTRY
(
VK_CONTEXT_MENU
NSMenuFunctionKey
)
KEYCODE_ENTRY
(
VK_NUMPAD0
'
0
'
)
KEYCODE_ENTRY
(
VK_NUMPAD1
'
1
'
)
KEYCODE_ENTRY
(
VK_NUMPAD2
'
2
'
)
KEYCODE_ENTRY
(
VK_NUMPAD3
'
3
'
)
KEYCODE_ENTRY
(
VK_NUMPAD4
'
4
'
)
KEYCODE_ENTRY
(
VK_NUMPAD5
'
5
'
)
KEYCODE_ENTRY
(
VK_NUMPAD6
'
6
'
)
KEYCODE_ENTRY
(
VK_NUMPAD7
'
7
'
)
KEYCODE_ENTRY
(
VK_NUMPAD8
'
8
'
)
KEYCODE_ENTRY
(
VK_NUMPAD9
'
9
'
)
KEYCODE_ENTRY
(
VK_MULTIPLY
'
*
'
)
KEYCODE_ENTRY
(
VK_ADD
'
+
'
)
KEYCODE_ENTRY
(
VK_SEPARATOR
0
)
KEYCODE_ENTRY
(
VK_SUBTRACT
'
-
'
)
KEYCODE_ENTRY
(
VK_DECIMAL
'
.
'
)
KEYCODE_ENTRY
(
VK_DIVIDE
'
/
'
)
KEYCODE_ENTRY
(
VK_F1
NSF1FunctionKey
)
KEYCODE_ENTRY
(
VK_F2
NSF2FunctionKey
)
KEYCODE_ENTRY
(
VK_F3
NSF3FunctionKey
)
KEYCODE_ENTRY
(
VK_F4
NSF4FunctionKey
)
KEYCODE_ENTRY
(
VK_F5
NSF5FunctionKey
)
KEYCODE_ENTRY
(
VK_F6
NSF6FunctionKey
)
KEYCODE_ENTRY
(
VK_F7
NSF7FunctionKey
)
KEYCODE_ENTRY
(
VK_F8
NSF8FunctionKey
)
KEYCODE_ENTRY
(
VK_F9
NSF9FunctionKey
)
KEYCODE_ENTRY
(
VK_F10
NSF10FunctionKey
)
KEYCODE_ENTRY
(
VK_F11
NSF11FunctionKey
)
KEYCODE_ENTRY
(
VK_F12
NSF12FunctionKey
)
KEYCODE_ENTRY
(
VK_F13
NSF13FunctionKey
)
KEYCODE_ENTRY
(
VK_F14
NSF14FunctionKey
)
KEYCODE_ENTRY
(
VK_F15
NSF15FunctionKey
)
KEYCODE_ENTRY
(
VK_F16
NSF16FunctionKey
)
KEYCODE_ENTRY
(
VK_F17
NSF17FunctionKey
)
KEYCODE_ENTRY
(
VK_F18
NSF18FunctionKey
)
KEYCODE_ENTRY
(
VK_F19
NSF19FunctionKey
)
KEYCODE_ENTRY
(
VK_F20
NSF20FunctionKey
)
KEYCODE_ENTRY
(
VK_F21
NSF21FunctionKey
)
KEYCODE_ENTRY
(
VK_F22
NSF22FunctionKey
)
KEYCODE_ENTRY
(
VK_F23
NSF23FunctionKey
)
KEYCODE_ENTRY
(
VK_F24
NSF24FunctionKey
)
KEYCODE_ENTRY
(
VK_NUM_LOCK
NSClearLineFunctionKey
)
KEYCODE_ENTRY
(
VK_SCROLL_LOCK
NSScrollLockFunctionKey
)
KEYCODE_ENTRY
(
VK_COMMA
'
'
)
KEYCODE_ENTRY
(
VK_PERIOD
'
.
'
)
KEYCODE_ENTRY
(
VK_SLASH
'
/
'
)
KEYCODE_ENTRY
(
VK_BACK_QUOTE
'
'
)
KEYCODE_ENTRY
(
VK_OPEN_BRACKET
'
[
'
)
KEYCODE_ENTRY
(
VK_BACK_SLASH
'
\
\
'
)
KEYCODE_ENTRY
(
VK_CLOSE_BRACKET
'
]
'
)
KEYCODE_ENTRY
(
VK_QUOTE
'
\
'
'
)
#
undef
KEYCODE_ENTRY
}
;
uint32_t
nsCocoaUtils
:
:
ConvertGeckoNameToMacCharCode
(
const
nsAString
&
aKeyCodeName
)
{
if
(
aKeyCodeName
.
IsEmpty
(
)
)
{
return
0
;
}
nsAutoCString
keyCodeName
;
LossyCopyUTF16toASCII
(
aKeyCodeName
keyCodeName
)
;
ToUpperCase
(
keyCodeName
)
;
uint32_t
keyCodeNameLength
=
keyCodeName
.
Length
(
)
;
const
char
*
keyCodeNameStr
=
keyCodeName
.
get
(
)
;
for
(
uint16_t
i
=
0
;
i
<
ArrayLength
(
gKeyConversions
)
;
+
+
i
)
{
if
(
keyCodeNameLength
=
=
gKeyConversions
[
i
]
.
strLength
&
&
nsCRT
:
:
strcmp
(
gKeyConversions
[
i
]
.
str
keyCodeNameStr
)
=
=
0
)
{
return
gKeyConversions
[
i
]
.
charCode
;
}
}
return
0
;
}
uint32_t
nsCocoaUtils
:
:
ConvertGeckoKeyCodeToMacCharCode
(
uint32_t
aKeyCode
)
{
if
(
!
aKeyCode
)
{
return
0
;
}
for
(
uint16_t
i
=
0
;
i
<
ArrayLength
(
gKeyConversions
)
;
+
+
i
)
{
if
(
gKeyConversions
[
i
]
.
geckoKeyCode
=
=
aKeyCode
)
{
return
gKeyConversions
[
i
]
.
charCode
;
}
}
return
0
;
}
NSEventModifierFlags
nsCocoaUtils
:
:
ConvertWidgetModifiersToMacModifierFlags
(
nsIWidget
:
:
Modifiers
aNativeModifiers
)
{
if
(
!
aNativeModifiers
)
{
return
0
;
}
struct
ModifierFlagMapEntry
{
nsIWidget
:
:
Modifiers
mWidgetModifier
;
NSEventModifierFlags
mModifierFlags
;
}
;
static
constexpr
ModifierFlagMapEntry
sModifierFlagMap
[
]
=
{
{
nsIWidget
:
:
CAPS_LOCK
NSEventModifierFlagCapsLock
}
{
nsIWidget
:
:
SHIFT_L
NSEventModifierFlagShift
|
0x0002
}
{
nsIWidget
:
:
SHIFT_R
NSEventModifierFlagShift
|
0x0004
}
{
nsIWidget
:
:
CTRL_L
NSEventModifierFlagControl
|
0x0001
}
{
nsIWidget
:
:
CTRL_R
NSEventModifierFlagControl
|
0x2000
}
{
nsIWidget
:
:
ALT_L
NSEventModifierFlagOption
|
0x0020
}
{
nsIWidget
:
:
ALT_R
NSEventModifierFlagOption
|
0x0040
}
{
nsIWidget
:
:
COMMAND_L
NSEventModifierFlagCommand
|
0x0008
}
{
nsIWidget
:
:
COMMAND_R
NSEventModifierFlagCommand
|
0x0010
}
{
nsIWidget
:
:
NUMERIC_KEY_PAD
NSEventModifierFlagNumericPad
}
{
nsIWidget
:
:
HELP
NSEventModifierFlagHelp
}
{
nsIWidget
:
:
FUNCTION
NSEventModifierFlagFunction
}
}
;
NSEventModifierFlags
modifierFlags
=
0
;
for
(
const
ModifierFlagMapEntry
&
entry
:
sModifierFlagMap
)
{
if
(
aNativeModifiers
&
entry
.
mWidgetModifier
)
{
modifierFlags
|
=
entry
.
mModifierFlags
;
}
}
return
modifierFlags
;
}
mozilla
:
:
MouseButton
nsCocoaUtils
:
:
ButtonForEvent
(
NSEvent
*
aEvent
)
{
switch
(
aEvent
.
type
)
{
case
NSEventTypeLeftMouseDown
:
case
NSEventTypeLeftMouseDragged
:
case
NSEventTypeLeftMouseUp
:
return
MouseButton
:
:
ePrimary
;
case
NSEventTypeRightMouseDown
:
case
NSEventTypeRightMouseDragged
:
case
NSEventTypeRightMouseUp
:
return
MouseButton
:
:
eSecondary
;
case
NSEventTypeOtherMouseDown
:
case
NSEventTypeOtherMouseDragged
:
case
NSEventTypeOtherMouseUp
:
switch
(
aEvent
.
buttonNumber
)
{
case
3
:
return
MouseButton
:
:
eX1
;
case
4
:
return
MouseButton
:
:
eX2
;
default
:
return
MouseButton
:
:
eMiddle
;
}
default
:
return
MouseButton
:
:
ePrimary
;
}
}
NSMutableAttributedString
*
nsCocoaUtils
:
:
GetNSMutableAttributedString
(
const
nsAString
&
aText
const
nsTArray
<
mozilla
:
:
FontRange
>
&
aFontRanges
const
bool
aIsVertical
const
CGFloat
aBackingScaleFactor
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
NSString
*
nsstr
=
nsCocoaUtils
:
:
ToNSString
(
aText
)
;
NSMutableAttributedString
*
attrStr
=
[
[
[
NSMutableAttributedString
alloc
]
initWithString
:
nsstr
attributes
:
nil
]
autorelease
]
;
int32_t
lastOffset
=
aText
.
Length
(
)
;
for
(
auto
i
=
aFontRanges
.
Length
(
)
;
i
>
0
;
-
-
i
)
{
const
FontRange
&
fontRange
=
aFontRanges
[
i
-
1
]
;
NSString
*
fontName
=
nsCocoaUtils
:
:
ToNSString
(
fontRange
.
mFontName
)
;
CGFloat
fontSize
=
fontRange
.
mFontSize
/
aBackingScaleFactor
;
NSFont
*
font
=
[
NSFont
fontWithName
:
fontName
size
:
fontSize
]
;
if
(
!
font
)
{
font
=
[
NSFont
systemFontOfSize
:
fontSize
]
;
}
NSDictionary
*
attrs
=
{
NSFontAttributeName
:
font
}
;
NSRange
range
=
NSMakeRange
(
fontRange
.
mStartOffset
lastOffset
-
fontRange
.
mStartOffset
)
;
[
attrStr
setAttributes
:
attrs
range
:
range
]
;
lastOffset
=
fontRange
.
mStartOffset
;
}
if
(
aIsVertical
)
{
[
attrStr
addAttribute
:
NSVerticalGlyphFormAttributeName
value
:
[
NSNumber
numberWithInt
:
1
]
range
:
NSMakeRange
(
0
[
attrStr
length
]
)
]
;
}
return
attrStr
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
}
TimeStamp
nsCocoaUtils
:
:
GetEventTimeStamp
(
NSTimeInterval
aEventTime
)
{
if
(
!
aEventTime
)
{
return
TimeStamp
:
:
Now
(
)
;
}
int64_t
tick
=
BaseTimeDurationPlatformUtils
:
:
TicksFromMilliseconds
(
aEventTime
*
1000
.
0
)
;
return
TimeStamp
:
:
FromSystemTime
(
tick
)
;
}
static
NSString
*
ActionOnDoubleClickSystemPref
(
)
{
NSUserDefaults
*
userDefaults
=
[
NSUserDefaults
standardUserDefaults
]
;
NSString
*
kAppleActionOnDoubleClickKey
=
"
AppleActionOnDoubleClick
"
;
id
value
=
[
userDefaults
objectForKey
:
kAppleActionOnDoubleClickKey
]
;
if
(
[
value
isKindOfClass
:
[
NSString
class
]
]
)
{
return
value
;
}
return
nil
;
}
interface
NSWindow
(
NSWindowShouldZoomOnDoubleClick
)
+
(
BOOL
)
_shouldZoomOnDoubleClick
;
end
bool
nsCocoaUtils
:
:
ShouldZoomOnTitlebarDoubleClick
(
)
{
if
(
[
NSWindow
respondsToSelector
:
selector
(
_shouldZoomOnDoubleClick
)
]
)
{
return
[
NSWindow
_shouldZoomOnDoubleClick
]
;
}
return
[
ActionOnDoubleClickSystemPref
(
)
isEqualToString
:
"
Maximize
"
]
;
}
bool
nsCocoaUtils
:
:
ShouldMinimizeOnTitlebarDoubleClick
(
)
{
return
[
ActionOnDoubleClickSystemPref
(
)
isEqualToString
:
"
Minimize
"
]
;
}
enum
GeckoAVAuthorizationStatus
:
NSInteger
{
GeckoAVAuthorizationStatusNotDetermined
=
0
GeckoAVAuthorizationStatusRestricted
=
1
GeckoAVAuthorizationStatusDenied
=
2
GeckoAVAuthorizationStatusAuthorized
=
3
}
;
#
if
!
defined
(
MAC_OS_X_VERSION_10_14
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_14
interface
AVCaptureDevice
(
GeckoAVAuthorizationStatus
)
+
(
GeckoAVAuthorizationStatus
)
authorizationStatusForMediaType
:
(
AVMediaType
)
mediaType
;
end
interface
AVCaptureDevice
(
WithCompletionHandler
)
+
(
void
)
requestAccessForMediaType
:
(
AVMediaType
)
mediaType
completionHandler
:
(
void
(
^
)
(
BOOL
granted
)
)
handler
;
end
#
endif
static
const
char
*
AVMediaTypeToString
(
AVMediaType
aType
)
{
if
(
aType
=
=
AVMediaTypeVideo
)
{
return
"
video
"
;
}
if
(
aType
=
=
AVMediaTypeAudio
)
{
return
"
audio
"
;
}
return
"
unexpected
type
"
;
}
static
void
LogAuthorizationStatus
(
AVMediaType
aType
int
aState
)
{
const
char
*
stateString
;
switch
(
aState
)
{
case
GeckoAVAuthorizationStatusAuthorized
:
stateString
=
"
AVAuthorizationStatusAuthorized
"
;
break
;
case
GeckoAVAuthorizationStatusDenied
:
stateString
=
"
AVAuthorizationStatusDenied
"
;
break
;
case
GeckoAVAuthorizationStatusNotDetermined
:
stateString
=
"
AVAuthorizationStatusNotDetermined
"
;
break
;
case
GeckoAVAuthorizationStatusRestricted
:
stateString
=
"
AVAuthorizationStatusRestricted
"
;
break
;
default
:
stateString
=
"
Invalid
state
"
;
}
LOG
(
"
%
s
authorization
status
:
%
s
\
n
"
AVMediaTypeToString
(
aType
)
stateString
)
;
}
static
nsresult
GetPermissionState
(
AVMediaType
aMediaType
uint16_t
&
aState
)
{
MOZ_ASSERT
(
aMediaType
=
=
AVMediaTypeVideo
|
|
aMediaType
=
=
AVMediaTypeAudio
)
;
if
(
available
(
macOS
10
.
14
*
)
)
{
GeckoAVAuthorizationStatus
authStatus
=
static_cast
<
GeckoAVAuthorizationStatus
>
(
[
AVCaptureDevice
authorizationStatusForMediaType
:
aMediaType
]
)
;
LogAuthorizationStatus
(
aMediaType
authStatus
)
;
switch
(
authStatus
)
{
case
GeckoAVAuthorizationStatusAuthorized
:
aState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_AUTHORIZED
;
return
NS_OK
;
case
GeckoAVAuthorizationStatusDenied
:
aState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_DENIED
;
return
NS_OK
;
case
GeckoAVAuthorizationStatusNotDetermined
:
aState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_NOTDETERMINED
;
return
NS_OK
;
case
GeckoAVAuthorizationStatusRestricted
:
aState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_RESTRICTED
;
return
NS_OK
;
default
:
MOZ_ASSERT
(
false
"
Invalid
authorization
status
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsCocoaUtils
:
:
GetVideoCapturePermissionState
(
uint16_t
&
aPermissionState
)
{
return
GetPermissionState
(
AVMediaTypeVideo
aPermissionState
)
;
}
nsresult
nsCocoaUtils
:
:
GetAudioCapturePermissionState
(
uint16_t
&
aPermissionState
)
{
return
GetPermissionState
(
AVMediaTypeAudio
aPermissionState
)
;
}
nsresult
nsCocoaUtils
:
:
GetScreenCapturePermissionState
(
uint16_t
&
aPermissionState
)
{
aPermissionState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_NOTDETERMINED
;
if
(
available
(
macOS
10
.
15
*
)
)
{
if
(
!
StaticPrefs
:
:
media_macos_screenrecording_oscheck_enabled
(
)
)
{
aPermissionState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_AUTHORIZED
;
LOG
(
"
screen
authorization
status
:
authorized
(
test
disabled
via
pref
)
"
)
;
return
NS_OK
;
}
AutoCFRelease
<
CFArrayRef
>
windowArray
=
CGWindowListCopyWindowInfo
(
kCGWindowListOptionAll
kCGNullWindowID
)
;
if
(
!
windowArray
)
{
LOG
(
"
GetScreenCapturePermissionState
(
)
ERROR
:
got
NULL
window
info
list
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
int32_t
windowLevelDock
=
CGWindowLevelForKey
(
kCGDockWindowLevelKey
)
;
int32_t
windowLevelNormal
=
CGWindowLevelForKey
(
kCGNormalWindowLevelKey
)
;
LOG
(
"
GetScreenCapturePermissionState
(
)
:
DockWindowLevel
:
%
d
"
"
NormalWindowLevel
:
%
d
"
windowLevelDock
windowLevelNormal
)
;
int32_t
thisPid
=
[
[
NSProcessInfo
processInfo
]
processIdentifier
]
;
CFIndex
windowCount
=
CFArrayGetCount
(
windowArray
)
;
LOG
(
"
GetScreenCapturePermissionState
(
)
returned
%
ld
windows
"
windowCount
)
;
if
(
windowCount
=
=
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
for
(
CFIndex
i
=
0
;
i
<
windowCount
;
i
+
+
)
{
CFDictionaryRef
windowDict
=
reinterpret_cast
<
CFDictionaryRef
>
(
CFArrayGetValueAtIndex
(
windowArray
i
)
)
;
int32_t
windowOwnerPid
=
-
1
;
CFNumberRef
windowPidRef
=
reinterpret_cast
<
CFNumberRef
>
(
CFDictionaryGetValue
(
windowDict
kCGWindowOwnerPID
)
)
;
if
(
!
windowPidRef
|
|
!
CFNumberGetValue
(
windowPidRef
kCFNumberIntType
&
windowOwnerPid
)
)
{
LOG
(
"
GetScreenCapturePermissionState
(
)
ERROR
:
failed
to
get
window
owner
"
)
;
continue
;
}
if
(
thisPid
=
=
windowOwnerPid
)
{
continue
;
}
CFStringRef
windowName
=
reinterpret_cast
<
CFStringRef
>
(
CFDictionaryGetValue
(
windowDict
kCGWindowName
)
)
;
if
(
!
windowName
)
{
continue
;
}
CFNumberRef
windowLayerRef
=
reinterpret_cast
<
CFNumberRef
>
(
CFDictionaryGetValue
(
windowDict
kCGWindowLayer
)
)
;
int32_t
windowLayer
;
if
(
!
windowLayerRef
|
|
!
CFNumberGetValue
(
windowLayerRef
kCFNumberIntType
&
windowLayer
)
)
{
LOG
(
"
GetScreenCapturePermissionState
(
)
ERROR
:
failed
to
get
layer
"
)
;
continue
;
}
LOG
(
"
GetScreenCapturePermissionState
(
)
:
windowLayer
:
%
d
"
windowLayer
)
;
if
(
windowLayer
=
=
windowLevelDock
|
|
windowLayer
=
=
windowLevelNormal
)
{
aPermissionState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_AUTHORIZED
;
LOG
(
"
screen
authorization
status
:
authorized
"
)
;
return
NS_OK
;
}
}
aPermissionState
=
nsIOSPermissionRequest
:
:
PERMISSION_STATE_DENIED
;
LOG
(
"
screen
authorization
status
:
not
authorized
"
)
;
return
NS_OK
;
}
LOG
(
"
GetScreenCapturePermissionState
(
)
:
nothing
to
do
not
on
10
.
15
+
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsresult
nsCocoaUtils
:
:
RequestVideoCapturePermission
(
RefPtr
<
Promise
>
&
aPromise
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsCocoaUtils
:
:
RequestCapturePermission
(
AVMediaTypeVideo
aPromise
sVideoCapturePromises
VideoCompletionHandler
)
;
}
nsresult
nsCocoaUtils
:
:
RequestAudioCapturePermission
(
RefPtr
<
Promise
>
&
aPromise
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsCocoaUtils
:
:
RequestCapturePermission
(
AVMediaTypeAudio
aPromise
sAudioCapturePromises
AudioCompletionHandler
)
;
}
nsresult
nsCocoaUtils
:
:
RequestCapturePermission
(
AVMediaType
aType
RefPtr
<
Promise
>
&
aPromise
PromiseArray
&
aPromiseList
void
(
^
aHandler
)
(
BOOL
granted
)
)
{
MOZ_ASSERT
(
aType
=
=
AVMediaTypeVideo
|
|
aType
=
=
AVMediaTypeAudio
)
;
#
if
defined
(
MAC_OS_X_VERSION_10_14
)
if
(
available
(
macOS
10
.
14
*
)
)
{
static_assert
(
(
int
)
GeckoAVAuthorizationStatusNotDetermined
=
=
(
int
)
AVAuthorizationStatusNotDetermined
"
GeckoAVAuthorizationStatusNotDetermined
does
not
match
"
)
;
static_assert
(
(
int
)
GeckoAVAuthorizationStatusRestricted
=
=
(
int
)
AVAuthorizationStatusRestricted
"
GeckoAVAuthorizationStatusRestricted
does
not
match
"
)
;
static_assert
(
(
int
)
GeckoAVAuthorizationStatusDenied
=
=
(
int
)
AVAuthorizationStatusDenied
"
GeckoAVAuthorizationStatusDenied
does
not
match
"
)
;
static_assert
(
(
int
)
GeckoAVAuthorizationStatusAuthorized
=
=
(
int
)
AVAuthorizationStatusAuthorized
"
GeckoAVAuthorizationStatusAuthorized
does
not
match
"
)
;
}
#
endif
LOG
(
"
RequestCapturePermission
(
%
s
)
"
AVMediaTypeToString
(
aType
)
)
;
if
(
available
(
macOS
10
.
14
*
)
)
{
sMediaCaptureMutex
.
Lock
(
)
;
if
(
aPromiseList
=
=
nullptr
)
{
aPromiseList
=
new
nsTArray
<
RefPtr
<
Promise
>
>
;
ClearOnShutdown
(
&
aPromiseList
)
;
}
aPromiseList
-
>
AppendElement
(
aPromise
)
;
size_t
nPromises
=
aPromiseList
-
>
Length
(
)
;
sMediaCaptureMutex
.
Unlock
(
)
;
LOG
(
"
RequestCapturePermission
(
%
s
)
:
%
ld
promise
(
s
)
unresolved
"
AVMediaTypeToString
(
aType
)
nPromises
)
;
if
(
nPromises
>
1
)
{
return
NS_OK
;
}
[
AVCaptureDevice
requestAccessForMediaType
:
aType
completionHandler
:
aHandler
]
;
return
NS_OK
;
}
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
(
^
nsCocoaUtils
:
:
AudioCompletionHandler
)
(
BOOL
)
=
^
void
(
BOOL
granted
)
{
nsCocoaUtils
:
:
ResolveAudioCapturePromises
(
granted
)
;
}
;
void
(
^
nsCocoaUtils
:
:
VideoCompletionHandler
)
(
BOOL
)
=
^
void
(
BOOL
granted
)
{
nsCocoaUtils
:
:
ResolveVideoCapturePromises
(
granted
)
;
}
;
void
nsCocoaUtils
:
:
ResolveMediaCapturePromises
(
bool
aGranted
PromiseArray
&
aPromiseList
)
{
StaticMutexAutoLock
lock
(
sMediaCaptureMutex
)
;
while
(
aPromiseList
-
>
Length
(
)
>
0
)
{
RefPtr
<
Promise
>
promise
=
aPromiseList
-
>
PopLastElement
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
ResolveMediaAccessPromise
"
[
aGranted
aPromise
=
std
:
:
move
(
promise
)
]
(
)
{
aPromise
-
>
MaybeResolve
(
aGranted
)
;
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
}
void
nsCocoaUtils
:
:
ResolveAudioCapturePromises
(
bool
aGranted
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
ResolveAudioCapturePromise
"
[
aGranted
]
(
)
{
ResolveMediaCapturePromises
(
aGranted
sAudioCapturePromises
)
;
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
nsresult
nsCocoaUtils
:
:
MaybeRequestScreenCapturePermission
(
)
{
LOG
(
"
MaybeRequestScreenCapturePermission
(
)
"
)
;
AutoCFRelease
<
CGImageRef
>
image
=
CGDisplayCreateImageForRect
(
kCGDirectMainDisplay
CGRectMake
(
0
0
1
1
)
)
;
return
NS_OK
;
}
void
nsCocoaUtils
:
:
ResolveVideoCapturePromises
(
bool
aGranted
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
NS_NewRunnableFunction
(
"
ResolveVideoCapturePromise
"
[
aGranted
]
(
)
{
ResolveMediaCapturePromises
(
aGranted
sVideoCapturePromises
)
;
}
)
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
