#
include
"
nsNativeThemeCocoa
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsNumberControlFrame
.
h
"
#
include
"
nsRangeFrame
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaWindow
.
h
"
#
include
"
nsNativeBasicTheme
.
h
"
#
include
"
nsNativeThemeColors
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
RelativeLuminanceUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMeterElement
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
VibrancyManager
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
gfxQuartzNativeDrawing
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
mozilla
:
:
dom
:
:
HTMLMeterElement
;
#
define
DRAW_IN_FRAME_DEBUG
0
#
define
SCROLLBARS_VISUAL_DEBUG
0
extern
"
C
"
{
CG_EXTERN
void
CGContextSetCTM
(
CGContextRef
CGAffineTransform
)
;
CG_EXTERN
void
CGContextSetBaseCTM
(
CGContextRef
CGAffineTransform
)
;
typedef
CFTypeRef
CUIRendererRef
;
void
CUIDraw
(
CUIRendererRef
r
CGRect
rect
CGContextRef
ctx
CFDictionaryRef
options
CFDictionaryRef
*
result
)
;
}
implementation
NSCell
(
ControlTintWorkaround
)
-
(
int
)
_realControlTint
{
return
[
self
controlTint
]
;
}
end
interface
CellDrawView
:
NSView
end
implementation
CellDrawView
-
(
BOOL
)
isFlipped
{
return
YES
;
}
-
(
NSText
*
)
currentEditor
{
return
nil
;
}
end
interface
RadioButtonCell
:
NSButtonCell
end
implementation
RadioButtonCell
end
interface
CheckboxCell
:
NSButtonCell
end
implementation
CheckboxCell
end
static
void
DrawFocusRingForCellIfNeeded
(
NSCell
*
aCell
NSRect
aWithFrame
NSView
*
aInView
)
{
if
(
[
aCell
showsFirstResponder
]
)
{
CGContextRef
cgContext
=
(
CGContextRef
)
[
[
NSGraphicsContext
currentContext
]
graphicsPort
]
;
CGContextSaveGState
(
cgContext
)
;
NSSetFocusRingStyle
(
NSFocusRingOnly
)
;
CGContextBeginTransparencyLayerWithRect
(
cgContext
NSRectToCGRect
(
aWithFrame
)
0
)
;
[
aCell
drawFocusRingMaskWithFrame
:
aWithFrame
inView
:
aInView
]
;
CGContextEndTransparencyLayer
(
cgContext
)
;
CGContextRestoreGState
(
cgContext
)
;
}
}
static
bool
FocusIsDrawnByDrawWithFrame
(
NSCell
*
aCell
)
{
#
if
defined
(
MAC_OS_X_VERSION_10_8
)
&
&
MAC_OS_X_VERSION_MAX_ALLOWED
>
=
MAC_OS_X_VERSION_10_8
return
false
;
#
else
if
(
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
return
true
;
}
return
[
aCell
isKindOfClass
:
[
RadioButtonCell
class
]
]
|
|
[
aCell
isKindOfClass
:
[
CheckboxCell
class
]
]
;
#
endif
}
static
void
DrawCellIncludingFocusRing
(
NSCell
*
aCell
NSRect
aWithFrame
NSView
*
aInView
)
{
[
aCell
drawWithFrame
:
aWithFrame
inView
:
aInView
]
;
if
(
!
FocusIsDrawnByDrawWithFrame
(
aCell
)
)
{
DrawFocusRingForCellIfNeeded
(
aCell
aWithFrame
aInView
)
;
}
}
interface
NSProgressBarCell
:
NSCell
{
double
mValue
;
double
mMax
;
bool
mIsIndeterminate
;
bool
mIsHorizontal
;
}
-
(
void
)
setValue
:
(
double
)
value
;
-
(
double
)
value
;
-
(
void
)
setMax
:
(
double
)
max
;
-
(
double
)
max
;
-
(
void
)
setIndeterminate
:
(
bool
)
aIndeterminate
;
-
(
bool
)
isIndeterminate
;
-
(
void
)
setHorizontal
:
(
bool
)
aIsHorizontal
;
-
(
bool
)
isHorizontal
;
-
(
void
)
drawWithFrame
:
(
NSRect
)
cellFrame
inView
:
(
NSView
*
)
controlView
;
end
implementation
NSProgressBarCell
-
(
void
)
setMax
:
(
double
)
aMax
{
mMax
=
aMax
;
}
-
(
double
)
max
{
return
mMax
;
}
-
(
void
)
setValue
:
(
double
)
aValue
{
mValue
=
aValue
;
}
-
(
double
)
value
{
return
mValue
;
}
-
(
void
)
setIndeterminate
:
(
bool
)
aIndeterminate
{
mIsIndeterminate
=
aIndeterminate
;
}
-
(
bool
)
isIndeterminate
{
return
mIsIndeterminate
;
}
-
(
void
)
setHorizontal
:
(
bool
)
aIsHorizontal
{
mIsHorizontal
=
aIsHorizontal
;
}
-
(
bool
)
isHorizontal
{
return
mIsHorizontal
;
}
-
(
void
)
drawWithFrame
:
(
NSRect
)
cellFrame
inView
:
(
NSView
*
)
controlView
{
CGContext
*
cgContext
=
(
CGContextRef
)
[
[
NSGraphicsContext
currentContext
]
graphicsPort
]
;
HIThemeTrackDrawInfo
tdi
;
tdi
.
version
=
0
;
tdi
.
min
=
0
;
tdi
.
value
=
INT32_MAX
*
(
mValue
/
mMax
)
;
tdi
.
max
=
INT32_MAX
;
tdi
.
bounds
=
NSRectToCGRect
(
cellFrame
)
;
tdi
.
attributes
=
mIsHorizontal
?
kThemeTrackHorizontal
:
0
;
tdi
.
enableState
=
[
self
controlTint
]
=
=
NSClearControlTint
?
kThemeTrackInactive
:
kThemeTrackActive
;
NSControlSize
size
=
[
self
controlSize
]
;
if
(
size
=
=
NSRegularControlSize
)
{
tdi
.
kind
=
mIsIndeterminate
?
kThemeLargeIndeterminateBar
:
kThemeLargeProgressBar
;
}
else
{
NS_ASSERTION
(
size
=
=
NSSmallControlSize
"
We
shouldn
'
t
have
another
size
than
small
and
regular
for
the
moment
"
)
;
tdi
.
kind
=
mIsIndeterminate
?
kThemeMediumIndeterminateBar
:
kThemeMediumProgressBar
;
}
int32_t
stepsPerSecond
=
mIsIndeterminate
?
60
:
30
;
int32_t
milliSecondsPerStep
=
1000
/
stepsPerSecond
;
tdi
.
trackInfo
.
progress
.
phase
=
uint8_t
(
PR_IntervalToMilliseconds
(
PR_IntervalNow
(
)
)
/
milliSecondsPerStep
)
;
HIThemeDrawTrack
(
&
tdi
NULL
cgContext
kHIThemeOrientationNormal
)
;
}
end
interface
SearchFieldCellWithFocusRing
:
NSSearchFieldCell
{
}
end
implementation
SearchFieldCellWithFocusRing
-
(
void
)
drawWithFrame
:
(
NSRect
)
rect
inView
:
(
NSView
*
)
controlView
{
[
super
drawWithFrame
:
rect
inView
:
controlView
]
;
if
(
FocusIsDrawnByDrawWithFrame
(
self
)
)
{
DrawFocusRingForCellIfNeeded
(
self
rect
controlView
)
;
}
}
-
(
void
)
drawFocusRingMaskWithFrame
:
(
NSRect
)
rect
inView
:
(
NSView
*
)
controlView
{
[
super
drawWithFrame
:
rect
inView
:
controlView
]
;
}
end
interface
ToolbarSearchFieldCellWithFocusRing
:
SearchFieldCellWithFocusRing
end
implementation
ToolbarSearchFieldCellWithFocusRing
-
(
BOOL
)
_isToolbarMode
{
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
return
NO
;
}
return
YES
;
}
end
#
define
HITHEME_ORIENTATION
kHIThemeOrientationNormal
static
CGFloat
kMaxFocusRingWidth
=
0
;
enum
{
leopardOSorlater
=
0
yosemiteOSorlater
=
1
}
;
enum
{
miniControlSize
smallControlSize
regularControlSize
}
;
enum
{
leftMargin
topMargin
rightMargin
bottomMargin
}
;
static
size_t
EnumSizeForCocoaSize
(
NSControlSize
cocoaControlSize
)
{
if
(
cocoaControlSize
=
=
NSMiniControlSize
)
return
miniControlSize
;
else
if
(
cocoaControlSize
=
=
NSSmallControlSize
)
return
smallControlSize
;
else
return
regularControlSize
;
}
static
NSControlSize
CocoaSizeForEnum
(
int32_t
enumControlSize
)
{
if
(
enumControlSize
=
=
miniControlSize
)
return
NSMiniControlSize
;
else
if
(
enumControlSize
=
=
smallControlSize
)
return
NSSmallControlSize
;
else
return
NSRegularControlSize
;
}
static
NSString
*
CUIControlSizeForCocoaSize
(
NSControlSize
aControlSize
)
{
if
(
aControlSize
=
=
NSRegularControlSize
)
return
"
regular
"
;
else
if
(
aControlSize
=
=
NSSmallControlSize
)
return
"
small
"
;
else
return
"
mini
"
;
}
static
void
InflateControlRect
(
NSRect
*
rect
NSControlSize
cocoaControlSize
const
float
marginSet
[
]
[
3
]
[
4
]
)
{
if
(
!
marginSet
)
return
;
static
int
osIndex
=
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
?
yosemiteOSorlater
:
leopardOSorlater
;
size_t
controlSize
=
EnumSizeForCocoaSize
(
cocoaControlSize
)
;
const
float
*
buttonMargins
=
marginSet
[
osIndex
]
[
controlSize
]
;
rect
-
>
origin
.
x
-
=
buttonMargins
[
leftMargin
]
;
rect
-
>
origin
.
y
-
=
buttonMargins
[
bottomMargin
]
;
rect
-
>
size
.
width
+
=
buttonMargins
[
leftMargin
]
+
buttonMargins
[
rightMargin
]
;
rect
-
>
size
.
height
+
=
buttonMargins
[
bottomMargin
]
+
buttonMargins
[
topMargin
]
;
}
static
NSWindow
*
NativeWindowForFrame
(
nsIFrame
*
aFrame
nsIWidget
*
*
aTopLevelWidget
=
NULL
)
{
if
(
!
aFrame
)
return
nil
;
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
)
;
if
(
!
widget
)
return
nil
;
nsIWidget
*
topLevelWidget
=
widget
-
>
GetTopLevelWidget
(
)
;
if
(
aTopLevelWidget
)
*
aTopLevelWidget
=
topLevelWidget
;
return
(
NSWindow
*
)
topLevelWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
}
static
NSSize
WindowButtonsSize
(
nsIFrame
*
aFrame
)
{
NSWindow
*
window
=
NativeWindowForFrame
(
aFrame
)
;
if
(
!
window
)
{
return
NSMakeSize
(
54
16
)
;
}
NSRect
buttonBox
=
NSZeroRect
;
NSButton
*
closeButton
=
[
window
standardWindowButton
:
NSWindowCloseButton
]
;
if
(
closeButton
)
{
buttonBox
=
NSUnionRect
(
buttonBox
[
closeButton
frame
]
)
;
}
NSButton
*
minimizeButton
=
[
window
standardWindowButton
:
NSWindowMiniaturizeButton
]
;
if
(
minimizeButton
)
{
buttonBox
=
NSUnionRect
(
buttonBox
[
minimizeButton
frame
]
)
;
}
NSButton
*
zoomButton
=
[
window
standardWindowButton
:
NSWindowZoomButton
]
;
if
(
zoomButton
)
{
buttonBox
=
NSUnionRect
(
buttonBox
[
zoomButton
frame
]
)
;
}
return
buttonBox
.
size
;
}
static
BOOL
FrameIsInActiveWindow
(
nsIFrame
*
aFrame
)
{
nsIWidget
*
topLevelWidget
=
NULL
;
NSWindow
*
win
=
NativeWindowForFrame
(
aFrame
&
topLevelWidget
)
;
if
(
!
topLevelWidget
|
|
!
win
)
return
YES
;
if
(
topLevelWidget
-
>
WindowType
(
)
=
=
eWindowType_popup
)
return
YES
;
if
(
[
win
isSheet
]
)
return
[
win
isKeyWindow
]
;
return
[
win
isMainWindow
]
&
&
!
[
win
attachedSheet
]
;
}
static
BOOL
IsActive
(
nsIFrame
*
aFrame
BOOL
aIsToolbarControl
)
{
if
(
aIsToolbarControl
)
return
[
NativeWindowForFrame
(
aFrame
)
isMainWindow
]
;
return
FrameIsInActiveWindow
(
aFrame
)
;
}
static
bool
IsInSourceList
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
frame
=
aFrame
-
>
GetParent
(
)
;
frame
;
frame
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
frame
)
)
{
if
(
frame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
=
=
StyleAppearance
:
:
MozMacSourceList
)
{
return
true
;
}
}
return
false
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsNativeThemeCocoa
nsNativeTheme
nsITheme
)
nsNativeThemeCocoa
:
:
nsNativeThemeCocoa
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
kMaxFocusRingWidth
=
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
?
7
:
4
;
nsAutoreleasePool
pool
;
mDisclosureButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mDisclosureButtonCell
setBezelStyle
:
NSRoundedDisclosureBezelStyle
]
;
[
mDisclosureButtonCell
setButtonType
:
NSPushOnPushOffButton
]
;
[
mDisclosureButtonCell
setHighlightsBy
:
NSPushInCellMask
]
;
mHelpButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mHelpButtonCell
setBezelStyle
:
NSHelpButtonBezelStyle
]
;
[
mHelpButtonCell
setButtonType
:
NSMomentaryPushInButton
]
;
[
mHelpButtonCell
setHighlightsBy
:
NSPushInCellMask
]
;
mPushButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mPushButtonCell
setButtonType
:
NSMomentaryPushInButton
]
;
[
mPushButtonCell
setHighlightsBy
:
NSPushInCellMask
]
;
mRadioButtonCell
=
[
[
RadioButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mRadioButtonCell
setButtonType
:
NSRadioButton
]
;
mCheckboxCell
=
[
[
CheckboxCell
alloc
]
initTextCell
:
"
"
]
;
[
mCheckboxCell
setButtonType
:
NSSwitchButton
]
;
[
mCheckboxCell
setAllowsMixedState
:
YES
]
;
mSearchFieldCell
=
[
[
SearchFieldCellWithFocusRing
alloc
]
initTextCell
:
"
"
]
;
[
mSearchFieldCell
setBezelStyle
:
NSTextFieldRoundedBezel
]
;
[
mSearchFieldCell
setBezeled
:
YES
]
;
[
mSearchFieldCell
setEditable
:
YES
]
;
[
mSearchFieldCell
setFocusRingType
:
NSFocusRingTypeExterior
]
;
mToolbarSearchFieldCell
=
[
[
ToolbarSearchFieldCellWithFocusRing
alloc
]
initTextCell
:
"
"
]
;
[
mToolbarSearchFieldCell
setBezelStyle
:
NSTextFieldRoundedBezel
]
;
[
mToolbarSearchFieldCell
setBezeled
:
YES
]
;
[
mToolbarSearchFieldCell
setEditable
:
YES
]
;
[
mToolbarSearchFieldCell
setFocusRingType
:
NSFocusRingTypeExterior
]
;
mDropdownCell
=
[
[
NSPopUpButtonCell
alloc
]
initTextCell
:
"
"
pullsDown
:
NO
]
;
mComboBoxCell
=
[
[
NSComboBoxCell
alloc
]
initTextCell
:
"
"
]
;
[
mComboBoxCell
setBezeled
:
YES
]
;
[
mComboBoxCell
setEditable
:
YES
]
;
[
mComboBoxCell
setFocusRingType
:
NSFocusRingTypeExterior
]
;
mProgressBarCell
=
[
[
NSProgressBarCell
alloc
]
init
]
;
mMeterBarCell
=
[
[
NSLevelIndicatorCell
alloc
]
initWithLevelIndicatorStyle
:
NSContinuousCapacityLevelIndicatorStyle
]
;
mCellDrawView
=
[
[
CellDrawView
alloc
]
init
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsNativeThemeCocoa
:
:
~
nsNativeThemeCocoa
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
mMeterBarCell
release
]
;
[
mProgressBarCell
release
]
;
[
mDisclosureButtonCell
release
]
;
[
mHelpButtonCell
release
]
;
[
mPushButtonCell
release
]
;
[
mRadioButtonCell
release
]
;
[
mCheckboxCell
release
]
;
[
mSearchFieldCell
release
]
;
[
mToolbarSearchFieldCell
release
]
;
[
mDropdownCell
release
]
;
[
mComboBoxCell
release
]
;
[
mCellDrawView
release
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
#
define
BITMAP_MAX_AREA
500000
static
int
GetBackingScaleFactorForRendering
(
CGContextRef
cgContext
)
{
CGAffineTransform
ctm
=
CGContextGetUserSpaceToDeviceSpaceTransform
(
cgContext
)
;
CGRect
transformedUserSpacePixel
=
CGRectApplyAffineTransform
(
CGRectMake
(
0
0
1
1
)
ctm
)
;
float
maxScale
=
std
:
:
max
(
fabs
(
transformedUserSpacePixel
.
size
.
width
)
fabs
(
transformedUserSpacePixel
.
size
.
height
)
)
;
return
maxScale
>
1
.
0
?
2
:
1
;
}
static
void
DrawCellWithScaling
(
NSCell
*
cell
CGContextRef
cgContext
const
HIRect
&
destRect
NSControlSize
controlSize
NSSize
naturalSize
NSSize
minimumSize
const
float
marginSet
[
]
[
3
]
[
4
]
NSView
*
view
BOOL
mirrorHorizontal
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSRect
drawRect
=
NSMakeRect
(
destRect
.
origin
.
x
destRect
.
origin
.
y
destRect
.
size
.
width
destRect
.
size
.
height
)
;
if
(
naturalSize
.
width
!
=
0
.
0f
)
drawRect
.
size
.
width
=
naturalSize
.
width
;
if
(
naturalSize
.
height
!
=
0
.
0f
)
drawRect
.
size
.
height
=
naturalSize
.
height
;
if
(
naturalSize
.
width
=
=
0
.
0f
&
&
naturalSize
.
height
!
=
0
.
0f
)
drawRect
.
size
.
width
=
destRect
.
size
.
width
*
naturalSize
.
height
/
destRect
.
size
.
height
;
if
(
naturalSize
.
height
=
=
0
.
0f
&
&
naturalSize
.
width
!
=
0
.
0f
)
drawRect
.
size
.
height
=
destRect
.
size
.
height
*
naturalSize
.
width
/
destRect
.
size
.
width
;
if
(
drawRect
.
size
.
width
<
minimumSize
.
width
)
drawRect
.
size
.
width
=
minimumSize
.
width
;
if
(
drawRect
.
size
.
height
<
minimumSize
.
height
)
drawRect
.
size
.
height
=
minimumSize
.
height
;
[
NSGraphicsContext
saveGraphicsState
]
;
if
(
drawRect
.
size
.
width
*
drawRect
.
size
.
height
>
BITMAP_MAX_AREA
)
{
InflateControlRect
(
&
drawRect
controlSize
marginSet
)
;
NSGraphicsContext
*
savedContext
=
[
NSGraphicsContext
currentContext
]
;
[
NSGraphicsContext
setCurrentContext
:
[
NSGraphicsContext
graphicsContextWithGraphicsPort
:
cgContext
flipped
:
YES
]
]
;
DrawCellIncludingFocusRing
(
cell
drawRect
view
)
;
[
NSGraphicsContext
setCurrentContext
:
savedContext
]
;
}
else
{
float
w
=
ceil
(
drawRect
.
size
.
width
)
;
float
h
=
ceil
(
drawRect
.
size
.
height
)
;
NSRect
tmpRect
=
NSMakeRect
(
kMaxFocusRingWidth
kMaxFocusRingWidth
w
h
)
;
InflateControlRect
(
&
tmpRect
controlSize
marginSet
)
;
w
+
=
kMaxFocusRingWidth
*
2
.
0
;
h
+
=
kMaxFocusRingWidth
*
2
.
0
;
int
backingScaleFactor
=
GetBackingScaleFactorForRendering
(
cgContext
)
;
CGColorSpaceRef
rgb
=
CGColorSpaceCreateDeviceRGB
(
)
;
CGContextRef
ctx
=
CGBitmapContextCreate
(
NULL
(
int
)
w
*
backingScaleFactor
(
int
)
h
*
backingScaleFactor
8
(
int
)
w
*
backingScaleFactor
*
4
rgb
kCGImageAlphaPremultipliedFirst
)
;
CGColorSpaceRelease
(
rgb
)
;
CGContextScaleCTM
(
cgContext
1
.
0f
-
1
.
0f
)
;
CGContextTranslateCTM
(
cgContext
0
.
0f
-
(
2
.
0
*
destRect
.
origin
.
y
+
destRect
.
size
.
height
)
)
;
if
(
mirrorHorizontal
)
{
CGContextScaleCTM
(
cgContext
-
1
.
0f
1
.
0f
)
;
CGContextTranslateCTM
(
cgContext
-
(
2
.
0
*
destRect
.
origin
.
x
+
destRect
.
size
.
width
)
0
.
0f
)
;
}
NSGraphicsContext
*
savedContext
=
[
NSGraphicsContext
currentContext
]
;
[
NSGraphicsContext
setCurrentContext
:
[
NSGraphicsContext
graphicsContextWithGraphicsPort
:
ctx
flipped
:
YES
]
]
;
CGContextScaleCTM
(
ctx
backingScaleFactor
backingScaleFactor
)
;
CGContextSetBaseCTM
(
ctx
CGAffineTransformMakeScale
(
backingScaleFactor
backingScaleFactor
)
)
;
CGContextScaleCTM
(
ctx
1
.
0f
-
1
.
0f
)
;
CGContextTranslateCTM
(
ctx
0
.
0f
-
(
2
.
0
*
tmpRect
.
origin
.
y
+
tmpRect
.
size
.
height
)
)
;
DrawCellIncludingFocusRing
(
cell
tmpRect
view
)
;
[
NSGraphicsContext
setCurrentContext
:
savedContext
]
;
CGImageRef
img
=
CGBitmapContextCreateImage
(
ctx
)
;
float
xscale
=
destRect
.
size
.
width
/
drawRect
.
size
.
width
;
float
yscale
=
destRect
.
size
.
height
/
drawRect
.
size
.
height
;
float
scaledFocusRingX
=
xscale
<
1
.
0f
?
kMaxFocusRingWidth
*
xscale
:
kMaxFocusRingWidth
;
float
scaledFocusRingY
=
yscale
<
1
.
0f
?
kMaxFocusRingWidth
*
yscale
:
kMaxFocusRingWidth
;
CGContextDrawImage
(
cgContext
CGRectMake
(
destRect
.
origin
.
x
-
scaledFocusRingX
destRect
.
origin
.
y
-
scaledFocusRingY
destRect
.
size
.
width
+
scaledFocusRingX
*
2
destRect
.
size
.
height
+
scaledFocusRingY
*
2
)
img
)
;
CGImageRelease
(
img
)
;
CGContextRelease
(
ctx
)
;
}
[
NSGraphicsContext
restoreGraphicsState
]
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
destRect
)
;
#
endif
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
struct
CellRenderSettings
{
NSSize
naturalSizes
[
3
]
;
NSSize
minimumSizes
[
3
]
;
float
margins
[
2
]
[
3
]
[
4
]
;
}
;
static
NSControlSize
FindControlSize
(
CGFloat
size
const
CGFloat
*
sizes
CGFloat
tolerance
)
{
for
(
uint32_t
i
=
miniControlSize
;
i
<
=
regularControlSize
;
+
+
i
)
{
if
(
sizes
[
i
]
=
=
0
)
{
continue
;
}
CGFloat
next
=
0
;
for
(
uint32_t
j
=
i
+
1
;
j
<
=
regularControlSize
;
+
+
j
)
{
if
(
sizes
[
j
]
!
=
0
)
{
next
=
sizes
[
j
]
;
break
;
}
}
if
(
next
=
=
0
)
{
return
CocoaSizeForEnum
(
i
)
;
}
if
(
size
<
=
sizes
[
i
]
+
tolerance
&
&
size
<
next
)
{
return
CocoaSizeForEnum
(
i
)
;
}
}
NS_ASSERTION
(
sizes
[
0
]
=
=
0
&
&
sizes
[
1
]
=
=
0
&
&
sizes
[
2
]
=
=
0
"
We
found
no
control
!
We
shouldn
'
t
be
there
!
"
)
;
return
CocoaSizeForEnum
(
regularControlSize
)
;
}
static
void
DrawCellWithSnapping
(
NSCell
*
cell
CGContextRef
cgContext
const
HIRect
&
destRect
const
CellRenderSettings
settings
float
verticalAlignFactor
NSView
*
view
BOOL
mirrorHorizontal
float
snapTolerance
=
2
.
0f
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
const
float
rectWidth
=
destRect
.
size
.
width
rectHeight
=
destRect
.
size
.
height
;
const
NSSize
*
sizes
=
settings
.
naturalSizes
;
const
NSSize
miniSize
=
sizes
[
EnumSizeForCocoaSize
(
NSMiniControlSize
)
]
;
const
NSSize
smallSize
=
sizes
[
EnumSizeForCocoaSize
(
NSSmallControlSize
)
]
;
const
NSSize
regularSize
=
sizes
[
EnumSizeForCocoaSize
(
NSRegularControlSize
)
]
;
HIRect
drawRect
=
destRect
;
CGFloat
controlWidths
[
3
]
=
{
miniSize
.
width
smallSize
.
width
regularSize
.
width
}
;
NSControlSize
controlSizeX
=
FindControlSize
(
rectWidth
controlWidths
snapTolerance
)
;
CGFloat
controlHeights
[
3
]
=
{
miniSize
.
height
smallSize
.
height
regularSize
.
height
}
;
NSControlSize
controlSizeY
=
FindControlSize
(
rectHeight
controlHeights
snapTolerance
)
;
NSControlSize
controlSize
=
NSRegularControlSize
;
size_t
sizeIndex
=
0
;
const
NSControlSize
smallerControlSize
=
EnumSizeForCocoaSize
(
controlSizeX
)
<
EnumSizeForCocoaSize
(
controlSizeY
)
?
controlSizeX
:
controlSizeY
;
const
size_t
smallerControlSizeIndex
=
EnumSizeForCocoaSize
(
smallerControlSize
)
;
const
NSSize
size
=
sizes
[
smallerControlSizeIndex
]
;
float
diffWidth
=
size
.
width
?
rectWidth
-
size
.
width
:
0
.
0f
;
float
diffHeight
=
size
.
height
?
rectHeight
-
size
.
height
:
0
.
0f
;
if
(
diffWidth
>
=
0
.
0f
&
&
diffHeight
>
=
0
.
0f
&
&
diffWidth
<
=
snapTolerance
&
&
diffHeight
<
=
snapTolerance
)
{
controlSize
=
smallerControlSize
;
sizeIndex
=
smallerControlSizeIndex
;
MOZ_ASSERT
(
sizeIndex
<
ArrayLength
(
settings
.
naturalSizes
)
)
;
if
(
sizes
[
sizeIndex
]
.
width
)
{
drawRect
.
origin
.
x
+
=
ceil
(
(
destRect
.
size
.
width
-
sizes
[
sizeIndex
]
.
width
)
/
2
)
;
drawRect
.
size
.
width
=
sizes
[
sizeIndex
]
.
width
;
}
if
(
sizes
[
sizeIndex
]
.
height
)
{
drawRect
.
origin
.
y
+
=
floor
(
(
destRect
.
size
.
height
-
sizes
[
sizeIndex
]
.
height
)
*
verticalAlignFactor
)
;
drawRect
.
size
.
height
=
sizes
[
sizeIndex
]
.
height
;
}
}
else
{
controlSize
=
EnumSizeForCocoaSize
(
controlSizeX
)
>
EnumSizeForCocoaSize
(
controlSizeY
)
?
controlSizeX
:
controlSizeY
;
sizeIndex
=
EnumSizeForCocoaSize
(
controlSize
)
;
}
[
cell
setControlSize
:
controlSize
]
;
MOZ_ASSERT
(
sizeIndex
<
ArrayLength
(
settings
.
minimumSizes
)
)
;
const
NSSize
minimumSize
=
settings
.
minimumSizes
[
sizeIndex
]
;
DrawCellWithScaling
(
cell
cgContext
drawRect
controlSize
sizes
[
sizeIndex
]
minimumSize
settings
.
margins
view
mirrorHorizontal
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
interface
NSWindow
(
CoreUIRendererPrivate
)
+
(
CUIRendererRef
)
coreUIRenderer
;
end
static
id
GetAquaAppearance
(
)
{
if
(
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
Class
NSAppearanceClass
=
NSClassFromString
(
"
NSAppearance
"
)
;
if
(
NSAppearanceClass
&
&
[
NSAppearanceClass
respondsToSelector
:
selector
(
appearanceNamed
:
)
]
)
{
return
[
NSAppearanceClass
performSelector
:
selector
(
appearanceNamed
:
)
withObject
:
"
NSAppearanceNameAqua
"
]
;
}
}
return
nil
;
}
interface
NSObject
(
NSAppearanceCoreUIRendering
)
-
(
void
)
_drawInRect
:
(
CGRect
)
rect
context
:
(
CGContextRef
)
cgContext
options
:
(
id
)
options
;
end
static
void
RenderWithCoreUI
(
CGRect
aRect
CGContextRef
cgContext
NSDictionary
*
aOptions
bool
aSkipAreaCheck
=
false
)
{
id
appearance
=
GetAquaAppearance
(
)
;
if
(
!
aSkipAreaCheck
&
&
aRect
.
size
.
width
*
aRect
.
size
.
height
>
BITMAP_MAX_AREA
)
{
return
;
}
if
(
appearance
&
&
[
appearance
respondsToSelector
:
selector
(
_drawInRect
:
context
:
options
:
)
]
)
{
[
appearance
_drawInRect
:
aRect
context
:
cgContext
options
:
aOptions
]
;
}
else
{
CUIRendererRef
renderer
=
[
NSWindow
respondsToSelector
:
selector
(
coreUIRenderer
)
]
?
[
NSWindow
coreUIRenderer
]
:
nil
;
CUIDraw
(
renderer
aRect
cgContext
(
CFDictionaryRef
)
aOptions
NULL
)
;
}
}
static
float
VerticalAlignFactor
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
return
0
.
5f
;
const
auto
&
va
=
aFrame
-
>
StyleDisplay
(
)
-
>
mVerticalAlign
;
auto
kw
=
va
.
IsKeyword
(
)
?
va
.
AsKeyword
(
)
:
StyleVerticalAlignKeyword
:
:
Middle
;
switch
(
kw
)
{
case
StyleVerticalAlignKeyword
:
:
Top
:
case
StyleVerticalAlignKeyword
:
:
TextTop
:
return
0
.
0f
;
case
StyleVerticalAlignKeyword
:
:
Sub
:
case
StyleVerticalAlignKeyword
:
:
Super
:
case
StyleVerticalAlignKeyword
:
:
Middle
:
case
StyleVerticalAlignKeyword
:
:
MozMiddleWithBaseline
:
return
0
.
5f
;
case
StyleVerticalAlignKeyword
:
:
Baseline
:
case
StyleVerticalAlignKeyword
:
:
Bottom
:
case
StyleVerticalAlignKeyword
:
:
TextBottom
:
return
1
.
0f
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
vertical
-
align
"
)
;
return
0
.
5f
;
}
}
static
void
ApplyControlParamsToNSCell
(
nsNativeThemeCocoa
:
:
ControlParams
aControlParams
NSCell
*
aCell
)
{
[
aCell
setEnabled
:
!
aControlParams
.
disabled
]
;
[
aCell
setShowsFirstResponder
:
(
aControlParams
.
focused
&
&
!
aControlParams
.
disabled
&
&
aControlParams
.
insideActiveWindow
)
]
;
[
aCell
setHighlighted
:
aControlParams
.
pressed
]
;
}
static
const
CellRenderSettings
radioSettings
=
{
{
NSMakeSize
(
11
11
)
NSMakeSize
(
13
13
)
NSMakeSize
(
16
16
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
0
0
0
0
}
{
0
1
1
1
}
{
0
0
0
0
}
}
{
{
0
0
0
0
}
{
1
1
1
2
}
{
0
0
0
0
}
}
}
}
;
static
const
CellRenderSettings
checkboxSettings
=
{
{
NSMakeSize
(
11
11
)
NSMakeSize
(
13
13
)
NSMakeSize
(
16
16
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
0
1
0
0
}
{
0
1
0
1
}
{
0
1
0
1
}
}
{
{
0
1
0
0
}
{
0
1
0
1
}
{
0
1
0
1
}
}
}
}
;
static
NSCellStateValue
CellStateForCheckboxOrRadioState
(
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
aState
)
{
switch
(
aState
)
{
case
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
:
:
eOff
:
return
NSOffState
;
case
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
:
:
eOn
:
return
NSOnState
;
case
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
:
:
eIndeterminate
:
return
NSMixedState
;
}
}
void
nsNativeThemeCocoa
:
:
DrawCheckboxOrRadio
(
CGContextRef
cgContext
bool
inCheckbox
const
HIRect
&
inBoxRect
const
CheckboxOrRadioParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSButtonCell
*
cell
=
inCheckbox
?
mCheckboxCell
:
mRadioButtonCell
;
ApplyControlParamsToNSCell
(
aParams
.
controlParams
cell
)
;
[
cell
setState
:
CellStateForCheckboxOrRadioState
(
aParams
.
state
)
]
;
[
cell
setControlTint
:
(
aParams
.
controlParams
.
insideActiveWindow
?
[
NSColor
currentControlTint
]
:
NSClearControlTint
)
]
;
float
length
=
std
:
:
min
(
inBoxRect
.
size
.
width
inBoxRect
.
size
.
height
)
;
HIRect
drawRect
=
CGRectMake
(
inBoxRect
.
origin
.
x
+
(
int
)
(
(
inBoxRect
.
size
.
width
-
length
)
/
2
.
0f
)
inBoxRect
.
origin
.
y
+
(
int
)
(
(
inBoxRect
.
size
.
height
-
length
)
/
2
.
0f
)
length
length
)
;
DrawCellWithSnapping
(
cell
cgContext
drawRect
inCheckbox
?
checkboxSettings
:
radioSettings
aParams
.
verticalAlignFactor
mCellDrawView
NO
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
const
CellRenderSettings
searchFieldSettings
=
{
{
NSMakeSize
(
0
16
)
NSMakeSize
(
0
19
)
NSMakeSize
(
0
22
)
}
{
NSMakeSize
(
32
0
)
NSMakeSize
(
38
0
)
NSMakeSize
(
44
0
)
}
{
{
{
0
0
0
0
}
{
0
0
0
0
}
{
0
0
0
0
}
}
{
{
0
0
0
0
}
{
0
0
0
0
}
{
0
0
0
0
}
}
}
}
;
static
bool
IsToolbarStyleContainer
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
false
;
}
if
(
content
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
toolbar
nsGkAtoms
:
:
toolbox
nsGkAtoms
:
:
statusbar
)
)
{
return
true
;
}
switch
(
aFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
)
{
case
StyleAppearance
:
:
Toolbar
:
case
StyleAppearance
:
:
Statusbar
:
return
true
;
default
:
return
false
;
}
}
static
bool
IsInsideToolbar
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
if
(
IsToolbarStyleContainer
(
frame
)
)
{
return
true
;
}
}
return
false
;
}
nsNativeThemeCocoa
:
:
SearchFieldParams
nsNativeThemeCocoa
:
:
ComputeSearchFieldParams
(
nsIFrame
*
aFrame
EventStates
aEventState
)
{
SearchFieldParams
params
;
params
.
insideToolbar
=
IsInsideToolbar
(
aFrame
)
;
params
.
disabled
=
IsDisabled
(
aFrame
aEventState
)
;
params
.
focused
=
IsFocused
(
aFrame
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawSearchField
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
SearchFieldParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSSearchFieldCell
*
cell
=
aParams
.
insideToolbar
?
mToolbarSearchFieldCell
:
mSearchFieldCell
;
[
cell
setEnabled
:
!
aParams
.
disabled
]
;
[
cell
setShowsFirstResponder
:
aParams
.
focused
]
;
[
cell
setPlaceholderString
:
"
"
]
;
DrawCellWithSnapping
(
cell
cgContext
inBoxRect
searchFieldSettings
aParams
.
verticalAlignFactor
mCellDrawView
aParams
.
rtl
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsNativeThemeCocoa
:
:
MenuBackgroundParams
nsNativeThemeCocoa
:
:
ComputeMenuBackgroundParams
(
nsIFrame
*
aFrame
EventStates
aEventState
)
{
MenuBackgroundParams
params
;
params
.
disabled
=
IsDisabled
(
aFrame
aEventState
)
;
bool
isLeftOfParent
=
false
;
params
.
submenuRightOfParent
=
IsSubmenu
(
aFrame
&
isLeftOfParent
)
&
&
!
isLeftOfParent
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawMenuBackground
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
const
MenuBackgroundParams
&
aParams
)
{
HIThemeMenuDrawInfo
mdi
;
memset
(
&
mdi
0
sizeof
(
mdi
)
)
;
mdi
.
version
=
0
;
mdi
.
menuType
=
aParams
.
disabled
?
static_cast
<
ThemeMenuType
>
(
kThemeMenuTypeInactive
)
:
static_cast
<
ThemeMenuType
>
(
kThemeMenuTypePopUp
)
;
if
(
aParams
.
submenuRightOfParent
)
{
mdi
.
menuType
=
kThemeMenuTypeHierarchical
;
}
CGRect
deflatedRect
=
CGRectMake
(
inBoxRect
.
origin
.
x
inBoxRect
.
origin
.
y
+
4
inBoxRect
.
size
.
width
inBoxRect
.
size
.
height
-
8
)
;
HIThemeDrawMenuBackground
(
&
deflatedRect
&
mdi
cgContext
HITHEME_ORIENTATION
)
;
}
static
const
NSSize
kCheckmarkSize
=
NSMakeSize
(
11
11
)
;
static
const
NSSize
kMenuarrowSize
=
NSMakeSize
(
9
10
)
;
static
const
NSSize
kMenuScrollArrowSize
=
NSMakeSize
(
10
8
)
;
static
NSString
*
kCheckmarkImage
=
"
MenuOnState
"
;
static
NSString
*
kMenuarrowRightImage
=
"
MenuSubmenu
"
;
static
NSString
*
kMenuarrowLeftImage
=
"
MenuSubmenuLeft
"
;
static
NSString
*
kMenuDownScrollArrowImage
=
"
MenuScrollDown
"
;
static
NSString
*
kMenuUpScrollArrowImage
=
"
MenuScrollUp
"
;
static
const
CGFloat
kMenuIconIndent
=
6
.
0f
;
NSString
*
nsNativeThemeCocoa
:
:
GetMenuIconName
(
const
MenuIconParams
&
aParams
)
{
switch
(
aParams
.
icon
)
{
case
MenuIcon
:
:
eCheckmark
:
return
kCheckmarkImage
;
case
MenuIcon
:
:
eMenuArrow
:
return
aParams
.
rtl
?
kMenuarrowLeftImage
:
kMenuarrowRightImage
;
case
MenuIcon
:
:
eMenuDownScrollArrow
:
return
kMenuDownScrollArrowImage
;
case
MenuIcon
:
:
eMenuUpScrollArrow
:
return
kMenuUpScrollArrowImage
;
}
}
NSSize
nsNativeThemeCocoa
:
:
GetMenuIconSize
(
MenuIcon
aIcon
)
{
switch
(
aIcon
)
{
case
MenuIcon
:
:
eCheckmark
:
return
kCheckmarkSize
;
case
MenuIcon
:
:
eMenuArrow
:
return
kMenuarrowSize
;
case
MenuIcon
:
:
eMenuDownScrollArrow
:
case
MenuIcon
:
:
eMenuUpScrollArrow
:
return
kMenuScrollArrowSize
;
}
}
nsNativeThemeCocoa
:
:
MenuIconParams
nsNativeThemeCocoa
:
:
ComputeMenuIconParams
(
nsIFrame
*
aFrame
EventStates
aEventState
MenuIcon
aIcon
)
{
bool
isDisabled
=
IsDisabled
(
aFrame
aEventState
)
;
MenuIconParams
params
;
params
.
icon
=
aIcon
;
params
.
disabled
=
isDisabled
;
params
.
insideActiveMenuItem
=
!
isDisabled
&
&
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
menuactive
)
;
params
.
centerHorizontally
=
true
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawMenuIcon
(
CGContextRef
cgContext
const
CGRect
&
aRect
const
MenuIconParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSSize
size
=
GetMenuIconSize
(
aParams
.
icon
)
;
CGFloat
paddingX
=
std
:
:
max
(
CGFloat
(
0
.
0
)
aRect
.
size
.
width
-
size
.
width
)
;
CGFloat
paddingY
=
std
:
:
max
(
CGFloat
(
0
.
0
)
aRect
.
size
.
height
-
size
.
height
)
;
CGFloat
paddingStartX
=
std
:
:
min
(
paddingX
kMenuIconIndent
)
;
CGFloat
paddingEndX
=
std
:
:
max
(
CGFloat
(
0
.
0
)
paddingX
-
kMenuIconIndent
)
;
CGRect
drawRect
=
CGRectMake
(
aRect
.
origin
.
x
+
(
aParams
.
centerHorizontally
?
ceil
(
paddingX
/
2
)
:
aParams
.
rtl
?
paddingEndX
:
paddingStartX
)
aRect
.
origin
.
y
+
ceil
(
paddingY
/
2
)
size
.
width
size
.
height
)
;
NSString
*
state
=
aParams
.
disabled
?
"
disabled
"
:
(
aParams
.
insideActiveMenuItem
?
"
pressed
"
:
"
normal
"
)
;
NSString
*
imageName
=
GetMenuIconName
(
aParams
)
;
if
(
!
nsCocoaFeatures
:
:
OnElCapitanOrLater
(
)
)
{
imageName
=
[
"
image
.
"
stringByAppendingString
:
imageName
]
;
}
RenderWithCoreUI
(
drawRect
cgContext
[
NSDictionary
dictionaryWithObjectsAndKeys
:
"
kCUIBackgroundTypeMenu
"
"
backgroundTypeKey
"
imageName
"
imageNameKey
"
state
"
state
"
"
image
"
"
widget
"
[
NSNumber
numberWithBool
:
YES
]
"
is
.
flipped
"
nil
]
)
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
drawRect
)
;
#
endif
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsNativeThemeCocoa
:
:
MenuItemParams
nsNativeThemeCocoa
:
:
ComputeMenuItemParams
(
nsIFrame
*
aFrame
EventStates
aEventState
bool
aIsChecked
)
{
bool
isDisabled
=
IsDisabled
(
aFrame
aEventState
)
;
MenuItemParams
params
;
params
.
backgroundIsVibrant
=
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
;
params
.
checked
=
aIsChecked
;
params
.
disabled
=
isDisabled
;
params
.
selected
=
!
isDisabled
&
&
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
menuactive
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
static
void
SetCGContextFillColor
(
CGContextRef
cgContext
const
sRGBColor
&
aColor
)
{
DeviceColor
color
=
ToDeviceColor
(
aColor
)
;
CGContextSetRGBFillColor
(
cgContext
color
.
r
color
.
g
color
.
b
color
.
a
)
;
}
static
void
SetCGContextFillColor
(
CGContextRef
cgContext
nscolor
aColor
)
{
DeviceColor
color
=
ToDeviceColor
(
aColor
)
;
CGContextSetRGBFillColor
(
cgContext
color
.
r
color
.
g
color
.
b
color
.
a
)
;
}
static
void
SetCGContextStrokeColor
(
CGContextRef
cgContext
nscolor
aColor
)
{
DeviceColor
color
=
ToDeviceColor
(
aColor
)
;
CGContextSetRGBStrokeColor
(
cgContext
color
.
r
color
.
g
color
.
b
color
.
a
)
;
}
void
nsNativeThemeCocoa
:
:
DrawMenuItem
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
const
MenuItemParams
&
aParams
)
{
if
(
!
aParams
.
backgroundIsVibrant
)
{
HIThemeMenuItemDrawInfo
drawInfo
;
memset
(
&
drawInfo
0
sizeof
(
drawInfo
)
)
;
drawInfo
.
version
=
0
;
drawInfo
.
itemType
=
kThemeMenuItemPlain
;
drawInfo
.
state
=
(
aParams
.
disabled
?
static_cast
<
ThemeMenuState
>
(
kThemeMenuDisabled
)
:
aParams
.
selected
?
static_cast
<
ThemeMenuState
>
(
kThemeMenuSelected
)
:
static_cast
<
ThemeMenuState
>
(
kThemeMenuActive
)
)
;
HIRect
ignored
;
HIThemeDrawMenuItem
(
&
inBoxRect
&
inBoxRect
&
drawInfo
cgContext
HITHEME_ORIENTATION
&
ignored
)
;
}
if
(
aParams
.
checked
)
{
MenuIconParams
params
;
params
.
disabled
=
aParams
.
disabled
;
params
.
insideActiveMenuItem
=
aParams
.
selected
;
params
.
rtl
=
aParams
.
rtl
;
params
.
icon
=
MenuIcon
:
:
eCheckmark
;
DrawMenuIcon
(
cgContext
inBoxRect
params
)
;
}
}
void
nsNativeThemeCocoa
:
:
DrawMenuSeparator
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
const
MenuItemParams
&
aParams
)
{
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
CGRect
separatorRect
=
inBoxRect
;
separatorRect
.
size
.
height
=
1
;
separatorRect
.
size
.
width
-
=
42
;
separatorRect
.
origin
.
x
+
=
21
;
DeviceColor
color
=
ToDeviceColor
(
mozilla
:
:
gfx
:
:
sRGBColor
:
:
FromU8
(
211
211
211
255
)
)
;
CGContextSetRGBFillColor
(
cgContext
color
.
r
color
.
g
color
.
b
color
.
a
)
;
CGContextFillRect
(
cgContext
separatorRect
)
;
return
;
}
ThemeMenuState
menuState
;
if
(
aParams
.
disabled
)
{
menuState
=
kThemeMenuDisabled
;
}
else
{
menuState
=
aParams
.
selected
?
kThemeMenuSelected
:
kThemeMenuActive
;
}
HIThemeMenuItemDrawInfo
midi
=
{
0
kThemeMenuItemPlain
menuState
}
;
HIThemeDrawMenuSeparator
(
&
inBoxRect
&
inBoxRect
&
midi
cgContext
HITHEME_ORIENTATION
)
;
}
static
bool
ShouldUnconditionallyDrawFocusRingIfFocused
(
nsIFrame
*
aFrame
)
{
switch
(
aFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
)
{
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Searchfield
:
case
StyleAppearance
:
:
Listbox
:
return
true
;
default
:
return
false
;
}
}
nsNativeThemeCocoa
:
:
ControlParams
nsNativeThemeCocoa
:
:
ComputeControlParams
(
nsIFrame
*
aFrame
EventStates
aEventState
)
{
ControlParams
params
;
params
.
disabled
=
IsDisabled
(
aFrame
aEventState
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
pressed
=
aEventState
.
HasAllStates
(
NS_EVENT_STATE_ACTIVE
|
NS_EVENT_STATE_HOVER
)
;
params
.
focused
=
aEventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
&
&
(
aEventState
.
HasState
(
NS_EVENT_STATE_FOCUSRING
)
|
|
ShouldUnconditionallyDrawFocusRingIfFocused
(
aFrame
)
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
static
const
NSSize
kHelpButtonSize
=
NSMakeSize
(
20
20
)
;
static
const
NSSize
kDisclosureButtonSize
=
NSMakeSize
(
21
21
)
;
static
const
CellRenderSettings
pushButtonSettings
=
{
{
NSMakeSize
(
0
16
)
NSMakeSize
(
0
19
)
NSMakeSize
(
0
22
)
}
{
NSMakeSize
(
18
0
)
NSMakeSize
(
26
0
)
NSMakeSize
(
30
0
)
}
{
{
{
0
0
0
0
}
{
4
0
4
1
}
{
5
0
5
2
}
}
{
{
0
0
0
0
}
{
4
0
4
1
}
{
5
0
5
2
}
}
}
}
;
#
define
DO_SQUARE_BUTTON_HEIGHT
26
void
nsNativeThemeCocoa
:
:
DrawRoundedBezelPushButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mPushButtonCell
)
;
[
mPushButtonCell
setBezelStyle
:
NSRoundedBezelStyle
]
;
DrawCellWithSnapping
(
mPushButtonCell
cgContext
inBoxRect
pushButtonSettings
0
.
5f
mCellDrawView
aControlParams
.
rtl
1
.
0f
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawSquareBezelPushButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mPushButtonCell
)
;
[
mPushButtonCell
setBezelStyle
:
NSShadowlessSquareBezelStyle
]
;
DrawCellWithScaling
(
mPushButtonCell
cgContext
inBoxRect
NSRegularControlSize
NSZeroSize
NSMakeSize
(
14
0
)
NULL
mCellDrawView
aControlParams
.
rtl
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawHelpButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mHelpButtonCell
)
;
DrawCellWithScaling
(
mHelpButtonCell
cgContext
inBoxRect
NSRegularControlSize
NSZeroSize
kHelpButtonSize
NULL
mCellDrawView
false
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawDisclosureButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
NSCellStateValue
aCellState
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mDisclosureButtonCell
)
;
[
mDisclosureButtonCell
setState
:
aCellState
]
;
DrawCellWithScaling
(
mDisclosureButtonCell
cgContext
inBoxRect
NSRegularControlSize
NSZeroSize
kDisclosureButtonSize
NULL
mCellDrawView
false
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawFocusOutline
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSGraphicsContext
*
savedContext
=
[
NSGraphicsContext
currentContext
]
;
[
NSGraphicsContext
setCurrentContext
:
[
NSGraphicsContext
graphicsContextWithGraphicsPort
:
cgContext
flipped
:
YES
]
]
;
CGContextSaveGState
(
cgContext
)
;
NSSetFocusRingStyle
(
NSFocusRingOnly
)
;
NSRectFill
(
NSRectFromCGRect
(
inBoxRect
)
)
;
CGContextRestoreGState
(
cgContext
)
;
[
NSGraphicsContext
setCurrentContext
:
savedContext
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
typedef
void
(
*
RenderHIThemeControlFunction
)
(
CGContextRef
cgContext
const
HIRect
&
aRenderRect
void
*
aData
)
;
static
void
RenderTransformedHIThemeControl
(
CGContextRef
aCGContext
const
HIRect
&
aRect
RenderHIThemeControlFunction
aFunc
void
*
aData
BOOL
mirrorHorizontally
=
NO
)
{
CGAffineTransform
savedCTM
=
CGContextGetCTM
(
aCGContext
)
;
CGContextTranslateCTM
(
aCGContext
aRect
.
origin
.
x
aRect
.
origin
.
y
)
;
bool
drawDirect
;
HIRect
drawRect
=
aRect
;
drawRect
.
origin
=
CGPointZero
;
if
(
!
mirrorHorizontally
&
&
savedCTM
.
a
=
=
1
.
0f
&
&
savedCTM
.
b
=
=
0
.
0f
&
&
savedCTM
.
c
=
=
0
.
0f
&
&
(
savedCTM
.
d
=
=
1
.
0f
|
|
savedCTM
.
d
=
=
-
1
.
0f
)
)
{
drawDirect
=
TRUE
;
}
else
{
drawDirect
=
FALSE
;
}
if
(
drawDirect
|
|
(
aRect
.
size
.
width
*
aRect
.
size
.
height
>
BITMAP_MAX_AREA
)
)
{
aFunc
(
aCGContext
drawRect
aData
)
;
}
else
{
int
w
=
ceil
(
drawRect
.
size
.
width
)
+
2
*
kMaxFocusRingWidth
;
int
h
=
ceil
(
drawRect
.
size
.
height
)
+
2
*
kMaxFocusRingWidth
;
int
backingScaleFactor
=
GetBackingScaleFactorForRendering
(
aCGContext
)
;
CGColorSpaceRef
colorSpace
=
CGColorSpaceCreateDeviceRGB
(
)
;
CGContextRef
bitmapctx
=
CGBitmapContextCreate
(
NULL
w
*
backingScaleFactor
h
*
backingScaleFactor
8
w
*
backingScaleFactor
*
4
colorSpace
kCGImageAlphaPremultipliedFirst
)
;
CGColorSpaceRelease
(
colorSpace
)
;
CGContextScaleCTM
(
bitmapctx
backingScaleFactor
backingScaleFactor
)
;
CGContextTranslateCTM
(
bitmapctx
kMaxFocusRingWidth
kMaxFocusRingWidth
)
;
CGContextSetBaseCTM
(
bitmapctx
CGAffineTransformMakeScale
(
backingScaleFactor
backingScaleFactor
)
)
;
CGContextTranslateCTM
(
bitmapctx
0
.
0f
aRect
.
size
.
height
)
;
CGContextScaleCTM
(
bitmapctx
1
.
0f
-
1
.
0f
)
;
aFunc
(
bitmapctx
drawRect
aData
)
;
CGImageRef
bitmap
=
CGBitmapContextCreateImage
(
bitmapctx
)
;
CGAffineTransform
ctm
=
CGContextGetCTM
(
aCGContext
)
;
CGContextTranslateCTM
(
aCGContext
0
.
0f
aRect
.
size
.
height
)
;
CGContextScaleCTM
(
aCGContext
1
.
0f
-
1
.
0f
)
;
if
(
mirrorHorizontally
)
{
CGContextTranslateCTM
(
aCGContext
aRect
.
size
.
width
0
)
;
CGContextScaleCTM
(
aCGContext
-
1
.
0f
1
.
0f
)
;
}
HIRect
inflatedDrawRect
=
CGRectMake
(
-
kMaxFocusRingWidth
-
kMaxFocusRingWidth
w
h
)
;
CGContextDrawImage
(
aCGContext
inflatedDrawRect
bitmap
)
;
CGContextSetCTM
(
aCGContext
ctm
)
;
CGImageRelease
(
bitmap
)
;
CGContextRelease
(
bitmapctx
)
;
}
CGContextSetCTM
(
aCGContext
savedCTM
)
;
}
static
void
RenderButton
(
CGContextRef
cgContext
const
HIRect
&
aRenderRect
void
*
aData
)
{
HIThemeButtonDrawInfo
*
bdi
=
(
HIThemeButtonDrawInfo
*
)
aData
;
HIThemeDrawButton
(
&
aRenderRect
bdi
cgContext
kHIThemeOrientationNormal
NULL
)
;
}
static
ThemeDrawState
ToThemeDrawState
(
const
nsNativeThemeCocoa
:
:
ControlParams
&
aParams
)
{
if
(
aParams
.
disabled
)
{
return
kThemeStateUnavailable
;
}
if
(
aParams
.
pressed
)
{
return
kThemeStatePressed
;
}
return
kThemeStateActive
;
}
void
nsNativeThemeCocoa
:
:
DrawHIThemeButton
(
CGContextRef
cgContext
const
HIRect
&
aRect
ThemeButtonKind
aKind
ThemeButtonValue
aValue
ThemeDrawState
aState
ThemeButtonAdornment
aAdornment
const
ControlParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeButtonDrawInfo
bdi
;
bdi
.
version
=
0
;
bdi
.
kind
=
aKind
;
bdi
.
value
=
aValue
;
bdi
.
state
=
aState
;
bdi
.
adornment
=
aAdornment
;
if
(
aParams
.
focused
&
&
aParams
.
insideActiveWindow
)
{
bdi
.
adornment
|
=
kThemeAdornmentFocus
;
}
if
(
(
aAdornment
&
kThemeAdornmentDefault
)
&
&
!
aParams
.
disabled
)
{
bdi
.
animation
.
time
.
start
=
0
;
bdi
.
animation
.
time
.
current
=
CFAbsoluteTimeGetCurrent
(
)
;
}
RenderTransformedHIThemeControl
(
cgContext
aRect
RenderButton
&
bdi
aParams
.
rtl
)
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
#
endif
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
ButtonParams
&
aParams
)
{
ControlParams
controlParams
=
aParams
.
controlParams
;
switch
(
aParams
.
button
)
{
case
ButtonType
:
:
eRegularPushButton
:
case
ButtonType
:
:
eDefaultPushButton
:
{
ThemeButtonAdornment
adornment
=
aParams
.
button
=
=
ButtonType
:
:
eDefaultPushButton
?
kThemeAdornmentDefault
:
kThemeAdornmentNone
;
HIRect
drawFrame
=
inBoxRect
;
drawFrame
.
size
.
height
-
=
2
;
if
(
inBoxRect
.
size
.
height
>
=
pushButtonSettings
.
naturalSizes
[
regularControlSize
]
.
height
)
{
DrawHIThemeButton
(
cgContext
drawFrame
kThemePushButton
kThemeButtonOff
ToThemeDrawState
(
controlParams
)
adornment
controlParams
)
;
return
;
}
if
(
inBoxRect
.
size
.
height
>
=
pushButtonSettings
.
naturalSizes
[
smallControlSize
]
.
height
)
{
drawFrame
.
origin
.
y
-
=
1
;
drawFrame
.
origin
.
x
+
=
1
;
drawFrame
.
size
.
width
-
=
2
;
DrawHIThemeButton
(
cgContext
drawFrame
kThemePushButtonSmall
kThemeButtonOff
ToThemeDrawState
(
controlParams
)
adornment
controlParams
)
;
return
;
}
DrawHIThemeButton
(
cgContext
drawFrame
kThemePushButtonMini
kThemeButtonOff
ToThemeDrawState
(
controlParams
)
adornment
controlParams
)
;
return
;
}
case
ButtonType
:
:
eRegularBevelButton
:
case
ButtonType
:
:
eDefaultBevelButton
:
{
ThemeButtonAdornment
adornment
=
aParams
.
button
=
=
ButtonType
:
:
eDefaultBevelButton
?
kThemeAdornmentDefault
:
kThemeAdornmentNone
;
DrawHIThemeButton
(
cgContext
inBoxRect
kThemeMediumBevelButton
kThemeButtonOff
ToThemeDrawState
(
controlParams
)
adornment
controlParams
)
;
return
;
}
case
ButtonType
:
:
eRoundedBezelPushButton
:
DrawRoundedBezelPushButton
(
cgContext
inBoxRect
controlParams
)
;
return
;
case
ButtonType
:
:
eSquareBezelPushButton
:
DrawSquareBezelPushButton
(
cgContext
inBoxRect
controlParams
)
;
return
;
case
ButtonType
:
:
eArrowButton
:
DrawHIThemeButton
(
cgContext
inBoxRect
kThemeArrowButton
kThemeButtonOn
kThemeStateUnavailable
kThemeAdornmentArrowDownArrow
controlParams
)
;
return
;
case
ButtonType
:
:
eHelpButton
:
DrawHelpButton
(
cgContext
inBoxRect
controlParams
)
;
return
;
case
ButtonType
:
:
eTreeTwistyPointingRight
:
DrawHIThemeButton
(
cgContext
inBoxRect
kThemeDisclosureButton
kThemeDisclosureRight
ToThemeDrawState
(
controlParams
)
kThemeAdornmentNone
controlParams
)
;
return
;
case
ButtonType
:
:
eTreeTwistyPointingDown
:
DrawHIThemeButton
(
cgContext
inBoxRect
kThemeDisclosureButton
kThemeDisclosureDown
ToThemeDrawState
(
controlParams
)
kThemeAdornmentNone
controlParams
)
;
return
;
case
ButtonType
:
:
eDisclosureButtonClosed
:
DrawDisclosureButton
(
cgContext
inBoxRect
controlParams
NSOffState
)
;
return
;
case
ButtonType
:
:
eDisclosureButtonOpen
:
DrawDisclosureButton
(
cgContext
inBoxRect
controlParams
NSOnState
)
;
return
;
}
}
nsNativeThemeCocoa
:
:
TreeHeaderCellParams
nsNativeThemeCocoa
:
:
ComputeTreeHeaderCellParams
(
nsIFrame
*
aFrame
EventStates
aEventState
)
{
TreeHeaderCellParams
params
;
params
.
controlParams
=
ComputeControlParams
(
aFrame
aEventState
)
;
params
.
sortDirection
=
GetTreeSortDirection
(
aFrame
)
;
params
.
lastTreeHeaderCell
=
IsLastTreeHeaderCell
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawTreeHeaderCell
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
TreeHeaderCellParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeButtonDrawInfo
bdi
;
bdi
.
version
=
0
;
bdi
.
kind
=
kThemeListHeaderButton
;
bdi
.
value
=
kThemeButtonOff
;
bdi
.
adornment
=
kThemeAdornmentNone
;
switch
(
aParams
.
sortDirection
)
{
case
eTreeSortDirection_Natural
:
break
;
case
eTreeSortDirection_Ascending
:
bdi
.
value
=
kThemeButtonOn
;
bdi
.
adornment
=
kThemeAdornmentHeaderButtonSortUp
;
break
;
case
eTreeSortDirection_Descending
:
bdi
.
value
=
kThemeButtonOn
;
break
;
}
if
(
aParams
.
controlParams
.
disabled
)
{
bdi
.
state
=
kThemeStateUnavailable
;
}
else
if
(
aParams
.
controlParams
.
pressed
)
{
bdi
.
state
=
kThemeStatePressed
;
}
else
if
(
!
aParams
.
controlParams
.
insideActiveWindow
)
{
bdi
.
state
=
kThemeStateInactive
;
}
else
{
bdi
.
state
=
kThemeStateActive
;
}
CGContextClipToRect
(
cgContext
inBoxRect
)
;
HIRect
drawFrame
=
inBoxRect
;
drawFrame
.
origin
.
y
-
=
1
;
drawFrame
.
size
.
height
+
=
1
;
drawFrame
.
size
.
width
+
=
1
;
if
(
aParams
.
lastTreeHeaderCell
)
{
drawFrame
.
size
.
width
+
=
1
;
}
if
(
!
aParams
.
controlParams
.
rtl
|
|
aParams
.
lastTreeHeaderCell
)
{
drawFrame
.
origin
.
x
-
=
1
;
}
RenderTransformedHIThemeControl
(
cgContext
drawFrame
RenderButton
&
bdi
aParams
.
controlParams
.
rtl
)
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
#
endif
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
const
CellRenderSettings
dropdownSettings
=
{
{
NSMakeSize
(
0
16
)
NSMakeSize
(
0
19
)
NSMakeSize
(
0
22
)
}
{
NSMakeSize
(
18
0
)
NSMakeSize
(
38
0
)
NSMakeSize
(
44
0
)
}
{
{
{
1
1
2
1
}
{
3
0
3
1
}
{
3
0
3
0
}
}
{
{
1
1
2
1
}
{
3
0
3
1
}
{
3
0
3
0
}
}
}
}
;
static
const
CellRenderSettings
editableMenulistSettings
=
{
{
NSMakeSize
(
0
15
)
NSMakeSize
(
0
18
)
NSMakeSize
(
0
21
)
}
{
NSMakeSize
(
18
0
)
NSMakeSize
(
38
0
)
NSMakeSize
(
44
0
)
}
{
{
{
0
0
2
2
}
{
0
0
3
2
}
{
0
1
3
3
}
}
{
{
0
0
2
2
}
{
0
0
3
2
}
{
0
1
3
3
}
}
}
}
;
void
nsNativeThemeCocoa
:
:
DrawDropdown
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
DropdownParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
mDropdownCell
setPullsDown
:
aParams
.
pullsDown
]
;
NSCell
*
cell
=
aParams
.
editable
?
(
NSCell
*
)
mComboBoxCell
:
(
NSCell
*
)
mDropdownCell
;
ApplyControlParamsToNSCell
(
aParams
.
controlParams
cell
)
;
if
(
aParams
.
controlParams
.
insideActiveWindow
)
{
[
cell
setControlTint
:
[
NSColor
currentControlTint
]
]
;
}
else
{
[
cell
setControlTint
:
NSClearControlTint
]
;
}
const
CellRenderSettings
&
settings
=
aParams
.
editable
?
editableMenulistSettings
:
dropdownSettings
;
DrawCellWithSnapping
(
cell
cgContext
inBoxRect
settings
0
.
5f
mCellDrawView
aParams
.
controlParams
.
rtl
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
const
CellRenderSettings
spinnerSettings
=
{
{
NSMakeSize
(
11
16
)
NSMakeSize
(
15
22
)
NSMakeSize
(
19
27
)
}
{
NSMakeSize
(
11
16
)
NSMakeSize
(
15
22
)
NSMakeSize
(
19
27
)
}
{
{
{
0
0
0
0
}
{
0
0
0
0
}
{
0
0
0
0
}
}
{
{
0
0
0
0
}
{
0
0
0
0
}
{
0
0
0
0
}
}
}
}
;
HIThemeButtonDrawInfo
nsNativeThemeCocoa
:
:
SpinButtonDrawInfo
(
ThemeButtonKind
aKind
const
SpinButtonParams
&
aParams
)
{
HIThemeButtonDrawInfo
bdi
;
bdi
.
version
=
0
;
bdi
.
kind
=
aKind
;
bdi
.
value
=
kThemeButtonOff
;
bdi
.
adornment
=
kThemeAdornmentNone
;
if
(
aParams
.
disabled
)
{
bdi
.
state
=
kThemeStateUnavailable
;
}
else
if
(
aParams
.
insideActiveWindow
&
&
aParams
.
pressedButton
)
{
if
(
*
aParams
.
pressedButton
=
=
SpinButton
:
:
eUp
)
{
bdi
.
state
=
kThemeStatePressedUp
;
}
else
{
bdi
.
state
=
kThemeStatePressedDown
;
}
}
else
{
bdi
.
state
=
kThemeStateActive
;
}
return
bdi
;
}
void
nsNativeThemeCocoa
:
:
DrawSpinButtons
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
SpinButtonParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeButtonDrawInfo
bdi
=
SpinButtonDrawInfo
(
kThemeIncDecButton
aParams
)
;
HIThemeDrawButton
(
&
inBoxRect
&
bdi
cgContext
HITHEME_ORIENTATION
NULL
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawSpinButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
SpinButton
aDrawnButton
const
SpinButtonParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeButtonDrawInfo
bdi
=
SpinButtonDrawInfo
(
kThemeIncDecButtonMini
aParams
)
;
HIRect
drawRect
=
inBoxRect
;
drawRect
.
size
.
height
*
=
2
;
if
(
aDrawnButton
=
=
SpinButton
:
:
eDown
)
{
drawRect
.
origin
.
y
-
=
inBoxRect
.
size
.
height
;
}
drawRect
.
origin
.
x
-
=
1
;
CGContextSaveGState
(
cgContext
)
;
CGContextClipToRect
(
cgContext
inBoxRect
)
;
HIThemeDrawButton
(
&
drawRect
&
bdi
cgContext
HITHEME_ORIENTATION
NULL
)
;
CGContextRestoreGState
(
cgContext
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawTextBox
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
TextBoxParams
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
SetCGContextFillColor
(
cgContext
sRGBColor
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
#
endif
if
(
aParams
.
borderless
)
{
return
;
}
HIThemeFrameDrawInfo
fdi
;
fdi
.
version
=
0
;
fdi
.
kind
=
kHIThemeFrameTextFieldSquare
;
fdi
.
state
=
aParams
.
disabled
?
kThemeStateUnavailable
:
kThemeStateActive
;
fdi
.
isFocused
=
aParams
.
focused
;
HIRect
drawRect
=
inBoxRect
;
SInt32
frameOutset
=
0
;
:
:
GetThemeMetric
(
kThemeMetricEditTextFrameOutset
&
frameOutset
)
;
drawRect
.
origin
.
x
+
=
frameOutset
;
drawRect
.
origin
.
y
+
=
frameOutset
;
drawRect
.
size
.
width
-
=
frameOutset
*
2
;
drawRect
.
size
.
height
-
=
frameOutset
*
2
;
HIThemeDrawFrame
(
&
drawRect
&
fdi
cgContext
HITHEME_ORIENTATION
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
const
CellRenderSettings
progressSettings
[
2
]
[
2
]
=
{
{
{
{
NSZeroSize
NSMakeSize
(
10
0
)
NSMakeSize
(
16
0
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
0
0
0
0
}
{
1
1
1
1
}
{
1
1
1
1
}
}
}
}
{
{
NSZeroSize
NSMakeSize
(
10
0
)
NSMakeSize
(
16
0
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
0
0
0
0
}
{
1
1
1
1
}
{
1
0
1
0
}
}
{
{
0
0
0
0
}
{
1
1
1
1
}
{
1
0
1
0
}
}
}
}
}
{
{
{
NSZeroSize
NSMakeSize
(
0
10
)
NSMakeSize
(
0
16
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
0
0
0
0
}
{
1
1
1
1
}
{
1
1
1
1
}
}
{
{
0
0
0
0
}
{
1
1
1
1
}
{
1
1
1
1
}
}
}
}
{
{
NSZeroSize
NSMakeSize
(
0
10
)
NSMakeSize
(
0
16
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
0
0
0
0
}
{
1
1
1
1
}
{
0
1
0
1
}
}
{
{
0
0
0
0
}
{
1
1
1
1
}
{
0
1
0
1
}
}
}
}
}
}
;
nsNativeThemeCocoa
:
:
ProgressParams
nsNativeThemeCocoa
:
:
ComputeProgressParams
(
nsIFrame
*
aFrame
EventStates
aEventState
bool
aIsHorizontal
)
{
ProgressParams
params
;
params
.
value
=
GetProgressValue
(
aFrame
)
;
params
.
max
=
GetProgressMaxValue
(
aFrame
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
indeterminate
=
IsIndeterminateProgress
(
aFrame
aEventState
)
;
params
.
horizontal
=
aIsHorizontal
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawProgress
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
ProgressParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSProgressBarCell
*
cell
=
mProgressBarCell
;
[
cell
setValue
:
aParams
.
value
]
;
[
cell
setMax
:
aParams
.
max
]
;
[
cell
setIndeterminate
:
aParams
.
indeterminate
]
;
[
cell
setHorizontal
:
aParams
.
horizontal
]
;
[
cell
setControlTint
:
(
aParams
.
insideActiveWindow
?
[
NSColor
currentControlTint
]
:
NSClearControlTint
)
]
;
DrawCellWithSnapping
(
cell
cgContext
inBoxRect
progressSettings
[
aParams
.
horizontal
]
[
aParams
.
indeterminate
]
aParams
.
verticalAlignFactor
mCellDrawView
aParams
.
rtl
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
const
CellRenderSettings
meterSetting
=
{
{
NSMakeSize
(
0
16
)
NSMakeSize
(
0
16
)
NSMakeSize
(
0
16
)
}
{
NSZeroSize
NSZeroSize
NSZeroSize
}
{
{
{
1
1
1
1
}
{
1
1
1
1
}
{
1
1
1
1
}
}
{
{
1
1
1
1
}
{
1
1
1
1
}
{
1
1
1
1
}
}
}
}
;
nsNativeThemeCocoa
:
:
MeterParams
nsNativeThemeCocoa
:
:
ComputeMeterParams
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
(
content
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
meter
)
)
)
{
return
MeterParams
(
)
;
}
HTMLMeterElement
*
meterElement
=
static_cast
<
HTMLMeterElement
*
>
(
content
)
;
MeterParams
params
;
params
.
value
=
meterElement
-
>
Value
(
)
;
params
.
min
=
meterElement
-
>
Min
(
)
;
params
.
max
=
meterElement
-
>
Max
(
)
;
EventStates
states
=
meterElement
-
>
State
(
)
;
if
(
states
.
HasState
(
NS_EVENT_STATE_SUB_OPTIMUM
)
)
{
params
.
optimumState
=
OptimumState
:
:
eSubOptimum
;
}
else
if
(
states
.
HasState
(
NS_EVENT_STATE_SUB_SUB_OPTIMUM
)
)
{
params
.
optimumState
=
OptimumState
:
:
eSubSubOptimum
;
}
params
.
horizontal
=
!
IsVerticalMeter
(
aFrame
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawMeter
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
MeterParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
NSLevelIndicatorCell
*
cell
=
mMeterBarCell
;
[
cell
setMinValue
:
aParams
.
min
]
;
[
cell
setMaxValue
:
aParams
.
max
]
;
[
cell
setDoubleValue
:
aParams
.
value
]
;
switch
(
aParams
.
optimumState
)
{
case
OptimumState
:
:
eOptimum
:
[
cell
setWarningValue
:
aParams
.
max
+
1
]
;
[
cell
setCriticalValue
:
aParams
.
max
+
1
]
;
break
;
case
OptimumState
:
:
eSubOptimum
:
[
cell
setWarningValue
:
aParams
.
value
]
;
[
cell
setCriticalValue
:
aParams
.
max
+
1
]
;
break
;
case
OptimumState
:
:
eSubSubOptimum
:
[
cell
setWarningValue
:
aParams
.
max
+
1
]
;
[
cell
setCriticalValue
:
aParams
.
value
]
;
break
;
}
HIRect
rect
=
CGRectStandardize
(
inBoxRect
)
;
BOOL
vertical
=
!
aParams
.
horizontal
;
CGContextSaveGState
(
cgContext
)
;
if
(
vertical
)
{
CGFloat
tmp
=
rect
.
size
.
width
;
rect
.
size
.
width
=
rect
.
size
.
height
;
rect
.
size
.
height
=
tmp
;
rect
.
origin
.
x
+
=
rect
.
size
.
height
/
2
.
f
-
rect
.
size
.
width
/
2
.
f
;
rect
.
origin
.
y
+
=
rect
.
size
.
width
/
2
.
f
-
rect
.
size
.
height
/
2
.
f
;
CGContextTranslateCTM
(
cgContext
CGRectGetMidX
(
rect
)
CGRectGetMidY
(
rect
)
)
;
CGContextRotateCTM
(
cgContext
-
M_PI
/
2
.
f
)
;
CGContextTranslateCTM
(
cgContext
-
CGRectGetMidX
(
rect
)
-
CGRectGetMidY
(
rect
)
)
;
}
DrawCellWithSnapping
(
cell
cgContext
rect
meterSetting
aParams
.
verticalAlignFactor
mCellDrawView
!
vertical
&
&
aParams
.
rtl
)
;
CGContextRestoreGState
(
cgContext
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
}
void
nsNativeThemeCocoa
:
:
DrawTabPanel
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
bool
aIsInsideActiveWindow
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeTabPaneDrawInfo
tpdi
;
tpdi
.
version
=
1
;
tpdi
.
state
=
aIsInsideActiveWindow
?
kThemeStateActive
:
kThemeStateInactive
;
tpdi
.
direction
=
kThemeTabNorth
;
tpdi
.
size
=
kHIThemeTabSizeNormal
;
tpdi
.
kind
=
kHIThemeTabKindNormal
;
HIThemeDrawTabPane
(
&
inBoxRect
&
tpdi
cgContext
HITHEME_ORIENTATION
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
Maybe
<
nsNativeThemeCocoa
:
:
ScaleParams
>
nsNativeThemeCocoa
:
:
ComputeHTMLScaleParams
(
nsIFrame
*
aFrame
EventStates
aEventState
)
{
nsRangeFrame
*
rangeFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
rangeFrame
)
{
return
Nothing
(
)
;
}
bool
isHorizontal
=
IsRangeHorizontal
(
aFrame
)
;
ScaleParams
params
;
params
.
value
=
int32_t
(
rangeFrame
-
>
GetValueAsFractionOfRange
(
)
*
1000
)
;
params
.
min
=
0
;
params
.
max
=
1000
;
params
.
reverse
=
!
isHorizontal
|
|
rangeFrame
-
>
IsRightToLeft
(
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
focused
=
aEventState
.
HasState
(
NS_EVENT_STATE_FOCUSRING
)
;
params
.
disabled
=
IsDisabled
(
aFrame
aEventState
)
;
params
.
horizontal
=
isHorizontal
;
return
Some
(
params
)
;
}
void
nsNativeThemeCocoa
:
:
DrawScale
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
ScaleParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeTrackDrawInfo
tdi
;
tdi
.
version
=
0
;
tdi
.
kind
=
kThemeMediumSlider
;
tdi
.
bounds
=
inBoxRect
;
tdi
.
min
=
aParams
.
min
;
tdi
.
max
=
aParams
.
max
;
tdi
.
value
=
aParams
.
value
;
tdi
.
attributes
=
kThemeTrackShowThumb
;
if
(
aParams
.
horizontal
)
{
tdi
.
attributes
|
=
kThemeTrackHorizontal
;
}
if
(
aParams
.
reverse
)
{
tdi
.
attributes
|
=
kThemeTrackRightToLeft
;
}
if
(
aParams
.
focused
)
{
tdi
.
attributes
|
=
kThemeTrackHasFocus
;
}
if
(
aParams
.
disabled
)
{
tdi
.
enableState
=
kThemeTrackDisabled
;
}
else
{
tdi
.
enableState
=
aParams
.
insideActiveWindow
?
kThemeTrackActive
:
kThemeTrackInactive
;
}
tdi
.
trackInfo
.
slider
.
thumbDir
=
kThemeThumbPlain
;
tdi
.
trackInfo
.
slider
.
pressState
=
0
;
HIThemeDrawTrack
(
&
tdi
NULL
cgContext
HITHEME_ORIENTATION
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsIFrame
*
nsNativeThemeCocoa
:
:
SeparatorResponsibility
(
nsIFrame
*
aBefore
nsIFrame
*
aAfter
)
{
if
(
!
aBefore
|
|
!
aAfter
)
return
nullptr
;
if
(
IsSelectedButton
(
aAfter
)
)
return
aAfter
;
if
(
IsSelectedButton
(
aBefore
)
|
|
IsPressedButton
(
aBefore
)
)
return
aBefore
;
return
aAfter
;
}
static
CGRect
SeparatorAdjustedRect
(
CGRect
aRect
nsNativeThemeCocoa
:
:
SegmentParams
aParams
)
{
if
(
!
aParams
.
atLeftEnd
&
&
!
aParams
.
drawsLeftSeparator
)
{
aRect
.
origin
.
x
+
=
1
;
aRect
.
size
.
width
-
=
1
;
}
if
(
aParams
.
drawsRightSeparator
)
{
aRect
.
size
.
width
+
=
1
;
}
return
aRect
;
}
static
NSString
*
ToolbarButtonPosition
(
BOOL
aIsFirst
BOOL
aIsLast
)
{
if
(
aIsFirst
)
{
if
(
aIsLast
)
return
"
kCUISegmentPositionOnly
"
;
return
"
kCUISegmentPositionFirst
"
;
}
if
(
aIsLast
)
return
"
kCUISegmentPositionLast
"
;
return
"
kCUISegmentPositionMiddle
"
;
}
struct
SegmentedControlRenderSettings
{
const
CGFloat
*
heights
;
const
NSString
*
widgetName
;
}
;
static
const
CGFloat
tabHeights
[
3
]
=
{
17
20
23
}
;
static
const
SegmentedControlRenderSettings
tabRenderSettings
=
{
tabHeights
"
tab
"
}
;
static
const
CGFloat
toolbarButtonHeights
[
3
]
=
{
15
18
22
}
;
static
const
SegmentedControlRenderSettings
toolbarButtonRenderSettings
=
{
toolbarButtonHeights
"
kCUIWidgetButtonSegmentedSCurve
"
}
;
nsNativeThemeCocoa
:
:
SegmentParams
nsNativeThemeCocoa
:
:
ComputeSegmentParams
(
nsIFrame
*
aFrame
EventStates
aEventState
SegmentType
aSegmentType
)
{
SegmentParams
params
;
params
.
segmentType
=
aSegmentType
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
pressed
=
IsPressedButton
(
aFrame
)
;
params
.
selected
=
IsSelectedButton
(
aFrame
)
;
params
.
focused
=
aEventState
.
HasState
(
NS_EVENT_STATE_FOCUSRING
)
;
bool
isRTL
=
IsFrameRTL
(
aFrame
)
;
nsIFrame
*
left
=
GetAdjacentSiblingFrameWithSameAppearance
(
aFrame
isRTL
)
;
nsIFrame
*
right
=
GetAdjacentSiblingFrameWithSameAppearance
(
aFrame
!
isRTL
)
;
params
.
atLeftEnd
=
!
left
;
params
.
atRightEnd
=
!
right
;
params
.
drawsLeftSeparator
=
SeparatorResponsibility
(
left
aFrame
)
=
=
aFrame
;
params
.
drawsRightSeparator
=
SeparatorResponsibility
(
aFrame
right
)
=
=
aFrame
;
params
.
rtl
=
isRTL
;
return
params
;
}
static
SegmentedControlRenderSettings
RenderSettingsForSegmentType
(
nsNativeThemeCocoa
:
:
SegmentType
aSegmentType
)
{
switch
(
aSegmentType
)
{
case
nsNativeThemeCocoa
:
:
SegmentType
:
:
eToolbarButton
:
return
toolbarButtonRenderSettings
;
case
nsNativeThemeCocoa
:
:
SegmentType
:
:
eTab
:
return
tabRenderSettings
;
}
}
void
nsNativeThemeCocoa
:
:
DrawSegmentBackground
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
SegmentParams
&
aParams
)
{
MOZ_ASSERT
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
;
if
(
aParams
.
selected
)
{
DeviceColor
color
=
ToDeviceColor
(
mozilla
:
:
gfx
:
:
sRGBColor
:
:
FromU8
(
93
93
93
255
)
)
;
CGContextSetRGBFillColor
(
cgContext
color
.
r
color
.
g
color
.
b
color
.
a
)
;
}
else
{
DeviceColor
color
=
ToDeviceColor
(
mozilla
:
:
gfx
:
:
sRGBColor
:
:
FromU8
(
247
247
247
255
)
)
;
CGContextSetRGBFillColor
(
cgContext
color
.
r
color
.
g
color
.
b
color
.
a
)
;
}
CGRect
bgRect
=
inBoxRect
;
bgRect
.
size
.
height
-
=
3
.
0
;
bgRect
.
size
.
width
-
=
4
.
0
;
bgRect
.
origin
.
x
+
=
2
.
0
;
bgRect
.
origin
.
y
+
=
1
.
0
;
if
(
aParams
.
atLeftEnd
|
|
aParams
.
atRightEnd
)
{
CGPathRef
path
=
CGPathCreateWithRoundedRect
(
bgRect
5
4
nullptr
)
;
CGContextAddPath
(
cgContext
path
)
;
CGPathRelease
(
path
)
;
CGContextClosePath
(
cgContext
)
;
CGContextFillPath
(
cgContext
)
;
}
if
(
!
aParams
.
atLeftEnd
&
&
aParams
.
atRightEnd
)
{
CGRect
leftRectEdge
=
bgRect
;
leftRectEdge
.
size
.
width
-
=
10
;
leftRectEdge
.
origin
.
x
-
=
2
;
CGContextFillRect
(
cgContext
leftRectEdge
)
;
}
else
if
(
aParams
.
atLeftEnd
&
&
!
aParams
.
atRightEnd
)
{
CGRect
rightRectEdge
=
bgRect
;
rightRectEdge
.
size
.
width
-
=
10
;
rightRectEdge
.
origin
.
x
+
=
12
;
CGContextFillRect
(
cgContext
rightRectEdge
)
;
}
else
if
(
!
aParams
.
atLeftEnd
&
&
!
aParams
.
atRightEnd
)
{
CGRect
middleRect
=
bgRect
;
middleRect
.
size
.
width
+
=
4
;
middleRect
.
origin
.
x
-
=
2
;
CGContextFillRect
(
cgContext
middleRect
)
;
}
}
void
nsNativeThemeCocoa
:
:
DrawSegment
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
SegmentParams
&
aParams
)
{
SegmentedControlRenderSettings
renderSettings
=
RenderSettingsForSegmentType
(
aParams
.
segmentType
)
;
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
&
&
(
aParams
.
segmentType
=
=
nsNativeThemeCocoa
:
:
SegmentType
:
:
eToolbarButton
)
)
{
DrawSegmentBackground
(
cgContext
inBoxRect
aParams
)
;
}
NSControlSize
controlSize
=
FindControlSize
(
inBoxRect
.
size
.
height
renderSettings
.
heights
4
.
0f
)
;
CGRect
drawRect
=
SeparatorAdjustedRect
(
inBoxRect
aParams
)
;
NSDictionary
*
dict
=
{
"
widget
"
:
renderSettings
.
widgetName
"
kCUIPresentationStateKey
"
:
(
aParams
.
insideActiveWindow
?
"
kCUIPresentationStateActiveKey
"
:
"
kCUIPresentationStateInactive
"
)
"
kCUIPositionKey
"
:
ToolbarButtonPosition
(
aParams
.
atLeftEnd
aParams
.
atRightEnd
)
"
kCUISegmentLeadingSeparatorKey
"
:
[
NSNumber
numberWithBool
:
aParams
.
drawsLeftSeparator
]
"
kCUISegmentTrailingSeparatorKey
"
:
[
NSNumber
numberWithBool
:
aParams
.
drawsRightSeparator
]
"
value
"
:
[
NSNumber
numberWithBool
:
aParams
.
selected
]
"
state
"
:
(
aParams
.
pressed
?
"
pressed
"
:
(
aParams
.
insideActiveWindow
?
"
normal
"
:
"
inactive
"
)
)
"
focus
"
:
[
NSNumber
numberWithBool
:
aParams
.
focused
]
"
size
"
:
CUIControlSizeForCocoaSize
(
controlSize
)
"
is
.
flipped
"
:
[
NSNumber
numberWithBool
:
YES
]
"
direction
"
:
"
up
"
}
;
RenderWithCoreUI
(
drawRect
cgContext
dict
)
;
}
static
nsIFrame
*
GetParentScrollbarFrame
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
scrollbarFrame
=
aFrame
;
do
{
if
(
scrollbarFrame
-
>
IsScrollbarFrame
(
)
)
break
;
}
while
(
(
scrollbarFrame
=
scrollbarFrame
-
>
GetParent
(
)
)
)
;
return
scrollbarFrame
;
}
void
nsNativeThemeCocoa
:
:
DrawToolbar
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
bool
aIsMain
)
{
CGRect
drawRect
=
inBoxRect
;
drawRect
.
size
.
height
=
1
.
0f
;
DrawNativeGreyColorInRect
(
cgContext
toolbarTopBorderGrey
drawRect
aIsMain
)
;
drawRect
.
origin
.
y
+
=
drawRect
.
size
.
height
;
drawRect
.
size
.
height
=
inBoxRect
.
size
.
height
-
2
.
0f
;
DrawNativeGreyColorInRect
(
cgContext
toolbarFillGrey
drawRect
aIsMain
)
;
drawRect
.
origin
.
y
+
=
drawRect
.
size
.
height
;
drawRect
.
size
.
height
=
1
.
0f
;
DrawNativeGreyColorInRect
(
cgContext
toolbarBottomBorderGrey
drawRect
aIsMain
)
;
}
static
bool
ToolbarCanBeUnified
(
const
gfx
:
:
Rect
&
aRect
NSWindow
*
aWindow
)
{
if
(
!
[
aWindow
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
return
false
;
ToolbarWindow
*
win
=
(
ToolbarWindow
*
)
aWindow
;
float
unifiedToolbarHeight
=
[
win
unifiedToolbarHeight
]
;
return
aRect
.
X
(
)
=
=
0
&
&
aRect
.
Width
(
)
>
=
[
win
frame
]
.
size
.
width
&
&
aRect
.
YMost
(
)
<
=
unifiedToolbarHeight
;
}
static
void
DrawNativeTitlebarToolbarWithSquareCorners
(
CGContextRef
aContext
const
CGRect
&
aRect
CGFloat
aUnifiedHeight
BOOL
aIsMain
BOOL
aIsFlipped
)
{
const
CGFloat
extendHorizontal
=
10
;
CGRect
drawRect
=
CGRectInset
(
aRect
-
extendHorizontal
0
)
;
CGContextSaveGState
(
aContext
)
;
CGContextClipToRect
(
aContext
aRect
)
;
RenderWithCoreUI
(
drawRect
aContext
[
NSDictionary
dictionaryWithObjectsAndKeys
:
"
kCUIWidgetWindowFrame
"
"
widget
"
"
regularwin
"
"
windowtype
"
(
aIsMain
?
"
normal
"
:
"
inactive
"
)
"
state
"
[
NSNumber
numberWithDouble
:
aUnifiedHeight
]
"
kCUIWindowFrameUnifiedTitleBarHeightKey
"
[
NSNumber
numberWithBool
:
YES
]
"
kCUIWindowFrameDrawTitleSeparatorKey
"
[
NSNumber
numberWithBool
:
aIsFlipped
]
"
is
.
flipped
"
nil
]
)
;
CGContextRestoreGState
(
aContext
)
;
}
void
nsNativeThemeCocoa
:
:
DrawUnifiedToolbar
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
UnifiedToolbarParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
CGContextSaveGState
(
cgContext
)
;
CGContextClipToRect
(
cgContext
inBoxRect
)
;
CGFloat
titlebarHeight
=
aParams
.
unifiedHeight
-
inBoxRect
.
size
.
height
;
CGRect
drawRect
=
CGRectMake
(
inBoxRect
.
origin
.
x
inBoxRect
.
origin
.
y
-
titlebarHeight
inBoxRect
.
size
.
width
inBoxRect
.
size
.
height
+
titlebarHeight
)
;
DrawNativeTitlebarToolbarWithSquareCorners
(
cgContext
drawRect
aParams
.
unifiedHeight
aParams
.
isMain
YES
)
;
CGContextRestoreGState
(
cgContext
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawStatusBar
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
bool
aIsMain
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
inBoxRect
.
size
.
height
<
2
.
0f
)
return
;
CGContextSaveGState
(
cgContext
)
;
CGContextClipToRect
(
cgContext
inBoxRect
)
;
CGRect
drawRect
=
inBoxRect
;
const
int
extendUpwards
=
40
;
drawRect
.
origin
.
y
-
=
extendUpwards
;
drawRect
.
size
.
height
+
=
extendUpwards
;
RenderWithCoreUI
(
drawRect
cgContext
[
NSDictionary
dictionaryWithObjectsAndKeys
:
"
kCUIWidgetWindowFrame
"
"
widget
"
"
regularwin
"
"
windowtype
"
(
aIsMain
?
"
normal
"
:
"
inactive
"
)
"
state
"
[
NSNumber
numberWithInt
:
inBoxRect
.
size
.
height
]
"
kCUIWindowFrameBottomBarHeightKey
"
[
NSNumber
numberWithBool
:
YES
]
"
kCUIWindowFrameDrawBottomBarSeparatorKey
"
[
NSNumber
numberWithBool
:
YES
]
"
is
.
flipped
"
nil
]
)
;
CGContextRestoreGState
(
cgContext
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawNativeTitlebar
(
CGContextRef
aContext
CGRect
aTitlebarRect
CGFloat
aUnifiedHeight
BOOL
aIsMain
BOOL
aIsFlipped
)
{
CGFloat
unifiedHeight
=
std
:
:
max
(
aUnifiedHeight
aTitlebarRect
.
size
.
height
)
;
DrawNativeTitlebarToolbarWithSquareCorners
(
aContext
aTitlebarRect
unifiedHeight
aIsMain
aIsFlipped
)
;
}
void
nsNativeThemeCocoa
:
:
DrawNativeTitlebar
(
CGContextRef
aContext
CGRect
aTitlebarRect
const
UnifiedToolbarParams
&
aParams
)
{
DrawNativeTitlebar
(
aContext
aTitlebarRect
aParams
.
unifiedHeight
aParams
.
isMain
YES
)
;
}
static
void
RenderResizer
(
CGContextRef
cgContext
const
HIRect
&
aRenderRect
void
*
aData
)
{
HIThemeGrowBoxDrawInfo
*
drawInfo
=
(
HIThemeGrowBoxDrawInfo
*
)
aData
;
HIThemeDrawGrowBox
(
&
CGPointZero
drawInfo
cgContext
kHIThemeOrientationNormal
)
;
}
void
nsNativeThemeCocoa
:
:
DrawResizer
(
CGContextRef
cgContext
const
HIRect
&
aRect
bool
aIsRTL
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
HIThemeGrowBoxDrawInfo
drawInfo
;
drawInfo
.
version
=
0
;
drawInfo
.
state
=
kThemeStateActive
;
drawInfo
.
kind
=
kHIThemeGrowBoxKindNormal
;
drawInfo
.
direction
=
kThemeGrowRight
|
kThemeGrowDown
;
drawInfo
.
size
=
kHIThemeGrowBoxSizeNormal
;
RenderTransformedHIThemeControl
(
cgContext
aRect
RenderResizer
&
drawInfo
aIsRTL
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
bool
IsSmallScrollbar
(
nsIFrame
*
aFrame
)
{
ComputedStyle
*
style
=
nsLayoutUtils
:
:
StyleForScrollbar
(
aFrame
)
;
if
(
style
-
>
StyleUIReset
(
)
-
>
mScrollbarWidth
=
=
StyleScrollbarWidth
:
:
Thin
)
{
return
true
;
}
nsIFrame
*
scrollbarFrame
=
GetParentScrollbarFrame
(
aFrame
)
;
if
(
scrollbarFrame
&
&
scrollbarFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
=
=
StyleAppearance
:
:
ScrollbarSmall
)
{
return
true
;
}
return
false
;
}
nsNativeThemeCocoa
:
:
ScrollbarParams
nsNativeThemeCocoa
:
:
ComputeScrollbarParams
(
nsIFrame
*
aFrame
bool
aIsHorizontal
)
{
ScrollbarParams
params
;
params
.
overlay
=
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
;
params
.
rolledOver
=
IsParentScrollbarRolledOver
(
aFrame
)
;
params
.
small
=
IsSmallScrollbar
(
aFrame
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
params
.
horizontal
=
aIsHorizontal
;
params
.
onDarkBackground
=
IsDarkBackground
(
aFrame
)
;
if
(
!
params
.
overlay
)
{
ComputedStyle
*
style
=
nsLayoutUtils
:
:
StyleForScrollbar
(
aFrame
)
;
const
nsStyleUI
*
ui
=
style
-
>
StyleUI
(
)
;
if
(
ui
-
>
HasCustomScrollbars
(
)
)
{
const
auto
&
colors
=
ui
-
>
mScrollbarColor
.
AsColors
(
)
;
params
.
custom
=
true
;
params
.
trackColor
=
colors
.
track
.
CalcColor
(
*
style
)
;
params
.
faceColor
=
colors
.
thumb
.
CalcColor
(
*
style
)
;
}
}
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawScrollbarThumb
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
ScrollbarParams
aParams
)
{
CGFloat
thickness
=
aParams
.
small
?
6
.
0f
:
8
.
0f
;
if
(
aParams
.
overlay
)
{
thickness
-
=
1
.
0f
;
if
(
aParams
.
rolledOver
)
{
thickness
+
=
4
.
0f
;
}
}
CGFloat
outerSpacing
=
(
aParams
.
overlay
|
|
aParams
.
small
)
?
1
.
0f
:
2
.
0f
;
CGRect
thumbRect
=
CGRectInset
(
inBoxRect
1
.
0f
1
.
0f
)
;
if
(
aParams
.
horizontal
)
{
thumbRect
.
origin
.
y
=
CGRectGetMaxY
(
thumbRect
)
-
outerSpacing
-
thickness
;
thumbRect
.
size
.
height
=
thickness
;
}
else
{
if
(
aParams
.
rtl
)
{
thumbRect
.
origin
.
x
=
thumbRect
.
origin
.
x
+
outerSpacing
;
}
else
{
thumbRect
.
origin
.
x
=
CGRectGetMaxX
(
thumbRect
)
-
outerSpacing
-
thickness
;
}
thumbRect
.
size
.
width
=
thickness
;
}
nscolor
faceColor
;
if
(
aParams
.
custom
)
{
faceColor
=
aParams
.
faceColor
;
}
else
{
if
(
aParams
.
overlay
)
{
faceColor
=
aParams
.
onDarkBackground
?
NS_RGBA
(
255
255
255
128
)
:
NS_RGBA
(
0
0
0
128
)
;
}
else
{
faceColor
=
aParams
.
rolledOver
?
NS_RGBA
(
125
125
125
255
)
:
NS_RGBA
(
194
194
194
255
)
;
}
}
CGFloat
cornerRadius
=
(
aParams
.
horizontal
?
thumbRect
.
size
.
height
:
thumbRect
.
size
.
width
)
/
2
.
0f
;
CGPathRef
path
=
CGPathCreateWithRoundedRect
(
thumbRect
cornerRadius
cornerRadius
nullptr
)
;
CGContextAddPath
(
cgContext
path
)
;
CGPathRelease
(
path
)
;
SetCGContextFillColor
(
cgContext
faceColor
)
;
CGContextFillPath
(
cgContext
)
;
if
(
aParams
.
overlay
)
{
CGFloat
strokeOutset
=
aParams
.
onDarkBackground
?
0
.
3f
:
0
.
5f
;
CGFloat
strokeWidth
=
aParams
.
onDarkBackground
?
0
.
6f
:
0
.
8f
;
nscolor
strokeColor
=
aParams
.
onDarkBackground
?
NS_RGBA
(
0
0
0
48
)
:
NS_RGBA
(
255
255
255
48
)
;
CGRect
thumbStrokeRect
=
CGRectInset
(
thumbRect
-
strokeOutset
-
strokeOutset
)
;
CGFloat
strokeRadius
=
(
aParams
.
horizontal
?
thumbStrokeRect
.
size
.
height
:
thumbStrokeRect
.
size
.
width
)
/
2
.
0f
;
CGPathRef
path
=
CGPathCreateWithRoundedRect
(
thumbStrokeRect
strokeRadius
strokeRadius
nullptr
)
;
CGContextAddPath
(
cgContext
path
)
;
CGPathRelease
(
path
)
;
SetCGContextStrokeColor
(
cgContext
strokeColor
)
;
CGContextSetLineWidth
(
cgContext
strokeWidth
)
;
CGContextStrokePath
(
cgContext
)
;
}
}
struct
ScrollbarTrackDecorationColors
{
nscolor
mInnerColor
;
nscolor
mShadowColor
;
nscolor
mOuterColor
;
}
;
static
ScrollbarTrackDecorationColors
ComputeScrollbarTrackDecorationColors
(
nscolor
aTrackColor
)
{
ScrollbarTrackDecorationColors
result
;
float
luminance
=
RelativeLuminanceUtils
:
:
Compute
(
aTrackColor
)
;
if
(
luminance
>
=
0
.
5
)
{
result
.
mInnerColor
=
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
luminance
*
0
.
836
)
;
result
.
mShadowColor
=
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
luminance
*
0
.
982
)
;
result
.
mOuterColor
=
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
luminance
*
0
.
886
)
;
}
else
{
result
.
mInnerColor
=
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
luminance
*
1
.
196
)
;
result
.
mShadowColor
=
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
luminance
*
1
.
018
)
;
result
.
mOuterColor
=
RelativeLuminanceUtils
:
:
Adjust
(
aTrackColor
luminance
*
1
.
129
)
;
}
return
result
;
}
void
nsNativeThemeCocoa
:
:
DrawScrollbarTrack
(
DrawTarget
&
aDT
const
gfx
:
:
Rect
&
aRect
ScrollbarParams
aParams
)
{
if
(
aParams
.
overlay
&
&
!
aParams
.
rolledOver
)
{
return
;
}
nscolor
trackColor
;
if
(
aParams
.
custom
)
{
trackColor
=
aParams
.
trackColor
;
}
else
{
if
(
aParams
.
overlay
)
{
trackColor
=
aParams
.
onDarkBackground
?
NS_RGBA
(
201
201
201
38
)
:
NS_RGBA
(
250
250
250
191
)
;
}
else
{
trackColor
=
NS_RGBA
(
250
250
250
255
)
;
}
}
float
thickness
=
aParams
.
horizontal
?
aRect
.
height
:
aRect
.
width
;
ScrollbarTrackDecorationColors
colors
=
ComputeScrollbarTrackDecorationColors
(
trackColor
)
;
struct
{
nscolor
color
;
float
thickness
;
}
segments
[
]
=
{
{
colors
.
mInnerColor
1
.
0f
}
{
colors
.
mShadowColor
1
.
0f
}
{
trackColor
thickness
-
3
.
0f
}
{
colors
.
mOuterColor
1
.
0f
}
}
;
float
accumulatedThickness
=
0
.
0f
;
for
(
const
auto
&
segment
:
segments
)
{
gfx
:
:
Rect
segmentRect
=
aRect
;
float
startThickness
=
accumulatedThickness
;
float
endThickness
=
startThickness
+
segment
.
thickness
;
if
(
aParams
.
horizontal
)
{
segmentRect
.
SetBoxY
(
aRect
.
Y
(
)
+
startThickness
aRect
.
Y
(
)
+
endThickness
)
;
}
else
{
if
(
aParams
.
rtl
)
{
segmentRect
.
SetBoxX
(
aRect
.
XMost
(
)
-
endThickness
aRect
.
XMost
(
)
-
startThickness
)
;
}
else
{
segmentRect
.
SetBoxX
(
aRect
.
X
(
)
+
startThickness
aRect
.
X
(
)
+
endThickness
)
;
}
}
aDT
.
FillRect
(
segmentRect
ColorPattern
(
ToDeviceColor
(
segment
.
color
)
)
)
;
accumulatedThickness
=
endThickness
;
}
}
void
nsNativeThemeCocoa
:
:
DrawScrollCorner
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
ScrollbarParams
aParams
)
{
if
(
aParams
.
overlay
&
&
!
aParams
.
rolledOver
)
{
return
;
}
if
(
!
aParams
.
custom
)
{
SetCGContextFillColor
(
cgContext
NS_RGB
(
255
255
255
)
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
return
;
}
SetCGContextFillColor
(
cgContext
aParams
.
trackColor
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
ScrollbarTrackDecorationColors
colors
=
ComputeScrollbarTrackDecorationColors
(
aParams
.
trackColor
)
;
CGRect
shadowRect
innerRect
;
if
(
aParams
.
rtl
)
{
shadowRect
.
origin
.
x
=
inBoxRect
.
origin
.
x
+
inBoxRect
.
size
.
width
-
2
;
innerRect
.
origin
.
x
=
shadowRect
.
origin
.
x
+
1
;
}
else
{
shadowRect
.
origin
.
x
=
inBoxRect
.
origin
.
x
;
innerRect
.
origin
.
x
=
shadowRect
.
origin
.
x
;
}
shadowRect
.
origin
.
y
=
inBoxRect
.
origin
.
y
;
shadowRect
.
size
.
width
=
shadowRect
.
size
.
height
=
2
;
innerRect
.
origin
.
y
=
inBoxRect
.
origin
.
y
;
innerRect
.
size
.
width
=
innerRect
.
size
.
height
=
1
;
SetCGContextFillColor
(
cgContext
colors
.
mShadowColor
)
;
CGContextFillRect
(
cgContext
shadowRect
)
;
SetCGContextFillColor
(
cgContext
colors
.
mInnerColor
)
;
CGContextFillRect
(
cgContext
innerRect
)
;
CGPoint
outerPoints
[
4
]
;
outerPoints
[
0
]
.
x
=
aParams
.
rtl
?
inBoxRect
.
origin
.
x
+
0
.
5
:
inBoxRect
.
origin
.
x
+
inBoxRect
.
size
.
width
-
0
.
5
;
outerPoints
[
0
]
.
y
=
inBoxRect
.
origin
.
y
;
outerPoints
[
1
]
.
x
=
outerPoints
[
0
]
.
x
;
outerPoints
[
1
]
.
y
=
outerPoints
[
0
]
.
y
+
inBoxRect
.
size
.
height
;
outerPoints
[
2
]
.
x
=
inBoxRect
.
origin
.
x
;
outerPoints
[
2
]
.
y
=
inBoxRect
.
origin
.
y
+
inBoxRect
.
size
.
height
-
0
.
5
;
outerPoints
[
3
]
.
x
=
outerPoints
[
2
]
.
x
+
inBoxRect
.
size
.
width
-
1
;
outerPoints
[
3
]
.
y
=
outerPoints
[
2
]
.
y
;
SetCGContextStrokeColor
(
cgContext
colors
.
mOuterColor
)
;
CGContextStrokeLineSegments
(
cgContext
outerPoints
4
)
;
}
static
const
sRGBColor
kTooltipBackgroundColor
(
0
.
996
1
.
000
0
.
792
0
.
950
)
;
static
const
sRGBColor
kMultilineTextFieldTopBorderColor
(
0
.
4510
0
.
4510
0
.
4510
1
.
0
)
;
static
const
sRGBColor
kMultilineTextFieldSidesAndBottomBorderColor
(
0
.
6
0
.
6
0
.
6
1
.
0
)
;
static
const
sRGBColor
kListboxTopBorderColor
(
0
.
557
0
.
557
0
.
557
1
.
0
)
;
static
const
sRGBColor
kListBoxSidesAndBottomBorderColor
(
0
.
745
0
.
745
0
.
745
1
.
0
)
;
void
nsNativeThemeCocoa
:
:
DrawMultilineTextField
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
bool
aIsFocused
)
{
SetCGContextFillColor
(
cgContext
sRGBColor
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
float
x
=
inBoxRect
.
origin
.
x
y
=
inBoxRect
.
origin
.
y
;
float
w
=
inBoxRect
.
size
.
width
h
=
inBoxRect
.
size
.
height
;
SetCGContextFillColor
(
cgContext
kMultilineTextFieldTopBorderColor
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
y
w
1
)
)
;
SetCGContextFillColor
(
cgContext
kMultilineTextFieldSidesAndBottomBorderColor
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
y
+
1
1
h
-
1
)
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
+
w
-
1
y
+
1
1
h
-
1
)
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
+
1
y
+
h
-
1
w
-
2
1
)
)
;
if
(
aIsFocused
)
{
NSGraphicsContext
*
savedContext
=
[
NSGraphicsContext
currentContext
]
;
[
NSGraphicsContext
setCurrentContext
:
[
NSGraphicsContext
graphicsContextWithGraphicsPort
:
cgContext
flipped
:
YES
]
]
;
CGContextSaveGState
(
cgContext
)
;
NSSetFocusRingStyle
(
NSFocusRingOnly
)
;
NSRectFill
(
NSRectFromCGRect
(
inBoxRect
)
)
;
CGContextRestoreGState
(
cgContext
)
;
[
NSGraphicsContext
setCurrentContext
:
savedContext
]
;
}
}
void
nsNativeThemeCocoa
:
:
DrawSourceList
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
bool
aIsActive
)
{
CGGradientRef
backgroundGradient
;
CGColorSpaceRef
rgb
=
CGColorSpaceCreateDeviceRGB
(
)
;
CGFloat
activeGradientColors
[
8
]
=
{
0
.
9137
0
.
9294
0
.
9490
1
.
0
0
.
8196
0
.
8471
0
.
8784
1
.
0
}
;
CGFloat
inactiveGradientColors
[
8
]
=
{
0
.
9686
0
.
9686
0
.
9686
1
.
0
0
.
9216
0
.
9216
0
.
9216
1
.
0
}
;
CGPoint
start
=
inBoxRect
.
origin
;
CGPoint
end
=
CGPointMake
(
inBoxRect
.
origin
.
x
inBoxRect
.
origin
.
y
+
inBoxRect
.
size
.
height
)
;
backgroundGradient
=
CGGradientCreateWithColorComponents
(
rgb
aIsActive
?
activeGradientColors
:
inactiveGradientColors
NULL
2
)
;
CGContextDrawLinearGradient
(
cgContext
backgroundGradient
start
end
0
)
;
CGGradientRelease
(
backgroundGradient
)
;
CGColorSpaceRelease
(
rgb
)
;
}
void
nsNativeThemeCocoa
:
:
DrawSourceListSelection
(
CGContextRef
aContext
const
CGRect
&
aRect
bool
aWindowIsActive
bool
aSelectionIsActive
)
{
if
(
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
RenderWithCoreUI
(
aRect
aContext
[
NSDictionary
dictionaryWithObjectsAndKeys
:
[
NSNumber
numberWithBool
:
aSelectionIsActive
]
"
focus
"
[
NSNumber
numberWithBool
:
YES
]
"
is
.
flipped
"
"
kCUIVariantGradientSideBarSelection
"
"
kCUIVariantKey
"
(
aWindowIsActive
?
"
normal
"
:
"
inactive
"
)
"
state
"
"
gradient
"
"
widget
"
nil
]
)
;
return
;
}
NSColor
*
fillColor
;
if
(
aSelectionIsActive
)
{
fillColor
=
ControlAccentColor
(
)
;
}
else
{
if
(
aWindowIsActive
)
{
fillColor
=
[
NSColor
colorWithWhite
:
0
.
871
alpha
:
1
.
0
]
;
}
else
{
fillColor
=
[
NSColor
colorWithWhite
:
0
.
808
alpha
:
1
.
0
]
;
}
}
CGContextSetFillColorWithColor
(
aContext
[
fillColor
CGColor
]
)
;
CGContextFillRect
(
aContext
aRect
)
;
}
bool
nsNativeThemeCocoa
:
:
IsParentScrollbarRolledOver
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
scrollbarFrame
=
GetParentScrollbarFrame
(
aFrame
)
;
return
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
?
CheckBooleanAttr
(
scrollbarFrame
nsGkAtoms
:
:
hover
)
:
GetContentState
(
scrollbarFrame
StyleAppearance
:
:
None
)
.
HasState
(
NS_EVENT_STATE_HOVER
)
;
}
static
bool
IsHiDPIContext
(
nsDeviceContext
*
aContext
)
{
return
AppUnitsPerCSSPixel
(
)
>
=
2
*
aContext
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
}
Maybe
<
nsNativeThemeCocoa
:
:
WidgetInfo
>
nsNativeThemeCocoa
:
:
ComputeWidgetInfo
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
int32_t
p2a
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Rect
nativeWidgetRect
(
aRect
.
x
aRect
.
y
aRect
.
width
aRect
.
height
)
;
nativeWidgetRect
.
Scale
(
1
.
0
/
gfxFloat
(
p2a
)
)
;
float
originalHeight
=
nativeWidgetRect
.
Height
(
)
;
nativeWidgetRect
.
Round
(
)
;
if
(
nativeWidgetRect
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
bool
hidpi
=
IsHiDPIContext
(
aFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
)
;
if
(
hidpi
)
{
nativeWidgetRect
.
Scale
(
0
.
5f
)
;
originalHeight
*
=
0
.
5f
;
}
EventStates
eventState
=
GetContentState
(
aFrame
aAppearance
)
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menupopup
:
if
(
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
WidgetInfo
:
:
MenuBackground
(
ComputeMenuBackgroundParams
(
aFrame
eventState
)
)
)
;
case
StyleAppearance
:
:
Menuarrow
:
return
Some
(
WidgetInfo
:
:
MenuIcon
(
ComputeMenuIconParams
(
aFrame
eventState
MenuIcon
:
:
eMenuArrow
)
)
)
;
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
return
Some
(
WidgetInfo
:
:
MenuItem
(
ComputeMenuItemParams
(
aFrame
eventState
aAppearance
=
=
StyleAppearance
:
:
Checkmenuitem
)
)
)
;
case
StyleAppearance
:
:
Menuseparator
:
return
Some
(
WidgetInfo
:
:
MenuSeparator
(
ComputeMenuItemParams
(
aFrame
eventState
false
)
)
)
;
case
StyleAppearance
:
:
ButtonArrowUp
:
case
StyleAppearance
:
:
ButtonArrowDown
:
{
MenuIcon
icon
=
aAppearance
=
=
StyleAppearance
:
:
ButtonArrowUp
?
MenuIcon
:
:
eMenuUpScrollArrow
:
MenuIcon
:
:
eMenuDownScrollArrow
;
return
Some
(
WidgetInfo
:
:
MenuIcon
(
ComputeMenuIconParams
(
aFrame
eventState
icon
)
)
)
;
}
case
StyleAppearance
:
:
Tooltip
:
if
(
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
WidgetInfo
:
:
Tooltip
(
)
)
;
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
{
bool
isCheckbox
=
(
aAppearance
=
=
StyleAppearance
:
:
Checkbox
)
;
CheckboxOrRadioParams
params
;
params
.
state
=
CheckboxOrRadioState
:
:
eOff
;
if
(
isCheckbox
&
&
GetIndeterminate
(
aFrame
)
)
{
params
.
state
=
CheckboxOrRadioState
:
:
eIndeterminate
;
}
else
if
(
GetCheckedOrSelected
(
aFrame
!
isCheckbox
)
)
{
params
.
state
=
CheckboxOrRadioState
:
:
eOn
;
}
params
.
controlParams
=
ComputeControlParams
(
aFrame
eventState
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
if
(
isCheckbox
)
{
return
Some
(
WidgetInfo
:
:
Checkbox
(
params
)
)
;
}
return
Some
(
WidgetInfo
:
:
Radio
(
params
)
)
;
}
case
StyleAppearance
:
:
Button
:
if
(
IsDefaultButton
(
aFrame
)
)
{
EventStates
docState
=
aFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetDocumentState
(
)
;
bool
isInActiveWindow
=
!
docState
.
HasState
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
;
bool
hasDefaultButtonLook
=
isInActiveWindow
&
&
!
eventState
.
HasState
(
NS_EVENT_STATE_ACTIVE
)
;
ButtonType
buttonType
=
hasDefaultButtonLook
?
ButtonType
:
:
eDefaultPushButton
:
ButtonType
:
:
eRegularPushButton
;
ControlParams
params
=
ComputeControlParams
(
aFrame
eventState
)
;
params
.
insideActiveWindow
=
isInActiveWindow
;
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
params
buttonType
}
)
)
;
}
if
(
IsButtonTypeMenu
(
aFrame
)
)
{
ControlParams
controlParams
=
ComputeControlParams
(
aFrame
eventState
)
;
controlParams
.
focused
=
controlParams
.
focused
|
|
IsFocused
(
aFrame
)
;
controlParams
.
pressed
=
IsOpenButton
(
aFrame
)
;
DropdownParams
params
;
params
.
controlParams
=
controlParams
;
params
.
pullsDown
=
true
;
params
.
editable
=
false
;
return
Some
(
WidgetInfo
:
:
Dropdown
(
params
)
)
;
}
if
(
originalHeight
>
DO_SQUARE_BUTTON_HEIGHT
)
{
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
ButtonType
:
:
eSquareBezelPushButton
}
)
)
;
}
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
ButtonType
:
:
eRoundedBezelPushButton
}
)
)
;
case
StyleAppearance
:
:
FocusOutline
:
return
Some
(
WidgetInfo
:
:
FocusOutline
(
)
)
;
case
StyleAppearance
:
:
MozMacHelpButton
:
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
ButtonType
:
:
eHelpButton
}
)
)
;
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
{
ButtonType
buttonType
=
(
aAppearance
=
=
StyleAppearance
:
:
MozMacDisclosureButtonClosed
)
?
ButtonType
:
:
eDisclosureButtonClosed
:
ButtonType
:
:
eDisclosureButtonOpen
;
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
buttonType
}
)
)
;
}
case
StyleAppearance
:
:
Spinner
:
{
bool
isSpinner
=
(
aAppearance
=
=
StyleAppearance
:
:
Spinner
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
isSpinner
&
&
content
-
>
IsHTMLElement
(
)
)
{
break
;
}
SpinButtonParams
params
;
if
(
content
-
>
IsElement
(
)
)
{
if
(
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
up
"
_ns
eCaseMatters
)
)
{
params
.
pressedButton
=
Some
(
SpinButton
:
:
eUp
)
;
}
else
if
(
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
down
"
_ns
eCaseMatters
)
)
{
params
.
pressedButton
=
Some
(
SpinButton
:
:
eDown
)
;
}
}
params
.
disabled
=
IsDisabled
(
aFrame
eventState
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
return
Some
(
WidgetInfo
:
:
SpinButtons
(
params
)
)
;
}
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
{
nsNumberControlFrame
*
numberControlFrame
=
nsNumberControlFrame
:
:
GetNumberControlFrameForSpinButton
(
aFrame
)
;
if
(
numberControlFrame
)
{
SpinButtonParams
params
;
if
(
numberControlFrame
-
>
SpinnerUpButtonIsDepressed
(
)
)
{
params
.
pressedButton
=
Some
(
SpinButton
:
:
eUp
)
;
}
else
if
(
numberControlFrame
-
>
SpinnerDownButtonIsDepressed
(
)
)
{
params
.
pressedButton
=
Some
(
SpinButton
:
:
eDown
)
;
}
params
.
disabled
=
IsDisabled
(
aFrame
eventState
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
if
(
aAppearance
=
=
StyleAppearance
:
:
SpinnerUpbutton
)
{
return
Some
(
WidgetInfo
:
:
SpinButtonUp
(
params
)
)
;
}
return
Some
(
WidgetInfo
:
:
SpinButtonDown
(
params
)
)
;
}
}
break
;
case
StyleAppearance
:
:
Toolbarbutton
:
{
SegmentParams
params
=
ComputeSegmentParams
(
aFrame
eventState
SegmentType
:
:
eToolbarButton
)
;
params
.
insideActiveWindow
=
[
NativeWindowForFrame
(
aFrame
)
isMainWindow
]
;
return
Some
(
WidgetInfo
:
:
Segment
(
params
)
)
;
}
case
StyleAppearance
:
:
Separator
:
return
Some
(
WidgetInfo
:
:
Separator
(
)
)
;
case
StyleAppearance
:
:
Toolbar
:
{
NSWindow
*
win
=
NativeWindowForFrame
(
aFrame
)
;
bool
isMain
=
[
win
isMainWindow
]
;
if
(
ToolbarCanBeUnified
(
nativeWidgetRect
win
)
)
{
float
unifiedHeight
=
std
:
:
max
(
float
(
[
(
ToolbarWindow
*
)
win
unifiedToolbarHeight
]
)
nativeWidgetRect
.
Height
(
)
)
;
return
Some
(
WidgetInfo
:
:
UnifiedToolbar
(
UnifiedToolbarParams
{
unifiedHeight
isMain
}
)
)
;
}
return
Some
(
WidgetInfo
:
:
Toolbar
(
isMain
)
)
;
}
case
StyleAppearance
:
:
MozWindowTitlebar
:
{
NSWindow
*
win
=
NativeWindowForFrame
(
aFrame
)
;
bool
isMain
=
[
win
isMainWindow
]
;
float
unifiedToolbarHeight
=
[
win
isKindOfClass
:
[
ToolbarWindow
class
]
]
?
[
(
ToolbarWindow
*
)
win
unifiedToolbarHeight
]
:
nativeWidgetRect
.
Height
(
)
;
return
Some
(
WidgetInfo
:
:
NativeTitlebar
(
UnifiedToolbarParams
{
unifiedToolbarHeight
isMain
}
)
)
;
}
case
StyleAppearance
:
:
Statusbar
:
return
Some
(
WidgetInfo
:
:
StatusBar
(
IsActive
(
aFrame
YES
)
)
)
;
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
Menulist
:
{
ControlParams
controlParams
=
ComputeControlParams
(
aFrame
eventState
)
;
controlParams
.
focused
=
controlParams
.
focused
|
|
IsFocused
(
aFrame
)
;
controlParams
.
pressed
=
IsOpenButton
(
aFrame
)
;
DropdownParams
params
;
params
.
controlParams
=
controlParams
;
params
.
pullsDown
=
false
;
params
.
editable
=
false
;
return
Some
(
WidgetInfo
:
:
Dropdown
(
params
)
)
;
}
case
StyleAppearance
:
:
MozMenulistArrowButton
:
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
ButtonType
:
:
eArrowButton
}
)
)
;
case
StyleAppearance
:
:
Groupbox
:
return
Some
(
WidgetInfo
:
:
GroupBox
(
)
)
;
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
NumberInput
:
{
bool
isFocused
=
eventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
;
if
(
aFrame
-
>
GetContent
(
)
-
>
IsXULElement
(
)
&
&
IsFocused
(
aFrame
)
)
{
isFocused
=
true
;
}
bool
isDisabled
=
IsDisabled
(
aFrame
eventState
)
|
|
IsReadOnly
(
aFrame
)
;
return
Some
(
WidgetInfo
:
:
TextBox
(
TextBoxParams
{
isDisabled
isFocused
false
}
)
)
;
}
case
StyleAppearance
:
:
Searchfield
:
return
Some
(
WidgetInfo
:
:
SearchField
(
ComputeSearchFieldParams
(
aFrame
eventState
)
)
)
;
case
StyleAppearance
:
:
ProgressBar
:
{
if
(
IsIndeterminateProgress
(
aFrame
eventState
)
)
{
if
(
!
QueueAnimatedContentForRefresh
(
aFrame
-
>
GetContent
(
)
30
)
)
{
NS_WARNING
(
"
Unable
to
animate
progressbar
!
"
)
;
}
}
return
Some
(
WidgetInfo
:
:
ProgressBar
(
ComputeProgressParams
(
aFrame
eventState
!
IsVerticalProgress
(
aFrame
)
)
)
)
;
}
case
StyleAppearance
:
:
Meter
:
return
Some
(
WidgetInfo
:
:
Meter
(
ComputeMeterParams
(
aFrame
)
)
)
;
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
Meterchunk
:
break
;
case
StyleAppearance
:
:
Treetwisty
:
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
ButtonType
:
:
eTreeTwistyPointingRight
}
)
)
;
case
StyleAppearance
:
:
Treetwistyopen
:
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
eventState
)
ButtonType
:
:
eTreeTwistyPointingDown
}
)
)
;
case
StyleAppearance
:
:
Treeheadercell
:
return
Some
(
WidgetInfo
:
:
TreeHeaderCell
(
ComputeTreeHeaderCellParams
(
aFrame
eventState
)
)
)
;
case
StyleAppearance
:
:
Treeitem
:
case
StyleAppearance
:
:
Treeview
:
return
Some
(
WidgetInfo
:
:
ColorFill
(
sRGBColor
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
)
;
case
StyleAppearance
:
:
Treeheader
:
case
StyleAppearance
:
:
Treeheadersortarrow
:
case
StyleAppearance
:
:
Treeline
:
break
;
case
StyleAppearance
:
:
Range
:
{
Maybe
<
ScaleParams
>
params
=
ComputeHTMLScaleParams
(
aFrame
eventState
)
;
if
(
params
)
{
return
Some
(
WidgetInfo
:
:
Scale
(
*
params
)
)
;
}
break
;
}
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
Scrollbar
:
break
;
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
return
Some
(
WidgetInfo
:
:
ScrollbarThumb
(
ComputeScrollbarParams
(
aFrame
aAppearance
=
=
StyleAppearance
:
:
ScrollbarthumbHorizontal
)
)
)
;
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
break
;
case
StyleAppearance
:
:
ScrollbartrackHorizontal
:
case
StyleAppearance
:
:
ScrollbartrackVertical
:
return
Some
(
WidgetInfo
:
:
ScrollbarTrack
(
ComputeScrollbarParams
(
aFrame
aAppearance
=
=
StyleAppearance
:
:
ScrollbartrackHorizontal
)
)
)
;
case
StyleAppearance
:
:
Scrollcorner
:
return
Some
(
WidgetInfo
:
:
ScrollCorner
(
ComputeScrollbarParams
(
aFrame
false
)
)
)
;
case
StyleAppearance
:
:
Textarea
:
return
Some
(
WidgetInfo
:
:
MultilineTextField
(
eventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
)
;
case
StyleAppearance
:
:
Listbox
:
return
Some
(
WidgetInfo
:
:
ListBox
(
)
)
;
case
StyleAppearance
:
:
MozMacSourceList
:
{
if
(
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
WidgetInfo
:
:
SourceList
(
FrameIsInActiveWindow
(
aFrame
)
)
)
;
}
case
StyleAppearance
:
:
MozMacSourceListSelection
:
case
StyleAppearance
:
:
MozMacActiveSourceListSelection
:
{
if
(
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
&
&
IsInSourceList
(
aFrame
)
)
{
return
Nothing
(
)
;
}
bool
isInActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
if
(
aAppearance
=
=
StyleAppearance
:
:
MozMacActiveSourceListSelection
)
{
return
Some
(
WidgetInfo
:
:
ActiveSourceListSelection
(
isInActiveWindow
)
)
;
}
return
Some
(
WidgetInfo
:
:
InactiveSourceListSelection
(
isInActiveWindow
)
)
;
}
case
StyleAppearance
:
:
Tab
:
{
SegmentParams
params
=
ComputeSegmentParams
(
aFrame
eventState
SegmentType
:
:
eTab
)
;
params
.
pressed
=
params
.
pressed
&
&
!
params
.
selected
;
return
Some
(
WidgetInfo
:
:
Segment
(
params
)
)
;
}
case
StyleAppearance
:
:
Tabpanels
:
return
Some
(
WidgetInfo
:
:
TabPanel
(
FrameIsInActiveWindow
(
aFrame
)
)
)
;
case
StyleAppearance
:
:
Resizer
:
return
Some
(
WidgetInfo
:
:
Resizer
(
IsFrameRTL
(
aFrame
)
)
)
;
default
:
break
;
}
return
Nothing
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
Nothing
(
)
)
;
}
NS_IMETHODIMP
nsNativeThemeCocoa
:
:
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
Maybe
<
WidgetInfo
>
widgetInfo
=
ComputeWidgetInfo
(
aFrame
aAppearance
aRect
)
;
if
(
!
widgetInfo
)
{
return
NS_OK
;
}
int32_t
p2a
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Rect
nativeWidgetRect
=
NSRectToRect
(
aRect
p2a
)
;
nativeWidgetRect
.
Round
(
)
;
bool
hidpi
=
IsHiDPIContext
(
aFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
)
;
RenderWidget
(
*
widgetInfo
*
aContext
-
>
GetDrawTarget
(
)
nativeWidgetRect
NSRectToRect
(
aDirtyRect
p2a
)
hidpi
?
2
.
0f
:
1
.
0f
)
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsNativeThemeCocoa
:
:
RenderWidget
(
const
WidgetInfo
&
aWidgetInfo
DrawTarget
&
aDrawTarget
const
gfx
:
:
Rect
&
aWidgetRect
const
gfx
:
:
Rect
&
aDirtyRect
float
aScale
)
{
AutoRestoreTransform
autoRestoreTransform
(
&
aDrawTarget
)
;
gfx
:
:
Rect
dirtyRect
=
aDirtyRect
;
gfx
:
:
Rect
widgetRect
=
aWidgetRect
;
dirtyRect
.
Scale
(
1
.
0f
/
aScale
)
;
widgetRect
.
Scale
(
1
.
0f
/
aScale
)
;
aDrawTarget
.
SetTransform
(
aDrawTarget
.
GetTransform
(
)
.
PreScale
(
aScale
aScale
)
)
;
const
Widget
widget
=
aWidgetInfo
.
Widget
(
)
;
switch
(
widget
)
{
case
Widget
:
:
eColorFill
:
{
sRGBColor
color
=
aWidgetInfo
.
Params
<
sRGBColor
>
(
)
;
aDrawTarget
.
FillRect
(
widgetRect
ColorPattern
(
ToDeviceColor
(
color
)
)
)
;
break
;
}
case
Widget
:
:
eScrollbarTrack
:
{
ScrollbarParams
params
=
aWidgetInfo
.
Params
<
ScrollbarParams
>
(
)
;
DrawScrollbarTrack
(
aDrawTarget
widgetRect
params
)
;
break
;
}
default
:
{
CGRect
macRect
=
CGRectMake
(
widgetRect
.
X
(
)
widgetRect
.
Y
(
)
widgetRect
.
Width
(
)
widgetRect
.
Height
(
)
)
;
gfxQuartzNativeDrawing
nativeDrawing
(
aDrawTarget
dirtyRect
)
;
CGContextRef
cgContext
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
cgContext
=
=
nullptr
)
{
return
;
}
CGContextSetBaseCTM
(
cgContext
CGAffineTransformMakeScale
(
aScale
aScale
)
)
;
switch
(
widget
)
{
case
Widget
:
:
eColorFill
:
case
Widget
:
:
eScrollbarTrack
:
{
MOZ_CRASH
(
"
already
handled
in
outer
switch
"
)
;
break
;
}
case
Widget
:
:
eMenuBackground
:
{
MenuBackgroundParams
params
=
aWidgetInfo
.
Params
<
MenuBackgroundParams
>
(
)
;
DrawMenuBackground
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMenuIcon
:
{
MenuIconParams
params
=
aWidgetInfo
.
Params
<
MenuIconParams
>
(
)
;
DrawMenuIcon
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMenuItem
:
{
MenuItemParams
params
=
aWidgetInfo
.
Params
<
MenuItemParams
>
(
)
;
DrawMenuItem
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMenuSeparator
:
{
MenuItemParams
params
=
aWidgetInfo
.
Params
<
MenuItemParams
>
(
)
;
DrawMenuSeparator
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eTooltip
:
{
SetCGContextFillColor
(
cgContext
kTooltipBackgroundColor
)
;
CGContextFillRect
(
cgContext
macRect
)
;
break
;
}
case
Widget
:
:
eCheckbox
:
{
CheckboxOrRadioParams
params
=
aWidgetInfo
.
Params
<
CheckboxOrRadioParams
>
(
)
;
DrawCheckboxOrRadio
(
cgContext
true
macRect
params
)
;
break
;
}
case
Widget
:
:
eRadio
:
{
CheckboxOrRadioParams
params
=
aWidgetInfo
.
Params
<
CheckboxOrRadioParams
>
(
)
;
DrawCheckboxOrRadio
(
cgContext
false
macRect
params
)
;
break
;
}
case
Widget
:
:
eButton
:
{
ButtonParams
params
=
aWidgetInfo
.
Params
<
ButtonParams
>
(
)
;
DrawButton
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eDropdown
:
{
DropdownParams
params
=
aWidgetInfo
.
Params
<
DropdownParams
>
(
)
;
DrawDropdown
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eFocusOutline
:
{
DrawFocusOutline
(
cgContext
macRect
)
;
break
;
}
case
Widget
:
:
eSpinButtons
:
{
SpinButtonParams
params
=
aWidgetInfo
.
Params
<
SpinButtonParams
>
(
)
;
DrawSpinButtons
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eSpinButtonUp
:
{
SpinButtonParams
params
=
aWidgetInfo
.
Params
<
SpinButtonParams
>
(
)
;
DrawSpinButton
(
cgContext
macRect
SpinButton
:
:
eUp
params
)
;
break
;
}
case
Widget
:
:
eSpinButtonDown
:
{
SpinButtonParams
params
=
aWidgetInfo
.
Params
<
SpinButtonParams
>
(
)
;
DrawSpinButton
(
cgContext
macRect
SpinButton
:
:
eDown
params
)
;
break
;
}
case
Widget
:
:
eSegment
:
{
SegmentParams
params
=
aWidgetInfo
.
Params
<
SegmentParams
>
(
)
;
DrawSegment
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eSeparator
:
{
HIThemeSeparatorDrawInfo
sdi
=
{
0
kThemeStateActive
}
;
HIThemeDrawSeparator
(
&
macRect
&
sdi
cgContext
HITHEME_ORIENTATION
)
;
break
;
}
case
Widget
:
:
eUnifiedToolbar
:
{
UnifiedToolbarParams
params
=
aWidgetInfo
.
Params
<
UnifiedToolbarParams
>
(
)
;
DrawUnifiedToolbar
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eToolbar
:
{
bool
isMain
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawToolbar
(
cgContext
macRect
isMain
)
;
break
;
}
case
Widget
:
:
eNativeTitlebar
:
{
UnifiedToolbarParams
params
=
aWidgetInfo
.
Params
<
UnifiedToolbarParams
>
(
)
;
DrawNativeTitlebar
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eStatusBar
:
{
bool
isMain
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawStatusBar
(
cgContext
macRect
isMain
)
;
break
;
}
case
Widget
:
:
eGroupBox
:
{
HIThemeGroupBoxDrawInfo
gdi
=
{
0
kThemeStateActive
kHIThemeGroupBoxKindPrimary
}
;
HIThemeDrawGroupBox
(
&
macRect
&
gdi
cgContext
HITHEME_ORIENTATION
)
;
break
;
}
case
Widget
:
:
eTextBox
:
{
TextBoxParams
params
=
aWidgetInfo
.
Params
<
TextBoxParams
>
(
)
;
DrawTextBox
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eSearchField
:
{
SearchFieldParams
params
=
aWidgetInfo
.
Params
<
SearchFieldParams
>
(
)
;
DrawSearchField
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eProgressBar
:
{
ProgressParams
params
=
aWidgetInfo
.
Params
<
ProgressParams
>
(
)
;
DrawProgress
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMeter
:
{
MeterParams
params
=
aWidgetInfo
.
Params
<
MeterParams
>
(
)
;
DrawMeter
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eTreeHeaderCell
:
{
TreeHeaderCellParams
params
=
aWidgetInfo
.
Params
<
TreeHeaderCellParams
>
(
)
;
DrawTreeHeaderCell
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eScale
:
{
ScaleParams
params
=
aWidgetInfo
.
Params
<
ScaleParams
>
(
)
;
DrawScale
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eScrollbarThumb
:
{
ScrollbarParams
params
=
aWidgetInfo
.
Params
<
ScrollbarParams
>
(
)
;
DrawScrollbarThumb
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eScrollCorner
:
{
ScrollbarParams
params
=
aWidgetInfo
.
Params
<
ScrollbarParams
>
(
)
;
DrawScrollCorner
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMultilineTextField
:
{
bool
isFocused
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawMultilineTextField
(
cgContext
macRect
isFocused
)
;
break
;
}
case
Widget
:
:
eListBox
:
{
SetCGContextFillColor
(
cgContext
sRGBColor
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
;
CGContextFillRect
(
cgContext
macRect
)
;
float
x
=
macRect
.
origin
.
x
y
=
macRect
.
origin
.
y
;
float
w
=
macRect
.
size
.
width
h
=
macRect
.
size
.
height
;
SetCGContextFillColor
(
cgContext
kListboxTopBorderColor
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
y
w
1
)
)
;
SetCGContextFillColor
(
cgContext
kListBoxSidesAndBottomBorderColor
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
y
+
1
1
h
-
1
)
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
+
w
-
1
y
+
1
1
h
-
1
)
)
;
CGContextFillRect
(
cgContext
CGRectMake
(
x
+
1
y
+
h
-
1
w
-
2
1
)
)
;
break
;
}
case
Widget
:
:
eSourceList
:
{
bool
isInActiveWindow
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawSourceList
(
cgContext
macRect
isInActiveWindow
)
;
break
;
}
case
Widget
:
:
eActiveSourceListSelection
:
case
Widget
:
:
eInactiveSourceListSelection
:
{
bool
isInActiveWindow
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
bool
isActiveSelection
=
aWidgetInfo
.
Widget
(
)
=
=
Widget
:
:
eActiveSourceListSelection
;
DrawSourceListSelection
(
cgContext
macRect
isInActiveWindow
isActiveSelection
)
;
break
;
}
case
Widget
:
:
eTabPanel
:
{
bool
isInsideActiveWindow
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawTabPanel
(
cgContext
macRect
isInsideActiveWindow
)
;
break
;
}
case
Widget
:
:
eResizer
:
{
bool
isRTL
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawResizer
(
cgContext
macRect
isRTL
)
;
break
;
}
}
CGContextSetBaseCTM
(
cgContext
CGAffineTransformIdentity
)
;
nativeDrawing
.
EndNativeDrawing
(
)
;
}
}
}
bool
nsNativeThemeCocoa
:
:
CreateWebRenderCommandsForWidget
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
wr
:
:
LayoutRect
bounds
=
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
aRect
presContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
EventStates
eventState
=
GetContentState
(
aFrame
aAppearance
)
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menupopup
:
if
(
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
return
true
;
}
return
false
;
case
StyleAppearance
:
:
Menuarrow
:
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Menuseparator
:
return
false
;
case
StyleAppearance
:
:
ButtonArrowUp
:
case
StyleAppearance
:
:
ButtonArrowDown
:
return
false
;
case
StyleAppearance
:
:
Tooltip
:
if
(
!
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
aBuilder
.
PushRect
(
bounds
bounds
true
wr
:
:
ToColorF
(
ToDeviceColor
(
kTooltipBackgroundColor
)
)
)
;
}
return
true
;
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
FocusOutline
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
Spinner
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
case
StyleAppearance
:
:
Toolbarbutton
:
case
StyleAppearance
:
:
Separator
:
case
StyleAppearance
:
:
Toolbar
:
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Searchfield
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Treetwisty
:
case
StyleAppearance
:
:
Treetwistyopen
:
case
StyleAppearance
:
:
Treeheadercell
:
case
StyleAppearance
:
:
Treeitem
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
return
false
;
case
StyleAppearance
:
:
Scrollcorner
:
case
StyleAppearance
:
:
ScrollbartrackHorizontal
:
case
StyleAppearance
:
:
ScrollbartrackVertical
:
{
BOOL
isOverlay
=
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
;
if
(
isOverlay
&
&
!
IsParentScrollbarRolledOver
(
aFrame
)
)
{
return
true
;
}
return
false
;
}
case
StyleAppearance
:
:
Textarea
:
{
if
(
eventState
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
{
return
false
;
}
aBuilder
.
PushRect
(
bounds
bounds
true
wr
:
:
ToColorF
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueWhite
(
)
)
)
)
;
wr
:
:
BorderSide
side
[
4
]
=
{
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kMultilineTextFieldTopBorderColor
)
StyleBorderStyle
:
:
Solid
)
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kMultilineTextFieldSidesAndBottomBorderColor
)
StyleBorderStyle
:
:
Solid
)
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kMultilineTextFieldSidesAndBottomBorderColor
)
StyleBorderStyle
:
:
Solid
)
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kMultilineTextFieldSidesAndBottomBorderColor
)
StyleBorderStyle
:
:
Solid
)
}
;
wr
:
:
BorderRadius
borderRadius
=
wr
:
:
EmptyBorderRadius
(
)
;
float
borderWidth
=
presContext
-
>
CSSPixelsToDevPixels
(
1
.
0f
)
;
wr
:
:
LayoutSideOffsets
borderWidths
=
wr
:
:
ToBorderWidths
(
borderWidth
borderWidth
borderWidth
borderWidth
)
;
mozilla
:
:
Range
<
const
wr
:
:
BorderSide
>
wrsides
(
side
4
)
;
aBuilder
.
PushBorder
(
bounds
bounds
true
borderWidths
wrsides
borderRadius
)
;
return
true
;
}
case
StyleAppearance
:
:
Listbox
:
{
aBuilder
.
PushRect
(
bounds
bounds
true
wr
:
:
ToColorF
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueWhite
(
)
)
)
)
;
wr
:
:
BorderSide
side
[
4
]
=
{
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kListboxTopBorderColor
)
StyleBorderStyle
:
:
Solid
)
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kListBoxSidesAndBottomBorderColor
)
StyleBorderStyle
:
:
Solid
)
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kListBoxSidesAndBottomBorderColor
)
StyleBorderStyle
:
:
Solid
)
wr
:
:
ToBorderSide
(
ToDeviceColor
(
kListBoxSidesAndBottomBorderColor
)
StyleBorderStyle
:
:
Solid
)
}
;
wr
:
:
BorderRadius
borderRadius
=
wr
:
:
EmptyBorderRadius
(
)
;
float
borderWidth
=
presContext
-
>
CSSPixelsToDevPixels
(
1
.
0f
)
;
wr
:
:
LayoutSideOffsets
borderWidths
=
wr
:
:
ToBorderWidths
(
borderWidth
borderWidth
borderWidth
borderWidth
)
;
mozilla
:
:
Range
<
const
wr
:
:
BorderSide
>
wrsides
(
side
4
)
;
aBuilder
.
PushBorder
(
bounds
bounds
true
borderWidths
wrsides
borderRadius
)
;
return
true
;
}
case
StyleAppearance
:
:
MozMacSourceList
:
if
(
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
)
{
return
true
;
}
return
false
;
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Resizer
:
return
false
;
default
:
return
true
;
}
}
LayoutDeviceIntMargin
nsNativeThemeCocoa
:
:
DirectionAwareMargin
(
const
LayoutDeviceIntMargin
&
aMargin
nsIFrame
*
aFrame
)
{
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
nsMargin
m
=
LogicalMargin
(
wm
aMargin
.
top
aMargin
.
right
aMargin
.
bottom
aMargin
.
left
)
.
GetPhysicalMargin
(
wm
)
;
return
LayoutDeviceIntMargin
(
m
.
top
m
.
right
m
.
bottom
m
.
left
)
;
}
static
const
LayoutDeviceIntMargin
kAquaDropdownBorder
(
1
22
2
5
)
;
static
const
LayoutDeviceIntMargin
kAquaComboboxBorder
(
3
20
3
4
)
;
static
const
LayoutDeviceIntMargin
kAquaSearchfieldBorder
(
3
5
2
19
)
;
static
const
LayoutDeviceIntMargin
kAquaSearchfieldBorderBigSur
(
5
5
4
26
)
;
LayoutDeviceIntMargin
nsNativeThemeCocoa
:
:
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
LayoutDeviceIntMargin
result
;
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
if
(
IsButtonTypeMenu
(
aFrame
)
)
{
result
=
DirectionAwareMargin
(
kAquaDropdownBorder
aFrame
)
;
}
else
{
result
=
DirectionAwareMargin
(
LayoutDeviceIntMargin
(
1
7
3
7
)
aFrame
)
;
}
break
;
}
case
StyleAppearance
:
:
Toolbarbutton
:
{
result
=
DirectionAwareMargin
(
LayoutDeviceIntMargin
(
1
4
1
4
)
aFrame
)
;
break
;
}
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
{
result
.
SizeTo
(
2
2
2
2
)
;
break
;
}
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
result
=
DirectionAwareMargin
(
kAquaDropdownBorder
aFrame
)
;
break
;
case
StyleAppearance
:
:
Menuarrow
:
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
result
.
SizeTo
(
0
0
0
28
)
;
}
break
;
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
{
SInt32
frameOutset
=
0
;
:
:
GetThemeMetric
(
kThemeMetricEditTextFrameOutset
&
frameOutset
)
;
SInt32
textPadding
=
0
;
:
:
GetThemeMetric
(
kThemeMetricEditTextWhitespace
&
textPadding
)
;
frameOutset
+
=
textPadding
;
result
.
SizeTo
(
frameOutset
frameOutset
frameOutset
frameOutset
)
;
break
;
}
case
StyleAppearance
:
:
Textarea
:
result
.
SizeTo
(
1
1
1
1
)
;
break
;
case
StyleAppearance
:
:
Searchfield
:
{
auto
border
=
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
?
kAquaSearchfieldBorderBigSur
:
kAquaSearchfieldBorder
;
result
=
DirectionAwareMargin
(
border
aFrame
)
;
break
;
}
case
StyleAppearance
:
:
Listbox
:
{
SInt32
frameOutset
=
0
;
:
:
GetThemeMetric
(
kThemeMetricListBoxFrameOutset
&
frameOutset
)
;
result
.
SizeTo
(
frameOutset
frameOutset
frameOutset
frameOutset
)
;
break
;
}
case
StyleAppearance
:
:
ScrollbartrackHorizontal
:
case
StyleAppearance
:
:
ScrollbartrackVertical
:
{
bool
isHorizontal
=
(
aAppearance
=
=
StyleAppearance
:
:
ScrollbartrackHorizontal
)
;
if
(
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
)
{
if
(
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
if
(
isHorizontal
)
{
result
.
top
=
2
;
result
.
bottom
=
1
;
}
else
{
result
.
left
=
2
;
result
.
right
=
1
;
}
}
if
(
isHorizontal
)
{
result
.
left
=
1
;
result
.
right
=
1
;
}
else
{
result
.
top
=
1
;
result
.
bottom
=
1
;
}
}
break
;
}
case
StyleAppearance
:
:
Statusbar
:
result
.
SizeTo
(
1
0
0
0
)
;
break
;
default
:
break
;
}
if
(
IsHiDPIContext
(
aContext
)
)
{
result
=
result
+
result
;
}
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
result
)
;
}
bool
nsNativeThemeCocoa
:
:
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
aResult
-
>
SizeTo
(
0
0
0
0
)
;
return
true
;
case
StyleAppearance
:
:
Menuarrow
:
case
StyleAppearance
:
:
Searchfield
:
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
return
true
;
}
break
;
default
:
break
;
}
return
false
;
}
bool
nsNativeThemeCocoa
:
:
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
{
nsIntMargin
overflow
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
Toolbarbutton
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Searchfield
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
FocusOutline
:
{
overflow
.
SizeTo
(
kMaxFocusRingWidth
kMaxFocusRingWidth
kMaxFocusRingWidth
kMaxFocusRingWidth
)
;
break
;
}
case
StyleAppearance
:
:
ProgressBar
:
{
overflow
.
bottom
=
2
;
break
;
}
case
StyleAppearance
:
:
Meter
:
{
overflow
.
SizeTo
(
2
2
2
2
)
;
break
;
}
default
:
break
;
}
if
(
IsHiDPIContext
(
aContext
)
)
{
overflow
+
=
overflow
;
}
if
(
overflow
!
=
nsIntMargin
(
)
)
{
int32_t
p2a
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aOverflowRect
-
>
Inflate
(
nsMargin
(
NSIntPixelsToAppUnits
(
overflow
.
top
p2a
)
NSIntPixelsToAppUnits
(
overflow
.
right
p2a
)
NSIntPixelsToAppUnits
(
overflow
.
bottom
p2a
)
NSIntPixelsToAppUnits
(
overflow
.
left
p2a
)
)
)
;
return
true
;
}
return
false
;
}
static
const
int32_t
kRegularScrollbarThumbMinSize
=
26
;
static
const
int32_t
kSmallScrollbarThumbMinSize
=
26
;
NS_IMETHODIMP
nsNativeThemeCocoa
:
:
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntSize
*
aResult
bool
*
aIsOverridable
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
aResult
-
>
SizeTo
(
0
0
)
;
*
aIsOverridable
=
true
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
aResult
-
>
SizeTo
(
pushButtonSettings
.
minimumSizes
[
miniControlSize
]
.
width
pushButtonSettings
.
naturalSizes
[
miniControlSize
]
.
height
)
;
break
;
}
case
StyleAppearance
:
:
ButtonArrowUp
:
case
StyleAppearance
:
:
ButtonArrowDown
:
{
aResult
-
>
SizeTo
(
kMenuScrollArrowSize
.
width
kMenuScrollArrowSize
.
height
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
Menuarrow
:
{
aResult
-
>
SizeTo
(
kMenuarrowSize
.
width
kMenuarrowSize
.
height
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
{
aResult
-
>
SizeTo
(
kDisclosureButtonSize
.
width
kDisclosureButtonSize
.
height
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
MozMacHelpButton
:
{
aResult
-
>
SizeTo
(
kHelpButtonSize
.
width
kHelpButtonSize
.
height
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
Toolbarbutton
:
{
aResult
-
>
SizeTo
(
0
toolbarButtonHeights
[
miniControlSize
]
)
;
break
;
}
case
StyleAppearance
:
:
Spinner
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
{
SInt32
buttonHeight
=
0
buttonWidth
=
0
;
if
(
aFrame
-
>
GetContent
(
)
-
>
IsXULElement
(
)
)
{
:
:
GetThemeMetric
(
kThemeMetricLittleArrowsWidth
&
buttonWidth
)
;
:
:
GetThemeMetric
(
kThemeMetricLittleArrowsHeight
&
buttonHeight
)
;
}
else
{
NSSize
size
=
spinnerSettings
.
minimumSizes
[
EnumSizeForCocoaSize
(
NSMiniControlSize
)
]
;
buttonWidth
=
size
.
width
;
buttonHeight
=
size
.
height
;
if
(
aAppearance
!
=
StyleAppearance
:
:
Spinner
)
{
buttonHeight
/
=
2
;
}
}
aResult
-
>
SizeTo
(
buttonWidth
buttonHeight
)
;
*
aIsOverridable
=
true
;
break
;
}
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
{
SInt32
popupHeight
=
0
;
:
:
GetThemeMetric
(
kThemeMetricPopupButtonHeight
&
popupHeight
)
;
aResult
-
>
SizeTo
(
0
popupHeight
)
;
break
;
}
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Searchfield
:
{
aResult
-
>
SizeTo
(
0
(
2
+
2
)
+
9
+
(
1
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
MozWindowButtonBox
:
{
NSSize
size
=
WindowButtonsSize
(
aFrame
)
;
aResult
-
>
SizeTo
(
size
.
width
size
.
height
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
MozMacFullscreenButton
:
{
if
(
[
NativeWindowForFrame
(
aFrame
)
respondsToSelector
:
selector
(
toggleFullScreen
:
)
]
&
&
!
nsCocoaFeatures
:
:
OnYosemiteOrLater
(
)
)
{
aResult
-
>
SizeTo
(
16
17
)
;
}
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
ProgressBar
:
{
SInt32
barHeight
=
0
;
:
:
GetThemeMetric
(
kThemeMetricNormalProgressBarThickness
&
barHeight
)
;
aResult
-
>
SizeTo
(
0
barHeight
)
;
break
;
}
case
StyleAppearance
:
:
Separator
:
{
aResult
-
>
SizeTo
(
1
1
)
;
break
;
}
case
StyleAppearance
:
:
Treetwisty
:
case
StyleAppearance
:
:
Treetwistyopen
:
{
SInt32
twistyHeight
=
0
twistyWidth
=
0
;
:
:
GetThemeMetric
(
kThemeMetricDisclosureButtonWidth
&
twistyWidth
)
;
:
:
GetThemeMetric
(
kThemeMetricDisclosureButtonHeight
&
twistyHeight
)
;
aResult
-
>
SizeTo
(
twistyWidth
twistyHeight
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
Treeheader
:
case
StyleAppearance
:
:
Treeheadercell
:
{
SInt32
headerHeight
=
0
;
:
:
GetThemeMetric
(
kThemeMetricListHeaderHeight
&
headerHeight
)
;
aResult
-
>
SizeTo
(
0
headerHeight
-
1
)
;
break
;
}
case
StyleAppearance
:
:
Tab
:
{
aResult
-
>
SizeTo
(
0
tabHeights
[
miniControlSize
]
)
;
break
;
}
case
StyleAppearance
:
:
RangeThumb
:
{
SInt32
width
=
0
;
SInt32
height
=
0
;
:
:
GetThemeMetric
(
kThemeMetricSliderMinThumbWidth
&
width
)
;
:
:
GetThemeMetric
(
kThemeMetricSliderMinThumbHeight
&
height
)
;
aResult
-
>
SizeTo
(
width
height
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
{
bool
isSmall
=
IsSmallScrollbar
(
aFrame
)
;
bool
isHorizontal
=
(
aAppearance
=
=
StyleAppearance
:
:
ScrollbarthumbHorizontal
)
;
int32_t
&
minSize
=
isHorizontal
?
aResult
-
>
width
:
aResult
-
>
height
;
minSize
=
isSmall
?
kSmallScrollbarThumbMinSize
:
kRegularScrollbarThumbMinSize
;
break
;
}
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
ScrollbartrackVertical
:
case
StyleAppearance
:
:
ScrollbartrackHorizontal
:
{
*
aIsOverridable
=
false
;
if
(
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
)
{
if
(
IsSmallScrollbar
(
aFrame
)
)
{
aResult
-
>
SizeTo
(
14
14
)
;
}
else
{
aResult
-
>
SizeTo
(
16
16
)
;
}
}
else
{
if
(
IsSmallScrollbar
(
aFrame
)
)
{
aResult
-
>
SizeTo
(
11
11
)
;
}
else
{
aResult
-
>
SizeTo
(
15
15
)
;
}
}
break
;
}
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
ScrollbarNonDisappearing
:
{
int32_t
themeMetric
=
kThemeMetricScrollBarWidth
;
SInt32
scrollbarWidth
=
0
;
:
:
GetThemeMetric
(
themeMetric
&
scrollbarWidth
)
;
aResult
-
>
SizeTo
(
scrollbarWidth
scrollbarWidth
)
;
break
;
}
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
{
int32_t
themeMetric
=
IsSmallScrollbar
(
aFrame
)
?
kThemeMetricSmallScrollBarWidth
:
kThemeMetricScrollBarWidth
;
SInt32
scrollbarWidth
=
0
;
:
:
GetThemeMetric
(
themeMetric
&
scrollbarWidth
)
;
if
(
aAppearance
=
=
StyleAppearance
:
:
ScrollbarbuttonLeft
|
|
aAppearance
=
=
StyleAppearance
:
:
ScrollbarbuttonRight
)
aResult
-
>
SizeTo
(
scrollbarWidth
+
1
scrollbarWidth
)
;
else
aResult
-
>
SizeTo
(
scrollbarWidth
scrollbarWidth
+
1
)
;
*
aIsOverridable
=
false
;
break
;
}
case
StyleAppearance
:
:
Resizer
:
{
HIThemeGrowBoxDrawInfo
drawInfo
;
drawInfo
.
version
=
0
;
drawInfo
.
state
=
kThemeStateActive
;
drawInfo
.
kind
=
kHIThemeGrowBoxKindNormal
;
drawInfo
.
direction
=
kThemeGrowRight
|
kThemeGrowDown
;
drawInfo
.
size
=
kHIThemeGrowBoxSizeNormal
;
HIPoint
pnt
=
{
0
0
}
;
HIRect
bounds
;
HIThemeGetGrowBoxBounds
(
&
pnt
&
drawInfo
&
bounds
)
;
aResult
-
>
SizeTo
(
bounds
.
size
.
width
bounds
.
size
.
height
)
;
*
aIsOverridable
=
false
;
}
default
:
break
;
}
if
(
IsHiDPIContext
(
aPresContext
-
>
DeviceContext
(
)
)
)
{
*
aResult
=
*
aResult
*
2
;
}
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
NS_IMETHODIMP
nsNativeThemeCocoa
:
:
WidgetStateChanged
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsAtom
*
aAttribute
bool
*
aShouldRepaint
const
nsAttrValue
*
aOldValue
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
Toolbox
:
case
StyleAppearance
:
:
Toolbar
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
Statusbarpanel
:
case
StyleAppearance
:
:
Resizerpanel
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Tabpanel
:
case
StyleAppearance
:
:
Dialog
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Meterchunk
:
case
StyleAppearance
:
:
MozMacVibrancyLight
:
case
StyleAppearance
:
:
MozMacVibrancyDark
:
case
StyleAppearance
:
:
MozMacVibrantTitlebarLight
:
case
StyleAppearance
:
:
MozMacVibrantTitlebarDark
:
*
aShouldRepaint
=
false
;
return
NS_OK
;
default
:
break
;
}
if
(
!
aAttribute
)
{
*
aShouldRepaint
=
true
;
}
else
{
*
aShouldRepaint
=
false
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
|
|
aAttribute
=
=
nsGkAtoms
:
:
checked
|
|
aAttribute
=
=
nsGkAtoms
:
:
selected
|
|
aAttribute
=
=
nsGkAtoms
:
:
visuallyselected
|
|
aAttribute
=
=
nsGkAtoms
:
:
menuactive
|
|
aAttribute
=
=
nsGkAtoms
:
:
sortDirection
|
|
aAttribute
=
=
nsGkAtoms
:
:
focused
|
|
aAttribute
=
=
nsGkAtoms
:
:
_default
|
|
aAttribute
=
=
nsGkAtoms
:
:
open
|
|
aAttribute
=
=
nsGkAtoms
:
:
hover
)
*
aShouldRepaint
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsNativeThemeCocoa
:
:
ThemeChanged
(
)
{
return
NS_OK
;
}
bool
nsNativeThemeCocoa
:
:
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
aAppearance
=
=
StyleAppearance
:
:
MozMenulistArrowButton
)
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
parentFrame
&
&
parentFrame
-
>
IsComboboxControlFrame
(
)
)
return
false
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
MenulistText
:
if
(
aFrame
&
&
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
return
false
;
}
[
[
fallthrough
]
]
;
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Dialog
:
case
StyleAppearance
:
:
Window
:
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Menuarrow
:
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Menuseparator
:
case
StyleAppearance
:
:
MozMacFullscreenButton
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
CheckboxContainer
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
RadioContainer
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
ButtonArrowUp
:
case
StyleAppearance
:
:
ButtonArrowDown
:
case
StyleAppearance
:
:
Toolbarbutton
:
case
StyleAppearance
:
:
Spinner
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
case
StyleAppearance
:
:
Toolbar
:
case
StyleAppearance
:
:
Statusbar
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Searchfield
:
case
StyleAppearance
:
:
Toolbox
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Meterchunk
:
case
StyleAppearance
:
:
Separator
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
Tab
:
case
StyleAppearance
:
:
Treetwisty
:
case
StyleAppearance
:
:
Treetwistyopen
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Treeheader
:
case
StyleAppearance
:
:
Treeheadercell
:
case
StyleAppearance
:
:
Treeheadersortarrow
:
case
StyleAppearance
:
:
Treeitem
:
case
StyleAppearance
:
:
Treeline
:
case
StyleAppearance
:
:
MozMacSourceList
:
case
StyleAppearance
:
:
MozMacSourceListSelection
:
case
StyleAppearance
:
:
MozMacActiveSourceListSelection
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
ScrollbarbuttonUp
:
case
StyleAppearance
:
:
ScrollbarbuttonDown
:
case
StyleAppearance
:
:
ScrollbarbuttonLeft
:
case
StyleAppearance
:
:
ScrollbarbuttonRight
:
case
StyleAppearance
:
:
ScrollbarthumbHorizontal
:
case
StyleAppearance
:
:
ScrollbarthumbVertical
:
case
StyleAppearance
:
:
ScrollbartrackVertical
:
case
StyleAppearance
:
:
ScrollbartrackHorizontal
:
case
StyleAppearance
:
:
ScrollbarNonDisappearing
:
return
!
IsWidgetStyled
(
aPresContext
aFrame
aAppearance
)
;
case
StyleAppearance
:
:
Scrollcorner
:
return
true
;
case
StyleAppearance
:
:
Resizer
:
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
|
|
!
parentFrame
-
>
IsScrollFrame
(
)
)
return
true
;
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
parentFrame
)
;
return
(
!
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
&
&
scrollFrame
&
&
scrollFrame
-
>
GetScrollbarVisibility
(
)
)
;
}
case
StyleAppearance
:
:
FocusOutline
:
return
true
;
case
StyleAppearance
:
:
MozMacVibrancyLight
:
case
StyleAppearance
:
:
MozMacVibrancyDark
:
case
StyleAppearance
:
:
MozMacVibrantTitlebarLight
:
case
StyleAppearance
:
:
MozMacVibrantTitlebarDark
:
return
VibrancyManager
:
:
SystemSupportsVibrancy
(
)
;
default
:
break
;
}
return
false
;
}
bool
nsNativeThemeCocoa
:
:
WidgetIsContainer
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
return
false
;
default
:
break
;
}
return
true
;
}
bool
nsNativeThemeCocoa
:
:
ThemeDrawsFocusForWidget
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Searchfield
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MenulistButton
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
Checkbox
:
return
true
;
default
:
return
false
;
}
}
bool
nsNativeThemeCocoa
:
:
ThemeNeedsComboboxDropmarker
(
)
{
return
false
;
}
bool
nsNativeThemeCocoa
:
:
WidgetAppearanceDependsOnWindowFocus
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Dialog
:
case
StyleAppearance
:
:
Groupbox
:
case
StyleAppearance
:
:
Tabpanels
:
case
StyleAppearance
:
:
ButtonArrowUp
:
case
StyleAppearance
:
:
ButtonArrowDown
:
case
StyleAppearance
:
:
Checkmenuitem
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Menuarrow
:
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Menuseparator
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Spinner
:
case
StyleAppearance
:
:
SpinnerUpbutton
:
case
StyleAppearance
:
:
SpinnerDownbutton
:
case
StyleAppearance
:
:
Separator
:
case
StyleAppearance
:
:
Toolbox
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Treeview
:
case
StyleAppearance
:
:
Treeline
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Listbox
:
case
StyleAppearance
:
:
Resizer
:
return
false
;
default
:
return
true
;
}
}
bool
nsNativeThemeCocoa
:
:
IsWindowSheet
(
nsIFrame
*
aFrame
)
{
NSWindow
*
win
=
NativeWindowForFrame
(
aFrame
)
;
id
winDelegate
=
[
win
delegate
]
;
nsIWidget
*
widget
=
[
(
WindowDelegate
*
)
winDelegate
geckoWidget
]
;
if
(
!
widget
)
{
return
false
;
}
return
(
widget
-
>
WindowType
(
)
=
=
eWindowType_sheet
)
;
}
nsITheme
:
:
ThemeGeometryType
nsNativeThemeCocoa
:
:
ThemeGeometryTypeForWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozWindowTitlebar
:
return
eThemeGeometryTypeTitlebar
;
case
StyleAppearance
:
:
Toolbar
:
return
eThemeGeometryTypeToolbar
;
case
StyleAppearance
:
:
Toolbox
:
return
eThemeGeometryTypeToolbox
;
case
StyleAppearance
:
:
MozWindowButtonBox
:
return
eThemeGeometryTypeWindowButtons
;
case
StyleAppearance
:
:
MozMacFullscreenButton
:
return
eThemeGeometryTypeFullscreenButton
;
case
StyleAppearance
:
:
MozMacVibrancyLight
:
return
eThemeGeometryTypeVibrancyLight
;
case
StyleAppearance
:
:
MozMacVibrancyDark
:
return
eThemeGeometryTypeVibrancyDark
;
case
StyleAppearance
:
:
MozMacVibrantTitlebarLight
:
return
eThemeGeometryTypeVibrantTitlebarLight
;
case
StyleAppearance
:
:
MozMacVibrantTitlebarDark
:
return
eThemeGeometryTypeVibrantTitlebarDark
;
case
StyleAppearance
:
:
Tooltip
:
return
eThemeGeometryTypeTooltip
;
case
StyleAppearance
:
:
Menupopup
:
return
eThemeGeometryTypeMenu
;
case
StyleAppearance
:
:
Menuitem
:
case
StyleAppearance
:
:
Checkmenuitem
:
{
EventStates
eventState
=
GetContentState
(
aFrame
aAppearance
)
;
bool
isDisabled
=
IsDisabled
(
aFrame
eventState
)
;
bool
isSelected
=
!
isDisabled
&
&
CheckBooleanAttr
(
aFrame
nsGkAtoms
:
:
menuactive
)
;
return
isSelected
?
eThemeGeometryTypeHighlightedMenuItem
:
eThemeGeometryTypeMenu
;
}
case
StyleAppearance
:
:
Dialog
:
return
IsWindowSheet
(
aFrame
)
?
eThemeGeometryTypeSheet
:
eThemeGeometryTypeUnknown
;
case
StyleAppearance
:
:
MozMacSourceList
:
return
eThemeGeometryTypeSourceList
;
case
StyleAppearance
:
:
MozMacSourceListSelection
:
return
IsInSourceList
(
aFrame
)
?
eThemeGeometryTypeSourceListSelection
:
eThemeGeometryTypeUnknown
;
case
StyleAppearance
:
:
MozMacActiveSourceListSelection
:
return
IsInSourceList
(
aFrame
)
?
eThemeGeometryTypeActiveSourceListSelection
:
eThemeGeometryTypeUnknown
;
default
:
return
eThemeGeometryTypeUnknown
;
}
}
nsITheme
:
:
Transparency
nsNativeThemeCocoa
:
:
GetWidgetTransparency
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Dialog
:
return
eTransparent
;
case
StyleAppearance
:
:
ScrollbarSmall
:
case
StyleAppearance
:
:
Scrollbar
:
case
StyleAppearance
:
:
Scrollcorner
:
{
if
(
nsLookAndFeel
:
:
UseOverlayScrollbars
(
)
)
{
return
eTransparent
;
}
const
nsStyleUI
*
ui
=
nsLayoutUtils
:
:
StyleForScrollbar
(
aFrame
)
-
>
StyleUI
(
)
;
if
(
!
ui
-
>
mScrollbarColor
.
IsAuto
(
)
&
&
ui
-
>
mScrollbarColor
.
AsColors
(
)
.
track
.
MaybeTransparent
(
)
)
{
return
eTransparent
;
}
return
eOpaque
;
}
case
StyleAppearance
:
:
Statusbar
:
return
eOpaque
;
case
StyleAppearance
:
:
Toolbar
:
return
eOpaque
;
default
:
return
eUnknownTransparency
;
}
}
already_AddRefed
<
nsITheme
>
do_GetNativeThemeDoNotUseDirectly
(
)
{
static
nsCOMPtr
<
nsITheme
>
inst
;
if
(
!
inst
)
{
inst
=
new
nsNativeThemeCocoa
(
)
;
ClearOnShutdown
(
&
inst
)
;
}
return
do_AddRef
(
inst
)
;
}
