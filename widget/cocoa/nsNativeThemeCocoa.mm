#
include
"
nsNativeThemeCocoa
.
h
"
#
include
<
objc
/
NSObjCRuntime
.
h
>
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsNumberControlFrame
.
h
"
#
include
"
nsRangeFrame
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaWindow
.
h
"
#
include
"
nsNativeThemeColors
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMeterElement
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
nsLookAndFeel
.
h
"
#
include
"
MacThemeGeometryType
.
h
"
#
include
"
VibrancyManager
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
gfxQuartzNativeDrawing
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
mozilla
:
:
dom
:
:
HTMLMeterElement
;
#
define
DRAW_IN_FRAME_DEBUG
0
#
define
SCROLLBARS_VISUAL_DEBUG
0
extern
"
C
"
{
CG_EXTERN
void
CGContextSetCTM
(
CGContextRef
CGAffineTransform
)
;
CG_EXTERN
void
CGContextSetBaseCTM
(
CGContextRef
CGAffineTransform
)
;
typedef
CFTypeRef
CUIRendererRef
;
void
CUIDraw
(
CUIRendererRef
r
CGRect
rect
CGContextRef
ctx
CFDictionaryRef
options
CFDictionaryRef
*
result
)
;
}
implementation
NSCell
(
ControlTintWorkaround
)
-
(
int
)
_realControlTint
{
return
[
self
controlTint
]
;
}
end
interface
MOZCellDrawWindow
:
NSWindow
property
BOOL
cellsShouldLookActive
;
end
implementation
MOZCellDrawWindow
-
(
BOOL
)
_hasActiveAppearance
{
return
self
.
cellsShouldLookActive
;
}
-
(
BOOL
)
hasKeyAppearance
{
return
self
.
cellsShouldLookActive
;
}
-
(
BOOL
)
_hasKeyAppearance
{
return
self
.
cellsShouldLookActive
;
}
end
interface
MOZCellDrawView
:
NSControl
property
BOOL
_drawingEndSeparator
;
end
implementation
MOZCellDrawView
-
(
BOOL
)
isFlipped
{
return
YES
;
}
-
(
NSText
*
)
currentEditor
{
return
nil
;
}
end
static
void
DrawFocusRingForCellIfNeeded
(
NSCell
*
aCell
NSRect
aWithFrame
NSView
*
aInView
)
{
if
(
[
aCell
showsFirstResponder
]
)
{
CGContextRef
cgContext
=
[
[
NSGraphicsContext
currentContext
]
CGContext
]
;
CGContextSaveGState
(
cgContext
)
;
NSSetFocusRingStyle
(
NSFocusRingOnly
)
;
CGContextBeginTransparencyLayerWithRect
(
cgContext
NSRectToCGRect
(
aWithFrame
)
0
)
;
[
aCell
drawFocusRingMaskWithFrame
:
aWithFrame
inView
:
aInView
]
;
CGContextEndTransparencyLayer
(
cgContext
)
;
CGContextRestoreGState
(
cgContext
)
;
}
}
static
void
DrawCellIncludingFocusRing
(
NSCell
*
aCell
NSRect
aWithFrame
NSView
*
aInView
)
{
[
aCell
drawWithFrame
:
aWithFrame
inView
:
aInView
]
;
DrawFocusRingForCellIfNeeded
(
aCell
aWithFrame
aInView
)
;
}
interface
NSProgressBarCell
:
NSCell
{
double
mValue
;
double
mMax
;
bool
mIsIndeterminate
;
bool
mIsHorizontal
;
}
-
(
void
)
setValue
:
(
double
)
value
;
-
(
double
)
value
;
-
(
void
)
setMax
:
(
double
)
max
;
-
(
double
)
max
;
-
(
void
)
setIndeterminate
:
(
bool
)
aIndeterminate
;
-
(
bool
)
isIndeterminate
;
-
(
void
)
setHorizontal
:
(
bool
)
aIsHorizontal
;
-
(
bool
)
isHorizontal
;
-
(
void
)
drawWithFrame
:
(
NSRect
)
cellFrame
inView
:
(
NSView
*
)
controlView
;
end
implementation
NSProgressBarCell
-
(
void
)
setMax
:
(
double
)
aMax
{
mMax
=
aMax
;
}
-
(
double
)
max
{
return
mMax
;
}
-
(
void
)
setValue
:
(
double
)
aValue
{
mValue
=
aValue
;
}
-
(
double
)
value
{
return
mValue
;
}
-
(
void
)
setIndeterminate
:
(
bool
)
aIndeterminate
{
mIsIndeterminate
=
aIndeterminate
;
}
-
(
bool
)
isIndeterminate
{
return
mIsIndeterminate
;
}
-
(
void
)
setHorizontal
:
(
bool
)
aIsHorizontal
{
mIsHorizontal
=
aIsHorizontal
;
}
-
(
bool
)
isHorizontal
{
return
mIsHorizontal
;
}
-
(
void
)
drawWithFrame
:
(
NSRect
)
cellFrame
inView
:
(
NSView
*
)
controlView
{
CGContext
*
cgContext
=
[
[
NSGraphicsContext
currentContext
]
CGContext
]
;
HIThemeTrackDrawInfo
tdi
;
tdi
.
version
=
0
;
tdi
.
min
=
0
;
tdi
.
value
=
INT32_MAX
*
(
mValue
/
mMax
)
;
tdi
.
max
=
INT32_MAX
;
tdi
.
bounds
=
NSRectToCGRect
(
cellFrame
)
;
tdi
.
attributes
=
mIsHorizontal
?
kThemeTrackHorizontal
:
0
;
tdi
.
enableState
=
[
self
controlTint
]
=
=
NSClearControlTint
?
kThemeTrackInactive
:
kThemeTrackActive
;
NSControlSize
size
=
[
self
controlSize
]
;
if
(
size
=
=
NSControlSizeRegular
)
{
tdi
.
kind
=
mIsIndeterminate
?
kThemeLargeIndeterminateBar
:
kThemeLargeProgressBar
;
}
else
{
NS_ASSERTION
(
size
=
=
NSControlSizeSmall
"
We
shouldn
'
t
have
another
size
than
small
and
regular
for
the
moment
"
)
;
tdi
.
kind
=
mIsIndeterminate
?
kThemeMediumIndeterminateBar
:
kThemeMediumProgressBar
;
}
int32_t
stepsPerSecond
=
mIsIndeterminate
?
60
:
30
;
int32_t
milliSecondsPerStep
=
1000
/
stepsPerSecond
;
tdi
.
trackInfo
.
progress
.
phase
=
uint8_t
(
PR_IntervalToMilliseconds
(
PR_IntervalNow
(
)
)
/
milliSecondsPerStep
)
;
HIThemeDrawTrack
(
&
tdi
NULL
cgContext
kHIThemeOrientationNormal
)
;
}
end
#
define
HITHEME_ORIENTATION
kHIThemeOrientationNormal
static
constexpr
CGFloat
kMaxFocusRingWidth
=
7
;
enum
class
CocoaSize
{
Mini
=
0
Small
Regular
}
;
static
constexpr
size_t
kControlSizeCount
=
3
;
template
<
typename
T
>
using
PerSizeArray
=
EnumeratedArray
<
CocoaSize
T
kControlSizeCount
>
;
static
CocoaSize
EnumSizeForCocoaSize
(
NSControlSize
cocoaControlSize
)
{
switch
(
cocoaControlSize
)
{
case
NSControlSizeMini
:
return
CocoaSize
:
:
Mini
;
case
NSControlSizeSmall
:
return
CocoaSize
:
:
Small
;
default
:
return
CocoaSize
:
:
Regular
;
}
}
static
NSControlSize
ControlSizeForEnum
(
CocoaSize
enumControlSize
)
{
switch
(
enumControlSize
)
{
case
CocoaSize
:
:
Mini
:
return
NSControlSizeMini
;
case
CocoaSize
:
:
Small
:
return
NSControlSizeSmall
;
case
CocoaSize
:
:
Regular
:
return
NSControlSizeRegular
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
enum
"
)
;
return
NSControlSizeRegular
;
}
using
CellMarginArray
=
PerSizeArray
<
IntMargin
>
;
static
void
InflateControlRect
(
NSRect
*
rect
NSControlSize
cocoaControlSize
const
CellMarginArray
&
marginSet
)
{
auto
controlSize
=
EnumSizeForCocoaSize
(
cocoaControlSize
)
;
const
IntMargin
&
buttonMargins
=
marginSet
[
controlSize
]
;
rect
-
>
origin
.
x
-
=
buttonMargins
.
left
;
rect
-
>
origin
.
y
-
=
buttonMargins
.
bottom
;
rect
-
>
size
.
width
+
=
buttonMargins
.
LeftRight
(
)
;
rect
-
>
size
.
height
+
=
buttonMargins
.
TopBottom
(
)
;
}
static
NSWindow
*
NativeWindowForFrame
(
nsIFrame
*
aFrame
nsIWidget
*
*
aTopLevelWidget
=
NULL
)
{
if
(
!
aFrame
)
return
nil
;
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
)
;
if
(
!
widget
)
return
nil
;
nsIWidget
*
topLevelWidget
=
widget
-
>
GetTopLevelWidget
(
)
;
if
(
aTopLevelWidget
)
*
aTopLevelWidget
=
topLevelWidget
;
return
(
NSWindow
*
)
topLevelWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
}
static
NSSize
WindowButtonsSize
(
nsIFrame
*
aFrame
)
{
NSWindow
*
window
=
NativeWindowForFrame
(
aFrame
)
;
if
(
!
window
)
{
return
NSSize
{
54
16
}
;
}
NSRect
buttonBox
=
NSZeroRect
;
NSButton
*
closeButton
=
[
window
standardWindowButton
:
NSWindowCloseButton
]
;
if
(
closeButton
)
{
buttonBox
=
NSUnionRect
(
buttonBox
[
closeButton
frame
]
)
;
}
NSButton
*
minimizeButton
=
[
window
standardWindowButton
:
NSWindowMiniaturizeButton
]
;
if
(
minimizeButton
)
{
buttonBox
=
NSUnionRect
(
buttonBox
[
minimizeButton
frame
]
)
;
}
NSButton
*
zoomButton
=
[
window
standardWindowButton
:
NSWindowZoomButton
]
;
if
(
zoomButton
)
{
buttonBox
=
NSUnionRect
(
buttonBox
[
zoomButton
frame
]
)
;
}
return
buttonBox
.
size
;
}
static
BOOL
FrameIsInActiveWindow
(
nsIFrame
*
aFrame
)
{
nsIWidget
*
topLevelWidget
=
NULL
;
NSWindow
*
win
=
NativeWindowForFrame
(
aFrame
&
topLevelWidget
)
;
if
(
!
topLevelWidget
|
|
!
win
)
return
YES
;
if
(
topLevelWidget
-
>
GetWindowType
(
)
=
=
widget
:
:
WindowType
:
:
Popup
)
{
return
YES
;
}
if
(
[
win
isSheet
]
)
{
return
[
win
isKeyWindow
]
;
}
return
[
win
isMainWindow
]
&
&
!
[
win
attachedSheet
]
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsNativeThemeCocoa
nsNativeTheme
nsITheme
)
nsNativeThemeCocoa
:
:
nsNativeThemeCocoa
(
)
:
ThemeCocoa
(
ScrollbarStyle
(
)
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsAutoreleasePool
pool
;
mDisclosureButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mDisclosureButtonCell
setBezelStyle
:
NSBezelStyleRoundedDisclosure
]
;
[
mDisclosureButtonCell
setButtonType
:
NSButtonTypePushOnPushOff
]
;
[
mDisclosureButtonCell
setHighlightsBy
:
NSPushInCellMask
]
;
mHelpButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mHelpButtonCell
setBezelStyle
:
NSBezelStyleHelpButton
]
;
[
mHelpButtonCell
setButtonType
:
NSButtonTypeMomentaryPushIn
]
;
[
mHelpButtonCell
setHighlightsBy
:
NSPushInCellMask
]
;
mPushButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mPushButtonCell
setButtonType
:
NSButtonTypeMomentaryPushIn
]
;
[
mPushButtonCell
setHighlightsBy
:
NSPushInCellMask
]
;
mRadioButtonCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mRadioButtonCell
setButtonType
:
NSButtonTypeRadio
]
;
mCheckboxCell
=
[
[
NSButtonCell
alloc
]
initTextCell
:
"
"
]
;
[
mCheckboxCell
setButtonType
:
NSButtonTypeSwitch
]
;
[
mCheckboxCell
setAllowsMixedState
:
YES
]
;
mTextFieldCell
=
[
[
NSTextFieldCell
alloc
]
initTextCell
:
"
"
]
;
[
mTextFieldCell
setBezeled
:
YES
]
;
[
mTextFieldCell
setEditable
:
YES
]
;
[
mTextFieldCell
setFocusRingType
:
NSFocusRingTypeExterior
]
;
mDropdownCell
=
[
[
NSPopUpButtonCell
alloc
]
initTextCell
:
"
"
pullsDown
:
NO
]
;
mComboBoxCell
=
[
[
NSComboBoxCell
alloc
]
initTextCell
:
"
"
]
;
[
mComboBoxCell
setBezeled
:
YES
]
;
[
mComboBoxCell
setEditable
:
YES
]
;
[
mComboBoxCell
setFocusRingType
:
NSFocusRingTypeExterior
]
;
mProgressBarCell
=
[
[
NSProgressBarCell
alloc
]
init
]
;
mMeterBarCell
=
[
[
NSLevelIndicatorCell
alloc
]
initWithLevelIndicatorStyle
:
NSLevelIndicatorStyleContinuousCapacity
]
;
mCellDrawView
=
[
[
MOZCellDrawView
alloc
]
init
]
;
if
(
XRE_IsParentProcess
(
)
)
{
mCellDrawWindow
=
[
[
MOZCellDrawWindow
alloc
]
initWithContentRect
:
NSZeroRect
styleMask
:
NSWindowStyleMaskBorderless
backing
:
NSBackingStoreBuffered
defer
:
NO
]
;
[
mCellDrawWindow
.
contentView
addSubview
:
mCellDrawView
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsNativeThemeCocoa
:
:
~
nsNativeThemeCocoa
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
mMeterBarCell
release
]
;
[
mProgressBarCell
release
]
;
[
mDisclosureButtonCell
release
]
;
[
mHelpButtonCell
release
]
;
[
mPushButtonCell
release
]
;
[
mRadioButtonCell
release
]
;
[
mCheckboxCell
release
]
;
[
mTextFieldCell
release
]
;
[
mDropdownCell
release
]
;
[
mComboBoxCell
release
]
;
[
mCellDrawWindow
release
]
;
[
mCellDrawView
release
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
define
BITMAP_MAX_AREA
500000
static
int
GetBackingScaleFactorForRendering
(
CGContextRef
cgContext
)
{
CGAffineTransform
ctm
=
CGContextGetUserSpaceToDeviceSpaceTransform
(
cgContext
)
;
CGRect
transformedUserSpacePixel
=
CGRectApplyAffineTransform
(
CGRectMake
(
0
0
1
1
)
ctm
)
;
float
maxScale
=
std
:
:
max
(
fabs
(
transformedUserSpacePixel
.
size
.
width
)
fabs
(
transformedUserSpacePixel
.
size
.
height
)
)
;
return
maxScale
>
1
.
0
?
2
:
1
;
}
static
void
DrawCellWithScaling
(
NSCell
*
cell
CGContextRef
cgContext
const
HIRect
&
destRect
NSControlSize
controlSize
NSSize
naturalSize
NSSize
minimumSize
const
CellMarginArray
&
marginSet
NSView
*
view
BOOL
mirrorHorizontal
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSRect
drawRect
=
NSMakeRect
(
destRect
.
origin
.
x
destRect
.
origin
.
y
destRect
.
size
.
width
destRect
.
size
.
height
)
;
if
(
naturalSize
.
width
!
=
0
.
0f
)
drawRect
.
size
.
width
=
naturalSize
.
width
;
if
(
naturalSize
.
height
!
=
0
.
0f
)
drawRect
.
size
.
height
=
naturalSize
.
height
;
if
(
naturalSize
.
width
=
=
0
.
0f
&
&
naturalSize
.
height
!
=
0
.
0f
)
drawRect
.
size
.
width
=
destRect
.
size
.
width
*
naturalSize
.
height
/
destRect
.
size
.
height
;
if
(
naturalSize
.
height
=
=
0
.
0f
&
&
naturalSize
.
width
!
=
0
.
0f
)
drawRect
.
size
.
height
=
destRect
.
size
.
height
*
naturalSize
.
width
/
destRect
.
size
.
width
;
if
(
drawRect
.
size
.
width
<
minimumSize
.
width
)
drawRect
.
size
.
width
=
minimumSize
.
width
;
if
(
drawRect
.
size
.
height
<
minimumSize
.
height
)
drawRect
.
size
.
height
=
minimumSize
.
height
;
[
NSGraphicsContext
saveGraphicsState
]
;
if
(
drawRect
.
size
.
width
*
drawRect
.
size
.
height
>
BITMAP_MAX_AREA
)
{
InflateControlRect
(
&
drawRect
controlSize
marginSet
)
;
NSGraphicsContext
*
savedContext
=
[
NSGraphicsContext
currentContext
]
;
[
NSGraphicsContext
setCurrentContext
:
[
NSGraphicsContext
graphicsContextWithCGContext
:
cgContext
flipped
:
YES
]
]
;
DrawCellIncludingFocusRing
(
cell
drawRect
view
)
;
[
NSGraphicsContext
setCurrentContext
:
savedContext
]
;
}
else
{
float
w
=
ceil
(
drawRect
.
size
.
width
)
;
float
h
=
ceil
(
drawRect
.
size
.
height
)
;
NSRect
tmpRect
=
NSMakeRect
(
kMaxFocusRingWidth
kMaxFocusRingWidth
w
h
)
;
InflateControlRect
(
&
tmpRect
controlSize
marginSet
)
;
w
+
=
kMaxFocusRingWidth
*
2
.
0
;
h
+
=
kMaxFocusRingWidth
*
2
.
0
;
int
backingScaleFactor
=
GetBackingScaleFactorForRendering
(
cgContext
)
;
CGColorSpaceRef
rgb
=
CGColorSpaceCreateDeviceRGB
(
)
;
CGContextRef
ctx
=
CGBitmapContextCreate
(
NULL
(
int
)
w
*
backingScaleFactor
(
int
)
h
*
backingScaleFactor
8
(
int
)
w
*
backingScaleFactor
*
4
rgb
kCGImageAlphaPremultipliedFirst
)
;
CGColorSpaceRelease
(
rgb
)
;
CGContextScaleCTM
(
cgContext
1
.
0f
-
1
.
0f
)
;
CGContextTranslateCTM
(
cgContext
0
.
0f
-
(
2
.
0
*
destRect
.
origin
.
y
+
destRect
.
size
.
height
)
)
;
if
(
mirrorHorizontal
)
{
CGContextScaleCTM
(
cgContext
-
1
.
0f
1
.
0f
)
;
CGContextTranslateCTM
(
cgContext
-
(
2
.
0
*
destRect
.
origin
.
x
+
destRect
.
size
.
width
)
0
.
0f
)
;
}
NSGraphicsContext
*
savedContext
=
[
NSGraphicsContext
currentContext
]
;
[
NSGraphicsContext
setCurrentContext
:
[
NSGraphicsContext
graphicsContextWithCGContext
:
ctx
flipped
:
YES
]
]
;
CGContextScaleCTM
(
ctx
backingScaleFactor
backingScaleFactor
)
;
CGContextSetBaseCTM
(
ctx
CGAffineTransformMakeScale
(
backingScaleFactor
backingScaleFactor
)
)
;
CGContextScaleCTM
(
ctx
1
.
0f
-
1
.
0f
)
;
CGContextTranslateCTM
(
ctx
0
.
0f
-
(
2
.
0
*
tmpRect
.
origin
.
y
+
tmpRect
.
size
.
height
)
)
;
DrawCellIncludingFocusRing
(
cell
tmpRect
view
)
;
[
NSGraphicsContext
setCurrentContext
:
savedContext
]
;
CGImageRef
img
=
CGBitmapContextCreateImage
(
ctx
)
;
float
xscale
=
destRect
.
size
.
width
/
drawRect
.
size
.
width
;
float
yscale
=
destRect
.
size
.
height
/
drawRect
.
size
.
height
;
float
scaledFocusRingX
=
xscale
<
1
.
0f
?
kMaxFocusRingWidth
*
xscale
:
kMaxFocusRingWidth
;
float
scaledFocusRingY
=
yscale
<
1
.
0f
?
kMaxFocusRingWidth
*
yscale
:
kMaxFocusRingWidth
;
CGContextDrawImage
(
cgContext
CGRectMake
(
destRect
.
origin
.
x
-
scaledFocusRingX
destRect
.
origin
.
y
-
scaledFocusRingY
destRect
.
size
.
width
+
scaledFocusRingX
*
2
destRect
.
size
.
height
+
scaledFocusRingY
*
2
)
img
)
;
CGImageRelease
(
img
)
;
CGContextRelease
(
ctx
)
;
}
[
NSGraphicsContext
restoreGraphicsState
]
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
destRect
)
;
#
endif
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
struct
CellRenderSettings
{
PerSizeArray
<
NSSize
>
naturalSizes
;
PerSizeArray
<
NSSize
>
minimumSizes
;
PerSizeArray
<
IntMargin
>
margins
;
}
;
static
NSControlSize
FindControlSize
(
CGFloat
size
const
PerSizeArray
<
CGFloat
>
&
sizes
CGFloat
tolerance
)
{
for
(
size_t
i
=
0
;
i
<
kControlSizeCount
;
+
+
i
)
{
if
(
sizes
[
CocoaSize
(
i
)
]
=
=
0
)
{
continue
;
}
CGFloat
next
=
0
;
for
(
size_t
j
=
i
+
1
;
j
<
kControlSizeCount
;
+
+
j
)
{
if
(
sizes
[
CocoaSize
(
j
)
]
!
=
0
)
{
next
=
sizes
[
CocoaSize
(
j
)
]
;
break
;
}
}
if
(
next
=
=
0
)
{
return
ControlSizeForEnum
(
CocoaSize
(
i
)
)
;
}
if
(
size
<
=
sizes
[
CocoaSize
(
i
)
]
+
tolerance
&
&
size
<
next
)
{
return
ControlSizeForEnum
(
CocoaSize
(
i
)
)
;
}
}
NS_ASSERTION
(
std
:
:
all_of
(
sizes
.
begin
(
)
sizes
.
end
(
)
[
]
(
CGFloat
s
)
{
return
s
=
=
0
;
}
)
"
We
found
no
control
!
We
shouldn
'
t
be
there
!
"
)
;
return
ControlSizeForEnum
(
CocoaSize
:
:
Regular
)
;
}
static
void
DrawCellWithSnapping
(
NSCell
*
cell
CGContextRef
cgContext
const
HIRect
&
destRect
const
CellRenderSettings
settings
float
verticalAlignFactor
NSView
*
view
BOOL
mirrorHorizontal
float
snapTolerance
=
2
.
0f
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
const
float
rectWidth
=
destRect
.
size
.
width
rectHeight
=
destRect
.
size
.
height
;
const
PerSizeArray
<
NSSize
>
&
sizes
=
settings
.
naturalSizes
;
const
NSSize
miniSize
=
sizes
[
EnumSizeForCocoaSize
(
NSControlSizeMini
)
]
;
const
NSSize
smallSize
=
sizes
[
EnumSizeForCocoaSize
(
NSControlSizeSmall
)
]
;
const
NSSize
regularSize
=
sizes
[
EnumSizeForCocoaSize
(
NSControlSizeRegular
)
]
;
HIRect
drawRect
=
destRect
;
PerSizeArray
<
CGFloat
>
controlWidths
{
miniSize
.
width
smallSize
.
width
regularSize
.
width
}
;
NSControlSize
controlSizeX
=
FindControlSize
(
rectWidth
controlWidths
snapTolerance
)
;
PerSizeArray
<
CGFloat
>
controlHeights
{
miniSize
.
height
smallSize
.
height
regularSize
.
height
}
;
NSControlSize
controlSizeY
=
FindControlSize
(
rectHeight
controlHeights
snapTolerance
)
;
NSControlSize
controlSize
=
NSControlSizeRegular
;
CocoaSize
sizeIndex
=
CocoaSize
:
:
Mini
;
const
NSControlSize
smallerControlSize
=
EnumSizeForCocoaSize
(
controlSizeX
)
<
EnumSizeForCocoaSize
(
controlSizeY
)
?
controlSizeX
:
controlSizeY
;
const
auto
smallerControlSizeIndex
=
EnumSizeForCocoaSize
(
smallerControlSize
)
;
const
NSSize
size
=
sizes
[
smallerControlSizeIndex
]
;
float
diffWidth
=
size
.
width
?
rectWidth
-
size
.
width
:
0
.
0f
;
float
diffHeight
=
size
.
height
?
rectHeight
-
size
.
height
:
0
.
0f
;
if
(
diffWidth
>
=
0
.
0f
&
&
diffHeight
>
=
0
.
0f
&
&
diffWidth
<
=
snapTolerance
&
&
diffHeight
<
=
snapTolerance
)
{
controlSize
=
smallerControlSize
;
sizeIndex
=
smallerControlSizeIndex
;
if
(
sizes
[
sizeIndex
]
.
width
)
{
drawRect
.
origin
.
x
+
=
ceil
(
(
destRect
.
size
.
width
-
sizes
[
sizeIndex
]
.
width
)
/
2
)
;
drawRect
.
size
.
width
=
sizes
[
sizeIndex
]
.
width
;
}
if
(
sizes
[
sizeIndex
]
.
height
)
{
drawRect
.
origin
.
y
+
=
floor
(
(
destRect
.
size
.
height
-
sizes
[
sizeIndex
]
.
height
)
*
verticalAlignFactor
)
;
drawRect
.
size
.
height
=
sizes
[
sizeIndex
]
.
height
;
}
}
else
{
controlSize
=
EnumSizeForCocoaSize
(
controlSizeX
)
>
EnumSizeForCocoaSize
(
controlSizeY
)
?
controlSizeX
:
controlSizeY
;
sizeIndex
=
EnumSizeForCocoaSize
(
controlSize
)
;
}
[
cell
setControlSize
:
controlSize
]
;
const
NSSize
minimumSize
=
settings
.
minimumSizes
[
sizeIndex
]
;
DrawCellWithScaling
(
cell
cgContext
drawRect
controlSize
sizes
[
sizeIndex
]
minimumSize
settings
.
margins
view
mirrorHorizontal
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
float
VerticalAlignFactor
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
return
0
.
5f
;
const
auto
&
va
=
aFrame
-
>
StyleDisplay
(
)
-
>
mVerticalAlign
;
auto
kw
=
va
.
IsKeyword
(
)
?
va
.
AsKeyword
(
)
:
StyleVerticalAlignKeyword
:
:
Middle
;
switch
(
kw
)
{
case
StyleVerticalAlignKeyword
:
:
Top
:
case
StyleVerticalAlignKeyword
:
:
TextTop
:
return
0
.
0f
;
case
StyleVerticalAlignKeyword
:
:
Sub
:
case
StyleVerticalAlignKeyword
:
:
Super
:
case
StyleVerticalAlignKeyword
:
:
Middle
:
case
StyleVerticalAlignKeyword
:
:
MozMiddleWithBaseline
:
return
0
.
5f
;
case
StyleVerticalAlignKeyword
:
:
Baseline
:
case
StyleVerticalAlignKeyword
:
:
Bottom
:
case
StyleVerticalAlignKeyword
:
:
TextBottom
:
return
1
.
0f
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
invalid
vertical
-
align
"
)
;
return
0
.
5f
;
}
}
static
void
ApplyControlParamsToNSCell
(
nsNativeThemeCocoa
:
:
ControlParams
aControlParams
NSCell
*
aCell
)
{
[
aCell
setEnabled
:
!
aControlParams
.
disabled
]
;
[
aCell
setShowsFirstResponder
:
(
aControlParams
.
focused
&
&
!
aControlParams
.
disabled
&
&
aControlParams
.
insideActiveWindow
)
]
;
[
aCell
setHighlighted
:
aControlParams
.
pressed
]
;
}
constexpr
static
CellRenderSettings
radioSettings
=
{
{
NSSize
{
11
11
}
NSSize
{
13
13
}
NSSize
{
16
16
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
1
1
1
2
}
IntMargin
{
0
0
0
0
}
}
}
;
constexpr
static
CellRenderSettings
checkboxSettings
=
{
{
NSSize
{
11
11
}
NSSize
{
13
13
}
NSSize
{
16
16
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
0
1
0
0
}
IntMargin
{
0
1
0
1
}
IntMargin
{
0
1
0
1
}
}
}
;
static
NSControlStateValue
CellStateForCheckboxOrRadioState
(
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
aState
)
{
switch
(
aState
)
{
case
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
:
:
eOff
:
return
NSControlStateValueOff
;
case
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
:
:
eOn
:
return
NSControlStateValueOn
;
case
nsNativeThemeCocoa
:
:
CheckboxOrRadioState
:
:
eIndeterminate
:
return
NSControlStateValueMixed
;
}
}
void
nsNativeThemeCocoa
:
:
DrawCheckboxOrRadio
(
CGContextRef
cgContext
bool
inCheckbox
const
HIRect
&
inBoxRect
const
CheckboxOrRadioParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSButtonCell
*
cell
=
inCheckbox
?
mCheckboxCell
:
mRadioButtonCell
;
ApplyControlParamsToNSCell
(
aParams
.
controlParams
cell
)
;
[
cell
setState
:
CellStateForCheckboxOrRadioState
(
aParams
.
state
)
]
;
[
cell
setControlTint
:
(
aParams
.
controlParams
.
insideActiveWindow
?
[
NSColor
currentControlTint
]
:
NSClearControlTint
)
]
;
float
length
=
std
:
:
min
(
inBoxRect
.
size
.
width
inBoxRect
.
size
.
height
)
;
HIRect
drawRect
=
CGRectMake
(
inBoxRect
.
origin
.
x
+
(
int
)
(
(
inBoxRect
.
size
.
width
-
length
)
/
2
.
0f
)
inBoxRect
.
origin
.
y
+
(
int
)
(
(
inBoxRect
.
size
.
height
-
length
)
/
2
.
0f
)
length
length
)
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aParams
.
controlParams
.
insideActiveWindow
;
}
DrawCellWithSnapping
(
cell
cgContext
drawRect
inCheckbox
?
checkboxSettings
:
radioSettings
aParams
.
verticalAlignFactor
mCellDrawView
NO
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
constexpr
static
CellRenderSettings
searchFieldSettings
=
{
{
NSSize
{
0
16
}
NSSize
{
0
19
}
NSSize
{
0
22
}
}
{
NSSize
{
32
0
}
NSSize
{
38
0
}
NSSize
{
44
0
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
0
0
0
0
}
IntMargin
{
0
0
0
0
}
}
}
;
static
bool
IsToolbarStyleContainer
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
false
;
}
if
(
content
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
toolbar
nsGkAtoms
:
:
toolbox
nsGkAtoms
:
:
statusbar
)
)
{
return
true
;
}
return
false
;
}
static
bool
IsInsideToolbar
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
if
(
IsToolbarStyleContainer
(
frame
)
)
{
return
true
;
}
}
return
false
;
}
nsNativeThemeCocoa
:
:
TextFieldParams
nsNativeThemeCocoa
:
:
ComputeTextFieldParams
(
nsIFrame
*
aFrame
ElementState
aEventState
)
{
TextFieldParams
params
;
params
.
insideToolbar
=
IsInsideToolbar
(
aFrame
)
;
params
.
disabled
=
aEventState
.
HasState
(
ElementState
:
:
DISABLED
)
;
params
.
focused
=
aEventState
.
HasState
(
ElementState
:
:
FOCUS
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawTextField
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
TextFieldParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSTextFieldCell
*
cell
=
mTextFieldCell
;
[
cell
setEnabled
:
!
aParams
.
disabled
]
;
[
cell
setShowsFirstResponder
:
aParams
.
focused
]
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
YES
;
}
DrawCellWithSnapping
(
cell
cgContext
inBoxRect
searchFieldSettings
aParams
.
verticalAlignFactor
mCellDrawView
aParams
.
rtl
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
bool
ShouldUnconditionallyDrawFocusRingIfFocused
(
nsIFrame
*
aFrame
)
{
switch
(
aFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
)
{
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
return
true
;
default
:
return
false
;
}
}
nsNativeThemeCocoa
:
:
ControlParams
nsNativeThemeCocoa
:
:
ComputeControlParams
(
nsIFrame
*
aFrame
ElementState
aEventState
)
{
ControlParams
params
;
params
.
disabled
=
aEventState
.
HasState
(
ElementState
:
:
DISABLED
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
pressed
=
aEventState
.
HasAllStates
(
ElementState
:
:
ACTIVE
|
ElementState
:
:
HOVER
)
;
params
.
focused
=
aEventState
.
HasState
(
ElementState
:
:
FOCUS
)
&
&
(
aEventState
.
HasState
(
ElementState
:
:
FOCUSRING
)
|
|
ShouldUnconditionallyDrawFocusRingIfFocused
(
aFrame
)
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
constexpr
static
NSSize
kHelpButtonSize
=
NSSize
{
20
20
}
;
constexpr
static
NSSize
kDisclosureButtonSize
=
NSSize
{
21
21
}
;
constexpr
static
CellRenderSettings
pushButtonSettings
=
{
{
NSSize
{
0
16
}
NSSize
{
0
19
}
NSSize
{
0
22
}
}
{
NSSize
{
18
0
}
NSSize
{
26
0
}
NSSize
{
30
0
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
4
0
4
1
}
IntMargin
{
5
0
5
2
}
}
}
;
#
define
DO_SQUARE_BUTTON_HEIGHT
26
void
nsNativeThemeCocoa
:
:
DrawPushButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ButtonType
aButtonType
ControlParams
aControlParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mPushButtonCell
)
;
[
mPushButtonCell
setBezelStyle
:
NSBezelStyleRounded
]
;
mPushButtonCell
.
keyEquivalent
=
aButtonType
=
=
ButtonType
:
:
eDefaultPushButton
?
"
\
r
"
:
"
"
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aControlParams
.
insideActiveWindow
;
}
DrawCellWithSnapping
(
mPushButtonCell
cgContext
inBoxRect
pushButtonSettings
0
.
5f
mCellDrawView
aControlParams
.
rtl
1
.
0f
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawSquareBezelPushButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mPushButtonCell
)
;
[
mPushButtonCell
setBezelStyle
:
NSBezelStyleShadowlessSquare
]
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aControlParams
.
insideActiveWindow
;
}
DrawCellWithScaling
(
mPushButtonCell
cgContext
inBoxRect
NSControlSizeRegular
NSSize
{
}
NSSize
{
14
0
}
{
}
mCellDrawView
aControlParams
.
rtl
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawHelpButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mHelpButtonCell
)
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aControlParams
.
insideActiveWindow
;
}
DrawCellWithScaling
(
mHelpButtonCell
cgContext
inBoxRect
NSControlSizeRegular
NSSize
{
}
kHelpButtonSize
{
}
mCellDrawView
false
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawDisclosureButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
ControlParams
aControlParams
NSControlStateValue
aCellState
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
ApplyControlParamsToNSCell
(
aControlParams
mDisclosureButtonCell
)
;
[
mDisclosureButtonCell
setState
:
aCellState
]
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aControlParams
.
insideActiveWindow
;
}
DrawCellWithScaling
(
mDisclosureButtonCell
cgContext
inBoxRect
NSControlSizeRegular
NSSize
{
}
kDisclosureButtonSize
{
}
mCellDrawView
false
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
typedef
void
(
*
RenderHIThemeControlFunction
)
(
CGContextRef
cgContext
const
HIRect
&
aRenderRect
void
*
aData
)
;
static
void
RenderTransformedHIThemeControl
(
CGContextRef
aCGContext
const
HIRect
&
aRect
RenderHIThemeControlFunction
aFunc
void
*
aData
BOOL
mirrorHorizontally
=
NO
)
{
CGAffineTransform
savedCTM
=
CGContextGetCTM
(
aCGContext
)
;
CGContextTranslateCTM
(
aCGContext
aRect
.
origin
.
x
aRect
.
origin
.
y
)
;
bool
drawDirect
;
HIRect
drawRect
=
aRect
;
drawRect
.
origin
=
CGPointZero
;
if
(
!
mirrorHorizontally
&
&
savedCTM
.
a
=
=
1
.
0f
&
&
savedCTM
.
b
=
=
0
.
0f
&
&
savedCTM
.
c
=
=
0
.
0f
&
&
(
savedCTM
.
d
=
=
1
.
0f
|
|
savedCTM
.
d
=
=
-
1
.
0f
)
)
{
drawDirect
=
TRUE
;
}
else
{
drawDirect
=
FALSE
;
}
if
(
drawDirect
|
|
(
aRect
.
size
.
width
*
aRect
.
size
.
height
>
BITMAP_MAX_AREA
)
)
{
aFunc
(
aCGContext
drawRect
aData
)
;
}
else
{
int
w
=
ceil
(
drawRect
.
size
.
width
)
+
2
*
kMaxFocusRingWidth
;
int
h
=
ceil
(
drawRect
.
size
.
height
)
+
2
*
kMaxFocusRingWidth
;
int
backingScaleFactor
=
GetBackingScaleFactorForRendering
(
aCGContext
)
;
CGColorSpaceRef
colorSpace
=
CGColorSpaceCreateDeviceRGB
(
)
;
CGContextRef
bitmapctx
=
CGBitmapContextCreate
(
NULL
w
*
backingScaleFactor
h
*
backingScaleFactor
8
w
*
backingScaleFactor
*
4
colorSpace
kCGImageAlphaPremultipliedFirst
)
;
CGColorSpaceRelease
(
colorSpace
)
;
CGContextScaleCTM
(
bitmapctx
backingScaleFactor
backingScaleFactor
)
;
CGContextTranslateCTM
(
bitmapctx
kMaxFocusRingWidth
kMaxFocusRingWidth
)
;
CGContextSetBaseCTM
(
bitmapctx
CGAffineTransformMakeScale
(
backingScaleFactor
backingScaleFactor
)
)
;
CGContextTranslateCTM
(
bitmapctx
0
.
0f
aRect
.
size
.
height
)
;
CGContextScaleCTM
(
bitmapctx
1
.
0f
-
1
.
0f
)
;
aFunc
(
bitmapctx
drawRect
aData
)
;
CGImageRef
bitmap
=
CGBitmapContextCreateImage
(
bitmapctx
)
;
CGAffineTransform
ctm
=
CGContextGetCTM
(
aCGContext
)
;
CGContextTranslateCTM
(
aCGContext
0
.
0f
aRect
.
size
.
height
)
;
CGContextScaleCTM
(
aCGContext
1
.
0f
-
1
.
0f
)
;
if
(
mirrorHorizontally
)
{
CGContextTranslateCTM
(
aCGContext
aRect
.
size
.
width
0
)
;
CGContextScaleCTM
(
aCGContext
-
1
.
0f
1
.
0f
)
;
}
HIRect
inflatedDrawRect
=
CGRectMake
(
-
kMaxFocusRingWidth
-
kMaxFocusRingWidth
w
h
)
;
CGContextDrawImage
(
aCGContext
inflatedDrawRect
bitmap
)
;
CGContextSetCTM
(
aCGContext
ctm
)
;
CGImageRelease
(
bitmap
)
;
CGContextRelease
(
bitmapctx
)
;
}
CGContextSetCTM
(
aCGContext
savedCTM
)
;
}
static
void
RenderButton
(
CGContextRef
cgContext
const
HIRect
&
aRenderRect
void
*
aData
)
{
HIThemeButtonDrawInfo
*
bdi
=
(
HIThemeButtonDrawInfo
*
)
aData
;
HIThemeDrawButton
(
&
aRenderRect
bdi
cgContext
kHIThemeOrientationNormal
NULL
)
;
}
void
nsNativeThemeCocoa
:
:
DrawHIThemeButton
(
CGContextRef
cgContext
const
HIRect
&
aRect
ThemeButtonKind
aKind
ThemeButtonValue
aValue
ThemeDrawState
aState
ThemeButtonAdornment
aAdornment
const
ControlParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
HIThemeButtonDrawInfo
bdi
;
bdi
.
version
=
0
;
bdi
.
kind
=
aKind
;
bdi
.
value
=
aValue
;
bdi
.
state
=
aState
;
bdi
.
adornment
=
aAdornment
;
if
(
aParams
.
focused
&
&
aParams
.
insideActiveWindow
)
{
bdi
.
adornment
|
=
kThemeAdornmentFocus
;
}
RenderTransformedHIThemeControl
(
cgContext
aRect
RenderButton
&
bdi
aParams
.
rtl
)
;
#
if
DRAW_IN_FRAME_DEBUG
CGContextSetRGBFillColor
(
cgContext
0
.
0
0
.
0
0
.
5
0
.
25
)
;
CGContextFillRect
(
cgContext
inBoxRect
)
;
#
endif
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawButton
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
ButtonParams
&
aParams
)
{
ControlParams
controlParams
=
aParams
.
controlParams
;
switch
(
aParams
.
button
)
{
case
ButtonType
:
:
eRegularPushButton
:
case
ButtonType
:
:
eDefaultPushButton
:
DrawPushButton
(
cgContext
inBoxRect
aParams
.
button
controlParams
)
;
return
;
case
ButtonType
:
:
eSquareBezelPushButton
:
DrawSquareBezelPushButton
(
cgContext
inBoxRect
controlParams
)
;
return
;
case
ButtonType
:
:
eArrowButton
:
DrawHIThemeButton
(
cgContext
inBoxRect
kThemeArrowButton
kThemeButtonOn
kThemeStateUnavailable
kThemeAdornmentArrowDownArrow
controlParams
)
;
return
;
case
ButtonType
:
:
eHelpButton
:
DrawHelpButton
(
cgContext
inBoxRect
controlParams
)
;
return
;
case
ButtonType
:
:
eDisclosureButtonClosed
:
DrawDisclosureButton
(
cgContext
inBoxRect
controlParams
NSControlStateValueOff
)
;
return
;
case
ButtonType
:
:
eDisclosureButtonOpen
:
DrawDisclosureButton
(
cgContext
inBoxRect
controlParams
NSControlStateValueOn
)
;
return
;
}
}
constexpr
static
CellRenderSettings
dropdownSettings
=
{
{
NSSize
{
0
16
}
NSSize
{
0
19
}
NSSize
{
0
22
}
}
{
NSSize
{
18
0
}
NSSize
{
38
0
}
NSSize
{
44
0
}
}
{
IntMargin
{
1
1
2
1
}
IntMargin
{
3
0
3
1
}
IntMargin
{
3
0
3
0
}
}
}
;
constexpr
static
CellRenderSettings
editableMenulistSettings
=
{
{
NSSize
{
0
15
}
NSSize
{
0
18
}
NSSize
{
0
21
}
}
{
NSSize
{
18
0
}
NSSize
{
38
0
}
NSSize
{
44
0
}
}
{
IntMargin
{
0
0
2
2
}
IntMargin
{
0
0
3
2
}
IntMargin
{
0
1
3
3
}
}
}
;
void
nsNativeThemeCocoa
:
:
DrawDropdown
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
DropdownParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
mDropdownCell
setPullsDown
:
aParams
.
pullsDown
]
;
NSCell
*
cell
=
aParams
.
editable
?
(
NSCell
*
)
mComboBoxCell
:
(
NSCell
*
)
mDropdownCell
;
ApplyControlParamsToNSCell
(
aParams
.
controlParams
cell
)
;
if
(
aParams
.
controlParams
.
insideActiveWindow
)
{
[
cell
setControlTint
:
[
NSColor
currentControlTint
]
]
;
}
else
{
[
cell
setControlTint
:
NSClearControlTint
]
;
}
const
CellRenderSettings
&
settings
=
aParams
.
editable
?
editableMenulistSettings
:
dropdownSettings
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aParams
.
controlParams
.
insideActiveWindow
;
}
DrawCellWithSnapping
(
cell
cgContext
inBoxRect
settings
0
.
5f
mCellDrawView
aParams
.
controlParams
.
rtl
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
constexpr
static
CellRenderSettings
progressSettings
[
2
]
[
2
]
=
{
{
{
{
NSSize
{
}
NSSize
{
10
0
}
NSSize
{
16
0
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
0
0
0
0
}
IntMargin
{
0
0
0
0
}
}
}
{
{
NSSize
{
}
NSSize
{
10
0
}
NSSize
{
16
0
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
1
1
1
1
}
IntMargin
{
1
0
1
0
}
}
}
}
{
{
{
NSSize
{
}
NSSize
{
0
10
}
NSSize
{
0
16
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
1
1
1
1
}
IntMargin
{
1
1
1
1
}
}
}
{
{
NSSize
{
}
NSSize
{
0
10
}
NSSize
{
0
16
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
0
0
0
0
}
IntMargin
{
1
1
1
1
}
IntMargin
{
0
1
0
1
}
}
}
}
}
;
nsNativeThemeCocoa
:
:
ProgressParams
nsNativeThemeCocoa
:
:
ComputeProgressParams
(
nsIFrame
*
aFrame
ElementState
aEventState
bool
aIsHorizontal
)
{
ProgressParams
params
;
params
.
value
=
GetProgressValue
(
aFrame
)
;
params
.
max
=
GetProgressMaxValue
(
aFrame
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
indeterminate
=
aEventState
.
HasState
(
ElementState
:
:
INDETERMINATE
)
;
params
.
horizontal
=
aIsHorizontal
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawProgress
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
ProgressParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSProgressBarCell
*
cell
=
mProgressBarCell
;
[
cell
setValue
:
aParams
.
value
]
;
[
cell
setMax
:
aParams
.
max
]
;
[
cell
setIndeterminate
:
aParams
.
indeterminate
]
;
[
cell
setHorizontal
:
aParams
.
horizontal
]
;
[
cell
setControlTint
:
(
aParams
.
insideActiveWindow
?
[
NSColor
currentControlTint
]
:
NSClearControlTint
)
]
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
aParams
.
insideActiveWindow
;
}
DrawCellWithSnapping
(
cell
cgContext
inBoxRect
progressSettings
[
aParams
.
horizontal
]
[
aParams
.
indeterminate
]
aParams
.
verticalAlignFactor
mCellDrawView
aParams
.
rtl
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
constexpr
static
CellRenderSettings
meterSetting
=
{
{
NSSize
{
0
16
}
NSSize
{
0
16
}
NSSize
{
0
16
}
}
{
NSSize
{
}
NSSize
{
}
NSSize
{
}
}
{
IntMargin
{
1
1
1
1
}
IntMargin
{
1
1
1
1
}
IntMargin
{
1
1
1
1
}
}
}
;
nsNativeThemeCocoa
:
:
MeterParams
nsNativeThemeCocoa
:
:
ComputeMeterParams
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
(
content
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
meter
)
)
)
{
return
MeterParams
(
)
;
}
HTMLMeterElement
*
meterElement
=
static_cast
<
HTMLMeterElement
*
>
(
content
)
;
MeterParams
params
;
params
.
value
=
meterElement
-
>
Value
(
)
;
params
.
min
=
meterElement
-
>
Min
(
)
;
params
.
max
=
meterElement
-
>
Max
(
)
;
ElementState
states
=
meterElement
-
>
State
(
)
;
if
(
states
.
HasState
(
ElementState
:
:
SUB_OPTIMUM
)
)
{
params
.
optimumState
=
OptimumState
:
:
eSubOptimum
;
}
else
if
(
states
.
HasState
(
ElementState
:
:
SUB_SUB_OPTIMUM
)
)
{
params
.
optimumState
=
OptimumState
:
:
eSubSubOptimum
;
}
params
.
horizontal
=
!
IsVerticalMeter
(
aFrame
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
params
.
rtl
=
IsFrameRTL
(
aFrame
)
;
return
params
;
}
void
nsNativeThemeCocoa
:
:
DrawMeter
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
MeterParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
NSLevelIndicatorCell
*
cell
=
mMeterBarCell
;
[
cell
setMinValue
:
aParams
.
min
]
;
[
cell
setMaxValue
:
aParams
.
max
]
;
[
cell
setDoubleValue
:
aParams
.
value
]
;
switch
(
aParams
.
optimumState
)
{
case
OptimumState
:
:
eOptimum
:
[
cell
setWarningValue
:
aParams
.
max
+
1
]
;
[
cell
setCriticalValue
:
aParams
.
max
+
1
]
;
break
;
case
OptimumState
:
:
eSubOptimum
:
[
cell
setWarningValue
:
aParams
.
value
]
;
[
cell
setCriticalValue
:
aParams
.
max
+
1
]
;
break
;
case
OptimumState
:
:
eSubSubOptimum
:
[
cell
setWarningValue
:
aParams
.
max
+
1
]
;
[
cell
setCriticalValue
:
aParams
.
value
]
;
break
;
}
HIRect
rect
=
CGRectStandardize
(
inBoxRect
)
;
BOOL
vertical
=
!
aParams
.
horizontal
;
CGContextSaveGState
(
cgContext
)
;
if
(
vertical
)
{
CGFloat
tmp
=
rect
.
size
.
width
;
rect
.
size
.
width
=
rect
.
size
.
height
;
rect
.
size
.
height
=
tmp
;
rect
.
origin
.
x
+
=
rect
.
size
.
height
/
2
.
f
-
rect
.
size
.
width
/
2
.
f
;
rect
.
origin
.
y
+
=
rect
.
size
.
width
/
2
.
f
-
rect
.
size
.
height
/
2
.
f
;
CGContextTranslateCTM
(
cgContext
CGRectGetMidX
(
rect
)
CGRectGetMidY
(
rect
)
)
;
CGContextRotateCTM
(
cgContext
-
M_PI
/
2
.
f
)
;
CGContextTranslateCTM
(
cgContext
-
CGRectGetMidX
(
rect
)
-
CGRectGetMidY
(
rect
)
)
;
}
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
YES
;
}
DrawCellWithSnapping
(
cell
cgContext
rect
meterSetting
aParams
.
verticalAlignFactor
mCellDrawView
!
vertical
&
&
aParams
.
rtl
)
;
CGContextRestoreGState
(
cgContext
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
}
Maybe
<
nsNativeThemeCocoa
:
:
ScaleParams
>
nsNativeThemeCocoa
:
:
ComputeHTMLScaleParams
(
nsIFrame
*
aFrame
ElementState
aEventState
)
{
nsRangeFrame
*
rangeFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
rangeFrame
)
{
return
Nothing
(
)
;
}
bool
isHorizontal
=
IsRangeHorizontal
(
aFrame
)
;
ScaleParams
params
;
params
.
value
=
int32_t
(
rangeFrame
-
>
GetValueAsFractionOfRange
(
)
*
1000
)
;
params
.
min
=
0
;
params
.
max
=
1000
;
params
.
reverse
=
!
isHorizontal
|
|
rangeFrame
-
>
IsRightToLeft
(
)
;
params
.
insideActiveWindow
=
FrameIsInActiveWindow
(
aFrame
)
;
params
.
focused
=
aEventState
.
HasState
(
ElementState
:
:
FOCUSRING
)
;
params
.
disabled
=
aEventState
.
HasState
(
ElementState
:
:
DISABLED
)
;
params
.
horizontal
=
isHorizontal
;
return
Some
(
params
)
;
}
void
nsNativeThemeCocoa
:
:
DrawScale
(
CGContextRef
cgContext
const
HIRect
&
inBoxRect
const
ScaleParams
&
aParams
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
HIThemeTrackDrawInfo
tdi
;
tdi
.
version
=
0
;
tdi
.
kind
=
kThemeMediumSlider
;
tdi
.
bounds
=
inBoxRect
;
tdi
.
min
=
aParams
.
min
;
tdi
.
max
=
aParams
.
max
;
tdi
.
value
=
aParams
.
value
;
tdi
.
attributes
=
kThemeTrackShowThumb
;
if
(
aParams
.
horizontal
)
{
tdi
.
attributes
|
=
kThemeTrackHorizontal
;
}
if
(
aParams
.
reverse
)
{
tdi
.
attributes
|
=
kThemeTrackRightToLeft
;
}
if
(
aParams
.
focused
)
{
tdi
.
attributes
|
=
kThemeTrackHasFocus
;
}
if
(
aParams
.
disabled
)
{
tdi
.
enableState
=
kThemeTrackDisabled
;
}
else
{
tdi
.
enableState
=
aParams
.
insideActiveWindow
?
kThemeTrackActive
:
kThemeTrackInactive
;
}
tdi
.
trackInfo
.
slider
.
thumbDir
=
kThemeThumbPlain
;
tdi
.
trackInfo
.
slider
.
pressState
=
0
;
HIThemeDrawTrack
(
&
tdi
NULL
cgContext
HITHEME_ORIENTATION
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsNativeThemeCocoa
:
:
DrawMultilineTextField
(
CGContextRef
cgContext
const
CGRect
&
inBoxRect
bool
aIsFocused
)
{
mTextFieldCell
.
enabled
=
YES
;
mTextFieldCell
.
showsFirstResponder
=
aIsFocused
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
cellsShouldLookActive
=
YES
;
}
NSGraphicsContext
*
savedContext
=
NSGraphicsContext
.
currentContext
;
NSGraphicsContext
.
currentContext
=
[
NSGraphicsContext
graphicsContextWithCGContext
:
cgContext
flipped
:
YES
]
;
DrawCellIncludingFocusRing
(
mTextFieldCell
inBoxRect
mCellDrawView
)
;
NSGraphicsContext
.
currentContext
=
savedContext
;
}
static
bool
IsHiDPIContext
(
nsDeviceContext
*
aContext
)
{
return
AppUnitsPerCSSPixel
(
)
>
=
2
*
aContext
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
}
Maybe
<
nsNativeThemeCocoa
:
:
WidgetInfo
>
nsNativeThemeCocoa
:
:
ComputeWidgetInfo
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
int32_t
p2a
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Rect
nativeWidgetRect
(
aRect
.
x
aRect
.
y
aRect
.
width
aRect
.
height
)
;
nativeWidgetRect
.
Scale
(
1
.
0
/
gfxFloat
(
p2a
)
)
;
float
originalHeight
=
nativeWidgetRect
.
Height
(
)
;
nativeWidgetRect
.
Round
(
)
;
if
(
nativeWidgetRect
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
bool
hidpi
=
IsHiDPIContext
(
aFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
)
;
if
(
hidpi
)
{
nativeWidgetRect
.
Scale
(
0
.
5f
)
;
originalHeight
*
=
0
.
5f
;
}
ElementState
elementState
=
GetContentState
(
aFrame
aAppearance
)
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Tooltip
:
return
Nothing
(
)
;
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
{
bool
isCheckbox
=
aAppearance
=
=
StyleAppearance
:
:
Checkbox
;
CheckboxOrRadioParams
params
;
params
.
state
=
CheckboxOrRadioState
:
:
eOff
;
if
(
isCheckbox
&
&
elementState
.
HasState
(
ElementState
:
:
INDETERMINATE
)
)
{
params
.
state
=
CheckboxOrRadioState
:
:
eIndeterminate
;
}
else
if
(
elementState
.
HasState
(
ElementState
:
:
CHECKED
)
)
{
params
.
state
=
CheckboxOrRadioState
:
:
eOn
;
}
params
.
controlParams
=
ComputeControlParams
(
aFrame
elementState
)
;
params
.
verticalAlignFactor
=
VerticalAlignFactor
(
aFrame
)
;
if
(
isCheckbox
)
{
return
Some
(
WidgetInfo
:
:
Checkbox
(
params
)
)
;
}
return
Some
(
WidgetInfo
:
:
Radio
(
params
)
)
;
}
case
StyleAppearance
:
:
Button
:
if
(
IsDefaultButton
(
aFrame
)
)
{
DocumentState
docState
=
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
State
(
)
;
ControlParams
params
=
ComputeControlParams
(
aFrame
elementState
)
;
params
.
insideActiveWindow
=
!
docState
.
HasState
(
DocumentState
:
:
WINDOW_INACTIVE
)
;
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
params
ButtonType
:
:
eDefaultPushButton
}
)
)
;
}
if
(
IsButtonTypeMenu
(
aFrame
)
)
{
ControlParams
controlParams
=
ComputeControlParams
(
aFrame
elementState
)
;
controlParams
.
pressed
=
IsOpenButton
(
aFrame
)
;
DropdownParams
params
;
params
.
controlParams
=
controlParams
;
params
.
pullsDown
=
true
;
params
.
editable
=
false
;
return
Some
(
WidgetInfo
:
:
Dropdown
(
params
)
)
;
}
if
(
originalHeight
>
DO_SQUARE_BUTTON_HEIGHT
)
{
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
elementState
)
ButtonType
:
:
eSquareBezelPushButton
}
)
)
;
}
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
elementState
)
ButtonType
:
:
eRegularPushButton
}
)
)
;
case
StyleAppearance
:
:
MozMacHelpButton
:
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
elementState
)
ButtonType
:
:
eHelpButton
}
)
)
;
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
{
ButtonType
buttonType
=
(
aAppearance
=
=
StyleAppearance
:
:
MozMacDisclosureButtonClosed
)
?
ButtonType
:
:
eDisclosureButtonClosed
:
ButtonType
:
:
eDisclosureButtonOpen
;
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
elementState
)
buttonType
}
)
)
;
}
case
StyleAppearance
:
:
MozSidebar
:
case
StyleAppearance
:
:
MozWindowTitlebar
:
{
return
Nothing
(
)
;
}
case
StyleAppearance
:
:
Menulist
:
{
ControlParams
controlParams
=
ComputeControlParams
(
aFrame
elementState
)
;
controlParams
.
pressed
=
IsOpenButton
(
aFrame
)
;
DropdownParams
params
;
params
.
controlParams
=
controlParams
;
params
.
pullsDown
=
false
;
params
.
editable
=
false
;
return
Some
(
WidgetInfo
:
:
Dropdown
(
params
)
)
;
}
case
StyleAppearance
:
:
MozMenulistArrowButton
:
return
Some
(
WidgetInfo
:
:
Button
(
ButtonParams
{
ComputeControlParams
(
aFrame
elementState
)
ButtonType
:
:
eArrowButton
}
)
)
;
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
return
Some
(
WidgetInfo
:
:
TextField
(
ComputeTextFieldParams
(
aFrame
elementState
)
)
)
;
case
StyleAppearance
:
:
ProgressBar
:
{
if
(
elementState
.
HasState
(
ElementState
:
:
INDETERMINATE
)
)
{
if
(
!
QueueAnimatedContentForRefresh
(
aFrame
-
>
GetContent
(
)
30
)
)
{
NS_WARNING
(
"
Unable
to
animate
progressbar
!
"
)
;
}
}
return
Some
(
WidgetInfo
:
:
ProgressBar
(
ComputeProgressParams
(
aFrame
elementState
!
IsVerticalProgress
(
aFrame
)
)
)
)
;
}
case
StyleAppearance
:
:
Meter
:
return
Some
(
WidgetInfo
:
:
Meter
(
ComputeMeterParams
(
aFrame
)
)
)
;
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
Meterchunk
:
break
;
case
StyleAppearance
:
:
Range
:
{
Maybe
<
ScaleParams
>
params
=
ComputeHTMLScaleParams
(
aFrame
elementState
)
;
if
(
params
)
{
return
Some
(
WidgetInfo
:
:
Scale
(
*
params
)
)
;
}
break
;
}
case
StyleAppearance
:
:
Textarea
:
return
Some
(
WidgetInfo
:
:
MultilineTextField
(
elementState
.
HasState
(
ElementState
:
:
FOCUS
)
)
)
;
default
:
break
;
}
return
Nothing
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
Nothing
(
)
)
;
}
void
nsNativeThemeCocoa
:
:
DrawWidgetBackground
(
gfxContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
DrawOverflow
aDrawOverflow
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
ThemeCocoa
:
:
DrawWidgetBackground
(
aContext
aFrame
aAppearance
aRect
aDirtyRect
aDrawOverflow
)
;
}
Maybe
<
WidgetInfo
>
widgetInfo
=
ComputeWidgetInfo
(
aFrame
aAppearance
aRect
)
;
if
(
!
widgetInfo
)
{
return
;
}
int32_t
p2a
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Rect
nativeWidgetRect
=
NSRectToRect
(
aRect
p2a
)
;
nativeWidgetRect
.
Round
(
)
;
bool
hidpi
=
IsHiDPIContext
(
aFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
)
;
auto
colorScheme
=
LookAndFeel
:
:
ColorSchemeForFrame
(
aFrame
)
;
RenderWidget
(
*
widgetInfo
colorScheme
*
aContext
-
>
GetDrawTarget
(
)
nativeWidgetRect
NSRectToRect
(
aDirtyRect
p2a
)
hidpi
?
2
.
0f
:
1
.
0f
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
}
void
nsNativeThemeCocoa
:
:
RenderWidget
(
const
WidgetInfo
&
aWidgetInfo
LookAndFeel
:
:
ColorScheme
aScheme
DrawTarget
&
aDrawTarget
const
gfx
:
:
Rect
&
aWidgetRect
const
gfx
:
:
Rect
&
aDirtyRect
float
aScale
)
{
NSAppearance
.
currentAppearance
=
NSAppearanceForColorScheme
(
aScheme
)
;
if
(
mCellDrawWindow
)
{
mCellDrawWindow
.
appearance
=
NSAppearance
.
currentAppearance
;
}
const
Widget
widget
=
aWidgetInfo
.
Widget
(
)
;
AutoRestoreTransform
autoRestoreTransform
(
&
aDrawTarget
)
;
gfx
:
:
Rect
widgetRect
=
aWidgetRect
;
gfx
:
:
Rect
dirtyRect
=
aDirtyRect
;
dirtyRect
.
Scale
(
1
.
0f
/
aScale
)
;
widgetRect
.
Scale
(
1
.
0f
/
aScale
)
;
aDrawTarget
.
SetTransform
(
aDrawTarget
.
GetTransform
(
)
.
PreScale
(
aScale
aScale
)
)
;
CGRect
macRect
=
CGRectMake
(
widgetRect
.
X
(
)
widgetRect
.
Y
(
)
widgetRect
.
Width
(
)
widgetRect
.
Height
(
)
)
;
gfxQuartzNativeDrawing
nativeDrawing
(
aDrawTarget
dirtyRect
)
;
CGContextRef
cgContext
=
nativeDrawing
.
BeginNativeDrawing
(
)
;
if
(
cgContext
=
=
nullptr
)
{
return
;
}
CGContextSetBaseCTM
(
cgContext
CGAffineTransformMakeScale
(
aScale
aScale
)
)
;
switch
(
widget
)
{
case
Widget
:
:
eCheckbox
:
{
CheckboxOrRadioParams
params
=
aWidgetInfo
.
Params
<
CheckboxOrRadioParams
>
(
)
;
DrawCheckboxOrRadio
(
cgContext
true
macRect
params
)
;
break
;
}
case
Widget
:
:
eRadio
:
{
CheckboxOrRadioParams
params
=
aWidgetInfo
.
Params
<
CheckboxOrRadioParams
>
(
)
;
DrawCheckboxOrRadio
(
cgContext
false
macRect
params
)
;
break
;
}
case
Widget
:
:
eButton
:
{
ButtonParams
params
=
aWidgetInfo
.
Params
<
ButtonParams
>
(
)
;
DrawButton
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eDropdown
:
{
DropdownParams
params
=
aWidgetInfo
.
Params
<
DropdownParams
>
(
)
;
DrawDropdown
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eTextField
:
{
TextFieldParams
params
=
aWidgetInfo
.
Params
<
TextFieldParams
>
(
)
;
DrawTextField
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eProgressBar
:
{
ProgressParams
params
=
aWidgetInfo
.
Params
<
ProgressParams
>
(
)
;
DrawProgress
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMeter
:
{
MeterParams
params
=
aWidgetInfo
.
Params
<
MeterParams
>
(
)
;
DrawMeter
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eScale
:
{
ScaleParams
params
=
aWidgetInfo
.
Params
<
ScaleParams
>
(
)
;
DrawScale
(
cgContext
macRect
params
)
;
break
;
}
case
Widget
:
:
eMultilineTextField
:
{
bool
isFocused
=
aWidgetInfo
.
Params
<
bool
>
(
)
;
DrawMultilineTextField
(
cgContext
macRect
isFocused
)
;
break
;
}
}
CGContextSetBaseCTM
(
cgContext
CGAffineTransformIdentity
)
;
nativeDrawing
.
EndNativeDrawing
(
)
;
}
bool
nsNativeThemeCocoa
:
:
CreateWebRenderCommandsForWidget
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsIFrame
*
aFrame
StyleAppearance
aAppearance
const
nsRect
&
aRect
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
ThemeCocoa
:
:
CreateWebRenderCommandsForWidget
(
aBuilder
aResources
aSc
aManager
aFrame
aAppearance
aRect
)
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
Textarea
:
return
false
;
default
:
return
true
;
}
}
LayoutDeviceIntMargin
nsNativeThemeCocoa
:
:
DirectionAwareMargin
(
const
LayoutDeviceIntMargin
&
aMargin
nsIFrame
*
aFrame
)
{
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
nsMargin
m
=
LogicalMargin
(
wm
aMargin
.
top
aMargin
.
right
aMargin
.
bottom
aMargin
.
left
)
.
GetPhysicalMargin
(
wm
)
;
return
LayoutDeviceIntMargin
(
m
.
top
m
.
right
m
.
bottom
m
.
left
)
;
}
static
constexpr
LayoutDeviceIntMargin
kAquaDropdownBorder
(
1
22
2
5
)
;
LayoutDeviceIntMargin
nsNativeThemeCocoa
:
:
GetWidgetBorder
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetWidgetBorder
(
aContext
aFrame
aAppearance
)
;
}
LayoutDeviceIntMargin
result
;
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
if
(
IsButtonTypeMenu
(
aFrame
)
)
{
result
=
DirectionAwareMargin
(
kAquaDropdownBorder
aFrame
)
;
}
else
{
result
=
DirectionAwareMargin
(
LayoutDeviceIntMargin
(
1
7
3
7
)
aFrame
)
;
}
break
;
}
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
result
=
DirectionAwareMargin
(
kAquaDropdownBorder
aFrame
)
;
break
;
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
{
SInt32
frameOutset
=
0
;
:
:
GetThemeMetric
(
kThemeMetricEditTextFrameOutset
&
frameOutset
)
;
SInt32
textPadding
=
0
;
:
:
GetThemeMetric
(
kThemeMetricEditTextWhitespace
&
textPadding
)
;
frameOutset
+
=
textPadding
;
result
.
SizeTo
(
frameOutset
frameOutset
frameOutset
frameOutset
)
;
break
;
}
case
StyleAppearance
:
:
Textarea
:
result
.
SizeTo
(
1
1
1
1
)
;
break
;
default
:
break
;
}
if
(
IsHiDPIContext
(
aContext
)
)
{
result
=
result
+
result
;
}
NS_OBJC_END_TRY_BLOCK_RETURN
(
result
)
;
}
bool
nsNativeThemeCocoa
:
:
GetWidgetPadding
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
LayoutDeviceIntMargin
*
aResult
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
Theme
:
:
GetWidgetPadding
(
aContext
aFrame
aAppearance
aResult
)
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
aResult
-
>
SizeTo
(
0
0
0
0
)
;
return
true
;
default
:
break
;
}
return
false
;
}
bool
nsNativeThemeCocoa
:
:
GetWidgetOverflow
(
nsDeviceContext
*
aContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
nsRect
*
aOverflowRect
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
ThemeCocoa
:
:
GetWidgetOverflow
(
aContext
aFrame
aAppearance
aOverflowRect
)
;
}
nsIntMargin
overflow
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
{
overflow
.
SizeTo
(
static_cast
<
int32_t
>
(
kMaxFocusRingWidth
)
static_cast
<
int32_t
>
(
kMaxFocusRingWidth
)
static_cast
<
int32_t
>
(
kMaxFocusRingWidth
)
static_cast
<
int32_t
>
(
kMaxFocusRingWidth
)
)
;
break
;
}
case
StyleAppearance
:
:
ProgressBar
:
{
overflow
.
bottom
=
2
;
break
;
}
case
StyleAppearance
:
:
Meter
:
{
overflow
.
SizeTo
(
2
2
2
2
)
;
break
;
}
default
:
break
;
}
if
(
IsHiDPIContext
(
aContext
)
)
{
overflow
+
=
overflow
;
}
if
(
overflow
!
=
nsIntMargin
(
)
)
{
int32_t
p2a
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aOverflowRect
-
>
Inflate
(
nsMargin
(
NSIntPixelsToAppUnits
(
overflow
.
top
p2a
)
NSIntPixelsToAppUnits
(
overflow
.
right
p2a
)
NSIntPixelsToAppUnits
(
overflow
.
bottom
p2a
)
NSIntPixelsToAppUnits
(
overflow
.
left
p2a
)
)
)
;
return
true
;
}
return
false
;
}
LayoutDeviceIntSize
nsNativeThemeCocoa
:
:
GetMinimumWidgetSize
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
ThemeCocoa
:
:
GetMinimumWidgetSize
(
aPresContext
aFrame
aAppearance
)
;
}
LayoutDeviceIntSize
result
;
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Button
:
{
result
.
SizeTo
(
pushButtonSettings
.
minimumSizes
[
CocoaSize
:
:
Mini
]
.
width
pushButtonSettings
.
naturalSizes
[
CocoaSize
:
:
Mini
]
.
height
)
;
break
;
}
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
{
result
.
SizeTo
(
kDisclosureButtonSize
.
width
kDisclosureButtonSize
.
height
)
;
break
;
}
case
StyleAppearance
:
:
MozMacHelpButton
:
{
result
.
SizeTo
(
kHelpButtonSize
.
width
kHelpButtonSize
.
height
)
;
break
;
}
case
StyleAppearance
:
:
Menulist
:
{
SInt32
popupHeight
=
0
;
:
:
GetThemeMetric
(
kThemeMetricPopupButtonHeight
&
popupHeight
)
;
result
.
SizeTo
(
0
popupHeight
)
;
break
;
}
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
{
result
.
SizeTo
(
0
(
2
+
2
)
+
9
+
(
1
+
1
)
)
;
break
;
}
case
StyleAppearance
:
:
MozWindowButtonBox
:
{
NSSize
size
=
WindowButtonsSize
(
aFrame
)
;
result
.
SizeTo
(
size
.
width
size
.
height
)
;
break
;
}
case
StyleAppearance
:
:
ProgressBar
:
{
SInt32
barHeight
=
0
;
:
:
GetThemeMetric
(
kThemeMetricNormalProgressBarThickness
&
barHeight
)
;
result
.
SizeTo
(
0
barHeight
)
;
break
;
}
case
StyleAppearance
:
:
RangeThumb
:
{
SInt32
width
=
0
;
SInt32
height
=
0
;
:
:
GetThemeMetric
(
kThemeMetricSliderMinThumbWidth
&
width
)
;
:
:
GetThemeMetric
(
kThemeMetricSliderMinThumbHeight
&
height
)
;
result
.
SizeTo
(
width
height
)
;
break
;
}
case
StyleAppearance
:
:
MozMenulistArrowButton
:
return
ThemeCocoa
:
:
GetMinimumWidgetSize
(
aPresContext
aFrame
aAppearance
)
;
default
:
break
;
}
if
(
IsHiDPIContext
(
aPresContext
-
>
DeviceContext
(
)
)
)
{
result
=
result
*
2
;
}
return
result
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntSize
(
)
)
;
}
bool
nsNativeThemeCocoa
:
:
WidgetAttributeChangeRequiresRepaint
(
StyleAppearance
aAppearance
nsAtom
*
aAttribute
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozSidebar
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Meterchunk
:
return
false
;
default
:
break
;
}
return
Theme
:
:
WidgetAttributeChangeRequiresRepaint
(
aAppearance
aAttribute
)
;
}
bool
nsNativeThemeCocoa
:
:
ThemeSupportsWidget
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetAlwaysNonNative
(
aFrame
aAppearance
)
)
{
return
ThemeCocoa
:
:
ThemeSupportsWidget
(
aPresContext
aFrame
aAppearance
)
;
}
if
(
aAppearance
=
=
StyleAppearance
:
:
MozMenulistArrowButton
)
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
parentFrame
&
&
parentFrame
-
>
IsComboboxControlFrame
(
)
)
return
false
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
MozMenulistArrowButton
:
if
(
aFrame
&
&
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
return
false
;
}
[
[
fallthrough
]
]
;
case
StyleAppearance
:
:
MozWindowButtonBox
:
case
StyleAppearance
:
:
MozWindowTitlebar
:
case
StyleAppearance
:
:
MozSidebar
:
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
MozMacWindow
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Progresschunk
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Meterchunk
:
case
StyleAppearance
:
:
Range
:
return
!
IsWidgetStyled
(
aPresContext
aFrame
aAppearance
)
;
default
:
break
;
}
return
false
;
}
bool
nsNativeThemeCocoa
:
:
WidgetIsContainer
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozMenulistArrowButton
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Checkbox
:
case
StyleAppearance
:
:
ProgressBar
:
case
StyleAppearance
:
:
Meter
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
return
false
;
default
:
break
;
}
return
true
;
}
bool
nsNativeThemeCocoa
:
:
ThemeDrawsFocusForWidget
(
nsIFrame
*
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Textarea
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Menulist
:
case
StyleAppearance
:
:
Button
:
case
StyleAppearance
:
:
MozMacHelpButton
:
case
StyleAppearance
:
:
MozMacDisclosureButtonOpen
:
case
StyleAppearance
:
:
MozMacDisclosureButtonClosed
:
case
StyleAppearance
:
:
Radio
:
case
StyleAppearance
:
:
Range
:
case
StyleAppearance
:
:
Checkbox
:
return
true
;
default
:
return
false
;
}
}
bool
nsNativeThemeCocoa
:
:
ThemeNeedsComboboxDropmarker
(
)
{
return
false
;
}
bool
nsNativeThemeCocoa
:
:
WidgetAppearanceDependsOnWindowFocus
(
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Tooltip
:
case
StyleAppearance
:
:
NumberInput
:
case
StyleAppearance
:
:
PasswordInput
:
case
StyleAppearance
:
:
Textfield
:
case
StyleAppearance
:
:
Textarea
:
return
false
;
default
:
return
true
;
}
}
nsITheme
:
:
ThemeGeometryType
nsNativeThemeCocoa
:
:
ThemeGeometryTypeForWidget
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
MozSidebar
:
return
eThemeGeometryTypeSidebar
;
case
StyleAppearance
:
:
MozWindowTitlebar
:
return
eThemeGeometryTypeTitlebar
;
case
StyleAppearance
:
:
MozWindowButtonBox
:
return
eThemeGeometryTypeWindowButtons
;
default
:
return
eThemeGeometryTypeUnknown
;
}
}
nsITheme
:
:
Transparency
nsNativeThemeCocoa
:
:
GetWidgetTransparency
(
nsIFrame
*
aFrame
StyleAppearance
aAppearance
)
{
if
(
IsWidgetScrollbarPart
(
aAppearance
)
)
{
return
ThemeCocoa
:
:
GetWidgetTransparency
(
aFrame
aAppearance
)
;
}
switch
(
aAppearance
)
{
case
StyleAppearance
:
:
Menupopup
:
case
StyleAppearance
:
:
Tooltip
:
return
eTransparent
;
case
StyleAppearance
:
:
MozMacWindow
:
return
eOpaque
;
default
:
return
eUnknownTransparency
;
}
}
already_AddRefed
<
widget
:
:
Theme
>
do_CreateNativeThemeDoNotUseDirectly
(
)
{
return
do_AddRef
(
new
nsNativeThemeCocoa
(
)
)
;
}
