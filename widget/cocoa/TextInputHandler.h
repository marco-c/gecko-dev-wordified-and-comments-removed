#
ifndef
TextInputHandler_h_
#
define
TextInputHandler_h_
#
include
"
nsCocoaUtils
.
h
"
#
import
<
Carbon
/
Carbon
.
h
>
#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
mozView
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
TextEventDispatcherListener
.
h
"
#
include
"
WritingModes
.
h
"
class
nsChildView
;
namespace
mozilla
{
namespace
widget
{
enum
{
#
if
!
defined
(
MAC_OS_X_VERSION_10_12
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_12
kVK_RightCommand
=
0x36
#
endif
kVK_PC_PrintScreen
=
kVK_F13
kVK_PC_ScrollLock
=
kVK_F14
kVK_PC_Pause
=
kVK_F15
kVK_PC_Insert
=
kVK_Help
kVK_PC_Backspace
=
kVK_Delete
kVK_PC_Delete
=
kVK_ForwardDelete
kVK_PC_ContextMenu
=
0x6E
kVK_Powerbook_KeypadEnter
=
0x34
}
;
class
TISInputSourceWrapper
{
public
:
static
TISInputSourceWrapper
&
CurrentInputSource
(
)
;
static
void
Shutdown
(
)
;
TISInputSourceWrapper
(
)
:
mInputSource
{
nullptr
}
mKeyboardLayout
{
nullptr
}
mUCKeyboardLayout
{
nullptr
}
mIsRTL
{
0
}
mOverrideKeyboard
{
false
}
{
mInputSourceList
=
nullptr
;
Clear
(
)
;
}
explicit
TISInputSourceWrapper
(
const
char
*
aID
)
:
mInputSource
{
nullptr
}
mKeyboardLayout
{
nullptr
}
mUCKeyboardLayout
{
nullptr
}
mIsRTL
{
0
}
mOverrideKeyboard
{
false
}
{
mInputSourceList
=
nullptr
;
InitByInputSourceID
(
aID
)
;
}
explicit
TISInputSourceWrapper
(
SInt32
aLayoutID
)
:
mInputSource
{
nullptr
}
mKeyboardLayout
{
nullptr
}
mUCKeyboardLayout
{
nullptr
}
mIsRTL
{
0
}
mOverrideKeyboard
{
false
}
{
mInputSourceList
=
nullptr
;
InitByLayoutID
(
aLayoutID
)
;
}
explicit
TISInputSourceWrapper
(
TISInputSourceRef
aInputSource
)
:
mInputSource
{
nullptr
}
mKeyboardLayout
{
nullptr
}
mUCKeyboardLayout
{
nullptr
}
mIsRTL
{
0
}
mOverrideKeyboard
{
false
}
{
mInputSourceList
=
nullptr
;
InitByTISInputSourceRef
(
aInputSource
)
;
}
~
TISInputSourceWrapper
(
)
{
Clear
(
)
;
}
void
InitByInputSourceID
(
const
char
*
aID
)
;
void
InitByInputSourceID
(
const
nsString
&
aID
)
;
void
InitByInputSourceID
(
const
CFStringRef
aID
)
;
void
InitByLayoutID
(
SInt32
aLayoutID
bool
aOverrideKeyboard
=
false
)
;
void
InitByCurrentInputSource
(
)
;
void
InitByCurrentKeyboardLayout
(
)
;
void
InitByCurrentASCIICapableInputSource
(
)
;
void
InitByCurrentASCIICapableKeyboardLayout
(
)
;
void
InitByCurrentInputMethodKeyboardLayoutOverride
(
)
;
void
InitByTISInputSourceRef
(
TISInputSourceRef
aInputSource
)
;
void
InitByLanguage
(
CFStringRef
aLanguage
)
;
TISInputSourceRef
GetKeyboardLayoutInputSource
(
)
const
{
return
mKeyboardLayout
;
}
const
UCKeyboardLayout
*
GetUCKeyboardLayout
(
)
;
bool
IsOpenedIMEMode
(
)
;
bool
IsIMEMode
(
)
;
bool
IsKeyboardLayout
(
)
;
bool
IsASCIICapable
(
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetBoolProperty
(
kTISPropertyInputSourceIsASCIICapable
)
;
}
bool
IsEnabled
(
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetBoolProperty
(
kTISPropertyInputSourceIsEnabled
)
;
}
bool
GetLanguageList
(
CFArrayRef
&
aLanguageList
)
;
bool
GetPrimaryLanguage
(
CFStringRef
&
aPrimaryLanguage
)
;
bool
GetPrimaryLanguage
(
nsAString
&
aPrimaryLanguage
)
;
bool
GetLocalizedName
(
CFStringRef
&
aName
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyLocalizedName
aName
)
;
}
bool
GetLocalizedName
(
nsAString
&
aName
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyLocalizedName
aName
)
;
}
bool
GetInputSourceID
(
CFStringRef
&
aID
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyInputSourceID
aID
)
;
}
bool
GetInputSourceID
(
nsAString
&
aID
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyInputSourceID
aID
)
;
}
bool
GetBundleID
(
CFStringRef
&
aBundleID
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyBundleID
aBundleID
)
;
}
bool
GetBundleID
(
nsAString
&
aBundleID
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyBundleID
aBundleID
)
;
}
bool
GetInputSourceType
(
CFStringRef
&
aType
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyInputSourceType
aType
)
;
}
bool
GetInputSourceType
(
nsAString
&
aType
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
return
GetStringProperty
(
kTISPropertyInputSourceType
aType
)
;
}
bool
IsForRTLLanguage
(
)
;
bool
IsForJapaneseLanguage
(
)
;
bool
IsInitializedByCurrentInputSource
(
)
;
enum
{
eKbdType_ANSI
=
40
}
;
void
Select
(
)
;
void
Clear
(
)
;
void
InitKeyEvent
(
NSEvent
*
aNativeKeyEvent
WidgetKeyboardEvent
&
aKeyEvent
bool
aIsProcessedByIME
const
nsAString
*
aInsertString
=
nullptr
)
;
void
WillDispatchKeyboardEvent
(
NSEvent
*
aNativeKeyEvent
const
nsAString
*
aInsertString
uint32_t
aIndexOfKeypress
WidgetKeyboardEvent
&
aKeyEvent
)
;
uint32_t
ComputeGeckoKeyCode
(
UInt32
aNativeKeyCode
UInt32
aKbType
bool
aCmdIsPressed
)
;
static
KeyNameIndex
ComputeGeckoKeyNameIndex
(
UInt32
aNativeKeyCode
)
;
static
CodeNameIndex
ComputeGeckoCodeNameIndex
(
UInt32
aNativeKeyCode
UInt32
aKbType
)
;
bool
IsDeadKey
(
NSEvent
*
aNativeKeyEvent
)
;
protected
:
bool
TranslateToString
(
UInt32
aKeyCode
UInt32
aModifiers
UInt32
aKbType
nsAString
&
aStr
)
;
uint32_t
TranslateToChar
(
UInt32
aKeyCode
UInt32
aModifiers
UInt32
aKbType
)
;
bool
IsDeadKey
(
UInt32
aKeyCode
UInt32
aModifiers
UInt32
aKbType
)
;
void
ComputeInsertStringForCharCode
(
NSEvent
*
aNativeKeyEvent
const
WidgetKeyboardEvent
&
aKeyEvent
const
nsAString
*
aInsertString
nsAString
&
aResult
)
;
bool
IsPrintableKeyEvent
(
NSEvent
*
aNativeKeyEvent
)
const
;
UInt32
GetKbdType
(
)
const
;
bool
GetBoolProperty
(
const
CFStringRef
aKey
)
;
bool
GetStringProperty
(
const
CFStringRef
aKey
CFStringRef
&
aStr
)
;
bool
GetStringProperty
(
const
CFStringRef
aKey
nsAString
&
aStr
)
;
TISInputSourceRef
mInputSource
;
TISInputSourceRef
mKeyboardLayout
;
CFArrayRef
mInputSourceList
;
const
UCKeyboardLayout
*
mUCKeyboardLayout
;
int8_t
mIsRTL
;
bool
mOverrideKeyboard
;
static
TISInputSourceWrapper
*
sCurrentInputSource
;
}
;
class
TextInputHandlerBase
:
public
TextEventDispatcherListener
{
public
:
NS_DECL_ISUPPORTS
bool
DispatchEvent
(
WidgetGUIEvent
&
aEvent
)
;
bool
SetSelection
(
NSRange
&
aRange
)
;
void
InitKeyEvent
(
NSEvent
*
aNativeKeyEvent
WidgetKeyboardEvent
&
aKeyEvent
bool
aIsProcessedByIME
const
nsAString
*
aInsertString
=
nullptr
)
;
nsresult
SynthesizeNativeKeyEvent
(
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
)
;
NS_IMETHOD
AttachNativeKeyEvent
(
WidgetKeyboardEvent
&
aKeyEvent
)
;
NSInteger
GetWindowLevel
(
)
;
static
bool
IsSpecialGeckoKey
(
UInt32
aNativeKeyCode
)
;
static
void
EnableSecureEventInput
(
)
;
static
void
DisableSecureEventInput
(
)
;
static
bool
IsSecureEventInputEnabled
(
)
;
static
void
EnsureSecureEventInputDisabled
(
)
;
public
:
virtual
bool
OnDestroyWidget
(
nsChildView
*
aDestroyingWidget
)
;
protected
:
nsChildView
*
mWidget
;
RefPtr
<
TextEventDispatcher
>
mDispatcher
;
NSView
<
mozView
>
*
mView
;
TextInputHandlerBase
(
nsChildView
*
aWidget
NSView
<
mozView
>
*
aNativeView
)
;
virtual
~
TextInputHandlerBase
(
)
;
bool
Destroyed
(
)
{
return
!
mWidget
;
}
struct
KeyEventState
{
NSEvent
*
mKeyEvent
;
nsAString
*
mInsertString
;
nsString
mInsertedString
;
uint32_t
mUniqueId
;
bool
mKeyDownDispatched
;
bool
mKeyDownHandled
;
bool
mKeyPressDispatched
;
bool
mKeyPressHandled
;
bool
mCausedOtherKeyEvents
;
bool
mCompositionDispatched
;
KeyEventState
(
)
:
mKeyEvent
(
nullptr
)
mUniqueId
(
0
)
{
Clear
(
)
;
}
explicit
KeyEventState
(
NSEvent
*
aNativeKeyEvent
uint32_t
aUniqueId
=
0
)
:
mKeyEvent
(
nullptr
)
mUniqueId
(
0
)
{
Clear
(
)
;
Set
(
aNativeKeyEvent
aUniqueId
)
;
}
KeyEventState
(
const
KeyEventState
&
aOther
)
=
delete
;
~
KeyEventState
(
)
{
Clear
(
)
;
}
void
Set
(
NSEvent
*
aNativeKeyEvent
uint32_t
aUniqueId
=
0
)
{
MOZ_ASSERT
(
aNativeKeyEvent
"
aNativeKeyEvent
must
not
be
NULL
"
)
;
Clear
(
)
;
mKeyEvent
=
[
aNativeKeyEvent
retain
]
;
mUniqueId
=
aUniqueId
;
}
void
Clear
(
)
{
if
(
mKeyEvent
)
{
[
mKeyEvent
release
]
;
mKeyEvent
=
nullptr
;
mUniqueId
=
0
;
}
mInsertString
=
nullptr
;
mInsertedString
.
Truncate
(
)
;
mKeyDownDispatched
=
false
;
mKeyDownHandled
=
false
;
mKeyPressDispatched
=
false
;
mKeyPressHandled
=
false
;
mCausedOtherKeyEvents
=
false
;
mCompositionDispatched
=
false
;
}
bool
IsDefaultPrevented
(
)
const
{
return
mKeyDownHandled
|
|
mKeyPressHandled
|
|
mCausedOtherKeyEvents
|
|
mCompositionDispatched
;
}
bool
CanDispatchKeyDownEvent
(
)
const
{
return
!
mKeyDownDispatched
;
}
bool
CanDispatchKeyPressEvent
(
)
const
{
return
!
mKeyPressDispatched
&
&
!
IsDefaultPrevented
(
)
;
}
bool
CanHandleCommand
(
)
const
{
return
!
mKeyDownHandled
&
&
!
mKeyPressHandled
;
}
bool
IsProperKeyEvent
(
Command
aCommand
)
const
{
if
(
NS_WARN_IF
(
!
mKeyEvent
)
)
{
return
false
;
}
KeyNameIndex
keyNameIndex
=
TISInputSourceWrapper
:
:
ComputeGeckoKeyNameIndex
(
[
mKeyEvent
keyCode
]
)
;
Modifiers
modifiers
=
nsCocoaUtils
:
:
ModifiersForEvent
(
mKeyEvent
)
&
(
MODIFIER_SHIFT
|
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
switch
(
aCommand
)
{
case
Command
:
:
InsertLineBreak
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Enter
&
&
modifiers
=
=
MODIFIER_CONTROL
;
case
Command
:
:
InsertParagraph
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Enter
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
DeleteCharBackward
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Backspace
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
DeleteToBeginningOfLine
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Backspace
&
&
modifiers
=
=
MODIFIER_META
;
case
Command
:
:
DeleteWordBackward
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Backspace
&
&
modifiers
=
=
MODIFIER_ALT
;
case
Command
:
:
DeleteCharForward
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Delete
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
DeleteWordForward
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Delete
&
&
modifiers
=
=
MODIFIER_ALT
;
case
Command
:
:
InsertTab
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Tab
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
InsertBacktab
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Tab
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
CharNext
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowRight
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
SelectCharNext
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowRight
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
WordNext
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowRight
&
&
modifiers
=
=
MODIFIER_ALT
;
case
Command
:
:
SelectWordNext
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowRight
&
&
modifiers
=
=
(
MODIFIER_ALT
|
MODIFIER_SHIFT
)
;
case
Command
:
:
EndLine
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowRight
&
&
modifiers
=
=
MODIFIER_META
;
case
Command
:
:
SelectEndLine
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowRight
&
&
modifiers
=
=
(
MODIFIER_META
|
MODIFIER_SHIFT
)
;
case
Command
:
:
CharPrevious
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowLeft
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
SelectCharPrevious
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowLeft
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
WordPrevious
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowLeft
&
&
modifiers
=
=
MODIFIER_ALT
;
case
Command
:
:
SelectWordPrevious
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowLeft
&
&
modifiers
=
=
(
MODIFIER_ALT
|
MODIFIER_SHIFT
)
;
case
Command
:
:
BeginLine
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowLeft
&
&
modifiers
=
=
MODIFIER_META
;
case
Command
:
:
SelectBeginLine
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowLeft
&
&
modifiers
=
=
(
MODIFIER_META
|
MODIFIER_SHIFT
)
;
case
Command
:
:
LinePrevious
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowUp
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
SelectLinePrevious
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowUp
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
MoveTop
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowUp
&
&
modifiers
=
=
MODIFIER_META
;
case
Command
:
:
SelectTop
:
return
(
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowUp
&
&
modifiers
=
=
(
MODIFIER_META
|
MODIFIER_SHIFT
)
)
|
|
(
keyNameIndex
=
=
KEY_NAME_INDEX_Home
&
&
modifiers
=
=
MODIFIER_SHIFT
)
;
case
Command
:
:
LineNext
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowDown
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
SelectLineNext
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowDown
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
MoveBottom
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowDown
&
&
modifiers
=
=
MODIFIER_META
;
case
Command
:
:
SelectBottom
:
return
(
keyNameIndex
=
=
KEY_NAME_INDEX_ArrowDown
&
&
modifiers
=
=
(
MODIFIER_META
|
MODIFIER_SHIFT
)
)
|
|
(
keyNameIndex
=
=
KEY_NAME_INDEX_End
&
&
modifiers
=
=
MODIFIER_SHIFT
)
;
case
Command
:
:
ScrollPageUp
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_PageUp
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
SelectPageUp
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_PageUp
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
ScrollPageDown
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_PageDown
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
SelectPageDown
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_PageDown
&
&
modifiers
=
=
MODIFIER_SHIFT
;
case
Command
:
:
ScrollBottom
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_End
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
ScrollTop
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Home
&
&
modifiers
=
=
MODIFIER_NONE
;
case
Command
:
:
CancelOperation
:
return
(
keyNameIndex
=
=
KEY_NAME_INDEX_Escape
&
&
(
modifiers
=
=
MODIFIER_NONE
|
|
modifiers
=
=
MODIFIER_SHIFT
)
)
|
|
(
[
mKeyEvent
keyCode
]
=
=
kVK_ANSI_Period
&
&
modifiers
=
=
MODIFIER_META
)
;
case
Command
:
:
Complete
:
return
keyNameIndex
=
=
KEY_NAME_INDEX_Escape
&
&
(
modifiers
=
=
MODIFIER_ALT
|
|
modifiers
=
=
(
MODIFIER_ALT
|
MODIFIER_SHIFT
)
)
;
default
:
return
false
;
}
}
void
InitKeyEvent
(
TextInputHandlerBase
*
aHandler
WidgetKeyboardEvent
&
aKeyEvent
bool
aIsProcessedByIME
)
;
void
GetUnhandledString
(
nsAString
&
aUnhandledString
)
const
;
}
;
class
AutoKeyEventStateCleaner
{
public
:
explicit
AutoKeyEventStateCleaner
(
TextInputHandlerBase
*
aHandler
)
:
mHandler
(
aHandler
)
{
}
~
AutoKeyEventStateCleaner
(
)
{
mHandler
-
>
RemoveCurrentKeyEvent
(
)
;
}
private
:
RefPtr
<
TextInputHandlerBase
>
mHandler
;
}
;
class
MOZ_STACK_CLASS
AutoInsertStringClearer
{
public
:
explicit
AutoInsertStringClearer
(
KeyEventState
*
aState
)
:
mState
(
aState
)
{
}
~
AutoInsertStringClearer
(
)
;
private
:
KeyEventState
*
mState
;
}
;
nsTArray
<
KeyEventState
*
>
mCurrentKeyEvents
;
KeyEventState
mFirstKeyEvent
;
KeyEventState
*
PushKeyEvent
(
NSEvent
*
aNativeKeyEvent
uint32_t
aUniqueId
=
0
)
{
uint32_t
nestCount
=
mCurrentKeyEvents
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
nestCount
;
i
+
+
)
{
mCurrentKeyEvents
[
i
]
-
>
mCausedOtherKeyEvents
=
true
;
}
KeyEventState
*
keyEvent
=
nullptr
;
if
(
nestCount
=
=
0
)
{
mFirstKeyEvent
.
Set
(
aNativeKeyEvent
aUniqueId
)
;
keyEvent
=
&
mFirstKeyEvent
;
}
else
{
keyEvent
=
new
KeyEventState
(
aNativeKeyEvent
aUniqueId
)
;
}
return
*
mCurrentKeyEvents
.
AppendElement
(
keyEvent
)
;
}
void
RemoveCurrentKeyEvent
(
)
{
NS_ASSERTION
(
mCurrentKeyEvents
.
Length
(
)
>
0
"
RemoveCurrentKeyEvent
(
)
is
called
unexpectedly
"
)
;
KeyEventState
*
keyEvent
=
mCurrentKeyEvents
.
PopLastElement
(
)
;
if
(
keyEvent
=
=
&
mFirstKeyEvent
)
{
keyEvent
-
>
Clear
(
)
;
}
else
{
delete
keyEvent
;
}
}
KeyEventState
*
GetCurrentKeyEvent
(
)
{
if
(
mCurrentKeyEvents
.
Length
(
)
=
=
0
)
{
return
nullptr
;
}
return
mCurrentKeyEvents
[
mCurrentKeyEvents
.
Length
(
)
-
1
]
;
}
struct
KeyboardLayoutOverride
final
{
int32_t
mKeyboardLayout
;
bool
mOverrideEnabled
;
KeyboardLayoutOverride
(
)
:
mKeyboardLayout
(
0
)
mOverrideEnabled
(
false
)
{
}
}
;
const
KeyboardLayoutOverride
&
KeyboardLayoutOverrideRef
(
)
const
{
return
mKeyboardOverride
;
}
static
bool
IsPrintableChar
(
char16_t
aChar
)
;
static
bool
IsNormalCharInputtingEvent
(
NSEvent
*
aNativeEvent
)
;
static
bool
IsModifierKey
(
UInt32
aNativeKeyCode
)
;
private
:
KeyboardLayoutOverride
mKeyboardOverride
;
static
int32_t
sSecureEventInputCount
;
}
;
class
IMEInputHandler
:
public
TextInputHandlerBase
{
public
:
NS_IMETHOD
NotifyIME
(
TextEventDispatcher
*
aTextEventDispatcher
const
IMENotification
&
aNotification
)
override
;
NS_IMETHOD_
(
IMENotificationRequests
)
GetIMENotificationRequests
(
)
override
;
NS_IMETHOD_
(
void
)
OnRemovedFrom
(
TextEventDispatcher
*
aTextEventDispatcher
)
override
;
NS_IMETHOD_
(
void
)
WillDispatchKeyboardEvent
(
TextEventDispatcher
*
aTextEventDispatcher
WidgetKeyboardEvent
&
aKeyboardEvent
uint32_t
aIndexOfKeypress
void
*
aData
)
override
;
public
:
virtual
bool
OnDestroyWidget
(
nsChildView
*
aDestroyingWidget
)
override
;
virtual
void
OnFocusChangeInGecko
(
bool
aFocus
)
;
void
OnSelectionChange
(
const
IMENotification
&
aIMENotification
)
;
void
OnLayoutChange
(
)
;
bool
OnHandleEvent
(
NSEvent
*
aEvent
)
;
void
SetMarkedText
(
NSAttributedString
*
aAttrString
NSRange
&
aSelectedRange
NSRange
*
aReplacementRange
=
nullptr
)
;
NSAttributedString
*
GetAttributedSubstringFromRange
(
NSRange
&
aRange
NSRange
*
aActualRange
=
nullptr
)
;
NSRange
SelectedRange
(
)
;
bool
DrawsVerticallyForCharacterAtIndex
(
uint32_t
aCharIndex
)
;
NSRect
FirstRectForCharacterRange
(
NSRange
&
aRange
NSRange
*
aActualRange
=
nullptr
)
;
NSUInteger
CharacterIndexForPoint
(
NSPoint
&
aPoint
)
;
NSArray
*
GetValidAttributesForMarkedText
(
)
;
bool
HasMarkedText
(
)
;
NSRange
MarkedRange
(
)
;
bool
IsIMEComposing
(
)
{
return
mIsIMEComposing
;
}
bool
IsDeadKeyComposing
(
)
{
return
mIsDeadKeyComposing
;
}
bool
IsIMEOpened
(
)
;
bool
IsIMEEnabled
(
)
{
return
mIsIMEEnabled
;
}
bool
IsASCIICapableOnly
(
)
{
return
mIsASCIICapableOnly
;
}
bool
IsEditableContent
(
)
const
{
return
mIsIMEEnabled
|
|
mIsASCIICapableOnly
;
}
bool
IgnoreIMECommit
(
)
{
return
mIgnoreIMECommit
;
}
void
CommitIMEComposition
(
)
;
void
CancelIMEComposition
(
)
;
void
EnableIME
(
bool
aEnableIME
)
;
void
SetIMEOpenState
(
bool
aOpen
)
;
void
SetASCIICapableOnly
(
bool
aASCIICapableOnly
)
;
bool
IsFocused
(
)
;
static
CFArrayRef
CreateAllIMEModeList
(
)
;
static
void
DebugPrintAllIMEModes
(
)
;
static
TSMDocumentID
GetCurrentTSMDocumentID
(
)
;
protected
:
nsCOMPtr
<
nsITimer
>
mTimer
;
enum
{
kNotifyIMEOfFocusChangeInGecko
=
1
kSyncASCIICapableOnly
=
2
}
;
uint32_t
mPendingMethods
;
IMEInputHandler
(
nsChildView
*
aWidget
NSView
<
mozView
>
*
aNativeView
)
;
virtual
~
IMEInputHandler
(
)
;
void
ResetTimer
(
)
;
virtual
void
ExecutePendingMethods
(
)
;
void
InsertTextAsCommittingComposition
(
NSAttributedString
*
aAttrString
NSRange
*
aReplacementRange
)
;
bool
MaybeDispatchCurrentKeydownEvent
(
bool
aIsProcessedByIME
)
;
private
:
NSString
*
mIMECompositionString
;
uint32_t
mIMECompositionStart
;
NSRange
mMarkedRange
;
NSRange
mSelectedRange
;
NSRange
mRangeForWritingMode
;
mozilla
:
:
WritingMode
mWritingMode
;
bool
mIsIMEComposing
;
bool
mIsDeadKeyComposing
;
bool
mIsIMEEnabled
;
bool
mIsASCIICapableOnly
;
bool
mIgnoreIMECommit
;
bool
mIMEHasFocus
;
void
KillIMEComposition
(
)
;
void
SendCommittedText
(
NSString
*
aString
)
;
void
OpenSystemPreferredLanguageIME
(
)
;
void
NotifyIMEOfFocusChangeInGecko
(
)
;
void
SyncASCIICapableOnly
(
)
;
static
bool
sStaticMembersInitialized
;
static
CFStringRef
sLatestIMEOpenedModeInputSourceID
;
static
void
InitStaticMembers
(
)
;
static
void
OnCurrentTextInputSourceChange
(
CFNotificationCenterRef
aCenter
void
*
aObserver
CFStringRef
aName
const
void
*
aObject
CFDictionaryRef
aUserInfo
)
;
static
void
FlushPendingMethods
(
nsITimer
*
aTimer
void
*
aClosure
)
;
TextRangeType
ConvertToTextRangeType
(
uint32_t
aUnderlineStyle
NSRange
&
aSelectedRange
)
;
uint32_t
GetRangeCount
(
NSAttributedString
*
aString
)
;
already_AddRefed
<
mozilla
:
:
TextRangeArray
>
CreateTextRangeArray
(
NSAttributedString
*
aAttrString
NSRange
&
aSelectedRange
)
;
bool
DispatchCompositionStartEvent
(
)
;
bool
DispatchCompositionChangeEvent
(
const
nsString
&
aText
NSAttributedString
*
aAttrString
NSRange
&
aSelectedRange
)
;
bool
DispatchCompositionCommitEvent
(
const
nsAString
*
aCommitString
=
nullptr
)
;
static
IMEInputHandler
*
sFocusedIMEHandler
;
static
bool
sCachedIsForRTLLangage
;
}
;
class
TextInputHandler
:
public
IMEInputHandler
{
public
:
static
NSUInteger
sLastModifierState
;
static
CFArrayRef
CreateAllKeyboardLayoutList
(
)
;
static
void
DebugPrintAllKeyboardLayouts
(
)
;
TextInputHandler
(
nsChildView
*
aWidget
NSView
<
mozView
>
*
aNativeView
)
;
virtual
~
TextInputHandler
(
)
;
bool
HandleKeyDownEvent
(
NSEvent
*
aNativeEvent
uint32_t
aUniqueId
)
;
void
HandleKeyUpEvent
(
NSEvent
*
aNativeEvent
)
;
void
HandleFlagsChanged
(
NSEvent
*
aNativeEvent
)
;
void
InsertText
(
NSAttributedString
*
aAttrString
NSRange
*
aReplacementRange
=
nullptr
)
;
bool
HandleCommand
(
Command
aCommand
)
;
bool
DoCommandBySelector
(
const
char
*
aSelector
)
;
bool
KeyPressWasHandled
(
)
{
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
return
currentKeyEvent
&
&
currentKeyEvent
-
>
mKeyPressHandled
;
}
protected
:
struct
ModifierKey
{
NSUInteger
flags
;
unsigned
short
keyCode
;
ModifierKey
(
NSUInteger
aFlags
unsigned
short
aKeyCode
)
:
flags
(
aFlags
)
keyCode
(
aKeyCode
)
{
}
NSUInteger
GetDeviceDependentFlags
(
)
const
{
return
(
flags
&
~
NSEventModifierFlagDeviceIndependentFlagsMask
)
;
}
NSUInteger
GetDeviceIndependentFlags
(
)
const
{
return
(
flags
&
NSEventModifierFlagDeviceIndependentFlagsMask
)
;
}
}
;
typedef
nsTArray
<
ModifierKey
>
ModifierKeyArray
;
ModifierKeyArray
mModifierKeys
;
const
ModifierKey
*
GetModifierKeyForNativeKeyCode
(
unsigned
short
aKeyCode
)
const
;
const
ModifierKey
*
GetModifierKeyForDeviceDependentFlags
(
NSUInteger
aFlags
)
const
;
void
DispatchKeyEventForFlagsChanged
(
NSEvent
*
aNativeEvent
bool
aDispatchKeyDown
)
;
}
;
}
}
#
endif
