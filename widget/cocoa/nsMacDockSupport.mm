#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsMacDockSupport
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsNativeThemeColors
.
h
"
NS_IMPL_ISUPPORTS
(
nsMacDockSupport
nsIMacDockSupport
nsITaskbarProgress
)
interface
MOZProgressDockOverlayView
:
NSView
{
double
mFractionValue
;
}
property
double
fractionValue
;
end
implementation
MOZProgressDockOverlayView
synthesize
fractionValue
=
mFractionValue
;
-
(
void
)
drawRect
:
(
NSRect
)
aRect
{
[
[
NSColor
clearColor
]
set
]
;
NSRectFill
(
self
.
bounds
)
;
CGFloat
radius
=
self
.
bounds
.
size
.
height
/
4
;
NSRect
barBounds
=
NSInsetRect
(
self
.
bounds
0
radius
)
;
NSBezierPath
*
path
=
[
NSBezierPath
bezierPathWithRoundedRect
:
barBounds
xRadius
:
radius
yRadius
:
radius
]
;
[
[
NSColor
colorWithDeviceWhite
:
0
alpha
:
0
.
1
]
setFill
]
;
[
path
fill
]
;
NSRect
progressFillRect
=
self
.
bounds
;
progressFillRect
.
size
.
width
*
=
mFractionValue
;
[
NSGraphicsContext
saveGraphicsState
]
;
[
NSBezierPath
clipRect
:
progressFillRect
]
;
[
ControlAccentColor
(
)
setFill
]
;
[
path
fill
]
;
[
NSGraphicsContext
restoreGraphicsState
]
;
[
NSGraphicsContext
saveGraphicsState
]
;
[
path
addClip
]
;
[
[
NSColor
colorWithDeviceWhite
:
0
alpha
:
0
.
2
]
setStroke
]
;
path
.
lineWidth
=
barBounds
.
size
.
height
/
10
;
[
path
stroke
]
;
[
NSGraphicsContext
restoreGraphicsState
]
;
}
end
nsMacDockSupport
:
:
nsMacDockSupport
(
)
:
mDockTileWrapperView
(
nil
)
mProgressDockOverlayView
(
nil
)
mProgressState
(
STATE_NO_PROGRESS
)
mProgressFraction
(
0
.
0
)
{
}
nsMacDockSupport
:
:
~
nsMacDockSupport
(
)
{
if
(
mDockTileWrapperView
)
{
[
mDockTileWrapperView
release
]
;
mDockTileWrapperView
=
nil
;
}
if
(
mProgressDockOverlayView
)
{
[
mProgressDockOverlayView
release
]
;
mProgressDockOverlayView
=
nil
;
}
}
NS_IMETHODIMP
nsMacDockSupport
:
:
GetDockMenu
(
nsIStandaloneNativeMenu
*
*
aDockMenu
)
{
nsCOMPtr
<
nsIStandaloneNativeMenu
>
dockMenu
(
mDockMenu
)
;
dockMenu
.
forget
(
aDockMenu
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsMacDockSupport
:
:
SetDockMenu
(
nsIStandaloneNativeMenu
*
aDockMenu
)
{
mDockMenu
=
aDockMenu
;
return
NS_OK
;
}
NS_IMETHODIMP
nsMacDockSupport
:
:
ActivateApplication
(
bool
aIgnoreOtherApplications
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
[
[
NSApplication
sharedApplication
]
activateIgnoringOtherApps
:
aIgnoreOtherApplications
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsMacDockSupport
:
:
SetBadgeText
(
const
nsAString
&
aBadgeText
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSDockTile
*
tile
=
[
[
NSApplication
sharedApplication
]
dockTile
]
;
mBadgeText
=
aBadgeText
;
if
(
aBadgeText
.
IsEmpty
(
)
)
[
tile
setBadgeLabel
:
nil
]
;
else
[
tile
setBadgeLabel
:
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
mBadgeText
.
get
(
)
)
length
:
mBadgeText
.
Length
(
)
]
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsMacDockSupport
:
:
GetBadgeText
(
nsAString
&
aBadgeText
)
{
aBadgeText
=
mBadgeText
;
return
NS_OK
;
}
NS_IMETHODIMP
nsMacDockSupport
:
:
SetProgressState
(
nsTaskbarProgressState
aState
uint64_t
aCurrentValue
uint64_t
aMaxValue
)
{
NS_ENSURE_ARG_RANGE
(
aState
0
STATE_PAUSED
)
;
if
(
aState
=
=
STATE_NO_PROGRESS
|
|
aState
=
=
STATE_INDETERMINATE
)
{
NS_ENSURE_TRUE
(
aCurrentValue
=
=
0
NS_ERROR_INVALID_ARG
)
;
NS_ENSURE_TRUE
(
aMaxValue
=
=
0
NS_ERROR_INVALID_ARG
)
;
}
if
(
aCurrentValue
>
aMaxValue
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
mProgressState
=
aState
;
if
(
aMaxValue
=
=
0
)
{
mProgressFraction
=
0
;
}
else
{
mProgressFraction
=
(
double
)
aCurrentValue
/
aMaxValue
;
}
return
UpdateDockTile
(
)
;
}
nsresult
nsMacDockSupport
:
:
UpdateDockTile
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
mProgressState
=
=
STATE_NORMAL
|
|
mProgressState
=
=
STATE_INDETERMINATE
)
{
if
(
!
mDockTileWrapperView
)
{
mDockTileWrapperView
=
[
[
NSView
alloc
]
initWithFrame
:
NSMakeRect
(
0
0
32
32
)
]
;
mDockTileWrapperView
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewHeightSizable
;
NSImageView
*
imageView
=
[
[
NSImageView
alloc
]
initWithFrame
:
[
mDockTileWrapperView
bounds
]
]
;
imageView
.
image
=
[
NSImage
imageNamed
:
"
NSApplicationIcon
"
]
;
imageView
.
imageScaling
=
NSImageScaleAxesIndependently
;
imageView
.
autoresizingMask
=
NSViewWidthSizable
|
NSViewHeightSizable
;
[
mDockTileWrapperView
addSubview
:
imageView
]
;
mProgressDockOverlayView
=
[
[
MOZProgressDockOverlayView
alloc
]
initWithFrame
:
NSMakeRect
(
1
3
30
4
)
]
;
mProgressDockOverlayView
.
autoresizingMask
=
NSViewMinXMargin
|
NSViewWidthSizable
|
NSViewMaxXMargin
|
NSViewMinYMargin
|
NSViewHeightSizable
|
NSViewMaxYMargin
;
[
mDockTileWrapperView
addSubview
:
mProgressDockOverlayView
]
;
}
if
(
NSApp
.
dockTile
.
contentView
!
=
mDockTileWrapperView
)
{
NSApp
.
dockTile
.
contentView
=
mDockTileWrapperView
;
}
if
(
mProgressState
=
=
STATE_NORMAL
)
{
mProgressDockOverlayView
.
fractionValue
=
mProgressFraction
;
}
else
{
mProgressDockOverlayView
.
fractionValue
=
1
.
0
;
}
[
NSApp
.
dockTile
display
]
;
}
else
if
(
NSApp
.
dockTile
.
contentView
)
{
NSApp
.
dockTile
.
contentView
=
nil
;
[
NSApp
.
dockTile
display
]
;
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
