#
include
<
objc
/
objc
-
runtime
.
h
>
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTouchBarNativeAPIDefines
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
Element
;
NativeMenuItemTarget
*
nsMenuBarX
:
:
sNativeEventTarget
=
nil
;
nsMenuBarX
*
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
nullptr
;
NSMenu
*
sApplicationMenu
=
nil
;
BOOL
sApplicationMenuIsFallback
=
NO
;
BOOL
gSomeMenuBarPainted
=
NO
;
extern
BOOL
sTouchBarIsInitialized
;
static
nsIContent
*
sAboutItemContent
=
nullptr
;
static
nsIContent
*
sPrefItemContent
=
nullptr
;
static
nsIContent
*
sAccountItemContent
=
nullptr
;
static
nsIContent
*
sQuitItemContent
=
nullptr
;
implementation
ApplicationMenuDelegate
-
(
id
)
initWithApplicationMenu
:
(
nsMenuBarX
*
)
aApplicationMenu
{
if
(
(
self
=
[
super
init
]
)
)
{
mApplicationMenu
=
aApplicationMenu
;
}
return
self
;
}
-
(
void
)
menuWillOpen
:
(
NSMenu
*
)
menu
{
mApplicationMenu
-
>
ApplicationMenuOpened
(
)
;
}
-
(
void
)
menuDidClose
:
(
NSMenu
*
)
menu
{
}
end
nsMenuBarX
:
:
nsMenuBarX
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
:
mNeedsRebuild
(
false
)
mApplicationMenuDelegate
(
nil
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mMenuGroupOwner
=
new
nsMenuGroupOwnerX
(
aElement
this
)
;
mMenuGroupOwner
-
>
RegisterForLocaleChanges
(
)
;
mNativeMenu
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
"
MainMenuBar
"
]
;
mContent
=
aElement
;
if
(
mContent
)
{
AquifyMenuBar
(
)
;
mMenuGroupOwner
-
>
RegisterForContentChanges
(
mContent
this
)
;
ConstructNativeMenus
(
)
;
}
else
{
ConstructFallbackNativeMenus
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsMenuBarX
:
:
~
nsMenuBarX
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
=
this
)
{
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
nullptr
;
}
if
(
sAboutItemContent
=
=
mAboutItemContent
)
{
sAboutItemContent
=
nullptr
;
}
if
(
sQuitItemContent
=
=
mQuitItemContent
)
{
sQuitItemContent
=
nullptr
;
}
if
(
sPrefItemContent
=
=
mPrefItemContent
)
{
sPrefItemContent
=
nullptr
;
}
if
(
sAccountItemContent
=
=
mAccountItemContent
)
{
sAccountItemContent
=
nullptr
;
}
mMenuGroupOwner
-
>
UnregisterForLocaleChanges
(
)
;
if
(
mContent
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mContent
)
;
}
for
(
nsMenuX
*
menu
:
mMenuArray
)
{
menu
-
>
DetachFromGroupOwnerRecursive
(
)
;
menu
-
>
DetachFromParent
(
)
;
}
if
(
mApplicationMenuDelegate
)
{
[
mApplicationMenuDelegate
release
]
;
}
[
mNativeMenu
release
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
ConstructNativeMenus
(
)
{
for
(
nsIContent
*
menuContent
=
mContent
-
>
GetFirstChild
(
)
;
menuContent
;
menuContent
=
menuContent
-
>
GetNextSibling
(
)
)
{
if
(
menuContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
{
InsertMenuAtIndex
(
MakeRefPtr
<
nsMenuX
>
(
this
mMenuGroupOwner
menuContent
-
>
AsElement
(
)
)
GetMenuCount
(
)
)
;
}
}
}
void
nsMenuBarX
:
:
ConstructFallbackNativeMenus
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
sApplicationMenu
)
{
return
;
}
nsCOMPtr
<
nsIStringBundle
>
stringBundle
;
nsCOMPtr
<
nsIStringBundleService
>
bundleSvc
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
)
;
bundleSvc
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
fallbackMenubar
.
properties
"
getter_AddRefs
(
stringBundle
)
)
;
if
(
!
stringBundle
)
{
return
;
}
nsAutoString
labelUTF16
;
nsAutoString
keyUTF16
;
const
char
*
labelProp
=
"
quitMenuitem
.
label
"
;
const
char
*
keyProp
=
"
quitMenuitem
.
key
"
;
stringBundle
-
>
GetStringFromName
(
labelProp
labelUTF16
)
;
stringBundle
-
>
GetStringFromName
(
keyProp
keyUTF16
)
;
NSString
*
labelStr
=
[
NSString
stringWithUTF8String
:
NS_ConvertUTF16toUTF8
(
labelUTF16
)
.
get
(
)
]
;
NSString
*
keyStr
=
[
NSString
stringWithUTF8String
:
NS_ConvertUTF16toUTF8
(
keyUTF16
)
.
get
(
)
]
;
if
(
!
nsMenuBarX
:
:
sNativeEventTarget
)
{
nsMenuBarX
:
:
sNativeEventTarget
=
[
[
NativeMenuItemTarget
alloc
]
init
]
;
}
sApplicationMenu
=
[
[
[
[
NSApp
mainMenu
]
itemAtIndex
:
0
]
submenu
]
retain
]
;
if
(
!
mApplicationMenuDelegate
)
{
mApplicationMenuDelegate
=
[
[
ApplicationMenuDelegate
alloc
]
initWithApplicationMenu
:
this
]
;
}
sApplicationMenu
.
delegate
=
mApplicationMenuDelegate
;
NSMenuItem
*
quitMenuItem
=
[
[
[
NSMenuItem
alloc
]
initWithTitle
:
labelStr
action
:
selector
(
menuItemHit
:
)
keyEquivalent
:
keyStr
]
autorelease
]
;
quitMenuItem
.
target
=
nsMenuBarX
:
:
sNativeEventTarget
;
quitMenuItem
.
tag
=
eCommand_ID_Quit
;
[
sApplicationMenu
addItem
:
quitMenuItem
]
;
sApplicationMenuIsFallback
=
YES
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
uint32_t
nsMenuBarX
:
:
GetMenuCount
(
)
{
return
mMenuArray
.
Length
(
)
;
}
bool
nsMenuBarX
:
:
MenuContainsAppMenu
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
return
(
mNativeMenu
.
numberOfItems
>
0
&
&
[
mNativeMenu
itemAtIndex
:
0
]
.
submenu
=
=
sApplicationMenu
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
InsertMenuAtIndex
(
RefPtr
<
nsMenuX
>
&
&
aMenu
uint32_t
aIndex
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
sApplicationMenu
&
&
sApplicationMenuIsFallback
)
{
ResetNativeApplicationMenu
(
)
;
}
if
(
!
sApplicationMenu
)
{
CreateApplicationMenu
(
aMenu
.
get
(
)
)
;
NSMenu
*
mainMenu
=
NSApp
.
mainMenu
;
NS_ASSERTION
(
mainMenu
.
numberOfItems
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
[
mainMenu
itemAtIndex
:
0
]
.
submenu
=
sApplicationMenu
;
}
mMenuArray
.
InsertElementAt
(
aIndex
aMenu
)
;
RefPtr
<
nsIContent
>
menuContent
=
aMenu
-
>
Content
(
)
;
if
(
menuContent
-
>
GetChildCount
(
)
>
0
&
&
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
menuContent
)
)
{
MenuChildChangedVisibility
(
MenuChild
(
aMenu
)
true
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
RemoveMenuAtIndex
(
uint32_t
aIndex
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mMenuArray
.
Length
(
)
<
=
aIndex
)
{
NS_ERROR
(
"
Attempting
submenu
removal
with
bad
index
!
"
)
;
return
;
}
RefPtr
<
nsMenuX
>
menu
=
mMenuArray
[
aIndex
]
;
mMenuArray
.
RemoveElementAt
(
aIndex
)
;
menu
-
>
DetachFromGroupOwnerRecursive
(
)
;
menu
-
>
DetachFromParent
(
)
;
NSMenuItem
*
nativeMenuItem
=
menu
-
>
NativeNSMenuItem
(
)
;
int
nativeMenuItemIndex
=
[
mNativeMenu
indexOfItem
:
nativeMenuItem
]
;
if
(
nativeMenuItemIndex
!
=
-
1
)
{
[
mNativeMenu
removeItemAtIndex
:
nativeMenuItemIndex
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
ObserveAttributeChanged
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
nsAtom
*
aAttribute
)
{
}
void
nsMenuBarX
:
:
ObserveContentRemoved
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
nsINode
*
parent
=
NODE_FROM
(
aContainer
aDocument
)
;
MOZ_ASSERT
(
parent
)
;
const
Maybe
<
uint32_t
>
index
=
parent
-
>
ComputeIndexOf
(
aPreviousSibling
)
;
MOZ_ASSERT
(
*
index
!
=
UINT32_MAX
)
;
RemoveMenuAtIndex
(
index
.
isSome
(
)
?
*
index
+
1u
:
0u
)
;
}
void
nsMenuBarX
:
:
ObserveContentInserted
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
InsertMenuAtIndex
(
MakeRefPtr
<
nsMenuX
>
(
this
mMenuGroupOwner
aChild
)
aContainer
-
>
ComputeIndexOf
(
aChild
)
.
valueOr
(
UINT32_MAX
)
)
;
}
void
nsMenuBarX
:
:
ForceUpdateNativeMenuAt
(
const
nsAString
&
aIndexString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aIndexString
.
BeginReading
(
)
)
length
:
aIndexString
.
Length
(
)
]
;
NSArray
*
indexes
=
[
locationString
componentsSeparatedByString
:
"
|
"
]
;
unsigned
int
indexCount
=
indexes
.
count
;
if
(
indexCount
=
=
0
)
{
return
;
}
RefPtr
<
nsMenuX
>
currentMenu
=
nullptr
;
int
targetIndex
=
[
[
indexes
objectAtIndex
:
0
]
intValue
]
;
int
visible
=
0
;
uint32_t
length
=
mMenuArray
.
Length
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
length
;
i
+
+
)
{
RefPtr
<
nsMenuX
>
menu
=
mMenuArray
[
i
]
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
menu
-
>
Content
(
)
)
)
{
visible
+
+
;
if
(
visible
=
=
(
targetIndex
+
1
)
)
{
currentMenu
=
std
:
:
move
(
menu
)
;
break
;
}
}
}
if
(
!
currentMenu
)
{
return
;
}
currentMenu
-
>
MenuOpened
(
)
;
currentMenu
-
>
MenuClosed
(
)
;
for
(
unsigned
int
i
=
1
;
currentMenu
&
&
i
<
indexCount
;
i
+
+
)
{
targetIndex
=
[
[
indexes
objectAtIndex
:
i
]
intValue
]
;
visible
=
0
;
length
=
currentMenu
-
>
GetItemCount
(
)
;
for
(
unsigned
int
j
=
0
;
j
<
length
;
j
+
+
)
{
Maybe
<
nsMenuX
:
:
MenuChild
>
targetMenu
=
currentMenu
-
>
GetItemAt
(
j
)
;
if
(
!
targetMenu
)
{
return
;
}
RefPtr
<
nsIContent
>
content
=
targetMenu
-
>
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
content
)
)
{
visible
+
+
;
if
(
targetMenu
-
>
is
<
RefPtr
<
nsMenuX
>
>
(
)
&
&
visible
=
=
(
targetIndex
+
1
)
)
{
currentMenu
=
targetMenu
-
>
as
<
RefPtr
<
nsMenuX
>
>
(
)
;
currentMenu
-
>
MenuOpened
(
)
;
currentMenu
-
>
MenuClosed
(
)
;
break
;
}
}
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
ForceNativeMenuReload
(
)
{
while
(
GetMenuCount
(
)
>
0
)
{
RemoveMenuAtIndex
(
0
)
;
}
ConstructNativeMenus
(
)
;
}
nsMenuX
*
nsMenuBarX
:
:
GetMenuAt
(
uint32_t
aIndex
)
{
if
(
mMenuArray
.
Length
(
)
<
=
aIndex
)
{
NS_ERROR
(
"
Requesting
menu
at
invalid
index
!
"
)
;
return
nullptr
;
}
return
mMenuArray
[
aIndex
]
.
get
(
)
;
}
nsMenuX
*
nsMenuBarX
:
:
GetXULHelpMenu
(
)
{
for
(
int32_t
i
=
GetMenuCount
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsMenuX
*
aMenu
=
GetMenuAt
(
i
)
;
if
(
aMenu
&
&
nsMenuX
:
:
IsXULHelpMenu
(
aMenu
-
>
Content
(
)
)
)
{
return
aMenu
;
}
}
return
nil
;
}
void
nsMenuBarX
:
:
SetSystemHelpMenu
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
nsMenuX
*
xulHelpMenu
=
GetXULHelpMenu
(
)
;
if
(
xulHelpMenu
)
{
NSMenu
*
helpMenu
=
xulHelpMenu
-
>
NativeNSMenu
(
)
;
if
(
helpMenu
)
{
NSApp
.
helpMenu
=
helpMenu
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsresult
nsMenuBarX
:
:
Paint
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSMenu
*
outgoingMenu
=
NSApp
.
mainMenu
;
NS_ASSERTION
(
outgoingMenu
.
numberOfItems
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
NSMenuItem
*
appMenuItem
=
[
[
outgoingMenu
itemAtIndex
:
0
]
retain
]
;
[
outgoingMenu
removeItemAtIndex
:
0
]
;
[
mNativeMenu
insertItem
:
appMenuItem
atIndex
:
0
]
;
[
appMenuItem
release
]
;
NSApp
.
mainMenu
=
mNativeMenu
;
SetSystemHelpMenu
(
)
;
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
this
;
gSomeMenuBarPainted
=
YES
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
ResetNativeApplicationMenu
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
sApplicationMenu
removeAllItems
]
;
[
sApplicationMenu
release
]
;
sApplicationMenu
=
nil
;
sApplicationMenuIsFallback
=
NO
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
SetNeedsRebuild
(
)
{
mNeedsRebuild
=
true
;
}
void
nsMenuBarX
:
:
ApplicationMenuOpened
(
)
{
if
(
mNeedsRebuild
)
{
if
(
!
mMenuArray
.
IsEmpty
(
)
)
{
ResetNativeApplicationMenu
(
)
;
CreateApplicationMenu
(
mMenuArray
[
0
]
.
get
(
)
)
;
}
mNeedsRebuild
=
false
;
}
}
bool
nsMenuBarX
:
:
PerformKeyEquivalent
(
NSEvent
*
aEvent
)
{
return
[
mNativeMenu
performSuperKeyEquivalent
:
aEvent
]
;
}
void
nsMenuBarX
:
:
MenuChildChangedVisibility
(
const
MenuChild
&
aChild
bool
aIsVisible
)
{
MOZ_RELEASE_ASSERT
(
aChild
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
"
nsMenuBarX
only
has
nsMenuX
children
"
)
;
const
RefPtr
<
nsMenuX
>
&
child
=
aChild
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
;
NSMenuItem
*
item
=
child
-
>
NativeNSMenuItem
(
)
;
if
(
aIsVisible
)
{
NSInteger
insertionPoint
=
CalculateNativeInsertionPoint
(
child
)
;
[
mNativeMenu
insertItem
:
child
-
>
NativeNSMenuItem
(
)
atIndex
:
insertionPoint
]
;
}
else
if
(
[
mNativeMenu
indexOfItem
:
item
]
!
=
-
1
)
{
[
mNativeMenu
removeItem
:
item
]
;
}
}
NSInteger
nsMenuBarX
:
:
CalculateNativeInsertionPoint
(
nsMenuX
*
aChild
)
{
NSInteger
insertionPoint
=
MenuContainsAppMenu
(
)
?
1
:
0
;
for
(
auto
&
currMenu
:
mMenuArray
)
{
if
(
currMenu
=
=
aChild
)
{
return
insertionPoint
;
}
if
(
currMenu
-
>
NativeNSMenuItem
(
)
.
menu
)
{
insertionPoint
+
+
;
}
}
return
insertionPoint
;
}
RefPtr
<
Element
>
nsMenuBarX
:
:
HideItem
(
mozilla
:
:
dom
:
:
Document
*
aDocument
const
nsAString
&
aID
)
{
RefPtr
<
Element
>
menuElement
=
aDocument
-
>
GetElementById
(
aID
)
;
if
(
menuElement
)
{
menuElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
u
"
true
"
_ns
false
)
;
}
return
menuElement
;
}
void
nsMenuBarX
:
:
AquifyMenuBar
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
domDoc
=
mContent
-
>
GetComposedDoc
(
)
;
if
(
domDoc
)
{
HideItem
(
domDoc
u
"
aboutSeparator
"
_ns
)
;
mAboutItemContent
=
HideItem
(
domDoc
u
"
aboutName
"
_ns
)
;
if
(
!
sAboutItemContent
)
{
sAboutItemContent
=
mAboutItemContent
;
}
HideItem
(
domDoc
u
"
menu_FileQuitSeparator
"
_ns
)
;
mQuitItemContent
=
HideItem
(
domDoc
u
"
menu_FileQuitItem
"
_ns
)
;
if
(
!
sQuitItemContent
)
{
sQuitItemContent
=
mQuitItemContent
;
}
HideItem
(
domDoc
u
"
menu_PrefsSeparator
"
_ns
)
;
mPrefItemContent
=
HideItem
(
domDoc
u
"
menu_preferences
"
_ns
)
;
if
(
!
sPrefItemContent
)
{
sPrefItemContent
=
mPrefItemContent
;
}
mAccountItemContent
=
HideItem
(
domDoc
u
"
menu_accountmgr
"
_ns
)
;
if
(
!
sAccountItemContent
)
{
sAccountItemContent
=
mAccountItemContent
;
}
HideItem
(
domDoc
u
"
menu_mac_services
"
_ns
)
;
HideItem
(
domDoc
u
"
menu_mac_hide_app
"
_ns
)
;
HideItem
(
domDoc
u
"
menu_mac_hide_others
"
_ns
)
;
HideItem
(
domDoc
u
"
menu_mac_show_all
"
_ns
)
;
HideItem
(
domDoc
u
"
menu_mac_touch_bar
"
_ns
)
;
}
}
NSMenuItem
*
nsMenuBarX
:
:
CreateNativeAppMenuItem
(
nsMenuX
*
aMenu
const
nsAString
&
aNodeID
SEL
aAction
int
aTag
NativeMenuItemTarget
*
aTarget
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
doc
=
aMenu
-
>
Content
(
)
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nil
;
}
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
menuItem
=
doc
-
>
GetElementById
(
aNodeID
)
;
if
(
!
menuItem
)
{
return
nil
;
}
if
(
menuItem
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
collapsed
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
nil
;
}
nsAutoString
label
;
nsAutoString
modifiers
;
nsAutoString
key
;
menuItem
-
>
GetAttr
(
nsGkAtoms
:
:
label
label
)
;
menuItem
-
>
GetAttr
(
nsGkAtoms
:
:
modifiers
modifiers
)
;
menuItem
-
>
GetAttr
(
nsGkAtoms
:
:
key
key
)
;
NSString
*
keyEquiv
=
nil
;
unsigned
int
macKeyModifiers
=
0
;
if
(
!
key
.
IsEmpty
(
)
)
{
RefPtr
<
Element
>
keyElement
=
doc
-
>
GetElementById
(
key
)
;
if
(
keyElement
)
{
nsAutoString
keyChar
(
u
"
"
_ns
)
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
keyChar
)
;
if
(
!
keyChar
.
EqualsLiteral
(
"
"
)
)
{
keyEquiv
=
[
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
keyChar
.
get
(
)
)
length
:
keyChar
.
Length
(
)
]
lowercaseString
]
;
}
nsAutoString
modifiersStr
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
modifiers
modifiersStr
)
;
uint8_t
geckoModifiers
=
nsMenuUtilsX
:
:
GeckoModifiersForNodeAttribute
(
modifiersStr
)
;
macKeyModifiers
=
nsMenuUtilsX
:
:
MacModifiersForGeckoModifiers
(
geckoModifiers
)
;
}
}
NSString
*
labelString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
label
.
get
(
)
)
length
:
label
.
Length
(
)
]
;
if
(
!
labelString
)
{
labelString
=
"
"
;
}
if
(
!
keyEquiv
)
{
keyEquiv
=
"
"
;
}
NSMenuItem
*
newMenuItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
labelString
action
:
aAction
keyEquivalent
:
keyEquiv
]
;
newMenuItem
.
tag
=
aTag
;
newMenuItem
.
target
=
aTarget
;
newMenuItem
.
keyEquivalentModifierMask
=
macKeyModifiers
;
newMenuItem
.
representedObject
=
mMenuGroupOwner
-
>
GetRepresentedObject
(
)
;
return
newMenuItem
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
CreateApplicationMenu
(
nsMenuX
*
aMenu
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
sApplicationMenu
=
[
[
NSApp
.
mainMenu
itemAtIndex
:
0
]
.
submenu
retain
]
;
if
(
sApplicationMenu
)
{
if
(
!
mApplicationMenuDelegate
)
{
mApplicationMenuDelegate
=
[
[
ApplicationMenuDelegate
alloc
]
initWithApplicationMenu
:
this
]
;
}
sApplicationMenu
.
delegate
=
mApplicationMenuDelegate
;
NSMenuItem
*
itemBeingAdded
=
nil
;
BOOL
addAboutSeparator
=
FALSE
;
BOOL
addPrefsSeparator
=
FALSE
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
aboutName
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_About
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addAboutSeparator
=
TRUE
;
}
if
(
addAboutSeparator
)
{
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_preferences
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_Prefs
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addPrefsSeparator
=
TRUE
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_accountmgr
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_Account
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
}
if
(
addPrefsSeparator
)
{
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_mac_services
"
_ns
nil
0
nil
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
NSMenu
*
servicesMenu
=
[
[
GeckoServicesNSMenu
alloc
]
initWithTitle
:
"
"
]
;
itemBeingAdded
.
submenu
=
servicesMenu
;
NSApp
.
servicesMenu
=
servicesMenu
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
BOOL
addHideShowSeparator
=
FALSE
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_mac_hide_app
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_HideApp
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addHideShowSeparator
=
TRUE
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_mac_hide_others
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_HideOthers
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addHideShowSeparator
=
TRUE
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_mac_show_all
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_ShowAll
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addHideShowSeparator
=
TRUE
;
}
if
(
addHideShowSeparator
)
{
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
BOOL
addTouchBarSeparator
=
NO
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_mac_touch_bar
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_TouchBar
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
if
(
!
sTouchBarIsInitialized
)
{
[
itemBeingAdded
setHidden
:
YES
]
;
}
else
{
addTouchBarSeparator
=
YES
;
}
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
}
if
(
addTouchBarSeparator
)
{
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
aMenu
u
"
menu_FileQuitItem
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_Quit
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
}
else
{
NSMenuItem
*
defaultQuitItem
=
[
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Quit
"
action
:
selector
(
menuItemHit
:
)
keyEquivalent
:
"
q
"
]
autorelease
]
;
defaultQuitItem
.
target
=
nsMenuBarX
:
:
sNativeEventTarget
;
defaultQuitItem
.
tag
=
eCommand_ID_Quit
;
[
sApplicationMenu
addItem
:
defaultQuitItem
]
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
static
BOOL
gMenuItemsExecuteCommands
=
YES
;
implementation
GeckoNSMenu
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
aEvent
{
if
(
self
.
numberOfItems
<
=
0
)
{
return
NO
;
}
NSWindow
*
keyWindow
=
NSApp
.
keyWindow
;
if
(
!
keyWindow
)
{
return
[
super
performKeyEquivalent
:
aEvent
]
;
}
NSResponder
*
firstResponder
=
keyWindow
.
firstResponder
;
gMenuItemsExecuteCommands
=
NO
;
[
super
performKeyEquivalent
:
aEvent
]
;
gMenuItemsExecuteCommands
=
YES
;
if
(
!
NSApp
.
keyWindow
|
|
NSApp
.
keyWindow
.
firstResponder
!
=
firstResponder
)
{
return
YES
;
}
return
NO
;
}
-
(
BOOL
)
performSuperKeyEquivalent
:
(
NSEvent
*
)
aEvent
{
return
[
super
performKeyEquivalent
:
aEvent
]
;
}
end
implementation
NativeMenuItemTarget
-
(
IBAction
)
menuItemHit
:
(
id
)
aSender
{
if
(
!
gMenuItemsExecuteCommands
)
{
return
;
}
if
(
!
[
aSender
isKindOfClass
:
[
NSMenuItem
class
]
]
)
{
return
;
}
NSMenuItem
*
nativeMenuItem
=
(
NSMenuItem
*
)
aSender
;
NSInteger
tag
=
nativeMenuItem
.
tag
;
nsMenuGroupOwnerX
*
menuGroupOwner
=
nullptr
;
nsMenuBarX
*
menuBar
=
nullptr
;
MOZMenuItemRepresentedObject
*
representedObject
=
nativeMenuItem
.
representedObject
;
if
(
representedObject
)
{
menuGroupOwner
=
representedObject
.
menuGroupOwner
;
if
(
!
menuGroupOwner
)
{
return
;
}
menuBar
=
menuGroupOwner
-
>
GetMenuBar
(
)
;
}
NSMenu
*
menu
=
nativeMenuItem
.
menu
;
if
(
[
menu
.
delegate
isKindOfClass
:
[
MenuDelegate
class
]
]
)
{
[
(
MenuDelegate
*
)
menu
.
delegate
menu
:
menu
willActivateItem
:
nativeMenuItem
]
;
}
NSEventModifierFlags
modifierFlags
=
NSApp
.
currentEvent
?
NSApp
.
currentEvent
.
modifierFlags
:
0
;
mozilla
:
:
MouseButton
button
=
NSApp
.
currentEvent
?
nsCocoaUtils
:
:
ButtonForEvent
(
NSApp
.
currentEvent
)
:
mozilla
:
:
MouseButton
:
:
ePrimary
;
if
(
tag
=
=
eCommand_ID_About
)
{
nsIContent
*
mostSpecificContent
=
sAboutItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mAboutItemContent
)
{
mostSpecificContent
=
menuBar
-
>
mAboutItemContent
;
}
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
modifierFlags
button
)
;
return
;
}
if
(
tag
=
=
eCommand_ID_Prefs
)
{
nsIContent
*
mostSpecificContent
=
sPrefItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mPrefItemContent
)
{
mostSpecificContent
=
menuBar
-
>
mPrefItemContent
;
}
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
modifierFlags
button
)
;
return
;
}
if
(
tag
=
=
eCommand_ID_Account
)
{
nsIContent
*
mostSpecificContent
=
sAccountItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mAccountItemContent
)
{
mostSpecificContent
=
menuBar
-
>
mAccountItemContent
;
}
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
modifierFlags
button
)
;
return
;
}
if
(
tag
=
=
eCommand_ID_HideApp
)
{
[
NSApp
hide
:
aSender
]
;
return
;
}
if
(
tag
=
=
eCommand_ID_HideOthers
)
{
[
NSApp
hideOtherApplications
:
aSender
]
;
return
;
}
if
(
tag
=
=
eCommand_ID_ShowAll
)
{
[
NSApp
unhideAllApplications
:
aSender
]
;
return
;
}
if
(
tag
=
=
eCommand_ID_TouchBar
)
{
[
NSApp
toggleTouchBarCustomizationPalette
:
aSender
]
;
return
;
}
if
(
tag
=
=
eCommand_ID_Quit
)
{
nsIContent
*
mostSpecificContent
=
sQuitItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mQuitItemContent
)
{
mostSpecificContent
=
menuBar
-
>
mQuitItemContent
;
}
if
(
mostSpecificContent
)
{
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
modifierFlags
button
)
;
}
else
{
nsCOMPtr
<
nsIAppStartup
>
appStartup
=
mozilla
:
:
components
:
:
AppStartup
:
:
Service
(
)
;
if
(
appStartup
)
{
bool
userAllowedQuit
=
true
;
appStartup
-
>
Quit
(
nsIAppStartup
:
:
eAttemptQuit
0
&
userAllowedQuit
)
;
}
}
return
;
}
if
(
menuGroupOwner
)
{
nsMenuItemX
*
menuItem
=
menuGroupOwner
-
>
GetMenuItemForCommandID
(
static_cast
<
uint32_t
>
(
tag
)
)
;
if
(
menuItem
)
{
menuItem
-
>
DoCommand
(
modifierFlags
button
)
;
}
}
}
end
implementation
GeckoServicesNSMenuItem
-
(
id
)
target
{
id
realTarget
=
super
.
target
;
if
(
gMenuItemsExecuteCommands
)
{
return
realTarget
;
}
return
realTarget
?
self
:
nil
;
}
-
(
SEL
)
action
{
SEL
realAction
=
super
.
action
;
if
(
gMenuItemsExecuteCommands
)
{
return
realAction
;
}
return
realAction
?
selector
(
_doNothing
:
)
:
nullptr
;
}
-
(
void
)
_doNothing
:
(
id
)
aSender
{
}
end
implementation
GeckoServicesNSMenu
-
(
void
)
addItem
:
(
NSMenuItem
*
)
aNewItem
{
[
self
_overrideClassOfMenuItem
:
aNewItem
]
;
[
super
addItem
:
aNewItem
]
;
}
-
(
NSMenuItem
*
)
addItemWithTitle
:
(
NSString
*
)
aString
action
:
(
SEL
)
aSelector
keyEquivalent
:
(
NSString
*
)
aKeyEquiv
{
NSMenuItem
*
newItem
=
[
super
addItemWithTitle
:
aString
action
:
aSelector
keyEquivalent
:
aKeyEquiv
]
;
[
self
_overrideClassOfMenuItem
:
newItem
]
;
return
newItem
;
}
-
(
void
)
insertItem
:
(
NSMenuItem
*
)
aNewItem
atIndex
:
(
NSInteger
)
aIndex
{
[
self
_overrideClassOfMenuItem
:
aNewItem
]
;
[
super
insertItem
:
aNewItem
atIndex
:
aIndex
]
;
}
-
(
NSMenuItem
*
)
insertItemWithTitle
:
(
NSString
*
)
aString
action
:
(
SEL
)
aSelector
keyEquivalent
:
(
NSString
*
)
aKeyEquiv
atIndex
:
(
NSInteger
)
aIndex
{
NSMenuItem
*
newItem
=
[
super
insertItemWithTitle
:
aString
action
:
aSelector
keyEquivalent
:
aKeyEquiv
atIndex
:
aIndex
]
;
[
self
_overrideClassOfMenuItem
:
newItem
]
;
return
newItem
;
}
-
(
void
)
_overrideClassOfMenuItem
:
(
NSMenuItem
*
)
aMenuItem
{
if
(
[
aMenuItem
class
]
=
=
[
NSMenuItem
class
]
)
{
object_setClass
(
aMenuItem
[
GeckoServicesNSMenuItem
class
]
)
;
}
}
end
