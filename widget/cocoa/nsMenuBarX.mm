#
include
<
objc
/
objc
-
runtime
.
h
>
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCocoaWindow
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTouchBarNativeAPIDefines
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIAppStartup
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsToolkitCompsCID
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
NativeMenuItemTarget
*
nsMenuBarX
:
:
sNativeEventTarget
=
nil
;
nsMenuBarX
*
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
nullptr
;
NSMenu
*
sApplicationMenu
=
nil
;
BOOL
sApplicationMenuIsFallback
=
NO
;
BOOL
gSomeMenuBarPainted
=
NO
;
extern
BOOL
sTouchBarIsInitialized
;
static
nsIContent
*
sAboutItemContent
=
nullptr
;
static
nsIContent
*
sPrefItemContent
=
nullptr
;
static
nsIContent
*
sQuitItemContent
=
nullptr
;
NS_IMPL_ISUPPORTS
(
nsNativeMenuServiceX
nsINativeMenuService
)
NS_IMETHODIMP
nsNativeMenuServiceX
:
:
CreateNativeMenuBar
(
nsIWidget
*
aParent
mozilla
:
:
dom
:
:
Element
*
aMenuBarElement
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Attempting
to
create
native
menu
bar
on
wrong
thread
!
"
)
;
RefPtr
<
nsMenuBarX
>
mb
=
new
nsMenuBarX
(
)
;
if
(
!
mb
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
mb
-
>
Create
(
aParent
aMenuBarElement
)
;
}
implementation
ApplicationMenuDelegate
-
(
id
)
initWithApplicationMenu
:
(
nsMenuBarX
*
)
aApplicationMenu
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
(
self
=
[
super
init
]
)
)
{
mApplicationMenu
=
aApplicationMenu
;
}
return
self
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
menuWillOpen
:
(
NSMenu
*
)
menu
{
mApplicationMenu
-
>
ApplicationMenuOpened
(
)
;
}
-
(
void
)
menuDidClose
:
(
NSMenu
*
)
menu
{
}
end
nsMenuBarX
:
:
nsMenuBarX
(
)
:
nsMenuGroupOwnerX
(
)
mParentWindow
(
nullptr
)
mNeedsRebuild
(
false
)
mApplicationMenuDelegate
(
nil
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mNativeMenu
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
"
MainMenuBar
"
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsMenuBarX
:
:
~
nsMenuBarX
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
=
this
)
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
nullptr
;
if
(
sAboutItemContent
=
=
mAboutItemContent
)
sAboutItemContent
=
nullptr
;
if
(
sQuitItemContent
=
=
mQuitItemContent
)
sQuitItemContent
=
nullptr
;
if
(
sPrefItemContent
=
=
mPrefItemContent
)
sPrefItemContent
=
nullptr
;
if
(
mContent
)
{
UnregisterForContentChanges
(
mContent
)
;
}
mMenuArray
.
Clear
(
)
;
if
(
mApplicationMenuDelegate
)
{
[
mApplicationMenuDelegate
release
]
;
}
[
mNativeMenu
release
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsresult
nsMenuBarX
:
:
Create
(
nsIWidget
*
aParent
Element
*
aContent
)
{
if
(
!
aParent
)
return
NS_ERROR_INVALID_ARG
;
mParentWindow
=
aParent
;
mContent
=
aContent
;
if
(
mContent
)
{
AquifyMenuBar
(
)
;
nsresult
rv
=
nsMenuGroupOwnerX
:
:
Create
(
aContent
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
RegisterForContentChanges
(
mContent
this
)
;
ConstructNativeMenus
(
)
;
}
else
{
ConstructFallbackNativeMenus
(
)
;
}
static_cast
<
nsCocoaWindow
*
>
(
mParentWindow
)
-
>
SetMenuBar
(
this
)
;
return
NS_OK
;
}
void
nsMenuBarX
:
:
ConstructNativeMenus
(
)
{
for
(
nsIContent
*
menuContent
=
mContent
-
>
GetFirstChild
(
)
;
menuContent
;
menuContent
=
menuContent
-
>
GetNextSibling
(
)
)
{
if
(
menuContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
{
nsMenuX
*
newMenu
=
new
nsMenuX
(
)
;
if
(
newMenu
)
{
nsresult
rv
=
newMenu
-
>
Create
(
this
this
menuContent
-
>
AsElement
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
InsertMenuAtIndex
(
newMenu
GetMenuCount
(
)
)
;
else
delete
newMenu
;
}
}
}
}
void
nsMenuBarX
:
:
ConstructFallbackNativeMenus
(
)
{
if
(
sApplicationMenu
)
{
return
;
}
nsCOMPtr
<
nsIStringBundle
>
stringBundle
;
nsCOMPtr
<
nsIStringBundleService
>
bundleSvc
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
)
;
bundleSvc
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
fallbackMenubar
.
properties
"
getter_AddRefs
(
stringBundle
)
)
;
if
(
!
stringBundle
)
{
return
;
}
nsAutoString
labelUTF16
;
nsAutoString
keyUTF16
;
const
char
*
labelProp
=
"
quitMenuitem
.
label
"
;
const
char
*
keyProp
=
"
quitMenuitem
.
key
"
;
stringBundle
-
>
GetStringFromName
(
labelProp
labelUTF16
)
;
stringBundle
-
>
GetStringFromName
(
keyProp
keyUTF16
)
;
NSString
*
labelStr
=
[
NSString
stringWithUTF8String
:
NS_ConvertUTF16toUTF8
(
labelUTF16
)
.
get
(
)
]
;
NSString
*
keyStr
=
[
NSString
stringWithUTF8String
:
NS_ConvertUTF16toUTF8
(
keyUTF16
)
.
get
(
)
]
;
if
(
!
nsMenuBarX
:
:
sNativeEventTarget
)
{
nsMenuBarX
:
:
sNativeEventTarget
=
[
[
NativeMenuItemTarget
alloc
]
init
]
;
}
sApplicationMenu
=
[
[
[
[
NSApp
mainMenu
]
itemAtIndex
:
0
]
submenu
]
retain
]
;
if
(
!
mApplicationMenuDelegate
)
{
mApplicationMenuDelegate
=
[
[
ApplicationMenuDelegate
alloc
]
initWithApplicationMenu
:
this
]
;
}
[
sApplicationMenu
setDelegate
:
mApplicationMenuDelegate
]
;
NSMenuItem
*
quitMenuItem
=
[
[
[
NSMenuItem
alloc
]
initWithTitle
:
labelStr
action
:
selector
(
menuItemHit
:
)
keyEquivalent
:
keyStr
]
autorelease
]
;
[
quitMenuItem
setTarget
:
nsMenuBarX
:
:
sNativeEventTarget
]
;
[
quitMenuItem
setTag
:
eCommand_ID_Quit
]
;
[
sApplicationMenu
addItem
:
quitMenuItem
]
;
sApplicationMenuIsFallback
=
YES
;
}
uint32_t
nsMenuBarX
:
:
GetMenuCount
(
)
{
return
mMenuArray
.
Length
(
)
;
}
bool
nsMenuBarX
:
:
MenuContainsAppMenu
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
return
(
[
mNativeMenu
numberOfItems
]
>
0
&
&
[
[
mNativeMenu
itemAtIndex
:
0
]
submenu
]
=
=
sApplicationMenu
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
nsresult
nsMenuBarX
:
:
InsertMenuAtIndex
(
nsMenuX
*
aMenu
uint32_t
aIndex
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
if
(
sApplicationMenu
&
&
sApplicationMenuIsFallback
)
{
ResetNativeApplicationMenu
(
)
;
}
if
(
!
sApplicationMenu
)
{
nsresult
rv
=
NS_OK
;
rv
=
CreateApplicationMenu
(
aMenu
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Can
'
t
create
Application
menu
"
)
;
NSMenu
*
mainMenu
=
[
NSApp
mainMenu
]
;
NS_ASSERTION
(
[
mainMenu
numberOfItems
]
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
[
[
mainMenu
itemAtIndex
:
0
]
setSubmenu
:
sApplicationMenu
]
;
}
mMenuArray
.
InsertElementAt
(
aIndex
aMenu
)
;
nsIContent
*
menuContent
=
aMenu
-
>
Content
(
)
;
if
(
menuContent
-
>
GetChildCount
(
)
>
0
&
&
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
menuContent
)
)
{
int
insertionIndex
=
nsMenuUtilsX
:
:
CalculateNativeInsertionPoint
(
this
aMenu
)
;
if
(
MenuContainsAppMenu
(
)
)
insertionIndex
+
+
;
[
mNativeMenu
insertItem
:
aMenu
-
>
NativeMenuItem
(
)
atIndex
:
insertionIndex
]
;
}
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsMenuBarX
:
:
RemoveMenuAtIndex
(
uint32_t
aIndex
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mMenuArray
.
Length
(
)
<
=
aIndex
)
{
NS_ERROR
(
"
Attempting
submenu
removal
with
bad
index
!
"
)
;
return
;
}
NSMenuItem
*
nativeMenuItem
=
mMenuArray
[
aIndex
]
-
>
NativeMenuItem
(
)
;
int
nativeMenuItemIndex
=
[
mNativeMenu
indexOfItem
:
nativeMenuItem
]
;
if
(
nativeMenuItemIndex
!
=
-
1
)
[
mNativeMenu
removeItemAtIndex
:
nativeMenuItemIndex
]
;
mMenuArray
.
RemoveElementAt
(
aIndex
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuBarX
:
:
ObserveAttributeChanged
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
nsAtom
*
aAttribute
)
{
}
void
nsMenuBarX
:
:
ObserveContentRemoved
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
nsINode
*
parent
=
NODE_FROM
(
aContainer
aDocument
)
;
MOZ_ASSERT
(
parent
)
;
int32_t
index
=
parent
-
>
ComputeIndexOf
(
aPreviousSibling
)
+
1
;
RemoveMenuAtIndex
(
index
)
;
}
void
nsMenuBarX
:
:
ObserveContentInserted
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
nsMenuX
*
newMenu
=
new
nsMenuX
(
)
;
if
(
newMenu
)
{
nsresult
rv
=
newMenu
-
>
Create
(
this
this
aChild
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
InsertMenuAtIndex
(
newMenu
aContainer
-
>
ComputeIndexOf
(
aChild
)
)
;
else
delete
newMenu
;
}
}
void
nsMenuBarX
:
:
ForceUpdateNativeMenuAt
(
const
nsAString
&
indexString
)
{
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
indexString
.
BeginReading
(
)
)
length
:
indexString
.
Length
(
)
]
;
NSArray
*
indexes
=
[
locationString
componentsSeparatedByString
:
"
|
"
]
;
unsigned
int
indexCount
=
[
indexes
count
]
;
if
(
indexCount
=
=
0
)
return
;
nsMenuX
*
currentMenu
=
NULL
;
int
targetIndex
=
[
[
indexes
objectAtIndex
:
0
]
intValue
]
;
int
visible
=
0
;
uint32_t
length
=
mMenuArray
.
Length
(
)
;
for
(
unsigned
int
i
=
0
;
i
<
length
;
i
+
+
)
{
nsMenuX
*
menu
=
mMenuArray
[
i
]
.
get
(
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
menu
-
>
Content
(
)
)
)
{
visible
+
+
;
if
(
visible
=
=
(
targetIndex
+
1
)
)
{
currentMenu
=
menu
;
break
;
}
}
}
if
(
!
currentMenu
)
return
;
currentMenu
-
>
MenuOpened
(
)
;
currentMenu
-
>
MenuClosed
(
)
;
for
(
unsigned
int
i
=
1
;
currentMenu
&
&
i
<
indexCount
;
i
+
+
)
{
targetIndex
=
[
[
indexes
objectAtIndex
:
i
]
intValue
]
;
visible
=
0
;
length
=
currentMenu
-
>
GetItemCount
(
)
;
for
(
unsigned
int
j
=
0
;
j
<
length
;
j
+
+
)
{
nsMenuObjectX
*
targetMenu
=
currentMenu
-
>
GetItemAt
(
j
)
;
if
(
!
targetMenu
)
return
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
targetMenu
-
>
Content
(
)
)
)
{
visible
+
+
;
if
(
targetMenu
-
>
MenuObjectType
(
)
=
=
eSubmenuObjectType
&
&
visible
=
=
(
targetIndex
+
1
)
)
{
currentMenu
=
static_cast
<
nsMenuX
*
>
(
targetMenu
)
;
currentMenu
-
>
MenuOpened
(
)
;
currentMenu
-
>
MenuClosed
(
)
;
break
;
}
}
}
}
}
void
nsMenuBarX
:
:
ForceNativeMenuReload
(
)
{
while
(
GetMenuCount
(
)
>
0
)
RemoveMenuAtIndex
(
0
)
;
ConstructNativeMenus
(
)
;
}
nsMenuX
*
nsMenuBarX
:
:
GetMenuAt
(
uint32_t
aIndex
)
{
if
(
mMenuArray
.
Length
(
)
<
=
aIndex
)
{
NS_ERROR
(
"
Requesting
menu
at
invalid
index
!
"
)
;
return
NULL
;
}
return
mMenuArray
[
aIndex
]
.
get
(
)
;
}
nsMenuX
*
nsMenuBarX
:
:
GetXULHelpMenu
(
)
{
for
(
int32_t
i
=
GetMenuCount
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsMenuX
*
aMenu
=
GetMenuAt
(
i
)
;
if
(
aMenu
&
&
nsMenuX
:
:
IsXULHelpMenu
(
aMenu
-
>
Content
(
)
)
)
return
aMenu
;
}
return
nil
;
}
void
nsMenuBarX
:
:
SetSystemHelpMenu
(
)
{
nsMenuX
*
xulHelpMenu
=
GetXULHelpMenu
(
)
;
if
(
xulHelpMenu
)
{
NSMenu
*
helpMenu
=
(
NSMenu
*
)
xulHelpMenu
-
>
NativeData
(
)
;
if
(
helpMenu
)
[
NSApp
setHelpMenu
:
helpMenu
]
;
}
}
nsresult
nsMenuBarX
:
:
Paint
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
NSMenu
*
outgoingMenu
=
[
NSApp
mainMenu
]
;
NS_ASSERTION
(
[
outgoingMenu
numberOfItems
]
>
0
"
Main
menu
does
not
have
any
items
something
is
terribly
wrong
!
"
)
;
NSMenuItem
*
appMenuItem
=
[
[
outgoingMenu
itemAtIndex
:
0
]
retain
]
;
[
outgoingMenu
removeItemAtIndex
:
0
]
;
[
mNativeMenu
insertItem
:
appMenuItem
atIndex
:
0
]
;
[
appMenuItem
release
]
;
[
NSApp
setMainMenu
:
mNativeMenu
]
;
SetSystemHelpMenu
(
)
;
nsMenuBarX
:
:
sLastGeckoMenuBarPainted
=
this
;
gSomeMenuBarPainted
=
YES
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
char
nsMenuBarX
:
:
GetLocalizedAccelKey
(
const
char
*
shortcutID
)
{
if
(
!
sLastGeckoMenuBarPainted
)
return
0
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Document
>
doc
=
sLastGeckoMenuBarPainted
-
>
mContent
-
>
OwnerDoc
(
)
;
if
(
!
doc
)
return
0
;
NS_ConvertASCIItoUTF16
shortcutIDStr
(
shortcutID
)
;
nsCOMPtr
<
Element
>
shortcutContent
=
doc
-
>
GetElementById
(
shortcutIDStr
)
;
if
(
!
shortcutContent
)
return
0
;
nsAutoString
key
;
shortcutContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
key
)
;
NS_LossyConvertUTF16toASCII
keyASC
(
key
.
get
(
)
)
;
const
char
*
keyASCPtr
=
keyASC
.
get
(
)
;
if
(
!
keyASCPtr
)
return
0
;
if
(
strlen
(
keyASCPtr
)
!
=
sizeof
(
char
)
)
return
0
;
char
retval
=
tolower
(
keyASCPtr
[
0
]
)
;
return
retval
;
}
void
nsMenuBarX
:
:
ResetNativeApplicationMenu
(
)
{
[
sApplicationMenu
removeAllItems
]
;
[
sApplicationMenu
release
]
;
sApplicationMenu
=
nil
;
sApplicationMenuIsFallback
=
NO
;
}
void
nsMenuBarX
:
:
SetNeedsRebuild
(
)
{
mNeedsRebuild
=
true
;
}
void
nsMenuBarX
:
:
ApplicationMenuOpened
(
)
{
if
(
mNeedsRebuild
)
{
if
(
!
mMenuArray
.
IsEmpty
(
)
)
{
ResetNativeApplicationMenu
(
)
;
CreateApplicationMenu
(
mMenuArray
[
0
]
.
get
(
)
)
;
}
mNeedsRebuild
=
false
;
}
}
bool
nsMenuBarX
:
:
PerformKeyEquivalent
(
NSEvent
*
theEvent
)
{
return
[
mNativeMenu
performSuperKeyEquivalent
:
theEvent
]
;
}
void
nsMenuBarX
:
:
HideItem
(
mozilla
:
:
dom
:
:
Document
*
inDoc
const
nsAString
&
inID
nsIContent
*
*
outHiddenNode
)
{
nsCOMPtr
<
Element
>
menuElement
=
inDoc
-
>
GetElementById
(
inID
)
;
if
(
menuElement
)
{
menuElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
u
"
true
"
_ns
false
)
;
if
(
outHiddenNode
)
{
*
outHiddenNode
=
menuElement
.
get
(
)
;
NS_IF_ADDREF
(
*
outHiddenNode
)
;
}
}
}
void
nsMenuBarX
:
:
AquifyMenuBar
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
domDoc
=
mContent
-
>
GetComposedDoc
(
)
;
if
(
domDoc
)
{
HideItem
(
domDoc
u
"
aboutSeparator
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
aboutName
"
_ns
getter_AddRefs
(
mAboutItemContent
)
)
;
if
(
!
sAboutItemContent
)
sAboutItemContent
=
mAboutItemContent
;
HideItem
(
domDoc
u
"
menu_FileQuitSeparator
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
menu_FileQuitItem
"
_ns
getter_AddRefs
(
mQuitItemContent
)
)
;
if
(
!
sQuitItemContent
)
sQuitItemContent
=
mQuitItemContent
;
HideItem
(
domDoc
u
"
menu_PrefsSeparator
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
menu_preferences
"
_ns
getter_AddRefs
(
mPrefItemContent
)
)
;
if
(
!
sPrefItemContent
)
sPrefItemContent
=
mPrefItemContent
;
HideItem
(
domDoc
u
"
menu_mac_services
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
menu_mac_hide_app
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
menu_mac_hide_others
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
menu_mac_show_all
"
_ns
nullptr
)
;
HideItem
(
domDoc
u
"
menu_mac_touch_bar
"
_ns
nullptr
)
;
}
}
NSMenuItem
*
nsMenuBarX
:
:
CreateNativeAppMenuItem
(
nsMenuX
*
inMenu
const
nsAString
&
nodeID
SEL
action
int
tag
NativeMenuItemTarget
*
target
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
doc
=
inMenu
-
>
Content
(
)
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nil
;
}
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
menuItem
=
doc
-
>
GetElementById
(
nodeID
)
;
if
(
!
menuItem
)
{
return
nil
;
}
if
(
menuItem
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
collapsed
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
nil
;
}
nsAutoString
label
;
nsAutoString
modifiers
;
nsAutoString
key
;
menuItem
-
>
GetAttr
(
nsGkAtoms
:
:
label
label
)
;
menuItem
-
>
GetAttr
(
nsGkAtoms
:
:
modifiers
modifiers
)
;
menuItem
-
>
GetAttr
(
nsGkAtoms
:
:
key
key
)
;
NSString
*
keyEquiv
=
nil
;
unsigned
int
macKeyModifiers
=
0
;
if
(
!
key
.
IsEmpty
(
)
)
{
RefPtr
<
Element
>
keyElement
=
doc
-
>
GetElementById
(
key
)
;
if
(
keyElement
)
{
nsAutoString
keyChar
(
u
"
"
_ns
)
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
keyChar
)
;
if
(
!
keyChar
.
EqualsLiteral
(
"
"
)
)
{
keyEquiv
=
[
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
keyChar
.
get
(
)
)
length
:
keyChar
.
Length
(
)
]
lowercaseString
]
;
}
nsAutoString
modifiersStr
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
modifiers
modifiersStr
)
;
uint8_t
geckoModifiers
=
nsMenuUtilsX
:
:
GeckoModifiersForNodeAttribute
(
modifiersStr
)
;
macKeyModifiers
=
nsMenuUtilsX
:
:
MacModifiersForGeckoModifiers
(
geckoModifiers
)
;
}
}
NSString
*
labelString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
label
.
get
(
)
)
length
:
label
.
Length
(
)
]
;
if
(
!
labelString
)
labelString
=
"
"
;
if
(
!
keyEquiv
)
keyEquiv
=
"
"
;
NSMenuItem
*
newMenuItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
labelString
action
:
action
keyEquivalent
:
keyEquiv
]
;
[
newMenuItem
setTag
:
tag
]
;
[
newMenuItem
setTarget
:
target
]
;
[
newMenuItem
setKeyEquivalentModifierMask
:
macKeyModifiers
]
;
MenuItemInfo
*
info
=
[
[
MenuItemInfo
alloc
]
initWithMenuGroupOwner
:
this
]
;
[
newMenuItem
setRepresentedObject
:
info
]
;
[
info
release
]
;
return
newMenuItem
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
nsresult
nsMenuBarX
:
:
CreateApplicationMenu
(
nsMenuX
*
inMenu
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
sApplicationMenu
=
[
[
[
[
NSApp
mainMenu
]
itemAtIndex
:
0
]
submenu
]
retain
]
;
if
(
sApplicationMenu
)
{
if
(
!
mApplicationMenuDelegate
)
{
mApplicationMenuDelegate
=
[
[
ApplicationMenuDelegate
alloc
]
initWithApplicationMenu
:
this
]
;
}
[
sApplicationMenu
setDelegate
:
mApplicationMenuDelegate
]
;
NSMenuItem
*
itemBeingAdded
=
nil
;
BOOL
addAboutSeparator
=
FALSE
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
aboutName
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_About
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addAboutSeparator
=
TRUE
;
}
if
(
addAboutSeparator
)
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_preferences
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_Prefs
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_mac_services
"
_ns
nil
0
nil
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
NSMenu
*
servicesMenu
=
[
[
GeckoServicesNSMenu
alloc
]
initWithTitle
:
"
"
]
;
[
itemBeingAdded
setSubmenu
:
servicesMenu
]
;
[
NSApp
setServicesMenu
:
servicesMenu
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
}
BOOL
addHideShowSeparator
=
FALSE
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_mac_hide_app
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_HideApp
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addHideShowSeparator
=
TRUE
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_mac_hide_others
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_HideOthers
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addHideShowSeparator
=
TRUE
;
}
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_mac_show_all
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_ShowAll
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
addHideShowSeparator
=
TRUE
;
}
if
(
addHideShowSeparator
)
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
BOOL
addTouchBarSeparator
=
NO
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_mac_touch_bar
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_TouchBar
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
if
(
!
sTouchBarIsInitialized
)
{
[
itemBeingAdded
setHidden
:
YES
]
;
}
else
{
addTouchBarSeparator
=
YES
;
}
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
}
if
(
addTouchBarSeparator
)
[
sApplicationMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
itemBeingAdded
=
CreateNativeAppMenuItem
(
inMenu
u
"
menu_FileQuitItem
"
_ns
selector
(
menuItemHit
:
)
eCommand_ID_Quit
nsMenuBarX
:
:
sNativeEventTarget
)
;
if
(
itemBeingAdded
)
{
[
sApplicationMenu
addItem
:
itemBeingAdded
]
;
[
itemBeingAdded
release
]
;
itemBeingAdded
=
nil
;
}
else
{
NSMenuItem
*
defaultQuitItem
=
[
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Quit
"
action
:
selector
(
menuItemHit
:
)
keyEquivalent
:
"
q
"
]
autorelease
]
;
[
defaultQuitItem
setTarget
:
nsMenuBarX
:
:
sNativeEventTarget
]
;
[
defaultQuitItem
setTag
:
eCommand_ID_Quit
]
;
[
sApplicationMenu
addItem
:
defaultQuitItem
]
;
}
}
return
(
sApplicationMenu
)
?
NS_OK
:
NS_ERROR_FAILURE
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
void
nsMenuBarX
:
:
SetParent
(
nsIWidget
*
aParent
)
{
mParentWindow
=
aParent
;
}
static
BOOL
gMenuItemsExecuteCommands
=
YES
;
implementation
GeckoNSMenu
-
(
BOOL
)
performKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
if
(
[
self
numberOfItems
]
<
=
0
)
{
return
NO
;
}
NSWindow
*
keyWindow
=
[
NSApp
keyWindow
]
;
if
(
!
keyWindow
)
{
return
[
super
performKeyEquivalent
:
theEvent
]
;
}
NSResponder
*
firstResponder
=
[
keyWindow
firstResponder
]
;
gMenuItemsExecuteCommands
=
NO
;
[
super
performKeyEquivalent
:
theEvent
]
;
gMenuItemsExecuteCommands
=
YES
;
if
(
!
[
NSApp
keyWindow
]
|
|
[
[
NSApp
keyWindow
]
firstResponder
]
!
=
firstResponder
)
{
return
YES
;
}
return
NO
;
}
-
(
BOOL
)
performSuperKeyEquivalent
:
(
NSEvent
*
)
theEvent
{
return
[
super
performKeyEquivalent
:
theEvent
]
;
}
end
implementation
NativeMenuItemTarget
-
(
IBAction
)
menuItemHit
:
(
id
)
sender
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
gMenuItemsExecuteCommands
)
{
return
;
}
int
tag
=
[
sender
tag
]
;
nsMenuGroupOwnerX
*
menuGroupOwner
=
nullptr
;
nsMenuBarX
*
menuBar
=
nullptr
;
MenuItemInfo
*
info
=
[
sender
representedObject
]
;
if
(
info
)
{
menuGroupOwner
=
[
info
menuGroupOwner
]
;
if
(
!
menuGroupOwner
)
{
return
;
}
if
(
menuGroupOwner
-
>
MenuObjectType
(
)
=
=
eMenuBarObjectType
)
{
menuBar
=
static_cast
<
nsMenuBarX
*
>
(
menuGroupOwner
)
;
}
}
if
(
tag
=
=
eCommand_ID_About
)
{
nsIContent
*
mostSpecificContent
=
sAboutItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mAboutItemContent
)
mostSpecificContent
=
menuBar
-
>
mAboutItemContent
;
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
)
;
return
;
}
else
if
(
tag
=
=
eCommand_ID_Prefs
)
{
nsIContent
*
mostSpecificContent
=
sPrefItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mPrefItemContent
)
mostSpecificContent
=
menuBar
-
>
mPrefItemContent
;
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
)
;
return
;
}
else
if
(
tag
=
=
eCommand_ID_HideApp
)
{
[
NSApp
hide
:
sender
]
;
return
;
}
else
if
(
tag
=
=
eCommand_ID_HideOthers
)
{
[
NSApp
hideOtherApplications
:
sender
]
;
return
;
}
else
if
(
tag
=
=
eCommand_ID_ShowAll
)
{
[
NSApp
unhideAllApplications
:
sender
]
;
return
;
}
else
if
(
tag
=
=
eCommand_ID_TouchBar
)
{
[
NSApp
toggleTouchBarCustomizationPalette
:
sender
]
;
return
;
}
else
if
(
tag
=
=
eCommand_ID_Quit
)
{
nsIContent
*
mostSpecificContent
=
sQuitItemContent
;
if
(
menuBar
&
&
menuBar
-
>
mQuitItemContent
)
mostSpecificContent
=
menuBar
-
>
mQuitItemContent
;
if
(
mostSpecificContent
)
{
nsMenuUtilsX
:
:
DispatchCommandTo
(
mostSpecificContent
)
;
}
else
{
nsCOMPtr
<
nsIAppStartup
>
appStartup
=
mozilla
:
:
components
:
:
AppStartup
:
:
Service
(
)
;
if
(
appStartup
)
{
bool
userAllowedQuit
=
true
;
appStartup
-
>
Quit
(
nsIAppStartup
:
:
eAttemptQuit
&
userAllowedQuit
)
;
}
}
return
;
}
if
(
menuGroupOwner
)
{
nsMenuItemX
*
menuItem
=
menuGroupOwner
-
>
GetMenuItemForCommandID
(
static_cast
<
uint32_t
>
(
tag
)
)
;
if
(
menuItem
)
menuItem
-
>
DoCommand
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
end
implementation
GeckoServicesNSMenuItem
-
(
id
)
target
{
id
realTarget
=
[
super
target
]
;
if
(
gMenuItemsExecuteCommands
)
return
realTarget
;
else
return
realTarget
?
self
:
nil
;
}
-
(
SEL
)
action
{
SEL
realAction
=
[
super
action
]
;
if
(
gMenuItemsExecuteCommands
)
return
realAction
;
else
return
realAction
?
selector
(
_doNothing
:
)
:
NULL
;
}
-
(
void
)
_doNothing
:
(
id
)
sender
{
}
end
implementation
GeckoServicesNSMenu
-
(
void
)
addItem
:
(
NSMenuItem
*
)
newItem
{
[
self
_overrideClassOfMenuItem
:
newItem
]
;
[
super
addItem
:
newItem
]
;
}
-
(
NSMenuItem
*
)
addItemWithTitle
:
(
NSString
*
)
aString
action
:
(
SEL
)
aSelector
keyEquivalent
:
(
NSString
*
)
keyEquiv
{
NSMenuItem
*
newItem
=
[
super
addItemWithTitle
:
aString
action
:
aSelector
keyEquivalent
:
keyEquiv
]
;
[
self
_overrideClassOfMenuItem
:
newItem
]
;
return
newItem
;
}
-
(
void
)
insertItem
:
(
NSMenuItem
*
)
newItem
atIndex
:
(
NSInteger
)
index
{
[
self
_overrideClassOfMenuItem
:
newItem
]
;
[
super
insertItem
:
newItem
atIndex
:
index
]
;
}
-
(
NSMenuItem
*
)
insertItemWithTitle
:
(
NSString
*
)
aString
action
:
(
SEL
)
aSelector
keyEquivalent
:
(
NSString
*
)
keyEquiv
atIndex
:
(
NSInteger
)
index
{
NSMenuItem
*
newItem
=
[
super
insertItemWithTitle
:
aString
action
:
aSelector
keyEquivalent
:
keyEquiv
atIndex
:
index
]
;
[
self
_overrideClassOfMenuItem
:
newItem
]
;
return
newItem
;
}
-
(
void
)
_overrideClassOfMenuItem
:
(
NSMenuItem
*
)
menuItem
{
if
(
[
menuItem
class
]
=
=
[
NSMenuItem
class
]
)
object_setClass
(
menuItem
[
GeckoServicesNSMenuItem
class
]
)
;
}
end
