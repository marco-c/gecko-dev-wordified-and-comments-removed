#
include
<
dlfcn
.
h
>
#
include
"
nsMenuX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsMenuItemIconX
.
h
"
#
include
"
nsStandaloneNativeMenu
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsBaseWidget
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
bool
gConstructingMenu
=
false
;
static
bool
gMenuMethodsSwizzled
=
false
;
int32_t
nsMenuX
:
:
sIndexingMenuLevel
=
0
;
implementation
MenuItemInfo
-
(
id
)
initWithMenuGroupOwner
:
(
nsMenuGroupOwnerX
*
)
aMenuGroupOwner
{
if
(
(
self
=
[
super
init
]
)
!
=
nil
)
{
[
self
setMenuGroupOwner
:
aMenuGroupOwner
]
;
}
return
self
;
}
-
(
void
)
dealloc
{
[
self
setMenuGroupOwner
:
nullptr
]
;
[
super
dealloc
]
;
}
-
(
nsMenuGroupOwnerX
*
)
menuGroupOwner
{
return
mMenuGroupOwner
;
}
-
(
void
)
setMenuGroupOwner
:
(
nsMenuGroupOwnerX
*
)
aMenuGroupOwner
{
mMenuGroupOwner
=
aMenuGroupOwner
;
if
(
aMenuGroupOwner
)
{
aMenuGroupOwner
-
>
AddMenuItemInfoToSet
(
self
)
;
}
}
end
nsMenuX
:
:
nsMenuX
(
)
:
mVisibleItemsCount
(
0
)
mParent
(
nullptr
)
mMenuGroupOwner
(
nullptr
)
mNativeMenu
(
nil
)
mNativeMenuItem
(
nil
)
mIsEnabled
(
true
)
mDestroyHandlerCalled
(
false
)
mNeedsRebuild
(
true
)
mConstructed
(
false
)
mVisible
(
true
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
gMenuMethodsSwizzled
)
{
nsToolkit
:
:
SwizzleMethods
(
[
NSMenu
class
]
selector
(
_addItem
:
toTable
:
)
selector
(
nsMenuX_NSMenu_addItem
:
toTable
:
)
true
)
;
nsToolkit
:
:
SwizzleMethods
(
[
NSMenu
class
]
selector
(
_removeItem
:
fromTable
:
)
selector
(
nsMenuX_NSMenu_removeItem
:
fromTable
:
)
true
)
;
dlopen
(
"
/
System
/
Library
/
PrivateFrameworks
/
Shortcut
.
framework
/
Shortcut
"
RTLD_LAZY
)
;
Class
SCTGRLIndexClass
=
:
:
NSClassFromString
(
"
SCTGRLIndex
"
)
;
nsToolkit
:
:
SwizzleMethods
(
SCTGRLIndexClass
selector
(
indexMenuBarDynamically
)
selector
(
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
)
)
;
gMenuMethodsSwizzled
=
true
;
}
mMenuDelegate
=
[
[
MenuDelegate
alloc
]
initWithGeckoMenu
:
this
]
;
if
(
!
nsMenuBarX
:
:
sNativeEventTarget
)
{
nsMenuBarX
:
:
sNativeEventTarget
=
[
[
NativeMenuItemTarget
alloc
]
init
]
;
}
MOZ_COUNT_CTOR
(
nsMenuX
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsMenuX
:
:
~
nsMenuX
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mIcon
)
{
mIcon
-
>
Destroy
(
)
;
}
RemoveAll
(
)
;
[
mNativeMenu
setDelegate
:
nil
]
;
[
mNativeMenu
release
]
;
[
mMenuDelegate
release
]
;
[
mNativeMenuItem
autorelease
]
;
if
(
mContent
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mContent
)
;
}
MOZ_COUNT_DTOR
(
nsMenuX
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsresult
nsMenuX
:
:
Create
(
nsMenuObjectX
*
aParent
nsMenuGroupOwnerX
*
aMenuGroupOwner
nsIContent
*
aContent
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
mContent
=
aContent
;
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
mLabel
)
;
}
mNativeMenu
=
CreateMenuWithGeckoString
(
mLabel
)
;
mMenuGroupOwner
=
aMenuGroupOwner
;
NS_ASSERTION
(
mMenuGroupOwner
"
No
menu
owner
given
must
have
one
"
)
;
mMenuGroupOwner
-
>
RegisterForContentChanges
(
mContent
this
)
;
mParent
=
aParent
;
#
ifdef
DEBUG
nsMenuObjectTypeX
parentType
=
#
endif
mParent
-
>
MenuObjectType
(
)
;
NS_ASSERTION
(
(
parentType
=
=
eMenuBarObjectType
|
|
parentType
=
=
eSubmenuObjectType
|
|
parentType
=
=
eStandaloneNativeMenuObjectType
)
"
Menu
parent
not
a
menu
bar
menu
or
native
menu
!
"
)
;
if
(
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
)
{
mVisible
=
false
;
}
if
(
mContent
-
>
GetChildCount
(
)
=
=
0
)
{
mVisible
=
false
;
}
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
mLabel
)
;
mNativeMenuItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
newCocoaLabelString
action
:
nil
keyEquivalent
:
"
"
]
;
[
mNativeMenuItem
setSubmenu
:
mNativeMenu
]
;
SetEnabled
(
!
mContent
-
>
IsElement
(
)
|
|
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
MenuConstruct
(
)
;
mIcon
=
new
nsMenuItemIconX
(
this
mContent
mNativeMenuItem
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsMenuX
:
:
AddMenuItem
(
nsMenuItemX
*
aMenuItem
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
aMenuItem
)
{
return
NS_ERROR_INVALID_ARG
;
}
mMenuObjectsArray
.
AppendElement
(
aMenuItem
)
;
if
(
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
aMenuItem
-
>
Content
(
)
)
)
{
return
NS_OK
;
}
+
+
mVisibleItemsCount
;
NSMenuItem
*
newNativeMenuItem
=
(
NSMenuItem
*
)
aMenuItem
-
>
NativeData
(
)
;
[
mNativeMenu
addItem
:
newNativeMenuItem
]
;
[
newNativeMenuItem
setTarget
:
nsMenuBarX
:
:
sNativeEventTarget
]
;
[
newNativeMenuItem
setAction
:
selector
(
menuItemHit
:
)
]
;
[
newNativeMenuItem
setTag
:
mMenuGroupOwner
-
>
RegisterForCommand
(
aMenuItem
)
]
;
MenuItemInfo
*
info
=
[
[
MenuItemInfo
alloc
]
initWithMenuGroupOwner
:
mMenuGroupOwner
]
;
[
newNativeMenuItem
setRepresentedObject
:
info
]
;
[
info
release
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsMenuX
*
nsMenuX
:
:
AddMenu
(
UniquePtr
<
nsMenuX
>
aMenu
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsMenuX
*
menu
=
aMenu
.
get
(
)
;
mMenuObjectsArray
.
AppendElement
(
std
:
:
move
(
aMenu
)
)
;
if
(
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
menu
-
>
Content
(
)
)
)
{
return
menu
;
}
+
+
mVisibleItemsCount
;
NSMenuItem
*
newNativeMenuItem
=
menu
-
>
NativeMenuItem
(
)
;
if
(
newNativeMenuItem
)
{
[
mNativeMenu
addItem
:
newNativeMenuItem
]
;
[
newNativeMenuItem
setSubmenu
:
(
NSMenu
*
)
menu
-
>
NativeData
(
)
]
;
}
return
menu
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nullptr
)
;
}
uint32_t
nsMenuX
:
:
GetItemCount
(
)
{
return
mMenuObjectsArray
.
Length
(
)
;
}
nsMenuObjectX
*
nsMenuX
:
:
GetItemAt
(
uint32_t
aPos
)
{
if
(
aPos
>
=
(
uint32_t
)
mMenuObjectsArray
.
Length
(
)
)
{
return
nullptr
;
}
return
mMenuObjectsArray
[
aPos
]
.
get
(
)
;
}
nsresult
nsMenuX
:
:
GetVisibleItemCount
(
uint32_t
&
aCount
)
{
aCount
=
mVisibleItemsCount
;
return
NS_OK
;
}
nsMenuObjectX
*
nsMenuX
:
:
GetVisibleItemAt
(
uint32_t
aPos
)
{
uint32_t
count
=
mMenuObjectsArray
.
Length
(
)
;
if
(
aPos
>
=
mVisibleItemsCount
|
|
aPos
>
=
count
)
{
return
nullptr
;
}
if
(
mVisibleItemsCount
=
=
count
)
{
return
mMenuObjectsArray
[
aPos
]
.
get
(
)
;
}
nsMenuObjectX
*
item
;
uint32_t
visibleNodeIndex
=
0
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
item
=
mMenuObjectsArray
[
i
]
.
get
(
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
item
-
>
Content
(
)
)
)
{
if
(
aPos
=
=
visibleNodeIndex
)
{
return
item
;
}
visibleNodeIndex
+
+
;
}
}
return
nullptr
;
}
nsresult
nsMenuX
:
:
RemoveAll
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
mNativeMenu
)
{
int
itemCount
=
[
mNativeMenu
numberOfItems
]
;
for
(
int
i
=
0
;
i
<
itemCount
;
i
+
+
)
{
mMenuGroupOwner
-
>
UnregisterCommand
(
(
uint32_t
)
[
[
mNativeMenu
itemAtIndex
:
i
]
tag
]
)
;
}
for
(
int
i
=
[
mNativeMenu
numberOfItems
]
-
1
;
i
>
=
0
;
i
-
-
)
{
[
mNativeMenu
removeItemAtIndex
:
i
]
;
}
}
mMenuObjectsArray
.
Clear
(
)
;
mVisibleItemsCount
=
0
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsEventStatus
nsMenuX
:
:
MenuOpened
(
)
{
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
open
u
"
true
"
_ns
true
)
;
}
bool
keepProcessing
=
OnOpen
(
)
;
if
(
!
mNeedsRebuild
|
|
!
keepProcessing
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
if
(
!
mConstructed
|
|
mNeedsRebuild
)
{
if
(
mNeedsRebuild
)
{
RemoveAll
(
)
;
}
MenuConstruct
(
)
;
mConstructed
=
true
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShown
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
popupContent
;
GetMenuPopupContent
(
getter_AddRefs
(
popupContent
)
)
;
nsIContent
*
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
void
nsMenuX
:
:
MenuClosed
(
)
{
if
(
mConstructed
)
{
if
(
!
OnClose
(
)
)
{
return
;
}
if
(
mNeedsRebuild
)
{
mConstructed
=
false
;
}
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
open
true
)
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupHidden
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
popupContent
;
GetMenuPopupContent
(
getter_AddRefs
(
popupContent
)
)
;
nsIContent
*
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
mDestroyHandlerCalled
=
true
;
mConstructed
=
false
;
}
}
void
nsMenuX
:
:
MenuConstruct
(
)
{
mConstructed
=
false
;
gConstructingMenu
=
true
;
mDestroyHandlerCalled
=
false
;
nsCOMPtr
<
nsIContent
>
menuPopup
;
GetMenuPopupContent
(
getter_AddRefs
(
menuPopup
)
)
;
if
(
!
menuPopup
)
{
gConstructingMenu
=
false
;
return
;
}
for
(
nsIContent
*
child
=
menuPopup
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menuitem
nsGkAtoms
:
:
menuseparator
)
)
{
LoadMenuItem
(
child
)
;
}
else
if
(
child
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
{
LoadSubMenu
(
child
)
;
}
}
gConstructingMenu
=
false
;
mNeedsRebuild
=
false
;
}
void
nsMenuX
:
:
SetRebuild
(
bool
aNeedsRebuild
)
{
if
(
!
gConstructingMenu
)
{
mNeedsRebuild
=
aNeedsRebuild
;
if
(
mParent
-
>
MenuObjectType
(
)
=
=
eMenuBarObjectType
)
{
nsMenuBarX
*
mb
=
static_cast
<
nsMenuBarX
*
>
(
mParent
)
;
mb
-
>
SetNeedsRebuild
(
)
;
}
}
}
nsresult
nsMenuX
:
:
SetEnabled
(
bool
aIsEnabled
)
{
if
(
aIsEnabled
!
=
mIsEnabled
)
{
mIsEnabled
=
aIsEnabled
;
[
mNativeMenuItem
setEnabled
:
(
BOOL
)
mIsEnabled
]
;
}
return
NS_OK
;
}
nsresult
nsMenuX
:
:
GetEnabled
(
bool
*
aIsEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aIsEnabled
)
;
*
aIsEnabled
=
mIsEnabled
;
return
NS_OK
;
}
GeckoNSMenu
*
nsMenuX
:
:
CreateMenuWithGeckoString
(
nsString
&
menuTitle
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSString
*
title
=
[
NSString
stringWithCharacters
:
(
UniChar
*
)
menuTitle
.
get
(
)
length
:
menuTitle
.
Length
(
)
]
;
GeckoNSMenu
*
myMenu
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
title
]
;
[
myMenu
setDelegate
:
mMenuDelegate
]
;
[
myMenu
setAutoenablesItems
:
NO
]
;
return
myMenu
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
void
nsMenuX
:
:
LoadMenuItem
(
nsIContent
*
inMenuItemContent
)
{
if
(
!
inMenuItemContent
)
{
return
;
}
nsAutoString
menuitemName
;
if
(
inMenuItemContent
-
>
IsElement
(
)
)
{
inMenuItemContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
menuitemName
)
;
}
EMenuItemType
itemType
=
eRegularMenuItemType
;
if
(
inMenuItemContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menuseparator
)
)
{
itemType
=
eSeparatorMenuItemType
;
}
else
if
(
inMenuItemContent
-
>
IsElement
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
radio
nullptr
}
;
switch
(
inMenuItemContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
type
strings
eCaseMatters
)
)
{
case
0
:
itemType
=
eCheckboxMenuItemType
;
break
;
case
1
:
itemType
=
eRadioMenuItemType
;
break
;
}
}
nsMenuItemX
*
menuItem
=
new
nsMenuItemX
(
)
;
if
(
!
menuItem
)
{
return
;
}
nsresult
rv
=
menuItem
-
>
Create
(
this
menuitemName
itemType
mMenuGroupOwner
inMenuItemContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
delete
menuItem
;
return
;
}
AddMenuItem
(
menuItem
)
;
menuItem
-
>
SetupIcon
(
)
;
}
void
nsMenuX
:
:
LoadSubMenu
(
nsIContent
*
inMenuContent
)
{
auto
menu
=
MakeUnique
<
nsMenuX
>
(
)
;
if
(
!
menu
)
{
return
;
}
nsresult
rv
=
menu
-
>
Create
(
this
mMenuGroupOwner
inMenuContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsMenuX
*
menu_ptr
=
AddMenu
(
std
:
:
move
(
menu
)
)
;
if
(
menu_ptr
)
{
menu_ptr
-
>
SetupIcon
(
)
;
}
}
bool
nsMenuX
:
:
OnOpen
(
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShowing
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
popupContent
;
GetMenuPopupContent
(
getter_AddRefs
(
popupContent
)
)
;
nsresult
rv
=
NS_OK
;
nsIContent
*
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
rv
=
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
if
(
NS_FAILED
(
rv
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
GetMenuPopupContent
(
getter_AddRefs
(
popupContent
)
)
;
if
(
!
popupContent
)
{
return
true
;
}
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdateMenuItems
(
popupContent
)
;
}
return
true
;
}
bool
nsMenuX
:
:
OnClose
(
)
{
if
(
mDestroyHandlerCalled
)
{
return
true
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupHiding
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
popupContent
;
GetMenuPopupContent
(
getter_AddRefs
(
popupContent
)
)
;
nsresult
rv
=
NS_OK
;
nsIContent
*
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
rv
=
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
mDestroyHandlerCalled
=
true
;
if
(
NS_FAILED
(
rv
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
return
true
;
}
void
nsMenuX
:
:
GetMenuPopupContent
(
nsIContent
*
*
aResult
)
{
if
(
!
aResult
)
{
return
;
}
*
aResult
=
nullptr
;
if
(
mContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
)
{
NS_ADDREF
(
*
aResult
=
mContent
)
;
return
;
}
for
(
nsIContent
*
child
=
mContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
)
{
NS_ADDREF
(
*
aResult
=
child
)
;
return
;
}
}
}
NSMenuItem
*
nsMenuX
:
:
NativeMenuItem
(
)
{
return
mNativeMenuItem
;
}
bool
nsMenuX
:
:
IsXULHelpMenu
(
nsIContent
*
aMenuContent
)
{
bool
retval
=
false
;
if
(
aMenuContent
&
&
aMenuContent
-
>
IsElement
(
)
)
{
nsAutoString
id
;
aMenuContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
if
(
id
.
Equals
(
u
"
helpMenu
"
_ns
)
)
{
retval
=
true
;
}
}
return
retval
;
}
void
nsMenuX
:
:
ObserveAttributeChanged
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
nsAtom
*
aAttribute
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
gConstructingMenu
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
open
)
)
{
return
;
}
nsMenuObjectTypeX
parentType
=
mParent
-
>
MenuObjectType
(
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
{
SetEnabled
(
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
mLabel
)
;
if
(
parentType
=
=
eMenuBarObjectType
)
{
NS_ASSERTION
(
mNativeMenu
"
nsMenuX
:
:
AttributeChanged
:
invalid
menu
handle
.
"
)
;
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
mLabel
)
;
[
mNativeMenu
setTitle
:
newCocoaLabelString
]
;
}
else
if
(
parentType
=
=
eSubmenuObjectType
)
{
static_cast
<
nsMenuX
*
>
(
mParent
)
-
>
SetRebuild
(
true
)
;
}
else
if
(
parentType
=
=
eStandaloneNativeMenuObjectType
)
{
static_cast
<
nsStandaloneNativeMenu
*
>
(
mParent
)
-
>
GetMenuXObject
(
)
-
>
SetRebuild
(
true
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
hidden
|
|
aAttribute
=
=
nsGkAtoms
:
:
collapsed
)
{
SetRebuild
(
true
)
;
bool
contentIsHiddenOrCollapsed
=
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
;
if
(
contentIsHiddenOrCollapsed
!
=
mVisible
)
{
return
;
}
if
(
contentIsHiddenOrCollapsed
)
{
if
(
parentType
=
=
eMenuBarObjectType
|
|
parentType
=
=
eSubmenuObjectType
|
|
parentType
=
=
eStandaloneNativeMenuObjectType
)
{
NSMenu
*
parentMenu
=
(
NSMenu
*
)
mParent
-
>
NativeData
(
)
;
if
(
[
parentMenu
indexOfItem
:
mNativeMenuItem
]
!
=
-
1
)
{
[
parentMenu
removeItem
:
mNativeMenuItem
]
;
}
mVisible
=
false
;
}
}
else
{
if
(
parentType
=
=
eMenuBarObjectType
|
|
parentType
=
=
eSubmenuObjectType
|
|
parentType
=
=
eStandaloneNativeMenuObjectType
)
{
int
insertionIndex
=
nsMenuUtilsX
:
:
CalculateNativeInsertionPoint
(
mParent
this
)
;
if
(
parentType
=
=
eMenuBarObjectType
)
{
nsMenuBarX
*
mb
=
static_cast
<
nsMenuBarX
*
>
(
mParent
)
;
if
(
mb
-
>
MenuContainsAppMenu
(
)
)
{
insertionIndex
+
+
;
}
}
NSMenu
*
parentMenu
=
(
NSMenu
*
)
mParent
-
>
NativeData
(
)
;
[
parentMenu
insertItem
:
mNativeMenuItem
atIndex
:
insertionIndex
]
;
[
mNativeMenuItem
setSubmenu
:
mNativeMenu
]
;
mVisible
=
true
;
}
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
image
)
{
SetupIcon
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
ObserveContentRemoved
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
gConstructingMenu
)
{
return
;
}
SetRebuild
(
true
)
;
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
aChild
)
;
}
void
nsMenuX
:
:
ObserveContentInserted
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
if
(
gConstructingMenu
)
{
return
;
}
SetRebuild
(
true
)
;
}
nsresult
nsMenuX
:
:
SetupIcon
(
)
{
if
(
!
mIcon
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
mIcon
-
>
SetupIcon
(
)
;
}
implementation
MenuDelegate
-
(
id
)
initWithGeckoMenu
:
(
nsMenuX
*
)
geckoMenu
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
(
self
=
[
super
init
]
)
)
{
NS_ASSERTION
(
geckoMenu
"
Cannot
initialize
native
menu
delegate
with
NULL
gecko
menu
!
Will
crash
!
"
)
;
mGeckoMenu
=
geckoMenu
;
}
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
menu
:
(
NSMenu
*
)
menu
willHighlightItem
:
(
NSMenuItem
*
)
item
{
if
(
!
menu
|
|
!
item
|
|
!
mGeckoMenu
)
{
return
;
}
nsMenuObjectX
*
target
=
mGeckoMenu
-
>
GetVisibleItemAt
(
(
uint32_t
)
[
menu
indexOfItem
:
item
]
)
;
if
(
target
&
&
(
target
-
>
MenuObjectType
(
)
=
=
eMenuItemObjectType
)
)
{
nsMenuItemX
*
targetMenuItem
=
static_cast
<
nsMenuItemX
*
>
(
target
)
;
bool
handlerCalledPreventDefault
;
targetMenuItem
-
>
DispatchDOMEvent
(
u
"
DOMMenuItemActive
"
_ns
&
handlerCalledPreventDefault
)
;
}
}
-
(
void
)
menuWillOpen
:
(
NSMenu
*
)
menu
{
if
(
!
mGeckoMenu
)
{
return
;
}
if
(
nsMenuX
:
:
sIndexingMenuLevel
>
0
)
{
return
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
if
(
rollupListener
)
{
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
rollupWidget
)
{
rollupListener
-
>
Rollup
(
0
true
nullptr
nullptr
)
;
[
menu
cancelTracking
]
;
return
;
}
}
mGeckoMenu
-
>
MenuOpened
(
)
;
}
-
(
void
)
menuDidClose
:
(
NSMenu
*
)
menu
{
if
(
!
mGeckoMenu
)
{
return
;
}
if
(
nsMenuX
:
:
sIndexingMenuLevel
>
0
)
{
return
;
}
mGeckoMenu
-
>
MenuClosed
(
)
;
}
end
static
NSMutableDictionary
*
gShadowKeyEquivDB
=
nil
;
interface
KeyEquivDBItem
:
NSObject
{
NSMenuItem
*
mItem
;
NSMutableSet
*
mTables
;
}
-
(
id
)
initWithItem
:
(
NSMenuItem
*
)
aItem
table
:
(
NSMapTable
*
)
aTable
;
-
(
BOOL
)
hasTable
:
(
NSMapTable
*
)
aTable
;
-
(
int
)
addTable
:
(
NSMapTable
*
)
aTable
;
-
(
int
)
removeTable
:
(
NSMapTable
*
)
aTable
;
end
implementation
KeyEquivDBItem
-
(
id
)
initWithItem
:
(
NSMenuItem
*
)
aItem
table
:
(
NSMapTable
*
)
aTable
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
gShadowKeyEquivDB
)
{
gShadowKeyEquivDB
=
[
[
NSMutableDictionary
alloc
]
init
]
;
}
self
=
[
super
init
]
;
if
(
aItem
&
&
aTable
)
{
mTables
=
[
[
NSMutableSet
alloc
]
init
]
;
mItem
=
[
aItem
retain
]
;
[
mTables
addObject
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
}
else
{
mTables
=
nil
;
mItem
=
nil
;
}
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mTables
)
{
[
mTables
release
]
;
}
if
(
mItem
)
{
[
mItem
release
]
;
}
[
super
dealloc
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
BOOL
)
hasTable
:
(
NSMapTable
*
)
aTable
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
[
mTables
member
:
[
NSValue
valueWithPointer
:
aTable
]
]
?
YES
:
NO
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
int
)
addTable
:
(
NSMapTable
*
)
aTable
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
aTable
)
{
[
mTables
addObject
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
}
return
[
mTables
count
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
0
)
;
}
-
(
int
)
removeTable
:
(
NSMapTable
*
)
aTable
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
aTable
)
{
NSValue
*
objectToRemove
=
[
mTables
member
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
if
(
objectToRemove
)
{
[
mTables
removeObject
:
objectToRemove
]
;
}
}
return
[
mTables
count
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
0
)
;
}
end
interface
NSMenu
(
MethodSwizzling
)
+
(
void
)
nsMenuX_NSMenu_addItem
:
(
NSMenuItem
*
)
aItem
toTable
:
(
NSMapTable
*
)
aTable
;
+
(
void
)
nsMenuX_NSMenu_removeItem
:
(
NSMenuItem
*
)
aItem
fromTable
:
(
NSMapTable
*
)
aTable
;
end
implementation
NSMenu
(
MethodSwizzling
)
+
(
void
)
nsMenuX_NSMenu_addItem
:
(
NSMenuItem
*
)
aItem
toTable
:
(
NSMapTable
*
)
aTable
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
aItem
&
&
aTable
)
{
NSValue
*
key
=
[
NSValue
valueWithPointer
:
aItem
]
;
KeyEquivDBItem
*
shadowItem
=
[
gShadowKeyEquivDB
objectForKey
:
key
]
;
if
(
shadowItem
)
{
[
shadowItem
addTable
:
aTable
]
;
}
else
{
shadowItem
=
[
[
KeyEquivDBItem
alloc
]
initWithItem
:
aItem
table
:
aTable
]
;
[
gShadowKeyEquivDB
setObject
:
shadowItem
forKey
:
key
]
;
[
shadowItem
release
]
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
[
self
nsMenuX_NSMenu_addItem
:
aItem
toTable
:
aTable
]
;
}
+
(
void
)
nsMenuX_NSMenu_removeItem
:
(
NSMenuItem
*
)
aItem
fromTable
:
(
NSMapTable
*
)
aTable
{
[
self
nsMenuX_NSMenu_removeItem
:
aItem
fromTable
:
aTable
]
;
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
aItem
&
&
aTable
)
{
NSValue
*
key
=
[
NSValue
valueWithPointer
:
aItem
]
;
KeyEquivDBItem
*
shadowItem
=
[
gShadowKeyEquivDB
objectForKey
:
key
]
;
if
(
shadowItem
&
&
[
shadowItem
hasTable
:
aTable
]
)
{
if
(
!
[
shadowItem
removeTable
:
aTable
]
)
{
[
gShadowKeyEquivDB
removeObjectForKey
:
key
]
;
}
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
end
interface
NSObject
(
SCTGRLIndexMethodSwizzling
)
-
(
void
)
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
;
end
implementation
NSObject
(
SCTGRLIndexMethodSwizzling
)
-
(
void
)
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
{
+
+
nsMenuX
:
:
sIndexingMenuLevel
;
[
self
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
]
;
-
-
nsMenuX
:
:
sIndexingMenuLevel
;
}
end
