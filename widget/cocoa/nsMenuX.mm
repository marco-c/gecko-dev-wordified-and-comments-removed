#
include
"
nsMenuX
.
h
"
#
include
<
_types
/
_uint32_t
.
h
>
#
include
<
dlfcn
.
h
>
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
MOZMenuOpeningCoordinator
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsMenuItemIconX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsBaseWidget
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsXULPopupManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
bool
gConstructingMenu
=
false
;
static
bool
gMenuMethodsSwizzled
=
false
;
int32_t
nsMenuX
:
:
sIndexingMenuLevel
=
0
;
static
void
SwizzleDynamicIndexingMethods
(
)
{
if
(
gMenuMethodsSwizzled
)
{
return
;
}
nsToolkit
:
:
SwizzleMethods
(
[
NSMenu
class
]
selector
(
_addItem
:
toTable
:
)
selector
(
nsMenuX_NSMenu_addItem
:
toTable
:
)
true
)
;
nsToolkit
:
:
SwizzleMethods
(
[
NSMenu
class
]
selector
(
_removeItem
:
fromTable
:
)
selector
(
nsMenuX_NSMenu_removeItem
:
fromTable
:
)
true
)
;
dlopen
(
"
/
System
/
Library
/
PrivateFrameworks
/
Shortcut
.
framework
/
Shortcut
"
RTLD_LAZY
)
;
Class
SCTGRLIndexClass
=
:
:
NSClassFromString
(
"
SCTGRLIndex
"
)
;
nsToolkit
:
:
SwizzleMethods
(
SCTGRLIndexClass
selector
(
indexMenuBarDynamically
)
selector
(
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
)
)
;
gMenuMethodsSwizzled
=
true
;
}
nsMenuX
:
:
nsMenuX
(
nsMenuParentX
*
aParent
nsMenuGroupOwnerX
*
aMenuGroupOwner
nsIContent
*
aContent
)
:
mContent
(
aContent
)
mParent
(
aParent
)
mMenuGroupOwner
(
aMenuGroupOwner
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_COUNT_CTOR
(
nsMenuX
)
;
SwizzleDynamicIndexingMethods
(
)
;
mMenuDelegate
=
[
[
MenuDelegate
alloc
]
initWithGeckoMenu
:
this
]
;
mMenuDelegate
.
menuIsInMenubar
=
mMenuGroupOwner
-
>
GetMenuBar
(
)
!
=
nullptr
;
if
(
!
nsMenuBarX
:
:
sNativeEventTarget
)
{
nsMenuBarX
:
:
sNativeEventTarget
=
[
[
NativeMenuItemTarget
alloc
]
init
]
;
}
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
mLabel
)
;
}
mNativeMenu
=
CreateMenuWithGeckoString
(
mLabel
)
;
NS_ASSERTION
(
mMenuGroupOwner
"
No
menu
owner
given
must
have
one
"
)
;
mMenuGroupOwner
-
>
RegisterForContentChanges
(
mContent
this
)
;
mVisible
=
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
;
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
mLabel
)
;
mNativeMenuItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
newCocoaLabelString
action
:
nil
keyEquivalent
:
"
"
]
;
mNativeMenuItem
.
submenu
=
mNativeMenu
;
SetEnabled
(
!
mContent
-
>
IsElement
(
)
|
|
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
RebuildMenu
(
)
;
mIcon
=
MakeUnique
<
nsMenuItemIconX
>
(
this
)
;
if
(
mVisible
)
{
SetupIcon
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsMenuX
:
:
~
nsMenuX
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
FlushMenuOpenedRunnable
(
)
;
if
(
mIsOpen
)
{
[
mNativeMenu
cancelTracking
]
;
MOZMenuOpeningCoordinator
.
needToUnwindForMenuClosing
=
YES
;
}
FlushMenuClosedRunnable
(
)
;
OnHighlightedItemChanged
(
Nothing
(
)
)
;
RemoveAll
(
)
;
mNativeMenu
.
delegate
=
nil
;
[
mNativeMenu
release
]
;
[
mMenuDelegate
release
]
;
[
mNativeMenuItem
autorelease
]
;
DetachFromGroupOwnerRecursive
(
)
;
MOZ_COUNT_DTOR
(
nsMenuX
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
DetachFromGroupOwnerRecursive
(
)
{
if
(
!
mMenuGroupOwner
)
{
return
;
}
if
(
mMenuGroupOwner
&
&
mContent
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mContent
)
;
}
mMenuGroupOwner
=
nullptr
;
for
(
auto
&
child
:
mMenuChildren
)
{
child
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
aMenu
-
>
DetachFromGroupOwnerRecursive
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
aMenuItem
-
>
DetachFromGroupOwner
(
)
;
}
)
;
}
}
void
nsMenuX
:
:
OnMenuWillOpen
(
dom
:
:
Element
*
aPopupElement
)
{
RefPtr
<
nsMenuX
>
kungFuDeathGrip
(
this
)
;
if
(
mObserver
)
{
mObserver
-
>
OnMenuWillOpen
(
aPopupElement
)
;
}
}
void
nsMenuX
:
:
OnMenuDidOpen
(
dom
:
:
Element
*
aPopupElement
)
{
RefPtr
<
nsMenuX
>
kungFuDeathGrip
(
this
)
;
if
(
mObserver
)
{
mObserver
-
>
OnMenuDidOpen
(
aPopupElement
)
;
}
}
void
nsMenuX
:
:
OnMenuWillActivateItem
(
dom
:
:
Element
*
aPopupElement
dom
:
:
Element
*
aMenuItemElement
)
{
RefPtr
<
nsMenuX
>
kungFuDeathGrip
(
this
)
;
if
(
mObserver
)
{
mObserver
-
>
OnMenuWillActivateItem
(
aPopupElement
aMenuItemElement
)
;
}
}
void
nsMenuX
:
:
OnMenuClosed
(
dom
:
:
Element
*
aPopupElement
)
{
RefPtr
<
nsMenuX
>
kungFuDeathGrip
(
this
)
;
if
(
mObserver
)
{
mObserver
-
>
OnMenuClosed
(
aPopupElement
)
;
}
}
void
nsMenuX
:
:
AddMenuChild
(
MenuChild
&
&
aChild
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
WillInsertChild
(
aChild
)
;
mMenuChildren
.
AppendElement
(
aChild
)
;
bool
isVisible
=
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
IsVisible
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
IsVisible
(
)
;
}
)
;
NSMenuItem
*
nativeItem
=
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
NativeNSMenuItem
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
NativeNSMenuItem
(
)
;
}
)
;
if
(
isVisible
)
{
RemovePlaceholderIfPresent
(
)
;
[
mNativeMenu
addItem
:
nativeItem
]
;
+
+
mVisibleItemsCount
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
InsertMenuChild
(
MenuChild
&
&
aChild
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
WillInsertChild
(
aChild
)
;
size_t
insertionIndex
=
FindInsertionIndex
(
aChild
)
;
mMenuChildren
.
InsertElementAt
(
insertionIndex
aChild
)
;
bool
isVisible
=
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
IsVisible
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
IsVisible
(
)
;
}
)
;
if
(
isVisible
)
{
MenuChildChangedVisibility
(
aChild
true
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
RemoveMenuChild
(
const
MenuChild
&
aChild
)
{
bool
isVisible
=
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
IsVisible
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
IsVisible
(
)
;
}
)
;
if
(
isVisible
)
{
MenuChildChangedVisibility
(
aChild
false
)
;
}
WillRemoveChild
(
aChild
)
;
mMenuChildren
.
RemoveElement
(
aChild
)
;
}
size_t
nsMenuX
:
:
FindInsertionIndex
(
const
MenuChild
&
aChild
)
{
nsCOMPtr
<
nsIContent
>
menuPopup
=
GetMenuPopupContent
(
)
;
MOZ_RELEASE_ASSERT
(
menuPopup
)
;
RefPtr
<
nsIContent
>
insertedContent
=
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
MOZ_RELEASE_ASSERT
(
insertedContent
-
>
GetParent
(
)
=
=
menuPopup
)
;
size_t
index
=
0
;
for
(
nsIContent
*
child
=
menuPopup
-
>
GetFirstChild
(
)
;
child
&
&
index
<
mMenuChildren
.
Length
(
)
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
=
=
insertedContent
)
{
break
;
}
RefPtr
<
nsIContent
>
contentAtIndex
=
mMenuChildren
[
index
]
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
child
=
=
contentAtIndex
)
{
index
+
+
;
}
}
return
index
;
}
uint32_t
nsMenuX
:
:
GetItemCount
(
)
{
return
mMenuChildren
.
Length
(
)
;
}
mozilla
:
:
Maybe
<
nsMenuX
:
:
MenuChild
>
nsMenuX
:
:
GetItemAt
(
uint32_t
aPos
)
{
if
(
aPos
>
=
(
uint32_t
)
mMenuChildren
.
Length
(
)
)
{
return
{
}
;
}
return
Some
(
mMenuChildren
[
aPos
]
)
;
}
nsresult
nsMenuX
:
:
GetVisibleItemCount
(
uint32_t
&
aCount
)
{
aCount
=
mVisibleItemsCount
;
return
NS_OK
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
nsMenuX
:
:
GetVisibleItemAt
(
uint32_t
aPos
)
{
uint32_t
count
=
mMenuChildren
.
Length
(
)
;
if
(
aPos
>
=
mVisibleItemsCount
|
|
aPos
>
=
count
)
{
return
{
}
;
}
if
(
mVisibleItemsCount
=
=
count
)
{
return
GetItemAt
(
aPos
)
;
}
uint32_t
visibleNodeIndex
=
0
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
MenuChild
item
=
*
GetItemAt
(
i
)
;
RefPtr
<
nsIContent
>
content
=
item
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
content
)
)
{
if
(
aPos
=
=
visibleNodeIndex
)
{
return
Some
(
item
)
;
}
visibleNodeIndex
+
+
;
}
}
return
{
}
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
nsMenuX
:
:
GetItemForElement
(
Element
*
aMenuChildElement
)
{
for
(
auto
&
child
:
mMenuChildren
)
{
RefPtr
<
nsIContent
>
content
=
child
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
content
=
=
aMenuChildElement
)
{
return
Some
(
child
)
;
}
}
return
{
}
;
}
nsresult
nsMenuX
:
:
RemoveAll
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
mNativeMenu
removeAllItems
]
;
for
(
auto
&
child
:
mMenuChildren
)
{
WillRemoveChild
(
child
)
;
}
mMenuChildren
.
Clear
(
)
;
mVisibleItemsCount
=
0
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
WillInsertChild
(
const
MenuChild
&
aChild
)
{
if
(
aChild
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
)
{
aChild
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
-
>
SetObserver
(
this
)
;
}
}
void
nsMenuX
:
:
WillRemoveChild
(
const
MenuChild
&
aChild
)
{
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
aMenu
-
>
DetachFromGroupOwnerRecursive
(
)
;
aMenu
-
>
DetachFromParent
(
)
;
aMenu
-
>
SetObserver
(
nullptr
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
aMenuItem
-
>
DetachFromGroupOwner
(
)
;
aMenuItem
-
>
DetachFromParent
(
)
;
}
)
;
}
void
nsMenuX
:
:
MenuOpened
(
)
{
if
(
mIsOpen
)
{
return
;
}
FlushMenuOpenedRunnable
(
)
;
FlushMenuClosedRunnable
(
)
;
if
(
!
mDidFirePopupshowingAndIsApprovedToOpen
)
{
bool
approvedToOpen
=
OnOpen
(
)
;
if
(
!
approvedToOpen
)
{
NS_WARNING
(
"
The
popupshowing
event
had
preventDefault
(
)
called
on
it
but
in
MenuOpened
(
)
it
"
"
is
too
late
to
stop
the
menu
from
opening
.
"
)
;
}
}
mIsOpen
=
true
;
mDidFirePopupshowingAndIsApprovedToOpen
=
false
;
if
(
mNeedsRebuild
)
{
OnHighlightedItemChanged
(
Nothing
(
)
)
;
RemoveAll
(
)
;
RebuildMenu
(
)
;
}
class
MenuOpenedAsyncRunnable
final
:
public
mozilla
:
:
CancelableRunnable
{
public
:
explicit
MenuOpenedAsyncRunnable
(
nsMenuX
*
aMenu
)
:
CancelableRunnable
(
"
MenuOpenedAsyncRunnable
"
)
mMenu
(
aMenu
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
Run
(
)
override
{
if
(
RefPtr
<
nsMenuX
>
menu
=
mMenu
)
{
menu
-
>
MenuOpenedAsync
(
)
;
mMenu
=
nullptr
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mMenu
=
nullptr
;
return
NS_OK
;
}
private
:
nsMenuX
*
mMenu
;
}
;
mPendingAsyncMenuOpenRunnable
=
new
MenuOpenedAsyncRunnable
(
this
)
;
NS_DispatchToCurrentThread
(
mPendingAsyncMenuOpenRunnable
)
;
}
void
nsMenuX
:
:
FlushMenuOpenedRunnable
(
)
{
if
(
mPendingAsyncMenuOpenRunnable
)
{
MenuOpenedAsync
(
)
;
}
}
void
nsMenuX
:
:
MenuOpenedAsync
(
)
{
if
(
mPendingAsyncMenuOpenRunnable
)
{
mPendingAsyncMenuOpenRunnable
-
>
Cancel
(
)
;
mPendingAsyncMenuOpenRunnable
=
nullptr
;
}
mIsOpenForGecko
=
true
;
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
open
u
"
true
"
_ns
true
)
;
}
RefPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
if
(
mObserver
&
&
popupContent
)
{
mObserver
-
>
OnMenuDidOpen
(
popupContent
-
>
AsElement
(
)
)
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShown
nullptr
WidgetMouseEvent
:
:
eReal
)
;
RefPtr
<
nsIContent
>
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
}
void
nsMenuX
:
:
MenuClosed
(
)
{
if
(
!
mIsOpen
)
{
return
;
}
FlushMenuOpenedRunnable
(
)
;
for
(
auto
&
child
:
mMenuChildren
)
{
if
(
child
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
)
{
child
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
-
>
MenuClosed
(
)
;
}
}
mIsOpen
=
false
;
class
MenuClosedAsyncRunnable
final
:
public
mozilla
:
:
CancelableRunnable
{
public
:
explicit
MenuClosedAsyncRunnable
(
nsMenuX
*
aMenu
)
:
CancelableRunnable
(
"
MenuClosedAsyncRunnable
"
)
mMenu
(
aMenu
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
Run
(
)
override
{
if
(
RefPtr
<
nsMenuX
>
menu
=
mMenu
)
{
menu
-
>
MenuClosedAsync
(
)
;
mMenu
=
nullptr
;
}
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
mMenu
=
nullptr
;
return
NS_OK
;
}
private
:
nsMenuX
*
mMenu
;
}
;
mPendingAsyncMenuCloseRunnable
=
new
MenuClosedAsyncRunnable
(
this
)
;
NS_DispatchToCurrentThread
(
mPendingAsyncMenuCloseRunnable
)
;
}
void
nsMenuX
:
:
FlushMenuClosedRunnable
(
)
{
for
(
auto
&
child
:
mMenuChildren
)
{
if
(
child
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
)
{
child
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
-
>
FlushMenuClosedRunnable
(
)
;
}
}
if
(
mPendingAsyncMenuCloseRunnable
)
{
MenuClosedAsync
(
)
;
}
}
void
nsMenuX
:
:
MenuClosedAsync
(
)
{
if
(
mPendingAsyncMenuCloseRunnable
)
{
mPendingAsyncMenuCloseRunnable
-
>
Cancel
(
)
;
mPendingAsyncMenuCloseRunnable
=
nullptr
;
}
nsTArray
<
PendingCommandEvent
>
events
=
std
:
:
move
(
mPendingCommandEvents
)
;
for
(
auto
&
event
:
events
)
{
event
.
mMenuItem
-
>
DoCommand
(
event
.
mModifiers
event
.
mButton
)
;
}
OnHighlightedItemChanged
(
Nothing
(
)
)
;
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
nsCOMPtr
<
nsIContent
>
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
popupHiding
(
true
eXULPopupHiding
nullptr
WidgetMouseEvent
:
:
eReal
)
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
popupHiding
nullptr
&
status
)
;
mIsOpenForGecko
=
false
;
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
open
true
)
;
}
WidgetMouseEvent
popupHidden
(
true
eXULPopupHidden
nullptr
WidgetMouseEvent
:
:
eReal
)
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
popupHidden
nullptr
&
status
)
;
if
(
mObserver
&
&
popupContent
)
{
mObserver
-
>
OnMenuClosed
(
popupContent
-
>
AsElement
(
)
)
;
}
}
void
nsMenuX
:
:
ActivateItemAfterClosing
(
RefPtr
<
nsMenuItemX
>
&
&
aItem
NSEventModifierFlags
aModifiers
int16_t
aButton
)
{
if
(
mIsOpenForGecko
)
{
mPendingCommandEvents
.
AppendElement
(
PendingCommandEvent
{
std
:
:
move
(
aItem
)
aModifiers
aButton
}
)
;
}
else
{
aItem
-
>
DoCommand
(
aModifiers
aButton
)
;
}
}
bool
nsMenuX
:
:
Close
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mDidFirePopupshowingAndIsApprovedToOpen
&
&
!
mIsOpen
)
{
MenuOpened
(
)
;
}
FlushMenuOpenedRunnable
(
)
;
bool
wasOpen
=
mIsOpenForGecko
;
if
(
mIsOpen
)
{
[
mNativeMenu
cancelTrackingWithoutAnimation
]
;
MOZMenuOpeningCoordinator
.
needToUnwindForMenuClosing
=
YES
;
MenuClosed
(
)
;
}
FlushMenuClosedRunnable
(
)
;
return
wasOpen
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
OnHighlightedItemChanged
(
const
Maybe
<
uint32_t
>
&
aNewHighlightedIndex
)
{
if
(
mHighlightedItemIndex
=
=
aNewHighlightedIndex
)
{
return
;
}
if
(
mHighlightedItemIndex
)
{
Maybe
<
nsMenuX
:
:
MenuChild
>
target
=
GetVisibleItemAt
(
*
mHighlightedItemIndex
)
;
if
(
target
&
&
target
-
>
is
<
RefPtr
<
nsMenuItemX
>
>
(
)
)
{
bool
handlerCalledPreventDefault
;
target
-
>
as
<
RefPtr
<
nsMenuItemX
>
>
(
)
-
>
DispatchDOMEvent
(
u
"
DOMMenuItemInactive
"
_ns
&
handlerCalledPreventDefault
)
;
}
}
if
(
aNewHighlightedIndex
)
{
Maybe
<
nsMenuX
:
:
MenuChild
>
target
=
GetVisibleItemAt
(
*
aNewHighlightedIndex
)
;
if
(
target
&
&
target
-
>
is
<
RefPtr
<
nsMenuItemX
>
>
(
)
)
{
bool
handlerCalledPreventDefault
;
target
-
>
as
<
RefPtr
<
nsMenuItemX
>
>
(
)
-
>
DispatchDOMEvent
(
u
"
DOMMenuItemActive
"
_ns
&
handlerCalledPreventDefault
)
;
}
}
mHighlightedItemIndex
=
aNewHighlightedIndex
;
}
void
nsMenuX
:
:
OnWillActivateItem
(
NSMenuItem
*
aItem
)
{
if
(
!
mIsOpenForGecko
)
{
return
;
}
if
(
mMenuGroupOwner
&
&
mObserver
)
{
nsMenuItemX
*
item
=
mMenuGroupOwner
-
>
GetMenuItemForCommandID
(
uint32_t
(
aItem
.
tag
)
)
;
if
(
item
&
&
item
-
>
Content
(
)
-
>
IsElement
(
)
)
{
RefPtr
<
dom
:
:
Element
>
itemElement
=
item
-
>
Content
(
)
-
>
AsElement
(
)
;
if
(
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
)
{
mObserver
-
>
OnMenuWillActivateItem
(
popupContent
-
>
AsElement
(
)
itemElement
)
;
}
}
}
}
static
NSUserInterfaceLayoutDirection
DirectionForElement
(
dom
:
:
Element
*
aElement
)
{
RefPtr
<
const
ComputedStyle
>
sc
=
nsComputedDOMStyle
:
:
GetComputedStyle
(
aElement
)
;
if
(
!
sc
)
{
return
NSApp
.
userInterfaceLayoutDirection
;
}
switch
(
sc
-
>
StyleVisibility
(
)
-
>
mDirection
)
{
case
StyleDirection
:
:
Ltr
:
return
NSUserInterfaceLayoutDirectionLeftToRight
;
case
StyleDirection
:
:
Rtl
:
return
NSUserInterfaceLayoutDirectionRightToLeft
;
}
}
void
nsMenuX
:
:
RebuildMenu
(
)
{
MOZ_RELEASE_ASSERT
(
mNeedsRebuild
)
;
gConstructingMenu
=
true
;
nsCOMPtr
<
nsIContent
>
menuPopup
=
GetMenuPopupContent
(
)
;
if
(
!
menuPopup
)
{
gConstructingMenu
=
false
;
return
;
}
if
(
menuPopup
-
>
IsElement
(
)
)
{
mNativeMenu
.
userInterfaceLayoutDirection
=
DirectionForElement
(
menuPopup
-
>
AsElement
(
)
)
;
}
for
(
nsIContent
*
child
=
menuPopup
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
Maybe
<
MenuChild
>
menuChild
=
CreateMenuChild
(
child
)
)
{
AddMenuChild
(
std
:
:
move
(
*
menuChild
)
)
;
}
}
InsertPlaceholderIfNeeded
(
)
;
gConstructingMenu
=
false
;
mNeedsRebuild
=
false
;
}
void
nsMenuX
:
:
InsertPlaceholderIfNeeded
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
[
mNativeMenu
numberOfItems
]
=
=
0
)
{
MOZ_RELEASE_ASSERT
(
mVisibleItemsCount
=
=
0
)
;
NSMenuItem
*
item
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
"
action
:
nil
keyEquivalent
:
"
"
]
;
item
.
enabled
=
NO
;
item
.
view
=
[
[
[
NSView
alloc
]
initWithFrame
:
NSMakeRect
(
0
0
150
1
)
]
autorelease
]
;
[
mNativeMenu
addItem
:
item
]
;
[
item
release
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
RemovePlaceholderIfPresent
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mVisibleItemsCount
=
=
0
&
&
[
mNativeMenu
numberOfItems
]
=
=
1
)
{
[
mNativeMenu
removeItemAtIndex
:
0
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
SetRebuild
(
bool
aNeedsRebuild
)
{
if
(
!
gConstructingMenu
)
{
mNeedsRebuild
=
aNeedsRebuild
;
if
(
mParent
&
&
mParent
-
>
AsMenuBar
(
)
)
{
mParent
-
>
AsMenuBar
(
)
-
>
SetNeedsRebuild
(
)
;
}
}
}
nsresult
nsMenuX
:
:
SetEnabled
(
bool
aIsEnabled
)
{
if
(
aIsEnabled
!
=
mIsEnabled
)
{
mIsEnabled
=
aIsEnabled
;
mNativeMenuItem
.
enabled
=
mIsEnabled
;
}
return
NS_OK
;
}
nsresult
nsMenuX
:
:
GetEnabled
(
bool
*
aIsEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aIsEnabled
)
;
*
aIsEnabled
=
mIsEnabled
;
return
NS_OK
;
}
GeckoNSMenu
*
nsMenuX
:
:
CreateMenuWithGeckoString
(
nsString
&
aMenuTitle
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSString
*
title
=
[
NSString
stringWithCharacters
:
(
UniChar
*
)
aMenuTitle
.
get
(
)
length
:
aMenuTitle
.
Length
(
)
]
;
GeckoNSMenu
*
myMenu
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
title
]
;
myMenu
.
delegate
=
mMenuDelegate
;
myMenu
.
autoenablesItems
=
NO
;
myMenu
.
allowsContextMenuPlugIns
=
NO
;
return
myMenu
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
nsMenuX
:
:
CreateMenuChild
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menuitem
nsGkAtoms
:
:
menuseparator
)
)
{
return
Some
(
MenuChild
(
CreateMenuItem
(
aContent
)
)
)
;
}
if
(
aContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
{
return
Some
(
MenuChild
(
MakeRefPtr
<
nsMenuX
>
(
this
mMenuGroupOwner
aContent
)
)
)
;
}
return
{
}
;
}
RefPtr
<
nsMenuItemX
>
nsMenuX
:
:
CreateMenuItem
(
nsIContent
*
aMenuItemContent
)
{
MOZ_RELEASE_ASSERT
(
aMenuItemContent
)
;
nsAutoString
menuitemName
;
if
(
aMenuItemContent
-
>
IsElement
(
)
)
{
aMenuItemContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
menuitemName
)
;
}
EMenuItemType
itemType
=
eRegularMenuItemType
;
if
(
aMenuItemContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menuseparator
)
)
{
itemType
=
eSeparatorMenuItemType
;
}
else
if
(
aMenuItemContent
-
>
IsElement
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
radio
nullptr
}
;
switch
(
aMenuItemContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
type
strings
eCaseMatters
)
)
{
case
0
:
itemType
=
eCheckboxMenuItemType
;
break
;
case
1
:
itemType
=
eRadioMenuItemType
;
break
;
}
}
return
MakeRefPtr
<
nsMenuItemX
>
(
this
menuitemName
itemType
mMenuGroupOwner
aMenuItemContent
)
;
}
bool
nsMenuX
:
:
OnOpen
(
)
{
if
(
mDidFirePopupshowingAndIsApprovedToOpen
)
{
return
true
;
}
if
(
mIsOpen
)
{
NS_WARNING
(
"
nsMenuX
:
:
OnOpen
(
)
called
while
the
menu
is
already
considered
to
be
open
.
This
"
"
seems
odd
.
"
)
;
}
RefPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
if
(
mObserver
&
&
popupContent
)
{
mObserver
-
>
OnMenuWillOpen
(
popupContent
-
>
AsElement
(
)
)
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShowing
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsresult
rv
=
NS_OK
;
RefPtr
<
nsIContent
>
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
rv
=
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
if
(
NS_FAILED
(
rv
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
DidFirePopupShowing
(
)
;
return
true
;
}
void
nsMenuX
:
:
DidFirePopupShowing
(
)
{
mDidFirePopupshowingAndIsApprovedToOpen
=
true
;
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
if
(
!
popupContent
)
{
return
;
}
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdateMenuItems
(
popupContent
)
;
}
}
already_AddRefed
<
nsIContent
>
nsMenuX
:
:
GetMenuPopupContent
(
)
{
if
(
mContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
)
{
return
do_AddRef
(
mContent
)
;
}
for
(
RefPtr
<
nsIContent
>
child
=
mContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
)
{
return
child
.
forget
(
)
;
}
}
return
nullptr
;
}
bool
nsMenuX
:
:
IsXULHelpMenu
(
nsIContent
*
aMenuContent
)
{
bool
retval
=
false
;
if
(
aMenuContent
&
&
aMenuContent
-
>
IsElement
(
)
)
{
nsAutoString
id
;
aMenuContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
if
(
id
.
Equals
(
u
"
helpMenu
"
_ns
)
)
{
retval
=
true
;
}
}
return
retval
;
}
void
nsMenuX
:
:
ObserveAttributeChanged
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
nsAtom
*
aAttribute
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
gConstructingMenu
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
open
)
)
{
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
{
SetEnabled
(
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
mLabel
)
;
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
mLabel
)
;
mNativeMenu
.
title
=
newCocoaLabelString
;
mNativeMenuItem
.
title
=
newCocoaLabelString
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
hidden
|
|
aAttribute
=
=
nsGkAtoms
:
:
collapsed
)
{
SetRebuild
(
true
)
;
bool
newVisible
=
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
;
if
(
newVisible
=
=
mVisible
)
{
return
;
}
mVisible
=
newVisible
;
if
(
mParent
)
{
RefPtr
<
nsMenuX
>
self
=
this
;
mParent
-
>
MenuChildChangedVisibility
(
MenuChild
(
self
)
newVisible
)
;
}
if
(
mVisible
)
{
SetupIcon
(
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
image
)
{
SetupIcon
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
ObserveContentRemoved
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
gConstructingMenu
)
{
return
;
}
SetRebuild
(
true
)
;
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
aChild
)
;
if
(
!
mIsOpen
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
if
(
popupContent
&
&
aContainer
=
=
popupContent
&
&
aChild
-
>
IsElement
(
)
)
{
if
(
Maybe
<
MenuChild
>
child
=
GetItemForElement
(
aChild
-
>
AsElement
(
)
)
)
{
RemoveMenuChild
(
*
child
)
;
}
}
}
void
nsMenuX
:
:
ObserveContentInserted
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
if
(
gConstructingMenu
)
{
return
;
}
SetRebuild
(
true
)
;
if
(
!
mIsOpen
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
if
(
popupContent
&
&
aContainer
=
=
popupContent
)
{
if
(
Maybe
<
MenuChild
>
child
=
CreateMenuChild
(
aChild
)
)
{
InsertMenuChild
(
std
:
:
move
(
*
child
)
)
;
}
}
}
void
nsMenuX
:
:
SetupIcon
(
)
{
mIcon
-
>
SetupIcon
(
mContent
)
;
mNativeMenuItem
.
image
=
mIcon
-
>
GetIconImage
(
)
;
}
void
nsMenuX
:
:
IconUpdated
(
)
{
mNativeMenuItem
.
image
=
mIcon
-
>
GetIconImage
(
)
;
if
(
mIconListener
)
{
mIconListener
-
>
IconUpdated
(
)
;
}
}
void
nsMenuX
:
:
MenuChildChangedVisibility
(
const
MenuChild
&
aChild
bool
aIsVisible
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSMenuItem
*
nativeItem
=
aChild
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
NativeNSMenuItem
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
NativeNSMenuItem
(
)
;
}
)
;
if
(
aIsVisible
)
{
MOZ_RELEASE_ASSERT
(
!
nativeItem
.
menu
"
The
native
item
should
not
be
in
a
menu
while
it
is
hidden
"
)
;
RemovePlaceholderIfPresent
(
)
;
NSInteger
insertionPoint
=
CalculateNativeInsertionPoint
(
aChild
)
;
[
mNativeMenu
insertItem
:
nativeItem
atIndex
:
insertionPoint
]
;
mVisibleItemsCount
+
+
;
}
else
{
MOZ_RELEASE_ASSERT
(
[
mNativeMenu
indexOfItem
:
nativeItem
]
!
=
-
1
"
The
native
item
should
be
in
this
menu
while
it
is
visible
"
)
;
[
mNativeMenu
removeItem
:
nativeItem
]
;
mVisibleItemsCount
-
-
;
InsertPlaceholderIfNeeded
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
NSInteger
nsMenuX
:
:
CalculateNativeInsertionPoint
(
const
MenuChild
&
aChild
)
{
NSInteger
insertionPoint
=
0
;
for
(
auto
&
currItem
:
mMenuChildren
)
{
if
(
currItem
=
=
aChild
)
{
return
insertionPoint
;
}
NSMenuItem
*
nativeItem
=
currItem
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
NativeNSMenuItem
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
NativeNSMenuItem
(
)
;
}
)
;
if
(
nativeItem
.
menu
)
{
insertionPoint
+
+
;
}
}
return
insertionPoint
;
}
void
nsMenuX
:
:
Dump
(
uint32_t
aIndent
)
const
{
printf
(
"
%
*
s
-
menu
[
%
p
]
%
-
16s
<
%
s
>
"
aIndent
*
2
"
"
this
mLabel
.
IsEmpty
(
)
?
"
(
empty
label
)
"
:
NS_ConvertUTF16toUTF8
(
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mContent
-
>
NodeName
(
)
)
.
get
(
)
)
;
if
(
mNeedsRebuild
)
{
printf
(
"
[
NeedsRebuild
]
"
)
;
}
if
(
mIsOpen
)
{
printf
(
"
[
Open
]
"
)
;
}
if
(
mVisible
)
{
printf
(
"
[
Visible
]
"
)
;
}
if
(
mIsEnabled
)
{
printf
(
"
[
IsEnabled
]
"
)
;
}
printf
(
"
(
%
d
visible
items
)
"
int
(
mVisibleItemsCount
)
)
;
printf
(
"
\
n
"
)
;
for
(
const
auto
&
subitem
:
mMenuChildren
)
{
subitem
.
match
(
[
=
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
aMenu
-
>
Dump
(
aIndent
+
1
)
;
}
[
=
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
aMenuItem
-
>
Dump
(
aIndent
+
1
)
;
}
)
;
}
}
implementation
MenuDelegate
-
(
id
)
initWithGeckoMenu
:
(
nsMenuX
*
)
geckoMenu
{
if
(
(
self
=
[
super
init
]
)
)
{
NS_ASSERTION
(
geckoMenu
"
Cannot
initialize
native
menu
delegate
with
NULL
gecko
menu
!
Will
crash
!
"
)
;
mGeckoMenu
=
geckoMenu
;
mBlocksToRunWhenOpen
=
[
[
NSMutableArray
alloc
]
init
]
;
}
return
self
;
}
-
(
void
)
dealloc
{
[
mBlocksToRunWhenOpen
release
]
;
[
super
dealloc
]
;
}
-
(
void
)
runBlockWhenOpen
:
(
void
(
^
)
(
)
)
block
{
[
mBlocksToRunWhenOpen
addObject
:
[
[
block
copy
]
autorelease
]
]
;
}
-
(
void
)
menu
:
(
NSMenu
*
)
aMenu
willHighlightItem
:
(
NSMenuItem
*
)
aItem
{
if
(
!
aMenu
|
|
!
mGeckoMenu
)
{
return
;
}
Maybe
<
uint32_t
>
index
=
aItem
?
Some
(
static_cast
<
uint32_t
>
(
[
aMenu
indexOfItem
:
aItem
]
)
)
:
Nothing
(
)
;
mGeckoMenu
-
>
OnHighlightedItemChanged
(
index
)
;
}
-
(
void
)
menuWillOpen
:
(
NSMenu
*
)
menu
{
for
(
void
(
^
block
)
(
)
in
mBlocksToRunWhenOpen
)
{
block
(
)
;
}
[
mBlocksToRunWhenOpen
removeAllObjects
]
;
if
(
!
mGeckoMenu
)
{
return
;
}
if
(
nsMenuX
:
:
sIndexingMenuLevel
>
0
)
{
return
;
}
if
(
self
.
menuIsInMenubar
)
{
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
if
(
rollupListener
)
{
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
rollupWidget
)
{
rollupListener
-
>
Rollup
(
0
true
nullptr
nullptr
)
;
[
menu
cancelTracking
]
;
return
;
}
}
}
RefPtr
<
nsMenuX
>
geckoMenu
=
mGeckoMenu
;
geckoMenu
-
>
MenuOpened
(
)
;
}
-
(
void
)
menuDidClose
:
(
NSMenu
*
)
menu
{
if
(
!
mGeckoMenu
)
{
return
;
}
if
(
nsMenuX
:
:
sIndexingMenuLevel
>
0
)
{
return
;
}
RefPtr
<
nsMenuX
>
geckoMenu
=
mGeckoMenu
;
geckoMenu
-
>
MenuClosed
(
)
;
}
-
(
void
)
menu
:
(
NSMenu
*
)
aMenu
willActivateItem
:
(
NSMenuItem
*
)
aItem
{
if
(
!
mGeckoMenu
)
{
return
;
}
RefPtr
<
nsMenuX
>
geckoMenu
=
mGeckoMenu
;
geckoMenu
-
>
OnWillActivateItem
(
aItem
)
;
}
end
static
NSMutableDictionary
*
gShadowKeyEquivDB
=
nil
;
interface
KeyEquivDBItem
:
NSObject
{
NSMenuItem
*
mItem
;
NSMutableSet
*
mTables
;
}
-
(
id
)
initWithItem
:
(
NSMenuItem
*
)
aItem
table
:
(
NSMapTable
*
)
aTable
;
-
(
BOOL
)
hasTable
:
(
NSMapTable
*
)
aTable
;
-
(
int
)
addTable
:
(
NSMapTable
*
)
aTable
;
-
(
int
)
removeTable
:
(
NSMapTable
*
)
aTable
;
end
implementation
KeyEquivDBItem
-
(
id
)
initWithItem
:
(
NSMenuItem
*
)
aItem
table
:
(
NSMapTable
*
)
aTable
{
if
(
!
gShadowKeyEquivDB
)
{
gShadowKeyEquivDB
=
[
[
NSMutableDictionary
alloc
]
init
]
;
}
self
=
[
super
init
]
;
if
(
aItem
&
&
aTable
)
{
mTables
=
[
[
NSMutableSet
alloc
]
init
]
;
mItem
=
[
aItem
retain
]
;
[
mTables
addObject
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
}
else
{
mTables
=
nil
;
mItem
=
nil
;
}
return
self
;
}
-
(
void
)
dealloc
{
if
(
mTables
)
{
[
mTables
release
]
;
}
if
(
mItem
)
{
[
mItem
release
]
;
}
[
super
dealloc
]
;
}
-
(
BOOL
)
hasTable
:
(
NSMapTable
*
)
aTable
{
return
[
mTables
member
:
[
NSValue
valueWithPointer
:
aTable
]
]
?
YES
:
NO
;
}
-
(
int
)
addTable
:
(
NSMapTable
*
)
aTable
{
if
(
aTable
)
{
[
mTables
addObject
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
}
return
[
mTables
count
]
;
}
-
(
int
)
removeTable
:
(
NSMapTable
*
)
aTable
{
if
(
aTable
)
{
NSValue
*
objectToRemove
=
[
mTables
member
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
if
(
objectToRemove
)
{
[
mTables
removeObject
:
objectToRemove
]
;
}
}
return
[
mTables
count
]
;
}
end
interface
NSMenu
(
MethodSwizzling
)
+
(
void
)
nsMenuX_NSMenu_addItem
:
(
NSMenuItem
*
)
aItem
toTable
:
(
NSMapTable
*
)
aTable
;
+
(
void
)
nsMenuX_NSMenu_removeItem
:
(
NSMenuItem
*
)
aItem
fromTable
:
(
NSMapTable
*
)
aTable
;
end
implementation
NSMenu
(
MethodSwizzling
)
+
(
void
)
nsMenuX_NSMenu_addItem
:
(
NSMenuItem
*
)
aItem
toTable
:
(
NSMapTable
*
)
aTable
{
if
(
aItem
&
&
aTable
)
{
NSValue
*
key
=
[
NSValue
valueWithPointer
:
aItem
]
;
KeyEquivDBItem
*
shadowItem
=
[
gShadowKeyEquivDB
objectForKey
:
key
]
;
if
(
shadowItem
)
{
[
shadowItem
addTable
:
aTable
]
;
}
else
{
shadowItem
=
[
[
KeyEquivDBItem
alloc
]
initWithItem
:
aItem
table
:
aTable
]
;
[
gShadowKeyEquivDB
setObject
:
shadowItem
forKey
:
key
]
;
[
shadowItem
release
]
;
}
}
[
self
nsMenuX_NSMenu_addItem
:
aItem
toTable
:
aTable
]
;
}
+
(
void
)
nsMenuX_NSMenu_removeItem
:
(
NSMenuItem
*
)
aItem
fromTable
:
(
NSMapTable
*
)
aTable
{
[
self
nsMenuX_NSMenu_removeItem
:
aItem
fromTable
:
aTable
]
;
if
(
aItem
&
&
aTable
)
{
NSValue
*
key
=
[
NSValue
valueWithPointer
:
aItem
]
;
KeyEquivDBItem
*
shadowItem
=
[
gShadowKeyEquivDB
objectForKey
:
key
]
;
if
(
shadowItem
&
&
[
shadowItem
hasTable
:
aTable
]
)
{
if
(
!
[
shadowItem
removeTable
:
aTable
]
)
{
[
gShadowKeyEquivDB
removeObjectForKey
:
key
]
;
}
}
}
}
end
interface
NSObject
(
SCTGRLIndexMethodSwizzling
)
-
(
void
)
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
;
end
implementation
NSObject
(
SCTGRLIndexMethodSwizzling
)
-
(
void
)
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
{
+
+
nsMenuX
:
:
sIndexingMenuLevel
;
[
self
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
]
;
-
-
nsMenuX
:
:
sIndexingMenuLevel
;
}
end
