#
include
<
dlfcn
.
h
>
#
include
"
nsMenuBaseX
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsMenuItemIconX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsBaseWidget
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
bool
gConstructingMenu
=
false
;
static
bool
gMenuMethodsSwizzled
=
false
;
int32_t
nsMenuX
:
:
sIndexingMenuLevel
=
0
;
implementation
MenuItemInfo
-
(
id
)
initWithMenuGroupOwner
:
(
nsMenuGroupOwnerX
*
)
aMenuGroupOwner
{
if
(
(
self
=
[
super
init
]
)
!
=
nil
)
{
[
self
setMenuGroupOwner
:
aMenuGroupOwner
]
;
}
return
self
;
}
-
(
void
)
dealloc
{
[
self
setMenuGroupOwner
:
nullptr
]
;
[
super
dealloc
]
;
}
-
(
nsMenuGroupOwnerX
*
)
menuGroupOwner
{
return
mMenuGroupOwner
;
}
-
(
void
)
setMenuGroupOwner
:
(
nsMenuGroupOwnerX
*
)
aMenuGroupOwner
{
mMenuGroupOwner
=
aMenuGroupOwner
;
if
(
aMenuGroupOwner
)
{
aMenuGroupOwner
-
>
AddMenuItemInfoToSet
(
self
)
;
}
}
end
static
void
SwizzleDynamicIndexingMethods
(
)
{
if
(
gMenuMethodsSwizzled
)
{
return
;
}
nsToolkit
:
:
SwizzleMethods
(
[
NSMenu
class
]
selector
(
_addItem
:
toTable
:
)
selector
(
nsMenuX_NSMenu_addItem
:
toTable
:
)
true
)
;
nsToolkit
:
:
SwizzleMethods
(
[
NSMenu
class
]
selector
(
_removeItem
:
fromTable
:
)
selector
(
nsMenuX_NSMenu_removeItem
:
fromTable
:
)
true
)
;
dlopen
(
"
/
System
/
Library
/
PrivateFrameworks
/
Shortcut
.
framework
/
Shortcut
"
RTLD_LAZY
)
;
Class
SCTGRLIndexClass
=
:
:
NSClassFromString
(
"
SCTGRLIndex
"
)
;
nsToolkit
:
:
SwizzleMethods
(
SCTGRLIndexClass
selector
(
indexMenuBarDynamically
)
selector
(
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
)
)
;
gMenuMethodsSwizzled
=
true
;
}
nsMenuX
:
:
nsMenuX
(
nsMenuObjectX
*
aParent
nsMenuGroupOwnerX
*
aMenuGroupOwner
nsIContent
*
aContent
)
:
mContent
(
aContent
)
mParent
(
aParent
)
mMenuGroupOwner
(
aMenuGroupOwner
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_COUNT_CTOR
(
nsMenuX
)
;
SwizzleDynamicIndexingMethods
(
)
;
mMenuDelegate
=
[
[
MenuDelegate
alloc
]
initWithGeckoMenu
:
this
]
;
if
(
!
nsMenuBarX
:
:
sNativeEventTarget
)
{
nsMenuBarX
:
:
sNativeEventTarget
=
[
[
NativeMenuItemTarget
alloc
]
init
]
;
}
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
mLabel
)
;
}
mNativeMenu
=
CreateMenuWithGeckoString
(
mLabel
)
;
NS_ASSERTION
(
mMenuGroupOwner
"
No
menu
owner
given
must
have
one
"
)
;
mMenuGroupOwner
-
>
RegisterForContentChanges
(
mContent
this
)
;
#
ifdef
DEBUG
nsMenuObjectTypeX
parentType
=
#
endif
mParent
-
>
MenuObjectType
(
)
;
NS_ASSERTION
(
(
parentType
=
=
eMenuBarObjectType
|
|
parentType
=
=
eSubmenuObjectType
|
|
parentType
=
=
eStandaloneNativeMenuObjectType
)
"
Menu
parent
not
a
menu
bar
menu
or
native
menu
!
"
)
;
if
(
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
)
{
mVisible
=
false
;
}
if
(
mContent
-
>
GetChildCount
(
)
=
=
0
)
{
mVisible
=
false
;
}
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
mLabel
)
;
mNativeMenuItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
newCocoaLabelString
action
:
nil
keyEquivalent
:
"
"
]
;
[
mNativeMenuItem
setSubmenu
:
mNativeMenu
]
;
SetEnabled
(
!
mContent
-
>
IsElement
(
)
|
|
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
RebuildMenu
(
)
;
mIcon
=
MakeUnique
<
nsMenuItemIconX
>
(
this
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsMenuX
:
:
~
nsMenuX
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
RemoveAll
(
)
;
mNativeMenu
.
delegate
=
nil
;
[
mNativeMenu
release
]
;
[
mMenuDelegate
release
]
;
[
mNativeMenuItem
autorelease
]
;
DetachFromGroupOwnerRecursive
(
)
;
MOZ_COUNT_DTOR
(
nsMenuX
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
DetachFromGroupOwnerRecursive
(
)
{
if
(
!
mMenuGroupOwner
)
{
return
;
}
if
(
mMenuGroupOwner
&
&
mContent
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mContent
)
;
}
UnregisterCommands
(
)
;
mMenuGroupOwner
=
nullptr
;
for
(
auto
&
child
:
mMenuChildren
)
{
child
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
aMenu
-
>
DetachFromGroupOwnerRecursive
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
aMenuItem
-
>
DetachFromGroupOwner
(
)
;
}
)
;
}
}
void
nsMenuX
:
:
UnregisterCommands
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
mMenuGroupOwner
|
|
!
mNativeMenu
)
{
return
;
}
for
(
NSMenuItem
*
item
in
mNativeMenu
.
itemArray
)
{
mMenuGroupOwner
-
>
UnregisterCommand
(
static_cast
<
uint32_t
>
(
item
.
tag
)
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
AddMenuItem
(
RefPtr
<
nsMenuItemX
>
&
&
aMenuItem
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mMenuChildren
.
AppendElement
(
aMenuItem
)
;
if
(
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
aMenuItem
-
>
Content
(
)
)
)
{
return
;
}
+
+
mVisibleItemsCount
;
NSMenuItem
*
newNativeMenuItem
=
aMenuItem
-
>
NativeNSMenuItem
(
)
;
[
mNativeMenu
addItem
:
newNativeMenuItem
]
;
newNativeMenuItem
.
target
=
nsMenuBarX
:
:
sNativeEventTarget
;
newNativeMenuItem
.
action
=
selector
(
menuItemHit
:
)
;
newNativeMenuItem
.
tag
=
mMenuGroupOwner
-
>
RegisterForCommand
(
aMenuItem
)
;
MenuItemInfo
*
info
=
[
[
MenuItemInfo
alloc
]
initWithMenuGroupOwner
:
mMenuGroupOwner
]
;
newNativeMenuItem
.
representedObject
=
info
;
[
info
release
]
;
aMenuItem
-
>
SetupIcon
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
AddMenu
(
RefPtr
<
nsMenuX
>
&
&
aMenu
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mMenuChildren
.
AppendElement
(
aMenu
)
;
if
(
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
aMenu
-
>
Content
(
)
)
)
{
return
;
}
+
+
mVisibleItemsCount
;
NSMenuItem
*
newNativeMenuItem
=
aMenu
-
>
NativeNSMenuItem
(
)
;
if
(
newNativeMenuItem
)
{
[
mNativeMenu
addItem
:
newNativeMenuItem
]
;
newNativeMenuItem
.
submenu
=
aMenu
-
>
NativeNSMenu
(
)
;
}
aMenu
-
>
SetupIcon
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
uint32_t
nsMenuX
:
:
GetItemCount
(
)
{
return
mMenuChildren
.
Length
(
)
;
}
mozilla
:
:
Maybe
<
nsMenuX
:
:
MenuChild
>
nsMenuX
:
:
GetItemAt
(
uint32_t
aPos
)
{
if
(
aPos
>
=
(
uint32_t
)
mMenuChildren
.
Length
(
)
)
{
return
{
}
;
}
return
Some
(
mMenuChildren
[
aPos
]
)
;
}
nsresult
nsMenuX
:
:
GetVisibleItemCount
(
uint32_t
&
aCount
)
{
aCount
=
mVisibleItemsCount
;
return
NS_OK
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
nsMenuX
:
:
GetVisibleItemAt
(
uint32_t
aPos
)
{
uint32_t
count
=
mMenuChildren
.
Length
(
)
;
if
(
aPos
>
=
mVisibleItemsCount
|
|
aPos
>
=
count
)
{
return
{
}
;
}
if
(
mVisibleItemsCount
=
=
count
)
{
return
GetItemAt
(
aPos
)
;
}
uint32_t
visibleNodeIndex
=
0
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
MenuChild
item
=
*
GetItemAt
(
i
)
;
RefPtr
<
nsIContent
>
content
=
item
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
content
)
)
{
if
(
aPos
=
=
visibleNodeIndex
)
{
return
Some
(
item
)
;
}
visibleNodeIndex
+
+
;
}
}
return
{
}
;
}
nsresult
nsMenuX
:
:
RemoveAll
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
UnregisterCommands
(
)
;
[
mNativeMenu
removeAllItems
]
;
for
(
auto
&
child
:
mMenuChildren
)
{
child
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
aMenu
-
>
DetachFromGroupOwnerRecursive
(
)
;
aMenu
-
>
DetachFromParent
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
aMenuItem
-
>
DetachFromGroupOwner
(
)
;
aMenuItem
-
>
DetachFromParent
(
)
;
}
)
;
}
mMenuChildren
.
Clear
(
)
;
mVisibleItemsCount
=
0
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsEventStatus
nsMenuX
:
:
MenuOpened
(
)
{
mIsOpen
=
true
;
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
open
u
"
true
"
_ns
true
)
;
}
if
(
!
OnOpen
(
)
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
if
(
mNeedsRebuild
)
{
RemoveAll
(
)
;
RebuildMenu
(
)
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShown
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
nsIContent
*
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
void
nsMenuX
:
:
MenuClosed
(
)
{
if
(
!
mIsOpen
)
{
return
;
}
mIsOpen
=
false
;
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
nsCOMPtr
<
nsIContent
>
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
popupHiding
(
true
eXULPopupHiding
nullptr
WidgetMouseEvent
:
:
eReal
)
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
popupHiding
nullptr
&
status
)
;
if
(
mContent
-
>
IsElement
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
open
true
)
;
}
WidgetMouseEvent
popupHidden
(
true
eXULPopupHidden
nullptr
WidgetMouseEvent
:
:
eReal
)
;
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
popupHidden
nullptr
&
status
)
;
}
void
nsMenuX
:
:
RebuildMenu
(
)
{
MOZ_RELEASE_ASSERT
(
mNeedsRebuild
)
;
gConstructingMenu
=
true
;
nsCOMPtr
<
nsIContent
>
menuPopup
=
GetMenuPopupContent
(
)
;
if
(
!
menuPopup
)
{
gConstructingMenu
=
false
;
return
;
}
for
(
nsIContent
*
child
=
menuPopup
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menuitem
nsGkAtoms
:
:
menuseparator
)
)
{
LoadMenuItem
(
child
)
;
}
else
if
(
child
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
{
LoadSubMenu
(
child
)
;
}
}
gConstructingMenu
=
false
;
mNeedsRebuild
=
false
;
}
void
nsMenuX
:
:
SetRebuild
(
bool
aNeedsRebuild
)
{
if
(
!
gConstructingMenu
)
{
mNeedsRebuild
=
aNeedsRebuild
;
if
(
mParent
&
&
mParent
-
>
MenuObjectType
(
)
=
=
eMenuBarObjectType
)
{
nsMenuBarX
*
mb
=
static_cast
<
nsMenuBarX
*
>
(
mParent
)
;
mb
-
>
SetNeedsRebuild
(
)
;
}
}
}
nsresult
nsMenuX
:
:
SetEnabled
(
bool
aIsEnabled
)
{
if
(
aIsEnabled
!
=
mIsEnabled
)
{
mIsEnabled
=
aIsEnabled
;
mNativeMenuItem
.
enabled
=
mIsEnabled
;
}
return
NS_OK
;
}
nsresult
nsMenuX
:
:
GetEnabled
(
bool
*
aIsEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aIsEnabled
)
;
*
aIsEnabled
=
mIsEnabled
;
return
NS_OK
;
}
GeckoNSMenu
*
nsMenuX
:
:
CreateMenuWithGeckoString
(
nsString
&
aMenuTitle
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSString
*
title
=
[
NSString
stringWithCharacters
:
(
UniChar
*
)
aMenuTitle
.
get
(
)
length
:
aMenuTitle
.
Length
(
)
]
;
GeckoNSMenu
*
myMenu
=
[
[
GeckoNSMenu
alloc
]
initWithTitle
:
title
]
;
myMenu
.
delegate
=
mMenuDelegate
;
myMenu
.
autoenablesItems
=
NO
;
return
myMenu
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
LoadMenuItem
(
nsIContent
*
aMenuItemContent
)
{
if
(
!
aMenuItemContent
)
{
return
;
}
nsAutoString
menuitemName
;
if
(
aMenuItemContent
-
>
IsElement
(
)
)
{
aMenuItemContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
menuitemName
)
;
}
EMenuItemType
itemType
=
eRegularMenuItemType
;
if
(
aMenuItemContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menuseparator
)
)
{
itemType
=
eSeparatorMenuItemType
;
}
else
if
(
aMenuItemContent
-
>
IsElement
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
radio
nullptr
}
;
switch
(
aMenuItemContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
type
strings
eCaseMatters
)
)
{
case
0
:
itemType
=
eCheckboxMenuItemType
;
break
;
case
1
:
itemType
=
eRadioMenuItemType
;
break
;
}
}
AddMenuItem
(
MakeRefPtr
<
nsMenuItemX
>
(
this
menuitemName
itemType
mMenuGroupOwner
aMenuItemContent
)
)
;
}
void
nsMenuX
:
:
LoadSubMenu
(
nsIContent
*
aMenuContent
)
{
AddMenu
(
MakeRefPtr
<
nsMenuX
>
(
this
mMenuGroupOwner
aMenuContent
)
)
;
}
bool
nsMenuX
:
:
OnOpen
(
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShowing
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
popupContent
=
GetMenuPopupContent
(
)
;
nsresult
rv
=
NS_OK
;
nsIContent
*
dispatchTo
=
popupContent
?
popupContent
:
mContent
;
rv
=
EventDispatcher
:
:
Dispatch
(
dispatchTo
nullptr
&
event
nullptr
&
status
)
;
if
(
NS_FAILED
(
rv
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
popupContent
=
GetMenuPopupContent
(
)
;
if
(
!
popupContent
)
{
return
true
;
}
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdateMenuItems
(
popupContent
)
;
}
return
true
;
}
already_AddRefed
<
nsIContent
>
nsMenuX
:
:
GetMenuPopupContent
(
)
{
if
(
mContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
)
{
return
do_AddRef
(
mContent
)
;
}
for
(
RefPtr
<
nsIContent
>
child
=
mContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsXULElement
(
nsGkAtoms
:
:
menupopup
)
)
{
return
child
.
forget
(
)
;
}
}
return
nullptr
;
}
bool
nsMenuX
:
:
IsXULHelpMenu
(
nsIContent
*
aMenuContent
)
{
bool
retval
=
false
;
if
(
aMenuContent
&
&
aMenuContent
-
>
IsElement
(
)
)
{
nsAutoString
id
;
aMenuContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
id
)
;
if
(
id
.
Equals
(
u
"
helpMenu
"
_ns
)
)
{
retval
=
true
;
}
}
return
retval
;
}
void
nsMenuX
:
:
ObserveAttributeChanged
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
nsAtom
*
aAttribute
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
gConstructingMenu
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
open
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
mParent
)
;
nsMenuObjectTypeX
parentType
=
mParent
-
>
MenuObjectType
(
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
{
SetEnabled
(
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
mLabel
)
;
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
mLabel
)
;
mNativeMenu
.
title
=
newCocoaLabelString
;
mNativeMenuItem
.
title
=
newCocoaLabelString
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
hidden
|
|
aAttribute
=
=
nsGkAtoms
:
:
collapsed
)
{
SetRebuild
(
true
)
;
bool
contentIsHiddenOrCollapsed
=
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
;
if
(
contentIsHiddenOrCollapsed
!
=
mVisible
)
{
return
;
}
NSMenu
*
parentMenu
=
nil
;
if
(
parentType
=
=
eMenuBarObjectType
)
{
parentMenu
=
static_cast
<
nsMenuBarX
*
>
(
mParent
)
-
>
NativeNSMenu
(
)
;
}
else
if
(
parentType
=
=
eSubmenuObjectType
)
{
parentMenu
=
static_cast
<
nsMenuX
*
>
(
mParent
)
-
>
NativeNSMenu
(
)
;
}
if
(
parentMenu
)
{
if
(
contentIsHiddenOrCollapsed
)
{
if
(
[
parentMenu
indexOfItem
:
mNativeMenuItem
]
!
=
-
1
)
{
[
parentMenu
removeItem
:
mNativeMenuItem
]
;
}
mVisible
=
false
;
}
else
{
int
insertionIndex
=
nsMenuUtilsX
:
:
CalculateNativeInsertionPoint
(
mParent
this
)
;
if
(
parentType
=
=
eMenuBarObjectType
)
{
nsMenuBarX
*
mb
=
static_cast
<
nsMenuBarX
*
>
(
mParent
)
;
if
(
mb
-
>
MenuContainsAppMenu
(
)
)
{
insertionIndex
+
+
;
}
}
[
parentMenu
insertItem
:
mNativeMenuItem
atIndex
:
insertionIndex
]
;
mNativeMenuItem
.
submenu
=
mNativeMenu
;
mVisible
=
true
;
}
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
image
)
{
SetupIcon
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuX
:
:
ObserveContentRemoved
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
gConstructingMenu
)
{
return
;
}
SetRebuild
(
true
)
;
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
aChild
)
;
}
void
nsMenuX
:
:
ObserveContentInserted
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
if
(
gConstructingMenu
)
{
return
;
}
SetRebuild
(
true
)
;
}
void
nsMenuX
:
:
SetupIcon
(
)
{
mIcon
-
>
SetupIcon
(
mContent
)
;
mNativeMenuItem
.
image
=
mIcon
-
>
GetIconImage
(
)
;
}
void
nsMenuX
:
:
IconUpdated
(
)
{
mNativeMenuItem
.
image
=
mIcon
-
>
GetIconImage
(
)
;
if
(
mParent
)
{
mParent
-
>
IconUpdated
(
)
;
}
}
NSInteger
nsMenuX
:
:
CalculateNativeInsertionPoint
(
nsMenuX
*
aChild
)
{
NSInteger
insertionPoint
=
0
;
for
(
auto
&
currItem
:
mMenuChildren
)
{
if
(
currItem
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
&
&
currItem
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
=
=
aChild
)
{
return
insertionPoint
;
}
NSMenuItem
*
nativeItem
=
currItem
.
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
NativeNSMenuItem
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
NativeNSMenuItem
(
)
;
}
)
;
if
(
nativeItem
.
menu
)
{
insertionPoint
+
+
;
}
}
return
insertionPoint
;
}
void
nsMenuX
:
:
Dump
(
uint32_t
aIndent
)
const
{
printf
(
"
%
*
s
-
menu
[
%
p
]
%
-
16s
<
%
s
>
"
aIndent
*
2
"
"
this
mLabel
.
IsEmpty
(
)
?
"
(
empty
label
)
"
:
NS_ConvertUTF16toUTF8
(
mLabel
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mContent
-
>
NodeName
(
)
)
.
get
(
)
)
;
if
(
mNeedsRebuild
)
{
printf
(
"
[
NeedsRebuild
]
"
)
;
}
if
(
mIsOpen
)
{
printf
(
"
[
Open
]
"
)
;
}
if
(
mVisible
)
{
printf
(
"
[
Visible
]
"
)
;
}
if
(
mIsEnabled
)
{
printf
(
"
[
IsEnabled
]
"
)
;
}
printf
(
"
(
%
d
visible
items
)
"
int
(
mVisibleItemsCount
)
)
;
printf
(
"
\
n
"
)
;
for
(
const
auto
&
subitem
:
mMenuChildren
)
{
subitem
.
match
(
[
=
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
aMenu
-
>
Dump
(
aIndent
+
1
)
;
}
[
=
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
aMenuItem
-
>
Dump
(
aIndent
+
1
)
;
}
)
;
}
}
implementation
MenuDelegate
-
(
id
)
initWithGeckoMenu
:
(
nsMenuX
*
)
geckoMenu
{
if
(
(
self
=
[
super
init
]
)
)
{
NS_ASSERTION
(
geckoMenu
"
Cannot
initialize
native
menu
delegate
with
NULL
gecko
menu
!
Will
crash
!
"
)
;
mGeckoMenu
=
geckoMenu
;
}
return
self
;
}
-
(
void
)
menu
:
(
NSMenu
*
)
menu
willHighlightItem
:
(
NSMenuItem
*
)
item
{
if
(
!
menu
|
|
!
item
|
|
!
mGeckoMenu
)
{
return
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
target
=
mGeckoMenu
-
>
GetVisibleItemAt
(
(
uint32_t
)
[
menu
indexOfItem
:
item
]
)
;
if
(
target
&
&
target
-
>
is
<
RefPtr
<
nsMenuItemX
>
>
(
)
)
{
bool
handlerCalledPreventDefault
;
target
-
>
as
<
RefPtr
<
nsMenuItemX
>
>
(
)
-
>
DispatchDOMEvent
(
u
"
DOMMenuItemActive
"
_ns
&
handlerCalledPreventDefault
)
;
}
}
-
(
void
)
menuWillOpen
:
(
NSMenu
*
)
menu
{
if
(
!
mGeckoMenu
)
{
return
;
}
if
(
nsMenuX
:
:
sIndexingMenuLevel
>
0
)
{
return
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
if
(
rollupListener
)
{
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
rollupWidget
)
{
rollupListener
-
>
Rollup
(
0
true
nullptr
nullptr
)
;
[
menu
cancelTracking
]
;
return
;
}
}
RefPtr
<
nsMenuX
>
geckoMenu
=
mGeckoMenu
;
geckoMenu
-
>
MenuOpened
(
)
;
}
-
(
void
)
menuDidClose
:
(
NSMenu
*
)
menu
{
if
(
!
mGeckoMenu
)
{
return
;
}
if
(
nsMenuX
:
:
sIndexingMenuLevel
>
0
)
{
return
;
}
RefPtr
<
nsMenuX
>
geckoMenu
=
mGeckoMenu
;
geckoMenu
-
>
MenuClosed
(
)
;
}
end
static
NSMutableDictionary
*
gShadowKeyEquivDB
=
nil
;
interface
KeyEquivDBItem
:
NSObject
{
NSMenuItem
*
mItem
;
NSMutableSet
*
mTables
;
}
-
(
id
)
initWithItem
:
(
NSMenuItem
*
)
aItem
table
:
(
NSMapTable
*
)
aTable
;
-
(
BOOL
)
hasTable
:
(
NSMapTable
*
)
aTable
;
-
(
int
)
addTable
:
(
NSMapTable
*
)
aTable
;
-
(
int
)
removeTable
:
(
NSMapTable
*
)
aTable
;
end
implementation
KeyEquivDBItem
-
(
id
)
initWithItem
:
(
NSMenuItem
*
)
aItem
table
:
(
NSMapTable
*
)
aTable
{
if
(
!
gShadowKeyEquivDB
)
{
gShadowKeyEquivDB
=
[
[
NSMutableDictionary
alloc
]
init
]
;
}
self
=
[
super
init
]
;
if
(
aItem
&
&
aTable
)
{
mTables
=
[
[
NSMutableSet
alloc
]
init
]
;
mItem
=
[
aItem
retain
]
;
[
mTables
addObject
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
}
else
{
mTables
=
nil
;
mItem
=
nil
;
}
return
self
;
}
-
(
void
)
dealloc
{
if
(
mTables
)
{
[
mTables
release
]
;
}
if
(
mItem
)
{
[
mItem
release
]
;
}
[
super
dealloc
]
;
}
-
(
BOOL
)
hasTable
:
(
NSMapTable
*
)
aTable
{
return
[
mTables
member
:
[
NSValue
valueWithPointer
:
aTable
]
]
?
YES
:
NO
;
}
-
(
int
)
addTable
:
(
NSMapTable
*
)
aTable
{
if
(
aTable
)
{
[
mTables
addObject
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
}
return
[
mTables
count
]
;
}
-
(
int
)
removeTable
:
(
NSMapTable
*
)
aTable
{
if
(
aTable
)
{
NSValue
*
objectToRemove
=
[
mTables
member
:
[
NSValue
valueWithPointer
:
aTable
]
]
;
if
(
objectToRemove
)
{
[
mTables
removeObject
:
objectToRemove
]
;
}
}
return
[
mTables
count
]
;
}
end
interface
NSMenu
(
MethodSwizzling
)
+
(
void
)
nsMenuX_NSMenu_addItem
:
(
NSMenuItem
*
)
aItem
toTable
:
(
NSMapTable
*
)
aTable
;
+
(
void
)
nsMenuX_NSMenu_removeItem
:
(
NSMenuItem
*
)
aItem
fromTable
:
(
NSMapTable
*
)
aTable
;
end
implementation
NSMenu
(
MethodSwizzling
)
+
(
void
)
nsMenuX_NSMenu_addItem
:
(
NSMenuItem
*
)
aItem
toTable
:
(
NSMapTable
*
)
aTable
{
if
(
aItem
&
&
aTable
)
{
NSValue
*
key
=
[
NSValue
valueWithPointer
:
aItem
]
;
KeyEquivDBItem
*
shadowItem
=
[
gShadowKeyEquivDB
objectForKey
:
key
]
;
if
(
shadowItem
)
{
[
shadowItem
addTable
:
aTable
]
;
}
else
{
shadowItem
=
[
[
KeyEquivDBItem
alloc
]
initWithItem
:
aItem
table
:
aTable
]
;
[
gShadowKeyEquivDB
setObject
:
shadowItem
forKey
:
key
]
;
[
shadowItem
release
]
;
}
}
[
self
nsMenuX_NSMenu_addItem
:
aItem
toTable
:
aTable
]
;
}
+
(
void
)
nsMenuX_NSMenu_removeItem
:
(
NSMenuItem
*
)
aItem
fromTable
:
(
NSMapTable
*
)
aTable
{
[
self
nsMenuX_NSMenu_removeItem
:
aItem
fromTable
:
aTable
]
;
if
(
aItem
&
&
aTable
)
{
NSValue
*
key
=
[
NSValue
valueWithPointer
:
aItem
]
;
KeyEquivDBItem
*
shadowItem
=
[
gShadowKeyEquivDB
objectForKey
:
key
]
;
if
(
shadowItem
&
&
[
shadowItem
hasTable
:
aTable
]
)
{
if
(
!
[
shadowItem
removeTable
:
aTable
]
)
{
[
gShadowKeyEquivDB
removeObjectForKey
:
key
]
;
}
}
}
}
end
interface
NSObject
(
SCTGRLIndexMethodSwizzling
)
-
(
void
)
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
;
end
implementation
NSObject
(
SCTGRLIndexMethodSwizzling
)
-
(
void
)
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
{
+
+
nsMenuX
:
:
sIndexingMenuLevel
;
[
self
nsMenuX_SCTGRLIndex_indexMenuBarDynamically
]
;
-
-
nsMenuX
:
:
sIndexingMenuLevel
;
}
end
