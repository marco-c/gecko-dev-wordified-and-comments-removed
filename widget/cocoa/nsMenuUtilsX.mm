#
include
"
nsMenuUtilsX
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
XULCommandEvent
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsStandaloneNativeMenu
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCocoaWindow
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsQueryObject
.
h
"
using
namespace
mozilla
;
void
nsMenuUtilsX
:
:
DispatchCommandTo
(
nsIContent
*
aTargetContent
)
{
MOZ_ASSERT
(
aTargetContent
"
null
ptr
"
)
;
dom
:
:
Document
*
doc
=
aTargetContent
-
>
OwnerDoc
(
)
;
if
(
doc
)
{
RefPtr
<
dom
:
:
XULCommandEvent
>
event
=
new
dom
:
:
XULCommandEvent
(
doc
doc
-
>
GetPresContext
(
)
nullptr
)
;
IgnoredErrorResult
rv
;
event
-
>
InitCommandEvent
(
u
"
command
"
_ns
true
true
nsGlobalWindowInner
:
:
Cast
(
doc
-
>
GetInnerWindow
(
)
)
0
false
false
false
false
nullptr
0
rv
)
;
if
(
!
rv
.
Failed
(
)
)
{
event
-
>
SetTrusted
(
true
)
;
aTargetContent
-
>
DispatchEvent
(
*
event
)
;
}
}
}
NSString
*
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
const
nsString
&
itemLabel
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
return
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
itemLabel
.
get
(
)
)
length
:
itemLabel
.
Length
(
)
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
uint8_t
nsMenuUtilsX
:
:
GeckoModifiersForNodeAttribute
(
const
nsString
&
modifiersAttribute
)
{
uint8_t
modifiers
=
knsMenuItemNoModifier
;
char
*
str
=
ToNewCString
(
modifiersAttribute
)
;
char
*
newStr
;
char
*
token
=
strtok_r
(
str
"
\
t
"
&
newStr
)
;
while
(
token
!
=
nullptr
)
{
if
(
strcmp
(
token
"
shift
"
)
=
=
0
)
{
modifiers
|
=
knsMenuItemShiftModifier
;
}
else
if
(
strcmp
(
token
"
alt
"
)
=
=
0
)
{
modifiers
|
=
knsMenuItemAltModifier
;
}
else
if
(
strcmp
(
token
"
control
"
)
=
=
0
)
{
modifiers
|
=
knsMenuItemControlModifier
;
}
else
if
(
(
strcmp
(
token
"
accel
"
)
=
=
0
)
|
|
(
strcmp
(
token
"
meta
"
)
=
=
0
)
)
{
modifiers
|
=
knsMenuItemCommandModifier
;
}
token
=
strtok_r
(
newStr
"
\
t
"
&
newStr
)
;
}
free
(
str
)
;
return
modifiers
;
}
unsigned
int
nsMenuUtilsX
:
:
MacModifiersForGeckoModifiers
(
uint8_t
geckoModifiers
)
{
unsigned
int
macModifiers
=
0
;
if
(
geckoModifiers
&
knsMenuItemShiftModifier
)
{
macModifiers
|
=
NSEventModifierFlagShift
;
}
if
(
geckoModifiers
&
knsMenuItemAltModifier
)
{
macModifiers
|
=
NSEventModifierFlagOption
;
}
if
(
geckoModifiers
&
knsMenuItemControlModifier
)
{
macModifiers
|
=
NSEventModifierFlagControl
;
}
if
(
geckoModifiers
&
knsMenuItemCommandModifier
)
{
macModifiers
|
=
NSEventModifierFlagCommand
;
}
return
macModifiers
;
}
nsMenuBarX
*
nsMenuUtilsX
:
:
GetHiddenWindowMenuBar
(
)
{
nsIWidget
*
hiddenWindowWidgetNoCOMPtr
=
nsCocoaUtils
:
:
GetHiddenWindowWidget
(
)
;
if
(
hiddenWindowWidgetNoCOMPtr
)
{
return
static_cast
<
nsCocoaWindow
*
>
(
hiddenWindowWidgetNoCOMPtr
)
-
>
GetMenuBar
(
)
;
}
return
nullptr
;
}
NSMenuItem
*
nsMenuUtilsX
:
:
GetStandardEditMenuItem
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSMenuItem
*
standardEditMenuItem
=
[
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Edit
"
action
:
nil
keyEquivalent
:
"
"
]
autorelease
]
;
NSMenu
*
standardEditMenu
=
[
[
NSMenu
alloc
]
initWithTitle
:
"
Edit
"
]
;
standardEditMenuItem
.
submenu
=
standardEditMenu
;
[
standardEditMenu
release
]
;
NSMenuItem
*
undoItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Undo
"
action
:
selector
(
undo
:
)
keyEquivalent
:
"
z
"
]
;
[
standardEditMenu
addItem
:
undoItem
]
;
[
undoItem
release
]
;
NSMenuItem
*
redoItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Redo
"
action
:
selector
(
redo
:
)
keyEquivalent
:
"
Z
"
]
;
[
standardEditMenu
addItem
:
redoItem
]
;
[
redoItem
release
]
;
[
standardEditMenu
addItem
:
[
NSMenuItem
separatorItem
]
]
;
NSMenuItem
*
cutItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Cut
"
action
:
selector
(
cut
:
)
keyEquivalent
:
"
x
"
]
;
[
standardEditMenu
addItem
:
cutItem
]
;
[
cutItem
release
]
;
NSMenuItem
*
copyItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Copy
"
action
:
selector
(
copy
:
)
keyEquivalent
:
"
c
"
]
;
[
standardEditMenu
addItem
:
copyItem
]
;
[
copyItem
release
]
;
NSMenuItem
*
pasteItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Paste
"
action
:
selector
(
paste
:
)
keyEquivalent
:
"
v
"
]
;
[
standardEditMenu
addItem
:
pasteItem
]
;
[
pasteItem
release
]
;
NSMenuItem
*
deleteItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Delete
"
action
:
selector
(
delete
:
)
keyEquivalent
:
"
"
]
;
[
standardEditMenu
addItem
:
deleteItem
]
;
[
deleteItem
release
]
;
NSMenuItem
*
selectAllItem
=
[
[
NSMenuItem
alloc
]
initWithTitle
:
"
Select
All
"
action
:
selector
(
selectAll
:
)
keyEquivalent
:
"
a
"
]
;
[
standardEditMenu
addItem
:
selectAllItem
]
;
[
selectAllItem
release
]
;
return
standardEditMenuItem
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
nsIContent
*
inContent
)
{
return
inContent
-
>
IsElement
(
)
&
&
(
inContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
nsGkAtoms
:
:
_true
eCaseMatters
)
|
|
inContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
collapsed
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
}
int
nsMenuUtilsX
:
:
CalculateNativeInsertionPoint
(
nsMenuObjectX
*
aParent
nsMenuObjectX
*
aChild
)
{
int
insertionPoint
=
0
;
nsMenuObjectTypeX
parentType
=
aParent
-
>
MenuObjectType
(
)
;
if
(
parentType
=
=
eMenuBarObjectType
)
{
nsMenuBarX
*
menubarParent
=
static_cast
<
nsMenuBarX
*
>
(
aParent
)
;
uint32_t
numMenus
=
menubarParent
-
>
GetMenuCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numMenus
;
i
+
+
)
{
nsMenuX
*
currMenu
=
menubarParent
-
>
GetMenuAt
(
i
)
;
if
(
currMenu
=
=
aChild
)
{
return
insertionPoint
;
}
if
(
currMenu
&
&
currMenu
-
>
NativeMenuItem
(
)
.
menu
)
{
insertionPoint
+
+
;
}
}
}
else
if
(
parentType
=
=
eSubmenuObjectType
|
|
parentType
=
=
eStandaloneNativeMenuObjectType
)
{
nsMenuX
*
menuParent
;
if
(
parentType
=
=
eSubmenuObjectType
)
{
menuParent
=
static_cast
<
nsMenuX
*
>
(
aParent
)
;
}
else
{
menuParent
=
static_cast
<
nsStandaloneNativeMenu
*
>
(
aParent
)
-
>
GetMenuXObject
(
)
;
}
uint32_t
numItems
=
menuParent
-
>
GetItemCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numItems
;
i
+
+
)
{
nsMenuObjectX
*
currItem
=
menuParent
-
>
GetItemAt
(
i
)
;
if
(
currItem
=
=
aChild
)
{
return
insertionPoint
;
}
NSMenuItem
*
nativeItem
=
nil
;
nsMenuObjectTypeX
currItemType
=
currItem
-
>
MenuObjectType
(
)
;
if
(
currItemType
=
=
eSubmenuObjectType
)
{
nativeItem
=
static_cast
<
nsMenuX
*
>
(
currItem
)
-
>
NativeMenuItem
(
)
;
}
else
{
nativeItem
=
(
NSMenuItem
*
)
(
currItem
-
>
NativeData
(
)
)
;
}
if
(
nativeItem
.
menu
)
{
insertionPoint
+
+
;
}
}
}
return
insertionPoint
;
}
NSMenuItem
*
nsMenuUtilsX
:
:
NativeMenuItemWithLocation
(
NSMenu
*
aRootMenu
NSString
*
aLocationString
bool
aIsMenuBar
)
{
NSArray
<
NSString
*
>
*
indexes
=
[
aLocationString
componentsSeparatedByString
:
"
|
"
]
;
unsigned
int
pathLength
=
indexes
.
count
;
if
(
pathLength
=
=
0
)
{
return
nil
;
}
NSMenu
*
currentSubmenu
=
aRootMenu
;
for
(
unsigned
int
depth
=
0
;
depth
<
pathLength
;
depth
+
+
)
{
NSInteger
targetIndex
=
[
indexes
objectAtIndex
:
depth
]
.
integerValue
;
if
(
aIsMenuBar
&
&
depth
=
=
0
)
{
targetIndex
+
+
;
}
int
itemCount
=
currentSubmenu
.
numberOfItems
;
if
(
targetIndex
<
itemCount
)
{
NSMenuItem
*
menuItem
=
[
currentSubmenu
itemAtIndex
:
targetIndex
]
;
if
(
depth
=
=
pathLength
-
1
)
{
return
menuItem
;
}
if
(
menuItem
.
hasSubmenu
)
{
currentSubmenu
=
menuItem
.
submenu
;
}
else
{
return
nil
;
}
}
}
return
nil
;
}
