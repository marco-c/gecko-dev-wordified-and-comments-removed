#
ifndef
nsMenuX_h_
#
define
nsMenuX_h_
#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsMenuParentX
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuGroupOwnerX
.
h
"
#
include
"
nsMenuItemIconX
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsChangeObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
class
nsMenuX
;
class
nsMenuItemX
;
class
nsIWidget
;
interface
MenuDelegate
:
NSObject
<
NSMenuDelegate
>
{
nsMenuX
*
mGeckoMenu
;
NSMutableArray
*
mBlocksToRunWhenOpen
;
}
-
(
id
)
initWithGeckoMenu
:
(
nsMenuX
*
)
geckoMenu
;
-
(
void
)
runBlockWhenOpen
:
(
void
(
^
)
(
)
)
block
;
-
(
void
)
menu
:
(
NSMenu
*
)
menu
willActivateItem
:
(
NSMenuItem
*
)
item
;
property
BOOL
menuIsInMenubar
;
end
class
nsMenuXObserver
{
public
:
virtual
void
OnMenuWillOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
=
0
;
virtual
void
OnMenuDidOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
=
0
;
virtual
void
OnMenuWillActivateItem
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
mozilla
:
:
dom
:
:
Element
*
aMenuItemElement
)
=
0
;
virtual
void
OnMenuClosed
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
=
0
;
}
;
class
nsMenuX
final
:
public
nsMenuParentX
public
nsChangeObserver
public
nsMenuItemIconX
:
:
Listener
public
nsMenuXObserver
{
public
:
using
Observer
=
nsMenuXObserver
;
nsMenuX
(
nsMenuParentX
*
aParent
nsMenuGroupOwnerX
*
aMenuGroupOwner
nsIContent
*
aContent
)
;
NS_INLINE_DECL_REFCOUNTING
(
nsMenuX
)
static
int32_t
sIndexingMenuLevel
;
NS_DECL_CHANGEOBSERVER
void
IconUpdated
(
)
override
;
void
OnMenuWillOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
override
;
void
OnMenuDidOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
override
;
void
OnMenuWillActivateItem
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
mozilla
:
:
dom
:
:
Element
*
aMenuItemElement
)
override
;
void
OnMenuClosed
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
override
;
bool
IsVisible
(
)
const
{
return
mVisible
;
}
void
DetachFromGroupOwnerRecursive
(
)
;
void
DetachFromParent
(
)
{
mParent
=
nullptr
;
}
mozilla
:
:
Maybe
<
MenuChild
>
GetItemAt
(
uint32_t
aPos
)
;
uint32_t
GetItemCount
(
)
;
mozilla
:
:
Maybe
<
MenuChild
>
GetVisibleItemAt
(
uint32_t
aPos
)
;
nsresult
GetVisibleItemCount
(
uint32_t
&
aCount
)
;
mozilla
:
:
Maybe
<
MenuChild
>
GetItemForElement
(
mozilla
:
:
dom
:
:
Element
*
aMenuChildElement
)
;
void
ActivateItemAfterClosing
(
RefPtr
<
nsMenuItemX
>
&
&
aItem
NSEventModifierFlags
aModifiers
int16_t
aButton
)
;
bool
IsOpenForGecko
(
)
const
{
return
mIsOpenForGecko
;
}
MOZ_CAN_RUN_SCRIPT
bool
OnOpen
(
)
;
void
PopupShowingEventWasSentAndApprovedExternally
(
)
{
DidFirePopupShowing
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
MenuOpened
(
)
;
void
MenuClosed
(
)
;
bool
Close
(
)
;
void
OnHighlightedItemChanged
(
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aNewHighlightedIndex
)
;
void
OnWillActivateItem
(
NSMenuItem
*
aItem
)
;
void
SetRebuild
(
bool
aMenuEvent
)
;
void
SetupIcon
(
)
;
nsIContent
*
Content
(
)
{
return
mContent
;
}
NSMenuItem
*
NativeNSMenuItem
(
)
{
return
mNativeMenuItem
;
}
GeckoNSMenu
*
NativeNSMenu
(
)
{
return
mNativeMenu
;
}
void
SetIconListener
(
nsMenuItemIconX
:
:
Listener
*
aListener
)
{
mIconListener
=
aListener
;
}
void
ClearIconListener
(
)
{
mIconListener
=
nullptr
;
}
void
MenuChildChangedVisibility
(
const
MenuChild
&
aChild
bool
aIsVisible
)
override
;
void
Dump
(
uint32_t
aIndent
)
const
;
static
bool
IsXULHelpMenu
(
nsIContent
*
aMenuContent
)
;
void
SetObserver
(
Observer
*
aObserver
)
{
mObserver
=
aObserver
;
}
void
ClearObserver
(
)
{
mObserver
=
nullptr
;
}
protected
:
virtual
~
nsMenuX
(
)
;
void
RebuildMenu
(
)
;
nsresult
RemoveAll
(
)
;
nsresult
SetEnabled
(
bool
aIsEnabled
)
;
nsresult
GetEnabled
(
bool
*
aIsEnabled
)
;
already_AddRefed
<
nsIContent
>
GetMenuPopupContent
(
)
;
void
WillInsertChild
(
const
MenuChild
&
aChild
)
;
void
WillRemoveChild
(
const
MenuChild
&
aChild
)
;
void
AddMenuChild
(
MenuChild
&
&
aChild
)
;
void
InsertMenuChild
(
MenuChild
&
&
aChild
)
;
void
RemoveMenuChild
(
const
MenuChild
&
aChild
)
;
mozilla
:
:
Maybe
<
MenuChild
>
CreateMenuChild
(
nsIContent
*
aContent
)
;
RefPtr
<
nsMenuItemX
>
CreateMenuItem
(
nsIContent
*
aMenuItemContent
)
;
GeckoNSMenu
*
CreateMenuWithGeckoString
(
nsString
&
aMenuTitle
)
;
void
DidFirePopupShowing
(
)
;
size_t
FindInsertionIndex
(
const
MenuChild
&
aChild
)
;
NSInteger
CalculateNativeInsertionPoint
(
const
MenuChild
&
aChild
)
;
MOZ_CAN_RUN_SCRIPT
void
MenuOpenedAsync
(
)
;
MOZ_CAN_RUN_SCRIPT
void
MenuClosedAsync
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
FlushMenuOpenedRunnable
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
FlushMenuClosedRunnable
(
)
;
void
InsertPlaceholderIfNeeded
(
)
;
void
RemovePlaceholderIfPresent
(
)
;
nsCOMPtr
<
nsIContent
>
mContent
;
nsTArray
<
MenuChild
>
mMenuChildren
;
nsString
mLabel
;
uint32_t
mVisibleItemsCount
=
0
;
nsMenuParentX
*
mParent
=
nullptr
;
nsMenuGroupOwnerX
*
mMenuGroupOwner
=
nullptr
;
nsMenuItemIconX
:
:
Listener
*
mIconListener
=
nullptr
;
mozilla
:
:
UniquePtr
<
nsMenuItemIconX
>
mIcon
;
Observer
*
mObserver
=
nullptr
;
RefPtr
<
mozilla
:
:
CancelableRunnable
>
mPendingAsyncMenuOpenRunnable
;
RefPtr
<
mozilla
:
:
CancelableRunnable
>
mPendingAsyncMenuCloseRunnable
;
struct
PendingCommandEvent
{
RefPtr
<
nsMenuItemX
>
mMenuItem
;
NSEventModifierFlags
mModifiers
;
int16_t
mButton
;
}
;
nsTArray
<
PendingCommandEvent
>
mPendingCommandEvents
;
GeckoNSMenu
*
mNativeMenu
=
nil
;
MenuDelegate
*
mMenuDelegate
=
nil
;
NSMenuItem
*
mNativeMenuItem
=
nil
;
mozilla
:
:
Maybe
<
uint32_t
>
mHighlightedItemIndex
;
bool
mIsEnabled
=
true
;
bool
mNeedsRebuild
=
true
;
bool
mIsOpen
=
false
;
bool
mIsOpenForGecko
=
false
;
bool
mVisible
=
true
;
bool
mDidFirePopupshowingAndIsApprovedToOpen
=
false
;
}
;
#
endif
