#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
nsFilePicker
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsArrayEnumerator
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsObjCExceptions
.
h
"
using
namespace
mozilla
;
const
float
kAccessoryViewPadding
=
5
;
const
int
kSaveTypeControlTag
=
1
;
static
bool
gCallSecretHiddenFileAPI
=
false
;
const
char
kShowHiddenFilesPref
[
]
=
"
filepicker
.
showHiddenFiles
"
;
interface
NSPopUpButtonObserver
:
NSObject
{
NSPopUpButton
*
mPopUpButton
;
NSOpenPanel
*
mOpenPanel
;
nsFilePicker
*
mFilePicker
;
}
-
(
void
)
setPopUpButton
:
(
NSPopUpButton
*
)
aPopUpButton
;
-
(
void
)
setOpenPanel
:
(
NSOpenPanel
*
)
aOpenPanel
;
-
(
void
)
setFilePicker
:
(
nsFilePicker
*
)
aFilePicker
;
-
(
void
)
menuChangedItem
:
(
NSNotification
*
)
aSender
;
end
NS_IMPL_ISUPPORTS
(
nsFilePicker
nsIFilePicker
)
static
void
SetShowHiddenFileState
(
NSSavePanel
*
panel
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
bool
show
=
false
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetBool
(
kShowHiddenFilesPref
&
show
)
)
)
{
gCallSecretHiddenFileAPI
=
true
;
}
if
(
gCallSecretHiddenFileAPI
)
{
SEL
navViewSelector
=
selector
(
_navView
)
;
NSMethodSignature
*
navViewSignature
=
[
panel
methodSignatureForSelector
:
navViewSelector
]
;
if
(
!
navViewSignature
)
return
;
NSInvocation
*
navViewInvocation
=
[
NSInvocation
invocationWithMethodSignature
:
navViewSignature
]
;
[
navViewInvocation
setSelector
:
navViewSelector
]
;
[
navViewInvocation
setTarget
:
panel
]
;
[
navViewInvocation
invoke
]
;
id
navView
=
nil
;
[
navViewInvocation
getReturnValue
:
&
navView
]
;
SEL
showHiddenFilesSelector
=
selector
(
setShowsHiddenFiles
:
)
;
NSMethodSignature
*
showHiddenFilesSignature
=
[
navView
methodSignatureForSelector
:
showHiddenFilesSelector
]
;
if
(
!
showHiddenFilesSignature
)
return
;
NSInvocation
*
showHiddenFilesInvocation
=
[
NSInvocation
invocationWithMethodSignature
:
showHiddenFilesSignature
]
;
[
showHiddenFilesInvocation
setSelector
:
showHiddenFilesSelector
]
;
[
showHiddenFilesInvocation
setTarget
:
navView
]
;
[
showHiddenFilesInvocation
setArgument
:
&
show
atIndex
:
2
]
;
[
showHiddenFilesInvocation
invoke
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
class
nsFilePicker
:
:
AsyncShowFilePicker
:
public
mozilla
:
:
Runnable
{
public
:
AsyncShowFilePicker
(
nsFilePicker
*
aFilePicker
nsIFilePickerShownCallback
*
aCallback
)
:
mozilla
:
:
Runnable
(
"
AsyncShowFilePicker
"
)
mFilePicker
(
aFilePicker
)
mCallback
(
aCallback
)
{
}
NS_IMETHOD
Run
(
)
override
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
AsyncShowFilePicker
should
be
on
the
main
thread
!
"
)
;
nsIFilePicker
:
:
ResultCode
result
=
nsIFilePicker
:
:
returnCancel
;
nsresult
rv
=
mFilePicker
-
>
Show
(
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
FilePicker
'
s
Show
(
)
implementation
failed
!
"
)
;
}
if
(
mCallback
)
{
mCallback
-
>
Done
(
result
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsFilePicker
>
mFilePicker
;
RefPtr
<
nsIFilePickerShownCallback
>
mCallback
;
}
;
nsFilePicker
:
:
nsFilePicker
(
)
:
mSelectedTypeIndex
(
0
)
{
}
nsFilePicker
:
:
~
nsFilePicker
(
)
{
}
void
nsFilePicker
:
:
InitNative
(
nsIWidget
*
aParent
const
nsAString
&
aTitle
)
{
mTitle
=
aTitle
;
}
NSView
*
nsFilePicker
:
:
GetAccessoryView
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSView
*
accessoryView
=
[
[
[
NSView
alloc
]
initWithFrame
:
NSMakeRect
(
0
0
0
0
)
]
autorelease
]
;
NSString
*
label
=
"
Format
:
"
;
nsCOMPtr
<
nsIStringBundleService
>
sbs
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
)
;
nsCOMPtr
<
nsIStringBundle
>
bundle
;
nsresult
rv
=
sbs
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
filepicker
.
properties
"
getter_AddRefs
(
bundle
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
locaLabel
;
rv
=
bundle
-
>
GetStringFromName
(
"
formatLabel
"
locaLabel
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
label
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
locaLabel
.
get
(
)
)
length
:
locaLabel
.
Length
(
)
]
;
}
}
NSTextField
*
textField
=
[
[
[
NSTextField
alloc
]
init
]
autorelease
]
;
[
textField
setEditable
:
NO
]
;
[
textField
setSelectable
:
NO
]
;
[
textField
setDrawsBackground
:
NO
]
;
[
textField
setBezeled
:
NO
]
;
[
textField
setBordered
:
NO
]
;
[
textField
setFont
:
[
NSFont
labelFontOfSize
:
13
.
0
]
]
;
[
textField
setStringValue
:
label
]
;
[
textField
setTag
:
0
]
;
[
textField
sizeToFit
]
;
NSPopUpButton
*
popupButton
=
[
[
[
NSPopUpButton
alloc
]
initWithFrame
:
NSMakeRect
(
0
0
0
0
)
pullsDown
:
NO
]
autorelease
]
;
uint32_t
numMenuItems
=
mTitles
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numMenuItems
;
i
+
+
)
{
const
nsString
&
currentTitle
=
mTitles
[
i
]
;
NSString
*
titleString
;
if
(
currentTitle
.
IsEmpty
(
)
)
{
const
nsString
&
currentFilter
=
mFilters
[
i
]
;
titleString
=
[
[
NSString
alloc
]
initWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
currentFilter
.
get
(
)
)
length
:
currentFilter
.
Length
(
)
]
;
}
else
{
titleString
=
[
[
NSString
alloc
]
initWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
currentTitle
.
get
(
)
)
length
:
currentTitle
.
Length
(
)
]
;
}
[
popupButton
addItemWithTitle
:
titleString
]
;
[
titleString
release
]
;
}
if
(
mSelectedTypeIndex
>
=
0
&
&
(
uint32_t
)
mSelectedTypeIndex
<
numMenuItems
)
[
popupButton
selectItemAtIndex
:
mSelectedTypeIndex
]
;
[
popupButton
setTag
:
kSaveTypeControlTag
]
;
[
popupButton
sizeToFit
]
;
[
popupButton
setFrameSize
:
NSMakeSize
(
180
[
popupButton
frame
]
.
size
.
height
)
]
;
float
greatestHeight
=
[
textField
frame
]
.
size
.
height
;
if
(
[
popupButton
frame
]
.
size
.
height
>
greatestHeight
)
greatestHeight
=
[
popupButton
frame
]
.
size
.
height
;
float
totalViewHeight
=
greatestHeight
+
kAccessoryViewPadding
*
2
;
float
totalViewWidth
=
[
textField
frame
]
.
size
.
width
+
[
popupButton
frame
]
.
size
.
width
+
kAccessoryViewPadding
*
3
;
[
accessoryView
setFrameSize
:
NSMakeSize
(
totalViewWidth
totalViewHeight
)
]
;
float
textFieldOriginY
=
(
(
greatestHeight
-
[
textField
frame
]
.
size
.
height
)
/
2
+
1
)
+
kAccessoryViewPadding
;
[
textField
setFrameOrigin
:
NSMakePoint
(
kAccessoryViewPadding
textFieldOriginY
)
]
;
float
popupOriginX
=
[
textField
frame
]
.
size
.
width
+
kAccessoryViewPadding
*
2
;
float
popupOriginY
=
(
(
greatestHeight
-
[
popupButton
frame
]
.
size
.
height
)
/
2
)
+
kAccessoryViewPadding
;
[
popupButton
setFrameOrigin
:
NSMakePoint
(
popupOriginX
popupOriginY
)
]
;
[
accessoryView
addSubview
:
textField
]
;
[
accessoryView
addSubview
:
popupButton
]
;
return
accessoryView
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
nsresult
nsFilePicker
:
:
Show
(
ResultCode
*
retval
)
{
NS_ENSURE_ARG_POINTER
(
retval
)
;
*
retval
=
returnCancel
;
ResultCode
userClicksOK
=
returnCancel
;
mFiles
.
Clear
(
)
;
nsCOMPtr
<
nsIFile
>
theFile
;
switch
(
mMode
)
{
case
modeOpen
:
userClicksOK
=
GetLocalFiles
(
false
mFiles
)
;
break
;
case
modeOpenMultiple
:
userClicksOK
=
GetLocalFiles
(
true
mFiles
)
;
break
;
case
modeSave
:
userClicksOK
=
PutLocalFile
(
getter_AddRefs
(
theFile
)
)
;
break
;
case
modeGetFolder
:
userClicksOK
=
GetLocalFolder
(
getter_AddRefs
(
theFile
)
)
;
break
;
default
:
NS_ERROR
(
"
Unknown
file
picker
mode
"
)
;
break
;
}
if
(
theFile
)
mFiles
.
AppendObject
(
theFile
)
;
*
retval
=
userClicksOK
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
Open
(
nsIFilePickerShownCallback
*
aCallback
)
{
if
(
MaybeBlockFilePicker
(
aCallback
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
filePickerEvent
=
new
AsyncShowFilePicker
(
this
aCallback
)
;
return
NS_DispatchToMainThread
(
filePickerEvent
)
;
}
static
void
UpdatePanelFileTypes
(
NSOpenPanel
*
aPanel
NSArray
*
aFilters
)
{
[
aPanel
setTreatsFilePackagesAsDirectories
:
!
aFilters
]
;
[
aPanel
setAllowedFileTypes
:
aFilters
]
;
}
implementation
NSPopUpButtonObserver
-
(
void
)
setPopUpButton
:
(
NSPopUpButton
*
)
aPopUpButton
{
mPopUpButton
=
aPopUpButton
;
}
-
(
void
)
setOpenPanel
:
(
NSOpenPanel
*
)
aOpenPanel
{
mOpenPanel
=
aOpenPanel
;
}
-
(
void
)
setFilePicker
:
(
nsFilePicker
*
)
aFilePicker
{
mFilePicker
=
aFilePicker
;
}
-
(
void
)
menuChangedItem
:
(
NSNotification
*
)
aSender
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
int32_t
selectedItem
=
[
mPopUpButton
indexOfSelectedItem
]
;
if
(
selectedItem
<
0
)
{
return
;
}
mFilePicker
-
>
SetFilterIndex
(
selectedItem
)
;
UpdatePanelFileTypes
(
mOpenPanel
mFilePicker
-
>
GetFilterList
(
)
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
)
;
}
end
nsIFilePicker
:
:
ResultCode
nsFilePicker
:
:
GetLocalFiles
(
bool
inAllowMultiple
nsCOMArray
<
nsIFile
>
&
outFiles
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
ResultCode
retVal
=
nsIFilePicker
:
:
returnCancel
;
NSOpenPanel
*
thePanel
=
[
NSOpenPanel
openPanel
]
;
SetShowHiddenFileState
(
thePanel
)
;
SetDialogTitle
(
mTitle
thePanel
)
;
[
thePanel
setAllowsMultipleSelection
:
inAllowMultiple
]
;
[
thePanel
setCanSelectHiddenExtension
:
YES
]
;
[
thePanel
setCanChooseDirectories
:
NO
]
;
[
thePanel
setCanChooseFiles
:
YES
]
;
[
thePanel
setResolvesAliases
:
YES
]
;
NSArray
*
filters
=
GetFilterList
(
)
;
NSString
*
theDir
=
PanelDefaultDirectory
(
)
;
if
(
!
theDir
)
{
if
(
filters
&
&
[
filters
count
]
=
=
1
&
&
[
(
NSString
*
)
[
filters
objectAtIndex
:
0
]
isEqualToString
:
"
app
"
]
)
theDir
=
"
/
Applications
/
"
;
else
theDir
=
"
"
;
}
if
(
theDir
)
{
[
thePanel
setDirectoryURL
:
[
NSURL
fileURLWithPath
:
theDir
isDirectory
:
YES
]
]
;
}
int
result
;
nsCocoaUtils
:
:
PrepareForNativeAppModalDialog
(
)
;
if
(
mFilters
.
Length
(
)
>
1
)
{
NSPopUpButtonObserver
*
observer
=
[
[
NSPopUpButtonObserver
alloc
]
init
]
;
NSView
*
accessoryView
=
GetAccessoryView
(
)
;
[
thePanel
setAccessoryView
:
accessoryView
]
;
[
observer
setPopUpButton
:
[
accessoryView
viewWithTag
:
kSaveTypeControlTag
]
]
;
[
observer
setOpenPanel
:
thePanel
]
;
[
observer
setFilePicker
:
this
]
;
[
[
NSNotificationCenter
defaultCenter
]
addObserver
:
observer
selector
:
selector
(
menuChangedItem
:
)
name
:
NSMenuWillSendActionNotification
object
:
nil
]
;
UpdatePanelFileTypes
(
thePanel
filters
)
;
result
=
[
thePanel
runModal
]
;
[
[
NSNotificationCenter
defaultCenter
]
removeObserver
:
observer
]
;
[
observer
release
]
;
}
else
{
if
(
!
filters
)
{
[
thePanel
setTreatsFilePackagesAsDirectories
:
YES
]
;
}
[
thePanel
setAllowedFileTypes
:
filters
]
;
result
=
[
thePanel
runModal
]
;
}
nsCocoaUtils
:
:
CleanUpAfterNativeAppModalDialog
(
)
;
if
(
result
=
=
NSModalResponseCancel
)
return
retVal
;
for
(
NSURL
*
url
in
[
thePanel
URLs
]
)
{
if
(
!
url
)
{
continue
;
}
nsCOMPtr
<
nsIFile
>
localFile
;
NS_NewLocalFile
(
u
"
"
_ns
getter_AddRefs
(
localFile
)
)
;
nsCOMPtr
<
nsILocalFileMac
>
macLocalFile
=
do_QueryInterface
(
localFile
)
;
if
(
macLocalFile
&
&
NS_SUCCEEDED
(
macLocalFile
-
>
InitWithCFURL
(
(
CFURLRef
)
url
)
)
)
{
outFiles
.
AppendObject
(
localFile
)
;
}
}
if
(
outFiles
.
Count
(
)
>
0
)
retVal
=
returnOK
;
return
retVal
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nsIFilePicker
:
:
returnOK
)
;
}
nsIFilePicker
:
:
ResultCode
nsFilePicker
:
:
GetLocalFolder
(
nsIFile
*
*
outFile
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ASSERTION
(
outFile
"
this
protected
member
function
expects
a
null
initialized
out
pointer
"
)
;
ResultCode
retVal
=
nsIFilePicker
:
:
returnCancel
;
NSOpenPanel
*
thePanel
=
[
NSOpenPanel
openPanel
]
;
SetShowHiddenFileState
(
thePanel
)
;
SetDialogTitle
(
mTitle
thePanel
)
;
[
thePanel
setAllowsMultipleSelection
:
NO
]
;
[
thePanel
setCanSelectHiddenExtension
:
YES
]
;
[
thePanel
setCanChooseDirectories
:
YES
]
;
[
thePanel
setCanChooseFiles
:
NO
]
;
[
thePanel
setResolvesAliases
:
YES
]
;
[
thePanel
setCanCreateDirectories
:
YES
]
;
[
thePanel
setTreatsFilePackagesAsDirectories
:
NO
]
;
NSString
*
theDir
=
PanelDefaultDirectory
(
)
;
if
(
theDir
)
{
[
thePanel
setDirectoryURL
:
[
NSURL
fileURLWithPath
:
theDir
isDirectory
:
YES
]
]
;
}
nsCocoaUtils
:
:
PrepareForNativeAppModalDialog
(
)
;
int
result
=
[
thePanel
runModal
]
;
nsCocoaUtils
:
:
CleanUpAfterNativeAppModalDialog
(
)
;
if
(
result
=
=
NSModalResponseCancel
)
return
retVal
;
NSURL
*
theURL
=
[
[
thePanel
URLs
]
objectAtIndex
:
0
]
;
if
(
theURL
)
{
nsCOMPtr
<
nsIFile
>
localFile
;
NS_NewLocalFile
(
u
"
"
_ns
getter_AddRefs
(
localFile
)
)
;
nsCOMPtr
<
nsILocalFileMac
>
macLocalFile
=
do_QueryInterface
(
localFile
)
;
if
(
macLocalFile
&
&
NS_SUCCEEDED
(
macLocalFile
-
>
InitWithCFURL
(
(
CFURLRef
)
theURL
)
)
)
{
*
outFile
=
localFile
;
NS_ADDREF
(
*
outFile
)
;
retVal
=
returnOK
;
}
}
return
retVal
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nsIFilePicker
:
:
returnOK
)
;
}
nsIFilePicker
:
:
ResultCode
nsFilePicker
:
:
PutLocalFile
(
nsIFile
*
*
outFile
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ASSERTION
(
outFile
"
this
protected
member
function
expects
a
null
initialized
out
pointer
"
)
;
ResultCode
retVal
=
nsIFilePicker
:
:
returnCancel
;
NSSavePanel
*
thePanel
=
[
NSSavePanel
savePanel
]
;
SetShowHiddenFileState
(
thePanel
)
;
SetDialogTitle
(
mTitle
thePanel
)
;
NSView
*
accessoryView
=
GetAccessoryView
(
)
;
[
thePanel
setAccessoryView
:
accessoryView
]
;
NSString
*
defaultFilename
=
[
NSString
stringWithCharacters
:
(
const
unichar
*
)
mDefaultFilename
.
get
(
)
length
:
mDefaultFilename
.
Length
(
)
]
;
NSString
*
extension
=
defaultFilename
.
pathExtension
;
if
(
extension
.
length
!
=
0
)
{
thePanel
.
allowedFileTypes
=
[
extension
]
;
}
thePanel
.
allowsOtherFileTypes
=
YES
;
NSString
*
fileName
=
[
[
defaultFilename
lastPathComponent
]
stringByDeletingPathExtension
]
;
NSString
*
otherExtension
=
fileName
.
pathExtension
;
if
(
otherExtension
.
length
!
=
0
)
{
CFStringRef
type
=
UTTypeCreatePreferredIdentifierForTag
(
kUTTagClassFilenameExtension
(
CFStringRef
)
otherExtension
NULL
)
;
if
(
type
)
{
if
(
!
CFStringHasPrefix
(
type
CFSTR
(
"
dyn
.
"
)
)
)
{
[
thePanel
setExtensionHidden
:
NO
]
;
}
CFRelease
(
type
)
;
}
}
NSString
*
theDir
=
PanelDefaultDirectory
(
)
;
if
(
theDir
)
{
[
thePanel
setDirectoryURL
:
[
NSURL
fileURLWithPath
:
theDir
isDirectory
:
YES
]
]
;
}
nsCocoaUtils
:
:
PrepareForNativeAppModalDialog
(
)
;
[
thePanel
setNameFieldStringValue
:
defaultFilename
]
;
int
result
=
[
thePanel
runModal
]
;
nsCocoaUtils
:
:
CleanUpAfterNativeAppModalDialog
(
)
;
if
(
result
=
=
NSModalResponseCancel
)
return
retVal
;
NSPopUpButton
*
popupButton
=
[
accessoryView
viewWithTag
:
kSaveTypeControlTag
]
;
if
(
popupButton
)
{
mSelectedTypeIndex
=
[
popupButton
indexOfSelectedItem
]
;
}
NSURL
*
fileURL
=
[
thePanel
URL
]
;
if
(
fileURL
)
{
nsCOMPtr
<
nsIFile
>
localFile
;
NS_NewLocalFile
(
u
"
"
_ns
getter_AddRefs
(
localFile
)
)
;
nsCOMPtr
<
nsILocalFileMac
>
macLocalFile
=
do_QueryInterface
(
localFile
)
;
if
(
macLocalFile
&
&
NS_SUCCEEDED
(
macLocalFile
-
>
InitWithCFURL
(
(
CFURLRef
)
fileURL
)
)
)
{
*
outFile
=
localFile
;
NS_ADDREF
(
*
outFile
)
;
if
(
[
[
NSFileManager
defaultManager
]
fileExistsAtPath
:
[
fileURL
path
]
]
)
retVal
=
returnReplace
;
else
retVal
=
returnOK
;
}
}
return
retVal
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nsIFilePicker
:
:
returnCancel
)
;
}
NSArray
*
nsFilePicker
:
:
GetFilterList
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mFilters
.
Length
(
)
)
{
return
nil
;
}
if
(
mFilters
.
Length
(
)
<
=
(
uint32_t
)
mSelectedTypeIndex
)
{
NS_WARNING
(
"
An
out
of
range
index
has
been
selected
.
Using
the
first
index
"
"
instead
.
"
)
;
mSelectedTypeIndex
=
0
;
}
const
nsString
&
filterWide
=
mFilters
[
mSelectedTypeIndex
]
;
if
(
!
filterWide
.
Length
(
)
)
{
return
nil
;
}
if
(
filterWide
.
Equals
(
u
"
*
"
_ns
)
)
{
return
nil
;
}
NSMutableString
*
filterString
=
[
[
[
NSMutableString
alloc
]
initWithString
:
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
filterWide
.
get
(
)
)
length
:
filterWide
.
Length
(
)
]
]
autorelease
]
;
NSCharacterSet
*
set
=
[
NSCharacterSet
characterSetWithCharactersInString
:
"
.
*
"
]
;
NSRange
range
=
[
filterString
rangeOfCharacterFromSet
:
set
]
;
while
(
range
.
length
)
{
[
filterString
replaceCharactersInRange
:
range
withString
:
"
"
]
;
range
=
[
filterString
rangeOfCharacterFromSet
:
set
]
;
}
return
[
[
[
NSArray
alloc
]
initWithArray
:
[
filterString
componentsSeparatedByString
:
"
;
"
]
]
autorelease
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
void
nsFilePicker
:
:
SetDialogTitle
(
const
nsString
&
inTitle
id
aPanel
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
aPanel
setTitle
:
[
NSString
stringWithCharacters
:
(
const
unichar
*
)
inTitle
.
get
(
)
length
:
inTitle
.
Length
(
)
]
]
;
if
(
!
mOkButtonLabel
.
IsEmpty
(
)
)
{
[
aPanel
setPrompt
:
[
NSString
stringWithCharacters
:
(
const
unichar
*
)
mOkButtonLabel
.
get
(
)
length
:
mOkButtonLabel
.
Length
(
)
]
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
NSString
*
nsFilePicker
:
:
PanelDefaultDirectory
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSString
*
directory
=
nil
;
if
(
mDisplayDirectory
)
{
nsAutoString
pathStr
;
mDisplayDirectory
-
>
GetPath
(
pathStr
)
;
directory
=
[
[
[
NSString
alloc
]
initWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
pathStr
.
get
(
)
)
length
:
pathStr
.
Length
(
)
]
autorelease
]
;
}
return
directory
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFile
(
nsIFile
*
*
aFile
)
{
NS_ENSURE_ARG_POINTER
(
aFile
)
;
*
aFile
=
nullptr
;
if
(
mFiles
.
Count
(
)
>
0
)
{
*
aFile
=
mFiles
.
ObjectAt
(
0
)
;
NS_IF_ADDREF
(
*
aFile
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFileURL
(
nsIURI
*
*
aFileURL
)
{
NS_ENSURE_ARG_POINTER
(
aFileURL
)
;
*
aFileURL
=
nullptr
;
if
(
mFiles
.
Count
(
)
=
=
0
)
return
NS_OK
;
return
NS_NewFileURI
(
aFileURL
mFiles
.
ObjectAt
(
0
)
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFiles
(
nsISimpleEnumerator
*
*
aFiles
)
{
return
NS_NewArrayEnumerator
(
aFiles
mFiles
NS_GET_IID
(
nsIFile
)
)
;
}
NS_IMETHODIMP
nsFilePicker
:
:
SetDefaultString
(
const
nsAString
&
aString
)
{
mDefaultFilename
=
aString
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetDefaultString
(
nsAString
&
aString
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetDefaultExtension
(
nsAString
&
aExtension
)
{
aExtension
.
Truncate
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
SetDefaultExtension
(
const
nsAString
&
aExtension
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
AppendFilter
(
const
nsAString
&
aTitle
const
nsAString
&
aFilter
)
{
if
(
aFilter
.
EqualsLiteral
(
"
.
.
apps
"
)
)
{
mFilters
.
AppendElement
(
u
"
*
.
app
"
_ns
)
;
}
else
{
mFilters
.
AppendElement
(
aFilter
)
;
}
mTitles
.
AppendElement
(
aTitle
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
GetFilterIndex
(
int32_t
*
aFilterIndex
)
{
*
aFilterIndex
=
mSelectedTypeIndex
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFilePicker
:
:
SetFilterIndex
(
int32_t
aFilterIndex
)
{
mSelectedTypeIndex
=
aFilterIndex
;
return
NS_OK
;
}
