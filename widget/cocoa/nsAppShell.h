#
ifndef
nsAppShell_h_
#
define
nsAppShell_h_
#
import
<
AppKit
/
NSApplication
.
h
>
#
include
"
nsBaseAppShell
.
h
"
#
include
"
nsTArray
.
h
"
class
ProfilingStack
;
namespace
mozilla
{
class
nsAvailableMemoryWatcherBase
;
}
interface
GeckoNSApplication
:
NSApplication
{
}
property
(
readonly
)
BOOL
didLaunch
;
end
class
AppShellDelegate
;
class
nsAppShell
:
public
nsBaseAppShell
{
public
:
NS_IMETHOD
ResumeNative
(
void
)
override
;
nsAppShell
(
)
;
nsresult
Init
(
)
;
NS_IMETHOD
Run
(
void
)
override
;
NS_IMETHOD
Exit
(
void
)
override
;
NS_IMETHOD
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
override
;
NS_IMETHOD
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aEventWasProcessed
)
override
;
void
OnRunLoopActivityChanged
(
CFRunLoopActivity
aActivity
)
;
void
WillTerminate
(
)
;
static
void
OnMemoryPressureChanged
(
dispatch_source_memorypressure_flags_t
aPressureLevel
)
;
protected
:
virtual
~
nsAppShell
(
)
;
virtual
void
ScheduleNativeEventCallback
(
)
override
;
virtual
bool
ProcessNextNativeEvent
(
bool
aMayWait
)
override
;
void
InitMemoryPressureObserver
(
)
;
static
void
ProcessGeckoEvents
(
void
*
aInfo
)
;
protected
:
CFMutableArrayRef
mAutoreleasePools
;
AppShellDelegate
*
mDelegate
;
CFRunLoopRef
mCFRunLoop
;
CFRunLoopSourceRef
mCFRunLoopSource
;
CFRunLoopObserverRef
mCFRunLoopObserver
;
ProfilingStack
*
mProfilingStackWhileWaiting
=
nullptr
;
dispatch_source_t
mMemoryPressureSource
=
nullptr
;
bool
mRunningEventLoop
;
bool
mStarted
;
bool
mTerminated
;
bool
mSkippedNativeCallback
;
bool
mRunningCocoaEmbedded
;
int32_t
mNativeEventCallbackDepth
;
int32_t
mNativeEventScheduledDepth
;
}
;
#
endif
