#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
nsMenuX
.
h
"
#
include
"
nsMenuItemIconX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
CallerType
;
using
mozilla
:
:
dom
:
:
Event
;
nsMenuItemX
:
:
nsMenuItemX
(
nsMenuX
*
aParent
const
nsString
&
aLabel
EMenuItemType
aItemType
nsMenuGroupOwnerX
*
aMenuGroupOwner
nsIContent
*
aNode
)
:
mContent
(
aNode
)
mType
(
aItemType
)
mMenuParent
(
aParent
)
mMenuGroupOwner
(
aMenuGroupOwner
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_COUNT_CTOR
(
nsMenuItemX
)
;
MOZ_RELEASE_ASSERT
(
mContent
-
>
IsElement
(
)
"
nsMenuItemX
should
only
be
created
for
elements
"
)
;
NS_ASSERTION
(
mMenuGroupOwner
"
No
menu
owner
given
must
have
one
!
"
)
;
mMenuGroupOwner
-
>
RegisterForContentChanges
(
mContent
this
)
;
dom
:
:
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
nsAutoString
ourCommand
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
command
ourCommand
)
;
if
(
!
ourCommand
.
IsEmpty
(
)
)
{
dom
:
:
Element
*
commandElement
=
doc
-
>
GetElementById
(
ourCommand
)
;
if
(
commandElement
)
{
mCommandElement
=
commandElement
;
mMenuGroupOwner
-
>
RegisterForContentChanges
(
mCommandElement
this
)
;
}
}
}
bool
isEnabled
;
if
(
mCommandElement
)
{
isEnabled
=
!
mCommandElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
else
{
isEnabled
=
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
if
(
mType
=
=
eSeparatorMenuItemType
)
{
mNativeMenuItem
=
[
[
NSMenuItem
separatorItem
]
retain
]
;
}
else
{
NSString
*
newCocoaLabelString
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
aLabel
)
;
mNativeMenuItem
=
[
[
GeckoNSMenuItem
alloc
]
initWithTitle
:
newCocoaLabelString
action
:
nil
keyEquivalent
:
"
"
]
;
mIsChecked
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
nsGkAtoms
:
:
_true
eCaseMatters
)
;
mNativeMenuItem
.
enabled
=
isEnabled
;
mNativeMenuItem
.
state
=
mIsChecked
?
NSControlStateValueOn
:
NSControlStateValueOff
;
SetKeyEquiv
(
)
;
SetBadge
(
)
;
}
mIcon
=
MakeUnique
<
nsMenuItemIconX
>
(
this
)
;
mIsVisible
=
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
id
u
"
menu_copy
"
_ns
eCaseMatters
)
)
{
mNativeMenuItem
.
action
=
selector
(
copy
:
)
;
}
else
{
mNativeMenuItem
.
action
=
selector
(
menuItemHit
:
)
;
mNativeMenuItem
.
target
=
nsMenuBarX
:
:
sNativeEventTarget
;
}
mNativeMenuItem
.
representedObject
=
mMenuGroupOwner
-
>
GetRepresentedObject
(
)
;
mNativeMenuItem
.
tag
=
mMenuGroupOwner
-
>
RegisterForCommand
(
this
)
;
if
(
mIsVisible
)
{
SetupIcon
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
nsMenuItemX
:
:
~
nsMenuItemX
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
mNativeMenuItem
autorelease
]
;
DetachFromGroupOwner
(
)
;
MOZ_COUNT_DTOR
(
nsMenuItemX
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuItemX
:
:
DetachFromGroupOwner
(
)
{
if
(
mMenuGroupOwner
)
{
mMenuGroupOwner
-
>
UnregisterCommand
(
mNativeMenuItem
.
tag
)
;
if
(
mContent
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mContent
)
;
}
if
(
mCommandElement
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mCommandElement
)
;
}
}
mMenuGroupOwner
=
nullptr
;
}
nsresult
nsMenuItemX
:
:
SetChecked
(
bool
aIsChecked
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mIsChecked
=
aIsChecked
;
if
(
mIsChecked
)
{
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
u
"
true
"
_ns
true
)
;
}
else
{
mContent
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
true
)
;
}
mNativeMenuItem
.
state
=
mIsChecked
?
NSControlStateValueOn
:
NSControlStateValueOff
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
EMenuItemType
nsMenuItemX
:
:
GetMenuItemType
(
)
{
return
mType
;
}
void
nsMenuItemX
:
:
DoCommand
(
NSEventModifierFlags
aModifierFlags
int16_t
aButton
)
{
if
(
mType
=
=
eCheckboxMenuItemType
|
|
(
mType
=
=
eRadioMenuItemType
&
&
!
mIsChecked
)
)
{
if
(
!
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
autocheck
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
SetChecked
(
!
mIsChecked
)
;
}
}
nsMenuUtilsX
:
:
DispatchCommandTo
(
mContent
aModifierFlags
aButton
)
;
}
nsresult
nsMenuItemX
:
:
DispatchDOMEvent
(
const
nsString
&
eventName
bool
*
preventDefaultCalled
)
{
if
(
!
mContent
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
dom
:
:
Document
>
parentDoc
=
mContent
-
>
OwnerDoc
(
)
;
ErrorResult
rv
;
RefPtr
<
Event
>
event
=
parentDoc
-
>
CreateEvent
(
u
"
Events
"
_ns
CallerType
:
:
System
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
create
Event
"
)
;
return
rv
.
StealNSResult
(
)
;
}
event
-
>
InitEvent
(
eventName
true
true
)
;
event
-
>
SetTrusted
(
true
)
;
*
preventDefaultCalled
=
mContent
-
>
DispatchEvent
(
*
event
CallerType
:
:
System
rv
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Failed
to
send
DOM
event
via
EventTarget
"
)
;
return
rv
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
void
nsMenuItemX
:
:
UncheckRadioSiblings
(
nsIContent
*
aCheckedContent
)
{
nsAutoString
myGroupName
;
aCheckedContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
name
myGroupName
)
;
if
(
!
myGroupName
.
Length
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
parent
=
aCheckedContent
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
;
}
for
(
nsIContent
*
sibling
=
parent
-
>
GetFirstChild
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
sibling
!
=
aCheckedContent
&
&
sibling
-
>
IsElement
(
)
)
{
if
(
sibling
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
myGroupName
eCaseMatters
)
)
{
sibling
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
u
"
false
"
_ns
true
)
;
}
}
}
}
void
nsMenuItemX
:
:
SetKeyEquiv
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
nsAutoString
keyValue
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
key
keyValue
)
;
if
(
!
keyValue
.
IsEmpty
(
)
&
&
mContent
-
>
GetUncomposedDoc
(
)
)
{
dom
:
:
Element
*
keyContent
=
mContent
-
>
GetUncomposedDoc
(
)
-
>
GetElementById
(
keyValue
)
;
if
(
keyContent
)
{
nsAutoString
keyChar
;
bool
hasKey
=
keyContent
-
>
GetAttr
(
nsGkAtoms
:
:
key
keyChar
)
;
if
(
!
hasKey
|
|
keyChar
.
IsEmpty
(
)
)
{
nsAutoString
keyCodeName
;
keyContent
-
>
GetAttr
(
nsGkAtoms
:
:
keycode
keyCodeName
)
;
uint32_t
charCode
=
nsCocoaUtils
:
:
ConvertGeckoNameToMacCharCode
(
keyCodeName
)
;
if
(
charCode
)
{
keyChar
.
Assign
(
charCode
)
;
}
else
{
keyChar
.
AssignLiteral
(
u
"
"
)
;
}
}
nsAutoString
modifiersStr
;
keyContent
-
>
GetAttr
(
nsGkAtoms
:
:
modifiers
modifiersStr
)
;
uint8_t
modifiers
=
nsMenuUtilsX
:
:
GeckoModifiersForNodeAttribute
(
modifiersStr
)
;
unsigned
int
macModifiers
=
nsMenuUtilsX
:
:
MacModifiersForGeckoModifiers
(
modifiers
)
;
mNativeMenuItem
.
keyEquivalentModifierMask
=
macModifiers
;
NSString
*
keyEquivalent
=
[
[
NSString
stringWithCharacters
:
(
unichar
*
)
keyChar
.
get
(
)
length
:
keyChar
.
Length
(
)
]
lowercaseString
]
;
if
(
[
keyEquivalent
isEqualToString
:
"
"
]
)
{
mNativeMenuItem
.
keyEquivalent
=
"
"
;
}
else
{
mNativeMenuItem
.
keyEquivalent
=
keyEquivalent
;
}
return
;
}
}
mNativeMenuItem
.
keyEquivalent
=
"
"
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuItemX
:
:
SetBadge
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
available
(
macOS
14
.
0
*
)
)
{
nsAutoString
badgeValue
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
badge
badgeValue
)
)
{
mNativeMenuItem
.
badge
=
nullptr
;
return
;
}
mNativeMenuItem
.
badge
=
[
[
NSMenuItemBadge
alloc
]
initWithString
:
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
badgeValue
)
]
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsMenuItemX
:
:
Dump
(
uint32_t
aIndent
)
const
{
printf
(
"
%
*
s
-
item
[
%
p
]
%
-
16s
<
%
s
>
\
n
"
aIndent
*
2
"
"
this
mType
=
=
eSeparatorMenuItemType
?
"
-
-
-
-
"
:
[
mNativeMenuItem
.
title
UTF8String
]
NS_ConvertUTF16toUTF8
(
mContent
-
>
NodeName
(
)
)
.
get
(
)
)
;
}
void
nsMenuItemX
:
:
ObserveAttributeChanged
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContent
nsAtom
*
aAttribute
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
aContent
)
{
return
;
}
if
(
aContent
=
=
mContent
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
checked
)
{
if
(
mType
=
=
eRadioMenuItemType
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
UncheckRadioSiblings
(
mContent
)
;
}
mMenuParent
-
>
SetRebuild
(
true
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
hidden
|
|
aAttribute
=
=
nsGkAtoms
:
:
collapsed
)
{
bool
isVisible
=
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
mContent
)
;
if
(
isVisible
!
=
mIsVisible
)
{
mIsVisible
=
isVisible
;
RefPtr
<
nsMenuItemX
>
self
=
this
;
mMenuParent
-
>
MenuChildChangedVisibility
(
nsMenuParentX
:
:
MenuChild
(
self
)
isVisible
)
;
if
(
mIsVisible
)
{
SetupIcon
(
)
;
}
}
mMenuParent
-
>
SetRebuild
(
true
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
if
(
mType
!
=
eSeparatorMenuItemType
)
{
nsAutoString
newLabel
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
label
newLabel
)
;
mNativeMenuItem
.
title
=
nsMenuUtilsX
:
:
GetTruncatedCocoaLabel
(
newLabel
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
badge
)
{
SetBadge
(
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
key
)
{
SetKeyEquiv
(
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
image
)
{
SetupIcon
(
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
{
mNativeMenuItem
.
enabled
=
!
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
}
else
if
(
aContent
=
=
mCommandElement
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
{
nsAutoString
commandDisabled
;
nsAutoString
menuDisabled
;
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
disabled
commandDisabled
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
disabled
menuDisabled
)
;
if
(
!
commandDisabled
.
Equals
(
menuDisabled
)
)
{
if
(
commandDisabled
.
IsEmpty
(
)
)
{
mContent
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
true
)
;
}
else
{
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
commandDisabled
true
)
;
}
}
mNativeMenuItem
.
enabled
=
!
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
IsMenuStructureElement
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
menuitem
nsGkAtoms
:
:
menuseparator
)
;
}
void
nsMenuItemX
:
:
ObserveContentRemoved
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
MOZ_RELEASE_ASSERT
(
mMenuGroupOwner
)
;
MOZ_RELEASE_ASSERT
(
mMenuParent
)
;
if
(
aChild
=
=
mCommandElement
)
{
mMenuGroupOwner
-
>
UnregisterForContentChanges
(
mCommandElement
)
;
mCommandElement
=
nullptr
;
}
if
(
IsMenuStructureElement
(
aChild
)
)
{
mMenuParent
-
>
SetRebuild
(
true
)
;
}
}
void
nsMenuItemX
:
:
ObserveContentInserted
(
dom
:
:
Document
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
)
{
MOZ_RELEASE_ASSERT
(
mMenuParent
)
;
if
(
IsMenuStructureElement
(
aChild
)
)
{
mMenuParent
-
>
SetRebuild
(
true
)
;
}
if
(
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
SetupIcon
(
)
;
}
}
void
nsMenuItemX
:
:
SetupIcon
(
)
{
if
(
mType
!
=
eRegularMenuItemType
)
{
return
;
}
mIcon
-
>
SetupIcon
(
mContent
)
;
mNativeMenuItem
.
image
=
mIcon
-
>
GetIconImage
(
)
;
}
void
nsMenuItemX
:
:
IconUpdated
(
)
{
mNativeMenuItem
.
image
=
mIcon
-
>
GetIconImage
(
)
;
}
