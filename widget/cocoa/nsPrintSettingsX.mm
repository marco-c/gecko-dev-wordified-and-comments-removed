#
include
"
nsPrintSettingsX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
plbase64
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
nsPrinterCUPS
.
h
"
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS_INHERITED
(
nsPrintSettingsX
nsPrintSettings
nsPrintSettingsX
)
nsPrintSettingsX
:
:
nsPrintSettingsX
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
mDestination
=
kPMDestinationInvalid
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
already_AddRefed
<
nsIPrintSettings
>
CreatePlatformPrintSettings
(
const
PrintSettingsInitializer
&
aSettings
)
{
RefPtr
<
nsPrintSettings
>
settings
=
new
nsPrintSettingsX
(
)
;
settings
-
>
InitWithInitializer
(
aSettings
)
;
settings
-
>
SetDefaultFileName
(
)
;
return
settings
.
forget
(
)
;
}
nsPrintSettingsX
&
nsPrintSettingsX
:
:
operator
=
(
const
nsPrintSettingsX
&
rhs
)
{
if
(
this
=
=
&
rhs
)
{
return
*
this
;
}
nsPrintSettings
:
:
operator
=
(
rhs
)
;
mDestination
=
rhs
.
mDestination
;
mDisposition
=
rhs
.
mDisposition
;
return
*
this
;
}
nsresult
nsPrintSettingsX
:
:
_Clone
(
nsIPrintSettings
*
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
auto
newSettings
=
MakeRefPtr
<
nsPrintSettingsX
>
(
)
;
*
newSettings
=
*
this
;
newSettings
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPrintSettingsX
:
:
_Assign
(
nsIPrintSettings
*
aPS
)
{
nsPrintSettingsX
*
printSettingsX
=
static_cast
<
nsPrintSettingsX
*
>
(
aPS
)
;
if
(
!
printSettingsX
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
this
=
*
printSettingsX
;
return
NS_OK
;
}
struct
KnownMonochromeSetting
{
const
NSString
*
mName
;
const
NSString
*
mValue
;
}
;
#
define
DECLARE_KNOWN_MONOCHROME_SETTING
(
key_
value_
)
\
{
key_
value_
}
\
static
const
KnownMonochromeSetting
kKnownMonochromeSettings
[
]
=
{
CUPS_EACH_MONOCHROME_PRINTER_SETTING
(
DECLARE_KNOWN_MONOCHROME_SETTING
)
}
;
#
undef
DECLARE_KNOWN_MONOCHROME_SETTING
NSPrintInfo
*
nsPrintSettingsX
:
:
CreateOrCopyPrintInfo
(
bool
aWithScaling
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
mSystemPrintInfo
)
{
NSPrintInfo
*
sysPrintInfo
=
[
mSystemPrintInfo
copy
]
;
[
sysPrintInfo
setScalingFactor
:
1
.
0f
]
;
return
sysPrintInfo
;
}
NSPrintInfo
*
printInfo
=
[
[
NSPrintInfo
sharedPrintInfo
]
copy
]
;
NSSize
paperSize
;
if
(
GetSheetOrientation
(
)
=
=
kPortraitOrientation
)
{
paperSize
.
width
=
CocoaPointsFromPaperSize
(
mPaperWidth
)
;
paperSize
.
height
=
CocoaPointsFromPaperSize
(
mPaperHeight
)
;
}
else
{
paperSize
.
width
=
CocoaPointsFromPaperSize
(
mPaperHeight
)
;
paperSize
.
height
=
CocoaPointsFromPaperSize
(
mPaperWidth
)
;
}
[
printInfo
setPaperSize
:
paperSize
]
;
if
(
paperSize
.
width
>
paperSize
.
height
)
{
[
printInfo
setOrientation
:
NSPaperOrientationLandscape
]
;
}
else
{
[
printInfo
setOrientation
:
NSPaperOrientationPortrait
]
;
}
[
printInfo
setTopMargin
:
mUnwriteableMargin
.
top
]
;
[
printInfo
setRightMargin
:
mUnwriteableMargin
.
right
]
;
[
printInfo
setBottomMargin
:
mUnwriteableMargin
.
bottom
]
;
[
printInfo
setLeftMargin
:
mUnwriteableMargin
.
left
]
;
if
(
!
mPrinter
.
EqualsLiteral
(
"
Mozilla
Save
to
PDF
"
)
)
{
[
printInfo
setPrinter
:
[
NSPrinter
printerWithName
:
nsCocoaUtils
:
:
ToNSString
(
mPrinter
)
]
]
;
}
[
printInfo
setScalingFactor
:
CGFloat
(
aWithScaling
?
mScaling
:
1
.
0f
)
]
;
const
bool
allPages
=
mPageRanges
.
IsEmpty
(
)
;
NSMutableDictionary
*
dict
=
[
printInfo
dictionary
]
;
[
dict
setObject
:
[
NSNumber
numberWithInt
:
mNumCopies
]
forKey
:
NSPrintCopies
]
;
[
dict
setObject
:
[
NSNumber
numberWithBool
:
allPages
]
forKey
:
NSPrintAllPages
]
;
int32_t
start
=
1
;
int32_t
end
=
1
;
for
(
size_t
i
=
0
;
i
<
mPageRanges
.
Length
(
)
;
i
+
=
2
)
{
start
=
std
:
:
min
(
start
mPageRanges
[
i
]
)
;
end
=
std
:
:
max
(
end
mPageRanges
[
i
+
1
]
)
;
}
[
dict
setObject
:
[
NSNumber
numberWithInt
:
start
]
forKey
:
NSPrintFirstPage
]
;
[
dict
setObject
:
[
NSNumber
numberWithInt
:
end
]
forKey
:
NSPrintLastPage
]
;
NSURL
*
jobSavingURL
=
nullptr
;
if
(
!
mToFileName
.
IsEmpty
(
)
)
{
jobSavingURL
=
[
NSURL
fileURLWithPath
:
nsCocoaUtils
:
:
ToNSString
(
mToFileName
)
]
;
if
(
jobSavingURL
)
{
[
dict
setObject
:
jobSavingURL
forKey
:
NSPrintJobSavingURL
]
;
}
}
if
(
mDisposition
.
IsEmpty
(
)
)
{
if
(
mOutputDestination
=
=
kOutputDestinationFile
)
{
[
printInfo
setJobDisposition
:
NSPrintSaveJob
]
;
}
else
{
[
printInfo
setJobDisposition
:
NSPrintSpoolJob
]
;
}
}
else
{
[
printInfo
setJobDisposition
:
nsCocoaUtils
:
:
ToNSString
(
mDisposition
)
]
;
}
PMDuplexMode
duplexSetting
;
switch
(
mDuplex
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unknown
duplex
value
"
)
;
case
kDuplexNone
:
duplexSetting
=
kPMDuplexNone
;
break
;
case
kDuplexFlipOnLongEdge
:
duplexSetting
=
kPMDuplexNoTumble
;
break
;
case
kDuplexFlipOnShortEdge
:
duplexSetting
=
kPMDuplexTumble
;
break
;
}
NSMutableDictionary
*
printSettings
=
[
printInfo
printSettings
]
;
[
printSettings
setObject
:
[
NSNumber
numberWithUnsignedShort
:
duplexSetting
]
forKey
:
"
com_apple_print_PrintSettings_PMDuplexing
"
]
;
if
(
mDestination
!
=
kPMDestinationInvalid
)
{
[
printSettings
setObject
:
[
NSNumber
numberWithUnsignedShort
:
mDestination
]
forKey
:
"
com_apple_print_PrintSettings_PMDestinationType
"
]
;
if
(
jobSavingURL
)
{
[
printSettings
setObject
:
[
jobSavingURL
absoluteString
]
forKey
:
"
com_apple_print_PrintSettings_PMOutputFilename
"
]
;
}
}
if
(
StaticPrefs
:
:
print_cups_monochrome_enabled
(
)
&
&
!
GetPrintInColor
(
)
)
{
for
(
const
auto
&
setting
:
kKnownMonochromeSettings
)
{
[
printSettings
setObject
:
setting
.
mValue
forKey
:
setting
.
mName
]
;
}
auto
applySetting
=
[
&
]
(
const
nsACString
&
aKey
const
nsACString
&
aValue
)
{
[
printSettings
setObject
:
nsCocoaUtils
:
:
ToNSString
(
aValue
)
forKey
:
nsCocoaUtils
:
:
ToNSString
(
aKey
)
]
;
}
;
nsPrinterCUPS
:
:
ForEachExtraMonochromeSetting
(
applySetting
)
;
}
return
printInfo
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nullptr
)
;
}
void
nsPrintSettingsX
:
:
SetFromPrintInfo
(
NSPrintInfo
*
aPrintInfo
bool
aAdoptPrintInfo
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSSize
paperSize
=
[
aPrintInfo
paperSize
]
;
const
bool
areSheetsOfPaperPortraitMode
=
(
[
aPrintInfo
orientation
]
=
=
NSPaperOrientationPortrait
)
;
const
bool
arePagesPortraitMode
=
(
areSheetsOfPaperPortraitMode
!
=
HasOrthogonalPagesPerSheet
(
)
)
;
if
(
arePagesPortraitMode
)
{
mOrientation
=
nsIPrintSettings
:
:
kPortraitOrientation
;
SetPaperWidth
(
PaperSizeFromCocoaPoints
(
paperSize
.
width
)
)
;
SetPaperHeight
(
PaperSizeFromCocoaPoints
(
paperSize
.
height
)
)
;
}
else
{
mOrientation
=
nsIPrintSettings
:
:
kLandscapeOrientation
;
SetPaperWidth
(
PaperSizeFromCocoaPoints
(
paperSize
.
height
)
)
;
SetPaperHeight
(
PaperSizeFromCocoaPoints
(
paperSize
.
width
)
)
;
}
mUnwriteableMargin
.
top
=
static_cast
<
int32_t
>
(
[
aPrintInfo
topMargin
]
)
;
mUnwriteableMargin
.
right
=
static_cast
<
int32_t
>
(
[
aPrintInfo
rightMargin
]
)
;
mUnwriteableMargin
.
bottom
=
static_cast
<
int32_t
>
(
[
aPrintInfo
bottomMargin
]
)
;
mUnwriteableMargin
.
left
=
static_cast
<
int32_t
>
(
[
aPrintInfo
leftMargin
]
)
;
if
(
aAdoptPrintInfo
)
{
if
(
mSystemPrintInfo
!
=
aPrintInfo
)
{
if
(
mSystemPrintInfo
)
{
[
mSystemPrintInfo
release
]
;
}
mSystemPrintInfo
=
aPrintInfo
;
[
mSystemPrintInfo
retain
]
;
}
}
else
{
if
(
mSystemPrintInfo
)
{
[
mSystemPrintInfo
release
]
;
mSystemPrintInfo
=
nullptr
;
}
}
nsCocoaUtils
:
:
GetStringForNSString
(
[
[
aPrintInfo
printer
]
name
]
mPrinter
)
;
bool
isShrinkToFitChecked
;
GetShrinkToFit
(
&
isShrinkToFitChecked
)
;
if
(
!
isShrinkToFitChecked
)
{
mScaling
=
round
(
double
(
[
aPrintInfo
scalingFactor
]
)
*
100
.
0
)
/
100
.
0
;
}
mOutputDestination
=
[
&
]
{
if
(
[
aPrintInfo
jobDisposition
]
=
=
NSPrintSaveJob
)
{
return
kOutputDestinationFile
;
}
return
kOutputDestinationPrinter
;
}
(
)
;
NSDictionary
*
dict
=
[
aPrintInfo
dictionary
]
;
const
char
*
filePath
=
[
[
dict
objectForKey
:
NSPrintJobSavingURL
]
fileSystemRepresentation
]
;
if
(
filePath
&
&
*
filePath
)
{
CopyUTF8toUTF16
(
Span
(
filePath
strlen
(
filePath
)
)
mToFileName
)
;
}
nsCocoaUtils
:
:
GetStringForNSString
(
[
aPrintInfo
jobDisposition
]
mDisposition
)
;
mNumCopies
=
[
[
dict
objectForKey
:
NSPrintCopies
]
intValue
]
;
mPageRanges
.
Clear
(
)
;
if
(
!
[
[
dict
objectForKey
:
NSPrintAllPages
]
boolValue
]
)
{
mPageRanges
.
AppendElement
(
[
[
dict
objectForKey
:
NSPrintFirstPage
]
intValue
]
)
;
mPageRanges
.
AppendElement
(
[
[
dict
objectForKey
:
NSPrintLastPage
]
intValue
]
)
;
}
NSDictionary
*
printSettings
=
[
aPrintInfo
printSettings
]
;
NSNumber
*
value
=
[
printSettings
objectForKey
:
"
com_apple_print_PrintSettings_PMDuplexing
"
]
;
if
(
value
)
{
PMDuplexMode
duplexSetting
=
[
value
unsignedShortValue
]
;
switch
(
duplexSetting
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unknown
duplex
value
"
)
;
case
kPMDuplexNone
:
mDuplex
=
kDuplexNone
;
break
;
case
kPMDuplexNoTumble
:
mDuplex
=
kDuplexFlipOnLongEdge
;
break
;
case
kPMDuplexTumble
:
mDuplex
=
kDuplexFlipOnShortEdge
;
break
;
}
}
else
{
mDuplex
=
kDuplexNone
;
}
value
=
[
printSettings
objectForKey
:
"
com_apple_print_PrintSettings_PMDestinationType
"
]
;
if
(
value
)
{
mDestination
=
[
value
unsignedShortValue
]
;
}
const
bool
color
=
[
&
]
{
if
(
StaticPrefs
:
:
print_cups_monochrome_enabled
(
)
)
{
for
(
const
auto
&
setting
:
kKnownMonochromeSettings
)
{
NSString
*
value
=
[
printSettings
objectForKey
:
setting
.
mName
]
;
if
(
!
value
)
{
continue
;
}
if
(
[
setting
.
mValue
isEqualToString
:
value
]
)
{
return
false
;
}
}
}
return
true
;
}
(
)
;
SetPrintInColor
(
color
)
;
SetIsInitializedFromPrinter
(
true
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
