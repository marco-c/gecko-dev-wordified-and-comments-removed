#
include
"
TextInputHandler
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
WidgetUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
ComplexTextInputPanel
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
LazyLogModule
gLog
(
"
TextInputHandlerWidgets
"
)
;
static
const
char
*
OnOrOff
(
bool
aBool
)
{
return
aBool
?
"
ON
"
:
"
off
"
;
}
static
const
char
*
TrueOrFalse
(
bool
aBool
)
{
return
aBool
?
"
TRUE
"
:
"
FALSE
"
;
}
static
const
char
*
GetKeyNameForNativeKeyCode
(
unsigned
short
aNativeKeyCode
)
{
switch
(
aNativeKeyCode
)
{
case
kVK_Escape
:
return
"
Escape
"
;
case
kVK_RightCommand
:
return
"
Right
-
Command
"
;
case
kVK_Command
:
return
"
Command
"
;
case
kVK_Shift
:
return
"
Shift
"
;
case
kVK_CapsLock
:
return
"
CapsLock
"
;
case
kVK_Option
:
return
"
Option
"
;
case
kVK_Control
:
return
"
Control
"
;
case
kVK_RightShift
:
return
"
Right
-
Shift
"
;
case
kVK_RightOption
:
return
"
Right
-
Option
"
;
case
kVK_RightControl
:
return
"
Right
-
Control
"
;
case
kVK_ANSI_KeypadClear
:
return
"
Clear
"
;
case
kVK_F1
:
return
"
F1
"
;
case
kVK_F2
:
return
"
F2
"
;
case
kVK_F3
:
return
"
F3
"
;
case
kVK_F4
:
return
"
F4
"
;
case
kVK_F5
:
return
"
F5
"
;
case
kVK_F6
:
return
"
F6
"
;
case
kVK_F7
:
return
"
F7
"
;
case
kVK_F8
:
return
"
F8
"
;
case
kVK_F9
:
return
"
F9
"
;
case
kVK_F10
:
return
"
F10
"
;
case
kVK_F11
:
return
"
F11
"
;
case
kVK_F12
:
return
"
F12
"
;
case
kVK_F13
:
return
"
F13
/
PrintScreen
"
;
case
kVK_F14
:
return
"
F14
/
ScrollLock
"
;
case
kVK_F15
:
return
"
F15
/
Pause
"
;
case
kVK_ANSI_Keypad0
:
return
"
NumPad
-
0
"
;
case
kVK_ANSI_Keypad1
:
return
"
NumPad
-
1
"
;
case
kVK_ANSI_Keypad2
:
return
"
NumPad
-
2
"
;
case
kVK_ANSI_Keypad3
:
return
"
NumPad
-
3
"
;
case
kVK_ANSI_Keypad4
:
return
"
NumPad
-
4
"
;
case
kVK_ANSI_Keypad5
:
return
"
NumPad
-
5
"
;
case
kVK_ANSI_Keypad6
:
return
"
NumPad
-
6
"
;
case
kVK_ANSI_Keypad7
:
return
"
NumPad
-
7
"
;
case
kVK_ANSI_Keypad8
:
return
"
NumPad
-
8
"
;
case
kVK_ANSI_Keypad9
:
return
"
NumPad
-
9
"
;
case
kVK_ANSI_KeypadMultiply
:
return
"
NumPad
-
*
"
;
case
kVK_ANSI_KeypadPlus
:
return
"
NumPad
-
+
"
;
case
kVK_ANSI_KeypadMinus
:
return
"
NumPad
-
-
"
;
case
kVK_ANSI_KeypadDecimal
:
return
"
NumPad
-
.
"
;
case
kVK_ANSI_KeypadDivide
:
return
"
NumPad
-
/
"
;
case
kVK_ANSI_KeypadEquals
:
return
"
NumPad
-
=
"
;
case
kVK_ANSI_KeypadEnter
:
return
"
NumPad
-
Enter
"
;
case
kVK_Return
:
return
"
Return
"
;
case
kVK_Powerbook_KeypadEnter
:
return
"
NumPad
-
EnterOnPowerBook
"
;
case
kVK_PC_Insert
:
return
"
Insert
/
Help
"
;
case
kVK_PC_Delete
:
return
"
Delete
"
;
case
kVK_Tab
:
return
"
Tab
"
;
case
kVK_PC_Backspace
:
return
"
Backspace
"
;
case
kVK_Home
:
return
"
Home
"
;
case
kVK_End
:
return
"
End
"
;
case
kVK_PageUp
:
return
"
PageUp
"
;
case
kVK_PageDown
:
return
"
PageDown
"
;
case
kVK_LeftArrow
:
return
"
LeftArrow
"
;
case
kVK_RightArrow
:
return
"
RightArrow
"
;
case
kVK_UpArrow
:
return
"
UpArrow
"
;
case
kVK_DownArrow
:
return
"
DownArrow
"
;
case
kVK_PC_ContextMenu
:
return
"
ContextMenu
"
;
case
kVK_Function
:
return
"
Function
"
;
case
kVK_VolumeUp
:
return
"
VolumeUp
"
;
case
kVK_VolumeDown
:
return
"
VolumeDown
"
;
case
kVK_Mute
:
return
"
Mute
"
;
case
kVK_ISO_Section
:
return
"
ISO_Section
"
;
case
kVK_JIS_Yen
:
return
"
JIS_Yen
"
;
case
kVK_JIS_Underscore
:
return
"
JIS_Underscore
"
;
case
kVK_JIS_KeypadComma
:
return
"
JIS_KeypadComma
"
;
case
kVK_JIS_Eisu
:
return
"
JIS_Eisu
"
;
case
kVK_JIS_Kana
:
return
"
JIS_Kana
"
;
case
kVK_ANSI_A
:
return
"
A
"
;
case
kVK_ANSI_B
:
return
"
B
"
;
case
kVK_ANSI_C
:
return
"
C
"
;
case
kVK_ANSI_D
:
return
"
D
"
;
case
kVK_ANSI_E
:
return
"
E
"
;
case
kVK_ANSI_F
:
return
"
F
"
;
case
kVK_ANSI_G
:
return
"
G
"
;
case
kVK_ANSI_H
:
return
"
H
"
;
case
kVK_ANSI_I
:
return
"
I
"
;
case
kVK_ANSI_J
:
return
"
J
"
;
case
kVK_ANSI_K
:
return
"
K
"
;
case
kVK_ANSI_L
:
return
"
L
"
;
case
kVK_ANSI_M
:
return
"
M
"
;
case
kVK_ANSI_N
:
return
"
N
"
;
case
kVK_ANSI_O
:
return
"
O
"
;
case
kVK_ANSI_P
:
return
"
P
"
;
case
kVK_ANSI_Q
:
return
"
Q
"
;
case
kVK_ANSI_R
:
return
"
R
"
;
case
kVK_ANSI_S
:
return
"
S
"
;
case
kVK_ANSI_T
:
return
"
T
"
;
case
kVK_ANSI_U
:
return
"
U
"
;
case
kVK_ANSI_V
:
return
"
V
"
;
case
kVK_ANSI_W
:
return
"
W
"
;
case
kVK_ANSI_X
:
return
"
X
"
;
case
kVK_ANSI_Y
:
return
"
Y
"
;
case
kVK_ANSI_Z
:
return
"
Z
"
;
case
kVK_ANSI_1
:
return
"
1
"
;
case
kVK_ANSI_2
:
return
"
2
"
;
case
kVK_ANSI_3
:
return
"
3
"
;
case
kVK_ANSI_4
:
return
"
4
"
;
case
kVK_ANSI_5
:
return
"
5
"
;
case
kVK_ANSI_6
:
return
"
6
"
;
case
kVK_ANSI_7
:
return
"
7
"
;
case
kVK_ANSI_8
:
return
"
8
"
;
case
kVK_ANSI_9
:
return
"
9
"
;
case
kVK_ANSI_0
:
return
"
0
"
;
case
kVK_ANSI_Equal
:
return
"
Equal
"
;
case
kVK_ANSI_Minus
:
return
"
Minus
"
;
case
kVK_ANSI_RightBracket
:
return
"
RightBracket
"
;
case
kVK_ANSI_LeftBracket
:
return
"
LeftBracket
"
;
case
kVK_ANSI_Quote
:
return
"
Quote
"
;
case
kVK_ANSI_Semicolon
:
return
"
Semicolon
"
;
case
kVK_ANSI_Backslash
:
return
"
Backslash
"
;
case
kVK_ANSI_Comma
:
return
"
Comma
"
;
case
kVK_ANSI_Slash
:
return
"
Slash
"
;
case
kVK_ANSI_Period
:
return
"
Period
"
;
case
kVK_ANSI_Grave
:
return
"
Grave
"
;
default
:
return
"
undefined
"
;
}
}
static
const
char
*
GetCharacters
(
const
nsAString
&
aString
)
{
if
(
aString
.
IsEmpty
(
)
)
{
return
"
"
;
}
nsAutoString
escapedStr
;
for
(
uint32_t
i
=
0
;
i
<
aString
.
Length
(
)
;
i
+
+
)
{
char16_t
ch
=
aString
.
CharAt
(
i
)
;
if
(
ch
<
0x20
)
{
nsPrintfCString
utf8str
(
"
(
U
+
%
04X
)
"
ch
)
;
escapedStr
+
=
NS_ConvertUTF8toUTF16
(
utf8str
)
;
}
else
if
(
ch
<
=
0x7E
)
{
escapedStr
+
=
ch
;
}
else
{
nsPrintfCString
utf8str
(
"
(
U
+
%
04X
)
"
ch
)
;
escapedStr
+
=
ch
;
escapedStr
+
=
NS_ConvertUTF8toUTF16
(
utf8str
)
;
}
}
NSString
*
result
=
nsCocoaUtils
:
:
ToNSString
(
escapedStr
)
;
return
[
result
UTF8String
]
;
}
static
const
char
*
GetCharacters
(
const
NSString
*
aString
)
{
nsAutoString
str
;
nsCocoaUtils
:
:
GetStringForNSString
(
aString
str
)
;
return
GetCharacters
(
str
)
;
}
static
const
char
*
GetCharacters
(
const
CFStringRef
aString
)
{
const
NSString
*
str
=
reinterpret_cast
<
const
NSString
*
>
(
aString
)
;
return
GetCharacters
(
str
)
;
}
static
const
char
*
GetNativeKeyEventType
(
NSEvent
*
aNativeEvent
)
{
switch
(
[
aNativeEvent
type
]
)
{
case
NSKeyDown
:
return
"
NSKeyDown
"
;
case
NSKeyUp
:
return
"
NSKeyUp
"
;
case
NSFlagsChanged
:
return
"
NSFlagsChanged
"
;
default
:
return
"
not
key
event
"
;
}
}
static
const
char
*
GetGeckoKeyEventType
(
const
WidgetEvent
&
aEvent
)
{
switch
(
aEvent
.
mMessage
)
{
case
eKeyDown
:
return
"
eKeyDown
"
;
case
eKeyUp
:
return
"
eKeyUp
"
;
case
eKeyPress
:
return
"
eKeyPress
"
;
default
:
return
"
not
key
event
"
;
}
}
static
const
char
*
GetWindowLevelName
(
NSInteger
aWindowLevel
)
{
switch
(
aWindowLevel
)
{
case
kCGBaseWindowLevelKey
:
return
"
kCGBaseWindowLevelKey
(
NSNormalWindowLevel
)
"
;
case
kCGMinimumWindowLevelKey
:
return
"
kCGMinimumWindowLevelKey
"
;
case
kCGDesktopWindowLevelKey
:
return
"
kCGDesktopWindowLevelKey
"
;
case
kCGBackstopMenuLevelKey
:
return
"
kCGBackstopMenuLevelKey
"
;
case
kCGNormalWindowLevelKey
:
return
"
kCGNormalWindowLevelKey
"
;
case
kCGFloatingWindowLevelKey
:
return
"
kCGFloatingWindowLevelKey
(
NSFloatingWindowLevel
)
"
;
case
kCGTornOffMenuWindowLevelKey
:
return
"
kCGTornOffMenuWindowLevelKey
(
NSSubmenuWindowLevel
NSTornOffMenuWindowLevel
)
"
;
case
kCGDockWindowLevelKey
:
return
"
kCGDockWindowLevelKey
(
NSDockWindowLevel
)
"
;
case
kCGMainMenuWindowLevelKey
:
return
"
kCGMainMenuWindowLevelKey
(
NSMainMenuWindowLevel
)
"
;
case
kCGStatusWindowLevelKey
:
return
"
kCGStatusWindowLevelKey
(
NSStatusWindowLevel
)
"
;
case
kCGModalPanelWindowLevelKey
:
return
"
kCGModalPanelWindowLevelKey
(
NSModalPanelWindowLevel
)
"
;
case
kCGPopUpMenuWindowLevelKey
:
return
"
kCGPopUpMenuWindowLevelKey
(
NSPopUpMenuWindowLevel
)
"
;
case
kCGDraggingWindowLevelKey
:
return
"
kCGDraggingWindowLevelKey
"
;
case
kCGScreenSaverWindowLevelKey
:
return
"
kCGScreenSaverWindowLevelKey
(
NSScreenSaverWindowLevel
)
"
;
case
kCGMaximumWindowLevelKey
:
return
"
kCGMaximumWindowLevelKey
"
;
case
kCGOverlayWindowLevelKey
:
return
"
kCGOverlayWindowLevelKey
"
;
case
kCGHelpWindowLevelKey
:
return
"
kCGHelpWindowLevelKey
"
;
case
kCGUtilityWindowLevelKey
:
return
"
kCGUtilityWindowLevelKey
"
;
case
kCGDesktopIconWindowLevelKey
:
return
"
kCGDesktopIconWindowLevelKey
"
;
case
kCGCursorWindowLevelKey
:
return
"
kCGCursorWindowLevelKey
"
;
case
kCGNumberOfWindowLevelKeys
:
return
"
kCGNumberOfWindowLevelKeys
"
;
default
:
return
"
unknown
window
level
"
;
}
}
static
bool
IsControlChar
(
uint32_t
aCharCode
)
{
return
aCharCode
<
'
'
|
|
aCharCode
=
=
0x7F
;
}
static
uint32_t
gHandlerInstanceCount
=
0
;
static
void
EnsureToLogAllKeyboardLayoutsAndIMEs
(
)
{
static
bool
sDone
=
false
;
if
(
!
sDone
)
{
sDone
=
true
;
TextInputHandler
:
:
DebugPrintAllKeyboardLayouts
(
)
;
IMEInputHandler
:
:
DebugPrintAllIMEModes
(
)
;
}
}
inline
NSRange
MakeNSRangeFrom
(
const
Maybe
<
OffsetAndData
<
uint32_t
>
>
&
aOffsetAndData
)
{
if
(
aOffsetAndData
.
isNothing
(
)
)
{
return
NSMakeRange
(
NSNotFound
0
)
;
}
return
NSMakeRange
(
aOffsetAndData
-
>
StartOffset
(
)
aOffsetAndData
-
>
Length
(
)
)
;
}
#
pragma
mark
-
TISInputSourceWrapper
*
TISInputSourceWrapper
:
:
sCurrentInputSource
=
nullptr
;
TISInputSourceWrapper
&
TISInputSourceWrapper
:
:
CurrentInputSource
(
)
{
if
(
!
sCurrentInputSource
)
{
sCurrentInputSource
=
new
TISInputSourceWrapper
(
)
;
}
if
(
!
sCurrentInputSource
-
>
IsInitializedByCurrentInputSource
(
)
)
{
sCurrentInputSource
-
>
InitByCurrentInputSource
(
)
;
}
return
*
sCurrentInputSource
;
}
void
TISInputSourceWrapper
:
:
Shutdown
(
)
{
if
(
!
sCurrentInputSource
)
{
return
;
}
sCurrentInputSource
-
>
Clear
(
)
;
delete
sCurrentInputSource
;
sCurrentInputSource
=
nullptr
;
}
bool
TISInputSourceWrapper
:
:
TranslateToString
(
UInt32
aKeyCode
UInt32
aModifiers
UInt32
aKbType
nsAString
&
aStr
)
{
aStr
.
Truncate
(
)
;
const
UCKeyboardLayout
*
UCKey
=
GetUCKeyboardLayout
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
TranslateToString
aKeyCode
=
0x
%
X
"
"
aModifiers
=
0x
%
X
aKbType
=
0x
%
X
UCKey
=
%
p
\
n
"
"
Shift
:
%
s
Ctrl
:
%
s
Opt
:
%
s
Cmd
:
%
s
CapsLock
:
%
s
NumLock
:
%
s
"
this
static_cast
<
unsigned
int
>
(
aKeyCode
)
static_cast
<
unsigned
int
>
(
aModifiers
)
static_cast
<
unsigned
int
>
(
aKbType
)
UCKey
OnOrOff
(
aModifiers
&
shiftKey
)
OnOrOff
(
aModifiers
&
controlKey
)
OnOrOff
(
aModifiers
&
optionKey
)
OnOrOff
(
aModifiers
&
cmdKey
)
OnOrOff
(
aModifiers
&
alphaLock
)
OnOrOff
(
aModifiers
&
kEventKeyModifierNumLockMask
)
)
)
;
NS_ENSURE_TRUE
(
UCKey
false
)
;
UInt32
deadKeyState
=
0
;
UniCharCount
len
;
UniChar
chars
[
5
]
;
OSStatus
err
=
:
:
UCKeyTranslate
(
UCKey
aKeyCode
kUCKeyActionDown
aModifiers
>
>
8
aKbType
kUCKeyTranslateNoDeadKeysMask
&
deadKeyState
5
&
len
chars
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
TranslateToString
err
=
0x
%
X
len
=
%
zu
"
this
static_cast
<
int
>
(
err
)
len
)
)
;
NS_ENSURE_TRUE
(
err
=
=
noErr
false
)
;
if
(
len
=
=
0
)
{
return
true
;
}
if
(
!
aStr
.
SetLength
(
len
fallible
)
)
{
return
false
;
}
NS_ASSERTION
(
sizeof
(
char16_t
)
=
=
sizeof
(
UniChar
)
"
size
of
char16_t
and
size
of
UniChar
are
different
"
)
;
memcpy
(
aStr
.
BeginWriting
(
)
chars
len
*
sizeof
(
char16_t
)
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
TranslateToString
aStr
=
\
"
%
s
\
"
"
this
NS_ConvertUTF16toUTF8
(
aStr
)
.
get
(
)
)
)
;
return
true
;
}
uint32_t
TISInputSourceWrapper
:
:
TranslateToChar
(
UInt32
aKeyCode
UInt32
aModifiers
UInt32
aKbType
)
{
nsAutoString
str
;
if
(
!
TranslateToString
(
aKeyCode
aModifiers
aKbType
str
)
|
|
str
.
Length
(
)
!
=
1
)
{
return
0
;
}
return
static_cast
<
uint32_t
>
(
str
.
CharAt
(
0
)
)
;
}
bool
TISInputSourceWrapper
:
:
IsDeadKey
(
NSEvent
*
aNativeKeyEvent
)
{
if
(
[
[
aNativeKeyEvent
characters
]
length
]
)
{
return
false
;
}
NSUInteger
cocoaState
=
[
aNativeKeyEvent
modifierFlags
]
;
if
(
cocoaState
&
(
NSControlKeyMask
|
NSCommandKeyMask
)
)
{
return
false
;
}
UInt32
nativeKeyCode
=
[
aNativeKeyEvent
keyCode
]
;
switch
(
nativeKeyCode
)
{
case
kVK_ANSI_A
:
case
kVK_ANSI_B
:
case
kVK_ANSI_C
:
case
kVK_ANSI_D
:
case
kVK_ANSI_E
:
case
kVK_ANSI_F
:
case
kVK_ANSI_G
:
case
kVK_ANSI_H
:
case
kVK_ANSI_I
:
case
kVK_ANSI_J
:
case
kVK_ANSI_K
:
case
kVK_ANSI_L
:
case
kVK_ANSI_M
:
case
kVK_ANSI_N
:
case
kVK_ANSI_O
:
case
kVK_ANSI_P
:
case
kVK_ANSI_Q
:
case
kVK_ANSI_R
:
case
kVK_ANSI_S
:
case
kVK_ANSI_T
:
case
kVK_ANSI_U
:
case
kVK_ANSI_V
:
case
kVK_ANSI_W
:
case
kVK_ANSI_X
:
case
kVK_ANSI_Y
:
case
kVK_ANSI_Z
:
case
kVK_ANSI_1
:
case
kVK_ANSI_2
:
case
kVK_ANSI_3
:
case
kVK_ANSI_4
:
case
kVK_ANSI_5
:
case
kVK_ANSI_6
:
case
kVK_ANSI_7
:
case
kVK_ANSI_8
:
case
kVK_ANSI_9
:
case
kVK_ANSI_0
:
case
kVK_ANSI_Equal
:
case
kVK_ANSI_Minus
:
case
kVK_ANSI_RightBracket
:
case
kVK_ANSI_LeftBracket
:
case
kVK_ANSI_Quote
:
case
kVK_ANSI_Semicolon
:
case
kVK_ANSI_Backslash
:
case
kVK_ANSI_Comma
:
case
kVK_ANSI_Slash
:
case
kVK_ANSI_Period
:
case
kVK_ANSI_Grave
:
case
kVK_JIS_Yen
:
case
kVK_JIS_Underscore
:
break
;
default
:
return
false
;
}
UInt32
kbType
=
GetKbdType
(
)
;
UInt32
carbonState
=
nsCocoaUtils
:
:
ConvertToCarbonModifier
(
cocoaState
)
;
return
IsDeadKey
(
nativeKeyCode
carbonState
kbType
)
;
}
bool
TISInputSourceWrapper
:
:
IsDeadKey
(
UInt32
aKeyCode
UInt32
aModifiers
UInt32
aKbType
)
{
const
UCKeyboardLayout
*
UCKey
=
GetUCKeyboardLayout
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
IsDeadKey
aKeyCode
=
0x
%
X
"
"
aModifiers
=
0x
%
X
aKbType
=
0x
%
X
UCKey
=
%
p
\
n
"
"
Shift
:
%
s
Ctrl
:
%
s
Opt
:
%
s
Cmd
:
%
s
CapsLock
:
%
s
NumLock
:
%
s
"
this
static_cast
<
unsigned
int
>
(
aKeyCode
)
static_cast
<
unsigned
int
>
(
aModifiers
)
static_cast
<
unsigned
int
>
(
aKbType
)
UCKey
OnOrOff
(
aModifiers
&
shiftKey
)
OnOrOff
(
aModifiers
&
controlKey
)
OnOrOff
(
aModifiers
&
optionKey
)
OnOrOff
(
aModifiers
&
cmdKey
)
OnOrOff
(
aModifiers
&
alphaLock
)
OnOrOff
(
aModifiers
&
kEventKeyModifierNumLockMask
)
)
)
;
if
(
NS_WARN_IF
(
!
UCKey
)
)
{
return
false
;
}
UInt32
deadKeyState
=
0
;
UniCharCount
len
;
UniChar
chars
[
5
]
;
OSStatus
err
=
:
:
UCKeyTranslate
(
UCKey
aKeyCode
kUCKeyActionDown
aModifiers
>
>
8
aKbType
0
&
deadKeyState
5
&
len
chars
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
IsDeadKey
err
=
0x
%
X
"
"
len
=
%
zu
deadKeyState
=
%
u
"
this
static_cast
<
int
>
(
err
)
len
deadKeyState
)
)
;
if
(
NS_WARN_IF
(
err
!
=
noErr
)
)
{
return
false
;
}
return
deadKeyState
!
=
0
;
}
void
TISInputSourceWrapper
:
:
InitByInputSourceID
(
const
char
*
aID
)
{
Clear
(
)
;
if
(
!
aID
)
return
;
CFStringRef
idstr
=
:
:
CFStringCreateWithCString
(
kCFAllocatorDefault
aID
kCFStringEncodingASCII
)
;
InitByInputSourceID
(
idstr
)
;
:
:
CFRelease
(
idstr
)
;
}
void
TISInputSourceWrapper
:
:
InitByInputSourceID
(
const
nsString
&
aID
)
{
Clear
(
)
;
if
(
aID
.
IsEmpty
(
)
)
return
;
CFStringRef
idstr
=
:
:
CFStringCreateWithCharacters
(
kCFAllocatorDefault
reinterpret_cast
<
const
UniChar
*
>
(
aID
.
get
(
)
)
aID
.
Length
(
)
)
;
InitByInputSourceID
(
idstr
)
;
:
:
CFRelease
(
idstr
)
;
}
void
TISInputSourceWrapper
:
:
InitByInputSourceID
(
const
CFStringRef
aID
)
{
Clear
(
)
;
if
(
!
aID
)
return
;
const
void
*
keys
[
]
=
{
kTISPropertyInputSourceID
}
;
const
void
*
values
[
]
=
{
aID
}
;
CFDictionaryRef
filter
=
:
:
CFDictionaryCreate
(
kCFAllocatorDefault
keys
values
1
NULL
NULL
)
;
NS_ASSERTION
(
filter
"
failed
to
create
the
filter
"
)
;
mInputSourceList
=
:
:
TISCreateInputSourceList
(
filter
true
)
;
:
:
CFRelease
(
filter
)
;
if
(
:
:
CFArrayGetCount
(
mInputSourceList
)
>
0
)
{
mInputSource
=
static_cast
<
TISInputSourceRef
>
(
const_cast
<
void
*
>
(
:
:
CFArrayGetValueAtIndex
(
mInputSourceList
0
)
)
)
;
if
(
IsKeyboardLayout
(
)
)
{
mKeyboardLayout
=
mInputSource
;
}
}
}
void
TISInputSourceWrapper
:
:
InitByLayoutID
(
SInt32
aLayoutID
bool
aOverrideKeyboard
)
{
switch
(
aLayoutID
)
{
case
0
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
US
"
)
;
break
;
case
1
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Greek
"
)
;
break
;
case
2
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
German
"
)
;
break
;
case
3
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Swedish
-
Pro
"
)
;
break
;
case
4
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
DVORAK
-
QWERTYCMD
"
)
;
break
;
case
5
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Thai
"
)
;
break
;
case
6
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Arabic
"
)
;
break
;
case
7
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
ArabicPC
"
)
;
break
;
case
8
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
French
"
)
;
break
;
case
9
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Hebrew
"
)
;
break
;
case
10
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Lithuanian
"
)
;
break
;
case
11
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Norwegian
"
)
;
break
;
case
12
:
InitByInputSourceID
(
"
com
.
apple
.
keylayout
.
Spanish
"
)
;
break
;
default
:
Clear
(
)
;
break
;
}
mOverrideKeyboard
=
aOverrideKeyboard
;
}
void
TISInputSourceWrapper
:
:
InitByCurrentInputSource
(
)
{
Clear
(
)
;
mInputSource
=
:
:
TISCopyCurrentKeyboardInputSource
(
)
;
mKeyboardLayout
=
:
:
TISCopyInputMethodKeyboardLayoutOverride
(
)
;
if
(
!
mKeyboardLayout
)
{
mKeyboardLayout
=
:
:
TISCopyCurrentKeyboardLayoutInputSource
(
)
;
}
if
(
IsOpenedIMEMode
(
)
)
{
TISInputSourceWrapper
tis
(
mKeyboardLayout
)
;
if
(
!
tis
.
IsASCIICapable
(
)
)
{
mKeyboardLayout
=
:
:
TISCopyCurrentASCIICapableKeyboardLayoutInputSource
(
)
;
}
}
}
void
TISInputSourceWrapper
:
:
InitByCurrentKeyboardLayout
(
)
{
Clear
(
)
;
mInputSource
=
:
:
TISCopyCurrentKeyboardLayoutInputSource
(
)
;
mKeyboardLayout
=
mInputSource
;
}
void
TISInputSourceWrapper
:
:
InitByCurrentASCIICapableInputSource
(
)
{
Clear
(
)
;
mInputSource
=
:
:
TISCopyCurrentASCIICapableKeyboardInputSource
(
)
;
mKeyboardLayout
=
:
:
TISCopyInputMethodKeyboardLayoutOverride
(
)
;
if
(
mKeyboardLayout
)
{
TISInputSourceWrapper
tis
(
mKeyboardLayout
)
;
if
(
!
tis
.
IsASCIICapable
(
)
)
{
mKeyboardLayout
=
nullptr
;
}
}
if
(
!
mKeyboardLayout
)
{
mKeyboardLayout
=
:
:
TISCopyCurrentASCIICapableKeyboardLayoutInputSource
(
)
;
}
}
void
TISInputSourceWrapper
:
:
InitByCurrentASCIICapableKeyboardLayout
(
)
{
Clear
(
)
;
mInputSource
=
:
:
TISCopyCurrentASCIICapableKeyboardLayoutInputSource
(
)
;
mKeyboardLayout
=
mInputSource
;
}
void
TISInputSourceWrapper
:
:
InitByCurrentInputMethodKeyboardLayoutOverride
(
)
{
Clear
(
)
;
mInputSource
=
:
:
TISCopyInputMethodKeyboardLayoutOverride
(
)
;
mKeyboardLayout
=
mInputSource
;
}
void
TISInputSourceWrapper
:
:
InitByTISInputSourceRef
(
TISInputSourceRef
aInputSource
)
{
Clear
(
)
;
mInputSource
=
aInputSource
;
if
(
IsKeyboardLayout
(
)
)
{
mKeyboardLayout
=
mInputSource
;
}
}
void
TISInputSourceWrapper
:
:
InitByLanguage
(
CFStringRef
aLanguage
)
{
Clear
(
)
;
mInputSource
=
:
:
TISCopyInputSourceForLanguage
(
aLanguage
)
;
if
(
IsKeyboardLayout
(
)
)
{
mKeyboardLayout
=
mInputSource
;
}
}
const
UCKeyboardLayout
*
TISInputSourceWrapper
:
:
GetUCKeyboardLayout
(
)
{
NS_ENSURE_TRUE
(
mKeyboardLayout
nullptr
)
;
if
(
mUCKeyboardLayout
)
{
return
mUCKeyboardLayout
;
}
CFDataRef
uchr
=
static_cast
<
CFDataRef
>
(
:
:
TISGetInputSourceProperty
(
mKeyboardLayout
kTISPropertyUnicodeKeyLayoutData
)
)
;
NS_ENSURE_TRUE
(
uchr
nullptr
)
;
mUCKeyboardLayout
=
reinterpret_cast
<
const
UCKeyboardLayout
*
>
(
CFDataGetBytePtr
(
uchr
)
)
;
return
mUCKeyboardLayout
;
}
bool
TISInputSourceWrapper
:
:
GetBoolProperty
(
const
CFStringRef
aKey
)
{
CFBooleanRef
ret
=
static_cast
<
CFBooleanRef
>
(
:
:
TISGetInputSourceProperty
(
mInputSource
aKey
)
)
;
return
:
:
CFBooleanGetValue
(
ret
)
;
}
bool
TISInputSourceWrapper
:
:
GetStringProperty
(
const
CFStringRef
aKey
CFStringRef
&
aStr
)
{
aStr
=
static_cast
<
CFStringRef
>
(
:
:
TISGetInputSourceProperty
(
mInputSource
aKey
)
)
;
return
aStr
!
=
nullptr
;
}
bool
TISInputSourceWrapper
:
:
GetStringProperty
(
const
CFStringRef
aKey
nsAString
&
aStr
)
{
CFStringRef
str
;
GetStringProperty
(
aKey
str
)
;
nsCocoaUtils
:
:
GetStringForNSString
(
(
const
NSString
*
)
str
aStr
)
;
return
!
aStr
.
IsEmpty
(
)
;
}
bool
TISInputSourceWrapper
:
:
IsOpenedIMEMode
(
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
if
(
!
IsIMEMode
(
)
)
return
false
;
return
!
IsASCIICapable
(
)
;
}
bool
TISInputSourceWrapper
:
:
IsIMEMode
(
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
CFStringRef
str
;
GetInputSourceType
(
str
)
;
NS_ENSURE_TRUE
(
str
false
)
;
return
:
:
CFStringCompare
(
kTISTypeKeyboardInputMode
str
0
)
=
=
kCFCompareEqualTo
;
}
bool
TISInputSourceWrapper
:
:
IsKeyboardLayout
(
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
CFStringRef
str
;
GetInputSourceType
(
str
)
;
NS_ENSURE_TRUE
(
str
false
)
;
return
:
:
CFStringCompare
(
kTISTypeKeyboardLayout
str
0
)
=
=
kCFCompareEqualTo
;
}
bool
TISInputSourceWrapper
:
:
GetLanguageList
(
CFArrayRef
&
aLanguageList
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
aLanguageList
=
static_cast
<
CFArrayRef
>
(
:
:
TISGetInputSourceProperty
(
mInputSource
kTISPropertyInputSourceLanguages
)
)
;
return
aLanguageList
!
=
nullptr
;
}
bool
TISInputSourceWrapper
:
:
GetPrimaryLanguage
(
CFStringRef
&
aPrimaryLanguage
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
CFArrayRef
langList
;
NS_ENSURE_TRUE
(
GetLanguageList
(
langList
)
false
)
;
if
(
:
:
CFArrayGetCount
(
langList
)
=
=
0
)
return
false
;
aPrimaryLanguage
=
static_cast
<
CFStringRef
>
(
:
:
CFArrayGetValueAtIndex
(
langList
0
)
)
;
return
aPrimaryLanguage
!
=
nullptr
;
}
bool
TISInputSourceWrapper
:
:
GetPrimaryLanguage
(
nsAString
&
aPrimaryLanguage
)
{
NS_ENSURE_TRUE
(
mInputSource
false
)
;
CFStringRef
primaryLanguage
;
NS_ENSURE_TRUE
(
GetPrimaryLanguage
(
primaryLanguage
)
false
)
;
nsCocoaUtils
:
:
GetStringForNSString
(
(
const
NSString
*
)
primaryLanguage
aPrimaryLanguage
)
;
return
!
aPrimaryLanguage
.
IsEmpty
(
)
;
}
bool
TISInputSourceWrapper
:
:
IsForRTLLanguage
(
)
{
if
(
mIsRTL
<
0
)
{
nsAutoString
str
;
bool
ret
=
TranslateToString
(
kVK_ANSI_A
0
eKbdType_ANSI
str
)
;
NS_ENSURE_TRUE
(
ret
ret
)
;
char16_t
ch
=
str
.
IsEmpty
(
)
?
char16_t
(
0
)
:
str
.
CharAt
(
0
)
;
mIsRTL
=
UTF16_CODE_UNIT_IS_BIDI
(
ch
)
;
}
return
mIsRTL
!
=
0
;
}
bool
TISInputSourceWrapper
:
:
IsForJapaneseLanguage
(
)
{
nsAutoString
lang
;
GetPrimaryLanguage
(
lang
)
;
return
lang
.
EqualsLiteral
(
"
ja
"
)
;
}
bool
TISInputSourceWrapper
:
:
IsInitializedByCurrentInputSource
(
)
{
return
mInputSource
=
=
:
:
TISCopyCurrentKeyboardInputSource
(
)
;
}
void
TISInputSourceWrapper
:
:
Select
(
)
{
if
(
!
mInputSource
)
return
;
:
:
TISSelectInputSource
(
mInputSource
)
;
}
void
TISInputSourceWrapper
:
:
Clear
(
)
{
EnsureToLogAllKeyboardLayoutsAndIMEs
(
)
;
if
(
mInputSourceList
)
{
:
:
CFRelease
(
mInputSourceList
)
;
}
mInputSourceList
=
nullptr
;
mInputSource
=
nullptr
;
mKeyboardLayout
=
nullptr
;
mIsRTL
=
-
1
;
mUCKeyboardLayout
=
nullptr
;
mOverrideKeyboard
=
false
;
}
bool
TISInputSourceWrapper
:
:
IsPrintableKeyEvent
(
NSEvent
*
aNativeKeyEvent
)
const
{
UInt32
nativeKeyCode
=
[
aNativeKeyEvent
keyCode
]
;
bool
isPrintableKey
=
!
TextInputHandler
:
:
IsSpecialGeckoKey
(
nativeKeyCode
)
;
if
(
isPrintableKey
&
&
[
aNativeKeyEvent
type
]
!
=
NSKeyDown
&
&
[
aNativeKeyEvent
type
]
!
=
NSKeyUp
)
{
NS_WARNING
(
"
Why
the
printable
key
doesn
'
t
cause
NSKeyDown
or
NSKeyUp
?
"
)
;
isPrintableKey
=
false
;
}
return
isPrintableKey
;
}
UInt32
TISInputSourceWrapper
:
:
GetKbdType
(
)
const
{
return
mOverrideKeyboard
?
eKbdType_ANSI
:
:
:
LMGetKbdType
(
)
;
}
void
TISInputSourceWrapper
:
:
ComputeInsertStringForCharCode
(
NSEvent
*
aNativeKeyEvent
const
WidgetKeyboardEvent
&
aKeyEvent
const
nsAString
*
aInsertString
nsAString
&
aResult
)
{
if
(
aInsertString
)
{
aResult
=
*
aInsertString
;
}
else
if
(
IsPrintableKeyEvent
(
aNativeKeyEvent
)
)
{
UInt32
nativeKeyCode
=
[
aNativeKeyEvent
keyCode
]
;
if
(
(
!
aKeyEvent
.
IsMeta
(
)
&
&
!
aKeyEvent
.
IsControl
(
)
&
&
IsOpenedIMEMode
(
)
)
|
|
!
[
[
aNativeKeyEvent
characters
]
length
]
)
{
UInt32
state
=
nsCocoaUtils
:
:
ConvertToCarbonModifier
(
[
aNativeKeyEvent
modifierFlags
]
)
;
uint32_t
ch
=
TranslateToChar
(
nativeKeyCode
state
GetKbdType
(
)
)
;
if
(
ch
)
{
aResult
=
ch
;
}
}
else
{
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
characters
]
aResult
)
;
}
if
(
aKeyEvent
.
IsControl
(
)
&
&
!
aResult
.
IsEmpty
(
)
&
&
aResult
[
0
]
<
=
char16_t
(
26
)
)
{
aResult
=
(
aKeyEvent
.
IsShift
(
)
^
aKeyEvent
.
IsCapsLocked
(
)
)
?
static_cast
<
char16_t
>
(
aResult
[
0
]
+
(
'
A
'
-
1
)
)
:
static_cast
<
char16_t
>
(
aResult
[
0
]
+
(
'
a
'
-
1
)
)
;
}
else
if
(
aKeyEvent
.
IsMeta
(
)
&
&
!
(
aKeyEvent
.
IsControl
(
)
|
|
aKeyEvent
.
IsAlt
(
)
)
)
{
UInt32
kbType
=
GetKbdType
(
)
;
UInt32
numLockState
=
aKeyEvent
.
IsNumLocked
(
)
?
kEventKeyModifierNumLockMask
:
0
;
UInt32
capsLockState
=
aKeyEvent
.
IsCapsLocked
(
)
?
alphaLock
:
0
;
UInt32
shiftState
=
aKeyEvent
.
IsShift
(
)
?
shiftKey
:
0
;
uint32_t
uncmdedChar
=
TranslateToChar
(
nativeKeyCode
numLockState
kbType
)
;
uint32_t
cmdedChar
=
TranslateToChar
(
nativeKeyCode
cmdKey
|
numLockState
kbType
)
;
uint32_t
ch
=
0
;
if
(
uncmdedChar
=
=
cmdedChar
)
{
ch
=
TranslateToChar
(
nativeKeyCode
shiftState
|
capsLockState
|
numLockState
kbType
)
;
}
else
{
TISInputSourceWrapper
USLayout
(
"
com
.
apple
.
keylayout
.
US
"
)
;
uint32_t
uncmdedUSChar
=
USLayout
.
TranslateToChar
(
nativeKeyCode
numLockState
kbType
)
;
if
(
uncmdedUSChar
=
=
cmdedChar
)
{
ch
=
USLayout
.
TranslateToChar
(
nativeKeyCode
shiftState
|
capsLockState
|
numLockState
kbType
)
;
}
}
if
(
ch
)
{
aResult
=
ch
;
}
}
}
if
(
!
aResult
.
IsEmpty
(
)
&
&
IsControlChar
(
aResult
[
0
]
)
)
{
aResult
.
Truncate
(
)
;
}
}
void
TISInputSourceWrapper
:
:
InitKeyEvent
(
NSEvent
*
aNativeKeyEvent
WidgetKeyboardEvent
&
aKeyEvent
bool
aIsProcessedByIME
const
nsAString
*
aInsertString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_ASSERT
(
!
aIsProcessedByIME
|
|
aKeyEvent
.
mMessage
!
=
eKeyPress
"
eKeyPress
event
should
not
be
marked
as
proccessed
by
IME
"
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
InitKeyEvent
aNativeKeyEvent
=
%
p
"
"
aKeyEvent
.
mMessage
=
%
s
aProcessedByIME
=
%
s
aInsertString
=
%
p
"
"
IsOpenedIMEMode
(
)
=
%
s
"
this
aNativeKeyEvent
GetGeckoKeyEventType
(
aKeyEvent
)
TrueOrFalse
(
aIsProcessedByIME
)
aInsertString
TrueOrFalse
(
IsOpenedIMEMode
(
)
)
)
)
;
if
(
NS_WARN_IF
(
!
aNativeKeyEvent
)
)
{
return
;
}
nsCocoaUtils
:
:
InitInputEvent
(
aKeyEvent
aNativeKeyEvent
)
;
aKeyEvent
.
mNativeKeyEvent
=
aNativeKeyEvent
;
if
(
[
aNativeKeyEvent
type
]
=
=
NSKeyDown
|
|
[
aNativeKeyEvent
type
]
=
=
NSKeyUp
)
{
aKeyEvent
.
mNativeKeyCode
=
[
aNativeKeyEvent
keyCode
]
;
aKeyEvent
.
mNativeModifierFlags
=
[
aNativeKeyEvent
modifierFlags
]
;
nsAutoString
nativeChars
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
characters
]
nativeChars
)
;
aKeyEvent
.
mNativeCharacters
.
Assign
(
nativeChars
)
;
nsAutoString
nativeCharsIgnoringModifiers
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
charactersIgnoringModifiers
]
nativeCharsIgnoringModifiers
)
;
aKeyEvent
.
mNativeCharactersIgnoringModifiers
.
Assign
(
nativeCharsIgnoringModifiers
)
;
}
else
if
(
[
aNativeKeyEvent
type
]
=
=
NSFlagsChanged
)
{
aKeyEvent
.
mNativeKeyCode
=
[
aNativeKeyEvent
keyCode
]
;
aKeyEvent
.
mNativeModifierFlags
=
[
aNativeKeyEvent
modifierFlags
]
;
}
aKeyEvent
.
mRefPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
UInt32
kbType
=
GetKbdType
(
)
;
UInt32
nativeKeyCode
=
[
aNativeKeyEvent
keyCode
]
;
bool
isProcessedByIME
=
aIsProcessedByIME
&
&
!
TISInputSourceWrapper
:
:
CurrentInputSource
(
)
.
IsDeadKey
(
aNativeKeyEvent
)
;
aKeyEvent
.
mKeyCode
=
isProcessedByIME
?
NS_VK_PROCESSKEY
:
ComputeGeckoKeyCode
(
nativeKeyCode
kbType
aKeyEvent
.
IsMeta
(
)
)
;
switch
(
nativeKeyCode
)
{
case
kVK_Command
:
case
kVK_Shift
:
case
kVK_Option
:
case
kVK_Control
:
aKeyEvent
.
mLocation
=
eKeyLocationLeft
;
break
;
case
kVK_RightCommand
:
case
kVK_RightShift
:
case
kVK_RightOption
:
case
kVK_RightControl
:
aKeyEvent
.
mLocation
=
eKeyLocationRight
;
break
;
case
kVK_ANSI_Keypad0
:
case
kVK_ANSI_Keypad1
:
case
kVK_ANSI_Keypad2
:
case
kVK_ANSI_Keypad3
:
case
kVK_ANSI_Keypad4
:
case
kVK_ANSI_Keypad5
:
case
kVK_ANSI_Keypad6
:
case
kVK_ANSI_Keypad7
:
case
kVK_ANSI_Keypad8
:
case
kVK_ANSI_Keypad9
:
case
kVK_ANSI_KeypadMultiply
:
case
kVK_ANSI_KeypadPlus
:
case
kVK_ANSI_KeypadMinus
:
case
kVK_ANSI_KeypadDecimal
:
case
kVK_ANSI_KeypadDivide
:
case
kVK_ANSI_KeypadEquals
:
case
kVK_ANSI_KeypadEnter
:
case
kVK_JIS_KeypadComma
:
case
kVK_Powerbook_KeypadEnter
:
aKeyEvent
.
mLocation
=
eKeyLocationNumpad
;
break
;
default
:
aKeyEvent
.
mLocation
=
eKeyLocationStandard
;
break
;
}
aKeyEvent
.
mIsRepeat
=
(
[
aNativeKeyEvent
type
]
=
=
NSKeyDown
)
?
[
aNativeKeyEvent
isARepeat
]
:
false
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
InitKeyEvent
"
"
shift
=
%
s
ctrl
=
%
s
alt
=
%
s
meta
=
%
s
"
this
OnOrOff
(
aKeyEvent
.
IsShift
(
)
)
OnOrOff
(
aKeyEvent
.
IsControl
(
)
)
OnOrOff
(
aKeyEvent
.
IsAlt
(
)
)
OnOrOff
(
aKeyEvent
.
IsMeta
(
)
)
)
)
;
if
(
isProcessedByIME
)
{
aKeyEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Process
;
}
else
if
(
IsPrintableKeyEvent
(
aNativeKeyEvent
)
)
{
aKeyEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_USE_STRING
;
if
(
aInsertString
&
&
!
aInsertString
-
>
IsEmpty
(
)
&
&
!
IsControlChar
(
(
*
aInsertString
)
[
0
]
)
)
{
aKeyEvent
.
mKeyValue
=
*
aInsertString
;
}
else
if
(
aKeyEvent
.
IsMeta
(
)
)
{
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
characters
]
aKeyEvent
.
mKeyValue
)
;
}
else
if
(
aKeyEvent
.
IsControl
(
)
)
{
NSUInteger
cocoaState
=
[
aNativeKeyEvent
modifierFlags
]
&
~
NSControlKeyMask
;
UInt32
carbonState
=
nsCocoaUtils
:
:
ConvertToCarbonModifier
(
cocoaState
)
;
if
(
IsDeadKey
(
nativeKeyCode
carbonState
kbType
)
)
{
aKeyEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Dead
;
}
else
{
aKeyEvent
.
mKeyValue
=
TranslateToChar
(
nativeKeyCode
carbonState
kbType
)
;
if
(
!
aKeyEvent
.
mKeyValue
.
IsEmpty
(
)
&
&
IsControlChar
(
aKeyEvent
.
mKeyValue
[
0
]
)
)
{
aKeyEvent
.
mKeyValue
.
Truncate
(
)
;
}
}
}
else
if
(
IsOpenedIMEMode
(
)
)
{
UInt32
state
=
nsCocoaUtils
:
:
ConvertToCarbonModifier
(
[
aNativeKeyEvent
modifierFlags
]
)
;
aKeyEvent
.
mKeyValue
=
TranslateToChar
(
nativeKeyCode
state
kbType
)
;
}
else
{
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
characters
]
aKeyEvent
.
mKeyValue
)
;
if
(
aKeyEvent
.
mKeyValue
.
IsEmpty
(
)
)
{
NSUInteger
cocoaState
=
[
aNativeKeyEvent
modifierFlags
]
;
UInt32
carbonState
=
nsCocoaUtils
:
:
ConvertToCarbonModifier
(
cocoaState
)
;
if
(
TranslateToChar
(
nativeKeyCode
carbonState
kbType
)
)
{
aKeyEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Dead
;
}
}
}
if
(
aKeyEvent
.
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
&
&
(
aKeyEvent
.
mKeyValue
.
IsEmpty
(
)
|
|
IsControlChar
(
aKeyEvent
.
mKeyValue
[
0
]
)
)
)
{
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
charactersIgnoringModifiers
]
aKeyEvent
.
mKeyValue
)
;
if
(
!
aKeyEvent
.
mKeyValue
.
IsEmpty
(
)
&
&
IsControlChar
(
aKeyEvent
.
mKeyValue
[
0
]
)
)
{
aKeyEvent
.
mKeyValue
.
Truncate
(
)
;
}
}
}
else
{
aKeyEvent
.
mKeyNameIndex
=
ComputeGeckoKeyNameIndex
(
nativeKeyCode
)
;
}
aKeyEvent
.
mCodeNameIndex
=
ComputeGeckoCodeNameIndex
(
nativeKeyCode
kbType
)
;
MOZ_ASSERT
(
aKeyEvent
.
mCodeNameIndex
!
=
CODE_NAME_INDEX_USE_STRING
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
}
void
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
(
NSEvent
*
aNativeKeyEvent
const
nsAString
*
aInsertString
uint32_t
aIndexOfKeypress
WidgetKeyboardEvent
&
aKeyEvent
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
[
aNativeKeyEvent
type
]
!
=
NSKeyDown
&
&
[
aNativeKeyEvent
type
]
!
=
NSKeyUp
)
{
return
;
}
UInt32
kbType
=
GetKbdType
(
)
;
if
(
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Info
)
)
{
nsAutoString
chars
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
aNativeKeyEvent
characters
]
chars
)
;
NS_ConvertUTF16toUTF8
utf8Chars
(
chars
)
;
char16_t
uniChar
=
static_cast
<
char16_t
>
(
aKeyEvent
.
mCharCode
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
"
"
aNativeKeyEvent
=
%
p
aInsertString
=
%
p
(
\
"
%
s
\
"
)
"
"
aIndexOfKeypress
=
%
u
[
aNativeKeyEvent
characters
]
=
\
"
%
s
\
"
"
"
aKeyEvent
=
{
mMessage
=
%
s
mCharCode
=
0x
%
X
(
%
s
)
}
kbType
=
0x
%
X
"
"
IsOpenedIMEMode
(
)
=
%
s
"
this
aNativeKeyEvent
aInsertString
aInsertString
?
GetCharacters
(
*
aInsertString
)
:
"
"
aIndexOfKeypress
GetCharacters
(
[
aNativeKeyEvent
characters
]
)
GetGeckoKeyEventType
(
aKeyEvent
)
aKeyEvent
.
mCharCode
uniChar
?
NS_ConvertUTF16toUTF8
(
&
uniChar
1
)
.
get
(
)
:
"
"
static_cast
<
unsigned
int
>
(
kbType
)
TrueOrFalse
(
IsOpenedIMEMode
(
)
)
)
)
;
}
nsAutoString
insertStringForCharCode
;
ComputeInsertStringForCharCode
(
aNativeKeyEvent
aKeyEvent
aInsertString
insertStringForCharCode
)
;
uint32_t
charCode
=
0
;
if
(
aIndexOfKeypress
<
insertStringForCharCode
.
Length
(
)
)
{
charCode
=
insertStringForCharCode
[
aIndexOfKeypress
]
;
}
aKeyEvent
.
SetCharCode
(
charCode
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
"
"
aKeyEvent
.
mKeyCode
=
0x
%
X
aKeyEvent
.
mCharCode
=
0x
%
X
"
this
aKeyEvent
.
mKeyCode
aKeyEvent
.
mCharCode
)
)
;
if
(
aInsertString
&
&
charCode
)
{
return
;
}
TISInputSourceWrapper
USLayout
(
"
com
.
apple
.
keylayout
.
US
"
)
;
bool
isRomanKeyboardLayout
=
IsASCIICapable
(
)
;
UInt32
key
=
[
aNativeKeyEvent
keyCode
]
;
UInt32
lockState
=
0
;
if
(
[
aNativeKeyEvent
modifierFlags
]
&
NSAlphaShiftKeyMask
)
{
lockState
|
=
alphaLock
;
}
if
(
[
aNativeKeyEvent
modifierFlags
]
&
NSNumericPadKeyMask
)
{
lockState
|
=
kEventKeyModifierNumLockMask
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
"
"
isRomanKeyboardLayout
=
%
s
kbType
=
0x
%
X
key
=
0x
%
X
"
this
TrueOrFalse
(
isRomanKeyboardLayout
)
static_cast
<
unsigned
int
>
(
kbType
)
static_cast
<
unsigned
int
>
(
key
)
)
)
;
nsString
str
;
uint32_t
unshiftedChar
=
TranslateToChar
(
key
lockState
kbType
)
;
UInt32
shiftLockMod
=
shiftKey
|
lockState
;
uint32_t
shiftedChar
=
TranslateToChar
(
key
shiftLockMod
kbType
)
;
UInt32
numState
=
(
lockState
&
~
alphaLock
)
;
uint32_t
uncmdedChar
=
TranslateToChar
(
key
numState
kbType
)
;
UInt32
shiftNumMod
=
numState
|
shiftKey
;
uint32_t
uncmdedShiftChar
=
TranslateToChar
(
key
shiftNumMod
kbType
)
;
uint32_t
uncmdedUSChar
=
USLayout
.
TranslateToChar
(
key
numState
kbType
)
;
UInt32
cmdNumMod
=
cmdKey
|
numState
;
uint32_t
cmdedChar
=
TranslateToChar
(
key
cmdNumMod
kbType
)
;
UInt32
cmdShiftNumMod
=
shiftKey
|
cmdNumMod
;
uint32_t
cmdedShiftChar
=
TranslateToChar
(
key
cmdShiftNumMod
kbType
)
;
bool
isCmdSwitchLayout
=
uncmdedChar
!
=
cmdedChar
;
bool
isDvorakQWERTY
=
isCmdSwitchLayout
&
&
isRomanKeyboardLayout
;
if
(
(
unshiftedChar
|
|
shiftedChar
)
&
&
(
!
aKeyEvent
.
IsMeta
(
)
|
|
!
isDvorakQWERTY
)
)
{
AlternativeCharCode
altCharCodes
(
unshiftedChar
shiftedChar
)
;
aKeyEvent
.
mAlternativeCharCodes
.
AppendElement
(
altCharCodes
)
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
"
"
aKeyEvent
.
isMeta
=
%
s
isDvorakQWERTY
=
%
s
"
"
unshiftedChar
=
U
+
%
X
shiftedChar
=
U
+
%
X
"
this
OnOrOff
(
aKeyEvent
.
IsMeta
(
)
)
TrueOrFalse
(
isDvorakQWERTY
)
unshiftedChar
shiftedChar
)
)
;
bool
hasCmdShiftOnlyChar
=
cmdedChar
!
=
cmdedShiftChar
&
&
uncmdedShiftChar
!
=
cmdedShiftChar
;
uint32_t
originalCmdedShiftChar
=
cmdedShiftChar
;
if
(
!
isCmdSwitchLayout
)
{
if
(
unshiftedChar
)
{
cmdedChar
=
unshiftedChar
;
}
if
(
shiftedChar
)
{
cmdedShiftChar
=
shiftedChar
;
}
}
else
if
(
uncmdedUSChar
=
=
cmdedChar
)
{
uint32_t
ch
=
USLayout
.
TranslateToChar
(
key
lockState
kbType
)
;
if
(
ch
)
{
cmdedChar
=
ch
;
}
ch
=
USLayout
.
TranslateToChar
(
key
shiftLockMod
kbType
)
;
if
(
ch
)
{
cmdedShiftChar
=
ch
;
}
}
if
(
(
cmdedChar
|
|
cmdedShiftChar
)
&
&
isCmdSwitchLayout
&
&
(
aKeyEvent
.
IsMeta
(
)
|
|
!
isDvorakQWERTY
)
)
{
AlternativeCharCode
altCharCodes
(
cmdedChar
cmdedShiftChar
)
;
aKeyEvent
.
mAlternativeCharCodes
.
AppendElement
(
altCharCodes
)
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
"
"
hasCmdShiftOnlyChar
=
%
s
isCmdSwitchLayout
=
%
s
isDvorakQWERTY
=
%
s
"
"
cmdedChar
=
U
+
%
X
cmdedShiftChar
=
U
+
%
X
"
this
TrueOrFalse
(
hasCmdShiftOnlyChar
)
TrueOrFalse
(
isDvorakQWERTY
)
TrueOrFalse
(
isDvorakQWERTY
)
cmdedChar
cmdedShiftChar
)
)
;
if
(
hasCmdShiftOnlyChar
&
&
originalCmdedShiftChar
)
{
AlternativeCharCode
altCharCodes
(
0
originalCmdedShiftChar
)
;
aKeyEvent
.
mAlternativeCharCodes
.
AppendElement
(
altCharCodes
)
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
WillDispatchKeyboardEvent
"
"
hasCmdShiftOnlyChar
=
%
s
originalCmdedShiftChar
=
U
+
%
X
"
this
TrueOrFalse
(
hasCmdShiftOnlyChar
)
originalCmdedShiftChar
)
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
}
uint32_t
TISInputSourceWrapper
:
:
ComputeGeckoKeyCode
(
UInt32
aNativeKeyCode
UInt32
aKbType
bool
aCmdIsPressed
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TISInputSourceWrapper
:
:
ComputeGeckoKeyCode
aNativeKeyCode
=
0x
%
X
"
"
aKbType
=
0x
%
X
aCmdIsPressed
=
%
s
IsOpenedIMEMode
(
)
=
%
s
"
"
IsASCIICapable
(
)
=
%
s
"
this
static_cast
<
unsigned
int
>
(
aNativeKeyCode
)
static_cast
<
unsigned
int
>
(
aKbType
)
TrueOrFalse
(
aCmdIsPressed
)
TrueOrFalse
(
IsOpenedIMEMode
(
)
)
TrueOrFalse
(
IsASCIICapable
(
)
)
)
)
;
switch
(
aNativeKeyCode
)
{
case
kVK_Space
:
return
NS_VK_SPACE
;
case
kVK_Escape
:
return
NS_VK_ESCAPE
;
case
kVK_RightCommand
:
case
kVK_Command
:
return
NS_VK_META
;
case
kVK_RightShift
:
case
kVK_Shift
:
return
NS_VK_SHIFT
;
case
kVK_CapsLock
:
return
NS_VK_CAPS_LOCK
;
case
kVK_RightControl
:
case
kVK_Control
:
return
NS_VK_CONTROL
;
case
kVK_RightOption
:
case
kVK_Option
:
return
NS_VK_ALT
;
case
kVK_ANSI_KeypadClear
:
return
NS_VK_CLEAR
;
case
kVK_F1
:
return
NS_VK_F1
;
case
kVK_F2
:
return
NS_VK_F2
;
case
kVK_F3
:
return
NS_VK_F3
;
case
kVK_F4
:
return
NS_VK_F4
;
case
kVK_F5
:
return
NS_VK_F5
;
case
kVK_F6
:
return
NS_VK_F6
;
case
kVK_F7
:
return
NS_VK_F7
;
case
kVK_F8
:
return
NS_VK_F8
;
case
kVK_F9
:
return
NS_VK_F9
;
case
kVK_F10
:
return
NS_VK_F10
;
case
kVK_F11
:
return
NS_VK_F11
;
case
kVK_F12
:
return
NS_VK_F12
;
case
kVK_F16
:
return
NS_VK_F16
;
case
kVK_F17
:
return
NS_VK_F17
;
case
kVK_F18
:
return
NS_VK_F18
;
case
kVK_F19
:
return
NS_VK_F19
;
case
kVK_PC_Pause
:
return
NS_VK_PAUSE
;
case
kVK_PC_ScrollLock
:
return
NS_VK_SCROLL_LOCK
;
case
kVK_PC_PrintScreen
:
return
NS_VK_PRINTSCREEN
;
case
kVK_ANSI_Keypad0
:
return
NS_VK_NUMPAD0
;
case
kVK_ANSI_Keypad1
:
return
NS_VK_NUMPAD1
;
case
kVK_ANSI_Keypad2
:
return
NS_VK_NUMPAD2
;
case
kVK_ANSI_Keypad3
:
return
NS_VK_NUMPAD3
;
case
kVK_ANSI_Keypad4
:
return
NS_VK_NUMPAD4
;
case
kVK_ANSI_Keypad5
:
return
NS_VK_NUMPAD5
;
case
kVK_ANSI_Keypad6
:
return
NS_VK_NUMPAD6
;
case
kVK_ANSI_Keypad7
:
return
NS_VK_NUMPAD7
;
case
kVK_ANSI_Keypad8
:
return
NS_VK_NUMPAD8
;
case
kVK_ANSI_Keypad9
:
return
NS_VK_NUMPAD9
;
case
kVK_ANSI_KeypadMultiply
:
return
NS_VK_MULTIPLY
;
case
kVK_ANSI_KeypadPlus
:
return
NS_VK_ADD
;
case
kVK_ANSI_KeypadMinus
:
return
NS_VK_SUBTRACT
;
case
kVK_ANSI_KeypadDecimal
:
return
NS_VK_DECIMAL
;
case
kVK_ANSI_KeypadDivide
:
return
NS_VK_DIVIDE
;
case
kVK_JIS_KeypadComma
:
return
NS_VK_SEPARATOR
;
case
kVK_JIS_Eisu
:
return
NS_VK_EISU
;
case
kVK_JIS_Kana
:
return
NS_VK_KANA
;
case
kVK_PC_Insert
:
return
NS_VK_INSERT
;
case
kVK_PC_Delete
:
return
NS_VK_DELETE
;
case
kVK_PC_Backspace
:
return
NS_VK_BACK
;
case
kVK_Tab
:
return
NS_VK_TAB
;
case
kVK_Home
:
return
NS_VK_HOME
;
case
kVK_End
:
return
NS_VK_END
;
case
kVK_PageUp
:
return
NS_VK_PAGE_UP
;
case
kVK_PageDown
:
return
NS_VK_PAGE_DOWN
;
case
kVK_LeftArrow
:
return
NS_VK_LEFT
;
case
kVK_RightArrow
:
return
NS_VK_RIGHT
;
case
kVK_UpArrow
:
return
NS_VK_UP
;
case
kVK_DownArrow
:
return
NS_VK_DOWN
;
case
kVK_PC_ContextMenu
:
return
NS_VK_CONTEXT_MENU
;
case
kVK_ANSI_1
:
return
NS_VK_1
;
case
kVK_ANSI_2
:
return
NS_VK_2
;
case
kVK_ANSI_3
:
return
NS_VK_3
;
case
kVK_ANSI_4
:
return
NS_VK_4
;
case
kVK_ANSI_5
:
return
NS_VK_5
;
case
kVK_ANSI_6
:
return
NS_VK_6
;
case
kVK_ANSI_7
:
return
NS_VK_7
;
case
kVK_ANSI_8
:
return
NS_VK_8
;
case
kVK_ANSI_9
:
return
NS_VK_9
;
case
kVK_ANSI_0
:
return
NS_VK_0
;
case
kVK_ANSI_KeypadEnter
:
case
kVK_Return
:
case
kVK_Powerbook_KeypadEnter
:
return
NS_VK_RETURN
;
}
UInt32
modifiers
=
aCmdIsPressed
?
cmdKey
:
0
;
uint32_t
charCode
=
TranslateToChar
(
aNativeKeyCode
modifiers
aKbType
)
;
if
(
charCode
=
=
0x00A5
)
{
return
NS_VK_BACK_SLASH
;
}
uint32_t
keyCode
=
WidgetUtils
:
:
ComputeKeyCodeFromChar
(
charCode
)
;
if
(
keyCode
)
{
return
keyCode
;
}
charCode
=
TranslateToChar
(
aNativeKeyCode
modifiers
|
shiftKey
aKbType
)
;
keyCode
=
WidgetUtils
:
:
ComputeKeyCodeFromChar
(
charCode
)
;
if
(
keyCode
)
{
return
keyCode
;
}
if
(
!
IsASCIICapable
(
)
)
{
TISInputSourceWrapper
currentKeyboardLayout
;
currentKeyboardLayout
.
InitByCurrentASCIICapableKeyboardLayout
(
)
;
NS_ENSURE_TRUE
(
mInputSource
!
=
currentKeyboardLayout
.
mInputSource
0
)
;
keyCode
=
currentKeyboardLayout
.
ComputeGeckoKeyCode
(
aNativeKeyCode
aKbType
aCmdIsPressed
)
;
if
(
keyCode
)
{
return
keyCode
;
}
}
CodeNameIndex
code
=
ComputeGeckoCodeNameIndex
(
aNativeKeyCode
aKbType
)
;
return
WidgetKeyboardEvent
:
:
GetFallbackKeyCodeOfPunctuationKey
(
code
)
;
}
KeyNameIndex
TISInputSourceWrapper
:
:
ComputeGeckoKeyNameIndex
(
UInt32
aNativeKeyCode
)
{
switch
(
aNativeKeyCode
)
{
#
define
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
(
aNativeKey
aKeyNameIndex
)
\
case
aNativeKey
:
\
return
aKeyNameIndex
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
default
:
return
KEY_NAME_INDEX_Unidentified
;
}
}
CodeNameIndex
TISInputSourceWrapper
:
:
ComputeGeckoCodeNameIndex
(
UInt32
aNativeKeyCode
UInt32
aKbType
)
{
if
(
:
:
KBGetLayoutType
(
aKbType
)
=
=
kKeyboardISO
)
{
if
(
aNativeKeyCode
=
=
kVK_ISO_Section
)
{
aNativeKeyCode
=
kVK_ANSI_Grave
;
}
else
if
(
aNativeKeyCode
=
=
kVK_ANSI_Grave
)
{
aNativeKeyCode
=
kVK_ISO_Section
;
}
}
switch
(
aNativeKeyCode
)
{
#
define
NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
(
aNativeKey
aCodeNameIndex
)
\
case
aNativeKey
:
\
return
aCodeNameIndex
;
#
include
"
NativeKeyToDOMCodeName
.
h
"
#
undef
NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
default
:
return
CODE_NAME_INDEX_UNKNOWN
;
}
}
#
pragma
mark
-
NSUInteger
TextInputHandler
:
:
sLastModifierState
=
0
;
CFArrayRef
TextInputHandler
:
:
CreateAllKeyboardLayoutList
(
)
{
const
void
*
keys
[
]
=
{
kTISPropertyInputSourceType
}
;
const
void
*
values
[
]
=
{
kTISTypeKeyboardLayout
}
;
CFDictionaryRef
filter
=
:
:
CFDictionaryCreate
(
kCFAllocatorDefault
keys
values
1
NULL
NULL
)
;
NS_ASSERTION
(
filter
"
failed
to
create
the
filter
"
)
;
CFArrayRef
list
=
:
:
TISCreateInputSourceList
(
filter
true
)
;
:
:
CFRelease
(
filter
)
;
return
list
;
}
void
TextInputHandler
:
:
DebugPrintAllKeyboardLayouts
(
)
{
if
(
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Info
)
)
{
CFArrayRef
list
=
CreateAllKeyboardLayoutList
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
Keyboard
layout
configuration
:
"
)
)
;
CFIndex
idx
=
:
:
CFArrayGetCount
(
list
)
;
TISInputSourceWrapper
tis
;
for
(
CFIndex
i
=
0
;
i
<
idx
;
+
+
i
)
{
TISInputSourceRef
inputSource
=
static_cast
<
TISInputSourceRef
>
(
const_cast
<
void
*
>
(
:
:
CFArrayGetValueAtIndex
(
list
i
)
)
)
;
tis
.
InitByTISInputSourceRef
(
inputSource
)
;
nsAutoString
name
isid
;
tis
.
GetLocalizedName
(
name
)
;
tis
.
GetInputSourceID
(
isid
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
s
\
t
<
%
s
>
%
s
%
s
\
n
"
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
isid
)
.
get
(
)
tis
.
IsASCIICapable
(
)
?
"
"
:
"
\
t
(
Isn
'
t
ASCII
capable
)
"
tis
.
IsKeyboardLayout
(
)
&
&
tis
.
GetUCKeyboardLayout
(
)
?
"
"
:
"
\
t
(
uchr
is
NOT
AVAILABLE
)
"
)
)
;
}
:
:
CFRelease
(
list
)
;
}
}
#
pragma
mark
-
TextInputHandler
:
:
TextInputHandler
(
nsChildView
*
aWidget
NSView
<
mozView
>
*
aNativeView
)
:
IMEInputHandler
(
aWidget
aNativeView
)
{
EnsureToLogAllKeyboardLayoutsAndIMEs
(
)
;
[
mView
installTextInputHandler
:
this
]
;
}
TextInputHandler
:
:
~
TextInputHandler
(
)
{
[
mView
uninstallTextInputHandler
]
;
}
bool
TextInputHandler
:
:
HandleKeyDownEvent
(
NSEvent
*
aNativeEvent
uint32_t
aUniqueId
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
"
"
widget
has
been
already
destroyed
"
this
)
)
;
return
false
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
"
)
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
aNativeEvent
=
%
p
"
"
type
=
%
s
keyCode
=
%
u
(
0x
%
X
)
modifierFlags
=
0x
%
lX
characters
=
\
"
%
s
\
"
"
"
charactersIgnoringModifiers
=
\
"
%
s
\
"
"
this
aNativeEvent
GetNativeKeyEventType
(
aNativeEvent
)
[
aNativeEvent
keyCode
]
[
aNativeEvent
keyCode
]
static_cast
<
unsigned
long
>
(
[
aNativeEvent
modifierFlags
]
)
GetCharacters
(
[
aNativeEvent
characters
]
)
GetCharacters
(
[
aNativeEvent
charactersIgnoringModifiers
]
)
)
)
;
if
(
!
(
[
aNativeEvent
modifierFlags
]
&
NSCommandKeyMask
)
)
{
[
NSCursor
setHiddenUntilMouseMoves
:
YES
]
;
}
RefPtr
<
nsChildView
>
widget
(
mWidget
)
;
KeyEventState
*
currentKeyEvent
=
PushKeyEvent
(
aNativeEvent
aUniqueId
)
;
AutoKeyEventStateCleaner
remover
(
this
)
;
ComplexTextInputPanel
*
ctiPanel
=
ComplexTextInputPanel
:
:
GetSharedComplexTextInputPanel
(
)
;
if
(
ctiPanel
&
&
ctiPanel
-
>
IsInComposition
(
)
)
{
nsAutoString
committed
;
ctiPanel
-
>
InterpretKeyEvent
(
aNativeEvent
committed
)
;
if
(
!
committed
.
IsEmpty
(
)
)
{
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
HandleKeyDownEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
"
at
dispatching
keydown
for
ComplexTextInputPanel
"
this
)
)
;
return
false
;
}
WidgetKeyboardEvent
imeEvent
(
true
eKeyDown
widget
)
;
currentKeyEvent
-
>
InitKeyEvent
(
this
imeEvent
false
)
;
imeEvent
.
mPluginTextEventString
.
Assign
(
committed
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyDown
imeEvent
status
currentKeyEvent
)
;
}
return
true
;
}
RefPtr
<
TextInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
IsIMEComposing
(
)
&
&
!
MaybeDispatchCurrentKeydownEvent
(
true
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
HandleKeyDownEvent
eKeyDown
caused
focus
move
or
"
"
something
and
canceling
the
composition
"
this
)
)
;
return
false
;
}
bool
wasComposing
=
IsIMEComposing
(
)
;
bool
interpretKeyEventsCalled
=
false
;
if
(
!
widget
-
>
IsPluginFocused
(
)
&
&
(
IsIMEEnabled
(
)
|
|
IsASCIICapableOnly
(
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
calling
interpretKeyEvents
"
this
)
)
;
[
mView
interpretKeyEvents
:
[
NSArray
arrayWithObject
:
aNativeEvent
]
]
;
interpretKeyEventsCalled
=
true
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
called
interpretKeyEvents
"
this
)
)
;
}
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
widget
was
destroyed
"
this
)
)
;
return
currentKeyEvent
-
>
IsDefaultPrevented
(
)
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
wasComposing
=
%
s
"
"
IsIMEComposing
(
)
=
%
s
"
this
TrueOrFalse
(
wasComposing
)
TrueOrFalse
(
IsIMEComposing
(
)
)
)
)
;
if
(
currentKeyEvent
-
>
CanDispatchKeyDownEvent
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
trying
to
dispatch
eKeyDown
"
"
event
since
it
'
s
not
yet
dispatched
"
this
)
)
;
if
(
!
MaybeDispatchCurrentKeydownEvent
(
IsIMEComposing
(
)
)
)
{
return
true
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
eKeyDown
event
has
been
"
"
dispatched
"
this
)
)
;
}
if
(
currentKeyEvent
-
>
CanDispatchKeyPressEvent
(
)
&
&
!
wasComposing
&
&
!
IsIMEComposing
(
)
)
{
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
HandleKeyDownEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
"
at
dispatching
keypress
"
this
)
)
;
return
false
;
}
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
widget
)
;
currentKeyEvent
-
>
InitKeyEvent
(
this
keypressEvent
false
)
;
if
(
!
(
interpretKeyEventsCalled
&
&
IsNormalCharInputtingEvent
(
keypressEvent
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
trying
to
dispatch
"
"
eKeyPress
event
since
it
'
s
not
yet
dispatched
"
this
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
currentKeyEvent
-
>
mKeyPressDispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
currentKeyEvent
)
;
currentKeyEvent
-
>
mKeyPressHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
currentKeyEvent
-
>
mKeyPressDispatched
=
true
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
eKeyPress
event
has
been
"
"
dispatched
"
this
)
)
;
}
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyDownEvent
"
"
keydown
handled
=
%
s
keypress
handled
=
%
s
causedOtherKeyEvents
=
%
s
"
"
compositionDispatched
=
%
s
"
this
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownHandled
)
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressHandled
)
TrueOrFalse
(
currentKeyEvent
-
>
mCausedOtherKeyEvents
)
TrueOrFalse
(
currentKeyEvent
-
>
mCompositionDispatched
)
)
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
"
)
)
;
return
currentKeyEvent
-
>
IsDefaultPrevented
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
void
TextInputHandler
:
:
HandleKeyUpEvent
(
NSEvent
*
aNativeEvent
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyUpEvent
aNativeEvent
=
%
p
"
"
type
=
%
s
keyCode
=
%
u
(
0x
%
X
)
modifierFlags
=
0x
%
lX
characters
=
\
"
%
s
\
"
"
"
charactersIgnoringModifiers
=
\
"
%
s
\
"
"
"
IsIMEComposing
(
)
=
%
s
"
this
aNativeEvent
GetNativeKeyEventType
(
aNativeEvent
)
[
aNativeEvent
keyCode
]
[
aNativeEvent
keyCode
]
static_cast
<
unsigned
long
>
(
[
aNativeEvent
modifierFlags
]
)
GetCharacters
(
[
aNativeEvent
characters
]
)
GetCharacters
(
[
aNativeEvent
charactersIgnoringModifiers
]
)
TrueOrFalse
(
IsIMEComposing
(
)
)
)
)
;
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleKeyUpEvent
"
"
widget
has
been
already
destroyed
"
this
)
)
;
return
;
}
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
HandleKeyUpEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
;
}
WidgetKeyboardEvent
keyupEvent
(
true
eKeyUp
mWidget
)
;
InitKeyEvent
(
aNativeEvent
keyupEvent
false
)
;
KeyEventState
currentKeyEvent
(
aNativeEvent
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyUp
keyupEvent
status
&
currentKeyEvent
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
TextInputHandler
:
:
HandleFlagsChanged
(
NSEvent
*
aNativeEvent
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleFlagsChanged
"
"
widget
has
been
already
destroyed
"
this
)
)
;
return
;
}
RefPtr
<
nsChildView
>
kungFuDeathGrip
(
mWidget
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleFlagsChanged
aNativeEvent
=
%
p
"
"
type
=
%
s
keyCode
=
%
s
(
0x
%
X
)
modifierFlags
=
0x
%
08lX
"
"
sLastModifierState
=
0x
%
08lX
IsIMEComposing
(
)
=
%
s
"
this
aNativeEvent
GetNativeKeyEventType
(
aNativeEvent
)
GetKeyNameForNativeKeyCode
(
[
aNativeEvent
keyCode
]
)
[
aNativeEvent
keyCode
]
static_cast
<
unsigned
long
>
(
[
aNativeEvent
modifierFlags
]
)
static_cast
<
unsigned
long
>
(
sLastModifierState
)
TrueOrFalse
(
IsIMEComposing
(
)
)
)
)
;
MOZ_ASSERT
(
[
aNativeEvent
type
]
=
=
NSFlagsChanged
)
;
NSUInteger
diff
=
[
aNativeEvent
modifierFlags
]
^
sLastModifierState
;
diff
&
=
~
(
NX_STYLUSPROXIMITYMASK
|
kCGEventFlagMaskNonCoalesced
)
;
switch
(
[
aNativeEvent
keyCode
]
)
{
case
kVK_CapsLock
:
{
DispatchKeyEventForFlagsChanged
(
aNativeEvent
true
)
;
break
;
}
case
kVK_Shift
:
case
kVK_RightShift
:
case
kVK_Command
:
case
kVK_RightCommand
:
case
kVK_Control
:
case
kVK_RightControl
:
case
kVK_Option
:
case
kVK_RightOption
:
case
kVK_Help
:
{
bool
isKeyDown
=
(
[
aNativeEvent
modifierFlags
]
&
diff
)
!
=
0
;
DispatchKeyEventForFlagsChanged
(
aNativeEvent
isKeyDown
)
;
if
(
isKeyDown
&
&
(
(
diff
&
~
NSDeviceIndependentModifierFlagsMask
)
!
=
0
)
)
{
unsigned
short
keyCode
=
[
aNativeEvent
keyCode
]
;
const
ModifierKey
*
modifierKey
=
GetModifierKeyForDeviceDependentFlags
(
diff
)
;
if
(
modifierKey
&
&
modifierKey
-
>
keyCode
!
=
keyCode
)
{
NS_WARNING
(
"
Resetting
stored
modifier
key
information
"
)
;
mModifierKeys
.
Clear
(
)
;
modifierKey
=
nullptr
;
}
if
(
!
modifierKey
)
{
mModifierKeys
.
AppendElement
(
ModifierKey
(
diff
keyCode
)
)
;
}
}
break
;
}
case
kVK_Function
:
break
;
default
:
{
NSUInteger
modifiers
=
sLastModifierState
;
AutoTArray
<
unsigned
short
10
>
dispatchedKeyCodes
;
for
(
int32_t
bit
=
0
;
bit
<
32
;
+
+
bit
)
{
NSUInteger
flag
=
1
<
<
bit
;
if
(
!
(
diff
&
flag
)
)
{
continue
;
}
bool
dispatchKeyDown
=
(
(
flag
&
[
aNativeEvent
modifierFlags
]
)
!
=
0
)
;
unsigned
short
keyCode
=
0
;
if
(
flag
&
NSDeviceIndependentModifierFlagsMask
)
{
switch
(
flag
)
{
case
NSAlphaShiftKeyMask
:
keyCode
=
kVK_CapsLock
;
dispatchKeyDown
=
true
;
break
;
case
NSNumericPadKeyMask
:
continue
;
case
NSHelpKeyMask
:
keyCode
=
kVK_Help
;
break
;
case
NSFunctionKeyMask
:
continue
;
case
NSShiftKeyMask
:
keyCode
=
(
modifiers
&
0x0004
)
?
kVK_RightShift
:
kVK_Shift
;
break
;
case
NSControlKeyMask
:
keyCode
=
(
modifiers
&
0x2000
)
?
kVK_RightControl
:
kVK_Control
;
break
;
case
NSAlternateKeyMask
:
keyCode
=
(
modifiers
&
0x0040
)
?
kVK_RightOption
:
kVK_Option
;
break
;
case
NSCommandKeyMask
:
keyCode
=
(
modifiers
&
0x0010
)
?
kVK_RightCommand
:
kVK_Command
;
break
;
default
:
continue
;
}
}
else
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForDeviceDependentFlags
(
flag
)
;
if
(
!
modifierKey
)
{
continue
;
}
keyCode
=
modifierKey
-
>
keyCode
;
}
modifiers
&
=
~
flag
;
switch
(
keyCode
)
{
case
kVK_Shift
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_RightShift
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSShiftKeyMask
;
}
break
;
}
case
kVK_RightShift
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_Shift
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSShiftKeyMask
;
}
break
;
}
case
kVK_Command
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_RightCommand
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSCommandKeyMask
;
}
break
;
}
case
kVK_RightCommand
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_Command
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSCommandKeyMask
;
}
break
;
}
case
kVK_Control
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_RightControl
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSControlKeyMask
;
}
break
;
}
case
kVK_RightControl
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_Control
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSControlKeyMask
;
}
break
;
}
case
kVK_Option
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_RightOption
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSAlternateKeyMask
;
}
break
;
}
case
kVK_RightOption
:
{
const
ModifierKey
*
modifierKey
=
GetModifierKeyForNativeKeyCode
(
kVK_Option
)
;
if
(
!
modifierKey
|
|
!
(
modifiers
&
modifierKey
-
>
GetDeviceDependentFlags
(
)
)
)
{
modifiers
&
=
~
NSAlternateKeyMask
;
}
break
;
}
case
kVK_Help
:
modifiers
&
=
~
NSHelpKeyMask
;
break
;
default
:
break
;
}
if
(
dispatchedKeyCodes
.
Contains
(
keyCode
)
)
{
continue
;
}
dispatchedKeyCodes
.
AppendElement
(
keyCode
)
;
NSEvent
*
event
=
[
NSEvent
keyEventWithType
:
NSFlagsChanged
location
:
[
aNativeEvent
locationInWindow
]
modifierFlags
:
modifiers
timestamp
:
[
aNativeEvent
timestamp
]
windowNumber
:
[
aNativeEvent
windowNumber
]
context
:
[
aNativeEvent
context
]
characters
:
"
"
charactersIgnoringModifiers
:
"
"
isARepeat
:
NO
keyCode
:
keyCode
]
;
DispatchKeyEventForFlagsChanged
(
event
dispatchKeyDown
)
;
if
(
Destroyed
(
)
)
{
break
;
}
if
(
!
[
mView
isFirstResponder
]
)
{
break
;
}
}
break
;
}
}
sLastModifierState
=
[
aNativeEvent
modifierFlags
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
const
TextInputHandler
:
:
ModifierKey
*
TextInputHandler
:
:
GetModifierKeyForNativeKeyCode
(
unsigned
short
aKeyCode
)
const
{
for
(
ModifierKeyArray
:
:
index_type
i
=
0
;
i
<
mModifierKeys
.
Length
(
)
;
+
+
i
)
{
if
(
mModifierKeys
[
i
]
.
keyCode
=
=
aKeyCode
)
{
return
&
(
(
ModifierKey
&
)
mModifierKeys
[
i
]
)
;
}
}
return
nullptr
;
}
const
TextInputHandler
:
:
ModifierKey
*
TextInputHandler
:
:
GetModifierKeyForDeviceDependentFlags
(
NSUInteger
aFlags
)
const
{
for
(
ModifierKeyArray
:
:
index_type
i
=
0
;
i
<
mModifierKeys
.
Length
(
)
;
+
+
i
)
{
if
(
mModifierKeys
[
i
]
.
GetDeviceDependentFlags
(
)
=
=
(
aFlags
&
~
NSDeviceIndependentModifierFlagsMask
)
)
{
return
&
(
(
ModifierKey
&
)
mModifierKeys
[
i
]
)
;
}
}
return
nullptr
;
}
void
TextInputHandler
:
:
DispatchKeyEventForFlagsChanged
(
NSEvent
*
aNativeEvent
bool
aDispatchKeyDown
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
Destroyed
(
)
)
{
return
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
DispatchKeyEventForFlagsChanged
aNativeEvent
=
%
p
"
"
type
=
%
s
keyCode
=
%
s
(
0x
%
X
)
aDispatchKeyDown
=
%
s
IsIMEComposing
(
)
=
%
s
"
this
aNativeEvent
GetNativeKeyEventType
(
aNativeEvent
)
GetKeyNameForNativeKeyCode
(
[
aNativeEvent
keyCode
]
)
[
aNativeEvent
keyCode
]
TrueOrFalse
(
aDispatchKeyDown
)
TrueOrFalse
(
IsIMEComposing
(
)
)
)
)
;
if
(
[
aNativeEvent
type
]
!
=
NSFlagsChanged
)
{
return
;
}
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchKeyEventForFlagsChanged
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
;
}
EventMessage
message
=
aDispatchKeyDown
?
eKeyDown
:
eKeyUp
;
WidgetKeyboardEvent
keyEvent
(
true
message
mWidget
)
;
InitKeyEvent
(
aNativeEvent
keyEvent
false
)
;
NPCocoaEvent
cocoaEvent
;
nsCocoaUtils
:
:
InitNPCocoaEvent
(
&
cocoaEvent
)
;
cocoaEvent
.
type
=
NPCocoaEventFlagsChanged
;
keyEvent
.
mPluginEvent
.
Copy
(
cocoaEvent
)
;
KeyEventState
currentKeyEvent
(
aNativeEvent
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mDispatcher
-
>
DispatchKeyboardEvent
(
message
keyEvent
status
&
currentKeyEvent
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
TextInputHandler
:
:
InsertText
(
NSAttributedString
*
aAttrString
NSRange
*
aReplacementRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
Destroyed
(
)
)
{
return
;
}
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
InsertText
aAttrString
=
\
"
%
s
\
"
"
"
aReplacementRange
=
%
p
{
location
=
%
lu
length
=
%
lu
}
"
"
IsIMEComposing
(
)
=
%
s
"
"
keyevent
=
%
p
keydownDispatched
=
%
s
"
"
keydownHandled
=
%
s
keypressDispatched
=
%
s
"
"
causedOtherKeyEvents
=
%
s
compositionDispatched
=
%
s
"
this
GetCharacters
(
[
aAttrString
string
]
)
aReplacementRange
static_cast
<
unsigned
long
>
(
aReplacementRange
?
aReplacementRange
-
>
location
:
0
)
static_cast
<
unsigned
long
>
(
aReplacementRange
?
aReplacementRange
-
>
length
:
0
)
TrueOrFalse
(
IsIMEComposing
(
)
)
currentKeyEvent
?
currentKeyEvent
-
>
mKeyEvent
:
nullptr
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownHandled
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCausedOtherKeyEvents
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCompositionDispatched
)
:
"
N
/
A
"
)
)
;
InputContext
context
=
mWidget
-
>
GetInputContext
(
)
;
bool
isEditable
=
(
context
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
ENABLED
|
|
context
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PASSWORD
)
;
NSRange
selectedRange
=
SelectedRange
(
)
;
nsAutoString
str
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
aAttrString
string
]
str
)
;
AutoInsertStringClearer
clearer
(
currentKeyEvent
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mInsertString
=
&
str
;
}
if
(
!
IsIMEComposing
(
)
&
&
str
.
IsEmpty
(
)
)
{
if
(
!
isEditable
)
{
return
;
}
if
(
aReplacementRange
&
&
aReplacementRange
-
>
location
!
=
NSNotFound
)
{
if
(
aReplacementRange
-
>
length
=
=
0
)
{
return
;
}
if
(
!
NSEqualRanges
(
selectedRange
*
aReplacementRange
)
)
{
NS_ENSURE_TRUE_VOID
(
SetSelection
(
*
aReplacementRange
)
)
;
}
selectedRange
=
SelectedRange
(
)
;
}
NS_ENSURE_TRUE_VOID
(
selectedRange
.
location
!
=
NSNotFound
)
;
if
(
selectedRange
.
length
=
=
0
)
{
return
;
}
if
(
!
currentKeyEvent
)
{
return
;
}
RefPtr
<
TextInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
!
IsIMEComposing
(
)
&
&
!
MaybeDispatchCurrentKeydownEvent
(
false
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertText
eKeyDown
caused
focus
move
or
"
"
something
and
canceling
the
composition
"
this
)
)
;
return
;
}
WidgetContentCommandEvent
deleteCommandEvent
(
true
eContentCommandDelete
mWidget
)
;
DispatchEvent
(
deleteCommandEvent
)
;
NS_ENSURE_TRUE_VOID
(
deleteCommandEvent
.
mSucceeded
)
;
return
;
}
bool
isReplacingSpecifiedRange
=
isEditable
&
&
aReplacementRange
&
&
aReplacementRange
-
>
location
!
=
NSNotFound
&
&
!
NSEqualRanges
(
selectedRange
*
aReplacementRange
)
;
if
(
!
currentKeyEvent
|
|
currentKeyEvent
-
>
mCompositionDispatched
|
|
IsIMEComposing
(
)
|
|
isReplacingSpecifiedRange
)
{
InsertTextAsCommittingComposition
(
aAttrString
aReplacementRange
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mCompositionDispatched
=
true
;
}
return
;
}
if
(
currentKeyEvent
&
&
!
currentKeyEvent
-
>
CanDispatchKeyPressEvent
(
)
&
&
(
str
.
IsEmpty
(
)
|
|
(
str
.
Length
(
)
=
=
1
&
&
!
IsPrintableChar
(
str
[
0
]
)
)
)
)
{
return
;
}
RefPtr
<
TextInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
!
MaybeDispatchCurrentKeydownEvent
(
false
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertText
eKeyDown
caused
focus
move
or
"
"
something
and
canceling
the
composition
"
this
)
)
;
return
;
}
RefPtr
<
nsChildView
>
widget
(
mWidget
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
InsertText
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertText
"
"
maybe
dispatches
eKeyPress
event
without
control
alt
and
meta
modifiers
"
this
)
)
;
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
widget
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
InitKeyEvent
(
this
keypressEvent
false
)
;
}
else
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
static_cast
<
NSEvent
*
>
(
nullptr
)
)
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_USE_STRING
;
keypressEvent
.
mKeyValue
=
str
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
bool
keyPressDispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
currentKeyEvent
)
;
bool
keyPressHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mKeyPressHandled
=
keyPressHandled
;
currentKeyEvent
-
>
mKeyPressDispatched
=
keyPressDispatched
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
TextInputHandler
:
:
HandleCommand
(
Command
aCommand
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
Destroyed
(
)
)
{
return
false
;
}
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
HandleCommand
"
"
aCommand
=
%
s
IsIMEComposing
(
)
=
%
s
"
"
keyevent
=
%
p
keydownHandled
=
%
s
keypressDispatched
=
%
s
"
"
causedOtherKeyEvents
=
%
s
compositionDispatched
=
%
s
"
this
ToChar
(
aCommand
)
TrueOrFalse
(
IsIMEComposing
(
)
)
currentKeyEvent
?
currentKeyEvent
-
>
mKeyEvent
:
nullptr
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownHandled
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCausedOtherKeyEvents
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCompositionDispatched
)
:
"
N
/
A
"
)
)
;
if
(
currentKeyEvent
&
&
!
currentKeyEvent
-
>
CanHandleCommand
(
)
)
{
return
false
;
}
RefPtr
<
TextInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
!
IsIMEComposing
(
)
&
&
!
MaybeDispatchCurrentKeydownEvent
(
false
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
eKeyDown
caused
focus
move
or
"
"
something
and
canceling
the
composition
"
this
)
)
;
return
false
;
}
if
(
IsIMEComposing
(
)
)
{
switch
(
aCommand
)
{
case
Command
:
:
InsertLineBreak
:
case
Command
:
:
InsertParagraph
:
{
NSAttributedString
*
lineBreaker
=
[
[
NSAttributedString
alloc
]
initWithString
:
"
\
n
"
]
;
InsertTextAsCommittingComposition
(
lineBreaker
nullptr
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mCompositionDispatched
=
true
;
}
[
lineBreaker
release
]
;
return
true
;
}
case
Command
:
:
DeleteCharBackward
:
case
Command
:
:
DeleteCharForward
:
case
Command
:
:
DeleteToBeginningOfLine
:
case
Command
:
:
DeleteWordBackward
:
case
Command
:
:
DeleteWordForward
:
return
false
;
case
Command
:
:
InsertTab
:
case
Command
:
:
InsertBacktab
:
return
false
;
case
Command
:
:
CharNext
:
case
Command
:
:
SelectCharNext
:
case
Command
:
:
WordNext
:
case
Command
:
:
SelectWordNext
:
case
Command
:
:
EndLine
:
case
Command
:
:
SelectEndLine
:
case
Command
:
:
CharPrevious
:
case
Command
:
:
SelectCharPrevious
:
case
Command
:
:
WordPrevious
:
case
Command
:
:
SelectWordPrevious
:
case
Command
:
:
BeginLine
:
case
Command
:
:
SelectBeginLine
:
case
Command
:
:
LinePrevious
:
case
Command
:
:
SelectLinePrevious
:
case
Command
:
:
MoveTop
:
case
Command
:
:
LineNext
:
case
Command
:
:
SelectLineNext
:
case
Command
:
:
MoveBottom
:
case
Command
:
:
SelectBottom
:
case
Command
:
:
SelectPageUp
:
case
Command
:
:
SelectPageDown
:
case
Command
:
:
ScrollBottom
:
case
Command
:
:
ScrollTop
:
return
false
;
case
Command
:
:
CancelOperation
:
case
Command
:
:
Complete
:
return
false
;
case
Command
:
:
ScrollPageUp
:
case
Command
:
:
ScrollPageDown
:
break
;
default
:
break
;
}
}
RefPtr
<
nsChildView
>
widget
(
mWidget
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
HandleCommand
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
bool
dispatchFakeKeyPress
=
!
(
currentKeyEvent
&
&
currentKeyEvent
-
>
IsProperKeyEvent
(
aCommand
)
)
;
WidgetKeyboardEvent
keydownEvent
(
true
eKeyDown
widget
)
;
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
widget
)
;
if
(
!
dispatchFakeKeyPress
)
{
currentKeyEvent
-
>
InitKeyEvent
(
this
keydownEvent
false
)
;
currentKeyEvent
-
>
InitKeyEvent
(
this
keypressEvent
false
)
;
}
else
{
NSEvent
*
keyEvent
=
currentKeyEvent
?
currentKeyEvent
-
>
mKeyEvent
:
nullptr
;
keydownEvent
.
mNativeKeyEvent
=
keypressEvent
.
mNativeKeyEvent
=
keyEvent
;
NS_WARNING_ASSERTION
(
keypressEvent
.
mNativeKeyEvent
"
Without
native
key
event
NativeKeyBindings
cannot
compute
aCommand
"
)
;
switch
(
aCommand
)
{
case
Command
:
:
InsertLineBreak
:
case
Command
:
:
InsertParagraph
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_RETURN
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Enter
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
InsertLineBreak
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_CONTROL
;
}
break
;
}
case
Command
:
:
InsertTab
:
case
Command
:
:
InsertBacktab
:
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_TAB
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Tab
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
InsertBacktab
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
break
;
case
Command
:
:
DeleteCharBackward
:
case
Command
:
:
DeleteToBeginningOfLine
:
case
Command
:
:
DeleteWordBackward
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_BACK
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Backspace
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
DeleteToBeginningOfLine
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_META
;
}
else
if
(
aCommand
=
=
Command
:
:
DeleteWordBackward
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_ALT
;
}
break
;
}
case
Command
:
:
DeleteCharForward
:
case
Command
:
:
DeleteWordForward
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_DELETE
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Delete
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
DeleteWordForward
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_ALT
;
}
break
;
}
case
Command
:
:
CharNext
:
case
Command
:
:
SelectCharNext
:
case
Command
:
:
WordNext
:
case
Command
:
:
SelectWordNext
:
case
Command
:
:
EndLine
:
case
Command
:
:
SelectEndLine
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_RIGHT
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_ArrowRight
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
SelectCharNext
|
|
aCommand
=
=
Command
:
:
SelectWordNext
|
|
aCommand
=
=
Command
:
:
SelectEndLine
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
if
(
aCommand
=
=
Command
:
:
WordNext
|
|
aCommand
=
=
Command
:
:
SelectWordNext
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_ALT
;
}
if
(
aCommand
=
=
Command
:
:
EndLine
|
|
aCommand
=
=
Command
:
:
SelectEndLine
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_META
;
}
break
;
}
case
Command
:
:
CharPrevious
:
case
Command
:
:
SelectCharPrevious
:
case
Command
:
:
WordPrevious
:
case
Command
:
:
SelectWordPrevious
:
case
Command
:
:
BeginLine
:
case
Command
:
:
SelectBeginLine
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_LEFT
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_ArrowLeft
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
SelectCharPrevious
|
|
aCommand
=
=
Command
:
:
SelectWordPrevious
|
|
aCommand
=
=
Command
:
:
SelectBeginLine
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
if
(
aCommand
=
=
Command
:
:
WordPrevious
|
|
aCommand
=
=
Command
:
:
SelectWordPrevious
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_ALT
;
}
if
(
aCommand
=
=
Command
:
:
BeginLine
|
|
aCommand
=
=
Command
:
:
SelectBeginLine
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_META
;
}
break
;
}
case
Command
:
:
LinePrevious
:
case
Command
:
:
SelectLinePrevious
:
case
Command
:
:
MoveTop
:
case
Command
:
:
SelectTop
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_UP
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_ArrowUp
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
SelectLinePrevious
|
|
aCommand
=
=
Command
:
:
SelectTop
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
if
(
aCommand
=
=
Command
:
:
MoveTop
|
|
aCommand
=
=
Command
:
:
SelectTop
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_META
;
}
break
;
}
case
Command
:
:
LineNext
:
case
Command
:
:
SelectLineNext
:
case
Command
:
:
MoveBottom
:
case
Command
:
:
SelectBottom
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_DOWN
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_ArrowDown
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
SelectLineNext
|
|
aCommand
=
=
Command
:
:
SelectBottom
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
if
(
aCommand
=
=
Command
:
:
MoveBottom
|
|
aCommand
=
=
Command
:
:
SelectBottom
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_META
;
}
break
;
}
case
Command
:
:
ScrollPageUp
:
case
Command
:
:
SelectPageUp
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_PAGE_UP
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_PageUp
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
SelectPageUp
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
break
;
}
case
Command
:
:
ScrollPageDown
:
case
Command
:
:
SelectPageDown
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_PAGE_DOWN
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_PageDown
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
SelectPageDown
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_SHIFT
;
}
break
;
}
case
Command
:
:
ScrollBottom
:
case
Command
:
:
ScrollTop
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
if
(
aCommand
=
=
Command
:
:
ScrollBottom
)
{
keypressEvent
.
mKeyCode
=
NS_VK_END
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_End
;
}
else
{
keypressEvent
.
mKeyCode
=
NS_VK_HOME
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Home
;
}
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
break
;
}
case
Command
:
:
CancelOperation
:
case
Command
:
:
Complete
:
{
nsCocoaUtils
:
:
InitInputEvent
(
keypressEvent
keyEvent
)
;
keypressEvent
.
mKeyCode
=
NS_VK_ESCAPE
;
keypressEvent
.
mKeyNameIndex
=
KEY_NAME_INDEX_Escape
;
keypressEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
if
(
aCommand
=
=
Command
:
:
Complete
)
{
keypressEvent
.
mModifiers
|
=
MODIFIER_ALT
;
}
break
;
}
default
:
return
false
;
}
nsCocoaUtils
:
:
InitInputEvent
(
keydownEvent
keyEvent
)
;
keydownEvent
.
mKeyCode
=
keypressEvent
.
mKeyCode
;
keydownEvent
.
mKeyNameIndex
=
keypressEvent
.
mKeyNameIndex
;
keydownEvent
.
mModifiers
=
keypressEvent
.
mModifiers
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
mDispatcher
-
>
DispatchKeyboardEvent
(
eKeyDown
keydownEvent
status
nullptr
)
)
{
bool
keydownHandled
=
status
=
=
nsEventStatus_eConsumeNoDefault
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mKeyDownDispatched
=
true
;
currentKeyEvent
-
>
mKeyDownHandled
|
=
keydownHandled
;
}
if
(
keydownHandled
)
{
return
true
;
}
}
bool
keyPressDispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
currentKeyEvent
)
;
bool
keyPressHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
keyPressDispatched
)
{
if
(
!
dispatchFakeKeyPress
&
&
currentKeyEvent
)
{
currentKeyEvent
-
>
mKeyPressHandled
=
keyPressHandled
;
currentKeyEvent
-
>
mKeyPressDispatched
=
keyPressDispatched
;
}
return
true
;
}
if
(
aCommand
=
=
Command
:
:
InsertLineBreak
|
|
aCommand
=
=
Command
:
:
InsertParagraph
)
{
NSAttributedString
*
lineBreaker
=
[
[
NSAttributedString
alloc
]
initWithString
:
"
\
n
"
]
;
InsertTextAsCommittingComposition
(
lineBreaker
nullptr
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mCompositionDispatched
=
true
;
}
[
lineBreaker
release
]
;
return
true
;
}
return
false
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
bool
TextInputHandler
:
:
DoCommandBySelector
(
const
char
*
aSelector
)
{
RefPtr
<
nsChildView
>
widget
(
mWidget
)
;
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
DoCommandBySelector
aSelector
=
\
"
%
s
\
"
"
"
Destroyed
(
)
=
%
s
keydownDispatched
=
%
s
keydownHandled
=
%
s
"
"
keypressDispatched
=
%
s
keypressHandled
=
%
s
causedOtherKeyEvents
=
%
s
"
this
aSelector
?
aSelector
:
"
"
TrueOrFalse
(
Destroyed
(
)
)
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownHandled
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressHandled
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCausedOtherKeyEvents
)
:
"
N
/
A
"
)
)
;
if
(
!
currentKeyEvent
)
{
return
Destroyed
(
)
;
}
RefPtr
<
TextInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
!
IsIMEComposing
(
)
&
&
!
MaybeDispatchCurrentKeydownEvent
(
false
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
eKeyDown
caused
focus
move
or
"
"
something
and
canceling
the
composition
"
this
)
)
;
return
true
;
}
if
(
currentKeyEvent
-
>
CanDispatchKeyPressEvent
(
)
)
{
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DoCommandBySelector
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
"
at
dispatching
keypress
"
this
)
)
;
return
Destroyed
(
)
;
}
WidgetKeyboardEvent
keypressEvent
(
true
eKeyPress
widget
)
;
currentKeyEvent
-
>
InitKeyEvent
(
this
keypressEvent
false
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
currentKeyEvent
-
>
mKeyPressDispatched
=
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
keypressEvent
status
currentKeyEvent
)
;
currentKeyEvent
-
>
mKeyPressHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandler
:
:
DoCommandBySelector
keypress
event
"
"
dispatched
Destroyed
(
)
=
%
s
keypressHandled
=
%
s
"
this
TrueOrFalse
(
Destroyed
(
)
)
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressHandled
)
)
)
;
return
true
;
}
if
(
Destroyed
(
)
|
|
!
currentKeyEvent
-
>
CanHandleCommand
(
)
)
{
return
true
;
}
if
(
!
strcmp
(
aSelector
"
cancelOperatiorn
:
"
)
&
&
currentKeyEvent
&
&
currentKeyEvent
-
>
IsProperKeyEvent
(
Command
:
:
CancelOperation
)
)
{
return
HandleCommand
(
Command
:
:
CancelOperation
)
;
}
return
false
;
}
#
pragma
mark
-
bool
IMEInputHandler
:
:
sStaticMembersInitialized
=
false
;
bool
IMEInputHandler
:
:
sCachedIsForRTLLangage
=
false
;
CFStringRef
IMEInputHandler
:
:
sLatestIMEOpenedModeInputSourceID
=
nullptr
;
IMEInputHandler
*
IMEInputHandler
:
:
sFocusedIMEHandler
=
nullptr
;
void
IMEInputHandler
:
:
InitStaticMembers
(
)
{
if
(
sStaticMembersInitialized
)
return
;
sStaticMembersInitialized
=
true
;
CFNotificationCenterRef
center
=
:
:
CFNotificationCenterGetDistributedCenter
(
)
;
:
:
CFNotificationCenterAddObserver
(
center
NULL
OnCurrentTextInputSourceChange
kTISNotifySelectedKeyboardInputSourceChanged
NULL
CFNotificationSuspensionBehaviorDeliverImmediately
)
;
OnCurrentTextInputSourceChange
(
NULL
NULL
kTISNotifySelectedKeyboardInputSourceChanged
NULL
NULL
)
;
}
void
IMEInputHandler
:
:
OnCurrentTextInputSourceChange
(
CFNotificationCenterRef
aCenter
void
*
aObserver
CFStringRef
aName
const
void
*
aObject
CFDictionaryRef
aUserInfo
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByCurrentInputSource
(
)
;
if
(
tis
.
IsOpenedIMEMode
(
)
)
{
tis
.
GetInputSourceID
(
sLatestIMEOpenedModeInputSourceID
)
;
nsAutoString
key
;
if
(
tis
.
IsForJapaneseLanguage
(
)
)
{
tis
.
GetBundleID
(
key
)
;
}
else
{
tis
.
GetInputSourceID
(
key
)
;
}
if
(
key
.
Length
(
)
>
72
)
{
if
(
NS_IS_SURROGATE_PAIR
(
key
[
72
-
2
]
key
[
72
-
1
]
)
)
{
key
.
Truncate
(
72
-
2
)
;
}
else
{
key
.
Truncate
(
72
-
1
)
;
}
key
.
Append
(
char16_t
(
0x2026
)
)
;
}
Telemetry
:
:
ScalarSet
(
Telemetry
:
:
ScalarID
:
:
WIDGET_IME_NAME_ON_MAC
key
true
)
;
}
if
(
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Info
)
)
{
static
CFStringRef
sLastTIS
=
nullptr
;
CFStringRef
newTIS
;
tis
.
GetInputSourceID
(
newTIS
)
;
if
(
!
sLastTIS
|
|
:
:
CFStringCompare
(
sLastTIS
newTIS
0
)
!
=
kCFCompareEqualTo
)
{
TISInputSourceWrapper
tis1
tis2
tis3
tis4
tis5
;
tis1
.
InitByCurrentKeyboardLayout
(
)
;
tis2
.
InitByCurrentASCIICapableInputSource
(
)
;
tis3
.
InitByCurrentASCIICapableKeyboardLayout
(
)
;
tis4
.
InitByCurrentInputMethodKeyboardLayoutOverride
(
)
;
tis5
.
InitByTISInputSourceRef
(
tis
.
GetKeyboardLayoutInputSource
(
)
)
;
CFStringRef
is0
=
nullptr
is1
=
nullptr
is2
=
nullptr
is3
=
nullptr
is4
=
nullptr
is5
=
nullptr
type0
=
nullptr
lang0
=
nullptr
bundleID0
=
nullptr
;
tis
.
GetInputSourceID
(
is0
)
;
tis1
.
GetInputSourceID
(
is1
)
;
tis2
.
GetInputSourceID
(
is2
)
;
tis3
.
GetInputSourceID
(
is3
)
;
tis4
.
GetInputSourceID
(
is4
)
;
tis5
.
GetInputSourceID
(
is5
)
;
tis
.
GetInputSourceType
(
type0
)
;
tis
.
GetPrimaryLanguage
(
lang0
)
;
tis
.
GetBundleID
(
bundleID0
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
IMEInputHandler
:
:
OnCurrentTextInputSourceChange
\
n
"
"
Current
Input
Source
is
changed
to
:
\
n
"
"
currentInputContext
=
%
p
\
n
"
"
%
s
\
n
"
"
type
=
%
s
%
s
\
n
"
"
overridden
keyboard
layout
=
%
s
\
n
"
"
used
keyboard
layout
for
translation
=
%
s
\
n
"
"
primary
language
=
%
s
\
n
"
"
bundle
ID
=
%
s
\
n
"
"
current
ASCII
capable
Input
Source
=
%
s
\
n
"
"
current
Keyboard
Layout
=
%
s
\
n
"
"
current
ASCII
capable
Keyboard
Layout
=
%
s
"
[
NSTextInputContext
currentInputContext
]
GetCharacters
(
is0
)
GetCharacters
(
type0
)
tis
.
IsASCIICapable
(
)
?
"
-
ASCII
capable
"
:
"
"
GetCharacters
(
is4
)
GetCharacters
(
is5
)
GetCharacters
(
lang0
)
GetCharacters
(
bundleID0
)
GetCharacters
(
is2
)
GetCharacters
(
is1
)
GetCharacters
(
is3
)
)
)
;
}
sLastTIS
=
newTIS
;
}
if
(
sCachedIsForRTLLangage
!
=
tis
.
IsForRTLLanguage
(
)
)
{
WidgetUtils
:
:
SendBidiKeyboardInfoToContent
(
)
;
sCachedIsForRTLLangage
=
tis
.
IsForRTLLanguage
(
)
;
}
}
void
IMEInputHandler
:
:
FlushPendingMethods
(
nsITimer
*
aTimer
void
*
aClosure
)
{
NS_ASSERTION
(
aClosure
"
aClosure
is
null
"
)
;
static_cast
<
IMEInputHandler
*
>
(
aClosure
)
-
>
ExecutePendingMethods
(
)
;
}
CFArrayRef
IMEInputHandler
:
:
CreateAllIMEModeList
(
)
{
const
void
*
keys
[
]
=
{
kTISPropertyInputSourceType
}
;
const
void
*
values
[
]
=
{
kTISTypeKeyboardInputMode
}
;
CFDictionaryRef
filter
=
:
:
CFDictionaryCreate
(
kCFAllocatorDefault
keys
values
1
NULL
NULL
)
;
NS_ASSERTION
(
filter
"
failed
to
create
the
filter
"
)
;
CFArrayRef
list
=
:
:
TISCreateInputSourceList
(
filter
true
)
;
:
:
CFRelease
(
filter
)
;
return
list
;
}
void
IMEInputHandler
:
:
DebugPrintAllIMEModes
(
)
{
if
(
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Info
)
)
{
CFArrayRef
list
=
CreateAllIMEModeList
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
IME
mode
configuration
:
"
)
)
;
CFIndex
idx
=
:
:
CFArrayGetCount
(
list
)
;
TISInputSourceWrapper
tis
;
for
(
CFIndex
i
=
0
;
i
<
idx
;
+
+
i
)
{
TISInputSourceRef
inputSource
=
static_cast
<
TISInputSourceRef
>
(
const_cast
<
void
*
>
(
:
:
CFArrayGetValueAtIndex
(
list
i
)
)
)
;
tis
.
InitByTISInputSourceRef
(
inputSource
)
;
nsAutoString
name
isid
bundleID
;
tis
.
GetLocalizedName
(
name
)
;
tis
.
GetInputSourceID
(
isid
)
;
tis
.
GetBundleID
(
bundleID
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
s
\
t
<
%
s
>
%
s
%
s
\
n
"
"
bundled
in
<
%
s
>
\
n
"
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
isid
)
.
get
(
)
tis
.
IsASCIICapable
(
)
?
"
"
:
"
\
t
(
Isn
'
t
ASCII
capable
)
"
tis
.
IsEnabled
(
)
?
"
"
:
"
\
t
(
Isn
'
t
Enabled
)
"
NS_ConvertUTF16toUTF8
(
bundleID
)
.
get
(
)
)
)
;
}
:
:
CFRelease
(
list
)
;
}
}
TSMDocumentID
IMEInputHandler
:
:
GetCurrentTSMDocumentID
(
)
{
[
NSTextInputContext
currentInputContext
]
;
return
:
:
TSMGetActiveDocument
(
)
;
}
#
pragma
mark
-
nsresult
IMEInputHandler
:
:
NotifyIME
(
TextEventDispatcher
*
aTextEventDispatcher
const
IMENotification
&
aNotification
)
{
switch
(
aNotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
CommitIMEComposition
(
)
;
return
NS_OK
;
case
REQUEST_TO_CANCEL_COMPOSITION
:
CancelIMEComposition
(
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_FOCUS
:
if
(
IsFocused
(
)
)
{
nsIWidget
*
widget
=
aTextEventDispatcher
-
>
GetWidget
(
)
;
if
(
widget
&
&
widget
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
)
{
EnableSecureEventInput
(
)
;
}
else
{
EnsureSecureEventInputDisabled
(
)
;
}
}
OnFocusChangeInGecko
(
true
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_BLUR
:
OnFocusChangeInGecko
(
false
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
OnSelectionChange
(
aNotification
)
;
return
NS_OK
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
OnLayoutChange
(
)
;
return
NS_OK
;
default
:
return
NS_ERROR_NOT_IMPLEMENTED
;
}
}
NS_IMETHODIMP_
(
IMENotificationRequests
)
IMEInputHandler
:
:
GetIMENotificationRequests
(
)
{
return
IMENotificationRequests
(
)
;
}
NS_IMETHODIMP_
(
void
)
IMEInputHandler
:
:
OnRemovedFrom
(
TextEventDispatcher
*
aTextEventDispatcher
)
{
}
NS_IMETHODIMP_
(
void
)
IMEInputHandler
:
:
WillDispatchKeyboardEvent
(
TextEventDispatcher
*
aTextEventDispatcher
WidgetKeyboardEvent
&
aKeyboardEvent
uint32_t
aIndexOfKeypress
void
*
aData
)
{
if
(
!
aData
)
{
return
;
}
KeyEventState
*
currentKeyEvent
=
static_cast
<
KeyEventState
*
>
(
aData
)
;
NSEvent
*
nativeEvent
=
currentKeyEvent
-
>
mKeyEvent
;
nsAString
*
insertString
=
currentKeyEvent
-
>
mInsertString
;
if
(
aKeyboardEvent
.
mMessage
=
=
eKeyPress
&
&
aIndexOfKeypress
=
=
0
&
&
(
!
insertString
|
|
insertString
-
>
IsEmpty
(
)
)
)
{
aKeyboardEvent
.
MarkAsWaitingReplyFromRemoteProcess
(
)
;
}
if
(
KeyboardLayoutOverrideRef
(
)
.
mOverrideEnabled
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByLayoutID
(
KeyboardLayoutOverrideRef
(
)
.
mKeyboardLayout
true
)
;
tis
.
WillDispatchKeyboardEvent
(
nativeEvent
insertString
aIndexOfKeypress
aKeyboardEvent
)
;
}
else
{
TISInputSourceWrapper
:
:
CurrentInputSource
(
)
.
WillDispatchKeyboardEvent
(
nativeEvent
insertString
aIndexOfKeypress
aKeyboardEvent
)
;
}
if
(
IsEditableContent
(
)
&
&
insertString
&
&
aKeyboardEvent
.
mMessage
=
=
eKeyPress
&
&
aKeyboardEvent
.
mCharCode
)
{
aKeyboardEvent
.
mModifiers
&
=
~
(
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
)
;
}
}
void
IMEInputHandler
:
:
NotifyIMEOfFocusChangeInGecko
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
NotifyIMEOfFocusChangeInGecko
"
"
Destroyed
(
)
=
%
s
IsFocused
(
)
=
%
s
inputContext
=
%
p
"
this
TrueOrFalse
(
Destroyed
(
)
)
TrueOrFalse
(
IsFocused
(
)
)
mView
?
[
mView
inputContext
]
:
nullptr
)
)
;
if
(
Destroyed
(
)
)
{
return
;
}
if
(
!
IsFocused
(
)
)
{
mPendingMethods
|
=
kNotifyIMEOfFocusChangeInGecko
;
return
;
}
MOZ_ASSERT
(
mView
)
;
NSTextInputContext
*
inputContext
=
[
mView
inputContext
]
;
NS_ENSURE_TRUE_VOID
(
inputContext
)
;
[
inputContext
deactivate
]
;
[
inputContext
activate
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
IMEInputHandler
:
:
SyncASCIICapableOnly
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SyncASCIICapableOnly
"
"
Destroyed
(
)
=
%
s
IsFocused
(
)
=
%
s
mIsASCIICapableOnly
=
%
s
"
"
GetCurrentTSMDocumentID
(
)
=
%
p
"
this
TrueOrFalse
(
Destroyed
(
)
)
TrueOrFalse
(
IsFocused
(
)
)
TrueOrFalse
(
mIsASCIICapableOnly
)
GetCurrentTSMDocumentID
(
)
)
)
;
if
(
Destroyed
(
)
)
{
return
;
}
if
(
!
IsFocused
(
)
)
{
mPendingMethods
|
=
kSyncASCIICapableOnly
;
return
;
}
TSMDocumentID
doc
=
GetCurrentTSMDocumentID
(
)
;
if
(
!
doc
)
{
mPendingMethods
|
=
kSyncASCIICapableOnly
;
NS_WARNING
(
"
Application
is
active
but
there
is
no
active
document
"
)
;
ResetTimer
(
)
;
return
;
}
if
(
mIsASCIICapableOnly
)
{
CFArrayRef
ASCIICapableTISList
=
:
:
TISCreateASCIICapableInputSourceList
(
)
;
:
:
TSMSetDocumentProperty
(
doc
kTSMDocumentEnabledInputSourcesPropertyTag
sizeof
(
CFArrayRef
)
&
ASCIICapableTISList
)
;
:
:
CFRelease
(
ASCIICapableTISList
)
;
}
else
{
:
:
TSMRemoveDocumentProperty
(
doc
kTSMDocumentEnabledInputSourcesPropertyTag
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
IMEInputHandler
:
:
ResetTimer
(
)
{
NS_ASSERTION
(
mPendingMethods
!
=
0
"
There
are
not
pending
methods
why
this
is
called
?
"
)
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
else
{
mTimer
=
NS_NewTimer
(
)
;
NS_ENSURE_TRUE
(
mTimer
)
;
}
mTimer
-
>
InitWithNamedFuncCallback
(
FlushPendingMethods
this
0
nsITimer
:
:
TYPE_ONE_SHOT
"
IMEInputHandler
:
:
FlushPendingMethods
"
)
;
}
void
IMEInputHandler
:
:
ExecutePendingMethods
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
if
(
!
[
[
NSApplication
sharedApplication
]
isActive
]
)
{
return
;
}
uint32_t
pendingMethods
=
mPendingMethods
;
mPendingMethods
=
0
;
if
(
pendingMethods
&
kSyncASCIICapableOnly
)
SyncASCIICapableOnly
(
)
;
if
(
pendingMethods
&
kNotifyIMEOfFocusChangeInGecko
)
{
NotifyIMEOfFocusChangeInGecko
(
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
#
pragma
mark
-
TextRangeType
IMEInputHandler
:
:
ConvertToTextRangeType
(
uint32_t
aUnderlineStyle
NSRange
&
aSelectedRange
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
ConvertToTextRangeType
"
"
aUnderlineStyle
=
%
u
aSelectedRange
.
length
=
%
lu
"
this
aUnderlineStyle
static_cast
<
unsigned
long
>
(
aSelectedRange
.
length
)
)
)
;
if
(
aSelectedRange
.
length
=
=
0
)
{
switch
(
aUnderlineStyle
)
{
case
NSUnderlineStyleSingle
:
return
TextRangeType
:
:
eRawClause
;
case
NSUnderlineStyleThick
:
return
TextRangeType
:
:
eSelectedRawClause
;
default
:
NS_WARNING
(
"
Unexpected
line
style
"
)
;
return
TextRangeType
:
:
eSelectedRawClause
;
}
}
switch
(
aUnderlineStyle
)
{
case
NSUnderlineStyleSingle
:
return
TextRangeType
:
:
eConvertedClause
;
case
NSUnderlineStyleThick
:
return
TextRangeType
:
:
eSelectedClause
;
default
:
NS_WARNING
(
"
Unexpected
line
style
"
)
;
return
TextRangeType
:
:
eSelectedClause
;
}
}
uint32_t
IMEInputHandler
:
:
GetRangeCount
(
NSAttributedString
*
aAttrString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
uint32_t
count
=
0
;
NSRange
effectiveRange
;
NSRange
limitRange
=
NSMakeRange
(
0
[
aAttrString
length
]
)
;
while
(
limitRange
.
length
>
0
)
{
[
aAttrString
attribute
:
NSUnderlineStyleAttributeName
atIndex
:
limitRange
.
location
longestEffectiveRange
:
&
effectiveRange
inRange
:
limitRange
]
;
limitRange
=
NSMakeRange
(
NSMaxRange
(
effectiveRange
)
NSMaxRange
(
limitRange
)
-
NSMaxRange
(
effectiveRange
)
)
;
count
+
+
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
GetRangeCount
aAttrString
=
\
"
%
s
\
"
count
=
%
u
"
this
GetCharacters
(
[
aAttrString
string
]
)
count
)
)
;
return
count
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
0
)
;
}
already_AddRefed
<
mozilla
:
:
TextRangeArray
>
IMEInputHandler
:
:
CreateTextRangeArray
(
NSAttributedString
*
aAttrString
NSRange
&
aSelectedRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
RefPtr
<
mozilla
:
:
TextRangeArray
>
textRangeArray
=
new
mozilla
:
:
TextRangeArray
(
)
;
if
(
!
[
aAttrString
length
]
)
{
return
textRangeArray
.
forget
(
)
;
}
NSRange
limitRange
=
NSMakeRange
(
0
[
aAttrString
length
]
)
;
uint32_t
rangeCount
=
GetRangeCount
(
aAttrString
)
;
for
(
uint32_t
i
=
0
;
i
<
rangeCount
&
&
limitRange
.
length
>
0
;
i
+
+
)
{
NSRange
effectiveRange
;
id
attributeValue
=
[
aAttrString
attribute
:
NSUnderlineStyleAttributeName
atIndex
:
limitRange
.
location
longestEffectiveRange
:
&
effectiveRange
inRange
:
limitRange
]
;
TextRange
range
;
range
.
mStartOffset
=
effectiveRange
.
location
;
range
.
mEndOffset
=
NSMaxRange
(
effectiveRange
)
;
range
.
mRangeType
=
ConvertToTextRangeType
(
[
attributeValue
intValue
]
aSelectedRange
)
;
textRangeArray
-
>
AppendElement
(
range
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
CreateTextRangeArray
"
"
range
=
{
mStartOffset
=
%
u
mEndOffset
=
%
u
mRangeType
=
%
s
}
"
this
range
.
mStartOffset
range
.
mEndOffset
ToChar
(
range
.
mRangeType
)
)
)
;
limitRange
=
NSMakeRange
(
NSMaxRange
(
effectiveRange
)
NSMaxRange
(
limitRange
)
-
NSMaxRange
(
effectiveRange
)
)
;
}
TextRange
range
;
range
.
mStartOffset
=
aSelectedRange
.
location
+
aSelectedRange
.
length
;
range
.
mEndOffset
=
range
.
mStartOffset
;
range
.
mRangeType
=
TextRangeType
:
:
eCaret
;
textRangeArray
-
>
AppendElement
(
range
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
CreateTextRangeArray
"
"
range
=
{
mStartOffset
=
%
u
mEndOffset
=
%
u
mRangeType
=
%
s
}
"
this
range
.
mStartOffset
range
.
mEndOffset
ToChar
(
range
.
mRangeType
)
)
)
;
return
textRangeArray
.
forget
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL
;
}
bool
IMEInputHandler
:
:
DispatchCompositionStartEvent
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionStartEvent
"
"
mSelectedRange
=
{
location
=
%
lu
length
=
%
lu
}
Destroyed
(
)
=
%
s
"
"
mView
=
%
p
mWidget
=
%
p
inputContext
=
%
p
mIsIMEComposing
=
%
s
"
this
static_cast
<
unsigned
long
>
(
SelectedRange
(
)
.
location
)
static_cast
<
unsigned
long
>
(
mSelectedRange
.
length
)
TrueOrFalse
(
Destroyed
(
)
)
mView
mWidget
mView
?
[
mView
inputContext
]
:
nullptr
TrueOrFalse
(
mIsIMEComposing
)
)
)
;
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionStartEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
NS_ASSERTION
(
!
mIsIMEComposing
"
There
is
a
composition
already
"
)
;
mIsIMEComposing
=
true
;
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
mIsDeadKeyComposing
=
currentKeyEvent
&
&
currentKeyEvent
-
>
mKeyEvent
&
&
TISInputSourceWrapper
:
:
CurrentInputSource
(
)
.
IsDeadKey
(
currentKeyEvent
-
>
mKeyEvent
)
;
nsEventStatus
status
;
rv
=
mDispatcher
-
>
StartComposition
(
status
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionStartEvent
"
"
FAILED
due
to
StartComposition
(
)
failure
"
this
)
)
;
return
false
;
}
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionStartEvent
"
"
destroyed
by
compositionstart
event
"
this
)
)
;
return
false
;
}
if
(
!
mIsIMEComposing
)
{
return
false
;
}
mIMECompositionStart
=
SelectedRange
(
)
.
location
;
return
true
;
}
bool
IMEInputHandler
:
:
DispatchCompositionChangeEvent
(
const
nsString
&
aText
NSAttributedString
*
aAttrString
NSRange
&
aSelectedRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionChangeEvent
"
"
aText
=
\
"
%
s
\
"
aAttrString
=
\
"
%
s
\
"
"
"
aSelectedRange
=
{
location
=
%
lu
length
=
%
lu
}
Destroyed
(
)
=
%
s
mView
=
%
p
"
"
mWidget
=
%
p
inputContext
=
%
p
mIsIMEComposing
=
%
s
"
this
NS_ConvertUTF16toUTF8
(
aText
)
.
get
(
)
GetCharacters
(
[
aAttrString
string
]
)
static_cast
<
unsigned
long
>
(
aSelectedRange
.
location
)
static_cast
<
unsigned
long
>
(
aSelectedRange
.
length
)
TrueOrFalse
(
Destroyed
(
)
)
mView
mWidget
mView
?
[
mView
inputContext
]
:
nullptr
TrueOrFalse
(
mIsIMEComposing
)
)
)
;
NS_ENSURE_TRUE
(
!
Destroyed
(
)
false
)
;
NS_ASSERTION
(
mIsIMEComposing
"
We
'
re
not
in
composition
"
)
;
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionChangeEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
RefPtr
<
TextRangeArray
>
rangeArray
=
CreateTextRangeArray
(
aAttrString
aSelectedRange
)
;
rv
=
mDispatcher
-
>
SetPendingComposition
(
aText
rangeArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionChangeEvent
"
"
FAILED
due
to
SetPendingComposition
(
)
failure
"
this
)
)
;
return
false
;
}
mSelectedRange
.
location
=
mIMECompositionStart
+
aSelectedRange
.
location
;
mSelectedRange
.
length
=
aSelectedRange
.
length
;
if
(
mIMECompositionString
)
{
[
mIMECompositionString
release
]
;
}
mIMECompositionString
=
[
[
aAttrString
string
]
retain
]
;
nsEventStatus
status
;
rv
=
mDispatcher
-
>
FlushPendingComposition
(
status
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionChangeEvent
"
"
FAILED
due
to
FlushPendingComposition
(
)
failure
"
this
)
)
;
return
false
;
}
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionChangeEvent
"
"
destroyed
by
compositionchange
event
"
this
)
)
;
return
false
;
}
return
mIsIMEComposing
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
bool
IMEInputHandler
:
:
DispatchCompositionCommitEvent
(
const
nsAString
*
aCommitString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionCommitEvent
"
"
aCommitString
=
0x
%
p
(
\
"
%
s
\
"
)
Destroyed
(
)
=
%
s
mView
=
%
p
mWidget
=
%
p
"
"
inputContext
=
%
p
mIsIMEComposing
=
%
s
"
this
aCommitString
aCommitString
?
NS_ConvertUTF16toUTF8
(
*
aCommitString
)
.
get
(
)
:
"
"
TrueOrFalse
(
Destroyed
(
)
)
mView
mWidget
mView
?
[
mView
inputContext
]
:
nullptr
TrueOrFalse
(
mIsIMEComposing
)
)
)
;
NS_ASSERTION
(
mIsIMEComposing
"
We
'
re
not
in
composition
"
)
;
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
!
Destroyed
(
)
)
{
mSelectedRange
.
location
=
mIMECompositionStart
;
if
(
aCommitString
)
{
mSelectedRange
.
location
+
=
aCommitString
-
>
Length
(
)
;
}
else
if
(
mIMECompositionString
)
{
nsAutoString
commitString
;
nsCocoaUtils
:
:
GetStringForNSString
(
mIMECompositionString
commitString
)
;
mSelectedRange
.
location
+
=
commitString
.
Length
(
)
;
}
mSelectedRange
.
length
=
0
;
nsresult
rv
=
mDispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionCommitEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
}
else
{
nsEventStatus
status
;
rv
=
mDispatcher
-
>
CommitComposition
(
status
aCommitString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionCommitEvent
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
}
}
}
mIsIMEComposing
=
mIsDeadKeyComposing
=
false
;
mIMECompositionStart
=
UINT32_MAX
;
if
(
mIMECompositionString
)
{
[
mIMECompositionString
release
]
;
mIMECompositionString
=
nullptr
;
}
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
DispatchCompositionCommitEvent
"
"
destroyed
by
compositioncommit
event
"
this
)
)
;
return
false
;
}
return
true
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
bool
IMEInputHandler
:
:
MaybeDispatchCurrentKeydownEvent
(
bool
aIsProcessedByIME
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
Destroyed
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mWidget
)
;
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
if
(
!
currentKeyEvent
|
|
!
currentKeyEvent
-
>
CanDispatchKeyDownEvent
(
)
)
{
return
true
;
}
NSEvent
*
nativeEvent
=
currentKeyEvent
-
>
mKeyEvent
;
if
(
NS_WARN_IF
(
!
nativeEvent
)
|
|
[
nativeEvent
type
]
!
=
NSKeyDown
)
{
return
true
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
MaybeDispatchKeydownEvent
aIsProcessedByIME
=
%
s
"
"
currentKeyEvent
=
{
mKeyEvent
(
%
p
)
=
{
type
=
%
s
keyCode
=
%
s
(
0x
%
X
)
}
}
"
"
aIsProcessedBy
=
%
s
IsDeadKeyComposing
(
)
=
%
s
"
this
TrueOrFalse
(
aIsProcessedByIME
)
nativeEvent
GetNativeKeyEventType
(
nativeEvent
)
GetKeyNameForNativeKeyCode
(
[
nativeEvent
keyCode
]
)
[
nativeEvent
keyCode
]
TrueOrFalse
(
IsIMEComposing
(
)
)
TrueOrFalse
(
IsDeadKeyComposing
(
)
)
)
)
;
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
RefPtr
<
TextEventDispatcher
>
dispatcher
(
mDispatcher
)
;
nsresult
rv
=
dispatcher
-
>
BeginNativeInputTransaction
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Error
(
"
%
p
IMEInputHandler
:
:
DispatchKeyEventForFlagsChanged
"
"
FAILED
due
to
BeginNativeInputTransaction
(
)
failure
"
this
)
)
;
return
false
;
}
NSResponder
*
firstResponder
=
[
[
mView
window
]
firstResponder
]
;
currentKeyEvent
-
>
mKeyDownDispatched
=
true
;
RefPtr
<
nsChildView
>
widget
(
mWidget
)
;
WidgetKeyboardEvent
keydownEvent
(
true
eKeyDown
widget
)
;
currentKeyEvent
-
>
InitKeyEvent
(
this
keydownEvent
aIsProcessedByIME
&
&
!
IsDeadKeyComposing
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
dispatcher
-
>
DispatchKeyboardEvent
(
eKeyDown
keydownEvent
status
currentKeyEvent
)
;
currentKeyEvent
-
>
mKeyDownHandled
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
Destroyed
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
MaybeDispatchKeydownEvent
"
"
widget
was
destroyed
by
keydown
event
"
this
)
)
;
return
false
;
}
if
(
firstResponder
!
=
[
[
mView
window
]
firstResponder
]
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
MaybeDispatchKeydownEvent
"
"
view
lost
focus
by
keydown
event
"
this
)
)
;
CommitIMEComposition
(
)
;
return
false
;
}
return
true
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
void
IMEInputHandler
:
:
InsertTextAsCommittingComposition
(
NSAttributedString
*
aAttrString
NSRange
*
aReplacementRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertTextAsCommittingComposition
"
"
aAttrString
=
\
"
%
s
\
"
aReplacementRange
=
%
p
{
location
=
%
lu
length
=
%
lu
}
"
"
Destroyed
(
)
=
%
s
IsIMEComposing
(
)
=
%
s
"
"
mMarkedRange
=
{
location
=
%
lu
length
=
%
lu
}
"
this
GetCharacters
(
[
aAttrString
string
]
)
aReplacementRange
static_cast
<
unsigned
long
>
(
aReplacementRange
?
aReplacementRange
-
>
location
:
0
)
static_cast
<
unsigned
long
>
(
aReplacementRange
?
aReplacementRange
-
>
length
:
0
)
TrueOrFalse
(
Destroyed
(
)
)
TrueOrFalse
(
IsIMEComposing
(
)
)
static_cast
<
unsigned
long
>
(
mMarkedRange
.
location
)
static_cast
<
unsigned
long
>
(
mMarkedRange
.
length
)
)
)
;
if
(
IgnoreIMECommit
(
)
)
{
MOZ_CRASH
(
"
IMEInputHandler
:
:
InsertTextAsCommittingComposition
(
)
must
not
"
"
be
called
while
canceling
the
composition
"
)
;
}
if
(
Destroyed
(
)
)
{
return
;
}
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
!
IsIMEComposing
(
)
&
&
!
MaybeDispatchCurrentKeydownEvent
(
false
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertTextAsCommittingComposition
eKeyDown
"
"
caused
focus
move
or
something
and
canceling
the
composition
"
this
)
)
;
return
;
}
if
(
IsIMEComposing
(
)
&
&
aReplacementRange
&
&
aReplacementRange
-
>
location
!
=
NSNotFound
&
&
!
NSEqualRanges
(
MarkedRange
(
)
*
aReplacementRange
)
)
{
if
(
!
DispatchCompositionCommitEvent
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertTextAsCommittingComposition
"
"
destroyed
by
commiting
composition
for
setting
replacement
range
"
this
)
)
;
return
;
}
}
nsString
str
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
aAttrString
string
]
str
)
;
if
(
!
IsIMEComposing
(
)
)
{
if
(
aReplacementRange
&
&
aReplacementRange
-
>
location
!
=
NSNotFound
&
&
!
NSEqualRanges
(
SelectedRange
(
)
*
aReplacementRange
)
)
{
NS_ENSURE_TRUE_VOID
(
SetSelection
(
*
aReplacementRange
)
)
;
}
if
(
!
DispatchCompositionStartEvent
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertTextAsCommittingComposition
"
"
cannot
continue
handling
composition
after
compositionstart
"
this
)
)
;
return
;
}
}
if
(
!
DispatchCompositionCommitEvent
(
&
str
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
InsertTextAsCommittingComposition
"
"
destroyed
by
compositioncommit
event
"
this
)
)
;
return
;
}
mMarkedRange
=
NSMakeRange
(
NSNotFound
0
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
IMEInputHandler
:
:
SetMarkedText
(
NSAttributedString
*
aAttrString
NSRange
&
aSelectedRange
NSRange
*
aReplacementRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
KeyEventState
*
currentKeyEvent
=
GetCurrentKeyEvent
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
"
"
aAttrString
=
\
"
%
s
\
"
aSelectedRange
=
{
location
=
%
lu
length
=
%
lu
}
"
"
aReplacementRange
=
%
p
{
location
=
%
lu
length
=
%
lu
}
"
"
Destroyed
(
)
=
%
s
IsIMEComposing
(
)
=
%
s
"
"
mMarkedRange
=
{
location
=
%
lu
length
=
%
lu
}
keyevent
=
%
p
"
"
keydownDispatched
=
%
s
keydownHandled
=
%
s
"
"
keypressDispatched
=
%
s
causedOtherKeyEvents
=
%
s
"
"
compositionDispatched
=
%
s
"
this
GetCharacters
(
[
aAttrString
string
]
)
static_cast
<
unsigned
long
>
(
aSelectedRange
.
location
)
static_cast
<
unsigned
long
>
(
aSelectedRange
.
length
)
aReplacementRange
static_cast
<
unsigned
long
>
(
aReplacementRange
?
aReplacementRange
-
>
location
:
0
)
static_cast
<
unsigned
long
>
(
aReplacementRange
?
aReplacementRange
-
>
length
:
0
)
TrueOrFalse
(
Destroyed
(
)
)
TrueOrFalse
(
IsIMEComposing
(
)
)
static_cast
<
unsigned
long
>
(
mMarkedRange
.
location
)
static_cast
<
unsigned
long
>
(
mMarkedRange
.
length
)
currentKeyEvent
?
currentKeyEvent
-
>
mKeyEvent
:
nullptr
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyDownHandled
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mKeyPressDispatched
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCausedOtherKeyEvents
)
:
"
N
/
A
"
currentKeyEvent
?
TrueOrFalse
(
currentKeyEvent
-
>
mCompositionDispatched
)
:
"
N
/
A
"
)
)
;
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
if
(
currentKeyEvent
)
{
currentKeyEvent
-
>
mCompositionDispatched
=
true
;
if
(
!
IsIMEComposing
(
)
&
&
!
MaybeDispatchCurrentKeydownEvent
(
true
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
eKeyDown
caused
focus
move
or
"
"
something
and
canceling
the
composition
"
this
)
)
;
return
;
}
}
if
(
Destroyed
(
)
)
{
return
;
}
if
(
IsIMEComposing
(
)
&
&
aReplacementRange
&
&
aReplacementRange
-
>
location
!
=
NSNotFound
&
&
!
NSEqualRanges
(
MarkedRange
(
)
*
aReplacementRange
)
)
{
AutoRestore
<
bool
>
ignoreIMECommit
(
mIgnoreIMECommit
)
;
mIgnoreIMECommit
=
false
;
if
(
!
DispatchCompositionCommitEvent
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
"
"
destroyed
by
commiting
composition
for
setting
replacement
range
"
this
)
)
;
return
;
}
}
nsString
str
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
aAttrString
string
]
str
)
;
mMarkedRange
.
length
=
str
.
Length
(
)
;
if
(
!
IsIMEComposing
(
)
&
&
!
str
.
IsEmpty
(
)
)
{
if
(
aReplacementRange
&
&
aReplacementRange
-
>
location
!
=
NSNotFound
&
&
!
NSEqualRanges
(
SelectedRange
(
)
*
aReplacementRange
)
)
{
mSelectedRange
=
*
aReplacementRange
;
if
(
NS_WARN_IF
(
!
SetSelection
(
*
aReplacementRange
)
)
)
{
mSelectedRange
.
location
=
NSNotFound
;
return
;
}
}
mMarkedRange
.
location
=
SelectedRange
(
)
.
location
;
if
(
!
DispatchCompositionStartEvent
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
cannot
continue
handling
"
"
composition
after
dispatching
compositionstart
"
this
)
)
;
return
;
}
}
if
(
!
str
.
IsEmpty
(
)
)
{
if
(
!
DispatchCompositionChangeEvent
(
str
aAttrString
aSelectedRange
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
cannot
continue
handling
"
"
composition
after
dispatching
compositionchange
"
this
)
)
;
}
return
;
}
if
(
!
DispatchCompositionCommitEvent
(
&
EmptyString
(
)
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SetMarkedText
"
"
destroyed
by
compositioncommit
event
"
this
)
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
NSAttributedString
*
IMEInputHandler
:
:
GetAttributedSubstringFromRange
(
NSRange
&
aRange
NSRange
*
aActualRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
GetAttributedSubstringFromRange
"
"
aRange
=
{
location
=
%
lu
length
=
%
lu
}
aActualRange
=
%
p
Destroyed
(
)
=
%
s
"
this
static_cast
<
unsigned
long
>
(
aRange
.
location
)
static_cast
<
unsigned
long
>
(
aRange
.
length
)
aActualRange
TrueOrFalse
(
Destroyed
(
)
)
)
)
;
if
(
aActualRange
)
{
*
aActualRange
=
NSMakeRange
(
NSNotFound
0
)
;
}
if
(
Destroyed
(
)
|
|
aRange
.
location
=
=
NSNotFound
|
|
aRange
.
length
=
=
0
)
{
return
nil
;
}
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
NSUInteger
compositionLength
=
mIMECompositionString
?
[
mIMECompositionString
length
]
:
0
;
if
(
mIMECompositionStart
!
=
UINT32_MAX
&
&
mIMECompositionStart
>
=
aRange
.
location
&
&
mIMECompositionStart
+
compositionLength
<
=
aRange
.
location
+
aRange
.
length
)
{
NSRange
range
=
NSMakeRange
(
aRange
.
location
-
mIMECompositionStart
aRange
.
length
)
;
NSString
*
nsstr
=
[
mIMECompositionString
substringWithRange
:
range
]
;
NSMutableAttributedString
*
result
=
[
[
[
NSMutableAttributedString
alloc
]
initWithString
:
nsstr
attributes
:
nil
]
autorelease
]
;
if
(
aActualRange
)
{
*
aActualRange
=
aRange
;
}
if
(
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Info
)
)
{
nsAutoString
str
;
nsCocoaUtils
:
:
GetStringForNSString
(
nsstr
str
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
GetAttributedSubstringFromRange
"
"
computed
with
mIMECompositionString
(
result
string
=
\
"
%
s
\
"
)
"
this
NS_ConvertUTF16toUTF8
(
str
)
.
get
(
)
)
)
;
}
return
result
;
}
nsAutoString
str
;
WidgetQueryContentEvent
queryTextContentEvent
(
true
eQueryTextContent
mWidget
)
;
WidgetQueryContentEvent
:
:
Options
options
;
int64_t
startOffset
=
aRange
.
location
;
if
(
IsIMEComposing
(
)
)
{
options
.
mRelativeToInsertionPoint
=
true
;
startOffset
-
=
mIMECompositionStart
;
}
queryTextContentEvent
.
InitForQueryTextContent
(
startOffset
aRange
.
length
options
)
;
queryTextContentEvent
.
RequestFontRanges
(
)
;
DispatchEvent
(
queryTextContentEvent
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
GetAttributedSubstringFromRange
"
"
queryTextContentEvent
=
{
mReply
=
%
s
}
"
this
ToString
(
queryTextContentEvent
.
mReply
)
.
c_str
(
)
)
)
;
if
(
queryTextContentEvent
.
Failed
(
)
)
{
return
nil
;
}
NSMutableAttributedString
*
result
=
nsCocoaUtils
:
:
GetNSMutableAttributedString
(
queryTextContentEvent
.
mReply
-
>
DataRef
(
)
queryTextContentEvent
.
mReply
-
>
mFontRanges
false
mWidget
-
>
BackingScaleFactor
(
)
)
;
if
(
aActualRange
)
{
*
aActualRange
=
MakeNSRangeFrom
(
queryTextContentEvent
.
mReply
-
>
mOffsetAndData
)
;
}
return
result
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
bool
IMEInputHandler
:
:
HasMarkedText
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
HasMarkedText
"
"
mMarkedRange
=
{
location
=
%
lu
length
=
%
lu
}
"
this
static_cast
<
unsigned
long
>
(
mMarkedRange
.
location
)
static_cast
<
unsigned
long
>
(
mMarkedRange
.
length
)
)
)
;
return
(
mMarkedRange
.
location
!
=
NSNotFound
)
&
&
(
mMarkedRange
.
length
!
=
0
)
;
}
NSRange
IMEInputHandler
:
:
MarkedRange
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
MarkedRange
"
"
mMarkedRange
=
{
location
=
%
lu
length
=
%
lu
}
"
this
static_cast
<
unsigned
long
>
(
mMarkedRange
.
location
)
static_cast
<
unsigned
long
>
(
mMarkedRange
.
length
)
)
)
;
if
(
!
HasMarkedText
(
)
)
{
return
NSMakeRange
(
NSNotFound
0
)
;
}
return
mMarkedRange
;
}
NSRange
IMEInputHandler
:
:
SelectedRange
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SelectedRange
Destroyed
(
)
=
%
s
mSelectedRange
=
{
"
"
location
=
%
lu
length
=
%
lu
}
"
this
TrueOrFalse
(
Destroyed
(
)
)
static_cast
<
unsigned
long
>
(
mSelectedRange
.
location
)
static_cast
<
unsigned
long
>
(
mSelectedRange
.
length
)
)
)
;
if
(
Destroyed
(
)
)
{
return
mSelectedRange
;
}
if
(
mSelectedRange
.
location
!
=
NSNotFound
)
{
MOZ_ASSERT
(
mIMEHasFocus
)
;
return
mSelectedRange
;
}
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
WidgetQueryContentEvent
querySelectedTextEvent
(
true
eQuerySelectedText
mWidget
)
;
DispatchEvent
(
querySelectedTextEvent
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SelectedRange
querySelectedTextEvent
=
{
mReply
=
%
s
}
"
this
ToString
(
querySelectedTextEvent
.
mReply
)
.
c_str
(
)
)
)
;
if
(
querySelectedTextEvent
.
Failed
(
)
)
{
return
mSelectedRange
;
}
mWritingMode
=
querySelectedTextEvent
.
mReply
-
>
WritingModeRef
(
)
;
mRangeForWritingMode
=
MakeNSRangeFrom
(
querySelectedTextEvent
.
mReply
-
>
mOffsetAndData
)
;
if
(
mIMEHasFocus
)
{
mSelectedRange
=
mRangeForWritingMode
;
}
return
mRangeForWritingMode
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
mSelectedRange
)
;
}
bool
IMEInputHandler
:
:
DrawsVerticallyForCharacterAtIndex
(
uint32_t
aCharIndex
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
if
(
Destroyed
(
)
)
{
return
false
;
}
if
(
mRangeForWritingMode
.
location
=
=
NSNotFound
)
{
SelectedRange
(
)
;
}
if
(
aCharIndex
<
mRangeForWritingMode
.
location
|
|
aCharIndex
>
mRangeForWritingMode
.
location
+
mRangeForWritingMode
.
length
)
{
NS_WARNING
(
"
DrawsVerticallyForCharacterAtIndex
not
using
cached
writing
mode
"
)
;
NSRange
range
=
NSMakeRange
(
aCharIndex
1
)
;
NSRange
actualRange
;
FirstRectForCharacterRange
(
range
&
actualRange
)
;
}
return
mWritingMode
.
IsVertical
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
NSRect
IMEInputHandler
:
:
FirstRectForCharacterRange
(
NSRange
&
aRange
NSRange
*
aActualRange
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
FirstRectForCharacterRange
Destroyed
(
)
=
%
s
"
"
aRange
=
{
location
=
%
lu
length
=
%
lu
}
aActualRange
=
%
p
}
"
this
TrueOrFalse
(
Destroyed
(
)
)
static_cast
<
unsigned
long
>
(
aRange
.
location
)
static_cast
<
unsigned
long
>
(
aRange
.
length
)
aActualRange
)
)
;
NSRect
rect
=
NSMakeRect
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
NSRange
actualRange
=
NSMakeRange
(
NSNotFound
0
)
;
if
(
aActualRange
)
{
*
aActualRange
=
actualRange
;
}
if
(
Destroyed
(
)
|
|
aRange
.
location
=
=
NSNotFound
)
{
return
rect
;
}
RefPtr
<
IMEInputHandler
>
kungFuDeathGrip
(
this
)
;
LayoutDeviceIntRect
r
;
bool
useCaretRect
=
(
aRange
.
length
=
=
0
)
;
if
(
!
useCaretRect
)
{
WidgetQueryContentEvent
queryTextRectEvent
(
true
eQueryTextRect
mWidget
)
;
WidgetQueryContentEvent
:
:
Options
options
;
int64_t
startOffset
=
aRange
.
location
;
if
(
IsIMEComposing
(
)
)
{
options
.
mRelativeToInsertionPoint
=
true
;
startOffset
-
=
mIMECompositionStart
;
}
queryTextRectEvent
.
InitForQueryTextRect
(
startOffset
1
options
)
;
DispatchEvent
(
queryTextRectEvent
)
;
if
(
queryTextRectEvent
.
Succeeded
(
)
)
{
r
=
queryTextRectEvent
.
mReply
-
>
mRect
;
actualRange
=
MakeNSRangeFrom
(
queryTextRectEvent
.
mReply
-
>
mOffsetAndData
)
;
mWritingMode
=
queryTextRectEvent
.
mReply
-
>
WritingModeRef
(
)
;
mRangeForWritingMode
=
actualRange
;
}
else
{
useCaretRect
=
true
;
}
}
if
(
useCaretRect
)
{
WidgetQueryContentEvent
queryCaretRectEvent
(
true
eQueryCaretRect
mWidget
)
;
WidgetQueryContentEvent
:
:
Options
options
;
int64_t
startOffset
=
aRange
.
location
;
if
(
IsIMEComposing
(
)
)
{
options
.
mRelativeToInsertionPoint
=
true
;
startOffset
-
=
mIMECompositionStart
;
}
queryCaretRectEvent
.
InitForQueryCaretRect
(
startOffset
options
)
;
DispatchEvent
(
queryCaretRectEvent
)
;
if
(
queryCaretRectEvent
.
Failed
(
)
)
{
return
rect
;
}
r
=
queryCaretRectEvent
.
mReply
-
>
mRect
;
r
.
width
=
0
;
actualRange
.
location
=
queryCaretRectEvent
.
mReply
-
>
StartOffset
(
)
;
actualRange
.
length
=
0
;
}
nsIWidget
*
rootWidget
=
mWidget
-
>
GetTopLevelWidget
(
)
;
NSWindow
*
rootWindow
=
static_cast
<
NSWindow
*
>
(
rootWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
NSView
*
rootView
=
static_cast
<
NSView
*
>
(
rootWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
if
(
!
rootWindow
|
|
!
rootView
)
{
return
rect
;
}
rect
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
r
mWidget
-
>
BackingScaleFactor
(
)
)
;
rect
=
[
rootView
convertRect
:
rect
toView
:
nil
]
;
rect
.
origin
=
nsCocoaUtils
:
:
ConvertPointToScreen
(
rootWindow
rect
.
origin
)
;
if
(
aActualRange
)
{
*
aActualRange
=
actualRange
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
FirstRectForCharacterRange
"
"
useCaretRect
=
%
s
rect
=
{
x
=
%
f
y
=
%
f
width
=
%
f
height
=
%
f
}
"
"
actualRange
=
{
location
=
%
lu
length
=
%
lu
}
"
this
TrueOrFalse
(
useCaretRect
)
rect
.
origin
.
x
rect
.
origin
.
y
rect
.
size
.
width
rect
.
size
.
height
static_cast
<
unsigned
long
>
(
actualRange
.
location
)
static_cast
<
unsigned
long
>
(
actualRange
.
length
)
)
)
;
return
rect
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NSMakeRect
(
0
.
0
0
.
0
0
.
0
0
.
0
)
)
;
}
NSUInteger
IMEInputHandler
:
:
CharacterIndexForPoint
(
NSPoint
&
aPoint
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
CharacterIndexForPoint
aPoint
=
{
x
=
%
f
y
=
%
f
}
"
this
aPoint
.
x
aPoint
.
y
)
)
;
NSWindow
*
mainWindow
=
[
NSApp
mainWindow
]
;
if
(
!
mWidget
|
|
!
mainWindow
)
{
return
NSNotFound
;
}
WidgetQueryContentEvent
queryCharAtPointEvent
(
true
eQueryCharacterAtPoint
mWidget
)
;
NSPoint
ptInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
mainWindow
aPoint
)
;
NSPoint
ptInView
=
[
mView
convertPoint
:
ptInWindow
fromView
:
nil
]
;
queryCharAtPointEvent
.
mRefPoint
.
x
=
static_cast
<
int32_t
>
(
ptInView
.
x
)
*
mWidget
-
>
BackingScaleFactor
(
)
;
queryCharAtPointEvent
.
mRefPoint
.
y
=
static_cast
<
int32_t
>
(
ptInView
.
y
)
*
mWidget
-
>
BackingScaleFactor
(
)
;
mWidget
-
>
DispatchWindowEvent
(
queryCharAtPointEvent
)
;
if
(
queryCharAtPointEvent
.
Failed
(
)
|
|
queryCharAtPointEvent
.
DidNotFindChar
(
)
|
|
queryCharAtPointEvent
.
mReply
-
>
StartOffset
(
)
>
=
static_cast
<
uint32_t
>
(
NSNotFound
)
)
{
return
NSNotFound
;
}
return
queryCharAtPointEvent
.
mReply
-
>
StartOffset
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NSNotFound
)
;
}
extern
"
C
"
{
extern
NSString
*
NSTextInputReplacementRangeAttributeName
;
}
NSArray
*
IMEInputHandler
:
:
GetValidAttributesForMarkedText
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
GetValidAttributesForMarkedText
"
this
)
)
;
return
[
NSArray
arrayWithObjects
:
NSUnderlineStyleAttributeName
NSUnderlineColorAttributeName
NSMarkedClauseSegmentAttributeName
NSTextInputReplacementRangeAttributeName
nil
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
#
pragma
mark
-
IMEInputHandler
:
:
IMEInputHandler
(
nsChildView
*
aWidget
NSView
<
mozView
>
*
aNativeView
)
:
TextInputHandlerBase
(
aWidget
aNativeView
)
mPendingMethods
(
0
)
mIMECompositionString
(
nullptr
)
mIMECompositionStart
(
UINT32_MAX
)
mRangeForWritingMode
(
)
mIsIMEComposing
(
false
)
mIsDeadKeyComposing
(
false
)
mIsIMEEnabled
(
true
)
mIsASCIICapableOnly
(
false
)
mIgnoreIMECommit
(
false
)
mIMEHasFocus
(
false
)
{
InitStaticMembers
(
)
;
mMarkedRange
.
location
=
NSNotFound
;
mMarkedRange
.
length
=
0
;
mSelectedRange
.
location
=
NSNotFound
;
mSelectedRange
.
length
=
0
;
}
IMEInputHandler
:
:
~
IMEInputHandler
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
if
(
sFocusedIMEHandler
=
=
this
)
{
sFocusedIMEHandler
=
nullptr
;
}
if
(
mIMECompositionString
)
{
[
mIMECompositionString
release
]
;
mIMECompositionString
=
nullptr
;
}
}
void
IMEInputHandler
:
:
OnFocusChangeInGecko
(
bool
aFocus
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
OnFocusChangeInGecko
aFocus
=
%
s
Destroyed
(
)
=
%
s
"
"
sFocusedIMEHandler
=
%
p
"
this
TrueOrFalse
(
aFocus
)
TrueOrFalse
(
Destroyed
(
)
)
sFocusedIMEHandler
)
)
;
mSelectedRange
.
location
=
NSNotFound
;
mIMEHasFocus
=
aFocus
;
if
(
!
aFocus
)
{
if
(
sFocusedIMEHandler
=
=
this
)
sFocusedIMEHandler
=
nullptr
;
return
;
}
sFocusedIMEHandler
=
this
;
mPendingMethods
|
=
kNotifyIMEOfFocusChangeInGecko
;
ResetTimer
(
)
;
}
bool
IMEInputHandler
:
:
OnDestroyWidget
(
nsChildView
*
aDestroyingWidget
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
OnDestroyWidget
aDestroyingWidget
=
%
p
"
"
sFocusedIMEHandler
=
%
p
IsIMEComposing
(
)
=
%
s
"
this
aDestroyingWidget
sFocusedIMEHandler
TrueOrFalse
(
IsIMEComposing
(
)
)
)
)
;
if
(
sFocusedIMEHandler
&
&
sFocusedIMEHandler
!
=
this
)
{
sFocusedIMEHandler
-
>
OnDestroyWidget
(
aDestroyingWidget
)
;
}
if
(
!
TextInputHandlerBase
:
:
OnDestroyWidget
(
aDestroyingWidget
)
)
{
return
false
;
}
if
(
IsIMEComposing
(
)
)
{
CancelIMEComposition
(
)
;
}
mSelectedRange
.
location
=
NSNotFound
;
mIMEHasFocus
=
false
;
return
true
;
}
void
IMEInputHandler
:
:
SendCommittedText
(
NSString
*
aString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SendCommittedText
mView
=
%
p
mWidget
=
%
p
"
"
inputContext
=
%
p
mIsIMEComposing
=
%
s
"
this
mView
mWidget
mView
?
[
mView
inputContext
]
:
nullptr
TrueOrFalse
(
mIsIMEComposing
)
)
)
;
NS_ENSURE_TRUE
(
mWidget
)
;
if
(
!
mView
)
{
return
;
}
NSAttributedString
*
attrStr
=
[
[
NSAttributedString
alloc
]
initWithString
:
aString
]
;
if
(
[
mView
conformsToProtocol
:
protocol
(
NSTextInputClient
)
]
)
{
NSObject
<
NSTextInputClient
>
*
textInputClient
=
static_cast
<
NSObject
<
NSTextInputClient
>
*
>
(
mView
)
;
[
textInputClient
insertText
:
attrStr
replacementRange
:
NSMakeRange
(
NSNotFound
0
)
]
;
}
if
(
mIsIMEComposing
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
SendCommittedText
trying
to
insert
text
directly
"
"
due
to
IME
not
calling
our
InsertText
(
)
"
this
)
)
;
static_cast
<
TextInputHandler
*
>
(
this
)
-
>
InsertText
(
attrStr
)
;
MOZ_ASSERT
(
!
mIsIMEComposing
)
;
}
[
attrStr
release
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
IMEInputHandler
:
:
KillIMEComposition
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
KillIMEComposition
mView
=
%
p
mWidget
=
%
p
"
"
inputContext
=
%
p
mIsIMEComposing
=
%
s
"
"
Destroyed
(
)
=
%
s
IsFocused
(
)
=
%
s
"
this
mView
mWidget
mView
?
[
mView
inputContext
]
:
nullptr
TrueOrFalse
(
mIsIMEComposing
)
TrueOrFalse
(
Destroyed
(
)
)
TrueOrFalse
(
IsFocused
(
)
)
)
)
;
if
(
Destroyed
(
)
|
|
NS_WARN_IF
(
!
mView
)
)
{
return
;
}
NSTextInputContext
*
inputContext
=
[
mView
inputContext
]
;
if
(
NS_WARN_IF
(
!
inputContext
)
)
{
return
;
}
[
inputContext
discardMarkedText
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
IMEInputHandler
:
:
CommitIMEComposition
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
CommitIMEComposition
mIMECompositionString
=
%
s
"
this
GetCharacters
(
mIMECompositionString
)
)
)
;
KillIMEComposition
(
)
;
if
(
!
IsIMEComposing
(
)
)
return
;
SendCommittedText
(
mIMECompositionString
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
IMEInputHandler
:
:
CancelIMEComposition
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
IsIMEComposing
(
)
)
return
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
CancelIMEComposition
mIMECompositionString
=
%
s
"
this
GetCharacters
(
mIMECompositionString
)
)
)
;
mIgnoreIMECommit
=
true
;
KillIMEComposition
(
)
;
mIgnoreIMECommit
=
false
;
if
(
!
IsIMEComposing
(
)
)
return
;
SendCommittedText
(
"
"
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
IMEInputHandler
:
:
IsFocused
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NS_ENSURE_TRUE
(
!
Destroyed
(
)
false
)
;
NSWindow
*
window
=
[
mView
window
]
;
NS_ENSURE_TRUE
(
window
false
)
;
return
[
window
firstResponder
]
=
=
mView
&
&
[
window
isKeyWindow
]
&
&
[
[
NSApplication
sharedApplication
]
isActive
]
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
false
)
;
}
bool
IMEInputHandler
:
:
IsIMEOpened
(
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByCurrentInputSource
(
)
;
return
tis
.
IsOpenedIMEMode
(
)
;
}
void
IMEInputHandler
:
:
SetASCIICapableOnly
(
bool
aASCIICapableOnly
)
{
if
(
aASCIICapableOnly
=
=
mIsASCIICapableOnly
)
return
;
CommitIMEComposition
(
)
;
mIsASCIICapableOnly
=
aASCIICapableOnly
;
SyncASCIICapableOnly
(
)
;
}
void
IMEInputHandler
:
:
EnableIME
(
bool
aEnableIME
)
{
if
(
aEnableIME
=
=
mIsIMEEnabled
)
return
;
CommitIMEComposition
(
)
;
mIsIMEEnabled
=
aEnableIME
;
}
void
IMEInputHandler
:
:
SetIMEOpenState
(
bool
aOpenIME
)
{
if
(
!
IsFocused
(
)
|
|
IsIMEOpened
(
)
=
=
aOpenIME
)
return
;
if
(
!
aOpenIME
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByCurrentASCIICapableInputSource
(
)
;
tis
.
Select
(
)
;
return
;
}
if
(
sLatestIMEOpenedModeInputSourceID
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByInputSourceID
(
sLatestIMEOpenedModeInputSourceID
)
;
tis
.
Select
(
)
;
return
;
}
static
bool
sIsPrefferredIMESearched
=
false
;
if
(
sIsPrefferredIMESearched
)
return
;
sIsPrefferredIMESearched
=
true
;
OpenSystemPreferredLanguageIME
(
)
;
}
void
IMEInputHandler
:
:
OpenSystemPreferredLanguageIME
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
OpenSystemPreferredLanguageIME
"
this
)
)
;
CFArrayRef
langList
=
:
:
CFLocaleCopyPreferredLanguages
(
)
;
if
(
!
langList
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
OpenSystemPreferredLanguageIME
langList
is
NULL
"
this
)
)
;
return
;
}
CFIndex
count
=
:
:
CFArrayGetCount
(
langList
)
;
for
(
CFIndex
i
=
0
;
i
<
count
;
i
+
+
)
{
CFLocaleRef
locale
=
:
:
CFLocaleCreate
(
kCFAllocatorDefault
static_cast
<
CFStringRef
>
(
:
:
CFArrayGetValueAtIndex
(
langList
i
)
)
)
;
if
(
!
locale
)
{
continue
;
}
bool
changed
=
false
;
CFStringRef
lang
=
static_cast
<
CFStringRef
>
(
:
:
CFLocaleGetValue
(
locale
kCFLocaleLanguageCode
)
)
;
NS_ASSERTION
(
lang
"
lang
is
null
"
)
;
if
(
lang
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByLanguage
(
lang
)
;
if
(
tis
.
IsOpenedIMEMode
(
)
)
{
if
(
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Info
)
)
{
CFStringRef
foundTIS
;
tis
.
GetInputSourceID
(
foundTIS
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
OpenSystemPreferredLanguageIME
"
"
foundTIS
=
%
s
lang
=
%
s
"
this
GetCharacters
(
foundTIS
)
GetCharacters
(
lang
)
)
)
;
}
tis
.
Select
(
)
;
changed
=
true
;
}
}
:
:
CFRelease
(
locale
)
;
if
(
changed
)
{
break
;
}
}
:
:
CFRelease
(
langList
)
;
}
void
IMEInputHandler
:
:
OnSelectionChange
(
const
IMENotification
&
aIMENotification
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
IMEInputHandler
:
:
OnSelectionChange
"
this
)
)
;
if
(
aIMENotification
.
mSelectionChangeData
.
mOffset
=
=
UINT32_MAX
)
{
mSelectedRange
.
location
=
NSNotFound
;
mSelectedRange
.
length
=
0
;
mRangeForWritingMode
.
location
=
NSNotFound
;
mRangeForWritingMode
.
length
=
0
;
return
;
}
mWritingMode
=
aIMENotification
.
mSelectionChangeData
.
GetWritingMode
(
)
;
mRangeForWritingMode
=
NSMakeRange
(
aIMENotification
.
mSelectionChangeData
.
mOffset
aIMENotification
.
mSelectionChangeData
.
Length
(
)
)
;
if
(
mIMEHasFocus
)
{
mSelectedRange
=
mRangeForWritingMode
;
}
}
void
IMEInputHandler
:
:
OnLayoutChange
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
!
IsFocused
(
)
)
{
return
;
}
NSTextInputContext
*
inputContext
=
[
mView
inputContext
]
;
[
inputContext
invalidateCharacterCoordinates
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
bool
IMEInputHandler
:
:
OnHandleEvent
(
NSEvent
*
aEvent
)
{
if
(
!
IsFocused
(
)
)
{
return
false
;
}
bool
allowConsumeEvent
=
true
;
if
(
nsCocoaFeatures
:
:
OnCatalinaOrLater
(
)
&
&
!
IsIMEComposing
(
)
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByCurrentInputSource
(
)
;
nsAutoString
inputSourceID
;
tis
.
GetInputSourceID
(
inputSourceID
)
;
allowConsumeEvent
=
!
StringBeginsWith
(
inputSourceID
u
"
com
.
apple
.
inputmethod
.
Korean
.
"
_ns
)
;
}
NSTextInputContext
*
inputContext
=
[
mView
inputContext
]
;
return
[
inputContext
handleEvent
:
aEvent
]
&
&
allowConsumeEvent
;
}
#
pragma
mark
-
int32_t
TextInputHandlerBase
:
:
sSecureEventInputCount
=
0
;
NS_IMPL_ISUPPORTS
(
TextInputHandlerBase
TextEventDispatcherListener
nsISupportsWeakReference
)
TextInputHandlerBase
:
:
TextInputHandlerBase
(
nsChildView
*
aWidget
NSView
<
mozView
>
*
aNativeView
)
:
mWidget
(
aWidget
)
mDispatcher
(
aWidget
-
>
GetTextEventDispatcher
(
)
)
{
gHandlerInstanceCount
+
+
;
mView
=
[
aNativeView
retain
]
;
}
TextInputHandlerBase
:
:
~
TextInputHandlerBase
(
)
{
[
mView
release
]
;
if
(
-
-
gHandlerInstanceCount
=
=
0
)
{
TISInputSourceWrapper
:
:
Shutdown
(
)
;
}
}
bool
TextInputHandlerBase
:
:
OnDestroyWidget
(
nsChildView
*
aDestroyingWidget
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandlerBase
:
:
OnDestroyWidget
"
"
aDestroyingWidget
=
%
p
mWidget
=
%
p
"
this
aDestroyingWidget
mWidget
)
)
;
if
(
aDestroyingWidget
!
=
mWidget
)
{
return
false
;
}
mWidget
=
nullptr
;
mDispatcher
=
nullptr
;
return
true
;
}
bool
TextInputHandlerBase
:
:
DispatchEvent
(
WidgetGUIEvent
&
aEvent
)
{
return
mWidget
-
>
DispatchWindowEvent
(
aEvent
)
;
}
void
TextInputHandlerBase
:
:
InitKeyEvent
(
NSEvent
*
aNativeKeyEvent
WidgetKeyboardEvent
&
aKeyEvent
bool
aIsProcessedByIME
const
nsAString
*
aInsertString
)
{
NS_ASSERTION
(
aNativeKeyEvent
"
aNativeKeyEvent
must
not
be
NULL
"
)
;
if
(
mKeyboardOverride
.
mOverrideEnabled
)
{
TISInputSourceWrapper
tis
;
tis
.
InitByLayoutID
(
mKeyboardOverride
.
mKeyboardLayout
true
)
;
tis
.
InitKeyEvent
(
aNativeKeyEvent
aKeyEvent
aIsProcessedByIME
aInsertString
)
;
return
;
}
TISInputSourceWrapper
:
:
CurrentInputSource
(
)
.
InitKeyEvent
(
aNativeKeyEvent
aKeyEvent
aIsProcessedByIME
aInsertString
)
;
}
nsresult
TextInputHandlerBase
:
:
SynthesizeNativeKeyEvent
(
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
static
const
uint32_t
sModifierFlagMap
[
]
[
2
]
=
{
{
nsIWidget
:
:
CAPS_LOCK
NSAlphaShiftKeyMask
}
{
nsIWidget
:
:
SHIFT_L
NSShiftKeyMask
|
0x0002
}
{
nsIWidget
:
:
SHIFT_R
NSShiftKeyMask
|
0x0004
}
{
nsIWidget
:
:
CTRL_L
NSControlKeyMask
|
0x0001
}
{
nsIWidget
:
:
CTRL_R
NSControlKeyMask
|
0x2000
}
{
nsIWidget
:
:
ALT_L
NSAlternateKeyMask
|
0x0020
}
{
nsIWidget
:
:
ALT_R
NSAlternateKeyMask
|
0x0040
}
{
nsIWidget
:
:
COMMAND_L
NSCommandKeyMask
|
0x0008
}
{
nsIWidget
:
:
COMMAND_R
NSCommandKeyMask
|
0x0010
}
{
nsIWidget
:
:
NUMERIC_KEY_PAD
NSNumericPadKeyMask
}
{
nsIWidget
:
:
HELP
NSHelpKeyMask
}
{
nsIWidget
:
:
FUNCTION
NSFunctionKeyMask
}
}
;
uint32_t
modifierFlags
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sModifierFlagMap
)
;
+
+
i
)
{
if
(
aModifierFlags
&
sModifierFlagMap
[
i
]
[
0
]
)
{
modifierFlags
|
=
sModifierFlagMap
[
i
]
[
1
]
;
}
}
NSInteger
windowNumber
=
[
[
mView
window
]
windowNumber
]
;
bool
sendFlagsChangedEvent
=
IsModifierKey
(
aNativeKeyCode
)
;
NSEventType
eventType
=
sendFlagsChangedEvent
?
NSFlagsChanged
:
NSKeyDown
;
NSEvent
*
downEvent
=
[
NSEvent
keyEventWithType
:
eventType
location
:
NSMakePoint
(
0
0
)
modifierFlags
:
modifierFlags
timestamp
:
0
windowNumber
:
windowNumber
context
:
[
NSGraphicsContext
currentContext
]
characters
:
nsCocoaUtils
:
:
ToNSString
(
aCharacters
)
charactersIgnoringModifiers
:
nsCocoaUtils
:
:
ToNSString
(
aUnmodifiedCharacters
)
isARepeat
:
NO
keyCode
:
aNativeKeyCode
]
;
NSEvent
*
upEvent
=
sendFlagsChangedEvent
?
nil
:
nsCocoaUtils
:
:
MakeNewCocoaEventWithType
(
NSKeyUp
downEvent
)
;
if
(
downEvent
&
&
(
sendFlagsChangedEvent
|
|
upEvent
)
)
{
KeyboardLayoutOverride
currentLayout
=
mKeyboardOverride
;
mKeyboardOverride
.
mKeyboardLayout
=
aNativeKeyboardLayout
;
mKeyboardOverride
.
mOverrideEnabled
=
true
;
[
NSApp
sendEvent
:
downEvent
]
;
if
(
upEvent
)
{
[
NSApp
sendEvent
:
upEvent
]
;
}
mKeyboardOverride
=
currentLayout
;
}
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
NSInteger
TextInputHandlerBase
:
:
GetWindowLevel
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandlerBase
:
:
GetWindowLevel
Destryoed
(
)
=
%
s
"
this
TrueOrFalse
(
Destroyed
(
)
)
)
)
;
if
(
Destroyed
(
)
)
{
return
NSNormalWindowLevel
;
}
NSView
<
mozView
>
*
editorView
=
mWidget
-
>
GetEditorView
(
)
;
NS_ENSURE_TRUE
(
editorView
NSNormalWindowLevel
)
;
NSInteger
windowLevel
=
[
[
editorView
window
]
level
]
;
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandlerBase
:
:
GetWindowLevel
windowLevel
=
%
s
(
%
lX
)
"
this
GetWindowLevelName
(
windowLevel
)
static_cast
<
unsigned
long
>
(
windowLevel
)
)
)
;
return
windowLevel
;
NS_OBJC_END_TRY_ABORT_BLOCK_RETURN
(
NSNormalWindowLevel
)
;
}
NS_IMETHODIMP
TextInputHandlerBase
:
:
AttachNativeKeyEvent
(
WidgetKeyboardEvent
&
aKeyEvent
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT
;
if
(
aKeyEvent
.
mNativeKeyEvent
|
|
aKeyEvent
.
mModifiers
&
MODIFIER_OS
)
{
return
NS_OK
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Info
(
"
%
p
TextInputHandlerBase
:
:
AttachNativeKeyEvent
key
=
0x
%
X
char
=
0x
%
X
"
"
mod
=
0x
%
X
"
this
aKeyEvent
.
mKeyCode
aKeyEvent
.
mCharCode
aKeyEvent
.
mModifiers
)
)
;
NSInteger
windowNumber
=
[
[
mView
window
]
windowNumber
]
;
NSGraphicsContext
*
context
=
[
NSGraphicsContext
currentContext
]
;
aKeyEvent
.
mNativeKeyEvent
=
nsCocoaUtils
:
:
MakeNewCococaEventFromWidgetEvent
(
aKeyEvent
windowNumber
context
)
;
return
NS_OK
;
NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT
;
}
bool
TextInputHandlerBase
:
:
SetSelection
(
NSRange
&
aRange
)
{
MOZ_ASSERT
(
!
Destroyed
(
)
)
;
RefPtr
<
TextInputHandlerBase
>
kungFuDeathGrip
(
this
)
;
WidgetSelectionEvent
selectionEvent
(
true
eSetSelection
mWidget
)
;
selectionEvent
.
mOffset
=
aRange
.
location
;
selectionEvent
.
mLength
=
aRange
.
length
;
selectionEvent
.
mReversed
=
false
;
selectionEvent
.
mExpandToClusterBoundary
=
false
;
DispatchEvent
(
selectionEvent
)
;
NS_ENSURE_TRUE
(
selectionEvent
.
mSucceeded
false
)
;
return
!
Destroyed
(
)
;
}
bool
TextInputHandlerBase
:
:
IsPrintableChar
(
char16_t
aChar
)
{
return
(
aChar
>
=
0x20
&
&
aChar
<
=
0x7E
)
|
|
aChar
>
=
0xA0
;
}
bool
TextInputHandlerBase
:
:
IsSpecialGeckoKey
(
UInt32
aNativeKeyCode
)
{
switch
(
aNativeKeyCode
)
{
case
kVK_Escape
:
case
kVK_Shift
:
case
kVK_RightShift
:
case
kVK_Command
:
case
kVK_RightCommand
:
case
kVK_CapsLock
:
case
kVK_Control
:
case
kVK_RightControl
:
case
kVK_Option
:
case
kVK_RightOption
:
case
kVK_ANSI_KeypadClear
:
case
kVK_Function
:
case
kVK_F1
:
case
kVK_F2
:
case
kVK_F3
:
case
kVK_F4
:
case
kVK_F5
:
case
kVK_F6
:
case
kVK_F7
:
case
kVK_F8
:
case
kVK_F9
:
case
kVK_F10
:
case
kVK_F11
:
case
kVK_F12
:
case
kVK_PC_Pause
:
case
kVK_PC_ScrollLock
:
case
kVK_PC_PrintScreen
:
case
kVK_F16
:
case
kVK_F17
:
case
kVK_F18
:
case
kVK_F19
:
case
kVK_PC_Insert
:
case
kVK_PC_Delete
:
case
kVK_Tab
:
case
kVK_PC_Backspace
:
case
kVK_PC_ContextMenu
:
case
kVK_JIS_Eisu
:
case
kVK_JIS_Kana
:
case
kVK_Home
:
case
kVK_End
:
case
kVK_PageUp
:
case
kVK_PageDown
:
case
kVK_LeftArrow
:
case
kVK_RightArrow
:
case
kVK_UpArrow
:
case
kVK_DownArrow
:
case
kVK_Return
:
case
kVK_ANSI_KeypadEnter
:
case
kVK_Powerbook_KeypadEnter
:
return
true
;
}
return
false
;
}
bool
TextInputHandlerBase
:
:
IsNormalCharInputtingEvent
(
const
WidgetKeyboardEvent
&
aKeyEvent
)
{
if
(
aKeyEvent
.
mNativeCharacters
.
IsEmpty
(
)
|
|
aKeyEvent
.
IsMeta
(
)
)
{
return
false
;
}
return
!
IsControlChar
(
aKeyEvent
.
mNativeCharacters
[
0
]
)
;
}
bool
TextInputHandlerBase
:
:
IsModifierKey
(
UInt32
aNativeKeyCode
)
{
switch
(
aNativeKeyCode
)
{
case
kVK_CapsLock
:
case
kVK_RightCommand
:
case
kVK_Command
:
case
kVK_Shift
:
case
kVK_Option
:
case
kVK_Control
:
case
kVK_RightShift
:
case
kVK_RightOption
:
case
kVK_RightControl
:
case
kVK_Function
:
return
true
;
}
return
false
;
}
void
TextInputHandlerBase
:
:
EnableSecureEventInput
(
)
{
sSecureEventInputCount
+
+
;
:
:
EnableSecureEventInput
(
)
;
}
void
TextInputHandlerBase
:
:
DisableSecureEventInput
(
)
{
if
(
!
sSecureEventInputCount
)
{
return
;
}
sSecureEventInputCount
-
-
;
:
:
DisableSecureEventInput
(
)
;
}
bool
TextInputHandlerBase
:
:
IsSecureEventInputEnabled
(
)
{
NS_ASSERTION
(
!
!
sSecureEventInputCount
=
=
!
!
:
:
IsSecureEventInputEnabled
(
)
"
Some
other
process
has
enabled
secure
event
input
"
)
;
return
!
!
sSecureEventInputCount
;
}
void
TextInputHandlerBase
:
:
EnsureSecureEventInputDisabled
(
)
{
while
(
sSecureEventInputCount
)
{
TextInputHandlerBase
:
:
DisableSecureEventInput
(
)
;
}
}
#
pragma
mark
-
void
TextInputHandlerBase
:
:
KeyEventState
:
:
InitKeyEvent
(
TextInputHandlerBase
*
aHandler
WidgetKeyboardEvent
&
aKeyEvent
bool
aIsProcessedByIME
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
MOZ_ASSERT
(
aHandler
)
;
MOZ_RELEASE_ASSERT
(
mKeyEvent
)
;
NSEvent
*
nativeEvent
=
mKeyEvent
;
if
(
!
mInsertedString
.
IsEmpty
(
)
)
{
nsAutoString
unhandledString
;
GetUnhandledString
(
unhandledString
)
;
NSString
*
unhandledNSString
=
nsCocoaUtils
:
:
ToNSString
(
unhandledString
)
;
nativeEvent
=
[
NSEvent
keyEventWithType
:
[
mKeyEvent
type
]
location
:
[
mKeyEvent
locationInWindow
]
modifierFlags
:
[
mKeyEvent
modifierFlags
]
timestamp
:
[
mKeyEvent
timestamp
]
windowNumber
:
[
mKeyEvent
windowNumber
]
context
:
[
mKeyEvent
context
]
characters
:
unhandledNSString
charactersIgnoringModifiers
:
[
mKeyEvent
charactersIgnoringModifiers
]
isARepeat
:
[
mKeyEvent
isARepeat
]
keyCode
:
[
mKeyEvent
keyCode
]
]
;
}
aKeyEvent
.
mUniqueId
=
mUniqueId
;
aHandler
-
>
InitKeyEvent
(
nativeEvent
aKeyEvent
aIsProcessedByIME
mInsertString
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
TextInputHandlerBase
:
:
KeyEventState
:
:
GetUnhandledString
(
nsAString
&
aUnhandledString
)
const
{
aUnhandledString
.
Truncate
(
)
;
if
(
NS_WARN_IF
(
!
mKeyEvent
)
)
{
return
;
}
nsAutoString
characters
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
mKeyEvent
characters
]
characters
)
;
if
(
characters
.
IsEmpty
(
)
)
{
return
;
}
if
(
mInsertedString
.
IsEmpty
(
)
)
{
aUnhandledString
=
characters
;
return
;
}
MOZ_ASSERT
(
StringBeginsWith
(
characters
mInsertedString
)
)
;
aUnhandledString
=
nsDependentSubstring
(
characters
mInsertedString
.
Length
(
)
)
;
}
#
pragma
mark
-
TextInputHandlerBase
:
:
AutoInsertStringClearer
:
:
~
AutoInsertStringClearer
(
)
{
if
(
mState
&
&
mState
-
>
mInsertString
)
{
nsAutoString
characters
;
nsCocoaUtils
:
:
GetStringForNSString
(
[
mState
-
>
mKeyEvent
characters
]
characters
)
;
nsAutoString
insertedString
(
mState
-
>
mInsertedString
)
;
insertedString
+
=
*
mState
-
>
mInsertString
;
if
(
StringBeginsWith
(
characters
insertedString
)
)
{
mState
-
>
mInsertedString
=
insertedString
;
}
}
if
(
mState
)
{
mState
-
>
mInsertString
=
nullptr
;
}
}
