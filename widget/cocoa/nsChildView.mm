#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
<
unistd
.
h
>
#
include
<
math
.
h
>
#
include
"
nsChildView
.
h
"
#
include
"
nsCocoaWindow
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SwipeTracker
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
WheelHandlingHelper
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
SimpleGestureEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
WheelEventBinding
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsExceptionHandler
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsILocalFileMac
.
h
"
#
include
"
nsGfxCIID
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsDragService
.
h
"
#
include
"
nsClipboard
.
h
"
#
include
"
nsCursorManager
.
h
"
#
include
"
nsWindowMap
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsMenuBarX
.
h
"
#
include
"
NativeKeyBindings
.
h
"
#
include
"
MacThemeGeometryType
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxQuartzSurface
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
Layers
.
h
"
#
include
"
GfxTexturesReporter
.
h
"
#
include
"
GLTextureImage
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
GLContextCGL
.
h
"
#
include
"
OGLShaderProgram
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
include
"
HeapCopyOfStackArray
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
APZInputBridge
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOGL
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
IpcResourceUpdateQueue
.
h
"
#
include
"
mozilla
/
layers
/
NativeLayerCA
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
widget
/
CompositorWidget
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
BorrowedContext
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
Platform
.
h
"
#
endif
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_general
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
<
dlfcn
.
h
>
#
include
<
ApplicationServices
/
ApplicationServices
.
h
>
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
layers
/
ChromeProcessController
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
InputData
.
h
"
#
include
"
VibrancyManager
.
h
"
#
include
"
nsNativeThemeCocoa
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
Units
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
CustomCocoaEvents
.
h
"
#
include
"
NativeMenuSupport
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gl
;
using
namespace
mozilla
:
:
widget
;
using
mozilla
:
:
gfx
:
:
Matrix4x4
;
#
undef
DEBUG_UPDATE
#
undef
INVALIDATE_DEBUGGING
/
/
flash
areas
as
they
are
invalidated
#
define
MAX_RECTS_IN_REGION
100
LazyLogModule
sCocoaLog
(
"
nsCocoaWidgets
"
)
;
extern
"
C
"
{
CG_EXTERN
void
CGContextResetCTM
(
CGContextRef
)
;
CG_EXTERN
void
CGContextSetCTM
(
CGContextRef
CGAffineTransform
)
;
CG_EXTERN
void
CGContextResetClip
(
CGContextRef
)
;
typedef
CFTypeRef
CGSRegionObj
;
CGError
CGSNewRegionWithRect
(
const
CGRect
*
rect
CGSRegionObj
*
outRegion
)
;
CGError
CGSNewRegionWithRectList
(
const
CGRect
*
rects
int
rectCount
CGSRegionObj
*
outRegion
)
;
}
extern
NSMenu
*
sApplicationMenu
;
extern
nsIArray
*
gDraggedTransferables
;
ChildView
*
ChildViewMouseTracker
:
:
sLastMouseEventView
=
nil
;
NSEvent
*
ChildViewMouseTracker
:
:
sLastMouseMoveEvent
=
nil
;
NSWindow
*
ChildViewMouseTracker
:
:
sWindowUnderMouse
=
nil
;
NSPoint
ChildViewMouseTracker
:
:
sLastScrollEventScreenLocation
=
NSZeroPoint
;
#
ifdef
INVALIDATE_DEBUGGING
static
void
blinkRect
(
Rect
*
r
)
;
static
void
blinkRgn
(
RgnHandle
rgn
)
;
#
endif
bool
gUserCancelledDrag
=
false
;
uint32_t
nsChildView
:
:
sLastInputEventCount
=
0
;
static
bool
sIsTabletPointerActivated
=
false
;
static
uint32_t
sUniqueKeyEventId
=
0
;
interface
PixelHostingView
:
NSView
{
}
end
interface
ChildView
(
Private
)
-
(
id
)
initWithFrame
:
(
NSRect
)
inFrame
geckoChild
:
(
nsChildView
*
)
inChild
;
-
(
void
)
convertCocoaMouseWheelEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetWheelEvent
*
)
outWheelEvent
;
-
(
void
)
convertCocoaMouseEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetInputEvent
*
)
outGeckoEvent
;
-
(
void
)
convertCocoaTabletPointerEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetMouseEvent
*
)
outGeckoEvent
;
-
(
NSMenu
*
)
contextMenu
;
-
(
void
)
markLayerForDisplay
;
-
(
CALayer
*
)
rootCALayer
;
-
(
void
)
updateRootCALayer
;
#
ifdef
ACCESSIBILITY
-
(
id
<
mozAccessible
>
)
accessible
;
#
endif
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinates
:
(
NSPoint
)
aPoint
;
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinatesRoundDown
:
(
NSPoint
)
aPoint
;
-
(
BOOL
)
inactiveWindowAcceptsMouseEvent
:
(
NSEvent
*
)
aEvent
;
-
(
void
)
updateWindowDraggableState
;
-
(
bool
)
beginOrEndGestureForEventPhase
:
(
NSEvent
*
)
aEvent
;
-
(
bool
)
shouldConsiderStartingSwipeFromEvent
:
(
NSEvent
*
)
aEvent
;
end
#
pragma
mark
-
static
inline
void
FlipCocoaScreenCoordinate
(
NSPoint
&
inPoint
)
{
inPoint
.
y
=
nsCocoaUtils
:
:
FlippedScreenY
(
inPoint
.
y
)
;
}
#
pragma
mark
-
nsChildView
:
:
nsChildView
(
)
:
nsBaseWidget
(
)
mView
(
nullptr
)
mParentView
(
nil
)
mParentWidget
(
nullptr
)
mCompositingLock
(
"
ChildViewCompositing
"
)
mBackingScaleFactor
(
0
.
0
)
mVisible
(
false
)
mSizeMode
(
nsSizeMode_Normal
)
mDrawing
(
false
)
mIsDispatchPaint
(
false
)
{
}
nsChildView
:
:
~
nsChildView
(
)
{
for
(
nsIWidget
*
kid
=
mLastChild
;
kid
;
)
{
nsChildView
*
childView
=
static_cast
<
nsChildView
*
>
(
kid
)
;
kid
=
kid
-
>
GetPrevSibling
(
)
;
childView
-
>
ResetParent
(
)
;
}
NS_WARNING_ASSERTION
(
mOnDestroyCalled
"
nsChildView
object
destroyed
without
calling
Destroy
(
)
"
)
;
if
(
mContentLayer
)
{
mNativeLayerRoot
-
>
RemoveLayer
(
mContentLayer
)
;
}
DestroyCompositor
(
)
;
[
mView
widgetDestroyed
]
;
mParentWidget
=
nil
;
TearDownView
(
)
;
}
nsresult
nsChildView
:
:
Create
(
nsIWidget
*
aParent
nsNativeWidget
aNativeParent
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsAutoreleasePool
localPool
;
mBounds
=
aRect
;
nsToolkit
:
:
GetToolkit
(
)
;
BaseCreate
(
aParent
aInitData
)
;
mParentView
=
nil
;
if
(
aParent
)
{
mParentView
=
(
NSView
*
)
aParent
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
mParentWidget
=
aParent
;
}
else
{
mParentView
=
reinterpret_cast
<
NSView
*
>
(
aNativeParent
)
;
}
CGFloat
scaleFactor
=
nsCocoaUtils
:
:
GetBackingScaleFactor
(
mParentView
)
;
NSRect
r
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
mBounds
scaleFactor
)
;
mView
=
[
[
ChildView
alloc
]
initWithFrame
:
r
geckoChild
:
this
]
;
mNativeLayerRoot
=
NativeLayerRootCA
:
:
CreateForCALayer
(
[
mView
rootCALayer
]
)
;
mNativeLayerRoot
-
>
SetBackingScale
(
scaleFactor
)
;
if
(
mParentWidget
)
[
mView
setHidden
:
YES
]
;
else
mVisible
=
true
;
if
(
mParentView
)
{
[
mParentView
addSubview
:
mView
]
;
}
if
(
[
mView
isKindOfClass
:
[
ChildView
class
]
]
)
[
[
WindowDataMap
sharedWindowDataMap
]
ensureDataForWindow
:
[
mView
window
]
]
;
NS_ASSERTION
(
!
mTextInputHandler
"
mTextInputHandler
has
already
existed
"
)
;
mTextInputHandler
=
new
TextInputHandler
(
this
mView
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsChildView
:
:
TearDownView
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mView
)
return
;
NSWindow
*
win
=
[
mView
window
]
;
NSResponder
*
responder
=
[
win
firstResponder
]
;
if
(
responder
&
&
[
responder
isKindOfClass
:
[
NSView
class
]
]
&
&
[
(
NSView
*
)
responder
isDescendantOf
:
mView
]
)
{
[
win
makeFirstResponder
:
[
mView
superview
]
]
;
}
if
(
[
mView
isEqual
:
[
win
contentView
]
]
)
{
[
mView
release
]
;
}
else
{
[
mView
performSelectorOnMainThread
:
selector
(
delayedTearDown
)
withObject
:
nil
waitUntilDone
:
false
]
;
}
mView
=
nil
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsCocoaWindow
*
nsChildView
:
:
GetAppWindowWidget
(
)
const
{
id
windowDelegate
=
[
[
mView
window
]
delegate
]
;
if
(
windowDelegate
&
&
[
windowDelegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
{
return
[
(
WindowDelegate
*
)
windowDelegate
geckoWidget
]
;
}
return
nullptr
;
}
void
nsChildView
:
:
Destroy
(
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
MutexAutoLock
lock
(
mCompositingLock
)
;
if
(
mOnDestroyCalled
)
return
;
mOnDestroyCalled
=
true
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
[
mView
widgetDestroyed
]
;
nsBaseWidget
:
:
Destroy
(
)
;
NotifyWindowDestroyed
(
)
;
mParentWidget
=
nil
;
TearDownView
(
)
;
nsBaseWidget
:
:
OnDestroy
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
#
if
0
static
void
PrintViewHierarchy
(
NSView
*
view
)
{
while
(
view
)
{
NSLog
(
"
view
is
%
x
frame
%
"
view
NSStringFromRect
(
[
view
frame
]
)
)
;
view
=
[
view
superview
]
;
}
}
#
endif
void
*
nsChildView
:
:
GetNativeData
(
uint32_t
aDataType
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
void
*
retVal
=
nullptr
;
switch
(
aDataType
)
{
case
NS_NATIVE_WIDGET
:
case
NS_NATIVE_DISPLAY
:
retVal
=
(
void
*
)
mView
;
break
;
case
NS_NATIVE_WINDOW
:
retVal
=
[
mView
window
]
;
break
;
case
NS_NATIVE_GRAPHIC
:
NS_ERROR
(
"
Requesting
NS_NATIVE_GRAPHIC
on
a
Mac
OS
X
child
view
!
"
)
;
retVal
=
nullptr
;
break
;
case
NS_NATIVE_OFFSETX
:
retVal
=
0
;
break
;
case
NS_NATIVE_OFFSETY
:
retVal
=
0
;
break
;
case
NS_RAW_NATIVE_IME_CONTEXT
:
retVal
=
GetPseudoIMEContext
(
)
;
if
(
retVal
)
{
break
;
}
retVal
=
[
mView
inputContext
]
;
if
(
NS_WARN_IF
(
!
retVal
)
)
{
retVal
=
this
;
}
break
;
case
NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID
:
{
NSWindow
*
win
=
[
mView
window
]
;
if
(
win
)
{
retVal
=
(
void
*
)
[
win
windowNumber
]
;
}
break
;
}
}
return
retVal
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nullptr
)
;
}
#
pragma
mark
-
void
nsChildView
:
:
SuppressAnimation
(
bool
aSuppress
)
{
GetAppWindowWidget
(
)
-
>
SuppressAnimation
(
aSuppress
)
;
}
bool
nsChildView
:
:
IsVisible
(
)
const
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mVisible
)
{
return
mVisible
;
}
if
(
!
GetAppWindowWidget
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
return
(
[
mView
window
]
!
=
nil
)
&
&
!
NSIsEmptyRect
(
[
mView
visibleRect
]
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
false
)
;
}
static
void
ManipulateViewWithoutNeedingDisplay
(
NSView
*
aView
void
(
^
aCallback
)
(
)
)
{
BaseWindow
*
win
=
nil
;
if
(
[
[
aView
window
]
isKindOfClass
:
[
BaseWindow
class
]
]
)
{
win
=
(
BaseWindow
*
)
[
aView
window
]
;
}
[
win
disableSetNeedsDisplay
]
;
aCallback
(
)
;
[
win
enableSetNeedsDisplay
]
;
}
void
nsChildView
:
:
Show
(
bool
aState
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
aState
!
=
mVisible
)
{
nsAutoreleasePool
localPool
;
ManipulateViewWithoutNeedingDisplay
(
mView
^
{
[
mView
setHidden
:
!
aState
]
;
}
)
;
mVisible
=
aState
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
SetParent
(
nsIWidget
*
aNewParent
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mOnDestroyCalled
)
return
;
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
if
(
mParentWidget
)
{
mParentWidget
-
>
RemoveChild
(
this
)
;
}
if
(
aNewParent
)
{
ReparentNativeWidget
(
aNewParent
)
;
}
else
{
[
mView
removeFromSuperview
]
;
mParentView
=
nil
;
}
mParentWidget
=
aNewParent
;
if
(
mParentWidget
)
{
mParentWidget
-
>
AddChild
(
this
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
ReparentNativeWidget
(
nsIWidget
*
aNewParent
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
MOZ_ASSERT
(
aNewParent
"
null
widget
"
)
;
if
(
mOnDestroyCalled
)
return
;
NSView
<
mozView
>
*
newParentView
=
(
NSView
<
mozView
>
*
)
aNewParent
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
NS_ENSURE_TRUE_VOID
(
newParentView
)
;
[
mView
removeFromSuperview
]
;
mParentView
=
newParentView
;
[
mParentView
addSubview
:
mView
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
ResetParent
(
)
{
if
(
!
mOnDestroyCalled
)
{
if
(
mParentWidget
)
mParentWidget
-
>
RemoveChild
(
this
)
;
if
(
mView
)
[
mView
removeFromSuperview
]
;
}
mParentWidget
=
nullptr
;
}
nsIWidget
*
nsChildView
:
:
GetParent
(
)
{
return
mParentWidget
;
}
float
nsChildView
:
:
GetDPI
(
)
{
float
dpi
=
96
.
0
;
nsCOMPtr
<
nsIScreen
>
screen
=
GetWidgetScreen
(
)
;
if
(
screen
)
{
screen
-
>
GetDpi
(
&
dpi
)
;
}
return
dpi
;
}
void
nsChildView
:
:
Enable
(
bool
aState
)
{
}
bool
nsChildView
:
:
IsEnabled
(
)
const
{
return
true
;
}
void
nsChildView
:
:
SetFocus
(
Raise
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSWindow
*
window
=
[
mView
window
]
;
if
(
window
)
[
window
makeFirstResponder
:
mView
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
SetCursor
(
const
Cursor
&
aCursor
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
[
mView
isDragInProgress
]
)
{
return
;
}
nsBaseWidget
:
:
SetCursor
(
aCursor
)
;
if
(
NS_SUCCEEDED
(
[
[
nsCursorManager
sharedInstance
]
setCustomCursor
:
aCursor
widgetScaleFactor
:
BackingScaleFactor
(
)
]
)
)
{
return
;
}
[
[
nsCursorManager
sharedInstance
]
setNonCustomCursor
:
aCursor
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
LayoutDeviceIntRect
nsChildView
:
:
GetBounds
(
)
{
return
!
mView
?
mBounds
:
CocoaPointsToDevPixels
(
[
mView
frame
]
)
;
}
LayoutDeviceIntRect
nsChildView
:
:
GetClientBounds
(
)
{
LayoutDeviceIntRect
rect
=
GetBounds
(
)
;
if
(
!
mParentWidget
)
{
rect
.
MoveTo
(
WidgetToScreenOffset
(
)
)
;
}
return
rect
;
}
LayoutDeviceIntRect
nsChildView
:
:
GetScreenBounds
(
)
{
LayoutDeviceIntRect
rect
=
GetBounds
(
)
;
rect
.
MoveTo
(
WidgetToScreenOffset
(
)
)
;
return
rect
;
}
double
nsChildView
:
:
GetDefaultScaleInternal
(
)
{
return
BackingScaleFactor
(
)
;
}
CGFloat
nsChildView
:
:
BackingScaleFactor
(
)
const
{
if
(
mBackingScaleFactor
>
0
.
0
)
{
return
mBackingScaleFactor
;
}
if
(
!
mView
)
{
return
1
.
0
;
}
mBackingScaleFactor
=
nsCocoaUtils
:
:
GetBackingScaleFactor
(
mView
)
;
return
mBackingScaleFactor
;
}
void
nsChildView
:
:
BackingScaleFactorChanged
(
)
{
CGFloat
newScale
=
nsCocoaUtils
:
:
GetBackingScaleFactor
(
mView
)
;
if
(
mBackingScaleFactor
=
=
newScale
)
{
return
;
}
SuspendAsyncCATransactions
(
)
;
mBackingScaleFactor
=
newScale
;
NSRect
frame
=
[
mView
frame
]
;
mBounds
=
nsCocoaUtils
:
:
CocoaRectToGeckoRectDevPix
(
frame
newScale
)
;
mNativeLayerRoot
-
>
SetBackingScale
(
mBackingScaleFactor
)
;
if
(
mWidgetListener
&
&
!
mWidgetListener
-
>
GetAppWindow
(
)
)
{
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
BackingScaleFactorChanged
(
)
;
}
}
}
int32_t
nsChildView
:
:
RoundsWidgetCoordinatesTo
(
)
{
if
(
BackingScaleFactor
(
)
=
=
2
.
0
)
{
return
2
;
}
return
1
;
}
void
nsChildView
:
:
Move
(
double
aX
double
aY
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
int32_t
x
=
NSToIntRound
(
aX
)
;
int32_t
y
=
NSToIntRound
(
aY
)
;
if
(
!
mView
|
|
(
mBounds
.
x
=
=
x
&
&
mBounds
.
y
=
=
y
)
)
return
;
mBounds
.
x
=
x
;
mBounds
.
y
=
y
;
ManipulateViewWithoutNeedingDisplay
(
mView
^
{
[
mView
setFrame
:
DevPixelsToCocoaPoints
(
mBounds
)
]
;
}
)
;
ReportMoveEvent
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
Resize
(
double
aWidth
double
aHeight
bool
aRepaint
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
int32_t
width
=
NSToIntRound
(
aWidth
)
;
int32_t
height
=
NSToIntRound
(
aHeight
)
;
if
(
!
mView
|
|
(
mBounds
.
width
=
=
width
&
&
mBounds
.
height
=
=
height
)
)
return
;
SuspendAsyncCATransactions
(
)
;
mBounds
.
width
=
width
;
mBounds
.
height
=
height
;
ManipulateViewWithoutNeedingDisplay
(
mView
^
{
[
mView
setFrame
:
DevPixelsToCocoaPoints
(
mBounds
)
]
;
}
)
;
if
(
mVisible
&
&
aRepaint
)
{
[
[
mView
pixelHostingView
]
setNeedsDisplay
:
YES
]
;
}
ReportSizeEvent
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
Resize
(
double
aX
double
aY
double
aWidth
double
aHeight
bool
aRepaint
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
int32_t
x
=
NSToIntRound
(
aX
)
;
int32_t
y
=
NSToIntRound
(
aY
)
;
int32_t
width
=
NSToIntRound
(
aWidth
)
;
int32_t
height
=
NSToIntRound
(
aHeight
)
;
BOOL
isMoving
=
(
mBounds
.
x
!
=
x
|
|
mBounds
.
y
!
=
y
)
;
BOOL
isResizing
=
(
mBounds
.
width
!
=
width
|
|
mBounds
.
height
!
=
height
)
;
if
(
!
mView
|
|
(
!
isMoving
&
&
!
isResizing
)
)
return
;
if
(
isMoving
)
{
mBounds
.
x
=
x
;
mBounds
.
y
=
y
;
}
if
(
isResizing
)
{
SuspendAsyncCATransactions
(
)
;
mBounds
.
width
=
width
;
mBounds
.
height
=
height
;
CALayer
*
layer
=
[
mView
rootCALayer
]
;
double
scale
=
BackingScaleFactor
(
)
;
layer
.
bounds
=
CGRectMake
(
0
0
width
/
scale
height
/
scale
)
;
}
ManipulateViewWithoutNeedingDisplay
(
mView
^
{
[
mView
setFrame
:
DevPixelsToCocoaPoints
(
mBounds
)
]
;
}
)
;
if
(
mVisible
&
&
aRepaint
)
{
[
[
mView
pixelHostingView
]
setNeedsDisplay
:
YES
]
;
}
if
(
isMoving
)
{
ReportMoveEvent
(
)
;
if
(
mOnDestroyCalled
)
return
;
}
if
(
isResizing
)
ReportSizeEvent
(
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
void
nsChildView
:
:
SuspendAsyncCATransactions
(
)
{
if
(
mUnsuspendAsyncCATransactionsRunnable
)
{
mUnsuspendAsyncCATransactionsRunnable
-
>
Cancel
(
)
;
mUnsuspendAsyncCATransactionsRunnable
=
nullptr
;
}
[
mView
markLayerForDisplay
]
;
mNativeLayerRoot
-
>
SuspendOffMainThreadCommits
(
)
;
}
void
nsChildView
:
:
MaybeScheduleUnsuspendAsyncCATransactions
(
)
{
if
(
mNativeLayerRoot
-
>
AreOffMainThreadCommitsSuspended
(
)
&
&
!
mUnsuspendAsyncCATransactionsRunnable
)
{
mUnsuspendAsyncCATransactionsRunnable
=
NewCancelableRunnableMethod
(
"
nsChildView
:
:
MaybeScheduleUnsuspendAsyncCATransactions
"
this
&
nsChildView
:
:
UnsuspendAsyncCATransactions
)
;
NS_DispatchToMainThread
(
mUnsuspendAsyncCATransactionsRunnable
)
;
}
}
void
nsChildView
:
:
UnsuspendAsyncCATransactions
(
)
{
mUnsuspendAsyncCATransactionsRunnable
=
nullptr
;
if
(
mNativeLayerRoot
-
>
UnsuspendOffMainThreadCommits
(
)
)
{
[
mView
markLayerForDisplay
]
;
}
}
void
nsChildView
:
:
UpdateFullscreen
(
bool
aFullscreen
)
{
if
(
mNativeLayerRoot
)
{
mNativeLayerRoot
-
>
SetWindowIsFullscreen
(
aFullscreen
)
;
}
}
nsresult
nsChildView
:
:
SynthesizeNativeKeyEvent
(
int32_t
aNativeKeyboardLayout
int32_t
aNativeKeyCode
uint32_t
aModifierFlags
const
nsAString
&
aCharacters
const
nsAString
&
aUnmodifiedCharacters
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
keyevent
"
)
;
return
mTextInputHandler
-
>
SynthesizeNativeKeyEvent
(
aNativeKeyboardLayout
aNativeKeyCode
aModifierFlags
aCharacters
aUnmodifiedCharacters
)
;
}
nsresult
nsChildView
:
:
SynthesizeNativeMouseEvent
(
LayoutDeviceIntPoint
aPoint
NativeMouseMessage
aNativeMessage
MouseButton
aButton
nsIWidget
:
:
Modifiers
aModifierFlags
nsIObserver
*
aObserver
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoObserverNotifier
notifier
(
aObserver
"
mouseevent
"
)
;
NSPoint
pt
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
aPoint
BackingScaleFactor
(
)
)
;
CGWarpMouseCursorPosition
(
NSPointToCGPoint
(
pt
)
)
;
CGAssociateMouseAndMouseCursorPosition
(
true
)
;
NSPoint
screenPoint
=
NSMakePoint
(
pt
.
x
nsCocoaUtils
:
:
FlippedScreenY
(
pt
.
y
)
)
;
NSPoint
windowPoint
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
[
mView
window
]
screenPoint
)
;
NSEventModifierFlags
modifierFlags
=
nsCocoaUtils
:
:
ConvertWidgetModifiersToMacModifierFlags
(
aModifierFlags
)
;
if
(
aButton
=
=
MouseButton
:
:
eX1
|
|
aButton
=
=
MouseButton
:
:
eX2
)
{
return
NS_ERROR_INVALID_ARG
;
}
NSEventType
nativeEventType
;
switch
(
aNativeMessage
)
{
case
NativeMouseMessage
:
:
ButtonDown
:
case
NativeMouseMessage
:
:
ButtonUp
:
{
switch
(
aButton
)
{
case
MouseButton
:
:
ePrimary
:
nativeEventType
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
NSEventTypeLeftMouseDown
:
NSEventTypeLeftMouseUp
;
break
;
case
MouseButton
:
:
eMiddle
:
nativeEventType
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
NSEventTypeOtherMouseDown
:
NSEventTypeOtherMouseUp
;
break
;
case
MouseButton
:
:
eSecondary
:
nativeEventType
=
aNativeMessage
=
=
NativeMouseMessage
:
:
ButtonDown
?
NSEventTypeRightMouseDown
:
NSEventTypeRightMouseUp
;
break
;
default
:
return
NS_ERROR_INVALID_ARG
;
}
break
;
}
case
NativeMouseMessage
:
:
Move
:
nativeEventType
=
NSEventTypeMouseMoved
;
break
;
case
NativeMouseMessage
:
:
EnterWindow
:
nativeEventType
=
NSEventTypeMouseEntered
;
break
;
case
NativeMouseMessage
:
:
LeaveWindow
:
nativeEventType
=
NSEventTypeMouseExited
;
break
;
}
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
nativeEventType
location
:
windowPoint
modifierFlags
:
modifierFlags
timestamp
:
[
[
NSProcessInfo
processInfo
]
systemUptime
]
windowNumber
:
[
[
mView
window
]
windowNumber
]
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0
]
;
if
(
!
event
)
return
NS_ERROR_FAILURE
;
if
(
[
[
mView
window
]
isKindOfClass
:
[
BaseWindow
class
]
]
)
{
BaseWindow
*
window
=
(
BaseWindow
*
)
[
mView
window
]
;
if
(
nativeEventType
=
=
NSEventTypeMouseEntered
)
{
[
window
mouseEntered
:
event
]
;
return
NS_OK
;
}
if
(
nativeEventType
=
=
NSEventTypeMouseExited
)
{
[
window
mouseExited
:
event
]
;
return
NS_OK
;
}
if
(
nativeEventType
=
=
NSEventTypeMouseMoved
)
{
[
window
mouseMoved
:
event
]
;
return
NS_OK
;
}
}
[
NSApp
sendEvent
:
event
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsChildView
:
:
SynthesizeNativeMouseScrollEvent
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aNativeMessage
double
aDeltaX
double
aDeltaY
double
aDeltaZ
uint32_t
aModifierFlags
uint32_t
aAdditionalFlags
nsIObserver
*
aObserver
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoObserverNotifier
notifier
(
aObserver
"
mousescrollevent
"
)
;
NSPoint
pt
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
aPoint
BackingScaleFactor
(
)
)
;
CGWarpMouseCursorPosition
(
NSPointToCGPoint
(
pt
)
)
;
CGAssociateMouseAndMouseCursorPosition
(
true
)
;
CGScrollEventUnit
units
=
(
aAdditionalFlags
&
nsIDOMWindowUtils
:
:
MOUSESCROLL_SCROLL_LINES
)
?
kCGScrollEventUnitLine
:
kCGScrollEventUnitPixel
;
CGEventRef
cgEvent
=
CGEventCreateScrollWheelEvent
(
NULL
units
3
(
int32_t
)
aDeltaY
(
int32_t
)
aDeltaX
(
int32_t
)
aDeltaZ
)
;
if
(
!
cgEvent
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aNativeMessage
)
{
CGEventSetIntegerValueField
(
cgEvent
kCGScrollWheelEventScrollPhase
aNativeMessage
)
;
}
CGPoint
location
=
CGEventGetLocation
(
cgEvent
)
;
location
.
y
+
=
NSMinY
(
[
[
mView
window
]
frame
]
)
;
location
.
x
-
=
NSMinX
(
[
[
mView
window
]
frame
]
)
;
CGEventSetLocation
(
cgEvent
location
)
;
uint64_t
kNanosPerSec
=
1000000000L
;
CGEventSetTimestamp
(
cgEvent
[
[
NSProcessInfo
processInfo
]
systemUptime
]
*
kNanosPerSec
)
;
NSEvent
*
event
=
[
NSEvent
eventWithCGEvent
:
cgEvent
]
;
[
event
setValue
:
[
mView
window
]
forKey
:
"
_window
"
]
;
[
mView
scrollWheel
:
event
]
;
CFRelease
(
cgEvent
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsChildView
:
:
SynthesizeNativeTouchPoint
(
uint32_t
aPointerId
TouchPointerState
aPointerState
mozilla
:
:
LayoutDeviceIntPoint
aPoint
double
aPointerPressure
uint32_t
aPointerOrientation
nsIObserver
*
aObserver
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
AutoObserverNotifier
notifier
(
aObserver
"
touchpoint
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aPointerState
=
=
TOUCH_HOVER
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mSynthesizedTouchInput
)
{
mSynthesizedTouchInput
=
MakeUnique
<
MultiTouchInput
>
(
)
;
}
LayoutDeviceIntPoint
pointInWindow
=
aPoint
-
WidgetToScreenOffset
(
)
;
MultiTouchInput
inputToDispatch
=
UpdateSynthesizedTouchState
(
mSynthesizedTouchInput
.
get
(
)
PR_IntervalNow
(
)
TimeStamp
:
:
Now
(
)
aPointerId
aPointerState
pointInWindow
aPointerPressure
aPointerOrientation
)
;
DispatchTouchInput
(
inputToDispatch
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsChildView
:
:
SynthesizeNativeTouchpadDoubleTap
(
mozilla
:
:
LayoutDeviceIntPoint
aPoint
uint32_t
aModifierFlags
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
DispatchDoubleTapGesture
(
TimeStamp
:
:
Now
(
)
aPoint
-
WidgetToScreenOffset
(
)
static_cast
<
Modifiers
>
(
aModifierFlags
)
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
bool
nsChildView
:
:
SendEventToNativeMenuSystem
(
NSEvent
*
aEvent
)
{
bool
handled
=
false
;
nsCocoaWindow
*
widget
=
GetAppWindowWidget
(
)
;
if
(
widget
)
{
nsMenuBarX
*
mb
=
widget
-
>
GetMenuBar
(
)
;
if
(
mb
)
{
handled
=
mb
-
>
PerformKeyEquivalent
(
aEvent
)
;
}
}
if
(
!
handled
&
&
sApplicationMenu
)
{
handled
=
[
sApplicationMenu
performKeyEquivalent
:
aEvent
]
;
}
return
handled
;
}
void
nsChildView
:
:
PostHandleKeyEvent
(
mozilla
:
:
WidgetKeyboardEvent
*
aEvent
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSMutableDictionary
*
nativeKeyEventsMap
=
[
ChildView
sNativeKeyEventsMap
]
;
NSEvent
*
cocoaEvent
=
[
nativeKeyEventsMap
objectForKey
:
(
aEvent
-
>
mUniqueId
)
]
;
if
(
!
cocoaEvent
)
{
return
;
}
if
(
StaticPrefs
:
:
browser_fullscreen_exit_on_escape
(
)
&
&
[
cocoaEvent
keyCode
]
=
=
kVK_Escape
&
&
[
[
mView
window
]
styleMask
]
&
NSWindowStyleMaskFullScreen
)
{
[
[
mView
window
]
toggleFullScreen
:
nil
]
;
}
if
(
SendEventToNativeMenuSystem
(
cocoaEvent
)
)
{
aEvent
-
>
PreventDefault
(
)
;
}
[
nativeKeyEventsMap
removeObjectForKey
:
(
aEvent
-
>
mUniqueId
)
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
nsresult
nsChildView
:
:
ActivateNativeMenuItemAt
(
const
nsAString
&
indexString
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsMenuUtilsX
:
:
CheckNativeMenuConsistency
(
[
NSApp
mainMenu
]
)
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
indexString
.
BeginReading
(
)
)
length
:
indexString
.
Length
(
)
]
;
NSMenuItem
*
item
=
nsMenuUtilsX
:
:
NativeMenuItemWithLocation
(
[
NSApp
mainMenu
]
locationString
true
)
;
if
(
item
&
&
!
[
item
hasSubmenu
]
)
{
NSMenu
*
parent
=
[
item
menu
]
;
if
(
parent
)
{
mozilla
:
:
AutoRestore
<
bool
>
autoRestore
(
nsMenuUtilsX
:
:
gIsSynchronouslyActivatingNativeMenuItemDuringTest
)
;
nsMenuUtilsX
:
:
gIsSynchronouslyActivatingNativeMenuItemDuringTest
=
true
;
[
parent
performActionForItemAtIndex
:
[
parent
indexOfItem
:
item
]
]
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
nsresult
nsChildView
:
:
ForceUpdateNativeMenuAt
(
const
nsAString
&
indexString
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsCocoaWindow
*
widget
=
GetAppWindowWidget
(
)
;
if
(
widget
)
{
nsMenuBarX
*
mb
=
widget
-
>
GetMenuBar
(
)
;
if
(
mb
)
{
if
(
indexString
.
IsEmpty
(
)
)
mb
-
>
ForceNativeMenuReload
(
)
;
else
mb
-
>
ForceUpdateNativeMenuAt
(
indexString
)
;
}
}
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
#
pragma
mark
-
#
ifdef
INVALIDATE_DEBUGGING
static
Boolean
KeyDown
(
const
UInt8
theKey
)
{
KeyMap
map
;
GetKeys
(
map
)
;
return
(
(
*
(
(
UInt8
*
)
map
+
(
theKey
>
>
3
)
)
>
>
(
theKey
&
7
)
)
&
1
)
!
=
0
;
}
static
Boolean
caps_lock
(
)
{
return
KeyDown
(
0x39
)
;
}
static
void
blinkRect
(
Rect
*
r
)
{
StRegionFromPool
oldClip
;
if
(
oldClip
!
=
NULL
)
:
:
GetClip
(
oldClip
)
;
:
:
ClipRect
(
r
)
;
:
:
InvertRect
(
r
)
;
UInt32
end
=
:
:
TickCount
(
)
+
5
;
while
(
:
:
TickCount
(
)
<
end
)
;
:
:
InvertRect
(
r
)
;
if
(
oldClip
!
=
NULL
)
:
:
SetClip
(
oldClip
)
;
}
static
void
blinkRgn
(
RgnHandle
rgn
)
{
StRegionFromPool
oldClip
;
if
(
oldClip
!
=
NULL
)
:
:
GetClip
(
oldClip
)
;
:
:
SetClip
(
rgn
)
;
:
:
InvertRgn
(
rgn
)
;
UInt32
end
=
:
:
TickCount
(
)
+
5
;
while
(
:
:
TickCount
(
)
<
end
)
;
:
:
InvertRgn
(
rgn
)
;
if
(
oldClip
!
=
NULL
)
:
:
SetClip
(
oldClip
)
;
}
#
endif
void
nsChildView
:
:
Invalidate
(
const
LayoutDeviceIntRect
&
aRect
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mView
|
|
!
mVisible
)
return
;
NS_ASSERTION
(
GetWindowRenderer
(
)
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_WR
"
Shouldn
'
t
need
to
invalidate
with
accelerated
OMTC
layers
!
"
)
;
EnsureContentLayerForMainThreadPainting
(
)
;
mContentLayerInvalidRegion
.
OrWith
(
aRect
.
Intersect
(
GetBounds
(
)
)
)
;
[
mView
markLayerForDisplay
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
bool
nsChildView
:
:
WidgetTypeSupportsAcceleration
(
)
{
return
true
;
}
bool
nsChildView
:
:
ShouldUseOffMainThreadCompositing
(
)
{
if
(
HasRemoteContent
(
)
)
{
return
true
;
}
if
(
[
mView
window
]
&
&
[
[
mView
window
]
isKindOfClass
:
[
PopupWindow
class
]
]
)
{
return
false
;
}
return
nsBaseWidget
:
:
ShouldUseOffMainThreadCompositing
(
)
;
}
#
pragma
mark
-
nsresult
nsChildView
:
:
DispatchEvent
(
WidgetGUIEvent
*
event
nsEventStatus
&
aStatus
)
{
RefPtr
<
nsChildView
>
kungFuDeathGrip
(
this
)
;
#
ifdef
DEBUG
debug_DumpEvent
(
stdout
event
-
>
mWidget
event
"
something
"
0
)
;
#
endif
if
(
event
-
>
mFlags
.
mIsSynthesizedForTests
)
{
WidgetKeyboardEvent
*
keyEvent
=
event
-
>
AsKeyboardEvent
(
)
;
if
(
keyEvent
)
{
nsresult
rv
=
mTextInputHandler
-
>
AttachNativeKeyEvent
(
*
keyEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
aStatus
=
nsEventStatus_eIgnore
;
nsIWidgetListener
*
listener
=
mWidgetListener
;
nsCOMPtr
<
nsIWidget
>
parentWidget
=
mParentWidget
;
if
(
!
listener
&
&
parentWidget
)
{
if
(
parentWidget
-
>
WindowType
(
)
=
=
eWindowType_popup
)
{
if
(
event
-
>
mWidget
)
{
listener
=
event
-
>
mWidget
-
>
GetWidgetListener
(
)
;
}
if
(
!
listener
)
{
event
-
>
mWidget
=
parentWidget
;
listener
=
parentWidget
-
>
GetWidgetListener
(
)
;
}
}
}
if
(
listener
)
aStatus
=
listener
-
>
HandleEvent
(
event
mUseAttachedEvents
)
;
return
NS_OK
;
}
nsIWidget
*
nsChildView
:
:
GetWidgetForListenerEvents
(
)
{
if
(
!
mWidgetListener
&
&
mParentWidget
&
&
mParentWidget
-
>
WindowType
(
)
=
=
eWindowType_popup
)
{
return
mParentWidget
;
}
return
this
;
}
void
nsChildView
:
:
WillPaintWindow
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidgetForListenerEvents
(
)
;
nsIWidgetListener
*
listener
=
widget
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
WillPaintWindow
(
widget
)
;
}
}
bool
nsChildView
:
:
PaintWindow
(
LayoutDeviceIntRegion
aRegion
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidgetForListenerEvents
(
)
;
nsIWidgetListener
*
listener
=
widget
-
>
GetWidgetListener
(
)
;
if
(
!
listener
)
return
false
;
bool
returnValue
=
false
;
bool
oldDispatchPaint
=
mIsDispatchPaint
;
mIsDispatchPaint
=
true
;
returnValue
=
listener
-
>
PaintWindow
(
widget
aRegion
)
;
listener
=
widget
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
listener
-
>
DidPaintWindow
(
)
;
}
mIsDispatchPaint
=
oldDispatchPaint
;
return
returnValue
;
}
bool
nsChildView
:
:
PaintWindowInDrawTarget
(
gfx
:
:
DrawTarget
*
aDT
const
LayoutDeviceIntRegion
&
aRegion
const
gfx
:
:
IntSize
&
aSurfaceSize
)
{
RefPtr
<
gfxContext
>
targetContext
=
gfxContext
:
:
CreateOrNull
(
aDT
)
;
MOZ_ASSERT
(
targetContext
)
;
targetContext
-
>
NewPath
(
)
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
LayoutDeviceIntRect
&
r
=
iter
.
Get
(
)
;
targetContext
-
>
Rectangle
(
gfxRect
(
r
.
x
r
.
y
r
.
width
r
.
height
)
)
;
aDT
-
>
ClearRect
(
gfx
:
:
Rect
(
r
.
ToUnknownRect
(
)
)
)
;
}
targetContext
-
>
Clip
(
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
mView
)
;
if
(
GetWindowRenderer
(
)
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_NONE
)
{
nsBaseWidget
:
:
AutoLayerManagerSetup
setupLayerManager
(
this
targetContext
BufferMode
:
:
BUFFER_NONE
)
;
return
PaintWindow
(
aRegion
)
;
}
return
false
;
}
void
nsChildView
:
:
EnsureContentLayerForMainThreadPainting
(
)
{
gfx
:
:
IntSize
size
=
GetBounds
(
)
.
Size
(
)
.
ToUnknownSize
(
)
;
if
(
mContentLayer
&
&
mContentLayer
-
>
GetSize
(
)
!
=
size
)
{
mNativeLayerRoot
-
>
RemoveLayer
(
mContentLayer
)
;
mContentLayer
=
nullptr
;
}
if
(
!
mContentLayer
)
{
mPoolHandle
=
SurfacePool
:
:
Create
(
0
)
-
>
GetHandleForGL
(
nullptr
)
;
RefPtr
<
NativeLayer
>
contentLayer
=
mNativeLayerRoot
-
>
CreateLayer
(
size
false
mPoolHandle
)
;
mNativeLayerRoot
-
>
AppendLayer
(
contentLayer
)
;
mContentLayer
=
contentLayer
-
>
AsNativeLayerCA
(
)
;
mContentLayer
-
>
SetSurfaceIsFlipped
(
false
)
;
mContentLayerInvalidRegion
=
GetBounds
(
)
;
}
}
void
nsChildView
:
:
PaintWindowInContentLayer
(
)
{
EnsureContentLayerForMainThreadPainting
(
)
;
mPoolHandle
-
>
OnBeginFrame
(
)
;
RefPtr
<
DrawTarget
>
dt
=
mContentLayer
-
>
NextSurfaceAsDrawTarget
(
gfx
:
:
IntRect
(
{
}
mContentLayer
-
>
GetSize
(
)
)
mContentLayerInvalidRegion
.
ToUnknownRegion
(
)
gfx
:
:
BackendType
:
:
SKIA
)
;
if
(
!
dt
)
{
return
;
}
PaintWindowInDrawTarget
(
dt
mContentLayerInvalidRegion
dt
-
>
GetSize
(
)
)
;
mContentLayer
-
>
NotifySurfaceReady
(
)
;
mContentLayerInvalidRegion
.
SetEmpty
(
)
;
mPoolHandle
-
>
OnEndFrame
(
)
;
}
void
nsChildView
:
:
HandleMainThreadCATransaction
(
)
{
WillPaintWindow
(
)
;
if
(
GetWindowRenderer
(
)
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_NONE
)
{
PaintWindowInContentLayer
(
)
;
}
else
{
PaintWindow
(
LayoutDeviceIntRegion
(
GetBounds
(
)
)
)
;
}
{
MutexAutoLock
lock
(
mCompositingLock
)
;
mNativeLayerRoot
-
>
CommitToScreen
(
)
;
}
MaybeScheduleUnsuspendAsyncCATransactions
(
)
;
}
#
pragma
mark
-
void
nsChildView
:
:
ReportMoveEvent
(
)
{
NotifyWindowMoved
(
mBounds
.
x
mBounds
.
y
)
;
}
void
nsChildView
:
:
ReportSizeEvent
(
)
{
if
(
mWidgetListener
)
mWidgetListener
-
>
WindowResized
(
this
mBounds
.
width
mBounds
.
height
)
;
}
#
pragma
mark
-
LayoutDeviceIntPoint
nsChildView
:
:
GetClientOffset
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSPoint
origin
=
[
mView
convertPoint
:
NSMakePoint
(
0
0
)
toView
:
nil
]
;
origin
.
y
=
[
[
mView
window
]
frame
]
.
size
.
height
-
origin
.
y
;
return
CocoaPointsToDevPixels
(
origin
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
LayoutDeviceIntPoint
nsChildView
:
:
WidgetToScreenOffset
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSPoint
origin
=
NSMakePoint
(
0
0
)
;
origin
=
[
mView
convertPoint
:
origin
toView
:
nil
]
;
origin
=
nsCocoaUtils
:
:
ConvertPointToScreen
(
[
mView
window
]
origin
)
;
FlipCocoaScreenCoordinate
(
origin
)
;
return
CocoaPointsToDevPixels
(
origin
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
LayoutDeviceIntPoint
(
0
0
)
)
;
}
nsresult
nsChildView
:
:
SetTitle
(
const
nsAString
&
title
)
{
return
NS_OK
;
}
nsresult
nsChildView
:
:
GetAttention
(
int32_t
aCycleCount
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
[
NSApp
requestUserAttention
:
NSInformationalRequest
]
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
bool
nsChildView
:
:
DoHasPendingInputEvent
(
)
{
return
sLastInputEventCount
!
=
GetCurrentInputEventCount
(
)
;
}
uint32_t
nsChildView
:
:
GetCurrentInputEventCount
(
)
{
static
const
CGEventType
eventTypes
[
]
=
{
kCGEventLeftMouseDown
kCGEventLeftMouseUp
kCGEventRightMouseDown
kCGEventRightMouseUp
kCGEventMouseMoved
kCGEventLeftMouseDragged
kCGEventRightMouseDragged
kCGEventKeyDown
kCGEventKeyUp
kCGEventScrollWheel
kCGEventTabletPointer
kCGEventOtherMouseDown
kCGEventOtherMouseUp
kCGEventOtherMouseDragged
}
;
uint32_t
eventCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
eventTypes
)
;
+
+
i
)
{
eventCount
+
=
CGEventSourceCounterForEventType
(
kCGEventSourceStateCombinedSessionState
eventTypes
[
i
]
)
;
}
return
eventCount
;
}
void
nsChildView
:
:
UpdateCurrentInputEventCount
(
)
{
sLastInputEventCount
=
GetCurrentInputEventCount
(
)
;
}
bool
nsChildView
:
:
HasPendingInputEvent
(
)
{
return
DoHasPendingInputEvent
(
)
;
}
#
pragma
mark
-
void
nsChildView
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
NS_ENSURE_TRUE_VOID
(
mTextInputHandler
)
;
if
(
mTextInputHandler
-
>
IsFocused
(
)
)
{
if
(
aContext
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
}
mInputContext
=
aContext
;
switch
(
aContext
.
mIMEState
.
mEnabled
)
{
case
IMEEnabled
:
:
Enabled
:
mTextInputHandler
-
>
SetASCIICapableOnly
(
false
)
;
mTextInputHandler
-
>
EnableIME
(
true
)
;
if
(
mInputContext
.
mIMEState
.
mOpen
!
=
IMEState
:
:
DONT_CHANGE_OPEN_STATE
)
{
mTextInputHandler
-
>
SetIMEOpenState
(
mInputContext
.
mIMEState
.
mOpen
=
=
IMEState
:
:
OPEN
)
;
}
break
;
case
IMEEnabled
:
:
Disabled
:
mTextInputHandler
-
>
SetASCIICapableOnly
(
false
)
;
mTextInputHandler
-
>
EnableIME
(
false
)
;
break
;
case
IMEEnabled
:
:
Password
:
mTextInputHandler
-
>
SetASCIICapableOnly
(
true
)
;
mTextInputHandler
-
>
EnableIME
(
false
)
;
break
;
default
:
NS_ERROR
(
"
not
implemented
!
"
)
;
}
}
InputContext
nsChildView
:
:
GetInputContext
(
)
{
switch
(
mInputContext
.
mIMEState
.
mEnabled
)
{
case
IMEEnabled
:
:
Enabled
:
if
(
mTextInputHandler
)
{
mInputContext
.
mIMEState
.
mOpen
=
mTextInputHandler
-
>
IsIMEOpened
(
)
?
IMEState
:
:
OPEN
:
IMEState
:
:
CLOSED
;
break
;
}
[
[
fallthrough
]
]
;
default
:
mInputContext
.
mIMEState
.
mOpen
=
IMEState
:
:
CLOSED
;
break
;
}
return
mInputContext
;
}
TextEventDispatcherListener
*
nsChildView
:
:
GetNativeTextEventDispatcherListener
(
)
{
if
(
NS_WARN_IF
(
!
mTextInputHandler
)
)
{
return
nullptr
;
}
return
mTextInputHandler
;
}
nsresult
nsChildView
:
:
AttachNativeKeyEvent
(
mozilla
:
:
WidgetKeyboardEvent
&
aEvent
)
{
NS_ENSURE_TRUE
(
mTextInputHandler
NS_ERROR_NOT_AVAILABLE
)
;
return
mTextInputHandler
-
>
AttachNativeKeyEvent
(
aEvent
)
;
}
bool
nsChildView
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
if
(
NS_WARN_IF
(
!
nsIWidget
:
:
GetEditCommands
(
aType
aEvent
aCommands
)
)
)
{
return
false
;
}
Maybe
<
WritingMode
>
writingMode
;
if
(
aEvent
.
NeedsToRemapNavigationKey
(
)
)
{
if
(
RefPtr
<
TextEventDispatcher
>
dispatcher
=
GetTextEventDispatcher
(
)
)
{
writingMode
=
dispatcher
-
>
MaybeQueryWritingModeAtSelection
(
)
;
}
}
NativeKeyBindings
*
keyBindings
=
NativeKeyBindings
:
:
GetInstance
(
aType
)
;
keyBindings
-
>
GetEditCommands
(
aEvent
writingMode
aCommands
)
;
return
true
;
}
NSView
<
mozView
>
*
nsChildView
:
:
GetEditorView
(
)
{
NSView
<
mozView
>
*
editorView
=
mView
;
WidgetQueryContentEvent
queryContentState
(
true
eQueryContentState
this
)
;
queryContentState
.
mNeedsToFlushLayout
=
false
;
DispatchWindowEvent
(
queryContentState
)
;
if
(
queryContentState
.
Succeeded
(
)
&
&
queryContentState
.
mReply
-
>
mFocusedWidget
)
{
NSView
<
mozView
>
*
view
=
static_cast
<
NSView
<
mozView
>
*
>
(
queryContentState
.
mReply
-
>
mFocusedWidget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
)
;
if
(
view
)
editorView
=
view
;
}
return
editorView
;
}
#
pragma
mark
-
void
nsChildView
:
:
CreateCompositor
(
)
{
nsBaseWidget
:
:
CreateCompositor
(
)
;
if
(
mCompositorBridgeChild
)
{
[
mView
setUsingOMTCompositor
:
true
]
;
}
}
void
nsChildView
:
:
ConfigureAPZCTreeManager
(
)
{
nsBaseWidget
:
:
ConfigureAPZCTreeManager
(
)
;
}
void
nsChildView
:
:
ConfigureAPZControllerThread
(
)
{
nsBaseWidget
:
:
ConfigureAPZControllerThread
(
)
;
}
bool
nsChildView
:
:
PreRender
(
WidgetRenderingContext
*
aContext
)
NO_THREAD_SAFETY_ANALYSIS
{
mCompositingLock
.
Lock
(
)
;
if
(
aContext
-
>
mGL
&
&
gfxPlatform
:
:
CanMigrateMacGPUs
(
)
)
{
GLContextCGL
:
:
Cast
(
aContext
-
>
mGL
)
-
>
MigrateToActiveGPU
(
)
;
}
return
true
;
}
void
nsChildView
:
:
PostRender
(
WidgetRenderingContext
*
aContext
)
NO_THREAD_SAFETY_ANALYSIS
{
mCompositingLock
.
Unlock
(
)
;
}
RefPtr
<
layers
:
:
NativeLayerRoot
>
nsChildView
:
:
GetNativeLayerRoot
(
)
{
return
mNativeLayerRoot
;
}
static
int32_t
FindTitlebarBottom
(
const
nsTArray
<
nsIWidget
:
:
ThemeGeometry
>
&
aThemeGeometries
int32_t
aWindowWidth
)
{
int32_t
titlebarBottom
=
0
;
for
(
auto
&
g
:
aThemeGeometries
)
{
if
(
g
.
mType
=
=
eThemeGeometryTypeTitlebar
&
&
g
.
mRect
.
X
(
)
<
=
0
&
&
g
.
mRect
.
XMost
(
)
>
=
aWindowWidth
&
&
g
.
mRect
.
Y
(
)
<
=
0
)
{
titlebarBottom
=
std
:
:
max
(
titlebarBottom
g
.
mRect
.
YMost
(
)
)
;
}
}
return
titlebarBottom
;
}
static
int32_t
FindUnifiedToolbarBottom
(
const
nsTArray
<
nsIWidget
:
:
ThemeGeometry
>
&
aThemeGeometries
int32_t
aWindowWidth
int32_t
aTitlebarBottom
)
{
int32_t
unifiedToolbarBottom
=
aTitlebarBottom
;
for
(
uint32_t
i
=
0
;
i
<
aThemeGeometries
.
Length
(
)
;
+
+
i
)
{
const
nsIWidget
:
:
ThemeGeometry
&
g
=
aThemeGeometries
[
i
]
;
if
(
(
g
.
mType
=
=
eThemeGeometryTypeToolbar
)
&
&
g
.
mRect
.
X
(
)
<
=
0
&
&
g
.
mRect
.
XMost
(
)
>
=
aWindowWidth
&
&
g
.
mRect
.
Y
(
)
<
=
aTitlebarBottom
)
{
unifiedToolbarBottom
=
std
:
:
max
(
unifiedToolbarBottom
g
.
mRect
.
YMost
(
)
)
;
}
}
return
unifiedToolbarBottom
;
}
static
LayoutDeviceIntRect
FindFirstRectOfType
(
const
nsTArray
<
nsIWidget
:
:
ThemeGeometry
>
&
aThemeGeometries
nsITheme
:
:
ThemeGeometryType
aThemeGeometryType
)
{
for
(
uint32_t
i
=
0
;
i
<
aThemeGeometries
.
Length
(
)
;
+
+
i
)
{
const
nsIWidget
:
:
ThemeGeometry
&
g
=
aThemeGeometries
[
i
]
;
if
(
g
.
mType
=
=
aThemeGeometryType
)
{
return
g
.
mRect
;
}
}
return
LayoutDeviceIntRect
(
)
;
}
void
nsChildView
:
:
UpdateThemeGeometries
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
if
(
!
[
mView
window
]
)
return
;
UpdateVibrancy
(
aThemeGeometries
)
;
if
(
!
[
[
mView
window
]
isKindOfClass
:
[
ToolbarWindow
class
]
]
)
return
;
int32_t
windowWidth
=
mBounds
.
width
;
int32_t
titlebarBottom
=
FindTitlebarBottom
(
aThemeGeometries
windowWidth
)
;
int32_t
unifiedToolbarBottom
=
FindUnifiedToolbarBottom
(
aThemeGeometries
windowWidth
titlebarBottom
)
;
int32_t
toolboxBottom
=
FindFirstRectOfType
(
aThemeGeometries
eThemeGeometryTypeToolbox
)
.
YMost
(
)
;
ToolbarWindow
*
win
=
(
ToolbarWindow
*
)
[
mView
window
]
;
int32_t
titlebarHeight
=
[
win
drawsContentsIntoWindowFrame
]
?
0
:
CocoaPointsToDevPixels
(
[
win
titlebarHeight
]
)
;
int32_t
devUnifiedHeight
=
titlebarHeight
+
unifiedToolbarBottom
;
[
win
setUnifiedToolbarHeight
:
DevPixelsToCocoaPoints
(
devUnifiedHeight
)
]
;
int32_t
sheetPositionDevPx
=
std
:
:
max
(
toolboxBottom
unifiedToolbarBottom
)
;
NSPoint
sheetPositionView
=
{
0
DevPixelsToCocoaPoints
(
sheetPositionDevPx
)
}
;
NSPoint
sheetPositionWindow
=
[
mView
convertPoint
:
sheetPositionView
toView
:
nil
]
;
[
win
setSheetAttachmentPosition
:
sheetPositionWindow
.
y
]
;
LayoutDeviceIntRect
windowButtonRect
=
FindFirstRectOfType
(
aThemeGeometries
eThemeGeometryTypeWindowButtons
)
;
[
win
placeWindowButtons
:
[
mView
convertRect
:
DevPixelsToCocoaPoints
(
windowButtonRect
)
toView
:
nil
]
]
;
}
static
Maybe
<
VibrancyType
>
ThemeGeometryTypeToVibrancyType
(
nsITheme
:
:
ThemeGeometryType
aThemeGeometryType
)
{
switch
(
aThemeGeometryType
)
{
case
eThemeGeometryTypeTooltip
:
return
Some
(
VibrancyType
:
:
TOOLTIP
)
;
case
eThemeGeometryTypeMenu
:
return
Some
(
VibrancyType
:
:
MENU
)
;
case
eThemeGeometryTypeHighlightedMenuItem
:
return
Some
(
VibrancyType
:
:
HIGHLIGHTED_MENUITEM
)
;
case
eThemeGeometryTypeSourceList
:
return
Some
(
VibrancyType
:
:
SOURCE_LIST
)
;
case
eThemeGeometryTypeSourceListSelection
:
return
Some
(
VibrancyType
:
:
SOURCE_LIST_SELECTION
)
;
case
eThemeGeometryTypeActiveSourceListSelection
:
return
Some
(
VibrancyType
:
:
ACTIVE_SOURCE_LIST_SELECTION
)
;
default
:
return
Nothing
(
)
;
}
}
static
LayoutDeviceIntRegion
GatherVibrantRegion
(
const
nsTArray
<
nsIWidget
:
:
ThemeGeometry
>
&
aThemeGeometries
VibrancyType
aVibrancyType
)
{
LayoutDeviceIntRegion
region
;
for
(
auto
&
geometry
:
aThemeGeometries
)
{
if
(
ThemeGeometryTypeToVibrancyType
(
geometry
.
mType
)
=
=
Some
(
aVibrancyType
)
)
{
region
.
OrWith
(
geometry
.
mRect
)
;
}
}
return
region
;
}
template
<
typename
Region
>
static
void
MakeRegionsNonOverlappingImpl
(
Region
&
aOutUnion
)
{
}
template
<
typename
Region
typename
.
.
.
Regions
>
static
void
MakeRegionsNonOverlappingImpl
(
Region
&
aOutUnion
Region
&
aFirst
Regions
&
.
.
.
aRest
)
{
MakeRegionsNonOverlappingImpl
(
aOutUnion
aRest
.
.
.
)
;
aFirst
.
SubOut
(
aOutUnion
)
;
aOutUnion
.
OrWith
(
aFirst
)
;
}
template
<
typename
Region
typename
.
.
.
Regions
>
static
void
MakeRegionsNonOverlapping
(
Region
&
aFirst
Regions
&
.
.
.
aRest
)
{
Region
unionOfAll
;
MakeRegionsNonOverlappingImpl
(
unionOfAll
aFirst
aRest
.
.
.
)
;
}
void
nsChildView
:
:
UpdateVibrancy
(
const
nsTArray
<
ThemeGeometry
>
&
aThemeGeometries
)
{
LayoutDeviceIntRegion
menuRegion
=
GatherVibrantRegion
(
aThemeGeometries
VibrancyType
:
:
MENU
)
;
LayoutDeviceIntRegion
tooltipRegion
=
GatherVibrantRegion
(
aThemeGeometries
VibrancyType
:
:
TOOLTIP
)
;
LayoutDeviceIntRegion
highlightedMenuItemRegion
=
GatherVibrantRegion
(
aThemeGeometries
VibrancyType
:
:
HIGHLIGHTED_MENUITEM
)
;
LayoutDeviceIntRegion
sourceListRegion
=
GatherVibrantRegion
(
aThemeGeometries
VibrancyType
:
:
SOURCE_LIST
)
;
LayoutDeviceIntRegion
sourceListSelectionRegion
=
GatherVibrantRegion
(
aThemeGeometries
VibrancyType
:
:
SOURCE_LIST_SELECTION
)
;
LayoutDeviceIntRegion
activeSourceListSelectionRegion
=
GatherVibrantRegion
(
aThemeGeometries
VibrancyType
:
:
ACTIVE_SOURCE_LIST_SELECTION
)
;
MakeRegionsNonOverlapping
(
menuRegion
tooltipRegion
highlightedMenuItemRegion
sourceListRegion
sourceListSelectionRegion
activeSourceListSelectionRegion
)
;
auto
&
vm
=
EnsureVibrancyManager
(
)
;
bool
changed
=
false
;
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
:
:
MENU
menuRegion
)
;
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
:
:
TOOLTIP
tooltipRegion
)
;
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
:
:
HIGHLIGHTED_MENUITEM
highlightedMenuItemRegion
)
;
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
:
:
SOURCE_LIST
sourceListRegion
)
;
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
:
:
SOURCE_LIST_SELECTION
sourceListSelectionRegion
)
;
changed
|
=
vm
.
UpdateVibrantRegion
(
VibrancyType
:
:
ACTIVE_SOURCE_LIST_SELECTION
activeSourceListSelectionRegion
)
;
if
(
changed
)
{
SuspendAsyncCATransactions
(
)
;
}
}
mozilla
:
:
VibrancyManager
&
nsChildView
:
:
EnsureVibrancyManager
(
)
{
MOZ_ASSERT
(
mView
"
Only
call
this
once
we
have
a
view
!
"
)
;
if
(
!
mVibrancyManager
)
{
mVibrancyManager
=
MakeUnique
<
VibrancyManager
>
(
*
this
[
mView
vibrancyViewsContainer
]
)
;
}
return
*
mVibrancyManager
;
}
void
nsChildView
:
:
UpdateBoundsFromView
(
)
{
auto
oldSize
=
mBounds
.
Size
(
)
;
mBounds
=
CocoaPointsToDevPixels
(
[
mView
frame
]
)
;
if
(
mBounds
.
Size
(
)
!
=
oldSize
)
{
SuspendAsyncCATransactions
(
)
;
}
}
interface
NonDraggableView
:
NSView
end
implementation
NonDraggableView
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
NO
;
}
-
(
NSView
*
)
hitTest
:
(
NSPoint
)
aPoint
{
return
nil
;
}
-
(
NSRect
)
_opaqueRectForWindowMoveWhenInTitlebar
{
return
[
self
visibleRect
]
;
}
end
void
nsChildView
:
:
UpdateWindowDraggingRegion
(
const
LayoutDeviceIntRegion
&
aRegion
)
{
LayoutDeviceIntRegion
nonDraggable
;
nonDraggable
.
Sub
(
LayoutDeviceIntRect
(
0
0
mBounds
.
width
mBounds
.
height
)
aRegion
)
;
__block
bool
changed
=
false
;
ManipulateViewWithoutNeedingDisplay
(
mView
^
(
)
{
changed
=
mNonDraggableRegion
.
UpdateRegion
(
nonDraggable
*
this
[
mView
nonDraggableViewsContainer
]
^
(
)
{
return
[
[
NonDraggableView
alloc
]
initWithFrame
:
NSZeroRect
]
;
}
)
;
}
)
;
if
(
changed
)
{
[
[
mView
window
]
setMovableByWindowBackground
:
NO
]
;
[
[
mView
window
]
setMovableByWindowBackground
:
YES
]
;
}
}
nsEventStatus
nsChildView
:
:
DispatchAPZInputEvent
(
InputData
&
aEvent
)
{
APZEventResult
result
;
if
(
mAPZC
)
{
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aEvent
)
;
}
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
result
.
GetStatus
(
)
;
}
if
(
aEvent
.
mInputType
=
=
PINCHGESTURE_INPUT
)
{
PinchGestureInput
&
pinchEvent
=
aEvent
.
AsPinchGestureInput
(
)
;
WidgetWheelEvent
wheelEvent
=
pinchEvent
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
wheelEvent
result
)
;
}
else
if
(
aEvent
.
mInputType
=
=
TAPGESTURE_INPUT
)
{
TapGestureInput
&
tapEvent
=
aEvent
.
AsTapGestureInput
(
)
;
WidgetSimpleGestureEvent
gestureEvent
=
tapEvent
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
gestureEvent
result
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
)
;
}
return
result
.
GetStatus
(
)
;
}
void
nsChildView
:
:
DispatchAPZWheelInputEvent
(
InputData
&
aEvent
bool
aCanTriggerSwipe
)
{
if
(
mSwipeTracker
&
&
aEvent
.
mInputType
=
=
PANGESTURE_INPUT
)
{
nsEventStatus
status
=
mSwipeTracker
-
>
ProcessEvent
(
aEvent
.
AsPanGestureInput
(
)
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
}
WidgetWheelEvent
event
(
true
eWheel
this
)
;
if
(
mAPZC
)
{
APZEventResult
result
;
switch
(
aEvent
.
mInputType
)
{
case
PANGESTURE_INPUT
:
{
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aEvent
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
event
=
MayStartSwipeForAPZ
(
aEvent
.
AsPanGestureInput
(
)
result
CanTriggerSwipe
{
aCanTriggerSwipe
}
)
;
break
;
}
case
SCROLLWHEEL_INPUT
:
{
event
=
aEvent
.
AsScrollWheelInput
(
)
.
ToWidgetEvent
(
this
)
;
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
event
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
break
;
}
;
default
:
MOZ_CRASH
(
"
unsupported
event
type
"
)
;
return
;
}
if
(
event
.
mMessage
=
=
eWheel
&
&
(
event
.
mDeltaX
!
=
0
|
|
event
.
mDeltaY
!
=
0
)
)
{
ProcessUntransformedAPZEvent
(
&
event
result
)
;
}
return
;
}
nsEventStatus
status
;
switch
(
aEvent
.
mInputType
)
{
case
PANGESTURE_INPUT
:
{
if
(
MayStartSwipeForNonAPZ
(
aEvent
.
AsPanGestureInput
(
)
CanTriggerSwipe
{
aCanTriggerSwipe
}
)
)
{
return
;
}
event
=
aEvent
.
AsPanGestureInput
(
)
.
ToWidgetEvent
(
this
)
;
break
;
}
case
SCROLLWHEEL_INPUT
:
{
event
=
aEvent
.
AsScrollWheelInput
(
)
.
ToWidgetEvent
(
this
)
;
break
;
}
default
:
MOZ_CRASH
(
"
unexpected
event
type
"
)
;
return
;
}
if
(
event
.
mMessage
=
=
eWheel
&
&
(
event
.
mDeltaX
!
=
0
|
|
event
.
mDeltaY
!
=
0
)
)
{
DispatchEvent
(
&
event
status
)
;
}
}
void
nsChildView
:
:
DispatchDoubleTapGesture
(
TimeStamp
aEventTimeStamp
LayoutDeviceIntPoint
aScreenPosition
mozilla
:
:
Modifiers
aModifiers
)
{
if
(
StaticPrefs
:
:
apz_mac_enable_double_tap_zoom_touchpad_gesture
(
)
)
{
PRIntervalTime
eventIntervalTime
=
PR_IntervalNow
(
)
;
TapGestureInput
event
{
TapGestureInput
:
:
TAPGESTURE_DOUBLE
eventIntervalTime
aEventTimeStamp
ViewAs
<
ScreenPixel
>
(
aScreenPosition
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
aModifiers
}
;
DispatchAPZInputEvent
(
event
)
;
}
else
{
WidgetSimpleGestureEvent
geckoEvent
(
true
eTapGesture
this
)
;
geckoEvent
.
mRefPoint
=
aScreenPosition
;
geckoEvent
.
mModifiers
=
aModifiers
;
geckoEvent
.
mTime
=
PR_IntervalNow
(
)
;
geckoEvent
.
mTimeStamp
=
aEventTimeStamp
;
geckoEvent
.
mClickCount
=
1
;
DispatchWindowEvent
(
geckoEvent
)
;
}
}
void
nsChildView
:
:
LookUpDictionary
(
const
nsAString
&
aText
const
nsTArray
<
mozilla
:
:
FontRange
>
&
aFontRangeArray
const
bool
aIsVertical
const
LayoutDeviceIntPoint
&
aPoint
)
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NSMutableAttributedString
*
attrStr
=
nsCocoaUtils
:
:
GetNSMutableAttributedString
(
aText
aFontRangeArray
aIsVertical
BackingScaleFactor
(
)
)
;
NSPoint
pt
=
nsCocoaUtils
:
:
DevPixelsToCocoaPoints
(
aPoint
BackingScaleFactor
(
)
)
;
NSDictionary
*
attributes
=
[
attrStr
attributesAtIndex
:
0
effectiveRange
:
nil
]
;
NSFont
*
font
=
[
attributes
objectForKey
:
NSFontAttributeName
]
;
if
(
font
)
{
if
(
aIsVertical
)
{
pt
.
x
-
=
[
font
descender
]
;
}
else
{
pt
.
y
+
=
[
font
ascender
]
;
}
}
[
mView
showDefinitionForAttributedString
:
attrStr
atPoint
:
pt
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
ifdef
ACCESSIBILITY
already_AddRefed
<
a11y
:
:
LocalAccessible
>
nsChildView
:
:
GetDocumentAccessible
(
)
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
nullptr
;
if
(
mAccessible
&
&
mAccessible
-
>
IsAlive
(
)
)
{
RefPtr
<
a11y
:
:
LocalAccessible
>
ret
;
CallQueryReferent
(
mAccessible
.
get
(
)
static_cast
<
a11y
:
:
LocalAccessible
*
*
>
(
getter_AddRefs
(
ret
)
)
)
;
return
ret
.
forget
(
)
;
}
RefPtr
<
a11y
:
:
LocalAccessible
>
acc
=
GetRootAccessible
(
)
;
mAccessible
=
do_GetWeakReference
(
acc
.
get
(
)
)
;
return
acc
.
forget
(
)
;
}
#
endif
class
WidgetsReleaserRunnable
final
:
public
mozilla
:
:
Runnable
{
public
:
explicit
WidgetsReleaserRunnable
(
nsTArray
<
nsCOMPtr
<
nsIWidget
>
>
&
&
aWidgetArray
)
:
mozilla
:
:
Runnable
(
"
WidgetsReleaserRunnable
"
)
mWidgetArray
(
std
:
:
move
(
aWidgetArray
)
)
{
}
private
:
nsTArray
<
nsCOMPtr
<
nsIWidget
>
>
mWidgetArray
;
}
;
#
pragma
mark
-
interface
ViewRegionContainerView
:
NSView
{
}
end
implementation
ViewRegionContainerView
-
(
NSView
*
)
hitTest
:
(
NSPoint
)
aPoint
{
return
nil
;
}
-
(
BOOL
)
isFlipped
{
return
[
[
self
superview
]
isFlipped
]
;
}
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
[
[
self
superview
]
mouseDownCanMoveWindow
]
;
}
end
implementation
ChildView
NSPasteboard
*
globalDragPboard
=
nil
;
NSView
*
gLastDragView
=
nil
;
NSEvent
*
gLastDragMouseDownEvent
=
nil
;
+
(
void
)
initialize
{
static
BOOL
initialized
=
NO
;
if
(
!
initialized
)
{
NSArray
*
types
=
[
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
;
[
NSApp
registerServicesMenuSendTypes
:
types
returnTypes
:
types
]
;
initialized
=
YES
;
}
}
+
(
void
)
registerViewForDraggedTypes
:
(
NSView
*
)
aView
{
[
aView
registerForDraggedTypes
:
[
NSArray
arrayWithObjects
:
[
UTIHelper
stringFromPboardType
:
NSFilenamesPboardType
]
[
UTIHelper
stringFromPboardType
:
kMozFileUrlsPboardType
]
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kPasteboardTypeFileURLPromise
]
[
UTIHelper
stringFromPboardType
:
kMozWildcardPboardType
]
[
UTIHelper
stringFromPboardType
:
kPublicUrlPboardType
]
[
UTIHelper
stringFromPboardType
:
kPublicUrlNamePboardType
]
[
UTIHelper
stringFromPboardType
:
kUrlsWithTitlesPboardType
]
nil
]
]
;
}
-
(
id
)
initWithFrame
:
(
NSRect
)
inFrame
geckoChild
:
(
nsChildView
*
)
inChild
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
(
self
=
[
super
initWithFrame
:
inFrame
]
)
)
{
mGeckoChild
=
inChild
;
mBlockedLastMouseDown
=
NO
;
mExpectingWheelStop
=
NO
;
mLastMouseDownEvent
=
nil
;
mLastKeyDownEvent
=
nil
;
mClickThroughMouseDownEvent
=
nil
;
mDragService
=
nullptr
;
mGestureState
=
eGestureState_None
;
mCumulativeRotation
=
0
.
0
;
mIsUpdatingLayer
=
NO
;
[
self
setFocusRingType
:
NSFocusRingTypeNone
]
;
#
ifdef
__LP64__
mCancelSwipeAnimation
=
nil
;
#
endif
mNonDraggableViewsContainer
=
[
[
ViewRegionContainerView
alloc
]
initWithFrame
:
[
self
bounds
]
]
;
mVibrancyViewsContainer
=
[
[
ViewRegionContainerView
alloc
]
initWithFrame
:
[
self
bounds
]
]
;
[
mNonDraggableViewsContainer
setAutoresizingMask
:
NSViewWidthSizable
|
NSViewHeightSizable
]
;
[
mVibrancyViewsContainer
setAutoresizingMask
:
NSViewWidthSizable
|
NSViewHeightSizable
]
;
[
self
addSubview
:
mNonDraggableViewsContainer
]
;
[
self
addSubview
:
mVibrancyViewsContainer
]
;
mPixelHostingView
=
[
[
PixelHostingView
alloc
]
initWithFrame
:
[
self
bounds
]
]
;
[
mPixelHostingView
setAutoresizingMask
:
NSViewWidthSizable
|
NSViewHeightSizable
]
;
[
self
addSubview
:
mPixelHostingView
]
;
mRootCALayer
=
[
[
CALayer
layer
]
retain
]
;
mRootCALayer
.
position
=
NSZeroPoint
;
mRootCALayer
.
bounds
=
NSZeroRect
;
mRootCALayer
.
anchorPoint
=
NSZeroPoint
;
mRootCALayer
.
contentsGravity
=
kCAGravityTopLeft
;
[
[
mPixelHostingView
layer
]
addSublayer
:
mRootCALayer
]
;
mLastPressureStage
=
0
;
}
[
ChildView
registerViewForDraggedTypes
:
self
]
;
return
self
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
NSTextInputContext
*
)
inputContext
{
if
(
!
mGeckoChild
)
{
return
nil
;
}
return
[
super
inputContext
]
;
}
-
(
void
)
installTextInputHandler
:
(
TextInputHandler
*
)
aHandler
{
mTextInputHandler
=
aHandler
;
}
-
(
void
)
uninstallTextInputHandler
{
mTextInputHandler
=
nullptr
;
}
-
(
NSView
*
)
vibrancyViewsContainer
{
return
mVibrancyViewsContainer
;
}
-
(
NSView
*
)
nonDraggableViewsContainer
{
return
mNonDraggableViewsContainer
;
}
-
(
NSView
*
)
pixelHostingView
{
return
mPixelHostingView
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
mLastMouseDownEvent
release
]
;
[
mLastKeyDownEvent
release
]
;
[
mClickThroughMouseDownEvent
release
]
;
ChildViewMouseTracker
:
:
OnDestroyView
(
self
)
;
[
mVibrancyViewsContainer
removeFromSuperview
]
;
[
mVibrancyViewsContainer
release
]
;
[
mNonDraggableViewsContainer
removeFromSuperview
]
;
[
mNonDraggableViewsContainer
release
]
;
[
mPixelHostingView
removeFromSuperview
]
;
[
mPixelHostingView
release
]
;
[
mRootCALayer
release
]
;
if
(
gLastDragView
=
=
self
)
{
gLastDragView
=
nil
;
}
[
super
dealloc
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
widgetDestroyed
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
OnDestroyWidget
(
mGeckoChild
)
;
mTextInputHandler
=
nullptr
;
}
mGeckoChild
=
nullptr
;
NS_IF_RELEASE
(
mDragService
)
;
}
-
(
nsIWidget
*
)
widget
{
return
static_cast
<
nsIWidget
*
>
(
mGeckoChild
)
;
}
-
(
NSString
*
)
description
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
[
NSString
stringWithFormat
:
"
ChildView
%
p
gecko
child
%
p
frame
%
"
self
mGeckoChild
NSStringFromRect
(
[
self
frame
]
)
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
BOOL
)
isFlipped
{
return
YES
;
}
-
(
BOOL
)
acceptsFirstResponder
{
return
YES
;
}
-
(
BOOL
)
acceptsFirstMouse
:
(
NSEvent
*
)
aEvent
{
if
(
!
[
[
self
window
]
isKindOfClass
:
[
PopupWindow
class
]
]
)
{
mClickThroughMouseDownEvent
=
[
aEvent
retain
]
;
}
return
YES
;
}
-
(
BOOL
)
mouseDownCanMoveWindow
{
return
YES
;
}
-
(
void
)
viewDidChangeBackingProperties
{
[
super
viewDidChangeBackingProperties
]
;
if
(
mGeckoChild
)
{
mGeckoChild
-
>
BackingScaleFactorChanged
(
)
;
}
}
-
(
BOOL
)
isCoveringTitlebar
{
return
[
[
self
window
]
isKindOfClass
:
[
BaseWindow
class
]
]
&
&
[
(
BaseWindow
*
)
[
self
window
]
mainChildView
]
=
=
self
&
&
[
(
BaseWindow
*
)
[
self
window
]
drawsContentsIntoWindowFrame
]
;
}
-
(
void
)
viewWillStartLiveResize
{
nsCocoaWindow
*
windowWidget
=
mGeckoChild
?
mGeckoChild
-
>
GetAppWindowWidget
(
)
:
nullptr
;
if
(
windowWidget
)
{
windowWidget
-
>
NotifyLiveResizeStarted
(
)
;
}
}
-
(
void
)
viewDidEndLiveResize
{
nsCocoaWindow
*
windowWidget
=
mGeckoChild
?
mGeckoChild
-
>
GetAppWindowWidget
(
)
:
nullptr
;
if
(
windowWidget
)
{
windowWidget
-
>
NotifyLiveResizeStopped
(
)
;
}
}
-
(
void
)
markLayerForDisplay
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mIsUpdatingLayer
)
{
[
[
mPixelHostingView
layer
]
setNeedsDisplay
]
;
}
}
-
(
void
)
ensureNextCompositeIsAtomicWithMainThreadPaint
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mGeckoChild
)
{
mGeckoChild
-
>
SuspendAsyncCATransactions
(
)
;
}
}
-
(
void
)
updateRootCALayer
{
if
(
NS_IsMainThread
(
)
&
&
mGeckoChild
)
{
MOZ_RELEASE_ASSERT
(
!
mIsUpdatingLayer
"
Re
-
entrant
layer
display
?
"
)
;
mIsUpdatingLayer
=
YES
;
mGeckoChild
-
>
HandleMainThreadCATransaction
(
)
;
mIsUpdatingLayer
=
NO
;
}
}
-
(
CALayer
*
)
rootCALayer
{
return
mRootCALayer
;
}
-
(
void
)
maybeInitContextMenuTracking
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
mozilla
:
:
widget
:
:
NativeMenuSupport
:
:
ShouldUseNativeContextMenus
(
)
)
{
return
;
}
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
NS_ENSURE_TRUE_VOID
(
rollupListener
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
rollupListener
-
>
GetRollupWidget
(
)
;
NS_ENSURE_TRUE_VOID
(
widget
)
;
NSWindow
*
popupWindow
=
(
NSWindow
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
!
popupWindow
|
|
!
[
popupWindow
isKindOfClass
:
[
PopupWindow
class
]
]
)
return
;
[
[
NSDistributedNotificationCenter
defaultCenter
]
postNotificationName
:
"
com
.
apple
.
HIToolbox
.
beginMenuTrackingNotification
"
object
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
;
[
(
PopupWindow
*
)
popupWindow
setIsContextMenu
:
YES
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
maybeRollup
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
BOOL
consumeEvent
=
NO
;
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
NS_ENSURE_TRUE
(
rollupListener
false
)
;
BOOL
isWheelTypeEvent
=
[
theEvent
type
]
=
=
NSEventTypeScrollWheel
|
|
[
theEvent
type
]
=
=
NSEventTypeMagnify
|
|
[
theEvent
type
]
=
=
NSEventTypeSmartMagnify
;
if
(
!
isWheelTypeEvent
&
&
rollupListener
-
>
RollupNativeMenu
(
)
)
{
return
NO
;
}
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
rollupWidget
)
{
NSWindow
*
currentPopup
=
static_cast
<
NSWindow
*
>
(
rollupWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
)
;
if
(
!
nsCocoaUtils
:
:
IsEventOverWindow
(
theEvent
currentPopup
)
)
{
bool
shouldRollup
=
true
;
if
(
isWheelTypeEvent
)
{
shouldRollup
=
rollupListener
-
>
ShouldRollupOnMouseWheelEvent
(
)
;
consumeEvent
=
rollupListener
-
>
ShouldConsumeOnMouseWheelEvent
(
)
;
}
uint32_t
popupsToRollup
=
UINT32_MAX
;
AutoTArray
<
nsIWidget
*
5
>
widgetChain
;
uint32_t
sameTypeCount
=
rollupListener
-
>
GetSubmenuWidgetChain
(
&
widgetChain
)
;
for
(
uint32_t
i
=
0
;
i
<
widgetChain
.
Length
(
)
;
i
+
+
)
{
nsIWidget
*
widget
=
widgetChain
[
i
]
;
NSWindow
*
currWindow
=
(
NSWindow
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
nsCocoaUtils
:
:
IsEventOverWindow
(
theEvent
currWindow
)
)
{
if
(
i
<
sameTypeCount
)
{
shouldRollup
=
false
;
}
else
{
popupsToRollup
=
sameTypeCount
;
}
break
;
}
}
if
(
shouldRollup
)
{
if
(
[
theEvent
type
]
=
=
NSEventTypeLeftMouseDown
)
{
NSPoint
point
=
[
NSEvent
mouseLocation
]
;
FlipCocoaScreenCoordinate
(
point
)
;
LayoutDeviceIntPoint
devPoint
=
mGeckoChild
-
>
CocoaPointsToDevPixels
(
point
)
;
consumeEvent
=
(
BOOL
)
rollupListener
-
>
Rollup
(
popupsToRollup
true
&
devPoint
nullptr
)
;
}
else
{
consumeEvent
=
(
BOOL
)
rollupListener
-
>
Rollup
(
popupsToRollup
true
nullptr
nullptr
)
;
}
}
}
}
return
consumeEvent
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
void
)
swipeWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
float
deltaX
=
[
anEvent
deltaX
]
;
float
deltaY
=
[
anEvent
deltaY
]
;
WidgetSimpleGestureEvent
geckoEvent
(
true
eSwipeGesture
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
if
(
deltaX
>
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_LEFT
;
else
if
(
deltaX
<
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_RIGHT
;
if
(
deltaY
>
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_UP
;
else
if
(
deltaY
<
0
.
0
)
geckoEvent
.
mDirection
|
=
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_DOWN
;
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
magnifyWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
[
self
maybeRollup
:
anEvent
]
)
{
return
;
}
if
(
!
mGeckoChild
)
{
return
;
}
if
(
mGestureState
=
=
eGestureState_RotateGesture
&
&
[
anEvent
phase
]
!
=
NSEventPhaseBegan
)
{
return
;
}
mGestureState
=
eGestureState_MagnifyGesture
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
anEvent
[
self
window
]
)
;
ScreenPoint
position
=
ViewAs
<
ScreenPixel
>
(
[
self
convertWindowCoordinatesRoundDown
:
locationInWindow
]
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
ExternalPoint
screenOffset
=
ViewAs
<
ExternalPixel
>
(
mGeckoChild
-
>
WidgetToScreenOffset
(
)
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
PRIntervalTime
eventIntervalTime
=
PR_IntervalNow
(
)
;
TimeStamp
eventTimeStamp
=
nsCocoaUtils
:
:
GetEventTimeStamp
(
[
anEvent
timestamp
]
)
;
NSEventPhase
eventPhase
=
[
anEvent
phase
]
;
PinchGestureInput
:
:
PinchGestureType
pinchGestureType
;
switch
(
eventPhase
)
{
case
NSEventPhaseBegan
:
{
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_START
;
break
;
}
case
NSEventPhaseChanged
:
{
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_SCALE
;
break
;
}
case
NSEventPhaseEnded
:
{
pinchGestureType
=
PinchGestureInput
:
:
PINCHGESTURE_END
;
mGestureState
=
eGestureState_None
;
break
;
}
default
:
{
NS_WARNING
(
"
Unexpected
phase
for
pinch
gesture
event
.
"
)
;
return
;
}
}
PinchGestureInput
event
{
pinchGestureType
PinchGestureInput
:
:
TRACKPAD
eventIntervalTime
eventTimeStamp
screenOffset
position
100
.
0
100
.
0
*
(
1
.
0
-
[
anEvent
magnification
]
)
nsCocoaUtils
:
:
ModifiersForEvent
(
anEvent
)
}
;
mGeckoChild
-
>
DispatchAPZInputEvent
(
event
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
smartMagnifyWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
|
|
[
self
beginOrEndGestureForEventPhase
:
anEvent
]
)
{
return
;
}
if
(
[
self
maybeRollup
:
anEvent
]
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
StaticPrefs
:
:
apz_mac_enable_double_tap_zoom_touchpad_gesture
(
)
)
{
TimeStamp
eventTimeStamp
=
nsCocoaUtils
:
:
GetEventTimeStamp
(
[
anEvent
timestamp
]
)
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
anEvent
[
self
window
]
)
;
LayoutDevicePoint
position
=
[
self
convertWindowCoordinatesRoundDown
:
locationInWindow
]
;
mGeckoChild
-
>
DispatchDoubleTapGesture
(
eventTimeStamp
RoundedToInt
(
position
)
nsCocoaUtils
:
:
ModifiersForEvent
(
anEvent
)
)
;
}
else
{
WidgetSimpleGestureEvent
geckoEvent
(
true
eTapGesture
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mClickCount
=
1
;
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
}
mGestureState
=
eGestureState_None
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rotateWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
|
|
[
self
beginOrEndGestureForEventPhase
:
anEvent
]
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
float
rotation
=
[
anEvent
rotation
]
;
EventMessage
msg
;
switch
(
mGestureState
)
{
case
eGestureState_StartGesture
:
msg
=
eRotateGestureStart
;
mGestureState
=
eGestureState_RotateGesture
;
break
;
case
eGestureState_RotateGesture
:
msg
=
eRotateGestureUpdate
;
break
;
case
eGestureState_None
:
case
eGestureState_MagnifyGesture
:
default
:
return
;
}
WidgetSimpleGestureEvent
geckoEvent
(
true
msg
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mDelta
=
-
rotation
;
if
(
rotation
>
0
.
0
)
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_COUNTERCLOCKWISE
;
}
else
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_CLOCKWISE
;
}
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
mCumulativeRotation
+
=
rotation
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
bool
)
beginOrEndGestureForEventPhase
:
(
NSEvent
*
)
aEvent
{
if
(
!
aEvent
)
{
return
false
;
}
if
(
aEvent
.
phase
=
=
NSEventPhaseBegan
)
{
[
self
beginGestureWithEvent
:
aEvent
]
;
return
true
;
}
if
(
aEvent
.
phase
=
=
NSEventPhaseEnded
|
|
aEvent
.
phase
=
=
NSEventPhaseCancelled
)
{
[
self
endGestureWithEvent
:
aEvent
]
;
return
true
;
}
return
false
;
}
-
(
void
)
beginGestureWithEvent
:
(
NSEvent
*
)
aEvent
{
if
(
!
aEvent
)
{
return
;
}
mGestureState
=
eGestureState_StartGesture
;
mCumulativeRotation
=
0
.
0
;
}
-
(
void
)
endGestureWithEvent
:
(
NSEvent
*
)
anEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
anEvent
|
|
!
mGeckoChild
)
{
mGestureState
=
eGestureState_None
;
mCumulativeRotation
=
0
.
0
;
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
switch
(
mGestureState
)
{
case
eGestureState_RotateGesture
:
{
WidgetSimpleGestureEvent
geckoEvent
(
true
eRotateGesture
mGeckoChild
)
;
[
self
convertCocoaMouseEvent
:
anEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mDelta
=
-
mCumulativeRotation
;
if
(
mCumulativeRotation
>
0
.
0
)
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_COUNTERCLOCKWISE
;
}
else
{
geckoEvent
.
mDirection
=
dom
:
:
SimpleGestureEvent_Binding
:
:
ROTATION_CLOCKWISE
;
}
mGeckoChild
-
>
DispatchWindowEvent
(
geckoEvent
)
;
}
break
;
case
eGestureState_MagnifyGesture
:
case
eGestureState_None
:
case
eGestureState_StartGesture
:
default
:
break
;
}
mGestureState
=
eGestureState_None
;
mCumulativeRotation
=
0
.
0
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
bool
)
shouldConsiderStartingSwipeFromEvent
:
(
NSEvent
*
)
anEvent
{
NSEventPhase
eventPhase
=
[
anEvent
phase
]
;
return
[
anEvent
type
]
=
=
NSEventTypeScrollWheel
&
&
eventPhase
=
=
NSEventPhaseBegan
&
&
[
anEvent
hasPreciseScrollingDeltas
]
&
&
[
NSEvent
isSwipeTrackingFromScrollEventsEnabled
]
;
}
-
(
void
)
setUsingOMTCompositor
:
(
BOOL
)
aUseOMTC
{
mUsingOMTCompositor
=
aUseOMTC
;
}
-
(
BOOL
)
shouldDelayWindowOrderingForEvent
:
(
NSEvent
*
)
aEvent
{
if
(
!
[
[
self
window
]
isKindOfClass
:
[
PopupWindow
class
]
]
)
return
NO
;
return
!
[
[
self
window
]
parentWindow
]
;
}
-
(
void
)
mouseDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
[
self
shouldDelayWindowOrderingForEvent
:
theEvent
]
)
{
[
NSApp
preventWindowOrdering
]
;
}
if
(
mLastMouseDownEvent
=
=
theEvent
)
{
[
mLastMouseDownEvent
release
]
;
mLastMouseDownEvent
=
nil
;
return
;
}
else
{
[
mLastMouseDownEvent
release
]
;
mLastMouseDownEvent
=
[
theEvent
retain
]
;
}
[
gLastDragMouseDownEvent
release
]
;
gLastDragMouseDownEvent
=
[
theEvent
retain
]
;
gLastDragView
=
self
;
BOOL
isClickThrough
=
(
theEvent
=
=
mClickThroughMouseDownEvent
)
;
[
mClickThroughMouseDownEvent
release
]
;
mClickThroughMouseDownEvent
=
nil
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
[
self
maybeRollup
:
theEvent
]
|
|
!
ChildViewMouseTracker
:
:
WindowAcceptsEvent
(
[
self
window
]
theEvent
self
isClickThrough
)
)
{
mBlockedLastMouseDown
=
YES
;
return
;
}
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseDown
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
NSInteger
clickCount
=
[
theEvent
clickCount
]
;
if
(
mBlockedLastMouseDown
&
&
clickCount
>
1
)
{
clickCount
-
-
;
}
geckoEvent
.
mClickCount
=
clickCount
;
if
(
!
StaticPrefs
:
:
dom_event_treat_ctrl_click_as_right_click_disabled
(
)
&
&
geckoEvent
.
IsControl
(
)
)
{
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
}
else
{
geckoEvent
.
mButton
=
MouseButton
:
:
ePrimary
;
geckoEvent
.
mClickEventPrevented
=
geckoEvent
.
IsControl
(
)
;
}
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
mBlockedLastMouseDown
=
NO
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
mouseUp
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
gLastDragView
=
nil
;
if
(
!
mGeckoChild
|
|
mBlockedLastMouseDown
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
WidgetMouseEvent
geckoEvent
(
true
eMouseUp
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
if
(
!
StaticPrefs
:
:
dom_event_treat_ctrl_click_as_right_click_disabled
(
)
&
&
(
[
theEvent
modifierFlags
]
&
NSEventModifierFlagControl
)
)
{
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
}
else
{
geckoEvent
.
mButton
=
MouseButton
:
:
ePrimary
;
}
LayoutDeviceIntPoint
pos
=
geckoEvent
.
mRefPoint
;
bool
defaultPrevented
=
(
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
.
mContentStatus
=
=
nsEventStatus_eConsumeNoDefault
)
;
if
(
!
mGeckoChild
)
{
return
;
}
if
(
!
defaultPrevented
&
&
[
theEvent
clickCount
]
=
=
2
&
&
!
mGeckoChild
-
>
GetNonDraggableRegion
(
)
.
Contains
(
pos
.
x
pos
.
y
)
)
{
if
(
nsCocoaUtils
:
:
ShouldZoomOnTitlebarDoubleClick
(
)
)
{
[
[
self
window
]
performZoom
:
nil
]
;
}
else
if
(
nsCocoaUtils
:
:
ShouldMinimizeOnTitlebarDoubleClick
(
)
)
{
[
[
self
window
]
performMiniaturize
:
nil
]
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
sendMouseEnterOrExitEvent
:
(
NSEvent
*
)
aEvent
enter
:
(
BOOL
)
aEnter
exitFrom
:
(
WidgetMouseEvent
:
:
ExitFrom
)
aExitFrom
{
if
(
!
mGeckoChild
)
return
;
NSPoint
windowEventLocation
=
nsCocoaUtils
:
:
EventLocationForWindow
(
aEvent
[
self
window
]
)
;
NSPoint
localEventLocation
=
[
self
convertPoint
:
windowEventLocation
fromView
:
nil
]
;
EventMessage
msg
=
aEnter
?
eMouseEnterIntoWidget
:
eMouseExitFromWidget
;
WidgetMouseEvent
event
(
true
msg
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
event
.
mRefPoint
=
mGeckoChild
-
>
CocoaPointsToDevPixels
(
localEventLocation
)
;
if
(
event
.
mMessage
=
=
eMouseExitFromWidget
)
{
event
.
mExitFrom
=
Some
(
aExitFrom
)
;
}
nsEventStatus
status
;
mGeckoChild
-
>
DispatchEvent
(
&
event
status
)
;
}
-
(
void
)
handleMouseMoved
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
mouseDragged
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rightMouseDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
[
self
maybeRollup
:
theEvent
]
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseDown
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
geckoEvent
.
mClickCount
=
[
theEvent
clickCount
]
;
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
;
if
(
!
StaticPrefs
:
:
ui_context_menus_after_mouseup
(
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
[
super
rightMouseDown
:
theEvent
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rightMouseUp
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseUp
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
geckoEvent
.
mClickCount
=
[
theEvent
clickCount
]
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
nsIWidget
:
:
ContentAndAPZEventStatus
eventStatus
=
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
;
if
(
StaticPrefs
:
:
ui_context_menus_after_mouseup
(
)
&
&
eventStatus
.
mApzStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
NSEvent
*
dupeEvent
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
theEvent
.
locationInWindow
modifierFlags
:
theEvent
.
modifierFlags
timestamp
:
theEvent
.
timestamp
windowNumber
:
theEvent
.
windowNumber
context
:
nil
eventNumber
:
theEvent
.
eventNumber
clickCount
:
theEvent
.
clickCount
pressure
:
theEvent
.
pressure
]
;
[
super
rightMouseDown
:
dupeEvent
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
rightMouseDragged
:
(
NSEvent
*
)
theEvent
{
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
static
bool
ShouldDispatchBackForwardCommandForMouseButton
(
int16_t
aButton
)
{
return
(
aButton
=
=
MouseButton
:
:
eX1
&
&
Preferences
:
:
GetBool
(
"
mousebutton
.
4th
.
enabled
"
true
)
)
|
|
(
aButton
=
=
MouseButton
:
:
eX2
&
&
Preferences
:
:
GetBool
(
"
mousebutton
.
5th
.
enabled
"
true
)
)
;
}
-
(
void
)
otherMouseDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
[
self
maybeRollup
:
theEvent
]
|
|
!
ChildViewMouseTracker
:
:
WindowAcceptsEvent
(
[
self
window
]
theEvent
self
)
)
return
;
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
int16_t
button
=
nsCocoaUtils
:
:
ButtonForEvent
(
theEvent
)
;
if
(
ShouldDispatchBackForwardCommandForMouseButton
(
button
)
)
{
WidgetCommandEvent
appCommandEvent
(
true
(
button
=
=
MouseButton
:
:
eX2
)
?
nsGkAtoms
:
:
Forward
:
nsGkAtoms
:
:
Back
mGeckoChild
)
;
mGeckoChild
-
>
DispatchWindowEvent
(
appCommandEvent
)
;
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseDown
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
button
;
geckoEvent
.
mClickCount
=
[
theEvent
clickCount
]
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
otherMouseUp
:
(
NSEvent
*
)
theEvent
{
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
int16_t
button
=
nsCocoaUtils
:
:
ButtonForEvent
(
theEvent
)
;
if
(
ShouldDispatchBackForwardCommandForMouseButton
(
button
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseUp
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
geckoEvent
.
mButton
=
button
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
-
(
void
)
otherMouseDragged
:
(
NSEvent
*
)
theEvent
{
if
(
!
mGeckoChild
)
return
;
if
(
mTextInputHandler
-
>
OnHandleEvent
(
theEvent
)
)
{
return
;
}
WidgetMouseEvent
geckoEvent
(
true
eMouseMove
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
int16_t
button
=
nsCocoaUtils
:
:
ButtonForEvent
(
theEvent
)
;
geckoEvent
.
mButton
=
button
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
}
-
(
void
)
sendWheelStartOrStop
:
(
EventMessage
)
msg
forEvent
:
(
NSEvent
*
)
theEvent
{
WidgetWheelEvent
wheelEvent
(
true
msg
mGeckoChild
)
;
[
self
convertCocoaMouseWheelEvent
:
theEvent
toGeckoEvent
:
&
wheelEvent
]
;
mExpectingWheelStop
=
(
msg
=
=
eWheelOperationStart
)
;
mGeckoChild
-
>
DispatchInputEvent
(
wheelEvent
.
AsInputEvent
(
)
)
;
}
-
(
void
)
sendWheelCondition
:
(
BOOL
)
condition
first
:
(
EventMessage
)
first
second
:
(
EventMessage
)
second
forEvent
:
(
NSEvent
*
)
theEvent
{
if
(
mExpectingWheelStop
=
=
condition
)
{
[
self
sendWheelStartOrStop
:
first
forEvent
:
theEvent
]
;
}
[
self
sendWheelStartOrStop
:
second
forEvent
:
theEvent
]
;
}
static
PanGestureInput
:
:
PanGestureType
PanGestureTypeForEvent
(
NSEvent
*
aEvent
)
{
switch
(
[
aEvent
phase
]
)
{
case
NSEventPhaseMayBegin
:
return
PanGestureInput
:
:
PANGESTURE_MAYSTART
;
case
NSEventPhaseCancelled
:
return
PanGestureInput
:
:
PANGESTURE_CANCELLED
;
case
NSEventPhaseBegan
:
return
PanGestureInput
:
:
PANGESTURE_START
;
case
NSEventPhaseChanged
:
return
PanGestureInput
:
:
PANGESTURE_PAN
;
case
NSEventPhaseEnded
:
return
PanGestureInput
:
:
PANGESTURE_END
;
case
NSEventPhaseNone
:
switch
(
[
aEvent
momentumPhase
]
)
{
case
NSEventPhaseBegan
:
return
PanGestureInput
:
:
PANGESTURE_MOMENTUMSTART
;
case
NSEventPhaseChanged
:
return
PanGestureInput
:
:
PANGESTURE_MOMENTUMPAN
;
case
NSEventPhaseEnded
:
return
PanGestureInput
:
:
PANGESTURE_MOMENTUMEND
;
default
:
NS_ERROR
(
"
unexpected
event
phase
"
)
;
return
PanGestureInput
:
:
PANGESTURE_PAN
;
}
default
:
NS_ERROR
(
"
unexpected
event
phase
"
)
;
return
PanGestureInput
:
:
PANGESTURE_PAN
;
}
}
static
int32_t
RoundUp
(
double
aDouble
)
{
return
aDouble
<
0
?
static_cast
<
int32_t
>
(
floor
(
aDouble
)
)
:
static_cast
<
int32_t
>
(
ceil
(
aDouble
)
)
;
}
static
gfx
:
:
IntPoint
GetIntegerDeltaForEvent
(
NSEvent
*
aEvent
)
{
if
(
[
aEvent
hasPreciseScrollingDeltas
]
)
{
return
PanGestureInput
:
:
GetIntegerDeltaForEvent
(
[
aEvent
phase
]
=
=
NSEventPhaseBegan
[
aEvent
deltaX
]
[
aEvent
deltaY
]
)
;
}
return
gfx
:
:
IntPoint
(
RoundUp
(
[
aEvent
deltaX
]
)
RoundUp
(
[
aEvent
deltaY
]
)
)
;
}
-
(
void
)
scrollWheel
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
ChildViewMouseTracker
:
:
MouseScrolled
(
theEvent
)
;
if
(
[
self
maybeRollup
:
theEvent
]
)
{
return
;
}
if
(
!
mGeckoChild
)
{
return
;
}
NSEventPhase
phase
=
[
theEvent
phase
]
;
if
(
phase
&
NSEventPhaseMayBegin
)
{
[
self
sendWheelCondition
:
YES
first
:
eWheelOperationEnd
second
:
eWheelOperationStart
forEvent
:
theEvent
]
;
}
else
if
(
phase
&
(
NSEventPhaseEnded
|
NSEventPhaseCancelled
)
)
{
[
self
sendWheelCondition
:
NO
first
:
eWheelOperationStart
second
:
eWheelOperationEnd
forEvent
:
theEvent
]
;
}
if
(
!
mGeckoChild
)
{
return
;
}
RefPtr
<
nsChildView
>
geckoChildDeathGrip
(
mGeckoChild
)
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
theEvent
[
self
window
]
)
;
ScreenPoint
position
=
ViewAs
<
ScreenPixel
>
(
[
self
convertWindowCoordinatesRoundDown
:
locationInWindow
]
PixelCastJustification
:
:
LayoutDeviceIsScreenForUntransformedEvent
)
;
bool
usePreciseDeltas
=
[
theEvent
hasPreciseScrollingDeltas
]
&
&
Preferences
:
:
GetBool
(
"
mousewheel
.
enable_pixel_scrolling
"
true
)
;
bool
hasPhaseInformation
=
nsCocoaUtils
:
:
EventHasPhaseInformation
(
theEvent
)
;
gfx
:
:
IntPoint
lineOrPageDelta
=
-
GetIntegerDeltaForEvent
(
theEvent
)
;
Modifiers
modifiers
=
nsCocoaUtils
:
:
ModifiersForEvent
(
theEvent
)
;
PRIntervalTime
eventIntervalTime
=
PR_IntervalNow
(
)
;
TimeStamp
eventTimeStamp
=
nsCocoaUtils
:
:
GetEventTimeStamp
(
[
theEvent
timestamp
]
)
;
ScreenPoint
preciseDelta
;
if
(
usePreciseDeltas
)
{
CGFloat
pixelDeltaX
=
[
theEvent
scrollingDeltaX
]
;
CGFloat
pixelDeltaY
=
[
theEvent
scrollingDeltaY
]
;
double
scale
=
geckoChildDeathGrip
-
>
BackingScaleFactor
(
)
;
preciseDelta
=
ScreenPoint
(
-
pixelDeltaX
*
scale
-
pixelDeltaY
*
scale
)
;
}
if
(
usePreciseDeltas
&
&
hasPhaseInformation
)
{
PanGestureInput
panEvent
(
PanGestureTypeForEvent
(
theEvent
)
eventIntervalTime
eventTimeStamp
position
ScreenPoint
(
)
modifiers
)
;
bool
shouldIgnoreDeltas
=
panEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_MAYSTART
|
|
panEvent
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_CANCELLED
;
if
(
!
shouldIgnoreDeltas
)
{
panEvent
.
mPanDisplacement
=
preciseDelta
;
panEvent
.
SetLineOrPageDeltas
(
lineOrPageDelta
.
x
lineOrPageDelta
.
y
)
;
}
bool
canTriggerSwipe
=
[
self
shouldConsiderStartingSwipeFromEvent
:
theEvent
]
&
&
SwipeTracker
:
:
CanTriggerSwipe
(
panEvent
)
;
;
panEvent
.
mRequiresContentResponseIfCannotScrollHorizontallyInStartDirection
=
canTriggerSwipe
;
geckoChildDeathGrip
-
>
DispatchAPZWheelInputEvent
(
panEvent
canTriggerSwipe
)
;
}
else
if
(
usePreciseDeltas
)
{
ScrollWheelInput
wheelEvent
(
eventIntervalTime
eventTimeStamp
modifiers
ScrollWheelInput
:
:
SCROLLMODE_INSTANT
ScrollWheelInput
:
:
SCROLLDELTA_PIXEL
position
preciseDelta
.
x
preciseDelta
.
y
false
WheelDeltaAdjustmentStrategy
:
:
eNone
)
;
wheelEvent
.
mLineOrPageDeltaX
=
lineOrPageDelta
.
x
;
wheelEvent
.
mLineOrPageDeltaY
=
lineOrPageDelta
.
y
;
wheelEvent
.
mIsMomentum
=
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
theEvent
)
;
geckoChildDeathGrip
-
>
DispatchAPZWheelInputEvent
(
wheelEvent
false
)
;
}
else
{
ScrollWheelInput
:
:
ScrollMode
scrollMode
=
ScrollWheelInput
:
:
SCROLLMODE_INSTANT
;
if
(
StaticPrefs
:
:
general_smoothScroll
(
)
&
&
StaticPrefs
:
:
general_smoothScroll_mouseWheel
(
)
)
{
scrollMode
=
ScrollWheelInput
:
:
SCROLLMODE_SMOOTH
;
}
ScrollWheelInput
wheelEvent
(
eventIntervalTime
eventTimeStamp
modifiers
scrollMode
ScrollWheelInput
:
:
SCROLLDELTA_LINE
position
lineOrPageDelta
.
x
lineOrPageDelta
.
y
false
WheelDeltaAdjustmentStrategy
:
:
eNone
)
;
wheelEvent
.
mLineOrPageDeltaX
=
lineOrPageDelta
.
x
;
wheelEvent
.
mLineOrPageDeltaY
=
lineOrPageDelta
.
y
;
geckoChildDeathGrip
-
>
DispatchAPZWheelInputEvent
(
wheelEvent
false
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
NSMenu
*
)
menuForEvent
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mGeckoChild
)
return
nil
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
[
self
maybeRollup
:
theEvent
]
;
if
(
!
mGeckoChild
)
return
nil
;
if
(
[
theEvent
type
]
=
=
NSEventTypeLeftMouseDown
)
{
[
self
mouseDown
:
theEvent
]
;
if
(
!
mGeckoChild
)
return
nil
;
}
WidgetMouseEvent
geckoEvent
(
true
eContextMenu
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
theEvent
toGeckoEvent
:
&
geckoEvent
]
;
if
(
StaticPrefs
:
:
dom_event_treat_ctrl_click_as_right_click_disabled
(
)
&
&
[
theEvent
type
]
=
=
NSEventTypeLeftMouseDown
)
{
geckoEvent
.
mContextMenuTrigger
=
WidgetMouseEvent
:
:
eControlClick
;
geckoEvent
.
mButton
=
MouseButton
:
:
ePrimary
;
}
else
{
geckoEvent
.
mButton
=
MouseButton
:
:
eSecondary
;
}
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
nil
;
[
self
maybeInitContextMenuTracking
]
;
return
nil
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
willOpenMenu
:
(
NSMenu
*
)
aMenu
withEvent
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
NativeMenuOpened
(
)
;
}
-
(
void
)
didCloseMenu
:
(
NSMenu
*
)
aMenu
withEvent
:
(
NSEvent
*
)
aEvent
{
ChildViewMouseTracker
:
:
NativeMenuClosed
(
)
;
}
-
(
void
)
convertCocoaMouseWheelEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetWheelEvent
*
)
outWheelEvent
{
[
self
convertCocoaMouseEvent
:
aMouseEvent
toGeckoEvent
:
outWheelEvent
]
;
bool
usePreciseDeltas
=
[
aMouseEvent
hasPreciseScrollingDeltas
]
&
&
Preferences
:
:
GetBool
(
"
mousewheel
.
enable_pixel_scrolling
"
true
)
;
outWheelEvent
-
>
mDeltaMode
=
usePreciseDeltas
?
dom
:
:
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
:
dom
:
:
WheelEvent_Binding
:
:
DOM_DELTA_LINE
;
outWheelEvent
-
>
mIsMomentum
=
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
aMouseEvent
)
;
}
-
(
void
)
convertCocoaMouseEvent
:
(
NSEvent
*
)
aMouseEvent
toGeckoEvent
:
(
WidgetInputEvent
*
)
outGeckoEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ASSERTION
(
outGeckoEvent
"
convertCocoaMouseEvent
:
toGeckoEvent
:
requires
non
-
null
aoutGeckoEvent
"
)
;
if
(
!
outGeckoEvent
)
return
;
nsCocoaUtils
:
:
InitInputEvent
(
*
outGeckoEvent
aMouseEvent
)
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
EventLocationForWindow
(
aMouseEvent
[
self
window
]
)
;
outGeckoEvent
-
>
mRefPoint
=
[
self
convertWindowCoordinates
:
locationInWindow
]
;
WidgetMouseEventBase
*
mouseEvent
=
outGeckoEvent
-
>
AsMouseEventBase
(
)
;
mouseEvent
-
>
mButtons
=
0
;
NSUInteger
mouseButtons
=
[
NSEvent
pressedMouseButtons
]
;
if
(
mouseButtons
&
0x01
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
ePrimaryFlag
;
}
if
(
mouseButtons
&
0x02
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
eSecondaryFlag
;
}
if
(
mouseButtons
&
0x04
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
eMiddleFlag
;
}
if
(
mouseButtons
&
0x08
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
e4thFlag
;
}
if
(
mouseButtons
&
0x10
)
{
mouseEvent
-
>
mButtons
|
=
MouseButtonsFlag
:
:
e5thFlag
;
}
switch
(
[
aMouseEvent
type
]
)
{
case
NSEventTypeLeftMouseDown
:
case
NSEventTypeLeftMouseUp
:
case
NSEventTypeLeftMouseDragged
:
case
NSEventTypeRightMouseDown
:
case
NSEventTypeRightMouseUp
:
case
NSEventTypeRightMouseDragged
:
case
NSEventTypeOtherMouseDown
:
case
NSEventTypeOtherMouseUp
:
case
NSEventTypeOtherMouseDragged
:
case
NSEventTypeMouseMoved
:
if
(
[
aMouseEvent
subtype
]
=
=
NSEventSubtypeTabletPoint
)
{
[
self
convertCocoaTabletPointerEvent
:
aMouseEvent
toGeckoEvent
:
mouseEvent
-
>
AsMouseEvent
(
)
]
;
}
break
;
default
:
break
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
convertCocoaTabletPointerEvent
:
(
NSEvent
*
)
aPointerEvent
toGeckoEvent
:
(
WidgetMouseEvent
*
)
aOutGeckoEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
if
(
!
aOutGeckoEvent
|
|
!
sIsTabletPointerActivated
)
{
return
;
}
if
(
[
aPointerEvent
type
]
!
=
NSEventTypeMouseMoved
)
{
aOutGeckoEvent
-
>
mPressure
=
[
aPointerEvent
pressure
]
;
MOZ_ASSERT
(
aOutGeckoEvent
-
>
mPressure
>
=
0
.
0
&
&
aOutGeckoEvent
-
>
mPressure
<
=
1
.
0
)
;
}
aOutGeckoEvent
-
>
mInputSource
=
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
;
aOutGeckoEvent
-
>
tiltX
=
lround
(
[
aPointerEvent
tilt
]
.
x
*
90
)
;
aOutGeckoEvent
-
>
tiltY
=
lround
(
[
aPointerEvent
tilt
]
.
y
*
90
)
;
aOutGeckoEvent
-
>
tangentialPressure
=
[
aPointerEvent
tangentialPressure
]
;
int32_t
twist
=
fmod
(
[
aPointerEvent
rotation
]
360
)
;
aOutGeckoEvent
-
>
twist
=
twist
>
=
0
?
twist
:
twist
+
360
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
tabletProximity
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
sIsTabletPointerActivated
=
[
theEvent
isEnteringProximity
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
}
#
pragma
mark
-
-
(
NSRange
)
markedRange
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
NSMakeRange
(
NSNotFound
0
)
)
;
return
mTextInputHandler
-
>
MarkedRange
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSMakeRange
(
0
0
)
)
;
}
-
(
NSRange
)
selectedRange
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
NSMakeRange
(
NSNotFound
0
)
)
;
return
mTextInputHandler
-
>
SelectedRange
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSMakeRange
(
0
0
)
)
;
}
-
(
BOOL
)
drawsVerticallyForCharacterAtIndex
:
(
NSUInteger
)
charIndex
{
NS_ENSURE_TRUE
(
mTextInputHandler
NO
)
;
if
(
charIndex
=
=
NSNotFound
)
{
return
NO
;
}
return
mTextInputHandler
-
>
DrawsVerticallyForCharacterAtIndex
(
charIndex
)
;
}
-
(
NSUInteger
)
characterIndexForPoint
:
(
NSPoint
)
thePoint
{
NS_ENSURE_TRUE
(
mTextInputHandler
0
)
;
return
mTextInputHandler
-
>
CharacterIndexForPoint
(
thePoint
)
;
}
-
(
NSArray
*
)
validAttributesForMarkedText
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
[
NSArray
array
]
)
;
return
mTextInputHandler
-
>
GetValidAttributesForMarkedText
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
void
)
insertText
:
(
id
)
aString
replacementRange
:
(
NSRange
)
replacementRange
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE_VOID
(
mGeckoChild
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
NSAttributedString
*
attrStr
;
if
(
[
aString
isKindOfClass
:
[
NSAttributedString
class
]
]
)
{
attrStr
=
static_cast
<
NSAttributedString
*
>
(
aString
)
;
}
else
{
attrStr
=
[
[
[
NSAttributedString
alloc
]
initWithString
:
aString
]
autorelease
]
;
}
mTextInputHandler
-
>
InsertText
(
attrStr
&
replacementRange
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
doCommandBySelector
:
(
SEL
)
aSelector
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
|
|
!
mTextInputHandler
)
{
return
;
}
const
char
*
sel
=
reinterpret_cast
<
const
char
*
>
(
aSelector
)
;
if
(
!
mTextInputHandler
-
>
DoCommandBySelector
(
sel
)
)
{
[
super
doCommandBySelector
:
aSelector
]
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
unmarkText
{
NS_ENSURE_TRUE_VOID
(
mTextInputHandler
)
;
mTextInputHandler
-
>
CommitIMEComposition
(
)
;
}
-
(
BOOL
)
hasMarkedText
{
NS_ENSURE_TRUE
(
mTextInputHandler
NO
)
;
return
mTextInputHandler
-
>
HasMarkedText
(
)
;
}
-
(
void
)
setMarkedText
:
(
id
)
aString
selectedRange
:
(
NSRange
)
selectedRange
replacementRange
:
(
NSRange
)
replacementRange
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE_VOID
(
mTextInputHandler
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
NSAttributedString
*
attrStr
;
if
(
[
aString
isKindOfClass
:
[
NSAttributedString
class
]
]
)
{
attrStr
=
static_cast
<
NSAttributedString
*
>
(
aString
)
;
}
else
{
attrStr
=
[
[
[
NSAttributedString
alloc
]
initWithString
:
aString
]
autorelease
]
;
}
mTextInputHandler
-
>
SetMarkedText
(
attrStr
selectedRange
&
replacementRange
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
NSAttributedString
*
)
attributedSubstringForProposedRange
:
(
NSRange
)
aRange
actualRange
:
(
NSRangePointer
)
actualRange
{
NS_ENSURE_TRUE
(
mTextInputHandler
nil
)
;
return
mTextInputHandler
-
>
GetAttributedSubstringFromRange
(
aRange
actualRange
)
;
}
-
(
NSRect
)
firstRectForCharacterRange
:
(
NSRange
)
aRange
actualRange
:
(
NSRangePointer
)
actualRange
{
NS_ENSURE_TRUE
(
mTextInputHandler
NSMakeRect
(
0
.
0
0
.
0
0
.
0
0
.
0
)
)
;
return
mTextInputHandler
-
>
FirstRectForCharacterRange
(
aRange
actualRange
)
;
}
-
(
void
)
quickLookWithEvent
:
(
NSEvent
*
)
event
{
WidgetContentCommandEvent
contentCommandEvent
(
true
eContentCommandLookUpDictionary
mGeckoChild
)
;
NSPoint
point
=
[
self
convertPoint
:
[
event
locationInWindow
]
fromView
:
nil
]
;
contentCommandEvent
.
mRefPoint
=
mGeckoChild
-
>
CocoaPointsToDevPixels
(
point
)
;
mGeckoChild
-
>
DispatchWindowEvent
(
contentCommandEvent
)
;
}
-
(
NSInteger
)
windowLevel
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ENSURE_TRUE
(
mTextInputHandler
[
[
self
window
]
level
]
)
;
return
mTextInputHandler
-
>
GetWindowLevel
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSNormalWindowLevel
)
;
}
#
pragma
mark
-
-
(
BOOL
)
_wantsKeyDownForEvent
:
(
NSEvent
*
)
event
{
return
YES
;
}
-
(
NSEvent
*
)
lastKeyDownEvent
{
return
mLastKeyDownEvent
;
}
-
(
void
)
keyDown
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
mLastKeyDownEvent
release
]
;
mLastKeyDownEvent
=
[
theEvent
retain
]
;
NSWindow
*
viewWindow
=
[
self
window
]
;
if
(
viewWindow
&
&
[
viewWindow
isKeyWindow
]
)
{
[
viewWindow
orderWindow
:
NSWindowAbove
relativeTo
:
0
]
;
}
#
if
!
defined
(
RELEASE_OR_BETA
)
|
|
defined
(
DEBUG
)
if
(
!
Preferences
:
:
GetBool
(
"
intl
.
allow
-
insecure
-
text
-
input
"
false
)
&
&
mGeckoChild
&
&
mTextInputHandler
&
&
mTextInputHandler
-
>
IsFocused
(
)
)
{
NSWindow
*
window
=
[
self
window
]
;
NSString
*
info
=
[
NSString
stringWithFormat
:
"
\
nview
[
%
]
window
[
%
]
window
is
key
%
i
is
fullscreen
%
i
app
is
active
%
i
"
self
window
[
window
isKeyWindow
]
(
[
window
styleMask
]
&
NSWindowStyleMaskFullScreen
)
!
=
0
[
NSApp
isActive
]
]
;
nsAutoCString
additionalInfo
(
[
info
UTF8String
]
)
;
if
(
mGeckoChild
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
&
&
!
TextInputHandler
:
:
IsSecureEventInputEnabled
(
)
)
{
#
define
CRASH_MESSAGE
"
A
password
editor
has
focus
but
not
in
secure
input
mode
"
CrashReporter
:
:
AppendAppNotesToCrashReport
(
"
\
nBug
893973
:
"
_ns
+
nsLiteralCString
(
CRASH_MESSAGE
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
additionalInfo
)
;
MOZ_CRASH
(
CRASH_MESSAGE
)
;
#
undef
CRASH_MESSAGE
}
else
if
(
!
mGeckoChild
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
&
&
TextInputHandler
:
:
IsSecureEventInputEnabled
(
)
)
{
#
define
CRASH_MESSAGE
"
A
non
-
password
editor
has
focus
but
in
secure
input
mode
"
CrashReporter
:
:
AppendAppNotesToCrashReport
(
"
\
nBug
893973
:
"
_ns
+
nsLiteralCString
(
CRASH_MESSAGE
)
)
;
CrashReporter
:
:
AppendAppNotesToCrashReport
(
additionalInfo
)
;
MOZ_CRASH
(
CRASH_MESSAGE
)
;
#
undef
CRASH_MESSAGE
}
}
#
endif
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
mGeckoChild
)
{
if
(
mTextInputHandler
)
{
sUniqueKeyEventId
+
+
;
NSMutableDictionary
*
nativeKeyEventsMap
=
[
ChildView
sNativeKeyEventsMap
]
;
[
nativeKeyEventsMap
setObject
:
theEvent
forKey
:
(
sUniqueKeyEventId
)
]
;
[
nativeKeyEventsMap
removeObjectForKey
:
(
sUniqueKeyEventId
-
10
)
]
;
mTextInputHandler
-
>
HandleKeyDownEvent
(
theEvent
sUniqueKeyEventId
)
;
}
else
{
mGeckoChild
-
>
SendEventToNativeMenuSystem
(
theEvent
)
;
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
keyUp
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE
(
mGeckoChild
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mTextInputHandler
-
>
HandleKeyUpEvent
(
theEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
insertNewline
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertParagraph
)
;
}
}
-
(
void
)
insertLineBreak
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertLineBreak
)
;
}
}
-
(
void
)
deleteBackward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteCharBackward
)
;
}
}
-
(
void
)
deleteBackwardByDecomposingPreviousCharacter
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteCharBackward
)
;
}
}
-
(
void
)
deleteWordBackward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteWordBackward
)
;
}
}
-
(
void
)
deleteToBeginningOfBackward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteToBeginningOfLine
)
;
}
}
-
(
void
)
deleteForward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteCharForward
)
;
}
}
-
(
void
)
deleteWordForward
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
DeleteWordForward
)
;
}
}
-
(
void
)
insertTab
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertTab
)
;
}
}
-
(
void
)
insertBacktab
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
InsertBacktab
)
;
}
}
-
(
void
)
moveRight
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
CharNext
)
;
}
}
-
(
void
)
moveRightAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectCharNext
)
;
}
}
-
(
void
)
moveWordRight
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
WordNext
)
;
}
}
-
(
void
)
moveWordRightAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectWordNext
)
;
}
}
-
(
void
)
moveToRightEndOfLine
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
EndLine
)
;
}
}
-
(
void
)
moveToRightEndOfLineAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectEndLine
)
;
}
}
-
(
void
)
moveLeft
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
CharPrevious
)
;
}
}
-
(
void
)
moveLeftAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectCharPrevious
)
;
}
}
-
(
void
)
moveWordLeft
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
WordPrevious
)
;
}
}
-
(
void
)
moveWordLeftAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectWordPrevious
)
;
}
}
-
(
void
)
moveToLeftEndOfLine
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
BeginLine
)
;
}
}
-
(
void
)
moveToLeftEndOfLineAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectBeginLine
)
;
}
}
-
(
void
)
moveUp
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
LinePrevious
)
;
}
}
-
(
void
)
moveUpAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectLinePrevious
)
;
}
}
-
(
void
)
moveToBeginningOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
MoveTop
)
;
}
}
-
(
void
)
moveToBeginningOfDocumentAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectTop
)
;
}
}
-
(
void
)
moveDown
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
LineNext
)
;
}
}
-
(
void
)
moveDownAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectLineNext
)
;
}
}
-
(
void
)
moveToEndOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
MoveBottom
)
;
}
}
-
(
void
)
moveToEndOfDocumentAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectBottom
)
;
}
}
-
(
void
)
scrollPageUp
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollPageUp
)
;
}
}
-
(
void
)
pageUpAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectPageUp
)
;
}
}
-
(
void
)
scrollPageDown
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollPageDown
)
;
}
}
-
(
void
)
pageDownAndModifySelection
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
SelectPageDown
)
;
}
}
-
(
void
)
scrollToEndOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollBottom
)
;
}
}
-
(
void
)
scrollToBeginningOfDocument
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
ScrollTop
)
;
}
}
-
(
void
)
complete
:
(
id
)
sender
{
if
(
mTextInputHandler
)
{
mTextInputHandler
-
>
HandleCommand
(
Command
:
:
Complete
)
;
}
}
-
(
void
)
flagsChanged
:
(
NSEvent
*
)
theEvent
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
NS_ENSURE_TRUE
(
mGeckoChild
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mTextInputHandler
-
>
HandleFlagsChanged
(
theEvent
)
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
BOOL
)
isFirstResponder
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSResponder
*
resp
=
[
[
self
window
]
firstResponder
]
;
return
(
resp
=
=
(
NSResponder
*
)
self
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
isDragInProgress
{
if
(
!
mDragService
)
return
NO
;
nsCOMPtr
<
nsIDragSession
>
dragSession
;
mDragService
-
>
GetCurrentSession
(
getter_AddRefs
(
dragSession
)
)
;
return
dragSession
!
=
nullptr
;
}
-
(
BOOL
)
inactiveWindowAcceptsMouseEvent
:
(
NSEvent
*
)
aEvent
{
if
(
!
mGeckoChild
)
return
YES
;
WidgetMouseEvent
geckoEvent
(
true
eMouseActivate
mGeckoChild
WidgetMouseEvent
:
:
eReal
)
;
[
self
convertCocoaMouseEvent
:
aEvent
toGeckoEvent
:
&
geckoEvent
]
;
return
(
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
.
mContentStatus
!
=
nsEventStatus_eConsumeNoDefault
)
;
}
-
(
BOOL
)
becomeFirstResponder
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
return
[
super
becomeFirstResponder
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
YES
)
;
}
-
(
void
)
viewsWindowDidBecomeKey
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
if
(
!
mGeckoChild
)
return
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
BOOL
isMozWindow
=
[
[
self
window
]
respondsToSelector
:
selector
(
setSuppressMakeKeyFront
:
)
]
;
if
(
isMozWindow
)
[
[
self
window
]
setSuppressMakeKeyFront
:
YES
]
;
nsIWidgetListener
*
listener
=
mGeckoChild
-
>
GetWidgetListener
(
)
;
if
(
listener
)
listener
-
>
WindowActivated
(
)
;
if
(
isMozWindow
)
[
[
self
window
]
setSuppressMakeKeyFront
:
NO
]
;
if
(
mGeckoChild
-
>
GetInputContext
(
)
.
IsPasswordEditor
(
)
)
{
TextInputHandler
:
:
EnableSecureEventInput
(
)
;
}
else
{
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
viewsWindowDidResignKey
{
if
(
!
mGeckoChild
)
return
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
nsIWidgetListener
*
listener
=
mGeckoChild
-
>
GetWidgetListener
(
)
;
if
(
listener
)
listener
-
>
WindowDeactivated
(
)
;
TextInputHandler
:
:
EnsureSecureEventInputDisabled
(
)
;
}
-
(
void
)
delayedTearDown
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
self
removeFromSuperview
]
;
[
self
release
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
#
define
kDragServiceContractID
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
-
(
NSDragOperation
)
dragOperationFromDragAction
:
(
int32_t
)
aDragAction
{
if
(
nsIDragService
:
:
DRAGDROP_ACTION_LINK
&
aDragAction
)
return
NSDragOperationLink
;
if
(
nsIDragService
:
:
DRAGDROP_ACTION_COPY
&
aDragAction
)
return
NSDragOperationCopy
;
if
(
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
&
aDragAction
)
return
NSDragOperationGeneric
;
return
NSDragOperationNone
;
}
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinates
:
(
NSPoint
)
aPoint
{
if
(
!
mGeckoChild
)
{
return
LayoutDeviceIntPoint
(
0
0
)
;
}
NSPoint
localPoint
=
[
self
convertPoint
:
aPoint
fromView
:
nil
]
;
return
mGeckoChild
-
>
CocoaPointsToDevPixels
(
localPoint
)
;
}
-
(
LayoutDeviceIntPoint
)
convertWindowCoordinatesRoundDown
:
(
NSPoint
)
aPoint
{
if
(
!
mGeckoChild
)
{
return
LayoutDeviceIntPoint
(
0
0
)
;
}
NSPoint
localPoint
=
[
self
convertPoint
:
aPoint
fromView
:
nil
]
;
return
mGeckoChild
-
>
CocoaPointsToDevPixelsRoundDown
(
localPoint
)
;
}
-
(
NSDragOperation
)
doDragAction
:
(
EventMessage
)
aMessage
sender
:
(
id
)
aSender
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mGeckoChild
)
return
NSDragOperationNone
;
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
doDragAction
:
entered
\
n
"
)
)
;
if
(
!
mDragService
)
{
CallGetService
(
kDragServiceContractID
&
mDragService
)
;
NS_ASSERTION
(
mDragService
"
Couldn
'
t
get
a
drag
service
-
big
problem
!
"
)
;
if
(
!
mDragService
)
return
NSDragOperationNone
;
}
if
(
aMessage
=
=
eDragEnter
)
{
mDragService
-
>
StartDragSession
(
)
;
}
nsCOMPtr
<
nsIDragSession
>
dragSession
;
mDragService
-
>
GetCurrentSession
(
getter_AddRefs
(
dragSession
)
)
;
if
(
dragSession
)
{
if
(
aMessage
=
=
eDragOver
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
mDragService
;
dragService
-
>
FireDragEventAtSource
(
eDrag
nsCocoaUtils
:
:
ModifiersForEvent
(
[
NSApp
currentEvent
]
)
)
;
dragSession
-
>
SetCanDrop
(
false
)
;
}
else
if
(
aMessage
=
=
eDrop
)
{
bool
canDrop
=
false
;
if
(
!
NS_SUCCEEDED
(
dragSession
-
>
GetCanDrop
(
&
canDrop
)
)
|
|
!
canDrop
)
{
[
self
doDragAction
:
eDragExit
sender
:
aSender
]
;
nsCOMPtr
<
nsINode
>
sourceNode
;
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
mDragService
;
dragService
-
>
EndDragSession
(
false
nsCocoaUtils
:
:
ModifiersForEvent
(
[
NSApp
currentEvent
]
)
)
;
}
return
NSDragOperationNone
;
}
}
unsigned
int
modifierFlags
=
[
[
NSApp
currentEvent
]
modifierFlags
]
;
uint32_t
action
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
if
(
modifierFlags
&
NSEventModifierFlagOption
)
{
if
(
modifierFlags
&
NSEventModifierFlagCommand
)
action
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
else
action
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
}
dragSession
-
>
SetDragAction
(
action
)
;
}
WidgetDragEvent
geckoEvent
(
true
aMessage
mGeckoChild
)
;
nsCocoaUtils
:
:
InitInputEvent
(
geckoEvent
[
NSApp
currentEvent
]
)
;
NSPoint
draggingLoc
=
[
aSender
draggingLocation
]
;
geckoEvent
.
mRefPoint
=
[
self
convertWindowCoordinates
:
draggingLoc
]
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
mGeckoChild
-
>
DispatchInputEvent
(
&
geckoEvent
)
;
if
(
!
mGeckoChild
)
return
NSDragOperationNone
;
if
(
dragSession
)
{
switch
(
aMessage
)
{
case
eDragEnter
:
case
eDragOver
:
{
uint32_t
dragAction
;
dragSession
-
>
GetDragAction
(
&
dragAction
)
;
nsDragService
*
dragService
=
static_cast
<
nsDragService
*
>
(
mDragService
)
;
int32_t
childDragAction
=
dragService
-
>
TakeChildProcessDragAction
(
)
;
if
(
childDragAction
!
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
{
dragAction
=
childDragAction
;
}
return
[
self
dragOperationFromDragAction
:
dragAction
]
;
}
case
eDragExit
:
case
eDrop
:
{
nsCOMPtr
<
nsINode
>
sourceNode
;
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
;
if
(
!
sourceNode
)
{
nsCOMPtr
<
nsIDragService
>
dragService
=
mDragService
;
dragService
-
>
EndDragSession
(
false
nsCocoaUtils
:
:
ModifiersForEvent
(
[
NSApp
currentEvent
]
)
)
;
}
break
;
}
default
:
break
;
}
}
return
NSDragOperationGeneric
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSDragOperationNone
)
;
}
-
(
NSDragOperation
)
draggingEntered
:
(
id
<
NSDraggingInfo
>
)
sender
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
draggingEntered
:
entered
\
n
"
)
)
;
[
globalDragPboard
release
]
;
globalDragPboard
=
[
[
sender
draggingPasteboard
]
retain
]
;
return
[
self
doDragAction
:
eDragEnter
sender
:
sender
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NSDragOperationNone
)
;
}
-
(
NSDragOperation
)
draggingUpdated
:
(
id
<
NSDraggingInfo
>
)
sender
{
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
draggingUpdated
:
entered
\
n
"
)
)
;
return
[
self
doDragAction
:
eDragOver
sender
:
sender
]
;
}
-
(
void
)
draggingExited
:
(
id
<
NSDraggingInfo
>
)
sender
{
MOZ_LOG
(
sCocoaLog
LogLevel
:
:
Info
(
"
ChildView
draggingExited
:
entered
\
n
"
)
)
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
[
self
doDragAction
:
eDragExit
sender
:
sender
]
;
NS_IF_RELEASE
(
mDragService
)
;
}
-
(
BOOL
)
performDragOperation
:
(
id
<
NSDraggingInfo
>
)
sender
{
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
BOOL
handled
=
[
self
doDragAction
:
eDrop
sender
:
sender
]
!
=
NSDragOperationNone
;
NS_IF_RELEASE
(
mDragService
)
;
return
handled
;
}
-
(
NSDragOperation
)
draggingSession
:
(
NSDraggingSession
*
)
session
sourceOperationMaskForDraggingContext
:
(
NSDraggingContext
)
context
{
return
UINT_MAX
;
}
-
(
BOOL
)
ignoreModifierKeysForDraggingSession
:
(
NSDraggingSession
*
)
session
{
return
YES
;
}
-
(
void
)
draggingSession
:
(
NSDraggingSession
*
)
aSession
endedAtPoint
:
(
NSPoint
)
aPoint
operation
:
(
NSDragOperation
)
aOperation
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
#
ifdef
NIGHTLY_BUILD
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
endif
gDraggedTransferables
=
nullptr
;
NSEvent
*
currentEvent
=
[
NSApp
currentEvent
]
;
gUserCancelledDrag
=
(
[
currentEvent
type
]
=
=
NSEventTypeKeyDown
&
&
[
currentEvent
keyCode
]
=
=
kVK_Escape
)
;
if
(
!
mDragService
)
{
CallGetService
(
kDragServiceContractID
&
mDragService
)
;
NS_ASSERTION
(
mDragService
"
Couldn
'
t
get
a
drag
service
-
big
problem
!
"
)
;
}
if
(
mDragService
)
{
RefPtr
<
nsDragService
>
dragService
=
static_cast
<
nsDragService
*
>
(
mDragService
)
;
NSPoint
pnt
=
[
NSEvent
mouseLocation
]
;
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
[
self
window
]
pnt
)
;
FlipCocoaScreenCoordinate
(
pnt
)
;
dragService
-
>
SetDragEndPoint
(
[
self
convertWindowCoordinates
:
locationInWindow
]
)
;
if
(
aOperation
=
=
NSDragOperationNone
)
{
RefPtr
<
dom
:
:
DataTransfer
>
dataTransfer
=
dragService
-
>
GetDataTransfer
(
)
;
if
(
dataTransfer
)
{
dataTransfer
-
>
SetDropEffectInt
(
nsIDragService
:
:
DRAGDROP_ACTION_NONE
)
;
}
}
dragService
-
>
EndDragSession
(
true
nsCocoaUtils
:
:
ModifiersForEvent
(
currentEvent
)
)
;
NS_RELEASE
(
mDragService
)
;
}
[
globalDragPboard
release
]
;
globalDragPboard
=
nil
;
[
gLastDragMouseDownEvent
release
]
;
gLastDragMouseDownEvent
=
nil
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
draggingSession
:
(
NSDraggingSession
*
)
aSession
movedToPoint
:
(
NSPoint
)
aPoint
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
nsCOMPtr
<
nsIDragService
>
dragService
=
mDragService
;
if
(
!
dragService
)
{
dragService
=
do_GetService
(
kDragServiceContractID
)
;
}
if
(
dragService
)
{
nsDragService
*
ds
=
static_cast
<
nsDragService
*
>
(
dragService
.
get
(
)
)
;
ds
-
>
DragMovedWithView
(
aSession
aPoint
)
;
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
-
(
void
)
draggingSession
:
(
NSDraggingSession
*
)
aSession
willBeginAtPoint
:
(
NSPoint
)
aPoint
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
[
globalDragPboard
release
]
;
globalDragPboard
=
[
[
aSession
draggingPasteboard
]
retain
]
;
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
static
CFTypeRefPtr
<
CFURLRef
>
GetPasteLocation
(
NSPasteboard
*
aPasteboard
)
{
PasteboardRef
pboardRef
=
nullptr
;
PasteboardCreate
(
(
CFStringRef
)
[
aPasteboard
name
]
&
pboardRef
)
;
if
(
!
pboardRef
)
{
return
nullptr
;
}
auto
pasteBoard
=
CFTypeRefPtr
<
PasteboardRef
>
:
:
WrapUnderCreateRule
(
pboardRef
)
;
PasteboardSynchronize
(
pasteBoard
.
get
(
)
)
;
CFURLRef
urlRef
=
nullptr
;
PasteboardCopyPasteLocation
(
pasteBoard
.
get
(
)
&
urlRef
)
;
return
CFTypeRefPtr
<
CFURLRef
>
:
:
WrapUnderCreateRule
(
urlRef
)
;
}
-
(
void
)
pasteboard
:
(
NSPasteboard
*
)
aPasteboard
item
:
(
NSPasteboardItem
*
)
aItem
provideDataForType
:
(
NSString
*
)
aType
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
;
#
ifdef
NIGHTLY_BUILD
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
endif
if
(
!
gDraggedTransferables
)
{
return
;
}
uint32_t
count
=
0
;
gDraggedTransferables
-
>
GetLength
(
&
count
)
;
for
(
uint32_t
j
=
0
;
j
<
count
;
j
+
+
)
{
nsCOMPtr
<
nsITransferable
>
currentTransferable
=
do_QueryElementAt
(
gDraggedTransferables
j
)
;
if
(
!
currentTransferable
)
{
return
;
}
NSDictionary
*
pasteboardOutputDict
=
nsClipboard
:
:
PasteboardDictFromTransferable
(
currentTransferable
)
;
if
(
!
pasteboardOutputDict
)
{
return
;
}
unsigned
int
typeCount
=
[
pasteboardOutputDict
count
]
;
NSMutableArray
*
types
=
[
NSMutableArray
arrayWithCapacity
:
typeCount
+
1
]
;
[
types
addObjectsFromArray
:
[
pasteboardOutputDict
allKeys
]
]
;
[
types
addObject
:
[
UTIHelper
stringFromPboardType
:
kMozWildcardPboardType
]
]
;
for
(
unsigned
int
k
=
0
;
k
<
typeCount
;
k
+
+
)
{
NSString
*
curType
=
[
types
objectAtIndex
:
k
]
;
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlPboardType
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlNamePboardType
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kUTTypeFileURL
]
]
)
{
[
aPasteboard
setString
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kUrlsWithTitlesPboardType
]
]
)
{
[
aPasteboard
setPropertyList
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
)
{
[
aPasteboard
setString
:
(
nsClipboard
:
:
WrapHtmlForSystemPasteboard
(
[
pasteboardOutputDict
valueForKey
:
curType
]
)
)
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeTIFF
]
]
|
|
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kMozCustomTypesPboardType
]
]
)
{
[
aPasteboard
setData
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kMozFileUrlsPboardType
]
]
)
{
[
aPasteboard
writeObjects
:
[
pasteboardOutputDict
valueForKey
:
curType
]
]
;
}
else
if
(
[
curType
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kPasteboardTypeFileURLPromise
]
]
)
{
nsCOMPtr
<
nsIFile
>
targFile
;
NS_NewLocalFile
(
u
"
"
_ns
true
getter_AddRefs
(
targFile
)
)
;
nsCOMPtr
<
nsILocalFileMac
>
macLocalFile
=
do_QueryInterface
(
targFile
)
;
if
(
!
macLocalFile
)
{
NS_ERROR
(
"
No
Mac
local
file
"
)
;
continue
;
}
CFTypeRefPtr
<
CFURLRef
>
url
=
GetPasteLocation
(
aPasteboard
)
;
if
(
!
url
)
{
continue
;
}
if
(
!
NS_SUCCEEDED
(
macLocalFile
-
>
InitWithCFURL
(
url
.
get
(
)
)
)
)
{
NS_ERROR
(
"
failed
InitWithCFURL
"
)
;
continue
;
}
if
(
!
gDraggedTransferables
)
{
continue
;
}
uint32_t
transferableCount
;
nsresult
rv
=
gDraggedTransferables
-
>
GetLength
(
&
transferableCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
continue
;
}
for
(
uint32_t
i
=
0
;
i
<
transferableCount
;
i
+
+
)
{
nsCOMPtr
<
nsITransferable
>
item
=
do_QueryElementAt
(
gDraggedTransferables
i
)
;
if
(
!
item
)
{
NS_ERROR
(
"
no
transferable
"
)
;
continue
;
}
item
-
>
SetTransferData
(
kFilePromiseDirectoryMime
macLocalFile
)
;
nsCOMPtr
<
nsISupports
>
fileDataPrimitive
;
Unused
<
<
item
-
>
GetTransferData
(
kFilePromiseMime
getter_AddRefs
(
fileDataPrimitive
)
)
;
}
[
aPasteboard
setPropertyList
:
[
pasteboardOutputDict
valueForKey
:
curType
]
forType
:
curType
]
;
}
}
}
NS_OBJC_END_TRY_IGNORE_BLOCK
;
}
#
pragma
mark
-
-
(
id
)
validRequestorForSendType
:
(
NSString
*
)
sendType
returnType
:
(
NSString
*
)
returnType
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
NS_IsMainThread
(
)
)
{
return
[
super
validRequestorForSendType
:
sendType
returnType
:
returnType
]
;
}
id
result
=
nil
;
NSString
*
stringType
=
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
;
NSString
*
htmlType
=
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
;
if
(
(
!
sendType
|
|
[
sendType
isEqualToString
:
stringType
]
|
|
[
sendType
isEqualToString
:
htmlType
]
)
&
&
(
!
returnType
|
|
[
returnType
isEqualToString
:
stringType
]
|
|
[
returnType
isEqualToString
:
htmlType
]
)
)
{
if
(
mGeckoChild
)
{
result
=
self
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
sendType
)
{
if
(
!
nsClipboard
:
:
sSelectionCache
)
{
result
=
nil
;
}
}
if
(
mGeckoChild
&
&
returnType
)
{
WidgetContentCommandEvent
command
(
true
eContentCommandPasteTransferable
mGeckoChild
true
)
;
mGeckoChild
-
>
DispatchWindowEvent
(
command
)
;
if
(
!
mGeckoChild
|
|
!
command
.
mSucceeded
|
|
!
command
.
mIsEnabled
)
result
=
nil
;
}
}
}
if
(
!
result
)
result
=
[
super
validRequestorForSendType
:
sendType
returnType
:
returnType
]
;
return
result
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
-
(
BOOL
)
writeSelectionToPasteboard
:
(
NSPasteboard
*
)
pboard
types
:
(
NSArray
*
)
types
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
if
(
!
[
types
containsObject
:
[
UTIHelper
stringFromPboardType
:
NSStringPboardType
]
]
&
&
!
[
types
containsObject
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
]
&
&
!
[
types
containsObject
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
)
{
return
NO
;
}
if
(
!
mGeckoChild
)
return
NO
;
NSDictionary
*
pasteboardOutputDict
=
nullptr
;
pasteboardOutputDict
=
nsClipboard
:
:
PasteboardDictFromTransferable
(
nsClipboard
:
:
sSelectionCache
)
;
if
(
!
pasteboardOutputDict
)
return
NO
;
unsigned
int
typeCount
=
[
pasteboardOutputDict
count
]
;
NSMutableArray
*
declaredTypes
=
[
NSMutableArray
arrayWithCapacity
:
typeCount
]
;
[
declaredTypes
addObjectsFromArray
:
[
pasteboardOutputDict
allKeys
]
]
;
[
pboard
declareTypes
:
declaredTypes
owner
:
nil
]
;
for
(
unsigned
int
i
=
0
;
i
<
typeCount
;
i
+
+
)
{
NSString
*
currentKey
=
[
declaredTypes
objectAtIndex
:
i
]
;
id
currentValue
=
[
pasteboardOutputDict
valueForKey
:
currentKey
]
;
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeString
]
]
|
|
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlPboardType
]
]
|
|
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kPublicUrlNamePboardType
]
]
)
{
[
pboard
setString
:
currentValue
forType
:
currentKey
]
;
}
else
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeHTML
]
]
)
{
[
pboard
setString
:
(
nsClipboard
:
:
WrapHtmlForSystemPasteboard
(
currentValue
)
)
forType
:
currentKey
]
;
}
else
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
NSPasteboardTypeTIFF
]
]
)
{
[
pboard
setData
:
currentValue
forType
:
currentKey
]
;
}
else
if
(
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
(
NSString
*
)
kPasteboardTypeFileURLPromise
]
]
|
|
[
currentKey
isEqualToString
:
[
UTIHelper
stringFromPboardType
:
kUrlsWithTitlesPboardType
]
]
)
{
[
pboard
setPropertyList
:
currentValue
forType
:
currentKey
]
;
}
}
return
YES
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NO
)
;
}
-
(
BOOL
)
readSelectionFromPasteboard
:
(
NSPasteboard
*
)
pboard
{
nsresult
rv
;
nsCOMPtr
<
nsITransferable
>
trans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
trans
-
>
Init
(
nullptr
)
;
trans
-
>
AddDataFlavor
(
kUnicodeMime
)
;
trans
-
>
AddDataFlavor
(
kHTMLMime
)
;
rv
=
nsClipboard
:
:
TransferableFromPasteboard
(
trans
pboard
)
;
if
(
NS_FAILED
(
rv
)
)
return
NO
;
NS_ENSURE_TRUE
(
mGeckoChild
false
)
;
WidgetContentCommandEvent
command
(
true
eContentCommandPasteTransferable
mGeckoChild
)
;
command
.
mTransferable
=
trans
;
mGeckoChild
-
>
DispatchWindowEvent
(
command
)
;
return
command
.
mSucceeded
&
&
command
.
mIsEnabled
;
}
-
(
void
)
pressureChangeWithEvent
:
(
NSEvent
*
)
event
{
NS_OBJC_BEGIN_TRY_IGNORE_BLOCK
NSInteger
stage
=
[
event
stage
]
;
if
(
mLastPressureStage
=
=
1
&
&
stage
=
=
2
)
{
NSUserDefaults
*
userDefaults
=
[
NSUserDefaults
standardUserDefaults
]
;
if
(
[
userDefaults
integerForKey
:
"
com
.
apple
.
trackpad
.
forceClick
"
]
=
=
1
)
{
[
self
quickLookWithEvent
:
event
]
;
}
}
mLastPressureStage
=
stage
;
NS_OBJC_END_TRY_IGNORE_BLOCK
}
nsresult
nsChildView
:
:
GetSelectionAsPlaintext
(
nsAString
&
aResult
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
nsClipboard
:
:
sSelectionCache
)
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
)
;
return
NS_OK
;
}
NSDictionary
*
pasteboardOutputDict
=
nullptr
;
pasteboardOutputDict
=
nsClipboard
:
:
PasteboardDictFromTransferable
(
nsClipboard
:
:
sSelectionCache
)
;
if
(
NS_WARN_IF
(
!
pasteboardOutputDict
)
)
{
return
NS_ERROR_FAILURE
;
}
unsigned
int
typeCount
=
[
pasteboardOutputDict
count
]
;
NSMutableArray
*
declaredTypes
=
[
NSMutableArray
arrayWithCapacity
:
typeCount
]
;
[
declaredTypes
addObjectsFromArray
:
[
pasteboardOutputDict
allKeys
]
]
;
NSString
*
currentKey
=
[
declaredTypes
objectAtIndex
:
0
]
;
NSString
*
currentValue
=
[
pasteboardOutputDict
valueForKey
:
currentKey
]
;
const
char
*
textSelection
=
[
currentValue
UTF8String
]
;
aResult
=
NS_ConvertUTF8toUTF16
(
textSelection
)
;
return
NS_OK
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
#
pragma
mark
-
#
ifdef
ACCESSIBILITY
-
(
id
<
mozAccessible
>
)
accessible
{
if
(
!
mGeckoChild
)
return
nil
;
id
<
mozAccessible
>
nativeAccessible
=
nil
;
nsAutoRetainCocoaObject
kungFuDeathGrip
(
self
)
;
RefPtr
<
nsChildView
>
geckoChild
(
mGeckoChild
)
;
RefPtr
<
a11y
:
:
LocalAccessible
>
accessible
=
geckoChild
-
>
GetDocumentAccessible
(
)
;
if
(
!
accessible
)
return
nil
;
accessible
-
>
GetNativeInterface
(
(
void
*
*
)
&
nativeAccessible
)
;
#
ifdef
DEBUG_hakan
NSAssert
(
!
[
nativeAccessible
isExpired
]
"
native
acc
is
expired
!
!
!
"
)
;
#
endif
return
nativeAccessible
;
}
-
(
BOOL
)
hasRepresentedView
{
return
YES
;
}
-
(
id
)
representedView
{
return
self
;
}
-
(
BOOL
)
isRoot
{
return
[
[
self
accessible
]
isRoot
]
;
}
#
pragma
mark
-
-
(
BOOL
)
isAccessibilityElement
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
isAccessibilityElement
]
;
return
[
[
self
accessible
]
isAccessibilityElement
]
;
}
-
(
id
)
accessibilityHitTest
:
(
NSPoint
)
point
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityHitTest
:
point
]
;
return
[
[
self
accessible
]
accessibilityHitTest
:
point
]
;
}
-
(
id
)
accessibilityFocusedUIElement
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityFocusedUIElement
]
;
return
[
[
self
accessible
]
accessibilityFocusedUIElement
]
;
}
-
(
NSArray
*
)
accessibilityActionNames
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityActionNames
]
;
return
[
[
self
accessible
]
accessibilityActionNames
]
;
}
-
(
NSString
*
)
accessibilityActionDescription
:
(
NSString
*
)
action
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityActionDescription
:
action
]
;
return
[
[
self
accessible
]
accessibilityActionDescription
:
action
]
;
}
-
(
void
)
accessibilityPerformAction
:
(
NSString
*
)
action
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityPerformAction
:
action
]
;
return
[
[
self
accessible
]
accessibilityPerformAction
:
action
]
;
}
-
(
NSArray
*
)
accessibilityAttributeNames
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityAttributeNames
]
;
return
[
[
self
accessible
]
accessibilityAttributeNames
]
;
}
-
(
BOOL
)
accessibilityIsAttributeSettable
:
(
NSString
*
)
attribute
{
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityIsAttributeSettable
:
attribute
]
;
return
[
[
self
accessible
]
accessibilityIsAttributeSettable
:
attribute
]
;
}
-
(
id
)
accessibilityAttributeValue
:
(
NSString
*
)
attribute
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
!
mozilla
:
:
a11y
:
:
ShouldA11yBeEnabled
(
)
)
return
[
super
accessibilityAttributeValue
:
attribute
]
;
id
<
mozAccessible
>
accessible
=
[
self
accessible
]
;
if
(
[
attribute
isEqualToString
:
NSAccessibilityParentAttribute
]
&
&
[
accessible
isRoot
]
)
{
id
parentAccessible
=
[
super
accessibilityAttributeValue
:
attribute
]
;
return
parentAccessible
;
}
return
[
accessible
accessibilityAttributeValue
:
attribute
]
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
nil
)
;
}
#
endif
+
(
uint32_t
)
sUniqueKeyEventId
{
return
sUniqueKeyEventId
;
}
+
(
NSMutableDictionary
*
)
sNativeKeyEventsMap
{
static
NSMutableDictionary
*
sNativeKeyEventsMap
=
[
[
NSMutableDictionary
alloc
]
init
]
;
return
sNativeKeyEventsMap
;
}
end
implementation
PixelHostingView
-
(
id
)
initWithFrame
:
(
NSRect
)
aRect
{
self
=
[
super
initWithFrame
:
aRect
]
;
self
.
wantsLayer
=
YES
;
self
.
layerContentsRedrawPolicy
=
NSViewLayerContentsRedrawDuringViewResize
;
return
self
;
}
-
(
BOOL
)
isFlipped
{
return
YES
;
}
-
(
NSView
*
)
hitTest
:
(
NSPoint
)
aPoint
{
return
nil
;
}
-
(
void
)
drawRect
:
(
NSRect
)
aRect
{
NS_WARNING
(
"
Unexpected
call
to
drawRect
:
This
view
returns
YES
from
wantsUpdateLayer
so
"
"
drawRect
should
not
be
called
.
"
)
;
}
-
(
BOOL
)
wantsUpdateLayer
{
return
YES
;
}
-
(
void
)
updateLayer
{
[
(
ChildView
*
)
[
self
superview
]
updateRootCALayer
]
;
}
-
(
BOOL
)
wantsBestResolutionOpenGLSurface
{
return
nsCocoaUtils
:
:
HiDPIEnabled
(
)
?
YES
:
NO
;
}
end
#
pragma
mark
-
void
ChildViewMouseTracker
:
:
OnDestroyView
(
ChildView
*
aView
)
{
if
(
sLastMouseEventView
=
=
aView
)
{
sLastMouseEventView
=
nil
;
[
sLastMouseMoveEvent
release
]
;
sLastMouseMoveEvent
=
nil
;
}
}
void
ChildViewMouseTracker
:
:
OnDestroyWindow
(
NSWindow
*
aWindow
)
{
if
(
sWindowUnderMouse
=
=
aWindow
)
{
sWindowUnderMouse
=
nil
;
}
}
void
ChildViewMouseTracker
:
:
MouseEnteredWindow
(
NSEvent
*
aEvent
)
{
sWindowUnderMouse
=
[
aEvent
window
]
;
ReEvaluateMouseEnterState
(
aEvent
)
;
}
void
ChildViewMouseTracker
:
:
MouseExitedWindow
(
NSEvent
*
aEvent
)
{
if
(
sWindowUnderMouse
=
=
[
aEvent
window
]
)
{
sWindowUnderMouse
=
nil
;
[
sLastMouseMoveEvent
release
]
;
sLastMouseMoveEvent
=
nil
;
ReEvaluateMouseEnterState
(
aEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
NativeMenuOpened
(
)
{
sWindowUnderMouse
=
nil
;
ReEvaluateMouseEnterState
(
nil
)
;
}
void
ChildViewMouseTracker
:
:
NativeMenuClosed
(
)
{
if
(
sLastMouseMoveEvent
)
{
sWindowUnderMouse
=
sLastMouseMoveEvent
.
window
;
ReEvaluateMouseEnterState
(
sLastMouseMoveEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
ReEvaluateMouseEnterState
(
NSEvent
*
aEvent
ChildView
*
aOldView
)
{
ChildView
*
oldView
=
aOldView
?
aOldView
:
sLastMouseEventView
;
sLastMouseEventView
=
ViewForEvent
(
aEvent
)
;
if
(
sLastMouseEventView
!
=
oldView
)
{
WidgetMouseEvent
:
:
ExitFrom
exitFrom
=
[
sLastMouseEventView
window
]
=
=
[
oldView
window
]
?
WidgetMouseEvent
:
:
ePlatformChild
:
WidgetMouseEvent
:
:
ePlatformTopLevel
;
[
oldView
sendMouseEnterOrExitEvent
:
aEvent
enter
:
NO
exitFrom
:
exitFrom
]
;
if
(
exitFrom
=
=
WidgetMouseEvent
:
:
ePlatformTopLevel
)
{
[
[
nsCursorManager
sharedInstance
]
setNonCustomCursor
:
nsIWidget
:
:
Cursor
{
eCursor_standard
}
]
;
}
[
sLastMouseEventView
sendMouseEnterOrExitEvent
:
aEvent
enter
:
YES
exitFrom
:
exitFrom
]
;
}
}
void
ChildViewMouseTracker
:
:
ResendLastMouseMoveEvent
(
)
{
if
(
sLastMouseMoveEvent
)
{
MouseMoved
(
sLastMouseMoveEvent
)
;
}
}
void
ChildViewMouseTracker
:
:
MouseMoved
(
NSEvent
*
aEvent
)
{
MouseEnteredWindow
(
aEvent
)
;
[
sLastMouseEventView
handleMouseMoved
:
aEvent
]
;
if
(
sLastMouseMoveEvent
!
=
aEvent
)
{
[
sLastMouseMoveEvent
release
]
;
sLastMouseMoveEvent
=
[
aEvent
retain
]
;
}
}
void
ChildViewMouseTracker
:
:
MouseScrolled
(
NSEvent
*
aEvent
)
{
if
(
!
nsCocoaUtils
:
:
IsMomentumScrollEvent
(
aEvent
)
)
{
sLastScrollEventScreenLocation
=
nsCocoaUtils
:
:
ScreenLocationForEvent
(
aEvent
)
;
}
}
ChildView
*
ChildViewMouseTracker
:
:
ViewForEvent
(
NSEvent
*
aEvent
)
{
NSWindow
*
window
=
sWindowUnderMouse
;
if
(
!
window
)
return
nil
;
NSPoint
windowEventLocation
=
nsCocoaUtils
:
:
EventLocationForWindow
(
aEvent
window
)
;
NSView
*
view
=
[
[
[
window
contentView
]
superview
]
hitTest
:
windowEventLocation
]
;
if
(
!
[
view
isKindOfClass
:
[
ChildView
class
]
]
)
return
nil
;
ChildView
*
childView
=
(
ChildView
*
)
view
;
if
(
!
[
childView
widget
]
)
return
nil
;
return
WindowAcceptsEvent
(
window
aEvent
childView
)
?
childView
:
nil
;
}
BOOL
ChildViewMouseTracker
:
:
WindowAcceptsEvent
(
NSWindow
*
aWindow
NSEvent
*
aEvent
ChildView
*
aView
BOOL
aIsClickThrough
)
{
if
(
!
aWindow
|
|
[
aEvent
type
]
=
=
NSEventTypeRightMouseDown
)
return
YES
;
id
delegate
=
[
aWindow
delegate
]
;
if
(
!
delegate
|
|
!
[
delegate
isKindOfClass
:
[
WindowDelegate
class
]
]
)
return
YES
;
nsIWidget
*
windowWidget
=
[
(
WindowDelegate
*
)
delegate
geckoWidget
]
;
if
(
!
windowWidget
)
return
YES
;
NSWindow
*
topLevelWindow
=
nil
;
switch
(
windowWidget
-
>
WindowType
(
)
)
{
case
eWindowType_popup
:
return
WindowAcceptsEvent
(
[
aWindow
parentWindow
]
aEvent
aView
aIsClickThrough
)
;
case
eWindowType_toplevel
:
case
eWindowType_dialog
:
if
(
[
aWindow
attachedSheet
]
)
return
NO
;
topLevelWindow
=
aWindow
;
break
;
case
eWindowType_sheet
:
{
nsIWidget
*
parentWidget
=
windowWidget
-
>
GetSheetWindowParent
(
)
;
if
(
!
parentWidget
)
return
YES
;
topLevelWindow
=
(
NSWindow
*
)
parentWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
break
;
}
default
:
return
YES
;
}
if
(
!
topLevelWindow
|
|
(
[
topLevelWindow
isMainWindow
]
&
&
!
aIsClickThrough
)
|
|
[
aEvent
type
]
=
=
NSEventTypeOtherMouseDown
|
|
(
(
[
aEvent
modifierFlags
]
&
NSEventModifierFlagCommand
)
!
=
0
&
&
[
aEvent
type
]
!
=
NSEventTypeMouseMoved
)
)
return
YES
;
return
[
aView
inactiveWindowAcceptsMouseEvent
:
aEvent
]
;
}
#
pragma
mark
-
