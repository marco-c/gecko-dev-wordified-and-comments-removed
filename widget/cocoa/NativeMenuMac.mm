#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
NativeMenuMac
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsMenuGroupOwnerX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
PresShell
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsIFrame
.
h
"
namespace
mozilla
{
using
dom
:
:
Element
;
namespace
widget
{
NativeMenuMac
:
:
NativeMenuMac
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
:
mContainerStatusBarItem
(
nil
)
{
MOZ_RELEASE_ASSERT
(
aElement
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
menupopup
)
)
;
mMenuGroupOwner
=
new
nsMenuGroupOwnerX
(
aElement
nullptr
)
;
mMenu
=
MakeRefPtr
<
nsMenuX
>
(
nullptr
mMenuGroupOwner
aElement
)
;
mMenu
-
>
SetObserver
(
this
)
;
mMenu
-
>
SetIconListener
(
this
)
;
mMenu
-
>
SetupIcon
(
)
;
}
NativeMenuMac
:
:
~
NativeMenuMac
(
)
{
mMenu
-
>
DetachFromGroupOwnerRecursive
(
)
;
mMenu
-
>
ClearObserver
(
)
;
mMenu
-
>
ClearIconListener
(
)
;
}
static
void
UpdateMenu
(
nsMenuX
*
aMenu
)
{
aMenu
-
>
MenuOpened
(
)
;
aMenu
-
>
MenuClosed
(
)
;
uint32_t
itemCount
=
aMenu
-
>
GetItemCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
itemCount
;
i
+
+
)
{
nsMenuX
:
:
MenuChild
menuObject
=
*
aMenu
-
>
GetItemAt
(
i
)
;
if
(
menuObject
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
)
{
UpdateMenu
(
menuObject
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
)
;
}
}
}
void
NativeMenuMac
:
:
MenuWillOpen
(
)
{
UpdateMenu
(
mMenu
.
get
(
)
)
;
}
bool
NativeMenuMac
:
:
ActivateNativeMenuItemAt
(
const
nsAString
&
aIndexString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSMenu
*
menu
=
mMenu
-
>
NativeNSMenu
(
)
;
nsMenuUtilsX
:
:
CheckNativeMenuConsistency
(
menu
)
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aIndexString
.
BeginReading
(
)
)
length
:
aIndexString
.
Length
(
)
]
;
NSMenuItem
*
item
=
nsMenuUtilsX
:
:
NativeMenuItemWithLocation
(
menu
locationString
false
)
;
if
(
item
&
&
!
item
.
hasSubmenu
)
{
NSMenu
*
parent
=
item
.
menu
;
if
(
parent
)
{
[
parent
performActionForItemAtIndex
:
[
parent
indexOfItem
:
item
]
]
;
return
true
;
}
}
return
false
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
ForceUpdateNativeMenuAt
(
const
nsAString
&
aIndexString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aIndexString
.
BeginReading
(
)
)
length
:
aIndexString
.
Length
(
)
]
;
NSArray
<
NSString
*
>
*
indexes
=
[
locationString
componentsSeparatedByString
:
"
|
"
]
;
RefPtr
<
nsMenuX
>
currentMenu
=
mMenu
.
get
(
)
;
unsigned
int
indexCount
=
indexes
.
count
;
for
(
unsigned
int
i
=
1
;
currentMenu
&
&
i
<
indexCount
;
i
+
+
)
{
int
targetIndex
=
[
indexes
objectAtIndex
:
i
]
.
intValue
;
int
visible
=
0
;
uint32_t
length
=
currentMenu
-
>
GetItemCount
(
)
;
for
(
unsigned
int
j
=
0
;
j
<
length
;
j
+
+
)
{
Maybe
<
nsMenuX
:
:
MenuChild
>
targetMenu
=
currentMenu
-
>
GetItemAt
(
j
)
;
if
(
!
targetMenu
)
{
return
;
}
RefPtr
<
nsIContent
>
content
=
targetMenu
-
>
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
content
)
)
{
visible
+
+
;
if
(
targetMenu
-
>
is
<
RefPtr
<
nsMenuX
>
>
(
)
&
&
visible
=
=
(
targetIndex
+
1
)
)
{
currentMenu
=
targetMenu
-
>
as
<
RefPtr
<
nsMenuX
>
>
(
)
;
break
;
}
}
}
}
currentMenu
-
>
MenuOpened
(
)
;
currentMenu
-
>
MenuClosed
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
IconUpdated
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mContainerStatusBarItem
)
{
NSImage
*
menuImage
=
mMenu
-
>
NativeNSMenuItem
(
)
.
image
;
if
(
menuImage
)
{
[
menuImage
setTemplate
:
YES
]
;
}
mContainerStatusBarItem
.
image
=
menuImage
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
SetContainerStatusBarItem
(
NSStatusItem
*
aItem
)
{
mContainerStatusBarItem
=
aItem
;
IconUpdated
(
)
;
}
void
NativeMenuMac
:
:
Dump
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mMenu
-
>
Dump
(
0
)
;
nsMenuUtilsX
:
:
DumpNativeMenu
(
mMenu
-
>
NativeNSMenu
(
)
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
OnMenuOpened
(
)
{
RefPtr
<
NativeMenuMac
>
kungFuDeathGrip
(
this
)
;
for
(
NativeMenu
:
:
Observer
*
observer
:
mObservers
.
Clone
(
)
)
{
observer
-
>
OnNativeMenuOpened
(
)
;
}
}
void
NativeMenuMac
:
:
OnMenuClosed
(
)
{
RefPtr
<
NativeMenuMac
>
kungFuDeathGrip
(
this
)
;
for
(
NativeMenu
:
:
Observer
*
observer
:
mObservers
.
Clone
(
)
)
{
observer
-
>
OnNativeMenuClosed
(
)
;
}
}
static
NSView
*
NativeViewForContent
(
nsIContent
*
aContent
)
{
mozilla
:
:
dom
:
:
Document
*
doc
=
aContent
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nil
;
}
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nil
;
}
nsIFrame
*
frame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
frame
)
{
return
nil
;
}
nsIWidget
*
widget
=
frame
-
>
GetNearestWidget
(
)
;
return
(
NSView
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
}
bool
NativeMenuMac
:
:
ShowAsContextMenu
(
const
mozilla
:
:
DesktopPoint
&
aPosition
)
{
bool
allowOpening
=
mMenu
-
>
OnOpen
(
)
;
if
(
!
allowOpening
)
{
return
false
;
}
mozilla
:
:
DesktopPoint
position
=
aPosition
;
RefPtr
<
NativeMenuMac
>
self
=
this
;
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
nsStandaloneNativeMenu
:
:
OpenMenu
"
[
=
]
(
)
{
self
-
>
OpenMenu
(
position
)
;
}
)
)
;
return
true
;
}
void
NativeMenuMac
:
:
OpenMenu
(
const
mozilla
:
:
DesktopPoint
&
aPosition
)
{
NSView
*
view
=
NativeViewForContent
(
mMenu
-
>
Content
(
)
)
;
NSMenu
*
nativeMenu
=
mMenu
-
>
NativeNSMenu
(
)
;
NSPoint
locationOnScreen
=
nsCocoaUtils
:
:
GeckoPointToCocoaPoint
(
aPosition
)
;
if
(
view
)
{
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
view
.
window
locationOnScreen
)
;
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
locationInWindow
modifierFlags
:
0
timestamp
:
[
[
NSProcessInfo
processInfo
]
systemUptime
]
windowNumber
:
view
.
window
.
windowNumber
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0f
]
;
[
NSMenu
popUpContextMenu
:
nativeMenu
withEvent
:
event
forView
:
view
]
;
}
else
{
[
nativeMenu
popUpMenuPositioningItem
:
nil
atLocation
:
locationOnScreen
inView
:
nil
]
;
}
}
}
}
