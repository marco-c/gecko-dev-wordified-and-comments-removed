#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
NativeMenuMac
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsMenuGroupOwnerX
.
h
"
#
include
"
nsMenuItemX
.
h
"
#
include
"
nsMenuUtilsX
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
PresShell
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsCocoaFeatures
.
h
"
#
if
!
defined
(
MAC_OS_X_VERSION_10_14
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_X_VERSION_10_14
interface
NSApplication
(
NSApplicationAppearance
)
property
(
readonly
strong
)
NSAppearance
*
effectiveAppearance
NS_AVAILABLE_MAC
(
10_14
)
;
end
#
endif
#
if
!
defined
(
MAC_OS_VERSION_11_0
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_VERSION_11_0
interface
NSMenu
(
NSMenuAppearance
)
-
(
void
)
setAppearance
:
(
NSAppearance
*
)
appearance
;
end
#
endif
namespace
mozilla
{
using
dom
:
:
Element
;
namespace
widget
{
NativeMenuMac
:
:
NativeMenuMac
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
:
mElement
(
aElement
)
mContainerStatusBarItem
(
nil
)
{
MOZ_RELEASE_ASSERT
(
aElement
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
menupopup
)
)
;
mMenuGroupOwner
=
new
nsMenuGroupOwnerX
(
aElement
nullptr
)
;
mMenu
=
MakeRefPtr
<
nsMenuX
>
(
nullptr
mMenuGroupOwner
aElement
)
;
mMenu
-
>
SetObserver
(
this
)
;
mMenu
-
>
SetIconListener
(
this
)
;
mMenu
-
>
SetupIcon
(
)
;
}
NativeMenuMac
:
:
~
NativeMenuMac
(
)
{
mMenu
-
>
DetachFromGroupOwnerRecursive
(
)
;
mMenu
-
>
ClearObserver
(
)
;
mMenu
-
>
ClearIconListener
(
)
;
}
static
void
UpdateMenu
(
nsMenuX
*
aMenu
)
{
aMenu
-
>
MenuOpened
(
)
;
aMenu
-
>
MenuClosed
(
)
;
uint32_t
itemCount
=
aMenu
-
>
GetItemCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
itemCount
;
i
+
+
)
{
nsMenuX
:
:
MenuChild
menuObject
=
*
aMenu
-
>
GetItemAt
(
i
)
;
if
(
menuObject
.
is
<
RefPtr
<
nsMenuX
>
>
(
)
)
{
UpdateMenu
(
menuObject
.
as
<
RefPtr
<
nsMenuX
>
>
(
)
)
;
}
}
}
void
NativeMenuMac
:
:
MenuWillOpen
(
)
{
UpdateMenu
(
mMenu
.
get
(
)
)
;
}
bool
NativeMenuMac
:
:
ActivateNativeMenuItemAt
(
const
nsAString
&
aIndexString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSMenu
*
menu
=
mMenu
-
>
NativeNSMenu
(
)
;
nsMenuUtilsX
:
:
CheckNativeMenuConsistency
(
menu
)
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aIndexString
.
BeginReading
(
)
)
length
:
aIndexString
.
Length
(
)
]
;
NSMenuItem
*
item
=
nsMenuUtilsX
:
:
NativeMenuItemWithLocation
(
menu
locationString
false
)
;
if
(
item
&
&
!
item
.
hasSubmenu
)
{
NSMenu
*
parent
=
item
.
menu
;
if
(
parent
)
{
[
parent
performActionForItemAtIndex
:
[
parent
indexOfItem
:
item
]
]
;
return
true
;
}
}
return
false
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
ForceUpdateNativeMenuAt
(
const
nsAString
&
aIndexString
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSString
*
locationString
=
[
NSString
stringWithCharacters
:
reinterpret_cast
<
const
unichar
*
>
(
aIndexString
.
BeginReading
(
)
)
length
:
aIndexString
.
Length
(
)
]
;
NSArray
<
NSString
*
>
*
indexes
=
[
locationString
componentsSeparatedByString
:
"
|
"
]
;
RefPtr
<
nsMenuX
>
currentMenu
=
mMenu
.
get
(
)
;
unsigned
int
indexCount
=
indexes
.
count
;
for
(
unsigned
int
i
=
1
;
currentMenu
&
&
i
<
indexCount
;
i
+
+
)
{
int
targetIndex
=
[
indexes
objectAtIndex
:
i
]
.
intValue
;
int
visible
=
0
;
uint32_t
length
=
currentMenu
-
>
GetItemCount
(
)
;
for
(
unsigned
int
j
=
0
;
j
<
length
;
j
+
+
)
{
Maybe
<
nsMenuX
:
:
MenuChild
>
targetMenu
=
currentMenu
-
>
GetItemAt
(
j
)
;
if
(
!
targetMenu
)
{
return
;
}
RefPtr
<
nsIContent
>
content
=
targetMenu
-
>
match
(
[
]
(
const
RefPtr
<
nsMenuX
>
&
aMenu
)
{
return
aMenu
-
>
Content
(
)
;
}
[
]
(
const
RefPtr
<
nsMenuItemX
>
&
aMenuItem
)
{
return
aMenuItem
-
>
Content
(
)
;
}
)
;
if
(
!
nsMenuUtilsX
:
:
NodeIsHiddenOrCollapsed
(
content
)
)
{
visible
+
+
;
if
(
targetMenu
-
>
is
<
RefPtr
<
nsMenuX
>
>
(
)
&
&
visible
=
=
(
targetIndex
+
1
)
)
{
currentMenu
=
targetMenu
-
>
as
<
RefPtr
<
nsMenuX
>
>
(
)
;
break
;
}
}
}
}
currentMenu
-
>
MenuOpened
(
)
;
currentMenu
-
>
MenuClosed
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
IconUpdated
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mContainerStatusBarItem
)
{
NSImage
*
menuImage
=
mMenu
-
>
NativeNSMenuItem
(
)
.
image
;
if
(
menuImage
)
{
[
menuImage
setTemplate
:
YES
]
;
}
mContainerStatusBarItem
.
image
=
menuImage
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
SetContainerStatusBarItem
(
NSStatusItem
*
aItem
)
{
mContainerStatusBarItem
=
aItem
;
IconUpdated
(
)
;
}
void
NativeMenuMac
:
:
Dump
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mMenu
-
>
Dump
(
0
)
;
nsMenuUtilsX
:
:
DumpNativeMenu
(
mMenu
-
>
NativeNSMenu
(
)
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
NativeMenuMac
:
:
OnMenuOpened
(
)
{
RefPtr
<
NativeMenuMac
>
kungFuDeathGrip
(
this
)
;
for
(
NativeMenu
:
:
Observer
*
observer
:
mObservers
.
Clone
(
)
)
{
observer
-
>
OnNativeMenuOpened
(
)
;
}
}
void
NativeMenuMac
:
:
OnMenuClosed
(
)
{
RefPtr
<
NativeMenuMac
>
kungFuDeathGrip
(
this
)
;
for
(
NativeMenu
:
:
Observer
*
observer
:
mObservers
.
Clone
(
)
)
{
observer
-
>
OnNativeMenuClosed
(
)
;
}
}
static
NSView
*
NativeViewForContent
(
nsIContent
*
aContent
)
{
mozilla
:
:
dom
:
:
Document
*
doc
=
aContent
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nil
;
}
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nil
;
}
nsIFrame
*
frame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
frame
)
{
return
nil
;
}
nsIWidget
*
widget
=
frame
-
>
GetNearestWidget
(
)
;
return
(
NSView
*
)
widget
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
;
}
void
NativeMenuMac
:
:
ShowAsContextMenu
(
const
mozilla
:
:
DesktopPoint
&
aPosition
)
{
mMenu
-
>
PopupShowingEventWasSentAndApprovedExternally
(
)
;
mozilla
:
:
DesktopPoint
position
=
aPosition
;
RefPtr
<
NativeMenuMac
>
self
=
this
;
NS_DispatchToCurrentThread
(
NS_NewRunnableFunction
(
"
nsStandaloneNativeMenu
:
:
OpenMenu
"
[
=
]
(
)
{
self
-
>
OpenMenu
(
position
)
;
}
)
)
;
}
void
NativeMenuMac
:
:
OpenMenu
(
const
mozilla
:
:
DesktopPoint
&
aPosition
)
{
NSView
*
view
=
NativeViewForContent
(
mMenu
-
>
Content
(
)
)
;
NSMenu
*
nativeMenu
=
mMenu
-
>
NativeNSMenu
(
)
;
if
(
available
(
macOS
10
.
14
*
)
)
{
#
if
!
defined
(
MAC_OS_VERSION_11_0
)
|
|
MAC_OS_X_VERSION_MAX_ALLOWED
<
MAC_OS_VERSION_11_0
if
(
nsCocoaFeatures
:
:
OnBigSurOrLater
(
)
)
{
#
else
if
(
available
(
macOS
11
.
0
*
)
)
{
#
endif
[
nativeMenu
setAppearance
:
NSApp
.
effectiveAppearance
]
;
}
}
NSPoint
locationOnScreen
=
nsCocoaUtils
:
:
GeckoPointToCocoaPoint
(
aPosition
)
;
if
(
view
)
{
NSPoint
locationInWindow
=
nsCocoaUtils
:
:
ConvertPointFromScreen
(
view
.
window
locationOnScreen
)
;
NSEvent
*
event
=
[
NSEvent
mouseEventWithType
:
NSEventTypeRightMouseDown
location
:
locationInWindow
modifierFlags
:
0
timestamp
:
[
[
NSProcessInfo
processInfo
]
systemUptime
]
windowNumber
:
view
.
window
.
windowNumber
context
:
nil
eventNumber
:
0
clickCount
:
1
pressure
:
0
.
0f
]
;
[
NSMenu
popUpContextMenu
:
nativeMenu
withEvent
:
event
forView
:
view
]
;
}
else
{
[
nativeMenu
popUpMenuPositioningItem
:
nil
atLocation
:
locationOnScreen
inView
:
nil
]
;
}
}
bool
NativeMenuMac
:
:
Close
(
)
{
return
mMenu
-
>
Close
(
)
;
}
RefPtr
<
nsMenuX
>
NativeMenuMac
:
:
GetOpenMenuContainingElement
(
dom
:
:
Element
*
aElement
)
{
nsTArray
<
RefPtr
<
dom
:
:
Element
>
>
submenuChain
;
RefPtr
<
dom
:
:
Element
>
currentElement
=
aElement
-
>
GetParentElement
(
)
;
while
(
currentElement
&
&
currentElement
!
=
mElement
)
{
if
(
currentElement
-
>
IsXULElement
(
nsGkAtoms
:
:
menu
)
)
{
submenuChain
.
AppendElement
(
currentElement
)
;
}
currentElement
=
currentElement
-
>
GetParentElement
(
)
;
}
if
(
!
currentElement
)
{
return
nullptr
;
}
submenuChain
.
Reverse
(
)
;
RefPtr
<
nsMenuX
>
menu
=
mMenu
;
for
(
const
auto
&
submenu
:
submenuChain
)
{
if
(
!
menu
-
>
IsOpenForGecko
(
)
)
{
return
nullptr
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
menuChild
=
menu
-
>
GetItemForElement
(
submenu
)
;
if
(
!
menuChild
|
|
!
menuChild
-
>
is
<
RefPtr
<
nsMenuX
>
>
(
)
)
{
return
nullptr
;
}
menu
=
menuChild
-
>
as
<
RefPtr
<
nsMenuX
>
>
(
)
;
}
return
menu
;
}
static
NSEventModifierFlags
ConvertModifierFlags
(
Modifiers
aModifiers
)
{
NSEventModifierFlags
flags
=
0
;
if
(
aModifiers
&
MODIFIER_CONTROL
)
{
flags
|
=
NSEventModifierFlagControl
;
}
if
(
aModifiers
&
MODIFIER_ALT
)
{
flags
|
=
NSEventModifierFlagOption
;
}
if
(
aModifiers
&
MODIFIER_SHIFT
)
{
flags
|
=
NSEventModifierFlagShift
;
}
if
(
aModifiers
&
MODIFIER_META
)
{
flags
|
=
NSEventModifierFlagCommand
;
}
return
flags
;
}
void
NativeMenuMac
:
:
ActivateItem
(
dom
:
:
Element
*
aItemElement
Modifiers
aModifiers
ErrorResult
&
aRv
)
{
RefPtr
<
nsMenuX
>
menu
=
GetOpenMenuContainingElement
(
aItemElement
)
;
if
(
!
menu
)
{
aRv
.
ThrowInvalidStateError
(
"
Menu
containing
menu
item
is
not
open
"
)
;
return
;
}
Maybe
<
nsMenuX
:
:
MenuChild
>
item
=
menu
-
>
GetItemForElement
(
aItemElement
)
;
if
(
!
item
|
|
!
item
-
>
is
<
RefPtr
<
nsMenuItemX
>
>
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Could
not
find
the
supplied
menu
item
"
)
;
return
;
}
mMenu
-
>
ActivateItemAndClose
(
std
:
:
move
(
item
-
>
as
<
RefPtr
<
nsMenuItemX
>
>
(
)
)
ConvertModifierFlags
(
aModifiers
)
)
;
}
RefPtr
<
Element
>
NativeMenuMac
:
:
Element
(
)
{
return
mElement
;
}
}
}
