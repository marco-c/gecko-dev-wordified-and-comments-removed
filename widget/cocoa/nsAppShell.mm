#
import
<
Cocoa
/
Cocoa
.
h
>
#
include
"
CustomCocoaEvents
.
h
"
#
include
"
mozilla
/
WidgetTraceEvent
.
h
"
#
include
"
nsAppShell
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsChildView
.
h
"
#
include
"
nsToolkit
.
h
"
#
include
"
TextInputHandler
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
ScreenHelperCocoa
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
widget
/
ScreenManager
.
h
"
#
include
"
HeadlessScreenHelper
.
h
"
#
include
"
pratom
.
h
"
#
if
!
defined
(
RELEASE_OR_BETA
)
|
|
defined
(
DEBUG
)
#
include
"
nsSandboxViolationSink
.
h
"
#
endif
#
include
<
IOKit
/
pwr_mgt
/
IOPMLib
.
h
>
#
include
"
nsIDOMWakeLockListener
.
h
"
#
include
"
nsIPowerManagerService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
#
define
WAKE_LOCK_LOG
(
.
.
.
)
MOZ_LOG
(
gMacWakeLockLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
static
mozilla
:
:
LazyLogModule
gMacWakeLockLog
(
"
MacWakeLock
"
)
;
class
MacWakeLockListener
final
:
public
nsIDOMMozWakeLockListener
{
public
:
NS_DECL_ISUPPORTS
;
private
:
~
MacWakeLockListener
(
)
{
}
IOPMAssertionID
mAssertionNoDisplaySleepID
=
kIOPMNullAssertionID
;
IOPMAssertionID
mAssertionNoIdleSleepID
=
kIOPMNullAssertionID
;
NS_IMETHOD
Callback
(
const
nsAString
&
aTopic
const
nsAString
&
aState
)
override
{
if
(
!
aTopic
.
EqualsASCII
(
"
screen
"
)
&
&
!
aTopic
.
EqualsASCII
(
"
audio
-
playing
"
)
&
&
!
aTopic
.
EqualsASCII
(
"
video
-
playing
"
)
)
{
return
NS_OK
;
}
if
(
aTopic
.
EqualsASCII
(
"
audio
-
playing
"
)
&
&
aState
.
EqualsASCII
(
"
locked
-
background
"
)
)
{
WAKE_LOCK_LOG
(
"
keep
audio
playing
even
in
background
"
)
;
return
NS_OK
;
}
bool
shouldKeepDisplayOn
=
aTopic
.
EqualsASCII
(
"
screen
"
)
|
|
aTopic
.
EqualsASCII
(
"
video
-
playing
"
)
;
CFStringRef
assertionType
=
shouldKeepDisplayOn
?
kIOPMAssertionTypeNoDisplaySleep
:
kIOPMAssertionTypeNoIdleSleep
;
IOPMAssertionID
&
assertionId
=
shouldKeepDisplayOn
?
mAssertionNoDisplaySleepID
:
mAssertionNoIdleSleepID
;
WAKE_LOCK_LOG
(
"
topic
=
%
s
state
=
%
s
shouldKeepDisplayOn
=
%
d
"
NS_ConvertUTF16toUTF8
(
aTopic
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aState
)
.
get
(
)
shouldKeepDisplayOn
)
;
if
(
aState
.
EqualsASCII
(
"
locked
-
foreground
"
)
)
{
if
(
assertionId
!
=
kIOPMNullAssertionID
)
{
WAKE_LOCK_LOG
(
"
already
has
a
lock
"
)
;
return
NS_OK
;
}
CFStringRef
cf_topic
=
:
:
CFStringCreateWithCharacters
(
kCFAllocatorDefault
reinterpret_cast
<
const
UniChar
*
>
(
aTopic
.
Data
(
)
)
aTopic
.
Length
(
)
)
;
IOReturn
success
=
:
:
IOPMAssertionCreateWithName
(
assertionType
kIOPMAssertionLevelOn
cf_topic
&
assertionId
)
;
CFRelease
(
cf_topic
)
;
if
(
success
!
=
kIOReturnSuccess
)
{
WAKE_LOCK_LOG
(
"
failed
to
disable
screensaver
"
)
;
}
WAKE_LOCK_LOG
(
"
create
screensaver
"
)
;
}
else
{
if
(
assertionId
!
=
kIOPMNullAssertionID
)
{
IOReturn
result
=
:
:
IOPMAssertionRelease
(
assertionId
)
;
if
(
result
!
=
kIOReturnSuccess
)
{
WAKE_LOCK_LOG
(
"
failed
to
release
screensaver
"
)
;
}
WAKE_LOCK_LOG
(
"
Release
screensaver
"
)
;
assertionId
=
kIOPMNullAssertionID
;
}
}
return
NS_OK
;
}
}
;
extern
int32_t
gXULModalLevel
;
static
bool
gAppShellMethodsSwizzled
=
false
;
implementation
GeckoNSApplication
-
(
void
)
sendEvent
:
(
NSEvent
*
)
anEvent
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
if
(
[
anEvent
type
]
=
=
NSEventTypeApplicationDefined
&
&
[
anEvent
subtype
]
=
=
kEventSubtypeTrace
)
{
mozilla
:
:
SignalTracerThread
(
)
;
return
;
}
[
super
sendEvent
:
anEvent
]
;
}
#
if
defined
(
MAC_OS_X_VERSION_10_12
)
&
&
MAC_OS_X_VERSION_MAX_ALLOWED
>
=
MAC_OS_X_VERSION_10_12
&
&
\
__LP64__
-
(
NSEvent
*
)
nextEventMatchingMask
:
(
NSEventMask
)
mask
#
else
-
(
NSEvent
*
)
nextEventMatchingMask
:
(
NSUInteger
)
mask
#
endif
untilDate
:
(
NSDate
*
)
expiration
inMode
:
(
NSString
*
)
mode
dequeue
:
(
BOOL
)
flag
{
if
(
expiration
)
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
}
NSEvent
*
nextEvent
=
[
super
nextEventMatchingMask
:
mask
untilDate
:
expiration
inMode
:
mode
dequeue
:
flag
]
;
if
(
expiration
)
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
}
return
nextEvent
;
}
end
interface
AppShellDelegate
:
NSObject
{
private
nsAppShell
*
mAppShell
;
}
-
(
id
)
initWithAppShell
:
(
nsAppShell
*
)
aAppShell
;
-
(
void
)
applicationWillTerminate
:
(
NSNotification
*
)
aNotification
;
-
(
void
)
beginMenuTracking
:
(
NSNotification
*
)
aNotification
;
end
NS_IMETHODIMP
nsAppShell
:
:
ResumeNative
(
void
)
{
nsresult
retval
=
nsBaseAppShell
:
:
ResumeNative
(
)
;
if
(
NS_SUCCEEDED
(
retval
)
&
&
(
mSuspendNativeCount
=
=
0
)
&
&
mSkippedNativeCallback
)
{
mSkippedNativeCallback
=
false
;
ScheduleNativeEventCallback
(
)
;
}
return
retval
;
}
nsAppShell
:
:
nsAppShell
(
)
:
mAutoreleasePools
(
nullptr
)
mDelegate
(
nullptr
)
mCFRunLoop
(
NULL
)
mCFRunLoopSource
(
NULL
)
mRunningEventLoop
(
false
)
mStarted
(
false
)
mTerminated
(
false
)
mSkippedNativeCallback
(
false
)
mNativeEventCallbackDepth
(
0
)
mNativeEventScheduledDepth
(
0
)
{
mRunningCocoaEmbedded
=
[
NSApp
isRunning
]
?
true
:
false
;
}
nsAppShell
:
:
~
nsAppShell
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
hal
:
:
Shutdown
(
)
;
if
(
mCFRunLoop
)
{
if
(
mCFRunLoopSource
)
{
:
:
CFRunLoopRemoveSource
(
mCFRunLoop
mCFRunLoopSource
kCFRunLoopCommonModes
)
;
:
:
CFRelease
(
mCFRunLoopSource
)
;
}
if
(
mCFRunLoopObserver
)
{
:
:
CFRunLoopRemoveObserver
(
mCFRunLoop
mCFRunLoopObserver
kCFRunLoopCommonModes
)
;
:
:
CFRelease
(
mCFRunLoopObserver
)
;
}
:
:
CFRelease
(
mCFRunLoop
)
;
}
if
(
mAutoreleasePools
)
{
NS_ASSERTION
(
:
:
CFArrayGetCount
(
mAutoreleasePools
)
=
=
0
"
nsAppShell
destroyed
without
popping
all
autorelease
pools
"
)
;
:
:
CFRelease
(
mAutoreleasePools
)
;
}
[
mDelegate
release
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
}
NS_IMPL_ISUPPORTS
(
MacWakeLockListener
nsIDOMMozWakeLockListener
)
mozilla
:
:
StaticRefPtr
<
MacWakeLockListener
>
sWakeLockListener
;
static
void
AddScreenWakeLockListener
(
)
{
nsCOMPtr
<
nsIPowerManagerService
>
sPowerManagerService
=
do_GetService
(
POWERMANAGERSERVICE_CONTRACTID
)
;
if
(
sPowerManagerService
)
{
sWakeLockListener
=
new
MacWakeLockListener
(
)
;
sPowerManagerService
-
>
AddWakeLockListener
(
sWakeLockListener
)
;
}
else
{
NS_WARNING
(
"
Failed
to
retrieve
PowerManagerService
wakelocks
will
be
broken
!
"
)
;
}
}
static
void
RemoveScreenWakeLockListener
(
)
{
nsCOMPtr
<
nsIPowerManagerService
>
sPowerManagerService
=
do_GetService
(
POWERMANAGERSERVICE_CONTRACTID
)
;
if
(
sPowerManagerService
)
{
sPowerManagerService
-
>
RemoveWakeLockListener
(
sWakeLockListener
)
;
sPowerManagerService
=
nullptr
;
sWakeLockListener
=
nullptr
;
}
}
void
RunLoopObserverCallback
(
CFRunLoopObserverRef
aObserver
CFRunLoopActivity
aActivity
void
*
aInfo
)
{
static_cast
<
nsAppShell
*
>
(
aInfo
)
-
>
OnRunLoopActivityChanged
(
aActivity
)
;
}
void
nsAppShell
:
:
OnRunLoopActivityChanged
(
CFRunLoopActivity
aActivity
)
{
#
ifdef
MOZ_GECKO_PROFILER
if
(
aActivity
=
=
kCFRunLoopBeforeWaiting
)
{
if
(
ProfilingStackOwner
*
profilingStackOwner
=
AutoProfilerLabel
:
:
ProfilingStackOwnerTLS
:
:
Get
(
)
)
{
mProfilingStackOwnerWhileWaiting
=
profilingStackOwner
;
uint8_t
variableOnStack
=
0
;
mProfilingStackOwnerWhileWaiting
-
>
ProfilingStack
(
)
.
pushLabelFrame
(
"
Native
event
loop
idle
"
nullptr
&
variableOnStack
JS
:
:
ProfilingCategoryPair
:
:
IDLE
0
)
;
}
}
else
{
if
(
mProfilingStackOwnerWhileWaiting
)
{
mProfilingStackOwnerWhileWaiting
-
>
ProfilingStack
(
)
.
pop
(
)
;
mProfilingStackOwnerWhileWaiting
=
nullptr
;
}
}
#
endif
}
nsresult
nsAppShell
:
:
Init
(
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NSAutoreleasePool
*
localPool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
mAutoreleasePools
=
:
:
CFArrayCreateMutable
(
nullptr
0
nullptr
)
;
NS_ENSURE_STATE
(
mAutoreleasePools
)
;
bool
isNSApplicationProcessType
=
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_RDD
)
&
&
(
XRE_GetProcessType
(
)
!
=
GeckoProcessType_Socket
)
;
if
(
isNSApplicationProcessType
)
{
[
[
NSBundle
mainBundle
]
loadNibNamed
:
"
res
/
MainMenu
"
owner
:
[
GeckoNSApplication
sharedApplication
]
topLevelObjects
:
nil
]
;
}
mDelegate
=
[
[
AppShellDelegate
alloc
]
initWithAppShell
:
this
]
;
NS_ENSURE_STATE
(
mDelegate
)
;
mCFRunLoop
=
[
[
NSRunLoop
currentRunLoop
]
getCFRunLoop
]
;
NS_ENSURE_STATE
(
mCFRunLoop
)
;
:
:
CFRetain
(
mCFRunLoop
)
;
CFRunLoopSourceContext
context
;
bzero
(
&
context
sizeof
(
context
)
)
;
context
.
info
=
this
;
context
.
perform
=
ProcessGeckoEvents
;
mCFRunLoopSource
=
:
:
CFRunLoopSourceCreate
(
kCFAllocatorDefault
0
&
context
)
;
NS_ENSURE_STATE
(
mCFRunLoopSource
)
;
:
:
CFRunLoopAddSource
(
mCFRunLoop
mCFRunLoopSource
kCFRunLoopCommonModes
)
;
CFRunLoopObserverContext
observerContext
;
PodZero
(
&
observerContext
)
;
observerContext
.
info
=
this
;
mCFRunLoopObserver
=
:
:
CFRunLoopObserverCreate
(
kCFAllocatorDefault
kCFRunLoopBeforeWaiting
|
kCFRunLoopAfterWaiting
|
kCFRunLoopExit
true
0
RunLoopObserverCallback
&
observerContext
)
;
NS_ENSURE_STATE
(
mCFRunLoopObserver
)
;
:
:
CFRunLoopAddObserver
(
mCFRunLoop
mCFRunLoopObserver
kCFRunLoopCommonModes
)
;
hal
:
:
Init
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
ScreenManager
&
screenManager
=
ScreenManager
:
:
GetSingleton
(
)
;
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
screenManager
.
SetHelper
(
mozilla
:
:
MakeUnique
<
HeadlessScreenHelper
>
(
)
)
;
}
else
{
screenManager
.
SetHelper
(
mozilla
:
:
MakeUnique
<
ScreenHelperCocoa
>
(
)
)
;
}
}
nsresult
rv
=
nsBaseAppShell
:
:
Init
(
)
;
if
(
isNSApplicationProcessType
&
&
!
gAppShellMethodsSwizzled
)
{
if
(
!
mRunningCocoaEmbedded
)
{
nsToolkit
:
:
SwizzleMethods
(
[
NSApplication
class
]
selector
(
terminate
:
)
selector
(
nsAppShell_NSApplication_terminate
:
)
)
;
}
gAppShellMethodsSwizzled
=
true
;
}
#
if
!
defined
(
RELEASE_OR_BETA
)
|
|
defined
(
DEBUG
)
if
(
Preferences
:
:
GetBool
(
"
security
.
sandbox
.
mac
.
track
.
violations
"
false
)
)
{
nsSandboxViolationSink
:
:
Start
(
)
;
}
#
endif
[
localPool
release
]
;
return
rv
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
void
nsAppShell
:
:
ProcessGeckoEvents
(
void
*
aInfo
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
AUTO_PROFILER_LABEL
(
"
nsAppShell
:
:
ProcessGeckoEvents
"
OTHER
)
;
nsAppShell
*
self
=
static_cast
<
nsAppShell
*
>
(
aInfo
)
;
if
(
self
-
>
mRunningEventLoop
)
{
self
-
>
mRunningEventLoop
=
false
;
[
NSApp
postEvent
:
[
NSEvent
otherEventWithType
:
NSEventTypeApplicationDefined
location
:
NSMakePoint
(
0
0
)
modifierFlags
:
0
timestamp
:
0
windowNumber
:
0
context
:
NULL
subtype
:
kEventSubtypeNone
data1
:
0
data2
:
0
]
atStart
:
NO
]
;
}
if
(
self
-
>
mSuspendNativeCount
<
=
0
)
{
+
+
self
-
>
mNativeEventCallbackDepth
;
self
-
>
NativeEventCallback
(
)
;
-
-
self
-
>
mNativeEventCallbackDepth
;
}
else
{
self
-
>
mSkippedNativeCallback
=
true
;
}
[
NSApp
postEvent
:
[
NSEvent
otherEventWithType
:
NSEventTypeApplicationDefined
location
:
NSMakePoint
(
0
0
)
modifierFlags
:
0
timestamp
:
0
windowNumber
:
0
context
:
NULL
subtype
:
kEventSubtypeNone
data1
:
0
data2
:
0
]
atStart
:
NO
]
;
if
(
self
-
>
mTerminated
)
{
int32_t
releaseCount
=
0
;
if
(
self
-
>
mNativeEventScheduledDepth
>
self
-
>
mNativeEventCallbackDepth
)
{
releaseCount
=
PR_ATOMIC_SET
(
&
self
-
>
mNativeEventScheduledDepth
self
-
>
mNativeEventCallbackDepth
)
;
}
while
(
releaseCount
-
-
>
self
-
>
mNativeEventCallbackDepth
)
self
-
>
Release
(
)
;
}
else
{
if
(
PR_ATOMIC_DECREMENT
(
&
self
-
>
mNativeEventScheduledDepth
)
<
0
)
{
PR_ATOMIC_SET
(
&
self
-
>
mNativeEventScheduledDepth
0
)
;
NS_WARNING
(
"
Spontaneous
call
to
ProcessGeckoEvents
(
)
!
"
)
;
}
else
{
self
-
>
Release
(
)
;
}
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
void
nsAppShell
:
:
WillTerminate
(
)
{
if
(
mTerminated
)
return
;
NS_ProcessPendingEvents
(
NS_GetCurrentThread
(
)
)
;
mTerminated
=
true
;
}
void
nsAppShell
:
:
ScheduleNativeEventCallback
(
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
if
(
mTerminated
)
return
;
NS_ADDREF_THIS
(
)
;
PR_ATOMIC_INCREMENT
(
&
mNativeEventScheduledDepth
)
;
:
:
CFRunLoopSourceSignal
(
mCFRunLoopSource
)
;
:
:
CFRunLoopWakeUp
(
mCFRunLoop
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
extern
"
C
"
EventAttributes
GetEventAttributes
(
EventRef
inEvent
)
;
bool
nsAppShell
:
:
ProcessNextNativeEvent
(
bool
aMayWait
)
{
bool
moreEvents
=
false
;
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
bool
eventProcessed
=
false
;
NSString
*
currentMode
=
nil
;
if
(
mTerminated
)
return
false
;
bool
wasRunningEventLoop
=
mRunningEventLoop
;
mRunningEventLoop
=
aMayWait
;
NSDate
*
waitUntil
=
nil
;
if
(
aMayWait
)
waitUntil
=
[
NSDate
distantFuture
]
;
NSRunLoop
*
currentRunLoop
=
[
NSRunLoop
currentRunLoop
]
;
EventQueueRef
currentEventQueue
=
GetCurrentEventQueue
(
)
;
EventTargetRef
eventDispatcherTarget
=
GetEventDispatcherTarget
(
)
;
if
(
aMayWait
)
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyWait
(
)
;
}
do
{
NS_ASSERTION
(
mAutoreleasePools
&
&
:
:
CFArrayGetCount
(
mAutoreleasePools
)
"
No
autorelease
pool
for
native
event
"
)
;
if
(
aMayWait
)
{
currentMode
=
[
currentRunLoop
currentMode
]
;
if
(
!
currentMode
)
currentMode
=
NSDefaultRunLoopMode
;
NSEvent
*
nextEvent
=
[
NSApp
nextEventMatchingMask
:
NSEventMaskAny
untilDate
:
waitUntil
inMode
:
currentMode
dequeue
:
YES
]
;
if
(
nextEvent
)
{
mozilla
:
:
BackgroundHangMonitor
(
)
.
NotifyActivity
(
)
;
[
NSApp
sendEvent
:
nextEvent
]
;
eventProcessed
=
true
;
}
}
else
{
EventRef
currentEvent
=
AcquireFirstMatchingEventInQueue
(
currentEventQueue
0
NULL
kEventQueueOptionsNone
)
;
if
(
!
currentEvent
)
{
continue
;
}
EventAttributes
attrs
=
GetEventAttributes
(
currentEvent
)
;
UInt32
eventKind
=
GetEventKind
(
currentEvent
)
;
UInt32
eventClass
=
GetEventClass
(
currentEvent
)
;
bool
osCocoaEvent
=
(
(
eventClass
=
=
'
appl
'
)
|
|
(
eventClass
=
=
kEventClassAppleEvent
)
|
|
(
(
eventClass
=
=
'
cgs
'
)
&
&
(
eventKind
!
=
NSEventTypeApplicationDefined
)
)
)
;
if
(
(
attrs
!
=
kEventAttributeNone
)
|
|
osCocoaEvent
)
{
eventProcessed
=
false
;
ReleaseEvent
(
currentEvent
)
;
break
;
}
RetainEvent
(
currentEvent
)
;
RemoveEventFromQueue
(
currentEventQueue
currentEvent
)
;
SendEventToEventTarget
(
currentEvent
eventDispatcherTarget
)
;
ReleaseEvent
(
currentEvent
)
;
eventProcessed
=
true
;
}
}
while
(
mRunningEventLoop
)
;
if
(
eventProcessed
)
{
moreEvents
=
(
AcquireFirstMatchingEventInQueue
(
currentEventQueue
0
NULL
kEventQueueOptionsNone
)
!
=
NULL
)
;
}
mRunningEventLoop
=
wasRunningEventLoop
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
if
(
!
moreEvents
)
{
nsChildView
:
:
UpdateCurrentInputEventCount
(
)
;
}
return
moreEvents
;
}
NS_IMETHODIMP
nsAppShell
:
:
Run
(
void
)
{
NS_ASSERTION
(
!
mStarted
"
nsAppShell
:
:
Run
(
)
called
multiple
times
"
)
;
if
(
mStarted
|
|
mTerminated
)
return
NS_OK
;
mStarted
=
true
;
if
(
XRE_IsParentProcess
(
)
)
{
AddScreenWakeLockListener
(
)
;
}
nsresult
rv
=
NS_OK
;
if
(
XRE_UseNativeEventProcessing
(
)
)
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
NSApp
run
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
else
{
rv
=
nsBaseAppShell
:
:
Run
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
RemoveScreenWakeLockListener
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsAppShell
:
:
Exit
(
void
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
if
(
mTerminated
)
{
NS_WARNING
(
"
nsAppShell
:
:
Exit
(
)
called
redundantly
"
)
;
return
NS_OK
;
}
mTerminated
=
true
;
#
if
!
defined
(
RELEASE_OR_BETA
)
|
|
defined
(
DEBUG
)
nsSandboxViolationSink
:
:
Stop
(
)
;
#
endif
BOOL
cocoaModal
=
[
NSApp
_isRunningModal
]
;
NS_ASSERTION
(
!
cocoaModal
"
Don
'
t
call
nsAppShell
:
:
Exit
(
)
from
a
modal
event
loop
!
"
)
;
if
(
cocoaModal
)
[
NSApp
stop
:
nullptr
]
;
[
NSApp
stop
:
nullptr
]
;
if
(
!
mNativeEventCallbackDepth
&
&
mNativeEventScheduledDepth
)
{
int32_t
releaseCount
=
PR_ATOMIC_SET
(
&
mNativeEventScheduledDepth
0
)
;
while
(
releaseCount
-
-
>
0
)
NS_RELEASE_THIS
(
)
;
}
return
nsBaseAppShell
:
:
Exit
(
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsAppShell
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aMayWait
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
NS_ASSERTION
(
mAutoreleasePools
"
No
stack
on
which
to
store
autorelease
pool
"
)
;
NSAutoreleasePool
*
pool
=
[
[
NSAutoreleasePool
alloc
]
init
]
;
:
:
CFArrayAppendValue
(
mAutoreleasePools
pool
)
;
return
nsBaseAppShell
:
:
OnProcessNextEvent
(
aThread
aMayWait
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsAppShell
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
aThread
bool
aEventWasProcessed
)
{
NS_OBJC_BEGIN_TRY_BLOCK_RETURN
;
CFIndex
count
=
:
:
CFArrayGetCount
(
mAutoreleasePools
)
;
NS_ASSERTION
(
mAutoreleasePools
&
&
count
"
Processed
an
event
but
there
'
s
no
autorelease
pool
?
"
)
;
const
NSAutoreleasePool
*
pool
=
static_cast
<
const
NSAutoreleasePool
*
>
(
:
:
CFArrayGetValueAtIndex
(
mAutoreleasePools
count
-
1
)
)
;
:
:
CFArrayRemoveValueAtIndex
(
mAutoreleasePools
count
-
1
)
;
[
pool
release
]
;
return
nsBaseAppShell
:
:
AfterProcessNextEvent
(
aThread
aEventWasProcessed
)
;
NS_OBJC_END_TRY_BLOCK_RETURN
(
NS_ERROR_FAILURE
)
;
}
implementation
AppShellDelegate
-
(
id
)
initWithAppShell
:
(
nsAppShell
*
)
aAppShell
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL
;
if
(
(
self
=
[
self
init
]
)
)
{
mAppShell
=
aAppShell
;
[
[
NSNotificationCenter
defaultCenter
]
addObserver
:
self
selector
:
selector
(
applicationWillTerminate
:
)
name
:
NSApplicationWillTerminateNotification
object
:
NSApp
]
;
[
[
NSNotificationCenter
defaultCenter
]
addObserver
:
self
selector
:
selector
(
applicationDidBecomeActive
:
)
name
:
NSApplicationDidBecomeActiveNotification
object
:
NSApp
]
;
[
[
NSDistributedNotificationCenter
defaultCenter
]
addObserver
:
self
selector
:
selector
(
beginMenuTracking
:
)
name
:
"
com
.
apple
.
HIToolbox
.
beginMenuTrackingNotification
"
object
:
nil
]
;
}
return
self
;
NS_OBJC_END_TRY_ABORT_BLOCK_NIL
;
}
-
(
void
)
dealloc
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
[
[
NSNotificationCenter
defaultCenter
]
removeObserver
:
self
]
;
[
[
NSDistributedNotificationCenter
defaultCenter
]
removeObserver
:
self
]
;
[
super
dealloc
]
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
applicationWillTerminate
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
mAppShell
-
>
WillTerminate
(
)
;
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
applicationDidBecomeActive
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSEvent
*
currentEvent
=
[
NSApp
currentEvent
]
;
if
(
currentEvent
)
{
TextInputHandler
:
:
sLastModifierState
=
[
currentEvent
modifierFlags
]
&
NSEventModifierFlagDeviceIndependentFlagsMask
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
nullptr
NS_WIDGET_MAC_APP_ACTIVATE_OBSERVER_TOPIC
nullptr
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
-
(
void
)
beginMenuTracking
:
(
NSNotification
*
)
aNotification
{
NS_OBJC_BEGIN_TRY_ABORT_BLOCK
;
NSString
*
sender
=
[
aNotification
object
]
;
if
(
!
sender
|
|
!
[
sender
isEqualToString
:
"
org
.
mozilla
.
gecko
.
PopupWindow
"
]
)
{
nsIRollupListener
*
rollupListener
=
nsBaseWidget
:
:
GetActiveRollupListener
(
)
;
nsCOMPtr
<
nsIWidget
>
rollupWidget
=
rollupListener
-
>
GetRollupWidget
(
)
;
if
(
rollupWidget
)
rollupListener
-
>
Rollup
(
0
true
nullptr
nullptr
)
;
}
NS_OBJC_END_TRY_ABORT_BLOCK
;
}
end
interface
NSApplication
(
MethodSwizzling
)
-
(
void
)
nsAppShell_NSApplication_terminate
:
(
id
)
sender
;
end
implementation
NSApplication
(
MethodSwizzling
)
-
(
void
)
nsAppShell_NSApplication_terminate
:
(
id
)
sender
{
[
[
NSNotificationCenter
defaultCenter
]
postNotificationName
:
NSApplicationWillTerminateNotification
object
:
NSApp
]
;
}
end
