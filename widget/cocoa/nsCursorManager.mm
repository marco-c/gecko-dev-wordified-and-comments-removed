#
include
"
imgIContainer
.
h
"
#
include
"
nsCocoaUtils
.
h
"
#
include
"
nsCursorManager
.
h
"
#
include
"
nsObjCExceptions
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
<
math
.
h
>
static
nsCursorManager
*
gInstance
;
static
CGFloat
sCurrentCursorScaleFactor
=
0
.
0f
;
static
nsIWidget
:
:
Cursor
sCurrentCursor
;
static
constexpr
nsCursor
kCustomCursor
=
eCursorCount
;
interface
nsCursorManager
(
PrivateMethods
)
-
(
NSCursor
*
)
getCursor
:
(
nsCursor
)
aCursor
;
-
(
nsresult
)
setMacCursor
:
(
NSCursor
*
)
aMacCursor
;
+
(
NSCursor
*
)
createCursor
:
(
enum
nsCursor
)
aCursor
;
end
interface
NSCursor
(
CreateWithImageNamed
)
+
(
NSCursor
*
)
cursorWithImageNamed
:
(
NSString
*
)
imageName
hotSpot
:
(
NSPoint
)
aPoint
;
end
implementation
nsCursorManager
+
(
nsCursorManager
*
)
sharedInstance
{
if
(
!
gInstance
)
{
gInstance
=
[
[
nsCursorManager
alloc
]
init
]
;
}
return
gInstance
;
}
+
(
void
)
dispose
{
[
gInstance
release
]
;
gInstance
=
nil
;
}
+
(
NSCursor
*
)
createCursor
:
(
enum
nsCursor
)
aCursor
{
switch
(
aCursor
)
{
case
eCursor_standard
:
return
[
NSCursor
arrowCursor
]
;
case
eCursor_wait
:
case
eCursor_spinning
:
return
[
NSCursor
busyButClickableCursor
]
;
case
eCursor_select
:
return
[
NSCursor
IBeamCursor
]
;
case
eCursor_hyperlink
:
return
[
NSCursor
pointingHandCursor
]
;
case
eCursor_crosshair
:
return
[
NSCursor
crosshairCursor
]
;
case
eCursor_move
:
return
[
NSCursor
cursorWithImageNamed
:
"
move
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_help
:
return
[
NSCursor
cursorWithImageNamed
:
"
help
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_copy
:
return
[
NSCursor
dragCopyCursor
]
;
case
eCursor_alias
:
return
[
NSCursor
dragLinkCursor
]
;
case
eCursor_context_menu
:
return
[
NSCursor
contextualMenuCursor
]
;
case
eCursor_cell
:
return
[
NSCursor
cursorWithImageNamed
:
"
cell
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_grab
:
return
[
NSCursor
openHandCursor
]
;
case
eCursor_grabbing
:
return
[
NSCursor
closedHandCursor
]
;
case
eCursor_zoom_in
:
return
[
NSCursor
cursorWithImageNamed
:
"
zoomIn
"
hotSpot
:
NSMakePoint
(
10
10
)
]
;
case
eCursor_zoom_out
:
return
[
NSCursor
cursorWithImageNamed
:
"
zoomOut
"
hotSpot
:
NSMakePoint
(
10
10
)
]
;
case
eCursor_vertical_text
:
return
[
NSCursor
cursorWithImageNamed
:
"
vtIBeam
"
hotSpot
:
NSMakePoint
(
12
11
)
]
;
case
eCursor_all_scroll
:
return
[
NSCursor
openHandCursor
]
;
case
eCursor_not_allowed
:
case
eCursor_no_drop
:
return
[
NSCursor
operationNotAllowedCursor
]
;
case
eCursor_n_resize
:
return
[
NSCursor
resizeUpCursor
]
;
case
eCursor_ne_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
sizeNE
"
hotSpot
:
NSMakePoint
(
12
11
)
]
;
case
eCursor_e_resize
:
return
[
NSCursor
resizeRightCursor
]
;
case
eCursor_se_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
sizeSE
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_s_resize
:
return
[
NSCursor
resizeDownCursor
]
;
case
eCursor_sw_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
sizeSW
"
hotSpot
:
NSMakePoint
(
10
12
)
]
;
case
eCursor_w_resize
:
return
[
NSCursor
resizeLeftCursor
]
;
case
eCursor_nw_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
sizeNW
"
hotSpot
:
NSMakePoint
(
11
11
)
]
;
case
eCursor_ns_resize
:
return
[
NSCursor
resizeUpDownCursor
]
;
case
eCursor_ew_resize
:
return
[
NSCursor
resizeLeftRightCursor
]
;
case
eCursor_nesw_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
sizeNESW
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_nwse_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
sizeNWSE
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_col_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
colResize
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
case
eCursor_row_resize
:
return
[
NSCursor
cursorWithImageNamed
:
"
rowResize
"
hotSpot
:
NSMakePoint
(
12
12
)
]
;
default
:
return
[
NSCursor
arrowCursor
]
;
}
}
-
(
id
)
init
{
if
(
(
self
=
[
super
init
]
)
)
{
mCursors
=
[
[
NSMutableDictionary
alloc
]
initWithCapacity
:
25
]
;
mCurrentCursor
=
[
NSCursor
arrowCursor
]
;
mCurrentCursorType
=
eCursor_standard
;
}
return
self
;
}
-
(
nsresult
)
setNonCustomCursor
:
(
const
nsIWidget
:
:
Cursor
&
)
aCursor
{
[
self
setMacCursor
:
[
self
getCursor
:
aCursor
.
mDefaultCursor
]
type
:
aCursor
.
mDefaultCursor
]
;
sCurrentCursor
=
aCursor
;
return
NS_OK
;
}
-
(
nsresult
)
setMacCursor
:
(
NSCursor
*
)
aMacCursor
type
:
(
nsCursor
)
aType
{
if
(
mCurrentCursorType
!
=
aType
)
{
if
(
aType
=
=
eCursor_none
)
{
[
NSCursor
hide
]
;
}
else
if
(
mCurrentCursorType
=
=
eCursor_none
)
{
[
NSCursor
unhide
]
;
}
mCurrentCursorType
=
aType
;
}
if
(
mCurrentCursor
!
=
aMacCursor
|
|
[
NSCursor
currentCursor
]
!
=
mCurrentCursor
)
{
[
aMacCursor
retain
]
;
[
aMacCursor
set
]
;
[
mCurrentCursor
release
]
;
mCurrentCursor
=
aMacCursor
;
}
return
NS_OK
;
}
-
(
nsresult
)
setCustomCursor
:
(
const
nsIWidget
:
:
Cursor
&
)
aCursor
widgetScaleFactor
:
(
CGFloat
)
scaleFactor
{
if
(
sCurrentCursor
=
=
aCursor
&
&
sCurrentCursorScaleFactor
=
=
scaleFactor
&
&
mCurrentCursor
)
{
if
(
MOZ_UNLIKELY
(
[
NSCursor
currentCursor
]
!
=
mCurrentCursor
)
)
{
[
mCurrentCursor
set
]
;
}
return
NS_OK
;
}
sCurrentCursor
=
aCursor
;
sCurrentCursorScaleFactor
=
scaleFactor
;
if
(
!
aCursor
.
IsCustom
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIntSize
size
=
nsIWidget
:
:
CustomCursorSize
(
aCursor
)
;
if
(
size
.
width
>
128
|
|
size
.
height
>
128
)
{
return
NS_ERROR_FAILURE
;
}
NSImage
*
cursorImage
;
nsresult
rv
=
nsCocoaUtils
:
:
CreateNSImageFromImageContainer
(
aCursor
.
mContainer
imgIContainer
:
:
FRAME_FIRST
nullptr
nullptr
&
cursorImage
scaleFactor
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
cursorImage
)
{
return
NS_ERROR_FAILURE
;
}
{
NSSize
cocoaSize
=
NSMakeSize
(
size
.
width
size
.
height
)
;
[
cursorImage
setSize
:
cocoaSize
]
;
[
[
[
cursorImage
representations
]
objectAtIndex
:
0
]
setSize
:
cocoaSize
]
;
}
uint32_t
hotspotX
=
aCursor
.
mHotspotX
>
(
uint32_t
(
size
.
width
)
-
1
)
?
0
:
aCursor
.
mHotspotX
;
uint32_t
hotspotY
=
aCursor
.
mHotspotY
>
(
uint32_t
(
size
.
height
)
-
1
)
?
0
:
aCursor
.
mHotspotY
;
NSPoint
hotSpot
=
:
:
NSMakePoint
(
hotspotX
hotspotY
)
;
[
self
setMacCursor
:
[
[
NSCursor
alloc
]
initWithImage
:
cursorImage
hotSpot
:
hotSpot
]
type
:
kCustomCursor
]
;
[
cursorImage
release
]
;
return
NS_OK
;
}
-
(
NSCursor
*
)
getCursor
:
(
enum
nsCursor
)
aCursor
{
NSCursor
*
result
=
[
mCursors
objectForKey
:
[
NSNumber
numberWithInt
:
aCursor
]
]
;
if
(
!
result
)
{
result
=
[
nsCursorManager
createCursor
:
aCursor
]
;
[
mCursors
setObject
:
result
forKey
:
[
NSNumber
numberWithInt
:
aCursor
]
]
;
}
return
result
;
}
-
(
void
)
dealloc
{
[
mCurrentCursor
release
]
;
[
mCursors
release
]
;
sCurrentCursor
=
{
}
;
[
super
dealloc
]
;
}
end
implementation
NSCursor
(
CreateWithImageName
)
+
(
NSCursor
*
)
cursorWithImageNamed
:
(
NSString
*
)
imageName
hotSpot
:
(
NSPoint
)
aPoint
{
nsCOMPtr
<
nsIFile
>
resDir
;
nsAutoCString
resPath
;
NSString
*
pathToImage
*
pathToHiDpiImage
;
NSImage
*
cursorImage
*
hiDpiCursorImage
;
nsresult
rv
=
NS_GetSpecialDirectory
(
NS_GRE_DIR
getter_AddRefs
(
resDir
)
)
;
if
(
NS_FAILED
(
rv
)
)
goto
INIT_FAILURE
;
resDir
-
>
AppendNative
(
"
res
"
_ns
)
;
resDir
-
>
AppendNative
(
"
cursors
"
_ns
)
;
rv
=
resDir
-
>
GetNativePath
(
resPath
)
;
if
(
NS_FAILED
(
rv
)
)
goto
INIT_FAILURE
;
pathToImage
=
[
NSString
stringWithUTF8String
:
(
const
char
*
)
resPath
.
get
(
)
]
;
if
(
!
pathToImage
)
goto
INIT_FAILURE
;
pathToImage
=
[
pathToImage
stringByAppendingPathComponent
:
imageName
]
;
pathToHiDpiImage
=
[
pathToImage
stringByAppendingString
:
"
2x
"
]
;
pathToImage
=
[
pathToImage
stringByAppendingPathExtension
:
"
png
"
]
;
pathToHiDpiImage
=
[
pathToHiDpiImage
stringByAppendingPathExtension
:
"
png
"
]
;
cursorImage
=
[
[
[
NSImage
alloc
]
initWithContentsOfFile
:
pathToImage
]
autorelease
]
;
if
(
!
cursorImage
)
goto
INIT_FAILURE
;
hiDpiCursorImage
=
[
[
[
NSImage
alloc
]
initWithContentsOfFile
:
pathToHiDpiImage
]
autorelease
]
;
if
(
hiDpiCursorImage
)
{
NSImageRep
*
imageRep
=
[
[
hiDpiCursorImage
representations
]
objectAtIndex
:
0
]
;
[
cursorImage
addRepresentation
:
imageRep
]
;
}
return
[
[
[
NSCursor
alloc
]
initWithImage
:
cursorImage
hotSpot
:
aPoint
]
autorelease
]
;
INIT_FAILURE
:
NS_WARNING
(
"
Problem
getting
path
to
cursor
image
file
!
"
)
;
[
self
release
]
;
return
nil
;
}
end
