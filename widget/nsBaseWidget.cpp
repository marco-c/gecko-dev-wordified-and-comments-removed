#
include
"
nsBaseWidget
.
h
"
#
include
<
utility
>
#
include
"
GLConsts
.
h
"
#
include
"
InputData
.
h
"
#
include
"
LiveResizeListener
.
h
"
#
include
"
SwipeTracker
.
h
"
#
include
"
TouchEvents
.
h
"
#
include
"
X11UndefineNone
.
h
"
#
include
"
base
/
thread
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GlobalKeyListener
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
TextEventDispatcher
.
h
"
#
include
"
mozilla
/
TextEventDispatcherListener
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
SimpleGestureEventBinding
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
GPUProcessManager
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
TouchActionHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZEventState
.
h
"
#
include
"
mozilla
/
layers
/
APZInputBridge
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
mozilla
/
layers
/
ChromeProcessController
.
h
"
#
include
"
mozilla
/
layers
/
Compositor
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeParent
.
h
"
#
include
"
mozilla
/
layers
/
CompositorOptions
.
h
"
#
include
"
mozilla
/
layers
/
IAPZCTreeManager
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsGfxCIID
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
prdtoa
.
h
"
#
include
"
prenv
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
gfxConfig
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
layers
/
CompositorSession
.
h
"
#
include
"
VRManagerChild
.
h
"
#
include
"
gfxConfig
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
ifdef
DEBUG
#
include
"
nsIObserver
.
h
"
static
void
debug_RegisterPrefCallbacks
(
)
;
#
endif
#
ifdef
NOISY_WIDGET_LEAKS
static
int32_t
gNumWidgets
;
#
endif
#
ifdef
XP_MACOSX
#
include
"
nsCocoaFeatures
.
h
"
#
endif
nsIRollupListener
*
nsBaseWidget
:
:
gRollupListener
=
nullptr
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
;
#
define
TOUCH_INJECT_PUMP_TIMER_MSEC
50
#
define
TOUCH_INJECT_LONG_TAP_DEFAULT_MSEC
1500
int32_t
nsIWidget
:
:
sPointerIdCounter
=
0
;
uint64_t
AutoObserverNotifier
:
:
sObserverId
=
0
;
nsTHashMap
<
uint64_t
nsCOMPtr
<
nsIObserver
>
>
AutoObserverNotifier
:
:
sSavedObservers
;
const
uint32_t
kAsyncDragDropTimeout
=
1000
;
NS_IMPL_ISUPPORTS
(
nsBaseWidget
nsIWidget
nsISupportsWeakReference
)
nsBaseWidget
:
:
nsBaseWidget
(
)
:
nsBaseWidget
(
eBorderStyle_none
)
{
}
nsBaseWidget
:
:
nsBaseWidget
(
nsBorderStyle
aBorderStyle
)
:
mWidgetListener
(
nullptr
)
mAttachedWidgetListener
(
nullptr
)
mPreviouslyAttachedWidgetListener
(
nullptr
)
mCompositorVsyncDispatcher
(
nullptr
)
mBorderStyle
(
aBorderStyle
)
mBounds
(
0
0
0
0
)
mIsTiled
(
false
)
mPopupLevel
(
ePopupLevelTop
)
mPopupType
(
ePopupTypeAny
)
mHasRemoteContent
(
false
)
mUpdateCursor
(
true
)
mUseAttachedEvents
(
false
)
mIMEHasFocus
(
false
)
mIMEHasQuit
(
false
)
mIsFullyOccluded
(
false
)
mNeedFastSnaphot
(
false
)
mCurrentPanGestureBelongsToSwipe
(
false
)
{
#
ifdef
NOISY_WIDGET_LEAKS
gNumWidgets
+
+
;
printf
(
"
WIDGETS
+
=
%
d
\
n
"
gNumWidgets
)
;
#
endif
#
ifdef
DEBUG
debug_RegisterPrefCallbacks
(
)
;
#
endif
mShutdownObserver
=
new
WidgetShutdownObserver
(
this
)
;
}
NS_IMPL_ISUPPORTS
(
WidgetShutdownObserver
nsIObserver
)
WidgetShutdownObserver
:
:
WidgetShutdownObserver
(
nsBaseWidget
*
aWidget
)
:
mWidget
(
aWidget
)
mRegistered
(
false
)
{
Register
(
)
;
}
WidgetShutdownObserver
:
:
~
WidgetShutdownObserver
(
)
{
}
NS_IMETHODIMP
WidgetShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
mWidget
)
{
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
RefPtr
<
nsBaseWidget
>
widget
(
mWidget
)
;
widget
-
>
Shutdown
(
)
;
}
else
if
(
!
strcmp
(
aTopic
"
quit
-
application
"
)
)
{
RefPtr
<
nsBaseWidget
>
widget
(
mWidget
)
;
widget
-
>
QuitIME
(
)
;
}
return
NS_OK
;
}
void
WidgetShutdownObserver
:
:
Register
(
)
{
if
(
!
mRegistered
)
{
mRegistered
=
true
;
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
#
ifndef
MOZ_WIDGET_ANDROID
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
this
"
quit
-
application
"
false
)
;
}
#
endif
}
}
void
WidgetShutdownObserver
:
:
Unregister
(
)
{
if
(
mRegistered
)
{
mWidget
=
nullptr
;
#
ifndef
MOZ_WIDGET_ANDROID
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
this
"
quit
-
application
"
)
;
}
#
endif
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
mRegistered
=
false
;
}
}
#
define
INTL_APP_LOCALES_CHANGED
"
intl
:
app
-
locales
-
changed
"
NS_IMPL_ISUPPORTS
(
LocalesChangedObserver
nsIObserver
)
LocalesChangedObserver
:
:
LocalesChangedObserver
(
nsBaseWidget
*
aWidget
)
:
mWidget
(
aWidget
)
mRegistered
(
false
)
{
Register
(
)
;
}
LocalesChangedObserver
:
:
~
LocalesChangedObserver
(
)
{
}
NS_IMETHODIMP
LocalesChangedObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
mWidget
)
{
return
NS_OK
;
}
if
(
!
strcmp
(
aTopic
INTL_APP_LOCALES_CHANGED
)
)
{
RefPtr
<
nsBaseWidget
>
widget
(
mWidget
)
;
widget
-
>
LocalesChanged
(
)
;
}
return
NS_OK
;
}
void
LocalesChangedObserver
:
:
Register
(
)
{
if
(
mRegistered
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
INTL_APP_LOCALES_CHANGED
true
)
;
}
RefPtr
<
nsBaseWidget
>
widget
(
mWidget
)
;
widget
-
>
LocalesChanged
(
)
;
mRegistered
=
true
;
}
void
LocalesChangedObserver
:
:
Unregister
(
)
{
if
(
!
mRegistered
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
INTL_APP_LOCALES_CHANGED
)
;
}
mWidget
=
nullptr
;
mRegistered
=
false
;
}
void
nsBaseWidget
:
:
Shutdown
(
)
{
NotifyLiveResizeStopped
(
)
;
RevokeTransactionIdAllocator
(
)
;
DestroyCompositor
(
)
;
FreeLocalesChangedObserver
(
)
;
FreeShutdownObserver
(
)
;
}
void
nsBaseWidget
:
:
QuitIME
(
)
{
IMEStateManager
:
:
WidgetOnQuit
(
this
)
;
this
-
>
mIMEHasQuit
=
true
;
}
void
nsBaseWidget
:
:
DestroyCompositor
(
)
{
if
(
mCompositorVsyncDispatcher
)
{
MOZ_ASSERT
(
mCompositorVsyncDispatcherLock
.
get
(
)
)
;
MutexAutoLock
lock
(
*
mCompositorVsyncDispatcherLock
.
get
(
)
)
;
mCompositorVsyncDispatcher
-
>
Shutdown
(
)
;
mCompositorVsyncDispatcher
=
nullptr
;
}
if
(
mCompositorSession
)
{
ReleaseContentController
(
)
;
mAPZC
=
nullptr
;
SetCompositorWidgetDelegate
(
nullptr
)
;
mCompositorBridgeChild
=
nullptr
;
mCompositorSession
-
>
Shutdown
(
)
;
mCompositorSession
=
nullptr
;
}
}
void
nsBaseWidget
:
:
RevokeTransactionIdAllocator
(
)
{
if
(
!
mWindowRenderer
|
|
!
mWindowRenderer
-
>
AsWebRender
(
)
)
{
return
;
}
mWindowRenderer
-
>
AsWebRender
(
)
-
>
SetTransactionIdAllocator
(
nullptr
)
;
}
void
nsBaseWidget
:
:
ReleaseContentController
(
)
{
if
(
mRootContentController
)
{
mRootContentController
-
>
Destroy
(
)
;
mRootContentController
=
nullptr
;
}
}
void
nsBaseWidget
:
:
DestroyLayerManager
(
)
{
if
(
mWindowRenderer
)
{
mWindowRenderer
-
>
Destroy
(
)
;
mWindowRenderer
=
nullptr
;
}
DestroyCompositor
(
)
;
}
void
nsBaseWidget
:
:
OnRenderingDeviceReset
(
)
{
DestroyLayerManager
(
)
;
}
void
nsBaseWidget
:
:
FreeShutdownObserver
(
)
{
if
(
mShutdownObserver
)
{
mShutdownObserver
-
>
Unregister
(
)
;
}
mShutdownObserver
=
nullptr
;
}
void
nsBaseWidget
:
:
FreeLocalesChangedObserver
(
)
{
if
(
mLocalesChangedObserver
)
{
mLocalesChangedObserver
-
>
Unregister
(
)
;
}
mLocalesChangedObserver
=
nullptr
;
}
nsBaseWidget
:
:
~
nsBaseWidget
(
)
{
if
(
mSwipeTracker
)
{
mSwipeTracker
-
>
Destroy
(
)
;
mSwipeTracker
=
nullptr
;
}
IMEStateManager
:
:
WidgetDestroyed
(
this
)
;
FreeLocalesChangedObserver
(
)
;
FreeShutdownObserver
(
)
;
RevokeTransactionIdAllocator
(
)
;
DestroyLayerManager
(
)
;
#
ifdef
NOISY_WIDGET_LEAKS
gNumWidgets
-
-
;
printf
(
"
WIDGETS
-
=
%
d
\
n
"
gNumWidgets
)
;
#
endif
}
void
nsBaseWidget
:
:
BaseCreate
(
nsIWidget
*
aParent
nsWidgetInitData
*
aInitData
)
{
if
(
aInitData
)
{
mWindowType
=
aInitData
-
>
mWindowType
;
mBorderStyle
=
aInitData
-
>
mBorderStyle
;
mPopupLevel
=
aInitData
-
>
mPopupLevel
;
mPopupType
=
aInitData
-
>
mPopupHint
;
mHasRemoteContent
=
aInitData
-
>
mHasRemoteContent
;
}
if
(
aParent
)
{
aParent
-
>
AddChild
(
this
)
;
}
}
nsIWidgetListener
*
nsBaseWidget
:
:
GetWidgetListener
(
)
const
{
return
mWidgetListener
;
}
void
nsBaseWidget
:
:
SetWidgetListener
(
nsIWidgetListener
*
aWidgetListener
)
{
mWidgetListener
=
aWidgetListener
;
}
already_AddRefed
<
nsIWidget
>
nsBaseWidget
:
:
CreateChild
(
const
LayoutDeviceIntRect
&
aRect
nsWidgetInitData
*
aInitData
bool
aForceUseIWidgetParent
)
{
nsIWidget
*
parent
=
this
;
nsNativeWidget
nativeParent
=
nullptr
;
if
(
!
aForceUseIWidgetParent
)
{
nativeParent
=
parent
?
parent
-
>
GetNativeData
(
NS_NATIVE_WIDGET
)
:
nullptr
;
parent
=
nativeParent
?
nullptr
:
parent
;
MOZ_ASSERT
(
!
parent
|
|
!
nativeParent
"
messed
up
logic
"
)
;
}
nsCOMPtr
<
nsIWidget
>
widget
;
if
(
aInitData
&
&
aInitData
-
>
mWindowType
=
=
eWindowType_popup
)
{
widget
=
AllocateChildPopupWidget
(
)
;
}
else
{
widget
=
nsIWidget
:
:
CreateChildWindow
(
)
;
}
if
(
widget
&
&
mNeedFastSnaphot
)
{
widget
-
>
SetNeedFastSnaphot
(
)
;
}
if
(
widget
&
&
NS_SUCCEEDED
(
widget
-
>
Create
(
parent
nativeParent
aRect
aInitData
)
)
)
{
return
widget
.
forget
(
)
;
}
return
nullptr
;
}
void
nsBaseWidget
:
:
AttachViewToTopLevel
(
bool
aUseAttachedEvents
)
{
NS_ASSERTION
(
(
mWindowType
=
=
eWindowType_toplevel
|
|
mWindowType
=
=
eWindowType_dialog
|
|
mWindowType
=
=
eWindowType_invisible
|
|
mWindowType
=
=
eWindowType_child
)
"
Can
'
t
attach
to
window
of
that
type
"
)
;
mUseAttachedEvents
=
aUseAttachedEvents
;
}
nsIWidgetListener
*
nsBaseWidget
:
:
GetAttachedWidgetListener
(
)
const
{
return
mAttachedWidgetListener
;
}
nsIWidgetListener
*
nsBaseWidget
:
:
GetPreviouslyAttachedWidgetListener
(
)
{
return
mPreviouslyAttachedWidgetListener
;
}
void
nsBaseWidget
:
:
SetPreviouslyAttachedWidgetListener
(
nsIWidgetListener
*
aListener
)
{
mPreviouslyAttachedWidgetListener
=
aListener
;
}
void
nsBaseWidget
:
:
SetAttachedWidgetListener
(
nsIWidgetListener
*
aListener
)
{
mAttachedWidgetListener
=
aListener
;
}
void
nsBaseWidget
:
:
Destroy
(
)
{
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
nsIWidget
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
parent
-
>
RemoveChild
(
this
)
;
}
}
nsIWidget
*
nsBaseWidget
:
:
GetParent
(
void
)
{
return
nullptr
;
}
nsIWidget
*
nsBaseWidget
:
:
GetTopLevelWidget
(
)
{
nsIWidget
*
topLevelWidget
=
nullptr
*
widget
=
this
;
while
(
widget
)
{
topLevelWidget
=
widget
;
widget
=
widget
-
>
GetParent
(
)
;
}
return
topLevelWidget
;
}
nsIWidget
*
nsBaseWidget
:
:
GetSheetWindowParent
(
void
)
{
return
nullptr
;
}
float
nsBaseWidget
:
:
GetDPI
(
)
{
return
96
.
0f
;
}
CSSToLayoutDeviceScale
nsIWidget
:
:
GetDefaultScale
(
)
{
double
devPixelsPerCSSPixel
=
StaticPrefs
:
:
layout_css_devPixelsPerPx
(
)
;
if
(
devPixelsPerCSSPixel
<
=
0
.
0
)
{
devPixelsPerCSSPixel
=
GetDefaultScaleInternal
(
)
;
}
return
CSSToLayoutDeviceScale
(
devPixelsPerCSSPixel
)
;
}
nsIntSize
nsIWidget
:
:
CustomCursorSize
(
const
Cursor
&
aCursor
)
{
MOZ_ASSERT
(
aCursor
.
IsCustom
(
)
)
;
int32_t
width
=
0
;
int32_t
height
=
0
;
aCursor
.
mContainer
-
>
GetWidth
(
&
width
)
;
aCursor
.
mContainer
-
>
GetHeight
(
&
height
)
;
aCursor
.
mResolution
.
ApplyTo
(
width
height
)
;
return
{
width
height
}
;
}
RefPtr
<
mozilla
:
:
VsyncDispatcher
>
nsIWidget
:
:
GetVsyncDispatcher
(
)
{
return
nullptr
;
}
void
nsBaseWidget
:
:
AddChild
(
nsIWidget
*
aChild
)
{
MOZ_ASSERT
(
!
aChild
-
>
GetNextSibling
(
)
&
&
!
aChild
-
>
GetPrevSibling
(
)
"
aChild
not
properly
removed
from
its
old
child
list
"
)
;
if
(
!
mFirstChild
)
{
mFirstChild
=
mLastChild
=
aChild
;
}
else
{
MOZ_ASSERT
(
mLastChild
)
;
MOZ_ASSERT
(
!
mLastChild
-
>
GetNextSibling
(
)
)
;
mLastChild
-
>
SetNextSibling
(
aChild
)
;
aChild
-
>
SetPrevSibling
(
mLastChild
)
;
mLastChild
=
aChild
;
}
}
void
nsBaseWidget
:
:
RemoveChild
(
nsIWidget
*
aChild
)
{
#
ifdef
DEBUG
#
ifdef
XP_MACOSX
nsIWidget
*
parent
=
aChild
-
>
GetParent
(
)
;
NS_ASSERTION
(
!
parent
|
|
parent
=
=
this
"
Not
one
of
our
kids
!
"
)
;
#
else
MOZ_RELEASE_ASSERT
(
aChild
-
>
GetParent
(
)
=
=
this
"
Not
one
of
our
kids
!
"
)
;
#
endif
#
endif
if
(
mLastChild
=
=
aChild
)
{
mLastChild
=
mLastChild
-
>
GetPrevSibling
(
)
;
}
if
(
mFirstChild
=
=
aChild
)
{
mFirstChild
=
mFirstChild
-
>
GetNextSibling
(
)
;
}
nsIWidget
*
prev
=
aChild
-
>
GetPrevSibling
(
)
;
nsIWidget
*
next
=
aChild
-
>
GetNextSibling
(
)
;
if
(
prev
)
{
prev
-
>
SetNextSibling
(
next
)
;
}
if
(
next
)
{
next
-
>
SetPrevSibling
(
prev
)
;
}
aChild
-
>
SetNextSibling
(
nullptr
)
;
aChild
-
>
SetPrevSibling
(
nullptr
)
;
}
void
nsBaseWidget
:
:
SetZIndex
(
int32_t
aZIndex
)
{
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
mZIndex
=
aZIndex
;
auto
*
parent
=
static_cast
<
nsBaseWidget
*
>
(
GetParent
(
)
)
;
if
(
parent
)
{
parent
-
>
RemoveChild
(
this
)
;
nsIWidget
*
sib
=
parent
-
>
GetFirstChild
(
)
;
for
(
;
sib
;
sib
=
sib
-
>
GetNextSibling
(
)
)
{
int32_t
childZIndex
=
GetZIndex
(
)
;
if
(
aZIndex
<
childZIndex
)
{
nsIWidget
*
prev
=
sib
-
>
GetPrevSibling
(
)
;
mNextSibling
=
sib
;
mPrevSibling
=
prev
;
sib
-
>
SetPrevSibling
(
this
)
;
if
(
prev
)
{
prev
-
>
SetNextSibling
(
this
)
;
}
else
{
NS_ASSERTION
(
sib
=
=
parent
-
>
mFirstChild
"
Broken
child
list
"
)
;
parent
-
>
mFirstChild
=
this
;
}
PlaceBehind
(
eZPlacementBelow
sib
false
)
;
break
;
}
}
if
(
!
sib
)
{
parent
-
>
AddChild
(
this
)
;
}
}
}
void
nsBaseWidget
:
:
GetWorkspaceID
(
nsAString
&
workspaceID
)
{
workspaceID
.
Truncate
(
)
;
}
void
nsBaseWidget
:
:
MoveToWorkspace
(
const
nsAString
&
workspaceID
)
{
}
void
nsBaseWidget
:
:
SetCursor
(
const
Cursor
&
aCursor
)
{
mCursor
=
aCursor
;
}
void
nsBaseWidget
:
:
SetTransparencyMode
(
nsTransparencyMode
aMode
)
{
}
nsTransparencyMode
nsBaseWidget
:
:
GetTransparencyMode
(
)
{
return
eTransparencyOpaque
;
}
void
nsBaseWidget
:
:
PerformFullscreenTransition
(
FullscreenTransitionStage
aStage
uint16_t
aDuration
nsISupports
*
aData
nsIRunnable
*
aCallback
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
never
call
PerformFullscreenTransition
on
nsBaseWidget
"
)
;
}
void
nsBaseWidget
:
:
InfallibleMakeFullScreen
(
bool
aFullScreen
)
{
MOZ_DIAGNOSTIC_ASSERT
(
BoundsUseDesktopPixels
(
)
"
non
-
desktop
windows
cannot
be
made
fullscreen
"
)
;
const
auto
doReposition
=
[
&
]
(
auto
rect
)
{
static_assert
(
std
:
:
is_base_of_v
<
DesktopPixel
std
:
:
remove_reference_t
<
decltype
(
rect
)
>
>
"
doReposition
requires
a
rectangle
using
desktop
pixels
"
)
;
Resize
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
true
)
;
}
;
HideWindowChrome
(
aFullScreen
)
;
if
(
aFullScreen
)
{
if
(
!
mSavedBounds
)
{
mSavedBounds
=
mozilla
:
:
MakeUnique
<
FullscreenSavedState
>
(
)
;
}
mSavedBounds
-
>
windowRect
=
GetScreenBounds
(
)
/
GetDesktopToDeviceScale
(
)
;
nsCOMPtr
<
nsIScreen
>
screen
=
GetWidgetScreen
(
)
;
if
(
!
screen
)
{
return
;
}
const
auto
screenRect
=
screen
-
>
GetRectDisplayPix
(
)
;
mSavedBounds
-
>
screenRect
=
screenRect
;
doReposition
(
screenRect
)
;
}
else
{
if
(
!
mSavedBounds
)
{
MOZ_ASSERT
(
false
"
fullscreen
window
did
not
have
saved
position
"
)
;
return
;
}
const
DesktopRect
currentWinRect
=
GetScreenBounds
(
)
/
GetDesktopToDeviceScale
(
)
;
if
(
currentWinRect
=
=
DesktopRect
(
mSavedBounds
-
>
screenRect
)
)
{
doReposition
(
mSavedBounds
-
>
windowRect
)
;
return
;
}
const
auto
splat
=
[
]
(
auto
rect
)
{
return
std
:
:
tuple
(
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
;
}
;
using
Range
=
std
:
:
pair
<
double
double
>
;
const
auto
remap
=
[
]
(
Range
dst
Range
src
double
val
)
{
const
auto
lerp
=
[
]
(
double
lo
double
hi
double
t
)
{
return
lo
+
t
*
(
hi
-
lo
)
;
}
;
const
auto
colerp
=
[
]
(
double
lo
double
hi
double
mid
)
{
return
(
mid
-
lo
)
/
(
hi
-
lo
)
;
}
;
const
auto
[
dst_a
dst_b
]
=
dst
;
const
auto
[
src_a
src_b
]
=
src
;
return
lerp
(
dst_a
dst_b
colerp
(
src_a
src_b
val
)
)
;
}
;
const
auto
[
px
py
pw
ph
]
=
splat
(
mSavedBounds
-
>
windowRect
)
;
const
auto
[
sx
sy
sw
sh
]
=
splat
(
mSavedBounds
-
>
screenRect
)
;
const
auto
[
tx
ty
tw
th
]
=
splat
(
currentWinRect
)
;
const
double
nx
=
remap
(
{
tx
tx
+
tw
}
{
sx
sx
+
sw
}
px
)
;
const
double
ny
=
remap
(
{
ty
ty
+
th
}
{
sy
sy
+
sh
}
py
)
;
const
double
nw
=
remap
(
{
0
tw
}
{
0
sw
}
pw
)
;
const
double
nh
=
remap
(
{
0
th
}
{
0
sh
}
ph
)
;
Resize
(
nx
ny
nw
nh
true
)
;
}
}
nsresult
nsBaseWidget
:
:
MakeFullScreen
(
bool
aFullScreen
)
{
InfallibleMakeFullScreen
(
aFullScreen
)
;
return
NS_OK
;
}
nsBaseWidget
:
:
AutoLayerManagerSetup
:
:
AutoLayerManagerSetup
(
nsBaseWidget
*
aWidget
gfxContext
*
aTarget
BufferMode
aDoubleBuffering
)
:
mWidget
(
aWidget
)
{
WindowRenderer
*
renderer
=
mWidget
-
>
GetWindowRenderer
(
)
;
if
(
renderer
-
>
AsFallback
(
)
)
{
mRenderer
=
renderer
-
>
AsFallback
(
)
;
mRenderer
-
>
SetTarget
(
aTarget
aDoubleBuffering
)
;
}
}
nsBaseWidget
:
:
AutoLayerManagerSetup
:
:
~
AutoLayerManagerSetup
(
)
{
if
(
mRenderer
)
{
mRenderer
-
>
SetTarget
(
nullptr
mozilla
:
:
layers
:
:
BufferMode
:
:
BUFFER_NONE
)
;
}
}
bool
nsBaseWidget
:
:
IsSmallPopup
(
)
const
{
return
mWindowType
=
=
eWindowType_popup
&
&
mPopupType
!
=
ePopupTypePanel
;
}
bool
nsBaseWidget
:
:
ComputeShouldAccelerate
(
)
{
return
gfx
:
:
gfxConfig
:
:
IsEnabled
(
gfx
:
:
Feature
:
:
HW_COMPOSITING
)
&
&
(
WidgetTypeSupportsAcceleration
(
)
|
|
StaticPrefs
:
:
gfx_webrender_unaccelerated_widget_force
(
)
)
;
}
bool
nsBaseWidget
:
:
UseAPZ
(
)
{
return
(
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
&
&
(
WindowType
(
)
=
=
eWindowType_toplevel
|
|
WindowType
(
)
=
=
eWindowType_child
|
|
(
(
WindowType
(
)
=
=
eWindowType_popup
|
|
WindowType
(
)
=
=
eWindowType_dialog
)
&
&
HasRemoteContent
(
)
&
&
StaticPrefs
:
:
apz_popups_enabled
(
)
)
)
)
;
}
void
nsBaseWidget
:
:
CreateCompositor
(
)
{
LayoutDeviceIntRect
rect
=
GetBounds
(
)
;
CreateCompositor
(
rect
.
Width
(
)
rect
.
Height
(
)
)
;
}
already_AddRefed
<
GeckoContentController
>
nsBaseWidget
:
:
CreateRootContentController
(
)
{
RefPtr
<
GeckoContentController
>
controller
=
new
ChromeProcessController
(
this
mAPZEventState
mAPZC
)
;
return
controller
.
forget
(
)
;
}
void
nsBaseWidget
:
:
ConfigureAPZCTreeManager
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mAPZC
)
;
mAPZC
-
>
SetDPI
(
GetDPI
(
)
)
;
if
(
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
)
{
KeyboardMap
map
=
RootWindowGlobalKeyListener
:
:
CollectKeyboardShortcuts
(
)
;
mAPZC
-
>
SetKeyboardMap
(
map
)
;
}
ContentReceivedInputBlockCallback
callback
(
[
treeManager
=
RefPtr
{
mAPZC
.
get
(
)
}
]
(
uint64_t
aInputBlockId
bool
aPreventDefault
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
treeManager
-
>
ContentReceivedInputBlock
(
aInputBlockId
aPreventDefault
)
;
}
)
;
mAPZEventState
=
new
APZEventState
(
this
std
:
:
move
(
callback
)
)
;
mRootContentController
=
CreateRootContentController
(
)
;
if
(
mRootContentController
)
{
mCompositorSession
-
>
SetContentController
(
mRootContentController
)
;
}
if
(
StaticPrefs
:
:
dom_w3c_touch_events_enabled
(
)
)
{
RegisterTouchWindow
(
)
;
}
}
void
nsBaseWidget
:
:
ConfigureAPZControllerThread
(
)
{
APZThreadUtils
:
:
SetControllerThread
(
NS_GetCurrentThread
(
)
)
;
}
void
nsBaseWidget
:
:
SetConfirmedTargetAPZC
(
uint64_t
aInputBlockId
const
nsTArray
<
ScrollableLayerGuid
>
&
aTargets
)
const
{
mAPZC
-
>
SetTargetAPZC
(
aInputBlockId
aTargets
)
;
}
void
nsBaseWidget
:
:
UpdateZoomConstraints
(
const
uint32_t
&
aPresShellId
const
ScrollableLayerGuid
:
:
ViewID
&
aViewId
const
Maybe
<
ZoomConstraints
>
&
aConstraints
)
{
if
(
!
mCompositorSession
|
|
!
mAPZC
)
{
if
(
mInitialZoomConstraints
)
{
MOZ_ASSERT
(
mInitialZoomConstraints
-
>
mPresShellID
=
=
aPresShellId
)
;
MOZ_ASSERT
(
mInitialZoomConstraints
-
>
mViewID
=
=
aViewId
)
;
if
(
!
aConstraints
)
{
mInitialZoomConstraints
.
reset
(
)
;
}
}
if
(
aConstraints
)
{
mInitialZoomConstraints
=
Some
(
InitialZoomConstraints
(
aPresShellId
aViewId
aConstraints
.
ref
(
)
)
)
;
}
return
;
}
LayersId
layersId
=
mCompositorSession
-
>
RootLayerTreeId
(
)
;
mAPZC
-
>
UpdateZoomConstraints
(
ScrollableLayerGuid
(
layersId
aPresShellId
aViewId
)
aConstraints
)
;
}
bool
nsBaseWidget
:
:
AsyncPanZoomEnabled
(
)
const
{
return
!
!
mAPZC
;
}
nsEventStatus
nsBaseWidget
:
:
ProcessUntransformedAPZEvent
(
WidgetInputEvent
*
aEvent
const
APZEventResult
&
aApzResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ScrollableLayerGuid
targetGuid
=
aApzResult
.
mTargetGuid
;
uint64_t
inputBlockId
=
aApzResult
.
mInputBlockId
;
InputAPZContext
context
(
aApzResult
.
mTargetGuid
inputBlockId
aApzResult
.
GetStatus
(
)
)
;
nsEventStatus
status
;
UniquePtr
<
WidgetEvent
>
original
(
aEvent
-
>
Duplicate
(
)
)
;
DispatchEvent
(
aEvent
status
)
;
if
(
mAPZC
&
&
!
InputAPZContext
:
:
WasRoutedToChildProcess
(
)
&
&
inputBlockId
)
{
LayersId
rootLayersId
=
mCompositorSession
-
>
RootLayerTreeId
(
)
;
RefPtr
<
DisplayportSetListener
>
postLayerization
;
if
(
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
)
{
nsTArray
<
TouchBehaviorFlags
>
allowedTouchBehaviors
;
if
(
touchEvent
-
>
mMessage
=
=
eTouchStart
)
{
auto
&
originalEvent
=
*
original
-
>
AsTouchEvent
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
allowedTouchBehaviors
=
TouchActionHelper
:
:
GetAllowedTouchBehavior
(
this
GetDocument
(
)
originalEvent
)
;
if
(
!
allowedTouchBehaviors
.
IsEmpty
(
)
)
{
mAPZC
-
>
SetAllowedTouchBehavior
(
inputBlockId
allowedTouchBehaviors
)
;
}
postLayerization
=
APZCCallbackHelper
:
:
SendSetTargetAPZCNotification
(
this
GetDocument
(
)
originalEvent
rootLayersId
inputBlockId
)
;
}
mAPZEventState
-
>
ProcessTouchEvent
(
*
touchEvent
targetGuid
inputBlockId
aApzResult
.
GetStatus
(
)
status
std
:
:
move
(
allowedTouchBehaviors
)
)
;
}
else
if
(
WidgetWheelEvent
*
wheelEvent
=
aEvent
-
>
AsWheelEvent
(
)
)
{
MOZ_ASSERT
(
wheelEvent
-
>
mFlags
.
mHandledByAPZ
)
;
postLayerization
=
APZCCallbackHelper
:
:
SendSetTargetAPZCNotification
(
this
GetDocument
(
)
*
original
-
>
AsWheelEvent
(
)
rootLayersId
inputBlockId
)
;
if
(
wheelEvent
-
>
mCanTriggerSwipe
)
{
ReportSwipeStarted
(
inputBlockId
wheelEvent
-
>
TriggersSwipe
(
)
)
;
}
mAPZEventState
-
>
ProcessWheelEvent
(
*
wheelEvent
inputBlockId
)
;
}
else
if
(
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
)
{
MOZ_ASSERT
(
mouseEvent
-
>
mFlags
.
mHandledByAPZ
)
;
postLayerization
=
APZCCallbackHelper
:
:
SendSetTargetAPZCNotification
(
this
GetDocument
(
)
*
original
-
>
AsMouseEvent
(
)
rootLayersId
inputBlockId
)
;
mAPZEventState
-
>
ProcessMouseEvent
(
*
mouseEvent
inputBlockId
)
;
}
if
(
postLayerization
)
{
postLayerization
-
>
Register
(
)
;
}
}
return
status
;
}
template
<
class
InputType
class
EventType
>
class
DispatchEventOnMainThread
:
public
Runnable
{
public
:
DispatchEventOnMainThread
(
const
InputType
&
aInput
nsBaseWidget
*
aWidget
const
APZEventResult
&
aAPZResult
)
:
mozilla
:
:
Runnable
(
"
DispatchEventOnMainThread
"
)
mInput
(
aInput
)
mWidget
(
aWidget
)
mAPZResult
(
aAPZResult
)
{
}
NS_IMETHOD
Run
(
)
override
{
EventType
event
=
mInput
.
ToWidgetEvent
(
mWidget
)
;
mWidget
-
>
ProcessUntransformedAPZEvent
(
&
event
mAPZResult
)
;
return
NS_OK
;
}
private
:
InputType
mInput
;
nsBaseWidget
*
mWidget
;
APZEventResult
mAPZResult
;
}
;
template
<
class
InputType
class
EventType
>
class
DispatchInputOnControllerThread
:
public
Runnable
{
public
:
DispatchInputOnControllerThread
(
const
EventType
&
aEvent
IAPZCTreeManager
*
aAPZC
nsBaseWidget
*
aWidget
)
:
mozilla
:
:
Runnable
(
"
DispatchInputOnControllerThread
"
)
mMainMessageLoop
(
MessageLoop
:
:
current
(
)
)
mInput
(
aEvent
)
mAPZC
(
aAPZC
)
mWidget
(
aWidget
)
{
}
NS_IMETHOD
Run
(
)
override
{
APZEventResult
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
mInput
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
NS_OK
;
}
RefPtr
<
Runnable
>
r
=
new
DispatchEventOnMainThread
<
InputType
EventType
>
(
mInput
mWidget
result
)
;
mMainMessageLoop
-
>
PostTask
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
private
:
MessageLoop
*
mMainMessageLoop
;
InputType
mInput
;
RefPtr
<
IAPZCTreeManager
>
mAPZC
;
nsBaseWidget
*
mWidget
;
}
;
void
nsBaseWidget
:
:
DispatchTouchInput
(
MultiTouchInput
&
aInput
uint16_t
aInputSource
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aInputSource
=
=
mozilla
:
:
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
|
|
aInputSource
=
=
mozilla
:
:
dom
:
:
MouseEvent_Binding
:
:
MOZ_SOURCE_PEN
)
;
if
(
mAPZC
)
{
MOZ_ASSERT
(
APZThreadUtils
:
:
IsControllerThread
(
)
)
;
APZEventResult
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aInput
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
WidgetTouchEvent
event
=
aInput
.
ToWidgetEvent
(
this
aInputSource
)
;
ProcessUntransformedAPZEvent
(
&
event
result
)
;
}
else
{
WidgetTouchEvent
event
=
aInput
.
ToWidgetEvent
(
this
aInputSource
)
;
nsEventStatus
status
;
DispatchEvent
(
&
event
status
)
;
}
}
void
nsBaseWidget
:
:
DispatchPanGestureInput
(
PanGestureInput
&
aInput
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mAPZC
)
{
MOZ_ASSERT
(
APZThreadUtils
:
:
IsControllerThread
(
)
)
;
APZEventResult
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aInput
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
WidgetWheelEvent
event
=
aInput
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
event
result
)
;
}
else
{
WidgetWheelEvent
event
=
aInput
.
ToWidgetEvent
(
this
)
;
nsEventStatus
status
;
DispatchEvent
(
&
event
status
)
;
}
}
void
nsBaseWidget
:
:
DispatchPinchGestureInput
(
PinchGestureInput
&
aInput
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mAPZC
)
{
MOZ_ASSERT
(
APZThreadUtils
:
:
IsControllerThread
(
)
)
;
APZEventResult
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
aInput
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
WidgetWheelEvent
event
=
aInput
.
ToWidgetEvent
(
this
)
;
ProcessUntransformedAPZEvent
(
&
event
result
)
;
}
else
{
WidgetWheelEvent
event
=
aInput
.
ToWidgetEvent
(
this
)
;
nsEventStatus
status
;
DispatchEvent
(
&
event
status
)
;
}
}
nsIWidget
:
:
ContentAndAPZEventStatus
nsBaseWidget
:
:
DispatchInputEvent
(
WidgetInputEvent
*
aEvent
)
{
nsIWidget
:
:
ContentAndAPZEventStatus
status
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mAPZC
)
{
if
(
APZThreadUtils
:
:
IsControllerThread
(
)
)
{
APZEventResult
result
=
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
*
aEvent
)
;
status
.
mApzStatus
=
result
.
GetStatus
(
)
;
if
(
result
.
GetStatus
(
)
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
status
;
}
status
.
mContentStatus
=
ProcessUntransformedAPZEvent
(
aEvent
result
)
;
return
status
;
}
if
(
WidgetWheelEvent
*
wheelEvent
=
aEvent
-
>
AsWheelEvent
(
)
)
{
RefPtr
<
Runnable
>
r
=
new
DispatchInputOnControllerThread
<
ScrollWheelInput
WidgetWheelEvent
>
(
*
wheelEvent
mAPZC
this
)
;
APZThreadUtils
:
:
RunOnControllerThread
(
std
:
:
move
(
r
)
)
;
status
.
mContentStatus
=
nsEventStatus_eConsumeDoDefault
;
return
status
;
}
if
(
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
)
{
RefPtr
<
Runnable
>
r
=
new
DispatchInputOnControllerThread
<
MouseInput
WidgetMouseEvent
>
(
*
mouseEvent
mAPZC
this
)
;
APZThreadUtils
:
:
RunOnControllerThread
(
std
:
:
move
(
r
)
)
;
status
.
mContentStatus
=
nsEventStatus_eConsumeDoDefault
;
return
status
;
}
if
(
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
)
{
RefPtr
<
Runnable
>
r
=
new
DispatchInputOnControllerThread
<
MultiTouchInput
WidgetTouchEvent
>
(
*
touchEvent
mAPZC
this
)
;
APZThreadUtils
:
:
RunOnControllerThread
(
std
:
:
move
(
r
)
)
;
status
.
mContentStatus
=
nsEventStatus_eConsumeDoDefault
;
return
status
;
}
MOZ_ASSERT
(
aEvent
-
>
AsKeyboardEvent
(
)
)
;
}
DispatchEvent
(
aEvent
status
.
mContentStatus
)
;
return
status
;
}
void
nsBaseWidget
:
:
DispatchEventToAPZOnly
(
mozilla
:
:
WidgetInputEvent
*
aEvent
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mAPZC
)
{
MOZ_ASSERT
(
APZThreadUtils
:
:
IsControllerThread
(
)
)
;
mAPZC
-
>
InputBridge
(
)
-
>
ReceiveInputEvent
(
*
aEvent
)
;
}
}
bool
nsBaseWidget
:
:
DispatchWindowEvent
(
WidgetGUIEvent
&
event
)
{
nsEventStatus
status
;
DispatchEvent
(
&
event
status
)
;
return
ConvertStatus
(
status
)
;
}
Document
*
nsBaseWidget
:
:
GetDocument
(
)
const
{
if
(
mWidgetListener
)
{
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
return
presShell
-
>
GetDocument
(
)
;
}
}
return
nullptr
;
}
void
nsBaseWidget
:
:
CreateCompositorVsyncDispatcher
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
if
(
!
mCompositorVsyncDispatcherLock
)
{
mCompositorVsyncDispatcherLock
=
MakeUnique
<
Mutex
>
(
"
mCompositorVsyncDispatcherLock
"
)
;
}
MutexAutoLock
lock
(
*
mCompositorVsyncDispatcherLock
.
get
(
)
)
;
if
(
!
mCompositorVsyncDispatcher
)
{
RefPtr
<
VsyncDispatcher
>
vsyncDispatcher
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetGlobalVsyncDispatcher
(
)
;
mCompositorVsyncDispatcher
=
new
CompositorVsyncDispatcher
(
std
:
:
move
(
vsyncDispatcher
)
)
;
}
}
}
already_AddRefed
<
CompositorVsyncDispatcher
>
nsBaseWidget
:
:
GetCompositorVsyncDispatcher
(
)
{
MOZ_ASSERT
(
mCompositorVsyncDispatcherLock
.
get
(
)
)
;
MutexAutoLock
lock
(
*
mCompositorVsyncDispatcherLock
.
get
(
)
)
;
RefPtr
<
CompositorVsyncDispatcher
>
dispatcher
=
mCompositorVsyncDispatcher
;
return
dispatcher
.
forget
(
)
;
}
already_AddRefed
<
WebRenderLayerManager
>
nsBaseWidget
:
:
CreateCompositorSession
(
int
aWidth
int
aHeight
CompositorOptions
*
aOptionsOut
)
{
MOZ_ASSERT
(
aOptionsOut
)
;
do
{
CreateCompositorVsyncDispatcher
(
)
;
gfx
:
:
GPUProcessManager
*
gpu
=
gfx
:
:
GPUProcessManager
:
:
Get
(
)
;
gpu
-
>
EnsureGPUReady
(
)
;
bool
supportsAcceleration
=
WidgetTypeSupportsAcceleration
(
)
;
bool
enableWR
;
bool
enableSWWR
;
if
(
supportsAcceleration
|
|
StaticPrefs
:
:
gfx_webrender_unaccelerated_widget_force
(
)
)
{
enableWR
=
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
;
enableSWWR
=
gfx
:
:
gfxVars
:
:
UseSoftwareWebRender
(
)
;
}
else
{
enableWR
=
enableSWWR
=
gfx
:
:
gfxVars
:
:
UseWebRender
(
)
;
}
MOZ_RELEASE_ASSERT
(
enableWR
)
;
bool
enableAPZ
=
UseAPZ
(
)
;
CompositorOptions
options
(
enableAPZ
enableSWWR
)
;
#
ifdef
XP_WIN
if
(
supportsAcceleration
)
{
options
.
SetAllowSoftwareWebRenderD3D11
(
gfx
:
:
gfxVars
:
:
AllowSoftwareWebRenderD3D11
(
)
)
;
}
if
(
mNeedFastSnaphot
)
{
options
.
SetNeedFastSnaphot
(
true
)
;
}
#
elif
defined
(
MOZ_WIDGET_ANDROID
)
MOZ_ASSERT
(
supportsAcceleration
)
;
options
.
SetAllowSoftwareWebRenderOGL
(
StaticPrefs
:
:
gfx_webrender_software_opengl_AtStartup
(
)
)
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
if
(
supportsAcceleration
)
{
options
.
SetAllowSoftwareWebRenderOGL
(
StaticPrefs
:
:
gfx_webrender_software_opengl_AtStartup
(
)
)
;
}
#
endif
#
ifdef
MOZ_WIDGET_ANDROID
options
.
SetInitiallyPaused
(
true
)
;
#
else
options
.
SetInitiallyPaused
(
CompositorInitiallyPaused
(
)
)
;
#
endif
RefPtr
<
WebRenderLayerManager
>
lm
=
new
WebRenderLayerManager
(
this
)
;
uint64_t
innerWindowId
=
0
;
if
(
Document
*
doc
=
GetDocument
(
)
)
{
innerWindowId
=
doc
-
>
InnerWindowID
(
)
;
}
bool
retry
=
false
;
mCompositorSession
=
gpu
-
>
CreateTopLevelCompositor
(
this
lm
GetDefaultScale
(
)
options
UseExternalCompositingSurface
(
)
gfx
:
:
IntSize
(
aWidth
aHeight
)
innerWindowId
&
retry
)
;
if
(
mCompositorSession
)
{
TextureFactoryIdentifier
textureFactoryIdentifier
;
nsCString
error
;
lm
-
>
Initialize
(
mCompositorSession
-
>
GetCompositorBridgeChild
(
)
wr
:
:
AsPipelineId
(
mCompositorSession
-
>
RootLayerTreeId
(
)
)
&
textureFactoryIdentifier
error
)
;
if
(
textureFactoryIdentifier
.
mParentBackend
!
=
LayersBackend
:
:
LAYERS_WR
)
{
retry
=
true
;
DestroyCompositor
(
)
;
gfx
:
:
GPUProcessManager
:
:
Get
(
)
-
>
DisableWebRender
(
wr
:
:
WebRenderError
:
:
INITIALIZE
error
)
;
}
}
if
(
mCompositorSession
|
|
!
retry
)
{
*
aOptionsOut
=
options
;
return
lm
.
forget
(
)
;
}
}
while
(
true
)
;
}
void
nsBaseWidget
:
:
CreateCompositor
(
int
aWidth
int
aHeight
)
{
gfxPlatform
:
:
GetPlatform
(
)
;
MOZ_ASSERT
(
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
"
This
function
assumes
OMTC
"
)
;
MOZ_ASSERT
(
!
mCompositorSession
&
&
!
mCompositorBridgeChild
"
Should
have
properly
cleaned
up
the
previous
PCompositor
pair
"
"
beforehand
"
)
;
if
(
mCompositorBridgeChild
)
{
mCompositorBridgeChild
-
>
Destroy
(
)
;
}
if
(
!
mShutdownObserver
)
{
return
;
}
ConfigureAPZControllerThread
(
)
;
CompositorOptions
options
;
RefPtr
<
WebRenderLayerManager
>
lm
=
CreateCompositorSession
(
aWidth
aHeight
&
options
)
;
if
(
!
lm
)
{
return
;
}
MOZ_ASSERT
(
mCompositorSession
)
;
mCompositorBridgeChild
=
mCompositorSession
-
>
GetCompositorBridgeChild
(
)
;
SetCompositorWidgetDelegate
(
mCompositorSession
-
>
GetCompositorWidgetDelegate
(
)
)
;
if
(
options
.
UseAPZ
(
)
)
{
mAPZC
=
mCompositorSession
-
>
GetAPZCTreeManager
(
)
;
ConfigureAPZCTreeManager
(
)
;
}
else
{
mAPZC
=
nullptr
;
}
if
(
mInitialZoomConstraints
)
{
UpdateZoomConstraints
(
mInitialZoomConstraints
-
>
mPresShellID
mInitialZoomConstraints
-
>
mViewID
Some
(
mInitialZoomConstraints
-
>
mConstraints
)
)
;
mInitialZoomConstraints
.
reset
(
)
;
}
TextureFactoryIdentifier
textureFactoryIdentifier
=
lm
-
>
GetTextureFactoryIdentifier
(
)
;
MOZ_ASSERT
(
textureFactoryIdentifier
.
mParentBackend
=
=
LayersBackend
:
:
LAYERS_WR
)
;
ImageBridgeChild
:
:
IdentifyCompositorTextureHost
(
textureFactoryIdentifier
)
;
gfx
:
:
VRManagerChild
:
:
IdentifyTextureHost
(
textureFactoryIdentifier
)
;
WindowUsesOMTC
(
)
;
mWindowRenderer
=
std
:
:
move
(
lm
)
;
#
if
defined
(
XP_MACOSX
)
bool
getCompositorFromThisWindow
=
true
;
#
else
bool
getCompositorFromThisWindow
=
(
mWindowType
=
=
eWindowType_toplevel
)
;
#
endif
if
(
getCompositorFromThisWindow
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
NotifyCompositorCreated
(
mWindowRenderer
-
>
GetCompositorBackendType
(
)
)
;
}
}
void
nsBaseWidget
:
:
NotifyCompositorSessionLost
(
CompositorSession
*
aSession
)
{
MOZ_ASSERT
(
aSession
=
=
mCompositorSession
)
;
DestroyLayerManager
(
)
;
}
bool
nsBaseWidget
:
:
ShouldUseOffMainThreadCompositing
(
)
{
return
gfxPlatform
:
:
UsesOffMainThreadCompositing
(
)
;
}
WindowRenderer
*
nsBaseWidget
:
:
GetWindowRenderer
(
)
{
if
(
!
mWindowRenderer
)
{
if
(
!
mShutdownObserver
)
{
return
nullptr
;
}
if
(
ShouldUseOffMainThreadCompositing
(
)
)
{
CreateCompositor
(
)
;
}
if
(
!
mWindowRenderer
)
{
mWindowRenderer
=
CreateFallbackRenderer
(
)
;
}
}
return
mWindowRenderer
;
}
WindowRenderer
*
nsBaseWidget
:
:
CreateFallbackRenderer
(
)
{
return
new
FallbackRenderer
;
}
CompositorBridgeChild
*
nsBaseWidget
:
:
GetRemoteRenderer
(
)
{
return
mCompositorBridgeChild
;
}
void
nsBaseWidget
:
:
ClearCachedWebrenderResources
(
)
{
if
(
!
mWindowRenderer
|
|
!
mWindowRenderer
-
>
AsWebRender
(
)
)
{
return
;
}
mWindowRenderer
-
>
AsWebRender
(
)
-
>
ClearCachedResources
(
)
;
}
void
nsBaseWidget
:
:
ClearWebrenderAnimationResources
(
)
{
if
(
!
mWindowRenderer
|
|
!
mWindowRenderer
-
>
AsWebRender
(
)
)
{
return
;
}
mWindowRenderer
-
>
AsWebRender
(
)
-
>
ClearAnimationResources
(
)
;
}
bool
nsBaseWidget
:
:
SetNeedFastSnaphot
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
mCompositorSession
)
;
if
(
!
XRE_IsParentProcess
(
)
|
|
mCompositorSession
)
{
return
false
;
}
mNeedFastSnaphot
=
true
;
return
true
;
}
already_AddRefed
<
gfx
:
:
DrawTarget
>
nsBaseWidget
:
:
StartRemoteDrawing
(
)
{
return
nullptr
;
}
uint32_t
nsBaseWidget
:
:
GetGLFrameBufferFormat
(
)
{
return
LOCAL_GL_RGBA
;
}
void
nsBaseWidget
:
:
OnDestroy
(
)
{
if
(
mTextEventDispatcher
)
{
mTextEventDispatcher
-
>
OnDestroyWidget
(
)
;
}
ReleaseContentController
(
)
;
}
void
nsBaseWidget
:
:
MoveClient
(
const
DesktopPoint
&
aOffset
)
{
LayoutDeviceIntPoint
clientOffset
(
GetClientOffset
(
)
)
;
if
(
BoundsUseDesktopPixels
(
)
)
{
DesktopPoint
desktopOffset
=
clientOffset
/
GetDesktopToDeviceScale
(
)
;
Move
(
aOffset
.
x
-
desktopOffset
.
x
aOffset
.
y
-
desktopOffset
.
y
)
;
}
else
{
LayoutDevicePoint
layoutOffset
=
aOffset
*
GetDesktopToDeviceScale
(
)
;
Move
(
layoutOffset
.
x
-
clientOffset
.
x
layoutOffset
.
y
-
clientOffset
.
y
)
;
}
}
void
nsBaseWidget
:
:
ResizeClient
(
const
DesktopSize
&
aSize
bool
aRepaint
)
{
NS_ASSERTION
(
(
aSize
.
width
>
=
0
)
"
Negative
width
passed
to
ResizeClient
"
)
;
NS_ASSERTION
(
(
aSize
.
height
>
=
0
)
"
Negative
height
passed
to
ResizeClient
"
)
;
LayoutDeviceIntRect
clientBounds
=
GetClientBounds
(
)
;
if
(
BoundsUseDesktopPixels
(
)
)
{
DesktopSize
desktopDelta
=
(
LayoutDeviceIntSize
(
mBounds
.
Width
(
)
mBounds
.
Height
(
)
)
-
clientBounds
.
Size
(
)
)
/
GetDesktopToDeviceScale
(
)
;
Resize
(
aSize
.
width
+
desktopDelta
.
width
aSize
.
height
+
desktopDelta
.
height
aRepaint
)
;
}
else
{
LayoutDeviceSize
layoutSize
=
aSize
*
GetDesktopToDeviceScale
(
)
;
Resize
(
mBounds
.
Width
(
)
+
(
layoutSize
.
width
-
clientBounds
.
Width
(
)
)
mBounds
.
Height
(
)
+
(
layoutSize
.
height
-
clientBounds
.
Height
(
)
)
aRepaint
)
;
}
}
void
nsBaseWidget
:
:
ResizeClient
(
const
DesktopRect
&
aRect
bool
aRepaint
)
{
NS_ASSERTION
(
(
aRect
.
Width
(
)
>
=
0
)
"
Negative
width
passed
to
ResizeClient
"
)
;
NS_ASSERTION
(
(
aRect
.
Height
(
)
>
=
0
)
"
Negative
height
passed
to
ResizeClient
"
)
;
LayoutDeviceIntRect
clientBounds
=
GetClientBounds
(
)
;
LayoutDeviceIntPoint
clientOffset
=
GetClientOffset
(
)
;
DesktopToLayoutDeviceScale
scale
=
GetDesktopToDeviceScale
(
)
;
if
(
BoundsUseDesktopPixels
(
)
)
{
DesktopPoint
desktopOffset
=
clientOffset
/
scale
;
DesktopSize
desktopDelta
=
(
LayoutDeviceIntSize
(
mBounds
.
Width
(
)
mBounds
.
Height
(
)
)
-
clientBounds
.
Size
(
)
)
/
scale
;
Resize
(
aRect
.
X
(
)
-
desktopOffset
.
x
aRect
.
Y
(
)
-
desktopOffset
.
y
aRect
.
Width
(
)
+
desktopDelta
.
width
aRect
.
Height
(
)
+
desktopDelta
.
height
aRepaint
)
;
}
else
{
LayoutDeviceRect
layoutRect
=
aRect
*
scale
;
Resize
(
layoutRect
.
X
(
)
-
clientOffset
.
x
layoutRect
.
Y
(
)
-
clientOffset
.
y
layoutRect
.
Width
(
)
+
mBounds
.
Width
(
)
-
clientBounds
.
Width
(
)
layoutRect
.
Height
(
)
+
mBounds
.
Height
(
)
-
clientBounds
.
Height
(
)
aRepaint
)
;
}
}
LayoutDeviceIntRect
nsBaseWidget
:
:
GetClientBounds
(
)
{
return
GetBounds
(
)
;
}
LayoutDeviceIntRect
nsBaseWidget
:
:
GetBounds
(
)
{
return
mBounds
;
}
LayoutDeviceIntRect
nsBaseWidget
:
:
GetScreenBounds
(
)
{
return
GetBounds
(
)
;
}
nsresult
nsBaseWidget
:
:
GetRestoredBounds
(
LayoutDeviceIntRect
&
aRect
)
{
if
(
SizeMode
(
)
!
=
nsSizeMode_Normal
)
{
return
NS_ERROR_FAILURE
;
}
aRect
=
GetScreenBounds
(
)
;
return
NS_OK
;
}
LayoutDeviceIntPoint
nsBaseWidget
:
:
GetClientOffset
(
)
{
return
LayoutDeviceIntPoint
(
0
0
)
;
}
nsresult
nsBaseWidget
:
:
SetNonClientMargins
(
LayoutDeviceIntMargin
&
margins
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
nsBaseWidget
:
:
SetResizeMargin
(
LayoutDeviceIntCoord
aResizeMargin
)
{
}
uint32_t
nsBaseWidget
:
:
GetMaxTouchPoints
(
)
const
{
return
0
;
}
bool
nsBaseWidget
:
:
HasPendingInputEvent
(
)
{
return
false
;
}
bool
nsBaseWidget
:
:
ShowsResizeIndicator
(
LayoutDeviceIntRect
*
aResizerRect
)
{
return
false
;
}
static
bool
ResolveIconNameHelper
(
nsIFile
*
aFile
const
nsAString
&
aIconName
const
nsAString
&
aIconSuffix
)
{
aFile
-
>
Append
(
u
"
icons
"
_ns
)
;
aFile
-
>
Append
(
u
"
default
"
_ns
)
;
aFile
-
>
Append
(
aIconName
+
aIconSuffix
)
;
bool
readable
;
return
NS_SUCCEEDED
(
aFile
-
>
IsReadable
(
&
readable
)
)
&
&
readable
;
}
void
nsBaseWidget
:
:
ResolveIconName
(
const
nsAString
&
aIconName
const
nsAString
&
aIconSuffix
nsIFile
*
*
aResult
)
{
*
aResult
=
nullptr
;
nsCOMPtr
<
nsIProperties
>
dirSvc
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
;
if
(
!
dirSvc
)
return
;
nsCOMPtr
<
nsISimpleEnumerator
>
dirs
;
dirSvc
-
>
Get
(
NS_APP_CHROME_DIR_LIST
NS_GET_IID
(
nsISimpleEnumerator
)
getter_AddRefs
(
dirs
)
)
;
if
(
dirs
)
{
bool
hasMore
;
while
(
NS_SUCCEEDED
(
dirs
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
element
;
dirs
-
>
GetNext
(
getter_AddRefs
(
element
)
)
;
if
(
!
element
)
continue
;
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
element
)
;
if
(
!
file
)
continue
;
if
(
ResolveIconNameHelper
(
file
aIconName
aIconSuffix
)
)
{
NS_ADDREF
(
*
aResult
=
file
)
;
return
;
}
}
}
nsCOMPtr
<
nsIFile
>
file
;
dirSvc
-
>
Get
(
NS_APP_CHROME_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
file
)
)
;
if
(
file
&
&
ResolveIconNameHelper
(
file
aIconName
aIconSuffix
)
)
NS_ADDREF
(
*
aResult
=
file
)
;
}
void
nsBaseWidget
:
:
SetSizeConstraints
(
const
SizeConstraints
&
aConstraints
)
{
mSizeConstraints
=
aConstraints
;
if
(
mWindowType
=
=
eWindowType_popup
)
{
return
;
}
LayoutDeviceIntSize
curSize
=
mBounds
.
Size
(
)
;
LayoutDeviceIntSize
clampedSize
=
Max
(
aConstraints
.
mMinSize
Min
(
aConstraints
.
mMaxSize
curSize
)
)
;
if
(
clampedSize
!
=
curSize
)
{
gfx
:
:
Size
size
;
if
(
BoundsUseDesktopPixels
(
)
)
{
DesktopSize
desktopSize
=
clampedSize
/
GetDesktopToDeviceScale
(
)
;
size
=
desktopSize
.
ToUnknownSize
(
)
;
}
else
{
size
=
gfx
:
:
Size
(
clampedSize
.
ToUnknownSize
(
)
)
;
}
Resize
(
size
.
width
size
.
height
true
)
;
}
}
const
widget
:
:
SizeConstraints
nsBaseWidget
:
:
GetSizeConstraints
(
)
{
return
mSizeConstraints
;
}
nsIRollupListener
*
nsBaseWidget
:
:
GetActiveRollupListener
(
)
{
if
(
gRollupListener
)
return
gRollupListener
;
return
nsXULPopupManager
:
:
GetInstance
(
)
;
}
void
nsBaseWidget
:
:
NotifyWindowDestroyed
(
)
{
if
(
!
mWidgetListener
)
return
;
nsCOMPtr
<
nsIAppWindow
>
window
=
mWidgetListener
-
>
GetAppWindow
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
appWindow
(
do_QueryInterface
(
window
)
)
;
if
(
appWindow
)
{
appWindow
-
>
Destroy
(
)
;
}
}
void
nsBaseWidget
:
:
NotifyWindowMoved
(
int32_t
aX
int32_t
aY
)
{
if
(
mWidgetListener
)
{
mWidgetListener
-
>
WindowMoved
(
this
aX
aY
)
;
}
if
(
mIMEHasFocus
&
&
IMENotificationRequestsRef
(
)
.
WantPositionChanged
(
)
)
{
NotifyIME
(
IMENotification
(
IMEMessage
:
:
NOTIFY_IME_OF_POSITION_CHANGE
)
)
;
}
}
void
nsBaseWidget
:
:
NotifySizeMoveDone
(
)
{
if
(
!
mWidgetListener
)
{
return
;
}
if
(
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
)
{
presShell
-
>
WindowSizeMoveDone
(
)
;
}
}
void
nsBaseWidget
:
:
NotifyThemeChanged
(
ThemeChangeKind
aKind
)
{
LookAndFeel
:
:
NotifyChangedAllWindows
(
aKind
)
;
}
void
nsBaseWidget
:
:
NotifyUIStateChanged
(
UIStateChangeType
aShowFocusRings
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
if
(
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
)
{
win
-
>
SetKeyboardIndicators
(
aShowFocusRings
)
;
}
}
}
nsresult
nsBaseWidget
:
:
NotifyIME
(
const
IMENotification
&
aIMENotification
)
{
if
(
mIMEHasQuit
)
{
return
NS_OK
;
}
switch
(
aIMENotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
case
REQUEST_TO_CANCEL_COMPOSITION
:
if
(
mTextEventDispatcher
&
&
mTextEventDispatcher
-
>
IsComposing
(
)
)
{
return
mTextEventDispatcher
-
>
NotifyIME
(
aIMENotification
)
;
}
return
NS_OK
;
default
:
{
if
(
aIMENotification
.
mMessage
=
=
NOTIFY_IME_OF_FOCUS
)
{
mIMEHasFocus
=
true
;
}
EnsureTextEventDispatcher
(
)
;
nsresult
rv
=
mTextEventDispatcher
-
>
NotifyIME
(
aIMENotification
)
;
if
(
aIMENotification
.
mMessage
=
=
NOTIFY_IME_OF_BLUR
)
{
mIMEHasFocus
=
false
;
}
return
rv
;
}
}
}
void
nsBaseWidget
:
:
EnsureTextEventDispatcher
(
)
{
if
(
mTextEventDispatcher
)
{
return
;
}
mTextEventDispatcher
=
new
TextEventDispatcher
(
this
)
;
}
nsIWidget
:
:
NativeIMEContext
nsBaseWidget
:
:
GetNativeIMEContext
(
)
{
if
(
mTextEventDispatcher
&
&
mTextEventDispatcher
-
>
GetPseudoIMEContext
(
)
)
{
NativeIMEContext
pseudoIMEContext
;
pseudoIMEContext
.
InitWithRawNativeIMEContext
(
mTextEventDispatcher
-
>
GetPseudoIMEContext
(
)
)
;
return
pseudoIMEContext
;
}
return
NativeIMEContext
(
this
)
;
}
nsIWidget
:
:
TextEventDispatcher
*
nsBaseWidget
:
:
GetTextEventDispatcher
(
)
{
EnsureTextEventDispatcher
(
)
;
return
mTextEventDispatcher
;
}
void
*
nsBaseWidget
:
:
GetPseudoIMEContext
(
)
{
TextEventDispatcher
*
dispatcher
=
GetTextEventDispatcher
(
)
;
if
(
!
dispatcher
)
{
return
nullptr
;
}
return
dispatcher
-
>
GetPseudoIMEContext
(
)
;
}
TextEventDispatcherListener
*
nsBaseWidget
:
:
GetNativeTextEventDispatcherListener
(
)
{
return
nullptr
;
}
void
nsBaseWidget
:
:
ZoomToRect
(
const
uint32_t
&
aPresShellId
const
ScrollableLayerGuid
:
:
ViewID
&
aViewId
const
CSSRect
&
aRect
const
uint32_t
&
aFlags
)
{
if
(
!
mCompositorSession
|
|
!
mAPZC
)
{
return
;
}
LayersId
layerId
=
mCompositorSession
-
>
RootLayerTreeId
(
)
;
mAPZC
-
>
ZoomToRect
(
ScrollableLayerGuid
(
layerId
aPresShellId
aViewId
)
ZoomTarget
{
aRect
}
aFlags
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
LocalAccessible
*
nsBaseWidget
:
:
GetRootAccessible
(
)
{
NS_ENSURE_TRUE
(
mWidgetListener
nullptr
)
;
PresShell
*
presShell
=
mWidgetListener
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
nullptr
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
-
>
GetContainerWeak
(
)
nullptr
)
;
nsAccessibilityService
*
accService
=
GetOrCreateAccService
(
)
;
if
(
accService
)
{
return
accService
-
>
GetRootDocumentAccessible
(
presShell
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
}
return
nullptr
;
}
#
endif
void
nsBaseWidget
:
:
StartAsyncScrollbarDrag
(
const
AsyncDragMetrics
&
aDragMetrics
)
{
if
(
!
AsyncPanZoomEnabled
(
)
)
{
return
;
}
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
&
&
mCompositorSession
)
;
LayersId
layersId
=
mCompositorSession
-
>
RootLayerTreeId
(
)
;
ScrollableLayerGuid
guid
(
layersId
aDragMetrics
.
mPresShellId
aDragMetrics
.
mViewId
)
;
mAPZC
-
>
StartScrollbarDrag
(
guid
aDragMetrics
)
;
}
bool
nsBaseWidget
:
:
StartAsyncAutoscroll
(
const
ScreenPoint
&
aAnchorLocation
const
ScrollableLayerGuid
&
aGuid
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
&
&
AsyncPanZoomEnabled
(
)
)
;
return
mAPZC
-
>
StartAutoscroll
(
aGuid
aAnchorLocation
)
;
}
void
nsBaseWidget
:
:
StopAsyncAutoscroll
(
const
ScrollableLayerGuid
&
aGuid
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
&
&
AsyncPanZoomEnabled
(
)
)
;
mAPZC
-
>
StopAutoscroll
(
aGuid
)
;
}
LayersId
nsBaseWidget
:
:
GetRootLayerTreeId
(
)
{
return
mCompositorSession
?
mCompositorSession
-
>
RootLayerTreeId
(
)
:
LayersId
{
0
}
;
}
already_AddRefed
<
nsIScreen
>
nsBaseWidget
:
:
GetWidgetScreen
(
)
{
nsCOMPtr
<
nsIScreenManager
>
screenManager
;
screenManager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
!
screenManager
)
{
return
nullptr
;
}
LayoutDeviceIntRect
bounds
=
GetScreenBounds
(
)
;
DesktopIntRect
deskBounds
=
RoundedToInt
(
bounds
/
GetDesktopToDeviceScale
(
)
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
screenManager
-
>
ScreenForRect
(
deskBounds
.
X
(
)
deskBounds
.
Y
(
)
deskBounds
.
Width
(
)
deskBounds
.
Height
(
)
getter_AddRefs
(
screen
)
)
;
return
screen
.
forget
(
)
;
}
mozilla
:
:
DesktopToLayoutDeviceScale
nsBaseWidget
:
:
GetDesktopToDeviceScaleByScreen
(
)
{
return
(
nsView
:
:
GetViewFor
(
this
)
-
>
GetViewManager
(
)
-
>
GetDeviceContext
(
)
)
-
>
GetDesktopToDeviceScale
(
)
;
}
nsresult
nsIWidget
:
:
SynthesizeNativeTouchTap
(
LayoutDeviceIntPoint
aPoint
bool
aLongTap
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
touchtap
"
)
;
if
(
sPointerIdCounter
>
TOUCH_INJECT_MAX_POINTS
)
{
sPointerIdCounter
=
0
;
}
int
pointerId
=
sPointerIdCounter
;
sPointerIdCounter
+
+
;
nsresult
rv
=
SynthesizeNativeTouchPoint
(
pointerId
TOUCH_CONTACT
aPoint
1
.
0
90
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aLongTap
)
{
return
SynthesizeNativeTouchPoint
(
pointerId
TOUCH_REMOVE
aPoint
0
0
nullptr
)
;
}
int
elapse
=
Preferences
:
:
GetInt
(
"
ui
.
click_hold_context_menus
.
delay
"
TOUCH_INJECT_LONG_TAP_DEFAULT_MSEC
)
;
if
(
!
mLongTapTimer
)
{
mLongTapTimer
=
NS_NewTimer
(
)
;
if
(
!
mLongTapTimer
)
{
SynthesizeNativeTouchPoint
(
pointerId
TOUCH_CANCEL
aPoint
0
0
nullptr
)
;
return
NS_ERROR_UNEXPECTED
;
}
int
timeout
=
elapse
;
if
(
timeout
>
TOUCH_INJECT_PUMP_TIMER_MSEC
)
{
timeout
=
TOUCH_INJECT_PUMP_TIMER_MSEC
;
}
mLongTapTimer
-
>
InitWithNamedFuncCallback
(
OnLongTapTimerCallback
this
timeout
nsITimer
:
:
TYPE_REPEATING_SLACK
"
nsIWidget
:
:
SynthesizeNativeTouchTap
"
)
;
}
if
(
mLongTapTouchPoint
)
{
SynthesizeNativeTouchPoint
(
mLongTapTouchPoint
-
>
mPointerId
TOUCH_CANCEL
mLongTapTouchPoint
-
>
mPosition
0
0
nullptr
)
;
}
mLongTapTouchPoint
=
MakeUnique
<
LongTapInfo
>
(
pointerId
aPoint
TimeDuration
:
:
FromMilliseconds
(
elapse
)
aObserver
)
;
notifier
.
SkipNotification
(
)
;
return
NS_OK
;
}
void
nsIWidget
:
:
OnLongTapTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
*
self
=
static_cast
<
nsIWidget
*
>
(
aClosure
)
;
if
(
(
self
-
>
mLongTapTouchPoint
-
>
mStamp
+
self
-
>
mLongTapTouchPoint
-
>
mDuration
)
>
TimeStamp
:
:
Now
(
)
)
{
#
ifdef
XP_WIN
self
-
>
SynthesizeNativeTouchPoint
(
self
-
>
mLongTapTouchPoint
-
>
mPointerId
TOUCH_CONTACT
self
-
>
mLongTapTouchPoint
-
>
mPosition
1
.
0
90
nullptr
)
;
#
endif
return
;
}
AutoObserverNotifier
notifier
(
self
-
>
mLongTapTouchPoint
-
>
mObserver
"
touchtap
"
)
;
self
-
>
mLongTapTimer
-
>
Cancel
(
)
;
self
-
>
mLongTapTimer
=
nullptr
;
self
-
>
SynthesizeNativeTouchPoint
(
self
-
>
mLongTapTouchPoint
-
>
mPointerId
TOUCH_REMOVE
self
-
>
mLongTapTouchPoint
-
>
mPosition
0
0
nullptr
)
;
self
-
>
mLongTapTouchPoint
=
nullptr
;
}
nsresult
nsIWidget
:
:
ClearNativeTouchSequence
(
nsIObserver
*
aObserver
)
{
AutoObserverNotifier
notifier
(
aObserver
"
cleartouch
"
)
;
if
(
!
mLongTapTimer
)
{
return
NS_OK
;
}
mLongTapTimer
-
>
Cancel
(
)
;
mLongTapTimer
=
nullptr
;
SynthesizeNativeTouchPoint
(
mLongTapTouchPoint
-
>
mPointerId
TOUCH_CANCEL
mLongTapTouchPoint
-
>
mPosition
0
0
nullptr
)
;
mLongTapTouchPoint
=
nullptr
;
return
NS_OK
;
}
MultiTouchInput
nsBaseWidget
:
:
UpdateSynthesizedTouchState
(
MultiTouchInput
*
aState
uint32_t
aTime
mozilla
:
:
TimeStamp
aTimeStamp
uint32_t
aPointerId
TouchPointerState
aPointerState
LayoutDeviceIntPoint
aPoint
double
aPointerPressure
uint32_t
aPointerOrientation
)
{
ScreenIntPoint
pointerScreenPoint
=
ViewAs
<
ScreenPixel
>
(
aPoint
PixelCastJustification
:
:
LayoutDeviceIsScreenForBounds
)
;
MultiTouchInput
inputToDispatch
;
inputToDispatch
.
mInputType
=
MULTITOUCH_INPUT
;
inputToDispatch
.
mTime
=
aTime
;
inputToDispatch
.
mTimeStamp
=
aTimeStamp
;
int32_t
index
=
aState
-
>
IndexOfTouch
(
(
int32_t
)
aPointerId
)
;
if
(
aPointerState
=
=
TOUCH_CONTACT
)
{
if
(
index
>
=
0
)
{
SingleTouchData
&
point
=
aState
-
>
mTouches
[
index
]
;
point
.
mScreenPoint
=
pointerScreenPoint
;
point
.
mRotationAngle
=
(
float
)
aPointerOrientation
;
point
.
mForce
=
(
float
)
aPointerPressure
;
inputToDispatch
.
mType
=
MultiTouchInput
:
:
MULTITOUCH_MOVE
;
}
else
{
aState
-
>
mTouches
.
AppendElement
(
SingleTouchData
(
(
int32_t
)
aPointerId
pointerScreenPoint
ScreenSize
(
0
0
)
(
float
)
aPointerOrientation
(
float
)
aPointerPressure
)
)
;
inputToDispatch
.
mType
=
MultiTouchInput
:
:
MULTITOUCH_START
;
}
inputToDispatch
.
mTouches
=
aState
-
>
mTouches
;
}
else
{
MOZ_ASSERT
(
aPointerState
=
=
TOUCH_REMOVE
|
|
aPointerState
=
=
TOUCH_CANCEL
)
;
if
(
index
>
=
0
)
{
aState
-
>
mTouches
.
RemoveElementAt
(
index
)
;
}
inputToDispatch
.
mType
=
(
aPointerState
=
=
TOUCH_REMOVE
?
MultiTouchInput
:
:
MULTITOUCH_END
:
MultiTouchInput
:
:
MULTITOUCH_CANCEL
)
;
inputToDispatch
.
mTouches
.
AppendElement
(
SingleTouchData
(
(
int32_t
)
aPointerId
pointerScreenPoint
ScreenSize
(
0
0
)
(
float
)
aPointerOrientation
(
float
)
aPointerPressure
)
)
;
}
return
inputToDispatch
;
}
void
nsBaseWidget
:
:
NotifyLiveResizeStarted
(
)
{
NotifyLiveResizeStopped
(
)
;
MOZ_ASSERT
(
mLiveResizeListeners
.
IsEmpty
(
)
)
;
if
(
!
mWidgetListener
)
{
return
;
}
nsCOMPtr
<
nsIAppWindow
>
appWindow
=
mWidgetListener
-
>
GetAppWindow
(
)
;
if
(
!
appWindow
)
{
return
;
}
mLiveResizeListeners
=
appWindow
-
>
GetLiveResizeListeners
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mLiveResizeListeners
.
Length
(
)
;
i
+
+
)
{
mLiveResizeListeners
[
i
]
-
>
LiveResizeStarted
(
)
;
}
}
void
nsBaseWidget
:
:
NotifyLiveResizeStopped
(
)
{
if
(
!
mLiveResizeListeners
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
mLiveResizeListeners
.
Length
(
)
;
i
+
+
)
{
mLiveResizeListeners
[
i
]
-
>
LiveResizeStopped
(
)
;
}
mLiveResizeListeners
.
Clear
(
)
;
}
}
nsresult
nsBaseWidget
:
:
AsyncEnableDragDrop
(
bool
aEnable
)
{
RefPtr
<
nsBaseWidget
>
kungFuDeathGrip
=
this
;
return
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
AsyncEnableDragDropFn
"
[
this
aEnable
kungFuDeathGrip
]
(
)
{
EnableDragDrop
(
aEnable
)
;
}
)
kAsyncDragDropTimeout
EventQueuePriority
:
:
Idle
)
;
}
void
nsBaseWidget
:
:
SwipeFinished
(
)
{
mSwipeTracker
=
nullptr
;
}
void
nsBaseWidget
:
:
ReportSwipeStarted
(
uint64_t
aInputBlockId
bool
aStartSwipe
)
{
if
(
mSwipeEventQueue
&
&
mSwipeEventQueue
-
>
inputBlockId
=
=
aInputBlockId
)
{
if
(
aStartSwipe
)
{
PanGestureInput
&
startEvent
=
mSwipeEventQueue
-
>
queuedEvents
[
0
]
;
TrackScrollEventAsSwipe
(
startEvent
mSwipeEventQueue
-
>
allowedDirections
)
;
for
(
size_t
i
=
1
;
i
<
mSwipeEventQueue
-
>
queuedEvents
.
Length
(
)
;
i
+
+
)
{
mSwipeTracker
-
>
ProcessEvent
(
mSwipeEventQueue
-
>
queuedEvents
[
i
]
)
;
}
}
mSwipeEventQueue
=
nullptr
;
}
}
void
nsBaseWidget
:
:
TrackScrollEventAsSwipe
(
const
mozilla
:
:
PanGestureInput
&
aSwipeStartEvent
uint32_t
aAllowedDirections
)
{
if
(
mSwipeTracker
)
{
mSwipeTracker
-
>
CancelSwipe
(
aSwipeStartEvent
.
mTimeStamp
)
;
mSwipeTracker
-
>
Destroy
(
)
;
mSwipeTracker
=
nullptr
;
}
uint32_t
direction
=
(
aSwipeStartEvent
.
mPanDisplacement
.
x
>
0
.
0
)
?
(
uint32_t
)
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_RIGHT
:
(
uint32_t
)
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_LEFT
;
mSwipeTracker
=
new
SwipeTracker
(
*
this
aSwipeStartEvent
aAllowedDirections
direction
)
;
if
(
!
mAPZC
)
{
mCurrentPanGestureBelongsToSwipe
=
true
;
}
}
nsBaseWidget
:
:
SwipeInfo
nsBaseWidget
:
:
SendMayStartSwipe
(
const
mozilla
:
:
PanGestureInput
&
aSwipeStartEvent
)
{
nsCOMPtr
<
nsIWidget
>
kungFuDeathGrip
(
this
)
;
uint32_t
direction
=
(
aSwipeStartEvent
.
mPanDisplacement
.
x
>
0
.
0
)
?
(
uint32_t
)
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_RIGHT
:
(
uint32_t
)
dom
:
:
SimpleGestureEvent_Binding
:
:
DIRECTION_LEFT
;
LayoutDeviceIntPoint
position
=
RoundedToInt
(
aSwipeStartEvent
.
mPanStartPoint
*
ScreenToLayoutDeviceScale
(
1
)
)
;
WidgetSimpleGestureEvent
geckoEvent
=
SwipeTracker
:
:
CreateSwipeGestureEvent
(
eSwipeGestureMayStart
this
position
aSwipeStartEvent
.
mTimeStamp
)
;
geckoEvent
.
mDirection
=
direction
;
geckoEvent
.
mDelta
=
0
.
0
;
geckoEvent
.
mAllowedDirections
=
0
;
bool
shouldStartSwipe
=
DispatchWindowEvent
(
geckoEvent
)
;
SwipeInfo
result
=
{
shouldStartSwipe
geckoEvent
.
mAllowedDirections
}
;
return
result
;
}
WidgetWheelEvent
nsBaseWidget
:
:
MayStartSwipeForAPZ
(
const
PanGestureInput
&
aPanInput
const
APZEventResult
&
aApzResult
CanTriggerSwipe
aCanTriggerSwipe
)
{
WidgetWheelEvent
event
=
aPanInput
.
ToWidgetEvent
(
this
)
;
if
(
aCanTriggerSwipe
=
=
CanTriggerSwipe
:
:
Yes
&
&
aPanInput
.
mOverscrollBehaviorAllowsSwipe
)
{
SwipeInfo
swipeInfo
=
SendMayStartSwipe
(
aPanInput
)
;
event
.
mCanTriggerSwipe
=
swipeInfo
.
wantsSwipe
;
if
(
swipeInfo
.
wantsSwipe
)
{
if
(
aApzResult
.
GetStatus
(
)
=
=
nsEventStatus_eIgnore
)
{
TrackScrollEventAsSwipe
(
aPanInput
swipeInfo
.
allowedDirections
)
;
}
else
{
mSwipeEventQueue
=
MakeUnique
<
SwipeEventQueue
>
(
swipeInfo
.
allowedDirections
aApzResult
.
mInputBlockId
)
;
}
}
}
if
(
mSwipeEventQueue
&
&
mSwipeEventQueue
-
>
inputBlockId
=
=
aApzResult
.
mInputBlockId
)
{
mSwipeEventQueue
-
>
queuedEvents
.
AppendElement
(
aPanInput
)
;
}
return
event
;
}
bool
nsBaseWidget
:
:
MayStartSwipeForNonAPZ
(
const
PanGestureInput
&
aPanInput
CanTriggerSwipe
aCanTriggerSwipe
)
{
if
(
aPanInput
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_MAYSTART
|
|
aPanInput
.
mType
=
=
PanGestureInput
:
:
PANGESTURE_START
)
{
mCurrentPanGestureBelongsToSwipe
=
false
;
}
if
(
mCurrentPanGestureBelongsToSwipe
)
{
MOZ_ASSERT
(
aPanInput
.
IsMomentum
(
)
"
If
the
fingers
are
still
on
the
touchpad
we
should
still
have
"
"
a
SwipeTracker
"
"
and
it
should
have
consumed
this
event
.
"
)
;
return
true
;
}
if
(
aCanTriggerSwipe
=
=
CanTriggerSwipe
:
:
No
)
{
return
false
;
}
SwipeInfo
swipeInfo
=
SendMayStartSwipe
(
aPanInput
)
;
ScrollableLayerGuid
guid
;
InputAPZContext
context
(
guid
0
nsEventStatus_eIgnore
)
;
WidgetWheelEvent
event
=
aPanInput
.
ToWidgetEvent
(
this
)
;
event
.
mCanTriggerSwipe
=
swipeInfo
.
wantsSwipe
;
nsEventStatus
status
;
DispatchEvent
(
&
event
status
)
;
if
(
swipeInfo
.
wantsSwipe
)
{
if
(
context
.
WasRoutedToChildProcess
(
)
)
{
mSwipeEventQueue
=
MakeUnique
<
SwipeEventQueue
>
(
swipeInfo
.
allowedDirections
0
)
;
}
else
if
(
event
.
TriggersSwipe
(
)
)
{
TrackScrollEventAsSwipe
(
aPanInput
swipeInfo
.
allowedDirections
)
;
}
}
if
(
mSwipeEventQueue
&
&
mSwipeEventQueue
-
>
inputBlockId
=
=
0
)
{
mSwipeEventQueue
-
>
queuedEvents
.
AppendElement
(
aPanInput
)
;
}
return
true
;
}
const
IMENotificationRequests
&
nsIWidget
:
:
IMENotificationRequestsRef
(
)
{
TextEventDispatcher
*
dispatcher
=
GetTextEventDispatcher
(
)
;
return
dispatcher
-
>
IMENotificationRequestsRef
(
)
;
}
void
nsIWidget
:
:
PostHandleKeyEvent
(
mozilla
:
:
WidgetKeyboardEvent
*
aEvent
)
{
}
bool
nsIWidget
:
:
GetEditCommands
(
NativeKeyBindingsType
aType
const
WidgetKeyboardEvent
&
aEvent
nsTArray
<
CommandInt
>
&
aCommands
)
{
MOZ_ASSERT
(
aEvent
.
IsTrusted
(
)
)
;
MOZ_ASSERT
(
aCommands
.
IsEmpty
(
)
)
;
return
true
;
}
already_AddRefed
<
nsIBidiKeyboard
>
nsIWidget
:
:
CreateBidiKeyboard
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
CreateBidiKeyboardContentProcess
(
)
;
}
return
CreateBidiKeyboardInner
(
)
;
}
#
ifdef
ANDROID
already_AddRefed
<
nsIBidiKeyboard
>
nsIWidget
:
:
CreateBidiKeyboardInner
(
)
{
return
nullptr
;
}
#
endif
namespace
mozilla
:
:
widget
{
const
char
*
ToChar
(
InputContext
:
:
Origin
aOrigin
)
{
switch
(
aOrigin
)
{
case
InputContext
:
:
ORIGIN_MAIN
:
return
"
ORIGIN_MAIN
"
;
case
InputContext
:
:
ORIGIN_CONTENT
:
return
"
ORIGIN_CONTENT
"
;
default
:
return
"
Unexpected
value
"
;
}
}
const
char
*
ToChar
(
IMEMessage
aIMEMessage
)
{
switch
(
aIMEMessage
)
{
case
NOTIFY_IME_OF_NOTHING
:
return
"
NOTIFY_IME_OF_NOTHING
"
;
case
NOTIFY_IME_OF_FOCUS
:
return
"
NOTIFY_IME_OF_FOCUS
"
;
case
NOTIFY_IME_OF_BLUR
:
return
"
NOTIFY_IME_OF_BLUR
"
;
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
return
"
NOTIFY_IME_OF_SELECTION_CHANGE
"
;
case
NOTIFY_IME_OF_TEXT_CHANGE
:
return
"
NOTIFY_IME_OF_TEXT_CHANGE
"
;
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
return
"
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
"
;
case
NOTIFY_IME_OF_POSITION_CHANGE
:
return
"
NOTIFY_IME_OF_POSITION_CHANGE
"
;
case
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
:
return
"
NOTIFY_IME_OF_MOUSE_BUTTON_EVENT
"
;
case
REQUEST_TO_COMMIT_COMPOSITION
:
return
"
REQUEST_TO_COMMIT_COMPOSITION
"
;
case
REQUEST_TO_CANCEL_COMPOSITION
:
return
"
REQUEST_TO_CANCEL_COMPOSITION
"
;
default
:
return
"
Unexpected
value
"
;
}
}
void
NativeIMEContext
:
:
Init
(
nsIWidget
*
aWidget
)
{
if
(
!
aWidget
)
{
mRawNativeIMEContext
=
reinterpret_cast
<
uintptr_t
>
(
nullptr
)
;
mOriginProcessID
=
static_cast
<
uint64_t
>
(
-
1
)
;
return
;
}
if
(
!
XRE_IsContentProcess
(
)
)
{
mRawNativeIMEContext
=
reinterpret_cast
<
uintptr_t
>
(
aWidget
-
>
GetNativeData
(
NS_RAW_NATIVE_IME_CONTEXT
)
)
;
mOriginProcessID
=
0
;
return
;
}
*
this
=
aWidget
-
>
GetNativeIMEContext
(
)
;
}
void
NativeIMEContext
:
:
InitWithRawNativeIMEContext
(
void
*
aRawNativeIMEContext
)
{
if
(
NS_WARN_IF
(
!
aRawNativeIMEContext
)
)
{
mRawNativeIMEContext
=
reinterpret_cast
<
uintptr_t
>
(
nullptr
)
;
mOriginProcessID
=
static_cast
<
uint64_t
>
(
-
1
)
;
return
;
}
mRawNativeIMEContext
=
reinterpret_cast
<
uintptr_t
>
(
aRawNativeIMEContext
)
;
mOriginProcessID
=
XRE_IsContentProcess
(
)
?
ContentChild
:
:
GetSingleton
(
)
-
>
GetID
(
)
:
0
;
}
void
IMENotification
:
:
TextChangeDataBase
:
:
MergeWith
(
const
IMENotification
:
:
TextChangeDataBase
&
aOther
)
{
MOZ_ASSERT
(
aOther
.
IsValid
(
)
"
Merging
data
must
store
valid
data
"
)
;
MOZ_ASSERT
(
aOther
.
mStartOffset
<
=
aOther
.
mRemovedEndOffset
"
end
of
removed
text
must
be
same
or
larger
than
start
"
)
;
MOZ_ASSERT
(
aOther
.
mStartOffset
<
=
aOther
.
mAddedEndOffset
"
end
of
added
text
must
be
same
or
larger
than
start
"
)
;
if
(
!
IsValid
(
)
)
{
*
this
=
aOther
;
return
;
}
const
TextChangeDataBase
&
newData
=
aOther
;
const
TextChangeDataBase
oldData
=
*
this
;
mCausedOnlyByComposition
=
newData
.
mCausedOnlyByComposition
&
&
oldData
.
mCausedOnlyByComposition
;
mIncludingChangesWithoutComposition
=
newData
.
mIncludingChangesWithoutComposition
|
|
oldData
.
mIncludingChangesWithoutComposition
;
if
(
!
newData
.
mCausedOnlyByComposition
&
&
!
newData
.
mIncludingChangesDuringComposition
)
{
MOZ_ASSERT
(
newData
.
mIncludingChangesWithoutComposition
)
;
MOZ_ASSERT
(
mIncludingChangesWithoutComposition
)
;
mIncludingChangesDuringComposition
=
false
;
}
else
{
mIncludingChangesDuringComposition
=
newData
.
mIncludingChangesDuringComposition
|
|
oldData
.
mIncludingChangesDuringComposition
;
}
if
(
newData
.
mStartOffset
>
=
oldData
.
mAddedEndOffset
)
{
mStartOffset
=
oldData
.
mStartOffset
;
uint32_t
newRemovedEndOffsetInOldText
=
newData
.
mRemovedEndOffset
-
oldData
.
Difference
(
)
;
mRemovedEndOffset
=
std
:
:
max
(
newRemovedEndOffsetInOldText
oldData
.
mRemovedEndOffset
)
;
mAddedEndOffset
=
newData
.
mAddedEndOffset
;
return
;
}
if
(
newData
.
mStartOffset
>
=
oldData
.
mStartOffset
)
{
mStartOffset
=
oldData
.
mStartOffset
;
if
(
newData
.
mRemovedEndOffset
>
=
oldData
.
mAddedEndOffset
)
{
uint32_t
newRemovedEndOffsetInOldText
=
newData
.
mRemovedEndOffset
-
oldData
.
Difference
(
)
;
mRemovedEndOffset
=
std
:
:
max
(
newRemovedEndOffsetInOldText
oldData
.
mRemovedEndOffset
)
;
mAddedEndOffset
=
newData
.
mAddedEndOffset
;
return
;
}
mRemovedEndOffset
=
oldData
.
mRemovedEndOffset
;
uint32_t
oldAddedEndOffsetInNewText
=
oldData
.
mAddedEndOffset
+
newData
.
Difference
(
)
;
mAddedEndOffset
=
std
:
:
max
(
newData
.
mAddedEndOffset
oldAddedEndOffsetInNewText
)
;
return
;
}
if
(
newData
.
mRemovedEndOffset
>
=
oldData
.
mStartOffset
)
{
MOZ_ASSERT
(
newData
.
mStartOffset
<
oldData
.
mStartOffset
"
new
start
offset
should
be
less
than
old
one
here
"
)
;
mStartOffset
=
newData
.
mStartOffset
;
if
(
newData
.
mRemovedEndOffset
>
=
oldData
.
mAddedEndOffset
)
{
uint32_t
newRemovedEndOffsetInOldText
=
newData
.
mRemovedEndOffset
-
oldData
.
Difference
(
)
;
mRemovedEndOffset
=
std
:
:
max
(
newRemovedEndOffsetInOldText
oldData
.
mRemovedEndOffset
)
;
mAddedEndOffset
=
newData
.
mAddedEndOffset
;
return
;
}
mRemovedEndOffset
=
oldData
.
mRemovedEndOffset
;
uint32_t
oldAddedEndOffsetInNewText
=
oldData
.
mAddedEndOffset
+
newData
.
Difference
(
)
;
mAddedEndOffset
=
std
:
:
max
(
newData
.
mAddedEndOffset
oldAddedEndOffsetInNewText
)
;
return
;
}
MOZ_ASSERT
(
newData
.
mStartOffset
<
oldData
.
mStartOffset
"
new
start
offset
should
be
less
than
old
one
here
"
)
;
mStartOffset
=
newData
.
mStartOffset
;
MOZ_ASSERT
(
newData
.
mRemovedEndOffset
<
oldData
.
mRemovedEndOffset
"
new
removed
end
offset
should
be
less
than
old
one
here
"
)
;
mRemovedEndOffset
=
oldData
.
mRemovedEndOffset
;
uint32_t
oldAddedEndOffsetInNewText
=
oldData
.
mAddedEndOffset
+
newData
.
Difference
(
)
;
mAddedEndOffset
=
std
:
:
max
(
newData
.
mAddedEndOffset
oldAddedEndOffsetInNewText
)
;
}
#
ifdef
DEBUG
void
IMENotification
:
:
TextChangeDataBase
:
:
Test
(
)
{
static
bool
gTestTextChangeEvent
=
true
;
if
(
!
gTestTextChangeEvent
)
{
return
;
}
gTestTextChangeEvent
=
false
;
MergeWith
(
TextChangeData
(
10
10
20
false
false
)
)
;
MergeWith
(
TextChangeData
(
20
20
35
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
1
-
1
-
1
:
mStartOffset
should
be
the
first
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
10
"
Test
1
-
1
-
2
:
mRemovedEndOffset
should
be
the
first
end
of
removed
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
35
"
Test
1
-
1
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
10
20
10
false
false
)
)
;
MergeWith
(
TextChangeData
(
10
30
10
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
1
-
2
-
1
:
mStartOffset
should
be
the
first
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
40
"
Test
1
-
2
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
with
already
removed
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
10
"
Test
1
-
2
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
10
20
10
false
false
)
)
;
MergeWith
(
TextChangeData
(
10
15
10
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
1
-
3
-
1
:
mStartOffset
should
be
the
first
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
25
"
Test
1
-
3
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
with
already
removed
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
10
"
Test
1
-
3
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
10
10
20
false
false
)
)
;
MergeWith
(
TextChangeData
(
55
55
60
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
1
-
4
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
45
"
Test
1
-
4
-
2
:
mRemovedEndOffset
should
be
the
the
largest
end
of
removed
"
"
text
without
already
added
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
60
"
Test
1
-
4
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
10
20
10
false
false
)
)
;
MergeWith
(
TextChangeData
(
55
68
55
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
1
-
5
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
78
"
Test
1
-
5
-
2
:
mRemovedEndOffset
should
be
the
the
largest
end
of
removed
"
"
text
with
already
removed
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
55
"
Test
1
-
5
-
3
:
mAddedEndOffset
should
be
the
largest
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
30
35
32
false
false
)
)
;
MergeWith
(
TextChangeData
(
32
32
40
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
30
"
Test
1
-
6
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
35
"
Test
1
-
6
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
40
"
Test
1
-
6
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
30
35
32
false
false
)
)
;
MergeWith
(
TextChangeData
(
32
32
33
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
30
"
Test
1
-
7
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
35
"
Test
1
-
7
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
33
"
Test
1
-
7
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
30
35
30
false
false
)
)
;
MergeWith
(
TextChangeData
(
32
34
48
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
30
"
Test
1
-
8
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
39
"
Test
1
-
8
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
"
"
removed
text
"
"
without
already
removed
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
48
"
Test
1
-
8
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
30
35
30
false
false
)
)
;
MergeWith
(
TextChangeData
(
32
38
36
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
30
"
Test
1
-
9
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
43
"
Test
1
-
9
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
"
"
removed
text
"
"
without
already
removed
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
36
"
Test
1
-
9
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
50
55
false
false
)
)
;
MergeWith
(
TextChangeData
(
53
60
54
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
50
"
Test
2
-
1
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
55
"
Test
2
-
1
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
54
"
Test
2
-
1
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
50
55
false
false
)
)
;
MergeWith
(
TextChangeData
(
54
62
68
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
50
"
Test
2
-
2
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
57
"
Test
2
-
2
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
68
"
Test
2
-
2
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
36
48
45
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
50
49
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
36
"
Test
2
-
3
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
53
"
Test
2
-
3
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
removed
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
49
"
Test
2
-
3
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
36
52
53
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
68
61
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
36
"
Test
2
-
4
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
67
"
Test
2
-
4
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
61
"
Test
2
-
4
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
10
10
20
false
false
)
)
;
MergeWith
(
TextChangeData
(
15
15
30
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
3
-
1
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
10
"
Test
3
-
1
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
"
"
removed
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
35
"
Test
3
-
1
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
50
55
false
false
)
)
;
MergeWith
(
TextChangeData
(
52
53
56
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
50
"
Test
3
-
2
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
50
"
Test
3
-
2
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
"
"
removed
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
58
"
Test
3
-
2
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
36
48
45
false
false
)
)
;
MergeWith
(
TextChangeData
(
37
38
50
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
36
"
Test
3
-
3
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
48
"
Test
3
-
3
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
"
"
removed
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
57
"
Test
3
-
3
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
32
48
53
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
50
52
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
32
"
Test
3
-
4
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
48
"
Test
3
-
4
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
55
"
Test
3
-
4
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
36
48
50
false
false
)
)
;
MergeWith
(
TextChangeData
(
37
49
47
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
36
"
Test
3
-
5
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
48
"
Test
3
-
5
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
48
"
Test
3
-
5
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
"
"
text
without
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
32
48
53
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
50
47
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
32
"
Test
3
-
6
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
48
"
Test
3
-
6
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
50
"
Test
3
-
6
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
"
"
text
without
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
50
55
false
false
)
)
;
MergeWith
(
TextChangeData
(
44
66
68
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
44
"
Test
4
-
1
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
61
"
Test
4
-
1
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
68
"
Test
4
-
1
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
62
50
false
false
)
)
;
MergeWith
(
TextChangeData
(
44
66
68
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
44
"
Test
4
-
2
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
78
"
Test
4
-
2
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
removed
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
68
"
Test
4
-
2
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
62
60
false
false
)
)
;
MergeWith
(
TextChangeData
(
49
128
130
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
49
"
Test
4
-
3
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
130
"
Test
4
-
3
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
without
already
removed
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
130
"
Test
4
-
3
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
61
73
false
false
)
)
;
MergeWith
(
TextChangeData
(
44
100
50
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
44
"
Test
4
-
4
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
88
"
Test
4
-
4
-
2
:
mRemovedEndOffset
should
be
the
the
last
end
of
"
"
removed
text
"
"
with
already
added
text
length
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
50
"
Test
4
-
4
-
3
:
mAddedEndOffset
should
be
the
last
end
of
added
text
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
50
55
false
false
)
)
;
MergeWith
(
TextChangeData
(
48
52
49
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
48
"
Test
5
-
1
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
50
"
Test
5
-
1
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
52
"
Test
5
-
1
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
60
58
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
50
48
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
43
"
Test
5
-
2
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
60
"
Test
5
-
2
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
56
"
Test
5
-
2
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
"
"
text
without
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
60
68
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
55
53
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
43
"
Test
5
-
3
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
60
"
Test
5
-
3
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
66
"
Test
5
-
3
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
"
"
text
without
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
60
58
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
50
128
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
43
"
Test
5
-
4
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
60
"
Test
5
-
4
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
136
"
Test
5
-
4
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
60
68
false
false
)
)
;
MergeWith
(
TextChangeData
(
43
55
65
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
43
"
Test
5
-
5
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
60
"
Test
5
-
5
-
2
:
mRemovedEndOffset
should
be
the
the
first
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
78
"
Test
5
-
5
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
30
30
45
false
false
)
)
;
MergeWith
(
TextChangeData
(
10
10
20
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
6
-
1
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
30
"
Test
6
-
1
-
2
:
mRemovedEndOffset
should
be
the
the
largest
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
55
"
Test
6
-
1
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
added
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
30
35
30
false
false
)
)
;
MergeWith
(
TextChangeData
(
10
25
10
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
10
"
Test
6
-
2
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
35
"
Test
6
-
2
-
2
:
mRemovedEndOffset
should
be
the
the
largest
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
15
"
Test
6
-
2
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
text
with
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
65
70
false
false
)
)
;
MergeWith
(
TextChangeData
(
13
24
15
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
13
"
Test
6
-
3
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
65
"
Test
6
-
3
-
2
:
mRemovedEndOffset
should
be
the
the
largest
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
61
"
Test
6
-
3
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
"
"
text
without
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
MergeWith
(
TextChangeData
(
50
65
70
false
false
)
)
;
MergeWith
(
TextChangeData
(
13
24
36
false
false
)
)
;
MOZ_ASSERT
(
mStartOffset
=
=
13
"
Test
6
-
4
-
1
:
mStartOffset
should
be
the
smallest
offset
"
)
;
MOZ_ASSERT
(
mRemovedEndOffset
=
=
65
"
Test
6
-
4
-
2
:
mRemovedEndOffset
should
be
the
the
largest
end
of
removed
"
"
text
"
)
;
MOZ_ASSERT
(
mAddedEndOffset
=
=
82
"
Test
6
-
4
-
3
:
mAddedEndOffset
should
be
the
first
end
of
added
"
"
text
without
"
"
removed
text
length
by
the
new
change
"
)
;
Clear
(
)
;
}
#
endif
}
#
ifdef
DEBUG
nsAutoString
nsBaseWidget
:
:
debug_GuiEventToString
(
WidgetGUIEvent
*
aGuiEvent
)
{
NS_ASSERTION
(
nullptr
!
=
aGuiEvent
"
cmon
null
gui
event
.
"
)
;
nsAutoString
eventName
(
u
"
UNKNOWN
"
_ns
)
;
#
define
_ASSIGN_eventName
(
_value
_name
)
\
case
_value
:
\
eventName
.
AssignLiteral
(
_name
)
;
\
break
switch
(
aGuiEvent
-
>
mMessage
)
{
_ASSIGN_eventName
(
eBlur
"
eBlur
"
)
;
_ASSIGN_eventName
(
eDrop
"
eDrop
"
)
;
_ASSIGN_eventName
(
eDragEnter
"
eDragEnter
"
)
;
_ASSIGN_eventName
(
eDragExit
"
eDragExit
"
)
;
_ASSIGN_eventName
(
eDragOver
"
eDragOver
"
)
;
_ASSIGN_eventName
(
eEditorInput
"
eEditorInput
"
)
;
_ASSIGN_eventName
(
eFocus
"
eFocus
"
)
;
_ASSIGN_eventName
(
eFocusIn
"
eFocusIn
"
)
;
_ASSIGN_eventName
(
eFocusOut
"
eFocusOut
"
)
;
_ASSIGN_eventName
(
eFormSelect
"
eFormSelect
"
)
;
_ASSIGN_eventName
(
eFormChange
"
eFormChange
"
)
;
_ASSIGN_eventName
(
eFormReset
"
eFormReset
"
)
;
_ASSIGN_eventName
(
eFormSubmit
"
eFormSubmit
"
)
;
_ASSIGN_eventName
(
eImageAbort
"
eImageAbort
"
)
;
_ASSIGN_eventName
(
eLoadError
"
eLoadError
"
)
;
_ASSIGN_eventName
(
eKeyDown
"
eKeyDown
"
)
;
_ASSIGN_eventName
(
eKeyPress
"
eKeyPress
"
)
;
_ASSIGN_eventName
(
eKeyUp
"
eKeyUp
"
)
;
_ASSIGN_eventName
(
eMouseEnterIntoWidget
"
eMouseEnterIntoWidget
"
)
;
_ASSIGN_eventName
(
eMouseExitFromWidget
"
eMouseExitFromWidget
"
)
;
_ASSIGN_eventName
(
eMouseDown
"
eMouseDown
"
)
;
_ASSIGN_eventName
(
eMouseUp
"
eMouseUp
"
)
;
_ASSIGN_eventName
(
eMouseClick
"
eMouseClick
"
)
;
_ASSIGN_eventName
(
eMouseAuxClick
"
eMouseAuxClick
"
)
;
_ASSIGN_eventName
(
eMouseDoubleClick
"
eMouseDoubleClick
"
)
;
_ASSIGN_eventName
(
eMouseMove
"
eMouseMove
"
)
;
_ASSIGN_eventName
(
eLoad
"
eLoad
"
)
;
_ASSIGN_eventName
(
ePopState
"
ePopState
"
)
;
_ASSIGN_eventName
(
eBeforeScriptExecute
"
eBeforeScriptExecute
"
)
;
_ASSIGN_eventName
(
eAfterScriptExecute
"
eAfterScriptExecute
"
)
;
_ASSIGN_eventName
(
eUnload
"
eUnload
"
)
;
_ASSIGN_eventName
(
eHashChange
"
eHashChange
"
)
;
_ASSIGN_eventName
(
eReadyStateChange
"
eReadyStateChange
"
)
;
_ASSIGN_eventName
(
eXULBroadcast
"
eXULBroadcast
"
)
;
_ASSIGN_eventName
(
eXULCommandUpdate
"
eXULCommandUpdate
"
)
;
#
undef
_ASSIGN_eventName
default
:
{
eventName
.
AssignLiteral
(
"
UNKNOWN
:
"
)
;
eventName
.
AppendInt
(
aGuiEvent
-
>
mMessage
)
;
}
break
;
}
return
nsAutoString
(
eventName
)
;
}
struct
PrefPair
{
const
char
*
name
;
bool
value
;
}
;
static
PrefPair
debug_PrefValues
[
]
=
{
{
"
nglayout
.
debug
.
crossing_event_dumping
"
false
}
{
"
nglayout
.
debug
.
event_dumping
"
false
}
{
"
nglayout
.
debug
.
invalidate_dumping
"
false
}
{
"
nglayout
.
debug
.
motion_event_dumping
"
false
}
{
"
nglayout
.
debug
.
paint_dumping
"
false
}
}
;
bool
nsBaseWidget
:
:
debug_GetCachedBoolPref
(
const
char
*
aPrefName
)
{
NS_ASSERTION
(
nullptr
!
=
aPrefName
"
cmon
pref
name
is
null
.
"
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
debug_PrefValues
)
;
i
+
+
)
{
if
(
strcmp
(
debug_PrefValues
[
i
]
.
name
aPrefName
)
=
=
0
)
{
return
debug_PrefValues
[
i
]
.
value
;
}
}
return
false
;
}
static
void
debug_SetCachedBoolPref
(
const
char
*
aPrefName
bool
aValue
)
{
NS_ASSERTION
(
nullptr
!
=
aPrefName
"
cmon
pref
name
is
null
.
"
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
debug_PrefValues
)
;
i
+
+
)
{
if
(
strcmp
(
debug_PrefValues
[
i
]
.
name
aPrefName
)
=
=
0
)
{
debug_PrefValues
[
i
]
.
value
=
aValue
;
return
;
}
}
NS_ASSERTION
(
false
"
cmon
this
code
is
not
reached
dude
.
"
)
;
}
class
Debug_PrefObserver
final
:
public
nsIObserver
{
~
Debug_PrefObserver
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
}
;
NS_IMPL_ISUPPORTS
(
Debug_PrefObserver
nsIObserver
)
NS_IMETHODIMP
Debug_PrefObserver
:
:
Observe
(
nsISupports
*
subject
const
char
*
topic
const
char16_t
*
data
)
{
NS_ConvertUTF16toUTF8
prefName
(
data
)
;
bool
value
=
Preferences
:
:
GetBool
(
prefName
.
get
(
)
false
)
;
debug_SetCachedBoolPref
(
prefName
.
get
(
)
value
)
;
return
NS_OK
;
}
void
debug_RegisterPrefCallbacks
(
)
{
static
bool
once
=
true
;
if
(
!
once
)
{
return
;
}
once
=
false
;
nsCOMPtr
<
nsIObserver
>
obs
(
new
Debug_PrefObserver
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
debug_PrefValues
)
;
i
+
+
)
{
debug_PrefValues
[
i
]
.
value
=
Preferences
:
:
GetBool
(
debug_PrefValues
[
i
]
.
name
false
)
;
if
(
obs
)
{
nsCString
name
;
name
.
AssignLiteral
(
debug_PrefValues
[
i
]
.
name
strlen
(
debug_PrefValues
[
i
]
.
name
)
)
;
Preferences
:
:
AddStrongObserver
(
obs
name
)
;
}
}
}
static
int32_t
_GetPrintCount
(
)
{
static
int32_t
sCount
=
0
;
return
+
+
sCount
;
}
void
nsBaseWidget
:
:
debug_DumpEvent
(
FILE
*
aFileOut
nsIWidget
*
aWidget
WidgetGUIEvent
*
aGuiEvent
const
char
*
aWidgetName
int32_t
aWindowID
)
{
if
(
aGuiEvent
-
>
mMessage
=
=
eMouseMove
)
{
if
(
!
debug_GetCachedBoolPref
(
"
nglayout
.
debug
.
motion_event_dumping
"
)
)
return
;
}
if
(
aGuiEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
|
|
aGuiEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
{
if
(
!
debug_GetCachedBoolPref
(
"
nglayout
.
debug
.
crossing_event_dumping
"
)
)
return
;
}
if
(
!
debug_GetCachedBoolPref
(
"
nglayout
.
debug
.
event_dumping
"
)
)
return
;
NS_LossyConvertUTF16toASCII
tempString
(
debug_GuiEventToString
(
aGuiEvent
)
.
get
(
)
)
;
fprintf
(
aFileOut
"
%
4d
%
-
26s
widget
=
%
-
8p
name
=
%
-
12s
id
=
0x
%
-
6x
refpt
=
%
d
%
d
\
n
"
_GetPrintCount
(
)
tempString
.
get
(
)
(
void
*
)
aWidget
aWidgetName
aWindowID
aGuiEvent
-
>
mRefPoint
.
x
aGuiEvent
-
>
mRefPoint
.
y
)
;
}
void
nsBaseWidget
:
:
debug_DumpPaintEvent
(
FILE
*
aFileOut
nsIWidget
*
aWidget
const
nsIntRegion
&
aRegion
const
char
*
aWidgetName
int32_t
aWindowID
)
{
NS_ASSERTION
(
nullptr
!
=
aFileOut
"
cmon
null
output
FILE
"
)
;
NS_ASSERTION
(
nullptr
!
=
aWidget
"
cmon
the
widget
is
null
"
)
;
if
(
!
debug_GetCachedBoolPref
(
"
nglayout
.
debug
.
paint_dumping
"
)
)
return
;
nsIntRect
rect
=
aRegion
.
GetBounds
(
)
;
fprintf
(
aFileOut
"
%
4d
PAINT
widget
=
%
p
name
=
%
-
12s
id
=
0x
%
-
6x
bounds
-
rect
=
%
3d
%
-
3d
"
"
%
3d
%
-
3d
"
_GetPrintCount
(
)
(
void
*
)
aWidget
aWidgetName
aWindowID
rect
.
X
(
)
rect
.
Y
(
)
rect
.
Width
(
)
rect
.
Height
(
)
)
;
fprintf
(
aFileOut
"
\
n
"
)
;
}
void
nsBaseWidget
:
:
debug_DumpInvalidate
(
FILE
*
aFileOut
nsIWidget
*
aWidget
const
LayoutDeviceIntRect
*
aRect
const
char
*
aWidgetName
int32_t
aWindowID
)
{
if
(
!
debug_GetCachedBoolPref
(
"
nglayout
.
debug
.
invalidate_dumping
"
)
)
return
;
NS_ASSERTION
(
nullptr
!
=
aFileOut
"
cmon
null
output
FILE
"
)
;
NS_ASSERTION
(
nullptr
!
=
aWidget
"
cmon
the
widget
is
null
"
)
;
fprintf
(
aFileOut
"
%
4d
Invalidate
widget
=
%
p
name
=
%
-
12s
id
=
0x
%
-
6x
"
_GetPrintCount
(
)
(
void
*
)
aWidget
aWidgetName
aWindowID
)
;
if
(
aRect
)
{
fprintf
(
aFileOut
"
rect
=
%
3d
%
-
3d
%
3d
%
-
3d
"
aRect
-
>
X
(
)
aRect
-
>
Y
(
)
aRect
-
>
Width
(
)
aRect
-
>
Height
(
)
)
;
}
else
{
fprintf
(
aFileOut
"
rect
=
%
-
15s
"
"
none
"
)
;
}
fprintf
(
aFileOut
"
\
n
"
)
;
}
#
endif
