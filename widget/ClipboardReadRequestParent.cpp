#
include
"
mozilla
/
ClipboardReadRequestParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsWidgetsCID
.
h
"
using
mozilla
:
:
dom
:
:
ContentParent
;
using
mozilla
:
:
ipc
:
:
IPCResult
;
namespace
mozilla
{
namespace
{
class
ClipboardGetDataCallback
final
:
public
nsIAsyncClipboardRequestCallback
{
public
:
explicit
ClipboardGetDataCallback
(
std
:
:
function
<
void
(
nsresult
)
>
&
&
aCallback
)
:
mCallback
(
std
:
:
move
(
aCallback
)
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
OnComplete
(
nsresult
aResult
)
override
{
mCallback
(
aResult
)
;
return
NS_OK
;
}
protected
:
~
ClipboardGetDataCallback
(
)
=
default
;
std
:
:
function
<
void
(
nsresult
)
>
mCallback
;
}
;
NS_IMPL_ISUPPORTS
(
ClipboardGetDataCallback
nsIAsyncClipboardRequestCallback
)
static
Result
<
nsCOMPtr
<
nsITransferable
>
nsresult
>
CreateTransferable
(
const
nsTArray
<
nsCString
>
&
aTypes
)
{
nsresult
rv
;
nsCOMPtr
<
nsITransferable
>
trans
=
do_CreateInstance
(
"
mozilla
.
org
/
widget
/
transferable
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
rv
)
;
}
MOZ_TRY
(
trans
-
>
Init
(
nullptr
)
)
;
trans
-
>
SetIsPrivateData
(
true
)
;
for
(
uint32_t
t
=
0
;
t
<
aTypes
.
Length
(
)
;
t
+
+
)
{
MOZ_TRY
(
trans
-
>
AddDataFlavor
(
aTypes
[
t
]
.
get
(
)
)
)
;
}
return
std
:
:
move
(
trans
)
;
}
}
IPCResult
ClipboardReadRequestParent
:
:
RecvGetData
(
const
nsTArray
<
nsCString
>
&
aFlavors
GetDataResolver
&
&
aResolver
)
{
bool
valid
=
false
;
if
(
NS_FAILED
(
mClipboardDataSnapshot
-
>
GetValid
(
&
valid
)
)
|
|
!
valid
)
{
Unused
<
<
PClipboardReadRequestParent
:
:
Send__delete__
(
this
)
;
aResolver
(
NS_ERROR_FAILURE
)
;
return
IPC_OK
(
)
;
}
auto
result
=
CreateTransferable
(
aFlavors
)
;
if
(
result
.
isErr
(
)
)
{
aResolver
(
result
.
unwrapErr
(
)
)
;
return
IPC_OK
(
)
;
}
nsCOMPtr
<
nsITransferable
>
trans
=
result
.
unwrap
(
)
;
RefPtr
<
ClipboardGetDataCallback
>
callback
=
MakeRefPtr
<
ClipboardGetDataCallback
>
(
[
self
=
RefPtr
{
this
}
resolver
=
std
:
:
move
(
aResolver
)
trans
manager
=
mManager
]
(
nsresult
aRv
)
{
if
(
NS_FAILED
(
aRv
)
)
{
bool
valid
=
false
;
if
(
NS_FAILED
(
self
-
>
mClipboardDataSnapshot
-
>
GetValid
(
&
valid
)
)
|
|
!
valid
)
{
Unused
<
<
PClipboardReadRequestParent
:
:
Send__delete__
(
self
)
;
}
resolver
(
aRv
)
;
return
;
}
dom
:
:
IPCTransferableData
ipcTransferableData
;
nsContentUtils
:
:
TransferableToIPCTransferableData
(
trans
&
ipcTransferableData
false
manager
)
;
resolver
(
std
:
:
move
(
ipcTransferableData
)
)
;
}
)
;
nsresult
rv
=
mClipboardDataSnapshot
-
>
GetData
(
trans
callback
)
;
if
(
NS_FAILED
(
rv
)
)
{
callback
-
>
OnComplete
(
rv
)
;
}
return
IPC_OK
(
)
;
}
}
