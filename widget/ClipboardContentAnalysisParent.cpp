#
include
"
ContentAnalysis
.
h
"
#
include
"
mozilla
/
ClipboardContentAnalysisParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsBaseClipboard
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsITransferable
.
h
"
namespace
mozilla
{
namespace
{
using
ClipboardResultPromise
=
MozPromise
<
dom
:
:
IPCTransferableData
nsresult
true
>
;
static
RefPtr
<
ClipboardResultPromise
>
GetClipboardImpl
(
const
nsTArray
<
nsCString
>
&
aTypes
int32_t
aWhichClipboard
uint64_t
aRequestingWindowContextId
dom
:
:
ThreadsafeContentParentHandle
*
aRequestingContentParent
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
window
=
dom
:
:
WindowGlobalParent
:
:
GetByInnerWindowId
(
aRequestingWindowContextId
)
;
if
(
!
window
)
{
return
ClipboardResultPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
if
(
window
-
>
IsDiscarded
(
)
)
{
NS_WARNING
(
"
discarded
window
passed
to
RecvGetClipboard
(
)
;
returning
"
"
no
clipboard
"
"
content
"
)
;
return
ClipboardResultPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
if
(
aRequestingContentParent
-
>
ChildID
(
)
!
=
window
-
>
ContentParentId
(
)
)
{
NS_WARNING
(
"
incorrect
content
process
passing
window
to
GetClipboard
"
)
;
return
ClipboardResultPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
nsCOMPtr
<
nsIClipboard
>
clipboard
=
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboard
;
1
"
)
;
if
(
!
clipboard
)
{
return
ClipboardResultPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
auto
transferableToCheck
=
dom
:
:
ContentParent
:
:
CreateClipboardTransferable
(
aTypes
)
;
if
(
transferableToCheck
.
isErr
(
)
)
{
return
ClipboardResultPromise
:
:
CreateAndReject
(
transferableToCheck
.
unwrapErr
(
)
__func__
)
;
}
nsCOMPtr
transferable
=
transferableToCheck
.
unwrap
(
)
;
nsresult
rv
=
clipboard
-
>
GetData
(
transferable
aWhichClipboard
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ClipboardResultPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
auto
resultPromise
=
MakeRefPtr
<
ClipboardResultPromise
:
:
Private
>
(
__func__
)
;
auto
contentAnalysisCallback
=
mozilla
:
:
MakeRefPtr
<
mozilla
:
:
contentanalysis
:
:
ContentAnalysis
:
:
SafeContentAnalysisResultCallback
>
(
[
transferable
resultPromise
cpHandle
=
RefPtr
{
aRequestingContentParent
}
]
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
aResult
)
{
AssertIsOnMainThread
(
)
;
bool
shouldAllow
=
aResult
-
>
GetShouldAllowContent
(
)
;
if
(
!
shouldAllow
)
{
resultPromise
-
>
Reject
(
NS_ERROR_CONTENT_BLOCKED
__func__
)
;
return
;
}
dom
:
:
IPCTransferableData
transferableData
;
RefPtr
<
dom
:
:
ContentParent
>
contentParent
=
cpHandle
-
>
GetContentParent
(
)
;
nsContentUtils
:
:
TransferableToIPCTransferableData
(
transferable
&
transferableData
true
contentParent
)
;
resultPromise
-
>
Resolve
(
std
:
:
move
(
transferableData
)
__func__
)
;
}
)
;
contentanalysis
:
:
ContentAnalysis
:
:
CheckClipboardContentAnalysis
(
static_cast
<
nsBaseClipboard
*
>
(
clipboard
.
get
(
)
)
window
transferable
aWhichClipboard
contentAnalysisCallback
)
;
return
resultPromise
;
}
}
ipc
:
:
IPCResult
ClipboardContentAnalysisParent
:
:
RecvGetClipboard
(
nsTArray
<
nsCString
>
&
&
aTypes
const
int32_t
&
aWhichClipboard
const
uint64_t
&
aRequestingWindowContextId
IPCTransferableDataOrError
*
aTransferableDataOrError
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
Monitor
mon
(
"
ClipboardContentAnalysisParent
:
:
RecvGetClipboard
"
)
;
InvokeAsync
(
GetMainThreadSerialEventTarget
(
)
__func__
[
&
]
(
)
{
return
GetClipboardImpl
(
aTypes
aWhichClipboard
aRequestingWindowContextId
mThreadsafeContentParentHandle
)
;
}
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
&
]
(
ClipboardResultPromise
:
:
ResolveOrRejectValue
&
&
aResult
)
{
AssertIsOnMainThread
(
)
;
MonitorAutoLock
lock
(
mon
)
;
if
(
aResult
.
IsResolve
(
)
)
{
*
aTransferableDataOrError
=
std
:
:
move
(
aResult
.
ResolveValue
(
)
)
;
}
else
{
*
aTransferableDataOrError
=
aResult
.
RejectValue
(
)
;
}
mon
.
Notify
(
)
;
}
)
;
{
MonitorAutoLock
lock
(
mon
)
;
while
(
aTransferableDataOrError
-
>
type
(
)
=
=
IPCTransferableDataOrError
:
:
T__None
)
{
mon
.
Wait
(
)
;
}
}
if
(
aTransferableDataOrError
-
>
type
(
)
=
=
IPCTransferableDataOrError
:
:
Tnsresult
)
{
NS_WARNING
(
nsPrintfCString
(
"
ClipboardContentAnalysisParent
:
:
"
"
RecvGetClipboard
got
error
%
x
"
static_cast
<
int
>
(
aTransferableDataOrError
-
>
get_nsresult
(
)
)
)
.
get
(
)
)
;
}
return
IPC_OK
(
)
;
}
}
