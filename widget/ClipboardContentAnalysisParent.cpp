#
include
"
ContentAnalysis
.
h
"
#
include
"
mozilla
/
ClipboardContentAnalysisParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
nsBaseClipboard
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsWidgetsCID
.
h
"
namespace
mozilla
{
static
NS_DEFINE_CID
(
kCClipboardCID
NS_CLIPBOARD_CID
)
;
ipc
:
:
IPCResult
ClipboardContentAnalysisParent
:
:
RecvGetClipboard
(
nsTArray
<
nsCString
>
&
&
aTypes
const
int32_t
&
aWhichClipboard
const
uint64_t
&
aRequestingWindowContextId
IPCTransferableDataOrError
*
aTransferableDataOrError
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
nsIThread
>
actorThread
=
NS_GetCurrentThread
(
)
;
NS_ASSERTION
(
actorThread
"
NS_GetCurrentThread
(
)
should
not
fail
"
)
;
mozilla
:
:
Maybe
<
mozilla
:
:
Variant
<
IPCTransferableData
nsresult
>
>
maybeTransferableResult
;
std
:
:
atomic
<
bool
>
transferableResultSet
=
false
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
actorThread
aTypes
=
std
:
:
move
(
aTypes
)
aWhichClipboard
aRequestingWindowContextId
&
maybeTransferableResult
&
transferableResultSet
]
(
)
{
nsresult
rv
=
NS_OK
;
auto
sendRv
=
MakeScopeExit
(
[
&
]
(
)
{
maybeTransferableResult
=
Some
(
AsVariant
(
rv
)
)
;
transferableResultSet
=
true
;
NS_DispatchToThreadQueue
(
NS_NewRunnableFunction
(
__func__
[
]
(
)
{
}
)
actorThread
EventQueuePriority
:
:
Normal
)
;
}
)
;
nsCOMPtr
<
nsIClipboard
>
clipboard
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
window
=
dom
:
:
WindowGlobalParent
:
:
GetByInnerWindowId
(
aRequestingWindowContextId
)
;
if
(
!
window
)
{
rv
=
NS_ERROR_FAILURE
;
return
;
}
if
(
window
-
>
IsDiscarded
(
)
)
{
NS_WARNING
(
"
discarded
window
passed
to
RecvGetClipboard
(
)
;
returning
"
"
no
clipboard
"
"
content
"
)
;
rv
=
NS_ERROR_FAILURE
;
return
;
}
clipboard
=
do_GetService
(
kCClipboardCID
&
rv
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
auto
transferableToCheck
=
dom
:
:
ContentParent
:
:
CreateClipboardTransferable
(
aTypes
)
;
if
(
transferableToCheck
.
isErr
(
)
)
{
rv
=
transferableToCheck
.
unwrapErr
(
)
;
return
;
}
nsCOMPtr
transferable
=
transferableToCheck
.
unwrap
(
)
;
rv
=
clipboard
-
>
GetData
(
transferable
aWhichClipboard
nullptr
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
auto
contentAnalysisCallback
=
mozilla
:
:
MakeRefPtr
<
mozilla
:
:
contentanalysis
:
:
ContentAnalysis
:
:
SafeContentAnalysisResultCallback
>
(
[
actorThread
transferable
aRequestingWindowContextId
&
maybeTransferableResult
&
transferableResultSet
]
(
RefPtr
<
nsIContentAnalysisResult
>
&
&
aResult
)
{
bool
shouldAllow
=
aResult
-
>
GetShouldAllowContent
(
)
;
if
(
!
shouldAllow
)
{
maybeTransferableResult
=
Some
(
AsVariant
(
NS_ERROR_CONTENT_BLOCKED
)
)
;
}
else
{
IPCTransferableData
transferableData
;
RefPtr
<
dom
:
:
WindowGlobalParent
>
window
=
dom
:
:
WindowGlobalParent
:
:
GetByInnerWindowId
(
aRequestingWindowContextId
)
;
if
(
!
window
&
&
window
-
>
IsDiscarded
(
)
)
{
maybeTransferableResult
=
Some
(
AsVariant
(
NS_ERROR_UNEXPECTED
)
)
;
}
else
{
maybeTransferableResult
=
Some
(
AsVariant
(
IPCTransferableData
(
)
)
)
;
nsContentUtils
:
:
TransferableToIPCTransferableData
(
transferable
&
(
maybeTransferableResult
.
ref
(
)
.
as
<
IPCTransferableData
>
(
)
)
true
window
-
>
BrowsingContext
(
)
-
>
GetContentParent
(
)
)
;
}
}
transferableResultSet
=
true
;
NS_DispatchToThreadQueue
(
NS_NewRunnableFunction
(
__func__
[
]
(
)
{
}
)
actorThread
EventQueuePriority
:
:
Normal
)
;
}
)
;
contentanalysis
:
:
ContentAnalysis
:
:
CheckClipboardContentAnalysis
(
static_cast
<
nsBaseClipboard
*
>
(
clipboard
.
get
(
)
)
window
transferable
aWhichClipboard
contentAnalysisCallback
)
;
sendRv
.
release
(
)
;
}
)
)
;
mozilla
:
:
SpinEventLoopUntil
(
"
Waiting
for
clipboard
and
content
analysis
"
_ns
[
&
transferableResultSet
]
{
return
transferableResultSet
.
load
(
)
;
}
)
;
NS_ASSERTION
(
maybeTransferableResult
.
isSome
(
)
"
maybeTransferableResult
should
be
set
when
"
"
transferableResultSet
is
true
!
"
)
;
auto
&
transferableResult
=
*
maybeTransferableResult
;
if
(
transferableResult
.
is
<
nsresult
>
(
)
)
{
*
aTransferableDataOrError
=
transferableResult
.
as
<
nsresult
>
(
)
;
NS_WARNING
(
nsPrintfCString
(
"
ClipboardContentAnalysisParent
:
:
"
"
RecvGetClipboard
got
error
%
x
"
static_cast
<
int
>
(
transferableResult
.
as
<
nsresult
>
(
)
)
)
.
get
(
)
)
;
}
else
{
*
aTransferableDataOrError
=
std
:
:
move
(
transferableResult
.
as
<
IPCTransferableData
>
(
)
)
;
}
return
IPC_OK
(
)
;
}
}
