#
include
"
nsBaseClipboard
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
nsIClipboardOwner
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsXPCOM
.
h
"
using
mozilla
:
:
GenericPromise
;
using
mozilla
:
:
LogLevel
;
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
dom
:
:
ClipboardCapabilities
;
NS_IMPL_ISUPPORTS
(
ClipboardSetDataHelper
:
:
AsyncSetClipboardData
nsIAsyncSetClipboardData
)
ClipboardSetDataHelper
:
:
AsyncSetClipboardData
:
:
AsyncSetClipboardData
(
int32_t
aClipboardType
ClipboardSetDataHelper
*
aClipboard
nsIAsyncSetClipboardDataCallback
*
aCallback
)
:
mClipboardType
(
aClipboardType
)
mClipboard
(
aClipboard
)
mCallback
(
aCallback
)
{
MOZ_ASSERT
(
mClipboard
)
;
MOZ_ASSERT
(
mClipboard
-
>
IsClipboardTypeSupported
(
mClipboardType
)
)
;
}
NS_IMETHODIMP
ClipboardSetDataHelper
:
:
AsyncSetClipboardData
:
:
SetData
(
nsITransferable
*
aTransferable
nsIClipboardOwner
*
aOwner
)
{
if
(
!
IsValid
(
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mClipboard
)
;
MOZ_ASSERT
(
mClipboard
-
>
IsClipboardTypeSupported
(
mClipboardType
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mClipboard
-
>
mPendingWriteRequests
[
mClipboardType
]
=
=
this
)
;
RefPtr
<
AsyncSetClipboardData
>
request
=
std
:
:
move
(
mClipboard
-
>
mPendingWriteRequests
[
mClipboardType
]
)
;
nsresult
rv
=
mClipboard
-
>
SetData
(
aTransferable
aOwner
mClipboardType
)
;
MaybeNotifyCallback
(
rv
)
;
return
rv
;
}
NS_IMETHODIMP
ClipboardSetDataHelper
:
:
AsyncSetClipboardData
:
:
Abort
(
nsresult
aReason
)
{
if
(
!
IsValid
(
)
|
|
!
NS_FAILED
(
aReason
)
)
{
return
NS_ERROR_FAILURE
;
}
MaybeNotifyCallback
(
aReason
)
;
return
NS_OK
;
}
void
ClipboardSetDataHelper
:
:
AsyncSetClipboardData
:
:
MaybeNotifyCallback
(
nsresult
aResult
)
{
MOZ_ASSERT
(
IsValid
(
)
)
;
if
(
nsCOMPtr
<
nsIAsyncSetClipboardDataCallback
>
callback
=
mCallback
.
forget
(
)
)
{
callback
-
>
OnComplete
(
aResult
)
;
}
mClipboard
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
ClipboardSetDataHelper
nsIClipboard
)
ClipboardSetDataHelper
:
:
~
ClipboardSetDataHelper
(
)
{
for
(
auto
&
request
:
mPendingWriteRequests
)
{
if
(
request
)
{
request
-
>
Abort
(
NS_ERROR_ABORT
)
;
request
=
nullptr
;
}
}
}
void
ClipboardSetDataHelper
:
:
RejectPendingAsyncSetDataRequestIfAny
(
int32_t
aClipboardType
)
{
MOZ_ASSERT
(
nsIClipboard
:
:
IsClipboardTypeSupported
(
aClipboardType
)
)
;
auto
&
request
=
mPendingWriteRequests
[
aClipboardType
]
;
if
(
request
)
{
request
-
>
Abort
(
NS_ERROR_ABORT
)
;
request
=
nullptr
;
}
}
NS_IMETHODIMP
ClipboardSetDataHelper
:
:
SetData
(
nsITransferable
*
aTransferable
nsIClipboardOwner
*
aOwner
int32_t
aWhichClipboard
)
{
NS_ENSURE_ARG
(
aTransferable
)
;
if
(
!
nsIClipboard
:
:
IsClipboardTypeSupported
(
aWhichClipboard
)
)
{
return
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
}
RejectPendingAsyncSetDataRequestIfAny
(
aWhichClipboard
)
;
return
SetNativeClipboardData
(
aTransferable
aOwner
aWhichClipboard
)
;
}
NS_IMETHODIMP
ClipboardSetDataHelper
:
:
AsyncSetData
(
int32_t
aWhichClipboard
nsIAsyncSetClipboardDataCallback
*
aCallback
nsIAsyncSetClipboardData
*
*
_retval
)
{
*
_retval
=
nullptr
;
if
(
!
nsIClipboard
:
:
IsClipboardTypeSupported
(
aWhichClipboard
)
)
{
return
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
}
RejectPendingAsyncSetDataRequestIfAny
(
aWhichClipboard
)
;
RefPtr
<
AsyncSetClipboardData
>
request
=
mozilla
:
:
MakeRefPtr
<
AsyncSetClipboardData
>
(
aWhichClipboard
this
aCallback
)
;
mPendingWriteRequests
[
aWhichClipboard
]
=
request
;
request
.
forget
(
_retval
)
;
return
NS_OK
;
}
nsBaseClipboard
:
:
nsBaseClipboard
(
const
ClipboardCapabilities
&
aClipboardCaps
)
:
mClipboardCaps
(
aClipboardCaps
)
{
using
mozilla
:
:
MakeUnique
;
mCaches
[
kGlobalClipboard
]
=
MakeUnique
<
ClipboardCache
>
(
)
;
if
(
mClipboardCaps
.
supportsSelectionClipboard
(
)
)
{
mCaches
[
kSelectionClipboard
]
=
MakeUnique
<
ClipboardCache
>
(
)
;
}
if
(
mClipboardCaps
.
supportsFindClipboard
(
)
)
{
mCaches
[
kFindClipboard
]
=
MakeUnique
<
ClipboardCache
>
(
)
;
}
if
(
mClipboardCaps
.
supportsSelectionCache
(
)
)
{
mCaches
[
kSelectionCache
]
=
MakeUnique
<
ClipboardCache
>
(
)
;
}
}
NS_IMPL_ISUPPORTS_INHERITED0
(
nsBaseClipboard
ClipboardSetDataHelper
)
NS_IMETHODIMP
nsBaseClipboard
:
:
SetData
(
nsITransferable
*
aTransferable
nsIClipboardOwner
*
anOwner
int32_t
aWhichClipboard
)
{
NS_ASSERTION
(
aTransferable
"
clipboard
given
a
null
transferable
"
)
;
CLIPBOARD_LOG
(
"
%
s
:
clipboard
=
%
d
"
__FUNCTION__
aWhichClipboard
)
;
if
(
!
nsIClipboard
:
:
IsClipboardTypeSupported
(
aWhichClipboard
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
clipboard
%
d
is
not
supported
.
"
__FUNCTION__
aWhichClipboard
)
;
return
NS_ERROR_FAILURE
;
}
const
auto
&
clipboardCache
=
mCaches
[
aWhichClipboard
]
;
MOZ_ASSERT
(
clipboardCache
)
;
if
(
aTransferable
=
=
clipboardCache
-
>
GetTransferable
(
)
&
&
anOwner
=
=
clipboardCache
-
>
GetClipboardOwner
(
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
skipping
update
.
"
__FUNCTION__
)
;
return
NS_OK
;
}
mEmptyingForSetData
=
true
;
if
(
NS_FAILED
(
EmptyClipboard
(
aWhichClipboard
)
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
emptying
clipboard
failed
.
"
__FUNCTION__
)
;
}
mEmptyingForSetData
=
false
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
aTransferable
)
{
mIgnoreEmptyNotification
=
true
;
rv
=
ClipboardSetDataHelper
:
:
SetData
(
aTransferable
anOwner
aWhichClipboard
)
;
mIgnoreEmptyNotification
=
false
;
}
if
(
NS_FAILED
(
rv
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
setting
native
clipboard
data
failed
.
"
__FUNCTION__
)
;
return
rv
;
}
auto
result
=
GetNativeClipboardSequenceNumber
(
aWhichClipboard
)
;
if
(
result
.
isErr
(
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
getting
native
clipboard
change
count
failed
.
"
__FUNCTION__
)
;
return
result
.
unwrapErr
(
)
;
}
clipboardCache
-
>
Update
(
aTransferable
anOwner
result
.
unwrap
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseClipboard
:
:
GetData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
)
{
CLIPBOARD_LOG
(
"
%
s
:
clipboard
=
%
d
"
__FUNCTION__
aWhichClipboard
)
;
if
(
!
aTransferable
)
{
NS_ASSERTION
(
false
"
clipboard
given
a
null
transferable
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
kSelectionCache
=
=
aWhichClipboard
|
|
!
nsIClipboard
:
:
IsClipboardTypeSupported
(
aWhichClipboard
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
clipboard
%
d
is
not
supported
.
"
__FUNCTION__
aWhichClipboard
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mozilla
:
:
StaticPrefs
:
:
widget_clipboard_use_cached_data_enabled
(
)
)
{
if
(
auto
*
clipboardCache
=
GetClipboardCacheIfValid
(
aWhichClipboard
)
)
{
MOZ_ASSERT
(
clipboardCache
-
>
GetTransferable
(
)
)
;
nsTArray
<
nsCString
>
flavors
;
nsresult
rv
=
aTransferable
-
>
FlavorsTransferableCanImport
(
flavors
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
const
auto
&
flavor
:
flavors
)
{
nsCOMPtr
<
nsISupports
>
dataSupports
;
rv
=
clipboardCache
-
>
GetTransferable
(
)
-
>
GetTransferData
(
flavor
.
get
(
)
getter_AddRefs
(
dataSupports
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
getting
%
s
from
cache
.
"
__FUNCTION__
flavor
.
get
(
)
)
;
aTransferable
-
>
SetTransferData
(
flavor
.
get
(
)
dataSupports
)
;
return
NS_OK
;
}
}
}
}
return
GetNativeClipboardData
(
aTransferable
aWhichClipboard
)
;
}
RefPtr
<
GenericPromise
>
nsBaseClipboard
:
:
AsyncGetData
(
nsITransferable
*
aTransferable
int32_t
aWhichClipboard
)
{
nsresult
rv
=
GetData
(
aTransferable
aWhichClipboard
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
GenericPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
NS_IMETHODIMP
nsBaseClipboard
:
:
EmptyClipboard
(
int32_t
aWhichClipboard
)
{
CLIPBOARD_LOG
(
"
%
s
:
clipboard
=
%
i
"
__FUNCTION__
aWhichClipboard
)
;
if
(
!
nsIClipboard
:
:
IsClipboardTypeSupported
(
aWhichClipboard
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mIgnoreEmptyNotification
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
How
did
we
get
here
?
"
)
;
return
NS_OK
;
}
const
auto
&
clipboardCache
=
mCaches
[
aWhichClipboard
]
;
MOZ_ASSERT
(
clipboardCache
)
;
clipboardCache
-
>
Clear
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsBaseClipboard
:
:
HasDataMatchingFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
bool
*
aOutResult
)
{
CLIPBOARD_LOG
(
"
%
s
:
clipboard
=
%
d
"
__FUNCTION__
aWhichClipboard
)
;
if
(
CLIPBOARD_LOG_ENABLED
(
)
)
{
CLIPBOARD_LOG
(
"
Asking
for
content
clipboard
=
%
i
:
\
n
"
aWhichClipboard
)
;
for
(
const
auto
&
flavor
:
aFlavorList
)
{
CLIPBOARD_LOG
(
"
MIME
%
s
"
flavor
.
get
(
)
)
;
}
}
*
aOutResult
=
false
;
if
(
kSelectionCache
=
=
aWhichClipboard
|
|
!
nsIClipboard
:
:
IsClipboardTypeSupported
(
aWhichClipboard
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
clipboard
%
d
is
not
supported
.
"
__FUNCTION__
aWhichClipboard
)
;
return
NS_OK
;
}
if
(
mozilla
:
:
StaticPrefs
:
:
widget_clipboard_use_cached_data_enabled
(
)
)
{
if
(
auto
*
clipboardCache
=
GetClipboardCacheIfValid
(
aWhichClipboard
)
)
{
MOZ_ASSERT
(
clipboardCache
-
>
GetTransferable
(
)
)
;
nsTArray
<
nsCString
>
transferableFlavors
;
nsresult
rv
=
clipboardCache
-
>
GetTransferable
(
)
-
>
FlavorsTransferableCanImport
(
transferableFlavors
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
CLIPBOARD_LOG_ENABLED
(
)
)
{
CLIPBOARD_LOG
(
"
Cached
transferable
types
(
nums
%
zu
)
\
n
"
transferableFlavors
.
Length
(
)
)
;
for
(
const
auto
&
transferableFlavor
:
transferableFlavors
)
{
CLIPBOARD_LOG
(
"
MIME
%
s
"
transferableFlavor
.
get
(
)
)
;
}
}
for
(
const
auto
&
transferableFlavor
:
transferableFlavors
)
{
for
(
const
auto
&
flavor
:
aFlavorList
)
{
if
(
transferableFlavor
.
Equals
(
flavor
)
)
{
CLIPBOARD_LOG
(
"
has
%
s
"
flavor
.
get
(
)
)
;
*
aOutResult
=
true
;
return
NS_OK
;
}
}
}
}
}
}
auto
resultOrError
=
HasNativeClipboardDataMatchingFlavors
(
aFlavorList
aWhichClipboard
)
;
if
(
resultOrError
.
isErr
(
)
)
{
CLIPBOARD_LOG
(
"
%
s
:
checking
native
clipboard
data
matching
flavors
falied
.
"
__FUNCTION__
)
;
return
resultOrError
.
unwrapErr
(
)
;
}
*
aOutResult
=
resultOrError
.
unwrap
(
)
;
return
NS_OK
;
}
RefPtr
<
DataFlavorsPromise
>
nsBaseClipboard
:
:
AsyncHasDataMatchingFlavors
(
const
nsTArray
<
nsCString
>
&
aFlavorList
int32_t
aWhichClipboard
)
{
nsTArray
<
nsCString
>
results
;
for
(
const
auto
&
flavor
:
aFlavorList
)
{
bool
hasMatchingFlavor
=
false
;
nsresult
rv
=
HasDataMatchingFlavors
(
AutoTArray
<
nsCString
1
>
{
flavor
}
aWhichClipboard
&
hasMatchingFlavor
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
hasMatchingFlavor
)
{
results
.
AppendElement
(
flavor
)
;
}
}
return
DataFlavorsPromise
:
:
CreateAndResolve
(
std
:
:
move
(
results
)
__func__
)
;
}
NS_IMETHODIMP
nsBaseClipboard
:
:
IsClipboardTypeSupported
(
int32_t
aWhichClipboard
bool
*
aRetval
)
{
NS_ENSURE_ARG_POINTER
(
aRetval
)
;
switch
(
aWhichClipboard
)
{
case
kGlobalClipboard
:
*
aRetval
=
true
;
return
NS_OK
;
case
kSelectionClipboard
:
*
aRetval
=
mClipboardCaps
.
supportsSelectionClipboard
(
)
;
return
NS_OK
;
case
kFindClipboard
:
*
aRetval
=
mClipboardCaps
.
supportsFindClipboard
(
)
;
return
NS_OK
;
case
kSelectionCache
:
*
aRetval
=
mClipboardCaps
.
supportsSelectionCache
(
)
;
return
NS_OK
;
default
:
*
aRetval
=
false
;
return
NS_OK
;
}
}
nsBaseClipboard
:
:
ClipboardCache
*
nsBaseClipboard
:
:
GetClipboardCacheIfValid
(
int32_t
aClipboardType
)
{
MOZ_ASSERT
(
nsIClipboard
:
:
IsClipboardTypeSupported
(
aClipboardType
)
)
;
const
mozilla
:
:
UniquePtr
<
ClipboardCache
>
&
cache
=
mCaches
[
aClipboardType
]
;
MOZ_ASSERT
(
cache
)
;
if
(
!
cache
-
>
GetTransferable
(
)
)
{
MOZ_ASSERT
(
cache
-
>
GetSequenceNumber
(
)
=
=
-
1
)
;
return
nullptr
;
}
auto
changeCountOrError
=
GetNativeClipboardSequenceNumber
(
aClipboardType
)
;
if
(
changeCountOrError
.
isErr
(
)
)
{
return
nullptr
;
}
if
(
changeCountOrError
.
unwrap
(
)
!
=
cache
-
>
GetSequenceNumber
(
)
)
{
cache
-
>
Clear
(
)
;
return
nullptr
;
}
return
cache
.
get
(
)
;
}
void
nsBaseClipboard
:
:
ClipboardCache
:
:
Clear
(
)
{
if
(
mClipboardOwner
)
{
mClipboardOwner
-
>
LosingOwnership
(
mTransferable
)
;
mClipboardOwner
=
nullptr
;
}
mTransferable
=
nullptr
;
mSequenceNumber
=
-
1
;
}
