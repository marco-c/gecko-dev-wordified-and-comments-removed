#
ifndef
mozilla_TextEvents_h__
#
define
mozilla_TextEvents_h__
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
FontRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsStringHashKey
;
template
<
class
class
>
class
nsDataHashtable
;
enum
{
#
define
NS_DEFINE_VK
(
aDOMKeyName
aDOMKeyCode
)
NS_
#
#
aDOMKeyName
=
aDOMKeyCode
#
include
"
mozilla
/
VirtualKeyCodeList
.
h
"
#
undef
NS_DEFINE_VK
NS_VK_UNKNOWN
=
0xFF
}
;
namespace
mozilla
{
enum
:
uint32_t
{
eKeyLocationStandard
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_KEY_LOCATION_STANDARD
eKeyLocationLeft
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_KEY_LOCATION_LEFT
eKeyLocationRight
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_KEY_LOCATION_RIGHT
eKeyLocationNumpad
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_KEY_LOCATION_NUMPAD
}
;
const
nsCString
GetDOMKeyCodeName
(
uint32_t
aKeyCode
)
;
namespace
dom
{
class
PBrowserParent
;
class
PBrowserChild
;
}
namespace
plugins
{
class
PPluginInstanceChild
;
}
enum
class
AccessKeyType
{
eChrome
eContent
eNone
}
;
struct
AlternativeCharCode
{
AlternativeCharCode
(
)
:
mUnshiftedCharCode
(
0
)
mShiftedCharCode
(
0
)
{
}
AlternativeCharCode
(
uint32_t
aUnshiftedCharCode
uint32_t
aShiftedCharCode
)
:
mUnshiftedCharCode
(
aUnshiftedCharCode
)
mShiftedCharCode
(
aShiftedCharCode
)
{
}
uint32_t
mUnshiftedCharCode
;
uint32_t
mShiftedCharCode
;
}
;
struct
ShortcutKeyCandidate
{
ShortcutKeyCandidate
(
)
:
mCharCode
(
0
)
mIgnoreShift
(
0
)
{
}
ShortcutKeyCandidate
(
uint32_t
aCharCode
bool
aIgnoreShift
)
:
mCharCode
(
aCharCode
)
mIgnoreShift
(
aIgnoreShift
)
{
}
uint32_t
mCharCode
;
bool
mIgnoreShift
;
}
;
struct
IgnoreModifierState
{
bool
mShift
;
bool
mOS
;
IgnoreModifierState
(
)
:
mShift
(
false
)
mOS
(
false
)
{
}
}
;
class
WidgetKeyboardEvent
:
public
WidgetInputEvent
{
private
:
friend
class
dom
:
:
PBrowserParent
;
friend
class
dom
:
:
PBrowserChild
;
friend
struct
IPC
:
:
ParamTraits
<
WidgetKeyboardEvent
>
;
protected
:
WidgetKeyboardEvent
(
)
:
mNativeKeyEvent
(
nullptr
)
mKeyCode
(
0
)
mCharCode
(
0
)
mPseudoCharCode
(
0
)
mLocation
(
eKeyLocationStandard
)
mUniqueId
(
0
)
#
ifdef
XP_MACOSX
mNativeModifierFlags
(
0
)
mNativeKeyCode
(
0
)
#
endif
mKeyNameIndex
(
KEY_NAME_INDEX_Unidentified
)
mCodeNameIndex
(
CODE_NAME_INDEX_UNKNOWN
)
mIsRepeat
(
false
)
mIsComposing
(
false
)
mIsSynthesizedByTIP
(
false
)
mMaybeSkippableInRemoteProcess
(
true
)
mUseLegacyKeyCodeAndCharCodeValues
(
false
)
mEditCommandsForSingleLineEditorInitialized
(
false
)
mEditCommandsForMultiLineEditorInitialized
(
false
)
mEditCommandsForRichTextEditorInitialized
(
false
)
{
}
public
:
virtual
WidgetKeyboardEvent
*
AsKeyboardEvent
(
)
override
{
return
this
;
}
WidgetKeyboardEvent
(
bool
aIsTrusted
EventMessage
aMessage
nsIWidget
*
aWidget
EventClassID
aEventClassID
=
eKeyboardEventClass
)
:
WidgetInputEvent
(
aIsTrusted
aMessage
aWidget
aEventClassID
)
mNativeKeyEvent
(
nullptr
)
mKeyCode
(
0
)
mCharCode
(
0
)
mPseudoCharCode
(
0
)
mLocation
(
eKeyLocationStandard
)
mUniqueId
(
0
)
#
ifdef
XP_MACOSX
mNativeModifierFlags
(
0
)
mNativeKeyCode
(
0
)
#
endif
mKeyNameIndex
(
KEY_NAME_INDEX_Unidentified
)
mCodeNameIndex
(
CODE_NAME_INDEX_UNKNOWN
)
mIsRepeat
(
false
)
mIsComposing
(
false
)
mIsSynthesizedByTIP
(
false
)
mMaybeSkippableInRemoteProcess
(
true
)
mUseLegacyKeyCodeAndCharCodeValues
(
false
)
mEditCommandsForSingleLineEditorInitialized
(
false
)
mEditCommandsForMultiLineEditorInitialized
(
false
)
mEditCommandsForRichTextEditorInitialized
(
false
)
{
if
(
IsKeyEventOnPlugin
(
)
)
{
mFlags
.
mOnlySystemGroupDispatchInContent
=
true
;
StopCrossProcessForwarding
(
)
;
}
}
static
bool
IsKeyDownOrKeyDownOnPlugin
(
EventMessage
aMessage
)
{
return
aMessage
=
=
eKeyDown
|
|
aMessage
=
=
eKeyDownOnPlugin
;
}
bool
IsKeyDownOrKeyDownOnPlugin
(
)
const
{
return
IsKeyDownOrKeyDownOnPlugin
(
mMessage
)
;
}
static
bool
IsKeyUpOrKeyUpOnPlugin
(
EventMessage
aMessage
)
{
return
aMessage
=
=
eKeyUp
|
|
aMessage
=
=
eKeyUpOnPlugin
;
}
bool
IsKeyUpOrKeyUpOnPlugin
(
)
const
{
return
IsKeyUpOrKeyUpOnPlugin
(
mMessage
)
;
}
static
bool
IsKeyEventOnPlugin
(
EventMessage
aMessage
)
{
return
aMessage
=
=
eKeyDownOnPlugin
|
|
aMessage
=
=
eKeyUpOnPlugin
;
}
bool
IsKeyEventOnPlugin
(
)
const
{
return
IsKeyEventOnPlugin
(
mMessage
)
;
}
bool
IsInputtingText
(
)
const
{
return
mMessage
=
=
eKeyPress
&
&
mCharCode
&
&
!
(
mModifiers
&
(
#
ifndef
XP_MACOSX
MODIFIER_ALT
|
#
endif
MODIFIER_CONTROL
|
MODIFIER_META
|
MODIFIER_OS
)
)
;
}
bool
IsInputtingLineBreak
(
)
const
{
return
mMessage
=
=
eKeyPress
&
&
mKeyNameIndex
=
=
KEY_NAME_INDEX_Enter
&
&
!
(
mModifiers
&
(
MODIFIER_ALT
|
MODIFIER_CONTROL
|
MODIFIER_META
|
MODIFIER_OS
)
)
;
}
bool
ShouldKeyPressEventBeFiredOnContent
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mMessage
=
=
eKeyPress
)
;
if
(
IsInputtingText
(
)
|
|
IsInputtingLineBreak
(
)
)
{
return
true
;
}
return
mMessage
=
=
eKeyPress
&
&
mKeyNameIndex
=
=
KEY_NAME_INDEX_Enter
&
&
!
(
mModifiers
&
(
MODIFIER_ALT
|
MODIFIER_META
|
MODIFIER_OS
|
MODIFIER_SHIFT
)
)
;
}
virtual
WidgetEvent
*
Duplicate
(
)
const
override
{
MOZ_ASSERT
(
mClass
=
=
eKeyboardEventClass
"
Duplicate
(
)
must
be
overridden
by
sub
class
"
)
;
WidgetKeyboardEvent
*
result
=
new
WidgetKeyboardEvent
(
false
mMessage
nullptr
)
;
result
-
>
AssignKeyEventData
(
*
this
true
)
;
result
-
>
mEditCommandsForSingleLineEditor
=
mEditCommandsForSingleLineEditor
;
result
-
>
mEditCommandsForMultiLineEditor
=
mEditCommandsForMultiLineEditor
;
result
-
>
mEditCommandsForRichTextEditor
=
mEditCommandsForRichTextEditor
;
result
-
>
mFlags
=
mFlags
;
return
result
;
}
nsTArray
<
AlternativeCharCode
>
mAlternativeCharCodes
;
nsString
mKeyValue
;
nsString
mCodeValue
;
#
ifdef
XP_MACOSX
nsString
mNativeCharacters
;
nsString
mNativeCharactersIgnoringModifiers
;
nsString
mPluginTextEventString
;
#
endif
void
*
mNativeKeyEvent
;
uint32_t
mKeyCode
;
uint32_t
mCharCode
;
uint32_t
mPseudoCharCode
;
uint32_t
mLocation
;
uint32_t
mUniqueId
;
#
ifdef
XP_MACOSX
uint32_t
mNativeModifierFlags
;
uint16_t
mNativeKeyCode
;
#
endif
KeyNameIndex
mKeyNameIndex
;
CodeNameIndex
mCodeNameIndex
;
bool
mIsRepeat
;
bool
mIsComposing
;
bool
mIsSynthesizedByTIP
;
bool
mMaybeSkippableInRemoteProcess
;
bool
mUseLegacyKeyCodeAndCharCodeValues
;
bool
CanSkipInRemoteProcess
(
)
const
{
return
mIsRepeat
&
&
mMaybeSkippableInRemoteProcess
;
}
void
InitAllEditCommands
(
)
;
void
InitEditCommandsFor
(
nsIWidget
:
:
NativeKeyBindingsType
aType
)
;
void
PreventNativeKeyBindings
(
)
{
mEditCommandsForSingleLineEditor
.
Clear
(
)
;
mEditCommandsForMultiLineEditor
.
Clear
(
)
;
mEditCommandsForRichTextEditor
.
Clear
(
)
;
mEditCommandsForSingleLineEditorInitialized
=
true
;
mEditCommandsForMultiLineEditorInitialized
=
true
;
mEditCommandsForRichTextEditorInitialized
=
true
;
}
const
nsTArray
<
CommandInt
>
&
EditCommandsConstRef
(
nsIWidget
:
:
NativeKeyBindingsType
aType
)
const
{
return
const_cast
<
WidgetKeyboardEvent
*
>
(
this
)
-
>
EditCommandsRef
(
aType
)
;
}
bool
IsEditCommandsInitialized
(
nsIWidget
:
:
NativeKeyBindingsType
aType
)
const
{
return
const_cast
<
WidgetKeyboardEvent
*
>
(
this
)
-
>
IsEditCommandsInitializedRef
(
aType
)
;
}
#
ifdef
DEBUG
bool
AreAllEditCommandsInitialized
(
)
const
{
return
mEditCommandsForSingleLineEditorInitialized
&
&
mEditCommandsForMultiLineEditorInitialized
&
&
mEditCommandsForRichTextEditorInitialized
;
}
#
endif
typedef
void
(
*
DoCommandCallback
)
(
Command
void
*
)
;
bool
ExecuteEditCommands
(
nsIWidget
:
:
NativeKeyBindingsType
aType
DoCommandCallback
aCallback
void
*
aCallbackData
)
;
bool
ShouldCauseKeypressEvents
(
)
const
;
uint32_t
PseudoCharCode
(
)
const
{
return
mMessage
=
=
eKeyPress
?
mCharCode
:
mPseudoCharCode
;
}
void
SetCharCode
(
uint32_t
aCharCode
)
{
if
(
mMessage
=
=
eKeyPress
)
{
mCharCode
=
aCharCode
;
}
else
{
mPseudoCharCode
=
aCharCode
;
}
}
void
GetDOMKeyName
(
nsAString
&
aKeyName
)
{
if
(
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
)
{
aKeyName
=
mKeyValue
;
return
;
}
GetDOMKeyName
(
mKeyNameIndex
aKeyName
)
;
}
void
GetDOMCodeName
(
nsAString
&
aCodeName
)
{
if
(
mCodeNameIndex
=
=
CODE_NAME_INDEX_USE_STRING
)
{
aCodeName
=
mCodeValue
;
return
;
}
GetDOMCodeName
(
mCodeNameIndex
aCodeName
)
;
}
static
uint32_t
GetFallbackKeyCodeOfPunctuationKey
(
CodeNameIndex
aCodeNameIndex
)
;
bool
IsModifierKeyEvent
(
)
const
{
return
GetModifierForKeyName
(
mKeyNameIndex
)
!
=
MODIFIER_NONE
;
}
void
GetShortcutKeyCandidates
(
ShortcutKeyCandidateArray
&
aCandidates
)
const
;
void
GetAccessKeyCandidates
(
nsTArray
<
uint32_t
>
&
aCandidates
)
const
;
bool
ModifiersMatchWithAccessKey
(
AccessKeyType
aType
)
const
;
Modifiers
ModifiersForAccessKeyMatching
(
)
const
;
static
Modifiers
AccessKeyModifiers
(
AccessKeyType
aType
)
;
static
void
Shutdown
(
)
;
static
uint32_t
ComputeLocationFromCodeValue
(
CodeNameIndex
aCodeNameIndex
)
;
static
uint32_t
ComputeKeyCodeFromKeyNameIndex
(
KeyNameIndex
aKeyNameIndex
)
;
static
CodeNameIndex
ComputeCodeNameIndexFromKeyNameIndex
(
KeyNameIndex
aKeyNameIndex
const
Maybe
<
uint32_t
>
&
aLocation
)
;
static
Modifier
GetModifierForKeyName
(
KeyNameIndex
aKeyNameIndex
)
;
static
bool
IsLeftOrRightModiferKeyNameIndex
(
KeyNameIndex
aKeyNameIndex
)
{
switch
(
aKeyNameIndex
)
{
case
KEY_NAME_INDEX_Alt
:
case
KEY_NAME_INDEX_Control
:
case
KEY_NAME_INDEX_Meta
:
case
KEY_NAME_INDEX_OS
:
case
KEY_NAME_INDEX_Shift
:
return
true
;
default
:
return
false
;
}
}
static
bool
IsLockableModifier
(
KeyNameIndex
aKeyNameIndex
)
;
static
void
GetDOMKeyName
(
KeyNameIndex
aKeyNameIndex
nsAString
&
aKeyName
)
;
static
void
GetDOMCodeName
(
CodeNameIndex
aCodeNameIndex
nsAString
&
aCodeName
)
;
static
KeyNameIndex
GetKeyNameIndex
(
const
nsAString
&
aKeyValue
)
;
static
CodeNameIndex
GetCodeNameIndex
(
const
nsAString
&
aCodeValue
)
;
static
const
char
*
GetCommandStr
(
Command
aCommand
)
;
void
AssignKeyEventData
(
const
WidgetKeyboardEvent
&
aEvent
bool
aCopyTargets
)
{
AssignInputEventData
(
aEvent
aCopyTargets
)
;
mKeyCode
=
aEvent
.
mKeyCode
;
mCharCode
=
aEvent
.
mCharCode
;
mPseudoCharCode
=
aEvent
.
mPseudoCharCode
;
mLocation
=
aEvent
.
mLocation
;
mAlternativeCharCodes
=
aEvent
.
mAlternativeCharCodes
;
mIsRepeat
=
aEvent
.
mIsRepeat
;
mIsComposing
=
aEvent
.
mIsComposing
;
mKeyNameIndex
=
aEvent
.
mKeyNameIndex
;
mCodeNameIndex
=
aEvent
.
mCodeNameIndex
;
mKeyValue
=
aEvent
.
mKeyValue
;
mCodeValue
=
aEvent
.
mCodeValue
;
mNativeKeyEvent
=
nullptr
;
mUniqueId
=
aEvent
.
mUniqueId
;
#
ifdef
XP_MACOSX
mNativeKeyCode
=
aEvent
.
mNativeKeyCode
;
mNativeModifierFlags
=
aEvent
.
mNativeModifierFlags
;
mNativeCharacters
.
Assign
(
aEvent
.
mNativeCharacters
)
;
mNativeCharactersIgnoringModifiers
.
Assign
(
aEvent
.
mNativeCharactersIgnoringModifiers
)
;
mPluginTextEventString
.
Assign
(
aEvent
.
mPluginTextEventString
)
;
#
endif
mIsSynthesizedByTIP
=
aEvent
.
mIsSynthesizedByTIP
;
mMaybeSkippableInRemoteProcess
=
aEvent
.
mMaybeSkippableInRemoteProcess
;
mUseLegacyKeyCodeAndCharCodeValues
=
aEvent
.
mUseLegacyKeyCodeAndCharCodeValues
;
mEditCommandsForSingleLineEditorInitialized
=
aEvent
.
mEditCommandsForSingleLineEditorInitialized
;
mEditCommandsForMultiLineEditorInitialized
=
aEvent
.
mEditCommandsForMultiLineEditorInitialized
;
mEditCommandsForRichTextEditorInitialized
=
aEvent
.
mEditCommandsForRichTextEditorInitialized
;
}
void
AssignCommands
(
const
WidgetKeyboardEvent
&
aEvent
)
{
mEditCommandsForSingleLineEditorInitialized
=
aEvent
.
mEditCommandsForSingleLineEditorInitialized
;
if
(
mEditCommandsForSingleLineEditorInitialized
)
{
mEditCommandsForSingleLineEditor
=
aEvent
.
mEditCommandsForSingleLineEditor
;
}
else
{
mEditCommandsForSingleLineEditor
.
Clear
(
)
;
}
mEditCommandsForMultiLineEditorInitialized
=
aEvent
.
mEditCommandsForMultiLineEditorInitialized
;
if
(
mEditCommandsForMultiLineEditorInitialized
)
{
mEditCommandsForMultiLineEditor
=
aEvent
.
mEditCommandsForMultiLineEditor
;
}
else
{
mEditCommandsForMultiLineEditor
.
Clear
(
)
;
}
mEditCommandsForRichTextEditorInitialized
=
aEvent
.
mEditCommandsForRichTextEditorInitialized
;
if
(
mEditCommandsForRichTextEditorInitialized
)
{
mEditCommandsForRichTextEditor
=
aEvent
.
mEditCommandsForRichTextEditor
;
}
else
{
mEditCommandsForRichTextEditor
.
Clear
(
)
;
}
}
private
:
static
const
char16_t
*
const
kKeyNames
[
]
;
static
const
char16_t
*
const
kCodeNames
[
]
;
typedef
nsDataHashtable
<
nsStringHashKey
KeyNameIndex
>
KeyNameIndexHashtable
;
typedef
nsDataHashtable
<
nsStringHashKey
CodeNameIndex
>
CodeNameIndexHashtable
;
static
KeyNameIndexHashtable
*
sKeyNameIndexHashtable
;
static
CodeNameIndexHashtable
*
sCodeNameIndexHashtable
;
nsTArray
<
CommandInt
>
mEditCommandsForSingleLineEditor
;
nsTArray
<
CommandInt
>
mEditCommandsForMultiLineEditor
;
nsTArray
<
CommandInt
>
mEditCommandsForRichTextEditor
;
nsTArray
<
CommandInt
>
&
EditCommandsRef
(
nsIWidget
:
:
NativeKeyBindingsType
aType
)
{
switch
(
aType
)
{
case
nsIWidget
:
:
NativeKeyBindingsForSingleLineEditor
:
return
mEditCommandsForSingleLineEditor
;
case
nsIWidget
:
:
NativeKeyBindingsForMultiLineEditor
:
return
mEditCommandsForMultiLineEditor
;
case
nsIWidget
:
:
NativeKeyBindingsForRichTextEditor
:
return
mEditCommandsForRichTextEditor
;
default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Invalid
native
key
binding
type
"
)
;
}
}
bool
mEditCommandsForSingleLineEditorInitialized
;
bool
mEditCommandsForMultiLineEditorInitialized
;
bool
mEditCommandsForRichTextEditorInitialized
;
bool
&
IsEditCommandsInitializedRef
(
nsIWidget
:
:
NativeKeyBindingsType
aType
)
{
switch
(
aType
)
{
case
nsIWidget
:
:
NativeKeyBindingsForSingleLineEditor
:
return
mEditCommandsForSingleLineEditorInitialized
;
case
nsIWidget
:
:
NativeKeyBindingsForMultiLineEditor
:
return
mEditCommandsForMultiLineEditorInitialized
;
case
nsIWidget
:
:
NativeKeyBindingsForRichTextEditor
:
return
mEditCommandsForRichTextEditorInitialized
;
default
:
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Invalid
native
key
binding
type
"
)
;
}
}
static
int32_t
GenericAccessModifierKeyPref
(
)
;
static
int32_t
ChromeAccessModifierMaskPref
(
)
;
static
int32_t
ContentAccessModifierMaskPref
(
)
;
}
;
class
WidgetCompositionEvent
:
public
WidgetGUIEvent
{
private
:
friend
class
mozilla
:
:
dom
:
:
PBrowserParent
;
friend
class
mozilla
:
:
dom
:
:
PBrowserChild
;
WidgetCompositionEvent
(
)
:
mOriginalMessage
(
eVoidEvent
)
{
}
public
:
virtual
WidgetCompositionEvent
*
AsCompositionEvent
(
)
override
{
return
this
;
}
WidgetCompositionEvent
(
bool
aIsTrusted
EventMessage
aMessage
nsIWidget
*
aWidget
)
:
WidgetGUIEvent
(
aIsTrusted
aMessage
aWidget
eCompositionEventClass
)
mNativeIMEContext
(
aWidget
)
mOriginalMessage
(
eVoidEvent
)
{
}
virtual
WidgetEvent
*
Duplicate
(
)
const
override
{
MOZ_ASSERT
(
mClass
=
=
eCompositionEventClass
"
Duplicate
(
)
must
be
overridden
by
sub
class
"
)
;
WidgetCompositionEvent
*
result
=
new
WidgetCompositionEvent
(
false
mMessage
nullptr
)
;
result
-
>
AssignCompositionEventData
(
*
this
true
)
;
result
-
>
mFlags
=
mFlags
;
return
result
;
}
nsString
mData
;
RefPtr
<
TextRangeArray
>
mRanges
;
widget
:
:
NativeIMEContext
mNativeIMEContext
;
EventMessage
mOriginalMessage
;
void
AssignCompositionEventData
(
const
WidgetCompositionEvent
&
aEvent
bool
aCopyTargets
)
{
AssignGUIEventData
(
aEvent
aCopyTargets
)
;
mData
=
aEvent
.
mData
;
mOriginalMessage
=
aEvent
.
mOriginalMessage
;
mRanges
=
aEvent
.
mRanges
;
}
bool
IsComposing
(
)
const
{
return
mRanges
&
&
mRanges
-
>
IsComposing
(
)
;
}
uint32_t
TargetClauseOffset
(
)
const
{
return
mRanges
?
mRanges
-
>
TargetClauseOffset
(
)
:
0
;
}
uint32_t
TargetClauseLength
(
)
const
{
uint32_t
length
=
UINT32_MAX
;
if
(
mRanges
)
{
length
=
mRanges
-
>
TargetClauseLength
(
)
;
}
return
length
=
=
UINT32_MAX
?
mData
.
Length
(
)
:
length
;
}
uint32_t
RangeCount
(
)
const
{
return
mRanges
?
mRanges
-
>
Length
(
)
:
0
;
}
bool
CausesDOMTextEvent
(
)
const
{
return
mMessage
=
=
eCompositionChange
|
|
mMessage
=
=
eCompositionCommit
|
|
mMessage
=
=
eCompositionCommitAsIs
;
}
bool
CausesDOMCompositionEndEvent
(
)
const
{
return
mMessage
=
=
eCompositionEnd
|
|
mMessage
=
=
eCompositionCommit
|
|
mMessage
=
=
eCompositionCommitAsIs
;
}
bool
IsFollowedByCompositionEnd
(
)
const
{
return
IsFollowedByCompositionEnd
(
mOriginalMessage
)
;
}
static
bool
IsFollowedByCompositionEnd
(
EventMessage
aEventMessage
)
{
return
aEventMessage
=
=
eCompositionCommit
|
|
aEventMessage
=
=
eCompositionCommitAsIs
;
}
}
;
class
WidgetQueryContentEvent
:
public
WidgetGUIEvent
{
private
:
friend
class
dom
:
:
PBrowserParent
;
friend
class
dom
:
:
PBrowserChild
;
WidgetQueryContentEvent
(
)
:
mSucceeded
(
false
)
mUseNativeLineBreak
(
true
)
mWithFontRanges
(
false
)
mNeedsToFlushLayout
(
true
)
{
MOZ_CRASH
(
"
WidgetQueryContentEvent
is
created
without
proper
arguments
"
)
;
}
public
:
virtual
WidgetQueryContentEvent
*
AsQueryContentEvent
(
)
override
{
return
this
;
}
WidgetQueryContentEvent
(
bool
aIsTrusted
EventMessage
aMessage
nsIWidget
*
aWidget
)
:
WidgetGUIEvent
(
aIsTrusted
aMessage
aWidget
eQueryContentEventClass
)
mSucceeded
(
false
)
mUseNativeLineBreak
(
true
)
mWithFontRanges
(
false
)
mNeedsToFlushLayout
(
true
)
{
}
WidgetQueryContentEvent
(
EventMessage
aMessage
const
WidgetQueryContentEvent
&
aOtherEvent
)
:
WidgetGUIEvent
(
aOtherEvent
.
IsTrusted
(
)
aMessage
const_cast
<
nsIWidget
*
>
(
aOtherEvent
.
mWidget
.
get
(
)
)
eQueryContentEventClass
)
mSucceeded
(
false
)
mUseNativeLineBreak
(
aOtherEvent
.
mUseNativeLineBreak
)
mWithFontRanges
(
false
)
mNeedsToFlushLayout
(
aOtherEvent
.
mNeedsToFlushLayout
)
{
}
virtual
WidgetEvent
*
Duplicate
(
)
const
override
{
NS_ASSERTION
(
!
IsAllowedToDispatchDOMEvent
(
)
"
WidgetQueryContentEvent
needs
to
support
Duplicate
(
)
"
)
;
MOZ_CRASH
(
"
WidgetQueryContentEvent
doesn
'
t
support
Duplicate
(
)
"
)
;
}
struct
Options
final
{
bool
mUseNativeLineBreak
;
bool
mRelativeToInsertionPoint
;
explicit
Options
(
)
:
mUseNativeLineBreak
(
true
)
mRelativeToInsertionPoint
(
false
)
{
}
explicit
Options
(
const
WidgetQueryContentEvent
&
aEvent
)
:
mUseNativeLineBreak
(
aEvent
.
mUseNativeLineBreak
)
mRelativeToInsertionPoint
(
aEvent
.
mInput
.
mRelativeToInsertionPoint
)
{
}
}
;
void
Init
(
const
Options
&
aOptions
)
{
mUseNativeLineBreak
=
aOptions
.
mUseNativeLineBreak
;
mInput
.
mRelativeToInsertionPoint
=
aOptions
.
mRelativeToInsertionPoint
;
MOZ_ASSERT
(
mInput
.
IsValidEventMessage
(
mMessage
)
)
;
}
void
InitForQueryTextContent
(
int64_t
aOffset
uint32_t
aLength
const
Options
&
aOptions
=
Options
(
)
)
{
NS_ASSERTION
(
mMessage
=
=
eQueryTextContent
"
wrong
initializer
is
called
"
)
;
mInput
.
mOffset
=
aOffset
;
mInput
.
mLength
=
aLength
;
Init
(
aOptions
)
;
MOZ_ASSERT
(
mInput
.
IsValidOffset
(
)
)
;
}
void
InitForQueryCaretRect
(
int64_t
aOffset
const
Options
&
aOptions
=
Options
(
)
)
{
NS_ASSERTION
(
mMessage
=
=
eQueryCaretRect
"
wrong
initializer
is
called
"
)
;
mInput
.
mOffset
=
aOffset
;
Init
(
aOptions
)
;
MOZ_ASSERT
(
mInput
.
IsValidOffset
(
)
)
;
}
void
InitForQueryTextRect
(
int64_t
aOffset
uint32_t
aLength
const
Options
&
aOptions
=
Options
(
)
)
{
NS_ASSERTION
(
mMessage
=
=
eQueryTextRect
"
wrong
initializer
is
called
"
)
;
mInput
.
mOffset
=
aOffset
;
mInput
.
mLength
=
aLength
;
Init
(
aOptions
)
;
MOZ_ASSERT
(
mInput
.
IsValidOffset
(
)
)
;
}
void
InitForQuerySelectedText
(
SelectionType
aSelectionType
const
Options
&
aOptions
=
Options
(
)
)
{
MOZ_ASSERT
(
mMessage
=
=
eQuerySelectedText
)
;
MOZ_ASSERT
(
aSelectionType
!
=
SelectionType
:
:
eNone
)
;
mInput
.
mSelectionType
=
aSelectionType
;
Init
(
aOptions
)
;
}
void
InitForQueryDOMWidgetHittest
(
const
mozilla
:
:
LayoutDeviceIntPoint
&
aPoint
)
{
NS_ASSERTION
(
mMessage
=
=
eQueryDOMWidgetHittest
"
wrong
initializer
is
called
"
)
;
mRefPoint
=
aPoint
;
}
void
InitForQueryTextRectArray
(
uint32_t
aOffset
uint32_t
aLength
const
Options
&
aOptions
=
Options
(
)
)
{
NS_ASSERTION
(
mMessage
=
=
eQueryTextRectArray
"
wrong
initializer
is
called
"
)
;
mInput
.
mOffset
=
aOffset
;
mInput
.
mLength
=
aLength
;
Init
(
aOptions
)
;
}
bool
NeedsToFlushLayout
(
)
const
{
#
ifdef
XP_MACOSX
return
true
;
#
else
return
mNeedsToFlushLayout
;
#
endif
}
void
RequestFontRanges
(
)
{
NS_ASSERTION
(
mMessage
=
=
eQueryTextContent
"
not
querying
text
content
"
)
;
mWithFontRanges
=
true
;
}
uint32_t
GetSelectionStart
(
void
)
const
{
NS_ASSERTION
(
mMessage
=
=
eQuerySelectedText
"
not
querying
selection
"
)
;
return
mReply
.
mOffset
+
(
mReply
.
mReversed
?
mReply
.
mString
.
Length
(
)
:
0
)
;
}
uint32_t
GetSelectionEnd
(
void
)
const
{
NS_ASSERTION
(
mMessage
=
=
eQuerySelectedText
"
not
querying
selection
"
)
;
return
mReply
.
mOffset
+
(
mReply
.
mReversed
?
0
:
mReply
.
mString
.
Length
(
)
)
;
}
mozilla
:
:
WritingMode
GetWritingMode
(
void
)
const
{
NS_ASSERTION
(
mMessage
=
=
eQuerySelectedText
|
|
mMessage
=
=
eQueryCaretRect
|
|
mMessage
=
=
eQueryTextRect
"
not
querying
selection
or
text
rect
"
)
;
return
mReply
.
mWritingMode
;
}
bool
mSucceeded
;
bool
mUseNativeLineBreak
;
bool
mWithFontRanges
;
bool
mNeedsToFlushLayout
;
struct
Input
final
{
uint32_t
EndOffset
(
)
const
{
CheckedInt
<
uint32_t
>
endOffset
=
CheckedInt
<
uint32_t
>
(
mOffset
)
+
mLength
;
return
NS_WARN_IF
(
!
endOffset
.
isValid
(
)
)
?
UINT32_MAX
:
endOffset
.
value
(
)
;
}
int64_t
mOffset
;
uint32_t
mLength
;
SelectionType
mSelectionType
;
bool
mRelativeToInsertionPoint
;
Input
(
)
:
mOffset
(
0
)
mLength
(
0
)
mSelectionType
(
SelectionType
:
:
eNormal
)
mRelativeToInsertionPoint
(
false
)
{
}
bool
IsValidOffset
(
)
const
{
return
mRelativeToInsertionPoint
|
|
mOffset
>
=
0
;
}
bool
IsValidEventMessage
(
EventMessage
aEventMessage
)
const
{
if
(
!
mRelativeToInsertionPoint
)
{
return
true
;
}
switch
(
aEventMessage
)
{
case
eQueryTextContent
:
case
eQueryCaretRect
:
case
eQueryTextRect
:
return
true
;
default
:
return
false
;
}
}
bool
MakeOffsetAbsolute
(
uint32_t
aInsertionPointOffset
)
{
if
(
NS_WARN_IF
(
!
mRelativeToInsertionPoint
)
)
{
return
true
;
}
mRelativeToInsertionPoint
=
false
;
if
(
mOffset
<
0
&
&
-
mOffset
>
aInsertionPointOffset
)
{
mOffset
=
0
;
return
true
;
}
CheckedInt
<
uint32_t
>
absOffset
=
mOffset
+
aInsertionPointOffset
;
if
(
NS_WARN_IF
(
!
absOffset
.
isValid
(
)
)
)
{
mOffset
=
UINT32_MAX
;
return
false
;
}
mOffset
=
absOffset
.
value
(
)
;
return
true
;
}
}
mInput
;
struct
Reply
final
{
void
*
mContentsRoot
;
uint32_t
mOffset
;
uint32_t
mTentativeCaretOffset
;
nsString
mString
;
mozilla
:
:
LayoutDeviceIntRect
mRect
;
nsIWidget
*
mFocusedWidget
;
mozilla
:
:
WritingMode
mWritingMode
;
nsCOMPtr
<
nsITransferable
>
mTransferable
;
AutoTArray
<
mozilla
:
:
FontRange
1
>
mFontRanges
;
nsTArray
<
mozilla
:
:
LayoutDeviceIntRect
>
mRectArray
;
bool
mReversed
;
bool
mHasSelection
;
bool
mWidgetIsHit
;
Reply
(
)
:
mContentsRoot
(
nullptr
)
mOffset
(
NOT_FOUND
)
mTentativeCaretOffset
(
NOT_FOUND
)
mFocusedWidget
(
nullptr
)
mReversed
(
false
)
mHasSelection
(
false
)
mWidgetIsHit
(
false
)
{
}
}
mReply
;
enum
{
NOT_FOUND
=
UINT32_MAX
}
;
enum
{
SCROLL_ACTION_NONE
SCROLL_ACTION_LINE
SCROLL_ACTION_PAGE
}
;
}
;
class
WidgetSelectionEvent
:
public
WidgetGUIEvent
{
private
:
friend
class
mozilla
:
:
dom
:
:
PBrowserParent
;
friend
class
mozilla
:
:
dom
:
:
PBrowserChild
;
WidgetSelectionEvent
(
)
:
mOffset
(
0
)
mLength
(
0
)
mReversed
(
false
)
mExpandToClusterBoundary
(
true
)
mSucceeded
(
false
)
mUseNativeLineBreak
(
true
)
mReason
(
nsISelectionListener
:
:
NO_REASON
)
{
}
public
:
virtual
WidgetSelectionEvent
*
AsSelectionEvent
(
)
override
{
return
this
;
}
WidgetSelectionEvent
(
bool
aIsTrusted
EventMessage
aMessage
nsIWidget
*
aWidget
)
:
WidgetGUIEvent
(
aIsTrusted
aMessage
aWidget
eSelectionEventClass
)
mOffset
(
0
)
mLength
(
0
)
mReversed
(
false
)
mExpandToClusterBoundary
(
true
)
mSucceeded
(
false
)
mUseNativeLineBreak
(
true
)
mReason
(
nsISelectionListener
:
:
NO_REASON
)
{
}
virtual
WidgetEvent
*
Duplicate
(
)
const
override
{
NS_ASSERTION
(
!
IsAllowedToDispatchDOMEvent
(
)
"
WidgetSelectionEvent
needs
to
support
Duplicate
(
)
"
)
;
MOZ_CRASH
(
"
WidgetSelectionEvent
doesn
'
t
support
Duplicate
(
)
"
)
;
return
nullptr
;
}
uint32_t
mOffset
;
uint32_t
mLength
;
bool
mReversed
;
bool
mExpandToClusterBoundary
;
bool
mSucceeded
;
bool
mUseNativeLineBreak
;
int16_t
mReason
;
}
;
class
InternalEditorInputEvent
:
public
InternalUIEvent
{
private
:
InternalEditorInputEvent
(
)
:
mData
(
VoidString
(
)
)
mInputType
(
EditorInputType
:
:
eUnknown
)
mIsComposing
(
false
)
{
}
public
:
virtual
InternalEditorInputEvent
*
AsEditorInputEvent
(
)
override
{
return
this
;
}
InternalEditorInputEvent
(
bool
aIsTrusted
EventMessage
aMessage
nsIWidget
*
aWidget
=
nullptr
)
:
InternalUIEvent
(
aIsTrusted
aMessage
aWidget
eEditorInputEventClass
)
mData
(
VoidString
(
)
)
mInputType
(
EditorInputType
:
:
eUnknown
)
{
}
virtual
WidgetEvent
*
Duplicate
(
)
const
override
{
MOZ_ASSERT
(
mClass
=
=
eEditorInputEventClass
"
Duplicate
(
)
must
be
overridden
by
sub
class
"
)
;
InternalEditorInputEvent
*
result
=
new
InternalEditorInputEvent
(
false
mMessage
nullptr
)
;
result
-
>
AssignEditorInputEventData
(
*
this
true
)
;
result
-
>
mFlags
=
mFlags
;
return
result
;
}
nsString
mData
;
RefPtr
<
dom
:
:
DataTransfer
>
mDataTransfer
;
EditorInputType
mInputType
;
bool
mIsComposing
;
void
AssignEditorInputEventData
(
const
InternalEditorInputEvent
&
aEvent
bool
aCopyTargets
)
{
AssignUIEventData
(
aEvent
aCopyTargets
)
;
mData
=
aEvent
.
mData
;
mDataTransfer
=
aEvent
.
mDataTransfer
;
mInputType
=
aEvent
.
mInputType
;
mIsComposing
=
aEvent
.
mIsComposing
;
}
void
GetDOMInputTypeName
(
nsAString
&
aInputTypeName
)
{
GetDOMInputTypeName
(
mInputType
aInputTypeName
)
;
}
static
void
GetDOMInputTypeName
(
EditorInputType
aInputType
nsAString
&
aInputTypeName
)
;
static
EditorInputType
GetEditorInputType
(
const
nsAString
&
aInputType
)
;
static
void
Shutdown
(
)
;
private
:
static
const
char16_t
*
const
kInputTypeNames
[
]
;
typedef
nsDataHashtable
<
nsStringHashKey
EditorInputType
>
InputTypeHashtable
;
static
InputTypeHashtable
*
sInputTypeHashtable
;
}
;
}
#
endif
