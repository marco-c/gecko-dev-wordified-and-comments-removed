#
include
"
nsTransferable
.
h
"
#
include
"
nsAnonymousTemporaryFile
.
h
"
#
include
"
nsArray
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIFormatConverter
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsPrimitiveHelpers
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsDirectoryService
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
NS_IMPL_ISUPPORTS
(
nsTransferable
nsITransferable
)
size_t
GetDataForFlavor
(
const
nsTArray
<
DataStruct
>
&
aArray
const
char
*
aDataFlavor
)
{
for
(
size_t
i
=
0
;
i
<
aArray
.
Length
(
)
;
+
+
i
)
{
if
(
aArray
[
i
]
.
GetFlavor
(
)
.
Equals
(
aDataFlavor
)
)
return
i
;
}
return
aArray
.
NoIndex
;
}
DataStruct
:
:
DataStruct
(
DataStruct
&
&
aRHS
)
:
mData
(
aRHS
.
mData
.
forget
(
)
)
mDataLen
(
aRHS
.
mDataLen
)
mCacheFD
(
aRHS
.
mCacheFD
)
mFlavor
(
aRHS
.
mFlavor
)
{
aRHS
.
mCacheFD
=
nullptr
;
}
DataStruct
:
:
~
DataStruct
(
)
{
if
(
mCacheFD
)
{
PR_Close
(
mCacheFD
)
;
}
}
void
DataStruct
:
:
SetData
(
nsISupports
*
aData
uint32_t
aDataLen
bool
aIsPrivateData
)
{
if
(
aDataLen
>
kLargeDatasetSize
&
&
!
aIsPrivateData
)
{
if
(
NS_SUCCEEDED
(
WriteCache
(
aData
aDataLen
)
)
)
{
mData
=
nullptr
;
mDataLen
=
0
;
return
;
}
NS_WARNING
(
"
Oh
no
couldn
'
t
write
data
to
the
cache
file
"
)
;
}
if
(
mCacheFD
)
{
PR_Close
(
mCacheFD
)
;
mCacheFD
=
nullptr
;
}
mData
=
aData
;
mDataLen
=
aDataLen
;
}
void
DataStruct
:
:
GetData
(
nsISupports
*
*
aData
uint32_t
*
aDataLen
)
{
if
(
mCacheFD
)
{
if
(
NS_SUCCEEDED
(
ReadCache
(
aData
aDataLen
)
)
)
return
;
else
{
NS_WARNING
(
"
Oh
no
couldn
'
t
read
data
in
from
the
cache
file
"
)
;
*
aData
=
nullptr
;
*
aDataLen
=
0
;
PR_Close
(
mCacheFD
)
;
mCacheFD
=
nullptr
;
return
;
}
}
*
aData
=
mData
;
if
(
mData
)
NS_ADDREF
(
*
aData
)
;
*
aDataLen
=
mDataLen
;
}
nsresult
DataStruct
:
:
WriteCache
(
nsISupports
*
aData
uint32_t
aDataLen
)
{
nsresult
rv
;
if
(
!
mCacheFD
)
{
rv
=
NS_OpenAnonymousTemporaryFile
(
&
mCacheFD
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
if
(
PR_Seek64
(
mCacheFD
0
PR_SEEK_SET
)
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
void
*
buff
=
nullptr
;
nsPrimitiveHelpers
:
:
CreateDataFromPrimitive
(
mFlavor
aData
&
buff
aDataLen
)
;
if
(
buff
)
{
int32_t
written
=
PR_Write
(
mCacheFD
buff
aDataLen
)
;
free
(
buff
)
;
if
(
written
)
{
return
NS_OK
;
}
}
PR_Close
(
mCacheFD
)
;
mCacheFD
=
nullptr
;
return
NS_ERROR_FAILURE
;
}
nsresult
DataStruct
:
:
ReadCache
(
nsISupports
*
*
aData
uint32_t
*
aDataLen
)
{
if
(
!
mCacheFD
)
{
return
NS_ERROR_FAILURE
;
}
PRFileInfo
fileInfo
;
if
(
PR_GetOpenFileInfo
(
mCacheFD
&
fileInfo
)
!
=
PR_SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
if
(
PR_Seek64
(
mCacheFD
0
PR_SEEK_SET
)
=
=
-
1
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
fileSize
=
fileInfo
.
size
;
auto
data
=
mozilla
:
:
MakeUnique
<
char
[
]
>
(
fileSize
)
;
if
(
!
data
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint32_t
actual
=
PR_Read
(
mCacheFD
data
.
get
(
)
fileSize
)
;
if
(
actual
!
=
fileSize
)
{
return
NS_ERROR_FAILURE
;
}
nsPrimitiveHelpers
:
:
CreatePrimitiveForData
(
mFlavor
data
.
get
(
)
fileSize
aData
)
;
*
aDataLen
=
fileSize
;
return
NS_OK
;
}
nsTransferable
:
:
nsTransferable
(
)
:
mPrivateData
(
false
)
mContentPolicyType
(
nsIContentPolicy
:
:
TYPE_OTHER
)
#
ifdef
DEBUG
mInitialized
(
false
)
#
endif
{
}
nsTransferable
:
:
~
nsTransferable
(
)
{
}
NS_IMETHODIMP
nsTransferable
:
:
Init
(
nsILoadContext
*
aContext
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
if
(
aContext
)
{
mPrivateData
=
aContext
-
>
UsePrivateBrowsing
(
)
;
}
#
ifdef
DEBUG
mInitialized
=
true
;
#
endif
return
NS_OK
;
}
already_AddRefed
<
nsIMutableArray
>
nsTransferable
:
:
GetTransferDataFlavors
(
)
{
MOZ_ASSERT
(
mInitialized
)
;
nsCOMPtr
<
nsIMutableArray
>
array
=
nsArray
:
:
Create
(
)
;
for
(
size_t
i
=
0
;
i
<
mDataArray
.
Length
(
)
;
+
+
i
)
{
DataStruct
&
data
=
mDataArray
.
ElementAt
(
i
)
;
nsCOMPtr
<
nsISupportsCString
>
flavorWrapper
=
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
;
if
(
flavorWrapper
)
{
flavorWrapper
-
>
SetData
(
data
.
GetFlavor
(
)
)
;
nsCOMPtr
<
nsISupports
>
genericWrapper
(
do_QueryInterface
(
flavorWrapper
)
)
;
array
-
>
AppendElement
(
genericWrapper
)
;
}
}
return
array
.
forget
(
)
;
}
NS_IMETHODIMP
nsTransferable
:
:
GetTransferData
(
const
char
*
aFlavor
nsISupports
*
*
aData
uint32_t
*
aDataLen
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
aFlavor
&
&
aData
&
&
aDataLen
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsISupports
>
savedData
;
for
(
size_t
i
=
0
;
i
<
mDataArray
.
Length
(
)
;
+
+
i
)
{
DataStruct
&
data
=
mDataArray
.
ElementAt
(
i
)
;
if
(
data
.
GetFlavor
(
)
.
Equals
(
aFlavor
)
)
{
nsCOMPtr
<
nsISupports
>
dataBytes
;
uint32_t
len
;
data
.
GetData
(
getter_AddRefs
(
dataBytes
)
&
len
)
;
if
(
len
=
=
kFlavorHasDataProvider
&
&
dataBytes
)
{
nsCOMPtr
<
nsIFlavorDataProvider
>
dataProvider
=
do_QueryInterface
(
dataBytes
)
;
if
(
dataProvider
)
{
rv
=
dataProvider
-
>
GetFlavorData
(
this
aFlavor
getter_AddRefs
(
dataBytes
)
&
len
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
}
}
if
(
dataBytes
&
&
len
>
0
)
{
*
aDataLen
=
len
;
dataBytes
.
forget
(
aData
)
;
return
NS_OK
;
}
savedData
=
dataBytes
;
break
;
}
}
bool
found
=
false
;
if
(
mFormatConv
)
{
for
(
size_t
i
=
0
;
i
<
mDataArray
.
Length
(
)
;
+
+
i
)
{
DataStruct
&
data
=
mDataArray
.
ElementAt
(
i
)
;
bool
canConvert
=
false
;
mFormatConv
-
>
CanConvert
(
data
.
GetFlavor
(
)
.
get
(
)
aFlavor
&
canConvert
)
;
if
(
canConvert
)
{
nsCOMPtr
<
nsISupports
>
dataBytes
;
uint32_t
len
;
data
.
GetData
(
getter_AddRefs
(
dataBytes
)
&
len
)
;
if
(
len
=
=
kFlavorHasDataProvider
&
&
dataBytes
)
{
nsCOMPtr
<
nsIFlavorDataProvider
>
dataProvider
=
do_QueryInterface
(
dataBytes
)
;
if
(
dataProvider
)
{
rv
=
dataProvider
-
>
GetFlavorData
(
this
aFlavor
getter_AddRefs
(
dataBytes
)
&
len
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
}
}
mFormatConv
-
>
Convert
(
data
.
GetFlavor
(
)
.
get
(
)
dataBytes
len
aFlavor
aData
aDataLen
)
;
found
=
true
;
break
;
}
}
}
if
(
!
found
)
{
savedData
.
forget
(
aData
)
;
*
aDataLen
=
0
;
}
return
found
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTransferable
:
:
GetAnyTransferData
(
nsACString
&
aFlavor
nsISupports
*
*
aData
uint32_t
*
aDataLen
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
aData
&
&
aDataLen
)
;
for
(
size_t
i
=
0
;
i
<
mDataArray
.
Length
(
)
;
+
+
i
)
{
DataStruct
&
data
=
mDataArray
.
ElementAt
(
i
)
;
if
(
data
.
IsDataAvailable
(
)
)
{
aFlavor
.
Assign
(
data
.
GetFlavor
(
)
)
;
data
.
GetData
(
aData
aDataLen
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTransferable
:
:
SetTransferData
(
const
char
*
aFlavor
nsISupports
*
aData
uint32_t
aDataLen
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG
(
aFlavor
)
;
for
(
size_t
i
=
0
;
i
<
mDataArray
.
Length
(
)
;
+
+
i
)
{
DataStruct
&
data
=
mDataArray
.
ElementAt
(
i
)
;
if
(
data
.
GetFlavor
(
)
.
Equals
(
aFlavor
)
)
{
data
.
SetData
(
aData
aDataLen
mPrivateData
)
;
return
NS_OK
;
}
}
if
(
mFormatConv
)
{
for
(
size_t
i
=
0
;
i
<
mDataArray
.
Length
(
)
;
+
+
i
)
{
DataStruct
&
data
=
mDataArray
.
ElementAt
(
i
)
;
bool
canConvert
=
false
;
mFormatConv
-
>
CanConvert
(
aFlavor
data
.
GetFlavor
(
)
.
get
(
)
&
canConvert
)
;
if
(
canConvert
)
{
nsCOMPtr
<
nsISupports
>
ConvertedData
;
uint32_t
ConvertedLen
;
mFormatConv
-
>
Convert
(
aFlavor
aData
aDataLen
data
.
GetFlavor
(
)
.
get
(
)
getter_AddRefs
(
ConvertedData
)
&
ConvertedLen
)
;
data
.
SetData
(
ConvertedData
ConvertedLen
mPrivateData
)
;
return
NS_OK
;
}
}
}
nsresult
result
=
NS_ERROR_FAILURE
;
if
(
NS_SUCCEEDED
(
AddDataFlavor
(
aFlavor
)
)
)
result
=
SetTransferData
(
aFlavor
aData
aDataLen
)
;
return
result
;
}
NS_IMETHODIMP
nsTransferable
:
:
AddDataFlavor
(
const
char
*
aDataFlavor
)
{
MOZ_ASSERT
(
mInitialized
)
;
if
(
GetDataForFlavor
(
mDataArray
aDataFlavor
)
!
=
mDataArray
.
NoIndex
)
return
NS_ERROR_FAILURE
;
mDataArray
.
AppendElement
(
DataStruct
(
aDataFlavor
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
RemoveDataFlavor
(
const
char
*
aDataFlavor
)
{
MOZ_ASSERT
(
mInitialized
)
;
size_t
idx
=
GetDataForFlavor
(
mDataArray
aDataFlavor
)
;
if
(
idx
!
=
mDataArray
.
NoIndex
)
{
mDataArray
.
RemoveElementAt
(
idx
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTransferable
:
:
IsLargeDataSet
(
bool
*
_retval
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
_retval
)
;
*
_retval
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
SetConverter
(
nsIFormatConverter
*
aConverter
)
{
MOZ_ASSERT
(
mInitialized
)
;
mFormatConv
=
aConverter
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
GetConverter
(
nsIFormatConverter
*
*
aConverter
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
aConverter
)
;
*
aConverter
=
mFormatConv
;
NS_IF_ADDREF
(
*
aConverter
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
FlavorsTransferableCanImport
(
nsIArray
*
*
_retval
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsCOMPtr
<
nsIMutableArray
>
array
=
GetTransferDataFlavors
(
)
;
nsCOMPtr
<
nsIFormatConverter
>
converter
;
GetConverter
(
getter_AddRefs
(
converter
)
)
;
if
(
converter
)
{
nsCOMPtr
<
nsIArray
>
convertedList
;
converter
-
>
GetInputDataFlavors
(
getter_AddRefs
(
convertedList
)
)
;
if
(
convertedList
)
{
uint32_t
importListLen
;
convertedList
-
>
GetLength
(
&
importListLen
)
;
for
(
uint32_t
i
=
0
;
i
<
importListLen
;
+
+
i
)
{
nsCOMPtr
<
nsISupportsCString
>
flavorWrapper
=
do_QueryElementAt
(
convertedList
i
)
;
nsAutoCString
flavorStr
;
flavorWrapper
-
>
GetData
(
flavorStr
)
;
if
(
GetDataForFlavor
(
mDataArray
flavorStr
.
get
(
)
)
=
=
mDataArray
.
NoIndex
)
array
-
>
AppendElement
(
flavorWrapper
)
;
}
}
}
array
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
FlavorsTransferableCanExport
(
nsIArray
*
*
_retval
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
_retval
)
;
nsCOMPtr
<
nsIMutableArray
>
array
=
GetTransferDataFlavors
(
)
;
nsCOMPtr
<
nsIFormatConverter
>
converter
;
GetConverter
(
getter_AddRefs
(
converter
)
)
;
if
(
converter
)
{
nsCOMPtr
<
nsIArray
>
convertedList
;
converter
-
>
GetOutputDataFlavors
(
getter_AddRefs
(
convertedList
)
)
;
if
(
convertedList
)
{
uint32_t
importListLen
;
convertedList
-
>
GetLength
(
&
importListLen
)
;
for
(
uint32_t
i
=
0
;
i
<
importListLen
;
+
+
i
)
{
nsCOMPtr
<
nsISupportsCString
>
flavorWrapper
=
do_QueryElementAt
(
convertedList
i
)
;
nsAutoCString
flavorStr
;
flavorWrapper
-
>
GetData
(
flavorStr
)
;
if
(
GetDataForFlavor
(
mDataArray
flavorStr
.
get
(
)
)
=
=
mDataArray
.
NoIndex
)
array
-
>
AppendElement
(
flavorWrapper
)
;
}
}
}
array
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
GetIsPrivateData
(
bool
*
aIsPrivateData
)
{
MOZ_ASSERT
(
mInitialized
)
;
NS_ENSURE_ARG_POINTER
(
aIsPrivateData
)
;
*
aIsPrivateData
=
mPrivateData
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
SetIsPrivateData
(
bool
aIsPrivateData
)
{
MOZ_ASSERT
(
mInitialized
)
;
mPrivateData
=
aIsPrivateData
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
GetRequestingPrincipal
(
nsIPrincipal
*
*
outRequestingPrincipal
)
{
NS_IF_ADDREF
(
*
outRequestingPrincipal
=
mRequestingPrincipal
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
SetRequestingPrincipal
(
nsIPrincipal
*
aRequestingPrincipal
)
{
mRequestingPrincipal
=
aRequestingPrincipal
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
GetContentPolicyType
(
nsContentPolicyType
*
outContentPolicyType
)
{
NS_ENSURE_ARG_POINTER
(
outContentPolicyType
)
;
*
outContentPolicyType
=
mContentPolicyType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTransferable
:
:
SetContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
{
mContentPolicyType
=
aContentPolicyType
;
return
NS_OK
;
}
