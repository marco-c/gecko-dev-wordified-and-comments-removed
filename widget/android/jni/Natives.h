#
ifndef
mozilla_jni_Natives_h__
#
define
mozilla_jni_Natives_h__
#
include
<
jni
.
h
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
RWLock
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
jni
/
Accessors
.
h
"
#
include
"
mozilla
/
jni
/
Refs
.
h
"
#
include
"
mozilla
/
jni
/
Types
.
h
"
#
include
"
mozilla
/
jni
/
Utils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
if
defined
(
_MSC_VER
)
#
define
FUNCTION_SIGNATURE
__FUNCSIG__
#
elif
defined
(
__GNUC__
)
#
define
FUNCTION_SIGNATURE
__PRETTY_FUNCTION__
#
endif
struct
NativeException
{
const
char
*
str
;
}
;
template
<
class
T
>
static
NativeException
NullHandle
(
)
{
return
{
FUNCTION_SIGNATURE
}
;
}
template
<
class
T
>
static
NativeException
NullWeakPtr
(
)
{
return
{
FUNCTION_SIGNATURE
}
;
}
namespace
mozilla
{
namespace
jni
{
namespace
detail
{
template
<
typename
typename
=
std
:
:
void_t
<
>
>
struct
HasWeakNonIntrusiveDetach
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
HasWeakNonIntrusiveDetach
<
T
std
:
:
void_t
<
decltype
(
std
:
:
declval
<
T
>
(
)
.
OnWeakNonIntrusiveDetach
(
std
:
:
declval
<
already_AddRefed
<
nsIRunnable
>
>
(
)
)
)
>
>
:
std
:
:
true_type
{
}
;
template
<
typename
typename
=
std
:
:
void_t
<
>
>
struct
IsRefCounted
:
std
:
:
false_type
{
}
;
template
<
typename
T
>
struct
IsRefCounted
<
T
std
:
:
void_t
<
decltype
(
std
:
:
declval
<
T
>
(
)
.
AddRef
(
)
std
:
:
declval
<
T
>
(
)
.
Release
(
)
)
>
>
:
std
:
:
true_type
{
}
;
enum
class
NativePtrInternalType
:
size_t
{
OWNING
=
1
WEAK
=
2
REFPTR
=
3
}
;
template
<
class
Impl
>
class
NativePtrInternalPicker
{
template
<
class
I
>
static
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
SupportsWeakPtr
I
>
:
:
value
char
(
&
)
[
static_cast
<
size_t
>
(
NativePtrInternalType
:
:
WEAK
)
]
>
Test
(
char
)
;
template
<
class
I
typename
=
decltype
(
&
I
:
:
AddRef
&
I
:
:
Release
)
>
static
char
(
&
Test
(
int
)
)
[
static_cast
<
size_t
>
(
NativePtrInternalType
:
:
REFPTR
)
]
;
template
<
class
>
static
char
(
&
Test
(
.
.
.
)
)
[
static_cast
<
size_t
>
(
NativePtrInternalType
:
:
OWNING
)
]
;
public
:
static
const
NativePtrInternalType
value
=
static_cast
<
NativePtrInternalType
>
(
sizeof
(
Test
<
Impl
>
(
'
\
0
'
)
)
/
sizeof
(
char
)
)
;
}
;
enum
class
NativePtrType
:
size_t
{
OWNING
=
1
WEAK_INTRUSIVE
=
2
WEAK_NON_INTRUSIVE
=
3
REFPTR
=
4
}
;
template
<
class
Impl
>
class
NativePtrPicker
{
template
<
NativePtrType
PtrType
>
using
ResultTypeT
=
char
(
&
)
[
static_cast
<
size_t
>
(
PtrType
)
]
;
template
<
typename
I
>
static
auto
Test
(
void
*
)
-
>
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
SupportsWeakPtr
I
>
:
:
value
ResultTypeT
<
NativePtrType
:
:
WEAK_INTRUSIVE
>
>
;
template
<
typename
I
>
static
auto
Test
(
void
*
)
-
>
std
:
:
enable_if_t
<
HasWeakNonIntrusiveDetach
<
I
>
:
:
value
ResultTypeT
<
NativePtrType
:
:
WEAK_NON_INTRUSIVE
>
>
;
template
<
typename
I
>
static
auto
Test
(
void
*
)
-
>
std
:
:
enable_if_t
<
std
:
:
conjunction_v
<
IsRefCounted
<
I
>
std
:
:
negation
<
HasWeakNonIntrusiveDetach
<
I
>
>
>
ResultTypeT
<
NativePtrType
:
:
REFPTR
>
>
;
template
<
typename
>
static
char
(
&
Test
(
.
.
.
)
)
[
static_cast
<
size_t
>
(
NativePtrType
:
:
OWNING
)
]
;
public
:
static
const
NativePtrType
value
=
static_cast
<
NativePtrType
>
(
sizeof
(
Test
<
Impl
>
(
nullptr
)
)
)
;
}
;
template
<
class
Impl
>
inline
uintptr_t
CheckNativeHandle
(
JNIEnv
*
env
uintptr_t
handle
)
{
if
(
!
handle
)
{
if
(
!
env
-
>
ExceptionCheck
(
)
)
{
ThrowException
(
env
"
java
/
lang
/
NullPointerException
"
NullHandle
<
Impl
>
(
)
.
str
)
;
}
return
0
;
}
return
handle
;
}
template
<
class
Impl
NativePtrType
Type
=
NativePtrPicker
<
Impl
>
:
:
value
>
struct
NativePtrTraits
;
template
<
class
Impl
>
struct
NativePtrTraits
<
Impl
NativePtrType
:
:
OWNING
>
{
using
AccessorType
=
Impl
*
;
using
HandleType
=
Impl
*
;
using
RefType
=
Impl
*
;
static
RefType
Get
(
JNIEnv
*
env
jobject
instance
)
{
static_assert
(
std
:
:
is_same
<
HandleType
RefType
>
:
:
value
"
HandleType
and
RefType
must
be
identical
for
owning
pointers
"
)
;
return
reinterpret_cast
<
HandleType
>
(
CheckNativeHandle
<
Impl
>
(
env
GetNativeHandle
(
env
instance
)
)
)
;
}
template
<
class
LocalRef
>
static
RefType
Get
(
const
LocalRef
&
instance
)
{
return
Get
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
static
AccessorType
Access
(
RefType
aImpl
JNIEnv
*
aEnv
=
nullptr
)
{
static_assert
(
std
:
:
is_same
<
AccessorType
RefType
>
:
:
value
"
AccessorType
and
RefType
must
be
identical
for
owning
pointers
"
)
;
return
aImpl
;
}
template
<
class
LocalRef
>
static
void
Set
(
const
LocalRef
&
instance
UniquePtr
<
Impl
>
&
&
ptr
)
{
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
reinterpret_cast
<
uintptr_t
>
(
ptr
.
release
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Clear
(
const
LocalRef
&
instance
)
{
UniquePtr
<
Impl
>
ptr
(
reinterpret_cast
<
RefType
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
ptr
)
{
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
}
}
;
template
<
class
Impl
>
struct
NativePtrTraits
<
Impl
NativePtrType
:
:
WEAK_INTRUSIVE
>
{
using
AccessorType
=
Impl
*
;
using
HandleType
=
WeakPtr
<
Impl
>
*
;
using
RefType
=
WeakPtr
<
Impl
>
;
static
RefType
Get
(
JNIEnv
*
env
jobject
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
HandleType
>
(
CheckNativeHandle
<
Impl
>
(
env
GetNativeHandle
(
env
instance
)
)
)
;
return
*
ptr
;
}
template
<
class
LocalRef
>
static
RefType
Get
(
const
LocalRef
&
instance
)
{
return
Get
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
static
AccessorType
Access
(
RefType
aPtr
JNIEnv
*
aEnv
=
nullptr
)
{
AccessorType
const
impl
=
*
aPtr
;
if
(
!
impl
)
{
JNIEnv
*
env
=
aEnv
?
aEnv
:
mozilla
:
:
jni
:
:
GetEnvForThread
(
)
;
ThrowException
(
env
"
java
/
lang
/
NullPointerException
"
NullWeakPtr
<
Impl
>
(
)
.
str
)
;
}
return
impl
;
}
template
<
class
LocalRef
>
static
void
Set
(
const
LocalRef
&
instance
Impl
*
ptr
)
{
const
uintptr_t
handle
=
reinterpret_cast
<
uintptr_t
>
(
new
WeakPtr
<
Impl
>
(
ptr
)
)
;
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
handle
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Clear
(
const
LocalRef
&
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
HandleType
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
ptr
)
{
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
delete
ptr
;
}
}
}
;
template
<
class
Impl
>
struct
NativePtrTraits
<
Impl
NativePtrType
:
:
REFPTR
>
{
using
AccessorType
=
Impl
*
;
using
HandleType
=
RefPtr
<
Impl
>
*
;
using
RefType
=
Impl
*
;
static
RefType
Get
(
JNIEnv
*
env
jobject
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
HandleType
>
(
CheckNativeHandle
<
Impl
>
(
env
GetNativeHandle
(
env
instance
)
)
)
;
if
(
!
ptr
)
{
return
nullptr
;
}
MOZ_ASSERT
(
*
ptr
)
;
return
*
ptr
;
}
template
<
class
LocalRef
>
static
RefType
Get
(
const
LocalRef
&
instance
)
{
return
Get
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
static
AccessorType
Access
(
RefType
aImpl
JNIEnv
*
aEnv
=
nullptr
)
{
static_assert
(
std
:
:
is_same
<
AccessorType
RefType
>
:
:
value
"
AccessorType
and
RefType
must
be
identical
for
refpointers
"
)
;
return
aImpl
;
}
template
<
class
LocalRef
>
static
void
Set
(
const
LocalRef
&
instance
RefType
ptr
)
{
const
uintptr_t
handle
=
reinterpret_cast
<
uintptr_t
>
(
new
RefPtr
<
Impl
>
(
ptr
)
)
;
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
handle
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Clear
(
const
LocalRef
&
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
HandleType
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
ptr
)
{
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
delete
ptr
;
}
}
}
;
}
template
<
typename
NativeImpl
>
class
NativeWeakPtr
;
template
<
typename
NativeImpl
>
class
NativeWeakPtrHolder
;
namespace
detail
{
template
<
typename
NativeImpl
NativePtrInternalType
PtrType
=
:
:
mozilla
:
:
jni
:
:
detail
:
:
NativePtrInternalPicker
<
NativeImpl
>
:
:
value
>
struct
NativeWeakPtrControlBlockStorageTraits
;
template
<
typename
NativeImpl
>
struct
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
:
:
mozilla
:
:
jni
:
:
detail
:
:
NativePtrInternalType
:
:
OWNING
>
{
using
Type
=
UniquePtr
<
NativeImpl
>
;
static
NativeImpl
*
AsRaw
(
const
Type
&
aStorage
)
{
return
aStorage
.
get
(
)
;
}
}
;
template
<
typename
NativeImpl
>
struct
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
:
:
mozilla
:
:
jni
:
:
detail
:
:
NativePtrInternalType
:
:
REFPTR
>
{
using
Type
=
RefPtr
<
NativeImpl
>
;
static
NativeImpl
*
AsRaw
(
const
Type
&
aStorage
)
{
return
aStorage
.
get
(
)
;
}
}
;
template
<
typename
NativeImpl
>
class
Accessor
;
template
<
typename
NativeImpl
>
class
MOZ_HEAP_CLASS
NativeWeakPtrControlBlock
final
{
public
:
using
StorageTraits
=
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
>
;
using
StorageType
=
typename
StorageTraits
:
:
Type
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
NativeWeakPtrControlBlock
)
NativeWeakPtrControlBlock
(
const
NativeWeakPtrControlBlock
&
)
=
delete
;
NativeWeakPtrControlBlock
(
NativeWeakPtrControlBlock
&
&
)
=
delete
;
NativeWeakPtrControlBlock
&
operator
=
(
const
NativeWeakPtrControlBlock
&
)
=
delete
;
NativeWeakPtrControlBlock
&
operator
=
(
NativeWeakPtrControlBlock
&
&
)
=
delete
;
mozilla
:
:
jni
:
:
Object
:
:
WeakRef
GetJavaOwner
(
)
const
{
return
mJavaOwner
;
}
private
:
NativeWeakPtrControlBlock
(
:
:
mozilla
:
:
jni
:
:
Object
:
:
Param
aJavaOwner
StorageType
&
&
aNativeImpl
)
:
mJavaOwner
(
aJavaOwner
)
mLock
(
"
mozilla
:
:
jni
:
:
detail
:
:
NativeWeakPtrControlBlock
"
)
mNativeImpl
(
std
:
:
move
(
aNativeImpl
)
)
{
}
~
NativeWeakPtrControlBlock
(
)
{
MOZ_ASSERT
(
!
(
*
this
)
)
;
}
StorageType
Clear
(
)
{
StorageType
nativeImpl
(
nullptr
)
;
{
AutoWriteLock
lock
(
mLock
)
;
std
:
:
swap
(
mNativeImpl
nativeImpl
)
;
}
return
nativeImpl
;
}
MOZ_PUSH_IGNORE_THREAD_SAFETY
void
Lock
(
)
const
{
mLock
.
ReadLock
(
)
;
}
void
Unlock
(
)
const
{
mLock
.
ReadUnlock
(
)
;
}
MOZ_POP_THREAD_SAFETY
#
if
defined
(
DEBUG
)
explicit
operator
bool
(
)
const
{
AutoReadLock
lock
(
mLock
)
;
return
!
!
mNativeImpl
;
}
#
endif
private
:
friend
class
Accessor
<
NativeImpl
>
;
friend
class
NativeWeakPtr
<
NativeImpl
>
;
friend
class
NativeWeakPtrHolder
<
NativeImpl
>
;
private
:
const
mozilla
:
:
jni
:
:
Object
:
:
WeakRef
mJavaOwner
;
mutable
RWLock
mLock
MOZ_UNANNOTATED
;
StorageType
mNativeImpl
;
}
;
template
<
typename
NativeImpl
>
class
NativeWeakPtrDetachRunnable
final
:
public
Runnable
{
public
:
NativeWeakPtrDetachRunnable
(
already_AddRefed
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
aCtlBlock
const
Object
:
:
LocalRef
&
aOwner
typename
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
>
:
:
Type
aNativeImpl
)
:
Runnable
(
"
mozilla
:
:
jni
:
:
detail
:
:
NativeWeakPtrDetachRunnable
"
)
mCtlBlock
(
aCtlBlock
)
mOwner
(
aOwner
)
mNativeImpl
(
std
:
:
move
(
aNativeImpl
)
)
mHasRun
(
false
)
{
MOZ_RELEASE_ASSERT
(
!
!
mCtlBlock
)
;
MOZ_RELEASE_ASSERT
(
!
!
mNativeImpl
)
;
}
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
NativeWeakPtrDetachRunnable
Runnable
)
NS_IMETHOD
Run
(
)
override
{
mHasRun
=
true
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
this
)
;
return
NS_OK
;
}
auto
owner
=
ToLocalRef
(
mOwner
)
;
auto
attachedNativeImpl
=
NativePtrTraits
<
NativeImpl
>
:
:
Get
(
owner
)
;
MOZ_RELEASE_ASSERT
(
!
!
attachedNativeImpl
)
;
if
(
attachedNativeImpl
-
>
IsSame
(
mCtlBlock
)
)
{
NativePtrTraits
<
NativeImpl
>
:
:
ClearFinish
(
owner
)
;
}
mNativeImpl
=
nullptr
;
return
NS_OK
;
}
private
:
~
NativeWeakPtrDetachRunnable
(
)
{
MOZ_RELEASE_ASSERT
(
mHasRun
"
You
must
run
/
dispatch
this
runnable
!
"
)
;
}
private
:
RefPtr
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
mCtlBlock
;
Object
:
:
GlobalRef
mOwner
;
typename
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
>
:
:
Type
mNativeImpl
;
bool
mHasRun
;
}
;
template
<
typename
NativeImpl
>
class
MOZ_STACK_CLASS
Accessor
final
{
public
:
~
Accessor
(
)
{
if
(
mCtlBlock
)
{
mCtlBlock
-
>
Unlock
(
)
;
}
}
explicit
operator
bool
(
)
const
{
return
mCtlBlock
&
&
mCtlBlock
-
>
mNativeImpl
;
}
NativeImpl
*
operator
-
>
(
)
const
{
return
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
>
:
:
AsRaw
(
mCtlBlock
-
>
mNativeImpl
)
;
}
template
<
typename
Member
>
auto
operator
-
>
*
(
Member
aMember
)
const
{
NativeImpl
*
impl
=
NativeWeakPtrControlBlockStorageTraits
<
NativeImpl
>
:
:
AsRaw
(
mCtlBlock
-
>
mNativeImpl
)
;
return
[
impl
member
=
aMember
]
(
auto
&
&
.
.
.
aArgs
)
{
return
(
impl
-
>
*
member
)
(
std
:
:
forward
<
decltype
(
aArgs
)
>
(
aArgs
)
.
.
.
)
;
}
;
}
template
<
typename
I
=
NativeImpl
>
auto
AsRefPtr
(
)
const
-
>
std
:
:
enable_if_t
<
IsRefCounted
<
I
>
:
:
value
RefPtr
<
I
>
>
{
MOZ_ASSERT
(
I
:
:
HasThreadSafeRefCnt
:
:
value
|
|
NS_IsMainThread
(
)
)
;
return
mCtlBlock
-
>
mNativeImpl
;
}
Accessor
(
const
Accessor
&
)
=
delete
;
Accessor
(
Accessor
&
&
)
=
delete
;
Accessor
&
operator
=
(
const
Accessor
&
)
=
delete
;
Accessor
&
operator
=
(
Accessor
&
&
)
=
delete
;
private
:
explicit
Accessor
(
const
RefPtr
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
&
aCtlBlock
)
:
mCtlBlock
(
aCtlBlock
)
{
if
(
aCtlBlock
)
{
aCtlBlock
-
>
Lock
(
)
;
}
}
private
:
friend
class
NativeWeakPtr
<
NativeImpl
>
;
friend
class
NativeWeakPtrHolder
<
NativeImpl
>
;
private
:
const
RefPtr
<
NativeWeakPtrControlBlock
<
NativeImpl
>
>
mCtlBlock
;
}
;
}
template
<
typename
NativeImpl
>
class
NativeWeakPtr
{
public
:
using
Accessor
=
detail
:
:
Accessor
<
NativeImpl
>
;
Accessor
Access
(
)
const
{
return
Accessor
(
mCtlBlock
)
;
}
void
Detach
(
)
{
if
(
!
IsAttached
(
)
)
{
return
;
}
auto
native
=
mCtlBlock
-
>
Clear
(
)
;
if
(
!
native
)
{
return
;
}
Object
:
:
LocalRef
owner
(
mCtlBlock
-
>
GetJavaOwner
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
!
owner
)
;
NativeImpl
*
rawImpl
=
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
:
:
StorageTraits
:
:
AsRaw
(
native
)
;
rawImpl
-
>
OnWeakNonIntrusiveDetach
(
do_AddRef
(
new
NativeWeakPtrDetachRunnable
<
NativeImpl
>
(
mCtlBlock
.
forget
(
)
owner
std
:
:
move
(
native
)
)
)
)
;
}
bool
IsAttached
(
)
const
{
return
!
!
mCtlBlock
;
}
bool
IsSame
(
const
Accessor
&
aAccessor
)
const
{
return
mCtlBlock
=
=
aAccessor
.
mCtlBlock
;
}
bool
IsSame
(
const
RefPtr
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
&
aOther
)
const
{
return
mCtlBlock
=
=
aOther
;
}
NativeWeakPtr
(
)
=
default
;
MOZ_IMPLICIT
NativeWeakPtr
(
decltype
(
nullptr
)
)
{
}
NativeWeakPtr
(
const
NativeWeakPtr
&
aOther
)
=
default
;
NativeWeakPtr
(
NativeWeakPtr
&
&
aOther
)
=
default
;
NativeWeakPtr
&
operator
=
(
const
NativeWeakPtr
&
aOther
)
=
default
;
NativeWeakPtr
&
operator
=
(
NativeWeakPtr
&
&
aOther
)
=
default
;
NativeWeakPtr
&
operator
=
(
decltype
(
nullptr
)
)
{
mCtlBlock
=
nullptr
;
return
*
this
;
}
protected
:
explicit
NativeWeakPtr
(
already_AddRefed
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
aCtlBlock
)
:
mCtlBlock
(
aCtlBlock
)
{
}
private
:
explicit
NativeWeakPtr
(
const
RefPtr
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
&
aCtlBlock
)
:
mCtlBlock
(
aCtlBlock
)
{
}
friend
class
NativeWeakPtrHolder
<
NativeImpl
>
;
protected
:
RefPtr
<
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
>
mCtlBlock
;
}
;
template
<
typename
NativeImpl
>
class
MOZ_HEAP_CLASS
NativeWeakPtrHolder
final
:
public
NativeWeakPtr
<
NativeImpl
>
{
using
Base
=
NativeWeakPtr
<
NativeImpl
>
;
public
:
using
Accessor
=
typename
Base
:
:
Accessor
;
using
StorageTraits
=
typename
detail
:
:
NativeWeakPtrControlBlock
<
NativeImpl
>
:
:
StorageTraits
;
using
StorageType
=
typename
StorageTraits
:
:
Type
;
template
<
typename
Cls
typename
JNIType
typename
.
.
.
Args
>
static
NativeWeakPtr
<
NativeImpl
>
Attach
(
const
Ref
<
Cls
JNIType
>
&
aJavaObject
Args
&
&
.
.
.
aArgs
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
StorageType
nativeImpl
(
new
NativeImpl
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
return
AttachInternal
(
aJavaObject
std
:
:
move
(
nativeImpl
)
)
;
}
template
<
typename
Cls
typename
JNIType
>
static
NativeWeakPtr
<
NativeImpl
>
AttachExisting
(
const
Ref
<
Cls
JNIType
>
&
aJavaObject
already_AddRefed
<
NativeImpl
>
aNativeImpl
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
StorageType
nativeImpl
(
aNativeImpl
)
;
return
AttachInternal
(
aJavaObject
std
:
:
move
(
nativeImpl
)
)
;
}
~
NativeWeakPtrHolder
(
)
=
default
;
MOZ_IMPLICIT
NativeWeakPtrHolder
(
decltype
(
nullptr
)
)
=
delete
;
NativeWeakPtrHolder
(
const
NativeWeakPtrHolder
&
)
=
delete
;
NativeWeakPtrHolder
(
NativeWeakPtrHolder
&
&
)
=
delete
;
NativeWeakPtrHolder
&
operator
=
(
const
NativeWeakPtrHolder
&
)
=
delete
;
NativeWeakPtrHolder
&
operator
=
(
NativeWeakPtrHolder
&
&
)
=
delete
;
NativeWeakPtrHolder
&
operator
=
(
decltype
(
nullptr
)
)
=
delete
;
private
:
template
<
typename
Cls
>
NativeWeakPtrHolder
(
const
LocalRef
<
Cls
>
&
aJavaObject
StorageType
&
&
aNativeImpl
)
:
NativeWeakPtr
<
NativeImpl
>
(
do_AddRef
(
new
NativeWeakPtrControlBlock
<
NativeImpl
>
(
aJavaObject
std
:
:
move
(
aNativeImpl
)
)
)
)
{
}
template
<
typename
Cls
typename
JNIType
>
static
NativeWeakPtr
<
NativeImpl
>
AttachInternal
(
const
Ref
<
Cls
JNIType
>
&
aJavaObject
StorageType
&
&
aPtr
)
{
auto
localJavaObject
=
ToLocalRef
(
aJavaObject
)
;
NativeWeakPtrHolder
<
NativeImpl
>
*
holder
=
new
NativeWeakPtrHolder
<
NativeImpl
>
(
localJavaObject
std
:
:
move
(
aPtr
)
)
;
static_assert
(
NativePtrPicker
<
NativeImpl
>
:
:
value
=
=
NativePtrType
:
:
WEAK_NON_INTRUSIVE
"
This
type
is
not
compatible
with
mozilla
:
:
jni
:
:
NativeWeakPtr
"
)
;
NativePtrTraits
<
NativeImpl
>
:
:
Set
(
localJavaObject
holder
)
;
return
NativeWeakPtr
<
NativeImpl
>
(
holder
-
>
mCtlBlock
)
;
}
}
;
namespace
detail
{
template
<
class
Impl
>
struct
NativePtrTraits
<
Impl
NativePtrType
:
:
WEAK_NON_INTRUSIVE
>
{
using
AccessorType
=
typename
NativeWeakPtrHolder
<
Impl
>
:
:
Accessor
;
using
HandleType
=
NativeWeakPtrHolder
<
Impl
>
*
;
using
RefType
=
NativeWeakPtrHolder
<
Impl
>
*
const
;
static
RefType
Get
(
JNIEnv
*
env
jobject
instance
)
{
return
GetHandle
(
env
instance
)
;
}
template
<
typename
Cls
>
static
RefType
Get
(
const
LocalRef
<
Cls
>
&
instance
)
{
return
GetHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
static
AccessorType
Access
(
RefType
aPtr
)
{
return
aPtr
-
>
Access
(
)
;
}
template
<
typename
Cls
>
static
void
Set
(
const
LocalRef
<
Cls
>
&
instance
HandleType
ptr
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
const
uintptr_t
handle
=
reinterpret_cast
<
uintptr_t
>
(
ptr
)
;
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
handle
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
typename
Cls
>
static
void
Clear
(
const
LocalRef
<
Cls
>
&
instance
)
{
auto
ptr
=
reinterpret_cast
<
HandleType
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
!
ptr
)
{
return
;
}
ptr
-
>
Detach
(
)
;
}
template
<
typename
Cls
>
static
void
ClearFinish
(
const
LocalRef
<
Cls
>
&
instance
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
JNIEnv
*
const
env
=
instance
.
Env
(
)
;
auto
ptr
=
reinterpret_cast
<
HandleType
>
(
GetNativeHandle
(
env
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
env
)
;
MOZ_RELEASE_ASSERT
(
!
!
ptr
)
;
SetNativeHandle
(
env
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
env
)
;
}
template
<
class
LocalRef
>
static
bool
IsStale
(
const
LocalRef
&
instance
)
{
JNIEnv
*
const
env
=
mozilla
:
:
jni
:
:
GetEnvForThread
(
)
;
const
auto
holder
=
reinterpret_cast
<
HandleType
>
(
GetNativeHandle
(
env
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
env
)
;
if
(
!
holder
|
|
!
holder
-
>
IsAttached
(
)
)
{
return
true
;
}
auto
acc
(
holder
-
>
Access
(
)
)
;
return
!
acc
;
}
private
:
static
HandleType
GetHandle
(
JNIEnv
*
env
jobject
instance
)
{
return
reinterpret_cast
<
HandleType
>
(
CheckNativeHandle
<
Impl
>
(
env
GetNativeHandle
(
env
instance
)
)
)
;
}
template
<
typename
Cls
>
static
HandleType
GetHandle
(
const
LocalRef
<
Cls
>
&
instance
)
{
return
GetHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
friend
class
NativeWeakPtrHolder
<
Impl
>
;
}
;
}
using
namespace
detail
;
namespace
detail
{
template
<
typename
T
>
struct
ProxyArg
{
static_assert
(
mozilla
:
:
IsPod
<
T
>
:
:
value
"
T
must
be
primitive
type
"
)
;
typedef
T
Type
;
typedef
typename
TypeAdapter
<
T
>
:
:
JNIType
JNIType
;
static
void
Clear
(
JNIEnv
*
env
Type
&
)
{
}
static
Type
From
(
JNIEnv
*
env
JNIType
val
)
{
return
TypeAdapter
<
T
>
:
:
ToNative
(
env
val
)
;
}
}
;
template
<
class
C
typename
T
>
struct
ProxyArg
<
Ref
<
C
T
>
>
{
typedef
typename
C
:
:
GlobalRef
Type
;
typedef
typename
TypeAdapter
<
Ref
<
C
T
>
>
:
:
JNIType
JNIType
;
static
void
Clear
(
JNIEnv
*
env
Type
&
ref
)
{
ref
.
Clear
(
env
)
;
}
static
Type
From
(
JNIEnv
*
env
JNIType
val
)
{
return
Type
(
env
C
:
:
Ref
:
:
From
(
val
)
)
;
}
}
;
template
<
typename
C
>
struct
ProxyArg
<
const
C
&
>
:
ProxyArg
<
C
>
{
}
;
template
<
>
struct
ProxyArg
<
StringParam
>
:
ProxyArg
<
String
:
:
Ref
>
{
}
;
template
<
class
C
>
struct
ProxyArg
<
LocalRef
<
C
>
>
:
ProxyArg
<
typename
C
:
:
Ref
>
{
}
;
template
<
class
Impl
class
Owner
bool
IsStatic
bool
HasThisArg
typename
.
.
.
Args
>
class
ProxyNativeCall
{
using
ThisArgClass
=
std
:
:
conditional_t
<
IsStatic
Class
Owner
>
;
using
ThisArgJNIType
=
std
:
:
conditional_t
<
IsStatic
jclass
jobject
>
;
using
NativeCallType
=
std
:
:
conditional_t
<
IsStatic
std
:
:
conditional_t
<
HasThisArg
void
(
*
)
(
const
Class
:
:
LocalRef
&
Args
.
.
.
)
void
(
*
)
(
Args
.
.
.
)
>
std
:
:
conditional_t
<
HasThisArg
void
(
Impl
:
:
*
)
(
const
typename
Owner
:
:
LocalRef
&
Args
.
.
.
)
void
(
Impl
:
:
*
)
(
Args
.
.
.
)
>
>
;
NativeCallType
mNativeCall
;
typename
ThisArgClass
:
:
GlobalRef
mThisArg
;
std
:
:
tuple
<
typename
ProxyArg
<
Args
>
:
:
Type
.
.
.
>
mArgs
;
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
std
:
:
enable_if_t
<
Static
&
&
ThisArg
void
>
Call
(
const
Class
:
:
LocalRef
&
cls
std
:
:
index_sequence
<
Indices
.
.
.
>
)
const
{
(
*
mNativeCall
)
(
cls
std
:
:
get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
std
:
:
enable_if_t
<
Static
&
&
!
ThisArg
void
>
Call
(
const
Class
:
:
LocalRef
&
cls
std
:
:
index_sequence
<
Indices
.
.
.
>
)
const
{
(
*
mNativeCall
)
(
std
:
:
get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
std
:
:
enable_if_t
<
!
Static
&
&
ThisArg
void
>
Call
(
const
typename
Owner
:
:
LocalRef
&
inst
std
:
:
index_sequence
<
Indices
.
.
.
>
)
const
{
auto
impl
=
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
inst
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
inst
.
Env
(
)
)
;
(
impl
-
>
*
mNativeCall
)
(
inst
std
:
:
get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
std
:
:
enable_if_t
<
!
Static
&
&
!
ThisArg
void
>
Call
(
const
typename
Owner
:
:
LocalRef
&
inst
std
:
:
index_sequence
<
Indices
.
.
.
>
)
const
{
auto
impl
=
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
inst
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
inst
.
Env
(
)
)
;
(
impl
-
>
*
mNativeCall
)
(
std
:
:
get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
template
<
size_t
.
.
.
Indices
>
void
Clear
(
JNIEnv
*
env
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
int
dummy
[
]
=
{
(
ProxyArg
<
Args
>
:
:
Clear
(
env
std
:
:
get
<
Indices
>
(
mArgs
)
)
0
)
.
.
.
}
;
mozilla
:
:
Unused
<
<
dummy
;
}
static
decltype
(
auto
)
GetNativeObject
(
Class
:
:
Param
thisArg
)
{
return
nullptr
;
}
static
decltype
(
auto
)
GetNativeObject
(
typename
Owner
:
:
Param
thisArg
)
{
return
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
GetEnvForThread
(
)
thisArg
.
Get
(
)
)
)
;
}
public
:
typedef
Impl
TargetClass
;
typedef
typename
ThisArgClass
:
:
Param
ThisArgType
;
static
const
bool
isStatic
=
IsStatic
;
ProxyNativeCall
(
ThisArgJNIType
thisArg
NativeCallType
nativeCall
JNIEnv
*
env
typename
ProxyArg
<
Args
>
:
:
JNIType
.
.
.
args
)
:
mNativeCall
(
nativeCall
)
mThisArg
(
env
ThisArgClass
:
:
Ref
:
:
From
(
thisArg
)
)
mArgs
(
ProxyArg
<
Args
>
:
:
From
(
env
args
)
.
.
.
)
{
}
ProxyNativeCall
(
ProxyNativeCall
&
&
)
=
default
;
ProxyNativeCall
(
const
ProxyNativeCall
&
)
=
default
;
typename
ThisArgClass
:
:
Param
GetThisArg
(
)
const
{
return
mThisArg
;
}
decltype
(
auto
)
GetNativeObject
(
)
const
{
return
GetNativeObject
(
mThisArg
)
;
}
bool
IsTarget
(
NativeCallType
call
)
const
{
return
call
=
=
mNativeCall
;
}
template
<
typename
T
>
bool
IsTarget
(
T
&
&
)
const
{
return
false
;
}
void
SetTarget
(
NativeCallType
call
)
{
mNativeCall
=
call
;
}
template
<
typename
T
>
void
SetTarget
(
T
&
&
)
const
{
MOZ_CRASH
(
)
;
}
void
operator
(
)
(
)
{
JNIEnv
*
const
env
=
GetEnvForThread
(
)
;
typename
ThisArgClass
:
:
LocalRef
thisArg
(
env
mThisArg
)
;
Call
<
IsStatic
HasThisArg
>
(
thisArg
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
Clear
(
env
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
mThisArg
.
Clear
(
env
)
;
}
}
;
template
<
class
Impl
bool
HasThisArg
typename
.
.
.
Args
>
struct
Dispatcher
{
template
<
class
Traits
bool
IsStatic
=
Traits
:
:
isStatic
typename
.
.
.
ProxyArgs
>
static
std
:
:
enable_if_t
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
PROXY
void
>
Run
(
ProxyArgs
&
&
.
.
.
args
)
{
Impl
:
:
OnNativeCall
(
ProxyNativeCall
<
Impl
typename
Traits
:
:
Owner
IsStatic
HasThisArg
Args
.
.
.
>
(
std
:
:
forward
<
ProxyArgs
>
(
args
)
.
.
.
)
)
;
}
template
<
class
Traits
bool
IsStatic
=
Traits
:
:
isStatic
typename
ThisArg
typename
.
.
.
ProxyArgs
>
static
std
:
:
enable_if_t
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
GECKO_PRIORITY
void
>
Run
(
ThisArg
thisArg
ProxyArgs
&
&
.
.
.
args
)
{
auto
proxy
=
ProxyNativeCall
<
Impl
typename
Traits
:
:
Owner
IsStatic
HasThisArg
Args
.
.
.
>
(
(
HasThisArg
|
|
!
IsStatic
)
?
thisArg
:
nullptr
std
:
:
forward
<
ProxyArgs
>
(
args
)
.
.
.
)
;
DispatchToGeckoPriorityQueue
(
NS_NewRunnableFunction
(
"
PriorityNativeCall
"
std
:
:
move
(
proxy
)
)
)
;
}
template
<
class
Traits
bool
IsStatic
=
Traits
:
:
isStatic
typename
ThisArg
typename
.
.
.
ProxyArgs
>
static
std
:
:
enable_if_t
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
GECKO
void
>
Run
(
ThisArg
thisArg
ProxyArgs
&
&
.
.
.
args
)
{
auto
proxy
=
ProxyNativeCall
<
Impl
typename
Traits
:
:
Owner
IsStatic
HasThisArg
Args
.
.
.
>
(
(
HasThisArg
|
|
!
IsStatic
)
?
thisArg
:
nullptr
std
:
:
forward
<
ProxyArgs
>
(
args
)
.
.
.
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
GeckoNativeCall
"
std
:
:
move
(
proxy
)
)
)
;
}
template
<
class
Traits
bool
IsStatic
=
false
typename
.
.
.
ProxyArgs
>
static
std
:
:
enable_if_t
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
CURRENT
void
>
Run
(
ProxyArgs
&
&
.
.
.
args
)
{
MOZ_CRASH
(
"
Unreachable
code
"
)
;
}
}
;
}
#
ifdef
__i386__
#
define
MOZ_JNICALL
JNICALL
__attribute__
(
(
force_align_arg_pointer
)
)
#
else
#
define
MOZ_JNICALL
JNICALL
#
endif
template
<
class
Traits
class
Impl
class
Args
=
typename
Traits
:
:
Args
>
class
NativeStub
;
template
<
class
Traits
class
Impl
typename
.
.
.
Args
>
class
NativeStub
<
Traits
Impl
jni
:
:
Args
<
Args
.
.
.
>
>
{
using
Owner
=
typename
Traits
:
:
Owner
;
using
ReturnType
=
typename
Traits
:
:
ReturnType
;
static
constexpr
bool
isStatic
=
Traits
:
:
isStatic
;
static
constexpr
bool
isVoid
=
std
:
:
is_void_v
<
ReturnType
>
;
struct
VoidType
{
using
JNIType
=
void
;
}
;
using
ReturnJNIType
=
typename
std
:
:
conditional_t
<
isVoid
VoidType
TypeAdapter
<
ReturnType
>
>
:
:
JNIType
;
using
ReturnTypeForNonVoidInstance
=
std
:
:
conditional_t
<
!
isStatic
&
&
!
isVoid
ReturnType
VoidType
>
;
using
ReturnTypeForVoidInstance
=
std
:
:
conditional_t
<
!
isStatic
&
&
isVoid
ReturnType
VoidType
&
>
;
using
ReturnTypeForNonVoidStatic
=
std
:
:
conditional_t
<
isStatic
&
&
!
isVoid
ReturnType
VoidType
>
;
using
ReturnTypeForVoidStatic
=
std
:
:
conditional_t
<
isStatic
&
&
isVoid
ReturnType
VoidType
&
>
;
static_assert
(
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
CURRENT
|
|
isVoid
"
Dispatched
calls
must
have
void
return
type
"
)
;
public
:
template
<
ReturnTypeForNonVoidInstance
(
Impl
:
:
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
auto
impl
=
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
env
instance
)
)
;
if
(
!
impl
)
{
return
ReturnJNIType
(
)
;
}
return
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
impl
-
>
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
}
template
<
ReturnTypeForNonVoidInstance
(
Impl
:
:
*
Method
)
(
const
typename
Owner
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
auto
impl
=
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
env
instance
)
)
;
if
(
!
impl
)
{
return
ReturnJNIType
(
)
;
}
auto
self
=
Owner
:
:
LocalRef
:
:
Adopt
(
env
instance
)
;
const
auto
res
=
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
impl
-
>
*
Method
)
(
self
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
self
.
Forget
(
)
;
return
res
;
}
template
<
ReturnTypeForVoidInstance
(
Impl
:
:
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
false
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
instance
Method
env
args
.
.
.
)
;
return
;
}
auto
impl
=
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
env
instance
)
)
;
if
(
!
impl
)
{
return
;
}
(
impl
-
>
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
}
template
<
ReturnTypeForVoidInstance
(
Impl
:
:
*
Method
)
(
const
typename
Owner
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
true
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
instance
Method
env
args
.
.
.
)
;
return
;
}
auto
impl
=
NativePtrTraits
<
Impl
>
:
:
Access
(
NativePtrTraits
<
Impl
>
:
:
Get
(
env
instance
)
)
;
if
(
!
impl
)
{
return
;
}
auto
self
=
Owner
:
:
LocalRef
:
:
Adopt
(
env
instance
)
;
(
impl
-
>
*
Method
)
(
self
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
self
.
Forget
(
)
;
}
template
<
ReturnTypeForVoidInstance
(
*
DisposeNative
)
(
const
typename
Owner
:
:
LocalRef
&
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jobject
instance
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
using
LocalRef
=
typename
Owner
:
:
LocalRef
;
Dispatcher
<
Impl
false
const
LocalRef
&
>
:
:
template
Run
<
Traits
true
>
(
nullptr
DisposeNative
env
instance
)
;
return
;
}
auto
self
=
Owner
:
:
LocalRef
:
:
Adopt
(
env
instance
)
;
DisposeNative
(
self
)
;
self
.
Forget
(
)
;
}
template
<
ReturnTypeForNonVoidStatic
(
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jclass
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
return
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
}
template
<
ReturnTypeForNonVoidStatic
(
*
Method
)
(
const
Class
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jclass
cls
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
auto
clazz
=
Class
:
:
LocalRef
:
:
Adopt
(
env
cls
)
;
const
auto
res
=
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
*
Method
)
(
clazz
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
clazz
.
Forget
(
)
;
return
res
;
}
template
<
ReturnTypeForVoidStatic
(
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jclass
cls
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
false
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
cls
Method
env
args
.
.
.
)
;
return
;
}
(
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
}
template
<
ReturnTypeForVoidStatic
(
*
Method
)
(
const
Class
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jclass
cls
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
true
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
cls
Method
env
args
.
.
.
)
;
return
;
}
auto
clazz
=
Class
:
:
LocalRef
:
:
Adopt
(
env
cls
)
;
(
*
Method
)
(
clazz
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
clazz
.
Forget
(
)
;
}
}
;
template
<
class
Traits
typename
Ret
typename
.
.
.
Args
>
constexpr
JNINativeMethod
MakeNativeMethod
(
MOZ_JNICALL
Ret
(
*
stub
)
(
JNIEnv
*
Args
.
.
.
)
)
{
return
{
Traits
:
:
name
Traits
:
:
signature
reinterpret_cast
<
void
*
>
(
stub
)
}
;
}
template
<
class
Cls
class
Impl
>
class
NativeImpl
{
typedef
typename
Cls
:
:
template
Natives
<
Impl
>
Natives
;
static
bool
sInited
;
public
:
static
void
Init
(
)
{
if
(
sInited
)
{
return
;
}
const
auto
&
ctx
=
typename
Cls
:
:
Context
(
)
;
ctx
.
Env
(
)
-
>
RegisterNatives
(
ctx
.
ClassRef
(
)
Natives
:
:
methods
sizeof
(
Natives
:
:
methods
)
/
sizeof
(
Natives
:
:
methods
[
0
]
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
ctx
.
Env
(
)
)
;
sInited
=
true
;
}
protected
:
static
void
AttachNative
(
const
typename
Cls
:
:
LocalRef
&
instance
SupportsWeakPtr
*
ptr
)
{
static_assert
(
NativePtrPicker
<
Impl
>
:
:
value
=
=
NativePtrType
:
:
WEAK_INTRUSIVE
"
Use
another
AttachNative
for
non
-
WeakPtr
usage
"
)
;
return
NativePtrTraits
<
Impl
>
:
:
Set
(
instance
static_cast
<
Impl
*
>
(
ptr
)
)
;
}
static
void
AttachNative
(
const
typename
Cls
:
:
LocalRef
&
instance
UniquePtr
<
Impl
>
&
&
ptr
)
{
static_assert
(
NativePtrPicker
<
Impl
>
:
:
value
=
=
NativePtrType
:
:
OWNING
"
Use
another
AttachNative
for
WeakPtr
or
RefPtr
usage
"
)
;
return
NativePtrTraits
<
Impl
>
:
:
Set
(
instance
std
:
:
move
(
ptr
)
)
;
}
static
void
AttachNative
(
const
typename
Cls
:
:
LocalRef
&
instance
Impl
*
ptr
)
{
static_assert
(
NativePtrPicker
<
Impl
>
:
:
value
=
=
NativePtrType
:
:
REFPTR
"
Use
another
AttachNative
for
non
-
RefPtr
usage
"
)
;
return
NativePtrTraits
<
Impl
>
:
:
Set
(
instance
ptr
)
;
}
static
decltype
(
auto
)
GetNative
(
const
typename
Cls
:
:
LocalRef
&
instance
)
{
return
NativePtrTraits
<
Impl
>
:
:
Get
(
instance
)
;
}
static
void
DisposeNative
(
const
typename
Cls
:
:
LocalRef
&
instance
)
{
NativePtrTraits
<
Impl
>
:
:
Clear
(
instance
)
;
}
NativeImpl
(
)
{
Init
(
)
;
}
}
;
template
<
class
C
class
I
>
bool
NativeImpl
<
C
I
>
:
:
sInited
;
}
}
#
endif
