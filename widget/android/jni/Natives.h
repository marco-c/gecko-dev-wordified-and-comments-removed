#
ifndef
mozilla_jni_Natives_h__
#
define
mozilla_jni_Natives_h__
#
include
<
jni
.
h
>
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
IndexSequence
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
jni
/
Accessors
.
h
"
#
include
"
mozilla
/
jni
/
Refs
.
h
"
#
include
"
mozilla
/
jni
/
Types
.
h
"
#
include
"
mozilla
/
jni
/
Utils
.
h
"
namespace
mozilla
{
namespace
jni
{
namespace
detail
{
enum
NativePtrType
{
OWNING
WEAK
REFPTR
}
;
template
<
class
Impl
>
class
NativePtrPicker
{
template
<
class
I
>
static
typename
EnableIf
<
IsBaseOf
<
SupportsWeakPtr
<
I
>
I
>
:
:
value
char
(
&
)
[
NativePtrType
:
:
WEAK
]
>
:
:
Type
Test
(
char
)
;
template
<
class
I
typename
=
decltype
(
&
I
:
:
AddRef
&
I
:
:
Release
)
>
static
char
(
&
Test
(
int
)
)
[
NativePtrType
:
:
REFPTR
]
;
template
<
class
>
static
char
(
&
Test
(
.
.
.
)
)
[
NativePtrType
:
:
OWNING
]
;
public
:
static
const
int
value
=
sizeof
(
Test
<
Impl
>
(
'
\
0
'
)
)
/
sizeof
(
char
)
;
}
;
inline
uintptr_t
CheckNativeHandle
(
JNIEnv
*
env
uintptr_t
handle
)
{
if
(
!
handle
)
{
if
(
!
env
-
>
ExceptionCheck
(
)
)
{
ThrowException
(
env
"
java
/
lang
/
NullPointerException
"
"
Null
native
pointer
"
)
;
}
return
0
;
}
return
handle
;
}
template
<
class
Impl
int
Type
=
NativePtrPicker
<
Impl
>
:
:
value
>
struct
NativePtr
;
template
<
class
Impl
>
struct
NativePtr
<
Impl
NativePtrType
:
:
OWNING
>
{
static
Impl
*
Get
(
JNIEnv
*
env
jobject
instance
)
{
return
reinterpret_cast
<
Impl
*
>
(
CheckNativeHandle
(
env
GetNativeHandle
(
env
instance
)
)
)
;
}
template
<
class
LocalRef
>
static
Impl
*
Get
(
const
LocalRef
&
instance
)
{
return
Get
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Set
(
const
LocalRef
&
instance
UniquePtr
<
Impl
>
&
&
ptr
)
{
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
reinterpret_cast
<
uintptr_t
>
(
ptr
.
release
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Clear
(
const
LocalRef
&
instance
)
{
UniquePtr
<
Impl
>
ptr
(
reinterpret_cast
<
Impl
*
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
ptr
)
{
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
}
}
;
template
<
class
Impl
>
struct
NativePtr
<
Impl
NativePtrType
:
:
WEAK
>
{
static
Impl
*
Get
(
JNIEnv
*
env
jobject
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
WeakPtr
<
Impl
>
*
>
(
CheckNativeHandle
(
env
GetNativeHandle
(
env
instance
)
)
)
;
if
(
!
ptr
)
{
return
nullptr
;
}
Impl
*
const
impl
=
*
ptr
;
if
(
!
impl
)
{
ThrowException
(
env
"
java
/
lang
/
NullPointerException
"
"
Native
weak
object
already
released
"
)
;
}
return
impl
;
}
template
<
class
LocalRef
>
static
Impl
*
Get
(
const
LocalRef
&
instance
)
{
return
Get
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Set
(
const
LocalRef
&
instance
Impl
*
ptr
)
{
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
reinterpret_cast
<
uintptr_t
>
(
new
WeakPtr
<
Impl
>
(
ptr
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Clear
(
const
LocalRef
&
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
WeakPtr
<
Impl
>
*
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
ptr
)
{
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
delete
ptr
;
}
}
}
;
template
<
class
Impl
>
struct
NativePtr
<
Impl
NativePtrType
:
:
REFPTR
>
{
static
Impl
*
Get
(
JNIEnv
*
env
jobject
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
RefPtr
<
Impl
>
*
>
(
CheckNativeHandle
(
env
GetNativeHandle
(
env
instance
)
)
)
;
if
(
!
ptr
)
{
return
nullptr
;
}
MOZ_ASSERT
(
*
ptr
)
;
return
*
ptr
;
}
template
<
class
LocalRef
>
static
Impl
*
Get
(
const
LocalRef
&
instance
)
{
return
Get
(
instance
.
Env
(
)
instance
.
Get
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Set
(
const
LocalRef
&
instance
Impl
*
ptr
)
{
Clear
(
instance
)
;
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
reinterpret_cast
<
uintptr_t
>
(
new
RefPtr
<
Impl
>
(
ptr
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
}
template
<
class
LocalRef
>
static
void
Clear
(
const
LocalRef
&
instance
)
{
const
auto
ptr
=
reinterpret_cast
<
RefPtr
<
Impl
>
*
>
(
GetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
if
(
ptr
)
{
SetNativeHandle
(
instance
.
Env
(
)
instance
.
Get
(
)
0
)
;
MOZ_CATCH_JNI_EXCEPTION
(
instance
.
Env
(
)
)
;
delete
ptr
;
}
}
}
;
}
using
namespace
detail
;
namespace
detail
{
template
<
typename
T
>
struct
ProxyArg
{
static_assert
(
mozilla
:
:
IsPod
<
T
>
:
:
value
"
T
must
be
primitive
type
"
)
;
typedef
T
Type
;
typedef
typename
TypeAdapter
<
T
>
:
:
JNIType
JNIType
;
static
void
Clear
(
JNIEnv
*
env
Type
&
)
{
}
static
Type
From
(
JNIEnv
*
env
JNIType
val
)
{
return
TypeAdapter
<
T
>
:
:
ToNative
(
env
val
)
;
}
}
;
template
<
class
C
typename
T
>
struct
ProxyArg
<
Ref
<
C
T
>
>
{
typedef
typename
C
:
:
GlobalRef
Type
;
typedef
typename
TypeAdapter
<
Ref
<
C
T
>
>
:
:
JNIType
JNIType
;
static
void
Clear
(
JNIEnv
*
env
Type
&
ref
)
{
ref
.
Clear
(
env
)
;
}
static
Type
From
(
JNIEnv
*
env
JNIType
val
)
{
return
Type
(
env
C
:
:
Ref
:
:
From
(
val
)
)
;
}
}
;
template
<
typename
C
>
struct
ProxyArg
<
const
C
&
>
:
ProxyArg
<
C
>
{
}
;
template
<
>
struct
ProxyArg
<
StringParam
>
:
ProxyArg
<
String
:
:
Ref
>
{
}
;
template
<
class
C
>
struct
ProxyArg
<
LocalRef
<
C
>
>
:
ProxyArg
<
typename
C
:
:
Ref
>
{
}
;
template
<
class
Impl
class
Owner
bool
IsStatic
bool
HasThisArg
typename
.
.
.
Args
>
class
ProxyNativeCall
:
public
AbstractCall
{
typedef
typename
mozilla
:
:
Conditional
<
IsStatic
Class
Owner
>
:
:
Type
ThisArgClass
;
typedef
typename
mozilla
:
:
Conditional
<
IsStatic
jclass
jobject
>
:
:
Type
ThisArgJNIType
;
typedef
typename
mozilla
:
:
Conditional
<
IsStatic
typename
mozilla
:
:
Conditional
<
HasThisArg
void
(
*
)
(
const
Class
:
:
LocalRef
&
Args
.
.
.
)
void
(
*
)
(
Args
.
.
.
)
>
:
:
Type
typename
mozilla
:
:
Conditional
<
HasThisArg
void
(
Impl
:
:
*
)
(
const
typename
Owner
:
:
LocalRef
&
Args
.
.
.
)
void
(
Impl
:
:
*
)
(
Args
.
.
.
)
>
:
:
Type
>
:
:
Type
NativeCallType
;
NativeCallType
mNativeCall
;
typename
ThisArgClass
:
:
GlobalRef
mThisArg
;
mozilla
:
:
Tuple
<
typename
ProxyArg
<
Args
>
:
:
Type
.
.
.
>
mArgs
;
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
typename
mozilla
:
:
EnableIf
<
Static
&
&
ThisArg
void
>
:
:
Type
Call
(
const
Class
:
:
LocalRef
&
cls
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
)
const
{
(
*
mNativeCall
)
(
cls
mozilla
:
:
Get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
typename
mozilla
:
:
EnableIf
<
Static
&
&
!
ThisArg
void
>
:
:
Type
Call
(
const
Class
:
:
LocalRef
&
cls
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
)
const
{
(
*
mNativeCall
)
(
mozilla
:
:
Get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
typename
mozilla
:
:
EnableIf
<
!
Static
&
&
ThisArg
void
>
:
:
Type
Call
(
const
typename
Owner
:
:
LocalRef
&
inst
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
)
const
{
if
(
Impl
*
const
impl
=
NativePtr
<
Impl
>
:
:
Get
(
inst
)
)
{
MOZ_CATCH_JNI_EXCEPTION
(
inst
.
Env
(
)
)
;
(
impl
-
>
*
mNativeCall
)
(
inst
mozilla
:
:
Get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
}
template
<
bool
Static
bool
ThisArg
size_t
.
.
.
Indices
>
typename
mozilla
:
:
EnableIf
<
!
Static
&
&
!
ThisArg
void
>
:
:
Type
Call
(
const
typename
Owner
:
:
LocalRef
&
inst
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
)
const
{
if
(
Impl
*
const
impl
=
NativePtr
<
Impl
>
:
:
Get
(
inst
)
)
{
MOZ_CATCH_JNI_EXCEPTION
(
inst
.
Env
(
)
)
;
(
impl
-
>
*
mNativeCall
)
(
mozilla
:
:
Get
<
Indices
>
(
mArgs
)
.
.
.
)
;
}
}
template
<
size_t
.
.
.
Indices
>
void
Clear
(
JNIEnv
*
env
mozilla
:
:
IndexSequence
<
Indices
.
.
.
>
)
{
int
dummy
[
]
=
{
(
ProxyArg
<
Args
>
:
:
Clear
(
env
Get
<
Indices
>
(
mArgs
)
)
0
)
.
.
.
}
;
mozilla
:
:
Unused
<
<
dummy
;
}
static
Impl
*
GetNativeObject
(
Class
:
:
Param
thisArg
)
{
return
nullptr
;
}
static
Impl
*
GetNativeObject
(
typename
Owner
:
:
Param
thisArg
)
{
return
NativePtr
<
Impl
>
:
:
Get
(
GetEnvForThread
(
)
thisArg
.
Get
(
)
)
;
}
public
:
typedef
Impl
TargetClass
;
typedef
typename
ThisArgClass
:
:
Param
ThisArgType
;
static
const
bool
isStatic
=
IsStatic
;
ProxyNativeCall
(
ThisArgJNIType
thisArg
NativeCallType
nativeCall
JNIEnv
*
env
typename
ProxyArg
<
Args
>
:
:
JNIType
.
.
.
args
)
:
mNativeCall
(
nativeCall
)
mThisArg
(
env
ThisArgClass
:
:
Ref
:
:
From
(
thisArg
)
)
mArgs
(
ProxyArg
<
Args
>
:
:
From
(
env
args
)
.
.
.
)
{
}
ProxyNativeCall
(
ProxyNativeCall
&
&
)
=
default
;
ProxyNativeCall
(
const
ProxyNativeCall
&
)
=
default
;
typename
ThisArgClass
:
:
Param
GetThisArg
(
)
const
{
return
mThisArg
;
}
Impl
*
GetNativeObject
(
)
const
{
return
GetNativeObject
(
mThisArg
)
;
}
bool
IsTarget
(
NativeCallType
call
)
const
{
return
call
=
=
mNativeCall
;
}
template
<
typename
T
>
bool
IsTarget
(
T
&
&
)
const
{
return
false
;
}
void
SetTarget
(
NativeCallType
call
)
{
mNativeCall
=
call
;
}
template
<
typename
T
>
void
SetTarget
(
T
&
&
)
const
{
MOZ_CRASH
(
)
;
}
void
operator
(
)
(
)
override
{
JNIEnv
*
const
env
=
GetEnvForThread
(
)
;
typename
ThisArgClass
:
:
LocalRef
thisArg
(
env
mThisArg
)
;
Call
<
IsStatic
HasThisArg
>
(
thisArg
typename
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
)
;
Clear
(
env
typename
IndexSequenceFor
<
Args
.
.
.
>
:
:
Type
(
)
)
;
mThisArg
.
Clear
(
env
)
;
}
}
;
template
<
class
Impl
bool
HasThisArg
typename
.
.
.
Args
>
struct
Dispatcher
{
template
<
class
Traits
bool
IsStatic
=
Traits
:
:
isStatic
typename
.
.
.
ProxyArgs
>
static
typename
EnableIf
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
PROXY
void
>
:
:
Type
Run
(
ProxyArgs
&
&
.
.
.
args
)
{
Impl
:
:
OnNativeCall
(
ProxyNativeCall
<
Impl
typename
Traits
:
:
Owner
IsStatic
HasThisArg
Args
.
.
.
>
(
Forward
<
ProxyArgs
>
(
args
)
.
.
.
)
)
;
}
template
<
class
Traits
bool
IsStatic
=
Traits
:
:
isStatic
typename
ThisArg
typename
.
.
.
ProxyArgs
>
static
typename
EnableIf
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
GECKO_PRIORITY
void
>
:
:
Type
Run
(
ThisArg
thisArg
ProxyArgs
&
&
.
.
.
args
)
{
DispatchToGeckoPriorityQueue
(
MakeUnique
<
ProxyNativeCall
<
Impl
typename
Traits
:
:
Owner
IsStatic
HasThisArg
Args
.
.
.
>
>
(
HasThisArg
|
|
!
IsStatic
?
thisArg
:
nullptr
Forward
<
ProxyArgs
>
(
args
)
.
.
.
)
)
;
}
template
<
class
Traits
bool
IsStatic
=
Traits
:
:
isStatic
typename
ThisArg
typename
.
.
.
ProxyArgs
>
static
typename
EnableIf
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
GECKO
void
>
:
:
Type
Run
(
ThisArg
thisArg
ProxyArgs
&
&
.
.
.
args
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ProxyNativeCall
"
ProxyNativeCall
<
Impl
typename
Traits
:
:
Owner
IsStatic
HasThisArg
Args
.
.
.
>
(
HasThisArg
|
|
!
IsStatic
?
thisArg
:
nullptr
Forward
<
ProxyArgs
>
(
args
)
.
.
.
)
)
)
;
}
template
<
class
Traits
bool
IsStatic
=
false
typename
.
.
.
ProxyArgs
>
static
typename
EnableIf
<
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
CURRENT
void
>
:
:
Type
Run
(
ProxyArgs
&
&
.
.
.
args
)
{
MOZ_CRASH
(
"
Unreachable
code
"
)
;
}
}
;
}
#
ifdef
__i386__
#
define
MOZ_JNICALL
JNICALL
__attribute__
(
(
force_align_arg_pointer
)
)
#
else
#
define
MOZ_JNICALL
JNICALL
#
endif
template
<
class
Traits
class
Impl
class
Args
=
typename
Traits
:
:
Args
>
class
NativeStub
;
template
<
class
Traits
class
Impl
typename
.
.
.
Args
>
class
NativeStub
<
Traits
Impl
jni
:
:
Args
<
Args
.
.
.
>
>
{
using
Owner
=
typename
Traits
:
:
Owner
;
using
ReturnType
=
typename
Traits
:
:
ReturnType
;
static
constexpr
bool
isStatic
=
Traits
:
:
isStatic
;
static
constexpr
bool
isVoid
=
mozilla
:
:
IsVoid
<
ReturnType
>
:
:
value
;
struct
VoidType
{
using
JNIType
=
void
;
}
;
using
ReturnJNIType
=
typename
Conditional
<
isVoid
VoidType
TypeAdapter
<
ReturnType
>
>
:
:
Type
:
:
JNIType
;
using
ReturnTypeForNonVoidInstance
=
typename
Conditional
<
!
isStatic
&
&
!
isVoid
ReturnType
VoidType
>
:
:
Type
;
using
ReturnTypeForVoidInstance
=
typename
Conditional
<
!
isStatic
&
&
isVoid
ReturnType
VoidType
&
>
:
:
Type
;
using
ReturnTypeForNonVoidStatic
=
typename
Conditional
<
isStatic
&
&
!
isVoid
ReturnType
VoidType
>
:
:
Type
;
using
ReturnTypeForVoidStatic
=
typename
Conditional
<
isStatic
&
&
isVoid
ReturnType
VoidType
&
>
:
:
Type
;
static_assert
(
Traits
:
:
dispatchTarget
=
=
DispatchTarget
:
:
CURRENT
|
|
isVoid
"
Dispatched
calls
must
have
void
return
type
"
)
;
public
:
template
<
ReturnTypeForNonVoidInstance
(
Impl
:
:
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
Impl
*
const
impl
=
NativePtr
<
Impl
>
:
:
Get
(
env
instance
)
;
if
(
!
impl
)
{
return
ReturnJNIType
(
)
;
}
return
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
impl
-
>
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
}
template
<
ReturnTypeForNonVoidInstance
(
Impl
:
:
*
Method
)
(
const
typename
Owner
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
Impl
*
const
impl
=
NativePtr
<
Impl
>
:
:
Get
(
env
instance
)
;
if
(
!
impl
)
{
return
ReturnJNIType
(
)
;
}
auto
self
=
Owner
:
:
LocalRef
:
:
Adopt
(
env
instance
)
;
const
auto
res
=
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
impl
-
>
*
Method
)
(
self
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
self
.
Forget
(
)
;
return
res
;
}
template
<
ReturnTypeForVoidInstance
(
Impl
:
:
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
false
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
instance
Method
env
args
.
.
.
)
;
return
;
}
Impl
*
const
impl
=
NativePtr
<
Impl
>
:
:
Get
(
env
instance
)
;
if
(
!
impl
)
{
return
;
}
(
impl
-
>
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
}
template
<
ReturnTypeForVoidInstance
(
Impl
:
:
*
Method
)
(
const
typename
Owner
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jobject
instance
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
true
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
instance
Method
env
args
.
.
.
)
;
return
;
}
Impl
*
const
impl
=
NativePtr
<
Impl
>
:
:
Get
(
env
instance
)
;
if
(
!
impl
)
{
return
;
}
auto
self
=
Owner
:
:
LocalRef
:
:
Adopt
(
env
instance
)
;
(
impl
-
>
*
Method
)
(
self
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
self
.
Forget
(
)
;
}
template
<
ReturnTypeForVoidInstance
(
*
DisposeNative
)
(
const
typename
Owner
:
:
LocalRef
&
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jobject
instance
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
using
LocalRef
=
typename
Owner
:
:
LocalRef
;
Dispatcher
<
Impl
false
const
LocalRef
&
>
:
:
template
Run
<
Traits
true
>
(
nullptr
DisposeNative
env
instance
)
;
return
;
}
auto
self
=
Owner
:
:
LocalRef
:
:
Adopt
(
env
instance
)
;
DisposeNative
(
self
)
;
self
.
Forget
(
)
;
}
template
<
ReturnTypeForNonVoidStatic
(
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jclass
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
return
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
}
template
<
ReturnTypeForNonVoidStatic
(
*
Method
)
(
const
Class
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
ReturnJNIType
Wrap
(
JNIEnv
*
env
jclass
cls
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
auto
clazz
=
Class
:
:
LocalRef
:
:
Adopt
(
env
cls
)
;
const
auto
res
=
TypeAdapter
<
ReturnType
>
:
:
FromNative
(
env
(
*
Method
)
(
clazz
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
)
;
clazz
.
Forget
(
)
;
return
res
;
}
template
<
ReturnTypeForVoidStatic
(
*
Method
)
(
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jclass
cls
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
false
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
cls
Method
env
args
.
.
.
)
;
return
;
}
(
*
Method
)
(
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
}
template
<
ReturnTypeForVoidStatic
(
*
Method
)
(
const
Class
:
:
LocalRef
&
Args
.
.
.
)
>
static
MOZ_JNICALL
void
Wrap
(
JNIEnv
*
env
jclass
cls
typename
TypeAdapter
<
Args
>
:
:
JNIType
.
.
.
args
)
{
MOZ_ASSERT_JNI_THREAD
(
Traits
:
:
callingThread
)
;
if
(
Traits
:
:
dispatchTarget
!
=
DispatchTarget
:
:
CURRENT
)
{
Dispatcher
<
Impl
true
Args
.
.
.
>
:
:
template
Run
<
Traits
>
(
cls
Method
env
args
.
.
.
)
;
return
;
}
auto
clazz
=
Class
:
:
LocalRef
:
:
Adopt
(
env
cls
)
;
(
*
Method
)
(
clazz
TypeAdapter
<
Args
>
:
:
ToNative
(
env
args
)
.
.
.
)
;
clazz
.
Forget
(
)
;
}
}
;
template
<
class
Traits
typename
Ret
typename
.
.
.
Args
>
constexpr
JNINativeMethod
MakeNativeMethod
(
MOZ_JNICALL
Ret
(
*
stub
)
(
JNIEnv
*
Args
.
.
.
)
)
{
return
{
Traits
:
:
name
Traits
:
:
signature
reinterpret_cast
<
void
*
>
(
stub
)
}
;
}
template
<
class
Cls
class
Impl
>
class
NativeImpl
{
typedef
typename
Cls
:
:
template
Natives
<
Impl
>
Natives
;
static
bool
sInited
;
public
:
static
void
Init
(
)
{
if
(
sInited
)
{
return
;
}
const
auto
&
ctx
=
typename
Cls
:
:
Context
(
)
;
ctx
.
Env
(
)
-
>
RegisterNatives
(
ctx
.
ClassRef
(
)
Natives
:
:
methods
sizeof
(
Natives
:
:
methods
)
/
sizeof
(
Natives
:
:
methods
[
0
]
)
)
;
MOZ_CATCH_JNI_EXCEPTION
(
ctx
.
Env
(
)
)
;
sInited
=
true
;
}
protected
:
static
void
AttachNative
(
const
typename
Cls
:
:
LocalRef
&
instance
SupportsWeakPtr
<
Impl
>
*
ptr
)
{
static_assert
(
NativePtrPicker
<
Impl
>
:
:
value
=
=
NativePtrType
:
:
WEAK
"
Use
another
AttachNative
for
non
-
WeakPtr
usage
"
)
;
return
NativePtr
<
Impl
>
:
:
Set
(
instance
static_cast
<
Impl
*
>
(
ptr
)
)
;
}
static
void
AttachNative
(
const
typename
Cls
:
:
LocalRef
&
instance
UniquePtr
<
Impl
>
&
&
ptr
)
{
static_assert
(
NativePtrPicker
<
Impl
>
:
:
value
=
=
NativePtrType
:
:
OWNING
"
Use
another
AttachNative
for
WeakPtr
or
RefPtr
usage
"
)
;
return
NativePtr
<
Impl
>
:
:
Set
(
instance
mozilla
:
:
Move
(
ptr
)
)
;
}
static
void
AttachNative
(
const
typename
Cls
:
:
LocalRef
&
instance
Impl
*
ptr
)
{
static_assert
(
NativePtrPicker
<
Impl
>
:
:
value
=
=
NativePtrType
:
:
REFPTR
"
Use
another
AttachNative
for
non
-
RefPtr
usage
"
)
;
return
NativePtr
<
Impl
>
:
:
Set
(
instance
ptr
)
;
}
static
Impl
*
GetNative
(
const
typename
Cls
:
:
LocalRef
&
instance
)
{
return
NativePtr
<
Impl
>
:
:
Get
(
instance
)
;
}
static
void
DisposeNative
(
const
typename
Cls
:
:
LocalRef
&
instance
)
{
NativePtr
<
Impl
>
:
:
Clear
(
instance
)
;
}
NativeImpl
(
)
{
Init
(
)
;
}
}
;
template
<
class
C
class
I
>
bool
NativeImpl
<
C
I
>
:
:
sInited
;
}
}
#
endif
