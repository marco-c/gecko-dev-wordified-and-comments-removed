#
include
"
AndroidBridge
.
h
"
#
include
"
base
/
message_loop
.
h
"
#
include
"
mozilla
/
Monitor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsThread
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
namespace
{
class
AndroidUiThread
;
StaticRefPtr
<
AndroidUiThread
>
sThread
;
static
MessageLoop
*
sMessageLoop
;
class
AndroidUiThread
:
public
nsThread
{
public
:
NS_DECL_ISUPPORTS_INHERITED
AndroidUiThread
(
)
:
nsThread
(
nsThread
:
:
NOT_MAIN_THREAD
0
)
{
}
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
override
;
nsresult
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
override
;
private
:
~
AndroidUiThread
(
)
{
}
}
;
NS_IMPL_ISUPPORTS_INHERITED0
(
AndroidUiThread
nsThread
)
NS_IMETHODIMP
AndroidUiThread
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aFlags
)
{
if
(
aFlags
&
NS_DISPATCH_SYNC
)
{
return
nsThread
:
:
Dispatch
(
Move
(
aEvent
)
aFlags
)
;
}
else
{
AndroidBridge
:
:
Bridge
(
)
-
>
PostTaskToUiThread
(
Move
(
aEvent
)
0
)
;
return
NS_OK
;
}
}
NS_IMETHODIMP
AndroidUiThread
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
aEvent
uint32_t
aDelayMs
)
{
AndroidBridge
:
:
Bridge
(
)
-
>
PostTaskToUiThread
(
Move
(
aEvent
)
aDelayMs
)
;
return
NS_OK
;
}
static
void
PumpEvents
(
)
{
NS_ProcessPendingEvents
(
sThread
.
get
(
)
)
;
}
class
ThreadObserver
:
public
nsIThreadObserver
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSITHREADOBSERVER
ThreadObserver
(
)
{
}
private
:
virtual
~
ThreadObserver
(
)
{
}
}
;
NS_IMPL_ISUPPORTS
(
ThreadObserver
nsIThreadObserver
)
NS_IMETHODIMP
ThreadObserver
:
:
OnDispatchedEvent
(
nsIThreadInternal
*
thread
)
{
AndroidBridge
:
:
Bridge
(
)
-
>
PostTaskToUiThread
(
NS_NewRunnableFunction
(
&
PumpEvents
)
0
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThreadObserver
:
:
OnProcessNextEvent
(
nsIThreadInternal
*
thread
bool
mayWait
)
{
return
NS_OK
;
}
NS_IMETHODIMP
ThreadObserver
:
:
AfterProcessNextEvent
(
nsIThreadInternal
*
thread
bool
eventWasProcessed
)
{
return
NS_OK
;
}
class
CreateOnUiThread
:
public
Runnable
{
public
:
CreateOnUiThread
(
)
:
mCreated
(
false
)
mThreadCreationMonitor
(
"
AndroidUiThreadCreationLock
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
MonitorAutoLock
lock
(
mThreadCreationMonitor
)
;
sThread
=
new
AndroidUiThread
(
)
;
sThread
-
>
InitCurrentThread
(
)
;
sThread
-
>
SetObserver
(
new
ThreadObserver
(
)
)
;
sMessageLoop
=
new
MessageLoop
(
MessageLoop
:
:
TYPE_MOZILLA_ANDROID_UI
sThread
.
get
(
)
)
;
mCreated
=
true
;
lock
.
NotifyAll
(
)
;
return
NS_OK
;
}
void
WaitForCreation
(
)
{
MonitorAutoLock
lock
(
mThreadCreationMonitor
)
;
while
(
!
mCreated
)
{
lock
.
Wait
(
)
;
}
}
private
:
bool
mCreated
;
Monitor
mThreadCreationMonitor
;
}
;
class
DestroyOnUiThread
:
public
Runnable
{
public
:
DestroyOnUiThread
(
)
:
mDestroyed
(
false
)
mThreadDestructionMonitor
(
"
AndroidUiThreadCreationLock
"
)
{
}
NS_IMETHOD
Run
(
)
override
{
MonitorAutoLock
lock
(
mThreadDestructionMonitor
)
;
delete
sMessageLoop
;
sMessageLoop
=
nullptr
;
MOZ_ASSERT
(
sThread
)
;
nsThreadManager
:
:
get
(
)
.
UnregisterCurrentThread
(
*
sThread
)
;
sThread
=
nullptr
;
mDestroyed
=
true
;
lock
.
NotifyAll
(
)
;
return
NS_OK
;
}
void
WaitForDestruction
(
)
{
MonitorAutoLock
lock
(
mThreadDestructionMonitor
)
;
while
(
!
mDestroyed
)
{
lock
.
Wait
(
)
;
}
}
private
:
bool
mDestroyed
;
Monitor
mThreadDestructionMonitor
;
}
;
}
namespace
mozilla
{
void
CreateAndroidUiThread
(
)
{
MOZ_ASSERT
(
!
sThread
)
;
RefPtr
<
CreateOnUiThread
>
runnable
=
new
CreateOnUiThread
;
AndroidBridge
:
:
Bridge
(
)
-
>
PostTaskToUiThread
(
do_AddRef
(
runnable
)
0
)
;
runnable
-
>
WaitForCreation
(
)
;
}
void
DestroyAndroidUiThread
(
)
{
MOZ_ASSERT
(
sThread
)
;
RefPtr
<
DestroyOnUiThread
>
runnable
=
new
DestroyOnUiThread
;
MOZ_ASSERT
(
AndroidBridge
:
:
Bridge
(
)
!
=
nullptr
)
;
AndroidBridge
:
:
Bridge
(
)
-
>
PostTaskToUiThread
(
do_AddRef
(
runnable
)
0
)
;
runnable
-
>
WaitForDestruction
(
)
;
}
MessageLoop
*
GetAndroidUiThreadMessageLoop
(
)
{
return
sMessageLoop
;
}
}
