#
include
"
GeckoEditableSupport
.
h
"
#
include
"
AndroidRect
.
h
"
#
include
"
KeyEvent
.
h
"
#
include
"
PuppetWidget
.
h
"
#
include
"
android_npapi
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
TextEventDispatcherListener
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
<
android
/
log
.
h
>
#
ifdef
DEBUG_ANDROID_IME
#
define
ALOGIME
(
args
.
.
.
)
__android_log_print
(
ANDROID_LOG_INFO
\
"
GeckoEditableSupport
"
#
#
args
)
#
else
#
define
ALOGIME
(
args
.
.
.
)
do
{
}
while
(
0
)
#
endif
template
<
>
const
char
nsWindow
:
:
NativePtr
<
mozilla
:
:
widget
:
:
GeckoEditableSupport
>
:
:
sName
[
]
=
"
GeckoEditableSupport
"
;
static
uint32_t
ConvertAndroidKeyCodeToDOMKeyCode
(
int32_t
androidKeyCode
)
{
if
(
androidKeyCode
>
=
AKEYCODE_A
&
&
androidKeyCode
<
=
AKEYCODE_Z
)
{
return
androidKeyCode
-
AKEYCODE_A
+
NS_VK_A
;
}
if
(
androidKeyCode
>
=
AKEYCODE_0
&
&
androidKeyCode
<
=
AKEYCODE_9
)
{
return
androidKeyCode
-
AKEYCODE_0
+
NS_VK_0
;
}
switch
(
androidKeyCode
)
{
case
AKEYCODE_BACK
:
return
NS_VK_ESCAPE
;
case
AKEYCODE_DPAD_UP
:
return
NS_VK_UP
;
case
AKEYCODE_DPAD_DOWN
:
return
NS_VK_DOWN
;
case
AKEYCODE_DPAD_LEFT
:
return
NS_VK_LEFT
;
case
AKEYCODE_DPAD_RIGHT
:
return
NS_VK_RIGHT
;
case
AKEYCODE_DPAD_CENTER
:
return
NS_VK_RETURN
;
case
AKEYCODE_VOLUME_UP
:
return
NS_VK_VOLUME_UP
;
case
AKEYCODE_VOLUME_DOWN
:
return
NS_VK_VOLUME_DOWN
;
case
AKEYCODE_COMMA
:
return
NS_VK_COMMA
;
case
AKEYCODE_PERIOD
:
return
NS_VK_PERIOD
;
case
AKEYCODE_ALT_LEFT
:
return
NS_VK_ALT
;
case
AKEYCODE_ALT_RIGHT
:
return
NS_VK_ALT
;
case
AKEYCODE_SHIFT_LEFT
:
return
NS_VK_SHIFT
;
case
AKEYCODE_SHIFT_RIGHT
:
return
NS_VK_SHIFT
;
case
AKEYCODE_TAB
:
return
NS_VK_TAB
;
case
AKEYCODE_SPACE
:
return
NS_VK_SPACE
;
case
AKEYCODE_ENTER
:
return
NS_VK_RETURN
;
case
AKEYCODE_DEL
:
return
NS_VK_BACK
;
case
AKEYCODE_GRAVE
:
return
NS_VK_BACK_QUOTE
;
case
AKEYCODE_EQUALS
:
return
NS_VK_EQUALS
;
case
AKEYCODE_LEFT_BRACKET
:
return
NS_VK_OPEN_BRACKET
;
case
AKEYCODE_RIGHT_BRACKET
:
return
NS_VK_CLOSE_BRACKET
;
case
AKEYCODE_BACKSLASH
:
return
NS_VK_BACK_SLASH
;
case
AKEYCODE_SEMICOLON
:
return
NS_VK_SEMICOLON
;
case
AKEYCODE_SLASH
:
return
NS_VK_SLASH
;
case
AKEYCODE_MUTE
:
return
NS_VK_VOLUME_MUTE
;
case
AKEYCODE_PAGE_UP
:
return
NS_VK_PAGE_UP
;
case
AKEYCODE_PAGE_DOWN
:
return
NS_VK_PAGE_DOWN
;
case
AKEYCODE_ESCAPE
:
return
NS_VK_ESCAPE
;
case
AKEYCODE_FORWARD_DEL
:
return
NS_VK_DELETE
;
case
AKEYCODE_CTRL_LEFT
:
return
NS_VK_CONTROL
;
case
AKEYCODE_CTRL_RIGHT
:
return
NS_VK_CONTROL
;
case
AKEYCODE_CAPS_LOCK
:
return
NS_VK_CAPS_LOCK
;
case
AKEYCODE_SCROLL_LOCK
:
return
NS_VK_SCROLL_LOCK
;
case
AKEYCODE_SYSRQ
:
return
NS_VK_PRINTSCREEN
;
case
AKEYCODE_BREAK
:
return
NS_VK_PAUSE
;
case
AKEYCODE_MOVE_HOME
:
return
NS_VK_HOME
;
case
AKEYCODE_MOVE_END
:
return
NS_VK_END
;
case
AKEYCODE_INSERT
:
return
NS_VK_INSERT
;
case
AKEYCODE_F1
:
return
NS_VK_F1
;
case
AKEYCODE_F2
:
return
NS_VK_F2
;
case
AKEYCODE_F3
:
return
NS_VK_F3
;
case
AKEYCODE_F4
:
return
NS_VK_F4
;
case
AKEYCODE_F5
:
return
NS_VK_F5
;
case
AKEYCODE_F6
:
return
NS_VK_F6
;
case
AKEYCODE_F7
:
return
NS_VK_F7
;
case
AKEYCODE_F8
:
return
NS_VK_F8
;
case
AKEYCODE_F9
:
return
NS_VK_F9
;
case
AKEYCODE_F10
:
return
NS_VK_F10
;
case
AKEYCODE_F11
:
return
NS_VK_F11
;
case
AKEYCODE_F12
:
return
NS_VK_F12
;
case
AKEYCODE_NUM_LOCK
:
return
NS_VK_NUM_LOCK
;
case
AKEYCODE_NUMPAD_0
:
return
NS_VK_NUMPAD0
;
case
AKEYCODE_NUMPAD_1
:
return
NS_VK_NUMPAD1
;
case
AKEYCODE_NUMPAD_2
:
return
NS_VK_NUMPAD2
;
case
AKEYCODE_NUMPAD_3
:
return
NS_VK_NUMPAD3
;
case
AKEYCODE_NUMPAD_4
:
return
NS_VK_NUMPAD4
;
case
AKEYCODE_NUMPAD_5
:
return
NS_VK_NUMPAD5
;
case
AKEYCODE_NUMPAD_6
:
return
NS_VK_NUMPAD6
;
case
AKEYCODE_NUMPAD_7
:
return
NS_VK_NUMPAD7
;
case
AKEYCODE_NUMPAD_8
:
return
NS_VK_NUMPAD8
;
case
AKEYCODE_NUMPAD_9
:
return
NS_VK_NUMPAD9
;
case
AKEYCODE_NUMPAD_DIVIDE
:
return
NS_VK_DIVIDE
;
case
AKEYCODE_NUMPAD_MULTIPLY
:
return
NS_VK_MULTIPLY
;
case
AKEYCODE_NUMPAD_SUBTRACT
:
return
NS_VK_SUBTRACT
;
case
AKEYCODE_NUMPAD_ADD
:
return
NS_VK_ADD
;
case
AKEYCODE_NUMPAD_DOT
:
return
NS_VK_DECIMAL
;
case
AKEYCODE_NUMPAD_COMMA
:
return
NS_VK_SEPARATOR
;
case
AKEYCODE_NUMPAD_ENTER
:
return
NS_VK_RETURN
;
case
AKEYCODE_NUMPAD_EQUALS
:
return
NS_VK_EQUALS
;
case
AKEYCODE_ZENKAKU_HANKAKU
:
return
0
;
case
AKEYCODE_EISU
:
return
NS_VK_EISU
;
case
AKEYCODE_MUHENKAN
:
return
NS_VK_NONCONVERT
;
case
AKEYCODE_HENKAN
:
return
NS_VK_CONVERT
;
case
AKEYCODE_KATAKANA_HIRAGANA
:
return
0
;
case
AKEYCODE_YEN
:
return
NS_VK_BACK_SLASH
;
case
AKEYCODE_RO
:
return
NS_VK_BACK_SLASH
;
case
AKEYCODE_KANA
:
return
NS_VK_KANA
;
case
AKEYCODE_ASSIST
:
return
NS_VK_HELP
;
case
AKEYCODE_BUTTON_A
:
return
NS_VK_RETURN
;
default
:
ALOG
(
"
ConvertAndroidKeyCodeToDOMKeyCode
:
"
"
No
DOM
keycode
for
Android
keycode
%
d
"
int
(
androidKeyCode
)
)
;
return
0
;
}
}
static
KeyNameIndex
ConvertAndroidKeyCodeToKeyNameIndex
(
int32_t
keyCode
int32_t
action
int32_t
domPrintableKeyValue
)
{
if
(
keyCode
>
=
AKEYCODE_A
&
&
keyCode
<
=
AKEYCODE_Z
)
{
return
KEY_NAME_INDEX_USE_STRING
;
}
if
(
keyCode
>
=
AKEYCODE_0
&
&
keyCode
<
=
AKEYCODE_9
)
{
return
KEY_NAME_INDEX_USE_STRING
;
}
switch
(
keyCode
)
{
#
define
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
(
aNativeKey
aKeyNameIndex
)
\
case
aNativeKey
:
return
aKeyNameIndex
;
#
include
"
NativeKeyToDOMKeyName
.
h
"
#
undef
NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
case
AKEYCODE_STAR
:
case
AKEYCODE_POUND
:
case
AKEYCODE_COMMA
:
case
AKEYCODE_PERIOD
:
case
AKEYCODE_SPACE
:
case
AKEYCODE_GRAVE
:
case
AKEYCODE_MINUS
:
case
AKEYCODE_EQUALS
:
case
AKEYCODE_LEFT_BRACKET
:
case
AKEYCODE_RIGHT_BRACKET
:
case
AKEYCODE_BACKSLASH
:
case
AKEYCODE_SEMICOLON
:
case
AKEYCODE_APOSTROPHE
:
case
AKEYCODE_SLASH
:
case
AKEYCODE_AT
:
case
AKEYCODE_PLUS
:
case
AKEYCODE_NUMPAD_0
:
case
AKEYCODE_NUMPAD_1
:
case
AKEYCODE_NUMPAD_2
:
case
AKEYCODE_NUMPAD_3
:
case
AKEYCODE_NUMPAD_4
:
case
AKEYCODE_NUMPAD_5
:
case
AKEYCODE_NUMPAD_6
:
case
AKEYCODE_NUMPAD_7
:
case
AKEYCODE_NUMPAD_8
:
case
AKEYCODE_NUMPAD_9
:
case
AKEYCODE_NUMPAD_DIVIDE
:
case
AKEYCODE_NUMPAD_MULTIPLY
:
case
AKEYCODE_NUMPAD_SUBTRACT
:
case
AKEYCODE_NUMPAD_ADD
:
case
AKEYCODE_NUMPAD_DOT
:
case
AKEYCODE_NUMPAD_COMMA
:
case
AKEYCODE_NUMPAD_EQUALS
:
case
AKEYCODE_NUMPAD_LEFT_PAREN
:
case
AKEYCODE_NUMPAD_RIGHT_PAREN
:
case
AKEYCODE_YEN
:
case
AKEYCODE_RO
:
return
KEY_NAME_INDEX_USE_STRING
;
case
AKEYCODE_NUM
:
case
AKEYCODE_PICTSYMBOLS
:
case
AKEYCODE_BUTTON_A
:
case
AKEYCODE_BUTTON_B
:
case
AKEYCODE_BUTTON_C
:
case
AKEYCODE_BUTTON_X
:
case
AKEYCODE_BUTTON_Y
:
case
AKEYCODE_BUTTON_Z
:
case
AKEYCODE_BUTTON_L1
:
case
AKEYCODE_BUTTON_R1
:
case
AKEYCODE_BUTTON_L2
:
case
AKEYCODE_BUTTON_R2
:
case
AKEYCODE_BUTTON_THUMBL
:
case
AKEYCODE_BUTTON_THUMBR
:
case
AKEYCODE_BUTTON_START
:
case
AKEYCODE_BUTTON_SELECT
:
case
AKEYCODE_BUTTON_MODE
:
case
AKEYCODE_MEDIA_CLOSE
:
case
AKEYCODE_BUTTON_1
:
case
AKEYCODE_BUTTON_2
:
case
AKEYCODE_BUTTON_3
:
case
AKEYCODE_BUTTON_4
:
case
AKEYCODE_BUTTON_5
:
case
AKEYCODE_BUTTON_6
:
case
AKEYCODE_BUTTON_7
:
case
AKEYCODE_BUTTON_8
:
case
AKEYCODE_BUTTON_9
:
case
AKEYCODE_BUTTON_10
:
case
AKEYCODE_BUTTON_11
:
case
AKEYCODE_BUTTON_12
:
case
AKEYCODE_BUTTON_13
:
case
AKEYCODE_BUTTON_14
:
case
AKEYCODE_BUTTON_15
:
case
AKEYCODE_BUTTON_16
:
return
KEY_NAME_INDEX_Unidentified
;
case
AKEYCODE_UNKNOWN
:
MOZ_ASSERT
(
action
!
=
AKEY_EVENT_ACTION_MULTIPLE
"
Don
'
t
call
this
when
action
is
AKEY_EVENT_ACTION_MULTIPLE
!
"
)
;
return
domPrintableKeyValue
?
KEY_NAME_INDEX_USE_STRING
:
KEY_NAME_INDEX_Unidentified
;
default
:
ALOG
(
"
ConvertAndroidKeyCodeToKeyNameIndex
:
"
"
No
DOM
key
name
index
for
Android
keycode
%
d
"
keyCode
)
;
return
KEY_NAME_INDEX_Unidentified
;
}
}
static
CodeNameIndex
ConvertAndroidScanCodeToCodeNameIndex
(
int32_t
scanCode
)
{
switch
(
scanCode
)
{
#
define
NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
(
aNativeKey
aCodeNameIndex
)
\
case
aNativeKey
:
return
aCodeNameIndex
;
#
include
"
NativeKeyToDOMCodeName
.
h
"
#
undef
NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
default
:
return
CODE_NAME_INDEX_UNKNOWN
;
}
}
static
void
InitKeyEvent
(
WidgetKeyboardEvent
&
aEvent
int32_t
aAction
int32_t
aKeyCode
int32_t
aScanCode
int32_t
aMetaState
int64_t
aTime
int32_t
aDomPrintableKeyValue
int32_t
aRepeatCount
int32_t
aFlags
)
{
const
uint32_t
domKeyCode
=
ConvertAndroidKeyCodeToDOMKeyCode
(
aKeyCode
)
;
aEvent
.
mModifiers
=
nsWindow
:
:
GetModifiers
(
aMetaState
)
;
aEvent
.
mKeyCode
=
domKeyCode
;
if
(
aEvent
.
mMessage
!
=
eKeyPress
)
{
ANPEvent
pluginEvent
;
pluginEvent
.
inSize
=
sizeof
(
pluginEvent
)
;
pluginEvent
.
eventType
=
kKey_ANPEventType
;
pluginEvent
.
data
.
key
.
action
=
(
aEvent
.
mMessage
=
=
eKeyDown
)
?
kDown_ANPKeyAction
:
kUp_ANPKeyAction
;
pluginEvent
.
data
.
key
.
nativeCode
=
aKeyCode
;
pluginEvent
.
data
.
key
.
virtualCode
=
domKeyCode
;
pluginEvent
.
data
.
key
.
unichar
=
aDomPrintableKeyValue
;
pluginEvent
.
data
.
key
.
modifiers
=
(
aMetaState
&
sdk
:
:
KeyEvent
:
:
META_SHIFT_MASK
?
kShift_ANPKeyModifier
:
0
)
|
(
aMetaState
&
sdk
:
:
KeyEvent
:
:
META_ALT_MASK
?
kAlt_ANPKeyModifier
:
0
)
;
pluginEvent
.
data
.
key
.
repeatCount
=
aRepeatCount
;
aEvent
.
mPluginEvent
.
Copy
(
pluginEvent
)
;
}
aEvent
.
mIsRepeat
=
(
aEvent
.
mMessage
=
=
eKeyDown
|
|
aEvent
.
mMessage
=
=
eKeyPress
)
&
&
(
(
aFlags
&
sdk
:
:
KeyEvent
:
:
FLAG_LONG_PRESS
)
|
|
aRepeatCount
)
;
aEvent
.
mKeyNameIndex
=
ConvertAndroidKeyCodeToKeyNameIndex
(
aKeyCode
aAction
aDomPrintableKeyValue
)
;
aEvent
.
mCodeNameIndex
=
ConvertAndroidScanCodeToCodeNameIndex
(
aScanCode
)
;
if
(
aEvent
.
mKeyNameIndex
=
=
KEY_NAME_INDEX_USE_STRING
&
&
aDomPrintableKeyValue
)
{
aEvent
.
mKeyValue
=
char16_t
(
aDomPrintableKeyValue
)
;
}
aEvent
.
mLocation
=
WidgetKeyboardEvent
:
:
ComputeLocationFromCodeValue
(
aEvent
.
mCodeNameIndex
)
;
aEvent
.
mTime
=
aTime
;
aEvent
.
mTimeStamp
=
nsWindow
:
:
GetEventTimeStamp
(
aTime
)
;
}
static
nscolor
ConvertAndroidColor
(
uint32_t
aArgb
)
{
return
NS_RGBA
(
(
aArgb
&
0x00ff0000
)
>
>
16
(
aArgb
&
0x0000ff00
)
>
>
8
(
aArgb
&
0x000000ff
)
(
aArgb
&
0xff000000
)
>
>
24
)
;
}
static
jni
:
:
ObjectArray
:
:
LocalRef
ConvertRectArrayToJavaRectFArray
(
const
nsTArray
<
LayoutDeviceIntRect
>
&
aRects
const
LayoutDeviceIntPoint
&
aOffset
const
CSSToLayoutDeviceScale
aScale
)
{
const
size_t
length
=
aRects
.
Length
(
)
;
auto
rects
=
jni
:
:
ObjectArray
:
:
New
<
sdk
:
:
RectF
>
(
length
)
;
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
LayoutDeviceIntRect
tmp
=
aRects
[
i
]
+
aOffset
;
sdk
:
:
RectF
:
:
LocalRef
rect
(
rects
.
Env
(
)
)
;
sdk
:
:
RectF
:
:
New
(
tmp
.
x
/
aScale
.
scale
tmp
.
y
/
aScale
.
scale
(
tmp
.
x
+
tmp
.
width
)
/
aScale
.
scale
(
tmp
.
y
+
tmp
.
height
)
/
aScale
.
scale
&
rect
)
;
rects
-
>
SetElement
(
i
rect
)
;
}
return
rects
;
}
namespace
mozilla
{
namespace
widget
{
NS_IMPL_ISUPPORTS
(
GeckoEditableSupport
TextEventDispatcherListener
nsISupportsWeakReference
)
RefPtr
<
TextComposition
>
GeckoEditableSupport
:
:
GetComposition
(
)
const
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
return
widget
?
IMEStateManager
:
:
GetTextCompositionFor
(
widget
)
:
nullptr
;
}
void
GeckoEditableSupport
:
:
RemoveComposition
(
RemoveCompositionFlag
aFlag
)
{
if
(
!
mDispatcher
|
|
!
mDispatcher
-
>
IsComposing
(
)
)
{
return
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
NS_ENSURE_SUCCESS_VOID
(
BeginInputTransaction
(
mDispatcher
)
)
;
mDispatcher
-
>
CommitComposition
(
status
aFlag
=
=
CANCEL_IME_COMPOSITION
?
&
EmptyString
(
)
:
nullptr
)
;
}
void
GeckoEditableSupport
:
:
OnKeyEvent
(
int32_t
aAction
int32_t
aKeyCode
int32_t
aScanCode
int32_t
aMetaState
int32_t
aKeyPressMetaState
int64_t
aTime
int32_t
aDomPrintableKeyValue
int32_t
aRepeatCount
int32_t
aFlags
bool
aIsSynthesizedImeKey
jni
:
:
Object
:
:
Param
aOriginalEvent
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
RefPtr
<
TextEventDispatcher
>
dispatcher
=
mDispatcher
?
mDispatcher
.
get
(
)
:
widget
?
widget
-
>
GetTextEventDispatcher
(
)
:
nullptr
;
NS_ENSURE_TRUE_VOID
(
dispatcher
&
&
widget
)
;
if
(
!
aIsSynthesizedImeKey
&
&
mWindow
)
{
mWindow
-
>
UserActivity
(
)
;
}
else
if
(
aIsSynthesizedImeKey
&
&
mIMEMaskEventsCount
>
0
)
{
return
;
}
EventMessage
msg
;
if
(
aAction
=
=
sdk
:
:
KeyEvent
:
:
ACTION_DOWN
)
{
msg
=
eKeyDown
;
}
else
if
(
aAction
=
=
sdk
:
:
KeyEvent
:
:
ACTION_UP
)
{
msg
=
eKeyUp
;
}
else
if
(
aAction
=
=
sdk
:
:
KeyEvent
:
:
ACTION_MULTIPLE
)
{
MOZ_CRASH
(
"
Cannot
handle
key
with
multiple
action
"
)
;
}
else
{
NS_WARNING
(
"
Unknown
key
action
event
"
)
;
return
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetKeyboardEvent
event
(
true
msg
widget
)
;
InitKeyEvent
(
event
aAction
aKeyCode
aScanCode
aMetaState
aTime
aDomPrintableKeyValue
aRepeatCount
aFlags
)
;
if
(
aIsSynthesizedImeKey
)
{
mIMEKeyEvents
.
AppendElement
(
UniquePtr
<
WidgetEvent
>
(
event
.
Duplicate
(
)
)
)
;
}
else
{
RemoveComposition
(
)
;
NS_ENSURE_SUCCESS_VOID
(
BeginInputTransaction
(
dispatcher
)
)
;
dispatcher
-
>
DispatchKeyboardEvent
(
msg
event
status
)
;
if
(
widget
-
>
Destroyed
(
)
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
;
}
mEditable
-
>
OnDefaultKeyEvent
(
aOriginalEvent
)
;
}
if
(
msg
!
=
eKeyDown
)
{
return
;
}
WidgetKeyboardEvent
pressEvent
(
true
eKeyPress
widget
)
;
InitKeyEvent
(
pressEvent
aAction
aKeyCode
aScanCode
aKeyPressMetaState
aTime
aDomPrintableKeyValue
aRepeatCount
aFlags
)
;
if
(
aIsSynthesizedImeKey
)
{
mIMEKeyEvents
.
AppendElement
(
UniquePtr
<
WidgetEvent
>
(
pressEvent
.
Duplicate
(
)
)
)
;
}
else
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
)
{
AutoCacheNativeKeyCommands
autoCache
(
static_cast
<
PuppetWidget
*
>
(
widget
.
get
(
)
)
)
;
autoCache
.
CacheNoCommands
(
)
;
dispatcher
-
>
MaybeDispatchKeypressEvents
(
pressEvent
status
)
;
}
else
{
dispatcher
-
>
MaybeDispatchKeypressEvents
(
pressEvent
status
)
;
}
}
void
GeckoEditableSupport
:
:
SendIMEDummyKeyEvent
(
nsIWidget
*
aWidget
EventMessage
msg
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
MOZ_ASSERT
(
mDispatcher
)
;
WidgetKeyboardEvent
event
(
true
msg
aWidget
)
;
event
.
mTime
=
PR_Now
(
)
/
1000
;
MOZ_ASSERT
(
event
.
mKeyCode
=
=
0
)
;
NS_ENSURE_SUCCESS_VOID
(
BeginInputTransaction
(
mDispatcher
)
)
;
mDispatcher
-
>
DispatchKeyboardEvent
(
msg
event
status
)
;
}
void
GeckoEditableSupport
:
:
AddIMETextChange
(
const
IMETextChange
&
aChange
)
{
mIMETextChanges
.
AppendElement
(
aChange
)
;
mIMETextChangedDuringFlush
=
true
;
const
int32_t
delta
=
aChange
.
mNewEnd
-
aChange
.
mOldEnd
;
for
(
int32_t
i
=
mIMETextChanges
.
Length
(
)
-
2
;
i
>
=
0
;
i
-
-
)
{
IMETextChange
&
previousChange
=
mIMETextChanges
[
i
]
;
if
(
previousChange
.
mStart
>
aChange
.
mOldEnd
)
{
previousChange
.
mStart
+
=
delta
;
previousChange
.
mOldEnd
+
=
delta
;
previousChange
.
mNewEnd
+
=
delta
;
}
}
int32_t
srcIndex
=
mIMETextChanges
.
Length
(
)
-
1
;
int32_t
dstIndex
=
srcIndex
;
while
(
-
-
dstIndex
>
=
0
)
{
IMETextChange
&
src
=
mIMETextChanges
[
srcIndex
]
;
IMETextChange
&
dst
=
mIMETextChanges
[
dstIndex
]
;
if
(
src
.
mOldEnd
<
dst
.
mStart
|
|
dst
.
mNewEnd
<
src
.
mStart
)
{
continue
;
}
dst
.
mStart
=
std
:
:
min
(
dst
.
mStart
src
.
mStart
)
;
if
(
src
.
mOldEnd
<
dst
.
mNewEnd
)
{
dst
.
mNewEnd
+
=
src
.
mNewEnd
-
src
.
mOldEnd
;
}
else
{
dst
.
mOldEnd
+
=
src
.
mOldEnd
-
dst
.
mNewEnd
;
dst
.
mNewEnd
=
src
.
mNewEnd
;
}
mIMETextChanges
.
RemoveElementAt
(
srcIndex
)
;
srcIndex
=
dstIndex
;
}
}
void
GeckoEditableSupport
:
:
PostFlushIMEChanges
(
)
{
if
(
!
mIMETextChanges
.
IsEmpty
(
)
|
|
mIMESelectionChanged
)
{
return
;
}
RefPtr
<
GeckoEditableSupport
>
self
(
this
)
;
nsAppShell
:
:
PostEvent
(
[
this
self
]
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
if
(
widget
&
&
!
widget
-
>
Destroyed
(
)
)
{
FlushIMEChanges
(
)
;
}
}
)
;
}
void
GeckoEditableSupport
:
:
FlushIMEChanges
(
FlushChangesFlag
aFlags
)
{
NS_ENSURE_TRUE_VOID
(
!
mIMEMaskEventsCount
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
NS_ENSURE_TRUE_VOID
(
widget
)
;
struct
TextRecord
{
nsString
text
;
int32_t
start
;
int32_t
oldEnd
;
int32_t
newEnd
;
}
;
AutoTArray
<
TextRecord
4
>
textTransaction
;
textTransaction
.
SetCapacity
(
mIMETextChanges
.
Length
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mIMETextChangedDuringFlush
=
false
;
auto
shouldAbort
=
[
=
]
(
bool
aForce
)
-
>
bool
{
if
(
!
aForce
&
&
!
mIMETextChangedDuringFlush
)
{
return
false
;
}
if
(
aFlags
=
=
FLUSH_FLAG_NONE
)
{
FlushIMEChanges
(
FLUSH_FLAG_RETRY
)
;
}
else
{
__android_log_print
(
ANDROID_LOG_WARN
"
GeckoEditableSupport
"
"
Already
retrying
IME
flush
"
)
;
}
return
true
;
}
;
for
(
const
IMETextChange
&
change
:
mIMETextChanges
)
{
if
(
change
.
mStart
=
=
change
.
mOldEnd
&
&
change
.
mStart
=
=
change
.
mNewEnd
)
{
continue
;
}
WidgetQueryContentEvent
event
(
true
eQueryTextContent
widget
)
;
if
(
change
.
mNewEnd
!
=
change
.
mStart
)
{
event
.
InitForQueryTextContent
(
change
.
mStart
change
.
mNewEnd
-
change
.
mStart
)
;
widget
-
>
DispatchEvent
(
&
event
status
)
;
if
(
shouldAbort
(
NS_WARN_IF
(
!
event
.
mSucceeded
)
)
)
{
return
;
}
}
textTransaction
.
AppendElement
(
TextRecord
{
event
.
mReply
.
mString
change
.
mStart
change
.
mOldEnd
change
.
mNewEnd
}
)
;
}
int32_t
selStart
=
-
1
;
int32_t
selEnd
=
-
1
;
if
(
mIMESelectionChanged
)
{
WidgetQueryContentEvent
event
(
true
eQuerySelectedText
widget
)
;
widget
-
>
DispatchEvent
(
&
event
status
)
;
if
(
shouldAbort
(
NS_WARN_IF
(
!
event
.
mSucceeded
)
)
)
{
return
;
}
selStart
=
int32_t
(
event
.
GetSelectionStart
(
)
)
;
selEnd
=
int32_t
(
event
.
GetSelectionEnd
(
)
)
;
}
JNIEnv
*
const
env
=
jni
:
:
GetGeckoThreadEnv
(
)
;
auto
flushOnException
=
[
=
]
(
)
-
>
bool
{
if
(
!
env
-
>
ExceptionCheck
(
)
)
{
return
false
;
}
if
(
aFlags
!
=
FLUSH_FLAG_RECOVER
)
{
env
-
>
ExceptionClear
(
)
;
__android_log_print
(
ANDROID_LOG_WARN
"
GeckoEditableSupport
"
"
Recovering
from
IME
exception
"
)
;
FlushIMEText
(
FLUSH_FLAG_RECOVER
)
;
}
else
{
MOZ_CATCH_JNI_EXCEPTION
(
env
)
;
}
return
true
;
}
;
mIMETextChanges
.
Clear
(
)
;
for
(
const
TextRecord
&
record
:
textTransaction
)
{
mEditable
-
>
OnTextChange
(
record
.
text
record
.
start
record
.
oldEnd
record
.
newEnd
)
;
if
(
flushOnException
(
)
)
{
return
;
}
}
if
(
mIMESelectionChanged
)
{
mIMESelectionChanged
=
false
;
mEditable
-
>
OnSelectionChange
(
selStart
selEnd
)
;
flushOnException
(
)
;
}
}
void
GeckoEditableSupport
:
:
FlushIMEText
(
FlushChangesFlag
aFlags
)
{
mIMETextChanges
.
Clear
(
)
;
mIMESelectionChanged
=
true
;
IMENotification
notification
(
NOTIFY_IME_OF_TEXT_CHANGE
)
;
notification
.
mTextChangeData
.
mStartOffset
=
0
;
notification
.
mTextChangeData
.
mRemovedEndOffset
=
INT32_MAX
/
2
;
notification
.
mTextChangeData
.
mAddedEndOffset
=
INT32_MAX
/
2
;
NotifyIME
(
mDispatcher
notification
)
;
FlushIMEChanges
(
aFlags
)
;
}
void
GeckoEditableSupport
:
:
UpdateCompositionRects
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
RefPtr
<
TextComposition
>
composition
(
GetComposition
(
)
)
;
NS_ENSURE_TRUE_VOID
(
mDispatcher
&
&
widget
)
;
if
(
!
composition
)
{
return
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
uint32_t
offset
=
composition
-
>
NativeOffsetOfStartComposition
(
)
;
WidgetQueryContentEvent
textRects
(
true
eQueryTextRectArray
widget
)
;
textRects
.
InitForQueryTextRectArray
(
offset
composition
-
>
String
(
)
.
Length
(
)
)
;
widget
-
>
DispatchEvent
(
&
textRects
status
)
;
auto
rects
=
ConvertRectArrayToJavaRectFArray
(
textRects
.
mReply
.
mRectArray
widget
-
>
WidgetToScreenOffset
(
)
widget
-
>
GetDefaultScale
(
)
)
;
mEditable
-
>
UpdateCompositionRects
(
rects
)
;
}
void
GeckoEditableSupport
:
:
OnImeSynchronize
(
)
{
if
(
!
mIMEMaskEventsCount
)
{
FlushIMEChanges
(
)
;
}
mEditable
-
>
NotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_REPLY_EVENT
)
;
}
void
GeckoEditableSupport
:
:
OnImeReplaceText
(
int32_t
aStart
int32_t
aEnd
jni
:
:
String
:
:
Param
aText
)
{
AutoIMESynchronize
as
(
this
)
;
if
(
mIMEMaskEventsCount
>
0
)
{
return
;
}
if
(
mWindow
)
{
mWindow
-
>
UserActivity
(
)
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
NS_ENSURE_TRUE_VOID
(
mDispatcher
&
&
widget
)
;
NS_ENSURE_SUCCESS_VOID
(
BeginInputTransaction
(
mDispatcher
)
)
;
RefPtr
<
TextComposition
>
composition
(
GetComposition
(
)
)
;
MOZ_ASSERT
(
!
composition
|
|
!
composition
-
>
IsEditorHandlingEvent
(
)
)
;
nsString
string
(
aText
-
>
ToString
(
)
)
;
const
bool
composing
=
!
mIMERanges
-
>
IsEmpty
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
!
mIMEKeyEvents
.
IsEmpty
(
)
|
|
!
mDispatcher
-
>
IsComposing
(
)
|
|
uint32_t
(
aStart
)
!
=
composition
-
>
NativeOffsetOfStartComposition
(
)
|
|
uint32_t
(
aEnd
)
!
=
composition
-
>
NativeOffsetOfStartComposition
(
)
+
composition
-
>
String
(
)
.
Length
(
)
)
{
RemoveComposition
(
)
;
{
WidgetSelectionEvent
event
(
true
eSetSelection
widget
)
;
event
.
mOffset
=
uint32_t
(
aStart
)
;
event
.
mLength
=
uint32_t
(
aEnd
-
aStart
)
;
event
.
mExpandToClusterBoundary
=
false
;
event
.
mReason
=
nsISelectionListener
:
:
IME_REASON
;
widget
-
>
DispatchEvent
(
&
event
status
)
;
}
if
(
!
mIMEKeyEvents
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
mIMEKeyEvents
.
Length
(
)
;
i
+
+
)
{
const
auto
event
=
mIMEKeyEvents
[
i
]
-
>
AsKeyboardEvent
(
)
;
event
-
>
mWidget
=
widget
;
if
(
event
-
>
mMessage
!
=
eKeyPress
)
{
mDispatcher
-
>
DispatchKeyboardEvent
(
event
-
>
mMessage
*
event
status
)
;
}
else
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
)
{
AutoCacheNativeKeyCommands
autoCache
(
static_cast
<
PuppetWidget
*
>
(
widget
.
get
(
)
)
)
;
autoCache
.
CacheNoCommands
(
)
;
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
*
event
status
)
;
}
else
{
mDispatcher
-
>
MaybeDispatchKeypressEvents
(
*
event
status
)
;
}
if
(
!
mDispatcher
|
|
widget
-
>
Destroyed
(
)
)
{
break
;
}
}
mIMEKeyEvents
.
Clear
(
)
;
return
;
}
if
(
aStart
!
=
aEnd
)
{
WidgetContentCommandEvent
event
(
true
eContentCommandDelete
widget
)
;
event
.
mTime
=
PR_Now
(
)
/
1000
;
widget
-
>
DispatchEvent
(
&
event
status
)
;
if
(
!
mDispatcher
|
|
widget
-
>
Destroyed
(
)
)
{
return
;
}
}
}
else
if
(
composition
-
>
String
(
)
.
Equals
(
string
)
)
{
IMETextChange
dummyChange
;
dummyChange
.
mStart
=
aStart
;
dummyChange
.
mOldEnd
=
dummyChange
.
mNewEnd
=
aEnd
;
AddIMETextChange
(
dummyChange
)
;
}
if
(
mInputContext
.
mMayBeIMEUnaware
)
{
SendIMEDummyKeyEvent
(
widget
eKeyDown
)
;
if
(
!
mDispatcher
|
|
widget
-
>
Destroyed
(
)
)
{
return
;
}
}
if
(
composing
)
{
mDispatcher
-
>
SetPendingComposition
(
string
mIMERanges
)
;
mDispatcher
-
>
FlushPendingComposition
(
status
)
;
mIMERanges
-
>
Clear
(
)
;
}
else
if
(
!
string
.
IsEmpty
(
)
|
|
mDispatcher
-
>
IsComposing
(
)
)
{
mDispatcher
-
>
CommitComposition
(
status
&
string
)
;
}
if
(
!
mDispatcher
|
|
widget
-
>
Destroyed
(
)
)
{
return
;
}
if
(
mInputContext
.
mMayBeIMEUnaware
)
{
SendIMEDummyKeyEvent
(
widget
eKeyUp
)
;
}
}
void
GeckoEditableSupport
:
:
OnImeAddCompositionRange
(
int32_t
aStart
int32_t
aEnd
int32_t
aRangeType
int32_t
aRangeStyle
int32_t
aRangeLineStyle
bool
aRangeBoldLine
int32_t
aRangeForeColor
int32_t
aRangeBackColor
int32_t
aRangeLineColor
)
{
if
(
mIMEMaskEventsCount
>
0
)
{
return
;
}
TextRange
range
;
range
.
mStartOffset
=
aStart
;
range
.
mEndOffset
=
aEnd
;
range
.
mRangeType
=
ToTextRangeType
(
aRangeType
)
;
range
.
mRangeStyle
.
mDefinedStyles
=
aRangeStyle
;
range
.
mRangeStyle
.
mLineStyle
=
aRangeLineStyle
;
range
.
mRangeStyle
.
mIsBoldLine
=
aRangeBoldLine
;
range
.
mRangeStyle
.
mForegroundColor
=
ConvertAndroidColor
(
uint32_t
(
aRangeForeColor
)
)
;
range
.
mRangeStyle
.
mBackgroundColor
=
ConvertAndroidColor
(
uint32_t
(
aRangeBackColor
)
)
;
range
.
mRangeStyle
.
mUnderlineColor
=
ConvertAndroidColor
(
uint32_t
(
aRangeLineColor
)
)
;
mIMERanges
-
>
AppendElement
(
range
)
;
}
void
GeckoEditableSupport
:
:
OnImeUpdateComposition
(
int32_t
aStart
int32_t
aEnd
)
{
if
(
mIMEMaskEventsCount
>
0
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
NS_ENSURE_TRUE_VOID
(
mDispatcher
&
&
widget
)
;
if
(
mIMERanges
-
>
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aStart
>
=
0
&
&
aEnd
>
=
0
)
;
RemoveComposition
(
)
;
WidgetSelectionEvent
selEvent
(
true
eSetSelection
widget
)
;
selEvent
.
mOffset
=
std
:
:
min
(
aStart
aEnd
)
;
selEvent
.
mLength
=
std
:
:
max
(
aStart
aEnd
)
-
selEvent
.
mOffset
;
selEvent
.
mReversed
=
aStart
>
aEnd
;
selEvent
.
mExpandToClusterBoundary
=
false
;
widget
-
>
DispatchEvent
(
&
selEvent
status
)
;
return
;
}
nsString
string
;
RefPtr
<
TextComposition
>
composition
(
GetComposition
(
)
)
;
MOZ_ASSERT
(
!
composition
|
|
!
composition
-
>
IsEditorHandlingEvent
(
)
)
;
if
(
!
mDispatcher
-
>
IsComposing
(
)
|
|
uint32_t
(
aStart
)
!
=
composition
-
>
NativeOffsetOfStartComposition
(
)
|
|
uint32_t
(
aEnd
)
!
=
composition
-
>
NativeOffsetOfStartComposition
(
)
+
composition
-
>
String
(
)
.
Length
(
)
)
{
RemoveComposition
(
)
;
{
WidgetSelectionEvent
event
(
true
eSetSelection
widget
)
;
event
.
mOffset
=
uint32_t
(
aStart
)
;
event
.
mLength
=
uint32_t
(
aEnd
-
aStart
)
;
event
.
mExpandToClusterBoundary
=
false
;
event
.
mReason
=
nsISelectionListener
:
:
IME_REASON
;
widget
-
>
DispatchEvent
(
&
event
status
)
;
}
{
WidgetQueryContentEvent
event
(
true
eQuerySelectedText
widget
)
;
widget
-
>
DispatchEvent
(
&
event
status
)
;
MOZ_ASSERT
(
event
.
mSucceeded
)
;
string
=
event
.
mReply
.
mString
;
}
}
else
{
string
=
composition
-
>
String
(
)
;
}
#
ifdef
DEBUG_ANDROID_IME
const
NS_ConvertUTF16toUTF8
data
(
event
.
mData
)
;
const
char
*
text
=
data
.
get
(
)
;
ALOGIME
(
"
IME
:
IME_SET_TEXT
:
text
=
\
"
%
s
\
"
length
=
%
u
range
=
%
u
"
text
event
.
mData
.
Length
(
)
event
.
mRanges
-
>
Length
(
)
)
;
#
endif
NS_ENSURE_SUCCESS_VOID
(
BeginInputTransaction
(
mDispatcher
)
)
;
mDispatcher
-
>
SetPendingComposition
(
string
mIMERanges
)
;
mDispatcher
-
>
FlushPendingComposition
(
status
)
;
mIMERanges
-
>
Clear
(
)
;
}
void
GeckoEditableSupport
:
:
OnImeRequestCursorUpdates
(
int
aRequestMode
)
{
if
(
aRequestMode
=
=
java
:
:
GeckoEditableClient
:
:
ONE_SHOT
)
{
UpdateCompositionRects
(
)
;
return
;
}
mIMEMonitorCursor
=
(
aRequestMode
=
=
java
:
:
GeckoEditableClient
:
:
START_MONITOR
)
;
}
void
GeckoEditableSupport
:
:
AsyncNotifyIME
(
int32_t
aNotification
)
{
RefPtr
<
GeckoEditableSupport
>
self
(
this
)
;
nsAppShell
:
:
PostEvent
(
[
this
self
aNotification
]
{
if
(
!
mIMEMaskEventsCount
)
{
mEditable
-
>
NotifyIME
(
aNotification
)
;
}
}
)
;
}
nsresult
GeckoEditableSupport
:
:
NotifyIME
(
TextEventDispatcher
*
aTextEventDispatcher
const
IMENotification
&
aNotification
)
{
MOZ_ASSERT
(
mEditable
)
;
switch
(
aNotification
.
mMessage
)
{
case
REQUEST_TO_COMMIT_COMPOSITION
:
{
ALOGIME
(
"
IME
:
REQUEST_TO_COMMIT_COMPOSITION
"
)
;
RemoveComposition
(
COMMIT_IME_COMPOSITION
)
;
AsyncNotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_TO_COMMIT_COMPOSITION
)
;
break
;
}
case
REQUEST_TO_CANCEL_COMPOSITION
:
{
ALOGIME
(
"
IME
:
REQUEST_TO_CANCEL_COMPOSITION
"
)
;
RemoveComposition
(
CANCEL_IME_COMPOSITION
)
;
AsyncNotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_TO_CANCEL_COMPOSITION
)
;
break
;
}
case
NOTIFY_IME_OF_FOCUS
:
{
ALOGIME
(
"
IME
:
NOTIFY_IME_OF_FOCUS
"
)
;
RefPtr
<
GeckoEditableSupport
>
self
(
this
)
;
RefPtr
<
TextEventDispatcher
>
dispatcher
=
aTextEventDispatcher
;
nsAppShell
:
:
PostEvent
(
[
this
self
dispatcher
]
{
nsCOMPtr
<
nsIWidget
>
widget
=
dispatcher
-
>
GetWidget
(
)
;
-
-
mIMEMaskEventsCount
;
if
(
mIMEMaskEventsCount
|
|
!
widget
|
|
widget
-
>
Destroyed
(
)
)
{
return
;
}
mEditable
-
>
NotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_OF_TOKEN
)
;
if
(
mIsRemote
)
{
if
(
!
mEditableAttached
)
{
AttachNative
(
mEditable
this
)
;
mEditableAttached
=
true
;
}
mInputContext
=
widget
-
>
GetInputContext
(
)
;
}
mDispatcher
=
dispatcher
;
mIMEKeyEvents
.
Clear
(
)
;
FlushIMEText
(
)
;
mIMEMonitorCursor
=
false
;
mEditable
-
>
NotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_OF_FOCUS
)
;
}
)
;
break
;
}
case
NOTIFY_IME_OF_BLUR
:
{
ALOGIME
(
"
IME
:
NOTIFY_IME_OF_BLUR
"
)
;
if
(
!
mIMEMaskEventsCount
)
{
mEditable
-
>
NotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_OF_BLUR
)
;
OnRemovedFrom
(
mDispatcher
)
;
}
mIMEMaskEventsCount
+
+
;
break
;
}
case
NOTIFY_IME_OF_SELECTION_CHANGE
:
{
ALOGIME
(
"
IME
:
NOTIFY_IME_OF_SELECTION_CHANGE
"
)
;
PostFlushIMEChanges
(
)
;
mIMESelectionChanged
=
true
;
break
;
}
case
NOTIFY_IME_OF_TEXT_CHANGE
:
{
ALOGIME
(
"
IME
:
NotifyIMEOfTextChange
:
s
=
%
d
oe
=
%
d
ne
=
%
d
"
aNotification
.
mTextChangeData
.
mStartOffset
aNotification
.
mTextChangeData
.
mRemovedEndOffset
aNotification
.
mTextChangeData
.
mAddedEndOffset
)
;
PostFlushIMEChanges
(
)
;
mIMESelectionChanged
=
true
;
AddIMETextChange
(
IMETextChange
(
aNotification
)
)
;
break
;
}
case
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
:
{
ALOGIME
(
"
IME
:
NOTIFY_IME_OF_COMPOSITION_EVENT_HANDLED
"
)
;
if
(
mIMEMonitorCursor
)
{
UpdateCompositionRects
(
)
;
}
break
;
}
default
:
break
;
}
return
NS_OK
;
}
void
GeckoEditableSupport
:
:
OnRemovedFrom
(
TextEventDispatcher
*
aTextEventDispatcher
)
{
mDispatcher
=
nullptr
;
if
(
mIsRemote
)
{
OnDetach
(
)
;
}
}
void
GeckoEditableSupport
:
:
WillDispatchKeyboardEvent
(
TextEventDispatcher
*
aTextEventDispatcher
WidgetKeyboardEvent
&
aKeyboardEvent
uint32_t
aIndexOfKeypress
void
*
aData
)
{
}
NS_IMETHODIMP_
(
IMENotificationRequests
)
GeckoEditableSupport
:
:
GetIMENotificationRequests
(
)
{
if
(
GetInputContext
(
)
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
)
{
return
IMENotificationRequests
(
)
;
}
return
IMENotificationRequests
(
IMENotificationRequests
:
:
NOTIFY_TEXT_CHANGE
)
;
}
void
GeckoEditableSupport
:
:
SetInputContext
(
const
InputContext
&
aContext
const
InputContextAction
&
aAction
)
{
MOZ_ASSERT
(
mEditable
)
;
ALOGIME
(
"
IME
:
SetInputContext
:
s
=
0x
%
X
0x
%
X
action
=
0x
%
X
0x
%
X
"
aContext
.
mIMEState
.
mEnabled
aContext
.
mIMEState
.
mOpen
aAction
.
mCause
aAction
.
mFocusChange
)
;
if
(
aContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
DISABLED
&
&
aContext
.
mIMEState
.
mEnabled
!
=
IMEState
:
:
PLUGIN
&
&
Preferences
:
:
GetBool
(
"
content
.
ime
.
strict_policy
"
false
)
&
&
!
aAction
.
ContentGotFocusByTrustedCause
(
)
&
&
!
aAction
.
UserMightRequestOpenVKB
(
)
)
{
return
;
}
IMEState
:
:
Enabled
enabled
=
aContext
.
mIMEState
.
mEnabled
;
if
(
aContext
.
mIMEState
.
mEnabled
=
=
IMEState
:
:
PLUGIN
&
&
aContext
.
mIMEState
.
mOpen
!
=
IMEState
:
:
OPEN
)
{
enabled
=
IMEState
:
:
DISABLED
;
}
mInputContext
=
aContext
;
mInputContext
.
mIMEState
.
mEnabled
=
enabled
;
if
(
enabled
=
=
IMEState
:
:
ENABLED
&
&
aAction
.
UserMightRequestOpenVKB
(
)
)
{
mEditable
-
>
NotifyIME
(
GeckoEditableListener
:
:
NOTIFY_IME_OPEN_VKB
)
;
return
;
}
if
(
mIMEUpdatingContext
)
{
return
;
}
mIMEUpdatingContext
=
true
;
RefPtr
<
GeckoEditableSupport
>
self
(
this
)
;
nsAppShell
:
:
PostEvent
(
[
this
self
]
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
)
;
mIMEUpdatingContext
=
false
;
if
(
!
widget
|
|
widget
-
>
Destroyed
(
)
)
{
return
;
}
mEditable
-
>
NotifyIMEContext
(
mInputContext
.
mIMEState
.
mEnabled
mInputContext
.
mHTMLInputType
mInputContext
.
mHTMLInputInputmode
mInputContext
.
mActionHint
)
;
}
)
;
}
InputContext
GeckoEditableSupport
:
:
GetInputContext
(
)
{
InputContext
context
=
mInputContext
;
context
.
mIMEState
.
mOpen
=
IMEState
:
:
OPEN_STATE_NOT_SUPPORTED
;
return
context
;
}
}
}
