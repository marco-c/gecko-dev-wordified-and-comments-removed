#
include
"
imgTools
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsError
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
imgICache
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIEncoder
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
ImageFactory
.
h
"
#
include
"
Image
.
h
"
#
include
"
ScriptedNotificationObserver
.
h
"
#
include
"
imgIScriptedNotificationObserver
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
jsfriendapi
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
image
{
namespace
{
class
ImageDecoderHelper
final
:
public
Runnable
public
nsIInputStreamCallback
{
public
:
NS_DECL_ISUPPORTS_INHERITED
ImageDecoderHelper
(
already_AddRefed
<
image
:
:
Image
>
aImage
already_AddRefed
<
nsIInputStream
>
aInputStream
nsIEventTarget
*
aEventTarget
imgIContainerCallback
*
aCallback
nsIEventTarget
*
aCallbackEventTarget
)
:
Runnable
(
"
ImageDecoderHelper
"
)
mImage
(
std
:
:
move
(
aImage
)
)
mInputStream
(
std
:
:
move
(
aInputStream
)
)
mEventTarget
(
aEventTarget
)
mCallback
(
aCallback
)
mCallbackEventTarget
(
aCallbackEventTarget
)
mStatus
(
NS_OK
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
NS_IsMainThread
(
)
)
{
mImage
-
>
OnImageDataComplete
(
nullptr
nullptr
mStatus
true
)
;
RefPtr
<
ProgressTracker
>
tracker
=
mImage
-
>
GetProgressTracker
(
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
nsCOMPtr
<
imgIContainer
>
container
;
if
(
NS_SUCCEEDED
(
mStatus
)
)
{
container
=
do_QueryInterface
(
mImage
)
;
}
mCallback
-
>
OnImageReady
(
container
mStatus
)
;
return
NS_OK
;
}
uint64_t
length
;
nsresult
rv
=
mInputStream
-
>
Available
(
&
length
)
;
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
)
{
return
OperationCompleted
(
NS_OK
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
OperationCompleted
(
rv
)
;
}
if
(
length
=
=
0
)
{
nsCOMPtr
<
nsIAsyncInputStream
>
asyncInputStream
=
do_QueryInterface
(
mInputStream
)
;
if
(
asyncInputStream
)
{
rv
=
asyncInputStream
-
>
AsyncWait
(
this
0
0
mEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
OperationCompleted
(
rv
)
;
}
return
NS_OK
;
}
if
(
length
=
=
0
)
{
return
OperationCompleted
(
NS_OK
)
;
}
}
rv
=
mImage
-
>
OnImageDataAvailable
(
nullptr
nullptr
mInputStream
0
uint32_t
(
length
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
OperationCompleted
(
rv
)
;
}
rv
=
mEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
OperationCompleted
(
rv
)
;
}
return
NS_OK
;
}
NS_IMETHOD
OnInputStreamReady
(
nsIAsyncInputStream
*
aAsyncInputStream
)
override
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
return
Run
(
)
;
}
nsresult
OperationCompleted
(
nsresult
aStatus
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mStatus
=
aStatus
;
mCallbackEventTarget
-
>
Dispatch
(
this
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
private
:
~
ImageDecoderHelper
(
)
{
NS_ReleaseOnMainThreadSystemGroup
(
"
ImageDecoderHelper
:
:
mImage
"
mImage
.
forget
(
)
)
;
NS_ReleaseOnMainThreadSystemGroup
(
"
ImageDecoderHelper
:
:
mCallback
"
mCallback
.
forget
(
)
)
;
}
RefPtr
<
image
:
:
Image
>
mImage
;
nsCOMPtr
<
nsIInputStream
>
mInputStream
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
nsCOMPtr
<
imgIContainerCallback
>
mCallback
;
nsCOMPtr
<
nsIEventTarget
>
mCallbackEventTarget
;
nsresult
mStatus
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
ImageDecoderHelper
Runnable
nsIInputStreamCallback
)
}
NS_IMPL_ISUPPORTS
(
imgTools
imgITools
)
imgTools
:
:
imgTools
(
)
{
}
imgTools
:
:
~
imgTools
(
)
{
}
NS_IMETHODIMP
imgTools
:
:
DecodeImageFromArrayBuffer
(
JS
:
:
HandleValue
aArrayBuffer
const
nsACString
&
aMimeType
JSContext
*
aCx
imgIContainer
*
*
aContainer
)
{
if
(
!
aArrayBuffer
.
isObject
(
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
js
:
:
UnwrapArrayBuffer
(
&
aArrayBuffer
.
toObject
(
)
)
)
;
if
(
!
obj
)
{
return
NS_ERROR_FAILURE
;
}
uint8_t
*
bufferData
=
nullptr
;
uint32_t
bufferLength
=
0
;
bool
isSharedMemory
=
false
;
js
:
:
GetArrayBufferLengthAndData
(
obj
&
bufferLength
&
isSharedMemory
&
bufferData
)
;
return
DecodeImageFromBuffer
(
(
char
*
)
bufferData
bufferLength
aMimeType
aContainer
)
;
}
NS_IMETHODIMP
imgTools
:
:
DecodeImageFromBuffer
(
const
char
*
aBuffer
uint32_t
aSize
const
nsACString
&
aMimeType
imgIContainer
*
*
aContainer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aBuffer
)
;
nsAutoCString
mimeType
(
aMimeType
)
;
RefPtr
<
image
:
:
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
mimeType
aSize
)
;
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
if
(
image
-
>
HasError
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
nsresult
rv
=
NS_NewByteInputStream
(
getter_AddRefs
(
stream
)
aBuffer
aSize
NS_ASSIGNMENT_DEPEND
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
stream
)
;
MOZ_ASSERT
(
NS_InputStreamIsBuffered
(
stream
)
)
;
rv
=
image
-
>
OnImageDataAvailable
(
nullptr
nullptr
stream
0
aSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
image
-
>
OnImageDataComplete
(
nullptr
nullptr
NS_OK
true
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
image
.
forget
(
aContainer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
imgTools
:
:
DecodeImageAsync
(
nsIInputStream
*
aInStr
const
nsACString
&
aMimeType
imgIContainerCallback
*
aCallback
nsIEventTarget
*
aEventTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aInStr
)
;
NS_ENSURE_ARG_POINTER
(
aCallback
)
;
NS_ENSURE_ARG_POINTER
(
aEventTarget
)
;
nsresult
rv
;
DecodePool
*
decodePool
=
DecodePool
:
:
Singleton
(
)
;
MOZ_ASSERT
(
decodePool
)
;
RefPtr
<
nsIEventTarget
>
target
=
decodePool
-
>
GetIOEventTarget
(
)
;
NS_ENSURE_TRUE
(
target
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIInputStream
>
stream
=
aInStr
;
if
(
!
NS_InputStreamIsBuffered
(
aInStr
)
)
{
nsCOMPtr
<
nsIInputStream
>
bufStream
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufStream
)
stream
.
forget
(
)
1024
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
stream
=
bufStream
.
forget
(
)
;
}
nsAutoCString
mimeType
(
aMimeType
)
;
RefPtr
<
image
:
:
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
mimeType
0
)
;
if
(
image
-
>
HasError
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
ImageDecoderHelper
>
helper
=
new
ImageDecoderHelper
(
image
.
forget
(
)
stream
.
forget
(
)
target
aCallback
aEventTarget
)
;
rv
=
target
-
>
Dispatch
(
helper
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
static
nsresult
EncodeImageData
(
DataSourceSurface
*
aDataSurface
DataSourceSurface
:
:
ScopedMap
&
aMap
const
nsACString
&
aMimeType
const
nsAString
&
aOutputOptions
nsIInputStream
*
*
aStream
)
{
MOZ_ASSERT
(
aDataSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
aDataSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
"
We
'
re
assuming
B8G8R8A8
/
X8
"
)
;
nsAutoCString
encoderCID
(
NS_LITERAL_CSTRING
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
"
)
+
aMimeType
)
;
nsCOMPtr
<
imgIEncoder
>
encoder
=
do_CreateInstance
(
encoderCID
.
get
(
)
)
;
if
(
!
encoder
)
{
return
NS_IMAGELIB_ERROR_NO_ENCODER
;
}
IntSize
size
=
aDataSurface
-
>
GetSize
(
)
;
uint32_t
dataLength
=
aMap
.
GetStride
(
)
*
size
.
height
;
nsresult
rv
=
encoder
-
>
InitFromData
(
aMap
.
GetData
(
)
dataLength
size
.
width
size
.
height
aMap
.
GetStride
(
)
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
aOutputOptions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
encoder
.
forget
(
aStream
)
;
return
NS_OK
;
}
static
nsresult
EncodeImageData
(
DataSourceSurface
*
aDataSurface
const
nsACString
&
aMimeType
const
nsAString
&
aOutputOptions
nsIInputStream
*
*
aStream
)
{
DataSourceSurface
:
:
ScopedMap
map
(
aDataSurface
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
EncodeImageData
(
aDataSurface
map
aMimeType
aOutputOptions
aStream
)
;
}
NS_IMETHODIMP
imgTools
:
:
EncodeImage
(
imgIContainer
*
aContainer
const
nsACString
&
aMimeType
const
nsAString
&
aOutputOptions
nsIInputStream
*
*
aStream
)
{
RefPtr
<
SourceSurface
>
frame
=
aContainer
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
;
if
(
frame
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
frame
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
)
{
dataSurface
=
frame
-
>
GetDataSurface
(
)
;
}
else
{
dataSurface
=
gfxUtils
:
:
CopySurfaceToDataSourceSurfaceWithFormat
(
frame
SurfaceFormat
:
:
B8G8R8A8
)
;
}
NS_ENSURE_TRUE
(
dataSurface
NS_ERROR_FAILURE
)
;
return
EncodeImageData
(
dataSurface
aMimeType
aOutputOptions
aStream
)
;
}
NS_IMETHODIMP
imgTools
:
:
EncodeScaledImage
(
imgIContainer
*
aContainer
const
nsACString
&
aMimeType
int32_t
aScaledWidth
int32_t
aScaledHeight
const
nsAString
&
aOutputOptions
nsIInputStream
*
*
aStream
)
{
NS_ENSURE_ARG
(
aScaledWidth
>
=
0
&
&
aScaledHeight
>
=
0
)
;
if
(
aScaledWidth
=
=
0
&
&
aScaledHeight
=
=
0
)
{
return
EncodeImage
(
aContainer
aMimeType
aOutputOptions
aStream
)
;
}
int32_t
imageWidth
=
0
;
int32_t
imageHeight
=
0
;
aContainer
-
>
GetWidth
(
&
imageWidth
)
;
aContainer
-
>
GetHeight
(
&
imageHeight
)
;
IntSize
scaledSize
(
aScaledWidth
=
=
0
?
imageWidth
:
aScaledWidth
aScaledHeight
=
=
0
?
imageHeight
:
aScaledHeight
)
;
RefPtr
<
SourceSurface
>
frame
=
aContainer
-
>
GetFrameAtSize
(
scaledSize
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
|
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
if
(
scaledSize
=
=
frame
-
>
GetSize
(
)
&
&
(
frame
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
frame
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
)
)
{
RefPtr
<
DataSourceSurface
>
dataSurface
=
frame
-
>
GetDataSurface
(
)
;
if
(
dataSurface
)
{
return
EncodeImageData
(
dataSurface
aMimeType
aOutputOptions
aStream
)
;
}
}
RefPtr
<
DataSourceSurface
>
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
scaledSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_WARN_IF
(
!
dataSurface
)
)
{
return
NS_ERROR_FAILURE
;
}
DataSourceSurface
:
:
ScopedMap
map
(
dataSurface
DataSourceSurface
:
:
READ_WRITE
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
SKIA
map
.
GetData
(
)
dataSurface
-
>
GetSize
(
)
map
.
GetStride
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
{
gfxWarning
(
)
<
<
"
imgTools
:
:
EncodeImage
failed
in
CreateDrawTargetForData
"
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
IntSize
frameSize
=
frame
-
>
GetSize
(
)
;
dt
-
>
DrawSurface
(
frame
Rect
(
0
0
scaledSize
.
width
scaledSize
.
height
)
Rect
(
0
0
frameSize
.
width
frameSize
.
height
)
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
return
EncodeImageData
(
dataSurface
map
aMimeType
aOutputOptions
aStream
)
;
}
NS_IMETHODIMP
imgTools
:
:
EncodeCroppedImage
(
imgIContainer
*
aContainer
const
nsACString
&
aMimeType
int32_t
aOffsetX
int32_t
aOffsetY
int32_t
aWidth
int32_t
aHeight
const
nsAString
&
aOutputOptions
nsIInputStream
*
*
aStream
)
{
NS_ENSURE_ARG
(
aOffsetX
>
=
0
&
&
aOffsetY
>
=
0
&
&
aWidth
>
=
0
&
&
aHeight
>
=
0
)
;
NS_ENSURE_ARG
(
aWidth
+
aHeight
>
0
|
|
aOffsetX
+
aOffsetY
=
=
0
)
;
if
(
aWidth
=
=
0
&
&
aHeight
=
=
0
)
{
return
EncodeImage
(
aContainer
aMimeType
aOutputOptions
aStream
)
;
}
RefPtr
<
SourceSurface
>
frame
=
aContainer
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
NS_ENSURE_TRUE
(
frame
NS_ERROR_FAILURE
)
;
int32_t
frameWidth
=
frame
-
>
GetSize
(
)
.
width
;
int32_t
frameHeight
=
frame
-
>
GetSize
(
)
.
height
;
if
(
aWidth
=
=
0
)
{
aWidth
=
frameWidth
;
}
else
if
(
aHeight
=
=
0
)
{
aHeight
=
frameHeight
;
}
NS_ENSURE_ARG
(
frameWidth
>
=
aOffsetX
+
aWidth
&
&
frameHeight
>
=
aOffsetY
+
aHeight
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
Factory
:
:
CreateDataSourceSurface
(
IntSize
(
aWidth
aHeight
)
SurfaceFormat
:
:
B8G8R8A8
true
)
;
if
(
NS_WARN_IF
(
!
dataSurface
)
)
{
return
NS_ERROR_FAILURE
;
}
DataSourceSurface
:
:
ScopedMap
map
(
dataSurface
DataSourceSurface
:
:
READ_WRITE
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DrawTarget
>
dt
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
SKIA
map
.
GetData
(
)
dataSurface
-
>
GetSize
(
)
map
.
GetStride
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
{
gfxWarning
(
)
<
<
"
imgTools
:
:
EncodeCroppedImage
failed
in
CreateDrawTargetForData
"
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
dt
-
>
CopySurface
(
frame
IntRect
(
aOffsetX
aOffsetY
aWidth
aHeight
)
IntPoint
(
0
0
)
)
;
return
EncodeImageData
(
dataSurface
map
aMimeType
aOutputOptions
aStream
)
;
}
NS_IMETHODIMP
imgTools
:
:
CreateScriptedObserver
(
imgIScriptedNotificationObserver
*
aInner
imgINotificationObserver
*
*
aObserver
)
{
NS_ADDREF
(
*
aObserver
=
new
ScriptedNotificationObserver
(
aInner
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
imgTools
:
:
GetImgLoaderForDocument
(
nsIDocument
*
aDoc
imgILoader
*
*
aLoader
)
{
NS_IF_ADDREF
(
*
aLoader
=
nsContentUtils
:
:
GetImgLoaderForDocument
(
aDoc
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
imgTools
:
:
GetImgCacheForDocument
(
nsIDocument
*
aDoc
imgICache
*
*
aCache
)
{
nsCOMPtr
<
imgILoader
>
loader
;
nsresult
rv
=
GetImgLoaderForDocument
(
aDoc
getter_AddRefs
(
loader
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
CallQueryInterface
(
loader
aCache
)
;
}
}
}
