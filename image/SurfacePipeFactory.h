#
ifndef
mozilla_image_SurfacePipeFactory_h
#
define
mozilla_image_SurfacePipeFactory_h
#
include
"
SurfacePipe
.
h
"
#
include
"
SurfaceFilters
.
h
"
namespace
mozilla
{
namespace
image
{
namespace
detail
{
template
<
typename
.
.
.
Configs
>
struct
FilterPipeline
;
template
<
typename
Config
typename
.
.
.
Configs
>
struct
FilterPipeline
<
Config
Configs
.
.
.
>
{
typedef
typename
Config
:
:
template
Filter
<
typename
FilterPipeline
<
Configs
.
.
.
>
:
:
Type
>
Type
;
}
;
template
<
typename
Config
>
struct
FilterPipeline
<
Config
>
{
typedef
typename
Config
:
:
Filter
Type
;
}
;
}
enum
class
SurfacePipeFlags
{
DEINTERLACE
=
1
<
<
0
ADAM7_INTERPOLATE
=
1
<
<
1
FLIP_VERTICALLY
=
1
<
<
2
PROGRESSIVE_DISPLAY
=
1
<
<
3
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
SurfacePipeFlags
)
class
SurfacePipeFactory
{
public
:
static
Maybe
<
SurfacePipe
>
CreateSurfacePipe
(
Decoder
*
aDecoder
const
nsIntSize
&
aInputSize
const
nsIntSize
&
aOutputSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
const
Maybe
<
AnimationParams
>
&
aAnimParams
SurfacePipeFlags
aFlags
)
{
const
bool
deinterlace
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
DEINTERLACE
)
;
const
bool
flipVertically
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
FLIP_VERTICALLY
)
;
const
bool
progressiveDisplay
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
PROGRESSIVE_DISPLAY
)
;
const
bool
downscale
=
aInputSize
!
=
aOutputSize
;
const
bool
removeFrameRect
=
!
aFrameRect
.
IsEqualEdges
(
nsIntRect
(
0
0
aInputSize
.
width
aInputSize
.
height
)
)
;
const
bool
adam7Interpolate
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
ADAM7_INTERPOLATE
)
&
&
progressiveDisplay
;
if
(
deinterlace
&
&
adam7Interpolate
)
{
MOZ_ASSERT_UNREACHABLE
(
"
ADAM7
deinterlacing
is
handled
by
libpng
"
)
;
return
Nothing
(
)
;
}
DeinterlacingConfig
<
uint32_t
>
deinterlacingConfig
{
progressiveDisplay
}
;
ADAM7InterpolatingConfig
interpolatingConfig
;
RemoveFrameRectConfig
removeFrameRectConfig
{
aFrameRect
}
;
DownscalingConfig
downscalingConfig
{
aInputSize
aFormat
}
;
SurfaceConfig
surfaceConfig
{
aDecoder
aOutputSize
aFormat
flipVertically
aAnimParams
}
;
Maybe
<
SurfacePipe
>
pipe
;
if
(
downscale
)
{
if
(
removeFrameRect
)
{
if
(
deinterlace
)
{
pipe
=
MakePipe
(
deinterlacingConfig
removeFrameRectConfig
downscalingConfig
surfaceConfig
)
;
}
else
if
(
adam7Interpolate
)
{
pipe
=
MakePipe
(
interpolatingConfig
removeFrameRectConfig
downscalingConfig
surfaceConfig
)
;
}
else
{
pipe
=
MakePipe
(
removeFrameRectConfig
downscalingConfig
surfaceConfig
)
;
}
}
else
{
if
(
deinterlace
)
{
pipe
=
MakePipe
(
deinterlacingConfig
downscalingConfig
surfaceConfig
)
;
}
else
if
(
adam7Interpolate
)
{
pipe
=
MakePipe
(
interpolatingConfig
downscalingConfig
surfaceConfig
)
;
}
else
{
pipe
=
MakePipe
(
downscalingConfig
surfaceConfig
)
;
}
}
}
else
{
if
(
removeFrameRect
)
{
if
(
deinterlace
)
{
pipe
=
MakePipe
(
deinterlacingConfig
removeFrameRectConfig
surfaceConfig
)
;
}
else
if
(
adam7Interpolate
)
{
pipe
=
MakePipe
(
interpolatingConfig
removeFrameRectConfig
surfaceConfig
)
;
}
else
{
pipe
=
MakePipe
(
removeFrameRectConfig
surfaceConfig
)
;
}
}
else
{
if
(
deinterlace
)
{
pipe
=
MakePipe
(
deinterlacingConfig
surfaceConfig
)
;
}
else
if
(
adam7Interpolate
)
{
pipe
=
MakePipe
(
interpolatingConfig
surfaceConfig
)
;
}
else
{
pipe
=
MakePipe
(
surfaceConfig
)
;
}
}
}
return
pipe
;
}
static
Maybe
<
SurfacePipe
>
CreatePalettedSurfacePipe
(
Decoder
*
aDecoder
const
nsIntSize
&
aInputSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
const
Maybe
<
AnimationParams
>
&
aAnimParams
SurfacePipeFlags
aFlags
)
{
const
bool
deinterlace
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
DEINTERLACE
)
;
const
bool
flipVertically
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
FLIP_VERTICALLY
)
;
const
bool
progressiveDisplay
=
bool
(
aFlags
&
SurfacePipeFlags
:
:
PROGRESSIVE_DISPLAY
)
;
DeinterlacingConfig
<
uint8_t
>
deinterlacingConfig
{
progressiveDisplay
}
;
PalettedSurfaceConfig
palettedSurfaceConfig
{
aDecoder
aInputSize
aFrameRect
aFormat
aPaletteDepth
flipVertically
aAnimParams
}
;
Maybe
<
SurfacePipe
>
pipe
;
if
(
deinterlace
)
{
pipe
=
MakePipe
(
deinterlacingConfig
palettedSurfaceConfig
)
;
}
else
{
pipe
=
MakePipe
(
palettedSurfaceConfig
)
;
}
return
pipe
;
}
private
:
template
<
typename
.
.
.
Configs
>
static
Maybe
<
SurfacePipe
>
MakePipe
(
const
Configs
&
.
.
.
aConfigs
)
{
auto
pipe
=
MakeUnique
<
typename
detail
:
:
FilterPipeline
<
Configs
.
.
.
>
:
:
Type
>
(
)
;
nsresult
rv
=
pipe
-
>
Configure
(
aConfigs
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Nothing
(
)
;
}
return
Some
(
SurfacePipe
{
Move
(
pipe
)
}
)
;
}
virtual
~
SurfacePipeFactory
(
)
=
0
;
}
;
}
}
#
endif
