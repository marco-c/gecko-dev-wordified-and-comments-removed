#
include
"
ImageFactory
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
MultipartImage
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
VectorImage
.
h
"
#
include
"
Image
.
h
"
#
include
"
nsMediaFragmentURIParser
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
gfxPrefs
.
h
"
namespace
mozilla
{
namespace
image
{
void
ImageFactory
:
:
Initialize
(
)
{
}
static
uint32_t
ComputeImageFlags
(
ImageURL
*
uri
const
nsCString
&
aMimeType
bool
isMultiPart
)
{
nsresult
rv
;
bool
isDiscardable
=
gfxPrefs
:
:
ImageMemDiscardable
(
)
;
bool
doDecodeImmediately
=
gfxPrefs
:
:
ImageDecodeImmediatelyEnabled
(
)
;
bool
isChrome
=
false
;
rv
=
uri
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isChrome
)
{
isDiscardable
=
false
;
}
bool
isResource
=
false
;
rv
=
uri
-
>
SchemeIs
(
"
resource
"
&
isResource
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isResource
)
{
isDiscardable
=
false
;
}
if
(
isMultiPart
)
{
isDiscardable
=
false
;
}
uint32_t
imageFlags
=
Image
:
:
INIT_FLAG_NONE
;
if
(
isDiscardable
)
{
imageFlags
|
=
Image
:
:
INIT_FLAG_DISCARDABLE
;
}
if
(
doDecodeImmediately
)
{
imageFlags
|
=
Image
:
:
INIT_FLAG_DECODE_IMMEDIATELY
;
}
if
(
isMultiPart
)
{
imageFlags
|
=
Image
:
:
INIT_FLAG_TRANSIENT
;
}
return
imageFlags
;
}
already_AddRefed
<
Image
>
ImageFactory
:
:
CreateImage
(
nsIRequest
*
aRequest
ProgressTracker
*
aProgressTracker
const
nsCString
&
aMimeType
ImageURL
*
aURI
bool
aIsMultiPart
uint32_t
aInnerWindowId
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
SingletonExists
(
)
"
Pref
observers
should
have
been
initialized
already
"
)
;
uint32_t
imageFlags
=
ComputeImageFlags
(
aURI
aMimeType
aIsMultiPart
)
;
#
ifdef
DEBUG
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
services
:
:
GetObserverService
(
)
;
NS_WARNING_ASSERTION
(
obs
"
Can
'
t
get
an
observer
service
handle
"
)
;
if
(
obs
)
{
nsAutoCString
spec
;
aURI
-
>
GetSpec
(
spec
)
;
obs
-
>
NotifyObservers
(
nullptr
"
image
-
loading
"
NS_ConvertUTF8toUTF16
(
spec
)
.
get
(
)
)
;
}
}
#
endif
if
(
aMimeType
.
EqualsLiteral
(
IMAGE_SVG_XML
)
)
{
return
CreateVectorImage
(
aRequest
aProgressTracker
aMimeType
aURI
imageFlags
aInnerWindowId
)
;
}
else
{
return
CreateRasterImage
(
aRequest
aProgressTracker
aMimeType
aURI
imageFlags
aInnerWindowId
)
;
}
}
template
<
typename
T
>
static
already_AddRefed
<
Image
>
BadImage
(
const
char
*
aMessage
RefPtr
<
T
>
&
aImage
)
{
aImage
-
>
SetHasError
(
)
;
return
aImage
.
forget
(
)
;
}
already_AddRefed
<
Image
>
ImageFactory
:
:
CreateAnonymousImage
(
const
nsCString
&
aMimeType
)
{
nsresult
rv
;
RefPtr
<
RasterImage
>
newImage
=
new
RasterImage
(
)
;
RefPtr
<
ProgressTracker
>
newTracker
=
new
ProgressTracker
(
)
;
newTracker
-
>
SetImage
(
newImage
)
;
newImage
-
>
SetProgressTracker
(
newTracker
)
;
rv
=
newImage
-
>
Init
(
aMimeType
.
get
(
)
Image
:
:
INIT_FLAG_SYNC_LOAD
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
BadImage
(
"
RasterImage
:
:
Init
failed
"
newImage
)
;
}
return
newImage
.
forget
(
)
;
}
already_AddRefed
<
MultipartImage
>
ImageFactory
:
:
CreateMultipartImage
(
Image
*
aFirstPart
ProgressTracker
*
aProgressTracker
)
{
MOZ_ASSERT
(
aFirstPart
)
;
MOZ_ASSERT
(
aProgressTracker
)
;
RefPtr
<
MultipartImage
>
newImage
=
new
MultipartImage
(
aFirstPart
)
;
aProgressTracker
-
>
SetImage
(
newImage
)
;
newImage
-
>
SetProgressTracker
(
aProgressTracker
)
;
newImage
-
>
Init
(
)
;
return
newImage
.
forget
(
)
;
}
int32_t
SaturateToInt32
(
int64_t
val
)
{
if
(
val
>
INT_MAX
)
{
return
INT_MAX
;
}
if
(
val
<
INT_MIN
)
{
return
INT_MIN
;
}
return
static_cast
<
int32_t
>
(
val
)
;
}
uint32_t
GetContentSize
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIChannel
>
channel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
channel
)
{
int64_t
size
;
nsresult
rv
=
channel
-
>
GetContentLength
(
&
size
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
std
:
:
max
(
SaturateToInt32
(
size
)
0
)
;
}
}
nsCOMPtr
<
nsIFileChannel
>
fileChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
fileChannel
)
{
nsCOMPtr
<
nsIFile
>
file
;
nsresult
rv
=
fileChannel
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
int64_t
filesize
;
rv
=
file
-
>
GetFileSize
(
&
filesize
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
std
:
:
max
(
SaturateToInt32
(
filesize
)
0
)
;
}
}
}
return
0
;
}
already_AddRefed
<
Image
>
ImageFactory
:
:
CreateRasterImage
(
nsIRequest
*
aRequest
ProgressTracker
*
aProgressTracker
const
nsCString
&
aMimeType
ImageURL
*
aURI
uint32_t
aImageFlags
uint32_t
aInnerWindowId
)
{
MOZ_ASSERT
(
aProgressTracker
)
;
nsresult
rv
;
RefPtr
<
RasterImage
>
newImage
=
new
RasterImage
(
aURI
)
;
aProgressTracker
-
>
SetImage
(
newImage
)
;
newImage
-
>
SetProgressTracker
(
aProgressTracker
)
;
rv
=
newImage
-
>
Init
(
aMimeType
.
get
(
)
aImageFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
BadImage
(
"
RasterImage
:
:
Init
failed
"
newImage
)
;
}
newImage
-
>
SetInnerWindowID
(
aInnerWindowId
)
;
uint32_t
len
=
GetContentSize
(
aRequest
)
;
if
(
len
>
0
)
{
uint32_t
sizeHint
=
std
:
:
min
<
uint32_t
>
(
len
20000000
)
;
rv
=
newImage
-
>
SetSourceSizeHint
(
sizeHint
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
nsMemory
:
:
HeapMinimize
(
true
)
;
nsresult
rv2
=
newImage
-
>
SetSourceSizeHint
(
sizeHint
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
rv2
)
)
{
NS_WARNING
(
"
About
to
hit
OOM
in
imagelib
!
"
)
;
}
}
}
return
newImage
.
forget
(
)
;
}
already_AddRefed
<
Image
>
ImageFactory
:
:
CreateVectorImage
(
nsIRequest
*
aRequest
ProgressTracker
*
aProgressTracker
const
nsCString
&
aMimeType
ImageURL
*
aURI
uint32_t
aImageFlags
uint32_t
aInnerWindowId
)
{
MOZ_ASSERT
(
aProgressTracker
)
;
nsresult
rv
;
RefPtr
<
VectorImage
>
newImage
=
new
VectorImage
(
aURI
)
;
aProgressTracker
-
>
SetImage
(
newImage
)
;
newImage
-
>
SetProgressTracker
(
aProgressTracker
)
;
rv
=
newImage
-
>
Init
(
aMimeType
.
get
(
)
aImageFlags
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
BadImage
(
"
VectorImage
:
:
Init
failed
"
newImage
)
;
}
newImage
-
>
SetInnerWindowID
(
aInnerWindowId
)
;
rv
=
newImage
-
>
OnStartRequest
(
aRequest
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
BadImage
(
"
VectorImage
:
:
OnStartRequest
failed
"
newImage
)
;
}
return
newImage
.
forget
(
)
;
}
}
}
