#
ifndef
mozilla_image_SurfacePipe_h
#
define
mozilla_image_SurfacePipe_h
#
include
<
stdint
.
h
>
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
AnimationParams
.
h
"
namespace
mozilla
{
namespace
image
{
class
Decoder
;
struct
SurfaceInvalidRect
{
gfx
:
:
IntRect
mInputSpaceRect
;
gfx
:
:
IntRect
mOutputSpaceRect
;
}
;
enum
class
WriteState
:
uint8_t
{
NEED_MORE_DATA
FINISHED
FAILURE
}
;
template
<
typename
PixelType
>
using
NextPixel
=
Variant
<
PixelType
WriteState
>
;
class
SurfaceFilter
{
public
:
SurfaceFilter
(
)
:
mRowPointer
(
nullptr
)
mCol
(
0
)
mPixelSize
(
0
)
{
}
virtual
~
SurfaceFilter
(
)
{
}
uint8_t
*
ResetToFirstRow
(
)
{
mCol
=
0
;
mRowPointer
=
DoResetToFirstRow
(
)
;
return
mRowPointer
;
}
uint8_t
*
AdvanceRow
(
)
{
mCol
=
0
;
mRowPointer
=
DoAdvanceRow
(
)
;
return
mRowPointer
;
}
uint8_t
*
CurrentRowPointer
(
)
const
{
return
mRowPointer
;
}
bool
IsSurfaceFinished
(
)
const
{
return
mRowPointer
=
=
nullptr
;
}
gfx
:
:
IntSize
InputSize
(
)
const
{
return
mInputSize
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WritePixels
(
Func
aFunc
)
{
Maybe
<
WriteState
>
result
;
while
(
!
(
result
=
DoWritePixelsToRow
<
PixelType
>
(
Forward
<
Func
>
(
aFunc
)
)
)
)
{
}
return
*
result
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WritePixelBlocks
(
Func
aFunc
)
{
Maybe
<
WriteState
>
result
;
while
(
!
(
result
=
DoWritePixelBlockToRow
<
PixelType
>
(
Forward
<
Func
>
(
aFunc
)
)
)
)
{
}
return
*
result
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WritePixelsToRow
(
Func
aFunc
)
{
return
DoWritePixelsToRow
<
PixelType
>
(
Forward
<
Func
>
(
aFunc
)
)
.
valueOr
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
template
<
typename
PixelType
>
WriteState
WriteBuffer
(
const
PixelType
*
aSource
)
{
return
WriteBuffer
(
aSource
0
mInputSize
.
width
)
;
}
template
<
typename
PixelType
>
WriteState
WriteBuffer
(
const
PixelType
*
aSource
const
size_t
aStartColumn
const
size_t
aLength
)
{
MOZ_ASSERT
(
mPixelSize
=
=
1
|
|
mPixelSize
=
=
4
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
1
sizeof
(
PixelType
)
=
=
sizeof
(
uint8_t
)
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
4
sizeof
(
PixelType
)
=
=
sizeof
(
uint32_t
)
)
;
if
(
IsSurfaceFinished
(
)
)
{
return
WriteState
:
:
FINISHED
;
}
if
(
MOZ_UNLIKELY
(
!
aSource
)
)
{
NS_WARNING
(
"
Passed
a
null
pointer
to
WriteBuffer
"
)
;
return
WriteState
:
:
FAILURE
;
}
PixelType
*
dest
=
reinterpret_cast
<
PixelType
*
>
(
mRowPointer
)
;
const
size_t
prefixLength
=
std
:
:
min
<
size_t
>
(
mInputSize
.
width
aStartColumn
)
;
if
(
MOZ_UNLIKELY
(
prefixLength
!
=
aStartColumn
)
)
{
NS_WARNING
(
"
Provided
starting
column
is
out
-
of
-
bounds
in
WriteBuffer
"
)
;
}
memset
(
dest
0
mInputSize
.
width
*
sizeof
(
PixelType
)
)
;
dest
+
=
prefixLength
;
const
size_t
bufferLength
=
std
:
:
min
<
size_t
>
(
mInputSize
.
width
-
prefixLength
aLength
)
;
if
(
MOZ_UNLIKELY
(
bufferLength
!
=
aLength
)
)
{
NS_WARNING
(
"
Provided
buffer
length
is
out
-
of
-
bounds
in
WriteBuffer
"
)
;
}
memcpy
(
dest
aSource
bufferLength
*
sizeof
(
PixelType
)
)
;
dest
+
=
bufferLength
;
const
size_t
suffixLength
=
mInputSize
.
width
-
(
prefixLength
+
bufferLength
)
;
memset
(
dest
0
suffixLength
*
sizeof
(
PixelType
)
)
;
AdvanceRow
(
)
;
return
IsSurfaceFinished
(
)
?
WriteState
:
:
FINISHED
:
WriteState
:
:
NEED_MORE_DATA
;
}
WriteState
WriteEmptyRow
(
)
{
if
(
IsSurfaceFinished
(
)
)
{
return
WriteState
:
:
FINISHED
;
}
memset
(
mRowPointer
0
mInputSize
.
width
*
mPixelSize
)
;
AdvanceRow
(
)
;
return
IsSurfaceFinished
(
)
?
WriteState
:
:
FINISHED
:
WriteState
:
:
NEED_MORE_DATA
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WriteUnsafeComputedRow
(
Func
aFunc
)
{
MOZ_ASSERT
(
mPixelSize
=
=
1
|
|
mPixelSize
=
=
4
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
1
sizeof
(
PixelType
)
=
=
sizeof
(
uint8_t
)
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
4
sizeof
(
PixelType
)
=
=
sizeof
(
uint32_t
)
)
;
if
(
IsSurfaceFinished
(
)
)
{
return
WriteState
:
:
FINISHED
;
}
PixelType
*
rowPtr
=
reinterpret_cast
<
PixelType
*
>
(
mRowPointer
)
;
aFunc
(
rowPtr
mInputSize
.
width
)
;
AdvanceRow
(
)
;
return
IsSurfaceFinished
(
)
?
WriteState
:
:
FINISHED
:
WriteState
:
:
NEED_MORE_DATA
;
}
virtual
bool
IsValidPalettedPipe
(
)
const
{
return
false
;
}
virtual
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
=
0
;
protected
:
virtual
uint8_t
*
DoResetToFirstRow
(
)
=
0
;
virtual
uint8_t
*
DoAdvanceRow
(
)
=
0
;
void
ConfigureFilter
(
gfx
:
:
IntSize
aInputSize
uint8_t
aPixelSize
)
{
mInputSize
=
aInputSize
;
mPixelSize
=
aPixelSize
;
ResetToFirstRow
(
)
;
}
private
:
template
<
typename
PixelType
typename
Func
>
Maybe
<
WriteState
>
DoWritePixelBlockToRow
(
Func
aFunc
)
{
MOZ_ASSERT
(
mPixelSize
=
=
1
|
|
mPixelSize
=
=
4
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
1
sizeof
(
PixelType
)
=
=
sizeof
(
uint8_t
)
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
4
sizeof
(
PixelType
)
=
=
sizeof
(
uint32_t
)
)
;
if
(
IsSurfaceFinished
(
)
)
{
return
Some
(
WriteState
:
:
FINISHED
)
;
}
PixelType
*
rowPtr
=
reinterpret_cast
<
PixelType
*
>
(
mRowPointer
)
;
int32_t
remainder
=
mInputSize
.
width
-
mCol
;
int32_t
written
;
Maybe
<
WriteState
>
result
;
Tie
(
written
result
)
=
aFunc
(
&
rowPtr
[
mCol
]
remainder
)
;
if
(
written
=
=
remainder
)
{
MOZ_ASSERT
(
result
.
isNothing
(
)
)
;
mCol
=
mInputSize
.
width
;
AdvanceRow
(
)
;
return
IsSurfaceFinished
(
)
?
Some
(
WriteState
:
:
FINISHED
)
:
Nothing
(
)
;
}
MOZ_ASSERT
(
written
>
=
0
&
&
written
<
remainder
)
;
MOZ_ASSERT
(
result
.
isSome
(
)
)
;
mCol
+
=
written
;
if
(
*
result
=
=
WriteState
:
:
FINISHED
)
{
ZeroOutRestOfSurface
<
PixelType
>
(
)
;
}
return
result
;
}
template
<
typename
PixelType
typename
Func
>
Maybe
<
WriteState
>
DoWritePixelsToRow
(
Func
aFunc
)
{
MOZ_ASSERT
(
mPixelSize
=
=
1
|
|
mPixelSize
=
=
4
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
1
sizeof
(
PixelType
)
=
=
sizeof
(
uint8_t
)
)
;
MOZ_ASSERT_IF
(
mPixelSize
=
=
4
sizeof
(
PixelType
)
=
=
sizeof
(
uint32_t
)
)
;
if
(
IsSurfaceFinished
(
)
)
{
return
Some
(
WriteState
:
:
FINISHED
)
;
}
PixelType
*
rowPtr
=
reinterpret_cast
<
PixelType
*
>
(
mRowPointer
)
;
for
(
;
mCol
<
mInputSize
.
width
;
+
+
mCol
)
{
NextPixel
<
PixelType
>
result
=
aFunc
(
)
;
if
(
result
.
template
is
<
PixelType
>
(
)
)
{
rowPtr
[
mCol
]
=
result
.
template
as
<
PixelType
>
(
)
;
continue
;
}
switch
(
result
.
template
as
<
WriteState
>
(
)
)
{
case
WriteState
:
:
NEED_MORE_DATA
:
return
Some
(
WriteState
:
:
NEED_MORE_DATA
)
;
case
WriteState
:
:
FINISHED
:
ZeroOutRestOfSurface
<
PixelType
>
(
)
;
return
Some
(
WriteState
:
:
FINISHED
)
;
case
WriteState
:
:
FAILURE
:
return
Some
(
WriteState
:
:
FAILURE
)
;
}
}
AdvanceRow
(
)
;
return
IsSurfaceFinished
(
)
?
Some
(
WriteState
:
:
FINISHED
)
:
Nothing
(
)
;
}
template
<
typename
PixelType
>
void
ZeroOutRestOfSurface
(
)
{
WritePixels
<
PixelType
>
(
[
]
{
return
AsVariant
(
PixelType
(
0
)
)
;
}
)
;
}
gfx
:
:
IntSize
mInputSize
;
uint8_t
*
mRowPointer
;
int32_t
mCol
;
uint8_t
mPixelSize
;
}
;
class
SurfacePipe
{
public
:
SurfacePipe
(
)
{
}
SurfacePipe
(
SurfacePipe
&
&
aOther
)
:
mHead
(
std
:
:
move
(
aOther
.
mHead
)
)
{
}
~
SurfacePipe
(
)
{
}
SurfacePipe
&
operator
=
(
SurfacePipe
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
)
;
mHead
=
std
:
:
move
(
aOther
.
mHead
)
;
return
*
this
;
}
void
ResetToFirstRow
(
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
mHead
-
>
ResetToFirstRow
(
)
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WritePixels
(
Func
aFunc
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
WritePixels
<
PixelType
>
(
Forward
<
Func
>
(
aFunc
)
)
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WritePixelBlocks
(
Func
aFunc
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
WritePixelBlocks
<
PixelType
>
(
Forward
<
Func
>
(
aFunc
)
)
;
}
template
<
typename
PixelType
typename
Func
>
WriteState
WritePixelsToRow
(
Func
aFunc
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
WritePixelsToRow
<
PixelType
>
(
Forward
<
Func
>
(
aFunc
)
)
;
}
template
<
typename
PixelType
>
WriteState
WriteBuffer
(
const
PixelType
*
aSource
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
WriteBuffer
<
PixelType
>
(
aSource
)
;
}
template
<
typename
PixelType
>
WriteState
WriteBuffer
(
const
PixelType
*
aSource
const
size_t
aStartColumn
const
size_t
aLength
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
WriteBuffer
<
PixelType
>
(
aSource
aStartColumn
aLength
)
;
}
WriteState
WriteEmptyRow
(
)
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
WriteEmptyRow
(
)
;
}
bool
IsSurfaceFinished
(
)
const
{
return
mHead
-
>
IsSurfaceFinished
(
)
;
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
const
{
MOZ_ASSERT
(
mHead
"
Use
before
configured
!
"
)
;
return
mHead
-
>
TakeInvalidRect
(
)
;
}
private
:
friend
class
SurfacePipeFactory
;
friend
class
TestSurfacePipeFactory
;
explicit
SurfacePipe
(
UniquePtr
<
SurfaceFilter
>
&
&
aHead
)
:
mHead
(
std
:
:
move
(
aHead
)
)
{
}
SurfacePipe
(
const
SurfacePipe
&
)
=
delete
;
SurfacePipe
&
operator
=
(
const
SurfacePipe
&
)
=
delete
;
UniquePtr
<
SurfaceFilter
>
mHead
;
}
;
class
AbstractSurfaceSink
:
public
SurfaceFilter
{
public
:
AbstractSurfaceSink
(
)
:
mImageData
(
nullptr
)
mImageDataLength
(
0
)
mRow
(
0
)
mFlipVertically
(
false
)
{
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
final
;
protected
:
uint8_t
*
DoResetToFirstRow
(
)
final
;
uint8_t
*
DoAdvanceRow
(
)
final
;
virtual
uint8_t
*
GetRowPointer
(
)
const
=
0
;
gfx
:
:
IntRect
mInvalidRect
;
uint8_t
*
mImageData
;
uint32_t
mImageDataLength
;
uint32_t
mRow
;
bool
mFlipVertically
;
}
;
class
SurfaceSink
;
struct
SurfaceConfig
{
using
Filter
=
SurfaceSink
;
Decoder
*
mDecoder
;
gfx
:
:
IntSize
mOutputSize
;
gfx
:
:
SurfaceFormat
mFormat
;
bool
mFlipVertically
;
Maybe
<
AnimationParams
>
mAnimParams
;
}
;
class
SurfaceSink
final
:
public
AbstractSurfaceSink
{
public
:
nsresult
Configure
(
const
SurfaceConfig
&
aConfig
)
;
protected
:
uint8_t
*
GetRowPointer
(
)
const
override
;
}
;
class
PalettedSurfaceSink
;
struct
PalettedSurfaceConfig
{
using
Filter
=
PalettedSurfaceSink
;
Decoder
*
mDecoder
;
gfx
:
:
IntSize
mOutputSize
;
gfx
:
:
IntRect
mFrameRect
;
gfx
:
:
SurfaceFormat
mFormat
;
uint8_t
mPaletteDepth
;
bool
mFlipVertically
;
Maybe
<
AnimationParams
>
mAnimParams
;
}
;
class
PalettedSurfaceSink
final
:
public
AbstractSurfaceSink
{
public
:
bool
IsValidPalettedPipe
(
)
const
override
{
return
true
;
}
nsresult
Configure
(
const
PalettedSurfaceConfig
&
aConfig
)
;
protected
:
uint8_t
*
GetRowPointer
(
)
const
override
;
private
:
gfx
:
:
IntRect
mFrameRect
;
}
;
}
}
#
endif
