#
ifndef
mozilla_image_Image_h
#
define
mozilla_image_Image_h
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
ImageURL
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
ProgressTracker
.
h
"
#
include
"
SurfaceCache
.
h
"
class
nsIRequest
;
class
nsIInputStream
;
namespace
mozilla
{
namespace
image
{
class
Image
;
struct
MemoryCounter
{
MemoryCounter
(
)
:
mSource
(
0
)
mDecodedHeap
(
0
)
mDecodedNonHeap
(
0
)
mSharedHandles
(
0
)
{
}
void
SetSource
(
size_t
aCount
)
{
mSource
=
aCount
;
}
size_t
Source
(
)
const
{
return
mSource
;
}
void
SetDecodedHeap
(
size_t
aCount
)
{
mDecodedHeap
=
aCount
;
}
size_t
DecodedHeap
(
)
const
{
return
mDecodedHeap
;
}
void
SetDecodedNonHeap
(
size_t
aCount
)
{
mDecodedNonHeap
=
aCount
;
}
size_t
DecodedNonHeap
(
)
const
{
return
mDecodedNonHeap
;
}
void
SetSharedHandles
(
size_t
aCount
)
{
mSharedHandles
=
aCount
;
}
size_t
SharedHandles
(
)
const
{
return
mSharedHandles
;
}
MemoryCounter
&
operator
+
=
(
const
MemoryCounter
&
aOther
)
{
mSource
+
=
aOther
.
mSource
;
mDecodedHeap
+
=
aOther
.
mDecodedHeap
;
mDecodedNonHeap
+
=
aOther
.
mDecodedNonHeap
;
mSharedHandles
+
=
aOther
.
mSharedHandles
;
return
*
this
;
}
private
:
size_t
mSource
;
size_t
mDecodedHeap
;
size_t
mDecodedNonHeap
;
size_t
mSharedHandles
;
}
;
enum
class
SurfaceMemoryCounterType
{
NORMAL
COMPOSITING
COMPOSITING_PREV
}
;
struct
SurfaceMemoryCounter
{
SurfaceMemoryCounter
(
const
SurfaceKey
&
aKey
bool
aIsLocked
bool
aCannotSubstitute
bool
aIsFactor2
SurfaceMemoryCounterType
aType
=
SurfaceMemoryCounterType
:
:
NORMAL
)
:
mKey
(
aKey
)
mType
(
aType
)
mIsLocked
(
aIsLocked
)
mCannotSubstitute
(
aCannotSubstitute
)
mIsFactor2
(
aIsFactor2
)
{
}
const
SurfaceKey
&
Key
(
)
const
{
return
mKey
;
}
MemoryCounter
&
Values
(
)
{
return
mValues
;
}
const
MemoryCounter
&
Values
(
)
const
{
return
mValues
;
}
SurfaceMemoryCounterType
Type
(
)
const
{
return
mType
;
}
bool
IsLocked
(
)
const
{
return
mIsLocked
;
}
bool
CannotSubstitute
(
)
const
{
return
mCannotSubstitute
;
}
bool
IsFactor2
(
)
const
{
return
mIsFactor2
;
}
private
:
const
SurfaceKey
mKey
;
MemoryCounter
mValues
;
const
SurfaceMemoryCounterType
mType
;
const
bool
mIsLocked
;
const
bool
mCannotSubstitute
;
const
bool
mIsFactor2
;
}
;
struct
ImageMemoryCounter
{
ImageMemoryCounter
(
Image
*
aImage
SizeOfState
&
aState
bool
aIsUsed
)
;
nsCString
&
URI
(
)
{
return
mURI
;
}
const
nsCString
&
URI
(
)
const
{
return
mURI
;
}
const
nsTArray
<
SurfaceMemoryCounter
>
&
Surfaces
(
)
const
{
return
mSurfaces
;
}
const
gfx
:
:
IntSize
IntrinsicSize
(
)
const
{
return
mIntrinsicSize
;
}
const
MemoryCounter
&
Values
(
)
const
{
return
mValues
;
}
uint16_t
Type
(
)
const
{
return
mType
;
}
bool
IsUsed
(
)
const
{
return
mIsUsed
;
}
bool
IsNotable
(
)
const
{
const
size_t
NotableThreshold
=
16
*
1024
;
size_t
total
=
mValues
.
Source
(
)
+
mValues
.
DecodedHeap
(
)
+
mValues
.
DecodedNonHeap
(
)
;
return
total
>
=
NotableThreshold
;
}
private
:
nsCString
mURI
;
nsTArray
<
SurfaceMemoryCounter
>
mSurfaces
;
gfx
:
:
IntSize
mIntrinsicSize
;
MemoryCounter
mValues
;
uint16_t
mType
;
const
bool
mIsUsed
;
}
;
class
Image
:
public
imgIContainer
{
public
:
static
const
uint32_t
INIT_FLAG_NONE
=
0x0
;
static
const
uint32_t
INIT_FLAG_DISCARDABLE
=
0x1
;
static
const
uint32_t
INIT_FLAG_DECODE_IMMEDIATELY
=
0x2
;
static
const
uint32_t
INIT_FLAG_TRANSIENT
=
0x4
;
static
const
uint32_t
INIT_FLAG_SYNC_LOAD
=
0x8
;
virtual
already_AddRefed
<
ProgressTracker
>
GetProgressTracker
(
)
=
0
;
virtual
void
SetProgressTracker
(
ProgressTracker
*
aProgressTracker
)
{
}
virtual
size_t
SizeOfSourceWithComputedFallback
(
SizeOfState
&
aState
)
const
=
0
;
virtual
void
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
=
0
;
virtual
void
IncrementAnimationConsumers
(
)
=
0
;
virtual
void
DecrementAnimationConsumers
(
)
=
0
;
#
ifdef
DEBUG
virtual
uint32_t
GetAnimationConsumers
(
)
=
0
;
#
endif
virtual
nsresult
OnImageDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
=
0
;
virtual
nsresult
OnImageDataComplete
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
bool
aLastPart
)
=
0
;
virtual
void
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
=
0
;
virtual
void
SetInnerWindowID
(
uint64_t
aInnerWindowId
)
=
0
;
virtual
uint64_t
InnerWindowID
(
)
const
=
0
;
virtual
bool
HasError
(
)
=
0
;
virtual
void
SetHasError
(
)
=
0
;
virtual
ImageURL
*
GetURI
(
)
=
0
;
virtual
void
ReportUseCounters
(
)
{
}
}
;
class
ImageResource
:
public
Image
{
public
:
already_AddRefed
<
ProgressTracker
>
GetProgressTracker
(
)
override
{
RefPtr
<
ProgressTracker
>
progressTracker
=
mProgressTracker
;
MOZ_ASSERT
(
progressTracker
)
;
return
progressTracker
.
forget
(
)
;
}
void
SetProgressTracker
(
ProgressTracker
*
aProgressTracker
)
override
final
{
MOZ_ASSERT
(
aProgressTracker
)
;
MOZ_ASSERT
(
!
mProgressTracker
)
;
mProgressTracker
=
aProgressTracker
;
}
virtual
void
IncrementAnimationConsumers
(
)
override
;
virtual
void
DecrementAnimationConsumers
(
)
override
;
#
ifdef
DEBUG
virtual
uint32_t
GetAnimationConsumers
(
)
override
{
return
mAnimationConsumers
;
}
#
endif
virtual
void
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
override
{
}
virtual
void
SetInnerWindowID
(
uint64_t
aInnerWindowId
)
override
{
mInnerWindowId
=
aInnerWindowId
;
}
virtual
uint64_t
InnerWindowID
(
)
const
override
{
return
mInnerWindowId
;
}
virtual
bool
HasError
(
)
override
{
return
mError
;
}
virtual
void
SetHasError
(
)
override
{
mError
=
true
;
}
virtual
ImageURL
*
GetURI
(
)
override
{
return
mURI
.
get
(
)
;
}
protected
:
explicit
ImageResource
(
ImageURL
*
aURI
)
;
~
ImageResource
(
)
;
nsresult
GetAnimationModeInternal
(
uint16_t
*
aAnimationMode
)
;
nsresult
SetAnimationModeInternal
(
uint16_t
aAnimationMode
)
;
bool
HadRecentRefresh
(
const
TimeStamp
&
aTime
)
;
virtual
void
EvaluateAnimation
(
)
;
virtual
bool
ShouldAnimate
(
)
{
return
mAnimationConsumers
>
0
&
&
mAnimationMode
!
=
kDontAnimMode
;
}
virtual
nsresult
StartAnimation
(
)
=
0
;
virtual
nsresult
StopAnimation
(
)
=
0
;
void
SendOnUnlockedDraw
(
uint32_t
aFlags
)
;
#
ifdef
DEBUG
void
NotifyDrawingObservers
(
)
;
#
endif
RefPtr
<
ProgressTracker
>
mProgressTracker
;
RefPtr
<
ImageURL
>
mURI
;
TimeStamp
mLastRefreshTime
;
uint64_t
mInnerWindowId
;
uint32_t
mAnimationConsumers
;
uint16_t
mAnimationMode
;
bool
mInitialized
:
1
;
bool
mAnimating
:
1
;
bool
mError
:
1
;
virtual
Tuple
<
DrawResult
gfx
:
:
IntSize
RefPtr
<
gfx
:
:
SourceSurface
>
>
GetFrameInternal
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
return
MakeTuple
(
DrawResult
:
:
BAD_IMAGE
aSize
RefPtr
<
gfx
:
:
SourceSurface
>
(
)
)
;
}
virtual
gfx
:
:
IntSize
GetImageContainerSize
(
layers
:
:
LayerManager
*
aManager
const
gfx
:
:
IntSize
&
aSize
uint32_t
aFlags
)
{
return
gfx
:
:
IntSize
(
0
0
)
;
}
already_AddRefed
<
layers
:
:
ImageContainer
>
GetImageContainerImpl
(
layers
:
:
LayerManager
*
aManager
const
gfx
:
:
IntSize
&
aSize
uint32_t
aFlags
)
;
void
UpdateImageContainer
(
)
;
void
ReleaseImageContainer
(
)
;
private
:
void
SetCurrentImage
(
layers
:
:
ImageContainer
*
aContainer
gfx
:
:
SourceSurface
*
aSurface
bool
aInTransaction
)
;
struct
ImageContainerEntry
{
ImageContainerEntry
(
const
gfx
:
:
IntSize
&
aSize
layers
:
:
ImageContainer
*
aContainer
uint32_t
aFlags
)
:
mSize
(
aSize
)
mContainer
(
aContainer
)
mLastDrawResult
(
DrawResult
:
:
NOT_READY
)
mFlags
(
aFlags
)
{
}
gfx
:
:
IntSize
mSize
;
WeakPtr
<
layers
:
:
ImageContainer
>
mContainer
;
DrawResult
mLastDrawResult
;
uint32_t
mFlags
;
}
;
AutoTArray
<
ImageContainerEntry
1
>
mImageContainers
;
layers
:
:
ImageContainer
:
:
ProducerID
mImageProducerID
;
layers
:
:
ImageContainer
:
:
FrameID
mLastFrameID
;
}
;
}
}
#
endif
