#
include
"
Decoder
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
ISurfaceProvider
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
using
mozilla
:
:
gfx
:
:
IntSize
;
using
mozilla
:
:
gfx
:
:
SurfaceFormat
;
namespace
mozilla
{
namespace
image
{
class
MOZ_STACK_CLASS
AutoRecordDecoderTelemetry
final
{
public
:
explicit
AutoRecordDecoderTelemetry
(
Decoder
*
aDecoder
)
:
mDecoder
(
aDecoder
)
{
MOZ_ASSERT
(
mDecoder
)
;
mStartTime
=
TimeStamp
:
:
Now
(
)
;
}
~
AutoRecordDecoderTelemetry
(
)
{
mDecoder
-
>
mDecodeTime
+
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
;
}
private
:
Decoder
*
mDecoder
;
TimeStamp
mStartTime
;
}
;
Decoder
:
:
Decoder
(
RasterImage
*
aImage
)
:
mImageData
(
nullptr
)
mImageDataLength
(
0
)
mColormap
(
nullptr
)
mColormapSize
(
0
)
mImage
(
aImage
)
mProgress
(
NoProgress
)
mFrameCount
(
0
)
mLoopLength
(
FrameTimeout
:
:
Zero
(
)
)
mDecoderFlags
(
DefaultDecoderFlags
(
)
)
mSurfaceFlags
(
DefaultSurfaceFlags
(
)
)
mInitialized
(
false
)
mMetadataDecode
(
false
)
mHaveExplicitOutputSize
(
false
)
mInFrame
(
false
)
mFinishedNewFrame
(
false
)
mReachedTerminalState
(
false
)
mDecodeDone
(
false
)
mError
(
false
)
mDecodeAborted
(
false
)
mShouldReportError
(
false
)
{
}
Decoder
:
:
~
Decoder
(
)
{
MOZ_ASSERT
(
mProgress
=
=
NoProgress
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
progress
changes
"
)
;
MOZ_ASSERT
(
mInvalidRect
.
IsEmpty
(
)
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
invalidations
"
)
;
mInitialized
=
false
;
if
(
mImage
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThread
(
mImage
.
forget
(
)
)
;
}
}
nsresult
Decoder
:
:
Init
(
)
{
MOZ_ASSERT
(
!
mInitialized
"
Can
'
t
re
-
initialize
a
decoder
!
"
)
;
MOZ_ASSERT
(
mIterator
)
;
MOZ_ASSERT_IF
(
mMetadataDecode
!
mHaveExplicitOutputSize
)
;
MOZ_ASSERT
(
ShouldUseSurfaceCache
(
)
|
|
IsFirstFrameDecode
(
)
)
;
nsresult
rv
=
InitInternal
(
)
;
mInitialized
=
true
;
return
rv
;
}
LexerResult
Decoder
:
:
Decode
(
IResumable
*
aOnResume
)
{
MOZ_ASSERT
(
mInitialized
"
Should
be
initialized
here
"
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
if
(
GetDecodeDone
(
)
)
{
return
LexerResult
(
HasError
(
)
?
TerminalState
:
:
FAILURE
:
TerminalState
:
:
SUCCESS
)
;
}
LexerResult
lexerResult
(
TerminalState
:
:
FAILURE
)
;
{
PROFILER_LABEL
(
"
ImageDecoder
"
"
Decode
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
AutoRecordDecoderTelemetry
telemetry
(
this
)
;
lexerResult
=
DoDecode
(
*
mIterator
aOnResume
)
;
}
;
if
(
lexerResult
.
is
<
Yield
>
(
)
)
{
return
lexerResult
;
}
MOZ_ASSERT
(
lexerResult
.
is
<
TerminalState
>
(
)
)
;
mReachedTerminalState
=
true
;
if
(
lexerResult
.
as
<
TerminalState
>
(
)
=
=
TerminalState
:
:
FAILURE
)
{
PostError
(
)
;
}
CompleteDecode
(
)
;
return
LexerResult
(
HasError
(
)
?
TerminalState
:
:
FAILURE
:
TerminalState
:
:
SUCCESS
)
;
}
LexerResult
Decoder
:
:
TerminateFailure
(
)
{
PostError
(
)
;
if
(
!
mReachedTerminalState
)
{
mReachedTerminalState
=
true
;
CompleteDecode
(
)
;
}
return
LexerResult
(
TerminalState
:
:
FAILURE
)
;
}
bool
Decoder
:
:
ShouldSyncDecode
(
size_t
aByteLimit
)
{
MOZ_ASSERT
(
aByteLimit
>
0
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
return
mIterator
-
>
RemainingBytesIsNoMoreThan
(
aByteLimit
)
;
}
void
Decoder
:
:
CompleteDecode
(
)
{
nsresult
rv
=
BeforeFinishInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PostError
(
)
;
}
rv
=
HasError
(
)
?
FinishWithErrorInternal
(
)
:
FinishInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PostError
(
)
;
}
if
(
IsMetadataDecode
(
)
&
&
!
HasSize
(
)
)
{
PostError
(
)
;
}
if
(
mInFrame
&
&
!
HasError
(
)
)
{
PostFrameStop
(
)
;
}
if
(
!
IsMetadataDecode
(
)
&
&
!
mDecodeDone
&
&
!
WasAborted
(
)
)
{
mShouldReportError
=
true
;
if
(
GetCompleteFrameCount
(
)
>
0
)
{
PostHasTransparency
(
)
;
if
(
mInFrame
)
{
PostFrameStop
(
)
;
}
PostDecodeDone
(
)
;
}
else
{
if
(
!
IsMetadataDecode
(
)
)
{
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
mProgress
|
=
FLAG_HAS_ERROR
;
}
}
if
(
mDecodeDone
&
&
!
IsMetadataDecode
(
)
)
{
MOZ_ASSERT
(
HasError
(
)
|
|
mCurrentFrame
"
Should
have
an
error
or
a
frame
"
)
;
if
(
!
HasAnimation
(
)
&
&
!
(
mDecoderFlags
&
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
)
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
SetOptimizable
(
)
;
}
}
}
void
Decoder
:
:
SetOutputSize
(
const
gfx
:
:
IntSize
&
aSize
)
{
mOutputSize
=
Some
(
aSize
)
;
mHaveExplicitOutputSize
=
true
;
}
Maybe
<
gfx
:
:
IntSize
>
Decoder
:
:
ExplicitOutputSize
(
)
const
{
MOZ_ASSERT_IF
(
mHaveExplicitOutputSize
mOutputSize
)
;
return
mHaveExplicitOutputSize
?
mOutputSize
:
Nothing
(
)
;
}
Maybe
<
uint32_t
>
Decoder
:
:
TakeCompleteFrameCount
(
)
{
const
bool
finishedNewFrame
=
mFinishedNewFrame
;
mFinishedNewFrame
=
false
;
return
finishedNewFrame
?
Some
(
GetCompleteFrameCount
(
)
)
:
Nothing
(
)
;
}
DecoderTelemetry
Decoder
:
:
Telemetry
(
)
const
{
MOZ_ASSERT
(
mIterator
)
;
return
DecoderTelemetry
(
SpeedHistogram
(
)
mIterator
-
>
ByteCount
(
)
mIterator
-
>
ChunkCount
(
)
mDecodeTime
)
;
}
nsresult
Decoder
:
:
AllocateFrame
(
uint32_t
aFrameNum
const
gfx
:
:
IntSize
&
aOutputSize
const
gfx
:
:
IntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
)
{
mCurrentFrame
=
AllocateFrameInternal
(
aFrameNum
aOutputSize
aFrameRect
aFormat
aPaletteDepth
mCurrentFrame
.
get
(
)
)
;
if
(
mCurrentFrame
)
{
mCurrentFrame
-
>
GetImageData
(
&
mImageData
&
mImageDataLength
)
;
mCurrentFrame
-
>
GetPaletteData
(
&
mColormap
&
mColormapSize
)
;
MOZ_ASSERT
(
aFrameNum
+
1
=
=
mFrameCount
)
;
MOZ_ASSERT_IF
(
mFrameCount
>
1
HasAnimation
(
)
)
;
MOZ_ASSERT
(
!
mInFrame
"
Starting
new
frame
but
not
done
with
old
one
!
"
)
;
mInFrame
=
true
;
}
return
mCurrentFrame
?
NS_OK
:
NS_ERROR_FAILURE
;
}
RawAccessFrameRef
Decoder
:
:
AllocateFrameInternal
(
uint32_t
aFrameNum
const
gfx
:
:
IntSize
&
aOutputSize
const
gfx
:
:
IntRect
&
aFrameRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
imgFrame
*
aPreviousFrame
)
{
if
(
HasError
(
)
)
{
return
RawAccessFrameRef
(
)
;
}
if
(
aFrameNum
!
=
mFrameCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Allocating
frames
out
of
order
"
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
aOutputSize
.
width
<
=
0
|
|
aOutputSize
.
height
<
=
0
|
|
aFrameRect
.
width
<
=
0
|
|
aFrameRect
.
height
<
=
0
)
{
NS_WARNING
(
"
Trying
to
add
frame
with
zero
or
negative
size
"
)
;
return
RawAccessFrameRef
(
)
;
}
const
uint32_t
bytesPerPixel
=
aPaletteDepth
=
=
0
?
4
:
1
;
if
(
ShouldUseSurfaceCache
(
)
&
&
!
SurfaceCache
:
:
CanHold
(
aFrameRect
.
Size
(
)
bytesPerPixel
)
)
{
NS_WARNING
(
"
Trying
to
add
frame
that
'
s
too
large
for
the
SurfaceCache
"
)
;
return
RawAccessFrameRef
(
)
;
}
NotNull
<
RefPtr
<
imgFrame
>
>
frame
=
WrapNotNull
(
new
imgFrame
(
)
)
;
bool
nonPremult
=
bool
(
mSurfaceFlags
&
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
)
;
if
(
NS_FAILED
(
frame
-
>
InitForDecoder
(
aOutputSize
aFrameRect
aFormat
aPaletteDepth
nonPremult
)
)
)
{
NS_WARNING
(
"
imgFrame
:
:
Init
should
succeed
"
)
;
return
RawAccessFrameRef
(
)
;
}
RawAccessFrameRef
ref
=
frame
-
>
RawAccessRef
(
)
;
if
(
!
ref
)
{
frame
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
ShouldUseSurfaceCache
(
)
)
{
NotNull
<
RefPtr
<
ISurfaceProvider
>
>
provider
=
WrapNotNull
(
new
SimpleSurfaceProvider
(
frame
)
)
;
InsertOutcome
outcome
=
SurfaceCache
:
:
Insert
(
provider
ImageKey
(
mImage
.
get
(
)
)
RasterSurfaceKey
(
aOutputSize
mSurfaceFlags
aFrameNum
)
)
;
if
(
outcome
=
=
InsertOutcome
:
:
FAILURE
)
{
ref
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
else
if
(
outcome
=
=
InsertOutcome
:
:
FAILURE_ALREADY_PRESENT
)
{
mDecodeAborted
=
true
;
ref
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
}
if
(
aFrameNum
=
=
1
)
{
MOZ_ASSERT
(
aPreviousFrame
"
Must
provide
a
previous
frame
when
animated
"
)
;
aPreviousFrame
-
>
SetRawAccessOnly
(
)
;
AnimationData
previousFrameData
=
aPreviousFrame
-
>
GetAnimationData
(
)
;
if
(
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR
|
|
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR_ALL
|
|
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
mFirstFrameRefreshArea
=
previousFrameData
.
mRect
;
}
}
if
(
aFrameNum
>
0
)
{
ref
-
>
SetRawAccessOnly
(
)
;
mFirstFrameRefreshArea
.
UnionRect
(
mFirstFrameRefreshArea
frame
-
>
GetRect
(
)
)
;
}
mFrameCount
+
+
;
return
ref
;
}
nsresult
Decoder
:
:
InitInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
BeforeFinishInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
FinishInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
FinishWithErrorInternal
(
)
{
return
NS_OK
;
}
void
Decoder
:
:
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
)
{
MOZ_ASSERT
(
aWidth
>
=
0
"
Width
can
'
t
be
negative
!
"
)
;
MOZ_ASSERT
(
aHeight
>
=
0
"
Height
can
'
t
be
negative
!
"
)
;
mImageMetadata
.
SetSize
(
aWidth
aHeight
aOrientation
)
;
if
(
!
mOutputSize
)
{
mOutputSize
=
Some
(
IntSize
(
aWidth
aHeight
)
)
;
}
MOZ_ASSERT
(
mOutputSize
-
>
width
<
=
aWidth
&
&
mOutputSize
-
>
height
<
=
aHeight
"
Output
size
will
result
in
upscaling
"
)
;
if
(
mOutputSize
-
>
width
<
aWidth
|
|
mOutputSize
-
>
height
<
aHeight
)
{
mDownscaler
.
emplace
(
*
mOutputSize
)
;
}
mProgress
|
=
FLAG_SIZE_AVAILABLE
;
}
void
Decoder
:
:
PostHasTransparency
(
)
{
mProgress
|
=
FLAG_HAS_TRANSPARENCY
;
}
void
Decoder
:
:
PostIsAnimated
(
FrameTimeout
aFirstFrameTimeout
)
{
mProgress
|
=
FLAG_IS_ANIMATED
;
mImageMetadata
.
SetHasAnimation
(
)
;
mImageMetadata
.
SetFirstFrameTimeout
(
aFirstFrameTimeout
)
;
}
void
Decoder
:
:
PostFrameStop
(
Opacity
aFrameOpacity
DisposalMethod
aDisposalMethod
FrameTimeout
aTimeout
BlendMethod
aBlendMethod
const
Maybe
<
nsIntRect
>
&
aBlendRect
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Stopping
frame
during
metadata
decode
"
)
;
MOZ_ASSERT
(
mInFrame
"
Stopping
frame
when
we
didn
'
t
start
one
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Stopping
frame
when
we
don
'
t
have
one
"
)
;
mInFrame
=
false
;
mFinishedNewFrame
=
true
;
mCurrentFrame
-
>
Finish
(
aFrameOpacity
aDisposalMethod
aTimeout
aBlendMethod
aBlendRect
)
;
mProgress
|
=
FLAG_FRAME_COMPLETE
;
mLoopLength
+
=
aTimeout
;
if
(
!
ShouldSendPartialInvalidations
(
)
&
&
mFrameCount
=
=
1
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
IntRect
(
IntPoint
(
)
Size
(
)
)
)
;
}
}
void
Decoder
:
:
PostInvalidation
(
const
gfx
:
:
IntRect
&
aRect
const
Maybe
<
gfx
:
:
IntRect
>
&
aRectAtOutputSize
)
{
MOZ_ASSERT
(
mInFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
if
(
ShouldSendPartialInvalidations
(
)
&
&
mFrameCount
=
=
1
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
aRect
)
;
mCurrentFrame
-
>
ImageUpdated
(
aRectAtOutputSize
.
valueOr
(
aRect
)
)
;
}
}
void
Decoder
:
:
PostDecodeDone
(
int32_t
aLoopCount
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Done
with
decoding
in
metadata
decode
"
)
;
MOZ_ASSERT
(
!
mInFrame
"
Can
'
t
be
done
decoding
if
we
'
re
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
!
mDecodeDone
"
Decode
already
done
!
"
)
;
mDecodeDone
=
true
;
mImageMetadata
.
SetLoopCount
(
aLoopCount
)
;
if
(
!
IsFirstFrameDecode
(
)
)
{
mImageMetadata
.
SetLoopLength
(
mLoopLength
)
;
mImageMetadata
.
SetFirstFrameRefreshArea
(
mFirstFrameRefreshArea
)
;
}
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
void
Decoder
:
:
PostError
(
)
{
mError
=
true
;
if
(
mInFrame
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
Abort
(
)
;
}
}
}
}
