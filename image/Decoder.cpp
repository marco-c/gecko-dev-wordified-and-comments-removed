#
include
"
Decoder
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
ISurfaceProvider
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
using
mozilla
:
:
gfx
:
:
IntSize
;
using
mozilla
:
:
gfx
:
:
SurfaceFormat
;
namespace
mozilla
{
namespace
image
{
class
MOZ_STACK_CLASS
AutoRecordDecoderTelemetry
final
{
public
:
AutoRecordDecoderTelemetry
(
Decoder
*
aDecoder
uint32_t
aByteCount
)
:
mDecoder
(
aDecoder
)
{
MOZ_ASSERT
(
mDecoder
)
;
mStartTime
=
TimeStamp
:
:
Now
(
)
;
mDecoder
-
>
mChunkCount
+
+
;
mDecoder
-
>
mBytesDecoded
+
=
aByteCount
;
}
~
AutoRecordDecoderTelemetry
(
)
{
mDecoder
-
>
mDecodeTime
+
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
;
}
private
:
Decoder
*
mDecoder
;
TimeStamp
mStartTime
;
}
;
Decoder
:
:
Decoder
(
RasterImage
*
aImage
)
:
mImageData
(
nullptr
)
mImageDataLength
(
0
)
mColormap
(
nullptr
)
mColormapSize
(
0
)
mImage
(
aImage
)
mProgress
(
NoProgress
)
mFrameCount
(
0
)
mChunkCount
(
0
)
mDecoderFlags
(
DefaultDecoderFlags
(
)
)
mSurfaceFlags
(
DefaultSurfaceFlags
(
)
)
mBytesDecoded
(
0
)
mInitialized
(
false
)
mMetadataDecode
(
false
)
mInFrame
(
false
)
mDataDone
(
false
)
mDecodeDone
(
false
)
mDataError
(
false
)
mDecodeAborted
(
false
)
mShouldReportError
(
false
)
{
}
Decoder
:
:
~
Decoder
(
)
{
MOZ_ASSERT
(
mProgress
=
=
NoProgress
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
progress
changes
"
)
;
MOZ_ASSERT
(
mInvalidRect
.
IsEmpty
(
)
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
invalidations
"
)
;
mInitialized
=
false
;
if
(
mImage
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThread
(
mImage
.
forget
(
)
)
;
}
}
nsresult
Decoder
:
:
Init
(
)
{
MOZ_ASSERT
(
!
mInitialized
"
Can
'
t
re
-
initialize
a
decoder
!
"
)
;
MOZ_ASSERT
(
mIterator
)
;
MOZ_ASSERT
(
ShouldUseSurfaceCache
(
)
|
|
IsFirstFrameDecode
(
)
)
;
nsresult
rv
=
InitInternal
(
)
;
mInitialized
=
true
;
return
rv
;
}
nsresult
Decoder
:
:
Decode
(
NotNull
<
IResumable
*
>
aOnResume
)
{
MOZ_ASSERT
(
mInitialized
"
Should
be
initialized
here
"
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
if
(
GetDecodeDone
(
)
)
{
return
HasError
(
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
while
(
!
GetDecodeDone
(
)
&
&
!
HasError
(
)
)
{
auto
newState
=
mIterator
-
>
AdvanceOrScheduleResume
(
aOnResume
.
get
(
)
)
;
if
(
newState
=
=
SourceBufferIterator
:
:
WAITING
)
{
return
NS_OK
;
}
if
(
newState
=
=
SourceBufferIterator
:
:
COMPLETE
)
{
mDataDone
=
true
;
nsresult
finalStatus
=
mIterator
-
>
CompletionStatus
(
)
;
if
(
NS_FAILED
(
finalStatus
)
)
{
PostDataError
(
)
;
}
CompleteDecode
(
)
;
return
finalStatus
;
}
MOZ_ASSERT
(
newState
=
=
SourceBufferIterator
:
:
READY
)
;
{
PROFILER_LABEL
(
"
ImageDecoder
"
"
Write
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
AutoRecordDecoderTelemetry
telemetry
(
this
mIterator
-
>
Length
(
)
)
;
Maybe
<
TerminalState
>
terminalState
=
DoDecode
(
*
mIterator
)
;
if
(
terminalState
=
=
Some
(
TerminalState
:
:
FAILURE
)
)
{
PostDataError
(
)
;
}
}
}
CompleteDecode
(
)
;
return
HasError
(
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
bool
Decoder
:
:
ShouldSyncDecode
(
size_t
aByteLimit
)
{
MOZ_ASSERT
(
aByteLimit
>
0
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
return
mIterator
-
>
RemainingBytesIsNoMoreThan
(
aByteLimit
)
;
}
void
Decoder
:
:
CompleteDecode
(
)
{
nsresult
rv
=
BeforeFinishInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PostDataError
(
)
;
}
rv
=
HasError
(
)
?
FinishWithErrorInternal
(
)
:
FinishInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PostDataError
(
)
;
}
if
(
IsMetadataDecode
(
)
&
&
!
HasSize
(
)
)
{
PostDataError
(
)
;
}
if
(
mInFrame
&
&
!
HasError
(
)
)
{
PostFrameStop
(
)
;
}
if
(
!
IsMetadataDecode
(
)
&
&
!
mDecodeDone
&
&
!
WasAborted
(
)
)
{
mShouldReportError
=
true
;
if
(
GetCompleteFrameCount
(
)
>
0
)
{
PostHasTransparency
(
)
;
if
(
mInFrame
)
{
PostFrameStop
(
)
;
}
PostDecodeDone
(
)
;
}
else
{
if
(
!
IsMetadataDecode
(
)
)
{
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
mProgress
|
=
FLAG_HAS_ERROR
;
}
}
if
(
mDecodeDone
&
&
!
IsMetadataDecode
(
)
)
{
MOZ_ASSERT
(
HasError
(
)
|
|
mCurrentFrame
"
Should
have
an
error
or
a
frame
"
)
;
if
(
!
HasAnimation
(
)
&
&
!
(
mDecoderFlags
&
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
)
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
SetOptimizable
(
)
;
}
}
}
nsresult
Decoder
:
:
SetTargetSize
(
const
nsIntSize
&
aSize
)
{
if
(
MOZ_UNLIKELY
(
aSize
.
width
<
=
0
|
|
aSize
.
height
<
=
0
)
)
{
return
NS_ERROR_FAILURE
;
}
mDownscaler
.
emplace
(
aSize
)
;
return
NS_OK
;
}
Maybe
<
IntSize
>
Decoder
:
:
GetTargetSize
(
)
{
return
mDownscaler
?
Some
(
mDownscaler
-
>
TargetSize
(
)
)
:
Nothing
(
)
;
}
nsresult
Decoder
:
:
AllocateFrame
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
)
{
mCurrentFrame
=
AllocateFrameInternal
(
aFrameNum
aTargetSize
aFrameRect
aFormat
aPaletteDepth
mCurrentFrame
.
get
(
)
)
;
if
(
mCurrentFrame
)
{
mCurrentFrame
-
>
GetImageData
(
&
mImageData
&
mImageDataLength
)
;
mCurrentFrame
-
>
GetPaletteData
(
&
mColormap
&
mColormapSize
)
;
if
(
aFrameNum
+
1
=
=
mFrameCount
)
{
MOZ_ASSERT_IF
(
mFrameCount
>
1
HasAnimation
(
)
)
;
MOZ_ASSERT
(
!
mInFrame
"
Starting
new
frame
but
not
done
with
old
one
!
"
)
;
mInFrame
=
true
;
}
}
return
mCurrentFrame
?
NS_OK
:
NS_ERROR_FAILURE
;
}
RawAccessFrameRef
Decoder
:
:
AllocateFrameInternal
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
imgFrame
*
aPreviousFrame
)
{
if
(
HasError
(
)
)
{
return
RawAccessFrameRef
(
)
;
}
if
(
aFrameNum
!
=
mFrameCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Allocating
frames
out
of
order
"
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
aTargetSize
.
width
<
=
0
|
|
aTargetSize
.
height
<
=
0
|
|
aFrameRect
.
width
<
=
0
|
|
aFrameRect
.
height
<
=
0
)
{
NS_WARNING
(
"
Trying
to
add
frame
with
zero
or
negative
size
"
)
;
return
RawAccessFrameRef
(
)
;
}
const
uint32_t
bytesPerPixel
=
aPaletteDepth
=
=
0
?
4
:
1
;
if
(
ShouldUseSurfaceCache
(
)
&
&
!
SurfaceCache
:
:
CanHold
(
aFrameRect
.
Size
(
)
bytesPerPixel
)
)
{
NS_WARNING
(
"
Trying
to
add
frame
that
'
s
too
large
for
the
SurfaceCache
"
)
;
return
RawAccessFrameRef
(
)
;
}
NotNull
<
RefPtr
<
imgFrame
>
>
frame
=
WrapNotNull
(
new
imgFrame
(
)
)
;
bool
nonPremult
=
bool
(
mSurfaceFlags
&
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
)
;
if
(
NS_FAILED
(
frame
-
>
InitForDecoder
(
aTargetSize
aFrameRect
aFormat
aPaletteDepth
nonPremult
)
)
)
{
NS_WARNING
(
"
imgFrame
:
:
Init
should
succeed
"
)
;
return
RawAccessFrameRef
(
)
;
}
RawAccessFrameRef
ref
=
frame
-
>
RawAccessRef
(
)
;
if
(
!
ref
)
{
frame
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
ShouldUseSurfaceCache
(
)
)
{
NotNull
<
RefPtr
<
ISurfaceProvider
>
>
provider
=
WrapNotNull
(
new
SimpleSurfaceProvider
(
frame
)
)
;
InsertOutcome
outcome
=
SurfaceCache
:
:
Insert
(
provider
ImageKey
(
mImage
.
get
(
)
)
RasterSurfaceKey
(
aTargetSize
mSurfaceFlags
aFrameNum
)
)
;
if
(
outcome
=
=
InsertOutcome
:
:
FAILURE
)
{
ref
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
else
if
(
outcome
=
=
InsertOutcome
:
:
FAILURE_ALREADY_PRESENT
)
{
mDecodeAborted
=
true
;
ref
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
}
nsIntRect
refreshArea
;
if
(
aFrameNum
=
=
1
)
{
MOZ_ASSERT
(
aPreviousFrame
"
Must
provide
a
previous
frame
when
animated
"
)
;
aPreviousFrame
-
>
SetRawAccessOnly
(
)
;
AnimationData
previousFrameData
=
aPreviousFrame
-
>
GetAnimationData
(
)
;
if
(
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR
|
|
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR_ALL
|
|
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
refreshArea
=
previousFrameData
.
mRect
;
}
}
if
(
aFrameNum
>
0
)
{
ref
-
>
SetRawAccessOnly
(
)
;
refreshArea
.
UnionRect
(
refreshArea
frame
-
>
GetRect
(
)
)
;
}
mFrameCount
+
+
;
if
(
mImage
)
{
mImage
-
>
OnAddedFrame
(
mFrameCount
refreshArea
)
;
}
return
ref
;
}
nsresult
Decoder
:
:
InitInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
BeforeFinishInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
FinishInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
FinishWithErrorInternal
(
)
{
return
NS_OK
;
}
void
Decoder
:
:
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
)
{
MOZ_ASSERT
(
aWidth
>
=
0
"
Width
can
'
t
be
negative
!
"
)
;
MOZ_ASSERT
(
aHeight
>
=
0
"
Height
can
'
t
be
negative
!
"
)
;
mImageMetadata
.
SetSize
(
aWidth
aHeight
aOrientation
)
;
mProgress
|
=
FLAG_SIZE_AVAILABLE
;
}
void
Decoder
:
:
PostHasTransparency
(
)
{
mProgress
|
=
FLAG_HAS_TRANSPARENCY
;
}
void
Decoder
:
:
PostIsAnimated
(
int32_t
aFirstFrameTimeout
)
{
mProgress
|
=
FLAG_IS_ANIMATED
;
mImageMetadata
.
SetHasAnimation
(
)
;
mImageMetadata
.
SetFirstFrameTimeout
(
aFirstFrameTimeout
)
;
}
void
Decoder
:
:
PostFrameStop
(
Opacity
aFrameOpacity
DisposalMethod
aDisposalMethod
int32_t
aTimeout
BlendMethod
aBlendMethod
const
Maybe
<
nsIntRect
>
&
aBlendRect
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Stopping
frame
during
metadata
decode
"
)
;
MOZ_ASSERT
(
mInFrame
"
Stopping
frame
when
we
didn
'
t
start
one
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Stopping
frame
when
we
don
'
t
have
one
"
)
;
mInFrame
=
false
;
mCurrentFrame
-
>
Finish
(
aFrameOpacity
aDisposalMethod
aTimeout
aBlendMethod
aBlendRect
)
;
mProgress
|
=
FLAG_FRAME_COMPLETE
;
if
(
!
ShouldSendPartialInvalidations
(
)
&
&
mFrameCount
=
=
1
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
GetSize
(
)
)
)
;
}
if
(
mImage
&
&
mFrameCount
=
=
1
&
&
HasAnimation
(
)
)
{
MOZ_ASSERT
(
HasProgress
(
)
)
;
IDecodingTask
:
:
NotifyProgress
(
WrapNotNull
(
this
)
)
;
}
}
void
Decoder
:
:
PostInvalidation
(
const
nsIntRect
&
aRect
const
Maybe
<
nsIntRect
>
&
aRectAtTargetSize
)
{
MOZ_ASSERT
(
mInFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
if
(
ShouldSendPartialInvalidations
(
)
&
&
mFrameCount
=
=
1
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
aRect
)
;
mCurrentFrame
-
>
ImageUpdated
(
aRectAtTargetSize
.
valueOr
(
aRect
)
)
;
}
}
void
Decoder
:
:
PostDecodeDone
(
int32_t
aLoopCount
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Done
with
decoding
in
metadata
decode
"
)
;
MOZ_ASSERT
(
!
mInFrame
"
Can
'
t
be
done
decoding
if
we
'
re
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
!
mDecodeDone
"
Decode
already
done
!
"
)
;
mDecodeDone
=
true
;
mImageMetadata
.
SetLoopCount
(
aLoopCount
)
;
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
void
Decoder
:
:
PostDataError
(
)
{
mDataError
=
true
;
if
(
mInFrame
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
Abort
(
)
;
}
}
Telemetry
:
:
ID
Decoder
:
:
SpeedHistogram
(
)
{
return
Telemetry
:
:
HistogramCount
;
}
}
}
