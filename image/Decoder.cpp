#
include
"
Decoder
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
ISurfaceProvider
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
using
mozilla
:
:
gfx
:
:
IntPoint
;
using
mozilla
:
:
gfx
:
:
IntRect
;
using
mozilla
:
:
gfx
:
:
IntSize
;
using
mozilla
:
:
gfx
:
:
SurfaceFormat
;
namespace
mozilla
{
namespace
image
{
class
MOZ_STACK_CLASS
AutoRecordDecoderTelemetry
final
{
public
:
explicit
AutoRecordDecoderTelemetry
(
Decoder
*
aDecoder
)
:
mDecoder
(
aDecoder
)
{
MOZ_ASSERT
(
mDecoder
)
;
mStartTime
=
TimeStamp
:
:
Now
(
)
;
}
~
AutoRecordDecoderTelemetry
(
)
{
mDecoder
-
>
mDecodeTime
+
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
;
}
private
:
Decoder
*
mDecoder
;
TimeStamp
mStartTime
;
}
;
Decoder
:
:
Decoder
(
RasterImage
*
aImage
)
:
mImageData
(
nullptr
)
mImageDataLength
(
0
)
mColormap
(
nullptr
)
mColormapSize
(
0
)
mImage
(
aImage
)
mFrameRecycler
(
nullptr
)
mProgress
(
NoProgress
)
mFrameCount
(
0
)
mLoopLength
(
FrameTimeout
:
:
Zero
(
)
)
mDecoderFlags
(
DefaultDecoderFlags
(
)
)
mSurfaceFlags
(
DefaultSurfaceFlags
(
)
)
mInitialized
(
false
)
mMetadataDecode
(
false
)
mHaveExplicitOutputSize
(
false
)
mInFrame
(
false
)
mFinishedNewFrame
(
false
)
mHasFrameToTake
(
false
)
mReachedTerminalState
(
false
)
mDecodeDone
(
false
)
mError
(
false
)
mShouldReportError
(
false
)
mFinalizeFrames
(
true
)
{
}
Decoder
:
:
~
Decoder
(
)
{
MOZ_ASSERT
(
mProgress
=
=
NoProgress
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
progress
changes
"
)
;
MOZ_ASSERT
(
mInvalidRect
.
IsEmpty
(
)
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
invalidations
"
)
;
mInitialized
=
false
;
if
(
mImage
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThreadSystemGroup
(
mImage
.
forget
(
)
)
;
}
}
nsresult
Decoder
:
:
Init
(
)
{
MOZ_ASSERT
(
!
mInitialized
"
Can
'
t
re
-
initialize
a
decoder
!
"
)
;
MOZ_ASSERT
(
mIterator
)
;
MOZ_ASSERT_IF
(
mMetadataDecode
!
mHaveExplicitOutputSize
)
;
MOZ_ASSERT_IF
(
mImage
IsMetadataDecode
(
)
)
;
nsresult
rv
=
InitInternal
(
)
;
mInitialized
=
true
;
return
rv
;
}
LexerResult
Decoder
:
:
Decode
(
IResumable
*
aOnResume
)
{
MOZ_ASSERT
(
mInitialized
"
Should
be
initialized
here
"
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
if
(
GetDecodeDone
(
)
)
{
return
LexerResult
(
HasError
(
)
?
TerminalState
:
:
FAILURE
:
TerminalState
:
:
SUCCESS
)
;
}
LexerResult
lexerResult
(
TerminalState
:
:
FAILURE
)
;
{
AUTO_PROFILER_LABEL_CATEGORY_PAIR
(
GRAPHICS_ImageDecoding
)
;
AutoRecordDecoderTelemetry
telemetry
(
this
)
;
lexerResult
=
DoDecode
(
*
mIterator
aOnResume
)
;
}
;
if
(
lexerResult
.
is
<
Yield
>
(
)
)
{
return
lexerResult
;
}
MOZ_ASSERT
(
lexerResult
.
is
<
TerminalState
>
(
)
)
;
mReachedTerminalState
=
true
;
if
(
lexerResult
.
as
<
TerminalState
>
(
)
=
=
TerminalState
:
:
FAILURE
)
{
PostError
(
)
;
}
CompleteDecode
(
)
;
return
LexerResult
(
HasError
(
)
?
TerminalState
:
:
FAILURE
:
TerminalState
:
:
SUCCESS
)
;
}
LexerResult
Decoder
:
:
TerminateFailure
(
)
{
PostError
(
)
;
if
(
!
mReachedTerminalState
)
{
mReachedTerminalState
=
true
;
CompleteDecode
(
)
;
}
return
LexerResult
(
TerminalState
:
:
FAILURE
)
;
}
bool
Decoder
:
:
ShouldSyncDecode
(
size_t
aByteLimit
)
{
MOZ_ASSERT
(
aByteLimit
>
0
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
return
mIterator
-
>
RemainingBytesIsNoMoreThan
(
aByteLimit
)
;
}
void
Decoder
:
:
CompleteDecode
(
)
{
nsresult
rv
=
BeforeFinishInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PostError
(
)
;
}
rv
=
HasError
(
)
?
FinishWithErrorInternal
(
)
:
FinishInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
PostError
(
)
;
}
if
(
IsMetadataDecode
(
)
)
{
if
(
!
HasSize
(
)
)
{
PostError
(
)
;
}
return
;
}
if
(
mInFrame
)
{
PostHasTransparency
(
)
;
PostFrameStop
(
)
;
}
if
(
!
mDecodeDone
)
{
mShouldReportError
=
true
;
if
(
GetCompleteFrameCount
(
)
>
0
)
{
PostHasTransparency
(
)
;
PostDecodeDone
(
)
;
}
else
{
mProgress
|
=
FLAG_DECODE_COMPLETE
|
FLAG_HAS_ERROR
;
}
}
if
(
mDecodeDone
)
{
MOZ_ASSERT
(
HasError
(
)
|
|
mCurrentFrame
"
Should
have
an
error
or
a
frame
"
)
;
if
(
!
HasAnimation
(
)
&
&
!
(
mDecoderFlags
&
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
)
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
SetOptimizable
(
)
;
}
}
}
void
Decoder
:
:
SetOutputSize
(
const
gfx
:
:
IntSize
&
aSize
)
{
mOutputSize
=
Some
(
aSize
)
;
mHaveExplicitOutputSize
=
true
;
}
Maybe
<
gfx
:
:
IntSize
>
Decoder
:
:
ExplicitOutputSize
(
)
const
{
MOZ_ASSERT_IF
(
mHaveExplicitOutputSize
mOutputSize
)
;
return
mHaveExplicitOutputSize
?
mOutputSize
:
Nothing
(
)
;
}
Maybe
<
uint32_t
>
Decoder
:
:
TakeCompleteFrameCount
(
)
{
const
bool
finishedNewFrame
=
mFinishedNewFrame
;
mFinishedNewFrame
=
false
;
return
finishedNewFrame
?
Some
(
GetCompleteFrameCount
(
)
)
:
Nothing
(
)
;
}
DecoderFinalStatus
Decoder
:
:
FinalStatus
(
)
const
{
return
DecoderFinalStatus
(
IsMetadataDecode
(
)
GetDecodeDone
(
)
HasError
(
)
ShouldReportError
(
)
)
;
}
DecoderTelemetry
Decoder
:
:
Telemetry
(
)
const
{
MOZ_ASSERT
(
mIterator
)
;
return
DecoderTelemetry
(
SpeedHistogram
(
)
mIterator
?
mIterator
-
>
ByteCount
(
)
:
0
mIterator
?
mIterator
-
>
ChunkCount
(
)
:
0
mDecodeTime
)
;
}
nsresult
Decoder
:
:
AllocateFrame
(
const
gfx
:
:
IntSize
&
aOutputSize
const
gfx
:
:
IntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
const
Maybe
<
AnimationParams
>
&
aAnimParams
)
{
mCurrentFrame
=
AllocateFrameInternal
(
aOutputSize
aFrameRect
aFormat
aPaletteDepth
aAnimParams
std
:
:
move
(
mCurrentFrame
)
)
;
if
(
mCurrentFrame
)
{
mHasFrameToTake
=
true
;
mCurrentFrame
-
>
GetImageData
(
&
mImageData
&
mImageDataLength
)
;
mCurrentFrame
-
>
GetPaletteData
(
&
mColormap
&
mColormapSize
)
;
MOZ_ASSERT_IF
(
aAnimParams
aAnimParams
-
>
mFrameNum
+
1
=
=
mFrameCount
)
;
MOZ_ASSERT_IF
(
mFrameCount
>
1
HasAnimation
(
)
)
;
MOZ_ASSERT
(
!
mInFrame
"
Starting
new
frame
but
not
done
with
old
one
!
"
)
;
mInFrame
=
true
;
}
return
mCurrentFrame
?
NS_OK
:
NS_ERROR_FAILURE
;
}
RawAccessFrameRef
Decoder
:
:
AllocateFrameInternal
(
const
gfx
:
:
IntSize
&
aOutputSize
const
gfx
:
:
IntRect
&
aFrameRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
const
Maybe
<
AnimationParams
>
&
aAnimParams
RawAccessFrameRef
&
&
aPreviousFrame
)
{
if
(
HasError
(
)
)
{
return
RawAccessFrameRef
(
)
;
}
uint32_t
frameNum
=
aAnimParams
?
aAnimParams
-
>
mFrameNum
:
0
;
if
(
frameNum
!
=
mFrameCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Allocating
frames
out
of
order
"
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
aOutputSize
.
width
<
=
0
|
|
aOutputSize
.
height
<
=
0
|
|
aFrameRect
.
Width
(
)
<
=
0
|
|
aFrameRect
.
Height
(
)
<
=
0
)
{
NS_WARNING
(
"
Trying
to
add
frame
with
zero
or
negative
size
"
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
frameNum
=
=
1
)
{
MOZ_ASSERT
(
aPreviousFrame
"
Must
provide
a
previous
frame
when
animated
"
)
;
aPreviousFrame
-
>
SetRawAccessOnly
(
)
;
}
if
(
frameNum
>
0
)
{
if
(
ShouldBlendAnimation
(
)
)
{
if
(
aPreviousFrame
-
>
GetDisposalMethod
(
)
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
mRestoreFrame
=
std
:
:
move
(
aPreviousFrame
)
;
mRestoreDirtyRect
.
SetBox
(
0
0
0
0
)
;
}
else
{
mRestoreDirtyRect
=
aPreviousFrame
-
>
GetBoundedBlendRect
(
)
;
}
}
}
RawAccessFrameRef
ref
;
if
(
mFrameRecycler
)
{
MOZ_ASSERT
(
ShouldBlendAnimation
(
)
)
;
MOZ_ASSERT
(
aPaletteDepth
=
=
0
)
;
MOZ_ASSERT
(
aAnimParams
)
;
MOZ_ASSERT
(
aFrameRect
.
IsEqualEdges
(
IntRect
(
IntPoint
(
0
0
)
aOutputSize
)
)
)
;
ref
=
mFrameRecycler
-
>
RecycleFrame
(
mRecycleRect
)
;
if
(
ref
)
{
bool
blocked
=
ref
.
get
(
)
=
=
mRestoreFrame
.
get
(
)
;
if
(
!
blocked
)
{
blocked
=
NS_FAILED
(
ref
-
>
InitForDecoderRecycle
(
aAnimParams
.
ref
(
)
)
)
;
}
if
(
blocked
)
{
ref
.
reset
(
)
;
}
}
}
if
(
!
ref
)
{
mRecycleRect
=
IntRect
(
IntPoint
(
0
0
)
aOutputSize
)
;
bool
nonPremult
=
bool
(
mSurfaceFlags
&
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
)
;
auto
frame
=
MakeNotNull
<
RefPtr
<
imgFrame
>
>
(
)
;
if
(
NS_FAILED
(
frame
-
>
InitForDecoder
(
aOutputSize
aFrameRect
aFormat
aPaletteDepth
nonPremult
aAnimParams
ShouldBlendAnimation
(
)
bool
(
mFrameRecycler
)
)
)
)
{
NS_WARNING
(
"
imgFrame
:
:
Init
should
succeed
"
)
;
return
RawAccessFrameRef
(
)
;
}
ref
=
frame
-
>
RawAccessRef
(
)
;
if
(
!
ref
)
{
frame
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
frameNum
>
0
)
{
frame
-
>
SetRawAccessOnly
(
)
;
}
}
mFrameCount
+
+
;
return
ref
;
}
nsresult
Decoder
:
:
InitInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
BeforeFinishInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
FinishInternal
(
)
{
return
NS_OK
;
}
nsresult
Decoder
:
:
FinishWithErrorInternal
(
)
{
MOZ_ASSERT
(
!
mInFrame
)
;
return
NS_OK
;
}
void
Decoder
:
:
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
)
{
MOZ_ASSERT
(
aWidth
>
=
0
"
Width
can
'
t
be
negative
!
"
)
;
MOZ_ASSERT
(
aHeight
>
=
0
"
Height
can
'
t
be
negative
!
"
)
;
mImageMetadata
.
SetSize
(
aWidth
aHeight
aOrientation
)
;
if
(
!
IsExpectedSize
(
)
)
{
PostError
(
)
;
return
;
}
if
(
!
mOutputSize
)
{
mOutputSize
=
Some
(
IntSize
(
aWidth
aHeight
)
)
;
}
MOZ_ASSERT
(
mOutputSize
-
>
width
<
=
aWidth
&
&
mOutputSize
-
>
height
<
=
aHeight
"
Output
size
will
result
in
upscaling
"
)
;
if
(
mOutputSize
-
>
width
<
aWidth
|
|
mOutputSize
-
>
height
<
aHeight
)
{
mDownscaler
.
emplace
(
*
mOutputSize
)
;
}
mProgress
|
=
FLAG_SIZE_AVAILABLE
;
}
void
Decoder
:
:
PostHasTransparency
(
)
{
mProgress
|
=
FLAG_HAS_TRANSPARENCY
;
}
void
Decoder
:
:
PostIsAnimated
(
FrameTimeout
aFirstFrameTimeout
)
{
mProgress
|
=
FLAG_IS_ANIMATED
;
mImageMetadata
.
SetHasAnimation
(
)
;
mImageMetadata
.
SetFirstFrameTimeout
(
aFirstFrameTimeout
)
;
}
void
Decoder
:
:
PostFrameStop
(
Opacity
aFrameOpacity
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Stopping
frame
during
metadata
decode
"
)
;
MOZ_ASSERT
(
mInFrame
"
Stopping
frame
when
we
didn
'
t
start
one
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Stopping
frame
when
we
don
'
t
have
one
"
)
;
mInFrame
=
false
;
mFinishedNewFrame
=
true
;
mCurrentFrame
-
>
Finish
(
aFrameOpacity
mFinalizeFrames
)
;
mProgress
|
=
FLAG_FRAME_COMPLETE
;
mLoopLength
+
=
mCurrentFrame
-
>
GetTimeout
(
)
;
if
(
mFrameCount
=
=
1
)
{
if
(
!
ShouldSendPartialInvalidations
(
)
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
IntRect
(
IntPoint
(
)
Size
(
)
)
)
;
}
switch
(
mCurrentFrame
-
>
GetDisposalMethod
(
)
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
CLEAR
:
case
DisposalMethod
:
:
CLEAR_ALL
:
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
mFirstFrameRefreshArea
=
IntRect
(
IntPoint
(
)
Size
(
)
)
;
break
;
case
DisposalMethod
:
:
KEEP
:
case
DisposalMethod
:
:
NOT_SPECIFIED
:
break
;
}
}
else
{
mFirstFrameRefreshArea
.
UnionRect
(
mFirstFrameRefreshArea
mCurrentFrame
-
>
GetBoundedBlendRect
(
)
)
;
}
}
void
Decoder
:
:
PostInvalidation
(
const
gfx
:
:
IntRect
&
aRect
const
Maybe
<
gfx
:
:
IntRect
>
&
aRectAtOutputSize
)
{
MOZ_ASSERT
(
mInFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
if
(
ShouldSendPartialInvalidations
(
)
&
&
mFrameCount
=
=
1
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
aRect
)
;
mCurrentFrame
-
>
ImageUpdated
(
aRectAtOutputSize
.
valueOr
(
aRect
)
)
;
}
}
void
Decoder
:
:
PostDecodeDone
(
int32_t
aLoopCount
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Done
with
decoding
in
metadata
decode
"
)
;
MOZ_ASSERT
(
!
mInFrame
"
Can
'
t
be
done
decoding
if
we
'
re
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
!
mDecodeDone
"
Decode
already
done
!
"
)
;
mDecodeDone
=
true
;
mImageMetadata
.
SetLoopCount
(
aLoopCount
)
;
if
(
!
IsFirstFrameDecode
(
)
)
{
mImageMetadata
.
SetLoopLength
(
mLoopLength
)
;
mImageMetadata
.
SetFirstFrameRefreshArea
(
mFirstFrameRefreshArea
)
;
}
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
void
Decoder
:
:
PostError
(
)
{
mError
=
true
;
if
(
mInFrame
)
{
MOZ_ASSERT
(
mCurrentFrame
)
;
MOZ_ASSERT
(
mFrameCount
>
0
)
;
mCurrentFrame
-
>
Abort
(
)
;
mInFrame
=
false
;
-
-
mFrameCount
;
mHasFrameToTake
=
false
;
}
}
}
}
