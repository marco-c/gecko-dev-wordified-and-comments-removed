#
include
"
Decoder
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
using
mozilla
:
:
gfx
:
:
IntSize
;
using
mozilla
:
:
gfx
:
:
SurfaceFormat
;
namespace
mozilla
{
namespace
image
{
Decoder
:
:
Decoder
(
RasterImage
*
aImage
)
:
mImageData
(
nullptr
)
mImageDataLength
(
0
)
mColormap
(
nullptr
)
mColormapSize
(
0
)
mImage
(
aImage
)
mProgress
(
NoProgress
)
mFrameCount
(
0
)
mFailCode
(
NS_OK
)
mChunkCount
(
0
)
mDecoderFlags
(
DefaultDecoderFlags
(
)
)
mSurfaceFlags
(
DefaultSurfaceFlags
(
)
)
mBytesDecoded
(
0
)
mInitialized
(
false
)
mMetadataDecode
(
false
)
mInFrame
(
false
)
mDataDone
(
false
)
mDecodeDone
(
false
)
mDataError
(
false
)
mDecodeAborted
(
false
)
mShouldReportError
(
false
)
{
}
Decoder
:
:
~
Decoder
(
)
{
MOZ_ASSERT
(
mProgress
=
=
NoProgress
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
progress
changes
"
)
;
MOZ_ASSERT
(
mInvalidRect
.
IsEmpty
(
)
|
|
!
mImage
"
Destroying
Decoder
without
taking
all
its
invalidations
"
)
;
mInitialized
=
false
;
if
(
mImage
&
&
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
NS_WARN_IF_FALSE
(
mainThread
"
Couldn
'
t
get
the
main
thread
!
"
)
;
if
(
mainThread
)
{
RasterImage
*
rawImg
=
nullptr
;
mImage
.
swap
(
rawImg
)
;
DebugOnly
<
nsresult
>
rv
=
NS_ProxyRelease
(
mainThread
NS_ISUPPORTS_CAST
(
ImageResource
*
rawImg
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
proxy
release
to
main
thread
"
)
;
}
}
}
void
Decoder
:
:
Init
(
)
{
MOZ_ASSERT
(
!
mInitialized
"
Can
'
t
re
-
initialize
a
decoder
!
"
)
;
MOZ_ASSERT
(
ShouldUseSurfaceCache
(
)
|
|
IsFirstFrameDecode
(
)
)
;
InitInternal
(
)
;
mInitialized
=
true
;
}
nsresult
Decoder
:
:
Decode
(
IResumable
*
aOnResume
)
{
MOZ_ASSERT
(
mInitialized
"
Should
be
initialized
here
"
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
IResumable
*
onResume
=
aOnResume
?
aOnResume
:
this
;
while
(
!
GetDecodeDone
(
)
&
&
!
HasError
(
)
)
{
auto
newState
=
mIterator
-
>
AdvanceOrScheduleResume
(
onResume
)
;
if
(
newState
=
=
SourceBufferIterator
:
:
WAITING
)
{
return
NS_OK
;
}
if
(
newState
=
=
SourceBufferIterator
:
:
COMPLETE
)
{
mDataDone
=
true
;
nsresult
finalStatus
=
mIterator
-
>
CompletionStatus
(
)
;
if
(
NS_FAILED
(
finalStatus
)
)
{
PostDataError
(
)
;
}
CompleteDecode
(
)
;
return
finalStatus
;
}
MOZ_ASSERT
(
newState
=
=
SourceBufferIterator
:
:
READY
)
;
Write
(
mIterator
-
>
Data
(
)
mIterator
-
>
Length
(
)
)
;
}
CompleteDecode
(
)
;
return
HasError
(
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
void
Decoder
:
:
Resume
(
)
{
DecodePool
*
decodePool
=
DecodePool
:
:
Singleton
(
)
;
MOZ_ASSERT
(
decodePool
)
;
decodePool
-
>
AsyncDecode
(
this
)
;
}
bool
Decoder
:
:
ShouldSyncDecode
(
size_t
aByteLimit
)
{
MOZ_ASSERT
(
aByteLimit
>
0
)
;
MOZ_ASSERT
(
mIterator
"
Should
have
a
SourceBufferIterator
"
)
;
return
mIterator
-
>
RemainingBytesIsNoMoreThan
(
aByteLimit
)
;
}
void
Decoder
:
:
Write
(
const
char
*
aBuffer
uint32_t
aCount
)
{
PROFILER_LABEL
(
"
ImageDecoder
"
"
Write
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
MOZ_ASSERT
(
aBuffer
)
;
MOZ_ASSERT
(
aCount
>
0
)
;
MOZ_ASSERT
(
!
HasDecoderError
(
)
"
Not
allowed
to
make
more
decoder
calls
after
error
!
"
)
;
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
mChunkCount
+
+
;
mBytesDecoded
+
=
aCount
;
if
(
HasDataError
(
)
)
{
return
;
}
if
(
IsMetadataDecode
(
)
&
&
HasSize
(
)
)
{
return
;
}
WriteInternal
(
aBuffer
aCount
)
;
mDecodeTime
+
=
(
TimeStamp
:
:
Now
(
)
-
start
)
;
}
void
Decoder
:
:
CompleteDecode
(
)
{
BeforeFinishInternal
(
)
;
if
(
!
HasError
(
)
)
{
FinishInternal
(
)
;
}
else
{
FinishWithErrorInternal
(
)
;
}
if
(
mInFrame
&
&
!
HasError
(
)
)
{
PostFrameStop
(
)
;
}
if
(
!
IsMetadataDecode
(
)
&
&
!
mDecodeDone
&
&
!
WasAborted
(
)
)
{
mShouldReportError
=
true
;
if
(
!
HasDecoderError
(
)
&
&
GetCompleteFrameCount
(
)
>
0
)
{
PostHasTransparency
(
)
;
if
(
mInFrame
)
{
PostFrameStop
(
)
;
}
PostDecodeDone
(
)
;
}
else
{
if
(
!
IsMetadataDecode
(
)
)
{
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
mProgress
|
=
FLAG_HAS_ERROR
;
}
}
if
(
mDecodeDone
&
&
!
IsMetadataDecode
(
)
)
{
MOZ_ASSERT
(
HasError
(
)
|
|
mCurrentFrame
"
Should
have
an
error
or
a
frame
"
)
;
if
(
!
HasAnimation
(
)
&
&
!
(
mDecoderFlags
&
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
)
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
SetOptimizable
(
)
;
}
}
}
nsresult
Decoder
:
:
SetTargetSize
(
const
nsIntSize
&
aSize
)
{
if
(
MOZ_UNLIKELY
(
aSize
.
width
<
=
0
|
|
aSize
.
height
<
=
0
)
)
{
return
NS_ERROR_FAILURE
;
}
mDownscaler
.
emplace
(
aSize
)
;
return
NS_OK
;
}
nsresult
Decoder
:
:
AllocateFrame
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
)
{
mCurrentFrame
=
AllocateFrameInternal
(
aFrameNum
aTargetSize
aFrameRect
aFormat
aPaletteDepth
mCurrentFrame
.
get
(
)
)
;
if
(
mCurrentFrame
)
{
mCurrentFrame
-
>
GetImageData
(
&
mImageData
&
mImageDataLength
)
;
mCurrentFrame
-
>
GetPaletteData
(
&
mColormap
&
mColormapSize
)
;
if
(
aFrameNum
+
1
=
=
mFrameCount
)
{
MOZ_ASSERT_IF
(
mFrameCount
>
1
HasAnimation
(
)
)
;
MOZ_ASSERT
(
!
mInFrame
"
Starting
new
frame
but
not
done
with
old
one
!
"
)
;
mInFrame
=
true
;
}
}
else
{
PostDataError
(
)
;
}
return
mCurrentFrame
?
NS_OK
:
NS_ERROR_FAILURE
;
}
RawAccessFrameRef
Decoder
:
:
AllocateFrameInternal
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
imgFrame
*
aPreviousFrame
)
{
if
(
mDataError
|
|
NS_FAILED
(
mFailCode
)
)
{
return
RawAccessFrameRef
(
)
;
}
if
(
aFrameNum
!
=
mFrameCount
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Allocating
frames
out
of
order
"
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
aTargetSize
.
width
<
=
0
|
|
aTargetSize
.
height
<
=
0
|
|
aFrameRect
.
width
<
=
0
|
|
aFrameRect
.
height
<
=
0
)
{
NS_WARNING
(
"
Trying
to
add
frame
with
zero
or
negative
size
"
)
;
return
RawAccessFrameRef
(
)
;
}
const
uint32_t
bytesPerPixel
=
aPaletteDepth
=
=
0
?
4
:
1
;
if
(
ShouldUseSurfaceCache
(
)
&
&
!
SurfaceCache
:
:
CanHold
(
aFrameRect
.
Size
(
)
bytesPerPixel
)
)
{
NS_WARNING
(
"
Trying
to
add
frame
that
'
s
too
large
for
the
SurfaceCache
"
)
;
return
RawAccessFrameRef
(
)
;
}
RefPtr
<
imgFrame
>
frame
=
new
imgFrame
(
)
;
bool
nonPremult
=
bool
(
mSurfaceFlags
&
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
)
;
if
(
NS_FAILED
(
frame
-
>
InitForDecoder
(
aTargetSize
aFrameRect
aFormat
aPaletteDepth
nonPremult
)
)
)
{
NS_WARNING
(
"
imgFrame
:
:
Init
should
succeed
"
)
;
return
RawAccessFrameRef
(
)
;
}
RawAccessFrameRef
ref
=
frame
-
>
RawAccessRef
(
)
;
if
(
!
ref
)
{
frame
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
if
(
ShouldUseSurfaceCache
(
)
)
{
InsertOutcome
outcome
=
SurfaceCache
:
:
Insert
(
frame
ImageKey
(
mImage
.
get
(
)
)
RasterSurfaceKey
(
aTargetSize
mSurfaceFlags
aFrameNum
)
)
;
if
(
outcome
=
=
InsertOutcome
:
:
FAILURE
)
{
ref
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
else
if
(
outcome
=
=
InsertOutcome
:
:
FAILURE_ALREADY_PRESENT
)
{
mDecodeAborted
=
true
;
ref
-
>
Abort
(
)
;
return
RawAccessFrameRef
(
)
;
}
}
nsIntRect
refreshArea
;
if
(
aFrameNum
=
=
1
)
{
MOZ_ASSERT
(
aPreviousFrame
"
Must
provide
a
previous
frame
when
animated
"
)
;
aPreviousFrame
-
>
SetRawAccessOnly
(
)
;
AnimationData
previousFrameData
=
aPreviousFrame
-
>
GetAnimationData
(
)
;
if
(
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR
|
|
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR_ALL
|
|
previousFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
refreshArea
=
previousFrameData
.
mRect
;
}
}
if
(
aFrameNum
>
0
)
{
ref
-
>
SetRawAccessOnly
(
)
;
refreshArea
.
UnionRect
(
refreshArea
frame
-
>
GetRect
(
)
)
;
}
mFrameCount
+
+
;
if
(
mImage
)
{
mImage
-
>
OnAddedFrame
(
mFrameCount
refreshArea
)
;
}
return
ref
;
}
void
Decoder
:
:
InitInternal
(
)
{
}
void
Decoder
:
:
BeforeFinishInternal
(
)
{
}
void
Decoder
:
:
FinishInternal
(
)
{
}
void
Decoder
:
:
FinishWithErrorInternal
(
)
{
}
void
Decoder
:
:
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
)
{
MOZ_ASSERT
(
aWidth
>
=
0
"
Width
can
'
t
be
negative
!
"
)
;
MOZ_ASSERT
(
aHeight
>
=
0
"
Height
can
'
t
be
negative
!
"
)
;
mImageMetadata
.
SetSize
(
aWidth
aHeight
aOrientation
)
;
mProgress
|
=
FLAG_SIZE_AVAILABLE
;
}
void
Decoder
:
:
PostHasTransparency
(
)
{
mProgress
|
=
FLAG_HAS_TRANSPARENCY
;
}
void
Decoder
:
:
PostIsAnimated
(
int32_t
aFirstFrameTimeout
)
{
mProgress
|
=
FLAG_IS_ANIMATED
;
mImageMetadata
.
SetHasAnimation
(
)
;
mImageMetadata
.
SetFirstFrameTimeout
(
aFirstFrameTimeout
)
;
}
void
Decoder
:
:
PostFrameStop
(
Opacity
aFrameOpacity
DisposalMethod
aDisposalMethod
int32_t
aTimeout
BlendMethod
aBlendMethod
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Stopping
frame
during
metadata
decode
"
)
;
MOZ_ASSERT
(
mInFrame
"
Stopping
frame
when
we
didn
'
t
start
one
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Stopping
frame
when
we
don
'
t
have
one
"
)
;
mInFrame
=
false
;
mCurrentFrame
-
>
Finish
(
aFrameOpacity
aDisposalMethod
aTimeout
aBlendMethod
)
;
mProgress
|
=
FLAG_FRAME_COMPLETE
;
if
(
!
ShouldSendPartialInvalidations
(
)
&
&
!
HasAnimation
(
)
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
GetSize
(
)
)
)
;
}
}
void
Decoder
:
:
PostInvalidation
(
const
nsIntRect
&
aRect
const
Maybe
<
nsIntRect
>
&
aRectAtTargetSize
)
{
MOZ_ASSERT
(
mInFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
mCurrentFrame
"
Can
'
t
invalidate
when
not
mid
-
frame
!
"
)
;
if
(
ShouldSendPartialInvalidations
(
)
&
&
!
HasAnimation
(
)
)
{
mInvalidRect
.
UnionRect
(
mInvalidRect
aRect
)
;
mCurrentFrame
-
>
ImageUpdated
(
aRectAtTargetSize
.
valueOr
(
aRect
)
)
;
}
}
void
Decoder
:
:
PostDecodeDone
(
int32_t
aLoopCount
)
{
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Done
with
decoding
in
metadata
decode
"
)
;
MOZ_ASSERT
(
!
mInFrame
"
Can
'
t
be
done
decoding
if
we
'
re
mid
-
frame
!
"
)
;
MOZ_ASSERT
(
!
mDecodeDone
"
Decode
already
done
!
"
)
;
mDecodeDone
=
true
;
mImageMetadata
.
SetLoopCount
(
aLoopCount
)
;
mProgress
|
=
FLAG_DECODE_COMPLETE
;
}
void
Decoder
:
:
PostDataError
(
)
{
mDataError
=
true
;
if
(
mInFrame
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
Abort
(
)
;
}
}
void
Decoder
:
:
PostDecoderError
(
nsresult
aFailureCode
)
{
MOZ_ASSERT
(
NS_FAILED
(
aFailureCode
)
"
Not
a
failure
code
!
"
)
;
mFailCode
=
aFailureCode
;
NS_WARNING
(
"
Image
decoding
error
-
This
is
probably
a
bug
!
"
)
;
if
(
mInFrame
&
&
mCurrentFrame
)
{
mCurrentFrame
-
>
Abort
(
)
;
}
}
Telemetry
:
:
ID
Decoder
:
:
SpeedHistogram
(
)
{
return
Telemetry
:
:
HistogramCount
;
}
}
}
