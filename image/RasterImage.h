#
ifndef
mozilla_image_RasterImage_h
#
define
mozilla_image_RasterImage_h
#
include
"
Image
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
FrameAnimator
.
h
"
#
include
"
ImageMetadata
.
h
"
#
include
"
ISurfaceProvider
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
PlaybackType
.
h
"
#
ifdef
DEBUG
#
include
"
imgIContainerDebug
.
h
"
#
endif
class
nsIInputStream
;
class
nsIRequest
;
#
define
NS_RASTERIMAGE_CID
\
{
/
*
376ff2c1
-
9bf6
-
418a
-
b143
-
3340c00112f7
*
/
\
0x376ff2c1
0x9bf6
0x418a
{
\
0xb1
0x43
0x33
0x40
0xc0
0x01
0x12
0xf7
\
}
\
}
namespace
mozilla
{
struct
OrientedPixel
{
}
;
template
<
>
struct
IsPixel
<
OrientedPixel
>
:
std
:
:
true_type
{
}
;
typedef
gfx
:
:
IntSizeTyped
<
OrientedPixel
>
OrientedIntSize
;
typedef
gfx
:
:
IntRectTyped
<
OrientedPixel
>
OrientedIntRect
;
struct
UnorientedPixel
{
}
;
template
<
>
struct
IsPixel
<
UnorientedPixel
>
:
std
:
:
true_type
{
}
;
typedef
gfx
:
:
IntSizeTyped
<
UnorientedPixel
>
UnorientedIntSize
;
typedef
gfx
:
:
IntRectTyped
<
UnorientedPixel
>
UnorientedIntRect
;
namespace
layers
{
class
ImageContainer
;
class
Image
;
class
LayersManager
;
}
namespace
image
{
class
Decoder
;
struct
DecoderFinalStatus
;
struct
DecoderTelemetry
;
class
ImageMetadata
;
class
SourceBuffer
;
class
RasterImage
final
:
public
ImageResource
public
SupportsWeakPtr
<
RasterImage
>
#
ifdef
DEBUG
public
imgIContainerDebug
#
endif
{
virtual
~
RasterImage
(
)
;
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
RasterImage
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_IMGICONTAINER
#
ifdef
DEBUG
NS_DECL_IMGICONTAINERDEBUG
#
endif
nsresult
GetNativeSizes
(
nsTArray
<
gfx
:
:
IntSize
>
&
aNativeSizes
)
const
override
;
size_t
GetNativeSizesLength
(
)
const
override
;
virtual
nsresult
StartAnimation
(
)
override
;
virtual
nsresult
StopAnimation
(
)
override
;
virtual
void
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
override
;
virtual
size_t
SizeOfSourceWithComputedFallback
(
SizeOfState
&
aState
)
const
override
;
virtual
void
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
override
;
void
Discard
(
)
;
void
NotifyProgress
(
Progress
aProgress
const
UnorientedIntRect
&
aInvalidRect
=
UnorientedIntRect
(
)
const
Maybe
<
uint32_t
>
&
aFrameCount
=
Nothing
(
)
DecoderFlags
aDecoderFlags
=
DefaultDecoderFlags
(
)
SurfaceFlags
aSurfaceFlags
=
DefaultSurfaceFlags
(
)
)
;
void
NotifyDecodeComplete
(
const
DecoderFinalStatus
&
aStatus
const
ImageMetadata
&
aMetadata
const
DecoderTelemetry
&
aTelemetry
Progress
aProgress
const
UnorientedIntRect
&
aInvalidRect
const
Maybe
<
uint32_t
>
&
aFrameCount
DecoderFlags
aDecoderFlags
SurfaceFlags
aSurfaceFlags
)
;
void
ReportDecoderError
(
)
;
virtual
nsresult
OnImageDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
override
;
virtual
nsresult
OnImageDataComplete
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
bool
aLastPart
)
override
;
void
NotifyForLoadEvent
(
Progress
aProgress
)
;
nsresult
SetSourceSizeHint
(
uint32_t
aSizeHint
)
;
nsCString
GetURIString
(
)
{
nsCString
spec
;
if
(
GetURI
(
)
)
{
GetURI
(
)
-
>
GetSpec
(
spec
)
;
}
return
spec
;
}
private
:
nsresult
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
;
LookupResult
LookupFrame
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
aMarkUsed
)
;
LookupResult
LookupFrameInternal
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
aMarkUsed
)
;
ImgDrawResult
DrawInternal
(
DrawableSurface
&
&
aFrameRef
gfxContext
*
aContext
const
UnorientedIntSize
&
aSize
const
ImageRegion
&
aRegion
gfx
:
:
SamplingFilter
aSamplingFilter
uint32_t
aFlags
float
aOpacity
)
;
Tuple
<
ImgDrawResult
gfx
:
:
IntSize
RefPtr
<
gfx
:
:
SourceSurface
>
>
GetFrameInternal
(
const
gfx
:
:
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aWhichFrame
uint32_t
aFlags
)
override
;
Tuple
<
ImgDrawResult
gfx
:
:
IntSize
>
GetImageContainerSize
(
layers
:
:
LayerManager
*
aManager
const
gfx
:
:
IntSize
&
aSize
uint32_t
aFlags
)
override
;
bool
Decode
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
)
;
NS_IMETHOD
DecodeMetadata
(
uint32_t
aFlags
)
;
bool
SetMetadata
(
const
ImageMetadata
&
aMetadata
bool
aFromMetadataDecode
)
;
void
RecoverFromInvalidFrames
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
)
;
void
OnSurfaceDiscardedInternal
(
bool
aAnimatedFramesDiscarded
)
;
gfxMatrix
OrientationMatrix
(
const
UnorientedIntSize
&
aSize
bool
aInvert
=
false
)
const
;
Orientation
UsedOrientation
(
)
const
{
return
mHandledOrientation
?
mOrientation
:
Orientation
(
)
;
}
UnorientedIntSize
ToUnoriented
(
OrientedIntSize
aSize
)
const
{
return
UsedOrientation
(
)
.
SwapsWidthAndHeight
(
)
?
UnorientedIntSize
(
aSize
.
height
aSize
.
width
)
:
UnorientedIntSize
(
aSize
.
width
aSize
.
height
)
;
}
OrientedIntSize
ToOriented
(
UnorientedIntSize
aSize
)
const
{
return
UsedOrientation
(
)
.
SwapsWidthAndHeight
(
)
?
OrientedIntSize
(
aSize
.
height
aSize
.
width
)
:
OrientedIntSize
(
aSize
.
width
aSize
.
height
)
;
}
OrientedIntRect
ToOriented
(
UnorientedIntRect
aRect
)
const
;
UnorientedIntRect
ToUnoriented
(
OrientedIntRect
aRect
)
const
;
private
:
OrientedIntSize
mSize
;
nsTArray
<
OrientedIntSize
>
mNativeSizes
;
Orientation
mOrientation
;
Maybe
<
Progress
>
mLoadProgress
;
gfx
:
:
IntPoint
mHotspot
;
UniquePtr
<
FrameAnimator
>
mFrameAnimator
;
Maybe
<
AnimationState
>
mAnimationState
;
uint32_t
mLockCount
;
DecoderType
mDecoderType
;
int32_t
mDecodeCount
;
#
ifdef
DEBUG
uint32_t
mFramesNotified
;
#
endif
NotNull
<
RefPtr
<
SourceBuffer
>
>
mSourceBuffer
;
bool
mHasSize
:
1
;
bool
mTransient
:
1
;
bool
mSyncLoad
:
1
;
bool
mDiscardable
:
1
;
bool
mSomeSourceData
:
1
;
bool
mAllSourceData
:
1
;
bool
mHasBeenDecoded
:
1
;
bool
mPendingAnimation
:
1
;
bool
mAnimationFinished
:
1
;
bool
mWantFullDecode
:
1
;
bool
mHandledOrientation
:
1
;
TimeStamp
mDrawStartTime
;
bool
CanDownscaleDuringDecode
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
)
;
void
DoError
(
)
;
class
HandleErrorWorker
:
public
Runnable
{
public
:
static
void
DispatchIfNeeded
(
RasterImage
*
aImage
)
;
NS_IMETHOD
Run
(
)
override
;
private
:
explicit
HandleErrorWorker
(
RasterImage
*
aImage
)
;
RefPtr
<
RasterImage
>
mImage
;
}
;
bool
CanDiscard
(
)
;
bool
IsOpaque
(
)
;
DrawableSurface
RequestDecodeForSizeInternal
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
uint32_t
aWhichFrame
)
;
protected
:
explicit
RasterImage
(
nsIURI
*
aURI
=
nullptr
)
;
bool
ShouldAnimate
(
)
override
;
friend
class
ImageFactory
;
}
;
inline
NS_IMETHODIMP
RasterImage
:
:
GetAnimationMode
(
uint16_t
*
aAnimationMode
)
{
return
GetAnimationModeInternal
(
aAnimationMode
)
;
}
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
image
:
:
RasterImage
*
p
)
{
return
NS_ISUPPORTS_CAST
(
mozilla
:
:
image
:
:
ImageResource
*
p
)
;
}
#
endif
