#
ifndef
mozilla_image_RasterImage_h
#
define
mozilla_image_RasterImage_h
#
include
"
Image
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
FrameAnimator
.
h
"
#
include
"
ImageMetadata
.
h
"
#
include
"
ISurfaceProvider
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
Pair
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
PlaybackType
.
h
"
#
ifdef
DEBUG
#
include
"
imgIContainerDebug
.
h
"
#
endif
class
nsIInputStream
;
class
nsIRequest
;
#
define
NS_RASTERIMAGE_CID
\
{
/
*
376ff2c1
-
9bf6
-
418a
-
b143
-
3340c00112f7
*
/
\
0x376ff2c1
\
0x9bf6
\
0x418a
\
{
0xb1
0x43
0x33
0x40
0xc0
0x01
0x12
0xf7
}
\
}
namespace
mozilla
{
namespace
layers
{
class
ImageContainer
;
class
Image
;
}
namespace
image
{
class
Decoder
;
struct
DecoderFinalStatus
;
struct
DecoderTelemetry
;
class
ImageMetadata
;
class
SourceBuffer
;
class
RasterImage
final
:
public
ImageResource
public
nsIProperties
public
SupportsWeakPtr
<
RasterImage
>
#
ifdef
DEBUG
public
imgIContainerDebug
#
endif
{
virtual
~
RasterImage
(
)
;
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
RasterImage
)
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIPROPERTIES
NS_DECL_IMGICONTAINER
#
ifdef
DEBUG
NS_DECL_IMGICONTAINERDEBUG
#
endif
virtual
nsresult
StartAnimation
(
)
override
;
virtual
nsresult
StopAnimation
(
)
override
;
virtual
void
OnSurfaceDiscarded
(
)
override
;
virtual
size_t
SizeOfSourceWithComputedFallback
(
MallocSizeOf
aMallocSizeOf
)
const
override
;
virtual
void
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
override
;
void
Discard
(
)
;
void
NotifyProgress
(
Progress
aProgress
const
gfx
:
:
IntRect
&
aInvalidRect
=
nsIntRect
(
)
const
Maybe
<
uint32_t
>
&
aFrameCount
=
Nothing
(
)
DecoderFlags
aDecoderFlags
=
DefaultDecoderFlags
(
)
SurfaceFlags
aSurfaceFlags
=
DefaultSurfaceFlags
(
)
)
;
void
NotifyDecodeComplete
(
const
DecoderFinalStatus
&
aStatus
const
ImageMetadata
&
aMetadata
const
DecoderTelemetry
&
aTelemetry
Progress
aProgress
const
gfx
:
:
IntRect
&
aInvalidRect
const
Maybe
<
uint32_t
>
&
aFrameCount
DecoderFlags
aDecoderFlags
SurfaceFlags
aSurfaceFlags
)
;
void
ReportDecoderError
(
)
;
virtual
nsresult
OnImageDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
override
;
virtual
nsresult
OnImageDataComplete
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
bool
aLastPart
)
override
;
void
NotifyForLoadEvent
(
Progress
aProgress
)
;
nsresult
SetSourceSizeHint
(
uint32_t
aSizeHint
)
;
nsCString
GetURIString
(
)
{
nsCString
spec
;
if
(
GetURI
(
)
)
{
GetURI
(
)
-
>
GetSpec
(
spec
)
;
}
return
spec
;
}
private
:
nsresult
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
;
DrawableSurface
LookupFrame
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
)
;
LookupResult
LookupFrameInternal
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
)
;
DrawResult
DrawInternal
(
DrawableSurface
&
&
aFrameRef
gfxContext
*
aContext
const
nsIntSize
&
aSize
const
ImageRegion
&
aRegion
gfx
:
:
SamplingFilter
aSamplingFilter
uint32_t
aFlags
)
;
Pair
<
DrawResult
RefPtr
<
gfx
:
:
SourceSurface
>
>
GetFrameInternal
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
;
Pair
<
DrawResult
RefPtr
<
layers
:
:
Image
>
>
GetCurrentImage
(
layers
:
:
ImageContainer
*
aContainer
uint32_t
aFlags
)
;
void
UpdateImageContainer
(
)
;
bool
IsUnlocked
(
)
{
return
(
mLockCount
=
=
0
|
|
(
mAnimationState
&
&
mAnimationConsumers
=
=
0
)
)
;
}
NS_IMETHOD
Decode
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
)
;
NS_IMETHOD
DecodeMetadata
(
uint32_t
aFlags
)
;
bool
SetMetadata
(
const
ImageMetadata
&
aMetadata
bool
aFromMetadataDecode
)
;
void
RecoverFromInvalidFrames
(
const
nsIntSize
&
aSize
uint32_t
aFlags
)
;
private
:
nsIntSize
mSize
;
Orientation
mOrientation
;
Maybe
<
Progress
>
mLoadProgress
;
nsCOMPtr
<
nsIProperties
>
mProperties
;
UniquePtr
<
FrameAnimator
>
mFrameAnimator
;
Maybe
<
AnimationState
>
mAnimationState
;
uint32_t
mLockCount
;
DecoderType
mDecoderType
;
int32_t
mDecodeCount
;
WeakPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
layers
:
:
ImageContainer
:
:
ProducerID
mImageProducerID
;
layers
:
:
ImageContainer
:
:
FrameID
mLastFrameID
;
DrawResult
mLastImageContainerDrawResult
;
#
ifdef
DEBUG
uint32_t
mFramesNotified
;
#
endif
NotNull
<
RefPtr
<
SourceBuffer
>
>
mSourceBuffer
;
bool
mHasSize
:
1
;
bool
mTransient
:
1
;
bool
mSyncLoad
:
1
;
bool
mDiscardable
:
1
;
bool
mHasSourceData
:
1
;
bool
mHasBeenDecoded
:
1
;
bool
mPendingAnimation
:
1
;
bool
mAnimationFinished
:
1
;
bool
mWantFullDecode
:
1
;
TimeStamp
mDrawStartTime
;
bool
CanDownscaleDuringDecode
(
const
nsIntSize
&
aSize
uint32_t
aFlags
)
;
void
DoError
(
)
;
class
HandleErrorWorker
:
public
Runnable
{
public
:
static
void
DispatchIfNeeded
(
RasterImage
*
aImage
)
;
NS_IMETHOD
Run
(
)
;
private
:
explicit
HandleErrorWorker
(
RasterImage
*
aImage
)
;
RefPtr
<
RasterImage
>
mImage
;
}
;
bool
CanDiscard
(
)
;
bool
IsOpaque
(
)
;
protected
:
explicit
RasterImage
(
ImageURL
*
aURI
=
nullptr
)
;
bool
ShouldAnimate
(
)
override
;
friend
class
ImageFactory
;
}
;
inline
NS_IMETHODIMP
RasterImage
:
:
GetAnimationMode
(
uint16_t
*
aAnimationMode
)
{
return
GetAnimationModeInternal
(
aAnimationMode
)
;
}
}
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
image
:
:
RasterImage
*
p
)
{
return
NS_ISUPPORTS_CAST
(
mozilla
:
:
image
:
:
ImageResource
*
p
)
;
}
#
endif
