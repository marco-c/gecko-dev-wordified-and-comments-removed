#
include
"
nsCRT
.
h
"
#
include
"
nsWebPEncoder
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
prprf
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
using
namespace
mozilla
;
NS_IMPL_ISUPPORTS
(
nsWebPEncoder
imgIEncoder
nsIInputStream
nsIAsyncInputStream
)
nsWebPEncoder
:
:
nsWebPEncoder
(
)
:
mFinished
(
false
)
mImageBuffer
(
nullptr
)
mImageBufferSize
(
0
)
mImageBufferUsed
(
0
)
mImageBufferReadPoint
(
0
)
mCallback
(
nullptr
)
mCallbackTarget
(
nullptr
)
mNotifyThreshold
(
0
)
mReentrantMonitor
(
"
nsWebPEncoder
.
mReentrantMonitor
"
)
{
}
nsWebPEncoder
:
:
~
nsWebPEncoder
(
)
{
if
(
mImageBuffer
)
{
WebPFree
(
mImageBuffer
)
;
mImageBuffer
=
nullptr
;
mImageBufferSize
=
0
;
mImageBufferUsed
=
0
;
mImageBufferReadPoint
=
0
;
}
}
NS_IMETHODIMP
nsWebPEncoder
:
:
InitFromData
(
const
uint8_t
*
aData
uint32_t
aLength
uint32_t
aWidth
uint32_t
aHeight
uint32_t
aStride
uint32_t
aInputFormat
const
nsAString
&
aOutputOptions
)
{
NS_ENSURE_ARG
(
aData
)
;
if
(
aInputFormat
!
=
INPUT_FORMAT_RGB
&
&
aInputFormat
!
=
INPUT_FORMAT_RGBA
&
&
aInputFormat
!
=
INPUT_FORMAT_HOSTARGB
)
return
NS_ERROR_INVALID_ARG
;
if
(
(
aInputFormat
=
=
INPUT_FORMAT_RGB
&
&
aStride
<
aWidth
*
3
)
|
|
(
(
aInputFormat
=
=
INPUT_FORMAT_RGBA
|
|
aInputFormat
=
=
INPUT_FORMAT_HOSTARGB
)
&
&
aStride
<
aWidth
*
4
)
)
{
NS_WARNING
(
"
Invalid
stride
for
InitFromData
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mImageBuffer
!
=
nullptr
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
int
quality
=
92
;
if
(
aOutputOptions
.
Length
(
)
>
0
)
{
const
nsString
qualityPrefix
(
u
"
quality
=
"
_ns
)
;
if
(
aOutputOptions
.
Length
(
)
>
qualityPrefix
.
Length
(
)
&
&
StringBeginsWith
(
aOutputOptions
qualityPrefix
)
)
{
nsCString
value
=
NS_ConvertUTF16toUTF8
(
Substring
(
aOutputOptions
qualityPrefix
.
Length
(
)
)
)
;
int
newquality
=
-
1
;
if
(
PR_sscanf
(
value
.
get
(
)
"
%
d
"
&
newquality
)
=
=
1
)
{
if
(
newquality
>
=
0
&
&
newquality
<
=
100
)
{
quality
=
newquality
;
}
else
{
NS_WARNING
(
"
Quality
value
out
of
range
should
be
0
-
100
"
"
using
default
"
)
;
}
}
else
{
NS_WARNING
(
"
Quality
value
invalid
should
be
integer
0
-
100
"
"
using
default
"
)
;
}
}
else
{
return
NS_ERROR_INVALID_ARG
;
}
}
size_t
size
=
0
;
CheckedInt32
width
=
CheckedInt32
(
aWidth
)
;
CheckedInt32
height
=
CheckedInt32
(
aHeight
)
;
CheckedInt32
stride
=
CheckedInt32
(
aStride
)
;
if
(
!
width
.
isValid
(
)
|
|
!
height
.
isValid
(
)
|
|
!
stride
.
isValid
(
)
|
|
!
(
CheckedUint32
(
aStride
)
*
CheckedUint32
(
aHeight
)
)
.
isValid
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aInputFormat
=
=
INPUT_FORMAT_RGB
)
{
size
=
quality
=
=
100
?
WebPEncodeLosslessRGB
(
aData
width
.
value
(
)
height
.
value
(
)
stride
.
value
(
)
&
mImageBuffer
)
:
WebPEncodeRGB
(
aData
width
.
value
(
)
height
.
value
(
)
stride
.
value
(
)
quality
&
mImageBuffer
)
;
}
else
if
(
aInputFormat
=
=
INPUT_FORMAT_RGBA
)
{
size
=
quality
=
=
100
?
WebPEncodeLosslessRGBA
(
aData
width
.
value
(
)
height
.
value
(
)
stride
.
value
(
)
&
mImageBuffer
)
:
WebPEncodeRGBA
(
aData
width
.
value
(
)
height
.
value
(
)
stride
.
value
(
)
quality
&
mImageBuffer
)
;
}
else
if
(
aInputFormat
=
=
INPUT_FORMAT_HOSTARGB
)
{
UniquePtr
<
uint8_t
[
]
>
aDest
=
MakeUniqueFallible
<
uint8_t
[
]
>
(
aStride
*
aHeight
)
;
if
(
NS_WARN_IF
(
!
aDest
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
y
=
0
;
y
<
aHeight
;
y
+
+
)
{
for
(
uint32_t
x
=
0
;
x
<
aWidth
;
x
+
+
)
{
const
uint32_t
&
pixelIn
=
(
(
const
uint32_t
*
)
(
aData
)
)
[
y
*
aStride
/
4
+
x
]
;
uint8_t
*
pixelOut
=
&
aDest
[
y
*
aStride
+
x
*
4
]
;
uint8_t
alpha
=
(
pixelIn
&
0xff000000
)
>
>
24
;
pixelOut
[
3
]
=
alpha
;
if
(
alpha
=
=
255
)
{
pixelOut
[
0
]
=
(
pixelIn
&
0xff0000
)
>
>
16
;
pixelOut
[
1
]
=
(
pixelIn
&
0x00ff00
)
>
>
8
;
pixelOut
[
2
]
=
(
pixelIn
&
0x0000ff
)
;
}
else
if
(
alpha
=
=
0
)
{
pixelOut
[
0
]
=
pixelOut
[
1
]
=
pixelOut
[
2
]
=
0
;
}
else
{
pixelOut
[
0
]
=
(
(
(
pixelIn
&
0xff0000
)
>
>
16
)
*
255
+
alpha
/
2
)
/
alpha
;
pixelOut
[
1
]
=
(
(
(
pixelIn
&
0x00ff00
)
>
>
8
)
*
255
+
alpha
/
2
)
/
alpha
;
pixelOut
[
2
]
=
(
(
(
pixelIn
&
0x0000ff
)
)
*
255
+
alpha
/
2
)
/
alpha
;
}
}
}
size
=
quality
=
=
100
?
WebPEncodeLosslessRGBA
(
aDest
.
get
(
)
width
.
value
(
)
height
.
value
(
)
stride
.
value
(
)
&
mImageBuffer
)
:
WebPEncodeRGBA
(
aDest
.
get
(
)
width
.
value
(
)
height
.
value
(
)
stride
.
value
(
)
quality
&
mImageBuffer
)
;
}
mFinished
=
true
;
if
(
size
=
=
0
)
{
return
NS_ERROR_FAILURE
;
}
mImageBufferUsed
=
size
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
StartImageEncode
(
uint32_t
aWidth
uint32_t
aHeight
uint32_t
aInputFormat
const
nsAString
&
aOutputOptions
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
GetImageBufferUsed
(
uint32_t
*
aOutputSize
)
{
NS_ENSURE_ARG_POINTER
(
aOutputSize
)
;
*
aOutputSize
=
mImageBufferUsed
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
GetImageBuffer
(
char
*
*
aOutputBuffer
)
{
NS_ENSURE_ARG_POINTER
(
aOutputBuffer
)
;
*
aOutputBuffer
=
reinterpret_cast
<
char
*
>
(
mImageBuffer
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
AddImageFrame
(
const
uint8_t
*
aData
uint32_t
aLength
uint32_t
aWidth
uint32_t
aHeight
uint32_t
aStride
uint32_t
aInputFormat
const
nsAString
&
aFrameOptions
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
EndImageEncode
(
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
Close
(
)
{
if
(
mImageBuffer
)
{
WebPFree
(
mImageBuffer
)
;
mImageBuffer
=
nullptr
;
mImageBufferSize
=
0
;
mImageBufferUsed
=
0
;
mImageBufferReadPoint
=
0
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
Available
(
uint64_t
*
_retval
)
{
if
(
!
mImageBuffer
)
{
return
NS_BASE_STREAM_CLOSED
;
}
*
_retval
=
mImageBufferUsed
-
mImageBufferReadPoint
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
StreamStatus
(
)
{
return
mImageBuffer
?
NS_OK
:
NS_BASE_STREAM_CLOSED
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
_retval
)
{
return
ReadSegments
(
NS_CopySegmentToBuffer
aBuf
aCount
_retval
)
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
_retval
)
{
ReentrantMonitorAutoEnter
autoEnter
(
mReentrantMonitor
)
;
uint32_t
maxCount
=
mImageBufferUsed
-
mImageBufferReadPoint
;
if
(
maxCount
=
=
0
)
{
*
_retval
=
0
;
return
mFinished
?
NS_OK
:
NS_BASE_STREAM_WOULD_BLOCK
;
}
if
(
aCount
>
maxCount
)
{
aCount
=
maxCount
;
}
nsresult
rv
=
aWriter
(
this
aClosure
reinterpret_cast
<
const
char
*
>
(
mImageBuffer
+
mImageBufferReadPoint
)
0
aCount
_retval
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ASSERTION
(
*
_retval
<
=
aCount
"
bad
write
count
"
)
;
mImageBufferReadPoint
+
=
*
_retval
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
IsNonBlocking
(
bool
*
_retval
)
{
*
_retval
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
AsyncWait
(
nsIInputStreamCallback
*
aCallback
uint32_t
aFlags
uint32_t
aRequestedCount
nsIEventTarget
*
aTarget
)
{
if
(
aFlags
!
=
0
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
mCallback
|
|
mCallbackTarget
)
{
return
NS_ERROR_UNEXPECTED
;
}
mCallbackTarget
=
aTarget
;
mNotifyThreshold
=
aRequestedCount
;
if
(
!
aRequestedCount
)
{
mNotifyThreshold
=
1024
;
}
mCallback
=
aCallback
;
NotifyListener
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsWebPEncoder
:
:
CloseWithStatus
(
nsresult
aStatus
)
{
return
Close
(
)
;
}
void
nsWebPEncoder
:
:
NotifyListener
(
)
{
ReentrantMonitorAutoEnter
autoEnter
(
mReentrantMonitor
)
;
if
(
mCallback
&
&
(
mImageBufferUsed
-
mImageBufferReadPoint
>
=
mNotifyThreshold
|
|
mFinished
)
)
{
nsCOMPtr
<
nsIInputStreamCallback
>
callback
;
if
(
mCallbackTarget
)
{
callback
=
NS_NewInputStreamReadyEvent
(
"
nsWebPEncoder
:
:
NotifyListener
"
mCallback
mCallbackTarget
)
;
}
else
{
callback
=
mCallback
;
}
NS_ASSERTION
(
callback
"
Shouldn
'
t
fail
to
make
the
callback
"
)
;
mCallback
=
nullptr
;
mCallbackTarget
=
nullptr
;
mNotifyThreshold
=
0
;
callback
-
>
OnInputStreamReady
(
this
)
;
}
}
