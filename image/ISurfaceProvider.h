#
ifndef
mozilla_image_ISurfaceProvider_h
#
define
mozilla_image_ISurfaceProvider_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
imgFrame
.
h
"
#
include
"
SurfaceCache
.
h
"
namespace
mozilla
{
namespace
image
{
class
CachedSurface
;
class
DrawableSurface
;
class
ISurfaceProvider
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
ImageKey
GetImageKey
(
)
const
{
return
mImageKey
;
}
const
SurfaceKey
&
GetSurfaceKey
(
)
const
{
return
mSurfaceKey
;
}
virtual
DrawableSurface
Surface
(
)
;
virtual
bool
IsFinished
(
)
const
=
0
;
virtual
bool
IsFullyDecoded
(
)
const
{
return
IsFinished
(
)
;
}
virtual
size_t
LogicalSizeInBytes
(
)
const
=
0
;
virtual
void
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
size_t
&
aHeapSizeOut
size_t
&
aNonHeapSizeOut
size_t
&
aExtHandlesOut
)
{
DrawableFrameRef
ref
=
DrawableRef
(
0
)
;
if
(
!
ref
)
{
return
;
}
ref
-
>
AddSizeOfExcludingThis
(
aMallocSizeOf
aHeapSizeOut
aNonHeapSizeOut
aExtHandlesOut
)
;
}
virtual
void
Reset
(
)
{
}
virtual
void
Advance
(
size_t
aFrame
)
{
}
AvailabilityState
&
Availability
(
)
{
return
mAvailability
;
}
const
AvailabilityState
&
Availability
(
)
const
{
return
mAvailability
;
}
protected
:
ISurfaceProvider
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
AvailabilityState
aAvailability
)
:
mImageKey
(
aImageKey
)
mSurfaceKey
(
aSurfaceKey
)
mAvailability
(
aAvailability
)
{
MOZ_ASSERT
(
aImageKey
"
Must
have
a
valid
image
key
"
)
;
}
virtual
~
ISurfaceProvider
(
)
{
}
virtual
DrawableFrameRef
DrawableRef
(
size_t
aFrame
)
=
0
;
virtual
bool
IsLocked
(
)
const
=
0
;
virtual
void
SetLocked
(
bool
aLocked
)
=
0
;
private
:
friend
class
CachedSurface
;
friend
class
DrawableSurface
;
const
ImageKey
mImageKey
;
const
SurfaceKey
mSurfaceKey
;
AvailabilityState
mAvailability
;
}
;
class
MOZ_STACK_CLASS
DrawableSurface
final
{
public
:
DrawableSurface
(
)
:
mHaveSurface
(
false
)
{
}
explicit
DrawableSurface
(
DrawableFrameRef
&
&
aDrawableRef
)
:
mDrawableRef
(
Move
(
aDrawableRef
)
)
mHaveSurface
(
bool
(
mDrawableRef
)
)
{
}
explicit
DrawableSurface
(
NotNull
<
ISurfaceProvider
*
>
aProvider
)
:
mProvider
(
aProvider
)
mHaveSurface
(
true
)
{
}
DrawableSurface
(
DrawableSurface
&
&
aOther
)
:
mDrawableRef
(
Move
(
aOther
.
mDrawableRef
)
)
mProvider
(
Move
(
aOther
.
mProvider
)
)
mHaveSurface
(
aOther
.
mHaveSurface
)
{
aOther
.
mHaveSurface
=
false
;
}
DrawableSurface
&
operator
=
(
DrawableSurface
&
&
aOther
)
{
MOZ_ASSERT
(
this
!
=
&
aOther
"
Self
-
moves
are
prohibited
"
)
;
mDrawableRef
=
Move
(
aOther
.
mDrawableRef
)
;
mProvider
=
Move
(
aOther
.
mProvider
)
;
mHaveSurface
=
aOther
.
mHaveSurface
;
aOther
.
mHaveSurface
=
false
;
return
*
this
;
}
nsresult
Seek
(
size_t
aFrame
)
{
MOZ_ASSERT
(
mHaveSurface
"
Trying
to
seek
an
empty
DrawableSurface
?
"
)
;
if
(
!
mProvider
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
seek
a
static
DrawableSurface
?
"
)
;
return
NS_ERROR_FAILURE
;
}
mDrawableRef
=
mProvider
-
>
DrawableRef
(
aFrame
)
;
return
mDrawableRef
?
NS_OK
:
NS_ERROR_FAILURE
;
}
void
Reset
(
)
{
if
(
!
mProvider
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
reset
a
static
DrawableSurface
?
"
)
;
return
;
}
mProvider
-
>
Reset
(
)
;
}
void
Advance
(
size_t
aFrame
)
{
if
(
!
mProvider
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
advance
a
static
DrawableSurface
?
"
)
;
return
;
}
mProvider
-
>
Advance
(
aFrame
)
;
}
bool
IsFullyDecoded
(
)
const
{
if
(
!
mProvider
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
check
decoding
state
of
a
static
DrawableSurface
?
"
)
;
return
false
;
}
return
mProvider
-
>
IsFullyDecoded
(
)
;
}
explicit
operator
bool
(
)
const
{
return
mHaveSurface
;
}
imgFrame
*
operator
-
>
(
)
{
return
DrawableRef
(
)
.
get
(
)
;
}
private
:
DrawableSurface
(
const
DrawableSurface
&
aOther
)
=
delete
;
DrawableSurface
&
operator
=
(
const
DrawableSurface
&
aOther
)
=
delete
;
DrawableFrameRef
&
DrawableRef
(
)
{
MOZ_ASSERT
(
mHaveSurface
)
;
if
(
!
mDrawableRef
)
{
MOZ_ASSERT
(
mProvider
)
;
mDrawableRef
=
mProvider
-
>
DrawableRef
(
0
)
;
}
MOZ_ASSERT
(
mDrawableRef
)
;
return
mDrawableRef
;
}
DrawableFrameRef
mDrawableRef
;
RefPtr
<
ISurfaceProvider
>
mProvider
;
bool
mHaveSurface
;
}
;
inline
DrawableSurface
ISurfaceProvider
:
:
Surface
(
)
{
return
DrawableSurface
(
DrawableRef
(
0
)
)
;
}
class
SimpleSurfaceProvider
final
:
public
ISurfaceProvider
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SimpleSurfaceProvider
override
)
SimpleSurfaceProvider
(
const
ImageKey
aImageKey
const
SurfaceKey
&
aSurfaceKey
NotNull
<
imgFrame
*
>
aSurface
)
:
ISurfaceProvider
(
aImageKey
aSurfaceKey
AvailabilityState
:
:
StartAvailable
(
)
)
mSurface
(
aSurface
)
{
MOZ_ASSERT
(
aSurfaceKey
.
Size
(
)
=
=
mSurface
-
>
GetSize
(
)
)
;
}
bool
IsFinished
(
)
const
override
{
return
mSurface
-
>
IsFinished
(
)
;
}
size_t
LogicalSizeInBytes
(
)
const
override
{
gfx
:
:
IntSize
size
=
mSurface
-
>
GetSize
(
)
;
return
size
.
width
*
size
.
height
*
mSurface
-
>
GetBytesPerPixel
(
)
;
}
protected
:
DrawableFrameRef
DrawableRef
(
size_t
aFrame
)
override
{
MOZ_ASSERT
(
aFrame
=
=
0
"
Requesting
an
animation
frame
from
a
SimpleSurfaceProvider
?
"
)
;
return
mSurface
-
>
DrawableRef
(
)
;
}
bool
IsLocked
(
)
const
override
{
return
bool
(
mLockRef
)
;
}
void
SetLocked
(
bool
aLocked
)
override
{
if
(
aLocked
=
=
IsLocked
(
)
)
{
return
;
}
mLockRef
=
aLocked
?
mSurface
-
>
DrawableRef
(
)
:
DrawableFrameRef
(
)
;
}
private
:
virtual
~
SimpleSurfaceProvider
(
)
{
}
NotNull
<
RefPtr
<
imgFrame
>
>
mSurface
;
DrawableFrameRef
mLockRef
;
}
;
}
}
#
endif
