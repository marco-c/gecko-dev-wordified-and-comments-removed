#
include
"
ImageLogging
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
base
/
histogram
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SurfaceCache
.
h
"
#
include
"
FrameAnimator
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
gfx
/
Scale
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
gfx
;
using
namespace
layers
;
namespace
image
{
using
std
:
:
ceil
;
using
std
:
:
min
;
static
int32_t
sMaxDecodeCount
=
0
;
#
ifndef
DEBUG
NS_IMPL_ISUPPORTS
(
RasterImage
imgIContainer
nsIProperties
)
#
else
NS_IMPL_ISUPPORTS
(
RasterImage
imgIContainer
nsIProperties
imgIContainerDebug
)
#
endif
RasterImage
:
:
RasterImage
(
ImageURL
*
aURI
)
:
ImageResource
(
aURI
)
mSize
(
0
0
)
mLockCount
(
0
)
mDecodeCount
(
0
)
mRequestedSampleSize
(
0
)
mLastImageContainerDrawResult
(
DrawResult
:
:
NOT_READY
)
#
ifdef
DEBUG
mFramesNotified
(
0
)
#
endif
mSourceBuffer
(
new
SourceBuffer
(
)
)
mFrameCount
(
0
)
mHasSize
(
false
)
mTransient
(
false
)
mSyncLoad
(
false
)
mDiscardable
(
false
)
mHasSourceData
(
false
)
mHasBeenDecoded
(
false
)
mPendingAnimation
(
false
)
mAnimationFinished
(
false
)
mWantFullDecode
(
false
)
{
Telemetry
:
:
GetHistogramById
(
Telemetry
:
:
IMAGE_DECODE_COUNT
)
-
>
Add
(
0
)
;
}
RasterImage
:
:
~
RasterImage
(
)
{
if
(
!
mSourceBuffer
-
>
IsComplete
(
)
)
{
mSourceBuffer
-
>
Complete
(
NS_ERROR_ABORT
)
;
}
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
}
nsresult
RasterImage
:
:
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
{
if
(
mInitialized
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT_IF
(
aFlags
&
INIT_FLAG_TRANSIENT
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
)
;
mDiscardable
=
!
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
;
mWantFullDecode
=
!
!
(
aFlags
&
INIT_FLAG_DECODE_IMMEDIATELY
)
;
mTransient
=
!
!
(
aFlags
&
INIT_FLAG_TRANSIENT
)
;
mSyncLoad
=
!
!
(
aFlags
&
INIT_FLAG_SYNC_LOAD
)
;
NS_ENSURE_ARG_POINTER
(
aMimeType
)
;
mDecoderType
=
DecoderFactory
:
:
GetDecoderType
(
aMimeType
)
;
if
(
mDecoderType
=
=
DecoderType
:
:
UNKNOWN
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDiscardable
)
{
mLockCount
+
+
;
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
if
(
!
mSyncLoad
)
{
nsresult
rv
=
DecodeMetadata
(
DECODE_FLAGS_DEFAULT
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_FAILURE
;
}
}
mInitialized
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
RasterImage
:
:
RequestRefresh
(
const
TimeStamp
&
aTime
)
{
if
(
HadRecentRefresh
(
aTime
)
)
{
return
;
}
EvaluateAnimation
(
)
;
if
(
!
mAnimating
)
{
return
;
}
FrameAnimator
:
:
RefreshResult
res
;
if
(
mAnim
)
{
res
=
mAnim
-
>
RequestRefresh
(
aTime
)
;
}
if
(
res
.
frameAdvanced
)
{
#
ifdef
DEBUG
mFramesNotified
+
+
;
#
endif
NotifyProgress
(
NoProgress
res
.
dirtyRect
)
;
}
if
(
res
.
animationFinished
)
{
mAnimationFinished
=
true
;
EvaluateAnimation
(
)
;
}
}
NS_IMETHODIMP
RasterImage
:
:
GetWidth
(
int32_t
*
aWidth
)
{
NS_ENSURE_ARG_POINTER
(
aWidth
)
;
if
(
mError
)
{
*
aWidth
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aWidth
=
mSize
.
width
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetHeight
(
int32_t
*
aHeight
)
{
NS_ENSURE_ARG_POINTER
(
aHeight
)
;
if
(
mError
)
{
*
aHeight
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aHeight
=
mSize
.
height
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetIntrinsicSize
(
nsSize
*
aSize
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
*
aSize
=
nsSize
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
mSize
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
mSize
.
height
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetIntrinsicRatio
(
nsSize
*
aRatio
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
*
aRatio
=
nsSize
(
mSize
.
width
mSize
.
height
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
Orientation
)
RasterImage
:
:
GetOrientation
(
)
{
return
mOrientation
;
}
NS_IMETHODIMP
RasterImage
:
:
GetType
(
uint16_t
*
aType
)
{
NS_ENSURE_ARG_POINTER
(
aType
)
;
*
aType
=
imgIContainer
:
:
TYPE_RASTER
;
return
NS_OK
;
}
LookupResult
RasterImage
:
:
LookupFrameInternal
(
uint32_t
aFrameNum
const
IntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
mAnim
)
{
NS_ASSERTION
(
aFrameNum
=
=
0
"
Don
'
t
ask
for
a
frame
>
0
if
we
'
re
not
animated
!
"
)
;
aFrameNum
=
0
;
}
if
(
mAnim
&
&
aFrameNum
>
0
)
{
MOZ_ASSERT
(
ToSurfaceFlags
(
aFlags
)
=
=
DefaultSurfaceFlags
(
)
"
Can
'
t
composite
frames
with
non
-
default
surface
flags
"
)
;
return
mAnim
-
>
GetCompositedFrame
(
aFrameNum
)
;
}
SurfaceFlags
surfaceFlags
=
ToSurfaceFlags
(
aFlags
)
;
if
(
aFlags
&
FLAG_SYNC_DECODE
)
{
return
SurfaceCache
:
:
Lookup
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
surfaceFlags
aFrameNum
)
)
;
}
return
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
surfaceFlags
aFrameNum
)
)
;
}
DrawableFrameRef
RasterImage
:
:
LookupFrame
(
uint32_t
aFrameNum
const
IntSize
&
aSize
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsOpaque
(
)
)
{
aFlags
&
=
~
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
;
}
IntSize
requestedSize
=
CanDownscaleDuringDecode
(
aSize
aFlags
)
?
aSize
:
mSize
;
if
(
requestedSize
.
IsEmpty
(
)
)
{
return
DrawableFrameRef
(
)
;
}
LookupResult
result
=
LookupFrameInternal
(
aFrameNum
requestedSize
aFlags
)
;
if
(
!
result
&
&
!
mHasSize
)
{
return
DrawableFrameRef
(
)
;
}
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
|
|
result
.
Type
(
)
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
|
|
(
(
aFlags
&
FLAG_SYNC_DECODE
)
&
&
!
result
)
)
{
MOZ_ASSERT
(
!
mAnim
|
|
GetNumFrames
(
)
<
1
"
Animated
frames
should
be
locked
"
)
;
Decode
(
requestedSize
aFlags
)
;
if
(
aFlags
&
FLAG_SYNC_DECODE
)
{
result
=
LookupFrameInternal
(
aFrameNum
requestedSize
aFlags
)
;
}
}
if
(
!
result
)
{
return
DrawableFrameRef
(
)
;
}
if
(
result
.
DrawableRef
(
)
-
>
GetCompositingFailed
(
)
)
{
return
DrawableFrameRef
(
)
;
}
MOZ_ASSERT
(
!
result
.
DrawableRef
(
)
-
>
GetIsPaletted
(
)
"
Should
not
have
a
paletted
frame
"
)
;
if
(
mHasSourceData
&
&
(
aFlags
&
FLAG_SYNC_DECODE
)
)
{
result
.
DrawableRef
(
)
-
>
WaitUntilComplete
(
)
;
}
return
Move
(
result
.
DrawableRef
(
)
)
;
}
uint32_t
RasterImage
:
:
GetCurrentFrameIndex
(
)
const
{
if
(
mAnim
)
{
return
mAnim
-
>
GetCurrentAnimationFrameIndex
(
)
;
}
return
0
;
}
uint32_t
RasterImage
:
:
GetRequestedFrameIndex
(
uint32_t
aWhichFrame
)
const
{
return
aWhichFrame
=
=
FRAME_FIRST
?
0
:
GetCurrentFrameIndex
(
)
;
}
IntRect
RasterImage
:
:
GetFirstFrameRect
(
)
{
if
(
mAnim
&
&
mHasBeenDecoded
)
{
return
mAnim
-
>
GetFirstFrameRefreshArea
(
)
;
}
return
IntRect
(
IntPoint
(
0
0
)
mSize
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
IsOpaque
(
)
{
if
(
mError
)
{
return
false
;
}
Progress
progress
=
mProgressTracker
-
>
GetProgress
(
)
;
if
(
!
(
progress
&
FLAG_DECODE_COMPLETE
)
)
{
return
false
;
}
return
!
(
progress
&
FLAG_HAS_TRANSPARENCY
)
;
}
void
RasterImage
:
:
OnSurfaceDiscarded
(
)
{
MOZ_ASSERT
(
mProgressTracker
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableMethod
(
mProgressTracker
&
ProgressTracker
:
:
OnDiscard
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
NS_IMETHODIMP
RasterImage
:
:
GetAnimated
(
bool
*
aAnimated
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_ARG_POINTER
(
aAnimated
)
;
if
(
mAnim
)
{
*
aAnimated
=
true
;
return
NS_OK
;
}
if
(
!
mHasBeenDecoded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aAnimated
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
int32_t
)
RasterImage
:
:
GetFirstFrameDelay
(
)
{
if
(
mError
)
{
return
-
1
;
}
bool
animated
=
false
;
if
(
NS_FAILED
(
GetAnimated
(
&
animated
)
)
|
|
!
animated
)
{
return
-
1
;
}
MOZ_ASSERT
(
mAnim
"
Animated
images
should
have
a
FrameAnimator
"
)
;
return
mAnim
-
>
GetTimeoutForFrame
(
0
)
;
}
already_AddRefed
<
SourceSurface
>
RasterImage
:
:
CopyFrame
(
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
nullptr
;
}
if
(
mError
)
{
return
nullptr
;
}
DrawableFrameRef
frameRef
=
LookupFrame
(
GetRequestedFrameIndex
(
aWhichFrame
)
mSize
aFlags
)
;
if
(
!
frameRef
)
{
return
nullptr
;
}
IntSize
size
(
mSize
.
width
mSize
.
height
)
;
RefPtr
<
DataSourceSurface
>
surf
=
Factory
:
:
CreateDataSourceSurface
(
size
SurfaceFormat
:
:
B8G8R8A8
true
)
;
if
(
NS_WARN_IF
(
!
surf
)
)
{
return
nullptr
;
}
DataSourceSurface
:
:
MappedSurface
mapping
;
if
(
!
surf
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
WRITE
&
mapping
)
)
{
gfxCriticalError
(
)
<
<
"
RasterImage
:
:
CopyFrame
failed
to
map
surface
"
;
return
nullptr
;
}
RefPtr
<
DrawTarget
>
target
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
mapping
.
mData
size
mapping
.
mStride
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
target
)
{
gfxWarning
(
)
<
<
"
RasterImage
:
:
CopyFrame
failed
in
CreateDrawTargetForData
"
;
return
nullptr
;
}
IntRect
intFrameRect
=
frameRef
-
>
GetRect
(
)
;
Rect
rect
(
intFrameRect
.
x
intFrameRect
.
y
intFrameRect
.
width
intFrameRect
.
height
)
;
if
(
frameRef
-
>
IsSinglePixel
(
)
)
{
target
-
>
FillRect
(
rect
ColorPattern
(
frameRef
-
>
SinglePixelColor
(
)
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
else
{
RefPtr
<
SourceSurface
>
srcSurf
=
frameRef
-
>
GetSurface
(
)
;
if
(
!
srcSurf
)
{
RecoverFromInvalidFrames
(
mSize
aFlags
)
;
return
nullptr
;
}
Rect
srcRect
(
0
0
intFrameRect
.
width
intFrameRect
.
height
)
;
target
-
>
DrawSurface
(
srcSurf
srcRect
rect
)
;
}
target
-
>
Flush
(
)
;
surf
-
>
Unmap
(
)
;
return
surf
.
forget
(
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
RasterImage
:
:
GetFrame
(
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
return
GetFrameInternal
(
mSize
aWhichFrame
aFlags
)
.
second
(
)
.
forget
(
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
RasterImage
:
:
GetFrameAtSize
(
const
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
return
GetFrameInternal
(
aSize
aWhichFrame
aFlags
)
.
second
(
)
.
forget
(
)
;
}
Pair
<
DrawResult
RefPtr
<
SourceSurface
>
>
RasterImage
:
:
GetFrameInternal
(
const
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
)
;
if
(
aSize
.
IsEmpty
(
)
)
{
return
MakePair
(
DrawResult
:
:
BAD_ARGS
RefPtr
<
SourceSurface
>
(
)
)
;
}
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
MakePair
(
DrawResult
:
:
BAD_ARGS
RefPtr
<
SourceSurface
>
(
)
)
;
}
if
(
mError
)
{
return
MakePair
(
DrawResult
:
:
BAD_IMAGE
RefPtr
<
SourceSurface
>
(
)
)
;
}
DrawableFrameRef
frameRef
=
LookupFrame
(
GetRequestedFrameIndex
(
aWhichFrame
)
aSize
aFlags
)
;
if
(
!
frameRef
)
{
return
MakePair
(
DrawResult
:
:
TEMPORARY_ERROR
RefPtr
<
SourceSurface
>
(
)
)
;
}
RefPtr
<
SourceSurface
>
frameSurf
;
if
(
!
frameRef
-
>
NeedsPadding
(
)
&
&
frameRef
-
>
GetSize
(
)
=
=
aSize
)
{
frameSurf
=
frameRef
-
>
GetSurface
(
)
;
}
if
(
!
frameSurf
)
{
frameSurf
=
CopyFrame
(
aWhichFrame
aFlags
)
;
}
if
(
!
frameRef
-
>
IsImageComplete
(
)
)
{
return
MakePair
(
DrawResult
:
:
INCOMPLETE
Move
(
frameSurf
)
)
;
}
return
MakePair
(
DrawResult
:
:
SUCCESS
Move
(
frameSurf
)
)
;
}
Pair
<
DrawResult
RefPtr
<
layers
:
:
Image
>
>
RasterImage
:
:
GetCurrentImage
(
ImageContainer
*
aContainer
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aContainer
)
;
DrawResult
drawResult
;
RefPtr
<
SourceSurface
>
surface
;
Tie
(
drawResult
surface
)
=
GetFrameInternal
(
mSize
FRAME_CURRENT
aFlags
|
FLAG_ASYNC_NOTIFY
)
;
if
(
!
surface
)
{
return
MakePair
(
drawResult
RefPtr
<
layers
:
:
Image
>
(
)
)
;
}
IntSize
size
;
GetWidth
(
&
size
.
width
)
;
GetHeight
(
&
size
.
height
)
;
RefPtr
<
layers
:
:
Image
>
image
=
new
layers
:
:
SourceSurfaceImage
(
size
surface
)
;
return
MakePair
(
drawResult
Move
(
image
)
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
IsImageContainerAvailable
(
LayerManager
*
aManager
uint32_t
aFlags
)
{
int32_t
maxTextureSize
=
aManager
-
>
GetMaxTextureSize
(
)
;
if
(
!
mHasSize
|
|
mSize
.
width
>
maxTextureSize
|
|
mSize
.
height
>
maxTextureSize
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
ImageContainer
>
)
RasterImage
:
:
GetImageContainer
(
LayerManager
*
aManager
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
(
aFlags
&
~
(
FLAG_SYNC_DECODE
|
FLAG_SYNC_DECODE_IF_FAST
|
FLAG_ASYNC_NOTIFY
)
)
=
=
FLAG_NONE
"
Unsupported
flag
passed
to
GetImageContainer
"
)
;
int32_t
maxTextureSize
=
aManager
-
>
GetMaxTextureSize
(
)
;
if
(
!
mHasSize
|
|
mSize
.
width
>
maxTextureSize
|
|
mSize
.
height
>
maxTextureSize
)
{
return
nullptr
;
}
if
(
IsUnlocked
(
)
&
&
mProgressTracker
)
{
mProgressTracker
-
>
OnUnlockedDraw
(
)
;
}
RefPtr
<
layers
:
:
ImageContainer
>
container
=
mImageContainer
.
get
(
)
;
bool
mustRedecode
=
(
aFlags
&
(
FLAG_SYNC_DECODE
|
FLAG_SYNC_DECODE_IF_FAST
)
)
&
&
mLastImageContainerDrawResult
!
=
DrawResult
:
:
SUCCESS
&
&
mLastImageContainerDrawResult
!
=
DrawResult
:
:
BAD_IMAGE
;
if
(
container
&
&
!
mustRedecode
)
{
return
container
.
forget
(
)
;
}
container
=
LayerManager
:
:
CreateImageContainer
(
)
;
DrawResult
drawResult
;
RefPtr
<
layers
:
:
Image
>
image
;
Tie
(
drawResult
image
)
=
GetCurrentImage
(
container
aFlags
)
;
if
(
!
image
)
{
return
nullptr
;
}
container
-
>
SetCurrentImageInTransaction
(
image
)
;
mLastImageContainerDrawResult
=
drawResult
;
mImageContainer
=
container
;
return
container
.
forget
(
)
;
}
void
RasterImage
:
:
UpdateImageContainer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
layers
:
:
ImageContainer
>
container
=
mImageContainer
.
get
(
)
;
if
(
!
container
)
{
return
;
}
DrawResult
drawResult
;
RefPtr
<
layers
:
:
Image
>
image
;
Tie
(
drawResult
image
)
=
GetCurrentImage
(
container
FLAG_NONE
)
;
if
(
!
image
)
{
return
;
}
mLastImageContainerDrawResult
=
drawResult
;
nsAutoTArray
<
ImageContainer
:
:
NonOwningImage
1
>
imageList
;
imageList
.
AppendElement
(
ImageContainer
:
:
NonOwningImage
(
image
)
)
;
container
-
>
SetCurrentImages
(
imageList
)
;
}
size_t
RasterImage
:
:
SizeOfSourceWithComputedFallback
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mSourceBuffer
-
>
SizeOfIncludingThisWithComputedFallback
(
aMallocSizeOf
)
;
}
void
RasterImage
:
:
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
SurfaceCache
:
:
CollectSizeOfSurfaces
(
ImageKey
(
this
)
aCounters
aMallocSizeOf
)
;
if
(
mAnim
)
{
mAnim
-
>
CollectSizeOfCompositingSurfaces
(
aCounters
aMallocSizeOf
)
;
}
}
class
OnAddedFrameRunnable
:
public
nsRunnable
{
public
:
OnAddedFrameRunnable
(
RasterImage
*
aImage
uint32_t
aNewFrameCount
const
IntRect
&
aNewRefreshArea
)
:
mImage
(
aImage
)
mNewFrameCount
(
aNewFrameCount
)
mNewRefreshArea
(
aNewRefreshArea
)
{
MOZ_ASSERT
(
aImage
)
;
}
NS_IMETHOD
Run
(
)
{
mImage
-
>
OnAddedFrame
(
mNewFrameCount
mNewRefreshArea
)
;
return
NS_OK
;
}
private
:
RefPtr
<
RasterImage
>
mImage
;
uint32_t
mNewFrameCount
;
IntRect
mNewRefreshArea
;
}
;
void
RasterImage
:
:
OnAddedFrame
(
uint32_t
aNewFrameCount
const
IntRect
&
aNewRefreshArea
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
OnAddedFrameRunnable
(
this
aNewFrameCount
aNewRefreshArea
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
;
}
MOZ_ASSERT
(
aNewFrameCount
<
=
mFrameCount
+
1
"
Skipped
a
frame
?
"
)
;
if
(
mError
)
{
return
;
}
if
(
aNewFrameCount
>
mFrameCount
)
{
mFrameCount
=
aNewFrameCount
;
if
(
aNewFrameCount
=
=
2
)
{
MOZ_ASSERT
(
mAnim
"
Should
already
have
animation
state
"
)
;
if
(
mPendingAnimation
&
&
ShouldAnimate
(
)
)
{
StartAnimation
(
)
;
}
}
if
(
aNewFrameCount
>
1
)
{
mAnim
-
>
UnionFirstFrameRefreshArea
(
aNewRefreshArea
)
;
}
}
}
bool
RasterImage
:
:
SetMetadata
(
const
ImageMetadata
&
aMetadata
bool
aFromMetadataDecode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
true
;
}
if
(
aMetadata
.
HasSize
(
)
)
{
IntSize
size
=
aMetadata
.
GetSize
(
)
;
if
(
size
.
width
<
0
|
|
size
.
height
<
0
)
{
NS_WARNING
(
"
Image
has
negative
intrinsic
size
"
)
;
DoError
(
)
;
return
true
;
}
MOZ_ASSERT
(
aMetadata
.
HasOrientation
(
)
)
;
Orientation
orientation
=
aMetadata
.
GetOrientation
(
)
;
if
(
mHasSize
&
&
(
size
!
=
mSize
|
|
orientation
!
=
mOrientation
)
)
{
NS_WARNING
(
"
Image
changed
size
or
orientation
on
redecode
!
"
"
This
should
not
happen
!
"
)
;
DoError
(
)
;
return
true
;
}
mSize
=
size
;
mOrientation
=
orientation
;
mHasSize
=
true
;
}
if
(
mHasSize
&
&
aMetadata
.
HasAnimation
(
)
&
&
!
mAnim
)
{
mAnim
=
MakeUnique
<
FrameAnimator
>
(
this
mSize
mAnimationMode
)
;
LockImage
(
)
;
if
(
!
aFromMetadataDecode
)
{
return
false
;
}
}
if
(
mAnim
)
{
mAnim
-
>
SetLoopCount
(
aMetadata
.
GetLoopCount
(
)
)
;
mAnim
-
>
SetFirstFrameTimeout
(
aMetadata
.
GetFirstFrameTimeout
(
)
)
;
}
if
(
aMetadata
.
HasHotspot
(
)
)
{
IntPoint
hotspot
=
aMetadata
.
GetHotspot
(
)
;
nsCOMPtr
<
nsISupportsPRUint32
>
intwrapx
=
do_CreateInstance
(
NS_SUPPORTS_PRUINT32_CONTRACTID
)
;
nsCOMPtr
<
nsISupportsPRUint32
>
intwrapy
=
do_CreateInstance
(
NS_SUPPORTS_PRUINT32_CONTRACTID
)
;
intwrapx
-
>
SetData
(
hotspot
.
x
)
;
intwrapy
-
>
SetData
(
hotspot
.
y
)
;
Set
(
"
hotspotX
"
intwrapx
)
;
Set
(
"
hotspotY
"
intwrapy
)
;
}
return
true
;
}
NS_IMETHODIMP
RasterImage
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
if
(
mAnim
)
{
mAnim
-
>
SetAnimationMode
(
aAnimationMode
)
;
}
return
SetAnimationModeInternal
(
aAnimationMode
)
;
}
nsresult
RasterImage
:
:
StartAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
ShouldAnimate
(
)
"
Should
not
animate
!
"
)
;
mPendingAnimation
=
!
mAnim
|
|
GetNumFrames
(
)
<
2
;
if
(
mPendingAnimation
)
{
return
NS_OK
;
}
if
(
mAnim
-
>
GetTimeoutForFrame
(
GetCurrentFrameIndex
(
)
)
<
0
)
{
mAnimationFinished
=
true
;
return
NS_ERROR_ABORT
;
}
mAnim
-
>
InitAnimationFrameTimeIfNecessary
(
)
;
return
NS_OK
;
}
nsresult
RasterImage
:
:
StopAnimation
(
)
{
MOZ_ASSERT
(
mAnimating
"
Should
be
animating
!
"
)
;
nsresult
rv
=
NS_OK
;
if
(
mError
)
{
rv
=
NS_ERROR_FAILURE
;
}
else
{
mAnim
-
>
SetAnimationFrameTime
(
TimeStamp
(
)
)
;
}
mAnimating
=
false
;
return
rv
;
}
NS_IMETHODIMP
RasterImage
:
:
ResetAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
mPendingAnimation
=
false
;
if
(
mAnimationMode
=
=
kDontAnimMode
|
|
!
mAnim
|
|
mAnim
-
>
GetCurrentAnimationFrameIndex
(
)
=
=
0
)
{
return
NS_OK
;
}
mAnimationFinished
=
false
;
if
(
mAnimating
)
{
StopAnimation
(
)
;
}
MOZ_ASSERT
(
mAnim
"
Should
have
a
FrameAnimator
"
)
;
mAnim
-
>
ResetAnimation
(
)
;
NotifyProgress
(
NoProgress
mAnim
-
>
GetFirstFrameRefreshArea
(
)
)
;
EvaluateAnimation
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
RasterImage
:
:
SetAnimationStartTime
(
const
TimeStamp
&
aTime
)
{
if
(
mError
|
|
mAnimationMode
=
=
kDontAnimMode
|
|
mAnimating
|
|
!
mAnim
)
{
return
;
}
mAnim
-
>
SetAnimationFrameTime
(
aTime
)
;
}
NS_IMETHODIMP_
(
float
)
RasterImage
:
:
GetFrameIndex
(
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
"
Invalid
argument
"
)
;
return
(
aWhichFrame
=
=
FRAME_FIRST
|
|
!
mAnim
)
?
0
.
0f
:
mAnim
-
>
GetCurrentAnimationFrameIndex
(
)
;
}
NS_IMETHODIMP_
(
IntRect
)
RasterImage
:
:
GetImageSpaceInvalidationRect
(
const
IntRect
&
aRect
)
{
return
aRect
;
}
nsresult
RasterImage
:
:
OnImageDataComplete
(
nsIRequest
*
nsISupports
*
nsresult
aStatus
bool
aLastPart
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHasSourceData
=
true
;
mSourceBuffer
-
>
Complete
(
aStatus
)
;
bool
canSyncDecodeMetadata
=
mSyncLoad
|
|
mTransient
|
|
DecodePool
:
:
NumberOfCores
(
)
<
2
;
if
(
canSyncDecodeMetadata
&
&
!
mHasSize
)
{
DecodeMetadata
(
FLAG_SYNC_DECODE
)
;
}
nsresult
finalStatus
=
mError
?
NS_ERROR_FAILURE
:
NS_OK
;
if
(
NS_FAILED
(
aStatus
)
)
{
finalStatus
=
aStatus
;
}
if
(
NS_FAILED
(
finalStatus
)
)
{
DoError
(
)
;
}
Progress
loadProgress
=
LoadCompleteProgress
(
aLastPart
mError
finalStatus
)
;
if
(
!
mHasSize
&
&
!
mError
)
{
MOZ_ASSERT
(
!
canSyncDecodeMetadata
"
Firing
load
async
after
metadata
sync
decode
?
"
)
;
NotifyProgress
(
FLAG_ONLOAD_BLOCKED
)
;
mLoadProgress
=
Some
(
loadProgress
)
;
return
finalStatus
;
}
NotifyForLoadEvent
(
loadProgress
)
;
return
finalStatus
;
}
void
RasterImage
:
:
NotifyForLoadEvent
(
Progress
aProgress
)
{
MOZ_ASSERT
(
mHasSize
|
|
mError
"
Need
to
know
size
before
firing
load
event
"
)
;
MOZ_ASSERT
(
!
mHasSize
|
|
(
mProgressTracker
-
>
GetProgress
(
)
&
FLAG_SIZE_AVAILABLE
)
"
Should
have
notified
that
the
size
is
available
if
we
have
it
"
)
;
if
(
mError
)
{
aProgress
|
=
FLAG_HAS_ERROR
;
}
NotifyProgress
(
aProgress
)
;
}
nsresult
RasterImage
:
:
OnImageDataAvailable
(
nsIRequest
*
nsISupports
*
nsIInputStream
*
aInputStream
uint64_t
uint32_t
aCount
)
{
nsresult
rv
=
mSourceBuffer
-
>
AppendFromInputStream
(
aInputStream
aCount
)
;
MOZ_ASSERT
(
rv
=
=
NS_OK
|
|
rv
=
=
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
MOZ_UNLIKELY
(
rv
=
=
NS_ERROR_OUT_OF_MEMORY
)
)
{
DoError
(
)
;
}
return
rv
;
}
nsresult
RasterImage
:
:
SetSourceSizeHint
(
uint32_t
aSizeHint
)
{
return
mSourceBuffer
-
>
ExpectLength
(
aSizeHint
)
;
}
NS_IMETHODIMP
RasterImage
:
:
Get
(
const
char
*
prop
const
nsIID
&
iid
void
*
*
result
)
{
if
(
!
mProperties
)
{
return
NS_ERROR_FAILURE
;
}
return
mProperties
-
>
Get
(
prop
iid
result
)
;
}
NS_IMETHODIMP
RasterImage
:
:
Set
(
const
char
*
prop
nsISupports
*
value
)
{
if
(
!
mProperties
)
{
mProperties
=
do_CreateInstance
(
"
mozilla
.
org
/
properties
;
1
"
)
;
}
if
(
!
mProperties
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
mProperties
-
>
Set
(
prop
value
)
;
}
NS_IMETHODIMP
RasterImage
:
:
Has
(
const
char
*
prop
bool
*
_retval
)
{
NS_ENSURE_ARG_POINTER
(
_retval
)
;
if
(
!
mProperties
)
{
*
_retval
=
false
;
return
NS_OK
;
}
return
mProperties
-
>
Has
(
prop
_retval
)
;
}
NS_IMETHODIMP
RasterImage
:
:
Undefine
(
const
char
*
prop
)
{
if
(
!
mProperties
)
{
return
NS_ERROR_FAILURE
;
}
return
mProperties
-
>
Undefine
(
prop
)
;
}
NS_IMETHODIMP
RasterImage
:
:
GetKeys
(
uint32_t
*
count
char
*
*
*
keys
)
{
if
(
!
mProperties
)
{
*
count
=
0
;
*
keys
=
nullptr
;
return
NS_OK
;
}
return
mProperties
-
>
GetKeys
(
count
keys
)
;
}
void
RasterImage
:
:
Discard
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
CanDiscard
(
)
"
Asked
to
discard
but
can
'
t
"
)
;
MOZ_ASSERT
(
!
mAnim
"
Asked
to
discard
for
animated
image
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
mProgressTracker
)
{
mProgressTracker
-
>
OnDiscard
(
)
;
}
}
bool
RasterImage
:
:
CanDiscard
(
)
{
return
mHasSourceData
&
&
!
mAnim
;
}
NS_IMETHODIMP
RasterImage
:
:
StartDecoding
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mHasSize
)
{
mWantFullDecode
=
true
;
return
NS_OK
;
}
return
RequestDecodeForSize
(
mSize
FLAG_SYNC_DECODE_IF_FAST
)
;
}
NS_IMETHODIMP
RasterImage
:
:
RequestDecodeForSize
(
const
IntSize
&
aSize
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mHasSize
)
{
return
NS_OK
;
}
bool
shouldSyncDecodeIfFast
=
!
mHasBeenDecoded
&
&
(
aFlags
&
FLAG_SYNC_DECODE_IF_FAST
)
;
uint32_t
flags
=
shouldSyncDecodeIfFast
?
aFlags
:
aFlags
&
~
FLAG_SYNC_DECODE_IF_FAST
;
LookupFrame
(
0
aSize
flags
)
;
return
NS_OK
;
}
static
void
LaunchDecoder
(
Decoder
*
aDecoder
RasterImage
*
aImage
uint32_t
aFlags
bool
aHaveSourceData
)
{
if
(
aHaveSourceData
)
{
if
(
aFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
{
PROFILER_LABEL_PRINTF
(
"
DecodePool
"
"
SyncDecodeIfPossible
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
"
%
s
"
aImage
-
>
GetURIString
(
)
.
get
(
)
)
;
DecodePool
:
:
Singleton
(
)
-
>
SyncDecodeIfPossible
(
aDecoder
)
;
return
;
}
if
(
aFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
)
{
PROFILER_LABEL_PRINTF
(
"
DecodePool
"
"
SyncDecodeIfSmall
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
"
%
s
"
aImage
-
>
GetURIString
(
)
.
get
(
)
)
;
DecodePool
:
:
Singleton
(
)
-
>
SyncDecodeIfSmall
(
aDecoder
)
;
return
;
}
}
DecodePool
:
:
Singleton
(
)
-
>
AsyncDecode
(
aDecoder
)
;
}
NS_IMETHODIMP
RasterImage
:
:
Decode
(
const
IntSize
&
aSize
uint32_t
aFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mHasSize
)
{
mWantFullDecode
=
true
;
return
NS_OK
;
}
SurfaceCache
:
:
UnlockSurfaces
(
ImageKey
(
this
)
)
;
Maybe
<
IntSize
>
targetSize
=
mSize
!
=
aSize
?
Some
(
aSize
)
:
Nothing
(
)
;
DecoderFlags
decoderFlags
=
DefaultDecoderFlags
(
)
;
if
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
{
decoderFlags
|
=
DecoderFlags
:
:
ASYNC_NOTIFY
;
}
if
(
mTransient
)
{
decoderFlags
|
=
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
;
}
if
(
mHasBeenDecoded
)
{
decoderFlags
|
=
DecoderFlags
:
:
IS_REDECODE
;
}
SurfaceFlags
surfaceFlags
=
ToSurfaceFlags
(
aFlags
)
;
if
(
IsOpaque
(
)
)
{
surfaceFlags
&
=
~
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
;
}
RefPtr
<
Decoder
>
decoder
;
if
(
mAnim
)
{
decoder
=
DecoderFactory
:
:
CreateAnimationDecoder
(
mDecoderType
this
mSourceBuffer
decoderFlags
surfaceFlags
)
;
}
else
{
decoder
=
DecoderFactory
:
:
CreateDecoder
(
mDecoderType
this
mSourceBuffer
targetSize
decoderFlags
surfaceFlags
mRequestedSampleSize
)
;
}
if
(
!
decoder
)
{
return
NS_ERROR_FAILURE
;
}
InsertOutcome
outcome
=
SurfaceCache
:
:
InsertPlaceholder
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
decoder
-
>
GetSurfaceFlags
(
)
0
)
)
;
if
(
outcome
!
=
InsertOutcome
:
:
SUCCESS
)
{
return
NS_ERROR_FAILURE
;
}
Telemetry
:
:
GetHistogramById
(
Telemetry
:
:
IMAGE_DECODE_COUNT
)
-
>
Subtract
(
mDecodeCount
)
;
mDecodeCount
+
+
;
Telemetry
:
:
GetHistogramById
(
Telemetry
:
:
IMAGE_DECODE_COUNT
)
-
>
Add
(
mDecodeCount
)
;
if
(
mDecodeCount
>
sMaxDecodeCount
)
{
if
(
sMaxDecodeCount
>
0
)
{
Telemetry
:
:
GetHistogramById
(
Telemetry
:
:
IMAGE_MAX_DECODE_COUNT
)
-
>
Subtract
(
sMaxDecodeCount
)
;
}
sMaxDecodeCount
=
mDecodeCount
;
Telemetry
:
:
GetHistogramById
(
Telemetry
:
:
IMAGE_MAX_DECODE_COUNT
)
-
>
Add
(
sMaxDecodeCount
)
;
}
LaunchDecoder
(
decoder
this
aFlags
mHasSourceData
)
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
DecodeMetadata
(
uint32_t
aFlags
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
mHasSize
"
Should
not
do
unnecessary
metadata
decodes
"
)
;
RefPtr
<
Decoder
>
decoder
=
DecoderFactory
:
:
CreateMetadataDecoder
(
mDecoderType
this
mSourceBuffer
mRequestedSampleSize
)
;
if
(
!
decoder
)
{
return
NS_ERROR_FAILURE
;
}
LaunchDecoder
(
decoder
this
aFlags
mHasSourceData
)
;
return
NS_OK
;
}
void
RasterImage
:
:
RecoverFromInvalidFrames
(
const
IntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
mHasSize
)
{
return
;
}
NS_WARNING
(
"
A
RasterImage
'
s
frames
became
invalid
.
Attempting
to
recover
.
.
.
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
mLockCount
>
0
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
if
(
mAnim
)
{
Decode
(
mSize
aFlags
|
FLAG_SYNC_DECODE
)
;
ResetAnimation
(
)
;
return
;
}
Decode
(
aSize
aFlags
)
;
}
static
bool
HaveSkia
(
)
{
#
ifdef
MOZ_ENABLE_SKIA
return
true
;
#
else
return
false
;
#
endif
}
bool
RasterImage
:
:
CanDownscaleDuringDecode
(
const
IntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
mHasSize
|
|
mTransient
|
|
!
HaveSkia
(
)
|
|
!
gfxPrefs
:
:
ImageDownscaleDuringDecodeEnabled
(
)
|
|
!
(
aFlags
&
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
)
)
{
return
false
;
}
if
(
mAnim
)
{
return
false
;
}
if
(
aSize
.
width
>
=
mSize
.
width
|
|
aSize
.
height
>
=
mSize
.
height
)
{
return
false
;
}
if
(
aSize
.
width
<
1
|
|
aSize
.
height
<
1
)
{
return
false
;
}
if
(
!
SurfaceCache
:
:
CanHold
(
aSize
)
)
{
return
false
;
}
return
true
;
}
DrawResult
RasterImage
:
:
DrawInternal
(
DrawableFrameRef
&
&
aFrameRef
gfxContext
*
aContext
const
IntSize
&
aSize
const
ImageRegion
&
aRegion
Filter
aFilter
uint32_t
aFlags
)
{
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aContext
)
;
ImageRegion
region
(
aRegion
)
;
bool
frameIsComplete
=
aFrameRef
-
>
IsImageComplete
(
)
;
IntSize
finalSize
=
aFrameRef
-
>
GetImageSize
(
)
;
bool
couldRedecodeForBetterFrame
=
false
;
if
(
finalSize
!
=
aSize
)
{
gfx
:
:
Size
scale
(
double
(
aSize
.
width
)
/
finalSize
.
width
double
(
aSize
.
height
)
/
finalSize
.
height
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scale
.
width
scale
.
height
)
)
;
region
.
Scale
(
1
.
0
/
scale
.
width
1
.
0
/
scale
.
height
)
;
couldRedecodeForBetterFrame
=
CanDownscaleDuringDecode
(
aSize
aFlags
)
;
}
if
(
!
aFrameRef
-
>
Draw
(
aContext
region
aFilter
aFlags
)
)
{
RecoverFromInvalidFrames
(
aSize
aFlags
)
;
return
DrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
!
frameIsComplete
)
{
return
DrawResult
:
:
INCOMPLETE
;
}
if
(
couldRedecodeForBetterFrame
)
{
return
DrawResult
:
:
WRONG_SIZE
;
}
return
DrawResult
:
:
SUCCESS
;
}
NS_IMETHODIMP_
(
DrawResult
)
RasterImage
:
:
Draw
(
gfxContext
*
aContext
const
IntSize
&
aSize
const
ImageRegion
&
aRegion
uint32_t
aWhichFrame
Filter
aFilter
const
Maybe
<
SVGImageContext
>
&
uint32_t
aFlags
)
{
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
DrawResult
:
:
BAD_ARGS
;
}
if
(
mError
)
{
return
DrawResult
:
:
BAD_IMAGE
;
}
if
(
ToSurfaceFlags
(
aFlags
)
!
=
DefaultSurfaceFlags
(
)
)
{
return
DrawResult
:
:
BAD_ARGS
;
}
if
(
!
aContext
)
{
return
DrawResult
:
:
BAD_ARGS
;
}
if
(
IsUnlocked
(
)
&
&
mProgressTracker
)
{
mProgressTracker
-
>
OnUnlockedDraw
(
)
;
}
uint32_t
flags
=
aFilter
=
=
Filter
:
:
GOOD
?
aFlags
:
aFlags
&
~
FLAG_HIGH_QUALITY_SCALING
;
DrawableFrameRef
ref
=
LookupFrame
(
GetRequestedFrameIndex
(
aWhichFrame
)
aSize
flags
)
;
if
(
!
ref
)
{
if
(
mDrawStartTime
.
IsNull
(
)
)
{
mDrawStartTime
=
TimeStamp
:
:
Now
(
)
;
}
return
DrawResult
:
:
NOT_READY
;
}
bool
shouldRecordTelemetry
=
!
mDrawStartTime
.
IsNull
(
)
&
&
ref
-
>
IsImageComplete
(
)
;
auto
result
=
DrawInternal
(
Move
(
ref
)
aContext
aSize
aRegion
aFilter
flags
)
;
if
(
shouldRecordTelemetry
)
{
TimeDuration
drawLatency
=
TimeStamp
:
:
Now
(
)
-
mDrawStartTime
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_ON_DRAW_LATENCY
int32_t
(
drawLatency
.
ToMicroseconds
(
)
)
)
;
mDrawStartTime
=
TimeStamp
(
)
;
}
return
result
;
}
NS_IMETHODIMP
RasterImage
:
:
LockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
to
encourage
serialization
with
UnlockImage
"
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
mLockCount
+
+
;
if
(
mLockCount
=
=
1
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
UnlockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
to
encourage
serialization
with
LockImage
"
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mLockCount
>
0
"
Calling
UnlockImage
with
mLockCount
=
=
0
!
"
)
;
if
(
mLockCount
=
=
0
)
{
return
NS_ERROR_ABORT
;
}
mLockCount
-
-
;
if
(
mLockCount
=
=
0
)
{
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
RequestDiscard
(
)
{
if
(
mDiscardable
&
&
mLockCount
=
=
0
&
&
CanDiscard
(
)
)
{
Discard
(
)
;
}
return
NS_OK
;
}
void
RasterImage
:
:
DoError
(
)
{
if
(
mError
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
)
{
HandleErrorWorker
:
:
DispatchIfNeeded
(
this
)
;
return
;
}
mError
=
true
;
if
(
mAnimating
)
{
StopAnimation
(
)
;
}
mAnim
=
nullptr
;
mLockCount
=
0
;
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
NotifyProgress
(
NoProgress
IntRect
(
0
0
mSize
.
width
mSize
.
height
)
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Error
(
"
RasterImage
:
[
this
=
%
p
]
Error
detected
for
image
\
n
"
this
)
)
;
}
void
RasterImage
:
:
HandleErrorWorker
:
:
DispatchIfNeeded
(
RasterImage
*
aImage
)
{
RefPtr
<
HandleErrorWorker
>
worker
=
new
HandleErrorWorker
(
aImage
)
;
NS_DispatchToMainThread
(
worker
)
;
}
RasterImage
:
:
HandleErrorWorker
:
:
HandleErrorWorker
(
RasterImage
*
aImage
)
:
mImage
(
aImage
)
{
MOZ_ASSERT
(
mImage
"
Should
have
image
"
)
;
}
NS_IMETHODIMP
RasterImage
:
:
HandleErrorWorker
:
:
Run
(
)
{
mImage
-
>
DoError
(
)
;
return
NS_OK
;
}
bool
RasterImage
:
:
ShouldAnimate
(
)
{
return
ImageResource
:
:
ShouldAnimate
(
)
&
&
GetNumFrames
(
)
>
=
2
&
&
!
mAnimationFinished
;
}
#
ifdef
DEBUG
NS_IMETHODIMP
RasterImage
:
:
GetFramesNotified
(
uint32_t
*
aFramesNotified
)
{
NS_ENSURE_ARG_POINTER
(
aFramesNotified
)
;
*
aFramesNotified
=
mFramesNotified
;
return
NS_OK
;
}
#
endif
void
RasterImage
:
:
NotifyProgress
(
Progress
aProgress
const
IntRect
&
aInvalidRect
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
RasterImage
>
image
(
this
)
;
bool
wasDefaultFlags
=
aSurfaceFlags
=
=
DefaultSurfaceFlags
(
)
;
if
(
!
aInvalidRect
.
IsEmpty
(
)
&
&
wasDefaultFlags
)
{
UpdateImageContainer
(
)
;
}
image
-
>
mProgressTracker
-
>
SyncNotifyProgress
(
aProgress
aInvalidRect
)
;
}
void
RasterImage
:
:
FinalizeDecoder
(
Decoder
*
aDecoder
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aDecoder
)
;
MOZ_ASSERT
(
aDecoder
-
>
HasError
(
)
|
|
!
aDecoder
-
>
InFrame
(
)
"
Finalizing
a
decoder
in
the
middle
of
a
frame
"
)
;
bool
wasMetadata
=
aDecoder
-
>
IsMetadataDecode
(
)
;
bool
done
=
aDecoder
-
>
GetDecodeDone
(
)
;
if
(
aDecoder
-
>
ShouldReportError
(
)
&
&
!
aDecoder
-
>
WasAborted
(
)
)
{
ReportDecoderError
(
aDecoder
)
;
}
bool
metadataOK
=
SetMetadata
(
aDecoder
-
>
GetImageMetadata
(
)
wasMetadata
)
;
if
(
!
metadataOK
)
{
aDecoder
-
>
TakeProgress
(
)
;
aDecoder
-
>
TakeInvalidRect
(
)
;
RecoverFromInvalidFrames
(
mSize
FromSurfaceFlags
(
aDecoder
-
>
GetSurfaceFlags
(
)
)
)
;
return
;
}
MOZ_ASSERT
(
mError
|
|
mHasSize
|
|
!
aDecoder
-
>
HasSize
(
)
"
SetMetadata
should
'
ve
gotten
a
size
"
)
;
if
(
!
wasMetadata
&
&
aDecoder
-
>
GetDecodeDone
(
)
&
&
!
aDecoder
-
>
WasAborted
(
)
)
{
mHasBeenDecoded
=
true
;
if
(
mAnim
)
{
mAnim
-
>
SetDoneDecoding
(
true
)
;
}
}
NotifyProgress
(
aDecoder
-
>
TakeProgress
(
)
aDecoder
-
>
TakeInvalidRect
(
)
aDecoder
-
>
GetSurfaceFlags
(
)
)
;
if
(
!
wasMetadata
&
&
aDecoder
-
>
ChunkCount
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_CHUNKS
aDecoder
-
>
ChunkCount
(
)
)
;
}
if
(
done
)
{
if
(
!
wasMetadata
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_TIME
int32_t
(
aDecoder
-
>
DecodeTime
(
)
.
ToMicroseconds
(
)
)
)
;
Telemetry
:
:
ID
id
=
aDecoder
-
>
SpeedHistogram
(
)
;
if
(
id
<
Telemetry
:
:
HistogramCount
)
{
int32_t
KBps
=
int32_t
(
aDecoder
-
>
BytesDecoded
(
)
/
(
1024
*
aDecoder
-
>
DecodeTime
(
)
.
ToSeconds
(
)
)
)
;
Telemetry
:
:
Accumulate
(
id
KBps
)
;
}
}
if
(
aDecoder
-
>
HasError
(
)
&
&
!
aDecoder
-
>
WasAborted
(
)
)
{
DoError
(
)
;
}
else
if
(
wasMetadata
&
&
!
mHasSize
)
{
DoError
(
)
;
}
if
(
mLoadProgress
&
&
wasMetadata
)
{
NotifyForLoadEvent
(
*
mLoadProgress
)
;
mLoadProgress
=
Nothing
(
)
;
NotifyProgress
(
FLAG_ONLOAD_UNBLOCKED
)
;
}
}
if
(
done
&
&
wasMetadata
&
&
mWantFullDecode
)
{
mWantFullDecode
=
false
;
RequestDecodeForSize
(
mSize
DECODE_FLAGS_DEFAULT
)
;
}
}
void
RasterImage
:
:
ReportDecoderError
(
Decoder
*
aDecoder
)
{
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
nsCOMPtr
<
nsIScriptError
>
errorObject
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
;
if
(
consoleService
&
&
errorObject
&
&
!
aDecoder
-
>
HasDecoderError
(
)
)
{
nsAutoString
msg
(
NS_LITERAL_STRING
(
"
Image
corrupt
or
truncated
.
"
)
)
;
nsAutoString
src
;
if
(
GetURI
(
)
)
{
nsCString
uri
;
if
(
GetURI
(
)
-
>
GetSpecTruncatedTo1k
(
uri
)
=
=
ImageURL
:
:
TruncatedTo1k
)
{
msg
+
=
NS_LITERAL_STRING
(
"
URI
in
this
note
truncated
due
to
length
.
"
)
;
}
src
=
NS_ConvertUTF8toUTF16
(
uri
)
;
}
if
(
NS_SUCCEEDED
(
errorObject
-
>
InitWithWindowID
(
msg
src
EmptyString
(
)
0
0
nsIScriptError
:
:
errorFlag
"
Image
"
InnerWindowID
(
)
)
)
)
{
consoleService
-
>
LogMessage
(
errorObject
)
;
}
}
}
already_AddRefed
<
imgIContainer
>
RasterImage
:
:
Unwrap
(
)
{
nsCOMPtr
<
imgIContainer
>
self
(
this
)
;
return
self
.
forget
(
)
;
}
void
RasterImage
:
:
PropagateUseCounters
(
nsIDocument
*
)
{
}
IntSize
RasterImage
:
:
OptimalImageSizeForDest
(
const
gfxSize
&
aDest
uint32_t
aWhichFrame
Filter
aFilter
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aDest
.
width
>
=
0
|
|
ceil
(
aDest
.
width
)
<
=
INT32_MAX
|
|
aDest
.
height
>
=
0
|
|
ceil
(
aDest
.
height
)
<
=
INT32_MAX
"
Unexpected
destination
size
"
)
;
if
(
mSize
.
IsEmpty
(
)
|
|
aDest
.
IsEmpty
(
)
)
{
return
IntSize
(
0
0
)
;
}
IntSize
destSize
(
ceil
(
aDest
.
width
)
ceil
(
aDest
.
height
)
)
;
if
(
aFilter
=
=
Filter
:
:
GOOD
&
&
CanDownscaleDuringDecode
(
destSize
aFlags
)
)
{
return
destSize
;
}
return
mSize
;
}
}
}
