#
include
"
RasterImage
.
h
"
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
DecodePool
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
FrameAnimator
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
ImageLogging
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
OrientedImage
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SurfaceCache
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SizeOfState
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Scale
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsProperties
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
WindowRenderer
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
using
namespace
layers
;
namespace
image
{
using
std
:
:
ceil
;
using
std
:
:
min
;
#
ifndef
DEBUG
NS_IMPL_ISUPPORTS
(
RasterImage
imgIContainer
)
#
else
NS_IMPL_ISUPPORTS
(
RasterImage
imgIContainer
imgIContainerDebug
)
#
endif
RasterImage
:
:
RasterImage
(
nsIURI
*
aURI
)
:
ImageResource
(
aURI
)
mSize
(
0
0
)
mLockCount
(
0
)
mDecoderType
(
DecoderType
:
:
UNKNOWN
)
mDecodeCount
(
0
)
#
ifdef
DEBUG
mFramesNotified
(
0
)
#
endif
mSourceBuffer
(
MakeNotNull
<
SourceBuffer
*
>
(
)
)
{
}
RasterImage
:
:
~
RasterImage
(
)
{
if
(
!
mSourceBuffer
-
>
IsComplete
(
)
)
{
mSourceBuffer
-
>
Complete
(
NS_ERROR_ABORT
)
;
}
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_COUNT
mDecodeCount
)
;
}
nsresult
RasterImage
:
:
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
{
if
(
mInitialized
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT_IF
(
aFlags
&
INIT_FLAG_TRANSIENT
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
)
;
StoreDiscardable
(
!
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
)
;
StoreWantFullDecode
(
!
!
(
aFlags
&
INIT_FLAG_DECODE_IMMEDIATELY
)
)
;
StoreTransient
(
!
!
(
aFlags
&
INIT_FLAG_TRANSIENT
)
)
;
StoreSyncLoad
(
!
!
(
aFlags
&
INIT_FLAG_SYNC_LOAD
)
)
;
NS_ENSURE_ARG_POINTER
(
aMimeType
)
;
mDecoderType
=
DecoderFactory
:
:
GetDecoderType
(
aMimeType
)
;
if
(
mDecoderType
=
=
DecoderType
:
:
UNKNOWN
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
LoadDiscardable
(
)
)
{
mLockCount
+
+
;
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
mDefaultDecoderFlags
=
DecoderFactory
:
:
GetDefaultDecoderFlagsForType
(
mDecoderType
)
;
mInitialized
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
RasterImage
:
:
RequestRefresh
(
const
TimeStamp
&
aTime
)
{
if
(
HadRecentRefresh
(
aTime
)
)
{
return
;
}
EvaluateAnimation
(
)
;
if
(
!
mAnimating
)
{
return
;
}
RefreshResult
res
;
if
(
mAnimationState
)
{
MOZ_ASSERT
(
mFrameAnimator
)
;
res
=
mFrameAnimator
-
>
RequestRefresh
(
*
mAnimationState
aTime
)
;
}
#
ifdef
DEBUG
if
(
res
.
mFrameAdvanced
)
{
mFramesNotified
+
+
;
}
#
endif
if
(
!
res
.
mDirtyRect
.
IsEmpty
(
)
|
|
res
.
mFrameAdvanced
)
{
auto
dirtyRect
=
OrientedIntRect
:
:
FromUnknownRect
(
res
.
mDirtyRect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
if
(
res
.
mAnimationFinished
)
{
StoreAnimationFinished
(
true
)
;
EvaluateAnimation
(
)
;
}
}
NS_IMETHODIMP
RasterImage
:
:
GetWidth
(
int32_t
*
aWidth
)
{
NS_ENSURE_ARG_POINTER
(
aWidth
)
;
if
(
mError
)
{
*
aWidth
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aWidth
=
mSize
.
width
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetHeight
(
int32_t
*
aHeight
)
{
NS_ENSURE_ARG_POINTER
(
aHeight
)
;
if
(
mError
)
{
*
aHeight
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aHeight
=
mSize
.
height
;
return
NS_OK
;
}
void
RasterImage
:
:
MediaFeatureValuesChangedAllDocuments
(
const
mozilla
:
:
MediaFeatureChange
&
aChange
)
{
}
nsresult
RasterImage
:
:
GetNativeSizes
(
nsTArray
<
IntSize
>
&
aNativeSizes
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
aNativeSizes
.
Clear
(
)
;
if
(
mNativeSizes
.
IsEmpty
(
)
)
{
aNativeSizes
.
AppendElement
(
mSize
.
ToUnknownSize
(
)
)
;
}
else
{
for
(
const
auto
&
size
:
mNativeSizes
)
{
aNativeSizes
.
AppendElement
(
size
.
ToUnknownSize
(
)
)
;
}
}
return
NS_OK
;
}
size_t
RasterImage
:
:
GetNativeSizesLength
(
)
{
if
(
mError
|
|
!
LoadHasSize
(
)
)
{
return
0
;
}
if
(
mNativeSizes
.
IsEmpty
(
)
)
{
return
1
;
}
return
mNativeSizes
.
Length
(
)
;
}
NS_IMETHODIMP
RasterImage
:
:
GetIntrinsicSize
(
nsSize
*
aSize
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
*
aSize
=
nsSize
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
mSize
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
mSize
.
height
)
)
;
return
NS_OK
;
}
Maybe
<
AspectRatio
>
RasterImage
:
:
GetIntrinsicRatio
(
)
{
if
(
mError
)
{
return
Nothing
(
)
;
}
return
Some
(
AspectRatio
:
:
FromSize
(
mSize
.
width
mSize
.
height
)
)
;
}
NS_IMETHODIMP_
(
Orientation
)
RasterImage
:
:
GetOrientation
(
)
{
return
mOrientation
;
}
NS_IMETHODIMP_
(
Resolution
)
RasterImage
:
:
GetResolution
(
)
{
return
mResolution
;
}
NS_IMETHODIMP
RasterImage
:
:
GetType
(
uint16_t
*
aType
)
{
NS_ENSURE_ARG_POINTER
(
aType
)
;
*
aType
=
imgIContainer
:
:
TYPE_RASTER
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetProviderId
(
uint32_t
*
aId
)
{
NS_ENSURE_ARG_POINTER
(
aId
)
;
*
aId
=
ImageResource
:
:
GetImageProviderId
(
)
;
return
NS_OK
;
}
LookupResult
RasterImage
:
:
LookupFrameInternal
(
const
OrientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
aMarkUsed
)
{
if
(
mAnimationState
&
&
aPlaybackType
=
=
PlaybackType
:
:
eAnimated
)
{
MOZ_ASSERT
(
mFrameAnimator
)
;
MOZ_ASSERT
(
ToSurfaceFlags
(
aFlags
)
=
=
DefaultSurfaceFlags
(
)
"
Can
'
t
composite
frames
with
non
-
default
surface
flags
"
)
;
return
mFrameAnimator
-
>
GetCompositedFrame
(
*
mAnimationState
aMarkUsed
)
;
}
SurfaceFlags
surfaceFlags
=
ToSurfaceFlags
(
aFlags
)
;
if
(
(
aFlags
&
FLAG_SYNC_DECODE
)
|
|
!
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
{
return
SurfaceCache
:
:
Lookup
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
.
ToUnknownSize
(
)
surfaceFlags
PlaybackType
:
:
eStatic
)
aMarkUsed
)
;
}
return
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
.
ToUnknownSize
(
)
surfaceFlags
PlaybackType
:
:
eStatic
)
aMarkUsed
)
;
}
LookupResult
RasterImage
:
:
LookupFrame
(
const
OrientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
aMarkUsed
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsOpaque
(
)
)
{
aFlags
&
=
~
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
;
}
OrientedIntSize
requestedSize
=
CanDownscaleDuringDecode
(
aSize
aFlags
)
?
aSize
:
mSize
;
if
(
requestedSize
.
IsEmpty
(
)
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
LookupResult
result
=
LookupFrameInternal
(
requestedSize
aFlags
aPlaybackType
aMarkUsed
)
;
if
(
!
result
&
&
!
LoadHasSize
(
)
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
const
bool
syncDecode
=
aFlags
&
FLAG_SYNC_DECODE
;
const
bool
avoidRedecode
=
aFlags
&
FLAG_AVOID_REDECODE_FOR_SIZE
;
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
|
|
(
result
.
Type
(
)
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
&
&
!
avoidRedecode
)
|
|
(
syncDecode
&
&
!
avoidRedecode
&
&
!
result
&
&
LoadAllSourceData
(
)
)
)
{
MOZ_ASSERT
(
aPlaybackType
!
=
PlaybackType
:
:
eAnimated
|
|
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
|
|
!
mAnimationState
|
|
mAnimationState
-
>
KnownFrameCount
(
)
<
1
"
Animated
frames
should
be
locked
"
)
;
if
(
!
result
.
SuggestedSize
(
)
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
syncDecode
&
&
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
;
requestedSize
=
OrientedIntSize
:
:
FromUnknownSize
(
result
.
SuggestedSize
(
)
)
;
}
bool
ranSync
=
false
failed
=
false
;
Decode
(
requestedSize
aFlags
aPlaybackType
ranSync
failed
)
;
if
(
failed
)
{
result
.
SetFailedToRequestDecode
(
)
;
}
if
(
ranSync
|
|
syncDecode
)
{
result
=
LookupFrameInternal
(
requestedSize
aFlags
aPlaybackType
aMarkUsed
)
;
}
}
if
(
!
result
)
{
return
result
;
}
if
(
LoadAllSourceData
(
)
&
&
syncDecode
)
{
result
.
Surface
(
)
-
>
WaitUntilFinished
(
)
;
}
if
(
aFlags
&
(
FLAG_SYNC_DECODE
|
FLAG_SYNC_DECODE_IF_FAST
)
&
&
result
.
Surface
(
)
-
>
IsAborted
(
)
)
{
DrawableSurface
tmp
=
std
:
:
move
(
result
.
Surface
(
)
)
;
return
result
;
}
return
result
;
}
bool
RasterImage
:
:
IsOpaque
(
)
{
if
(
mError
)
{
return
false
;
}
Progress
progress
=
mProgressTracker
-
>
GetProgress
(
)
;
if
(
!
(
progress
&
FLAG_DECODE_COMPLETE
)
)
{
return
false
;
}
return
!
(
progress
&
FLAG_HAS_TRANSPARENCY
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
WillDrawOpaqueNow
(
)
{
if
(
!
IsOpaque
(
)
)
{
return
false
;
}
if
(
mAnimationState
)
{
if
(
!
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
{
return
true
;
}
else
{
if
(
mAnimationState
-
>
GetCompositedFrameInvalid
(
)
)
{
return
false
;
}
}
}
if
(
mLockCount
=
=
0
)
{
return
false
;
}
LookupResult
result
=
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
RasterSurfaceKey
(
mSize
.
ToUnknownSize
(
)
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eStatic
)
false
)
;
MatchType
matchType
=
result
.
Type
(
)
;
if
(
matchType
=
=
MatchType
:
:
NOT_FOUND
|
|
matchType
=
=
MatchType
:
:
PENDING
|
|
!
result
.
Surface
(
)
-
>
IsFinished
(
)
)
{
return
false
;
}
return
true
;
}
void
RasterImage
:
:
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
{
MOZ_ASSERT
(
mProgressTracker
)
;
bool
animatedFramesDiscarded
=
mAnimationState
&
&
aSurfaceKey
.
Playback
(
)
=
=
PlaybackType
:
:
eAnimated
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
if
(
mProgressTracker
)
{
eventTarget
=
mProgressTracker
-
>
GetEventTarget
(
)
;
}
else
{
eventTarget
=
do_GetMainThread
(
)
;
}
RefPtr
<
RasterImage
>
image
=
this
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NS_NewRunnableFunction
(
"
RasterImage
:
:
OnSurfaceDiscarded
"
[
=
]
(
)
-
>
void
{
image
-
>
OnSurfaceDiscardedInternal
(
animatedFramesDiscarded
)
;
}
)
;
eventTarget
-
>
Dispatch
(
ev
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RasterImage
:
:
OnSurfaceDiscardedInternal
(
bool
aAnimatedFramesDiscarded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aAnimatedFramesDiscarded
&
&
mAnimationState
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
;
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
mSize
.
ToUnknownSize
(
)
)
;
auto
dirtyRect
=
OrientedIntRect
:
:
FromUnknownRect
(
rect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
if
(
mProgressTracker
)
{
mProgressTracker
-
>
OnDiscard
(
)
;
}
}
NS_IMETHODIMP
RasterImage
:
:
GetAnimated
(
bool
*
aAnimated
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_ARG_POINTER
(
aAnimated
)
;
if
(
mAnimationState
)
{
*
aAnimated
=
true
;
return
NS_OK
;
}
if
(
!
LoadHasBeenDecoded
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aAnimated
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
int32_t
)
RasterImage
:
:
GetFirstFrameDelay
(
)
{
if
(
mError
)
{
return
-
1
;
}
bool
animated
=
false
;
if
(
NS_FAILED
(
GetAnimated
(
&
animated
)
)
|
|
!
animated
)
{
return
-
1
;
}
MOZ_ASSERT
(
mAnimationState
"
Animated
images
should
have
an
AnimationState
"
)
;
return
mAnimationState
-
>
FirstFrameTimeout
(
)
.
AsEncodedValueDeprecated
(
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
RasterImage
:
:
GetFrame
(
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
return
GetFrameAtSize
(
mSize
.
ToUnknownSize
(
)
aWhichFrame
aFlags
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
RasterImage
:
:
GetFrameAtSize
(
const
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
)
;
AutoProfilerImagePaintMarker
PROFILER_RAII
(
this
)
;
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
if
(
aSize
.
IsEmpty
(
)
|
|
aWhichFrame
>
FRAME_MAX_VALUE
|
|
mError
)
{
return
nullptr
;
}
auto
size
=
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
;
LookupResult
result
=
LookupFrame
(
size
aFlags
ToPlaybackType
(
aWhichFrame
)
true
)
;
if
(
!
result
)
{
return
nullptr
;
}
return
result
.
Surface
(
)
-
>
GetSourceSurface
(
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
IsImageContainerAvailable
(
WindowRenderer
*
aRenderer
uint32_t
aFlags
)
{
return
LoadHasSize
(
)
;
}
NS_IMETHODIMP_
(
ImgDrawResult
)
RasterImage
:
:
GetImageProvider
(
WindowRenderer
*
aRenderer
const
gfx
:
:
IntSize
&
aSize
const
SVGImageContext
&
aSVGContext
const
Maybe
<
ImageIntRegion
>
&
aRegion
uint32_t
aFlags
WebRenderImageProvider
*
*
aProvider
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aRenderer
)
;
if
(
mError
)
{
return
ImgDrawResult
:
:
BAD_IMAGE
;
}
if
(
!
LoadHasSize
(
)
)
{
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
aSize
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
int32_t
maxTextureSize
=
aRenderer
-
>
GetMaxTextureSize
(
)
;
if
(
min
(
mSize
.
width
aSize
.
width
)
>
maxTextureSize
|
|
min
(
mSize
.
height
aSize
.
height
)
>
maxTextureSize
)
{
return
ImgDrawResult
:
:
NOT_SUPPORTED
;
}
AutoProfilerImagePaintMarker
PROFILER_RAII
(
this
)
;
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
LookupResult
result
=
LookupFrame
(
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
aFlags
PlaybackType
:
:
eAnimated
true
)
;
if
(
!
result
)
{
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
!
result
.
Surface
(
)
-
>
IsFinished
(
)
)
{
result
.
Surface
(
)
.
TakeProvider
(
aProvider
)
;
return
ImgDrawResult
:
:
INCOMPLETE
;
}
result
.
Surface
(
)
.
TakeProvider
(
aProvider
)
;
switch
(
result
.
Type
(
)
)
{
case
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
:
case
MatchType
:
:
SUBSTITUTE_BECAUSE_PENDING
:
return
ImgDrawResult
:
:
WRONG_SIZE
;
default
:
return
ImgDrawResult
:
:
SUCCESS
;
}
}
size_t
RasterImage
:
:
SizeOfSourceWithComputedFallback
(
SizeOfState
&
aState
)
const
{
return
mSourceBuffer
-
>
SizeOfIncludingThisWithComputedFallback
(
aState
.
mMallocSizeOf
)
;
}
bool
RasterImage
:
:
SetMetadata
(
const
ImageMetadata
&
aMetadata
bool
aFromMetadataDecode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
true
;
}
mResolution
=
aMetadata
.
GetResolution
(
)
;
if
(
aMetadata
.
HasSize
(
)
)
{
auto
metadataSize
=
aMetadata
.
GetSize
(
)
;
if
(
metadataSize
.
width
<
0
|
|
metadataSize
.
height
<
0
)
{
NS_WARNING
(
"
Image
has
negative
intrinsic
size
"
)
;
DoError
(
)
;
return
true
;
}
MOZ_ASSERT
(
aMetadata
.
HasOrientation
(
)
)
;
Orientation
orientation
=
aMetadata
.
GetOrientation
(
)
;
if
(
LoadHasSize
(
)
&
&
(
metadataSize
!
=
mSize
|
|
orientation
!
=
mOrientation
)
)
{
NS_WARNING
(
"
Image
changed
size
or
orientation
on
redecode
!
"
"
This
should
not
happen
!
"
)
;
DoError
(
)
;
return
true
;
}
mOrientation
=
orientation
;
mSize
=
metadataSize
;
mNativeSizes
.
Clear
(
)
;
for
(
const
auto
&
nativeSize
:
aMetadata
.
GetNativeSizes
(
)
)
{
mNativeSizes
.
AppendElement
(
nativeSize
)
;
}
StoreHasSize
(
true
)
;
}
if
(
LoadHasSize
(
)
&
&
aMetadata
.
HasAnimation
(
)
&
&
!
mAnimationState
)
{
mAnimationState
.
emplace
(
mAnimationMode
)
;
mFrameAnimator
=
MakeUnique
<
FrameAnimator
>
(
this
mSize
.
ToUnknownSize
(
)
)
;
if
(
!
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
{
LockImage
(
)
;
}
if
(
!
aFromMetadataDecode
)
{
return
false
;
}
}
if
(
mAnimationState
)
{
mAnimationState
-
>
SetLoopCount
(
aMetadata
.
GetLoopCount
(
)
)
;
mAnimationState
-
>
SetFirstFrameTimeout
(
aMetadata
.
GetFirstFrameTimeout
(
)
)
;
if
(
aMetadata
.
HasLoopLength
(
)
)
{
mAnimationState
-
>
SetLoopLength
(
aMetadata
.
GetLoopLength
(
)
)
;
}
if
(
aMetadata
.
HasFirstFrameRefreshArea
(
)
)
{
mAnimationState
-
>
SetFirstFrameRefreshArea
(
aMetadata
.
GetFirstFrameRefreshArea
(
)
)
;
}
}
if
(
aMetadata
.
HasHotspot
(
)
)
{
MOZ_ASSERT
(
mOrientation
.
IsIdentity
(
)
"
Would
need
to
orient
hotspot
point
"
)
;
auto
hotspot
=
aMetadata
.
GetHotspot
(
)
;
mHotspot
.
x
=
std
:
:
max
(
std
:
:
min
(
hotspot
.
x
.
value
mSize
.
width
-
1
)
0
)
;
mHotspot
.
y
=
std
:
:
max
(
std
:
:
min
(
hotspot
.
y
.
value
mSize
.
height
-
1
)
0
)
;
}
return
true
;
}
NS_IMETHODIMP
RasterImage
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
if
(
mAnimationState
)
{
mAnimationState
-
>
SetAnimationMode
(
aAnimationMode
)
;
}
return
SetAnimationModeInternal
(
aAnimationMode
)
;
}
nsresult
RasterImage
:
:
StartAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
ShouldAnimate
(
)
"
Should
not
animate
!
"
)
;
StorePendingAnimation
(
!
mAnimationState
|
|
mAnimationState
-
>
KnownFrameCount
(
)
<
1
)
;
if
(
LoadPendingAnimation
(
)
)
{
return
NS_OK
;
}
if
(
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
=
=
0
&
&
mAnimationState
-
>
FirstFrameTimeout
(
)
=
=
FrameTimeout
:
:
Forever
(
)
)
{
StoreAnimationFinished
(
true
)
;
return
NS_ERROR_ABORT
;
}
mAnimationState
-
>
InitAnimationFrameTimeIfNecessary
(
)
;
return
NS_OK
;
}
nsresult
RasterImage
:
:
StopAnimation
(
)
{
MOZ_ASSERT
(
mAnimating
"
Should
be
animating
!
"
)
;
nsresult
rv
=
NS_OK
;
if
(
mError
)
{
rv
=
NS_ERROR_FAILURE
;
}
else
{
mAnimationState
-
>
SetAnimationFrameTime
(
TimeStamp
(
)
)
;
}
mAnimating
=
false
;
return
rv
;
}
NS_IMETHODIMP
RasterImage
:
:
ResetAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
StorePendingAnimation
(
false
)
;
if
(
mAnimationMode
=
=
kDontAnimMode
|
|
!
mAnimationState
|
|
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
=
=
0
)
{
return
NS_OK
;
}
StoreAnimationFinished
(
false
)
;
if
(
mAnimating
)
{
StopAnimation
(
)
;
}
MOZ_ASSERT
(
mAnimationState
"
Should
have
AnimationState
"
)
;
MOZ_ASSERT
(
mFrameAnimator
"
Should
have
FrameAnimator
"
)
;
mFrameAnimator
-
>
ResetAnimation
(
*
mAnimationState
)
;
IntRect
area
=
mAnimationState
-
>
FirstFrameRefreshArea
(
)
;
NotifyProgress
(
NoProgress
OrientedIntRect
:
:
FromUnknownRect
(
area
)
)
;
EvaluateAnimation
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
RasterImage
:
:
SetAnimationStartTime
(
const
TimeStamp
&
aTime
)
{
if
(
mError
|
|
mAnimationMode
=
=
kDontAnimMode
|
|
mAnimating
|
|
!
mAnimationState
)
{
return
;
}
mAnimationState
-
>
SetAnimationFrameTime
(
aTime
)
;
}
NS_IMETHODIMP_
(
float
)
RasterImage
:
:
GetFrameIndex
(
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
"
Invalid
argument
"
)
;
return
(
aWhichFrame
=
=
FRAME_FIRST
|
|
!
mAnimationState
)
?
0
.
0f
:
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
;
}
NS_IMETHODIMP_
(
IntRect
)
RasterImage
:
:
GetImageSpaceInvalidationRect
(
const
IntRect
&
aRect
)
{
return
aRect
;
}
nsresult
RasterImage
:
:
OnImageDataComplete
(
nsIRequest
*
nsresult
aStatus
bool
aLastPart
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StoreAllSourceData
(
true
)
;
mSourceBuffer
-
>
Complete
(
aStatus
)
;
bool
canSyncDecodeMetadata
=
LoadSyncLoad
(
)
|
|
LoadTransient
(
)
|
|
DecodePool
:
:
NumberOfCores
(
)
<
2
;
if
(
canSyncDecodeMetadata
&
&
!
LoadHasSize
(
)
)
{
DecodeMetadata
(
FLAG_SYNC_DECODE
)
;
}
nsresult
finalStatus
=
mError
?
NS_ERROR_FAILURE
:
NS_OK
;
if
(
NS_FAILED
(
aStatus
)
)
{
finalStatus
=
aStatus
;
}
if
(
NS_FAILED
(
finalStatus
)
)
{
DoError
(
)
;
}
Progress
loadProgress
=
LoadCompleteProgress
(
aLastPart
mError
finalStatus
)
;
if
(
!
LoadHasSize
(
)
&
&
!
mError
)
{
MOZ_ASSERT
(
!
canSyncDecodeMetadata
"
Firing
load
async
after
metadata
sync
decode
?
"
)
;
mLoadProgress
=
Some
(
loadProgress
)
;
return
finalStatus
;
}
NotifyForLoadEvent
(
loadProgress
)
;
return
finalStatus
;
}
void
RasterImage
:
:
NotifyForLoadEvent
(
Progress
aProgress
)
{
MOZ_ASSERT
(
LoadHasSize
(
)
|
|
mError
"
Need
to
know
size
before
firing
load
event
"
)
;
MOZ_ASSERT
(
!
LoadHasSize
(
)
|
|
(
mProgressTracker
-
>
GetProgress
(
)
&
FLAG_SIZE_AVAILABLE
)
"
Should
have
notified
that
the
size
is
available
if
we
have
it
"
)
;
if
(
mError
)
{
aProgress
|
=
FLAG_HAS_ERROR
;
}
NotifyProgress
(
aProgress
)
;
}
nsresult
RasterImage
:
:
OnImageDataAvailable
(
nsIRequest
*
nsIInputStream
*
aInputStream
uint64_t
uint32_t
aCount
)
{
nsresult
rv
=
mSourceBuffer
-
>
AppendFromInputStream
(
aInputStream
aCount
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
LoadSomeSourceData
(
)
)
{
StoreSomeSourceData
(
true
)
;
if
(
!
LoadSyncLoad
(
)
)
{
rv
=
DecodeMetadata
(
DECODE_FLAGS_DEFAULT
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
DoError
(
)
;
}
return
rv
;
}
nsresult
RasterImage
:
:
SetSourceSizeHint
(
uint32_t
aSizeHint
)
{
if
(
aSizeHint
=
=
0
)
{
return
NS_OK
;
}
nsresult
rv
=
mSourceBuffer
-
>
ExpectLength
(
aSizeHint
)
;
if
(
rv
=
=
NS_ERROR_OUT_OF_MEMORY
)
{
rv
=
nsMemory
:
:
HeapMinimize
(
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
mSourceBuffer
-
>
ExpectLength
(
aSizeHint
)
;
}
}
return
rv
;
}
nsresult
RasterImage
:
:
GetHotspotX
(
int32_t
*
aX
)
{
*
aX
=
mHotspot
.
x
;
return
NS_OK
;
}
nsresult
RasterImage
:
:
GetHotspotY
(
int32_t
*
aY
)
{
*
aY
=
mHotspot
.
y
;
return
NS_OK
;
}
void
RasterImage
:
:
Discard
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
CanDiscard
(
)
"
Asked
to
discard
but
can
'
t
"
)
;
MOZ_ASSERT
(
!
mAnimationState
|
|
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
"
Asked
to
discard
for
animated
image
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
mAnimationState
)
{
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
mSize
.
ToUnknownSize
(
)
)
;
auto
dirtyRect
=
OrientedIntRect
:
:
FromUnknownRect
(
rect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
if
(
mProgressTracker
)
{
mProgressTracker
-
>
OnDiscard
(
)
;
}
}
bool
RasterImage
:
:
CanDiscard
(
)
{
return
LoadAllSourceData
(
)
&
&
(
!
mAnimationState
|
|
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
;
}
NS_IMETHODIMP
RasterImage
:
:
StartDecoding
(
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
LoadHasSize
(
)
)
{
StoreWantFullDecode
(
true
)
;
return
NS_OK
;
}
uint32_t
flags
=
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
|
FLAG_SYNC_DECODE_IF_FAST
|
FLAG_HIGH_QUALITY_SCALING
;
return
RequestDecodeForSize
(
mSize
.
ToUnknownSize
(
)
flags
aWhichFrame
)
;
}
bool
RasterImage
:
:
StartDecodingWithResult
(
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
if
(
mError
)
{
return
false
;
}
if
(
!
LoadHasSize
(
)
)
{
StoreWantFullDecode
(
true
)
;
return
false
;
}
uint32_t
flags
=
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
|
FLAG_SYNC_DECODE_IF_FAST
|
FLAG_HIGH_QUALITY_SCALING
;
LookupResult
result
=
RequestDecodeForSizeInternal
(
mSize
flags
aWhichFrame
)
;
DrawableSurface
surface
=
std
:
:
move
(
result
.
Surface
(
)
)
;
return
surface
&
&
surface
-
>
IsFinished
(
)
;
}
bool
RasterImage
:
:
HasDecodedPixels
(
)
{
LookupResult
result
=
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
RasterSurfaceKey
(
mSize
.
ToUnknownSize
(
)
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eStatic
)
false
)
;
MatchType
matchType
=
result
.
Type
(
)
;
if
(
matchType
=
=
MatchType
:
:
NOT_FOUND
|
|
matchType
=
=
MatchType
:
:
PENDING
|
|
!
bool
(
result
.
Surface
(
)
)
)
{
return
false
;
}
return
!
result
.
Surface
(
)
-
>
GetDecodedRect
(
)
.
IsEmpty
(
)
;
}
imgIContainer
:
:
DecodeResult
RasterImage
:
:
RequestDecodeWithResult
(
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
imgIContainer
:
:
DECODE_REQUEST_FAILED
;
}
uint32_t
flags
=
aFlags
|
FLAG_ASYNC_NOTIFY
;
LookupResult
result
=
RequestDecodeForSizeInternal
(
mSize
flags
aWhichFrame
)
;
DrawableSurface
surface
=
std
:
:
move
(
result
.
Surface
(
)
)
;
if
(
surface
&
&
surface
-
>
IsFinished
(
)
)
{
return
imgIContainer
:
:
DECODE_SURFACE_AVAILABLE
;
}
if
(
result
.
GetFailedToRequestDecode
(
)
)
{
return
imgIContainer
:
:
DECODE_REQUEST_FAILED
;
}
return
imgIContainer
:
:
DECODE_REQUESTED
;
}
NS_IMETHODIMP
RasterImage
:
:
RequestDecodeForSize
(
const
IntSize
&
aSize
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
RequestDecodeForSizeInternal
(
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
aFlags
aWhichFrame
)
;
return
NS_OK
;
}
LookupResult
RasterImage
:
:
RequestDecodeForSizeInternal
(
const
OrientedIntSize
&
aSize
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
if
(
mError
)
{
LookupResult
result
=
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
result
.
SetFailedToRequestDecode
(
)
;
return
result
;
}
if
(
!
LoadHasSize
(
)
)
{
StoreWantFullDecode
(
true
)
;
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
bool
shouldSyncDecodeIfFast
=
!
LoadHasBeenDecoded
(
)
&
&
(
aFlags
&
FLAG_SYNC_DECODE_IF_FAST
)
;
uint32_t
flags
=
shouldSyncDecodeIfFast
?
aFlags
:
aFlags
&
~
FLAG_SYNC_DECODE_IF_FAST
;
return
LookupFrame
(
aSize
flags
ToPlaybackType
(
aWhichFrame
)
false
)
;
}
static
bool
LaunchDecodingTask
(
IDecodingTask
*
aTask
RasterImage
*
aImage
uint32_t
aFlags
bool
aHaveSourceData
)
{
if
(
aHaveSourceData
)
{
nsCString
uri
(
aImage
-
>
GetURIString
(
)
)
;
if
(
aFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
{
DecodePool
:
:
Singleton
(
)
-
>
SyncRunIfPossible
(
aTask
uri
)
;
return
true
;
}
if
(
aFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
)
{
return
DecodePool
:
:
Singleton
(
)
-
>
SyncRunIfPreferred
(
aTask
uri
)
;
}
}
DecodePool
:
:
Singleton
(
)
-
>
AsyncRun
(
aTask
)
;
return
false
;
}
void
RasterImage
:
:
Decode
(
const
OrientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
&
aOutRanSync
bool
&
aOutFailed
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
aOutFailed
=
true
;
return
;
}
if
(
!
LoadHasSize
(
)
)
{
StoreWantFullDecode
(
true
)
;
return
;
}
SurfaceCache
:
:
UnlockEntries
(
ImageKey
(
this
)
)
;
DecoderFlags
decoderFlags
=
mDefaultDecoderFlags
;
if
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
{
decoderFlags
|
=
DecoderFlags
:
:
ASYNC_NOTIFY
;
}
if
(
LoadTransient
(
)
)
{
decoderFlags
|
=
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
;
}
if
(
LoadHasBeenDecoded
(
)
)
{
decoderFlags
|
=
DecoderFlags
:
:
IS_REDECODE
;
}
if
(
(
aFlags
&
FLAG_SYNC_DECODE
)
|
|
!
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
{
decoderFlags
|
=
DecoderFlags
:
:
CANNOT_SUBSTITUTE
;
}
SurfaceFlags
surfaceFlags
=
ToSurfaceFlags
(
aFlags
)
;
if
(
IsOpaque
(
)
)
{
surfaceFlags
&
=
~
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
;
}
RefPtr
<
IDecodingTask
>
task
;
nsresult
rv
;
bool
animated
=
mAnimationState
&
&
aPlaybackType
=
=
PlaybackType
:
:
eAnimated
;
if
(
animated
)
{
size_t
currentFrame
=
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
;
rv
=
DecoderFactory
:
:
CreateAnimationDecoder
(
mDecoderType
WrapNotNull
(
this
)
mSourceBuffer
mSize
.
ToUnknownSize
(
)
decoderFlags
surfaceFlags
currentFrame
getter_AddRefs
(
task
)
)
;
}
else
{
rv
=
DecoderFactory
:
:
CreateDecoder
(
mDecoderType
WrapNotNull
(
this
)
mSourceBuffer
mSize
.
ToUnknownSize
(
)
aSize
.
ToUnknownSize
(
)
decoderFlags
surfaceFlags
getter_AddRefs
(
task
)
)
;
}
if
(
rv
=
=
NS_ERROR_ALREADY_INITIALIZED
)
{
MOZ_ASSERT
(
!
task
)
;
aOutRanSync
=
true
;
return
;
}
if
(
animated
)
{
#
ifdef
DEBUG
IntRect
rect
=
#
endif
mAnimationState
-
>
UpdateState
(
this
mSize
.
ToUnknownSize
(
)
false
)
;
MOZ_ASSERT
(
rect
.
IsEmpty
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
!
task
)
;
aOutFailed
=
true
;
return
;
}
MOZ_ASSERT
(
task
)
;
mDecodeCount
+
+
;
aOutRanSync
=
LaunchDecodingTask
(
task
this
aFlags
LoadAllSourceData
(
)
)
;
}
NS_IMETHODIMP
RasterImage
:
:
DecodeMetadata
(
uint32_t
aFlags
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
LoadHasSize
(
)
"
Should
not
do
unnecessary
metadata
decodes
"
)
;
RefPtr
<
IDecodingTask
>
task
=
DecoderFactory
:
:
CreateMetadataDecoder
(
mDecoderType
WrapNotNull
(
this
)
mDefaultDecoderFlags
mSourceBuffer
)
;
if
(
!
task
)
{
return
NS_ERROR_FAILURE
;
}
LaunchDecodingTask
(
task
this
aFlags
LoadAllSourceData
(
)
)
;
return
NS_OK
;
}
void
RasterImage
:
:
RecoverFromInvalidFrames
(
const
OrientedIntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
LoadHasSize
(
)
)
{
return
;
}
NS_WARNING
(
"
A
RasterImage
'
s
frames
became
invalid
.
Attempting
to
recover
.
.
.
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
mLockCount
>
0
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
bool
unused1
unused2
;
if
(
mAnimationState
)
{
Decode
(
mSize
aFlags
|
FLAG_SYNC_DECODE
PlaybackType
:
:
eAnimated
unused1
unused2
)
;
ResetAnimation
(
)
;
return
;
}
Decode
(
aSize
aFlags
PlaybackType
:
:
eStatic
unused1
unused2
)
;
}
bool
RasterImage
:
:
CanDownscaleDuringDecode
(
const
OrientedIntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
LoadHasSize
(
)
|
|
LoadTransient
(
)
|
|
!
StaticPrefs
:
:
image_downscale_during_decode_enabled
(
)
|
|
!
(
aFlags
&
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
)
)
{
return
false
;
}
if
(
mAnimationState
)
{
return
false
;
}
if
(
aSize
.
width
>
=
mSize
.
width
|
|
aSize
.
height
>
=
mSize
.
height
)
{
return
false
;
}
if
(
aSize
.
width
<
1
|
|
aSize
.
height
<
1
)
{
return
false
;
}
if
(
!
SurfaceCache
:
:
CanHold
(
aSize
.
ToUnknownSize
(
)
)
)
{
return
false
;
}
return
true
;
}
ImgDrawResult
RasterImage
:
:
DrawInternal
(
DrawableSurface
&
&
aSurface
gfxContext
*
aContext
const
OrientedIntSize
&
aSize
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aFlags
float
aOpacity
)
{
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aContext
)
;
ImageRegion
region
(
aRegion
)
;
bool
frameIsFinished
=
aSurface
-
>
IsFinished
(
)
;
AutoProfilerImagePaintMarker
PROFILER_RAII
(
this
)
;
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
IntSize
finalSize
=
aSurface
-
>
GetSize
(
)
;
bool
couldRedecodeForBetterFrame
=
false
;
if
(
finalSize
!
=
aSize
.
ToUnknownSize
(
)
)
{
gfx
:
:
MatrixScales
scale
(
double
(
aSize
.
width
)
/
finalSize
.
width
double
(
aSize
.
height
)
/
finalSize
.
height
)
;
aContext
-
>
Multiply
(
gfx
:
:
Matrix
:
:
Scaling
(
scale
)
)
;
region
.
Scale
(
1
.
0
/
scale
.
xScale
1
.
0
/
scale
.
yScale
)
;
couldRedecodeForBetterFrame
=
CanDownscaleDuringDecode
(
aSize
aFlags
)
;
}
if
(
!
aSurface
-
>
Draw
(
aContext
region
aSamplingFilter
aFlags
aOpacity
)
)
{
RecoverFromInvalidFrames
(
aSize
aFlags
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
!
frameIsFinished
)
{
return
ImgDrawResult
:
:
INCOMPLETE
;
}
if
(
couldRedecodeForBetterFrame
)
{
return
ImgDrawResult
:
:
WRONG_SIZE
;
}
return
ImgDrawResult
:
:
SUCCESS
;
}
NS_IMETHODIMP_
(
ImgDrawResult
)
RasterImage
:
:
Draw
(
gfxContext
*
aContext
const
IntSize
&
aSize
const
ImageRegion
&
aRegion
uint32_t
aWhichFrame
SamplingFilter
aSamplingFilter
const
SVGImageContext
&
uint32_t
aFlags
float
aOpacity
)
{
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
mError
)
{
return
ImgDrawResult
:
:
BAD_IMAGE
;
}
if
(
ToSurfaceFlags
(
aFlags
)
!
=
DefaultSurfaceFlags
(
)
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
!
aContext
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
mAnimationConsumers
=
=
0
&
&
mAnimationState
)
{
SendOnUnlockedDraw
(
aFlags
)
;
}
uint32_t
flags
=
aSamplingFilter
=
=
SamplingFilter
:
:
GOOD
?
aFlags
:
aFlags
&
~
FLAG_HIGH_QUALITY_SCALING
;
auto
size
=
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
;
LookupResult
result
=
LookupFrame
(
size
flags
ToPlaybackType
(
aWhichFrame
)
true
)
;
if
(
!
result
)
{
if
(
mDrawStartTime
.
IsNull
(
)
)
{
mDrawStartTime
=
TimeStamp
:
:
Now
(
)
;
}
return
ImgDrawResult
:
:
NOT_READY
;
}
bool
shouldRecordTelemetry
=
!
mDrawStartTime
.
IsNull
(
)
&
&
result
.
Surface
(
)
-
>
IsFinished
(
)
;
ImgDrawResult
drawResult
=
DrawInternal
(
std
:
:
move
(
result
.
Surface
(
)
)
aContext
size
aRegion
aSamplingFilter
flags
aOpacity
)
;
if
(
shouldRecordTelemetry
)
{
TimeDuration
drawLatency
=
TimeStamp
:
:
Now
(
)
-
mDrawStartTime
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_ON_DRAW_LATENCY
int32_t
(
drawLatency
.
ToMicroseconds
(
)
)
)
;
mDrawStartTime
=
TimeStamp
(
)
;
}
return
drawResult
;
}
NS_IMETHODIMP
RasterImage
:
:
LockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
to
encourage
serialization
with
UnlockImage
"
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
mLockCount
+
+
;
if
(
mLockCount
=
=
1
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
UnlockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
to
encourage
serialization
with
LockImage
"
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mLockCount
>
0
"
Calling
UnlockImage
with
mLockCount
=
=
0
!
"
)
;
if
(
mLockCount
=
=
0
)
{
return
NS_ERROR_ABORT
;
}
mLockCount
-
-
;
if
(
mLockCount
=
=
0
)
{
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
RequestDiscard
(
)
{
if
(
LoadDiscardable
(
)
&
&
mLockCount
=
=
0
&
&
CanDiscard
(
)
)
{
Discard
(
)
;
}
return
NS_OK
;
}
void
RasterImage
:
:
DoError
(
)
{
if
(
mError
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
)
{
HandleErrorWorker
:
:
DispatchIfNeeded
(
this
)
;
return
;
}
mError
=
true
;
if
(
mAnimating
)
{
StopAnimation
(
)
;
}
mAnimationState
=
Nothing
(
)
;
mFrameAnimator
=
nullptr
;
mLockCount
=
0
;
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
auto
dirtyRect
=
OrientedIntRect
(
{
0
0
}
mSize
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Error
(
"
RasterImage
:
[
this
=
%
p
]
Error
detected
for
image
\
n
"
this
)
)
;
}
void
RasterImage
:
:
HandleErrorWorker
:
:
DispatchIfNeeded
(
RasterImage
*
aImage
)
{
RefPtr
<
HandleErrorWorker
>
worker
=
new
HandleErrorWorker
(
aImage
)
;
NS_DispatchToMainThread
(
worker
)
;
}
RasterImage
:
:
HandleErrorWorker
:
:
HandleErrorWorker
(
RasterImage
*
aImage
)
:
Runnable
(
"
image
:
:
RasterImage
:
:
HandleErrorWorker
"
)
mImage
(
aImage
)
{
MOZ_ASSERT
(
mImage
"
Should
have
image
"
)
;
}
NS_IMETHODIMP
RasterImage
:
:
HandleErrorWorker
:
:
Run
(
)
{
mImage
-
>
DoError
(
)
;
return
NS_OK
;
}
bool
RasterImage
:
:
ShouldAnimate
(
)
{
return
ImageResource
:
:
ShouldAnimate
(
)
&
&
mAnimationState
&
&
mAnimationState
-
>
KnownFrameCount
(
)
>
=
1
&
&
!
LoadAnimationFinished
(
)
;
}
#
ifdef
DEBUG
NS_IMETHODIMP
RasterImage
:
:
GetFramesNotified
(
uint32_t
*
aFramesNotified
)
{
NS_ENSURE_ARG_POINTER
(
aFramesNotified
)
;
*
aFramesNotified
=
mFramesNotified
;
return
NS_OK
;
}
#
endif
void
RasterImage
:
:
NotifyProgress
(
Progress
aProgress
const
OrientedIntRect
&
aInvalidRect
const
Maybe
<
uint32_t
>
&
aFrameCount
DecoderFlags
aDecoderFlags
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
RasterImage
>
image
=
this
;
OrientedIntRect
invalidRect
=
aInvalidRect
;
if
(
!
(
aDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
)
{
MOZ_ASSERT_IF
(
aFrameCount
&
&
*
aFrameCount
>
1
mAnimationState
|
|
mError
)
;
if
(
mAnimationState
&
&
aFrameCount
)
{
mAnimationState
-
>
UpdateKnownFrameCount
(
*
aFrameCount
)
;
}
if
(
mAnimationState
&
&
aFrameCount
=
=
Some
(
1u
)
&
&
LoadPendingAnimation
(
)
&
&
ShouldAnimate
(
)
)
{
StartAnimation
(
)
;
}
if
(
mAnimationState
)
{
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
mSize
.
ToUnknownSize
(
)
)
;
invalidRect
.
UnionRect
(
invalidRect
OrientedIntRect
:
:
FromUnknownRect
(
rect
)
)
;
}
}
image
-
>
mProgressTracker
-
>
SyncNotifyProgress
(
aProgress
invalidRect
.
ToUnknownRect
(
)
)
;
}
void
RasterImage
:
:
NotifyDecodeComplete
(
const
DecoderFinalStatus
&
aStatus
const
ImageMetadata
&
aMetadata
const
DecoderTelemetry
&
aTelemetry
Progress
aProgress
const
OrientedIntRect
&
aInvalidRect
const
Maybe
<
uint32_t
>
&
aFrameCount
DecoderFlags
aDecoderFlags
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aStatus
.
mShouldReportError
)
{
ReportDecoderError
(
)
;
}
bool
metadataOK
=
SetMetadata
(
aMetadata
aStatus
.
mWasMetadataDecode
)
;
if
(
!
metadataOK
)
{
RecoverFromInvalidFrames
(
mSize
FromSurfaceFlags
(
aSurfaceFlags
)
)
;
return
;
}
MOZ_ASSERT
(
mError
|
|
LoadHasSize
(
)
|
|
!
aMetadata
.
HasSize
(
)
"
SetMetadata
should
'
ve
gotten
a
size
"
)
;
if
(
!
aStatus
.
mWasMetadataDecode
&
&
aStatus
.
mFinished
)
{
StoreHasBeenDecoded
(
true
)
;
}
NotifyProgress
(
aProgress
aInvalidRect
aFrameCount
aDecoderFlags
aSurfaceFlags
)
;
if
(
!
(
aDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
)
{
MOZ_ASSERT_IF
(
aFrameCount
&
&
*
aFrameCount
>
1
mAnimationState
|
|
mError
)
;
if
(
mAnimationState
&
&
aFrameCount
)
{
mAnimationState
-
>
UpdateKnownFrameCount
(
*
aFrameCount
)
;
}
if
(
mAnimationState
&
&
aFrameCount
=
=
Some
(
1u
)
&
&
LoadPendingAnimation
(
)
&
&
ShouldAnimate
(
)
)
{
StartAnimation
(
)
;
}
if
(
mAnimationState
&
&
LoadHasBeenDecoded
(
)
)
{
mAnimationState
-
>
NotifyDecodeComplete
(
)
;
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
mSize
.
ToUnknownSize
(
)
)
;
if
(
!
rect
.
IsEmpty
(
)
)
{
auto
dirtyRect
=
OrientedIntRect
:
:
FromUnknownRect
(
rect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
}
}
if
(
!
aStatus
.
mWasMetadataDecode
)
{
if
(
aTelemetry
.
mChunkCount
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_CHUNKS
aTelemetry
.
mChunkCount
)
;
}
if
(
aStatus
.
mFinished
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_TIME
int32_t
(
aTelemetry
.
mDecodeTime
.
ToMicroseconds
(
)
)
)
;
if
(
aTelemetry
.
mSpeedHistogram
&
&
aTelemetry
.
mBytesDecoded
)
{
Telemetry
:
:
Accumulate
(
*
aTelemetry
.
mSpeedHistogram
aTelemetry
.
Speed
(
)
)
;
}
}
}
if
(
aStatus
.
mHadError
&
&
(
!
mAnimationState
|
|
mAnimationState
-
>
KnownFrameCount
(
)
=
=
0
)
)
{
DoError
(
)
;
}
else
if
(
aStatus
.
mWasMetadataDecode
&
&
!
LoadHasSize
(
)
)
{
DoError
(
)
;
}
if
(
aStatus
.
mFinished
&
&
aStatus
.
mWasMetadataDecode
)
{
if
(
mLoadProgress
)
{
NotifyForLoadEvent
(
*
mLoadProgress
)
;
mLoadProgress
=
Nothing
(
)
;
}
if
(
LoadWantFullDecode
(
)
)
{
StoreWantFullDecode
(
false
)
;
RequestDecodeForSizeInternal
(
mSize
DECODE_FLAGS_DEFAULT
|
FLAG_HIGH_QUALITY_SCALING
|
FLAG_AVOID_REDECODE_FOR_SIZE
FRAME_CURRENT
)
;
}
}
}
void
RasterImage
:
:
ReportDecoderError
(
)
{
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
nsCOMPtr
<
nsIScriptError
>
errorObject
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
;
if
(
consoleService
&
&
errorObject
)
{
nsAutoString
msg
(
u
"
Image
corrupt
or
truncated
.
"
_ns
)
;
nsAutoString
src
;
if
(
GetURI
(
)
)
{
nsAutoCString
uri
;
if
(
!
GetSpecTruncatedTo1k
(
uri
)
)
{
msg
+
=
u
"
URI
in
this
note
truncated
due
to
length
.
"
_ns
;
}
CopyUTF8toUTF16
(
uri
src
)
;
}
if
(
NS_SUCCEEDED
(
errorObject
-
>
InitWithWindowID
(
msg
src
u
"
"
_ns
0
0
nsIScriptError
:
:
errorFlag
"
Image
"
InnerWindowID
(
)
)
)
)
{
consoleService
-
>
LogMessage
(
errorObject
)
;
}
}
}
already_AddRefed
<
imgIContainer
>
RasterImage
:
:
Unwrap
(
)
{
nsCOMPtr
<
imgIContainer
>
self
(
this
)
;
return
self
.
forget
(
)
;
}
void
RasterImage
:
:
PropagateUseCounters
(
dom
:
:
Document
*
)
{
}
IntSize
RasterImage
:
:
OptimalImageSizeForDest
(
const
gfxSize
&
aDest
uint32_t
aWhichFrame
SamplingFilter
aSamplingFilter
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aDest
.
width
>
=
0
|
|
ceil
(
aDest
.
width
)
<
=
INT32_MAX
|
|
aDest
.
height
>
=
0
|
|
ceil
(
aDest
.
height
)
<
=
INT32_MAX
"
Unexpected
destination
size
"
)
;
if
(
mSize
.
IsEmpty
(
)
|
|
aDest
.
IsEmpty
(
)
)
{
return
IntSize
(
0
0
)
;
}
auto
dest
=
OrientedIntSize
:
:
FromUnknownSize
(
IntSize
:
:
Ceil
(
aDest
.
width
aDest
.
height
)
)
;
if
(
aSamplingFilter
=
=
SamplingFilter
:
:
GOOD
&
&
CanDownscaleDuringDecode
(
dest
aFlags
)
)
{
return
dest
.
ToUnknownSize
(
)
;
}
return
mSize
.
ToUnknownSize
(
)
;
}
}
}
