#
include
"
RasterImage
.
h
"
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
DecodePool
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
FrameAnimator
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
ImageLogging
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
OrientedImage
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SurfaceCache
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SizeOfState
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Scale
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsProperties
.
h
"
#
include
"
prenv
.
h
"
#
include
"
prsystem
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
using
namespace
layers
;
namespace
image
{
using
std
:
:
ceil
;
using
std
:
:
min
;
#
ifndef
DEBUG
NS_IMPL_ISUPPORTS
(
RasterImage
imgIContainer
)
#
else
NS_IMPL_ISUPPORTS
(
RasterImage
imgIContainer
imgIContainerDebug
)
#
endif
RasterImage
:
:
RasterImage
(
nsIURI
*
aURI
)
:
ImageResource
(
aURI
)
mSize
(
0
0
)
mLockCount
(
0
)
mDecoderType
(
DecoderType
:
:
UNKNOWN
)
mDecodeCount
(
0
)
#
ifdef
DEBUG
mFramesNotified
(
0
)
#
endif
mSourceBuffer
(
MakeNotNull
<
SourceBuffer
*
>
(
)
)
mHasSize
(
false
)
mTransient
(
false
)
mSyncLoad
(
false
)
mDiscardable
(
false
)
mSomeSourceData
(
false
)
mAllSourceData
(
false
)
mHasBeenDecoded
(
false
)
mPendingAnimation
(
false
)
mAnimationFinished
(
false
)
mWantFullDecode
(
false
)
mHandledOrientation
(
StaticPrefs
:
:
image_honor_orientation_metadata
(
)
)
{
}
RasterImage
:
:
~
RasterImage
(
)
{
if
(
!
mSourceBuffer
-
>
IsComplete
(
)
)
{
mSourceBuffer
-
>
Complete
(
NS_ERROR_ABORT
)
;
}
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_COUNT
mDecodeCount
)
;
}
nsresult
RasterImage
:
:
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
{
if
(
mInitialized
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT_IF
(
aFlags
&
INIT_FLAG_TRANSIENT
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
)
;
mDiscardable
=
!
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
;
mWantFullDecode
=
!
!
(
aFlags
&
INIT_FLAG_DECODE_IMMEDIATELY
)
;
mTransient
=
!
!
(
aFlags
&
INIT_FLAG_TRANSIENT
)
;
mSyncLoad
=
!
!
(
aFlags
&
INIT_FLAG_SYNC_LOAD
)
;
NS_ENSURE_ARG_POINTER
(
aMimeType
)
;
mDecoderType
=
DecoderFactory
:
:
GetDecoderType
(
aMimeType
)
;
if
(
mDecoderType
=
=
DecoderType
:
:
UNKNOWN
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDiscardable
)
{
mLockCount
+
+
;
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
mInitialized
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
RasterImage
:
:
RequestRefresh
(
const
TimeStamp
&
aTime
)
{
if
(
HadRecentRefresh
(
aTime
)
)
{
return
;
}
EvaluateAnimation
(
)
;
if
(
!
mAnimating
)
{
return
;
}
RefreshResult
res
;
if
(
mAnimationState
)
{
MOZ_ASSERT
(
mFrameAnimator
)
;
res
=
mFrameAnimator
-
>
RequestRefresh
(
*
mAnimationState
aTime
)
;
}
#
ifdef
DEBUG
if
(
res
.
mFrameAdvanced
)
{
mFramesNotified
+
+
;
}
#
endif
if
(
!
res
.
mDirtyRect
.
IsEmpty
(
)
|
|
res
.
mFrameAdvanced
)
{
auto
dirtyRect
=
UnorientedIntRect
:
:
FromUnknownRect
(
res
.
mDirtyRect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
if
(
res
.
mAnimationFinished
)
{
mAnimationFinished
=
true
;
EvaluateAnimation
(
)
;
}
}
NS_IMETHODIMP
RasterImage
:
:
GetWidth
(
int32_t
*
aWidth
)
{
NS_ENSURE_ARG_POINTER
(
aWidth
)
;
if
(
mError
)
{
*
aWidth
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aWidth
=
mSize
.
width
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetHeight
(
int32_t
*
aHeight
)
{
NS_ENSURE_ARG_POINTER
(
aHeight
)
;
if
(
mError
)
{
*
aHeight
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aHeight
=
mSize
.
height
;
return
NS_OK
;
}
nsresult
RasterImage
:
:
GetNativeSizes
(
nsTArray
<
IntSize
>
&
aNativeSizes
)
const
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
aNativeSizes
.
Clear
(
)
;
if
(
mNativeSizes
.
IsEmpty
(
)
)
{
aNativeSizes
.
AppendElement
(
mSize
.
ToUnknownSize
(
)
)
;
}
else
{
for
(
const
auto
&
size
:
mNativeSizes
)
{
aNativeSizes
.
AppendElement
(
size
.
ToUnknownSize
(
)
)
;
}
}
return
NS_OK
;
}
size_t
RasterImage
:
:
GetNativeSizesLength
(
)
const
{
if
(
mError
|
|
!
mHasSize
)
{
return
0
;
}
if
(
mNativeSizes
.
IsEmpty
(
)
)
{
return
1
;
}
return
mNativeSizes
.
Length
(
)
;
}
NS_IMETHODIMP
RasterImage
:
:
GetIntrinsicSize
(
nsSize
*
aSize
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
*
aSize
=
nsSize
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
mSize
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
mSize
.
height
)
)
;
return
NS_OK
;
}
Maybe
<
AspectRatio
>
RasterImage
:
:
GetIntrinsicRatio
(
)
{
if
(
mError
)
{
return
Nothing
(
)
;
}
return
Some
(
AspectRatio
:
:
FromSize
(
mSize
.
width
mSize
.
height
)
)
;
}
NS_IMETHODIMP_
(
Orientation
)
RasterImage
:
:
GetOrientation
(
)
{
return
mOrientation
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
HandledOrientation
(
)
{
return
mHandledOrientation
;
}
NS_IMETHODIMP
RasterImage
:
:
GetType
(
uint16_t
*
aType
)
{
NS_ENSURE_ARG_POINTER
(
aType
)
;
*
aType
=
imgIContainer
:
:
TYPE_RASTER
;
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
GetProducerId
(
uint32_t
*
aId
)
{
NS_ENSURE_ARG_POINTER
(
aId
)
;
*
aId
=
ImageResource
:
:
GetImageProducerId
(
)
;
return
NS_OK
;
}
LookupResult
RasterImage
:
:
LookupFrameInternal
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
aMarkUsed
)
{
if
(
mAnimationState
&
&
aPlaybackType
=
=
PlaybackType
:
:
eAnimated
)
{
MOZ_ASSERT
(
mFrameAnimator
)
;
MOZ_ASSERT
(
ToSurfaceFlags
(
aFlags
)
=
=
DefaultSurfaceFlags
(
)
"
Can
'
t
composite
frames
with
non
-
default
surface
flags
"
)
;
return
mFrameAnimator
-
>
GetCompositedFrame
(
*
mAnimationState
aMarkUsed
)
;
}
SurfaceFlags
surfaceFlags
=
ToSurfaceFlags
(
aFlags
)
;
if
(
(
aFlags
&
FLAG_SYNC_DECODE
)
|
|
!
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
{
return
SurfaceCache
:
:
Lookup
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
.
ToUnknownSize
(
)
surfaceFlags
PlaybackType
:
:
eStatic
)
aMarkUsed
)
;
}
return
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
RasterSurfaceKey
(
aSize
.
ToUnknownSize
(
)
surfaceFlags
PlaybackType
:
:
eStatic
)
aMarkUsed
)
;
}
LookupResult
RasterImage
:
:
LookupFrame
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
aMarkUsed
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsOpaque
(
)
)
{
aFlags
&
=
~
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
;
}
UnorientedIntSize
requestedSize
=
CanDownscaleDuringDecode
(
aSize
aFlags
)
?
aSize
:
ToUnoriented
(
mSize
)
;
if
(
requestedSize
.
IsEmpty
(
)
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
LookupResult
result
=
LookupFrameInternal
(
requestedSize
aFlags
aPlaybackType
aMarkUsed
)
;
if
(
!
result
&
&
!
mHasSize
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
const
bool
syncDecode
=
aFlags
&
FLAG_SYNC_DECODE
;
const
bool
avoidRedecode
=
aFlags
&
FLAG_AVOID_REDECODE_FOR_SIZE
;
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
|
|
(
result
.
Type
(
)
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
&
&
!
avoidRedecode
)
|
|
(
syncDecode
&
&
!
avoidRedecode
&
&
!
result
)
)
{
MOZ_ASSERT
(
aPlaybackType
!
=
PlaybackType
:
:
eAnimated
|
|
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
|
|
!
mAnimationState
|
|
mAnimationState
-
>
KnownFrameCount
(
)
<
1
"
Animated
frames
should
be
locked
"
)
;
if
(
!
result
.
SuggestedSize
(
)
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
syncDecode
&
&
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
;
requestedSize
=
UnorientedIntSize
:
:
FromUnknownSize
(
result
.
SuggestedSize
(
)
)
;
}
bool
ranSync
=
false
failed
=
false
;
Decode
(
requestedSize
aFlags
aPlaybackType
ranSync
failed
)
;
if
(
failed
)
{
result
.
SetFailedToRequestDecode
(
)
;
}
if
(
ranSync
|
|
syncDecode
)
{
result
=
LookupFrameInternal
(
requestedSize
aFlags
aPlaybackType
aMarkUsed
)
;
}
}
if
(
!
result
)
{
return
result
;
}
if
(
mAllSourceData
&
&
syncDecode
)
{
result
.
Surface
(
)
-
>
WaitUntilFinished
(
)
;
}
if
(
aFlags
&
(
FLAG_SYNC_DECODE
|
FLAG_SYNC_DECODE_IF_FAST
)
&
&
result
.
Surface
(
)
-
>
IsAborted
(
)
)
{
DrawableSurface
tmp
=
std
:
:
move
(
result
.
Surface
(
)
)
;
return
result
;
}
return
result
;
}
bool
RasterImage
:
:
IsOpaque
(
)
{
if
(
mError
)
{
return
false
;
}
Progress
progress
=
mProgressTracker
-
>
GetProgress
(
)
;
if
(
!
(
progress
&
FLAG_DECODE_COMPLETE
)
)
{
return
false
;
}
return
!
(
progress
&
FLAG_HAS_TRANSPARENCY
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
WillDrawOpaqueNow
(
)
{
if
(
!
IsOpaque
(
)
)
{
return
false
;
}
if
(
mAnimationState
)
{
if
(
!
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
{
return
true
;
}
else
{
if
(
mAnimationState
-
>
GetCompositedFrameInvalid
(
)
)
{
return
false
;
}
}
}
if
(
mLockCount
=
=
0
)
{
return
false
;
}
auto
size
=
ToUnoriented
(
mSize
)
;
LookupResult
result
=
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
RasterSurfaceKey
(
size
.
ToUnknownSize
(
)
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eStatic
)
false
)
;
MatchType
matchType
=
result
.
Type
(
)
;
if
(
matchType
=
=
MatchType
:
:
NOT_FOUND
|
|
matchType
=
=
MatchType
:
:
PENDING
|
|
!
result
.
Surface
(
)
-
>
IsFinished
(
)
)
{
return
false
;
}
return
true
;
}
void
RasterImage
:
:
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
{
MOZ_ASSERT
(
mProgressTracker
)
;
bool
animatedFramesDiscarded
=
mAnimationState
&
&
aSurfaceKey
.
Playback
(
)
=
=
PlaybackType
:
:
eAnimated
;
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
if
(
mProgressTracker
)
{
eventTarget
=
mProgressTracker
-
>
GetEventTarget
(
)
;
}
else
{
eventTarget
=
do_GetMainThread
(
)
;
}
RefPtr
<
RasterImage
>
image
=
this
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NS_NewRunnableFunction
(
"
RasterImage
:
:
OnSurfaceDiscarded
"
[
=
]
(
)
-
>
void
{
image
-
>
OnSurfaceDiscardedInternal
(
animatedFramesDiscarded
)
;
}
)
;
eventTarget
-
>
Dispatch
(
ev
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
RasterImage
:
:
OnSurfaceDiscardedInternal
(
bool
aAnimatedFramesDiscarded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aAnimatedFramesDiscarded
&
&
mAnimationState
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
;
ReleaseImageContainer
(
)
;
auto
size
=
ToUnoriented
(
mSize
)
;
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
size
.
ToUnknownSize
(
)
)
;
auto
dirtyRect
=
UnorientedIntRect
:
:
FromUnknownRect
(
rect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
if
(
mProgressTracker
)
{
mProgressTracker
-
>
OnDiscard
(
)
;
}
}
NS_IMETHODIMP
RasterImage
:
:
GetAnimated
(
bool
*
aAnimated
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_ARG_POINTER
(
aAnimated
)
;
if
(
mAnimationState
)
{
*
aAnimated
=
true
;
return
NS_OK
;
}
if
(
!
mHasBeenDecoded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
*
aAnimated
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
int32_t
)
RasterImage
:
:
GetFirstFrameDelay
(
)
{
if
(
mError
)
{
return
-
1
;
}
bool
animated
=
false
;
if
(
NS_FAILED
(
GetAnimated
(
&
animated
)
)
|
|
!
animated
)
{
return
-
1
;
}
MOZ_ASSERT
(
mAnimationState
"
Animated
images
should
have
an
AnimationState
"
)
;
return
mAnimationState
-
>
FirstFrameTimeout
(
)
.
AsEncodedValueDeprecated
(
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
RasterImage
:
:
GetFrame
(
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
return
GetFrameAtSize
(
mSize
.
ToUnknownSize
(
)
aWhichFrame
aFlags
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
RasterImage
:
:
GetFrameAtSize
(
const
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
auto
result
=
GetFrameInternal
(
aSize
Nothing
(
)
aWhichFrame
aFlags
)
;
return
mozilla
:
:
Get
<
2
>
(
result
)
.
forget
(
)
;
}
Tuple
<
ImgDrawResult
IntSize
RefPtr
<
SourceSurface
>
>
RasterImage
:
:
GetFrameInternal
(
const
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
)
;
auto
size
=
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
;
if
(
aSize
.
IsEmpty
(
)
|
|
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_ARGS
aSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
if
(
mError
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_IMAGE
aSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
LookupResult
result
=
LookupFrame
(
ToUnoriented
(
size
)
aFlags
ToPlaybackType
(
aWhichFrame
)
true
)
;
auto
resultSuggestedSize
=
UnorientedIntSize
:
:
FromUnknownSize
(
result
.
SuggestedSize
(
)
)
;
OrientedIntSize
suggestedSize
=
ToOriented
(
resultSuggestedSize
)
;
if
(
suggestedSize
.
IsEmpty
(
)
)
{
suggestedSize
=
size
;
}
MOZ_ASSERT_IF
(
result
.
Type
(
)
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_BEST
suggestedSize
!
=
size
)
;
if
(
!
result
)
{
return
MakeTuple
(
ImgDrawResult
:
:
TEMPORARY_ERROR
suggestedSize
.
ToUnknownSize
(
)
RefPtr
<
SourceSurface
>
(
)
)
;
}
RefPtr
<
SourceSurface
>
surface
=
result
.
Surface
(
)
-
>
GetSourceSurface
(
)
;
surface
=
OrientedImage
:
:
OrientSurface
(
UsedOrientation
(
)
surface
)
;
if
(
!
result
.
Surface
(
)
-
>
IsFinished
(
)
)
{
return
MakeTuple
(
ImgDrawResult
:
:
INCOMPLETE
suggestedSize
.
ToUnknownSize
(
)
std
:
:
move
(
surface
)
)
;
}
return
MakeTuple
(
ImgDrawResult
:
:
SUCCESS
suggestedSize
.
ToUnknownSize
(
)
std
:
:
move
(
surface
)
)
;
}
Tuple
<
ImgDrawResult
IntSize
>
RasterImage
:
:
GetImageContainerSize
(
LayerManager
*
aManager
const
IntSize
&
aRequestedSize
uint32_t
aFlags
)
{
if
(
!
mHasSize
)
{
return
MakeTuple
(
ImgDrawResult
:
:
NOT_READY
IntSize
(
0
0
)
)
;
}
if
(
aRequestedSize
.
IsEmpty
(
)
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_ARGS
IntSize
(
0
0
)
)
;
}
int32_t
maxTextureSize
=
aManager
-
>
GetMaxTextureSize
(
)
;
if
(
min
(
mSize
.
width
aRequestedSize
.
width
)
>
maxTextureSize
|
|
min
(
mSize
.
height
aRequestedSize
.
height
)
>
maxTextureSize
)
{
return
MakeTuple
(
ImgDrawResult
:
:
NOT_SUPPORTED
IntSize
(
0
0
)
)
;
}
auto
requestedSize
=
OrientedIntSize
:
:
FromUnknownSize
(
aRequestedSize
)
;
if
(
!
CanDownscaleDuringDecode
(
ToUnoriented
(
requestedSize
)
aFlags
)
)
{
return
MakeTuple
(
ImgDrawResult
:
:
SUCCESS
mSize
.
ToUnknownSize
(
)
)
;
}
return
MakeTuple
(
ImgDrawResult
:
:
SUCCESS
aRequestedSize
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
IsImageContainerAvailable
(
LayerManager
*
aManager
uint32_t
aFlags
)
{
return
IsImageContainerAvailableAtSize
(
aManager
mSize
.
ToUnknownSize
(
)
aFlags
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
ImageContainer
>
)
RasterImage
:
:
GetImageContainer
(
LayerManager
*
aManager
uint32_t
aFlags
)
{
RefPtr
<
ImageContainer
>
container
;
ImgDrawResult
drawResult
=
GetImageContainerImpl
(
aManager
mSize
.
ToUnknownSize
(
)
Nothing
(
)
aFlags
getter_AddRefs
(
container
)
)
;
(
void
)
drawResult
;
return
container
.
forget
(
)
;
}
NS_IMETHODIMP_
(
bool
)
RasterImage
:
:
IsImageContainerAvailableAtSize
(
LayerManager
*
aManager
const
IntSize
&
aRequestedSize
uint32_t
aFlags
)
{
int32_t
maxTextureSize
=
aManager
-
>
GetMaxTextureSize
(
)
;
if
(
!
mHasSize
|
|
aRequestedSize
.
IsEmpty
(
)
|
|
min
(
mSize
.
width
aRequestedSize
.
width
)
>
maxTextureSize
|
|
min
(
mSize
.
height
aRequestedSize
.
height
)
>
maxTextureSize
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP_
(
ImgDrawResult
)
RasterImage
:
:
GetImageContainerAtSize
(
layers
:
:
LayerManager
*
aManager
const
gfx
:
:
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
layers
:
:
ImageContainer
*
*
aOutContainer
)
{
return
GetImageContainerImpl
(
aManager
aSize
Nothing
(
)
aFlags
aOutContainer
)
;
}
size_t
RasterImage
:
:
SizeOfSourceWithComputedFallback
(
SizeOfState
&
aState
)
const
{
return
mSourceBuffer
-
>
SizeOfIncludingThisWithComputedFallback
(
aState
.
mMallocSizeOf
)
;
}
void
RasterImage
:
:
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
SurfaceCache
:
:
CollectSizeOfSurfaces
(
ImageKey
(
this
)
aCounters
aMallocSizeOf
)
;
}
bool
RasterImage
:
:
SetMetadata
(
const
ImageMetadata
&
aMetadata
bool
aFromMetadataDecode
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
true
;
}
if
(
aMetadata
.
HasSize
(
)
)
{
auto
metadataSize
=
UnorientedIntSize
:
:
FromUnknownSize
(
aMetadata
.
GetSize
(
)
)
;
if
(
metadataSize
.
width
<
0
|
|
metadataSize
.
height
<
0
)
{
NS_WARNING
(
"
Image
has
negative
intrinsic
size
"
)
;
DoError
(
)
;
return
true
;
}
MOZ_ASSERT
(
aMetadata
.
HasOrientation
(
)
)
;
Orientation
orientation
=
aMetadata
.
GetOrientation
(
)
;
if
(
mHasSize
&
&
(
metadataSize
!
=
ToUnoriented
(
mSize
)
|
|
orientation
!
=
mOrientation
)
)
{
NS_WARNING
(
"
Image
changed
size
or
orientation
on
redecode
!
"
"
This
should
not
happen
!
"
)
;
DoError
(
)
;
return
true
;
}
mOrientation
=
orientation
;
mSize
=
ToOriented
(
metadataSize
)
;
mNativeSizes
.
Clear
(
)
;
for
(
const
auto
&
nativeSize
:
aMetadata
.
GetNativeSizes
(
)
)
{
mNativeSizes
.
AppendElement
(
ToOriented
(
UnorientedIntSize
:
:
FromUnknownSize
(
nativeSize
)
)
)
;
}
mHasSize
=
true
;
}
if
(
mHasSize
&
&
aMetadata
.
HasAnimation
(
)
&
&
!
mAnimationState
)
{
mAnimationState
.
emplace
(
mAnimationMode
)
;
mFrameAnimator
=
MakeUnique
<
FrameAnimator
>
(
this
ToUnoriented
(
mSize
)
.
ToUnknownSize
(
)
)
;
if
(
!
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
{
LockImage
(
)
;
}
if
(
!
aFromMetadataDecode
)
{
return
false
;
}
}
if
(
mAnimationState
)
{
mAnimationState
-
>
SetLoopCount
(
aMetadata
.
GetLoopCount
(
)
)
;
mAnimationState
-
>
SetFirstFrameTimeout
(
aMetadata
.
GetFirstFrameTimeout
(
)
)
;
if
(
aMetadata
.
HasLoopLength
(
)
)
{
mAnimationState
-
>
SetLoopLength
(
aMetadata
.
GetLoopLength
(
)
)
;
}
if
(
aMetadata
.
HasFirstFrameRefreshArea
(
)
)
{
mAnimationState
-
>
SetFirstFrameRefreshArea
(
aMetadata
.
GetFirstFrameRefreshArea
(
)
)
;
}
}
if
(
aMetadata
.
HasHotspot
(
)
)
{
MOZ_ASSERT
(
UsedOrientation
(
)
.
IsIdentity
(
)
"
Would
need
to
orient
hotspot
point
"
)
;
auto
hotspot
=
aMetadata
.
GetHotspot
(
)
;
mHotspot
.
x
=
std
:
:
max
(
std
:
:
min
(
hotspot
.
x
mSize
.
width
-
1
)
0
)
;
mHotspot
.
y
=
std
:
:
max
(
std
:
:
min
(
hotspot
.
y
mSize
.
height
-
1
)
0
)
;
}
return
true
;
}
NS_IMETHODIMP
RasterImage
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
if
(
mAnimationState
)
{
mAnimationState
-
>
SetAnimationMode
(
aAnimationMode
)
;
}
return
SetAnimationModeInternal
(
aAnimationMode
)
;
}
nsresult
RasterImage
:
:
StartAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
ShouldAnimate
(
)
"
Should
not
animate
!
"
)
;
mPendingAnimation
=
!
mAnimationState
|
|
mAnimationState
-
>
KnownFrameCount
(
)
<
1
;
if
(
mPendingAnimation
)
{
return
NS_OK
;
}
if
(
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
=
=
0
&
&
mAnimationState
-
>
FirstFrameTimeout
(
)
=
=
FrameTimeout
:
:
Forever
(
)
)
{
mAnimationFinished
=
true
;
return
NS_ERROR_ABORT
;
}
mAnimationState
-
>
InitAnimationFrameTimeIfNecessary
(
)
;
return
NS_OK
;
}
nsresult
RasterImage
:
:
StopAnimation
(
)
{
MOZ_ASSERT
(
mAnimating
"
Should
be
animating
!
"
)
;
nsresult
rv
=
NS_OK
;
if
(
mError
)
{
rv
=
NS_ERROR_FAILURE
;
}
else
{
mAnimationState
-
>
SetAnimationFrameTime
(
TimeStamp
(
)
)
;
}
mAnimating
=
false
;
return
rv
;
}
NS_IMETHODIMP
RasterImage
:
:
ResetAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
mPendingAnimation
=
false
;
if
(
mAnimationMode
=
=
kDontAnimMode
|
|
!
mAnimationState
|
|
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
=
=
0
)
{
return
NS_OK
;
}
mAnimationFinished
=
false
;
if
(
mAnimating
)
{
StopAnimation
(
)
;
}
MOZ_ASSERT
(
mAnimationState
"
Should
have
AnimationState
"
)
;
MOZ_ASSERT
(
mFrameAnimator
"
Should
have
FrameAnimator
"
)
;
mFrameAnimator
-
>
ResetAnimation
(
*
mAnimationState
)
;
IntRect
area
=
mAnimationState
-
>
FirstFrameRefreshArea
(
)
;
NotifyProgress
(
NoProgress
UnorientedIntRect
:
:
FromUnknownRect
(
area
)
)
;
EvaluateAnimation
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
RasterImage
:
:
SetAnimationStartTime
(
const
TimeStamp
&
aTime
)
{
if
(
mError
|
|
mAnimationMode
=
=
kDontAnimMode
|
|
mAnimating
|
|
!
mAnimationState
)
{
return
;
}
mAnimationState
-
>
SetAnimationFrameTime
(
aTime
)
;
}
NS_IMETHODIMP_
(
float
)
RasterImage
:
:
GetFrameIndex
(
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
"
Invalid
argument
"
)
;
return
(
aWhichFrame
=
=
FRAME_FIRST
|
|
!
mAnimationState
)
?
0
.
0f
:
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
;
}
NS_IMETHODIMP_
(
IntRect
)
RasterImage
:
:
GetImageSpaceInvalidationRect
(
const
IntRect
&
aRect
)
{
return
aRect
;
}
nsresult
RasterImage
:
:
OnImageDataComplete
(
nsIRequest
*
nsISupports
*
nsresult
aStatus
bool
aLastPart
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mAllSourceData
=
true
;
mSourceBuffer
-
>
Complete
(
aStatus
)
;
bool
canSyncDecodeMetadata
=
mSyncLoad
|
|
mTransient
|
|
DecodePool
:
:
NumberOfCores
(
)
<
2
;
if
(
canSyncDecodeMetadata
&
&
!
mHasSize
)
{
DecodeMetadata
(
FLAG_SYNC_DECODE
)
;
}
nsresult
finalStatus
=
mError
?
NS_ERROR_FAILURE
:
NS_OK
;
if
(
NS_FAILED
(
aStatus
)
)
{
finalStatus
=
aStatus
;
}
if
(
NS_FAILED
(
finalStatus
)
)
{
DoError
(
)
;
}
Progress
loadProgress
=
LoadCompleteProgress
(
aLastPart
mError
finalStatus
)
;
if
(
!
mHasSize
&
&
!
mError
)
{
MOZ_ASSERT
(
!
canSyncDecodeMetadata
"
Firing
load
async
after
metadata
sync
decode
?
"
)
;
mLoadProgress
=
Some
(
loadProgress
)
;
return
finalStatus
;
}
NotifyForLoadEvent
(
loadProgress
)
;
return
finalStatus
;
}
void
RasterImage
:
:
NotifyForLoadEvent
(
Progress
aProgress
)
{
MOZ_ASSERT
(
mHasSize
|
|
mError
"
Need
to
know
size
before
firing
load
event
"
)
;
MOZ_ASSERT
(
!
mHasSize
|
|
(
mProgressTracker
-
>
GetProgress
(
)
&
FLAG_SIZE_AVAILABLE
)
"
Should
have
notified
that
the
size
is
available
if
we
have
it
"
)
;
if
(
mError
)
{
aProgress
|
=
FLAG_HAS_ERROR
;
}
NotifyProgress
(
aProgress
)
;
}
nsresult
RasterImage
:
:
OnImageDataAvailable
(
nsIRequest
*
nsISupports
*
nsIInputStream
*
aInputStream
uint64_t
uint32_t
aCount
)
{
nsresult
rv
=
mSourceBuffer
-
>
AppendFromInputStream
(
aInputStream
aCount
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
mSomeSourceData
)
{
mSomeSourceData
=
true
;
if
(
!
mSyncLoad
)
{
rv
=
DecodeMetadata
(
DECODE_FLAGS_DEFAULT
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
DoError
(
)
;
}
return
rv
;
}
nsresult
RasterImage
:
:
SetSourceSizeHint
(
uint32_t
aSizeHint
)
{
if
(
aSizeHint
=
=
0
)
{
return
NS_OK
;
}
nsresult
rv
=
mSourceBuffer
-
>
ExpectLength
(
aSizeHint
)
;
if
(
rv
=
=
NS_ERROR_OUT_OF_MEMORY
)
{
rv
=
nsMemory
:
:
HeapMinimize
(
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
mSourceBuffer
-
>
ExpectLength
(
aSizeHint
)
;
}
}
return
rv
;
}
nsresult
RasterImage
:
:
GetHotspotX
(
int32_t
*
aX
)
{
*
aX
=
mHotspot
.
x
;
return
NS_OK
;
}
nsresult
RasterImage
:
:
GetHotspotY
(
int32_t
*
aY
)
{
*
aY
=
mHotspot
.
y
;
return
NS_OK
;
}
void
RasterImage
:
:
Discard
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
CanDiscard
(
)
"
Asked
to
discard
but
can
'
t
"
)
;
MOZ_ASSERT
(
!
mAnimationState
|
|
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
"
Asked
to
discard
for
animated
image
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
mAnimationState
)
{
ReleaseImageContainer
(
)
;
auto
size
=
ToUnoriented
(
mSize
)
;
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
size
.
ToUnknownSize
(
)
)
;
auto
dirtyRect
=
UnorientedIntRect
:
:
FromUnknownRect
(
rect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
if
(
mProgressTracker
)
{
mProgressTracker
-
>
OnDiscard
(
)
;
}
}
bool
RasterImage
:
:
CanDiscard
(
)
{
return
mAllSourceData
&
&
(
!
mAnimationState
|
|
StaticPrefs
:
:
image_mem_animated_discardable_AtStartup
(
)
)
;
}
NS_IMETHODIMP
RasterImage
:
:
StartDecoding
(
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mHasSize
)
{
mWantFullDecode
=
true
;
return
NS_OK
;
}
uint32_t
flags
=
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
|
FLAG_SYNC_DECODE_IF_FAST
|
FLAG_HIGH_QUALITY_SCALING
;
return
RequestDecodeForSize
(
mSize
.
ToUnknownSize
(
)
flags
aWhichFrame
)
;
}
bool
RasterImage
:
:
StartDecodingWithResult
(
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
if
(
mError
)
{
return
false
;
}
if
(
!
mHasSize
)
{
mWantFullDecode
=
true
;
return
false
;
}
uint32_t
flags
=
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
|
FLAG_SYNC_DECODE_IF_FAST
|
FLAG_HIGH_QUALITY_SCALING
;
LookupResult
result
=
RequestDecodeForSizeInternal
(
ToUnoriented
(
mSize
)
flags
aWhichFrame
)
;
DrawableSurface
surface
=
std
:
:
move
(
result
.
Surface
(
)
)
;
return
surface
&
&
surface
-
>
IsFinished
(
)
;
}
imgIContainer
:
:
DecodeResult
RasterImage
:
:
RequestDecodeWithResult
(
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
imgIContainer
:
:
DECODE_REQUEST_FAILED
;
}
uint32_t
flags
=
aFlags
|
FLAG_ASYNC_NOTIFY
;
LookupResult
result
=
RequestDecodeForSizeInternal
(
ToUnoriented
(
mSize
)
flags
aWhichFrame
)
;
DrawableSurface
surface
=
std
:
:
move
(
result
.
Surface
(
)
)
;
if
(
surface
&
&
surface
-
>
IsFinished
(
)
)
{
return
imgIContainer
:
:
DECODE_SURFACE_AVAILABLE
;
}
if
(
result
.
GetFailedToRequestDecode
(
)
)
{
return
imgIContainer
:
:
DECODE_REQUEST_FAILED
;
}
return
imgIContainer
:
:
DECODE_REQUESTED
;
}
NS_IMETHODIMP
RasterImage
:
:
RequestDecodeForSize
(
const
IntSize
&
aSize
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
RequestDecodeForSizeInternal
(
ToUnoriented
(
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
)
aFlags
aWhichFrame
)
;
return
NS_OK
;
}
LookupResult
RasterImage
:
:
RequestDecodeForSizeInternal
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
if
(
mError
)
{
LookupResult
result
=
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
result
.
SetFailedToRequestDecode
(
)
;
return
result
;
}
if
(
!
mHasSize
)
{
mWantFullDecode
=
true
;
return
LookupResult
(
MatchType
:
:
NOT_FOUND
)
;
}
bool
shouldSyncDecodeIfFast
=
!
mHasBeenDecoded
&
&
(
aFlags
&
FLAG_SYNC_DECODE_IF_FAST
)
;
uint32_t
flags
=
shouldSyncDecodeIfFast
?
aFlags
:
aFlags
&
~
FLAG_SYNC_DECODE_IF_FAST
;
return
LookupFrame
(
aSize
flags
ToPlaybackType
(
aWhichFrame
)
false
)
;
}
static
bool
LaunchDecodingTask
(
IDecodingTask
*
aTask
RasterImage
*
aImage
uint32_t
aFlags
bool
aHaveSourceData
)
{
if
(
aHaveSourceData
)
{
nsCString
uri
(
aImage
-
>
GetURIString
(
)
)
;
if
(
aFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
{
DecodePool
:
:
Singleton
(
)
-
>
SyncRunIfPossible
(
aTask
uri
)
;
return
true
;
}
if
(
aFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
)
{
return
DecodePool
:
:
Singleton
(
)
-
>
SyncRunIfPreferred
(
aTask
uri
)
;
}
}
DecodePool
:
:
Singleton
(
)
-
>
AsyncRun
(
aTask
)
;
return
false
;
}
void
RasterImage
:
:
Decode
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
PlaybackType
aPlaybackType
bool
&
aOutRanSync
bool
&
aOutFailed
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
aOutFailed
=
true
;
return
;
}
if
(
!
mHasSize
)
{
mWantFullDecode
=
true
;
return
;
}
SurfaceCache
:
:
UnlockEntries
(
ImageKey
(
this
)
)
;
DecoderFlags
decoderFlags
=
DefaultDecoderFlags
(
)
;
if
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
{
decoderFlags
|
=
DecoderFlags
:
:
ASYNC_NOTIFY
;
}
if
(
mTransient
)
{
decoderFlags
|
=
DecoderFlags
:
:
IMAGE_IS_TRANSIENT
;
}
if
(
mHasBeenDecoded
)
{
decoderFlags
|
=
DecoderFlags
:
:
IS_REDECODE
;
}
if
(
(
aFlags
&
FLAG_SYNC_DECODE
)
|
|
!
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
{
decoderFlags
|
=
DecoderFlags
:
:
CANNOT_SUBSTITUTE
;
}
SurfaceFlags
surfaceFlags
=
ToSurfaceFlags
(
aFlags
)
;
if
(
IsOpaque
(
)
)
{
surfaceFlags
&
=
~
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
;
}
RefPtr
<
IDecodingTask
>
task
;
nsresult
rv
;
bool
animated
=
mAnimationState
&
&
aPlaybackType
=
=
PlaybackType
:
:
eAnimated
;
if
(
animated
)
{
size_t
currentFrame
=
mAnimationState
-
>
GetCurrentAnimationFrameIndex
(
)
;
rv
=
DecoderFactory
:
:
CreateAnimationDecoder
(
mDecoderType
WrapNotNull
(
this
)
mSourceBuffer
ToUnoriented
(
mSize
)
.
ToUnknownSize
(
)
decoderFlags
surfaceFlags
currentFrame
getter_AddRefs
(
task
)
)
;
}
else
{
rv
=
DecoderFactory
:
:
CreateDecoder
(
mDecoderType
WrapNotNull
(
this
)
mSourceBuffer
ToUnoriented
(
mSize
)
.
ToUnknownSize
(
)
aSize
.
ToUnknownSize
(
)
decoderFlags
surfaceFlags
getter_AddRefs
(
task
)
)
;
}
if
(
rv
=
=
NS_ERROR_ALREADY_INITIALIZED
)
{
MOZ_ASSERT
(
!
task
)
;
aOutRanSync
=
true
;
return
;
}
if
(
animated
)
{
#
ifdef
DEBUG
IntRect
rect
=
#
endif
mAnimationState
-
>
UpdateState
(
this
ToUnoriented
(
mSize
)
.
ToUnknownSize
(
)
false
)
;
MOZ_ASSERT
(
rect
.
IsEmpty
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
!
task
)
;
aOutFailed
=
true
;
return
;
}
MOZ_ASSERT
(
task
)
;
mDecodeCount
+
+
;
aOutRanSync
=
LaunchDecodingTask
(
task
this
aFlags
mAllSourceData
)
;
}
NS_IMETHODIMP
RasterImage
:
:
DecodeMetadata
(
uint32_t
aFlags
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
mHasSize
"
Should
not
do
unnecessary
metadata
decodes
"
)
;
RefPtr
<
IDecodingTask
>
task
=
DecoderFactory
:
:
CreateMetadataDecoder
(
mDecoderType
WrapNotNull
(
this
)
mSourceBuffer
)
;
if
(
!
task
)
{
return
NS_ERROR_FAILURE
;
}
LaunchDecodingTask
(
task
this
aFlags
mAllSourceData
)
;
return
NS_OK
;
}
void
RasterImage
:
:
RecoverFromInvalidFrames
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
mHasSize
)
{
return
;
}
NS_WARNING
(
"
A
RasterImage
'
s
frames
became
invalid
.
Attempting
to
recover
.
.
.
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
mLockCount
>
0
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
bool
unused1
unused2
;
if
(
mAnimationState
)
{
Decode
(
ToUnoriented
(
mSize
)
aFlags
|
FLAG_SYNC_DECODE
PlaybackType
:
:
eAnimated
unused1
unused2
)
;
ResetAnimation
(
)
;
return
;
}
Decode
(
aSize
aFlags
PlaybackType
:
:
eStatic
unused1
unused2
)
;
}
static
bool
HaveSkia
(
)
{
#
ifdef
MOZ_ENABLE_SKIA
return
true
;
#
else
return
false
;
#
endif
}
bool
RasterImage
:
:
CanDownscaleDuringDecode
(
const
UnorientedIntSize
&
aSize
uint32_t
aFlags
)
{
if
(
!
mHasSize
|
|
mTransient
|
|
!
HaveSkia
(
)
|
|
!
StaticPrefs
:
:
image_downscale_during_decode_enabled
(
)
|
|
!
(
aFlags
&
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
)
)
{
return
false
;
}
if
(
mAnimationState
)
{
return
false
;
}
UnorientedIntSize
ourSize
=
ToUnoriented
(
mSize
)
;
if
(
aSize
.
width
>
=
ourSize
.
width
|
|
aSize
.
height
>
=
ourSize
.
height
)
{
return
false
;
}
if
(
aSize
.
width
<
1
|
|
aSize
.
height
<
1
)
{
return
false
;
}
if
(
!
SurfaceCache
:
:
CanHold
(
aSize
.
ToUnknownSize
(
)
)
)
{
return
false
;
}
return
true
;
}
ImgDrawResult
RasterImage
:
:
DrawInternal
(
DrawableSurface
&
&
aSurface
gfxContext
*
aContext
const
UnorientedIntSize
&
aSize
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aFlags
float
aOpacity
)
{
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aContext
)
;
ImageRegion
region
(
aRegion
)
;
bool
frameIsFinished
=
aSurface
-
>
IsFinished
(
)
;
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
IntSize
finalSize
=
aSurface
-
>
GetSize
(
)
;
bool
couldRedecodeForBetterFrame
=
false
;
if
(
finalSize
!
=
aSize
.
ToUnknownSize
(
)
)
{
gfx
:
:
Size
scale
(
double
(
aSize
.
width
)
/
finalSize
.
width
double
(
aSize
.
height
)
/
finalSize
.
height
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scale
.
width
scale
.
height
)
)
;
region
.
Scale
(
1
.
0
/
scale
.
width
1
.
0
/
scale
.
height
)
;
couldRedecodeForBetterFrame
=
CanDownscaleDuringDecode
(
aSize
aFlags
)
;
}
if
(
!
aSurface
-
>
Draw
(
aContext
region
aSamplingFilter
aFlags
aOpacity
)
)
{
RecoverFromInvalidFrames
(
aSize
aFlags
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
if
(
!
frameIsFinished
)
{
return
ImgDrawResult
:
:
INCOMPLETE
;
}
if
(
couldRedecodeForBetterFrame
)
{
return
ImgDrawResult
:
:
WRONG_SIZE
;
}
return
ImgDrawResult
:
:
SUCCESS
;
}
NS_IMETHODIMP_
(
ImgDrawResult
)
RasterImage
:
:
Draw
(
gfxContext
*
aContext
const
IntSize
&
aSize
const
ImageRegion
&
aRegion
uint32_t
aWhichFrame
SamplingFilter
aSamplingFilter
const
Maybe
<
SVGImageContext
>
&
uint32_t
aFlags
float
aOpacity
)
{
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
mError
)
{
return
ImgDrawResult
:
:
BAD_IMAGE
;
}
if
(
ToSurfaceFlags
(
aFlags
)
!
=
DefaultSurfaceFlags
(
)
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
!
aContext
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
mAnimationConsumers
=
=
0
)
{
SendOnUnlockedDraw
(
aFlags
)
;
}
uint32_t
flags
=
aSamplingFilter
=
=
SamplingFilter
:
:
GOOD
?
aFlags
:
aFlags
&
~
FLAG_HIGH_QUALITY_SCALING
;
auto
size
=
ToUnoriented
(
OrientedIntSize
:
:
FromUnknownSize
(
aSize
)
)
;
LookupResult
result
=
LookupFrame
(
size
flags
ToPlaybackType
(
aWhichFrame
)
true
)
;
if
(
!
result
)
{
if
(
mDrawStartTime
.
IsNull
(
)
)
{
mDrawStartTime
=
TimeStamp
:
:
Now
(
)
;
}
return
ImgDrawResult
:
:
NOT_READY
;
}
bool
shouldRecordTelemetry
=
!
mDrawStartTime
.
IsNull
(
)
&
&
result
.
Surface
(
)
-
>
IsFinished
(
)
;
ImgDrawResult
drawResult
;
{
gfxContextMatrixAutoSaveRestore
asr
;
ImageRegion
region
(
aRegion
)
;
if
(
!
UsedOrientation
(
)
.
IsIdentity
(
)
)
{
gfxMatrix
matrix
=
OrientationMatrix
(
size
)
;
asr
.
SetContext
(
aContext
)
;
aContext
-
>
Multiply
(
matrix
)
;
gfxMatrix
inverseMatrix
=
OrientationMatrix
(
size
true
)
;
region
.
TransformBoundsBy
(
inverseMatrix
)
;
}
drawResult
=
DrawInternal
(
std
:
:
move
(
result
.
Surface
(
)
)
aContext
size
region
aSamplingFilter
flags
aOpacity
)
;
}
if
(
shouldRecordTelemetry
)
{
TimeDuration
drawLatency
=
TimeStamp
:
:
Now
(
)
-
mDrawStartTime
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_ON_DRAW_LATENCY
int32_t
(
drawLatency
.
ToMicroseconds
(
)
)
)
;
mDrawStartTime
=
TimeStamp
(
)
;
}
return
drawResult
;
}
NS_IMETHODIMP
RasterImage
:
:
LockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
to
encourage
serialization
with
UnlockImage
"
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
mLockCount
+
+
;
if
(
mLockCount
=
=
1
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
UnlockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Main
thread
to
encourage
serialization
with
LockImage
"
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mLockCount
>
0
"
Calling
UnlockImage
with
mLockCount
=
=
0
!
"
)
;
if
(
mLockCount
=
=
0
)
{
return
NS_ERROR_ABORT
;
}
mLockCount
-
-
;
if
(
mLockCount
=
=
0
)
{
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
RasterImage
:
:
RequestDiscard
(
)
{
if
(
mDiscardable
&
&
mLockCount
=
=
0
&
&
CanDiscard
(
)
)
{
Discard
(
)
;
}
return
NS_OK
;
}
void
RasterImage
:
:
DoError
(
)
{
if
(
mError
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
)
{
HandleErrorWorker
:
:
DispatchIfNeeded
(
this
)
;
return
;
}
mError
=
true
;
if
(
mAnimating
)
{
StopAnimation
(
)
;
}
mAnimationState
=
Nothing
(
)
;
mFrameAnimator
=
nullptr
;
mLockCount
=
0
;
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
auto
dirtyRect
=
UnorientedIntRect
(
{
0
0
}
ToUnoriented
(
mSize
)
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
MOZ_LOG
(
gImgLog
LogLevel
:
:
Error
(
"
RasterImage
:
[
this
=
%
p
]
Error
detected
for
image
\
n
"
this
)
)
;
}
void
RasterImage
:
:
HandleErrorWorker
:
:
DispatchIfNeeded
(
RasterImage
*
aImage
)
{
RefPtr
<
HandleErrorWorker
>
worker
=
new
HandleErrorWorker
(
aImage
)
;
NS_DispatchToMainThread
(
worker
)
;
}
RasterImage
:
:
HandleErrorWorker
:
:
HandleErrorWorker
(
RasterImage
*
aImage
)
:
Runnable
(
"
image
:
:
RasterImage
:
:
HandleErrorWorker
"
)
mImage
(
aImage
)
{
MOZ_ASSERT
(
mImage
"
Should
have
image
"
)
;
}
NS_IMETHODIMP
RasterImage
:
:
HandleErrorWorker
:
:
Run
(
)
{
mImage
-
>
DoError
(
)
;
return
NS_OK
;
}
bool
RasterImage
:
:
ShouldAnimate
(
)
{
return
ImageResource
:
:
ShouldAnimate
(
)
&
&
mAnimationState
&
&
mAnimationState
-
>
KnownFrameCount
(
)
>
=
1
&
&
!
mAnimationFinished
;
}
#
ifdef
DEBUG
NS_IMETHODIMP
RasterImage
:
:
GetFramesNotified
(
uint32_t
*
aFramesNotified
)
{
NS_ENSURE_ARG_POINTER
(
aFramesNotified
)
;
*
aFramesNotified
=
mFramesNotified
;
return
NS_OK
;
}
#
endif
void
RasterImage
:
:
NotifyProgress
(
Progress
aProgress
const
UnorientedIntRect
&
aInvalidRect
const
Maybe
<
uint32_t
>
&
aFrameCount
DecoderFlags
aDecoderFlags
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
RasterImage
>
image
=
this
;
UnorientedIntRect
invalidRect
=
aInvalidRect
;
if
(
!
(
aDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
)
{
MOZ_ASSERT_IF
(
aFrameCount
&
&
*
aFrameCount
>
1
mAnimationState
|
|
mError
)
;
if
(
mAnimationState
&
&
aFrameCount
)
{
mAnimationState
-
>
UpdateKnownFrameCount
(
*
aFrameCount
)
;
}
if
(
mAnimationState
&
&
aFrameCount
=
=
Some
(
1u
)
&
&
mPendingAnimation
&
&
ShouldAnimate
(
)
)
{
StartAnimation
(
)
;
}
if
(
mAnimationState
)
{
auto
size
=
ToUnoriented
(
mSize
)
;
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
size
.
ToUnknownSize
(
)
)
;
invalidRect
.
UnionRect
(
invalidRect
UnorientedIntRect
:
:
FromUnknownRect
(
rect
)
)
;
}
}
const
bool
wasDefaultFlags
=
aSurfaceFlags
=
=
DefaultSurfaceFlags
(
)
;
auto
orientedInvalidRect
=
ToOriented
(
invalidRect
)
;
if
(
!
orientedInvalidRect
.
IsEmpty
(
)
&
&
wasDefaultFlags
)
{
UpdateImageContainer
(
Some
(
orientedInvalidRect
.
ToUnknownRect
(
)
)
)
;
}
image
-
>
mProgressTracker
-
>
SyncNotifyProgress
(
aProgress
orientedInvalidRect
.
ToUnknownRect
(
)
)
;
}
void
RasterImage
:
:
NotifyDecodeComplete
(
const
DecoderFinalStatus
&
aStatus
const
ImageMetadata
&
aMetadata
const
DecoderTelemetry
&
aTelemetry
Progress
aProgress
const
UnorientedIntRect
&
aInvalidRect
const
Maybe
<
uint32_t
>
&
aFrameCount
DecoderFlags
aDecoderFlags
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aStatus
.
mShouldReportError
)
{
ReportDecoderError
(
)
;
}
bool
metadataOK
=
SetMetadata
(
aMetadata
aStatus
.
mWasMetadataDecode
)
;
if
(
!
metadataOK
)
{
RecoverFromInvalidFrames
(
ToUnoriented
(
mSize
)
FromSurfaceFlags
(
aSurfaceFlags
)
)
;
return
;
}
MOZ_ASSERT
(
mError
|
|
mHasSize
|
|
!
aMetadata
.
HasSize
(
)
"
SetMetadata
should
'
ve
gotten
a
size
"
)
;
if
(
!
aStatus
.
mWasMetadataDecode
&
&
aStatus
.
mFinished
)
{
mHasBeenDecoded
=
true
;
}
NotifyProgress
(
aProgress
aInvalidRect
aFrameCount
aDecoderFlags
aSurfaceFlags
)
;
if
(
!
(
aDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
)
{
MOZ_ASSERT_IF
(
aFrameCount
&
&
*
aFrameCount
>
1
mAnimationState
|
|
mError
)
;
if
(
mAnimationState
&
&
aFrameCount
)
{
mAnimationState
-
>
UpdateKnownFrameCount
(
*
aFrameCount
)
;
}
if
(
mAnimationState
&
&
aFrameCount
=
=
Some
(
1u
)
&
&
mPendingAnimation
&
&
ShouldAnimate
(
)
)
{
StartAnimation
(
)
;
}
if
(
mAnimationState
&
&
mHasBeenDecoded
)
{
mAnimationState
-
>
NotifyDecodeComplete
(
)
;
auto
size
=
ToUnoriented
(
mSize
)
;
IntRect
rect
=
mAnimationState
-
>
UpdateState
(
this
size
.
ToUnknownSize
(
)
)
;
if
(
!
rect
.
IsEmpty
(
)
)
{
auto
dirtyRect
=
UnorientedIntRect
:
:
FromUnknownRect
(
rect
)
;
NotifyProgress
(
NoProgress
dirtyRect
)
;
}
}
}
if
(
!
aStatus
.
mWasMetadataDecode
)
{
if
(
aTelemetry
.
mChunkCount
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_CHUNKS
aTelemetry
.
mChunkCount
)
;
}
if
(
aStatus
.
mFinished
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_DECODE_TIME
int32_t
(
aTelemetry
.
mDecodeTime
.
ToMicroseconds
(
)
)
)
;
if
(
aTelemetry
.
mSpeedHistogram
&
&
aTelemetry
.
mBytesDecoded
)
{
Telemetry
:
:
Accumulate
(
*
aTelemetry
.
mSpeedHistogram
aTelemetry
.
Speed
(
)
)
;
}
}
}
if
(
aStatus
.
mHadError
&
&
(
!
mAnimationState
|
|
mAnimationState
-
>
KnownFrameCount
(
)
=
=
0
)
)
{
DoError
(
)
;
}
else
if
(
aStatus
.
mWasMetadataDecode
&
&
!
mHasSize
)
{
DoError
(
)
;
}
if
(
aStatus
.
mFinished
&
&
aStatus
.
mWasMetadataDecode
)
{
if
(
mLoadProgress
)
{
NotifyForLoadEvent
(
*
mLoadProgress
)
;
mLoadProgress
=
Nothing
(
)
;
}
if
(
mWantFullDecode
)
{
mWantFullDecode
=
false
;
RequestDecodeForSize
(
mSize
.
ToUnknownSize
(
)
DECODE_FLAGS_DEFAULT
|
FLAG_HIGH_QUALITY_SCALING
FRAME_CURRENT
)
;
}
}
}
void
RasterImage
:
:
ReportDecoderError
(
)
{
nsCOMPtr
<
nsIConsoleService
>
consoleService
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
nsCOMPtr
<
nsIScriptError
>
errorObject
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
;
if
(
consoleService
&
&
errorObject
)
{
nsAutoString
msg
(
u
"
Image
corrupt
or
truncated
.
"
_ns
)
;
nsAutoString
src
;
if
(
GetURI
(
)
)
{
nsAutoCString
uri
;
if
(
!
GetSpecTruncatedTo1k
(
uri
)
)
{
msg
+
=
u
"
URI
in
this
note
truncated
due
to
length
.
"
_ns
;
}
CopyUTF8toUTF16
(
uri
src
)
;
}
if
(
NS_SUCCEEDED
(
errorObject
-
>
InitWithWindowID
(
msg
src
u
"
"
_ns
0
0
nsIScriptError
:
:
errorFlag
"
Image
"
InnerWindowID
(
)
)
)
)
{
consoleService
-
>
LogMessage
(
errorObject
)
;
}
}
}
already_AddRefed
<
imgIContainer
>
RasterImage
:
:
Unwrap
(
)
{
nsCOMPtr
<
imgIContainer
>
self
(
this
)
;
return
self
.
forget
(
)
;
}
void
RasterImage
:
:
PropagateUseCounters
(
dom
:
:
Document
*
)
{
}
IntSize
RasterImage
:
:
OptimalImageSizeForDest
(
const
gfxSize
&
aDest
uint32_t
aWhichFrame
SamplingFilter
aSamplingFilter
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aDest
.
width
>
=
0
|
|
ceil
(
aDest
.
width
)
<
=
INT32_MAX
|
|
aDest
.
height
>
=
0
|
|
ceil
(
aDest
.
height
)
<
=
INT32_MAX
"
Unexpected
destination
size
"
)
;
if
(
mSize
.
IsEmpty
(
)
|
|
aDest
.
IsEmpty
(
)
)
{
return
IntSize
(
0
0
)
;
}
auto
dest
=
OrientedIntSize
:
:
FromUnknownSize
(
IntSize
:
:
Ceil
(
aDest
.
width
aDest
.
height
)
)
;
if
(
aSamplingFilter
=
=
SamplingFilter
:
:
GOOD
&
&
CanDownscaleDuringDecode
(
ToUnoriented
(
dest
)
aFlags
)
)
{
return
dest
.
ToUnknownSize
(
)
;
}
return
mSize
.
ToUnknownSize
(
)
;
}
gfxMatrix
RasterImage
:
:
OrientationMatrix
(
const
UnorientedIntSize
&
aSize
bool
aInvert
)
const
{
return
OrientedImage
:
:
OrientationMatrix
(
UsedOrientation
(
)
aSize
.
ToUnknownSize
(
)
aInvert
)
;
}
static
void
Rotate
(
IntRect
&
aRect
const
IntSize
&
aSize
Angle
aAngle
)
{
switch
(
aAngle
)
{
case
Angle
:
:
D0
:
break
;
case
Angle
:
:
D90
:
aRect
=
{
aSize
.
height
-
aRect
.
YMost
(
)
aRect
.
x
aRect
.
height
aRect
.
width
}
;
break
;
case
Angle
:
:
D180
:
aRect
.
MoveTo
(
aSize
.
width
-
aRect
.
XMost
(
)
aSize
.
height
-
aRect
.
YMost
(
)
)
;
break
;
case
Angle
:
:
D270
:
aRect
=
{
aRect
.
y
aSize
.
width
-
aRect
.
XMost
(
)
aRect
.
height
aRect
.
width
}
;
break
;
}
}
static
void
Flip
(
IntRect
&
aRect
const
IntSize
&
aSize
Flip
aFlip
)
{
switch
(
aFlip
)
{
case
Flip
:
:
Unflipped
:
break
;
case
Flip
:
:
Horizontal
:
aRect
.
x
=
aSize
.
width
-
aRect
.
XMost
(
)
;
break
;
}
}
OrientedIntRect
RasterImage
:
:
ToOriented
(
UnorientedIntRect
aRect
)
const
{
IntRect
rect
=
aRect
.
ToUnknownRect
(
)
;
auto
size
=
ToUnoriented
(
mSize
)
;
MOZ_ASSERT
(
!
UsedOrientation
(
)
.
flipFirst
"
flipFirst
should
only
be
used
by
OrientedImage
"
)
;
Angle
angle
=
Orientation
:
:
InvertAngle
(
UsedOrientation
(
)
.
rotation
)
;
Rotate
(
rect
size
.
ToUnknownSize
(
)
angle
)
;
Flip
(
rect
mSize
.
ToUnknownSize
(
)
UsedOrientation
(
)
.
flip
)
;
return
OrientedIntRect
:
:
FromUnknownRect
(
rect
)
;
}
UnorientedIntRect
RasterImage
:
:
ToUnoriented
(
OrientedIntRect
aRect
)
const
{
IntRect
rect
=
aRect
.
ToUnknownRect
(
)
;
Flip
(
rect
mSize
.
ToUnknownSize
(
)
UsedOrientation
(
)
.
flip
)
;
Rotate
(
rect
mSize
.
ToUnknownSize
(
)
UsedOrientation
(
)
.
rotation
)
;
MOZ_ASSERT
(
!
UsedOrientation
(
)
.
flipFirst
"
flipFirst
should
only
be
used
by
OrientedImage
"
)
;
return
UnorientedIntRect
:
:
FromUnknownRect
(
rect
)
;
}
}
}
