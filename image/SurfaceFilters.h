#
ifndef
mozilla_image_SurfaceFilters_h
#
define
mozilla_image_SurfaceFilters_h
#
include
<
algorithm
>
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
DownscalingFilter
.
h
"
#
include
"
SurfaceCache
.
h
"
#
include
"
SurfacePipe
.
h
"
namespace
mozilla
{
namespace
image
{
template
<
typename
PixelType
typename
Next
>
class
DeinterlacingFilter
;
template
<
typename
PixelType
>
struct
DeinterlacingConfig
{
template
<
typename
Next
>
using
Filter
=
DeinterlacingFilter
<
PixelType
Next
>
;
bool
mProgressiveDisplay
;
}
;
template
<
typename
PixelType
typename
Next
>
class
DeinterlacingFilter
final
:
public
SurfaceFilter
{
public
:
DeinterlacingFilter
(
)
:
mInputRow
(
0
)
mOutputRow
(
0
)
mPass
(
0
)
mProgressiveDisplay
(
true
)
{
}
template
<
typename
.
.
.
Rest
>
nsresult
Configure
(
const
DeinterlacingConfig
<
PixelType
>
&
aConfig
Rest
.
.
.
aRest
)
{
nsresult
rv
=
mNext
.
Configure
(
aRest
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
sizeof
(
PixelType
)
=
=
1
&
&
!
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
Paletted
DeinterlacingFilter
used
with
non
-
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
sizeof
(
PixelType
)
=
=
4
&
&
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
Non
-
paletted
DeinterlacingFilter
used
with
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
gfx
:
:
IntSize
outputSize
=
mNext
.
InputSize
(
)
;
mProgressiveDisplay
=
aConfig
.
mProgressiveDisplay
;
const
uint32_t
bufferSize
=
outputSize
.
width
*
outputSize
.
height
*
sizeof
(
PixelType
)
;
if
(
!
SurfaceCache
:
:
CanHold
(
bufferSize
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mBuffer
.
reset
(
new
(
fallible
)
uint8_t
[
bufferSize
]
)
;
if
(
MOZ_UNLIKELY
(
!
mBuffer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint8_t
clear
=
0
;
GetClearValue
(
clear
)
;
memset
(
mBuffer
.
get
(
)
clear
bufferSize
)
;
ConfigureFilter
(
outputSize
sizeof
(
PixelType
)
)
;
return
NS_OK
;
}
bool
IsValidPalettedPipe
(
)
const
override
{
return
sizeof
(
PixelType
)
=
=
1
&
&
mNext
.
IsValidPalettedPipe
(
)
;
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
override
{
return
mNext
.
TakeInvalidRect
(
)
;
}
bool
GetClearValue
(
uint8_t
&
aValue
)
const
override
{
return
mNext
.
GetClearValue
(
aValue
)
;
}
protected
:
void
DoZeroOutRestOfSurface
(
)
override
{
mNext
.
ZeroOutRestOfSurface
(
)
;
mInputRow
=
InputSize
(
)
.
height
;
mPass
=
4
;
}
uint8_t
*
DoResetToFirstRow
(
)
override
{
mNext
.
ResetToFirstRow
(
)
;
mPass
=
0
;
mInputRow
=
0
;
mOutputRow
=
InterlaceOffset
(
mPass
)
;
return
GetRowPointer
(
mOutputRow
)
;
}
uint8_t
*
DoAdvanceRow
(
)
override
{
if
(
mPass
>
=
4
)
{
return
nullptr
;
}
if
(
mInputRow
>
=
InputSize
(
)
.
height
)
{
return
nullptr
;
}
DuplicateRows
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
mOutputRow
)
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
)
;
OutputRows
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
mOutputRow
)
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
)
;
bool
advancedPass
=
false
;
uint32_t
stride
=
InterlaceStride
(
mPass
)
;
int32_t
nextOutputRow
=
mOutputRow
+
stride
;
while
(
nextOutputRow
>
=
InputSize
(
)
.
height
)
{
if
(
!
advancedPass
)
{
OutputRows
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
InputSize
(
)
.
height
)
;
}
mPass
+
+
;
if
(
mPass
>
=
4
)
{
return
nullptr
;
}
mNext
.
ResetToFirstRow
(
)
;
advancedPass
=
true
;
stride
=
InterlaceStride
(
mPass
)
;
nextOutputRow
=
InterlaceOffset
(
mPass
)
;
}
MOZ_ASSERT
(
nextOutputRow
>
=
0
)
;
MOZ_ASSERT
(
nextOutputRow
<
InputSize
(
)
.
height
)
;
MOZ_ASSERT
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
>
=
0
)
;
MOZ_ASSERT
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
<
InputSize
(
)
.
height
)
;
MOZ_ASSERT
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
<
=
nextOutputRow
)
;
MOZ_ASSERT
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
nextOutputRow
)
>
=
0
)
;
MOZ_ASSERT
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
nextOutputRow
)
<
=
InputSize
(
)
.
height
)
;
MOZ_ASSERT
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
nextOutputRow
)
>
nextOutputRow
)
;
int32_t
nextHaeberliOutputRow
=
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
;
if
(
advancedPass
)
{
OutputRows
(
0
nextHaeberliOutputRow
)
;
}
else
{
OutputRows
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
nextHaeberliOutputRow
)
;
}
mInputRow
+
+
;
mOutputRow
=
nextOutputRow
;
return
GetRowPointer
(
nextHaeberliOutputRow
)
;
}
private
:
static
uint32_t
InterlaceOffset
(
uint32_t
aPass
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
offset
[
]
=
{
0
4
2
1
}
;
return
offset
[
aPass
]
;
}
static
uint32_t
InterlaceStride
(
uint32_t
aPass
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
stride
[
]
=
{
8
8
4
2
}
;
return
stride
[
aPass
]
;
}
static
int32_t
HaeberliOutputStartRow
(
uint32_t
aPass
bool
aProgressiveDisplay
int32_t
aOutputRow
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
firstRowOffset
[
]
=
{
3
1
0
0
}
;
if
(
aProgressiveDisplay
)
{
return
std
:
:
max
(
aOutputRow
-
firstRowOffset
[
aPass
]
0
)
;
}
else
{
return
aOutputRow
;
}
}
static
int32_t
HaeberliOutputUntilRow
(
uint32_t
aPass
bool
aProgressiveDisplay
const
gfx
:
:
IntSize
&
aInputSize
int32_t
aOutputRow
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
lastRowOffset
[
]
=
{
4
2
1
0
}
;
if
(
aProgressiveDisplay
)
{
return
std
:
:
min
(
aOutputRow
+
lastRowOffset
[
aPass
]
aInputSize
.
height
-
1
)
+
1
;
}
else
{
return
aOutputRow
+
1
;
}
}
void
DuplicateRows
(
int32_t
aStart
int32_t
aUntil
)
{
MOZ_ASSERT
(
aStart
>
=
0
)
;
MOZ_ASSERT
(
aUntil
>
=
0
)
;
if
(
aUntil
<
=
aStart
|
|
aStart
>
=
InputSize
(
)
.
height
)
{
return
;
}
const
uint8_t
*
sourceRowPointer
=
GetRowPointer
(
aStart
)
;
for
(
int32_t
destRow
=
aStart
+
1
;
destRow
<
aUntil
;
+
+
destRow
)
{
uint8_t
*
destRowPointer
=
GetRowPointer
(
destRow
)
;
memcpy
(
destRowPointer
sourceRowPointer
InputSize
(
)
.
width
*
sizeof
(
PixelType
)
)
;
}
}
void
OutputRows
(
int32_t
aStart
int32_t
aUntil
)
{
MOZ_ASSERT
(
aStart
>
=
0
)
;
MOZ_ASSERT
(
aUntil
>
=
0
)
;
if
(
aUntil
<
=
aStart
|
|
aStart
>
=
InputSize
(
)
.
height
)
{
return
;
}
for
(
int32_t
rowToOutput
=
aStart
;
rowToOutput
<
aUntil
;
+
+
rowToOutput
)
{
mNext
.
WriteBuffer
(
reinterpret_cast
<
PixelType
*
>
(
GetRowPointer
(
rowToOutput
)
)
)
;
}
}
uint8_t
*
GetRowPointer
(
uint32_t
aRow
)
const
{
uint32_t
offset
=
aRow
*
InputSize
(
)
.
width
*
sizeof
(
PixelType
)
;
MOZ_ASSERT
(
offset
<
InputSize
(
)
.
width
*
InputSize
(
)
.
height
*
sizeof
(
PixelType
)
"
Start
of
row
is
outside
of
image
"
)
;
MOZ_ASSERT
(
offset
+
InputSize
(
)
.
width
*
sizeof
(
PixelType
)
<
=
InputSize
(
)
.
width
*
InputSize
(
)
.
height
*
sizeof
(
PixelType
)
"
End
of
row
is
outside
of
image
"
)
;
return
mBuffer
.
get
(
)
+
offset
;
}
Next
mNext
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
int32_t
mInputRow
;
int32_t
mOutputRow
;
uint8_t
mPass
;
bool
mProgressiveDisplay
;
}
;
template
<
typename
Next
>
class
RemoveFrameRectFilter
;
struct
RemoveFrameRectConfig
{
template
<
typename
Next
>
using
Filter
=
RemoveFrameRectFilter
<
Next
>
;
gfx
:
:
IntRect
mFrameRect
;
}
;
template
<
typename
Next
>
class
RemoveFrameRectFilter
final
:
public
SurfaceFilter
{
public
:
RemoveFrameRectFilter
(
)
:
mRow
(
0
)
{
}
template
<
typename
.
.
.
Rest
>
nsresult
Configure
(
const
RemoveFrameRectConfig
&
aConfig
Rest
.
.
.
aRest
)
{
nsresult
rv
=
mNext
.
Configure
(
aRest
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
RemoveFrameRectFilter
used
with
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
mFrameRect
=
mUnclampedFrameRect
=
aConfig
.
mFrameRect
;
gfx
:
:
IntSize
outputSize
=
mNext
.
InputSize
(
)
;
if
(
aConfig
.
mFrameRect
.
width
<
0
|
|
aConfig
.
mFrameRect
.
height
<
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
gfx
:
:
IntRect
outputRect
(
0
0
outputSize
.
width
outputSize
.
height
)
;
mFrameRect
=
mFrameRect
.
Intersect
(
outputRect
)
;
if
(
mFrameRect
.
IsEmpty
(
)
)
{
mFrameRect
.
MoveTo
(
0
0
)
;
}
if
(
mFrameRect
.
width
<
mUnclampedFrameRect
.
width
)
{
mBuffer
.
reset
(
new
(
fallible
)
uint8_t
[
mUnclampedFrameRect
.
width
*
sizeof
(
uint32_t
)
]
)
;
if
(
MOZ_UNLIKELY
(
!
mBuffer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint8_t
clear
=
0
;
GetClearValue
(
clear
)
;
memset
(
mBuffer
.
get
(
)
clear
mUnclampedFrameRect
.
width
*
sizeof
(
uint32_t
)
)
;
}
ConfigureFilter
(
mUnclampedFrameRect
.
Size
(
)
sizeof
(
uint32_t
)
)
;
return
NS_OK
;
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
override
{
return
mNext
.
TakeInvalidRect
(
)
;
}
bool
GetClearValue
(
uint8_t
&
aValue
)
const
override
{
return
mNext
.
GetClearValue
(
aValue
)
;
}
protected
:
void
DoZeroOutRestOfSurface
(
)
override
{
mNext
.
ZeroOutRestOfSurface
(
)
;
mRow
=
mFrameRect
.
YMost
(
)
;
}
uint8_t
*
DoResetToFirstRow
(
)
override
{
uint8_t
*
rowPtr
=
mNext
.
ResetToFirstRow
(
)
;
if
(
rowPtr
=
=
nullptr
)
{
mRow
=
mFrameRect
.
YMost
(
)
;
return
nullptr
;
}
mRow
=
mUnclampedFrameRect
.
y
;
if
(
mFrameRect
.
y
>
0
)
{
for
(
int32_t
rowToOutput
=
0
;
rowToOutput
<
mFrameRect
.
y
;
+
+
rowToOutput
)
{
mNext
.
WriteEmptyRow
(
)
;
}
}
rowPtr
=
mBuffer
?
mBuffer
.
get
(
)
:
mNext
.
CurrentRowPointer
(
)
;
if
(
!
mFrameRect
.
IsEmpty
(
)
|
|
rowPtr
=
=
nullptr
)
{
return
AdjustRowPointer
(
rowPtr
)
;
}
while
(
mNext
.
WriteEmptyRow
(
)
=
=
WriteState
:
:
NEED_MORE_DATA
)
{
}
mRow
=
mFrameRect
.
YMost
(
)
;
return
nullptr
;
}
uint8_t
*
DoAdvanceRow
(
)
override
{
uint8_t
*
rowPtr
=
nullptr
;
const
int32_t
currentRow
=
mRow
;
mRow
+
+
;
if
(
currentRow
<
mFrameRect
.
y
)
{
rowPtr
=
mBuffer
?
mBuffer
.
get
(
)
:
mNext
.
CurrentRowPointer
(
)
;
return
AdjustRowPointer
(
rowPtr
)
;
}
else
if
(
currentRow
>
=
mFrameRect
.
YMost
(
)
)
{
NS_WARNING
(
"
RemoveFrameRectFilter
:
Advancing
past
end
of
frame
rect
"
)
;
return
nullptr
;
}
if
(
mBuffer
)
{
uint32_t
*
source
=
reinterpret_cast
<
uint32_t
*
>
(
mBuffer
.
get
(
)
)
-
std
:
:
min
(
mUnclampedFrameRect
.
x
0
)
;
WriteState
state
=
mNext
.
WriteBuffer
(
source
mFrameRect
.
x
mFrameRect
.
width
)
;
rowPtr
=
state
=
=
WriteState
:
:
NEED_MORE_DATA
?
mBuffer
.
get
(
)
:
nullptr
;
}
else
{
uint8_t
*
currentRowPtr
=
CurrentRowPointer
(
)
;
if
(
currentRowPtr
)
{
uint8_t
clear
=
0
;
if
(
GetClearValue
(
clear
)
)
{
gfx
:
:
IntSize
outputSize
=
mNext
.
InputSize
(
)
;
const
size_t
pixelSize
=
sizeof
(
uint32_t
)
;
const
size_t
prefixOffset
=
mFrameRect
.
x
*
pixelSize
;
const
size_t
postfixOffset
=
mFrameRect
.
width
*
pixelSize
;
const
size_t
postfixLength
=
(
outputSize
.
width
-
mFrameRect
.
XMost
(
)
)
*
pixelSize
;
memset
(
currentRowPtr
-
prefixOffset
clear
prefixOffset
)
;
memset
(
currentRowPtr
+
postfixOffset
clear
postfixLength
)
;
}
}
rowPtr
=
mNext
.
AdvanceRow
(
)
;
}
if
(
mRow
<
mFrameRect
.
YMost
(
)
|
|
rowPtr
=
=
nullptr
)
{
return
AdjustRowPointer
(
rowPtr
)
;
}
while
(
mNext
.
WriteEmptyRow
(
)
=
=
WriteState
:
:
NEED_MORE_DATA
)
{
}
mRow
=
mFrameRect
.
YMost
(
)
;
return
nullptr
;
}
private
:
uint8_t
*
AdjustRowPointer
(
uint8_t
*
aNextRowPointer
)
const
{
if
(
mBuffer
)
{
MOZ_ASSERT
(
aNextRowPointer
=
=
mBuffer
.
get
(
)
|
|
aNextRowPointer
=
=
nullptr
)
;
return
aNextRowPointer
;
}
if
(
mFrameRect
.
IsEmpty
(
)
|
|
mRow
>
=
mFrameRect
.
YMost
(
)
|
|
aNextRowPointer
=
=
nullptr
)
{
return
nullptr
;
}
return
aNextRowPointer
+
mFrameRect
.
x
*
sizeof
(
uint32_t
)
;
}
Next
mNext
;
gfx
:
:
IntRect
mFrameRect
;
gfx
:
:
IntRect
mUnclampedFrameRect
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
int32_t
mRow
;
}
;
template
<
typename
Next
>
class
ADAM7InterpolatingFilter
;
struct
ADAM7InterpolatingConfig
{
template
<
typename
Next
>
using
Filter
=
ADAM7InterpolatingFilter
<
Next
>
;
}
;
template
<
typename
Next
>
class
ADAM7InterpolatingFilter
final
:
public
SurfaceFilter
{
public
:
ADAM7InterpolatingFilter
(
)
:
mPass
(
0
)
mRow
(
0
)
{
}
template
<
typename
.
.
.
Rest
>
nsresult
Configure
(
const
ADAM7InterpolatingConfig
&
aConfig
Rest
.
.
.
aRest
)
{
nsresult
rv
=
mNext
.
Configure
(
aRest
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
ADAM7InterpolatingFilter
used
with
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
size_t
inputWidthInBytes
=
mNext
.
InputSize
(
)
.
width
*
sizeof
(
uint32_t
)
;
mPreviousRow
.
reset
(
new
(
fallible
)
uint8_t
[
inputWidthInBytes
]
)
;
if
(
MOZ_UNLIKELY
(
!
mPreviousRow
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mCurrentRow
.
reset
(
new
(
fallible
)
uint8_t
[
inputWidthInBytes
]
)
;
if
(
MOZ_UNLIKELY
(
!
mCurrentRow
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint8_t
clear
=
0
;
GetClearValue
(
clear
)
;
memset
(
mPreviousRow
.
get
(
)
clear
inputWidthInBytes
)
;
memset
(
mCurrentRow
.
get
(
)
clear
inputWidthInBytes
)
;
ConfigureFilter
(
mNext
.
InputSize
(
)
sizeof
(
uint32_t
)
)
;
return
NS_OK
;
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
override
{
return
mNext
.
TakeInvalidRect
(
)
;
}
bool
GetClearValue
(
uint8_t
&
aValue
)
const
override
{
return
mNext
.
GetClearValue
(
aValue
)
;
}
protected
:
void
DoZeroOutRestOfSurface
(
)
override
{
mNext
.
ZeroOutRestOfSurface
(
)
;
mRow
=
InputSize
(
)
.
height
;
mPass
=
7
;
}
uint8_t
*
DoResetToFirstRow
(
)
override
{
mRow
=
0
;
mPass
=
std
:
:
min
(
mPass
+
1
7
)
;
uint8_t
*
rowPtr
=
mNext
.
ResetToFirstRow
(
)
;
if
(
mPass
=
=
7
)
{
return
rowPtr
;
}
return
mCurrentRow
.
get
(
)
;
}
uint8_t
*
DoAdvanceRow
(
)
override
{
MOZ_ASSERT
(
0
<
mPass
&
&
mPass
<
=
7
"
Invalid
pass
"
)
;
int32_t
currentRow
=
mRow
;
+
+
mRow
;
if
(
mPass
=
=
7
)
{
return
mNext
.
AdvanceRow
(
)
;
}
const
int32_t
lastImportantRow
=
LastImportantRow
(
InputSize
(
)
.
height
mPass
)
;
if
(
currentRow
>
lastImportantRow
)
{
return
nullptr
;
}
if
(
!
IsImportantRow
(
currentRow
mPass
)
)
{
return
mCurrentRow
.
get
(
)
;
}
InterpolateHorizontally
(
mCurrentRow
.
get
(
)
InputSize
(
)
.
width
mPass
)
;
if
(
currentRow
!
=
0
)
{
InterpolateVertically
(
mPreviousRow
.
get
(
)
mCurrentRow
.
get
(
)
mPass
mNext
)
;
}
uint32_t
*
currentRowAsPixels
=
reinterpret_cast
<
uint32_t
*
>
(
mCurrentRow
.
get
(
)
)
;
mNext
.
WriteBuffer
(
currentRowAsPixels
)
;
if
(
currentRow
=
=
lastImportantRow
)
{
while
(
mNext
.
WriteBuffer
(
currentRowAsPixels
)
=
=
WriteState
:
:
NEED_MORE_DATA
)
{
}
return
nullptr
;
}
Swap
(
mPreviousRow
mCurrentRow
)
;
MOZ_ASSERT
(
mRow
<
InputSize
(
)
.
height
"
Reached
the
end
of
the
surface
without
"
"
hitting
the
last
important
row
?
"
)
;
return
mCurrentRow
.
get
(
)
;
}
private
:
static
void
InterpolateVertically
(
uint8_t
*
aPreviousRow
uint8_t
*
aCurrentRow
uint8_t
aPass
SurfaceFilter
&
aNext
)
{
const
float
*
weights
=
InterpolationWeights
(
ImportantRowStride
(
aPass
)
)
;
for
(
int32_t
outRow
=
1
;
outRow
<
ImportantRowStride
(
aPass
)
;
+
+
outRow
)
{
const
float
weight
=
weights
[
outRow
]
;
uint8_t
*
prevRowBytes
=
aPreviousRow
;
uint8_t
*
currRowBytes
=
aCurrentRow
;
aNext
.
template
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
uint32_t
pixel
=
0
;
auto
*
component
=
reinterpret_cast
<
uint8_t
*
>
(
&
pixel
)
;
*
component
+
+
=
InterpolateByte
(
*
prevRowBytes
+
+
*
currRowBytes
+
+
weight
)
;
*
component
+
+
=
InterpolateByte
(
*
prevRowBytes
+
+
*
currRowBytes
+
+
weight
)
;
*
component
+
+
=
InterpolateByte
(
*
prevRowBytes
+
+
*
currRowBytes
+
+
weight
)
;
*
component
+
+
=
InterpolateByte
(
*
prevRowBytes
+
+
*
currRowBytes
+
+
weight
)
;
return
AsVariant
(
pixel
)
;
}
)
;
}
}
static
void
InterpolateHorizontally
(
uint8_t
*
aRow
int32_t
aWidth
uint8_t
aPass
)
{
const
size_t
finalPixelStride
=
FinalPixelStride
(
aPass
)
;
const
size_t
finalPixelStrideBytes
=
finalPixelStride
*
sizeof
(
uint32_t
)
;
const
size_t
lastFinalPixel
=
LastFinalPixel
(
aWidth
aPass
)
;
const
size_t
lastFinalPixelBytes
=
lastFinalPixel
*
sizeof
(
uint32_t
)
;
const
float
*
weights
=
InterpolationWeights
(
finalPixelStride
)
;
for
(
size_t
blockBytes
=
0
;
blockBytes
<
lastFinalPixelBytes
;
blockBytes
+
=
finalPixelStrideBytes
)
{
uint8_t
*
finalPixelA
=
aRow
+
blockBytes
;
uint8_t
*
finalPixelB
=
aRow
+
blockBytes
+
finalPixelStrideBytes
;
MOZ_ASSERT
(
finalPixelA
<
aRow
+
aWidth
*
sizeof
(
uint32_t
)
"
Running
off
end
of
buffer
"
)
;
MOZ_ASSERT
(
finalPixelB
<
aRow
+
aWidth
*
sizeof
(
uint32_t
)
"
Running
off
end
of
buffer
"
)
;
for
(
size_t
pixelIndex
=
1
;
pixelIndex
<
finalPixelStride
;
+
+
pixelIndex
)
{
const
float
weight
=
weights
[
pixelIndex
]
;
uint8_t
*
pixel
=
aRow
+
blockBytes
+
pixelIndex
*
sizeof
(
uint32_t
)
;
MOZ_ASSERT
(
pixel
<
aRow
+
aWidth
*
sizeof
(
uint32_t
)
"
Running
off
end
of
buffer
"
)
;
for
(
size_t
component
=
0
;
component
<
sizeof
(
uint32_t
)
;
+
+
component
)
{
pixel
[
component
]
=
InterpolateByte
(
finalPixelA
[
component
]
finalPixelB
[
component
]
weight
)
;
}
}
}
uint32_t
*
rowPixels
=
reinterpret_cast
<
uint32_t
*
>
(
aRow
)
;
uint32_t
pixelToDuplicate
=
rowPixels
[
lastFinalPixel
]
;
for
(
int32_t
pixelIndex
=
lastFinalPixel
+
1
;
pixelIndex
<
aWidth
;
+
+
pixelIndex
)
{
MOZ_ASSERT
(
pixelIndex
<
aWidth
"
Running
off
end
of
buffer
"
)
;
rowPixels
[
pixelIndex
]
=
pixelToDuplicate
;
}
}
static
uint8_t
InterpolateByte
(
uint8_t
aByteA
uint8_t
aByteB
float
aWeight
)
{
return
uint8_t
(
aByteA
*
aWeight
+
aByteB
*
(
1
.
0f
-
aWeight
)
)
;
}
static
int32_t
ImportantRowStride
(
uint8_t
aPass
)
{
MOZ_ASSERT
(
0
<
aPass
&
&
aPass
<
=
7
"
Invalid
pass
"
)
;
static
int32_t
strides
[
]
=
{
1
8
8
4
4
2
2
1
}
;
return
strides
[
aPass
]
;
}
static
bool
IsImportantRow
(
int32_t
aRow
uint8_t
aPass
)
{
MOZ_ASSERT
(
aRow
>
=
0
)
;
int32_t
mask
=
ImportantRowStride
(
aPass
)
-
1
;
return
(
aRow
&
mask
)
=
=
0
;
}
static
int32_t
LastImportantRow
(
int32_t
aHeight
uint8_t
aPass
)
{
MOZ_ASSERT
(
aHeight
>
0
)
;
int32_t
lastRow
=
aHeight
-
1
;
int32_t
mask
=
ImportantRowStride
(
aPass
)
-
1
;
return
lastRow
-
(
lastRow
&
mask
)
;
}
static
size_t
FinalPixelStride
(
uint8_t
aPass
)
{
MOZ_ASSERT
(
0
<
aPass
&
&
aPass
<
=
7
"
Invalid
pass
"
)
;
static
size_t
strides
[
]
=
{
1
8
4
4
2
2
1
1
}
;
return
strides
[
aPass
]
;
}
static
size_t
LastFinalPixel
(
int32_t
aWidth
uint8_t
aPass
)
{
MOZ_ASSERT
(
aWidth
>
=
0
)
;
int32_t
lastColumn
=
aWidth
-
1
;
size_t
mask
=
FinalPixelStride
(
aPass
)
-
1
;
return
lastColumn
-
(
lastColumn
&
mask
)
;
}
static
const
float
*
InterpolationWeights
(
int32_t
aStride
)
{
static
float
stride8Weights
[
]
=
{
1
.
0f
7
/
8
.
0f
6
/
8
.
0f
5
/
8
.
0f
4
/
8
.
0f
3
/
8
.
0f
2
/
8
.
0f
1
/
8
.
0f
}
;
static
float
stride4Weights
[
]
=
{
1
.
0f
3
/
4
.
0f
2
/
4
.
0f
1
/
4
.
0f
}
;
static
float
stride2Weights
[
]
=
{
1
.
0f
1
/
2
.
0f
}
;
static
float
stride1Weights
[
]
=
{
1
.
0f
}
;
switch
(
aStride
)
{
case
8
:
return
stride8Weights
;
case
4
:
return
stride4Weights
;
case
2
:
return
stride2Weights
;
case
1
:
return
stride1Weights
;
default
:
MOZ_CRASH
(
)
;
}
}
Next
mNext
;
UniquePtr
<
uint8_t
[
]
>
mPreviousRow
;
UniquePtr
<
uint8_t
[
]
>
mCurrentRow
;
uint8_t
mPass
;
int32_t
mRow
;
}
;
}
}
#
endif
