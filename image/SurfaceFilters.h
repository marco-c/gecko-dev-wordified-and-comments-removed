#
ifndef
mozilla_image_SurfaceFilters_h
#
define
mozilla_image_SurfaceFilters_h
#
include
<
stdint
.
h
>
#
include
<
string
.
h
>
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
DownscalingFilter
.
h
"
#
include
"
SurfacePipe
.
h
"
namespace
mozilla
{
namespace
image
{
template
<
typename
PixelType
typename
Next
>
class
DeinterlacingFilter
;
template
<
typename
PixelType
>
struct
DeinterlacingConfig
{
template
<
typename
Next
>
using
Filter
=
DeinterlacingFilter
<
PixelType
Next
>
;
bool
mProgressiveDisplay
;
}
;
template
<
typename
PixelType
typename
Next
>
class
DeinterlacingFilter
final
:
public
SurfaceFilter
{
public
:
DeinterlacingFilter
(
)
:
mInputRow
(
0
)
mOutputRow
(
0
)
mPass
(
0
)
mProgressiveDisplay
(
true
)
{
}
template
<
typename
.
.
.
Rest
>
nsresult
Configure
(
const
DeinterlacingConfig
<
PixelType
>
&
aConfig
Rest
.
.
.
aRest
)
{
nsresult
rv
=
mNext
.
Configure
(
aRest
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
sizeof
(
PixelType
)
=
=
1
&
&
!
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
Paletted
DeinterlacingFilter
used
with
non
-
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
sizeof
(
PixelType
)
=
=
4
&
&
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
Non
-
paletted
DeinterlacingFilter
used
with
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
gfx
:
:
IntSize
outputSize
=
mNext
.
InputSize
(
)
;
mProgressiveDisplay
=
aConfig
.
mProgressiveDisplay
;
const
uint32_t
bufferSize
=
outputSize
.
width
*
outputSize
.
height
*
sizeof
(
PixelType
)
;
mBuffer
.
reset
(
new
(
fallible
)
uint8_t
[
bufferSize
]
)
;
if
(
MOZ_UNLIKELY
(
!
mBuffer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
memset
(
mBuffer
.
get
(
)
0
bufferSize
)
;
ConfigureFilter
(
outputSize
sizeof
(
PixelType
)
)
;
return
NS_OK
;
}
bool
IsValidPalettedPipe
(
)
const
override
{
return
sizeof
(
PixelType
)
=
=
1
&
&
mNext
.
IsValidPalettedPipe
(
)
;
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
override
{
return
mNext
.
TakeInvalidRect
(
)
;
}
protected
:
uint8_t
*
DoResetToFirstRow
(
)
override
{
mNext
.
ResetToFirstRow
(
)
;
mPass
=
0
;
mInputRow
=
0
;
mOutputRow
=
InterlaceOffset
(
mPass
)
;
;
return
GetRowPointer
(
mOutputRow
)
;
}
uint8_t
*
DoAdvanceRow
(
)
override
{
if
(
mPass
>
=
4
)
{
return
nullptr
;
}
if
(
mInputRow
>
=
InputSize
(
)
.
height
)
{
return
nullptr
;
}
DuplicateRows
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
mOutputRow
)
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
)
;
OutputRows
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
mOutputRow
)
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
)
;
bool
advancedPass
=
false
;
uint32_t
stride
=
InterlaceStride
(
mPass
)
;
int32_t
nextOutputRow
=
mOutputRow
+
stride
;
while
(
nextOutputRow
>
=
InputSize
(
)
.
height
)
{
if
(
!
advancedPass
)
{
DuplicateRows
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
InputSize
(
)
.
height
)
;
OutputRows
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
InputSize
(
)
.
height
)
;
}
mPass
+
+
;
if
(
mPass
>
=
4
)
{
return
nullptr
;
}
mNext
.
ResetToFirstRow
(
)
;
advancedPass
=
true
;
stride
=
InterlaceStride
(
mPass
)
;
nextOutputRow
=
InterlaceOffset
(
mPass
)
;
}
MOZ_ASSERT
(
nextOutputRow
>
=
0
)
;
MOZ_ASSERT
(
nextOutputRow
<
InputSize
(
)
.
height
)
;
MOZ_ASSERT
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
>
=
0
)
;
MOZ_ASSERT
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
<
InputSize
(
)
.
height
)
;
MOZ_ASSERT
(
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
<
=
nextOutputRow
)
;
MOZ_ASSERT
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
nextOutputRow
)
>
=
0
)
;
MOZ_ASSERT
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
nextOutputRow
)
<
=
InputSize
(
)
.
height
)
;
MOZ_ASSERT
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
nextOutputRow
)
>
nextOutputRow
)
;
int32_t
nextHaeberliOutputRow
=
HaeberliOutputStartRow
(
mPass
mProgressiveDisplay
nextOutputRow
)
;
if
(
advancedPass
)
{
OutputRows
(
0
nextHaeberliOutputRow
)
;
}
else
{
OutputRows
(
HaeberliOutputUntilRow
(
mPass
mProgressiveDisplay
InputSize
(
)
mOutputRow
)
nextHaeberliOutputRow
)
;
}
mInputRow
+
+
;
mOutputRow
=
nextOutputRow
;
return
GetRowPointer
(
nextHaeberliOutputRow
)
;
}
private
:
static
uint32_t
InterlaceOffset
(
uint32_t
aPass
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
offset
[
]
=
{
0
4
2
1
}
;
return
offset
[
aPass
]
;
}
static
uint32_t
InterlaceStride
(
uint32_t
aPass
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
stride
[
]
=
{
8
8
4
2
}
;
return
stride
[
aPass
]
;
}
static
int32_t
HaeberliOutputStartRow
(
uint32_t
aPass
bool
aProgressiveDisplay
int32_t
aOutputRow
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
firstRowOffset
[
]
=
{
3
1
0
0
}
;
if
(
aProgressiveDisplay
)
{
return
std
:
:
max
(
aOutputRow
-
firstRowOffset
[
aPass
]
0
)
;
}
else
{
return
aOutputRow
;
}
}
static
int32_t
HaeberliOutputUntilRow
(
uint32_t
aPass
bool
aProgressiveDisplay
const
gfx
:
:
IntSize
&
aInputSize
int32_t
aOutputRow
)
{
MOZ_ASSERT
(
aPass
<
4
"
Invalid
pass
"
)
;
static
const
uint8_t
lastRowOffset
[
]
=
{
4
2
1
0
}
;
if
(
aProgressiveDisplay
)
{
return
std
:
:
min
(
aOutputRow
+
lastRowOffset
[
aPass
]
aInputSize
.
height
-
1
)
+
1
;
}
else
{
return
aOutputRow
+
1
;
}
}
void
DuplicateRows
(
int32_t
aStart
int32_t
aUntil
)
{
MOZ_ASSERT
(
aStart
>
=
0
)
;
MOZ_ASSERT
(
aUntil
>
=
0
)
;
if
(
aUntil
<
=
aStart
|
|
aStart
>
=
InputSize
(
)
.
height
)
{
return
;
}
const
uint8_t
*
sourceRowPointer
=
GetRowPointer
(
aStart
)
;
for
(
int32_t
destRow
=
aStart
+
1
;
destRow
<
aUntil
;
+
+
destRow
)
{
uint8_t
*
destRowPointer
=
GetRowPointer
(
destRow
)
;
memcpy
(
destRowPointer
sourceRowPointer
InputSize
(
)
.
width
*
sizeof
(
PixelType
)
)
;
}
}
void
OutputRows
(
int32_t
aStart
int32_t
aUntil
)
{
MOZ_ASSERT
(
aStart
>
=
0
)
;
MOZ_ASSERT
(
aUntil
>
=
0
)
;
if
(
aUntil
<
=
aStart
|
|
aStart
>
=
InputSize
(
)
.
height
)
{
return
;
}
int32_t
rowToOutput
=
aStart
;
mNext
.
template
WriteRows
<
PixelType
>
(
[
&
]
(
PixelType
*
aRow
uint32_t
aLength
)
{
const
uint8_t
*
rowToOutputPointer
=
GetRowPointer
(
rowToOutput
)
;
memcpy
(
aRow
rowToOutputPointer
aLength
*
sizeof
(
PixelType
)
)
;
rowToOutput
+
+
;
return
rowToOutput
>
=
aUntil
?
Some
(
WriteState
:
:
NEED_MORE_DATA
)
:
Nothing
(
)
;
}
)
;
}
uint8_t
*
GetRowPointer
(
uint32_t
aRow
)
const
{
uint32_t
offset
=
aRow
*
InputSize
(
)
.
width
*
sizeof
(
PixelType
)
;
MOZ_ASSERT
(
offset
<
InputSize
(
)
.
width
*
InputSize
(
)
.
height
*
sizeof
(
PixelType
)
"
Start
of
row
is
outside
of
image
"
)
;
MOZ_ASSERT
(
offset
+
InputSize
(
)
.
width
*
sizeof
(
PixelType
)
<
=
InputSize
(
)
.
width
*
InputSize
(
)
.
height
*
sizeof
(
PixelType
)
"
End
of
row
is
outside
of
image
"
)
;
return
mBuffer
.
get
(
)
+
offset
;
}
Next
mNext
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
int32_t
mInputRow
;
int32_t
mOutputRow
;
uint8_t
mPass
;
bool
mProgressiveDisplay
;
}
;
template
<
typename
Next
>
class
RemoveFrameRectFilter
;
struct
RemoveFrameRectConfig
{
template
<
typename
Next
>
using
Filter
=
RemoveFrameRectFilter
<
Next
>
;
gfx
:
:
IntRect
mFrameRect
;
}
;
template
<
typename
Next
>
class
RemoveFrameRectFilter
final
:
public
SurfaceFilter
{
public
:
RemoveFrameRectFilter
(
)
:
mRow
(
0
)
{
}
template
<
typename
.
.
.
Rest
>
nsresult
Configure
(
const
RemoveFrameRectConfig
&
aConfig
Rest
.
.
.
aRest
)
{
nsresult
rv
=
mNext
.
Configure
(
aRest
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mNext
.
IsValidPalettedPipe
(
)
)
{
NS_WARNING
(
"
RemoveFrameRectFilter
used
with
paletted
pipe
?
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
mFrameRect
=
mUnclampedFrameRect
=
aConfig
.
mFrameRect
;
gfx
:
:
IntSize
outputSize
=
mNext
.
InputSize
(
)
;
if
(
aConfig
.
mFrameRect
.
width
<
0
|
|
aConfig
.
mFrameRect
.
height
<
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
gfx
:
:
IntRect
outputRect
(
0
0
outputSize
.
width
outputSize
.
height
)
;
mFrameRect
=
mFrameRect
.
Intersect
(
outputRect
)
;
if
(
mFrameRect
.
IsEmpty
(
)
)
{
mFrameRect
.
MoveTo
(
0
0
)
;
}
if
(
mFrameRect
.
width
<
mUnclampedFrameRect
.
width
)
{
mBuffer
.
reset
(
new
(
fallible
)
uint8_t
[
mUnclampedFrameRect
.
width
*
sizeof
(
uint32_t
)
]
)
;
if
(
MOZ_UNLIKELY
(
!
mBuffer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
memset
(
mBuffer
.
get
(
)
0
mUnclampedFrameRect
.
width
*
sizeof
(
uint32_t
)
)
;
}
ConfigureFilter
(
mUnclampedFrameRect
.
Size
(
)
sizeof
(
uint32_t
)
)
;
return
NS_OK
;
}
Maybe
<
SurfaceInvalidRect
>
TakeInvalidRect
(
)
override
{
return
mNext
.
TakeInvalidRect
(
)
;
}
protected
:
uint8_t
*
DoResetToFirstRow
(
)
override
{
uint8_t
*
rowPtr
=
mNext
.
ResetToFirstRow
(
)
;
if
(
rowPtr
=
=
nullptr
)
{
mRow
=
InputSize
(
)
.
height
;
return
nullptr
;
}
mRow
=
mUnclampedFrameRect
.
y
;
if
(
mFrameRect
.
y
>
0
)
{
int32_t
rowsToWrite
=
mFrameRect
.
y
;
mNext
.
template
WriteRows
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aRow
uint32_t
aLength
)
-
>
Maybe
<
WriteState
>
{
memset
(
aRow
0
aLength
*
sizeof
(
uint32_t
)
)
;
rowsToWrite
-
-
;
return
rowsToWrite
>
0
?
Nothing
(
)
:
Some
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
)
;
}
rowPtr
=
mBuffer
?
mBuffer
.
get
(
)
:
mNext
.
CurrentRowPointer
(
)
;
if
(
!
mFrameRect
.
IsEmpty
(
)
|
|
rowPtr
=
=
nullptr
)
{
return
AdjustRowPointer
(
rowPtr
)
;
}
mNext
.
template
WriteRows
<
uint32_t
>
(
[
]
(
uint32_t
*
aRow
uint32_t
aLength
)
{
memset
(
aRow
0
aLength
*
sizeof
(
uint32_t
)
)
;
return
Nothing
(
)
;
}
)
;
mRow
=
InputSize
(
)
.
height
;
return
nullptr
;
}
uint8_t
*
DoAdvanceRow
(
)
override
{
uint8_t
*
rowPtr
=
nullptr
;
const
int32_t
currentRow
=
mRow
;
mRow
+
+
;
if
(
currentRow
<
mFrameRect
.
y
)
{
rowPtr
=
mBuffer
?
mBuffer
.
get
(
)
:
mNext
.
CurrentRowPointer
(
)
;
return
AdjustRowPointer
(
rowPtr
)
;
}
else
if
(
currentRow
>
=
mFrameRect
.
YMost
(
)
)
{
NS_WARNING
(
"
RemoveFrameRectFilter
:
Advancing
past
end
of
frame
rect
"
)
;
return
nullptr
;
}
if
(
mBuffer
)
{
mNext
.
template
WriteRows
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aRow
uint32_t
aLength
)
{
MOZ_ASSERT
(
mFrameRect
.
x
>
=
0
)
;
MOZ_ASSERT
(
uint32_t
(
mFrameRect
.
x
)
<
aLength
)
;
memset
(
aRow
0
mFrameRect
.
x
*
sizeof
(
uint32_t
)
)
;
MOZ_ASSERT
(
mFrameRect
.
width
>
=
0
)
;
aRow
+
=
mFrameRect
.
x
;
aLength
-
=
std
:
:
min
(
aLength
uint32_t
(
mFrameRect
.
x
)
)
;
uint32_t
toWrite
=
std
:
:
min
(
aLength
uint32_t
(
mFrameRect
.
width
)
)
;
uint8_t
*
source
=
mBuffer
.
get
(
)
-
std
:
:
min
(
mUnclampedFrameRect
.
x
0
)
*
sizeof
(
uint32_t
)
;
MOZ_ASSERT
(
source
>
=
mBuffer
.
get
(
)
)
;
MOZ_ASSERT
(
source
+
toWrite
*
sizeof
(
uint32_t
)
<
=
mBuffer
.
get
(
)
+
mUnclampedFrameRect
.
width
*
sizeof
(
uint32_t
)
)
;
memcpy
(
aRow
source
toWrite
*
sizeof
(
uint32_t
)
)
;
aRow
+
=
toWrite
;
aLength
-
=
std
:
:
min
(
aLength
toWrite
)
;
memset
(
aRow
0
aLength
*
sizeof
(
uint32_t
)
)
;
return
Some
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
)
;
rowPtr
=
mBuffer
.
get
(
)
;
}
else
{
rowPtr
=
mNext
.
AdvanceRow
(
)
;
}
if
(
mRow
<
mFrameRect
.
YMost
(
)
|
|
rowPtr
=
=
nullptr
)
{
return
AdjustRowPointer
(
rowPtr
)
;
}
mNext
.
template
WriteRows
<
uint32_t
>
(
[
]
(
uint32_t
*
aRow
uint32_t
aLength
)
{
memset
(
aRow
0
aLength
*
sizeof
(
uint32_t
)
)
;
return
Nothing
(
)
;
}
)
;
mRow
=
InputSize
(
)
.
height
;
return
nullptr
;
}
private
:
uint8_t
*
AdjustRowPointer
(
uint8_t
*
aNextRowPointer
)
const
{
if
(
mBuffer
)
{
MOZ_ASSERT
(
aNextRowPointer
=
=
mBuffer
.
get
(
)
)
;
return
aNextRowPointer
;
}
if
(
mFrameRect
.
IsEmpty
(
)
|
|
mRow
>
=
mFrameRect
.
YMost
(
)
|
|
aNextRowPointer
=
=
nullptr
)
{
return
nullptr
;
}
return
aNextRowPointer
+
mFrameRect
.
x
*
sizeof
(
uint32_t
)
;
}
Next
mNext
;
gfx
:
:
IntRect
mFrameRect
;
gfx
:
:
IntRect
mUnclampedFrameRect
;
UniquePtr
<
uint8_t
[
]
>
mBuffer
;
int32_t
mRow
;
}
;
}
}
#
endif
