#
include
"
VectorImage
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
imgFrame
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGDocument
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Tuple
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
ISurfaceProvider
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
SVGDocumentWrapper
.
h
"
#
include
"
SVGDrawingParameters
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
SurfaceCache
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
dom
:
:
SVGPreserveAspectRatio_Binding
;
using
namespace
gfx
;
using
namespace
layers
;
namespace
image
{
class
SVGRootRenderingObserver
final
:
public
SVGRenderingObserver
{
public
:
NS_DECL_ISUPPORTS
SVGRootRenderingObserver
(
SVGDocumentWrapper
*
aDocWrapper
VectorImage
*
aVectorImage
)
:
SVGRenderingObserver
(
)
mDocWrapper
(
aDocWrapper
)
mVectorImage
(
aVectorImage
)
mHonoringInvalidations
(
true
)
{
MOZ_ASSERT
(
mDocWrapper
"
Need
a
non
-
null
SVG
document
wrapper
"
)
;
MOZ_ASSERT
(
mVectorImage
"
Need
a
non
-
null
VectorImage
"
)
;
StartObserving
(
)
;
Element
*
elem
=
GetReferencedElementWithoutObserving
(
)
;
MOZ_ASSERT
(
elem
"
no
root
SVG
node
for
us
to
observe
"
)
;
SVGObserverUtils
:
:
AddRenderingObserver
(
elem
this
)
;
mInObserverList
=
true
;
}
void
ResumeHonoringInvalidations
(
)
{
mHonoringInvalidations
=
true
;
}
protected
:
virtual
~
SVGRootRenderingObserver
(
)
{
StopObserving
(
)
;
}
Element
*
GetReferencedElementWithoutObserving
(
)
final
{
return
mDocWrapper
-
>
GetRootSVGElem
(
)
;
}
virtual
void
OnRenderingChange
(
)
override
{
Element
*
elem
=
GetReferencedElementWithoutObserving
(
)
;
MOZ_ASSERT
(
elem
"
missing
root
SVG
node
"
)
;
if
(
mHonoringInvalidations
&
&
!
mDocWrapper
-
>
ShouldIgnoreInvalidation
(
)
)
{
nsIFrame
*
frame
=
elem
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
frame
-
>
PresShell
(
)
-
>
IsDestroying
(
)
)
{
return
;
}
mHonoringInvalidations
=
false
;
mVectorImage
-
>
InvalidateObserversOnNextRefreshDriverTick
(
)
;
}
if
(
!
mInObserverList
)
{
SVGObserverUtils
:
:
AddRenderingObserver
(
elem
this
)
;
mInObserverList
=
true
;
}
}
const
RefPtr
<
SVGDocumentWrapper
>
mDocWrapper
;
VectorImage
*
const
mVectorImage
;
bool
mHonoringInvalidations
;
}
;
NS_IMPL_ISUPPORTS
(
SVGRootRenderingObserver
nsIMutationObserver
)
class
SVGParseCompleteListener
final
:
public
nsStubDocumentObserver
{
public
:
NS_DECL_ISUPPORTS
SVGParseCompleteListener
(
SVGDocument
*
aDocument
VectorImage
*
aImage
)
:
mDocument
(
aDocument
)
mImage
(
aImage
)
{
MOZ_ASSERT
(
mDocument
"
Need
an
SVG
document
"
)
;
MOZ_ASSERT
(
mImage
"
Need
an
image
"
)
;
mDocument
-
>
AddObserver
(
this
)
;
}
private
:
~
SVGParseCompleteListener
(
)
{
if
(
mDocument
)
{
Cancel
(
)
;
}
}
public
:
void
EndLoad
(
Document
*
aDocument
)
override
{
MOZ_ASSERT
(
aDocument
=
=
mDocument
"
Got
EndLoad
for
wrong
document
?
"
)
;
RefPtr
<
SVGParseCompleteListener
>
kungFuDeathGrip
(
this
)
;
mImage
-
>
OnSVGDocumentParsed
(
)
;
}
void
Cancel
(
)
{
MOZ_ASSERT
(
mDocument
"
Duplicate
call
to
Cancel
"
)
;
if
(
mDocument
)
{
mDocument
-
>
RemoveObserver
(
this
)
;
mDocument
=
nullptr
;
}
}
private
:
RefPtr
<
SVGDocument
>
mDocument
;
VectorImage
*
const
mImage
;
}
;
NS_IMPL_ISUPPORTS
(
SVGParseCompleteListener
nsIDocumentObserver
)
class
SVGLoadEventListener
final
:
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
SVGLoadEventListener
(
Document
*
aDocument
VectorImage
*
aImage
)
:
mDocument
(
aDocument
)
mImage
(
aImage
)
{
MOZ_ASSERT
(
mDocument
"
Need
an
SVG
document
"
)
;
MOZ_ASSERT
(
mImage
"
Need
an
image
"
)
;
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
MozSVGAsImageDocumentLoad
"
)
this
true
false
)
;
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
SVGAbort
"
)
this
true
false
)
;
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
SVGError
"
)
this
true
false
)
;
}
private
:
~
SVGLoadEventListener
(
)
{
if
(
mDocument
)
{
Cancel
(
)
;
}
}
public
:
NS_IMETHOD
HandleEvent
(
Event
*
aEvent
)
override
{
MOZ_ASSERT
(
mDocument
"
Need
an
SVG
document
.
Received
multiple
events
?
"
)
;
RefPtr
<
SVGLoadEventListener
>
kungFuDeathGrip
(
this
)
;
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
MOZ_ASSERT
(
eventType
.
EqualsLiteral
(
"
MozSVGAsImageDocumentLoad
"
)
|
|
eventType
.
EqualsLiteral
(
"
SVGAbort
"
)
|
|
eventType
.
EqualsLiteral
(
"
SVGError
"
)
"
Received
unexpected
event
"
)
;
if
(
eventType
.
EqualsLiteral
(
"
MozSVGAsImageDocumentLoad
"
)
)
{
mImage
-
>
OnSVGDocumentLoaded
(
)
;
}
else
{
mImage
-
>
OnSVGDocumentError
(
)
;
}
return
NS_OK
;
}
void
Cancel
(
)
{
MOZ_ASSERT
(
mDocument
"
Duplicate
call
to
Cancel
"
)
;
if
(
mDocument
)
{
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
MozSVGAsImageDocumentLoad
"
)
this
true
)
;
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
SVGAbort
"
)
this
true
)
;
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
SVGError
"
)
this
true
)
;
mDocument
=
nullptr
;
}
}
private
:
nsCOMPtr
<
Document
>
mDocument
;
VectorImage
*
const
mImage
;
}
;
NS_IMPL_ISUPPORTS
(
SVGLoadEventListener
nsIDOMEventListener
)
class
SVGDrawingCallback
:
public
gfxDrawingCallback
{
public
:
SVGDrawingCallback
(
SVGDocumentWrapper
*
aSVGDocumentWrapper
const
IntSize
&
aViewportSize
const
IntSize
&
aSize
uint32_t
aImageFlags
)
:
mSVGDocumentWrapper
(
aSVGDocumentWrapper
)
mViewportSize
(
aViewportSize
)
mSize
(
aSize
)
mImageFlags
(
aImageFlags
)
{
}
virtual
bool
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
SamplingFilter
aSamplingFilter
const
gfxMatrix
&
aTransform
)
override
;
private
:
RefPtr
<
SVGDocumentWrapper
>
mSVGDocumentWrapper
;
const
IntSize
mViewportSize
;
const
IntSize
mSize
;
uint32_t
mImageFlags
;
}
;
bool
SVGDrawingCallback
:
:
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
SamplingFilter
aSamplingFilter
const
gfxMatrix
&
aTransform
)
{
MOZ_ASSERT
(
mSVGDocumentWrapper
"
need
an
SVGDocumentWrapper
"
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mSVGDocumentWrapper
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
"
GetPresShell
returned
null
for
an
SVG
image
?
"
)
;
#
ifdef
MOZ_GECKO_PROFILER
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
nsIURI
*
uri
=
doc
?
doc
-
>
GetDocumentURI
(
)
:
nullptr
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
SVG
Image
drawing
"
GRAPHICS
nsPrintfCString
(
"
%
dx
%
d
%
s
"
mSize
.
width
mSize
.
height
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
N
/
A
"
)
)
;
#
endif
gfxContextAutoSaveRestore
contextRestorer
(
aContext
)
;
aContext
-
>
NewPath
(
)
;
aContext
-
>
Rectangle
(
aFillRect
)
;
aContext
-
>
Clip
(
)
;
gfxMatrix
matrix
=
aTransform
;
if
(
!
matrix
.
Invert
(
)
)
{
return
false
;
}
aContext
-
>
SetMatrixDouble
(
aContext
-
>
CurrentMatrixDouble
(
)
.
PreMultiply
(
matrix
)
.
PreScale
(
double
(
mSize
.
width
)
/
mViewportSize
.
width
double
(
mSize
.
height
)
/
mViewportSize
.
height
)
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
"
pres
shell
w
/
out
pres
context
"
)
;
nsRect
svgRect
(
0
0
presContext
-
>
DevPixelsToAppUnits
(
mViewportSize
.
width
)
presContext
-
>
DevPixelsToAppUnits
(
mViewportSize
.
height
)
)
;
uint32_t
renderDocFlags
=
nsIPresShell
:
:
RENDER_IGNORE_VIEWPORT_SCROLLING
;
if
(
!
(
mImageFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
)
{
renderDocFlags
|
=
nsIPresShell
:
:
RENDER_ASYNC_DECODE_IMAGES
;
}
presShell
-
>
RenderDocument
(
svgRect
renderDocFlags
NS_RGBA
(
0
0
0
0
)
aContext
)
;
return
true
;
}
class
MOZ_STACK_CLASS
AutoRestoreSVGState
final
{
public
:
AutoRestoreSVGState
(
const
SVGDrawingParameters
&
aParams
SVGDocumentWrapper
*
aSVGDocumentWrapper
bool
&
aIsDrawing
bool
aContextPaint
)
:
mIsDrawing
(
aIsDrawing
)
mPAR
(
aParams
.
svgContext
aSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
)
mTime
(
aSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
aParams
.
animationTime
)
{
MOZ_ASSERT
(
!
aIsDrawing
)
;
MOZ_ASSERT
(
aSVGDocumentWrapper
-
>
GetDocument
(
)
)
;
aIsDrawing
=
true
;
if
(
aContextPaint
)
{
MOZ_ASSERT
(
aParams
.
svgContext
-
>
GetContextPaint
(
)
)
;
mContextPaint
.
emplace
(
*
aParams
.
svgContext
-
>
GetContextPaint
(
)
*
aSVGDocumentWrapper
-
>
GetDocument
(
)
)
;
}
}
private
:
AutoRestore
<
bool
>
mIsDrawing
;
AutoPreserveAspectRatioOverride
mPAR
;
AutoSVGTimeSetRestore
mTime
;
Maybe
<
AutoSetRestoreSVGContextPaint
>
mContextPaint
;
}
;
NS_IMPL_ISUPPORTS
(
VectorImage
imgIContainer
nsIStreamListener
nsIRequestObserver
)
VectorImage
:
:
VectorImage
(
nsIURI
*
aURI
)
:
ImageResource
(
aURI
)
mLockCount
(
0
)
mIsInitialized
(
false
)
mDiscardable
(
false
)
mIsFullyLoaded
(
false
)
mIsDrawing
(
false
)
mHaveAnimations
(
false
)
mHasPendingInvalidation
(
false
)
{
}
VectorImage
:
:
~
VectorImage
(
)
{
CancelAllListeners
(
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
}
nsresult
VectorImage
:
:
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
{
if
(
mIsInitialized
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
MOZ_ASSERT
(
!
mIsFullyLoaded
&
&
!
mHaveAnimations
&
&
!
mError
"
Flags
unexpectedly
set
before
initialization
"
)
;
MOZ_ASSERT
(
!
strcmp
(
aMimeType
IMAGE_SVG_XML
)
"
Unexpected
mimetype
"
)
;
mDiscardable
=
!
!
(
aFlags
&
INIT_FLAG_DISCARDABLE
)
;
if
(
!
mDiscardable
)
{
mLockCount
+
+
;
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
mIsInitialized
=
true
;
return
NS_OK
;
}
size_t
VectorImage
:
:
SizeOfSourceWithComputedFallback
(
SizeOfState
&
aState
)
const
{
if
(
!
mSVGDocumentWrapper
)
{
return
0
;
}
SVGDocument
*
doc
=
mSVGDocumentWrapper
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
0
;
}
nsWindowSizes
windowSizes
(
aState
)
;
doc
-
>
DocAddSizeOfIncludingThis
(
windowSizes
)
;
if
(
windowSizes
.
getTotalSize
(
)
=
=
0
)
{
return
100
*
1024
;
}
return
windowSizes
.
getTotalSize
(
)
;
}
void
VectorImage
:
:
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
SurfaceCache
:
:
CollectSizeOfSurfaces
(
ImageKey
(
this
)
aCounters
aMallocSizeOf
)
;
}
nsresult
VectorImage
:
:
OnImageDataComplete
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
bool
aLastPart
)
{
nsresult
finalStatus
=
OnStopRequest
(
aRequest
aContext
aStatus
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
finalStatus
=
aStatus
;
}
Progress
loadProgress
=
LoadCompleteProgress
(
aLastPart
mError
finalStatus
)
;
if
(
mIsFullyLoaded
|
|
mError
)
{
mProgressTracker
-
>
SyncNotifyProgress
(
loadProgress
)
;
}
else
{
mLoadProgress
=
Some
(
loadProgress
)
;
}
return
finalStatus
;
}
nsresult
VectorImage
:
:
OnImageDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
{
return
OnDataAvailable
(
aRequest
aContext
aInStr
aSourceOffset
aCount
)
;
}
nsresult
VectorImage
:
:
StartAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
ShouldAnimate
(
)
"
Should
not
animate
!
"
)
;
mSVGDocumentWrapper
-
>
StartAnimation
(
)
;
return
NS_OK
;
}
nsresult
VectorImage
:
:
StopAnimation
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mError
)
{
rv
=
NS_ERROR_FAILURE
;
}
else
{
MOZ_ASSERT
(
mIsFullyLoaded
&
&
mHaveAnimations
"
Should
not
have
been
animating
!
"
)
;
mSVGDocumentWrapper
-
>
StopAnimation
(
)
;
}
mAnimating
=
false
;
return
rv
;
}
bool
VectorImage
:
:
ShouldAnimate
(
)
{
return
ImageResource
:
:
ShouldAnimate
(
)
&
&
mIsFullyLoaded
&
&
mHaveAnimations
;
}
NS_IMETHODIMP_
(
void
)
VectorImage
:
:
SetAnimationStartTime
(
const
TimeStamp
&
aTime
)
{
}
NS_IMETHODIMP
VectorImage
:
:
GetWidth
(
int32_t
*
aWidth
)
{
if
(
mError
|
|
!
mIsFullyLoaded
)
{
*
aWidth
=
0
;
return
NS_ERROR_FAILURE
;
}
SVGSVGElement
*
rootElem
=
mSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
;
MOZ_ASSERT
(
rootElem
"
Should
have
a
root
SVG
elem
since
we
finished
"
"
loading
without
errors
"
)
;
int32_t
rootElemWidth
=
rootElem
-
>
GetIntrinsicWidth
(
)
;
if
(
rootElemWidth
<
0
)
{
*
aWidth
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aWidth
=
rootElemWidth
;
return
NS_OK
;
}
nsresult
VectorImage
:
:
GetNativeSizes
(
nsTArray
<
IntSize
>
&
aNativeSizes
)
const
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
size_t
VectorImage
:
:
GetNativeSizesLength
(
)
const
{
return
0
;
}
NS_IMETHODIMP_
(
void
)
VectorImage
:
:
RequestRefresh
(
const
TimeStamp
&
aTime
)
{
if
(
HadRecentRefresh
(
aTime
)
)
{
return
;
}
PendingAnimationTracker
*
tracker
=
mSVGDocumentWrapper
-
>
GetDocument
(
)
-
>
GetPendingAnimationTracker
(
)
;
if
(
tracker
&
&
ShouldAnimate
(
)
)
{
tracker
-
>
TriggerPendingAnimationsOnNextTick
(
aTime
)
;
}
EvaluateAnimation
(
)
;
mSVGDocumentWrapper
-
>
TickRefreshDriver
(
)
;
if
(
mHasPendingInvalidation
)
{
SendInvalidationNotifications
(
)
;
}
}
void
VectorImage
:
:
SendInvalidationNotifications
(
)
{
MOZ_ASSERT
(
mHasPendingInvalidation
)
;
mHasPendingInvalidation
=
false
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
if
(
UpdateImageContainer
(
Nothing
(
)
)
)
{
MOZ_ASSERT
(
mRenderingObserver
"
Should
have
a
rendering
observer
by
now
"
)
;
mRenderingObserver
-
>
ResumeHonoringInvalidations
(
)
;
}
if
(
mProgressTracker
)
{
mProgressTracker
-
>
SyncNotifyProgress
(
FLAG_FRAME_COMPLETE
GetMaxSizedIntRect
(
)
)
;
}
}
NS_IMETHODIMP_
(
IntRect
)
VectorImage
:
:
GetImageSpaceInvalidationRect
(
const
IntRect
&
aRect
)
{
return
aRect
;
}
NS_IMETHODIMP
VectorImage
:
:
GetHeight
(
int32_t
*
aHeight
)
{
if
(
mError
|
|
!
mIsFullyLoaded
)
{
*
aHeight
=
0
;
return
NS_ERROR_FAILURE
;
}
SVGSVGElement
*
rootElem
=
mSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
;
MOZ_ASSERT
(
rootElem
"
Should
have
a
root
SVG
elem
since
we
finished
"
"
loading
without
errors
"
)
;
int32_t
rootElemHeight
=
rootElem
-
>
GetIntrinsicHeight
(
)
;
if
(
rootElemHeight
<
0
)
{
*
aHeight
=
0
;
return
NS_ERROR_FAILURE
;
}
*
aHeight
=
rootElemHeight
;
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
GetIntrinsicSize
(
nsSize
*
aSize
)
{
if
(
mError
|
|
!
mIsFullyLoaded
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
rootFrame
=
mSVGDocumentWrapper
-
>
GetRootLayoutFrame
(
)
;
if
(
!
rootFrame
)
{
return
NS_ERROR_FAILURE
;
}
*
aSize
=
nsSize
(
-
1
-
1
)
;
IntrinsicSize
rfSize
=
rootFrame
-
>
GetIntrinsicSize
(
)
;
if
(
rfSize
.
width
.
GetUnit
(
)
=
=
eStyleUnit_Coord
)
{
aSize
-
>
width
=
rfSize
.
width
.
GetCoordValue
(
)
;
}
if
(
rfSize
.
height
.
GetUnit
(
)
=
=
eStyleUnit_Coord
)
{
aSize
-
>
height
=
rfSize
.
height
.
GetCoordValue
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
GetIntrinsicRatio
(
nsSize
*
aRatio
)
{
if
(
mError
|
|
!
mIsFullyLoaded
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
rootFrame
=
mSVGDocumentWrapper
-
>
GetRootLayoutFrame
(
)
;
if
(
!
rootFrame
)
{
return
NS_ERROR_FAILURE
;
}
*
aRatio
=
rootFrame
-
>
GetIntrinsicRatio
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
Orientation
)
VectorImage
:
:
GetOrientation
(
)
{
return
Orientation
(
)
;
}
NS_IMETHODIMP
VectorImage
:
:
GetType
(
uint16_t
*
aType
)
{
NS_ENSURE_ARG_POINTER
(
aType
)
;
*
aType
=
imgIContainer
:
:
TYPE_VECTOR
;
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
GetProducerId
(
uint32_t
*
aId
)
{
NS_ENSURE_ARG_POINTER
(
aId
)
;
*
aId
=
ImageResource
:
:
GetImageProducerId
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
GetAnimated
(
bool
*
aAnimated
)
{
if
(
mError
|
|
!
mIsFullyLoaded
)
{
return
NS_ERROR_FAILURE
;
}
*
aAnimated
=
mSVGDocumentWrapper
-
>
IsAnimated
(
)
;
return
NS_OK
;
}
int32_t
VectorImage
:
:
GetFirstFrameDelay
(
)
{
if
(
mError
)
{
return
-
1
;
}
if
(
!
mSVGDocumentWrapper
-
>
IsAnimated
(
)
)
{
return
-
1
;
}
return
0
;
}
NS_IMETHODIMP_
(
bool
)
VectorImage
:
:
WillDrawOpaqueNow
(
)
{
return
false
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
VectorImage
:
:
GetFrame
(
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
if
(
mError
)
{
return
nullptr
;
}
SVGSVGElement
*
svgElem
=
mSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
;
MOZ_ASSERT
(
svgElem
"
Should
have
a
root
SVG
elem
since
we
finished
"
"
loading
without
errors
"
)
;
nsIntSize
imageIntSize
(
svgElem
-
>
GetIntrinsicWidth
(
)
svgElem
-
>
GetIntrinsicHeight
(
)
)
;
if
(
imageIntSize
.
IsEmpty
(
)
)
{
return
nullptr
;
}
return
GetFrameAtSize
(
imageIntSize
aWhichFrame
aFlags
)
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
SourceSurface
>
)
VectorImage
:
:
GetFrameAtSize
(
const
IntSize
&
aSize
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
auto
result
=
GetFrameInternal
(
aSize
Nothing
(
)
aWhichFrame
aFlags
)
;
return
Get
<
2
>
(
result
)
.
forget
(
)
;
}
Tuple
<
ImgDrawResult
IntSize
RefPtr
<
SourceSurface
>
>
VectorImage
:
:
GetFrameInternal
(
const
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aWhichFrame
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
)
;
if
(
aSize
.
IsEmpty
(
)
|
|
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_ARGS
aSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
if
(
mError
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_IMAGE
aSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
if
(
!
mIsFullyLoaded
)
{
return
MakeTuple
(
ImgDrawResult
:
:
NOT_READY
aSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
RefPtr
<
SourceSurface
>
sourceSurface
;
IntSize
decodeSize
;
Tie
(
sourceSurface
decodeSize
)
=
LookupCachedSurface
(
aSize
aSVGContext
aFlags
)
;
if
(
sourceSurface
)
{
return
MakeTuple
(
ImgDrawResult
:
:
SUCCESS
decodeSize
std
:
:
move
(
sourceSurface
)
)
;
}
if
(
mIsDrawing
)
{
NS_WARNING
(
"
Refusing
to
make
re
-
entrant
call
to
VectorImage
:
:
Draw
"
)
;
return
MakeTuple
(
ImgDrawResult
:
:
TEMPORARY_ERROR
decodeSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
SVGDrawingParameters
params
(
nullptr
decodeSize
aSize
ImageRegion
:
:
Create
(
decodeSize
)
SamplingFilter
:
:
POINT
aSVGContext
mSVGDocumentWrapper
-
>
GetCurrentTimeAsFloat
(
)
aFlags
1
.
0
)
;
bool
didCache
;
bool
contextPaint
=
aSVGContext
&
&
aSVGContext
-
>
GetContextPaint
(
)
;
AutoRestoreSVGState
autoRestore
(
params
mSVGDocumentWrapper
mIsDrawing
contextPaint
)
;
RefPtr
<
gfxDrawable
>
svgDrawable
=
CreateSVGDrawable
(
params
)
;
RefPtr
<
SourceSurface
>
surface
=
CreateSurface
(
params
svgDrawable
didCache
)
;
if
(
!
surface
)
{
MOZ_ASSERT
(
!
didCache
)
;
return
MakeTuple
(
ImgDrawResult
:
:
TEMPORARY_ERROR
decodeSize
RefPtr
<
SourceSurface
>
(
)
)
;
}
SendFrameComplete
(
didCache
params
.
flags
)
;
return
MakeTuple
(
ImgDrawResult
:
:
SUCCESS
decodeSize
std
:
:
move
(
surface
)
)
;
}
Tuple
<
ImgDrawResult
IntSize
>
VectorImage
:
:
GetImageContainerSize
(
LayerManager
*
aManager
const
IntSize
&
aSize
uint32_t
aFlags
)
{
if
(
mError
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_IMAGE
IntSize
(
0
0
)
)
;
}
if
(
!
mIsFullyLoaded
)
{
return
MakeTuple
(
ImgDrawResult
:
:
NOT_READY
IntSize
(
0
0
)
)
;
}
if
(
mHaveAnimations
|
|
aManager
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_WR
)
{
return
MakeTuple
(
ImgDrawResult
:
:
NOT_SUPPORTED
IntSize
(
0
0
)
)
;
}
if
(
aSize
.
IsEmpty
(
)
)
{
return
MakeTuple
(
ImgDrawResult
:
:
BAD_ARGS
IntSize
(
0
0
)
)
;
}
return
MakeTuple
(
ImgDrawResult
:
:
SUCCESS
aSize
)
;
}
NS_IMETHODIMP_
(
bool
)
VectorImage
:
:
IsImageContainerAvailable
(
LayerManager
*
aManager
uint32_t
aFlags
)
{
if
(
mError
|
|
!
mIsFullyLoaded
|
|
mHaveAnimations
|
|
aManager
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_WR
)
{
return
false
;
}
return
true
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
ImageContainer
>
)
VectorImage
:
:
GetImageContainer
(
LayerManager
*
aManager
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aManager
-
>
GetBackendType
(
)
!
=
LayersBackend
:
:
LAYERS_WR
"
WebRender
should
always
use
GetImageContainerAvailableAtSize
!
"
)
;
return
nullptr
;
}
NS_IMETHODIMP_
(
bool
)
VectorImage
:
:
IsImageContainerAvailableAtSize
(
LayerManager
*
aManager
const
IntSize
&
aSize
uint32_t
aFlags
)
{
return
!
aSize
.
IsEmpty
(
)
&
&
UseSurfaceCacheForSize
(
aSize
)
&
&
IsImageContainerAvailable
(
aManager
aFlags
)
;
}
NS_IMETHODIMP_
(
ImgDrawResult
)
VectorImage
:
:
GetImageContainerAtSize
(
layers
:
:
LayerManager
*
aManager
const
gfx
:
:
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
layers
:
:
ImageContainer
*
*
aOutContainer
)
{
if
(
!
UseSurfaceCacheForSize
(
aSize
)
)
{
return
ImgDrawResult
:
:
NOT_SUPPORTED
;
}
Maybe
<
SVGImageContext
>
newSVGContext
;
MaybeRestrictSVGContext
(
newSVGContext
aSVGContext
aFlags
)
;
uint32_t
flags
=
aFlags
&
~
(
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
)
;
return
GetImageContainerImpl
(
aManager
aSize
newSVGContext
?
newSVGContext
:
aSVGContext
flags
aOutContainer
)
;
}
bool
VectorImage
:
:
MaybeRestrictSVGContext
(
Maybe
<
SVGImageContext
>
&
aNewSVGContext
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
)
{
bool
overridePAR
=
(
aFlags
&
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
)
&
&
aSVGContext
;
bool
haveContextPaint
=
aSVGContext
&
&
aSVGContext
-
>
GetContextPaint
(
)
;
bool
blockContextPaint
=
false
;
if
(
haveContextPaint
)
{
blockContextPaint
=
!
SVGContextPaint
:
:
IsAllowedForImageFromURI
(
mURI
)
;
}
if
(
overridePAR
|
|
blockContextPaint
)
{
aNewSVGContext
=
aSVGContext
;
if
(
overridePAR
)
{
MOZ_ASSERT
(
!
aSVGContext
-
>
GetPreserveAspectRatio
(
)
"
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
is
not
expected
if
a
"
"
preserveAspectRatio
override
is
supplied
"
)
;
Maybe
<
SVGPreserveAspectRatio
>
aspectRatio
=
Some
(
SVGPreserveAspectRatio
(
SVG_PRESERVEASPECTRATIO_NONE
SVG_MEETORSLICE_UNKNOWN
)
)
;
aNewSVGContext
-
>
SetPreserveAspectRatio
(
aspectRatio
)
;
}
if
(
blockContextPaint
)
{
aNewSVGContext
-
>
ClearContextPaint
(
)
;
}
}
return
haveContextPaint
&
&
!
blockContextPaint
;
}
NS_IMETHODIMP_
(
ImgDrawResult
)
VectorImage
:
:
Draw
(
gfxContext
*
aContext
const
nsIntSize
&
aSize
const
ImageRegion
&
aRegion
uint32_t
aWhichFrame
SamplingFilter
aSamplingFilter
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
float
aOpacity
)
{
if
(
aWhichFrame
>
FRAME_MAX_VALUE
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
!
aContext
)
{
return
ImgDrawResult
:
:
BAD_ARGS
;
}
if
(
mError
)
{
return
ImgDrawResult
:
:
BAD_IMAGE
;
}
if
(
!
mIsFullyLoaded
)
{
return
ImgDrawResult
:
:
NOT_READY
;
}
if
(
mAnimationConsumers
=
=
0
)
{
SendOnUnlockedDraw
(
aFlags
)
;
}
if
(
aContext
-
>
GetDrawTarget
(
)
-
>
GetBackendType
(
)
=
=
BackendType
:
:
RECORDING
|
|
!
UseSurfaceCacheForSize
(
aSize
)
)
{
aFlags
|
=
FLAG_BYPASS_SURFACE_CACHE
;
}
MOZ_ASSERT
(
!
(
aFlags
&
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
)
|
|
(
aSVGContext
&
&
aSVGContext
-
>
GetViewportSize
(
)
)
"
Viewport
size
is
required
when
using
"
"
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
"
)
;
float
animTime
=
(
aWhichFrame
=
=
FRAME_FIRST
)
?
0
.
0f
:
mSVGDocumentWrapper
-
>
GetCurrentTimeAsFloat
(
)
;
Maybe
<
SVGImageContext
>
newSVGContext
;
bool
contextPaint
=
MaybeRestrictSVGContext
(
newSVGContext
aSVGContext
aFlags
)
;
SVGDrawingParameters
params
(
aContext
aSize
aSize
aRegion
aSamplingFilter
newSVGContext
?
newSVGContext
:
aSVGContext
animTime
aFlags
aOpacity
)
;
RefPtr
<
SourceSurface
>
sourceSurface
;
Tie
(
sourceSurface
params
.
size
)
=
LookupCachedSurface
(
aSize
params
.
svgContext
aFlags
)
;
if
(
sourceSurface
)
{
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxSurfaceDrawable
(
sourceSurface
params
.
size
)
;
Show
(
drawable
params
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
mIsDrawing
)
{
NS_WARNING
(
"
Refusing
to
make
re
-
entrant
call
to
VectorImage
:
:
Draw
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
AutoRestoreSVGState
autoRestore
(
params
mSVGDocumentWrapper
mIsDrawing
contextPaint
)
;
bool
didCache
;
RefPtr
<
gfxDrawable
>
svgDrawable
=
CreateSVGDrawable
(
params
)
;
sourceSurface
=
CreateSurface
(
params
svgDrawable
didCache
)
;
if
(
!
sourceSurface
)
{
MOZ_ASSERT
(
!
didCache
)
;
Show
(
svgDrawable
params
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxSurfaceDrawable
(
sourceSurface
params
.
size
)
;
Show
(
drawable
params
)
;
SendFrameComplete
(
didCache
params
.
flags
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
already_AddRefed
<
gfxDrawable
>
VectorImage
:
:
CreateSVGDrawable
(
const
SVGDrawingParameters
&
aParams
)
{
RefPtr
<
gfxDrawingCallback
>
cb
=
new
SVGDrawingCallback
(
mSVGDocumentWrapper
aParams
.
viewportSize
aParams
.
size
aParams
.
flags
)
;
RefPtr
<
gfxDrawable
>
svgDrawable
=
new
gfxCallbackDrawable
(
cb
aParams
.
size
)
;
return
svgDrawable
.
forget
(
)
;
}
bool
VectorImage
:
:
UseSurfaceCacheForSize
(
const
IntSize
&
aSize
)
const
{
int32_t
maxSizeKB
=
gfxPrefs
:
:
ImageCacheMaxRasterizedSVGThresholdKB
(
)
;
if
(
maxSizeKB
<
=
0
)
{
return
true
;
}
if
(
!
SurfaceCache
:
:
IsLegalSize
(
aSize
)
)
{
return
false
;
}
return
aSize
.
width
*
aSize
.
height
/
1024
<
=
maxSizeKB
;
}
Tuple
<
RefPtr
<
SourceSurface
>
IntSize
>
VectorImage
:
:
LookupCachedSurface
(
const
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
)
{
if
(
aFlags
&
FLAG_BYPASS_SURFACE_CACHE
)
{
return
MakeTuple
(
RefPtr
<
SourceSurface
>
(
)
aSize
)
;
}
if
(
mHaveAnimations
)
{
return
MakeTuple
(
RefPtr
<
SourceSurface
>
(
)
aSize
)
;
}
LookupResult
result
(
MatchType
:
:
NOT_FOUND
)
;
SurfaceKey
surfaceKey
=
VectorSurfaceKey
(
aSize
aSVGContext
)
;
if
(
(
aFlags
&
FLAG_SYNC_DECODE
)
|
|
!
(
aFlags
&
FLAG_HIGH_QUALITY_SCALING
)
)
{
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
this
)
surfaceKey
true
)
;
}
else
{
result
=
SurfaceCache
:
:
LookupBestMatch
(
ImageKey
(
this
)
surfaceKey
true
)
;
}
IntSize
rasterSize
=
result
.
SuggestedSize
(
)
.
IsEmpty
(
)
?
aSize
:
result
.
SuggestedSize
(
)
;
MOZ_ASSERT
(
result
.
Type
(
)
!
=
MatchType
:
:
SUBSTITUTE_BECAUSE_PENDING
)
;
if
(
!
result
|
|
result
.
Type
(
)
=
=
MatchType
:
:
SUBSTITUTE_BECAUSE_NOT_FOUND
)
{
return
MakeTuple
(
RefPtr
<
SourceSurface
>
(
)
rasterSize
)
;
}
RefPtr
<
SourceSurface
>
sourceSurface
=
result
.
Surface
(
)
-
>
GetSourceSurface
(
)
;
if
(
!
sourceSurface
)
{
RecoverFromLossOfSurfaces
(
)
;
return
MakeTuple
(
RefPtr
<
SourceSurface
>
(
)
rasterSize
)
;
}
return
MakeTuple
(
std
:
:
move
(
sourceSurface
)
rasterSize
)
;
}
already_AddRefed
<
SourceSurface
>
VectorImage
:
:
CreateSurface
(
const
SVGDrawingParameters
&
aParams
gfxDrawable
*
aSVGDrawable
bool
&
aWillCache
)
{
MOZ_ASSERT
(
mIsDrawing
)
;
mSVGDocumentWrapper
-
>
UpdateViewportBounds
(
aParams
.
viewportSize
)
;
mSVGDocumentWrapper
-
>
FlushImageTransformInvalidation
(
)
;
aWillCache
=
!
(
aParams
.
flags
&
FLAG_BYPASS_SURFACE_CACHE
)
&
&
!
mHaveAnimations
&
&
SurfaceCache
:
:
CanHold
(
aParams
.
size
)
;
if
(
!
aWillCache
&
&
aParams
.
context
)
{
return
nullptr
;
}
if
(
aWillCache
)
{
SurfaceCache
:
:
UnlockEntries
(
ImageKey
(
this
)
)
;
}
BackendType
backend
=
aParams
.
context
?
aParams
.
context
-
>
GetDrawTarget
(
)
-
>
GetBackendType
(
)
:
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
;
auto
frame
=
MakeNotNull
<
RefPtr
<
imgFrame
>
>
(
)
;
nsresult
rv
=
frame
-
>
InitWithDrawable
(
aSVGDrawable
aParams
.
size
SurfaceFormat
:
:
B8G8R8A8
SamplingFilter
:
:
POINT
aParams
.
flags
backend
aParams
.
context
?
aParams
.
context
-
>
GetDrawTarget
(
)
:
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
aWillCache
=
false
;
return
nullptr
;
}
RefPtr
<
SourceSurface
>
surface
=
frame
-
>
GetSourceSurface
(
)
;
if
(
!
surface
)
{
aWillCache
=
false
;
return
nullptr
;
}
if
(
!
aWillCache
)
{
return
surface
.
forget
(
)
;
}
SurfaceKey
surfaceKey
=
VectorSurfaceKey
(
aParams
.
size
aParams
.
svgContext
)
;
NotNull
<
RefPtr
<
ISurfaceProvider
>
>
provider
=
MakeNotNull
<
SimpleSurfaceProvider
*
>
(
ImageKey
(
this
)
surfaceKey
frame
)
;
if
(
SurfaceCache
:
:
Insert
(
provider
)
=
=
InsertOutcome
:
:
SUCCESS
&
&
aParams
.
size
!
=
aParams
.
drawSize
)
{
SurfaceCache
:
:
PruneImage
(
ImageKey
(
this
)
)
;
}
return
surface
.
forget
(
)
;
}
void
VectorImage
:
:
SendFrameComplete
(
bool
aDidCache
uint32_t
aFlags
)
{
if
(
!
aDidCache
)
{
return
;
}
if
(
!
(
aFlags
&
FLAG_ASYNC_NOTIFY
)
)
{
mProgressTracker
-
>
SyncNotifyProgress
(
FLAG_FRAME_COMPLETE
GetMaxSizedIntRect
(
)
)
;
}
else
{
NotNull
<
RefPtr
<
VectorImage
>
>
image
=
WrapNotNull
(
this
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
ProgressTracker
:
:
SyncNotifyProgress
"
[
=
]
(
)
-
>
void
{
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
if
(
tracker
)
{
tracker
-
>
SyncNotifyProgress
(
FLAG_FRAME_COMPLETE
GetMaxSizedIntRect
(
)
)
;
}
}
)
)
;
}
}
void
VectorImage
:
:
Show
(
gfxDrawable
*
aDrawable
const
SVGDrawingParameters
&
aParams
)
{
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aParams
.
context
)
;
ImageRegion
region
(
aParams
.
region
)
;
if
(
aParams
.
drawSize
!
=
aParams
.
size
)
{
gfx
:
:
Size
scale
(
double
(
aParams
.
drawSize
.
width
)
/
aParams
.
size
.
width
double
(
aParams
.
drawSize
.
height
)
/
aParams
.
size
.
height
)
;
aParams
.
context
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scale
.
width
scale
.
height
)
)
;
region
.
Scale
(
1
.
0
/
scale
.
width
1
.
0
/
scale
.
height
)
;
}
MOZ_ASSERT
(
aDrawable
"
Should
have
a
gfxDrawable
by
now
"
)
;
gfxUtils
:
:
DrawPixelSnapped
(
aParams
.
context
aDrawable
SizeDouble
(
aParams
.
size
)
region
SurfaceFormat
:
:
B8G8R8A8
aParams
.
samplingFilter
aParams
.
flags
aParams
.
opacity
false
)
;
#
ifdef
DEBUG
NotifyDrawingObservers
(
)
;
#
endif
MOZ_ASSERT
(
mRenderingObserver
"
Should
have
a
rendering
observer
by
now
"
)
;
mRenderingObserver
-
>
ResumeHonoringInvalidations
(
)
;
}
void
VectorImage
:
:
RecoverFromLossOfSurfaces
(
)
{
NS_WARNING
(
"
An
imgFrame
became
invalid
.
Attempting
to
recover
.
.
.
"
)
;
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
}
NS_IMETHODIMP
VectorImage
:
:
StartDecoding
(
uint32_t
aFlags
)
{
return
NS_OK
;
}
bool
VectorImage
:
:
StartDecodingWithResult
(
uint32_t
aFlags
)
{
return
mIsFullyLoaded
;
}
NS_IMETHODIMP
VectorImage
:
:
RequestDecodeForSize
(
const
nsIntSize
&
aSize
uint32_t
aFlags
)
{
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
LockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
mLockCount
+
+
;
if
(
mLockCount
=
=
1
)
{
SurfaceCache
:
:
LockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
UnlockImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mLockCount
=
=
0
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Calling
UnlockImage
with
a
zero
lock
count
"
)
;
return
NS_ERROR_ABORT
;
}
mLockCount
-
-
;
if
(
mLockCount
=
=
0
)
{
SurfaceCache
:
:
UnlockImage
(
ImageKey
(
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
RequestDiscard
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mDiscardable
&
&
mLockCount
=
=
0
)
{
SurfaceCache
:
:
RemoveImage
(
ImageKey
(
this
)
)
;
mProgressTracker
-
>
OnDiscard
(
)
;
}
return
NS_OK
;
}
void
VectorImage
:
:
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
{
MOZ_ASSERT
(
mProgressTracker
)
;
NS_DispatchToMainThread
(
NewRunnableMethod
(
"
ProgressTracker
:
:
OnDiscard
"
mProgressTracker
&
ProgressTracker
:
:
OnDiscard
)
)
;
}
NS_IMETHODIMP
VectorImage
:
:
ResetAnimation
(
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mIsFullyLoaded
|
|
!
mHaveAnimations
)
{
return
NS_OK
;
}
mSVGDocumentWrapper
-
>
ResetAnimation
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
float
)
VectorImage
:
:
GetFrameIndex
(
uint32_t
aWhichFrame
)
{
MOZ_ASSERT
(
aWhichFrame
<
=
FRAME_MAX_VALUE
"
Invalid
argument
"
)
;
return
aWhichFrame
=
=
FRAME_FIRST
?
0
.
0f
:
mSVGDocumentWrapper
-
>
GetCurrentTimeAsFloat
(
)
;
}
NS_IMETHODIMP
VectorImage
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aCtxt
)
{
MOZ_ASSERT
(
!
mSVGDocumentWrapper
"
Repeated
call
to
OnStartRequest
-
-
can
this
happen
?
"
)
;
mSVGDocumentWrapper
=
new
SVGDocumentWrapper
(
)
;
nsresult
rv
=
mSVGDocumentWrapper
-
>
OnStartRequest
(
aRequest
aCtxt
)
;
if
(
NS_FAILED
(
rv
)
)
{
mSVGDocumentWrapper
=
nullptr
;
mError
=
true
;
return
rv
;
}
SVGDocument
*
document
=
mSVGDocumentWrapper
-
>
GetDocument
(
)
;
mLoadEventListener
=
new
SVGLoadEventListener
(
document
this
)
;
mParseCompleteListener
=
new
SVGParseCompleteListener
(
document
this
)
;
return
NS_OK
;
}
NS_IMETHODIMP
VectorImage
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aCtxt
nsresult
aStatus
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
return
mSVGDocumentWrapper
-
>
OnStopRequest
(
aRequest
aCtxt
aStatus
)
;
}
void
VectorImage
:
:
OnSVGDocumentParsed
(
)
{
MOZ_ASSERT
(
mParseCompleteListener
"
Should
have
the
parse
complete
listener
"
)
;
MOZ_ASSERT
(
mLoadEventListener
"
Should
have
the
load
event
listener
"
)
;
if
(
!
mSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
)
{
OnSVGDocumentError
(
)
;
}
}
void
VectorImage
:
:
CancelAllListeners
(
)
{
if
(
mParseCompleteListener
)
{
mParseCompleteListener
-
>
Cancel
(
)
;
mParseCompleteListener
=
nullptr
;
}
if
(
mLoadEventListener
)
{
mLoadEventListener
-
>
Cancel
(
)
;
mLoadEventListener
=
nullptr
;
}
}
void
VectorImage
:
:
OnSVGDocumentLoaded
(
)
{
MOZ_ASSERT
(
mSVGDocumentWrapper
-
>
GetRootSVGElem
(
)
"
Should
have
parsed
successfully
"
)
;
MOZ_ASSERT
(
!
mIsFullyLoaded
&
&
!
mHaveAnimations
"
These
flags
shouldn
'
t
get
set
until
OnSVGDocumentLoaded
.
"
"
Duplicate
calls
to
OnSVGDocumentLoaded
?
"
)
;
CancelAllListeners
(
)
;
mSVGDocumentWrapper
-
>
FlushLayout
(
)
;
mIsFullyLoaded
=
true
;
mHaveAnimations
=
mSVGDocumentWrapper
-
>
IsAnimated
(
)
;
mRenderingObserver
=
new
SVGRootRenderingObserver
(
mSVGDocumentWrapper
this
)
;
RefPtr
<
VectorImage
>
kungFuDeathGrip
(
this
)
;
if
(
mProgressTracker
)
{
Progress
progress
=
FLAG_SIZE_AVAILABLE
|
FLAG_HAS_TRANSPARENCY
|
FLAG_FRAME_COMPLETE
|
FLAG_DECODE_COMPLETE
;
if
(
mHaveAnimations
)
{
progress
|
=
FLAG_IS_ANIMATED
;
}
if
(
mLoadProgress
)
{
progress
|
=
*
mLoadProgress
;
mLoadProgress
=
Nothing
(
)
;
}
mProgressTracker
-
>
SyncNotifyProgress
(
progress
GetMaxSizedIntRect
(
)
)
;
}
EvaluateAnimation
(
)
;
}
void
VectorImage
:
:
OnSVGDocumentError
(
)
{
CancelAllListeners
(
)
;
mError
=
true
;
if
(
mProgressTracker
)
{
Progress
progress
=
FLAG_HAS_ERROR
;
if
(
mLoadProgress
)
{
progress
|
=
*
mLoadProgress
;
mLoadProgress
=
Nothing
(
)
;
}
mProgressTracker
-
>
SyncNotifyProgress
(
progress
)
;
}
}
NS_IMETHODIMP
VectorImage
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aCtxt
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
{
if
(
mError
)
{
return
NS_ERROR_FAILURE
;
}
return
mSVGDocumentWrapper
-
>
OnDataAvailable
(
aRequest
aCtxt
aInStr
aSourceOffset
aCount
)
;
}
void
VectorImage
:
:
InvalidateObserversOnNextRefreshDriverTick
(
)
{
if
(
mHasPendingInvalidation
)
{
return
;
}
mHasPendingInvalidation
=
true
;
if
(
mHaveAnimations
)
{
return
;
}
nsCOMPtr
<
nsIEventTarget
>
eventTarget
;
if
(
mProgressTracker
)
{
eventTarget
=
mProgressTracker
-
>
GetEventTarget
(
)
;
}
else
{
eventTarget
=
do_GetMainThread
(
)
;
}
RefPtr
<
VectorImage
>
self
(
this
)
;
nsCOMPtr
<
nsIRunnable
>
ev
(
NS_NewRunnableFunction
(
"
VectorImage
:
:
SendInvalidationNotifications
"
[
=
]
(
)
-
>
void
{
self
-
>
SendInvalidationNotifications
(
)
;
}
)
)
;
eventTarget
-
>
Dispatch
(
ev
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
VectorImage
:
:
PropagateUseCounters
(
Document
*
aParentDocument
)
{
Document
*
doc
=
mSVGDocumentWrapper
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
PropagateUseCounters
(
aParentDocument
)
;
}
}
void
VectorImage
:
:
ReportUseCounters
(
)
{
if
(
Document
*
doc
=
mSVGDocumentWrapper
-
>
GetDocument
(
)
)
{
doc
-
>
ReportUseCounters
(
)
;
}
}
nsIntSize
VectorImage
:
:
OptimalImageSizeForDest
(
const
gfxSize
&
aDest
uint32_t
aWhichFrame
SamplingFilter
aSamplingFilter
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aDest
.
width
>
=
0
|
|
ceil
(
aDest
.
width
)
<
=
INT32_MAX
|
|
aDest
.
height
>
=
0
|
|
ceil
(
aDest
.
height
)
<
=
INT32_MAX
"
Unexpected
destination
size
"
)
;
return
nsIntSize
:
:
Ceil
(
aDest
.
width
aDest
.
height
)
;
}
already_AddRefed
<
imgIContainer
>
VectorImage
:
:
Unwrap
(
)
{
nsCOMPtr
<
imgIContainer
>
self
(
this
)
;
return
self
.
forget
(
)
;
}
}
}
