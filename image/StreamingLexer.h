#
ifndef
mozilla_image_StreamingLexer_h
#
define
mozilla_image_StreamingLexer_h
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
{
namespace
image
{
enum
class
BufferingStrategy
{
BUFFERED
UNBUFFERED
}
;
enum
class
TerminalState
{
SUCCESS
FAILURE
}
;
enum
class
Yield
{
NEED_MORE_DATA
}
;
typedef
Variant
<
TerminalState
Yield
>
LexerResult
;
template
<
typename
State
>
class
LexerTransition
{
public
:
MOZ_IMPLICIT
LexerTransition
(
TerminalState
aFinalState
)
:
mNextState
(
aFinalState
)
{
}
bool
NextStateIsTerminal
(
)
const
{
return
mNextState
.
template
is
<
TerminalState
>
(
)
;
}
TerminalState
NextStateAsTerminal
(
)
const
{
return
mNextState
.
template
as
<
TerminalState
>
(
)
;
}
State
NextState
(
)
const
{
return
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mState
;
}
State
UnbufferedState
(
)
const
{
return
*
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mUnbufferedState
;
}
size_t
Size
(
)
const
{
return
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mSize
;
}
BufferingStrategy
Buffering
(
)
const
{
return
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mBufferingStrategy
;
}
private
:
friend
struct
Transition
;
LexerTransition
(
State
aNextState
const
Maybe
<
State
>
&
aUnbufferedState
size_t
aSize
BufferingStrategy
aBufferingStrategy
)
:
mNextState
(
NonTerminalState
(
aNextState
aUnbufferedState
aSize
aBufferingStrategy
)
)
{
}
struct
NonTerminalState
{
State
mState
;
Maybe
<
State
>
mUnbufferedState
;
size_t
mSize
;
BufferingStrategy
mBufferingStrategy
;
NonTerminalState
(
State
aState
const
Maybe
<
State
>
&
aUnbufferedState
size_t
aSize
BufferingStrategy
aBufferingStrategy
)
:
mState
(
aState
)
mUnbufferedState
(
aUnbufferedState
)
mSize
(
aSize
)
mBufferingStrategy
(
aBufferingStrategy
)
{
MOZ_ASSERT_IF
(
mBufferingStrategy
=
=
BufferingStrategy
:
:
UNBUFFERED
mUnbufferedState
)
;
MOZ_ASSERT_IF
(
mUnbufferedState
mBufferingStrategy
=
=
BufferingStrategy
:
:
UNBUFFERED
)
;
}
}
;
Variant
<
NonTerminalState
TerminalState
>
mNextState
;
}
;
struct
Transition
{
template
<
typename
State
>
static
LexerTransition
<
State
>
To
(
const
State
&
aNextState
size_t
aSize
)
{
return
LexerTransition
<
State
>
(
aNextState
Nothing
(
)
aSize
BufferingStrategy
:
:
BUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
ToUnbuffered
(
const
State
&
aNextState
const
State
&
aUnbufferedState
size_t
aSize
)
{
return
LexerTransition
<
State
>
(
aNextState
Some
(
aUnbufferedState
)
aSize
BufferingStrategy
:
:
UNBUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
ContinueUnbuffered
(
const
State
&
aUnbufferedState
)
{
return
LexerTransition
<
State
>
(
aUnbufferedState
Nothing
(
)
0
BufferingStrategy
:
:
BUFFERED
)
;
}
static
TerminalState
TerminateSuccess
(
)
{
return
TerminalState
:
:
SUCCESS
;
}
static
TerminalState
TerminateFailure
(
)
{
return
TerminalState
:
:
FAILURE
;
}
private
:
Transition
(
)
;
}
;
template
<
typename
State
size_t
InlineBufferSize
=
16
>
class
StreamingLexer
{
public
:
explicit
StreamingLexer
(
LexerTransition
<
State
>
aStartState
)
:
mTransition
(
TerminalState
:
:
FAILURE
)
{
SetTransition
(
aStartState
)
;
}
template
<
typename
Func
>
LexerResult
Lex
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
Func
aFunc
)
{
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
LexerResult
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
Maybe
<
LexerResult
>
result
;
do
{
MOZ_ASSERT_IF
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
mUnbufferedState
)
;
const
size_t
toRead
=
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
?
mUnbufferedState
-
>
mBytesRemaining
:
mTransition
.
Size
(
)
-
mBuffer
.
length
(
)
;
switch
(
aIterator
.
AdvanceOrScheduleResume
(
toRead
aOnResume
)
)
{
case
SourceBufferIterator
:
:
WAITING
:
result
=
Some
(
LexerResult
(
Yield
:
:
NEED_MORE_DATA
)
)
;
break
;
case
SourceBufferIterator
:
:
COMPLETE
:
result
=
SetTransition
(
NS_SUCCEEDED
(
aIterator
.
CompletionStatus
(
)
)
?
Transition
:
:
TerminateSuccess
(
)
:
Transition
:
:
TerminateFailure
(
)
)
;
break
;
case
SourceBufferIterator
:
:
READY
:
MOZ_ASSERT
(
aIterator
.
Data
(
)
)
;
result
=
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
?
UnbufferedRead
(
aIterator
aFunc
)
:
BufferedRead
(
aIterator
aFunc
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
SourceBufferIterator
state
"
)
;
result
=
SetTransition
(
Transition
:
:
TerminateFailure
(
)
)
;
}
}
while
(
!
result
)
;
return
*
result
;
}
private
:
template
<
typename
Func
>
Maybe
<
LexerResult
>
UnbufferedRead
(
SourceBufferIterator
&
aIterator
Func
aFunc
)
{
MOZ_ASSERT
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
)
;
MOZ_ASSERT
(
mUnbufferedState
)
;
MOZ_ASSERT
(
mBuffer
.
empty
(
)
"
Buffered
read
at
the
same
time
as
unbuffered
read
?
"
)
;
MOZ_ASSERT
(
aIterator
.
Length
(
)
<
=
mUnbufferedState
-
>
mBytesRemaining
"
Read
too
much
data
during
unbuffered
read
?
"
)
;
if
(
mUnbufferedState
-
>
mBytesRemaining
>
0
)
{
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aIterator
.
Data
(
)
aIterator
.
Length
(
)
)
;
if
(
unbufferedTransition
.
NextStateIsTerminal
(
)
)
{
return
SetTransition
(
unbufferedTransition
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
mUnbufferedState
-
>
mBytesRemaining
-
=
std
:
:
min
(
mUnbufferedState
-
>
mBytesRemaining
aIterator
.
Length
(
)
)
;
if
(
mUnbufferedState
-
>
mBytesRemaining
!
=
0
)
{
return
Nothing
(
)
;
}
}
return
SetTransition
(
aFunc
(
mTransition
.
NextState
(
)
nullptr
0
)
)
;
}
template
<
typename
Func
>
Maybe
<
LexerResult
>
BufferedRead
(
SourceBufferIterator
&
aIterator
Func
aFunc
)
{
MOZ_ASSERT
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
BUFFERED
)
;
MOZ_ASSERT
(
!
mUnbufferedState
"
Buffered
read
at
the
same
time
as
unbuffered
read
?
"
)
;
MOZ_ASSERT
(
mBuffer
.
length
(
)
<
mTransition
.
Size
(
)
|
|
(
mBuffer
.
length
(
)
=
=
0
&
&
mTransition
.
Size
(
)
=
=
0
)
"
Buffered
more
than
we
needed
?
"
)
;
if
(
mBuffer
.
empty
(
)
&
&
aIterator
.
Length
(
)
=
=
mTransition
.
Size
(
)
)
{
return
SetTransition
(
aFunc
(
mTransition
.
NextState
(
)
aIterator
.
Data
(
)
aIterator
.
Length
(
)
)
)
;
}
if
(
!
mBuffer
.
reserve
(
mTransition
.
Size
(
)
)
)
{
return
SetTransition
(
Transition
:
:
TerminateFailure
(
)
)
;
}
if
(
!
mBuffer
.
append
(
aIterator
.
Data
(
)
aIterator
.
Length
(
)
)
)
{
return
SetTransition
(
Transition
:
:
TerminateFailure
(
)
)
;
}
if
(
mBuffer
.
length
(
)
!
=
mTransition
.
Size
(
)
)
{
return
Nothing
(
)
;
}
return
SetTransition
(
aFunc
(
mTransition
.
NextState
(
)
mBuffer
.
begin
(
)
mBuffer
.
length
(
)
)
)
;
}
Maybe
<
LexerResult
>
SetTransition
(
const
LexerTransition
<
State
>
&
aTransition
)
{
mTransition
=
aTransition
;
mBuffer
.
clear
(
)
;
mUnbufferedState
=
Nothing
(
)
;
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
Some
(
LexerResult
(
mTransition
.
NextStateAsTerminal
(
)
)
)
;
}
if
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
)
{
mUnbufferedState
.
emplace
(
mTransition
.
Size
(
)
)
;
}
return
Nothing
(
)
;
}
struct
UnbufferedState
{
explicit
UnbufferedState
(
size_t
aBytesRemaining
)
:
mBytesRemaining
(
aBytesRemaining
)
{
}
size_t
mBytesRemaining
;
}
;
Vector
<
char
InlineBufferSize
>
mBuffer
;
LexerTransition
<
State
>
mTransition
;
Maybe
<
UnbufferedState
>
mUnbufferedState
;
}
;
}
}
#
endif
