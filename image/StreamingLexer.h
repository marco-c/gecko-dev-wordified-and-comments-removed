#
ifndef
mozilla_image_StreamingLexer_h
#
define
mozilla_image_StreamingLexer_h
#
include
<
algorithm
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
{
namespace
image
{
enum
class
BufferingStrategy
{
BUFFERED
UNBUFFERED
}
;
template
<
typename
State
>
bool
IsTerminalState
(
State
aState
)
{
return
aState
=
=
State
:
:
SUCCESS
|
|
aState
=
=
State
:
:
FAILURE
;
}
template
<
typename
State
>
class
LexerTransition
{
public
:
State
NextState
(
)
const
{
return
mNextState
;
}
State
UnbufferedState
(
)
const
{
return
*
mUnbufferedState
;
}
size_t
Size
(
)
const
{
return
mSize
;
}
BufferingStrategy
Buffering
(
)
const
{
return
mBufferingStrategy
;
}
private
:
friend
struct
Transition
;
LexerTransition
(
const
State
&
aNextState
const
Maybe
<
State
>
&
aUnbufferedState
size_t
aSize
BufferingStrategy
aBufferingStrategy
)
:
mNextState
(
aNextState
)
mUnbufferedState
(
aUnbufferedState
)
mSize
(
aSize
)
mBufferingStrategy
(
aBufferingStrategy
)
{
MOZ_ASSERT_IF
(
mBufferingStrategy
=
=
BufferingStrategy
:
:
UNBUFFERED
mUnbufferedState
)
;
MOZ_ASSERT_IF
(
mUnbufferedState
mBufferingStrategy
=
=
BufferingStrategy
:
:
UNBUFFERED
)
;
}
State
mNextState
;
Maybe
<
State
>
mUnbufferedState
;
size_t
mSize
;
BufferingStrategy
mBufferingStrategy
;
}
;
struct
Transition
{
template
<
typename
State
>
static
LexerTransition
<
State
>
To
(
const
State
&
aNextState
size_t
aSize
)
{
MOZ_ASSERT
(
!
IsTerminalState
(
aNextState
)
)
;
return
LexerTransition
<
State
>
(
aNextState
Nothing
(
)
aSize
BufferingStrategy
:
:
BUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
ToUnbuffered
(
const
State
&
aNextState
const
State
&
aUnbufferedState
size_t
aSize
)
{
MOZ_ASSERT
(
!
IsTerminalState
(
aNextState
)
)
;
MOZ_ASSERT
(
!
IsTerminalState
(
aUnbufferedState
)
)
;
return
LexerTransition
<
State
>
(
aNextState
Some
(
aUnbufferedState
)
aSize
BufferingStrategy
:
:
UNBUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
ContinueUnbuffered
(
const
State
&
aUnbufferedState
)
{
MOZ_ASSERT
(
!
IsTerminalState
(
aUnbufferedState
)
)
;
return
LexerTransition
<
State
>
(
aUnbufferedState
Nothing
(
)
0
BufferingStrategy
:
:
BUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
Terminate
(
const
State
&
aFinalState
)
{
MOZ_ASSERT
(
IsTerminalState
(
aFinalState
)
)
;
return
LexerTransition
<
State
>
(
aFinalState
Nothing
(
)
0
BufferingStrategy
:
:
BUFFERED
)
;
}
private
:
Transition
(
)
;
}
;
template
<
typename
State
size_t
InlineBufferSize
=
16
>
class
StreamingLexer
{
public
:
explicit
StreamingLexer
(
LexerTransition
<
State
>
aStartState
)
:
mTransition
(
aStartState
)
mToReadUnbuffered
(
0
)
{
}
template
<
typename
Func
>
Maybe
<
State
>
Lex
(
const
char
*
aInput
size_t
aLength
Func
aFunc
)
{
if
(
IsTerminalState
(
mTransition
.
NextState
(
)
)
)
{
return
Some
(
mTransition
.
NextState
(
)
)
;
}
if
(
mToReadUnbuffered
>
0
)
{
MOZ_ASSERT
(
mBuffer
.
empty
(
)
"
Shouldn
'
t
be
continuing
an
unbuffered
read
and
a
buffered
"
"
read
at
the
same
time
"
)
;
size_t
toRead
=
std
:
:
min
(
mToReadUnbuffered
aLength
)
;
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aInput
toRead
)
;
if
(
IsTerminalState
(
unbufferedTransition
.
NextState
(
)
)
)
{
mTransition
=
unbufferedTransition
;
return
Some
(
mTransition
.
NextState
(
)
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
aInput
+
=
toRead
;
aLength
-
=
toRead
;
mToReadUnbuffered
-
=
toRead
;
if
(
mToReadUnbuffered
!
=
0
)
{
return
Nothing
(
)
;
}
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
nullptr
0
)
;
if
(
IsTerminalState
(
mTransition
.
NextState
(
)
)
)
{
return
Some
(
mTransition
.
NextState
(
)
)
;
}
}
else
if
(
0
<
mBuffer
.
length
(
)
)
{
MOZ_ASSERT
(
mToReadUnbuffered
=
=
0
"
Shouldn
'
t
be
continuing
an
unbuffered
read
and
a
buffered
"
"
read
at
the
same
time
"
)
;
MOZ_ASSERT
(
mBuffer
.
length
(
)
<
mTransition
.
Size
(
)
"
Buffered
more
than
we
needed
?
"
)
;
size_t
toRead
=
std
:
:
min
(
aLength
mTransition
.
Size
(
)
-
mBuffer
.
length
(
)
)
;
mBuffer
.
append
(
aInput
toRead
)
;
aInput
+
=
toRead
;
aLength
-
=
toRead
;
if
(
mBuffer
.
length
(
)
!
=
mTransition
.
Size
(
)
)
{
return
Nothing
(
)
;
}
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
mBuffer
.
begin
(
)
mBuffer
.
length
(
)
)
;
mBuffer
.
clear
(
)
;
if
(
IsTerminalState
(
mTransition
.
NextState
(
)
)
)
{
return
Some
(
mTransition
.
NextState
(
)
)
;
}
}
MOZ_ASSERT
(
mToReadUnbuffered
=
=
0
)
;
MOZ_ASSERT
(
mBuffer
.
empty
(
)
)
;
while
(
mTransition
.
Size
(
)
<
=
aLength
)
{
size_t
toRead
=
mTransition
.
Size
(
)
;
if
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
BUFFERED
)
{
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
aInput
toRead
)
;
}
else
{
MOZ_ASSERT
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
)
;
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aInput
toRead
)
;
if
(
IsTerminalState
(
unbufferedTransition
.
NextState
(
)
)
)
{
mTransition
=
unbufferedTransition
;
return
Some
(
mTransition
.
NextState
(
)
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
nullptr
0
)
;
}
aInput
+
=
toRead
;
aLength
-
=
toRead
;
if
(
IsTerminalState
(
mTransition
.
NextState
(
)
)
)
{
return
Some
(
mTransition
.
NextState
(
)
)
;
}
}
if
(
aLength
=
=
0
)
{
return
Nothing
(
)
;
}
if
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
)
{
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aInput
aLength
)
;
if
(
IsTerminalState
(
unbufferedTransition
.
NextState
(
)
)
)
{
mTransition
=
unbufferedTransition
;
return
Some
(
mTransition
.
NextState
(
)
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
mToReadUnbuffered
=
mTransition
.
Size
(
)
-
aLength
;
return
Nothing
(
)
;
}
MOZ_ASSERT
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
BUFFERED
)
;
if
(
!
mBuffer
.
reserve
(
mTransition
.
Size
(
)
)
)
{
return
Some
(
State
:
:
FAILURE
)
;
}
mBuffer
.
append
(
aInput
aLength
)
;
return
Nothing
(
)
;
}
private
:
Vector
<
char
InlineBufferSize
>
mBuffer
;
LexerTransition
<
State
>
mTransition
;
size_t
mToReadUnbuffered
;
}
;
}
}
#
endif
