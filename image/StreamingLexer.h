#
ifndef
mozilla_image_StreamingLexer_h
#
define
mozilla_image_StreamingLexer_h
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
namespace
mozilla
{
namespace
image
{
enum
class
BufferingStrategy
{
BUFFERED
UNBUFFERED
}
;
enum
class
TerminalState
{
SUCCESS
FAILURE
}
;
template
<
typename
State
>
class
LexerTransition
{
public
:
MOZ_IMPLICIT
LexerTransition
(
TerminalState
aFinalState
)
:
mNextState
(
aFinalState
)
{
}
bool
NextStateIsTerminal
(
)
const
{
return
mNextState
.
template
is
<
TerminalState
>
(
)
;
}
TerminalState
NextStateAsTerminal
(
)
const
{
return
mNextState
.
template
as
<
TerminalState
>
(
)
;
}
State
NextState
(
)
const
{
return
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mState
;
}
State
UnbufferedState
(
)
const
{
return
*
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mUnbufferedState
;
}
size_t
Size
(
)
const
{
return
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mSize
;
}
BufferingStrategy
Buffering
(
)
const
{
return
mNextState
.
template
as
<
NonTerminalState
>
(
)
.
mBufferingStrategy
;
}
private
:
friend
struct
Transition
;
LexerTransition
(
State
aNextState
const
Maybe
<
State
>
&
aUnbufferedState
size_t
aSize
BufferingStrategy
aBufferingStrategy
)
:
mNextState
(
NonTerminalState
(
aNextState
aUnbufferedState
aSize
aBufferingStrategy
)
)
{
}
struct
NonTerminalState
{
State
mState
;
Maybe
<
State
>
mUnbufferedState
;
size_t
mSize
;
BufferingStrategy
mBufferingStrategy
;
NonTerminalState
(
State
aState
const
Maybe
<
State
>
&
aUnbufferedState
size_t
aSize
BufferingStrategy
aBufferingStrategy
)
:
mState
(
aState
)
mUnbufferedState
(
aUnbufferedState
)
mSize
(
aSize
)
mBufferingStrategy
(
aBufferingStrategy
)
{
MOZ_ASSERT_IF
(
mBufferingStrategy
=
=
BufferingStrategy
:
:
UNBUFFERED
mUnbufferedState
)
;
MOZ_ASSERT_IF
(
mUnbufferedState
mBufferingStrategy
=
=
BufferingStrategy
:
:
UNBUFFERED
)
;
}
}
;
Variant
<
NonTerminalState
TerminalState
>
mNextState
;
}
;
struct
Transition
{
template
<
typename
State
>
static
LexerTransition
<
State
>
To
(
const
State
&
aNextState
size_t
aSize
)
{
return
LexerTransition
<
State
>
(
aNextState
Nothing
(
)
aSize
BufferingStrategy
:
:
BUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
ToUnbuffered
(
const
State
&
aNextState
const
State
&
aUnbufferedState
size_t
aSize
)
{
return
LexerTransition
<
State
>
(
aNextState
Some
(
aUnbufferedState
)
aSize
BufferingStrategy
:
:
UNBUFFERED
)
;
}
template
<
typename
State
>
static
LexerTransition
<
State
>
ContinueUnbuffered
(
const
State
&
aUnbufferedState
)
{
return
LexerTransition
<
State
>
(
aUnbufferedState
Nothing
(
)
0
BufferingStrategy
:
:
BUFFERED
)
;
}
static
TerminalState
TerminateSuccess
(
)
{
return
TerminalState
:
:
SUCCESS
;
}
static
TerminalState
TerminateFailure
(
)
{
return
TerminalState
:
:
FAILURE
;
}
private
:
Transition
(
)
;
}
;
template
<
typename
State
size_t
InlineBufferSize
=
16
>
class
StreamingLexer
{
public
:
explicit
StreamingLexer
(
LexerTransition
<
State
>
aStartState
)
:
mTransition
(
aStartState
)
mToReadUnbuffered
(
0
)
{
}
template
<
typename
Func
>
Maybe
<
TerminalState
>
Lex
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
Func
aFunc
)
{
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
do
{
switch
(
aIterator
.
AdvanceOrScheduleResume
(
SIZE_MAX
aOnResume
)
)
{
case
SourceBufferIterator
:
:
WAITING
:
return
Nothing
(
)
;
case
SourceBufferIterator
:
:
COMPLETE
:
mTransition
=
NS_SUCCEEDED
(
aIterator
.
CompletionStatus
(
)
)
?
Transition
:
:
TerminateSuccess
(
)
:
Transition
:
:
TerminateFailure
(
)
;
break
;
case
SourceBufferIterator
:
:
READY
:
MOZ_ASSERT
(
aIterator
.
Data
(
)
)
;
MOZ_ASSERT
(
aIterator
.
Length
(
)
>
0
)
;
Lex
(
aIterator
.
Data
(
)
aIterator
.
Length
(
)
aFunc
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
SourceBufferIterator
state
"
)
;
mTransition
=
Transition
:
:
TerminateFailure
(
)
;
}
}
while
(
!
mTransition
.
NextStateIsTerminal
(
)
)
;
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
template
<
typename
Func
>
Maybe
<
TerminalState
>
Lex
(
const
char
*
aInput
size_t
aLength
Func
aFunc
)
{
MOZ_ASSERT
(
aInput
)
;
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
if
(
mToReadUnbuffered
>
0
)
{
MOZ_ASSERT
(
mBuffer
.
empty
(
)
"
Shouldn
'
t
be
continuing
an
unbuffered
read
and
a
buffered
"
"
read
at
the
same
time
"
)
;
size_t
toRead
=
std
:
:
min
(
mToReadUnbuffered
aLength
)
;
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aInput
toRead
)
;
if
(
unbufferedTransition
.
NextStateIsTerminal
(
)
)
{
mTransition
=
unbufferedTransition
;
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
aInput
+
=
toRead
;
aLength
-
=
toRead
;
mToReadUnbuffered
-
=
toRead
;
if
(
mToReadUnbuffered
!
=
0
)
{
return
Nothing
(
)
;
}
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
nullptr
0
)
;
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
}
else
if
(
0
<
mBuffer
.
length
(
)
)
{
MOZ_ASSERT
(
mToReadUnbuffered
=
=
0
"
Shouldn
'
t
be
continuing
an
unbuffered
read
and
a
buffered
"
"
read
at
the
same
time
"
)
;
MOZ_ASSERT
(
mBuffer
.
length
(
)
<
mTransition
.
Size
(
)
"
Buffered
more
than
we
needed
?
"
)
;
size_t
toRead
=
std
:
:
min
(
aLength
mTransition
.
Size
(
)
-
mBuffer
.
length
(
)
)
;
if
(
!
mBuffer
.
append
(
aInput
toRead
)
)
{
return
Some
(
TerminalState
:
:
FAILURE
)
;
}
aInput
+
=
toRead
;
aLength
-
=
toRead
;
if
(
mBuffer
.
length
(
)
!
=
mTransition
.
Size
(
)
)
{
return
Nothing
(
)
;
}
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
mBuffer
.
begin
(
)
mBuffer
.
length
(
)
)
;
mBuffer
.
clear
(
)
;
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
}
MOZ_ASSERT
(
mToReadUnbuffered
=
=
0
)
;
MOZ_ASSERT
(
mBuffer
.
empty
(
)
)
;
while
(
mTransition
.
Size
(
)
<
=
aLength
)
{
size_t
toRead
=
mTransition
.
Size
(
)
;
if
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
BUFFERED
)
{
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
aInput
toRead
)
;
}
else
{
MOZ_ASSERT
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
)
;
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aInput
toRead
)
;
if
(
unbufferedTransition
.
NextStateIsTerminal
(
)
)
{
mTransition
=
unbufferedTransition
;
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
mTransition
=
aFunc
(
mTransition
.
NextState
(
)
nullptr
0
)
;
}
aInput
+
=
toRead
;
aLength
-
=
toRead
;
if
(
mTransition
.
NextStateIsTerminal
(
)
)
{
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
}
if
(
aLength
=
=
0
)
{
return
Nothing
(
)
;
}
if
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
UNBUFFERED
)
{
LexerTransition
<
State
>
unbufferedTransition
=
aFunc
(
mTransition
.
UnbufferedState
(
)
aInput
aLength
)
;
if
(
unbufferedTransition
.
NextStateIsTerminal
(
)
)
{
mTransition
=
unbufferedTransition
;
return
Some
(
mTransition
.
NextStateAsTerminal
(
)
)
;
}
MOZ_ASSERT
(
mTransition
.
UnbufferedState
(
)
=
=
unbufferedTransition
.
NextState
(
)
)
;
mToReadUnbuffered
=
mTransition
.
Size
(
)
-
aLength
;
return
Nothing
(
)
;
}
MOZ_ASSERT
(
mTransition
.
Buffering
(
)
=
=
BufferingStrategy
:
:
BUFFERED
)
;
if
(
!
mBuffer
.
reserve
(
mTransition
.
Size
(
)
)
)
{
return
Some
(
TerminalState
:
:
FAILURE
)
;
}
if
(
!
mBuffer
.
append
(
aInput
aLength
)
)
{
return
Some
(
TerminalState
:
:
FAILURE
)
;
}
return
Nothing
(
)
;
}
private
:
Vector
<
char
InlineBufferSize
>
mBuffer
;
LexerTransition
<
State
>
mTransition
;
size_t
mToReadUnbuffered
;
}
;
}
}
#
endif
