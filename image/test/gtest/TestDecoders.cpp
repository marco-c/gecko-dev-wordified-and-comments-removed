#
include
"
gtest
/
gtest
.
h
"
#
include
"
Common
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
decoders
/
nsBMPDecoder
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
ImageFactory
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProgressTracker
.
h
"
#
include
"
SourceBuffer
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
TEST
(
ImageDecoders
ImageModuleAvailable
)
{
nsCOMPtr
<
imgITools
>
imgTools
=
do_CreateInstance
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
EXPECT_TRUE
(
imgTools
!
=
nullptr
)
;
}
static
already_AddRefed
<
SourceSurface
>
CheckDecoderState
(
const
ImageTestCase
&
aTestCase
Decoder
*
aDecoder
)
{
EXPECT_TRUE
(
aDecoder
-
>
GetDecodeDone
(
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
aDecoder
-
>
HasError
(
)
)
;
EXPECT_TRUE
(
!
aDecoder
-
>
WasAborted
(
)
)
;
Progress
progress
=
aDecoder
-
>
TakeProgress
(
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
bool
(
progress
&
FLAG_HAS_ERROR
)
)
;
if
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
{
return
nullptr
;
}
EXPECT_TRUE
(
bool
(
progress
&
FLAG_SIZE_AVAILABLE
)
)
;
EXPECT_TRUE
(
bool
(
progress
&
FLAG_DECODE_COMPLETE
)
)
;
EXPECT_TRUE
(
bool
(
progress
&
FLAG_FRAME_COMPLETE
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_IS_TRANSPARENT
)
bool
(
progress
&
FLAG_HAS_TRANSPARENCY
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_IS_ANIMATED
)
bool
(
progress
&
FLAG_IS_ANIMATED
)
)
;
IntSize
size
=
aDecoder
-
>
GetSize
(
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
width
size
.
width
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
height
size
.
height
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_EQ
(
SurfaceType
:
:
DATA
surface
-
>
GetType
(
)
)
;
EXPECT_TRUE
(
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8X8
|
|
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
)
;
EXPECT_EQ
(
aTestCase
.
mOutputSize
surface
-
>
GetSize
(
)
)
;
return
surface
.
forget
(
)
;
}
static
void
CheckDecoderResults
(
const
ImageTestCase
&
aTestCase
Decoder
*
aDecoder
)
{
RefPtr
<
SourceSurface
>
surface
=
CheckDecoderState
(
aTestCase
aDecoder
)
;
if
(
!
surface
)
{
return
;
}
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
aTestCase
.
mFlags
&
TEST_CASE_IS_FUZZY
?
1
:
0
)
)
;
}
template
<
typename
Func
>
void
WithSingleChunkDecode
(
const
ImageTestCase
&
aTestCase
const
Maybe
<
IntSize
>
&
aOutputSize
Func
aResultChecker
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
SourceBuffer
>
sourceBuffer
=
new
SourceBuffer
(
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
sourceBuffer
-
>
Complete
(
NS_OK
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
aOutputSize
DefaultSurfaceFlags
(
)
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
decoder
-
>
Decode
(
)
;
aResultChecker
(
decoder
)
;
}
static
void
CheckDecoderSingleChunk
(
const
ImageTestCase
&
aTestCase
)
{
WithSingleChunkDecode
(
aTestCase
Nothing
(
)
[
&
]
(
Decoder
*
aDecoder
)
{
CheckDecoderResults
(
aTestCase
aDecoder
)
;
}
)
;
}
class
NoResume
:
public
IResumable
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
NoResume
override
)
virtual
void
Resume
(
)
override
{
}
private
:
~
NoResume
(
)
{
}
}
;
static
void
CheckDecoderMultiChunk
(
const
ImageTestCase
&
aTestCase
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
SourceBuffer
>
sourceBuffer
=
new
SourceBuffer
(
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
Nothing
(
)
DefaultSurfaceFlags
(
)
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
RefPtr
<
NoResume
>
noResume
=
new
NoResume
(
)
;
for
(
uint64_t
read
=
0
;
read
<
length
;
+
+
read
)
{
uint64_t
available
=
0
;
rv
=
inputStream
-
>
Available
(
&
available
)
;
ASSERT_TRUE
(
available
>
0
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
1
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
decoder
-
>
Decode
(
noResume
)
;
}
sourceBuffer
-
>
Complete
(
NS_OK
)
;
decoder
-
>
Decode
(
noResume
)
;
CheckDecoderResults
(
aTestCase
decoder
)
;
}
static
void
CheckDownscaleDuringDecode
(
const
ImageTestCase
&
aTestCase
)
{
IntSize
outputSize
(
20
20
)
;
WithSingleChunkDecode
(
aTestCase
Some
(
outputSize
)
[
&
]
(
Decoder
*
aDecoder
)
{
RefPtr
<
SourceSurface
>
surface
=
CheckDecoderState
(
aTestCase
aDecoder
)
;
EXPECT_TRUE
(
surface
!
=
nullptr
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
0
4
BGRAColor
:
:
Green
(
)
4
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
6
3
BGRAColor
:
:
Red
(
)
4
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
11
3
BGRAColor
:
:
Green
(
)
4
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
16
4
BGRAColor
:
:
Red
(
)
3
)
)
;
}
)
;
}
TEST
(
ImageDecoders
PNGSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenPNGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
PNGMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenPNGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
PNGDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledPNGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
GIFSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenGIFTestCase
(
)
)
;
}
TEST
(
ImageDecoders
GIFMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenGIFTestCase
(
)
)
;
}
TEST
(
ImageDecoders
GIFDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledGIFTestCase
(
)
)
;
}
TEST
(
ImageDecoders
JPGSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenJPGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
JPGMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenJPGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
JPGDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledJPGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
BMPSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenBMPTestCase
(
)
)
;
}
TEST
(
ImageDecoders
BMPMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenBMPTestCase
(
)
)
;
}
TEST
(
ImageDecoders
BMPDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledBMPTestCase
(
)
)
;
}
TEST
(
ImageDecoders
ICOSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenICOTestCase
(
)
)
;
}
TEST
(
ImageDecoders
ICOMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenICOTestCase
(
)
)
;
}
TEST
(
ImageDecoders
ICODownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledICOTestCase
(
)
)
;
}
TEST
(
ImageDecoders
IconSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenIconTestCase
(
)
)
;
}
TEST
(
ImageDecoders
IconMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenIconTestCase
(
)
)
;
}
TEST
(
ImageDecoders
IconDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledIconTestCase
(
)
)
;
}
TEST
(
ImageDecoders
AnimatedGIFSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST
(
ImageDecoders
AnimatedGIFMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST
(
ImageDecoders
AnimatedPNGSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenFirstFrameAnimatedPNGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
AnimatedPNGMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenFirstFrameAnimatedPNGTestCase
(
)
)
;
}
TEST
(
ImageDecoders
CorruptSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptTestCase
(
)
)
;
}
TEST
(
ImageDecoders
CorruptMultiChunk
)
{
CheckDecoderMultiChunk
(
CorruptTestCase
(
)
)
;
}
