#
include
"
gtest
/
gtest
.
h
"
#
include
"
Common
.
h
"
#
include
"
AnimationSurfaceProvider
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
decoders
/
nsBMPDecoder
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
ImageFactory
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProgressTracker
.
h
"
#
include
"
SourceBuffer
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
static
already_AddRefed
<
SourceSurface
>
CheckDecoderState
(
const
ImageTestCase
&
aTestCase
image
:
:
Decoder
*
aDecoder
)
{
EXPECT_NE
(
aDecoder
-
>
GetType
(
)
DecoderType
:
:
UNKNOWN
)
;
EXPECT_EQ
(
aDecoder
-
>
GetType
(
)
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
)
;
EXPECT_TRUE
(
aDecoder
-
>
GetDecodeDone
(
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
aDecoder
-
>
HasError
(
)
)
;
Progress
progress
=
aDecoder
-
>
TakeProgress
(
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
bool
(
progress
&
FLAG_HAS_ERROR
)
)
;
if
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
{
return
nullptr
;
}
EXPECT_TRUE
(
bool
(
progress
&
FLAG_SIZE_AVAILABLE
)
)
;
EXPECT_TRUE
(
bool
(
progress
&
FLAG_DECODE_COMPLETE
)
)
;
EXPECT_TRUE
(
bool
(
progress
&
FLAG_FRAME_COMPLETE
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_IS_TRANSPARENT
)
bool
(
progress
&
FLAG_HAS_TRANSPARENCY
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_IS_ANIMATED
)
bool
(
progress
&
FLAG_IS_ANIMATED
)
)
;
IntSize
size
=
aDecoder
-
>
Size
(
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
width
size
.
width
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
height
size
.
height
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
surface
-
>
IsDataSourceSurface
(
)
)
;
EXPECT_TRUE
(
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
OS_RGBX
|
|
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
OS_RGBA
)
;
EXPECT_EQ
(
aTestCase
.
mOutputSize
surface
-
>
GetSize
(
)
)
;
return
surface
.
forget
(
)
;
}
static
void
CheckDecoderResults
(
const
ImageTestCase
&
aTestCase
image
:
:
Decoder
*
aDecoder
)
{
RefPtr
<
SourceSurface
>
surface
=
CheckDecoderState
(
aTestCase
aDecoder
)
;
if
(
!
surface
)
{
return
;
}
if
(
aTestCase
.
mFlags
&
TEST_CASE_IGNORE_OUTPUT
)
{
return
;
}
EXPECT_TRUE
(
IsSolidColor
(
surface
aTestCase
.
Color
(
)
aTestCase
.
Fuzz
(
)
)
)
;
}
template
<
typename
Func
>
void
WithBadBufferDecode
(
const
ImageTestCase
&
aTestCase
const
Maybe
<
IntSize
>
&
aOutputSize
Func
aResultChecker
)
{
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
sourceBuffer
-
>
ExpectLength
(
SIZE_MAX
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
image
:
:
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
aOutputSize
DecoderFlags
:
:
FIRST_FRAME_ONLY
aTestCase
.
mSurfaceFlags
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
RefPtr
<
IDecodingTask
>
task
=
new
AnonymousDecodingTask
(
WrapNotNull
(
decoder
)
false
)
;
task
-
>
Run
(
)
;
aResultChecker
(
decoder
)
;
}
static
void
CheckDecoderBadBuffer
(
const
ImageTestCase
&
aTestCase
)
{
WithBadBufferDecode
(
aTestCase
Nothing
(
)
[
&
]
(
image
:
:
Decoder
*
aDecoder
)
{
CheckDecoderResults
(
aTestCase
aDecoder
)
;
}
)
;
}
template
<
typename
Func
>
void
WithSingleChunkDecode
(
const
ImageTestCase
&
aTestCase
const
Maybe
<
IntSize
>
&
aOutputSize
bool
aUseDecodePool
Func
aResultChecker
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
sourceBuffer
-
>
Complete
(
NS_OK
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
image
:
:
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
aOutputSize
DecoderFlags
:
:
FIRST_FRAME_ONLY
aTestCase
.
mSurfaceFlags
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
RefPtr
<
IDecodingTask
>
task
=
new
AnonymousDecodingTask
(
WrapNotNull
(
decoder
)
false
)
;
if
(
aUseDecodePool
)
{
DecodePool
:
:
Singleton
(
)
-
>
AsyncRun
(
task
.
get
(
)
)
;
while
(
!
decoder
-
>
GetDecodeDone
(
)
)
{
task
-
>
Resume
(
)
;
}
}
else
{
task
-
>
Run
(
)
;
}
aResultChecker
(
decoder
)
;
}
static
void
CheckDecoderSingleChunk
(
const
ImageTestCase
&
aTestCase
bool
aUseDecodePool
=
false
)
{
WithSingleChunkDecode
(
aTestCase
Nothing
(
)
aUseDecodePool
[
&
]
(
image
:
:
Decoder
*
aDecoder
)
{
CheckDecoderResults
(
aTestCase
aDecoder
)
;
}
)
;
}
template
<
typename
Func
>
void
WithDelayedChunkDecode
(
const
ImageTestCase
&
aTestCase
const
Maybe
<
IntSize
>
&
aOutputSize
Func
aResultChecker
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
image
:
:
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
aOutputSize
DecoderFlags
:
:
FIRST_FRAME_ONLY
aTestCase
.
mSurfaceFlags
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
RefPtr
<
IDecodingTask
>
task
=
new
AnonymousDecodingTask
(
WrapNotNull
(
decoder
)
true
)
;
task
-
>
Run
(
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
sourceBuffer
-
>
Complete
(
NS_OK
)
;
SpinPendingEvents
(
)
;
aResultChecker
(
decoder
)
;
}
static
void
CheckDecoderDelayedChunk
(
const
ImageTestCase
&
aTestCase
)
{
WithDelayedChunkDecode
(
aTestCase
Nothing
(
)
[
&
]
(
image
:
:
Decoder
*
aDecoder
)
{
CheckDecoderResults
(
aTestCase
aDecoder
)
;
}
)
;
}
static
void
CheckDecoderMultiChunk
(
const
ImageTestCase
&
aTestCase
uint64_t
aChunkSize
=
1
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
image
:
:
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
Nothing
(
)
DecoderFlags
:
:
FIRST_FRAME_ONLY
aTestCase
.
mSurfaceFlags
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
RefPtr
<
IDecodingTask
>
task
=
new
AnonymousDecodingTask
(
WrapNotNull
(
decoder
)
true
)
;
task
-
>
Run
(
)
;
while
(
length
>
0
)
{
uint64_t
read
=
length
>
aChunkSize
?
aChunkSize
:
length
;
length
-
=
read
;
uint64_t
available
=
0
;
rv
=
inputStream
-
>
Available
(
&
available
)
;
ASSERT_TRUE
(
available
>
=
read
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
read
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
SpinPendingEvents
(
)
;
}
sourceBuffer
-
>
Complete
(
NS_OK
)
;
SpinPendingEvents
(
)
;
CheckDecoderResults
(
aTestCase
decoder
)
;
}
static
void
CheckDownscaleDuringDecode
(
const
ImageTestCase
&
aTestCase
)
{
IntSize
outputSize
(
20
20
)
;
WithSingleChunkDecode
(
aTestCase
Some
(
outputSize
)
false
[
&
]
(
image
:
:
Decoder
*
aDecoder
)
{
RefPtr
<
SourceSurface
>
surface
=
CheckDecoderState
(
aTestCase
aDecoder
)
;
EXPECT_TRUE
(
surface
!
=
nullptr
)
;
if
(
aTestCase
.
mFlags
&
TEST_CASE_IGNORE_OUTPUT
)
{
return
;
}
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
0
4
aTestCase
.
ChooseColor
(
BGRAColor
:
:
Green
(
)
)
47
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
6
3
aTestCase
.
ChooseColor
(
BGRAColor
:
:
Red
(
)
)
27
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
11
3
BGRAColor
:
:
Green
(
)
47
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
16
4
aTestCase
.
ChooseColor
(
BGRAColor
:
:
Red
(
)
)
27
)
)
;
}
)
;
}
static
void
CheckAnimationDecoderResults
(
const
ImageTestCase
&
aTestCase
AnimationSurfaceProvider
*
aProvider
image
:
:
Decoder
*
aDecoder
)
{
EXPECT_TRUE
(
aDecoder
-
>
GetDecodeDone
(
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
aDecoder
-
>
HasError
(
)
)
;
if
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
{
return
;
}
IntSize
size
=
aDecoder
-
>
Size
(
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
width
size
.
width
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
height
size
.
height
)
;
if
(
aTestCase
.
mFlags
&
TEST_CASE_IGNORE_OUTPUT
)
{
return
;
}
AutoTArray
<
BGRAColor
2
>
framePixels
;
framePixels
.
AppendElement
(
aTestCase
.
ChooseColor
(
BGRAColor
:
:
Green
(
)
)
)
;
framePixels
.
AppendElement
(
aTestCase
.
ChooseColor
(
BGRAColor
(
0x7F
0x7F
0x7F
0xFF
)
)
)
;
DrawableSurface
drawableSurface
(
WrapNotNull
(
aProvider
)
)
;
for
(
size_t
i
=
0
;
i
<
framePixels
.
Length
(
)
;
+
+
i
)
{
nsresult
rv
=
drawableSurface
.
Seek
(
i
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RawAccessFrameRef
rawFrame
=
drawableSurface
-
>
RawAccessRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
rawFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
surface
-
>
IsDataSourceSurface
(
)
)
;
EXPECT_TRUE
(
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
OS_RGBX
|
|
surface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
OS_RGBA
)
;
EXPECT_EQ
(
aTestCase
.
mOutputSize
surface
-
>
GetSize
(
)
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
framePixels
[
i
]
aTestCase
.
Fuzz
(
)
)
)
;
}
nsresult
rv
=
drawableSurface
.
Seek
(
framePixels
.
Length
(
)
)
;
EXPECT_TRUE
(
NS_FAILED
(
rv
)
)
;
}
template
<
typename
Func
>
static
void
WithSingleChunkAnimationDecode
(
const
ImageTestCase
&
aTestCase
Func
aResultChecker
)
{
RefPtr
<
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
nsDependentCString
(
aTestCase
.
mMimeType
)
)
;
ASSERT_TRUE
(
!
image
-
>
HasError
(
)
)
;
NotNull
<
RefPtr
<
RasterImage
>
>
rasterImage
=
WrapNotNull
(
static_cast
<
RasterImage
*
>
(
image
.
get
(
)
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
NotNull
<
RefPtr
<
SourceBuffer
>
>
sourceBuffer
=
WrapNotNull
(
new
SourceBuffer
(
)
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
sourceBuffer
-
>
Complete
(
NS_OK
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
IDecodingTask
>
task
=
DecoderFactory
:
:
CreateMetadataDecoder
(
decoderType
rasterImage
sourceBuffer
)
;
ASSERT_TRUE
(
task
!
=
nullptr
)
;
task
-
>
Run
(
)
;
DecoderFlags
decoderFlags
=
DefaultDecoderFlags
(
)
;
SurfaceFlags
surfaceFlags
=
aTestCase
.
mSurfaceFlags
;
RefPtr
<
image
:
:
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
Nothing
(
)
decoderFlags
surfaceFlags
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
SurfaceKey
surfaceKey
=
RasterSurfaceKey
(
aTestCase
.
mOutputSize
surfaceFlags
PlaybackType
:
:
eAnimated
)
;
RefPtr
<
AnimationSurfaceProvider
>
provider
=
new
AnimationSurfaceProvider
(
rasterImage
surfaceKey
WrapNotNull
(
decoder
)
0
)
;
provider
-
>
Run
(
)
;
aResultChecker
(
provider
decoder
)
;
}
static
void
CheckAnimationDecoderSingleChunk
(
const
ImageTestCase
&
aTestCase
)
{
WithSingleChunkAnimationDecode
(
aTestCase
[
&
]
(
AnimationSurfaceProvider
*
aProvider
image
:
:
Decoder
*
aDecoder
)
{
CheckAnimationDecoderResults
(
aTestCase
aProvider
aDecoder
)
;
}
)
;
}
static
void
CheckDecoderFrameFirst
(
const
ImageTestCase
&
aTestCase
)
{
RefPtr
<
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
nsDependentCString
(
aTestCase
.
mMimeType
)
)
;
ASSERT_TRUE
(
!
image
-
>
HasError
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataAvailable
(
nullptr
nullptr
inputStream
0
static_cast
<
uint32_t
>
(
length
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataComplete
(
nullptr
nullptr
NS_OK
true
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
image
-
>
LockImage
(
)
;
auto
unlock
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
image
-
>
UnlockImage
(
)
;
}
)
;
RefPtr
<
SourceSurface
>
surface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
IntSize
imageSize
(
0
0
)
;
rv
=
image
-
>
GetWidth
(
&
imageSize
.
width
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
GetHeight
(
&
imageSize
.
height
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
width
imageSize
.
width
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
height
imageSize
.
height
)
;
Progress
imageProgress
=
tracker
-
>
GetProgress
(
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_HAS_TRANSPARENCY
)
=
=
false
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_IS_ANIMATED
)
=
=
true
)
;
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eStatic
)
false
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
}
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eAnimated
)
false
)
;
ASSERT_EQ
(
MatchType
:
:
NOT_FOUND
result
.
Type
(
)
)
;
}
RefPtr
<
SourceSurface
>
animatedSurface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eAnimated
)
true
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
result
.
Surface
(
)
.
Seek
(
0
)
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
RefPtr
<
imgFrame
>
partialFrame
=
result
.
Surface
(
)
.
GetFrame
(
1
)
;
EXPECT_TRUE
(
bool
(
partialFrame
)
)
;
}
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eStatic
)
true
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
}
}
static
void
CheckDecoderFrameCurrent
(
const
ImageTestCase
&
aTestCase
)
{
RefPtr
<
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
nsDependentCString
(
aTestCase
.
mMimeType
)
)
;
ASSERT_TRUE
(
!
image
-
>
HasError
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataAvailable
(
nullptr
nullptr
inputStream
0
static_cast
<
uint32_t
>
(
length
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataComplete
(
nullptr
nullptr
NS_OK
true
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
image
-
>
LockImage
(
)
;
RefPtr
<
SourceSurface
>
surface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
IntSize
imageSize
(
0
0
)
;
rv
=
image
-
>
GetWidth
(
&
imageSize
.
width
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
GetHeight
(
&
imageSize
.
height
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
width
imageSize
.
width
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
height
imageSize
.
height
)
;
Progress
imageProgress
=
tracker
-
>
GetProgress
(
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_HAS_TRANSPARENCY
)
=
=
false
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_IS_ANIMATED
)
=
=
true
)
;
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eAnimated
)
true
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
result
.
Surface
(
)
.
Seek
(
0
)
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
RefPtr
<
imgFrame
>
partialFrame
=
result
.
Surface
(
)
.
GetFrame
(
1
)
;
EXPECT_TRUE
(
bool
(
partialFrame
)
)
;
}
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eStatic
)
false
)
;
ASSERT_EQ
(
MatchType
:
:
NOT_FOUND
result
.
Type
(
)
)
;
}
RefPtr
<
SourceSurface
>
animatedSurface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_FIRST
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eStatic
)
true
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
}
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
aTestCase
.
mSurfaceFlags
PlaybackType
:
:
eAnimated
)
true
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
result
.
Surface
(
)
.
Seek
(
0
)
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
RefPtr
<
imgFrame
>
partialFrame
=
result
.
Surface
(
)
.
GetFrame
(
1
)
;
EXPECT_TRUE
(
bool
(
partialFrame
)
)
;
}
}
class
ImageDecoders
:
public
:
:
testing
:
:
Test
{
protected
:
AutoInitializeImageLib
mInit
;
}
;
#
define
IMAGE_GTEST_DECODER_BASE_F
(
test_prefix
)
\
TEST_F
(
ImageDecoders
test_prefix
#
#
SingleChunk
)
{
\
CheckDecoderSingleChunk
(
Green
#
#
test_prefix
#
#
TestCase
(
)
)
;
\
}
\
\
TEST_F
(
ImageDecoders
test_prefix
#
#
DelayedChunk
)
{
\
CheckDecoderDelayedChunk
(
Green
#
#
test_prefix
#
#
TestCase
(
)
)
;
\
}
\
\
TEST_F
(
ImageDecoders
test_prefix
#
#
MultiChunk
)
{
\
CheckDecoderMultiChunk
(
Green
#
#
test_prefix
#
#
TestCase
(
)
)
;
\
}
\
\
TEST_F
(
ImageDecoders
test_prefix
#
#
DownscaleDuringDecode
)
{
\
CheckDownscaleDuringDecode
(
Downscaled
#
#
test_prefix
#
#
TestCase
(
)
)
;
\
}
\
\
TEST_F
(
ImageDecoders
test_prefix
#
#
ForceSRGB
)
{
\
CheckDecoderSingleChunk
(
Green
#
#
test_prefix
#
#
TestCase
(
)
.
WithSurfaceFlags
(
\
SurfaceFlags
:
:
TO_SRGB_COLORSPACE
)
)
;
\
}
\
\
TEST_F
(
ImageDecoders
test_prefix
#
#
BadBuffer
)
{
\
CheckDecoderBadBuffer
(
Green
#
#
test_prefix
#
#
TestCase
(
)
.
WithFlags
(
\
TEST_CASE_HAS_ERROR
|
TEST_CASE_IGNORE_OUTPUT
)
)
;
\
}
IMAGE_GTEST_DECODER_BASE_F
(
PNG
)
IMAGE_GTEST_DECODER_BASE_F
(
GIF
)
IMAGE_GTEST_DECODER_BASE_F
(
JPG
)
IMAGE_GTEST_DECODER_BASE_F
(
BMP
)
IMAGE_GTEST_DECODER_BASE_F
(
ICO
)
IMAGE_GTEST_DECODER_BASE_F
(
Icon
)
IMAGE_GTEST_DECODER_BASE_F
(
WebP
)
TEST_F
(
ImageDecoders
ICOWithANDMaskDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledTransparentICOWithANDMaskTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
WebPLargeMultiChunk
)
{
CheckDecoderMultiChunk
(
LargeWebPTestCase
(
)
64
)
;
}
TEST_F
(
ImageDecoders
WebPIccSrgbMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenWebPIccSrgbTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
WebPTransparentSingleChunk
)
{
CheckDecoderSingleChunk
(
TransparentWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
WebPTransparentNoAlphaHeaderSingleChunk
)
{
CheckDecoderSingleChunk
(
TransparentNoAlphaHeaderWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenAVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent10bit420
)
{
CheckDecoderSingleChunk
(
Transparent10bit420AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent10bit422
)
{
CheckDecoderSingleChunk
(
Transparent10bit422AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent10bit444
)
{
CheckDecoderSingleChunk
(
Transparent10bit444AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent12bit420
)
{
CheckDecoderSingleChunk
(
Transparent12bit420AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent12bit422
)
{
CheckDecoderSingleChunk
(
Transparent12bit422AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent12bit444
)
{
CheckDecoderSingleChunk
(
Transparent12bit444AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent8bit420
)
{
CheckDecoderSingleChunk
(
Transparent8bit420AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent8bit422
)
{
CheckDecoderSingleChunk
(
Transparent8bit422AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFSingleChunkTransparent8bit444
)
{
CheckDecoderSingleChunk
(
Transparent8bit444AVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFMultiLayerSingleChunk
)
{
CheckDecoderSingleChunk
(
MultiLayerAVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFStackCheck
)
{
CheckDecoderSingleChunk
(
StackCheckAVIFTestCase
(
)
true
)
;
}
TEST_F
(
ImageDecoders
AVIFDelayedChunk
)
{
CheckDecoderDelayedChunk
(
GreenAVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenAVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AVIFLargeMultiChunk
)
{
CheckDecoderMultiChunk
(
LargeAVIFTestCase
(
)
64
)
;
}
TEST_F
(
ImageDecoders
AVIFDownscaleDuringDecode
)
{
CheckDownscaleDuringDecode
(
DownscaledAVIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedGIFSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedGIFMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedGIFWithBlendedFrames
)
{
CheckAnimationDecoderSingleChunk
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedPNGSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenFirstFrameAnimatedPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedPNGMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenFirstFrameAnimatedPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedPNGWithBlendedFrames
)
{
CheckAnimationDecoderSingleChunk
(
GreenFirstFrameAnimatedPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedWebPSingleChunk
)
{
CheckDecoderSingleChunk
(
GreenFirstFrameAnimatedWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedWebPMultiChunk
)
{
CheckDecoderMultiChunk
(
GreenFirstFrameAnimatedWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedWebPWithBlendedFrames
)
{
CheckAnimationDecoderSingleChunk
(
GreenFirstFrameAnimatedWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptMultiChunk
)
{
CheckDecoderMultiChunk
(
CorruptTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptBMPWithTruncatedHeaderSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptBMPWithTruncatedHeader
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptBMPWithTruncatedHeaderMultiChunk
)
{
CheckDecoderMultiChunk
(
CorruptBMPWithTruncatedHeader
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptICOWithBadBMPWidthSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptICOWithBadBMPWidthTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptICOWithBadBMPWidthMultiChunk
)
{
CheckDecoderMultiChunk
(
CorruptICOWithBadBMPWidthTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptICOWithBadBMPHeightSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptICOWithBadBMPHeightTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptICOWithBadBMPHeightMultiChunk
)
{
CheckDecoderMultiChunk
(
CorruptICOWithBadBMPHeightTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
CorruptICOWithBadBppSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptICOWithBadBppTestCase
(
)
)
;
}
#
ifndef
ANDROID
TEST_F
(
ImageDecoders
CorruptAVIFSingleChunk
)
{
CheckDecoderSingleChunk
(
CorruptAVIFTestCase
(
)
)
;
}
#
endif
TEST_F
(
ImageDecoders
AnimatedGIFWithFRAME_FIRST
)
{
CheckDecoderFrameFirst
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedGIFWithFRAME_CURRENT
)
{
CheckDecoderFrameCurrent
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedGIFWithExtraImageSubBlocks
)
{
ImageTestCase
testCase
=
ExtraImageSubBlocksAnimatedGIFTestCase
(
)
;
RefPtr
<
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
nsDependentCString
(
testCase
.
mMimeType
)
)
;
ASSERT_TRUE
(
!
image
-
>
HasError
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
testCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataAvailable
(
nullptr
nullptr
inputStream
0
static_cast
<
uint32_t
>
(
length
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataComplete
(
nullptr
nullptr
NS_OK
true
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
RefPtr
<
SourceSurface
>
surface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
IntSize
imageSize
(
0
0
)
;
rv
=
image
-
>
GetWidth
(
&
imageSize
.
width
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
GetHeight
(
&
imageSize
.
height
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
EXPECT_EQ
(
testCase
.
mSize
.
width
imageSize
.
width
)
;
EXPECT_EQ
(
testCase
.
mSize
.
height
imageSize
.
height
)
;
Progress
imageProgress
=
tracker
-
>
GetProgress
(
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_HAS_TRANSPARENCY
)
=
=
false
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_IS_ANIMATED
)
=
=
true
)
;
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
testCase
.
mSurfaceFlags
PlaybackType
:
:
eAnimated
)
true
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
result
.
Surface
(
)
.
Seek
(
0
)
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
RefPtr
<
imgFrame
>
partialFrame
=
result
.
Surface
(
)
.
GetFrame
(
1
)
;
EXPECT_TRUE
(
bool
(
partialFrame
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedWebPWithFRAME_FIRST
)
{
CheckDecoderFrameFirst
(
GreenFirstFrameAnimatedWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
AnimatedWebPWithFRAME_CURRENT
)
{
CheckDecoderFrameCurrent
(
GreenFirstFrameAnimatedWebPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
TruncatedSmallGIFSingleChunk
)
{
CheckDecoderSingleChunk
(
TruncatedSmallGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
LargeICOWithBMPSingleChunk
)
{
CheckDecoderSingleChunk
(
LargeICOWithBMPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
LargeICOWithBMPMultiChunk
)
{
CheckDecoderMultiChunk
(
LargeICOWithBMPTestCase
(
)
64
)
;
}
TEST_F
(
ImageDecoders
LargeICOWithPNGSingleChunk
)
{
CheckDecoderSingleChunk
(
LargeICOWithPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
LargeICOWithPNGMultiChunk
)
{
CheckDecoderMultiChunk
(
LargeICOWithPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoders
MultipleSizesICOSingleChunk
)
{
ImageTestCase
testCase
=
GreenMultipleSizesICOTestCase
(
)
;
RefPtr
<
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
nsDependentCString
(
testCase
.
mMimeType
)
)
;
ASSERT_TRUE
(
!
image
-
>
HasError
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
testCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataAvailable
(
nullptr
nullptr
inputStream
0
static_cast
<
uint32_t
>
(
length
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataComplete
(
nullptr
nullptr
NS_OK
true
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
RefPtr
<
SourceSurface
>
surface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
IntSize
imageSize
(
0
0
)
;
rv
=
image
-
>
GetWidth
(
&
imageSize
.
width
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
GetHeight
(
&
imageSize
.
height
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
EXPECT_EQ
(
testCase
.
mSize
.
width
imageSize
.
width
)
;
EXPECT_EQ
(
testCase
.
mSize
.
height
imageSize
.
height
)
;
nsTArray
<
IntSize
>
nativeSizes
;
rv
=
image
-
>
GetNativeSizes
(
nativeSizes
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_EQ
(
6u
nativeSizes
.
Length
(
)
)
;
IntSize
expectedSizes
[
]
=
{
IntSize
(
16
16
)
IntSize
(
32
32
)
IntSize
(
64
64
)
IntSize
(
128
128
)
IntSize
(
256
256
)
IntSize
(
256
128
)
}
;
for
(
int
i
=
0
;
i
<
6
;
+
+
i
)
{
EXPECT_EQ
(
expectedSizes
[
i
]
nativeSizes
[
i
]
)
;
}
RefPtr
<
Image
>
image90
=
ImageOps
:
:
Orient
(
image
Orientation
(
Angle
:
:
D90
Flip
:
:
Unflipped
)
)
;
rv
=
image90
-
>
GetNativeSizes
(
nativeSizes
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_EQ
(
6u
nativeSizes
.
Length
(
)
)
;
for
(
int
i
=
0
;
i
<
5
;
+
+
i
)
{
EXPECT_EQ
(
expectedSizes
[
i
]
nativeSizes
[
i
]
)
;
}
EXPECT_EQ
(
IntSize
(
128
256
)
nativeSizes
[
5
]
)
;
RefPtr
<
Image
>
image180
=
ImageOps
:
:
Orient
(
image
Orientation
(
Angle
:
:
D180
Flip
:
:
Unflipped
)
)
;
rv
=
image180
-
>
GetNativeSizes
(
nativeSizes
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
ASSERT_EQ
(
6u
nativeSizes
.
Length
(
)
)
;
for
(
int
i
=
0
;
i
<
6
;
+
+
i
)
{
EXPECT_EQ
(
expectedSizes
[
i
]
nativeSizes
[
i
]
)
;
}
}
