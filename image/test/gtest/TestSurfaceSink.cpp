#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
Common
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SurfacePipe
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
enum
class
Orient
{
NORMAL
FLIP_VERTICALLY
}
;
static
void
InitializeRowBuffer
(
uint32_t
*
aBuffer
size_t
aSize
size_t
aStartPixel
size_t
aEndPixel
uint32_t
aSetPixel
)
{
uint32_t
transparentPixel
=
BGRAColor
:
:
Transparent
(
)
.
AsPixel
(
)
;
for
(
size_t
i
=
0
;
i
<
aStartPixel
&
&
i
<
aSize
;
+
+
i
)
{
aBuffer
[
i
]
=
transparentPixel
;
}
for
(
size_t
i
=
aStartPixel
;
i
<
aEndPixel
&
&
i
<
aSize
;
+
+
i
)
{
aBuffer
[
i
]
=
aSetPixel
;
}
for
(
size_t
i
=
aEndPixel
;
i
<
aSize
;
+
+
i
)
{
aBuffer
[
i
]
=
transparentPixel
;
}
}
template
<
Orient
Orientation
typename
Func
>
void
WithSurfaceSink
(
Func
aFunc
)
{
RefPtr
<
Decoder
>
decoder
=
CreateTrivialDecoder
(
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
const
bool
flipVertically
=
Orientation
=
=
Orient
:
:
FLIP_VERTICALLY
;
WithFilterPipeline
(
decoder
std
:
:
forward
<
Func
>
(
aFunc
)
SurfaceConfig
{
decoder
IntSize
(
100
100
)
SurfaceFormat
:
:
OS_RGBA
flipVertically
}
)
;
}
void
ResetForNextPass
(
SurfaceFilter
*
aSink
)
{
aSink
-
>
ResetToFirstRow
(
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
template
<
typename
WriteFunc
typename
CheckFunc
>
void
DoCheckIterativeWrite
(
SurfaceFilter
*
aSink
WriteFunc
aWriteFunc
CheckFunc
aCheckFunc
)
{
uint32_t
row
=
0
;
WriteState
result
=
WriteState
:
:
NEED_MORE_DATA
;
while
(
result
=
=
WriteState
:
:
NEED_MORE_DATA
)
{
result
=
aWriteFunc
(
row
)
;
+
+
row
;
}
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
row
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
aCheckFunc
(
)
;
}
template
<
typename
WriteFunc
>
void
CheckIterativeWrite
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
const
IntRect
&
aOutputRect
WriteFunc
aWriteFunc
)
{
auto
writeFunc
=
[
&
]
(
uint32_t
)
{
return
aWriteFunc
(
)
;
}
;
DoCheckIterativeWrite
(
aSink
writeFunc
[
&
]
{
CheckGeneratedImage
(
aDecoder
aOutputRect
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkInitialization
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
0
0
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixels
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
CheckWritePixels
(
aDecoder
aSink
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelsFinish
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
count
+
+
;
return
AsVariant
(
WriteState
:
:
FINISHED
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
1u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Transparent
(
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelsEarlyExit
)
{
auto
checkEarlyExit
=
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
WriteState
aState
)
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
aState
)
;
}
return
count
+
+
<
50
?
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
:
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
aState
result
)
;
EXPECT_EQ
(
50u
count
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
50
1
)
)
;
if
(
aState
!
=
WriteState
:
:
FINISHED
)
{
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
100
1
)
)
;
return
;
}
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
50
1
)
)
;
}
;
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
&
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
checkEarlyExit
(
aDecoder
aSink
WriteState
:
:
NEED_MORE_DATA
)
;
}
)
;
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
&
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
checkEarlyExit
(
aDecoder
aSink
WriteState
:
:
FAILURE
)
;
}
)
;
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
&
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
checkEarlyExit
(
aDecoder
aSink
WriteState
:
:
FINISHED
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelsToRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
for
(
int
row
=
0
;
row
<
99
;
+
+
row
)
{
uint32_t
count
=
0
;
WriteState
result
=
aSink
-
>
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
100u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
row
100
1
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
row
100
1
)
invalidRect
-
>
mOutputSpaceRect
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
100
row
+
1
)
)
;
}
uint32_t
count
=
0
;
WriteState
result
=
aSink
-
>
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
99
100
1
)
IntRect
(
0
99
100
1
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
100
100
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
100
100
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelsToRowEarlyExit
)
{
auto
checkEarlyExit
=
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
WriteState
aState
)
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixelsToRow
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
aState
)
;
}
return
count
+
+
<
50
?
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
:
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
aState
result
)
;
EXPECT_EQ
(
50u
count
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
50
1
)
)
;
if
(
aState
!
=
WriteState
:
:
FINISHED
)
{
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
count
=
0
;
WriteState
result
=
aSink
-
>
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
100
1
)
)
;
return
;
}
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
50
1
)
)
;
}
;
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
&
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
checkEarlyExit
(
aDecoder
aSink
WriteState
:
:
NEED_MORE_DATA
)
;
}
)
;
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
&
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
checkEarlyExit
(
aDecoder
aSink
WriteState
:
:
FAILURE
)
;
}
)
;
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
&
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
checkEarlyExit
(
aDecoder
aSink
WriteState
:
:
FINISHED
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBuffer
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
InitializeRowBuffer
(
buffer
100
20
80
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
20
0
60
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferPartialRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
20
0
60
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
20
60
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferPartialRowStartColOverflow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
100
100
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
50
100
)
;
}
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferPartialRowBufferOverflow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
200
]
;
for
(
int
i
=
0
;
i
<
200
;
+
+
i
)
{
buffer
[
i
]
=
i
<
100
?
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
:
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
;
}
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
100
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
0
200
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
50
200
)
;
}
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferFromNullSource
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
*
nullBuffer
=
nullptr
;
WriteState
result
=
aSink
-
>
WriteBuffer
(
nullBuffer
)
;
EXPECT_EQ
(
WriteState
:
:
FAILURE
result
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
0
0
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteEmptyRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
auto
writeFunc
=
[
&
]
(
uint32_t
aRow
)
{
if
(
aRow
<
20
|
|
aRow
>
=
80
)
{
return
aSink
-
>
WriteBuffer
(
buffer
)
;
}
else
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
}
;
auto
checkFunc
=
[
&
]
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
0
20
BGRAColor
:
:
Green
(
)
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
20
60
BGRAColor
:
:
Transparent
(
)
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
80
20
BGRAColor
:
:
Green
(
)
)
)
;
}
;
DoCheckIterativeWrite
(
aSink
writeFunc
checkFunc
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteUnsafeComputedRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteUnsafeComputedRow
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aRow
uint32_t
aLength
)
{
EXPECT_EQ
(
100u
aLength
)
;
memcpy
(
aRow
+
50
buffer
50
*
sizeof
(
uint32_t
)
)
;
}
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelBlocks
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
InitializeRowBuffer
(
buffer
100
20
80
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
uint32_t
count
=
0
;
WriteState
result
=
aSink
-
>
WritePixelBlocks
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aBlockStart
int32_t
aLength
)
{
+
+
count
;
EXPECT_EQ
(
int32_t
(
100
)
aLength
)
;
memcpy
(
aBlockStart
buffer
100
*
sizeof
(
uint32_t
)
)
;
return
MakeTuple
(
int32_t
(
100
)
Maybe
<
WriteState
>
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
20
0
60
100
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixelBlocks
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aBlockStart
int32_t
aLength
)
{
count
+
+
;
for
(
int32_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
aBlockStart
[
i
]
=
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
;
}
return
MakeTuple
(
aLength
Maybe
<
WriteState
>
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
20
0
60
100
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelBlocksPartialRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
InitializeRowBuffer
(
buffer
100
20
80
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
for
(
int
row
=
0
;
row
<
99
;
+
+
row
)
{
for
(
int32_t
written
=
0
;
written
<
100
;
)
{
WriteState
result
=
aSink
-
>
WritePixelBlocks
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aBlockStart
int32_t
aLength
)
{
if
(
aLength
=
=
int32_t
(
100
)
&
&
written
=
=
int32_t
(
100
)
)
{
return
MakeTuple
(
int32_t
(
0
)
Some
(
WriteState
:
:
NEED_MORE_DATA
)
)
;
}
EXPECT_EQ
(
int32_t
(
100
)
-
written
aLength
)
;
memcpy
(
aBlockStart
&
buffer
[
written
]
25
*
sizeof
(
uint32_t
)
)
;
written
+
=
25
;
if
(
written
=
=
int32_t
(
100
)
)
{
return
MakeTuple
(
int32_t
(
25
)
Maybe
<
WriteState
>
(
)
)
;
}
return
MakeTuple
(
int32_t
(
25
)
Some
(
WriteState
:
:
NEED_MORE_DATA
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
}
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
row
100
1
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
row
100
1
)
invalidRect
-
>
mOutputSpaceRect
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
20
0
60
row
+
1
)
)
;
}
uint32_t
count
=
0
;
WriteState
result
=
aSink
-
>
WritePixelBlocks
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aBlockStart
int32_t
aLength
)
{
+
+
count
;
EXPECT_EQ
(
int32_t
(
100
)
aLength
)
;
memcpy
(
aBlockStart
buffer
100
*
sizeof
(
uint32_t
)
)
;
return
MakeTuple
(
int32_t
(
100
)
Maybe
<
WriteState
>
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
1u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
99
100
1
)
IntRect
(
0
99
100
1
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
20
0
60
100
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixelBlocks
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aBlockStart
int32_t
aLength
)
{
count
+
+
;
for
(
int32_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
aBlockStart
[
i
]
=
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
;
}
return
MakeTuple
(
aLength
Maybe
<
WriteState
>
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
20
0
60
100
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkProgressivePasses
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
ResetForNextPass
(
aSink
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
)
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkInvalidRect
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
100
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
100u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
0
100
1
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
0
100
1
)
invalidRect
-
>
mOutputSpaceRect
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
100
*
8
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
100u
*
8u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
1
100
8
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
1
100
8
)
invalidRect
-
>
mOutputSpaceRect
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
9
100
1
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
9
100
1
)
invalidRect
-
>
mOutputSpaceRect
)
;
}
{
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
90u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
10
100
90
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
10
100
90
)
invalidRect
-
>
mOutputSpaceRect
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
)
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkFlipVertically
)
{
WithSurfaceSink
<
Orient
:
:
FLIP_VERTICALLY
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
ResetForNextPass
(
aSink
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
25
*
100
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
25u
*
100u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
75
100
25
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
75
100
25
)
invalidRect
-
>
mOutputSpaceRect
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
0
75
BGRAColor
:
:
Red
(
)
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
75
25
BGRAColor
:
:
Green
(
)
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
75u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
75
)
IntRect
(
0
0
100
75
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
)
)
;
}
}
)
;
}
