#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
Common
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SurfacePipe
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
enum
class
Orient
{
NORMAL
FLIP_VERTICALLY
}
;
template
<
Orient
Orientation
typename
Func
>
void
WithSurfaceSink
(
Func
aFunc
)
{
RefPtr
<
Decoder
>
decoder
=
CreateTrivialDecoder
(
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
const
bool
flipVertically
=
Orientation
=
=
Orient
:
:
FLIP_VERTICALLY
;
WithFilterPipeline
(
decoder
Forward
<
Func
>
(
aFunc
)
SurfaceConfig
{
decoder
0
IntSize
(
100
100
)
SurfaceFormat
:
:
B8G8R8A8
flipVertically
}
)
;
}
template
<
typename
Func
>
void
WithPalettedSurfaceSink
(
const
IntRect
&
aFrameRect
Func
aFunc
)
{
RefPtr
<
Decoder
>
decoder
=
CreateTrivialDecoder
(
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
WithFilterPipeline
(
decoder
Forward
<
Func
>
(
aFunc
)
PalettedSurfaceConfig
{
decoder
0
IntSize
(
100
100
)
aFrameRect
SurfaceFormat
:
:
B8G8R8A8
8
false
}
)
;
}
void
ResetForNextPass
(
SurfaceFilter
*
aSink
)
{
aSink
-
>
ResetToFirstRow
(
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
template
<
typename
WriteFunc
typename
CheckFunc
>
void
DoCheckIterativeWrite
(
SurfaceFilter
*
aSink
WriteFunc
aWriteFunc
CheckFunc
aCheckFunc
)
{
uint32_t
row
=
0
;
WriteState
result
=
WriteState
:
:
NEED_MORE_DATA
;
while
(
result
=
=
WriteState
:
:
NEED_MORE_DATA
)
{
result
=
aWriteFunc
(
row
)
;
+
+
row
;
}
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
row
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
aCheckFunc
(
)
;
}
template
<
typename
WriteFunc
>
void
CheckIterativeWrite
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
const
IntRect
&
aOutputRect
WriteFunc
aWriteFunc
)
{
auto
writeFunc
=
[
&
]
(
uint32_t
)
{
return
aWriteFunc
(
)
;
}
;
DoCheckIterativeWrite
(
aSink
writeFunc
[
&
]
{
CheckGeneratedImage
(
aDecoder
aOutputRect
)
;
}
)
;
}
template
<
typename
WriteFunc
>
void
CheckPalettedIterativeWrite
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
const
IntRect
&
aOutputRect
WriteFunc
aWriteFunc
)
{
auto
writeFunc
=
[
&
]
(
uint32_t
)
{
return
aWriteFunc
(
)
;
}
;
DoCheckIterativeWrite
(
aSink
writeFunc
[
&
]
{
CheckGeneratedPalettedImage
(
aDecoder
aOutputRect
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
NullSurfaceSink
)
{
NullSurfaceSink
sink
;
nsresult
rv
=
sink
.
Configure
(
NullSurfaceConfig
{
}
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
EXPECT_TRUE
(
!
sink
.
IsValidPalettedPipe
(
)
)
;
bool
gotCalled
=
false
;
auto
result
=
sink
.
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
gotCalled
=
true
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_FALSE
(
gotCalled
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
uint32_t
source
=
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
;
result
=
sink
.
WriteBuffer
(
&
source
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
result
=
sink
.
WriteBuffer
(
&
source
0
1
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
result
=
sink
.
WriteEmptyRow
(
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
result
=
sink
.
WriteUnsafeComputedRow
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aRow
uint32_t
aLength
)
{
gotCalled
=
true
;
for
(
uint32_t
col
=
0
;
col
<
aLength
;
+
+
col
+
+
aRow
)
{
*
aRow
=
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
;
}
}
)
;
EXPECT_FALSE
(
gotCalled
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
sink
.
AdvanceRow
(
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
sink
.
ResetToFirstRow
(
)
;
EXPECT_TRUE
(
sink
.
IsSurfaceFinished
(
)
)
;
invalidRect
=
sink
.
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkInitialization
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
0
0
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixels
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
CheckWritePixels
(
aDecoder
aSink
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWritePixelsFinish
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
count
+
+
;
return
AsVariant
(
WriteState
:
:
FINISHED
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
1u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
count
=
0
;
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
0u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Transparent
(
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBuffer
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
20
<
=
i
&
&
i
<
80
?
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
:
BGRAColor
:
:
Transparent
(
)
.
AsPixel
(
)
;
}
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
20
0
60
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferPartialRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
20
0
60
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
20
60
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferPartialRowStartColOverflow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
100
100
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
50
100
)
;
}
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferPartialRowBufferOverflow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
200
]
;
for
(
int
i
=
0
;
i
<
200
;
+
+
i
)
{
buffer
[
i
]
=
i
<
100
?
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
:
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
;
}
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
100
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
0
200
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
50
200
)
;
}
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteBufferFromNullSource
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
*
nullBuffer
=
nullptr
;
WriteState
result
=
aSink
-
>
WriteBuffer
(
nullBuffer
)
;
EXPECT_EQ
(
WriteState
:
:
FAILURE
result
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
CheckGeneratedImage
(
aDecoder
IntRect
(
0
0
0
0
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteEmptyRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
auto
writeFunc
=
[
&
]
(
uint32_t
aRow
)
{
if
(
aRow
<
20
|
|
aRow
>
=
80
)
{
return
aSink
-
>
WriteBuffer
(
buffer
)
;
}
else
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
}
;
auto
checkFunc
=
[
&
]
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
0
20
BGRAColor
:
:
Green
(
)
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
20
60
BGRAColor
:
:
Transparent
(
)
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
80
20
BGRAColor
:
:
Green
(
)
)
)
;
}
;
DoCheckIterativeWrite
(
aSink
writeFunc
checkFunc
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkWriteUnsafeComputedRow
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
uint32_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
;
}
CheckIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteUnsafeComputedRow
<
uint32_t
>
(
[
&
]
(
uint32_t
*
aRow
uint32_t
aLength
)
{
EXPECT_EQ
(
100u
aLength
)
;
memcpy
(
aRow
+
50
buffer
50
*
sizeof
(
uint32_t
)
)
;
}
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkProgressivePasses
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
ResetForNextPass
(
aSink
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
)
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkInvalidRect
)
{
WithSurfaceSink
<
Orient
:
:
NORMAL
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
100
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
100u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
0
100
1
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
0
100
1
)
invalidRect
-
>
mOutputSpaceRect
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
100
*
8
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
100u
*
8u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
1
100
8
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
1
100
8
)
invalidRect
-
>
mOutputSpaceRect
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
50
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
50u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
9
100
1
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
9
100
1
)
invalidRect
-
>
mOutputSpaceRect
)
;
}
{
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
90u
count
)
;
EXPECT_TRUE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
10
100
90
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
10
100
90
)
invalidRect
-
>
mOutputSpaceRect
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
)
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
SurfaceSinkFlipVertically
)
{
WithSurfaceSink
<
Orient
:
:
FLIP_VERTICALLY
>
(
[
]
(
Decoder
*
aDecoder
SurfaceSink
*
aSink
)
{
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Red
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
100u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
100
)
IntRect
(
0
0
100
100
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
ResetForNextPass
(
aSink
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Red
(
)
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
-
>
NextPixel
<
uint32_t
>
{
if
(
count
=
=
25
*
100
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
count
+
+
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
NEED_MORE_DATA
result
)
;
EXPECT_EQ
(
25u
*
100u
count
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
IntRect
(
0
75
100
25
)
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
IntRect
(
0
75
100
25
)
invalidRect
-
>
mOutputSpaceRect
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
0
75
BGRAColor
:
:
Red
(
)
)
)
;
EXPECT_TRUE
(
RowsAreSolidColor
(
surface
75
25
BGRAColor
:
:
Green
(
)
)
)
;
}
{
uint32_t
count
=
0
;
auto
result
=
aSink
-
>
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
75u
*
100u
count
)
;
AssertCorrectPipelineFinalState
(
aSink
IntRect
(
0
0
100
75
)
IntRect
(
0
0
100
75
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSurface
(
)
;
EXPECT_TRUE
(
IsSolidColor
(
surface
BGRAColor
:
:
Green
(
)
)
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkInitialization
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
uint8_t
*
imageData
=
nullptr
;
uint32_t
imageLength
=
0
;
currentFrame
-
>
GetImageData
(
&
imageData
&
imageLength
)
;
ASSERT_TRUE
(
imageData
!
=
nullptr
)
;
ASSERT_EQ
(
100u
*
100u
imageLength
)
;
for
(
uint32_t
i
=
0
;
i
<
imageLength
;
+
+
i
)
{
ASSERT_EQ
(
uint8_t
(
0
)
imageData
[
i
]
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWritePixelsFor0_0_100_100
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
CheckPalettedWritePixels
(
aDecoder
aSink
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWritePixelsFor25_25_50_50
)
{
WithPalettedSurfaceSink
(
IntRect
(
25
25
50
50
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
CheckPalettedWritePixels
(
aDecoder
aSink
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
25
25
50
50
)
)
Some
(
IntRect
(
25
25
50
50
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWritePixelsForMinus25_Minus25_50_50
)
{
WithPalettedSurfaceSink
(
IntRect
(
-
25
-
25
50
50
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
CheckPalettedWritePixels
(
aDecoder
aSink
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
-
25
-
25
50
50
)
)
Some
(
IntRect
(
-
25
-
25
50
50
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWritePixelsFor75_Minus25_50_50
)
{
WithPalettedSurfaceSink
(
IntRect
(
75
-
25
50
50
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
CheckPalettedWritePixels
(
aDecoder
aSink
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
75
-
25
50
50
)
)
Some
(
IntRect
(
75
-
25
50
50
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWritePixelsForMinus25_75_50_50
)
{
WithPalettedSurfaceSink
(
IntRect
(
-
25
75
50
50
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
CheckPalettedWritePixels
(
aDecoder
aSink
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
-
25
75
50
50
)
)
Some
(
IntRect
(
-
25
75
50
50
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWritePixelsFor75_75_50_50
)
{
WithPalettedSurfaceSink
(
IntRect
(
75
75
50
50
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
CheckPalettedWritePixels
(
aDecoder
aSink
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
0
0
50
50
)
)
Some
(
IntRect
(
75
75
50
50
)
)
Some
(
IntRect
(
75
75
50
50
)
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteBuffer
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
uint8_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
20
<
=
i
&
&
i
<
80
?
255
:
0
;
}
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
20
0
60
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteBufferPartialRow
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
uint8_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
255
;
}
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
20
0
60
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
20
60
)
;
}
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteBufferPartialRowStartColOverflow
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
uint8_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
255
;
}
{
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
100
100
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
50
100
)
;
}
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteBufferPartialRowBufferOverflow
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
uint8_t
buffer
[
200
]
;
for
(
int
i
=
0
;
i
<
200
;
+
+
i
)
{
buffer
[
i
]
=
i
<
100
?
255
:
128
;
}
{
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
100
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
0
200
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteBuffer
(
buffer
50
200
)
;
}
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteBufferFromNullSource
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
uint8_t
*
nullBuffer
=
nullptr
;
WriteState
result
=
aSink
-
>
WriteBuffer
(
nullBuffer
)
;
EXPECT_EQ
(
WriteState
:
:
FAILURE
result
)
;
EXPECT_FALSE
(
aSink
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aSink
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
CheckGeneratedPalettedImage
(
aDecoder
IntRect
(
0
0
0
0
)
)
;
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteEmptyRow
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
{
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
0
0
0
0
)
[
&
]
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
)
;
}
ResetForNextPass
(
aSink
)
;
{
uint8_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
255
;
}
auto
writeFunc
=
[
&
]
(
uint32_t
aRow
)
{
if
(
aRow
<
20
|
|
aRow
>
=
80
)
{
return
aSink
-
>
WriteBuffer
(
buffer
)
;
}
else
{
return
aSink
-
>
WriteEmptyRow
(
)
;
}
}
;
auto
checkFunc
=
[
&
]
{
EXPECT_TRUE
(
PalettedRowsAreSolidColor
(
aDecoder
0
20
255
)
)
;
EXPECT_TRUE
(
PalettedRowsAreSolidColor
(
aDecoder
20
60
0
)
)
;
EXPECT_TRUE
(
PalettedRowsAreSolidColor
(
aDecoder
80
20
255
)
)
;
}
;
DoCheckIterativeWrite
(
aSink
writeFunc
checkFunc
)
;
}
}
)
;
}
TEST
(
ImageSurfaceSink
PalettedSurfaceSinkWriteUnsafeComputedRow
)
{
WithPalettedSurfaceSink
(
IntRect
(
0
0
100
100
)
[
]
(
Decoder
*
aDecoder
PalettedSurfaceSink
*
aSink
)
{
uint8_t
buffer
[
100
]
;
for
(
int
i
=
0
;
i
<
100
;
+
+
i
)
{
buffer
[
i
]
=
255
;
}
CheckPalettedIterativeWrite
(
aDecoder
aSink
IntRect
(
50
0
50
100
)
[
&
]
{
return
aSink
-
>
WriteUnsafeComputedRow
<
uint8_t
>
(
[
&
]
(
uint8_t
*
aRow
uint32_t
aLength
)
{
EXPECT_EQ
(
100u
aLength
)
;
memcpy
(
aRow
+
50
buffer
50
*
sizeof
(
uint8_t
)
)
;
}
)
;
}
)
;
}
)
;
}
