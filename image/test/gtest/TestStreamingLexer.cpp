#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
StreamingLexer
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
image
;
enum
class
TestState
{
ONE
TWO
THREE
UNBUFFERED
TRUNCATED_SUCCESS
TRUNCATED_FAILURE
}
;
void
CheckLexedData
(
const
char
*
aData
size_t
aLength
size_t
aOffset
size_t
aExpectedLength
)
{
EXPECT_TRUE
(
aLength
=
=
aExpectedLength
)
;
for
(
size_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
EXPECT_EQ
(
aData
[
i
]
char
(
aOffset
+
i
+
1
)
)
;
}
}
LexerTransition
<
TestState
>
DoLex
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
To
(
TestState
:
:
TWO
3
)
;
case
TestState
:
:
TWO
:
CheckLexedData
(
aData
aLength
3
3
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
3
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
6
3
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
TRUNCATED_SUCCESS
:
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
TRUNCATED_FAILURE
:
return
Transition
:
:
TerminateFailure
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithUnbuffered
(
TestState
aState
const
char
*
aData
size_t
aLength
Vector
<
char
>
&
aUnbufferedVector
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
ToUnbuffered
(
TestState
:
:
TWO
TestState
:
:
UNBUFFERED
3
)
;
case
TestState
:
:
TWO
:
CheckLexedData
(
aUnbufferedVector
.
begin
(
)
aUnbufferedVector
.
length
(
)
3
3
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
3
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
6
3
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
UNBUFFERED
:
EXPECT_TRUE
(
aLength
<
=
3
)
;
EXPECT_TRUE
(
aUnbufferedVector
.
append
(
aData
aLength
)
)
;
return
Transition
:
:
ContinueUnbuffered
(
TestState
:
:
UNBUFFERED
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithUnbufferedTerminate
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
ToUnbuffered
(
TestState
:
:
TWO
TestState
:
:
UNBUFFERED
3
)
;
case
TestState
:
:
UNBUFFERED
:
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithYield
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
ToAfterYield
(
TestState
:
:
TWO
)
;
case
TestState
:
:
TWO
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
6
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
3
6
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithTerminateAfterYield
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
ToAfterYield
(
TestState
:
:
TWO
)
;
case
TestState
:
:
TWO
:
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithZeroLengthStates
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
To
(
TestState
:
:
TWO
0
)
;
case
TestState
:
:
TWO
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
9
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
0
9
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithZeroLengthStatesAtEnd
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
9
)
;
return
Transition
:
:
To
(
TestState
:
:
TWO
0
)
;
case
TestState
:
:
TWO
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
0
)
;
case
TestState
:
:
THREE
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithZeroLengthYield
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
EXPECT_EQ
(
0u
aLength
)
;
return
Transition
:
:
ToAfterYield
(
TestState
:
:
TWO
)
;
case
TestState
:
:
TWO
:
EXPECT_EQ
(
0u
aLength
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
9
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
0
9
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithZeroLengthStatesUnbuffered
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
ToUnbuffered
(
TestState
:
:
TWO
TestState
:
:
UNBUFFERED
0
)
;
case
TestState
:
:
TWO
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
9
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
0
9
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
UNBUFFERED
:
ADD_FAILURE
(
)
<
<
"
Should
not
enter
zero
-
length
unbuffered
state
"
;
return
Transition
:
:
TerminateFailure
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
LexerTransition
<
TestState
>
DoLexWithZeroLengthStatesAfterUnbuffered
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
ToUnbuffered
(
TestState
:
:
TWO
TestState
:
:
UNBUFFERED
9
)
;
case
TestState
:
:
TWO
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
0
)
;
case
TestState
:
:
THREE
:
EXPECT_TRUE
(
aLength
=
=
0
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
UNBUFFERED
:
CheckLexedData
(
aData
aLength
0
9
)
;
return
Transition
:
:
ContinueUnbuffered
(
TestState
:
:
UNBUFFERED
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
class
ImageStreamingLexer
:
public
:
:
testing
:
:
Test
{
public
:
ImageStreamingLexer
(
)
:
mLexer
(
Transition
:
:
To
(
TestState
:
:
ONE
3
)
Transition
:
:
TerminateFailure
(
)
)
mSourceBuffer
(
new
SourceBuffer
)
mIterator
(
mSourceBuffer
-
>
Iterator
(
)
)
mExpectNoResume
(
new
ExpectNoResume
)
mCountResumes
(
new
CountResumes
)
{
}
protected
:
void
CheckTruncatedState
(
StreamingLexer
<
TestState
>
&
aLexer
TerminalState
aExpectedTerminalState
nsresult
aCompletionStatus
=
NS_OK
)
{
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
if
(
i
<
2
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
}
else
if
(
i
=
=
2
)
{
mSourceBuffer
-
>
Complete
(
aCompletionStatus
)
;
}
LexerResult
result
=
aLexer
.
Lex
(
mIterator
mCountResumes
DoLex
)
;
if
(
i
>
=
2
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
aExpectedTerminalState
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
2u
mCountResumes
-
>
Count
(
)
)
;
}
AutoInitializeImageLib
mInit
;
const
char
mData
[
9
]
{
1
2
3
4
5
6
7
8
9
}
;
StreamingLexer
<
TestState
>
mLexer
;
RefPtr
<
SourceBuffer
>
mSourceBuffer
;
SourceBufferIterator
mIterator
;
RefPtr
<
ExpectNoResume
>
mExpectNoResume
;
RefPtr
<
CountResumes
>
mCountResumes
;
}
;
TEST_F
(
ImageStreamingLexer
ZeroLengthData
)
{
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mExpectNoResume
DoLex
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
FAILURE
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthDataUnbuffered
)
{
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
ToUnbuffered
(
TestState
:
:
ONE
TestState
:
:
UNBUFFERED
sizeof
(
mData
)
)
Transition
:
:
TerminateFailure
(
)
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLex
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
FAILURE
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
StartWithTerminal
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
TerminateSuccess
(
)
Transition
:
:
TerminateFailure
(
)
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLex
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
SingleChunk
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mExpectNoResume
DoLex
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
SingleChunkWithUnbuffered
)
{
Vector
<
char
>
unbufferedVector
;
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mExpectNoResume
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
return
DoLexWithUnbuffered
(
aState
aData
aLength
unbufferedVector
)
;
}
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
SingleChunkWithYield
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithYield
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
result
=
mLexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithYield
)
;
ASSERT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ChunkPerState
)
{
for
(
unsigned
i
=
0
;
i
<
3
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
3
*
i
3
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLex
)
;
if
(
i
=
=
2
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
2u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
ChunkPerStateWithUnbuffered
)
{
Vector
<
char
>
unbufferedVector
;
for
(
unsigned
i
=
0
;
i
<
3
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
3
*
i
3
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
return
DoLexWithUnbuffered
(
aState
aData
aLength
unbufferedVector
)
;
}
)
;
if
(
i
=
=
2
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
2u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
ChunkPerStateWithYield
)
{
mSourceBuffer
-
>
Append
(
mData
3
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithYield
)
;
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithYield
)
;
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
mSourceBuffer
-
>
Append
(
mData
+
3
6
)
;
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithYield
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
1u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
ChunkPerStateWithUnbufferedYield
)
{
size_t
unbufferedCallCount
=
0
;
Vector
<
char
>
unbufferedVector
;
auto
lexerFunc
=
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
-
>
LexerTransition
<
TestState
>
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
CheckLexedData
(
aData
aLength
0
3
)
;
return
Transition
:
:
ToUnbuffered
(
TestState
:
:
TWO
TestState
:
:
UNBUFFERED
3
)
;
case
TestState
:
:
TWO
:
CheckLexedData
(
unbufferedVector
.
begin
(
)
unbufferedVector
.
length
(
)
3
3
)
;
return
Transition
:
:
To
(
TestState
:
:
THREE
3
)
;
case
TestState
:
:
THREE
:
CheckLexedData
(
aData
aLength
6
3
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
UNBUFFERED
:
switch
(
unbufferedCallCount
)
{
case
0
:
CheckLexedData
(
aData
aLength
3
3
)
;
EXPECT_TRUE
(
unbufferedVector
.
append
(
aData
2
)
)
;
unbufferedCallCount
+
+
;
return
Transition
:
:
ContinueUnbufferedAfterYield
(
TestState
:
:
UNBUFFERED
2
)
;
case
1
:
CheckLexedData
(
aData
aLength
5
1
)
;
EXPECT_TRUE
(
unbufferedVector
.
append
(
aData
1
)
)
;
unbufferedCallCount
+
+
;
return
Transition
:
:
ContinueUnbuffered
(
TestState
:
:
UNBUFFERED
)
;
}
ADD_FAILURE
(
)
<
<
"
Too
many
invocations
of
TestState
:
:
UNBUFFERED
"
;
return
Transition
:
:
TerminateFailure
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
;
for
(
unsigned
i
=
0
;
i
<
3
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
3
*
i
3
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
lexerFunc
)
;
switch
(
i
)
{
case
0
:
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
0u
unbufferedCallCount
)
;
break
;
case
1
:
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
1u
unbufferedCallCount
)
;
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
lexerFunc
)
;
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
2u
unbufferedCallCount
)
;
break
;
case
2
:
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
break
;
}
}
EXPECT_EQ
(
2u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
lexerFunc
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
OneByteChunks
)
{
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLex
)
;
if
(
i
=
=
8
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
8u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
OneByteChunksWithUnbuffered
)
{
Vector
<
char
>
unbufferedVector
;
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
return
DoLexWithUnbuffered
(
aState
aData
aLength
unbufferedVector
)
;
}
)
;
if
(
i
=
=
8
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
8u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
OneByteChunksWithYield
)
{
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithYield
)
;
switch
(
i
)
{
case
2
:
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithYield
)
;
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
break
;
case
8
:
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
break
;
default
:
EXPECT_TRUE
(
i
<
9
)
;
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
8u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthState
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
0
)
Transition
:
:
TerminateFailure
(
)
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithZeroLengthStates
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthStatesAtEnd
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
9
)
Transition
:
:
TerminateFailure
(
)
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithZeroLengthStatesAtEnd
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthStateWithYield
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
0
)
Transition
:
:
TerminateFailure
(
)
)
;
mSourceBuffer
-
>
Append
(
mData
3
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithZeroLengthYield
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
result
=
lexer
.
Lex
(
mIterator
mCountResumes
DoLexWithZeroLengthYield
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
mSourceBuffer
-
>
Append
(
mData
+
3
sizeof
(
mData
)
-
3
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithZeroLengthYield
)
;
ASSERT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
1u
mCountResumes
-
>
Count
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthStateWithUnbuffered
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
ToUnbuffered
(
TestState
:
:
ONE
TestState
:
:
UNBUFFERED
0
)
Transition
:
:
TerminateFailure
(
)
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithZeroLengthStatesUnbuffered
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthStateAfterUnbuffered
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
0
)
Transition
:
:
TerminateFailure
(
)
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
DoLexWithZeroLengthStatesAfterUnbuffered
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
ZeroLengthStateWithUnbufferedYield
)
{
size_t
unbufferedCallCount
=
0
;
auto
lexerFunc
=
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
-
>
LexerTransition
<
TestState
>
{
switch
(
aState
)
{
case
TestState
:
:
ONE
:
EXPECT_EQ
(
0u
aLength
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
case
TestState
:
:
UNBUFFERED
:
switch
(
unbufferedCallCount
)
{
case
0
:
CheckLexedData
(
aData
aLength
0
3
)
;
unbufferedCallCount
+
+
;
return
Transition
:
:
ContinueUnbufferedAfterYield
(
TestState
:
:
UNBUFFERED
0
)
;
case
1
:
CheckLexedData
(
aData
aLength
0
3
)
;
unbufferedCallCount
+
+
;
return
Transition
:
:
ContinueUnbufferedAfterYield
(
TestState
:
:
UNBUFFERED
2
)
;
case
2
:
EXPECT_EQ
(
1u
aLength
)
;
CheckLexedData
(
aData
aLength
2
1
)
;
unbufferedCallCount
+
+
;
return
Transition
:
:
ContinueUnbufferedAfterYield
(
TestState
:
:
UNBUFFERED
1
)
;
case
3
:
CheckLexedData
(
aData
aLength
3
6
)
;
unbufferedCallCount
+
+
;
return
Transition
:
:
ContinueUnbufferedAfterYield
(
TestState
:
:
UNBUFFERED
6
)
;
}
ADD_FAILURE
(
)
<
<
"
Too
many
invocations
of
TestState
:
:
UNBUFFERED
"
;
return
Transition
:
:
TerminateFailure
(
)
;
default
:
MOZ_CRASH
(
"
Unexpected
or
unhandled
TestState
"
)
;
}
}
;
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
ToUnbuffered
(
TestState
:
:
ONE
TestState
:
:
UNBUFFERED
sizeof
(
mData
)
)
Transition
:
:
TerminateFailure
(
)
)
;
mSourceBuffer
-
>
Append
(
mData
3
)
;
LexerResult
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
lexerFunc
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
1u
unbufferedCallCount
)
;
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
lexerFunc
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
2u
unbufferedCallCount
)
;
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
lexerFunc
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
3u
unbufferedCallCount
)
;
result
=
lexer
.
Lex
(
mIterator
mCountResumes
lexerFunc
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
3u
unbufferedCallCount
)
;
mSourceBuffer
-
>
Append
(
mData
+
3
6
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
EXPECT_EQ
(
1u
mCountResumes
-
>
Count
(
)
)
;
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
lexerFunc
)
;
ASSERT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
EXPECT_EQ
(
4u
unbufferedCallCount
)
;
result
=
lexer
.
Lex
(
mIterator
mExpectNoResume
lexerFunc
)
;
ASSERT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
TerminateSuccess
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
SourceBufferIterator
iterator
=
mSourceBuffer
-
>
Iterator
(
)
;
LexerResult
result
=
mLexer
.
Lex
(
iterator
mExpectNoResume
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
EXPECT_TRUE
(
aState
=
=
TestState
:
:
ONE
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
}
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
SourceBufferIterator
iterator2
=
mSourceBuffer
-
>
Iterator
(
)
;
result
=
mLexer
.
Lex
(
iterator2
mExpectNoResume
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
EXPECT_TRUE
(
false
)
;
return
Transition
:
:
TerminateFailure
(
)
;
}
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
TerminateFailure
)
{
mSourceBuffer
-
>
Append
(
mData
sizeof
(
mData
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
SourceBufferIterator
iterator
=
mSourceBuffer
-
>
Iterator
(
)
;
LexerResult
result
=
mLexer
.
Lex
(
iterator
mExpectNoResume
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
EXPECT_TRUE
(
aState
=
=
TestState
:
:
ONE
)
;
return
Transition
:
:
TerminateFailure
(
)
;
}
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
FAILURE
result
.
as
<
TerminalState
>
(
)
)
;
SourceBufferIterator
iterator2
=
mSourceBuffer
-
>
Iterator
(
)
;
result
=
mLexer
.
Lex
(
iterator2
mExpectNoResume
[
&
]
(
TestState
aState
const
char
*
aData
size_t
aLength
)
{
EXPECT_TRUE
(
false
)
;
return
Transition
:
:
TerminateFailure
(
)
;
}
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
FAILURE
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
TerminateUnbuffered
)
{
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithUnbufferedTerminate
)
;
if
(
i
>
2
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
3u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
TerminateAfterYield
)
{
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mCountResumes
DoLexWithTerminateAfterYield
)
;
if
(
i
>
2
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
if
(
i
=
=
2
)
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
OUTPUT_AVAILABLE
result
.
as
<
Yield
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
EXPECT_EQ
(
2u
mCountResumes
-
>
Count
(
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
TEST_F
(
ImageStreamingLexer
SourceBufferImmediateComplete
)
{
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
mExpectNoResume
DoLex
)
;
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
FAILURE
result
.
as
<
TerminalState
>
(
)
)
;
}
TEST_F
(
ImageStreamingLexer
SourceBufferTruncatedTerminalStateSuccess
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
3
)
Transition
:
:
TerminateSuccess
(
)
)
;
CheckTruncatedState
(
lexer
TerminalState
:
:
SUCCESS
)
;
}
TEST_F
(
ImageStreamingLexer
SourceBufferTruncatedTerminalStateFailure
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
3
)
Transition
:
:
TerminateFailure
(
)
)
;
CheckTruncatedState
(
lexer
TerminalState
:
:
FAILURE
)
;
}
TEST_F
(
ImageStreamingLexer
SourceBufferTruncatedStateReturningSuccess
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
3
)
Transition
:
:
To
(
TestState
:
:
TRUNCATED_SUCCESS
0
)
)
;
CheckTruncatedState
(
lexer
TerminalState
:
:
SUCCESS
)
;
}
TEST_F
(
ImageStreamingLexer
SourceBufferTruncatedStateReturningFailure
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
3
)
Transition
:
:
To
(
TestState
:
:
TRUNCATED_FAILURE
0
)
)
;
CheckTruncatedState
(
lexer
TerminalState
:
:
FAILURE
)
;
}
TEST_F
(
ImageStreamingLexer
SourceBufferTruncatedFailingCompleteStatus
)
{
StreamingLexer
<
TestState
>
lexer
(
Transition
:
:
To
(
TestState
:
:
ONE
3
)
Transition
:
:
TerminateSuccess
(
)
)
;
CheckTruncatedState
(
lexer
TerminalState
:
:
FAILURE
NS_ERROR_FAILURE
)
;
}
TEST_F
(
ImageStreamingLexer
NoSourceBufferResumable
)
{
for
(
unsigned
i
=
0
;
i
<
9
;
+
+
i
)
{
mSourceBuffer
-
>
Append
(
mData
+
i
1
)
;
LexerResult
result
=
mLexer
.
Lex
(
mIterator
nullptr
DoLex
)
;
if
(
i
=
=
8
)
{
EXPECT_TRUE
(
result
.
is
<
TerminalState
>
(
)
)
;
EXPECT_EQ
(
TerminalState
:
:
SUCCESS
result
.
as
<
TerminalState
>
(
)
)
;
}
else
{
EXPECT_TRUE
(
result
.
is
<
Yield
>
(
)
)
;
EXPECT_EQ
(
Yield
:
:
NEED_MORE_DATA
result
.
as
<
Yield
>
(
)
)
;
}
}
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
