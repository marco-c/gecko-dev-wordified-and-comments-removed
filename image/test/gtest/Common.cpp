#
include
"
Common
.
h
"
#
include
<
cstdlib
>
#
include
"
gfxPrefs
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIDirectoryService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
namespace
image
{
using
namespace
gfx
;
using
std
:
:
abs
;
using
std
:
:
vector
;
static
bool
sImageLibInitialized
=
false
;
AutoInitializeImageLib
:
:
AutoInitializeImageLib
(
)
{
if
(
MOZ_LIKELY
(
sImageLibInitialized
)
)
{
return
;
}
EXPECT_TRUE
(
NS_IsMainThread
(
)
)
;
sImageLibInitialized
=
true
;
nsresult
rv
=
Preferences
:
:
SetBool
(
"
gfx
.
color_management
.
force_srgb
"
true
)
;
EXPECT_TRUE
(
rv
=
=
NS_OK
)
;
rv
=
Preferences
:
:
SetBool
(
"
image
.
webp
.
enabled
"
true
)
;
EXPECT_TRUE
(
rv
=
=
NS_OK
)
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_CreateInstance
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
EXPECT_TRUE
(
imgTools
!
=
nullptr
)
;
gfxPlatform
:
:
GetPlatform
(
)
;
SpinPendingEvents
(
)
;
}
#
define
ASSERT_TRUE_OR_RETURN
(
e
rv
)
\
EXPECT_TRUE
(
e
)
;
\
if
(
!
(
e
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_EQ_OR_RETURN
(
a
b
rv
)
\
EXPECT_EQ
(
a
b
)
;
\
if
(
(
a
)
!
=
(
b
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_GE_OR_RETURN
(
a
b
rv
)
\
EXPECT_GE
(
a
b
)
;
\
if
(
!
(
(
a
)
>
=
(
b
)
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_LE_OR_RETURN
(
a
b
rv
)
\
EXPECT_LE
(
a
b
)
;
\
if
(
!
(
(
a
)
<
=
(
b
)
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_LT_OR_RETURN
(
a
b
rv
)
\
EXPECT_LT
(
a
b
)
;
\
if
(
!
(
(
a
)
<
(
b
)
)
)
{
\
return
rv
;
\
}
void
SpinPendingEvents
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
EXPECT_TRUE
(
mainThread
!
=
nullptr
)
;
bool
processed
;
do
{
processed
=
false
;
nsresult
rv
=
mainThread
-
>
ProcessNextEvent
(
false
&
processed
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
}
while
(
processed
)
;
}
already_AddRefed
<
nsIInputStream
>
LoadFile
(
const
char
*
aRelativePath
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
dirService
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
;
ASSERT_TRUE_OR_RETURN
(
dirService
!
=
nullptr
nullptr
)
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
dirService
-
>
Get
(
NS_OS_CURRENT_WORKING_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
file
)
)
;
ASSERT_TRUE_OR_RETURN
(
NS_SUCCEEDED
(
rv
)
nullptr
)
;
file
-
>
AppendNative
(
nsDependentCString
(
aRelativePath
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
inputStream
)
file
)
;
ASSERT_TRUE_OR_RETURN
(
NS_SUCCEEDED
(
rv
)
nullptr
)
;
if
(
!
NS_InputStreamIsBuffered
(
inputStream
)
)
{
nsCOMPtr
<
nsIInputStream
>
bufStream
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufStream
)
inputStream
.
forget
(
)
1024
)
;
ASSERT_TRUE_OR_RETURN
(
NS_SUCCEEDED
(
rv
)
nullptr
)
;
inputStream
=
bufStream
;
}
return
inputStream
.
forget
(
)
;
}
bool
IsSolidColor
(
SourceSurface
*
aSurface
BGRAColor
aColor
uint8_t
aFuzz
)
{
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
return
RectIsSolidColor
(
aSurface
IntRect
(
0
0
size
.
width
size
.
height
)
aColor
aFuzz
)
;
}
bool
IsSolidPalettedColor
(
Decoder
*
aDecoder
uint8_t
aColor
)
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
return
PalettedRectIsSolidColor
(
aDecoder
currentFrame
-
>
GetRect
(
)
aColor
)
;
}
bool
RowsAreSolidColor
(
SourceSurface
*
aSurface
int32_t
aStartRow
int32_t
aRowCount
BGRAColor
aColor
uint8_t
aFuzz
)
{
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
return
RectIsSolidColor
(
aSurface
IntRect
(
0
aStartRow
size
.
width
aRowCount
)
aColor
aFuzz
)
;
}
bool
PalettedRowsAreSolidColor
(
Decoder
*
aDecoder
int32_t
aStartRow
int32_t
aRowCount
uint8_t
aColor
)
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
IntRect
frameRect
=
currentFrame
-
>
GetRect
(
)
;
IntRect
solidColorRect
(
frameRect
.
X
(
)
aStartRow
frameRect
.
Width
(
)
aRowCount
)
;
return
PalettedRectIsSolidColor
(
aDecoder
solidColorRect
aColor
)
;
}
bool
RectIsSolidColor
(
SourceSurface
*
aSurface
const
IntRect
&
aRect
BGRAColor
aColor
uint8_t
aFuzz
)
{
IntSize
surfaceSize
=
aSurface
-
>
GetSize
(
)
;
IntRect
rect
=
aRect
.
Intersect
(
IntRect
(
0
0
surfaceSize
.
width
surfaceSize
.
height
)
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
aSurface
-
>
GetDataSurface
(
)
;
ASSERT_TRUE_OR_RETURN
(
dataSurface
!
=
nullptr
false
)
;
DataSourceSurface
:
:
ScopedMap
mapping
(
dataSurface
DataSourceSurface
:
:
MapType
:
:
READ
)
;
ASSERT_TRUE_OR_RETURN
(
mapping
.
IsMapped
(
)
false
)
;
ASSERT_EQ_OR_RETURN
(
mapping
.
GetStride
(
)
surfaceSize
.
width
*
4
false
)
;
uint8_t
*
data
=
mapping
.
GetData
(
)
;
ASSERT_TRUE_OR_RETURN
(
data
!
=
nullptr
false
)
;
BGRAColor
pmColor
=
aColor
.
Premultiply
(
)
;
int32_t
rowLength
=
mapping
.
GetStride
(
)
;
for
(
int32_t
row
=
rect
.
Y
(
)
;
row
<
rect
.
YMost
(
)
;
+
+
row
)
{
for
(
int32_t
col
=
rect
.
X
(
)
;
col
<
rect
.
XMost
(
)
;
+
+
col
)
{
int32_t
i
=
row
*
rowLength
+
col
*
4
;
if
(
aFuzz
!
=
0
)
{
ASSERT_LE_OR_RETURN
(
abs
(
pmColor
.
mBlue
-
data
[
i
+
0
]
)
aFuzz
false
)
;
ASSERT_LE_OR_RETURN
(
abs
(
pmColor
.
mGreen
-
data
[
i
+
1
]
)
aFuzz
false
)
;
ASSERT_LE_OR_RETURN
(
abs
(
pmColor
.
mRed
-
data
[
i
+
2
]
)
aFuzz
false
)
;
ASSERT_LE_OR_RETURN
(
abs
(
pmColor
.
mAlpha
-
data
[
i
+
3
]
)
aFuzz
false
)
;
}
else
{
ASSERT_EQ_OR_RETURN
(
pmColor
.
mBlue
data
[
i
+
0
]
false
)
;
ASSERT_EQ_OR_RETURN
(
pmColor
.
mGreen
data
[
i
+
1
]
false
)
;
ASSERT_EQ_OR_RETURN
(
pmColor
.
mRed
data
[
i
+
2
]
false
)
;
ASSERT_EQ_OR_RETURN
(
pmColor
.
mAlpha
data
[
i
+
3
]
false
)
;
}
}
}
return
true
;
}
bool
PalettedRectIsSolidColor
(
Decoder
*
aDecoder
const
IntRect
&
aRect
uint8_t
aColor
)
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
uint8_t
*
imageData
;
uint32_t
imageLength
;
currentFrame
-
>
GetImageData
(
&
imageData
&
imageLength
)
;
ASSERT_TRUE_OR_RETURN
(
imageData
false
)
;
IntRect
frameRect
=
currentFrame
-
>
GetRect
(
)
;
ASSERT_EQ_OR_RETURN
(
imageLength
uint32_t
(
frameRect
.
Area
(
)
)
false
)
;
IntRect
rect
=
aRect
.
Intersect
(
frameRect
)
;
ASSERT_EQ_OR_RETURN
(
rect
.
Area
(
)
aRect
.
Area
(
)
false
)
;
rect
-
=
frameRect
.
TopLeft
(
)
;
int32_t
rowLength
=
frameRect
.
Width
(
)
;
for
(
int32_t
row
=
rect
.
Y
(
)
;
row
<
rect
.
YMost
(
)
;
+
+
row
)
{
for
(
int32_t
col
=
rect
.
X
(
)
;
col
<
rect
.
XMost
(
)
;
+
+
col
)
{
int32_t
i
=
row
*
rowLength
+
col
;
ASSERT_EQ_OR_RETURN
(
aColor
imageData
[
i
]
false
)
;
}
}
return
true
;
}
bool
RowHasPixels
(
SourceSurface
*
aSurface
int32_t
aRow
const
vector
<
BGRAColor
>
&
aPixels
)
{
ASSERT_GE_OR_RETURN
(
aRow
0
false
)
;
IntSize
surfaceSize
=
aSurface
-
>
GetSize
(
)
;
ASSERT_EQ_OR_RETURN
(
aPixels
.
size
(
)
size_t
(
surfaceSize
.
width
)
false
)
;
ASSERT_LT_OR_RETURN
(
aRow
surfaceSize
.
height
false
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
aSurface
-
>
GetDataSurface
(
)
;
ASSERT_TRUE_OR_RETURN
(
dataSurface
false
)
;
DataSourceSurface
:
:
ScopedMap
mapping
(
dataSurface
DataSourceSurface
:
:
MapType
:
:
READ
)
;
ASSERT_TRUE_OR_RETURN
(
mapping
.
IsMapped
(
)
false
)
;
ASSERT_EQ_OR_RETURN
(
mapping
.
GetStride
(
)
surfaceSize
.
width
*
4
false
)
;
uint8_t
*
data
=
mapping
.
GetData
(
)
;
ASSERT_TRUE_OR_RETURN
(
data
!
=
nullptr
false
)
;
int32_t
rowLength
=
mapping
.
GetStride
(
)
;
for
(
int32_t
col
=
0
;
col
<
surfaceSize
.
width
;
+
+
col
)
{
int32_t
i
=
aRow
*
rowLength
+
col
*
4
;
ASSERT_EQ_OR_RETURN
(
aPixels
[
col
]
.
mBlue
data
[
i
+
0
]
false
)
;
ASSERT_EQ_OR_RETURN
(
aPixels
[
col
]
.
mGreen
data
[
i
+
1
]
false
)
;
ASSERT_EQ_OR_RETURN
(
aPixels
[
col
]
.
mRed
data
[
i
+
2
]
false
)
;
ASSERT_EQ_OR_RETURN
(
aPixels
[
col
]
.
mAlpha
data
[
i
+
3
]
false
)
;
}
return
true
;
}
already_AddRefed
<
Decoder
>
CreateTrivialDecoder
(
)
{
gfxPrefs
:
:
GetSingleton
(
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
"
image
/
gif
"
)
;
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
RefPtr
<
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
Nothing
(
)
DefaultDecoderFlags
(
)
DefaultSurfaceFlags
(
)
)
;
return
decoder
.
forget
(
)
;
}
void
AssertCorrectPipelineFinalState
(
SurfaceFilter
*
aFilter
const
gfx
:
:
IntRect
&
aInputSpaceRect
const
gfx
:
:
IntRect
&
aOutputSpaceRect
)
{
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
aInputSpaceRect
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
aOutputSpaceRect
invalidRect
-
>
mOutputSpaceRect
)
;
}
void
CheckGeneratedImage
(
Decoder
*
aDecoder
const
IntRect
&
aRect
uint8_t
aFuzz
)
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
CheckGeneratedSurface
(
surface
aRect
BGRAColor
:
:
Green
(
)
BGRAColor
:
:
Transparent
(
)
aFuzz
)
;
}
void
CheckGeneratedSurface
(
SourceSurface
*
aSurface
const
IntRect
&
aRect
const
BGRAColor
&
aInnerColor
const
BGRAColor
&
aOuterColor
uint8_t
aFuzz
)
{
const
IntSize
surfaceSize
=
aSurface
-
>
GetSize
(
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
aRect
aInnerColor
aFuzz
)
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
0
0
surfaceSize
.
width
aRect
.
Y
(
)
)
aOuterColor
aFuzz
)
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
0
aRect
.
Y
(
)
aRect
.
X
(
)
aRect
.
YMost
(
)
)
aOuterColor
aFuzz
)
)
;
const
int32_t
widthOnRight
=
surfaceSize
.
width
-
aRect
.
XMost
(
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
aRect
.
XMost
(
)
aRect
.
Y
(
)
widthOnRight
aRect
.
YMost
(
)
)
aOuterColor
aFuzz
)
)
;
const
int32_t
heightBelow
=
surfaceSize
.
height
-
aRect
.
YMost
(
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
0
aRect
.
YMost
(
)
surfaceSize
.
width
heightBelow
)
aOuterColor
aFuzz
)
)
;
}
void
CheckGeneratedPalettedImage
(
Decoder
*
aDecoder
const
IntRect
&
aRect
)
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
IntSize
imageSize
=
currentFrame
-
>
GetImageSize
(
)
;
EXPECT_TRUE
(
PalettedRectIsSolidColor
(
aDecoder
aRect
255
)
)
;
EXPECT_TRUE
(
PalettedRectIsSolidColor
(
aDecoder
IntRect
(
0
0
imageSize
.
width
aRect
.
Y
(
)
)
0
)
)
;
EXPECT_TRUE
(
PalettedRectIsSolidColor
(
aDecoder
IntRect
(
0
aRect
.
Y
(
)
aRect
.
X
(
)
aRect
.
YMost
(
)
)
0
)
)
;
const
int32_t
widthOnRight
=
imageSize
.
width
-
aRect
.
XMost
(
)
;
EXPECT_TRUE
(
PalettedRectIsSolidColor
(
aDecoder
IntRect
(
aRect
.
XMost
(
)
aRect
.
Y
(
)
widthOnRight
aRect
.
YMost
(
)
)
0
)
)
;
const
int32_t
heightBelow
=
imageSize
.
height
-
aRect
.
YMost
(
)
;
EXPECT_TRUE
(
PalettedRectIsSolidColor
(
aDecoder
IntRect
(
0
aRect
.
YMost
(
)
imageSize
.
width
heightBelow
)
0
)
)
;
}
void
CheckWritePixels
(
Decoder
*
aDecoder
SurfaceFilter
*
aFilter
const
Maybe
<
IntRect
>
&
aOutputRect
const
Maybe
<
IntRect
>
&
aInputRect
const
Maybe
<
IntRect
>
&
aInputWriteRect
const
Maybe
<
IntRect
>
&
aOutputWriteRect
uint8_t
aFuzz
)
{
IntRect
outputRect
=
aOutputRect
.
valueOr
(
IntRect
(
0
0
100
100
)
)
;
IntRect
inputRect
=
aInputRect
.
valueOr
(
IntRect
(
0
0
100
100
)
)
;
IntRect
inputWriteRect
=
aInputWriteRect
.
valueOr
(
inputRect
)
;
IntRect
outputWriteRect
=
aOutputWriteRect
.
valueOr
(
outputRect
)
;
int32_t
count
=
0
;
auto
result
=
aFilter
-
>
WritePixels
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
inputWriteRect
.
Width
(
)
*
inputWriteRect
.
Height
(
)
count
)
;
AssertCorrectPipelineFinalState
(
aFilter
inputRect
outputRect
)
;
const
int32_t
oldCount
=
count
;
result
=
aFilter
-
>
WritePixels
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
BGRAColor
:
:
Green
(
)
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
oldCount
count
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
aFilter
-
>
AdvanceRow
(
)
;
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
CheckGeneratedImage
(
aDecoder
outputWriteRect
aFuzz
)
;
}
void
CheckPalettedWritePixels
(
Decoder
*
aDecoder
SurfaceFilter
*
aFilter
const
Maybe
<
IntRect
>
&
aOutputRect
const
Maybe
<
IntRect
>
&
aInputRect
const
Maybe
<
IntRect
>
&
aInputWriteRect
const
Maybe
<
IntRect
>
&
aOutputWriteRect
uint8_t
aFuzz
)
{
IntRect
outputRect
=
aOutputRect
.
valueOr
(
IntRect
(
0
0
100
100
)
)
;
IntRect
inputRect
=
aInputRect
.
valueOr
(
IntRect
(
0
0
100
100
)
)
;
IntRect
inputWriteRect
=
aInputWriteRect
.
valueOr
(
inputRect
)
;
IntRect
outputWriteRect
=
aOutputWriteRect
.
valueOr
(
outputRect
)
;
int32_t
count
=
0
;
auto
result
=
aFilter
-
>
WritePixels
<
uint8_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
uint8_t
(
255
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
inputWriteRect
.
Width
(
)
*
inputWriteRect
.
Height
(
)
count
)
;
AssertCorrectPipelineFinalState
(
aFilter
inputRect
outputRect
)
;
const
int32_t
oldCount
=
count
;
result
=
aFilter
-
>
WritePixels
<
uint8_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
uint8_t
(
255
)
)
;
}
)
;
EXPECT_EQ
(
oldCount
count
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
aFilter
-
>
AdvanceRow
(
)
;
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
uint8_t
*
imageData
;
uint32_t
imageLength
;
currentFrame
-
>
GetImageData
(
&
imageData
&
imageLength
)
;
ASSERT_TRUE
(
imageData
!
=
nullptr
)
;
ASSERT_EQ
(
outputWriteRect
.
Width
(
)
*
outputWriteRect
.
Height
(
)
int32_t
(
imageLength
)
)
;
for
(
uint32_t
i
=
0
;
i
<
imageLength
;
+
+
i
)
{
ASSERT_EQ
(
uint8_t
(
255
)
imageData
[
i
]
)
;
}
}
ImageTestCase
GreenPNGTestCase
(
)
{
return
ImageTestCase
(
"
green
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenGIFTestCase
(
)
{
return
ImageTestCase
(
"
green
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenJPGTestCase
(
)
{
return
ImageTestCase
(
"
green
.
jpg
"
"
image
/
jpeg
"
IntSize
(
100
100
)
TEST_CASE_IS_FUZZY
)
;
}
ImageTestCase
GreenBMPTestCase
(
)
{
return
ImageTestCase
(
"
green
.
bmp
"
"
image
/
bmp
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenICOTestCase
(
)
{
return
ImageTestCase
(
"
green
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
GreenIconTestCase
(
)
{
return
ImageTestCase
(
"
green
.
icon
"
"
image
/
icon
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
GreenWebPTestCase
(
)
{
return
ImageTestCase
(
"
green
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
LargeWebPTestCase
(
)
{
return
ImageTestCase
(
"
large
.
webp
"
"
image
/
webp
"
IntSize
(
1200
660
)
TEST_CASE_IGNORE_OUTPUT
)
;
}
ImageTestCase
GreenWebPIccSrgbTestCase
(
)
{
return
ImageTestCase
(
"
green
.
icc_srgb
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenFirstFrameAnimatedGIFTestCase
(
)
{
return
ImageTestCase
(
"
first
-
frame
-
green
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
GreenFirstFrameAnimatedPNGTestCase
(
)
{
return
ImageTestCase
(
"
first
-
frame
-
green
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
GreenFirstFrameAnimatedWebPTestCase
(
)
{
return
ImageTestCase
(
"
first
-
frame
-
green
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
BlendAnimatedGIFTestCase
(
)
{
return
ImageTestCase
(
"
blend
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
BlendAnimatedPNGTestCase
(
)
{
return
ImageTestCase
(
"
blend
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
BlendAnimatedWebPTestCase
(
)
{
return
ImageTestCase
(
"
blend
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
CorruptTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
.
jpg
"
"
image
/
jpeg
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptBMPWithTruncatedHeader
(
)
{
return
ImageTestCase
(
"
invalid
-
truncated
-
metadata
.
bmp
"
"
image
/
bmp
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptICOWithBadBMPWidthTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
-
with
-
bad
-
bmp
-
width
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptICOWithBadBMPHeightTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
-
with
-
bad
-
bmp
-
height
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptICOWithBadBppTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
-
with
-
bad
-
ico
-
bpp
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentPNGTestCase
(
)
{
return
ImageTestCase
(
"
transparent
.
png
"
"
image
/
png
"
IntSize
(
32
32
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentGIFTestCase
(
)
{
return
ImageTestCase
(
"
transparent
.
gif
"
"
image
/
gif
"
IntSize
(
16
16
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentWebPTestCase
(
)
{
ImageTestCase
test
(
"
transparent
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
test
.
mColor
=
BGRAColor
:
:
Transparent
(
)
;
return
test
;
}
ImageTestCase
TransparentNoAlphaHeaderWebPTestCase
(
)
{
ImageTestCase
test
(
"
transparent
-
no
-
alpha
-
header
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_FUZZY
)
;
test
.
mColor
=
BGRAColor
(
0x00
0x00
0x00
0xFF
)
;
return
test
;
}
ImageTestCase
FirstFramePaddingGIFTestCase
(
)
{
return
ImageTestCase
(
"
transparent
.
gif
"
"
image
/
gif
"
IntSize
(
16
16
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentIfWithinICOBMPTestCase
(
TestCaseFlags
aFlags
)
{
return
ImageTestCase
(
"
transparent
-
if
-
within
-
ico
.
bmp
"
"
image
/
bmp
"
IntSize
(
32
32
)
aFlags
)
;
}
ImageTestCase
RLE4BMPTestCase
(
)
{
return
ImageTestCase
(
"
rle4
.
bmp
"
"
image
/
bmp
"
IntSize
(
320
240
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
RLE8BMPTestCase
(
)
{
return
ImageTestCase
(
"
rle8
.
bmp
"
"
image
/
bmp
"
IntSize
(
32
32
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
NoFrameDelayGIFTestCase
(
)
{
return
ImageTestCase
(
"
no
-
frame
-
delay
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
ExtraImageSubBlocksAnimatedGIFTestCase
(
)
{
return
ImageTestCase
(
"
animated
-
with
-
extra
-
image
-
sub
-
blocks
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
DownscaledPNGTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledGIFTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledJPGTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
jpg
"
"
image
/
jpeg
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledBMPTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
bmp
"
"
image
/
bmp
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledICOTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
IntSize
(
20
20
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
DownscaledIconTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
icon
"
"
image
/
icon
"
IntSize
(
100
100
)
IntSize
(
20
20
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
DownscaledWebPTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledTransparentICOWithANDMaskTestCase
(
)
{
return
ImageTestCase
(
"
transparent
-
ico
-
with
-
and
-
mask
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
32
32
)
IntSize
(
20
20
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IGNORE_OUTPUT
)
;
}
ImageTestCase
TruncatedSmallGIFTestCase
(
)
{
return
ImageTestCase
(
"
green
-
1x1
-
truncated
.
gif
"
"
image
/
gif
"
IntSize
(
1
1
)
)
;
}
ImageTestCase
LargeICOWithBMPTestCase
(
)
{
return
ImageTestCase
(
"
green
-
large
-
bmp
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
256
256
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
LargeICOWithPNGTestCase
(
)
{
return
ImageTestCase
(
"
green
-
large
-
png
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
512
512
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
GreenMultipleSizesICOTestCase
(
)
{
return
ImageTestCase
(
"
green
-
multiple
-
sizes
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
256
256
)
)
;
}
}
}
