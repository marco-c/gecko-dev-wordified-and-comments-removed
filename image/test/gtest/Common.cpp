#
include
"
Common
.
h
"
#
include
<
cstdlib
>
#
include
"
gfxPlatform
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIProperties
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
namespace
image
{
using
namespace
gfx
;
using
std
:
:
vector
;
static
bool
sImageLibInitialized
=
false
;
AutoInitializeImageLib
:
:
AutoInitializeImageLib
(
)
{
if
(
MOZ_LIKELY
(
sImageLibInitialized
)
)
{
return
;
}
EXPECT_TRUE
(
NS_IsMainThread
(
)
)
;
sImageLibInitialized
=
true
;
nsresult
rv
=
Preferences
:
:
SetBool
(
"
image
.
avif
.
enabled
"
true
)
;
EXPECT_TRUE
(
rv
=
=
NS_OK
)
;
nsCOMPtr
<
imgITools
>
imgTools
=
do_CreateInstance
(
"
mozilla
.
org
/
image
/
tools
;
1
"
)
;
EXPECT_TRUE
(
imgTools
!
=
nullptr
)
;
gfxPlatform
:
:
GetPlatform
(
)
;
gfxPlatform
:
:
GetCMSMode
(
)
;
gfxPlatform
:
:
SetCMSModeOverride
(
eCMSMode_All
)
;
SpinPendingEvents
(
)
;
}
void
ImageBenchmarkBase
:
:
SetUp
(
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
mTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
mSourceBuffer
=
new
SourceBuffer
(
)
;
mSourceBuffer
-
>
ExpectLength
(
length
)
;
rv
=
mSourceBuffer
-
>
AppendFromInputStream
(
inputStream
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
mSourceBuffer
-
>
Complete
(
NS_OK
)
;
}
void
ImageBenchmarkBase
:
:
TearDown
(
)
{
}
#
define
ASSERT_TRUE_OR_RETURN
(
e
rv
)
\
EXPECT_TRUE
(
e
)
;
\
if
(
!
(
e
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_EQ_OR_RETURN
(
a
b
rv
)
\
EXPECT_EQ
(
a
b
)
;
\
if
(
(
a
)
!
=
(
b
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_GE_OR_RETURN
(
a
b
rv
)
\
EXPECT_GE
(
a
b
)
;
\
if
(
!
(
(
a
)
>
=
(
b
)
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_LE_OR_RETURN
(
a
b
rv
)
\
EXPECT_LE
(
a
b
)
;
\
if
(
!
(
(
a
)
<
=
(
b
)
)
)
{
\
return
rv
;
\
}
#
define
ASSERT_LT_OR_RETURN
(
a
b
rv
)
\
EXPECT_LT
(
a
b
)
;
\
if
(
!
(
(
a
)
<
(
b
)
)
)
{
\
return
rv
;
\
}
void
SpinPendingEvents
(
)
{
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
EXPECT_TRUE
(
mainThread
!
=
nullptr
)
;
bool
processed
;
do
{
processed
=
false
;
nsresult
rv
=
mainThread
-
>
ProcessNextEvent
(
false
&
processed
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
}
while
(
processed
)
;
}
already_AddRefed
<
nsIInputStream
>
LoadFile
(
const
char
*
aRelativePath
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProperties
>
dirService
=
do_GetService
(
NS_DIRECTORY_SERVICE_CONTRACTID
)
;
ASSERT_TRUE_OR_RETURN
(
dirService
!
=
nullptr
nullptr
)
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
dirService
-
>
Get
(
NS_OS_CURRENT_WORKING_DIR
NS_GET_IID
(
nsIFile
)
getter_AddRefs
(
file
)
)
;
ASSERT_TRUE_OR_RETURN
(
NS_SUCCEEDED
(
rv
)
nullptr
)
;
file
-
>
AppendNative
(
nsDependentCString
(
aRelativePath
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
rv
=
NS_NewLocalFileInputStream
(
getter_AddRefs
(
inputStream
)
file
)
;
ASSERT_TRUE_OR_RETURN
(
NS_SUCCEEDED
(
rv
)
nullptr
)
;
if
(
!
NS_InputStreamIsBuffered
(
inputStream
)
)
{
nsCOMPtr
<
nsIInputStream
>
bufStream
;
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufStream
)
inputStream
.
forget
(
)
1024
)
;
ASSERT_TRUE_OR_RETURN
(
NS_SUCCEEDED
(
rv
)
nullptr
)
;
inputStream
=
bufStream
;
}
return
inputStream
.
forget
(
)
;
}
bool
IsSolidColor
(
SourceSurface
*
aSurface
BGRAColor
aColor
uint8_t
aFuzz
)
{
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
return
RectIsSolidColor
(
aSurface
IntRect
(
0
0
size
.
width
size
.
height
)
aColor
aFuzz
)
;
}
bool
RowsAreSolidColor
(
SourceSurface
*
aSurface
int32_t
aStartRow
int32_t
aRowCount
BGRAColor
aColor
uint8_t
aFuzz
)
{
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
return
RectIsSolidColor
(
aSurface
IntRect
(
0
aStartRow
size
.
width
aRowCount
)
aColor
aFuzz
)
;
}
bool
RectIsSolidColor
(
SourceSurface
*
aSurface
const
IntRect
&
aRect
BGRAColor
aColor
uint8_t
aFuzz
)
{
IntSize
surfaceSize
=
aSurface
-
>
GetSize
(
)
;
IntRect
rect
=
aRect
.
Intersect
(
IntRect
(
0
0
surfaceSize
.
width
surfaceSize
.
height
)
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
aSurface
-
>
GetDataSurface
(
)
;
ASSERT_TRUE_OR_RETURN
(
dataSurface
!
=
nullptr
false
)
;
DataSourceSurface
:
:
ScopedMap
mapping
(
dataSurface
DataSourceSurface
:
:
MapType
:
:
READ
)
;
ASSERT_TRUE_OR_RETURN
(
mapping
.
IsMapped
(
)
false
)
;
ASSERT_EQ_OR_RETURN
(
mapping
.
GetStride
(
)
surfaceSize
.
width
*
4
false
)
;
uint8_t
*
data
=
mapping
.
GetData
(
)
;
ASSERT_TRUE_OR_RETURN
(
data
!
=
nullptr
false
)
;
BGRAColor
pmColor
=
aColor
.
Premultiply
(
)
;
uint32_t
expectedPixel
=
pmColor
.
AsPixel
(
)
;
int32_t
rowLength
=
mapping
.
GetStride
(
)
;
for
(
int32_t
row
=
rect
.
Y
(
)
;
row
<
rect
.
YMost
(
)
;
+
+
row
)
{
for
(
int32_t
col
=
rect
.
X
(
)
;
col
<
rect
.
XMost
(
)
;
+
+
col
)
{
int32_t
i
=
row
*
rowLength
+
col
*
4
;
uint32_t
gotPixel
=
*
reinterpret_cast
<
uint32_t
*
>
(
data
+
i
)
;
if
(
expectedPixel
!
=
gotPixel
)
{
BGRAColor
gotColor
=
BGRAColor
:
:
FromPixel
(
gotPixel
)
;
if
(
abs
(
pmColor
.
mBlue
-
gotColor
.
mBlue
)
>
aFuzz
|
|
abs
(
pmColor
.
mGreen
-
gotColor
.
mGreen
)
>
aFuzz
|
|
abs
(
pmColor
.
mRed
-
gotColor
.
mRed
)
>
aFuzz
|
|
abs
(
pmColor
.
mAlpha
-
gotColor
.
mAlpha
)
>
aFuzz
)
{
EXPECT_EQ
(
pmColor
.
mBlue
gotColor
.
mBlue
)
;
EXPECT_EQ
(
pmColor
.
mGreen
gotColor
.
mGreen
)
;
EXPECT_EQ
(
pmColor
.
mRed
gotColor
.
mRed
)
;
EXPECT_EQ
(
pmColor
.
mAlpha
gotColor
.
mAlpha
)
;
ASSERT_EQ_OR_RETURN
(
expectedPixel
gotPixel
false
)
;
}
}
}
}
return
true
;
}
bool
RowHasPixels
(
SourceSurface
*
aSurface
int32_t
aRow
const
vector
<
BGRAColor
>
&
aPixels
)
{
ASSERT_GE_OR_RETURN
(
aRow
0
false
)
;
IntSize
surfaceSize
=
aSurface
-
>
GetSize
(
)
;
ASSERT_EQ_OR_RETURN
(
aPixels
.
size
(
)
size_t
(
surfaceSize
.
width
)
false
)
;
ASSERT_LT_OR_RETURN
(
aRow
surfaceSize
.
height
false
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
aSurface
-
>
GetDataSurface
(
)
;
ASSERT_TRUE_OR_RETURN
(
dataSurface
false
)
;
DataSourceSurface
:
:
ScopedMap
mapping
(
dataSurface
DataSourceSurface
:
:
MapType
:
:
READ
)
;
ASSERT_TRUE_OR_RETURN
(
mapping
.
IsMapped
(
)
false
)
;
ASSERT_EQ_OR_RETURN
(
mapping
.
GetStride
(
)
surfaceSize
.
width
*
4
false
)
;
uint8_t
*
data
=
mapping
.
GetData
(
)
;
ASSERT_TRUE_OR_RETURN
(
data
!
=
nullptr
false
)
;
int32_t
rowLength
=
mapping
.
GetStride
(
)
;
for
(
int32_t
col
=
0
;
col
<
surfaceSize
.
width
;
+
+
col
)
{
int32_t
i
=
aRow
*
rowLength
+
col
*
4
;
uint32_t
gotPixelData
=
*
reinterpret_cast
<
uint32_t
*
>
(
data
+
i
)
;
BGRAColor
gotPixel
=
BGRAColor
:
:
FromPixel
(
gotPixelData
)
;
EXPECT_EQ
(
aPixels
[
col
]
.
mBlue
gotPixel
.
mBlue
)
;
EXPECT_EQ
(
aPixels
[
col
]
.
mGreen
gotPixel
.
mGreen
)
;
EXPECT_EQ
(
aPixels
[
col
]
.
mRed
gotPixel
.
mRed
)
;
EXPECT_EQ
(
aPixels
[
col
]
.
mAlpha
gotPixel
.
mAlpha
)
;
ASSERT_EQ_OR_RETURN
(
aPixels
[
col
]
.
AsPixel
(
)
gotPixelData
false
)
;
}
return
true
;
}
already_AddRefed
<
Decoder
>
CreateTrivialDecoder
(
)
{
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
"
image
/
gif
"
)
;
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
RefPtr
<
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
Nothing
(
)
DefaultDecoderFlags
(
)
DefaultSurfaceFlags
(
)
)
;
return
decoder
.
forget
(
)
;
}
void
AssertCorrectPipelineFinalState
(
SurfaceFilter
*
aFilter
const
gfx
:
:
IntRect
&
aInputSpaceRect
const
gfx
:
:
IntRect
&
aOutputSpaceRect
)
{
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isSome
(
)
)
;
EXPECT_EQ
(
aInputSpaceRect
invalidRect
-
>
mInputSpaceRect
)
;
EXPECT_EQ
(
aOutputSpaceRect
invalidRect
-
>
mOutputSpaceRect
)
;
}
void
CheckGeneratedImage
(
Decoder
*
aDecoder
const
IntRect
&
aRect
uint8_t
aFuzz
)
{
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
CheckGeneratedSurface
(
surface
aRect
BGRAColor
:
:
Green
(
)
BGRAColor
:
:
Transparent
(
)
aFuzz
)
;
}
void
CheckGeneratedSurface
(
SourceSurface
*
aSurface
const
IntRect
&
aRect
const
BGRAColor
&
aInnerColor
const
BGRAColor
&
aOuterColor
uint8_t
aFuzz
)
{
const
IntSize
surfaceSize
=
aSurface
-
>
GetSize
(
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
aRect
aInnerColor
aFuzz
)
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
0
0
surfaceSize
.
width
aRect
.
Y
(
)
)
aOuterColor
aFuzz
)
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
0
aRect
.
Y
(
)
aRect
.
X
(
)
aRect
.
YMost
(
)
)
aOuterColor
aFuzz
)
)
;
const
int32_t
widthOnRight
=
surfaceSize
.
width
-
aRect
.
XMost
(
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
aRect
.
XMost
(
)
aRect
.
Y
(
)
widthOnRight
aRect
.
YMost
(
)
)
aOuterColor
aFuzz
)
)
;
const
int32_t
heightBelow
=
surfaceSize
.
height
-
aRect
.
YMost
(
)
;
EXPECT_TRUE
(
RectIsSolidColor
(
aSurface
IntRect
(
0
aRect
.
YMost
(
)
surfaceSize
.
width
heightBelow
)
aOuterColor
aFuzz
)
)
;
}
void
CheckWritePixels
(
Decoder
*
aDecoder
SurfaceFilter
*
aFilter
const
Maybe
<
IntRect
>
&
aOutputRect
const
Maybe
<
IntRect
>
&
aInputRect
const
Maybe
<
IntRect
>
&
aInputWriteRect
const
Maybe
<
IntRect
>
&
aOutputWriteRect
uint8_t
aFuzz
)
{
CheckTransformedWritePixels
(
aDecoder
aFilter
BGRAColor
:
:
Green
(
)
BGRAColor
:
:
Green
(
)
aOutputRect
aInputRect
aInputWriteRect
aOutputWriteRect
aFuzz
)
;
}
void
CheckTransformedWritePixels
(
Decoder
*
aDecoder
SurfaceFilter
*
aFilter
const
BGRAColor
&
aInputColor
const
BGRAColor
&
aOutputColor
const
Maybe
<
IntRect
>
&
aOutputRect
const
Maybe
<
IntRect
>
&
aInputRect
const
Maybe
<
IntRect
>
&
aInputWriteRect
const
Maybe
<
IntRect
>
&
aOutputWriteRect
uint8_t
aFuzz
)
{
IntRect
outputRect
=
aOutputRect
.
valueOr
(
IntRect
(
0
0
100
100
)
)
;
IntRect
inputRect
=
aInputRect
.
valueOr
(
IntRect
(
0
0
100
100
)
)
;
IntRect
inputWriteRect
=
aInputWriteRect
.
valueOr
(
inputRect
)
;
IntRect
outputWriteRect
=
aOutputWriteRect
.
valueOr
(
outputRect
)
;
int32_t
count
=
0
;
auto
result
=
aFilter
-
>
WritePixels
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
aInputColor
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_EQ
(
inputWriteRect
.
Width
(
)
*
inputWriteRect
.
Height
(
)
count
)
;
AssertCorrectPipelineFinalState
(
aFilter
inputRect
outputRect
)
;
const
int32_t
oldCount
=
count
;
result
=
aFilter
-
>
WritePixels
<
uint32_t
>
(
[
&
]
{
+
+
count
;
return
AsVariant
(
aInputColor
.
AsPixel
(
)
)
;
}
)
;
EXPECT_EQ
(
oldCount
count
)
;
EXPECT_EQ
(
WriteState
:
:
FINISHED
result
)
;
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
aFilter
-
>
AdvanceRow
(
)
;
EXPECT_TRUE
(
aFilter
-
>
IsSurfaceFinished
(
)
)
;
invalidRect
=
aFilter
-
>
TakeInvalidRect
(
)
;
EXPECT_TRUE
(
invalidRect
.
isNothing
(
)
)
;
RawAccessFrameRef
currentFrame
=
aDecoder
-
>
GetCurrentFrameRef
(
)
;
RefPtr
<
SourceSurface
>
surface
=
currentFrame
-
>
GetSourceSurface
(
)
;
CheckGeneratedSurface
(
surface
outputWriteRect
aOutputColor
BGRAColor
:
:
Transparent
(
)
aFuzz
)
;
}
ImageTestCase
GreenPNGTestCase
(
)
{
return
ImageTestCase
(
"
green
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
GreenGIFTestCase
(
)
{
return
ImageTestCase
(
"
green
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenJPGTestCase
(
)
{
return
ImageTestCase
(
"
green
.
jpg
"
"
image
/
jpeg
"
IntSize
(
100
100
)
TEST_CASE_IS_FUZZY
|
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
GreenBMPTestCase
(
)
{
return
ImageTestCase
(
"
green
.
bmp
"
"
image
/
bmp
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenICOTestCase
(
)
{
return
ImageTestCase
(
"
green
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
GreenIconTestCase
(
)
{
return
ImageTestCase
(
"
green
.
icon
"
"
image
/
icon
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
GreenWebPTestCase
(
)
{
return
ImageTestCase
(
"
green
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
GreenAVIFTestCase
(
)
{
return
ImageTestCase
(
"
green
.
avif
"
"
image
/
avif
"
IntSize
(
100
100
)
)
.
WithSurfaceFlags
(
SurfaceFlags
:
:
TO_SRGB_COLORSPACE
)
;
}
ImageTestCase
StackCheckAVIFTestCase
(
)
{
return
ImageTestCase
(
"
stackcheck
.
avif
"
"
image
/
avif
"
IntSize
(
4096
2924
)
TEST_CASE_IGNORE_OUTPUT
)
.
WithSurfaceFlags
(
SurfaceFlags
:
:
TO_SRGB_COLORSPACE
)
;
}
ImageTestCase
LargeWebPTestCase
(
)
{
return
ImageTestCase
(
"
large
.
webp
"
"
image
/
webp
"
IntSize
(
1200
660
)
TEST_CASE_IGNORE_OUTPUT
)
;
}
ImageTestCase
LargeAVIFTestCase
(
)
{
return
ImageTestCase
(
"
large
.
avif
"
"
image
/
avif
"
IntSize
(
1200
660
)
TEST_CASE_IGNORE_OUTPUT
)
;
}
ImageTestCase
GreenWebPIccSrgbTestCase
(
)
{
return
ImageTestCase
(
"
green
.
icc_srgb
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
GreenFirstFrameAnimatedGIFTestCase
(
)
{
return
ImageTestCase
(
"
first
-
frame
-
green
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
GreenFirstFrameAnimatedPNGTestCase
(
)
{
return
ImageTestCase
(
"
first
-
frame
-
green
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IS_ANIMATED
|
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
GreenFirstFrameAnimatedWebPTestCase
(
)
{
return
ImageTestCase
(
"
first
-
frame
-
green
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_ANIMATED
|
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
BlendAnimatedGIFTestCase
(
)
{
return
ImageTestCase
(
"
blend
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
TEST_CASE_IS_ANIMATED
)
;
}
ImageTestCase
BlendAnimatedPNGTestCase
(
)
{
return
ImageTestCase
(
"
blend
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IS_ANIMATED
|
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
BlendAnimatedWebPTestCase
(
)
{
return
ImageTestCase
(
"
blend
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IS_ANIMATED
|
TEST_CASE_ASSUME_SRGB_OUTPUT
)
;
}
ImageTestCase
CorruptTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
.
jpg
"
"
image
/
jpeg
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptBMPWithTruncatedHeader
(
)
{
return
ImageTestCase
(
"
invalid
-
truncated
-
metadata
.
bmp
"
"
image
/
bmp
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptICOWithBadBMPWidthTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
-
with
-
bad
-
bmp
-
width
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptICOWithBadBMPHeightTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
-
with
-
bad
-
bmp
-
height
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_HAS_ERROR
)
;
}
ImageTestCase
CorruptICOWithBadBppTestCase
(
)
{
return
ImageTestCase
(
"
corrupt
-
with
-
bad
-
ico
-
bpp
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentPNGTestCase
(
)
{
return
ImageTestCase
(
"
transparent
.
png
"
"
image
/
png
"
IntSize
(
32
32
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentGIFTestCase
(
)
{
return
ImageTestCase
(
"
transparent
.
gif
"
"
image
/
gif
"
IntSize
(
16
16
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentWebPTestCase
(
)
{
ImageTestCase
test
(
"
transparent
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_TRANSPARENT
)
;
test
.
mColor
=
BGRAColor
:
:
Transparent
(
)
;
return
test
;
}
ImageTestCase
TransparentNoAlphaHeaderWebPTestCase
(
)
{
ImageTestCase
test
(
"
transparent
-
no
-
alpha
-
header
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
TEST_CASE_IS_FUZZY
)
;
test
.
mColor
=
BGRAColor
(
0x00
0x00
0x00
0xFF
)
;
return
test
;
}
ImageTestCase
FirstFramePaddingGIFTestCase
(
)
{
return
ImageTestCase
(
"
transparent
.
gif
"
"
image
/
gif
"
IntSize
(
16
16
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
TransparentIfWithinICOBMPTestCase
(
TestCaseFlags
aFlags
)
{
return
ImageTestCase
(
"
transparent
-
if
-
within
-
ico
.
bmp
"
"
image
/
bmp
"
IntSize
(
32
32
)
aFlags
)
;
}
ImageTestCase
RLE4BMPTestCase
(
)
{
return
ImageTestCase
(
"
rle4
.
bmp
"
"
image
/
bmp
"
IntSize
(
320
240
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
RLE8BMPTestCase
(
)
{
return
ImageTestCase
(
"
rle8
.
bmp
"
"
image
/
bmp
"
IntSize
(
32
32
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
NoFrameDelayGIFTestCase
(
)
{
return
ImageTestCase
(
"
no
-
frame
-
delay
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
ExtraImageSubBlocksAnimatedGIFTestCase
(
)
{
return
ImageTestCase
(
"
animated
-
with
-
extra
-
image
-
sub
-
blocks
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
)
;
}
ImageTestCase
DownscaledPNGTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
png
"
"
image
/
png
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledGIFTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
gif
"
"
image
/
gif
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledJPGTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
jpg
"
"
image
/
jpeg
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledBMPTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
bmp
"
"
image
/
bmp
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledICOTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
100
100
)
IntSize
(
20
20
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
DownscaledIconTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
icon
"
"
image
/
icon
"
IntSize
(
100
100
)
IntSize
(
20
20
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
DownscaledWebPTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
webp
"
"
image
/
webp
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledAVIFTestCase
(
)
{
return
ImageTestCase
(
"
downscaled
.
avif
"
"
image
/
avif
"
IntSize
(
100
100
)
IntSize
(
20
20
)
)
;
}
ImageTestCase
DownscaledTransparentICOWithANDMaskTestCase
(
)
{
return
ImageTestCase
(
"
transparent
-
ico
-
with
-
and
-
mask
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
32
32
)
IntSize
(
20
20
)
TEST_CASE_IS_TRANSPARENT
|
TEST_CASE_IGNORE_OUTPUT
)
;
}
ImageTestCase
TruncatedSmallGIFTestCase
(
)
{
return
ImageTestCase
(
"
green
-
1x1
-
truncated
.
gif
"
"
image
/
gif
"
IntSize
(
1
1
)
)
;
}
ImageTestCase
LargeICOWithBMPTestCase
(
)
{
return
ImageTestCase
(
"
green
-
large
-
bmp
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
256
256
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
LargeICOWithPNGTestCase
(
)
{
return
ImageTestCase
(
"
green
-
large
-
png
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
512
512
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
GreenMultipleSizesICOTestCase
(
)
{
return
ImageTestCase
(
"
green
-
multiple
-
sizes
.
ico
"
"
image
/
x
-
icon
"
IntSize
(
256
256
)
)
.
WithSurfaceFlags
(
SurfaceFlags
:
:
TO_SRGB_COLORSPACE
)
;
}
ImageTestCase
PerfGrayJPGTestCase
(
)
{
return
ImageTestCase
(
"
perf_gray
.
jpg
"
"
image
/
jpeg
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfCmykJPGTestCase
(
)
{
return
ImageTestCase
(
"
perf_cmyk
.
jpg
"
"
image
/
jpeg
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfYCbCrJPGTestCase
(
)
{
return
ImageTestCase
(
"
perf_ycbcr
.
jpg
"
"
image
/
jpeg
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfRgbPNGTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb
.
png
"
"
image
/
png
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfRgbAlphaPNGTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb_alpha
.
png
"
"
image
/
png
"
IntSize
(
1000
1000
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
PerfGrayPNGTestCase
(
)
{
return
ImageTestCase
(
"
perf_gray
.
png
"
"
image
/
png
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfGrayAlphaPNGTestCase
(
)
{
return
ImageTestCase
(
"
perf_gray_alpha
.
png
"
"
image
/
png
"
IntSize
(
1000
1000
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
PerfRgbLosslessWebPTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb_lossless
.
webp
"
"
image
/
webp
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfRgbAlphaLosslessWebPTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb_alpha_lossless
.
webp
"
"
image
/
webp
"
IntSize
(
1000
1000
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
PerfRgbLossyWebPTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb_lossy
.
webp
"
"
image
/
webp
"
IntSize
(
1000
1000
)
)
;
}
ImageTestCase
PerfRgbAlphaLossyWebPTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb_alpha_lossy
.
webp
"
"
image
/
webp
"
IntSize
(
1000
1000
)
TEST_CASE_IS_TRANSPARENT
)
;
}
ImageTestCase
PerfRgbGIFTestCase
(
)
{
return
ImageTestCase
(
"
perf_srgb
.
gif
"
"
image
/
gif
"
IntSize
(
1000
1000
)
)
;
}
}
}
