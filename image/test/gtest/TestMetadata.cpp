#
include
"
gtest
/
gtest
.
h
"
#
include
"
Common
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
DecoderFactory
.
h
"
#
include
"
decoders
/
nsBMPDecoder
.
h
"
#
include
"
IDecodingTask
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgITools
.
h
"
#
include
"
ImageFactory
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ProgressTracker
.
h
"
#
include
"
SourceBuffer
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
enum
class
BMPWithinICO
{
NO
YES
}
;
static
void
CheckMetadata
(
const
ImageTestCase
&
aTestCase
BMPWithinICO
aBMPWithinICO
=
BMPWithinICO
:
:
NO
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
aTestCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
auto
sourceBuffer
=
MakeNotNull
<
RefPtr
<
SourceBuffer
>
>
(
)
;
sourceBuffer
-
>
ExpectLength
(
length
)
;
rv
=
sourceBuffer
-
>
AppendFromInputStream
(
inputStream
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
sourceBuffer
-
>
Complete
(
NS_OK
)
;
DecoderType
decoderType
=
DecoderFactory
:
:
GetDecoderType
(
aTestCase
.
mMimeType
)
;
RefPtr
<
Decoder
>
decoder
=
DecoderFactory
:
:
CreateAnonymousMetadataDecoder
(
decoderType
sourceBuffer
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
RefPtr
<
IDecodingTask
>
task
=
new
AnonymousDecodingTask
(
WrapNotNull
(
decoder
)
)
;
if
(
aBMPWithinICO
=
=
BMPWithinICO
:
:
YES
)
{
static_cast
<
nsBMPDecoder
*
>
(
decoder
.
get
(
)
)
-
>
SetIsWithinICO
(
)
;
}
task
-
>
Run
(
)
;
Progress
metadataProgress
=
decoder
-
>
TakeProgress
(
)
;
EXPECT_TRUE
(
0
=
=
(
metadataProgress
&
~
(
FLAG_SIZE_AVAILABLE
|
FLAG_HAS_TRANSPARENCY
|
FLAG_IS_ANIMATED
)
)
)
;
if
(
aTestCase
.
mFlags
&
TEST_CASE_HAS_ERROR
)
{
EXPECT_TRUE
(
decoder
-
>
GetDecodeDone
(
)
)
;
EXPECT_TRUE
(
decoder
-
>
HasError
(
)
)
;
return
;
}
EXPECT_TRUE
(
decoder
-
>
GetDecodeDone
(
)
&
&
!
decoder
-
>
HasError
(
)
)
;
EXPECT_TRUE
(
metadataProgress
&
FLAG_SIZE_AVAILABLE
)
;
IntSize
metadataSize
=
decoder
-
>
Size
(
)
;
EXPECT_EQ
(
aTestCase
.
mSize
.
width
metadataSize
.
width
)
;
if
(
aBMPWithinICO
=
=
BMPWithinICO
:
:
YES
)
{
EXPECT_EQ
(
aTestCase
.
mSize
.
height
/
2
metadataSize
.
height
)
;
}
else
{
EXPECT_EQ
(
aTestCase
.
mSize
.
height
metadataSize
.
height
)
;
}
bool
expectTransparency
=
aBMPWithinICO
=
=
BMPWithinICO
:
:
YES
?
true
:
bool
(
aTestCase
.
mFlags
&
TEST_CASE_IS_TRANSPARENT
)
;
EXPECT_EQ
(
expectTransparency
bool
(
metadataProgress
&
FLAG_HAS_TRANSPARENCY
)
)
;
EXPECT_EQ
(
bool
(
aTestCase
.
mFlags
&
TEST_CASE_IS_ANIMATED
)
bool
(
metadataProgress
&
FLAG_IS_ANIMATED
)
)
;
decoder
=
DecoderFactory
:
:
CreateAnonymousDecoder
(
decoderType
sourceBuffer
Nothing
(
)
DefaultSurfaceFlags
(
)
)
;
ASSERT_TRUE
(
decoder
!
=
nullptr
)
;
task
=
new
AnonymousDecodingTask
(
WrapNotNull
(
decoder
)
)
;
if
(
aBMPWithinICO
=
=
BMPWithinICO
:
:
YES
)
{
static_cast
<
nsBMPDecoder
*
>
(
decoder
.
get
(
)
)
-
>
SetIsWithinICO
(
)
;
}
task
-
>
Run
(
)
;
EXPECT_TRUE
(
decoder
-
>
GetDecodeDone
(
)
&
&
!
decoder
-
>
HasError
(
)
)
;
Progress
fullProgress
=
decoder
-
>
TakeProgress
(
)
;
EXPECT_EQ
(
fullProgress
metadataProgress
|
fullProgress
)
;
IntSize
fullSize
=
decoder
-
>
Size
(
)
;
EXPECT_EQ
(
metadataSize
.
width
fullSize
.
width
)
;
EXPECT_EQ
(
metadataSize
.
height
fullSize
.
height
)
;
EXPECT_TRUE
(
!
(
fullProgress
&
FLAG_HAS_TRANSPARENCY
)
|
|
(
metadataProgress
&
FLAG_HAS_TRANSPARENCY
)
|
|
(
fullProgress
&
FLAG_IS_ANIMATED
)
)
;
}
class
ImageDecoderMetadata
:
public
:
:
testing
:
:
Test
{
protected
:
AutoInitializeImageLib
mInit
;
}
;
TEST_F
(
ImageDecoderMetadata
PNG
)
{
CheckMetadata
(
GreenPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
TransparentPNG
)
{
CheckMetadata
(
TransparentPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
GIF
)
{
CheckMetadata
(
GreenGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
TransparentGIF
)
{
CheckMetadata
(
TransparentGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
JPG
)
{
CheckMetadata
(
GreenJPGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
BMP
)
{
CheckMetadata
(
GreenBMPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
ICO
)
{
CheckMetadata
(
GreenICOTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
Icon
)
{
CheckMetadata
(
GreenIconTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
AnimatedGIF
)
{
CheckMetadata
(
GreenFirstFrameAnimatedGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
AnimatedPNG
)
{
CheckMetadata
(
GreenFirstFrameAnimatedPNGTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
FirstFramePaddingGIF
)
{
CheckMetadata
(
FirstFramePaddingGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
TransparentIfWithinICOBMPNotWithinICO
)
{
CheckMetadata
(
TransparentIfWithinICOBMPTestCase
(
TEST_CASE_DEFAULT_FLAGS
)
BMPWithinICO
:
:
NO
)
;
}
TEST_F
(
ImageDecoderMetadata
TransparentIfWithinICOBMPWithinICO
)
{
CheckMetadata
(
TransparentIfWithinICOBMPTestCase
(
TEST_CASE_IS_TRANSPARENT
)
BMPWithinICO
:
:
YES
)
;
}
TEST_F
(
ImageDecoderMetadata
RLE4BMP
)
{
CheckMetadata
(
RLE4BMPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
RLE8BMP
)
{
CheckMetadata
(
RLE8BMPTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
Corrupt
)
{
CheckMetadata
(
CorruptTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
NoFrameDelayGIF
)
{
CheckMetadata
(
NoFrameDelayGIFTestCase
(
)
)
;
}
TEST_F
(
ImageDecoderMetadata
NoFrameDelayGIFFullDecode
)
{
ImageTestCase
testCase
=
NoFrameDelayGIFTestCase
(
)
;
RefPtr
<
Image
>
image
=
ImageFactory
:
:
CreateAnonymousImage
(
nsDependentCString
(
testCase
.
mMimeType
)
)
;
ASSERT_TRUE
(
!
image
-
>
HasError
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
=
LoadFile
(
testCase
.
mPath
)
;
ASSERT_TRUE
(
inputStream
!
=
nullptr
)
;
uint64_t
length
;
nsresult
rv
=
inputStream
-
>
Available
(
&
length
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataAvailable
(
nullptr
nullptr
inputStream
0
static_cast
<
uint32_t
>
(
length
)
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
OnImageDataComplete
(
nullptr
nullptr
NS_OK
true
)
;
ASSERT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
RefPtr
<
ProgressTracker
>
tracker
=
image
-
>
GetProgressTracker
(
)
;
tracker
-
>
SyncNotifyProgress
(
FLAG_LOAD_COMPLETE
)
;
RefPtr
<
SourceSurface
>
surface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
IntSize
imageSize
(
0
0
)
;
rv
=
image
-
>
GetWidth
(
&
imageSize
.
width
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
image
-
>
GetHeight
(
&
imageSize
.
height
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
rv
)
)
;
EXPECT_EQ
(
testCase
.
mSize
.
width
imageSize
.
width
)
;
EXPECT_EQ
(
testCase
.
mSize
.
height
imageSize
.
height
)
;
Progress
imageProgress
=
tracker
-
>
GetProgress
(
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_HAS_TRANSPARENCY
)
=
=
false
)
;
EXPECT_TRUE
(
bool
(
imageProgress
&
FLAG_IS_ANIMATED
)
=
=
true
)
;
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
image
.
get
(
)
)
RasterSurfaceKey
(
imageSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
ASSERT_EQ
(
MatchType
:
:
EXACT
result
.
Type
(
)
)
;
EXPECT_TRUE
(
NS_SUCCEEDED
(
result
.
Surface
(
)
.
Seek
(
0
)
)
)
;
EXPECT_TRUE
(
bool
(
result
.
Surface
(
)
)
)
;
RawAccessFrameRef
partialFrame
=
result
.
Surface
(
)
.
RawAccessRef
(
1
)
;
EXPECT_TRUE
(
bool
(
partialFrame
)
)
;
}
