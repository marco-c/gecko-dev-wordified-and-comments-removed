#
ifndef
mozilla_image_LookupResult_h
#
define
mozilla_image_LookupResult_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
ISurfaceProvider
.
h
"
namespace
mozilla
{
namespace
image
{
enum
class
MatchType
:
uint8_t
{
NOT_FOUND
PENDING
EXACT
SUBSTITUTE_BECAUSE_NOT_FOUND
SUBSTITUTE_BECAUSE_PENDING
}
;
class
MOZ_STACK_CLASS
LookupResult
{
public
:
explicit
LookupResult
(
MatchType
aMatchType
)
:
mMatchType
(
aMatchType
)
{
MOZ_ASSERT
(
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
"
Only
NOT_FOUND
or
PENDING
make
sense
with
no
surface
"
)
;
}
LookupResult
(
LookupResult
&
&
aOther
)
:
mProvider
(
Move
(
aOther
.
mProvider
)
)
mMatchType
(
aOther
.
mMatchType
)
{
}
LookupResult
(
RefPtr
<
ISurfaceProvider
>
&
&
aProvider
MatchType
aMatchType
)
:
mProvider
(
Move
(
aProvider
)
)
mMatchType
(
aMatchType
)
{
MOZ_ASSERT
(
!
mProvider
|
|
!
(
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
)
"
Only
NOT_FOUND
or
PENDING
make
sense
with
no
surface
"
)
;
MOZ_ASSERT
(
mProvider
|
|
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
"
NOT_FOUND
or
PENDING
do
not
make
sense
with
a
surface
"
)
;
}
LookupResult
&
operator
=
(
LookupResult
&
&
aOther
)
{
MOZ_ASSERT
(
&
aOther
!
=
this
"
Self
-
move
-
assignment
is
not
supported
"
)
;
mProvider
=
Move
(
aOther
.
mProvider
)
;
mMatchType
=
aOther
.
mMatchType
;
return
*
this
;
}
ISurfaceProvider
*
Provider
(
)
{
return
mProvider
.
get
(
)
;
}
const
ISurfaceProvider
*
Provider
(
)
const
{
return
mProvider
.
get
(
)
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mProvider
)
;
}
MatchType
Type
(
)
const
{
return
mMatchType
;
}
private
:
LookupResult
(
const
LookupResult
&
)
=
delete
;
RefPtr
<
ISurfaceProvider
>
mProvider
;
MatchType
mMatchType
;
}
;
}
}
#
endif
