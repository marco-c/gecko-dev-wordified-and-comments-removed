#
ifndef
mozilla_image_LookupResult_h
#
define
mozilla_image_LookupResult_h
#
include
<
utility
>
#
include
"
ISurfaceProvider
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
namespace
mozilla
{
namespace
image
{
enum
class
MatchType
:
uint8_t
{
NOT_FOUND
PENDING
EXACT
SUBSTITUTE_BECAUSE_NOT_FOUND
SUBSTITUTE_BECAUSE_PENDING
SUBSTITUTE_BECAUSE_BEST
}
;
class
MOZ_STACK_CLASS
LookupResult
{
public
:
explicit
LookupResult
(
MatchType
aMatchType
)
:
mMatchType
(
aMatchType
)
{
MOZ_ASSERT
(
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
"
Only
NOT_FOUND
or
PENDING
make
sense
with
no
surface
"
)
;
}
LookupResult
(
LookupResult
&
&
aOther
)
:
mSurface
(
std
:
:
move
(
aOther
.
mSurface
)
)
mMatchType
(
aOther
.
mMatchType
)
mSuggestedSize
(
aOther
.
mSuggestedSize
)
{
}
LookupResult
(
DrawableSurface
&
&
aSurface
MatchType
aMatchType
)
:
mSurface
(
std
:
:
move
(
aSurface
)
)
mMatchType
(
aMatchType
)
{
MOZ_ASSERT
(
!
mSurface
|
|
!
(
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
)
"
Only
NOT_FOUND
or
PENDING
make
sense
with
no
surface
"
)
;
MOZ_ASSERT
(
mSurface
|
|
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
"
NOT_FOUND
or
PENDING
do
not
make
sense
with
a
surface
"
)
;
}
LookupResult
(
MatchType
aMatchType
const
gfx
:
:
IntSize
&
aSuggestedSize
)
:
mMatchType
(
aMatchType
)
mSuggestedSize
(
aSuggestedSize
)
{
MOZ_ASSERT
(
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
"
Only
NOT_FOUND
or
PENDING
make
sense
with
no
surface
"
)
;
}
LookupResult
(
DrawableSurface
&
&
aSurface
MatchType
aMatchType
const
gfx
:
:
IntSize
&
aSuggestedSize
)
:
mSurface
(
std
:
:
move
(
aSurface
)
)
mMatchType
(
aMatchType
)
mSuggestedSize
(
aSuggestedSize
)
{
MOZ_ASSERT
(
!
mSurface
|
|
!
(
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
)
"
Only
NOT_FOUND
or
PENDING
make
sense
with
no
surface
"
)
;
MOZ_ASSERT
(
mSurface
|
|
mMatchType
=
=
MatchType
:
:
NOT_FOUND
|
|
mMatchType
=
=
MatchType
:
:
PENDING
"
NOT_FOUND
or
PENDING
do
not
make
sense
with
a
surface
"
)
;
}
LookupResult
&
operator
=
(
LookupResult
&
&
aOther
)
{
MOZ_ASSERT
(
&
aOther
!
=
this
"
Self
-
move
-
assignment
is
not
supported
"
)
;
mSurface
=
std
:
:
move
(
aOther
.
mSurface
)
;
mMatchType
=
aOther
.
mMatchType
;
mSuggestedSize
=
aOther
.
mSuggestedSize
;
return
*
this
;
}
DrawableSurface
&
Surface
(
)
{
return
mSurface
;
}
const
DrawableSurface
&
Surface
(
)
const
{
return
mSurface
;
}
const
gfx
:
:
IntSize
&
SuggestedSize
(
)
const
{
return
mSuggestedSize
;
}
explicit
operator
bool
(
)
const
{
return
bool
(
mSurface
)
;
}
MatchType
Type
(
)
const
{
return
mMatchType
;
}
private
:
LookupResult
(
const
LookupResult
&
)
=
delete
;
LookupResult
&
operator
=
(
const
LookupResult
&
aOther
)
=
delete
;
DrawableSurface
mSurface
;
MatchType
mMatchType
;
gfx
:
:
IntSize
mSuggestedSize
;
}
;
}
}
#
endif
