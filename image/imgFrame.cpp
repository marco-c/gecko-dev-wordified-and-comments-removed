#
include
"
imgFrame
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
SurfaceCache
.
h
"
#
include
"
prenv
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
gfx
;
namespace
image
{
class
RecyclingSourceSurfaceSharedData
final
:
public
SourceSurfaceSharedData
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
RecyclingSourceSurfaceSharedData
override
)
SurfaceType
GetType
(
)
const
override
{
return
SurfaceType
:
:
DATA_RECYCLING_SHARED
;
}
}
;
static
already_AddRefed
<
SourceSurfaceSharedData
>
AllocateBufferForImage
(
const
IntSize
&
size
SurfaceFormat
format
bool
aShouldRecycle
=
false
)
{
int32_t
stride
=
(
size
.
width
*
BytesPerPixel
(
format
)
+
0x3
)
&
~
0x3
;
RefPtr
<
SourceSurfaceSharedData
>
newSurf
;
if
(
aShouldRecycle
)
{
newSurf
=
new
RecyclingSourceSurfaceSharedData
(
)
;
}
else
{
newSurf
=
new
SourceSurfaceSharedData
(
)
;
}
if
(
!
newSurf
-
>
Init
(
size
stride
format
)
)
{
return
nullptr
;
}
return
newSurf
.
forget
(
)
;
}
static
bool
GreenSurface
(
SourceSurfaceSharedData
*
aSurface
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
int32_t
stride
=
aSurface
-
>
Stride
(
)
;
uint32_t
*
surfaceData
=
reinterpret_cast
<
uint32_t
*
>
(
aSurface
-
>
GetData
(
)
)
;
uint32_t
surfaceDataLength
=
(
stride
*
aSize
.
height
)
/
sizeof
(
uint32_t
)
;
uint32_t
color
=
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
0x00FF00FF
)
;
MOZ_ASSERT
(
surfaceData
)
;
MOZ_ASSERT
(
aFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
aFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
|
|
aFormat
=
=
SurfaceFormat
:
:
R8G8B8A8
|
|
aFormat
=
=
SurfaceFormat
:
:
R8G8B8X8
|
|
aFormat
=
=
SurfaceFormat
:
:
A8R8G8B8
|
|
aFormat
=
=
SurfaceFormat
:
:
X8R8G8B8
)
;
MOZ_ASSERT
(
(
stride
*
aSize
.
height
)
%
sizeof
(
uint32_t
)
)
;
if
(
aFormat
=
=
SurfaceFormat
:
:
A8R8G8B8
|
|
aFormat
=
=
SurfaceFormat
:
:
X8R8G8B8
)
{
color
=
mozilla
:
:
NativeEndian
:
:
swapFromBigEndian
(
0xFF00FF00
)
;
}
for
(
uint32_t
i
=
0
;
i
<
surfaceDataLength
;
i
+
+
)
{
surfaceData
[
i
]
=
color
;
}
return
true
;
}
static
bool
ClearSurface
(
SourceSurfaceSharedData
*
aSurface
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
int32_t
stride
=
aSurface
-
>
Stride
(
)
;
uint8_t
*
data
=
aSurface
-
>
GetData
(
)
;
MOZ_ASSERT
(
data
)
;
if
(
aFormat
=
=
SurfaceFormat
:
:
OS_RGBX
)
{
memset
(
data
0xFF
stride
*
aSize
.
height
)
;
}
else
if
(
aSurface
-
>
OnHeap
(
)
)
{
memset
(
data
0
stride
*
aSize
.
height
)
;
}
return
true
;
}
imgFrame
:
:
imgFrame
(
)
:
mMonitor
(
"
imgFrame
"
)
mDecoded
(
0
0
0
0
)
mAborted
(
false
)
mFinished
(
false
)
mShouldRecycle
(
false
)
mTimeout
(
FrameTimeout
:
:
FromRawMilliseconds
(
100
)
)
mDisposalMethod
(
DisposalMethod
:
:
NOT_SPECIFIED
)
mBlendMethod
(
BlendMethod
:
:
OVER
)
mFormat
(
SurfaceFormat
:
:
UNKNOWN
)
mNonPremult
(
false
)
{
}
imgFrame
:
:
~
imgFrame
(
)
{
#
ifdef
DEBUG
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mAborted
|
|
AreAllPixelsWritten
(
)
)
;
MOZ_ASSERT
(
mAborted
|
|
mFinished
)
;
#
endif
}
nsresult
imgFrame
:
:
InitForDecoder
(
const
nsIntSize
&
aImageSize
SurfaceFormat
aFormat
bool
aNonPremult
const
Maybe
<
AnimationParams
>
&
aAnimParams
bool
aShouldRecycle
uint32_t
*
aImageDataLength
)
{
if
(
!
SurfaceCache
:
:
IsLegalSize
(
aImageSize
)
)
{
NS_WARNING
(
"
Should
have
legal
image
size
"
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mAborted
=
true
;
return
NS_ERROR_FAILURE
;
}
mImageSize
=
aImageSize
;
mDirtyRect
=
GetRect
(
)
;
if
(
aAnimParams
)
{
mBlendRect
=
aAnimParams
-
>
mBlendRect
;
mTimeout
=
aAnimParams
-
>
mTimeout
;
mBlendMethod
=
aAnimParams
-
>
mBlendMethod
;
mDisposalMethod
=
aAnimParams
-
>
mDisposalMethod
;
}
else
{
mBlendRect
=
GetRect
(
)
;
}
if
(
aShouldRecycle
)
{
MOZ_ASSERT
(
aAnimParams
)
;
mFormat
=
SurfaceFormat
:
:
OS_RGBA
;
}
else
{
mFormat
=
aFormat
;
}
mNonPremult
=
aNonPremult
;
MonitorAutoLock
lock
(
mMonitor
)
;
mShouldRecycle
=
aShouldRecycle
;
MOZ_ASSERT
(
!
mRawSurface
"
Called
imgFrame
:
:
InitForDecoder
(
)
twice
?
"
)
;
mRawSurface
=
AllocateBufferForImage
(
mImageSize
mFormat
mShouldRecycle
)
;
if
(
!
mRawSurface
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
StaticPrefs
:
:
browser_measurement_render_anims_and_video_solid
(
)
&
&
aAnimParams
)
{
mBlankRawSurface
=
AllocateBufferForImage
(
mImageSize
mFormat
)
;
if
(
!
mBlankRawSurface
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
if
(
!
ClearSurface
(
mRawSurface
mImageSize
mFormat
)
)
{
NS_WARNING
(
"
Could
not
clear
allocated
buffer
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mBlankRawSurface
)
{
if
(
!
GreenSurface
(
mBlankRawSurface
mImageSize
mFormat
)
)
{
NS_WARNING
(
"
Could
not
clear
allocated
blank
buffer
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
if
(
aImageDataLength
)
{
*
aImageDataLength
=
GetImageDataLength
(
)
;
}
return
NS_OK
;
}
nsresult
imgFrame
:
:
InitForDecoderRecycle
(
const
AnimationParams
&
aAnimParams
uint32_t
*
aImageDataLength
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mRawSurface
)
;
if
(
!
mShouldRecycle
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MozRefCountType
internalRefs
=
1
;
if
(
mOptSurface
=
=
mRawSurface
)
{
+
+
internalRefs
;
}
if
(
mRawSurface
-
>
refCount
(
)
>
internalRefs
)
{
if
(
NS_IsMainThread
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Recycling
/
decoding
on
the
main
thread
?
"
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
int32_t
refreshInterval
=
std
:
:
clamp
(
nsRefreshDriver
:
:
DefaultInterval
(
)
4
20
)
;
TimeDuration
waitInterval
=
TimeDuration
:
:
FromMilliseconds
(
refreshInterval
>
>
2
)
;
TimeStamp
timeout
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromMilliseconds
(
refreshInterval
)
;
while
(
true
)
{
mMonitor
.
Wait
(
waitInterval
)
;
if
(
mRawSurface
-
>
refCount
(
)
<
=
internalRefs
)
{
break
;
}
if
(
timeout
<
=
TimeStamp
:
:
Now
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
}
mBlendRect
=
aAnimParams
.
mBlendRect
;
mTimeout
=
aAnimParams
.
mTimeout
;
mBlendMethod
=
aAnimParams
.
mBlendMethod
;
mDisposalMethod
=
aAnimParams
.
mDisposalMethod
;
mDirtyRect
=
GetRect
(
)
;
if
(
aImageDataLength
)
{
*
aImageDataLength
=
GetImageDataLength
(
)
;
}
return
NS_OK
;
}
nsresult
imgFrame
:
:
InitWithDrawable
(
gfxDrawable
*
aDrawable
const
nsIntSize
&
aSize
const
SurfaceFormat
aFormat
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
gfx
:
:
BackendType
aBackend
)
{
if
(
!
SurfaceCache
:
:
IsLegalSize
(
aSize
)
)
{
NS_WARNING
(
"
Should
have
legal
image
size
"
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mAborted
=
true
;
return
NS_ERROR_FAILURE
;
}
mImageSize
=
aSize
;
mFormat
=
aFormat
;
RefPtr
<
DrawTarget
>
target
;
bool
canUseDataSurface
=
Factory
:
:
DoesBackendSupportDataDrawtarget
(
aBackend
)
;
if
(
canUseDataSurface
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
!
mRawSurface
"
Called
imgFrame
:
:
InitWithDrawable
(
)
twice
?
"
)
;
mRawSurface
=
AllocateBufferForImage
(
mImageSize
mFormat
)
;
if
(
!
mRawSurface
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
ClearSurface
(
mRawSurface
mImageSize
mFormat
)
)
{
NS_WARNING
(
"
Could
not
clear
allocated
buffer
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
target
=
gfxPlatform
:
:
CreateDrawTargetForData
(
mRawSurface
-
>
GetData
(
)
mImageSize
mRawSurface
-
>
Stride
(
)
mFormat
)
;
}
else
{
#
ifdef
DEBUG
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
!
mOptSurface
"
Called
imgFrame
:
:
InitWithDrawable
(
)
twice
?
"
)
;
}
#
endif
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
SupportsAzureContentForType
(
aBackend
)
)
{
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForBackend
(
aBackend
mImageSize
mFormat
)
;
}
else
{
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
mImageSize
mFormat
)
;
}
}
if
(
!
target
|
|
!
target
-
>
IsValid
(
)
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
gfxContext
ctx
(
target
)
;
gfxUtils
:
:
DrawPixelSnapped
(
&
ctx
aDrawable
SizeDouble
(
mImageSize
)
ImageRegion
:
:
Create
(
ThebesRect
(
GetRect
(
)
)
)
mFormat
aSamplingFilter
aImageFlags
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
canUseDataSurface
&
&
!
mRawSurface
)
{
NS_WARNING
(
"
Failed
to
create
SourceSurfaceSharedData
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
canUseDataSurface
)
{
mOptSurface
=
target
-
>
Snapshot
(
)
;
}
else
{
FinalizeSurfaceInternal
(
)
;
}
mDecoded
=
GetRect
(
)
;
mFinished
=
true
;
MOZ_ASSERT
(
AreAllPixelsWritten
(
)
)
;
return
NS_OK
;
}
DrawableFrameRef
imgFrame
:
:
DrawableRef
(
)
{
return
DrawableFrameRef
(
this
)
;
}
RawAccessFrameRef
imgFrame
:
:
RawAccessRef
(
gfx
:
:
DataSourceSurface
:
:
MapType
aMapType
)
{
return
RawAccessFrameRef
(
this
aMapType
)
;
}
imgFrame
:
:
SurfaceWithFormat
imgFrame
:
:
SurfaceForDrawing
(
bool
aDoPartialDecode
bool
aDoTile
ImageRegion
&
aRegion
SourceSurface
*
aSurface
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
!
aDoPartialDecode
)
{
return
SurfaceWithFormat
(
new
gfxSurfaceDrawable
(
aSurface
mImageSize
)
mFormat
)
;
}
gfxRect
available
=
gfxRect
(
mDecoded
.
X
(
)
mDecoded
.
Y
(
)
mDecoded
.
Width
(
)
mDecoded
.
Height
(
)
)
;
if
(
aDoTile
)
{
RefPtr
<
DrawTarget
>
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
mImageSize
SurfaceFormat
:
:
OS_RGBA
)
;
if
(
!
target
)
{
return
SurfaceWithFormat
(
)
;
}
SurfacePattern
pattern
(
aSurface
aRegion
.
GetExtendMode
(
)
Matrix
:
:
Translation
(
mDecoded
.
X
(
)
mDecoded
.
Y
(
)
)
)
;
target
-
>
FillRect
(
ToRect
(
aRegion
.
Intersect
(
available
)
.
Rect
(
)
)
pattern
)
;
RefPtr
<
SourceSurface
>
newsurf
=
target
-
>
Snapshot
(
)
;
return
SurfaceWithFormat
(
new
gfxSurfaceDrawable
(
newsurf
mImageSize
)
target
-
>
GetFormat
(
)
)
;
}
aRegion
=
aRegion
.
Intersect
(
available
)
;
IntSize
availableSize
(
mDecoded
.
Width
(
)
mDecoded
.
Height
(
)
)
;
return
SurfaceWithFormat
(
new
gfxSurfaceDrawable
(
aSurface
availableSize
)
mFormat
)
;
}
bool
imgFrame
:
:
Draw
(
gfxContext
*
aContext
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
float
aOpacity
)
{
AUTO_PROFILER_LABEL
(
"
imgFrame
:
:
Draw
"
GRAPHICS
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
!
aRegion
.
Rect
(
)
.
IsEmpty
(
)
"
Drawing
empty
region
!
"
)
;
NS_ASSERTION
(
!
aRegion
.
IsRestricted
(
)
|
|
!
aRegion
.
Rect
(
)
.
Intersect
(
aRegion
.
Restriction
(
)
)
.
IsEmpty
(
)
"
We
must
be
allowed
to
sample
*
some
*
source
pixels
!
"
)
;
RefPtr
<
SourceSurface
>
surf
;
SurfaceWithFormat
surfaceResult
;
ImageRegion
region
(
aRegion
)
;
gfxRect
imageRect
(
0
0
mImageSize
.
width
mImageSize
.
height
)
;
{
MonitorAutoLock
lock
(
mMonitor
)
;
bool
doPartialDecode
=
!
AreAllPixelsWritten
(
)
;
DrawTarget
*
drawTarget
=
aContext
-
>
GetDrawTarget
(
)
;
bool
recording
=
drawTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
RECORDING
;
RefPtr
<
SourceSurface
>
surf
=
GetSourceSurfaceInternal
(
)
;
if
(
!
surf
)
{
return
false
;
}
bool
doTile
=
!
imageRect
.
Contains
(
aRegion
.
Rect
(
)
)
&
&
!
(
aImageFlags
&
imgIContainer
:
:
FLAG_CLAMP
)
;
surfaceResult
=
SurfaceForDrawing
(
doPartialDecode
doTile
region
surf
)
;
if
(
recording
&
&
surfaceResult
.
IsValid
(
)
)
{
mShouldRecycle
=
false
;
}
}
if
(
surfaceResult
.
IsValid
(
)
)
{
gfxUtils
:
:
DrawPixelSnapped
(
aContext
surfaceResult
.
mDrawable
imageRect
.
Size
(
)
region
surfaceResult
.
mFormat
aSamplingFilter
aImageFlags
aOpacity
)
;
}
return
true
;
}
nsresult
imgFrame
:
:
ImageUpdated
(
const
nsIntRect
&
aUpdateRect
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
ImageUpdatedInternal
(
aUpdateRect
)
;
}
nsresult
imgFrame
:
:
ImageUpdatedInternal
(
const
nsIntRect
&
aUpdateRect
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
IntRect
updateRect
=
aUpdateRect
.
Intersect
(
GetRect
(
)
)
;
if
(
updateRect
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
mDecoded
.
UnionRect
(
mDecoded
updateRect
)
;
if
(
mRawSurface
)
{
mRawSurface
-
>
Invalidate
(
updateRect
)
;
}
return
NS_OK
;
}
void
imgFrame
:
:
Finish
(
Opacity
aFrameOpacity
bool
aFinalize
bool
aOrientationSwapsWidthAndHeight
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
IntRect
frameRect
(
GetRect
(
)
)
;
if
(
!
mDecoded
.
IsEqualEdges
(
frameRect
)
)
{
IntRect
delta
(
0
0
frameRect
.
width
0
)
;
if
(
!
aOrientationSwapsWidthAndHeight
)
{
delta
.
width
=
frameRect
.
width
;
if
(
mDecoded
.
y
=
=
0
)
{
delta
.
y
=
mDecoded
.
height
;
delta
.
height
=
frameRect
.
height
-
mDecoded
.
height
;
}
else
if
(
mDecoded
.
y
+
mDecoded
.
height
=
=
frameRect
.
height
)
{
delta
.
height
=
frameRect
.
height
-
mDecoded
.
y
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Decoder
only
updated
middle
of
image
!
"
)
;
delta
=
frameRect
;
}
}
else
{
delta
.
height
=
frameRect
.
height
;
if
(
mDecoded
.
x
=
=
0
)
{
delta
.
x
=
mDecoded
.
width
;
delta
.
width
=
frameRect
.
width
-
mDecoded
.
width
;
}
else
if
(
mDecoded
.
x
+
mDecoded
.
width
=
=
frameRect
.
width
)
{
delta
.
width
=
frameRect
.
width
-
mDecoded
.
x
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Decoder
only
updated
middle
of
image
!
"
)
;
delta
=
frameRect
;
}
}
ImageUpdatedInternal
(
delta
)
;
}
MOZ_ASSERT
(
mDecoded
.
IsEqualEdges
(
frameRect
)
)
;
if
(
aFinalize
)
{
FinalizeSurfaceInternal
(
)
;
}
mFinished
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
uint32_t
imgFrame
:
:
GetImageBytesPerRow
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mRawSurface
)
{
return
mImageSize
.
width
*
BytesPerPixel
(
mFormat
)
;
}
return
0
;
}
uint32_t
imgFrame
:
:
GetImageDataLength
(
)
const
{
return
GetImageBytesPerRow
(
)
*
mImageSize
.
height
;
}
void
imgFrame
:
:
FinalizeSurface
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
FinalizeSurfaceInternal
(
)
;
}
void
imgFrame
:
:
FinalizeSurfaceInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mShouldRecycle
|
|
!
mRawSurface
|
|
mRawSurface
-
>
GetType
(
)
!
=
SurfaceType
:
:
DATA_SHARED
)
{
return
;
}
auto
*
sharedSurf
=
static_cast
<
SourceSurfaceSharedData
*
>
(
mRawSurface
.
get
(
)
)
;
sharedSurf
-
>
Finalize
(
)
;
}
already_AddRefed
<
SourceSurface
>
imgFrame
:
:
GetSourceSurface
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
GetSourceSurfaceInternal
(
)
;
}
already_AddRefed
<
SourceSurface
>
imgFrame
:
:
GetSourceSurfaceInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mOptSurface
)
{
if
(
mOptSurface
-
>
IsValid
(
)
)
{
RefPtr
<
SourceSurface
>
surf
(
mOptSurface
)
;
return
surf
.
forget
(
)
;
}
mOptSurface
=
nullptr
;
}
if
(
mBlankRawSurface
)
{
RefPtr
<
SourceSurface
>
surf
(
mBlankRawSurface
)
;
return
surf
.
forget
(
)
;
}
RefPtr
<
SourceSurface
>
surf
(
mRawSurface
)
;
return
surf
.
forget
(
)
;
}
void
imgFrame
:
:
Abort
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mAborted
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
bool
imgFrame
:
:
IsAborted
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mAborted
;
}
bool
imgFrame
:
:
IsFinished
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mFinished
;
}
void
imgFrame
:
:
WaitUntilFinished
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
true
)
{
if
(
mAborted
|
|
mFinished
)
{
return
;
}
mMonitor
.
Wait
(
)
;
}
}
bool
imgFrame
:
:
AreAllPixelsWritten
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mDecoded
.
IsEqualInterior
(
GetRect
(
)
)
;
}
void
imgFrame
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
const
AddSizeOfCb
&
aCallback
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
AddSizeOfCbData
metadata
;
metadata
.
mFinished
=
mFinished
;
if
(
mOptSurface
)
{
metadata
.
mHeapBytes
+
=
aMallocSizeOf
(
mOptSurface
)
;
SourceSurface
:
:
SizeOfInfo
info
;
mOptSurface
-
>
SizeOfExcludingThis
(
aMallocSizeOf
info
)
;
metadata
.
Accumulate
(
info
)
;
}
if
(
mRawSurface
)
{
metadata
.
mHeapBytes
+
=
aMallocSizeOf
(
mRawSurface
)
;
SourceSurface
:
:
SizeOfInfo
info
;
mRawSurface
-
>
SizeOfExcludingThis
(
aMallocSizeOf
info
)
;
metadata
.
Accumulate
(
info
)
;
}
aCallback
(
metadata
)
;
}
}
}
