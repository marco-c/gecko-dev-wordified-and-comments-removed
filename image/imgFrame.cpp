#
include
"
imgFrame
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
ShutdownTracker
.
h
"
#
include
"
prenv
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
gfxAlphaRecovery
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
image
{
static
void
VolatileBufferRelease
(
void
*
vbuf
)
{
delete
static_cast
<
VolatileBufferPtr
<
unsigned
char
>
*
>
(
vbuf
)
;
}
static
int32_t
VolatileSurfaceStride
(
const
IntSize
&
size
SurfaceFormat
format
)
{
return
(
size
.
width
*
BytesPerPixel
(
format
)
+
0x3
)
&
~
0x3
;
}
static
already_AddRefed
<
DataSourceSurface
>
CreateLockedSurface
(
VolatileBuffer
*
vbuf
const
IntSize
&
size
SurfaceFormat
format
)
{
VolatileBufferPtr
<
unsigned
char
>
*
vbufptr
=
new
VolatileBufferPtr
<
unsigned
char
>
(
vbuf
)
;
MOZ_ASSERT
(
!
vbufptr
-
>
WasBufferPurged
(
)
"
Expected
image
data
!
"
)
;
const
int32_t
stride
=
VolatileSurfaceStride
(
size
format
)
;
RefPtr
<
DataSourceSurface
>
surf
=
Factory
:
:
CreateWrappingDataSourceSurface
(
*
vbufptr
stride
size
format
&
VolatileBufferRelease
static_cast
<
void
*
>
(
vbufptr
)
)
;
if
(
!
surf
)
{
delete
vbufptr
;
return
nullptr
;
}
return
surf
.
forget
(
)
;
}
static
already_AddRefed
<
VolatileBuffer
>
AllocateBufferForImage
(
const
IntSize
&
size
SurfaceFormat
format
)
{
int32_t
stride
=
VolatileSurfaceStride
(
size
format
)
;
RefPtr
<
VolatileBuffer
>
buf
=
new
VolatileBuffer
(
)
;
if
(
buf
-
>
Init
(
stride
*
size
.
height
size_t
(
1
)
<
<
gfxAlphaRecovery
:
:
GoodAlignmentLog2
(
)
)
)
{
return
buf
.
forget
(
)
;
}
return
nullptr
;
}
static
bool
ClearSurface
(
VolatileBuffer
*
aVBuf
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
VolatileBufferPtr
<
unsigned
char
>
vbufptr
(
aVBuf
)
;
if
(
vbufptr
.
WasBufferPurged
(
)
)
{
NS_WARNING
(
"
VolatileBuffer
was
purged
"
)
;
return
false
;
}
int32_t
stride
=
VolatileSurfaceStride
(
aSize
aFormat
)
;
if
(
aFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
)
{
memset
(
vbufptr
0xFF
stride
*
aSize
.
height
)
;
}
else
if
(
aVBuf
-
>
OnHeap
(
)
)
{
memset
(
vbufptr
0
stride
*
aSize
.
height
)
;
}
return
true
;
}
static
bool
AllowedImageSize
(
int32_t
aWidth
int32_t
aHeight
)
{
const
int32_t
k64KLimit
=
0x0000FFFF
;
if
(
MOZ_UNLIKELY
(
aWidth
>
k64KLimit
|
|
aHeight
>
k64KLimit
)
)
{
NS_WARNING
(
"
image
too
big
"
)
;
return
false
;
}
if
(
MOZ_UNLIKELY
(
aHeight
<
=
0
|
|
aWidth
<
=
0
)
)
{
return
false
;
}
CheckedInt32
requiredBytes
=
CheckedInt32
(
aWidth
)
*
CheckedInt32
(
aHeight
)
*
4
;
if
(
MOZ_UNLIKELY
(
!
requiredBytes
.
isValid
(
)
)
)
{
NS_WARNING
(
"
width
or
height
too
large
"
)
;
return
false
;
}
#
if
defined
(
XP_MACOSX
)
if
(
MOZ_UNLIKELY
(
aHeight
>
SHRT_MAX
)
)
{
NS_WARNING
(
"
image
too
big
"
)
;
return
false
;
}
#
endif
return
true
;
}
static
bool
AllowedImageAndFrameDimensions
(
const
nsIntSize
&
aImageSize
const
nsIntRect
&
aFrameRect
)
{
if
(
!
AllowedImageSize
(
aImageSize
.
width
aImageSize
.
height
)
)
{
return
false
;
}
if
(
!
AllowedImageSize
(
aFrameRect
.
width
aFrameRect
.
height
)
)
{
return
false
;
}
nsIntRect
imageRect
(
0
0
aImageSize
.
width
aImageSize
.
height
)
;
if
(
!
imageRect
.
Contains
(
aFrameRect
)
)
{
NS_WARNING
(
"
Animated
image
frame
does
not
fit
inside
bounds
of
image
"
)
;
}
return
true
;
}
imgFrame
:
:
imgFrame
(
)
:
mMonitor
(
"
imgFrame
"
)
mDecoded
(
0
0
0
0
)
mLockCount
(
0
)
mTimeout
(
FrameTimeout
:
:
FromRawMilliseconds
(
100
)
)
mDisposalMethod
(
DisposalMethod
:
:
NOT_SPECIFIED
)
mBlendMethod
(
BlendMethod
:
:
OVER
)
mHasNoAlpha
(
false
)
mAborted
(
false
)
mFinished
(
false
)
mOptimizable
(
false
)
mPalettedImageData
(
nullptr
)
mPaletteDepth
(
0
)
mNonPremult
(
false
)
mCompositingFailed
(
false
)
{
}
imgFrame
:
:
~
imgFrame
(
)
{
#
ifdef
DEBUG
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mAborted
|
|
AreAllPixelsWritten
(
)
)
;
MOZ_ASSERT
(
mAborted
|
|
mFinished
)
;
#
endif
free
(
mPalettedImageData
)
;
mPalettedImageData
=
nullptr
;
}
nsresult
imgFrame
:
:
InitForDecoder
(
const
nsIntSize
&
aImageSize
const
nsIntRect
&
aRect
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
bool
aNonPremult
)
{
if
(
!
AllowedImageAndFrameDimensions
(
aImageSize
aRect
)
)
{
NS_WARNING
(
"
Should
have
legal
image
size
"
)
;
mAborted
=
true
;
return
NS_ERROR_FAILURE
;
}
mImageSize
=
aImageSize
;
mFrameRect
=
aRect
;
if
(
aPaletteDepth
=
=
0
&
&
!
mFrameRect
.
IsEqualEdges
(
IntRect
(
IntPoint
(
)
mImageSize
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Creating
a
non
-
paletted
imgFrame
with
a
"
"
non
-
trivial
frame
rect
"
)
;
return
NS_ERROR_FAILURE
;
}
mFormat
=
aFormat
;
mPaletteDepth
=
aPaletteDepth
;
mNonPremult
=
aNonPremult
;
if
(
aPaletteDepth
!
=
0
)
{
if
(
aPaletteDepth
>
8
)
{
NS_WARNING
(
"
Should
have
legal
palette
depth
"
)
;
NS_ERROR
(
"
This
Depth
is
not
supported
"
)
;
mAborted
=
true
;
return
NS_ERROR_FAILURE
;
}
size_t
dataSize
=
PaletteDataLength
(
)
+
mFrameRect
.
Area
(
)
;
mPalettedImageData
=
static_cast
<
uint8_t
*
>
(
calloc
(
dataSize
sizeof
(
uint8_t
)
)
)
;
if
(
!
mPalettedImageData
)
{
NS_WARNING
(
"
Call
to
calloc
for
paletted
image
data
should
succeed
"
)
;
}
NS_ENSURE_TRUE
(
mPalettedImageData
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
{
MOZ_ASSERT
(
!
mImageSurface
"
Called
imgFrame
:
:
InitForDecoder
(
)
twice
?
"
)
;
mVBuf
=
AllocateBufferForImage
(
mFrameRect
.
Size
(
)
mFormat
)
;
if
(
!
mVBuf
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
mImageSurface
=
CreateLockedSurface
(
mVBuf
mFrameRect
.
Size
(
)
mFormat
)
;
if
(
!
mImageSurface
)
{
NS_WARNING
(
"
Failed
to
create
ImageSurface
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
ClearSurface
(
mVBuf
mFrameRect
.
Size
(
)
mFormat
)
)
{
NS_WARNING
(
"
Could
not
clear
allocated
buffer
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
nsresult
imgFrame
:
:
InitWithDrawable
(
gfxDrawable
*
aDrawable
const
nsIntSize
&
aSize
const
SurfaceFormat
aFormat
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
)
{
if
(
!
AllowedImageSize
(
aSize
.
width
aSize
.
height
)
)
{
NS_WARNING
(
"
Should
have
legal
image
size
"
)
;
mAborted
=
true
;
return
NS_ERROR_FAILURE
;
}
mImageSize
=
aSize
;
mFrameRect
=
IntRect
(
IntPoint
(
0
0
)
aSize
)
;
mFormat
=
aFormat
;
mPaletteDepth
=
0
;
RefPtr
<
DrawTarget
>
target
;
bool
canUseDataSurface
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CanRenderContentToDataSurface
(
)
;
if
(
canUseDataSurface
)
{
MOZ_ASSERT
(
!
mImageSurface
"
Called
imgFrame
:
:
InitWithDrawable
(
)
twice
?
"
)
;
mVBuf
=
AllocateBufferForImage
(
mFrameRect
.
Size
(
)
mFormat
)
;
if
(
!
mVBuf
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
int32_t
stride
=
VolatileSurfaceStride
(
mFrameRect
.
Size
(
)
mFormat
)
;
VolatileBufferPtr
<
uint8_t
>
ptr
(
mVBuf
)
;
if
(
!
ptr
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
mImageSurface
=
CreateLockedSurface
(
mVBuf
mFrameRect
.
Size
(
)
mFormat
)
;
if
(
!
mImageSurface
)
{
NS_WARNING
(
"
Failed
to
create
ImageSurface
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
ClearSurface
(
mVBuf
mFrameRect
.
Size
(
)
mFormat
)
)
{
NS_WARNING
(
"
Could
not
clear
allocated
buffer
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForData
(
ptr
mFrameRect
.
Size
(
)
stride
mFormat
)
;
}
else
{
MOZ_ASSERT
(
!
mOptSurface
"
Called
imgFrame
:
:
InitWithDrawable
(
)
twice
?
"
)
;
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
mFrameRect
.
Size
(
)
mFormat
)
;
}
if
(
!
target
|
|
!
target
-
>
IsValid
(
)
)
{
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
target
)
;
MOZ_ASSERT
(
ctx
)
;
gfxUtils
:
:
DrawPixelSnapped
(
ctx
aDrawable
mFrameRect
.
Size
(
)
ImageRegion
:
:
Create
(
ThebesRect
(
mFrameRect
)
)
mFormat
aSamplingFilter
aImageFlags
)
;
if
(
canUseDataSurface
&
&
!
mImageSurface
)
{
NS_WARNING
(
"
Failed
to
create
VolatileDataSourceSurface
"
)
;
mAborted
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
!
canUseDataSurface
)
{
mOptSurface
=
target
-
>
Snapshot
(
)
;
}
mDecoded
=
GetRect
(
)
;
mFinished
=
true
;
#
ifdef
DEBUG
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
AreAllPixelsWritten
(
)
)
;
#
endif
return
NS_OK
;
}
bool
imgFrame
:
:
CanOptimizeOpaqueImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
ShutdownTracker
:
:
ShutdownHasStarted
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mHasNoAlpha
&
&
mFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
&
&
mImageSurface
&
&
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetDefaultContentBackend
(
)
!
=
BackendType
:
:
SKIA
)
;
}
nsresult
imgFrame
:
:
Optimize
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mLockCount
=
=
1
"
Should
only
optimize
when
holding
the
lock
exclusively
"
)
;
static
bool
gDisableOptimize
=
false
;
static
bool
hasCheckedOptimize
=
false
;
if
(
!
hasCheckedOptimize
)
{
if
(
PR_GetEnv
(
"
MOZ_DISABLE_IMAGE_OPTIMIZE
"
)
)
{
gDisableOptimize
=
true
;
}
hasCheckedOptimize
=
true
;
}
if
(
ShutdownTracker
:
:
ShutdownHasStarted
(
)
)
{
return
NS_OK
;
}
if
(
CanOptimizeOpaqueImage
(
)
)
{
mFormat
=
SurfaceFormat
:
:
B8G8R8X8
;
mImageSurface
=
CreateLockedSurface
(
mVBuf
mFrameRect
.
Size
(
)
mFormat
)
;
}
if
(
!
mOptimizable
|
|
gDisableOptimize
)
{
return
NS_OK
;
}
if
(
mPalettedImageData
|
|
mOptSurface
)
{
return
NS_OK
;
}
if
(
mNonPremult
)
{
return
NS_OK
;
}
#
ifdef
ANDROID
SurfaceFormat
optFormat
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
Optimal2DFormatForContent
(
gfxContentType
:
:
COLOR
)
;
if
(
mFormat
!
=
SurfaceFormat
:
:
B8G8R8A8
&
&
optFormat
=
=
SurfaceFormat
:
:
R5G6B5_UINT16
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
IMAGE_OPTIMIZE_TO_565_USED
true
)
;
RefPtr
<
VolatileBuffer
>
buf
=
AllocateBufferForImage
(
mFrameRect
.
Size
(
)
optFormat
)
;
if
(
!
buf
)
{
return
NS_OK
;
}
RefPtr
<
DataSourceSurface
>
surf
=
CreateLockedSurface
(
buf
mFrameRect
.
Size
(
)
optFormat
)
;
if
(
!
surf
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DataSourceSurface
:
:
MappedSurface
mapping
;
if
(
!
surf
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
WRITE
&
mapping
)
)
{
gfxCriticalError
(
)
<
<
"
imgFrame
:
:
Optimize
failed
to
map
surface
"
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DrawTarget
>
target
=
Factory
:
:
CreateDrawTargetForData
(
BackendType
:
:
CAIRO
mapping
.
mData
mFrameRect
.
Size
(
)
mapping
.
mStride
optFormat
)
;
if
(
!
target
)
{
gfxWarning
(
)
<
<
"
imgFrame
:
:
Optimize
failed
in
CreateDrawTargetForData
"
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
Rect
rect
(
0
0
mFrameRect
.
width
mFrameRect
.
height
)
;
target
-
>
DrawSurface
(
mImageSurface
rect
rect
)
;
target
-
>
Flush
(
)
;
surf
-
>
Unmap
(
)
;
mImageSurface
=
surf
;
mVBuf
=
buf
;
mFormat
=
optFormat
;
}
#
else
mOptSurface
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
-
>
OptimizeSourceSurface
(
mImageSurface
)
;
if
(
mOptSurface
=
=
mImageSurface
)
{
mOptSurface
=
nullptr
;
}
#
endif
if
(
mOptSurface
)
{
mVBuf
=
nullptr
;
mVBufPtr
=
nullptr
;
mImageSurface
=
nullptr
;
}
#
ifdef
MOZ_WIDGET_ANDROID
mImageSurface
=
nullptr
;
#
endif
return
NS_OK
;
}
DrawableFrameRef
imgFrame
:
:
DrawableRef
(
)
{
return
DrawableFrameRef
(
this
)
;
}
RawAccessFrameRef
imgFrame
:
:
RawAccessRef
(
)
{
return
RawAccessFrameRef
(
this
)
;
}
void
imgFrame
:
:
SetRawAccessOnly
(
)
{
AssertImageDataLocked
(
)
;
LockImageData
(
)
;
}
imgFrame
:
:
SurfaceWithFormat
imgFrame
:
:
SurfaceForDrawing
(
bool
aDoPadding
bool
aDoPartialDecode
bool
aDoTile
gfxContext
*
aContext
const
nsIntMargin
&
aPadding
gfxRect
&
aImageRect
ImageRegion
&
aRegion
SourceSurface
*
aSurface
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mMonitor
.
AssertCurrentThreadOwns
(
)
;
IntSize
size
(
int32_t
(
aImageRect
.
Width
(
)
)
int32_t
(
aImageRect
.
Height
(
)
)
)
;
if
(
!
aDoPadding
&
&
!
aDoPartialDecode
)
{
return
SurfaceWithFormat
(
new
gfxSurfaceDrawable
(
aSurface
size
)
mFormat
)
;
}
gfxRect
available
=
gfxRect
(
mDecoded
.
x
mDecoded
.
y
mDecoded
.
width
mDecoded
.
height
)
;
if
(
aDoTile
)
{
RefPtr
<
DrawTarget
>
target
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
size
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
target
)
{
return
SurfaceWithFormat
(
)
;
}
SurfacePattern
pattern
(
aSurface
aRegion
.
GetExtendMode
(
)
Matrix
:
:
Translation
(
mDecoded
.
x
mDecoded
.
y
)
)
;
target
-
>
FillRect
(
ToRect
(
aRegion
.
Intersect
(
available
)
.
Rect
(
)
)
pattern
)
;
RefPtr
<
SourceSurface
>
newsurf
=
target
-
>
Snapshot
(
)
;
return
SurfaceWithFormat
(
new
gfxSurfaceDrawable
(
newsurf
size
)
target
-
>
GetFormat
(
)
)
;
}
gfxPoint
paddingTopLeft
(
aPadding
.
left
aPadding
.
top
)
;
aRegion
=
aRegion
.
Intersect
(
available
)
-
paddingTopLeft
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
paddingTopLeft
)
)
;
aImageRect
=
gfxRect
(
0
0
mFrameRect
.
width
mFrameRect
.
height
)
;
IntSize
availableSize
(
mDecoded
.
width
mDecoded
.
height
)
;
return
SurfaceWithFormat
(
new
gfxSurfaceDrawable
(
aSurface
availableSize
)
mFormat
)
;
}
bool
imgFrame
:
:
Draw
(
gfxContext
*
aContext
const
ImageRegion
&
aRegion
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
)
{
PROFILER_LABEL
(
"
imgFrame
"
"
Draw
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ASSERTION
(
!
aRegion
.
Rect
(
)
.
IsEmpty
(
)
"
Drawing
empty
region
!
"
)
;
NS_ASSERTION
(
!
aRegion
.
IsRestricted
(
)
|
|
!
aRegion
.
Rect
(
)
.
Intersect
(
aRegion
.
Restriction
(
)
)
.
IsEmpty
(
)
"
We
must
be
allowed
to
sample
*
some
*
source
pixels
!
"
)
;
NS_ASSERTION
(
!
mPalettedImageData
"
Directly
drawing
a
paletted
image
!
"
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
nsIntMargin
padding
(
mFrameRect
.
y
mImageSize
.
width
-
mFrameRect
.
XMost
(
)
mImageSize
.
height
-
mFrameRect
.
YMost
(
)
mFrameRect
.
x
)
;
bool
doPadding
=
padding
!
=
nsIntMargin
(
0
0
0
0
)
;
bool
doPartialDecode
=
!
AreAllPixelsWritten
(
)
;
RefPtr
<
SourceSurface
>
surf
=
GetSurfaceInternal
(
)
;
if
(
!
surf
)
{
return
false
;
}
gfxRect
imageRect
(
0
0
mImageSize
.
width
mImageSize
.
height
)
;
bool
doTile
=
!
imageRect
.
Contains
(
aRegion
.
Rect
(
)
)
&
&
!
(
aImageFlags
&
imgIContainer
:
:
FLAG_CLAMP
)
;
ImageRegion
region
(
aRegion
)
;
gfxContextMatrixAutoSaveRestore
autoSR
(
aContext
)
;
SurfaceWithFormat
surfaceResult
=
SurfaceForDrawing
(
doPadding
doPartialDecode
doTile
aContext
padding
imageRect
region
surf
)
;
if
(
surfaceResult
.
IsValid
(
)
)
{
gfxUtils
:
:
DrawPixelSnapped
(
aContext
surfaceResult
.
mDrawable
imageRect
.
Size
(
)
region
surfaceResult
.
mFormat
aSamplingFilter
aImageFlags
)
;
}
return
true
;
}
nsresult
imgFrame
:
:
ImageUpdated
(
const
nsIntRect
&
aUpdateRect
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
ImageUpdatedInternal
(
aUpdateRect
)
;
}
nsresult
imgFrame
:
:
ImageUpdatedInternal
(
const
nsIntRect
&
aUpdateRect
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
mDecoded
.
UnionRect
(
mDecoded
aUpdateRect
)
;
mDecoded
.
IntersectRect
(
mDecoded
mFrameRect
)
;
return
NS_OK
;
}
void
imgFrame
:
:
Finish
(
Opacity
aFrameOpacity
DisposalMethod
aDisposalMethod
FrameTimeout
aTimeout
BlendMethod
aBlendMethod
const
Maybe
<
IntRect
>
&
aBlendRect
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mLockCount
>
0
"
Image
data
should
be
locked
"
)
;
if
(
aFrameOpacity
=
=
Opacity
:
:
FULLY_OPAQUE
)
{
mHasNoAlpha
=
true
;
}
mDisposalMethod
=
aDisposalMethod
;
mTimeout
=
aTimeout
;
mBlendMethod
=
aBlendMethod
;
mBlendRect
=
aBlendRect
;
ImageUpdatedInternal
(
GetRect
(
)
)
;
mFinished
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
uint32_t
imgFrame
:
:
GetImageBytesPerRow
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mVBuf
)
{
return
mFrameRect
.
width
*
BytesPerPixel
(
mFormat
)
;
}
if
(
mPaletteDepth
)
{
return
mFrameRect
.
width
;
}
return
0
;
}
uint32_t
imgFrame
:
:
GetImageDataLength
(
)
const
{
return
GetImageBytesPerRow
(
)
*
mFrameRect
.
height
;
}
void
imgFrame
:
:
GetImageData
(
uint8_t
*
*
aData
uint32_t
*
aLength
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
GetImageDataInternal
(
aData
aLength
)
;
}
void
imgFrame
:
:
GetImageDataInternal
(
uint8_t
*
*
aData
uint32_t
*
aLength
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
MOZ_ASSERT
(
mLockCount
>
0
"
Image
data
should
be
locked
"
)
;
if
(
mImageSurface
)
{
*
aData
=
mVBufPtr
;
MOZ_ASSERT
(
*
aData
"
mImageSurface
is
non
-
null
but
mVBufPtr
is
null
in
GetImageData
"
)
;
}
else
if
(
mPalettedImageData
)
{
*
aData
=
mPalettedImageData
+
PaletteDataLength
(
)
;
MOZ_ASSERT
(
*
aData
"
mPalettedImageData
is
non
-
null
but
result
is
null
in
GetImageData
"
)
;
}
else
{
MOZ_ASSERT
(
false
"
Have
neither
mImageSurface
nor
mPalettedImageData
in
GetImageData
"
)
;
*
aData
=
nullptr
;
}
*
aLength
=
GetImageDataLength
(
)
;
}
uint8_t
*
imgFrame
:
:
GetImageData
(
)
const
{
uint8_t
*
data
;
uint32_t
length
;
GetImageData
(
&
data
&
length
)
;
return
data
;
}
bool
imgFrame
:
:
GetIsPaletted
(
)
const
{
return
mPalettedImageData
!
=
nullptr
;
}
void
imgFrame
:
:
GetPaletteData
(
uint32_t
*
*
aPalette
uint32_t
*
length
)
const
{
AssertImageDataLocked
(
)
;
if
(
!
mPalettedImageData
)
{
*
aPalette
=
nullptr
;
*
length
=
0
;
}
else
{
*
aPalette
=
(
uint32_t
*
)
mPalettedImageData
;
*
length
=
PaletteDataLength
(
)
;
}
}
uint32_t
*
imgFrame
:
:
GetPaletteData
(
)
const
{
uint32_t
*
data
;
uint32_t
length
;
GetPaletteData
(
&
data
&
length
)
;
return
data
;
}
nsresult
imgFrame
:
:
LockImageData
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mLockCount
>
=
0
"
Unbalanced
locks
and
unlocks
"
)
;
if
(
mLockCount
<
0
)
{
return
NS_ERROR_FAILURE
;
}
mLockCount
+
+
;
if
(
mLockCount
!
=
1
)
{
return
NS_OK
;
}
if
(
mImageSurface
)
{
mVBufPtr
=
mVBuf
;
return
NS_OK
;
}
if
(
mPalettedImageData
)
{
return
NS_OK
;
}
MOZ_ASSERT_UNREACHABLE
(
"
It
'
s
illegal
to
re
-
lock
an
optimized
imgFrame
"
)
;
return
NS_ERROR_FAILURE
;
}
void
imgFrame
:
:
AssertImageDataLocked
(
)
const
{
#
ifdef
DEBUG
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mLockCount
>
0
"
Image
data
should
be
locked
"
)
;
#
endif
}
class
UnlockImageDataRunnable
:
public
Runnable
{
public
:
explicit
UnlockImageDataRunnable
(
imgFrame
*
aTarget
)
:
mTarget
(
aTarget
)
{
MOZ_ASSERT
(
mTarget
)
;
}
NS_IMETHOD
Run
(
)
{
return
mTarget
-
>
UnlockImageData
(
)
;
}
private
:
RefPtr
<
imgFrame
>
mTarget
;
}
;
nsresult
imgFrame
:
:
UnlockImageData
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mLockCount
>
0
"
Unlocking
an
unlocked
image
!
"
)
;
if
(
mLockCount
<
=
0
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
mLockCount
>
1
|
|
mFinished
|
|
mAborted
"
Should
have
Finish
(
)
'
d
or
aborted
before
unlocking
"
)
;
if
(
mLockCount
=
=
1
&
&
!
mPalettedImageData
)
{
if
(
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
UnlockImageDataRunnable
(
this
)
;
NS_DispatchToMainThread
(
runnable
)
;
return
NS_OK
;
}
Optimize
(
)
;
mVBufPtr
=
nullptr
;
}
mLockCount
-
-
;
return
NS_OK
;
}
void
imgFrame
:
:
SetOptimizable
(
)
{
AssertImageDataLocked
(
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
mOptimizable
=
true
;
}
already_AddRefed
<
SourceSurface
>
imgFrame
:
:
GetSurface
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
GetSurfaceInternal
(
)
;
}
already_AddRefed
<
SourceSurface
>
imgFrame
:
:
GetSurfaceInternal
(
)
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
if
(
mOptSurface
)
{
if
(
mOptSurface
-
>
IsValid
(
)
)
{
RefPtr
<
SourceSurface
>
surf
(
mOptSurface
)
;
return
surf
.
forget
(
)
;
}
else
{
mOptSurface
=
nullptr
;
}
}
if
(
mImageSurface
)
{
RefPtr
<
SourceSurface
>
surf
(
mImageSurface
)
;
return
surf
.
forget
(
)
;
}
if
(
!
mVBuf
)
{
return
nullptr
;
}
VolatileBufferPtr
<
char
>
buf
(
mVBuf
)
;
if
(
buf
.
WasBufferPurged
(
)
)
{
return
nullptr
;
}
return
CreateLockedSurface
(
mVBuf
mFrameRect
.
Size
(
)
mFormat
)
;
}
AnimationData
imgFrame
:
:
GetAnimationData
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
MOZ_ASSERT
(
mLockCount
>
0
"
Image
data
should
be
locked
"
)
;
uint8_t
*
data
;
if
(
mPalettedImageData
)
{
data
=
mPalettedImageData
;
}
else
{
uint32_t
length
;
GetImageDataInternal
(
&
data
&
length
)
;
}
bool
hasAlpha
=
mFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
;
return
AnimationData
(
data
PaletteDataLength
(
)
mTimeout
GetRect
(
)
mBlendMethod
mBlendRect
mDisposalMethod
hasAlpha
)
;
}
void
imgFrame
:
:
Abort
(
)
{
MonitorAutoLock
lock
(
mMonitor
)
;
mAborted
=
true
;
mMonitor
.
NotifyAll
(
)
;
}
bool
imgFrame
:
:
IsAborted
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mAborted
;
}
bool
imgFrame
:
:
IsFinished
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
return
mFinished
;
}
void
imgFrame
:
:
WaitUntilFinished
(
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
while
(
true
)
{
if
(
mAborted
|
|
mFinished
)
{
return
;
}
mMonitor
.
Wait
(
)
;
}
}
bool
imgFrame
:
:
AreAllPixelsWritten
(
)
const
{
mMonitor
.
AssertCurrentThreadOwns
(
)
;
return
mDecoded
.
IsEqualInterior
(
mFrameRect
)
;
}
bool
imgFrame
:
:
GetCompositingFailed
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mCompositingFailed
;
}
void
imgFrame
:
:
SetCompositingFailed
(
bool
val
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCompositingFailed
=
val
;
}
void
imgFrame
:
:
AddSizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
size_t
&
aHeapSizeOut
size_t
&
aNonHeapSizeOut
)
const
{
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mPalettedImageData
)
{
aHeapSizeOut
+
=
aMallocSizeOf
(
mPalettedImageData
)
;
}
if
(
mImageSurface
)
{
aHeapSizeOut
+
=
aMallocSizeOf
(
mImageSurface
)
;
}
if
(
mOptSurface
)
{
aHeapSizeOut
+
=
aMallocSizeOf
(
mOptSurface
)
;
}
if
(
mVBuf
)
{
aHeapSizeOut
+
=
aMallocSizeOf
(
mVBuf
)
;
aHeapSizeOut
+
=
mVBuf
-
>
HeapSizeOfExcludingThis
(
aMallocSizeOf
)
;
aNonHeapSizeOut
+
=
mVBuf
-
>
NonHeapSizeOfExcludingThis
(
)
;
}
}
}
}
