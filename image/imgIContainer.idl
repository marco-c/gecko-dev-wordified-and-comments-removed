#
include
"
nsISupports
.
idl
"
webidl
Document
;
%
{
C
+
+
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
AspectRatio
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
limits
.
h
"
class
gfxContext
;
namespace
mozilla
{
struct
AspectRatio
;
namespace
gfx
{
class
SourceSurface
;
}
namespace
layers
{
class
LayerManager
;
class
ImageContainer
;
}
}
class
nsIFrame
;
namespace
mozilla
{
class
TimeStamp
;
class
SVGImageContext
;
struct
MediaFeatureChange
;
}
namespace
mozilla
{
namespace
image
{
class
ImageRegion
;
class
ImageIntRegion
;
struct
Orientation
;
struct
Resolution
;
}
}
%
}
native
MaybeAspectRatio
(
mozilla
:
:
Maybe
<
mozilla
:
:
AspectRatio
>
)
;
native
ImgDrawResult
(
mozilla
:
:
image
:
:
ImgDrawResult
)
;
[
ptr
]
native
gfxContext
(
gfxContext
)
;
[
ref
]
native
gfxMatrix
(
gfxMatrix
)
;
[
ref
]
native
gfxRect
(
gfxRect
)
;
[
ref
]
native
gfxSize
(
gfxSize
)
;
native
SamplingFilter
(
mozilla
:
:
gfx
:
:
SamplingFilter
)
;
[
ref
]
native
nsIntRect
(
nsIntRect
)
;
native
nsIntRectByVal
(
nsIntRect
)
;
[
ref
]
native
nsIntSize
(
nsIntSize
)
;
native
nsSize
(
nsSize
)
;
[
ptr
]
native
nsIFrame
(
nsIFrame
)
;
native
TempRefImageContainer
(
already_AddRefed
<
mozilla
:
:
layers
:
:
ImageContainer
>
)
;
[
ptr
]
native
ImageContainer
(
mozilla
:
:
layers
:
:
ImageContainer
)
;
[
ref
]
native
ImageRegion
(
mozilla
:
:
image
:
:
ImageRegion
)
;
[
ptr
]
native
LayerManager
(
mozilla
:
:
layers
:
:
LayerManager
)
;
native
Orientation
(
mozilla
:
:
image
:
:
Orientation
)
;
native
ImageResolution
(
mozilla
:
:
image
:
:
Resolution
)
;
[
ref
]
native
TimeStamp
(
mozilla
:
:
TimeStamp
)
;
[
ref
]
native
MaybeSVGImageContext
(
mozilla
:
:
Maybe
<
mozilla
:
:
SVGImageContext
>
)
;
[
ref
]
native
MaybeImageIntRegion
(
mozilla
:
:
Maybe
<
mozilla
:
:
image
:
:
ImageIntRegion
>
)
;
native
TempRefSourceSurface
(
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
)
;
native
TempRefImgIContainer
(
already_AddRefed
<
imgIContainer
>
)
;
native
nsIntSizeByVal
(
nsIntSize
)
;
[
scriptable
builtinclass
uuid
(
a8dbee24
-
ff86
-
4755
-
b40e
-
51175caf31af
)
]
interface
imgIContainer
:
nsISupports
{
readonly
attribute
int32_t
width
;
readonly
attribute
int32_t
height
;
[
noscript
]
readonly
attribute
nsSize
intrinsicSize
;
[
notxpcom
nostdcall
]
readonly
attribute
MaybeAspectRatio
intrinsicRatio
;
readonly
attribute
int32_t
hotspotX
;
readonly
attribute
int32_t
hotspotY
;
[
notxpcom
nostdcall
]
nsIntSizeByVal
optimalImageSizeForDest
(
[
const
]
in
gfxSize
aDest
in
uint32_t
aWhichFrame
in
SamplingFilter
aSamplingFilter
in
uint32_t
aFlags
)
;
const
unsigned
short
TYPE_RASTER
=
0
;
const
unsigned
short
TYPE_VECTOR
=
1
;
const
unsigned
short
TYPE_REQUEST
=
2
;
[
infallible
]
readonly
attribute
unsigned
short
type
;
readonly
attribute
boolean
animated
;
[
infallible
]
readonly
attribute
unsigned
long
producerId
;
const
unsigned
long
FLAG_NONE
=
0x0
;
const
unsigned
long
FLAG_SYNC_DECODE
=
0x1
;
const
unsigned
long
FLAG_SYNC_DECODE_IF_FAST
=
0x2
;
const
unsigned
long
FLAG_ASYNC_NOTIFY
=
0x4
;
const
unsigned
long
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
=
0x8
;
const
unsigned
long
FLAG_DECODE_NO_COLORSPACE_CONVERSION
=
0x10
;
const
unsigned
long
FLAG_CLAMP
=
0x20
;
const
unsigned
long
FLAG_HIGH_QUALITY_SCALING
=
0x40
;
const
unsigned
long
FLAG_BYPASS_SURFACE_CACHE
=
0x80
;
const
unsigned
long
FLAG_FORCE_PRESERVEASPECTRATIO_NONE
=
0x100
;
const
unsigned
long
FLAG_FORCE_UNIFORM_SCALING
=
0x200
;
const
unsigned
long
FLAG_AVOID_REDECODE_FOR_SIZE
=
0x400
;
const
unsigned
long
FLAG_DECODE_TO_SRGB_COLORSPACE
=
0x800
;
const
unsigned
long
FLAG_RECORD_BLOB
=
0x1000
;
const
unsigned
long
DECODE_FLAGS_DEFAULT
=
0
;
const
unsigned
long
DECODE_FLAGS_FOR_REENCODE
=
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
|
FLAG_DECODE_TO_SRGB_COLORSPACE
;
const
unsigned
long
FRAME_FIRST
=
0
;
const
unsigned
long
FRAME_CURRENT
=
1
;
const
unsigned
long
FRAME_MAX_VALUE
=
1
;
[
noscript
notxpcom
]
TempRefSourceSurface
getFrame
(
in
uint32_t
aWhichFrame
in
uint32_t
aFlags
)
;
[
noscript
notxpcom
]
TempRefSourceSurface
getFrameAtSize
(
[
const
]
in
nsIntSize
aSize
in
uint32_t
aWhichFrame
in
uint32_t
aFlags
)
;
[
noscript
notxpcom
]
boolean
willDrawOpaqueNow
(
)
;
[
noscript
notxpcom
]
boolean
isImageContainerAvailable
(
in
LayerManager
aManager
in
uint32_t
aFlags
)
;
[
noscript
notxpcom
]
TempRefImageContainer
getImageContainer
(
in
LayerManager
aManager
in
uint32_t
aFlags
)
;
[
noscript
notxpcom
]
ImgDrawResult
getImageContainerAtSize
(
in
LayerManager
aManager
[
const
]
in
nsIntSize
aSize
[
const
]
in
MaybeSVGImageContext
aSVGContext
[
const
]
in
MaybeImageIntRegion
aRegion
in
uint32_t
aFlags
out
ImageContainer
aOutContainer
)
;
[
noscript
notxpcom
]
boolean
isImageContainerAvailableAtSize
(
in
LayerManager
aManager
[
const
]
in
nsIntSize
aSize
in
uint32_t
aFlags
)
;
[
noscript
notxpcom
]
ImgDrawResult
draw
(
in
gfxContext
aContext
[
const
]
in
nsIntSize
aSize
[
const
]
in
ImageRegion
aRegion
in
uint32_t
aWhichFrame
in
SamplingFilter
aSamplingFilter
[
const
]
in
MaybeSVGImageContext
aSVGContext
in
uint32_t
aFlags
in
float
aOpacity
)
;
[
noscript
]
void
startDecoding
(
in
uint32_t
aFlags
in
uint32_t
aWhichFrame
)
;
%
{
C
+
+
nsresult
StartDecoding
(
uint32_t
aFlags
)
{
return
StartDecoding
(
aFlags
FRAME_CURRENT
)
;
}
%
}
[
noscript
notxpcom
]
boolean
startDecodingWithResult
(
in
uint32_t
aFlags
in
uint32_t
aWhichFrame
)
;
%
{
C
+
+
bool
StartDecodingWithResult
(
uint32_t
aFlags
)
{
return
StartDecodingWithResult
(
aFlags
FRAME_CURRENT
)
;
}
%
}
cenum
DecodeResult
:
8
{
DECODE_SURFACE_AVAILABLE
=
0
DECODE_REQUESTED
=
1
DECODE_REQUEST_FAILED
=
2
}
;
[
noscript
notxpcom
]
imgIContainer_DecodeResult
requestDecodeWithResult
(
in
uint32_t
aFlags
in
uint32_t
aWhichFrame
)
;
%
{
C
+
+
DecodeResult
RequestDecodeWithResult
(
uint32_t
aFlags
)
{
return
RequestDecodeWithResult
(
aFlags
FRAME_CURRENT
)
;
}
%
}
[
noscript
]
void
requestDecodeForSize
(
[
const
]
in
nsIntSize
aSize
in
uint32_t
aFlags
in
uint32_t
aWhichFrame
)
;
%
{
C
+
+
nsresult
RequestDecodeForSize
(
const
nsIntSize
&
aSize
uint32_t
aFlags
)
{
return
RequestDecodeForSize
(
aSize
aFlags
FRAME_CURRENT
)
;
}
%
}
void
lockImage
(
)
;
void
unlockImage
(
)
;
void
requestDiscard
(
)
;
[
notxpcom
]
void
requestRefresh
(
[
const
]
in
TimeStamp
aTime
)
;
const
short
kNormalAnimMode
=
0
;
const
short
kDontAnimMode
=
1
;
const
short
kLoopOnceAnimMode
=
2
;
attribute
unsigned
short
animationMode
;
void
resetAnimation
(
)
;
[
notxpcom
]
float
getFrameIndex
(
in
uint32_t
aWhichFrame
)
;
[
notxpcom
]
Orientation
getOrientation
(
)
;
[
notxpcom
]
ImageResolution
getResolution
(
)
;
[
notxpcom
]
int32_t
getFirstFrameDelay
(
)
;
[
notxpcom
]
void
setAnimationStartTime
(
[
const
]
in
TimeStamp
aTime
)
;
[
notxpcom
]
nsIntRectByVal
getImageSpaceInvalidationRect
(
[
const
]
in
nsIntRect
aRect
)
;
[
notxpcom
nostdcall
]
TempRefImgIContainer
unwrap
(
)
;
[
noscript
notxpcom
]
void
propagateUseCounters
(
in
Document
aReferencingDocument
)
;
%
{
C
+
+
virtual
void
MediaFeatureValuesChangedAllDocuments
(
const
mozilla
:
:
MediaFeatureChange
&
aChange
)
{
}
virtual
nsresult
GetNativeSizes
(
nsTArray
<
nsIntSize
>
&
aNativeSizes
)
const
=
0
;
virtual
size_t
GetNativeSizesLength
(
)
const
=
0
;
%
}
}
;
