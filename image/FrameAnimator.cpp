#
include
"
FrameAnimator
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
pixman
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
gfx
;
namespace
image
{
const
gfx
:
:
IntRect
AnimationState
:
:
UpdateState
(
bool
aAnimationFinished
RasterImage
*
aImage
const
gfx
:
:
IntSize
&
aSize
bool
aAllowInvalidation
)
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
aImage
)
RasterSurfaceKey
(
aSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
return
UpdateStateInternal
(
result
aAnimationFinished
aSize
aAllowInvalidation
)
;
}
const
gfx
:
:
IntRect
AnimationState
:
:
UpdateStateInternal
(
LookupResult
&
aResult
bool
aAnimationFinished
const
gfx
:
:
IntSize
&
aSize
bool
aAllowInvalidation
)
{
if
(
aResult
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
)
{
mDiscarded
=
mHasBeenDecoded
;
mIsCurrentlyDecoded
=
false
;
}
else
if
(
aResult
.
Type
(
)
=
=
MatchType
:
:
PENDING
)
{
mDiscarded
=
false
;
mIsCurrentlyDecoded
=
false
;
mHasRequestedDecode
=
true
;
}
else
{
MOZ_ASSERT
(
aResult
.
Type
(
)
=
=
MatchType
:
:
EXACT
)
;
mDiscarded
=
false
;
mHasRequestedDecode
=
true
;
if
(
mHasBeenDecoded
)
{
Maybe
<
uint32_t
>
frameCount
=
FrameCount
(
)
;
MOZ_ASSERT
(
frameCount
.
isSome
(
)
)
;
mIsCurrentlyDecoded
=
aResult
.
Surface
(
)
.
IsFullyDecoded
(
)
;
}
}
gfx
:
:
IntRect
ret
;
if
(
aAllowInvalidation
)
{
if
(
mIsCurrentlyDecoded
|
|
aAnimationFinished
)
{
if
(
mCompositedFrameInvalid
)
{
ret
.
SizeTo
(
aSize
)
;
}
mCompositedFrameInvalid
=
false
;
}
else
if
(
aResult
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
|
|
aResult
.
Type
(
)
=
=
MatchType
:
:
PENDING
)
{
if
(
mHasRequestedDecode
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
ImageMemAnimatedDiscardable
(
)
)
;
mCompositedFrameInvalid
=
true
;
}
}
}
return
ret
;
}
void
AnimationState
:
:
NotifyDecodeComplete
(
)
{
mHasBeenDecoded
=
true
;
}
void
AnimationState
:
:
ResetAnimation
(
)
{
mCurrentAnimationFrameIndex
=
0
;
}
void
AnimationState
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
mAnimationMode
=
aAnimationMode
;
}
void
AnimationState
:
:
UpdateKnownFrameCount
(
uint32_t
aFrameCount
)
{
if
(
aFrameCount
<
=
mFrameCount
)
{
return
;
}
MOZ_ASSERT
(
!
mHasBeenDecoded
"
Adding
new
frames
after
decoding
is
finished
?
"
)
;
MOZ_ASSERT
(
aFrameCount
<
=
mFrameCount
+
1
"
Skipped
a
frame
?
"
)
;
mFrameCount
=
aFrameCount
;
}
Maybe
<
uint32_t
>
AnimationState
:
:
FrameCount
(
)
const
{
return
mHasBeenDecoded
?
Some
(
mFrameCount
)
:
Nothing
(
)
;
}
void
AnimationState
:
:
SetFirstFrameRefreshArea
(
const
IntRect
&
aRefreshArea
)
{
mFirstFrameRefreshArea
=
aRefreshArea
;
}
void
AnimationState
:
:
InitAnimationFrameTimeIfNecessary
(
)
{
if
(
mCurrentAnimationFrameTime
.
IsNull
(
)
)
{
mCurrentAnimationFrameTime
=
TimeStamp
:
:
Now
(
)
;
}
}
void
AnimationState
:
:
SetAnimationFrameTime
(
const
TimeStamp
&
aTime
)
{
mCurrentAnimationFrameTime
=
aTime
;
}
bool
AnimationState
:
:
MaybeAdvanceAnimationFrameTime
(
const
TimeStamp
&
aTime
)
{
if
(
!
gfxPrefs
:
:
ImageAnimatedResumeFromLastDisplayed
(
)
|
|
mCurrentAnimationFrameTime
>
=
aTime
)
{
return
false
;
}
mCurrentAnimationFrameTime
=
aTime
;
return
true
;
}
uint32_t
AnimationState
:
:
GetCurrentAnimationFrameIndex
(
)
const
{
return
mCurrentAnimationFrameIndex
;
}
FrameTimeout
AnimationState
:
:
LoopLength
(
)
const
{
if
(
!
mLoopLength
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
MOZ_ASSERT
(
mHasBeenDecoded
"
We
know
the
loop
length
but
decoding
isn
'
t
done
?
"
)
;
if
(
mAnimationMode
!
=
imgIContainer
:
:
kNormalAnimMode
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
return
*
mLoopLength
;
}
TimeStamp
FrameAnimator
:
:
GetCurrentImgFrameEndTime
(
AnimationState
&
aState
FrameTimeout
aCurrentTimeout
)
const
{
if
(
aCurrentTimeout
=
=
FrameTimeout
:
:
Forever
(
)
)
{
return
TimeStamp
:
:
NowLoRes
(
)
+
TimeDuration
:
:
FromMilliseconds
(
31536000
.
0
)
;
}
TimeDuration
durationOfTimeout
=
TimeDuration
:
:
FromMilliseconds
(
double
(
aCurrentTimeout
.
AsMilliseconds
(
)
)
)
;
return
aState
.
mCurrentAnimationFrameTime
+
durationOfTimeout
;
}
RefreshResult
FrameAnimator
:
:
AdvanceFrame
(
AnimationState
&
aState
DrawableSurface
&
aFrames
RawAccessFrameRef
&
aCurrentFrame
TimeStamp
aTime
)
{
AUTO_PROFILER_LABEL
(
"
FrameAnimator
:
:
AdvanceFrame
"
GRAPHICS
)
;
RefreshResult
ret
;
uint32_t
currentFrameIndex
=
aState
.
mCurrentAnimationFrameIndex
;
uint32_t
nextFrameIndex
=
currentFrameIndex
+
1
;
if
(
aState
.
FrameCount
(
)
=
=
Some
(
nextFrameIndex
)
)
{
if
(
aState
.
mLoopRemainingCount
<
0
&
&
aState
.
LoopCount
(
)
>
=
0
)
{
aState
.
mLoopRemainingCount
=
aState
.
LoopCount
(
)
;
}
if
(
aState
.
mAnimationMode
=
=
imgIContainer
:
:
kLoopOnceAnimMode
|
|
aState
.
mLoopRemainingCount
=
=
0
)
{
ret
.
mAnimationFinished
=
true
;
}
nextFrameIndex
=
0
;
if
(
aState
.
mLoopRemainingCount
>
0
)
{
aState
.
mLoopRemainingCount
-
-
;
}
if
(
ret
.
mAnimationFinished
)
{
return
ret
;
}
}
if
(
nextFrameIndex
>
=
aState
.
KnownFrameCount
(
)
)
{
aState
.
mCurrentAnimationFrameTime
=
aTime
;
return
ret
;
}
MOZ_ASSERT
(
nextFrameIndex
<
aState
.
KnownFrameCount
(
)
)
;
RawAccessFrameRef
nextFrame
=
aFrames
.
RawAccessRef
(
nextFrameIndex
)
;
if
(
!
nextFrame
)
{
aState
.
mCurrentAnimationFrameTime
=
aTime
;
return
ret
;
}
if
(
nextFrame
-
>
GetTimeout
(
)
=
=
FrameTimeout
:
:
Forever
(
)
)
{
ret
.
mAnimationFinished
=
true
;
}
if
(
nextFrameIndex
=
=
0
)
{
ret
.
mDirtyRect
=
aState
.
FirstFrameRefreshArea
(
)
;
}
else
{
MOZ_ASSERT
(
nextFrameIndex
=
=
currentFrameIndex
+
1
)
;
if
(
!
DoBlend
(
aCurrentFrame
nextFrame
nextFrameIndex
&
ret
.
mDirtyRect
)
)
{
NS_WARNING
(
"
FrameAnimator
:
:
AdvanceFrame
(
)
:
Compositing
of
frame
failed
"
)
;
nextFrame
-
>
SetCompositingFailed
(
true
)
;
aState
.
mCurrentAnimationFrameTime
=
GetCurrentImgFrameEndTime
(
aState
aCurrentFrame
-
>
GetTimeout
(
)
)
;
aState
.
mCurrentAnimationFrameIndex
=
nextFrameIndex
;
aState
.
mCompositedFrameRequested
=
false
;
aCurrentFrame
=
std
:
:
move
(
nextFrame
)
;
aFrames
.
Advance
(
nextFrameIndex
)
;
return
ret
;
}
nextFrame
-
>
SetCompositingFailed
(
false
)
;
}
aState
.
mCurrentAnimationFrameTime
=
GetCurrentImgFrameEndTime
(
aState
aCurrentFrame
-
>
GetTimeout
(
)
)
;
FrameTimeout
loopTime
=
aState
.
LoopLength
(
)
;
if
(
loopTime
!
=
FrameTimeout
:
:
Forever
(
)
&
&
(
aState
.
LoopCount
(
)
<
0
|
|
aState
.
mLoopRemainingCount
>
=
0
)
)
{
TimeDuration
delay
=
aTime
-
aState
.
mCurrentAnimationFrameTime
;
if
(
delay
.
ToMilliseconds
(
)
>
loopTime
.
AsMilliseconds
(
)
)
{
uint64_t
loops
=
static_cast
<
uint64_t
>
(
delay
.
ToMilliseconds
(
)
)
/
loopTime
.
AsMilliseconds
(
)
;
if
(
aState
.
mLoopRemainingCount
>
=
0
)
{
MOZ_ASSERT
(
aState
.
LoopCount
(
)
>
=
0
)
;
loops
=
std
:
:
min
(
loops
CheckedUint64
(
aState
.
mLoopRemainingCount
)
.
value
(
)
)
;
}
aState
.
mCurrentAnimationFrameTime
+
=
TimeDuration
:
:
FromMilliseconds
(
loops
*
loopTime
.
AsMilliseconds
(
)
)
;
if
(
aState
.
mLoopRemainingCount
>
=
0
)
{
MOZ_ASSERT
(
loops
<
=
CheckedUint64
(
aState
.
mLoopRemainingCount
)
.
value
(
)
)
;
aState
.
mLoopRemainingCount
-
=
CheckedInt32
(
loops
)
.
value
(
)
;
}
}
}
aState
.
mCurrentAnimationFrameIndex
=
nextFrameIndex
;
aState
.
mCompositedFrameRequested
=
false
;
aCurrentFrame
=
std
:
:
move
(
nextFrame
)
;
aFrames
.
Advance
(
nextFrameIndex
)
;
ret
.
mFrameAdvanced
=
true
;
return
ret
;
}
void
FrameAnimator
:
:
ResetAnimation
(
AnimationState
&
aState
)
{
aState
.
ResetAnimation
(
)
;
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
if
(
!
result
)
{
return
;
}
result
.
Surface
(
)
.
Reset
(
)
;
}
RefreshResult
FrameAnimator
:
:
RequestRefresh
(
AnimationState
&
aState
const
TimeStamp
&
aTime
bool
aAnimationFinished
)
{
RefreshResult
ret
;
if
(
aState
.
IsDiscarded
(
)
)
{
aState
.
MaybeAdvanceAnimationFrameTime
(
aTime
)
;
return
ret
;
}
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
ret
.
mDirtyRect
=
aState
.
UpdateStateInternal
(
result
aAnimationFinished
mSize
)
;
if
(
aState
.
IsDiscarded
(
)
|
|
!
result
)
{
aState
.
MaybeAdvanceAnimationFrameTime
(
aTime
)
;
if
(
!
ret
.
mDirtyRect
.
IsEmpty
(
)
)
{
ret
.
mFrameAdvanced
=
true
;
}
return
ret
;
}
RawAccessFrameRef
currentFrame
=
result
.
Surface
(
)
.
RawAccessRef
(
aState
.
mCurrentAnimationFrameIndex
)
;
if
(
!
currentFrame
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
ImageMemAnimatedDiscardable
(
)
)
;
MOZ_ASSERT
(
aState
.
GetHasRequestedDecode
(
)
&
&
!
aState
.
GetIsCurrentlyDecoded
(
)
)
;
MOZ_ASSERT
(
aState
.
mCompositedFrameInvalid
)
;
aState
.
MaybeAdvanceAnimationFrameTime
(
aTime
)
;
return
ret
;
}
TimeStamp
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
currentFrame
-
>
GetTimeout
(
)
)
;
if
(
!
aState
.
mCompositedFrameRequested
&
&
aState
.
MaybeAdvanceAnimationFrameTime
(
aTime
)
)
{
return
ret
;
}
while
(
currentFrameEndTime
<
=
aTime
)
{
TimeStamp
oldFrameEndTime
=
currentFrameEndTime
;
RefreshResult
frameRes
=
AdvanceFrame
(
aState
result
.
Surface
(
)
currentFrame
aTime
)
;
ret
.
Accumulate
(
frameRes
)
;
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
currentFrame
-
>
GetTimeout
(
)
)
;
if
(
!
frameRes
.
mFrameAdvanced
&
&
currentFrameEndTime
=
=
oldFrameEndTime
)
{
break
;
}
}
if
(
currentFrameEndTime
>
aTime
)
{
aState
.
mCompositedFrameInvalid
=
false
;
ret
.
mDirtyRect
=
IntRect
(
IntPoint
(
0
0
)
mSize
)
;
}
MOZ_ASSERT
(
!
aState
.
mIsCurrentlyDecoded
|
|
!
aState
.
mCompositedFrameInvalid
)
;
return
ret
;
}
LookupResult
FrameAnimator
:
:
GetCompositedFrame
(
AnimationState
&
aState
)
{
aState
.
mCompositedFrameRequested
=
true
;
if
(
!
aState
.
mCompositedFrameInvalid
&
&
mLastCompositedFrameIndex
>
=
0
&
&
(
uint32_t
(
mLastCompositedFrameIndex
)
=
=
aState
.
mCurrentAnimationFrameIndex
)
)
{
return
LookupResult
(
DrawableSurface
(
mCompositingFrame
-
>
DrawableRef
(
)
)
MatchType
:
:
EXACT
)
;
}
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
if
(
aState
.
mCompositedFrameInvalid
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
ImageMemAnimatedDiscardable
(
)
)
;
MOZ_ASSERT
(
aState
.
GetHasRequestedDecode
(
)
)
;
MOZ_ASSERT
(
!
aState
.
GetIsCurrentlyDecoded
(
)
)
;
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
)
{
return
result
;
}
return
LookupResult
(
MatchType
:
:
PENDING
)
;
}
if
(
!
result
)
{
return
result
;
}
if
(
NS_FAILED
(
result
.
Surface
(
)
.
Seek
(
aState
.
mCurrentAnimationFrameIndex
)
)
)
{
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
)
{
return
result
;
}
return
LookupResult
(
MatchType
:
:
PENDING
)
;
}
MOZ_ASSERT
(
!
result
.
Surface
(
)
-
>
GetIsPaletted
(
)
"
About
to
return
a
paletted
frame
"
)
;
return
result
;
}
static
void
DoCollectSizeOfCompositingSurfaces
(
const
RawAccessFrameRef
&
aSurface
SurfaceMemoryCounterType
aType
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
{
SurfaceKey
key
=
RasterSurfaceKey
(
aSurface
-
>
GetImageSize
(
)
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eStatic
)
;
SurfaceMemoryCounter
counter
(
key
true
false
false
aType
)
;
size_t
heap
=
0
nonHeap
=
0
handles
=
0
;
aSurface
-
>
AddSizeOfExcludingThis
(
aMallocSizeOf
heap
nonHeap
handles
)
;
counter
.
Values
(
)
.
SetDecodedHeap
(
heap
)
;
counter
.
Values
(
)
.
SetDecodedNonHeap
(
nonHeap
)
;
counter
.
Values
(
)
.
SetExternalHandles
(
handles
)
;
aCounters
.
AppendElement
(
counter
)
;
}
void
FrameAnimator
:
:
CollectSizeOfCompositingSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
mCompositingFrame
)
{
DoCollectSizeOfCompositingSurfaces
(
mCompositingFrame
SurfaceMemoryCounterType
:
:
COMPOSITING
aCounters
aMallocSizeOf
)
;
}
if
(
mCompositingPrevFrame
)
{
DoCollectSizeOfCompositingSurfaces
(
mCompositingPrevFrame
SurfaceMemoryCounterType
:
:
COMPOSITING_PREV
aCounters
aMallocSizeOf
)
;
}
}
bool
FrameAnimator
:
:
DoBlend
(
const
RawAccessFrameRef
&
aPrevFrame
const
RawAccessFrameRef
&
aNextFrame
uint32_t
aNextFrameIndex
IntRect
*
aDirtyRect
)
{
MOZ_ASSERT
(
aPrevFrame
&
&
aNextFrame
"
Should
have
frames
here
"
)
;
DisposalMethod
prevDisposalMethod
=
aPrevFrame
-
>
GetDisposalMethod
(
)
;
bool
prevHasAlpha
=
aPrevFrame
-
>
FormatHasAlpha
(
)
;
if
(
prevDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
&
&
!
mCompositingPrevFrame
)
{
prevDisposalMethod
=
DisposalMethod
:
:
CLEAR
;
}
IntRect
prevRect
=
aPrevFrame
-
>
GetBoundedBlendRect
(
)
;
bool
isFullPrevFrame
=
prevRect
.
IsEqualRect
(
0
0
mSize
.
width
mSize
.
height
)
;
if
(
isFullPrevFrame
&
&
(
prevDisposalMethod
=
=
DisposalMethod
:
:
CLEAR
)
)
{
prevDisposalMethod
=
DisposalMethod
:
:
CLEAR_ALL
;
}
DisposalMethod
nextDisposalMethod
=
aNextFrame
-
>
GetDisposalMethod
(
)
;
bool
nextHasAlpha
=
aNextFrame
-
>
FormatHasAlpha
(
)
;
IntRect
nextRect
=
aNextFrame
-
>
GetBoundedBlendRect
(
)
;
bool
isFullNextFrame
=
nextRect
.
IsEqualRect
(
0
0
mSize
.
width
mSize
.
height
)
;
if
(
!
aNextFrame
-
>
GetIsPaletted
(
)
)
{
if
(
prevDisposalMethod
=
=
DisposalMethod
:
:
CLEAR_ALL
)
{
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
return
true
;
}
if
(
isFullNextFrame
&
&
(
nextDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
&
&
!
nextHasAlpha
)
{
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
return
true
;
}
}
switch
(
prevDisposalMethod
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
NOT_SPECIFIED
:
case
DisposalMethod
:
:
KEEP
:
*
aDirtyRect
=
nextRect
;
break
;
case
DisposalMethod
:
:
CLEAR_ALL
:
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
break
;
case
DisposalMethod
:
:
CLEAR
:
aDirtyRect
-
>
UnionRect
(
nextRect
prevRect
)
;
break
;
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
break
;
}
if
(
mLastCompositedFrameIndex
=
=
int32_t
(
aNextFrameIndex
)
)
{
return
true
;
}
bool
needToBlankComposite
=
false
;
if
(
!
mCompositingFrame
)
{
RefPtr
<
imgFrame
>
newFrame
=
new
imgFrame
;
nsresult
rv
=
newFrame
-
>
InitForAnimator
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCompositingFrame
.
reset
(
)
;
return
false
;
}
mCompositingFrame
=
newFrame
-
>
RawAccessRef
(
)
;
needToBlankComposite
=
true
;
}
else
if
(
int32_t
(
aNextFrameIndex
)
!
=
mLastCompositedFrameIndex
+
1
)
{
needToBlankComposite
=
true
;
}
bool
doDisposal
=
true
;
if
(
!
nextHasAlpha
&
&
nextDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
if
(
isFullNextFrame
)
{
doDisposal
=
false
;
needToBlankComposite
=
false
;
}
else
{
if
(
(
prevRect
.
X
(
)
>
=
nextRect
.
X
(
)
)
&
&
(
prevRect
.
Y
(
)
>
=
nextRect
.
Y
(
)
)
&
&
(
prevRect
.
XMost
(
)
<
=
nextRect
.
XMost
(
)
)
&
&
(
prevRect
.
YMost
(
)
<
=
nextRect
.
YMost
(
)
)
)
{
doDisposal
=
false
;
}
}
}
if
(
doDisposal
)
{
switch
(
prevDisposalMethod
)
{
case
DisposalMethod
:
:
CLEAR
:
if
(
needToBlankComposite
)
{
ClearFrame
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
}
else
{
ClearFrame
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
prevRect
)
;
}
break
;
case
DisposalMethod
:
:
CLEAR_ALL
:
ClearFrame
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
break
;
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
if
(
mCompositingPrevFrame
)
{
CopyFrameImage
(
mCompositingPrevFrame
.
Data
(
)
mCompositingPrevFrame
-
>
GetRect
(
)
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
if
(
nextDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
mCompositingPrevFrame
.
reset
(
)
;
}
}
else
{
ClearFrame
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
}
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
NOT_SPECIFIED
:
case
DisposalMethod
:
:
KEEP
:
if
(
mLastCompositedFrameIndex
!
=
int32_t
(
aNextFrameIndex
-
1
)
)
{
if
(
isFullPrevFrame
&
&
!
aPrevFrame
-
>
GetIsPaletted
(
)
)
{
CopyFrameImage
(
aPrevFrame
.
Data
(
)
prevRect
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
}
else
{
if
(
needToBlankComposite
)
{
if
(
prevHasAlpha
|
|
!
isFullPrevFrame
)
{
ClearFrame
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
}
}
DrawFrameTo
(
aPrevFrame
.
Data
(
)
aPrevFrame
-
>
GetRect
(
)
aPrevFrame
.
PaletteDataLength
(
)
prevHasAlpha
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
aPrevFrame
-
>
GetBlendMethod
(
)
aPrevFrame
-
>
GetBlendRect
(
)
)
;
}
}
}
}
else
if
(
needToBlankComposite
)
{
ClearFrame
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
)
;
}
if
(
(
nextDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
&
&
(
prevDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
)
{
if
(
!
mCompositingPrevFrame
)
{
RefPtr
<
imgFrame
>
newFrame
=
new
imgFrame
;
nsresult
rv
=
newFrame
-
>
InitForAnimator
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCompositingPrevFrame
.
reset
(
)
;
return
false
;
}
mCompositingPrevFrame
=
newFrame
-
>
RawAccessRef
(
)
;
}
CopyFrameImage
(
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
mCompositingPrevFrame
.
Data
(
)
mCompositingPrevFrame
-
>
GetRect
(
)
)
;
mCompositingPrevFrame
-
>
Finish
(
)
;
}
DrawFrameTo
(
aNextFrame
.
Data
(
)
aNextFrame
-
>
GetRect
(
)
aNextFrame
.
PaletteDataLength
(
)
nextHasAlpha
mCompositingFrame
.
Data
(
)
mCompositingFrame
-
>
GetRect
(
)
aNextFrame
-
>
GetBlendMethod
(
)
aNextFrame
-
>
GetBlendRect
(
)
)
;
mCompositingFrame
-
>
Finish
(
)
;
mLastCompositedFrameIndex
=
int32_t
(
aNextFrameIndex
)
;
return
true
;
}
void
FrameAnimator
:
:
ClearFrame
(
uint8_t
*
aFrameData
const
IntRect
&
aFrameRect
)
{
if
(
!
aFrameData
)
{
return
;
}
memset
(
aFrameData
0
aFrameRect
.
Width
(
)
*
aFrameRect
.
Height
(
)
*
4
)
;
}
void
FrameAnimator
:
:
ClearFrame
(
uint8_t
*
aFrameData
const
IntRect
&
aFrameRect
const
IntRect
&
aRectToClear
)
{
if
(
!
aFrameData
|
|
aFrameRect
.
Width
(
)
<
=
0
|
|
aFrameRect
.
Height
(
)
<
=
0
|
|
aRectToClear
.
Width
(
)
<
=
0
|
|
aRectToClear
.
Height
(
)
<
=
0
)
{
return
;
}
IntRect
toClear
=
aFrameRect
.
Intersect
(
aRectToClear
)
;
if
(
toClear
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
bytesPerRow
=
aFrameRect
.
Width
(
)
*
4
;
for
(
int
row
=
toClear
.
Y
(
)
;
row
<
toClear
.
YMost
(
)
;
+
+
row
)
{
memset
(
aFrameData
+
toClear
.
X
(
)
*
4
+
row
*
bytesPerRow
0
toClear
.
Width
(
)
*
4
)
;
}
}
bool
FrameAnimator
:
:
CopyFrameImage
(
const
uint8_t
*
aDataSrc
const
IntRect
&
aRectSrc
uint8_t
*
aDataDest
const
IntRect
&
aRectDest
)
{
uint32_t
dataLengthSrc
=
aRectSrc
.
Width
(
)
*
aRectSrc
.
Height
(
)
*
4
;
uint32_t
dataLengthDest
=
aRectDest
.
Width
(
)
*
aRectDest
.
Height
(
)
*
4
;
if
(
!
aDataDest
|
|
!
aDataSrc
|
|
dataLengthSrc
!
=
dataLengthDest
)
{
return
false
;
}
memcpy
(
aDataDest
aDataSrc
dataLengthDest
)
;
return
true
;
}
nsresult
FrameAnimator
:
:
DrawFrameTo
(
const
uint8_t
*
aSrcData
const
IntRect
&
aSrcRect
uint32_t
aSrcPaletteLength
bool
aSrcHasAlpha
uint8_t
*
aDstPixels
const
IntRect
&
aDstRect
BlendMethod
aBlendMethod
const
IntRect
&
aBlendRect
)
{
NS_ENSURE_ARG_POINTER
(
aSrcData
)
;
NS_ENSURE_ARG_POINTER
(
aDstPixels
)
;
if
(
aSrcRect
.
X
(
)
<
0
|
|
aSrcRect
.
Y
(
)
<
0
)
{
NS_WARNING
(
"
FrameAnimator
:
:
DrawFrameTo
:
negative
offsets
not
allowed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
(
aSrcRect
.
X
(
)
>
aDstRect
.
Width
(
)
)
|
|
(
aSrcRect
.
Y
(
)
>
aDstRect
.
Height
(
)
)
)
{
return
NS_OK
;
}
if
(
aSrcPaletteLength
)
{
int32_t
width
=
std
:
:
min
(
aSrcRect
.
Width
(
)
aDstRect
.
Width
(
)
-
aSrcRect
.
X
(
)
)
;
int32_t
height
=
std
:
:
min
(
aSrcRect
.
Height
(
)
aDstRect
.
Height
(
)
-
aSrcRect
.
Y
(
)
)
;
NS_ASSERTION
(
(
aSrcRect
.
X
(
)
>
=
0
)
&
&
(
aSrcRect
.
Y
(
)
>
=
0
)
&
&
(
aSrcRect
.
X
(
)
+
width
<
=
aDstRect
.
Width
(
)
)
&
&
(
aSrcRect
.
Y
(
)
+
height
<
=
aDstRect
.
Height
(
)
)
"
FrameAnimator
:
:
DrawFrameTo
:
Invalid
aSrcRect
"
)
;
NS_ASSERTION
(
(
width
<
=
aSrcRect
.
Width
(
)
)
&
&
(
height
<
=
aSrcRect
.
Height
(
)
)
"
FrameAnimator
:
:
DrawFrameTo
:
source
must
be
smaller
than
dest
"
)
;
const
uint8_t
*
srcPixels
=
aSrcData
+
aSrcPaletteLength
;
uint32_t
*
dstPixels
=
reinterpret_cast
<
uint32_t
*
>
(
aDstPixels
)
;
const
uint32_t
*
colormap
=
reinterpret_cast
<
const
uint32_t
*
>
(
aSrcData
)
;
dstPixels
+
=
aSrcRect
.
X
(
)
+
(
aSrcRect
.
Y
(
)
*
aDstRect
.
Width
(
)
)
;
if
(
!
aSrcHasAlpha
)
{
for
(
int32_t
r
=
height
;
r
>
0
;
-
-
r
)
{
for
(
int32_t
c
=
0
;
c
<
width
;
c
+
+
)
{
dstPixels
[
c
]
=
colormap
[
srcPixels
[
c
]
]
;
}
srcPixels
+
=
aSrcRect
.
Width
(
)
;
dstPixels
+
=
aDstRect
.
Width
(
)
;
}
}
else
{
for
(
int32_t
r
=
height
;
r
>
0
;
-
-
r
)
{
for
(
int32_t
c
=
0
;
c
<
width
;
c
+
+
)
{
const
uint32_t
color
=
colormap
[
srcPixels
[
c
]
]
;
if
(
color
)
{
dstPixels
[
c
]
=
color
;
}
}
srcPixels
+
=
aSrcRect
.
Width
(
)
;
dstPixels
+
=
aDstRect
.
Width
(
)
;
}
}
}
else
{
pixman_image_t
*
src
=
pixman_image_create_bits
(
aSrcHasAlpha
?
PIXMAN_a8r8g8b8
:
PIXMAN_x8r8g8b8
aSrcRect
.
Width
(
)
aSrcRect
.
Height
(
)
reinterpret_cast
<
uint32_t
*
>
(
const_cast
<
uint8_t
*
>
(
aSrcData
)
)
aSrcRect
.
Width
(
)
*
4
)
;
if
(
!
src
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
pixman_image_t
*
dst
=
pixman_image_create_bits
(
PIXMAN_a8r8g8b8
aDstRect
.
Width
(
)
aDstRect
.
Height
(
)
reinterpret_cast
<
uint32_t
*
>
(
aDstPixels
)
aDstRect
.
Width
(
)
*
4
)
;
if
(
!
dst
)
{
pixman_image_unref
(
src
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
op
=
aBlendMethod
=
=
BlendMethod
:
:
SOURCE
?
PIXMAN_OP_SRC
:
PIXMAN_OP_OVER
;
if
(
aBlendMethod
=
=
BlendMethod
:
:
OVER
|
|
(
aBlendMethod
=
=
BlendMethod
:
:
SOURCE
&
&
aSrcRect
.
IsEqualEdges
(
aBlendRect
)
)
)
{
pixman_image_composite32
(
op
src
nullptr
dst
0
0
0
0
aSrcRect
.
X
(
)
aSrcRect
.
Y
(
)
aSrcRect
.
Width
(
)
aSrcRect
.
Height
(
)
)
;
}
else
{
pixman_image_composite32
(
PIXMAN_OP_OVER
src
nullptr
dst
0
0
0
0
aSrcRect
.
X
(
)
aSrcRect
.
Y
(
)
aSrcRect
.
Width
(
)
aSrcRect
.
Height
(
)
)
;
pixman_image_composite32
(
PIXMAN_OP_SRC
src
nullptr
dst
aBlendRect
.
X
(
)
aBlendRect
.
Y
(
)
0
0
aBlendRect
.
X
(
)
aBlendRect
.
Y
(
)
aBlendRect
.
Width
(
)
aBlendRect
.
Height
(
)
)
;
}
pixman_image_unref
(
src
)
;
pixman_image_unref
(
dst
)
;
}
return
NS_OK
;
}
}
}
