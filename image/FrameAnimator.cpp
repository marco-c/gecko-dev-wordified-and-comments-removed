#
include
"
FrameAnimator
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
pixman
.
h
"
namespace
mozilla
{
using
namespace
gfx
;
namespace
image
{
void
AnimationState
:
:
SetDoneDecoding
(
bool
aDone
)
{
mDoneDecoding
=
aDone
;
}
void
AnimationState
:
:
ResetAnimation
(
)
{
mCurrentAnimationFrameIndex
=
0
;
}
void
AnimationState
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
mAnimationMode
=
aAnimationMode
;
}
void
AnimationState
:
:
UnionFirstFrameRefreshArea
(
const
nsIntRect
&
aRect
)
{
mFirstFrameRefreshArea
.
UnionRect
(
mFirstFrameRefreshArea
aRect
)
;
}
void
AnimationState
:
:
InitAnimationFrameTimeIfNecessary
(
)
{
if
(
mCurrentAnimationFrameTime
.
IsNull
(
)
)
{
mCurrentAnimationFrameTime
=
TimeStamp
:
:
Now
(
)
;
}
}
void
AnimationState
:
:
SetAnimationFrameTime
(
const
TimeStamp
&
aTime
)
{
mCurrentAnimationFrameTime
=
aTime
;
}
uint32_t
AnimationState
:
:
GetCurrentAnimationFrameIndex
(
)
const
{
return
mCurrentAnimationFrameIndex
;
}
nsIntRect
AnimationState
:
:
GetFirstFrameRefreshArea
(
)
const
{
return
mFirstFrameRefreshArea
;
}
FrameTimeout
FrameAnimator
:
:
GetSingleLoopTime
(
AnimationState
&
aState
)
const
{
if
(
!
aState
.
mDoneDecoding
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
if
(
aState
.
mAnimationMode
!
=
imgIContainer
:
:
kNormalAnimMode
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
FrameTimeout
loopTime
=
FrameTimeout
:
:
Zero
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mImage
-
>
GetNumFrames
(
)
;
+
+
i
)
{
loopTime
+
=
GetTimeoutForFrame
(
i
)
;
}
if
(
loopTime
=
=
FrameTimeout
:
:
Forever
(
)
)
{
NS_WARNING
(
"
Infinite
frame
timeout
-
how
did
this
happen
?
"
)
;
}
return
loopTime
;
}
TimeStamp
FrameAnimator
:
:
GetCurrentImgFrameEndTime
(
AnimationState
&
aState
)
const
{
TimeStamp
currentFrameTime
=
aState
.
mCurrentAnimationFrameTime
;
FrameTimeout
timeout
=
GetTimeoutForFrame
(
aState
.
mCurrentAnimationFrameIndex
)
;
if
(
timeout
=
=
FrameTimeout
:
:
Forever
(
)
)
{
return
TimeStamp
:
:
NowLoRes
(
)
+
TimeDuration
:
:
FromMilliseconds
(
31536000
.
0
)
;
}
TimeDuration
durationOfTimeout
=
TimeDuration
:
:
FromMilliseconds
(
double
(
timeout
.
AsMilliseconds
(
)
)
)
;
TimeStamp
currentFrameEndTime
=
currentFrameTime
+
durationOfTimeout
;
return
currentFrameEndTime
;
}
FrameAnimator
:
:
RefreshResult
FrameAnimator
:
:
AdvanceFrame
(
AnimationState
&
aState
TimeStamp
aTime
)
{
NS_ASSERTION
(
aTime
<
=
TimeStamp
:
:
Now
(
)
"
Given
time
appears
to
be
in
the
future
"
)
;
PROFILER_LABEL_FUNC
(
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
RefreshResult
ret
;
uint32_t
currentFrameIndex
=
aState
.
mCurrentAnimationFrameIndex
;
uint32_t
nextFrameIndex
=
currentFrameIndex
+
1
;
if
(
mImage
-
>
GetNumFrames
(
)
=
=
nextFrameIndex
)
{
if
(
!
aState
.
mDoneDecoding
)
{
aState
.
mCurrentAnimationFrameTime
=
aTime
;
return
ret
;
}
if
(
aState
.
mLoopRemainingCount
<
0
&
&
aState
.
LoopCount
(
)
>
=
0
)
{
aState
.
mLoopRemainingCount
=
aState
.
LoopCount
(
)
;
}
if
(
aState
.
mAnimationMode
=
=
imgIContainer
:
:
kLoopOnceAnimMode
|
|
aState
.
mLoopRemainingCount
=
=
0
)
{
ret
.
animationFinished
=
true
;
}
nextFrameIndex
=
0
;
if
(
aState
.
mLoopRemainingCount
>
0
)
{
aState
.
mLoopRemainingCount
-
-
;
}
if
(
ret
.
animationFinished
)
{
return
ret
;
}
}
MOZ_ASSERT
(
nextFrameIndex
<
mImage
-
>
GetNumFrames
(
)
)
;
RawAccessFrameRef
nextFrame
=
GetRawFrame
(
nextFrameIndex
)
;
bool
canDisplay
=
aState
.
mDoneDecoding
|
|
(
nextFrame
&
&
nextFrame
-
>
IsFinished
(
)
)
;
if
(
!
canDisplay
)
{
return
ret
;
}
if
(
GetTimeoutForFrame
(
nextFrameIndex
)
=
=
FrameTimeout
:
:
Forever
(
)
)
{
ret
.
animationFinished
=
true
;
}
if
(
nextFrameIndex
=
=
0
)
{
ret
.
dirtyRect
=
aState
.
mFirstFrameRefreshArea
;
}
else
{
MOZ_ASSERT
(
nextFrameIndex
=
=
currentFrameIndex
+
1
)
;
if
(
!
DoBlend
(
&
ret
.
dirtyRect
currentFrameIndex
nextFrameIndex
)
)
{
NS_WARNING
(
"
FrameAnimator
:
:
AdvanceFrame
(
)
:
Compositing
of
frame
failed
"
)
;
nextFrame
-
>
SetCompositingFailed
(
true
)
;
aState
.
mCurrentAnimationFrameTime
=
GetCurrentImgFrameEndTime
(
aState
)
;
aState
.
mCurrentAnimationFrameIndex
=
nextFrameIndex
;
return
ret
;
}
nextFrame
-
>
SetCompositingFailed
(
false
)
;
}
aState
.
mCurrentAnimationFrameTime
=
GetCurrentImgFrameEndTime
(
aState
)
;
FrameTimeout
loopTime
=
GetSingleLoopTime
(
aState
)
;
if
(
loopTime
!
=
FrameTimeout
:
:
Forever
(
)
)
{
TimeDuration
delay
=
aTime
-
aState
.
mCurrentAnimationFrameTime
;
if
(
delay
.
ToMilliseconds
(
)
>
loopTime
.
AsMilliseconds
(
)
)
{
uint64_t
loops
=
static_cast
<
uint64_t
>
(
delay
.
ToMilliseconds
(
)
)
/
loopTime
.
AsMilliseconds
(
)
;
aState
.
mCurrentAnimationFrameTime
+
=
TimeDuration
:
:
FromMilliseconds
(
loops
*
loopTime
.
AsMilliseconds
(
)
)
;
}
}
aState
.
mCurrentAnimationFrameIndex
=
nextFrameIndex
;
ret
.
frameAdvanced
=
true
;
return
ret
;
}
FrameAnimator
:
:
RefreshResult
FrameAnimator
:
:
RequestRefresh
(
AnimationState
&
aState
const
TimeStamp
&
aTime
)
{
TimeStamp
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
)
;
RefreshResult
ret
;
while
(
currentFrameEndTime
<
=
aTime
)
{
TimeStamp
oldFrameEndTime
=
currentFrameEndTime
;
RefreshResult
frameRes
=
AdvanceFrame
(
aState
aTime
)
;
ret
.
Accumulate
(
frameRes
)
;
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
)
;
if
(
!
frameRes
.
frameAdvanced
&
&
(
currentFrameEndTime
=
=
oldFrameEndTime
)
)
{
break
;
}
}
return
ret
;
}
LookupResult
FrameAnimator
:
:
GetCompositedFrame
(
uint32_t
aFrameNum
)
{
MOZ_ASSERT
(
aFrameNum
!
=
0
"
First
frame
is
never
composited
"
)
;
if
(
mLastCompositedFrameIndex
=
=
int32_t
(
aFrameNum
)
)
{
return
LookupResult
(
mCompositingFrame
-
>
DrawableRef
(
)
MatchType
:
:
EXACT
)
;
}
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
aFrameNum
)
)
;
MOZ_ASSERT
(
!
result
|
|
!
result
.
DrawableRef
(
)
-
>
GetIsPaletted
(
)
"
About
to
return
a
paletted
frame
"
)
;
return
result
;
}
FrameTimeout
FrameAnimator
:
:
GetTimeoutForFrame
(
uint32_t
aFrameNum
)
const
{
RawAccessFrameRef
frame
=
GetRawFrame
(
aFrameNum
)
;
if
(
frame
)
{
AnimationData
data
=
frame
-
>
GetAnimationData
(
)
;
return
data
.
mTimeout
;
}
NS_WARNING
(
"
No
frame
;
called
GetTimeoutForFrame
too
early
?
"
)
;
return
FrameTimeout
:
:
FromRawMilliseconds
(
100
)
;
}
static
void
DoCollectSizeOfCompositingSurfaces
(
const
RawAccessFrameRef
&
aSurface
SurfaceMemoryCounterType
aType
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
{
SurfaceKey
key
=
RasterSurfaceKey
(
aSurface
-
>
GetImageSize
(
)
DefaultSurfaceFlags
(
)
0
)
;
SurfaceMemoryCounter
counter
(
key
true
aType
)
;
size_t
heap
=
0
nonHeap
=
0
;
aSurface
-
>
AddSizeOfExcludingThis
(
aMallocSizeOf
heap
nonHeap
)
;
counter
.
Values
(
)
.
SetDecodedHeap
(
heap
)
;
counter
.
Values
(
)
.
SetDecodedNonHeap
(
nonHeap
)
;
aCounters
.
AppendElement
(
counter
)
;
}
void
FrameAnimator
:
:
CollectSizeOfCompositingSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
mCompositingFrame
)
{
DoCollectSizeOfCompositingSurfaces
(
mCompositingFrame
SurfaceMemoryCounterType
:
:
COMPOSITING
aCounters
aMallocSizeOf
)
;
}
if
(
mCompositingPrevFrame
)
{
DoCollectSizeOfCompositingSurfaces
(
mCompositingPrevFrame
SurfaceMemoryCounterType
:
:
COMPOSITING_PREV
aCounters
aMallocSizeOf
)
;
}
}
RawAccessFrameRef
FrameAnimator
:
:
GetRawFrame
(
uint32_t
aFrameNum
)
const
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
aFrameNum
)
)
;
return
result
?
result
.
DrawableRef
(
)
-
>
RawAccessRef
(
)
:
RawAccessFrameRef
(
)
;
}
bool
FrameAnimator
:
:
DoBlend
(
nsIntRect
*
aDirtyRect
uint32_t
aPrevFrameIndex
uint32_t
aNextFrameIndex
)
{
RawAccessFrameRef
prevFrame
=
GetRawFrame
(
aPrevFrameIndex
)
;
RawAccessFrameRef
nextFrame
=
GetRawFrame
(
aNextFrameIndex
)
;
MOZ_ASSERT
(
prevFrame
&
&
nextFrame
"
Should
have
frames
here
"
)
;
AnimationData
prevFrameData
=
prevFrame
-
>
GetAnimationData
(
)
;
if
(
prevFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
&
&
!
mCompositingPrevFrame
)
{
prevFrameData
.
mDisposalMethod
=
DisposalMethod
:
:
CLEAR
;
}
bool
isFullPrevFrame
=
prevFrameData
.
mRect
.
x
=
=
0
&
&
prevFrameData
.
mRect
.
y
=
=
0
&
&
prevFrameData
.
mRect
.
width
=
=
mSize
.
width
&
&
prevFrameData
.
mRect
.
height
=
=
mSize
.
height
;
if
(
isFullPrevFrame
&
&
(
prevFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR
)
)
{
prevFrameData
.
mDisposalMethod
=
DisposalMethod
:
:
CLEAR_ALL
;
}
AnimationData
nextFrameData
=
nextFrame
-
>
GetAnimationData
(
)
;
bool
isFullNextFrame
=
nextFrameData
.
mRect
.
x
=
=
0
&
&
nextFrameData
.
mRect
.
y
=
=
0
&
&
nextFrameData
.
mRect
.
width
=
=
mSize
.
width
&
&
nextFrameData
.
mRect
.
height
=
=
mSize
.
height
;
if
(
!
nextFrame
-
>
GetIsPaletted
(
)
)
{
if
(
prevFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR_ALL
)
{
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
return
true
;
}
if
(
isFullNextFrame
&
&
(
nextFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
&
&
!
nextFrameData
.
mHasAlpha
)
{
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
return
true
;
}
}
switch
(
prevFrameData
.
mDisposalMethod
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
NOT_SPECIFIED
:
case
DisposalMethod
:
:
KEEP
:
*
aDirtyRect
=
nextFrameData
.
mRect
;
break
;
case
DisposalMethod
:
:
CLEAR_ALL
:
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
break
;
case
DisposalMethod
:
:
CLEAR
:
aDirtyRect
-
>
UnionRect
(
nextFrameData
.
mRect
prevFrameData
.
mRect
)
;
break
;
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
break
;
}
if
(
mLastCompositedFrameIndex
=
=
int32_t
(
aNextFrameIndex
)
)
{
return
true
;
}
bool
needToBlankComposite
=
false
;
if
(
!
mCompositingFrame
)
{
RefPtr
<
imgFrame
>
newFrame
=
new
imgFrame
;
nsresult
rv
=
newFrame
-
>
InitForDecoder
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCompositingFrame
.
reset
(
)
;
return
false
;
}
mCompositingFrame
=
newFrame
-
>
RawAccessRef
(
)
;
needToBlankComposite
=
true
;
}
else
if
(
int32_t
(
aNextFrameIndex
)
!
=
mLastCompositedFrameIndex
+
1
)
{
needToBlankComposite
=
true
;
}
AnimationData
compositingFrameData
=
mCompositingFrame
-
>
GetAnimationData
(
)
;
bool
doDisposal
=
true
;
if
(
!
nextFrameData
.
mHasAlpha
&
&
nextFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
if
(
isFullNextFrame
)
{
doDisposal
=
false
;
needToBlankComposite
=
false
;
}
else
{
if
(
(
prevFrameData
.
mRect
.
x
>
=
nextFrameData
.
mRect
.
x
)
&
&
(
prevFrameData
.
mRect
.
y
>
=
nextFrameData
.
mRect
.
y
)
&
&
(
prevFrameData
.
mRect
.
x
+
prevFrameData
.
mRect
.
width
<
=
nextFrameData
.
mRect
.
x
+
nextFrameData
.
mRect
.
width
)
&
&
(
prevFrameData
.
mRect
.
y
+
prevFrameData
.
mRect
.
height
<
=
nextFrameData
.
mRect
.
y
+
nextFrameData
.
mRect
.
height
)
)
{
doDisposal
=
false
;
}
}
}
if
(
doDisposal
)
{
switch
(
prevFrameData
.
mDisposalMethod
)
{
case
DisposalMethod
:
:
CLEAR
:
if
(
needToBlankComposite
)
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
else
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
prevFrameData
.
mRect
)
;
}
break
;
case
DisposalMethod
:
:
CLEAR_ALL
:
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
break
;
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
if
(
mCompositingPrevFrame
)
{
AnimationData
compositingPrevFrameData
=
mCompositingPrevFrame
-
>
GetAnimationData
(
)
;
CopyFrameImage
(
compositingPrevFrameData
.
mRawData
compositingPrevFrameData
.
mRect
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
if
(
nextFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
mCompositingPrevFrame
.
reset
(
)
;
}
}
else
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
NOT_SPECIFIED
:
case
DisposalMethod
:
:
KEEP
:
if
(
mLastCompositedFrameIndex
!
=
int32_t
(
aNextFrameIndex
-
1
)
)
{
if
(
isFullPrevFrame
&
&
!
prevFrame
-
>
GetIsPaletted
(
)
)
{
CopyFrameImage
(
prevFrameData
.
mRawData
prevFrameData
.
mRect
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
else
{
if
(
needToBlankComposite
)
{
if
(
prevFrameData
.
mHasAlpha
|
|
!
isFullPrevFrame
)
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
}
DrawFrameTo
(
prevFrameData
.
mRawData
prevFrameData
.
mRect
prevFrameData
.
mPaletteDataLength
prevFrameData
.
mHasAlpha
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
prevFrameData
.
mBlendMethod
prevFrameData
.
mBlendRect
)
;
}
}
}
}
else
if
(
needToBlankComposite
)
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
if
(
(
nextFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
&
&
(
prevFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
)
{
if
(
!
mCompositingPrevFrame
)
{
RefPtr
<
imgFrame
>
newFrame
=
new
imgFrame
;
nsresult
rv
=
newFrame
-
>
InitForDecoder
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCompositingPrevFrame
.
reset
(
)
;
return
false
;
}
mCompositingPrevFrame
=
newFrame
-
>
RawAccessRef
(
)
;
}
AnimationData
compositingPrevFrameData
=
mCompositingPrevFrame
-
>
GetAnimationData
(
)
;
CopyFrameImage
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
compositingPrevFrameData
.
mRawData
compositingPrevFrameData
.
mRect
)
;
mCompositingPrevFrame
-
>
Finish
(
)
;
}
DrawFrameTo
(
nextFrameData
.
mRawData
nextFrameData
.
mRect
nextFrameData
.
mPaletteDataLength
nextFrameData
.
mHasAlpha
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
nextFrameData
.
mBlendMethod
nextFrameData
.
mBlendRect
)
;
mCompositingFrame
-
>
Finish
(
)
;
mLastCompositedFrameIndex
=
int32_t
(
aNextFrameIndex
)
;
return
true
;
}
void
FrameAnimator
:
:
ClearFrame
(
uint8_t
*
aFrameData
const
nsIntRect
&
aFrameRect
)
{
if
(
!
aFrameData
)
{
return
;
}
memset
(
aFrameData
0
aFrameRect
.
width
*
aFrameRect
.
height
*
4
)
;
}
void
FrameAnimator
:
:
ClearFrame
(
uint8_t
*
aFrameData
const
nsIntRect
&
aFrameRect
const
nsIntRect
&
aRectToClear
)
{
if
(
!
aFrameData
|
|
aFrameRect
.
width
<
=
0
|
|
aFrameRect
.
height
<
=
0
|
|
aRectToClear
.
width
<
=
0
|
|
aRectToClear
.
height
<
=
0
)
{
return
;
}
nsIntRect
toClear
=
aFrameRect
.
Intersect
(
aRectToClear
)
;
if
(
toClear
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
bytesPerRow
=
aFrameRect
.
width
*
4
;
for
(
int
row
=
toClear
.
y
;
row
<
toClear
.
y
+
toClear
.
height
;
+
+
row
)
{
memset
(
aFrameData
+
toClear
.
x
*
4
+
row
*
bytesPerRow
0
toClear
.
width
*
4
)
;
}
}
bool
FrameAnimator
:
:
CopyFrameImage
(
const
uint8_t
*
aDataSrc
const
nsIntRect
&
aRectSrc
uint8_t
*
aDataDest
const
nsIntRect
&
aRectDest
)
{
uint32_t
dataLengthSrc
=
aRectSrc
.
width
*
aRectSrc
.
height
*
4
;
uint32_t
dataLengthDest
=
aRectDest
.
width
*
aRectDest
.
height
*
4
;
if
(
!
aDataDest
|
|
!
aDataSrc
|
|
dataLengthSrc
!
=
dataLengthDest
)
{
return
false
;
}
memcpy
(
aDataDest
aDataSrc
dataLengthDest
)
;
return
true
;
}
nsresult
FrameAnimator
:
:
DrawFrameTo
(
const
uint8_t
*
aSrcData
const
nsIntRect
&
aSrcRect
uint32_t
aSrcPaletteLength
bool
aSrcHasAlpha
uint8_t
*
aDstPixels
const
nsIntRect
&
aDstRect
BlendMethod
aBlendMethod
const
Maybe
<
nsIntRect
>
&
aBlendRect
)
{
NS_ENSURE_ARG_POINTER
(
aSrcData
)
;
NS_ENSURE_ARG_POINTER
(
aDstPixels
)
;
if
(
aSrcRect
.
x
<
0
|
|
aSrcRect
.
y
<
0
)
{
NS_WARNING
(
"
FrameAnimator
:
:
DrawFrameTo
:
negative
offsets
not
allowed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
(
aSrcRect
.
x
>
aDstRect
.
width
)
|
|
(
aSrcRect
.
y
>
aDstRect
.
height
)
)
{
return
NS_OK
;
}
if
(
aSrcPaletteLength
)
{
int32_t
width
=
std
:
:
min
(
aSrcRect
.
width
aDstRect
.
width
-
aSrcRect
.
x
)
;
int32_t
height
=
std
:
:
min
(
aSrcRect
.
height
aDstRect
.
height
-
aSrcRect
.
y
)
;
NS_ASSERTION
(
(
aSrcRect
.
x
>
=
0
)
&
&
(
aSrcRect
.
y
>
=
0
)
&
&
(
aSrcRect
.
x
+
width
<
=
aDstRect
.
width
)
&
&
(
aSrcRect
.
y
+
height
<
=
aDstRect
.
height
)
"
FrameAnimator
:
:
DrawFrameTo
:
Invalid
aSrcRect
"
)
;
NS_ASSERTION
(
(
width
<
=
aSrcRect
.
width
)
&
&
(
height
<
=
aSrcRect
.
height
)
"
FrameAnimator
:
:
DrawFrameTo
:
source
must
be
smaller
than
dest
"
)
;
const
uint8_t
*
srcPixels
=
aSrcData
+
aSrcPaletteLength
;
uint32_t
*
dstPixels
=
reinterpret_cast
<
uint32_t
*
>
(
aDstPixels
)
;
const
uint32_t
*
colormap
=
reinterpret_cast
<
const
uint32_t
*
>
(
aSrcData
)
;
dstPixels
+
=
aSrcRect
.
x
+
(
aSrcRect
.
y
*
aDstRect
.
width
)
;
if
(
!
aSrcHasAlpha
)
{
for
(
int32_t
r
=
height
;
r
>
0
;
-
-
r
)
{
for
(
int32_t
c
=
0
;
c
<
width
;
c
+
+
)
{
dstPixels
[
c
]
=
colormap
[
srcPixels
[
c
]
]
;
}
srcPixels
+
=
aSrcRect
.
width
;
dstPixels
+
=
aDstRect
.
width
;
}
}
else
{
for
(
int32_t
r
=
height
;
r
>
0
;
-
-
r
)
{
for
(
int32_t
c
=
0
;
c
<
width
;
c
+
+
)
{
const
uint32_t
color
=
colormap
[
srcPixels
[
c
]
]
;
if
(
color
)
{
dstPixels
[
c
]
=
color
;
}
}
srcPixels
+
=
aSrcRect
.
width
;
dstPixels
+
=
aDstRect
.
width
;
}
}
}
else
{
pixman_image_t
*
src
=
pixman_image_create_bits
(
aSrcHasAlpha
?
PIXMAN_a8r8g8b8
:
PIXMAN_x8r8g8b8
aSrcRect
.
width
aSrcRect
.
height
reinterpret_cast
<
uint32_t
*
>
(
const_cast
<
uint8_t
*
>
(
aSrcData
)
)
aSrcRect
.
width
*
4
)
;
if
(
!
src
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
pixman_image_t
*
dst
=
pixman_image_create_bits
(
PIXMAN_a8r8g8b8
aDstRect
.
width
aDstRect
.
height
reinterpret_cast
<
uint32_t
*
>
(
aDstPixels
)
aDstRect
.
width
*
4
)
;
if
(
!
dst
)
{
pixman_image_unref
(
src
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
op
=
aBlendMethod
=
=
BlendMethod
:
:
SOURCE
?
PIXMAN_OP_SRC
:
PIXMAN_OP_OVER
;
if
(
aBlendMethod
=
=
BlendMethod
:
:
OVER
|
|
!
aBlendRect
|
|
(
aBlendMethod
=
=
BlendMethod
:
:
SOURCE
&
&
aSrcRect
.
IsEqualEdges
(
*
aBlendRect
)
)
)
{
pixman_image_composite32
(
op
src
nullptr
dst
0
0
0
0
aSrcRect
.
x
aSrcRect
.
y
aSrcRect
.
width
aSrcRect
.
height
)
;
}
else
{
pixman_image_composite32
(
PIXMAN_OP_OVER
src
nullptr
dst
0
0
0
0
aSrcRect
.
x
aSrcRect
.
y
aSrcRect
.
width
aSrcRect
.
height
)
;
pixman_image_composite32
(
PIXMAN_OP_SRC
src
nullptr
dst
aBlendRect
-
>
x
aBlendRect
-
>
y
0
0
aBlendRect
-
>
x
aBlendRect
-
>
y
aBlendRect
-
>
width
aBlendRect
-
>
height
)
;
}
pixman_image_unref
(
src
)
;
pixman_image_unref
(
dst
)
;
}
return
NS_OK
;
}
}
}
