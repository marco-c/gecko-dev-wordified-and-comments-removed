#
include
"
FrameAnimator
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
LookupResult
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
pixman
.
h
"
#
include
<
algorithm
>
namespace
mozilla
{
using
namespace
gfx
;
namespace
image
{
const
gfx
:
:
IntRect
AnimationState
:
:
UpdateState
(
bool
aAnimationFinished
RasterImage
*
aImage
const
gfx
:
:
IntSize
&
aSize
bool
aAllowInvalidation
)
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
aImage
)
RasterSurfaceKey
(
aSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
return
UpdateStateInternal
(
result
aAnimationFinished
aSize
aAllowInvalidation
)
;
}
const
gfx
:
:
IntRect
AnimationState
:
:
UpdateStateInternal
(
LookupResult
&
aResult
bool
aAnimationFinished
const
gfx
:
:
IntSize
&
aSize
bool
aAllowInvalidation
)
{
if
(
aResult
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
)
{
mDiscarded
=
mHasBeenDecoded
;
mIsCurrentlyDecoded
=
false
;
}
else
if
(
aResult
.
Type
(
)
=
=
MatchType
:
:
PENDING
)
{
mDiscarded
=
false
;
mIsCurrentlyDecoded
=
false
;
mHasRequestedDecode
=
true
;
}
else
{
MOZ_ASSERT
(
aResult
.
Type
(
)
=
=
MatchType
:
:
EXACT
)
;
mDiscarded
=
false
;
mHasRequestedDecode
=
true
;
if
(
mHasBeenDecoded
)
{
Maybe
<
uint32_t
>
frameCount
=
FrameCount
(
)
;
MOZ_ASSERT
(
frameCount
.
isSome
(
)
)
;
if
(
NS_SUCCEEDED
(
aResult
.
Surface
(
)
.
Seek
(
*
frameCount
-
1
)
)
&
&
aResult
.
Surface
(
)
-
>
IsFinished
(
)
)
{
mIsCurrentlyDecoded
=
true
;
}
else
{
mIsCurrentlyDecoded
=
false
;
}
}
}
gfx
:
:
IntRect
ret
;
if
(
aAllowInvalidation
)
{
if
(
mIsCurrentlyDecoded
|
|
aAnimationFinished
)
{
if
(
mCompositedFrameInvalid
)
{
ret
.
SizeTo
(
aSize
)
;
}
mCompositedFrameInvalid
=
false
;
}
else
if
(
aResult
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
|
|
aResult
.
Type
(
)
=
=
MatchType
:
:
PENDING
)
{
if
(
mHasRequestedDecode
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
ImageMemAnimatedDiscardable
(
)
)
;
mCompositedFrameInvalid
=
true
;
}
}
}
return
ret
;
}
void
AnimationState
:
:
NotifyDecodeComplete
(
)
{
mHasBeenDecoded
=
true
;
}
void
AnimationState
:
:
ResetAnimation
(
)
{
mCurrentAnimationFrameIndex
=
0
;
}
void
AnimationState
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
mAnimationMode
=
aAnimationMode
;
}
void
AnimationState
:
:
UpdateKnownFrameCount
(
uint32_t
aFrameCount
)
{
if
(
aFrameCount
<
=
mFrameCount
)
{
return
;
}
MOZ_ASSERT
(
!
mHasBeenDecoded
"
Adding
new
frames
after
decoding
is
finished
?
"
)
;
MOZ_ASSERT
(
aFrameCount
<
=
mFrameCount
+
1
"
Skipped
a
frame
?
"
)
;
mFrameCount
=
aFrameCount
;
}
Maybe
<
uint32_t
>
AnimationState
:
:
FrameCount
(
)
const
{
return
mHasBeenDecoded
?
Some
(
mFrameCount
)
:
Nothing
(
)
;
}
void
AnimationState
:
:
SetFirstFrameRefreshArea
(
const
IntRect
&
aRefreshArea
)
{
mFirstFrameRefreshArea
=
aRefreshArea
;
}
void
AnimationState
:
:
InitAnimationFrameTimeIfNecessary
(
)
{
if
(
mCurrentAnimationFrameTime
.
IsNull
(
)
)
{
mCurrentAnimationFrameTime
=
TimeStamp
:
:
Now
(
)
;
}
}
void
AnimationState
:
:
SetAnimationFrameTime
(
const
TimeStamp
&
aTime
)
{
mCurrentAnimationFrameTime
=
aTime
;
}
uint32_t
AnimationState
:
:
GetCurrentAnimationFrameIndex
(
)
const
{
return
mCurrentAnimationFrameIndex
;
}
FrameTimeout
AnimationState
:
:
LoopLength
(
)
const
{
if
(
!
mLoopLength
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
MOZ_ASSERT
(
mHasBeenDecoded
"
We
know
the
loop
length
but
decoding
isn
'
t
done
?
"
)
;
if
(
mAnimationMode
!
=
imgIContainer
:
:
kNormalAnimMode
)
{
return
FrameTimeout
:
:
Forever
(
)
;
}
return
*
mLoopLength
;
}
Maybe
<
TimeStamp
>
FrameAnimator
:
:
GetCurrentImgFrameEndTime
(
AnimationState
&
aState
DrawableSurface
&
aFrames
)
const
{
TimeStamp
currentFrameTime
=
aState
.
mCurrentAnimationFrameTime
;
Maybe
<
FrameTimeout
>
timeout
=
GetTimeoutForFrame
(
aState
aFrames
aState
.
mCurrentAnimationFrameIndex
)
;
if
(
timeout
.
isNothing
(
)
)
{
MOZ_ASSERT
(
aState
.
GetHasRequestedDecode
(
)
&
&
!
aState
.
GetIsCurrentlyDecoded
(
)
)
;
return
Nothing
(
)
;
}
if
(
*
timeout
=
=
FrameTimeout
:
:
Forever
(
)
)
{
return
Some
(
TimeStamp
:
:
NowLoRes
(
)
+
TimeDuration
:
:
FromMilliseconds
(
31536000
.
0
)
)
;
}
TimeDuration
durationOfTimeout
=
TimeDuration
:
:
FromMilliseconds
(
double
(
timeout
-
>
AsMilliseconds
(
)
)
)
;
TimeStamp
currentFrameEndTime
=
currentFrameTime
+
durationOfTimeout
;
return
Some
(
currentFrameEndTime
)
;
}
RefreshResult
FrameAnimator
:
:
AdvanceFrame
(
AnimationState
&
aState
DrawableSurface
&
aFrames
TimeStamp
aTime
)
{
NS_ASSERTION
(
aTime
<
=
TimeStamp
:
:
Now
(
)
"
Given
time
appears
to
be
in
the
future
"
)
;
AUTO_PROFILER_LABEL
(
"
FrameAnimator
:
:
AdvanceFrame
"
GRAPHICS
)
;
RefreshResult
ret
;
uint32_t
currentFrameIndex
=
aState
.
mCurrentAnimationFrameIndex
;
uint32_t
nextFrameIndex
=
currentFrameIndex
+
1
;
if
(
aState
.
FrameCount
(
)
=
=
Some
(
nextFrameIndex
)
)
{
if
(
aState
.
mLoopRemainingCount
<
0
&
&
aState
.
LoopCount
(
)
>
=
0
)
{
aState
.
mLoopRemainingCount
=
aState
.
LoopCount
(
)
;
}
if
(
aState
.
mAnimationMode
=
=
imgIContainer
:
:
kLoopOnceAnimMode
|
|
aState
.
mLoopRemainingCount
=
=
0
)
{
ret
.
mAnimationFinished
=
true
;
}
nextFrameIndex
=
0
;
if
(
aState
.
mLoopRemainingCount
>
0
)
{
aState
.
mLoopRemainingCount
-
-
;
}
if
(
ret
.
mAnimationFinished
)
{
return
ret
;
}
}
if
(
nextFrameIndex
>
=
aState
.
KnownFrameCount
(
)
)
{
aState
.
mCurrentAnimationFrameTime
=
aTime
;
return
ret
;
}
MOZ_ASSERT
(
nextFrameIndex
<
aState
.
KnownFrameCount
(
)
)
;
RawAccessFrameRef
nextFrame
=
GetRawFrame
(
aFrames
nextFrameIndex
)
;
if
(
!
nextFrame
|
|
!
nextFrame
-
>
IsFinished
(
)
)
{
return
ret
;
}
Maybe
<
FrameTimeout
>
nextFrameTimeout
=
GetTimeoutForFrame
(
aState
aFrames
nextFrameIndex
)
;
MOZ_ASSERT
(
nextFrameTimeout
.
isSome
(
)
)
;
if
(
*
nextFrameTimeout
=
=
FrameTimeout
:
:
Forever
(
)
)
{
ret
.
mAnimationFinished
=
true
;
}
if
(
nextFrameIndex
=
=
0
)
{
ret
.
mDirtyRect
=
aState
.
FirstFrameRefreshArea
(
)
;
}
else
{
MOZ_ASSERT
(
nextFrameIndex
=
=
currentFrameIndex
+
1
)
;
if
(
!
DoBlend
(
aFrames
&
ret
.
mDirtyRect
currentFrameIndex
nextFrameIndex
)
)
{
NS_WARNING
(
"
FrameAnimator
:
:
AdvanceFrame
(
)
:
Compositing
of
frame
failed
"
)
;
nextFrame
-
>
SetCompositingFailed
(
true
)
;
Maybe
<
TimeStamp
>
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
aFrames
)
;
MOZ_ASSERT
(
currentFrameEndTime
.
isSome
(
)
)
;
aState
.
mCurrentAnimationFrameTime
=
*
currentFrameEndTime
;
aState
.
mCurrentAnimationFrameIndex
=
nextFrameIndex
;
return
ret
;
}
nextFrame
-
>
SetCompositingFailed
(
false
)
;
}
Maybe
<
TimeStamp
>
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
aFrames
)
;
MOZ_ASSERT
(
currentFrameEndTime
.
isSome
(
)
)
;
aState
.
mCurrentAnimationFrameTime
=
*
currentFrameEndTime
;
FrameTimeout
loopTime
=
aState
.
LoopLength
(
)
;
if
(
loopTime
!
=
FrameTimeout
:
:
Forever
(
)
&
&
(
aState
.
LoopCount
(
)
<
0
|
|
aState
.
mLoopRemainingCount
>
=
0
)
)
{
TimeDuration
delay
=
aTime
-
aState
.
mCurrentAnimationFrameTime
;
if
(
delay
.
ToMilliseconds
(
)
>
loopTime
.
AsMilliseconds
(
)
)
{
uint64_t
loops
=
static_cast
<
uint64_t
>
(
delay
.
ToMilliseconds
(
)
)
/
loopTime
.
AsMilliseconds
(
)
;
if
(
aState
.
mLoopRemainingCount
>
=
0
)
{
MOZ_ASSERT
(
aState
.
LoopCount
(
)
>
=
0
)
;
loops
=
std
:
:
min
(
loops
CheckedUint64
(
aState
.
mLoopRemainingCount
)
.
value
(
)
)
;
}
aState
.
mCurrentAnimationFrameTime
+
=
TimeDuration
:
:
FromMilliseconds
(
loops
*
loopTime
.
AsMilliseconds
(
)
)
;
if
(
aState
.
mLoopRemainingCount
>
=
0
)
{
MOZ_ASSERT
(
loops
<
=
CheckedUint64
(
aState
.
mLoopRemainingCount
)
.
value
(
)
)
;
aState
.
mLoopRemainingCount
-
=
CheckedInt32
(
loops
)
.
value
(
)
;
}
}
}
aState
.
mCurrentAnimationFrameIndex
=
nextFrameIndex
;
ret
.
mFrameAdvanced
=
true
;
return
ret
;
}
RefreshResult
FrameAnimator
:
:
RequestRefresh
(
AnimationState
&
aState
const
TimeStamp
&
aTime
bool
aAnimationFinished
)
{
RefreshResult
ret
;
if
(
aState
.
IsDiscarded
(
)
)
{
return
ret
;
}
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
ret
.
mDirtyRect
=
aState
.
UpdateStateInternal
(
result
aAnimationFinished
mSize
)
;
if
(
aState
.
IsDiscarded
(
)
|
|
!
result
)
{
if
(
!
ret
.
mDirtyRect
.
IsEmpty
(
)
)
{
ret
.
mFrameAdvanced
=
true
;
}
return
ret
;
}
Maybe
<
TimeStamp
>
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
result
.
Surface
(
)
)
;
if
(
currentFrameEndTime
.
isNothing
(
)
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
ImageMemAnimatedDiscardable
(
)
)
;
MOZ_ASSERT
(
aState
.
GetHasRequestedDecode
(
)
&
&
!
aState
.
GetIsCurrentlyDecoded
(
)
)
;
MOZ_ASSERT
(
aState
.
mCompositedFrameInvalid
)
;
return
ret
;
}
while
(
*
currentFrameEndTime
<
=
aTime
)
{
TimeStamp
oldFrameEndTime
=
*
currentFrameEndTime
;
RefreshResult
frameRes
=
AdvanceFrame
(
aState
result
.
Surface
(
)
aTime
)
;
ret
.
Accumulate
(
frameRes
)
;
currentFrameEndTime
=
GetCurrentImgFrameEndTime
(
aState
result
.
Surface
(
)
)
;
MOZ_ASSERT
(
currentFrameEndTime
.
isSome
(
)
)
;
if
(
!
frameRes
.
mFrameAdvanced
&
&
(
*
currentFrameEndTime
=
=
oldFrameEndTime
)
)
{
break
;
}
}
if
(
*
currentFrameEndTime
>
aTime
)
{
aState
.
mCompositedFrameInvalid
=
false
;
ret
.
mDirtyRect
=
IntRect
(
IntPoint
(
0
0
)
mSize
)
;
}
MOZ_ASSERT
(
!
aState
.
mIsCurrentlyDecoded
|
|
!
aState
.
mCompositedFrameInvalid
)
;
return
ret
;
}
LookupResult
FrameAnimator
:
:
GetCompositedFrame
(
AnimationState
&
aState
)
{
LookupResult
result
=
SurfaceCache
:
:
Lookup
(
ImageKey
(
mImage
)
RasterSurfaceKey
(
mSize
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eAnimated
)
)
;
if
(
aState
.
mCompositedFrameInvalid
)
{
MOZ_ASSERT
(
gfxPrefs
:
:
ImageMemAnimatedDiscardable
(
)
)
;
MOZ_ASSERT
(
aState
.
GetHasRequestedDecode
(
)
)
;
MOZ_ASSERT
(
!
aState
.
GetIsCurrentlyDecoded
(
)
)
;
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
)
{
return
result
;
}
return
LookupResult
(
MatchType
:
:
PENDING
)
;
}
if
(
mLastCompositedFrameIndex
>
=
0
&
&
(
uint32_t
(
mLastCompositedFrameIndex
)
=
=
aState
.
mCurrentAnimationFrameIndex
)
)
{
return
LookupResult
(
DrawableSurface
(
mCompositingFrame
-
>
DrawableRef
(
)
)
MatchType
:
:
EXACT
)
;
}
if
(
!
result
)
{
return
result
;
}
if
(
NS_FAILED
(
result
.
Surface
(
)
.
Seek
(
aState
.
mCurrentAnimationFrameIndex
)
)
)
{
if
(
result
.
Type
(
)
=
=
MatchType
:
:
NOT_FOUND
)
{
return
result
;
}
return
LookupResult
(
MatchType
:
:
PENDING
)
;
}
MOZ_ASSERT
(
!
result
.
Surface
(
)
-
>
GetIsPaletted
(
)
"
About
to
return
a
paletted
frame
"
)
;
return
result
;
}
Maybe
<
FrameTimeout
>
FrameAnimator
:
:
GetTimeoutForFrame
(
AnimationState
&
aState
DrawableSurface
&
aFrames
uint32_t
aFrameNum
)
const
{
RawAccessFrameRef
frame
=
GetRawFrame
(
aFrames
aFrameNum
)
;
if
(
frame
)
{
AnimationData
data
=
frame
-
>
GetAnimationData
(
)
;
return
Some
(
data
.
mTimeout
)
;
}
MOZ_ASSERT
(
aState
.
mHasRequestedDecode
&
&
!
aState
.
mIsCurrentlyDecoded
)
;
return
Nothing
(
)
;
}
static
void
DoCollectSizeOfCompositingSurfaces
(
const
RawAccessFrameRef
&
aSurface
SurfaceMemoryCounterType
aType
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
{
SurfaceKey
key
=
RasterSurfaceKey
(
aSurface
-
>
GetImageSize
(
)
DefaultSurfaceFlags
(
)
PlaybackType
:
:
eStatic
)
;
SurfaceMemoryCounter
counter
(
key
true
false
false
aType
)
;
size_t
heap
=
0
nonHeap
=
0
handles
=
0
;
aSurface
-
>
AddSizeOfExcludingThis
(
aMallocSizeOf
heap
nonHeap
handles
)
;
counter
.
Values
(
)
.
SetDecodedHeap
(
heap
)
;
counter
.
Values
(
)
.
SetDecodedNonHeap
(
nonHeap
)
;
counter
.
Values
(
)
.
SetExternalHandles
(
handles
)
;
aCounters
.
AppendElement
(
counter
)
;
}
void
FrameAnimator
:
:
CollectSizeOfCompositingSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
{
if
(
mCompositingFrame
)
{
DoCollectSizeOfCompositingSurfaces
(
mCompositingFrame
SurfaceMemoryCounterType
:
:
COMPOSITING
aCounters
aMallocSizeOf
)
;
}
if
(
mCompositingPrevFrame
)
{
DoCollectSizeOfCompositingSurfaces
(
mCompositingPrevFrame
SurfaceMemoryCounterType
:
:
COMPOSITING_PREV
aCounters
aMallocSizeOf
)
;
}
}
RawAccessFrameRef
FrameAnimator
:
:
GetRawFrame
(
DrawableSurface
&
aFrames
uint32_t
aFrameNum
)
const
{
if
(
NS_FAILED
(
aFrames
.
Seek
(
aFrameNum
)
)
)
{
return
RawAccessFrameRef
(
)
;
}
return
aFrames
-
>
RawAccessRef
(
)
;
}
bool
FrameAnimator
:
:
DoBlend
(
DrawableSurface
&
aFrames
IntRect
*
aDirtyRect
uint32_t
aPrevFrameIndex
uint32_t
aNextFrameIndex
)
{
RawAccessFrameRef
prevFrame
=
GetRawFrame
(
aFrames
aPrevFrameIndex
)
;
RawAccessFrameRef
nextFrame
=
GetRawFrame
(
aFrames
aNextFrameIndex
)
;
MOZ_ASSERT
(
prevFrame
&
&
nextFrame
"
Should
have
frames
here
"
)
;
AnimationData
prevFrameData
=
prevFrame
-
>
GetAnimationData
(
)
;
if
(
prevFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
&
&
!
mCompositingPrevFrame
)
{
prevFrameData
.
mDisposalMethod
=
DisposalMethod
:
:
CLEAR
;
}
IntRect
prevRect
=
prevFrameData
.
mBlendRect
?
prevFrameData
.
mRect
.
Intersect
(
*
prevFrameData
.
mBlendRect
)
:
prevFrameData
.
mRect
;
bool
isFullPrevFrame
=
prevRect
.
IsEqualRect
(
0
0
mSize
.
width
mSize
.
height
)
;
if
(
isFullPrevFrame
&
&
(
prevFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR
)
)
{
prevFrameData
.
mDisposalMethod
=
DisposalMethod
:
:
CLEAR_ALL
;
}
AnimationData
nextFrameData
=
nextFrame
-
>
GetAnimationData
(
)
;
IntRect
nextRect
=
nextFrameData
.
mBlendRect
?
nextFrameData
.
mRect
.
Intersect
(
*
nextFrameData
.
mBlendRect
)
:
nextFrameData
.
mRect
;
bool
isFullNextFrame
=
nextRect
.
IsEqualRect
(
0
0
mSize
.
width
mSize
.
height
)
;
if
(
!
nextFrame
-
>
GetIsPaletted
(
)
)
{
if
(
prevFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
CLEAR_ALL
)
{
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
return
true
;
}
if
(
isFullNextFrame
&
&
(
nextFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
&
&
!
nextFrameData
.
mHasAlpha
)
{
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
return
true
;
}
}
switch
(
prevFrameData
.
mDisposalMethod
)
{
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
NOT_SPECIFIED
:
case
DisposalMethod
:
:
KEEP
:
*
aDirtyRect
=
nextRect
;
break
;
case
DisposalMethod
:
:
CLEAR_ALL
:
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
break
;
case
DisposalMethod
:
:
CLEAR
:
aDirtyRect
-
>
UnionRect
(
nextRect
prevRect
)
;
break
;
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
aDirtyRect
-
>
SetRect
(
0
0
mSize
.
width
mSize
.
height
)
;
break
;
}
if
(
mLastCompositedFrameIndex
=
=
int32_t
(
aNextFrameIndex
)
)
{
return
true
;
}
bool
needToBlankComposite
=
false
;
if
(
!
mCompositingFrame
)
{
RefPtr
<
imgFrame
>
newFrame
=
new
imgFrame
;
nsresult
rv
=
newFrame
-
>
InitForAnimator
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCompositingFrame
.
reset
(
)
;
return
false
;
}
mCompositingFrame
=
newFrame
-
>
RawAccessRef
(
)
;
needToBlankComposite
=
true
;
}
else
if
(
int32_t
(
aNextFrameIndex
)
!
=
mLastCompositedFrameIndex
+
1
)
{
needToBlankComposite
=
true
;
}
AnimationData
compositingFrameData
=
mCompositingFrame
-
>
GetAnimationData
(
)
;
bool
doDisposal
=
true
;
if
(
!
nextFrameData
.
mHasAlpha
&
&
nextFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
if
(
isFullNextFrame
)
{
doDisposal
=
false
;
needToBlankComposite
=
false
;
}
else
{
if
(
(
prevRect
.
X
(
)
>
=
nextRect
.
X
(
)
)
&
&
(
prevRect
.
Y
(
)
>
=
nextRect
.
Y
(
)
)
&
&
(
prevRect
.
XMost
(
)
<
=
nextRect
.
XMost
(
)
)
&
&
(
prevRect
.
YMost
(
)
<
=
nextRect
.
YMost
(
)
)
)
{
doDisposal
=
false
;
}
}
}
if
(
doDisposal
)
{
switch
(
prevFrameData
.
mDisposalMethod
)
{
case
DisposalMethod
:
:
CLEAR
:
if
(
needToBlankComposite
)
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
else
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
prevRect
)
;
}
break
;
case
DisposalMethod
:
:
CLEAR_ALL
:
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
break
;
case
DisposalMethod
:
:
RESTORE_PREVIOUS
:
if
(
mCompositingPrevFrame
)
{
AnimationData
compositingPrevFrameData
=
mCompositingPrevFrame
-
>
GetAnimationData
(
)
;
CopyFrameImage
(
compositingPrevFrameData
.
mRawData
compositingPrevFrameData
.
mRect
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
if
(
nextFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
{
mCompositingPrevFrame
.
reset
(
)
;
}
}
else
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unexpected
DisposalMethod
"
)
;
case
DisposalMethod
:
:
NOT_SPECIFIED
:
case
DisposalMethod
:
:
KEEP
:
if
(
mLastCompositedFrameIndex
!
=
int32_t
(
aNextFrameIndex
-
1
)
)
{
if
(
isFullPrevFrame
&
&
!
prevFrame
-
>
GetIsPaletted
(
)
)
{
CopyFrameImage
(
prevFrameData
.
mRawData
prevRect
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
else
{
if
(
needToBlankComposite
)
{
if
(
prevFrameData
.
mHasAlpha
|
|
!
isFullPrevFrame
)
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
}
DrawFrameTo
(
prevFrameData
.
mRawData
prevFrameData
.
mRect
prevFrameData
.
mPaletteDataLength
prevFrameData
.
mHasAlpha
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
prevFrameData
.
mBlendMethod
prevFrameData
.
mBlendRect
)
;
}
}
}
}
else
if
(
needToBlankComposite
)
{
ClearFrame
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
)
;
}
if
(
(
nextFrameData
.
mDisposalMethod
=
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
&
&
(
prevFrameData
.
mDisposalMethod
!
=
DisposalMethod
:
:
RESTORE_PREVIOUS
)
)
{
if
(
!
mCompositingPrevFrame
)
{
RefPtr
<
imgFrame
>
newFrame
=
new
imgFrame
;
nsresult
rv
=
newFrame
-
>
InitForAnimator
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCompositingPrevFrame
.
reset
(
)
;
return
false
;
}
mCompositingPrevFrame
=
newFrame
-
>
RawAccessRef
(
)
;
}
AnimationData
compositingPrevFrameData
=
mCompositingPrevFrame
-
>
GetAnimationData
(
)
;
CopyFrameImage
(
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
compositingPrevFrameData
.
mRawData
compositingPrevFrameData
.
mRect
)
;
mCompositingPrevFrame
-
>
Finish
(
)
;
}
DrawFrameTo
(
nextFrameData
.
mRawData
nextFrameData
.
mRect
nextFrameData
.
mPaletteDataLength
nextFrameData
.
mHasAlpha
compositingFrameData
.
mRawData
compositingFrameData
.
mRect
nextFrameData
.
mBlendMethod
nextFrameData
.
mBlendRect
)
;
mCompositingFrame
-
>
Finish
(
)
;
mLastCompositedFrameIndex
=
int32_t
(
aNextFrameIndex
)
;
return
true
;
}
void
FrameAnimator
:
:
ClearFrame
(
uint8_t
*
aFrameData
const
IntRect
&
aFrameRect
)
{
if
(
!
aFrameData
)
{
return
;
}
memset
(
aFrameData
0
aFrameRect
.
Width
(
)
*
aFrameRect
.
Height
(
)
*
4
)
;
}
void
FrameAnimator
:
:
ClearFrame
(
uint8_t
*
aFrameData
const
IntRect
&
aFrameRect
const
IntRect
&
aRectToClear
)
{
if
(
!
aFrameData
|
|
aFrameRect
.
Width
(
)
<
=
0
|
|
aFrameRect
.
Height
(
)
<
=
0
|
|
aRectToClear
.
Width
(
)
<
=
0
|
|
aRectToClear
.
Height
(
)
<
=
0
)
{
return
;
}
IntRect
toClear
=
aFrameRect
.
Intersect
(
aRectToClear
)
;
if
(
toClear
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
bytesPerRow
=
aFrameRect
.
Width
(
)
*
4
;
for
(
int
row
=
toClear
.
Y
(
)
;
row
<
toClear
.
YMost
(
)
;
+
+
row
)
{
memset
(
aFrameData
+
toClear
.
X
(
)
*
4
+
row
*
bytesPerRow
0
toClear
.
Width
(
)
*
4
)
;
}
}
bool
FrameAnimator
:
:
CopyFrameImage
(
const
uint8_t
*
aDataSrc
const
IntRect
&
aRectSrc
uint8_t
*
aDataDest
const
IntRect
&
aRectDest
)
{
uint32_t
dataLengthSrc
=
aRectSrc
.
Width
(
)
*
aRectSrc
.
Height
(
)
*
4
;
uint32_t
dataLengthDest
=
aRectDest
.
Width
(
)
*
aRectDest
.
Height
(
)
*
4
;
if
(
!
aDataDest
|
|
!
aDataSrc
|
|
dataLengthSrc
!
=
dataLengthDest
)
{
return
false
;
}
memcpy
(
aDataDest
aDataSrc
dataLengthDest
)
;
return
true
;
}
nsresult
FrameAnimator
:
:
DrawFrameTo
(
const
uint8_t
*
aSrcData
const
IntRect
&
aSrcRect
uint32_t
aSrcPaletteLength
bool
aSrcHasAlpha
uint8_t
*
aDstPixels
const
IntRect
&
aDstRect
BlendMethod
aBlendMethod
const
Maybe
<
IntRect
>
&
aBlendRect
)
{
NS_ENSURE_ARG_POINTER
(
aSrcData
)
;
NS_ENSURE_ARG_POINTER
(
aDstPixels
)
;
if
(
aSrcRect
.
X
(
)
<
0
|
|
aSrcRect
.
Y
(
)
<
0
)
{
NS_WARNING
(
"
FrameAnimator
:
:
DrawFrameTo
:
negative
offsets
not
allowed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
(
aSrcRect
.
X
(
)
>
aDstRect
.
Width
(
)
)
|
|
(
aSrcRect
.
Y
(
)
>
aDstRect
.
Height
(
)
)
)
{
return
NS_OK
;
}
if
(
aSrcPaletteLength
)
{
int32_t
width
=
std
:
:
min
(
aSrcRect
.
Width
(
)
aDstRect
.
Width
(
)
-
aSrcRect
.
X
(
)
)
;
int32_t
height
=
std
:
:
min
(
aSrcRect
.
Height
(
)
aDstRect
.
Height
(
)
-
aSrcRect
.
Y
(
)
)
;
NS_ASSERTION
(
(
aSrcRect
.
X
(
)
>
=
0
)
&
&
(
aSrcRect
.
Y
(
)
>
=
0
)
&
&
(
aSrcRect
.
X
(
)
+
width
<
=
aDstRect
.
Width
(
)
)
&
&
(
aSrcRect
.
Y
(
)
+
height
<
=
aDstRect
.
Height
(
)
)
"
FrameAnimator
:
:
DrawFrameTo
:
Invalid
aSrcRect
"
)
;
NS_ASSERTION
(
(
width
<
=
aSrcRect
.
Width
(
)
)
&
&
(
height
<
=
aSrcRect
.
Height
(
)
)
"
FrameAnimator
:
:
DrawFrameTo
:
source
must
be
smaller
than
dest
"
)
;
const
uint8_t
*
srcPixels
=
aSrcData
+
aSrcPaletteLength
;
uint32_t
*
dstPixels
=
reinterpret_cast
<
uint32_t
*
>
(
aDstPixels
)
;
const
uint32_t
*
colormap
=
reinterpret_cast
<
const
uint32_t
*
>
(
aSrcData
)
;
dstPixels
+
=
aSrcRect
.
X
(
)
+
(
aSrcRect
.
Y
(
)
*
aDstRect
.
Width
(
)
)
;
if
(
!
aSrcHasAlpha
)
{
for
(
int32_t
r
=
height
;
r
>
0
;
-
-
r
)
{
for
(
int32_t
c
=
0
;
c
<
width
;
c
+
+
)
{
dstPixels
[
c
]
=
colormap
[
srcPixels
[
c
]
]
;
}
srcPixels
+
=
aSrcRect
.
Width
(
)
;
dstPixels
+
=
aDstRect
.
Width
(
)
;
}
}
else
{
for
(
int32_t
r
=
height
;
r
>
0
;
-
-
r
)
{
for
(
int32_t
c
=
0
;
c
<
width
;
c
+
+
)
{
const
uint32_t
color
=
colormap
[
srcPixels
[
c
]
]
;
if
(
color
)
{
dstPixels
[
c
]
=
color
;
}
}
srcPixels
+
=
aSrcRect
.
Width
(
)
;
dstPixels
+
=
aDstRect
.
Width
(
)
;
}
}
}
else
{
pixman_image_t
*
src
=
pixman_image_create_bits
(
aSrcHasAlpha
?
PIXMAN_a8r8g8b8
:
PIXMAN_x8r8g8b8
aSrcRect
.
Width
(
)
aSrcRect
.
Height
(
)
reinterpret_cast
<
uint32_t
*
>
(
const_cast
<
uint8_t
*
>
(
aSrcData
)
)
aSrcRect
.
Width
(
)
*
4
)
;
if
(
!
src
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
pixman_image_t
*
dst
=
pixman_image_create_bits
(
PIXMAN_a8r8g8b8
aDstRect
.
Width
(
)
aDstRect
.
Height
(
)
reinterpret_cast
<
uint32_t
*
>
(
aDstPixels
)
aDstRect
.
Width
(
)
*
4
)
;
if
(
!
dst
)
{
pixman_image_unref
(
src
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
auto
op
=
aBlendMethod
=
=
BlendMethod
:
:
SOURCE
?
PIXMAN_OP_SRC
:
PIXMAN_OP_OVER
;
if
(
aBlendMethod
=
=
BlendMethod
:
:
OVER
|
|
!
aBlendRect
|
|
(
aBlendMethod
=
=
BlendMethod
:
:
SOURCE
&
&
aSrcRect
.
IsEqualEdges
(
*
aBlendRect
)
)
)
{
pixman_image_composite32
(
op
src
nullptr
dst
0
0
0
0
aSrcRect
.
X
(
)
aSrcRect
.
Y
(
)
aSrcRect
.
Width
(
)
aSrcRect
.
Height
(
)
)
;
}
else
{
pixman_image_composite32
(
PIXMAN_OP_OVER
src
nullptr
dst
0
0
0
0
aSrcRect
.
X
(
)
aSrcRect
.
Y
(
)
aSrcRect
.
Width
(
)
aSrcRect
.
Height
(
)
)
;
pixman_image_composite32
(
PIXMAN_OP_SRC
src
nullptr
dst
aBlendRect
-
>
X
(
)
aBlendRect
-
>
Y
(
)
0
0
aBlendRect
-
>
X
(
)
aBlendRect
-
>
Y
(
)
aBlendRect
-
>
Width
(
)
aBlendRect
-
>
Height
(
)
)
;
}
pixman_image_unref
(
src
)
;
pixman_image_unref
(
dst
)
;
}
return
NS_OK
;
}
}
}
