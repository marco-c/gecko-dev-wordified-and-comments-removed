#
ifndef
mozilla_image_Downscaler_h
#
define
mozilla_image_Downscaler_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsRect
.
h
"
namespace
skia
{
class
ConvolutionFilter1D
;
}
namespace
mozilla
{
namespace
image
{
struct
DownscalerInvalidRect
{
nsIntRect
mOriginalSizeRect
;
nsIntRect
mTargetSizeRect
;
}
;
#
ifdef
MOZ_ENABLE_SKIA
class
Downscaler
{
public
:
explicit
Downscaler
(
const
nsIntSize
&
aTargetSize
)
;
~
Downscaler
(
)
;
const
nsIntSize
&
OriginalSize
(
)
const
{
return
mOriginalSize
;
}
const
nsIntSize
&
TargetSize
(
)
const
{
return
mTargetSize
;
}
const
nsIntSize
FrameSize
(
)
const
{
return
nsIntSize
(
mFrameRect
.
width
mFrameRect
.
height
)
;
}
const
gfxSize
&
Scale
(
)
const
{
return
mScale
;
}
nsresult
BeginFrame
(
const
nsIntSize
&
aOriginalSize
const
Maybe
<
nsIntRect
>
&
aFrameRect
uint8_t
*
aOutputBuffer
bool
aHasAlpha
bool
aFlipVertically
=
false
)
;
bool
IsFrameComplete
(
)
const
{
return
mCurrentInLine
>
=
mOriginalSize
.
height
;
}
uint8_t
*
RowBuffer
(
)
{
return
mRowBuffer
.
get
(
)
+
mFrameRect
.
x
*
sizeof
(
uint32_t
)
;
}
void
ClearRow
(
)
{
ClearRestOfRow
(
0
)
;
}
void
ClearRestOfRow
(
uint32_t
aStartingAtCol
)
;
void
CommitRow
(
)
;
bool
HasInvalidation
(
)
const
;
DownscalerInvalidRect
TakeInvalidRect
(
)
;
void
ResetForNextProgressivePass
(
)
;
private
:
void
DownscaleInputLine
(
)
;
void
ReleaseWindow
(
)
;
void
SkipToRow
(
int32_t
aRow
)
;
nsIntSize
mOriginalSize
;
nsIntSize
mTargetSize
;
nsIntRect
mFrameRect
;
gfxSize
mScale
;
uint8_t
*
mOutputBuffer
;
UniquePtr
<
uint8_t
[
]
>
mRowBuffer
;
UniquePtr
<
uint8_t
*
[
]
>
mWindow
;
UniquePtr
<
skia
:
:
ConvolutionFilter1D
>
mXFilter
;
UniquePtr
<
skia
:
:
ConvolutionFilter1D
>
mYFilter
;
int32_t
mWindowCapacity
;
int32_t
mLinesInBuffer
;
int32_t
mPrevInvalidatedLine
;
int32_t
mCurrentOutLine
;
int32_t
mCurrentInLine
;
bool
mHasAlpha
:
1
;
bool
mFlipVertically
:
1
;
}
;
#
else
class
Downscaler
{
public
:
explicit
Downscaler
(
const
nsIntSize
&
)
{
MOZ_RELEASE_ASSERT
(
false
"
Skia
is
not
enabled
"
)
;
}
const
nsIntSize
&
OriginalSize
(
)
const
{
return
nsIntSize
(
)
;
}
const
nsIntSize
&
TargetSize
(
)
const
{
return
nsIntSize
(
)
;
}
const
gfxSize
&
Scale
(
)
const
{
return
gfxSize
(
1
.
0
1
.
0
)
;
}
nsresult
BeginFrame
(
const
nsIntSize
&
const
Maybe
<
nsIntRect
>
&
uint8_t
*
bool
bool
=
false
)
{
return
NS_ERROR_FAILURE
;
}
bool
IsFrameComplete
(
)
const
{
return
false
;
}
uint8_t
*
RowBuffer
(
)
{
return
nullptr
;
}
void
ClearRow
(
)
{
}
void
ClearRestOfRow
(
uint32_t
)
{
}
void
CommitRow
(
)
{
}
bool
HasInvalidation
(
)
const
{
return
false
;
}
DownscalerInvalidRect
TakeInvalidRect
(
)
{
return
DownscalerInvalidRect
(
)
;
}
void
ResetForNextProgressivePass
(
)
{
}
const
nsIntSize
FrameSize
(
)
const
{
return
nsIntSize
(
0
0
)
;
}
}
;
#
endif
}
}
#
endif
