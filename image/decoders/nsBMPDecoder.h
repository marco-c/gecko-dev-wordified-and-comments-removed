#
ifndef
mozilla_image_decoders_nsBMPDecoder_h
#
define
mozilla_image_decoders_nsBMPDecoder_h
#
include
"
BMPFileHeaders
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
gfxColor
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
StreamingLexer
.
h
"
namespace
mozilla
{
namespace
image
{
namespace
bmp
{
struct
ColorTableEntry
{
uint8_t
mRed
;
uint8_t
mGreen
;
uint8_t
mBlue
;
}
;
struct
BitFields
{
uint32_t
red
;
uint32_t
green
;
uint32_t
blue
;
uint8_t
redLeftShift
;
uint8_t
redRightShift
;
uint8_t
greenLeftShift
;
uint8_t
greenRightShift
;
uint8_t
blueLeftShift
;
uint8_t
blueRightShift
;
static
const
size_t
LENGTH
=
12
;
}
;
}
class
RasterImage
;
class
nsBMPDecoder
:
public
Decoder
{
public
:
~
nsBMPDecoder
(
)
;
void
SetUseAlphaData
(
bool
useAlphaData
)
;
int32_t
GetBitsPerPixel
(
)
const
;
int32_t
GetWidth
(
)
const
;
int32_t
GetHeight
(
)
const
;
uint32_t
*
GetImageData
(
)
;
size_t
GetImageDataLength
(
)
const
{
return
mImageDataLength
;
}
int32_t
GetCompressedImageSize
(
)
const
;
bool
HasAlphaData
(
)
const
{
return
mHaveAlphaData
;
}
void
SetHasAlphaData
(
)
{
mHaveAlphaData
=
true
;
}
virtual
void
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
override
;
virtual
void
FinishInternal
(
)
override
;
private
:
friend
class
DecoderFactory
;
friend
class
nsICODecoder
;
explicit
nsBMPDecoder
(
RasterImage
*
aImage
)
;
void
CalcBitShift
(
)
;
void
DoReadBitfields
(
const
char
*
aData
)
;
uint32_t
*
RowBuffer
(
)
;
void
FinishRow
(
)
;
enum
class
State
{
FILE_HEADER
INFO_HEADER_SIZE
INFO_HEADER_REST
BITFIELDS
COLOR_TABLE
GAP
PIXEL_ROW
RLE_SEGMENT
RLE_DELTA
RLE_ABSOLUTE
SUCCESS
FAILURE
}
;
LexerTransition
<
State
>
ReadFileHeader
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadInfoHeaderSize
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadInfoHeaderRest
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadBitfields
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadColorTable
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
SkipGap
(
)
;
LexerTransition
<
State
>
ReadPixelRow
(
const
char
*
aData
)
;
LexerTransition
<
State
>
ReadRLESegment
(
const
char
*
aData
)
;
LexerTransition
<
State
>
ReadRLEDelta
(
const
char
*
aData
)
;
LexerTransition
<
State
>
ReadRLEAbsolute
(
const
char
*
aData
size_t
aLength
)
;
StreamingLexer
<
State
>
mLexer
;
bmp
:
:
FileHeader
mBFH
;
bmp
:
:
V5InfoHeader
mBIH
;
bmp
:
:
BitFields
mBitFields
;
uint32_t
mNumColors
;
bmp
:
:
ColorTableEntry
*
mColors
;
uint32_t
mBytesPerColor
;
uint32_t
mPreGapLength
;
uint32_t
mPixelRowSize
;
int32_t
mCurrentRow
;
int32_t
mCurrentPos
;
uint32_t
mAbsoluteModeNumPixels
;
bool
mUseAlphaData
;
bool
mHaveAlphaData
;
}
;
static
inline
void
SetPixel
(
uint32_t
*
&
aDecoded
uint8_t
aRed
uint8_t
aGreen
uint8_t
aBlue
uint8_t
aAlpha
=
0xFF
)
{
*
aDecoded
+
+
=
gfxPackedPixel
(
aAlpha
aRed
aGreen
aBlue
)
;
}
static
inline
void
SetPixel
(
uint32_t
*
&
aDecoded
uint8_t
idx
bmp
:
:
ColorTableEntry
*
aColors
)
{
SetPixel
(
aDecoded
aColors
[
idx
]
.
mRed
aColors
[
idx
]
.
mGreen
aColors
[
idx
]
.
mBlue
)
;
}
inline
void
Set4BitPixel
(
uint32_t
*
&
aDecoded
uint8_t
aData
uint32_t
&
aCount
bmp
:
:
ColorTableEntry
*
aColors
)
{
uint8_t
idx
=
aData
>
>
4
;
SetPixel
(
aDecoded
idx
aColors
)
;
if
(
-
-
aCount
>
0
)
{
idx
=
aData
&
0xF
;
SetPixel
(
aDecoded
idx
aColors
)
;
-
-
aCount
;
}
}
}
}
#
endif
