#
ifndef
mozilla_image_decoders_nsBMPDecoder_h
#
define
mozilla_image_decoders_nsBMPDecoder_h
#
include
"
BMPFileHeaders
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
gfxColor
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
StreamingLexer
.
h
"
namespace
mozilla
{
namespace
image
{
namespace
bmp
{
struct
ColorTableEntry
{
uint8_t
mRed
;
uint8_t
mGreen
;
uint8_t
mBlue
;
}
;
class
BitFields
{
class
Value
{
friend
class
BitFields
;
uint32_t
mMask
;
uint8_t
mRightShift
;
uint8_t
mBitWidth
;
void
Set
(
uint32_t
aMask
)
;
public
:
uint8_t
Get
(
uint32_t
aVal
)
const
;
uint8_t
Get5
(
uint32_t
aVal
)
const
;
}
;
public
:
Value
mRed
;
Value
mGreen
;
Value
mBlue
;
void
SetR5G5B5
(
)
;
bool
IsR5G5B5
(
)
const
;
void
ReadFromHeader
(
const
char
*
aData
)
;
static
const
size_t
LENGTH
=
12
;
}
;
}
class
RasterImage
;
class
nsBMPDecoder
:
public
Decoder
{
public
:
~
nsBMPDecoder
(
)
;
void
SetUseAlphaData
(
bool
useAlphaData
)
;
int32_t
GetBitsPerPixel
(
)
const
;
int32_t
GetWidth
(
)
const
;
int32_t
GetHeight
(
)
const
;
uint32_t
*
GetImageData
(
)
;
size_t
GetImageDataLength
(
)
const
{
return
mImageDataLength
;
}
int32_t
GetCompressedImageSize
(
)
const
;
bool
HasAlphaData
(
)
const
{
return
mHaveAlphaData
;
}
void
SetHasAlphaData
(
)
{
mHaveAlphaData
=
true
;
}
virtual
void
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
override
;
virtual
void
FinishInternal
(
)
override
;
private
:
friend
class
DecoderFactory
;
friend
class
nsICODecoder
;
explicit
nsBMPDecoder
(
RasterImage
*
aImage
)
;
uint32_t
*
RowBuffer
(
)
;
void
FinishRow
(
)
;
enum
class
State
{
FILE_HEADER
INFO_HEADER_SIZE
INFO_HEADER_REST
BITFIELDS
COLOR_TABLE
GAP
PIXEL_ROW
RLE_SEGMENT
RLE_DELTA
RLE_ABSOLUTE
SUCCESS
FAILURE
}
;
LexerTransition
<
State
>
ReadFileHeader
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadInfoHeaderSize
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadInfoHeaderRest
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadBitfields
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
ReadColorTable
(
const
char
*
aData
size_t
aLength
)
;
LexerTransition
<
State
>
SkipGap
(
)
;
LexerTransition
<
State
>
ReadPixelRow
(
const
char
*
aData
)
;
LexerTransition
<
State
>
ReadRLESegment
(
const
char
*
aData
)
;
LexerTransition
<
State
>
ReadRLEDelta
(
const
char
*
aData
)
;
LexerTransition
<
State
>
ReadRLEAbsolute
(
const
char
*
aData
size_t
aLength
)
;
StreamingLexer
<
State
>
mLexer
;
bmp
:
:
FileHeader
mBFH
;
bmp
:
:
V5InfoHeader
mBIH
;
bmp
:
:
BitFields
mBitFields
;
uint32_t
mNumColors
;
bmp
:
:
ColorTableEntry
*
mColors
;
uint32_t
mBytesPerColor
;
uint32_t
mPreGapLength
;
uint32_t
mPixelRowSize
;
int32_t
mCurrentRow
;
int32_t
mCurrentPos
;
uint32_t
mAbsoluteModeNumPixels
;
bool
mUseAlphaData
;
bool
mHaveAlphaData
;
}
;
}
}
#
endif
