#
include
"
nsIconDecoder
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nspr
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsError
.
h
"
#
include
"
RasterImage
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
:
:
gfx
;
using
std
:
:
min
;
namespace
mozilla
{
namespace
image
{
nsIconDecoder
:
:
nsIconDecoder
(
RasterImage
*
aImage
)
:
Decoder
(
aImage
)
mExpectedDataLength
(
0
)
mPixBytesRead
(
0
)
mState
(
iconStateStart
)
mWidth
(
-
1
)
mHeight
(
-
1
)
{
}
nsIconDecoder
:
:
~
nsIconDecoder
(
)
{
}
void
nsIconDecoder
:
:
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
WriteInternal
after
error
!
"
)
;
while
(
aCount
>
0
)
{
switch
(
mState
)
{
case
iconStateStart
:
mWidth
=
(
uint8_t
)
*
aBuffer
;
aBuffer
+
+
;
aCount
-
-
;
mState
=
iconStateHaveHeight
;
break
;
case
iconStateHaveHeight
:
mHeight
=
(
uint8_t
)
*
aBuffer
;
PostSize
(
mWidth
mHeight
)
;
PostHasTransparency
(
)
;
if
(
HasError
(
)
)
{
mState
=
iconStateFinished
;
return
;
}
if
(
IsMetadataDecode
(
)
)
{
mState
=
iconStateFinished
;
break
;
}
mExpectedDataLength
=
mWidth
*
mHeight
*
4
;
{
MOZ_ASSERT
(
!
mImageData
"
Already
have
a
buffer
allocated
?
"
)
;
IntSize
targetSize
=
mDownscaler
?
mDownscaler
-
>
TargetSize
(
)
:
GetSize
(
)
;
nsresult
rv
=
AllocateFrame
(
0
targetSize
IntRect
(
IntPoint
(
)
targetSize
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
mState
=
iconStateFinished
;
return
;
}
}
MOZ_ASSERT
(
mImageData
"
Should
have
a
buffer
now
"
)
;
if
(
mDownscaler
)
{
nsresult
rv
=
mDownscaler
-
>
BeginFrame
(
GetSize
(
)
Nothing
(
)
mImageData
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
mState
=
iconStateFinished
;
return
;
}
}
aBuffer
+
+
;
aCount
-
-
;
mState
=
iconStateReadPixels
;
break
;
case
iconStateReadPixels
:
{
uint32_t
bytesToRead
=
min
(
aCount
mExpectedDataLength
-
mPixBytesRead
)
;
if
(
mDownscaler
)
{
uint8_t
*
row
=
mDownscaler
-
>
RowBuffer
(
)
;
const
uint32_t
bytesPerRow
=
mWidth
*
4
;
const
uint32_t
rowOffset
=
mPixBytesRead
%
bytesPerRow
;
aCount
-
=
bytesToRead
;
mPixBytesRead
+
=
bytesToRead
;
if
(
rowOffset
>
0
)
{
const
uint32_t
remaining
=
bytesPerRow
-
rowOffset
;
memcpy
(
row
+
rowOffset
aBuffer
remaining
)
;
aBuffer
+
=
remaining
;
bytesToRead
-
=
remaining
;
mDownscaler
-
>
CommitRow
(
)
;
}
while
(
bytesToRead
>
bytesPerRow
)
{
memcpy
(
row
aBuffer
bytesPerRow
)
;
aBuffer
+
=
bytesPerRow
;
bytesToRead
-
=
bytesPerRow
;
mDownscaler
-
>
CommitRow
(
)
;
}
if
(
bytesToRead
>
0
)
{
memcpy
(
row
aBuffer
bytesToRead
)
;
aBuffer
+
=
bytesPerRow
;
bytesToRead
-
=
bytesPerRow
;
}
if
(
mDownscaler
-
>
HasInvalidation
(
)
)
{
DownscalerInvalidRect
invalidRect
=
mDownscaler
-
>
TakeInvalidRect
(
)
;
PostInvalidation
(
invalidRect
.
mOriginalSizeRect
Some
(
invalidRect
.
mTargetSizeRect
)
)
;
}
}
else
{
memcpy
(
mImageData
+
mPixBytesRead
aBuffer
bytesToRead
)
;
aBuffer
+
=
bytesToRead
;
aCount
-
=
bytesToRead
;
mPixBytesRead
+
=
bytesToRead
;
PostInvalidation
(
IntRect
(
0
0
mWidth
mHeight
)
)
;
}
if
(
mPixBytesRead
=
=
mExpectedDataLength
)
{
PostFrameStop
(
)
;
PostDecodeDone
(
)
;
mState
=
iconStateFinished
;
}
break
;
}
case
iconStateFinished
:
aCount
=
0
;
break
;
}
}
}
}
}
