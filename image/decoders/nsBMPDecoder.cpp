#
include
<
stdlib
.
h
>
#
include
"
ImageLogging
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Endian
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsBMPDecoder
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
RasterImage
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
image
{
namespace
bmp
{
struct
Compression
{
enum
{
RGB
=
0
RLE8
=
1
RLE4
=
2
BITFIELDS
=
3
}
;
}
;
struct
RLE
{
enum
{
ESCAPE
=
0
ESCAPE_EOL
=
0
ESCAPE_EOF
=
1
ESCAPE_DELTA
=
2
SEGMENT_LENGTH
=
2
DELTA_LENGTH
=
2
}
;
}
;
}
using
namespace
bmp
;
static
void
SetPixel
(
uint32_t
*
&
aDecoded
uint8_t
aRed
uint8_t
aGreen
uint8_t
aBlue
uint8_t
aAlpha
=
0xFF
)
{
*
aDecoded
+
+
=
gfxPackedPixel
(
aAlpha
aRed
aGreen
aBlue
)
;
}
static
void
SetPixel
(
uint32_t
*
&
aDecoded
uint8_t
idx
bmp
:
:
ColorTableEntry
*
aColors
)
{
SetPixel
(
aDecoded
aColors
[
idx
]
.
mRed
aColors
[
idx
]
.
mGreen
aColors
[
idx
]
.
mBlue
)
;
}
static
void
Set4BitPixel
(
uint32_t
*
&
aDecoded
uint8_t
aData
uint32_t
&
aCount
bmp
:
:
ColorTableEntry
*
aColors
)
{
uint8_t
idx
=
aData
>
>
4
;
SetPixel
(
aDecoded
idx
aColors
)
;
if
(
-
-
aCount
>
0
)
{
idx
=
aData
&
0xF
;
SetPixel
(
aDecoded
idx
aColors
)
;
-
-
aCount
;
}
}
static
PRLogModuleInfo
*
GetBMPLog
(
)
{
static
PRLogModuleInfo
*
sBMPLog
;
if
(
!
sBMPLog
)
{
sBMPLog
=
PR_NewLogModule
(
"
BMPDecoder
"
)
;
}
return
sBMPLog
;
}
nsBMPDecoder
:
:
nsBMPDecoder
(
RasterImage
*
aImage
)
:
Decoder
(
aImage
)
mLexer
(
Transition
:
:
To
(
State
:
:
FILE_HEADER
FileHeader
:
:
LENGTH
)
)
mMayHaveTransparency
(
false
)
mNumColors
(
0
)
mColors
(
nullptr
)
mBytesPerColor
(
0
)
mPreGapLength
(
0
)
mCurrentRow
(
0
)
mCurrentPos
(
0
)
mAbsoluteModeNumPixels
(
0
)
mUseAlphaData
(
false
)
mHaveAlphaData
(
false
)
{
memset
(
&
mBFH
0
sizeof
(
mBFH
)
)
;
memset
(
&
mBIH
0
sizeof
(
mBIH
)
)
;
}
nsBMPDecoder
:
:
~
nsBMPDecoder
(
)
{
delete
[
]
mColors
;
}
void
nsBMPDecoder
:
:
SetUseAlphaData
(
bool
useAlphaData
)
{
mUseAlphaData
=
useAlphaData
;
}
int32_t
nsBMPDecoder
:
:
GetBitsPerPixel
(
)
const
{
return
mBIH
.
bpp
;
}
int32_t
nsBMPDecoder
:
:
GetWidth
(
)
const
{
return
mBIH
.
width
;
}
int32_t
nsBMPDecoder
:
:
GetHeight
(
)
const
{
return
abs
(
mBIH
.
height
)
;
}
uint32_t
*
nsBMPDecoder
:
:
GetImageData
(
)
{
return
reinterpret_cast
<
uint32_t
*
>
(
mImageData
)
;
}
int32_t
nsBMPDecoder
:
:
GetCompressedImageSize
(
)
const
{
MOZ_ASSERT
(
mPixelRowSize
!
=
0
)
;
return
mBIH
.
compression
=
=
Compression
:
:
RGB
?
mPixelRowSize
*
GetHeight
(
)
:
mBIH
.
image_size
;
}
void
nsBMPDecoder
:
:
FinishInternal
(
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Can
'
t
call
FinishInternal
on
error
!
"
)
;
MOZ_ASSERT
(
GetFrameCount
(
)
<
=
1
"
Multiple
BMP
frames
?
"
)
;
if
(
!
IsMetadataDecode
(
)
&
&
HasSize
(
)
)
{
nsIntRect
r
(
0
0
mBIH
.
width
GetHeight
(
)
)
;
PostInvalidation
(
r
)
;
if
(
mUseAlphaData
&
&
mHaveAlphaData
)
{
PostFrameStop
(
Opacity
:
:
SOME_TRANSPARENCY
)
;
}
else
{
PostFrameStop
(
Opacity
:
:
OPAQUE
)
;
}
PostDecodeDone
(
)
;
}
}
void
BitFields
:
:
Value
:
:
Set
(
uint32_t
aMask
)
{
mMask
=
aMask
;
bool
started
=
false
;
mRightShift
=
mBitWidth
=
0
;
for
(
uint8_t
pos
=
0
;
pos
<
=
31
;
pos
+
+
)
{
if
(
!
started
&
&
(
aMask
&
(
1
<
<
pos
)
)
)
{
mRightShift
=
pos
;
started
=
true
;
}
else
if
(
started
&
&
!
(
aMask
&
(
1
<
<
pos
)
)
)
{
mBitWidth
=
pos
-
mRightShift
;
break
;
}
}
}
inline
uint8_t
BitFields
:
:
Value
:
:
Get
(
uint32_t
aValue
)
const
{
uint32_t
v
=
(
aValue
&
mMask
)
>
>
mRightShift
;
uint8_t
v2
=
0
;
int32_t
i
;
for
(
i
=
8
-
mBitWidth
;
i
>
0
;
i
-
=
mBitWidth
)
{
v2
|
=
v
<
<
uint32_t
(
i
)
;
}
v2
|
=
v
>
>
uint32_t
(
-
i
)
;
return
v2
;
}
MOZ_ALWAYS_INLINE
uint8_t
BitFields
:
:
Value
:
:
Get5
(
uint32_t
aValue
)
const
{
MOZ_ASSERT
(
mBitWidth
=
=
5
)
;
uint32_t
v
=
(
aValue
&
mMask
)
>
>
mRightShift
;
return
(
v
<
<
3u
)
|
(
v
>
>
2u
)
;
}
void
BitFields
:
:
SetR5G5B5
(
)
{
mRed
.
Set
(
0x7c00
)
;
mGreen
.
Set
(
0x03e0
)
;
mBlue
.
Set
(
0x001f
)
;
}
bool
BitFields
:
:
IsR5G5B5
(
)
const
{
return
mRed
.
mBitWidth
=
=
5
&
&
mGreen
.
mBitWidth
=
=
5
&
&
mBlue
.
mBitWidth
=
=
5
;
}
uint32_t
*
nsBMPDecoder
:
:
RowBuffer
(
)
{
if
(
mDownscaler
)
{
return
reinterpret_cast
<
uint32_t
*
>
(
mDownscaler
-
>
RowBuffer
(
)
)
+
mCurrentPos
;
}
int32_t
line
=
(
mBIH
.
height
<
0
)
?
-
mBIH
.
height
-
mCurrentRow
:
mCurrentRow
-
1
;
int32_t
offset
=
line
*
mBIH
.
width
+
mCurrentPos
;
return
reinterpret_cast
<
uint32_t
*
>
(
mImageData
)
+
offset
;
}
void
nsBMPDecoder
:
:
FinishRow
(
)
{
if
(
mDownscaler
)
{
mDownscaler
-
>
CommitRow
(
)
;
if
(
mDownscaler
-
>
HasInvalidation
(
)
)
{
DownscalerInvalidRect
invalidRect
=
mDownscaler
-
>
TakeInvalidRect
(
)
;
PostInvalidation
(
invalidRect
.
mOriginalSizeRect
Some
(
invalidRect
.
mTargetSizeRect
)
)
;
}
}
else
{
PostInvalidation
(
IntRect
(
0
mCurrentRow
mBIH
.
width
1
)
)
;
}
mCurrentRow
-
-
;
}
void
nsBMPDecoder
:
:
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
WriteInternal
after
error
!
"
)
;
MOZ_ASSERT
(
aBuffer
)
;
MOZ_ASSERT
(
aCount
>
0
)
;
Maybe
<
State
>
terminalState
=
mLexer
.
Lex
(
aBuffer
aCount
[
=
]
(
State
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
State
:
:
FILE_HEADER
:
return
ReadFileHeader
(
aData
aLength
)
;
case
State
:
:
INFO_HEADER_SIZE
:
return
ReadInfoHeaderSize
(
aData
aLength
)
;
case
State
:
:
INFO_HEADER_REST
:
return
ReadInfoHeaderRest
(
aData
aLength
)
;
case
State
:
:
BITFIELDS
:
return
ReadBitfields
(
aData
aLength
)
;
case
State
:
:
COLOR_TABLE
:
return
ReadColorTable
(
aData
aLength
)
;
case
State
:
:
GAP
:
return
SkipGap
(
)
;
case
State
:
:
PIXEL_ROW
:
return
ReadPixelRow
(
aData
)
;
case
State
:
:
RLE_SEGMENT
:
return
ReadRLESegment
(
aData
)
;
case
State
:
:
RLE_DELTA
:
return
ReadRLEDelta
(
aData
)
;
case
State
:
:
RLE_ABSOLUTE
:
return
ReadRLEAbsolute
(
aData
aLength
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
State
"
)
;
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
}
)
;
if
(
!
terminalState
)
{
return
;
}
if
(
*
terminalState
=
=
State
:
:
FAILURE
)
{
PostDataError
(
)
;
return
;
}
MOZ_ASSERT
(
*
terminalState
=
=
State
:
:
SUCCESS
)
;
return
;
}
static
const
uint32_t
BIHSIZE_FIELD_LENGTH
=
4
;
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadFileHeader
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
mBFH
.
signature
[
0
]
=
aData
[
0
]
;
mBFH
.
signature
[
1
]
=
aData
[
1
]
;
bool
signatureOk
=
mBFH
.
signature
[
0
]
=
=
'
B
'
&
&
mBFH
.
signature
[
1
]
=
=
'
M
'
;
if
(
!
signatureOk
)
{
PostDataError
(
)
;
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
mBFH
.
filesize
=
LittleEndian
:
:
readUint32
(
aData
+
2
)
;
mBFH
.
reserved
=
0
;
mBFH
.
dataoffset
=
LittleEndian
:
:
readUint32
(
aData
+
10
)
;
return
Transition
:
:
To
(
State
:
:
INFO_HEADER_SIZE
BIHSIZE_FIELD_LENGTH
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadInfoHeaderSize
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
mBIH
.
bihsize
=
LittleEndian
:
:
readUint32
(
aData
)
;
bool
bihsizeOk
=
mBIH
.
bihsize
=
=
InfoHeaderLength
:
:
WIN_V2
|
|
mBIH
.
bihsize
=
=
InfoHeaderLength
:
:
WIN_V3
|
|
mBIH
.
bihsize
=
=
InfoHeaderLength
:
:
WIN_V4
|
|
mBIH
.
bihsize
=
=
InfoHeaderLength
:
:
WIN_V5
|
|
(
mBIH
.
bihsize
>
=
InfoHeaderLength
:
:
OS2_V2_MIN
&
&
mBIH
.
bihsize
<
=
InfoHeaderLength
:
:
OS2_V2_MAX
)
;
if
(
!
bihsizeOk
)
{
PostDataError
(
)
;
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
return
Transition
:
:
To
(
State
:
:
INFO_HEADER_REST
mBIH
.
bihsize
-
BIHSIZE_FIELD_LENGTH
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadInfoHeaderRest
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
if
(
mBIH
.
bihsize
=
=
InfoHeaderLength
:
:
WIN_V2
)
{
mBIH
.
width
=
LittleEndian
:
:
readUint16
(
aData
+
0
)
;
mBIH
.
height
=
LittleEndian
:
:
readUint16
(
aData
+
2
)
;
mBIH
.
planes
=
LittleEndian
:
:
readUint16
(
aData
+
4
)
;
mBIH
.
bpp
=
LittleEndian
:
:
readUint16
(
aData
+
6
)
;
}
else
{
mBIH
.
width
=
LittleEndian
:
:
readUint32
(
aData
+
0
)
;
mBIH
.
height
=
LittleEndian
:
:
readUint32
(
aData
+
4
)
;
mBIH
.
planes
=
LittleEndian
:
:
readUint16
(
aData
+
8
)
;
mBIH
.
bpp
=
LittleEndian
:
:
readUint16
(
aData
+
10
)
;
mBIH
.
compression
=
aLength
>
=
16
?
LittleEndian
:
:
readUint32
(
aData
+
12
)
:
0
;
mBIH
.
image_size
=
aLength
>
=
20
?
LittleEndian
:
:
readUint32
(
aData
+
16
)
:
0
;
mBIH
.
xppm
=
aLength
>
=
24
?
LittleEndian
:
:
readUint32
(
aData
+
20
)
:
0
;
mBIH
.
yppm
=
aLength
>
=
28
?
LittleEndian
:
:
readUint32
(
aData
+
24
)
:
0
;
mBIH
.
colors
=
aLength
>
=
32
?
LittleEndian
:
:
readUint32
(
aData
+
28
)
:
0
;
mBIH
.
important_colors
=
aLength
>
=
36
?
LittleEndian
:
:
readUint32
(
aData
+
32
)
:
0
;
}
MOZ_LOG
(
GetBMPLog
(
)
LogLevel
:
:
Debug
(
"
BMP
:
bihsize
=
%
u
%
d
x
%
d
bpp
=
%
u
compression
=
%
u
colors
=
%
u
\
n
"
mBIH
.
bihsize
mBIH
.
width
mBIH
.
height
uint32_t
(
mBIH
.
bpp
)
mBIH
.
compression
mBIH
.
colors
)
)
;
const
int32_t
k64KWidth
=
0x0000FFFF
;
bool
sizeOk
=
0
<
=
mBIH
.
width
&
&
mBIH
.
width
<
=
k64KWidth
&
&
mBIH
.
height
!
=
INT_MIN
;
if
(
!
sizeOk
)
{
PostDataError
(
)
;
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
bool
bppCompressionOk
=
(
mBIH
.
compression
=
=
Compression
:
:
RGB
&
&
(
mBIH
.
bpp
=
=
1
|
|
mBIH
.
bpp
=
=
4
|
|
mBIH
.
bpp
=
=
8
|
|
mBIH
.
bpp
=
=
16
|
|
mBIH
.
bpp
=
=
24
|
|
mBIH
.
bpp
=
=
32
)
)
|
|
(
mBIH
.
compression
=
=
Compression
:
:
RLE8
&
&
mBIH
.
bpp
=
=
8
)
|
|
(
mBIH
.
compression
=
=
Compression
:
:
RLE4
&
&
mBIH
.
bpp
=
=
4
)
|
|
(
mBIH
.
compression
=
=
Compression
:
:
BITFIELDS
&
&
(
mBIH
.
bpp
=
=
16
|
|
mBIH
.
bpp
=
=
32
)
)
;
if
(
!
bppCompressionOk
)
{
PostDataError
(
)
;
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
uint32_t
realHeight
=
GetHeight
(
)
;
PostSize
(
mBIH
.
width
realHeight
)
;
mCurrentRow
=
realHeight
;
mPixelRowSize
=
(
mBIH
.
bpp
*
mBIH
.
width
+
7
)
/
8
;
uint32_t
surplus
=
mPixelRowSize
%
4
;
if
(
surplus
!
=
0
)
{
mPixelRowSize
+
=
4
-
surplus
;
}
mMayHaveTransparency
=
(
mBIH
.
compression
=
=
Compression
:
:
RLE8
)
|
|
(
mBIH
.
compression
=
=
Compression
:
:
RLE4
)
|
|
(
mBIH
.
bpp
=
=
32
&
&
mUseAlphaData
)
;
if
(
mMayHaveTransparency
)
{
PostHasTransparency
(
)
;
}
size_t
bitFieldsLengthStillToRead
=
0
;
if
(
mBIH
.
compression
=
=
Compression
:
:
BITFIELDS
)
{
if
(
mBIH
.
bihsize
>
=
InfoHeaderLength
:
:
WIN_V4
)
{
mBitFields
.
ReadFromHeader
(
aData
+
36
)
;
}
else
{
bitFieldsLengthStillToRead
=
BitFields
:
:
LENGTH
;
}
}
else
if
(
mBIH
.
bpp
=
=
16
)
{
mBitFields
.
SetR5G5B5
(
)
;
}
return
Transition
:
:
To
(
State
:
:
BITFIELDS
bitFieldsLengthStillToRead
)
;
}
void
BitFields
:
:
ReadFromHeader
(
const
char
*
aData
)
{
mRed
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
0
)
)
;
mGreen
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
4
)
)
;
mBlue
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
8
)
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadBitfields
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
if
(
aLength
!
=
0
)
{
mBitFields
.
ReadFromHeader
(
aData
)
;
}
if
(
IsMetadataDecode
(
)
)
{
return
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
;
}
if
(
mBIH
.
bpp
<
=
8
)
{
mNumColors
=
1
<
<
mBIH
.
bpp
;
if
(
0
<
mBIH
.
colors
&
&
mBIH
.
colors
<
mNumColors
)
{
mNumColors
=
mBIH
.
colors
;
}
mColors
=
new
ColorTableEntry
[
256
]
;
memset
(
mColors
0
256
*
sizeof
(
ColorTableEntry
)
)
;
mBytesPerColor
=
(
mBIH
.
bihsize
=
=
InfoHeaderLength
:
:
WIN_V2
)
?
3
:
4
;
}
MOZ_ASSERT
(
!
mImageData
"
Already
have
a
buffer
allocated
?
"
)
;
IntSize
targetSize
=
mDownscaler
?
mDownscaler
-
>
TargetSize
(
)
:
GetSize
(
)
;
nsresult
rv
=
AllocateFrame
(
0
targetSize
IntRect
(
IntPoint
(
)
targetSize
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
MOZ_ASSERT
(
mImageData
"
Should
have
a
buffer
now
"
)
;
if
(
mDownscaler
)
{
rv
=
mDownscaler
-
>
BeginFrame
(
GetSize
(
)
Nothing
(
)
mImageData
mMayHaveTransparency
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
}
return
Transition
:
:
To
(
State
:
:
COLOR_TABLE
mNumColors
*
mBytesPerColor
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadColorTable
(
const
char
*
aData
size_t
aLength
)
{
MOZ_ASSERT_IF
(
aLength
!
=
0
mNumColors
>
0
&
&
mColors
)
;
mPreGapLength
+
=
aLength
;
for
(
uint32_t
i
=
0
;
i
<
mNumColors
;
i
+
+
)
{
mColors
[
i
]
.
mBlue
=
uint8_t
(
aData
[
0
]
)
;
mColors
[
i
]
.
mGreen
=
uint8_t
(
aData
[
1
]
)
;
mColors
[
i
]
.
mRed
=
uint8_t
(
aData
[
2
]
)
;
aData
+
=
mBytesPerColor
;
}
if
(
mPreGapLength
>
mBFH
.
dataoffset
)
{
PostDataError
(
)
;
return
Transition
:
:
Terminate
(
State
:
:
FAILURE
)
;
}
uint32_t
gapLength
=
mBFH
.
dataoffset
-
mPreGapLength
;
return
Transition
:
:
To
(
State
:
:
GAP
gapLength
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
SkipGap
(
)
{
bool
hasRLE
=
mBIH
.
compression
=
=
Compression
:
:
RLE8
|
|
mBIH
.
compression
=
=
Compression
:
:
RLE4
;
return
hasRLE
?
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
:
Transition
:
:
To
(
State
:
:
PIXEL_ROW
mPixelRowSize
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadPixelRow
(
const
char
*
aData
)
{
MOZ_ASSERT
(
mCurrentPos
=
=
0
)
;
const
uint8_t
*
src
=
reinterpret_cast
<
const
uint8_t
*
>
(
aData
)
;
uint32_t
*
dst
=
RowBuffer
(
)
;
uint32_t
lpos
=
mBIH
.
width
;
switch
(
mBIH
.
bpp
)
{
case
1
:
while
(
lpos
>
0
)
{
int8_t
bit
;
uint8_t
idx
;
for
(
bit
=
7
;
bit
>
=
0
&
&
lpos
>
0
;
bit
-
-
)
{
idx
=
(
*
src
>
>
bit
)
&
1
;
SetPixel
(
dst
idx
mColors
)
;
-
-
lpos
;
}
+
+
src
;
}
break
;
case
4
:
while
(
lpos
>
0
)
{
Set4BitPixel
(
dst
*
src
lpos
mColors
)
;
+
+
src
;
}
break
;
case
8
:
while
(
lpos
>
0
)
{
SetPixel
(
dst
*
src
mColors
)
;
-
-
lpos
;
+
+
src
;
}
break
;
case
16
:
if
(
mBitFields
.
IsR5G5B5
(
)
)
{
while
(
lpos
>
0
)
{
uint16_t
val
=
LittleEndian
:
:
readUint16
(
src
)
;
SetPixel
(
dst
mBitFields
.
mRed
.
Get5
(
val
)
mBitFields
.
mGreen
.
Get5
(
val
)
mBitFields
.
mBlue
.
Get5
(
val
)
)
;
-
-
lpos
;
src
+
=
2
;
}
}
else
{
while
(
lpos
>
0
)
{
uint16_t
val
=
LittleEndian
:
:
readUint16
(
src
)
;
SetPixel
(
dst
mBitFields
.
mRed
.
Get
(
val
)
mBitFields
.
mGreen
.
Get
(
val
)
mBitFields
.
mBlue
.
Get
(
val
)
)
;
-
-
lpos
;
src
+
=
2
;
}
}
break
;
case
24
:
while
(
lpos
>
0
)
{
SetPixel
(
dst
src
[
2
]
src
[
1
]
src
[
0
]
)
;
-
-
lpos
;
src
+
=
3
;
}
break
;
case
32
:
while
(
lpos
>
0
)
{
if
(
mUseAlphaData
)
{
if
(
MOZ_UNLIKELY
(
!
mHaveAlphaData
&
&
src
[
3
]
)
)
{
PostHasTransparency
(
)
;
mHaveAlphaData
=
true
;
}
SetPixel
(
dst
src
[
2
]
src
[
1
]
src
[
0
]
src
[
3
]
)
;
}
else
{
SetPixel
(
dst
src
[
2
]
src
[
1
]
src
[
0
]
)
;
}
-
-
lpos
;
src
+
=
4
;
}
break
;
default
:
MOZ_CRASH
(
"
Unsupported
color
depth
;
earlier
check
didn
'
t
catch
it
?
"
)
;
}
FinishRow
(
)
;
return
mCurrentRow
=
=
0
?
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
:
Transition
:
:
To
(
State
:
:
PIXEL_ROW
mPixelRowSize
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadRLESegment
(
const
char
*
aData
)
{
if
(
mCurrentRow
=
=
0
)
{
return
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
;
}
uint8_t
byte1
=
uint8_t
(
aData
[
0
]
)
;
uint8_t
byte2
=
uint8_t
(
aData
[
1
]
)
;
if
(
byte1
!
=
RLE
:
:
ESCAPE
)
{
uint32_t
pixelsNeeded
=
std
:
:
min
<
uint32_t
>
(
mBIH
.
width
-
mCurrentPos
byte1
)
;
if
(
pixelsNeeded
)
{
uint32_t
*
dst
=
RowBuffer
(
)
;
mCurrentPos
+
=
pixelsNeeded
;
if
(
mBIH
.
compression
=
=
Compression
:
:
RLE8
)
{
do
{
SetPixel
(
dst
byte2
mColors
)
;
pixelsNeeded
-
-
;
}
while
(
pixelsNeeded
)
;
}
else
{
do
{
Set4BitPixel
(
dst
byte2
pixelsNeeded
mColors
)
;
}
while
(
pixelsNeeded
)
;
}
}
return
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
if
(
byte2
=
=
RLE
:
:
ESCAPE_EOL
)
{
mCurrentPos
=
0
;
FinishRow
(
)
;
return
mCurrentRow
=
=
0
?
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
:
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
if
(
byte2
=
=
RLE
:
:
ESCAPE_EOF
)
{
return
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
;
}
if
(
byte2
=
=
RLE
:
:
ESCAPE_DELTA
)
{
return
Transition
:
:
To
(
State
:
:
RLE_DELTA
RLE
:
:
DELTA_LENGTH
)
;
}
MOZ_ASSERT
(
mAbsoluteModeNumPixels
=
=
0
)
;
mAbsoluteModeNumPixels
=
byte2
;
uint32_t
length
=
byte2
;
if
(
mBIH
.
compression
=
=
Compression
:
:
RLE4
)
{
length
=
(
length
+
1
)
/
2
;
}
if
(
length
&
1
)
{
length
+
+
;
}
return
Transition
:
:
To
(
State
:
:
RLE_ABSOLUTE
length
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadRLEDelta
(
const
char
*
aData
)
{
if
(
MOZ_UNLIKELY
(
!
mHaveAlphaData
)
)
{
PostHasTransparency
(
)
;
mHaveAlphaData
=
true
;
}
mUseAlphaData
=
mHaveAlphaData
=
true
;
if
(
mDownscaler
)
{
mDownscaler
-
>
ClearRow
(
mCurrentPos
)
;
}
mCurrentPos
+
=
uint8_t
(
aData
[
0
]
)
;
if
(
mCurrentPos
>
mBIH
.
width
)
{
mCurrentPos
=
mBIH
.
width
;
}
int32_t
yDelta
=
std
:
:
min
<
int32_t
>
(
uint8_t
(
aData
[
1
]
)
mCurrentRow
)
;
mCurrentRow
-
=
yDelta
;
if
(
mDownscaler
&
&
yDelta
>
0
)
{
mDownscaler
-
>
CommitRow
(
)
;
for
(
int32_t
line
=
1
;
line
<
yDelta
;
line
+
+
)
{
mDownscaler
-
>
ClearRow
(
)
;
mDownscaler
-
>
CommitRow
(
)
;
}
}
return
mCurrentRow
=
=
0
?
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
:
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadRLEAbsolute
(
const
char
*
aData
size_t
aLength
)
{
uint32_t
n
=
mAbsoluteModeNumPixels
;
mAbsoluteModeNumPixels
=
0
;
if
(
mCurrentPos
+
n
>
uint32_t
(
mBIH
.
width
)
)
{
return
Transition
:
:
Terminate
(
State
:
:
SUCCESS
)
;
}
uint32_t
*
dst
=
RowBuffer
(
)
;
uint32_t
iSrc
=
0
;
uint32_t
*
oldPos
=
dst
;
if
(
mBIH
.
compression
=
=
Compression
:
:
RLE8
)
{
while
(
n
>
0
)
{
SetPixel
(
dst
aData
[
iSrc
]
mColors
)
;
n
-
-
;
iSrc
+
+
;
}
}
else
{
while
(
n
>
0
)
{
Set4BitPixel
(
dst
aData
[
iSrc
]
n
mColors
)
;
iSrc
+
+
;
}
}
mCurrentPos
+
=
dst
-
oldPos
;
MOZ_ASSERT
(
iSrc
=
=
aLength
-
1
|
|
iSrc
=
=
aLength
)
;
return
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
}
}
