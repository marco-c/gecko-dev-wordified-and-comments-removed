#
include
"
ImageLogging
.
h
"
#
include
"
nsBMPDecoder
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
RasterImage
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
image
{
namespace
bmp
{
struct
Compression
{
enum
{
RGB
=
0
RLE8
=
1
RLE4
=
2
BITFIELDS
=
3
}
;
}
;
struct
RLE
{
enum
{
ESCAPE
=
0
ESCAPE_EOL
=
0
ESCAPE_EOF
=
1
ESCAPE_DELTA
=
2
SEGMENT_LENGTH
=
2
DELTA_LENGTH
=
2
}
;
}
;
}
using
namespace
bmp
;
static
void
SetPixel
(
uint32_t
*
&
aDecoded
uint8_t
aRed
uint8_t
aGreen
uint8_t
aBlue
uint8_t
aAlpha
=
0xFF
)
{
*
aDecoded
+
+
=
gfxPackedPixel
(
aAlpha
aRed
aGreen
aBlue
)
;
}
static
void
SetPixel
(
uint32_t
*
&
aDecoded
uint8_t
idx
const
UniquePtr
<
ColorTableEntry
[
]
>
&
aColors
)
{
SetPixel
(
aDecoded
aColors
[
idx
]
.
mRed
aColors
[
idx
]
.
mGreen
aColors
[
idx
]
.
mBlue
)
;
}
static
void
Set4BitPixel
(
uint32_t
*
&
aDecoded
uint8_t
aData
uint32_t
&
aCount
const
UniquePtr
<
ColorTableEntry
[
]
>
&
aColors
)
{
uint8_t
idx
=
aData
>
>
4
;
SetPixel
(
aDecoded
idx
aColors
)
;
if
(
-
-
aCount
>
0
)
{
idx
=
aData
&
0xF
;
SetPixel
(
aDecoded
idx
aColors
)
;
-
-
aCount
;
}
}
static
mozilla
:
:
LazyLogModule
sBMPLog
(
"
BMPDecoder
"
)
;
static
const
uint32_t
BIHSIZE_FIELD_LENGTH
=
4
;
nsBMPDecoder
:
:
nsBMPDecoder
(
RasterImage
*
aImage
State
aState
size_t
aLength
bool
aForClipboard
)
:
Decoder
(
aImage
)
mLexer
(
Transition
:
:
To
(
aState
aLength
)
Transition
:
:
TerminateSuccess
(
)
)
mIsWithinICO
(
false
)
mIsForClipboard
(
aForClipboard
)
mMayHaveTransparency
(
false
)
mDoesHaveTransparency
(
false
)
mNumColors
(
0
)
mColors
(
nullptr
)
mBytesPerColor
(
0
)
mPreGapLength
(
0
)
mPixelRowSize
(
0
)
mCurrentRow
(
0
)
mCurrentPos
(
0
)
mAbsoluteModeNumPixels
(
0
)
{
}
nsBMPDecoder
:
:
nsBMPDecoder
(
RasterImage
*
aImage
bool
aForClipboard
)
:
nsBMPDecoder
(
aImage
aForClipboard
?
State
:
:
INFO_HEADER_SIZE
:
State
:
:
FILE_HEADER
aForClipboard
?
BIHSIZE_FIELD_LENGTH
:
FILE_HEADER_LENGTH
aForClipboard
)
{
}
nsBMPDecoder
:
:
nsBMPDecoder
(
RasterImage
*
aImage
uint32_t
aDataOffset
)
:
nsBMPDecoder
(
aImage
State
:
:
INFO_HEADER_SIZE
BIHSIZE_FIELD_LENGTH
false
)
{
SetIsWithinICO
(
)
;
mPreGapLength
+
=
FILE_HEADER_LENGTH
;
mH
.
mDataOffset
=
aDataOffset
;
}
nsBMPDecoder
:
:
~
nsBMPDecoder
(
)
{
}
int32_t
nsBMPDecoder
:
:
GetCompressedImageSize
(
)
const
{
MOZ_ASSERT
(
mPixelRowSize
!
=
0
)
;
return
mH
.
mCompression
=
=
Compression
:
:
RGB
?
mPixelRowSize
*
AbsoluteHeight
(
)
:
mH
.
mImageSize
;
}
nsresult
nsBMPDecoder
:
:
BeforeFinishInternal
(
)
{
if
(
!
IsMetadataDecode
(
)
&
&
!
mImageData
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
nsBMPDecoder
:
:
FinishInternal
(
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Can
'
t
call
FinishInternal
on
error
!
"
)
;
MOZ_ASSERT
(
GetFrameCount
(
)
<
=
1
"
Multiple
BMP
frames
?
"
)
;
if
(
!
IsMetadataDecode
(
)
&
&
HasSize
(
)
)
{
MOZ_ASSERT
(
mImageData
)
;
while
(
mCurrentRow
>
0
)
{
uint32_t
*
dst
=
RowBuffer
(
)
;
while
(
mCurrentPos
<
mH
.
mWidth
)
{
SetPixel
(
dst
0
0
0
)
;
mCurrentPos
+
+
;
}
mCurrentPos
=
0
;
FinishRow
(
)
;
}
nsIntRect
r
(
0
0
mH
.
mWidth
AbsoluteHeight
(
)
)
;
PostInvalidation
(
r
)
;
MOZ_ASSERT_IF
(
mDoesHaveTransparency
mMayHaveTransparency
)
;
const
Opacity
opacity
=
mDoesHaveTransparency
|
|
mIsWithinICO
?
Opacity
:
:
SOME_TRANSPARENCY
:
Opacity
:
:
FULLY_OPAQUE
;
PostFrameStop
(
opacity
)
;
PostDecodeDone
(
)
;
}
return
NS_OK
;
}
void
BitFields
:
:
Value
:
:
Set
(
uint32_t
aMask
)
{
mMask
=
aMask
;
if
(
mMask
=
=
0x0
)
{
mRightShift
=
0
;
mBitWidth
=
1
;
return
;
}
uint8_t
i
;
for
(
i
=
0
;
i
<
32
;
i
+
+
)
{
if
(
mMask
&
(
1
<
<
i
)
)
{
break
;
}
}
mRightShift
=
i
;
for
(
i
=
i
+
1
;
i
<
32
;
i
+
+
)
{
if
(
!
(
mMask
&
(
1
<
<
i
)
)
)
{
break
;
}
}
mBitWidth
=
i
-
mRightShift
;
}
MOZ_ALWAYS_INLINE
uint8_t
BitFields
:
:
Value
:
:
Get
(
uint32_t
aValue
)
const
{
uint32_t
v
=
(
aValue
&
mMask
)
>
>
mRightShift
;
uint8_t
v2
=
0
;
int32_t
i
;
for
(
i
=
8
-
mBitWidth
;
i
>
0
;
i
-
=
mBitWidth
)
{
v2
|
=
v
<
<
uint32_t
(
i
)
;
}
v2
|
=
v
>
>
uint32_t
(
-
i
)
;
return
v2
;
}
MOZ_ALWAYS_INLINE
uint8_t
BitFields
:
:
Value
:
:
GetAlpha
(
uint32_t
aValue
bool
&
aHasAlphaOut
)
const
{
if
(
mMask
=
=
0x0
)
{
return
0xff
;
}
aHasAlphaOut
=
true
;
return
Get
(
aValue
)
;
}
MOZ_ALWAYS_INLINE
uint8_t
BitFields
:
:
Value
:
:
Get5
(
uint32_t
aValue
)
const
{
MOZ_ASSERT
(
mBitWidth
=
=
5
)
;
uint32_t
v
=
(
aValue
&
mMask
)
>
>
mRightShift
;
return
(
v
<
<
3u
)
|
(
v
>
>
2u
)
;
}
MOZ_ALWAYS_INLINE
uint8_t
BitFields
:
:
Value
:
:
Get8
(
uint32_t
aValue
)
const
{
MOZ_ASSERT
(
mBitWidth
=
=
8
)
;
uint32_t
v
=
(
aValue
&
mMask
)
>
>
mRightShift
;
return
v
;
}
void
BitFields
:
:
SetR5G5B5
(
)
{
mRed
.
Set
(
0x7c00
)
;
mGreen
.
Set
(
0x03e0
)
;
mBlue
.
Set
(
0x001f
)
;
}
void
BitFields
:
:
SetR8G8B8
(
)
{
mRed
.
Set
(
0xff0000
)
;
mGreen
.
Set
(
0xff00
)
;
mBlue
.
Set
(
0x00ff
)
;
}
bool
BitFields
:
:
IsR5G5B5
(
)
const
{
return
mRed
.
mBitWidth
=
=
5
&
&
mGreen
.
mBitWidth
=
=
5
&
&
mBlue
.
mBitWidth
=
=
5
&
&
mAlpha
.
mMask
=
=
0x0
;
}
bool
BitFields
:
:
IsR8G8B8
(
)
const
{
return
mRed
.
mBitWidth
=
=
8
&
&
mGreen
.
mBitWidth
=
=
8
&
&
mBlue
.
mBitWidth
=
=
8
&
&
mAlpha
.
mMask
=
=
0x0
;
}
uint32_t
*
nsBMPDecoder
:
:
RowBuffer
(
)
{
if
(
mDownscaler
)
{
return
reinterpret_cast
<
uint32_t
*
>
(
mDownscaler
-
>
RowBuffer
(
)
)
+
mCurrentPos
;
}
int32_t
line
=
(
mH
.
mHeight
<
0
)
?
-
mH
.
mHeight
-
mCurrentRow
:
mCurrentRow
-
1
;
int32_t
offset
=
line
*
mH
.
mWidth
+
mCurrentPos
;
return
reinterpret_cast
<
uint32_t
*
>
(
mImageData
)
+
offset
;
}
void
nsBMPDecoder
:
:
FinishRow
(
)
{
if
(
mDownscaler
)
{
mDownscaler
-
>
CommitRow
(
)
;
if
(
mDownscaler
-
>
HasInvalidation
(
)
)
{
DownscalerInvalidRect
invalidRect
=
mDownscaler
-
>
TakeInvalidRect
(
)
;
PostInvalidation
(
invalidRect
.
mOriginalSizeRect
Some
(
invalidRect
.
mTargetSizeRect
)
)
;
}
}
else
{
PostInvalidation
(
IntRect
(
0
mCurrentRow
mH
.
mWidth
1
)
)
;
}
mCurrentRow
-
-
;
}
LexerResult
nsBMPDecoder
:
:
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
DoDecode
after
error
!
"
)
;
return
mLexer
.
Lex
(
aIterator
aOnResume
[
=
]
(
State
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
State
:
:
FILE_HEADER
:
return
ReadFileHeader
(
aData
aLength
)
;
case
State
:
:
INFO_HEADER_SIZE
:
return
ReadInfoHeaderSize
(
aData
aLength
)
;
case
State
:
:
INFO_HEADER_REST
:
return
ReadInfoHeaderRest
(
aData
aLength
)
;
case
State
:
:
BITFIELDS
:
return
ReadBitfields
(
aData
aLength
)
;
case
State
:
:
COLOR_TABLE
:
return
ReadColorTable
(
aData
aLength
)
;
case
State
:
:
GAP
:
return
SkipGap
(
)
;
case
State
:
:
AFTER_GAP
:
return
AfterGap
(
)
;
case
State
:
:
PIXEL_ROW
:
return
ReadPixelRow
(
aData
)
;
case
State
:
:
RLE_SEGMENT
:
return
ReadRLESegment
(
aData
)
;
case
State
:
:
RLE_DELTA
:
return
ReadRLEDelta
(
aData
)
;
case
State
:
:
RLE_ABSOLUTE
:
return
ReadRLEAbsolute
(
aData
aLength
)
;
default
:
MOZ_CRASH
(
"
Unknown
State
"
)
;
}
}
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadFileHeader
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
bool
signatureOk
=
aData
[
0
]
=
=
'
B
'
&
&
aData
[
1
]
=
=
'
M
'
;
if
(
!
signatureOk
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
mH
.
mDataOffset
=
LittleEndian
:
:
readUint32
(
aData
+
10
)
;
return
Transition
:
:
To
(
State
:
:
INFO_HEADER_SIZE
BIHSIZE_FIELD_LENGTH
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadInfoHeaderSize
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
mH
.
mBIHSize
=
LittleEndian
:
:
readUint32
(
aData
)
;
bool
bihSizeOk
=
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V2
|
|
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V3
|
|
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V4
|
|
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V5
|
|
(
mH
.
mBIHSize
>
=
InfoHeaderLength
:
:
OS2_V2_MIN
&
&
mH
.
mBIHSize
<
=
InfoHeaderLength
:
:
OS2_V2_MAX
)
;
if
(
!
bihSizeOk
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
MOZ_ASSERT_IF
(
mIsWithinICO
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V3
)
;
return
Transition
:
:
To
(
State
:
:
INFO_HEADER_REST
mH
.
mBIHSize
-
BIHSIZE_FIELD_LENGTH
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadInfoHeaderRest
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
if
(
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V2
)
{
mH
.
mWidth
=
LittleEndian
:
:
readUint16
(
aData
+
0
)
;
mH
.
mHeight
=
LittleEndian
:
:
readUint16
(
aData
+
2
)
;
mH
.
mBpp
=
LittleEndian
:
:
readUint16
(
aData
+
6
)
;
}
else
{
mH
.
mWidth
=
LittleEndian
:
:
readUint32
(
aData
+
0
)
;
mH
.
mHeight
=
LittleEndian
:
:
readUint32
(
aData
+
4
)
;
mH
.
mBpp
=
LittleEndian
:
:
readUint16
(
aData
+
10
)
;
mH
.
mCompression
=
aLength
>
=
16
?
LittleEndian
:
:
readUint32
(
aData
+
12
)
:
0
;
mH
.
mImageSize
=
aLength
>
=
20
?
LittleEndian
:
:
readUint32
(
aData
+
16
)
:
0
;
mH
.
mNumColors
=
aLength
>
=
32
?
LittleEndian
:
:
readUint32
(
aData
+
28
)
:
0
;
}
if
(
mIsWithinICO
)
{
mH
.
mHeight
=
abs
(
mH
.
mHeight
)
/
2
;
}
MOZ_LOG
(
sBMPLog
LogLevel
:
:
Debug
(
"
BMP
:
bihsize
=
%
u
%
d
x
%
d
bpp
=
%
u
compression
=
%
u
colors
=
%
u
\
n
"
mH
.
mBIHSize
mH
.
mWidth
mH
.
mHeight
uint32_t
(
mH
.
mBpp
)
mH
.
mCompression
mH
.
mNumColors
)
)
;
const
int32_t
k64KWidth
=
0x0000FFFF
;
bool
sizeOk
=
0
<
=
mH
.
mWidth
&
&
mH
.
mWidth
<
=
k64KWidth
&
&
mH
.
mHeight
!
=
INT_MIN
;
if
(
!
sizeOk
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
bool
bppCompressionOk
=
(
mH
.
mCompression
=
=
Compression
:
:
RGB
&
&
(
mH
.
mBpp
=
=
1
|
|
mH
.
mBpp
=
=
4
|
|
mH
.
mBpp
=
=
8
|
|
mH
.
mBpp
=
=
16
|
|
mH
.
mBpp
=
=
24
|
|
mH
.
mBpp
=
=
32
)
)
|
|
(
mH
.
mCompression
=
=
Compression
:
:
RLE8
&
&
mH
.
mBpp
=
=
8
)
|
|
(
mH
.
mCompression
=
=
Compression
:
:
RLE4
&
&
mH
.
mBpp
=
=
4
)
|
|
(
mH
.
mCompression
=
=
Compression
:
:
BITFIELDS
&
&
(
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V3
|
|
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V4
|
|
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V5
)
&
&
(
mH
.
mBpp
=
=
16
|
|
mH
.
mBpp
=
=
32
)
)
;
if
(
!
bppCompressionOk
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
mCurrentRow
=
AbsoluteHeight
(
)
;
mPixelRowSize
=
(
mH
.
mBpp
*
mH
.
mWidth
+
7
)
/
8
;
uint32_t
surplus
=
mPixelRowSize
%
4
;
if
(
surplus
!
=
0
)
{
mPixelRowSize
+
=
4
-
surplus
;
}
size_t
bitFieldsLengthStillToRead
=
0
;
if
(
mH
.
mCompression
=
=
Compression
:
:
BITFIELDS
)
{
if
(
mH
.
mBIHSize
>
=
InfoHeaderLength
:
:
WIN_V4
)
{
mBitFields
.
ReadFromHeader
(
aData
+
36
true
)
;
if
(
mIsForClipboard
)
{
mH
.
mDataOffset
+
=
BitFields
:
:
LENGTH
;
}
}
else
{
bitFieldsLengthStillToRead
=
BitFields
:
:
LENGTH
;
}
}
else
if
(
mH
.
mBpp
=
=
16
)
{
mBitFields
.
SetR5G5B5
(
)
;
}
else
if
(
mH
.
mBpp
=
=
32
)
{
mBitFields
.
SetR8G8B8
(
)
;
}
return
Transition
:
:
To
(
State
:
:
BITFIELDS
bitFieldsLengthStillToRead
)
;
}
void
BitFields
:
:
ReadFromHeader
(
const
char
*
aData
bool
aReadAlpha
)
{
mRed
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
0
)
)
;
mGreen
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
4
)
)
;
mBlue
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
8
)
)
;
if
(
aReadAlpha
)
{
mAlpha
.
Set
(
LittleEndian
:
:
readUint32
(
aData
+
12
)
)
;
}
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadBitfields
(
const
char
*
aData
size_t
aLength
)
{
mPreGapLength
+
=
aLength
;
if
(
aLength
!
=
0
)
{
mBitFields
.
ReadFromHeader
(
aData
false
)
;
}
mMayHaveTransparency
=
mIsWithinICO
|
|
mH
.
mCompression
=
=
Compression
:
:
RLE8
|
|
mH
.
mCompression
=
=
Compression
:
:
RLE4
|
|
(
mH
.
mCompression
=
=
Compression
:
:
BITFIELDS
&
&
mBitFields
.
mAlpha
.
IsPresent
(
)
)
;
if
(
mMayHaveTransparency
)
{
PostHasTransparency
(
)
;
}
PostSize
(
mH
.
mWidth
AbsoluteHeight
(
)
)
;
if
(
HasError
(
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
IsMetadataDecode
(
)
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
if
(
mH
.
mBpp
<
=
8
)
{
mNumColors
=
1
<
<
mH
.
mBpp
;
if
(
0
<
mH
.
mNumColors
&
&
mH
.
mNumColors
<
mNumColors
)
{
mNumColors
=
mH
.
mNumColors
;
}
mColors
=
MakeUnique
<
ColorTableEntry
[
]
>
(
256
)
;
memset
(
mColors
.
get
(
)
0
256
*
sizeof
(
ColorTableEntry
)
)
;
mBytesPerColor
=
(
mH
.
mBIHSize
=
=
InfoHeaderLength
:
:
WIN_V2
)
?
3
:
4
;
}
MOZ_ASSERT
(
!
mImageData
"
Already
have
a
buffer
allocated
?
"
)
;
nsresult
rv
=
AllocateFrame
(
OutputSize
(
)
FullOutputFrame
(
)
mMayHaveTransparency
?
SurfaceFormat
:
:
B8G8R8A8
:
SurfaceFormat
:
:
B8G8R8X8
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
MOZ_ASSERT
(
mImageData
"
Should
have
a
buffer
now
"
)
;
if
(
mDownscaler
)
{
rv
=
mDownscaler
-
>
BeginFrame
(
Size
(
)
Nothing
(
)
mImageData
mMayHaveTransparency
mH
.
mHeight
>
=
0
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
}
return
Transition
:
:
To
(
State
:
:
COLOR_TABLE
mNumColors
*
mBytesPerColor
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadColorTable
(
const
char
*
aData
size_t
aLength
)
{
MOZ_ASSERT_IF
(
aLength
!
=
0
mNumColors
>
0
&
&
mColors
)
;
mPreGapLength
+
=
aLength
;
for
(
uint32_t
i
=
0
;
i
<
mNumColors
;
i
+
+
)
{
mColors
[
i
]
.
mBlue
=
uint8_t
(
aData
[
0
]
)
;
mColors
[
i
]
.
mGreen
=
uint8_t
(
aData
[
1
]
)
;
mColors
[
i
]
.
mRed
=
uint8_t
(
aData
[
2
]
)
;
aData
+
=
mBytesPerColor
;
}
if
(
mIsForClipboard
)
{
mH
.
mDataOffset
+
=
mPreGapLength
;
}
if
(
mPreGapLength
>
mH
.
mDataOffset
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
uint32_t
gapLength
=
mH
.
mDataOffset
-
mPreGapLength
;
return
Transition
:
:
ToUnbuffered
(
State
:
:
AFTER_GAP
State
:
:
GAP
gapLength
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
SkipGap
(
)
{
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
GAP
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
AfterGap
(
)
{
if
(
mH
.
mWidth
=
=
0
|
|
mH
.
mHeight
=
=
0
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
bool
hasRLE
=
mH
.
mCompression
=
=
Compression
:
:
RLE8
|
|
mH
.
mCompression
=
=
Compression
:
:
RLE4
;
return
hasRLE
?
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
:
Transition
:
:
To
(
State
:
:
PIXEL_ROW
mPixelRowSize
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadPixelRow
(
const
char
*
aData
)
{
MOZ_ASSERT
(
mCurrentRow
>
0
)
;
MOZ_ASSERT
(
mCurrentPos
=
=
0
)
;
const
uint8_t
*
src
=
reinterpret_cast
<
const
uint8_t
*
>
(
aData
)
;
uint32_t
*
dst
=
RowBuffer
(
)
;
uint32_t
lpos
=
mH
.
mWidth
;
switch
(
mH
.
mBpp
)
{
case
1
:
while
(
lpos
>
0
)
{
int8_t
bit
;
uint8_t
idx
;
for
(
bit
=
7
;
bit
>
=
0
&
&
lpos
>
0
;
bit
-
-
)
{
idx
=
(
*
src
>
>
bit
)
&
1
;
SetPixel
(
dst
idx
mColors
)
;
-
-
lpos
;
}
+
+
src
;
}
break
;
case
4
:
while
(
lpos
>
0
)
{
Set4BitPixel
(
dst
*
src
lpos
mColors
)
;
+
+
src
;
}
break
;
case
8
:
while
(
lpos
>
0
)
{
SetPixel
(
dst
*
src
mColors
)
;
-
-
lpos
;
+
+
src
;
}
break
;
case
16
:
if
(
mBitFields
.
IsR5G5B5
(
)
)
{
while
(
lpos
>
0
)
{
uint16_t
val
=
LittleEndian
:
:
readUint16
(
src
)
;
SetPixel
(
dst
mBitFields
.
mRed
.
Get5
(
val
)
mBitFields
.
mGreen
.
Get5
(
val
)
mBitFields
.
mBlue
.
Get5
(
val
)
)
;
-
-
lpos
;
src
+
=
2
;
}
}
else
{
bool
anyHasAlpha
=
false
;
while
(
lpos
>
0
)
{
uint16_t
val
=
LittleEndian
:
:
readUint16
(
src
)
;
SetPixel
(
dst
mBitFields
.
mRed
.
Get
(
val
)
mBitFields
.
mGreen
.
Get
(
val
)
mBitFields
.
mBlue
.
Get
(
val
)
mBitFields
.
mAlpha
.
GetAlpha
(
val
anyHasAlpha
)
)
;
-
-
lpos
;
src
+
=
2
;
}
if
(
anyHasAlpha
)
{
MOZ_ASSERT
(
mMayHaveTransparency
)
;
mDoesHaveTransparency
=
true
;
}
}
break
;
case
24
:
while
(
lpos
>
0
)
{
SetPixel
(
dst
src
[
2
]
src
[
1
]
src
[
0
]
)
;
-
-
lpos
;
src
+
=
3
;
}
break
;
case
32
:
if
(
mH
.
mCompression
=
=
Compression
:
:
RGB
&
&
mIsWithinICO
&
&
mH
.
mBpp
=
=
32
)
{
while
(
lpos
>
0
)
{
if
(
!
mDoesHaveTransparency
&
&
src
[
3
]
!
=
0
)
{
if
(
mDownscaler
)
{
mDownscaler
-
>
ResetForNextProgressivePass
(
)
;
}
MOZ_ASSERT
(
mCurrentPos
=
=
0
)
;
int32_t
currentRow
=
mCurrentRow
;
mCurrentRow
=
AbsoluteHeight
(
)
;
while
(
mCurrentRow
>
currentRow
)
{
dst
=
RowBuffer
(
)
;
for
(
int32_t
i
=
0
;
i
<
mH
.
mWidth
;
i
+
+
)
{
SetPixel
(
dst
0
0
0
0
)
;
}
FinishRow
(
)
;
}
dst
=
RowBuffer
(
)
;
int32_t
n
=
mH
.
mWidth
-
lpos
;
for
(
int32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
SetPixel
(
dst
0
0
0
0
)
;
}
MOZ_ASSERT
(
mMayHaveTransparency
)
;
mDoesHaveTransparency
=
true
;
}
SetPixel
(
dst
src
[
2
]
src
[
1
]
src
[
0
]
mDoesHaveTransparency
?
src
[
3
]
:
0xff
)
;
src
+
=
4
;
-
-
lpos
;
}
}
else
if
(
mBitFields
.
IsR8G8B8
(
)
)
{
while
(
lpos
>
0
)
{
uint32_t
val
=
LittleEndian
:
:
readUint32
(
src
)
;
SetPixel
(
dst
mBitFields
.
mRed
.
Get8
(
val
)
mBitFields
.
mGreen
.
Get8
(
val
)
mBitFields
.
mBlue
.
Get8
(
val
)
)
;
-
-
lpos
;
src
+
=
4
;
}
}
else
{
bool
anyHasAlpha
=
false
;
while
(
lpos
>
0
)
{
uint32_t
val
=
LittleEndian
:
:
readUint32
(
src
)
;
SetPixel
(
dst
mBitFields
.
mRed
.
Get
(
val
)
mBitFields
.
mGreen
.
Get
(
val
)
mBitFields
.
mBlue
.
Get
(
val
)
mBitFields
.
mAlpha
.
GetAlpha
(
val
anyHasAlpha
)
)
;
-
-
lpos
;
src
+
=
4
;
}
if
(
anyHasAlpha
)
{
MOZ_ASSERT
(
mMayHaveTransparency
)
;
mDoesHaveTransparency
=
true
;
}
}
break
;
default
:
MOZ_CRASH
(
"
Unsupported
color
depth
;
earlier
check
didn
'
t
catch
it
?
"
)
;
}
FinishRow
(
)
;
return
mCurrentRow
=
=
0
?
Transition
:
:
TerminateSuccess
(
)
:
Transition
:
:
To
(
State
:
:
PIXEL_ROW
mPixelRowSize
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadRLESegment
(
const
char
*
aData
)
{
if
(
mCurrentRow
=
=
0
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
uint8_t
byte1
=
uint8_t
(
aData
[
0
]
)
;
uint8_t
byte2
=
uint8_t
(
aData
[
1
]
)
;
if
(
byte1
!
=
RLE
:
:
ESCAPE
)
{
uint32_t
pixelsNeeded
=
std
:
:
min
<
uint32_t
>
(
mH
.
mWidth
-
mCurrentPos
byte1
)
;
if
(
pixelsNeeded
)
{
uint32_t
*
dst
=
RowBuffer
(
)
;
mCurrentPos
+
=
pixelsNeeded
;
if
(
mH
.
mCompression
=
=
Compression
:
:
RLE8
)
{
do
{
SetPixel
(
dst
byte2
mColors
)
;
pixelsNeeded
-
-
;
}
while
(
pixelsNeeded
)
;
}
else
{
do
{
Set4BitPixel
(
dst
byte2
pixelsNeeded
mColors
)
;
}
while
(
pixelsNeeded
)
;
}
}
return
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
if
(
byte2
=
=
RLE
:
:
ESCAPE_EOL
)
{
mCurrentPos
=
0
;
FinishRow
(
)
;
return
mCurrentRow
=
=
0
?
Transition
:
:
TerminateSuccess
(
)
:
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
if
(
byte2
=
=
RLE
:
:
ESCAPE_EOF
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
if
(
byte2
=
=
RLE
:
:
ESCAPE_DELTA
)
{
return
Transition
:
:
To
(
State
:
:
RLE_DELTA
RLE
:
:
DELTA_LENGTH
)
;
}
MOZ_ASSERT
(
mAbsoluteModeNumPixels
=
=
0
)
;
mAbsoluteModeNumPixels
=
byte2
;
uint32_t
length
=
byte2
;
if
(
mH
.
mCompression
=
=
Compression
:
:
RLE4
)
{
length
=
(
length
+
1
)
/
2
;
}
if
(
length
&
1
)
{
length
+
+
;
}
return
Transition
:
:
To
(
State
:
:
RLE_ABSOLUTE
length
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadRLEDelta
(
const
char
*
aData
)
{
MOZ_ASSERT
(
mMayHaveTransparency
)
;
mDoesHaveTransparency
=
true
;
if
(
mDownscaler
)
{
mDownscaler
-
>
ClearRestOfRow
(
mCurrentPos
)
;
}
mCurrentPos
+
=
uint8_t
(
aData
[
0
]
)
;
if
(
mCurrentPos
>
mH
.
mWidth
)
{
mCurrentPos
=
mH
.
mWidth
;
}
int32_t
yDelta
=
std
:
:
min
<
int32_t
>
(
uint8_t
(
aData
[
1
]
)
mCurrentRow
)
;
mCurrentRow
-
=
yDelta
;
if
(
mDownscaler
&
&
yDelta
>
0
)
{
mDownscaler
-
>
CommitRow
(
)
;
for
(
int32_t
line
=
1
;
line
<
yDelta
;
line
+
+
)
{
mDownscaler
-
>
ClearRow
(
)
;
mDownscaler
-
>
CommitRow
(
)
;
}
}
return
mCurrentRow
=
=
0
?
Transition
:
:
TerminateSuccess
(
)
:
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
LexerTransition
<
nsBMPDecoder
:
:
State
>
nsBMPDecoder
:
:
ReadRLEAbsolute
(
const
char
*
aData
size_t
aLength
)
{
uint32_t
n
=
mAbsoluteModeNumPixels
;
mAbsoluteModeNumPixels
=
0
;
if
(
mCurrentPos
+
n
>
uint32_t
(
mH
.
mWidth
)
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
uint32_t
*
dst
=
RowBuffer
(
)
;
uint32_t
iSrc
=
0
;
uint32_t
*
oldPos
=
dst
;
if
(
mH
.
mCompression
=
=
Compression
:
:
RLE8
)
{
while
(
n
>
0
)
{
SetPixel
(
dst
aData
[
iSrc
]
mColors
)
;
n
-
-
;
iSrc
+
+
;
}
}
else
{
while
(
n
>
0
)
{
Set4BitPixel
(
dst
aData
[
iSrc
]
n
mColors
)
;
iSrc
+
+
;
}
}
mCurrentPos
+
=
dst
-
oldPos
;
MOZ_ASSERT
(
iSrc
=
=
aLength
-
1
|
|
iSrc
=
=
aLength
)
;
return
Transition
:
:
To
(
State
:
:
RLE_SEGMENT
RLE
:
:
SEGMENT_LENGTH
)
;
}
}
}
