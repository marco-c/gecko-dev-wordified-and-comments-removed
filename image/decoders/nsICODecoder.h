#
ifndef
mozilla_image_decoders_nsICODecoder_h
#
define
mozilla_image_decoders_nsICODecoder_h
#
include
"
StreamingLexer
.
h
"
#
include
"
Decoder
.
h
"
#
include
"
imgFrame
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsBMPDecoder
.
h
"
#
include
"
nsPNGDecoder
.
h
"
#
include
"
ICOFileHeaders
.
h
"
namespace
mozilla
{
namespace
image
{
class
RasterImage
;
enum
class
ICOState
{
HEADER
DIR_ENTRY
SKIP_TO_RESOURCE
FOUND_RESOURCE
SNIFF_RESOURCE
READ_PNG
READ_BIH
READ_BMP
PREPARE_FOR_MASK
READ_MASK_ROW
FINISH_MASK
SKIP_MASK
FINISHED_RESOURCE
}
;
class
nsICODecoder
:
public
Decoder
{
public
:
virtual
~
nsICODecoder
(
)
{
}
static
uint32_t
GetRealWidth
(
const
IconDirEntry
&
aEntry
)
{
return
aEntry
.
mWidth
=
=
0
?
256
:
aEntry
.
mWidth
;
}
uint32_t
GetRealWidth
(
)
const
{
return
GetRealWidth
(
mDirEntry
)
;
}
static
uint32_t
GetRealHeight
(
const
IconDirEntry
&
aEntry
)
{
return
aEntry
.
mHeight
=
=
0
?
256
:
aEntry
.
mHeight
;
}
uint32_t
GetRealHeight
(
)
const
{
return
GetRealHeight
(
mDirEntry
)
;
}
gfx
:
:
IntSize
GetRealSize
(
)
const
{
return
gfx
:
:
IntSize
(
GetRealWidth
(
)
GetRealHeight
(
)
)
;
}
size_t
FirstResourceOffset
(
)
const
;
LexerResult
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
override
;
nsresult
FinishInternal
(
)
override
;
nsresult
FinishWithErrorInternal
(
)
override
;
private
:
friend
class
DecoderFactory
;
explicit
nsICODecoder
(
RasterImage
*
aImage
)
;
bool
WriteToContainedDecoder
(
const
char
*
aBuffer
uint32_t
aCount
)
;
nsresult
GetFinalStateFromContainedDecoder
(
)
;
bool
CheckAndFixBitmapSize
(
int8_t
*
aBIH
)
;
uint16_t
GetNumColors
(
)
;
LexerTransition
<
ICOState
>
ReadHeader
(
const
char
*
aData
)
;
LexerTransition
<
ICOState
>
ReadDirEntry
(
const
char
*
aData
)
;
LexerTransition
<
ICOState
>
SniffResource
(
const
char
*
aData
)
;
LexerTransition
<
ICOState
>
ReadPNG
(
const
char
*
aData
uint32_t
aLen
)
;
LexerTransition
<
ICOState
>
ReadBIH
(
const
char
*
aData
)
;
LexerTransition
<
ICOState
>
ReadBMP
(
const
char
*
aData
uint32_t
aLen
)
;
LexerTransition
<
ICOState
>
PrepareForMask
(
)
;
LexerTransition
<
ICOState
>
ReadMaskRow
(
const
char
*
aData
)
;
LexerTransition
<
ICOState
>
FinishMask
(
)
;
LexerTransition
<
ICOState
>
FinishResource
(
)
;
StreamingLexer
<
ICOState
32
>
mLexer
;
RefPtr
<
Decoder
>
mContainedDecoder
;
RefPtr
<
SourceBuffer
>
mContainedSourceBuffer
;
UniquePtr
<
uint8_t
[
]
>
mMaskBuffer
;
char
mBIHraw
[
bmp
:
:
InfoHeaderLength
:
:
WIN_ICO
]
;
IconDirEntry
mDirEntry
;
gfx
:
:
IntSize
mBiggestResourceSize
;
gfx
:
:
IntSize
mBiggestResourceHotSpot
;
uint16_t
mBiggestResourceColorDepth
;
int32_t
mBestResourceDelta
;
uint16_t
mBestResourceColorDepth
;
uint16_t
mNumIcons
;
uint16_t
mCurrIcon
;
uint16_t
mBPP
;
uint32_t
mMaskRowSize
;
uint32_t
mCurrMaskLine
;
bool
mIsCursor
;
bool
mHasMaskAlpha
;
}
;
}
}
#
endif
