#
include
"
ImageLogging
.
h
"
#
include
"
nsPNGDecoder
.
h
"
#
include
<
algorithm
>
#
include
<
cstdint
>
#
include
"
gfxColor
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
imgFrame
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nspr
.
h
"
#
include
"
png
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
SurfacePipeFactory
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
image
{
static
LazyLogModule
sPNGLog
(
"
PNGDecoder
"
)
;
static
LazyLogModule
sPNGDecoderAccountingLog
(
"
PNGDecoderAccounting
"
)
;
#
ifndef
MOZ_PNG_MAX_DIMENSION
#
define
MOZ_PNG_MAX_DIMENSION
32767
#
endif
nsPNGDecoder
:
:
AnimFrameInfo
:
:
AnimFrameInfo
(
)
:
mDispose
(
DisposalMethod
:
:
KEEP
)
mBlend
(
BlendMethod
:
:
OVER
)
mTimeout
(
0
)
{
}
#
ifdef
PNG_APNG_SUPPORTED
int32_t
GetNextFrameDelay
(
png_structp
aPNG
png_infop
aInfo
)
{
png_uint_16
delayNum
=
png_get_next_frame_delay_num
(
aPNG
aInfo
)
;
png_uint_16
delayDen
=
png_get_next_frame_delay_den
(
aPNG
aInfo
)
;
if
(
delayNum
=
=
0
)
{
return
0
;
}
if
(
delayDen
=
=
0
)
{
delayDen
=
100
;
}
return
static_cast
<
int32_t
>
(
static_cast
<
double
>
(
delayNum
)
*
1000
/
delayDen
)
;
}
nsPNGDecoder
:
:
AnimFrameInfo
:
:
AnimFrameInfo
(
png_structp
aPNG
png_infop
aInfo
)
:
mDispose
(
DisposalMethod
:
:
KEEP
)
mBlend
(
BlendMethod
:
:
OVER
)
mTimeout
(
0
)
{
png_byte
dispose_op
=
png_get_next_frame_dispose_op
(
aPNG
aInfo
)
;
png_byte
blend_op
=
png_get_next_frame_blend_op
(
aPNG
aInfo
)
;
if
(
dispose_op
=
=
PNG_DISPOSE_OP_PREVIOUS
)
{
mDispose
=
DisposalMethod
:
:
RESTORE_PREVIOUS
;
}
else
if
(
dispose_op
=
=
PNG_DISPOSE_OP_BACKGROUND
)
{
mDispose
=
DisposalMethod
:
:
CLEAR
;
}
else
{
mDispose
=
DisposalMethod
:
:
KEEP
;
}
if
(
blend_op
=
=
PNG_BLEND_OP_SOURCE
)
{
mBlend
=
BlendMethod
:
:
SOURCE
;
}
else
{
mBlend
=
BlendMethod
:
:
OVER
;
}
mTimeout
=
GetNextFrameDelay
(
aPNG
aInfo
)
;
}
#
endif
const
uint8_t
nsPNGDecoder
:
:
pngSignatureBytes
[
]
=
{
137
80
78
71
13
10
26
10
}
;
nsPNGDecoder
:
:
nsPNGDecoder
(
RasterImage
*
aImage
)
:
Decoder
(
aImage
)
mLexer
(
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_PNG_DATA
State
:
:
PNG_DATA
SIZE_MAX
)
Transition
:
:
TerminateSuccess
(
)
)
mPNG
(
nullptr
)
mInfo
(
nullptr
)
mCMSLine
(
nullptr
)
interlacebuf
(
nullptr
)
mInProfile
(
nullptr
)
mTransform
(
nullptr
)
format
(
gfx
:
:
SurfaceFormat
:
:
UNKNOWN
)
mCMSMode
(
0
)
mChannels
(
0
)
mPass
(
0
)
mFrameIsHidden
(
false
)
mDisablePremultipliedAlpha
(
false
)
mNumFrames
(
0
)
{
}
nsPNGDecoder
:
:
~
nsPNGDecoder
(
)
{
if
(
mPNG
)
{
png_destroy_read_struct
(
&
mPNG
mInfo
?
&
mInfo
:
nullptr
nullptr
)
;
}
if
(
mCMSLine
)
{
free
(
mCMSLine
)
;
}
if
(
interlacebuf
)
{
free
(
interlacebuf
)
;
}
if
(
mInProfile
)
{
qcms_profile_release
(
mInProfile
)
;
if
(
mTransform
)
{
qcms_transform_release
(
mTransform
)
;
}
}
}
nsPNGDecoder
:
:
TransparencyType
nsPNGDecoder
:
:
GetTransparencyType
(
SurfaceFormat
aFormat
const
IntRect
&
aFrameRect
)
{
if
(
aFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
)
{
return
TransparencyType
:
:
eAlpha
;
}
if
(
!
IntRect
(
IntPoint
(
)
GetSize
(
)
)
.
IsEqualEdges
(
aFrameRect
)
)
{
MOZ_ASSERT
(
HasAnimation
(
)
)
;
return
TransparencyType
:
:
eFrameRect
;
}
return
TransparencyType
:
:
eNone
;
}
void
nsPNGDecoder
:
:
PostHasTransparencyIfNeeded
(
TransparencyType
aTransparencyType
)
{
switch
(
aTransparencyType
)
{
case
TransparencyType
:
:
eNone
:
return
;
case
TransparencyType
:
:
eAlpha
:
PostHasTransparency
(
)
;
return
;
case
TransparencyType
:
:
eFrameRect
:
if
(
mNumFrames
=
=
0
)
{
PostHasTransparency
(
)
;
}
return
;
}
}
nsresult
nsPNGDecoder
:
:
CreateFrame
(
SurfaceFormat
aFormat
const
IntRect
&
aFrameRect
bool
aIsInterlaced
)
{
MOZ_ASSERT
(
HasSize
(
)
)
;
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
)
;
auto
transparency
=
GetTransparencyType
(
aFormat
aFrameRect
)
;
PostHasTransparencyIfNeeded
(
transparency
)
;
SurfaceFormat
format
=
transparency
=
=
TransparencyType
:
:
eNone
?
SurfaceFormat
:
:
B8G8R8X8
:
SurfaceFormat
:
:
B8G8R8A8
;
MOZ_ASSERT_IF
(
mDownscaler
mNumFrames
=
=
0
)
;
MOZ_ASSERT_IF
(
mDownscaler
!
GetImageMetadata
(
)
.
HasAnimation
(
)
)
;
MOZ_ASSERT_IF
(
mDownscaler
transparency
!
=
TransparencyType
:
:
eFrameRect
)
;
IntSize
targetSize
=
mDownscaler
?
mDownscaler
-
>
TargetSize
(
)
:
GetSize
(
)
;
SurfacePipeFlags
pipeFlags
=
aIsInterlaced
?
SurfacePipeFlags
:
:
ADAM7_INTERPOLATE
:
SurfacePipeFlags
(
)
;
if
(
mNumFrames
=
=
0
)
{
pipeFlags
|
=
SurfacePipeFlags
:
:
PROGRESSIVE_DISPLAY
;
}
Maybe
<
SurfacePipe
>
pipe
=
SurfacePipeFactory
:
:
CreateSurfacePipe
(
this
mNumFrames
GetSize
(
)
targetSize
aFrameRect
format
pipeFlags
)
;
if
(
!
pipe
)
{
mPipe
=
SurfacePipe
(
)
;
return
NS_ERROR_FAILURE
;
}
mPipe
=
Move
(
*
pipe
)
;
mFrameRect
=
aFrameRect
;
mPass
=
0
;
MOZ_LOG
(
sPNGDecoderAccountingLog
LogLevel
:
:
Debug
(
"
PNGDecoderAccounting
:
nsPNGDecoder
:
:
CreateFrame
-
-
created
"
"
image
frame
with
%
dx
%
d
pixels
for
decoder
%
p
"
aFrameRect
.
width
aFrameRect
.
height
this
)
)
;
#
ifdef
PNG_APNG_SUPPORTED
if
(
png_get_valid
(
mPNG
mInfo
PNG_INFO_acTL
)
)
{
mAnimInfo
=
AnimFrameInfo
(
mPNG
mInfo
)
;
if
(
mAnimInfo
.
mDispose
=
=
DisposalMethod
:
:
CLEAR
)
{
PostHasTransparency
(
)
;
}
}
#
endif
return
NS_OK
;
}
void
nsPNGDecoder
:
:
EndImageFrame
(
)
{
if
(
mFrameIsHidden
)
{
return
;
}
mNumFrames
+
+
;
Opacity
opacity
=
Opacity
:
:
SOME_TRANSPARENCY
;
if
(
format
=
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
)
{
opacity
=
Opacity
:
:
FULLY_OPAQUE
;
}
PostFrameStop
(
opacity
mAnimInfo
.
mDispose
mAnimInfo
.
mTimeout
mAnimInfo
.
mBlend
Some
(
mFrameRect
)
)
;
}
nsresult
nsPNGDecoder
:
:
InitInternal
(
)
{
mCMSMode
=
gfxPlatform
:
:
GetCMSMode
(
)
;
if
(
GetSurfaceFlags
(
)
&
SurfaceFlags
:
:
NO_COLORSPACE_CONVERSION
)
{
mCMSMode
=
eCMSMode_Off
;
}
mDisablePremultipliedAlpha
=
bool
(
GetSurfaceFlags
(
)
&
SurfaceFlags
:
:
NO_PREMULTIPLY_ALPHA
)
;
#
ifdef
PNG_HANDLE_AS_UNKNOWN_SUPPORTED
static
png_byte
color_chunks
[
]
=
{
99
72
82
77
'
\
0
'
105
67
67
80
'
\
0
'
}
;
static
png_byte
unused_chunks
[
]
=
{
98
75
71
68
'
\
0
'
104
73
83
84
'
\
0
'
105
84
88
116
'
\
0
'
111
70
70
115
'
\
0
'
112
67
65
76
'
\
0
'
115
67
65
76
'
\
0
'
112
72
89
115
'
\
0
'
115
66
73
84
'
\
0
'
115
80
76
84
'
\
0
'
116
69
88
116
'
\
0
'
116
73
77
69
'
\
0
'
122
84
88
116
'
\
0
'
}
;
#
endif
mPNG
=
png_create_read_struct
(
PNG_LIBPNG_VER_STRING
nullptr
nsPNGDecoder
:
:
error_callback
nsPNGDecoder
:
:
warning_callback
)
;
if
(
!
mPNG
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mInfo
=
png_create_info_struct
(
mPNG
)
;
if
(
!
mInfo
)
{
png_destroy_read_struct
(
&
mPNG
nullptr
nullptr
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
#
ifdef
PNG_HANDLE_AS_UNKNOWN_SUPPORTED
if
(
mCMSMode
=
=
eCMSMode_Off
|
|
IsMetadataDecode
(
)
)
{
png_set_keep_unknown_chunks
(
mPNG
1
color_chunks
2
)
;
}
png_set_keep_unknown_chunks
(
mPNG
1
unused_chunks
(
int
)
sizeof
(
unused_chunks
)
/
5
)
;
#
endif
#
ifdef
PNG_SET_USER_LIMITS_SUPPORTED
if
(
mCMSMode
!
=
eCMSMode_Off
)
{
png_set_chunk_malloc_max
(
mPNG
4000000L
)
;
}
#
endif
#
ifdef
PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
png_set_check_for_invalid_index
(
mPNG
0
)
;
#
endif
#
if
defined
(
PNG_SET_OPTION_SUPPORTED
)
&
&
defined
(
PNG_sRGB_PROFILE_CHECKS
)
&
&
\
PNG_sRGB_PROFILE_CHECKS
>
=
0
png_set_option
(
mPNG
PNG_SKIP_sRGB_CHECK_PROFILE
PNG_OPTION_ON
)
;
#
endif
png_set_progressive_read_fn
(
mPNG
static_cast
<
png_voidp
>
(
this
)
nsPNGDecoder
:
:
info_callback
nsPNGDecoder
:
:
row_callback
nsPNGDecoder
:
:
end_callback
)
;
return
NS_OK
;
}
LexerResult
nsPNGDecoder
:
:
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
DoDecode
after
error
!
"
)
;
return
mLexer
.
Lex
(
aIterator
aOnResume
[
=
]
(
State
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
State
:
:
PNG_DATA
:
return
ReadPNGData
(
aData
aLength
)
;
case
State
:
:
FINISHED_PNG_DATA
:
return
FinishedPNGData
(
)
;
}
MOZ_CRASH
(
"
Unknown
State
"
)
;
}
)
;
}
LexerTransition
<
nsPNGDecoder
:
:
State
>
nsPNGDecoder
:
:
ReadPNGData
(
const
char
*
aData
size_t
aLength
)
{
if
(
setjmp
(
png_jmpbuf
(
mPNG
)
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
png_process_data
(
mPNG
mInfo
reinterpret_cast
<
unsigned
char
*
>
(
const_cast
<
char
*
>
(
(
aData
)
)
)
aLength
)
;
if
(
HasError
(
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
GetDecodeDone
(
)
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
PNG_DATA
)
;
}
LexerTransition
<
nsPNGDecoder
:
:
State
>
nsPNGDecoder
:
:
FinishedPNGData
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Read
the
entire
address
space
?
"
)
;
return
Transition
:
:
TerminateFailure
(
)
;
}
static
void
PNGDoGammaCorrection
(
png_structp
png_ptr
png_infop
info_ptr
)
{
double
aGamma
;
if
(
png_get_gAMA
(
png_ptr
info_ptr
&
aGamma
)
)
{
if
(
(
aGamma
<
=
0
.
0
)
|
|
(
aGamma
>
21474
.
83
)
)
{
aGamma
=
0
.
45455
;
png_set_gAMA
(
png_ptr
info_ptr
aGamma
)
;
}
png_set_gamma
(
png_ptr
2
.
2
aGamma
)
;
}
else
{
png_set_gamma
(
png_ptr
2
.
2
0
.
45455
)
;
}
}
static
qcms_profile
*
PNGGetColorProfile
(
png_structp
png_ptr
png_infop
info_ptr
int
color_type
qcms_data_type
*
inType
uint32_t
*
intent
)
{
qcms_profile
*
profile
=
nullptr
;
*
intent
=
QCMS_INTENT_PERCEPTUAL
;
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_iCCP
)
)
{
png_uint_32
profileLen
;
png_bytep
profileData
;
png_charp
profileName
;
int
compression
;
png_get_iCCP
(
png_ptr
info_ptr
&
profileName
&
compression
&
profileData
&
profileLen
)
;
profile
=
qcms_profile_from_memory
(
(
char
*
)
profileData
profileLen
)
;
if
(
profile
)
{
uint32_t
profileSpace
=
qcms_profile_get_color_space
(
profile
)
;
bool
mismatch
=
false
;
if
(
color_type
&
PNG_COLOR_MASK_COLOR
)
{
if
(
profileSpace
!
=
icSigRgbData
)
{
mismatch
=
true
;
}
}
else
{
if
(
profileSpace
=
=
icSigRgbData
)
{
png_set_gray_to_rgb
(
png_ptr
)
;
}
else
if
(
profileSpace
!
=
icSigGrayData
)
{
mismatch
=
true
;
}
}
if
(
mismatch
)
{
qcms_profile_release
(
profile
)
;
profile
=
nullptr
;
}
else
{
*
intent
=
qcms_profile_get_rendering_intent
(
profile
)
;
}
}
}
if
(
!
profile
&
&
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_sRGB
)
)
{
profile
=
qcms_profile_sRGB
(
)
;
if
(
profile
)
{
int
fileIntent
;
png_set_gray_to_rgb
(
png_ptr
)
;
png_get_sRGB
(
png_ptr
info_ptr
&
fileIntent
)
;
uint32_t
map
[
]
=
{
QCMS_INTENT_PERCEPTUAL
QCMS_INTENT_RELATIVE_COLORIMETRIC
QCMS_INTENT_SATURATION
QCMS_INTENT_ABSOLUTE_COLORIMETRIC
}
;
*
intent
=
map
[
fileIntent
]
;
}
}
if
(
!
profile
&
&
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_gAMA
)
&
&
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_cHRM
)
)
{
qcms_CIE_xyYTRIPLE
primaries
;
qcms_CIE_xyY
whitePoint
;
png_get_cHRM
(
png_ptr
info_ptr
&
whitePoint
.
x
&
whitePoint
.
y
&
primaries
.
red
.
x
&
primaries
.
red
.
y
&
primaries
.
green
.
x
&
primaries
.
green
.
y
&
primaries
.
blue
.
x
&
primaries
.
blue
.
y
)
;
whitePoint
.
Y
=
primaries
.
red
.
Y
=
primaries
.
green
.
Y
=
primaries
.
blue
.
Y
=
1
.
0
;
double
gammaOfFile
;
png_get_gAMA
(
png_ptr
info_ptr
&
gammaOfFile
)
;
profile
=
qcms_profile_create_rgb_with_gamma
(
whitePoint
primaries
1
.
0
/
gammaOfFile
)
;
if
(
profile
)
{
png_set_gray_to_rgb
(
png_ptr
)
;
}
}
if
(
profile
)
{
uint32_t
profileSpace
=
qcms_profile_get_color_space
(
profile
)
;
if
(
profileSpace
=
=
icSigGrayData
)
{
if
(
color_type
&
PNG_COLOR_MASK_ALPHA
)
{
*
inType
=
QCMS_DATA_GRAYA_8
;
}
else
{
*
inType
=
QCMS_DATA_GRAY_8
;
}
}
else
{
if
(
color_type
&
PNG_COLOR_MASK_ALPHA
|
|
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
*
inType
=
QCMS_DATA_RGBA_8
;
}
else
{
*
inType
=
QCMS_DATA_RGB_8
;
}
}
}
return
profile
;
}
void
nsPNGDecoder
:
:
info_callback
(
png_structp
png_ptr
png_infop
info_ptr
)
{
png_uint_32
width
height
;
int
bit_depth
color_type
interlace_type
compression_type
filter_type
;
unsigned
int
channels
;
png_bytep
trans
=
nullptr
;
int
num_trans
=
0
;
nsPNGDecoder
*
decoder
=
static_cast
<
nsPNGDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
;
png_get_IHDR
(
png_ptr
info_ptr
&
width
&
height
&
bit_depth
&
color_type
&
interlace_type
&
compression_type
&
filter_type
)
;
if
(
width
>
MOZ_PNG_MAX_DIMENSION
|
|
height
>
MOZ_PNG_MAX_DIMENSION
)
{
png_longjmp
(
decoder
-
>
mPNG
1
)
;
}
const
IntRect
frameRect
(
0
0
width
height
)
;
decoder
-
>
PostSize
(
frameRect
.
width
frameRect
.
height
)
;
if
(
decoder
-
>
HasError
(
)
)
{
png_longjmp
(
decoder
-
>
mPNG
1
)
;
}
if
(
color_type
=
=
PNG_COLOR_TYPE_PALETTE
)
{
png_set_expand
(
png_ptr
)
;
}
if
(
color_type
=
=
PNG_COLOR_TYPE_GRAY
&
&
bit_depth
<
8
)
{
png_set_expand
(
png_ptr
)
;
}
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_tRNS
)
)
{
png_color_16p
trans_values
;
png_get_tRNS
(
png_ptr
info_ptr
&
trans
&
num_trans
&
trans_values
)
;
if
(
bit_depth
<
16
)
{
png_uint_16
sample_max
=
(
1
<
<
bit_depth
)
-
1
;
if
(
(
color_type
=
=
PNG_COLOR_TYPE_GRAY
&
&
trans_values
-
>
gray
>
sample_max
)
|
|
(
color_type
=
=
PNG_COLOR_TYPE_RGB
&
&
(
trans_values
-
>
red
>
sample_max
|
|
trans_values
-
>
green
>
sample_max
|
|
trans_values
-
>
blue
>
sample_max
)
)
)
{
png_free_data
(
png_ptr
info_ptr
PNG_FREE_TRNS
0
)
;
num_trans
=
0
;
}
}
if
(
num_trans
!
=
0
)
{
png_set_expand
(
png_ptr
)
;
}
}
if
(
bit_depth
=
=
16
)
{
png_set_scale_16
(
png_ptr
)
;
}
qcms_data_type
inType
=
QCMS_DATA_RGBA_8
;
uint32_t
intent
=
-
1
;
uint32_t
pIntent
;
if
(
decoder
-
>
mCMSMode
!
=
eCMSMode_Off
)
{
intent
=
gfxPlatform
:
:
GetRenderingIntent
(
)
;
decoder
-
>
mInProfile
=
PNGGetColorProfile
(
png_ptr
info_ptr
color_type
&
inType
&
pIntent
)
;
if
(
intent
=
=
uint32_t
(
-
1
)
)
{
intent
=
pIntent
;
}
}
if
(
decoder
-
>
mInProfile
&
&
gfxPlatform
:
:
GetCMSOutputProfile
(
)
)
{
qcms_data_type
outType
;
if
(
color_type
&
PNG_COLOR_MASK_ALPHA
|
|
num_trans
)
{
outType
=
QCMS_DATA_RGBA_8
;
}
else
{
outType
=
QCMS_DATA_RGB_8
;
}
decoder
-
>
mTransform
=
qcms_transform_create
(
decoder
-
>
mInProfile
inType
gfxPlatform
:
:
GetCMSOutputProfile
(
)
outType
(
qcms_intent
)
intent
)
;
}
else
{
png_set_gray_to_rgb
(
png_ptr
)
;
if
(
decoder
-
>
mCMSMode
!
=
eCMSMode_Off
)
{
PNGDoGammaCorrection
(
png_ptr
info_ptr
)
;
}
if
(
decoder
-
>
mCMSMode
=
=
eCMSMode_All
)
{
if
(
color_type
&
PNG_COLOR_MASK_ALPHA
|
|
num_trans
)
{
decoder
-
>
mTransform
=
gfxPlatform
:
:
GetCMSRGBATransform
(
)
;
}
else
{
decoder
-
>
mTransform
=
gfxPlatform
:
:
GetCMSRGBTransform
(
)
;
}
}
}
const
bool
isInterlaced
=
interlace_type
=
=
PNG_INTERLACE_ADAM7
;
if
(
isInterlaced
)
{
png_set_interlace_handling
(
png_ptr
)
;
}
png_read_update_info
(
png_ptr
info_ptr
)
;
decoder
-
>
mChannels
=
channels
=
png_get_channels
(
png_ptr
info_ptr
)
;
if
(
channels
=
=
1
|
|
channels
=
=
3
)
{
decoder
-
>
format
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
}
else
if
(
channels
=
=
2
|
|
channels
=
=
4
)
{
decoder
-
>
format
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
}
else
{
png_longjmp
(
decoder
-
>
mPNG
1
)
;
}
#
ifdef
PNG_APNG_SUPPORTED
bool
isAnimated
=
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_acTL
)
;
if
(
isAnimated
)
{
decoder
-
>
PostIsAnimated
(
GetNextFrameDelay
(
png_ptr
info_ptr
)
)
;
if
(
decoder
-
>
mDownscaler
&
&
!
decoder
-
>
IsFirstFrameDecode
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Doing
downscale
-
during
-
decode
"
"
for
an
animated
image
?
"
)
;
png_longjmp
(
decoder
-
>
mPNG
1
)
;
}
}
#
endif
if
(
decoder
-
>
IsMetadataDecode
(
)
)
{
auto
transparency
=
decoder
-
>
GetTransparencyType
(
decoder
-
>
format
frameRect
)
;
decoder
-
>
PostHasTransparencyIfNeeded
(
transparency
)
;
png_process_data_pause
(
png_ptr
false
)
;
return
;
}
#
ifdef
PNG_APNG_SUPPORTED
if
(
isAnimated
)
{
png_set_progressive_frame_fn
(
png_ptr
nsPNGDecoder
:
:
frame_info_callback
nullptr
)
;
}
if
(
png_get_first_frame_is_hidden
(
png_ptr
info_ptr
)
)
{
decoder
-
>
mFrameIsHidden
=
true
;
}
else
{
#
endif
nsresult
rv
=
decoder
-
>
CreateFrame
(
decoder
-
>
format
frameRect
isInterlaced
)
;
if
(
NS_FAILED
(
rv
)
)
{
png_longjmp
(
decoder
-
>
mPNG
5
)
;
}
MOZ_ASSERT
(
decoder
-
>
mImageData
"
Should
have
a
buffer
now
"
)
;
#
ifdef
PNG_APNG_SUPPORTED
}
#
endif
if
(
decoder
-
>
mTransform
&
&
(
channels
<
=
2
|
|
isInterlaced
)
)
{
uint32_t
bpp
[
]
=
{
0
3
4
3
4
}
;
decoder
-
>
mCMSLine
=
static_cast
<
uint8_t
*
>
(
malloc
(
bpp
[
channels
]
*
frameRect
.
width
)
)
;
if
(
!
decoder
-
>
mCMSLine
)
{
png_longjmp
(
decoder
-
>
mPNG
5
)
;
}
}
if
(
interlace_type
=
=
PNG_INTERLACE_ADAM7
)
{
if
(
frameRect
.
height
<
INT32_MAX
/
(
frameRect
.
width
*
int32_t
(
channels
)
)
)
{
const
size_t
bufferSize
=
channels
*
frameRect
.
width
*
frameRect
.
height
;
decoder
-
>
interlacebuf
=
static_cast
<
uint8_t
*
>
(
malloc
(
bufferSize
)
)
;
}
if
(
!
decoder
-
>
interlacebuf
)
{
png_longjmp
(
decoder
-
>
mPNG
5
)
;
}
}
}
void
nsPNGDecoder
:
:
PostInvalidationIfNeeded
(
)
{
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
mPipe
.
TakeInvalidRect
(
)
;
if
(
!
invalidRect
)
{
return
;
}
PostInvalidation
(
invalidRect
-
>
mInputSpaceRect
Some
(
invalidRect
-
>
mOutputSpaceRect
)
)
;
}
static
NextPixel
<
uint32_t
>
PackRGBPixelAndAdvance
(
uint8_t
*
&
aRawPixelInOut
)
{
const
uint32_t
pixel
=
gfxPackedPixel
(
0xFF
aRawPixelInOut
[
0
]
aRawPixelInOut
[
1
]
aRawPixelInOut
[
2
]
)
;
aRawPixelInOut
+
=
3
;
return
AsVariant
(
pixel
)
;
}
static
NextPixel
<
uint32_t
>
PackRGBAPixelAndAdvance
(
uint8_t
*
&
aRawPixelInOut
)
{
const
uint32_t
pixel
=
gfxPackedPixel
(
aRawPixelInOut
[
3
]
aRawPixelInOut
[
0
]
aRawPixelInOut
[
1
]
aRawPixelInOut
[
2
]
)
;
aRawPixelInOut
+
=
4
;
return
AsVariant
(
pixel
)
;
}
static
NextPixel
<
uint32_t
>
PackUnpremultipliedRGBAPixelAndAdvance
(
uint8_t
*
&
aRawPixelInOut
)
{
const
uint32_t
pixel
=
gfxPackedPixelNoPreMultiply
(
aRawPixelInOut
[
3
]
aRawPixelInOut
[
0
]
aRawPixelInOut
[
1
]
aRawPixelInOut
[
2
]
)
;
aRawPixelInOut
+
=
4
;
return
AsVariant
(
pixel
)
;
}
void
nsPNGDecoder
:
:
row_callback
(
png_structp
png_ptr
png_bytep
new_row
png_uint_32
row_num
int
pass
)
{
nsPNGDecoder
*
decoder
=
static_cast
<
nsPNGDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
;
if
(
decoder
-
>
mFrameIsHidden
)
{
return
;
}
MOZ_ASSERT_IF
(
decoder
-
>
IsFirstFrameDecode
(
)
decoder
-
>
mNumFrames
=
=
0
)
;
while
(
pass
>
decoder
-
>
mPass
)
{
decoder
-
>
mPipe
.
ResetToFirstRow
(
)
;
decoder
-
>
mPass
+
+
;
}
const
png_uint_32
height
=
static_cast
<
png_uint_32
>
(
decoder
-
>
mFrameRect
.
height
)
;
if
(
row_num
>
=
height
)
{
MOZ_ASSERT_UNREACHABLE
(
"
libpng
producing
extra
rows
?
"
)
;
return
;
}
MOZ_ASSERT_IF
(
!
new_row
decoder
-
>
interlacebuf
)
;
uint8_t
*
rowToWrite
=
new_row
;
if
(
decoder
-
>
interlacebuf
)
{
uint32_t
width
=
uint32_t
(
decoder
-
>
mFrameRect
.
width
)
;
rowToWrite
=
decoder
-
>
interlacebuf
+
(
row_num
*
decoder
-
>
mChannels
*
width
)
;
png_progressive_combine_row
(
png_ptr
rowToWrite
new_row
)
;
}
decoder
-
>
WriteRow
(
rowToWrite
)
;
}
void
nsPNGDecoder
:
:
WriteRow
(
uint8_t
*
aRow
)
{
MOZ_ASSERT
(
aRow
)
;
uint8_t
*
rowToWrite
=
aRow
;
uint32_t
width
=
uint32_t
(
mFrameRect
.
width
)
;
if
(
mTransform
)
{
if
(
mCMSLine
)
{
qcms_transform_data
(
mTransform
rowToWrite
mCMSLine
width
)
;
if
(
mChannels
=
=
2
|
|
mChannels
=
=
4
)
{
for
(
uint32_t
i
=
0
;
i
<
width
;
+
+
i
)
{
mCMSLine
[
4
*
i
+
3
]
=
rowToWrite
[
mChannels
*
i
+
mChannels
-
1
]
;
}
}
rowToWrite
=
mCMSLine
;
}
else
{
qcms_transform_data
(
mTransform
rowToWrite
rowToWrite
width
)
;
}
}
DebugOnly
<
WriteState
>
result
=
WriteState
:
:
FAILURE
;
switch
(
format
)
{
case
SurfaceFormat
:
:
B8G8R8X8
:
result
=
mPipe
.
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
return
PackRGBPixelAndAdvance
(
rowToWrite
)
;
}
)
;
break
;
case
SurfaceFormat
:
:
B8G8R8A8
:
if
(
mDisablePremultipliedAlpha
)
{
result
=
mPipe
.
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
return
PackUnpremultipliedRGBAPixelAndAdvance
(
rowToWrite
)
;
}
)
;
}
else
{
result
=
mPipe
.
WritePixelsToRow
<
uint32_t
>
(
[
&
]
{
return
PackRGBAPixelAndAdvance
(
rowToWrite
)
;
}
)
;
}
break
;
default
:
png_longjmp
(
mPNG
1
)
;
}
MOZ_ASSERT
(
WriteState
(
result
)
!
=
WriteState
:
:
FAILURE
)
;
PostInvalidationIfNeeded
(
)
;
}
#
ifdef
PNG_APNG_SUPPORTED
void
nsPNGDecoder
:
:
frame_info_callback
(
png_structp
png_ptr
png_uint_32
frame_num
)
{
nsPNGDecoder
*
decoder
=
static_cast
<
nsPNGDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
;
decoder
-
>
EndImageFrame
(
)
;
if
(
!
decoder
-
>
mFrameIsHidden
&
&
decoder
-
>
IsFirstFrameDecode
(
)
)
{
decoder
-
>
PostDecodeDone
(
)
;
png_process_data_pause
(
png_ptr
false
)
;
return
;
}
decoder
-
>
mFrameIsHidden
=
false
;
const
IntRect
frameRect
(
png_get_next_frame_x_offset
(
png_ptr
decoder
-
>
mInfo
)
png_get_next_frame_y_offset
(
png_ptr
decoder
-
>
mInfo
)
png_get_next_frame_width
(
png_ptr
decoder
-
>
mInfo
)
png_get_next_frame_height
(
png_ptr
decoder
-
>
mInfo
)
)
;
const
bool
isInterlaced
=
bool
(
decoder
-
>
interlacebuf
)
;
nsresult
rv
=
decoder
-
>
CreateFrame
(
decoder
-
>
format
frameRect
isInterlaced
)
;
if
(
NS_FAILED
(
rv
)
)
{
png_longjmp
(
decoder
-
>
mPNG
5
)
;
}
MOZ_ASSERT
(
decoder
-
>
mImageData
"
Should
have
a
buffer
now
"
)
;
}
#
endif
void
nsPNGDecoder
:
:
end_callback
(
png_structp
png_ptr
png_infop
info_ptr
)
{
nsPNGDecoder
*
decoder
=
static_cast
<
nsPNGDecoder
*
>
(
png_get_progressive_ptr
(
png_ptr
)
)
;
MOZ_ASSERT
(
!
decoder
-
>
HasError
(
)
"
Finishing
up
PNG
but
hit
error
!
"
)
;
int32_t
loop_count
=
0
;
#
ifdef
PNG_APNG_SUPPORTED
if
(
png_get_valid
(
png_ptr
info_ptr
PNG_INFO_acTL
)
)
{
int32_t
num_plays
=
png_get_num_plays
(
png_ptr
info_ptr
)
;
loop_count
=
num_plays
-
1
;
}
#
endif
decoder
-
>
EndImageFrame
(
)
;
decoder
-
>
PostDecodeDone
(
loop_count
)
;
}
void
nsPNGDecoder
:
:
error_callback
(
png_structp
png_ptr
png_const_charp
error_msg
)
{
MOZ_LOG
(
sPNGLog
LogLevel
:
:
Error
(
"
libpng
error
:
%
s
\
n
"
error_msg
)
)
;
png_longjmp
(
png_ptr
1
)
;
}
void
nsPNGDecoder
:
:
warning_callback
(
png_structp
png_ptr
png_const_charp
warning_msg
)
{
MOZ_LOG
(
sPNGLog
LogLevel
:
:
Warning
(
"
libpng
warning
:
%
s
\
n
"
warning_msg
)
)
;
}
Telemetry
:
:
ID
nsPNGDecoder
:
:
SpeedHistogram
(
)
{
return
Telemetry
:
:
IMAGE_DECODE_SPEED_PNG
;
}
bool
nsPNGDecoder
:
:
IsValidICO
(
)
const
{
if
(
setjmp
(
png_jmpbuf
(
mPNG
)
)
)
{
return
false
;
}
png_uint_32
png_width
png_height
;
int
png_bit_depth
png_color_type
;
if
(
png_get_IHDR
(
mPNG
mInfo
&
png_width
&
png_height
&
png_bit_depth
&
png_color_type
nullptr
nullptr
nullptr
)
)
{
return
(
(
png_color_type
=
=
PNG_COLOR_TYPE_RGB_ALPHA
|
|
png_color_type
=
=
PNG_COLOR_TYPE_RGB
)
&
&
png_bit_depth
=
=
8
)
;
}
else
{
return
false
;
}
}
}
}
