#
include
"
nsIconChannel
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
unistd
.
h
>
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
ipc
/
ByteBuf
.
h
"
#
include
<
algorithm
>
#
include
<
gio
/
gio
.
h
>
#
include
<
gio
/
gdesktopappinfo
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIPipe
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
prlink
.
h
"
#
include
"
gfxPlatform
.
h
"
using
mozilla
:
:
CheckedInt32
;
using
mozilla
:
:
ipc
:
:
ByteBuf
;
NS_IMPL_ISUPPORTS
(
nsIconChannel
nsIRequest
nsIChannel
)
static
nsresult
MozGdkPixbufToByteBuf
(
GdkPixbuf
*
aPixbuf
ByteBuf
*
aByteBuf
)
{
int
width
=
gdk_pixbuf_get_width
(
aPixbuf
)
;
int
height
=
gdk_pixbuf_get_height
(
aPixbuf
)
;
NS_ENSURE_TRUE
(
height
<
256
&
&
width
<
256
&
&
height
>
0
&
&
width
>
0
&
&
gdk_pixbuf_get_colorspace
(
aPixbuf
)
=
=
GDK_COLORSPACE_RGB
&
&
gdk_pixbuf_get_bits_per_sample
(
aPixbuf
)
=
=
8
&
&
gdk_pixbuf_get_has_alpha
(
aPixbuf
)
&
&
gdk_pixbuf_get_n_channels
(
aPixbuf
)
=
=
4
NS_ERROR_UNEXPECTED
)
;
const
int
n_channels
=
4
;
CheckedInt32
buf_size
=
4
+
n_channels
*
CheckedInt32
(
height
)
*
CheckedInt32
(
width
)
;
if
(
!
buf_size
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint8_t
*
const
buf
=
(
uint8_t
*
)
moz_xmalloc
(
buf_size
.
value
(
)
)
;
uint8_t
*
out
=
buf
;
*
(
out
+
+
)
=
width
;
*
(
out
+
+
)
=
height
;
*
(
out
+
+
)
=
uint8_t
(
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
OS_RGBA
)
;
*
(
out
+
+
)
=
0xFF
;
const
guchar
*
const
pixels
=
gdk_pixbuf_get_pixels
(
aPixbuf
)
;
int
instride
=
gdk_pixbuf_get_rowstride
(
aPixbuf
)
;
int
outstride
=
width
*
n_channels
;
mozilla
:
:
gfx
:
:
SwizzleData
(
pixels
instride
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
out
outstride
mozilla
:
:
gfx
:
:
SurfaceFormat
:
:
OS_RGBA
mozilla
:
:
gfx
:
:
IntSize
(
width
height
)
)
;
*
aByteBuf
=
ByteBuf
(
buf
buf_size
.
value
(
)
buf_size
.
value
(
)
)
;
return
NS_OK
;
}
static
nsresult
ByteBufToStream
(
ByteBuf
&
&
aBuf
nsIInputStream
*
*
aStream
)
{
nsresult
rv
;
nsCOMPtr
<
nsIStringInputStream
>
stream
=
do_CreateInstance
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
stream
-
>
AdoptData
(
reinterpret_cast
<
char
*
>
(
aBuf
.
mData
)
aBuf
.
mLen
)
;
MOZ_ASSERT
(
CheckedInt32
(
aBuf
.
mLen
)
.
isValid
(
)
"
aBuf
.
mLen
should
fit
in
int32_t
"
)
;
aBuf
.
mData
=
nullptr
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
stream
.
forget
(
aStream
)
;
return
NS_OK
;
}
static
nsresult
StreamToChannel
(
already_AddRefed
<
nsIInputStream
>
aStream
nsIURI
*
aURI
nsIChannel
*
*
aChannel
)
{
nsCOMPtr
<
nsIPrincipal
>
nullPrincipal
=
mozilla
:
:
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
return
NS_NewInputStreamChannel
(
aChannel
aURI
std
:
:
move
(
aStream
)
nullPrincipal
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
nsLiteralCString
(
IMAGE_ICON_MS
)
)
;
}
static
GtkWidget
*
gProtoWindow
=
nullptr
;
static
GtkWidget
*
gStockImageWidget
=
nullptr
;
static
void
ensure_stock_image_widget
(
)
{
if
(
!
gProtoWindow
)
{
gProtoWindow
=
gtk_window_new
(
GTK_WINDOW_POPUP
)
;
GtkWidget
*
protoLayout
=
gtk_fixed_new
(
)
;
gtk_container_add
(
GTK_CONTAINER
(
gProtoWindow
)
protoLayout
)
;
gStockImageWidget
=
gtk_image_new
(
)
;
gtk_container_add
(
GTK_CONTAINER
(
protoLayout
)
gStockImageWidget
)
;
gtk_widget_ensure_style
(
gStockImageWidget
)
;
}
}
static
GtkIconSize
moz_gtk_icon_size
(
const
char
*
name
)
{
if
(
strcmp
(
name
"
button
"
)
=
=
0
)
{
return
GTK_ICON_SIZE_BUTTON
;
}
if
(
strcmp
(
name
"
menu
"
)
=
=
0
)
{
return
GTK_ICON_SIZE_MENU
;
}
if
(
strcmp
(
name
"
toolbar
"
)
=
=
0
)
{
return
GTK_ICON_SIZE_LARGE_TOOLBAR
;
}
if
(
strcmp
(
name
"
toolbarsmall
"
)
=
=
0
)
{
return
GTK_ICON_SIZE_SMALL_TOOLBAR
;
}
if
(
strcmp
(
name
"
dnd
"
)
=
=
0
)
{
return
GTK_ICON_SIZE_DND
;
}
if
(
strcmp
(
name
"
dialog
"
)
=
=
0
)
{
return
GTK_ICON_SIZE_DIALOG
;
}
return
GTK_ICON_SIZE_MENU
;
}
static
int32_t
GetIconSize
(
nsIMozIconURI
*
aIconURI
)
{
nsAutoCString
iconSizeString
;
aIconURI
-
>
GetIconSize
(
iconSizeString
)
;
if
(
iconSizeString
.
IsEmpty
(
)
)
{
uint32_t
size
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
aIconURI
-
>
GetImageSize
(
&
size
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetImageSize
failed
"
)
;
return
size
;
}
int
size
;
GtkIconSize
icon_size
=
moz_gtk_icon_size
(
iconSizeString
.
get
(
)
)
;
gtk_icon_size_lookup
(
icon_size
&
size
nullptr
)
;
return
size
;
}
static
nsresult
ScaleIconBuf
(
GdkPixbuf
*
*
aBuf
int32_t
iconSize
)
{
if
(
gdk_pixbuf_get_width
(
*
aBuf
)
!
=
iconSize
&
&
gdk_pixbuf_get_height
(
*
aBuf
)
!
=
iconSize
)
{
GdkPixbuf
*
scaled
=
gdk_pixbuf_scale_simple
(
*
aBuf
iconSize
iconSize
GDK_INTERP_BILINEAR
)
;
g_object_unref
(
*
aBuf
)
;
*
aBuf
=
scaled
;
if
(
!
scaled
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
nsresult
nsIconChannel
:
:
GetIconWithGIO
(
nsIMozIconURI
*
aIconURI
ByteBuf
*
aDataOut
)
{
GIcon
*
icon
=
nullptr
;
nsCOMPtr
<
nsIURL
>
fileURI
;
aIconURI
-
>
GetIconURL
(
getter_AddRefs
(
fileURI
)
)
;
if
(
fileURI
)
{
nsAutoCString
spec
;
fileURI
-
>
GetAsciiSpec
(
spec
)
;
if
(
fileURI
-
>
SchemeIs
(
"
file
"
)
)
{
GFile
*
file
=
g_file_new_for_uri
(
spec
.
get
(
)
)
;
GFileInfo
*
fileInfo
=
g_file_query_info
(
file
G_FILE_ATTRIBUTE_STANDARD_ICON
G_FILE_QUERY_INFO_NONE
nullptr
nullptr
)
;
g_object_unref
(
file
)
;
if
(
fileInfo
)
{
icon
=
g_file_info_get_icon
(
fileInfo
)
;
if
(
icon
)
{
g_object_ref
(
icon
)
;
}
g_object_unref
(
fileInfo
)
;
}
}
}
else
{
nsAutoCString
appId
;
aIconURI
-
>
GetAsciiSpec
(
appId
)
;
if
(
appId
.
Find
(
"
?
size
=
"
)
)
{
appId
.
Truncate
(
appId
.
Find
(
"
?
size
=
"
)
)
;
}
appId
=
Substring
(
appId
sizeof
(
"
moz
-
icon
:
/
"
)
)
;
GDesktopAppInfo
*
app_info
=
g_desktop_app_info_new
(
appId
.
get
(
)
)
;
if
(
app_info
)
{
icon
=
g_app_info_get_icon
(
(
GAppInfo
*
)
app_info
)
;
if
(
icon
)
{
g_object_ref
(
icon
)
;
}
g_object_unref
(
app_info
)
;
}
}
if
(
!
icon
)
{
nsAutoCString
type
;
aIconURI
-
>
GetContentType
(
type
)
;
if
(
type
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIMIMEService
>
ms
(
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
)
;
if
(
ms
)
{
nsAutoCString
fileExt
;
aIconURI
-
>
GetFileExtension
(
fileExt
)
;
ms
-
>
GetTypeFromExtension
(
fileExt
type
)
;
}
}
char
*
ctype
=
nullptr
;
if
(
!
type
.
IsEmpty
(
)
)
{
ctype
=
g_content_type_from_mime_type
(
type
.
get
(
)
)
;
}
if
(
ctype
)
{
icon
=
g_content_type_get_icon
(
ctype
)
;
g_free
(
ctype
)
;
}
}
GtkIconTheme
*
iconTheme
=
gtk_icon_theme_get_default
(
)
;
GtkIconInfo
*
iconInfo
=
nullptr
;
int32_t
iconSize
=
GetIconSize
(
aIconURI
)
;
if
(
icon
)
{
iconInfo
=
gtk_icon_theme_lookup_by_gicon
(
iconTheme
icon
iconSize
(
GtkIconLookupFlags
)
0
)
;
g_object_unref
(
icon
)
;
}
if
(
!
iconInfo
)
{
iconInfo
=
gtk_icon_theme_lookup_icon
(
iconTheme
"
unknown
"
iconSize
(
GtkIconLookupFlags
)
0
)
;
if
(
!
iconInfo
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
}
GdkPixbuf
*
buf
=
gtk_icon_info_load_icon
(
iconInfo
nullptr
)
;
gtk_icon_info_free
(
iconInfo
)
;
if
(
!
buf
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
ScaleIconBuf
(
&
buf
iconSize
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MozGdkPixbufToByteBuf
(
buf
aDataOut
)
;
g_object_unref
(
buf
)
;
return
rv
;
}
nsresult
nsIconChannel
:
:
GetIcon
(
nsIURI
*
aURI
ByteBuf
*
aDataOut
)
{
nsCOMPtr
<
nsIMozIconURI
>
iconURI
=
do_QueryInterface
(
aURI
)
;
NS_ASSERTION
(
iconURI
"
URI
is
not
an
nsIMozIconURI
"
)
;
if
(
!
iconURI
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
gfxPlatform
:
:
IsHeadless
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
stockIcon
;
iconURI
-
>
GetStockIcon
(
stockIcon
)
;
if
(
stockIcon
.
IsEmpty
(
)
)
{
return
GetIconWithGIO
(
iconURI
aDataOut
)
;
}
nsAutoCString
iconSizeString
;
iconURI
-
>
GetIconSize
(
iconSizeString
)
;
nsAutoCString
iconStateString
;
iconURI
-
>
GetIconState
(
iconStateString
)
;
GtkIconSize
icon_size
=
moz_gtk_icon_size
(
iconSizeString
.
get
(
)
)
;
GtkStateType
state
=
iconStateString
.
EqualsLiteral
(
"
disabled
"
)
?
GTK_STATE_INSENSITIVE
:
GTK_STATE_NORMAL
;
GtkTextDirection
direction
=
GTK_TEXT_DIR_NONE
;
if
(
StringEndsWith
(
stockIcon
"
-
ltr
"
_ns
)
)
{
direction
=
GTK_TEXT_DIR_LTR
;
}
else
if
(
StringEndsWith
(
stockIcon
"
-
rtl
"
_ns
)
)
{
direction
=
GTK_TEXT_DIR_RTL
;
}
bool
forceDirection
=
direction
!
=
GTK_TEXT_DIR_NONE
;
nsAutoCString
stockID
;
bool
useIconName
=
false
;
if
(
!
forceDirection
)
{
direction
=
gtk_widget_get_default_direction
(
)
;
stockID
=
stockIcon
;
}
else
{
stockID
=
Substring
(
stockIcon
0
stockIcon
.
Length
(
)
-
4
)
;
GtkIconTheme
*
icon_theme
=
gtk_icon_theme_get_default
(
)
;
gint
width
height
;
if
(
gtk_icon_size_lookup
(
icon_size
&
width
&
height
)
)
{
gint
size
=
std
:
:
min
(
width
height
)
;
GtkIconInfo
*
icon
=
gtk_icon_theme_lookup_icon
(
icon_theme
stockIcon
.
get
(
)
size
(
GtkIconLookupFlags
)
0
)
;
if
(
icon
)
{
useIconName
=
true
;
gtk_icon_info_free
(
icon
)
;
}
}
}
ensure_stock_image_widget
(
)
;
GtkStyle
*
style
=
gtk_widget_get_style
(
gStockImageWidget
)
;
GtkIconSet
*
icon_set
=
nullptr
;
if
(
!
useIconName
)
{
icon_set
=
gtk_style_lookup_icon_set
(
style
stockID
.
get
(
)
)
;
}
if
(
!
icon_set
)
{
useIconName
=
true
;
icon_set
=
gtk_icon_set_new
(
)
;
GtkIconSource
*
icon_source
=
gtk_icon_source_new
(
)
;
gtk_icon_source_set_icon_name
(
icon_source
stockIcon
.
get
(
)
)
;
gtk_icon_set_add_source
(
icon_set
icon_source
)
;
gtk_icon_source_free
(
icon_source
)
;
}
GdkPixbuf
*
icon
=
gtk_icon_set_render_icon
(
icon_set
style
direction
state
icon_size
gStockImageWidget
nullptr
)
;
if
(
useIconName
)
{
gtk_icon_set_unref
(
icon_set
)
;
}
if
(
!
icon
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsresult
rv
=
MozGdkPixbufToByteBuf
(
icon
aDataOut
)
;
g_object_unref
(
icon
)
;
return
rv
;
}
nsresult
nsIconChannel
:
:
Init
(
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
using
ContentChild
=
mozilla
:
:
dom
:
:
ContentChild
;
if
(
auto
*
contentChild
=
ContentChild
:
:
GetSingleton
(
)
)
{
RefPtr
<
ContentChild
:
:
GetSystemIconPromise
>
icon
=
contentChild
-
>
SendGetSystemIcon
(
aURI
)
;
if
(
!
icon
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIAsyncInputStream
>
inputStream
;
nsCOMPtr
<
nsIAsyncOutputStream
>
outputStream
;
NS_NewPipe2
(
getter_AddRefs
(
inputStream
)
getter_AddRefs
(
outputStream
)
true
false
0
UINT32_MAX
)
;
icon
-
>
Then
(
mozilla
:
:
GetCurrentSerialEventTarget
(
)
__func__
[
outputStream
]
(
std
:
:
tuple
<
nsresult
mozilla
:
:
Maybe
<
ByteBuf
>
>
&
&
aArg
)
{
nsresult
rv
=
std
:
:
get
<
0
>
(
aArg
)
;
mozilla
:
:
Maybe
<
ByteBuf
>
bytes
=
std
:
:
move
(
std
:
:
get
<
1
>
(
aArg
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_RELEASE_ASSERT
(
bytes
)
;
uint32_t
written
;
rv
=
outputStream
-
>
Write
(
reinterpret_cast
<
char
*
>
(
bytes
-
>
mData
)
static_cast
<
uint32_t
>
(
bytes
-
>
mLen
)
&
written
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
const
bool
wroteAll
=
static_cast
<
size_t
>
(
written
)
=
=
bytes
-
>
mLen
;
MOZ_ASSERT
(
wroteAll
)
;
if
(
!
wroteAll
)
{
rv
=
NS_ERROR_UNEXPECTED
;
}
}
}
else
{
MOZ_ASSERT
(
!
bytes
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
outputStream
-
>
CloseWithStatus
(
rv
)
;
}
}
[
outputStream
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
outputStream
-
>
CloseWithStatus
(
NS_ERROR_FAILURE
)
;
}
)
;
stream
=
inputStream
.
forget
(
)
;
}
else
{
ByteBuf
bytebuf
;
nsresult
rv
=
GetIcon
(
aURI
&
bytebuf
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
ByteBufToStream
(
std
:
:
move
(
bytebuf
)
getter_AddRefs
(
stream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
StreamToChannel
(
stream
.
forget
(
)
aURI
getter_AddRefs
(
mRealChannel
)
)
;
}
void
nsIconChannel
:
:
Shutdown
(
)
{
if
(
gProtoWindow
)
{
gtk_widget_destroy
(
gProtoWindow
)
;
gProtoWindow
=
nullptr
;
gStockImageWidget
=
nullptr
;
}
}
