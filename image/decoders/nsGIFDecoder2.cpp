#
include
<
stddef
.
h
>
#
include
"
imgFrame
.
h
"
#
include
"
nsGIFDecoder2
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
SurfaceFilters
.
h
"
#
include
"
SurfacePipeFactory
.
h
"
#
include
"
gfxColor
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
qcms
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Telemetry
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
image
{
#
define
GETN
(
n
s
)
\
PR_BEGIN_MACRO
\
mGIFStruct
.
bytes_to_consume
=
(
n
)
;
\
mGIFStruct
.
state
=
(
s
)
;
\
PR_END_MACRO
#
define
GETINT16
(
p
)
(
(
p
)
[
1
]
<
<
8
|
(
p
)
[
0
]
)
nsGIFDecoder2
:
:
nsGIFDecoder2
(
RasterImage
*
aImage
)
:
Decoder
(
aImage
)
mOldColor
(
0
)
mCurrentFrameIndex
(
-
1
)
mGIFOpen
(
false
)
mSawTransparency
(
false
)
{
memset
(
&
mGIFStruct
0
sizeof
(
mGIFStruct
)
)
;
mGIFStruct
.
loop_count
=
1
;
mGIFStruct
.
state
=
gif_type
;
mGIFStruct
.
bytes_to_consume
=
6
;
}
nsGIFDecoder2
:
:
~
nsGIFDecoder2
(
)
{
free
(
mGIFStruct
.
local_colormap
)
;
free
(
mGIFStruct
.
hold
)
;
}
void
nsGIFDecoder2
:
:
FinishInternal
(
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
FinishInternal
after
error
!
"
)
;
if
(
!
IsMetadataDecode
(
)
&
&
mGIFOpen
)
{
if
(
mCurrentFrameIndex
=
=
mGIFStruct
.
images_decoded
)
{
EndImageFrame
(
)
;
}
PostDecodeDone
(
mGIFStruct
.
loop_count
-
1
)
;
mGIFOpen
=
false
;
}
}
void
nsGIFDecoder2
:
:
FlushImageData
(
)
{
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
mPipe
.
TakeInvalidRect
(
)
;
if
(
!
invalidRect
)
{
return
;
}
PostInvalidation
(
invalidRect
-
>
mInputSpaceRect
Some
(
invalidRect
-
>
mOutputSpaceRect
)
)
;
}
void
nsGIFDecoder2
:
:
BeginGIF
(
)
{
if
(
mGIFOpen
)
{
return
;
}
mGIFOpen
=
true
;
PostSize
(
mGIFStruct
.
screen_width
mGIFStruct
.
screen_height
)
;
}
bool
nsGIFDecoder2
:
:
CheckForTransparency
(
const
IntRect
&
aFrameRect
)
{
if
(
mGIFStruct
.
is_transparent
)
{
PostHasTransparency
(
)
;
return
true
;
}
if
(
mGIFStruct
.
images_decoded
>
0
)
{
return
false
;
}
IntRect
imageRect
(
0
0
mGIFStruct
.
screen_width
mGIFStruct
.
screen_height
)
;
if
(
!
imageRect
.
IsEqualEdges
(
aFrameRect
)
)
{
PostHasTransparency
(
)
;
mSawTransparency
=
true
;
return
true
;
}
return
false
;
}
IntRect
nsGIFDecoder2
:
:
ClampToImageRect
(
const
IntRect
&
aRect
)
{
IntRect
imageRect
(
0
0
mGIFStruct
.
screen_width
mGIFStruct
.
screen_height
)
;
IntRect
visibleFrameRect
=
aRect
.
Intersect
(
imageRect
)
;
if
(
visibleFrameRect
.
IsEmpty
(
)
)
{
visibleFrameRect
.
MoveTo
(
0
0
)
;
}
return
visibleFrameRect
;
}
nsresult
nsGIFDecoder2
:
:
BeginImageFrame
(
const
IntRect
&
aFrameRect
uint16_t
aDepth
bool
aIsInterlaced
)
{
MOZ_ASSERT
(
HasSize
(
)
)
;
bool
hasTransparency
=
CheckForTransparency
(
aFrameRect
)
;
gfx
:
:
SurfaceFormat
format
=
hasTransparency
?
SurfaceFormat
:
:
B8G8R8A8
:
SurfaceFormat
:
:
B8G8R8X8
;
MOZ_ASSERT_IF
(
mDownscaler
!
GetImageMetadata
(
)
.
HasAnimation
(
)
)
;
SurfacePipeFlags
pipeFlags
=
aIsInterlaced
?
SurfacePipeFlags
:
:
DEINTERLACE
:
SurfacePipeFlags
(
)
;
Maybe
<
SurfacePipe
>
pipe
;
if
(
mGIFStruct
.
images_decoded
=
=
0
)
{
IntSize
targetSize
=
mDownscaler
?
mDownscaler
-
>
TargetSize
(
)
:
GetSize
(
)
;
pipeFlags
|
=
SurfacePipeFlags
:
:
PROGRESSIVE_DISPLAY
;
pipe
=
SurfacePipeFactory
:
:
CreateSurfacePipe
(
this
mGIFStruct
.
images_decoded
GetSize
(
)
targetSize
aFrameRect
format
pipeFlags
)
;
}
else
{
MOZ_ASSERT
(
!
mDownscaler
)
;
pipe
=
SurfacePipeFactory
:
:
CreatePalettedSurfacePipe
(
this
mGIFStruct
.
images_decoded
GetSize
(
)
aFrameRect
format
aDepth
pipeFlags
)
;
}
mCurrentFrameIndex
=
mGIFStruct
.
images_decoded
;
if
(
!
pipe
)
{
mPipe
=
SurfacePipe
(
)
;
return
NS_ERROR_FAILURE
;
}
mPipe
=
Move
(
*
pipe
)
;
return
NS_OK
;
}
void
nsGIFDecoder2
:
:
EndImageFrame
(
)
{
Opacity
opacity
=
Opacity
:
:
SOME_TRANSPARENCY
;
if
(
mGIFStruct
.
images_decoded
=
=
0
)
{
FlushImageData
(
)
;
if
(
!
mGIFStruct
.
is_transparent
&
&
!
mSawTransparency
)
{
opacity
=
Opacity
:
:
FULLY_OPAQUE
;
}
}
mGIFStruct
.
images_decoded
+
+
;
PostFrameStop
(
opacity
DisposalMethod
(
mGIFStruct
.
disposal_method
)
mGIFStruct
.
delay_time
)
;
if
(
mOldColor
)
{
mColormap
[
mGIFStruct
.
tpixel
]
=
mOldColor
;
mOldColor
=
0
;
}
mCurrentFrameIndex
=
-
1
;
}
template
<
typename
PixelSize
>
PixelSize
nsGIFDecoder2
:
:
ColormapIndexToPixel
(
uint8_t
aIndex
)
{
MOZ_ASSERT
(
sizeof
(
PixelSize
)
=
=
sizeof
(
uint32_t
)
)
;
uint32_t
color
=
mColormap
[
aIndex
&
mColorMask
]
;
if
(
mGIFStruct
.
is_transparent
)
{
mSawTransparency
=
mSawTransparency
|
|
color
=
=
0
;
}
return
color
;
}
template
<
>
uint8_t
nsGIFDecoder2
:
:
ColormapIndexToPixel
<
uint8_t
>
(
uint8_t
aIndex
)
{
return
aIndex
&
mColorMask
;
}
template
<
typename
PixelSize
>
NextPixel
<
PixelSize
>
nsGIFDecoder2
:
:
YieldPixel
(
const
uint8_t
*
&
aCurrentByteInOut
)
{
MOZ_ASSERT
(
mGIFStruct
.
stackp
>
=
mGIFStruct
.
stack
)
;
if
(
mGIFStruct
.
stackp
=
=
mGIFStruct
.
stack
)
{
while
(
mGIFStruct
.
bits
<
mGIFStruct
.
codesize
&
&
mGIFStruct
.
count
>
0
)
{
mGIFStruct
.
datum
+
=
int32_t
(
*
aCurrentByteInOut
)
<
<
mGIFStruct
.
bits
;
mGIFStruct
.
bits
+
=
8
;
+
+
aCurrentByteInOut
;
-
-
mGIFStruct
.
count
;
}
if
(
mGIFStruct
.
bits
<
mGIFStruct
.
codesize
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
int
code
=
mGIFStruct
.
datum
&
mGIFStruct
.
codemask
;
mGIFStruct
.
datum
>
>
=
mGIFStruct
.
codesize
;
mGIFStruct
.
bits
-
=
mGIFStruct
.
codesize
;
const
int
clearCode
=
ClearCode
(
)
;
if
(
code
=
=
clearCode
)
{
mGIFStruct
.
codesize
=
mGIFStruct
.
datasize
+
1
;
mGIFStruct
.
codemask
=
(
1
<
<
mGIFStruct
.
codesize
)
-
1
;
mGIFStruct
.
avail
=
clearCode
+
2
;
mGIFStruct
.
oldcode
=
-
1
;
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
if
(
code
=
=
(
clearCode
+
1
)
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
if
(
mGIFStruct
.
oldcode
=
=
-
1
)
{
if
(
code
>
=
MAX_BITS
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
mGIFStruct
.
firstchar
=
mGIFStruct
.
oldcode
=
code
;
mGIFStruct
.
pixels_remaining
-
-
;
return
AsVariant
(
ColormapIndexToPixel
<
PixelSize
>
(
mGIFStruct
.
suffix
[
code
]
)
)
;
}
int
incode
=
code
;
if
(
code
>
=
mGIFStruct
.
avail
)
{
*
mGIFStruct
.
stackp
+
+
=
mGIFStruct
.
firstchar
;
code
=
mGIFStruct
.
oldcode
;
if
(
mGIFStruct
.
stackp
>
=
mGIFStruct
.
stack
+
MAX_BITS
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
}
while
(
code
>
=
clearCode
)
{
if
(
(
code
>
=
MAX_BITS
)
|
|
(
code
=
=
mGIFStruct
.
prefix
[
code
]
)
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
*
mGIFStruct
.
stackp
+
+
=
mGIFStruct
.
suffix
[
code
]
;
code
=
mGIFStruct
.
prefix
[
code
]
;
if
(
mGIFStruct
.
stackp
>
=
mGIFStruct
.
stack
+
MAX_BITS
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
}
*
mGIFStruct
.
stackp
+
+
=
mGIFStruct
.
firstchar
=
mGIFStruct
.
suffix
[
code
]
;
if
(
mGIFStruct
.
avail
<
4096
)
{
mGIFStruct
.
prefix
[
mGIFStruct
.
avail
]
=
mGIFStruct
.
oldcode
;
mGIFStruct
.
suffix
[
mGIFStruct
.
avail
]
=
mGIFStruct
.
firstchar
;
mGIFStruct
.
avail
+
+
;
if
(
(
(
mGIFStruct
.
avail
&
mGIFStruct
.
codemask
)
=
=
0
)
&
&
(
mGIFStruct
.
avail
<
4096
)
)
{
mGIFStruct
.
codesize
+
+
;
mGIFStruct
.
codemask
+
=
mGIFStruct
.
avail
;
}
}
mGIFStruct
.
oldcode
=
incode
;
}
if
(
MOZ_UNLIKELY
(
mGIFStruct
.
stackp
<
=
mGIFStruct
.
stack
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
decoded
data
but
we
didn
'
t
return
early
?
"
)
;
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
mGIFStruct
.
pixels_remaining
-
-
;
return
AsVariant
(
ColormapIndexToPixel
<
PixelSize
>
(
*
-
-
mGIFStruct
.
stackp
)
)
;
}
bool
nsGIFDecoder2
:
:
DoLzw
(
const
uint8_t
*
aData
)
{
const
uint8_t
*
currentByte
=
aData
;
while
(
mGIFStruct
.
count
>
0
&
&
mGIFStruct
.
pixels_remaining
>
0
)
{
auto
result
=
mGIFStruct
.
images_decoded
>
0
?
mPipe
.
WritePixels
<
uint8_t
>
(
[
&
]
(
)
{
return
YieldPixel
<
uint8_t
>
(
currentByte
)
;
}
)
:
mPipe
.
WritePixels
<
uint32_t
>
(
[
&
]
(
)
{
return
YieldPixel
<
uint32_t
>
(
currentByte
)
;
}
)
;
switch
(
result
)
{
case
WriteState
:
:
NEED_MORE_DATA
:
continue
;
case
WriteState
:
:
FINISHED
:
NS_WARN_IF
(
mGIFStruct
.
pixels_remaining
>
0
)
;
mGIFStruct
.
pixels_remaining
=
0
;
return
true
;
case
WriteState
:
:
FAILURE
:
return
false
;
}
}
return
true
;
}
static
void
ConvertColormap
(
uint32_t
*
aColormap
uint32_t
aColors
)
{
if
(
gfxPlatform
:
:
GetCMSMode
(
)
=
=
eCMSMode_All
)
{
qcms_transform
*
transform
=
gfxPlatform
:
:
GetCMSRGBTransform
(
)
;
if
(
transform
)
{
qcms_transform_data
(
transform
aColormap
aColormap
aColors
)
;
}
}
uint8_t
*
from
=
(
(
uint8_t
*
)
aColormap
)
+
3
*
aColors
;
uint32_t
*
to
=
aColormap
+
aColors
;
if
(
!
aColors
)
{
return
;
}
uint32_t
c
=
aColors
;
for
(
;
(
NS_PTR_TO_UINT32
(
from
)
&
0x3
)
&
&
c
;
-
-
c
)
{
from
-
=
3
;
*
-
-
to
=
gfxPackedPixel
(
0xFF
from
[
0
]
from
[
1
]
from
[
2
]
)
;
}
while
(
c
>
=
4
)
{
from
-
=
12
;
to
-
=
4
;
c
-
=
4
;
GFX_BLOCK_RGB_TO_FRGB
(
from
to
)
;
}
while
(
c
-
-
)
{
from
-
=
3
;
*
-
-
to
=
gfxPackedPixel
(
0xFF
from
[
0
]
from
[
1
]
from
[
2
]
)
;
}
}
void
nsGIFDecoder2
:
:
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
WriteInternal
after
error
!
"
)
;
const
uint8_t
*
buf
=
(
const
uint8_t
*
)
aBuffer
;
uint32_t
len
=
aCount
;
const
uint8_t
*
q
=
buf
;
uint8_t
*
p
=
(
mGIFStruct
.
state
=
=
gif_global_colormap
)
?
(
uint8_t
*
)
mGIFStruct
.
global_colormap
:
(
mGIFStruct
.
state
=
=
gif_image_colormap
)
?
(
uint8_t
*
)
mColormap
:
(
mGIFStruct
.
bytes_in_hold
)
?
mGIFStruct
.
hold
:
nullptr
;
if
(
len
=
=
0
&
&
buf
=
=
nullptr
)
{
len
=
mGIFStruct
.
bytes_in_hold
;
q
=
buf
=
p
;
}
else
if
(
p
)
{
uint32_t
l
=
std
:
:
min
(
len
mGIFStruct
.
bytes_to_consume
)
;
memcpy
(
p
+
mGIFStruct
.
bytes_in_hold
buf
l
)
;
if
(
l
<
mGIFStruct
.
bytes_to_consume
)
{
mGIFStruct
.
bytes_in_hold
+
=
l
;
mGIFStruct
.
bytes_to_consume
-
=
l
;
return
;
}
q
=
p
;
}
for
(
;
len
>
=
mGIFStruct
.
bytes_to_consume
;
q
=
buf
mGIFStruct
.
bytes_in_hold
=
0
)
{
buf
+
=
mGIFStruct
.
bytes_to_consume
;
len
-
=
mGIFStruct
.
bytes_to_consume
;
switch
(
mGIFStruct
.
state
)
{
case
gif_lzw
:
if
(
!
DoLzw
(
q
)
)
{
mGIFStruct
.
state
=
gif_error
;
break
;
}
GETN
(
1
gif_sub_block
)
;
break
;
case
gif_lzw_start
:
{
if
(
mGIFStruct
.
is_transparent
)
{
if
(
mColormap
=
=
mGIFStruct
.
global_colormap
)
{
mOldColor
=
mColormap
[
mGIFStruct
.
tpixel
]
;
}
mColormap
[
mGIFStruct
.
tpixel
]
=
0
;
}
mGIFStruct
.
datasize
=
*
q
;
const
int
clear_code
=
ClearCode
(
)
;
if
(
mGIFStruct
.
datasize
>
MAX_LZW_BITS
|
|
clear_code
>
=
MAX_BITS
)
{
mGIFStruct
.
state
=
gif_error
;
break
;
}
mGIFStruct
.
avail
=
clear_code
+
2
;
mGIFStruct
.
oldcode
=
-
1
;
mGIFStruct
.
codesize
=
mGIFStruct
.
datasize
+
1
;
mGIFStruct
.
codemask
=
(
1
<
<
mGIFStruct
.
codesize
)
-
1
;
mGIFStruct
.
datum
=
mGIFStruct
.
bits
=
0
;
for
(
int
i
=
0
;
i
<
clear_code
;
i
+
+
)
{
mGIFStruct
.
suffix
[
i
]
=
i
;
}
mGIFStruct
.
stackp
=
mGIFStruct
.
stack
;
GETN
(
1
gif_sub_block
)
;
}
break
;
case
gif_type
:
if
(
!
strncmp
(
(
char
*
)
q
"
GIF89a
"
6
)
)
{
mGIFStruct
.
version
=
89
;
}
else
if
(
!
strncmp
(
(
char
*
)
q
"
GIF87a
"
6
)
)
{
mGIFStruct
.
version
=
87
;
}
else
{
mGIFStruct
.
state
=
gif_error
;
break
;
}
GETN
(
7
gif_global_header
)
;
break
;
case
gif_global_header
:
mGIFStruct
.
screen_width
=
GETINT16
(
q
)
;
mGIFStruct
.
screen_height
=
GETINT16
(
q
+
2
)
;
mGIFStruct
.
global_colormap_depth
=
(
q
[
4
]
&
0x07
)
+
1
;
if
(
q
[
4
]
&
0x80
)
{
const
uint32_t
size
=
(
3
<
<
mGIFStruct
.
global_colormap_depth
)
;
if
(
len
<
size
)
{
GETN
(
size
gif_global_colormap
)
;
break
;
}
memcpy
(
mGIFStruct
.
global_colormap
buf
size
)
;
buf
+
=
size
;
len
-
=
size
;
GETN
(
0
gif_global_colormap
)
;
break
;
}
GETN
(
1
gif_image_start
)
;
break
;
case
gif_global_colormap
:
ConvertColormap
(
mGIFStruct
.
global_colormap
1
<
<
mGIFStruct
.
global_colormap_depth
)
;
GETN
(
1
gif_image_start
)
;
break
;
case
gif_image_start
:
switch
(
*
q
)
{
case
GIF_TRAILER
:
if
(
IsMetadataDecode
(
)
)
{
return
;
}
mGIFStruct
.
state
=
gif_done
;
break
;
case
GIF_EXTENSION_INTRODUCER
:
GETN
(
2
gif_extension
)
;
break
;
case
GIF_IMAGE_SEPARATOR
:
GETN
(
9
gif_image_header
)
;
break
;
default
:
if
(
mGIFStruct
.
images_decoded
>
0
)
{
mGIFStruct
.
state
=
gif_done
;
}
else
{
mGIFStruct
.
state
=
gif_error
;
}
}
break
;
case
gif_extension
:
mGIFStruct
.
bytes_to_consume
=
q
[
1
]
;
if
(
mGIFStruct
.
bytes_to_consume
)
{
switch
(
*
q
)
{
case
GIF_GRAPHIC_CONTROL_LABEL
:
mGIFStruct
.
state
=
gif_control_extension
;
mGIFStruct
.
bytes_to_consume
=
std
:
:
max
(
mGIFStruct
.
bytes_to_consume
4u
)
;
break
;
case
GIF_APPLICATION_EXTENSION_LABEL
:
mGIFStruct
.
state
=
gif_application_extension
;
break
;
case
GIF_PLAIN_TEXT_LABEL
:
mGIFStruct
.
state
=
gif_skip_block
;
break
;
case
GIF_COMMENT_LABEL
:
mGIFStruct
.
state
=
gif_consume_comment
;
break
;
default
:
mGIFStruct
.
state
=
gif_skip_block
;
}
}
else
{
GETN
(
1
gif_image_start
)
;
}
break
;
case
gif_consume_block
:
if
(
!
*
q
)
{
GETN
(
1
gif_image_start
)
;
}
else
{
GETN
(
*
q
gif_skip_block
)
;
}
break
;
case
gif_skip_block
:
GETN
(
1
gif_consume_block
)
;
break
;
case
gif_control_extension
:
mGIFStruct
.
is_transparent
=
*
q
&
0x1
;
mGIFStruct
.
tpixel
=
q
[
3
]
;
mGIFStruct
.
disposal_method
=
(
(
*
q
)
>
>
2
)
&
0x7
;
if
(
mGIFStruct
.
disposal_method
=
=
4
)
{
mGIFStruct
.
disposal_method
=
3
;
}
else
if
(
mGIFStruct
.
disposal_method
>
4
)
{
mGIFStruct
.
disposal_method
=
0
;
}
{
DisposalMethod
method
=
DisposalMethod
(
mGIFStruct
.
disposal_method
)
;
if
(
method
=
=
DisposalMethod
:
:
CLEAR_ALL
|
|
method
=
=
DisposalMethod
:
:
CLEAR
)
{
PostHasTransparency
(
)
;
}
}
mGIFStruct
.
delay_time
=
GETINT16
(
q
+
1
)
*
10
;
if
(
mGIFStruct
.
delay_time
>
0
)
{
PostIsAnimated
(
mGIFStruct
.
delay_time
)
;
}
GETN
(
1
gif_consume_block
)
;
break
;
case
gif_comment_extension
:
if
(
*
q
)
{
GETN
(
*
q
gif_consume_comment
)
;
}
else
{
GETN
(
1
gif_image_start
)
;
}
break
;
case
gif_consume_comment
:
GETN
(
1
gif_comment_extension
)
;
break
;
case
gif_application_extension
:
if
(
mGIFStruct
.
bytes_to_consume
=
=
11
&
&
(
!
strncmp
(
(
char
*
)
q
"
NETSCAPE2
.
0
"
11
)
|
|
!
strncmp
(
(
char
*
)
q
"
ANIMEXTS1
.
0
"
11
)
)
)
{
GETN
(
1
gif_netscape_extension_block
)
;
}
else
{
GETN
(
1
gif_consume_block
)
;
}
break
;
case
gif_netscape_extension_block
:
if
(
*
q
)
{
GETN
(
std
:
:
max
(
3
static_cast
<
int
>
(
*
q
)
)
gif_consume_netscape_extension
)
;
}
else
{
GETN
(
1
gif_image_start
)
;
}
break
;
case
gif_consume_netscape_extension
:
switch
(
q
[
0
]
&
7
)
{
case
1
:
mGIFStruct
.
loop_count
=
GETINT16
(
q
+
1
)
;
GETN
(
1
gif_netscape_extension_block
)
;
break
;
case
2
:
GETN
(
1
gif_netscape_extension_block
)
;
break
;
default
:
mGIFStruct
.
state
=
gif_error
;
}
break
;
case
gif_image_header
:
{
if
(
mGIFStruct
.
images_decoded
=
=
1
)
{
if
(
!
HasAnimation
(
)
)
{
PostIsAnimated
(
0
)
;
}
if
(
IsFirstFrameDecode
(
)
)
{
mGIFStruct
.
state
=
gif_done
;
break
;
}
if
(
mDownscaler
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Doing
downscale
-
during
-
decode
"
"
for
an
animated
image
?
"
)
;
mDownscaler
.
reset
(
)
;
}
}
IntRect
frameRect
;
frameRect
.
x
=
GETINT16
(
q
)
;
frameRect
.
y
=
GETINT16
(
q
+
2
)
;
frameRect
.
width
=
GETINT16
(
q
+
4
)
;
frameRect
.
height
=
GETINT16
(
q
+
6
)
;
if
(
!
mGIFStruct
.
images_decoded
)
{
if
(
(
mGIFStruct
.
screen_height
<
frameRect
.
height
)
|
|
(
mGIFStruct
.
screen_width
<
frameRect
.
width
)
|
|
(
mGIFStruct
.
version
=
=
87
)
)
{
mGIFStruct
.
screen_height
=
frameRect
.
height
;
mGIFStruct
.
screen_width
=
frameRect
.
width
;
frameRect
.
MoveTo
(
0
0
)
;
}
BeginGIF
(
)
;
if
(
HasError
(
)
)
{
mGIFStruct
.
state
=
gif_error
;
return
;
}
if
(
IsMetadataDecode
(
)
)
{
CheckForTransparency
(
frameRect
)
;
return
;
}
}
if
(
!
frameRect
.
height
|
|
!
frameRect
.
width
)
{
frameRect
.
height
=
mGIFStruct
.
screen_height
;
frameRect
.
width
=
mGIFStruct
.
screen_width
;
if
(
!
frameRect
.
height
|
|
!
frameRect
.
width
)
{
mGIFStruct
.
state
=
gif_error
;
break
;
}
}
uint32_t
depth
=
mGIFStruct
.
global_colormap_depth
;
if
(
q
[
8
]
&
0x80
)
{
depth
=
(
q
[
8
]
&
0x07
)
+
1
;
}
uint32_t
realDepth
=
depth
;
while
(
mGIFStruct
.
tpixel
>
=
(
1
<
<
realDepth
)
&
&
(
realDepth
<
8
)
)
{
realDepth
+
+
;
}
mColorMask
=
0xFF
>
>
(
8
-
realDepth
)
;
const
bool
isInterlaced
=
q
[
8
]
&
0x40
;
if
(
NS_FAILED
(
BeginImageFrame
(
frameRect
realDepth
isInterlaced
)
)
)
{
mGIFStruct
.
state
=
gif_error
;
return
;
}
memset
(
mImageData
0
mImageDataLength
)
;
if
(
mColormap
)
{
memset
(
mColormap
0
mColormapSize
)
;
}
mGIFStruct
.
pixels_remaining
=
frameRect
.
width
*
frameRect
.
height
;
if
(
q
[
8
]
&
0x80
)
{
mGIFStruct
.
local_colormap_size
=
1
<
<
depth
;
if
(
!
mGIFStruct
.
images_decoded
)
{
mColormapSize
=
sizeof
(
uint32_t
)
<
<
realDepth
;
if
(
!
mGIFStruct
.
local_colormap
)
{
mGIFStruct
.
local_colormap
=
(
uint32_t
*
)
moz_xmalloc
(
mColormapSize
)
;
}
mColormap
=
mGIFStruct
.
local_colormap
;
}
const
uint32_t
size
=
3
<
<
depth
;
if
(
mColormapSize
>
size
)
{
memset
(
(
(
uint8_t
*
)
mColormap
)
+
size
0
mColormapSize
-
size
)
;
}
if
(
len
<
size
)
{
GETN
(
size
gif_image_colormap
)
;
break
;
}
memcpy
(
mColormap
buf
size
)
;
buf
+
=
size
;
len
-
=
size
;
GETN
(
0
gif_image_colormap
)
;
break
;
}
else
{
if
(
mGIFStruct
.
images_decoded
)
{
memcpy
(
mColormap
mGIFStruct
.
global_colormap
mColormapSize
)
;
}
else
{
mColormap
=
mGIFStruct
.
global_colormap
;
}
}
GETN
(
1
gif_lzw_start
)
;
}
break
;
case
gif_image_colormap
:
ConvertColormap
(
mColormap
mGIFStruct
.
local_colormap_size
)
;
GETN
(
1
gif_lzw_start
)
;
break
;
case
gif_sub_block
:
mGIFStruct
.
count
=
*
q
;
if
(
mGIFStruct
.
count
)
{
if
(
mGIFStruct
.
pixels_remaining
<
=
0
)
{
#
ifdef
DONT_TOLERATE_BROKEN_GIFS
mGIFStruct
.
state
=
gif_error
;
break
;
#
else
GETN
(
1
gif_sub_block
)
;
#
endif
if
(
mGIFStruct
.
count
=
=
GIF_TRAILER
)
{
GETN
(
1
gif_done
)
;
break
;
}
}
GETN
(
mGIFStruct
.
count
gif_lzw
)
;
}
else
{
EndImageFrame
(
)
;
GETN
(
1
gif_image_start
)
;
}
break
;
case
gif_done
:
MOZ_ASSERT
(
!
IsMetadataDecode
(
)
"
Metadata
decodes
shouldn
'
t
reach
gif_done
"
)
;
FinishInternal
(
)
;
goto
done
;
case
gif_error
:
PostDataError
(
)
;
return
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
mGIFStruct
.
state
"
)
;
PostDecoderError
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
}
if
(
mGIFStruct
.
state
=
=
gif_error
)
{
PostDataError
(
)
;
return
;
}
if
(
len
)
{
if
(
mGIFStruct
.
state
!
=
gif_global_colormap
&
&
mGIFStruct
.
state
!
=
gif_image_colormap
)
{
if
(
!
SetHold
(
buf
len
)
)
{
PostDataError
(
)
;
return
;
}
}
else
{
uint8_t
*
p
=
(
mGIFStruct
.
state
=
=
gif_global_colormap
)
?
(
uint8_t
*
)
mGIFStruct
.
global_colormap
:
(
uint8_t
*
)
mColormap
;
memcpy
(
p
buf
len
)
;
mGIFStruct
.
bytes_in_hold
=
len
;
}
mGIFStruct
.
bytes_to_consume
-
=
len
;
}
done
:
if
(
!
mGIFStruct
.
images_decoded
)
{
FlushImageData
(
)
;
}
}
bool
nsGIFDecoder2
:
:
SetHold
(
const
uint8_t
*
buf1
uint32_t
count1
const
uint8_t
*
buf2
uint32_t
count2
)
{
uint8_t
*
newHold
=
(
uint8_t
*
)
malloc
(
std
:
:
max
(
uint32_t
(
MIN_HOLD_SIZE
)
count1
+
count2
)
)
;
if
(
!
newHold
)
{
mGIFStruct
.
state
=
gif_error
;
return
false
;
}
memcpy
(
newHold
buf1
count1
)
;
if
(
buf2
)
{
memcpy
(
newHold
+
count1
buf2
count2
)
;
}
free
(
mGIFStruct
.
hold
)
;
mGIFStruct
.
hold
=
newHold
;
mGIFStruct
.
bytes_in_hold
=
count1
+
count2
;
return
true
;
}
Telemetry
:
:
ID
nsGIFDecoder2
:
:
SpeedHistogram
(
)
{
return
Telemetry
:
:
IMAGE_DECODE_SPEED_GIF
;
}
}
}
