#
include
"
nsGIFDecoder2
.
h
"
#
include
<
stddef
.
h
>
#
include
"
imgFrame
.
h
"
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
SurfacePipeFactory
.
h
"
#
include
"
gfxColor
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
qcms
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
Telemetry
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
std
:
:
max
;
namespace
mozilla
{
namespace
image
{
static
const
size_t
GIF_HEADER_LEN
=
6
;
static
const
size_t
GIF_SCREEN_DESCRIPTOR_LEN
=
7
;
static
const
size_t
BLOCK_HEADER_LEN
=
1
;
static
const
size_t
SUB_BLOCK_HEADER_LEN
=
1
;
static
const
size_t
EXTENSION_HEADER_LEN
=
2
;
static
const
size_t
GRAPHIC_CONTROL_EXTENSION_LEN
=
4
;
static
const
size_t
APPLICATION_EXTENSION_LEN
=
11
;
static
const
size_t
IMAGE_DESCRIPTOR_LEN
=
9
;
static
const
uint8_t
PACKED_FIELDS_COLOR_TABLE_BIT
=
0x80
;
static
const
uint8_t
PACKED_FIELDS_INTERLACED_BIT
=
0x40
;
static
const
uint8_t
PACKED_FIELDS_TABLE_DEPTH_MASK
=
0x07
;
nsGIFDecoder2
:
:
nsGIFDecoder2
(
RasterImage
*
aImage
)
:
Decoder
(
aImage
)
mLexer
(
Transition
:
:
To
(
State
:
:
GIF_HEADER
GIF_HEADER_LEN
)
)
mOldColor
(
0
)
mCurrentFrameIndex
(
-
1
)
mColorTablePos
(
0
)
mGIFOpen
(
false
)
mSawTransparency
(
false
)
{
memset
(
&
mGIFStruct
0
sizeof
(
mGIFStruct
)
)
;
mGIFStruct
.
loop_count
=
1
;
}
nsGIFDecoder2
:
:
~
nsGIFDecoder2
(
)
{
free
(
mGIFStruct
.
local_colormap
)
;
}
void
nsGIFDecoder2
:
:
FinishInternal
(
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
FinishInternal
after
error
!
"
)
;
if
(
!
IsMetadataDecode
(
)
&
&
mGIFOpen
)
{
if
(
mCurrentFrameIndex
=
=
mGIFStruct
.
images_decoded
)
{
EndImageFrame
(
)
;
}
PostDecodeDone
(
mGIFStruct
.
loop_count
-
1
)
;
mGIFOpen
=
false
;
}
}
void
nsGIFDecoder2
:
:
FlushImageData
(
)
{
Maybe
<
SurfaceInvalidRect
>
invalidRect
=
mPipe
.
TakeInvalidRect
(
)
;
if
(
!
invalidRect
)
{
return
;
}
PostInvalidation
(
invalidRect
-
>
mInputSpaceRect
Some
(
invalidRect
-
>
mOutputSpaceRect
)
)
;
}
void
nsGIFDecoder2
:
:
BeginGIF
(
)
{
if
(
mGIFOpen
)
{
return
;
}
mGIFOpen
=
true
;
PostSize
(
mGIFStruct
.
screen_width
mGIFStruct
.
screen_height
)
;
}
bool
nsGIFDecoder2
:
:
CheckForTransparency
(
const
IntRect
&
aFrameRect
)
{
if
(
mGIFStruct
.
is_transparent
)
{
PostHasTransparency
(
)
;
return
true
;
}
if
(
mGIFStruct
.
images_decoded
>
0
)
{
return
false
;
}
IntRect
imageRect
(
0
0
mGIFStruct
.
screen_width
mGIFStruct
.
screen_height
)
;
if
(
!
imageRect
.
IsEqualEdges
(
aFrameRect
)
)
{
PostHasTransparency
(
)
;
mSawTransparency
=
true
;
return
true
;
}
return
false
;
}
nsresult
nsGIFDecoder2
:
:
BeginImageFrame
(
const
IntRect
&
aFrameRect
uint16_t
aDepth
bool
aIsInterlaced
)
{
MOZ_ASSERT
(
HasSize
(
)
)
;
bool
hasTransparency
=
CheckForTransparency
(
aFrameRect
)
;
gfx
:
:
SurfaceFormat
format
=
hasTransparency
?
SurfaceFormat
:
:
B8G8R8A8
:
SurfaceFormat
:
:
B8G8R8X8
;
MOZ_ASSERT_IF
(
mDownscaler
!
GetImageMetadata
(
)
.
HasAnimation
(
)
)
;
SurfacePipeFlags
pipeFlags
=
aIsInterlaced
?
SurfacePipeFlags
:
:
DEINTERLACE
:
SurfacePipeFlags
(
)
;
Maybe
<
SurfacePipe
>
pipe
;
if
(
mGIFStruct
.
images_decoded
=
=
0
)
{
IntSize
targetSize
=
mDownscaler
?
mDownscaler
-
>
TargetSize
(
)
:
GetSize
(
)
;
pipeFlags
|
=
SurfacePipeFlags
:
:
PROGRESSIVE_DISPLAY
;
pipe
=
SurfacePipeFactory
:
:
CreateSurfacePipe
(
this
mGIFStruct
.
images_decoded
GetSize
(
)
targetSize
aFrameRect
format
pipeFlags
)
;
}
else
{
MOZ_ASSERT
(
!
mDownscaler
)
;
pipe
=
SurfacePipeFactory
:
:
CreatePalettedSurfacePipe
(
this
mGIFStruct
.
images_decoded
GetSize
(
)
aFrameRect
format
aDepth
pipeFlags
)
;
}
mCurrentFrameIndex
=
mGIFStruct
.
images_decoded
;
if
(
!
pipe
)
{
mPipe
=
SurfacePipe
(
)
;
return
NS_ERROR_FAILURE
;
}
mPipe
=
Move
(
*
pipe
)
;
return
NS_OK
;
}
void
nsGIFDecoder2
:
:
EndImageFrame
(
)
{
Opacity
opacity
=
Opacity
:
:
SOME_TRANSPARENCY
;
if
(
mGIFStruct
.
images_decoded
=
=
0
)
{
FlushImageData
(
)
;
if
(
!
mGIFStruct
.
is_transparent
&
&
!
mSawTransparency
)
{
opacity
=
Opacity
:
:
FULLY_OPAQUE
;
}
}
mGIFStruct
.
images_decoded
+
+
;
PostFrameStop
(
opacity
DisposalMethod
(
mGIFStruct
.
disposal_method
)
mGIFStruct
.
delay_time
)
;
if
(
mOldColor
)
{
mColormap
[
mGIFStruct
.
tpixel
]
=
mOldColor
;
mOldColor
=
0
;
}
mCurrentFrameIndex
=
-
1
;
}
template
<
typename
PixelSize
>
PixelSize
nsGIFDecoder2
:
:
ColormapIndexToPixel
(
uint8_t
aIndex
)
{
MOZ_ASSERT
(
sizeof
(
PixelSize
)
=
=
sizeof
(
uint32_t
)
)
;
uint32_t
color
=
mColormap
[
aIndex
&
mColorMask
]
;
if
(
mGIFStruct
.
is_transparent
)
{
mSawTransparency
=
mSawTransparency
|
|
color
=
=
0
;
}
return
color
;
}
template
<
>
uint8_t
nsGIFDecoder2
:
:
ColormapIndexToPixel
<
uint8_t
>
(
uint8_t
aIndex
)
{
return
aIndex
&
mColorMask
;
}
template
<
typename
PixelSize
>
NextPixel
<
PixelSize
>
nsGIFDecoder2
:
:
YieldPixel
(
const
uint8_t
*
aData
size_t
aLength
size_t
*
aBytesReadOut
)
{
MOZ_ASSERT
(
aData
)
;
MOZ_ASSERT
(
aBytesReadOut
)
;
MOZ_ASSERT
(
mGIFStruct
.
stackp
>
=
mGIFStruct
.
stack
)
;
const
uint8_t
*
data
=
aData
+
*
aBytesReadOut
;
if
(
mGIFStruct
.
stackp
=
=
mGIFStruct
.
stack
)
{
while
(
mGIFStruct
.
bits
<
mGIFStruct
.
codesize
&
&
*
aBytesReadOut
<
aLength
)
{
mGIFStruct
.
datum
+
=
int32_t
(
*
data
)
<
<
mGIFStruct
.
bits
;
mGIFStruct
.
bits
+
=
8
;
data
+
=
1
;
*
aBytesReadOut
+
=
1
;
}
if
(
mGIFStruct
.
bits
<
mGIFStruct
.
codesize
)
{
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
int
code
=
mGIFStruct
.
datum
&
mGIFStruct
.
codemask
;
mGIFStruct
.
datum
>
>
=
mGIFStruct
.
codesize
;
mGIFStruct
.
bits
-
=
mGIFStruct
.
codesize
;
const
int
clearCode
=
ClearCode
(
)
;
if
(
code
=
=
clearCode
)
{
mGIFStruct
.
codesize
=
mGIFStruct
.
datasize
+
1
;
mGIFStruct
.
codemask
=
(
1
<
<
mGIFStruct
.
codesize
)
-
1
;
mGIFStruct
.
avail
=
clearCode
+
2
;
mGIFStruct
.
oldcode
=
-
1
;
return
AsVariant
(
WriteState
:
:
NEED_MORE_DATA
)
;
}
if
(
code
=
=
(
clearCode
+
1
)
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
if
(
mGIFStruct
.
oldcode
=
=
-
1
)
{
if
(
code
>
=
MAX_BITS
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
mGIFStruct
.
firstchar
=
mGIFStruct
.
oldcode
=
code
;
mGIFStruct
.
pixels_remaining
-
-
;
return
AsVariant
(
ColormapIndexToPixel
<
PixelSize
>
(
mGIFStruct
.
suffix
[
code
]
)
)
;
}
int
incode
=
code
;
if
(
code
>
=
mGIFStruct
.
avail
)
{
*
mGIFStruct
.
stackp
+
+
=
mGIFStruct
.
firstchar
;
code
=
mGIFStruct
.
oldcode
;
if
(
mGIFStruct
.
stackp
>
=
mGIFStruct
.
stack
+
MAX_BITS
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
}
while
(
code
>
=
clearCode
)
{
if
(
(
code
>
=
MAX_BITS
)
|
|
(
code
=
=
mGIFStruct
.
prefix
[
code
]
)
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
*
mGIFStruct
.
stackp
+
+
=
mGIFStruct
.
suffix
[
code
]
;
code
=
mGIFStruct
.
prefix
[
code
]
;
if
(
mGIFStruct
.
stackp
>
=
mGIFStruct
.
stack
+
MAX_BITS
)
{
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
}
*
mGIFStruct
.
stackp
+
+
=
mGIFStruct
.
firstchar
=
mGIFStruct
.
suffix
[
code
]
;
if
(
mGIFStruct
.
avail
<
4096
)
{
mGIFStruct
.
prefix
[
mGIFStruct
.
avail
]
=
mGIFStruct
.
oldcode
;
mGIFStruct
.
suffix
[
mGIFStruct
.
avail
]
=
mGIFStruct
.
firstchar
;
mGIFStruct
.
avail
+
+
;
if
(
(
(
mGIFStruct
.
avail
&
mGIFStruct
.
codemask
)
=
=
0
)
&
&
(
mGIFStruct
.
avail
<
4096
)
)
{
mGIFStruct
.
codesize
+
+
;
mGIFStruct
.
codemask
+
=
mGIFStruct
.
avail
;
}
}
mGIFStruct
.
oldcode
=
incode
;
}
if
(
MOZ_UNLIKELY
(
mGIFStruct
.
stackp
<
=
mGIFStruct
.
stack
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
decoded
data
but
we
didn
'
t
return
early
?
"
)
;
return
AsVariant
(
WriteState
:
:
FAILURE
)
;
}
mGIFStruct
.
pixels_remaining
-
-
;
return
AsVariant
(
ColormapIndexToPixel
<
PixelSize
>
(
*
-
-
mGIFStruct
.
stackp
)
)
;
}
static
void
ConvertColormap
(
uint32_t
*
aColormap
uint32_t
aColors
)
{
if
(
gfxPlatform
:
:
GetCMSMode
(
)
=
=
eCMSMode_All
)
{
qcms_transform
*
transform
=
gfxPlatform
:
:
GetCMSRGBTransform
(
)
;
if
(
transform
)
{
qcms_transform_data
(
transform
aColormap
aColormap
aColors
)
;
}
}
uint8_t
*
from
=
(
(
uint8_t
*
)
aColormap
)
+
3
*
aColors
;
uint32_t
*
to
=
aColormap
+
aColors
;
if
(
!
aColors
)
{
return
;
}
uint32_t
c
=
aColors
;
for
(
;
(
NS_PTR_TO_UINT32
(
from
)
&
0x3
)
&
&
c
;
-
-
c
)
{
from
-
=
3
;
*
-
-
to
=
gfxPackedPixel
(
0xFF
from
[
0
]
from
[
1
]
from
[
2
]
)
;
}
while
(
c
>
=
4
)
{
from
-
=
12
;
to
-
=
4
;
c
-
=
4
;
GFX_BLOCK_RGB_TO_FRGB
(
from
to
)
;
}
while
(
c
-
-
)
{
from
-
=
3
;
*
-
-
to
=
gfxPackedPixel
(
0xFF
from
[
0
]
from
[
1
]
from
[
2
]
)
;
}
}
void
nsGIFDecoder2
:
:
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
WriteInternal
after
error
!
"
)
;
MOZ_ASSERT
(
aBuffer
)
;
MOZ_ASSERT
(
aCount
>
0
)
;
Maybe
<
TerminalState
>
terminalState
=
mLexer
.
Lex
(
aBuffer
aCount
[
=
]
(
State
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
State
:
:
GIF_HEADER
:
return
ReadGIFHeader
(
aData
)
;
case
State
:
:
SCREEN_DESCRIPTOR
:
return
ReadScreenDescriptor
(
aData
)
;
case
State
:
:
GLOBAL_COLOR_TABLE
:
return
ReadGlobalColorTable
(
aData
aLength
)
;
case
State
:
:
FINISHED_GLOBAL_COLOR_TABLE
:
return
FinishedGlobalColorTable
(
)
;
case
State
:
:
BLOCK_HEADER
:
return
ReadBlockHeader
(
aData
)
;
case
State
:
:
EXTENSION_HEADER
:
return
ReadExtensionHeader
(
aData
)
;
case
State
:
:
GRAPHIC_CONTROL_EXTENSION
:
return
ReadGraphicControlExtension
(
aData
)
;
case
State
:
:
APPLICATION_IDENTIFIER
:
return
ReadApplicationIdentifier
(
aData
)
;
case
State
:
:
NETSCAPE_EXTENSION_SUB_BLOCK
:
return
ReadNetscapeExtensionSubBlock
(
aData
)
;
case
State
:
:
NETSCAPE_EXTENSION_DATA
:
return
ReadNetscapeExtensionData
(
aData
)
;
case
State
:
:
IMAGE_DESCRIPTOR
:
return
ReadImageDescriptor
(
aData
)
;
case
State
:
:
LOCAL_COLOR_TABLE
:
return
ReadLocalColorTable
(
aData
aLength
)
;
case
State
:
:
FINISHED_LOCAL_COLOR_TABLE
:
return
FinishedLocalColorTable
(
)
;
case
State
:
:
IMAGE_DATA_BLOCK
:
return
ReadImageDataBlock
(
aData
)
;
case
State
:
:
IMAGE_DATA_SUB_BLOCK
:
return
ReadImageDataSubBlock
(
aData
)
;
case
State
:
:
LZW_DATA
:
return
ReadLZWData
(
aData
aLength
)
;
case
State
:
:
SKIP_LZW_DATA
:
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
SKIP_LZW_DATA
)
;
case
State
:
:
FINISHED_LZW_DATA
:
return
Transition
:
:
To
(
State
:
:
IMAGE_DATA_SUB_BLOCK
SUB_BLOCK_HEADER_LEN
)
;
case
State
:
:
SKIP_SUB_BLOCKS
:
return
SkipSubBlocks
(
aData
)
;
case
State
:
:
SKIP_DATA_THEN_SKIP_SUB_BLOCKS
:
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
SKIP_DATA_THEN_SKIP_SUB_BLOCKS
)
;
case
State
:
:
FINISHED_SKIPPING_DATA
:
return
Transition
:
:
To
(
State
:
:
SKIP_SUB_BLOCKS
SUB_BLOCK_HEADER_LEN
)
;
default
:
MOZ_CRASH
(
"
Unknown
State
"
)
;
}
}
)
;
if
(
terminalState
=
=
Some
(
TerminalState
:
:
FAILURE
)
)
{
PostDataError
(
)
;
}
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadGIFHeader
(
const
char
*
aData
)
{
if
(
strncmp
(
aData
"
GIF87a
"
GIF_HEADER_LEN
)
=
=
0
)
{
mGIFStruct
.
version
=
87
;
}
else
if
(
strncmp
(
aData
"
GIF89a
"
GIF_HEADER_LEN
)
=
=
0
)
{
mGIFStruct
.
version
=
89
;
}
else
{
return
Transition
:
:
TerminateFailure
(
)
;
}
return
Transition
:
:
To
(
State
:
:
SCREEN_DESCRIPTOR
GIF_SCREEN_DESCRIPTOR_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadScreenDescriptor
(
const
char
*
aData
)
{
mGIFStruct
.
screen_width
=
LittleEndian
:
:
readUint16
(
aData
+
0
)
;
mGIFStruct
.
screen_height
=
LittleEndian
:
:
readUint16
(
aData
+
2
)
;
const
uint8_t
packedFields
=
aData
[
4
]
;
mGIFStruct
.
global_colormap_depth
=
(
packedFields
&
PACKED_FIELDS_TABLE_DEPTH_MASK
)
+
1
;
mGIFStruct
.
global_colormap_count
=
1
<
<
mGIFStruct
.
global_colormap_depth
;
if
(
packedFields
&
PACKED_FIELDS_COLOR_TABLE_BIT
)
{
MOZ_ASSERT
(
mColorTablePos
=
=
0
)
;
const
size_t
globalColorTableSize
=
3
*
mGIFStruct
.
global_colormap_count
;
return
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_GLOBAL_COLOR_TABLE
State
:
:
GLOBAL_COLOR_TABLE
globalColorTableSize
)
;
}
return
Transition
:
:
To
(
State
:
:
BLOCK_HEADER
BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadGlobalColorTable
(
const
char
*
aData
size_t
aLength
)
{
uint8_t
*
dest
=
reinterpret_cast
<
uint8_t
*
>
(
mGIFStruct
.
global_colormap
)
+
mColorTablePos
;
memcpy
(
dest
aData
aLength
)
;
mColorTablePos
+
=
aLength
;
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
GLOBAL_COLOR_TABLE
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
FinishedGlobalColorTable
(
)
{
ConvertColormap
(
mGIFStruct
.
global_colormap
mGIFStruct
.
global_colormap_count
)
;
mColorTablePos
=
0
;
return
Transition
:
:
To
(
State
:
:
BLOCK_HEADER
BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadBlockHeader
(
const
char
*
aData
)
{
switch
(
aData
[
0
]
)
{
case
GIF_EXTENSION_INTRODUCER
:
return
Transition
:
:
To
(
State
:
:
EXTENSION_HEADER
EXTENSION_HEADER_LEN
)
;
case
GIF_IMAGE_SEPARATOR
:
return
Transition
:
:
To
(
State
:
:
IMAGE_DESCRIPTOR
IMAGE_DESCRIPTOR_LEN
)
;
case
GIF_TRAILER
:
FinishInternal
(
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
default
:
if
(
mGIFStruct
.
images_decoded
>
0
)
{
FinishInternal
(
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
}
return
Transition
:
:
TerminateFailure
(
)
;
}
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadExtensionHeader
(
const
char
*
aData
)
{
const
uint8_t
label
=
aData
[
0
]
;
const
uint8_t
extensionHeaderLength
=
aData
[
1
]
;
if
(
extensionHeaderLength
=
=
0
)
{
return
Transition
:
:
To
(
State
:
:
BLOCK_HEADER
BLOCK_HEADER_LEN
)
;
}
switch
(
label
)
{
case
GIF_GRAPHIC_CONTROL_LABEL
:
return
Transition
:
:
To
(
State
:
:
GRAPHIC_CONTROL_EXTENSION
max
<
uint8_t
>
(
extensionHeaderLength
GRAPHIC_CONTROL_EXTENSION_LEN
)
)
;
case
GIF_APPLICATION_EXTENSION_LABEL
:
return
extensionHeaderLength
=
=
APPLICATION_EXTENSION_LEN
?
Transition
:
:
To
(
State
:
:
APPLICATION_IDENTIFIER
extensionHeaderLength
)
:
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_SKIPPING_DATA
State
:
:
SKIP_DATA_THEN_SKIP_SUB_BLOCKS
extensionHeaderLength
)
;
default
:
return
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_SKIPPING_DATA
State
:
:
SKIP_DATA_THEN_SKIP_SUB_BLOCKS
extensionHeaderLength
)
;
}
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadGraphicControlExtension
(
const
char
*
aData
)
{
mGIFStruct
.
is_transparent
=
aData
[
0
]
&
0x1
;
mGIFStruct
.
tpixel
=
uint8_t
(
aData
[
3
]
)
;
mGIFStruct
.
disposal_method
=
(
aData
[
0
]
>
>
2
)
&
0x7
;
if
(
mGIFStruct
.
disposal_method
=
=
4
)
{
mGIFStruct
.
disposal_method
=
3
;
}
else
if
(
mGIFStruct
.
disposal_method
>
4
)
{
mGIFStruct
.
disposal_method
=
0
;
}
DisposalMethod
method
=
DisposalMethod
(
mGIFStruct
.
disposal_method
)
;
if
(
method
=
=
DisposalMethod
:
:
CLEAR_ALL
|
|
method
=
=
DisposalMethod
:
:
CLEAR
)
{
PostHasTransparency
(
)
;
}
mGIFStruct
.
delay_time
=
LittleEndian
:
:
readUint16
(
aData
+
1
)
*
10
;
if
(
mGIFStruct
.
delay_time
>
0
)
{
PostIsAnimated
(
mGIFStruct
.
delay_time
)
;
}
return
Transition
:
:
To
(
State
:
:
SKIP_SUB_BLOCKS
SUB_BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadApplicationIdentifier
(
const
char
*
aData
)
{
if
(
(
strncmp
(
aData
"
NETSCAPE2
.
0
"
11
)
=
=
0
)
|
|
(
strncmp
(
aData
"
ANIMEXTS1
.
0
"
11
)
=
=
0
)
)
{
return
Transition
:
:
To
(
State
:
:
NETSCAPE_EXTENSION_SUB_BLOCK
SUB_BLOCK_HEADER_LEN
)
;
}
return
Transition
:
:
To
(
State
:
:
SKIP_SUB_BLOCKS
SUB_BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadNetscapeExtensionSubBlock
(
const
char
*
aData
)
{
const
uint8_t
blockLength
=
aData
[
0
]
;
if
(
blockLength
=
=
0
)
{
return
Transition
:
:
To
(
State
:
:
BLOCK_HEADER
BLOCK_HEADER_LEN
)
;
}
const
size_t
extensionLength
=
max
<
uint8_t
>
(
blockLength
3
)
;
return
Transition
:
:
To
(
State
:
:
NETSCAPE_EXTENSION_DATA
extensionLength
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadNetscapeExtensionData
(
const
char
*
aData
)
{
static
const
uint8_t
NETSCAPE_LOOPING_EXTENSION_SUB_BLOCK_ID
=
1
;
static
const
uint8_t
NETSCAPE_BUFFERING_EXTENSION_SUB_BLOCK_ID
=
2
;
const
uint8_t
subBlockID
=
aData
[
0
]
&
7
;
switch
(
subBlockID
)
{
case
NETSCAPE_LOOPING_EXTENSION_SUB_BLOCK_ID
:
mGIFStruct
.
loop_count
=
LittleEndian
:
:
readUint16
(
aData
+
1
)
;
return
Transition
:
:
To
(
State
:
:
NETSCAPE_EXTENSION_SUB_BLOCK
SUB_BLOCK_HEADER_LEN
)
;
case
NETSCAPE_BUFFERING_EXTENSION_SUB_BLOCK_ID
:
return
Transition
:
:
To
(
State
:
:
NETSCAPE_EXTENSION_SUB_BLOCK
SUB_BLOCK_HEADER_LEN
)
;
default
:
return
Transition
:
:
TerminateFailure
(
)
;
}
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadImageDescriptor
(
const
char
*
aData
)
{
if
(
mGIFStruct
.
images_decoded
=
=
1
)
{
if
(
!
HasAnimation
(
)
)
{
PostIsAnimated
(
0
)
;
}
if
(
IsFirstFrameDecode
(
)
)
{
FinishInternal
(
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
}
if
(
mDownscaler
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Doing
downscale
-
during
-
decode
for
an
animated
"
"
image
?
"
)
;
mDownscaler
.
reset
(
)
;
}
}
IntRect
frameRect
;
frameRect
.
x
=
LittleEndian
:
:
readUint16
(
aData
+
0
)
;
frameRect
.
y
=
LittleEndian
:
:
readUint16
(
aData
+
2
)
;
frameRect
.
width
=
LittleEndian
:
:
readUint16
(
aData
+
4
)
;
frameRect
.
height
=
LittleEndian
:
:
readUint16
(
aData
+
6
)
;
if
(
!
mGIFStruct
.
images_decoded
)
{
if
(
mGIFStruct
.
screen_height
<
frameRect
.
height
|
|
mGIFStruct
.
screen_width
<
frameRect
.
width
|
|
mGIFStruct
.
version
=
=
87
)
{
mGIFStruct
.
screen_height
=
frameRect
.
height
;
mGIFStruct
.
screen_width
=
frameRect
.
width
;
frameRect
.
MoveTo
(
0
0
)
;
}
BeginGIF
(
)
;
if
(
HasError
(
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
IsMetadataDecode
(
)
)
{
CheckForTransparency
(
frameRect
)
;
FinishInternal
(
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
}
}
if
(
frameRect
.
height
=
=
0
|
|
frameRect
.
width
=
=
0
)
{
frameRect
.
height
=
mGIFStruct
.
screen_height
;
frameRect
.
width
=
mGIFStruct
.
screen_width
;
if
(
frameRect
.
height
=
=
0
|
|
frameRect
.
width
=
=
0
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
}
bool
haveLocalColorTable
=
false
;
uint16_t
depth
=
0
;
uint8_t
packedFields
=
aData
[
8
]
;
if
(
packedFields
&
PACKED_FIELDS_COLOR_TABLE_BIT
)
{
depth
=
(
packedFields
&
PACKED_FIELDS_TABLE_DEPTH_MASK
)
+
1
;
haveLocalColorTable
=
true
;
}
else
{
depth
=
mGIFStruct
.
global_colormap_depth
;
}
uint16_t
realDepth
=
depth
;
while
(
mGIFStruct
.
tpixel
>
=
(
1
<
<
realDepth
)
&
&
realDepth
<
8
)
{
realDepth
+
+
;
}
mColorMask
=
0xFF
>
>
(
8
-
realDepth
)
;
const
bool
isInterlaced
=
packedFields
&
PACKED_FIELDS_INTERLACED_BIT
;
if
(
NS_FAILED
(
BeginImageFrame
(
frameRect
realDepth
isInterlaced
)
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
mGIFStruct
.
pixels_remaining
=
frameRect
.
width
*
frameRect
.
height
;
if
(
haveLocalColorTable
)
{
mGIFStruct
.
local_colormap_size
=
1
<
<
depth
;
if
(
mGIFStruct
.
images_decoded
=
=
0
)
{
mColormapSize
=
sizeof
(
uint32_t
)
<
<
realDepth
;
if
(
!
mGIFStruct
.
local_colormap
)
{
mGIFStruct
.
local_colormap
=
static_cast
<
uint32_t
*
>
(
moz_xmalloc
(
mColormapSize
)
)
;
}
mColormap
=
mGIFStruct
.
local_colormap
;
}
const
size_t
size
=
3
<
<
depth
;
if
(
mColormapSize
>
size
)
{
memset
(
reinterpret_cast
<
uint8_t
*
>
(
mColormap
)
+
size
0
mColormapSize
-
size
)
;
}
MOZ_ASSERT
(
mColorTablePos
=
=
0
)
;
return
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_LOCAL_COLOR_TABLE
State
:
:
LOCAL_COLOR_TABLE
size
)
;
}
if
(
mGIFStruct
.
images_decoded
>
0
)
{
memcpy
(
mColormap
mGIFStruct
.
global_colormap
mColormapSize
)
;
}
else
{
mColormap
=
mGIFStruct
.
global_colormap
;
}
return
Transition
:
:
To
(
State
:
:
IMAGE_DATA_BLOCK
BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadLocalColorTable
(
const
char
*
aData
size_t
aLength
)
{
uint8_t
*
dest
=
reinterpret_cast
<
uint8_t
*
>
(
mColormap
)
+
mColorTablePos
;
memcpy
(
dest
aData
aLength
)
;
mColorTablePos
+
=
aLength
;
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
LOCAL_COLOR_TABLE
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
FinishedLocalColorTable
(
)
{
ConvertColormap
(
mColormap
mGIFStruct
.
local_colormap_size
)
;
mColorTablePos
=
0
;
return
Transition
:
:
To
(
State
:
:
IMAGE_DATA_BLOCK
BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadImageDataBlock
(
const
char
*
aData
)
{
if
(
mGIFStruct
.
is_transparent
)
{
if
(
mColormap
=
=
mGIFStruct
.
global_colormap
)
{
mOldColor
=
mColormap
[
mGIFStruct
.
tpixel
]
;
}
mColormap
[
mGIFStruct
.
tpixel
]
=
0
;
}
mGIFStruct
.
datasize
=
uint8_t
(
aData
[
0
]
)
;
const
int
clearCode
=
ClearCode
(
)
;
if
(
mGIFStruct
.
datasize
>
MAX_LZW_BITS
|
|
clearCode
>
=
MAX_BITS
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
mGIFStruct
.
avail
=
clearCode
+
2
;
mGIFStruct
.
oldcode
=
-
1
;
mGIFStruct
.
codesize
=
mGIFStruct
.
datasize
+
1
;
mGIFStruct
.
codemask
=
(
1
<
<
mGIFStruct
.
codesize
)
-
1
;
mGIFStruct
.
datum
=
mGIFStruct
.
bits
=
0
;
for
(
int
i
=
0
;
i
<
clearCode
;
i
+
+
)
{
mGIFStruct
.
suffix
[
i
]
=
i
;
}
mGIFStruct
.
stackp
=
mGIFStruct
.
stack
;
return
Transition
:
:
To
(
State
:
:
IMAGE_DATA_SUB_BLOCK
SUB_BLOCK_HEADER_LEN
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadImageDataSubBlock
(
const
char
*
aData
)
{
const
uint8_t
subBlockLength
=
aData
[
0
]
;
if
(
subBlockLength
=
=
0
)
{
EndImageFrame
(
)
;
return
Transition
:
:
To
(
State
:
:
BLOCK_HEADER
BLOCK_HEADER_LEN
)
;
}
if
(
mGIFStruct
.
pixels_remaining
=
=
0
)
{
if
(
subBlockLength
=
=
GIF_TRAILER
)
{
FinishInternal
(
)
;
return
Transition
:
:
TerminateSuccess
(
)
;
}
return
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_LZW_DATA
State
:
:
SKIP_LZW_DATA
subBlockLength
)
;
}
return
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_LZW_DATA
State
:
:
LZW_DATA
subBlockLength
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
ReadLZWData
(
const
char
*
aData
size_t
aLength
)
{
const
uint8_t
*
data
=
reinterpret_cast
<
const
uint8_t
*
>
(
aData
)
;
size_t
length
=
aLength
;
while
(
length
>
0
&
&
mGIFStruct
.
pixels_remaining
>
0
)
{
size_t
bytesRead
=
0
;
auto
result
=
mGIFStruct
.
images_decoded
=
=
0
?
mPipe
.
WritePixels
<
uint32_t
>
(
[
&
]
{
return
YieldPixel
<
uint32_t
>
(
data
length
&
bytesRead
)
;
}
)
:
mPipe
.
WritePixels
<
uint8_t
>
(
[
&
]
{
return
YieldPixel
<
uint8_t
>
(
data
length
&
bytesRead
)
;
}
)
;
if
(
MOZ_UNLIKELY
(
bytesRead
>
length
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Overread
?
"
)
;
bytesRead
=
length
;
}
data
+
=
bytesRead
;
length
-
=
bytesRead
;
switch
(
result
)
{
case
WriteState
:
:
NEED_MORE_DATA
:
continue
;
case
WriteState
:
:
FINISHED
:
NS_WARN_IF
(
mGIFStruct
.
pixels_remaining
>
0
)
;
mGIFStruct
.
pixels_remaining
=
0
;
break
;
case
WriteState
:
:
FAILURE
:
return
Transition
:
:
TerminateFailure
(
)
;
}
}
return
Transition
:
:
ContinueUnbuffered
(
State
:
:
LZW_DATA
)
;
}
LexerTransition
<
nsGIFDecoder2
:
:
State
>
nsGIFDecoder2
:
:
SkipSubBlocks
(
const
char
*
aData
)
{
const
uint8_t
nextSubBlockLength
=
aData
[
0
]
;
if
(
nextSubBlockLength
=
=
0
)
{
return
Transition
:
:
To
(
State
:
:
BLOCK_HEADER
BLOCK_HEADER_LEN
)
;
}
return
Transition
:
:
ToUnbuffered
(
State
:
:
FINISHED_SKIPPING_DATA
State
:
:
SKIP_DATA_THEN_SKIP_SUB_BLOCKS
nextSubBlockLength
)
;
}
Telemetry
:
:
ID
nsGIFDecoder2
:
:
SpeedHistogram
(
)
{
return
Telemetry
:
:
IMAGE_DECODE_SPEED_GIF
;
}
}
}
