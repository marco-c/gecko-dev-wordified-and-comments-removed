#
include
"
nsICODecoder
.
h
"
#
include
<
stdlib
.
h
>
#
include
"
mozilla
/
EndianUtils
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
RasterImage
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
image
{
static
const
uint32_t
ICOHEADERSIZE
=
6
;
static
const
uint32_t
BITMAPINFOSIZE
=
bmp
:
:
InfoHeaderLength
:
:
WIN_ICO
;
uint16_t
nsICODecoder
:
:
GetNumColors
(
)
{
uint16_t
numColors
=
0
;
if
(
mBPP
<
=
8
)
{
switch
(
mBPP
)
{
case
1
:
numColors
=
2
;
break
;
case
4
:
numColors
=
16
;
break
;
case
8
:
numColors
=
256
;
break
;
default
:
numColors
=
(
uint16_t
)
-
1
;
}
}
return
numColors
;
}
nsICODecoder
:
:
nsICODecoder
(
RasterImage
*
aImage
)
:
Decoder
(
aImage
)
mLexer
(
Transition
:
:
To
(
ICOState
:
:
HEADER
ICOHEADERSIZE
)
Transition
:
:
TerminateSuccess
(
)
)
mBiggestResourceColorDepth
(
0
)
mBestResourceDelta
(
INT_MIN
)
mBestResourceColorDepth
(
0
)
mNumIcons
(
0
)
mCurrIcon
(
0
)
mBPP
(
0
)
mMaskRowSize
(
0
)
mCurrMaskLine
(
0
)
mIsCursor
(
false
)
mHasMaskAlpha
(
false
)
{
}
nsresult
nsICODecoder
:
:
FinishInternal
(
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
FinishInternal
after
error
!
"
)
;
return
GetFinalStateFromContainedDecoder
(
)
;
}
nsresult
nsICODecoder
:
:
FinishWithErrorInternal
(
)
{
return
GetFinalStateFromContainedDecoder
(
)
;
}
nsresult
nsICODecoder
:
:
GetFinalStateFromContainedDecoder
(
)
{
if
(
!
mContainedDecoder
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mContainedSourceBuffer
"
Should
have
a
SourceBuffer
if
we
have
a
decoder
"
)
;
if
(
!
mContainedSourceBuffer
-
>
IsComplete
(
)
)
{
mContainedSourceBuffer
-
>
Complete
(
NS_OK
)
;
mContainedDecoder
-
>
Decode
(
)
;
}
mDecodeDone
=
mContainedDecoder
-
>
GetDecodeDone
(
)
;
mProgress
|
=
mContainedDecoder
-
>
TakeProgress
(
)
;
mInvalidRect
.
UnionRect
(
mInvalidRect
mContainedDecoder
-
>
TakeInvalidRect
(
)
)
;
mCurrentFrame
=
mContainedDecoder
-
>
GetCurrentFrameRef
(
)
;
nsresult
rv
=
HasError
(
)
|
|
mContainedDecoder
-
>
HasError
(
)
?
NS_ERROR_FAILURE
:
NS_OK
;
MOZ_ASSERT
(
NS_FAILED
(
rv
)
|
|
!
mCurrentFrame
|
|
mCurrentFrame
-
>
IsFinished
(
)
)
;
return
rv
;
}
bool
nsICODecoder
:
:
CheckAndFixBitmapSize
(
int8_t
*
aBIH
)
{
const
int32_t
width
=
LittleEndian
:
:
readInt32
(
aBIH
+
4
)
;
if
(
width
<
=
0
|
|
width
>
256
)
{
return
false
;
}
if
(
width
!
=
int32_t
(
GetRealWidth
(
)
)
)
{
return
false
;
}
int32_t
height
=
LittleEndian
:
:
readInt32
(
aBIH
+
8
)
;
if
(
height
=
=
0
)
{
return
false
;
}
height
=
abs
(
height
)
;
height
/
=
2
;
if
(
height
>
256
)
{
return
false
;
}
if
(
height
!
=
int32_t
(
GetRealHeight
(
)
)
)
{
return
false
;
}
LittleEndian
:
:
writeInt32
(
aBIH
+
8
GetRealHeight
(
)
)
;
return
true
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
ReadHeader
(
const
char
*
aData
)
{
if
(
(
aData
[
2
]
!
=
1
)
&
&
(
aData
[
2
]
!
=
2
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
mIsCursor
=
(
aData
[
2
]
=
=
2
)
;
mNumIcons
=
LittleEndian
:
:
readUint16
(
aData
+
4
)
;
if
(
mNumIcons
=
=
0
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
PostHasTransparency
(
)
;
return
Transition
:
:
To
(
ICOState
:
:
DIR_ENTRY
ICODIRENTRYSIZE
)
;
}
size_t
nsICODecoder
:
:
FirstResourceOffset
(
)
const
{
MOZ_ASSERT
(
mNumIcons
>
0
"
Calling
FirstResourceOffset
before
processing
header
"
)
;
return
ICOHEADERSIZE
+
mNumIcons
*
ICODIRENTRYSIZE
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
ReadDirEntry
(
const
char
*
aData
)
{
mCurrIcon
+
+
;
IconDirEntry
e
;
e
.
mWidth
=
aData
[
0
]
;
e
.
mHeight
=
aData
[
1
]
;
e
.
mColorCount
=
aData
[
2
]
;
e
.
mReserved
=
aData
[
3
]
;
e
.
mPlanes
=
LittleEndian
:
:
readUint16
(
aData
+
4
)
;
e
.
mBitCount
=
LittleEndian
:
:
readUint16
(
aData
+
6
)
;
e
.
mBytesInRes
=
LittleEndian
:
:
readUint32
(
aData
+
8
)
;
e
.
mImageOffset
=
LittleEndian
:
:
readUint32
(
aData
+
12
)
;
const
Maybe
<
IntSize
>
desiredSize
=
ExplicitOutputSize
(
)
;
IntSize
entrySize
(
GetRealWidth
(
e
)
GetRealHeight
(
e
)
)
;
if
(
e
.
mBitCount
>
=
mBiggestResourceColorDepth
&
&
entrySize
.
width
*
entrySize
.
height
>
=
mBiggestResourceSize
.
width
*
mBiggestResourceSize
.
height
)
{
mBiggestResourceSize
=
entrySize
;
mBiggestResourceColorDepth
=
e
.
mBitCount
;
mBiggestResourceHotSpot
=
IntSize
(
e
.
mXHotspot
e
.
mYHotspot
)
;
if
(
!
desiredSize
)
{
mDirEntry
=
e
;
}
}
if
(
desiredSize
)
{
int32_t
delta
=
std
:
:
min
(
entrySize
.
width
-
desiredSize
-
>
width
entrySize
.
height
-
desiredSize
-
>
height
)
;
if
(
e
.
mBitCount
>
=
mBestResourceColorDepth
&
&
(
(
mBestResourceDelta
<
0
&
&
delta
>
=
mBestResourceDelta
)
|
|
(
delta
>
=
0
&
&
delta
<
=
mBestResourceDelta
)
)
)
{
mBestResourceDelta
=
delta
;
mBestResourceColorDepth
=
e
.
mBitCount
;
mDirEntry
=
e
;
}
}
if
(
mCurrIcon
=
=
mNumIcons
)
{
if
(
mDirEntry
.
mImageOffset
<
FirstResourceOffset
(
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
mIsCursor
)
{
mImageMetadata
.
SetHotspot
(
mBiggestResourceHotSpot
.
width
mBiggestResourceHotSpot
.
height
)
;
}
PostSize
(
mBiggestResourceSize
.
width
mBiggestResourceSize
.
height
)
;
if
(
IsMetadataDecode
(
)
)
{
return
Transition
:
:
TerminateSuccess
(
)
;
}
if
(
GetRealSize
(
)
=
=
OutputSize
(
)
)
{
MOZ_ASSERT_IF
(
desiredSize
GetRealSize
(
)
=
=
*
desiredSize
)
;
MOZ_ASSERT_IF
(
!
desiredSize
GetRealSize
(
)
=
=
Size
(
)
)
;
mDownscaler
.
reset
(
)
;
}
size_t
offsetToResource
=
mDirEntry
.
mImageOffset
-
FirstResourceOffset
(
)
;
return
Transition
:
:
ToUnbuffered
(
ICOState
:
:
FOUND_RESOURCE
ICOState
:
:
SKIP_TO_RESOURCE
offsetToResource
)
;
}
return
Transition
:
:
To
(
ICOState
:
:
DIR_ENTRY
ICODIRENTRYSIZE
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
SniffResource
(
const
char
*
aData
)
{
bool
isPNG
=
!
memcmp
(
aData
nsPNGDecoder
:
:
pngSignatureBytes
PNGSIGNATURESIZE
)
;
if
(
isPNG
)
{
mContainedSourceBuffer
=
new
SourceBuffer
(
)
;
mContainedSourceBuffer
-
>
ExpectLength
(
mDirEntry
.
mBytesInRes
)
;
mContainedDecoder
=
DecoderFactory
:
:
CreateDecoderForICOResource
(
DecoderType
:
:
PNG
WrapNotNull
(
mContainedSourceBuffer
)
WrapNotNull
(
this
)
)
;
if
(
!
WriteToContainedDecoder
(
aData
PNGSIGNATURESIZE
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
mDirEntry
.
mBytesInRes
<
=
PNGSIGNATURESIZE
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
size_t
toRead
=
mDirEntry
.
mBytesInRes
-
PNGSIGNATURESIZE
;
return
Transition
:
:
ToUnbuffered
(
ICOState
:
:
FINISHED_RESOURCE
ICOState
:
:
READ_PNG
toRead
)
;
}
else
{
int32_t
bihSize
=
LittleEndian
:
:
readUint32
(
aData
)
;
if
(
bihSize
!
=
static_cast
<
int32_t
>
(
BITMAPINFOSIZE
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
memcpy
(
mBIHraw
aData
PNGSIGNATURESIZE
)
;
return
Transition
:
:
To
(
ICOState
:
:
READ_BIH
BITMAPINFOSIZE
-
PNGSIGNATURESIZE
)
;
}
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
ReadPNG
(
const
char
*
aData
uint32_t
aLen
)
{
if
(
!
WriteToContainedDecoder
(
aData
aLen
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
!
static_cast
<
nsPNGDecoder
*
>
(
mContainedDecoder
.
get
(
)
)
-
>
IsValidICO
(
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
return
Transition
:
:
ContinueUnbuffered
(
ICOState
:
:
READ_PNG
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
ReadBIH
(
const
char
*
aData
)
{
memcpy
(
mBIHraw
+
PNGSIGNATURESIZE
aData
BITMAPINFOSIZE
-
PNGSIGNATURESIZE
)
;
mBPP
=
LittleEndian
:
:
readUint16
(
mBIHraw
+
14
)
;
uint32_t
dataOffset
=
bmp
:
:
FILE_HEADER_LENGTH
+
BITMAPINFOSIZE
;
if
(
mDirEntry
.
mBitCount
<
=
8
)
{
uint16_t
numColors
=
GetNumColors
(
)
;
if
(
numColors
=
=
(
uint16_t
)
-
1
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
dataOffset
+
=
4
*
numColors
;
}
mContainedSourceBuffer
=
new
SourceBuffer
(
)
;
mContainedSourceBuffer
-
>
ExpectLength
(
mDirEntry
.
mBytesInRes
)
;
mContainedDecoder
=
DecoderFactory
:
:
CreateDecoderForICOResource
(
DecoderType
:
:
BMP
WrapNotNull
(
mContainedSourceBuffer
)
WrapNotNull
(
this
)
Some
(
dataOffset
)
)
;
RefPtr
<
nsBMPDecoder
>
bmpDecoder
=
static_cast
<
nsBMPDecoder
*
>
(
mContainedDecoder
.
get
(
)
)
;
if
(
!
CheckAndFixBitmapSize
(
reinterpret_cast
<
int8_t
*
>
(
mBIHraw
)
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
!
WriteToContainedDecoder
(
mBIHraw
sizeof
(
mBIHraw
)
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
uint16_t
numColors
=
GetNumColors
(
)
;
if
(
numColors
=
=
uint16_t
(
-
1
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
uint32_t
bmpDataLength
=
bmpDecoder
-
>
GetCompressedImageSize
(
)
+
4
*
numColors
;
bool
hasANDMask
=
(
BITMAPINFOSIZE
+
bmpDataLength
)
<
mDirEntry
.
mBytesInRes
;
ICOState
afterBMPState
=
hasANDMask
?
ICOState
:
:
PREPARE_FOR_MASK
:
ICOState
:
:
FINISHED_RESOURCE
;
return
Transition
:
:
ToUnbuffered
(
afterBMPState
ICOState
:
:
READ_BMP
bmpDataLength
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
ReadBMP
(
const
char
*
aData
uint32_t
aLen
)
{
if
(
!
WriteToContainedDecoder
(
aData
aLen
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
return
Transition
:
:
ContinueUnbuffered
(
ICOState
:
:
READ_BMP
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
PrepareForMask
(
)
{
RefPtr
<
nsBMPDecoder
>
bmpDecoder
=
static_cast
<
nsBMPDecoder
*
>
(
mContainedDecoder
.
get
(
)
)
;
uint16_t
numColors
=
GetNumColors
(
)
;
MOZ_ASSERT
(
numColors
!
=
uint16_t
(
-
1
)
)
;
uint32_t
bmpLengthWithHeader
=
BITMAPINFOSIZE
+
bmpDecoder
-
>
GetCompressedImageSize
(
)
+
4
*
numColors
;
MOZ_ASSERT
(
bmpLengthWithHeader
<
mDirEntry
.
mBytesInRes
)
;
uint32_t
maskLength
=
mDirEntry
.
mBytesInRes
-
bmpLengthWithHeader
;
if
(
bmpDecoder
-
>
HasTransparency
(
)
|
|
GetRealWidth
(
)
=
=
0
|
|
GetRealHeight
(
)
=
=
0
)
{
return
Transition
:
:
ToUnbuffered
(
ICOState
:
:
FINISHED_RESOURCE
ICOState
:
:
SKIP_MASK
maskLength
)
;
}
mMaskRowSize
=
(
(
GetRealWidth
(
)
+
31
)
/
32
)
*
4
;
uint32_t
expectedLength
=
mMaskRowSize
*
GetRealHeight
(
)
;
if
(
maskLength
<
expectedLength
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
if
(
mDownscaler
)
{
MOZ_ASSERT
(
bmpDecoder
-
>
GetImageDataLength
(
)
=
=
mDownscaler
-
>
TargetSize
(
)
.
width
*
mDownscaler
-
>
TargetSize
(
)
.
height
*
sizeof
(
uint32_t
)
)
;
mMaskBuffer
=
MakeUnique
<
uint8_t
[
]
>
(
bmpDecoder
-
>
GetImageDataLength
(
)
)
;
nsresult
rv
=
mDownscaler
-
>
BeginFrame
(
GetRealSize
(
)
Nothing
(
)
mMaskBuffer
.
get
(
)
true
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
}
mCurrMaskLine
=
GetRealHeight
(
)
;
return
Transition
:
:
To
(
ICOState
:
:
READ_MASK_ROW
mMaskRowSize
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
ReadMaskRow
(
const
char
*
aData
)
{
mCurrMaskLine
-
-
;
uint8_t
sawTransparency
=
0
;
const
uint8_t
*
mask
=
reinterpret_cast
<
const
uint8_t
*
>
(
aData
)
;
const
uint8_t
*
maskRowEnd
=
mask
+
mMaskRowSize
;
uint32_t
*
decoded
=
nullptr
;
if
(
mDownscaler
)
{
memset
(
mDownscaler
-
>
RowBuffer
(
)
0xFF
GetRealWidth
(
)
*
sizeof
(
uint32_t
)
)
;
decoded
=
reinterpret_cast
<
uint32_t
*
>
(
mDownscaler
-
>
RowBuffer
(
)
)
;
}
else
{
RefPtr
<
nsBMPDecoder
>
bmpDecoder
=
static_cast
<
nsBMPDecoder
*
>
(
mContainedDecoder
.
get
(
)
)
;
uint32_t
*
imageData
=
bmpDecoder
-
>
GetImageData
(
)
;
if
(
!
imageData
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
decoded
=
imageData
+
mCurrMaskLine
*
GetRealWidth
(
)
;
}
MOZ_ASSERT
(
decoded
)
;
uint32_t
*
decodedRowEnd
=
decoded
+
GetRealWidth
(
)
;
while
(
mask
<
maskRowEnd
)
{
uint8_t
idx
=
*
mask
+
+
;
sawTransparency
|
=
idx
;
for
(
uint8_t
bit
=
0x80
;
bit
&
&
decoded
<
decodedRowEnd
;
bit
>
>
=
1
)
{
if
(
idx
&
bit
)
{
*
decoded
=
0
;
}
decoded
+
+
;
}
}
if
(
mDownscaler
)
{
mDownscaler
-
>
CommitRow
(
)
;
}
if
(
sawTransparency
)
{
mHasMaskAlpha
=
true
;
}
if
(
mCurrMaskLine
=
=
0
)
{
return
Transition
:
:
To
(
ICOState
:
:
FINISH_MASK
0
)
;
}
return
Transition
:
:
To
(
ICOState
:
:
READ_MASK_ROW
mMaskRowSize
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
FinishMask
(
)
{
if
(
mDownscaler
)
{
RefPtr
<
nsBMPDecoder
>
bmpDecoder
=
static_cast
<
nsBMPDecoder
*
>
(
mContainedDecoder
.
get
(
)
)
;
uint8_t
*
imageData
=
reinterpret_cast
<
uint8_t
*
>
(
bmpDecoder
-
>
GetImageData
(
)
)
;
if
(
!
imageData
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
MOZ_ASSERT
(
mMaskBuffer
)
;
MOZ_ASSERT
(
bmpDecoder
-
>
GetImageDataLength
(
)
>
0
)
;
for
(
size_t
i
=
3
;
i
<
bmpDecoder
-
>
GetImageDataLength
(
)
;
i
+
=
4
)
{
imageData
[
i
]
=
mMaskBuffer
[
i
]
;
}
}
return
Transition
:
:
To
(
ICOState
:
:
FINISHED_RESOURCE
0
)
;
}
LexerTransition
<
ICOState
>
nsICODecoder
:
:
FinishResource
(
)
{
if
(
mContainedDecoder
-
>
HasSize
(
)
&
&
mContainedDecoder
-
>
Size
(
)
!
=
GetRealSize
(
)
)
{
return
Transition
:
:
TerminateFailure
(
)
;
}
return
Transition
:
:
TerminateSuccess
(
)
;
}
LexerResult
nsICODecoder
:
:
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
{
MOZ_ASSERT
(
!
HasError
(
)
"
Shouldn
'
t
call
DoDecode
after
error
!
"
)
;
return
mLexer
.
Lex
(
aIterator
aOnResume
[
=
]
(
ICOState
aState
const
char
*
aData
size_t
aLength
)
{
switch
(
aState
)
{
case
ICOState
:
:
HEADER
:
return
ReadHeader
(
aData
)
;
case
ICOState
:
:
DIR_ENTRY
:
return
ReadDirEntry
(
aData
)
;
case
ICOState
:
:
SKIP_TO_RESOURCE
:
return
Transition
:
:
ContinueUnbuffered
(
ICOState
:
:
SKIP_TO_RESOURCE
)
;
case
ICOState
:
:
FOUND_RESOURCE
:
return
Transition
:
:
To
(
ICOState
:
:
SNIFF_RESOURCE
PNGSIGNATURESIZE
)
;
case
ICOState
:
:
SNIFF_RESOURCE
:
return
SniffResource
(
aData
)
;
case
ICOState
:
:
READ_PNG
:
return
ReadPNG
(
aData
aLength
)
;
case
ICOState
:
:
READ_BIH
:
return
ReadBIH
(
aData
)
;
case
ICOState
:
:
READ_BMP
:
return
ReadBMP
(
aData
aLength
)
;
case
ICOState
:
:
PREPARE_FOR_MASK
:
return
PrepareForMask
(
)
;
case
ICOState
:
:
READ_MASK_ROW
:
return
ReadMaskRow
(
aData
)
;
case
ICOState
:
:
FINISH_MASK
:
return
FinishMask
(
)
;
case
ICOState
:
:
SKIP_MASK
:
return
Transition
:
:
ContinueUnbuffered
(
ICOState
:
:
SKIP_MASK
)
;
case
ICOState
:
:
FINISHED_RESOURCE
:
return
FinishResource
(
)
;
default
:
MOZ_CRASH
(
"
Unknown
ICOState
"
)
;
}
}
)
;
}
bool
nsICODecoder
:
:
WriteToContainedDecoder
(
const
char
*
aBuffer
uint32_t
aCount
)
{
MOZ_ASSERT
(
mContainedDecoder
)
;
MOZ_ASSERT
(
mContainedSourceBuffer
)
;
mContainedSourceBuffer
-
>
Append
(
aBuffer
aCount
)
;
bool
succeeded
=
true
;
LexerResult
result
=
mContainedDecoder
-
>
Decode
(
)
;
if
(
result
=
=
LexerResult
(
TerminalState
:
:
FAILURE
)
)
{
succeeded
=
false
;
}
MOZ_ASSERT
(
result
!
=
LexerResult
(
Yield
:
:
OUTPUT_AVAILABLE
)
"
Unexpected
yield
"
)
;
mProgress
|
=
mContainedDecoder
-
>
TakeProgress
(
)
;
mInvalidRect
.
UnionRect
(
mInvalidRect
mContainedDecoder
-
>
TakeInvalidRect
(
)
)
;
if
(
mContainedDecoder
-
>
HasError
(
)
)
{
succeeded
=
false
;
}
return
succeeded
;
}
}
}
