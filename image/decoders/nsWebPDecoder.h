#
ifndef
mozilla_image_decoders_nsWebPDecoder_h
#
define
mozilla_image_decoders_nsWebPDecoder_h
#
include
"
Decoder
.
h
"
#
include
"
webp
/
demux
.
h
"
#
include
"
StreamingLexer
.
h
"
#
include
"
SurfacePipe
.
h
"
namespace
mozilla
{
namespace
image
{
class
RasterImage
;
class
nsWebPDecoder
final
:
public
Decoder
{
public
:
virtual
~
nsWebPDecoder
(
)
;
DecoderType
GetType
(
)
const
override
{
return
DecoderType
:
:
WEBP
;
}
protected
:
LexerResult
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
override
;
Maybe
<
Telemetry
:
:
HistogramID
>
SpeedHistogram
(
)
const
override
;
private
:
friend
class
DecoderFactory
;
explicit
nsWebPDecoder
(
RasterImage
*
aImage
)
;
void
ApplyColorProfile
(
const
char
*
aProfile
size_t
aLength
)
;
LexerResult
UpdateBuffer
(
SourceBufferIterator
&
aIterator
SourceBufferIterator
:
:
State
aState
)
;
LexerResult
ReadData
(
)
;
LexerResult
ReadHeader
(
WebPDemuxer
*
aDemuxer
bool
aIsComplete
)
;
LexerResult
ReadPayload
(
WebPDemuxer
*
aDemuxer
bool
aIsComplete
)
;
nsresult
CreateFrame
(
const
nsIntRect
&
aFrameRect
)
;
void
EndFrame
(
)
;
LexerResult
ReadSingle
(
const
uint8_t
*
aData
size_t
aLength
const
IntRect
&
aFrameRect
)
;
LexerResult
ReadMultiple
(
WebPDemuxer
*
aDemuxer
bool
aIsComplete
)
;
SurfacePipe
mPipe
;
Vector
<
uint8_t
>
mBufferedData
;
WebPDecBuffer
mBuffer
;
WebPIDecoder
*
mDecoder
;
BlendMethod
mBlend
;
DisposalMethod
mDisposal
;
FrameTimeout
mTimeout
;
gfx
:
:
SurfaceFormat
mFormat
;
IntRect
mFrameRect
;
int
mLastRow
;
uint32_t
mCurrentFrame
;
const
uint8_t
*
mData
;
size_t
mLength
;
bool
mIteratorComplete
;
bool
mNeedDemuxer
;
bool
mGotColorProfile
;
}
;
}
}
#
endif
