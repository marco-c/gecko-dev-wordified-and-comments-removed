#
ifndef
mozilla_image_decoders_nsPNGDecoder_h
#
define
mozilla_image_decoders_nsPNGDecoder_h
#
include
"
Decoder
.
h
"
#
include
"
png
.
h
"
#
include
"
qcms
.
h
"
#
include
"
SurfacePipe
.
h
"
namespace
mozilla
{
namespace
image
{
class
RasterImage
;
class
nsPNGDecoder
:
public
Decoder
{
public
:
virtual
~
nsPNGDecoder
(
)
;
virtual
void
InitInternal
(
)
override
;
virtual
void
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
override
;
virtual
Telemetry
:
:
ID
SpeedHistogram
(
)
override
;
private
:
friend
class
DecoderFactory
;
friend
class
nsICODecoder
;
explicit
nsPNGDecoder
(
RasterImage
*
aImage
)
;
nsresult
CreateFrame
(
gfx
:
:
SurfaceFormat
aFormat
const
gfx
:
:
IntRect
&
aFrameRect
bool
aIsInterlaced
)
;
void
EndImageFrame
(
)
;
enum
class
TransparencyType
{
eNone
eAlpha
eFrameRect
}
;
TransparencyType
GetTransparencyType
(
gfx
:
:
SurfaceFormat
aFormat
const
gfx
:
:
IntRect
&
aFrameRect
)
;
void
PostHasTransparencyIfNeeded
(
TransparencyType
aTransparencyType
)
;
void
PostInvalidationIfNeeded
(
)
;
void
WriteRow
(
uint8_t
*
aRow
)
;
bool
IsValidICO
(
)
const
{
if
(
setjmp
(
png_jmpbuf
(
mPNG
)
)
)
{
return
false
;
}
png_uint_32
png_width
png_height
;
int
png_bit_depth
png_color_type
;
if
(
png_get_IHDR
(
mPNG
mInfo
&
png_width
&
png_height
&
png_bit_depth
&
png_color_type
nullptr
nullptr
nullptr
)
)
{
return
(
(
png_color_type
=
=
PNG_COLOR_TYPE_RGB_ALPHA
|
|
png_color_type
=
=
PNG_COLOR_TYPE_RGB
)
&
&
png_bit_depth
=
=
8
)
;
}
else
{
return
false
;
}
}
public
:
png_structp
mPNG
;
png_infop
mInfo
;
nsIntRect
mFrameRect
;
uint8_t
*
mCMSLine
;
uint8_t
*
interlacebuf
;
qcms_profile
*
mInProfile
;
qcms_transform
*
mTransform
;
gfx
:
:
SurfaceFormat
format
;
uint32_t
mCMSMode
;
uint8_t
mChannels
;
uint8_t
mPass
;
bool
mFrameIsHidden
;
bool
mDisablePremultipliedAlpha
;
struct
AnimFrameInfo
{
AnimFrameInfo
(
)
;
#
ifdef
PNG_APNG_SUPPORTED
AnimFrameInfo
(
png_structp
aPNG
png_infop
aInfo
)
;
#
endif
DisposalMethod
mDispose
;
BlendMethod
mBlend
;
int32_t
mTimeout
;
}
;
AnimFrameInfo
mAnimInfo
;
SurfacePipe
mPipe
;
uint32_t
mNumFrames
;
static
void
PNGAPI
info_callback
(
png_structp
png_ptr
png_infop
info_ptr
)
;
static
void
PNGAPI
row_callback
(
png_structp
png_ptr
png_bytep
new_row
png_uint_32
row_num
int
pass
)
;
#
ifdef
PNG_APNG_SUPPORTED
static
void
PNGAPI
frame_info_callback
(
png_structp
png_ptr
png_uint_32
frame_num
)
;
#
endif
static
void
PNGAPI
end_callback
(
png_structp
png_ptr
png_infop
info_ptr
)
;
static
void
PNGAPI
error_callback
(
png_structp
png_ptr
png_const_charp
error_msg
)
;
static
void
PNGAPI
warning_callback
(
png_structp
png_ptr
png_const_charp
warning_msg
)
;
static
const
uint8_t
pngSignatureBytes
[
]
;
}
;
}
}
#
endif
