#
include
"
SVGDocumentWrapper
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
dom
/
SVGDocument
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocumentLoaderFactory
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsRefreshDriver
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
gfx
;
namespace
image
{
NS_IMPL_ISUPPORTS
(
SVGDocumentWrapper
nsIStreamListener
nsIRequestObserver
nsIObserver
nsISupportsWeakReference
)
SVGDocumentWrapper
:
:
SVGDocumentWrapper
(
)
:
mIgnoreInvalidation
(
false
)
mRegisteredForXPCOMShutdown
(
false
)
{
}
SVGDocumentWrapper
:
:
~
SVGDocumentWrapper
(
)
{
DestroyViewer
(
)
;
if
(
mRegisteredForXPCOMShutdown
)
{
UnregisterForXPCOMShutdown
(
)
;
}
}
void
SVGDocumentWrapper
:
:
DestroyViewer
(
)
{
if
(
mViewer
)
{
mViewer
-
>
GetDocument
(
)
-
>
OnPageHide
(
false
nullptr
)
;
mViewer
-
>
Close
(
nullptr
)
;
mViewer
-
>
Destroy
(
)
;
mViewer
=
nullptr
;
}
}
nsIFrame
*
SVGDocumentWrapper
:
:
GetRootLayoutFrame
(
)
{
Element
*
rootElem
=
GetRootSVGElem
(
)
;
return
rootElem
?
rootElem
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
void
SVGDocumentWrapper
:
:
UpdateViewportBounds
(
const
nsIntSize
&
aViewportSize
)
{
MOZ_ASSERT
(
!
mIgnoreInvalidation
"
shouldn
'
t
be
reentrant
"
)
;
mIgnoreInvalidation
=
true
;
nsIntRect
currentBounds
;
mViewer
-
>
GetBounds
(
currentBounds
)
;
if
(
currentBounds
.
Size
(
)
!
=
aViewportSize
)
{
mViewer
-
>
SetBounds
(
IntRect
(
IntPoint
(
0
0
)
aViewportSize
)
)
;
FlushLayout
(
)
;
}
mIgnoreInvalidation
=
false
;
}
void
SVGDocumentWrapper
:
:
FlushImageTransformInvalidation
(
)
{
MOZ_ASSERT
(
!
mIgnoreInvalidation
"
shouldn
'
t
be
reentrant
"
)
;
SVGSVGElement
*
svgElem
=
GetRootSVGElem
(
)
;
if
(
!
svgElem
)
{
return
;
}
mIgnoreInvalidation
=
true
;
svgElem
-
>
FlushImageTransformInvalidation
(
)
;
FlushLayout
(
)
;
mIgnoreInvalidation
=
false
;
}
bool
SVGDocumentWrapper
:
:
IsAnimated
(
)
{
if
(
!
mViewer
)
{
return
false
;
}
Document
*
doc
=
mViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
false
;
}
if
(
doc
-
>
Timeline
(
)
-
>
HasAnimations
(
)
)
{
return
true
;
}
if
(
doc
-
>
HasAnimationController
(
)
&
&
doc
-
>
GetAnimationController
(
)
-
>
HasRegisteredAnimations
(
)
)
{
return
true
;
}
return
false
;
}
void
SVGDocumentWrapper
:
:
StartAnimation
(
)
{
if
(
!
mViewer
)
{
return
;
}
Document
*
doc
=
mViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
SMILAnimationController
*
controller
=
doc
-
>
GetAnimationController
(
)
;
if
(
controller
)
{
controller
-
>
Resume
(
SMILTimeContainer
:
:
PAUSE_IMAGE
)
;
}
doc
-
>
ImageTracker
(
)
-
>
SetAnimatingState
(
true
)
;
}
}
void
SVGDocumentWrapper
:
:
StopAnimation
(
)
{
if
(
!
mViewer
)
{
return
;
}
Document
*
doc
=
mViewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
SMILAnimationController
*
controller
=
doc
-
>
GetAnimationController
(
)
;
if
(
controller
)
{
controller
-
>
Pause
(
SMILTimeContainer
:
:
PAUSE_IMAGE
)
;
}
doc
-
>
ImageTracker
(
)
-
>
SetAnimatingState
(
false
)
;
}
}
void
SVGDocumentWrapper
:
:
ResetAnimation
(
)
{
SVGSVGElement
*
svgElem
=
GetRootSVGElem
(
)
;
if
(
!
svgElem
)
{
return
;
}
svgElem
-
>
SetCurrentTime
(
0
.
0f
)
;
}
float
SVGDocumentWrapper
:
:
GetCurrentTimeAsFloat
(
)
{
SVGSVGElement
*
svgElem
=
GetRootSVGElem
(
)
;
return
svgElem
?
svgElem
-
>
GetCurrentTimeAsFloat
(
)
:
0
.
0f
;
}
void
SVGDocumentWrapper
:
:
SetCurrentTime
(
float
aTime
)
{
SVGSVGElement
*
svgElem
=
GetRootSVGElem
(
)
;
if
(
svgElem
&
&
svgElem
-
>
GetCurrentTimeAsFloat
(
)
!
=
aTime
)
{
svgElem
-
>
SetCurrentTime
(
aTime
)
;
}
}
void
SVGDocumentWrapper
:
:
TickRefreshDriver
(
)
{
if
(
RefPtr
<
PresShell
>
presShell
=
mViewer
-
>
GetPresShell
(
)
)
{
if
(
RefPtr
<
nsPresContext
>
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
RefreshDriver
(
)
-
>
DoTick
(
)
;
}
}
}
NS_IMETHODIMP
SVGDocumentWrapper
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
inStr
uint64_t
sourceOffset
uint32_t
count
)
{
return
mListener
-
>
OnDataAvailable
(
aRequest
inStr
sourceOffset
count
)
;
}
NS_IMETHODIMP
SVGDocumentWrapper
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
nsresult
rv
=
SetupViewer
(
aRequest
getter_AddRefs
(
mViewer
)
getter_AddRefs
(
mLoadGroup
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
NS_SUCCEEDED
(
mListener
-
>
OnStartRequest
(
aRequest
)
)
)
{
mViewer
-
>
GetDocument
(
)
-
>
SetIsBeingUsedAsImage
(
)
;
StopAnimation
(
)
;
rv
=
mViewer
-
>
Init
(
nullptr
nsIntRect
(
0
0
0
0
)
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
mViewer
-
>
Open
(
nullptr
nullptr
)
;
}
}
return
rv
;
}
NS_IMETHODIMP
SVGDocumentWrapper
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
status
)
{
if
(
mListener
)
{
mListener
-
>
OnStopRequest
(
aRequest
status
)
;
mListener
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
SVGDocumentWrapper
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
{
SVGSVGElement
*
svgElem
=
GetRootSVGElem
(
)
;
if
(
svgElem
)
{
SVGObserverUtils
:
:
RemoveAllRenderingObservers
(
svgElem
)
;
}
DestroyViewer
(
)
;
if
(
mListener
)
{
mListener
=
nullptr
;
}
if
(
mLoadGroup
)
{
mLoadGroup
=
nullptr
;
}
mRegisteredForXPCOMShutdown
=
false
;
}
else
{
NS_ERROR
(
"
Unexpected
observer
topic
.
"
)
;
}
return
NS_OK
;
}
nsresult
SVGDocumentWrapper
:
:
SetupViewer
(
nsIRequest
*
aRequest
nsIContentViewer
*
*
aViewer
nsILoadGroup
*
*
aLoadGroup
)
{
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
aRequest
)
)
;
NS_ENSURE_TRUE
(
chan
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
if
(
NS_FAILED
(
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
)
|
|
!
requestSucceeded
)
{
return
NS_ERROR_FAILURE
;
}
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
chan
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
nsCOMPtr
<
nsILoadGroup
>
newLoadGroup
=
do_CreateInstance
(
NS_LOADGROUP_CONTRACTID
)
;
NS_ENSURE_TRUE
(
newLoadGroup
NS_ERROR_OUT_OF_MEMORY
)
;
newLoadGroup
-
>
SetLoadGroup
(
loadGroup
)
;
nsCOMPtr
<
nsICategoryManager
>
catMan
=
do_GetService
(
NS_CATEGORYMANAGER_CONTRACTID
)
;
NS_ENSURE_TRUE
(
catMan
NS_ERROR_NOT_AVAILABLE
)
;
nsCString
contractId
;
nsresult
rv
=
catMan
-
>
GetCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
IMAGE_SVG_XML
contractId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docLoaderFactory
=
do_GetService
(
contractId
.
get
(
)
)
;
NS_ENSURE_TRUE
(
docLoaderFactory
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
docLoaderFactory
-
>
CreateInstance
(
"
external
-
resource
"
chan
newLoadGroup
nsLiteralCString
(
IMAGE_SVG_XML
)
nullptr
nullptr
getter_AddRefs
(
listener
)
getter_AddRefs
(
viewer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
viewer
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
nsDOMNavigationTiming
>
timing
=
new
nsDOMNavigationTiming
(
nullptr
)
;
timing
-
>
NotifyNavigationStart
(
nsDOMNavigationTiming
:
:
DocShellState
:
:
eInactive
)
;
viewer
-
>
SetNavigationTiming
(
timing
)
;
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryInterface
(
listener
)
;
NS_ENSURE_TRUE
(
parser
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIContentSink
>
sink
=
parser
-
>
GetContentSink
(
)
;
NS_ENSURE_TRUE
(
sink
NS_ERROR_UNEXPECTED
)
;
listener
.
swap
(
mListener
)
;
viewer
.
forget
(
aViewer
)
;
newLoadGroup
.
forget
(
aLoadGroup
)
;
RegisterForXPCOMShutdown
(
)
;
return
NS_OK
;
}
void
SVGDocumentWrapper
:
:
RegisterForXPCOMShutdown
(
)
{
MOZ_ASSERT
(
!
mRegisteredForXPCOMShutdown
"
re
-
registering
for
XPCOM
shutdown
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
do_GetService
(
OBSERVER_SVC_CID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
obsSvc
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
true
)
)
)
{
NS_WARNING
(
"
Failed
to
register
as
observer
of
XPCOM
shutdown
"
)
;
}
else
{
mRegisteredForXPCOMShutdown
=
true
;
}
}
void
SVGDocumentWrapper
:
:
UnregisterForXPCOMShutdown
(
)
{
MOZ_ASSERT
(
mRegisteredForXPCOMShutdown
"
unregistering
for
XPCOM
shutdown
w
/
out
being
registered
"
)
;
nsresult
rv
;
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
do_GetService
(
OBSERVER_SVC_CID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
obsSvc
-
>
RemoveObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
)
)
{
NS_WARNING
(
"
Failed
to
unregister
as
observer
of
XPCOM
shutdown
"
)
;
}
else
{
mRegisteredForXPCOMShutdown
=
false
;
}
}
void
SVGDocumentWrapper
:
:
FlushLayout
(
)
{
if
(
SVGDocument
*
doc
=
GetDocument
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
SVGDocument
*
SVGDocumentWrapper
:
:
GetDocument
(
)
{
if
(
!
mViewer
)
{
return
nullptr
;
}
Document
*
doc
=
mViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
return
doc
-
>
AsSVGDocument
(
)
;
}
SVGSVGElement
*
SVGDocumentWrapper
:
:
GetRootSVGElem
(
)
{
if
(
!
mViewer
)
{
return
nullptr
;
}
Document
*
doc
=
mViewer
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
Element
*
rootElem
=
mViewer
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
;
if
(
!
rootElem
|
|
!
rootElem
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
nullptr
;
}
return
static_cast
<
SVGSVGElement
*
>
(
rootElem
)
;
}
}
}
