#
ifndef
mozilla_image_imgRequestProxy_h
#
define
mozilla_image_imgRequestProxy_h
#
include
"
imgIRequest
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
imgRequest
.
h
"
#
include
"
IProgressObserver
.
h
"
#
define
NS_IMGREQUESTPROXY_CID
\
{
/
*
20557898
-
1dd2
-
11b2
-
8f65
-
9c462ee2bc95
*
/
\
0x20557898
0x1dd2
0x11b2
{
\
0x8f
0x65
0x9c
0x46
0x2e
0xe2
0xbc
0x95
\
}
\
}
class
imgCacheValidator
;
class
imgINotificationObserver
;
class
imgStatusNotifyRunnable
;
class
ProxyBehaviour
;
namespace
mozilla
{
namespace
dom
{
class
TabGroup
;
}
namespace
image
{
class
Image
;
class
ProgressTracker
;
}
}
class
imgRequestProxy
:
public
imgIRequest
public
mozilla
:
:
image
:
:
IProgressObserver
public
nsISupportsPriority
public
nsITimedChannel
{
protected
:
virtual
~
imgRequestProxy
(
)
;
public
:
typedef
mozilla
:
:
dom
:
:
Document
Document
;
typedef
mozilla
:
:
image
:
:
Image
Image
;
typedef
mozilla
:
:
image
:
:
ProgressTracker
ProgressTracker
;
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
imgRequestProxy
)
NS_DECL_ISUPPORTS
NS_DECL_IMGIREQUEST
NS_DECL_NSIREQUEST
NS_DECL_NSISUPPORTSPRIORITY
imgRequestProxy
(
)
;
nsresult
Init
(
imgRequest
*
aOwner
nsILoadGroup
*
aLoadGroup
Document
*
aLoadingDocument
nsIURI
*
aURI
imgINotificationObserver
*
aObserver
)
;
nsresult
ChangeOwner
(
imgRequest
*
aNewOwner
)
;
void
AddToLoadGroup
(
)
;
inline
bool
HasObserver
(
)
const
{
return
mListener
!
=
nullptr
;
}
void
NotifyListener
(
)
;
void
SyncNotifyListener
(
)
;
virtual
void
Notify
(
int32_t
aType
const
mozilla
:
:
gfx
:
:
IntRect
*
aRect
=
nullptr
)
override
;
virtual
void
OnLoadComplete
(
bool
aLastPart
)
override
;
virtual
void
SetHasImage
(
)
override
;
virtual
bool
NotificationsDeferred
(
)
const
override
{
return
IsValidating
(
)
|
|
mPendingNotify
;
}
virtual
void
MarkPendingNotify
(
)
override
{
mPendingNotify
=
true
;
}
virtual
void
ClearPendingNotify
(
)
override
{
mPendingNotify
=
false
;
}
bool
IsValidating
(
)
const
{
return
mValidating
;
}
void
MarkValidating
(
)
;
void
ClearValidating
(
)
;
bool
IsOnEventTarget
(
)
const
;
already_AddRefed
<
nsIEventTarget
>
GetEventTarget
(
)
const
override
;
void
ClearAnimationConsumers
(
)
;
nsresult
SyncClone
(
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
imgRequestProxy
*
*
aClone
)
;
nsresult
Clone
(
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
imgRequestProxy
*
*
aClone
)
;
nsresult
GetStaticRequest
(
Document
*
aLoadingDocument
imgRequestProxy
*
*
aReturn
)
;
protected
:
friend
class
mozilla
:
:
image
:
:
ProgressTracker
;
friend
class
imgStatusNotifyRunnable
;
class
imgCancelRunnable
;
friend
class
imgCancelRunnable
;
class
imgCancelRunnable
:
public
mozilla
:
:
Runnable
{
public
:
imgCancelRunnable
(
imgRequestProxy
*
owner
nsresult
status
)
:
Runnable
(
"
imgCancelRunnable
"
)
mOwner
(
owner
)
mStatus
(
status
)
{
}
NS_IMETHOD
Run
(
)
override
{
mOwner
-
>
DoCancel
(
mStatus
)
;
return
NS_OK
;
}
private
:
RefPtr
<
imgRequestProxy
>
mOwner
;
nsresult
mStatus
;
}
;
void
RemoveFromLoadGroup
(
)
;
void
MoveToBackgroundInLoadGroup
(
)
;
void
DoCancel
(
nsresult
status
)
;
void
NullOutListener
(
)
;
already_AddRefed
<
ProgressTracker
>
GetProgressTracker
(
)
const
;
nsITimedChannel
*
TimedChannel
(
)
{
if
(
!
GetOwner
(
)
)
{
return
nullptr
;
}
return
GetOwner
(
)
-
>
GetTimedChannel
(
)
;
}
already_AddRefed
<
Image
>
GetImage
(
)
const
;
bool
HasImage
(
)
const
;
imgRequest
*
GetOwner
(
)
const
;
imgCacheValidator
*
GetValidator
(
)
const
;
nsresult
PerformClone
(
imgINotificationObserver
*
aObserver
Document
*
aLoadingDocument
bool
aSyncNotify
imgRequestProxy
*
*
aClone
)
;
virtual
imgRequestProxy
*
NewClonedProxy
(
)
;
public
:
NS_FORWARD_SAFE_NSITIMEDCHANNEL
(
TimedChannel
(
)
)
protected
:
mozilla
:
:
UniquePtr
<
ProxyBehaviour
>
mBehaviour
;
private
:
friend
class
imgCacheValidator
;
void
AddToOwner
(
Document
*
aLoadingDocument
)
;
void
RemoveFromOwner
(
nsresult
aStatus
)
;
nsresult
DispatchWithTargetIfAvailable
(
already_AddRefed
<
nsIRunnable
>
aEvent
)
;
void
DispatchWithTarget
(
already_AddRefed
<
nsIRunnable
>
aEvent
)
;
nsCOMPtr
<
nsIURI
>
mURI
;
imgINotificationObserver
*
MOZ_UNSAFE_REF
(
"
Observers
must
call
Cancel
(
)
or
"
"
CancelAndForgetObserver
(
)
before
"
"
they
are
destroyed
"
)
mListener
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
RefPtr
<
mozilla
:
:
dom
:
:
TabGroup
>
mTabGroup
;
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
nsLoadFlags
mLoadFlags
;
uint32_t
mLockCount
;
uint32_t
mAnimationConsumers
;
bool
mCanceled
:
1
;
bool
mIsInLoadGroup
:
1
;
bool
mForceDispatchLoadGroup
:
1
;
bool
mListenerIsStrongRef
:
1
;
bool
mDecodeRequested
:
1
;
bool
mPendingNotify
:
1
;
bool
mValidating
:
1
;
bool
mHadListener
:
1
;
bool
mHadDispatch
:
1
;
}
;
class
imgRequestProxyStatic
:
public
imgRequestProxy
{
public
:
imgRequestProxyStatic
(
Image
*
aImage
nsIPrincipal
*
aPrincipal
bool
hadCrossOriginRedirects
)
;
NS_IMETHOD
GetImagePrincipal
(
nsIPrincipal
*
*
aPrincipal
)
override
;
NS_IMETHOD
GetHadCrossOriginRedirects
(
bool
*
aHadCrossOriginRedirects
)
override
;
protected
:
imgRequestProxy
*
NewClonedProxy
(
)
override
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
const
bool
mHadCrossOriginRedirects
;
}
;
#
endif
