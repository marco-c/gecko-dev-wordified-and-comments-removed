#
ifndef
mozilla_image_VectorImage_h
#
define
mozilla_image_VectorImage_h
#
include
"
Image
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
class
nsIRequest
;
class
gfxDrawable
;
namespace
mozilla
{
namespace
image
{
struct
SVGDrawingParameters
;
class
SVGDocumentWrapper
;
class
SVGRootRenderingObserver
;
class
SVGLoadEventListener
;
class
SVGParseCompleteListener
;
class
VectorImage
final
:
public
ImageResource
public
nsIStreamListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_IMGICONTAINER
nsresult
GetNativeSizes
(
nsTArray
<
gfx
:
:
IntSize
>
&
aNativeSizes
)
const
override
;
size_t
GetNativeSizesLength
(
)
const
override
;
virtual
size_t
SizeOfSourceWithComputedFallback
(
SizeOfState
&
aState
)
const
override
;
virtual
void
CollectSizeOfSurfaces
(
nsTArray
<
SurfaceMemoryCounter
>
&
aCounters
MallocSizeOf
aMallocSizeOf
)
const
override
;
virtual
nsresult
OnImageDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
override
;
virtual
nsresult
OnImageDataComplete
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aResult
bool
aLastPart
)
override
;
virtual
void
OnSurfaceDiscarded
(
const
SurfaceKey
&
aSurfaceKey
)
override
;
void
InvalidateObserversOnNextRefreshDriverTick
(
)
;
void
OnSVGDocumentParsed
(
)
;
void
OnSVGDocumentLoaded
(
)
;
void
OnSVGDocumentError
(
)
;
protected
:
explicit
VectorImage
(
nsIURI
*
aURI
=
nullptr
)
;
virtual
~
VectorImage
(
)
;
virtual
nsresult
StartAnimation
(
)
override
;
virtual
nsresult
StopAnimation
(
)
override
;
virtual
bool
ShouldAnimate
(
)
override
;
private
:
Tuple
<
ImgDrawResult
IntSize
RefPtr
<
SourceSurface
>
>
GetFrameInternal
(
const
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aWhichFrame
uint32_t
aFlags
)
override
;
Tuple
<
ImgDrawResult
IntSize
>
GetImageContainerSize
(
layers
:
:
LayerManager
*
aManager
const
IntSize
&
aSize
uint32_t
aFlags
)
override
;
Tuple
<
RefPtr
<
SourceSurface
>
IntSize
>
LookupCachedSurface
(
const
IntSize
&
aSize
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
)
;
bool
MaybeRestrictSVGContext
(
Maybe
<
SVGImageContext
>
&
aNewSVGContext
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aFlags
)
;
already_AddRefed
<
gfxDrawable
>
CreateSVGDrawable
(
const
SVGDrawingParameters
&
aParams
)
;
already_AddRefed
<
SourceSurface
>
CreateSurface
(
const
SVGDrawingParameters
&
aParams
gfxDrawable
*
aSVGDrawable
bool
&
aWillCache
)
;
void
SendFrameComplete
(
bool
aDidCache
uint32_t
aFlags
)
;
void
Show
(
gfxDrawable
*
aDrawable
const
SVGDrawingParameters
&
aParams
)
;
nsresult
Init
(
const
char
*
aMimeType
uint32_t
aFlags
)
;
void
RecoverFromLossOfSurfaces
(
)
;
void
CancelAllListeners
(
)
;
void
SendInvalidationNotifications
(
)
;
RefPtr
<
SVGDocumentWrapper
>
mSVGDocumentWrapper
;
RefPtr
<
SVGRootRenderingObserver
>
mRenderingObserver
;
RefPtr
<
SVGLoadEventListener
>
mLoadEventListener
;
RefPtr
<
SVGParseCompleteListener
>
mParseCompleteListener
;
uint32_t
mLockCount
;
Maybe
<
Progress
>
mLoadProgress
;
bool
mIsInitialized
;
bool
mDiscardable
;
bool
mIsFullyLoaded
;
bool
mIsDrawing
;
bool
mHaveAnimations
;
bool
mHasPendingInvalidation
;
friend
class
ImageFactory
;
}
;
inline
NS_IMETHODIMP
VectorImage
:
:
GetAnimationMode
(
uint16_t
*
aAnimationMode
)
{
return
GetAnimationModeInternal
(
aAnimationMode
)
;
}
inline
NS_IMETHODIMP
VectorImage
:
:
SetAnimationMode
(
uint16_t
aAnimationMode
)
{
return
SetAnimationModeInternal
(
aAnimationMode
)
;
}
}
}
#
endif
