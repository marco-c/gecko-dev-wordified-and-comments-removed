#
ifndef
mozilla_image_Decoder_h
#
define
mozilla_image_Decoder_h
#
include
"
FrameAnimator
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
DecoderFlags
.
h
"
#
include
"
Downscaler
.
h
"
#
include
"
ImageMetadata
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
StreamingLexer
.
h
"
#
include
"
SurfaceFlags
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
enum
ID
:
uint32_t
;
}
namespace
image
{
struct
DecoderFinalStatus
final
{
DecoderFinalStatus
(
bool
aWasMetadataDecode
bool
aFinished
bool
aHadError
bool
aShouldReportError
)
:
mWasMetadataDecode
(
aWasMetadataDecode
)
mFinished
(
aFinished
)
mHadError
(
aHadError
)
mShouldReportError
(
aShouldReportError
)
{
}
const
bool
mWasMetadataDecode
:
1
;
const
bool
mFinished
:
1
;
const
bool
mHadError
:
1
;
const
bool
mShouldReportError
:
1
;
}
;
struct
DecoderTelemetry
final
{
DecoderTelemetry
(
Maybe
<
Telemetry
:
:
ID
>
aSpeedHistogram
size_t
aBytesDecoded
uint32_t
aChunkCount
TimeDuration
aDecodeTime
)
:
mSpeedHistogram
(
aSpeedHistogram
)
mBytesDecoded
(
aBytesDecoded
)
mChunkCount
(
aChunkCount
)
mDecodeTime
(
aDecodeTime
)
{
}
int32_t
Speed
(
)
const
{
return
mBytesDecoded
/
(
1024
*
mDecodeTime
.
ToSeconds
(
)
)
;
}
int32_t
DecodeTimeMicros
(
)
{
return
mDecodeTime
.
ToMicroseconds
(
)
;
}
const
Maybe
<
Telemetry
:
:
ID
>
mSpeedHistogram
;
const
size_t
mBytesDecoded
;
const
uint32_t
mChunkCount
;
const
TimeDuration
mDecodeTime
;
}
;
class
Decoder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Decoder
)
explicit
Decoder
(
RasterImage
*
aImage
)
;
nsresult
Init
(
)
;
LexerResult
Decode
(
IResumable
*
aOnResume
=
nullptr
)
;
LexerResult
TerminateFailure
(
)
;
bool
ShouldSyncDecode
(
size_t
aByteLimit
)
;
nsIntRect
TakeInvalidRect
(
)
{
nsIntRect
invalidRect
=
mInvalidRect
;
mInvalidRect
.
SetEmpty
(
)
;
return
invalidRect
;
}
Progress
TakeProgress
(
)
{
Progress
progress
=
mProgress
;
mProgress
=
NoProgress
;
return
progress
;
}
bool
HasProgress
(
)
const
{
return
mProgress
!
=
NoProgress
|
|
!
mInvalidRect
.
IsEmpty
(
)
|
|
mFinishedNewFrame
;
}
void
SetMetadataDecode
(
bool
aMetadataDecode
)
{
MOZ_ASSERT
(
!
mInitialized
"
Shouldn
'
t
be
initialized
yet
"
)
;
mMetadataDecode
=
aMetadataDecode
;
}
bool
IsMetadataDecode
(
)
const
{
return
mMetadataDecode
;
}
void
SetOutputSize
(
const
gfx
:
:
IntSize
&
aSize
)
;
gfx
:
:
IntSize
OutputSize
(
)
const
{
MOZ_ASSERT
(
HasSize
(
)
)
;
return
*
mOutputSize
;
}
Maybe
<
gfx
:
:
IntSize
>
ExplicitOutputSize
(
)
const
;
virtual
void
SetSampleSize
(
int
aSampleSize
)
{
}
void
SetIterator
(
SourceBufferIterator
&
&
aIterator
)
{
MOZ_ASSERT
(
!
mInitialized
"
Shouldn
'
t
be
initialized
yet
"
)
;
mIterator
.
emplace
(
Move
(
aIterator
)
)
;
}
bool
ShouldSendPartialInvalidations
(
)
const
{
return
!
(
mDecoderFlags
&
DecoderFlags
:
:
IS_REDECODE
)
;
}
bool
IsFirstFrameDecode
(
)
const
{
return
bool
(
mDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
;
}
Maybe
<
uint32_t
>
TakeCompleteFrameCount
(
)
;
uint32_t
GetFrameCount
(
)
{
return
mFrameCount
;
}
bool
HasAnimation
(
)
const
{
return
mImageMetadata
.
HasAnimation
(
)
;
}
bool
HasError
(
)
const
{
return
mError
;
}
bool
ShouldReportError
(
)
const
{
return
mShouldReportError
;
}
bool
GetDecodeDone
(
)
const
{
return
mReachedTerminalState
|
|
mDecodeDone
|
|
(
mMetadataDecode
&
&
HasSize
(
)
)
|
|
HasError
(
)
;
}
bool
InFrame
(
)
const
{
return
mInFrame
;
}
enum
DecodeStyle
{
PROGRESSIVE
SEQUENTIAL
}
;
void
SetDecoderFlags
(
DecoderFlags
aDecoderFlags
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mDecoderFlags
=
aDecoderFlags
;
}
DecoderFlags
GetDecoderFlags
(
)
const
{
return
mDecoderFlags
;
}
void
SetSurfaceFlags
(
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mSurfaceFlags
=
aSurfaceFlags
;
}
SurfaceFlags
GetSurfaceFlags
(
)
const
{
return
mSurfaceFlags
;
}
bool
HasSize
(
)
const
{
return
mImageMetadata
.
HasSize
(
)
;
}
gfx
:
:
IntSize
Size
(
)
const
{
MOZ_ASSERT
(
HasSize
(
)
)
;
return
mImageMetadata
.
GetSize
(
)
;
}
gfx
:
:
IntRect
FullFrame
(
)
const
{
return
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
)
Size
(
)
)
;
}
gfx
:
:
IntRect
FullOutputFrame
(
)
const
{
return
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
)
OutputSize
(
)
)
;
}
DecoderFinalStatus
FinalStatus
(
)
const
;
const
ImageMetadata
&
GetImageMetadata
(
)
{
return
mImageMetadata
;
}
DecoderTelemetry
Telemetry
(
)
const
;
NotNull
<
RasterImage
*
>
GetImage
(
)
const
{
return
WrapNotNull
(
mImage
.
get
(
)
)
;
}
RasterImage
*
GetImageMaybeNull
(
)
const
{
return
mImage
.
get
(
)
;
}
RawAccessFrameRef
GetCurrentFrameRef
(
)
{
return
mCurrentFrame
?
mCurrentFrame
-
>
RawAccessRef
(
)
:
RawAccessFrameRef
(
)
;
}
protected
:
friend
class
AutoRecordDecoderTelemetry
;
friend
class
nsICODecoder
;
friend
class
PalettedSurfaceSink
;
friend
class
SurfaceSink
;
virtual
~
Decoder
(
)
;
virtual
nsresult
InitInternal
(
)
;
virtual
LexerResult
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
=
0
;
virtual
nsresult
BeforeFinishInternal
(
)
;
virtual
nsresult
FinishInternal
(
)
;
virtual
nsresult
FinishWithErrorInternal
(
)
;
virtual
Maybe
<
Telemetry
:
:
ID
>
SpeedHistogram
(
)
const
{
return
Nothing
(
)
;
}
void
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
=
Orientation
(
)
)
;
void
PostHasTransparency
(
)
;
void
PostIsAnimated
(
FrameTimeout
aFirstFrameTimeout
)
;
void
PostFrameStop
(
Opacity
aFrameOpacity
=
Opacity
:
:
SOME_TRANSPARENCY
DisposalMethod
aDisposalMethod
=
DisposalMethod
:
:
KEEP
FrameTimeout
aTimeout
=
FrameTimeout
:
:
Forever
(
)
BlendMethod
aBlendMethod
=
BlendMethod
:
:
OVER
const
Maybe
<
nsIntRect
>
&
aBlendRect
=
Nothing
(
)
)
;
void
PostInvalidation
(
const
gfx
:
:
IntRect
&
aRect
const
Maybe
<
gfx
:
:
IntRect
>
&
aRectAtOutputSize
=
Nothing
(
)
)
;
void
PostDecodeDone
(
int32_t
aLoopCount
=
0
)
;
nsresult
AllocateFrame
(
uint32_t
aFrameNum
const
gfx
:
:
IntSize
&
aOutputSize
const
gfx
:
:
IntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
=
0
)
;
private
:
void
PostError
(
)
;
void
CompleteDecode
(
)
;
uint32_t
GetCompleteFrameCount
(
)
{
if
(
mFrameCount
=
=
0
)
{
return
0
;
}
return
mInFrame
?
mFrameCount
-
1
:
mFrameCount
;
}
RawAccessFrameRef
AllocateFrameInternal
(
uint32_t
aFrameNum
const
gfx
:
:
IntSize
&
aOutputSize
const
gfx
:
:
IntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
imgFrame
*
aPreviousFrame
)
;
protected
:
Maybe
<
Downscaler
>
mDownscaler
;
uint8_t
*
mImageData
;
uint32_t
mImageDataLength
;
uint32_t
*
mColormap
;
uint32_t
mColormapSize
;
private
:
RefPtr
<
RasterImage
>
mImage
;
Maybe
<
SourceBufferIterator
>
mIterator
;
RawAccessFrameRef
mCurrentFrame
;
ImageMetadata
mImageMetadata
;
gfx
:
:
IntRect
mInvalidRect
;
Maybe
<
gfx
:
:
IntSize
>
mOutputSize
;
Progress
mProgress
;
uint32_t
mFrameCount
;
FrameTimeout
mLoopLength
;
gfx
:
:
IntRect
mFirstFrameRefreshArea
;
TimeDuration
mDecodeTime
;
DecoderFlags
mDecoderFlags
;
SurfaceFlags
mSurfaceFlags
;
bool
mInitialized
:
1
;
bool
mMetadataDecode
:
1
;
bool
mHaveExplicitOutputSize
:
1
;
bool
mInFrame
:
1
;
bool
mFinishedNewFrame
:
1
;
bool
mReachedTerminalState
:
1
;
bool
mDecodeDone
:
1
;
bool
mError
:
1
;
bool
mShouldReportError
:
1
;
}
;
}
}
#
endif
