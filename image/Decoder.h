#
ifndef
mozilla_image_Decoder_h
#
define
mozilla_image_Decoder_h
#
include
"
FrameAnimator
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
DecoderFlags
.
h
"
#
include
"
Downscaler
.
h
"
#
include
"
ImageMetadata
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
StreamingLexer
.
h
"
#
include
"
SurfaceFlags
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
enum
ID
:
uint32_t
;
}
namespace
image
{
class
Decoder
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Decoder
)
explicit
Decoder
(
RasterImage
*
aImage
)
;
nsresult
Init
(
)
;
nsresult
Decode
(
IResumable
*
aOnResume
=
nullptr
)
;
bool
ShouldSyncDecode
(
size_t
aByteLimit
)
;
nsIntRect
TakeInvalidRect
(
)
{
nsIntRect
invalidRect
=
mInvalidRect
;
mInvalidRect
.
SetEmpty
(
)
;
return
invalidRect
;
}
Progress
TakeProgress
(
)
{
Progress
progress
=
mProgress
;
mProgress
=
NoProgress
;
return
progress
;
}
bool
HasProgress
(
)
const
{
return
mProgress
!
=
NoProgress
|
|
!
mInvalidRect
.
IsEmpty
(
)
;
}
void
SetMetadataDecode
(
bool
aMetadataDecode
)
{
MOZ_ASSERT
(
!
mInitialized
"
Shouldn
'
t
be
initialized
yet
"
)
;
mMetadataDecode
=
aMetadataDecode
;
}
bool
IsMetadataDecode
(
)
const
{
return
mMetadataDecode
;
}
nsresult
SetTargetSize
(
const
gfx
:
:
IntSize
&
aSize
)
;
Maybe
<
gfx
:
:
IntSize
>
GetTargetSize
(
)
;
virtual
void
SetSampleSize
(
int
aSampleSize
)
{
}
void
SetIterator
(
SourceBufferIterator
&
&
aIterator
)
{
MOZ_ASSERT
(
!
mInitialized
"
Shouldn
'
t
be
initialized
yet
"
)
;
mIterator
.
emplace
(
Move
(
aIterator
)
)
;
}
bool
ShouldSendPartialInvalidations
(
)
const
{
return
!
(
mDecoderFlags
&
DecoderFlags
:
:
IS_REDECODE
)
;
}
bool
IsFirstFrameDecode
(
)
const
{
return
bool
(
mDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
;
}
size_t
BytesDecoded
(
)
const
{
MOZ_ASSERT
(
mIterator
)
;
return
mIterator
-
>
ByteCount
(
)
;
}
TimeDuration
DecodeTime
(
)
const
{
return
mDecodeTime
;
}
uint32_t
ChunkCount
(
)
const
{
MOZ_ASSERT
(
mIterator
)
;
return
mIterator
-
>
ChunkCount
(
)
;
}
uint32_t
GetFrameCount
(
)
{
return
mFrameCount
;
}
uint32_t
GetCompleteFrameCount
(
)
{
return
mInFrame
?
mFrameCount
-
1
:
mFrameCount
;
}
bool
HasAnimation
(
)
const
{
return
mImageMetadata
.
HasAnimation
(
)
;
}
bool
HasError
(
)
const
{
return
mError
;
}
bool
ShouldReportError
(
)
const
{
return
mShouldReportError
;
}
bool
GetDecodeDone
(
)
const
{
return
mReachedTerminalState
|
|
mDecodeDone
|
|
(
mMetadataDecode
&
&
HasSize
(
)
)
|
|
HasError
(
)
;
}
bool
InFrame
(
)
const
{
return
mInFrame
;
}
bool
ShouldUseSurfaceCache
(
)
const
{
return
bool
(
mImage
)
;
}
bool
WasAborted
(
)
const
{
return
mDecodeAborted
;
}
enum
DecodeStyle
{
PROGRESSIVE
SEQUENTIAL
}
;
void
SetDecoderFlags
(
DecoderFlags
aDecoderFlags
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mDecoderFlags
=
aDecoderFlags
;
}
DecoderFlags
GetDecoderFlags
(
)
const
{
return
mDecoderFlags
;
}
void
SetSurfaceFlags
(
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mSurfaceFlags
=
aSurfaceFlags
;
}
SurfaceFlags
GetSurfaceFlags
(
)
const
{
return
mSurfaceFlags
;
}
bool
HasSize
(
)
const
{
return
mImageMetadata
.
HasSize
(
)
;
}
nsIntSize
GetSize
(
)
const
{
MOZ_ASSERT
(
HasSize
(
)
)
;
return
mImageMetadata
.
GetSize
(
)
;
}
virtual
Telemetry
:
:
ID
SpeedHistogram
(
)
;
ImageMetadata
&
GetImageMetadata
(
)
{
return
mImageMetadata
;
}
RasterImage
*
GetImage
(
)
const
{
MOZ_ASSERT
(
mImage
)
;
return
mImage
.
get
(
)
;
}
RasterImage
*
GetImageMaybeNull
(
)
const
{
return
mImage
.
get
(
)
;
}
RawAccessFrameRef
GetCurrentFrameRef
(
)
{
return
mCurrentFrame
?
mCurrentFrame
-
>
RawAccessRef
(
)
:
RawAccessFrameRef
(
)
;
}
protected
:
friend
class
AutoRecordDecoderTelemetry
;
friend
class
nsICODecoder
;
friend
class
PalettedSurfaceSink
;
friend
class
SurfaceSink
;
virtual
~
Decoder
(
)
;
virtual
nsresult
InitInternal
(
)
;
virtual
LexerResult
DoDecode
(
SourceBufferIterator
&
aIterator
IResumable
*
aOnResume
)
=
0
;
virtual
nsresult
BeforeFinishInternal
(
)
;
virtual
nsresult
FinishInternal
(
)
;
virtual
nsresult
FinishWithErrorInternal
(
)
;
void
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
=
Orientation
(
)
)
;
void
PostHasTransparency
(
)
;
void
PostIsAnimated
(
int32_t
aFirstFrameTimeout
)
;
void
PostFrameStop
(
Opacity
aFrameOpacity
=
Opacity
:
:
SOME_TRANSPARENCY
DisposalMethod
aDisposalMethod
=
DisposalMethod
:
:
KEEP
int32_t
aTimeout
=
0
BlendMethod
aBlendMethod
=
BlendMethod
:
:
OVER
const
Maybe
<
nsIntRect
>
&
aBlendRect
=
Nothing
(
)
)
;
void
PostInvalidation
(
const
nsIntRect
&
aRect
const
Maybe
<
nsIntRect
>
&
aRectAtTargetSize
=
Nothing
(
)
)
;
void
PostDecodeDone
(
int32_t
aLoopCount
=
0
)
;
nsresult
AllocateFrame
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
=
0
)
;
nsresult
AllocateBasicFrame
(
)
{
nsIntSize
size
=
GetSize
(
)
;
return
AllocateFrame
(
0
size
nsIntRect
(
nsIntPoint
(
)
size
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
;
}
private
:
void
PostError
(
)
;
void
CompleteDecode
(
)
;
RawAccessFrameRef
AllocateFrameInternal
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
imgFrame
*
aPreviousFrame
)
;
protected
:
Maybe
<
Downscaler
>
mDownscaler
;
uint8_t
*
mImageData
;
uint32_t
mImageDataLength
;
uint32_t
*
mColormap
;
uint32_t
mColormapSize
;
private
:
RefPtr
<
RasterImage
>
mImage
;
Maybe
<
SourceBufferIterator
>
mIterator
;
RawAccessFrameRef
mCurrentFrame
;
ImageMetadata
mImageMetadata
;
nsIntRect
mInvalidRect
;
Progress
mProgress
;
uint32_t
mFrameCount
;
TimeDuration
mDecodeTime
;
DecoderFlags
mDecoderFlags
;
SurfaceFlags
mSurfaceFlags
;
bool
mInitialized
:
1
;
bool
mMetadataDecode
:
1
;
bool
mInFrame
:
1
;
bool
mReachedTerminalState
:
1
;
bool
mDecodeDone
:
1
;
bool
mError
:
1
;
bool
mDecodeAborted
:
1
;
bool
mShouldReportError
:
1
;
}
;
}
}
#
endif
