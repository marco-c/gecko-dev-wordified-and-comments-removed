#
ifndef
mozilla_image_Decoder_h
#
define
mozilla_image_Decoder_h
#
include
"
FrameAnimator
.
h
"
#
include
"
RasterImage
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
DecodePool
.
h
"
#
include
"
DecoderFlags
.
h
"
#
include
"
ImageMetadata
.
h
"
#
include
"
Orientation
.
h
"
#
include
"
SourceBuffer
.
h
"
#
include
"
SurfaceFlags
.
h
"
namespace
mozilla
{
namespace
Telemetry
{
enum
ID
:
uint32_t
;
}
namespace
image
{
class
Decoder
:
public
IResumable
{
public
:
explicit
Decoder
(
RasterImage
*
aImage
)
;
void
Init
(
)
;
nsresult
Decode
(
)
;
bool
ShouldSyncDecode
(
size_t
aByteLimit
)
;
nsIntRect
TakeInvalidRect
(
)
{
nsIntRect
invalidRect
=
mInvalidRect
;
mInvalidRect
.
SetEmpty
(
)
;
return
invalidRect
;
}
Progress
TakeProgress
(
)
{
Progress
progress
=
mProgress
;
mProgress
=
NoProgress
;
return
progress
;
}
bool
HasProgress
(
)
const
{
return
mProgress
!
=
NoProgress
|
|
!
mInvalidRect
.
IsEmpty
(
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Decoder
override
)
virtual
void
Resume
(
)
override
;
void
SetMetadataDecode
(
bool
aMetadataDecode
)
{
MOZ_ASSERT
(
!
mInitialized
"
Shouldn
'
t
be
initialized
yet
"
)
;
mMetadataDecode
=
aMetadataDecode
;
}
bool
IsMetadataDecode
(
)
const
{
return
mMetadataDecode
;
}
virtual
nsresult
SetTargetSize
(
const
nsIntSize
&
aSize
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
virtual
void
SetSampleSize
(
int
aSampleSize
)
{
}
virtual
void
SetResolution
(
const
gfx
:
:
IntSize
&
aResolution
)
{
}
void
SetIterator
(
SourceBufferIterator
&
&
aIterator
)
{
MOZ_ASSERT
(
!
mInitialized
"
Shouldn
'
t
be
initialized
yet
"
)
;
mIterator
.
emplace
(
Move
(
aIterator
)
)
;
}
bool
ShouldSendPartialInvalidations
(
)
const
{
return
!
(
mDecoderFlags
&
DecoderFlags
:
:
IS_REDECODE
)
;
}
bool
IsFirstFrameDecode
(
)
const
{
return
bool
(
mDecoderFlags
&
DecoderFlags
:
:
FIRST_FRAME_ONLY
)
;
}
size_t
BytesDecoded
(
)
const
{
return
mBytesDecoded
;
}
TimeDuration
DecodeTime
(
)
const
{
return
mDecodeTime
;
}
uint32_t
ChunkCount
(
)
const
{
return
mChunkCount
;
}
uint32_t
GetFrameCount
(
)
{
return
mFrameCount
;
}
uint32_t
GetCompleteFrameCount
(
)
{
return
mInFrame
?
mFrameCount
-
1
:
mFrameCount
;
}
bool
HasAnimation
(
)
const
{
return
mImageMetadata
.
HasAnimation
(
)
;
}
bool
HasError
(
)
const
{
return
HasDataError
(
)
|
|
HasDecoderError
(
)
;
}
bool
HasDataError
(
)
const
{
return
mDataError
;
}
bool
HasDecoderError
(
)
const
{
return
NS_FAILED
(
mFailCode
)
;
}
bool
ShouldReportError
(
)
const
{
return
mShouldReportError
;
}
nsresult
GetDecoderError
(
)
const
{
return
mFailCode
;
}
void
PostResizeError
(
)
{
PostDataError
(
)
;
}
bool
GetDecodeDone
(
)
const
{
return
mDecodeDone
|
|
(
mMetadataDecode
&
&
HasSize
(
)
)
|
|
HasError
(
)
|
|
mDataDone
;
}
bool
GetDecodeTotallyDone
(
)
const
{
return
mDecodeDone
&
&
!
IsMetadataDecode
(
)
;
}
bool
InFrame
(
)
const
{
return
mInFrame
;
}
bool
ShouldUseSurfaceCache
(
)
const
{
return
bool
(
mImage
)
;
}
bool
WasAborted
(
)
const
{
return
mDecodeAborted
;
}
enum
DecodeStyle
{
PROGRESSIVE
SEQUENTIAL
}
;
void
SetDecoderFlags
(
DecoderFlags
aDecoderFlags
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mDecoderFlags
=
aDecoderFlags
;
}
DecoderFlags
GetDecoderFlags
(
)
const
{
return
mDecoderFlags
;
}
void
SetSurfaceFlags
(
SurfaceFlags
aSurfaceFlags
)
{
MOZ_ASSERT
(
!
mInitialized
)
;
mSurfaceFlags
=
aSurfaceFlags
;
}
SurfaceFlags
GetSurfaceFlags
(
)
const
{
return
mSurfaceFlags
;
}
bool
HasSize
(
)
const
{
return
mImageMetadata
.
HasSize
(
)
;
}
nsIntSize
GetSize
(
)
const
{
MOZ_ASSERT
(
HasSize
(
)
)
;
return
mImageMetadata
.
GetSize
(
)
;
}
virtual
Telemetry
:
:
ID
SpeedHistogram
(
)
;
ImageMetadata
&
GetImageMetadata
(
)
{
return
mImageMetadata
;
}
RasterImage
*
GetImage
(
)
const
{
MOZ_ASSERT
(
mImage
)
;
return
mImage
.
get
(
)
;
}
RawAccessFrameRef
GetCurrentFrameRef
(
)
{
return
mCurrentFrame
?
mCurrentFrame
-
>
RawAccessRef
(
)
:
RawAccessFrameRef
(
)
;
}
void
Write
(
const
char
*
aBuffer
uint32_t
aCount
)
;
protected
:
friend
class
nsICODecoder
;
virtual
~
Decoder
(
)
;
virtual
void
InitInternal
(
)
;
virtual
void
WriteInternal
(
const
char
*
aBuffer
uint32_t
aCount
)
=
0
;
virtual
void
FinishInternal
(
)
;
virtual
void
FinishWithErrorInternal
(
)
;
void
PostSize
(
int32_t
aWidth
int32_t
aHeight
Orientation
aOrientation
=
Orientation
(
)
)
;
void
PostHasTransparency
(
)
;
void
PostIsAnimated
(
int32_t
aFirstFrameTimeout
)
;
void
PostFrameStop
(
Opacity
aFrameOpacity
=
Opacity
:
:
SOME_TRANSPARENCY
DisposalMethod
aDisposalMethod
=
DisposalMethod
:
:
KEEP
int32_t
aTimeout
=
0
BlendMethod
aBlendMethod
=
BlendMethod
:
:
OVER
)
;
void
PostInvalidation
(
const
nsIntRect
&
aRect
const
Maybe
<
nsIntRect
>
&
aRectAtTargetSize
=
Nothing
(
)
)
;
void
PostDecodeDone
(
int32_t
aLoopCount
=
0
)
;
void
PostDataError
(
)
;
void
PostDecoderError
(
nsresult
aFailCode
)
;
void
CompleteDecode
(
)
;
nsresult
AllocateFrame
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
=
0
)
;
nsresult
AllocateBasicFrame
(
)
{
nsIntSize
size
=
GetSize
(
)
;
return
AllocateFrame
(
0
size
nsIntRect
(
nsIntPoint
(
)
size
)
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
)
;
}
RawAccessFrameRef
AllocateFrameInternal
(
uint32_t
aFrameNum
const
nsIntSize
&
aTargetSize
const
nsIntRect
&
aFrameRect
gfx
:
:
SurfaceFormat
aFormat
uint8_t
aPaletteDepth
imgFrame
*
aPreviousFrame
)
;
protected
:
uint8_t
*
mImageData
;
uint32_t
mImageDataLength
;
uint32_t
*
mColormap
;
uint32_t
mColormapSize
;
private
:
nsRefPtr
<
RasterImage
>
mImage
;
Maybe
<
SourceBufferIterator
>
mIterator
;
RawAccessFrameRef
mCurrentFrame
;
ImageMetadata
mImageMetadata
;
nsIntRect
mInvalidRect
;
Progress
mProgress
;
uint32_t
mFrameCount
;
nsresult
mFailCode
;
TimeDuration
mDecodeTime
;
uint32_t
mChunkCount
;
DecoderFlags
mDecoderFlags
;
SurfaceFlags
mSurfaceFlags
;
size_t
mBytesDecoded
;
bool
mInitialized
:
1
;
bool
mMetadataDecode
:
1
;
bool
mInFrame
:
1
;
bool
mDataDone
:
1
;
bool
mDecodeDone
:
1
;
bool
mDataError
:
1
;
bool
mDecodeAborted
:
1
;
bool
mShouldReportError
:
1
;
}
;
}
}
#
endif
